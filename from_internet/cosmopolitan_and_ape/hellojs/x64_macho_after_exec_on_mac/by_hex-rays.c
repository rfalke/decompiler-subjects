/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2);
__int64 __fastcall sub_400748(int, int);
void __fastcall __noreturn sub_401000(__int64, __int64, __int64);
__int64 __fastcall sub_401158(unsigned __int64, int, __int64, __int64 *);
__int64 sub_40126D();
void __fastcall sub_4012F0();
__int64 __fastcall sub_4015A2(__m128, __m128);
__int64 sub_4017C2();
void __fastcall sub_4017E5(__int64, __int64);
__int64 __fastcall sub_401839(__int64, int *, __int64, __int64);
__int64 __fastcall sub_401866(__int64, __int64, __int64);
__int64 __fastcall sub_4018BB(__int64, __int64, __int64, __int64);
void __fastcall sub_401958(int *);
__int64 __fastcall sub_401A89(_QWORD *, unsigned __int8 *, __int64, int);
char __fastcall sub_401AB7(_BYTE *, char *);
__int64 __fastcall sub_401AC8(__int64 *);
void __fastcall __noreturn sub_401AEB(unsigned int, __int64, __int64);
__int64 __fastcall sub_401B04(__int64 *, __int64, __m128, __m128);
__int64 sub_401B75(__int64 *, __int64, unsigned int, _BYTE *, ...);
__int64 __fastcall sub_401C42(__int64 *a1, __int64 a2, unsigned int a3, const char *a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_401C60(__int64 *a1, __int64 a2, int a3, int a4, const char *a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_401CB7(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_401CC7(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_401CD7(__int64 *a1, __int64 a2, int a3, const char *a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_401CE2(__int64 *a1, __int64 a2, int a3, const char *a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_401CED(__int64 *, __int64, int, int);
__int64 __fastcall sub_401D02(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_401D12(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_401D22(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_401D32(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5);
void __fastcall __noreturn sub_401D42(__int64, __int64, __int64);
void __fastcall sub_401D4B(__int64, __m128, __m128);
__int64 __fastcall sub_401EA7(__int64 *, __int128 *, __int128 *, __m128, __m128);
void __fastcall __noreturn sub_401F78(__int64, __int64);
void __fastcall __noreturn sub_401F82(__int64, __int64);
__int64 __fastcall sub_401F8C(__int64, __int64, const char *);
void __fastcall __noreturn sub_401FE8(__int64, __int64, __int64);
__int64 __fastcall sub_40200C(__int64, __int64);
__int64 sub_4020AC();
__int64 sub_4020BC();
__int64 sub_4020CC();
__int64 sub_4020DC();
__int64 sub_4020EC();
__int64 sub_4020FC();
__int64 sub_40210C();
__int64 sub_40211C();
__int64 sub_40212C();
__int64 sub_40213C();
__int64 sub_40214C();
__int64 sub_40215C();
__int64 sub_40216C();
__int64 __fastcall sub_40217D(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_40241F(unsigned __int16 **);
unsigned __int64 __fastcall sub_40244A(__int64, unsigned int);
__int64 __fastcall sub_40247A(unsigned __int16 *, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_402687(__int64, __int64, __int64);
__int64 __fastcall sub_402713(__int64, __int64);
__int64 __fastcall sub_40287E(_BYTE *, __int64);
unsigned __int64 __fastcall sub_402993(_BYTE *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_402B09(_QWORD *, __int64 *, __int64, __int64);
__int64 __fastcall sub_402B93(_QWORD *, __int64 *, __int64, __int64);
__int64 __fastcall sub_402C35(_BYTE *, __int64, _WORD *);
__int64 __fastcall sub_402D09(__int64, __int64);
_BYTE *__fastcall sub_402D2E(_BYTE *);
__int64 __fastcall sub_402DA8(__int64, __int64, __int64);
__int64 __fastcall sub_402DC1(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_402DD7(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_402DED(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_402E03(__int64, __int64, __int64, __int64);
__int64 sub_402E19();
__int64 sub_402E2F();
void sub_402E45();
void sub_402E5B();
__int64 __fastcall sub_402E71(__int64, __int64, __int64);
__int64 sub_402E8A();
__int64 __fastcall sub_402EA0(__int64, __int64, __int64);
__int64 __fastcall sub_402EB9(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_402ECF(__int64, __int64, __int64);
__int64 __fastcall sub_402F19(__int64, __int64, __m128, __m128);
void __fastcall sub_402F7A(__int64, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_402FA0(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
void __fastcall sub_402FE5(__int64 *a1, unsigned __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40303B(__int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_4030A6(__int64, __int64 (__fastcall *)(__int64, __int64), __int64, __int64, __m128, __m128);
__int64 __fastcall sub_403142(__int64);
__int64 __fastcall sub_40314F(__int64, __int64, __int64, int);
__int64 __fastcall sub_403189(__int64 *, __m128);
__int64 __fastcall sub_4031E2(__int64 *, __m128, __m128, __int64, __int64);
__int64 __fastcall sub_40323B(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_403319(__int64 *, __int64, __int64, int, __m128, __m128);
__int64 __fastcall sub_40338B(__int64 *, __int64, __int64, int, __m128, __m128);
__int64 __fastcall sub_4033EA(__int64 (__fastcall *)(__int64, __int64), __int64 (__fastcall *)(), __int64 (__fastcall *)(), __int64, void (__fastcall __noreturn *)(__int64 a1, __int64 a2, __int64 a3), __m128, __m128);
__int64 __fastcall sub_403420(__int64, __m128, __m128);
__int64 __fastcall sub_4035A2(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_403616(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_40365C(__int64 *, int, __int64, __m128, __m128);
__int64 __fastcall sub_403690(__int64 *, int, __int64, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_4036CF(__int64 *a1, int a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_40370E(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_403745(__int64 *, int, unsigned int *, __m128, __m128);
__int64 __fastcall sub_40377C(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_4037B9(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_4037C1(__int64 *a1, int a2, unsigned int a3, _DWORD *a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_4037EC(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_403846(__int64 *, int, unsigned int, __m128, __m128);
__int64 __fastcall sub_403883(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_40388B(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_403895(__int64 *, int, __int64, __m128, __m128);
__int64 __fastcall sub_4038CF(__int64 *, int, __int64, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_403911(__int64 *, int, __int64, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_403953(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40398D(__int64 *, int, unsigned int *, __m128, __m128);
__int64 __fastcall sub_4039C7(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_403A07(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_403A0F(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_403B1D(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_403BC8(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_403CC0(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_403D2E(__int64 *, int, unsigned int, __m128, __m128);
__int64 __fastcall sub_403D6B(__int64 *, int, char, __m128, __m128);
__int64 __fastcall sub_403DB2(__int64 *, int, unsigned int, int, __m128, __m128);
__int64 __fastcall sub_403DDC(__int64 *, int, unsigned int, char, __m128, __m128);
__int64 __fastcall sub_403E13(__int64 *, int, __m128, __m128);
void __fastcall sub_403E24(__int64 *, int, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_403E29(__int64 *, int, __int16, __m128, __m128);
__int64 __fastcall sub_403F77(__int64 *, int, unsigned int, __m128, __m128);
__int64 __fastcall sub_403FC8(_QWORD *, int, __m128, __m128);
__int64 __fastcall sub_403FED(_QWORD *, __m128, __m128);
__int64 __fastcall sub_403FF2(__int64 *, int, unsigned int, __m128, __m128);
__int64 __fastcall sub_404025(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_40405C(_QWORD *, int, int, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_4042B7(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_404413(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40447B(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4044A5(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4044EE(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_404524(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40452E(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_404583(__int64, int);
__int64 __fastcall sub_40459D(__int64, _DWORD *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40460F(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_404639(__int64, __int64, __int64, __int64, __m128, __m128);
_OWORD *__fastcall sub_40469E(_QWORD *, int, __m128, __m128);
__int64 __fastcall sub_40472D(_QWORD *, __int64, unsigned int, int, unsigned int, __m128, __m128);
__int64 __fastcall sub_4047ED(__int64, int);
__int64 __fastcall sub_40480A(__int64 *, int);
__int64 __fastcall sub_40483D(__int64, int);
__int64 *__fastcall sub_404863(__int64, int);
__int64 __fastcall sub_404878(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4048FE(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_404982(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_4049F5(__int64, int);
__int64 __fastcall sub_404A12(__int64 *a1, int a2);
__int64 __fastcall sub_404A4F(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_404AC6(__int64 *, int);
__int64 __fastcall sub_404AE7(__int64);
__int64 __fastcall sub_404AF4(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_404B20(_QWORD *, unsigned int, __m128, __m128);
__int64 __fastcall sub_404BCC(__int64, unsigned int, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_404C48(__int64, unsigned int, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_404C73(__int64);
__int64 __fastcall sub_404C89(__int64);
__int64 __fastcall sub_404C98(__int64 *);
unsigned __int64 __fastcall sub_404CC3(__int64 *, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_404D56(_QWORD *, unsigned __int64, __m128, __m128);
unsigned __int64 __fastcall sub_404DC3(_QWORD *, int, __m128, __m128);
__int64 __fastcall sub_404E0C(_QWORD *, int, __m128, __m128);
unsigned __int64 __fastcall sub_404E3A(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_404EC4(__int64 *a1, int a2, int a3);
__int64 __fastcall sub_404F05(__int64 *a1, int a2);
_QWORD *__fastcall sub_404F0A(__int64 *a1, int a2, __m128 a3, __m128 a4);
_QWORD *__fastcall sub_404F67(__int64 *, __m128, __m128);
_QWORD *__fastcall sub_404FD6(__int64 *a1, __m128 a2, __m128 a3);
_QWORD *__fastcall sub_404FDD(__int64 *a1, __m128 a2, __m128 a3);
_QWORD *__fastcall sub_404FE7(__int64 *a1, __m128 a2, __m128 a3);
_QWORD *__fastcall sub_404FF1(__int64 *a1, __m128 a2, __m128 a3);
_QWORD *__fastcall sub_404FFB(__int64 *a1, __m128 a2, __m128 a3);
_QWORD *__fastcall sub_405005(__int64 *a1, __m128 a2, __m128 a3);
void __fastcall sub_40500F(__int64 *a1, int a2);
__int64 __fastcall sub_405057(__int64 *a1, int a2, __int64 a3, __int64 a4, double a5, __m128 a6);
__int64 __fastcall sub_4050B6(__int64 *a1, int a2, int a3, __int64 a4, __m128 a5, __m128 a6);
void __fastcall sub_40511F(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40517F(_QWORD, _QWORD, _QWORD, _QWORD); // weak
void __fastcall sub_405181(__int64 *a1, __m128 a2, __m128 a3);
_DWORD *__fastcall sub_405188(__int64, int, __int64, __int64, __m128, __m128);
_DWORD *__fastcall sub_405227(__int64, int, __int64, __int64, __m128, __m128);
void __fastcall sub_405305(__int64, int, int);
void __fastcall sub_405335(__int64, int, int);
__int64 __fastcall sub_4053B6(__int64, int);
double __fastcall sub_40541C(__int64, int);
double __fastcall sub_40544E(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405483(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40548C(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4054AF(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 *__fastcall sub_4054BB(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40554E(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_405563(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_405573(__int64 *a1, int a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6, __m128 xmm0_8_0, __m128 a8, _DWORD *a9);
__int64 __fastcall sub_40564B(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_405672(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40568B(__int64, int);
__int64 __fastcall sub_405695(__int64, int);
__int64 __fastcall sub_4056B9(__int64, int);
_DWORD *__fastcall sub_405717(__int64, int);
_DWORD *__fastcall sub_40573B(__int64, int);
__int64 __fastcall sub_40574F(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40578B(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_4057AC(__int64 *a1, int a2, __m128 a3, __m128 a4);
const signed __int32 *__fastcall sub_4057BB(__int64 *a1, int a2, __m128 a3, __m128 a4);
const signed __int32 *__fastcall sub_4057F3(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_405823(__int64, int);
__int64 __fastcall sub_40582D(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405869(__int64, int);
__int64 __fastcall sub_405873(__int64 *a1, int a2, __m128 a3, __m128 a4);
_DWORD *__fastcall sub_4058AF(__int64, int);
_DWORD *__fastcall sub_4058D5(__int64 *a1, int a2, __m128 a3, __m128 a4);
const signed __int32 *__fastcall sub_405991(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4059C9(__int64, int);
__int64 __fastcall sub_405A5E(__int64, int);
_DWORD *__fastcall sub_405AC3(__int64, int);
_DWORD *__fastcall sub_405AEC(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405B3C(__int64, int);
__int64 __fastcall sub_405B41(__int64, int);
__int64 __fastcall sub_405B46(__int64, int);
__int64 __fastcall sub_405B50(__int64, int);
unsigned int *__fastcall sub_405B55(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405BBB(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405C10(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_405C43(__int64 *, int, __m128, __m128);
double __fastcall sub_405CAB(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_405CB0(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_405D63(__int64 *, __m128, __m128);
__int64 __fastcall sub_405D6D(__int64 *a1, __int64 *a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_405DB7(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405DDC(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405E01(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405E64(__int64 *a1, int a2, __m128 a3, __m128 a4);
char __fastcall sub_405F30(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_405FB5(__int64 *a1, int a2, int a3, int a4, int *a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_406077(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_40608A(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_406092(unsigned int *);
__int64 __fastcall sub_40609C(__int64, int);
__int64 __fastcall sub_4060B0(__int64, int);
_BOOL8 __fastcall sub_4060E2(__int64, int);
__int64 __fastcall sub_4060F9(unsigned int *);
__int64 __fastcall sub_406103(__int64, int);
__int64 __fastcall sub_406117(__int64 *a1, int a2, __m128 a3, __m128 a4);
_BOOL8 __fastcall sub_40649F(__int64, int);
_BOOL8 __fastcall sub_4064B3(__int64, int);
_BOOL8 __fastcall sub_4064DB(__int64, int);
__int64 __fastcall sub_4064EF(__int64, int);
_BOOL8 __fastcall sub_406515(__int64, int);
_BOOL8 __fastcall sub_406529(__int64, int);
_BOOL8 __fastcall sub_40653D(__int64, int);
_BOOL8 __fastcall sub_406551(__int64, int);
__int64 __fastcall sub_406565(__int64, int);
__int64 __fastcall sub_4065BA(__int64, int);
_BOOL8 __fastcall sub_4065D7(__int64, int);
_BOOL8 __fastcall sub_4065F2(__int64, int);
__int64 __fastcall sub_40661B(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_406646(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5);
_BOOL8 __fastcall sub_4066B4(__int64, __int64);
_BOOL8 __fastcall sub_4066D3(__int64, int);
__int64 __fastcall sub_406883(__int64 *a1, __int128 *a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4068D1(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
void __fastcall sub_4068FC(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40691D(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
_DWORD *__fastcall sub_406955(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40699D(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_4069DC(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_406A1B(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_406A68(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_406AAF(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_406AF7(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_406B26(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406B69(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406BF4(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_406C45(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406D71(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406DB4(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_406EB2(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406EBC(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
int *__fastcall sub_406EC3(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_406F18(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_406F59(__int64 *, int, __m128, __m128);
_OWORD *__fastcall sub_406FB2(_QWORD *, __m128, __m128);
_OWORD *__fastcall sub_406FB9(_QWORD *, __m128, __m128);
__int64 __fastcall sub_406FC3(__int64);
__int64 __fastcall sub_406FCC(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5);
int *__fastcall sub_407003(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
int *__fastcall sub_407074(__int64 *a1, int a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_407095(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_4070BA(_QWORD *, __m128, __m128);
__int64 __fastcall sub_407108(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_407143(_QWORD *, __m128, __m128);
__int64 __fastcall sub_40715D(_QWORD *, unsigned int, __m128, __m128);
__int64 __fastcall sub_407199(_QWORD *, unsigned int, __m128, __m128);
__int64 __fastcall sub_4071BC(_QWORD *, char, __m128, __m128);
int *__fastcall sub_407292(_QWORD *, __m128, __m128);
__int64 __fastcall sub_407318(__int64 *, __m128, __m128);
__int64 __fastcall sub_40738C(_QWORD *, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_40739C(_QWORD *, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_4073AC(_QWORD *, __int64, unsigned int, __m128, __m128);
int *__fastcall sub_40746B(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
int *__fastcall sub_4074D7(__int64 *a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_40762B(__int64 *, unsigned __int64, char, __m128, __m128);
__int64 __fastcall sub_4076DF(__int64 *, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_4076E9(__int64 *, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_4076F0(__int64 *, unsigned int *, __m128, __m128);
__int64 __fastcall sub_40779C(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_407808(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_407826(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_407835(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_407963(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_407973(__int64 *, _BYTE *, _DWORD *, __m128, __m128);
__int64 sub_407AA3(__int64 *, _BYTE *, ...);
__int64 __fastcall sub_407B29(__int64 *, int, __int64, int, _BYTE *, _DWORD *, __m128, __m128);
__int64 sub_407BD4(__int64 *, int, __int64, int, _BYTE *, ...);
__int64 __fastcall sub_407C45(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_407C63(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_407CCF(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_407CED(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_407CFD(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_407D1C(__int64 *a1, _DWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_407D45(__int64, _DWORD *, __int64, __int64, __m128, __m128);
_DWORD *__fastcall sub_407D4A(__int64, int);
__int64 __fastcall sub_407D7E(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_407DA1(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_407DA6(__int64);
void __fastcall sub_407DBA(__int64);
__int64 __fastcall sub_407DC0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_407DE7(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_407DF2(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_407DFC(__int64, __int64, __int64, __int64, __m128, __m128);
_DWORD *__fastcall sub_407E10(_QWORD *, unsigned int, __m128, __m128);
__int64 __fastcall sub_407E9B(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408001(__int64 *, __int64, __m128, __m128);
void __fastcall __noreturn sub_408053(__int64);
__int64 sub_40807C(__int64 *, __int64, __int64, int, _BYTE *, ...);
__int64 __fastcall sub_408133(__int64, int, __m128, __m128);
__int64 __fastcall sub_40816B(__int64, int, __m128, __m128);
__int64 __fastcall sub_4081DD(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_408233(__int64 *, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_408290(__int64 *a1, int a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_408411(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8);
__int64 __fastcall sub_408432(__int64 *, int, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_408491(__int64 *, int, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_408496(__int64 *, int, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40849B(__int64 *, __m128, __m128, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_408553(__int64 *, int, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_4085AE(__int64 *, __int128 *, int, double, __m128);
__int64 __fastcall sub_40869C(__int64 *, __m128, __m128);
__int64 __fastcall sub_4086BF(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_4086CB(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_408725(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408821(__int64 *, int, _QWORD *, __m128, __m128);
__int64 __fastcall sub_40884A(__int64 *a1, int a2, _QWORD *a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_408916(__int64 *, __m128, __m128);
__int64 __fastcall sub_408929(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408985(__int64 *, __m128, __m128);
__int64 __fastcall sub_408998(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_4089B9(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4089F1(__int64 *, __m128, __m128);
__int64 __fastcall sub_4089F6(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408A0E(__int64 *, __m128, __m128);
const signed __int32 *__fastcall sub_408A2B(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408A51(__int64 *, __int64, int, __m128, __m128);
__int64 __fastcall sub_408C16(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_408C1D(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_408C2C(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_408C36(__int64 *, __int64, __m128, __m128);
void __fastcall sub_408C9E(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_408CCE(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_408E52(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408E59(__int64 *, __m128, __m128);
__int64 __fastcall sub_408F0F(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_408F19(__int64 *a1, int a2, __int64 (__fastcall *a3)(__int64, _QWORD), __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_409057(__int64 *a1, int a2, unsigned __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_4090EA(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_409239(__int64 *, __m128, __m128);
const signed __int32 *__fastcall sub_4093B8(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_409409(__int64 *, char, __m128, __m128);
__int64 __fastcall sub_4094BB(__int64 *, __m128, __m128);
__int64 __fastcall sub_4094C5(__int64 *a1, _DWORD *a2, int *a3, _DWORD *a4, int a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_409572(__int64 *a1, int a2, char a3, _DWORD *a4, _DWORD *a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_409619(__int64 *a1, int a2, int *a3, _DWORD *a4, __int64 a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_40967D(__int64 *a1, int a2, __m128 a3, __m128 a4);
void __fastcall sub_4096A4(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_4096D9(__int64, __int64, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_409749(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_40AF4D(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B00C(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B041(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B07A(__int64 *, int, __int64);
__int64 __fastcall sub_40B11C(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B151(__int64 *, int *, __m128, __m128);
__int64 __fastcall sub_40B3E1(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_40B3EE(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_40B408(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B4EE(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B5D1(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B627(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B645(__int64 *, __m128, __m128);
__int64 __fastcall sub_40B66B(__int64 *a1, unsigned int a2, __int64 a3, __m128 a4, __m128 a5);
char *__fastcall sub_40B6EA(__int64 *a1, __int64 a2, __int64 a3, int a4, char a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_40B994(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40B99E(__int64 *, __m128, __m128);
__int64 __fastcall sub_40BA08(_QWORD *, int);
__int64 __fastcall sub_40BA4F(__int64, int, __int64);
__int64 __fastcall sub_40BA70(__int64 *, int, const char *, __int64, int, __m128, __m128);
__int64 __fastcall sub_40BB4A(__int64 *, int);
__int64 __fastcall sub_40BB67(__int64, unsigned __int64, char, _QWORD *, __m128, __m128);
__int64 __fastcall sub_40BC90(__int64, __int64);
__int64 __fastcall sub_40BC95(__int64, unsigned int);
__int64 __fastcall sub_40BCB5(__int64, unsigned int *);
__int64 __fastcall sub_40BD49(__int64, _DWORD *);
__int64 __fastcall sub_40BD82(__int64);
__int64 __fastcall sub_40BD87(__int64, unsigned int *);
__int64 __fastcall sub_40BD9E(__int64);
__int64 __fastcall sub_40BDF0(__int64, __m128, __m128);
__int64 __fastcall sub_40BF33(__int64 (__fastcall *)(__int64, __int64), __m128, __m128, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_40C1D2(__int64, __m128, __m128);
__int64 __fastcall sub_40C214(__int64, int *, __m128, __m128, __int64, __int64);
__int64 __fastcall sub_40C261(__int64, __m128, __m128, __int64, __int64, __int64);
void __fastcall sub_40C30F(_DWORD *, int *);
void __fastcall sub_40C5C6(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_40C5DA(_QWORD *, __m128, __m128);
__int64 __fastcall sub_40C5FE(_QWORD *, __int64, __m128, __m128);
__int64 __fastcall sub_40C646(unsigned int *);
__int64 __fastcall sub_40C6B4(__int64, int, __m128, __m128);
__int64 __fastcall sub_40C9D7(__int64, __int64);
__int64 __fastcall sub_40C9F5(__int64, __int64);
__int64 __fastcall sub_40CA16(__int64, __int64);
__int64 __fastcall sub_40CA34(__int64, __int64);
__int64 __fastcall sub_40CA54(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_40CA67(__int64, __int64);
__int64 __fastcall sub_40CAA6(__int64, _DWORD *);
__int64 __fastcall sub_40CAE2(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CAF7(__int64, unsigned int *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CEAE(__int64, unsigned int *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CEB9(__int64, __int64, int, __int64, __m128, __m128);
__int64 __fastcall sub_40CFCD(__int64, _DWORD *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CFD5(__int64, _DWORD *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CFE0(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40CFF2(__int64, __int64);
__int64 __fastcall sub_40D015(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_40D1BA(__int64, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_40D302(__int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_40D33F(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5);
int *__fastcall sub_40D37C(__int64 *a1, __int64 a2, __int16 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40D3CE(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40D40B(__int64, __int64);
__int64 __fastcall sub_40D44A(__int64, __int64, __int64);
void __fastcall sub_40D473(__int64, __m128, __m128);
__int64 __fastcall sub_40D483(__int64);
int *__fastcall sub_40D4DB(__int64 *a1, int a2, unsigned __int64 a3, __m128 a4, __m128 a5);
void __fastcall sub_40D513(__int64, int, __m128, __m128);
int *__fastcall sub_40D551(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D558(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D562(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40D56C(__int64, int, __m128, __m128);
int *__fastcall sub_40D5C7(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40D5D1(__int64, int, __m128, __m128);
__int64 __fastcall sub_40D625(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D662(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D66C(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D676(__int64 *a1, int a2, __m128 a3, __m128 a4);
int *__fastcall sub_40D680(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40D68A(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_40D6B2(__int64, int, int);
__int64 __fastcall sub_40D757(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_40DAF3(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_40DC2D(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_40DCA3(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_40DCFB(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40DD1E(unsigned int);
__int64 __fastcall sub_40DD3B(__int64);
__int64 __fastcall sub_40DD65(__int64, _DWORD *, _DWORD *);
__int64 __fastcall sub_40DDAB(double);
__int64 __fastcall sub_40DDDC(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_40DE49(__int64 *, __int64 *, __m128, __m128);
__int64 __fastcall sub_40DE74(__int64 *, __int128 *, __int64 *, __m128, __m128);
__int64 __fastcall sub_40DE9A(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_40DEB7(__int64 *a1, __int64 a2, int a3, __int64 a4, _QWORD *a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_40DF43(__int64);
__int64 __fastcall sub_40DF53(_QWORD *, __int64, unsigned int, unsigned int, unsigned int, int, __m128, __m128);
__int64 __fastcall sub_40E25B(_QWORD *, __int64, __m128, __m128);
__int64 __fastcall sub_40E2DD(_QWORD *, unsigned int, __int64, __m128, __m128);
__int64 __fastcall sub_40E3BE(__int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40E495(_QWORD *, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_40E4C4(_QWORD *, __int64, __m128, __m128);
__int64 __fastcall sub_40E53D(__int64, __int64, __int64, unsigned int *, unsigned int *);
__int64 __fastcall sub_40E5DF(__int64, __int64, __int64);
__int64 __fastcall sub_40E629(__int64, __int64, unsigned int);
__int64 __fastcall sub_40E635(__int64, __int64, __int64, _DWORD *);
__int64 __fastcall sub_40E68B(__int64, __int64, unsigned int);
__int64 __fastcall sub_40E6B8(__int64, __int64);
__int64 __fastcall sub_40E6C2(__int64, __int64);
__int64 __fastcall sub_40E6D6(__int64, __int64);
__int64 __fastcall sub_40E6FC(__int64, __int64);
__int64 __fastcall sub_40E722(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, char a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_40E733(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 *a6, __m128 a7, __m128 a8);
__int64 __fastcall sub_40E804(__int64 *, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_40E863(__int64 *, __int64, __int64, unsigned int, __int64, char, __m128, __m128);
__int64 __fastcall sub_40EC01(__int64 *, __int128 *, __m128 *, __m128);
__int64 __fastcall sub_40F1DF(__int64 *, int *, __int128 *, double, __m128);
__int64 __fastcall sub_40F3D3(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_40F441(__int64 *, __int64, __int64, char, __m128, __m128);
_BOOL8 __fastcall sub_40F669(__int64 *, __int64, unsigned int, unsigned int, int, unsigned int *, __m128, __m128);
__int64 __fastcall sub_40F7B6(__int64 *, __int64 *, __m128 *, __int128 *, unsigned int, __m128);
__int64 __fastcall sub_41018F(__int64 *, __int128 *, __int128 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_4103F9(__int64 *, __int64, __int64, char, __m128, __m128);
__int64 __fastcall sub_4105E1(__int64 *, __int64, unsigned int, int, __m128, __m128);
unsigned __int64 __fastcall sub_4106A4(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_410740(__int64);
void __fastcall sub_410761(__int64 *, int, __m128, __m128, __int64, __int64, __int64);
const signed __int32 **__fastcall sub_410892(__int64 *a1, int a2, int *a3, int *a4, const signed __int32 **a5, const signed __int32 **a6, __m128 a7, __m128 a8);
__int64 __fastcall sub_410A94(__int64 *, __int16, __int64, __int64, int, __int64, __m128, __m128, __int64, int);
__int64 __fastcall sub_41162B(__int64 *, int, __m128, __m128);
_BYTE *__fastcall sub_41168F(_QWORD *, __int64, int, __m128, __m128);
__int64 __fastcall sub_4116DD(__int64, __int64, int);
__int64 __fastcall sub_41176B(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6);
_BOOL8 __fastcall sub_411829(__int64, __int64);
__int64 __fastcall sub_411864(__int64, _QWORD *, __m128, __m128);
__int64 __fastcall sub_4118E4(__int64, __int64);
__int64 __fastcall sub_4118E9(__int64 *a1, __int64 *a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_411944(__int64 *, __m128, __m128);
__int64 __fastcall sub_411F9C(__int64, __int64);
__int64 __fastcall sub_411FBE(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_412000(__int64, __int64);
__int64 *__fastcall sub_41203C(__int64);
__int64 __fastcall sub_412059(__int64, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_4120AE(__int64 *, __m128, __m128, __int64, __int64, __int64);
_QWORD *__fastcall sub_41214B(__int64, __int64);
_QWORD *__fastcall sub_412166(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_412195(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_4121C6(__int64 *, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_4121FB(__int64 *, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_412200(__int64, int);
__int64 __fastcall sub_41221D(__int64, int, int);
__int64 __fastcall sub_41223D(__int64, int);
__int64 __fastcall sub_412251(__int64, __m128, __m128);
__int64 __fastcall sub_4123AE(__int64 *, __int64, int, _DWORD *, _DWORD *, _DWORD *, __m128, __m128, _DWORD *);
unsigned __int8 __fastcall sub_412449(__int64, int, __m128, __m128);
unsigned __int8 __fastcall sub_412529(__int64, __m128, __m128);
__int64 __fastcall sub_412531(__int64, __m128, __m128);
__int64 __fastcall sub_412615(__int64, int *, _DWORD *, __m128, __m128);
__int64 __fastcall sub_412717(__int64, __int64, int, int, __m128, __m128);
_DWORD *__fastcall sub_412810(__int64, int, int);
__int64 __fastcall sub_41282E(__int64 *, _DWORD *, _DWORD *, __int64, __m128, __m128);
__int64 __fastcall sub_412889(__int64, __m128, __m128);
__int64 __fastcall sub_4128B7(__int64, int, __m128, __m128);
__int64 __fastcall sub_4128FC(__int64, __m128, __m128);
_DWORD *__fastcall sub_412903(__int64, int, __m128, __m128);
__int64 __fastcall sub_41299B(__int64, __m128, __m128);
_DWORD *__fastcall sub_4129C3(__int64, __m128, __m128);
__int64 __fastcall sub_4129CD(_QWORD **, __m128, __m128);
_DWORD *__fastcall sub_412D6A(__int64 *, int, __m128, __m128);
_DWORD *__fastcall sub_412DAE(__int64, __int16, int, int, __m128, __m128);
_DWORD *__fastcall sub_412EC4(__int64, __int16, int, __m128, __m128);
_DWORD *__fastcall sub_412ECD(__int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_412ED7(__int64, int, __m128, __m128);
_DWORD *__fastcall sub_412F21(__int64 a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_412F7E(__int64, _DWORD *, int, char, __m128, __m128);
_DWORD *__fastcall sub_41315A(__int64, unsigned int, int, int, int, __m128, __m128);
__int64 __fastcall sub_4134B2(__int64, int *, __m128, __m128);
void __fastcall sub_4134F7(__int64, unsigned int *, int, __m128, __m128);
void __fastcall sub_413793(__int64, unsigned int *, __m128, __m128);
__int64 __fastcall sub_4137B8(__int64, unsigned int *, int, char, __m128, __m128);
__int64 __fastcall sub_4137FD(__int64, unsigned int *, int, __m128, __m128);
__int64 __fastcall sub_413801(__int64, unsigned int *, __int64, int, __m128, __m128);
__int64 __fastcall sub_413890(__int64, _DWORD *, signed __int32, __m128, __m128);
__int64 __fastcall sub_415091(__int64, _DWORD *, signed __int32, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_415116(__int64, unsigned int *, int, _DWORD *, _DWORD *, __m128, __m128);
__int64 __fastcall sub_415286(__int64, unsigned int *, int, __m128, __m128);
__int64 __fastcall sub_4152CE(__int64, unsigned int *, __m128, __m128, __int64, __int64, __int64, __int64);
void __fastcall sub_4152FE(__int64, unsigned int *, int, __m128, __m128);
__int64 __fastcall sub_416732(__int64, int, int, int, __m128, __m128);
__int64 __fastcall sub_4167EA(__int64, int, int, int, int, __m128, __m128);
__int64 __fastcall sub_416F22(__int64, char, __m128, __m128);
__int64 __fastcall sub_4170A8(__int64, char, __m128, __m128);
__int64 __fastcall sub_4172FA(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_4174F4(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4, signed __int32 a5, int a6);
__int64 __fastcall sub_417525(__int64, unsigned int *, __m128, __m128);
void __fastcall sub_4175A2(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4, signed __int32 a5);
__int64 __fastcall sub_4175C8(__int64, unsigned int *, __m128, __m128);
__int64 __fastcall sub_4175F8(__int64 *, __int64, __int64, int, __m128, __m128);
__int64 __fastcall sub_4176AB(__int64 *, __int128 *, __int128 *, int, __m128, __m128);
__int64 __fastcall sub_41787D(unsigned int, double, double);
__int64 __fastcall sub_4178C9(__int64);
double __fastcall sub_417910(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_417A0C(__int64, __int64, double);
__int64 __fastcall sub_417A42(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_417A4E(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_417AB3(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_417B0B(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_417B16(__int64 *a1, _DWORD *a2, _DWORD *a3, char a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_417D71(__int64, __int64, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_417DB2(__int64, __int64);
__int64 __fastcall sub_417DC2(__int64 *, __int64, __int64, char, __m128, __m128);
__int64 __fastcall sub_417EE5(__int64 *, __int128 *, __int128 *, __m128, __m128);
__int64 __fastcall sub_417EEF(__int64 *, __int128 *, __int128 *, __m128, __m128);
__int64 __fastcall sub_417EF6(__int64 *, __int128 *, __int128 *, __m128, __m128);
__int64 __fastcall sub_417F60(__int64);
_BOOL8 __fastcall sub_417FC2(__int64);
_BOOL8 __fastcall sub_417FDB(__int64);
__int64 __fastcall sub_417FE9(unsigned __int8 *, int);
__int64 __fastcall sub_418032(__int64 *, __int64, __int64, __int64, int, __int64, __m128, __m128);
__int64 __fastcall sub_41827C(__int64 *, __int64, __int64, __int64, unsigned int, __m128, __m128);
__int64 *__fastcall sub_41833D(__int64 *, __int64, __int64, __int64, __int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_41843F(__int64 *, __int64, __int64, __int64, int, __m128, __m128);
int *__fastcall sub_4186B8(__int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_418785(__int64, _QWORD *, __m128, __m128);
__int64 __fastcall sub_4187BD(__int64 *, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_418885(__int64 *, __int64, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_418892(__int64 *, __int64, __int64, unsigned int, __m128, __m128);
__int64 *__fastcall sub_4188A7(__int64 *, __int64, __int64, __int64 *, unsigned int, __m128, __m128);
__int64 *__fastcall sub_4188B7(__int64 *, __int64, __int64, __int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_4188CF(__int64 *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_418926(__int64 *, _QWORD *, __int64, __m128 *, char, int, double, __m128);
unsigned __int8 *__fastcall sub_418B4C(__int64 a1, unsigned int a2, __m128 a3, __m128 a4);
unsigned __int8 *__fastcall sub_418CB4(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_418CEF(int **, __m128, __m128, __int64, __int64);
__int64 __fastcall sub_418D1D(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_418D73(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_418DBF(__int64 *, __m128, __m128);
__int64 __fastcall sub_418E07(__int64 *, int *, int);
__int64 __fastcall sub_418E75(__int64 (__fastcall *)(__int64, __int64, __int64, __int64), __int64, unsigned __int16 *, int);
__int64 __fastcall sub_418EB9(unsigned int **, char, __m128, __m128);
void __fastcall sub_418FA3(__int64);
__int64 __fastcall sub_418FB0(__int64, __int64);
unsigned __int8 *__fastcall sub_418FC1(__int64 a1, __int64 a2, __m128 a3, __m128 a4);
unsigned __int8 __fastcall sub_418FE2(int **, __int64, int, int, __m128, __m128);
unsigned __int8 *__fastcall sub_419B9C(int **a1, __int64 a2, __m128 a3, __m128 a4);
unsigned __int8 *__fastcall sub_41A06B(unsigned int **a1, __int64 (__fastcall *a2)(__int64, __int64, __int64, __int64), __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41A342(_DWORD *);
__int64 __fastcall sub_41A35D(int *, int *);
__int64 __fastcall sub_41A3A1(_DWORD *, _DWORD *, _DWORD *);
__int64 __fastcall sub_41A401(_DWORD *, _DWORD *, _DWORD *);
void __fastcall sub_41A4A8(__int64, int *);
__int64 __fastcall sub_41A4C6(__int64, int);
__int64 __fastcall sub_41A54B(_DWORD *, _DWORD *, int);
void __fastcall sub_41A584(_DWORD *, int, int *);
void __fastcall sub_41A5AF(_DWORD *);
__int64 __fastcall sub_41A6F9(_DWORD *);
void __fastcall sub_41A95B(_DWORD *, int, int, _DWORD *, int *);
__int64 __fastcall sub_41AA14(int *);
__int64 __fastcall sub_41AC55(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41B2D3(__int64 *a1, unsigned int a2, int a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_41B6BE(__int64 *a1, unsigned int a2, int a3, int a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_41B6EB(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5);
_BYTE *__fastcall sub_41B712(__int64 *, char, __m128, __m128);
__int64 __fastcall sub_41B75D(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_41B7AF(__int64 *, unsigned int, unsigned int, __m128, __m128);
__int64 __fastcall sub_41B7F2(__int64 *, unsigned int, int, __m128, __m128);
__int64 __fastcall sub_41B84B(__int64, unsigned int, int, int, __m128, __m128);
int *__fastcall sub_41B95F(__int64 a1, int a2, int *a3, __m128 a4, __m128 a5);
void __fastcall sub_41C0B4(__int64 *, __m128, __m128);
__int64 __fastcall sub_41C395(__int64 *, __m128, __m128);
__int64 __fastcall sub_41C41B(__int64 *);
__int64 __fastcall sub_41C47F(__int64, __int64, int);
__int64 __fastcall sub_41C4EA(unsigned int);
__int64 __fastcall sub_41C531(unsigned int, _BYTE *);
__int64 __fastcall sub_41C56C(_BYTE **, unsigned int, __int64 *);
__int64 __fastcall sub_41C6FA(unsigned int, _BYTE *);
__int64 __fastcall sub_41C7A1(__int64, unsigned __int64 *, unsigned __int64, unsigned __int64, int *);
__int64 __fastcall sub_41C85D(__int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_41C892(_BYTE *, unsigned __int64, __int64, int);
__int64 __fastcall sub_41C942(__int64, unsigned __int64);
__int64 __fastcall sub_41CA19(int);
_BOOL8 __fastcall sub_41CA82(int);
_BOOL8 __fastcall sub_41CAA1(int);
_BOOL8 __fastcall sub_41CADA(int);
__int64 __fastcall sub_41CB38(int);
void __fastcall sub_41CB8C(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_41CD28(__int64, unsigned int);
__int64 __fastcall sub_41CD7E(int);
__int64 __fastcall sub_41CDA5(__int64 *, int);
__int64 __fastcall sub_41CDF1(__int64 *);
__int64 __fastcall sub_41CDF8(__int64 *, int);
__int64 __fastcall sub_41CE22(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_41CE24(__int64 *);
__int64 __fastcall sub_41CE93(__int64 *);
__int64 __fastcall sub_41CF7C(__int64, _QWORD *, __int64);
__int64 __fastcall sub_41CF97(__int64 *, _QWORD *, unsigned __int64, __m128, __m128);
__int64 __fastcall sub_41CFE2(__int64 *a1, _QWORD *a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41D054(__int64 *a1, _QWORD *a2, __m128 a3, __m128 a4);
void __fastcall sub_41D08C(__int64, __int64 *, __int64, unsigned __int64);
void __fastcall sub_41D0AD(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6);
void __fastcall sub_41D0F2(__int64, _QWORD *, __int64, __int64, unsigned __int64);
void __fastcall sub_41D130(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, unsigned __int64 a5, __m128 a6, __m128 a7);
void __fastcall sub_41D180(__int64, _QWORD *, unsigned __int64, unsigned __int64, unsigned __int64);
void __fastcall sub_41D1C8(__int64 *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5, __m128 a6, __m128 a7);
void __fastcall sub_41D218(__int64, _QWORD *, __int64, __int64);
void __fastcall sub_41D23D(__int64 *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6);
void __fastcall sub_41D282(__int64, _QWORD *, __int64, __int64);
__int64 __fastcall sub_41D2A1(double);
__int64 __fastcall sub_41D2CA(double);
__int64 sub_41D2F0(void); // weak
__m128 __fastcall sub_41D2F2(double); // weak
__m128 __fastcall sub_41D2F4(__m128);
_BOOL8 __fastcall sub_41D385(double);
_BOOL8 __fastcall sub_41D3C3(double);
__int64 __fastcall sub_41D3F3(double);
_BOOL8 __fastcall sub_41D436(double);
_BOOL8 __fastcall sub_41D45B(double);
__int64 __fastcall sub_41D498(__int64, __int64, __int64);
_BOOL8 __fastcall sub_41D4BF(double, double);
double __fastcall sub_41D4DE(double, double);
_BOOL8 __fastcall sub_41D4E3(double);
__int64 __fastcall sub_41D508(__int64, __int64, double);
_BOOL8 __fastcall sub_41D552(__int64, __int64, double);
__int64 __fastcall sub_41D58D(int *, double);
__int64 __fastcall sub_41D5D5(int *, double);
double __fastcall sub_41D60E(double, __m128d);
__int64 __fastcall nullsub_3(_QWORD); // weak
__int64 __fastcall nullsub_2(_QWORD, _QWORD); // weak
unsigned __int64 __fastcall sub_41D667(unsigned __int64 *);
__int64 __fastcall sub_41D671(_QWORD); // weak
__int64 __fastcall sub_41D673(unsigned int *);
__int64 __fastcall sub_41D67A(_QWORD); // weak
_BOOL8 __fastcall sub_41D67C(double, double);
__int64 __fastcall sub_41D69F(__int64, __int64, __int64);
__int64 __fastcall sub_41D6AC(_QWORD, _QWORD); // weak
unsigned __int64 __fastcall sub_41D6B1(__int64);
double __fastcall sub_41D71B(__int64);
__int64 __fastcall sub_41D784(__int64, __int64);
__int64 __fastcall sub_41D78C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_41D797(__int64 a1, __int64 a2);
__int64 __fastcall sub_41D79F(__int64 *a1, int a2, unsigned __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41D8AF(__int64 *a1, int *a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41D8F0(__int64, int *);
void __fastcall sub_41D928(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_41D9B8(__int64 *, __int64, __m128, __m128, __m128);
__int64 __fastcall sub_41D9F1(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41DA2F(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41DA64(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41DAD1(_QWORD *, __int64 (__fastcall *)(__int64, __int64), __int64, int, int, __m128, __m128);
__int64 __fastcall sub_41DB66(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41DBA7(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41DBF3(__int64 *a1, int a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41DC34(__int64 *a1, int *a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_41DC85(__int64);
__int64 __fastcall sub_41DC9A(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_41DCBE(__int64);
__int64 __fastcall sub_41DCD3(__int64);
const signed __int32 *__fastcall sub_41DD48(__int64 *a1, int a2, __int16 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_41DD5D(__int64 *a1, __m128 a2, __m128 a3);
double __fastcall sub_41DD96(_QWORD); // weak
__int64 __fastcall sub_41DD9B(__int64, __int64, __int64, __int64);
double __fastcall sub_41DDAA(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_41DE9A(__int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_41DF22(__int64 *, __int64, int, __m128, __m128);
__int64 __fastcall sub_41DF78(__int64 *, char, _DWORD *, __m128, __m128);
double __fastcall sub_41E05A(__int64, __int64, double result);
__int64 __fastcall sub_41E098(int);
_BOOL8 __fastcall sub_41E0FB(int);
__int64 __fastcall sub_41E147(double);
__int64 __fastcall sub_41E185(int *, __int64, char, double);
double __fastcall sub_41E321(__int64, __int64);
__int64 __fastcall sub_41E537(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_41E6C9(__int64 *, __m128, __m128);
__int64 __fastcall sub_41E80C(__int64 *, __m128, __m128);
__int64 __fastcall sub_41E852(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_41E8A1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_41E8C2(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EA97(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EABC(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EB58(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EBDA(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EC20(__int64 *, __m128, __m128);
__int64 __fastcall sub_41ED76(__int64 *, __m128, __m128);
__int64 __fastcall sub_41EDBF(_QWORD *, __m128, __m128);
double __fastcall sub_41EE6B(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_41EEA7(double);
__int64 __fastcall sub_41EFAF(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_41F058(__int64 *a1, __m128 a2, __m128 a3);
__int64 sub_41F120();
__int64 __fastcall sub_41F123(__int64 *, __m128, __m128);
__int64 __fastcall sub_41F274(__int64 *, __m128, __m128);
__int64 sub_41F325();
__int64 sub_41F32B();
__int64 sub_41F331();
__int64 sub_41F337();
__int64 __fastcall sub_41F33D(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_41F5B5(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_41F61B(__int64 *, __m128, __m128);
__int64 __fastcall sub_41F671(__int64, __m128, __m128);
_BYTE *__fastcall sub_41F69C(__int64 *, __m128, __m128, __int64, int);
__int64 __fastcall sub_41F7B1(__int64, int);
__int64 __fastcall sub_41F7D9(__int64 *, __m128, __m128, __int64, unsigned int);
__int64 __fastcall sub_41F872(__int64 *, void (__fastcall *)(__int64 **, __int64, _QWORD), __int64, __m128, __m128);
_BYTE *__fastcall sub_41F90E(_QWORD *, __int64, signed int, __m128, __m128);
__int64 __fastcall sub_41FA57(__int64 *, __int64, unsigned int, __m128, __m128, __int64, __int64, __int64);
__int64 __fastcall sub_41FC62(__int64 *, __m128, __m128, __m128);
__int64 __fastcall sub_41FDDE(__int64 *, __m128, __m128);
__int64 __fastcall sub_41FE5E(__int64 *, __m128, __m128);
__int64 __fastcall sub_41FE8B(__int64 *, __m128, __m128);
__int64 __fastcall sub_41FEB8(__int64 *, __m128, __m128);
__int64 __fastcall sub_41FEF4(__int64 *, __m128, __m128);
__int64 __fastcall sub_41FF48(__int64 *, __int64, char, __m128, __m128);
__int64 __fastcall sub_42005E(__int64 *, __m128, __m128);
void __fastcall sub_420081(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5);
void __fastcall sub_4200FB(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5);
void __fastcall sub_42011D(__int64 *a1, __int64 a2, __m128 a3, __m128 a4);
__int64 __fastcall sub_420124(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_42014B(__int64 *, __int64, unsigned int, __m128, __m128);
__int64 __fastcall sub_4202D0(__int64 *, int, unsigned int, __m128, __m128);
double __fastcall sub_4203F2(double result, double);
double __fastcall sub_4203F7(double result, double);
_DWORD *__fastcall sub_42045D(__int64 *a1, __m128 a2, __m128 a3);
unsigned int *__fastcall sub_42048D(__int64 *a1, int a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_4204D4(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_420529(__int64 a1);
__int64 __fastcall sub_42056C(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6);
double __fastcall nullsub_1(double, double); // weak
char *__fastcall sub_4205E2(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_420642(__int64 a1, int a2, unsigned int a3, __m128 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_421382(__int64, int, unsigned int, __m128, __m128, __m128);
__int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_4213B7(__int64, __int64 (__fastcall *)(__int64, __int64), __int64, int, int, __m128, __m128);
__int64 __fastcall sub_42165E(__int64 *a1, __int128 *a2, __int128 *a3, unsigned int a4, unsigned int a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_421738(__int64 *a1, unsigned int a2, __int64 a3, int a4, __m128 a5, __m128 a6);
unsigned int *__fastcall sub_4217B1(__int64 *, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_4218C9(__int64 *, __int64, __int64, unsigned int, unsigned int, __m128, __m128, __m128);
__int64 __fastcall sub_4219BF(__int64 *, char *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_421ABC(_QWORD *, _QWORD *, __m128, __m128);
__int64 __fastcall sub_421B08(_QWORD *, __m128, __m128);
__int64 __fastcall sub_421B56(__int64, _QWORD *, __int64, __int64, __m128, __m128);
unsigned int *__fastcall sub_421BAE(__int64 *, unsigned int, __int64, char, unsigned int, __m128, __m128);
__int64 __fastcall sub_421CC1(__int64, __int64, __int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_421D43(_QWORD *, __int64 *, unsigned int, __m128, __m128);
__int64 __fastcall sub_421D90(__int64 *, __int64, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_421EFA(_QWORD *, int, unsigned int, __int64, __m128, __m128);
__int64 __fastcall sub_421FA0(__int64, _DWORD *, _DWORD *, __int64, __m128, __m128, __m128);
__int64 __fastcall sub_422318(__int64, __int64, __int64, __m128, __m128, __m128, __int64, __int64, __int64, char);
unsigned __int64 __fastcall sub_4261E0(__int64, int, int);
unsigned __int64 __fastcall sub_426227(__int64);
__int64 __fastcall sub_426238(__int64 *, __m128, __m128);
_DWORD *__fastcall sub_426263(__int64);
__int64 __fastcall sub_42628A(__int64 *, __m128, __m128);
void __fastcall sub_4262BB(__int64 *, int, int, __m128, __m128);
__int64 __fastcall sub_426341(__int64 *, int, int, __m128, __m128);
void __fastcall sub_426454(__int64 *, int, int, __m128);
__int64 __fastcall sub_42653A(_QWORD *, __m128, __m128);
__int64 __fastcall sub_4265E7(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42660E(__int64 *, __m128, __m128);
__int64 __fastcall sub_426670(__int64 *, __m128, __m128);
__int64 __fastcall sub_426820(__int64 *, __m128, __m128);
__int64 __fastcall sub_42696F(__int64 *, __m128, __m128);
__int64 __fastcall sub_426A44(__int64 *, __m128, __m128);
__int64 __fastcall sub_426B90(__int64 *, __m128, __m128);
__int64 __fastcall sub_426BC2(__int64 *, __m128, __m128);
__int64 __fastcall sub_426E2B(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_426EE4(__int64 *, __m128, __m128);
__int64 __fastcall sub_426FD0(__int64 *, __m128, __m128);
__int64 __fastcall sub_427082(__int64 *, __m128, __m128);
__int64 __fastcall sub_427168(__int64 *, __m128, __m128);
__int64 __fastcall sub_427245(__int64 *, __m128, __m128);
__int64 __fastcall sub_4273EF(__int64 *, __m128, __m128);
__int64 __fastcall sub_427511(__int64 *, __m128, __m128);
__int64 __fastcall sub_427598(__int64 *, __m128, __m128);
_WORD *__fastcall sub_4275F7(__int64, unsigned int, char);
__int64 __fastcall sub_42766D(__int64 *);
unsigned __int64 __fastcall sub_427689(__int64, unsigned __int64, __int64, __m128, __m128);
__int64 __fastcall sub_427705(__int64 *);
char __fastcall sub_427721(__int64);
__int64 __fastcall sub_427753(__int64);
__int64 __fastcall sub_427793(__int64, unsigned __int64);
__int16 __fastcall sub_4277C9(__int64);
__int64 __fastcall sub_4277FE(__int64);
__int64 __fastcall sub_427833(__int64 **, char, int, __m128, __m128);
__int64 __fastcall sub_427927(__int64 **, char);
__int64 __fastcall sub_427990(__int64 **, char, __int64, __m128, __m128);
__int64 __fastcall sub_4279F8(__int64 **, char, __m128, __m128);
__int64 __fastcall sub_427AF5(__int64 **, __int64, __m128, __m128);
__int64 __fastcall sub_427EEF(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_427F79(__int64 *, __m128, __m128);
__int64 __fastcall sub_428018(__int64, __m128, __m128);
__int64 __fastcall sub_428481(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_428518(__int64 *, __m128, __m128);
__int64 __fastcall sub_428544(__int64 *, __m128, __m128);
__int64 __fastcall sub_428557(__int64 *, __m128, __m128);
__int64 __fastcall sub_42856A(__int64 *, __m128, __m128);
__int64 __fastcall sub_42858F(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_4285BE(__int64 *, __m128, __m128);
__int64 __fastcall sub_42860A(__int64 *, __m128, __m128);
__int64 __fastcall sub_4286D5(__int64 *, __m128, __m128);
__int64 __fastcall sub_428799(_QWORD *, __m128, __m128);
__int64 __fastcall sub_4287AB(__int64 *, unsigned int, __m128, __m128, __m128);
__int64 __fastcall sub_428BB1(__int64 *, __m128, __m128);
__int64 __fastcall sub_428C27(__int64 *, __m128, __m128);
__int64 __fastcall sub_428D24(__int64 *, __m128, __m128, __m128);
_BYTE *__fastcall sub_428D5B(__int64, unsigned __int64, _BYTE *);
_BYTE *__fastcall sub_428E41(__int64 *, char, __m128, __m128);
__int64 __fastcall sub_428E7D(__int64, __int64, unsigned __int64, __int64, __m128, __m128);
__int64 __fastcall sub_428F0A(__int64 *, unsigned int, __int64, __m128, __m128);
__int64 __fastcall sub_428FAA(__int64 *, __int64, __int64, __m128, __m128);
__int64 __fastcall sub_428FFB(__int64 *, unsigned int, __int64, __m128, __m128);
__int64 __fastcall sub_429056(__int64, __m128, __m128);
__int64 __fastcall sub_42909D(__int64);
char *__fastcall sub_4290BE(__int64, int, __m128, __m128);
char *__fastcall sub_4290F1(__int64, __m128, __m128);
char *__fastcall sub_429282(_QWORD *, unsigned int);
__int64 __fastcall sub_4292BB(__int64, __m128, __m128);
__int64 __fastcall sub_429412(__int64, unsigned int *, __m128, __m128);
__int64 __fastcall sub_42946B(__int64, _DWORD *, __m128, __m128);
__int64 __fastcall sub_429568(_DWORD *, unsigned int, _WORD *);
_BYTE *__fastcall sub_4295DD(__int64, __int64, __m128, __m128);
_BYTE *__fastcall sub_42974E(__int64, __int64, __m128, __m128);
__int64 __fastcall sub_4297BE(__int64, __m128, __m128);
__int64 __fastcall sub_429962(__int64, int, __m128, __m128);
unsigned __int8 __fastcall sub_429DD9(__int64);
unsigned __int8 *__fastcall sub_429DF6(__int64, __m128, __m128);
void __fastcall sub_42A197(__int64 *, __m128, __m128, __int64, int);
__int64 __fastcall sub_42A276(__int64 *, int, int, int, int, __m128, __m128);
__int64 __fastcall sub_42A5E8(__int64 *, __m128, __m128);
__int64 __fastcall sub_42A601(__int64 *, __m128, __m128);
__m128 __fastcall sub_42A620(__m128);
double __fastcall sub_42A641(double);
__int64 __fastcall sub_42A678(__int64 *, double (__fastcall *)(double, double), __m128, __m128, __m128);
double __fastcall sub_42A723(double, double);
double __fastcall sub_42A7A1(double result);
double __fastcall sub_42A7F7(double, double, __m128d, __m128d);
__int64 __fastcall sub_42A86D(__int64 *, __m128, __m128);
__int64 __fastcall sub_42A8A2(__int64 *, __m128, __m128, __m128);
__int64 __fastcall sub_42A8FA(__int64 *, __m128, __m128, __m128);
__int64 __fastcall sub_42A91E(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42A93F(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AA6C(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AACA(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42AB36(__int64 *a1, __m128 a2, __m128 a3);
double __fastcall sub_42AB6D(__int64 *, __m128, __m128);
__int64 __fastcall sub_42ABE8(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AC70(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AC80(__int64 *, __m128, __m128);
__int64 __fastcall sub_42ACD0(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AD58(__int64 *, __m128, __m128);
__int64 __fastcall sub_42ADD9(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AE59(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42AEBE(__int64 *, double, __m128);
__int64 __fastcall sub_42AED8(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AF2C(__int64 *, __m128, __m128);
__int64 __fastcall sub_42AFBF(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42AFE9(__int64 *, __m128, __m128, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_42B0CF(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B130(_QWORD *, __m128, __m128);
__int64 __fastcall sub_42B155(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42B1CE(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B206(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B216(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B266(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B277(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B30A(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B457(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B50D(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B541(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B590(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B68D(_QWORD *, __m128, __m128);
__int64 __fastcall sub_42B6EE(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B745(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B80A(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6);
__int64 __fastcall sub_42B82B(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B89E(__int64 *, __m128, __m128);
__int64 __fastcall sub_42B923(__int64, __m128, __m128);
__int64 __fastcall sub_42B968(__int64, __m128, __m128);
__int64 __fastcall sub_42B9E3(__int64, __m128, __m128);
__int64 __fastcall sub_42BA26(__int64, __m128, __m128);
void __fastcall sub_42BAB2(_QWORD *, __m128, __m128);
__int64 __fastcall sub_42BADF(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BBFD(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BC1E(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BC5A(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BCB8(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BD48(__int64 *, __m128, __m128);
__int64 __fastcall sub_42BE33(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42BF57(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, int a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_42C020(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42C059(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C090(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C137(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C148(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C1B4(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C1E9(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42C269(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42C2EB(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42C375(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42C40D(__int64 *, __m128, __m128);
__int64 __fastcall sub_42C43E(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42C4EA(__int64 *, __m128, __m128);
__int64 __fastcall sub_42CB67(__int64 *, __m128, __m128);
__int64 __fastcall sub_42CEE9(__int64 *, __m128, __m128);
__int64 __fastcall sub_42CF4B(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D07D(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D0B2(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D0D5(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D19A(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D20E(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D2FE(__int64 *, __int64, __m128, __m128);
const signed __int32 *__fastcall sub_42D369(__int64 *, __int64);
__int64 __fastcall sub_42D3B3(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D4A7(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D502(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42D54A(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42D584(__int64 *, __m128, __m128, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_42D5D7(__int64 *, __m128, __m128);
__int64 __fastcall sub_42D78B(__int64 *, __int64, __m128, __m128);
__int64 __fastcall sub_42D87C(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_42D88C(__int64 *a1, __m128 a2, __m128 a3);
__int64 __fastcall sub_42D8A3(__int64, unsigned __int64 *, __m128, __m128);
__int64 __fastcall sub_42D8B3(__int64, unsigned __int64 *, __m128, __m128);
_BYTE *__fastcall sub_42D8DE(__int64 *a1, _BYTE **a2, unsigned __int64 a3, unsigned __int64 a4, int a5, __m128 a6, __m128 a7);
__int64 __fastcall sub_42D922(__int64, unsigned __int64 *, __m128, __m128);
__int64 __fastcall sub_42D95C(__int64 *, _BYTE *, __m128, __m128);
_BYTE *__fastcall sub_42D99B(__int64, unsigned __int64, _BYTE *, __m128, __m128);
__int64 __fastcall sub_42DF94(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42E2A2(__int64 *, __m128, __m128);
__int64 __fastcall sub_42E2A9(__int64 *, __m128, __m128);
__int16 __fastcall sub_42E2B3(_WORD *);
__int64 __fastcall sub_42E2B9(unsigned int *);
float __fastcall sub_42E2BE(int *);
double __fastcall sub_42E2DB(__int64 *);
__int16 __fastcall sub_42E362(_WORD *, __int16);
void __fastcall sub_42E36A(_DWORD *, unsigned int);
__int64 __fastcall sub_42E36F(float *, float);
__int64 __fastcall sub_42E395(double *a1, double a2);
__int16 __fastcall sub_42E3D7(_WORD **, __int16);
void __fastcall sub_42E3EF(_DWORD **, unsigned int);
__int64 __fastcall sub_42E404(float **, float);
__int64 __fastcall sub_42E41D(double **a1, double a2);
__int64 __fastcall sub_42E436(_BYTE **, unsigned int);
char __fastcall sub_42E46E(unsigned __int8 *, _BYTE *);
_QWORD *__fastcall sub_42E4BF(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_42E507(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42E6E3(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42E8D0(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42E9AD(__int64 *, int, __m128, __m128);
__int64 __fastcall sub_42EB6E(__int64 *, __m128, __m128);
__int64 __fastcall sub_42ED6F(__int64 *, __int64, __m128, __m128, __int64, __int64);
double __fastcall sub_42EE0D(double);
void __fastcall sub_42EE95(double);
double __fastcall sub_42EFC4(double);
__m128 __fastcall sub_42F04C(__m128);
void __fastcall sub_42F192(__m128, double);
__m128 __fastcall sub_42F31C(__m128 result);
unsigned __int64 __fastcall sub_42F501(double);
__int64 __fastcall sub_42F63A(double);
void __fastcall sub_42F6D7(double, double, double, double, __m128);
double __fastcall sub_42F775(double result);
__int64 __fastcall sub_42F94A(double);
double __fastcall sub_42F9DE(double result, double);
__int64 __fastcall sub_42FB3D(double);
double __fastcall sub_42FB80(double result);
double __fastcall sub_42FD67(double result);
double __fastcall sub_43030C(double);
void sub_430315();
double __fastcall sub_430322(int);
unsigned __int64 __fastcall sub_430355(unsigned __int64 a1);
void __fastcall sub_4303AD(double, double);
__int64 __fastcall sub_430953(double *, double, double, double, double, __m128);
__int64 __fastcall sub_430D42(__int64, double *, int, int, int, __m128, __m128);
double __fastcall sub_43140F(int, double);
double __fastcall sub_43149B(int, double, double);
void __fastcall sub_431539(double, double, double, double, __m128);
void __fastcall sub_4315E8(__m128, double, __m128, double, __m128, __int64, __int64, __int64, unsigned __int32);
void sub_431665();
double __fastcall sub_4316BD(double, double);
__m128 __fastcall sub_43175D(int, __m128, double, __m128, __int64, __int64, unsigned __int32);
void __fastcall __noreturn sub_431916(__int64, __int64, const char *);
char __fastcall sub_431925(__int64, __int64);
__int64 __fastcall sub_431ABE(_DWORD *);
__int64 sub_431B90(__int64, _BYTE *, ...);
__int64 __fastcall sub_431C16(char *, __int64);
__int64 __fastcall sub_431CDA(__int64);
__int64 __fastcall sub_431CE2(__int64, int);
__int64 __fastcall sub_431D03(__int64);
__int64 __fastcall sub_431D58(int, __int64);
__int64 __fastcall sub_431DD4(__int64, _BYTE *, __int64, __int64, __int64);
_BOOL8 __fastcall sub_431E05(__int64);
__int64 __fastcall sub_431E0F(__int64);
__int64 __fastcall sub_431E1D(__int64);
double __fastcall sub_431EA0(int, int);
__int64 __fastcall sub_431EA9(__int64 *, _QWORD *, __int64, __int64);
__int64 __fastcall sub_431EF7(char *);
__int64 __fastcall sub_431F12(char *);
_BYTE *__fastcall sub_431F31(_BYTE *, __int64, unsigned __int64);
char *__fastcall sub_431F59(char *, int *, int, int);
char *__fastcall sub_431F99(char *);
char *__fastcall sub_432012(char *);
char *__fastcall sub_43204C(char *, _DWORD *);
__int64 __fastcall sub_43210F(__int64, int, int *, int);
__int64 __fastcall sub_4322A9(__int64, __int64, __int64);
__int64 __fastcall sub_4323D8(int);
__int64 __fastcall sub_432409(__int64, int, __int64, __int64);
__int64 __fastcall sub_4327F2(_DWORD *, _DWORD *);
_BOOL8 __fastcall sub_43281F(__int64, int, int);
__int64 __fastcall sub_4328B2(int *, int *, int);
__int64 __fastcall sub_4328E9(unsigned int *, __int64 (__fastcall *)(__int64 *a1, __int64 a2, __int64 a3), unsigned int, _DWORD *, int);
__int64 __fastcall sub_432E49(unsigned int *, __int64 (__fastcall *)(__int64 *a1, __int64 a2, __int64 a3), unsigned int, _DWORD *);
__int64 __fastcall sub_432E8A(unsigned int *, __int64 (__fastcall *)(__int64 *a1, __int64 a2, __int64 a3), unsigned int);
__int64 __fastcall sub_43307C(_BYTE *, __int64, unsigned __int64);
__int64 __fastcall sub_433507(char *, __int64, __int64);
__int64 __fastcall sub_433C81(__int64);
__int64 __fastcall sub_433CBC(__int64 *, int, __int64);
__int64 __fastcall sub_433D49(__int64 *, __int64, __int64);
__int64 __fastcall sub_433EF5(__int64, char *, __int64, __int64);
__int64 __fastcall sub_434061(__int64 *, char *, __int64, __int64);
__int64 __fastcall sub_43408C(__int64 *, __int64);
__int64 __fastcall sub_434096(unsigned int *, char *, __int64, __int64);
_BYTE *__fastcall sub_4340B8(_BYTE *, unsigned __int64, char *);
_BYTE *__fastcall sub_4340D1(_BYTE *, unsigned __int64, unsigned int, _BYTE *);
_BYTE *__fastcall sub_434113(_BYTE *a1, _BYTE *a2, _BYTE *a3, __int64 a4);
__int64 __fastcall sub_434660(_BYTE *, __int64, _BYTE *, __int64);
_BYTE *__fastcall sub_43468F(_BYTE *, _BYTE *, __int64);
__int64 __fastcall sub_434AC1(__int64 *, _QWORD *, __int64, __int64);
__int64 __fastcall sub_434AF5(__int64);
__int64 __fastcall sub_434B23(__int64, __int64, __int64, char);
__int64 *__fastcall sub_434B4A(__int64, __int64, __int64, char);
__int64 __fastcall sub_434C48(__int64, unsigned __int8 *, __int64);
__int64 __fastcall sub_434C82(_QWORD *, int);
unsigned __int64 __fastcall sub_434E00(__int64 a1, _QWORD *a2);
unsigned __int64 __fastcall sub_434E5B(_QWORD *, __int64 *, __int64, unsigned __int64);
__int64 __fastcall sub_434EC1(__int64, __int64, __int64);
__int64 __fastcall sub_434F19(__int64, _QWORD *, __int64, char);
__int64 __fastcall sub_434FB8(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_434FBE(_QWORD); // weak
__int64 __fastcall sub_434FC4(_QWORD); // weak
__int64 __fastcall sub_434FCA(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_434FD0(_QWORD *, __int64, __int64);
__int64 __fastcall sub_435017(__int64);
_BOOL8 __fastcall sub_4352D4(_QWORD *, unsigned __int64);
__int64 __fastcall sub_435410(__int64, __int64, unsigned __int64);
unsigned __int64 __fastcall sub_43588C(unsigned __int64);
void __fastcall sub_436810(__int64);
void __fastcall sub_436D15(unsigned __int64, __int64);
__int64 *__fastcall sub_436D71(__int64, __int64 *, unsigned __int64);
__int64 *__fastcall sub_437100(__int64 a1, unsigned __int64 a2);
void __fastcall sub_4371B9(__int64, __int64);
__int64 __fastcall sub_437240(unsigned __int64);
__int64 __fastcall sub_437254(__int64, __int64);
__int64 (*__fastcall sub_437268(__int64))(void);
__int64 __fastcall sub_43727D(__int64);
__int64 __fastcall sub_43731B(__int64, __int64, __int64);
void __fastcall sub_4373B0(__int64 *, __int64, __int64);
char __fastcall sub_437453(__int64 *, unsigned __int64 *, unsigned __int64, __int64);
_BOOL8 __fastcall sub_437599(__int64);
__int64 __fastcall sub_437606(unsigned __int64);
__int64 __fastcall sub_43762C(__int64 a1, unsigned __int64 a2, unsigned int a3, int a4, int a5, __int64 a6);
__int64 sub_4378A4();
__int64 __fastcall sub_4378AA(__int64, __int64);
__int64 __fastcall sub_4379ED(int, __int64, int);
__int64 __fastcall sub_437A0D(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_437A1A(unsigned int);
unsigned __int64 __fastcall sub_437AA9(__int64, __int64, __int64);
__int64 __fastcall sub_437B03(char, int);
__int64 __fastcall sub_437B3E(int, int *);
__int64 __fastcall sub_437BCC(const char *);
__int64 __fastcall sub_437CA8(__int64);
__int64 __fastcall sub_437D19(int a1);
__int64 __fastcall sub_437D47(__int64, __int64, __int64);
bool __fastcall sub_437DB6(int, int);
unsigned __int64 __fastcall sub_437DD1(_BYTE *a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
unsigned __int64 __fastcall sub_437E75(int, __int64, __int64);
void __fastcall sub_437F99(__int64);
__int64 __fastcall sub_437FC9(__int64, __int64, __int64);
__int64 __fastcall sub_437FE2(int, __int64, __int64);
unsigned __int64 __fastcall sub_438106(__int64);
unsigned __int64 __fastcall sub_438122(unsigned __int64 *, __int64);
__int64 __fastcall sub_43814E(char *, char **, int);
__int64 __fastcall sub_438178(char *, char **, int);
__int64 __fastcall sub_438380(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_438390(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_4383A0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_4383B0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_4383C0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_4383D0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_4383E0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_438400(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_438410(__int64 (__fastcall *)(__int64, __int64), __int64, __int64, unsigned __int64, char, long double);
__int64 __fastcall sub_4386B4(__int64 (__fastcall *)(__int64, __int64), __int64, __int64, __int64, int, unsigned int, unsigned int, unsigned __int8, __int64);
__int64 __fastcall sub_438B80(__int64 (__fastcall *)(), __int64, _BYTE *, __int64, __int64);
__int64 sub_438FFB(__int64, __int64, _BYTE *, ...);
__int64 __fastcall sub_43907A(__int64 (__fastcall *)(__int64, __int64), __int64, int);
__int64 sub_4390BD(__int64, _BYTE *, ...);
__int64 sub_43914E(__int64, unsigned __int64, ...);
__int64 __fastcall sub_4391D4(unsigned int (__fastcall *)(_QWORD), __int64, unsigned __int64, char, unsigned __int64, unsigned __int64, char, unsigned __int8);
void *__fastcall sub_439554(unsigned int);
__int64 __fastcall sub_43956E(unsigned int, __int64, __int64);
__int64 __fastcall sub_43962C(char, _QWORD *);
__int64 __fastcall sub_439652(__int64, __int64, _BYTE *, __int64, __int64);
__int64 __fastcall sub_4396A1(_QWORD *);
__int64 __fastcall sub_4396C3(__int64, unsigned __int64, int *);
__int64 __fastcall sub_4396ED(__int64 (__fastcall *)(__int64), __int64, unsigned __int64, int *);
__int64 __fastcall sub_439F54(__int64, _DWORD *);
__int64 __fastcall sub_439F63(_WORD *, unsigned __int64, unsigned int, char);
__int64 __fastcall sub_439F72(unsigned __int8 *, int *);
__int64 __fastcall sub_439F81(__int64);
__int64 __fastcall sub_439FB4(__int64);
__int64 __fastcall sub_439FDC(__int64, _DWORD *);
__int64 __fastcall sub_43A03D(_WORD *, unsigned __int64, unsigned int, char);
__int64 __fastcall sub_43A0CE(__int64, __int64);
__int64 __fastcall sub_43A0EB(__int64, __int64);
char *__fastcall sub_43A117(__int64, __int64, unsigned __int64);
void __fastcall sub_43A17B(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_43A1BD(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_43A1F2(unsigned __int8 *, int *);
__int64 __fastcall sub_43A2A2(_BYTE *, unsigned __int64, unsigned int, int);
unsigned __int64 __fastcall sub_43A304(unsigned __int64, __int64, __int64, unsigned __int64, int *);
__int64 __fastcall sub_43A36F(__int64, __int64, __int64);
__int64 __fastcall sub_43A438(_BYTE *, __int64, unsigned __int8 *, __int64, __int64);
_DWORD *__fastcall sub_43A823(unsigned __int64, unsigned __int64);
void __fastcall sub_43A84E(__int64, __int64, __int64, unsigned __int64);
__int64 __fastcall sub_43A8A2(unsigned __int64, unsigned __int64);
__int64 __fastcall sub_43A8B2(_QWORD); // weak
unsigned __int64 __fastcall sub_43A91D(__int128, _DWORD *);
void __fastcall sub_43AA20(__int64 a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5);
__int64 __fastcall sub_43AA7D(_QWORD, _QWORD, _QWORD); // weak
void __fastcall sub_43AAA0(__int64, __int64, unsigned __int64);
void __fastcall sub_43AAB4(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX);
void __fastcall sub_43ABC2(_BYTE *, _BYTE *, __int64);
void __fastcall sub_43ABE2(__int64, __int64, unsigned __int64);
void __fastcall sub_43ABFC(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3);
__int64 __fastcall sub_43ACAE(_QWORD *, __int64, __int64, __int64, __int64, __int64, char);
__int64 __fastcall sub_43ACDD(__int64, __int64, __int64);
__int64 __fastcall sub_43AD14(_QWORD, _QWORD); // weak
__int64 __fastcall sub_43AD1A(_QWORD, _QWORD); // weak
void sub_43AD27();
void sub_43AD3B();
__int64 __fastcall sub_43AD53(_QWORD); // weak
char *__fastcall sub_43AD57(__int64, unsigned __int64);
__int64 __fastcall sub_43AE48(__int64, __int64);
__int64 __fastcall sub_43AE6F(__int64, unsigned int);
__int64 __fastcall sub_43AE81(__int64, unsigned int);
__int64 __fastcall sub_43AE92(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_43AEF4(__int64, __int64, unsigned int);
void __fastcall __noreturn sub_43B001(__int64, __int64, __int64);
__int64 __fastcall sub_43B03A(int, int);
__int64 sub_43B0C6();
__int64 __fastcall sub_43B0EA(__int64);
__int64 __fastcall sub_43E760(); // weak

//-------------------------------------------------------------------------
// Data declarations

int dword_400000 = -17958193; // weak
_UNKNOWN locret_408000; // weak
_UNKNOWN loc_408080; // weak
char byte_43B032[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_43C320[] = { 321323008 }; // weak
char *off_43C350[2] = { "default", "string" }; // weak
int dword_43C380[] = { 16 }; // weak
int dword_43C3C0[] = { 4 }; // weak
char *off_43C400 = "hidden"; // weak
__int64 qword_43C420[2] = { 7LL, 0LL }; // weak
char byte_43C4B1[4] = { 'n', 'o', 't', ' ' }; // weak
int dword_43C614 = 1852785538; // weak
char byte_43CB7B[5] = { 'i', 'n', 'v', 'a', 'l' }; // weak
char byte_43D280[] = { '\x01' }; // weak
__int128 xmmword_43D2F0 = 0x08000000000000000LL; // weak
__int16 word_43D4F8[] = { 100 }; // weak
char byte_43D579[7] = { 'u', 'n', 't', 'e', 'r', 'm', 'i' }; // weak
__int16 word_43D960[] = { 957 }; // weak
__int16 word_43D962[] = { -1147 }; // weak
char byte_43DA00[] = { 'E' }; // weak
char byte_43DA30[7] = { 'r', 'e', 'g', 'e', 'x', 'p', ' ' }; // weak
char byte_43DB74[] = { '\x01' }; // weak
char byte_43DB77 = '\0'; // weak
_UNKNOWN off_43DC40; // weak
__int64 qword_43DCA0[4] = { 18014647620665344LL, 27022010087243867LL, 4294901883LL, 0LL }; // weak
__int64 qword_43DCC0[8] =
{
  8725784408096768LL,
  1621015082376822817LL,
  2305587987344070273LL,
  2318826223442534411LL,
  3458518636075819056LL,
  -1095233556479LL,
  0LL,
  0LL
}; // weak
__int16 asc_43DD00[4] = { 9, 13, 32, 32 }; // weak
int dword_43DD2C = 3735600; // weak
char byte_43DD30[] = { '\0' }; // weak
char byte_43DD40[] = { '\0' }; // weak
__int64 qword_43DDC0[2] = { -281225865527296LL, 8658703LL }; // weak
__int16 a09azAz[8] = { 48, 57, 65, 90, 95, 95, 97, 122 }; // weak
char byte_43DDE0[] = { '\x17' }; // weak
__int64 qword_43DEE0[92] =
{
  -4609794308621466720LL,
  4638748917007171591LL,
  -1512960434333736906LL,
  -7997404588895927999LL,
  2631799029593452803LL,
  2449993488701191183LL,
  -6485178777599934335LL,
  1387120953874033696LL,
  1436669518542131209LL,
  8263155480452992248LL,
  69877228538971124LL,
  280844960599765377LL,
  1082214144369165028LL,
  6926369234383540132LL,
  6953030060136742672LL,
  -9151035987248267138LL,
  -1277906002091736581LL,
  -1436785874570148096LL,
  321479445087184911LL,
  9054626726390255679LL,
  -62556732299210520LL,
  301182813258971041LL,
  1585291314806205705LL,
  -142638533252993256LL,
  1152939304738291267LL,
  5674641247888080915LL,
  -7519603294146900416LL,
  217302008372230401LL,
  943649285386668038LL,
  -4531553490188628584LL,
  -9188397799333414112LL,
  186050565787140476LL,
  -8213285871304900062LL,
  -4603223334895743724LL,
  2310986525795469342LL,
  3477113994514350225LL,
  8638210064810627LL,
  -4593041323844042466LL,
  7149854877961512061LL,
  -7114254988065885632LL,
  5444897650786737509LL,
  -6403371490761031469LL,
  -7098123475796226269LL,
  -559584094558052890LL,
  -3102324763577910950LL,
  883810716231525106LL,
  481891791558495235LL,
  2031176269169561780LL,
  35994154892794960LL,
  1009658167938456715LL,
  1577393328730148867LL,
  -7637820056263241667LL,
  610242654428752130LL,
  6827721019297635395LL,
  7043792821429485312LL,
  7151847601564849536LL,
  7259967527747360448LL,
  7277984949918000192LL,
  7350044743000168448LL,
  7458132783349655040LL,
  7710279936690396608LL,
  8971351604091462272LL,
  9025325255790459968LL,
  -8178423671312846912LL,
  -8106366901799609973LL,
  -7998286558035699317LL,
  -2521836293617311232LL,
  -2179464314329440896LL,
  -936481537359025280LL,
  -143853500051163712LL,
  -6357056268808356800LL,
  -880475683295905920LL,
  -51799058007199737LL,
  5352794789937478663LL,
  5496706843256822400LL,
  1732585994894988168LL,
  1786691552136599563LL,
  1966840485050539975LL,
  1966837736305038400LL,
  4362743392229889216LL,
  -2132069285790925685LL,
  -1555543692311665687LL,
  -1483487472529074240LL,
  -1393398987290469568LL,
  -1411412836031553216LL,
  -1015015628313340694LL,
  -1033118438720412375LL,
  2309573207646036871LL,
  57440LL,
  0LL,
  0LL,
  0LL
}; // weak
__int64 qword_43E1C0[180] =
{
  -4609513383392181352LL,
  4674956256001179654LL,
  7818427624294826058LL,
  -5979790751096307391LL,
  4909494661393319939LL,
  2046919327576099855LL,
  -8502791419251711888LL,
  6002244249608028160LL,
  2088843580248320008LL,
  8221567581902276285LL,
  4681492878080610316LL,
  280564035370480001LL,
  1082216343358866149LL,
  7502821190594203552LL,
  -4000031598654243312LL,
  2436727434488324223LL,
  -197050885468093961LL,
  -2877938708812691648LL,
  349063949855153167LL,
  -8808894598236618689LL,
  -4349719515447787136LL,
  654150735935946754LL,
  -26881784096170838LL,
  -4611681603124946288LL,
  1414151382290241545LL,
  6827533079102947473LL,
  198581427149823616LL,
  245449506680840449LL,
  1026877920649873510LL,
  -9070372659250852104LL,
  -4570801493445163904LL,
  216938599352992401LL,
  -4609220878581365799LL,
  1163855220337021508LL,
  217946364388050982LL,
  -6320897979024661568LL,
  7506520555599171352LL,
  -4035127399505565908LL,
  3606593945266794675LL,
  -1957938391368041983LL,
  -8084830164740873100LL,
  -6377194367386141229LL,
  -7058793941682943106LL,
  -6900168575125250466LL,
  -2161726260983906207LL,
  487516609595040384LL,
  432356597495489539LL,
  -4097510264446971752LL,
  -4395297181186078926LL,
  -3673806207678086782LL,
  -8214407665526746033LL,
  2822915614483677633LL,
  4129812957171664656LL,
  292755416657432512LL,
  2594099979902523280LL,
  2256330970244323632LL,
  2567079825576565088LL,
  1909554829892524496LL,
  1787961419475458928LL,
  -4178736753073446944LL,
  -4097671132347226640LL,
  1747437406475265280LL,
  1851021159983752544LL,
  1801482390364366080LL,
  1814993257954420272LL,
  1837511324781389376LL,
  8847926340137133680LL,
  1810490896552175568LL,
  -4120186796920264752LL,
  8897468339969468480LL,
  2634650724994131984LL,
  1954607662469490752LL,
  8928994430709016944LL,
  3994753962054005760LL,
  4188414037421210208LL,
  4107350755957029936LL,
  4201926073259146528LL,
  4355047910855949664LL,
  4183914011210825712LL,
  3976748359735066384LL,
  5544015048735735792LL,
  4688467257242732545LL,
  4778540074425960513LL,
  5075777374975477793LL,
  8618437925103388705LL,
  9001244513554061265LL,
  4170609240529037665LL,
  1432730459180236433LL,
  -4174055986161379294LL,
  2549255788771198466LL,
  8703901355107078114LL,
  8951603868706961850LL,
  -1145110314237643478LL,
  8648402267818596354LL,
  -8790704311945159680LL,
  6917635819643652097LL,
  1747423215985653280LL,
  4441686583048678408LL,
  -4590417512157151187LL,
  -5187565322296524790LL,
  1443036447127130136LL,
  -6336741142494694083LL,
  2114697737627792448LL,
  551402882719029288LL,
  -9102551093431892406LL,
  4881919182407041490LL,
  5258006372900077793LL,
  3604872283606009884LL,
  -4427095052026706113LL,
  -526657121350000317LL,
  512352854913588328LL,
  -8084944813963657422LL,
  3526638960050783172LL,
  1458696773980408056LL,
  -3710538318115556857LL,
  -1070885289011722609LL,
  4500499864050268336LL,
  -9113298694082263268LL,
  2554386398333931468LL,
  -7711068438156201742LL,
  -7705897285031865282LL,
  8322904190704667777LL,
  -231904143618280925LL,
  1094162718578720436LL,
  64532315531674007LL,
  -4027263731670768781LL,
  3980955602678371580LL,
  -1926469098577750769LL,
  2047160569028637568LL,
  4553710265999621320LL,
  4886563704207249215LL,
  5258850815010078957LL,
  3605083389838608412LL,
  -3274173546614536385LL,
  -310479941189702333LL,
  566396050458811496LL,
  -8084944607801032910LL,
  3527764859958412244LL,
  -3152989240152012549LL,
  -3710485540483681785LL,
  -782654912658680177LL,
  4500500963561896880LL,
  -9099787620322244644LL,
  2554456844388634572LL,
  -6557865457513369354LL,
  -4034823672957563897LL,
  7503123289272721793LL,
  2055924638841795392LL,
  4553710506519887560LL,
  4675457471677661575LL,
  -5180035707217698703LL,
  -8933402202186313702LL,
  -3710461410250116601LL,
  6917635819643660687LL,
  1747423903169968643LL,
  4576789933262700040LL,
  1126183050444308911LL,
  243194799181816049LL,
  583286624240892156LL,
  -3657162564082129665LL,
  8421998551642526209LL,
  -49260030439956064LL,
  527492477243366608LL,
  -8084944539306344654LL,
  -504891993718701829LL,
  -1945616491145967587LL,
  2522017948257178119LL,
  702571164752225024LL,
  -2853309433695412161LL,
  -679198517498216418LL,
  9017895454182178825LL,
  -3431568049146511230LL,
  -8643924080455411710LL,
  -7349133511737570038LL,
  7097575708788034301LL,
  773730967447677648LL,
  7998088LL,
  0LL,
  0LL,
  0LL
}; // weak
__int64 qword_43E9A0[8] =
{
  7199565933680062719LL,
  -5120556664264641551LL,
  -1872438489054480LL,
  -4548355087930227472LL,
  2165951042338426633LL,
  61685LL,
  0LL,
  0LL
}; // weak
__int64 qword_43E9E0[140] =
{
  1094101409150841081LL,
  164382210043674159LL,
  2450529058895852303LL,
  -452058489355571198LL,
  -1136701573374414494LL,
  -787543070708121675LL,
  148375912000327474LL,
  724970637083275266LL,
  291157207487421169LL,
  5976320340659276047LL,
  -6987330357700708225LL,
  7089492729759395841LL,
  13249175278793732LL,
  1324730023656360219LL,
  157350074803887890LL,
  1100024422761243266LL,
  1401477142356758276LL,
  1301557077350703856LL,
  3756657406798397743LL,
  1083325872059187730LL,
  1082254186921488934LL,
  -1143225989327804916LL,
  80785594904777330LL,
  148499976600814623LL,
  -1142524153116546810LL,
  2090499449708315266LL,
  180971101341494383LL,
  1314777378328877714LL,
  7300068157995233551LL,
  302960542271062001LL,
  460195107397510424LL,
  3901031937828122883LL,
  2526870285911532320LL,
  4549525331457024054LL,
  3838808440226967859LL,
  -6417608643191636401LL,
  3454261188041946355LL,
  -1008472331280977920LL,
  4870911505723626831LL,
  2594056256818127601LL,
  2931826615389053936LL,
  -1058610601066857744LL,
  -1073001370943028225LL,
  4895741666233748687LL,
  1464287921194660232LL,
  3821551670485056262LL,
  3395749441774622271LL,
  4838627555502538511LL,
  -1089764499501458379LL,
  8089626261199058220LL,
  -1130293335556939744LL,
  -1012481520415336129LL,
  460195219679737842LL,
  7096248054516871683LL,
  4787153103615058530LL,
  3784352930280046095LL,
  1976837562969507423LL,
  36013452173528623LL,
  -8103663544413396737LL,
  -71442906825556164LL,
  5763832497795465187LL,
  1094357252287017216LL,
  2683959833596608575LL,
  -1150899351826271692LL,
  4613360720932775167LL,
  990774359105523489LL,
  -5464796055852802161LL,
  535910933439977775LL,
  2319411262412443456LL,
  -6470206098518662416LL,
  -4394064353218778LL,
  2404649382916522239LL,
  218141526386077951LL,
  -4426472982250475531LL,
  -66480918003318206LL,
  -1070098384721781280LL,
  752085156992710315LL,
  3617856447369382527LL,
  3323941500545358833LL,
  -61502336445451971LL,
  -1220440374216028705LL,
  6274709513401954062LL,
  6851188827744104740LL,
  -76569832470323436LL,
  167629891019250178LL,
  8858716737811825393LL,
  7777746462061101040LL,
  1094972328149299184LL,
  -3102948395126214143LL,
  -1004918510220615696LL,
  6931022504658727019LL,
  -1063146109848150029LL,
  477293655658200655LL,
  2152706490887557112LL,
  -1085344626878369807LL,
  -1151813055701576753LL,
  -862106166418661264LL,
  -1071980779260403610LL,
  4621855564786250119LL,
  4895453545497903344LL,
  2333410102988595440LL,
  2337352486775402490LL,
  -6920941792012377872LL,
  -1067230008856019701LL,
  2315114191102933264LL,
  -3499032477505167120LL,
  -7422168237555519458LL,
  -716564981269654225LL,
  -5336641381967388378LL,
  4314728822513610529LL,
  -3519283699675938832LL,
  -7206234414223723176LL,
  -117114489099059697LL,
  -2161819011866714349LL,
  5760119591280807723LL,
  247422139276455968LL,
  -5263738126628232705LL,
  -68100373527710705LL,
  -7351336195718928LL,
  2530743706563117552LL,
  -1729524227067280593LL,
  71951528825910776LL,
  221647196065651206LL,
  3680271447792693779LL,
  7062842901410112114LL,
  3389291911335829759LL,
  3389291936833154831LL,
  2812831184529731343LL,
  1081549850956851455LL,
  -357784386032171266LL,
  -8990594364489912993LL,
  2315739920072772399LL,
  2315169204821585952LL,
  3683980917050712112LL,
  7061977544372986662LL,
  -8141662666285306076LL,
  -937100627256475393LL,
  5717039287055416444LL,
  -5620985182439801088LL,
  18048547795631679LL
}; // weak
char byte_43EE40[] = { '0' }; // weak
__int128 xmmword_43EEA0 = 9223372036854775807LL; // weak
__int16 word_43EEC0[] = { 12336 }; // weak
__int16 word_43F0C0[] = { -1 }; // weak
char byte_43F2C0[] = { '0' }; // weak
char byte_43F2E0[] = { '0' }; // weak
__int16 word_43F420[] = { 208 }; // weak
int dword_43F480[] = { 132097 }; // weak
char byte_43F4B0[] = { '\x1F' }; // weak
char byte_43F4C0[] = { '+' }; // weak
char a5a1962[15] = "5A1=-9)*6&2>.:"; // weak
char byte_43F548[3] = { '%', 'c', '\0' }; // weak
char byte_43F54B[3] = { '%', 'x', '\0' }; // weak
__int16 word_43F54E = 44; // weak
char byte_43F630[] = { '\0' }; // weak
__int64 qword_43F650[2] = { -6052670395461402624LL, 1LL }; // weak
char byte_43F6C0 = '\x90'; // weak
__int64 qword_440780[] = { 0LL }; // weak
__int64 qword_440D60[121] =
{
  5622297357523691599LL,
  6498184280988551990LL,
  8152473152851150968LL,
  -6455711671833507391LL,
  -7918721904675113849LL,
  4654034263355904156LL,
  1773367197787085876LL,
  -7532541719314545882LL,
  -3919960777521525628LL,
  1784561213637511636LL,
  3513335649183885536LL,
  2052294273107601522LL,
  -5663483702738656764LL,
  8878359005179692736LL,
  7062907076892168732LL,
  628381840671517452LL,
  6577453955907786948LL,
  -7017156388178523008LL,
  -2805490730245029481LL,
  1571246680965179881LL,
  1784560942822196334LL,
  332380690084989543LL,
  8192963000304929890LL,
  -5178994866074923071LL,
  -268999874599660474LL,
  1355552867185430651LL,
  -6842141346813877248LL,
  4161827477563533329LL,
  1968464485054759333LL,
  988897219138556486LL,
  2970503563740306804LL,
  8186646946475216325LL,
  -6829503137859618985LL,
  -2095068512088400730LL,
  -5491073990389425786LL,
  -6590867609311044982LL,
  7316458372864781849LL,
  5695177908036645911LL,
  -8488053202694346616LL,
  8699522788359638150LL,
  3964730435499923065LL,
  8349972791946439748LL,
  -7329605490999803754LL,
  -7634995225351779757LL,
  -8823599697535695513LL,
  -4300405888781301693LL,
  -8595123719286118348LL,
  -9192136001092038551LL,
  -1302123662595368834LL,
  -4698529874120283241LL,
  -4738402522876490054LL,
  7819463996161004300LL,
  3251612268630204900LL,
  -7272458321901090460LL,
  7246931194829522473LL,
  5317836587758248675LL,
  -4304049919753068404LL,
  -966291447619848023LL,
  -6583548966765347863LL,
  8250983508290305535LL,
  479189742998543614LL,
  3471283418593992584LL,
  4859747861770493742LL,
  8782265563431881037LL,
  661626497931292716LL,
  -4611646166346034995LL,
  -4195341020138859755LL,
  -3004246808211721005LL,
  8580317626506011347LL,
  -3903251758819755995LL,
  907580950826722509LL,
  7465356944688288794LL,
  -1043689006724642532LL,
  -8492609283506477015LL,
  154837919678871991LL,
  256022953439923252LL,
  -3567657289051965688LL,
  -7551183775725448884LL,
  -4003556805329782886LL,
  -1287159363905663347LL,
  5652843209757007986LL,
  6544542185331901604LL,
  4176940771975250458LL,
  3770701149507503184LL,
  6746518058896541195LL,
  3842916570250178824LL,
  2747285864337480436LL,
  7230555383397421636LL,
  -5942213004812466579LL,
  -5262465977343531864LL,
  7537964608910315944LL,
  7971487319590420047LL,
  -2328942566950056201LL,
  -4131503188798612770LL,
  -8747478151154893948LL,
  -2884826533704795241LL,
  -3533330587426361489LL,
  3304199210468055719LL,
  5395073984223850266LL,
  4617353455945289752LL,
  4929264229200006808LL,
  2910623094599155980LL,
  955086761360931112LL,
  -2953783470861311292LL,
  1030710135448769921LL,
  3487267884450812008LL,
  2652999315646137396LL,
  5508681092017297129LL,
  8114575834266112488LL,
  -6754185273365175959LL,
  8389108554097911155LL,
  -7755047434963483604LL,
  -3681448442618362232LL,
  -2493929003794514716LL,
  7769067946069235225LL,
  -6590916212052270300LL,
  7793701089146301233LL,
  -4885340056111279415LL,
  2785521167162429442LL,
  -3527389408511738300LL,
  2508509747418846880LL
}; // weak
__int16 word_4411DA = 29477; // weak
char byte_441B49[7] = { 'c', 'b', 'o', 'r', ' ', 'd', 'e' }; // weak
__int64 qword_441B70[3] = { 0LL, 0LL, 0LL }; // weak
char byte_441EA0[] = { '\0' }; // weak
char byte_441FA0[] = { '\0' }; // weak
char byte_4420A0[] = { '\0' }; // weak
char byte_4421C0[] = { '\x80' }; // weak
void (__fastcall *funcs_42A8DF[2])(__m128, double) = { &sub_42A673, &sub_4203F7 }; // weak
__int64 (__fastcall *funcs_42A889[17])() =
{
  &sub_42A620,
  &sub_42A66E,
  &sub_42A669,
  &sub_42A664,
  &sub_42A65F,
  &sub_42A65A,
  &sub_42A655,
  &sub_42A64B,
  &sub_42A650,
  &sub_42A7A1,
  &sub_42A646,
  &sub_42A641,
  &sub_42A63C,
  &sub_42A637,
  &sub_42A632,
  &sub_42A62D,
  &sub_42A628
}; // weak
int dword_442410[] = { 144 }; // weak
_UNKNOWN sub_4424B4; // weak
char byte_442660[] = { '\x03' }; // weak
char byte_442680[] = { '\xFD' }; // weak
char byte_442780[] = { 'A' }; // weak
__int64 qword_442920[] = { 4357843414468748770LL }; // weak
__int64 qword_442940[] = { 4602023952714414927LL }; // weak
__int64 qword_442A90[] = { 0LL }; // weak
__int64 qword_442A98[] = { 4607182418800017408LL }; // weak
__int64 qword_443300[] = { 4609176140020449280LL }; // weak
__int64 qword_443308[] = { 4460540536611119616LL }; // weak
__int64 qword_444C88[] = { 4609047190520725504LL }; // weak
__int64 qword_444C98[] = { -4623459026519603200LL }; // weak
__int64 qword_444CA0[] = { 4394022453839877760LL }; // weak
__int64 qword_445D00[] = { 4609753056584663040LL }; // weak
int dword_445D40[] = { 10680707 }; // weak
int dword_446810[] = { 3 }; // weak
char byte_446918[3] = { '=', '=', '\0' }; // weak
char byte_44691B[3] = { '!', '=', '\0' }; // weak
int dword_446A10[] = { 365 }; // weak
int dword_446A20[] = { 31 }; // weak
char byte_446A80[4] = { 'U', 'T', 'C', '\0' }; // weak
int dword_446A84 = 2105376; // weak
char byte_446A88[2] = { '?', '\0' }; // weak
__int16 word_446A8A = 19792; // weak
char byte_446A8D[3] = { 'A', 'M', '\0' }; // weak
char byte_446A90[2] = { '-', '\0' }; // weak
__int16 word_446A92 = 43; // weak
char aJanuary[8] = "January"; // weak
__int64 qword_446E10[6] =
{
  27695899046994250LL,
  32211571827695949LL,
  31091208134156621LL,
  29120844641629514LL,
  32760288259368275LL,
  27977365434298190LL
}; // weak
char aSunday[7] = "Sunday"; // weak
char byte_446E87[] = { 'S' }; // weak
__int64 qword_446EC0[2] = { 24LL, 0LL }; // weak
int dword_446F20[] = { 1 }; // weak
char byte_446FD3[5] = { '\x01', '\xC0', '\x01', '\xC0', '\x01' }; // weak
__int16 word_447006 = 13; // weak
__int16 word_447020[] = { 3 }; // weak
__int16 word_447060[] = { 1 }; // weak
char byte_4470A0[] = { '\0' }; // weak
char byte_4470C0[] = { '\0' }; // weak
char byte_4470E0[] = { '\x10' }; // weak
char byte_4470F3 = '\x90'; // weak
__int64 qword_447100[64] =
{
  2766659581575299232LL,
  2315455352824604262LL,
  2756807536476366296LL,
  2755119313691747904LL,
  2322768432283788730LL,
  2425229820014559414LL,
  2418469911410188689LL,
  2719089722022699551LL,
  9886928818208800LL,
  2312598571865931812LL,
  12103604389871656LL,
  13229521476845612LL,
  14355438563819568LL,
  15481355650793524LL,
  16607272737767480LL,
  2325827998852120636LL,
  18859106911715392LL,
  19985023998689348LL,
  21110941085663304LL,
  22236858172637260LL,
  23362775259611216LL,
  24488692346585172LL,
  25614609433559128LL,
  26740526520533084LL,
  27866443607507040LL,
  28992360694480996LL,
  30118277781454952LL,
  31244194868428908LL,
  32370111955402864LL,
  33496029042376820LL,
  34621946129350776LL,
  2522579282454970492LL,
  63614345480503495LL,
  65021703182352612LL,
  67273515881660650LL,
  55451412241055982LL,
  68680744735998153LL,
  70088347253604598LL,
  45599891133956351LL,
  113188863754961059LL,
  70369787870249185LL,
  52355075826319601LL,
  53199509920940223LL,
  52636555094851772LL,
  2666735243277510033LL,
  2690378930864596260LL,
  2690660332826994005LL,
  2670675652429751645LL,
  2674053150284195092LL,
  2692912188472698112LL,
  2694882560555885914LL,
  2695164048417236320LL,
  2691223368679826792LL,
  2696289840950027608LL,
  2704452310328157546LL,
  2702201077457757572LL,
  270219907551921073LL,
  271345983600919459LL,
  266842302366352294LL,
  2461502747321967134LL,
  2478143512159265377LL,
  2470225457059013408LL,
  2457277333235105968LL,
  268849971895345279LL
}; // weak
char byte_447300[] = { '\0' }; // weak
char byte_448000[4104] =
{
  '\x0F',
  '\x04',
  '\x06',
  '\x05',
  '\x03',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\r',
  '\t',
  '\v',
  '\a',
  '\x1B',
  '\x02',
  '\x1C',
  '\x1D',
  '\x1F',
  ' ',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x0F',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
__int64 (__fastcall *qword_449020)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47AC8LL; // weak
__int64 (__fastcall *qword_449028)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47AD6LL; // weak
__int64 (__fastcall *qword_449030)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47AF0LL; // weak
__int64 (__fastcall *qword_449038)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47AFELL; // weak
__int64 (__fastcall *qword_449040)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47B10LL; // weak
__int64 (__fastcall *qword_449048)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47B1ELL; // weak
__int64 (__fastcall *qword_449050)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47B32LL; // weak
__int64 (*qword_449068)(void) = (__int64 (*)(void))0x47B70LL; // weak
__int64 (__fastcall *qword_449070)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47B80LL; // weak
__int64 (*qword_449078)(void) = (__int64 (*)(void))0x47B92LL; // weak
__int64 (__fastcall *qword_449098)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47C00LL; // weak
__int64 (*qword_4490A0)(void) = (__int64 (*)(void))0x47C0ELL; // weak
__int64 qword_4490A8 = 293918LL; // weak
__int64 (__fastcall *qword_4490B8)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47C3ELL; // weak
__int64 (__fastcall *qword_4490C0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47C58LL; // weak
__int64 (__fastcall *qword_4490C8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47C6ELL; // weak
__int64 (__fastcall *qword_4490D0)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47C7ALL; // weak
__int64 (__fastcall *qword_4490D8)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47C8ALL; // weak
__int64 (__fastcall *qword_4490E0)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47C9CLL; // weak
__int64 (__fastcall *qword_4490F0)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x47CCELL; // weak
__int64 (__fastcall *qword_4490F8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x47CE0LL; // weak
int dword_44DB80 = 101010256; // weak
__int64 qword_44E000; // weak
char byte_44E03C; // weak
char byte_44E03D; // weak
char byte_44E328[256]; // weak
__int64 qword_44E428; // weak
char byte_44E430[256]; // weak
char byte_44E530[256]; // weak
_UNKNOWN unk_44E630; // weak
_UNKNOWN unk_44E640; // weak
__int64 qword_44EB58; // weak
int dword_44EB70; // weak
__int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int dword_44EBA8; // weak
__int64 qword_44EBB0; // weak
int dword_44EBB8; // weak
int dword_44EBC0; // weak
__int64 qword_44EBC8; // weak
int dword_44EBD0; // weak
int dword_44EBD8; // weak
int dword_44EBE0; // weak
int dword_44EBE8; // weak
int dword_44EBF0; // weak
int dword_44EBF8; // weak
int dword_44EC00; // weak
int dword_44EC08; // weak
int dword_44EC10; // weak
int dword_44EC18; // weak
__int64 qword_44EC20; // weak
int dword_44EC28; // weak
int dword_44EC30; // weak
int dword_44EC38; // weak
int dword_44EC40; // weak
__int64 qword_44EC48; // weak
int dword_44EC50; // weak
__int64 qword_44EC78; // weak
__int64 qword_44EC80; // weak
__int64 qword_44EC88; // weak
__int64 qword_44EC98; // weak
__int64 qword_44ECA0; // weak
__int64 qword_44ECA8; // weak
__int64 qword_44ECB0; // weak
__int64 qword_44ECB8; // weak
__int64 qword_450038; // weak
__int64 qword_452038; // weak
char byte_452040; // weak
char byte_452041; // weak
int dword_452048; // weak
int dword_45204C; // weak
__int64 qword_452050; // weak
int dword_452058; // weak
int dword_45205C; // weak
__int64 qword_452060; // weak
__int64 qword_452080; // weak
__int64 qword_452090; // weak
int dword_4520E0; // weak
int dword_4520E4; // weak
__int64 qword_4520E8[]; // weak
__int64 qword_4520F0; // weak
__int64 qword_4520F8; // weak
__int64 qword_452100; // weak
__int64 qword_452108; // weak
__int64 qword_452110; // weak
__int64 qword_452118; // weak
__int64 qword_452120; // weak
_UNKNOWN unk_452128; // weak
_UNKNOWN unk_452328; // weak
__int64 qword_452338[32]; // weak
__int64 qword_452438; // weak
__int64 qword_452440; // weak
__int64 qword_452448; // weak
int dword_452450; // weak
__int64 qword_452458; // weak
__int64 qword_452460; // weak
__int64 qword_452468; // weak
int dword_452470; // weak
__int64 qword_4524A0; // weak
__int64 qword_4524A8; // weak
__int64 qword_4524B0; // weak
__int64 qword_4524B8; // weak
__int64 qword_4524C0; // weak
int dword_4524C8; // weak
__int64 qword_4524E0; // weak
_UNKNOWN unk_4524E8; // weak
_UNKNOWN unk_4527F8; // weak
__int64 qword_452800[]; // weak
int dword_452808[]; // weak
int dword_45280C[595]; // weak
_BYTE byte_453158[8]; // weak
_BYTE byte_453160[8]; // weak
__int64 qword_453168[303]; // weak
__int64 qword_453AE0; // weak
__int64 qword_453AE8; // weak
__int64 qword_453AF0; // weak
_UNKNOWN unk_453AF8; // weak
int dword_453CA8; // weak
__int64 qword_453CB0; // weak
__int64 qword_453CB8; // weak
char byte_453CC0; // weak
__int64 qword_453CC8; // weak
__int64 qword_453CD0; // weak
__int64 qword_453CD8; // weak
__int64 qword_453CE0; // weak
int dword_453D68; // weak
char byte_453D6C; // weak
_UNKNOWN unk_453D6D; // weak
_UNKNOWN unk_453F80; // weak
__int64 qword_454080[]; // weak
__int64 qword_454088; // weak
__int64 qword_454090; // weak
__int64 qword_454098; // weak
_UNKNOWN unk_4540A0; // weak
int dword_4540AC; // weak
int dword_4540B0; // weak
int dword_4540B4; // weak
int dword_4540B8; // weak


//----- (0000000000400675) ----------------------------------------------------
void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2)
{
  unsigned __int8 v2; // al

  while ( 1 )
  {
    v2 = __inbyte(a2 + 5);
    if ( (v2 & 0x20) != 0 )
      break;
    _mm_pause();
  }
  __outbyte(a2, a1);
}

//----- (0000000000400748) ----------------------------------------------------
__int64 __fastcall sub_400748(int a1, int a2)
{
  qmemcpy((void *)(a1 & 0xFFFF8000), (const void *)(unsigned int)(a1 - a2), a1 - a2 - (a1 & 0xFFFF8000));
  return (unsigned int)(a1 - a2);
}

//----- (0000000000401000) ----------------------------------------------------
void __fastcall __noreturn sub_401000(__int64 a1, __int64 a2, __int64 a3)
{
  dword_4540B8 |= 2u;
  if ( (dword_44EB70 & 4) == 0 )
  {
    a3 = 0LL;
    __asm
    {
      syscall; Low latency system call
      syscall; Low latency system call
    }
    a2 = 6LL;
    __asm { syscall; Low latency system call }
  }
  sub_43B001(134LL, a2, a3);
}
// 44EB70: using guessed type int dword_44EB70;
// 4540B8: using guessed type int dword_4540B8;

//----- (0000000000401158) ----------------------------------------------------
__int64 __fastcall sub_401158(unsigned __int64 a1, int a2, __int64 a3, __int64 *a4)
{
  char i; // cl
  __int64 v6; // rax
  __int64 *v8; // rdx
  __int64 v9; // rax

  for ( i = 39; ; i -= 9 )
  {
    --a2;
    v6 = (a1 >> i) & 0x1FF;
    if ( a2 == -1 )
      break;
    v8 = (__int64 *)(a3 + 8 * v6);
    if ( !*v8 )
    {
      v9 = *a4 - 4096;
      *a4 = v9;
      *v8 = v9 | 3;
    }
    a3 = *v8 & 0x3FFFFFFFFF000LL;
  }
  return a3 + 8 * v6;
}

//----- (000000000040126D) ----------------------------------------------------
__int64 sub_40126D()
{
  return 0LL;
}

//----- (000000000040129E) ----------------------------------------------------
#error "40129E: function frame is wrong (funcsize=0)"

//----- (00000000004012F0) ----------------------------------------------------
void __fastcall sub_4012F0()
{
  __int64 *v0; // rbx
  __int64 *v1; // rdi
  unsigned __int64 v2; // rax
  _DWORD *i; // rdi
  _BYTE *v4; // r8
  _DWORD *v10; // rdi
  __int64 v11; // [rsp+0h] [rbp-38h]
  __int64 v12; // [rsp+8h] [rbp-30h]
  __int64 v13; // [rsp+10h] [rbp-28h]
  __int64 v14; // [rsp+18h] [rbp-20h]
  __int64 v15; // [rsp+20h] [rbp-18h]
  __int64 v16; // [rsp+28h] [rbp-10h]
  __int64 *v17; // [rsp+30h] [rbp-8h]

  v17 = &qword_44E000;
  qword_453CD8 = 4LL;
  *(&qword_453CD8 + 1) = (__int64)(&qword_453CD8 + 2);
  v1 = v17;
  v2 = __rdtsc();
  *(_DWORD *)v1 = v2;
  v1 = (__int64 *)((char *)v1 + 4);
  *(_DWORD *)v1 = HIDWORD(v2);
  i = (_DWORD *)v1 + 1;
  v17 = v0;
  v16 = 0LL;
  v15 = 22LL;
  v14 = -2147483641LL;
  v13 = -2147483647LL;
  v12 = 7LL;
  v11 = 2LL;
  v4 = i;
  _RAX = 0LL;
  while ( 1 )
  {
    __asm { cpuid }
    *i = _RAX;
    v10 = i + 1;
    *v10++ = _RBX;
    *v10++ = _RCX;
    *v10 = _RDX;
    for ( i = v10 + 1; ; i += 4 )
    {
      _RAX = 1LL;
      if ( *v4 )
        break;
    }
  }
}
// 4012F0: could not find valid save-restore pair for rbx
// 40133D: conditional instruction was optimized away because %0x10.4==1
// 401315: variable 'v0' is possibly undefined
// 4490B0: using guessed type __int64 (__fastcall *qword_4490B0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 44E000: using guessed type __int64 qword_44E000;
// 44E03C: using guessed type char byte_44E03C;
// 44EB70: using guessed type int dword_44EB70;
// 450038: using guessed type __int64 qword_450038;
// 452038: using guessed type __int64 qword_452038;
// 453CC8: using guessed type __int64 qword_453CC8;
// 453CD8: using guessed type __int64 qword_453CD8;

//----- (00000000004015A2) ----------------------------------------------------
__int64 __fastcall sub_4015A2(__m128 a1, __m128 a2)
{
  __int64 *v2; // r13
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  int v7; // eax
  __int64 v8; // rsi
  __int64 v9; // rdi
  unsigned int v10; // er14
  __int64 v11; // r12
  __int64 v12; // r15
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  int v17[12]; // [rsp+0h] [rbp-100h] BYREF
  __int64 v18; // [rsp+30h] [rbp-D0h]
  __int64 savedregs; // [rsp+100h] [rbp+0h] BYREF

  v2 = (__int64 *)sub_4033EA(0LL, 0LL, 0LL, 0LL, 0LL, a1, a2);
  sub_40738C(v2, (__int64)sub_4031E2, 0xFFFFFFFF, a1, a2);
  sub_4042B7(v2, (__int64)"NativePrint", a1, a2);
  sub_40738C(v2, (__int64)sub_403189, 0xFFFFFFFF, a1, a2);
  sub_4042B7(v2, (__int64)"NativeAdd", a1, a2);
  v7 = sub_437DD1("zip:examples/hello.js", qword_44EC98, v3, v4, v5, v6, v17[0]);
  if ( v7 == -1 )
    goto LABEL_2;
  v10 = v7;
  if ( (unsigned int)sub_437B3E(v7, v17) == -1 )
    goto LABEL_2;
  v11 = sub_434FC4(v18);
  sub_4373B0(&savedregs, (__int64)sub_437268, v11);
  if ( !v11 )
  {
    v8 = 0LL;
    v9 = 0LL;
LABEL_6:
    sub_401F82(v9, v8);
  }
  v12 = v18;
  v13 = sub_437E75(v10, v11, v18);
  if ( v12 != v13 )
    sub_401F78(v12, v13);
  if ( (unsigned int)sub_437A1A(v10) == -1 )
  {
LABEL_2:
    v8 = -1LL;
    v9 = -1LL;
    goto LABEL_6;
  }
  sub_40338B(v2, v11, 0LL, 3592, a1, a2);
  sub_407D7E(v2, v11, v14, v15, a1, a2);
  sub_403420((__int64)v2, a1, a2);
  return 0LL;
}
// 40160F: variable 'v3' is possibly undefined
// 40160F: variable 'v4' is possibly undefined
// 40160F: variable 'v5' is possibly undefined
// 40160F: variable 'v6' is possibly undefined
// 4016AB: variable 'v14' is possibly undefined
// 4016AB: variable 'v15' is possibly undefined
// 434FC4: using guessed type __int64 __fastcall sub_434FC4(_QWORD);
// 44EC98: using guessed type __int64 qword_44EC98;
// 4015A2: using guessed type int var_100[12];

//----- (00000000004017C2) ----------------------------------------------------
__int64 sub_4017C2()
{
  __int64 result; // rax

  result = 2105376LL;
  qword_454080[0] = (__int64)&dword_4540B4;
  qword_454088 = (__int64)&dword_4540B4;
  dword_4540B4 = 2105376;
  return result;
}
// 454080: using guessed type __int64 qword_454080[];
// 454088: using guessed type __int64 qword_454088;
// 4540B4: using guessed type int dword_4540B4;

//----- (00000000004017E5) ----------------------------------------------------
void __fastcall sub_4017E5(__int64 a1, __int64 a2)
{
  sub_4371B9(a1, a2);
}

//----- (0000000000401839) ----------------------------------------------------
__int64 __fastcall sub_401839(__int64 a1, int *a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  unsigned int v5; // [rsp+Ch] [rbp-14h]

  result = sub_438390(a1, (__int64)a2, a3, a4);
  if ( (_DWORD)result != -1 )
  {
    v5 = result;
    sub_401958(a2);
    return v5;
  }
  return result;
}

//----- (0000000000401866) ----------------------------------------------------
__int64 __fastcall sub_401866(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rbp
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 result; // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_4490A8;
  qword_453AE0 = 3LL;
  *(&qword_453AE0 + 2) = (__int64)(&qword_453AE0 + 3);
  *(&qword_453AE0 + 1) = 16LL;
  *((_DWORD *)&qword_453AE0 + 10) = 1;
  *((_DWORD *)&qword_453AE0 + 16) = 1;
  *((_DWORD *)&qword_453AE0 + 22) = 1;
  *(&qword_453AE0 + 3) = v3(a1, a2, a3, -10LL);
  *(&qword_453AE0 + 6) = v3(a1, a2, v4, -11LL);
  result = v3(a1, a2, v5, -12LL);
  *(&qword_453AE0 + 9) = result;
  return result;
}
// 4018A3: variable 'v4' is possibly undefined
// 4018AC: variable 'v5' is possibly undefined
// 4490A8: using guessed type __int64 qword_4490A8;
// 453AE0: using guessed type __int64 qword_453AE0;

//----- (00000000004018BB) ----------------------------------------------------
__int64 __fastcall sub_4018BB(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // er13
  int v5; // ebx
  __int64 v7; // rdx
  int v9[6]; // [rsp+10h] [rbp-100h] BYREF
  int v10; // [rsp+28h] [rbp-E8h]

  v4 = dword_44EB70 & 4;
  if ( (dword_44EB70 & 4) != 0 )
  {
    v4 = 0;
    if ( sub_437DB6(a1, 1) )
      return (unsigned int)sub_402E71(*(_QWORD *)(qword_453AF0 + 24LL * (int)a1), 1LL, v7) == 2;
  }
  else
  {
    v5 = dword_453D68;
    if ( (unsigned int)sub_401839(a1, v9, a3, a4) != -1 )
      return (v10 & 0xF000) == 0x2000;
    dword_453D68 = v5;
  }
  return v4;
}
// 401937: variable 'v7' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 453AF0: using guessed type __int64 qword_453AF0;
// 453D68: using guessed type int dword_453D68;
// 4018BB: using guessed type int var_100[6];

//----- (0000000000401958) ----------------------------------------------------
void __fastcall sub_401958(int *a1)
{
  __int64 v1; // r14
  int v2; // er13
  __int64 v3; // r10
  __int64 v4; // r15
  __int64 v5; // r12
  __int64 v6; // r11
  __int64 v7; // r8
  __int64 v8; // rbx
  __int64 v9; // r9
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // r11
  __int64 v15; // rbx
  __int64 v16; // r10
  __int64 v17; // r12
  int v18; // er14
  __int64 v19; // r13
  __int64 v20; // r15

  if ( a1 )
  {
    if ( (dword_44EB70 & 8) != 0 )
    {
      v1 = *((unsigned __int16 *)a1 + 3);
      v2 = *((unsigned __int16 *)a1 + 2);
      v3 = a1[28];
      v4 = *a1;
      v5 = *((_QWORD *)a1 + 2);
      v6 = *((_QWORD *)a1 + 12);
      v7 = *((_QWORD *)a1 + 5);
      *((_QWORD *)a1 + 5) = a1[6];
      v8 = *((_QWORD *)a1 + 13);
      v9 = *((_QWORD *)a1 + 4);
      v10 = *((_QWORD *)a1 + 6);
      v11 = *((_QWORD *)a1 + 7);
      v12 = *((_QWORD *)a1 + 8);
      v13 = *((_QWORD *)a1 + 9);
      *(_QWORD *)a1 = v4;
      *((_QWORD *)a1 + 2) = v1;
      a1[6] = v2;
      *(_QWORD *)(a1 + 7) = v5;
      *((_QWORD *)a1 + 6) = v6;
      *((_QWORD *)a1 + 7) = v3;
      *((_QWORD *)a1 + 8) = v8;
    }
    else
    {
      if ( (dword_44EB70 & 0x20) != 0 )
      {
        v14 = a1[32];
        v15 = *((_QWORD *)a1 + 14);
        v16 = *((_QWORD *)a1 + 15);
        v9 = *((_QWORD *)a1 + 6);
        v7 = *((_QWORD *)a1 + 7);
        v10 = *((_QWORD *)a1 + 8);
        v11 = *((_QWORD *)a1 + 9);
        v12 = *((_QWORD *)a1 + 10);
        v13 = *((_QWORD *)a1 + 11);
        a1[6] = *((unsigned __int16 *)a1 + 12);
      }
      else
      {
        if ( (dword_44EB70 & 0x10) == 0 )
          return;
        v17 = a1[7];
        v18 = *a1;
        v19 = *(_QWORD *)(a1 + 5);
        v14 = a1[24];
        v15 = *((_QWORD *)a1 + 10);
        v16 = *((_QWORD *)a1 + 11);
        v10 = *((_QWORD *)a1 + 6);
        *(_QWORD *)a1 = a1[1];
        v20 = (unsigned int)a1[4];
        v11 = *((_QWORD *)a1 + 7);
        v12 = *((_QWORD *)a1 + 8);
        v13 = *((_QWORD *)a1 + 9);
        v9 = *((_QWORD *)a1 + 4);
        v7 = *((_QWORD *)a1 + 5);
        a1[6] = v18;
        *((_QWORD *)a1 + 2) = v20;
        *(_QWORD *)(a1 + 7) = v19;
        *((_QWORD *)a1 + 5) = v17;
      }
      *((_QWORD *)a1 + 6) = v15;
      *((_QWORD *)a1 + 7) = v14;
      *((_QWORD *)a1 + 8) = v16;
    }
    *((_QWORD *)a1 + 9) = v9;
    *((_QWORD *)a1 + 10) = v7;
    *((_QWORD *)a1 + 11) = v10;
    *((_QWORD *)a1 + 12) = v11;
    *((_QWORD *)a1 + 13) = v12;
    *((_QWORD *)a1 + 14) = v13;
  }
}
// 44EB70: using guessed type int dword_44EB70;

//----- (0000000000401A89) ----------------------------------------------------
__int64 __fastcall sub_401A89(_QWORD *a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  char v4; // zf
  __int64 v5; // rax

  do
  {
    v5 = *a2++;
    *a1++ = a3 + v5;
    --a4;
  }
  while ( a4 );
  *a1 = a3 + a2[(unsigned __int8)((2 * !v4) | ((byte_44E03D & 2) != 0))];
  return *(_QWORD *)a2;
}
// 401A89: variable 'v4' is possibly undefined
// 44E03D: using guessed type char byte_44E03D;

//----- (0000000000401AB7) ----------------------------------------------------
char __fastcall sub_401AB7(_BYTE *a1, char *a2)
{
  __int64 v2; // rcx
  char v3; // al
  char *v4; // rsi
  char result; // al

  v2 = 0LL;
  while ( 1 )
  {
    v3 = *a2;
    v4 = a2 + 1;
    LOBYTE(v2) = v3;
    result = *v4;
    a2 = v4 + 1;
    if ( !v2 )
      break;
    do
    {
      *a1++ = result;
      v2 = (unsigned int)(v2 - 1);
    }
    while ( (_DWORD)v2 );
  }
  return result;
}

//----- (0000000000401AC8) ----------------------------------------------------
__int64 __fastcall sub_401AC8(__int64 *a1)
{
  int v1; // ecx
  __int64 result; // rax

  v1 = 32;
  result = 0x706050403020100LL;
  do
  {
    *a1++ = result;
    result += 0x808080808080808LL;
    --v1;
  }
  while ( v1 );
  return result;
}

//----- (0000000000401AEB) ----------------------------------------------------
void __fastcall __noreturn sub_401AEB(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx

  sub_43731B(0LL, a2, a3);
  sub_43B001(a1, a2, v3);
}
// 401AFF: variable 'v3' is possibly undefined

//----- (0000000000401B04) ----------------------------------------------------
__int64 __fastcall sub_401B04(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  unsigned int v5; // er8
  __int64 v6; // rcx
  __int64 v7; // rdx
  unsigned __int64 v8; // rax
  _DWORD *i; // rdx

  v4 = sub_4030A6(a1[8], sub_4118E4, (__int64)a1, 16 * a2, a3, a4);
  v5 = 0;
  if ( v4 )
  {
    v6 = v4 - a1[10];
    v7 = a1[12];
    a1[13] += v6;
    a1[14] += v6;
    a1[10] = v4;
    v8 = 16 * a2 + v4;
    a1[11] += v6;
    a1[12] = v8;
    for ( i = (_DWORD *)(v6 + v7); v8 > (unsigned __int64)i; i += 4 )
      *i = 2;
    return 1;
  }
  return v5;
}

//----- (0000000000401B75) ----------------------------------------------------
__int64 sub_401B75(__int64 *a1, __int64 a2, unsigned int a3, _BYTE *a4, ...)
{
  __m128 v4; // xmm0
  __m128 v5; // xmm1
  va_list va; // [rsp+8h] [rbp-1E8h] BYREF
  char v9[256]; // [rsp+20h] [rbp-1D0h] BYREF
  __int64 v10; // [rsp+140h] [rbp-B0h]
  __int128 v11; // [rsp+150h] [rbp-A0h]
  __int128 v12; // [rsp+160h] [rbp-90h]

  va_start(va, a4);
  v10 = va_arg(va, _QWORD);
  *(double *)&v11 = va_arg(va, double);
  v4.i64[0] = v11;
  *(double *)&v12 = va_arg(va, double);
  v5.i64[0] = v12;
  va_end(va);
  va_start(va, a4);
  sub_439652((__int64)v9, 256LL, a4, (__int64)va, v10);
  v9[255] = 0;
  return sub_40BA70(a1, HIBYTE(a3), v9, a2, a3 & 0xFFFFFF, v4, v5);
}
// 401C2F: variable 'v4' is possibly undefined
// 401C2F: variable 'v5' is possibly undefined

//----- (0000000000401C42) ----------------------------------------------------
__int64 __fastcall sub_401C42(__int64 *a1, __int64 a2, unsigned int a3, const char *a4, __m128 a5, __m128 a6)
{
  return sub_40BA70(a1, HIBYTE(a3), a4, a2, a3 & 0xFFFFFF, a5, a6);
}

//----- (0000000000401C60) ----------------------------------------------------
__int64 __fastcall sub_401C60(__int64 *a1, __int64 a2, int a3, int a4, const char *a5, __m128 a6, __m128 a7)
{
  __int64 v8; // rbx
  const char *v10; // [rsp-8h] [rbp-38h]

  v8 = a4;
  v10 = (const char *)sub_408C1D(a1, a4, a6, a7);
  return sub_401B75(a1, a2, a3 | 0x6000000u, "%s required, found %s (stack index %ld)", a5, v10, v8);
}

//----- (0000000000401CB7) ----------------------------------------------------
__int64 __fastcall sub_401CB7(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x1000000u, "internal error", a4, a5);
}

//----- (0000000000401CC7) ----------------------------------------------------
__int64 __fastcall sub_401CC7(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x1000000u, "alloc failed", a4, a5);
}

//----- (0000000000401CD7) ----------------------------------------------------
__int64 __fastcall sub_401CD7(__int64 *a1, __int64 a2, int a3, const char *a4, __m128 a5, __m128 a6)
{
  return sub_401C42(a1, a2, a3 | 0x1000000u, a4, a5, a6);
}

//----- (0000000000401CE2) ----------------------------------------------------
__int64 __fastcall sub_401CE2(__int64 *a1, __int64 a2, int a3, const char *a4, __m128 a5, __m128 a6)
{
  return sub_401C42(a1, a2, a3 | 0x3000000u, a4, a5, a6);
}

//----- (0000000000401CED) ----------------------------------------------------
__int64 __fastcall sub_401CED(__int64 *a1, __int64 a2, int a3, int a4)
{
  return sub_401B75(a1, a2, a3 | 0x3000000u, "invalid stack index %ld", a4);
}

//----- (0000000000401D02) ----------------------------------------------------
__int64 __fastcall sub_401D02(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x3000000u, "cannot push beyond allocated stack", a4, a5);
}

//----- (0000000000401D12) ----------------------------------------------------
__int64 __fastcall sub_401D12(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x6000000u, "invalid args", a4, a5);
}

//----- (0000000000401D22) ----------------------------------------------------
__int64 __fastcall sub_401D22(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x6000000u, "invalid state", a4, a5);
}

//----- (0000000000401D32) ----------------------------------------------------
__int64 __fastcall sub_401D32(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_401C42(a1, a2, a3 | 0x6000000u, "invalid trap result", a4, a5);
}

//----- (0000000000401D42) ----------------------------------------------------
void __fastcall __noreturn sub_401D42(__int64 a1, __int64 a2, __int64 a3)
{
  sub_401000(a1, a2, a3);
}

//----- (0000000000401D4B) ----------------------------------------------------
void __fastcall sub_401D4B(__int64 a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // ecx
  unsigned int v5; // eax
  unsigned int v6; // eax
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r11
  unsigned int v12; // edi
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // rsi
  __int64 i; // rdx
  __int64 v17; // r10
  __int64 v18; // rsi
  unsigned int v19; // ecx
  __int64 v20; // rax
  __int64 v21; // rdx
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // rdi
  __int64 v25; // r11

  if ( !*(_DWORD *)(a1 + 260) )
  {
    v3 = *(_DWORD *)(a1 + 252);
    v5 = *(_DWORD *)(a1 + 256);
    *(_DWORD *)(a1 + 260) = 1;
    v6 = v5 / (v3 >> 4);
    if ( v6 <= 0x10 )
    {
      if ( v6 <= 6 && v3 > 0x400 )
      {
        v18 = *(_QWORD *)(a1 + 240);
        v19 = v3 >> 1;
        v20 = 0LL;
        v21 = 8LL * v19;
        do
        {
          v22 = *(_QWORD *)(v18 + 8 * v20);
          v23 = *(_QWORD *)(v18 + v21 + 8 * v20);
          if ( v22 )
          {
            v24 = *(_QWORD *)(v18 + 8 * v20);
            do
            {
              v25 = v24;
              v24 = *(_QWORD *)(v24 + 8);
            }
            while ( v24 );
            *(_QWORD *)(v25 + 8) = v23;
            v23 = v22;
          }
          *(_QWORD *)(v18 + 8 * v20++) = v23;
        }
        while ( v19 > (unsigned int)v20 );
        *(_DWORD *)(a1 + 252) = v19;
        *(_DWORD *)(a1 + 248) = v19 - 1;
        *(_QWORD *)(a1 + 240) = sub_40303B(a1, v18, v21, a2, a3);
      }
    }
    else if ( v3 <= 0xFFFFFFF )
    {
      v7 = 2 * v3;
      v8 = sub_40303B(a1, *(_QWORD *)(a1 + 240), 8 * v7, a2, a3);
      if ( v8 )
      {
        v9 = *(unsigned int *)(a1 + 252);
        *(_QWORD *)(a1 + 240) = v8;
        v10 = 0LL;
        v11 = v8 + 8 * v9;
        v12 = v9;
        while ( v12 > (unsigned int)v10 )
        {
          v13 = *(_QWORD *)(v8 + 8 * v10);
          v14 = 0LL;
          v15 = 0LL;
          for ( i = v13; i; i = v17 )
          {
            v17 = *(_QWORD *)(i + 8);
            if ( (v12 & *(_DWORD *)(i + 16)) != 0 )
            {
              if ( v15 )
                *(_QWORD *)(v15 + 8) = v17;
              else
                v13 = *(_QWORD *)(i + 8);
              *(_QWORD *)(i + 8) = v14;
              v14 = i;
              i = v15;
            }
            v15 = i;
          }
          *(_QWORD *)(v8 + 8 * v10) = v13;
          *(_QWORD *)(v11 + 8 * v10++) = v14;
        }
        *(_DWORD *)(a1 + 252) = v7;
        *(_DWORD *)(a1 + 248) = v7 - 1;
      }
    }
    *(_DWORD *)(a1 + 260) = 0;
  }
}

//----- (0000000000401EA7) ----------------------------------------------------
__int64 __fastcall sub_401EA7(__int64 *a1, __int128 *a2, __int128 *a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // er13
  const char *v7; // rbx
  const char *v8; // rax
  const char *v10; // [rsp+8h] [rbp-28h]

  v6 = sub_404AE7((__int64)a1);
  sub_406883(a1, a2, a4, a5);
  sub_406883(a1, a3, a4, a5);
  sub_40779C(a1, a4, a5);
  v10 = (const char *)sub_408C1D(a1, -4, a4, a5);
  v7 = (const char *)sub_408C1D(a1, -3, a4, a5);
  v8 = (const char *)sub_408C1D(a1, -5, a4, a5);
  sub_407BD4(
    a1,
    16777222,
    (__int64)"third_party/duktape/duk_js_call.c",
    2917,
    "%s not callable (property %s of %s)",
    v10,
    v7,
    v8);
  sub_403DDC(a1, -5, 0x60u, 0, a4, a5);
  sub_404EC4(a1, -4, v6 - 1);
  return sub_404B20(a1, v6, a4, a5);
}

//----- (0000000000401F78) ----------------------------------------------------
void __fastcall __noreturn sub_401F78(__int64 a1, __int64 a2)
{
  sub_431916(a1, a2, byte_446918);
}

//----- (0000000000401F82) ----------------------------------------------------
void __fastcall __noreturn sub_401F82(__int64 a1, __int64 a2)
{
  sub_431916(a1, a2, byte_44691B);
}

//----- (0000000000401F8C) ----------------------------------------------------
__int64 __fastcall sub_401F8C(__int64 a1, __int64 a2, const char *a3)
{
  unsigned int v3; // er13
  const char *v4; // rax

  v3 = dword_453D68;
  sub_40200C(a1, a2);
  v4 = (const char *)sub_439554(v3);
  return sub_431B90(qword_450038, "%s: %#lx %s %#lx (%s)\n", "check failed", a1, a3, a2, v4);
}
// 450038: using guessed type __int64 qword_450038;
// 453D68: using guessed type int dword_453D68;

//----- (0000000000401FE8) ----------------------------------------------------
void __fastcall __noreturn sub_401FE8(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !byte_453D6C )
  {
    byte_453D6C = 1;
    sub_401AEB(dword_44EC30, a2, a3);
  }
  sub_401000(a1, a2, a3);
}
// 44EC30: using guessed type int dword_44EC30;
// 453D6C: using guessed type char byte_453D6C;

//----- (000000000040200C) ----------------------------------------------------
__int64 __fastcall sub_40200C(__int64 a1, __int64 a2)
{
  const char *v2; // rbx
  __int64 v3; // rdi
  char v4; // al
  char *v5; // r8
  char v6; // al
  const char *v7; // rdx
  const char *v9; // [rsp+0h] [rbp-20h]
  const char *v10; // [rsp+8h] [rbp-18h]

  v2 = "\x1B[0m";
  sub_431ABE((_DWORD *)qword_452038);
  v3 = qword_450038;
  sub_431ABE((_DWORD *)qword_450038);
  *(_BYTE *)qword_450038 = 0;
  if ( !sub_431925(v3, a2) )
    v2 = &byte_43DB77;
  v9 = (const char *)qword_44EB58;
  v4 = sub_431925(v3, a2);
  v5 = "\x1B[94;49m";
  if ( !v4 )
    v5 = &byte_43DB77;
  v10 = v5;
  v6 = sub_431925(v3, a2);
  v7 = "\x1B[30;101m";
  if ( !v6 )
    v7 = &byte_43DB77;
  return sub_431B90(qword_450038, "%s%s%s:%s%s: ", v7, "error", v10, v9, v2);
}
// 43DB77: using guessed type char byte_43DB77;
// 44EB58: using guessed type __int64 qword_44EB58;
// 450038: using guessed type __int64 qword_450038;
// 452038: using guessed type __int64 qword_452038;

//----- (00000000004020AC) ----------------------------------------------------
__int64 sub_4020AC()
{
  dword_453D68 = dword_44EBB8;
  return -1LL;
}
// 44EBB8: using guessed type int dword_44EBB8;
// 453D68: using guessed type int dword_453D68;

//----- (00000000004020BC) ----------------------------------------------------
__int64 sub_4020BC()
{
  dword_453D68 = dword_44EBC0;
  return -1LL;
}
// 44EBC0: using guessed type int dword_44EBC0;
// 453D68: using guessed type int dword_453D68;

//----- (00000000004020CC) ----------------------------------------------------
__int64 sub_4020CC()
{
  dword_453D68 = dword_44EBD0;
  return -1LL;
}
// 44EBD0: using guessed type int dword_44EBD0;
// 453D68: using guessed type int dword_453D68;

//----- (00000000004020DC) ----------------------------------------------------
__int64 sub_4020DC()
{
  dword_453D68 = dword_44EBD8;
  return -1LL;
}
// 44EBD8: using guessed type int dword_44EBD8;
// 453D68: using guessed type int dword_453D68;

//----- (00000000004020EC) ----------------------------------------------------
__int64 sub_4020EC()
{
  dword_453D68 = dword_44EBE0;
  return -1LL;
}
// 44EBE0: using guessed type int dword_44EBE0;
// 453D68: using guessed type int dword_453D68;

//----- (00000000004020FC) ----------------------------------------------------
__int64 sub_4020FC()
{
  dword_453D68 = dword_44EBE8;
  return -1LL;
}
// 44EBE8: using guessed type int dword_44EBE8;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040210C) ----------------------------------------------------
__int64 sub_40210C()
{
  dword_453D68 = dword_44EBF0;
  return -1LL;
}
// 44EBF0: using guessed type int dword_44EBF0;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040211C) ----------------------------------------------------
__int64 sub_40211C()
{
  dword_453D68 = dword_44EBF8;
  return -1LL;
}
// 44EBF8: using guessed type int dword_44EBF8;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040212C) ----------------------------------------------------
__int64 sub_40212C()
{
  dword_453D68 = dword_44EC00;
  return -1LL;
}
// 44EC00: using guessed type int dword_44EC00;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040213C) ----------------------------------------------------
__int64 sub_40213C()
{
  dword_453D68 = dword_44EC08;
  return -1LL;
}
// 44EC08: using guessed type int dword_44EC08;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040214C) ----------------------------------------------------
__int64 sub_40214C()
{
  dword_453D68 = dword_44EC10;
  return -1LL;
}
// 44EC10: using guessed type int dword_44EC10;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040215C) ----------------------------------------------------
__int64 sub_40215C()
{
  dword_453D68 = dword_44EC18;
  return -1LL;
}
// 44EC18: using guessed type int dword_44EC18;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040216C) ----------------------------------------------------
__int64 sub_40216C()
{
  dword_453D68 = dword_44EC28;
  return -1LL;
}
// 44EC28: using guessed type int dword_44EC28;
// 453D68: using guessed type int dword_453D68;

//----- (000000000040217D) ----------------------------------------------------
__int64 __fastcall sub_40217D(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  if ( qword_452050 )
  {
    qword_4490D0(a1, a2, a3, (unsigned int)dword_452048);
    result = qword_4490D8(a1, a2, (unsigned int)dword_45204C, qword_452050);
  }
  if ( qword_452060 )
  {
    qword_4490E0(a1, a2, a3, (unsigned int)dword_452058);
    return qword_4490D8(a1, a2, (unsigned int)dword_45205C, qword_452060);
  }
  return result;
}
// 4021C6: variable 'a3' is possibly undefined
// 4490D0: using guessed type __int64 (__fastcall *qword_4490D0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490D8: using guessed type __int64 (__fastcall *qword_4490D8)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490E0: using guessed type __int64 (__fastcall *qword_4490E0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 452048: using guessed type int dword_452048;
// 45204C: using guessed type int dword_45204C;
// 452050: using guessed type __int64 qword_452050;
// 452058: using guessed type int dword_452058;
// 45205C: using guessed type int dword_45205C;
// 452060: using guessed type __int64 qword_452060;

//----- (000000000040241F) ----------------------------------------------------
__int64 __fastcall sub_40241F(unsigned __int16 **a1)
{
  unsigned __int16 **v1; // rdx
  unsigned __int16 *v2; // rdi
  int v3; // eax
  unsigned int v4; // eax
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  v3 = *v2;
  if ( (unsigned __int16)v3 > 0xD7FFu )
  {
    v4 = sub_439F54((__int64)v2, (_DWORD *)v1 + 6);
  }
  else
  {
    *((_DWORD *)v1 + 6) = v3;
    v4 = 1;
  }
  result = 2LL * v4;
  *v1 = (unsigned __int16 *)((char *)*v1 + result);
  return result;
}
// 402446: variable 'v1' is possibly undefined

//----- (000000000040244A) ----------------------------------------------------
unsigned __int64 __fastcall sub_40244A(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  _BYTE *v5; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 16);
  result = (int)a2;
  if ( a2 > 0x7F )
    result = sub_439F81(a2);
  do
  {
    v5 = *(_BYTE **)(v2 + 8);
    if ( v3 <= (unsigned __int64)v5 )
      break;
    *(_QWORD *)(v2 + 8) = v5 + 1;
    *v5 = result;
    result >>= 8;
  }
  while ( result );
  return result;
}
// 402460: variable 'v2' is possibly undefined
// 402467: variable 'v3' is possibly undefined

//----- (000000000040247A) ----------------------------------------------------
__int64 __fastcall sub_40247A(unsigned __int16 *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // r10
  __int64 v7; // r10
  __int64 v8; // r11
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r10
  unsigned __int64 v12; // rax
  bool v13; // r14
  unsigned __int64 v14; // r12
  __int64 v15; // r9
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  __int64 v18; // r9
  bool v19; // cf
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // r12
  unsigned __int64 v24; // [rsp+0h] [rbp-60h]
  unsigned __int16 *v26; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v27; // [rsp+18h] [rbp-48h]
  unsigned __int64 v28; // [rsp+20h] [rbp-40h]
  unsigned int v29; // [rsp+28h] [rbp-38h]

  v4 = 0x100002600LL;
  v5 = 0LL;
  v26 = a1;
  v27 = a2;
  v28 = a2 + a3;
  sub_40241F(&v26);
LABEL_2:
  if ( v29 )
  {
    while ( 1 )
    {
      if ( !v29 )
        goto LABEL_7;
      if ( v29 > 0x20 || !_bittest64(&v4, v29) )
        break;
      sub_40241F(&v26);
    }
    if ( ++v5 < v6 )
    {
      v12 = v27;
      if ( v27 >= v28 )
        v12 = 0LL;
      *(_QWORD *)(a4 + 8 * v5 - 8) = v12;
    }
    v13 = 0;
    while ( 1 )
    {
      if ( !v29 )
      {
LABEL_45:
        sub_40244A((__int64)&v26, 0);
        goto LABEL_2;
      }
      if ( v13 || v29 > 0x20 )
      {
        if ( v29 != 34 && v29 != 92 )
          goto LABEL_44;
        v14 = 0LL;
        while ( v29 == 92 )
        {
          ++v14;
          sub_40241F(&v26);
        }
        v15 = 0LL;
        while ( v29 == 34 )
        {
          sub_40241F(&v26);
          v15 = v16 + 1;
        }
        v17 = v14;
        if ( v15 )
        {
          while ( v17 > 1 )
          {
            v24 = v17;
            sub_40244A((__int64)&v26, 0x5Cu);
            v17 = v24 - 2;
          }
          if ( (v14 & 1) == 0 || (sub_40244A((__int64)&v26, 0x22u), (v15 = v18 - 1) != 0) )
          {
            v19 = !v13;
            v20 = 3LL;
            v21 = v15 - v19;
            v22 = v21 + 1;
            while ( v22 >= v20 )
            {
              v20 += 3LL;
              sub_40244A((__int64)&v26, 0x22u);
            }
            v13 = v21 % 3 == 0;
          }
        }
        else
        {
          while ( --v14 != -1LL )
            sub_40244A((__int64)&v26, 0x5Cu);
        }
      }
      else
      {
        if ( _bittest64(&v4, v29) )
          goto LABEL_45;
LABEL_44:
        sub_40244A((__int64)&v26, v29);
        sub_40241F(&v26);
      }
    }
  }
LABEL_7:
  sub_40244A((__int64)&v26, 0);
  if ( v8 )
  {
    v9 = v8 - 1;
    v10 = v27 - a2;
    if ( v27 - a2 > v9 )
      v10 = v9;
    *(_BYTE *)(a2 + v10) = 0;
  }
  if ( v7 )
  {
    v11 = v7 - 1;
    if ( v11 > v5 )
      v11 = v5;
    *(_QWORD *)(a4 + 8 * v11) = 0LL;
  }
  return (unsigned int)v5;
}
// 4024EE: variable 'v8' is possibly undefined
// 40250A: variable 'v7' is possibly undefined
// 402531: variable 'v6' is possibly undefined
// 4025A6: variable 'v16' is possibly undefined
// 402602: variable 'v18' is possibly undefined
// 402615: variable 'v15' is possibly undefined
// 402640: variable 'v21' is possibly undefined

//----- (0000000000402687) ----------------------------------------------------
__int64 __fastcall sub_402687(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // rbx
  int v7; // er12
  __int64 result; // rax

  if ( !(_DWORD)a1 )
    return sub_4020AC();
  v3 = 24LL * (int)a1;
  if ( *(_DWORD *)(v3 + qword_453AF0 + 16) == 1 )
    qword_449048(a1, a2, a3, *(_QWORD *)(v3 + qword_453AF0));
  v4 = sub_402DA8(*(_QWORD *)(qword_453AF0 + 24LL * (int)a1), a2, a3);
  v6 = qword_453AF0 + v3;
  v7 = v4;
  if ( *(_DWORD *)(v6 + 16) == 4 )
    v7 = sub_402DA8(*(_QWORD *)(v6 + 8), a2, v5) & v4;
  sub_437F99((unsigned int)a1);
  result = 0LL;
  if ( !v7 )
    return sub_43B0C6();
  return result;
}
// 4026CB: variable 'a3' is possibly undefined
// 4026E4: variable 'v5' is possibly undefined
// 449048: using guessed type __int64 (__fastcall *qword_449048)(_QWORD, _QWORD, _QWORD, _QWORD);
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000402713) ----------------------------------------------------
__int64 __fastcall sub_402713(__int64 a1, __int64 a2)
{
  int v3; // eax
  __int64 v4; // rdx
  int v5; // esi
  int v6; // edx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx
  int v15; // eax
  __int64 v16; // rax
  __int64 v18; // [rsp+8h] [rbp-58h]
  int v19; // [rsp+1Ch] [rbp-44h]
  __int64 v20; // [rsp+20h] [rbp-40h]
  __int64 v21; // [rsp+28h] [rbp-38h]
  __int64 v22; // [rsp+30h] [rbp-30h]
  unsigned int v23; // [rsp+38h] [rbp-28h]
  unsigned int v24; // [rsp+3Ch] [rbp-24h]
  unsigned int v25; // [rsp+40h] [rbp-20h]
  unsigned int v26; // [rsp+44h] [rbp-1Ch]
  unsigned int v27; // [rsp+48h] [rbp-18h]
  unsigned int v28; // [rsp+4Ch] [rbp-14h]

  sub_402E5B();
  if ( !v3 )
    return sub_43B0C6();
  sub_43ABE2(a2, 0LL, 0xE0uLL);
  v5 = sub_402E71(a1, 0LL, v4);
  v6 = 0x4000;
  if ( (v19 & 0x10) == 0 )
  {
    if ( v5 == 1 )
    {
      v7 = 24576;
      v9 = 0;
    }
    else
    {
      v7 = 0;
      v8 = 0x2000;
      if ( v5 != 2 )
        v8 = 0;
      v9 = v8;
    }
    v10 = v7 | v9;
    v11 = 4096;
    if ( v5 != 3 )
      v11 = 0;
    v6 = v11 | v10;
  }
  *(_DWORD *)(a2 + 24) = v6 | (v19 << 10 >> 31) & 0xA000 | ((v19 & 1) == 0 ? 448 : 320) | ((_WORD)v19 << 8) & 0x8000;
  *(_QWORD *)(a2 + 72) = sub_438106(v21);
  *(_QWORD *)(a2 + 80) = v12;
  *(_QWORD *)(a2 + 88) = sub_438106(v22);
  *(_QWORD *)(a2 + 96) = v13;
  *(_QWORD *)(a2 + 104) = sub_438106(v20);
  *(_QWORD *)(a2 + 112) = v14;
  *(_QWORD *)(a2 + 56) = 4096LL;
  *(_QWORD *)(a2 + 48) = v25 | ((unsigned __int64)v24 << 32);
  *(_QWORD *)a2 = v23;
  *(_QWORD *)(a2 + 8) = v28 | ((unsigned __int64)v27 << 32);
  *(_QWORD *)(a2 + 16) = v26;
  sub_402E45();
  if ( v15 )
    v16 = v18;
  else
    v16 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 64) = ((unsigned __int64)(v16 + 4095) >> 9) & 0x7FFFFFFFFFFFF8LL;
  return 0LL;
}
// 40272F: variable 'v3' is possibly undefined
// 402747: variable 'v4' is possibly undefined
// 402783: variable 'v19' is possibly undefined
// 4027C7: variable 'v21' is possibly undefined
// 4027D4: variable 'v12' is possibly undefined
// 4027D8: variable 'v22' is possibly undefined
// 4027E5: variable 'v13' is possibly undefined
// 4027E9: variable 'v20' is possibly undefined
// 4027FA: variable 'v14' is possibly undefined
// 4027FE: variable 'v25' is possibly undefined
// 4027F2: variable 'v24' is possibly undefined
// 40281F: variable 'v23' is possibly undefined
// 402818: variable 'v28' is possibly undefined
// 402825: variable 'v27' is possibly undefined
// 402837: variable 'v26' is possibly undefined
// 402845: variable 'v15' is possibly undefined
// 402847: variable 'v18' is possibly undefined

//----- (000000000040287E) ----------------------------------------------------
__int64 __fastcall sub_40287E(_BYTE *a1, __int64 a2)
{
  __int64 v2; // r10
  __int64 v3; // r12
  __int64 *v4; // rcx
  __int64 v5; // rax
  __int16 v7[256]; // [rsp+10h] [rbp-200h] BYREF

  if ( (unsigned int)sub_402C35(a1, a2, v7) == -1 )
    return -1LL;
  v4 = qword_446EC0;
  if ( ((unsigned int)a2 & (unsigned int)qword_44EC80) == 0 )
    v4 = 0LL;
  v5 = sub_402DD7(v2, (unsigned int)a2 & 0xF000000F, 7LL, (__int64)v4);
  v3 = v5;
  if ( v5 == -1 )
    return -1LL;
  if ( ((unsigned int)a2 & (unsigned int)qword_44ECA8) != 0 )
    sub_402DED(v5, 590020LL, 0LL, 0LL);
  return v3;
}
// 402945: variable 'v2' is possibly undefined
// 446EC0: using guessed type __int64 qword_446EC0[2];
// 44EC80: using guessed type __int64 qword_44EC80;
// 44ECA8: using guessed type __int64 qword_44ECA8;
// 40287E: using guessed type __int16 var_200[256];

//----- (0000000000402993) ----------------------------------------------------
unsigned __int64 __fastcall sub_402993(_BYTE *a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r12
  __int64 *v4; // r15
  __int64 v5; // rbx
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rax
  _QWORD *v9; // rdx
  __int64 *v10; // r15
  int v11; // er14
  __int64 v12; // rax
  __int64 v13; // r15
  __int64 v14; // rbx
  __int64 v15; // rax

  v3 = sub_437AA9((__int64)a1, a2, a3);
  if ( v3 == -1LL )
    return v3;
  v4 = (__int64 *)qword_453AF0;
  v5 = 24 * v3;
  if ( ((unsigned int)a2 & (unsigned int)qword_44EC78) != qword_44ECA0
    || (unsigned int)sub_43AE48((__int64)a1, (__int64)"/dev/tty") )
  {
    v15 = sub_40287E(a1, (unsigned int)a2);
    v4[(unsigned __int64)v5 / 8] = v15;
    if ( v15 != -1 )
    {
      v14 = qword_453AF0 + v5;
      *(_DWORD *)(v14 + 16) = 1;
      goto LABEL_12;
    }
    if ( (unsigned int)sub_402E8A() == 80
      && ((unsigned int)a2 & (unsigned int)qword_44EC88) != 0
      && ((unsigned int)a2 & (unsigned int)qword_44ECB0) != 0 )
    {
      return sub_4020EC();
    }
    return sub_43B0C6();
  }
  if ( (unsigned int)sub_402E71(*v4, (__int64)"/dev/tty", v6) != 2
    || (unsigned int)sub_402E71(*(_QWORD *)(qword_453AF0 + 24), (__int64)"/dev/tty", v7) != 2 )
  {
    v10 = (__int64 *)(v5 + qword_453AF0);
    v11 = a2 & ~(_DWORD)qword_44EC78;
    v12 = sub_40287E("CONIN$", v11 | (unsigned int)qword_44EC98);
    *v10 = v12;
    if ( v12 != -1 )
    {
      v13 = v5 + qword_453AF0;
      *(_QWORD *)(v13 + 8) = sub_40287E("CONOUT$", v11 | (unsigned int)qword_44ECB8);
      goto LABEL_9;
    }
    return sub_43B0C6();
  }
  v8 = qword_453AF0;
  v9 = (_QWORD *)(qword_453AF0 + v5);
  *v9 = *(_QWORD *)qword_453AF0;
  v9[1] = *(_QWORD *)(v8 + 24);
LABEL_9:
  v14 = qword_453AF0 + v5;
  *(_DWORD *)(v14 + 16) = 4;
LABEL_12:
  *(_DWORD *)(v14 + 20) = a2;
  return v3;
}
// 4029FA: variable 'v6' is possibly undefined
// 402A0F: variable 'v7' is possibly undefined
// 44EC78: using guessed type __int64 qword_44EC78;
// 44EC88: using guessed type __int64 qword_44EC88;
// 44EC98: using guessed type __int64 qword_44EC98;
// 44ECA0: using guessed type __int64 qword_44ECA0;
// 44ECB0: using guessed type __int64 qword_44ECB0;
// 44ECB8: using guessed type __int64 qword_44ECB8;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000402B09) ----------------------------------------------------
__int64 __fastcall sub_402B09(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 result; // rax
  unsigned int v11; // [rsp+Ch] [rbp-44h] BYREF
  char v12[64]; // [rsp+10h] [rbp-40h] BYREF

  while ( a3 && !a2[1] )
  {
    a2 += 2;
    --a3;
  }
  sub_402D09(a4, (__int64)v12);
  if ( a3 )
  {
    v8 = *((unsigned int *)a2 + 2);
    v9 = *a2;
  }
  else
  {
    v8 = 0LL;
    v9 = 0LL;
  }
  if ( (unsigned int)qword_4490C8(a4, v12, v9, *a1, v8, &v11) )
    return v11;
  result = 0LL;
  if ( __readgsdword(0x68u) != 109 )
    return sub_43B0C6();
  return result;
}
// 4490C8: using guessed type __int64 (__fastcall *qword_4490C8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402B93) ----------------------------------------------------
__int64 __fastcall sub_402B93(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 i; // rax
  unsigned int v13; // [rsp+Ch] [rbp-44h] BYREF
  char v14[64]; // [rsp+10h] [rbp-40h] BYREF

  while ( a3 && !a2[1] )
  {
    a2 += 2;
    --a3;
  }
  sub_402D09(a4, (__int64)v14);
  if ( a3 )
  {
    v8 = *((unsigned int *)a2 + 2);
    v9 = *a2;
  }
  else
  {
    v8 = 0LL;
    v9 = 0LL;
  }
  if ( !(unsigned int)qword_4490F8(a4, v14, v9, *a1, v8, &v13) )
    return sub_43B0C6();
  if ( !v13 )
  {
    for ( i = 0LL; a3 != i; ++i )
      ;
  }
  qword_449048(a4, v14, v10, *a1);
  return v13;
}
// 402C16: variable 'v10' is possibly undefined
// 449048: using guessed type __int64 (__fastcall *qword_449048)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490F8: using guessed type __int64 (__fastcall *qword_4490F8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402C35) ----------------------------------------------------
__int64 __fastcall sub_402C35(_BYTE *a1, __int64 a2, _WORD *a3)
{
  __int64 v4; // rcx
  _BYTE *v5; // r8
  __int64 v6; // r9
  int *v7; // r10
  unsigned __int64 v8; // r11
  int v9; // eax
  _WORD *v11; // rdi
  int v12; // eax
  unsigned int v13; // [rsp+0h] [rbp-4Ch]

  v5 = sub_402D2E(a1);
  while ( 1 )
  {
    if ( (char)v5[v6] < 0 )
    {
      v9 = sub_439F72(&v5[v6], v7);
      if ( v9 == -1 )
        goto LABEL_5;
    }
    else
    {
      v13 = (char)v5[v6];
      v9 = 1;
    }
    if ( !v13 )
      break;
    v6 += v9;
    if ( v13 == 47 )
      v13 = 92;
    if ( (unsigned __int64)(v4 + 3) > 0xE7 )
    {
      *a3 = 0;
      return sub_40210C();
    }
    v11 = &a3[v4];
    if ( v13 > 0xD7FF )
    {
      v12 = sub_439F63(v11, v8, v13, v4);
      if ( v12 == -1 )
      {
LABEL_5:
        *a3 = 0;
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      *v11 = v13;
      v12 = 1;
    }
    v4 += v12;
  }
  a3[v4] = 0;
  return (unsigned int)v4;
}
// 402C64: variable 'v5' is possibly undefined
// 402C64: variable 'v6' is possibly undefined
// 402C7C: variable 'v7' is possibly undefined
// 402C95: variable 'v13' is possibly undefined
// 402CA8: variable 'v4' is possibly undefined
// 402CD3: variable 'v8' is possibly undefined

//----- (0000000000402D09) ----------------------------------------------------
__int64 __fastcall sub_402D09(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // rcx
  _DWORD *v5; // rdi

  v3 = a2;
  if ( a1 == -1 )
    return 0LL;
  v4 = 8LL;
  v5 = (_DWORD *)a2;
  while ( v4 )
  {
    *v5++ = 0;
    --v4;
  }
  *(_QWORD *)(a2 + 16) = a1;
  return v3;
}

//----- (0000000000402D2E) ----------------------------------------------------
_BYTE *__fastcall sub_402D2E(_BYTE *a1)
{
  __int64 v1; // rdx
  int v2; // ecx
  __int64 v3; // rsi
  __int64 v4; // rdx

  if ( *a1 == 47 )
  {
    if ( (unsigned int)sub_43AE48((__int64)a1, (__int64)"/dev/tty") )
      goto LABEL_14;
    v3 = (unsigned int)qword_44EC78 & v2;
    if ( v3 == qword_44EC98 )
      return (_BYTE *)(v1 + 46);
    if ( v3 != qword_44ECB8 )
    {
LABEL_14:
      if ( !(unsigned int)sub_43AE48((__int64)a1, v1 + 9) )
        return (_BYTE *)(v4 + 42);
      if ( !(unsigned int)sub_43AE48((__int64)a1, v4 + 19) )
        return (_BYTE *)(v1 + 46);
      if ( (unsigned int)sub_43AE48((__int64)a1, v1 + 30) )
        return a1;
    }
    return (_BYTE *)(v1 + 53);
  }
  return a1;
}
// 402D50: variable 'v2' is possibly undefined
// 402D68: variable 'v1' is possibly undefined
// 402D75: variable 'v4' is possibly undefined
// 44EC78: using guessed type __int64 qword_44EC78;
// 44EC98: using guessed type __int64 qword_44EC98;
// 44ECB8: using guessed type __int64 qword_44ECB8;

//----- (0000000000402DA8) ----------------------------------------------------
__int64 __fastcall sub_402DA8(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_449020(a1, a2, a3, a1);
}
// 449020: using guessed type __int64 (__fastcall *qword_449020)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402DC1) ----------------------------------------------------
__int64 __fastcall sub_402DC1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_449028(a1, a2, a2, a1, a3, a4);
}
// 449028: using guessed type __int64 (__fastcall *qword_449028)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402DD7) ----------------------------------------------------
__int64 __fastcall sub_402DD7(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_449030(a1, a2, a2, a1, a3, a4);
}
// 449030: using guessed type __int64 (__fastcall *qword_449030)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402DED) ----------------------------------------------------
__int64 __fastcall sub_402DED(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_449038(a1, a2, a2, a1, a3, a4);
}
// 449038: using guessed type __int64 (__fastcall *qword_449038)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402E03) ----------------------------------------------------
__int64 __fastcall sub_402E03(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_449050(a1, a2, a2, a1, a3, a4);
}
// 449050: using guessed type __int64 (__fastcall *qword_449050)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402E19) ----------------------------------------------------
__int64 sub_402E19()
{
  return qword_449068();
}
// 449068: using guessed type __int64 (*qword_449068)(void);

//----- (0000000000402E2F) ----------------------------------------------------
__int64 sub_402E2F()
{
  return qword_449078();
}
// 449078: using guessed type __int64 (*qword_449078)(void);

//----- (0000000000402E45) ----------------------------------------------------
void sub_402E45()
{
  JUMPOUT(0x402F04LL);
}
// 402E56: control flows out of bounds to 402F04

//----- (0000000000402E5B) ----------------------------------------------------
void sub_402E5B()
{
  JUMPOUT(0x402F04LL);
}
// 402E6C: control flows out of bounds to 402F04

//----- (0000000000402E71) ----------------------------------------------------
__int64 __fastcall sub_402E71(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_449098(a1, a2, a3, a1);
}
// 449098: using guessed type __int64 (__fastcall *qword_449098)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402E8A) ----------------------------------------------------
__int64 sub_402E8A()
{
  return qword_4490A0();
}
// 4490A0: using guessed type __int64 (*qword_4490A0)(void);

//----- (0000000000402EA0) ----------------------------------------------------
__int64 __fastcall sub_402EA0(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_4490B8(a1, a2, a3, a1);
}
// 4490B8: using guessed type __int64 (__fastcall *qword_4490B8)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402EB9) ----------------------------------------------------
__int64 __fastcall sub_402EB9(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_4490C0(a1, a2, a2, a1, a3, a4);
}
// 4490C0: using guessed type __int64 (__fastcall *qword_4490C0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402ECF) ----------------------------------------------------
__int64 __fastcall sub_402ECF(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_4490F0(a1, a2, a3, a1);
}
// 4490F0: using guessed type __int64 (__fastcall *qword_4490F0)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000402F19) ----------------------------------------------------
__int64 __fastcall sub_402F19(__int64 a1, __int64 a2, __m128 a3, __m128 a4)
{
  bool v4; // sf
  int v5; // er13
  __int64 result; // rax

  v4 = --*(_DWORD *)(a1 + 88) < 0;
  if ( v4
    || (result = (*(__int64 (__fastcall **)(_QWORD, double, double))(a1 + 8))(
                   *(_QWORD *)(a1 + 32),
                   *(double *)a3.i64,
                   *(double *)a4.i64)) == 0 )
  {
    v5 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        sub_40C6B4(a1, v5 > 1, a3, a4);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 8))(*(_QWORD *)(a1 + 32), a2);
        if ( result )
          break;
        if ( ++v5 == 10 )
          return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (0000000000402F7A) ----------------------------------------------------
void __fastcall sub_402F7A(__int64 a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax

  v4 = sub_402F19(a1, a2, a3, a4);
  if ( v4 )
    sub_43ABE2(v4, 0LL, a2);
}

//----- (0000000000402FA0) ----------------------------------------------------
__int64 __fastcall sub_402FA0(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  result = sub_402F19(a1[8], a2, a3, a4);
  if ( !result )
  {
    if ( a2 )
    {
      sub_401CC7(a1, (__int64)"third_party/duktape/duk_heap_memory.c", 143, a3, a4);
      return 0LL;
    }
  }
  return result;
}

//----- (0000000000402FE5) ----------------------------------------------------
void __fastcall sub_402FE5(__int64 *a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax

  v4 = sub_402F19(a1[8], a2, a3, a4);
  if ( v4 )
  {
    sub_43ABE2(v4, 0LL, a2);
  }
  else if ( a2 )
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_heap_memory.c", 162, a3, a4);
  }
}

//----- (000000000040303B) ----------------------------------------------------
__int64 __fastcall sub_40303B(__int64 a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  bool v5; // sf
  int v7; // er14
  __int64 result; // rax

  v5 = --*(_DWORD *)(a1 + 88) < 0;
  if ( v5
    || (result = (*(__int64 (__fastcall **)(_QWORD, double, double))(a1 + 16))(
                   *(_QWORD *)(a1 + 32),
                   *(double *)a4.i64,
                   *(double *)a5.i64)) == 0 )
  {
    v7 = 0;
    if ( a3 )
    {
      while ( 1 )
      {
        sub_40C6B4(a1, v7 > 1, a4, a5);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(a1 + 16))(*(_QWORD *)(a1 + 32), a2, a3);
        if ( result )
          break;
        if ( ++v7 == 10 )
          return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (00000000004030A6) ----------------------------------------------------
__int64 __fastcall sub_4030A6(
        __int64 a1,
        __int64 (__fastcall *a2)(__int64, __int64),
        __int64 a3,
        __int64 a4,
        __m128 a5,
        __m128 a6)
{
  bool v8; // sf
  int v9; // er15
  __int64 (__fastcall *v10)(_QWORD, __int64, __int64); // r15
  __int64 v11; // rax
  __int64 result; // rax
  __int64 v13; // rax
  __int64 (__fastcall *v14)(_QWORD, __int64, __int64); // [rsp+8h] [rbp-38h]

  v8 = --*(_DWORD *)(a1 + 88) < 0;
  if ( v8
    || (v10 = *(__int64 (__fastcall **)(_QWORD, __int64, __int64))(a1 + 16),
        v11 = ((__int64 (__fastcall *)(__int64, __int64, double, double))a2)(
                a1,
                a3,
                *(double *)a5.i64,
                *(double *)a6.i64),
        (result = v10(*(_QWORD *)(a1 + 32), v11, a4)) == 0) )
  {
    v9 = 0;
    if ( a4 )
    {
      while ( 1 )
      {
        sub_40C6B4(a1, v9 > 1, a5, a6);
        v14 = *(__int64 (__fastcall **)(_QWORD, __int64, __int64))(a1 + 16);
        v13 = a2(a1, a3);
        result = v14(*(_QWORD *)(a1 + 32), v13, a4);
        if ( result )
          break;
        if ( ++v9 == 10 )
          return 0LL;
      }
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (0000000000403142) ----------------------------------------------------
__int64 __fastcall sub_403142(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1 + 24))(*(_QWORD *)(a1 + 32));
}

//----- (000000000040314F) ----------------------------------------------------
__int64 __fastcall sub_40314F(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 result; // rax
  __int64 v5; // rdx

  result = *(unsigned int *)(a1 + 28);
  if ( !(_DWORD)result )
  {
    result = sub_41C892((_BYTE *)(a1 + 32), *(unsigned int *)(a1 + 24), a3, a4);
    v5 = *(unsigned int *)(a1 + 24);
    *(_DWORD *)(a1 + 28) = result;
    if ( result == v5 )
      *(_DWORD *)a1 |= 0x80u;
  }
  return result;
}

//----- (0000000000403189) ----------------------------------------------------
__int64 __fastcall sub_403189(__int64 *a1, __m128 a2)
{
  int v2; // ebx
  __m128 v3; // xmm1
  int v4; // er13

  v2 = 0;
  v3 = 0LL;
  v4 = sub_404AE7((__int64)a1);
  while ( v2 < v4 )
  {
    sub_405C43(a1, v2++, a2, v3);
    *(double *)v3.i64 = *(double *)v3.i64 + *(double *)a2.i64;
  }
  sub_406A1B(a1, v3, v3);
  return 1LL;
}

//----- (00000000004031E2) ----------------------------------------------------
__int64 __fastcall sub_4031E2(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  int v5; // eax
  __int64 v6; // r13
  char *v7; // rax

  sub_406D71(a1, 4483430LL, a5, a2, a3);
  sub_40500F(a1, 0);
  v5 = sub_404AE7((__int64)a1);
  sub_408F0F(a1, v5 - 1, a2, a3);
  v6 = qword_452038;
  v7 = (char *)sub_407835(a1, -1, a2, a3);
  sub_431C16(v7, v6);
  return 0LL;
}
// 452038: using guessed type __int64 qword_452038;

//----- (000000000040323B) ----------------------------------------------------
__int64 __fastcall sub_40323B(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // ebx
  __int64 v5; // rax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rax

  v4 = *(_DWORD *)(a2 + 16);
  if ( (v4 & 0x800) != 0 )
    sub_407826(a1, (*(_DWORD *)(a2 + 16) & 8) == 0 ? 108 : 33, a3, a4);
  if ( !*(_QWORD *)(a2 + 8) )
  {
    v5 = sub_40568B((__int64)a1, -2);
    if ( (v4 & 0x200) != 0 || !v5 )
    {
      sub_401C42(a1, (__int64)"third_party/duktape/duk_api_compile.c", 0x600005Bu, "no sourcecode", a3, a4);
      return 0LL;
    }
    v7 = v5 + 32;
    v8 = *(unsigned int *)(v5 + 24);
    *(_QWORD *)(a2 + 8) = v7;
    *(_QWORD *)a2 = v8;
  }
  if ( (v4 & 0x10) != 0 )
    v4 |= 0x1008u;
  sub_4175F8(a1, *(_QWORD *)(a2 + 8), *(_QWORD *)a2, v4, a3, a4);
  if ( (v4 & 0x200) == 0 )
    sub_405181(a1, a3, a4);
  v9 = sub_405B41((__int64)a1, -1);
  sub_41843F(a1, v9, a1[21], a1[21], 1, a3, a4);
  sub_405181(a1, a3, a4);
  return 1LL;
}

//----- (0000000000403319) ----------------------------------------------------
__int64 __fastcall sub_403319(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v9[2]; // [rsp+8h] [rbp-38h] BYREF
  int v10; // [rsp+18h] [rbp-28h]

  if ( (a4 & 0x400) != 0 && a2 )
    a3 = sub_43AD53(a2);
  v9[1] = a2;
  v9[0] = a3;
  v10 = a4;
  if ( (a4 & 0x80u) != 0 )
    return sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_40323B, (__int64)v9, a4 & 7, 1, a5, a6);
  sub_40323B(a1, (__int64)v9, a5, a6);
  return 0LL;
}
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (000000000040338B) ----------------------------------------------------
__int64 __fastcall sub_40338B(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  unsigned int v6; // er12
  __int16 v7; // bx
  __int64 v8; // rdx
  __int64 v9; // rcx

  v6 = 1;
  v7 = a4;
  if ( !(unsigned int)sub_403319(a1, a2, a3, a4 | 8u, a5, a6) )
  {
    v6 = 0;
    sub_407CFD(a1, a5, a6);
    a2 = 0LL;
    if ( (v7 & 0x80u) == 0 )
      sub_41DA64(a1, 0, a5, a6);
    else
      v6 = sub_41DBA7(a1, 0, a5, a6);
  }
  if ( (v7 & 0x100) != 0 )
    sub_407D7E(a1, a2, v8, v9, a5, a6);
  return v6;
}
// 4033DA: variable 'v8' is possibly undefined
// 4033DA: variable 'v9' is possibly undefined

//----- (00000000004033EA) ----------------------------------------------------
__int64 __fastcall sub_4033EA(
        __int64 (__fastcall *a1)(__int64, __int64),
        __int64 (__fastcall *a2)(),
        __int64 (__fastcall *a3)(),
        __int64 a4,
        void (__fastcall __noreturn *a5)(__int64 a1, __int64 a2, __int64 a3),
        __m128 a6,
        __m128 a7)
{
  __int64 result; // rax

  if ( !a1 )
  {
    a3 = (__int64 (__fastcall *)())sub_41D797;
    a2 = (__int64 (__fastcall *)())sub_41D78C;
    a1 = sub_41D784;
  }
  if ( !a5 )
    a5 = sub_401D42;
  result = sub_40BF33(a1, a6, a7, (__int64)a2, (__int64)a3, a4, (__int64)a5);
  if ( result )
    return *(_QWORD *)(result + 176);
  return result;
}

//----- (0000000000403420) ----------------------------------------------------
__int64 __fastcall sub_403420(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 result; // rax

  if ( a1 )
    return sub_40BDF0(*(_QWORD *)(a1 + 64), a2, a3);
  return result;
}

//----- (00000000004035A2) ----------------------------------------------------
__int64 __fastcall sub_4035A2(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  __int64 *v6; // r13
  __m128 *v7; // r14
  __int128 *v8; // r15
  unsigned int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // rcx
  unsigned int v13; // [rsp+Ch] [rbp-34h]

  v6 = (__int64 *)sub_404A12(a1, a2);
  v7 = (__m128 *)sub_404A12(a1, a3);
  v8 = (__int128 *)sub_404A12(a1, a3 ^ 1u);
  v9 = sub_41DCBE((__int64)a1);
  v13 = sub_40F7B6(a1, v6, v7, v8, v9, a4);
  sub_407DC0(a1, (__int64)v6, v10, v11, a4, a5);
  return v13;
}
// 4035FF: variable 'v10' is possibly undefined
// 4035FF: variable 'v11' is possibly undefined

//----- (0000000000403616) ----------------------------------------------------
__int64 __fastcall sub_403616(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int128 *v4; // r13
  __m128 *v5; // rax
  unsigned int v7; // [rsp+Ch] [rbp-14h]

  v4 = (__int128 *)sub_404A12(a1, a2);
  v5 = (__m128 *)sub_404A12(a1, -1);
  v7 = sub_40EC01(a1, v4, v5, a3);
  sub_405181(a1, a3, a4);
  return v7;
}

//----- (000000000040365C) ----------------------------------------------------
__int64 __fastcall sub_40365C(__int64 *a1, int a2, __int64 a3, __m128 a4, __m128 a5)
{
  int v6; // er13
  __int64 v7; // rdx

  v6 = sub_40480A(a1, a2);
  sub_406D71(a1, a3, v7, a4, a5);
  return sub_403616(a1, v6, a4, a5);
}
// 40367B: variable 'v7' is possibly undefined

//----- (0000000000403690) ----------------------------------------------------
__int64 __fastcall sub_403690(__int64 *a1, int a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  int v8; // er13

  v8 = sub_40480A(a1, a2);
  sub_406B69(a1, a3, a4, a5, a6);
  return sub_403616(a1, v8, a5, a6);
}

//----- (00000000004036CF) ----------------------------------------------------
__int64 __fastcall sub_4036CF(__int64 *a1, int a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  int v8; // er13

  v8 = sub_40480A(a1, a2);
  sub_406EC3(a1, a3, a4, a5, a6);
  return sub_403616(a1, v8, a5, a6);
}

//----- (000000000040370E) ----------------------------------------------------
__int64 __fastcall sub_40370E(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_406AAF(a1, a3, a4, a5);
  return sub_403616(a1, v6, a4, a5);
}

//----- (0000000000403745) ----------------------------------------------------
__int64 __fastcall sub_403745(__int64 *a1, int a2, unsigned int *a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_4076F0(a1, a3, a4, a5);
  return sub_403616(a1, v6, a4, a5);
}

//----- (000000000040377C) ----------------------------------------------------
__int64 __fastcall sub_40377C(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbx
  int v6; // er13

  v5 = a3;
  v6 = sub_40480A(a1, a2);
  sub_407808(a1, *(_QWORD *)(a1[71] + 8 * v5), a4, a5);
  return sub_403616(a1, v6, a4, a5);
}

//----- (00000000004037B9) ----------------------------------------------------
__int64 __fastcall sub_4037B9(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40377C(a1, a2 >> 16, (unsigned __int16)a2, a3, a4);
}

//----- (00000000004037C1) ----------------------------------------------------
__int64 __fastcall sub_4037C1(__int64 *a1, int a2, unsigned int a3, _DWORD *a4, __m128 a5, __m128 a6)
{
  int v7; // eax

  v7 = sub_40377C(a1, a2, a3, a5, a6);
  if ( a4 )
    *a4 = v7;
  return sub_405C10(a1, a5, a6);
}

//----- (00000000004037EC) ----------------------------------------------------
__int64 __fastcall sub_4037EC(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v6; // r13
  __int64 v7; // rax
  __int128 *v8; // rsi

  v4 = sub_405823((__int64)a1, a2);
  if ( !v4 )
    return 0LL;
  v6 = v4;
  v7 = sub_40574F(a1, -1, a3, a4);
  v8 = (__int128 *)sub_40E5DF(a1[8], v6, v7);
  if ( !v8 )
    return 0LL;
  sub_406883(a1, v8, a3, a4);
  sub_405181(a1, a3, a4);
  return 1LL;
}

//----- (0000000000403846) ----------------------------------------------------
__int64 __fastcall sub_403846(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbx
  int v6; // er13

  v5 = a3;
  v6 = sub_40480A(a1, a2);
  sub_407808(a1, *(_QWORD *)(a1[71] + 8 * v5), a4, a5);
  return sub_4037EC(a1, v6, a4, a5);
}

//----- (0000000000403883) ----------------------------------------------------
__int64 __fastcall sub_403883(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_403846(a1, a2 >> 16, (unsigned __int16)a2, a3, a4);
}

//----- (000000000040388B) ----------------------------------------------------
__int64 __fastcall sub_40388B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_4035A2(a1, a2, -2, a3, a4);
}

//----- (0000000000403895) ----------------------------------------------------
__int64 __fastcall sub_403895(__int64 *a1, int a2, __int64 a3, __m128 a4, __m128 a5)
{
  int v6; // er13
  __int64 v7; // rdx

  v6 = sub_4047ED((__int64)a1, a2);
  sub_406D71(a1, a3, v7, a4, a5);
  return sub_4035A2(a1, v6, -1, a4, a5);
}
// 4038B4: variable 'v7' is possibly undefined

//----- (00000000004038CF) ----------------------------------------------------
__int64 __fastcall sub_4038CF(__int64 *a1, int a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  int v8; // er13

  v8 = sub_4047ED((__int64)a1, a2);
  sub_406B69(a1, a3, a4, a5, a6);
  return sub_4035A2(a1, v8, -1, a5, a6);
}

//----- (0000000000403911) ----------------------------------------------------
__int64 __fastcall sub_403911(__int64 *a1, int a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  int v8; // er13

  v8 = sub_4047ED((__int64)a1, a2);
  sub_406EC3(a1, a3, a4, a5, a6);
  return sub_4035A2(a1, v8, -1, a5, a6);
}

//----- (0000000000403953) ----------------------------------------------------
__int64 __fastcall sub_403953(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_406AAF(a1, a3, a4, a5);
  return sub_4035A2(a1, v6, -1, a4, a5);
}

//----- (000000000040398D) ----------------------------------------------------
__int64 __fastcall sub_40398D(__int64 *a1, int a2, unsigned int *a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_4076F0(a1, a3, a4, a5);
  return sub_4035A2(a1, v6, -1, a4, a5);
}

//----- (00000000004039C7) ----------------------------------------------------
__int64 __fastcall sub_4039C7(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbx
  int v6; // er13

  v5 = a3;
  v6 = sub_40480A(a1, a2);
  sub_407808(a1, *(_QWORD *)(a1[71] + 8 * v5), a4, a5);
  return sub_4035A2(a1, v6, -1, a4, a5);
}

//----- (0000000000403A07) ----------------------------------------------------
__int64 __fastcall sub_403A07(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_4039C7(a1, a2 >> 16, (unsigned __int16)a2, a3, a4);
}

//----- (0000000000403A0F) ----------------------------------------------------
__int64 __fastcall sub_403A0F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int128 *v4; // r13
  __int128 *v5; // r14
  unsigned int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned int v10; // [rsp+Ch] [rbp-24h]

  v4 = (__int128 *)sub_404A12(a1, a2);
  v5 = (__int128 *)sub_404A12(a1, -1);
  v6 = sub_41DCBE((__int64)a1);
  v10 = sub_41018F(a1, v4, v5, v6, a3, a4);
  sub_407D7E(a1, (__int64)v4, v7, v8, a3, a4);
  return v10;
}
// 403A54: variable 'v7' is possibly undefined
// 403A54: variable 'v8' is possibly undefined

//----- (0000000000403B1D) ----------------------------------------------------
__int64 __fastcall sub_403B1D(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_406AAF(a1, a3, a4, a5);
  return sub_403A0F(a1, v6, a4, a5);
}

//----- (0000000000403BC8) ----------------------------------------------------
__int64 __fastcall sub_403BC8(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int *v4; // r13
  __int128 *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  unsigned int v9; // [rsp+Ch] [rbp-14h]

  v4 = (int *)sub_404A12(a1, a2);
  v5 = (__int128 *)sub_404A12(a1, -1);
  v9 = sub_40F1DF(a1, v4, v5, *(double *)a3.i64, a4);
  sub_407D7E(a1, (__int64)v4, v6, v7, a3, a4);
  return v9;
}
// 403BFE: variable 'v6' is possibly undefined
// 403BFE: variable 'v7' is possibly undefined

//----- (0000000000403CC0) ----------------------------------------------------
__int64 __fastcall sub_403CC0(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_406AAF(a1, a3, a4, a5);
  return sub_403BC8(a1, v6, a4, a5);
}

//----- (0000000000403D2E) ----------------------------------------------------
__int64 __fastcall sub_403D2E(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbx
  int v6; // er13

  v5 = a3;
  v6 = sub_40480A(a1, a2);
  sub_407808(a1, *(_QWORD *)(a1[71] + 8 * v5), a4, a5);
  return sub_403BC8(a1, v6, a4, a5);
}

//----- (0000000000403D6B) ----------------------------------------------------
__int64 __fastcall sub_403D6B(__int64 *a1, int a2, char a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rax
  __int64 v7; // r13
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v11; // [rsp-8h] [rbp-20h]

  v11 = v5;
  v7 = sub_40582D(a1, a2, a4, a5);
  v8 = sub_4089B9(a1, -2, a4, a5);
  sub_4103F9(a1, v7, v8, a3, a4, a5);
  return sub_407D7E(a1, v7, v11, v9, a4, a5);
}
// 403D7B: variable 'v5' is possibly undefined
// 403DAD: variable 'v9' is possibly undefined

//----- (0000000000403DB2) ----------------------------------------------------
__int64 __fastcall sub_403DB2(__int64 *a1, int a2, unsigned int a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rax

  v6 = sub_40582D(a1, a2, a5, a6);
  return sub_4105E1(a1, v6, a3, a4, a5, a6);
}

//----- (0000000000403DDC) ----------------------------------------------------
__int64 __fastcall sub_403DDC(__int64 *a1, int a2, unsigned int a3, char a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rax

  v6 = a3;
  v7 = sub_40582D(a1, a2, a5, a6);
  return sub_4103F9(a1, v7, *(_QWORD *)(a1[71] + 8 * v6), a4, a5, a6);
}

//----- (0000000000403E13) ----------------------------------------------------
__int64 __fastcall sub_403E13(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_403DDC(a1, a2 >> 24, (unsigned __int16)((unsigned int)a2 >> 8), a2, a3, a4);
}

//----- (0000000000403E29) ----------------------------------------------------
__int64 __fastcall sub_403E29(__int64 *a1, int a2, __int16 a3, __m128 a4, __m128 a5)
{
  __int64 v6; // r15
  const char *v7; // rcx
  unsigned int v8; // edx
  __int64 v9; // rbx
  int v10; // eax
  unsigned int v11; // er12
  __int64 v12; // rcx
  __int64 v13; // r8
  const signed __int32 *v14; // rax
  const signed __int32 *v15; // r9
  __int64 v16; // rcx
  __int64 v17; // r8
  const signed __int32 *v18; // rax
  int v19; // er8
  __int64 v21; // [rsp+8h] [rbp-48h]
  int v22; // [rsp+14h] [rbp-3Ch]
  __int64 v23; // [rsp+18h] [rbp-38h]

  v6 = sub_40582D(a1, a2, a4, a5);
  if ( (a3 & 0x48) != 0 && (a3 & 0x180) != 0 )
  {
    v7 = "invalid descriptor";
    v8 = 100663905;
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_api_object.c", v8, v7, a4, a5);
  }
  v9 = 0LL;
  v10 = sub_404C73((__int64)a1);
  v11 = v10;
  if ( (a3 & 0x100) != 0 )
  {
    sub_406117(a1, v10, a4, a5);
    v14 = (const signed __int32 *)sub_408491(a1, v11, 512LL, v12, v13, a4, a5);
    v9 = (__int64)v14;
    if ( v14 && !_bittest(v14, 9u) )
      goto LABEL_15;
    --v11;
  }
  v15 = 0LL;
  if ( (a3 & 0x80u) != 0 )
  {
    sub_406117(a1, v11, a4, a5);
    v18 = (const signed __int32 *)sub_408491(a1, v11, 512LL, v16, v17, a4, a5);
    v15 = v18;
    if ( !v18 || _bittest(v18, 9u) )
    {
      --v11;
      goto LABEL_12;
    }
LABEL_15:
    v7 = "not callable";
    v8 = 100663909;
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_api_object.c", v8, v7, a4, a5);
  }
LABEL_12:
  v19 = -1;
  if ( (a3 & 0x40) != 0 )
    v19 = v11--;
  v21 = (__int64)v15;
  v22 = v19;
  v23 = sub_4089B9(a1, v11, a4, a5);
  sub_404AC6(a1, v11);
  sub_410A94(a1, a3, v6, v23, v22, v21, a4, a5, v9, 1);
  return sub_404B20(a1, v11, a4, a5);
}
// 403E94: variable 'v12' is possibly undefined
// 403E94: variable 'v13' is possibly undefined
// 403ED2: variable 'v16' is possibly undefined
// 403ED2: variable 'v17' is possibly undefined

//----- (0000000000403F77) ----------------------------------------------------
__int64 __fastcall sub_403F77(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  int v6; // er13

  v6 = sub_40480A(a1, a2);
  sub_407826(a1, a3, a4, a5);
  sub_407CED(a1, 33, a4, a5);
  sub_404F67(a1, a4, a5);
  return sub_403E29(a1, v6, 896, a4, a5);
}

//----- (0000000000403FC8) ----------------------------------------------------
__int64 __fastcall sub_403FC8(_QWORD *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  result = sub_405823((__int64)a1, a2);
  if ( result )
    return sub_40E4C4(a1, result, a3, a4);
  return result;
}

//----- (0000000000403FED) ----------------------------------------------------
__int64 __fastcall sub_403FED(_QWORD *a1, __m128 a2, __m128 a3)
{
  return sub_403FC8(a1, -1, a2, a3);
}

//----- (0000000000403FF2) ----------------------------------------------------
__int64 __fastcall sub_403FF2(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v6; // rcx
  __int64 v7; // r8

  sub_404F0A(a1, a2, a4, a5);
  sub_408496(a1, -1, 640LL, v6, v7, a4, a5);
  return sub_40D757(a1, a3, a4, a5);
}
// 404010: variable 'v6' is possibly undefined
// 404010: variable 'v7' is possibly undefined

//----- (0000000000404025) ----------------------------------------------------
__int64 __fastcall sub_404025(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  sub_40582D(a1, a2, a4, a5);
  sub_404F0A(a1, a2, a4, a5);
  return sub_40DAF3(a1, a3, a4, a5);
}

//----- (000000000040405C) ----------------------------------------------------
__int64 __fastcall sub_40405C(_QWORD *a1, int a2, int a3, __m128 a4, __m128 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v9; // rax
  const signed __int32 *v10; // r14

  v9 = sub_404A12(a1, a2);
  if ( *(_DWORD *)v9 == 9 )
  {
    v10 = *(const signed __int32 **)(v9 + 8);
    if ( !a3 || !_bittest(v10, 0xDu) )
    {
      sub_41168F(a1, *(_QWORD *)(v9 + 8), a3, a4, a5);
      return sub_40E4C4(a1, (__int64)v10, a4, a5);
    }
    return sub_401D12(a1, (__int64)"third_party/duktape/duk_api_object.c", 708, a4, a5);
  }
  if ( *(_DWORD *)v9 == 10 && a3 )
    return sub_401D12(a1, (__int64)"third_party/duktape/duk_api_object.c", 708, a4, a5);
  return a8;
}

//----- (00000000004042B7) ----------------------------------------------------
__int64 __fastcall sub_4042B7(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned int v7; // [rsp+Ch] [rbp-14h]

  sub_407C45(a1, a1[20], a3, a4);
  sub_40500F(a1, -2);
  v7 = sub_403895(a1, -2, a2, a3, a4);
  sub_407D7E(a1, 4294967294LL, v4, v5, a3, a4);
  return v7;
}
// 4042F8: variable 'v4' is possibly undefined
// 4042F8: variable 'v5' is possibly undefined

//----- (0000000000404413) ----------------------------------------------------
__int64 __fastcall sub_404413(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  sub_40377C(a1, a2, a3, a4, a5);
  if ( (sub_406103((__int64)a1, -1) & 6) != 0 )
  {
    sub_407DA6((__int64)a1);
    return 0LL;
  }
  else if ( sub_4065F2((__int64)a1, -1) )
  {
    return 1LL;
  }
  else
  {
    sub_401C42(a1, (__int64)"third_party/duktape/duk_api_object.c", 0x6000383u, "not callable", a4, a5);
    return 0LL;
  }
}

//----- (000000000040447B) ----------------------------------------------------
__int64 __fastcall sub_40447B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  __int64 v5; // rsi

  v5 = *(_QWORD *)(sub_40582D(a1, a2, a3, a4) + 32);
  if ( v5 )
    return sub_407C45(a1, v5, a3, a4);
  else
    return sub_4068D1(a1, 0LL, v4, a3, a4);
}
// 4044A0: variable 'v4' is possibly undefined

//----- (00000000004044A5) ----------------------------------------------------
__int64 __fastcall sub_4044A5(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rcx

  v4 = sub_40582D(a1, a2, a3, a4);
  sub_406117(a1, -1, a3, a4);
  v5 = sub_405823((__int64)a1, -1);
  sub_40DCFB((__int64)a1, v4, v5, v6, a3, a4);
  return sub_407D7E(a1, v4, v7, v8, a3, a4);
}
// 4044DC: variable 'v6' is possibly undefined
// 4044E9: variable 'v7' is possibly undefined
// 4044E9: variable 'v8' is possibly undefined

//----- (00000000004044EE) ----------------------------------------------------
__int64 __fastcall sub_4044EE(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rcx

  v4 = sub_40582D(a1, a2, a3, a4);
  return sub_40DCFB((__int64)a1, v4, 0LL, v5, a3, a4);
}
// 404509: variable 'v5' is possibly undefined

//----- (0000000000404524) ----------------------------------------------------
__int64 __fastcall sub_404524(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40377C(a1, a2, 0x69u, a3, a4);
}

//----- (000000000040452E) ----------------------------------------------------
__int64 __fastcall sub_40452E(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int *v4; // rbx
  _BOOL4 v5; // er14
  int v6; // eax
  __int64 result; // rax

  v4 = (int *)sub_40582D(a1, a2, a3, a4);
  v5 = sub_4065F2((__int64)a1, -1);
  sub_4039C7(a1, a2, 0x69u, a3, a4);
  v6 = *v4;
  if ( v5 )
    result = v6 | 0x200000u;
  else
    result = v6 & 0xFFDFFFFF;
  *v4 = result;
  return result;
}

//----- (0000000000404583) ----------------------------------------------------
__int64 __fastcall sub_404583(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // rax

  v2 = 16LL * a2;
  if ( a2 >= 0 )
    v3 = *(_QWORD *)(a1 + 104) + v2;
  else
    v3 = *(_QWORD *)(a1 + 112) + v2;
  return *(_QWORD *)(v3 + 8);
}

//----- (000000000040459D) ----------------------------------------------------
__int64 __fastcall sub_40459D(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  unsigned __int64 v6; // rbx
  __int64 v7; // r14
  __int64 v8; // r13
  int v9; // eax
  __int64 v12; // [rsp+8h] [rbp-28h]

  v6 = 16LL * (int)a2;
  v7 = *(_QWORD *)(a1 + 112);
  v8 = v7;
  while ( v8 != v7 - v6 )
  {
    v9 = *(_DWORD *)(v8 - 16);
    v8 -= 16LL;
    a2 = *(_DWORD **)(v8 + 8);
    *(_DWORD *)v8 = 2;
    if ( (v9 & 8) != 0 && a2[1]-- == 1 )
    {
      v12 = a1;
      sub_40CFD5(a1, a2, a3, a4, a5, a6);
    }
  }
  *(_QWORD *)(a1 + 112) = v7 - 16 * (v6 >> 4);
  return sub_40CA65(a1, a2, v12);
}
// 4045E6: variable 'a3' is possibly undefined
// 4045E6: variable 'a4' is possibly undefined
// 40460A: variable 'v12' is possibly undefined
// 40CA65: using guessed type __int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD);

//----- (000000000040460F) ----------------------------------------------------
__int64 __fastcall sub_40460F(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  _DWORD *v7; // rsi
  __int64 v8; // rdx

  result = *(_QWORD *)(a1 + 112);
  v7 = *(_DWORD **)(result - 8);
  *(_QWORD *)(a1 + 112) = result - 16;
  v8 = *(unsigned int *)(result - 16);
  *(_DWORD *)(result - 16) = 2;
  LOBYTE(v8) = v8 & 8;
  if ( (_BYTE)v8 )
  {
    if ( v7[1]-- == 1 )
      return sub_40CFCD(a1, v7, v8, a4, a5, a6);
  }
  return result;
}

//----- (0000000000404639) ----------------------------------------------------
__int64 __fastcall sub_404639(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rax
  _DWORD *v7; // rsi
  __int64 v8; // rdx
  bool v9; // zf
  __int64 result; // rax
  _DWORD *v11; // rsi
  __int64 v12; // rdx

  v6 = *(_QWORD *)(a1 + 112);
  v7 = *(_DWORD **)(v6 - 8);
  *(_QWORD *)(a1 + 112) = v6 - 16;
  v8 = *(unsigned int *)(v6 - 16);
  *(_DWORD *)(v6 - 16) = 2;
  LOBYTE(v8) = v8 & 8;
  if ( (_BYTE)v8 )
  {
    v9 = v7[1]-- == 1;
    if ( v9 )
      sub_40CFCD(a1, v7, v8, a4, a5, a6);
  }
  result = *(_QWORD *)(a1 + 112);
  v11 = *(_DWORD **)(result - 8);
  *(_QWORD *)(a1 + 112) = result - 16;
  v12 = *(unsigned int *)(result - 16);
  *(_DWORD *)(result - 16) = 2;
  LOBYTE(v12) = v12 & 8;
  if ( (_BYTE)v12 )
  {
    v9 = v11[1]-- == 1;
    if ( v9 )
      return sub_40CFCD(a1, v11, v12, a4, a5, a6);
  }
  return result;
}
// 404697: variable 'a4' is possibly undefined

//----- (000000000040469E) ----------------------------------------------------
_OWORD *__fastcall sub_40469E(_QWORD *a1, int a2, __m128 a3, __m128 a4)
{
  _OWORD *v4; // rcx
  bool v5; // zf
  _OWORD *result; // rax

  if ( a1[14] >= a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4509, a3, a4);
  v4 = (_OWORD *)a1[14];
  v5 = a1[15] == 0LL;
  result = v4 + 1;
  a1[14] = v4 + 1;
  if ( v5 )
  {
    if ( !a2 )
      return result;
    return (_OWORD *)sub_401C42(
                       a1,
                       (__int64)"third_party/duktape/duk_api_stack.c",
                       0x60011B9u,
                       "not object coercible",
                       a3,
                       a4);
  }
  result = (_OWORD *)a1[13];
  if ( a2 && (unsigned int)(*((_DWORD *)result - 4) - 2) <= 1 )
    return (_OWORD *)sub_401C42(
                       a1,
                       (__int64)"third_party/duktape/duk_api_stack.c",
                       0x60011B9u,
                       "not object coercible",
                       a3,
                       a4);
  *v4 = *(result - 1);
  if ( (*(_BYTE *)(result - 1) & 8) != 0 )
  {
    result = (_OWORD *)*((_QWORD *)result - 1);
    ++*((_DWORD *)result + 1);
  }
  return result;
}

//----- (000000000040472D) ----------------------------------------------------
__int64 __fastcall sub_40472D(_QWORD *a1, __int64 a2, unsigned int a3, int a4, unsigned int a5, __m128 a6, __m128 a7)
{
  __int64 v9; // rbx
  int *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // r9

  v9 = a5;
  if ( a1[14] >= a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5071, a6, a7);
  if ( a2 && (a3 <= 0x7FFE || a3 == -1) )
  {
    v10 = sub_40D562(a1, a4, a6, a7);
    v11 = a1[14];
    *((_QWORD *)v10 + 7) = a2;
    *((_WORD *)v10 + 32) = a3;
    *(_DWORD *)v11 = 9;
    *(_QWORD *)(v11 + 8) = v10;
    v12 = v11 - a1[13];
    ++v10[1];
    a1[14] = v11 + 16;
    v13 = a1[v9 + 20];
    v14 = v12 >> 4;
    *((_QWORD *)v10 + 4) = v13;
    if ( v13 )
      ++*(_DWORD *)(v13 + 4);
  }
  else
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5104, a6, a7);
    LODWORD(v14) = 0;
  }
  return (unsigned int)v14;
}

//----- (00000000004047ED) ----------------------------------------------------
__int64 __fastcall sub_4047ED(__int64 a1, int a2)
{
  __int64 v2; // rax
  bool v3; // cf
  __int64 result; // rax

  v2 = (__int64)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 4;
  if ( a2 < 0 )
    a2 += v2;
  v3 = a2 < (unsigned int)v2;
  result = 0x80000000LL;
  if ( v3 )
    return (unsigned int)a2;
  return result;
}

//----- (000000000040480A) ----------------------------------------------------
__int64 __fastcall sub_40480A(__int64 *a1, int a2)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = (a1[14] - a1[13]) >> 4;
  result = (unsigned int)(a2 + v2);
  if ( a2 >= 0 )
    result = (unsigned int)a2;
  if ( (unsigned int)result >= (unsigned int)v2 )
  {
    sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 300, a2);
    return 0LL;
  }
  return result;
}

//----- (000000000040483D) ----------------------------------------------------
__int64 __fastcall sub_40483D(__int64 a1, int a2)
{
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 104);
  v3 = (*(_QWORD *)(a1 + 112) - v2) >> 4;
  if ( a2 < 0 )
    a2 += v3;
  result = 0LL;
  if ( a2 < (unsigned int)v3 )
    return v2 + 16LL * (unsigned int)a2;
  return result;
}

//----- (0000000000404863) ----------------------------------------------------
__int64 *__fastcall sub_404863(__int64 a1, int a2)
{
  __int64 *result; // rax

  result = (__int64 *)sub_40483D(a1, a2);
  if ( !result )
    return qword_43C420;
  return result;
}
// 43C420: using guessed type __int64 qword_43C420[2];

//----- (0000000000404878) ----------------------------------------------------
__int64 __fastcall sub_404878(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // rax
  unsigned int v5; // er8
  int v6; // er9
  int v7; // er10
  double v9; // [rsp+8h] [rbp-8h]

  v4 = sub_404863((__int64)a1, a2);
  if ( *(_DWORD *)v4 )
  {
    if ( v7 )
    {
      sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 174, v6, "number", a3, a4);
      return 0;
    }
  }
  else
  {
    v9 = *((double *)v4 + 1);
    v5 = sub_42FB3D(v9);
    if ( v5 )
    {
      v5 = 0x80000000;
      if ( v9 >= -2147483648.0 )
      {
        v5 = 0x7FFFFFFF;
        if ( v9 <= 2147483647.0 )
          return (unsigned int)(int)v9;
      }
    }
  }
  return v5;
}
// 4048DC: variable 'v7' is possibly undefined
// 4048F1: variable 'v6' is possibly undefined
// 4048F9: variable 'v5' is possibly undefined

//----- (00000000004048FE) ----------------------------------------------------
__int64 __fastcall sub_4048FE(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // rax
  int v5; // er8
  int v6; // er9
  unsigned int v7; // er10
  unsigned int v8; // er12
  double v10; // [rsp+8h] [rbp-18h]

  v4 = sub_404863((__int64)a1, a2);
  v8 = *(_DWORD *)v4;
  if ( *(_DWORD *)v4 )
  {
    v8 = v7;
    if ( v5 )
    {
      v8 = 0;
      sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 225, v6, "number", a3, a4);
    }
  }
  else
  {
    v10 = *((double *)v4 + 1);
    if ( (unsigned int)sub_42FB3D(v10) )
    {
      if ( v10 >= 0.0 )
      {
        v8 = -1;
        if ( v10 <= 4294967295.0 )
          return (unsigned int)(int)v10;
      }
    }
  }
  return v8;
}
// 404957: variable 'v7' is possibly undefined
// 40495A: variable 'v5' is possibly undefined
// 404972: variable 'v6' is possibly undefined

//----- (0000000000404982) ----------------------------------------------------
__int64 __fastcall sub_404982(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  __int64 *v5; // rax
  __int64 v6; // r8
  int v7; // er9
  __int64 v8; // r10
  _QWORD *v9; // r11
  __int64 v10; // rax

  if ( a3 )
    *a3 = 0LL;
  v5 = sub_404863((__int64)a1, a2);
  if ( *(_DWORD *)v5 == 10 )
  {
    v10 = v5[1];
    v6 = *(_QWORD *)(v10 + 24);
    v8 = v10 + 32;
    if ( *(char *)v10 < 0 )
      v8 = *(_QWORD *)(v10 + 32);
  }
  else if ( v7 )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1924, a2, "buffer", a4, a5);
    return 0LL;
  }
  if ( v9 )
    *v9 = v6;
  return v8;
}
// 4049C6: variable 'v7' is possibly undefined
// 4049E8: variable 'v9' is possibly undefined
// 4049EA: variable 'v6' is possibly undefined
// 4049EE: variable 'v8' is possibly undefined

//----- (00000000004049F5) ----------------------------------------------------
__int64 __fastcall sub_4049F5(__int64 a1, int a2)
{
  __int64 *v2; // rax
  __int64 v3; // r9
  int v4; // er8

  v2 = sub_404863(a1, a2);
  v3 = 0LL;
  if ( *(_DWORD *)v2 == v4 )
    return v2[1];
  return v3;
}
// 404A07: variable 'v4' is possibly undefined

//----- (0000000000404A12) ----------------------------------------------------
__int64 __fastcall sub_404A12(__int64 *a1, int a2)
{
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // rdx

  v3 = a1[13];
  v4 = (a1[14] - v3) >> 4;
  v5 = (unsigned int)(a2 + v4);
  if ( a2 >= 0 )
    v5 = (unsigned int)a2;
  if ( (unsigned int)v5 < (unsigned int)v4 )
    return 16 * v5 + v3;
  sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 376, a2);
  return 0LL;
}

//----- (0000000000404A4F) ----------------------------------------------------
__int64 __fastcall sub_404A4F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  unsigned int *v5; // rax
  __int64 v6; // rcx
  _DWORD *v7; // rsi
  __int64 v8; // rdx
  __int64 v11; // [rsp+0h] [rbp-20h]

  v4 = sub_404A12(a1, a2);
  sub_417A42(a1, v4, a3, a4);
  v5 = (unsigned int *)sub_404A12(a1, a2);
  v8 = *v5;
  v7 = (_DWORD *)*((_QWORD *)v5 + 1);
  *v5 = 0;
  LOBYTE(v8) = v8 & 8;
  *((_QWORD *)v5 + 1) = a3.i64[0];
  if ( (_BYTE)v8 )
  {
    if ( v7[1]-- == 1 )
      sub_40CFCD((__int64)a1, v7, v8, v6, a3, a4);
  }
  return v11;
}
// 404AA4: variable 'v6' is possibly undefined
// 404AAE: variable 'v11' is possibly undefined

//----- (0000000000404AC6) ----------------------------------------------------
__int64 __fastcall sub_404AC6(__int64 *a1, int a2)
{
  __int64 result; // rax
  int v3; // ecx

  result = sub_4047ED((__int64)a1, a2);
  if ( (int)result < 0 )
    return sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 394, v3);
  return result;
}
// 404AE0: variable 'v3' is possibly undefined

//----- (0000000000404AE7) ----------------------------------------------------
__int64 __fastcall sub_404AE7(__int64 a1)
{
  return (__int64)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 4;
}

//----- (0000000000404AF4) ----------------------------------------------------
__int64 __fastcall sub_404AF4(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  result = (a1[14] - a1[13]) >> 4;
  if ( a2 > (int)result )
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_stack.c", 419, a3, a4);
    return 0LL;
  }
  return result;
}

//----- (0000000000404B20) ----------------------------------------------------
__int64 __fastcall sub_404B20(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 result; // rax
  __int64 v8; // rdx
  __int64 v9; // r12
  int v10; // eax
  _DWORD *v11; // rsi
  _QWORD *v13; // [rsp+8h] [rbp-18h]

  v4 = a2;
  v5 = a1[14];
  v6 = a1[13];
  result = (v5 - v6) >> 4;
  v8 = (unsigned int)(v4 + result);
  if ( (int)v4 >= 0 )
    v8 = (unsigned int)v4;
  if ( (unsigned int)v8 > (unsigned int)((a1[11] - v6) >> 4) )
    return sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 464, v4);
  if ( (unsigned int)v8 < (unsigned int)result )
  {
    v9 = v5 - 16LL * (unsigned int)(result - v8);
    do
    {
      v10 = *(_DWORD *)(v5 - 16);
      v5 -= 16LL;
      v11 = *(_DWORD **)(v5 + 8);
      *(_DWORD *)v5 = 2;
      if ( (v10 & 8) != 0 && v11[1]-- == 1 )
      {
        v13 = a1;
        sub_40CFD5((__int64)a1, v11, v8, v4, a3, a4);
      }
    }
    while ( v9 != v5 );
    a1[14] = v9;
    return sub_40CA65(a1, v11, v13);
  }
  else
  {
    a1[14] = v6 + 16 * v8;
  }
  return result;
}
// 404BAF: variable 'v8' is possibly undefined
// 404BAF: variable 'v4' is possibly undefined
// 404BC7: variable 'v13' is possibly undefined
// 40CA65: using guessed type __int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD);

//----- (0000000000404BCC) ----------------------------------------------------
__int64 __fastcall sub_404BCC(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rdx
  __int64 result; // rax
  __int64 v9; // r13
  int v10; // eax
  _DWORD *v11; // rsi
  __int64 v13; // [rsp+8h] [rbp-18h]

  v6 = *(_QWORD *)(a1 + 112);
  v7 = *(_QWORD *)(a1 + 104);
  result = (v6 - v7) >> 4;
  if ( a2 < (unsigned int)result )
  {
    v9 = v6 - 16LL * ((unsigned int)result - a2);
    do
    {
      v10 = *(_DWORD *)(v6 - 16);
      v6 -= 16LL;
      v11 = *(_DWORD **)(v6 + 8);
      *(_DWORD *)v6 = 2;
      if ( (v10 & 8) != 0 && v11[1]-- == 1 )
      {
        v13 = a1;
        sub_40CFD5(a1, v11, v7, a4, a5, a6);
      }
    }
    while ( v9 != v6 );
    *(_QWORD *)(a1 + 112) = v9;
    return sub_40CA65(a1, v11, v13);
  }
  else
  {
    *(_QWORD *)(a1 + 112) = v7 + 16LL * a2;
  }
  return result;
}
// 404C2B: variable 'v7' is possibly undefined
// 404C2B: variable 'a4' is possibly undefined
// 404C43: variable 'v13' is possibly undefined
// 40CA65: using guessed type __int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD);

//----- (0000000000404C48) ----------------------------------------------------
__int64 __fastcall sub_404C48(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx

  sub_404BCC(a1, a3, a3, a4, a5, a6);
  return sub_404BCC(a1, a2, v6, v7, a5, a6);
}
// 404C6E: variable 'v6' is possibly undefined
// 404C6E: variable 'v7' is possibly undefined

//----- (0000000000404C73) ----------------------------------------------------
__int64 __fastcall sub_404C73(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)((__int64)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 4) - 1;
  if ( (int)result < 0 )
    return 0x80000000LL;
  return result;
}

//----- (0000000000404C89) ----------------------------------------------------
__int64 __fastcall sub_404C89(__int64 a1)
{
  return (unsigned int)((__int64)(*(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 104)) >> 4) - 1;
}

//----- (0000000000404C98) ----------------------------------------------------
__int64 __fastcall sub_404C98(__int64 *a1)
{
  __int64 result; // rax

  result = (unsigned int)((a1[14] - a1[13]) >> 4) - 1;
  if ( (int)result < 0 )
  {
    sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 647, -1);
    return 0LL;
  }
  return result;
}

//----- (0000000000404CC3) ----------------------------------------------------
unsigned __int64 __fastcall sub_404CC3(__int64 *a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rsi

  result = a2 + a1[10];
  if ( a1[11] < result )
  {
    if ( a1[12] < result )
    {
      v6 = (a2 >> 6) + (a2 >> 4);
      if ( v6 > 0xF4240 )
      {
        return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 848, "valstack limit", a3, a4);
      }
      else
      {
        result = sub_401B04(a1, v6, a3, a4);
        if ( (_DWORD)result )
          a1[11] = a1[10] + (a2 & 0xFFFFFFFFFFFFFFF0LL);
        else
          return sub_401CC7(a1, (__int64)"third_party/duktape/duk_api_stack.c", 856, a3, a4);
      }
    }
    else
    {
      a1[11] = result;
    }
  }
  return result;
}

//----- (0000000000404D56) ----------------------------------------------------
__int64 __fastcall sub_404D56(_QWORD *a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er13
  unsigned __int64 v5; // rax
  unsigned __int64 v7; // rsi

  v4 = 1;
  v5 = a2 + a1[10];
  if ( a1[11] < v5 )
  {
    if ( a1[12] < v5 )
    {
      v7 = (a2 >> 6) + (a2 >> 4);
      if ( v7 <= 0xF4240 && (unsigned int)sub_401B04(a1, v7, a3, a4) )
        a1[11] = a1[10] + (a2 & 0xFFFFFFFFFFFFFFF0LL);
      else
        return 0;
    }
    else
    {
      a1[11] = v5;
    }
  }
  return v4;
}

//----- (0000000000404DC3) ----------------------------------------------------
unsigned __int64 __fastcall sub_404DC3(_QWORD *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rsi

  v4 = a1[10];
  result = a1[12] - v4;
  v7 = a1[11] - v4;
  if ( !a2 )
  {
    if ( result - v7 < result >> 2 )
      return result;
    v7 += (result >> 4) & 0xFFFFFFFFFFFFFFF0LL;
  }
  if ( v7 < result )
    return sub_401B04(a1, v7 >> 4, a3, a4);
  return result;
}

//----- (0000000000404E0C) ----------------------------------------------------
__int64 __fastcall sub_404E0C(_QWORD *a1, int a2, __m128 a3, __m128 a4)
{
  if ( (unsigned int)a2 > 0xF4240 )
    a2 = ~(a2 >> 31) & 0xF4240;
  return sub_404D56(a1, a1[14] - a1[10] + 16 * (a2 + 32LL), a3, a4);
}

//----- (0000000000404E3A) ----------------------------------------------------
unsigned __int64 __fastcall sub_404E3A(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  if ( (unsigned int)a2 > 0xF4240 )
    a2 = ~(a2 >> 31) & 0xF4240;
  return sub_404CC3(a1, a1[14] - a1[10] + 16 * (a2 + 32LL), a3, a4);
}

//----- (0000000000404EC4) ----------------------------------------------------
__int64 __fastcall sub_404EC4(__int64 *a1, int a2, int a3)
{
  __int64 *v4; // rbx
  __int64 result; // rax
  __int64 v6; // rsi
  __int64 v7; // rdi

  v4 = (__int64 *)sub_404A12(a1, a2);
  result = sub_404A12(a1, a3);
  v6 = *v4;
  v7 = v4[1];
  *(_OWORD *)v4 = *(_OWORD *)result;
  *(_QWORD *)result = v6;
  *(_QWORD *)(result + 8) = v7;
  return result;
}

//----- (0000000000404F05) ----------------------------------------------------
__int64 __fastcall sub_404F05(__int64 *a1, int a2)
{
  return sub_404EC4(a1, a2, -1);
}

//----- (0000000000404F0A) ----------------------------------------------------
_QWORD *__fastcall sub_404F0A(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // r8
  _QWORD *result; // rax
  __int64 v6; // rsi
  __int64 v7; // rdx

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1096, a3, a4);
  v4 = (__int64 *)sub_404A12(a1, a2);
  result = (_QWORD *)a1[14];
  v6 = v4[1];
  a1[14] = (__int64)(result + 2);
  v7 = *v4;
  result[1] = v6;
  *result = v7;
  if ( (v7 & 8) != 0 )
    ++*(_DWORD *)(v6 + 4);
  return result;
}

//----- (0000000000404F67) ----------------------------------------------------
_QWORD *__fastcall sub_404F67(__int64 *a1, __m128 a2, __m128 a3)
{
  _QWORD *result; // rax
  __int64 v4; // rsi
  __int64 v5; // rdx

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1114, a2, a3);
  result = (_QWORD *)a1[14];
  if ( (__int64)result - a1[13] <= 0 )
    return (_QWORD *)sub_401CED(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1117, -1);
  v4 = *(result - 1);
  a1[14] = (__int64)(result + 2);
  v5 = *(result - 2);
  result[1] = v4;
  *result = v5;
  if ( (v5 & 8) != 0 )
    ++*(_DWORD *)(v4 + 4);
  return result;
}

//----- (0000000000404FD6) ----------------------------------------------------
_QWORD *__fastcall sub_404FD6(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, 0, a2, a3);
}

//----- (0000000000404FDD) ----------------------------------------------------
_QWORD *__fastcall sub_404FDD(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, 1, a2, a3);
}

//----- (0000000000404FE7) ----------------------------------------------------
_QWORD *__fastcall sub_404FE7(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, 2, a2, a3);
}

//----- (0000000000404FF1) ----------------------------------------------------
_QWORD *__fastcall sub_404FF1(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, -2, a2, a3);
}

//----- (0000000000404FFB) ----------------------------------------------------
_QWORD *__fastcall sub_404FFB(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, -3, a2, a3);
}

//----- (0000000000405005) ----------------------------------------------------
_QWORD *__fastcall sub_405005(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_404F0A(a1, -4, a2, a3);
}

//----- (000000000040500F) ----------------------------------------------------
void __fastcall sub_40500F(__int64 *a1, int a2)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // r8
  __int64 v5; // r9

  v2 = sub_404A12(a1, a2);
  v3 = sub_404A12(a1, -1);
  sub_43ABC2((_BYTE *)(v2 + 16), (_BYTE *)v2, v3 - v2);
  *(_QWORD *)v2 = v4;
  *(_QWORD *)(v2 + 8) = v5;
}
// 405049: variable 'v4' is possibly undefined
// 40504C: variable 'v5' is possibly undefined

//----- (0000000000405057) ----------------------------------------------------
__int64 __fastcall sub_405057(__int64 *a1, int a2, __int64 a3, __int64 a4, double a5, __m128 a6)
{
  __m128 *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rcx
  int v9; // edx
  _DWORD *v10; // rsi
  __m128 v11; // xmm0
  bool v12; // zf

  v6 = (__m128 *)sub_404A12(a1, -1);
  v7 = sub_404A12(a1, a2);
  v9 = *(_DWORD *)v7;
  v10 = *(_DWORD **)(v7 + 8);
  v11 = *v6;
  *(__m128 *)v7 = *v6;
  v6->i32[0] = 2;
  a1[14] -= 16LL;
  if ( (v9 & 8) != 0 && (v12 = v10[1] == 1, --v10[1], v12) )
    return sub_40CFCD((__int64)a1, v10, a4, v8, v11, a6);
  else
    return a4;
}
// 4050A9: variable 'v8' is possibly undefined

//----- (00000000004050B6) ----------------------------------------------------
__int64 __fastcall sub_4050B6(__int64 *a1, int a2, int a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v7; // rbx
  _QWORD *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rbx
  _DWORD *v11; // rsi

  v7 = sub_404A12(a1, a2);
  v8 = (_QWORD *)sub_404A12(a1, a3);
  if ( (*(_BYTE *)v7 & 8) != 0 )
    ++*(_DWORD *)(*(_QWORD *)(v7 + 8) + 4LL);
  v9 = *(_QWORD *)v7;
  v10 = *(_QWORD *)(v7 + 8);
  if ( (*(_BYTE *)v8 & 8) != 0 )
  {
    v11 = (_DWORD *)v8[1];
    *v8 = v9;
    v8[1] = v10;
    if ( v11[1]-- == 1 )
      return sub_40CFCD((__int64)a1, v11, a4, v9, a5, a6);
  }
  else
  {
    *v8 = v9;
    v8[1] = v10;
  }
  return a4;
}

//----- (000000000040511F) ----------------------------------------------------
void __fastcall sub_40511F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  _BYTE *v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rdx
  _DWORD *v7; // r8
  _DWORD *v8; // rax
  __int64 v9; // rcx

  v4 = (_BYTE *)sub_404A12(a1, a2);
  v5 = sub_404A12(a1, -1);
  sub_43ABC2(v4, v4 + 16, v5 - (_QWORD)v4);
  *v8 = 2;
  a1[14] -= 16LL;
  LOBYTE(v9) = v9 & 8;
  if ( (_BYTE)v9 )
  {
    if ( v7[1]-- == 1 )
      sub_40CFCD((__int64)a1, v7, v6, v9, a3, a4);
  }
}
// 405154: variable 'v8' is possibly undefined
// 405160: variable 'v9' is possibly undefined
// 405165: variable 'v7' is possibly undefined
// 405175: variable 'v6' is possibly undefined

//----- (0000000000405181) ----------------------------------------------------
void __fastcall sub_405181(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40511F(a1, -2, a2, a3);
}

//----- (0000000000405188) ----------------------------------------------------
_DWORD *__fastcall sub_405188(__int64 a1, int a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // r13
  _BYTE *v7; // rbx
  _BYTE *v8; // r14
  _DWORD *v9; // rsi
  unsigned __int64 v11; // rcx
  _DWORD *result; // rax
  __int64 v13; // [rsp+8h] [rbp-38h]

  v6 = 16LL * (int)a3;
  v7 = (_BYTE *)(16LL * a2 + *(_QWORD *)(a1 + 104));
  v8 = v7;
  v13 = *(_QWORD *)(a1 + 112) - (_QWORD)&v7[v6];
  while ( v8 < &v7[v6] )
  {
    if ( (*v8 & 8) != 0 )
    {
      v9 = (_DWORD *)*((_QWORD *)v8 + 1);
      if ( v9[1]-- == 1 )
        sub_40CFD5(a1, v9, a3, a4, a5, a6);
    }
    v8 += 16;
  }
  sub_43ABC2(v7, &v7[v6], v13);
  v11 = *(_QWORD *)(a1 + 112);
  for ( result = (_DWORD *)(v11 - v6); (unsigned __int64)result < v11; result += 4 )
    *result = 2;
  *(_QWORD *)(a1 + 112) = v11 - v6;
  return result;
}
// 4051DA: variable 'a3' is possibly undefined
// 4051DA: variable 'a4' is possibly undefined

//----- (0000000000405305) ----------------------------------------------------
void __fastcall sub_405305(__int64 a1, int a2, int a3)
{
  __int64 v3; // rcx
  _BYTE *v4; // rax
  __int64 v5; // rdx

  v3 = a3;
  v4 = (_BYTE *)(*(_QWORD *)(a1 + 104) + 16LL * a2);
  v5 = *(_QWORD *)(a1 + 112);
  v3 *= 16LL;
  *(_QWORD *)(a1 + 112) = v5 + v3;
  sub_43ABC2(&v4[v3], v4, v5 - (_QWORD)v4);
}

//----- (0000000000405335) ----------------------------------------------------
void __fastcall sub_405335(__int64 a1, int a2, int a3)
{
  _DWORD *v3; // rax
  __int64 v4; // r9
  _DWORD *v5; // r9

  sub_405305(a1, a2, a3);
  v5 = &v3[4 * v4];
  while ( v3 != v5 )
  {
    *v3 = 2;
    v3 += 4;
  }
}
// 405348: variable 'v3' is possibly undefined
// 405344: variable 'v4' is possibly undefined

//----- (00000000004053B6) ----------------------------------------------------
__int64 __fastcall sub_4053B6(__int64 a1, int a2)
{
  __int64 *v2; // rax
  unsigned int v3; // er8

  v2 = sub_404863(a1, a2);
  v3 = 0;
  if ( *(_DWORD *)v2 == 4 )
    return *((unsigned int *)v2 + 2);
  return v3;
}

//----- (000000000040541C) ----------------------------------------------------
double __fastcall sub_40541C(__int64 a1, int a2)
{
  __int64 *v2; // rax
  double result; // xmm0_8

  v2 = sub_404863(a1, a2);
  result = NAN;
  if ( !*(_DWORD *)v2 )
    return *((double *)v2 + 1);
  return result;
}

//----- (000000000040544E) ----------------------------------------------------
double __fastcall sub_40544E(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // rax
  int v5; // er9

  v4 = sub_404863((__int64)a1, a2);
  if ( !*(_DWORD *)v4 )
    return *((double *)v4 + 1);
  sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1592, v5, "number", a3, a4);
  return 0.0;
}
// 405472: variable 'v5' is possibly undefined

//----- (0000000000405483) ----------------------------------------------------
__int64 __fastcall sub_405483(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_404878(a1, a2, a3, a4);
}

//----- (000000000040548C) ----------------------------------------------------
__int64 __fastcall sub_40548C(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_4048FE(a1, a2, a3, a4);
}

//----- (00000000004054AF) ----------------------------------------------------
__int64 __fastcall sub_4054AF(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_4048FE(a1, a2, a3, a4);
}

//----- (00000000004054BB) ----------------------------------------------------
__int64 *__fastcall sub_4054BB(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *result; // rax
  int v5; // er9

  result = sub_404863((__int64)a1, a2);
  if ( *(_DWORD *)result != 9 )
    return (__int64 *)sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 1824, v5, "object", a3, a4);
  return result;
}
// 4054E0: variable 'v5' is possibly undefined

//----- (000000000040554E) ----------------------------------------------------
__int64 __fastcall sub_40554E(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  return sub_404982(a1, a2, a3, a4, a5);
}

//----- (0000000000405563) ----------------------------------------------------
__int64 __fastcall sub_405563(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  return sub_404982(a1, a2, a3, a4, a5);
}

//----- (0000000000405573) ----------------------------------------------------
__int64 __fastcall sub_405573(
        __int64 *a1,
        int a2,
        _QWORD *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __m128 xmm0_8_0,
        __m128 a8,
        _DWORD *a9)
{
  __int64 *v9; // rax
  int v10; // er9
  __int64 v11; // r10
  _QWORD *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r10

  if ( a9 )
    *a9 = 0;
  if ( a3 )
    *a3 = a5;
  v9 = sub_404863((__int64)a1, a2);
  if ( *(_DWORD *)v9 == 10 )
  {
    v13 = v9[1];
    if ( v12 )
      *v12 = *(_QWORD *)(v13 + 24);
    if ( a9 )
      *a9 = 1;
    v11 = v13 + 32;
    if ( *(char *)v13 < 0 )
      return *(_QWORD *)(v13 + 32);
  }
  else if ( *(_DWORD *)v9 == 9
         && (v14 = v9[1], _bittest((const signed __int32 *)v14, 0xDu))
         && (v15 = *(_QWORD *)(v14 + 56)) != 0
         && (unsigned __int64)(unsigned int)(*(_DWORD *)(v14 + 72) + *(_DWORD *)(v14 + 76)) <= *(_QWORD *)(v15 + 24) )
  {
    v16 = v15 + 32;
    if ( *(char *)v15 < 0 )
      v16 = *(_QWORD *)(v15 + 32);
    if ( v12 )
      *v12 = *(unsigned int *)(v14 + 76);
    if ( a9 )
      *a9 = 1;
    return *(unsigned int *)(v14 + 72) + v16;
  }
  else if ( v10 )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2028, a2, "buffer", xmm0_8_0, a8);
    return 0LL;
  }
  return v11;
}
// 4055B0: variable 'v12' is possibly undefined
// 405626: variable 'v10' is possibly undefined
// 405644: variable 'v11' is possibly undefined

//----- (000000000040564B) ----------------------------------------------------
__int64 __fastcall sub_40564B(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  return sub_405573(a1, a2, a3, 0LL, 0LL, 0LL, a4, a5, 0LL);
}

//----- (0000000000405672) ----------------------------------------------------
__int64 __fastcall sub_405672(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  return sub_405573(a1, a2, a3, 0LL, 0LL, 1LL, a4, a5, 0LL);
}

//----- (000000000040568B) ----------------------------------------------------
__int64 __fastcall sub_40568B(__int64 a1, int a2)
{
  return sub_4049F5(a1, a2);
}

//----- (0000000000405695) ----------------------------------------------------
__int64 __fastcall sub_405695(__int64 a1, int a2)
{
  __int64 result; // rax
  _QWORD *v3; // r10
  __int64 v4; // rdx

  result = sub_40568B(a1, a2);
  v4 = 0LL;
  if ( result )
  {
    v4 = *(unsigned int *)(result + 24);
    result += 32LL;
  }
  if ( v3 )
    *v3 = v4;
  return result;
}
// 4056B2: variable 'v3' is possibly undefined

//----- (00000000004056B9) ----------------------------------------------------
__int64 __fastcall sub_4056B9(__int64 a1, int a2)
{
  __int64 result; // rax

  result = sub_40568B(a1, a2);
  if ( result )
    result += 32LL;
  return result;
}

//----- (0000000000405717) ----------------------------------------------------
_DWORD *__fastcall sub_405717(__int64 a1, int a2)
{
  _DWORD *result; // rax

  result = (_DWORD *)sub_4049F5(a1, a2);
  if ( result )
  {
    if ( (*result & 0x200) != 0 )
      return 0LL;
  }
  return result;
}

//----- (000000000040573B) ----------------------------------------------------
_DWORD *__fastcall sub_40573B(__int64 a1, int a2)
{
  _DWORD *result; // rax

  result = sub_405717(a1, a2);
  if ( result )
    result += 8;
  return result;
}

//----- (000000000040574F) ----------------------------------------------------
__int64 __fastcall sub_40574F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // er10

  result = sub_4049F5((__int64)a1, a2);
  if ( !result )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2108, v5, "string", a3, a4);
    return 0LL;
  }
  return result;
}
// 405780: variable 'v5' is possibly undefined

//----- (000000000040578B) ----------------------------------------------------
__int64 __fastcall sub_40578B(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  __int64 v6; // rax

  v6 = sub_40574F(a1, a2, a4, a5);
  if ( a3 )
    *a3 = *(unsigned int *)(v6 + 24);
  return v6 + 32;
}

//----- (00000000004057AC) ----------------------------------------------------
__int64 __fastcall sub_4057AC(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40574F(a1, a2, a3, a4) + 32;
}

//----- (00000000004057BB) ----------------------------------------------------
const signed __int32 *__fastcall sub_4057BB(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  const signed __int32 *result; // rax
  int v5; // er10

  result = (const signed __int32 *)sub_4049F5((__int64)a1, a2);
  if ( !result || _bittest(result, 9u) )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2121, v5, "string", a3, a4);
    return 0LL;
  }
  return result;
}
// 4057EA: variable 'v5' is possibly undefined

//----- (00000000004057F3) ----------------------------------------------------
const signed __int32 *__fastcall sub_4057F3(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  const signed __int32 *v6; // rax

  v6 = sub_4057BB(a1, a2, a4, a5);
  if ( a3 )
    *a3 = *((unsigned int *)v6 + 6);
  return v6 + 8;
}

//----- (0000000000405823) ----------------------------------------------------
__int64 __fastcall sub_405823(__int64 a1, int a2)
{
  return sub_4049F5(a1, a2);
}

//----- (000000000040582D) ----------------------------------------------------
__int64 __fastcall sub_40582D(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // er10

  result = sub_4049F5((__int64)a1, a2);
  if ( !result )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2139, v5, "object", a3, a4);
    return 0LL;
  }
  return result;
}
// 40585E: variable 'v5' is possibly undefined

//----- (0000000000405869) ----------------------------------------------------
__int64 __fastcall sub_405869(__int64 a1, int a2)
{
  return sub_4049F5(a1, a2);
}

//----- (0000000000405873) ----------------------------------------------------
__int64 __fastcall sub_405873(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // er10

  result = sub_4049F5((__int64)a1, a2);
  if ( !result )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2157, v5, "buffer", a3, a4);
    return 0LL;
  }
  return result;
}
// 4058A4: variable 'v5' is possibly undefined

//----- (00000000004058AF) ----------------------------------------------------
_DWORD *__fastcall sub_4058AF(__int64 a1, int a2)
{
  _DWORD *result; // rax

  result = (_DWORD *)sub_4049F5(a1, a2);
  if ( result )
  {
    if ( *result >> 27 != 18 )
      return 0LL;
  }
  return result;
}

//----- (00000000004058D5) ----------------------------------------------------
_DWORD *__fastcall sub_4058D5(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  _DWORD *result; // rax
  int v5; // er10

  result = (_DWORD *)sub_4049F5((__int64)a1, a2);
  if ( !result || *result >> 27 != 18 )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2182, v5, "thread", a3, a4);
    return 0LL;
  }
  return result;
}
// 405908: variable 'v5' is possibly undefined

//----- (0000000000405991) ----------------------------------------------------
const signed __int32 *__fastcall sub_405991(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  const signed __int32 *result; // rax
  int v5; // er10

  result = (const signed __int32 *)sub_4049F5((__int64)a1, a2);
  if ( !result || !_bittest(result, 0xCu) )
  {
    sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2232, v5, "nativefunction", a3, a4);
    return 0LL;
  }
  return result;
}
// 4059C0: variable 'v5' is possibly undefined

//----- (00000000004059C9) ----------------------------------------------------
__int64 __fastcall sub_4059C9(__int64 a1, int a2)
{
  __int64 *v2; // rax
  __int64 v3; // r8
  __int64 v4; // rax

  v2 = sub_404863(a1, a2);
  v3 = 0LL;
  if ( *(_DWORD *)v2 == 9 )
  {
    v4 = v2[1];
    if ( _bittest((const signed __int32 *)v4, 0xCu) )
      return *(_QWORD *)(v4 + 56);
  }
  return v3;
}

//----- (0000000000405A5E) ----------------------------------------------------
__int64 __fastcall sub_405A5E(__int64 a1, int a2)
{
  __int64 *v2; // rax
  __int64 v3; // r8

  v2 = sub_404863(a1, a2);
  v3 = 0LL;
  if ( (*(_BYTE *)v2 & 8) != 0 )
    return v2[1];
  return v3;
}

//----- (0000000000405AC3) ----------------------------------------------------
_DWORD *__fastcall sub_405AC3(__int64 a1, int a2)
{
  _DWORD *result; // rax
  int v3; // er10

  result = (_DWORD *)sub_4049F5(a1, a2);
  if ( result )
  {
    if ( *result >> 27 != v3 )
      return 0LL;
  }
  return result;
}
// 405AE6: variable 'v3' is possibly undefined

//----- (0000000000405AEC) ----------------------------------------------------
_DWORD *__fastcall sub_405AEC(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  _DWORD *result; // rax
  __int64 v5; // r10
  int v6; // er11

  result = (_DWORD *)sub_4049F5((__int64)a1, a2);
  if ( !result || *result >> 27 != (_DWORD)v5 )
  {
    sub_401C60(
      a1,
      (__int64)"third_party/duktape/duk_api_stack.c",
      2495,
      v6,
      (const char *)(*(_QWORD *)(a1[71] + 8LL * (unsigned __int8)byte_448000[v5]) + 32LL),
      a3,
      a4);
    return 0LL;
  }
  return result;
}
// 405B0D: variable 'v5' is possibly undefined
// 405B33: variable 'v6' is possibly undefined

//----- (0000000000405B55) ----------------------------------------------------
unsigned int *__fastcall sub_405B55(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int *result; // rax
  __int64 v5; // rcx
  _DWORD *v6; // rsi
  __int64 v7; // rdx

  result = (unsigned int *)sub_404A12(a1, a2);
  v7 = *result;
  v6 = (_DWORD *)*((_QWORD *)result + 1);
  *result = 2;
  LOBYTE(v7) = v7 & 8;
  if ( (_BYTE)v7 )
  {
    if ( v6[1]-- == 1 )
      return (unsigned int *)sub_40CFCD((__int64)a1, v6, v7, v5, a3, a4);
  }
  return result;
}
// 405B81: variable 'v5' is possibly undefined

//----- (0000000000405BBB) ----------------------------------------------------
__int64 __fastcall sub_405BBB(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned int v7; // er13
  int v8; // eax
  _DWORD *v9; // rsi

  v4 = a1[13] + 16LL * (int)sub_40480A(a1, a2);
  v7 = sub_4178C9(v4);
  v8 = *(_DWORD *)v4;
  v9 = *(_DWORD **)(v4 + 8);
  *(_DWORD *)v4 = 4;
  *(_DWORD *)(v4 + 8) = v7;
  if ( (v8 & 8) != 0 && v9[1]-- == 1 )
    sub_40CFCD((__int64)a1, v9, v5, v6, a3, a4);
  return v7;
}
// 405C00: variable 'v5' is possibly undefined
// 405C00: variable 'v6' is possibly undefined

//----- (0000000000405C10) ----------------------------------------------------
__int64 __fastcall sub_405C10(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned int v7; // [rsp+Ch] [rbp-14h]

  v3 = sub_404A12(a1, -1);
  v7 = sub_4178C9(v3);
  sub_40460F((__int64)a1, 0xFFFFFFFFLL, v4, v5, a2, a3);
  return v7;
}
// 405C33: variable 'v4' is possibly undefined
// 405C33: variable 'v5' is possibly undefined

//----- (0000000000405C43) ----------------------------------------------------
__int64 __fastcall sub_405C43(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rbx
  __int64 v5; // rcx
  unsigned int *v6; // rax
  _DWORD *v7; // rsi
  __int64 v8; // rdx
  __int64 v11; // [rsp+0h] [rbp-20h]

  v4 = 16LL * (int)sub_40480A(a1, a2);
  *(double *)a3.i64 = sub_417910(a1, v4 + a1[13], a3, a4);
  v6 = (unsigned int *)(v4 + a1[13]);
  v8 = *v6;
  v7 = (_DWORD *)*((_QWORD *)v6 + 1);
  *((_QWORD *)v6 + 1) = a3.i64[0];
  *v6 = 0;
  LOBYTE(v8) = v8 & 8;
  if ( (_BYTE)v8 )
  {
    if ( v7[1]-- == 1 )
      sub_40CFCD((__int64)a1, v7, v8, v5, a3, a4);
  }
  return v11;
}
// 405C9A: variable 'v5' is possibly undefined
// 405CA4: variable 'v11' is possibly undefined

//----- (0000000000405CAB) ----------------------------------------------------
double __fastcall sub_405CAB(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_405C43(a1, -1, a2, a3);
  return *(double *)a2.i64;
}

//----- (0000000000405CB0) ----------------------------------------------------
__int64 __fastcall sub_405CB0(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // rax
  int v5; // ecx
  __int64 v6; // rdx
  unsigned __int64 v7; // r12
  __int64 v9; // rdx
  __int64 v10; // rcx

  v4 = sub_404863((__int64)a1, a2);
  v6 = *(unsigned int *)v4;
  if ( (_DWORD)v6 == 9 )
    return sub_4106A4(a1, v4[1], a3, a4);
  if ( (unsigned int)v6 <= 9 )
  {
    if ( (_DWORD)v6 == 6 )
    {
      sub_40377C(a1, a2, 0x57u, a3, a4);
      *(double *)a3.i64 = sub_405CAB(a1, a3, a4);
      *(double *)a4.i64 = 9.223372036854776e18;
      v7 = (unsigned int)(int)*(double *)a3.i64;
      if ( *(double *)a3.i64 >= 9.223372036854776e18 )
      {
        *(double *)a3.i64 = *(double *)a3.i64 - 9.223372036854776e18;
        v7 = (unsigned int)(int)*(double *)a3.i64 ^ 0x8000000000000000LL;
      }
      sub_40460F((__int64)a1, a2, v9, v10, a3, a4);
      return v7;
    }
    if ( (_DWORD)v6 == 8 && !_bittest((const signed __int32 *)v4[1], 9u) )
      return sub_40314F(v4[1], a2, v6, v5);
    return 0LL;
  }
  if ( (_DWORD)v6 != 10 )
    return 0LL;
  return *(_QWORD *)(v4[1] + 24);
}
// 405D01: variable 'v5' is possibly undefined
// 405D3C: variable 'v9' is possibly undefined
// 405D3C: variable 'v10' is possibly undefined

//----- (0000000000405D63) ----------------------------------------------------
__int64 __fastcall sub_405D63(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_405C43(a1, -2, a2, a3);
}

//----- (0000000000405D6D) ----------------------------------------------------
__int64 __fastcall sub_405D6D(__int64 *a1, __int64 *a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 *v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rsi
  _DWORD *v8; // rdx

  v5 = (__int64 *)a1[14];
  a1[14] = (__int64)(v5 + 2);
  v6 = *a2;
  v7 = a2[1];
  *v5 = v6;
  v5[1] = v7;
  if ( (v6 & 8) != 0 )
    ++*(_DWORD *)(v7 + 4);
  sub_405CAB(a1, a4, a5);
  v8 = (_DWORD *)(a1[14] - 16);
  a1[14] = (__int64)v8;
  *v8 = 2;
  return a3;
}

//----- (0000000000405DB7) ----------------------------------------------------
__int64 __fastcall sub_405DB7(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  sub_404A4F(a1, a2, a3, a4);
  return sub_404878(a1, a2, a3, a4);
}

//----- (0000000000405DDC) ----------------------------------------------------
__int64 __fastcall sub_405DDC(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  sub_404A4F(a1, a2, a3, a4);
  return sub_4048FE(a1, a2, a3, a4);
}

//----- (0000000000405E01) ----------------------------------------------------
__int64 __fastcall sub_405E01(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  int v5; // er13
  unsigned int *v6; // rax
  __int64 v7; // rcx
  _DWORD *v8; // rsi
  __int64 v9; // rdx

  v4 = sub_404A12(a1, a2);
  v5 = sub_417A4E(a1, v4, a3, a4);
  v6 = (unsigned int *)sub_404A12(a1, a2);
  v9 = *v6;
  v8 = (_DWORD *)*((_QWORD *)v6 + 1);
  *v6 = 0;
  LOBYTE(v9) = v9 & 8;
  *((double *)v6 + 1) = (double)v5;
  if ( (_BYTE)v9 )
  {
    if ( v8[1]-- == 1 )
    {
      *(double *)a3.i64 = (double)v5;
      sub_40CFCD((__int64)a1, v8, v9, v7, a3, a4);
    }
  }
  return (unsigned int)v5;
}
// 405E53: variable 'v7' is possibly undefined

//----- (0000000000405E64) ----------------------------------------------------
__int64 __fastcall sub_405E64(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  int v5; // er13
  unsigned int *v6; // rax
  _DWORD *v7; // rsi
  __int64 v8; // rcx

  v4 = sub_404A12(a1, a2);
  v5 = sub_417AB3(a1, v4, a3, a4);
  v6 = (unsigned int *)sub_404A12(a1, a2);
  v8 = *v6;
  v7 = (_DWORD *)*((_QWORD *)v6 + 1);
  *v6 = 0;
  LOBYTE(v8) = v8 & 8;
  *((double *)v6 + 1) = (double)v5;
  if ( (_BYTE)v8 )
  {
    if ( v7[1]-- == 1 )
    {
      *(double *)a3.i64 = (double)v5;
      sub_40CFCD((__int64)a1, v7, (unsigned int)v5, v8, a3, a4);
    }
  }
  return (unsigned int)v5;
}

//----- (0000000000405F30) ----------------------------------------------------
char __fastcall sub_405F30(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // eax
  _BOOL4 v5; // er8

  sub_405C43(a1, a2, a3, a4);
  LOBYTE(v4) = 0;
  if ( *(double *)a3.i64 > 0.0 )
  {
    LOBYTE(v4) = -1;
    if ( *(double *)a3.i64 < 255.0 )
    {
      sub_42F94A(*(double *)a3.i64);
      v5 = sub_41D67C(*(double *)a3.i64 - *(double *)a3.i64, 0.5);
      v4 = ((int)*(double *)a3.i64 + 1) & 0xFFFFFFFE;
      if ( !v5 )
        return (int)(*(double *)a3.i64 + 0.5);
    }
  }
  return v4;
}

//----- (0000000000405FB5) ----------------------------------------------------
__int64 __fastcall sub_405FB5(__int64 *a1, int a2, int a3, int a4, int *a5, __m128 a6, __m128 a7)
{
  int v7; // er15
  __int64 v10; // rax
  unsigned int *v11; // rax
  __int64 v12; // rdx
  _DWORD *v13; // rsi
  __int64 v14; // rcx

  v7 = 1;
  v10 = sub_404A12(a1, a2);
  sub_417A42(a1, v10, a6, a7);
  *(double *)a7.i64 = (double)a3;
  if ( (double)a3 <= *(double *)a6.i64 )
  {
    *(double *)a7.i64 = (double)a4;
    a3 = a4;
    if ( *(double *)a6.i64 <= (double)a4 )
    {
      a3 = (int)*(double *)a6.i64;
      a7 = a6;
      v7 = 0;
    }
  }
  v11 = (unsigned int *)sub_40483D((__int64)a1, a2);
  v14 = *v11;
  v13 = (_DWORD *)*((_QWORD *)v11 + 1);
  *((_QWORD *)v11 + 1) = a7.i64[0];
  *v11 = 0;
  LOBYTE(v14) = v14 & 8;
  if ( (_BYTE)v14 )
  {
    if ( v13[1]-- == 1 )
      sub_40CFCD((__int64)a1, v13, v12, v14, a6, a7);
  }
  if ( a5 )
  {
    *a5 = v7;
  }
  else if ( v7 )
  {
    a3 = 0;
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 3293, "number outside range", a6, a7);
  }
  return (unsigned int)a3;
}
// 406037: variable 'v12' is possibly undefined

//----- (0000000000406077) ----------------------------------------------------
__int64 __fastcall sub_406077(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  int v7; // [rsp+Ch] [rbp-4h] BYREF

  return sub_405FB5(a1, a2, a3, a4, &v7, a5, a6);
}

//----- (000000000040608A) ----------------------------------------------------
__int64 __fastcall sub_40608A(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  return sub_405FB5(a1, a2, a3, a4, 0LL, a5, a6);
}

//----- (0000000000406092) ----------------------------------------------------
__int64 __fastcall sub_406092(unsigned int *a1)
{
  return (unsigned int)dword_43C3C0[*a1];
}
// 43C3C0: using guessed type int dword_43C3C0[];

//----- (000000000040609C) ----------------------------------------------------
__int64 __fastcall sub_40609C(__int64 a1, int a2)
{
  return (unsigned int)dword_43C3C0[*(unsigned int *)sub_404863(a1, a2)];
}
// 43C3C0: using guessed type int dword_43C3C0[];

//----- (00000000004060B0) ----------------------------------------------------
__int64 __fastcall sub_4060B0(__int64 a1, int a2)
{
  __int64 *v2; // rax
  int v3; // edx
  __int64 result; // rax

  v2 = sub_404863(a1, a2);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == 9 )
    return *(_DWORD *)v2[1] >> 27;
  result = 22LL;
  if ( v3 != 10 )
    return 3 * (unsigned int)(v3 == 6);
  return result;
}

//----- (00000000004060E2) ----------------------------------------------------
_BOOL8 __fastcall sub_4060E2(__int64 a1, int a2)
{
  int v2; // eax
  int v3; // er8

  v2 = sub_40609C(a1, a2);
  return v2 == v3;
}
// 4060F1: variable 'v3' is possibly undefined

//----- (00000000004060F9) ----------------------------------------------------
__int64 __fastcall sub_4060F9(unsigned int *a1)
{
  return (unsigned int)dword_43C380[*a1];
}
// 43C380: using guessed type int dword_43C380[];

//----- (0000000000406103) ----------------------------------------------------
__int64 __fastcall sub_406103(__int64 a1, int a2)
{
  return (unsigned int)dword_43C380[*(unsigned int *)sub_404863(a1, a2)];
}
// 43C380: using guessed type int dword_43C380[];

//----- (0000000000406117) ----------------------------------------------------
__int64 __fastcall sub_406117(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er8
  int v5; // er9
  __int64 result; // rax

  v5 = sub_406103((__int64)a1, a2);
  result = 1LL;
  if ( (v4 & v5) == 0 )
  {
    result = v4 & 0x400;
    if ( (v4 & 0x400) != 0 )
    {
      sub_401C42(a1, (__int64)"third_party/duktape/duk_api_stack.c", 0x6000F5Fu, "unexpected type", a3, a4);
      return 0LL;
    }
  }
  return result;
}
// 40612B: variable 'v4' is possibly undefined

//----- (000000000040649F) ----------------------------------------------------
_BOOL8 __fastcall sub_40649F(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 2;
}

//----- (00000000004064B3) ----------------------------------------------------
_BOOL8 __fastcall sub_4064B3(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 3;
}

//----- (00000000004064DB) ----------------------------------------------------
_BOOL8 __fastcall sub_4064DB(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 0;
}

//----- (00000000004064EF) ----------------------------------------------------
__int64 __fastcall sub_4064EF(__int64 a1, int a2)
{
  sub_404863(a1, a2);
  return 0LL;
}

//----- (0000000000406515) ----------------------------------------------------
_BOOL8 __fastcall sub_406515(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 8;
}

//----- (0000000000406529) ----------------------------------------------------
_BOOL8 __fastcall sub_406529(__int64 a1, int a2)
{
  return sub_405717(a1, a2) != 0LL;
}

//----- (000000000040653D) ----------------------------------------------------
_BOOL8 __fastcall sub_40653D(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 9;
}

//----- (0000000000406551) ----------------------------------------------------
_BOOL8 __fastcall sub_406551(__int64 a1, int a2)
{
  return *(_DWORD *)sub_404863(a1, a2) == 10;
}

//----- (0000000000406565) ----------------------------------------------------
__int64 __fastcall sub_406565(__int64 a1, int a2)
{
  __int64 *v2; // rax
  int v3; // ecx
  __int64 *v4; // rdx
  __int64 result; // rax

  v2 = sub_404863(a1, a2);
  v3 = *(_DWORD *)v2;
  v4 = v2;
  result = 1LL;
  if ( v3 != 10 )
  {
    result = 0LL;
    if ( v3 == 9 )
      return (*(_DWORD *)v4[1] >> 13) & 1;
  }
  return result;
}

//----- (00000000004065BA) ----------------------------------------------------
__int64 __fastcall sub_4065BA(__int64 a1, int a2)
{
  _DWORD *v2; // rdx
  __int64 result; // rax

  v2 = (_DWORD *)sub_40568B(a1, a2);
  result = 0LL;
  if ( v2 )
    return (*v2 >> 9) & 1;
  return result;
}

//----- (00000000004065D7) ----------------------------------------------------
_BOOL8 __fastcall sub_4065D7(__int64 a1, int a2)
{
  __int64 v2; // rax

  v2 = sub_40483D(a1, a2);
  return v2 && sub_417FDB(v2);
}

//----- (00000000004065F2) ----------------------------------------------------
_BOOL8 __fastcall sub_4065F2(__int64 a1, int a2)
{
  __int64 *v2; // rax

  v2 = sub_404863(a1, a2);
  if ( *(_DWORD *)v2 == 9 )
    return (*(_DWORD *)v2[1] >> 9) & 1;
  else
    return *(_DWORD *)v2 == 6;
}

//----- (000000000040661B) ----------------------------------------------------
__int64 __fastcall sub_40661B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // er9

  result = sub_4065F2((__int64)a1, a2);
  if ( !(_DWORD)result )
    return sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2300, v5, "function", a3, a4);
  return result;
}
// 40663F: variable 'v5' is possibly undefined

//----- (0000000000406646) ----------------------------------------------------
__int64 __fastcall sub_406646(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  int v5; // er13
  __int64 v6; // rdx
  __int64 v7; // rcx

  v5 = a2;
  if ( (unsigned int)sub_40377C(a1, a2, a3, a4, a5)
    && (a2 = 0xFFFFFFFFLL, sub_4065F2((__int64)a1, -1))
    && (sub_404F0A(a1, v5, a4, a5),
        sub_41DA64(a1, 0, a4, a5),
        a2 = 0xFFFFFFFFLL,
        (unsigned int)sub_406117(a1, -1, a4, a5)) )
  {
    sub_405057(a1, v5, v6, v7, *(double *)a4.i64, a5);
    return 1LL;
  }
  else
  {
    sub_40460F((__int64)a1, a2, v6, v7, a4, a5);
    return 0LL;
  }
}
// 406698: variable 'v6' is possibly undefined
// 406698: variable 'v7' is possibly undefined

//----- (00000000004066B4) ----------------------------------------------------
_BOOL8 __fastcall sub_4066B4(__int64 a1, __int64 a2)
{
  if ( *(_DWORD *)a2 == 9 )
    return (**(_DWORD **)(a2 + 8) >> 9) & 1;
  else
    return *(_DWORD *)a2 == 6;
}

//----- (00000000004066D3) ----------------------------------------------------
_BOOL8 __fastcall sub_4066D3(__int64 a1, int a2)
{
  __int64 *v2; // rax

  v2 = sub_404863(a1, a2);
  if ( *(_DWORD *)v2 == 9 )
    return (*(_DWORD *)v2[1] >> 8) & 1;
  else
    return *(_DWORD *)v2 == 6;
}

//----- (0000000000406883) ----------------------------------------------------
__int64 __fastcall sub_406883(__int64 *a1, __int128 *a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  __int128 v5; // xmm0

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4264, a3, a4);
  result = a1[14];
  v5 = *a2;
  a1[14] = result + 16;
  *(_OWORD *)result = v5;
  if ( (*(_BYTE *)a2 & 8) != 0 )
  {
    result = *((_QWORD *)a2 + 1);
    ++*(_DWORD *)(result + 4);
  }
  return result;
}

//----- (00000000004068D1) ----------------------------------------------------
__int64 __fastcall sub_4068D1(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4273, a4, a5);
  a1[14] += 16LL;
  return a3;
}

//----- (00000000004068FC) ----------------------------------------------------
void __fastcall sub_4068FC(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  sub_4068D1(a1, a2, a3, a4, a5);
  sub_40500F(a1, a2);
}

//----- (000000000040691D) ----------------------------------------------------
__int64 __fastcall sub_40691D(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  _DWORD *v5; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4286, a4, a5);
  v5 = (_DWORD *)a1[14];
  a1[14] = (__int64)(v5 + 4);
  *v5 = 3;
  return a3;
}

//----- (0000000000406955) ----------------------------------------------------
_DWORD *__fastcall sub_406955(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  _DWORD *result; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4296, a3, a4);
  result = (_DWORD *)a1[14];
  a1[14] = (__int64)(result + 4);
  *result = 4;
  result[2] = a2 != 0;
  return result;
}

//----- (000000000040699D) ----------------------------------------------------
__int64 __fastcall sub_40699D(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  _DWORD *v5; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4306, a2, a3);
  v5 = (_DWORD *)a1[14];
  a1[14] = (__int64)(v5 + 4);
  *v5 = 4;
  v5[2] = 1;
  return a5;
}

//----- (00000000004069DC) ----------------------------------------------------
__int64 __fastcall sub_4069DC(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  _DWORD *v5; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4315, a2, a3);
  v5 = (_DWORD *)a1[14];
  a1[14] = (__int64)(v5 + 4);
  *v5 = 4;
  v5[2] = 0;
  return a5;
}

//----- (0000000000406A1B) ----------------------------------------------------
__int64 __fastcall sub_406A1B(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 result; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4326, a2, a3);
  result = a1[14];
  a1[14] = result + 16;
  *(_QWORD *)(result + 8) = a2.i64[0];
  *(_DWORD *)result = 0;
  return result;
}

//----- (0000000000406A68) ----------------------------------------------------
__int64 __fastcall sub_406A68(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4355, a3, a4);
  result = a1[14];
  a1[14] = result + 16;
  *(_DWORD *)result = 0;
  *(double *)(result + 8) = (double)a2;
  return result;
}

//----- (0000000000406AAF) ----------------------------------------------------
__int64 __fastcall sub_406AAF(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4385, a3, a4);
  result = a1[14];
  a1[14] = result + 16;
  *(_DWORD *)result = 0;
  *(double *)(result + 8) = (double)a2;
  return result;
}

//----- (0000000000406AF7) ----------------------------------------------------
__int64 __fastcall sub_406AF7(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  int v5; // edx

  v4 = sub_4047ED((__int64)a1, a2);
  sub_406AAF(a1, v5, a3, a4);
  return sub_4039C7(a1, v4, 0x57u, a3, a4);
}
// 406B0C: variable 'v5' is possibly undefined

//----- (0000000000406B26) ----------------------------------------------------
__int64 __fastcall sub_406B26(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4397, a4, a5);
  v5 = a1[14];
  a1[14] = v5 + 16;
  *(_DWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0x7FF8000000000000LL;
  return a3;
}

//----- (0000000000406B69) ----------------------------------------------------
__int64 __fastcall sub_406B69(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v7; // rax
  __int64 v8; // rdx

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4411, a4, a5);
  if ( a2 )
  {
    if ( a3 > 0x7FFFFFFF )
    {
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4424, "string too long", a4, a5);
      return 0LL;
    }
  }
  else
  {
    LODWORD(a3) = 0;
  }
  v7 = sub_40D33F(a1, a2, a3, a4, a5);
  v8 = a1[14];
  a1[14] = v8 + 16;
  *(_QWORD *)(v8 + 8) = v7;
  *(_DWORD *)v8 = 8;
  ++*(_DWORD *)(v7 + 4);
  return v7 + 32;
}

//----- (0000000000406BF4) ----------------------------------------------------
__int64 __fastcall sub_406BF4(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v9; // [rsp+8h] [rbp-28h]
  __int64 v10[3]; // [rsp+18h] [rbp-18h] BYREF

  v4 = sub_40480A(a1, a2);
  v5 = sub_405672(a1, v4, v10, a3, a4);
  v9 = sub_406B69(a1, v5, v10[0], a3, a4);
  sub_405057(a1, v4, v6, v7, *(double *)a3.i64, a4);
  return v9;
}
// 406C32: variable 'v6' is possibly undefined
// 406C32: variable 'v7' is possibly undefined
// 406BF4: using guessed type unsigned __int64 var_18[3];

//----- (0000000000406C45) ----------------------------------------------------
__int64 __fastcall sub_406C45(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  char *v5; // r15
  __int64 v6; // r13
  __int64 v8; // rbx
  unsigned __int64 v9; // rbx
  unsigned int v10; // edi
  char v11; // al
  char *v12; // rax
  __int64 v14; // [rsp+8h] [rbp-2F8h]
  unsigned int v15; // [rsp+1Ch] [rbp-2E4h] BYREF
  __int64 v16; // [rsp+20h] [rbp-2E0h] BYREF
  char v17; // [rsp+2Bh] [rbp-2D5h] BYREF
  char v18; // [rsp+2Ch] [rbp-2D4h] BYREF

  v5 = &v18;
  v6 = 0LL;
  v8 = *(unsigned int *)(a2 + 24);
  v16 = a2 + 32;
  v17 = 39;
  v14 = a3;
  v9 = a2 + 32 + v8;
  while ( v16 < v9 )
  {
    if ( v14 == v6 )
    {
      *(_WORD *)v5 = 11822;
      v5[2] = 46;
      v5 += 3;
      break;
    }
    if ( (unsigned int)sub_41C7A1((__int64)a1, (unsigned __int64 *)&v16, a2 + 32, v9, (int *)&v15) )
    {
      v10 = v15;
      if ( v15 == 39 || v15 == 127 || v15 <= 0x1F || v15 == 92 )
      {
        *(_WORD *)v5 = 30812;
        v11 = byte_43F2E0[v10 >> 4];
        v5[3] = byte_43F2E0[v10 & 0xF];
        v5[2] = v11;
        v12 = v5 + 4;
      }
      else
      {
        v12 = &v5[(int)sub_41C531(v15, v5)];
      }
    }
    else
    {
      ++v16;
      v12 = v5 + 1;
      *v5 = 63;
    }
    ++v6;
    v5 = v12;
  }
  *v5 = 39;
  return sub_406B69(a1, (__int64)&v17, v5 + 1 - &v17, a4, a5);
}
// 406C45: using guessed type unsigned __int64 var_2E0;

//----- (0000000000406D71) ----------------------------------------------------
__int64 __fastcall sub_406D71(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned __int64 v5; // rax

  if ( a2 )
  {
    v5 = sub_43AD53(a2);
    return sub_406B69(a1, a2, v5, a4, a5);
  }
  else
  {
    sub_40691D(a1, 0LL, a3, a4, a5);
    return 0LL;
  }
}
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (0000000000406DB4) ----------------------------------------------------
__int64 __fastcall sub_406DB4(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v7; // rbx
  unsigned int v8; // er13
  __int64 result; // rax
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rcx
  int v13; // ebx
  unsigned int v14; // edx
  unsigned int v15; // er14

  v7 = a3;
  v8 = sub_40480A(a1, a2);
  result = sub_406117(a1, v8, a5, a6);
  if ( (_DWORD)result )
  {
    if ( a4 && (unsigned int)sub_404413(a1, v8, 0x4Cu, a5, a6) )
    {
      sub_404F0A(a1, v8, a5, a6);
      sub_406D71(a1, (__int64)off_43C350[v7], v10, a5, a6);
      sub_41DA64(a1, 1, a5, a6);
      if ( (unsigned int)sub_406117(a1, -1, a5, a6) )
        return sub_401C42(
                 a1,
                 (__int64)"third_party/duktape/duk_api_stack.c",
                 0x6000AD4u,
                 "coercion to primitive failed",
                 a5,
                 a6);
      return sub_405057(a1, v8, v11, v12, *(double *)a5.i64, a6);
    }
    else
    {
      v13 = v7 - 1;
      v14 = 40;
      v15 = 40;
      if ( !v13 )
        v14 = 82;
      if ( v13 )
        v15 = 82;
      result = sub_406646(a1, v8, v14, a5, a6);
      if ( !(_DWORD)result )
      {
        result = sub_406646(a1, v8, v15, a5, a6);
        if ( !(_DWORD)result )
          return sub_401C42(
                   a1,
                   (__int64)"third_party/duktape/duk_api_stack.c",
                   0x6000AD4u,
                   "coercion to primitive failed",
                   a5,
                   a6);
      }
    }
  }
  return result;
}
// 406E1A: variable 'v10' is possibly undefined
// 406E6D: variable 'v11' is possibly undefined
// 406E6D: variable 'v12' is possibly undefined
// 43C350: using guessed type char *off_43C350[2];

//----- (0000000000406EB2) ----------------------------------------------------
__int64 __fastcall sub_406EB2(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  return sub_406DB4(a1, a2, a3, 1, a4, a5);
}

//----- (0000000000406EBC) ----------------------------------------------------
__int64 __fastcall sub_406EBC(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  return sub_406DB4(a1, a2, a3, 0, a4, a5);
}

//----- (0000000000406EC3) ----------------------------------------------------
int *__fastcall sub_406EC3(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  int *v6; // rax
  __int64 v7; // rdx

  if ( a3 <= 0x7FFFFFFF )
  {
    v6 = sub_40D37C(a1, a2, a3, a4, a5);
    v7 = a1[14];
    a1[14] = v7 + 16;
    *(_QWORD *)(v7 + 8) = v6;
    *(_DWORD *)v7 = 8;
    ++v6[1];
    return v6 + 8;
  }
  else
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4461, "string too long", a4, a5);
    return 0LL;
  }
}

//----- (0000000000406F18) ----------------------------------------------------
__int64 __fastcall sub_406F18(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4489, a3, a4);
  result = a1[14];
  a1[14] = result + 16;
  *(_DWORD *)result = 5;
  *(_QWORD *)(result + 8) = a2;
  return result;
}

//----- (0000000000406F59) ----------------------------------------------------
__int64 __fastcall sub_406F59(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er14
  __int64 v5; // rax
  __int64 v6; // r13
  __int64 v7; // rdx
  __int64 v8; // rcx

  v4 = sub_40480A(a1, a2);
  v5 = a1[13] + 16LL * v4;
  if ( *(_DWORD *)v5 == 5 || (v6 = 0LL, (unsigned int)(*(_DWORD *)v5 - 8) <= 2) )
    v6 = *(_QWORD *)(v5 + 8);
  sub_406F18(a1, v6, a3, a4);
  sub_405057(a1, v4, v7, v8, *(double *)a3.i64, a4);
  return v6;
}
// 406FA1: variable 'v7' is possibly undefined
// 406FA1: variable 'v8' is possibly undefined

//----- (0000000000406FB2) ----------------------------------------------------
_OWORD *__fastcall sub_406FB2(_QWORD *a1, __m128 a2, __m128 a3)
{
  return sub_40469E(a1, 0, a2, a3);
}

//----- (0000000000406FB9) ----------------------------------------------------
_OWORD *__fastcall sub_406FB9(_QWORD *a1, __m128 a2, __m128 a3)
{
  return sub_40469E(a1, 1, a2, a3);
}

//----- (0000000000406FC3) ----------------------------------------------------
__int64 __fastcall sub_406FC3(__int64 a1)
{
  return *(_QWORD *)(a1 + 104) - 16LL;
}

//----- (0000000000406FCC) ----------------------------------------------------
__int64 __fastcall sub_406FCC(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  __int64 i; // rsi
  int v6; // eax

  for ( i = a1[15]; i; i = *(_QWORD *)(i + 24) )
  {
    v6 = *(_DWORD *)(i + 88);
    if ( (v6 & 4) != 0 )
      return sub_406883(a1, (__int128 *)i, a2, a3);
    if ( (v6 & 0x10) == 0 )
      break;
  }
  return sub_4068D1(a1, i, a5, a2, a3);
}

//----- (0000000000407003) ----------------------------------------------------
int *__fastcall sub_407003(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // r12
  int *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rdx

  v5 = a3;
  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4794, a4, a5);
  result = sub_40D551(a1, a2, a4, a5);
  v7 = a1[14];
  *(_DWORD *)v7 = 9;
  *(_QWORD *)(v7 + 8) = result;
  ++result[1];
  a1[14] = v7 + 16;
  if ( (int)v5 >= 0 )
  {
    v8 = a1[v5 + 20];
    *((_QWORD *)result + 4) = v8;
    if ( v8 )
      ++*(_DWORD *)(v8 + 4);
  }
  return result;
}

//----- (0000000000407074) ----------------------------------------------------
int *__fastcall sub_407074(__int64 *a1, int a2, __int64 a3, __m128 a4, __m128 a5)
{
  int *result; // rax

  result = sub_407003(a1, a2, -1, a4, a5);
  *((_QWORD *)result + 4) = a3;
  if ( a3 )
    ++*(_DWORD *)(a3 + 4);
  return result;
}

//----- (0000000000407095) ----------------------------------------------------
__int64 __fastcall sub_407095(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_407003(a1, 134234240, 3, a2, a3);
  return sub_404C89((__int64)a1);
}

//----- (00000000004070BA) ----------------------------------------------------
__int64 __fastcall sub_4070BA(_QWORD *a1, __m128 a2, __m128 a3)
{
  int *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rax

  v3 = sub_40D662(a1, 272679040, a2, a3);
  v4 = a1[28];
  *((_QWORD *)v3 + 4) = v4;
  if ( v4 )
    ++*(_DWORD *)(v4 + 4);
  v5 = a1[14];
  *(_QWORD *)(v5 + 8) = v3;
  *(_DWORD *)v5 = 9;
  ++v3[1];
  v6 = v5 - a1[13];
  a1[14] = v5 + 16;
  return v6 >> 4;
}

//----- (0000000000407108) ----------------------------------------------------
__int64 __fastcall sub_407108(__int64 *a1, __m128 a2, __m128 a3)
{
  int *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rax

  v3 = sub_40D662(a1, 272679040, a2, a3);
  v4 = a1[14];
  *(_QWORD *)(v4 + 8) = v3;
  *(_DWORD *)v4 = 9;
  ++v3[1];
  v5 = v4 - a1[13];
  a1[14] = v4 + 16;
  return v5 >> 4;
}

//----- (0000000000407143) ----------------------------------------------------
__int64 __fastcall sub_407143(_QWORD *a1, __m128 a2, __m128 a3)
{
  sub_4070BA(a1, a2, a3);
  return *(_QWORD *)(a1[14] - 8LL);
}

//----- (000000000040715D) ----------------------------------------------------
__int64 __fastcall sub_40715D(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-18h]

  v5 = sub_407143(a1, a3, a4);
  sub_40DF53(a1, v5, 0, a2, 0, 0, a3, a4);
  result = v5;
  *(_DWORD *)(v5 + 56) = a2;
  return result;
}

//----- (0000000000407199) ----------------------------------------------------
__int64 __fastcall sub_407199(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax

  v4 = sub_40715D(a1, a2, a3, a4);
  return *(_QWORD *)(v4 + 24) + 25LL * *(unsigned int *)(v4 + 40) + (-*(_DWORD *)(v4 + 40) & 7);
}

//----- (00000000004071BC) ----------------------------------------------------
__int64 __fastcall sub_4071BC(_QWORD *a1, char a2, __m128 a3, __m128 a4)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // r13
  __int64 v12; // r13
  __int64 v13; // rax

  if ( a1[14] >= a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4946, a3, a4);
  v6 = sub_40D625(a1, -1879048064, a3, a4);
  *(_BYTE *)(v6 + 73) = 1;
  v7 = (__int64 *)v6;
  v8 = a1[8];
  v9 = v6;
  *(_QWORD *)(v6 + 568) = a1[71];
  v10 = a1[14];
  *(_DWORD *)v10 = 9;
  *(_QWORD *)(v10 + 8) = v9;
  ++*(_DWORD *)(v9 + 4);
  v11 = v10 - a1[13];
  a1[14] = v10 + 16;
  v12 = v11 >> 4;
  if ( (unsigned int)sub_411864(v8, (_QWORD *)v9, a3, a4) )
  {
    if ( (a2 & 1) != 0 )
      sub_411944(v7, a3, a4);
    else
      sub_411F9C((__int64)a1, (__int64)v7);
    v13 = v7[55];
    v7[4] = v13;
    if ( v13 )
      ++*(_DWORD *)(v13 + 4);
  }
  else
  {
    LODWORD(v12) = 0;
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4973, a3, a4);
  }
  return (unsigned int)v12;
}

//----- (0000000000407292) ----------------------------------------------------
int *__fastcall sub_407292(_QWORD *a1, __m128 a2, __m128 a3)
{
  int *v3; // r13
  __int64 v4; // rax
  __int64 v5; // rax

  if ( a1[14] >= a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5002, a2, a3);
  v3 = sub_40D558(a1, 402655872, a2, a3);
  if ( v3 )
  {
    v4 = a1[14];
    *(_DWORD *)v4 = 9;
    *(_QWORD *)(v4 + 8) = v3;
    ++v3[1];
    a1[14] = v4 + 16;
    v5 = a1[25];
    *((_QWORD *)v3 + 4) = v5;
    if ( v5 )
      ++*(_DWORD *)(v5 + 4);
  }
  else
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5015, a2, a3);
  }
  return v3;
}

//----- (0000000000407318) ----------------------------------------------------
__int64 __fastcall sub_407318(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // r13
  __int64 v4; // rax

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5039, a2, a3);
  v3 = sub_40D56C(a1[8], 402655104, a2, a3);
  if ( v3 )
  {
    v4 = a1[14];
    a1[14] = v4 + 16;
    *(_DWORD *)v4 = 9;
    *(_QWORD *)(v4 + 8) = v3;
    ++*(_DWORD *)(v3 + 4);
  }
  else
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5047, a2, a3);
  }
  return v3;
}

//----- (000000000040738C) ----------------------------------------------------
__int64 __fastcall sub_40738C(_QWORD *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  return sub_40472D(a1, a2, a3, 403133312, 6u, a4, a5);
}

//----- (000000000040739C) ----------------------------------------------------
__int64 __fastcall sub_40739C(_QWORD *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  return sub_40472D(a1, a2, a3, 403133312, 5u, a4, a5);
}

//----- (00000000004073AC) ----------------------------------------------------
__int64 __fastcall sub_4073AC(_QWORD *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  return sub_40472D(a1, a2, a3, 403133056, 5u, a4, a5);
}

//----- (000000000040746B) ----------------------------------------------------
int *__fastcall sub_40746B(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // r12
  int *result; // rax
  __int64 v7; // rdx
  _DWORD *v8; // rdx

  v5 = a3;
  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5208, a4, a5);
  result = sub_40D5C7(a1, a2, a4, a5);
  v7 = a1[v5 + 20];
  *((_QWORD *)result + 4) = v7;
  if ( v7 )
    ++*(_DWORD *)(v7 + 4);
  v8 = (_DWORD *)a1[14];
  *v8 = 9;
  v8 += 4;
  *((_QWORD *)v8 - 1) = result;
  ++result[1];
  a1[14] = (__int64)v8;
  return result;
}

//----- (00000000004074D7) ----------------------------------------------------
int *__fastcall sub_4074D7(__int64 *a1, int a2, __int64 a3, __int64 a4, unsigned int a5, __m128 a6, __m128 a7)
{
  int v7; // er13
  unsigned int v8; // er12
  int v9; // ebx
  __int64 v10; // rax
  int v11; // er10
  __int64 v12; // r14
  __int64 v13; // r8
  bool v14; // cf
  int *result; // rax
  __int64 v16; // [rsp+0h] [rbp-40h]

  if ( a3 != (unsigned int)a3 )
    return (int *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5348, "invalid args", a6, a7);
  v7 = a4;
  if ( a4 != (unsigned int)a4 )
    return (int *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5348, "invalid args", a6, a7);
  if ( a5 > 0xB )
    return (int *)sub_401C42(a1, (__int64)"third_party/duktape/duk_api_stack.c", 0x60014E8u, "invalid args", a6, a7);
  v8 = dword_43C320[a5];
  v9 = a3;
  v10 = sub_405823((__int64)a1, a2);
  v12 = v10;
  if ( v10 && v11 && *(_DWORD *)v10 >> 27 == 19 )
  {
    v13 = *(_QWORD *)(v10 + 56);
    if ( v13 )
    {
      v14 = __CFADD__(*(_DWORD *)(v10 + 72), v9);
      v9 += *(_DWORD *)(v10 + 72);
      if ( v14 )
        return (int *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5348, "invalid args", a6, a7);
      goto LABEL_11;
    }
    return (int *)sub_401C42(a1, (__int64)"third_party/duktape/duk_api_stack.c", 0x60014E8u, "invalid args", a6, a7);
  }
  v12 = 0LL;
  v13 = sub_405873(a1, a2, a6, a7);
LABEL_11:
  v16 = v13;
  if ( __CFADD__(v7, v9) )
    return (int *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5348, "invalid args", a6, a7);
  result = sub_40746B(a1, (HIBYTE(v8) << 27) | 0x2080, BYTE2(v8), a6, a7);
  *((_QWORD *)result + 7) = v16;
  ++*(_DWORD *)(v16 + 4);
  *((_QWORD *)result + 8) = v12;
  if ( v12 )
    ++*(_DWORD *)(v12 + 4);
  result[18] = v9;
  result[19] = v7;
  *((_BYTE *)result + 80) = (unsigned __int8)v8 >> 4;
  *((_BYTE *)result + 81) = BYTE1(v8);
  *((_BYTE *)result + 82) = v8 & 0xF;
  return result;
}
// 40754E: variable 'v11' is possibly undefined
// 43C320: using guessed type int dword_43C320[];

//----- (000000000040762B) ----------------------------------------------------
__int64 __fastcall sub_40762B(__int64 *a1, unsigned __int64 a2, char a3, __m128 a4, __m128 a5)
{
  __int64 v6; // r13
  __int64 v7; // rax
  __int64 v9[5]; // [rsp+8h] [rbp-28h] BYREF

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5458, a4, a5);
  if ( a2 <= 0x7FFFFFFE )
  {
    v6 = sub_40BB67(a1[8], a2, a3, v9, a4, a5);
    if ( v6 )
    {
      v7 = a1[14];
      *(_QWORD *)(v7 + 8) = v6;
      *(_DWORD *)v7 = 10;
      ++*(_DWORD *)(v6 + 4);
      v6 = v9[0];
      a1[14] = v7 + 16;
    }
    else
    {
      sub_401CC7(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5468, a4, a5);
    }
  }
  else
  {
    v6 = 0LL;
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5462, "buffer too long", a4, a5);
  }
  return v6;
}
// 40762B: using guessed type __int64 var_28[5];

//----- (00000000004076DF) ----------------------------------------------------
__int64 __fastcall sub_4076DF(__int64 *a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  return sub_40762B(a1, a2, 4, a3, a4);
}

//----- (00000000004076E9) ----------------------------------------------------
__int64 __fastcall sub_4076E9(__int64 *a1, unsigned __int64 a2, __m128 a3, __m128 a4)
{
  return sub_40762B(a1, a2, 0, a3, a4);
}

//----- (00000000004076F0) ----------------------------------------------------
__int64 __fastcall sub_4076F0(__int64 *a1, unsigned int *a2, __m128 a3, __m128 a4)
{
  __int64 v5; // r13
  __int64 v6; // r14
  __int64 v7; // r14
  unsigned int v8; // edx
  __int64 v9; // rdi

  if ( a1[14] >= (unsigned __int64)a1[11] )
    sub_401D02(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5719, a3, a4);
  v5 = a1[14];
  v6 = v5 - a1[13];
  a1[14] = v5 + 16;
  v7 = v6 >> 4;
  if ( a2 )
  {
    v8 = *a2;
    if ( (*a2 & 0x10) != 0 )
    {
      --a2[1];
      v9 = a1[8];
      *a2 = v8 & 0xFFFFFFCF;
      sub_40CA34(v9, (__int64)a2);
      sub_40C9D7(a1[8], (__int64)a2);
    }
    if ( (*a2 & 3) != 0 )
    {
      if ( (*a2 & 3) == 1 )
        *(_DWORD *)v5 = 9;
      else
        *(_DWORD *)v5 = 10;
    }
    else
    {
      *(_DWORD *)v5 = 8;
    }
    *(_QWORD *)(v5 + 8) = a2;
    ++a2[1];
  }
  return (unsigned int)v7;
}

//----- (000000000040779C) ----------------------------------------------------
__int64 __fastcall sub_40779C(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_407003(a1, 134234240, -1, a2, a3);
  return sub_404C89((__int64)a1);
}

//----- (0000000000407808) ----------------------------------------------------
__int64 __fastcall sub_407808(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int128 v5; // [rsp+0h] [rbp-10h] BYREF

  *((_QWORD *)&v5 + 1) = a2;
  LODWORD(v5) = 8;
  return sub_406883(a1, &v5, a3, a4);
}

//----- (0000000000407826) ----------------------------------------------------
__int64 __fastcall sub_407826(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  return sub_407808(a1, *(_QWORD *)(a1[71] + 8LL * a2), a3, a4);
}

//----- (0000000000407835) ----------------------------------------------------
__int64 __fastcall sub_407835(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  __int64 v5; // rdx
  __int64 v6; // rcx

  v4 = sub_40480A(a1, a2);
  sub_404F0A(a1, v4, a3, a4);
  sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_408916, 0LL, 1, 1, a3, a4);
  if ( !sub_406515((__int64)a1, -1) )
  {
    sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_408916, 0LL, 1, 1, a3, a4);
    if ( !sub_406515((__int64)a1, -1) )
    {
      sub_40460F((__int64)a1, 0xFFFFFFFFLL, v5, v6, a3, a4);
      sub_407826(a1, 0xCu, a3, a4);
    }
  }
  sub_405057(a1, v4, v5, v6, *(double *)a3.i64, a4);
  return sub_405695((__int64)a1, v4);
}
// 4078A7: variable 'v5' is possibly undefined
// 4078A7: variable 'v6' is possibly undefined

//----- (0000000000407963) ----------------------------------------------------
__int64 __fastcall sub_407963(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_407808(a1, *(_QWORD *)(a1[71] + 120), a2, a3);
}

//----- (0000000000407973) ----------------------------------------------------
__int64 __fastcall sub_407973(__int64 *a1, _BYTE *a2, _DWORD *a3, __m128 a4, __m128 a5)
{
  __int64 result; // rax
  unsigned __int64 v8; // rbx
  __int64 v9; // r8
  int v10; // er15
  char *v11; // r14
  _DWORD *v12; // rsi
  __int64 v13; // rcx
  char *v14; // rdi
  int v15; // eax
  __int64 v17; // [rsp+8h] [rbp-158h]
  char v18[24]; // [rsp+18h] [rbp-148h] BYREF
  char v19; // [rsp+30h] [rbp-130h] BYREF

  if ( a2 )
  {
    v8 = sub_43AD53(a2) + 16;
    if ( v8 < 0x100 )
      v8 = 256LL;
    v10 = 0;
    while ( 1 )
    {
      v11 = &v19;
      if ( v8 > 0x100 )
      {
        if ( v10 )
        {
          v11 = (char *)sub_41D79F(a1, -1, v8, a4, a5);
        }
        else
        {
          v10 = 1;
          v11 = (char *)sub_40762B(a1, v8, 1, a4, a5);
        }
      }
      v12 = a3;
      v13 = 6LL;
      v14 = v18;
      while ( v13 )
      {
        *(_DWORD *)v14 = *v12++;
        v14 += 4;
        --v13;
      }
      v15 = sub_439652((__int64)v11, v8, a2, (__int64)v18, v9);
      if ( v15 < (int)v8 && v15 >= 0 )
        break;
      v8 *= 2LL;
      if ( v8 > 0x3FFFFFFF )
      {
        sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 4757, "result too long", a4, a5);
        return 0LL;
      }
    }
    result = sub_406B69(a1, (__int64)v11, v15, a4, a5);
    if ( v10 )
    {
      v17 = result;
      sub_405181(a1, a4, a5);
      return v17;
    }
  }
  else
  {
    sub_407963(a1, a4, a5);
    return *(_QWORD *)(a1[14] - 8) + 32LL;
  }
  return result;
}
// 407A34: variable 'v9' is possibly undefined
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (0000000000407AA3) ----------------------------------------------------
__int64 sub_407AA3(__int64 *a1, _BYTE *a2, ...)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm1
  va_list va; // [rsp+8h] [rbp-C8h] BYREF
  __int128 v6; // [rsp+50h] [rbp-80h]
  __int128 v7; // [rsp+60h] [rbp-70h]

  va_start(va, a2);
  *(double *)&v6 = va_arg(va, double);
  v2.i64[0] = v6;
  *(double *)&v7 = va_arg(va, double);
  v3.i64[0] = v7;
  va_end(va);
  va_start(va, a2);
  return sub_407973(a1, a2, va, v2, v3);
}
// 407B22: variable 'v2' is possibly undefined
// 407B22: variable 'v3' is possibly undefined

//----- (0000000000407B29) ----------------------------------------------------
__int64 __fastcall sub_407B29(__int64 *a1, int a2, __int64 a3, int a4, _BYTE *a5, _DWORD *a6, __m128 a7, __m128 a8)
{
  __int64 v10; // rax

  v10 = sub_40BA08(a1, a2 & 0xFEFFFFFF);
  sub_407074(a1, 939540608, v10, a7, a8);
  if ( a5 )
    sub_407973(a1, a5, a6, a7, a8);
  else
    sub_406A68(a1, a2 & 0xFEFFFFFF, a7, a8);
  sub_403E13(a1, -33541115, a7, a8);
  sub_40B6EA(a1, (__int64)a1, a3, a4, HIBYTE(a2) & 1, a7, a8);
  return sub_404C89((__int64)a1);
}

//----- (0000000000407BD4) ----------------------------------------------------
__int64 sub_407BD4(__int64 *a1, int a2, __int64 a3, int a4, _BYTE *a5, ...)
{
  __m128 v5; // xmm0
  __m128 v6; // xmm1
  va_list va; // [rsp+8h] [rbp-C8h] BYREF
  __int128 v9; // [rsp+50h] [rbp-80h]
  __int128 v10; // [rsp+60h] [rbp-70h]

  va_start(va, a5);
  *(double *)&v9 = va_arg(va, double);
  v5.i64[0] = v9;
  *(double *)&v10 = va_arg(va, double);
  v6.i64[0] = v10;
  va_end(va);
  va_start(va, a5);
  return sub_407B29(a1, a2, a3, a4, a5, va, v5, v6);
}
// 407C3E: variable 'v5' is possibly undefined
// 407C3E: variable 'v6' is possibly undefined

//----- (0000000000407C45) ----------------------------------------------------
__int64 __fastcall sub_407C45(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int128 v5; // [rsp+0h] [rbp-10h] BYREF

  *((_QWORD *)&v5 + 1) = a2;
  LODWORD(v5) = 9;
  return sub_406883(a1, &v5, a3, a4);
}

//----- (0000000000407C63) ----------------------------------------------------
__int64 __fastcall sub_407C63(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rsi

  v5 = *(_QWORD *)(a1[8] + 184);
  if ( v5 )
    return sub_407C45(a1, v5, a2, a3);
  else
    return sub_4068D1(a1, 0LL, a5, a2, a3);
}

//----- (0000000000407CCF) ----------------------------------------------------
__int64 __fastcall sub_407CCF(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int128 v5; // [rsp+0h] [rbp-10h] BYREF

  *((_QWORD *)&v5 + 1) = a2;
  LODWORD(v5) = 10;
  return sub_406883(a1, &v5, a3, a4);
}

//----- (0000000000407CED) ----------------------------------------------------
__int64 __fastcall sub_407CED(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_407C45(a1, a1[a2 + 20], a3, a4);
}

//----- (0000000000407CFD) ----------------------------------------------------
__int64 __fastcall sub_407CFD(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_407CED(a1, 0, a2, a3);
}

//----- (0000000000407D1C) ----------------------------------------------------
__int64 __fastcall sub_407D1C(__int64 *a1, _DWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  if ( (unsigned int)a2 <= (unsigned int)((a1[14] - a1[13]) >> 4) )
    return sub_40459D((__int64)a1, a2, a3, a4, a5, a6);
  else
    return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5897, "invalid count", a5, a6);
}

//----- (0000000000407D4A) ----------------------------------------------------
_DWORD *__fastcall sub_407D4A(__int64 a1, int a2)
{
  _DWORD *result; // rax
  int v3; // edx
  _DWORD *v4; // rcx

  result = *(_DWORD **)(a1 + 112);
  v3 = a2;
  v4 = result;
  while ( v3 > 0 )
  {
    v4 -= 4;
    --v3;
    *v4 = 2;
  }
  if ( a2 < 0 )
    a2 = 0;
  *(_QWORD *)(a1 + 112) = &result[-4 * a2];
  return result;
}

//----- (0000000000407D7E) ----------------------------------------------------
__int64 __fastcall sub_407D7E(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  if ( a1[14] == a1[13] )
    return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5985, "invalid count", a5, a6);
  else
    return sub_40460F((__int64)a1, a2, a3, a4, a5, a6);
}

//----- (0000000000407DA6) ----------------------------------------------------
__int64 __fastcall sub_407DA6(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = result - 16;
  *(_DWORD *)(result - 16) = 2;
  return result;
}

//----- (0000000000407DBA) ----------------------------------------------------
void __fastcall sub_407DBA(__int64 a1)
{
  *(_QWORD *)(a1 + 112) -= 16LL;
}

//----- (0000000000407DC0) ----------------------------------------------------
__int64 __fastcall sub_407DC0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  if ( a1[13] <= (unsigned __int64)(a1[14] - 32) )
    return sub_404639((__int64)a1, a2, a3, a4, a5, a6);
  else
    return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 6074, "invalid count", a5, a6);
}

//----- (0000000000407DF2) ----------------------------------------------------
__int64 __fastcall sub_407DF2(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return sub_407D1C(a1, (_DWORD *)3, a5, a6, a2, a3);
}

//----- (0000000000407DFC) ----------------------------------------------------
__int64 __fastcall sub_407DFC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  return sub_40459D(a1, (_DWORD *)3, a3, a4, a5, a6);
}

//----- (0000000000407E10) ----------------------------------------------------
_DWORD *__fastcall sub_407E10(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  _DWORD *result; // rax
  __int64 v6; // rdi
  unsigned __int64 v7; // rdx
  __int64 v8; // rsi
  _DWORD *v9; // rdx
  _DWORD *v10; // rsi

  if ( a2 > (unsigned int)((__int64)(a1[14] - a1[13]) >> 4) )
    return (_DWORD *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 6133, "invalid count", a3, a4);
  v6 = sub_407199(a1, a2, a3, a4);
  v7 = 16LL * (int)a2;
  v8 = a1[14] + -16LL - v7;
  if ( v7 )
    sub_43AAA0(v6, v8, v7);
  v9 = (_DWORD *)a1[14];
  v10 = (_DWORD *)(v8 + 16);
  *((_OWORD *)v10 - 1) = *((_OWORD *)v9 - 1);
  for ( result = v10; result != v9; result += 4 )
    *result = 2;
  a1[14] = v10;
  return result;
}

//----- (0000000000407E9B) ----------------------------------------------------
__int64 __fastcall sub_407E9B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  int v6; // er15
  unsigned int v7; // er13
  __int64 v8; // rcx
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 i; // rax
  __int64 v12; // r9
  char v13; // r8
  int v14; // er14
  __int64 v15; // rdx
  __int64 v16; // rcx
  int v17; // ebx
  int v18; // er15
  int v19; // edx

  v4 = sub_404A12(a1, a2);
  if ( *(_DWORD *)v4 == 9 )
  {
    v5 = *(_QWORD *)(v4 + 8);
    if ( _bittest((const signed __int32 *)v5, 0x16u) )
    {
      v6 = *(_DWORD *)(v5 + 56);
      if ( (unsigned int)v6 <= *(_DWORD *)(v5 + 48) )
      {
        if ( v6 < 0 )
          goto LABEL_20;
        sub_404E3A(a1, v6, a3, a4);
        v7 = *(_DWORD *)(v5 + 56);
        if ( v6 == v7 && v7 <= *(_DWORD *)(v5 + 48) )
        {
          v8 = a1[14];
          v9 = 16LL * v7;
          v10 = *(_QWORD *)(v5 + 24) + 25LL * *(unsigned int *)(v5 + 40) + (-*(_DWORD *)(v5 + 40) & 7);
          for ( i = 0LL; v9 != i; i += 16LL )
          {
            if ( *(_DWORD *)(v10 + i) != 7 )
            {
              v12 = *(_QWORD *)(v10 + i + 8);
              v13 = *(_QWORD *)(v10 + i);
              *(_QWORD *)(v8 + i) = *(_QWORD *)(v10 + i);
              *(_QWORD *)(v8 + i + 8) = v12;
              if ( (v13 & 8) != 0 )
                ++*(_DWORD *)(v12 + 4);
            }
          }
          a1[14] = v9 + v8;
          return v7;
        }
      }
    }
    v14 = sub_4047ED((__int64)a1, a2);
    sub_40377C(a1, v14, 0x57u, a3, a4);
    v17 = sub_405E64(a1, -1, a3, a4);
    v7 = v17;
    if ( v17 >= 0 )
    {
      v18 = 0;
      sub_40460F((__int64)a1, 0xFFFFFFFFLL, v15, v16, a3, a4);
      sub_404E3A(a1, v17, a3, a4);
      while ( v18 != v17 )
      {
        v19 = v18++;
        sub_40370E(a1, v14, v19, a3, a4);
      }
      return v7;
    }
LABEL_20:
    v7 = 0;
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_stack.c", 6274, "invalid length", a3, a4);
    return v7;
  }
  v7 = 0;
  if ( (unsigned int)(*(_DWORD *)v4 - 2) > 1 )
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_stack.c", 6270, a3, a4);
  return v7;
}
// 407F92: variable 'v15' is possibly undefined
// 407F92: variable 'v16' is possibly undefined

//----- (0000000000408001) ----------------------------------------------------
__int64 __fastcall sub_408001(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rdx

  if ( a1[14] != a1[13] )
  {
    sub_41203C((__int64)a1);
    sub_40B994(a1, a2, v5, a3, a4);
    sub_40BA4F((__int64)a1, 1, a1[14] - 16);
    sub_40B99E(a1, a3, a4);
    sub_408053((__int64)a1);
  }
  return sub_401D12(a1, (__int64)"third_party/duktape/duk_api_stack.c", 6291, a3, a4);
}
// 408030: variable 'v5' is possibly undefined

//----- (0000000000408053) ----------------------------------------------------
void __fastcall __noreturn sub_408053(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)(a1 + 64) + 40LL))(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 32LL));
  while ( 1 )
    ;
}

//----- (000000000040807C) ----------------------------------------------------
__int64 sub_40807C(__int64 *a1, __int64 a2, __int64 a3, int a4, _BYTE *a5, ...)
{
  __m128 v5; // xmm0
  __m128 v6; // xmm1
  va_list va; // [rsp+18h] [rbp-C8h] BYREF
  __int128 v9; // [rsp+60h] [rbp-80h]
  __int128 v10; // [rsp+70h] [rbp-70h]

  va_start(va, a5);
  *(double *)&v9 = va_arg(va, double);
  v5.i64[0] = v9;
  *(double *)&v10 = va_arg(va, double);
  v6.i64[0] = v10;
  va_end(va);
  va_start(va, a5);
  sub_407B29(a1, a2, a3, a4, a5, va, v5, v6);
  return sub_408001(a1, a2, v5, v6);
}
// 4080ED: variable 'v5' is possibly undefined
// 4080ED: variable 'v6' is possibly undefined

//----- (0000000000408133) ----------------------------------------------------
__int64 __fastcall sub_408133(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er9
  _DWORD *v5; // rax
  _DWORD *v6; // r8

  sub_40483D(a1, a2);
  v5 = (_DWORD *)sub_40483D(a1, v4);
  if ( v6 && v5 )
    return sub_417B16(0LL, v6, v5, 2, a3, a4);
  else
    return 0LL;
}
// 408145: variable 'v4' is possibly undefined
// 40814D: variable 'v6' is possibly undefined

//----- (000000000040816B) ----------------------------------------------------
__int64 __fastcall sub_40816B(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er9
  _DWORD *v5; // rax
  _DWORD *v6; // r8

  sub_40483D(a1, a2);
  v5 = (_DWORD *)sub_40483D(a1, v4);
  if ( v6 && v5 )
    return sub_417B16(0LL, v6, v5, 1, a3, a4);
  else
    return 0LL;
}
// 40817D: variable 'v4' is possibly undefined
// 408185: variable 'v6' is possibly undefined

//----- (00000000004081DD) ----------------------------------------------------
__int64 __fastcall sub_4081DD(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned __int8 v8; // al
  char v9; // r8
  char v11[2]; // [rsp+0h] [rbp-42h]
  char v12[64]; // [rsp+2h] [rbp-40h] BYREF

  v5 = a3 + a2;
  v6 = 0LL;
  while ( 1 )
  {
    v7 = v6 + 1;
    if ( (unsigned int)v6 >= a3 )
      break;
    v8 = *(_BYTE *)(v5 + ~v6);
    v9 = byte_43F2E0[v8 >> 4];
    v11[2 * v7 + 1] = byte_43F2E0[v8 & 0xF];
    v6 = v7;
    v11[2 * v7] = v9;
  }
  return sub_406B69(a1, (__int64)v12, 2 * a3, a4, a5);
}
// 4081DD: using guessed type char var_40[64];

//----- (0000000000408233) ----------------------------------------------------
__int64 __fastcall sub_408233(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 v7[3]; // [rsp+8h] [rbp-18h] BYREF

  v7[0] = a2;
  sub_406EC3(a1, (__int64)"light_", 6uLL, a4, a5);
  sub_4081DD(a1, (__int64)v7, 8uLL, a4, a5);
  sub_407AA3(a1, "_%04x", a3);
  return sub_408E52(a1, 3, a4, a5);
}
// 408233: using guessed type __int64 var_18[3];

//----- (0000000000408290) ----------------------------------------------------
__int64 __fastcall sub_408290(
        __int64 *a1,
        int a2,
        __m128 a3,
        __m128 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  int v8; // er13
  __int64 v9; // rax
  int v10; // edx
  int v11; // esi
  int v13; // eax
  __int64 v14; // rcx
  unsigned int v15; // ebx
  __int64 v16; // r14
  int v17; // er15
  int v18; // esi

  v8 = sub_40480A(a1, a2);
  v9 = a1[13] + 16LL * v8;
  switch ( *(_DWORD *)v9 )
  {
    case 2:
    case 3:
      return sub_401C42(a1, (__int64)"third_party/duktape/duk_api_stack.c", 0x6000E2Bu, "not object coercible", a3, a4);
    case 4:
      v10 = 12;
      v11 = 671105152;
      goto LABEL_13;
    case 5:
      v10 = 36;
      v11 = -2013249408;
      goto LABEL_13;
    case 6:
      v15 = *(_DWORD *)(v9 + 4);
      v16 = *(_QWORD *)(v9 + 8);
      v17 = v15 & 0xF;
      if ( v17 == 15 )
        v17 = -1;
      sub_40472D(a1, *(_QWORD *)(v9 + 8), v17, 403133312, 6u, a3, a4);
      v18 = (unsigned __int8)v15 >> 4;
      if ( v17 != v18 )
      {
        sub_406A68(a1, v18, a3, a4);
        sub_403E13(a1, -33532160, a3, a4);
      }
      sub_408233(a1, v16, v15, a3, a4);
      sub_403E13(a1, -33530620, a3, a4);
      *(_WORD *)(*(_QWORD *)(a1[14] - 8) + 66LL) = (__int16)v15 >> 8;
      return sub_405057(a1, v8, a8, v14, *(double *)a3.i64, a4);
    case 8:
      v13 = **(_DWORD **)(v9 + 8) & 0x200;
      v10 = v13 == 0 ? 10 : 38;
      v11 = v13 == 0 ? 1619017856 : 1879064704;
      goto LABEL_13;
    case 9:
      return a8;
    case 0xA:
      sub_4096A4(a1, *(_QWORD *)(v9 + 8), a3, a4);
      return sub_405057(a1, v8, a8, v14, *(double *)a3.i64, a4);
    default:
      v10 = 14;
      v11 = 1342193792;
LABEL_13:
      sub_407003(a1, v11, v10, a3, a4);
      sub_404F0A(a1, v8, a3, a4);
      sub_403E13(a1, -33527296, a3, a4);
      return sub_405057(a1, v8, a8, v14, *(double *)a3.i64, a4);
  }
}
// 408400: variable 'v14' is possibly undefined

//----- (0000000000408411) ----------------------------------------------------
__int64 __fastcall sub_408411(
        __int64 *a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __m128 a7,
        __m128 a8)
{
  sub_408290(a1, a2, a7, a8, a3, a4, a5, a6);
  return sub_404583((__int64)a1, a2);
}

//----- (0000000000408432) ----------------------------------------------------
__int64 __fastcall sub_408432(__int64 *a1, int a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6, __int64 a7)
{
  int v7; // er10
  __int64 v8; // r12
  int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  int v13; // er10
  int v14; // er11

  v8 = sub_405823((__int64)a1, a2);
  if ( !v8 )
  {
    v9 = sub_406103((__int64)a1, v7);
    if ( (v14 & v9) != 0 )
    {
      if ( (v14 & 0x800) != 0 )
        return sub_408411(a1, v13, v10, a7, v11, v12, a3, a4);
    }
    else if ( (v14 & 0x400) != 0 )
    {
      sub_401C60(a1, (__int64)"third_party/duktape/duk_api_stack.c", 2434, v13, "object", a3, a4);
    }
  }
  return v8;
}
// 408450: variable 'v7' is possibly undefined
// 408455: variable 'v14' is possibly undefined
// 408468: variable 'v13' is possibly undefined
// 408468: variable 'v10' is possibly undefined
// 408468: variable 'v11' is possibly undefined
// 408468: variable 'v12' is possibly undefined

//----- (0000000000408491) ----------------------------------------------------
__int64 __fastcall sub_408491(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __m128 a6, __m128 a7)
{
  BYTE1(a3) |= 8u;
  return sub_408432(a1, a2, a6, a7, a3, a4, a5);
}

//----- (0000000000408496) ----------------------------------------------------
__int64 __fastcall sub_408496(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __m128 a6, __m128 a7)
{
  BYTE1(a3) |= 0xCu;
  return sub_408432(a1, a2, a6, a7, a3, a4, a5);
}

//----- (000000000040849B) ----------------------------------------------------
__int64 __fastcall sub_40849B(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  const signed __int32 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  const signed __int32 *v10; // rbx
  const signed __int32 *v11; // r13
  int v12; // esi
  int *v13; // rax
  __int64 v14; // rdx

  v7 = (const signed __int32 *)sub_408432(a1, -2, a2, a3, 3712LL, a6, a7);
  if ( _bittest(v7, 0x19u)
    || (v10 = v7, v11 = (const signed __int32 *)sub_408432(a1, -1, a2, a3, 3712LL, v8, v9), _bittest(v11, 0x19u)) )
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_stack.c", 5592, a2, a3);
    return 0LL;
  }
  else
  {
    v12 = *v10 & 0x300 | 0xA000080;
    if ( (*v10 & 0x200) != 0 )
      v12 = *v10 & 0x300 | 0x1E000080;
    v13 = sub_40D680(a1, v12, a2, a3);
    v14 = a1[14];
    *((_QWORD *)v13 + 7) = v10;
    *((_QWORD *)v13 + 8) = v11;
    *(_QWORD *)(v14 - 24) = v13;
    *(_DWORD *)(v14 - 32) = 9;
    ++v13[1];
    *(_DWORD *)(v14 - 16) = 2;
    a1[14] = v14 - 16;
    return (unsigned int)((v14 - 16 - a1[13]) >> 4) - 1;
  }
}
// 4084CB: variable 'v8' is possibly undefined
// 4084CB: variable 'v9' is possibly undefined

//----- (0000000000408553) ----------------------------------------------------
__int64 __fastcall sub_408553(__int64 *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __m128 a6, __m128 a7)
{
  BYTE1(a3) |= 4u;
  return sub_408432(a1, a2, a6, a7, a3, a4, a5);
}

//----- (00000000004085AE) ----------------------------------------------------
__int64 __fastcall sub_4085AE(__int64 *a1, __int128 *a2, int a3, double a4, __m128 a5)
{
  __int128 v6; // xmm0
  unsigned int v7; // esi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  _DWORD *v12; // rbx
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rcx
  int v17; // er13
  __int128 v19[3]; // [rsp+0h] [rbp-30h] BYREF

  v6 = *a2;
  v19[0] = v6;
  sub_406EC3(a1, (__int64)"[object ", 8uLL, (__m128)v6, a5);
  if ( (_DWORD)v6 == 3 )
  {
    v7 = 1;
    goto LABEL_14;
  }
  if ( (_DWORD)v6 == 7 || (_DWORD)v6 == 2 )
  {
    v7 = 0;
LABEL_14:
    sub_407826(a1, v7, (__m128)v6, a5);
    goto LABEL_15;
  }
  sub_406883(a1, v19, (__m128)v6, a5);
  v12 = (_DWORD *)sub_408411(a1, -1, v8, v9, v10, v11, (__m128)v6, a5);
  if ( sub_417FC2((__int64)v12) )
  {
    v17 = 6;
    goto LABEL_13;
  }
  if ( a3 )
  {
LABEL_11:
    v17 = (unsigned __int8)byte_448000[*v12 >> 27];
LABEL_13:
    sub_40460F((__int64)a1, 0xFFFFFFFFLL, v13, v14, (__m128)v6, a5);
    v7 = v17;
    goto LABEL_14;
  }
  sub_40377C(a1, -1, 0x4Eu, (__m128)v6, a5);
  if ( !sub_406529((__int64)a1, -1) )
  {
    sub_40460F((__int64)a1, 0xFFFFFFFFLL, v15, v16, (__m128)v6, a5);
    goto LABEL_11;
  }
  sub_405181(a1, (__m128)v6, a5);
LABEL_15:
  sub_406EC3(a1, (__int64)"]", 1uLL, (__m128)v6, a5);
  return sub_408E52(a1, 3, (__m128)v6, a5);
}
// 408606: variable 'v8' is possibly undefined
// 408606: variable 'v9' is possibly undefined
// 408606: variable 'v10' is possibly undefined
// 408606: variable 'v11' is possibly undefined
// 408645: variable 'v15' is possibly undefined
// 408645: variable 'v16' is possibly undefined
// 408662: variable 'v13' is possibly undefined
// 408662: variable 'v14' is possibly undefined
// 4085AE: using guessed type __int128 var_30[3];

//----- (000000000040869C) ----------------------------------------------------
__int64 __fastcall sub_40869C(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  sub_40469E(a1, 1, a2, a3);
  return sub_408411(a1, -1, v3, v4, v5, v6, a2, a3);
}
// 4086BA: variable 'v3' is possibly undefined
// 4086BA: variable 'v4' is possibly undefined
// 4086BA: variable 'v5' is possibly undefined
// 4086BA: variable 'v6' is possibly undefined

//----- (00000000004086BF) ----------------------------------------------------
__int64 __fastcall sub_4086BF(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  return sub_408233(a1, *(_QWORD *)(a2 + 8), *(_DWORD *)(a2 + 4), a3, a4);
}

//----- (00000000004086CB) ----------------------------------------------------
__int64 __fastcall sub_4086CB(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er14
  __int64 v5; // r13

  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_QWORD *)(a2 + 8);
  sub_406EC3(a1, (__int64)"function ", 9uLL, a3, a4);
  sub_408233(a1, v5, v4, a3, a4);
  sub_406EC3(a1, (__int64)"() { [lightfunc code] }", 0x17uLL, a3, a4);
  return sub_408E52(a1, 3, a3, a4);
}

//----- (0000000000408725) ----------------------------------------------------
__int64 __fastcall sub_408725(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  __int64 v5; // rsi
  unsigned int v6; // esi
  __int64 v7; // rdx
  __int64 v8; // rcx
  const void *v9; // rdx

  LODWORD(v4) = a2;
  while ( 2 )
  {
    v4 = (int)sub_40480A(a1, v4);
    v5 = a1[13] + 16 * v4;
    switch ( *(_DWORD *)v5 )
    {
      case 2:
        v6 = 58;
        goto LABEL_6;
      case 3:
        goto LABEL_13;
      case 4:
        if ( *(_DWORD *)(v5 + 8) )
          v6 = 156;
        else
          v6 = 157;
        goto LABEL_6;
      case 5:
        v9 = *(const void **)(v5 + 8);
        if ( v9 )
        {
          sub_407AA3(a1, "%p", v9);
        }
        else
        {
LABEL_13:
          v6 = 155;
LABEL_6:
          sub_407826(a1, v6, a3, a4);
        }
        goto LABEL_16;
      case 6:
        sub_4086CB(a1, v5, a3, a4);
        goto LABEL_16;
      case 8:
        if ( (**(_DWORD **)(v5 + 8) & 0x200) != 0 )
          sub_401C42(
            a1,
            (__int64)"third_party/duktape/duk_api_stack.c",
            0x6000D17u,
            "cannot string coerce Symbol",
            a3,
            a4);
        return sub_4057AC(a1, v4, a3, a4);
      case 9:
      case 0xA:
        sub_406EB2(a1, v4, 1, a3, a4);
        continue;
      default:
        sub_406883(a1, (__int128 *)v5, a3, a4);
        sub_41B6BE(a1, 0xAu, 0, 0, a3, a4);
LABEL_16:
        sub_405057(a1, v4, v7, v8, *(double *)a3.i64, a4);
        return sub_4057AC(a1, v4, a3, a4);
    }
  }
}
// 40880C: variable 'v7' is possibly undefined
// 40880C: variable 'v8' is possibly undefined

//----- (0000000000408821) ----------------------------------------------------
__int64 __fastcall sub_408821(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  sub_408725(a1, a2, a4, a5);
  return sub_40578B(a1, a2, a3, a4, a5);
}

//----- (000000000040884A) ----------------------------------------------------
__int64 __fastcall sub_40884A(__int64 *a1, int a2, _QWORD *a3, int a4, __m128 a5, __m128 a6)
{
  int v8; // er14
  unsigned int *v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // r12
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rbx
  __int64 v18[7]; // [rsp+8h] [rbp-38h] BYREF

  v8 = sub_40480A(a1, a2);
  v9 = (unsigned int *)sub_405869((__int64)a1, v8);
  if ( v9 )
  {
    v10 = *v9;
    v11 = (__int64)(v9 + 8);
    v12 = *v9;
    if ( (v10 & 0x80u) != 0LL )
      v11 = *((_QWORD *)v9 + 4);
    v18[0] = *((_QWORD *)v9 + 3);
    if ( ((v10 >> 7) & 1) == a4 )
    {
      if ( (v12 & 0x100) == 0 )
        goto LABEL_13;
    }
    else if ( a4 == 2 )
    {
      goto LABEL_13;
    }
  }
  else
  {
    v11 = sub_408821(a1, v8, v18, a5, a6);
  }
  v13 = sub_40762B(a1, v18[0], a4 == 1, a5, a6);
  v15 = v18[0];
  v16 = v13;
  if ( v18[0] )
    sub_43AAA0(v13, v11, v18[0]);
  v11 = v16;
  sub_405057(a1, v8, v15, v14, *(double *)a5.i64, a6);
LABEL_13:
  if ( a3 )
    *a3 = v18[0];
  return v11;
}
// 4088F3: variable 'v15' is possibly undefined
// 4088F3: variable 'v14' is possibly undefined
// 40884A: using guessed type unsigned __int64 var_38[7];

//----- (0000000000408916) ----------------------------------------------------
__int64 __fastcall sub_408916(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_408725(a1, -1, a2, a3);
  return 1LL;
}

//----- (0000000000408929) ----------------------------------------------------
__int64 __fastcall sub_408929(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  __int64 v5; // rdx
  __int64 v6; // rcx

  v4 = sub_40480A(a1, a2);
  if ( sub_40653D((__int64)a1, v4) )
  {
    sub_40365C(a1, v4, 4441894LL, a3, a4);
    if ( sub_406515((__int64)a1, -1) )
      sub_405057(a1, v4, v5, v6, *(double *)a3.i64, a4);
    else
      sub_407D7E(a1, 0xFFFFFFFFLL, v5, v6, a3, a4);
  }
  return sub_408725(a1, v4, a3, a4);
}
// 408969: variable 'v5' is possibly undefined
// 408969: variable 'v6' is possibly undefined

//----- (0000000000408985) ----------------------------------------------------
__int64 __fastcall sub_408985(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_408929(a1, -1, a2, a3);
  return 1LL;
}

//----- (0000000000408998) ----------------------------------------------------
__int64 __fastcall sub_408998(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  sub_408725(a1, a2, a3, a4);
  return sub_40568B((__int64)a1, a2);
}

//----- (00000000004089B9) ----------------------------------------------------
__int64 __fastcall sub_4089B9(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  sub_406EB2(a1, a2, 1, a3, a4);
  result = sub_40568B((__int64)a1, a2);
  if ( !result )
    return sub_408998(a1, a2, a3, a4);
  return result;
}

//----- (00000000004089F1) ----------------------------------------------------
__int64 __fastcall sub_4089F1(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_408998(a1, -1, a2, a3);
}

//----- (00000000004089F6) ----------------------------------------------------
__int64 __fastcall sub_4089F6(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  sub_406AAF(a1, a2, a3, a4);
  return sub_4089F1(a1, a3, a4);
}

//----- (0000000000408A0E) ----------------------------------------------------
__int64 __fastcall sub_408A0E(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40469E(a1, 1, a2, a3);
  return sub_4089F1(a1, a2, a3);
}

//----- (0000000000408A2B) ----------------------------------------------------
const signed __int32 *__fastcall sub_408A2B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  const signed __int32 *result; // rax

  result = (const signed __int32 *)sub_40568B((__int64)a1, a2);
  if ( !result || !_bittest(result, 9u) )
    return (const signed __int32 *)sub_408998(a1, a2, a3, a4);
  return result;
}

//----- (0000000000408A51) ----------------------------------------------------
__int64 __fastcall sub_408A51(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  unsigned int v5; // eax
  __int64 v6; // r13
  __int64 v7; // rdx
  __int64 v8; // rax
  unsigned int v9; // edx
  __int64 v10; // rsi
  __int64 v11; // r14
  __int64 v12; // rax
  const char *v13; // rax

  if ( !a2 )
  {
    sub_406EC3(a1, (__int64)"none", 4uLL, a4, a5);
    return sub_408725(a1, -1, a4, a5);
  }
  v5 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 == 9 )
  {
    if ( !a3
      || (v11 = *(_QWORD *)(a2 + 8), !(unsigned int)sub_40DCA3(a1, v11, a1[40], 1, a4, a5))
      || (v12 = sub_40E629(a1[8], v11, 0x34u)) == 0
      || *(_DWORD *)v12 != 8 )
    {
      sub_4085AE(a1, (__int128 *)a2, 1, *(double *)a4.i64, a5);
      return sub_408725(a1, -1, a4, a5);
    }
    v10 = *(_QWORD *)(v12 + 8);
    v9 = 96;
    goto LABEL_23;
  }
  if ( v5 > 9 )
  {
    if ( v5 == 10 )
    {
      sub_407AA3(a1, "[buffer:%ld]", *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24LL));
      return sub_408725(a1, -1, a4, a5);
    }
LABEL_26:
    sub_406883(a1, (__int128 *)a2, a4, a5);
    return sub_408725(a1, -1, a4, a5);
  }
  if ( v5 == 5 )
  {
    sub_406883(a1, (__int128 *)a2, a4, a5);
    v13 = (const char *)sub_408725(a1, -1, a4, a5);
    sub_407AA3(a1, "(%s)", v13);
    sub_405181(a1, a4, a5);
    return sub_408725(a1, -1, a4, a5);
  }
  if ( v5 != 8 )
    goto LABEL_26;
  v6 = *(_QWORD *)(a2 + 8);
  if ( !_bittest((const signed __int32 *)v6, 9u) )
  {
    v9 = 32;
    v10 = *(_QWORD *)(a2 + 8);
LABEL_23:
    sub_406C45(a1, v10, v9, a4, a5);
    return sub_408725(a1, -1, a4, a5);
  }
  sub_406EC3(a1, (__int64)"[Symbol ", 8uLL, a4, a5);
  LOBYTE(v7) = *(_BYTE *)(v6 + 32);
  if ( (_BYTE)v7 == 0xFF || (_BYTE)v7 == 0x82 )
  {
    v8 = 0LL;
  }
  else
  {
    v8 = 1LL;
    if ( (_BYTE)v7 != 0x80 )
      v8 = (unsigned int)(*(_BYTE *)(v6 + *(unsigned int *)(v6 + 24) + 31) == 0xFF) + 2;
  }
  sub_406D71(a1, (__int64)(&off_43C400)[v8], v7, a4, a5);
  sub_406EC3(a1, 4483430LL, 1uLL, a4, a5);
  sub_406C45(a1, v6, 0x20u, a4, a5);
  sub_406EC3(a1, 4440648LL, 1uLL, a4, a5);
  sub_408E52(a1, 5, a4, a5);
  return sub_408725(a1, -1, a4, a5);
}
// 408B16: variable 'v7' is possibly undefined
// 43C400: using guessed type char *off_43C400;

//----- (0000000000408C16) ----------------------------------------------------
__int64 __fastcall sub_408C16(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  return sub_408A51(a1, a2, 0, a3, a4);
}

//----- (0000000000408C1D) ----------------------------------------------------
__int64 __fastcall sub_408C1D(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax

  v4 = sub_40483D((__int64)a1, a2);
  return sub_408C16(a1, v4, a3, a4);
}

//----- (0000000000408C2C) ----------------------------------------------------
__int64 __fastcall sub_408C2C(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  return sub_408A51(a1, a2, 1, a3, a4);
}

//----- (0000000000408C36) ----------------------------------------------------
__int64 __fastcall sub_408C36(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rsi
  _BYTE *i; // rdx

  sub_406EC3(a1, (__int64)"Symbol(", 7uLL, a3, a4);
  v5 = a2 + 33;
  for ( i = (_BYTE *)v5; (unsigned __int64)i < a2 + (unsigned __int64)*(unsigned int *)(a2 + 24) + 32 && *i != 0xFF; ++i )
    ;
  sub_406B69(a1, v5, (unsigned __int64)&i[-v5], a3, a4);
  sub_406EC3(a1, 4447044LL, 1uLL, a3, a4);
  return sub_408E52(a1, 3, a3, a4);
}

//----- (0000000000408C9E) ----------------------------------------------------
void __fastcall sub_408C9E(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi

  v4 = a2;
  if ( 16 * a4 )
    sub_43AAA0(a2, a3, 16 * a4);
  while ( --a4 != -1 )
  {
    if ( (*(_BYTE *)v4 & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(v4 + 8) + 4LL);
    v4 += 16LL;
  }
}
// 408CC4: variable 'a4' is possibly undefined

//----- (0000000000408CCE) ----------------------------------------------------
__int64 __fastcall sub_408CCE(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  const char *v5; // rcx
  int v6; // edx
  unsigned __int64 v8; // r14
  __int64 v11; // rax
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // r14
  int v14; // er15
  unsigned __int64 v15; // rsi
  __int64 v16; // r14
  __int64 v17; // r15
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  unsigned __int64 v26; // rsi
  int v27; // [rsp+Ch] [rbp-34h]

  if ( a2 > 0 )
  {
    v8 = 0LL;
    if ( a3 )
    {
      v11 = sub_408998(a1, ~a2, a4, a5);
      v12 = (unsigned int)(a2 - 1);
      v13 = *(unsigned int *)(v11 + 24);
      if ( a2 != 1 && 0x7FFFFFFF / v12 < v13 )
      {
LABEL_21:
        v5 = "result too long";
        v6 = 106;
        return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_string.c", v6, v5, a4, a5);
      }
      v8 = v12 * v13;
    }
    v14 = a2;
    while ( 1 )
    {
      v8 += *(unsigned int *)(sub_408998(a1, -v14, a4, a5) + 24);
      if ( v8 >= 0x80000000 )
        break;
      if ( !--v14 )
      {
        v15 = v8;
        v16 = 0LL;
        v17 = sub_4076DF(a1, v15, a4, a5);
        v27 = a2;
        while ( 1 )
        {
          v18 = sub_40574F(a1, ~v27, a4, a5);
          sub_43AAA0(v17 + v16, v18 + 32, *(unsigned int *)(v18 + 24));
          v16 += *(unsigned int *)(v21 + 24);
          if ( !--v27 )
            break;
          if ( a2 != v27 && (a3 & 1) != 0 )
          {
            v22 = sub_40574F(a1, -2 - a2, a4, a5);
            sub_43AAA0(v17 + v16, v22 + 32, *(unsigned int *)(v22 + 24));
            v16 += *(unsigned int *)(v23 + 24);
          }
        }
        if ( a3 )
        {
          sub_405057(a1, -2 - a2, v19, v20, *(double *)a4.i64, a5);
          v26 = (unsigned int)a2;
        }
        else
        {
          sub_405057(a1, ~a2, v19, v20, *(double *)a4.i64, a5);
          v26 = (unsigned int)(a2 - 1);
        }
        sub_407D1C(a1, (_DWORD *)v26, v24, v25, a4, a5);
        return sub_406BF4(a1, -1, a4, a5);
      }
    }
    goto LABEL_21;
  }
  if ( !a2 )
    return sub_407963(a1, a4, a5);
  v5 = "invalid count";
  v6 = 19;
  return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_string.c", v6, v5, a4, a5);
}
// 408DA3: variable 'v21' is possibly undefined
// 408DDA: variable 'v23' is possibly undefined
// 408DF1: variable 'v19' is possibly undefined
// 408DF1: variable 'v20' is possibly undefined
// 408E0F: variable 'v24' is possibly undefined
// 408E0F: variable 'v25' is possibly undefined

//----- (0000000000408E52) ----------------------------------------------------
__int64 __fastcall sub_408E52(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_408CCE(a1, a2, 0, a3, a4);
}

//----- (0000000000408E59) ----------------------------------------------------
__int64 __fastcall sub_408E59(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // r13
  __int64 v5; // rax
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // r15
  __int64 v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx

  v4 = sub_408998(a1, -2, a2, a3);
  v5 = sub_408998(a1, -1, a2, a3);
  v6 = *(unsigned int *)(v4 + 24);
  v7 = *(unsigned int *)(v5 + 24);
  if ( v6 + v7 > 0x7FFFFFFF )
    return sub_401CE2(a1, (__int64)"third_party/duktape/duk_api_string.c", 156, "result too long", a2, a3);
  v9 = v5;
  v10 = sub_4076DF(a1, v6 + v7, a2, a3);
  sub_43AAA0(v10, v4 + 32, v6);
  sub_43AAA0(v6 + v10, v9 + 32, v7);
  sub_406BF4(a1, -1, a2, a3);
  sub_405057(a1, -3, v11, v12, *(double *)a2.i64, a3);
  return sub_407DA1((__int64)a1, 4294967293LL, v13, v14, a2, a3);
}
// 408EF7: variable 'v11' is possibly undefined
// 408EF7: variable 'v12' is possibly undefined
// 408F0A: variable 'v13' is possibly undefined
// 408F0A: variable 'v14' is possibly undefined

//----- (0000000000408F0F) ----------------------------------------------------
__int64 __fastcall sub_408F0F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_408CCE(a1, a2, 1, a3, a4);
}

//----- (0000000000408F19) ----------------------------------------------------
__int64 __fastcall sub_408F19(
        __int64 *a1,
        int a2,
        __int64 (__fastcall *a3)(__int64, _QWORD),
        __int64 a4,
        __m128 a5,
        __m128 a6)
{
  __int64 result; // rax
  __int64 v9; // r12
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // r12
  unsigned int v12; // eax
  __int64 v13[7]; // [rsp+8h] [rbp-38h] BYREF

  result = sub_40574F(a1, a2, a5, a6);
  v9 = *(unsigned int *)(result + 24);
  v10 = result + 32;
  v13[0] = result + 32;
  v11 = result + 32 + v9;
  while ( v13[0] < v11 )
  {
    v12 = sub_41C85D(a1, (unsigned __int64 *)v13, v10, v11, a5, a6);
    result = a3(a4, v12);
  }
  return result;
}
// 408F19: using guessed type unsigned __int64 var_38[7];

//----- (0000000000409057) ----------------------------------------------------
__int64 __fastcall sub_409057(__int64 *a1, int a2, unsigned __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rax
  unsigned int v9; // eax
  __int64 v10; // rsi
  int v11; // er15
  __int64 v12; // r13
  __int64 v13; // rdx
  int v14; // ecx
  unsigned __int64 v15; // rax
  int v16; // ecx
  __int64 v17; // rdx
  __int64 v18; // r14
  int v19; // ecx
  int v20; // eax
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v24; // [rsp-8h] [rbp-30h]

  v24 = v6;
  v9 = sub_40480A(a1, a2);
  v10 = v9;
  v11 = v9;
  v12 = sub_40574F(a1, v9, a5, a6);
  v15 = sub_40314F(v12, v10, v13, v14);
  v17 = a3;
  if ( v15 <= a4 )
    a4 = v15;
  if ( a4 <= a3 )
    v17 = a4;
  v18 = (unsigned int)sub_40D015(a1, v12, v17, v16, a5, a6);
  v20 = sub_40D015(a1, v12, (unsigned int)a4, v19, a5, a6);
  v21 = sub_40D33F(a1, v12 + v18 + 32, v20 - (int)v18, a5, a6);
  sub_407808(a1, v21, a5, a6);
  return sub_405057(a1, v11, v24, v22, *(double *)a5.i64, a6);
}
// 40906D: variable 'v6' is possibly undefined
// 409086: variable 'v13' is possibly undefined
// 409086: variable 'v14' is possibly undefined
// 4090A2: variable 'v16' is possibly undefined
// 4090B2: variable 'v19' is possibly undefined
// 4090E5: variable 'v22' is possibly undefined

//----- (00000000004090EA) ----------------------------------------------------
__int64 __fastcall sub_4090EA(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r12
  unsigned __int64 v7; // rbx
  int v8; // er15
  unsigned __int64 v9; // r15
  char v10; // al
  unsigned __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rcx
  int v14; // [rsp+8h] [rbp-48h]
  int v15; // [rsp+Ch] [rbp-44h]
  unsigned __int64 v16; // [rsp+10h] [rbp-40h] BYREF
  __int64 v17[7]; // [rsp+18h] [rbp-38h] BYREF

  v15 = sub_40480A(a1, a2);
  result = sub_40574F(a1, v15, a3, a4);
  v5 = result + 32;
  v6 = result + 32;
  v7 = result + 32 + *(unsigned int *)(result + 24);
  while ( v6 < v7 )
  {
    v16 = v6;
    v8 = sub_41C85D(a1, &v16, v5, v7, a3, a4);
    result = sub_41CA19(v8);
    if ( !(_DWORD)result )
    {
      result = sub_41CA82(v8);
      if ( !(_DWORD)result )
        goto LABEL_6;
    }
    v6 = v16;
  }
  v9 = v6;
  if ( v6 == v7 )
    goto LABEL_16;
LABEL_6:
  v9 = v7;
  while ( v9 > v5 )
  {
    v16 = v9;
    do
      v10 = *(_BYTE *)--v9;
    while ( (v10 & 0xC0) == 0x80 && v5 < v9 );
    v17[0] = v9;
    v14 = sub_41C85D(a1, (unsigned __int64 *)v17, v5, v7, a3, a4);
    result = sub_41CA19(v14);
    if ( !(_DWORD)result )
    {
      result = sub_41CA82(v14);
      if ( !(_DWORD)result )
      {
        v9 = v16;
        break;
      }
    }
  }
LABEL_16:
  v11 = v9;
  if ( v6 >= v9 )
    v11 = v6;
  if ( v6 != v5 || v11 != v7 )
  {
    sub_406B69(a1, v6, v11 - v6, a3, a4);
    return sub_405057(a1, v15, v12, v13, *(double *)a3.i64, a4);
  }
  return result;
}
// 4091DE: variable 'v12' is possibly undefined
// 4091DE: variable 'v13' is possibly undefined
// 4090EA: using guessed type unsigned __int64 var_38[7];

//----- (0000000000409239) ----------------------------------------------------
__int64 __fastcall sub_409239(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  int v4; // eax
  __int64 v5; // rbx
  __int64 v6; // r13
  int v7; // edx
  __int64 v8; // rbx
  int v9; // er13
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v16[5]; // [rsp+8h] [rbp-28h] BYREF

  v3 = sub_40609C((__int64)a1, 0);
  if ( v3 != 6 )
  {
    if ( v3 <= 6 )
    {
      if ( v3 == 4 )
      {
        v4 = sub_406077(a1, 0, 0, 0x7FFFFFFF, a2, a3);
        sub_4076E9(a1, v4, a2, a3);
        return sub_405B46((__int64)a1, -1);
      }
      if ( v3 == 5 )
      {
        sub_4057BB(a1, 0, a2, a3);
        sub_404FD6(a1, a2, a3);
        sub_40884A(a1, -1, v16, 2, a2, a3);
        return sub_405B46((__int64)a1, -1);
      }
      goto LABEL_16;
    }
    if ( v3 != 7 )
    {
LABEL_16:
      v7 = 573;
      goto LABEL_17;
    }
LABEL_19:
    v8 = 0LL;
    sub_4037B9(a1, 87, a2, a3);
    v9 = sub_406077(a1, -1, 0, 0x7FFFFFFF, a2, a3);
    sub_407D7E(a1, 0xFFFFFFFFLL, v10, v11, a2, a3);
    v12 = sub_4076DF(a1, v9, a2, a3);
    while ( v9 > (int)v8 )
    {
      sub_40370E(a1, 0, v8, a2, a3);
      *(_BYTE *)(v12 + v8++) = sub_405E64(a1, -1, a2, a3);
      sub_407D7E(a1, 0xFFFFFFFFLL, v13, v14, a2, a3);
    }
    return sub_405B46((__int64)a1, -1);
  }
  v5 = sub_405B41((__int64)a1, 0);
  if ( *(_DWORD *)v5 >> 27 != 19 )
    goto LABEL_19;
  v6 = *(_QWORD *)(v5 + 56);
  if ( v6 )
  {
    if ( *(_DWORD *)(v5 + 72) || *(_DWORD *)(v5 + 76) != *(_QWORD *)(v6 + 24) )
    {
      v7 = 557;
LABEL_17:
      v6 = 0LL;
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_buffer.c", v7, a2, a3);
      return v6;
    }
    sub_407CCF(a1, *(_QWORD *)(v5 + 56), a2, a3);
    return *(_QWORD *)(v5 + 56);
  }
  else
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_buffer.c", 548, a2, a3);
  }
  return v6;
}
// 40936A: variable 'v10' is possibly undefined
// 40936A: variable 'v11' is possibly undefined
// 4093A3: variable 'v13' is possibly undefined
// 4093A3: variable 'v14' is possibly undefined
// 409239: using guessed type __int64 var_28[5];

//----- (00000000004093B8) ----------------------------------------------------
const signed __int32 *__fastcall sub_4093B8(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  const signed __int32 *result; // rax

  v4 = (unsigned int *)sub_404A12(a1, a2);
  v8 = *v4;
  if ( (_DWORD)v8 == 9 )
  {
    result = (const signed __int32 *)*((_QWORD *)v4 + 1);
    if ( _bittest(result, 0xDu) )
      return result;
  }
  else if ( (_DWORD)v8 == 10 )
  {
    return (const signed __int32 *)sub_408411(a1, a2, v8, v5, v6, v7, a3, a4);
  }
  sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_buffer.c", 0x60000C8u, byte_43C4B1, a3, a4);
  return 0LL;
}
// 4093EC: variable 'v5' is possibly undefined
// 4093EC: variable 'v6' is possibly undefined
// 4093EC: variable 'v7' is possibly undefined

//----- (0000000000409409) ----------------------------------------------------
__int64 __fastcall sub_409409(__int64 *a1, char a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // r12
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int *v10; // rax
  __int64 v11; // rcx
  _DWORD *v12; // rsi
  __int64 v13; // rdx

  v4 = sub_406FC3((__int64)a1);
  if ( *(_DWORD *)v4 == 9 )
  {
    v5 = *(_QWORD *)(v4 + 8);
    if ( _bittest((const signed __int32 *)v5, 0xDu) )
      return v5;
    goto LABEL_11;
  }
  if ( *(_DWORD *)v4 != 10 )
  {
LABEL_11:
    v5 = 0LL;
    if ( (a2 & 1) != 0 )
      sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_buffer.c", 0x600009Bu, byte_43C4B1, a3, a4);
    return v5;
  }
  if ( (a2 & 2) == 0 )
    return *(_QWORD *)(v4 + 8);
  sub_406FB2(a1, a3, a4);
  v5 = sub_408411(a1, -1, v6, v7, v8, v9, a3, a4);
  v10 = (unsigned int *)sub_406FC3((__int64)a1);
  v13 = *v10;
  v12 = (_DWORD *)*((_QWORD *)v10 + 1);
  *v10 = 9;
  *((_QWORD *)v10 + 1) = v5;
  ++*(_DWORD *)(v5 + 4);
  LOBYTE(v13) = v13 & 8;
  if ( (_BYTE)v13 )
  {
    if ( v12[1]-- == 1 )
      sub_40CFCD((__int64)a1, v12, v13, v11, a3, a4);
  }
  sub_407D7E(a1, (__int64)v12, v13, v11, a3, a4);
  return v5;
}
// 40944A: variable 'v6' is possibly undefined
// 40944A: variable 'v7' is possibly undefined
// 40944A: variable 'v8' is possibly undefined
// 40944A: variable 'v9' is possibly undefined
// 40947C: variable 'v11' is possibly undefined
// 409484: variable 'v13' is possibly undefined

//----- (00000000004094BB) ----------------------------------------------------
__int64 __fastcall sub_4094BB(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_409409(a1, 3, a2, a3);
}

//----- (00000000004094C5) ----------------------------------------------------
__int64 __fastcall sub_4094C5(__int64 *a1, _DWORD *a2, int *a3, _DWORD *a4, int a5, __m128 a6, __m128 a7)
{
  int v9; // eax
  int v10; // er12
  __int64 result; // rax
  unsigned int v12; // ecx

  v9 = sub_405DB7(a1, 1, a6, a7);
  if ( v9 >= 0 )
  {
    v10 = v9;
    if ( (unsigned int)v9 <= *a2 )
    {
      if ( sub_40649F((__int64)a1, 2) )
      {
        result = (unsigned int)(*a2 - v10);
LABEL_9:
        *a3 = v10;
        *a4 = result;
        return result;
      }
      result = sub_405DB7(a1, 2, a6, a7);
      if ( (int)result >= 0 )
      {
        v12 = *a2 - v10;
        if ( (unsigned int)result <= v12 )
          goto LABEL_9;
        if ( !a5 )
        {
          result = v12;
          goto LABEL_9;
        }
      }
    }
  }
  return sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_buffer.c", 273, "invalid args", a6, a7);
}

//----- (0000000000409572) ----------------------------------------------------
__int64 __fastcall sub_409572(__int64 *a1, int a2, char a3, _DWORD *a4, _DWORD *a5, __m128 a6, __m128 a7)
{
  int v9; // ebx
  int v10; // er15
  _BOOL4 v11; // er8
  __int64 result; // rax
  int v13; // edx
  int v14; // esi

  v9 = a2 >> a3;
  v10 = sub_405DB7(a1, 0, a6, a7);
  if ( v10 < 0 )
    v10 += v9;
  v11 = sub_40649F((__int64)a1, 1);
  result = (unsigned int)v9;
  if ( v11 )
  {
LABEL_6:
    v13 = 0;
    if ( v10 < 0 )
      goto LABEL_9;
    goto LABEL_7;
  }
  result = sub_405DB7(a1, 1, a6, a7);
  if ( (int)result < 0 )
  {
    result = (unsigned int)(v9 + result);
    goto LABEL_6;
  }
  if ( v10 >= 0 )
  {
LABEL_7:
    v13 = v10;
    if ( v9 <= v10 )
      v13 = v9;
LABEL_9:
    v14 = v13;
    if ( v13 > (int)result )
      goto LABEL_16;
    goto LABEL_13;
  }
  v13 = 0;
LABEL_13:
  v14 = v13;
  if ( v9 <= (int)result )
    result = (unsigned int)v9;
  v13 = result;
LABEL_16:
  *a4 = v14 << a3;
  *a5 = v13 << a3;
  return result;
}

//----- (0000000000409619) ----------------------------------------------------
__int64 __fastcall sub_409619(__int64 *a1, int a2, int *a3, _DWORD *a4, __int64 a5, __m128 a6, __m128 a7)
{
  int v9; // er12
  int v10; // ebx

  v9 = a2;
  v10 = sub_406077(a1, 1, 0, a2, a6, a7);
  if ( !sub_40649F((__int64)a1, 2) )
    v9 = sub_406077(a1, 2, v10, a2, a6, a7);
  *a3 = v10;
  *a4 = v9;
  return a5;
}

//----- (000000000040967D) ----------------------------------------------------
__int64 __fastcall sub_40967D(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9

  result = sub_406551((__int64)a1, a2);
  if ( (_DWORD)result )
    return sub_408290(a1, a2, a3, a4, v5, v6, v7, v8);
  return result;
}
// 40969D: variable 'v5' is possibly undefined
// 40969D: variable 'v6' is possibly undefined
// 40969D: variable 'v7' is possibly undefined
// 40969D: variable 'v8' is possibly undefined

//----- (00000000004096A4) ----------------------------------------------------
void __fastcall sub_4096A4(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  sub_407CCF(a1, a2, a3, a4);
  sub_4074D7(a1, -1, 0LL, *(_QWORD *)(a2 + 24), 4u, a3, a4);
  sub_405181(a1, a3, a4);
}

//----- (00000000004096D9) ----------------------------------------------------
__int64 __fastcall sub_4096D9(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __m128 a5, __m128 a6)
{
  __int64 *v6; // r8
  __int64 v7; // rax
  int v8; // esi
  int v9; // esi
  __int64 v11; // [rsp+8h] [rbp-8h] BYREF

  sub_43AAA0((__int64)&v11, a3, a4);
  switch ( v7 )
  {
    case 0LL:
    case 1LL:
      v8 = (unsigned __int8)v11;
      return sub_406AAF(v6, v8, a5, a6);
    case 2LL:
      v9 = (char)v11;
      return sub_406A68(v6, v9, a5, a6);
    case 3LL:
      v8 = (unsigned __int16)v11;
      return sub_406AAF(v6, v8, a5, a6);
    case 4LL:
      v9 = (__int16)v11;
      return sub_406A68(v6, v9, a5, a6);
    case 5LL:
      v8 = v11;
      return sub_406AAF(v6, v8, a5, a6);
    case 6LL:
      v9 = v11;
      return sub_406A68(v6, v9, a5, a6);
    case 7LL:
      *(double *)a5.i64 = *(float *)&v11;
      return sub_406A1B(v6, a5, a6);
    case 8LL:
      a5.i64[0] = v11;
      return sub_406A1B(v6, a5, a6);
  }
}
// 4096FA: variable 'v7' is possibly undefined
// 409714: variable 'v6' is possibly undefined

//----- (0000000000409749) ----------------------------------------------------
__int64 __fastcall sub_409749(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __m128 a5, __m128 a6)
{
  char v8; // al
  __int16 v9; // ax
  int v10; // eax
  __int64 v12; // [rsp+3Ch] [rbp-20h]
  double v13[2]; // [rsp+44h] [rbp-18h] BYREF

  switch ( *(_BYTE *)(a2 + 81) )
  {
    case 0:
      v8 = sub_405E64(a1, -1, a5, a6);
      goto LABEL_4;
    case 1:
      v8 = sub_405F30(a1, -1, a5, a6);
      goto LABEL_4;
    case 2:
      v8 = sub_405E01(a1, -1, a5, a6);
LABEL_4:
      LOBYTE(v13[0]) = v8;
      break;
    case 3:
      v9 = sub_405E64(a1, -1, a5, a6);
      goto LABEL_8;
    case 4:
      v9 = sub_405E01(a1, -1, a5, a6);
LABEL_8:
      LOWORD(v13[0]) = v9;
      break;
    case 5:
      v10 = sub_405E64(a1, -1, a5, a6);
      goto LABEL_11;
    case 6:
      v10 = sub_405E01(a1, -1, a5, a6);
LABEL_11:
      LODWORD(v13[0]) = v10;
      break;
    case 7:
      *(double *)a5.i64 = sub_405CAB(a1, a5, a6);
      LODWORD(v13[0]) = sub_41D2F4(a5).u32[0];
      break;
    case 8:
      v13[0] = sub_405CAB(a1, a5, a6);
      break;
  }
  sub_43AAA0(a3, (__int64)v13, a4);
  return v12;
}
// 4097DD: variable 'v12' is possibly undefined
// 409749: using guessed type double var_18[2];

//----- (000000000040AF4D) ----------------------------------------------------
__int64 __fastcall sub_40AF4D(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  int *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // r13
  int *v7; // rax
  bool v8; // zf
  int v9; // edx
  __int64 v10; // rsi
  __int64 result; // rax

  v3 = sub_409409(a1, 1, a2, a3);
  if ( (*(_DWORD *)v3 & 3) == 2 )
  {
    v4 = sub_40746B(a1, -1744822144, 39, a2, a3);
    v5 = *(_QWORD *)(v3 + 24);
    *((_QWORD *)v4 + 7) = v3;
    ++*(_DWORD *)(v3 + 4);
    v4[19] = v5;
    return 1LL;
  }
  if ( !*(_QWORD *)(v3 + 64) && *(_DWORD *)v3 >> 27 != 19 )
  {
    v6 = *(_QWORD *)(v3 + 56);
    if ( v6 )
    {
      v7 = sub_40746B(a1, -1744822144, 39, a2, a3);
      *((_QWORD *)v7 + 7) = v6;
      ++*(_DWORD *)(v6 + 4);
      v8 = *(_QWORD *)(v3 + 64) == 0LL;
      v7[19] = *(_QWORD *)(v6 + 24);
      if ( v8 )
      {
        v9 = *(_DWORD *)(v3 + 76);
        v7[18] = 0;
        v7[19] = *(_DWORD *)(v3 + 72) + v9;
        *(_QWORD *)(v3 + 64) = v7;
        ++v7[1];
      }
    }
  }
  v10 = *(_QWORD *)(v3 + 64);
  result = 0LL;
  if ( v10 )
  {
    sub_407C45(a1, v10, a2, a3);
    return 1LL;
  }
  return result;
}

//----- (000000000040B00C) ----------------------------------------------------
__int64 __fastcall sub_40B00C(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rax
  int v4; // esi

  v3 = (_DWORD *)sub_409409(a1, 1, a2, a3);
  v4 = 0;
  if ( (*v3 & 3) != 2 )
    v4 = v3[18];
  sub_406AAF(a1, v4, a2, a3);
  return 1LL;
}

//----- (000000000040B041) ----------------------------------------------------
__int64 __fastcall sub_40B041(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rsi

  v3 = sub_409409(a1, 1, a2, a3);
  if ( (*(_DWORD *)v3 & 3) == 2 )
    v4 = *(_QWORD *)(v3 + 24);
  else
    LODWORD(v4) = *(_DWORD *)(v3 + 76);
  sub_406AAF(a1, v4, a2, a3);
  return 1LL;
}

//----- (000000000040B07A) ----------------------------------------------------
__int64 __fastcall sub_40B07A(__int64 *a1, int a2, __int64 a3)
{
  unsigned int v4; // edi
  _BYTE *v5; // rax
  int v6; // eax
  __int64 v7; // rax

  v4 = a2;
  if ( a2 > 127 )
  {
    if ( a2 > 1114111 )
      goto LABEL_5;
    goto LABEL_6;
  }
  if ( *((_DWORD *)a1 + 2) )
  {
LABEL_6:
    v6 = *((_DWORD *)a1 + 2);
    if ( (unsigned int)(a2 - 55296) > 0x7FF )
    {
      if ( v6 )
      {
        v7 = *a1;
        *((_DWORD *)a1 + 2) = 0;
        v7 += 3LL;
        *(_WORD *)(v7 - 3) = -16401;
        *(_BYTE *)(v7 - 1) = -67;
        *a1 = v7;
      }
      goto LABEL_14;
    }
    if ( a2 > 56319 )
    {
      if ( v6 )
      {
        *((_DWORD *)a1 + 2) = 0;
        v4 = a2 + ((v6 - 55296) << 10) + 9216;
        goto LABEL_14;
      }
    }
    else
    {
      *((_DWORD *)a1 + 2) = a2;
      if ( !v6 )
        return a3;
    }
LABEL_5:
    v4 = 65533;
LABEL_14:
    *a1 += (int)sub_41C531(v4, (_BYTE *)*a1);
    return a3;
  }
  v5 = (_BYTE *)(*a1)++;
  *v5 = a2;
  return a3;
}

//----- (000000000040B11C) ----------------------------------------------------
__int64 __fastcall sub_40B11C(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_406FB2(a1, a2, a3);
  sub_4036CF(a1, -1, (__int64)&dword_43C614, 8uLL, a2, a3);
  return sub_405563(a1, -1, 0LL, a2, a3);
}
// 43C614: using guessed type int dword_43C614;

//----- (000000000040B151) ----------------------------------------------------
__int64 __fastcall sub_40B151(__int64 *a1, int *a2, __m128 a3, __m128 a4)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  int v8; // er14
  const char *v9; // rcx
  unsigned int v10; // edx
  __int64 v11; // r13
  __int64 v12; // rdx
  _BYTE *v13; // r15
  unsigned __int8 *i; // rsi
  char v15; // r8
  int v16; // edi
  unsigned __int8 *v17; // rcx
  int v18; // edi
  int v19; // eax
  int v20; // eax
  unsigned __int8 *v22; // [rsp+0h] [rbp-50h]
  __int64 v23; // [rsp+8h] [rbp-48h]
  unsigned __int64 v24; // [rsp+10h] [rbp-40h] BYREF
  __int64 v25[7]; // [rsp+18h] [rbp-38h] BYREF

  v24 = 0LL;
  if ( sub_40649F((__int64)a1, 0) )
  {
    sub_4076DF(a1, 0LL, a3, a4);
    sub_405057(a1, 0, v6, v7, *(double *)a3.i64, a4);
  }
  sub_405672(a1, 0, &v24, a3, a4);
  if ( (unsigned int)sub_406117(a1, 1, a3, a4)
    || (sub_406117(a1, 1, a3, a4), !(unsigned int)sub_4036CF(a1, 1, (__int64)"stream", 6uLL, a3, a4)) )
  {
    v8 = 0;
  }
  else
  {
    v8 = sub_405BBB(a1, -1, a3, a4);
  }
  if ( v24 > 0x2AAAAAA6 )
  {
    v9 = "result too long";
    v10 = 100663552;
LABEL_52:
    sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_encoding.c", v10, v9, a3, a4);
    return 0LL;
  }
  v11 = sub_4076DF(a1, 3 * (v24 + 1), a3, a4);
  v12 = sub_40564B(a1, 0, v25, a3, a4);
  if ( v24 != v25[0] )
    goto LABEL_51;
  v13 = (_BYTE *)v11;
  for ( i = (unsigned __int8 *)v12; (unsigned __int64)i < v12 + v24; i = v17 )
  {
    v15 = *((_BYTE *)a2 + 6);
    v16 = *i;
    v17 = i + 1;
    if ( v15 )
    {
      if ( (unsigned __int8)v16 < *((_BYTE *)a2 + 5) || (unsigned __int8)v16 > *((_BYTE *)a2 + 4) )
      {
        *a2 = 0;
        *((_WORD *)a2 + 2) = -32577;
        *((_BYTE *)a2 + 6) = 0;
      }
      else
      {
        v19 = *a2;
        *((_WORD *)a2 + 2) = -32577;
        v16 = (v19 << 6) | v16 & 0x3F;
        *a2 = v16;
        *((_BYTE *)a2 + 6) = v15 - 1;
        if ( v15 != 1 )
          continue;
        *a2 = 0;
        if ( v16 >= 0 )
          goto LABEL_40;
        if ( v16 == -1 )
          continue;
        if ( v16 != -3 )
          goto LABEL_38;
      }
      v17 = i;
LABEL_38:
      if ( *((_BYTE *)a2 + 8) )
        goto LABEL_51;
      v16 = 65533;
      goto LABEL_40;
    }
    if ( (v16 & 0x80u) != 0 )
    {
      if ( (unsigned __int8)(v16 + 62) <= 0x1Du )
      {
        *((_BYTE *)a2 + 6) = 1;
        v18 = v16 & 0x1F;
LABEL_28:
        *a2 = v18;
        continue;
      }
      if ( (unsigned __int8)(v16 + 32) <= 0xFu )
      {
        if ( (_BYTE)v16 == 0xE0 )
        {
          *((_BYTE *)a2 + 5) = -96;
        }
        else if ( (_BYTE)v16 == 0xED )
        {
          *((_BYTE *)a2 + 4) = -97;
        }
        *((_BYTE *)a2 + 6) = 2;
        v18 = v16 & 0xF;
        goto LABEL_28;
      }
      if ( (unsigned __int8)(v16 + 16) <= 4u )
      {
        if ( (_BYTE)v16 == 0xF0 )
        {
          *((_BYTE *)a2 + 5) = -112;
        }
        else if ( (_BYTE)v16 == 0xF4 )
        {
          *((_BYTE *)a2 + 4) = -113;
        }
        *((_BYTE *)a2 + 6) = 3;
        v18 = v16 & 7;
        goto LABEL_28;
      }
      goto LABEL_38;
    }
LABEL_40:
    if ( !*((_BYTE *)a2 + 7) )
    {
      *((_BYTE *)a2 + 7) = 1;
      if ( v16 == 65279 && !*((_BYTE *)a2 + 9) )
        continue;
    }
    v22 = v17;
    v23 = v12;
    v20 = sub_41C6FA(v16, v13);
    v12 = v23;
    v17 = v22;
    v13 += v20;
  }
  if ( v8 )
    goto LABEL_50;
  if ( !*((_BYTE *)a2 + 6) )
    goto LABEL_49;
  if ( *((_BYTE *)a2 + 8) )
  {
LABEL_51:
    v9 = "utf-8 decode failed";
    v10 = 100663630;
    goto LABEL_52;
  }
  v13 += (int)sub_41C6FA(0xFFFDu, v13);
LABEL_49:
  *(_QWORD *)a2 = 0x80BF00000000LL;
LABEL_50:
  sub_406B69(a1, v11, (unsigned __int64)&v13[-v11], a3, a4);
  return 1LL;
}
// 40B18A: variable 'v6' is possibly undefined
// 40B18A: variable 'v7' is possibly undefined
// 40B151: using guessed type __int64 var_38[7];

//----- (000000000040B3E1) ----------------------------------------------------
__int64 __fastcall sub_40B3E1(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_41DC9A(a1, a2, a3);
  return 0LL;
}

//----- (000000000040B3EE) ----------------------------------------------------
__int64 __fastcall sub_40B3EE(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_406EC3(a1, (__int64)"utf-8", 5uLL, a2, a3);
  return 1LL;
}

//----- (000000000040B408) ----------------------------------------------------
__int64 __fastcall sub_40B408(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  int v5; // ecx
  unsigned __int64 v6; // r12
  char *v8; // rax
  char *v9; // rbx
  _WORD *v10; // rdx
  char *v11; // [rsp+0h] [rbp-30h] BYREF
  int v12; // [rsp+8h] [rbp-28h]

  if ( sub_40649F((__int64)a1, 0) )
  {
    v6 = 0LL;
  }
  else
  {
    v3 = sub_408998(a1, 0, a2, a3);
    v6 = sub_40314F(v3, 0LL, v4, v5);
    if ( v6 > 0x2AAAAAA9 )
    {
      sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_encoding.c", 0x6000176u, "result too long", a2, a3);
      return 0LL;
    }
  }
  v8 = (char *)sub_40762B(a1, 3 * v6, 1, a2, a3);
  v9 = v8;
  if ( v6 )
  {
    v12 = 0;
    v11 = v8;
    sub_408F19(a1, 0, (__int64 (__fastcall *)(__int64, _QWORD))sub_40B07A, (__int64)&v11, a2, a3);
    if ( v12 )
    {
      v10 = v11;
      *(_WORD *)v11 = -16401;
      *((_BYTE *)v10 + 2) = -67;
      v11 = (char *)v10 + 3;
    }
    v6 = v11 - v9;
    sub_41D79F(a1, -1, v11 - v9, a2, a3);
  }
  sub_4074D7(a1, -1, 0LL, v6, 4u, a2, a3);
  return 1LL;
}
// 40B430: variable 'v4' is possibly undefined
// 40B430: variable 'v5' is possibly undefined

//----- (000000000040B4EE) ----------------------------------------------------
__int64 __fastcall sub_40B4EE(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  char v4; // r13
  int v5; // eax
  char v6; // bl
  __int64 v7; // rax

  sub_41DC9A(a1, a2, a3);
  if ( !sub_40649F((__int64)a1, 0) )
    sub_408725(a1, 0, a2, a3);
  if ( (sub_406103((__int64)a1, 1) & 6) != 0 )
  {
    v6 = 0;
    v4 = 0;
  }
  else
  {
    v3 = sub_4036CF(a1, 1, (__int64)"fatal", 5uLL, a2, a3);
    v4 = v3;
    if ( v3 )
      v4 = sub_405BBB(a1, -1, a2, a3);
    v5 = sub_4036CF(a1, 1, (__int64)"ignoreBOM", 9uLL, a2, a3);
    v6 = v5;
    if ( v5 )
      v6 = sub_405BBB(a1, -1, a2, a3);
  }
  sub_406FB2(a1, a2, a3);
  v7 = sub_40762B(a1, 0xCuLL, 0, a2, a3);
  *(_BYTE *)(v7 + 8) = v4;
  *(_BYTE *)(v7 + 9) = v6;
  *(_QWORD *)v7 = 0x80BF00000000LL;
  sub_403911(a1, -2, (__int64)&dword_43C614, 8uLL, a2, a3);
  return 0LL;
}
// 43C614: using guessed type int dword_43C614;

//----- (000000000040B5D1) ----------------------------------------------------
__int64 __fastcall sub_40B5D1(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  int v4; // eax
  int v5; // esi

  v3 = sub_40B11C(a1, a2, a3);
  v4 = sub_41DCD3((__int64)a1);
  if ( v4 )
  {
    if ( v4 == 1 )
      v5 = *(unsigned __int8 *)(v3 + 8);
    else
      v5 = *(unsigned __int8 *)(v3 + 9);
    sub_406955(a1, v5, a2, a3);
  }
  else
  {
    sub_406EC3(a1, (__int64)"utf-8", 5uLL, a2, a3);
  }
  return 1LL;
}

//----- (000000000040B627) ----------------------------------------------------
__int64 __fastcall sub_40B627(__int64 *a1, __m128 a2, __m128 a3)
{
  int *v3; // rax

  v3 = (int *)sub_40B11C(a1, a2, a3);
  return sub_40B151(a1, v3, a2, a3);
}

//----- (000000000040B645) ----------------------------------------------------
__int64 __fastcall sub_40B645(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // [rsp+4h] [rbp-Ch] BYREF
  __int16 v5; // [rsp+Ch] [rbp-4h]

  v4 = 0x80BF00000000LL;
  v5 = 256;
  return sub_40B151(a1, (int *)&v4, a2, a3);
}

//----- (000000000040B66B) ----------------------------------------------------
__int64 __fastcall sub_40B66B(__int64 *a1, unsigned int a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v6; // rdi
  __int64 v8; // rsi
  __int128 *v9; // rsi
  __int64 v10; // rdx

  v6 = a1[8];
  if ( !*(_DWORD *)(v6 + 120) )
  {
    v8 = a1[54];
    if ( v8 )
    {
      v9 = (__int128 *)sub_40E629(v6, v8, a2);
      if ( v9 )
      {
        sub_406883(a1, v9, a4, a5);
        sub_40500F(a1, -2);
        sub_4068D1(a1, 4294967294LL, v10, a4, a5);
        sub_40500F(a1, -2);
        *(_DWORD *)(a1[8] + 120) = 1;
        sub_41DBA7(a1, 1, a4, a5);
        *(_DWORD *)(a1[8] + 120) = 0;
      }
    }
  }
  return a3;
}
// 40B6B1: variable 'v10' is possibly undefined

//----- (000000000040B6EA) ----------------------------------------------------
char *__fastcall sub_40B6EA(__int64 *a1, __int64 a2, __int64 a3, int a4, char a5, __m128 a6, __m128 a7)
{
  char *result; // rax
  char *v9; // r13
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rax
  char *v15; // rcx
  __int64 v16; // r14
  __int64 v17; // rax
  int v18; // er15
  __int64 v19; // rax
  unsigned int v20; // er13
  __int64 v21; // r13
  __int64 v22; // rsi
  __int64 v23; // rax
  int v24; // eax
  __int64 v25; // rax
  __int64 v26; // rsi
  char v27; // dl
  int v28; // er8
  int v29; // eax

  result = (char *)sub_405823((__int64)a1, -1);
  if ( result )
  {
    v9 = result;
    result = (char *)sub_40DCA3(a1, (__int64)result, a1[40], 1, a6, a7);
    if ( (_DWORD)result )
    {
      if ( *v9 >= 0 )
        return (char *)sub_40B66B(a1, 0x6Du, v10, a6, a7);
      v11 = a1[19];
      if ( v11 && *(_QWORD *)(v11 + 8) )
      {
        if ( (unsigned int)sub_4037B9(a1, -65484, a6, a7) )
        {
          v14 = a1[19];
          v15 = ", end of input";
          if ( **(int **)(v14 + 16) >= 0 )
            v15 = &byte_43DB77;
          sub_407AA3(a1, " (line %ld%s)", *(int *)(v14 + 1760), v15);
          sub_408E52(a1, 2, a6, a7);
          sub_403A07(a1, -131020, a6, a7);
        }
        else
        {
          sub_407D7E(a1, 4294901812LL, v12, v13, a6, a7);
        }
      }
      if ( sub_40E629(a1[8], (__int64)v9, 0x5Cu) )
        return (char *)sub_40B66B(a1, 0x6Du, v10, a6, a7);
      v16 = a1[15];
      v17 = *(_QWORD *)(a2 + 128);
      v18 = v17;
      if ( (int)v17 > 9 )
      {
        v18 = 10;
      }
      else if ( (int)v17 <= 0 )
      {
LABEL_18:
        v19 = a1[19];
        v20 = 2 * v18;
        if ( v19 && *(_QWORD *)(v19 + 8) )
          v20 += 2;
        if ( a3 )
        {
          v20 += 2;
          sub_406D71(a1, a3, v10, a6, a7);
        }
        v21 = sub_407199(a1, v20, a6, a7);
        sub_4044EE(a1, -1, a6, a7);
        v22 = a1[19];
        if ( v22 )
        {
          v23 = *(_QWORD *)(v22 + 8);
          if ( v23 )
          {
            *(_QWORD *)(v21 + 8) = v23;
            *(_DWORD *)v21 = 8;
            v21 += 32LL;
            ++*(_DWORD *)(v23 + 4);
            v24 = *(_DWORD *)(v22 + 1760);
            *(_DWORD *)(v21 - 16) = 0;
            *(double *)a6.i64 = (double)v24;
            *(double *)(v21 - 8) = (double)v24;
          }
        }
        if ( a3 )
        {
          *(double *)a7.i64 = 4294967296.0;
          v25 = *(_QWORD *)(a1[14] - 24);
          *(_DWORD *)v21 = 8;
          *(_QWORD *)(v21 + 8) = v25;
          ++*(_DWORD *)(v25 + 4);
          if ( (a5 & 1) == 0 )
            a7 = 0LL;
          *(_DWORD *)(v21 + 16) = 0;
          v21 += 32LL;
          *(double *)a6.i64 = (double)a4 + *(double *)a7.i64;
          *(_QWORD *)(v21 - 8) = a6.i64[0];
        }
        while ( v18 > 0 )
        {
          v26 = *(_QWORD *)(v16 + 8);
          v27 = *(_QWORD *)v16;
          *(_QWORD *)v21 = *(_QWORD *)v16;
          *(_QWORD *)(v21 + 8) = v26;
          if ( (v27 & 8) != 0 )
            ++*(_DWORD *)(v26 + 4);
          v21 += 32LL;
          --v18;
          v28 = sub_412000(a2, v16);
          v29 = *(_DWORD *)(v16 + 88);
          *(_DWORD *)(v21 - 16) = 0;
          *(double *)a7.i64 = (double)v28;
          *(double *)a6.i64 = (double)v29 * 4294967296.0 + (double)v28;
          *(_QWORD *)(v21 - 8) = a6.i64[0];
          v16 = *(_QWORD *)(v16 + 24);
        }
        if ( a3 )
          sub_405181(a1, a6, a7);
        sub_403E13(a1, -33530873, a6, a7);
        return (char *)sub_40B66B(a1, 0x6Du, v10, a6, a7);
      }
      if ( (a5 & 2) != 0 )
      {
        v16 = *(_QWORD *)(v16 + 24);
        --v18;
      }
      goto LABEL_18;
    }
  }
  return result;
}
// 40B7C2: variable 'v12' is possibly undefined
// 40B7C2: variable 'v13' is possibly undefined
// 40B83E: variable 'v10' is possibly undefined
// 43DB77: using guessed type char byte_43DB77;

//----- (000000000040B994) ----------------------------------------------------
__int64 __fastcall sub_40B994(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  return sub_40B66B(a1, 0x6Eu, a3, a4, a5);
}

//----- (000000000040B99E) ----------------------------------------------------
__int64 __fastcall sub_40B99E(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // rsi
  _QWORD *v5; // rdi
  const char *v6; // rax
  char v8[144]; // [rsp+0h] [rbp-90h] BYREF

  v4 = a1[8];
  v5 = *(_QWORD **)(v4 + 128);
  ++*(_DWORD *)(v4 + 108);
  if ( !v5 )
  {
    v6 = (const char *)sub_408C2C(a1, v4 + 144, a2, a3);
    sub_438FFB((__int64)v8, 128LL, "uncaught: %s", v6);
    v8[127] = 0;
    sub_408053((__int64)a1);
  }
  sub_43B0EA((__int64)v5);
  return sub_40BA08(v5, 1);
}

//----- (000000000040BA08) ----------------------------------------------------
__int64 __fastcall sub_40BA08(_QWORD *a1, int a2)
{
  __int64 result; // rax

  switch ( a2 )
  {
    case 2:
      result = a1[42];
      break;
    case 3:
      result = a1[44];
      break;
    case 4:
      result = a1[46];
      break;
    case 5:
      result = a1[48];
      break;
    case 6:
      result = a1[50];
      break;
    case 7:
      result = a1[52];
      break;
    default:
      result = a1[40];
      break;
  }
  return result;
}

//----- (000000000040BA4F) ----------------------------------------------------
__int64 __fastcall sub_40BA4F(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax
  bool v4; // zf

  result = *(_QWORD *)(a1 + 64);
  *(_OWORD *)(result + 144) = *(_OWORD *)a3;
  v4 = (*(_BYTE *)a3 & 8) == 0;
  *(_DWORD *)(result + 136) = a2;
  if ( !v4 )
  {
    result = *(_QWORD *)(a3 + 8);
    ++*(_DWORD *)(result + 4);
  }
  return result;
}

//----- (000000000040BA70) ----------------------------------------------------
__int64 __fastcall sub_40BA70(__int64 *a1, int a2, const char *a3, __int64 a4, int a5, __m128 a6, __m128 a7)
{
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rdx
  int v14; // [rsp+0h] [rbp-40h] BYREF
  double v15; // [rsp+8h] [rbp-38h]

  sub_41203C((__int64)a1);
  v10 = a1[8];
  if ( *(_DWORD *)(v10 + 116) )
  {
    *(_DWORD *)(v10 + 116) = 0;
    v11 = a1[57];
    if ( v11 )
    {
      v14 = 9;
      v15 = *(double *)&v11;
    }
    else
    {
      *(double *)a6.i64 = (double)a2;
      v14 = 0;
      v15 = (double)a2;
    }
    sub_40BA4F((__int64)a1, 1, (__int64)&v14);
  }
  else
  {
    *(_DWORD *)(v10 + 116) = 1;
    sub_404E3A(a1, 1, a6, a7);
    sub_407BD4(a1, a2 | 0x1000000, a4, a5, "%s", a3);
    sub_40B994(a1, a2 | 0x1000000u, v12, a6, a7);
    sub_40BA4F((__int64)a1, 1, a1[14] - 16);
    *(_DWORD *)(a1[8] + 116) = 0;
  }
  sub_40B99E(a1, a6, a7);
  return sub_40BB4A(a1, 1);
}
// 40BB1B: variable 'v12' is possibly undefined

//----- (000000000040BB4A) ----------------------------------------------------
__int64 __fastcall sub_40BB4A(__int64 *a1, int a2)
{
  return sub_40807C(a1, (unsigned int)-a2, 0LL, 0, "error (rc %ld)", a2);
}

//----- (000000000040BB67) ----------------------------------------------------
__int64 __fastcall sub_40BB67(__int64 a1, unsigned __int64 a2, char a3, _QWORD *a4, __m128 a5, __m128 a6)
{
  __int64 v6; // r12
  int v7; // er14
  __int64 v11; // rsi
  __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rax
  int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // edx
  int v20; // edx
  __int64 v22; // [rsp+8h] [rbp-48h]
  char v23; // [rsp+18h] [rbp-38h]
  int v24; // [rsp+1Ch] [rbp-34h]

  v6 = 0LL;
  if ( a2 > 0x7FFFFFFE )
    return v6;
  v7 = a3 & 1;
  v24 = a3 & 2;
  if ( (a3 & 3) != 0 )
  {
    v11 = 40LL;
    v12 = 40LL;
  }
  else
  {
    v11 = a2 + 32;
    v12 = 32LL;
  }
  v23 = a3;
  v22 = v12;
  v13 = sub_402F19(a1, v11, a5, a6);
  v6 = v13;
  if ( !v13 )
    goto LABEL_20;
  v14 = v22;
  if ( (v23 & 4) == 0 )
    v14 = v11;
  sub_43ABE2(v13, 0LL, v14);
  if ( !v24 )
  {
    if ( !v7 )
    {
      *a4 = v15 + 32;
      goto LABEL_15;
    }
    if ( a2 )
    {
      sub_402F7A(a1, a2, a5, a6);
      if ( v16 )
      {
        *a4 = v16;
        *(_QWORD *)(v6 + 32) = v16;
        goto LABEL_15;
      }
LABEL_20:
      v6 = 0LL;
      sub_403142(a1);
      return v6;
    }
  }
  *a4 = 0LL;
LABEL_15:
  v17 = *(_DWORD *)v6;
  *(_QWORD *)(v6 + 24) = a2;
  v18 = v17 & 0xFFFFFFFC;
  if ( v7 )
  {
    v19 = v18;
    LOBYTE(v18) = v18 | 0x82;
    v20 = v19 | 0x182;
    if ( v24 )
      v18 = v20;
  }
  else
  {
    v18 |= 2u;
  }
  *(_DWORD *)v6 = v18;
  sub_40C9D7(a1, v6);
  return v6;
}
// 40BC23: variable 'v16' is possibly undefined
// 40BC30: variable 'v15' is possibly undefined

//----- (000000000040BC90) ----------------------------------------------------
__int64 __fastcall sub_40BC90(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a2 + 32);
}

//----- (000000000040BC95) ----------------------------------------------------
__int64 __fastcall sub_40BC95(__int64 a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // er8
  __int64 v4; // rax
  unsigned int v5; // eax

  v2 = *(_DWORD *)(a1 + 72);
  v3 = 0;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24LL);
  if ( v2 <= (unsigned int)v4 )
  {
    v5 = v4 - v2;
    if ( v5 <= a2 )
      return v5;
    return a2;
  }
  return v3;
}

//----- (000000000040BCB5) ----------------------------------------------------
__int64 __fastcall sub_40BCB5(__int64 a1, unsigned int *a2)
{
  unsigned int v2; // eax
  __int64 i; // r14
  _QWORD *j; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rbx

  sub_403142(a1);
  v2 = *a2;
  if ( (*a2 & 0x1800) == 0 )
  {
    if ( v2 >> 27 == 18 )
    {
      sub_403142(a1);
      for ( i = *((_QWORD *)a2 + 15); i; i = v6 )
      {
        for ( j = *(_QWORD **)(i + 48); j; j = v5 )
        {
          v5 = (_QWORD *)*j;
          sub_403142(a1);
        }
        v6 = *(_QWORD *)(i + 24);
        sub_403142(a1);
      }
    }
    else if ( (v2 & 0x400) != 0 )
    {
      sub_403142(a1);
    }
  }
  return sub_403142(a1);
}

//----- (000000000040BD49) ----------------------------------------------------
__int64 __fastcall sub_40BD49(__int64 a1, _DWORD *a2)
{
  if ( (*a2 & 0x180) == 128 )
    sub_403142(a1);
  return sub_403142(a1);
}

//----- (000000000040BD87) ----------------------------------------------------
__int64 __fastcall sub_40BD87(__int64 a1, unsigned int *a2)
{
  if ( (*a2 & 3) == 0 )
    return sub_403142(a1);
  if ( (*a2 & 3) == 1 )
    return sub_40BCB5(a1, a2);
  return sub_40BD49(a1, a2);
}

//----- (000000000040BD9E) ----------------------------------------------------
__int64 __fastcall sub_40BD9E(__int64 a1)
{
  __int64 i; // rsi
  __int64 v2; // r12
  __int64 result; // rax
  _QWORD *v4; // rsi
  _QWORD *v5; // r12

  for ( i = *(_QWORD *)(a1 + 72); i; i = v2 )
  {
    v2 = *(_QWORD *)(i + 24);
    result = sub_403142(a1);
  }
  v4 = *(_QWORD **)(a1 + 80);
  *(_QWORD *)(a1 + 72) = 0LL;
  while ( v4 )
  {
    v5 = (_QWORD *)*v4;
    result = sub_403142(a1);
    v4 = v5;
  }
  *(_QWORD *)(a1 + 80) = 0LL;
  return result;
}

//----- (000000000040BDF0) ----------------------------------------------------
__int64 __fastcall sub_40BDF0(__int64 a1, __m128 a2, __m128 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // r15
  unsigned __int64 v5; // r14
  __int64 v6; // r13
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r13
  __int64 j; // rsi
  __int64 v11; // rbx
  __int64 k; // rsi
  __int64 v13; // rbx
  int i; // [rsp+Ch] [rbp-34h]

  sub_40C6B4(a1, 0, a2, a3);
  sub_40C6B4(a1, 0, a2, a3);
  *(_DWORD *)(a1 + 112) = 1;
  sub_40C6B4(a1, 0, a2, a3);
  *(_DWORD *)a1 |= 4u;
  if ( *(_QWORD *)(a1 + 176) )
  {
    *(_DWORD *)(a1 + 100) = 2;
    v3 = 0LL;
    *(_QWORD *)(a1 + 104) = 0x100000001LL;
    for ( i = 0; ; ++i )
    {
      v4 = *(_QWORD *)(a1 + 48);
      v5 = 0LL;
      v6 = 0LL;
      while ( v4 )
      {
        ++v6;
        if ( (*(_BYTE *)v4 & 1) != 0 && (unsigned int)sub_410740(v4) && (*(_BYTE *)v4 & 0x20) == 0 )
        {
          ++v5;
          sub_40C214(a1, (int *)v4, a2, a3, v7, v8);
        }
        v4 = *(_QWORD *)(v4 + 8);
      }
      v9 = 2 * v6;
      v3 = (3 * v3) >> 2;
      if ( !i )
        v3 = v9;
      if ( v5 >= v3 || !v5 )
        break;
    }
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 108) = 0;
  }
  sub_40BD9E(a1);
  for ( j = *(_QWORD *)(a1 + 48); j; j = v11 )
  {
    v11 = *(_QWORD *)(j + 8);
    sub_40BD87(a1, (unsigned int *)j);
  }
  for ( k = *(_QWORD *)(a1 + 64); k; k = v13 )
  {
    v13 = *(_QWORD *)(k + 8);
    sub_40BD87(a1, (unsigned int *)k);
  }
  sub_40D483(a1);
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(a1 + 24))(*(_QWORD *)(a1 + 32), a1);
}
// 40BE91: variable 'v7' is possibly undefined
// 40BE91: variable 'v8' is possibly undefined

//----- (000000000040BF33) ----------------------------------------------------
__int64 __fastcall sub_40BF33(
        __int64 (__fastcall *a1)(__int64, __int64),
        __m128 a2,
        __m128 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  __int64 v10; // rax
  __int64 v11; // r12
  _QWORD *v12; // rax
  __int64 v13; // r10
  __int64 v14; // rdi
  int v15; // eax
  __int64 v16; // rcx
  __int64 v17; // rbx
  char *v18; // rdi
  unsigned int v19; // eax
  int *v20; // rax
  int v21; // edx
  __int64 v22; // rax
  __int64 *v23; // rbx
  __int64 v24; // rax
  __int64 v25; // rax
  double v26; // xmm0_8
  int v27; // ebx
  __int64 v28; // rdi
  char v30[27]; // [rsp+15h] [rbp-6Bh] BYREF
  __int64 *v31; // [rsp+30h] [rbp-50h] BYREF
  char v32; // [rsp+38h] [rbp-48h] BYREF
  __int64 v33; // [rsp+40h] [rbp-40h]

  v10 = ((__int64 (__fastcall *)(__int64, __int64, double, double))a1)(a6, 5760LL, *(double *)a2.i64, *(double *)a3.i64);
  v11 = v10;
  if ( v10 )
  {
    sub_43ABE2(v10, 0LL, 0x1680uLL);
    v12[1] = a1;
    v12[2] = v13;
    v12[3] = a5;
    v12[4] = a6;
    v12[5] = a7;
    *(_DWORD *)(v11 + 144) = 2;
    *(_QWORD *)(v11 + 104) = 0x100000001LL;
    *(_DWORD *)(v11 + 160) = 2;
    *(_QWORD *)(v11 + 200) = 0x3E800000000LL;
    *(_DWORD *)(v11 + 208) = v11 ^ 0x1505;
    v14 = a1(a6, 0x2000LL);
    *(_QWORD *)(v11 + 240) = v14;
    if ( v14 )
    {
      *(_QWORD *)(v11 + 248) = 0x400000003FFLL;
      sub_43ABE2(v14, 0LL, 0x2000uLL);
      v31 = qword_440D60;
      v17 = 0LL;
      v18 = &v32;
      while ( v16 )
      {
        *(_DWORD *)v18 = v15;
        v18 += 4;
        --v16;
      }
      v33 = 972LL;
      while ( 1 )
      {
        v19 = sub_41CE93((__int64 *)&v31);
        v20 = (int *)sub_40D1BA(v11, (__int64)v30, v19, a2, a3);
        if ( !v20 )
          break;
        if ( (_DWORD)v17 == 33 || (_DWORD)v17 == 67 )
          *v20 |= 0x2000u;
        if ( (unsigned int)(v17 - 122) <= 0x2C )
        {
          v21 = *v20;
          BYTE1(v21) = BYTE1(*v20) | 8;
          if ( (unsigned int)v17 >= 0x9E )
            v21 = *v20 | 0x1800;
          *v20 = v21;
        }
        ++v20[1];
        *(_QWORD *)(v11 + 8 * v17++ + 4424) = v20;
        if ( v17 == 167 )
        {
          v22 = sub_40D5D1(v11, -1879048064, a2, a3);
          v23 = (__int64 *)v22;
          if ( v22 )
          {
            *(_BYTE *)(v22 + 73) = 1;
            *(_QWORD *)(v22 + 568) = v11 + 4424;
            *(_QWORD *)(v11 + 176) = v22;
            ++*(_DWORD *)(v22 + 4);
            if ( (unsigned int)sub_411864(v11, (_QWORD *)v22, a2, a3) )
            {
              sub_411944(v23, a2, a3);
              v24 = v23[55];
              v23[4] = v24;
              if ( v24 )
                ++*(_DWORD *)(v24 + 4);
              sub_40D513(v11, 134234240, a2, a3);
              *(_QWORD *)(v11 + 192) = v25;
              if ( v25 )
              {
                ++*(_DWORD *)(v25 + 4);
                v26 = sub_41DD96(*(_QWORD *)(v11 + 176));
                if ( v26 >= 9.223372036854776e18 )
                {
                  *(_QWORD *)(v11 + 216) = (unsigned int)(int)(v26 - 9.223372036854776e18);
                  *(_QWORD *)(v11 + 216) ^= 0x8000000000000000LL;
                }
                else
                {
                  *(_QWORD *)(v11 + 216) = (unsigned int)(int)v26;
                }
                v27 = 10;
                sub_41D6B1(*(_QWORD *)(v11 + 176));
                *(_QWORD *)(v11 + 224) ^= v11;
                do
                {
                  sub_41D71B(*(_QWORD *)(v11 + 176));
                  --v27;
                }
                while ( v27 );
                *(_QWORD *)(v11 + 104) = 0LL;
                return v11;
              }
            }
          }
          break;
        }
      }
    }
    if ( *(_QWORD *)(v11 + 176) )
      *(_QWORD *)(v11 + 104) = 0LL;
    v28 = v11;
    v11 = 0LL;
    sub_40BDF0(v28, a2, a3);
  }
  return v11;
}
// 40BF7D: variable 'v12' is possibly undefined
// 40BF81: variable 'v13' is possibly undefined
// 40C02D: variable 'v16' is possibly undefined
// 40C02D: variable 'v15' is possibly undefined
// 40C119: variable 'v25' is possibly undefined
// 41DD96: using guessed type double __fastcall sub_41DD96(_QWORD);
// 440D60: using guessed type __int64 qword_440D60[121];
// 40BF33: using guessed type char var_6B[27];

//----- (000000000040C1D2) ----------------------------------------------------
__int64 __fastcall sub_40C1D2(__int64 a1, __m128 a2, __m128 a3)
{
  sub_4037B9((__int64 *)a1, -65431, a2, a3);
  sub_404FF1((__int64 *)a1, a2, a3);
  sub_406955((__int64 *)a1, **(_DWORD **)(a1 + 64) & 4, a2, a3);
  sub_41DA2F((__int64 *)a1, 2, a2, a3);
  return 0LL;
}

//----- (000000000040C214) ----------------------------------------------------
__int64 __fastcall sub_40C214(__int64 a1, int *a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 *v7; // r12
  __int64 v8; // rcx

  v6 = *a2;
  v7 = *(__int64 **)(a1 + 176);
  *a2 |= 0x20u;
  if ( (v6 & 0x2000000) != 0 )
    return a6;
  sub_407C45(v7, (__int64)a2, a3, a4);
  sub_41DAD1(v7, (__int64 (__fastcall *)(__int64, __int64))sub_40C1D2, 0LL, 0, 1, a3, a4);
  return sub_407DC0(v7, (__int64)sub_40C1D2, a6, v8, a3, a4);
}
// 40C257: variable 'v8' is possibly undefined

//----- (000000000040C261) ----------------------------------------------------
__int64 __fastcall sub_40C261(__int64 a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int *v6; // r12
  int v7; // er13
  int v8; // er14
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 result; // rax

  if ( !*(_DWORD *)(a1 + 108) )
  {
    *(_DWORD *)(a1 + 108) = 1;
    while ( 1 )
    {
      v6 = *(int **)(a1 + 64);
      if ( !v6 )
      {
        *(_DWORD *)(a1 + 108) = 0;
        return result;
      }
      v7 = *(_DWORD *)(a1 + 112);
      *v6 &= ~0x10u;
      if ( v7 )
        goto LABEL_8;
      v8 = v6[1];
      sub_40C214(a1, v6, a2, a3, a5, a6);
      if ( v6[1] != 1 )
        break;
LABEL_9:
      sub_40CA34(a1, (__int64)v6);
      if ( v7 )
      {
        --v6[1];
        *v6 &= ~0x10u;
        result = sub_40C9D7(a1, (__int64)v6);
      }
      else
      {
        sub_40CAF7(a1, (unsigned int *)v6, v9, v10, a2, a3);
        result = sub_40BCB5(a1, (unsigned int *)v6);
      }
    }
    if ( v8 == 1 )
      *v6 &= ~0x20u;
LABEL_8:
    v7 = 1;
    goto LABEL_9;
  }
  return result;
}
// 40C2A2: variable 'a5' is possibly undefined
// 40C2A2: variable 'a6' is possibly undefined
// 40C2EC: variable 'v9' is possibly undefined
// 40C2EC: variable 'v10' is possibly undefined

//----- (000000000040C30F) ----------------------------------------------------
void __fastcall sub_40C30F(_DWORD *a1, int *a2)
{
  int v3; // eax
  unsigned int v4; // er13
  unsigned int v5; // edx
  unsigned int i; // er14
  int *v7; // rsi
  __int64 v8; // rsi
  __int64 v9; // r15
  __int64 v10; // rsi
  unsigned int v11; // eax
  __int64 v12; // r13
  unsigned __int64 v13; // r14
  unsigned __int64 j; // r13
  __int64 v15; // rsi
  int **v16; // r13
  unsigned __int64 v17; // rbx
  int *v18; // rsi
  unsigned int v19; // edx
  int *v20; // rsi
  __int64 v21; // r13
  int k; // ebx
  unsigned __int64 m; // r13
  __int64 v24; // rsi
  __int64 n; // r13
  int *v26; // rsi

  if ( a2 )
  {
    v3 = *a2;
    v4 = *a2 & 4;
    if ( !v4 )
    {
      *a2 = v3 | 4;
      v5 = a1[23];
      if ( v5 > 0xFF )
      {
        *a1 |= 1u;
        *a2 = v3 | 0xC;
        return;
      }
      a1[23] = v5 + 1;
      if ( (v3 & 3) != 1 )
        goto LABEL_46;
      for ( i = 0; i < a2[11]; ++i )
      {
        v7 = *(int **)(*((_QWORD *)a2 + 3) + 16LL * (unsigned int)a2[10] + 8LL * i);
        if ( v7 )
        {
          sub_40C30F(a1, v7);
          v8 = *((_QWORD *)a2 + 3);
          v9 = 16LL * i;
          if ( (*(_BYTE *)(v8 + 24LL * (unsigned int)a2[10] + i) & 8) != 0 )
          {
            sub_40C30F(a1, *(int **)(v8 + 16LL * i));
            sub_40C30F(a1, *(int **)(*((_QWORD *)a2 + 3) + v9 + 8));
          }
          else
          {
            sub_40C5C6(a1, v9 + v8);
          }
        }
      }
      while ( v4 < a2[12] )
      {
        v10 = v4++;
        sub_40C5C6(a1, *((_QWORD *)a2 + 3) + (-a2[10] & 7) + 25LL * (unsigned int)a2[10] + 16 * v10);
      }
      sub_40C30F(a1, *((int **)a2 + 4));
      v11 = *a2;
      if ( (*a2 & 0x4000) != 0 )
        goto LABEL_46;
      if ( (v11 & 0x800) != 0 )
      {
        sub_40C30F(a1, *((int **)a2 + 7));
        sub_40C30F(a1, *((int **)a2 + 10));
        sub_40C30F(a1, *((int **)a2 + 11));
        v12 = *((_QWORD *)a2 + 7);
        if ( v12 )
        {
          v13 = *((_QWORD *)a2 + 8);
          for ( j = v12 + 32; v13 > j; j += 16LL )
          {
            v15 = j;
            sub_40C5C6(a1, v15);
          }
          v16 = (int **)*((_QWORD *)a2 + 8);
          v17 = *((_QWORD *)a2 + 9);
          while ( v17 > (unsigned __int64)v16 )
          {
            v18 = *v16++;
            sub_40C30F(a1, v18);
          }
        }
        goto LABEL_46;
      }
      v19 = v11 >> 27;
      if ( v11 >> 27 != 16 )
      {
        if ( v19 == 15 )
        {
          v20 = (int *)*((_QWORD *)a2 + 7);
LABEL_29:
          sub_40C30F(a1, v20);
LABEL_46:
          --a1[23];
          return;
        }
        if ( (v11 & 0x2000) == 0 )
        {
          if ( (v11 & 0x400) != 0 )
          {
            sub_40C5C6(a1, (__int64)(a2 + 14));
            sub_40C5C6(a1, (__int64)(a2 + 18));
            v21 = *((_QWORD *)a2 + 11);
            for ( k = a2[24]; k > 0; --k )
            {
              if ( (*(_BYTE *)v21 & 8) != 0 )
                sub_40C30F(a1, *(int **)(v21 + 8));
              v21 += 16LL;
            }
            goto LABEL_46;
          }
          if ( (v11 & 0x2000000) == 0 )
          {
            if ( v19 == 18 )
            {
              for ( m = *((_QWORD *)a2 + 10); m < *((_QWORD *)a2 + 14); m += 16LL )
              {
                v24 = m;
                sub_40C5C6(a1, v24);
              }
              for ( n = *((_QWORD *)a2 + 15); n; n = *(_QWORD *)(n + 24) )
              {
                sub_40C30F(a1, *(int **)(n + 16));
                sub_40C30F(a1, *(int **)(n + 32));
                sub_40C30F(a1, *(int **)(n + 40));
              }
              sub_40C30F(a1, *((int **)a2 + 18));
              do
              {
                v26 = *(int **)((char *)a2 + n + 160);
                n += 8LL;
                sub_40C30F(a1, v26);
              }
              while ( n != 408 );
            }
            goto LABEL_46;
          }
        }
      }
      sub_40C30F(a1, *((int **)a2 + 7));
      v20 = (int *)*((_QWORD *)a2 + 8);
      goto LABEL_29;
    }
  }
}

//----- (000000000040C5C6) ----------------------------------------------------
void __fastcall sub_40C5C6(_DWORD *a1, __int64 a2)
{
  if ( a2 )
  {
    if ( (*(_BYTE *)a2 & 8) != 0 )
      sub_40C30F(a1, *(int **)(a2 + 8));
  }
}

//----- (000000000040C5DA) ----------------------------------------------------
__int64 __fastcall sub_40C5DA(_QWORD *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax

  v3 = sub_405B41((__int64)a1, -1);
  sub_40E4C4(a1, v3, a2, a3);
  return 0LL;
}

//----- (000000000040C5FE) ----------------------------------------------------
__int64 __fastcall sub_40C5FE(_QWORD *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  while ( a2 )
  {
    result = (*(_DWORD *)a2 & 3u) - 1;
    if ( (*(_DWORD *)a2 & 3) == 1 )
    {
      sub_407C45(a1, a2, a3, a4);
      result = sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_40C5DA, 0LL, 1, 0, a3, a4);
    }
    a2 = *(_QWORD *)(a2 + 8);
  }
  return result;
}

//----- (000000000040C646) ----------------------------------------------------
__int64 __fastcall sub_40C646(unsigned int *a1)
{
  __int64 result; // rax
  __int64 v2; // r12
  __int64 i; // r12

  while ( 1 )
  {
    result = *a1;
    if ( (result & 1) == 0 )
      break;
    v2 = *((_QWORD *)a1 + 6);
    *a1 = result & 0xFFFFFFFE;
    while ( v2 )
    {
      if ( (*(_DWORD *)v2 & 8) != 0 )
      {
        *(_DWORD *)v2 &= 0xFFFFFFF3;
        sub_40C30F(a1, (int *)v2);
      }
      v2 = *(_QWORD *)(v2 + 8);
    }
    for ( i = *((_QWORD *)a1 + 8); i; i = *(_QWORD *)(i + 8) )
    {
      if ( (*(_DWORD *)i & 8) != 0 )
      {
        *(_DWORD *)i &= 0xFFFFFFF3;
        sub_40C30F(a1, (int *)i);
      }
    }
  }
  return result;
}

//----- (000000000040C6B4) ----------------------------------------------------
__int64 __fastcall sub_40C6B4(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // er12
  __int64 i; // rax
  __int64 v7; // rbx
  int *v8; // rsi
  __int64 v9; // r13
  __int64 ii; // rsi
  __int64 j; // rbx
  __int64 m; // rbx
  __int64 k; // rbx
  __int64 v14; // rdx
  __int64 v15; // rcx
  unsigned int *n; // rbx
  unsigned int *v17; // r15
  __int64 v18; // r13
  unsigned int v19; // edx
  __int64 v20; // rbx
  __int64 v21; // r15
  __int64 jj; // rax
  unsigned int *v23; // [rsp+10h] [rbp-40h]
  __int64 v24; // [rsp+10h] [rbp-40h]
  unsigned int v25; // [rsp+1Ch] [rbp-34h]

  result = *(unsigned int *)(a1 + 104);
  v25 = *(_DWORD *)(a1 + 104);
  if ( !(_DWORD)result )
  {
    v5 = a2 | *(_DWORD *)(a1 + 96);
    if ( *(_QWORD *)(a1 + 64) )
      LOBYTE(v5) = v5 | 2;
    *(_QWORD *)(a1 + 100) = 0x100000001LL;
    sub_40BD9E(a1);
    for ( i = 0LL; i != 4096; i += 16LL )
      *(_QWORD *)(a1 + i + 328) = 0LL;
    v7 = 0LL;
    sub_40C30F((_DWORD *)a1, *(int **)(a1 + 176));
    sub_40C30F((_DWORD *)a1, *(int **)(a1 + 192));
    do
    {
      v8 = *(int **)(a1 + v7 + 4424);
      v7 += 8LL;
      sub_40C30F((_DWORD *)a1, v8);
    }
    while ( v7 != 1336 );
    v9 = 0LL;
    sub_40C5C6((_DWORD *)a1, a1 + 144);
    ii = a1 + 160;
    sub_40C5C6((_DWORD *)a1, a1 + 160);
    sub_40C646((unsigned int *)a1);
    for ( j = *(_QWORD *)(a1 + 48); j; j = *(_QWORD *)(j + 8) )
    {
      if ( (*(_DWORD *)j & 0x25) == 1 )
      {
        if ( (unsigned int)sub_410740(j) )
        {
          *(_DWORD *)j |= 0x10u;
          ++v9;
        }
      }
    }
    if ( v9 )
    {
      for ( k = *(_QWORD *)(a1 + 48); k; k = *(_QWORD *)(k + 8) )
      {
        if ( (*(_BYTE *)k & 0x10) != 0 )
        {
          ii = k;
          sub_40C30F((_DWORD *)a1, (int *)k);
        }
      }
    }
    for ( m = *(_QWORD *)(a1 + 64); m; m = *(_QWORD *)(m + 8) )
    {
      ii = m;
      sub_40C30F((_DWORD *)a1, (int *)m);
    }
    sub_40C646((unsigned int *)a1);
    for ( n = *(unsigned int **)(a1 + 48); n; n = (unsigned int *)*((_QWORD *)n + 1) )
    {
      if ( (*(_BYTE *)n & 4) == 0 )
      {
        ii = (__int64)n;
        sub_40CEAE(a1, n, v14, v15, a3, a4);
      }
    }
    v17 = *(unsigned int **)(a1 + 48);
    v18 = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    while ( v17 )
    {
      v19 = *v17;
      v23 = (unsigned int *)*((_QWORD *)v17 + 1);
      if ( (*v17 & 4) != 0 )
      {
        if ( (v19 & 0x10) != 0 )
        {
          ++v17[1];
          ii = (__int64)v17;
          sub_40CA16(a1, (__int64)v17);
        }
        else
        {
          if ( (v19 & 0x20) == 0 || (v5 & 2) != 0 )
            ++v18;
          else
            *v17 = v19 & 0xFFFFFFDF;
          if ( n )
            *((_QWORD *)n + 1) = v17;
          else
            *(_QWORD *)(a1 + 48) = v17;
          *((_QWORD *)v17 + 2) = n;
          n = v17;
        }
        v14 = *v17;
        if ( (v14 & 1) != 0 )
        {
          v14 = (unsigned int)v14 >> 27;
          if ( (_DWORD)v14 == 18 )
          {
            ii = v5 & 1;
            sub_404DC3(v17, v5 & 1, a3, a4);
          }
        }
        *v17 &= ~4u;
      }
      else
      {
        ii = (__int64)v17;
        sub_40BD87(a1, v17);
      }
      v17 = v23;
    }
    if ( n )
      *((_QWORD *)n + 1) = 0LL;
    v20 = 0LL;
    if ( *(_QWORD *)(a1 + 240) )
    {
      while ( v25 < *(_DWORD *)(a1 + 252) )
      {
        v14 = *(_QWORD *)(a1 + 240);
        v21 = 0LL;
        for ( ii = *(_QWORD *)(v14 + 8LL * v25); ii; ii = v24 )
        {
          v24 = *(_QWORD *)(ii + 8);
          if ( (*(_DWORD *)ii & 4) != 0 )
          {
            ++v20;
            v21 = ii;
            *(_DWORD *)ii &= ~4u;
          }
          else
          {
            sub_40CFF2(a1, ii);
            sub_40D44A(a1, ii, v21);
            sub_40BD82(a1);
          }
        }
        ++v25;
      }
    }
    for ( jj = *(_QWORD *)(a1 + 64); jj; jj = *(_QWORD *)(jj + 8) )
      *(_DWORD *)jj &= ~4u;
    if ( (v5 & 5) == 1 && !*(_DWORD *)(a1 + 136) )
    {
      sub_40C5FE(*(_QWORD **)(a1 + 176), *(_QWORD *)(a1 + 48), a3, a4);
      ii = *(_QWORD *)(a1 + 64);
      sub_40C5FE(*(_QWORD **)(a1 + 176), ii, a3, a4);
    }
    if ( (v5 & 1) != 0 )
      sub_40D473(a1, a3, a4);
    *(_QWORD *)(a1 + 100) = 0LL;
    *(_DWORD *)(a1 + 88) = 12800 * ((unsigned __int64)(v18 + v20) >> 8) + 1024;
    return sub_40C261(a1, a3, a4, ii, v14, v15);
  }
  return result;
}
// 40C804: variable 'v14' is possibly undefined
// 40C804: variable 'v15' is possibly undefined

//----- (000000000040C9D7) ----------------------------------------------------
__int64 __fastcall sub_40C9D7(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 48);
  if ( result )
    *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(a2 + 16) = 0LL;
  *(_QWORD *)(a2 + 8) = result;
  *(_QWORD *)(a1 + 48) = a2;
  return result;
}

//----- (000000000040C9F5) ----------------------------------------------------
__int64 __fastcall sub_40C9F5(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = *(_QWORD *)(a2 + 16);
  result = *(_QWORD *)(a2 + 8);
  if ( v2 )
    *(_QWORD *)(v2 + 8) = result;
  else
    *(_QWORD *)(a1 + 48) = result;
  if ( result )
    *(_QWORD *)(result + 16) = v2;
  return result;
}

//----- (000000000040CA16) ----------------------------------------------------
__int64 __fastcall sub_40CA16(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a2 + 16) = 0LL;
  if ( result )
    *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(a2 + 8) = result;
  *(_QWORD *)(a1 + 64) = a2;
  return result;
}

//----- (000000000040CA34) ----------------------------------------------------
__int64 __fastcall sub_40CA34(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx

  result = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  if ( result )
    *(_QWORD *)(result + 16) = v3;
  if ( v3 )
    *(_QWORD *)(v3 + 8) = result;
  else
    *(_QWORD *)(a1 + 64) = result;
  return result;
}

//----- (000000000040CA54) ----------------------------------------------------
__int64 __fastcall sub_40CA54(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rdi
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 64);
  if ( *(_QWORD *)(v6 + 64) )
    return sub_40C261(v6, a5, a6, a2, a3, a4);
  return result;
}

//----- (000000000040CA67) ----------------------------------------------------
__int64 __fastcall sub_40CA67(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 64);
  if ( !*(_DWORD *)(v2 + 100) )
  {
    sub_40CFF2(*(_QWORD *)(a1 + 64), a2);
    sub_40D40B(v2, a2);
    return sub_40BD82(v2);
  }
  return result;
}

//----- (000000000040CAA6) ----------------------------------------------------
__int64 __fastcall sub_40CAA6(__int64 a1, _DWORD *a2)
{
  __int64 v2; // r13
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 64);
  if ( !*(_DWORD *)(v2 + 100) )
  {
    sub_40C9F5(*(_QWORD *)(a1 + 64), (__int64)a2);
    return sub_40BD49(v2, a2);
  }
  return result;
}

//----- (000000000040CAE2) ----------------------------------------------------
__int64 __fastcall sub_40CAE2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rdi
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 64);
  if ( !*(_DWORD *)(v6 + 100) )
    return sub_40CEB9(v6, a2, 1, a4, a5, a6);
  return result;
}

//----- (000000000040CAF7) ----------------------------------------------------
__int64 __fastcall sub_40CAF7(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v7; // r15
  __int64 v8; // r12
  unsigned int v9; // er14
  __int64 v10; // rax
  __int64 v11; // rsi
  bool v12; // zf
  __int64 *v13; // r13
  __int64 v14; // rsi
  __int64 v15; // rsi
  _DWORD *v16; // rsi
  __int64 v17; // r14
  unsigned int v18; // er15
  __int64 v19; // r13
  __int64 v20; // rax
  _DWORD *v21; // rsi
  __int64 v22; // rsi
  __int64 result; // rax
  __int64 v24; // r13
  _DWORD *v25; // rsi
  unsigned __int64 v26; // r14
  unsigned __int64 i; // r13
  _DWORD *v28; // rsi
  __int64 *v29; // r13
  unsigned __int64 v30; // r14
  __int64 v31; // rsi
  _DWORD *v32; // rsi
  _DWORD *v33; // rsi
  __int64 v34; // rdx
  __int64 v35; // rsi
  __int64 v36; // rsi
  _DWORD *v37; // rsi
  _DWORD *v38; // rsi
  _DWORD *v39; // rsi
  __int64 v40; // r13
  int m; // ebx
  _DWORD *v42; // rsi
  __int64 v43; // rsi
  unsigned __int64 j; // r13
  _DWORD *v45; // rsi
  _QWORD *k; // r13
  __int64 v47; // rsi
  __int64 v48; // rsi
  __int64 v49; // rsi
  __int64 v50; // rsi
  __int64 v51; // [rsp+10h] [rbp-40h]
  __int64 v52; // [rsp+18h] [rbp-38h]

  v7 = *((_QWORD *)a2 + 3);
  v8 = *(_QWORD *)(a1 + 176);
  v9 = a2[11];
  v10 = a2[10];
  v52 = 16 * v10;
  v51 = v7 + 24 * v10;
  while ( --v9 != -1 )
  {
    a4 = v52;
    a3 = v9;
    v11 = *(_QWORD *)(v7 + 8LL * v9 + v52);
    if ( v11 )
    {
      v12 = (*(_DWORD *)(v11 + 4))-- == 1;
      if ( v12 )
      {
        sub_40CA67(v8, v11);
        a3 = v9;
      }
      v13 = (__int64 *)(v7 + 16 * a3);
      if ( (*(_BYTE *)(v51 + a3) & 8) != 0 )
      {
        v14 = *v13;
        if ( *v13 )
        {
          v12 = (*(_DWORD *)(v14 + 4))-- == 1;
          if ( v12 )
            sub_40CAE2(v8, v14, a3, a4, a5, a6);
        }
        v15 = v13[1];
        if ( v15 )
        {
          v12 = (*(_DWORD *)(v15 + 4))-- == 1;
          if ( v12 )
            sub_40CAE2(v8, v15, a3, a4, a5, a6);
        }
      }
      else if ( (*(_BYTE *)v13 & 8) != 0 )
      {
        v16 = (_DWORD *)v13[1];
        v12 = v16[1]-- == 1;
        if ( v12 )
          sub_40CFD5(v8, v16, a3, a4, a5, a6);
      }
    }
  }
  v17 = *((_QWORD *)a2 + 3);
  v18 = a2[12];
  v19 = 25LL * a2[10] + (-a2[10] & 7);
  while ( --v18 != -1 )
  {
    v20 = v17 + v19 + 16LL * v18;
    if ( (*(_BYTE *)v20 & 8) != 0 )
    {
      v21 = *(_DWORD **)(v20 + 8);
      v12 = v21[1]-- == 1;
      if ( v12 )
        sub_40CFD5(v8, v21, a3, a4, a5, a6);
    }
  }
  v22 = *((_QWORD *)a2 + 4);
  if ( v22 )
  {
    v12 = (*(_DWORD *)(v22 + 4))-- == 1;
    if ( v12 )
      sub_40CAE2(v8, v22, a3, a4, a5, a6);
  }
  result = *a2;
  if ( (result & 0x4000) == 0 )
  {
    if ( (result & 0x800) != 0 )
    {
      v24 = *((_QWORD *)a2 + 7);
      if ( v24 )
      {
        v26 = *((_QWORD *)a2 + 8);
        for ( i = v24 + 32; i < v26; i += 16LL )
        {
          if ( (*(_BYTE *)i & 8) != 0 )
          {
            v28 = *(_DWORD **)(i + 8);
            v12 = v28[1]-- == 1;
            if ( v12 )
              result = sub_40CFD5(v8, v28, a3, a4, a5, a6);
          }
        }
        v29 = (__int64 *)*((_QWORD *)a2 + 8);
        v30 = *((_QWORD *)a2 + 9);
        while ( (unsigned __int64)v29 < v30 )
        {
          v31 = *v29;
          v12 = (*(_DWORD *)(*v29 + 4))-- == 1;
          if ( v12 )
            result = sub_40CAE2(v8, v31, a3, a4, a5, a6);
          ++v29;
        }
      }
      v25 = (_DWORD *)*((_QWORD *)a2 + 10);
      if ( v25 )
      {
        v12 = v25[1]-- == 1;
        if ( v12 )
          result = sub_40CFCD(v8, v25, a3, a4, a5, a6);
      }
      v32 = (_DWORD *)*((_QWORD *)a2 + 11);
      if ( v32 )
      {
        v12 = v32[1]-- == 1;
        if ( v12 )
          result = sub_40CFCD(v8, v32, a3, a4, a5, a6);
      }
      v33 = (_DWORD *)*((_QWORD *)a2 + 7);
      if ( v33 )
      {
        v12 = v33[1]-- == 1;
        if ( v12 )
          return sub_40CFCD(v8, v33, a3, a4, a5, a6);
      }
      return result;
    }
    v34 = (unsigned int)result >> 27;
    if ( (_DWORD)v34 == 16 )
    {
      v35 = *((_QWORD *)a2 + 7);
      if ( v35 )
      {
        v12 = (*(_DWORD *)(v35 + 4))-- == 1;
        if ( v12 )
          result = sub_40CAE2(v8, v35, v34, a4, a5, a6);
      }
LABEL_58:
      v36 = *((_QWORD *)a2 + 8);
      goto LABEL_100;
    }
    if ( (_DWORD)v34 == 15 )
    {
      v36 = *((_QWORD *)a2 + 7);
      goto LABEL_101;
    }
    if ( (result & 0x2000) != 0 )
    {
      v37 = (_DWORD *)*((_QWORD *)a2 + 7);
      if ( v37 )
      {
        v12 = v37[1]-- == 1;
        if ( v12 )
          result = sub_40CAA6(v8, v37);
      }
      goto LABEL_58;
    }
    if ( (result & 0x400) == 0 )
    {
      if ( (result & 0x2000000) == 0 )
      {
        if ( (_DWORD)v34 != 18 )
          return result;
        for ( j = *((_QWORD *)a2 + 10); *((_QWORD *)a2 + 14) > j; j += 16LL )
        {
          if ( (*(_BYTE *)j & 8) != 0 )
          {
            v45 = *(_DWORD **)(j + 8);
            v12 = v45[1]-- == 1;
            if ( v12 )
              result = sub_40CFD5(v8, v45, v34, a4, a5, a6);
          }
        }
        for ( k = (_QWORD *)*((_QWORD *)a2 + 15); k; k = (_QWORD *)k[3] )
        {
          v47 = k[2];
          if ( v47 )
          {
            v12 = (*(_DWORD *)(v47 + 4))-- == 1;
            if ( v12 )
              result = sub_40CAE2(v8, v47, v34, a4, a5, a6);
          }
          v48 = k[4];
          if ( v48 )
          {
            v12 = (*(_DWORD *)(v48 + 4))-- == 1;
            if ( v12 )
              result = sub_40CAE2(v8, v48, v34, a4, a5, a6);
          }
          v49 = k[5];
          if ( v49 )
          {
            v12 = (*(_DWORD *)(v49 + 4))-- == 1;
            if ( v12 )
              result = sub_40CAE2(v8, v49, v34, a4, a5, a6);
          }
        }
        do
        {
          v50 = *(_QWORD *)((char *)k + (_QWORD)a2 + 160);
          if ( v50 )
          {
            v12 = (*(_DWORD *)(v50 + 4))-- == 1;
            if ( v12 )
              result = sub_40CAE2(v8, v50, v34, a4, a5, a6);
          }
          ++k;
        }
        while ( k != (_QWORD *)408 );
        v36 = *((_QWORD *)a2 + 18);
LABEL_100:
        if ( !v36 )
          return result;
        goto LABEL_101;
      }
      v43 = *((_QWORD *)a2 + 7);
      v12 = (*(_DWORD *)(v43 + 4))-- == 1;
      if ( v12 )
        result = sub_40CAE2(v8, v43, v34, a4, a5, a6);
      v36 = *((_QWORD *)a2 + 8);
LABEL_101:
      v12 = (*(_DWORD *)(v36 + 4))-- == 1;
      if ( v12 )
        return sub_40CAE2(v8, v36, v34, a4, a5, a6);
      return result;
    }
    if ( (a2[14] & 8) != 0 )
    {
      v38 = (_DWORD *)*((_QWORD *)a2 + 8);
      v12 = v38[1]-- == 1;
      if ( v12 )
        result = sub_40CFD5(v8, v38, v34, a4, a5, a6);
    }
    if ( (a2[18] & 8) != 0 )
    {
      v39 = (_DWORD *)*((_QWORD *)a2 + 10);
      v12 = v39[1]-- == 1;
      if ( v12 )
        result = sub_40CFD5(v8, v39, v34, a4, a5, a6);
    }
    v40 = *((_QWORD *)a2 + 11);
    for ( m = a2[24]; m > 0; --m )
    {
      if ( (*(_BYTE *)v40 & 8) != 0 )
      {
        v42 = *(_DWORD **)(v40 + 8);
        v12 = v42[1]-- == 1;
        if ( v12 )
          result = sub_40CFD5(v8, v42, v34, a4, a5, a6);
      }
      v40 += 16LL;
    }
  }
  return result;
}
// 40CB91: variable 'a4' is possibly undefined
// 40CBA7: variable 'a3' is possibly undefined
// 40CD7B: variable 'v34' is possibly undefined

//----- (000000000040CEAE) ----------------------------------------------------
__int64 __fastcall sub_40CEAE(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax

  if ( (*(_BYTE *)a2 & 1) != 0 )
    return sub_40CAF7(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (000000000040CEB9) ----------------------------------------------------
__int64 __fastcall sub_40CEB9(__int64 a1, __int64 a2, int a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // r12
  __int64 v8; // rdx
  __int64 v9; // rcx
  unsigned int v10; // eax
  __int64 v12; // rax

  v6 = a2;
  sub_40C9F5(a1, a2);
  if ( !(unsigned int)sub_410740(a2) || (v10 = *(_DWORD *)a2, (*(_DWORD *)a2 & 0x20) != 0) )
  {
    v12 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a2 + 16) = 0LL;
    *(_QWORD *)(a1 + 56) = a2;
    if ( v12 )
    {
      *(_QWORD *)(v12 + 16) = a2;
    }
    else
    {
      do
      {
        sub_40CAF7(a1, (unsigned int *)v6, v8, v9, a5, a6);
        a2 = v6;
        v6 = *(_QWORD *)(v6 + 16);
        sub_40BCB5(a1, (unsigned int *)a2);
      }
      while ( v6 );
      *(_QWORD *)(a1 + 56) = 0LL;
      if ( !a3 && *(_QWORD *)(a1 + 64) )
        return sub_40C261(a1, a5, a6, a2, a4, v9);
    }
  }
  else
  {
    ++*(_DWORD *)(a2 + 4);
    *(_DWORD *)a2 = v10 | 0x10;
    sub_40CA16(a1, a2);
    if ( !a3 && !*(_QWORD *)(a1 + 56) )
      return sub_40C261(a1, a5, a6, a2, a4, v9);
  }
  return a4;
}
// 40CF10: variable 'v9' is possibly undefined
// 40CF31: variable 'v8' is possibly undefined

//----- (000000000040CFCD) ----------------------------------------------------
__int64 __fastcall sub_40CFCD(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v7; // rdi

  v7 = *(_QWORD *)(a1 + 64);
  result = *a2 & 3;
  if ( !*(_DWORD *)(v7 + 100) )
  {
    if ( (_DWORD)result )
    {
      if ( (_DWORD)result == 1 )
      {
        return sub_40CEB9(v7, (__int64)a2, 0, a4, a5, a6);
      }
      else
      {
        sub_40C9F5(v7, (__int64)a2);
        return sub_40BD49(v7, a2);
      }
    }
    else
    {
      sub_40CFF2(v7, (__int64)a2);
      sub_40D40B(v7, (__int64)a2);
      return sub_40BD82(v7);
    }
  }
  return result;
}

//----- (000000000040CFD5) ----------------------------------------------------
__int64 __fastcall sub_40CFD5(__int64 a1, _DWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v7; // rdi

  v7 = *(_QWORD *)(a1 + 64);
  result = *a2 & 3;
  if ( !*(_DWORD *)(v7 + 100) )
  {
    if ( (_DWORD)result )
    {
      if ( (_DWORD)result == 1 )
      {
        return sub_40CEB9(v7, (__int64)a2, 1, a4, a5, a6);
      }
      else
      {
        sub_40C9F5(v7, (__int64)a2);
        return sub_40BD49(v7, a2);
      }
    }
    else
    {
      sub_40CFF2(v7, (__int64)a2);
      sub_40D40B(v7, (__int64)a2);
      return sub_40BD82(v7);
    }
  }
  return result;
}

//----- (000000000040CFE0) ----------------------------------------------------
__int64 __fastcall sub_40CFE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rdi
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 64);
  if ( !*(_DWORD *)(v6 + 100) )
    return sub_40CEB9(v6, a2, 0, a4, a5, a6);
  return result;
}

//----- (000000000040CFF2) ----------------------------------------------------
__int64 __fastcall sub_40CFF2(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  for ( result = 0LL; result != 64; result += 16LL )
  {
    if ( *(_QWORD *)(a1 + result + 264) == a2 )
      *(_QWORD *)(a1 + result + 264) = 0LL;
  }
  return result;
}

//----- (000000000040D015) ----------------------------------------------------
__int64 __fastcall sub_40D015(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  unsigned int v6; // ebx
  unsigned int v7; // er13
  unsigned int v10; // eax
  unsigned __int64 v11; // rdx
  __int64 v12; // r8
  unsigned __int64 v13; // rdi
  unsigned int v14; // er9
  unsigned __int64 v15; // r10
  unsigned int v16; // esi
  unsigned int v17; // ecx
  unsigned int v18; // esi
  _BYTE *v19; // rcx
  unsigned int v20; // esi
  unsigned int v21; // esi
  unsigned int v22; // ecx
  int v23; // ecx
  __int64 v24; // r8
  __int64 v25; // rax

  v6 = a3;
  if ( *(char *)a2 < 0 )
    return v6;
  v10 = sub_40314F(a2, a2, a3, a4);
  v7 = *(_DWORD *)a2 & 0x80;
  if ( v7 )
    return v6;
  v11 = 0LL;
  v12 = a1[8];
  if ( v10 > 0x10 )
  {
    v11 = v12 + 264;
    while ( *(_QWORD *)v11 != a2 )
    {
      v11 += 16LL;
      if ( v12 + 328 == v11 )
      {
        v11 = 0LL;
        break;
      }
    }
  }
  v13 = a2 + 32;
  v14 = v10 - v6;
  v15 = a2 + 32 + *(unsigned int *)(a2 + 24);
  if ( !v11 )
    goto LABEL_25;
  v16 = *(_DWORD *)(v11 + 12);
  v17 = v10 - v6;
  if ( v6 <= v14 )
    v17 = v6;
  if ( v16 > v6 )
  {
    v20 = v16 - v6;
    if ( v17 >= v20 )
    {
      v19 = (_BYTE *)(v13 + *(unsigned int *)(v11 + 8));
      while ( v13 <= (unsigned __int64)--v19 )
      {
        if ( (*v19 & 0xC0) != 0x80 && !--v20 )
          goto LABEL_37;
      }
      goto LABEL_36;
    }
LABEL_25:
    v19 = (_BYTE *)(a2 + 32 + *(unsigned int *)(a2 + 24));
    if ( v6 > v14 )
    {
LABEL_34:
      if ( v14 )
      {
        while ( v13 <= (unsigned __int64)--v19 )
        {
          if ( (*v19 & 0xC0) != 0x80 )
          {
            --v14;
            goto LABEL_34;
          }
        }
        goto LABEL_36;
      }
    }
    else
    {
      v21 = v6;
      v19 = (_BYTE *)(a2 + 32);
LABEL_27:
      if ( v21 )
      {
        while ( v15 > (unsigned __int64)++v19 )
        {
          if ( (*v19 & 0xC0) != 0x80 )
          {
            --v21;
            goto LABEL_27;
          }
        }
        goto LABEL_36;
      }
    }
    goto LABEL_37;
  }
  v18 = v6 - v16;
  if ( v17 < v18 )
    goto LABEL_25;
  v19 = (_BYTE *)(v13 + *(unsigned int *)(v11 + 8));
LABEL_15:
  if ( v18 )
  {
    while ( v15 > (unsigned __int64)++v19 )
    {
      if ( (*v19 & 0xC0) != 0x80 )
      {
        --v18;
        goto LABEL_15;
      }
    }
LABEL_36:
    sub_401CB7(a1, (__int64)"third_party/duktape/duk_heap_stringcache.c", 307, a5, a6);
    return v7;
  }
LABEL_37:
  v22 = (_DWORD)v19 - v13;
  v7 = v22;
  if ( v10 > 0x10 )
  {
    if ( !v11 )
    {
      v11 = v12 + 312;
      *(_QWORD *)(v12 + 312) = a2;
    }
    *(_DWORD *)(v11 + 8) = v22;
    *(_DWORD *)(v11 + 12) = v6;
    if ( v12 + 264 < v11 )
    {
      sub_43ABC2((_BYTE *)(v12 + 280), (_BYTE *)(v12 + 264), v11 - (v12 + 264));
      *(_DWORD *)(v24 + 272) = v23;
      *(_DWORD *)(v24 + 276) = v6;
      *(_QWORD *)(v24 + 264) = v25;
    }
  }
  return v7;
}
// 40D199: variable 'v23' is possibly undefined
// 40D199: variable 'v24' is possibly undefined
// 40D1A7: variable 'v25' is possibly undefined

//----- (000000000040D1BA) ----------------------------------------------------
__int64 __fastcall sub_40D1BA(__int64 a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  unsigned __int64 v5; // r15
  unsigned int v7; // ebx
  __int64 i; // r12
  __int64 v9; // rcx
  _DWORD *v10; // rdi
  int v11; // eax
  char v12; // al
  __int64 *v13; // rax

  v5 = a3;
  v7 = sub_420124(a1, a2, a3);
  for ( i = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8LL * (*(_DWORD *)(a1 + 248) & v7)); i; i = *(_QWORD *)(i + 8) )
  {
    if ( *(_DWORD *)(i + 16) == v7 && *(_DWORD *)(i + 24) == (_DWORD)v5 && !(unsigned int)sub_41D69F(a2, i + 32, v5) )
      return i;
  }
  ++*(_DWORD *)(a1 + 108);
  if ( !*(_BYTE *)(a1 + 256) )
    sub_401D4B(a1, a4, a5);
  i = sub_402F19(a1, v5 + 33, a4, a5);
  if ( i )
  {
    v9 = 8LL;
    v10 = (_DWORD *)i;
    while ( v9 )
    {
      *v10++ = 0;
      --v9;
    }
    sub_43AAA0(i + 32, a2, v5);
    *(_BYTE *)(i + v5 + 32) = 0;
    *(_DWORD *)(i + 24) = v5;
    *(_DWORD *)(i + 16) = v7;
    v11 = sub_417FE9((unsigned __int8 *)(i + 32), v5);
    *(_DWORD *)(i + 20) = v11;
    if ( v11 == -1 )
    {
      v12 = *(_BYTE *)(i + 32);
      if ( v12 < 0 )
      {
        if ( (unsigned __int8)v12 > 0x81u )
        {
          if ( v12 == -126 || v12 == -1 )
            *(_DWORD *)i |= 0x600u;
        }
        else
        {
          *(_DWORD *)i |= 0x200u;
        }
      }
    }
    else
    {
      *(_DWORD *)i |= 0x180u;
    }
  }
  --*(_DWORD *)(a1 + 108);
  if ( i )
  {
    v13 = (__int64 *)(*(_QWORD *)(a1 + 240) + 8LL * (*(_DWORD *)(a1 + 248) & v7));
    *(_QWORD *)(i + 8) = *v13;
    *v13 = i;
    ++*(_DWORD *)(a1 + 256);
  }
  return i;
}

//----- (000000000040D302) ----------------------------------------------------
__int64 __fastcall sub_40D302(__int64 a1, unsigned int a2, __m128 a3, __m128 a4)
{
  char *v4; // r8
  unsigned int v5; // edx
  __int64 savedregs; // [rsp+10h] [rbp+0h] BYREF

  v4 = (char *)&savedregs;
  do
  {
    *--v4 = byte_43F2E0[a2 % 0xA];
    v5 = a2;
    a2 /= 0xAu;
  }
  while ( v5 > 9 );
  return sub_40D1BA(a1, (__int64)v4, (char *)&savedregs - v4, a3, a4);
}

//----- (000000000040D33F) ----------------------------------------------------
__int64 __fastcall sub_40D33F(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  __int64 result; // rax

  result = sub_40D1BA(a1[8], a2, a3, a4, a5);
  if ( !result )
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_heap_stringtable.c", 805, a4, a5);
    return 0LL;
  }
  return result;
}

//----- (000000000040D37C) ----------------------------------------------------
int *__fastcall sub_40D37C(__int64 *a1, __int64 a2, __int16 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 *v7; // r12
  int *result; // rax
  int v9; // edx

  v5 = a1[8];
  v6 = 16LL * (unsigned __int8)(a2 ^ a3);
  v7 = (__int64 *)(v5 + v6 + 328);
  if ( *v7 == a2 )
    return *(int **)(v5 + v6 + 336);
  result = (int *)sub_40D33F(a1, a2, a3, a4, a5);
  v9 = *result;
  *v7 = a2;
  v7[1] = (__int64)result;
  if ( (v9 & 0x8000) == 0 )
  {
    ++result[1];
    BYTE1(v9) |= 0x80u;
    *result = v9;
  }
  return result;
}

//----- (000000000040D3CE) ----------------------------------------------------
__int64 __fastcall sub_40D3CE(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  result = sub_40D302(a1[8], a2, a3, a4);
  if ( !result )
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_heap_stringtable.c", 875, a3, a4);
    return 0LL;
  }
  return result;
}

//----- (000000000040D40B) ----------------------------------------------------
__int64 __fastcall sub_40D40B(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 *v4; // rcx
  __int64 v5; // rdx
  __int64 i; // rax
  __int64 result; // rax

  v2 = (unsigned int)(*(_DWORD *)(a1 + 248) & *(_DWORD *)(a2 + 16));
  v3 = *(_QWORD *)(a1 + 240);
  --*(_DWORD *)(a1 + 256);
  v4 = (__int64 *)(v3 + 8 * v2);
  v5 = 0LL;
  for ( i = *v4; i != a2; i = *(_QWORD *)(i + 8) )
    v5 = i;
  result = *(_QWORD *)(i + 8);
  if ( v5 )
    *(_QWORD *)(v5 + 8) = result;
  else
    *v4 = result;
  return result;
}

//----- (000000000040D44A) ----------------------------------------------------
__int64 __fastcall sub_40D44A(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 result; // rax

  --*(_DWORD *)(a1 + 256);
  v3 = *(_QWORD *)(a2 + 8);
  if ( a3 )
  {
    *(_QWORD *)(a3 + 8) = v3;
  }
  else
  {
    result = (unsigned int)(*(_DWORD *)(a1 + 248) & *(_DWORD *)(a2 + 16));
    *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * result) = v3;
  }
  return result;
}

//----- (000000000040D473) ----------------------------------------------------
void __fastcall sub_40D473(__int64 a1, __m128 a2, __m128 a3)
{
  if ( *(_QWORD *)(a1 + 240) )
    sub_401D4B(a1, a2, a3);
}

//----- (000000000040D483) ----------------------------------------------------
__int64 __fastcall sub_40D483(__int64 a1)
{
  __int64 v1; // rbx
  __int64 i; // r13
  __int64 j; // rsi
  __int64 v4; // r14

  v1 = *(_QWORD *)(a1 + 240);
  for ( i = v1 + 8LL * *(unsigned int *)(a1 + 252); i != v1; i -= 8LL )
  {
    for ( j = *(_QWORD *)(i - 8); j; j = v4 )
    {
      v4 = *(_QWORD *)(j + 8);
      sub_40BD82(a1);
    }
  }
  return sub_403142(a1);
}

//----- (000000000040D4DB) ----------------------------------------------------
int *__fastcall sub_40D4DB(__int64 *a1, int a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rdi
  int *v6; // rax
  int *v8; // [rsp+8h] [rbp-18h]

  sub_402FE5(a1, a3, a4, a5);
  v5 = a1[8];
  *v6 = a2 | 1;
  v8 = v6;
  sub_40C9D7(v5, (__int64)v6);
  return v8;
}
// 40D4FD: variable 'v6' is possibly undefined

//----- (000000000040D513) ----------------------------------------------------
void __fastcall sub_40D513(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  int *v4; // rax

  sub_402F7A(a1, 0x38uLL, a3, a4);
  if ( v4 )
  {
    *v4 = a2 | 1;
    sub_40C9D7(a1, (__int64)v4);
  }
}
// 40D52F: variable 'v4' is possibly undefined

//----- (000000000040D551) ----------------------------------------------------
int *__fastcall sub_40D551(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x38uLL, a3, a4);
}

//----- (000000000040D558) ----------------------------------------------------
int *__fastcall sub_40D558(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x68uLL, a3, a4);
}

//----- (000000000040D562) ----------------------------------------------------
int *__fastcall sub_40D562(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x48uLL, a3, a4);
}

//----- (000000000040D56C) ----------------------------------------------------
__int64 __fastcall sub_40D56C(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int *v5; // rax
  __int64 v6; // [rsp+8h] [rbp-18h]

  result = sub_402F19(a1, 104LL, a3, a4);
  if ( result )
  {
    v6 = result;
    sub_43ABE2(result, 0LL, 0x68uLL);
    *v5 = a2 | 1;
    sub_40C9D7(a1, (__int64)v5);
    result = v6;
    *(_DWORD *)(v6 + 56) = 2;
    *(_DWORD *)(v6 + 72) = 2;
  }
  return result;
}
// 40D5A1: variable 'v5' is possibly undefined

//----- (000000000040D5C7) ----------------------------------------------------
int *__fastcall sub_40D5C7(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x58uLL, a3, a4);
}

//----- (000000000040D5D1) ----------------------------------------------------
__int64 __fastcall sub_40D5D1(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int *v5; // rax
  __int64 v6; // [rsp+8h] [rbp-18h]

  result = sub_402F19(a1, 576LL, a3, a4);
  if ( result )
  {
    v6 = result;
    sub_43ABE2(result, 0LL, 0x240uLL);
    *v5 = a2 | 1;
    sub_40C9D7(a1, (__int64)v5);
    result = v6;
    *(_QWORD *)(v6 + 64) = a1;
  }
  return result;
}
// 40D608: variable 'v5' is possibly undefined

//----- (000000000040D625) ----------------------------------------------------
__int64 __fastcall sub_40D625(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  result = sub_40D5D1(a1[8], a2, a3, a4);
  if ( !result )
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_hobject_alloc.c", 216, a3, a4);
    return 0LL;
  }
  return result;
}

//----- (000000000040D662) ----------------------------------------------------
int *__fastcall sub_40D662(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x40uLL, a3, a4);
}

//----- (000000000040D66C) ----------------------------------------------------
int *__fastcall sub_40D66C(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x50uLL, a3, a4);
}

//----- (000000000040D676) ----------------------------------------------------
int *__fastcall sub_40D676(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x48uLL, a3, a4);
}

//----- (000000000040D680) ----------------------------------------------------
int *__fastcall sub_40D680(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_40D4DB(a1, a2, 0x48uLL, a3, a4);
}

//----- (000000000040D68A) ----------------------------------------------------
__int64 __fastcall sub_40D68A(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx

  sub_407808(a1, a2, a3, a4);
  sub_40699D(a1, a3, a4, a2, v4);
  return sub_40388B(a1, -3, a3, a4);
}
// 40D69C: variable 'v4' is possibly undefined

//----- (000000000040D6B2) ----------------------------------------------------
__int64 __fastcall sub_40D6B2(__int64 a1, int a2, int a3)
{
  __int64 result; // rax
  int v4; // er9
  int v5; // er8
  __int64 v6; // rcx
  __int64 v7; // rbx
  int v8; // er11
  _DWORD *v9; // r12
  int v10; // er11
  _BYTE *v11; // rsi
  __int64 v12; // r10

  result = (unsigned int)(a2 + 1);
  if ( (int)result < a3 )
  {
    v4 = a2;
    v5 = a3;
    result = (int)result;
    v6 = *(_QWORD *)(a1 + 24) + 16LL * *(unsigned int *)(a1 + 40);
    do
    {
      v7 = result - 1;
      do
      {
        v8 = v7;
        if ( v4 > (int)v7 )
          break;
        v9 = *(_DWORD **)(v6 + 8 * v7--);
      }
      while ( *(unsigned int *)(*(_QWORD *)(v6 + 8 * result) + 20LL)
            + (unsigned __int64)(**(_DWORD **)(v6 + 8 * result) & 0x200) < (unsigned int)v9[5]
                                                                         + (unsigned __int64)(*v9 & 0x200) );
      v10 = v8 + 1;
      if ( v10 != (_DWORD)result )
      {
        v11 = (_BYTE *)(v6 + 8LL * v10);
        sub_43ABC2((_BYTE *)(v6 + 8LL * v10 + 8), v11, 8LL * ((int)result - v10));
        *(_QWORD *)v11 = v12;
      }
      ++result;
    }
    while ( v5 > (int)result );
  }
  return result;
}
// 40D6F9: variable 'v4' is possibly undefined
// 40D6FB: variable 'v6' is possibly undefined
// 40D744: variable 'v12' is possibly undefined
// 40D747: variable 'result' is possibly undefined
// 40D74D: variable 'v5' is possibly undefined

//----- (000000000040D757) ----------------------------------------------------
__int64 __fastcall sub_40D757(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  char v4; // r13
  __int64 v5; // r15
  __int64 v6; // r14
  int v7; // ebx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  int v13; // er13
  __int64 v14; // rdx
  int v15; // er9
  unsigned int i; // eax
  int v17; // ebx
  __int64 v18; // rax
  __int64 v19; // rdx
  int v20; // ecx
  int v21; // edx
  unsigned int k; // ecx
  __int64 v23; // rax
  unsigned int j; // ecx
  __int64 v25; // rax
  __int64 v26; // rdx
  int *v27; // rsi
  int v28; // edx
  int v30; // [rsp+Ch] [rbp-54h]
  int v31; // [rsp+10h] [rbp-50h]
  unsigned int v32; // [rsp+10h] [rbp-50h]
  unsigned int v33; // [rsp+14h] [rbp-4Ch]
  unsigned int v34; // [rsp+18h] [rbp-48h]
  unsigned int v35; // [rsp+18h] [rbp-48h]
  int v36; // [rsp+1Ch] [rbp-44h]
  __int64 v37; // [rsp+20h] [rbp-40h] BYREF
  __int64 v38[7]; // [rsp+28h] [rbp-38h] BYREF

  v4 = a2;
  v5 = sub_40582D(a1, -1, a3, a4);
  sub_40779C(a1, a3, a4);
  v6 = sub_405B41((__int64)a1, -1);
  sub_407C45(a1, v5, a3, a4);
  sub_403A07(a1, -130976, a3, a4);
  sub_406A68(a1, 2, a3, a4);
  sub_403A07(a1, -130975, a3, a4);
  v7 = a2 & 0x80;
  if ( (a2 & 0x80) == 0 && (unsigned int)sub_40DE9A(v5, &v37, v38) )
  {
    sub_407C45(a1, v38[0], a3, a4);
    if ( (unsigned int)sub_4037B9(a1, -65461, a3, a4) )
    {
      sub_40500F(a1, -2);
      sub_407C45(a1, v37, a3, a4);
      sub_41DA64(a1, 1, a3, a4);
      sub_40582D(a1, -1, a3, a4);
      sub_41FF48(a1, v37, a2, a3, a4);
      v10 = 0xFFFFFFFFLL;
      v13 = sub_405CB0(a1, 0xFFFFFFFF, a3, a4);
      while ( v7 != v13 )
      {
        sub_40370E(a1, -1, v7++, a3, a4);
        sub_40699D(a1, a3, a4, 0xFFFFFFFFLL, v14);
        v10 = 4294967291LL;
        sub_40388B(a1, -5, a3, a4);
      }
      sub_407DC0(a1, v10, v11, v12, a3, a4);
      sub_405181(a1, a3, a4);
      return sub_40E4C4(a1, v6, a3, a4);
    }
    v5 = v37;
    sub_407C45(a1, v37, a3, a4);
    sub_403A07(a1, -262048, a3, a4);
    sub_407DC0(a1, 4294705248LL, v8, v9, a3, a4);
  }
  v36 = 2;
  v33 = a2 >> 6;
LABEL_17:
  if ( v5 )
  {
    if ( (*(_DWORD *)v5 & 0x802000) == 0 )
    {
      if ( (v4 & 8) != 0 )
      {
LABEL_12:
        v15 = 0;
        for ( i = 0; ; ++i )
        {
          if ( *(_DWORD *)(v5 + 44) <= i )
          {
            v17 = *(_DWORD *)(v6 + 44);
            if ( (v33 & 1) == 0 && v15 )
              sub_40D6B2(v6, v36, v17);
            if ( (v4 & 0x10) != 0 )
              goto LABEL_54;
            v5 = *(_QWORD *)(v5 + 32);
            v36 = v17;
            goto LABEL_17;
          }
          v26 = *(_QWORD *)(v5 + 24);
          v27 = *(int **)(v26 + 16LL * *(unsigned int *)(v5 + 40) + 8LL * i);
          if ( v27 && ((v4 & 1) != 0 || (*(_BYTE *)(24LL * *(unsigned int *)(v5 + 40) + v26 + i) & 2) != 0) )
          {
            v28 = *v27;
            if ( (*v27 & 0x200) != 0 )
            {
              if ( (v4 & 2) == 0 && (v28 & 0x400) != 0 || (v4 & 4) == 0 )
                continue;
              v15 = 1;
            }
            else if ( (v4 & 8) != 0 )
            {
              continue;
            }
            if ( (v28 & 0x100) != 0 )
            {
              v15 = 1;
LABEL_50:
              v30 = v15;
              v32 = i;
              sub_40D68A(a1, (__int64)v27, a3, a4);
              v15 = v30;
              i = v32;
              continue;
            }
            if ( (v4 & 0x20) == 0 )
              goto LABEL_50;
          }
        }
      }
LABEL_29:
      for ( j = 0; *(_DWORD *)(v5 + 48) > j; ++j )
      {
        if ( *(_DWORD *)(*(_QWORD *)(v5 + 24)
                       + 25LL * *(unsigned int *)(v5 + 40)
                       + 16LL * j
                       + (-*(_DWORD *)(v5 + 40) & 7)) != 7 )
        {
          v35 = j;
          v25 = sub_40D3CE(a1, j, a3, a4);
          sub_40D68A(a1, v25, a3, a4);
          j = v35;
        }
      }
      if ( _bittest((const signed __int32 *)v5, 0x16u) && (v4 & 1) != 0 )
        sub_40D68A(a1, *(_QWORD *)(a1[71] + 696), a3, a4);
      goto LABEL_12;
    }
    if ( (v4 & 8) != 0 )
      goto LABEL_12;
    if ( (*(_DWORD *)v5 & 0x800000) != 0 )
    {
      v18 = sub_40E6C2(a1[8], v5);
      v21 = sub_40314F(v18, v5, v19, v20);
    }
    else
    {
      if ( !*(_BYTE *)(v5 + 82) )
        goto LABEL_29;
      v21 = *(_DWORD *)(v5 + 76) >> *(_BYTE *)(v5 + 80);
    }
    for ( k = 0; k != v21; k = v34 + 1 )
    {
      v31 = v21;
      v34 = k;
      v23 = sub_40D3CE(a1, k, a3, a4);
      sub_40D68A(a1, v23, a3, a4);
      v21 = v31;
    }
    if ( (v4 & 1) != 0 )
      sub_40D68A(a1, *(_QWORD *)(a1[71] + 696), a3, a4);
    goto LABEL_29;
  }
LABEL_54:
  sub_405181(a1, a3, a4);
  if ( (v4 & 0x40) != 0 )
    sub_40D6B2(v6, 2, *(_DWORD *)(v6 + 44));
  return sub_40E4C4(a1, v6, a3, a4);
}
// 40D81C: variable 'v8' is possibly undefined
// 40D81C: variable 'v9' is possibly undefined
// 40D89B: variable 'v14' is possibly undefined
// 40D8B2: variable 'v11' is possibly undefined
// 40D8B2: variable 'v12' is possibly undefined
// 40D937: variable 'v19' is possibly undefined
// 40D937: variable 'v20' is possibly undefined
// 40D757: using guessed type __int64 var_38[7];

//----- (000000000040DAF3) ----------------------------------------------------
__int64 __fastcall sub_40DAF3(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rbx
  unsigned int v5; // er13
  __int64 v6; // rdx
  __int64 v7; // rcx
  _DWORD *v8; // r14
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // r15
  __int64 v13; // rdx
  __int64 v14; // rcx
  int v16; // [rsp+Ch] [rbp-34h]

  v4 = sub_40582D(a1, -1, a3, a4);
  sub_4037B9(a1, -65439, a3, a4);
  v5 = sub_4054AF(a1, -1, a3, a4);
  sub_407D7E(a1, 0xFFFFFFFFLL, v6, v7, a3, a4);
  sub_403883(a1, -65440, a3, a4);
  v8 = (_DWORD *)sub_40582D(a1, -1, a3, a4);
  v16 = *v8 & 0x2000000;
  sub_407D7E(a1, 0xFFFFFFFFLL, v9, v10, a3, a4);
  while ( *(_DWORD *)(v4 + 44) > v5 )
  {
    v11 = v5++;
    v12 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 16LL * *(unsigned int *)(v4 + 40) + 8 * v11);
    if ( v16 || (unsigned int)sub_40F3D3(a1, (__int64)v8, v12, a3, a4) )
      goto LABEL_7;
  }
  v12 = 0LL;
LABEL_7:
  sub_406AAF(a1, v5, a3, a4);
  sub_403A07(a1, -130975, a3, a4);
  if ( v12 )
  {
    sub_407808(a1, v12, a3, a4);
    if ( a2 )
    {
      sub_407C45(a1, (__int64)v8, a3, a4);
      sub_404FF1(a1, a3, a4);
      sub_403616(a1, -2, a3, a4);
      sub_405181(a1, a3, a4);
      sub_40511F(a1, -3, a3, a4);
    }
    else
    {
      sub_405181(a1, a3, a4);
    }
    return 1LL;
  }
  else
  {
    sub_407D7E(a1, 4294836321LL, v13, v14, a3, a4);
    return 0LL;
  }
}
// 40DB33: variable 'v6' is possibly undefined
// 40DB33: variable 'v7' is possibly undefined
// 40DB60: variable 'v9' is possibly undefined
// 40DB60: variable 'v10' is possibly undefined
// 40DC17: variable 'v13' is possibly undefined
// 40DC17: variable 'v14' is possibly undefined

//----- (000000000040DC2D) ----------------------------------------------------
__int64 __fastcall sub_40DC2D(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  unsigned int v5; // ebx
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rsi

  sub_40D757(a1, a2, a3, a4);
  v4 = sub_405B41((__int64)a1, -1);
  v5 = *(_DWORD *)(v4 + 44) - 2;
  v6 = sub_407199(a1, v5, a3, a4);
  v7 = 0LL;
  v8 = *(_QWORD *)(v4 + 24) + 16 * (*(unsigned int *)(v4 + 40) + 1LL);
  while ( --v5 != -1 )
  {
    v9 = *(_QWORD *)(v8 + v7);
    *(_DWORD *)(v6 + 2 * v7) = 8;
    *(_QWORD *)(v6 + 2 * v7 + 8) = v9;
    ++*(_DWORD *)(v9 + 4);
    v7 += 8LL;
  }
  sub_405181(a1, a3, a4);
  return 1LL;
}

//----- (000000000040DCA3) ----------------------------------------------------
__int64 __fastcall sub_40DCA3(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  unsigned int v6; // er12

  if ( a2 && a3 )
  {
    v6 = 10001;
    while ( 1 )
    {
      if ( a2 == a3 )
        return 1;
      if ( !--v6 )
        break;
      a2 = *(_QWORD *)(a2 + 32);
      if ( !a2 )
        return 0;
    }
    if ( !a4 )
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_hobject_misc.c", 29, "prototype chain limit", a5, a6);
  }
  else
  {
    return 0;
  }
  return v6;
}

//----- (000000000040DCFB) ----------------------------------------------------
__int64 __fastcall sub_40DCFB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v7; // rsi

  result = a2;
  v7 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 32) = a3;
  if ( a3 )
    ++*(_DWORD *)(a3 + 4);
  if ( v7 )
  {
    if ( (*(_DWORD *)(v7 + 4))-- == 1 )
      return sub_40CFE0(a1, v7, a3, a4, a5, a6);
  }
  return result;
}

//----- (000000000040DD1E) ----------------------------------------------------
__int64 __fastcall sub_40DD1E(unsigned int a1)
{
  __int64 result; // rax

  result = 2LL;
  while ( a1 > 0x3F )
  {
    a1 >>= 6;
    result = (unsigned int)((_DWORD)result << 6);
  }
  while ( a1 )
  {
    a1 >>= 1;
    result = (unsigned int)(2 * result);
  }
  return result;
}

//----- (000000000040DD3B) ----------------------------------------------------
__int64 __fastcall sub_40DD3B(__int64 a1)
{
  __int64 v1; // rdx
  unsigned int v2; // er8

  v1 = 0LL;
  v2 = 0;
  while ( *(_DWORD *)(a1 + 44) > (unsigned int)v1 )
  {
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL * *(unsigned int *)(a1 + 40) + 8 * v1) )
      ++v2;
    ++v1;
  }
  return v2;
}

//----- (000000000040DD65) ----------------------------------------------------
__int64 __fastcall sub_40DD65(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // er9
  int v4; // er8
  __int64 v5; // rcx
  __int64 result; // rax
  int v7; // edi

  v3 = *(_DWORD *)(a1 + 48);
  v4 = 0;
  v5 = 0LL;
  result = *(_QWORD *)(a1 + 24) + 25LL * *(unsigned int *)(a1 + 40) + (-*(_DWORD *)(a1 + 40) & 7);
  v7 = -1;
  while ( v3 > (unsigned int)v5 )
  {
    if ( *(_DWORD *)(result + 16 * v5) != 7 )
    {
      ++v4;
      v7 = v5;
    }
    ++v5;
  }
  *a2 = v4;
  *a3 = v7 + 1;
  return result;
}

//----- (000000000040DDAB) ----------------------------------------------------
__int64 __fastcall sub_40DDAB(double a1)
{
  unsigned int v1; // er12

  v1 = (int)a1;
  if ( !sub_41D67C((double)(int)a1, a1) )
    return (unsigned int)-1;
  return v1;
}

//----- (000000000040DDDC) ----------------------------------------------------
__int64 __fastcall sub_40DDDC(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  unsigned int v5; // er12
  __m128 v6; // xmm0

  if ( *(_DWORD *)a2 )
  {
    *(double *)a3.i64 = sub_417910(a1, a2, a3, a4);
    a4 = a3;
  }
  else
  {
    a4.i64[0] = *(__int64 *)(a2 + 8);
  }
  v6 = sub_41D2F2(*(double *)a4.i64);
  v5 = v4;
  *(double *)v6.i64 = (double)v4;
  if ( !sub_41D67C((double)v4, *(double *)a4.i64) )
  {
    v5 = 0;
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 3199, "invalid array length", v6, a4);
  }
  return v5;
}
// 40DE0C: variable 'v4' is possibly undefined
// 41D2F2: using guessed type __m128 __fastcall sub_41D2F2(double);

//----- (000000000040DE49) ----------------------------------------------------
__int64 __fastcall sub_40DE49(__int64 *a1, __int64 *a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rax

  v4 = a1[14];
  if ( *(_DWORD *)(v4 - 16) == 8 )
    v5 = *(_QWORD *)(v4 - 8);
  else
    v5 = sub_4089B9(a1, -1, a3, a4);
  *a2 = v5;
  return *(unsigned int *)(v5 + 20);
}

//----- (000000000040DE74) ----------------------------------------------------
__int64 __fastcall sub_40DE74(__int64 *a1, __int128 *a2, __int64 *a3, __m128 a4, __m128 a5)
{
  sub_406883(a1, a2, a4, a5);
  return sub_40DE49(a1, a3, a4, a5);
}

//----- (000000000040DE9A) ----------------------------------------------------
__int64 __fastcall sub_40DE9A(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 result; // rax

  result = *(_DWORD *)a1 & 0x2000000;
  if ( (*(_DWORD *)a1 & 0x2000000) != 0 )
  {
    *a3 = *(_QWORD *)(a1 + 64);
    *a2 = *(_QWORD *)(a1 + 56);
    return 1LL;
  }
  return result;
}

//----- (000000000040DEB7) ----------------------------------------------------
__int64 __fastcall sub_40DEB7(__int64 *a1, __int64 a2, int a3, __int64 a4, _QWORD *a5, __m128 a6, __m128 a7)
{
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13[3]; // [rsp+18h] [rbp-18h] BYREF

  result = sub_40DE9A(a2, a5, v13);
  if ( (_DWORD)result )
  {
    if ( *(_DWORD *)v9 != 8 || (result = 0LL, (**(_DWORD **)(v9 + 8) & 0x400) == 0) )
    {
      sub_404E3A(a1, 20, a6, a7);
      sub_407C45(a1, v13[0], a6, a7);
      v10 = (unsigned int)(a3 - 0x10000);
      if ( (unsigned int)sub_4037B9(a1, v10, a6, a7) )
      {
        sub_40500F(a1, -2);
        return 1LL;
      }
      else
      {
        sub_407DE7((__int64)a1, v10, v11, v12, a6, a7);
        return 0LL;
      }
    }
  }
  return result;
}
// 40DEDA: variable 'v9' is possibly undefined
// 40DF32: variable 'v11' is possibly undefined
// 40DF32: variable 'v12' is possibly undefined
// 40DEB7: using guessed type __int64 var_18[3];

//----- (000000000040DF43) ----------------------------------------------------
__int64 __fastcall sub_40DF43(__int64 a1)
{
  __int64 result; // rax

  for ( result = a1; _bittest((const signed __int32 *)result, 0x19u); result = *(_QWORD *)(result + 56) )
    ;
  return result;
}

//----- (000000000040DF53) ----------------------------------------------------
__int64 __fastcall sub_40DF53(
        _QWORD *a1,
        __int64 a2,
        unsigned int a3,
        unsigned int a4,
        unsigned int a5,
        int a6,
        __m128 a7,
        __m128 a8)
{
  unsigned int v8; // eax
  int v10; // edx
  __int64 v11; // rdi
  __int64 v13; // r13
  int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // ebx
  __m128 *v17; // r12
  __int64 v18; // rax
  __int64 v19; // rdx
  unsigned int i; // edx
  __int64 v21; // rax
  __int64 v22; // r9
  __int64 v23; // rcx
  __int64 v24; // rdi
  unsigned int v25; // esi
  __int64 v26; // r8
  unsigned __int64 v27; // rdx
  __int64 v28; // rdi
  __int64 v29; // rdx
  _DWORD *v30; // rax
  __int64 v31; // rdi
  __int64 v32; // rax
  int v33; // ecx
  unsigned int j; // edx
  _DWORD *v35; // rsi
  __int64 result; // rax
  __int64 v37; // rax
  __int64 v38; // [rsp+0h] [rbp-70h]
  __int64 v40; // [rsp+10h] [rbp-60h]
  unsigned int v41; // [rsp+18h] [rbp-58h]
  int v42; // [rsp+1Ch] [rbp-54h]
  __int64 v43; // [rsp+28h] [rbp-48h]
  unsigned int v44; // [rsp+30h] [rbp-40h]

  v8 = a4 + a3;
  v10 = 707;
  if ( v8 > 0x3FFFFFFF )
    return sub_401CC7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", v10, a7, a8);
  v11 = a1[8];
  v13 = 0LL;
  v14 = *(_DWORD *)(v11 + 96);
  ++*(_DWORD *)(v11 + 108);
  v42 = v14;
  *(_DWORD *)(v11 + 96) = v14 | 4;
  v41 = -a3 & 7;
  v15 = v41 + 25 * a3 + 16 * a4 + 4 * a5;
  if ( v15 )
  {
    v13 = sub_402F19(v11, v15, a7, a8);
    if ( !v13 )
    {
LABEL_35:
      sub_403142(a1[8]);
      v37 = a1[8];
      v10 = 1063;
      --*(_DWORD *)(v37 + 108);
      *(_DWORD *)(v37 + 96) = v42;
      return sub_401CC7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", v10, a7, a8);
    }
  }
  v43 = v13 + 16LL * a3;
  v16 = 0;
  v40 = v43 + 8LL * a3;
  if ( a6 )
  {
    v44 = 0;
    v16 = 0;
    while ( *(_DWORD *)(a2 + 48) > v44 )
    {
      v17 = (__m128 *)(*(_QWORD *)(a2 + 24)
                     + (-*(_DWORD *)(a2 + 40) & 7)
                     + 25LL * *(unsigned int *)(a2 + 40)
                     + 16LL * v44);
      if ( v17->i32[0] != 7 )
      {
        if ( !(unsigned int)sub_404E0C(a1, 1, a7, a8) )
          goto LABEL_35;
        v18 = sub_40D302(a1[8], v44, a7, a8);
        if ( !v18 )
          goto LABEL_35;
        v38 = v18;
        sub_407808(a1, v18, a7, a8);
        v19 = v16++;
        *(_QWORD *)(v43 + 8 * v19) = v38;
        a7 = *v17;
        *(__m128 *)(v13 + 16 * v19) = *v17;
        *(_BYTE *)(v40 + v19) = 7;
      }
      ++v44;
    }
    sub_407D4A((__int64)a1, v16);
  }
  for ( i = 0; ; ++i )
  {
    v21 = *(unsigned int *)(a2 + 40);
    v22 = *(_QWORD *)(a2 + 24);
    if ( *(_DWORD *)(a2 + 44) <= i )
      break;
    v23 = *(_QWORD *)(v22 + 16 * v21 + 8LL * i);
    if ( v23 )
    {
      v24 = v16++;
      *(_QWORD *)(v43 + 8 * v24) = v23;
      *(_OWORD *)(v13 + 16 * v24) = *(_OWORD *)(v22 + 16LL * i);
      *(_BYTE *)(v40 + v24) = *(_BYTE *)(24 * v21 + v22 + i);
    }
  }
  v25 = *(_DWORD *)(a2 + 48);
  v26 = 16LL * a4;
  v27 = v26;
  if ( v25 < a4 )
    v27 = 16LL * v25;
  v28 = v40 + a3 + (unsigned __int64)v41;
  if ( v27 )
    sub_43AAA0(v28, v22 + 25 * v21 + (-*(_DWORD *)(a2 + 40) & 7), v27);
  v29 = *(unsigned int *)(a2 + 48);
  v30 = (_DWORD *)(v28 + 16 * v29);
  while ( (unsigned int)v29 < a4 )
  {
    *v30 = 7;
    LODWORD(v29) = v29 + 1;
    v30 += 4;
  }
  if ( a5 )
  {
    v31 = v26 + v28;
    sub_43ABE2(v31, 255LL, 4LL * a5);
    while ( v16 > (unsigned int)v32 )
    {
      for ( j = v33 & *(_DWORD *)(*(_QWORD *)(v43 + 8 * v32) + 16LL); ; j = v33 & (j + 1) )
      {
        v35 = (_DWORD *)(v31 + 4LL * j);
        if ( *v35 == -1 )
          break;
      }
      *v35 = v32++;
    }
  }
  sub_403142(a1[8]);
  *(_QWORD *)(a2 + 24) = v13;
  *(_DWORD *)(a2 + 44) = v16;
  *(_DWORD *)(a2 + 40) = a3;
  *(_DWORD *)(a2 + 48) = a4;
  *(_DWORD *)(a2 + 52) = a5;
  if ( a6 )
    *(_DWORD *)a2 &= ~0x8000u;
  result = a1[8];
  --*(_DWORD *)(result + 108);
  *(_DWORD *)(result + 96) = v42;
  return result;
}
// 40E1C1: variable 'v26' is possibly undefined
// 40E1DC: variable 'v32' is possibly undefined
// 40E1EB: variable 'v33' is possibly undefined

//----- (000000000040E25B) ----------------------------------------------------
__int64 __fastcall sub_40E25B(_QWORD *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // er11
  unsigned int v5; // eax
  unsigned int v6; // edx
  _BOOL4 v7; // ecx
  unsigned int v8; // er8
  __int64 v10; // [rsp+0h] [rbp-20h]
  int v11; // [rsp+8h] [rbp-18h] BYREF
  int v12[5]; // [rsp+Ch] [rbp-14h] BYREF

  sub_40DD3B(a2);
  sub_40DD65(a2, &v11, v12);
  v5 = (unsigned int)(v4 + v11 + 16) >> 3;
  v6 = v5 + v4 + v11;
  v7 = __CFADD__(v5, v4 + v11);
  v8 = 0;
  if ( v6 > 7 )
    v8 = sub_40DD1E(v6);
  if ( v7 )
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 1229, a3, a4);
  else
    sub_40DF53(a1, a2, v6, 0, v8, 1, a3, a4);
  return v10;
}
// 40E28A: variable 'v4' is possibly undefined
// 40E2AC: variable 'v7' is possibly undefined
// 40E2D0: variable 'v6' is possibly undefined
// 40E2D5: variable 'v10' is possibly undefined
// 40E25B: using guessed type int var_14[5];

//----- (000000000040E2DD) ----------------------------------------------------
__int64 __fastcall sub_40E2DD(_QWORD *a1, unsigned int a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // eax
  __int64 v7; // rdx
  unsigned int v8; // edi
  __int64 v9; // rdx
  unsigned int v10; // eax
  __int64 *v11; // r11
  unsigned int v12; // ecx
  unsigned int v14; // [rsp+8h] [rbp-28h] BYREF
  int v15[9]; // [rsp+Ch] [rbp-24h] BYREF

  v6 = *(_DWORD *)(a3 + 48);
  if ( v6 <= a2 )
  {
    v11 = a1;
    if ( a2 + 1 > 0x100 && a2 > 9 * ((v6 + 7) >> 3) )
    {
      sub_40DD65(a3, &v14, v15);
      if ( v14 < 2 * (a2 >> 3) )
      {
        sub_40E25B(v11, a3, a4, a5);
        return 0LL;
      }
    }
    v12 = a2 + ((a2 + 16) >> 3);
    if ( a2 + 1 <= v12 )
      sub_40DF53(v11, a3, *(_DWORD *)(a3 + 40), v12, *(_DWORD *)(a3 + 52), 0, a4, a5);
    else
      sub_401CC7(v11, (__int64)"third_party/duktape/duk_hobject_props.c", 1174, a4, a5);
    v10 = *(_DWORD *)(a3 + 40);
    v9 = 25LL * v10 + 16LL * a2;
  }
  else
  {
    v7 = *(unsigned int *)(a3 + 40);
    v8 = v7;
    v9 = 25 * v7 + 16LL * a2;
    v10 = v8;
  }
  return *(_QWORD *)(a3 + 24) + v9 + (-v10 & 7);
}
// 40E348: variable 'v11' is possibly undefined
// 40E2DD: using guessed type int var_24[9];

//----- (000000000040E3BE) ----------------------------------------------------
__int64 __fastcall sub_40E3BE(__int64 a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  int v7; // eax
  __int64 *v8; // r10
  unsigned int v9; // er8
  unsigned int v10; // ecx
  unsigned int v11; // edx
  __int64 v12; // rdi
  __int64 v13; // rcx
  __int64 v14; // rsi
  int v15; // eax
  unsigned int v16; // er8
  __int64 v17; // rdx
  int v18; // ecx
  int v19; // ecx
  __int64 v20; // rax
  unsigned int i; // edx
  unsigned int *v22; // rdi

  if ( *(_DWORD *)(a2 + 44) >= *(_DWORD *)(a2 + 40) )
  {
    v7 = sub_40DD3B(a2);
    v9 = 0;
    v10 = v7 + 1;
    v11 = v7 + ((unsigned int)(v7 + 16) >> 3);
    if ( v11 > 7 )
      v9 = sub_40DD1E(v11);
    if ( v10 <= v11 )
      sub_40DF53(v8, a2, v11, *(_DWORD *)(a2 + 48), v9, 0, a4, a5);
    else
      sub_401CC7(v8, (__int64)"third_party/duktape/duk_hobject_props.c", 1137, a4, a5);
  }
  v12 = *(unsigned int *)(a2 + 40);
  v13 = *(unsigned int *)(a2 + 44);
  v14 = *(_QWORD *)(a2 + 24);
  v15 = v13 + 1;
  v16 = *(_DWORD *)(a2 + 44);
  v17 = 16LL * *(unsigned int *)(a2 + 40) + 8 * v13;
  v18 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 44) = v15;
  *(_QWORD *)(v14 + v17) = a3;
  ++*(_DWORD *)(a3 + 4);
  if ( v18 )
  {
    v19 = v18 - 1;
    v20 = 25 * v12 + 16LL * *(unsigned int *)(a2 + 48) + (-(int)v12 & 7);
    for ( i = v19 & *(_DWORD *)(a3 + 16); ; i = v19 & (i + 1) )
    {
      v22 = (unsigned int *)(v14 + v20 + 4LL * i);
      if ( *v22 > 0xFFFFFFFD )
        break;
    }
    *v22 = v16;
  }
  return v16;
}
// 40E3FD: variable 'v10' is possibly undefined
// 40E3FD: variable 'v11' is possibly undefined
// 40E40C: variable 'v8' is possibly undefined

//----- (000000000040E495) ----------------------------------------------------
__int64 __fastcall sub_40E495(_QWORD *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  _QWORD *v5; // r10
  unsigned int v6; // er8

  v5 = a1;
  if ( *(_DWORD *)(a2 + 40) >= a3 )
    a3 = *(_DWORD *)(a2 + 40);
  v6 = 0;
  if ( a3 > 7 )
    v6 = sub_40DD1E(a3);
  return sub_40DF53(v5, a2, a3, *(_DWORD *)(a2 + 48), v6, 0, a4, a5);
}
// 40E4BF: variable 'v5' is possibly undefined
// 40E4BF: variable 'a3' is possibly undefined

//----- (000000000040E4C4) ----------------------------------------------------
__int64 __fastcall sub_40E4C4(_QWORD *a1, __int64 a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er11
  int v5; // er9
  unsigned int v6; // er8
  __int64 v8; // [rsp+0h] [rbp-20h]
  unsigned int v9; // [rsp+8h] [rbp-18h] BYREF
  int v10[5]; // [rsp+Ch] [rbp-14h] BYREF

  sub_40DD3B(a2);
  sub_40DD65(a2, v10, &v9);
  v5 = 0;
  if ( v10[0] < 2 * (v9 >> 3) )
  {
    v4 += v10[0];
    v9 = 0;
    v5 = 1;
  }
  v6 = 0;
  if ( v4 > 7 )
    v6 = sub_40DD1E(v4);
  sub_40DF53(a1, a2, v4, v9, v6, v5, a3, a4);
  return v8;
}
// 40E500: variable 'v4' is possibly undefined
// 40E530: variable 'v5' is possibly undefined
// 40E535: variable 'v8' is possibly undefined
// 40E4C4: using guessed type unsigned int var_14[5];

//----- (000000000040E53D) ----------------------------------------------------
__int64 __fastcall sub_40E53D(__int64 a1, __int64 a2, __int64 a3, unsigned int *a4, unsigned int *a5)
{
  __int64 result; // rax
  __int64 v6; // r10
  __int64 v7; // r9
  unsigned int v8; // edi
  __int64 v9; // r9
  __int64 j; // rsi
  int v11; // eax
  __int64 v12; // rsi
  unsigned int i; // edi
  unsigned int v14; // er11

  result = *(unsigned int *)(a2 + 52);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = 16LL * *(unsigned int *)(a2 + 40);
  if ( (_DWORD)result )
  {
    v11 = result - 1;
    v12 = (-*(_DWORD *)(a2 + 40) & 7) + 25LL * *(unsigned int *)(a2 + 40) + 16LL * *(unsigned int *)(a2 + 48);
    for ( i = v11 & *(_DWORD *)(a3 + 16); ; i = v11 & (i + 1) )
    {
      v14 = *(_DWORD *)(v6 + 4LL * i + v12);
      if ( v14 == -1 )
        break;
      if ( v14 != -2 && *(_QWORD *)(v6 + 8LL * v14 + v7) == a3 )
      {
        *a4 = v14;
        result = 1LL;
        *a5 = i;
        return result;
      }
    }
    return 0LL;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 44);
    v9 = v6 + v7;
    for ( j = 0LL; v8 > (unsigned int)j; ++j )
    {
      if ( *(_QWORD *)(v9 + 8 * j) == a3 )
      {
        *a4 = j;
        result = 1LL;
        *a5 = -1;
        return result;
      }
    }
  }
  return result;
}

//----- (000000000040E5DF) ----------------------------------------------------
__int64 __fastcall sub_40E5DF(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  __int64 v4; // r8
  __int64 v5; // rcx
  int v7; // [rsp+8h] [rbp-18h] BYREF
  int v8[5]; // [rsp+Ch] [rbp-14h] BYREF

  v3 = sub_40E53D(a1, a2, a3, (unsigned int *)&v7, (unsigned int *)v8);
  v4 = 0LL;
  if ( v3 )
  {
    v5 = *(_QWORD *)(a2 + 24);
    if ( (*(_BYTE *)(v5 + 24LL * *(unsigned int *)(a2 + 40) + v7) & 8) == 0 )
      return v5 + 16LL * v7;
  }
  return v4;
}
// 40E5DF: using guessed type unsigned int var_14[5];

//----- (000000000040E629) ----------------------------------------------------
__int64 __fastcall sub_40E629(__int64 a1, __int64 a2, unsigned int a3)
{
  return sub_40E5DF(a1, a2, *(_QWORD *)(a1 + 8LL * a3 + 4424));
}

//----- (000000000040E635) ----------------------------------------------------
__int64 __fastcall sub_40E635(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  int v5; // eax
  __int64 v6; // r8
  __int64 v7; // rcx
  int v8; // edx
  __int64 v9; // rax
  int v11; // [rsp+8h] [rbp-18h] BYREF
  int v12[5]; // [rsp+Ch] [rbp-14h] BYREF

  v5 = sub_40E53D(a1, a2, a3, (unsigned int *)&v11, (unsigned int *)v12);
  v6 = 0LL;
  if ( v5 )
  {
    v7 = *(_QWORD *)(a2 + 24);
    v8 = *(unsigned __int8 *)(v7 + 24LL * *(unsigned int *)(a2 + 40) + v11);
    if ( (v8 & 8) == 0 )
    {
      v9 = 16LL * v11;
      *a4 = v8;
      return v7 + v9;
    }
  }
  return v6;
}
// 40E635: using guessed type unsigned int var_14[5];

//----- (000000000040E68B) ----------------------------------------------------
__int64 __fastcall sub_40E68B(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax

  result = 0LL;
  if ( _bittest((const signed __int32 *)a2, 0xFu) )
  {
    if ( *(_DWORD *)(a2 + 48) > a3 )
      return *(_QWORD *)(a2 + 24) + 25LL * *(unsigned int *)(a2 + 40) + 16LL * a3 + (-*(_DWORD *)(a2 + 40) & 7);
  }
  return result;
}

//----- (000000000040E6B8) ----------------------------------------------------
__int64 __fastcall sub_40E6B8(__int64 a1, __int64 a2)
{
  return sub_40E629(a1, a2, 0x6Au);
}

//----- (000000000040E6C2) ----------------------------------------------------
__int64 __fastcall sub_40E6C2(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_40E6B8(a1, a2);
  if ( result )
    return *(_QWORD *)(result + 8);
  return result;
}

//----- (000000000040E6D6) ----------------------------------------------------
__int64 __fastcall sub_40E6D6(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_40E629(*(_QWORD *)(a1 + 64), a2, 0x63u);
  if ( result )
  {
    if ( *(_DWORD *)result == 9 )
      return *(_QWORD *)(result + 8);
    else
      return 0LL;
  }
  return result;
}

//----- (000000000040E6FC) ----------------------------------------------------
__int64 __fastcall sub_40E6FC(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = sub_40E629(*(_QWORD *)(a1 + 64), a2, 0x64u);
  if ( result )
  {
    if ( *(_DWORD *)result == 9 )
      return *(_QWORD *)(result + 8);
    else
      return 0LL;
  }
  return result;
}

//----- (000000000040E722) ----------------------------------------------------
__int64 __fastcall sub_40E722(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, char a5, __m128 a6, __m128 a7)
{
  return sub_40E863(a1, a2, a3, *(_DWORD *)(a3 + 20), a4, a5, a6, a7);
}

//----- (000000000040E733) ----------------------------------------------------
__int64 __fastcall sub_40E733(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 *a5,
        __int64 *a6,
        __m128 a7,
        __m128 a8)
{
  __int64 v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r12
  __int64 v15; // rdx
  __int64 v16; // rcx

  if ( !(unsigned int)sub_40E722(a1, a2, *(_QWORD *)(a1[71] + 824), a4, 1, a7, a8) )
    return 0LL;
  v11 = sub_40582D(a1, -1, a7, a8);
  sub_407DA1((__int64)a1, 0xFFFFFFFFLL, v12, v13, a7, a8);
  if ( !(unsigned int)sub_40E722(a1, v11, a3, a4, 1, a7, a8) )
    return 0LL;
  sub_40E722(a1, a2, *(_QWORD *)(a1[71] + 832), a4, 1, a7, a8);
  v14 = sub_40582D(a1, -1, a7, a8);
  sub_407DA1((__int64)a1, 0xFFFFFFFFLL, v15, v16, a7, a8);
  *a5 = v11;
  *a6 = v14;
  return 1LL;
}
// 40E78A: variable 'v12' is possibly undefined
// 40E78A: variable 'v13' is possibly undefined
// 40E7DD: variable 'v15' is possibly undefined
// 40E7DD: variable 'v16' is possibly undefined

//----- (000000000040E804) ----------------------------------------------------
__int64 __fastcall sub_40E804(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v7; // r13
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // [rsp+0h] [rbp-20h] BYREF
  __int64 v14[3]; // [rsp+8h] [rbp-18h] BYREF

  result = sub_40E733(a1, a2, a3, a4, &v13, v14, a5, a6);
  if ( (_DWORD)result )
  {
    v7 = sub_40574F(a1, -1, a5, a6);
    sub_407DA1((__int64)a1, 0xFFFFFFFFLL, v8, v9, a5, a6);
    v10 = v14[0];
    sub_418885(a1, v14[0], v7, 1u, a5, a6);
    sub_407DA1((__int64)a1, v10, v11, v12, a5, a6);
    return 1LL;
  }
  return result;
}
// 40E835: variable 'v8' is possibly undefined
// 40E835: variable 'v9' is possibly undefined
// 40E851: variable 'v11' is possibly undefined
// 40E851: variable 'v12' is possibly undefined
// 40E804: using guessed type __int64 var_18[3];

//----- (000000000040E863) ----------------------------------------------------
__int64 __fastcall sub_40E863(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        char a6,
        __m128 a7,
        __m128 a8)
{
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rsi
  int v16; // ecx
  __int64 v17; // rsi
  __int64 v18; // rdx
  signed __int32 v19; // ecx
  unsigned int v20; // er8
  __int128 *v21; // rsi
  bool v22; // zf
  __int64 v23; // rsi
  __int64 v24; // rax
  __int64 v25; // rdx
  int v26; // ecx
  __int64 v27; // r15
  unsigned __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rdx
  int v31; // ecx
  __int64 v32; // rdi
  int v33; // esi
  char v34; // cl
  __int64 v35; // rsi
  __int64 v36; // r12
  unsigned int v37; // ecx
  __int64 v38; // rax
  __int64 v39; // rdx
  unsigned __int32 v40; // eax
  bool v42; // [rsp+8h] [rbp-68h]
  char v44[88]; // [rsp+18h] [rbp-58h] BYREF

  v42 = a4 != -1;
  if ( (unsigned int)sub_40E53D(a1[8], a2, a3, (unsigned int *)(a5 + 24), (unsigned int *)(a5 + 28)) )
  {
    v13 = *(unsigned int *)(a2 + 40);
    v14 = *(_QWORD *)(a2 + 24);
    v15 = *(int *)(a5 + 24);
    *(_DWORD *)(a5 + 32) = -1;
    v16 = *(unsigned __int8 *)(v14 + 24 * v13 + v15);
    *(_QWORD *)(a5 + 8) = 0LL;
    v17 = v14 + 16 * v15;
    *(_QWORD *)(a5 + 16) = 0LL;
    *(_DWORD *)a5 = v16;
    if ( (v16 & 8) != 0 )
    {
      *(_QWORD *)(a5 + 8) = *(_QWORD *)v17;
      v18 = *(_QWORD *)(v17 + 8);
      *(_QWORD *)(a5 + 16) = v18;
      if ( (a6 & 1) != 0 )
        sub_4068D1(a1, v17, v18, a7, a8);
    }
    else if ( (a6 & 1) != 0 )
    {
      sub_406883(a1, (__int128 *)v17, a7, a8);
    }
    goto LABEL_55;
  }
  v19 = *(_DWORD *)a2;
  v20 = 0;
  if ( (*(_DWORD *)a2 & 0x8000) == 0
    || !v42
    || *(_DWORD *)(a2 + 48) <= a4
    || (v21 = (__int128 *)(*(_QWORD *)(a2 + 24)
                         + 25LL * *(unsigned int *)(a2 + 40)
                         + 16LL * a4
                         + (-*(_BYTE *)(a2 + 40) & 7)),
        *(_DWORD *)v21 == 7) )
  {
    if ( (v19 & 0xC02000) == 0 )
      return v20;
    if ( (v19 & 0x400000) != 0 )
    {
      if ( *(_QWORD *)(a1[71] + 696) != a3 )
        return v20;
      if ( (a6 & 1) != 0 )
        sub_406AAF(a1, *(_DWORD *)(a2 + 56), a7, a8);
      v22 = *(_DWORD *)(a2 + 60) == 0;
      *(_DWORD *)a5 = 16;
      if ( v22 )
        *(_DWORD *)a5 = 17;
      goto LABEL_29;
    }
    if ( (v19 & 0x800000) != 0 )
    {
      if ( a4 != -1 )
      {
        v23 = a2;
        v24 = sub_40E6B8(a1[8], a2);
        v27 = v24;
        if ( v24 )
          v27 = *(_QWORD *)(v24 + 8);
        v28 = sub_40314F(v27, v23, v25, v26);
        v20 = 0;
        if ( a4 >= v28 )
          return v20;
        if ( (a6 & 1) != 0 )
        {
          sub_407808(a1, v27, a7, a8);
          sub_409057(a1, -1, a4, a4 + 1, a7, a8);
        }
        *(_DWORD *)a5 = 18;
LABEL_29:
        *(_QWORD *)(a5 + 8) = 0LL;
        *(_QWORD *)(a5 + 16) = 0LL;
        *(_QWORD *)(a5 + 24) = -1LL;
        *(_DWORD *)(a5 + 32) = -1;
        return 1;
      }
      if ( *(_QWORD *)(a1[71] + 696) != a3 )
        return v20;
      v29 = sub_40E6B8(a1[8], a2);
      v32 = v29;
      if ( v29 )
        v32 = *(_QWORD *)(v29 + 8);
      if ( (a6 & 1) == 0 )
      {
LABEL_37:
        *(_DWORD *)a5 = 16;
        goto LABEL_29;
      }
      v33 = sub_40314F(v32, a2, v30, v31);
    }
    else
    {
      if ( (v19 & 0x2000) == 0 )
        return v20;
      if ( a4 != -1 && *(_BYTE *)(a2 + 82) )
      {
        v34 = *(_BYTE *)(a2 + 80);
        if ( *(_DWORD *)(a2 + 76) >> v34 <= a4 )
          return v20;
        if ( (a6 & 1) != 0 )
        {
          v35 = *(_QWORD *)(a2 + 56);
          if ( v35
            && (v36 = a4 << v34,
                v37 = 1 << v34,
                v38 = *(unsigned int *)(a2 + 72),
                (unsigned __int64)((unsigned int)v38 + (_DWORD)v36 + v37) <= *(_QWORD *)(v35 + 24)) )
          {
            v39 = v35 + 32;
            if ( *(char *)v35 < 0 )
              v39 = *(_QWORD *)(v35 + 32);
            sub_4096D9((__int64)a1, a2, v38 + v36 + v39, v37, a7, a8);
          }
          else
          {
            sub_406AAF(a1, 0, a7, a8);
          }
        }
        v40 = *(_DWORD *)a2;
        *(_DWORD *)a5 = 17;
        if ( v40 >> 27 != 19 )
          *(_DWORD *)a5 = 19;
        goto LABEL_29;
      }
      if ( *(_QWORD *)(a1[71] + 696) != a3 || !*(_BYTE *)(a2 + 82) )
        return v20;
      if ( (a6 & 1) == 0 )
        goto LABEL_37;
      v33 = *(_DWORD *)(a2 + 76) >> *(_BYTE *)(a2 + 80);
    }
    sub_406AAF(a1, v33, a7, a8);
    goto LABEL_37;
  }
  if ( (a6 & 1) != 0 )
    sub_406883(a1, v21, a7, a8);
  *(_DWORD *)a5 = 7;
  *(_QWORD *)(a5 + 8) = 0LL;
  *(_QWORD *)(a5 + 16) = 0LL;
  *(_QWORD *)(a5 + 24) = -1LL;
  *(_DWORD *)(a5 + 32) = a4;
LABEL_55:
  v20 = 1;
  if ( _bittest((const signed __int32 *)a2, 0x18u) && v42 && (a6 & 1) != 0 )
  {
    if ( (unsigned int)sub_40E804(a1, a2, a3, (__int64)v44, a7, a8) )
      sub_405181(a1, a7, a8);
    return 1;
  }
  return v20;
}
// 40EA26: variable 'v25' is possibly undefined
// 40EA26: variable 'v26' is possibly undefined
// 40EABE: variable 'v30' is possibly undefined
// 40EABE: variable 'v31' is possibly undefined
// 40E863: using guessed type char var_58[88];

//----- (000000000040EC01) ----------------------------------------------------
__int64 __fastcall sub_40EC01(__int64 *a1, __int128 *a2, __m128 *a3, __m128 a4)
{
  __int128 v5; // kr00_16
  __m128 v6; // xmm1
  const char *v7; // rax
  __int64 v8; // r13
  __int64 v9; // r13
  __int64 v10; // rdx
  int v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // er14
  __int64 v14; // rcx
  __int64 v15; // rdx
  int v16; // ecx
  unsigned int v17; // eax
  __int128 *v18; // rsi
  unsigned int v19; // eax
  char v20; // cl
  __int64 v21; // rdi
  __int64 v22; // rax
  int v23; // edx
  unsigned int v24; // ecx
  __int64 v25; // rsi
  __int64 v26; // rdx
  unsigned int v27; // eax
  __int64 v28; // rsi
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rsi
  _DWORD *v32; // rbx
  _DWORD *v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rdx
  const char *v36; // rcx
  unsigned int v37; // edx
  __int64 v38; // r13
  __int64 v39; // rsi
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // rax
  unsigned int v43; // er14
  __int64 v44; // rdx
  __int64 v45; // rcx
  int *v46; // rax
  int v47; // eax
  const char *v49; // [rsp+8h] [rbp-98h]
  __int64 v50; // [rsp+18h] [rbp-88h] BYREF
  __int64 v51; // [rsp+20h] [rbp-80h] BYREF
  __int128 v52; // [rsp+28h] [rbp-78h] BYREF
  __m128 v53; // [rsp+38h] [rbp-68h] BYREF
  int v54; // [rsp+48h] [rbp-58h] BYREF
  __int64 v55; // [rsp+50h] [rbp-50h]

  v5 = *a2;
  v6 = *a3;
  v50 = 0LL;
  v52 = v5;
  v53 = v6;
  switch ( (int)v5 )
  {
    case 2:
    case 3:
      v49 = (const char *)sub_408C16(a1, (__int64)&v52, a4, v6);
      v7 = (const char *)sub_408C16(a1, (__int64)&v53, a4, v6);
      sub_401B75(
        a1,
        (__int64)"third_party/duktape/duk_hobject_props.c",
        0x60009F4u,
        "cannot read property %s of %s",
        v7,
        v49);
      return 0;
    case 4:
      v8 = a1[32];
      goto LABEL_67;
    case 5:
      v8 = a1[56];
      goto LABEL_67;
    case 6:
      v8 = a1[26];
      goto LABEL_67;
    case 8:
      v9 = *((_QWORD *)&v52 + 1);
      if ( _bittest(*((const signed __int32 **)&v52 + 1), 9u) )
      {
        v8 = a1[58];
        goto LABEL_67;
      }
      if ( v53.i32[0] )
      {
        a2 = (__int128 *)&v53;
        v13 = 1;
        v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
        if ( v12 == -1 )
          goto LABEL_15;
      }
      else
      {
        a4.i64[0] = v53.i64[1];
        v12 = sub_40DDAB(*(double *)&v53.i64[1]);
        if ( v12 == -1 )
        {
LABEL_8:
          a2 = (__int128 *)&v53;
          v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
          goto LABEL_15;
        }
        v13 = 0;
      }
      if ( v12 < (unsigned __int64)sub_40314F(v9, (__int64)a2, v10, v11) )
      {
        sub_407D45((__int64)a1, (_DWORD *)v13, v10, v14, a4, v6);
        sub_407808(a1, v9, a4, v6);
        sub_409057(a1, -1, v12, v12 + 1, a4, v6);
        return 1;
      }
      if ( !v13 )
        goto LABEL_8;
LABEL_15:
      if ( *(_QWORD *)(a1[71] + 696) != v50 )
      {
        v8 = a1[30];
        goto LABEL_68;
      }
      sub_407DA1((__int64)a1, (__int64)a2, v10, v50, a4, v6);
      LODWORD(a2) = sub_40314F(v9, (__int64)a2, v15, v16);
LABEL_61:
      sub_406AAF(a1, (int)a2, a4, v6);
      return 1;
    case 9:
      v8 = *((_QWORD *)&v52 + 1);
      if ( (**((_DWORD **)&v52 + 1) & 0x380A000) == 0x8000 && !v53.i32[0] )
      {
        a4.i64[0] = v53.i64[1];
        v17 = sub_40DDAB(*(double *)&v53.i64[1]);
        if ( v17 < *(_DWORD *)(*((_QWORD *)&v52 + 1) + 48LL) )
        {
          v18 = (__int128 *)(*(_QWORD *)(*((_QWORD *)&v52 + 1) + 24LL)
                           + (-*(_DWORD *)(*((_QWORD *)&v52 + 1) + 40LL) & 7)
                           + 25LL * *(unsigned int *)(*((_QWORD *)&v52 + 1) + 40LL)
                           + 16LL * v17);
          if ( *(_DWORD *)v18 != 7 )
          {
            sub_406883(a1, v18, a4, v6);
            return 1;
          }
        }
      }
      if ( _bittest(*((const signed __int32 **)&v52 + 1), 0xDu) )
      {
        if ( *(_BYTE *)(*((_QWORD *)&v52 + 1) + 82LL) )
        {
          if ( !v53.i32[0] )
          {
            a4.i64[0] = v53.i64[1];
            v19 = sub_40DDAB(*(double *)&v53.i64[1]);
            v20 = *(_BYTE *)(*((_QWORD *)&v52 + 1) + 80LL);
            if ( v19 < *(_DWORD *)(*((_QWORD *)&v52 + 1) + 76LL) >> v20 )
            {
              v21 = *(_QWORD *)(*((_QWORD *)&v52 + 1) + 56LL);
              v22 = v19 << v20;
              v23 = 1 << v20;
              v24 = 1 << v20;
              if ( !v21
                || (v25 = *(unsigned int *)(*((_QWORD *)&v52 + 1) + 72LL),
                    (unsigned __int64)(unsigned int)(v22 + v23 + v25) > *(_QWORD *)(v21 + 24)) )
              {
                LODWORD(a2) = 0;
                goto LABEL_61;
              }
              v26 = v21 + 32;
              if ( *(char *)v21 < 0 )
                v26 = *(_QWORD *)(v21 + 32);
              sub_4096D9((__int64)a1, *((__int64 *)&v52 + 1), v25 + v22 + v26, v24, a4, v6);
              return 1;
            }
          }
        }
      }
      if ( !_bittest(*((const signed __int32 **)&v52 + 1), 0x19u) )
        goto LABEL_46;
      if ( (unsigned int)sub_40DEB7(a1, *((__int64 *)&v52 + 1), 73, (__int64)&v53, &v51, a4, v6) )
      {
        sub_407C45(a1, v51, a4, v6);
        sub_406883(a1, (__int128 *)&v53, a4, v6);
        sub_406883(a1, &v52, a4, v6);
        sub_41DA64(a1, 3, a4, v6);
        v27 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
        v28 = v51;
        if ( (unsigned int)sub_40E863(a1, v51, v50, v27, (__int64)&v54, 1, a4, v6) )
        {
          v31 = 0xFFFFFFFFLL;
          v32 = (_DWORD *)sub_404A12(a1, -3);
          v33 = (_DWORD *)sub_404A12(a1, -1);
          v34 = 0LL;
          v35 = (__int64)v33;
          if ( (v54 & 0xD) == 0 )
          {
            v31 = (__int64)v32;
            v34 = (unsigned int)sub_417B16(0LL, v32, v33, 1, a4, v6) == 0;
          }
          if ( (v54 & 0xC) == 8 && !v55 && *v32 != 2 || (_DWORD)v34 )
          {
            v36 = "proxy rejected";
            v37 = 100666003;
            goto LABEL_84;
          }
          sub_407DE7((__int64)a1, v31, v35, v34, a4, v6);
        }
        else
        {
          sub_407DA1((__int64)a1, v28, v29, v30, a4, v6);
        }
        return 1;
      }
      v8 = v51;
      LODWORD(v52) = 9;
      *((_QWORD *)&v52 + 1) = v51;
LABEL_46:
      if ( !_bittest((const signed __int32 *)v8, 0x18u) )
      {
LABEL_67:
        v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
        goto LABEL_68;
      }
      v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
      if ( !(unsigned int)sub_40E804(a1, v8, v50, (__int64)&v54, a4, v6) )
        goto LABEL_68;
      goto LABEL_48;
    case 10:
      v38 = *((_QWORD *)&v52 + 1);
      if ( v53.i32[0] )
      {
        v39 = (__int64)&v53;
        v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
        if ( v12 == -1 )
          goto LABEL_59;
        v39 = 1LL;
      }
      else
      {
        a4.i64[0] = v53.i64[1];
        v39 = 0LL;
        v12 = sub_40DDAB(*(double *)&v53.i64[1]);
        if ( v12 == -1 )
        {
LABEL_51:
          v39 = (__int64)&v53;
          v12 = sub_40DE74(a1, (__int128 *)&v53, &v50, a4, v6);
          goto LABEL_59;
        }
      }
      if ( (unsigned __int64)v12 < *(_QWORD *)(v38 + 24) )
      {
        sub_407D45((__int64)a1, (_DWORD *)v39, v40, v41, a4, v6);
        v42 = v38 + 32;
        if ( *(char *)v38 < 0 )
          v42 = *(_QWORD *)(v38 + 32);
        LODWORD(a2) = *(unsigned __int8 *)(v42 + v12);
        goto LABEL_61;
      }
      if ( !(_DWORD)v39 )
        goto LABEL_51;
LABEL_59:
      if ( *(_QWORD *)(a1[71] + 696) == v50 )
      {
        sub_407DA1((__int64)a1, v39, v40, v50, a4, v6);
        a2 = *(__int128 **)(v38 + 24);
        goto LABEL_61;
      }
      v8 = a1[62];
LABEL_68:
      v43 = 10001;
      while ( !(unsigned int)sub_40E863(a1, v8, v50, v12, (__int64)&v54, 1, a4, v6) )
      {
        if ( !--v43 )
        {
          sub_401CE2(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 2899, "prototype chain limit", a4, v6);
          return v43;
        }
        v8 = *(_QWORD *)(v8 + 32);
        if ( !v8 )
        {
          sub_405B55(a1, -1, a4, v6);
          return 0;
        }
      }
      if ( v55 )
      {
        sub_407DA1((__int64)a1, v8, v44, v45, a4, v6);
        sub_407C45(a1, v55, a4, v6);
        sub_406883(a1, &v52, a4, v6);
        sub_404FFB(a1, a4, v6);
        sub_41DA64(a1, 1, a4, v6);
      }
      if ( *(_QWORD *)(a1[71] + 552) != v50
        || (_DWORD)v52 != 9
        || (**((_DWORD **)&v52 + 1) & 0x1001800) == 0
        || (v46 = (int *)sub_405823((__int64)a1, -1)) == 0LL
        || (v47 = *v46, (v47 & 0x1C00) == 0)
        || (v47 & 0x10000) == 0 )
      {
LABEL_48:
        sub_405181(a1, a4, v6);
        return 1;
      }
      v36 = "cannot read strict 'caller'";
      v37 = 100666266;
LABEL_84:
      sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", v37, v36, a4, v6);
      return 0;
    default:
      v8 = a1[34];
      goto LABEL_67;
  }
}
// 40ED0D: variable 'v10' is possibly undefined
// 40ED0D: variable 'v11' is possibly undefined
// 40ED1D: variable 'v14' is possibly undefined
// 40ED6B: variable 'v15' is possibly undefined
// 40ED6B: variable 'v16' is possibly undefined
// 40EF57: variable 'v35' is possibly undefined
// 40EF64: variable 'v29' is possibly undefined
// 40EF64: variable 'v30' is possibly undefined
// 40F024: variable 'v40' is possibly undefined
// 40F024: variable 'v41' is possibly undefined
// 40F106: variable 'v44' is possibly undefined
// 40F106: variable 'v45' is possibly undefined

//----- (000000000040F1DF) ----------------------------------------------------
__int64 __fastcall sub_40F1DF(__int64 *a1, int *a2, __int128 *a3, double a4, __m128 a5)
{
  int v6; // eax
  __int128 v7; // xmm0
  char *v8; // r13
  unsigned int v9; // er15
  __int64 v10; // rsi
  unsigned int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // rdx
  unsigned int v14; // eax
  unsigned int v15; // er14
  __int64 v16; // rbx
  int v17; // er15
  unsigned int v19; // [rsp+Ch] [rbp-84h]
  __int64 v20; // [rsp+18h] [rbp-78h] BYREF
  char *v21; // [rsp+20h] [rbp-70h] BYREF
  __int128 v22; // [rsp+28h] [rbp-68h] BYREF
  char v23[88]; // [rsp+38h] [rbp-58h] BYREF

  v6 = *a2;
  v7 = *a3;
  v22 = *a3;
  switch ( v6 )
  {
    case 9:
      v8 = (char *)*((_QWORD *)a2 + 1);
      v9 = sub_40DE74(a1, &v22, &v20, (__m128)v7, a5);
      goto LABEL_10;
    case 10:
      v10 = (__int64)&v22;
      v11 = sub_40DE74(a1, &v22, &v20, (__m128)v7, a5);
      v13 = v11;
      v9 = v11;
      if ( (unsigned __int64)v11 < *(_QWORD *)(*((_QWORD *)a2 + 1) + 24LL) || v20 == *(_QWORD *)(a1[71] + 696) )
        goto LABEL_24;
      v8 = (char *)a1[62];
LABEL_10:
      if ( _bittest((const signed __int32 *)v8, 0x19u) )
      {
        if ( (unsigned int)sub_40DEB7(a1, (__int64)v8, 74, (__int64)&v22, &v21, (__m128)v7, a5) )
        {
          sub_407C45(a1, (__int64)v21, (__m128)v7, a5);
          sub_406883(a1, &v22, (__m128)v7, a5);
          v10 = 2LL;
          sub_41DA64(a1, 2, (__m128)v7, a5);
          v15 = sub_405C10(a1, (__m128)v7, a5);
          if ( !v15 )
          {
            v10 = (__int64)v21;
            if ( (unsigned int)sub_40E863(a1, (__int64)v21, v20, v9, (__int64)v23, 0, (__m128)v7, a5) )
            {
              if ( (v23[0] & 4) == 0 || *v21 >= 0 )
              {
                sub_401C42(
                  a1,
                  (__int64)"third_party/duktape/duk_hobject_props.c",
                  0x6000C15u,
                  "proxy rejected",
                  (__m128)v7,
                  a5);
                return v15;
              }
            }
          }
LABEL_25:
          sub_407DA1((__int64)a1, v10, v13, v12, (__m128)v7, a5);
          return v15;
        }
        v8 = v21;
      }
      v16 = v20;
      v17 = 10001;
      LODWORD(v12) = *(_DWORD *)(v20 + 20);
      while ( 1 )
      {
        v10 = (__int64)v8;
        v19 = v12;
        v15 = sub_40E863(a1, (__int64)v8, v16, v12, (__int64)v23, 0, (__m128)v7, a5);
        if ( v15 )
          break;
        --v17;
        v12 = v19;
        if ( !v17 )
        {
          v10 = (__int64)"third_party/duktape/duk_hobject_props.c";
          sub_401CE2(
            a1,
            (__int64)"third_party/duktape/duk_hobject_props.c",
            2214,
            "prototype chain limit",
            (__m128)v7,
            a5);
          goto LABEL_25;
        }
        v8 = (char *)*((_QWORD *)v8 + 4);
        if ( !v8 )
          goto LABEL_25;
      }
LABEL_24:
      v15 = 1;
      goto LABEL_25;
    case 6:
      v14 = sub_40DE74(a1, &v22, &v20, (__m128)v7, a5);
      v8 = (char *)a1[26];
      v9 = v14;
      goto LABEL_10;
  }
  v15 = 0;
  sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 0x6000BE9u, "invalid base value", (__m128)v7, a5);
  return v15;
}
// 40F3BC: variable 'v13' is possibly undefined
// 40F3BC: variable 'v12' is possibly undefined

//----- (000000000040F3D3) ----------------------------------------------------
__int64 __fastcall sub_40F3D3(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // er12
  unsigned int v8; // er15
  char v10[88]; // [rsp+8h] [rbp-58h] BYREF

  v6 = 10001;
  v8 = *(_DWORD *)(a3 + 20);
  while ( !(unsigned int)sub_40E863(a1, a2, a3, v8, (__int64)v10, 2, a4, a5) )
  {
    if ( !--v6 )
      return v6;
    a2 = *(_QWORD *)(a2 + 32);
    if ( !a2 )
      return 0;
  }
  return 1;
}
// 40F3D3: using guessed type char var_58[88];

//----- (000000000040F441) ----------------------------------------------------
__int64 __fastcall sub_40F441(__int64 *a1, __int64 a2, __int64 a3, char a4, __m128 a5, __m128 a6)
{
  unsigned int v9; // ebx
  __int64 v10; // rcx
  unsigned int *v11; // rax
  _DWORD *v12; // rsi
  __int64 v13; // rdx
  bool v14; // zf
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rsi
  __int64 v20; // rax
  _DWORD *v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // r13
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 result; // rax
  char v28[24]; // [rsp+8h] [rbp-58h] BYREF
  int v29; // [rsp+20h] [rbp-40h]
  int v30; // [rsp+24h] [rbp-3Ch]
  int v31; // [rsp+28h] [rbp-38h]

  v9 = *(_DWORD *)(a3 + 20);
  if ( (unsigned int)sub_40E863(a1, a2, a3, v9, (__int64)v28, 0, a5, a6) )
  {
    if ( !(a4 & 2 | v28[0] & 4) )
      goto LABEL_29;
    if ( v31 >= 0 )
    {
      v10 = 25LL * *(unsigned int *)(a2 + 40);
      v11 = (unsigned int *)(*(_QWORD *)(a2 + 24) + v10 + 16LL * v31 + (-*(_DWORD *)(a2 + 40) & 7));
      v13 = *v11;
      v12 = (_DWORD *)*((_QWORD *)v11 + 1);
      *v11 = 7;
      LOBYTE(v13) = v13 & 8;
      if ( (_BYTE)v13 )
      {
        v14 = v12[1]-- == 1;
        if ( v14 )
          sub_40CFCD((__int64)a1, v12, v13, v10, a5, a6);
      }
    }
    else
    {
      if ( v29 < 0 )
      {
LABEL_29:
        result = a4 & 1;
        if ( (a4 & 1) != 0 )
        {
          sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 0x6001198u, "not configurable", a5, a6);
          return 0LL;
        }
        return result;
      }
      v15 = *(_QWORD *)(a2 + 24);
      if ( v30 >= 0 )
        *(_DWORD *)(v15
                  + 25LL * *(unsigned int *)(a2 + 40)
                  + 16LL * *(unsigned int *)(a2 + 48)
                  + 4LL * v30
                  + (-*(_DWORD *)(a2 + 40) & 7)) = -2;
      v16 = 24LL * *(unsigned int *)(a2 + 40);
      v17 = (__int64 *)(v15 + 16LL * v29);
      v18 = v16 + v15;
      if ( (*(_BYTE *)(v18 + v29) & 8) != 0 )
      {
        v19 = *v17;
        *v17 = 0LL;
        if ( v19 )
        {
          v14 = (*(_DWORD *)(v19 + 4))-- == 1;
          if ( v14 )
            sub_40CAE2((__int64)a1, v19, v18, v16, a5, a6);
        }
        v20 = *(_QWORD *)(a2 + 24) + 16LL * v29;
        v21 = *(_DWORD **)(v20 + 8);
        *(_QWORD *)(v20 + 8) = 0LL;
        if ( v21 )
        {
          v14 = v21[1]-- == 1;
          if ( v14 )
            sub_40CAE2((__int64)a1, (__int64)v21, v18, v16, a5, a6);
        }
      }
      else
      {
        v22 = *(unsigned int *)v17;
        v21 = (_DWORD *)v17[1];
        *(_DWORD *)v17 = 2;
        LOBYTE(v22) = v22 & 8;
        if ( (_BYTE)v22 )
        {
          v14 = v21[1]-- == 1;
          if ( v14 )
            sub_40CFD5((__int64)a1, v21, v22, v16, a5, a6);
        }
      }
      v23 = v29;
      *(_QWORD *)(*(_QWORD *)(a2 + 24) + 16LL * *(unsigned int *)(a2 + 40) + 8LL * v29) = 0LL;
      v14 = (*(_DWORD *)(a3 + 4))-- == 1;
      if ( v14 )
      {
        v21 = (_DWORD *)a3;
        sub_40CA67((__int64)a1, a3);
      }
      sub_40CA54((__int64)a1, (__int64)v21, v23, v16, a5, a6);
    }
  }
  if ( v9 != -1
    && _bittest((const signed __int32 *)a2, 0x18u)
    && (unsigned int)sub_40E722(a1, a2, *(_QWORD *)(a1[71] + 824), (__int64)v28, 1, a5, a6) )
  {
    v24 = sub_40582D(a1, -1, a5, a6);
    sub_407DA1((__int64)a1, 0xFFFFFFFFLL, v25, v26, a5, a6);
    sub_40F441(a1, v24, a3, 0, a5, a6);
  }
  return 1LL;
}
// 40F57F: variable 'v18' is possibly undefined
// 40F57F: variable 'v16' is possibly undefined
// 40F5D3: variable 'v23' is possibly undefined
// 40F61D: variable 'v25' is possibly undefined
// 40F61D: variable 'v26' is possibly undefined
// 40F441: using guessed type _BYTE var_58[24];

//----- (000000000040F669) ----------------------------------------------------
_BOOL8 __fastcall sub_40F669(
        __int64 *a1,
        __int64 a2,
        unsigned int a3,
        unsigned int a4,
        int a5,
        unsigned int *a6,
        __m128 a7,
        __m128 a8)
{
  unsigned int v12; // er15
  unsigned int v13; // er15
  __int64 v14; // rcx
  unsigned int *v15; // rax
  _DWORD *v16; // rsi
  __int64 v17; // rdx
  unsigned int v20; // er9
  unsigned int v21; // edi
  __int64 i; // rax
  __int64 v23; // rdx
  __int64 v24; // rsi
  unsigned int v25; // esi
  int v26; // ecx
  __int64 v27; // rdx
  unsigned int v28; // [rsp+8h] [rbp-38h]
  int v29; // [rsp+Ch] [rbp-34h]

  v12 = *(_DWORD *)a2 & 0x8000;
  if ( v12 )
  {
    if ( *(_DWORD *)(a2 + 48) <= a3 )
      a3 = *(_DWORD *)(a2 + 48);
    v13 = a3;
    while ( v13 > a4 )
    {
      --v13;
      v14 = (-*(_DWORD *)(a2 + 40) & 7) + 25LL * *(unsigned int *)(a2 + 40);
      v15 = (unsigned int *)(*(_QWORD *)(a2 + 24) + v14 + 16LL * v13);
      v17 = *v15;
      v16 = (_DWORD *)*((_QWORD *)v15 + 1);
      *v15 = 7;
      LOBYTE(v17) = v17 & 8;
      if ( (_BYTE)v17 )
      {
        if ( v16[1]-- == 1 )
          sub_40CFCD((__int64)a1, v16, v17, v14, a7, a8);
      }
    }
    *a6 = a4;
    return 1LL;
  }
  else
  {
    v20 = a4;
    if ( !a5 )
    {
      v21 = *(_DWORD *)(a2 + 44);
      for ( i = 0LL; v21 > (unsigned int)i; ++i )
      {
        v23 = *(_QWORD *)(a2 + 24);
        v24 = *(_QWORD *)(v23 + 16LL * *(unsigned int *)(a2 + 40) + 8 * i);
        if ( v24 )
        {
          if ( _bittest((const signed __int32 *)v24, 8u) )
          {
            v25 = *(_DWORD *)(v24 + 20);
            if ( a4 <= v25 && (*(_BYTE *)(24LL * *(unsigned int *)(a2 + 40) + v23 + i) & 4) == 0 && v20 <= v25 )
              v20 = v25 + 1;
          }
        }
      }
    }
    v26 = a5 != 0 ? 2 : 0;
    while ( *(_DWORD *)(a2 + 44) > v12 )
    {
      v27 = *(_QWORD *)(*(_QWORD *)(a2 + 24) + 16LL * *(unsigned int *)(a2 + 40) + 8LL * v12);
      if ( v27 && _bittest((const signed __int32 *)v27, 8u) && v20 <= *(_DWORD *)(v27 + 20) )
      {
        v28 = v20;
        v29 = v26;
        sub_40F441(a1, a2, v27, v26, a7, a8);
        v20 = v28;
        v26 = v29;
      }
      ++v12;
    }
    *a6 = v20;
    return v20 == a4;
  }
}

//----- (000000000040F7B6) ----------------------------------------------------
__int64 __fastcall sub_40F7B6(__int64 *a1, __int64 *a2, __m128 *a3, __int128 *a4, unsigned int a5, __m128 a6)
{
  __int64 v9; // rdx
  __int64 v10; // rsi
  __m128 v11; // xmm1
  __int128 v12; // xmm2
  __int64 v13; // rax
  __int64 v14; // r11
  const signed __int32 *v15; // r13
  unsigned __int64 v16; // rdx
  __int64 v17; // rcx
  unsigned int v18; // er15
  __int64 v19; // r11
  __int64 v20; // r13
  unsigned __int64 v21; // rax
  unsigned int v22; // eax
  __int64 v23; // rdx
  __int64 v24; // rax
  __int128 v25; // rcx
  _DWORD *v26; // rsi
  bool v27; // zf
  unsigned int v28; // ebx
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rdx
  const char *v32; // rcx
  unsigned int v33; // edx
  unsigned int v34; // eax
  __int64 v35; // rsi
  _DWORD *v36; // rax
  __int64 v37; // rcx
  __int64 v38; // rdx
  __int64 v39; // r13
  int v40; // ebx
  __int64 v41; // r14
  __int64 v42; // rcx
  unsigned int v43; // eax
  int v44; // ebx
  int v45; // eax
  __int64 v46; // r11
  int v47; // ebx
  unsigned __int64 v48; // rdx
  __int64 v49; // rcx
  unsigned int v50; // er15
  unsigned int v51; // eax
  __int64 v52; // rdx
  __int64 v53; // rcx
  __int64 v54; // rdi
  __int64 v55; // rax
  __int64 v56; // rdx
  __int64 v57; // rdx
  __int128 v58; // kr00_16
  unsigned __int64 v59; // rax
  int v60; // ebx
  _QWORD *v61; // rax
  int v62; // eax
  __int64 v63; // rcx
  __int64 v64; // r8
  _QWORD *v65; // rdx
  __int64 v66; // r13
  __int64 v67; // rdx
  __int64 v68; // rcx
  __int64 *v69; // rax
  __int64 v70; // rax
  __int64 v72; // [rsp+0h] [rbp-B0h]
  __int64 v73; // [rsp+8h] [rbp-A8h]
  char v74; // [rsp+8h] [rbp-A8h]
  __int64 v75; // [rsp+8h] [rbp-A8h]
  __int64 v76; // [rsp+8h] [rbp-A8h]
  int v77; // [rsp+8h] [rbp-A8h]
  char v78; // [rsp+8h] [rbp-A8h]
  __int64 v79; // [rsp+8h] [rbp-A8h]
  __int64 v80; // [rsp+10h] [rbp-A0h] BYREF
  __int64 v81; // [rsp+18h] [rbp-98h] BYREF
  __int64 v82; // [rsp+20h] [rbp-90h] BYREF
  __int128 v83; // [rsp+28h] [rbp-88h] BYREF
  __m128 v84; // [rsp+38h] [rbp-78h] BYREF
  __int128 v85; // [rsp+48h] [rbp-68h] BYREF
  char v86[16]; // [rsp+58h] [rbp-58h] BYREF
  __int64 v87; // [rsp+68h] [rbp-48h]
  int v88; // [rsp+70h] [rbp-40h]
  int v89; // [rsp+78h] [rbp-38h]

  v9 = *a2;
  v10 = a2[1];
  v11 = *a3;
  v80 = 0LL;
  v12 = *a4;
  *(_QWORD *)&v83 = v9;
  *((_QWORD *)&v83 + 1) = v10;
  v84 = v11;
  v85 = v12;
  switch ( (int)v9 )
  {
    case 2:
    case 3:
      v73 = sub_408C16(a1, (__int64)&v83, a6, v11);
      v13 = sub_408C16(a1, (__int64)&v84, a6, v11);
      sub_401B75(
        a1,
        (__int64)"third_party/duktape/duk_hobject_props.c",
        0x6000DE3u,
        "cannot write property %s of %s",
        v13,
        v73);
      return 0;
    case 4:
      v14 = a1[32];
      goto LABEL_64;
    case 5:
      v14 = a1[56];
      goto LABEL_64;
    case 6:
      v14 = a1[26];
      goto LABEL_64;
    case 8:
      v15 = (const signed __int32 *)*((_QWORD *)&v83 + 1);
      v10 = (__int64)&v84;
      v18 = sub_40DE74(a1, (__int128 *)&v84, &v80, a6, v11);
      if ( _bittest(v15, 9u) )
      {
        v19 = a1[58];
        goto LABEL_9;
      }
      if ( *(_QWORD *)(a1[71] + 696) == v80 )
        goto LABEL_144;
      if ( v18 != -1 )
      {
        v21 = sub_40314F((__int64)v15, (__int64)&v84, v16, v17);
        v16 = v18;
        if ( v18 < v21 )
          goto LABEL_144;
      }
      v19 = a1[30];
      goto LABEL_9;
    case 9:
      v20 = *((_QWORD *)&v83 + 1);
      if ( (**((_DWORD **)&v83 + 1) & 0x408080) != (_DWORD)&loc_408080 )
        goto LABEL_24;
      if ( v84.i32[0] )
        goto LABEL_24;
      a6.i64[0] = v84.i64[1];
      v22 = sub_40DDAB(*(double *)&v84.i64[1]);
      if ( v22 >= *(_DWORD *)(*((_QWORD *)&v83 + 1) + 48LL) )
        goto LABEL_24;
      if ( v22 < *(_DWORD *)(*((_QWORD *)&v83 + 1) + 56LL) )
        goto LABEL_18;
      if ( !*(_DWORD *)(*((_QWORD *)&v83 + 1) + 60LL) )
      {
        *(_DWORD *)(*((_QWORD *)&v83 + 1) + 56LL) = v22 + 1;
LABEL_18:
        v23 = 25LL * *(unsigned int *)(v20 + 40) + (-*(_DWORD *)(v20 + 40) & 7);
        v24 = *(_QWORD *)(v20 + 24) + v23 + 16LL * v22;
        if ( (v85 & 8) != 0 )
        {
          v23 = *((_QWORD *)&v85 + 1);
          ++*(_DWORD *)(*((_QWORD *)&v85 + 1) + 4LL);
        }
        v25 = v85;
        if ( (*(_BYTE *)v24 & 8) == 0 )
        {
          *(_OWORD *)v24 = v85;
          return 1;
        }
        v26 = *(_DWORD **)(v24 + 8);
        *(_QWORD *)v24 = v85;
        a5 = 1;
        *(_QWORD *)(v24 + 8) = *((_QWORD *)&v25 + 1);
        v27 = v26[1]-- == 1;
        if ( v27 )
          sub_40CFCD((__int64)a1, v26, v23, v25, a6, v11);
        return a5;
      }
LABEL_24:
      if ( _bittest(*((const signed __int32 **)&v83 + 1), 0xDu) )
      {
        if ( !(_DWORD)v85 )
        {
          if ( *(_BYTE *)(*((_QWORD *)&v83 + 1) + 82LL) )
          {
            if ( !v84.i32[0] )
            {
              a6.i64[0] = v84.i64[1];
              v28 = sub_40DDAB(*(double *)&v84.i64[1]);
              v74 = *(_BYTE *)(*((_QWORD *)&v83 + 1) + 80LL);
              if ( v28 < *(_DWORD *)(*((_QWORD *)&v83 + 1) + 76LL) >> v74 )
              {
                sub_406883(a1, &v85, a6, v11);
                v10 = *(_QWORD *)(*((_QWORD *)&v83 + 1) + 56LL);
                if ( v10 )
                {
                  v29 = v28 << v74;
                  v17 = (unsigned int)(1 << v74);
                  v30 = *(unsigned int *)(*((_QWORD *)&v83 + 1) + 72LL);
                  v16 = (unsigned int)(v29 + v17 + v30);
                  if ( v16 <= *(_QWORD *)(v10 + 24) )
                  {
                    v31 = v10 + 32;
                    if ( *(char *)v10 < 0 )
                      v31 = *(_QWORD *)(v10 + 32);
                    v10 = *((_QWORD *)&v83 + 1);
                    sub_409749(a1, *((__int64 *)&v83 + 1), v30 + v29 + v31, v17, a6, v11);
                  }
                }
                goto LABEL_137;
              }
            }
          }
        }
      }
      v14 = *((_QWORD *)&v83 + 1);
      if ( !_bittest(*((const signed __int32 **)&v83 + 1), 0x19u) )
        goto LABEL_65;
      if ( !(unsigned int)sub_40DEB7(a1, *((__int64 *)&v83 + 1), 88, (__int64)&v84, &v82, a6, v11) )
      {
        v20 = v82;
        LODWORD(v83) = 9;
        *((_QWORD *)&v83 + 1) = v82;
        v14 = v82;
LABEL_65:
        v75 = v14;
        v43 = sub_40DE74(a1, (__int128 *)&v84, &v80, a6, v11);
        v19 = v75;
        v18 = v43;
        goto LABEL_66;
      }
      sub_407C45(a1, v82, a6, v11);
      sub_406883(a1, (__int128 *)&v84, a6, v11);
      sub_406883(a1, &v85, a6, v11);
      sub_406883(a1, &v83, a6, v11);
      sub_41DA64(a1, 4, a6, v11);
      if ( (unsigned int)sub_405C10(a1, a6, v11) )
      {
        v34 = sub_40DE74(a1, (__int128 *)&v84, &v80, a6, v11);
        v10 = v82;
        if ( !(unsigned int)sub_40E863(a1, v82, v80, v34, (__int64)v86, 1, a6, v11) )
          goto LABEL_137;
        v35 = 0xFFFFFFFFLL;
        v36 = (_DWORD *)sub_404A12(a1, -1);
        v37 = 0LL;
        v38 = (__int64)v36;
        if ( (v86[0] & 0xD) == 0 )
        {
          v35 = (__int64)&v85;
          v37 = (unsigned int)sub_417B16(0LL, &v85, v36, 1, a6, v11) == 0;
        }
        if ( (v86[0] & 0xC) == 8 && !v87 || (_DWORD)v37 )
        {
          v32 = "proxy rejected";
          v33 = 100666990;
          goto LABEL_146;
        }
        sub_407DE7((__int64)a1, v35, v38, v37, a6, v11);
        return 1;
      }
      if ( !a5 )
        return a5;
      v32 = "proxy rejected";
      v33 = 100667569;
      goto LABEL_146;
    case 10:
      v39 = *((_QWORD *)&v83 + 1);
      if ( v84.i32[0] )
      {
        v10 = (__int64)&v84;
        v18 = sub_40DE74(a1, (__int128 *)&v84, &v80, a6, v11);
        if ( v18 == -1 )
          goto LABEL_59;
        v40 = 1;
      }
      else
      {
        a6.i64[0] = v84.i64[1];
        v40 = 0;
        v18 = sub_40DDAB(*(double *)&v84.i64[1]);
        if ( v18 == -1 )
        {
LABEL_51:
          v10 = (__int64)&v84;
          v18 = sub_40DE74(a1, (__int128 *)&v84, &v80, a6, v11);
          goto LABEL_59;
        }
      }
      v16 = v18;
      if ( (unsigned __int64)v18 < *(_QWORD *)(v39 + 24) )
      {
        v41 = v39 + 32;
        if ( *(char *)v39 < 0 )
          v41 = *(_QWORD *)(v39 + 32);
        sub_406883(a1, &v85, a6, v11);
        *(_BYTE *)(v41 + v18) = sub_405E64(a1, -1, a6, v11);
        sub_407D45((__int64)a1, (_DWORD *)(unsigned int)(v40 + 1), v18, v42, a6, v11);
        return 1;
      }
      if ( !v40 )
        goto LABEL_51;
LABEL_59:
      if ( *(_QWORD *)(a1[71] + 696) == v80 )
        goto LABEL_144;
      v19 = a1[62];
LABEL_9:
      v20 = 0LL;
LABEL_66:
      v44 = 10001;
      break;
    default:
      v14 = a1[34];
LABEL_64:
      v20 = 0LL;
      goto LABEL_65;
  }
  do
  {
    v10 = v19;
    v76 = v19;
    v45 = sub_40E863(a1, v19, v80, v18, (__int64)v86, 0, a6, v11);
    v46 = v76;
    if ( v45 )
    {
      v47 = v86[0] & 8;
      if ( (v86[0] & 8) != 0 )
      {
        v10 = *(_QWORD *)(*(_QWORD *)(v76 + 24) + 16LL * v88 + 8);
        if ( !v10 )
        {
          if ( a5 )
          {
            v32 = "setter undefined";
            v33 = 100667630;
            goto LABEL_146;
          }
          goto LABEL_141;
        }
        sub_407C45(a1, v10, a6, v11);
        sub_406883(a1, &v83, a6, v11);
        sub_406883(a1, &v85, a6, v11);
        sub_405005(a1, a6, v11);
        v10 = 2LL;
        sub_41DA64(a1, 2, a6, v11);
      }
      else
      {
        if ( !v20 )
          goto LABEL_138;
        if ( v20 != v76 )
        {
          if ( *(char *)v20 < 0 )
          {
            if ( (v86[0] & 1) != 0 )
              goto LABEL_116;
LABEL_144:
            if ( a5 )
            {
              v32 = "not writable";
              v33 = 100667602;
              goto LABEL_146;
            }
            goto LABEL_141;
          }
          goto LABEL_142;
        }
        v17 = v86[0] & 1;
        v77 = v86[0] & 1;
        if ( (v86[0] & 1) == 0 )
          goto LABEL_144;
        if ( (v86[0] & 0x10) != 0 )
        {
          if ( (*(_DWORD *)v20 & 0x400000) != 0 )
          {
            sub_406883(a1, &v85, a6, v11);
            v50 = *(_DWORD *)(v20 + 56);
            v10 = a1[14] - 16;
            v51 = sub_40DDDC(a1, v10, a6, v11);
            v53 = v51;
            if ( !*(_DWORD *)(v20 + 60) )
            {
              if ( v50 > v51 )
              {
                v10 = v20;
                v47 = sub_40F669(a1, v20, v50, v51, 0, (unsigned int *)&v82, a6, v11);
                *(_DWORD *)(v20 + 56) = v82;
              }
              else
              {
                v47 = v77;
                *(_DWORD *)(v20 + 56) = v51;
              }
            }
            sub_407DA1((__int64)a1, v10, v52, v53, a6, v11);
            if ( v47 )
              goto LABEL_137;
            if ( a5 )
            {
              v32 = "not configurable";
              v33 = 100667621;
              goto LABEL_146;
            }
            goto LABEL_141;
          }
          if ( (*(_DWORD *)v20 & 0x2000) == 0
            || (v17 = *(unsigned __int8 *)(v46 + 80), *(_DWORD *)(v46 + 76) >> v17 <= v18)
            || !*(_BYTE *)(v46 + 82) )
          {
            if ( a5 )
            {
              sub_401CB7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 4343, a6, v11);
              return 0;
            }
LABEL_141:
            sub_407DA1((__int64)a1, v10, v16, v17, a6, v11);
            return 0;
          }
          v10 = (__int64)&v85;
          v72 = v46;
          v78 = *(_BYTE *)(v46 + 80);
          sub_406883(a1, &v85, a6, v11);
          *(double *)a6.i64 = sub_405CAB(a1, a6, v11);
          v54 = *(_QWORD *)(v72 + 56);
          if ( v54 )
          {
            v10 = *(unsigned int *)(v72 + 72);
            v55 = v18 << v78;
            v49 = (unsigned int)(1 << v78);
            v48 = (unsigned int)(v10 + v55 + (1 << v78));
            if ( v48 <= *(_QWORD *)(v54 + 24) )
            {
              v56 = v54 + 32;
              if ( *(char *)v54 < 0 )
                v56 = *(_QWORD *)(v54 + 32);
              v57 = v55 + v10 + v56;
              v10 = v72;
              sub_409749(a1, v72, v57, v49, a6, v11);
            }
          }
        }
        else
        {
          v58 = v85;
          v10 = v85 & 8;
          if ( v88 < 0 )
          {
            v17 = 25LL * *(unsigned int *)(v20 + 40) + 16LL * v89;
            v16 = v17 + (-*(_DWORD *)(v20 + 40) & 7);
          }
          else
          {
            v16 = 16LL * v88;
          }
          v59 = v16 + *(_QWORD *)(v20 + 24);
          if ( (v85 & 8) != 0 )
          {
            v16 = *((_QWORD *)&v85 + 1);
            ++*(_DWORD *)(*((_QWORD *)&v85 + 1) + 4LL);
          }
          if ( (*(_BYTE *)v59 & 8) != 0 )
          {
            v10 = *(_QWORD *)(v59 + 8);
            *(_OWORD *)v59 = v58;
            v27 = (*(_DWORD *)(v10 + 4))-- == 1;
            if ( v27 )
              sub_40CFCD((__int64)a1, (_DWORD *)v10, v16, v17, a6, v11);
          }
          else
          {
            *(_OWORD *)v59 = v58;
          }
          if ( v18 == -1 || !_bittest((const signed __int32 *)v20, 0x18u) )
            goto LABEL_137;
          sub_406883(a1, &v85, a6, v11);
          v10 = v20;
          if ( (unsigned int)sub_40E733(a1, v20, v80, (__int64)v86, &v81, &v82, a6, v11) )
          {
            v66 = sub_40574F(a1, -1, a6, v11);
            sub_407DA1((__int64)a1, 0xFFFFFFFFLL, v67, v68, a6, v11);
            v69 = (__int64 *)sub_404A12(a1, -1);
            v10 = v82;
            sub_4188A7(a1, v82, v66, v69, a5, a6, v11);
          }
        }
      }
      sub_407DA1((__int64)a1, v10, v48, v49, a6, v11);
      goto LABEL_137;
    }
    if ( !--v44 )
    {
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 3994, "prototype chain limit", a6, v11);
      return 0;
    }
    v19 = *(_QWORD *)(v76 + 32);
  }
  while ( v19 );
  if ( !v20 )
  {
LABEL_138:
    if ( a5 )
    {
      v79 = sub_408C16(a1, (__int64)&v83, a6, v11);
      v70 = sub_408C16(a1, (__int64)&v84, a6, v11);
      sub_401B75(
        a1,
        (__int64)"third_party/duktape/duk_hobject_props.c",
        0x60010BEu,
        "cannot write property %s of %s",
        v70,
        v79);
      return 0;
    }
    goto LABEL_141;
  }
  if ( *(char *)v20 >= 0 )
  {
LABEL_142:
    if ( a5 )
    {
      v32 = "not extensible";
      v33 = 100667593;
LABEL_146:
      sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", v33, v32, a6, v11);
      return 0;
    }
    goto LABEL_141;
  }
LABEL_116:
  v60 = *(_DWORD *)v20 & 0x400000;
  if ( v60 )
  {
    if ( v18 == -1 )
    {
      v60 = 0;
    }
    else
    {
      if ( v18 < *(_DWORD *)(v20 + 56) )
      {
        v60 = 0;
      }
      else
      {
        v60 = v18 + 1;
        if ( *(_DWORD *)(v20 + 60) )
          goto LABEL_144;
      }
LABEL_124:
      if ( (*(_DWORD *)v20 & 0x8000) != 0 )
      {
        v61 = (_QWORD *)sub_40E2DD(a1, v18, v20, a6, v11);
        if ( v61 )
        {
          v10 = *((_QWORD *)&v85 + 1);
          v16 = v85;
          v17 = (unsigned int)v85;
          *v61 = v85;
          v61[1] = v10;
          LOBYTE(v17) = v17 & 8;
          if ( (_BYTE)v17 )
            ++*(_DWORD *)(v10 + 4);
          goto LABEL_132;
        }
      }
    }
  }
  else if ( v18 != -1 )
  {
    goto LABEL_124;
  }
  v62 = sub_40E3BE((__int64)a1, v20, v80, a6, v11);
  v10 = v85;
  v63 = *(_QWORD *)(v20 + 24);
  v64 = *((_QWORD *)&v85 + 1);
  v65 = (_QWORD *)(v63 + 16LL * v62);
  v27 = (v85 & 8) == 0;
  *v65 = v85;
  v65[1] = v64;
  if ( !v27 )
    ++*(_DWORD *)(v64 + 4);
  v16 = 24LL * *(unsigned int *)(v20 + 40);
  v17 = v16 + v63;
  *(_BYTE *)(v17 + v62) = 7;
LABEL_132:
  if ( v60 )
    *(_DWORD *)(v20 + 56) = v60;
LABEL_137:
  sub_407DA1((__int64)a1, v10, v16, v17, a6, v11);
  return 1;
}
// 40F8B6: variable 'v16' is possibly undefined
// 40F8B6: variable 'v17' is possibly undefined
// 40FB56: variable 'v38' is possibly undefined
// 40FC19: variable 'v42' is possibly undefined
// 40FE01: variable 'v52' is possibly undefined
// 40FE01: variable 'v53' is possibly undefined
// 40FEBE: variable 'v48' is possibly undefined
// 40FEBE: variable 'v49' is possibly undefined
// 41008E: variable 'v67' is possibly undefined
// 41008E: variable 'v68' is possibly undefined
// 40F7B6: using guessed type _BYTE var_58[16];

//----- (000000000041018F) ----------------------------------------------------
__int64 __fastcall sub_41018F(__int64 *a1, __int128 *a2, __int128 *a3, unsigned int a4, __m128 a5, __m128 a6)
{
  unsigned int v8; // er15
  const char *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  int v12; // eax
  const signed __int32 *v13; // r14
  const char *v14; // rcx
  unsigned int v15; // edx
  unsigned int v16; // eax
  __int64 v17; // rbx
  unsigned __int64 v18; // r14
  bool v19; // cf
  __int64 v20; // rbx
  unsigned int v21; // eax
  const char *v23; // [rsp+8h] [rbp-78h]
  __int64 v24; // [rsp+18h] [rbp-68h] BYREF
  const signed __int32 *v25; // [rsp+20h] [rbp-60h] BYREF
  int v26[22]; // [rsp+28h] [rbp-58h] BYREF

  v24 = 0LL;
  v8 = sub_404AE7((__int64)a1);
  if ( (unsigned int)(*(_DWORD *)a2 - 2) <= 1 )
  {
    v23 = (const char *)sub_408C16(a1, (__int64)a2, a5, a6);
    v9 = (const char *)sub_408C16(a1, (__int64)a3, a5, a6);
    sub_401B75(
      a1,
      (__int64)"third_party/duktape/duk_hobject_props.c",
      0x6001240u,
      "cannot delete property %s of %s",
      v9,
      v23);
    return 0;
  }
  sub_406883(a1, a2, a5, a6);
  sub_406883(a1, a3, a5, a6);
  v11 = a1[14];
  v12 = *(_DWORD *)(v11 - 32);
  if ( v12 != 9 )
  {
    if ( v12 == 8 )
    {
      v17 = *(_QWORD *)(v11 - 24);
      v18 = (unsigned int)sub_40DE49(a1, &v24, a5, a6);
      v10 = v24;
      if ( *(_QWORD *)(a1[71] + 696) == v24 )
        goto LABEL_27;
      if ( (_DWORD)v18 == -1 )
        goto LABEL_26;
      v19 = v18 < sub_40314F(v17, (__int64)&v24, v11, v24);
    }
    else
    {
      if ( v12 != 10 )
      {
        if ( v12 == 6 )
          sub_40DE49(a1, &v24, a5, a6);
        goto LABEL_26;
      }
      v20 = *(_QWORD *)(v11 - 24);
      v21 = sub_40DE49(a1, &v24, a5, a6);
      v11 = a1[71];
      v10 = v24;
      if ( *(_QWORD *)(v11 + 696) == v24 )
        goto LABEL_27;
      if ( v21 == -1 )
        goto LABEL_26;
      v19 = (unsigned __int64)v21 < *(_QWORD *)(v20 + 24);
    }
    if ( !v19 )
      goto LABEL_26;
LABEL_27:
    if ( a4 )
    {
      v14 = "not configurable";
      v15 = 100667985;
      goto LABEL_29;
    }
LABEL_31:
    sub_404BCC((__int64)a1, v8, v11, v10, a5, a6);
    return a4;
  }
  v13 = *(const signed __int32 **)(v11 - 24);
  if ( !_bittest(v13, 0x19u) )
  {
LABEL_13:
    sub_40DE49(a1, &v24, a5, a6);
    a4 = sub_40F441(a1, (__int64)v13, v24, a4 != 0, a5, a6);
    goto LABEL_31;
  }
  if ( !(unsigned int)sub_40DEB7(a1, *(_QWORD *)(v11 - 24), 72, (__int64)a3, &v25, a5, a6) )
  {
    v13 = v25;
    goto LABEL_13;
  }
  sub_407C45(a1, (__int64)v25, a5, a6);
  sub_405005(a1, a5, a6);
  sub_41DA64(a1, 2, a5, a6);
  if ( !(unsigned int)sub_405C10(a1, a5, a6) )
  {
    if ( a4 )
    {
      v14 = "proxy rejected";
      v15 = 100667976;
LABEL_29:
      sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", v15, v14, a5, a6);
      return 0;
    }
    goto LABEL_31;
  }
  v16 = sub_40DE74(a1, (__int128 *)(a1[14] - 16), &v24, a5, a6);
  if ( !(unsigned int)sub_40E863(a1, (__int64)v25, v24, v16, (__int64)v26, 0, a5, a6)
    || (a4 = v26[0] & 4, (v26[0] & 4) != 0) )
  {
LABEL_26:
    a4 = 1;
    goto LABEL_31;
  }
  sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 0x60011EEu, "proxy rejected", a5, a6);
  return a4;
}
// 41035F: variable 'v11' is possibly undefined
// 4103E2: variable 'v10' is possibly undefined
// 41018F: using guessed type int var_58[22];

//----- (00000000004103F9) ----------------------------------------------------
__int64 __fastcall sub_4103F9(__int64 *a1, __int64 a2, __int64 a3, char a4, __m128 a5, __m128 a6)
{
  __int64 v7; // r12
  unsigned int v9; // er15
  __int64 v10; // rdx
  __int64 v11; // rcx
  _BYTE *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rbx
  int v17; // eax
  __int64 v18; // rax
  __int64 v19; // rax
  int v22; // [rsp+Ch] [rbp-64h]
  char v23[24]; // [rsp+18h] [rbp-58h] BYREF
  int v24; // [rsp+30h] [rbp-40h]
  int v25; // [rsp+38h] [rbp-38h]

  v7 = a2;
  v9 = *(_DWORD *)(a3 + 20);
  v22 = a4 & 0xF;
  if ( !(unsigned int)sub_40E863(a1, a2, a3, v9, (__int64)v23, 0, a5, a6) )
  {
    if ( !_bittest((const signed __int32 *)a2, 0xFu) || v9 == -1 || !sub_40E2DD(a1, v9, a2, a5, a6) )
    {
      v17 = sub_40E3BE((__int64)a1, a2, a3, a5, a6);
      *(_BYTE *)(*(_QWORD *)(a2 + 24) + 24LL * *(unsigned int *)(a2 + 40) + v17) = v22;
      v16 = *(_QWORD *)(a2 + 24) + 16LL * v17;
      *(_DWORD *)v16 = 2;
      goto LABEL_21;
    }
    v14 = (-*(_DWORD *)(a2 + 40) & 7) + 25LL * *(unsigned int *)(a2 + 40);
    v15 = 16LL * v9;
    goto LABEL_10;
  }
  v10 = v24;
  v11 = a4 & 0x10;
  if ( v24 < 0 )
  {
    if ( v25 < 0 )
    {
      if ( (a4 & 0x10) == 0 )
      {
        if ( *(_QWORD *)(a1[71] + 696) != a3 || !_bittest((const signed __int32 *)a2, 0x16u) )
          return sub_401CB7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 4830, a5, a6);
        a2 = a1[14] - 16;
        *(_DWORD *)(v7 + 56) = sub_40DDDC(a1, a2, a5, a6);
      }
      return sub_407DA1((__int64)a1, a2, v10, v11, a5, a6);
    }
    if ( (a4 & 0x10) != 0 )
      return sub_407DA1((__int64)a1, a2, v10, v11, a5, a6);
    if ( v22 != 7 )
      return sub_401CB7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 4830, a5, a6);
    v14 = 25LL * *(unsigned int *)(a2 + 40) + 16LL * v25;
    v15 = -*(_BYTE *)(a2 + 40) & 7;
LABEL_10:
    v13 = v14 + v15;
    goto LABEL_11;
  }
  if ( (a4 & 0x10) != 0 )
    return sub_407DA1((__int64)a1, a2, v10, v11, a5, a6);
  v12 = (_BYTE *)(*(_QWORD *)(a2 + 24) + v24 + 24LL * *(unsigned int *)(a2 + 40));
  if ( (*v12 & 8) == 0 )
  {
    *v12 = v22;
    v13 = 16LL * v24;
LABEL_11:
    v16 = *(_QWORD *)(a2 + 24) + v13;
LABEL_21:
    a2 = 0xFFFFFFFFLL;
    v18 = sub_404A12(a1, -1);
    if ( (*(_BYTE *)v18 & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(v18 + 8) + 4LL);
    v10 = *(_QWORD *)(v18 + 8);
    v19 = *(_QWORD *)v18;
    if ( (*(_BYTE *)v16 & 8) != 0 )
    {
      a2 = *(_QWORD *)(v16 + 8);
      *(_QWORD *)v16 = v19;
      *(_QWORD *)(v16 + 8) = v10;
      if ( (*(_DWORD *)(a2 + 4))-- == 1 )
        sub_40CFCD((__int64)a1, (_DWORD *)a2, v10, v11, a5, a6);
    }
    else
    {
      *(_QWORD *)v16 = v19;
      *(_QWORD *)(v16 + 8) = v10;
    }
    return sub_407DA1((__int64)a1, a2, v10, v11, a5, a6);
  }
  return sub_401CB7(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 4830, a5, a6);
}
// 4105A8: variable 'v11' is possibly undefined
// 4105B9: variable 'v10' is possibly undefined
// 4103F9: using guessed type char var_58[24];

//----- (00000000004105E1) ----------------------------------------------------
__int64 __fastcall sub_4105E1(__int64 *a1, __int64 a2, unsigned int a3, int a4, __m128 a5, __m128 a6)
{
  char v6; // r15
  _QWORD *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v14; // r14

  v6 = a4;
  if ( _bittest((const signed __int32 *)a2, 0xFu)
    && a3 != -1
    && a4 == 7
    && (v8 = (_QWORD *)sub_40E2DD(a1, a3, a2, a5, a6)) != 0LL )
  {
    a2 = 0xFFFFFFFFLL;
    v9 = sub_404A12(a1, -1);
    if ( (*(_BYTE *)v9 & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(v9 + 8) + 4LL);
    v11 = *(_QWORD *)(v9 + 8);
    v12 = *(_QWORD *)v9;
    if ( (*(_BYTE *)v8 & 8) != 0 )
    {
      a2 = v8[1];
      *v8 = v12;
      v8[1] = v11;
      if ( (*(_DWORD *)(a2 + 4))-- == 1 )
        sub_40CFCD((__int64)a1, (_DWORD *)a2, v11, v10, a5, a6);
    }
    else
    {
      *v8 = v12;
      v8[1] = v11;
    }
  }
  else
  {
    v14 = sub_4089F6(a1, a3, a5, a6);
    sub_40500F(a1, -2);
    sub_4103F9(a1, a2, v14, v6, a5, a6);
  }
  return sub_407DA1((__int64)a1, a2, v11, v10, a5, a6);
}
// 410655: variable 'v10' is possibly undefined
// 41069F: variable 'v11' is possibly undefined

//----- (00000000004106A4) ----------------------------------------------------
unsigned __int64 __fastcall sub_4106A4(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  unsigned __int64 result; // rax
  __int128 *v5; // rsi
  __m128 *v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rcx

  if ( _bittest((const signed __int32 *)a2, 0x16u) )
    return *(unsigned int *)(a2 + 56);
  sub_407C45(a1, a2, a3, a4);
  sub_407826(a1, 0x57u, a3, a4);
  v5 = (__int128 *)a1[14];
  v6 = (__m128 *)(v5 - 1);
  v5 -= 2;
  sub_40EC01(a1, v5, v6, a3);
  *(double *)a3.i64 = sub_405CAB(a1, a3, a4);
  sub_407DFC((__int64)a1, (__int64)v5, v7, v8, a3, a4);
  if ( *(double *)a3.i64 < 0.0 || *(double *)a3.i64 > 1.844674407370955e19 )
    return 0LL;
  result = (unsigned int)(int)*(double *)a3.i64;
  if ( *(double *)a3.i64 >= 9.223372036854776e18 )
    return (unsigned int)(int)(*(double *)a3.i64 - 9.223372036854776e18) ^ 0x8000000000000000LL;
  return result;
}
// 4106F2: variable 'v7' is possibly undefined
// 4106F2: variable 'v8' is possibly undefined

//----- (0000000000410740) ----------------------------------------------------
__int64 __fastcall sub_410740(__int64 a1)
{
  __int64 result; // rax

  LODWORD(result) = 10001;
  while ( !_bittest((const signed __int32 *)a1, 0x15u) )
  {
    result = (unsigned int)(result - 1);
    if ( !(_DWORD)result )
      return result;
    a1 = *(_QWORD *)(a1 + 32);
    if ( !a1 )
      return 0LL;
  }
  return 1LL;
}

//----- (0000000000410761) ----------------------------------------------------
void __fastcall sub_410761(__int64 *a1, int a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // r13
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  int v12; // esi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned int v17; // [rsp+8h] [rbp-38h] BYREF
  __int64 v18; // [rsp+10h] [rbp-30h]
  __int64 v19; // [rsp+18h] [rbp-28h]

  v7 = sub_408496(a1, a2, 640LL, a6, a7, a3, a4);
  v8 = sub_4089B9(a1, -1, a3, a4);
  if ( (unsigned int)sub_40E722(a1, v7, v8, (__int64)&v17, 1, a3, a4) )
  {
    sub_407095(a1, a3, a4);
    if ( (v17 & 8) != 0 )
    {
      if ( v18 )
        sub_407C45(a1, v18, a3, a4);
      else
        sub_4068D1(a1, 0LL, v10, a3, a4);
      sub_403A07(a1, -130999, a3, a4);
      if ( v19 )
        sub_407C45(a1, v19, a3, a4);
      else
        sub_4068D1(a1, 0LL, v11, a3, a4);
      v12 = -130984;
    }
    else
    {
      sub_404FF1(a1, a3, a4);
      sub_403A07(a1, -131038, a3, a4);
      sub_406955(a1, v17 & 1, a3, a4);
      v12 = -131037;
    }
    sub_403A07(a1, v12, a3, a4);
    sub_406955(a1, (v17 >> 1) & 1, a3, a4);
    sub_403A07(a1, -131035, a3, a4);
    sub_406955(a1, (v17 >> 2) & 1, a3, a4);
    sub_403A07(a1, -131036, a3, a4);
    sub_405057(a1, -3, v13, v14, *(double *)a3.i64, a4);
    sub_407DA1((__int64)a1, 4294967293LL, v15, v16, a3, a4);
  }
  else
  {
    sub_4068D1(a1, v7, v9, a3, a4);
    sub_405181(a1, a3, a4);
  }
}
// 4107A7: variable 'v9' is possibly undefined
// 4107D7: variable 'v10' is possibly undefined
// 4107FC: variable 'v11' is possibly undefined
// 41087B: variable 'v13' is possibly undefined
// 41087B: variable 'v14' is possibly undefined
// 410883: variable 'v15' is possibly undefined
// 410883: variable 'v16' is possibly undefined

//----- (0000000000410892) ----------------------------------------------------
const signed __int32 **__fastcall sub_410892(
        __int64 *a1,
        int a2,
        int *a3,
        int *a4,
        const signed __int32 **a5,
        const signed __int32 **a6,
        __m128 a7,
        __m128 a8)
{
  int v8; // er13
  int v9; // ebx
  const signed __int32 *v10; // r15
  __int64 v11; // rcx
  __int64 v12; // r8
  const signed __int32 *v13; // rax
  const signed __int32 *v14; // r14
  __int64 v15; // rcx
  __int64 v16; // r8
  const signed __int32 *v17; // rax
  const signed __int32 **result; // rax
  int v23; // [rsp+24h] [rbp-3Ch]
  int v24; // [rsp+28h] [rbp-38h]
  int v25; // [rsp+2Ch] [rbp-34h]

  v8 = sub_40480A(a1, a2);
  sub_40582D(a1, v8, a7, a8);
  v25 = sub_40377C(a1, v8, 0x22u, a7, a8);
  if ( v25 )
  {
    v9 = 64;
    v25 = 1;
    v23 = sub_404C73((__int64)a1);
  }
  else
  {
    v9 = 0;
    v23 = -1;
  }
  if ( (unsigned int)sub_40377C(a1, v8, 0x23u, a7, a8) )
  {
    if ( (unsigned int)sub_405C10(a1, a7, a8) )
      v9 |= 9u;
    else
      v9 |= 8u;
    v25 = 1;
  }
  v24 = sub_40377C(a1, v8, 0x49u, a7, a8);
  if ( v24 )
  {
    v10 = 0LL;
    if ( *(_DWORD *)sub_404A12(a1, -1) != 2 )
    {
      v13 = (const signed __int32 *)sub_408491(a1, -1, 512LL, v11, v12, a7, a8);
      v10 = v13;
      if ( !v13 || !_bittest(v13, 9u) )
        return (const signed __int32 **)sub_401C42(
                                          a1,
                                          (__int64)"third_party/duktape/duk_hobject_props.c",
                                          0x600141Fu,
                                          "invalid descriptor",
                                          a7,
                                          a8);
    }
    LOBYTE(v9) = v9 | 0x80;
    v24 = 1;
  }
  else
  {
    v10 = 0LL;
  }
  if ( (unsigned int)sub_40377C(a1, v8, 0x58u, a7, a8) )
  {
    v14 = 0LL;
    if ( *(_DWORD *)sub_404A12(a1, -1) != 2 )
    {
      v17 = (const signed __int32 *)sub_408491(a1, -1, 512LL, v15, v16, a7, a8);
      v14 = v17;
      if ( !v17 || !_bittest(v17, 9u) )
        return (const signed __int32 **)sub_401C42(
                                          a1,
                                          (__int64)"third_party/duktape/duk_hobject_props.c",
                                          0x600141Fu,
                                          "invalid descriptor",
                                          a7,
                                          a8);
    }
    BYTE1(v9) |= 1u;
    v24 = 1;
  }
  else
  {
    v14 = 0LL;
  }
  if ( (unsigned int)sub_40377C(a1, v8, 0x25u, a7, a8) )
  {
    if ( (unsigned int)sub_405C10(a1, a7, a8) )
      v9 |= 0x12u;
    else
      v9 |= 0x10u;
  }
  if ( (unsigned int)sub_40377C(a1, v8, 0x24u, a7, a8) )
  {
    if ( (unsigned int)sub_405C10(a1, a7, a8) )
      v9 |= 0x24u;
    else
      v9 |= 0x20u;
  }
  if ( (v24 & v25) == 0 )
  {
    *a3 = v9;
    *a4 = v23;
    *a5 = v10;
    result = a6;
    *a6 = v14;
    return result;
  }
  return (const signed __int32 **)sub_401C42(
                                    a1,
                                    (__int64)"third_party/duktape/duk_hobject_props.c",
                                    0x600141Fu,
                                    "invalid descriptor",
                                    a7,
                                    a8);
}
// 410965: variable 'v11' is possibly undefined
// 410965: variable 'v12' is possibly undefined
// 4109C1: variable 'v15' is possibly undefined
// 4109C1: variable 'v16' is possibly undefined

//----- (0000000000410A94) ----------------------------------------------------
__int64 __fastcall sub_410A94(
        __int64 *a1,
        __int16 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        __m128 a7,
        __m128 a8,
        __int64 a9,
        int a10)
{
  __int64 v10; // r13
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rcx
  bool v19; // al
  int v20; // er13
  int v21; // eax
  __int64 v22; // rdx
  __int64 *v23; // rcx
  int v24; // ebx
  __int64 v25; // r14
  __int64 *v26; // rax
  _QWORD *v27; // rax
  int v28; // eax
  __int64 v29; // rcx
  __int64 v30; // rdx
  _DWORD *v31; // rax
  bool v32; // zf
  __int64 v33; // rdx
  __int64 v34; // rcx
  unsigned int *v35; // rax
  _DWORD *v36; // rsi
  __int64 v37; // rdx
  __int64 v38; // rax
  _QWORD *v39; // rdx
  _BYTE *v40; // rax
  __int64 *v41; // rax
  __int64 v42; // rsi
  __int64 v43; // rax
  __int64 v44; // rdx
  __int64 v45; // rax
  _BYTE *v46; // rax
  _DWORD *v47; // rax
  unsigned int v48; // er11
  __int64 v49; // rax
  __int64 v50; // rdx
  __int64 v51; // rdx
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 *v54; // rax
  __int64 v55; // rbx
  _BOOL4 v56; // eax
  __int64 v57; // r13
  __int64 *v58; // rax
  _DWORD *v59; // [rsp+8h] [rbp-C8h]
  _DWORD *v60; // [rsp+8h] [rbp-C8h]
  __int64 v61; // [rsp+10h] [rbp-C0h]
  int v62; // [rsp+1Ch] [rbp-B4h]
  int v63; // [rsp+20h] [rbp-B0h]
  int v64; // [rsp+24h] [rbp-ACh]
  int v65; // [rsp+28h] [rbp-A8h]
  char v66; // [rsp+28h] [rbp-A8h]
  int v67; // [rsp+2Ch] [rbp-A4h]
  int v68; // [rsp+30h] [rbp-A0h]
  int v69; // [rsp+34h] [rbp-9Ch]
  int v70; // [rsp+38h] [rbp-98h]
  int v72; // [rsp+40h] [rbp-90h]
  unsigned int v73; // [rsp+44h] [rbp-8Ch]
  int v74; // [rsp+48h] [rbp-88h]
  unsigned int v75; // [rsp+4Ch] [rbp-84h]
  unsigned int v77; // [rsp+58h] [rbp-78h]
  unsigned int v79; // [rsp+5Ch] [rbp-74h]
  __int64 v80; // [rsp+68h] [rbp-68h] BYREF
  __int64 v81; // [rsp+70h] [rbp-60h] BYREF
  unsigned int v82; // [rsp+78h] [rbp-58h] BYREF
  __int64 v83; // [rsp+80h] [rbp-50h]
  __int64 v84; // [rsp+88h] [rbp-48h]
  int v85; // [rsp+90h] [rbp-40h]
  int v86; // [rsp+98h] [rbp-38h]

  v68 = a2 & 8;
  v62 = a2 & 0x10;
  v65 = a2 & 0x20;
  v69 = a2 & 0x40;
  v70 = a2 & 1;
  v64 = a2 & 2;
  v63 = a2 & 4;
  v67 = a2 & 0x200;
  v75 = *(_DWORD *)(a4 + 20);
  v74 = *(_DWORD *)a3 & 0x400000;
  if ( !v74 )
    goto LABEL_15;
  if ( *(_QWORD *)(a1[71] + 696) != a4 )
  {
    if ( v75 == -1 || v75 < *(_DWORD *)(a3 + 56) )
      goto LABEL_18;
    if ( *(_DWORD *)(a3 + 60) && (a2 & 0x200) == 0 )
      goto LABEL_189;
    v74 = v75 + 1;
LABEL_15:
    v72 = 0;
    v77 = 0;
    v73 = 0;
    goto LABEL_20;
  }
  if ( (a2 & 0x40) == 0 )
  {
LABEL_18:
    v72 = 0;
    v77 = 0;
    v73 = 0;
    goto LABEL_19;
  }
  v73 = *(_DWORD *)(a3 + 56);
  v77 = sub_40DDDC(a1, a1[13] + 16LL * a5, a7, a8);
  sub_406AAF(a1, v77, a7, a8);
  sub_405057(a1, a5, v13, v14, *(double *)a7.i64, a8);
  if ( v73 > v77 )
  {
    if ( *(_DWORD *)(a3 + 60) && (a2 & 0x200) == 0 )
      goto LABEL_189;
    if ( (a2 & 8) != 0 && (a2 & 1) == 0 )
    {
      v72 = 1;
      v74 = 0;
      v70 = 1;
      goto LABEL_20;
    }
  }
  v72 = 0;
LABEL_19:
  v74 = 0;
LABEL_20:
  v15 = a3;
  if ( !(unsigned int)sub_40E863(a1, a3, a4, v75, (__int64)&v82, 1, a7, a8) )
  {
    if ( !(v67 | *(_DWORD *)a3 & 0x80) )
    {
      if ( a10 )
      {
        v79 = v67 | *(_DWORD *)a3 & 0x80;
        sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 0x6001796u, "not extensible", a7, a8);
        return v79;
      }
      return 0LL;
    }
    v19 = v64 != 0 && v62 != 0;
    if ( (a2 & 0x180) != 0 )
    {
      v20 = !v19 ? 8 : 10;
      if ( v65 && v63 )
        LOBYTE(v20) = v20 | 4;
      if ( v75 != -1 && (*(_DWORD *)a3 & 0x8000) != 0 )
        sub_40E25B(a1, a3, a7, a8);
      v15 = a3;
      v21 = sub_40E3BE((__int64)a1, a3, a4, a7, a8);
      v22 = *(_QWORD *)(a3 + 24);
      v23 = (__int64 *)(v22 + 16LL * v21);
      *v23 = a6;
      v23[1] = a9;
      if ( a6 )
        ++*(_DWORD *)(a6 + 4);
      if ( a9 )
        ++*(_DWORD *)(a9 + 4);
      v17 = 24LL * *(unsigned int *)(a3 + 40);
      v16 = v17 + v22;
      *(_BYTE *)(v16 + v21) = v20;
      goto LABEL_170;
    }
    LOBYTE(a6) = v68 != 0;
    v24 = v70 & a6;
    if ( v19 )
      v24 |= 2u;
    if ( v65 && v63 )
      v24 |= 4u;
    v25 = 2LL;
    if ( v69 )
    {
      v26 = (__int64 *)sub_404A12(a1, a5);
      v25 = *(unsigned int *)v26;
      v10 = v26[1];
      v61 = *v26;
    }
    if ( v75 != -1 && _bittest((const signed __int32 *)a3, 0xFu) )
    {
      if ( v24 == 7 )
      {
        v15 = v75;
        v27 = (_QWORD *)sub_40E2DD(a1, v75, a3, a7, a8);
        if ( v27 )
        {
          v27[1] = v10;
          v16 = v61 & 0xFFFFFFFF00000000LL;
          *v27 = v61 & 0xFFFFFFFF00000000LL | v25;
          if ( (v25 & 8) != 0 )
            ++*(_DWORD *)(v10 + 4);
          goto LABEL_170;
        }
      }
      else
      {
        sub_40E25B(a1, a3, a7, a8);
      }
    }
    v28 = sub_40E3BE((__int64)a1, a3, a4, a7, a8);
    v29 = *(_QWORD *)(a3 + 24);
    v15 = v29 + 16LL * v28;
    *(_QWORD *)(v15 + 8) = v10;
    *(_QWORD *)v15 = v61 & 0xFFFFFFFF00000000LL | v25;
    if ( (v25 & 8) != 0 )
      ++*(_DWORD *)(v10 + 4);
    v16 = 24LL * *(unsigned int *)(a3 + 40);
    v17 = v16 + v29;
    *(_BYTE *)(v17 + v28) = v24;
LABEL_170:
    if ( (*(_DWORD *)a3 & 0x400000) != 0 )
    {
      if ( v74 )
        *(_DWORD *)(a3 + 56) = v74;
      if ( *(_QWORD *)(a1[71] + 696) == a4 && v73 > v77 )
      {
        v15 = a3;
        v56 = sub_40F669(a1, a3, v73, v77, v67, (unsigned int *)&v81, a7, a8);
        v16 = (unsigned int)v81;
        *(_DWORD *)(a3 + 56) = v81;
        if ( v72 )
          *(_DWORD *)(a3 + 60) = 1;
        if ( !v56 )
          goto LABEL_189;
      }
    }
    else if ( v75 != -1 && (*(_DWORD *)a3 & 0x1000000) != 0 )
    {
      v15 = a3;
      v80 = 0LL;
      v81 = 0LL;
      if ( (unsigned int)sub_40E733(a1, a3, a4, (__int64)&v82, &v80, &v81, a7, a8) )
      {
        if ( (a2 & 0x180) != 0 )
          goto LABEL_187;
        if ( v69 )
        {
          v57 = sub_40574F(a1, -1, a7, a8);
          v58 = (__int64 *)sub_404A12(a1, a5);
          v15 = v81;
          sub_4188A7(a1, v81, v57, v58, 1u, a7, a8);
        }
        if ( v68 && !v70 )
        {
LABEL_187:
          v15 = v80;
          sub_40F441(a1, v80, a4, 0, a7, a8);
        }
      }
    }
LABEL_188:
    sub_40CA54((__int64)a1, v15, v16, v17, a7, a8);
    return 1LL;
  }
  if ( v62 )
  {
    if ( v64 )
    {
      if ( (v82 & 2) == 0 )
        goto LABEL_56;
    }
    else if ( (v82 & 2) != 0 )
    {
      goto LABEL_56;
    }
  }
  if ( v65 )
  {
    if ( v63 )
    {
      if ( (v82 & 4) == 0 )
        goto LABEL_56;
    }
    else if ( (v82 & 4) != 0 )
    {
      goto LABEL_56;
    }
  }
  if ( v69 )
  {
    if ( (v82 & 8) != 0 )
      goto LABEL_56;
    v59 = (_DWORD *)sub_404A12(a1, -1);
    v31 = (_DWORD *)sub_404A12(a1, a5);
    v15 = (__int64)v59;
    if ( !(unsigned int)sub_417B16(0LL, v59, v31, 1, a7, a8) )
      goto LABEL_56;
  }
  if ( !v68 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      if ( (v82 & 8) == 0 || v84 != a9 )
        goto LABEL_56;
      if ( (a2 & 0x80) == 0 )
        goto LABEL_188;
    }
    else
    {
      if ( (a2 & 0x80) == 0 )
        goto LABEL_188;
      if ( (v82 & 8) == 0 )
        goto LABEL_56;
    }
    v32 = v83 == a6;
LABEL_198:
    if ( v32 )
      goto LABEL_188;
    goto LABEL_56;
  }
  if ( (v82 & 8) == 0 )
  {
    if ( v70 )
    {
      if ( (v82 & 1) == 0 )
        goto LABEL_56;
    }
    else if ( (v82 & 1) != 0 )
    {
      goto LABEL_56;
    }
    if ( (a2 & 0x100) == 0 )
    {
      v32 = (a2 & 0x80) == 0;
      goto LABEL_198;
    }
  }
LABEL_56:
  v30 = v67 | v82 & 4;
  if ( !(v67 | v82 & 4) )
  {
    if ( v65 && v63 )
      goto LABEL_189;
    if ( v62 )
    {
      if ( (v82 & 2) != 0 )
      {
        if ( !v64 )
          goto LABEL_189;
      }
      else if ( v64 )
      {
        goto LABEL_189;
      }
    }
  }
  if ( (a2 & 0x180) != 0 )
  {
    if ( (v82 & 8) != 0 )
    {
      if ( !(_DWORD)v30 && ((a2 & 0x100) != 0 && v84 != a9 || (a2 & 0x80) != 0 && v83 != a6) )
        goto LABEL_189;
    }
    else
    {
      if ( !(_DWORD)v30 )
        goto LABEL_189;
      if ( v86 >= 0 )
      {
        sub_40E25B(a1, a3, a7, a8);
        sub_407DA1((__int64)a1, a3, v33, v34, a7, a8);
        sub_40E863(a1, a3, a4, v75, (__int64)&v82, 1, a7, a8);
      }
      if ( v85 < 0 )
        goto LABEL_189;
      v35 = (unsigned int *)(*(_QWORD *)(a3 + 24) + 16LL * v85);
      v37 = *v35;
      v36 = (_DWORD *)*((_QWORD *)v35 + 1);
      *v35 = 2;
      LOBYTE(v37) = v37 & 8;
      if ( (_BYTE)v37 )
      {
        v32 = v36[1]-- == 1;
        if ( v32 )
          sub_40CFD5((__int64)a1, v36, v37, v17, a7, a8);
      }
      v15 = v85;
      v17 = *(_QWORD *)(a3 + 24);
      v38 = 24LL * *(unsigned int *)(a3 + 40);
      v39 = (_QWORD *)(v17 + 16LL * v85);
      *v39 = 0LL;
      v39[1] = 0LL;
      *(_BYTE *)(v17 + v15 + v38) &= ~1u;
      v40 = (_BYTE *)(*(_QWORD *)(a3 + 24) + v85 + 24LL * *(unsigned int *)(a3 + 40));
      *v40 |= 8u;
      v82 = v82 & 0xFFFFFFF6 | 8;
    }
  }
  else if ( (a2 & 0x48) != 0 )
  {
    if ( (v82 & 8) != 0 )
    {
      if ( !(_DWORD)v30 || v85 < 0 )
        goto LABEL_189;
      v41 = (__int64 *)(*(_QWORD *)(a3 + 24) + 16LL * v85);
      v42 = *v41;
      *v41 = 0LL;
      if ( v42 )
      {
        v32 = (*(_DWORD *)(v42 + 4))-- == 1;
        if ( v32 )
          sub_40CAE2((__int64)a1, v42, v30, v17, a7, a8);
      }
      v43 = *(_QWORD *)(a3 + 24) + 16LL * v85;
      v15 = *(_QWORD *)(v43 + 8);
      *(_QWORD *)(v43 + 8) = 0LL;
      if ( v15 )
      {
        v32 = (*(_DWORD *)(v15 + 4))-- == 1;
        if ( v32 )
          sub_40CAE2((__int64)a1, v15, v30, v17, a7, a8);
      }
      v17 = v85;
      v44 = *(_QWORD *)(a3 + 24);
      *(_DWORD *)(v44 + 16LL * v85) = 2;
      v45 = v17 + 24LL * *(unsigned int *)(a3 + 40);
      *(_BYTE *)(v44 + v45) &= ~1u;
      v46 = (_BYTE *)(*(_QWORD *)(a3 + 24) + v85 + 24LL * *(unsigned int *)(a3 + 40));
      *v46 &= ~8u;
      v82 &= 0xFFFFFFF6;
    }
    else if ( !(v67 | v82 & 5) )
    {
      if ( v68 && v70 )
        goto LABEL_189;
      if ( v69 )
      {
        v60 = (_DWORD *)sub_404A12(a1, -1);
        v47 = (_DWORD *)sub_404A12(a1, a5);
        v15 = (__int64)v60;
        if ( !(unsigned int)sub_417B16(0LL, v60, v47, 1, a7, a8) )
          goto LABEL_189;
      }
    }
  }
  v48 = v82;
  if ( v62 )
  {
    if ( v64 )
      v48 = v82 | 2;
    else
      v48 = v82 & 0xFFFFFFFD;
  }
  if ( v65 )
  {
    if ( v63 )
      v48 |= 4u;
    else
      v48 &= ~4u;
  }
  if ( v68 )
  {
    if ( v70 )
      v48 |= 1u;
    else
      v48 &= ~1u;
  }
  if ( v86 >= 0 )
  {
    if ( v48 == 7 )
    {
      v49 = sub_404A12(a1, a5);
      v15 = 25LL * *(unsigned int *)(a3 + 40);
      v50 = v15 + 16LL * v86 + (-*(_DWORD *)(a3 + 40) & 7);
LABEL_161:
      v16 = *(_QWORD *)(a3 + 24) + v50;
      if ( (*(_BYTE *)v49 & 8) != 0 )
        ++*(_DWORD *)(*(_QWORD *)(v49 + 8) + 4LL);
      v17 = *(_QWORD *)v49;
      v55 = *(_QWORD *)(v49 + 8);
      if ( (*(_BYTE *)v16 & 8) != 0 )
      {
        v15 = *(_QWORD *)(v16 + 8);
        *(_QWORD *)v16 = v17;
        *(_QWORD *)(v16 + 8) = v55;
        v32 = (*(_DWORD *)(v15 + 4))-- == 1;
        if ( v32 )
          sub_40CFCD((__int64)a1, (_DWORD *)v15, v16, v17, a7, a8);
      }
      else
      {
        *(_QWORD *)v16 = v17;
        *(_QWORD *)(v16 + 8) = v55;
      }
      goto LABEL_170;
    }
    v66 = v48;
    sub_40E25B(a1, a3, a7, a8);
    sub_407DA1((__int64)a1, a3, v51, v52, a7, a8);
    v15 = a3;
    sub_40E863(a1, a3, a4, v75, (__int64)&v82, 1, a7, a8);
    LOBYTE(v48) = v66;
  }
  v16 = v85;
  if ( v85 < 0 )
  {
    v17 = a4;
    if ( *(_QWORD *)(a1[71] + 696) == a4 && _bittest((const signed __int32 *)a3, 0x16u) )
    {
      if ( (((unsigned __int8)v48 ^ (unsigned __int8)v82) & 6) != 0 )
        goto LABEL_189;
      *(_DWORD *)(a3 + 60) = (v48 & 1) == 0;
    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(a3 + 24) + 24LL * *(unsigned int *)(a3 + 40) + v85) = v48;
  }
  if ( (a2 & 0x100) != 0 )
  {
    if ( v85 < 0 )
      goto LABEL_189;
    v53 = *(_QWORD *)(a3 + 24) + 16LL * v85;
    v15 = *(_QWORD *)(v53 + 8);
    *(_QWORD *)(v53 + 8) = a9;
    if ( a9 )
      ++*(_DWORD *)(a9 + 4);
    if ( v15 )
    {
      v32 = (*(_DWORD *)(v15 + 4))-- == 1;
      if ( v32 )
        sub_40CFE0((__int64)a1, v15, v16, v17, a7, a8);
    }
  }
  if ( (a2 & 0x80) != 0 )
  {
    if ( v85 < 0 )
      goto LABEL_189;
    v54 = (__int64 *)(*(_QWORD *)(a3 + 24) + 16LL * v85);
    v15 = *v54;
    *v54 = a6;
    if ( a6 )
      ++*(_DWORD *)(a6 + 4);
    if ( !v15 || (v32 = *(_DWORD *)(v15 + 4) == 1, --*(_DWORD *)(v15 + 4), !v32) )
    {
      if ( !v69 )
        goto LABEL_170;
      goto LABEL_160;
    }
    sub_40CFE0((__int64)a1, v15, v16, v17, a7, a8);
  }
  if ( !v69 )
    goto LABEL_170;
  if ( v85 >= 0 )
  {
LABEL_160:
    v15 = (unsigned int)a5;
    v49 = sub_404A12(a1, a5);
    v50 = 16LL * v85;
    goto LABEL_161;
  }
  if ( *(_QWORD *)(a1[71] + 696) == a4 && _bittest((const signed __int32 *)a3, 0x16u) )
  {
    *(_DWORD *)(a3 + 56) = v77;
    goto LABEL_170;
  }
LABEL_189:
  if ( a10 )
    sub_401C42(a1, (__int64)"third_party/duktape/duk_hobject_props.c", 0x600179Eu, "not configurable", a7, a8);
  return 0LL;
}
// 410B89: variable 'v13' is possibly undefined
// 410B89: variable 'v14' is possibly undefined
// 410E0A: variable 'v10' is possibly undefined
// 410E12: variable 'v61' is possibly undefined
// 411076: variable 'v33' is possibly undefined
// 411076: variable 'v34' is possibly undefined
// 4110C7: variable 'v17' is possibly undefined
// 411192: variable 'v30' is possibly undefined
// 4112ED: variable 'v51' is possibly undefined
// 4112ED: variable 'v52' is possibly undefined
// 4113E5: variable 'v16' is possibly undefined

//----- (000000000041162B) ----------------------------------------------------
__int64 __fastcall sub_41162B(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  const signed __int32 *v5; // r13
  __int64 v6; // rax
  int v7; // esi
  int v9[18]; // [rsp+8h] [rbp-48h] BYREF

  v5 = sub_408A2B(a1, 0, a3, a4);
  v6 = sub_40869C(a1, a3, a4);
  v7 = 0;
  if ( (unsigned int)sub_40E722(a1, v6, (__int64)v5, (__int64)v9, 0, a3, a4) )
    v7 = (a2 & v9[0]) == a2;
  sub_406955(a1, v7, a3, a4);
  return 1LL;
}
// 41162B: using guessed type int var_48[18];

//----- (000000000041168F) ----------------------------------------------------
_BYTE *__fastcall sub_41168F(_QWORD *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  _BYTE *result; // rax
  int v8; // ecx
  unsigned int i; // esi

  result = (_BYTE *)sub_40E25B(a1, a2, a4, a5);
  for ( i = 0; *(_DWORD *)(a2 + 44) > i; ++i )
  {
    result = (_BYTE *)(*(_QWORD *)(a2 + 24) + i + 24LL * *(unsigned int *)(a2 + 40));
    LOBYTE(v8) = *result;
    if ( !a3 || (v8 & 8) != 0 )
      v8 &= ~4u;
    else
      v8 &= 0xFFFFFFFA;
    *result = v8;
  }
  *(_DWORD *)a2 &= ~0x80u;
  return result;
}
// 4116C4: variable 'v8' is possibly undefined

//----- (00000000004116DD) ----------------------------------------------------
__int64 __fastcall sub_4116DD(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // er8
  __int64 i; // rax
  __int64 v5; // rcx
  char v6; // cl
  __int64 v7; // rdx
  __int64 v8; // r9

  v3 = *(_DWORD *)a2 & 0x80;
  if ( v3 )
  {
    return 0;
  }
  else
  {
    for ( i = 0LL; *(_DWORD *)(a2 + 44) > (unsigned int)i; ++i )
    {
      v5 = *(_QWORD *)(a2 + 24);
      if ( *(_QWORD *)(v5 + 16LL * *(unsigned int *)(a2 + 40) + 8 * i) )
      {
        v6 = *(_BYTE *)(24LL * *(unsigned int *)(a2 + 40) + v5 + i);
        if ( (v6 & 4) != 0 || a3 && (v6 & 9) == 1 )
          return v3;
      }
    }
    v7 = 0LL;
    while ( *(_DWORD *)(a2 + 48) > (unsigned int)v7 )
    {
      v8 = v7++;
      if ( *(_DWORD *)(*(_QWORD *)(a2 + 24) + 16 * v8 + 25LL * *(unsigned int *)(a2 + 40) + (-*(_DWORD *)(a2 + 40) & 7)) != 7 )
        return v3;
    }
    return 1;
  }
}

//----- (000000000041176B) ----------------------------------------------------
__int64 __fastcall sub_41176B(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  unsigned int v7; // eax
  __int64 v8; // r14
  unsigned __int64 v9; // r14
  unsigned int v11; // [rsp+0h] [rbp-40h] BYREF
  int v12; // [rsp+4h] [rbp-3Ch] BYREF
  unsigned __int64 v13[7]; // [rsp+8h] [rbp-38h] BYREF

  v7 = sub_40D015(a1, a2, a3, a4, a5, a6);
  v8 = *(unsigned int *)(a2 + 24);
  v13[0] = a2 + 32 + v7;
  v9 = a2 + 32 + v8;
  if ( (unsigned int)sub_41C7A1((__int64)a1, v13, a2 + 32, v9, (int *)&v11) )
  {
    if ( a4 )
    {
      if ( v11 - 55296 <= 0x3FF )
      {
        v12 = 0;
        sub_41C7A1((__int64)a1, v13, a2 + 32, v9, &v12);
        if ( (unsigned int)(v12 - 56320) <= 0x3FF )
          return v12 + ((v11 - 55296) << 10) + 9216;
      }
    }
  }
  else
  {
    return 65533;
  }
  return v11;
}

//----- (0000000000411829) ----------------------------------------------------
_BOOL8 __fastcall sub_411829(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  _BOOL8 result; // rax

  v2 = sub_43AD53(a2);
  result = 0LL;
  if ( *(_DWORD *)(a1 + 24) == v2 )
    return (unsigned int)sub_41D6AC(a2, a1 + 32) == 0;
  return result;
}
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (0000000000411864) ----------------------------------------------------
__int64 __fastcall sub_411864(__int64 a1, _QWORD *a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  _DWORD *v6; // rax
  _DWORD *v7; // rdx

  v4 = sub_402F19(a1, 1536LL, a3, a4);
  a2[10] = v4;
  if ( v4 )
  {
    sub_43ABE2(v4, 0LL, 0x600uLL);
    v6 = (_DWORD *)a2[10];
    a2[13] = v6;
    a2[14] = v6;
    a2[11] = v6 + 256;
    v7 = v6 + 384;
    a2[12] = v6 + 384;
    do
    {
      *v6 = 2;
      v6 += 4;
    }
    while ( v6 != v7 );
    return 1LL;
  }
  else
  {
    sub_403142(a1);
    a2[10] = 0LL;
    return 0LL;
  }
}

//----- (00000000004118E4) ----------------------------------------------------
__int64 __fastcall sub_4118E4(__int64 a1, __int64 a2)
{
  return *(_QWORD *)(a2 + 80);
}

//----- (00000000004118E9) ----------------------------------------------------
__int64 __fastcall sub_4118E9(__int64 *a1, __int64 *a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  unsigned int v5; // eax
  char v7[272]; // [rsp+0h] [rbp-110h] BYREF

  v4 = sub_41CE24(a2);
  if ( v4 )
    return sub_407826(a1, v4 - 1, a3, a4);
  v5 = sub_41CE93(a2);
  return sub_406B69(a1, (__int64)v7, v5, a3, a4);
}
// 4118E9: using guessed type char var_110[272];

//----- (0000000000411944) ----------------------------------------------------
__int64 __fastcall sub_411944(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rcx
  unsigned __int64 v4; // r14
  char *v6; // rdi
  int v7; // er13
  int v8; // er15
  __int64 v9; // rbx
  unsigned int v10; // edx
  __int64 v11; // rbx
  int *v12; // rbx
  __int64 v13; // rax
  _DWORD *v14; // rbx
  int i; // ebx
  const signed __int32 *v16; // r13
  int v17; // eax
  __int64 v18; // rcx
  __int64 v19; // rdx
  int v20; // eax
  int v21; // eax
  int v22; // er15
  __int16 v23; // r13
  __int64 v24; // rdx
  char *v25; // r14
  unsigned int v26; // eax
  unsigned int v27; // eax
  int v28; // eax
  __int16 v29; // r14
  __int64 v30; // rsi
  __int64 v31; // rsi
  int v32; // er15
  __int64 v33; // r13
  int v34; // er14
  int v35; // edx
  __int64 (*v36)(); // r13
  __int64 v37; // rax
  __int16 v38; // ax
  int v39; // ebx
  _DWORD *v40; // rax
  __int64 v41; // rdx
  int v42; // esi
  __int64 v43; // rax
  int v45; // [rsp+0h] [rbp-160h]
  int v46; // [rsp+4h] [rbp-15Ch]
  unsigned int v47; // [rsp+4h] [rbp-15Ch]
  int v48; // [rsp+8h] [rbp-158h]
  __int16 v49; // [rsp+8h] [rbp-158h]
  __int16 v50; // [rsp+Ch] [rbp-154h]
  int v51; // [rsp+Ch] [rbp-154h]
  char *v52; // [rsp+10h] [rbp-150h] BYREF
  char v53; // [rsp+18h] [rbp-148h] BYREF
  __int64 v54; // [rsp+20h] [rbp-140h]
  __int64 v55; // [rsp+30h] [rbp-130h] BYREF
  char v56; // [rsp+38h] [rbp-128h] BYREF

  v3 = 6LL;
  v4 = 0LL;
  v6 = &v53;
  v52 = &byte_43F6C0;
  while ( v3 )
  {
    *(_DWORD *)v6 = 0;
    v6 += 4;
    --v3;
  }
  v54 = 4281LL;
  sub_404E3A(a1, 80, a2, a3);
  do
  {
    v7 = sub_41CE24((__int64 *)&v52);
    v8 = sub_41CE22(&v52, 3LL, 0xFFFFFFFFLL);
    switch ( v7 )
    {
      case 3:
        v9 = qword_440780[(unsigned int)sub_41CE24((__int64 *)&v52)];
        v10 = sub_41CE22(&v52, 3LL, (unsigned int)v8);
        if ( v10 == 7 )
          v10 = -1;
        sub_40739C(a1, v9, v10, a2, a3);
        v11 = sub_405B41((__int64)a1, -1);
        sub_4118E9(a1, (__int64 *)&v52, a2, a3);
        sub_403E13(a1, -33530620, a2, a3);
        if ( !(unsigned int)sub_41CDF1((__int64 *)&v52) )
          *(_DWORD *)v11 &= ~0x100u;
        *(_WORD *)(v11 + 66) = sub_41CE24((__int64 *)&v52);
        break;
      case 2:
        sub_4070BA(a1, a2, a3);
        break;
      case 15:
        v12 = sub_40D676(a1, 2013266048, a2, a3);
        sub_407C45(a1, (__int64)v12, a2, a3);
        v13 = sub_405B41((__int64)a1, 0);
        *((_QWORD *)v12 + 7) = v13;
        ++*(_DWORD *)(v13 + 4);
        break;
      default:
        sub_407003(a1, 16512, -1, a2, a3);
        break;
    }
    v14 = (_DWORD *)sub_405B41((__int64)a1, -1);
    *v14 = (v7 << 27) | *v14 & 0x7FFFFFF;
    if ( v4 <= 0x32 )
    {
      a1[v4 + 20] = (__int64)v14;
      ++v14[1];
    }
    if ( v8 >= 0 )
    {
      sub_406A68(a1, v8, a2, a3);
      sub_403E13(a1, -33532156, a2, a3);
    }
    if ( v7 == 12 )
      *v14 |= 0x800000u;
    ++v4;
  }
  while ( v4 != 80 );
  for ( i = 0; i != 80; ++i )
  {
    v16 = (const signed __int32 *)sub_405B41((__int64)a1, i);
    v17 = sub_41CE24((__int64 *)&v52);
    if ( v17 )
    {
      v19 = sub_405B41((__int64)a1, v17 - 1);
    }
    else
    {
      if ( !_bittest(v16, 0xCu) )
        goto LABEL_29;
      v19 = a1[25];
    }
    sub_40DCFB((__int64)a1, (__int64)v16, v19, v18, a2, a3);
LABEL_29:
    v20 = sub_41CE24((__int64 *)&v52);
    if ( v20 )
    {
      sub_404F0A(a1, v20 - 1, a2, a3);
      sub_403DDC(a1, i, 0x32u, 0, a2, a3);
    }
    v21 = sub_41CE24((__int64 *)&v52);
    if ( v21 )
    {
      sub_404F0A(a1, v21 - 1, a2, a3);
      sub_403DDC(a1, i, 0x33u, 5, a2, a3);
    }
    v22 = 0;
    v48 = sub_41CE24((__int64 *)&v52);
    while ( v22 != v48 )
    {
      sub_4118E9(a1, (__int64 *)&v52, a2, a3);
      v50 = sub_41CDF8((__int64 *)&v52, 3);
      v23 = v50 | 0x278;
      switch ( (unsigned int)sub_41CDA5((__int64 *)&v52, 3) )
      {
        case 0u:
          v25 = (char *)&v55;
          do
            *v25++ = sub_41CDA5((__int64 *)&v52, 8);
          while ( &v56 != v25 );
          a2.i64[0] = v55;
          sub_406A1B(a1, a2, a3);
          break;
        case 1u:
          v26 = sub_41CE93((__int64 *)&v52);
          sub_406B69(a1, (__int64)&v55, v26, a2, a3);
          break;
        case 2u:
          v27 = sub_41CE24((__int64 *)&v52);
          sub_407826(a1, v27, a2, a3);
          break;
        case 3u:
          v28 = sub_41CE24((__int64 *)&v52);
          sub_404F0A(a1, v28, a2, a3);
          break;
        case 4u:
          sub_4068D1(a1, 3LL, v24, a2, a3);
          break;
        case 5u:
          sub_40699D(a1, a2, a3, 3LL, v24);
          break;
        case 6u:
          sub_4069DC(a1, a2, a3, 3LL, v24);
          break;
        case 7u:
          v46 = sub_41CE24((__int64 *)&v52);
          v45 = sub_41CE24((__int64 *)&v52);
          v29 = sub_41CE24((__int64 *)&v52);
          v30 = qword_440780[v46];
          if ( v30 )
          {
            sub_4073AC(a1, v30, 0, a2, a3);
            sub_41DD48(a1, -1, v29, a2, a3);
            v23 = v50 | 0x2F8;
          }
          v31 = qword_440780[v45];
          if ( v31 )
          {
            v23 |= 0x100u;
            sub_4073AC(a1, v31, 1u, a2, a3);
            sub_41DD48(a1, -1, v29, a2, a3);
          }
          v23 = v23 & 0xFF87 | 0x30;
          break;
      }
      ++v22;
      sub_403E29(a1, i, v23, a2, a3);
    }
    v32 = 0;
    v51 = sub_41CE24((__int64 *)&v52);
    while ( v32 != v51 )
    {
      sub_4118E9(a1, (__int64 *)&v52, a2, a3);
      sub_405B3C((__int64)a1, -1);
      v33 = (unsigned int)sub_41CE24((__int64 *)&v52);
      v34 = sub_41CDA5((__int64 *)&v52, 3);
      v35 = sub_41CDF8((__int64 *)&v52, 3);
      if ( v35 == 7 )
        v35 = -1;
      v36 = (__int64 (*)())qword_440780[v33];
      v47 = v35;
      v49 = sub_41CE24((__int64 *)&v52);
      sub_4073AC(a1, (__int64)v36, v47, a2, a3);
      v37 = sub_405B50((__int64)a1, -1);
      if ( v36 == sub_41F331
        || v36 == sub_41F32B
        || v36 == sub_41F325
        || (char *)v36 == (char *)sub_41FC62
        || v36 == sub_41F337 )
      {
        *(_DWORD *)v37 |= 0x4000000u;
      }
      *(_DWORD *)v37 |= 0x10000u;
      *(_WORD *)(v37 + 66) = v49;
      ++v32;
      sub_406AAF(a1, v34, a2, a3);
      sub_403E13(a1, -33532156, a2, a3);
      sub_404FF1(a1, a2, a3);
      sub_403E13(a1, -33530620, a2, a3);
      v38 = sub_41CDF8((__int64 *)&v52, 3);
      sub_403E29(a1, i, v38 | 0x278, a2, a3);
    }
  }
  v39 = 0;
  sub_4037B9(a1, 1048617, a2, a3);
  sub_403E13(a1, 268446469, a2, a3);
  v40 = (_DWORD *)sub_405B41((__int64)a1, 37);
  *v40 &= ~0x80u;
  sub_406D71(a1, (__int64)"ll u nl p2 a8 x64 linux gcc", v41, a2, a3);
  sub_403E13(a1, 570453765, a2, a3);
  do
  {
    v42 = v39++;
    v43 = sub_405B41((__int64)a1, v42);
    sub_40E4C4(a1, v43, a2, a3);
  }
  while ( v39 != 80 );
  return sub_404B20(a1, 0, a2, a3);
}
// 411B54: variable 'v18' is possibly undefined
// 411CC7: variable 'v24' is possibly undefined
// 411F52: variable 'v41' is possibly undefined
// 41CE22: using guessed type __int64 __fastcall sub_41CE22(_QWORD, _QWORD, _QWORD);
// 43F6C0: using guessed type char byte_43F6C0;
// 440780: using guessed type __int64 qword_440780[];

//----- (0000000000411F9C) ----------------------------------------------------
__int64 __fastcall sub_411F9C(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx

  for ( result = 160LL; result != 568; result += 8LL )
  {
    v3 = *(_QWORD *)(a1 + result);
    *(_QWORD *)(a2 + result) = v3;
    if ( v3 )
      ++*(_DWORD *)(v3 + 4);
  }
  return result;
}

//----- (0000000000411FBE) ----------------------------------------------------
__int64 __fastcall sub_411FBE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx

  while ( *(_QWORD *)(a1 + 120) )
    sub_4121C6((__int64 *)a1, a2, a3, a4, a5, a6);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 80);
  sub_404B20((_QWORD *)a1, 0, a5, a6);
  *(_BYTE *)(a1 + 73) = 5;
  return sub_40CA54(a1, 0LL, v6, v7, a5, a6);
}
// 411FD3: variable 'a3' is possibly undefined
// 411FD3: variable 'a4' is possibly undefined
// 411FFB: variable 'v6' is possibly undefined
// 411FFB: variable 'v7' is possibly undefined

//----- (0000000000412000) ----------------------------------------------------
__int64 __fastcall sub_412000(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rax

  v2 = *(_QWORD *)(a2 + 16);
  result = 0LL;
  if ( v2 )
  {
    result = *(_DWORD *)v2 & 0x800;
    if ( (*(_DWORD *)v2 & 0x800) != 0 )
    {
      v4 = (__int64)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(v2 + 72)) >> 2;
      return ((_DWORD)v4 == 0) + (unsigned int)v4 - 1;
    }
  }
  return result;
}

//----- (000000000041203C) ----------------------------------------------------
__int64 *__fastcall sub_41203C(__int64 a1)
{
  __int64 *result; // rax
  __int64 v2; // rdx

  result = *(__int64 **)(a1 + 56);
  if ( result )
  {
    v2 = *result;
    result = *(__int64 **)(a1 + 120);
    result[7] = v2;
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  return result;
}

//----- (0000000000412059) ----------------------------------------------------
__int64 __fastcall sub_412059(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v7; // r12
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v11; // rax

  v7 = *(_QWORD *)(a2 + 48);
  if ( *(char *)(v7 + 32) < 0 )
  {
    v8 = *(_QWORD *)(a2 + 40);
    v9 = *(_QWORD *)(v8 + 32);
    *(_QWORD *)(a2 + 40) = v9;
    ++*(_DWORD *)(v9 + 4);
    if ( (*(_DWORD *)(v8 + 4))-- == 1 )
      sub_40CAE2(a1, v8, a3, a4, a5, a6);
  }
  *(_QWORD *)(a2 + 48) = *(_QWORD *)v7;
  v11 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)v7 = *(_QWORD *)(v11 + 80);
  *(_QWORD *)(v11 + 80) = v7;
  return a3;
}

//----- (00000000004120AE) ----------------------------------------------------
__int64 __fastcall sub_4120AE(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 i; // rbx
  __int64 result; // rax
  __int64 v8; // rsi
  __int64 v9; // rsi
  bool v10; // zf
  __int64 v11; // rsi
  __int64 v12; // rsi

  for ( i = a1[15]; *(_QWORD *)(i + 48); sub_412059((__int64)a1, i, a5, a6, a2, a3) )
    ;
  result = *(_QWORD *)(i + 16);
  if ( !result || (result = *(unsigned int *)result, (result & 0x40000) != 0) )
  {
    v8 = *(_QWORD *)(i + 32);
    if ( v8 )
      result = sub_4187BD(a1, v8, a5, a6, a2, a3);
  }
  if ( (*(_BYTE *)(i + 88) & 8) != 0 )
    --a1[17];
  v9 = *(_QWORD *)(i + 32);
  if ( v9 )
  {
    v10 = (*(_DWORD *)(v9 + 4))-- == 1;
    if ( v10 )
      result = sub_40CAE2((__int64)a1, v9, a5, a6, a2, a3);
  }
  v11 = *(_QWORD *)(i + 40);
  if ( v11 )
  {
    v10 = (*(_DWORD *)(v11 + 4))-- == 1;
    if ( v10 )
      result = sub_40CAE2((__int64)a1, v11, a5, a6, a2, a3);
  }
  v12 = *(_QWORD *)(i + 16);
  if ( v12 )
  {
    v10 = (*(_DWORD *)(v12 + 4))-- == 1;
    if ( v10 )
      return sub_40CAE2((__int64)a1, v12, a5, a6, a2, a3);
  }
  return result;
}
// 4120C9: variable 'a5' is possibly undefined
// 4120C9: variable 'a6' is possibly undefined

//----- (000000000041214B) ----------------------------------------------------
_QWORD *__fastcall sub_41214B(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v3; // rdx

  result = *(_QWORD **)(a2 + 48);
  *(_QWORD *)(a2 + 48) = *result;
  v3 = *(_QWORD *)(a1 + 64);
  *result = *(_QWORD *)(v3 + 80);
  *(_QWORD *)(v3 + 80) = result;
  return result;
}

//----- (0000000000412166) ----------------------------------------------------
_QWORD *__fastcall sub_412166(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  _QWORD *result; // rax

  v3 = a1[8];
  result = *(_QWORD **)(v3 + 80);
  if ( !result )
    return (_QWORD *)sub_402FA0(a1, 40LL, a2, a3);
  *(_QWORD *)(v3 + 80) = *result;
  return result;
}

//----- (0000000000412195) ----------------------------------------------------
__int64 __fastcall sub_412195(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 result; // rax

  v3 = a1[8];
  result = *(_QWORD *)(v3 + 72);
  if ( !result )
    return sub_402FA0(a1, 96LL, a2, a3);
  *(_QWORD *)(v3 + 72) = *(_QWORD *)(result + 24);
  return result;
}

//----- (00000000004121C6) ----------------------------------------------------
__int64 __fastcall sub_4121C6(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rdx

  sub_4120AE(a1, a5, a6, a2, a3, a4);
  result = a1[15];
  v7 = *(_QWORD *)(result + 24);
  --a1[16];
  a1[15] = v7;
  v8 = a1[8];
  *(_QWORD *)(result + 24) = *(_QWORD *)(v8 + 72);
  *(_QWORD *)(v8 + 72) = result;
  return result;
}

//----- (0000000000412200) ----------------------------------------------------
__int64 __fastcall sub_412200(__int64 a1, int a2)
{
  __int64 result; // rax

  result = 0LL;
  if ( a2 < 0 )
  {
    result = *(_QWORD *)(a1 + 120);
    while ( result && a2 != -1 )
    {
      result = *(_QWORD *)(result + 24);
      ++a2;
    }
  }
  return result;
}

//----- (000000000041221D) ----------------------------------------------------
__int64 __fastcall sub_41221D(__int64 a1, int a2, int a3)
{
  __int64 result; // rax

  if ( a2 >= 0 )
  {
    result = *(_QWORD *)(a1 + 1816);
    *(_DWORD *)(result + 8LL * a2) = ((a3 - a2 + 0x7FFFFF) << 8) | 2;
  }
  return result;
}

//----- (000000000041223D) ----------------------------------------------------
__int64 __fastcall sub_41223D(__int64 a1, int a2)
{
  return sub_41221D(a1, a2, (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3);
}

//----- (0000000000412251) ----------------------------------------------------
__int64 __fastcall sub_412251(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 *v3; // r12
  int v4; // eax
  int v5; // er13
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 result; // rax

  v3 = *(__int64 **)a1;
  sub_404AE7(*(_QWORD *)a1);
  sub_43ABE2(a1 + 1808, 0LL, 0xD8uLL);
  v5 = v4;
  sub_404E3A(v3, 16, a2, a3);
  sub_41CF97(v3, (_QWORD *)(a1 + 1808), 0x800uLL, a2, a3);
  sub_407108(v3, a2, a3);
  v6 = 16 * (v5 + 1LL);
  *(_DWORD *)(a1 + 1904) = v5 + 1;
  *(_QWORD *)(a1 + 1848) = *(_QWORD *)(v3[13] + v6 + 8);
  sub_407108(v3, a2, a3);
  *(_DWORD *)(a1 + 1908) = v5 + 2;
  *(_QWORD *)(a1 + 1856) = *(_QWORD *)(v3[13] + v6 + 24);
  sub_407108(v3, a2, a3);
  *(_DWORD *)(a1 + 1912) = v5 + 3;
  *(_QWORD *)(a1 + 1864) = *(_QWORD *)(v3[13] + v6 + 40);
  sub_407108(v3, a2, a3);
  *(_DWORD *)(a1 + 1916) = v5 + 4;
  *(_QWORD *)(a1 + 1872) = *(_QWORD *)(v3[13] + v6 + 56);
  sub_40762B(v3, 0LL, 1, a2, a3);
  *(_DWORD *)(a1 + 1920) = v5 + 5;
  *(_QWORD *)(a1 + 1880) = sub_405B46((__int64)v3, v5 + 5);
  sub_407108(v3, a2, a3);
  *(_DWORD *)(a1 + 1924) = v5 + 6;
  *(_QWORD *)(a1 + 1888) = *(_QWORD *)(v3[13] + v6 + 88);
  sub_40779C(v3, a2, a3);
  v7 = v3[13];
  *(_DWORD *)(a1 + 1928) = v5 + 7;
  result = *(_QWORD *)(v7 + v6 + 104);
  *(_QWORD *)(a1 + 1896) = result;
  return result;
}
// 412288: variable 'v4' is possibly undefined

//----- (00000000004123AE) ----------------------------------------------------
__int64 __fastcall sub_4123AE(
        __int64 *a1,
        __int64 a2,
        int a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        __m128 a7,
        __m128 a8,
        _DWORD *a9)
{
  __int64 v9; // rax
  __int64 *v10; // r11
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdi
  unsigned __int64 i; // rax
  _BYTE *v14; // r10
  unsigned int v15; // edx
  __int64 result; // rax

  v9 = a1[235];
  v10 = (__int64 *)*a1;
  v11 = *(_QWORD *)(v9 + 32);
  v12 = v11 + *(_QWORD *)(v9 + 24);
  for ( i = v12; ; i -= 24LL )
  {
    if ( i <= v11 )
    {
      v15 = 83889230;
      return sub_401C42(v10, (__int64)"third_party/duktape/duk_js_compiler.c", v15, "invalid label", a7, a8);
    }
    v14 = (_BYTE *)(i - 24);
    if ( *(_QWORD *)(i - 16) == a2 )
      break;
LABEL_8:
    ;
  }
  if ( !a3 && (*v14 & 2) == 0 )
  {
    if ( *(_QWORD *)(v10[71] + 120) != a2 )
    {
      v15 = 83889219;
      return sub_401C42(v10, (__int64)"third_party/duktape/duk_js_compiler.c", v15, "invalid label", a7, a8);
    }
    goto LABEL_8;
  }
  *a4 = *(_DWORD *)(i - 20);
  *a5 = *(_DWORD *)(i - 8);
  *a6 = *(_DWORD *)(i - 4);
  result = v14 == (_BYTE *)(v12 - 24);
  *a9 = result;
  return result;
}

//----- (0000000000412449) ----------------------------------------------------
unsigned __int8 __fastcall sub_412449(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // r13
  int v5; // eax
  int v6; // er12
  __int64 v8; // rcx
  __int64 v9; // rcx

  v4 = *(__int64 **)a1;
  v5 = *(_DWORD *)(a1 + 1720);
  if ( *(_BYTE *)(a1 + 2020) )
  {
    *(_BYTE *)(a1 + 2020) = 0;
    v6 = 0;
  }
  else
  {
    v6 = (((unsigned __int8)byte_43D280[v5] >> 5) ^ 1) & 1;
  }
  if ( *(_BYTE *)(a1 + 2021) )
  {
    *(_BYTE *)(a1 + 2021) = 0;
    v6 = 1;
  }
  if ( a2 != -1 && v5 != a2 )
    return sub_401C42(v4, (__int64)"third_party/duktape/duk_js_compiler.c", 0x5000274u, "parse error", a3, a4);
  sub_43AAA0(a1 + 1664, a1 + 1720, 0x38uLL);
  sub_4050B6(v4, *(_DWORD *)(a1 + 1776), *(_DWORD *)(a1 + 1784), v8, a3, a4);
  sub_4050B6(v4, *(_DWORD *)(a1 + 1780), *(_DWORD *)(a1 + 1788), v9, a3, a4);
  return sub_418FE2((int **)(a1 + 16), a1 + 1720, *(unsigned __int8 *)(a1 + 2010), v6, a3, a4);
}
// 4124F2: variable 'v8' is possibly undefined
// 412506: variable 'v9' is possibly undefined

//----- (0000000000412529) ----------------------------------------------------
unsigned __int8 __fastcall sub_412529(__int64 a1, __m128 a2, __m128 a3)
{
  return sub_412449(a1, -1, a2, a3);
}

//----- (0000000000412531) ----------------------------------------------------
__int64 __fastcall sub_412531(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // er12
  __int64 *v4; // r13
  int v5; // ebx
  __int64 v6; // r15
  _DWORD *v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  int v11; // eax
  int v13; // [rsp+Ch] [rbp-34h]

  v3 = 256;
  v4 = *(__int64 **)a1;
  v5 = sub_405CB0(*(__int64 **)a1, *(_DWORD *)(a1 + 1904), a2, a3);
  if ( v5 <= 256 )
    v3 = v5;
  v6 = 0LL;
  v7 = (_DWORD *)(v4[14] - 16);
  while ( 1 )
  {
    v13 = v6;
    if ( v3 <= (int)v6 )
      break;
    v8 = v6++;
    if ( (unsigned int)sub_417B16(
                         0LL,
                         v7,
                         (_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 1848) + 24LL)
                                  + 16 * v8
                                  + 25LL * *(unsigned int *)(*(_QWORD *)(a1 + 1848) + 40LL)
                                  + (-*(_DWORD *)(*(_QWORD *)(a1 + 1848) + 40LL) & 7)),
                         1,
                         a2,
                         a3) )
    {
      sub_407D7E(v4, (__int64)v7, v9, v10, a2, a3);
      v11 = v13;
      return v11 | 0x80000000;
    }
  }
  if ( v5 > 0xFFFF )
  {
    sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", 2305, "const limit", a2, a3);
    return 0LL;
  }
  sub_403953(v4, *(_DWORD *)(a1 + 1904), v5, a2, a3);
  v11 = v5;
  return v11 | 0x80000000;
}
// 4125C1: variable 'v9' is possibly undefined
// 4125C1: variable 'v10' is possibly undefined

//----- (0000000000412615) ----------------------------------------------------
__int64 __fastcall sub_412615(__int64 a1, int *a2, _DWORD *a3, __m128 a4, __m128 a5)
{
  __int64 *v6; // r15
  __int64 *v7; // r13
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  int v15; // eax
  int v16; // [rsp+Ch] [rbp-34h]

  v6 = *(__int64 **)a1;
  sub_404F67(*(__int64 **)a1, a4, a5);
  v7 = *(__int64 **)a1;
  if ( *(_QWORD *)(v7[71] + 536) == sub_405B3C(*(_QWORD *)a1, -1) )
    *(_BYTE *)(a1 + 2015) = 1;
  if ( *(int *)(a1 + 1988) > 0 )
    goto LABEL_10;
  sub_403616(v7, *(_DWORD *)(a1 + 1928), a4, a5);
  if ( !sub_4064DB((__int64)v7, -1) )
  {
    sub_407D7E(v7, 0xFFFFFFFFLL, v8, v9, a4, a5);
    if ( *(int *)(a1 + 1984) <= 0 && *(int *)(a1 + 1988) <= 0 )
    {
      *(_BYTE *)(a1 + 2016) = 1;
      goto LABEL_11;
    }
LABEL_10:
    *(_WORD *)(a1 + 2016) = 257;
    goto LABEL_11;
  }
  v16 = sub_405DB7(v7, -1, a4, a5);
  sub_407D7E(v7, 0xFFFFFFFFLL, v10, v11, a4, a5);
  if ( v16 >= 0 )
  {
    *a2 = v16;
    *a3 = 0;
    sub_407D7E(v6, 0xFFFFFFFFLL, v12, v13, a4, a5);
    return 1LL;
  }
LABEL_11:
  v15 = sub_412531(a1, a4, a5);
  *a2 = -1;
  *a3 = v15;
  return 0LL;
}
// 41269D: variable 'v10' is possibly undefined
// 41269D: variable 'v11' is possibly undefined
// 4126B5: variable 'v12' is possibly undefined
// 4126B5: variable 'v13' is possibly undefined
// 4126C4: variable 'v8' is possibly undefined
// 4126C4: variable 'v9' is possibly undefined

//----- (0000000000412717) ----------------------------------------------------
__int64 __fastcall sub_412717(__int64 a1, __int64 a2, int a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v8; // rax
  __int64 *v9; // r13
  __int64 v10; // r14
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rax
  __int64 result; // rax
  int v14; // edx

  v8 = *(_QWORD *)(a1 + 1880);
  v9 = *(__int64 **)a1;
  v10 = *(_QWORD *)(v8 + 24);
  v11 = *(_QWORD *)(v8 + 32);
  v12 = v11 + v10;
  while ( v12 > v11 )
  {
    v12 -= 24LL;
    if ( *(_QWORD *)(v12 + 8) == a2 && *(_QWORD *)(v9[71] + 120) != a2 )
      return sub_401C42(v9, (__int64)"third_party/duktape/duk_js_compiler.c", 0x5000BACu, "duplicate label", a5, a6);
  }
  sub_407808(v9, a2, a5, a6);
  sub_403953(v9, *(_DWORD *)(a1 + 1916), -1431655765 * (v10 >> 3), a5, a6);
  sub_4200FB(v9, *(_QWORD *)(a1 + 1880), v10 + 24, a5, a6);
  result = *(_QWORD *)(*(_QWORD *)(a1 + 1880) + 32LL) + *(_QWORD *)(*(_QWORD *)(a1 + 1880) + 24LL);
  v14 = *(_DWORD *)(a1 + 1984);
  *(_DWORD *)(result - 24) = 1;
  *(_DWORD *)(result - 20) = a4;
  *(_QWORD *)(result - 16) = a2;
  *(_DWORD *)(result - 8) = v14;
  *(_DWORD *)(result - 4) = a3;
  return result;
}

//----- (0000000000412810) ----------------------------------------------------
_DWORD *__fastcall sub_412810(__int64 a1, int a2, int a3)
{
  unsigned __int64 v3; // rcx
  _DWORD *result; // rax

  v3 = *(_QWORD *)(a1 + 32);
  for ( result = (_DWORD *)(v3 + *(_QWORD *)(a1 + 24)); v3 < (unsigned __int64)result; *result = a3 )
  {
    result -= 6;
    if ( result[1] != a2 )
      break;
  }
  return result;
}

//----- (000000000041282E) ----------------------------------------------------
__int64 __fastcall sub_41282E(__int64 *a1, _DWORD *a2, _DWORD *a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // rax
  __int64 *v10; // rdi
  int v11; // eax
  int v12; // esi
  __int64 v14; // [rsp-8h] [rbp-20h]

  v14 = v6;
  v10 = (__int64 *)*a1;
  *a3 = *a2;
  a3[1] = a2[1];
  a3[2] = a2[2];
  a3[3] = a2[3];
  a3[5] = a2[5];
  v11 = a2[6];
  v12 = a2[4];
  a3[6] = v11;
  sub_4050B6(v10, v12, a3[4], a4, a5, a6);
  return sub_4050B6((__int64 *)*a1, a2[7], a3[7], v14, a5, a6);
}
// 412840: variable 'v6' is possibly undefined

//----- (0000000000412889) ----------------------------------------------------
__int64 __fastcall sub_412889(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  __int64 result; // rax

  v3 = *(_DWORD *)(a1 + 1792);
  if ( v3 >= *(_DWORD *)(a1 + 1796) )
    return sub_401CE2(
             *(__int64 **)a1,
             (__int64)"third_party/duktape/duk_js_compiler.c",
             560,
             "compiler recursion limit",
             a2,
             a3);
  result = (unsigned int)(v3 + 1);
  *(_DWORD *)(a1 + 1792) = result;
  return result;
}

//----- (00000000004128B7) ----------------------------------------------------
__int64 __fastcall sub_4128B7(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  int v5; // esi

  result = *(unsigned int *)(a1 + 1936);
  v5 = result + a2;
  *(_DWORD *)(a1 + 1936) = v5;
  if ( v5 <= 0xFFFF )
  {
    if ( v5 > *(_DWORD *)(a1 + 1940) )
      *(_DWORD *)(a1 + 1940) = v5;
  }
  else
  {
    sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", 2241, "temp limit", a3, a4);
    return 0LL;
  }
  return result;
}

//----- (00000000004128FC) ----------------------------------------------------
__int64 __fastcall sub_4128FC(__int64 a1, __m128 a2, __m128 a3)
{
  return sub_4128B7(a1, 1, a2, a3);
}

//----- (0000000000412903) ----------------------------------------------------
_DWORD *__fastcall sub_412903(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  _DWORD *result; // rax
  __int64 v6; // rdi
  int v7; // ecx
  unsigned __int64 v8; // rdx

  result = *(_DWORD **)(a1 + 1808);
  if ( *(_QWORD *)(a1 + 1824) - (_QWORD)result <= 7uLL )
    result = (_DWORD *)sub_41CFE2(*(__int64 **)a1, (_QWORD *)(a1 + 1808), 8LL, a3, a4);
  v6 = *(_QWORD *)(a1 + 1808);
  v7 = *(_DWORD *)(a1 + 1704);
  *(_QWORD *)(a1 + 1808) = v6 + 8;
  if ( !v7 )
    v7 = *(_DWORD *)(a1 + 1760);
  v8 = v6 + 8 - *(_QWORD *)(a1 + 1816);
  *result = a2;
  result[1] = v7;
  if ( v8 > 0x7FFF0000 || v7 > 2147418112 )
    return (_DWORD *)sub_401CE2(
                       *(__int64 **)a1,
                       (__int64)"third_party/duktape/duk_js_compiler.c",
                       1379,
                       "bytecode limit",
                       a3,
                       a4);
  return result;
}

//----- (000000000041299B) ----------------------------------------------------
__int64 __fastcall sub_41299B(__int64 a1, __m128 a2, __m128 a3)
{
  unsigned __int64 v3; // rbx

  v3 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
  sub_412903(a1, 2, a2, a3);
  return (unsigned int)(v3 >> 3);
}

//----- (00000000004129C3) ----------------------------------------------------
_DWORD *__fastcall sub_4129C3(__int64 a1, __m128 a2, __m128 a3)
{
  return sub_412903(a1, 206, a2, a3);
}

//----- (00000000004129CD) ----------------------------------------------------
__int64 __fastcall sub_4129CD(_QWORD **a1, __m128 a2, __m128 a3)
{
  __int64 *v4; // r12
  int *v5; // rbx
  __int64 v6; // rcx
  int v7; // eax
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // r13
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r9
  __int64 i; // r8
  __m128 *v15; // rax
  __int64 v16; // r15
  __int64 v17; // r8
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  _QWORD *v21; // r15
  __int64 v22; // rax
  _QWORD *v23; // rsi
  __int64 v24; // rsi
  _QWORD *v25; // rdi
  __int64 v26; // rdx
  __int64 v27; // r8
  __int64 *v28; // rax
  __int64 v29; // r9
  __int64 v31; // rdx
  __int64 v32; // rcx
  _QWORD *v33; // rsi
  _QWORD *v34; // rsi
  __int64 v36; // [rsp+8h] [rbp-58h]
  __int64 v37; // [rsp+10h] [rbp-50h]
  __int64 v38; // [rsp+10h] [rbp-50h]
  __int64 v39; // [rsp+18h] [rbp-48h]
  __int64 v40; // [rsp+18h] [rbp-48h]
  __int64 v41; // [rsp+20h] [rbp-40h]
  unsigned __int64 v42; // [rsp+28h] [rbp-38h]
  int v43; // [rsp+28h] [rbp-38h]

  v4 = *a1;
  v5 = sub_407292(*a1, a2, a3);
  sub_40DCFB((__int64)v4, (__int64)v5, 0LL, v6, a2, a3);
  if ( *((_BYTE *)a1 + 2004) )
  {
    v7 = *v5;
    *v5 |= 0x40000u;
    if ( !*((_BYTE *)a1 + 2018) && *((_WORD *)a1 + 1007) )
      *v5 = v7 | 0x140000;
    if ( *((_BYTE *)a1 + 2007) && a1[230] )
      *v5 |= 0x80000u;
LABEL_11:
    if ( !*((_BYTE *)a1 + 2010) )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( !*((_BYTE *)a1 + 2005) )
    goto LABEL_11;
  if ( !*((_BYTE *)a1 + 2010) )
    goto LABEL_13;
  *v5 |= 0x40000u;
LABEL_12:
  *v5 |= 0x10000u;
LABEL_13:
  if ( *((_BYTE *)a1 + 2011) )
    *v5 |= 0x20000u;
  if ( *((_BYTE *)a1 + 2008) )
    *v5 |= 0x100u;
  v8 = sub_4106A4(v4, (__int64)a1[231], a2, a3);
  v42 = sub_4106A4(v4, (__int64)a1[232], a2, a3);
  v9 = (unsigned __int64)((char *)a1[226] - (char *)a1[227]) >> 3;
  sub_4076DF(v4, 4 * v9 + 8 * (v42 / 3 + 2 * v8), a2, a3);
  v10 = 0xFFFFFFFFLL;
  v11 = sub_405B46((__int64)v4, -1);
  *((_QWORD *)v5 + 7) = v11;
  ++*(_DWORD *)(v11 + 4);
  v13 = v11;
  for ( i = 0LL; i != v8; i = v39 + 1 )
  {
    v10 = (__int64)a1[231];
    v37 = v13;
    v39 = i;
    v15 = (__m128 *)sub_40E68B(v4[8], v10, i);
    v13 = v37;
    a2 = *v15;
    *(__m128 *)(v37 + 16 * v39 + 32) = *v15;
    if ( (v15->i8[0] & 8) != 0 )
      ++*(_DWORD *)(v15->i64[1] + 4);
  }
  v16 = 0LL;
  v17 = v13 + 16 * i + 32;
  *((_QWORD *)v5 + 8) = v17;
  while ( v16 != v42 / 3 )
  {
    v10 = (__int64)a1[232];
    v40 = v17;
    v18 = sub_40E68B(v4[8], v10, 3 * (int)v16);
    v17 = v40;
    v19 = *(_QWORD *)(v18 + 8);
    *(_QWORD *)(v40 + 8 * v16) = v19;
    ++*(_DWORD *)(v19 + 4);
    ++v16;
  }
  v20 = v17 + 8 * v16;
  v21 = a1[227];
  v22 = 0LL;
  *((_QWORD *)v5 + 9) = v20;
  while ( v22 != v9 )
  {
    v10 = LODWORD(v21[v22]);
    *(_DWORD *)(v20 + 4 * v22++) = v10;
  }
  sub_407D7E(v4, v10, v20, v12, a2, a3);
  v23 = a1[236];
  *((_WORD *)v5 + 48) = *((_DWORD *)a1 + 485);
  *((_WORD *)v5 + 49) = sub_4106A4(v4, (__int64)v23, a2, a3);
  if ( *((_BYTE *)a1 + 2017) || *((_WORD *)a1 + 1007) || v42 > 2 )
  {
    v24 = *((unsigned int *)a1 + 482);
    sub_404F0A(v4, v24, a2, a3);
    v25 = *a1;
    v26 = 0LL;
    v43 = 0;
    v27 = *(_QWORD *)((*a1)[14] - 8LL);
    v41 = 8LL * *(unsigned int *)(v27 + 44);
    while ( v41 != v26 )
    {
      v24 = *(_QWORD *)(v27 + 24);
      v28 = (__int64 *)(v24 + v26 + 16LL * *(unsigned int *)(v27 + 40));
      v29 = *v28;
      if ( *v28 )
      {
        if ( *(_DWORD *)(v24 + 2 * v26) )
        {
          *v28 = 0LL;
          if ( (*(_DWORD *)(v29 + 4))-- == 1 )
          {
            v24 = v29;
            v36 = v26;
            v38 = v27;
            sub_40CA67((__int64)v25, v29);
            v27 = v38;
            v26 = v36;
          }
        }
        else
        {
          ++v43;
        }
      }
      v26 += 8LL;
    }
    sub_403FED(v25, a2, a3);
    if ( v43 )
      sub_403E13(v4, -33528832, a2, a3);
    else
      sub_407D7E(v4, v24, v31, v32, a2, a3);
  }
  if ( *((unsigned __int16 *)v5 + 49) != sub_405CB0(v4, *((_DWORD *)a1 + 481), a2, a3)
    || *((_WORD *)a1 + 1007) && *((_WORD *)v5 + 49) )
  {
    sub_404F0A(v4, *((_DWORD *)a1 + 481), a2, a3);
    sub_403E13(v4, -33529088, a2, a3);
  }
  v33 = a1[230];
  if ( v33 )
  {
    sub_407808(v4, (__int64)v33, a2, a3);
    sub_403E13(v4, -33530624, a2, a3);
  }
  sub_42014B(v4, (__int64)v21, v9, a2, a3);
  sub_403E13(v4, -33528320, a2, a3);
  v34 = a1[1];
  if ( v34 )
  {
    sub_407808(v4, (__int64)v34, a2, a3);
    sub_403E13(v4, -33530368, a2, a3);
  }
  return sub_403FED(v4, a2, a3);
}
// 4129F7: variable 'v6' is possibly undefined
// 412BC1: variable 'v12' is possibly undefined
// 412CAE: variable 'v31' is possibly undefined
// 412CAE: variable 'v32' is possibly undefined

//----- (0000000000412D6A) ----------------------------------------------------
_DWORD *__fastcall sub_412D6A(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // esi

  v4 = a2 - ((unsigned __int64)(a1[226] - a1[227]) >> 3) + 0x7FFFFF;
  if ( v4 <= 0xFFFFFF )
    return sub_412903((__int64)a1, (v4 << 8) | 2u, a3, a4);
  else
    return (_DWORD *)sub_401CE2(
                       (__int64 *)*a1,
                       (__int64)"third_party/duktape/duk_js_compiler.c",
                       1832,
                       "register limit",
                       a3,
                       a4);
}

//----- (0000000000412DAE) ----------------------------------------------------
_DWORD *__fastcall sub_412DAE(__int64 a1, __int16 a2, int a3, int a4, __m128 a5, __m128 a6)
{
  int v6; // ebx
  int v7; // esi
  int v8; // er12
  int v10; // er12
  int v11; // er14
  int v12; // er12
  int v13; // er14
  __int64 v14; // [rsp+8h] [rbp-28h]

  if ( (a4 & 0x7FFF0000) == 0 )
  {
    v6 = a4 & 0x7FFFFFFF;
    if ( a3 <= 255 )
    {
      v7 = (a4 << 16) | (unsigned __int8)a2 | (a3 << 8);
      return sub_412903(a1, v7, a5, a6);
    }
    if ( (a2 & 0x100) == 0 )
    {
      if ( (a2 & 0xF0) == 176 )
      {
        v8 = *(_DWORD *)(a1 + 1944);
        *(_BYTE *)(a1 + 2019) = 1;
        v14 = a1;
        sub_412F21(a1, v8, a3, a5, a6);
        v7 = (v6 << 16) | (unsigned __int8)a2 | (v8 << 8) | 8;
LABEL_7:
        a1 = v14;
        return sub_412903(a1, v7, a5, a6);
      }
      if ( a3 <= 0xFFFF )
      {
        v10 = *(_DWORD *)(a1 + 1944);
        *(_BYTE *)(a1 + 2019) = 1;
        v10 <<= 8;
        v11 = v10 | (unsigned __int8)a2;
        v12 = (a3 << 16) | v10;
        v13 = (a4 << 16) | v11;
        v14 = a1;
        if ( (a2 & 0x800) != 0 )
        {
          sub_412903(a1, v12, a5, a6);
          v7 = v13;
        }
        else
        {
          sub_412903(a1, v13, a5, a6);
          v7 = v12 | 1;
        }
        goto LABEL_7;
      }
    }
  }
  return (_DWORD *)sub_401CE2(
                     *(__int64 **)a1,
                     (__int64)"third_party/duktape/duk_js_compiler.c",
                     1794,
                     "register limit",
                     a5,
                     a6);
}

//----- (0000000000412EC4) ----------------------------------------------------
_DWORD *__fastcall sub_412EC4(__int64 a1, __int16 a2, int a3, __m128 a4, __m128 a5)
{
  return sub_412DAE(a1, a2, 0, a3, a4, a5);
}

//----- (0000000000412ECD) ----------------------------------------------------
_DWORD *__fastcall sub_412ECD(__int64 a1, unsigned int a2, __m128 a3, __m128 a4)
{
  return sub_412EC4(a1, (unsigned __int16)(a2 >> 31) + 48, a2, a3, a4);
}

//----- (0000000000412ED7) ----------------------------------------------------
__int64 __fastcall sub_412ED7(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er12

  v4 = a2;
  if ( a2 < 0 )
  {
    v4 = *(_DWORD *)(a1 + 1980);
    *(_DWORD *)(a1 + 1980) = v4 + 1;
    sub_412EC4(a1, 161, v4, a3, a4);
    sub_4129C3(a1, a3, a4);
    sub_4129C3(a1, a3, a4);
  }
  return v4;
}

//----- (0000000000412F21) ----------------------------------------------------
_DWORD *__fastcall sub_412F21(__int64 a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v5; // ecx
  int v6; // edx
  __int16 v7; // si
  unsigned __int16 v8; // bx

  v5 = a3 + 0x8000;
  if ( (unsigned int)(a3 + 0x8000) > 0xFFFF )
  {
    v8 = a3;
    sub_412DAE(a1, 4, a2, (a3 >> 16) + 0x8000, a4, a5);
    v5 = v8;
    v6 = a2;
    v7 = 5;
  }
  else
  {
    v6 = a2;
    v7 = 4;
  }
  return sub_412DAE(a1, v7, v6, v5, a4, a5);
}

//----- (0000000000412F7E) ----------------------------------------------------
__int64 __fastcall sub_412F7E(__int64 a1, _DWORD *a2, int a3, char a4, __m128 a5, __m128 a6)
{
  int v8; // ebx
  __int64 *v9; // r8
  __int64 v10; // rsi
  unsigned int *v11; // r12
  unsigned int v12; // eax
  unsigned int v13; // eax
  bool v14; // zf
  int v15; // edx
  __int16 v16; // si
  int v17; // er14
  int v18; // eax
  unsigned int v19; // eax
  int v20; // ecx
  __int16 v21; // si
  unsigned int v22; // eax
  int v23; // ecx
  int v24; // edx
  __int16 v25; // si
  unsigned int v26; // eax
  unsigned int v27; // er12
  __int64 *v29; // [rsp+8h] [rbp-48h]
  int v30[13]; // [rsp+1Ch] [rbp-34h] BYREF

  v8 = a3;
  v9 = *(__int64 **)a1;
  if ( *a2 == 1 )
  {
    v10 = (int)a2[2];
    v11 = (unsigned int *)(v9[13] + 16 * v10);
    v12 = *v11;
    if ( *v11 == 4 )
    {
      if ( a3 < 0 )
        v8 = sub_4128FC(a1, a5, a6);
      v15 = v8;
      v16 = 10 - (v11[2] != 0);
    }
    else
    {
      if ( v12 > 4 )
      {
        if ( v12 == 8 )
        {
          sub_404F0A(*(__int64 **)a1, v10, a5, a6);
          v13 = sub_412531(a1, a5, a6);
          v14 = (a4 & 1) == 0;
          v27 = v13;
LABEL_28:
          if ( !v14 )
            return v27;
          if ( v8 < 0 )
            v8 = sub_4128FC(a1, a5, a6);
          goto LABEL_33;
        }
LABEL_22:
        v17 = a4 & 1;
        if ( (a4 & 1) == 0 )
        {
          a5.i64[0] = *((__int64 *)v11 + 1);
          v29 = *(__int64 **)a1;
          v18 = sub_41D58D(v30, *(double *)a5.i64);
          v9 = v29;
          if ( v18 )
          {
            if ( v8 < 0 )
              v8 = sub_4128FC(a1, a5, a6);
            sub_412F21(a1, v8, v30[0], a5, a6);
            return (unsigned int)v8;
          }
        }
        sub_404F0A(v9, a2[2], a5, a6);
        v19 = sub_412531(a1, a5, a6);
        v14 = v17 == 0;
        v27 = v19;
        goto LABEL_28;
      }
      if ( v12 == 2 )
      {
        if ( a3 < 0 )
          v8 = sub_4128FC(a1, a5, a6);
        v15 = v8;
        v16 = 7;
      }
      else
      {
        if ( v12 != 3 )
          goto LABEL_22;
        if ( a3 < 0 )
          v8 = sub_4128FC(a1, a5, a6);
        v15 = v8;
        v16 = 8;
      }
    }
    sub_412EC4(a1, v16, v15, a5, a6);
    return (unsigned int)v8;
  }
  if ( *a2 != 2 )
  {
    v27 = 0;
    sub_401CB7(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", 2525, a5, a6);
    return v27;
  }
  v27 = a2[1];
  if ( a3 >= 0 )
  {
    if ( (v27 & 0x80000000) == 0 )
    {
      if ( a3 == v27 )
        return v27;
      v20 = a2[1];
      v21 = 0;
      goto LABEL_36;
    }
LABEL_33:
    v20 = v27;
    a3 = v8;
    v21 = 3;
LABEL_36:
    sub_412DAE(a1, v21, a3, v20, a5, a6);
    return (unsigned int)v8;
  }
  if ( (v27 & 0x80000000) != 0 )
  {
    if ( (a4 & 1) != 0 )
      return v27;
    v22 = sub_4128FC(a1, a5, a6);
    v23 = a2[1];
    v27 = v22;
    v24 = v22;
    v25 = 3;
LABEL_43:
    sub_412DAE(a1, v25, v24, v23, a5, a6);
    return v27;
  }
  if ( (a4 & 2) != 0 && *(_DWORD *)(a1 + 1932) > (signed int)v27 )
  {
    v26 = sub_4128FC(a1, a5, a6);
    v23 = a2[1];
    v27 = v26;
    v24 = v26;
    v25 = 0;
    goto LABEL_43;
  }
  return v27;
}
// 412F7E: using guessed type int var_34[13];

//----- (000000000041315A) ----------------------------------------------------
_DWORD *__fastcall sub_41315A(__int64 a1, unsigned int a2, int a3, int a4, int a5, __m128 a6, __m128 a7)
{
  unsigned int v7; // er13
  int v9; // edx
  int v11; // eax
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // er14
  int v16; // ebx
  int v17; // esi
  _DWORD *result; // rax
  int v19; // edx
  int v20; // esi
  int v21; // [rsp+8h] [rbp-48h]
  int v22; // [rsp+Ch] [rbp-44h]
  int v23; // [rsp+10h] [rbp-40h]
  int v24; // [rsp+14h] [rbp-3Ch]
  int v25; // [rsp+18h] [rbp-38h]
  int v27; // [rsp+1Ch] [rbp-34h]

  v7 = a2;
  v9 = a4;
  v22 = (unsigned __int8)a2;
  if ( a3 <= 255 )
  {
    v24 = a3;
    a3 = -1;
  }
  else
  {
    if ( (a2 & 0x100) != 0 || a3 > 0xFFFF )
      return (_DWORD *)sub_401CE2(
                         *(__int64 **)a1,
                         (__int64)"third_party/duktape/duk_js_compiler.c",
                         1689,
                         "register limit",
                         a6,
                         a7);
    v11 = *(_DWORD *)(a1 + 1944);
    *(_BYTE *)(a1 + 2019) = 1;
    v24 = v11;
    if ( (a2 & 0x800) != 0 )
    {
      v12 = (a3 << 16) | (v11 << 8);
      a3 = -1;
      sub_412903(a1, v12, a6, a7);
      v9 = a4;
    }
    else if ( (unsigned __int8)a2 == 172 && a3 == 0xFFFF )
    {
      return (_DWORD *)sub_401CE2(
                         *(__int64 **)a1,
                         (__int64)"third_party/duktape/duk_js_compiler.c",
                         1689,
                         "register limit",
                         a6,
                         a7);
    }
  }
  if ( v9 < 0 )
  {
    if ( (v9 & 0x7FFFFF00) == 0 )
    {
      v27 = v9 & 0x7FFFFFFF;
      v25 = (v7 >> 14) & 1;
LABEL_21:
      v9 = -1;
      goto LABEL_25;
    }
    if ( (v9 & 0x7FFF0000) != 0 )
      return (_DWORD *)sub_401CE2(
                         *(__int64 **)a1,
                         (__int64)"third_party/duktape/duk_js_compiler.c",
                         1689,
                         "register limit",
                         a6,
                         a7);
    v13 = *(_DWORD *)(a1 + 1948);
    *(_BYTE *)(a1 + 2019) = 1;
    v27 = v13;
    sub_412903(a1, (v13 << 8) | (v9 << 16) | 3, a6, a7);
    goto LABEL_23;
  }
  if ( v9 <= 255 )
  {
    v27 = v9;
LABEL_23:
    v9 = -1;
    goto LABEL_24;
  }
  if ( (v7 & 0x200) != 0 || v9 > 0xFFFF )
    return (_DWORD *)sub_401CE2(
                       *(__int64 **)a1,
                       (__int64)"third_party/duktape/duk_js_compiler.c",
                       1689,
                       "register limit",
                       a6,
                       a7);
  v14 = *(_DWORD *)(a1 + 1948);
  *(_BYTE *)(a1 + 2019) = 1;
  v27 = v14;
  v25 = v7 & 0x1000;
  if ( (v7 & 0x1000) == 0 )
  {
    if ( (v7 & 0xFB) == 194 )
    {
      LOWORD(v7) = v7 + 1;
      sub_412F21(a1, v14, v9, a6, a7);
    }
    else
    {
      sub_412903(a1, (v9 << 16) | (v14 << 8), a6, a7);
    }
    goto LABEL_21;
  }
LABEL_24:
  v25 = 0;
LABEL_25:
  if ( a5 < 0 )
  {
    v15 = a5 & 0x7FFFFFFF;
    if ( (a5 & 0x7FFFFF00) == 0 )
    {
      a5 = -1;
      if ( (v7 & 0x4000) != 0 )
        v25 |= 2u;
      goto LABEL_38;
    }
    v23 = v9;
    if ( (a5 & 0x7FFF0000) == 0 )
    {
      v16 = *(_DWORD *)(a1 + 1952);
      *(_BYTE *)(a1 + 2019) = 1;
      v17 = (v16 << 8) | (v15 << 16);
      v15 = v16;
      sub_412903(a1, v17 | 3, a6, a7);
LABEL_36:
      v9 = v23;
      a5 = -1;
      goto LABEL_38;
    }
    return (_DWORD *)sub_401CE2(
                       *(__int64 **)a1,
                       (__int64)"third_party/duktape/duk_js_compiler.c",
                       1689,
                       "register limit",
                       a6,
                       a7);
  }
  if ( a5 <= 255 )
  {
    v15 = a5;
    a5 = -1;
    goto LABEL_38;
  }
  if ( (v7 & 0x400) != 0 || a5 > 0xFFFF )
    return (_DWORD *)sub_401CE2(
                       *(__int64 **)a1,
                       (__int64)"third_party/duktape/duk_js_compiler.c",
                       1689,
                       "register limit",
                       a6,
                       a7);
  v15 = *(_DWORD *)(a1 + 1952);
  *(_BYTE *)(a1 + 2019) = 1;
  if ( (v7 & 0x2000) == 0 )
  {
    v23 = v9;
    sub_412903(a1, (a5 << 16) | (v15 << 8), a6, a7);
    goto LABEL_36;
  }
LABEL_38:
  v21 = v9;
  result = sub_412903(a1, (v15 << 24) | v25 | (v27 << 16) | (v24 << 8) | (unsigned int)(unsigned __int8)v7, a6, a7);
  v19 = v21;
  if ( (v7 & 0x8000) != 0 )
  {
    *(_DWORD *)(a1 + 1800) = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
    result = sub_412903(a1, 2, a6, a7);
    v19 = v21;
  }
  if ( a3 != -1 )
  {
    result = sub_412903(a1, (v24 << 8) | (a3 << 16) | 1u, a6, a7);
    if ( v22 != 172 )
      return result;
    v20 = ((v24 + 1) << 8) | ((a3 + 1) << 16);
    return sub_412903(a1, v20 | 1u, a6, a7);
  }
  if ( v19 != -1 )
  {
    v20 = (v27 << 8) | (v19 << 16);
    return sub_412903(a1, v20 | 1u, a6, a7);
  }
  if ( a5 != -1 )
  {
    v20 = (a5 << 16) | (v15 << 8);
    return sub_412903(a1, v20 | 1u, a6, a7);
  }
  return result;
}

//----- (00000000004134B2) ----------------------------------------------------
__int64 __fastcall sub_4134B2(__int64 a1, int *a2, __m128 a3, __m128 a4)
{
  int v4; // er8
  __int64 result; // rax

  v4 = a2[2];
  if ( v4 )
  {
    sub_41315A(a1, 0xCC2u, *a2, a2[1], 2 * v4, a3, a4);
    a2[3] += a2[2];
    a2[2] = 0;
  }
  result = (unsigned int)a2[1];
  *(_DWORD *)(a1 + 1936) = result;
  return result;
}

//----- (00000000004134F7) ----------------------------------------------------
void __fastcall sub_4134F7(__int64 a1, unsigned int *a2, int a3, __m128 a4, __m128 a5)
{
  unsigned int v7; // eax
  __int64 *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // r14
  __int64 v12; // rax
  unsigned int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // rcx
  int v16; // er14
  int v17; // er8
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  unsigned int v22; // esi
  int v23; // er14
  int v24; // eax
  int v25; // eax
  unsigned int v26; // eax
  int v27; // [rsp+Ch] [rbp-44h]
  int v28; // [rsp+Ch] [rbp-44h]
  unsigned int v29; // [rsp+18h] [rbp-38h] BYREF
  int v30[13]; // [rsp+1Ch] [rbp-34h] BYREF

  v7 = *a2;
  v8 = *(__int64 **)a1;
  if ( *a2 == 3 )
  {
    v23 = sub_412F7E(a1, a2 + 2, -1, 5, a4, a5);
    v17 = sub_412F7E(a1, a2 + 5, -1, 5, a4, a5);
    if ( a3 < 0 )
    {
      v24 = *(_DWORD *)(a1 + 1932);
      a3 = v23;
      if ( v24 > v23 )
      {
        a3 = v17;
        if ( v24 > v17 )
        {
          v28 = v17;
          v25 = sub_4128FC(a1, a4, a5);
          v17 = v28;
          a3 = v25;
        }
      }
    }
    v20 = v23;
    v21 = a3;
    v22 = 16492;
    goto LABEL_38;
  }
  if ( v7 <= 3 )
  {
    if ( v7 == 1 )
      return;
    if ( v7 != 2 )
      goto LABEL_45;
    if ( a2[2] != 1 || a2[5] != 1 )
      goto LABEL_28;
    v9 = v8[13];
    v10 = (int)a2[4];
    v11 = v9 + 16 * v10;
    v12 = v9 + 16LL * (int)a2[7];
    if ( *(_DWORD *)v11 )
    {
      if ( a2[1] == 52 && *(_DWORD *)v11 == 8 && *(_DWORD *)v12 == 8 )
      {
        sub_404F0A(*(__int64 **)a1, v10, a4, a5);
        sub_404F0A(v8, a2[7], a4, a5);
        sub_408E52(v8, 2, a4, a5);
        sub_405057(v8, a2[4], v14, v15, *(double *)a4.i64, a5);
        *a2 = 1;
        return;
      }
      goto LABEL_28;
    }
    if ( !*(_DWORD *)v12 )
    {
      a5.i64[0] = *(__int64 *)(v12 + 8);
      v13 = a2[1];
      a4.i64[0] = *(__int64 *)(v11 + 8);
      if ( v13 == 60 )
      {
        *(double *)a4.i64 = *(double *)a4.i64 * *(double *)a5.i64;
      }
      else if ( v13 > 0x3C )
      {
        if ( v13 == 64 )
        {
          *(double *)a4.i64 = sub_41D60E(*(double *)a4.i64, (__m128d)a5);
        }
        else
        {
          if ( v13 != 72 )
            goto LABEL_28;
          *(double *)a4.i64 = sub_4203F7(*(double *)a4.i64, *(double *)a5.i64);
        }
      }
      else if ( v13 == 52 )
      {
        *(double *)a4.i64 = *(double *)a4.i64 + *(double *)a5.i64;
      }
      else
      {
        *(double *)a4.i64 = *(double *)a4.i64 - *(double *)a5.i64;
        if ( v13 != 56 )
          goto LABEL_28;
      }
      *a2 = 1;
      *(_QWORD *)(v11 + 8) = a4.i64[0];
      *(_DWORD *)v11 = 0;
      return;
    }
LABEL_28:
    v16 = sub_412F7E(a1, a2 + 2, -1, 5, a4, a5);
    v17 = sub_412F7E(a1, a2 + 5, -1, 5, a4, a5);
    if ( a3 < 0 )
    {
      v18 = *(_DWORD *)(a1 + 1932);
      a3 = v16;
      if ( v18 > v16 )
      {
        a3 = v17;
        if ( v18 > v17 )
        {
          v27 = v17;
          v19 = sub_4128FC(a1, a4, a5);
          v17 = v27;
          a3 = v19;
        }
      }
    }
    v20 = v16;
    v21 = a3;
    v22 = a2[1] | 0x4000;
LABEL_38:
    sub_41315A(a1, v22, v21, v20, v17, a4, a5);
    goto LABEL_39;
  }
  if ( v7 == 4 )
  {
    sub_404F0A(*(__int64 **)a1, a2[4], a4, a5);
    if ( (unsigned int)sub_412615(a1, (int *)&v29, v30, a4, a5) )
    {
      v26 = v29;
      *a2 = 1;
      a2[2] = 2;
      a2[3] = v26;
      return;
    }
    if ( a3 < 0 )
      a3 = sub_4128FC(a1, a4, a5);
    sub_412DAE(a1, 11, a3, v30[0], a4, a5);
LABEL_39:
    *a2 = 1;
    a2[2] = 2;
    a2[3] = a3;
    return;
  }
LABEL_45:
  sub_401CB7(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", 2736, a4, a5);
}
// 41361B: variable 'v14' is possibly undefined
// 41361B: variable 'v15' is possibly undefined
// 4134F7: using guessed type int var_34[13];

//----- (0000000000413793) ----------------------------------------------------
void __fastcall sub_413793(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4)
{
  int v4; // er12

  v4 = *(_DWORD *)(a1 + 1936);
  sub_4134F7(a1, a2, -1, a3, a4);
  *(_DWORD *)(a1 + 1936) = v4;
}

//----- (00000000004137B8) ----------------------------------------------------
__int64 __fastcall sub_4137B8(__int64 a1, unsigned int *a2, int a3, char a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax

  sub_4134F7(a1, a2, a3, a5, a6);
  result = sub_412F7E(a1, a2 + 2, a3, a4, a5, a6);
  *a2 = 1;
  a2[2] = 2;
  a2[3] = result;
  return result;
}

//----- (00000000004137FD) ----------------------------------------------------
__int64 __fastcall sub_4137FD(__int64 a1, unsigned int *a2, int a3, __m128 a4, __m128 a5)
{
  return sub_4137B8(a1, a2, a3, 0, a4, a5);
}

//----- (0000000000413801) ----------------------------------------------------
__int64 __fastcall sub_413801(__int64 a1, unsigned int *a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  int v8; // eax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 result; // rax
  __int64 *v13; // rdi
  int v14; // esi

  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 == 1 || v8 == 100 )
  {
    sub_407808(*(__int64 **)a1, *(_QWORD *)(a3 + 16), a5, a6);
  }
  else
  {
    result = 1LL;
    if ( *(_DWORD *)a3 != 99 )
      return result;
    a5.i64[0] = *(__int64 *)(a3 + 8);
    sub_406A1B(*(__int64 **)a1, a5, a6);
  }
  v13 = *(__int64 **)a1;
  v14 = a2[4];
  *a2 = 1;
  a2[2] = 1;
  sub_405057(v13, v14, v10, v11, *(double *)a5.i64, a6);
  *(_DWORD *)(a1 + 1936) = a4 + 1;
  sub_4137FD(a1, a2, a4, a5, a6);
  *(_DWORD *)(a1 + 1936) = a4 + 1;
  return 0LL;
}
// 413864: variable 'v10' is possibly undefined
// 413864: variable 'v11' is possibly undefined

//----- (0000000000413890) ----------------------------------------------------
__int64 __fastcall sub_413890(__int64 a1, _DWORD *a2, signed __int32 a3, __m128 a4, __m128 a5)
{
  __int64 *v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rcx
  unsigned int *v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 result; // rax
  __int64 *v15; // rdi
  __int64 v16; // rsi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned int v22; // eax
  __int64 *v23; // r14
  int v24; // er12
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 *v27; // rdi
  int v28; // eax
  int i; // edx
  unsigned int v30; // er12
  int v31; // er12
  int v32; // er12
  int v33; // edx
  int v34; // er13
  int v35; // eax
  int v36; // ecx
  int v37; // er8
  int v38; // edx
  unsigned int v39; // er12
  int v40; // eax
  int v41; // eax
  bool v42; // zf
  unsigned int v43; // er13
  int v44; // edx
  const char *v45; // rcx
  unsigned int v46; // edx
  int v47; // eax
  int v48; // eax
  int v49; // edx
  int v50; // er13
  int v51; // eax
  int v52; // er12
  int v53; // eax
  __int64 v54; // rdx
  __int16 v55; // r13
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // edx
  __int64 *v60; // rdi
  int v61; // esi
  __int64 v62; // rdx
  __int64 v63; // rcx
  int v64; // eax
  int v65; // eax
  int v66; // eax
  int v67; // edx
  int v68; // ecx
  int v69; // eax
  int v70; // eax
  int v71; // er13
  int v72; // eax
  __int64 v73; // rdx
  unsigned int v74; // er13
  int v75; // eax
  __int64 v76; // rax
  double *v77; // r12
  int v78; // er14
  int v79; // er13
  _DWORD *v80; // rax
  int v81; // ecx
  int v82; // edx
  int v83; // er14
  int v84; // eax
  __int64 v85; // rax
  __int64 *v86; // r12
  int v87; // er13
  int v88; // eax
  unsigned int v89; // er14
  unsigned int v90; // er13
  unsigned int v91; // er13
  unsigned int v92; // er13
  __int64 v93; // rcx
  const char *v94; // rcx
  unsigned int v95; // edx
  __int64 v96; // rax
  __int64 *v97; // rdi
  int v98; // esi
  __int64 v99; // rdx
  __int64 v100; // rcx
  __int64 v101; // rcx
  __int64 *v102; // rdi
  __int64 v103; // rcx
  __int64 v104; // rcx
  __int64 *v105; // rdi
  int v106; // esi
  int v107; // edx
  int v108; // er13
  int v109; // er14
  __int64 v110; // rax
  __int64 v111; // rdx
  int v112; // eax
  int v113; // eax
  unsigned int v114; // er12
  int v115; // er14
  int v116; // er13
  __int64 v117; // rcx
  signed __int32 v118; // er14
  int v119; // er13
  unsigned int v120; // er14
  int v121; // esi
  _DWORD *v122; // rax
  bool v123; // r13
  __int64 v124; // rcx
  int v125; // er14
  int v126; // eax
  int v127; // er10
  int v128; // er12
  int v129; // eax
  __int64 v130; // rax
  int v131; // er10
  bool v132; // cc
  int v133; // edx
  unsigned int *v134; // rsi
  int v135; // er13
  int v136; // er14
  _DWORD *v137; // rax
  __int16 v138; // r13
  int v139; // ecx
  int v140; // edx
  __int16 v141; // si
  int v142; // er12
  int v143; // eax
  int v144; // [rsp+4h] [rbp-ACh]
  int v145; // [rsp+4h] [rbp-ACh]
  __int64 v146; // [rsp+8h] [rbp-A8h]
  __int64 v147; // [rsp+10h] [rbp-A0h]
  signed __int32 v148; // [rsp+18h] [rbp-98h] BYREF
  unsigned int v149; // [rsp+1Ch] [rbp-94h]
  __int64 v150; // [rsp+20h] [rbp-90h]
  __int64 v151; // [rsp+28h] [rbp-88h]
  double v152; // [rsp+30h] [rbp-80h]
  __int64 *v153; // [rsp+38h] [rbp-78h]
  int v154; // [rsp+4Ch] [rbp-64h] BYREF
  int v155; // [rsp+50h] [rbp-60h] BYREF
  int v156; // [rsp+54h] [rbp-5Ch]
  __int64 v157; // [rsp+58h] [rbp-58h]
  unsigned int v158[2]; // [rsp+60h] [rbp-50h] BYREF
  __int64 v159; // [rsp+68h] [rbp-48h]
  int v160; // [rsp+70h] [rbp-40h]
  __int64 v161; // [rsp+74h] [rbp-3Ch]
  int v162; // [rsp+7Ch] [rbp-34h]

  v7 = *(__int64 **)a1;
  v148 = a3;
  v153 = v7;
  sub_412889(a1, a4, a5);
  v8 = 16LL;
  sub_404E3A(v153, 16, a4, a5);
  v9 = 8LL;
  v10 = v158;
  while ( v9 )
  {
    *v10++ = 0;
    --v9;
  }
  v160 = sub_404AE7((__int64)v153);
  v162 = v160 + 1;
  sub_4068D1(v153, 16LL, v11, a4, a5);
  sub_4068D1(v153, 16LL, v12, a4, a5);
  if ( ((*(_DWORD *)(a1 + 1720) - 54) & 0xFFFFFFFD) != 0 )
  {
    sub_412529(a1, a4, a5);
    v22 = *(_DWORD *)(a1 + 1664);
    ++*(_DWORD *)(a1 + 1956);
    v23 = *(__int64 **)a1;
    v24 = *(_DWORD *)(a1 + 1936);
    *a2 = 0;
    if ( v22 == 51 )
    {
      v39 = 0;
      LODWORD(v152) = sub_4128FC(a1, a4, a5);
      v16 = 193LL;
      v147 = *(_QWORD *)(a1 + 1808);
      v146 = *(_QWORD *)(a1 + 1816);
      sub_412EC4(a1, 193, SLODWORD(v152), a4, a5);
      v40 = *(_DWORD *)(a1 + 1936);
      LODWORD(v150) = 0;
      v149 = 0;
      LODWORD(v151) = v40;
      v41 = 0;
      while ( 1 )
      {
        v42 = *(_DWORD *)(a1 + 1720) == 52;
        *(_DWORD *)(a1 + 1936) = v151;
        if ( v42 )
          break;
        v43 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            v44 = *(_DWORD *)(a1 + 1720);
            if ( v44 == 52 )
              goto LABEL_48;
            if ( !v41 )
              break;
            if ( v44 != 57 )
            {
              v45 = "invalid array literal";
              v46 = 83889431;
              goto LABEL_153;
            }
            sub_412529(a1, a4, a5);
            v41 = 0;
          }
          if ( v44 == 57 )
            break;
          if ( !v43 )
          {
            v47 = sub_4128FC(a1, a4, a5);
            sub_412F21(a1, v47, v39, a4, a5);
            v149 = v39;
          }
          ++v43;
          ++v39;
          v48 = sub_4128FC(a1, a4, a5);
          *(_DWORD *)(a1 + 1936) = v48;
          v16 = (__int64)a2;
          v144 = v48;
          sub_4174F4(a1, a2, a4, a5, 6, v48);
          *(_DWORD *)(a1 + 1936) = v144 + 1;
          v41 = 1;
          if ( v43 > 0x13 )
            goto LABEL_49;
        }
        ++v39;
        sub_412529(a1, a4, a5);
        v41 = 0;
LABEL_48:
        if ( v43 )
        {
LABEL_49:
          v16 = 3270LL;
          v145 = v41;
          sub_41315A(a1, 0xCC6u, SLODWORD(v152), v151, v43 + 1, a4, a5);
          v41 = v145;
          LODWORD(v150) = v149 + v43;
        }
      }
      v49 = 255;
      if ( v39 <= 0xFF )
        v49 = v39;
      *(_DWORD *)(*(_QWORD *)(a1 + 1816) + 8LL * (int)((unsigned __int64)(v147 - v146) >> 3)) |= v49 << 8;
      sub_412529(a1, a4, a5);
      if ( (unsigned int)v150 < v39 )
      {
        v50 = sub_4128FC(a1, a4, a5);
        sub_412F21(a1, v50, v39, a4, a5);
        v16 = 2248LL;
        sub_412DAE(a1, 2248, SLODWORD(v152), v50, a4, a5);
      }
      *(_DWORD *)(a1 + 1936) = v151;
      v51 = LODWORD(v152);
      *a2 = 1;
      a2[2] = 2;
LABEL_84:
      a2[3] = v51;
    }
    else
    {
      if ( v22 <= 0x33 )
      {
        if ( v22 <= 0x25 )
        {
          if ( v22 > 0x10 )
          {
            switch ( v22 )
            {
              case 0x11u:
                v66 = sub_4128B7(a1, 2, a4, a5);
                v32 = v66;
                if ( *(_DWORD *)(a1 + 1720) != 55 )
                {
                  sub_4174F4(a1, a2, a4, a5, 36, v66);
                  sub_412EC4(a1, 192, v32 + 1, a4, a5);
                  v67 = 0;
                  v42 = *(_DWORD *)(a1 + 1720) == 53;
                  *(_DWORD *)(a1 + 1936) = v32 + 2;
                  if ( v42 )
                  {
                    sub_412529(a1, a4, a5);
                    v67 = sub_417525(a1, a2, a4, a5);
                  }
                  v68 = v32;
                  v16 = 178LL;
                  goto LABEL_103;
                }
                sub_412529(a1, a4, a5);
                if ( *(_DWORD *)(a1 + 1724) == 1
                  && sub_411829(*(_QWORD *)(a1 + 1736), (__int64)"target")
                  && !*(_BYTE *)(a1 + 2006) )
                {
                  sub_412529(a1, a4, a5);
                  v33 = v32;
                  v16 = 203LL;
                  goto LABEL_91;
                }
                v45 = byte_43CB7B;
                v46 = 83890314;
                break;
              case 0x14u:
                v16 = 6LL;
                v32 = sub_4128FC(a1, a4, a5);
                v33 = v32;
                goto LABEL_91;
              case 0x17u:
                sub_413890(a1, a2, 30, a4, a5);
                v74 = 153;
                if ( *a2 != 4 )
                  goto LABEL_134;
                sub_404F0A(v23, a2[4], a4, a5);
                if ( (unsigned int)sub_412615(a1, &v154, &v155, a4, a5) )
                  goto LABEL_134;
                v75 = sub_4128FC(a1, a4, a5);
                v68 = v155;
                v32 = v75;
                v67 = v75;
                v16 = 154LL;
                goto LABEL_103;
              case 0x1Au:
                sub_413890(a1, a2, 30, a4, a5);
                sub_413793(a1, a2, a4, a5);
                sub_4068D1(v23, (__int64)a2, v73, a4, a5);
                goto LABEL_150;
              case 0x23u:
                sub_40691D(v23, 16LL, v21, a4, a5);
                goto LABEL_150;
              case 0x24u:
                goto LABEL_107;
              case 0x25u:
                sub_4069DC(v23, a4, a5, 16LL, v21);
                goto LABEL_150;
              default:
                goto LABEL_133;
            }
            goto LABEL_153;
          }
          if ( v22 != 8 )
          {
            if ( v22 != 13 )
            {
              if ( v22 == 1 )
              {
                sub_407808(v23, *(_QWORD *)(a1 + 1680), a4, a5);
                v27 = *(__int64 **)a1;
                *a2 = 4;
LABEL_151:
                v16 = (unsigned int)a2[4];
                a2[2] = 1;
                sub_405057(v27, v16, v25, v26, *(double *)a4.i64, a5);
                goto LABEL_154;
              }
              goto LABEL_133;
            }
            v32 = sub_4128FC(a1, a4, a5);
            v69 = sub_4170A8(a1, 0, a4, a5);
            v67 = v32;
            v68 = v69;
            v16 = 152LL;
            goto LABEL_103;
          }
          v8 = (__int64)a2;
          sub_413890(a1, a2, 30, a4, a5);
          if ( *a2 == 4 )
          {
            if ( *(_BYTE *)(a1 + 2010) )
            {
              v45 = "cannot delete identifier";
              v46 = 83890051;
LABEL_153:
              v16 = (__int64)"third_party/duktape/duk_js_compiler.c";
              sub_401C42(v23, (__int64)"third_party/duktape/duk_js_compiler.c", v46, v45, a4, a5);
              goto LABEL_154;
            }
            *(_DWORD *)(a1 + 1936) = v24;
            v32 = sub_4128FC(a1, a4, a5);
            sub_404F0A(v23, a2[4], a4, a5);
            if ( (unsigned int)sub_412615(a1, &v154, &v155, a4, a5) )
            {
              v33 = v32;
              v16 = 10LL;
LABEL_91:
              sub_412EC4(a1, v16, v33, a4, a5);
              goto LABEL_92;
            }
            sub_404F0A(v23, a2[4], a4, a5);
            v70 = sub_412531(a1, a4, a5);
            v67 = v32;
            v68 = v70;
            v155 = v70;
            v16 = 156LL;
            goto LABEL_103;
          }
          if ( *a2 == 3 )
          {
            *(_DWORD *)(a1 + 1936) = v24;
            v32 = sub_4128FC(a1, a4, a5);
            v71 = sub_412F7E(a1, a2 + 2, -1, 0, a4, a5);
            v72 = sub_412F7E(a1, a2 + 5, -1, 1, a4, a5);
            v36 = v71;
            v37 = v72;
            v38 = v32;
            v16 = 16500LL;
            goto LABEL_106;
          }
LABEL_107:
          sub_40699D(v23, a4, a5, v8, v21);
LABEL_150:
          v27 = *(__int64 **)a1;
          *a2 = 1;
          goto LABEL_151;
        }
        if ( v22 == 49 )
        {
          v155 = sub_4128FC(a1, a4, a5);
          v28 = *(_DWORD *)(a1 + 1936);
          v157 = 0LL;
          v156 = v28;
          v152 = *(double *)(a1 + 1808);
          v151 = *(_QWORD *)(a1 + 1816);
          sub_412EC4(a1, 192, v155, a4, a5);
          for ( i = 1; ; i = 0 )
          {
            v58 = *(_DWORD *)(a1 + 1720);
            if ( v58 == 50 )
              goto LABEL_81;
            if ( !i )
            {
              if ( v58 != 57 )
                goto LABEL_85;
              sub_412529(a1, a4, a5);
              if ( *(_DWORD *)(a1 + 1720) == 50 )
              {
LABEL_81:
                v16 = (__int64)&v155;
                sub_4134B2(a1, &v155, a4, a5);
                v65 = 255;
                if ( HIDWORD(v157) <= 0xFF )
                  v65 = HIDWORD(v157);
                *(_DWORD *)(*(_QWORD *)(a1 + 1816) + 8LL * (int)((unsigned __int64)(*(_QWORD *)&v152 - v151) >> 3)) |= v65 << 8;
                sub_412529(a1, a4, a5);
                v51 = v155;
                *a2 = 1;
                a2[2] = 2;
                goto LABEL_84;
              }
            }
            sub_412529(a1, a4, a5);
            if ( (unsigned int)v157 > 9 )
              sub_4134B2(a1, &v155, a4, a5);
            *(_DWORD *)(a1 + 1936) = v156 + 2 * v157;
            v52 = sub_4128B7(a1, 2, a4, a5);
            v53 = *(_DWORD *)(a1 + 1664);
            if ( v53 != 1 )
              break;
            v54 = v23[71];
            v55 = *(_QWORD *)(v54 + 584) == *(_QWORD *)(a1 + 1680);
            if ( *(_QWORD *)(a1 + 1680) != *(_QWORD *)(v54 + 704) && *(_QWORD *)(v54 + 584) != *(_QWORD *)(a1 + 1680)
              || *(_DWORD *)(a1 + 1720) == 85 )
            {
              v59 = *(_DWORD *)(a1 + 1720);
              if ( v59 == 57 || v59 == 50 )
              {
                sub_413801(a1, a2, a1 + 1664, v52, a4, a5);
                sub_407808(*(__int64 **)a1, *(_QWORD *)(a1 + 1680), a4, a5);
                v60 = *(__int64 **)a1;
                v61 = a2[4];
                *a2 = 4;
                a2[2] = 1;
                sub_405057(v60, v61, v62, v63, *(double *)a4.i64, a5);
                sub_4137FD(a1, a2, v52 + 1, a4, a5);
LABEL_80:
                LODWORD(v157) = v157 + 1;
                continue;
              }
LABEL_73:
              if ( *(_DWORD *)(a1 + 1720) == 53 )
              {
                if ( (unsigned int)sub_413801(a1, a2, a1 + 1664, v52, a4, a5) )
                  goto LABEL_85;
                v64 = sub_4170A8(a1, 20, a4, a5);
                sub_412DAE(a1, 152, v52 + 1, v64, a4, a5);
                goto LABEL_80;
              }
LABEL_76:
              if ( v53 == 51 )
              {
                *(_DWORD *)(a1 + 1936) = v52;
                sub_4174F4(a1, a2, a4, a5, 4, v52);
                sub_412449(a1, 52, a4, a5);
              }
              else if ( (unsigned int)sub_413801(a1, a2, a1 + 1664, v52, a4, a5) )
              {
LABEL_85:
                v45 = "invalid object literal";
                v46 = 83889729;
                goto LABEL_153;
              }
              sub_412449(a1, 85, a4, a5);
              *(_DWORD *)(a1 + 1936) = v52 + 1;
              sub_4174F4(a1, a2, a4, a5, 6, v52 + 1);
              goto LABEL_80;
            }
            sub_4134B2(a1, &v155, a4, a5);
            v56 = sub_4128B7(a1, 2, a4, a5);
            if ( (unsigned int)sub_413801(a1, a2, a1 + 1720, v56, a4, a5) )
              goto LABEL_85;
            v57 = sub_4170A8(a1, 2, a4, a5);
            sub_412DAE(a1, 152, v156 + 1, v57, a4, a5);
            sub_412DAE(a1, v55 + 2244, v155, v156, a4, a5);
          }
          if ( (unsigned int)(v53 - 99) <= 1 )
            goto LABEL_73;
          goto LABEL_76;
        }
LABEL_133:
        v45 = "parse error";
        v46 = 83890217;
        goto LABEL_153;
      }
      if ( v22 > 0x51 )
      {
        switch ( v22 )
        {
          case 'd':
            sub_407808(v23, *(_QWORD *)(a1 + 1680), a4, a5);
            goto LABEL_150;
          case 'e':
            v32 = sub_4128FC(a1, a4, a5);
            sub_407808(v23, *(_QWORD *)(a1 + 1680), a4, a5);
            sub_407808(v23, *(_QWORD *)(a1 + 1688), a4, a5);
            sub_41C0B4(v23, a4, a5);
            v34 = sub_412531(a1, a4, a5);
            v35 = sub_412531(a1, a4, a5);
            v36 = v34;
            v37 = v35;
            v38 = v32;
            v16 = 16532LL;
LABEL_106:
            sub_41315A(a1, v16, v38, v36, v37, a4, a5);
            goto LABEL_92;
          case 'c':
            a4.i64[0] = *(__int64 *)(a1 + 1672);
            sub_406A1B(v23, a4, a5);
            goto LABEL_150;
        }
        goto LABEL_133;
      }
      if ( v22 > 0x41 )
      {
        switch ( v22 )
        {
          case 'B':
            sub_413890(a1, a2, 30, a4, a5);
            if ( *a2 == 1 && a2[2] == 1 )
            {
              v16 = (unsigned int)a2[4];
              if ( sub_4064DB((__int64)v23, v16) )
                goto LABEL_154;
            }
            v74 = 15;
            goto LABEL_134;
          case 'C':
            sub_413890(a1, a2, 30, a4, a5);
            if ( *a2 != 1 || a2[2] != 1 || (v16 = (unsigned int)a2[4], !sub_4064DB((__int64)v23, v16)) )
            {
              v74 = 14;
              goto LABEL_134;
            }
            v76 = v23[13] + 16LL * (int)a2[4];
            a4.i64[0] = *(__int64 *)(v76 + 8);
            *(_DWORD *)v76 = 0;
            a4 = _mm_xor_ps(a4, (__m128)xmmword_43D2F0);
            *(_QWORD *)(v76 + 8) = a4.i64[0];
            goto LABEL_154;
          case 'H':
            v30 = 32888;
            goto LABEL_138;
          case 'I':
            v30 = 33913;
LABEL_138:
            v79 = sub_4128FC(a1, a4, a5);
            sub_413890(a1, a2, 30, a4, a5);
            if ( *a2 == 4 )
            {
              v80 = (_DWORD *)sub_405B3C((__int64)v23, a2[4]);
              if ( *(_BYTE *)(a1 + 2010) && (*v80 & 0x2000) != 0 )
              {
                v45 = "invalid expression";
                v46 = 83890319;
                goto LABEL_153;
              }
              sub_404F0A(v23, a2[4], a4, a5);
              if ( (unsigned int)sub_412615(a1, &v154, &v155, a4, a5) )
              {
                v81 = v154;
                v82 = v79;
                v16 = (unsigned __int8)v30;
              }
              else
              {
                v81 = v155;
                v16 = (unsigned int)(unsigned __int8)v30 + 4;
                v82 = v79;
              }
              sub_412DAE(a1, v16, v82, v81, a4, a5);
            }
            else if ( *a2 == 3 )
            {
              v83 = sub_412F7E(a1, a2 + 2, -1, 0, a4, a5);
              v84 = sub_412F7E(a1, a2 + 5, -1, 1, a4, a5);
              v16 = (v30 >> 8) | 0x4000;
              sub_41315A(a1, v16, v79, v83, v84, a4, a5);
            }
            else
            {
              sub_4137FD(a1, a2, v79, a4, a5);
              sub_412EC4(a1, 15, v79, a4, a5);
              v16 = 170LL;
              sub_412903(a1, 170, a4, a5);
            }
            *(_DWORD *)(a1 + 1936) = v79 + 1;
            *a2 = 1;
            a2[2] = 2;
            a2[3] = v79;
            goto LABEL_154;
          case 'P':
            v16 = (__int64)a2;
            sub_413890(a1, a2, 30, a4, a5);
            if ( *a2 != 1 || a2[2] != 1 )
              goto LABEL_124;
            v77 = (double *)(v23[13] + 16LL * (int)a2[4]);
            if ( *(_DWORD *)v77 )
            {
              if ( *(_DWORD *)v77 == 4 )
              {
                *((_DWORD *)v77 + 2) ^= 1u;
                goto LABEL_154;
              }
            }
            else
            {
              a5 = 0LL;
              v152 = v77[1];
              *(double *)a4.i64 = v152;
              if ( sub_41D67C(v152, 0.0) )
              {
                *(_DWORD *)v77 = 4;
                *((_DWORD *)v77 + 2) = 1;
                goto LABEL_154;
              }
              *(double *)a5.i64 = 1.0;
              if ( sub_41D67C(v152, 1.0) )
              {
                *(_DWORD *)v77 = 4;
                *((_DWORD *)v77 + 2) = 0;
                goto LABEL_154;
              }
            }
LABEL_124:
            v74 = 13;
LABEL_134:
            v78 = sub_4137B8(a1, a2, -1, 0, a4, a5);
            v32 = v78;
            if ( v78 < *(_DWORD *)(a1 + 1932) )
              v32 = sub_4128FC(a1, a4, a5);
            v68 = v78;
            v67 = v32;
            v16 = v74;
            break;
          case 'Q':
            v74 = 12;
            sub_413890(a1, a2, 30, a4, a5);
            goto LABEL_134;
          default:
            goto LABEL_133;
        }
LABEL_103:
        sub_412DAE(a1, v16, v67, v68, a4, a5);
LABEL_92:
        *a2 = 1;
        a2[2] = 2;
        a2[3] = v32;
        goto LABEL_154;
      }
      if ( v22 != 53 )
        goto LABEL_133;
      ++*(_DWORD *)(a1 + 1964);
      v31 = *(_DWORD *)(a1 + 1972);
      *(_DWORD *)(a1 + 1972) = 1;
      sub_413890(a1, a2, 4, a4, a5);
      v16 = 54LL;
      sub_412449(a1, 54, a4, a5);
      --*(_DWORD *)(a1 + 1964);
      *(_DWORD *)(a1 + 1972) = v31;
    }
LABEL_154:
    v149 = (unsigned __int8)v148;
    while ( 1 )
    {
      v85 = *(unsigned int *)(a1 + 1720);
      if ( (_DWORD)v85 == 15 )
      {
        if ( !*(_DWORD *)(a1 + 1972) )
          goto LABEL_269;
      }
      else
      {
        v19 = (unsigned int)(v85 - 72);
        if ( (unsigned int)v19 <= 1 && *(_DWORD *)(a1 + 1768) )
          goto LABEL_269;
      }
      if ( v149 >= 2 * (byte_43D280[v85] & 0x1Fu) )
        goto LABEL_269;
      sub_412529(a1, a4, a5);
      v86 = *(__int64 **)a1;
      v87 = *(_DWORD *)(a1 + 1960) + 1;
      v88 = *(_DWORD *)(a1 + 1664);
      *(_DWORD *)(a1 + 1960) = v87;
      switch ( v88 )
      {
        case 15:
          v92 = 26648;
          goto LABEL_215;
        case 16:
          v92 = 25624;
          goto LABEL_215;
        case 51:
          sub_4137B8(a1, a2, -1, 3, a4, a5);
          sub_4175A2(a1, v158, a4, a5, 4);
          sub_412449(a1, 52, a4, a5);
          v102 = *(__int64 **)a1;
          v158[0] = 3;
          v161 = v159;
          sub_4050B6(v102, v160, v162, v103, a4, a5);
          v105 = *(__int64 **)a1;
          v106 = a2[4];
          v107 = v160;
          v159 = *((_QWORD *)a2 + 1);
          goto LABEL_216;
        case 53:
          v108 = sub_4128B7(a1, 2, a4, a5);
          v109 = v108 + 1;
          if ( *a2 == 4 )
          {
            v110 = sub_405B3C((__int64)v86, a2[4]);
            v111 = v86[71];
            LODWORD(v152) = 176;
            if ( *(_QWORD *)(v111 + 264) == v110 )
            {
              *(_BYTE *)(a1 + 2014) = 1;
              LODWORD(v152) = 180;
            }
            sub_404F0A(v86, a2[4], a4, a5);
            if ( (unsigned int)sub_412615(a1, &v154, &v155, a4, a5) )
              sub_412DAE(a1, 2219, v154, v108, a4, a5);
            else
              sub_41315A(a1, 0x40ACu, v108, v155, 0, a4, a5);
          }
          else
          {
            if ( *a2 == 3 )
            {
              sub_412F7E(a1, a2 + 2, v109, 0, a4, a5);
              v112 = sub_412F7E(a1, a2 + 5, -1, 1, a4, a5);
              sub_41315A(a1, 0x40D0u, v108, v109, v112, a4, a5);
            }
            else
            {
              sub_4137FD(a1, a2, v108, a4, a5);
              sub_412EC4(a1, 7, v109, a4, a5);
            }
            LODWORD(v152) = 176;
          }
          *(_DWORD *)(a1 + 1936) = v108 + 2;
          v113 = sub_417525(a1, v158, a4, a5);
          sub_412DAE(a1, SLOWORD(v152), v113, v108, a4, a5);
          *(_DWORD *)(a1 + 1936) = v109;
          v158[0] = 1;
          LODWORD(v159) = 2;
          HIDWORD(v159) = v108;
          goto LABEL_268;
        case 55:
          sub_4134F7(a1, a2, -1, a4, a5);
          if ( *(_DWORD *)(a1 + 1724) != 1 )
          {
            v94 = "expected identifier";
            v95 = 83890378;
            goto LABEL_261;
          }
          v96 = *((_QWORD *)a2 + 1);
          v97 = *(__int64 **)a1;
          v98 = a2[4];
          v158[0] = 3;
          v159 = v96;
          sub_4050B6(v97, v98, v160, v93, a4, a5);
          sub_407808(v86, *(_QWORD *)(a1 + 1736), a4, a5);
          sub_405057(v86, v162, v99, v100, *(double *)a4.i64, a5);
          *(_BYTE *)(a1 + 2020) = 1;
          LODWORD(v161) = 1;
          sub_412529(a1, a4, a5);
          goto LABEL_268;
        case 57:
          sub_413793(a1, a2, a4, a5);
          sub_4175A2(a1, v158, a4, a5, 5);
          goto LABEL_268;
        case 58:
          v92 = 10264;
          goto LABEL_215;
        case 59:
          v92 = 8216;
          goto LABEL_215;
        case 60:
          v92 = 11288;
          goto LABEL_215;
        case 61:
          v92 = 9240;
          goto LABEL_215;
        case 62:
          v92 = 4118;
          goto LABEL_215;
        case 63:
          v92 = 5142;
          goto LABEL_215;
        case 64:
          v92 = 6166;
          goto LABEL_215;
        case 65:
          v92 = 7190;
          goto LABEL_215;
        case 66:
          v92 = 13340;
          goto LABEL_215;
        case 67:
          v92 = 14364;
          goto LABEL_215;
        case 68:
          v92 = 15390;
          goto LABEL_215;
        case 69:
          v92 = 16414;
          goto LABEL_215;
        case 70:
          v92 = 17438;
          goto LABEL_215;
        case 71:
          v92 = 18463;
          goto LABEL_215;
        case 72:
          v91 = 8944128;
          goto LABEL_255;
        case 73:
          v91 = 9206528;
LABEL_255:
          v136 = sub_4128FC(a1, a4, a5);
          if ( *a2 == 4 )
          {
            v137 = (_DWORD *)sub_405B3C((__int64)v86, a2[4]);
            if ( *(_BYTE *)(a1 + 2010) && (*v137 & 0x2000) != 0 )
            {
              v94 = "invalid expression";
              v95 = 83891300;
              goto LABEL_261;
            }
            v138 = BYTE1(v91);
            sub_404F0A(v86, a2[4], a4, a5);
            if ( (unsigned int)sub_412615(a1, &v154, &v155, a4, a5) )
            {
              v139 = v154;
              v140 = v136;
              v141 = v138;
            }
            else
            {
              v139 = v155;
              v141 = v138 + 4;
              v140 = v136;
            }
            sub_412DAE(a1, v141, v140, v139, a4, a5);
          }
          else if ( *a2 == 3 )
          {
            v142 = sub_412F7E(a1, a2 + 2, -1, 0, a4, a5);
            v143 = sub_412F7E(a1, a2 + 5, -1, 1, a4, a5);
            sub_41315A(a1, HIWORD(v91) | 0x4000, v136, v142, v143, a4, a5);
          }
          else
          {
            sub_4137FD(a1, a2, v136, a4, a5);
            sub_412EC4(a1, 15, v136, a4, a5);
            sub_412903(a1, 170, a4, a5);
          }
          v158[0] = 1;
          LODWORD(v159) = 2;
          HIDWORD(v159) = v136;
          *(_DWORD *)(a1 + 1936) = v136 + 1;
          goto LABEL_268;
        case 74:
          v92 = 22554;
          goto LABEL_215;
        case 75:
          v92 = 24602;
          goto LABEL_215;
        case 76:
          v92 = 23578;
          goto LABEL_215;
        case 77:
          v92 = 19476;
          goto LABEL_215;
        case 78:
          v92 = 20496;
          goto LABEL_215;
        case 79:
          v92 = 21522;
LABEL_215:
          sub_4134F7(a1, a2, -1, a4, a5);
          sub_4175A2(a1, v158, a4, a5, (unsigned __int8)v92);
          v158[0] = 2;
          v158[1] = v92 >> 8;
          v161 = v159;
          sub_4050B6(v86, v160, v162, v117, a4, a5);
          v106 = a2[4];
          v105 = v86;
          v107 = v160;
          v159 = *((_QWORD *)a2 + 1);
LABEL_216:
          sub_4050B6(v105, v106, v107, v104, a4, a5);
          goto LABEL_268;
        case 82:
          v90 = 269;
          goto LABEL_218;
        case 83:
          v90 = 11;
LABEL_218:
          v118 = (unsigned __int8)v90;
          v114 = sub_4128FC(a1, a4, a5);
          sub_4137FD(a1, a2, v114, a4, a5);
          sub_412EC4(a1, v90 >> 8 == 0 ? 50 : 48, v114, a4, a5);
          v119 = sub_41299B(a1, a4, a5);
          sub_4174F4(a1, v158, a4, a5, v118, v114);
          sub_41223D(a1, v119);
          goto LABEL_253;
        case 84:
          v114 = sub_4128FC(a1, a4, a5);
          sub_4137FD(a1, a2, v114, a4, a5);
          sub_412ECD(a1, v114, a4, a5);
          v115 = sub_41299B(a1, a4, a5);
          sub_4174F4(a1, v158, a4, a5, 6, v114);
          sub_412449(a1, 85, a4, a5);
          v116 = sub_41299B(a1, a4, a5);
          sub_41223D(a1, v115);
          sub_4174F4(a1, v158, a4, a5, 6, v114);
          sub_41223D(a1, v116);
          *(_DWORD *)(a1 + 1936) = v114 + 1;
          goto LABEL_253;
        case 86:
          v89 = 65543;
          goto LABEL_221;
        case 87:
          v89 = 13319;
          goto LABEL_221;
        case 88:
          v89 = 14343;
          goto LABEL_221;
        case 89:
          v89 = 15367;
          goto LABEL_221;
        case 90:
          v89 = 16391;
          goto LABEL_221;
        case 91:
          v89 = 17415;
          goto LABEL_221;
        case 92:
          v89 = 18439;
          goto LABEL_221;
        case 93:
          v89 = 22535;
          goto LABEL_221;
        case 94:
          v89 = 24583;
          goto LABEL_221;
        case 95:
          v89 = 23559;
          goto LABEL_221;
        case 96:
          v89 = 19463;
          goto LABEL_221;
        case 97:
          v89 = 20487;
          goto LABEL_221;
        case 98:
          v89 = 21511;
LABEL_221:
          v120 = v89 >> 8;
          if ( *a2 == 4 )
          {
            v121 = a2[4];
            LODWORD(v152) = *(_DWORD *)(a1 + 1956);
            v122 = (_DWORD *)sub_405B3C((__int64)v86, v121);
            if ( *(_BYTE *)(a1 + 2010) && (*v122 & 0x2000) != 0 )
            {
              v94 = "invalid lvalue";
              v95 = 83891304;
LABEL_261:
              sub_401C42(v86, (__int64)"third_party/duktape/duk_js_compiler.c", v95, v94, a4, a5);
            }
            else
            {
              v123 = LODWORD(v152) == 1 && v87 == 1;
              sub_404F0A(v86, a2[4], a4, a5);
              sub_412615(a1, &v154, &v155, a4, a5);
              if ( v120 == 256 )
              {
                sub_413890(a1, v158, 7, a4, a5);
                if ( !v123 && (v158[0] != 1 || (_DWORD)v159 == 2 && HIDWORD(v159) < *(_DWORD *)(a1 + 1932)) )
                  sub_4137B8(a1, v158, -1, 3, a4, a5);
              }
              else
              {
                v125 = v120 | 0x4000;
                v126 = sub_4128FC(a1, a4, a5);
                v127 = v154;
                v128 = v126;
                if ( v154 < 0 )
                {
                  sub_412DAE(a1, 11, v126, v155, a4, a5);
                  sub_4175C8(a1, v158, a4, a5);
                  sub_41315A(a1, v125, v128, v128, SHIDWORD(v159), a4, a5);
                  HIDWORD(v159) = v128;
                }
                else
                {
                  if ( !v123 )
                  {
                    v129 = sub_4128FC(a1, a4, a5);
                    v127 = v128;
                    v128 = v129;
                  }
                  v130 = *(_QWORD *)(a1 + 1808);
                  v148 = v127;
                  v151 = v130;
                  v150 = *(_QWORD *)(a1 + 1816);
                  sub_412DAE(a1, 0, v128, v154, a4, a5);
                  *(_QWORD *)&v152 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
                  sub_4175C8(a1, v158, a4, a5);
                  v131 = v148;
                  if ( LODWORD(v152) == (unsigned int)((*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3) )
                  {
                    v128 = v154;
                    *(_QWORD *)(a1 + 1808) += (int)(8 * (((unsigned __int64)(v151 - v150) >> 3) - LODWORD(v152)));
                  }
                  LODWORD(v152) = v131;
                  sub_41315A(a1, v125, v131, v128, SHIDWORD(v159), a4, a5);
                  v132 = SLODWORD(v152) < *(_DWORD *)(a1 + 1932);
                  HIDWORD(v159) = LODWORD(v152);
                  if ( !v132 )
                    *(_DWORD *)(a1 + 1936) = LODWORD(v152) + 1;
                }
              }
              v133 = v154;
              if ( v154 >= 0 )
              {
                if ( v158[0] == 1 )
                  goto LABEL_244;
                v134 = v158;
                if ( !v123 )
                {
                  sub_4137B8(a1, v158, -1, 3, a4, a5);
LABEL_244:
                  sub_41282E((__int64 *)a1, v158, a2, v124, a4, a5);
                  v133 = v154;
                  v134 = a2;
                }
                sub_4137FD(a1, v134, v133, a4, a5);
                goto LABEL_268;
              }
              sub_4137B8(a1, v158, -1, 0, a4, a5);
              sub_412DAE(a1, 2203, SHIDWORD(v159), v155, a4, a5);
            }
          }
          else
          {
            if ( *a2 == 3 )
            {
              v135 = sub_412F7E(a1, a2 + 2, -1, 2, a4, a5);
              LODWORD(v152) = sub_412F7E(a1, a2 + 5, -1, 3, a4, a5);
              if ( v120 == 256 )
              {
                sub_4175C8(a1, v158, a4, a5);
                v114 = HIDWORD(v159);
              }
              else
              {
                v114 = sub_4128FC(a1, a4, a5);
                sub_41315A(a1, 0x406Cu, v114, v135, SLODWORD(v152), a4, a5);
                sub_4175C8(a1, v158, a4, a5);
                sub_41315A(a1, v120 | 0x4000, v114, v114, SHIDWORD(v159), a4, a5);
              }
              sub_41315A(a1, 0x4870u, v135, SLODWORD(v152), v114, a4, a5);
            }
            else
            {
              sub_413793(a1, a2, a4, a5);
              v114 = sub_4175C8(a1, v158, a4, a5);
              sub_412903(a1, 170, a4, a5);
            }
LABEL_253:
            v158[0] = 1;
            LODWORD(v159) = 2;
            HIDWORD(v159) = v114;
          }
LABEL_268:
          v16 = (__int64)v158;
          sub_41282E((__int64 *)a1, v158, a2, v101, a4, a5);
          break;
        default:
          v94 = "parse error";
          v95 = 83890814;
          goto LABEL_261;
      }
    }
  }
  if ( !_bittest(&v148, 9u) )
    return sub_401C42(
             v153,
             (__int64)"third_party/duktape/duk_js_compiler.c",
             0x50014C3u,
             "empty expression not allowed",
             a4,
             a5);
  sub_4068D1(v153, 16LL, v13, a4, a5);
  v15 = *(__int64 **)a1;
  v16 = (unsigned int)a2[4];
  *a2 = 1;
  a2[2] = 1;
  sub_405057(v15, v16, v17, v18, *(double *)a4.i64, a5);
LABEL_269:
  result = sub_407DC0(v153, v16, v19, v20, a4, a5);
  --*(_DWORD *)(a1 + 1792);
  return result;
}
// 413EB2: conditional instruction was optimized away because eax.4==1
// 4138EF: variable 'v11' is possibly undefined
// 4138F8: variable 'v12' is possibly undefined
// 413936: variable 'v13' is possibly undefined
// 413951: variable 'v17' is possibly undefined
// 413951: variable 'v18' is possibly undefined
// 413AF4: variable 'v21' is possibly undefined
// 413EFE: variable 'v62' is possibly undefined
// 413EFE: variable 'v63' is possibly undefined
// 41427B: variable 'v73' is possibly undefined
// 4145D1: variable 'v25' is possibly undefined
// 4145D1: variable 'v26' is possibly undefined
// 4146E1: variable 'v93' is possibly undefined
// 4146FB: variable 'v99' is possibly undefined
// 4146FB: variable 'v100' is possibly undefined
// 414764: variable 'v103' is possibly undefined
// 414B12: variable 'v117' is possibly undefined
// 414B29: variable 'v104' is possibly undefined
// 414DEB: variable 'v124' is possibly undefined
// 415056: variable 'v101' is possibly undefined
// 415064: variable 'v19' is possibly undefined
// 415064: variable 'v20' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (0000000000415091) ----------------------------------------------------
__int64 __fastcall sub_415091(
        __int64 a1,
        _DWORD *a2,
        signed __int32 a3,
        __m128 a4,
        __m128 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int16 v8; // r12
  __int64 *v9; // r13

  v8 = a3;
  *(_QWORD *)(a1 + 1964) = 0x100000000LL;
  *(_QWORD *)(a1 + 1956) = 0LL;
  v9 = *(__int64 **)a1;
  *(_DWORD *)(a1 + 1972) = (BYTE1(a3) ^ 1) & 1;
  sub_413890(a1, a2, a3, a4, a5);
  if ( (v8 & 0x200) != 0 || *(_DWORD *)(a1 + 1956) || *(_DWORD *)(a1 + 1960) )
    return a8;
  else
    return sub_401C42(
             v9,
             (__int64)"third_party/duktape/duk_js_compiler.c",
             0x50014ECu,
             "empty expression not allowed",
             a4,
             a5);
}

//----- (0000000000415116) ----------------------------------------------------
__int64 __fastcall sub_415116(__int64 a1, unsigned int *a2, int a3, _DWORD *a4, _DWORD *a5, __m128 a6, __m128 a7)
{
  __int64 *v7; // r12
  const signed __int32 *v8; // r15
  __int64 result; // rax
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  int v18; // eax
  int v21; // [rsp+18h] [rbp-48h]
  int v22; // [rsp+28h] [rbp-38h] BYREF
  int v23[13]; // [rsp+2Ch] [rbp-34h] BYREF

  v7 = *(__int64 **)a1;
  if ( *(_DWORD *)(a1 + 1720) != 1 )
    return sub_401C42(
             v7,
             (__int64)"third_party/duktape/duk_js_compiler.c",
             0x50015C7u,
             "invalid variable declaration",
             a6,
             a7);
  v8 = *(const signed __int32 **)(a1 + 1736);
  if ( *(_BYTE *)(a1 + 2010) )
  {
    if ( _bittest(v8, 0xDu) )
      return sub_401C42(
               v7,
               (__int64)"third_party/duktape/duk_js_compiler.c",
               0x50015C7u,
               "invalid variable declaration",
               a6,
               a7);
  }
  if ( *(_BYTE *)(a1 + 2013) )
  {
    v21 = sub_405CB0(v7, *(_DWORD *)(a1 + 1912), a6, a7);
    sub_407808(v7, (__int64)v8, a6, a7);
    sub_403953(v7, *(_DWORD *)(a1 + 1912), v21, a6, a7);
    sub_406A68(v7, 0, a6, a7);
    sub_403953(v7, *(_DWORD *)(a1 + 1912), v21 + 1, a6, a7);
  }
  sub_407808(v7, (__int64)v8, a6, a7);
  sub_404F67(v7, a6, a7);
  v12 = (__int64)&v22;
  sub_412615(a1, &v22, v23, a6, a7);
  sub_412529(a1, a6, a7);
  if ( *(_DWORD *)(a1 + 1720) == 86 )
  {
    sub_412529(a1, a6, a7);
    sub_415091(a1, a2, a3 | 6, a6, a7, v15, v16, v17);
    if ( v22 < 0 )
    {
      v18 = sub_4137B8(a1, a2, -1, 0, a6, a7);
      v12 = 2203LL;
      sub_412DAE(a1, 2203, v18, v23[0], a6, a7);
    }
    else
    {
      v12 = (__int64)a2;
      sub_4137FD(a1, a2, v22, a6, a7);
    }
  }
  else if ( (a3 & 0x400) != 0 )
  {
    return sub_401C42(
             v7,
             (__int64)"third_party/duktape/duk_js_compiler.c",
             0x50015C7u,
             "invalid variable declaration",
             a6,
             a7);
  }
  sub_407D7E(v7, v12, v13, v14, a6, a7);
  *a5 = v23[0];
  result = (unsigned int)v22;
  *a4 = v22;
  return result;
}
// 415216: variable 'v15' is possibly undefined
// 415216: variable 'v16' is possibly undefined
// 415216: variable 'v17' is possibly undefined
// 415260: variable 'v13' is possibly undefined
// 415260: variable 'v14' is possibly undefined
// 415116: using guessed type int var_34[13];

//----- (0000000000415286) ----------------------------------------------------
__int64 __fastcall sub_415286(__int64 a1, unsigned int *a2, int a3, __m128 a4, __m128 a5)
{
  __int64 result; // rax
  int v7; // [rsp+8h] [rbp-28h] BYREF
  int v8[9]; // [rsp+Ch] [rbp-24h] BYREF

  do
  {
    sub_412529(a1, a4, a5);
    result = sub_415116(a1, a2, a3, &v7, v8, a4, a5);
  }
  while ( *(_DWORD *)(a1 + 1720) == 57 );
  return result;
}
// 415286: using guessed type int var_24[9];

//----- (00000000004152CE) ----------------------------------------------------
__int64 __fastcall sub_4152CE(
        __int64 a1,
        unsigned int *a2,
        __m128 a3,
        __m128 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  sub_415091(a1, a2, 4, a3, a4, a6, a7, a8);
  return sub_4137B8(a1, a2, -1, 1, a3, a4);
}

//----- (00000000004152FE) ----------------------------------------------------
void __fastcall sub_4152FE(__int64 a1, unsigned int *a2, int a3, __m128 a4, __m128 a5)
{
  __int64 v5; // r15
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // rax
  unsigned int v13; // er14
  const char *v14; // rcx
  unsigned int v15; // edx
  int v16; // er12
  int v17; // er13
  int v18; // edx
  int v19; // er13
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  unsigned int v24; // eax
  int v25; // eax
  int v26; // er12
  int v27; // esi
  int v28; // er13
  unsigned __int64 v29; // r12
  __int64 v30; // rdx
  __int64 v31; // rcx
  __int64 v32; // r8
  __int64 v33; // r9
  unsigned int v34; // eax
  int v35; // er14
  unsigned __int64 v36; // r12
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  unsigned int v41; // eax
  int v42; // eax
  int v43; // er13
  int v44; // esi
  __int64 *v45; // r13
  int v46; // er12
  int v47; // er14
  __int64 v48; // rcx
  __int64 v49; // r8
  __int64 v50; // r9
  bool v51; // zf
  int v52; // ecx
  int v53; // edx
  __int64 v54; // r15
  const char *v55; // rcx
  unsigned int v56; // edx
  __int64 *v57; // rdi
  __int16 v58; // si
  int v59; // er13
  int v60; // eax
  __int64 v61; // r13
  __int64 v62; // rcx
  __int64 v63; // r8
  __int64 v64; // r9
  int v65; // er14
  unsigned int v66; // eax
  __int64 v67; // rcx
  __int64 v68; // r8
  __int64 v69; // r9
  int v70; // er15
  unsigned __int64 v71; // r12
  unsigned __int64 v72; // r12
  int v73; // esi
  int v74; // er8
  int v75; // er8
  int v76; // esi
  int v77; // edx
  __int64 *v78; // rdi
  int v79; // edx
  _DWORD *v80; // rax
  __int64 v81; // rax
  __int64 v82; // rcx
  __int64 v83; // r8
  __int64 v84; // r9
  int v85; // eax
  int v86; // eax
  unsigned __int64 v87; // r14
  unsigned __int64 v88; // r13
  int v89; // er12
  int v90; // er8
  int v91; // er8
  __int64 *v92; // r12
  int v93; // eax
  int v94; // edx
  const char *v95; // rcx
  unsigned int v96; // edx
  __int64 *v97; // rdi
  int v98; // edx
  __int16 v99; // si
  __int64 *v100; // r12
  __int64 v101; // rdx
  __int64 v102; // rcx
  __int64 v103; // r8
  __int64 v104; // r9
  unsigned __int64 v105; // r12
  int v106; // eax
  __int64 v107; // rcx
  int v108; // edx
  unsigned __int64 v109; // r12
  unsigned __int64 v110; // rax
  _DWORD *v111; // rcx
  __int16 v112; // si
  _BOOL4 v113; // er12
  __int64 v114; // rdx
  __int64 v115; // rcx
  int v116; // er13
  __int64 v117; // rcx
  __int64 v118; // r8
  __int64 v119; // r9
  unsigned __int64 v120; // r12
  __int64 v121; // r12
  int v122; // er14
  int v123; // er13
  __int64 v124; // rdx
  __int64 v125; // rcx
  __int64 v126; // r8
  __int64 v127; // r9
  int v128; // er15
  int v129; // eax
  __int64 v130; // rdx
  __int64 v131; // rcx
  __int64 v132; // r8
  __int64 v133; // r9
  unsigned int v134; // er13
  __int64 v135; // rcx
  __int64 v136; // r8
  __int64 v137; // r9
  __int64 *v138; // r12
  __int64 v139; // r15
  __int64 v140; // r13
  __int64 v141; // r14
  __int64 v142; // rax
  int v143; // er14
  __int64 v144; // rdx
  __int64 v145; // rcx
  __int64 v146; // rdx
  __int64 v147; // rdx
  unsigned __int64 v148; // r15
  int v149; // er14
  unsigned __int64 v150; // r13
  unsigned __int64 v151; // r13
  int v152; // esi
  __int64 v153; // rcx
  unsigned __int64 v154; // r12
  _DWORD *v155; // rdx
  int v156; // eax
  int v157; // esi
  int v158; // eax
  __int64 v159; // r12
  __int64 v160; // rsi
  char v161; // r14
  __int64 v162; // rdi
  int v163; // eax
  int v164; // edx
  __int64 *v165; // r12
  int v166; // esi
  __int64 v167; // [rsp+0h] [rbp-90h]
  int v168; // [rsp+8h] [rbp-88h]
  __int64 v169; // [rsp+8h] [rbp-88h]
  __int64 v170; // [rsp+10h] [rbp-80h]
  int v171; // [rsp+10h] [rbp-80h]
  __int64 v172; // [rsp+10h] [rbp-80h]
  int v173; // [rsp+18h] [rbp-78h]
  int v174; // [rsp+18h] [rbp-78h]
  int v175; // [rsp+18h] [rbp-78h]
  __int64 v176; // [rsp+18h] [rbp-78h]
  __int64 v177; // [rsp+20h] [rbp-70h]
  char v178; // [rsp+28h] [rbp-68h]
  int v179; // [rsp+28h] [rbp-68h]
  __int64 v180; // [rsp+28h] [rbp-68h]
  __int64 v181; // [rsp+28h] [rbp-68h]
  int v182; // [rsp+28h] [rbp-68h]
  __int64 *v183; // [rsp+30h] [rbp-60h]
  __int64 v184; // [rsp+38h] [rbp-58h]
  int v185; // [rsp+38h] [rbp-58h]
  int v186; // [rsp+38h] [rbp-58h]
  int v187; // [rsp+40h] [rbp-50h]
  int v188; // [rsp+44h] [rbp-4Ch]
  int v190; // [rsp+50h] [rbp-40h] BYREF
  int v191; // [rsp+54h] [rbp-3Ch] BYREF
  int v192; // [rsp+58h] [rbp-38h] BYREF
  int v193[13]; // [rsp+5Ch] [rbp-34h] BYREF

  v5 = 134746624LL;
  v183 = *(__int64 **)a1;
  sub_412889(a1, a4, a5);
  v187 = *(_DWORD *)(a1 + 1936);
  v184 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
  v8 = sub_405CB0(v183, *(_DWORD *)(a1 + 1916), a4, a5);
  ++*(_DWORD *)(a1 + 1976);
  v177 = v8;
  LOBYTE(v8) = *(_BYTE *)(a1 + 2012);
  v188 = -1;
  *(_BYTE *)(a1 + 2012) = 0;
  v178 = v8;
  while ( 1 )
  {
    v12 = *(unsigned int *)(a1 + 1720);
    if ( (unsigned int)v12 <= 0x1B && _bittest64(&v5, v12) )
    {
      v188 = sub_412ED7(a1, v188, a4, a5);
      sub_412717(a1, *(_QWORD *)(v183[71] + 120), v184, v188, a4, a5);
    }
    v13 = *(_DWORD *)(a1 + 1720);
    if ( v13 > 0x31 )
    {
      if ( v13 == 56 )
      {
LABEL_175:
        LOBYTE(v13) = 2;
        goto LABEL_176;
      }
    }
    else if ( v13 > 1 )
    {
      switch ( v13 )
      {
        case 2u:
        case 5u:
          v92 = *(__int64 **)a1;
          v192 = 0;
          v190 = 0;
          v191 = 0;
          v193[0] = 0;
          sub_412529(a1, a4, a5);
          v93 = *(_DWORD *)(a1 + 1720);
          v94 = v13 == 2;
          if ( v93 == 56 || *(_QWORD *)(a1 + 1768) )
          {
            sub_4123AE((__int64 *)a1, *(_QWORD *)(v92[71] + 120), v94, &v190, &v191, &v192, a4, a5, v193);
          }
          else
          {
            if ( v93 != 1 )
            {
              v95 = "invalid break/continue label";
              v96 = 83892425;
              v97 = v92;
              goto LABEL_119;
            }
            sub_4123AE((__int64 *)a1, *(_QWORD *)(a1 + 1736), v94, &v190, &v191, &v192, a4, a5, v193);
            sub_412529(a1, a4, a5);
          }
          if ( *(_DWORD *)(a1 + 1984) == v191 && v193[0] )
          {
            sub_412D6A((__int64 *)a1, (v13 != 2) + v192 + 1, a4, a5);
            goto LABEL_120;
          }
          v98 = v190;
          v99 = (v13 != 2) + 163;
          goto LABEL_122;
        case 6u:
          sub_412529(a1, a4, a5);
          goto LABEL_175;
        case 9u:
          LOBYTE(v13) = 6;
          sub_412810(*(_QWORD *)(a1 + 1880), v188, 3);
          sub_412529(a1, a4, a5);
          v29 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
          sub_4152FE(a1, a2, 0, a4, a5);
          sub_41223D(a1, v184 + 2);
          sub_412449(a1, 27, a4, a5);
          sub_412449(a1, 53, a4, a5);
          v34 = sub_4152CE(a1, a2, a4, a5, v30, v31, v32, v33);
          sub_412EC4(a1, (v34 >> 31) + 50, v34, a4, a5);
          sub_412D6A((__int64 *)a1, v29 >> 3, a4, a5);
          *(_BYTE *)(a1 + 2021) = 1;
          sub_412449(a1, 54, a4, a5);
          sub_41223D(a1, v184 + 1);
          goto LABEL_176;
        case 0xCu:
          sub_412810(*(_QWORD *)(a1 + 1880), v188, 3);
          v45 = *(__int64 **)a1;
          v46 = sub_4128B7(a1, 2, a4, a5);
          v47 = *(_DWORD *)(a1 + 1936);
          sub_412529(a1, a4, a5);
          sub_412449(a1, 53, a4, a5);
          if ( *(_DWORD *)(a1 + 1720) == 24 )
          {
            sub_412529(a1, a4, a5);
            sub_415116(a1, a2, 256, &v192, v193, a4, a5);
            v51 = *(_DWORD *)(a1 + 1720) == 15;
            *(_DWORD *)(a1 + 1936) = v47;
            if ( v51 )
            {
              v52 = v46;
              v53 = v192;
              v54 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
              if ( v192 < 0 )
              {
LABEL_43:
                v52 = v193[0];
                v53 = v46;
                v58 = 2203;
                goto LABEL_44;
              }
LABEL_42:
              v58 = 0;
LABEL_44:
              sub_412DAE(a1, v58, v53, v52, a4, a5);
LABEL_61:
              v78 = *(__int64 **)a1;
              *(_DWORD *)(a1 + 1936) = v47;
              sub_41D23D(v78, (_QWORD *)(a1 + 1808), 8LL * (int)v54, 8uLL, a4, a5);
              v79 = *(_DWORD *)(a1 + 1760);
              *v80 = 2;
              v80[1] = v79;
              v81 = *(_QWORD *)(a1 + 1808) + 8LL;
              *(_QWORD *)(a1 + 1808) = v81;
              if ( (unsigned __int64)(v81 - *(_QWORD *)(a1 + 1816)) > 0x7FFF0000 )
                sub_401CE2(
                  *(__int64 **)a1,
                  (__int64)"third_party/duktape/duk_js_compiler.c",
                  1947,
                  "bytecode limit",
                  a4,
                  a5);
              v168 = sub_41299B(a1, a4, a5);
              sub_412529(a1, a4, a5);
              v180 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
              sub_415091(a1, a2, 4, a4, a5, v82, v83, v84);
              v85 = sub_4137B8(a1, a2, -1, 0, a4, a5);
              sub_41315A(a1, 0x10C9u, 0, v46 + 1, v85, a4, a5);
              v86 = sub_41299B(a1, a4, a5);
              *(_DWORD *)(a1 + 1936) = v47;
              *(_BYTE *)(a1 + 2021) = 1;
              v174 = v86;
              sub_412449(a1, 54, a4, a5);
              v87 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
              sub_4152FE(a1, a2, 0, a4, a5);
              v88 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
              sub_41315A(a1, 0x90CAu, 0, v46, v46 + 1, a4, a5);
              v89 = *(_DWORD *)(a1 + 1800);
              v88 >>= 3;
              sub_412D6A((__int64 *)a1, v54 + 1, a4, a5);
              sub_41221D(a1, v54, v180);
              sub_41221D(a1, v168, v87 >> 3);
              sub_41221D(a1, v174, v88);
              sub_41221D(a1, v89, v90);
              sub_41221D(a1, v184 + 1, v91);
              v77 = v88;
              v76 = v184 + 2;
              goto LABEL_64;
            }
            while ( *(_DWORD *)(a1 + 1720) == 57 )
            {
              sub_412529(a1, a4, a5);
              sub_415116(a1, a2, 256, &v192, v193, a4, a5);
            }
          }
          else
          {
            v54 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
            sub_415091(a1, a2, 772, a4, a5, v48, v49, v50);
            if ( *(_DWORD *)(a1 + 1720) == 15 )
            {
              if ( !*(_DWORD *)(a1 + 1956) && !*(_DWORD *)(a1 + 1960) )
              {
                v55 = "invalid for statement";
                v56 = 83892059;
                v57 = v45;
                goto LABEL_116;
              }
              if ( *a2 != 4 )
              {
                if ( *a2 == 3 )
                {
                  v59 = sub_412F7E(a1, a2 + 2, -1, 0, a4, a5);
                  v60 = sub_412F7E(a1, a2 + 5, -1, 1, a4, a5);
                  sub_41315A(a1, 0x4870u, v59, v60, v46, a4, a5);
                }
                else
                {
                  sub_413793(a1, a2, a4, a5);
                  sub_412903(a1, 170, a4, a5);
                }
                goto LABEL_61;
              }
              sub_404F0A(v45, a2[4], a4, a5);
              if ( !(unsigned int)sub_412615(a1, &v192, v193, a4, a5) )
                goto LABEL_43;
              v53 = v192;
              v52 = v46;
              goto LABEL_42;
            }
            sub_413793(a1, a2, a4, a5);
          }
          *(_DWORD *)(a1 + 1936) = v46;
          sub_412449(a1, 56, a4, a5);
          v61 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
          sub_415091(a1, a2, 516, a4, a5, v62, v63, v64);
          v65 = v61;
          if ( *(_DWORD *)(a1 + 1956) || *(_DWORD *)(a1 + 1960) )
          {
            v66 = sub_4137B8(a1, a2, -1, 1, a4, a5);
            sub_412EC4(a1, (v66 >> 31) + 50, v66, a4, a5);
            v179 = sub_41299B(a1, a4, a5);
            v173 = sub_41299B(a1, a4, a5);
          }
          else
          {
            v173 = -1;
            v179 = sub_41299B(a1, a4, a5);
          }
          *(_DWORD *)(a1 + 1936) = v46;
          sub_412449(a1, 56, a4, a5);
          v170 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
          sub_415091(a1, a2, 516, a4, a5, v67, v68, v69);
          if ( *(_DWORD *)(a1 + 1956) || (v70 = 1, *(_DWORD *)(a1 + 1960)) )
          {
            v70 = 0;
            sub_413793(a1, a2, a4, a5);
            sub_412D6A((__int64 *)a1, v61, a4, a5);
          }
          *(_DWORD *)(a1 + 1936) = v46;
          *(_BYTE *)(a1 + 2021) = 1;
          sub_412449(a1, 54, a4, a5);
          v71 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
          sub_4152FE(a1, a2, 0, a4, a5);
          v72 = v71 >> 3;
          v73 = v61;
          if ( !v70 )
            v73 = v170;
          sub_412D6A((__int64 *)a1, v73, a4, a5);
          sub_41221D(a1, v179, v72);
          sub_41221D(a1, v173, v74);
          sub_41221D(a1, v184 + 1, v75);
          if ( !v70 )
            v65 = v170;
          v76 = v184 + 2;
          v77 = v65;
LABEL_64:
          sub_41221D(a1, v76, v77);
          goto LABEL_15;
        case 0xDu:
          if ( !a3 && *(_BYTE *)(a1 + 2010) )
          {
            v14 = "function statement not allowed";
            v15 = 83893027;
            goto LABEL_185;
          }
          sub_412529(a1, a4, a5);
          v16 = sub_4170A8(a1, 9, a4, a5);
          if ( *(_BYTE *)(a1 + 2013) )
          {
            v17 = sub_405CB0(v183, *(_DWORD *)(a1 + 1912), a4, a5);
            sub_403953(v183, *(_DWORD *)(a1 + 1912), v17, a4, a5);
            sub_406A68(v183, (v16 << 8) + 1, a4, a5);
            sub_403953(v183, *(_DWORD *)(a1 + 1912), v17 + 1, a4, a5);
          }
          goto LABEL_15;
        case 0xEu:
          v19 = *(_DWORD *)(a1 + 1936);
          sub_412529(a1, a4, a5);
          sub_412449(a1, 53, a4, a5);
          v24 = sub_4152CE(a1, a2, a4, a5, v20, v21, v22, v23);
          sub_412ECD(a1, v24, a4, a5);
          v25 = sub_41299B(a1, a4, a5);
          *(_DWORD *)(a1 + 1936) = v19;
          *(_BYTE *)(a1 + 2021) = 1;
          v26 = v25;
          sub_412449(a1, 54, a4, a5);
          sub_4152FE(a1, a2, 0, a4, a5);
          v27 = v26;
          if ( *(_DWORD *)(a1 + 1720) == 10 )
          {
            sub_412529(a1, a4, a5);
            v28 = sub_41299B(a1, a4, a5);
            sub_41223D(a1, v26);
            sub_4152FE(a1, a2, 0, a4, a5);
            v27 = v28;
          }
          sub_41223D(a1, v27);
          goto LABEL_23;
        case 0x12u:
          v100 = *(__int64 **)a1;
          sub_412529(a1, a4, a5);
          if ( *(_BYTE *)(a1 + 2004) )
          {
            if ( *(_DWORD *)(a1 + 1720) == 56 || *(_QWORD *)(a1 + 1768) )
            {
              sub_412903(a1, 158, a4, a5);
            }
            else
            {
              v105 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
              v106 = sub_4152CE(a1, a2, a4, a5, v101, v102, v103, v104);
              v107 = *(_QWORD *)(a1 + 1816);
              v108 = v106;
              v109 = v105 >> 3;
              v110 = (unsigned __int64)(*(_QWORD *)(a1 + 1808) - v107) >> 3;
              if ( !*(_DWORD *)(a1 + 1984) && (int)v109 < (int)v110 )
              {
                v111 = (_DWORD *)(v107 + 8LL * ((int)v110 - 1));
                if ( (*v111 & 0xF0) == 176 && v108 >= *(_DWORD *)(a1 + 1932) )
                  *v111 |= 1u;
              }
              v112 = 157;
              if ( v108 < 0 )
              {
                v185 = v108 & 0x7FFFFFFF;
                sub_40370E(*(__int64 **)a1, *(_DWORD *)(a1 + 1904), v108 & 0x7FFFFFFF, a4, a5);
                v113 = sub_4064DB(*(_QWORD *)a1, -1);
                sub_407D7E(*(__int64 **)a1, 0xFFFFFFFFLL, v114, v115, a4, a5);
                v108 = v185;
                v112 = 159;
                if ( v113 )
                  v112 = 160;
              }
              sub_412EC4(a1, v112, v108, a4, a5);
            }
          }
          else
          {
            sub_401C42(v100, (__int64)"third_party/duktape/duk_js_compiler.c", 0x50018F5u, "invalid return", a4, a5);
          }
          goto LABEL_176;
        case 0x13u:
          LODWORD(v121) = -1;
          v122 = -1;
          v123 = -1;
          sub_412810(*(_QWORD *)(a1 + 1880), v188, 1);
          v181 = *(_QWORD *)a1;
          sub_412529(a1, a4, a5);
          sub_412449(a1, 53, a4, a5);
          v175 = sub_4152CE(a1, a2, a4, a5, v124, v125, v126, v127);
          sub_412449(a1, 54, a4, a5);
          sub_412449(a1, 49, a4, a5);
          v128 = *(_DWORD *)(a1 + 1936);
          while ( 2 )
          {
            v129 = *(_DWORD *)(a1 + 1720);
            *(_DWORD *)(a1 + 1936) = v128;
            if ( v129 == 50 )
            {
              *(_BYTE *)(a1 + 2021) = 1;
              sub_412529(a1, a4, a5);
              if ( (int)v121 < 0 )
                sub_41223D(a1, v123);
              else
                sub_41221D(a1, v123, v121);
              v44 = v122;
LABEL_27:
              sub_41223D(a1, v44);
LABEL_28:
              sub_41223D(a1, v184 + 1);
            }
            else
            {
              if ( v129 == 3 )
              {
                sub_41223D(a1, v123);
                sub_412529(a1, a4, a5);
                v171 = sub_4152CE(a1, a2, a4, a5, v130, v131, v132, v133);
                sub_412449(a1, 85, a4, a5);
                v134 = sub_4128FC(a1, a4, a5);
                sub_41315A(a1, 0x4018u, v134, v175, v171, a4, a5);
                sub_412ECD(a1, v134, a4, a5);
                v123 = sub_41299B(a1, a4, a5);
                if ( (_DWORD)v121 != -2 )
                  goto LABEL_106;
                goto LABEL_105;
              }
              if ( (int)v121 < 0 && v129 == 7 )
              {
                sub_412529(a1, a4, a5);
                sub_412449(a1, 85, a4, a5);
                if ( v123 < 0 )
                  v123 = sub_41299B(a1, a4, a5);
LABEL_105:
                v121 = (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3;
LABEL_106:
                sub_41223D(a1, v122);
                while ( (*(_DWORD *)(a1 + 1720) & 0xFFFFFFFB) != 3 && *(_DWORD *)(a1 + 1720) != 50 )
                  sub_4152FE(a1, a2, 0, a4, a5);
                v122 = sub_41299B(a1, a4, a5);
                continue;
              }
              v57 = (__int64 *)v181;
              v55 = "invalid switch statement";
              v56 = 83892265;
LABEL_116:
              sub_401C42(v57, (__int64)"third_party/duktape/duk_js_compiler.c", v56, v55, a4, a5);
            }
            goto LABEL_15;
          }
        case 0x15u:
          sub_412529(a1, a4, a5);
          if ( *(_DWORD *)(a1 + 1768) )
          {
            v97 = *(__int64 **)a1;
            v95 = "invalid throw";
            v96 = 83892575;
LABEL_119:
            sub_401C42(v97, (__int64)"third_party/duktape/duk_js_compiler.c", v96, v95, a4, a5);
          }
          else
          {
            sub_415091(a1, a2, 4, a4, a5, v135, v136, v137);
            v99 = 169;
            v98 = sub_4137B8(a1, a2, -1, 0, a4, a5);
LABEL_122:
            sub_412EC4(a1, v99, v98, a4, a5);
          }
LABEL_120:
          LOBYTE(v13) = 18;
          goto LABEL_176;
        case 0x16u:
          ++*(_DWORD *)(a1 + 1984);
          v138 = *(__int64 **)a1;
          sub_412529(a1, a4, a5);
          v186 = sub_4128B7(a1, 2, a4, a5);
          v176 = *(_QWORD *)(a1 + 1808);
          v172 = *(_QWORD *)(a1 + 1816);
          sub_412DAE(a1, 3, v186, 0, a4, a5);
          v169 = *(_QWORD *)(a1 + 1808);
          v167 = *(_QWORD *)(a1 + 1816);
          sub_4129C3(a1, a4, a5);
          sub_4129C3(a1, a4, a5);
          sub_4129C3(a1, a4, a5);
          sub_412449(a1, 49, a4, a5);
          sub_416732(a1, 0, 0, 1, a4, a5);
          sub_412903(a1, 166, a4, a5);
          if ( *(_DWORD *)(a1 + 1720) == 4 )
          {
            v139 = *(_QWORD *)(a1 + 1808);
            v140 = *(_QWORD *)(a1 + 1816);
            sub_412529(a1, a4, a5);
            sub_412449(a1, 53, a4, a5);
            if ( *(_DWORD *)(a1 + 1720) != 1 )
              goto LABEL_157;
            v141 = *(_QWORD *)(a1 + 1736);
            sub_407808(v138, v141, a4, a5);
            if ( *(_BYTE *)(a1 + 2010) )
            {
              v142 = v138[71];
              if ( v141 == *(_QWORD *)(v142 + 264) || v141 == *(_QWORD *)(v142 + 536) )
                goto LABEL_157;
            }
            v143 = -2;
            sub_404F67(v138, a4, a5);
            v182 = sub_412531(a1, a4, a5);
            sub_412529(a1, a4, a5);
            sub_412449(a1, 54, a4, a5);
            sub_412449(a1, 49, a4, a5);
            sub_404F67(v138, a4, a5);
            sub_403616(v138, *(_DWORD *)(a1 + 1928), a4, a5);
            if ( !sub_40649F((__int64)v138, -1) )
            {
              v143 = -1;
              if ( !sub_4064B3((__int64)v138, -1) )
                v143 = sub_405483(v138, -1, a4, a5);
            }
            sub_407D7E(v138, 0xFFFFFFFFLL, v144, v145, a4, a5);
            sub_404F67(v138, a4, a5);
            sub_40691D(v138, 0xFFFFFFFFLL, v146, a4, a5);
            sub_40388B(v138, *(_DWORD *)(a1 + 1928), a4, a5);
            sub_412DAE(a1, 2203, v186, v182, a4, a5);
            sub_416732(a1, 0, 0, 1, a4, a5);
            if ( v143 == -2 )
            {
              sub_403A0F(v138, *(_DWORD *)(a1 + 1928), a4, a5);
            }
            else
            {
              if ( v143 == -1 )
                sub_40691D(v138, 0LL, v147, a4, a5);
              else
                sub_406A68(v138, v143, a4, a5);
              sub_40388B(v138, *(_DWORD *)(a1 + 1928), a4, a5);
            }
            v148 = (unsigned __int64)(v139 - v140) >> 3;
            v149 = 5;
            sub_412903(a1, 167, a4, a5);
          }
          else
          {
            LODWORD(v148) = -1;
            v149 = 0;
            v182 = 0;
          }
          LODWORD(v150) = -1;
          if ( *(_DWORD *)(a1 + 1720) == 11 )
          {
            v151 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
            sub_412529(a1, a4, a5);
            v149 |= 2u;
            sub_412449(a1, 49, a4, a5);
            v150 = v151 >> 3;
            sub_416732(a1, 0, 0, 1, a4, a5);
            if ( v186 <= 0xFFFFFF )
            {
              v152 = v186 << 8;
              LOBYTE(v152) = -88;
              sub_412903(a1, v152, a4, a5);
            }
            else
            {
              sub_401CE2(
                *(__int64 **)a1,
                (__int64)"third_party/duktape/duk_js_compiler.c",
                1832,
                "register limit",
                a4,
                a5);
            }
          }
          if ( (v149 & 3) != 0 )
          {
            v153 = *(_QWORD *)(a1 + 1816);
            v154 = (unsigned __int64)(v169 - v167) >> 3;
            v155 = (_DWORD *)(v153 + 8LL * (int)((unsigned __int64)(v176 - v172) >> 3));
            if ( v182 >= 0 )
            {
              *v155 = 205;
            }
            else
            {
              if ( (v182 & 0x7FFF0000) != 0 || v186 > 0xFFFF )
              {
                sub_401CE2(
                  *(__int64 **)a1,
                  (__int64)"third_party/duktape/duk_js_compiler.c",
                  2014,
                  "register limit",
                  a4,
                  a5);
LABEL_151:
                if ( (v149 & 1) != 0 )
                  sub_41221D(a1, v154 + 1, v148);
                v157 = v154 + 2;
                if ( (v149 & 2) != 0 )
                  sub_41221D(a1, v157, v150);
                else
                  sub_41223D(a1, v157);
                --*(_DWORD *)(a1 + 1984);
LABEL_15:
                LOBYTE(v13) = 0;
                goto LABEL_176;
              }
              *v155 |= v182 << 16;
            }
            v156 = (v149 << 8) | (v186 << 16);
            LOBYTE(v156) = -91;
            *(_DWORD *)(v153 + 8LL * (int)v154) = v156;
            goto LABEL_151;
          }
LABEL_157:
          v55 = "invalid try";
          v56 = 83892819;
          v57 = v138;
          goto LABEL_116;
        case 0x18u:
          v18 = 0;
          goto LABEL_19;
        case 0x19u:
          v18 = 1024;
LABEL_19:
          sub_415286(a1, a2, v18, a4, a5);
          goto LABEL_175;
        case 0x1Bu:
          sub_412810(*(_QWORD *)(a1 + 1880), v188, 3);
          v35 = *(_DWORD *)(a1 + 1936);
          sub_412529(a1, a4, a5);
          sub_412449(a1, 53, a4, a5);
          v36 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
          sub_41223D(a1, v184 + 2);
          v41 = sub_4152CE(a1, a2, a4, a5, v37, v38, v39, v40);
          sub_412ECD(a1, v41, a4, a5);
          v42 = sub_41299B(a1, a4, a5);
          *(_DWORD *)(a1 + 1936) = v35;
          *(_BYTE *)(a1 + 2021) = 1;
          v43 = v42;
          sub_412449(a1, 54, a4, a5);
          sub_4152FE(a1, a2, 0, a4, a5);
          sub_412D6A((__int64 *)a1, v36 >> 3, a4, a5);
          v44 = v43;
          goto LABEL_27;
        case 0x1Cu:
          ++*(_DWORD *)(a1 + 1988);
          if ( *(_BYTE *)(a1 + 2010) )
          {
            sub_401C42(
              *(__int64 **)a1,
              (__int64)"third_party/duktape/duk_js_compiler.c",
              0x5001A5Fu,
              "with in strict mode",
              a4,
              a5);
          }
          else
          {
            ++*(_DWORD *)(a1 + 1984);
            sub_412529(a1, a4, a5);
            v116 = sub_4128B7(a1, 2, a4, a5);
            sub_412449(a1, 53, a4, a5);
            sub_415091(a1, a2, 4, a4, a5, v117, v118, v119);
            sub_4137FD(a1, a2, v116, a4, a5);
            *(_BYTE *)(a1 + 2021) = 1;
            sub_412449(a1, 54, a4, a5);
            v120 = *(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816);
            sub_412DAE(a1, 421, 8, v116, a4, a5);
            sub_4129C3(a1, a4, a5);
            sub_4129C3(a1, a4, a5);
            sub_4152FE(a1, a2, 0, a4, a5);
            sub_412903(a1, 166, a4, a5);
            sub_41221D(a1, (v120 >> 3) + 2, (*(_QWORD *)(a1 + 1808) - *(_QWORD *)(a1 + 1816)) >> 3);
            --*(_DWORD *)(a1 + 1984);
          }
          if ( v188 >= 0 )
            sub_41223D(a1, v184 + 1);
          --*(_DWORD *)(a1 + 1988);
          goto LABEL_15;
        case 0x31u:
          sub_412529(a1, a4, a5);
          sub_416732(a1, 0, 0, 1, a4, a5);
LABEL_23:
          if ( v188 >= 0 )
            goto LABEL_28;
          goto LABEL_15;
        default:
          break;
      }
    }
    sub_415091(a1, a2, 4, a4, a5, v9, v10, v11);
    if ( *(_DWORD *)(a1 + 1956) != 1 || *(_DWORD *)(a1 + 1960) )
    {
LABEL_173:
      v161 = 0;
      goto LABEL_174;
    }
    v158 = *(_DWORD *)(a1 + 1664);
    if ( v158 != 1 )
      break;
    if ( *(_DWORD *)(a1 + 1720) != 85 )
      goto LABEL_173;
    v159 = *(_QWORD *)(a1 + 1680);
    sub_412529(a1, a4, a5);
    v160 = v159;
    v188 = sub_412ED7(a1, v188, a4, a5);
    a3 = 0;
    sub_412717(a1, v160, v184, v188, a4, a5);
  }
  v161 = 0;
  if ( v178 )
  {
    if ( v158 == 100 )
    {
      v161 = 8;
      if ( *(int *)(a1 + 1708) <= 0 )
      {
        v162 = *(_QWORD *)(a1 + 1680);
        v163 = *(_DWORD *)(v162 + 24);
        if ( v163 == 10 )
        {
          if ( !(unsigned int)sub_43AD14(v162 + 32, "use strict") )
            *(_BYTE *)(a1 + 2010) = 1;
        }
        else if ( v163 == 14 && !(unsigned int)sub_43AD14(v162 + 32, "use duk notail") )
        {
          *(_BYTE *)(a1 + 2011) = 1;
        }
      }
    }
  }
LABEL_174:
  LOBYTE(v13) = v161 | 3;
LABEL_176:
  if ( (v13 & 1) != 0 )
  {
    v164 = *(_DWORD *)(a1 + 2000);
    if ( v164 < 0 )
      sub_413793(a1, a2, a4, a5);
    else
      sub_4137FD(a1, a2, v164, a4, a5);
  }
  if ( (v13 & 2) == 0 )
    goto LABEL_186;
  if ( *(_DWORD *)(a1 + 1720) == 56 )
  {
    sub_412529(a1, a4, a5);
    goto LABEL_186;
  }
  if ( *(_DWORD *)(a1 + 1772) | v13 & 4 )
  {
LABEL_186:
    if ( (v13 & 8) != 0 )
      *(_BYTE *)(a1 + 2012) = 1;
    if ( v188 >= 0 )
      sub_412EC4(a1, 162, v188, a4, a5);
    v165 = *(__int64 **)a1;
    v166 = *(_DWORD *)(a1 + 1916);
    *(_DWORD *)(a1 + 1936) = v187;
    sub_406AF7(v165, v166, a4, a5);
    sub_4200FB(v165, *(_QWORD *)(a1 + 1880), 24 * v177, a4, a5);
    --*(_DWORD *)(a1 + 1792);
  }
  else
  {
    v14 = "unterminated statement";
    v15 = 83893377;
LABEL_185:
    sub_401C42(v183, (__int64)"third_party/duktape/duk_js_compiler.c", v15, v14, a4, a5);
  }
}
// 4154DD: variable 'v20' is possibly undefined
// 4154DD: variable 'v21' is possibly undefined
// 4154DD: variable 'v22' is possibly undefined
// 4154DD: variable 'v23' is possibly undefined
// 4155DD: variable 'v30' is possibly undefined
// 4155DD: variable 'v31' is possibly undefined
// 4155DD: variable 'v32' is possibly undefined
// 4155DD: variable 'v33' is possibly undefined
// 415679: variable 'v37' is possibly undefined
// 415679: variable 'v38' is possibly undefined
// 415679: variable 'v39' is possibly undefined
// 415679: variable 'v40' is possibly undefined
// 4157DB: variable 'v48' is possibly undefined
// 4157DB: variable 'v49' is possibly undefined
// 4157DB: variable 'v50' is possibly undefined
// 415911: variable 'v62' is possibly undefined
// 415911: variable 'v63' is possibly undefined
// 415911: variable 'v64' is possibly undefined
// 4159B1: variable 'v67' is possibly undefined
// 4159B1: variable 'v68' is possibly undefined
// 4159B1: variable 'v69' is possibly undefined
// 415A5C: variable 'v74' is possibly undefined
// 415A6A: variable 'v75' is possibly undefined
// 415AAD: variable 'v80' is possibly undefined
// 415B26: variable 'v82' is possibly undefined
// 415B26: variable 'v83' is possibly undefined
// 415B26: variable 'v84' is possibly undefined
// 415C20: variable 'v90' is possibly undefined
// 415C2E: variable 'v91' is possibly undefined
// 415DB4: variable 'v101' is possibly undefined
// 415DB4: variable 'v102' is possibly undefined
// 415DB4: variable 'v103' is possibly undefined
// 415DB4: variable 'v104' is possibly undefined
// 415E3A: variable 'v114' is possibly undefined
// 415E3A: variable 'v115' is possibly undefined
// 415EC0: variable 'v117' is possibly undefined
// 415EC0: variable 'v118' is possibly undefined
// 415EC0: variable 'v119' is possibly undefined
// 415FC0: variable 'v124' is possibly undefined
// 415FC0: variable 'v125' is possibly undefined
// 415FC0: variable 'v126' is possibly undefined
// 415FC0: variable 'v127' is possibly undefined
// 41601B: variable 'v130' is possibly undefined
// 41601B: variable 'v131' is possibly undefined
// 41601B: variable 'v132' is possibly undefined
// 41601B: variable 'v133' is possibly undefined
// 41618B: variable 'v135' is possibly undefined
// 41618B: variable 'v136' is possibly undefined
// 41618B: variable 'v137' is possibly undefined
// 416358: variable 'v144' is possibly undefined
// 416358: variable 'v145' is possibly undefined
// 416368: variable 'v146' is possibly undefined
// 4163BE: variable 'v147' is possibly undefined
// 416582: variable 'v9' is possibly undefined
// 416582: variable 'v10' is possibly undefined
// 416582: variable 'v11' is possibly undefined
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);

//----- (0000000000416732) ----------------------------------------------------
__int64 __fastcall sub_416732(__int64 a1, int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v8; // rsi
  __int64 *v11; // r12
  unsigned int *v12; // rdi
  __int64 i; // rcx
  __int64 v14; // rdx
  __int64 v15; // rdx
  int v16; // eax
  __int64 v18; // rdx
  __int64 v19; // rcx
  unsigned int v21[4]; // [rsp+0h] [rbp-50h] BYREF
  int v22; // [rsp+10h] [rbp-40h]
  int v23; // [rsp+1Ch] [rbp-34h]

  v8 = 16LL;
  v11 = *(__int64 **)a1;
  sub_404E3A(*(__int64 **)a1, 16, a5, a6);
  v12 = v21;
  for ( i = 8LL; i; --i )
    *v12++ = 0;
  v21[0] = 1;
  v21[2] = 1;
  v22 = sub_404AE7((__int64)v11);
  v23 = v22 + 1;
  sub_4068D1(v11, 16LL, v14, a5, a6);
  sub_4068D1(v11, 16LL, v15, a5, a6);
  while ( 1 )
  {
    v16 = *(_DWORD *)(a1 + 1720);
    if ( a3 ? v16 == 0 : v16 == 50 )
      break;
    v8 = (__int64)v21;
    sub_4152FE(a1, v21, a2, a5, a6);
  }
  if ( a4 )
    *(_BYTE *)(a1 + 2021) = 1;
  sub_412529(a1, a5, a6);
  return sub_407DC0(v11, v8, v18, v19, a5, a6);
}
// 41678C: variable 'v14' is possibly undefined
// 416794: variable 'v15' is possibly undefined
// 4167D6: variable 'v18' is possibly undefined
// 4167D6: variable 'v19' is possibly undefined

//----- (00000000004167EA) ----------------------------------------------------
__int64 __fastcall sub_4167EA(__int64 a1, int a2, int a3, int a4, int a5, __m128 a6, __m128 a7)
{
  __int64 *v9; // rax
  int v10; // eax
  int *v11; // rax
  __int64 *v12; // rbx
  int v13; // esi
  int v14; // esi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 *v17; // r12
  unsigned int v18; // esi
  __int64 *v19; // rdi
  __int64 v20; // rax
  int v21; // ebx
  __int64 v22; // rax
  int v23; // er13
  const signed __int32 *v24; // rax
  const signed __int32 *v25; // r14
  int v26; // esi
  bool v27; // cc
  int v28; // eax
  unsigned int v29; // ebx
  int v30; // er14
  int v31; // er13
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // rsi
  int v35; // er13
  int v36; // eax
  __int64 v37; // rdx
  unsigned int i; // ebx
  char v39; // r14
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // rax
  __int64 v43; // rcx
  __int64 v44; // rdx
  int v45; // eax
  int v46; // er14
  __int64 v47; // rdx
  bool v48; // zf
  int v49; // er12
  int v50; // eax
  int *v51; // rax
  int v52; // eax
  __int64 result; // rax
  __int64 v54; // rsi
  int v55; // er10
  unsigned __int64 v56; // rdx
  int v57; // er8
  unsigned int v58; // ecx
  int v59; // edi
  unsigned int v60; // ecx
  int v61; // [rsp+4h] [rbp-8Ch]
  __int64 v62; // [rsp+8h] [rbp-88h]
  char v63; // [rsp+13h] [rbp-7Dh]
  int v66; // [rsp+1Ch] [rbp-74h]
  unsigned int v67; // [rsp+20h] [rbp-70h]
  int v68; // [rsp+24h] [rbp-6Ch]
  int *v69; // [rsp+28h] [rbp-68h]
  unsigned __int8 v71; // [rsp+34h] [rbp-5Ch]
  int v72; // [rsp+34h] [rbp-5Ch]
  int v73; // [rsp+34h] [rbp-5Ch]
  __int64 *v74; // [rsp+38h] [rbp-58h]
  int v75; // [rsp+4Ch] [rbp-44h] BYREF
  char v76[64]; // [rsp+50h] [rbp-40h] BYREF

  v9 = *(__int64 **)a1;
  v75 = -1;
  v74 = v9;
  sub_412889(a1, a6, a7);
  sub_404E3A(v74, 16, a6, a7);
  v62 = a1 + 16;
  sub_418FB0(a1 + 16, (__int64)v76);
  if ( a3 )
    v75 = sub_4128FC(a1, a6, a7);
  v10 = v75;
  *(_DWORD *)(a1 + 2012) = 257;
  *(_WORD *)(a1 + 2016) = 0;
  *(_DWORD *)(a1 + 2000) = v10;
  if ( a5 == -1 )
  {
    *(_DWORD *)(a1 + 1720) = 0;
    sub_412529(a1, a6, a7);
  }
  else
  {
    sub_412449(a1, a5, a6, a7);
  }
  sub_416732(a1, 1, a2, a4, a6, a7);
  v11 = 0LL;
  v66 = 2;
  if ( a3 )
    v11 = &v75;
  v69 = v11;
  while ( 1 )
  {
    v63 = *(_BYTE *)(a1 + 2019);
    sub_418FC1(v62, (__int64)v76, a6, a7);
    *(_DWORD *)(a1 + 1720) = 0;
    *(_DWORD *)(a1 + 1760) = 0;
    sub_412529(a1, a6, a7);
    v12 = *(__int64 **)a1;
    v13 = *(_DWORD *)(a1 + 1904);
    *(_QWORD *)(a1 + 1808) = *(_QWORD *)(a1 + 1816);
    sub_406AF7(v12, v13, a6, a7);
    v14 = *(_DWORD *)(a1 + 1916);
    *(_DWORD *)(a1 + 1992) = 0;
    sub_406AF7(v12, v14, a6, a7);
    sub_42011D(v12, *(_QWORD *)(a1 + 1880), a6, a7);
    sub_40779C(v12, a6, a7);
    sub_405057(v12, *(_DWORD *)(a1 + 1928), v15, v16, *(double *)a6.i64, a7);
    v17 = *(__int64 **)a1;
    v18 = *(_DWORD *)(a1 + 1924);
    v19 = *(__int64 **)a1;
    v20 = v12[13] + 16LL * *(int *)(a1 + 1928);
    v21 = 0;
    v22 = *(_QWORD *)(v20 + 8);
    *(_WORD *)(a1 + 2012) = 1;
    *(_QWORD *)(a1 + 1896) = v22;
    v71 = *(_BYTE *)(a1 + 2005);
    v23 = sub_405CB0(v19, v18, a6, a7);
    while ( v23 != v21 )
    {
      sub_40370E(v17, *(_DWORD *)(a1 + 1924), v21, a6, a7);
      v24 = (const signed __int32 *)sub_405B3C((__int64)v17, -1);
      v25 = v24;
      if ( *(_BYTE *)(a1 + 2010) )
      {
        if ( _bittest(v24, 0xDu)
          || (sub_404F67(v17, a6, a7), (unsigned int)sub_403BC8(v17, *(_DWORD *)(a1 + 1928), a6, a7))
          || (*v25 & 0x1000) != 0 )
        {
          sub_401C42(v17, (__int64)"third_party/duktape/duk_js_compiler.c", 0x5001E3Du, "invalid argument name", a6, a7);
          goto LABEL_50;
        }
      }
      v26 = v21++;
      sub_406AAF(v17, v26, a6, a7);
      sub_40388B(v17, *(_DWORD *)(a1 + 1928), a6, a7);
    }
    v27 = v23 <= *(_DWORD *)(a1 + 1940);
    *(_DWORD *)(a1 + 1936) = v23;
    if ( !v27 )
      *(_DWORD *)(a1 + 1940) = v23;
    if ( v69 )
      *v69 = sub_4128FC(a1, a6, a7);
    if ( *(_BYTE *)(a1 + 2019) )
    {
      v28 = sub_4128B7(a1, 3, a6, a7);
      *(_DWORD *)(a1 + 1944) = v28;
      *(_DWORD *)(a1 + 1952) = v28 + 2;
      *(_DWORD *)(a1 + 1948) = v28 + 1;
    }
    if ( *(int *)(a1 + 1936) <= 256 )
    {
      v68 = v71;
      v67 = sub_405CB0(v17, *(_DWORD *)(a1 + 1912), a6, a7);
      v29 = 0;
      v30 = v71 == 0 ? 19 : 23;
      while ( v67 > v29 )
      {
        sub_40370E(v17, *(_DWORD *)(a1 + 1912), v29 + 1, a6, a7);
        v31 = sub_405DB7(v17, -1, a6, a7);
        sub_407D7E(v17, 0xFFFFFFFFLL, v32, v33, a6, a7);
        if ( (_BYTE)v31 == 1 )
        {
          v34 = *(unsigned int *)(a1 + 1912);
          v35 = v31 >> 8;
          sub_40370E(v17, v34, v29, a6, a7);
          if ( *(_BYTE *)(a1 + 2004) )
          {
            sub_404F67(v17, a6, a7);
            if ( (unsigned int)sub_403BC8(v17, *(_DWORD *)(a1 + 1928), a6, a7) )
            {
              sub_404F67(v17, a6, a7);
              sub_403616(v17, *(_DWORD *)(a1 + 1928), a6, a7);
              v36 = sub_405DB7(v17, -1, a6, a7);
              sub_412DAE(a1, 152, v36, v35, a6, a7);
            }
            else
            {
              v72 = sub_4128FC(a1, a6, a7);
              sub_412DAE(a1, 152, v72, v35, a6, a7);
              sub_406A68(v17, v72, a6, a7);
            }
          }
          else
          {
            v73 = sub_4128FC(a1, a6, a7);
            sub_404F67(v17, a6, a7);
            v61 = sub_412531(a1, a6, a7);
            sub_40691D(v17, v34, v37, a6, a7);
            sub_412DAE(a1, 152, v73, v35, a6, a7);
            sub_41315A(a1, 0x4190u, v30, v61, v73, a6, a7);
            *(_DWORD *)(a1 + 1936) = v73;
          }
          sub_40388B(v17, *(_DWORD *)(a1 + 1928), a6, a7);
        }
        v29 += 2;
      }
      if ( (unsigned int)sub_403D2E(v17, *(_DWORD *)(a1 + 1928), 0x43u, a6, a7) )
        *(_BYTE *)(a1 + 2018) = 1;
      for ( i = 0; v67 > i; i += 2 )
      {
        sub_40370E(v17, *(_DWORD *)(a1 + 1912), i + 1, a6, a7);
        v39 = sub_405DB7(v17, -1, a6, a7);
        sub_407D7E(v17, 0xFFFFFFFFLL, v40, v41, a6, a7);
        if ( !v39 )
        {
          sub_40370E(v17, *(_DWORD *)(a1 + 1912), i, a6, a7);
          if ( !(unsigned int)sub_403BC8(v17, *(_DWORD *)(a1 + 1928), a6, a7) )
          {
            sub_40370E(v17, *(_DWORD *)(a1 + 1912), i, a6, a7);
            v42 = sub_405B3C((__int64)v17, -1);
            v44 = v17[71];
            if ( *(_QWORD *)(v44 + 536) != v42 || *(_BYTE *)(a1 + 2018) )
            {
              if ( *(_BYTE *)(a1 + 2004) )
              {
                v45 = sub_4128FC(a1, a6, a7);
                sub_406A68(v17, v45, a6, a7);
              }
              else
              {
                sub_404F67(v17, a6, a7);
                v46 = sub_412531(a1, a6, a7);
                sub_40691D(v17, 0xFFFFFFFFLL, v47, a6, a7);
                sub_41315A(a1, 0x4190u, v68 == 0 ? 3 : 7, v46, 0, a6, a7);
              }
              sub_40388B(v17, *(_DWORD *)(a1 + 1928), a6, a7);
            }
            else
            {
              sub_407D7E(v17, 0xFFFFFFFFLL, v44, v43, a6, a7);
            }
          }
        }
      }
    }
    else
    {
      sub_401CE2(v17, (__int64)"third_party/duktape/duk_js_compiler.c", 7737, "register limit", a6, a7);
    }
LABEL_50:
    v48 = *(_BYTE *)(a1 + 2004) == 0;
    v49 = v75;
    v50 = *(_DWORD *)(a1 + 1936);
    *(_QWORD *)(a1 + 1976) = 0LL;
    *(_BYTE *)(a1 + 2015) = 0;
    *(_WORD *)(a1 + 2016) = 0;
    *(_DWORD *)(a1 + 2000) = v49;
    *(_DWORD *)(a1 + 1932) = v50;
    if ( !v48 && !*(_BYTE *)(a1 + 2009) )
    {
      v51 = *(int **)(a1 + 1840);
      if ( v51 )
      {
        v52 = *v51;
        if ( *(_BYTE *)(a1 + 2010) )
        {
          if ( (v52 & 0x3000) != 0 )
            return sub_401C42(
                     v74,
                     (__int64)"third_party/duktape/duk_js_compiler.c",
                     0x5001F6Au,
                     "invalid function name",
                     a6,
                     a7);
        }
        else if ( (v52 & 0x1800) == 2048 )
        {
          return sub_401C42(
                   v74,
                   (__int64)"third_party/duktape/duk_js_compiler.c",
                   0x5001F6Au,
                   "invalid function name",
                   a6,
                   a7);
        }
      }
    }
    if ( a3 )
      sub_412EC4(a1, 7, 0, a6, a7);
    sub_416732(a1, 1, a2, a4, a6, a7);
    if ( v63 == *(_BYTE *)(a1 + 2019) )
      break;
    if ( v66 == 1 )
      return sub_401CB7(v74, (__int64)"third_party/duktape/duk_js_compiler.c", 7997, a6, a7);
    v66 = 1;
  }
  if ( v49 < 0 )
    sub_412903(a1, 158, a6, a7);
  else
    sub_412EC4(a1, 157, v49, a6, a7);
  v54 = *(_QWORD *)(a1 + 1816);
  v55 = 3;
  v56 = (unsigned __int64)(*(_QWORD *)(a1 + 1808) - v54) >> 3;
  do
  {
    result = 0LL;
    v57 = 0;
    while ( (int)v56 > (int)result )
    {
      v58 = *(_DWORD *)(v54 + 8 * result);
      if ( (_BYTE)v58 == 2 )
      {
        v59 = (v58 >> 8) + result - 0x7FFFFF;
        v60 = *(_DWORD *)(v54 + 8LL * v59);
        if ( (_BYTE)v60 == 2 )
        {
          ++v57;
          *(_DWORD *)(v54 + 8 * result) = ((v59 - (_DWORD)result + (v60 >> 8)) << 8) | 2;
        }
      }
      ++result;
    }
    if ( !v57 )
      break;
    --v55;
  }
  while ( v55 );
  --*(_DWORD *)(a1 + 1792);
  return result;
}
// 41695E: variable 'v15' is possibly undefined
// 41695E: variable 'v16' is possibly undefined
// 416B0A: variable 'v32' is possibly undefined
// 416B0A: variable 'v33' is possibly undefined
// 416BE2: variable 'v37' is possibly undefined
// 416C96: variable 'v40' is possibly undefined
// 416C96: variable 'v41' is possibly undefined
// 416D06: variable 'v43' is possibly undefined
// 416D41: variable 'v47' is possibly undefined

//----- (0000000000416F22) ----------------------------------------------------
__int64 __fastcall sub_416F22(__int64 a1, char a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 *v5; // r13
  int v6; // edx
  const char *v7; // rcx
  unsigned int v8; // edx
  __int64 *v10; // r13
  int v11; // eax
  int v12; // eax

  v4 = a1 + 1664;
  v5 = *(__int64 **)a1;
  if ( (a2 & 0x10) == 0 )
    v4 = a1 + 1720;
  v6 = *(_DWORD *)(v4 + 4);
  if ( (a2 & 2) != 0 )
  {
    if ( v6 != 1 && *(_DWORD *)v4 != 100 )
    {
      if ( *(_DWORD *)v4 == 99 )
      {
        a3.i64[0] = *(__int64 *)(v4 + 8);
        sub_406A1B(*(__int64 **)a1, a3, a4);
        sub_408725(v5, -1, a3, a4);
        goto LABEL_11;
      }
      v7 = "invalid getter/setter name";
      v8 = 83894239;
      return sub_401C42(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", v8, v7, a3, a4);
    }
  }
  else if ( v6 != 1 )
  {
    if ( (a2 & 1) == 0 )
      goto LABEL_16;
    v7 = "function name required";
    v8 = 83894259;
    return sub_401C42(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", v8, v7, a3, a4);
  }
  sub_407808(*(__int64 **)a1, *(_QWORD *)(v4 + 16), a3, a4);
LABEL_11:
  *(_QWORD *)(a1 + 1840) = sub_405B3C((__int64)v5, -1);
  if ( (a2 & 0x10) == 0 )
    sub_412529(a1, a3, a4);
LABEL_16:
  sub_412449(a1, 53, a3, a4);
  v10 = *(__int64 **)a1;
  v11 = 1;
  while ( *(_DWORD *)(a1 + 1720) != 54 )
  {
    if ( !v11 )
      sub_412449(a1, 57, a3, a4);
    if ( *(_DWORD *)(a1 + 1720) != 1 )
    {
      sub_401C42(v10, (__int64)"third_party/duktape/duk_js_compiler.c", 0x5001F9Bu, "expected identifier", a3, a4);
      break;
    }
    sub_407808(v10, *(_QWORD *)(a1 + 1736), a3, a4);
    v12 = sub_405CB0(v10, *(_DWORD *)(a1 + 1924), a3, a4);
    sub_403953(v10, *(_DWORD *)(a1 + 1924), v12, a3, a4);
    sub_412529(a1, a3, a4);
    v11 = 0;
  }
  sub_412529(a1, a3, a4);
  sub_4167EA(a1, 0, 0, a2 & 1, 49, a3, a4);
  return sub_4129CD((_QWORD **)a1, a3, a4);
}

//----- (00000000004170A8) ----------------------------------------------------
__int64 __fastcall sub_4170A8(__int64 a1, char a2, __m128 a3, __m128 a4)
{
  __int64 *v5; // r12
  unsigned int v6; // er13
  int v7; // esi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rcx
  int v12; // er14
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  char v15; // al
  unsigned int v17; // esi
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v21; // [rsp+18h] [rbp-108h] BYREF
  int v22; // [rsp+20h] [rbp-100h]
  int v23; // [rsp+7Ch] [rbp-A4h]
  int v24; // [rsp+D0h] [rbp-50h]
  char v25; // [rsp+E2h] [rbp-3Eh]

  v5 = *(__int64 **)a1;
  if ( *(_BYTE *)(a1 + 2013) )
  {
    v12 = sub_404AE7(*(_QWORD *)a1);
    sub_43AAA0((__int64)&v21, a1 + 1808, 0xD8uLL);
    sub_43ABE2(v13, 0LL, v14);
    sub_412251(a1, a3, a4);
    v15 = v25;
    *(_BYTE *)(a1 + 2004) = 1;
    *(_BYTE *)(a1 + 2010) = v15;
    *(_BYTE *)(a1 + 2007) = (a2 & 7) == 0;
    *(_BYTE *)(a1 + 2009) = (a2 & 2) != 0;
    *(_BYTE *)(a1 + 2008) = (a2 & 6) == 0;
    sub_416F22(a1, a2, a3, a4);
    v6 = v24;
    if ( v24++ <= 0xFFFF )
    {
      sub_403953(v5, v23, 3 * v6, a3, a4);
      sub_406AAF(v5, *(_DWORD *)(a1 + 1696), a3, a4);
      sub_403953(v5, v23, 3 * v6 + 1, a3, a4);
      sub_406A68(v5, *(_DWORD *)(a1 + 1704), a3, a4);
      sub_403953(v5, v23, 3 * v6 + 2, a3, a4);
      v17 = v12;
      if ( (a2 & 8) != 0 )
      {
        sub_407808(v5, *(_QWORD *)(a1 + 1840), a3, a4);
        sub_405057(v5, v12, v18, v19, *(double *)a3.i64, a4);
        v17 = v12 + 1;
      }
      sub_404B20(v5, v17, a3, a4);
      sub_43AAA0(a1 + 1808, (__int64)&v21, 0xD8uLL);
    }
    else
    {
      v6 = 0;
      sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_js_compiler.c", 8346, "function limit", a3, a4);
    }
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 1992);
    v7 = *(_DWORD *)(a1 + 1908);
    *(_DWORD *)(a1 + 1992) = v6 + 1;
    sub_40370E(v5, v7, 3 * v6 + 1, a3, a4);
    v21 = (unsigned int)sub_405DDC(v5, -1, a3, a4);
    sub_407D7E(v5, 0xFFFFFFFFLL, v8, v9, a3, a4);
    sub_40370E(v5, *(_DWORD *)(a1 + 1908), 3 * v6 + 2, a3, a4);
    v22 = sub_405DB7(v5, -1, a3, a4);
    sub_407D7E(v5, 0xFFFFFFFFLL, v10, v11, a3, a4);
    sub_418FC1(a1 + 16, (__int64)&v21, a3, a4);
    *(_DWORD *)(a1 + 1720) = 0;
    *(_DWORD *)(a1 + 1760) = 0;
    sub_412529(a1, a3, a4);
    if ( (a2 & 1) != 0 )
      *(_BYTE *)(a1 + 2021) = 1;
    sub_412449(a1, 50, a3, a4);
  }
  return v6;
}
// 417110: variable 'v8' is possibly undefined
// 417110: variable 'v9' is possibly undefined
// 41713C: variable 'v10' is possibly undefined
// 41713C: variable 'v11' is possibly undefined
// 4171C0: variable 'v13' is possibly undefined
// 4171C0: variable 'v14' is possibly undefined
// 4172BC: variable 'v18' is possibly undefined
// 4172BC: variable 'v19' is possibly undefined

//----- (00000000004172FA) ----------------------------------------------------
__int64 __fastcall sub_4172FA(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  _QWORD **v4; // r14
  int v5; // ebx
  int v6; // er13
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v12; // [rsp+0h] [rbp-40h]
  int v13; // [rsp+8h] [rbp-38h]
  int v14; // [rsp+Ch] [rbp-34h]

  v4 = (_QWORD **)(a2 + 8);
  v13 = sub_404AE7((__int64)a1);
  v5 = (*(_DWORD *)a2 >> 12) & 1;
  v6 = (*(_DWORD *)a2 >> 3) & 1;
  v14 = (*(_DWORD *)a2 >> 5) & 1;
  v12 = sub_40568B((__int64)a1, -1);
  sub_404E3A(a1, 8, a3, a4);
  sub_40762B(a1, 0LL, 1, a3, a4);
  sub_4068D1(a1, 0LL, v7, a3, a4);
  sub_4068D1(a1, 0LL, v8, a3, a4);
  sub_4068D1(a1, 0LL, v9, a3, a4);
  sub_4068D1(a1, 0LL, v10, a3, a4);
  *(_QWORD *)(a2 + 8) = a1;
  *(_DWORD *)(a2 + 1804) = 2500;
  *(_QWORD *)(a2 + 1568) = a1;
  *(_QWORD *)(a2 + 16) = v12;
  *(_DWORD *)(a2 + 1612) = v13;
  *(_DWORD *)(a2 + 1792) = v13 + 3;
  *(_DWORD *)(a2 + 1784) = v13 + 1;
  *(_DWORD *)(a2 + 1604) = v13 + 1;
  *(_DWORD *)(a2 + 1788) = v13 + 2;
  *(_DWORD *)(a2 + 1796) = v13 + 4;
  *(_DWORD *)(a2 + 1608) = v13 + 2;
  *(_QWORD *)(a2 + 1616) = sub_405B46((__int64)a1, v13);
  *(_DWORD *)(a2 + 1660) = 100000000;
  *(_QWORD *)(a2 + 2032) = 0LL;
  *(_DWORD *)(a2 + 2040) = 1;
  sub_418FC1(a2 + 24, a2 + 2032, a3, a4);
  *(_DWORD *)(a2 + 1768) = 0;
  sub_412251(a2 + 8, a3, a4);
  if ( !v5 )
  {
    sub_407826(a1, v6 == 0 ? 27 : 33, a3, a4);
    *(_QWORD *)(a2 + 1848) = sub_40568B((__int64)a1, -1);
  }
  *(_BYTE *)(a2 + 2018) = v14;
  if ( v5 )
  {
    *(_BYTE *)(a2 + 2012) = 1;
    *(_WORD *)(a2 + 2015) = 257;
    sub_412529((__int64)v4, a3, a4);
    sub_412449((__int64)v4, 13, a3, a4);
    sub_416F22((__int64)v4, 0, a3, a4);
  }
  else
  {
    *(_BYTE *)(a2 + 2013) = v6;
    *(_BYTE *)(a2 + 2014) = v6 ^ 1;
    sub_4167EA((__int64)v4, 1, 1, 1, -1, a3, a4);
  }
  sub_4129CD(v4, a3, a4);
  return 1LL;
}
// 41736A: variable 'v7' is possibly undefined
// 417372: variable 'v8' is possibly undefined
// 41737A: variable 'v9' is possibly undefined
// 417382: variable 'v10' is possibly undefined

//----- (00000000004174F4) ----------------------------------------------------
__int64 __fastcall sub_4174F4(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4, signed __int32 a5, int a6)
{
  sub_413890(a1, a2, a5, a3, a4);
  return sub_4137FD(a1, a2, a6, a3, a4);
}

//----- (0000000000417525) ----------------------------------------------------
__int64 __fastcall sub_417525(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er13
  int v5; // eax
  int v6; // ebx

  v4 = 0;
  while ( *(_DWORD *)(a1 + 1720) != 54 )
  {
    if ( v4 )
      sub_412449(a1, 57, a3, a4);
    ++v4;
    v5 = sub_4128FC(a1, a3, a4);
    *(_DWORD *)(a1 + 1936) = v5;
    v6 = v5 + 1;
    sub_4174F4(a1, a2, a3, a4, 6, v5);
    *(_DWORD *)(a1 + 1936) = v6;
  }
  sub_412449(a1, 54, a3, a4);
  return v4;
}

//----- (00000000004175A2) ----------------------------------------------------
void __fastcall sub_4175A2(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4, signed __int32 a5)
{
  sub_413890(a1, a2, a5, a3, a4);
  sub_4134F7(a1, a2, -1, a3, a4);
}

//----- (00000000004175C8) ----------------------------------------------------
__int64 __fastcall sub_4175C8(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4)
{
  sub_413890(a1, a2, 7, a3, a4);
  return sub_4137B8(a1, a2, -1, 1, a3, a4);
}

//----- (00000000004175F8) ----------------------------------------------------
__int64 __fastcall sub_4175F8(__int64 *a1, __int64 a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  int v8; // ecx
  __int64 v9; // rbx
  __int64 result; // rax
  int v11; // [rsp+0h] [rbp-830h] BYREF
  char v12; // [rsp+8h] [rbp-828h] BYREF
  char v13[1552]; // [rsp+18h] [rbp-818h] BYREF
  __int64 v14; // [rsp+628h] [rbp-208h]
  __int64 v15; // [rsp+630h] [rbp-200h]
  int v16; // [rsp+680h] [rbp-1B0h]

  sub_43ABE2((__int64)&v11, 0LL, 0x800uLL);
  v11 = v8;
  sub_418FA3((__int64)v13);
  v16 = a4;
  v9 = a1[19];
  a1[19] = (__int64)&v12;
  v14 = a2;
  v15 = a3;
  result = sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_4172FA, (__int64)&v11, 1, 1, a5, a6);
  a1[19] = v9;
  if ( (_DWORD)result )
    return sub_408001(a1, (__int64)sub_4172FA, a5, a6);
  return result;
}
// 417634: variable 'v8' is possibly undefined
// 4175F8: using guessed type char var_818[1552];

//----- (00000000004176AB) ----------------------------------------------------
__int64 __fastcall sub_4176AB(__int64 *a1, __int128 *a2, __int128 *a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v8; // rcx
  __int64 v9; // r14
  unsigned int v11; // er13
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned int v15; // eax
  __int64 v16; // r14
  int v17; // ebx
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r15
  __int64 v21; // rax

  sub_406883(a1, a2, a5, a6);
  sub_406883(a1, a3, a5, a6);
  v9 = sub_40582D(a1, -1, a5, a6);
  if ( !a4 && (unsigned int)sub_404413(a1, 0xFFFFFFFFLL, 0x4Du, a5, a6) )
  {
    sub_40500F(a1, -3);
    sub_404F05(a1, -2);
    sub_41DA64(a1, 1, a5, a6);
    return sub_405C10(a1, a5, a6);
  }
  v11 = *(_DWORD *)v9 & 0x200;
  if ( v11 )
  {
    if ( (*(_DWORD *)v9 & 0x400) != 0 )
    {
      sub_406883(a1, (__int128 *)(v9 + 56), a5, a6);
      sub_405057(a1, -2, v12, v13, *(double *)a5.i64, a6);
      sub_40582D(a1, -1, a5, a6);
    }
    v14 = a1[14];
    v15 = *(_DWORD *)(v14 - 32);
    if ( v15 == 9 )
    {
      v16 = *(_QWORD *)(v14 - 24);
      v17 = 1;
      goto LABEL_19;
    }
    if ( v15 > 9 )
    {
      if ( v15 == 10 )
      {
        v16 = a1[62];
        goto LABEL_16;
      }
    }
    else
    {
      if ( v15 == 5 )
      {
        v16 = a1[56];
        goto LABEL_16;
      }
      if ( v15 == 6 )
      {
        v16 = a1[25];
LABEL_16:
        v17 = 0;
LABEL_19:
        v11 = 10000;
        sub_4037B9(a1, -65486, a5, a6);
        v20 = sub_405823((__int64)a1, -1);
        if ( v20 )
        {
          do
          {
            if ( !v16 )
            {
              sub_407DFC((__int64)a1, 0xFFFFFFFFLL, v18, v19, a5, a6);
              return 0;
            }
            v21 = sub_40DF43(v16);
            if ( !v17 && v20 == v21 )
            {
              v11 = 1;
              sub_407DFC((__int64)a1, 0xFFFFFFFFLL, v18, v19, a5, a6);
              return v11;
            }
            v17 = 0;
            --v11;
            v16 = *(_QWORD *)(v21 + 32);
          }
          while ( v11 );
          sub_401CE2(a1, (__int64)"third_party/duktape/duk_js_ops.c", 1181, "prototype chain limit", a5, a6);
          return v11;
        }
        sub_401C42(
          a1,
          (__int64)"third_party/duktape/duk_js_ops.c",
          0x60004B2u,
          "instanceof rval has no .prototype",
          a5,
          a6);
        return 0;
      }
    }
    sub_407DE7((__int64)a1, 0xFFFFFFFFLL, v14, v8, a5, a6);
    return 0;
  }
  sub_401C42(a1, (__int64)"third_party/duktape/duk_js_ops.c", 0x60004ADu, "invalid instanceof rval", a5, a6);
  return v11;
}
// 417777: variable 'v12' is possibly undefined
// 417777: variable 'v13' is possibly undefined
// 4177D3: variable 'v8' is possibly undefined
// 417821: variable 'v18' is possibly undefined
// 417821: variable 'v19' is possibly undefined

//----- (000000000041787D) ----------------------------------------------------
__int64 __fastcall sub_41787D(unsigned int a1, double a2, double a3)
{
  unsigned int v3; // er12

  v3 = a1;
  if ( a3 <= a2 )
  {
    if ( a2 <= a3 && (sub_41D3C3(a2) || sub_41D3C3(a3)) )
      return 0;
  }
  else
  {
    return a1 ^ 1;
  }
  return v3;
}

//----- (00000000004178C9) ----------------------------------------------------
__int64 __fastcall sub_4178C9(__int64 a1)
{
  __int64 result; // rax
  bool v2; // zf

  switch ( *(_DWORD *)a1 )
  {
    case 2:
    case 3:
      result = 0LL;
      break;
    case 4:
      result = *(unsigned int *)(a1 + 8);
      break;
    case 5:
      v2 = *(_QWORD *)(a1 + 8) == 0LL;
      goto LABEL_6;
    case 6:
    case 9:
    case 0xA:
      result = 1LL;
      break;
    case 8:
      v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 24LL) == 0;
LABEL_6:
      result = !v2;
      break;
    default:
      result = (unsigned int)sub_41D3F3(*(double *)(a1 + 8)) ^ 1;
      break;
  }
  return result;
}

//----- (0000000000417910) ----------------------------------------------------
double __fastcall sub_417910(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  bool v4; // zf
  const signed __int32 *v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rcx

  switch ( *(_DWORD *)a2 )
  {
    case 2:
    case 6:
      *(double *)a3.i64 = NAN;
      return *(double *)a3.i64;
    case 3:
      goto LABEL_12;
    case 4:
      v4 = *(_DWORD *)(a2 + 8) == 0;
      a3.i64[0] = 0LL;
      goto LABEL_9;
    case 5:
      v4 = *(_QWORD *)(a2 + 8) == 0LL;
      a3.i64[0] = 0LL;
LABEL_9:
      if ( !v4 )
        *(double *)a3.i64 = 1.0;
      break;
    case 7:
      a3.i64[0] = *(__int64 *)(a2 + 8);
      break;
    case 8:
      v5 = *(const signed __int32 **)(a2 + 8);
      if ( _bittest(v5, 9u) )
      {
        sub_401C42(a1, (__int64)"third_party/duktape/duk_js_ops.c", 0x60000DDu, "cannot number coerce Symbol", a3, a4);
LABEL_12:
        a3.i64[0] = 0LL;
      }
      else
      {
        sub_407808(a1, (__int64)v5, a3, a4);
        sub_41B6EB(a1, 10, 0x6FFBu, a3, a4);
        v6 = a1[14];
        a3.i64[0] = *(__int64 *)(v6 - 8);
        a1[14] = v6 - 16;
        *(_DWORD *)(v6 - 16) = 2;
      }
      break;
    case 9:
    case 0xA:
      sub_406883(a1, (__int128 *)a2, a3, a4);
      sub_406EB2(a1, -1, 2, a3, a4);
      v7 = sub_40483D((__int64)a1, -1);
      *(double *)a3.i64 = sub_417910((__int64)a1, v7, a3, a4);
      sub_407DA1((__int64)a1, v7, v8, v9, a3, a4);
      break;
    default:
      a3.i64[0] = *(__int64 *)(a2 + 8);
      break;
  }
  return *(double *)a3.i64;
}
// 4179D4: variable 'v8' is possibly undefined
// 4179D4: variable 'v9' is possibly undefined

//----- (0000000000417A0C) ----------------------------------------------------
__int64 __fastcall sub_417A0C(__int64 a1, __int64 a2, double a3)
{
  __int64 v3; // rdx

  if ( sub_41D436(a3) )
    return sub_41D3C3(a3);
  else
    return sub_41D498(a1, a2, v3);
}
// 417A3B: variable 'v3' is possibly undefined

//----- (0000000000417A42) ----------------------------------------------------
__int64 __fastcall sub_417A42(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  double v4; // xmm0_8

  v4 = sub_417910(a1, a2, a3, a4);
  return sub_417A0C((__int64)a1, a2, v4);
}

//----- (0000000000417A4E) ----------------------------------------------------
__int64 __fastcall sub_417A4E(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  double v5; // xmm0_8
  double v7; // [rsp+8h] [rbp-8h]

  v7 = sub_417910(a1, a2, a3, a4);
  v5 = 0.0;
  if ( !sub_41D45B(v7) )
  {
    sub_41D498((__int64)a1, a2, v4);
    v5 = sub_42F9DE(v7, 4294967296.0);
    if ( v5 < 0.0 )
      v5 = v5 + 4294967296.0;
    if ( v5 >= 2147483648.0 )
      v5 = v5 - 4294967296.0;
  }
  return (unsigned int)(int)v5;
}
// 417A74: variable 'v4' is possibly undefined

//----- (0000000000417AB3) ----------------------------------------------------
__int64 __fastcall sub_417AB3(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  double v5; // xmm0_8
  double v7; // [rsp+8h] [rbp-8h]

  v7 = sub_417910(a1, a2, a3, a4);
  v5 = 0.0;
  if ( !sub_41D45B(v7) )
  {
    sub_41D498((__int64)a1, a2, v4);
    v5 = sub_42F9DE(v7, 4294967296.0);
    if ( v5 < 0.0 )
      v5 = v5 + 4294967296.0;
  }
  return (unsigned int)(int)v5;
}
// 417AD9: variable 'v4' is possibly undefined

//----- (0000000000417B0B) ----------------------------------------------------
__int64 __fastcall sub_417B0B(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  return sub_417AB3(a1, a2, a3, a4);
}

//----- (0000000000417B16) ----------------------------------------------------
__int64 __fastcall sub_417B16(__int64 *a1, _DWORD *a2, _DWORD *a3, char a4, __m128 a5, __m128 a6)
{
  int v7; // eax
  int v8; // edx
  double v9; // xmm2_8
  double v10; // xmm1_8
  int v11; // er12
  int v12; // ebx
  __int64 result; // rax
  bool v14; // zf
  char v15; // bl
  char v16; // al
  __int64 v17; // rdx
  int v18; // esi
  _DWORD *v19; // rsi
  _DWORD *v20; // rdx
  __int64 v21; // rdx
  __int64 v22; // rcx
  double v23; // [rsp+8h] [rbp-38h]
  double *v24; // [rsp+18h] [rbp-28h]
  double v25; // [rsp+18h] [rbp-28h]
  unsigned int v26; // [rsp+18h] [rbp-28h]

  v7 = *a2;
  v8 = *a3;
  if ( !*a2 )
  {
    if ( !v8 )
    {
      v9 = *((double *)a2 + 1);
      v10 = *((double *)a3 + 1);
      if ( (a4 & 1) != 0 )
      {
        v23 = *((double *)a2 + 1);
        v11 = sub_42FB3D(v9);
        v12 = sub_42FB3D(v10);
        if ( sub_41D67C(v23, v10) )
        {
          if ( v11 == 2 && v12 == 2 )
            return sub_41D4BF(v23, v10);
          return 1LL;
        }
        v14 = (v12 | v11) == 0;
LABEL_12:
        LOBYTE(result) = v14;
        return (unsigned __int8)result;
      }
LABEL_28:
      LOBYTE(result) = sub_41D67C(v9, v10);
      return (unsigned __int8)result;
    }
LABEL_15:
    if ( (a4 & 3) != 0 )
      return 0LL;
    v24 = (double *)a2;
    v15 = sub_4060F9(a2);
    v16 = sub_4060F9(a3);
    if ( (v15 & 6) != 0 && (v16 & 6) != 0 )
      return 1LL;
    if ( (v15 & 0x10) != 0 && (v16 & 0x20) != 0 && (v17 = **((unsigned int **)a3 + 1), (v17 & 0x200) == 0) )
    {
      a2 = a3;
      v25 = v24[1];
    }
    else
    {
      if ( (v15 & 0x20) == 0 || (v16 & 0x10) == 0 || (v17 = **((unsigned int **)a2 + 1), (v17 & 0x200) != 0) )
      {
        if ( (v15 & 8) != 0 )
        {
          sub_406AAF(a1, a2[2], a5, a6);
          sub_406883(a1, (__int128 *)a3, a5, a6);
        }
        else if ( (v16 & 8) != 0 )
        {
          sub_406883(a1, (__int128 *)a2, a5, a6);
          sub_406AAF(a1, a3[2], a5, a6);
        }
        else
        {
          if ( (v15 & 0x30) != 0 && (v16 & 0x40) != 0 )
          {
            sub_406883(a1, (__int128 *)a2, a5, a6);
            sub_406883(a1, (__int128 *)a3, a5, a6);
            v18 = -1;
          }
          else
          {
            if ( (v15 & 0x40) == 0 || (v16 & 0x30) == 0 )
              return 0LL;
            sub_406883(a1, (__int128 *)a2, a5, a6);
            sub_406883(a1, (__int128 *)a3, a5, a6);
            v18 = -2;
          }
          sub_406EB2(a1, v18, 0, a5, a6);
        }
        v19 = (_DWORD *)a1[14];
        v20 = v19 - 4;
        v19 -= 8;
        v26 = sub_417B16((__int64)a1, v19, v20, 0, a5, a6);
        sub_407DE7((__int64)a1, (__int64)v19, v21, v22, a5, a6);
        return v26;
      }
      v25 = *((double *)a3 + 1);
    }
    sub_405D6D(a1, (__int64 *)a2, v17, a5, a6);
    v9 = v25;
    v10 = *(double *)a5.i64;
    goto LABEL_28;
  }
  if ( v7 != v8 )
    goto LABEL_15;
  switch ( v7 )
  {
    case 2:
    case 3:
      return 1LL;
    case 4:
      v14 = a2[2] == a3[2];
      goto LABEL_12;
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
      v14 = *((_QWORD *)a2 + 1) == *((_QWORD *)a3 + 1);
      goto LABEL_12;
    case 6:
      result = (a2[1] == a3[1]) & (unsigned __int8)(*((_QWORD *)a2 + 1) == *((_QWORD *)a3 + 1));
      break;
  }
  return result;
}
// 417D57: variable 'v21' is possibly undefined
// 417D57: variable 'v22' is possibly undefined

//----- (0000000000417D71) ----------------------------------------------------
__int64 __fastcall sub_417D71(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  bool v4; // cc
  __int64 v6; // rdx
  int v8; // er8
  __int64 result; // rax

  v4 = a3 <= a4;
  v6 = a4;
  if ( v4 )
    v6 = a3;
  v8 = sub_41D69F(a1, a2, v6);
  result = 0xFFFFFFFFLL;
  if ( v8 >= 0 )
  {
    result = 1LL;
    if ( !v8 )
    {
      result = 0xFFFFFFFFLL;
      if ( a3 >= a4 )
        return a3 > a4;
    }
  }
  return result;
}

//----- (0000000000417DB2) ----------------------------------------------------
__int64 __fastcall sub_417DB2(__int64 a1, __int64 a2)
{
  return sub_417D71(a1 + 32, a2 + 32, *(unsigned int *)(a1 + 24), *(unsigned int *)(a2 + 24));
}

//----- (0000000000417DC2) ----------------------------------------------------
__int64 __fastcall sub_417DC2(__int64 *a1, __int64 a2, __int64 a3, char a4, __m128 a5, __m128 a6)
{
  unsigned int v7; // er13
  double v9; // xmm0_8
  double v10; // xmm1_8
  int v11; // esi
  __int64 v12; // rax
  const signed __int32 *v13; // rsi
  int v14; // ebx
  __int64 v15; // rdx
  __int64 v16; // rcx
  double v17; // xmm0_8
  __int64 v18; // rax
  __int64 v20; // [rsp+8h] [rbp-28h]

  v7 = a4 & 1;
  if ( !*(_DWORD *)a2 && !*(_DWORD *)a3 )
  {
    v9 = *(double *)(a2 + 8);
    v10 = *(double *)(a3 + 8);
    return sub_41787D(v7, v9, v10);
  }
  sub_406883(a1, (__int128 *)a2, a5, a6);
  sub_406883(a1, (__int128 *)a3, a5, a6);
  if ( (a4 & 2) != 0 )
  {
    sub_406EB2(a1, -2, 2, a5, a6);
    v11 = -1;
  }
  else
  {
    sub_406EB2(a1, -1, 2, a5, a6);
    v11 = -2;
  }
  sub_406EB2(a1, v11, 2, a5, a6);
  v12 = a1[14];
  if ( *(_DWORD *)(v12 - 32) != 8
    || *(_DWORD *)(v12 - 16) != 8
    || (v13 = *(const signed __int32 **)(v12 - 8), _bittest(*(const signed __int32 **)(v12 - 24), 9u))
    || _bittest(v13, 9u) )
  {
    sub_405D63(a1, a5, a6);
    v20 = a5.i64[0];
    v17 = sub_405CAB(a1, a5, a6);
    v18 = a1[14];
    v10 = v17;
    v9 = *(double *)&v20;
    a1[14] = v18 - 32;
    *(_DWORD *)(v18 - 32) = 2;
    *(_DWORD *)(v18 - 16) = 2;
    return sub_41787D(v7, v9, v10);
  }
  v14 = sub_417DB2(*(_QWORD *)(v12 - 24), (__int64)v13);
  sub_407DE7((__int64)a1, (__int64)v13, v15, v16, a5, a6);
  if ( v14 < 0 )
    v7 ^= 1u;
  return v7;
}
// 417E79: variable 'v15' is possibly undefined
// 417E79: variable 'v16' is possibly undefined

//----- (0000000000417EE5) ----------------------------------------------------
__int64 __fastcall sub_417EE5(__int64 *a1, __int128 *a2, __int128 *a3, __m128 a4, __m128 a5)
{
  return sub_4176AB(a1, a2, a3, 1, a4, a5);
}

//----- (0000000000417EEF) ----------------------------------------------------
__int64 __fastcall sub_417EEF(__int64 *a1, __int128 *a2, __int128 *a3, __m128 a4, __m128 a5)
{
  return sub_4176AB(a1, a2, a3, 0, a4, a5);
}

//----- (0000000000417EF6) ----------------------------------------------------
__int64 __fastcall sub_417EF6(__int64 *a1, __int128 *a2, __int128 *a3, __m128 a4, __m128 a5)
{
  int *v6; // rsi
  __int128 *v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rcx
  unsigned int v11; // [rsp+Ch] [rbp-14h]

  sub_406883(a1, a2, a4, a5);
  sub_406883(a1, a3, a4, a5);
  sub_406117(a1, -1, a4, a5);
  sub_4089B9(a1, -2, a4, a5);
  v6 = (int *)a1[14];
  v7 = (__int128 *)(v6 - 8);
  v6 -= 4;
  v11 = sub_40F1DF(a1, v6, v7, *(double *)a4.i64, a5);
  sub_407DE7((__int64)a1, (__int64)v6, v8, v9, a4, a5);
  return v11;
}
// 417F50: variable 'v8' is possibly undefined
// 417F50: variable 'v9' is possibly undefined

//----- (0000000000417F60) ----------------------------------------------------
__int64 __fastcall sub_417F60(__int64 a1)
{
  __int64 result; // rax

  switch ( *(_DWORD *)a1 )
  {
    case 2:
      result = 58LL;
      break;
    case 3:
    case 0xA:
      result = 57LL;
      break;
    case 4:
      result = 53LL;
      break;
    case 5:
      result = 95LL;
      break;
    case 6:
      result = 133LL;
      break;
    case 8:
      result = 56 - (unsigned int)((**(_DWORD **)(a1 + 8) & 0x200) == 0);
      break;
    case 9:
      result = (**(_DWORD **)(a1 + 8) & 0x200) == 0 ? 57 : 133;
      break;
    default:
      result = 54LL;
      break;
  }
  return result;
}

//----- (0000000000417FC2) ----------------------------------------------------
_BOOL8 __fastcall sub_417FC2(__int64 a1)
{
  return *(_DWORD *)sub_40DF43(a1) >> 27 == 2;
}

//----- (0000000000417FDB) ----------------------------------------------------
_BOOL8 __fastcall sub_417FDB(__int64 a1)
{
  return *(_DWORD *)a1 == 9 && sub_417FC2(*(_QWORD *)(a1 + 8));
}

//----- (0000000000417FE9) ----------------------------------------------------
__int64 __fastcall sub_417FE9(unsigned __int8 *a1, int a2)
{
  __int64 result; // rax
  int v3; // ecx
  unsigned int v4; // edx

  result = 0xFFFFFFFFLL;
  if ( a2 )
  {
    LODWORD(result) = 0;
    while ( 1 )
    {
      v3 = *a1++;
      v4 = v3 - 48;
      if ( (unsigned int)(v3 - 48) > 9 )
        break;
      if ( (unsigned int)result <= 0x19999998 )
      {
        result = v4 + 10 * (_DWORD)result;
        if ( !(_DWORD)result )
          return (unsigned int)-(a2 != 1);
      }
      else
      {
        if ( (_DWORD)result != 429496729 || v4 > 5 )
          return 0xFFFFFFFFLL;
        result = (unsigned int)(v3 - 54);
      }
      if ( !--a2 )
        return result;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000418032) ----------------------------------------------------
__int64 __fastcall sub_418032(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        __m128 a7,
        __m128 a8)
{
  __int64 v10; // rbx
  __int64 v12; // rsi
  __int64 v13; // rax
  double v14; // xmm0_8
  unsigned __int64 v15; // rax
  __int64 v16; // rax
  unsigned int v17; // er13
  const signed __int32 *v18; // rcx
  __int64 v19; // rax
  double v20; // xmm0_8
  unsigned __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  unsigned int v24; // eax
  int v25; // eax
  int v26; // eax
  __int64 v28; // [rsp+0h] [rbp-60h]
  __int128 v30; // [rsp+10h] [rbp-50h] BYREF
  unsigned int v31; // [rsp+20h] [rbp-40h] BYREF
  const signed __int32 *v32; // [rsp+28h] [rbp-38h]

  v10 = a2;
  if ( a2 || !a4 )
    goto LABEL_12;
  if ( !_bittest(*(const signed __int32 **)(a4 + 16), 0xBu)
    || (v12 = sub_40E6FC((__int64)a1, *(_QWORD *)(a4 + 16))) == 0
    || (v13 = sub_40E5DF(a1[8], v12, a3)) == 0 )
  {
    if ( !a5 )
      return 0;
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 16) + 80LL);
    if ( !v10 )
      v10 = a1[21];
LABEL_12:
    v17 = 10001;
    while ( v10 )
    {
      v18 = *(const signed __int32 **)(v10 + 56);
      if ( *(_DWORD *)v10 >> 27 == 16 )
      {
        if ( v18 )
        {
          v19 = sub_40E5DF(a1[8], *(_QWORD *)(v10 + 64), a3);
          if ( v19 )
          {
            v20 = *(double *)(v19 + 8);
            v21 = (unsigned int)(int)v20;
            if ( v20 >= 9.223372036854776e18 )
              v21 = (unsigned int)(int)(v20 - 9.223372036854776e18) ^ 0x8000000000000000LL;
            v22 = *(_QWORD *)(*(_QWORD *)(v10 + 56) + 80LL) + *(_QWORD *)(v10 + 72) + 16 * v21;
            *(_QWORD *)a6 = v10;
            *(_QWORD *)(a6 + 16) = v22;
            goto LABEL_21;
          }
        }
        v23 = sub_40E635(a1[8], v10, a3, &v31);
        if ( v23 )
        {
          *(_QWORD *)(a6 + 16) = v23;
          v24 = v31;
          *(_QWORD *)a6 = v10;
          *(_QWORD *)(a6 + 8) = v10;
          *(_QWORD *)(a6 + 24) = v24;
          return 1;
        }
      }
      else
      {
        if ( _bittest(v18, 0x19u) )
        {
          LODWORD(v30) = 8;
          *((_QWORD *)&v30 + 1) = a3;
          v31 = 9;
          v32 = v18;
          v28 = (__int64)v18;
          v25 = sub_40F1DF(a1, (int *)&v31, &v30, *(double *)a7.i64, a8);
        }
        else
        {
          v28 = *(_QWORD *)(v10 + 56);
          v25 = sub_40F3D3(a1, v28, a3, a7, a8);
        }
        if ( v25 )
        {
          v26 = *(_DWORD *)(v10 + 64);
          *(_QWORD *)(a6 + 16) = 0LL;
          *(_DWORD *)(a6 + 24) = 0;
          *(_QWORD *)a6 = v10;
          *(_QWORD *)(a6 + 8) = v28;
          *(_DWORD *)(a6 + 28) = v26;
          return 1;
        }
      }
      if ( !a5 )
        return 0;
      if ( !--v17 )
      {
        sub_401CE2(a1, (__int64)"third_party/duktape/duk_js_var.c", 1096, "prototype chain limit", a7, a8);
        return v17;
      }
      v10 = *(_QWORD *)(v10 + 32);
    }
    return 0;
  }
  v14 = *(double *)(v13 + 8);
  v15 = (unsigned int)(int)v14;
  if ( v14 >= 9.223372036854776e18 )
    v15 = (unsigned int)(int)(v14 - 9.223372036854776e18) ^ 0x8000000000000000LL;
  v16 = a1[10] + *(_QWORD *)(a4 + 64) + 16 * v15;
  *(_QWORD *)a6 = 0LL;
  *(_QWORD *)(a6 + 16) = v16;
LABEL_21:
  *(_QWORD *)(a6 + 8) = 0LL;
  *(_QWORD *)(a6 + 24) = 1LL;
  return 1;
}

//----- (000000000041827C) ----------------------------------------------------
__int64 __fastcall sub_41827C(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __m128 a6, __m128 a7)
{
  __int128 *v9; // rsi
  __int64 v10; // rdx
  __int128 v12; // [rsp+10h] [rbp-50h] BYREF
  __m128 v13; // [rsp+20h] [rbp-40h] BYREF
  char v14[8]; // [rsp+30h] [rbp-30h] BYREF
  __int64 v15; // [rsp+38h] [rbp-28h]
  __int128 *v16; // [rsp+40h] [rbp-20h]
  int v17; // [rsp+4Ch] [rbp-14h]

  if ( (unsigned int)sub_418032(a1, a2, a4, a3, 1, (__int64)v14, a6, a7) )
  {
    v9 = v16;
    if ( v16 )
    {
      sub_406883(a1, v16, a6, a7);
    }
    else
    {
      v9 = &v12;
      LODWORD(v12) = 9;
      v13.i32[0] = 8;
      v13.i64[1] = a4;
      *((_QWORD *)&v12 + 1) = v15;
      sub_40EC01(a1, &v12, &v13, a6);
      if ( v17 )
      {
        sub_407C45(a1, v15, a6, a7);
        return 1;
      }
    }
    sub_4068D1(a1, (__int64)v9, v10, a6, a7);
    return 1;
  }
  if ( a5 )
  {
    a5 = 0;
    sub_401B75(
      a1,
      (__int64)"third_party/duktape/duk_js_var.c",
      0x40004D2u,
      "identifier '%s' undefined",
      (const char *)(a4 + 32));
  }
  return a5;
}
// 418308: variable 'v10' is possibly undefined
// 41827C: using guessed type char var_30[8];

//----- (000000000041833D) ----------------------------------------------------
__int64 *__fastcall sub_41833D(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 *a5,
        unsigned int a6,
        __m128 a7,
        __m128 a8)
{
  __int64 v11; // rdx
  __int64 *result; // rax
  __int64 v13; // rcx
  __int64 v14; // rbx
  _DWORD *v15; // rsi
  unsigned int v17; // er8
  __int64 v18; // rax
  __int64 v19; // [rsp+10h] [rbp-60h] BYREF
  __int64 v20; // [rsp+18h] [rbp-58h]
  __m128 v21; // [rsp+20h] [rbp-50h] BYREF
  char v22[8]; // [rsp+30h] [rbp-40h] BYREF
  __int64 v23; // [rsp+38h] [rbp-38h]
  __int64 *v24; // [rsp+40h] [rbp-30h]
  char v25; // [rsp+48h] [rbp-28h]

  if ( !(unsigned int)sub_418032(a1, a2, a4, a3, 1, (__int64)v22, a7, a8) )
  {
    if ( a6 )
      return (__int64 *)sub_401B75(
                          a1,
                          (__int64)"third_party/duktape/duk_js_var.c",
                          0x400054Fu,
                          "identifier '%s' undefined",
                          (const char *)(a4 + 32));
    v18 = a1[20];
    LODWORD(v19) = 9;
    v17 = 0;
    v21.i32[0] = 8;
    v21.i64[1] = a4;
    v20 = v18;
    return (__int64 *)sub_40F7B6(a1, &v19, &v21, (__int128 *)a5, v17, a7);
  }
  result = v24;
  if ( !v24 || (v25 & 1) == 0 )
  {
    LODWORD(v19) = 9;
    v17 = a6;
    v21.i32[0] = 8;
    v21.i64[1] = a4;
    v20 = v23;
    return (__int64 *)sub_40F7B6(a1, &v19, &v21, (__int128 *)a5, v17, a7);
  }
  if ( (*(_BYTE *)a5 & 8) != 0 )
  {
    v11 = a5[1];
    ++*(_DWORD *)(v11 + 4);
  }
  v13 = *a5;
  v14 = a5[1];
  if ( (*(_BYTE *)result & 8) != 0 )
  {
    v15 = (_DWORD *)result[1];
    *result = v13;
    result[1] = v14;
    if ( v15[1]-- == 1 )
      return (__int64 *)sub_40CFCD((__int64)a1, v15, v11, v13, a7, a8);
  }
  else
  {
    *result = v13;
    result[1] = v14;
  }
  return result;
}
// 4183B4: variable 'v11' is possibly undefined
// 41833D: using guessed type char var_40[8];

//----- (000000000041843F) ----------------------------------------------------
__int64 __fastcall sub_41843F(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, int a5, __m128 a6, __m128 a7)
{
  int *v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 *v12; // rcx
  unsigned __int64 i; // rax
  unsigned __int64 v14; // rsi
  __int64 v15; // rax
  int v16; // ecx
  int v17; // eax
  int *v18; // r15
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 j; // r13
  __int64 v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // rax
  int v26; // esi
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // rdx
  __int64 v30; // rcx
  int v33; // [rsp+0h] [rbp-40h]
  int v35; // [rsp+Ch] [rbp-34h]

  v9 = sub_407292(a1, a6, a7);
  sub_407C45(a1, a2, a6, a7);
  v10 = *(_QWORD *)(a2 + 56);
  *((_QWORD *)v9 + 8) = *(_QWORD *)(a2 + 64);
  v11 = *(_QWORD *)(a2 + 72);
  *((_QWORD *)v9 + 7) = v10;
  *((_QWORD *)v9 + 9) = v11;
  v12 = *(__int64 **)(a2 + 64);
  ++*(_DWORD *)(v10 + 4);
  for ( i = v10 + 32; (unsigned __int64)v12 > i; i += 16LL )
  {
    if ( (*(_BYTE *)i & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(i + 8) + 4LL);
  }
  v14 = *(_QWORD *)(a2 + 72);
  while ( v14 > (unsigned __int64)v12 )
  {
    v15 = *v12++;
    ++*(_DWORD *)(v15 + 4);
  }
  v16 = 0;
  *((_WORD *)v9 + 48) = *(_DWORD *)(a2 + 96);
  *((_WORD *)v9 + 49) = *(_WORD *)(a2 + 98);
  v17 = *(_DWORD *)a2 | *v9 & 3;
  if ( (v17 & 0x100) != 0 )
    v16 = a5;
  *v9 = v17;
  v35 = v16;
  if ( (v17 & 0x40000) != 0 )
  {
    if ( (v17 & 0x80000) != 0 )
    {
      if ( !a4 )
        a4 = a1[21];
      v18 = sub_40D66C(a1, -2147483520, a6, a7);
      sub_407C45(a1, (__int64)v18, a6, a7);
      *((_QWORD *)v18 + 4) = a4;
      if ( a4 )
        ++*(_DWORD *)(a4 + 4);
      sub_4037B9(a1, -130979, a6, a7);
      sub_405005(a1, a6, a7);
      sub_403D6B(a1, -3, 0, a6, a7);
      *((_QWORD *)v9 + 10) = v18;
      *((_QWORD *)v9 + 11) = v18;
      v18[1] += 2;
      sub_407DA1((__int64)a1, 4294967293LL, v19, v20, a6, a7);
    }
    else
    {
      *((_QWORD *)v9 + 10) = a4;
      *((_QWORD *)v9 + 11) = a4;
      *(_DWORD *)(a4 + 4) += 2;
    }
  }
  else
  {
    *((_QWORD *)v9 + 10) = a4;
    *((_QWORD *)v9 + 11) = a3;
    ++*(_DWORD *)(a4 + 4);
    ++*(_DWORD *)(a3 + 4);
  }
  for ( j = 0LL; j != 4; ++j )
  {
    v22 = (unsigned int)(unsigned __int16)word_43D4F8[j] - 0x10000;
    v33 = (unsigned __int16)word_43D4F8[j];
    if ( (unsigned int)sub_403883(a1, v22, a6, a7) )
      sub_403E13(a1, (v33 << 8) - 50331644, a6, a7);
    else
      sub_407DA1((__int64)a1, v22, v23, v24, a6, a7);
  }
  v25 = sub_40E6D6((__int64)a1, a2);
  if ( v25 )
    v26 = *(_DWORD *)(v25 + 56);
  else
    v26 = *(unsigned __int16 *)(a2 + 98);
  sub_406AAF(a1, v26, a6, a7);
  sub_403E13(a1, -50309372, a6, a7);
  if ( v35 )
  {
    sub_407095(a1, a6, a7);
    sub_404FFB(a1, a6, a7);
    sub_403E13(a1, -33541371, a6, a7);
    sub_403FC8(a1, -1, a6, a7);
    sub_403E13(a1, -50318847, a6, a7);
  }
  if ( (*v9 & 0x10000) != 0 )
  {
    sub_403F77(a1, -2, 0x45u, a6, a7);
    sub_403F77(a1, -2, 0x43u, a6, a7);
  }
  if ( (unsigned int)sub_4037B9(a1, -65443, a6, a7) )
    sub_403E13(a1, -50307836, a6, a7);
  else
    sub_407DA1((__int64)a1, 4294901853LL, v27, v28, a6, a7);
  sub_403FC8(a1, -2, a6, a7);
  return sub_407DA1((__int64)a1, 4294967294LL, v29, v30, a6, a7);
}
// 41856A: variable 'v19' is possibly undefined
// 41856A: variable 'v20' is possibly undefined
// 4185C9: variable 'v23' is possibly undefined
// 4185C9: variable 'v24' is possibly undefined
// 418690: variable 'v27' is possibly undefined
// 418690: variable 'v28' is possibly undefined
// 4186B3: variable 'v29' is possibly undefined
// 4186B3: variable 'v30' is possibly undefined
// 43D4F8: using guessed type __int16 word_43D4F8[];

//----- (00000000004186B8) ----------------------------------------------------
int *__fastcall sub_4186B8(__int64 a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v6; // r13
  int *v7; // r12
  __int64 v8; // rax
  __int64 v9; // r13
  unsigned int v10; // er14
  __int64 v11; // rdx
  __int64 v12; // r15

  v6 = *(_QWORD *)(a2 + 80);
  if ( !v6 )
    v6 = *(_QWORD *)(a1 + 168);
  v7 = sub_40D66C((__int64 *)a1, -2147483520, a4, a5);
  sub_407C45((__int64 *)a1, (__int64)v7, a4, a5);
  *((_QWORD *)v7 + 4) = v6;
  if ( v6 )
    ++*(_DWORD *)(v6 + 4);
  if ( _bittest((const signed __int32 *)a2, 0xBu) )
  {
    v8 = sub_40E6FC(a1, a2);
    v9 = v8;
    if ( v8 )
    {
      *((_QWORD *)v7 + 8) = v8;
      ++*(_DWORD *)(v8 + 4);
      *((_QWORD *)v7 + 7) = a1;
      ++*(_DWORD *)(a1 + 4);
      *((_QWORD *)v7 + 9) = a3;
      v10 = 0;
      while ( v10 < *(_DWORD *)(v9 + 44) )
      {
        v11 = v10++;
        v12 = *(_QWORD *)(*(_QWORD *)(v9 + 24) + 16LL * *(unsigned int *)(v9 + 40) + 8 * v11);
        sub_4068D1((__int64 *)a1, a2, v11, a4, a5);
        a2 = (__int64)v7;
        sub_4103F9((__int64 *)a1, (__int64)v7, v12, 3, a4, a5);
      }
    }
  }
  return v7;
}

//----- (0000000000418785) ----------------------------------------------------
__int64 __fastcall sub_418785(__int64 a1, _QWORD *a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rdx
  __int64 v6; // rsi
  int *v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx

  v5 = a2[8];
  v6 = a2[2];
  v7 = sub_4186B8(a1, v6, v5, a3, a4);
  a2[5] = v7;
  a2[4] = v7;
  v7[1] += 2;
  return sub_407DA1(a1, v6, v8, v9, a3, a4);
}
// 4187B8: variable 'v8' is possibly undefined
// 4187B8: variable 'v9' is possibly undefined

//----- (00000000004187BD) ----------------------------------------------------
__int64 __fastcall sub_4187BD(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 result; // rax
  __int64 v8; // r14
  unsigned int v9; // er13
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // r15
  __int64 v13; // rsi
  bool v14; // zf
  __int64 v15; // rsi

  result = *(_DWORD *)a2 >> 27;
  if ( (_DWORD)result == 16 )
  {
    v8 = *(_QWORD *)(a2 + 64);
    if ( v8 )
    {
      v9 = 0;
      while ( *(_DWORD *)(v8 + 44) > v9 )
      {
        v10 = *(_QWORD *)(v8 + 24);
        v11 = v9++;
        v12 = *(_QWORD *)(v10 + 16LL * *(unsigned int *)(v8 + 40) + 8 * v11);
        sub_406883(
          a1,
          (__int128 *)(a1[10] + *(_QWORD *)(a2 + 72) + 16LL * (unsigned int)(int)*(double *)(v10 + 16 * v11 + 8)),
          a5,
          a6);
        sub_4103F9(a1, a2, v12, 3, a5, a6);
      }
      v13 = *(_QWORD *)(a2 + 56);
      v14 = (*(_DWORD *)(v13 + 4))-- == 1;
      if ( v14 )
        sub_40CAE2((__int64)a1, v13, a3, a4, a5, a6);
      v15 = *(_QWORD *)(a2 + 64);
      v14 = (*(_DWORD *)(v15 + 4))-- == 1;
      if ( v14 )
        sub_40CAE2((__int64)a1, v15, a3, a4, a5, a6);
      *(_QWORD *)(a2 + 56) = 0LL;
      *(_QWORD *)(a2 + 64) = 0LL;
    }
    return a3;
  }
  return result;
}
// 418852: variable 'a3' is possibly undefined
// 418852: variable 'a4' is possibly undefined

//----- (0000000000418885) ----------------------------------------------------
__int64 __fastcall sub_418885(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __m128 a5, __m128 a6)
{
  return sub_41827C(a1, a2, 0LL, a3, a4, a5, a6);
}

//----- (0000000000418892) ----------------------------------------------------
__int64 __fastcall sub_418892(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __m128 a5, __m128 a6)
{
  return sub_41827C(a1, *(_QWORD *)(a2 + 40), a2, a3, a4, a5, a6);
}

//----- (00000000004188A7) ----------------------------------------------------
__int64 *__fastcall sub_4188A7(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, unsigned int a5, __m128 a6, __m128 a7)
{
  return sub_41833D(a1, a2, 0LL, a3, a4, a5, a6, a7);
}

//----- (00000000004188B7) ----------------------------------------------------
__int64 *__fastcall sub_4188B7(__int64 *a1, __int64 a2, __int64 a3, __int64 *a4, unsigned int a5, __m128 a6, __m128 a7)
{
  return sub_41833D(a1, *(_QWORD *)(a2 + 40), a2, a3, a4, a5, a6, a7);
}

//----- (00000000004188CF) ----------------------------------------------------
__int64 __fastcall sub_4188CF(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  int v5; // er8
  __int64 result; // rax
  char v8[8]; // [rsp+10h] [rbp-20h] BYREF
  __int64 v9; // [rsp+18h] [rbp-18h]
  __int64 v10; // [rsp+20h] [rbp-10h]
  int v11; // [rsp+28h] [rbp-8h]

  v5 = sub_418032(a1, *(_QWORD *)(a2 + 40), a3, a2, 1, (__int64)v8, a4, a5);
  result = 1LL;
  if ( v5 )
  {
    if ( !v10 )
      return sub_40F441(a1, v9, a3, 0, a4, a5);
    result = v11 & 4;
    if ( (v11 & 4) != 0 )
      return sub_40F441(a1, v9, a3, 0, a4, a5);
  }
  return result;
}
// 4188CF: using guessed type char var_20[8];

//----- (0000000000418926) ----------------------------------------------------
__int64 __fastcall sub_418926(__int64 *a1, _QWORD *a2, __int64 a3, __m128 *a4, char a5, int a6, double a7, __m128 a8)
{
  bool v11; // zf
  __m128 v12; // xmm0
  char *v13; // rsi
  unsigned int v14; // er13
  __int64 i; // rbx
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 *v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rax
  __int64 v21; // rsi
  _DWORD *v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int64 v26; // r8
  _QWORD *v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v31; // [rsp+8h] [rbp-78h]
  int v32; // [rsp+18h] [rbp-68h] BYREF
  unsigned int v33; // [rsp+1Ch] [rbp-64h] BYREF
  __m128 v34; // [rsp+20h] [rbp-60h] BYREF
  char v35[8]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v36; // [rsp+38h] [rbp-48h]

  v11 = a2[4] == 0LL;
  v12 = *a4;
  v34 = *a4;
  if ( v11 )
    sub_418785((__int64)a1, a2, v12, a8);
  v31 = a2[4];
  v13 = (char *)v31;
  v14 = sub_418032(a1, v31, a3, 0LL, 0, (__int64)v35, v12, a8);
  if ( v14 )
  {
    v14 = 1;
    if ( a6 && v31 == a1[21] )
    {
      for ( i = v36; !(unsigned int)sub_40E53D(a1[8], i, a3, (unsigned int *)&v32, &v33); i = *(_QWORD *)(i + 32) )
        ;
      v16 = *(_QWORD *)(i + 24);
      v17 = v16 + 24LL * *(unsigned int *)(i + 40);
      LOBYTE(v17) = *(_BYTE *)(v17 + v32);
      if ( (v17 & 4) != 0 || (v17 & 8) == 0 && (v17 & 3) == 3 )
      {
        if ( i == v36 )
        {
          v18 = (__int64 *)(v16 + 16LL * v32);
          LOBYTE(v17) = v17 & 8;
          if ( (_BYTE)v17 )
          {
            v19 = *v18;
            *v18 = 0LL;
            if ( v19 )
            {
              v11 = (*(_DWORD *)(v19 + 4))-- == 1;
              if ( v11 )
                sub_40CFE0((__int64)a1, v19, v16, v17, v12, a8);
            }
            v20 = *(_QWORD *)(i + 24) + 16LL * v32;
            v21 = *(_QWORD *)(v20 + 8);
            *(_QWORD *)(v20 + 8) = 0LL;
            if ( v21 )
            {
              v11 = (*(_DWORD *)(v21 + 4))-- == 1;
              if ( v11 )
                sub_40CFE0((__int64)a1, v21, v16, v17, v12, a8);
            }
          }
          else
          {
            v23 = *(unsigned int *)v18;
            v22 = (_DWORD *)v18[1];
            *(_DWORD *)v18 = 2;
            LOBYTE(v23) = v23 & 8;
            if ( (_BYTE)v23 )
            {
              v11 = v22[1]-- == 1;
              if ( v11 )
                sub_40CFCD((__int64)a1, v22, v23, v17, v12, a8);
            }
          }
          v24 = v32;
          v25 = *(_QWORD *)(i + 24);
          v26 = v34.i64[1];
          v27 = (_QWORD *)(v25 + 16LL * v32);
          v11 = (v34.i8[0] & 8) == 0;
          *v27 = v34.i64[0];
          v27[1] = v26;
          if ( !v11 )
            ++*(_DWORD *)(v26 + 4);
          *(_BYTE *)(24LL * *(unsigned int *)(i + 40) + v25 + v24) = a5;
        }
        else
        {
          sub_406883(a1, (__int128 *)&v34, v12, a8);
          sub_4103F9(a1, v36, a3, a5, v12, a8);
        }
        return 0;
      }
LABEL_31:
      sub_401C42(a1, (__int64)"third_party/duktape/duk_js_var.c", 0x60006D8u, "declaration failed", v12, a8);
      return 0;
    }
  }
  else
  {
    if ( *(_DWORD *)v31 >> 27 != 16 )
      v13 = *(char **)(v31 + 56);
    if ( *v13 >= 0 )
      goto LABEL_31;
    sub_407C45(a1, (__int64)v13, v12, a8);
    sub_407808(a1, a3, v12, a8);
    sub_406883(a1, (__int128 *)&v34, v12, a8);
    sub_403D6B(a1, -3, a5, v12, a8);
    sub_407DA1((__int64)a1, 4294967293LL, v28, v29, v12, a8);
  }
  return v14;
}
// 418A4F: variable 'v16' is possibly undefined
// 418A4F: variable 'v17' is possibly undefined
// 418B19: variable 'v28' is possibly undefined
// 418B19: variable 'v29' is possibly undefined
// 418926: using guessed type char var_50[8];

//----- (0000000000418B4C) ----------------------------------------------------
unsigned __int8 *__fastcall sub_418B4C(__int64 a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r8
  __int64 v5; // r10
  int v6; // er9
  unsigned __int8 *v7; // rcx
  unsigned __int64 v8; // r11
  unsigned __int8 *result; // rax
  unsigned __int8 *v10; // rsi
  unsigned int v11; // edx
  unsigned __int8 v12; // al
  unsigned int v13; // eax
  unsigned int v14; // ecx
  char v15; // dl

  v4 = a1 + a2 + 8;
  v5 = *(_QWORD *)(a1 + 1552);
  v6 = *(_DWORD *)(a1 + 1576);
  v7 = (unsigned __int8 *)(v5 + *(_QWORD *)(a1 + 1568));
  v8 = v5 + *(_QWORD *)(a1 + 1560);
  while ( 1 )
  {
    result = &v7[-v5];
    if ( v4 == a1 + 1544 )
    {
      *(_QWORD *)(a1 + 1568) = result;
      *(_DWORD *)(a1 + 1576) = v6;
      return result;
    }
    *(_QWORD *)(v4 + 8) = result;
    *(_DWORD *)(v4 + 16) = v6;
    if ( (unsigned __int64)v7 >= v8 )
    {
      *(_DWORD *)v4 = -1;
      v10 = v7;
      goto LABEL_25;
    }
    v11 = *v7;
    v10 = v7 + 1;
    v12 = *v7;
    if ( (v11 & 0x80u) != 0 )
      break;
    if ( v11 <= 0xD && (v11 == 10 || v11 == 13 && (v8 <= (unsigned __int64)v10 || v7[1] != 10)) )
      ++v6;
    *(_DWORD *)v4 = v11;
LABEL_25:
    v4 += 24LL;
    v7 = v10;
  }
  if ( v11 > 0xBF )
  {
    if ( v11 > 0xDF )
    {
      if ( v11 <= 0xEF )
      {
        v13 = v12 & 0xF;
        v14 = 2;
        goto LABEL_20;
      }
      if ( v11 <= 0xF7 )
      {
        v13 = v12 & 7;
        v14 = 3;
        goto LABEL_20;
      }
    }
    else
    {
      v13 = v12 & 0x1F;
      v14 = 1;
LABEL_20:
      if ( v14 <= v8 - (unsigned __int64)v10 )
      {
        while ( 1 )
        {
          v15 = *v10++;
          if ( (v15 & 0xC0) != 0x80 )
            break;
          v13 = (v15 & 0x3F) + (v13 << 6);
          if ( !--v14 )
          {
            if ( v13 > 0x10FFFF )
              break;
            *(_DWORD *)v4 = v13;
            v6 += v13 - 8232 < 2;
            goto LABEL_25;
          }
        }
      }
    }
  }
  *(_DWORD *)(a1 + 1576) = v6;
  *(_QWORD *)(a1 + 1568) = &v10[-v5];
  return (unsigned __int8 *)sub_401C42(
                              *(__int64 **)(a1 + 1544),
                              (__int64)"third_party/duktape/duk_lexer.c",
                              0x500013Bu,
                              "source decode failed",
                              a3,
                              a4);
}

//----- (0000000000418CB4) ----------------------------------------------------
unsigned __int8 *__fastcall sub_418CB4(_QWORD *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  _BYTE *v4; // rsi
  _BYTE *v5; // rdi
  unsigned __int8 *result; // rax
  _QWORD *v7; // r8
  unsigned int v8; // er9

  v4 = (_BYTE *)(*a1 + a2);
  v5 = a1 + 1;
  *((_QWORD *)v5 - 1) = v4;
  result = (unsigned __int8 *)(unsigned int)((_DWORD)v5 - (_DWORD)v4);
  if ( (unsigned int)((_DWORD)result + 1536) <= 0x8F )
  {
    sub_43ABC2(v5, v4, (unsigned int)((_DWORD)result + 1536));
    *v7 = v5;
    return sub_418B4C((__int64)v7, v8, a3, a4);
  }
  return result;
}
// 418CE0: variable 'v7' is possibly undefined
// 418CE9: variable 'v8' is possibly undefined

//----- (0000000000418CEF) ----------------------------------------------------
__int64 __fastcall sub_418CEF(int **a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5)
{
  int v6; // edi

  while ( 1 )
  {
    v6 = **a1;
    if ( v6 < 0 || sub_41CA82(v6) )
      break;
    sub_418CB4(a1, 0x18u, a2, a3);
  }
  return a5;
}

//----- (0000000000418D1D) ----------------------------------------------------
__int64 __fastcall sub_418D1D(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  if ( (unsigned __int64)(a1[202] - a1[200]) <= 5 )
    sub_41CFE2((__int64 *)a1[193], a1 + 200, 6LL, a3, a4);
  result = (int)sub_41C6FA(a2, (_BYTE *)a1[200]);
  a1[200] += (int)result;
  return result;
}

//----- (0000000000418D73) ----------------------------------------------------
__int64 __fastcall sub_418D73(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx

  sub_406B69((__int64 *)a1[193], a1[201], a1[200] - a1[201], a3, a4);
  sub_405057((__int64 *)a1[193], a2, v4, v5, *(double *)a3.i64, a4);
  return sub_405B3C(a1[193], a2);
}
// 418DA7: variable 'v4' is possibly undefined
// 418DA7: variable 'v5' is possibly undefined

//----- (0000000000418DBF) ----------------------------------------------------
__int64 __fastcall sub_418DBF(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rsi

  v3 = a1[199];
  if ( *(_QWORD *)(v3 + 24) > 0xFFuLL )
    sub_4200FB((__int64 *)a1[193], v3, 0x100uLL, a2, a3);
  return sub_41CF7C(a1[193], a1 + 200, a1[199]);
}

//----- (0000000000418E07) ----------------------------------------------------
__int64 __fastcall sub_418E07(__int64 *a1, int *a2, int a3)
{
  __int64 v3; // r10
  unsigned int v4; // er8
  __int64 v5; // rdi
  int v6; // ecx
  __int64 result; // rax

  v3 = *a1;
  v4 = 0;
  v5 = 1LL;
  while ( 1 )
  {
    v6 = v5;
    result = *(unsigned int *)(v3 + 24 * v5);
    if ( (unsigned int)(result - 48) > 7 )
      break;
    result = (_DWORD)result - 48 + 8 * v4;
    if ( (int)result > 255 )
      break;
    if ( ++v5 == 4 )
    {
      v6 = 4;
      goto LABEL_11;
    }
    v4 = result;
  }
  if ( (_DWORD)v5 == 1 )
  {
    v6 = 2;
    goto LABEL_16;
  }
  if ( (_DWORD)v5 == 2 && !v4 )
  {
    v6 = 2;
    result = 0LL;
    goto LABEL_16;
  }
  result = v4;
LABEL_11:
  if ( a3 )
    result = 0xFFFFFFFFLL;
LABEL_16:
  *a2 = v6;
  return result;
}

//----- (0000000000418E75) ----------------------------------------------------
__int64 __fastcall sub_418E75(
        __int64 (__fastcall *a1)(__int64, __int64, __int64, __int64),
        __int64 a2,
        unsigned __int16 *a3,
        int a4)
{
  unsigned __int16 *v5; // r12
  unsigned __int16 *i; // rbx
  __int64 v7; // rdx
  __int64 v8; // rsi
  __int64 result; // rax

  v5 = &a3[a4];
  for ( i = a3; v5 > i; i += 2 )
  {
    v7 = i[1];
    v8 = *i;
    result = a1(a2, v8, v7, 1LL);
  }
  return result;
}

//----- (0000000000418EB9) ----------------------------------------------------
__int64 __fastcall sub_418EB9(unsigned int **a1, char a2, __m128 a3, __m128 a4)
{
  int v4; // esi
  int v5; // ebx
  unsigned int v6; // er12
  unsigned int v7; // er14
  int v8; // eax

  if ( (*a1)[6] == 117 )
  {
    if ( (*a1)[12] == 123 && (a2 & 1) != 0 )
    {
      v4 = 3;
      v5 = 0;
    }
    else
    {
      v4 = 2;
      v5 = 4;
    }
  }
  else
  {
    v4 = 2;
    v5 = 2;
  }
  v6 = 0;
  sub_418CB4(a1, 24 * v4, a3, a4);
  while ( 1 )
  {
    v7 = **a1;
    sub_418CB4(a1, 0x18u, a3, a4);
    if ( v7 > 0xFF )
    {
      v8 = -1;
      goto LABEL_12;
    }
    v8 = byte_44E328[v7];
    if ( v8 < 0 )
      break;
LABEL_12:
    if ( v5 <= 0 )
    {
      if ( v8 == -1 )
        goto LABEL_20;
      v6 = v8 + 16 * v6;
      if ( (int)v6 > 1114111 )
        goto LABEL_22;
      v5 = -1;
    }
    else
    {
      --v5;
      if ( v8 == -1 )
        goto LABEL_22;
      v6 = v8 + 16 * v6;
      if ( !v5 )
        return v6;
    }
  }
  if ( v5 > 0 )
  {
LABEL_22:
    v6 = 0;
    sub_401C42((__int64 *)a1[193], (__int64)"third_party/duktape/duk_lexer.c", 0x50002E7u, "invalid escape", a3, a4);
    return v6;
  }
LABEL_20:
  if ( !v5 || v7 != 125 )
    goto LABEL_22;
  return v6;
}

//----- (0000000000418FA3) ----------------------------------------------------
void __fastcall sub_418FA3(__int64 a1)
{
  sub_43ABE2(a1, 0LL, 0x670uLL);
}

//----- (0000000000418FB0) ----------------------------------------------------
__int64 __fastcall sub_418FB0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(unsigned int *)(*(_QWORD *)a1 + 16LL);
  *(_QWORD *)a2 = *(_QWORD *)(*(_QWORD *)a1 + 8LL);
  *(_DWORD *)(a2 + 8) = result;
  return result;
}

//----- (0000000000418FC1) ----------------------------------------------------
unsigned __int8 *__fastcall sub_418FC1(__int64 a1, __int64 a2, __m128 a3, __m128 a4)
{
  *(_QWORD *)(a1 + 1568) = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 1576) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)a1 = a1 + 8;
  return sub_418B4C(a1, 0, a3, a4);
}

//----- (0000000000418FE2) ----------------------------------------------------
unsigned __int8 __fastcall sub_418FE2(int **a1, __int64 a2, int a3, int a4, __m128 a5, __m128 a6)
{
  int v7; // eax
  bool v8; // cc
  unsigned __int8 result; // al
  __int64 v10; // rbx
  int v11; // er14
  int *v12; // rax
  int v13; // er13
  __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned int v16; // er13
  int v17; // eax
  _BOOL4 v18; // er15
  int v19; // er13
  __int64 *v20; // rdi
  const char *v21; // rcx
  unsigned int v22; // edx
  int v23; // er15
  int v24; // edi
  int v25; // er13
  int v26; // esi
  bool v27; // zf
  int v28; // eax
  bool v29; // zf
  int v30; // eax
  int v31; // edx
  int v32; // edx
  int v33; // eax
  int v34; // edx
  int v35; // eax
  int v36; // eax
  int *v37; // rax
  int v38; // er15
  int v39; // esi
  unsigned int v40; // eax
  __int64 *v41; // rdi
  const char *v42; // rcx
  unsigned int v43; // edx
  int *v44; // rax
  _BOOL4 v45; // eax
  int i; // edx
  int v47; // edi
  unsigned int v48; // er13
  _BOOL4 v49; // eax
  __int64 v50; // rax
  __int64 v51; // rdx
  int v52; // edx
  int v53; // er13
  int v54; // esi
  int v55; // eax
  int v56; // er15
  unsigned int v57; // esi
  unsigned int v58; // er15
  int v59; // esi
  __int64 *v60; // rdi
  __int64 v61; // rdx
  __int64 v62; // rcx
  int v63; // edi
  int v65; // [rsp+10h] [rbp-50h]
  __int64 v66; // [rsp+10h] [rbp-50h]
  int v68; // [rsp+18h] [rbp-48h]
  int v69[13]; // [rsp+2Ch] [rbp-34h] BYREF

  v7 = *((_DWORD *)a1 + 408) + 1;
  v8 = v7 < *((_DWORD *)a1 + 409);
  *((_DWORD *)a1 + 408) = v7;
  if ( !v8 )
    return sub_401CE2((__int64 *)a1[193], (__int64)"third_party/duktape/duk_lexer.c", 1788, "token limit", a5, a6);
  v10 = a2;
  *(_DWORD *)(a2 + 44) = 0;
  v11 = 0;
  *(_QWORD *)a2 = 0xFFFFFFFF00000000LL;
LABEL_4:
  *(_DWORD *)(v10 + 40) = (*a1)[4];
  while ( 1 )
  {
    v12 = *a1;
    v13 = **a1;
    v14 = *((_QWORD *)*a1 + 1);
    *(_QWORD *)(v10 + 32) = v14;
    if ( v13 > 94 )
    {
      if ( v13 == 125 )
      {
        v16 = 6194;
        goto LABEL_222;
      }
      if ( v13 > 125 )
      {
        if ( v13 == 126 )
        {
          v16 = 6225;
          goto LABEL_222;
        }
      }
      else
      {
        if ( v13 == 123 )
        {
          v16 = 6193;
          goto LABEL_222;
        }
        if ( v13 == 124 )
        {
          v36 = v12[6];
          v16 = 12371;
          if ( v36 == 124 )
            goto LABEL_222;
          v27 = v36 == 61;
          v16 = 12385;
          v28 = 6222;
          goto LABEL_90;
        }
      }
      goto LABEL_143;
    }
    if ( v13 > 31 )
    {
      v15 = (unsigned int)(v13 - 32);
      switch ( v13 )
      {
        case ' ':
          goto LABEL_214;
        case '!':
          v16 = 6224;
          if ( v12[6] != 61 )
            goto LABEL_222;
          v27 = v12[12] == 61;
          v16 = 18497;
          v28 = 12351;
          goto LABEL_90;
        case '"':
        case '\'':
          sub_418DBF((__int64 *)a1, a5, a6);
          v69[0] = 1;
          while ( 2 )
          {
            sub_418CB4(a1, 24 * v69[0], a5, a6);
            v37 = *a1;
            v38 = **a1;
            v69[0] = 1;
            if ( v13 == v38 )
            {
              sub_418CB4(a1, 0x18u, a5, a6);
LABEL_142:
              v16 = 100;
              sub_418D73((__int64 *)a1, *((_DWORD *)a1 + 395), a5, a6);
              *(_QWORD *)(v10 + 16) = sub_405B3C((__int64)a1[193], *((_DWORD *)a1 + 395));
              sub_418DBF((__int64 *)a1, a5, a6);
              goto LABEL_222;
            }
            if ( v38 == 92 )
            {
              v39 = v37[6];
              v69[0] = 2;
              if ( v39 <= 120 )
              {
                if ( v39 > 97 )
                {
                  switch ( v39 )
                  {
                    case 'b':
                      v39 = 8;
                      goto LABEL_131;
                    case 'f':
                      v39 = 12;
                      goto LABEL_131;
                    case 'n':
                      v39 = 10;
                      goto LABEL_131;
                    case 'r':
                      v39 = 13;
                      goto LABEL_131;
                    case 't':
                      v39 = 9;
                      goto LABEL_131;
                    case 'u':
                    case 'x':
                      v40 = sub_418EB9((unsigned int **)a1, 1, a5, a6);
                      sub_418D1D((__int64 *)a1, v40, a5, a6);
                      v69[0] = 0;
                      goto LABEL_132;
                    case 'v':
                      v39 = 11;
                      goto LABEL_131;
                    default:
                      goto LABEL_117;
                  }
                }
                if ( v39 == 39 || v39 == 92 || v39 == 34 )
                  goto LABEL_131;
              }
LABEL_117:
              if ( sub_41CA82(v39) )
              {
                if ( v39 == 13 && (*a1)[12] == 10 )
                  v69[0] = 3;
                goto LABEL_132;
              }
              if ( (unsigned int)(v39 - 48) <= 9 )
              {
                v39 = sub_418E07((__int64 *)a1, v69, a3);
                if ( v39 < 0 )
                {
                  v41 = (__int64 *)a1[193];
                  v42 = "invalid escape";
                  v43 = 83887020;
LABEL_141:
                  sub_401C42(v41, (__int64)"third_party/duktape/duk_lexer.c", v43, v42, a5, a6);
                  goto LABEL_142;
                }
LABEL_131:
                sub_418D1D((__int64 *)a1, v39, a5, a6);
LABEL_132:
                ++*(_DWORD *)(v10 + 44);
                continue;
              }
              if ( v39 >= 0 )
                goto LABEL_131;
            }
            else
            {
              if ( (unsigned int)(v38 - 32) <= 0x5F )
              {
                if ( a1[202] == a1[200] )
                  sub_41CFE2((__int64 *)a1[193], a1 + 200, 1LL, a5, a6);
                v44 = a1[200];
                a1[200] = (int *)((char *)v44 + 1);
                *(_BYTE *)v44 = v38;
                continue;
              }
              if ( v38 >= 0 && !sub_41CA82(v38) )
              {
                sub_418D1D((__int64 *)a1, v38, a5, a6);
                continue;
              }
            }
            break;
          }
          v41 = (__int64 *)a1[193];
          v42 = byte_43D579;
          v43 = 83887024;
          goto LABEL_141;
        case '#':
          if ( v12[6] != 33 || v14 || ((_BYTE)a1[205] & 0x40) == 0 )
            goto LABEL_228;
          goto LABEL_22;
        case '%':
          v27 = v12[6] == 61;
          v16 = 12379;
          v28 = 6214;
          goto LABEL_90;
        case '&':
          v35 = v12[6];
          v16 = 12370;
          if ( v35 == 38 )
            goto LABEL_222;
          v27 = v35 == 61;
          v16 = 12384;
          v28 = 6221;
          goto LABEL_90;
        case '(':
          v16 = 6197;
          goto LABEL_222;
        case ')':
          v16 = 6198;
          goto LABEL_222;
        case '*':
          v34 = v12[6];
          if ( v34 == 42 )
          {
            v27 = v12[12] == 61;
            v16 = 18524;
            v28 = 12359;
          }
          else
          {
            v27 = v34 == 61;
            v16 = 12377;
            v28 = 6212;
          }
          goto LABEL_90;
        case '+':
          v33 = v12[6];
          v16 = 12360;
          if ( v33 == 43 )
            goto LABEL_222;
          v27 = v33 == 61;
          v16 = 12375;
          v28 = 6210;
          goto LABEL_90;
        case ',':
          v16 = 6201;
          goto LABEL_222;
        case '-':
          v15 = (unsigned int)v12[6];
          if ( !v11 )
          {
            v16 = 12361;
            if ( (_DWORD)v15 == 45 )
              goto LABEL_222;
LABEL_89:
            v27 = (_DWORD)v15 == 61;
            v16 = 12376;
            v28 = 6211;
LABEL_90:
            if ( !v27 )
              v16 = v28;
            goto LABEL_222;
          }
          if ( (_DWORD)v15 != 45 )
            goto LABEL_89;
          if ( v12[12] != 62 )
          {
            v16 = 12361;
            goto LABEL_222;
          }
LABEL_22:
          sub_418CEF(a1, a5, a6, a2, v15);
          continue;
        case '.':
          if ( (unsigned int)(v12[6] - 48) <= 9 )
            goto LABEL_143;
          v16 = 6199;
          goto LABEL_222;
        case '/':
          v17 = v12[6];
          if ( v17 == 47 )
            goto LABEL_22;
          if ( v17 != 42 )
          {
            if ( a4 )
            {
              v23 = 0;
              sub_418DBF((__int64 *)a1, a5, a6);
              while ( 1 )
              {
                sub_418CB4(a1, 0x18u, a5, a6);
                v24 = **a1;
                if ( v24 < 0 )
                  break;
                v25 = sub_41CA82(v24);
                if ( v25 )
                  break;
                v26 = **a1;
                if ( v23 )
                {
                  if ( v23 != 1 )
                  {
                    if ( v23 == 2 )
                    {
                      if ( v26 != 93 )
                        v25 = (v26 == 92) + 2;
                    }
                    else
                    {
                      v25 = 2;
                    }
                  }
                }
                else
                {
                  switch ( v26 )
                  {
                    case '/':
                      sub_418CB4(a1, 0x18u, a5, a6);
                      *(_QWORD *)(v10 + 16) = sub_418D73((__int64 *)a1, *((_DWORD *)a1 + 395), a5, a6);
                      sub_418DBF((__int64 *)a1, a5, a6);
                      while ( sub_41CADA(**a1) )
                      {
                        sub_418D1D((__int64 *)a1, **a1, a5, a6);
                        sub_418CB4(a1, 0x18u, a5, a6);
                      }
                      v16 = 101;
                      *(_QWORD *)(v10 + 24) = sub_418D73((__int64 *)a1, *((_DWORD *)a1 + 396), a5, a6);
                      sub_418DBF((__int64 *)a1, a5, a6);
                      goto LABEL_222;
                    case '\\':
                      v25 = 1;
                      break;
                    case '[':
                      v25 = 2;
                      break;
                  }
                }
                v23 = v25;
                sub_418D1D((__int64 *)a1, v26, a5, a6);
              }
              v20 = (__int64 *)a1[193];
              v21 = "unterminated regexp";
              v22 = 83887884;
              return sub_401C42(v20, (__int64)"third_party/duktape/duk_lexer.c", v22, v21, a5, a6);
            }
            v27 = v17 == 61;
            v16 = 12378;
            v28 = 6213;
            goto LABEL_90;
          }
          v18 = 0;
          sub_418CB4(a1, 0x30u, a5, a6);
          while ( 1 )
          {
            v19 = **a1;
            if ( v19 < 0 )
            {
              v20 = (__int64 *)a1[193];
              v21 = "unterminated comment";
              v22 = 83887888;
              return sub_401C42(v20, (__int64)"third_party/duktape/duk_lexer.c", v22, v21, a5, a6);
            }
            a2 = 24LL;
            sub_418CB4(a1, 0x18u, a5, a6);
            if ( v19 == 47 && v18 )
              break;
            if ( sub_41CA82(v19) )
              v11 = 1;
            v18 = v19 == 42;
          }
          goto LABEL_4;
        case ':':
          v16 = 6229;
          goto LABEL_222;
        case ';':
          v16 = 6200;
          goto LABEL_222;
        case '<':
          v15 = (unsigned int)v12[6];
          if ( (_DWORD)v15 != 33 )
          {
            if ( (_DWORD)v15 != 60 )
            {
              v29 = (_DWORD)v15 == 61;
              v16 = 6202;
              v30 = 12348;
LABEL_72:
              if ( v29 )
                v16 = v30;
              goto LABEL_222;
            }
            v27 = v12[12] == 61;
            v16 = 18525;
            v28 = 12362;
            goto LABEL_90;
          }
          if ( v12[12] != 45 || v12[18] != 45 )
          {
            v16 = 6202;
            goto LABEL_222;
          }
          goto LABEL_22;
        case '=':
          v16 = 6230;
          if ( v12[6] != 61 )
            goto LABEL_222;
          v27 = v12[12] == 61;
          v16 = 18496;
          v28 = 12350;
          goto LABEL_90;
        case '>':
          v31 = v12[6];
          if ( v31 == 62 )
          {
            v32 = v12[12];
            if ( v32 == 62 )
            {
              v29 = v12[18] == 61;
              v16 = 18508;
              v30 = 24671;
              goto LABEL_72;
            }
            v27 = v32 == 61;
            v16 = 18526;
            v28 = 12363;
          }
          else
          {
            v27 = v31 == 61;
            v16 = 12349;
            v28 = 6203;
          }
          goto LABEL_90;
        case '?':
          v16 = 6228;
          goto LABEL_222;
        case '[':
          v16 = 6195;
          goto LABEL_222;
        case ']':
          v16 = 6196;
          goto LABEL_222;
        case '^':
          v27 = v12[6] == 61;
          v16 = 12386;
          v28 = 6223;
          goto LABEL_90;
        default:
          goto LABEL_143;
      }
    }
    if ( v13 == 9 )
      goto LABEL_214;
    if ( v13 == 10 )
      goto LABEL_146;
LABEL_143:
    if ( sub_41CA82(v13) )
    {
      if ( v13 != 13 || (a2 = 48LL, (*a1)[6] != 10) )
LABEL_146:
        a2 = 24LL;
      v11 = 1;
      sub_418CB4(a1, a2, a5, a6);
      goto LABEL_4;
    }
    v45 = sub_41CAA1(v13);
    if ( v13 == 92 || v45 )
      break;
    if ( (unsigned int)(v13 - 48) <= 9 || v13 == 46 )
    {
      sub_418DBF((__int64 *)a1, a5, a6);
      if ( v13 == 48 )
      {
        v52 = (*a1)[6] | 0x20;
        switch ( v52 )
        {
          case 'x':
            v54 = 2;
            v53 = 16;
            break;
          case 'o':
            v54 = 2;
            v53 = 8;
            break;
          case 'b':
            v54 = 2;
            v53 = 2;
            break;
          default:
            if ( (unsigned int)((*a1)[6] - 48) <= 9 )
            {
              if ( a3 )
                goto LABEL_229;
              v53 = 8;
              sub_418D1D((__int64 *)a1, 0x30u, a5, a6);
              v54 = 1;
              v55 = 1;
              goto LABEL_181;
            }
            goto LABEL_179;
        }
LABEL_180:
        v55 = 0;
LABEL_181:
        v56 = 0;
        v68 = v55;
        sub_418CB4(a1, 24 * v54, a5, a6);
        while ( 1 )
        {
          v57 = **a1;
          if ( v57 - 48 > 9 )
          {
            if ( v53 == 16 && v57 <= 0xFF )
            {
              if ( byte_44E328[v57] >= 0 )
              {
                v53 = 16;
                goto LABEL_205;
              }
              if ( v57 == 46 )
              {
                v53 = 16;
LABEL_208:
                v58 = 1024;
                sub_418D73((__int64 *)a1, *((_DWORD *)a1 + 395), a5, a6);
                v59 = *((_DWORD *)a1 + 395);
                v60 = (__int64 *)a1[193];
                if ( v53 == 10 )
                  v58 = 1474;
                sub_404F0A(v60, v59, a5, a6);
                sub_41B6EB((__int64 *)a1[193], v53, v58, a5, a6);
                *(double *)a5.i64 = sub_405CAB((__int64 *)a1[193], a5, a6);
                sub_405057((__int64 *)a1[193], *((_DWORD *)a1 + 395), v61, v62, *(double *)a5.i64, a6);
                sub_418DBF((__int64 *)a1, a5, a6);
                v63 = **a1;
                if ( (unsigned int)(v63 - 48) > 9 && !sub_41CAA1(v63) )
                {
                  v16 = 99;
                  *(_QWORD *)(v10 + 8) = a5.i64[0];
                  goto LABEL_222;
                }
LABEL_229:
                v20 = (__int64 *)a1[193];
                v21 = "invalid number literal";
                v22 = 83887876;
                return sub_401C42(v20, (__int64)"third_party/duktape/duk_lexer.c", v22, v21, a5, a6);
              }
            }
            else if ( v57 == 46 )
            {
              if ( v56 || v53 != 10 )
                goto LABEL_208;
              v56 = 1;
              goto LABEL_205;
            }
            if ( (v57 & 0xFFFFFFDF) != 69 )
            {
              if ( ((v57 - 43) & 0xFFFFFFFD) != 0 || v56 != 2 )
                goto LABEL_208;
LABEL_204:
              v56 = 3;
              goto LABEL_205;
            }
            if ( v56 > 1 || v53 != 10 )
              goto LABEL_208;
            v56 = 2;
          }
          else if ( v56 || !v68 )
          {
            if ( v56 == 2 )
              goto LABEL_204;
          }
          else if ( v57 - 56 <= 1 )
          {
            v53 = 10;
          }
LABEL_205:
          sub_418D1D((__int64 *)a1, v57, a5, a6);
          sub_418CB4(a1, 0x18u, a5, a6);
        }
      }
LABEL_179:
      v54 = 0;
      v53 = 10;
      goto LABEL_180;
    }
    if ( !(unsigned int)sub_41CA19(**a1) )
    {
      if ( v13 < 0 )
      {
        v16 = 0;
        goto LABEL_222;
      }
LABEL_228:
      v20 = (__int64 *)a1[193];
      v21 = "invalid token";
      v22 = 83887872;
      return sub_401C42(v20, (__int64)"third_party/duktape/duk_lexer.c", v22, v21, a5, a6);
    }
LABEL_214:
    a2 = 24LL;
    sub_418CB4(a1, 0x18u, a5, a6);
  }
  sub_418DBF((__int64 *)a1, a5, a6);
  for ( i = 1; ; i = 0 )
  {
    v65 = i;
    v47 = **a1;
    if ( v47 != 92 )
      break;
    if ( (*a1)[6] != 117
      || ((v48 = sub_418EB9((unsigned int **)a1, 1, a5, a6), sub_418D1D((__int64 *)a1, v48, a5, a6), !v65) ? (v49 = sub_41CADA(v48)) : (v49 = sub_41CAA1(v48)),
          !v49) )
    {
      v20 = (__int64 *)a1[193];
      v21 = "invalid escape";
      v22 = 83887880;
      return sub_401C42(v20, (__int64)"third_party/duktape/duk_lexer.c", v22, v21, a5, a6);
    }
    ++*(_DWORD *)(v10 + 44);
LABEL_158:
    ;
  }
  if ( sub_41CADA(v47) )
  {
    sub_418D1D((__int64 *)a1, **a1, a5, a6);
    sub_418CB4(a1, 0x18u, a5, a6);
    goto LABEL_158;
  }
  v16 = 1;
  v50 = sub_418D73((__int64 *)a1, *((_DWORD *)a1 + 395), a5, a6);
  *(_DWORD *)(v10 + 4) = 1;
  *(_QWORD *)(v10 + 16) = v50;
  v66 = v50;
  sub_418DBF((__int64 *)a1, a5, a6);
  if ( !*(_DWORD *)(v10 + 44) )
  {
    v51 = 122LL;
    do
    {
      if ( v66 == *(_QWORD *)(*((_QWORD *)a1[193] + 71) + 8 * v51) )
      {
        v16 = v51 - 120;
        goto LABEL_222;
      }
      ++v51;
    }
    while ( (a3 == 0 ? 158 : 167) > (unsigned int)v51 );
    v16 = 1;
  }
LABEL_222:
  sub_418CB4(a1, v16 >> 8, a5, a6);
  v27 = *(_DWORD *)(v10 + 4) == -1;
  *(_DWORD *)v10 = (unsigned __int8)v16;
  if ( v27 )
    *(_DWORD *)(v10 + 4) = (unsigned __int8)v16;
  *(_DWORD *)(v10 + 48) = v11;
  result = (unsigned __int8)v16 == 50;
  *(_DWORD *)(v10 + 52) = result | ((unsigned __int8)v16 == 0) || (v11 & 1) != 0;
  return result;
}
// 419A6E: variable 'v61' is possibly undefined
// 419A6E: variable 'v62' is possibly undefined
// 418FE2: using guessed type int var_34[13];

//----- (0000000000419B9C) ----------------------------------------------------
unsigned __int8 *__fastcall sub_419B9C(int **a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  bool v5; // cc
  unsigned __int8 *result; // rax
  int *v8; // rcx
  int v9; // edx
  int v10; // eax
  unsigned int v11; // ebx
  bool v12; // zf
  unsigned __int64 v13; // rcx
  int v14; // er14
  int v15; // er15
  int v16; // ebx
  __int64 v17; // rax
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  unsigned int v21; // esi
  int v22; // er15
  int v23; // ebx
  __int64 v24; // rax
  int v25; // ebx
  int v26; // eax
  int v27; // eax
  __int64 *v28; // rdi
  const char *v29; // rcx
  unsigned int v30; // edx
  char v31[64]; // [rsp+0h] [rbp-40h] BYREF

  v4 = *((_DWORD *)a1 + 408) + 1;
  v5 = v4 < *((_DWORD *)a1 + 409);
  *((_DWORD *)a1 + 408) = v4;
  if ( !v5 )
    return (unsigned __int8 *)sub_401CE2(
                                (__int64 *)a1[193],
                                (__int64)"third_party/duktape/duk_lexer.c",
                                2161,
                                "token limit",
                                a3,
                                a4);
  sub_43ABE2(a2, 0LL, 0x14uLL);
  v8 = *a1;
  v9 = **a1;
  v10 = (*a1)[6];
  if ( v9 <= 46 )
  {
    if ( v9 <= 35 )
    {
      v11 = 0;
      v12 = v9 == -1;
      goto LABEL_16;
    }
    switch ( v9 )
    {
      case '$':
        v11 = 6148;
        goto LABEL_108;
      case '(':
        v11 = 6162;
        if ( v10 != 63 )
          goto LABEL_108;
        v27 = v8[12];
        if ( v27 == 61 )
        {
          v11 = 18439;
          goto LABEL_108;
        }
        if ( v27 == 33 )
        {
          v11 = 18440;
          goto LABEL_108;
        }
        v11 = 18451;
        if ( v27 == 58 )
          goto LABEL_108;
        v28 = (__int64 *)a1[193];
        v29 = "invalid regexp group";
        v30 = 83888249;
        break;
      case ')':
        v11 = 6166;
        goto LABEL_108;
      case '*':
        v13 = 0xFFFFFFFF00000000LL;
        goto LABEL_19;
      case '+':
        v13 = 0xFFFFFFFF00000001LL;
        goto LABEL_19;
      case '.':
        v11 = 6153;
        goto LABEL_108;
      default:
        goto LABEL_94;
    }
    return (unsigned __int8 *)sub_401C42(v28, (__int64)"third_party/duktape/duk_lexer.c", v30, v29, a3, a4);
  }
  if ( v9 == 94 )
  {
    v11 = 6147;
    goto LABEL_108;
  }
  if ( v9 <= 94 )
  {
    if ( v9 == 91 )
    {
      v11 = 6164;
      if ( v10 == 94 )
        v11 = 12309;
      goto LABEL_108;
    }
    if ( v9 != 92 )
    {
      if ( v9 == 63 )
      {
        v13 = 0x100000000LL;
LABEL_19:
        *(_QWORD *)(a2 + 12) = v13;
        if ( v10 == 63 )
        {
          *(_DWORD *)(a2 + 4) = 0;
          v11 = 12290;
        }
        else
        {
          *(_DWORD *)(a2 + 4) = 1;
          v11 = 6146;
        }
        goto LABEL_108;
      }
      goto LABEL_94;
    }
    switch ( v10 )
    {
      case 'b':
        v11 = 12293;
        goto LABEL_108;
      case 'B':
        v11 = 12294;
        goto LABEL_108;
      case 'f':
        *(_DWORD *)(a2 + 8) = 12;
        break;
      case 'n':
        *(_DWORD *)(a2 + 8) = 10;
        break;
      case 't':
        *(_DWORD *)(a2 + 8) = 9;
        break;
      case 'r':
        *(_DWORD *)(a2 + 8) = 13;
        break;
      case 'v':
        *(_DWORD *)(a2 + 8) = 11;
        break;
      default:
        switch ( v10 )
        {
          case 'c':
            if ( (v8[12] & 0xFFFFFFDF) - 65 <= 0x19 )
            {
              v11 = 18442;
              *(_DWORD *)(a2 + 8) = v8[12] % 32;
              goto LABEL_108;
            }
            break;
          case 'x':
          case 'u':
            v11 = 10;
            *(_DWORD *)(a2 + 8) = sub_418EB9((unsigned int **)a1, 0, a3, a4);
            goto LABEL_108;
          case 'd':
            v11 = 12299;
            goto LABEL_108;
          case 'D':
            v11 = 12300;
            goto LABEL_108;
          case 's':
            v11 = 12301;
            goto LABEL_108;
          case 'S':
            v11 = 12302;
            goto LABEL_108;
          case 'w':
            v11 = 12303;
            goto LABEL_108;
          case 'W':
            v11 = 12304;
            goto LABEL_108;
          default:
            if ( (unsigned int)(v10 - 48) > 9 )
            {
              if ( v10 >= 0 )
              {
                *(_DWORD *)(a2 + 8) = v10;
                goto LABEL_84;
              }
            }
            else
            {
              if ( v10 != 48 )
              {
                v22 = 9;
                v23 = 0;
                while ( 1 )
                {
                  sub_418CB4(a1, 0x18u, a3, a4);
                  v24 = **a1;
                  if ( (unsigned int)(v24 - 48) > 9 )
                    break;
                  v25 = 10 * v23;
                  v26 = byte_44E328[v24];
                  if ( v26 < 0 )
                    v26 = -1;
                  v23 = v26 + v25;
                  if ( !--v22 )
                    goto LABEL_109;
                }
                *(_DWORD *)(a2 + 8) = v23;
                v11 = 17;
                goto LABEL_108;
              }
              if ( (unsigned int)(v8[12] - 48) > 9 )
              {
                *(_DWORD *)(a2 + 8) = 0;
                goto LABEL_84;
              }
            }
            break;
        }
LABEL_109:
        v28 = (__int64 *)a1[193];
        v29 = "invalid regexp escape";
        v30 = 83888245;
        return (unsigned __int8 *)sub_401C42(v28, (__int64)"third_party/duktape/duk_lexer.c", v30, v29, a3, a4);
    }
LABEL_84:
    v11 = 12298;
    goto LABEL_108;
  }
  if ( v9 != 123 )
  {
    v11 = 6145;
    v12 = v9 == 124;
LABEL_16:
    if ( v12 )
      goto LABEL_108;
LABEL_94:
    *(_DWORD *)(a2 + 8) = v9;
LABEL_95:
    v11 = 6154;
    goto LABEL_108;
  }
  v14 = 0;
  v15 = -1;
  v16 = 0;
  sub_418FB0((__int64)a1, (__int64)v31);
  while ( 1 )
  {
    sub_418CB4(a1, 0x18u, a3, a4);
    v17 = **a1;
    if ( (unsigned int)(v17 - 48) <= 9 )
    {
      v18 = byte_44E328[v17];
      ++v14;
      v19 = 10 * v16;
      if ( v18 < 0 )
        v18 = -1;
      v20 = v19 + v18;
      v16 = v15;
      goto LABEL_28;
    }
    if ( (_DWORD)v17 != 44 )
      break;
    if ( v15 != -1 || v14 > 9 )
      goto LABEL_46;
    if ( (*a1)[6] == 125 )
    {
      if ( v14 )
      {
        *(_DWORD *)(a2 + 12) = v16;
        *(_DWORD *)(a2 + 16) = -1;
        v21 = 48;
        goto LABEL_42;
      }
LABEL_46:
      sub_418FC1((__int64)a1, (__int64)v31, a3, a4);
      *(_DWORD *)(a2 + 8) = 123;
      goto LABEL_95;
    }
    v14 = 0;
    v20 = 0;
LABEL_28:
    v15 = v16;
    v16 = v20;
  }
  if ( v14 == 0 || (_DWORD)v17 != 125 || v14 > 9 )
    goto LABEL_46;
  if ( v15 == -1 )
    *(_DWORD *)(a2 + 12) = v16;
  else
    *(_DWORD *)(a2 + 12) = v15;
  *(_DWORD *)(a2 + 16) = v16;
  v21 = 24;
LABEL_42:
  sub_418CB4(a1, v21, a3, a4);
  if ( **a1 == 63 )
  {
    *(_DWORD *)(a2 + 4) = 0;
    sub_418CB4(a1, 0x18u, a3, a4);
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 1;
  }
  v11 = 2;
LABEL_108:
  result = sub_418CB4(a1, v11 >> 8, a3, a4);
  *(_DWORD *)a2 = (unsigned __int8)v11;
  return result;
}

//----- (000000000041A06B) ----------------------------------------------------
unsigned __int8 *__fastcall sub_41A06B(
        unsigned int **a1,
        __int64 (__fastcall *a2)(__int64, __int64, __int64, __int64),
        __int64 a3,
        __m128 a4,
        __m128 a5)
{
  int v6; // er15
  unsigned int v7; // er12
  unsigned int *v8; // rax
  int v9; // er8
  __int64 *v10; // rdi
  const char *v11; // rcx
  unsigned int v12; // edx
  signed int v14; // eax
  int v15; // eax
  int v16; // ecx
  __int64 *v17; // rdx
  int v18; // [rsp+Ch] [rbp-44h]
  int v19[13]; // [rsp+1Ch] [rbp-34h] BYREF

  v19[0] = 0;
LABEL_2:
  v6 = 0;
LABEL_3:
  v7 = -1;
  while ( 1 )
  {
    sub_418CB4(a1, 24 * v19[0], a4, a5);
    v8 = *a1;
    v19[0] = 1;
    v9 = *v8;
    if ( (*v8 & 0x80000000) != 0 )
    {
      v10 = (__int64 *)a1[193];
      v11 = "unterminated character class";
      v12 = 83888515;
      return (unsigned __int8 *)sub_401C42(v10, (__int64)"third_party/duktape/duk_lexer.c", v12, v11, a4, a5);
    }
    if ( v9 == 93 )
      break;
    if ( v9 == 45 )
    {
      if ( (v7 & 0x80000000) != 0 || v6 )
        goto LABEL_55;
      v6 = 1;
      if ( v8[6] == 93 )
        goto LABEL_60;
    }
    else
    {
      if ( v9 != 92 )
        goto LABEL_55;
      v9 = v8[6];
      v19[0] = 2;
      switch ( v9 )
      {
        case 'b':
          v9 = 8;
          goto LABEL_55;
        case 'f':
          v9 = 12;
          goto LABEL_55;
        case 'n':
          v9 = 10;
          goto LABEL_55;
        case 't':
          v9 = 9;
          goto LABEL_55;
        case 'r':
          v9 = 13;
          goto LABEL_55;
        case 'v':
          v9 = 11;
          goto LABEL_55;
        case 'c':
          v14 = v8[12];
          v19[0] = 3;
          if ( (v14 & 0xFFFFFFDF) - 65 > 0x19 )
            goto LABEL_61;
          v9 = v14 % 32;
          goto LABEL_45;
        case 'x':
        case 'u':
          v15 = sub_418EB9(a1, 0, a4, a5);
          v19[0] = 0;
          v9 = v15;
          goto LABEL_45;
        case 'd':
          v16 = 2;
          v17 = (__int64 *)&dword_43DD2C;
LABEL_40:
          sub_418E75(a2, a3, (unsigned __int16 *)v17, v16);
LABEL_46:
          if ( v7 != -1 )
          {
            if ( !v6 )
            {
              a2(a3, v7, v7, 0LL);
              goto LABEL_3;
            }
            goto LABEL_62;
          }
          break;
        case 'D':
          v16 = 4;
          v17 = qword_43DDC0;
          goto LABEL_40;
        case 's':
          v16 = 22;
          v17 = (__int64 *)asc_43DD00;
          goto LABEL_40;
        case 'S':
          v16 = 24;
          v17 = qword_43DCC0;
          goto LABEL_40;
        case 'w':
          v16 = 8;
          v17 = (__int64 *)a09azAz;
          goto LABEL_40;
        case 'W':
          v16 = 10;
          v17 = qword_43DCA0;
          goto LABEL_40;
        default:
          if ( (unsigned int)(v9 - 48) > 9 )
          {
            if ( v9 < 0 )
            {
LABEL_61:
              v10 = (__int64 *)a1[193];
              v11 = "invalid regexp escape";
              v12 = 83888507;
              return (unsigned __int8 *)sub_401C42(v10, (__int64)"third_party/duktape/duk_lexer.c", v12, v11, a4, a5);
            }
            goto LABEL_55;
          }
          v9 = sub_418E07((__int64 *)a1, v19, 0);
LABEL_45:
          if ( v9 < 0 )
            goto LABEL_46;
LABEL_55:
          if ( v7 == -1 )
          {
            v7 = v9;
          }
          else
          {
            if ( v6 )
            {
              if ( (int)v7 <= v9 )
              {
                a2(a3, v7, (unsigned int)v9, 0LL);
                goto LABEL_2;
              }
LABEL_62:
              v10 = (__int64 *)a1[193];
              v11 = "invalid range";
              v12 = 83888511;
              return (unsigned __int8 *)sub_401C42(v10, (__int64)"third_party/duktape/duk_lexer.c", v12, v11, a4, a5);
            }
LABEL_60:
            v18 = v9;
            v6 = 0;
            a2(a3, v7, v7, 0LL);
            v7 = v18;
          }
          break;
      }
    }
  }
  if ( v7 != -1 )
    *(double *)a4.i64 = ((double (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))a2)(a3, v7, v7, 0LL);
  return sub_418CB4(a1, 0x18u, a4, a5);
}
// 43DCA0: using guessed type __int64 qword_43DCA0[4];
// 43DCC0: using guessed type __int64 qword_43DCC0[8];
// 43DD00: using guessed type __int16 asc_43DD00[4];
// 43DD2C: using guessed type int dword_43DD2C;
// 43DDC0: using guessed type __int64 qword_43DDC0[2];
// 43DDD0: using guessed type __int16 a09azAz[8];
// 41A06B: using guessed type int var_34[13];

//----- (000000000041A342) ----------------------------------------------------
__int64 __fastcall sub_41A342(_DWORD *a1)
{
  __int64 result; // rax
  int v2; // edx

  result = *a1 - 1;
  do
  {
    v2 = result;
    if ( (int)result < 0 )
      break;
    --result;
  }
  while ( !a1[result + 2] );
  *a1 = v2 + 1;
  return result;
}

//----- (000000000041A35D) ----------------------------------------------------
__int64 __fastcall sub_41A35D(int *a1, int *a2)
{
  int v2; // eax
  unsigned int v3; // er8
  __int64 i; // rax
  unsigned int v5; // ecx
  unsigned int v6; // edx

  v2 = *a1;
  v3 = 1;
  if ( *a1 <= *a2 )
  {
    v3 = -1;
    if ( v2 >= *a2 )
    {
      for ( i = v2 - 1; ; --i )
      {
        if ( (int)i < 0 )
          return 0;
        v5 = a1[i + 1];
        v6 = a2[i + 1];
        if ( v5 > v6 )
          break;
        if ( v5 < v6 )
          return (unsigned int)-1;
      }
      return 1;
    }
  }
  return v3;
}

//----- (000000000041A3A1) ----------------------------------------------------
__int64 __fastcall sub_41A3A1(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // rax
  __int64 result; // rax
  int v5; // er9
  __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx

  if ( *a3 > *a2 )
  {
    v3 = a2;
    a2 = a3;
    a3 = v3;
  }
  result = (unsigned int)*a2;
  v5 = *a3;
  v6 = 0LL;
  v7 = 0LL;
  while ( (int)result > (int)v6 )
  {
    v8 = (unsigned int)a2[v6 + 1] + v7;
    if ( v5 > (int)v6 )
      v8 += (unsigned int)a3[v6 + 1];
    a1[v6 + 1] = v8;
    v7 = HIDWORD(v8);
    ++v6;
  }
  if ( (int)result < 0 )
    result = 0LL;
  if ( v7 )
  {
    v9 = (int)result;
    result = (unsigned int)(result + 1);
    a1[v9 + 1] = 1;
  }
  *a1 = result;
  return result;
}

//----- (000000000041A401) ----------------------------------------------------
__int64 __fastcall sub_41A401(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  __int64 result; // rax
  int *v4; // rcx
  _DWORD *v5; // r8
  int *v6; // r9
  int v7; // eax
  __int64 v8; // rdx
  int v9; // edi
  int v10; // er10
  _DWORD *v11; // rsi
  __int64 v12; // rbx
  unsigned __int64 i; // rax
  __int64 v14; // r14
  unsigned __int64 v15; // rax
  int v16; // esi

  result = (unsigned int)(*a2 + *a3);
  if ( *a2 + *a3 )
  {
    sub_43ABE2((__int64)(a1 + 1), 0LL, 4LL * (int)result);
    *v5 = v7;
    v8 = 0LL;
    v9 = *v6;
    v10 = *v4;
    while ( v10 > (int)v8 )
    {
      v11 = &v5[v8];
      v12 = 0LL;
      for ( i = 0LL; ; i = HIDWORD(v15) )
      {
        ++v11;
        if ( v9 <= (int)v12 )
          break;
        v14 = (unsigned int)v6[++v12];
        v15 = i + (unsigned int)*v11 + v14 * (unsigned int)v4[v8 + 1];
        *v11 = v15;
      }
      v16 = 0;
      if ( v9 >= 0 )
        v16 = v9;
      if ( i )
        v5[(int)v8 + 1 + v16] = i;
      ++v8;
    }
    return sub_41A342(v5);
  }
  else
  {
    *a1 = 0;
  }
  return result;
}
// 41A431: variable 'v7' is possibly undefined
// 41A431: variable 'v5' is possibly undefined
// 41A43C: variable 'v6' is possibly undefined
// 41A43F: variable 'v4' is possibly undefined

//----- (000000000041A4A8) ----------------------------------------------------
void __fastcall sub_41A4A8(__int64 a1, int *a2)
{
  __int64 v2; // rdx
  __int64 v3; // rdi

  v2 = *a2;
  v3 = a1 + 4;
  *(_DWORD *)(v3 - 4) = v2;
  sub_43AAA0(v3, (__int64)(a2 + 1), 4 * v2);
}

//----- (000000000041A4C6) ----------------------------------------------------
__int64 __fastcall sub_41A4C6(__int64 a1, int a2)
{
  unsigned int v2; // er8
  _BYTE *v3; // rsi
  __int64 v4; // rcx
  int v5; // edx

  v2 = 0;
  if ( *(_BYTE *)(a1 + a2 + 1108) >= (unsigned __int8)((*(_DWORD *)(a1 + 1088) + 1) / 2) )
  {
    v3 = (_BYTE *)(a1 + a2 + 1108);
    do
    {
      *v3 = 0;
      if ( v3 == (_BYTE *)(a1 + 1108) )
      {
        sub_43ABC2((_BYTE *)(a1 + 1109), v3, *(int *)(a1 + 2148));
        *(_BYTE *)(v4 + 1108) = 1;
        ++*(_DWORD *)(v4 + 1092);
        ++*(_DWORD *)(v4 + 2148);
        return v2;
      }
      v5 = (unsigned __int8)*--v3;
    }
    while ( v5 + 1 >= *(_DWORD *)(a1 + 1088) );
    v2 = 0;
    *v3 = v5 + 1;
  }
  return v2;
}
// 41A518: variable 'v4' is possibly undefined
// 41A547: variable 'v2' is possibly undefined

//----- (000000000041A54B) ----------------------------------------------------
__int64 __fastcall sub_41A54B(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4[38]; // [rsp+8h] [rbp-98h] BYREF

  if ( a3 )
  {
    v4[0] = 1;
    v4[1] = a3;
  }
  else
  {
    v4[0] = 0;
  }
  return sub_41A401(a1, a2, v4);
}

//----- (000000000041A584) ----------------------------------------------------
void __fastcall sub_41A584(_DWORD *a1, int a2, int *a3)
{
  sub_41A54B(a3, a1, a2);
  sub_41A4A8((__int64)a1, a3);
}

//----- (000000000041A5AF) ----------------------------------------------------
void __fastcall sub_41A5AF(_DWORD *a1)
{
  int *v1; // r13
  int i; // ebx
  int *v3; // [rsp+0h] [rbp-40h]
  _DWORD *v4; // [rsp+8h] [rbp-38h]

  v1 = a1 + 114;
  for ( i = 0; ; ++i )
  {
    v4 = a1 + 38;
    sub_41A3A1(a1 + 190, a1 + 38, v1);
    if ( __SPAIR64__(sub_41A35D(a1 + 190, a1 + 76), a1[275]) < 1 )
      break;
    sub_41A584(a1 + 76, a1[272], a1 + 190);
  }
  if ( !i )
  {
    v3 = a1 + 228;
    while ( 1 )
    {
      sub_41A3A1(a1 + 190, v4, v1);
      sub_41A54B(v3, a1 + 190, a1[272]);
      if ( -(a1[275] != 0) < (int)sub_41A35D(v3, a1 + 76) )
        break;
      sub_41A584(v4, a1[272], a1 + 190);
      sub_41A584(v1, a1[272], a1 + 190);
      if ( a1[276] )
        sub_41A584(a1 + 152, a1[272], a1 + 190);
      --i;
    }
  }
  if ( !a1[276] )
    sub_41A4A8((__int64)(a1 + 152), v1);
  a1[273] = i;
}

//----- (000000000041A6F9) ----------------------------------------------------
__int64 __fastcall sub_41A6F9(_DWORD *a1)
{
  int *v2; // r13
  int v3; // ebx
  int v4; // er8
  int v5; // er9
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // r10
  __int64 v9; // rax
  __int64 result; // rax
  int v11; // er11
  char v12; // r15
  int v13; // er8
  int v14; // er10
  int v15; // edx
  int *v16; // [rsp+20h] [rbp-40h]
  __int64 i; // [rsp+28h] [rbp-38h]

  v2 = a1 + 38;
  for ( i = 0LL; ; ++i )
  {
    v3 = 0;
    sub_41A54B(a1 + 190, v2, a1[272]);
    v16 = a1 + 76;
    while ( (int)sub_41A35D(a1 + 190, v16) >= 0 )
    {
      v4 = a1[190];
      v5 = a1[76];
      v6 = 0LL;
      v7 = 0LL;
      while ( (int)v6 < v4 )
      {
        v8 = 0LL;
        if ( (int)v6 < v5 )
          v8 = (unsigned int)a1[v6 + 77];
        v9 = (unsigned int)a1[v6 + 191] - v8 + v7;
        a1[v6 + 229] = v9;
        v7 = v9 >> 32;
        ++v6;
      }
      if ( v4 < 0 )
        v4 = 0;
      ++v3;
      a1[228] = v4;
      sub_41A342(a1 + 228);
      sub_41A4A8((__int64)(a1 + 190), a1 + 228);
    }
    sub_41A4A8((__int64)v2, a1 + 190);
    sub_41A584(a1 + 114, a1[272], a1 + 228);
    sub_41A584(a1 + 152, a1[272], a1 + 228);
    if ( a1[267] )
    {
      result = 0LL;
      v11 = 0;
    }
    else
    {
      sub_41A35D(v2, a1 + 152);
      sub_41A3A1(a1 + 190, v2, a1 + 114);
      result = __SPAIR64__(sub_41A35D(a1 + 190, v16), a1[275]) >= 1;
    }
    v12 = v3;
    v13 = i + 1;
    if ( v11 )
      break;
    if ( (_DWORD)result )
    {
      result = (int)i;
      *((_BYTE *)a1 + (int)i + 1108) = v3 + 1;
      goto LABEL_29;
    }
    result = i;
    *((_BYTE *)a1 + i + 1108) = v3;
    if ( a1[267] )
    {
      v15 = a1[268];
      if ( a1[269] )
      {
        result = (unsigned int)(a1[273] - v13);
        if ( v15 > (int)result )
          goto LABEL_29;
      }
      else if ( v15 <= v13 )
      {
        goto LABEL_29;
      }
    }
  }
  if ( (_DWORD)result )
  {
    sub_41A54B(a1 + 190, v2, 2);
    v14 = sub_41A35D(a1 + 190, v16);
    result = (unsigned int)(v3 + 1);
    v13 = i + 1;
    if ( v14 >= 0 )
      v12 = v3 + 1;
    *((_BYTE *)a1 + (int)i + 1108) = v12;
  }
  else
  {
    *((_BYTE *)a1 + (int)i + 1108) = v3;
  }
LABEL_29:
  a1[537] = v13;
  return result;
}
// 41A893: variable 'v11' is possibly undefined

//----- (000000000041A95B) ----------------------------------------------------
void __fastcall sub_41A95B(_DWORD *a1, int a2, int a3, _DWORD *a4, int *a5)
{
  int v5; // ebx
  int v6; // er8
  char v7; // cl
  __int64 v8; // rax

  v5 = a3;
  if ( a2 == 2 )
  {
    sub_43ABE2((__int64)(a1 + 1), 0LL, 4LL * (a3 / 32 + 1));
    *a1 = v6;
    a1[v8 + 1] = 1 << v7;
  }
  else
  {
    *(_QWORD *)a1 = 0x100000001LL;
    if ( a2 )
    {
      *a4 = 1;
      a4[1] = a2;
    }
    else
    {
      *a4 = 0;
    }
    while ( 1 )
    {
      if ( (v5 & 1) != 0 )
      {
        sub_41A401(a5, a1, a4);
        sub_41A4A8((__int64)a1, a5);
      }
      v5 >>= 1;
      if ( !v5 )
        break;
      sub_41A401(a5, a4, a4);
      sub_41A4A8((__int64)a4, a5);
    }
  }
}
// 41A999: variable 'v6' is possibly undefined
// 41A99D: variable 'v7' is possibly undefined
// 41A99F: variable 'v8' is possibly undefined

//----- (000000000041AA14) ----------------------------------------------------
__int64 __fastcall sub_41AA14(int *a1)
{
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int *v5; // r8
  int v6; // esi
  int *v7; // rcx
  int *v8; // rdi
  __int64 result; // rax
  int *v10; // [rsp+8h] [rbp-38h]

  v2 = *a1;
  if ( *a1 && (a1[1] & 1) != 0 )
    *((_QWORD *)a1 + 137) = 0LL;
  else
    *((_QWORD *)a1 + 137) = 0x100000001LL;
  v3 = a1[266];
  if ( v3 )
  {
    v3 = 0;
  }
  else if ( v2 == 2 && !a1[1] )
  {
    v3 = a1[2] == 0x100000;
  }
  v4 = a1[270];
  v5 = a1 + 228;
  a1[276] = 0;
  if ( v4 >= 0 )
  {
    v6 = a1[271];
    v7 = a1 + 190;
    v8 = a1 + 152;
    if ( !v3 )
    {
      sub_41A95B(v8, v6, v4, v7, v5);
      sub_41A4A8((__int64)(a1 + 114), a1 + 152);
      sub_41A54B(a1 + 190, a1, 2);
      sub_41A401(a1 + 38, a1 + 190, a1 + 114);
      result = 0x200000001LL;
      *((_QWORD *)a1 + 38) = 0x200000001LL;
      return result;
    }
    sub_41A95B(v8, v6, v4, v7, v5);
    sub_41A54B(a1 + 114, a1 + 152, a1[271]);
    sub_41A54B(a1 + 190, a1, 2);
    sub_41A401(a1 + 38, a1 + 190, a1 + 114);
    result = (unsigned int)(2 * a1[271]);
    if ( (_DWORD)result )
    {
      a1[76] = 1;
      a1[77] = result;
    }
    else
    {
      a1[76] = 0;
    }
    goto LABEL_19;
  }
  v10 = a1 + 228;
  if ( v4 >= -1021 && (v3 & 1) != 0 )
  {
    sub_41A54B(a1 + 38, a1, 2 * a1[271]);
    sub_41A95B(a1 + 190, a1[271], 1 - a1[270], a1 + 76, v10);
    sub_41A54B(a1 + 76, a1 + 190, 2);
    *((_QWORD *)a1 + 57) = 0x200000001LL;
    result = 0x100000001LL;
    *((_QWORD *)a1 + 76) = 0x100000001LL;
LABEL_19:
    a1[276] = 1;
    return result;
  }
  sub_41A54B(a1 + 38, a1, 2);
  sub_41A95B(a1 + 190, a1[271], -a1[270], a1 + 76, v10);
  sub_41A54B(a1 + 76, a1 + 190, 2);
  result = 0x100000001LL;
  *((_QWORD *)a1 + 57) = 0x100000001LL;
  *((_QWORD *)a1 + 76) = 0x100000001LL;
  return result;
}

//----- (000000000041AC55) ----------------------------------------------------
__int64 __fastcall sub_41AC55(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  unsigned int v5; // er14
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r15
  int v12; // eax
  unsigned __int8 *v13; // rdi
  char v14; // al
  unsigned int v15; // ecx
  int v16; // er13
  int v17; // er10
  int v18; // eax
  int v19; // er11
  int v20; // edx
  bool v22; // zf
  int v23; // eax
  int v24; // er13
  char v25; // r14
  __int64 v26; // r8
  int v27; // er15
  int v28; // er9
  int v29; // er10
  int v30; // esi
  __int64 v31; // rax
  int v32; // er8
  char *v33; // r9
  int v34; // edi
  __int64 v35; // rdx
  int v36; // [rsp+8h] [rbp-968h]
  int v37; // [rsp+Ch] [rbp-964h]
  int v38; // [rsp+10h] [rbp-960h]
  int v39; // [rsp+18h] [rbp-958h]
  int v40; // [rsp+1Ch] [rbp-954h]
  unsigned __int8 *v41; // [rsp+20h] [rbp-950h]
  int v42; // [rsp+28h] [rbp-948h]
  __int64 v43; // [rsp+28h] [rbp-948h]
  int v44; // [rsp+30h] [rbp-940h]
  int v45; // [rsp+34h] [rbp-93Ch]
  int v46; // [rsp+34h] [rbp-93Ch]
  int v47; // [rsp+38h] [rbp-938h]
  double v48; // [rsp+40h] [rbp-930h] BYREF
  int v49[190]; // [rsp+D8h] [rbp-898h] BYREF
  int v50[76]; // [rsp+3D0h] [rbp-5A0h] BYREF
  __int64 v51; // [rsp+500h] [rbp-470h]
  __int64 v52; // [rsp+508h] [rbp-468h]
  int v53; // [rsp+510h] [rbp-460h]
  int v54; // [rsp+514h] [rbp-45Ch]
  int v55; // [rsp+518h] [rbp-458h]
  int v56; // [rsp+51Ch] [rbp-454h]
  int v57; // [rsp+93Ch] [rbp-34h]

  v5 = a3;
  if ( (a3 & 1) != 0 )
    sub_4090EA(a1, -1, a4, a5);
  v8 = 0xFFFFFFFFLL;
  v11 = sub_40574F(a1, -1, a4, a5);
  v12 = *(unsigned __int8 *)(v11 + 32);
  if ( v12 == 43 )
  {
    v13 = (unsigned __int8 *)(v11 + 33);
    if ( (v5 & 8) == 0 )
      goto LABEL_119;
    goto LABEL_8;
  }
  if ( v12 != 45 )
  {
    v13 = (unsigned __int8 *)(v11 + 32);
LABEL_8:
    v44 = 0;
    goto LABEL_11;
  }
  if ( (v5 & 0x10) == 0 )
    goto LABEL_119;
  v13 = (unsigned __int8 *)(v11 + 33);
  v44 = 1;
LABEL_11:
  if ( (v5 & 0x20) != 0 )
  {
    v8 = (__int64)"Infinity";
    if ( !(unsigned int)sub_43AD1A(v13, "Infinity") )
    {
      if ( (v5 & 4) == 0 && v13[8] )
        goto LABEL_119;
      goto LABEL_14;
    }
  }
  if ( *v13 != 48 )
    goto LABEL_28;
  v14 = v13[1] | 0x20;
  if ( (v5 & 0x800) != 0 && v14 == 120 )
  {
    a2 = 16;
  }
  else if ( (v5 & 0x2000) != 0 && v14 == 111 )
  {
    a2 = 8;
  }
  else
  {
    if ( (v5 & 0x4000) == 0 || v14 != 98 )
      goto LABEL_28;
    a2 = 2;
  }
  v13 += 2;
  v15 = v5 & 0xFFFFFC3D;
  BYTE1(v15) = ((unsigned __int16)(v5 & 0xFC3D) >> 8) | 4;
  v5 = v15;
LABEL_28:
  v49[0] = 0;
  v47 = 0;
  v10 = v5 >> 1;
  v16 = -1;
  v17 = -1;
  v39 = 0;
  v45 = 0;
  v18 = 0;
  v42 = 0;
  v40 = 0;
  while ( 1 )
  {
    v9 = *v13;
    v41 = v13 + 1;
    v19 = v9 - 48;
    v8 = v9;
    if ( (unsigned int)(v9 - 48) > 9 )
      break;
LABEL_49:
    if ( a2 <= v19 )
      goto LABEL_50;
    if ( v16 == -1 )
    {
      if ( (unsigned __int8)byte_43DA00[a2 - 2] <= v47 )
      {
        ++v42;
      }
      else
      {
        v10 = v49[0] | (unsigned int)v19;
        if ( !(v49[0] | v19) )
        {
          if ( v17 != -1 )
            goto LABEL_63;
          ++v39;
LABEL_64:
          ++v45;
          v17 = -1;
          goto LABEL_35;
        }
        v36 = v17;
        v37 = v19;
        v38 = v18;
        sub_41A54B(v50, v49, a2);
        if ( v37 )
        {
          LODWORD(v48) = 1;
          HIDWORD(v48) = v37;
        }
        else
        {
          LODWORD(v48) = 0;
        }
        sub_41A3A1(v49, v50, &v48);
        ++v47;
        v18 = v38;
        v17 = v36;
      }
      if ( v17 != -1 )
      {
LABEL_63:
        --v42;
        ++v17;
        goto LABEL_35;
      }
      goto LABEL_64;
    }
    v18 = v19 + a2 * v18;
    if ( v18 > 10000000 )
      return sub_401CE2(a1, (__int64)"third_party/duktape/duk_numconv.c", 2273, "exponent too large", a4, a5);
    ++v16;
LABEL_35:
    v13 = v41;
  }
  if ( (_DWORD)v9 != 46 )
  {
    if ( !(_DWORD)v9 )
      goto LABEL_68;
    if ( (v5 & 2) != 0 && v16 == -1 && (v9 & 0xDF) == 69 )
    {
      v20 = v13[1];
      if ( v20 == 45 )
      {
        v16 = 0;
        v40 = 1;
        v41 = v13 + 2;
      }
      else
      {
        v16 = 0;
        if ( v20 == 43 )
        {
          v10 = (__int64)(v13 + 2);
          v41 = v13 + 2;
        }
      }
      goto LABEL_35;
    }
    v8 = (unsigned int)(v9 - 97);
    v19 = v9 - 87;
    if ( (unsigned int)v8 > 0x19 )
    {
      v8 = (unsigned int)(v9 - 65);
      v19 = 255;
      if ( (unsigned int)v8 <= 0x19 )
        v19 = v9 - 55;
    }
    goto LABEL_49;
  }
  if ( v17 < 0 && v16 < 0 )
  {
    if ( (v5 & 0x40) == 0 && (v5 & 4) != 0 )
    {
      v16 = -1;
      v17 = -1;
      goto LABEL_68;
    }
    v16 = -1;
    v17 = 0;
    goto LABEL_35;
  }
LABEL_50:
  if ( (v5 & 4) == 0 )
    goto LABEL_119;
LABEL_68:
  if ( v39 > 0 && v45 > 1 )
  {
    if ( (v5 & 0x400) == 0 )
      goto LABEL_119;
LABEL_79:
    v22 = (v17 | v5 & 0x100) == 0;
    v9 = v17 | v5 & 0x100;
LABEL_80:
    if ( v22 )
      goto LABEL_119;
    goto LABEL_81;
  }
  if ( v45 )
    goto LABEL_79;
  if ( !v17 )
    goto LABEL_119;
  if ( v17 > 0 )
  {
    v22 = (v5 & 0x80u) == 0;
    goto LABEL_80;
  }
  if ( (v5 & 0x200) == 0 || *(_DWORD *)(v11 + 24) )
  {
LABEL_119:
    sub_407D7E(a1, v8, v9, v10, a4, a5);
    return sub_406B26(a1, v8, v35, a4, a5);
  }
LABEL_81:
  v10 = v16 | v5 & 4;
  if ( !(v16 | v5 & 4) )
    goto LABEL_119;
  if ( v40 )
    v18 = -v18;
  v22 = v42 + v18 == 0;
  v23 = v42 + v18;
  LOBYTE(v8) = v22;
  v24 = v23;
  v25 = v22 && v49[0] <= 1;
  if ( v25 )
  {
    v9 = (unsigned int)(v49[0] - 1);
    if ( v49[0] != 1 )
      goto LABEL_87;
    *(double *)a4.i64 = (double)v49[1];
    goto LABEL_116;
  }
  v26 = a2 - 2;
  v27 = (unsigned __int8)byte_43DA00[v26];
  while ( 1 )
  {
    v8 = (unsigned int)v47;
    v9 = (unsigned int)(v47 + v23 - v24);
    if ( v27 <= (int)v9 )
      break;
    v43 = v26;
    v46 = v23;
    --v24;
    sub_41A584(v49, a2, v50);
    v26 = v43;
    v23 = v46;
  }
  if ( !v49[0] )
    goto LABEL_87;
  if ( word_43D960[2 * v26] < v24 )
  {
LABEL_14:
    *(double *)a4.i64 = INFINITY;
    goto LABEL_116;
  }
  if ( word_43D962[2 * v26] <= v24 )
  {
    v53 = v24;
    v51 = 0x100000001LL;
    v54 = a2;
    v55 = 2;
    v52 = 54LL;
    sub_41AA14(v49);
    sub_41A5AF(v49);
    sub_41A6F9(v49);
    v48 = 0.0;
    if ( v56 - 1 > 1023 )
    {
      v28 = -255;
      v29 = 2047;
    }
    else
    {
      v28 = v56 + 1022;
      v29 = 0;
      if ( v56 - 1 >= -1022 )
      {
        v29 = v56 + 1022;
        v28 = 1;
      }
    }
    v30 = v28 + 52;
    if ( v57 > v28 + 52 && v30 >= 0 && (unsigned int)sub_41A4C6((__int64)v49, v30) )
    {
      if ( v56 - 1 > 1023 )
      {
        v28 = -255;
        v29 = 2047;
      }
      else
      {
        v28 = v56 + 1022;
        v29 = 0;
        if ( v56 - 1 >= -1022 )
        {
          v29 = v56 + 1022;
          v28 = 1;
        }
      }
    }
    LODWORD(v8) = v28 + 51;
    v31 = 0LL;
    v32 = 0;
    LODWORD(v9) = 0;
    v33 = (char *)v49 + v28;
    do
    {
      v10 = (unsigned int)v31;
      if ( (int)v8 < 0 || v57 <= (int)v8 )
        v34 = 0;
      else
        v34 = (unsigned __int8)v33[-v31 + 1159];
      v9 = (unsigned int)((v34 << v31) + v9);
      if ( v31 == 31 )
      {
        v32 = v9;
        v25 = 1;
        v9 = 0LL;
      }
      ++v31;
      v8 = (unsigned int)(v8 - 1);
    }
    while ( v31 != 52 );
    if ( v25 )
      LODWORD(v48) = v32;
    HIDWORD(v48) = v9 + (v29 << 20);
    *(double *)a4.i64 = v48;
    goto LABEL_116;
  }
LABEL_87:
  a4 = 0LL;
LABEL_116:
  if ( v44 )
    a4 = _mm_xor_ps(a4, (__m128)xmmword_43D2F0);
  sub_407D7E(a1, v8, v9, v10, a4, a5);
  return sub_406A1B(a1, a4, a5);
}
// 41B211: variable 'v28' is possibly undefined
// 41B269: variable 'v29' is possibly undefined
// 41B29A: variable 'v9' is possibly undefined
// 41B29A: variable 'v10' is possibly undefined
// 41B2BC: variable 'v35' is possibly undefined
// 43AD1A: using guessed type __int64 __fastcall sub_43AD1A(_QWORD, _QWORD);
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43D960: using guessed type __int16 word_43D960[];
// 43D962: using guessed type __int16 word_43D962[];
// 41AC55: using guessed type int var_5A0[76];

//----- (000000000041B2D3) ----------------------------------------------------
__int64 __fastcall sub_41B2D3(__int64 *a1, unsigned int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v10; // rdx
  __int64 v11; // rcx
  __m128 v12; // xmm0
  int v13; // eax
  int v14; // er15
  unsigned int v15; // esi
  int v17; // eax
  __m128 v18; // xmm0
  _BOOL4 v19; // eax
  unsigned int v20; // ecx
  int *v21; // rdi
  _BYTE *v22; // rsi
  bool v23; // cc
  __int64 v24; // rdx
  __int64 v25; // rdx
  int v26; // eax
  unsigned __int32 v27; // eax
  int v28; // esi
  int v29; // esi
  int v30; // eax
  int *v31; // rcx
  int v32; // edi
  int v33; // edx
  int v34; // er8
  int *v35; // rdx
  char v36; // dl
  _BYTE *v37; // rcx
  unsigned int v38; // er8
  int v39; // et2
  __int64 v40; // rdx
  int v41; // eax
  int v42; // [rsp+0h] [rbp-8B0h]
  int v43; // [rsp+4h] [rbp-8ACh]
  int v44[2]; // [rsp+18h] [rbp-898h] BYREF
  int v45; // [rsp+20h] [rbp-890h]
  int v46; // [rsp+440h] [rbp-470h]
  __int64 v47; // [rsp+444h] [rbp-46Ch]
  int v48; // [rsp+44Ch] [rbp-464h]
  unsigned __int32 v49; // [rsp+450h] [rbp-460h]
  int v50; // [rsp+454h] [rbp-45Ch]
  unsigned int v51; // [rsp+458h] [rbp-458h]
  int v52; // [rsp+45Ch] [rbp-454h]
  char v53[1040]; // [rsp+46Ch] [rbp-444h] BYREF
  int v54; // [rsp+87Ch] [rbp-34h]

  *(double *)a5.i64 = sub_40544E(a1, -1, a5, a6);
  sub_407D7E(a1, 0xFFFFFFFFLL, v10, v11, a5, a6);
  a6.i64[0] = a5.i64[0];
  v12 = a6;
  v13 = sub_42FB3D(*(double *)a6.i64);
  v14 = _mm_movemask_pd((__m128d)a6) & 1;
  if ( v14 )
  {
    a6 = _mm_xor_ps(a6, (__m128)xmmword_43D2F0);
    v14 = 1;
  }
  v15 = 59;
  if ( !v13 )
    return sub_407826(a1, v15, v12, a6);
  if ( v13 == 1 )
  {
    v15 = 61;
    if ( !v14 )
      v15 = 60;
    return sub_407826(a1, v15, v12, a6);
  }
  v42 = v13;
  v18 = sub_41D2F2(*(double *)a6.i64);
  *(double *)v18.i64 = (double)v17;
  v43 = v17;
  v19 = sub_41D67C((double)v17, *(double *)a6.i64);
  if ( !a4 )
  {
    v20 = v43;
    if ( v19 )
    {
      if ( v43 && v14 )
      {
        v21 = (int *)((char *)v44 + 1);
        LOBYTE(v44[0]) = 45;
      }
      else
      {
        v21 = v44;
      }
      v22 = v21 + 8;
      do
      {
        --v22;
        v23 = a2 <= v20;
        v24 = (int)(v20 % a2);
        v20 /= a2;
        *v22 = byte_43F2E0[v24];
      }
      while ( v23 );
      v25 = (char *)(v21 + 8) - v22;
      goto LABEL_68;
    }
  }
  v46 = 0;
  v50 = 2;
  v51 = a2;
  v48 = 0;
  if ( (a4 & 1) == 0 )
  {
    v47 = 0LL;
    if ( v42 == 2 )
    {
      v41 = 1;
      goto LABEL_25;
    }
LABEL_26:
    v44[1] = _mm_cvtsi128_si32((__m128i)a6);
    v44[0] = 2;
    v45 = a6.i32[1] & 0xFFFFF;
    if ( (((unsigned __int32)a6.i32[1] >> 20) & 0x7FF) != 0 )
    {
      v27 = (((unsigned __int32)a6.i32[1] >> 20) & 0x7FF) - 1075;
      v45 = a6.i32[1] & 0xFFFFF | 0x100000;
    }
    else
    {
      sub_41A342(v44);
      v27 = -1074;
    }
    v49 = v27;
    sub_41AA14(v44);
    sub_41A5AF(v44);
    sub_41A6F9(v44);
    goto LABEL_30;
  }
  LODWORD(v47) = 1;
  if ( (a4 & 8) == 0 )
  {
    v41 = a3 + 1;
    HIDWORD(v47) = a3 + 1;
    if ( v42 == 2 )
      goto LABEL_25;
    goto LABEL_26;
  }
  v48 = 1;
  HIDWORD(v47) = -a3;
  if ( v42 != 2 )
    goto LABEL_26;
  v41 = a3 + 2;
LABEL_25:
  v14 = 0;
  sub_43ABE2((__int64)v53, 0LL, v41);
  v54 = v26;
  v52 = 1;
LABEL_30:
  if ( (a4 & 1) != 0 )
  {
    v28 = a3;
    if ( (a4 & 8) != 0 )
      v28 = v52 + a3;
    if ( v28 < v54 && v28 >= 0 )
      sub_41A4C6((__int64)v44, v28);
  }
  v29 = v52;
  v30 = 0x10000;
  if ( !v48 )
  {
    if ( (a4 & 2) != 0 || (a4 & 4) != 0 && v52 - a3 > 0 || (unsigned int)(v52 + 5) > 0x1A && a2 == 10 )
    {
      v30 = v52 - 1;
      v29 = 1;
    }
    else
    {
      v30 = 0x10000;
    }
  }
  v31 = v44;
  if ( v14 )
  {
    v31 = (int *)((char *)v44 + 1);
    LOBYTE(v44[0]) = 45;
  }
  v32 = 1;
  if ( v29 > 0 )
    v32 = v29;
  if ( (_DWORD)v47 )
  {
    v33 = v29 - a3;
    if ( v48 )
      v33 = -a3;
  }
  else
  {
    v33 = v29 - v54;
  }
  v34 = 0;
  if ( v33 <= 0 )
    v34 = v33;
  while ( 1 )
  {
    v35 = (int *)((char *)v31 + 1);
    if ( v29 >= v32 && v29 - v54 < v32 )
      *(_BYTE *)v31 = byte_43F2E0[(unsigned __int8)v53[v29 - v32]];
    else
      *(_BYTE *)v31 = 48;
    if ( v34 == --v32 )
      break;
    if ( !v32 )
    {
      v35 = (int *)((char *)v31 + 2);
      *((_BYTE *)v31 + 1) = 46;
    }
    v31 = v35;
  }
  if ( v30 == 0x10000 )
    return sub_406B69(a1, (__int64)v44, (char *)v35 - (char *)v44, v18, a6);
  *((_BYTE *)v31 + 1) = 101;
  v36 = 43;
  if ( v30 < 0 )
  {
    v30 = -v30;
    v36 = 45;
  }
  *((_BYTE *)v31 + 2) = v36;
  v21 = (int *)((char *)v31 + 3);
  v37 = (char *)v31 + 35;
  v22 = v37;
  do
  {
    v38 = v30;
    --v22;
    v39 = v30 % a2;
    v30 /= a2;
    *v22 = byte_43F2E0[v39];
  }
  while ( a2 <= v38 );
  v25 = v37 - v22;
LABEL_68:
  sub_43ABC2(v21, v22, v25);
  v35 = (int *)((char *)v21 + v40);
  return sub_406B69(a1, (__int64)v44, (char *)v35 - (char *)v44, v18, a6);
}
// 41B305: variable 'v10' is possibly undefined
// 41B305: variable 'v11' is possibly undefined
// 41B388: variable 'v17' is possibly undefined
// 41B4A1: variable 'v26' is possibly undefined
// 41B68B: variable 'v40' is possibly undefined
// 41D2F2: using guessed type __m128 __fastcall sub_41D2F2(double);
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 41B2D3: using guessed type char var_444[1040];

//----- (000000000041B6BE) ----------------------------------------------------
__int64 __fastcall sub_41B6BE(__int64 *a1, unsigned int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  *(double *)a5.i64 = nullsub_1(*(double *)a5.i64, *(double *)a6.i64);
  return sub_41B2D3(a1, a2, a3, a4, a5, a6);
}
// 4205E1: using guessed type double __fastcall nullsub_1(double, double);

//----- (000000000041B6EB) ----------------------------------------------------
__int64 __fastcall sub_41B6EB(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  *(double *)a4.i64 = nullsub_1(*(double *)a4.i64, *(double *)a5.i64);
  return sub_41AC55(a1, a2, a3, a4, a5);
}
// 4205E1: using guessed type double __fastcall nullsub_1(double, double);

//----- (000000000041B712) ----------------------------------------------------
_BYTE *__fastcall sub_41B712(__int64 *a1, char a2, __m128 a3, __m128 a4)
{
  _BYTE *result; // rax

  if ( a1[213] == a1[211] )
    sub_41CFE2((__int64 *)*a1, a1 + 211, 1LL, a3, a4);
  result = (_BYTE *)a1[211];
  a1[211] = (__int64)(result + 1);
  *result = a2;
  return result;
}

//----- (000000000041B75D) ----------------------------------------------------
__int64 __fastcall sub_41B75D(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax

  if ( (unsigned __int64)(a1[213] - a1[211]) <= 6 )
    sub_41CFE2((__int64 *)*a1, a1 + 211, 7LL, a3, a4);
  result = (int)sub_41C531(a2, (_BYTE *)a1[211]);
  a1[211] += (int)result;
  return result;
}

//----- (000000000041B7AF) ----------------------------------------------------
__int64 __fastcall sub_41B7AF(__int64 *a1, unsigned int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // [rsp+Ch] [rbp-24h]
  char v7[23]; // [rsp+19h] [rbp-17h] BYREF

  v6 = sub_41C531(a3, v7);
  sub_41D130((__int64 *)*a1, a1 + 211, a2, (__int64)v7, (int)v6, a4, a5);
  return v6;
}

//----- (000000000041B7F2) ----------------------------------------------------
__int64 __fastcall sub_41B7F2(__int64 *a1, unsigned int a2, int a3, __m128 a4, __m128 a5)
{
  unsigned int v5; // er8
  int v6; // eax

  v5 = 2 * a3;
  if ( a3 < 0 )
  {
    v6 = a3 - 1;
    if ( a3 < -62 )
    {
      v6 = a3 - 2;
      if ( a3 < -1021 )
      {
        v6 = a3 - 3;
        if ( a3 < -32764 )
        {
          v6 = a3 - 4;
          if ( a3 < -1048571 )
          {
            v6 = a3 - 5;
            if ( a3 < -33554426 )
            {
              v6 = a3 - 7;
              if ( a3 >= -1073741817 )
                v6 = a3 - 6;
            }
          }
        }
      }
    }
    v5 = -2 * v6 + 1;
  }
  return sub_41B7AF(a1, a2, v5, a4, a5);
}

//----- (000000000041B84B) ----------------------------------------------------
__int64 __fastcall sub_41B84B(__int64 a1, unsigned int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  unsigned int v7; // esi
  unsigned int v8; // er14
  unsigned int v9; // er12
  int i; // esi
  unsigned int j; // eax
  unsigned int v12; // er15
  unsigned int v13; // esi
  __int64 result; // rax
  unsigned int v15; // [rsp+Ch] [rbp-34h]

  if ( !a4 && (*(_BYTE *)(a1 + 8) & 2) != 0 )
  {
    v8 = sub_41CD28(*(_QWORD *)a1, a2);
    v9 = v8;
    for ( i = a2 + 1; a3 >= i; i = v12 + 1 )
    {
      for ( j = i >> 5; ; ++j )
      {
        if ( a3 >> 5 < j || j > 0x7FF )
        {
          v12 = a3;
          goto LABEL_14;
        }
        if ( ((unsigned __int8)(1 << (j & 7)) & (unsigned __int8)byte_43DDE0[j >> 3]) == 0 )
          break;
      }
      v12 = i;
      if ( i >> 5 < j )
        v12 = 32 * j;
LABEL_14:
      v15 = v8 + v12 - i;
      v8 = sub_41CD28(*(_QWORD *)a1, v12);
      if ( v8 != v15 + 1 )
      {
        v13 = v9;
        v9 = v8;
        sub_41B75D((__int64 *)a1, v13, a5, a6);
        sub_41B75D((__int64 *)a1, v15, a5, a6);
        ++*(_DWORD *)(a1 + 1736);
      }
    }
    sub_41B75D((__int64 *)a1, v9, a5, a6);
    v7 = v8;
  }
  else
  {
    sub_41B75D((__int64 *)a1, a2, a5, a6);
    v7 = a3;
  }
  result = sub_41B75D((__int64 *)a1, v7, a5, a6);
  ++*(_DWORD *)(a1 + 1736);
  return result;
}

//----- (000000000041B95F) ----------------------------------------------------
int *__fastcall sub_41B95F(__int64 a1, int a2, int *a3, __m128 a4, __m128 a5)
{
  unsigned int v5; // eax
  const char *v6; // rcx
  int v7; // edx
  int v8; // er12
  int v9; // er15
  signed int v10; // er14
  int v11; // edx
  int v12; // eax
  const char *v13; // rcx
  unsigned int v14; // edx
  unsigned int v15; // er13
  unsigned int v16; // er8
  int v17; // er12
  unsigned int v18; // er14
  unsigned int v19; // er14
  int v20; // eax
  unsigned int v21; // edx
  unsigned int v22; // er14
  unsigned int v23; // er14
  int v24; // eax
  int v25; // edx
  unsigned int v26; // esi
  int *result; // rax
  int v28; // eax
  int v29; // er13
  unsigned int v30; // er12
  char v31; // si
  unsigned int v32; // edx
  char v33; // si
  __int64 v34; // r12
  unsigned int v35; // er13
  unsigned int v36; // esi
  __int64 v37; // rax
  int v38; // er13
  unsigned __int16 *v39; // r15
  char v40; // si
  unsigned __int16 *v41; // r13
  unsigned int v42; // esi
  unsigned int v43; // er13
  unsigned int v44; // esi
  unsigned int v45; // er13
  __int64 v46; // r13
  __int64 v47; // r13
  int v48; // eax
  int v51; // [rsp+18h] [rbp-68h]
  __int64 v52; // [rsp+18h] [rbp-68h]
  int **v53; // [rsp+20h] [rbp-60h]
  int v54; // [rsp+28h] [rbp-58h]
  unsigned int v55; // [rsp+28h] [rbp-58h]
  __int64 *v56; // [rsp+28h] [rbp-58h]
  unsigned int v57; // [rsp+30h] [rbp-50h]
  int v58; // [rsp+34h] [rbp-4Ch]
  unsigned int v59; // [rsp+38h] [rbp-48h]
  signed int v60; // [rsp+3Ch] [rbp-44h]
  int v61[13]; // [rsp+4Ch] [rbp-34h] BYREF

  v54 = *(_DWORD *)(a1 + 1720);
  v57 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
  *(double *)a4.i64 = nullsub_1(*(double *)a4.i64, *(double *)a5.i64);
  v5 = *(_DWORD *)(a1 + 1728);
  if ( v5 >= *(_DWORD *)(a1 + 1732) )
  {
    v6 = byte_43DA30;
    v7 = 527;
    return (int *)sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_regexp_compiler.c", v7, v6, a4, a5);
  }
  v8 = 0;
  v60 = -1;
  *(_DWORD *)(a1 + 1728) = v5 + 1;
  v59 = -1;
  v9 = 0;
  v10 = -1;
  v53 = (int **)(a1 + 16);
  while ( 2 )
  {
    sub_419B9C(v53, a1 + 1664, a4, a5);
    v11 = *(_DWORD *)(a1 + 1664);
    v58 = *(_DWORD *)(a1 + 1720);
    switch ( v11 )
    {
      case 0:
        if ( a2 )
          goto LABEL_80;
        v13 = "unexpected end of pattern";
        v14 = 83887025;
        return (int *)sub_401C42(
                        *(__int64 **)a1,
                        (__int64)"third_party/duktape/duk_regexp_compiler.c",
                        v14,
                        v13,
                        a4,
                        a5);
      case 1:
        if ( v60 >= 0 )
        {
          v12 = sub_41B7F2((__int64 *)a1, v60, *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - v60, a4, a5);
          sub_41B7F2((__int64 *)a1, v59, v60 + v12 - v59, a4, a5);
        }
        sub_41B7AF((__int64 *)a1, v57, 7u, a4, a5);
        v59 = v57 + 1;
        sub_41B712((__int64 *)a1, 6, a4, a5);
        v60 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        goto LABEL_49;
      case 2:
        if ( v10 < 0 )
        {
          v13 = "quantifier without preceding atom";
          v14 = 83886681;
          return (int *)sub_401C42(
                          *(__int64 **)a1,
                          (__int64)"third_party/duktape/duk_regexp_compiler.c",
                          v14,
                          v13,
                          a4,
                          a5);
        }
        v15 = *(_DWORD *)(a1 + 1676);
        v16 = *(_DWORD *)(a1 + 1680);
        if ( v15 > v16 )
        {
          v13 = "quantifier values invalid (qmin > qmax)";
          v14 = 83886685;
          return (int *)sub_401C42(
                          *(__int64 **)a1,
                          (__int64)"third_party/duktape/duk_regexp_compiler.c",
                          v14,
                          v13,
                          a4,
                          a5);
        }
        if ( v9 >= 0 )
        {
          if ( !v9 )
          {
            v15 = v15 != 0;
            v16 = v16 != 0;
          }
          v55 = v16;
          sub_41B712((__int64 *)a1, 1, a4, a5);
          v17 = *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - v10;
          if ( *(_DWORD *)(a1 + 1668) )
          {
            v18 = sub_41B7AF((__int64 *)a1, v10, 0xAu, a4, a5) + v10;
            v19 = sub_41B7AF((__int64 *)a1, v18, v15, a4, a5) + v18;
            v20 = sub_41B7AF((__int64 *)a1, v19, v55, a4, a5);
            v21 = v9;
            v22 = v20 + v19;
          }
          else
          {
            v23 = sub_41B7AF((__int64 *)a1, v10, 9u, a4, a5) + v10;
            v22 = sub_41B7AF((__int64 *)a1, v23, v15, a4, a5) + v23;
            v21 = v55;
          }
          v24 = sub_41B7AF((__int64 *)a1, v22, v21, a4, a5);
          v25 = v17;
          v26 = v22 + v24;
LABEL_48:
          sub_41B7F2((__int64 *)a1, v26, v25, a4, a5);
          goto LABEL_49;
        }
        if ( v16 != -1 )
          v15 = *(_DWORD *)(a1 + 1680);
        if ( v15 <= 0x3E8 )
        {
          if ( v58 != v54 )
          {
            sub_41B7AF((__int64 *)a1, v10, 2 * (v58 - v54), a4, a5);
            sub_41B7AF((__int64 *)a1, v10, 2 * v54 + 2, a4, a5);
            sub_41B7AF((__int64 *)a1, v10, 0xCu, a4, a5);
          }
          v28 = *(_DWORD *)(a1 + 1676);
          v29 = *(_DWORD *)(a1 + 1680);
          v30 = *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - v10;
          while ( 1 )
          {
            v56 = (__int64 *)(a1 + 1688);
            if ( !v28 )
              break;
            v51 = v28;
            sub_41D0AD(*(__int64 **)a1, v56, v10, v30, a4, a5);
            v28 = v51 - 1;
            if ( v29 != -1 )
              --v29;
          }
          if ( v29 == -1 )
          {
            if ( !*(_DWORD *)(a1 + 1676) )
            {
              sub_41B712((__int64 *)a1, 6, a4, a5);
              sub_41B7F2((__int64 *)a1, *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696), v30, a4, a5);
              sub_41D0AD(*(__int64 **)a1, (__int64 *)(a1 + 1688), v10, v30, a4, a5);
            }
            v31 = 8;
            if ( !*(_DWORD *)(a1 + 1668) )
              v31 = 7;
            sub_41B712((__int64 *)a1, v31, a4, a5);
            sub_41B7F2((__int64 *)a1, *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696), ~v30, a4, a5);
          }
          else
          {
            v52 = *(_QWORD *)(a1 + 1688) - *(_QWORD *)(a1 + 1696);
            while ( v29 )
            {
              sub_41D1C8(*(__int64 **)a1, v56, (unsigned int)v52, v10, v30, a4, a5);
              v32 = 7;
              if ( !*(_DWORD *)(a1 + 1668) )
                v32 = 8;
              --v29;
              sub_41B7AF((__int64 *)a1, v52, v32, a4, a5);
              sub_41B7F2((__int64 *)a1, v52 + 1, *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - 1 - v52, a4, a5);
            }
          }
          sub_41D282(*(_QWORD *)a1, v56, v10, v30);
LABEL_49:
          v8 = -1;
LABEL_50:
          v9 = -1;
          v10 = -1;
LABEL_51:
          v54 = v58;
          continue;
        }
        v6 = "quantifier requires too many atom copies";
        v7 = 674;
        return (int *)sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_regexp_compiler.c", v7, v6, a4, a5);
      case 3:
        v33 = 16;
        goto LABEL_46;
      case 4:
        v33 = 17;
        goto LABEL_46;
      case 5:
        v33 = 18;
        goto LABEL_46;
      case 6:
        v33 = 19;
LABEL_46:
        sub_41B712((__int64 *)a1, v33, a4, a5);
        goto LABEL_50;
      case 7:
      case 8:
        v34 = *(_QWORD *)(a1 + 1688) - *(_QWORD *)(a1 + 1696);
        v35 = (v11 != 7) + 13;
        sub_41B95F(a1, 0, v61, a4, a5);
        sub_41B712((__int64 *)a1, 1, a4, a5);
        sub_41B7AF((__int64 *)a1, v34, v35, a4, a5);
        v26 = v34 + 1;
        v25 = *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - 1 - v34;
        goto LABEL_48;
      case 9:
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        sub_41B712((__int64 *)a1, 3, a4, a5);
        goto LABEL_77;
      case 10:
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        sub_41B712((__int64 *)a1, 2, a4, a5);
        v36 = *(_DWORD *)(a1 + 1672);
        if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
          v36 = sub_41CD28(*(_QWORD *)a1, v36);
        sub_41B75D((__int64 *)a1, v36, a4, a5);
        goto LABEL_77;
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
        v37 = (unsigned int)(v11 - 11) >> 1;
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        v38 = (unsigned __int8)byte_43DB74[v37];
        v39 = (unsigned __int16 *)*((_QWORD *)&off_43DC40 + v37);
        sub_41B712((__int64 *)a1, 5 - (v11 & 1), a4, a5);
        v40 = v38;
        v41 = &v39[2 * v38];
        sub_41B712((__int64 *)a1, v40, a4, a5);
        while ( v39 != v41 )
        {
          v42 = *v39++;
          sub_41B75D((__int64 *)a1, v42, a4, a5);
        }
        goto LABEL_77;
      case 17:
        v43 = *(_DWORD *)(a1 + 1672);
        if ( v43 > *(_DWORD *)(a1 + 1724) )
          *(_DWORD *)(a1 + 1724) = v43;
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        sub_41B712((__int64 *)a1, 15, a4, a5);
        v44 = v43;
        goto LABEL_63;
      case 18:
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        *(_DWORD *)(a1 + 1720) = v58 + 1;
        v45 = 2 * (v58 + 1);
        sub_41B712((__int64 *)a1, 11, a4, a5);
        sub_41B75D((__int64 *)a1, v45, a4, a5);
        sub_41B95F(a1, 0, v61, a4, a5);
        sub_41B712((__int64 *)a1, 11, a4, a5);
        v44 = v45 + 1;
LABEL_63:
        sub_41B75D((__int64 *)a1, v44, a4, a5);
        if ( v10 >= 0 )
          v8 = -1;
        v9 = -1;
        goto LABEL_51;
      case 19:
        v46 = *(_QWORD *)(a1 + 1688) - *(_QWORD *)(a1 + 1696);
        sub_41B95F(a1, 0, v61, a4, a5);
        v9 = v61[0];
        v10 = v46;
        if ( (int)v46 < 0 )
          goto LABEL_51;
        if ( v61[0] >= 0 )
        {
LABEL_78:
          if ( v8 != -1 )
            v8 += v9;
        }
        else
        {
          v8 = -1;
        }
        goto LABEL_51;
      case 20:
      case 21:
        v10 = *(_QWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696);
        sub_41B712((__int64 *)a1, (v11 != 20) + 4, a4, a5);
        v47 = *(_QWORD *)(a1 + 1688) - *(_QWORD *)(a1 + 1696);
        *(_DWORD *)(a1 + 1736) = 0;
        sub_41A06B(
          (unsigned int **)v53,
          (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))sub_41B84B,
          a1,
          a4,
          a5);
        sub_41B7AF((__int64 *)a1, v47, *(_DWORD *)(a1 + 1736), a4, a5);
LABEL_77:
        v9 = 1;
        if ( v10 >= 0 )
          goto LABEL_78;
        goto LABEL_51;
      case 22:
        if ( a2 )
        {
          v13 = "unexpected closing parenthesis";
          v14 = 83887018;
          return (int *)sub_401C42(
                          *(__int64 **)a1,
                          (__int64)"third_party/duktape/duk_regexp_compiler.c",
                          v14,
                          v13,
                          a4,
                          a5);
        }
LABEL_80:
        if ( v60 >= 0 )
        {
          v48 = sub_41B7F2((__int64 *)a1, v60, *(_DWORD *)(a1 + 1688) - *(_DWORD *)(a1 + 1696) - v60, a4, a5);
          sub_41B7F2((__int64 *)a1, v59, v60 + v48 - v59, a4, a5);
        }
        result = a3;
        *a3 = v8;
        --*(_DWORD *)(a1 + 1728);
        return result;
      default:
        v13 = "unexpected token in regexp";
        v14 = 83887031;
        return (int *)sub_401C42(
                        *(__int64 **)a1,
                        (__int64)"third_party/duktape/duk_regexp_compiler.c",
                        v14,
                        v13,
                        a4,
                        a5);
    }
  }
}
// 4205E1: using guessed type double __fastcall nullsub_1(double, double);

//----- (000000000041C0B4) ----------------------------------------------------
void __fastcall sub_41C0B4(__int64 *a1, __m128 a2, __m128 a3)
{
  const signed __int32 *v3; // r14
  const signed __int32 *v4; // rbx
  __int64 v5; // rax
  __int64 v6; // r15
  _BYTE *v7; // rax
  char v8; // r8
  _BYTE *v9; // rdx
  __int64 v10; // rcx
  char *v11; // rdx
  __int64 v12; // rax
  char *v13; // rcx
  unsigned int v14; // eax
  char v15; // si
  char v16; // [rsp+6h] [rbp-72Ah]
  char v17; // [rsp+7h] [rbp-729h]
  unsigned __int64 v18; // [rsp+8h] [rbp-728h]
  unsigned __int64 v19; // [rsp+8h] [rbp-728h]
  int v20; // [rsp+1Ch] [rbp-714h] BYREF
  __int64 v21; // [rsp+20h] [rbp-710h] BYREF
  int v22; // [rsp+28h] [rbp-708h]
  __int64 *v23; // [rsp+30h] [rbp-700h] BYREF
  unsigned int v24; // [rsp+38h] [rbp-6F8h]
  __int64 v25[204]; // [rsp+40h] [rbp-6F0h] BYREF
  int v26; // [rsp+6A4h] [rbp-8Ch]
  __int64 v27[4]; // [rsp+6C8h] [rbp-68h] BYREF
  unsigned int v28; // [rsp+6E8h] [rbp-48h]
  unsigned int v29; // [rsp+6ECh] [rbp-44h]
  int v30; // [rsp+6F4h] [rbp-3Ch]

  v3 = sub_4057BB(a1, -2, a2, a3);
  v4 = sub_4057BB(a1, -1, a2, a3);
  v5 = sub_405B3C((__int64)a1, -2);
  if ( *(_DWORD *)(v5 + 24) )
  {
    v6 = v5;
    v18 = *(unsigned int *)(v5 + 24);
    sub_41CF97(a1, &v23, v18, a2, a3);
    v7 = v23;
    v8 = 0;
    v19 = v6 + v18;
    do
    {
      v17 = v8;
      v8 = *(_BYTE *)(v6 + 32);
      if ( v25[0] - (__int64)v7 <= 1uLL )
      {
        v16 = *(_BYTE *)(v6 + 32);
        v23 = (__int64 *)v7;
        v7 = (_BYTE *)sub_41CFE2(a1, &v23, 2LL, a2, a3);
        v8 = v16;
      }
      if ( v8 != 47 || v17 == 92 )
      {
        v9 = v7;
      }
      else
      {
        v9 = v7 + 1;
        *v7 = 92;
      }
      ++v6;
      v7 = v9 + 1;
      *v9 = v8;
    }
    while ( v19 != v6 );
    v23 = (__int64 *)(v9 + 1);
    sub_41D054(a1, &v23, a2, a3);
    sub_406BF4(a1, -1, a2, a3);
  }
  else
  {
    sub_406EC3(a1, (__int64)"(?:)", 4uLL, a2, a3);
  }
  sub_43ABE2((__int64)&v23, 0LL, 0x6D0uLL);
  sub_418FA3((__int64)v25);
  v10 = *((unsigned int *)v4 + 6);
  v11 = (char *)(v4 + 8);
  v23 = a1;
  v25[193] = (__int64)a1;
  v25[194] = (__int64)(v3 + 8);
  v12 = *((unsigned int *)v3 + 6);
  v26 = 100000000;
  v30 = 10000;
  v13 = (char *)v4 + v10 + 32;
  v25[195] = v12;
  v14 = 0;
  while ( v13 > v11 )
  {
    v15 = *v11;
    if ( *v11 == 105 )
    {
      if ( (v14 & 2) != 0 )
        goto LABEL_24;
      v14 |= 2u;
    }
    else if ( v15 == 109 )
    {
      if ( (v14 & 4) != 0 )
        goto LABEL_24;
      v14 |= 4u;
    }
    else
    {
      if ( v15 != 103 || (v14 & 1) != 0 )
      {
LABEL_24:
        sub_401C42(a1, (__int64)"third_party/duktape/duk_regexp_compiler.c", 0x5000416u, "invalid regexp flags", a2, a3);
        v14 = 0;
        break;
      }
      v14 |= 1u;
    }
    ++v11;
  }
  v24 = v14;
  sub_41CF97(a1, v27, 0x40uLL, a2, a3);
  v21 = 0LL;
  v22 = 1;
  sub_418FC1((__int64)v25, (__int64)&v21, a2, a3);
  sub_41B712((__int64 *)&v23, 11, a2, a3);
  sub_41B712((__int64 *)&v23, 0, a2, a3);
  sub_41B95F((__int64)&v23, 1, &v20, a2, a3);
  sub_41B712((__int64 *)&v23, 11, a2, a3);
  sub_41B712((__int64 *)&v23, 1, a2, a3);
  sub_41B712((__int64 *)&v23, 1, a2, a3);
  if ( v29 <= v28 )
  {
    sub_41B7AF((__int64 *)&v23, 0, 2 * v28 + 2, a2, a3);
    sub_41B7AF((__int64 *)&v23, 0, v24, a2, a3);
    sub_41D054(a1, v27, a2, a3);
    sub_406BF4(a1, -1, a2, a3);
    sub_40511F(a1, -4, a2, a3);
    sub_40511F(a1, -3, a2, a3);
  }
  else
  {
    sub_401C42(a1, (__int64)"third_party/duktape/duk_regexp_compiler.c", 0x50004BAu, "invalid backreference(s)", a2, a3);
  }
}
// 41C0B4: using guessed type _QWORD var_68[4];

//----- (000000000041C395) ----------------------------------------------------
__int64 __fastcall sub_41C395(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // r13
  __int64 v4; // rdx
  __int64 v5; // rcx

  sub_407095(a1, a2, a3);
  v3 = (_DWORD *)sub_405B41((__int64)a1, -1);
  sub_40500F(a1, -3);
  v4 = a1[38];
  *v3 = *v3 & 0x7FFFFFF | 0x58000000;
  sub_40DCFB((__int64)a1, (__int64)v3, v4, v5, a2, a3);
  sub_403E13(a1, -50306560, a2, a3);
  sub_403E13(a1, -33528576, a2, a3);
  sub_406A68(a1, 0, a2, a3);
  return sub_403E13(a1, -33542399, a2, a3);
}
// 41C3E0: variable 'v5' is possibly undefined

//----- (000000000041C41B) ----------------------------------------------------
__int64 __fastcall sub_41C41B(__int64 *a1)
{
  __int64 result; // rax
  unsigned int v2; // eax

  result = sub_41CDA5(a1, 4);
  if ( (unsigned int)result > 0xE )
  {
    v2 = sub_41CDA5(a1, 8);
    if ( v2 > 0xFD )
    {
      if ( v2 == 254 )
        return (unsigned int)sub_41CDA5(a1, 12) + 269;
      else
        return (unsigned int)sub_41CDA5(a1, 24) + 4365;
    }
    else
    {
      return v2 + 15;
    }
  }
  return result;
}

//----- (000000000041C47F) ----------------------------------------------------
__int64 __fastcall sub_41C47F(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rcx
  int v5; // er13
  char *v7; // rdi
  unsigned int v8; // er12
  int v9; // er12
  __int64 v11; // [rsp+0h] [rbp-40h] BYREF
  char v12; // [rsp+8h] [rbp-38h] BYREF
  __int64 v13; // [rsp+10h] [rbp-30h]

  v4 = 6LL;
  v5 = 0;
  v7 = &v12;
  v11 = a1;
  while ( v4 )
  {
    *(_DWORD *)v7 = 0;
    v7 += 4;
    --v4;
  }
  v13 = a2;
  while ( 1 )
  {
    v8 = sub_41C41B(&v11);
    if ( !v8 )
      break;
    v9 = v5 + v8;
    v5 = sub_41C41B(&v11) + v9;
    if ( v9 <= a3 && v5 >= a3 )
      return 1;
  }
  return v8;
}

//----- (000000000041C4EA) ----------------------------------------------------
__int64 __fastcall sub_41C4EA(unsigned int a1)
{
  __int64 result; // rax

  result = 1LL;
  if ( a1 > 0x7F )
  {
    result = 2LL;
    if ( a1 > 0x7FF )
    {
      result = 3LL;
      if ( a1 > 0xFFFF )
      {
        result = 4LL;
        if ( a1 > 0x1FFFFF )
        {
          result = 5LL;
          if ( a1 > 0x3FFFFFF )
            return (a1 >> 31) + 6;
        }
      }
    }
  }
  return result;
}

//----- (000000000041C531) ----------------------------------------------------
__int64 __fastcall sub_41C531(unsigned int a1, _BYTE *a2)
{
  __int64 result; // rax
  char v3; // cl
  __int64 i; // rdx
  char v5; // r8

  result = sub_41C4EA(a1);
  v3 = byte_43DD30[(int)result - 1];
  for ( i = (int)result; ; a2[i] = (v5 & 0x3F) + 0x80 )
  {
    --i;
    v5 = a1;
    if ( (int)i <= 0 )
      break;
    a1 >>= 6;
  }
  *a2 = v3 + a1;
  return result;
}

//----- (000000000041C56C) ----------------------------------------------------
__int64 __fastcall sub_41C56C(_BYTE **a1, unsigned int a2, __int64 *a3)
{
  int v3; // er14
  int v6; // er15
  int v7; // eax
  signed int v8; // esi
  int v9; // er14
  int v10; // er15
  unsigned int v11; // eax
  int i; // er14
  int v13; // er15
  unsigned int v14; // eax
  signed int v16; // [rsp+8h] [rbp-38h]
  int v17; // [rsp+Ch] [rbp-34h]
  int v18; // [rsp+Ch] [rbp-34h]

  v3 = 0;
  while ( 1 )
  {
    ++v3;
    v6 = sub_41CDA5(a3, 6);
    if ( v6 == 63 )
      break;
    while ( v6 )
    {
      v16 = sub_41CDA5(a3, 16);
      v17 = sub_41CDA5(a3, 16);
      v7 = sub_41CDA5(a3, 7);
      if ( v16 <= (int)a2 )
      {
        v8 = a2 - v16;
        if ( (int)(a2 - v16) < v3 * v7 && !(v8 % v3) )
        {
          a2 = v8 + v17;
          goto LABEL_23;
        }
      }
      --v6;
    }
  }
  v9 = sub_41CDA5(a3, 7);
  while ( v9 )
  {
    --v9;
    v10 = sub_41CDA5(a3, 16);
    v11 = sub_41CDA5(a3, 16);
    if ( a2 == v10 )
    {
      a2 = v11;
      goto LABEL_23;
    }
  }
  for ( i = sub_41CDA5(a3, 7); i; --i )
  {
    v18 = sub_41CDA5(a3, 16);
    v13 = sub_41CDA5(a3, 2);
    if ( a2 == v18 )
    {
      if ( a1 )
      {
        while ( --v13 != -1 )
        {
          v14 = sub_41CDA5(a3, 16);
          *a1 += (int)sub_41C531(v14, *a1);
        }
      }
      return (unsigned int)-1;
    }
    while ( --v13 != -1 )
      sub_41CDA5(a3, 16);
  }
LABEL_23:
  if ( a1 )
    *a1 += (int)sub_41C531(a2, *a1);
  return a2;
}

//----- (000000000041C6FA) ----------------------------------------------------
__int64 __fastcall sub_41C6FA(unsigned int a1, _BYTE *a2)
{
  unsigned int v3; // edi

  if ( a1 > 0x7F )
  {
    if ( a1 > 0x7FF )
    {
      if ( a1 > 0xFFFF )
      {
        v3 = a1 - 0x10000;
        *a2 = -19;
        a2[3] = -19;
        a2[1] = (BYTE2(v3) & 0xF) - 96;
        a2[2] = ((v3 >> 10) & 0x3F) + 0x80;
        a2[5] = (v3 & 0x3F) + 0x80;
        a2[4] = ((v3 >> 6) & 0xF) - 80;
        return 6LL;
      }
      else
      {
        *a2 = (a1 >> 12) - 32;
        a2[2] = (a1 & 0x3F) + 0x80;
        a2[1] = ((a1 >> 6) & 0x3F) + 0x80;
        return 3LL;
      }
    }
    else
    {
      a2[1] = (a1 & 0x3F) + 0x80;
      *a2 = (a1 >> 6) - 64;
      return 2LL;
    }
  }
  else
  {
    *a2 = a1;
    return 1LL;
  }
}

//----- (000000000041C7A1) ----------------------------------------------------
__int64 __fastcall sub_41C7A1(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4, int *a5)
{
  unsigned __int8 *v5; // rdi
  int v6; // eax
  __int64 v7; // rdx
  unsigned int v8; // er9
  unsigned __int64 v9; // r10
  __int64 i; // rcx
  unsigned __int8 v11; // r9

  v5 = (unsigned __int8 *)*a2;
  if ( *a2 < a3 || (unsigned __int64)v5 >= a4 )
    return 0;
  v6 = *v5;
  v7 = 0LL;
  if ( (v6 & 0x80u) != 0 )
  {
    v8 = 0;
    if ( (unsigned __int8)v6 <= 0xBFu )
      return v8;
    if ( (unsigned __int8)v6 > 0xDFu )
    {
      if ( (unsigned __int8)v6 > 0xEFu )
      {
        if ( (unsigned __int8)v6 > 0xF7u )
        {
          if ( (unsigned __int8)v6 > 0xFBu )
          {
            if ( (unsigned __int8)v6 > 0xFDu )
            {
              v8 = 0;
              if ( (_BYTE)v6 == 0xFF )
                return v8;
              v7 = 6LL;
              v6 = 0;
            }
            else
            {
              v6 &= 1u;
              v7 = 5LL;
            }
          }
          else
          {
            v6 &= 3u;
            v7 = 4LL;
          }
        }
        else
        {
          v6 &= 7u;
          v7 = 3LL;
        }
      }
      else
      {
        v6 &= 0xFu;
        v7 = 2LL;
      }
    }
    else
    {
      v6 &= 0x1Fu;
      v7 = 1LL;
    }
  }
  v9 = (unsigned __int64)&v5[v7 + 1];
  v8 = 0;
  if ( a4 >= v9 )
  {
    for ( i = 0LL; v7 != i; ++i )
    {
      v11 = v5[i + 1];
      v6 = (v11 & 0x3F) + (v6 << 6);
    }
    *a2 = v9;
    v8 = 1;
    *a5 = v6;
  }
  return v8;
}

//----- (000000000041C85D) ----------------------------------------------------
__int64 __fastcall sub_41C85D(
        __int64 *a1,
        unsigned __int64 *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __m128 a5,
        __m128 a6)
{
  unsigned int v7; // [rsp+1Ch] [rbp-4h] BYREF

  if ( (unsigned int)sub_41C7A1((__int64)a1, a2, a3, a4, (int *)&v7) )
    return v7;
  sub_401CB7(a1, (__int64)"third_party/duktape/duk_unicode_support.c", 282, a5, a6);
  return 0LL;
}

//----- (000000000041C892) ----------------------------------------------------
__int64 __fastcall sub_41C892(_BYTE *a1, unsigned __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdx
  _BYTE *v5; // r8
  unsigned __int64 v6; // rax
  _BYTE *v7; // rsi
  unsigned int v8; // ecx
  __int64 v9; // rdx

  v4 = 0LL;
  v5 = &a1[a2];
  v6 = a2;
  if ( a2 > 0xF )
  {
    while ( ((unsigned __int8)a1 & 3) != 0 )
    {
      LOBYTE(a2) = *a1++;
      a4 = a2 - 128;
      v4 += (unsigned __int8)(a2 + 0x80) < 0x40u;
    }
    v7 = &a1[(v5 - a1) & 0xFFFFFFFFFFFFFFFCLL];
    while ( a1 != v7 )
    {
      a4 = *(_DWORD *)a1;
      a1 += 4;
      if ( (a4 & 0x80808080) != 0 )
      {
        v8 = a4 ^ 0x80808080;
        v9 = ((v8 & 0xC000) == 0) + ((v8 & 0xC00000) == 0) + ((v8 & 0xC0000000) == 0) + v4;
        a4 = v8 & 0xC0;
        v4 = (a4 == 0) + v9;
      }
    }
  }
  while ( a1 != v5 )
  {
    LOBYTE(a4) = *a1++;
    a4 -= 128;
    v4 += (unsigned __int8)a4 < 0x40u;
  }
  return v6 - v4;
}

//----- (000000000041C942) ----------------------------------------------------
__int64 __fastcall sub_41C942(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rdx
  unsigned __int64 v3; // rcx
  char v4; // al
  unsigned int v5; // eax
  unsigned int v6; // er9
  unsigned __int64 v7; // rdx

  for ( i = 0LL;
        i < (a2 & 0xFFFFFFFFFFFFFFFCLL)
     && ((*(_BYTE *)(a1 + i + 3) | *(_BYTE *)(a1 + i + 2) | *(_BYTE *)(a1 + i + 1) | *(_BYTE *)(a1 + i)) & 0x80u) == 0;
        i += 4LL )
  {
    ;
  }
LABEL_17:
  v3 = i;
  do
  {
    if ( v3 >= a2 )
      return 1LL;
    ++v3;
    v4 = *(_BYTE *)(a1 + v3 - 1);
  }
  while ( v4 >= 0 );
  if ( (unsigned __int8)v4 > 0xDFu )
  {
    if ( (unsigned __int8)v4 > 0xEFu )
    {
      if ( (unsigned __int8)v4 > 0xF7u )
        return 0LL;
      v5 = v4 & 7;
      v6 = 0x10000;
      v7 = 3LL;
    }
    else
    {
      v5 = v4 & 0xF;
      v6 = 2048;
      v7 = 2LL;
    }
LABEL_10:
    if ( v7 <= a2 - v3 )
    {
      i = v3 + v7;
      while ( 1 )
      {
        ++v3;
        if ( (*(_BYTE *)(a1 + v3 - 1) & 0xC0) != 0x80 )
          break;
        v5 = (*(_BYTE *)(a1 + v3 - 1) & 0x3F) + (v5 << 6);
        if ( i == v3 )
        {
          if ( v6 > v5 || v5 > 0x10FFFF || v5 - 55296 <= 0x7FF )
            return 0LL;
          goto LABEL_17;
        }
      }
    }
    return 0LL;
  }
  if ( (unsigned __int8)v4 > 0xBFu )
  {
    v5 = v4 & 0x1F;
    v6 = 128;
    v7 = 1LL;
    goto LABEL_10;
  }
  return 0LL;
}

//----- (000000000041CA19) ----------------------------------------------------
__int64 __fastcall sub_41CA19(int a1)
{
  __int64 result; // rax
  bool v2; // al
  bool v3; // zf

  if ( a1 >> 8 )
  {
    if ( a1 >> 8 == 32 )
    {
      v2 = (_BYTE)a1 == 47 || (unsigned __int8)a1 <= 0xAu;
      v3 = (_BYTE)a1 == 95;
    }
    else
    {
      if ( a1 == 5760 || a1 == 6158 )
        return 1LL;
      v2 = a1 == 12288;
      v3 = a1 == 65279;
    }
    LOBYTE(result) = v3 || v2;
    return (unsigned __int8)result;
  }
  if ( (unsigned __int8)(a1 - 11) > 1u && (_BYTE)a1 != 9 )
  {
    LOBYTE(result) = (a1 & 0x7F) == 32;
    return (unsigned __int8)result;
  }
  return 1LL;
}

//----- (000000000041CA82) ----------------------------------------------------
_BOOL8 __fastcall sub_41CA82(int a1)
{
  return a1 == 10 || a1 == 13 || (unsigned int)(a1 - 8232) <= 1;
}

//----- (000000000041CAA1) ----------------------------------------------------
_BOOL8 __fastcall sub_41CAA1(int a1)
{
  _BOOL8 result; // rax

  if ( a1 > 127 )
    return (unsigned int)sub_41C47F((__int64)qword_43E9E0, 1116LL, a1) != 0;
  result = 0LL;
  if ( a1 >= 0 )
    return byte_43DD40[a1] > 0;
  return result;
}
// 43E9E0: using guessed type __int64 qword_43E9E0[140];

//----- (000000000041CADA) ----------------------------------------------------
_BOOL8 __fastcall sub_41CADA(int a1)
{
  _BOOL8 result; // rax

  if ( a1 > 127 )
  {
    if ( (unsigned int)sub_41C47F((__int64)qword_43E9E0, 1116LL, a1) )
      return 1LL;
    return (unsigned int)sub_41C47F((__int64)sub_43E760, 576LL, a1) != 0;
  }
  else
  {
    result = 0LL;
    if ( a1 >= 0 && byte_43DD40[a1] )
      return 1LL;
  }
  return result;
}
// 43E760: using guessed type __int64 __fastcall sub_43E760();
// 43E9E0: using guessed type __int64 qword_43E9E0[140];

//----- (000000000041CB38) ----------------------------------------------------
__int64 __fastcall sub_41CB38(int a1)
{
  __int64 result; // rax

  if ( a1 > 127 )
  {
    result = sub_41C47F((__int64)qword_43E9E0, 1116LL, a1);
    if ( !(_DWORD)result )
      return result;
    LOBYTE(result) = (unsigned int)sub_41C47F((__int64)qword_43E9A0, 42LL, a1) == 0;
  }
  else
  {
    LOBYTE(result) = (a1 & 0xFFFFFFDF) - 65 <= 0x19;
  }
  return (unsigned __int8)result;
}
// 43E9A0: using guessed type __int64 qword_43E9A0[8];
// 43E9E0: using guessed type __int64 qword_43E9E0[140];

//----- (000000000041CB8C) ----------------------------------------------------
void __fastcall sub_41CB8C(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rbx
  unsigned __int64 v6; // r15
  __int64 v7; // rax
  signed int v8; // ebx
  int v9; // er13
  char v10; // al
  _BYTE *v11; // rdx
  int v12; // eax
  __int64 *v13; // rdi
  __int64 i; // rcx
  unsigned __int64 v15; // [rsp+0h] [rbp-90h]
  int v16; // [rsp+Ch] [rbp-84h]
  unsigned __int64 v17; // [rsp+18h] [rbp-78h] BYREF
  _BYTE *v18[4]; // [rsp+20h] [rbp-70h] BYREF
  __int64 v19[2]; // [rsp+40h] [rbp-50h] BYREF
  __int64 v20; // [rsp+50h] [rbp-40h]

  v5 = sub_40574F(a1, -1, a3, a4);
  v6 = v5 + 32;
  sub_41CF97(a1, v18, *(unsigned int *)(v5 + 24), a3, a4);
  v7 = *(unsigned int *)(v5 + 24);
  v17 = v6;
  v8 = -1;
  v16 = -1;
  v15 = v6 + v7;
  while ( 1 )
  {
    if ( v17 < v15 )
    {
      v9 = sub_41C85D(a1, &v17, v6, v15, a3, a4);
      if ( v8 < 0 )
        goto LABEL_4;
      goto LABEL_7;
    }
    if ( v8 < 0 )
      break;
    v9 = -1;
LABEL_7:
    if ( (_BYTE *)(v18[2] - v18[0]) <= (_BYTE *)0x37 )
      sub_41CFE2(a1, v18, 56LL, a3, a4);
    if ( v8 > 127 )
    {
      if ( a2 || v8 != 931 || !(unsigned int)sub_41CB38(v16) || (unsigned int)sub_41CB38(v9) )
      {
        v13 = v19;
        for ( i = 8LL; i; --i )
        {
          *(_DWORD *)v13 = 0;
          v13 = (__int64 *)((char *)v13 + 4);
        }
        if ( a2 )
        {
          v19[0] = (__int64)qword_43E1C0;
          v20 = 1411LL;
        }
        else
        {
          v19[0] = (__int64)qword_43DEE0;
          v20 = 706LL;
        }
        sub_41C56C(v18, v8, v19);
      }
      else
      {
        v12 = sub_41C531(0x3C2u, v18[0]);
        v18[0] += v12;
      }
    }
    else
    {
      if ( a2 )
      {
        v10 = v8;
        if ( (unsigned int)(v8 - 97) <= 0x19 )
          v10 = v8 - 32;
      }
      else
      {
        v10 = v8;
        if ( (unsigned int)(v8 - 65) <= 0x19 )
          v10 = v8 + 32;
      }
      v11 = v18[0]++;
      *v11 = v10;
    }
LABEL_4:
    v16 = v8;
    v8 = v9;
  }
  sub_41D054(a1, v18, a3, a4);
  sub_406BF4(a1, -1, a3, a4);
  sub_405181(a1, a3, a4);
}
// 43DEE0: using guessed type __int64 qword_43DEE0[92];
// 43E1C0: using guessed type __int64 qword_43E1C0[180];

//----- (000000000041CD28) ----------------------------------------------------
__int64 __fastcall sub_41CD28(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  __int64 v3; // rcx
  char *v4; // rdi
  __int64 *v5; // [rsp+0h] [rbp-30h] BYREF
  char v6; // [rsp+8h] [rbp-28h] BYREF
  __int64 v7; // [rsp+10h] [rbp-20h]

  if ( (int)a2 <= 127 )
  {
    result = a2 - 32;
    if ( a2 - 97 <= 0x19 )
      return result;
    return a2;
  }
  v3 = 6LL;
  v5 = qword_43E1C0;
  v4 = &v6;
  while ( v3 )
  {
    *(_DWORD *)v4 = 0;
    v4 += 4;
    --v3;
  }
  v7 = 1411LL;
  result = sub_41C56C(0LL, a2, (__int64 *)&v5);
  if ( (int)result <= 127 )
    return a2;
  return result;
}
// 43E1C0: using guessed type __int64 qword_43E1C0[180];

//----- (000000000041CD7E) ----------------------------------------------------
__int64 __fastcall sub_41CD7E(int a1)
{
  __int64 result; // rax

  result = 1LL;
  if ( (unsigned int)(a1 - 48) > 9 )
    return (a1 == 95) | (unsigned __int8)((a1 & 0xFFFFFFDF) - 65 <= 0x19);
  return result;
}

//----- (000000000041CDA5) ----------------------------------------------------
__int64 __fastcall sub_41CDA5(__int64 *a1, int a2)
{
  int v3; // edx
  unsigned int v4; // eax
  int v5; // eax
  unsigned __int64 v6; // rsi
  bool v7; // cf
  __int64 v8; // r8
  int v9; // edx

  while ( 1 )
  {
    v3 = *((_DWORD *)a1 + 7);
    v4 = *((_DWORD *)a1 + 6);
    if ( v3 >= a2 )
      break;
    v5 = v4 << 8;
    v6 = a1[1];
    v7 = v6 < a1[2];
    *((_DWORD *)a1 + 6) = v5;
    if ( v7 )
    {
      v8 = *a1;
      a1[1] = v6 + 1;
      *((_DWORD *)a1 + 6) = *(unsigned __int8 *)(v8 + v6) | v5;
    }
    *((_DWORD *)a1 + 7) = v3 + 8;
  }
  v9 = v3 - a2;
  *((_DWORD *)a1 + 7) = v9;
  return ~(-1 << a2) & (v4 >> v9);
}

//----- (000000000041CDF1) ----------------------------------------------------
__int64 __fastcall sub_41CDF1(__int64 *a1)
{
  return sub_41CDA5(a1, 1);
}

//----- (000000000041CDF8) ----------------------------------------------------
__int64 __fastcall sub_41CDF8(__int64 *a1, int a2)
{
  unsigned int v2; // er11

  if ( (unsigned int)sub_41CDF1(a1) )
    return sub_41CDA5(a1, a2);
  else
    return v2;
}
// 41CE1D: variable 'v2' is possibly undefined

//----- (000000000041CE24) ----------------------------------------------------
__int64 __fastcall sub_41CE24(__int64 *a1)
{
  __int64 result; // rax
  int v2; // edx

  result = sub_41CDA5(a1, 2);
  if ( (_DWORD)result == 1 )
    return (unsigned int)sub_41CDA5(a1, 2) + 1;
  if ( (_DWORD)result == 2 )
    return (unsigned int)sub_41CDA5(a1, 5) + 5;
  if ( (_DWORD)result )
  {
    v2 = sub_41CDA5(a1, 7);
    result = (unsigned int)(v2 + 36);
    if ( !v2 )
      return sub_41CDA5(a1, 20);
  }
  return result;
}

//----- (000000000041CE93) ----------------------------------------------------
__int64 __fastcall sub_41CE93(__int64 *a1)
{
  unsigned int v1; // eax
  __int64 *v2; // r10
  _BYTE *v3; // r11
  unsigned int v4; // er12
  char v5; // bl
  _BYTE *v6; // r13
  __int64 v7; // rax
  _BYTE *v8; // r11

  v1 = sub_41CDA5(a1, 5);
  if ( v1 == 31 )
    v1 = sub_41CDA5(v2, 8);
  v4 = v1;
  v5 = 32;
  v6 = &v3[v1];
  while ( v3 != v6 )
  {
    LODWORD(v7) = sub_41CDA5(v2, 5);
    if ( (unsigned int)v7 <= 0x19 )
      goto LABEL_15;
    switch ( (_DWORD)v7 )
    {
      case 0x1A:
        v7 = (unsigned int)sub_41CDA5(v2, 3);
LABEL_10:
        LOBYTE(v7) = byte_43EE40[v7];
        break;
      case 0x1B:
        v7 = (unsigned int)sub_41CDA5(v2, 3) + 8;
        goto LABEL_10;
      case 0x1C:
        LOBYTE(v7) = (v5 ^ 0x20) + sub_41CDA5(v2, 5) + 65;
        break;
      case 0x1D:
        v5 ^= 0x20u;
        LOBYTE(v7) = sub_41CDA5(v2, 5);
LABEL_15:
        LOBYTE(v7) = v5 + v7 + 65;
        break;
      case 0x1F:
        LOBYTE(v7) = sub_41CDA5(v2, 8);
        break;
    }
    *v8 = v7;
    v3 = v8 + 1;
  }
  return v4;
}
// 41CEBA: variable 'v2' is possibly undefined
// 41CECA: variable 'v3' is possibly undefined
// 41CF66: variable 'v8' is possibly undefined

//----- (000000000041CF7C) ----------------------------------------------------
__int64 __fastcall sub_41CF7C(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 result; // rax

  v3 = *(_QWORD *)(a3 + 24);
  v4 = *(_QWORD *)(a3 + 32);
  a2[3] = a3;
  *a2 = v4;
  a2[1] = v4;
  result = v3 + v4;
  a2[2] = result;
  return result;
}

//----- (000000000041CF97) ----------------------------------------------------
__int64 __fastcall sub_41CF97(__int64 *a1, _QWORD *a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 result; // rax
  __int64 v7; // rdx

  sub_40762B(a1, a3, 1, a4, a5);
  result = sub_405B46((__int64)a1, -1);
  v7 = *(_QWORD *)(result + 32);
  a2[3] = result;
  *a2 = v7;
  a2[1] = v7;
  a2[2] = a3 + v7;
  return result;
}

//----- (000000000041CFE2) ----------------------------------------------------
__int64 __fastcall sub_41CFE2(__int64 *a1, _QWORD *a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // r13
  __int64 result; // rax
  __int64 v8; // rdx

  v5 = *a2 - a2[1];
  v6 = v5 + a3 + 64 + (v5 >> 2);
  if ( v5 <= v6 )
  {
    sub_4200FB(a1, a2[3], v6, a4, a5);
    v8 = *(_QWORD *)(a2[3] + 32LL);
    result = v8 + v5;
    a2[1] = v8;
    a2[2] = v6 + v8;
    *a2 = v8 + v5;
  }
  else
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_util_bufwriter.c", 71, "buffer too long", a4, a5);
    return 0LL;
  }
  return result;
}

//----- (000000000041D054) ----------------------------------------------------
__int64 __fastcall sub_41D054(__int64 *a1, _QWORD *a2, __m128 a3, __m128 a4)
{
  unsigned __int64 v4; // r12
  __int64 result; // rax
  __int64 v6; // r12

  v4 = *a2 - a2[1];
  sub_4200FB(a1, a2[3], v4, a3, a4);
  result = *(_QWORD *)(a2[3] + 32LL);
  v6 = result + v4;
  a2[1] = result;
  *a2 = v6;
  a2[2] = v6;
  return result;
}

//----- (000000000041D08C) ----------------------------------------------------
void __fastcall sub_41D08C(__int64 a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rdi
  __int64 *v5; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rsi

  v4 = *a2;
  v5 = a2;
  v7 = a4;
  v8 = a3 + a2[1];
  if ( a4 )
    sub_43AAA0(v4, v8, a4);
  *v5 += v7;
}
// 41D0A9: variable 'v7' is possibly undefined
// 41D0A9: variable 'v5' is possibly undefined

//----- (000000000041D0AD) ----------------------------------------------------
void __fastcall sub_41D0AD(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  unsigned __int64 v7; // [rsp+8h] [rbp-28h]

  if ( a4 > a2[2] - *a2 )
  {
    v7 = a4;
    sub_41CFE2(a1, a2, a4, a5, a6);
    a4 = v7;
  }
  sub_41D08C((__int64)a1, a2, a3, a4);
}

//----- (000000000041D0F2) ----------------------------------------------------
void __fastcall sub_41D0F2(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v6; // rax
  _QWORD *v7; // r9
  __int64 v8; // rdx
  _BYTE *v9; // rdi
  _BYTE *v10; // rax
  __int64 v11; // rdx

  v6 = a2[1];
  v7 = a2;
  v8 = *a2 - v6;
  v9 = (_BYTE *)(v6 + a3 + a5);
  v10 = (_BYTE *)(a3 + v6);
  v11 = v8 - a3;
  if ( v11 )
    sub_43ABC2(v9, v10, v11);
  if ( a5 )
    sub_43AAA0((__int64)v10, a4, a5);
  *v7 += a5;
}
// 41D11C: variable 'a5' is possibly undefined
// 41D127: variable 'v10' is possibly undefined
// 41D127: variable 'a4' is possibly undefined
// 41D12C: variable 'v7' is possibly undefined

//----- (000000000041D130) ----------------------------------------------------
void __fastcall sub_41D130(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4, unsigned __int64 a5, __m128 a6, __m128 a7)
{
  __int64 v8; // [rsp+0h] [rbp-30h]
  unsigned __int64 v9; // [rsp+8h] [rbp-28h]

  if ( a5 > a2[2] - *a2 )
  {
    v8 = a4;
    v9 = a5;
    sub_41CFE2(a1, a2, a5, a6, a7);
    a4 = v8;
    a5 = v9;
  }
  sub_41D0F2((__int64)a1, a2, a3, a4, a5);
}

//----- (000000000041D180) ----------------------------------------------------
void __fastcall sub_41D180(__int64 a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // rax
  _QWORD *v6; // r10
  __int64 v8; // r11
  _BYTE *v9; // rdi
  __int64 v10; // rdx

  v5 = a2[1];
  v6 = a2;
  if ( a4 >= a3 )
    a4 += a5;
  v8 = v5 + a3;
  v9 = (_BYTE *)(v5 + a3 + a5);
  v10 = *a2 - v5 - a3;
  if ( v10 )
    sub_43ABC2(v9, (_BYTE *)(v5 + a3), v10);
  if ( a5 )
    sub_43AAA0(v8, v5 + a4, a5);
  *v6 += a5;
}
// 41D1B7: variable 'a5' is possibly undefined
// 41D1BF: variable 'v8' is possibly undefined
// 41D1B3: variable 'v5' is possibly undefined
// 41D1B3: variable 'a4' is possibly undefined
// 41D1C4: variable 'v6' is possibly undefined

//----- (000000000041D1C8) ----------------------------------------------------
void __fastcall sub_41D1C8(
        __int64 *a1,
        _QWORD *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __m128 a6,
        __m128 a7)
{
  unsigned __int64 v8; // [rsp+0h] [rbp-30h]
  unsigned __int64 v9; // [rsp+8h] [rbp-28h]

  if ( a5 > a2[2] - *a2 )
  {
    v8 = a4;
    v9 = a5;
    sub_41CFE2(a1, a2, a5, a6, a7);
    a4 = v8;
    a5 = v9;
  }
  sub_41D180((__int64)a1, a2, a3, a4, a5);
}

//----- (000000000041D218) ----------------------------------------------------
void __fastcall sub_41D218(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rax
  __int64 v6; // rdx
  _BYTE *v7; // rdi
  _BYTE *v8; // rax
  __int64 v9; // rdx

  v5 = a2[1];
  v6 = *a2 - v5;
  v7 = (_BYTE *)(v5 + a3 + a4);
  v8 = (_BYTE *)(a3 + v5);
  v9 = v6 - a3;
  if ( v9 )
    sub_43ABC2(v7, v8, v9);
}

//----- (000000000041D23D) ----------------------------------------------------
void __fastcall sub_41D23D(__int64 *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4, __m128 a5, __m128 a6)
{
  unsigned __int64 v7; // [rsp+8h] [rbp-28h]

  if ( a4 > a2[2] - *a2 )
  {
    v7 = a4;
    sub_41CFE2(a1, a2, a4, a5, a6);
    a4 = v7;
  }
  sub_41D218((__int64)a1, a2, a3, a4);
}

//----- (000000000041D282) ----------------------------------------------------
void __fastcall sub_41D282(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rax
  _BYTE *v5; // rdi
  __int64 v6; // rdx

  v4 = a2;
  v5 = (_BYTE *)(a3 + a2[1]);
  v6 = *a2 - (_QWORD)&v5[a4];
  if ( v6 )
    sub_43ABC2(v5, &v5[a4], v6);
  *v4 -= a4;
}
// 41D29D: variable 'v4' is possibly undefined
// 41D29D: variable 'a4' is possibly undefined

//----- (000000000041D2A1) ----------------------------------------------------
__int64 __fastcall sub_41D2A1(double a1)
{
  __int64 result; // rax

  if ( a1 < -2147483648.0 )
    return 0x80000000LL;
  result = (unsigned int)(int)a1;
  if ( a1 > 2147483647.0 )
    return 0x7FFFFFFFLL;
  return result;
}

//----- (000000000041D2CA) ----------------------------------------------------
__int64 __fastcall sub_41D2CA(double a1)
{
  __int64 result; // rax

  if ( a1 < 0.0 )
    return 0LL;
  result = (unsigned int)(int)a1;
  if ( a1 > 4294967295.0 )
    return 0xFFFFFFFFLL;
  return result;
}

//----- (000000000041D2F4) ----------------------------------------------------
__m128 __fastcall sub_41D2F4(__m128 a1)
{
  __m128 v1; // xmm1

  v1 = _mm_and_ps(a1, (__m128)xmmword_43EEA0);
  if ( *(double *)v1.i64 > 3.402823466385289e38 )
  {
    if ( *(double *)v1.i64 > 3.402823567797336e38 )
    {
      v1 = (__m128)0xFF800000;
      if ( *(double *)a1.i64 >= 0.0 )
        return (__m128)0x7F800000u;
    }
    else
    {
      v1 = (__m128)0xFF7FFFFF;
      if ( *(double *)a1.i64 >= 0.0 )
        return (__m128)0x7F7FFFFFu;
    }
  }
  else
  {
    v1.f32[0] = *(double *)a1.i64;
  }
  return v1;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041D385) ----------------------------------------------------
_BOOL8 __fastcall sub_41D385(double a1)
{
  return *(_QWORD *)&a1 == 0x7FF0000000000000LL;
}

//----- (000000000041D3C3) ----------------------------------------------------
_BOOL8 __fastcall sub_41D3C3(double a1)
{
  _BOOL8 result; // rax

  result = 0LL;
  if ( (*(_QWORD *)&a1 & 0x7FF0000000000000LL) == 0x7FF0000000000000LL )
    return (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0;
  return result;
}

//----- (000000000041D3F3) ----------------------------------------------------
__int64 __fastcall sub_41D3F3(double a1)
{
  unsigned int v1; // er8

  if ( (*(_QWORD *)&a1 & 0x7FF0000000000000LL) != 0x7FF0000000000000LL )
    return (*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  v1 = 1;
  if ( (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) == 0 )
    return (*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0;
  return v1;
}

//----- (000000000041D436) ----------------------------------------------------
_BOOL8 __fastcall sub_41D436(double a1)
{
  return (*(_QWORD *)&a1 & 0x7FF0000000000000LL) == 0x7FF0000000000000LL;
}

//----- (000000000041D45B) ----------------------------------------------------
_BOOL8 __fastcall sub_41D45B(double a1)
{
  if ( (*(_QWORD *)&a1 & 0x7FF0000000000000LL) != 0 )
    return (*(_QWORD *)&a1 & 0x7FF0000000000000LL) == 0x7FF0000000000000LL;
  else
    return a1 >= 0.0;
}

//----- (000000000041D498) ----------------------------------------------------
__int64 __fastcall sub_41D498(__int64 a1, __int64 a2, __int64 a3)
{
  sub_431665();
  return a3;
}
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041D4BF) ----------------------------------------------------
_BOOL8 __fastcall sub_41D4BF(double a1, double a2)
{
  return (HIDWORD(a2) ^ HIDWORD(a1)) >= 0;
}

//----- (000000000041D4DE) ----------------------------------------------------
double __fastcall sub_41D4DE(double a1, double a2)
{
  return fmax(a1, a2);
}

//----- (000000000041D4E3) ----------------------------------------------------
_BOOL8 __fastcall sub_41D4E3(double a1)
{
  return (*(_QWORD *)&a1 & 0x7FF0000000000000LL) != 0x7FF0000000000000LL;
}

//----- (000000000041D508) ----------------------------------------------------
__int64 __fastcall sub_41D508(__int64 a1, __int64 a2, double a3)
{
  unsigned int v3; // er12

  v3 = 0;
  if ( (*(_QWORD *)&a3 & 0x7FF0000000000000LL) != 0x7FF0000000000000LL )
  {
    sub_417A0C(a1, a2, a3);
    return 1;
  }
  return v3;
}

//----- (000000000041D552) ----------------------------------------------------
_BOOL8 __fastcall sub_41D552(__int64 a1, __int64 a2, double a3)
{
  int v3; // er8
  _BOOL8 result; // rax

  v3 = sub_41D508(a1, a2, a3);
  result = 0LL;
  if ( v3 )
    return COERCE_DOUBLE(*(_QWORD *)&a3 & 0x7FFFFFFFFFFFFFFFLL) <= 9.007199254740991e15;
  return result;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041D58D) ----------------------------------------------------
__int64 __fastcall sub_41D58D(int *a1, double a2)
{
  int v2; // eax
  unsigned int v3; // er8

  v2 = sub_41D2F0();
  if ( (double)v2 == a2 )
  {
    if ( v2 || (v3 = 0, a2 >= 0.0) )
    {
      *a1 = v2;
      return 1;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}
// 41D2F0: using guessed type __int64 sub_41D2F0(void);

//----- (000000000041D5D5) ----------------------------------------------------
__int64 __fastcall sub_41D5D5(int *a1, double a2)
{
  int v2; // eax

  v2 = sub_41D2F0();
  if ( (double)v2 != a2 )
    return 0LL;
  *a1 = v2;
  return 1LL;
}
// 41D2F0: using guessed type __int64 sub_41D2F0(void);

//----- (000000000041D60E) ----------------------------------------------------
double __fastcall sub_41D60E(double a1, __m128d a2)
{
  double result; // xmm0_8

  if ( a2.f64[0] != 0.0 )
    return a1 / a2.f64[0];
  if ( a1 <= 0.0 )
  {
    if ( a1 >= 0.0 )
    {
      return NAN;
    }
    else
    {
      result = -INFINITY;
      if ( (_mm_movemask_pd(a2) & 1) != 0 )
        return INFINITY;
    }
  }
  else
  {
    result = INFINITY;
    if ( (_mm_movemask_pd(a2) & 1) != 0 )
      return -INFINITY;
  }
  return result;
}

//----- (000000000041D667) ----------------------------------------------------
unsigned __int64 __fastcall sub_41D667(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax

  result = _byteswap_uint64(*a1);
  *a1 = result;
  return result;
}

//----- (000000000041D673) ----------------------------------------------------
__int64 __fastcall sub_41D673(unsigned int *a1)
{
  __int64 result; // rax

  result = _byteswap_ulong(*a1);
  *a1 = result;
  return result;
}

//----- (000000000041D67C) ----------------------------------------------------
_BOOL8 __fastcall sub_41D67C(double a1, double a2)
{
  return a1 == a2;
}

//----- (000000000041D69F) ----------------------------------------------------
__int64 __fastcall sub_41D69F(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a3 )
    return sub_43AA7D(a1, a2, a3);
  else
    return 0LL;
}
// 43AA7D: using guessed type __int64 __fastcall sub_43AA7D(_QWORD, _QWORD, _QWORD);

//----- (000000000041D6B1) ----------------------------------------------------
unsigned __int64 __fastcall sub_41D6B1(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // ecx
  unsigned __int64 v3; // rsi
  char v4; // dl
  unsigned __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 64);
  v2 = 0;
  v3 = *(_QWORD *)(v1 + 216);
  do
  {
    v3 -= 0x61C8864680B583EBLL;
    v4 = v2++;
    result = ((0x94D049BB133111EBLL
             * ((0xBF58476D1CE4E5B9LL * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v3 ^ (v3 >> 30))) >> 27))) >> 31) ^ (0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9LL * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9LL * (v3 ^ (v3 >> 30))) >> 27)));
    *(_QWORD *)(v1 + 8 * ((v4 & 1) + 26LL) + 8) = result;
  }
  while ( v2 != 64 );
  return result;
}

//----- (000000000041D71B) ----------------------------------------------------
double __fastcall sub_41D71B(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  __int64 v3; // rcx

  v1 = *(_QWORD *)(a1 + 64);
  v2 = *(_QWORD *)(v1 + 224);
  v3 = *(_QWORD *)(v1 + 216);
  *(_QWORD *)(v1 + 224) = __ROR8__(v2 ^ v3, 28);
  *(_QWORD *)(v1 + 216) = ((v2 ^ v3) << 14) ^ v2 ^ v3 ^ __ROR8__(v3, 9);
  return COERCE_DOUBLE(((unsigned __int64)(v2 + v3) >> 12) | 0x3FF0000000000000LL) - 1.0;
}

//----- (000000000041D784) ----------------------------------------------------
__int64 __fastcall sub_41D784(__int64 a1, __int64 a2)
{
  return sub_434FC4(a2);
}
// 434FC4: using guessed type __int64 __fastcall sub_434FC4(_QWORD);

//----- (000000000041D78C) ----------------------------------------------------
__int64 __fastcall sub_41D78C(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_434FCA(a2, a3, a3);
}
// 434FCA: using guessed type __int64 __fastcall sub_434FCA(_QWORD, _QWORD, _QWORD);

//----- (000000000041D797) ----------------------------------------------------
__int64 __fastcall sub_41D797(__int64 a1, __int64 a2)
{
  return sub_434FBE(a2);
}
// 434FBE: using guessed type __int64 __fastcall sub_434FBE(_QWORD);

//----- (000000000041D79F) ----------------------------------------------------
__int64 __fastcall sub_41D79F(__int64 *a1, int a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbx

  v5 = sub_405873(a1, a2, a4, a5);
  if ( (*(_DWORD *)v5 & 0x180) == 128 )
  {
    sub_4200FB(a1, v5, a3, a4, a5);
    return *(_QWORD *)(v5 + 32);
  }
  else
  {
    sub_401C42(a1, (__int64)"third_party/duktape/duk_api_buffer.c", 0x6000010u, "wrong buffer type", a4, a5);
    return 0LL;
  }
}

//----- (000000000041D8AF) ----------------------------------------------------
__int64 __fastcall sub_41D8AF(__int64 *a1, int *a2, __m128 a3, __m128 a4)
{
  int v4; // ebx
  __int64 v5; // rbx
  __int64 v6; // rdx

  v4 = *a2;
  v5 = (unsigned int)sub_404AE7((__int64)a1) - v4;
  sub_4068FC(a1, v5, v6, a3, a4);
  sub_4213B2(a1, (unsigned int)(v5 - 1), (unsigned int)a2[1]);
  return 1LL;
}
// 41D8CF: variable 'v6' is possibly undefined
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (000000000041D8F0) ----------------------------------------------------
__int64 __fastcall sub_41D8F0(__int64 a1, int *a2)
{
  int v2; // er13
  int v3; // eax

  v2 = *a2;
  v3 = sub_404AE7(a1);
  sub_4213B2(a1, (unsigned int)(v3 - v2 - 2), (unsigned int)a2[1]);
  return 1LL;
}
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (000000000041D928) ----------------------------------------------------
void __fastcall sub_41D928(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v5; // er14
  __int64 v7; // rdx
  __int64 v8; // rcx

  v5 = ~a3;
  sub_404F0A(a1, ~a3, a4, a5);
  sub_403616(a1, a2, a4, a5);
  if ( !sub_4065F2((__int64)a1, -1) )
    sub_401EA7(a1, (__int128 *)(a1[13] + 16LL * a2), (__int128 *)(a1[14] + 16LL * -a3 - 32), a4, a5);
  sub_405057(a1, -2 - a3, v7, v8, *(double *)a4.i64, a5);
  sub_404F0A(a1, a2, a4, a5);
  sub_40500F(a1, v5);
}
// 41D995: variable 'v7' is possibly undefined
// 41D995: variable 'v8' is possibly undefined

//----- (000000000041D9B8) ----------------------------------------------------
__int64 __fastcall sub_41D9B8(__int64 *a1, __int64 a2, __m128 a3, __m128 a4, __m128 a5)
{
  int v5; // eax

  v5 = sub_40480A(a1, *(_DWORD *)a2);
  sub_41D928(a1, v5, *(_DWORD *)(a2 + 4), a3, a4);
  sub_421382((__int64)a1, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), a3, a4, a5);
  return 1LL;
}

//----- (000000000041D9F1) ----------------------------------------------------
__int64 __fastcall sub_41D9F1(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  __int64 result; // rax

  result = (unsigned int)sub_404AE7((__int64)a1) - a2 - a3;
  if ( (int)(result | a2) < 0 )
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_call.c", 55, a4, a5);
    return 0LL;
  }
  return result;
}

//----- (000000000041DA2F) ----------------------------------------------------
__int64 __fastcall sub_41DA2F(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er13
  __int64 v5; // rdx

  v4 = sub_41D9F1(a1, a2, 1, a3, a4);
  sub_4068FC(a1, v4 + 1, v5, a3, a4);
  return sub_4213B2(a1, v4, 0LL);
}
// 41DA4D: variable 'v5' is possibly undefined
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (000000000041DA64) ----------------------------------------------------
__int64 __fastcall sub_41DA64(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // eax

  v4 = sub_41D9F1(a1, a2, 2, a3, a4);
  return sub_4213B2(a1, v4, 0LL);
}
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (000000000041DAD1) ----------------------------------------------------
__int64 __fastcall sub_41DAD1(
        _QWORD *a1,
        __int64 (__fastcall *a2)(__int64, __int64),
        __int64 a3,
        int a4,
        int a5,
        __m128 a6,
        __m128 a7)
{
  unsigned __int64 v7; // r9
  __int64 v8; // rax

  if ( (a5 | a4) >= 0 )
  {
    v7 = a1[14];
    v8 = 16LL * a4;
    if ( v7 >= v8 + a1[13] && a1[11] + v8 >= 16LL * a5 + v7 )
      return sub_4213B7((__int64)a1, a2, a3, a4, a5, a6, a7);
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_api_call.c", 314, a6, a7);
  return 1LL;
}

//----- (000000000041DB66) ----------------------------------------------------
__int64 __fastcall sub_41DB66(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6[2]; // [rsp+8h] [rbp-8h] BYREF

  v6[0] = a2;
  if ( a2 >= 0 )
  {
    v6[1] = a3;
    return sub_41DAD1(a1, (__int64 (__fastcall *)(__int64, __int64))sub_41D8F0, (__int64)v6, a2 + 2, 1, a4, a5);
  }
  else
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_api_call.c", 237, a4, a5);
    return 1LL;
  }
}

//----- (000000000041DBA7) ----------------------------------------------------
__int64 __fastcall sub_41DBA7(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  return sub_41DB66(a1, a2, 0, a3, a4);
}

//----- (000000000041DBF3) ----------------------------------------------------
__int64 __fastcall sub_41DBF3(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // er13

  v4 = sub_41D9F1(a1, a2, 1, a3, a4);
  sub_407095(a1, a3, a4);
  sub_40500F(a1, v4 + 1);
  return sub_4213B2(a1, v4, 2LL);
}
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (000000000041DC34) ----------------------------------------------------
__int64 __fastcall sub_41DC34(__int64 *a1, int *a2, __m128 a3, __m128 a4)
{
  sub_41DBF3(a1, *a2, a3, a4);
  return 1LL;
}

//----- (000000000041DC85) ----------------------------------------------------
__int64 __fastcall sub_41DC85(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 120);
  result = 0LL;
  if ( v1 )
    return (*(_DWORD *)(v1 + 88) >> 2) & 1;
  return result;
}

//----- (000000000041DC9A) ----------------------------------------------------
__int64 __fastcall sub_41DC9A(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 result; // rax

  result = sub_41DC85((__int64)a1);
  if ( !(_DWORD)result )
    return sub_401C42(
             a1,
             (__int64)"third_party/duktape/duk_api_call.c",
             0x6000182u,
             "constructor requires 'new'",
             a2,
             a3);
  return result;
}

//----- (000000000041DCBE) ----------------------------------------------------
__int64 __fastcall sub_41DCBE(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 120);
  result = 1LL;
  if ( v1 )
    return *(_DWORD *)(v1 + 88) & 1;
  return result;
}

//----- (000000000041DCD3) ----------------------------------------------------
__int64 __fastcall sub_41DCD3(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax
  __int64 v3; // rdx

  v1 = *(_QWORD *)(a1 + 120);
  result = 0LL;
  if ( v1 )
  {
    v3 = *(_QWORD *)(v1 + 16);
    if ( v3 )
    {
      result = 0LL;
      if ( _bittest((const signed __int32 *)v3, 0xCu) )
        return (unsigned int)*(__int16 *)(v3 + 66);
    }
    else
    {
      return (unsigned int)*(char *)(v1 + 5);
    }
  }
  return result;
}

//----- (000000000041DD48) ----------------------------------------------------
const signed __int32 *__fastcall sub_41DD48(__int64 *a1, int a2, __int16 a3, __m128 a4, __m128 a5)
{
  const signed __int32 *result; // rax

  result = sub_405991(a1, a2, a4, a5);
  *((_WORD *)result + 33) = a3;
  return result;
}

//----- (000000000041DD5D) ----------------------------------------------------
__int64 __fastcall sub_41DD5D(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 result; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx

  result = a1[14];
  if ( *(_DWORD *)(result - 16) == 9 )
  {
    if ( _bittest(*(const signed __int32 **)(result - 8), 0xAu) )
    {
      sub_406883(a1, (__int128 *)(*(_QWORD *)(result - 8) + 56LL), a2, a3);
      return sub_405057(a1, -2, v4, v5, *(double *)a2.i64, a3);
    }
  }
  return result;
}
// 41DD5D: could not find valid save-restore pair for rbp
// 41DD90: variable 'v4' is possibly undefined
// 41DD90: variable 'v5' is possibly undefined

//----- (000000000041DD9B) ----------------------------------------------------
__int64 __fastcall sub_41DD9B(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  double v4; // xmm0_8

  v4 = sub_41EE6B(a1, a2, a3, a4);
  return sub_42F94A(v4);
}

//----- (000000000041DE9A) ----------------------------------------------------
__int64 __fastcall sub_41DE9A(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4)
{
  __int64 result; // rax
  __int64 v6; // rsi
  __int64 v7; // rdx
  __int64 v8; // rcx
  __m128 v9; // xmm1
  __int64 v10; // rdx
  __int64 v11; // rcx

  sub_405C43(a1, a2, a3, a4);
  result = sub_4064EF((__int64)a1, a2);
  if ( !(_DWORD)result )
  {
    sub_404F0A(a1, a2, a3, a4);
    sub_405DB7(a1, -1, a3, a4);
    v6 = 0xFFFFFFFFLL;
    *(double *)a3.i64 = sub_40541C((__int64)a1, -1);
    v9 = 0LL;
    if ( *(double *)a3.i64 >= 0.0 )
    {
      *(double *)v9.i64 = 99.0;
      if ( *(double *)a3.i64 <= 99.0 )
      {
        *(double *)a3.i64 = *(double *)a3.i64 + 1900.0;
        sub_406A1B(a1, a3, v9);
        v6 = a2;
        sub_405057(a1, a2, v10, v11, *(double *)a3.i64, v9);
      }
    }
    return sub_407D7E(a1, v6, v7, v8, a3, v9);
  }
  return result;
}
// 41DF0A: variable 'v10' is possibly undefined
// 41DF0A: variable 'v11' is possibly undefined
// 41DF17: variable 'v7' is possibly undefined
// 41DF17: variable 'v8' is possibly undefined

//----- (000000000041DF22) ----------------------------------------------------
__int64 __fastcall sub_41DF22(__int64 *a1, __int64 a2, int a3, __m128 a4, __m128 a5)
{
  __int64 v6; // rbx
  __int64 result; // rax
  double v8; // xmm0_8

  v6 = 0LL;
  result = sub_41DE9A(a1, 0, a4, a5);
  do
  {
    v8 = 0.0;
    if ( a3 > (int)v6 )
    {
      result = sub_405C43(a1, v6, (__m128)0LL, a5);
      if ( v6 == 2 )
        v8 = 0.0 - 1.0;
    }
    *(double *)(a2 + 8 * v6++) = v8;
  }
  while ( v6 != 8 );
  return result;
}

//----- (000000000041DF78) ----------------------------------------------------
__int64 __fastcall sub_41DF78(__int64 *a1, char a2, _DWORD *a3, __m128 a4, __m128 a5)
{
  _DWORD *v6; // rax
  __int64 result; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx

  sub_406FB2(a1, a4, a5);
  v6 = (_DWORD *)sub_405823((__int64)a1, -1);
  if ( !v6 || *v6 >> 27 != 6 )
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_date.c", 0x6000384u, "expected Date", a4, a5);
  sub_403883(a1, -65430, a4, a5);
  *(double *)a4.i64 = sub_405CAB(a1, a4, a5);
  sub_407D7E(a1, 4294901866LL, v8, v9, a4, a5);
  result = 0LL;
  if ( (a2 & 0x10) != 0 )
    result = sub_41EEA7(*(double *)a4.i64);
  if ( a3 )
    *a3 = result;
  return result;
}
// 41DFE3: variable 'v8' is possibly undefined
// 41DFE3: variable 'v9' is possibly undefined

//----- (000000000041E05A) ----------------------------------------------------
double __fastcall sub_41E05A(__int64 a1, __int64 a2, double result)
{
  if ( fabs(result) > 1.797693134862316e308 || result < -8.64e15 || result > 8.64e15 )
    return NAN;
  sub_417A0C(a1, a2, result);
  return result;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041E098) ----------------------------------------------------
__int64 __fastcall sub_41E098(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // ecx
  int v5; // eax

  if ( a1 - 1969 < 0 )
    v1 = (a1 - 1972) / 4;
  else
    v1 = (a1 - 1969) >> 2;
  v2 = 365 * (a1 - 1970) + v1;
  v3 = a1 - 1901;
  if ( a1 - 1901 < 0 )
    v3 = a1 - 2000;
  v4 = v2 - v3 / 100;
  v5 = a1 - 1601;
  if ( a1 - 1601 < 0 )
    v5 = a1 - 2000;
  return (unsigned int)(v4 + v5 / 400);
}

//----- (000000000041E0FB) ----------------------------------------------------
_BOOL8 __fastcall sub_41E0FB(int a1)
{
  _BOOL8 result; // rax

  result = 0LL;
  if ( (a1 & 3) == 0 )
  {
    result = 1LL;
    if ( !(a1 % 100) )
      return a1 % 400 == 0;
  }
  return result;
}

//----- (000000000041E147) ----------------------------------------------------
__int64 __fastcall sub_41E147(double a1)
{
  return (a1 >= -8.6400000864e15) & (unsigned __int8)(a1 <= 8.6400000864e15);
}

//----- (000000000041E185) ----------------------------------------------------
__int64 __fastcall sub_41E185(int *a1, __int64 a2, char a3, double a4)
{
  double v7; // xmm2_8
  __int64 v8; // rtt
  __int64 v9; // rtt
  __int64 v10; // rtt
  int v11; // ecx
  int i; // edi
  int v13; // esi
  int v14; // er9
  int v15; // er10
  _BOOL4 v16; // er8
  int v17; // er9
  __int64 result; // rax
  int v19; // edx
  int v20; // ecx
  int v21; // edx

  sub_42F94A(a4);
  v7 = sub_42F9DE(a4, 86400000.0);
  if ( v7 < 0.0 )
    v7 = v7 + 86400000.0;
  sub_42F94A(a4 / 86400000.0);
  LODWORD(v8) = (int)v7;
  HIDWORD(v8) = (int)v7 >> 31;
  a1[6] = v8 % 1000;
  v9 = (int)(v8 / 1000);
  a1[5] = v9 % 60;
  v10 = (int)(v9 / 60);
  a1[3] = v10 / 60;
  a1[4] = v10 % 60;
  v11 = 365;
  a1[7] = ((int)(a4 / 86400000.0) + 140000004) % 7;
  if ( (int)(a4 / 86400000.0) < 0 )
    v11 = 366;
  for ( i = (int)(a4 / 86400000.0) / v11 + 1970; ; i -= (v13 - v14 - 1) / v15 + 1 )
  {
    v13 = sub_41E098(i);
    if ( v13 - v14 <= 0 )
      break;
  }
  v16 = sub_41E0FB(i);
  result = 0LL;
  while ( 1 )
  {
    v19 = (unsigned __int8)byte_43F4B0[result];
    v20 = result;
    if ( (_DWORD)result == 1 )
      v19 -= !v16 - 1;
    if ( v19 > v17 )
      break;
    ++result;
    v17 -= v19;
    if ( result == 12 )
    {
      v20 = 12;
      break;
    }
  }
  if ( (a3 & 8) != 0 )
  {
    result = (unsigned int)(i - 1971);
    if ( (unsigned int)result > 0x42 )
    {
      v21 = (v13 + 140000004) % 7;
      if ( v16 )
        v21 += 7;
      result = v21;
      i = (unsigned __int8)a5a1962[v21] + 1970;
    }
  }
  *a1 = i;
  a1[1] = v20;
  a1[2] = v17;
  if ( (a3 & 4) != 0 )
  {
    a1[1] = v20 + 1;
    a1[2] = v17 + 1;
  }
  if ( a2 )
  {
    for ( result = 0LL; result != 8; ++result )
      *(double *)(a2 + 8 * result) = (double)a1[result];
  }
  return result;
}
// 41E250: variable 'v14' is possibly undefined
// 41E269: variable 'v15' is possibly undefined
// 41E291: variable 'v17' is possibly undefined

//----- (000000000041E321) ----------------------------------------------------
double __fastcall sub_41E321(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  char v3; // r12
  __int64 v4; // rbx
  double v5; // xmm0_8
  double v6; // xmm5_8
  double v7; // xmm1_8
  double v8; // xmm6_8
  double v9; // xmm0_8
  double v10; // xmm3_8
  _BOOL4 v11; // eax
  __int64 i; // rcx
  double v13; // xmm1_8
  int v14; // er13
  int v15; // er12
  int v16; // ebx
  int v17; // eax
  double v19; // [rsp+8h] [rbp-38h]
  double v20; // [rsp+10h] [rbp-30h]
  double v21; // [rsp+10h] [rbp-30h]
  double v22; // [rsp+18h] [rbp-28h]

  v2 = 0LL;
  v3 = a2;
  v4 = a1;
  do
  {
    v5 = *(double *)(a1 + 8 * v2);
    v6 = 1.797693134862316e308;
    if ( fabs(v5) <= 1.797693134862316e308 )
    {
      sub_417A0C(a1, a2, v5);
      *(double *)(a1 + 8 * v2) = v5;
      v6 = 1.797693134862316e308;
    }
    ++v2;
  }
  while ( v2 != 7 );
  v20 = *(double *)a1;
  v7 = NAN;
  v22 = 1000.0 * *(double *)(a1 + 40)
      + 3600000.0 * *(double *)(a1 + 24)
      + 0.0
      + 60000.0 * *(double *)(a1 + 32)
      + *(double *)(a1 + 48);
  if ( v6 >= fabs(*(double *)a1) )
  {
    v8 = *(double *)(a1 + 8);
    if ( v6 >= fabs(v8) )
    {
      v19 = *(double *)(a1 + 8);
      sub_42F94A(v8 / 12.0);
      v21 = v20 + v8 / 12.0;
      v9 = sub_42F9DE(v19, 12.0);
      if ( v9 < 0.0 )
        v9 = v9 + 12.0;
      if ( v21 < -271821.0 || v21 > 275760.0 )
      {
        v7 = NAN;
      }
      else
      {
        a1 = (unsigned int)(int)v21;
        v10 = *(double *)(v4 + 16);
        a2 = (unsigned int)sub_41E098(a1);
        v11 = sub_41E0FB(a1);
        for ( i = 0LL; (int)v9 > (int)i; ++i )
        {
          a1 = (unsigned __int8)byte_43F4B0[i];
          a2 = (unsigned int)(a1 + a2);
          if ( (_DWORD)i == 1 )
          {
            LOBYTE(a1) = v11;
            a2 = (unsigned int)a2 - (!v11 - 1);
          }
        }
        v7 = (double)(int)a2 + v10;
      }
    }
  }
  v13 = v7 * 86400000.0 + v22;
  if ( (v3 & 0x10) != 0 )
  {
    v14 = 4;
    v15 = 999999999;
    v16 = 0;
    do
    {
      v17 = sub_41EEA7(v13 - (double)(1000 * v16));
      if ( v17 == v16 )
        break;
      if ( v17 == v15 )
      {
        if ( v16 < v15 )
          v16 = v15;
        break;
      }
      --v14;
      v15 = v16;
      v16 = v17;
    }
    while ( v14 );
    v13 = v13 - (double)(1000 * v16);
  }
  return sub_41E05A(a1, a2, v13);
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041E537) ----------------------------------------------------
__int64 __fastcall sub_41E537(__int64 *a1, __m128 a2, __m128 a3)
{
  _BYTE *v3; // rax
  _BYTE *v4; // r8
  char v5; // dl
  _BOOL4 v6; // ebx
  int v7; // er10
  unsigned int v8; // eax
  int v9; // edx
  unsigned int v10; // esi
  int v11; // er9
  __int64 v13; // rax
  __int64 v14; // rdx
  int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // edx
  int v19; // eax
  __int64 i; // rax
  int v21; // [rsp+Ch] [rbp-74h] BYREF
  __int64 v22; // [rsp+10h] [rbp-70h]
  int v23; // [rsp+18h] [rbp-68h]
  int v24; // [rsp+1Ch] [rbp-64h]
  int v25; // [rsp+28h] [rbp-58h]
  int v26; // [rsp+2Ch] [rbp-54h]
  double v27[10]; // [rsp+30h] [rbp-50h] BYREF

  sub_43ABE2((__int64)&v21, 0LL, 0x24uLL);
  v5 = *v3;
  v22 = 0x100000001LL;
  v6 = 0;
  if ( v5 != 43 )
  {
    v6 = v5 == 45;
    if ( v5 != 45 )
      v4 = v3;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = (unsigned __int8)*v4++;
      if ( (unsigned __int8)(v11 - 48) > 9u )
        break;
      if ( v8 > 8 )
        return 0LL;
      if ( v10 != 6 || v8 <= 2 )
      {
        ++v8;
        v9 = 10 * v9 + v11 - 48;
      }
    }
    if ( !v8 )
      return 0LL;
    if ( v10 == 6 )
    {
      while ( v8 <= 2 )
      {
        v9 *= 10;
        ++v8;
      }
    }
    *(&v21 + v10) = v9;
    v13 = 0LL;
    while ( byte_43F4C0[v13] != (_BYTE)v11 )
    {
      if ( ++v13 == 8 )
        return 0LL;
    }
    v14 = 0LL;
    v15 = (1LL << ((unsigned __int8)v13 + 9)) + (1LL << v10);
    while ( 1 )
    {
      v16 = dword_43F480[v14];
      if ( (v16 & v15) == v15 )
        break;
      if ( ++v14 == 11 )
        return 0LL;
    }
    v17 = v16 >> 21;
    v10 = ((unsigned int)dword_43F480[v14] >> 17) & 0xF;
    if ( (v17 & 1) != 0 )
      v7 = v17 & 1;
    if ( (v17 & 2) != 0 )
      goto LABEL_28;
    v8 = v17 & 4;
    if ( v8 )
      break;
    if ( !(_BYTE)v11 )
      return 0LL;
    v9 = 0;
  }
  if ( *v4 )
    return 0LL;
LABEL_28:
  if ( v6 )
    v21 = -v21;
  if ( v7 )
  {
    v18 = v25 + v23;
    v19 = v26 + v24;
  }
  else
  {
    v18 = v23 - v25;
    v19 = v24 - v26;
  }
  v23 = v18;
  LODWORD(v22) = v22 - 1;
  --HIDWORD(v22);
  v24 = v19;
  for ( i = 0LL; i != 8; ++i )
    v27[i] = (double)*(&v21 + i);
  *(double *)a2.i64 = sub_41E321((__int64)v27, 0LL);
  sub_406A1B(a1, a2, a3);
  return 1LL;
}
// 41E566: variable 'v3' is possibly undefined
// 41E58E: variable 'v4' is possibly undefined
// 43F480: using guessed type int dword_43F480[];
// 41E537: using guessed type double var_50[10];

//----- (000000000041E6C9) ----------------------------------------------------
__int64 __fastcall sub_41E6C9(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  int v4; // ebx
  __int64 v5; // rdx
  __int64 v6; // rcx
  _DWORD *v7; // r13
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rcx
  char v13[96]; // [rsp+0h] [rbp-60h] BYREF

  v3 = sub_404AE7((__int64)a1);
  v4 = sub_41DC85((__int64)a1);
  sub_407003(a1, 805322880, 16, a2, a3);
  if ( v3 && v4 )
  {
    if ( v3 == 1 )
    {
      sub_406EB2(a1, 0, 0, a2, a3);
      v7 = sub_40573B((__int64)a1, 0);
      if ( v7 )
      {
        if ( !(unsigned int)sub_41E537(a1, a2, a3) && !(unsigned int)sub_41EFAF(a1, a2, a3) )
          sub_406B26(a1, (__int64)v7, v8, a2, a3);
        sub_405057(a1, 0, v8, v9, *(double *)a2.i64, a3);
      }
      sub_405C43(a1, 0, a2, a3);
      *(double *)a2.i64 = sub_41E05A((__int64)a1, 0LL, *(double *)a2.i64);
      sub_406A1B(a1, a2, a3);
      sub_403E13(a1, -33527295, a2, a3);
    }
    else
    {
      sub_41DF22(a1, (__int64)v13, v3, a2, a3);
      *(double *)a2.i64 = sub_41E321((__int64)v13, 16LL);
      sub_406A1B(a1, a2, a3);
      sub_404F67(a1, a2, a3);
      sub_403E13(a1, -50304511, a2, a3);
      sub_407D7E(a1, 4244662785LL, v10, v11, a2, a3);
    }
  }
  else
  {
    sub_41DD9B((__int64)a1, 805322880LL, v5, v6);
    *(double *)a2.i64 = sub_41E05A((__int64)a1, 805322880LL, *(double *)a2.i64);
    sub_406A1B(a1, a2, a3);
    sub_403E13(a1, -33527295, a2, a3);
    if ( !v4 )
      sub_408725(a1, -1, a2, a3);
  }
  return 1LL;
}
// 41E709: variable 'v5' is possibly undefined
// 41E709: variable 'v6' is possibly undefined
// 41E785: variable 'v8' is possibly undefined
// 41E78F: variable 'v9' is possibly undefined
// 41E7F7: variable 'v10' is possibly undefined
// 41E7F7: variable 'v11' is possibly undefined

//----- (000000000041E80C) ----------------------------------------------------
__int64 __fastcall sub_41E80C(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // r13
  __int64 v4; // rdx

  v3 = sub_408725(a1, 0, a2, a3);
  if ( !(unsigned int)sub_41E537(a1, a2, a3) && !(unsigned int)sub_41EFAF(a1, a2, a3) )
    sub_406B26(a1, v3, v4, a2, a3);
  return 1LL;
}
// 41E842: variable 'v4' is possibly undefined

//----- (000000000041E852) ----------------------------------------------------
__int64 __fastcall sub_41E852(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  __int64 v5; // rdx
  char v7[80]; // [rsp+0h] [rbp-50h] BYREF

  v4 = sub_404AE7((__int64)a1);
  if ( v4 > 1 )
  {
    sub_41DF22(a1, (__int64)v7, v4, a3, a4);
    *(double *)a3.i64 = sub_41E321((__int64)v7, 0LL);
    sub_406A1B(a1, a3, a4);
  }
  else
  {
    sub_406B26(a1, a2, v5, a3, a4);
  }
  return 1LL;
}
// 41E86C: variable 'v5' is possibly undefined

//----- (000000000041E8A1) ----------------------------------------------------
__int64 __fastcall sub_41E8A1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  sub_41DD9B((__int64)a1, a2, a3, a4);
  sub_406A1B(a1, a5, a6);
  return 1LL;
}

//----- (000000000041E8C2) ----------------------------------------------------
__int64 __fastcall sub_41E8C2(__int64 *a1, __m128 a2, __m128 a3)
{
  __int16 v3; // r14
  int v4; // ebx
  char *v5; // rdx
  char *v6; // r9
  __int64 v7; // rdx
  __int64 v9; // [rsp-10h] [rbp-90h]
  int v10; // [rsp+4h] [rbp-7Ch] BYREF
  char v11[8]; // [rsp+8h] [rbp-78h] BYREF
  __int16 v12[3]; // [rsp+10h] [rbp-70h] BYREF
  char v13; // [rsp+17h] [rbp-69h]
  unsigned int v14; // [rsp+18h] [rbp-68h] BYREF
  unsigned int v15; // [rsp+1Ch] [rbp-64h]
  unsigned int v16; // [rsp+20h] [rbp-60h]
  unsigned int v17; // [rsp+24h] [rbp-5Ch]
  unsigned int v18; // [rsp+28h] [rbp-58h]
  unsigned int v19; // [rsp+2Ch] [rbp-54h]
  unsigned int v20; // [rsp+30h] [rbp-50h]
  char v21[72]; // [rsp+38h] [rbp-48h] BYREF

  v3 = word_43F420[(unsigned int)sub_41DCD3((__int64)a1)];
  v10 = 0;
  sub_41DF78(a1, v3, &v10, a2, a3);
  sub_41E185((int *)&v14, 0LL, 4, *(double *)a2.i64);
  if ( (v3 & 0x100) == 0 || !(unsigned int)sub_41F058(a1, a2, a3) )
  {
    v4 = v10;
    v5 = "%04ld";
    if ( v14 > 0x270F )
    {
      v5 = "+%06ld";
      if ( (v14 & 0x80000000) != 0 )
        v5 = "%07ld";
    }
    sub_438FFB((__int64)v11, 8LL, v5, (int)v14);
    v11[7] = 0;
    if ( (v3 & 0x10) != 0 )
    {
      v6 = "+%02d:%02d";
      if ( v4 < 0 )
      {
        v4 = -v4;
        v6 = "-%02d:%02d";
      }
      sub_438FFB((__int64)v12, 8LL, v6, (v4 / 60 / 60) & 0x3F, (unsigned int)(v4 / 60 % 60));
      v13 = 0;
    }
    else
    {
      v12[0] = 90;
    }
    if ( (v3 & 0xC0) == 192 )
    {
      sub_4390BD(
        (__int64)v21,
        "%s-%02d-%02d%c%02d:%02d:%02d.%03d%s",
        v11,
        v15,
        v16,
        (unsigned int)((v3 & 0x800) == 0 ? 32 : 84),
        v17,
        v18,
        v19,
        v20,
        (const char *)v12);
    }
    else if ( (v3 & 0x40) != 0 )
    {
      sub_4390BD((__int64)v21, "%s-%02d-%02d", v11, v15, v16);
    }
    else
    {
      sub_4390BD((__int64)v21, "%02d:%02d:%02d.%03d%s", v17, v18, v19, v20, (const char *)v12);
      v7 = v9;
    }
    sub_406D71(a1, (__int64)v21, v7, a2, a3);
  }
  return 1LL;
}
// 41EA77: variable 'v9' is possibly undefined
// 41EA80: variable 'v7' is possibly undefined
// 43F420: using guessed type __int16 word_43F420[];

//----- (000000000041EA97) ----------------------------------------------------
__int64 __fastcall sub_41EA97(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_41DF78(a1, 0, 0LL, a2, a3);
  sub_406A1B(a1, a2, a3);
  return 1LL;
}

//----- (000000000041EABC) ----------------------------------------------------
__int64 __fastcall sub_41EABC(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rdx
  __int64 v8; // rcx

  sub_406FB2(a1, a2, a3);
  sub_408290(a1, -1, a2, a3, v3, v4, v5, v6);
  sub_404F67(a1, a2, a3);
  sub_406EB2(a1, -1, 2, a2, a3);
  if ( sub_4064DB((__int64)a1, -1)
    && (*(double *)a2.i64 = sub_40541C((__int64)a1, -1),
        a2 = _mm_and_ps(a2, (__m128)xmmword_43EEA0),
        *(double *)a3.i64 = 1.797693134862316e308,
        *(double *)a2.i64 > 1.797693134862316e308) )
  {
    sub_40691D(a1, 0xFFFFFFFFLL, v7, a2, a3);
  }
  else
  {
    sub_407D7E(a1, 0xFFFFFFFFLL, v7, v8, a2, a3);
    sub_4037B9(a1, -65494, a2, a3);
    sub_404FF1(a1, a2, a3);
    sub_41DA64(a1, 0, a2, a3);
  }
  return 1LL;
}
// 41EAD1: variable 'v3' is possibly undefined
// 41EAD1: variable 'v4' is possibly undefined
// 41EAD1: variable 'v5' is possibly undefined
// 41EAD1: variable 'v6' is possibly undefined
// 41EB20: variable 'v7' is possibly undefined
// 41EB2A: variable 'v8' is possibly undefined
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041EB58) ----------------------------------------------------
__int64 __fastcall sub_41EB58(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  unsigned int v4; // er13
  int v5; // esi
  int v7[16]; // [rsp+0h] [rbp-40h] BYREF

  v3 = sub_41DCD3((__int64)a1);
  v4 = (unsigned __int16)word_43F420[v3];
  sub_41DF78(a1, word_43F420[v3], 0LL, a2, a3);
  sub_41E185(v7, 0LL, v4, *(double *)a2.i64);
  v5 = v7[v4 >> 12];
  if ( (v4 & 0x20) != 0 )
    v5 -= 1900;
  sub_406A68(a1, v5, a2, a3);
  return 1LL;
}
// 43F420: using guessed type __int16 word_43F420[];
// 41EB58: using guessed type int var_40[16];

//----- (000000000041EBDA) ----------------------------------------------------
__int64 __fastcall sub_41EBDA(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  sub_41DF78(a1, 0, 0LL, a2, a3);
  v3 = sub_41EEA7(*(double *)a2.i64);
  sub_406A68(a1, -v3 / 60, a2, a3);
  return 1LL;
}

//----- (000000000041EC20) ----------------------------------------------------
__int64 __fastcall sub_41EC20(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // er13
  __int64 v4; // rsi
  __int64 v5; // rdx
  unsigned int v6; // er14
  __m128 v7; // xmm1
  int v8; // eax
  unsigned int v9; // eax
  unsigned int i; // er15
  unsigned int v12; // [rsp+0h] [rbp-A0h]
  signed int v13; // [rsp+4h] [rbp-9Ch]
  int v14[8]; // [rsp+10h] [rbp-90h] BYREF
  __int64 v15[14]; // [rsp+30h] [rbp-70h] BYREF

  v3 = (unsigned __int16)word_43F420[(unsigned int)sub_41DCD3((__int64)a1)];
  v13 = sub_404AE7((__int64)a1);
  v4 = v3;
  sub_41DF78(a1, v3, 0LL, a2, a3);
  v6 = v3 >> 12;
  v7 = _mm_and_ps(a2, (__m128)xmmword_43EEA0);
  if ( *(double *)v7.i64 <= 1.797693134862316e308 )
  {
    v4 = (__int64)v15;
    sub_41E185(v14, (__int64)v15, v3, *(double *)a2.i64);
  }
  v8 = 7;
  if ( (v3 & 0x200) == 0 )
    v8 = 3;
  v9 = v8 - v6;
  for ( i = 0; v6 != i && v13 > (int)i; ++i )
  {
    if ( !v9 && (v3 & 0x400) != 0 )
    {
      sub_41DE9A(a1, i, a2, v7);
      v9 = 0;
    }
    v4 = i;
    v12 = v9;
    sub_405C43(a1, i, a2, v7);
    v15[v12] = a2.i64[0];
    if ( v12 == 2 )
    {
      *(double *)a2.i64 = *(double *)a2.i64 - 1.0;
      v15[2] = a2.i64[0];
    }
    v9 = v12 + 1;
  }
  if ( *(double *)v7.i64 > 1.797693134862316e308 )
  {
    sub_406B26(a1, v4, v5, a2, v7);
  }
  else
  {
    *(double *)a2.i64 = sub_41E321((__int64)v15, v3);
    sub_406A1B(a1, a2, v7);
    sub_404F67(a1, a2, v7);
    sub_403E13(a1, -50304511, a2, v7);
  }
  return 1LL;
}
// 41ED5D: variable 'v5' is possibly undefined
// 43EEA0: using guessed type __int128 xmmword_43EEA0;
// 43F420: using guessed type __int16 word_43F420[];
// 41EC20: using guessed type int var_90[8];

//----- (000000000041ED76) ----------------------------------------------------
__int64 __fastcall sub_41ED76(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_41DF78(a1, 0, 0LL, a2, a3);
  sub_405C43(a1, 0, a2, a3);
  *(double *)a2.i64 = sub_41E05A((__int64)a1, 0LL, *(double *)a2.i64);
  sub_406A1B(a1, a2, a3);
  sub_404F67(a1, a2, a3);
  sub_403E13(a1, -50304511, a2, a3);
  return 1LL;
}

//----- (000000000041EDBF) ----------------------------------------------------
__int64 __fastcall sub_41EDBF(_QWORD *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // rdi
  int v5; // eax
  int v6; // edx
  __int64 v8[3]; // [rsp+18h] [rbp-18h] BYREF

  sub_406FB2(a1, a2, a3);
  sub_4054BB(a1, -1, a2, a3);
  v4 = sub_40578B(a1, 0, v8, a2, a3);
  if ( v8[0] != 6 )
  {
    if ( v8[0] != 7 || (unsigned int)sub_43AD14(v4, "default") )
      goto LABEL_8;
    goto LABEL_9;
  }
  if ( !(unsigned int)sub_43AD14(v4, "string") )
  {
LABEL_9:
    v6 = 1;
    goto LABEL_10;
  }
  v5 = sub_43AD14(v4, "number");
  v6 = 2;
  if ( v5 )
  {
LABEL_8:
    sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_date.c", 1763, a2, a3);
    return 0LL;
  }
LABEL_10:
  sub_406EBC(a1, -1, v6, a2, a3);
  return 1LL;
}
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);
// 41EDBF: using guessed type __int64 var_18[3];

//----- (000000000041EE6B) ----------------------------------------------------
double __fastcall sub_41EE6B(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  double result; // xmm0_8
  __int64 v5; // [rsp+0h] [rbp-10h] BYREF
  __int64 v6; // [rsp+8h] [rbp-8h]

  result = 0.0;
  if ( !(unsigned int)sub_431EA9(&v5, 0LL, a3, a4) )
    return (double)(int)v5 * 1000.0 + (double)(int)v6 / 1000.0;
  return result;
}

//----- (000000000041EEA7) ----------------------------------------------------
__int64 __fastcall sub_41EEA7(double a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r12
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // [rsp-F0h] [rbp-F0h] BYREF
  int v11; // [rsp-E8h] [rbp-E8h] BYREF
  _BYTE v12[64]; // [rsp-C8h] [rbp-C8h] BYREF
  unsigned int v13[14]; // [rsp-88h] [rbp-88h] BYREF
  unsigned int v14[20]; // [rsp-50h] [rbp-50h] BYREF

  if ( fabs(a1) > 1.797693134862316e308 )
    return 0LL;
  if ( !(unsigned int)sub_41E147(a1) )
    return 0LL;
  sub_41E185(&v11, (__int64)v12, 8, a1);
  v10 = (unsigned int)(int)(sub_41E321((__int64)v12, 0LL) / 1000.0);
  sub_43ABE2((__int64)v13, 0LL, 0x70uLL);
  sub_43408C(&v10, (__int64)v13);
  sub_434061(&v10, (char *)v14, v2, v3);
  v13[8] = 0;
  v14[8] = 0;
  v6 = sub_434096(v13, (char *)v14, v4, v5);
  v9 = sub_434096(v14, (char *)v14, v7, v8);
  if ( v6 == -1 || v9 == -1 )
    return 0LL;
  return (unsigned int)(int)sub_431EA0(v9, v6);
}
// 41EF57: variable 'v2' is possibly undefined
// 41EF57: variable 'v3' is possibly undefined
// 41EF6D: variable 'v4' is possibly undefined
// 41EF6D: variable 'v5' is possibly undefined
// 41EF79: variable 'v7' is possibly undefined
// 41EF79: variable 'v8' is possibly undefined
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041EFAF) ----------------------------------------------------
__int64 __fastcall sub_41EFAF(__int64 *a1, __m128 a2, __m128 a3)
{
  const char *v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v7; // rax
  unsigned int v8[14]; // [rsp+8h] [rbp-98h] BYREF
  char v9[96]; // [rsp+40h] [rbp-60h] BYREF

  sub_43ABE2((__int64)v9, 0LL, 0x40uLL);
  sub_438FFB((__int64)v9, 64LL, "%s", v3);
  v9[63] = 0;
  sub_43ABE2((__int64)v8, 0LL, 0x38uLL);
  if ( !sub_43468F(v9, byte_43F548, (__int64)v8) )
    return 0LL;
  v8[8] = -1;
  v7 = sub_434096(v8, byte_43F548, v4, v5);
  if ( v7 < 0 )
    return 0LL;
  *(double *)a2.i64 = (double)(int)v7 * 1000.0;
  sub_406A1B(a1, a2, a3);
  return 1LL;
}
// 41EFEC: variable 'v3' is possibly undefined
// 41F027: variable 'v4' is possibly undefined
// 41F027: variable 'v5' is possibly undefined

//----- (000000000041F058) ----------------------------------------------------
__int64 __fastcall sub_41F058(__int64 *a1, __m128 a2, __m128 a3)
{
  int *v4; // rax
  int v5; // edx
  int v6; // edi
  int v7; // edx
  int v8; // edi
  __int64 v9; // rcx
  char v10; // r8
  char *v11; // rdx
  int v12; // eax
  __int64 v13; // rdx
  int v15[14]; // [rsp+8h] [rbp-88h] BYREF
  char v16[80]; // [rsp+40h] [rbp-50h] BYREF

  sub_43ABE2((__int64)v15, 0LL, 0x38uLL);
  v5 = v4[5];
  v6 = v4[1];
  v15[8] = 0;
  v15[0] = v5;
  v15[1] = v4[4];
  v15[2] = v4[3];
  v15[3] = v4[2];
  v7 = v6 - 1;
  v8 = *v4;
  LODWORD(v4) = v4[7];
  v15[4] = v7;
  v15[6] = (int)v4;
  v15[5] = v8 - 1900;
  sub_43ABE2((__int64)v16, 0LL, 0x40uLL);
  v11 = byte_43F548;
  if ( v12 != 192 )
  {
    v11 = byte_43F54B;
    if ( (v10 & 0x40) == 0 )
      v11 = "%X";
  }
  sub_434660(v16, 63LL, v11, v9);
  sub_406D71(a1, (__int64)v16, v13, a2, a3);
  return 1LL;
}
// 41F087: variable 'v4' is possibly undefined
// 41F0E5: variable 'v12' is possibly undefined
// 41F0E7: variable 'v10' is possibly undefined
// 41F101: variable 'v9' is possibly undefined
// 41F10C: variable 'v13' is possibly undefined

//----- (000000000041F120) ----------------------------------------------------
__int64 sub_41F120()
{
  return 0LL;
}

//----- (000000000041F123) ----------------------------------------------------
__int64 __fastcall sub_41F123(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  int v4; // ebx
  int v5; // esi
  __int64 v6; // rax
  __int64 v7; // rax

  v3 = 0;
  v4 = sub_404AE7((__int64)a1);
  while ( v3 < v4 )
  {
    v5 = v3++;
    sub_408725(a1, v5, a2, a3);
  }
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      sub_40500F(a1, 0);
      sub_406EC3(a1, (__int64)&word_43F54E, 1uLL, a2, a3);
      sub_40500F(a1, 1);
      sub_408F0F(a1, v4 - 1, a2, a3);
      goto LABEL_9;
    }
  }
  else
  {
    sub_407963(a1, a2, a3);
  }
  sub_407963(a1, a2, a3);
LABEL_9:
  sub_406EC3(a1, (__int64)"function(", 9uLL, a2, a3);
  sub_404FDD(a1, a2, a3);
  sub_406EC3(a1, (__int64)"){", 2uLL, a2, a3);
  sub_404FD6(a1, a2, a3);
  sub_406EC3(a1, (__int64)"\n}", 2uLL, a2, a3);
  sub_408E52(a1, 5, a2, a3);
  sub_407826(a1, 0x6Bu, a2, a3);
  v6 = sub_40574F(a1, -2, a2, a3);
  sub_4175F8(a1, v6 + 32, *(unsigned int *)(v6 + 24), 4096, a2, a3);
  sub_406EC3(a1, (__int64)"anonymous", 9uLL, a2, a3);
  sub_403E13(a1, -33530620, a2, a3);
  v7 = sub_405B41((__int64)a1, -1);
  sub_41843F(a1, v7, a1[21], a1[21], 1, a2, a3);
  return 1LL;
}
// 43F54E: using guessed type __int16 word_43F54E;

//----- (000000000041F274) ----------------------------------------------------
__int64 __fastcall sub_41F274(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rsi
  int v4; // eax
  int *v5; // rbx
  _BOOL4 v6; // eax
  char *v7; // rdx
  int v8; // eax
  char *v9; // rsi

  sub_406FB2(a1, a2, a3);
  v3 = a1[14];
  v4 = *(_DWORD *)(v3 - 16);
  if ( v4 == 9 )
  {
    v5 = *(int **)(v3 - 8);
    sub_4037B9(a1, -65443, a2, a3);
    v6 = sub_40649F((__int64)a1, -1);
    v7 = &byte_43DB77;
    if ( !v6 )
      v7 = (char *)sub_408725(a1, -1, a2, a3);
    v8 = *v5;
    v9 = "function %s() { [ecmascript code] }";
    if ( (*v5 & 0x800) != 0 )
      goto LABEL_8;
    v9 = "function %s() { [native code] }";
    if ( (v8 & 0x1000) != 0 )
      goto LABEL_8;
    if ( (v8 & 0x400) != 0 )
    {
      v9 = "function %s() { [bound code] }";
LABEL_8:
      sub_407AA3(a1, v9, v7);
      return 1LL;
    }
  }
  else if ( v4 == 6 )
  {
    sub_4086CB(a1, v3 - 16, a2, a3);
    return 1LL;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_function.c", 162, a2, a3);
  return 0LL;
}
// 43DB77: using guessed type char byte_43DB77;

//----- (000000000041F325) ----------------------------------------------------
__int64 sub_41F325()
{
  return 4294967290LL;
}

//----- (000000000041F32B) ----------------------------------------------------
__int64 sub_41F32B()
{
  return 4294967290LL;
}

//----- (000000000041F331) ----------------------------------------------------
__int64 sub_41F331()
{
  return 4294967290LL;
}

//----- (000000000041F337) ----------------------------------------------------
__int64 sub_41F337()
{
  return 4294967290LL;
}

//----- (000000000041F33D) ----------------------------------------------------
__int64 __fastcall sub_41F33D(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  __int64 v5; // rdx
  int v6; // er14
  int v7; // edx
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r13
  __int64 v13; // rdx
  __int128 v14; // xmm4
  __int64 v15; // rax
  __int64 v17; // rax
  __int64 v18; // r15
  int v19; // ebx
  int v20; // eax
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // [rsp+0h] [rbp-40h]

  v4 = sub_404AE7((__int64)a1);
  v6 = v4 - 1;
  if ( v4 - 1 < 0 )
  {
    v6 = v4;
    sub_4068D1(a1, a2, v5, a3, a4);
  }
  if ( v6 > 0x20000000 )
  {
    v7 = 227;
LABEL_21:
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_function.c", v7, "invalid count", a3, a4);
    return 0LL;
  }
  sub_406FB2(a1, a3, a4);
  sub_40661B(a1, -1, a3, a4);
  v8 = sub_407318(a1, a3, a4);
  a4 = *(__m128 *)a1[13];
  v9 = a1[14];
  *(__m128 *)(v8 + 72) = a4;
  *(_OWORD *)(v8 + 56) = *(_OWORD *)(v9 - 32);
  if ( *(_DWORD *)(v9 - 32) == 9 )
  {
    v10 = *(_QWORD *)(v9 - 24);
    v11 = *(_QWORD *)(v10 + 32);
    *(_QWORD *)(v8 + 32) = v11;
    if ( v11 )
      ++*(_DWORD *)(v11 + 4);
    if ( _bittest((const signed __int32 *)v10, 0x10u) )
      *(_DWORD *)v8 |= 0x10000u;
    if ( _bittest((const signed __int32 *)v10, 0xAu) )
    {
      v12 = *(int *)(v10 + 96);
      v13 = *(_QWORD *)(v10 + 88);
      v14 = *(_OWORD *)(v10 + 72);
      *(_OWORD *)(v8 + 56) = *(_OWORD *)(v10 + 56);
      *(_OWORD *)(v8 + 72) = v14;
      goto LABEL_15;
    }
  }
  else
  {
    v15 = a1[25];
    *(_DWORD *)v8 |= 0x10000u;
    *(_QWORD *)(v8 + 32) = v15;
    if ( v15 )
      ++*(_DWORD *)(v15 + 4);
  }
  v12 = 0LL;
  v13 = 0LL;
LABEL_15:
  if ( (*(_BYTE *)(v8 + 56) & 8) != 0 )
    ++*(_DWORD *)(*(_QWORD *)(v8 + 64) + 4LL);
  if ( (*(_BYTE *)(v8 + 72) & 8) != 0 )
    ++*(_DWORD *)(*(_QWORD *)(v8 + 80) + 4LL);
  if ( v6 + (int)v12 > 0x20000000 )
  {
    v7 = 316;
    goto LABEL_21;
  }
  v26 = v13;
  v17 = sub_402FA0(a1, 16LL * (v6 + (int)v12), a3, a4);
  *(_QWORD *)(v8 + 88) = v17;
  v18 = v17;
  *(_DWORD *)(v8 + 96) = v6 + v12;
  sub_408C9E((__int64)a1, v17, v26, v12);
  v19 = 0;
  sub_408C9E((__int64)a1, v18 + 16 * v12, a1[13] + 16, v6);
  sub_4037B9(a1, -130985, a3, a4);
  v20 = sub_405483(a1, -1, a3, a4);
  if ( v6 <= v20 )
    v19 = v20 - v6;
  sub_407D7E(a1, 0xFFFFFFFFLL, v21, v22, a3, a4);
  *(double *)a3.i64 = (double)v19;
  v23 = a1[14];
  a1[14] = v23 + 16;
  *(_DWORD *)v23 = 0;
  *(double *)(v23 + 8) = (double)v19;
  sub_403E13(a1, -33532156, a3, a4);
  sub_403F77(a1, -1, 0x45u, a3, a4);
  sub_403F77(a1, -1, 0x43u, a3, a4);
  sub_406EC3(a1, (__int64)"bound ", 6uLL, a3, a4);
  sub_40377C(a1, -3, 0x5Du, a3, a4);
  if ( !sub_406529((__int64)a1, -1) )
  {
    sub_407D7E(a1, 0xFFFFFFFFLL, v24, v25, a3, a4);
    sub_407963(a1, a3, a4);
  }
  sub_408E52(a1, 2, a3, a4);
  sub_403E13(a1, -33530620, a3, a4);
  sub_4037B9(a1, -130978, a3, a4);
  sub_403E13(a1, -33530364, a3, a4);
  return 1LL;
}
// 41F366: variable 'v5' is possibly undefined
// 41F4DB: variable 'v21' is possibly undefined
// 41F4DB: variable 'v22' is possibly undefined
// 41F560: variable 'v24' is possibly undefined
// 41F560: variable 'v25' is possibly undefined

//----- (000000000041F5B5) ----------------------------------------------------
__int64 __fastcall sub_41F5B5(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rax
  int v5; // esi

  v3 = sub_406FC3((__int64)a1);
  if ( *(_DWORD *)v3 == 9 )
  {
    v4 = *(_QWORD *)(v3 + 8);
    if ( _bittest((const signed __int32 *)v4, 0xCu) )
    {
      v5 = *(__int16 *)(v4 + 64);
      if ( *(_WORD *)(v4 + 64) == 0xFFFF )
        v5 = 0;
      sub_406A68(a1, v5, a2, a3);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)v3 == 6 )
  {
    sub_406AAF(a1, (*(_DWORD *)(v3 + 4) >> 4) & 0xF, a2, a3);
    return 1LL;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_function.c", 412, a2, a3);
  return 0LL;
}

//----- (000000000041F61B) ----------------------------------------------------
__int64 __fastcall sub_41F61B(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rsi

  v3 = sub_406FC3((__int64)a1);
  if ( *(_DWORD *)v3 == 9 )
  {
    if ( (**(_DWORD **)(v3 + 8) & 0x1000) != 0 )
    {
      sub_407963(a1, a2, a3);
      return 1LL;
    }
  }
  else if ( *(_DWORD *)v3 == 6 )
  {
    sub_4086BF(a1, v3, a2, a3);
    return 1LL;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_function.c", 441, a2, a3);
  return 0LL;
}

//----- (000000000041F671) ----------------------------------------------------
__int64 __fastcall sub_41F671(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  v3 = sub_417EE5((__int64 *)a1, *(__int128 **)(a1 + 104), (__int128 *)(*(_QWORD *)(a1 + 104) - 16LL), a2, a3);
  sub_406955((__int64 *)a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000041F69C) ----------------------------------------------------
_BYTE *__fastcall sub_41F69C(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, int a5)
{
  int v6; // edx
  _BYTE *result; // rax
  _BYTE *v8; // rax
  char v9; // dl
  __int64 v10; // rax
  char v11; // dl

  if ( (unsigned __int64)(a1[4] - a1[2]) <= 5 )
    sub_41CFE2((__int64 *)*a1, a1 + 2, 6LL, a2, a3);
  if ( a5 >= 0 )
  {
    if ( a5 <= 127 )
    {
      v6 = (unsigned __int8)byte_43F630[a5 >> 3];
      if ( _bittest(&v6, a5 & 7) )
      {
        result = (_BYTE *)a1[2];
        a1[2] = (__int64)(result + 1);
        *result = a5;
        return result;
      }
      goto LABEL_8;
    }
    if ( a5 <= 255 )
    {
LABEL_8:
      v8 = (_BYTE *)a1[2];
      v9 = byte_43F2C0[a5 >> 4];
      *v8 = 37;
      result = v8 + 3;
      *(result - 2) = v9;
      *(result - 1) = byte_43F2C0[a5 & 0xF];
LABEL_11:
      a1[2] = (__int64)result;
      return result;
    }
    if ( a5 <= 0xFFFF )
    {
      v10 = a1[2];
      v11 = byte_43F2C0[a5 >> 12];
      *(_WORD *)v10 = 29989;
      result = (_BYTE *)(v10 + 6);
      *(result - 4) = v11;
      *(result - 3) = byte_43F2C0[(a5 >> 8) & 0xF];
      *(result - 2) = byte_43F2C0[(a5 >> 4) & 0xF];
      *(result - 1) = byte_43F2C0[a5 & 0xF];
      goto LABEL_11;
    }
  }
  return (_BYTE *)sub_401C42(
                    (__int64 *)*a1,
                    (__int64)"third_party/duktape/duk_bi_global.c",
                    0x60001AFu,
                    "invalid input",
                    a2,
                    a3);
}

//----- (000000000041F7B1) ----------------------------------------------------
__int64 __fastcall sub_41F7B1(__int64 a1, int a2)
{
  __int64 v2; // rdx
  __int64 result; // rax
  int v4; // eax
  int v5; // ecx

  v2 = 0LL;
  LODWORD(result) = 0;
  while ( 1 )
  {
    v4 = 16 * result;
    v5 = byte_44E328[*(unsigned __int8 *)(a1 + v2)];
    if ( v5 < 0 )
      break;
    result = (unsigned int)(v5 + v4);
    if ( a2 - (int)++v2 <= 0 )
      return result;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000041F7D9) ----------------------------------------------------
__int64 __fastcall sub_41F7D9(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, unsigned int a5)
{
  unsigned int v5; // er12
  _BYTE *v6; // r8
  unsigned __int64 v7; // rax
  int v8; // eax
  __int64 v9; // r8
  __int64 v10; // r8
  __int64 result; // rax

  v5 = a5;
  if ( a5 == 37 )
  {
    v6 = (_BYTE *)a1[6];
    v7 = a1[8] - (_QWORD)v6;
    if ( v7 <= 4 )
    {
      if ( v7 <= 1 )
        goto LABEL_10;
    }
    else if ( *v6 == 117 )
    {
      v8 = sub_41F7B1((__int64)(v6 + 1), 4);
      if ( v8 >= 0 )
      {
        v9 = (__int64)(v6 + 5);
LABEL_9:
        a1[6] = v9;
        v5 = v8;
        goto LABEL_10;
      }
    }
    v8 = sub_41F7B1((__int64)v6, 2);
    if ( v8 < 0 )
      goto LABEL_10;
    v9 = v10 + 2;
    goto LABEL_9;
  }
LABEL_10:
  if ( (unsigned __int64)(a1[4] - a1[2]) <= 6 )
    sub_41CFE2((__int64 *)*a1, a1 + 2, 7LL, a2, a3);
  result = (int)sub_41C531(v5, (_BYTE *)a1[2]);
  a1[2] += (int)result;
  return result;
}
// 41F814: variable 'v6' is possibly undefined
// 41F831: variable 'v10' is possibly undefined

//----- (000000000041F872) ----------------------------------------------------
__int64 __fastcall sub_41F872(
        __int64 *a1,
        void (__fastcall *a2)(__int64 **, __int64, _QWORD),
        __int64 a3,
        __m128 a4,
        __m128 a5)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rdx
  unsigned int v9; // eax
  __int64 *v11; // [rsp+8h] [rbp-68h] BYREF
  __int64 v12; // [rsp+10h] [rbp-60h]
  __int64 v13[4]; // [rsp+18h] [rbp-58h] BYREF
  unsigned __int64 v14; // [rsp+38h] [rbp-38h] BYREF
  unsigned __int64 v15; // [rsp+40h] [rbp-30h]
  unsigned __int64 v16; // [rsp+48h] [rbp-28h]

  v11 = a1;
  v6 = sub_408998(a1, 0, a4, a5);
  v7 = *(unsigned int *)(v6 + 24);
  v12 = v6;
  sub_41CF97(a1, v13, v7, a4, a5);
  v8 = *(unsigned int *)(v12 + 24);
  v15 = v12 + 32;
  v14 = v12 + 32;
  v16 = v12 + 32 + v8;
  while ( v14 < v16 )
  {
    v9 = sub_41C85D(a1, &v14, v15, v16, a4, a5);
    a2(&v11, a3, v9);
  }
  sub_41D054(a1, v13, a4, a5);
  sub_406BF4(a1, -1, a4, a5);
  return 1LL;
}
// 41F872: using guessed type _QWORD var_58[4];

//----- (000000000041F90E) ----------------------------------------------------
_BYTE *__fastcall sub_41F90E(_QWORD *a1, __int64 a2, signed int a3, __m128 a4, __m128 a5)
{
  int v7; // edx
  _BYTE *result; // rax
  __int64 v9; // rcx
  unsigned __int8 v10; // si
  _BYTE *v11; // rdx
  char v12; // di
  int v13; // [rsp+4h] [rbp-2Ch] BYREF
  char v14[39]; // [rsp+9h] [rbp-27h] BYREF

  if ( a1[4] - a1[2] <= 0x14uLL )
    sub_41CFE2((__int64 *)*a1, a1 + 2, 21LL, a4, a5);
  if ( a3 < 0 )
    return (_BYTE *)sub_401C42(
                      (__int64 *)*a1,
                      (__int64)"third_party/duktape/duk_bi_global.c",
                      0x70000FAu,
                      "invalid input",
                      a4,
                      a5);
  if ( a3 <= 127 )
  {
    v7 = *(unsigned __int8 *)(a2 + (a3 >> 3));
    if ( _bittest(&v7, a3 & 7) )
    {
      result = (_BYTE *)a1[2];
      a1[2] = result + 1;
      *result = a3;
      return result;
    }
  }
  if ( (unsigned int)(a3 - 56320) <= 0x3FF )
    return (_BYTE *)sub_401C42(
                      (__int64 *)*a1,
                      (__int64)"third_party/duktape/duk_bi_global.c",
                      0x70000FAu,
                      "invalid input",
                      a4,
                      a5);
  if ( (unsigned int)(a3 - 55296) <= 0x3FF )
  {
    if ( (unsigned int)sub_41C7A1(*a1, a1 + 6, a1[7], a1[8], &v13) && (unsigned int)(v13 - 56320) <= 0x3FF )
    {
      a3 = v13 + ((a3 - 55296) << 10) + 9216;
      goto LABEL_13;
    }
    return (_BYTE *)sub_401C42(
                      (__int64 *)*a1,
                      (__int64)"third_party/duktape/duk_bi_global.c",
                      0x70000FAu,
                      "invalid input",
                      a4,
                      a5);
  }
  if ( a3 > 1114111 )
    return (_BYTE *)sub_401C42(
                      (__int64 *)*a1,
                      (__int64)"third_party/duktape/duk_bi_global.c",
                      0x70000FAu,
                      "invalid input",
                      a4,
                      a5);
LABEL_13:
  result = (_BYTE *)sub_41C531(a3, v14);
  v9 = 0LL;
  while ( (int)result > (int)v9 )
  {
    v10 = v14[v9];
    v11 = (_BYTE *)a1[2];
    ++v9;
    *v11 = 37;
    v11 += 3;
    v12 = byte_43F2C0[v10 >> 4];
    *(v11 - 1) = byte_43F2C0[v10 & 0xF];
    *(v11 - 2) = v12;
    a1[2] = v11;
  }
  return result;
}
// 41F90E: using guessed type int var_2C;
// 41F90E: using guessed type char var_27[39];

//----- (000000000041FA57) ----------------------------------------------------
__int64 __fastcall sub_41FA57(
        __int64 *a1,
        __int64 a2,
        unsigned int a3,
        __m128 a4,
        __m128 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  _BYTE *v10; // rdi
  int v11; // eax
  unsigned __int64 v12; // r9
  _BYTE *v13; // rdx
  int v14; // esi
  __int64 v15; // rdx
  int v16; // er12
  int v17; // eax
  __int64 i; // r10
  int v19; // eax
  __int64 v20; // r9
  __int64 v21; // r10
  int v22; // er11
  _BYTE *v23; // rsi
  unsigned int v24; // edi
  int v25; // er12

  if ( (unsigned __int64)(a1[4] - a1[2]) <= 6 )
    sub_41CFE2((__int64 *)*a1, a1 + 2, 7LL, a4, a5);
  if ( a3 != 37 )
  {
    v23 = (_BYTE *)a1[2];
    v24 = a3;
LABEL_31:
    a1[2] += (int)sub_41C531(v24, v23);
    return a8;
  }
  v10 = (_BYTE *)a1[6];
  if ( (unsigned __int64)(a1[8] - (_QWORD)v10) <= 1 )
    return sub_401C42(
             (__int64 *)*a1,
             (__int64)"third_party/duktape/duk_bi_global.c",
             0x7000186u,
             "invalid input",
             a4,
             a5);
  v11 = sub_41F7B1((__int64)v10, 2);
  if ( v11 < 0 )
    return sub_401C42(
             (__int64 *)*a1,
             (__int64)"third_party/duktape/duk_bi_global.c",
             0x7000186u,
             "invalid input",
             a4,
             a5);
  if ( v11 > 127 )
  {
    if ( v11 > 191 )
    {
      if ( v11 <= 223 )
      {
        v16 = v11 & 0x1F;
        v17 = 2;
        goto LABEL_18;
      }
      if ( v11 <= 239 )
      {
        v16 = v11 & 0xF;
        v17 = 3;
        goto LABEL_18;
      }
      if ( v11 <= 247 )
      {
        v16 = v11 & 7;
        v17 = 4;
LABEL_18:
        if ( v12 >= (unsigned int)(3 * v17 - 1) )
        {
          for ( i = (__int64)(v10 + 3); ; i = v21 + 3 )
          {
            v19 = sub_41F7B1(i, 2);
            if ( v19 < 0 || (v19 & 0xC0) != 128 )
              break;
            v16 = (v19 & 0x3F) + (v16 << 6);
            if ( v21 + 3 == v20 )
            {
              a1[6] = v21 + 2;
              if ( v16 < v22 || v16 > 1114111 || (unsigned int)(v16 - 55296) <= 0x7FF )
                return sub_401C42(
                         (__int64 *)*a1,
                         (__int64)"third_party/duktape/duk_bi_global.c",
                         0x7000186u,
                         "invalid input",
                         a4,
                         a5);
              v23 = (_BYTE *)a1[2];
              v24 = v16;
              if ( v16 > 0xFFFF )
              {
                v25 = v16 - 0x10000;
                v23 = (_BYTE *)(a1[2] + (int)sub_41C531((v25 >> 10) + 55296, v23));
                v24 = (v25 & 0x3FF) + 56320;
                a1[2] = (__int64)v23;
              }
              goto LABEL_31;
            }
          }
        }
      }
    }
    return sub_401C42(
             (__int64 *)*a1,
             (__int64)"third_party/duktape/duk_bi_global.c",
             0x7000186u,
             "invalid input",
             a4,
             a5);
  }
  v13 = (_BYTE *)a1[2];
  v14 = *(unsigned __int8 *)(a2 + (v11 >> 3));
  if ( _bittest(&v14, v11 & 7) )
  {
    *v13 = 37;
    v15 = (__int64)(v13 + 3);
    *(_BYTE *)(v15 - 2) = *v10;
    *(_BYTE *)(v15 - 1) = v10[1];
    a1[2] = v15;
  }
  else
  {
    a1[2] = (__int64)(v13 + 1);
    *v13 = v11;
  }
  a1[6] += 2LL;
  return a8;
}
// 41FB6A: variable 'v12' is possibly undefined
// 41FBB0: variable 'v21' is possibly undefined
// 41FBB7: variable 'v20' is possibly undefined
// 41FBC9: variable 'v22' is possibly undefined

//----- (000000000041FC62) ----------------------------------------------------
__int64 __fastcall sub_41FC62(__int64 *a1, __m128 a2, __m128 a3, __m128 a4)
{
  _DWORD *v4; // rax
  __int64 v5; // r15
  _DWORD *v6; // r13
  int v7; // er14
  __int64 v8; // rax
  _QWORD *v9; // rbx
  _DWORD *v10; // r14
  int v11; // eax
  int *v12; // r13
  __int64 v13; // r9
  int v14; // edx
  __int64 v16; // [rsp+8h] [rbp-38h]
  int v17; // [rsp+8h] [rbp-38h]

  v4 = sub_405717((__int64)a1, 0);
  if ( v4 )
  {
    v5 = a1[15];
    v6 = v4;
    v7 = 8;
    v8 = sub_412200((__int64)a1, -2);
    v9 = (_QWORD *)v8;
    if ( v8 && (*(_BYTE *)(v8 + 88) & 1) != 0 )
      v7 = (*(_DWORD *)(v5 + 88) & 0x10) == 0 ? 8 : 40;
    sub_407826(a1, 0x6Cu, a2, a3);
    sub_4175F8(a1, (__int64)(v6 + 8), (unsigned int)v6[6], v7, a2, a3);
    v10 = (_DWORD *)sub_405B41((__int64)a1, -1);
    if ( (*(_BYTE *)(v5 + 88) & 0x10) != 0 )
    {
      if ( !v9[5] )
        sub_418785((__int64)a1, v9, a2, a3);
      v11 = *v10 & 0x10000;
      if ( v11 )
      {
        v16 = v9[5];
        v12 = sub_40D66C(a1, -2147483520, a2, a3);
        sub_407C45(a1, (__int64)v12, a2, a3);
        *((_QWORD *)v12 + 4) = v16;
        if ( v16 )
          ++*(_DWORD *)(v16 + 4);
        sub_40500F(a1, 0);
        v13 = (__int64)v12;
        v11 = 0;
      }
      else
      {
        v13 = v9[4];
        v12 = (int *)v9[5];
      }
    }
    else
    {
      v12 = (int *)a1[21];
      v11 = 1;
      v13 = (__int64)v12;
    }
    v17 = v11;
    sub_41843F(a1, (__int64)v10, v13, (__int64)v12, 0, a2, a3);
    if ( v17 )
      sub_407CED(a1, 0, a2, a3);
    else
      sub_406883(a1, (__int128 *)(a1[10] + v9[8] - 16), a2, a3);
    v14 = *(_DWORD *)(v5 + 88) & 0x10;
    if ( v14 )
      v14 = 16;
    sub_421382((__int64)a1, 0, v14, a2, a3, a4);
  }
  return 1LL;
}

//----- (000000000041FDDE) ----------------------------------------------------
__int64 __fastcall sub_41FDDE(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  __int64 v4; // rdx
  int v5; // er13
  unsigned int v6; // er14

  sub_408725(a1, 0, a2, a3);
  v3 = sub_405E01(a1, 1, a2, a3);
  if ( !v3 )
  {
    v6 = 3101;
    v5 = 10;
LABEL_8:
    sub_404FD6(a1, a2, a3);
    sub_41B6EB(a1, v5, v6, a2, a3);
    return 1LL;
  }
  v5 = v3;
  if ( (unsigned int)(v3 - 2) <= 0x22 )
  {
    v6 = 3101;
    if ( v3 != 16 )
      v6 = 1053;
    goto LABEL_8;
  }
  sub_406B26(a1, 1LL, v4, a2, a3);
  return 1LL;
}
// 41FE12: variable 'v4' is possibly undefined

//----- (000000000041FE5E) ----------------------------------------------------
__int64 __fastcall sub_41FE5E(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_408725(a1, 0, a2, a3);
  sub_41B6EB(a1, 10, 0x5FFu, a2, a3);
  return 1LL;
}

//----- (000000000041FE8B) ----------------------------------------------------
__int64 __fastcall sub_41FE8B(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_405C43(a1, 0, a2, a3);
  sub_406955(a1, 0, a2, a3);
  return 1LL;
}

//----- (000000000041FEB8) ----------------------------------------------------
__int64 __fastcall sub_41FEB8(__int64 *a1, __m128 a2, __m128 a3)
{
  __m128 v3; // xmm0

  sub_405C43(a1, 0, a2, a3);
  v3 = _mm_and_ps(a2, (__m128)xmmword_43EEA0);
  *(double *)a3.i64 = 1.797693134862316e308;
  sub_406955(a1, *(double *)v3.i64 <= 1.797693134862316e308, v3, a3);
  return 1LL;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000041FEF4) ----------------------------------------------------
__int64 __fastcall sub_41FEF4(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_41F872(a1, (void (__fastcall *)(__int64 **, __int64, _QWORD))sub_41FA57, (__int64)qword_43F650, a2, a3);
}
// 43F650: using guessed type __int64 qword_43F650[2];

//----- (000000000041FF48) ----------------------------------------------------
__int64 __fastcall sub_41FF48(__int64 *a1, __int64 a2, char a3, __m128 a4, __m128 a5)
{
  int v6; // er14
  int v7; // er13
  __int64 result; // rax
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  _DWORD *v14; // r9
  __int64 v15; // rax
  _DWORD *v16; // [rsp+0h] [rbp-70h]
  int v17; // [rsp+Ch] [rbp-64h]
  char v18[88]; // [rsp+18h] [rbp-58h] BYREF

  v6 = 0;
  v7 = 0;
  v17 = sub_405CB0(a1, 0xFFFFFFFF, a4, a5);
  sub_4070BA(a1, a4, a5);
  result = a3 & 1;
  while ( v7 != v17 )
  {
    sub_40370E(a1, -2, v7, a4, a5);
    v10 = 0xFFFFFFFFLL;
    v11 = sub_40568B((__int64)a1, -1);
    v14 = (_DWORD *)v11;
    if ( !v11 )
      return sub_401D32(a1, (__int64)"third_party/duktape/duk_bi_proxy.c", 30, a4, a5);
    if ( (a3 & 1) != 0
      || (v16 = (_DWORD *)v11,
          v15 = sub_405B3C((__int64)a1, -1),
          v10 = a2,
          (unsigned int)sub_40E722(a1, a2, v15, (__int64)v18, 0, a4, a5))
      && (v14 = v16, (v18[0] & 2) != 0) )
    {
      if ( (*v14 & 0x200) != 0 )
      {
        if ( (a3 & 4) != 0 && ((*v14 & 0x400) == 0 || (a3 & 2) != 0) )
        {
LABEL_16:
          result = sub_403953(a1, -2, v6++, a4, a5);
          goto LABEL_18;
        }
      }
      else if ( (a3 & 8) == 0 )
      {
        goto LABEL_16;
      }
    }
    result = sub_407D7E(a1, v10, v12, v13, a4, a5);
LABEL_18:
    ++v7;
  }
  return result;
}
// 420042: variable 'v12' is possibly undefined
// 420042: variable 'v13' is possibly undefined
// 41FF48: using guessed type char var_58[88];

//----- (000000000042005E) ----------------------------------------------------
__int64 __fastcall sub_42005E(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8

  sub_41DC9A(a1, a2, a3);
  sub_40849B(a1, a2, a3, 0LL, v3, v4, v5);
  return 1LL;
}
// 420075: variable 'v3' is possibly undefined
// 420075: variable 'v4' is possibly undefined
// 420075: variable 'v5' is possibly undefined

//----- (0000000000420081) ----------------------------------------------------
void __fastcall sub_420081(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rdx

  v6 = sub_4030A6(a1[8], sub_40BC90, a2, a3, a4, a5);
  if ( !v6 && a3 )
  {
    sub_401CC7(a1, (__int64)"third_party/duktape/duk_hbuffer_ops.c", 64, a4, a5);
  }
  else
  {
    v7 = *(_QWORD *)(a2 + 24);
    if ( a3 > v7 )
      sub_43ABE2(v6 + v7, 0LL, a3 - v7);
    *(_QWORD *)(a2 + 24) = a3;
    *(_QWORD *)(a2 + 32) = v6;
  }
}
// 4200D5: variable 'v6' is possibly undefined

//----- (00000000004200FB) ----------------------------------------------------
void __fastcall sub_4200FB(__int64 *a1, __int64 a2, unsigned __int64 a3, __m128 a4, __m128 a5)
{
  if ( a3 <= 0x7FFFFFFE )
    sub_420081(a1, a2, a3, a4, a5);
  else
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_hbuffer_ops.c", 26, "buffer too long", a4, a5);
}

//----- (000000000042011D) ----------------------------------------------------
void __fastcall sub_42011D(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  sub_420081(a1, a2, 0LL, a3, a4);
}

//----- (0000000000420124) ----------------------------------------------------
__int64 __fastcall sub_420124(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rcx
  __int64 result; // rax
  int v5; // edi

  v3 = (a3 >> 5) + 1;
  result = (unsigned int)a3 ^ *(_DWORD *)(a1 + 208);
  while ( a3 >= v3 )
  {
    v5 = *(unsigned __int8 *)(a2 + a3 - 1);
    a3 -= v3;
    result = (unsigned int)(v5 + 33 * result);
  }
  return result;
}

//----- (000000000042014B) ----------------------------------------------------
__int64 __fastcall sub_42014B(__int64 *a1, __int64 a2, unsigned int a3, __m128 a4, __m128 a5)
{
  unsigned int v5; // ebx
  unsigned __int64 v6; // r15
  __int64 v7; // r14
  __int64 v8; // rcx
  int v9; // eax
  unsigned int v10; // er9
  __int64 v11; // rcx
  unsigned int v12; // esi
  int v13; // edx
  int v14; // esi
  unsigned int v18; // [rsp+18h] [rbp-68h]
  __int64 v19; // [rsp+28h] [rbp-58h] BYREF
  int v20; // [rsp+30h] [rbp-50h]
  __int64 v21; // [rsp+38h] [rbp-48h]

  v5 = 0;
  v6 = 8 * ((a3 + 63) >> 6) + 4;
  sub_40762B(a1, v6, 1, a4, a5);
  v7 = sub_405B46((__int64)a1, -1);
  **(_DWORD **)(v7 + 32) = a3;
  while ( v5 < a3 )
  {
    sub_4200FB(a1, v7, (unsigned int)(v6 + 276), a4, a5);
    v8 = *(_QWORD *)(v7 + 32);
    v9 = 2 * (v5 >> 6);
    *(_DWORD *)(v8 + 4LL * (unsigned int)(v9 + 1)) = *(_DWORD *)(a2 + 8LL * v5 + 4);
    *(_DWORD *)(v8 + 4LL * (unsigned int)(v9 + 2)) = v6;
    sub_43ABE2((__int64)&v19, 0LL, 0x28uLL);
    v21 = 276LL;
    v19 = v11 + (unsigned int)v6;
    while ( (++v5 & 0x3F) != 0 && a3 > v5 )
    {
      v18 = *(_DWORD *)(a2 + 8LL * v5 + 4);
      v12 = v18 - v10;
      if ( v18 == v10 )
      {
        v13 = 1;
        v14 = 0;
      }
      else if ( v12 - 1 > 3 )
      {
        if ( v12 + 128 > 0xFF )
        {
          sub_4261E0((__int64)&v19, HIWORD(v18) + 458752, 19);
          v14 = (unsigned __int16)v18;
          v13 = 16;
        }
        else
        {
          v14 = v12 + 1664;
          v13 = 11;
        }
      }
      else
      {
        v14 = v12 + 7;
        v13 = 4;
      }
      sub_4261E0((__int64)&v19, v14, v13);
      v10 = v18;
    }
    sub_426227((__int64)&v19);
    LODWORD(v6) = v20 + v6;
  }
  sub_4200FB(a1, v7, (unsigned int)v6, a4, a5);
  return sub_40884A(a1, -1, 0LL, 0, a4, a5);
}
// 420203: variable 'v11' is possibly undefined
// 420226: variable 'v10' is possibly undefined

//----- (00000000004202D0) ----------------------------------------------------
__int64 __fastcall sub_4202D0(__int64 *a1, int a2, unsigned int a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // er12
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rdi
  unsigned __int64 v13; // r8
  int v14; // ebx
  char *v15; // rdi
  unsigned int v16; // er12
  __int64 v18; // [rsp+0h] [rbp-40h] BYREF
  char v19; // [rsp+8h] [rbp-38h] BYREF
  unsigned __int64 v20; // [rsp+10h] [rbp-30h]

  v6 = 0;
  sub_403883(a1, (a2 << 16) + 102, a4, a5);
  v8 = 0xFFFFFFFFLL;
  v9 = sub_405869((__int64)a1, -1);
  if ( v9 )
  {
    v8 = *(_QWORD *)(v9 + 24);
    if ( v8 > 4 && a3 < *(_DWORD *)(v9 + 32) )
    {
      v10 = v9 + 32;
      v11 = a3 >> 6;
      v12 = (unsigned int)(2 * v11 + 2);
      v13 = *(unsigned int *)(v9 + 4 * v12 + 32);
      if ( v8 >= v13 )
      {
        v11 = 6LL;
        v8 -= v13;
        v14 = a3 & 0x3F;
        v6 = *(_DWORD *)(v10 + 4LL * (unsigned int)(v12 - 1));
        v15 = &v19;
        v10 += v13;
        while ( v11 )
        {
          *(_DWORD *)v15 = 0;
          v15 += 4;
          --v11;
        }
        v18 = v10;
        v20 = v8;
        while ( v14 )
        {
          if ( (unsigned int)sub_41CDF1(&v18) )
          {
            if ( (unsigned int)sub_41CDF1(&v18) )
            {
              if ( (unsigned int)sub_41CDF1(&v18) )
              {
                v8 = 16LL;
                v16 = (unsigned int)sub_41CDA5(&v18, 16) << 16;
                v6 = sub_41CDA5(&v18, 16) + v16;
              }
              else
              {
                v8 = 8LL;
                v6 = v6 + sub_41CDA5(&v18, 8) - 128;
              }
            }
            else
            {
              v8 = 2LL;
              v6 += sub_41CDA5(&v18, 2) + 1;
            }
          }
          --v14;
        }
      }
    }
  }
  sub_407D7E(a1, v8, v10, v11, a4, a5);
  return v6;
}
// 4203DF: variable 'v10' is possibly undefined
// 4203DF: variable 'v11' is possibly undefined

//----- (00000000004203F7) ----------------------------------------------------
double __fastcall sub_4203F7(double result, double a2)
{
  int v2; // eax
  int v3; // ebx
  _BOOL4 v4; // eax

  v2 = sub_42FB3D(a2);
  if ( !v2 )
    return NAN;
  v3 = v2;
  v4 = sub_41D67C(COERCE_DOUBLE(*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFLL), 1.0);
  if ( v3 == 1 && v4 )
    return NAN;
  sub_4303AD(result, a2);
  return result;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000042045D) ----------------------------------------------------
_DWORD *__fastcall sub_42045D(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *result; // rax

  result = (_DWORD *)a1[8];
  if ( !result[30] || result[51] + 11 < result[50] )
    return (_DWORD *)sub_401CE2(a1, (__int64)"third_party/duktape/duk_js_call.c", 73, "C stack depth limit", a2, a3);
  return result;
}

//----- (000000000042048D) ----------------------------------------------------
unsigned int *__fastcall sub_42048D(
        __int64 *a1,
        int a2,
        __m128 a3,
        __m128 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned int *result; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx

  result = (unsigned int *)(a1[13] + 16LL * a2);
  v9 = *result;
  if ( (unsigned int)v9 > 3 )
  {
    if ( (_DWORD)v9 == 9 )
      return result;
    return (unsigned int *)sub_408290(a1, a2, a3, a4, v9, a6, a7, a8);
  }
  if ( (unsigned int)v9 <= 1 )
    return (unsigned int *)sub_408290(a1, a2, a3, a4, v9, a6, a7, a8);
  v10 = a1[20];
  if ( v10 )
  {
    *result = 9;
    *((_QWORD *)result + 1) = v10;
    ++*(_DWORD *)(v10 + 4);
  }
  else
  {
    *result = 2;
  }
  return result;
}

//----- (00000000004204D4) ----------------------------------------------------
__int64 __fastcall sub_4204D4(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r13
  __int64 v10; // rcx

  sub_4037B9(a1, (a2 << 16) + 50, a3, a4);
  v5 = 0xFFFFFFFFLL;
  v6 = sub_405823((__int64)a1, -1);
  if ( v6 )
  {
    v9 = v6;
    v5 = sub_405B41((__int64)a1, a2 + 1);
    sub_40DCFB((__int64)a1, v5, v9, v10, a3, a4);
  }
  return sub_407D7E(a1, v5, v7, v8, a3, a4);
}
// 420515: variable 'v10' is possibly undefined
// 420524: variable 'v7' is possibly undefined
// 420524: variable 'v8' is possibly undefined

//----- (0000000000420529) ----------------------------------------------------
__int64 __fastcall sub_420529(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // r8

  result = *(_QWORD *)(a1 + 64);
  v2 = *(unsigned __int8 *)(a1 + 73);
  if ( *(_QWORD *)(result + 184) == a1 )
  {
    if ( (_BYTE)v2 == 2 )
      return result;
  }
  else if ( (_BYTE)v2 == 1 )
  {
    *(_QWORD *)(result + 184) = a1;
    *(_BYTE *)(a1 + 73) = 2;
    return result;
  }
  return sub_401B75(
           (__int64 *)a1,
           (__int64)"third_party/duktape/duk_js_call.c",
           0x6000782u,
           "invalid thread state (%ld)",
           v2);
}

//----- (000000000042056C) ----------------------------------------------------
__int64 __fastcall sub_42056C(__int64 *a1, int a2, int a3, int a4, __m128 a5, __m128 a6)
{
  int v7; // eax
  __int64 v8; // rcx
  __int64 v10; // rdx
  __int64 v11; // rcx

  v7 = sub_404AE7((__int64)a1) - a4;
  if ( v7 < 0 )
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_js_call.c", 0x600057Du, "invalid C function rc", a5, a6);
  if ( v7 <= a2 )
    sub_405335((__int64)a1, v7, a2 - v7);
  else
    sub_405188((__int64)a1, a2, (unsigned int)(v7 - a2), v8, a5, a6);
  return sub_404BCC((__int64)a1, a2 + a3, v10, v11, a5, a6);
}
// 4205BA: variable 'v8' is possibly undefined
// 4205DC: variable 'v10' is possibly undefined
// 4205DC: variable 'v11' is possibly undefined

//----- (00000000004205E2) ----------------------------------------------------
char *__fastcall sub_4205E2(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rdx
  __int64 v5; // rcx

  if ( !(unsigned int)sub_406117(a1, -1, a3, a4) )
  {
    if ( a2 )
      return (char *)sub_401D32(a1, (__int64)"third_party/duktape/duk_js_call.c", 527, a3, a4);
    sub_407D7E(a1, 0xFFFFFFFFLL, v4, v5, a3, a4);
    sub_406FB2(a1, a3, a4);
  }
  return sub_40B6EA(a1, (__int64)a1, 0LL, 0, 3, a3, a4);
}
// 42061C: variable 'v4' is possibly undefined
// 42061C: variable 'v5' is possibly undefined

//----- (0000000000420642) ----------------------------------------------------
__int64 __fastcall sub_420642(__int64 a1, int a2, unsigned int a3, __m128 a4, __m128 a5, __m128 a6)
{
  __int64 v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r13
  signed int v13; // er15
  __int64 v14; // rcx
  __int64 v15; // r8
  int v16; // ebx
  signed __int32 v17; // eax
  __int64 v18; // rax
  unsigned int *v19; // rax
  __int64 v20; // r13
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // rsi
  __int64 v27; // rdx
  __int64 v28; // rcx
  int v29; // eax
  int v30; // esi
  unsigned __int64 v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // rcx
  signed int v35; // eax
  __int64 v36; // rdx
  __int64 v37; // rcx
  __int64 v38; // rax
  __int64 v39; // r15
  unsigned int v40; // eax
  __int64 v41; // rcx
  __int64 v42; // rdx
  __int64 v43; // rsi
  __int64 v44; // rax
  unsigned __int8 v45; // cf
  __int64 v46; // rax
  _BYTE *v47; // rdx
  __int64 v48; // rcx
  __int64 v49; // rbx
  _DWORD *v50; // rsi
  bool v51; // zf
  unsigned __int64 v52; // rax
  __int64 v53; // rax
  signed __int32 v54; // eax
  int v55; // ebx
  __int64 v56; // rax
  __int64 v57; // rdx
  int v58; // eax
  int v59; // esi
  int v60; // ebx
  __int64 v61; // rsi
  __int64 v62; // rdx
  __int64 v63; // rcx
  __int64 v64; // rsi
  __int64 v65; // rdx
  __int64 v66; // rcx
  __int64 v67; // rsi
  __int64 v68; // rdx
  __int64 v69; // rcx
  __int64 v70; // rdx
  __int64 v71; // rax
  __int64 v72; // rsi
  __int64 v73; // rdx
  __int64 v74; // rcx
  __int64 v75; // r8
  __int64 v76; // r9
  __int64 v78; // rdx
  __int64 v79; // rcx
  int v80; // eax
  __int64 v81; // rax
  __int64 v82; // rdx
  __int64 *v83; // rax
  __int64 v84; // rcx
  __int64 v85; // rbx
  _DWORD *v86; // rsi
  __int64 v87; // rsi
  __int64 v88; // rax
  __int64 v89; // rdx
  __int64 v90; // rax
  int v91; // eax
  __m128 *v92; // rax
  int v93; // edx
  __int128 *v94; // rax
  __int64 v95; // rsi
  char v96; // [rsp+0h] [rbp-C0h]
  int *v97; // [rsp+8h] [rbp-B8h]
  __int64 v98; // [rsp+10h] [rbp-B0h]
  int v99; // [rsp+18h] [rbp-A8h]
  char v100; // [rsp+1Fh] [rbp-A1h]
  __int64 v101; // [rsp+20h] [rbp-A0h]
  __int64 v102; // [rsp+28h] [rbp-98h]
  int v103; // [rsp+30h] [rbp-90h]
  int v104; // [rsp+34h] [rbp-8Ch]
  unsigned int v105; // [rsp+38h] [rbp-88h]
  unsigned int v106; // [rsp+3Ch] [rbp-84h]
  __int64 v107; // [rsp+40h] [rbp-80h]
  int v108; // [rsp+48h] [rbp-78h]
  int v109; // [rsp+4Ch] [rbp-74h]
  int *v110; // [rsp+50h] [rbp-70h]
  __int64 v111; // [rsp+58h] [rbp-68h]
  unsigned int v112; // [rsp+58h] [rbp-68h]
  unsigned __int64 v113; // [rsp+60h] [rbp-60h]
  __int64 v114; // [rsp+68h] [rbp-58h]
  signed int v115; // [rsp+68h] [rbp-58h]
  __int64 v116; // [rsp+70h] [rbp-50h]
  __int64 v117; // [rsp+78h] [rbp-48h]
  int v118; // [rsp+80h] [rbp-40h]
  int v119; // [rsp+80h] [rbp-40h]
  __int64 v120; // [rsp+80h] [rbp-40h]
  int v121; // [rsp+88h] [rbp-38h]

  v107 = *(_QWORD *)(a1 + 80);
  v116 = *(_QWORD *)(a1 + 104) - v107;
  v102 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 64);
  v101 = *(_QWORD *)(v7 + 184);
  v103 = *(_DWORD *)(v7 + 200);
  v100 = *(_BYTE *)(a1 + 73);
  v98 = *(_QWORD *)(a1 + 56);
  sub_41203C(a1);
  sub_420529(a1);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL) >= *(_DWORD *)(*(_QWORD *)(a1 + 64) + 204LL) )
    sub_42045D((__int64 *)a1, a4, a5);
  ++*(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL);
  sub_404E3A((__int64 *)a1, 8, a4, a5);
  v117 = 16LL * a2;
  if ( (a3 & 2) == 0 )
  {
    v8 = 16LL * a2 + *(_QWORD *)(a1 + 104);
    if ( *(_DWORD *)v8 == 9 )
    {
      v12 = *(_QWORD *)(v8 + 8);
      v8 = *(_DWORD *)v12 & 0x4000600;
      if ( (_DWORD)v8 == 512 )
      {
        if ( (*(_DWORD *)v12 & 0x10000) == 0 )
          sub_42048D((__int64 *)a1, a2 + 1, a4, a5, v8, v9, v10, v11);
        goto LABEL_71;
      }
    }
    else
    {
      v12 = 0LL;
      if ( *(_DWORD *)v8 == 6 )
        goto LABEL_71;
    }
  }
  v13 = a2 + 2;
  v14 = 1LL;
  v114 = v117 + 32;
  while ( 1 )
  {
    v15 = *(_QWORD *)(a1 + 104) + v117;
    v16 = a3 & 2;
    if ( *(_DWORD *)v15 != 9 )
    {
      v12 = 0LL;
      if ( *(_DWORD *)v15 == 6 )
        goto LABEL_71;
      goto LABEL_69;
    }
    v12 = *(_QWORD *)(v15 + 8);
    v17 = *(_DWORD *)v12;
    if ( (a3 & 2) == 0 )
    {
      if ( (v17 & 0x200) != 0 )
        goto LABEL_15;
      v120 = *(_QWORD *)(a1 + 104) + v117;
      v94 = (__int128 *)sub_40E629(*(_QWORD *)(a1 + 64), *(_QWORD *)(v15 + 8), 0x60u);
      v15 = v120;
      v95 = (__int64)v94;
      if ( v94 )
      {
        sub_406883((__int64 *)a1, v94, a4, a5);
        sub_408001((__int64 *)a1, v95, a4, a5);
        goto LABEL_70;
      }
LABEL_69:
      v38 = sub_408C16((__int64 *)a1, v15, a4, a5);
      sub_401B75(
        (__int64 *)a1,
        (__int64)"third_party/duktape/duk_js_call.c",
        0x6000554u,
        &word_4411DA,
        v38,
        *(double *)a4.i64,
        *(double *)a5.i64,
        *(double *)a6.i64);
      goto LABEL_70;
    }
    if ( (v17 & 0x100) == 0 )
    {
      v18 = sub_408C16((__int64 *)a1, *(_QWORD *)(a1 + 104) + v117, a4, a5);
      sub_401B75((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 0x6000561u, "%s not constructable", v18);
LABEL_70:
      v12 = 0LL;
      goto LABEL_71;
    }
LABEL_15:
    if ( (v17 & 0x6000400) == 0 )
      goto LABEL_64;
    if ( (v17 & 0x400) != 0 )
    {
      v19 = (unsigned int *)sub_404A12((__int64 *)a1, a2);
      v8 = *v19;
      if ( (_DWORD)v8 == 9 )
      {
        v20 = *((_QWORD *)v19 + 1);
        if ( !_bittest((const signed __int32 *)v20, 0xAu) )
          goto LABEL_19;
        v111 = *(_QWORD *)(v20 + 88);
        v118 = *(_DWORD *)(v20 + 96);
        if ( (a3 & 2) == 0 )
        {
          sub_406883((__int64 *)a1, (__int128 *)(v20 + 72), a4, a5);
          sub_405057((__int64 *)a1, a2 + 1, v21, v22, *(double *)a4.i64, a5);
        }
        sub_404E3A((__int64 *)a1, v118, a4, a5);
        sub_405305(a1, v13, v118);
        sub_408C9E(a1, v23, v111, v118);
        sub_406883((__int64 *)a1, (__int128 *)(v20 + 56), a4, a5);
        goto LABEL_31;
      }
      if ( (_DWORD)v8 != 6 )
        sub_401CB7((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 628, a4, a5);
      goto LABEL_19;
    }
    if ( (v17 & 0x2000000) != 0 )
    {
      sub_407C45((__int64 *)a1, *(_QWORD *)(v12 + 64), a4, a5);
      v26 = (unsigned int)(-(v16 == 0) - 65465);
      if ( !(unsigned int)sub_4037B9((__int64 *)a1, v26, a4, a5) )
      {
        if ( (a3 & 2) != 0 && (a3 & 0x40) == 0 )
        {
          v26 = (unsigned int)a2;
          a3 |= 0x40u;
          sub_4204D4((__int64 *)a1, a2, a4, a5);
        }
        sub_407DC0((__int64 *)a1, v26, v27, v28, a4, a5);
        sub_407C45((__int64 *)a1, *(_QWORD *)(v12 + 56), a4, a5);
LABEL_31:
        sub_405057((__int64 *)a1, a2, v24, v25, *(double *)a4.i64, a5);
        goto LABEL_19;
      }
      sub_40500F((__int64 *)a1, a2 + 1);
      sub_40500F((__int64 *)a1, v13);
      sub_407C45((__int64 *)a1, *(_QWORD *)(v12 + 56), a4, a5);
      sub_40500F((__int64 *)a1, a2 + 3);
      v29 = sub_404AE7(a1);
      sub_407E10((_QWORD *)a1, v29 - (a2 + 5), a4, a5);
      if ( (a3 & 2) != 0 )
      {
        a3 = a3 & 0xFFFFFFDD | 0x20;
        sub_40511F((__int64 *)a1, a2 + 4, a4, a5);
        sub_407C45((__int64 *)a1, v12, a4, a5);
      }
      v30 = a2;
      goto LABEL_55;
    }
    LOWORD(v8) = *(_WORD *)(v12 + 66);
    if ( (_WORD)v8 == 15 )
      break;
    if ( (_WORD)v8 == 2 )
    {
      sub_405227(a1, a2, 2LL, v14, a4, a5);
    }
    else
    {
      if ( (__int16)v8 > 2 )
      {
        a3 |= 2u;
        sub_405227(a1, a2, 2LL, v14, a4, a5);
        sub_404AE7(a1);
        if ( !sub_4066D3(a1, a2) )
        {
          sub_404BCC(a1, v13, v33, v34, a4, a5);
          goto LABEL_19;
        }
        sub_407095((__int64 *)a1, a4, a5);
        sub_40500F((__int64 *)a1, a2 + 1);
        v35 = sub_404AE7(a1);
        if ( v35 <= v13 )
        {
          sub_401D12((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 805, a4, a5);
          goto LABEL_19;
        }
        if ( v35 > a2 + 3 )
        {
          if ( !(unsigned int)sub_408133(a1, a2, a4, a5) )
          {
            sub_401C42((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 0x100032Bu, "unsupported", a4, a5);
            goto LABEL_19;
          }
          sub_404BCC(a1, a2 + 3, v36, v37, a4, a5);
        }
LABEL_54:
        sub_407E9B((__int64 *)a1, v13, a4, a5);
        v30 = a2 + 2;
LABEL_55:
        sub_40511F((__int64 *)a1, v30, a4, a5);
        goto LABEL_19;
      }
      if ( !(_WORD)v8 )
      {
        sub_40517F(a1, (unsigned int)a2, v8, v14);
        v31 = *(_QWORD *)(a1 + 104) + v114;
        if ( v31 <= *(_QWORD *)(a1 + 112) )
          goto LABEL_19;
LABEL_57:
        *(_QWORD *)(a1 + 112) = v31;
        goto LABEL_19;
      }
      sub_40517F(a1, (unsigned int)a2, v8, v14);
    }
    v31 = *(_QWORD *)(a1 + 104) + v114;
    v8 = *(_QWORD *)(a1 + 112);
    if ( v31 >= v8 )
      goto LABEL_57;
    if ( v8 > v31 + 16 )
      sub_404BCC(a1, a2 + 3, v8, v32, a4, a5);
    if ( sub_4065F2(a1, a2) )
      goto LABEL_54;
LABEL_19:
    v14 = 0LL;
  }
  if ( (_DWORD)v14 && (a3 & 4) != 0 )
  {
    v8 = a3 & 0xFFFFFFEB | 0x10;
    a3 = a3 & 0xFFFFFFEB | 0x10;
  }
LABEL_64:
  if ( (v17 & 0x10000) == 0 )
    sub_42048D((__int64 *)a1, a2 + 1, a4, a5, v8, v14, v15, v11);
  if ( v16 && (a3 & 0x40) == 0 )
  {
    a3 |= 0x40u;
    sub_4204D4((__int64 *)a1, a2, a4, a5);
  }
LABEL_71:
  v109 = a3 & 1;
  if ( (a3 & 1) != 0 )
  {
    if ( v12 )
    {
      if ( (*(_DWORD *)v12 & 0x800) != 0 )
      {
        v39 = *(_QWORD *)(a1 + 120);
        v40 = *(_DWORD *)(v39 + 88);
        v41 = (v40 >> 4) & 2 | (v40 >> 2) & 1;
        v42 = (a3 >> 4) & 2 | (a3 >> 1) & 1;
        if ( (_DWORD)v41 == (_DWORD)v42 )
        {
          v43 = *(_DWORD *)v12 & 0x20000;
          if ( !((unsigned int)v43 | v40 & 8) )
          {
            sub_4121FB((__int64 *)a1, a4, a5, v43, v42, v41);
            v44 = *(_QWORD *)(v12 + 72);
            *(_QWORD *)(v39 + 48) = 0LL;
            *(_QWORD *)(v39 + 32) = 0LL;
            *(_QWORD *)(v39 + 40) = 0LL;
            *(_QWORD *)(v39 + 16) = v12;
            *(_DWORD *)v39 = 9;
            *(_QWORD *)(v39 + 56) = v44;
            *(_QWORD *)(v39 + 8) = v12;
            ++*(_DWORD *)(v12 + 4);
            v45 = _bittest((const signed __int32 *)v12, 0x10u);
            *(_DWORD *)(v39 + 88) = 2;
            if ( v45 )
              *(_DWORD *)(v39 + 88) = 3;
            if ( (a3 & 2) != 0 )
              *(_DWORD *)(v39 + 88) |= 4u;
            if ( (a3 & 0x20) != 0 )
              *(_DWORD *)(v39 + 88) |= 0x20u;
            *(_QWORD *)(v39 + 80) = 0LL;
            *(_QWORD *)(v39 + 64) = v116;
            v46 = *(_QWORD *)(a1 + 104);
            v47 = (_BYTE *)(v46 + v117 + 16);
            if ( (*v47 & 8) != 0 )
              ++*(_DWORD *)(*(_QWORD *)(v46 + v117 + 24) + 4LL);
            v48 = *(_QWORD *)v47;
            v49 = *(_QWORD *)(v46 + v117 + 24);
            if ( (*(_BYTE *)(v46 - 16) & 8) != 0 )
            {
              v50 = *(_DWORD **)(v46 - 8);
              *(_QWORD *)(v46 - 16) = v48;
              *(_QWORD *)(v46 - 8) = v49;
              v51 = v50[1]-- == 1;
              if ( v51 )
                sub_40CFCD(a1, v50, (__int64)v47, v48, a4, a5);
            }
            else
            {
              *(_QWORD *)(v46 - 16) = v48;
              *(_QWORD *)(v46 - 8) = v49;
            }
            sub_405188(a1, 0, (unsigned int)(a2 + 2), v48, a4, a5);
            v121 = 0;
            v119 = *(unsigned __int16 *)(v12 + 98);
            v115 = *(unsigned __int16 *)(v12 + 96);
            v113 = v116 + 16 * (*(unsigned __int16 *)(v12 + 96) + 32LL);
            goto LABEL_106;
          }
        }
      }
    }
  }
  v52 = *(_QWORD *)(a1 + 128);
  if ( v52 > 0x270F && (!*(_DWORD *)(*(_QWORD *)(a1 + 64) + 120LL) || v52 > 0x271B) )
    sub_401CE2((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 111, "callstack limit", a4, a5);
  v39 = sub_412195((__int64 *)a1, a4, a5);
  v53 = *(_QWORD *)(a1 + 120);
  if ( v53 )
    *(_QWORD *)(v53 + 72) = v117 + v116;
  *(_QWORD *)(v39 + 24) = v53;
  ++*(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 120) = v39;
  *(_QWORD *)(v39 + 48) = 0LL;
  *(_DWORD *)(v39 + 88) = 4 * ((a3 & 2) != 0);
  if ( (a3 & 0x20) != 0 )
    *(_DWORD *)(v39 + 88) |= 0x20u;
  if ( (a3 & 0x10) != 0 )
    *(_DWORD *)(v39 + 88) |= 0x10u;
  *(_QWORD *)(v39 + 16) = v12;
  if ( v12 )
  {
    v54 = *(_DWORD *)v12;
    *(_DWORD *)v39 = 9;
    *(_QWORD *)(v39 + 8) = v12;
    if ( (v54 & 0x10000) != 0 )
      *(_DWORD *)(v39 + 88) |= 1u;
    if ( (v54 & 0x800) != 0 )
    {
      v119 = *(unsigned __int16 *)(v12 + 98);
      v115 = *(unsigned __int16 *)(v12 + 96);
      v113 = v116 + 16 * (a2 + (unsigned __int64)*(unsigned __int16 *)(v12 + 96) + 34);
      goto LABEL_103;
    }
    v119 = *(__int16 *)(v12 + 64);
    if ( v119 < 0 )
      v90 = *(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 80) + 1536LL;
    else
      v90 = v116 + 16 * (a2 + (__int64)*(__int16 *)(v12 + 64) + 98);
    v113 = v90;
    v91 = *(__int16 *)(v12 + 64);
LABEL_164:
    v115 = v91;
  }
  else
  {
    v92 = (__m128 *)(*(_QWORD *)(a1 + 104) + v117);
    *(_DWORD *)(v39 + 88) |= 1u;
    a4 = *v92;
    *(__m128 *)v39 = *v92;
    v93 = v92->i32[1] & 0xF;
    v119 = v93;
    if ( v93 != 15 )
    {
      v113 = v116 + 16 * (a2 + (__int64)v93 + 98);
      v91 = v92->i32[1] & 0xF;
      goto LABEL_164;
    }
    v115 = -1;
    v119 = -1;
    v113 = *(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 80) + 1536LL;
  }
LABEL_103:
  *(_QWORD *)(v39 + 32) = 0LL;
  *(_QWORD *)(v39 + 40) = 0LL;
  *(_QWORD *)(v39 + 56) = 0LL;
  *(_QWORD *)(v39 + 80) = 0LL;
  *(_QWORD *)(v39 + 64) = v116 + v117 + 32;
  if ( v12 )
    ++*(_DWORD *)(v12 + 4);
  v109 = 0;
  v121 = a2 + 2;
  if ( v12 )
  {
LABEL_106:
    if ( (*(_DWORD *)v12 & 0x40000) != 0 )
    {
      if ( (*(_DWORD *)v12 & 0x100000) != 0 )
      {
        v110 = sub_4186B8(a1, v12, *(_QWORD *)(v39 + 64), a4, a5);
        v55 = sub_404AE7(a1) - v121;
        v56 = sub_40E6D6(a1, v12);
        if ( v56 )
        {
          v104 = *(_DWORD *)(v56 + 56);
          sub_407C45((__int64 *)a1, v56, a4, a5);
        }
        else
        {
          sub_4068D1((__int64 *)a1, 0LL, v57, a4, a5);
          v104 = 0;
        }
        v99 = sub_404C98((__int64 *)a1);
        v97 = sub_407003((__int64 *)a1, 536920192, 3, a4, a5);
        sub_407003((__int64 *)a1, 134234240, -1, a4, a5);
        sub_407003((__int64 *)a1, 134234240, -1, a4, a5);
        v58 = sub_404AE7(a1);
        v59 = v55 - 1;
        v60 = v55 - 2;
        v112 = v58 - 3;
        v105 = v58 - 1;
        v106 = v58 - 2;
        sub_406A68((__int64 *)a1, v59, a4, a5);
        sub_403DDC((__int64 *)a1, v112, 0x57u, 5, a4, a5);
        v108 = 0;
        while ( v60 >= 0 )
        {
          sub_404F0A((__int64 *)a1, v121 + v60, a4, a5);
          sub_403DB2((__int64 *)a1, v112, v60, 7, a4, a5);
          if ( !_bittest((const signed __int32 *)v12, 0x10u) && v60 < v104 )
          {
            sub_40370E((__int64 *)a1, v99, v60, a4, a5);
            sub_404F67((__int64 *)a1, a4, a5);
            v61 = v105;
            if ( !(unsigned int)sub_403BC8((__int64 *)a1, v105, a4, a5) )
            {
              sub_404F67((__int64 *)a1, a4, a5);
              sub_4089F6((__int64 *)a1, v60, a4, a5);
              sub_403D6B((__int64 *)a1, v105, 7, a4, a5);
              sub_404F67((__int64 *)a1, a4, a5);
              v61 = v106;
              sub_403DB2((__int64 *)a1, v106, v60, 7, a4, a5);
              v108 = 1;
            }
            sub_407D7E((__int64 *)a1, v61, v62, v63, a4, a5);
          }
          --v60;
        }
        if ( v108 )
        {
          sub_404F0A((__int64 *)a1, v106, a4, a5);
          sub_403DDC((__int64 *)a1, v112, 0x67u, 0, a4, a5);
          sub_407C45((__int64 *)a1, (__int64)v110, a4, a5);
          sub_403DDC((__int64 *)a1, v112, 0x68u, 0, a4, a5);
        }
        if ( _bittest((const signed __int32 *)v12, 0x10u) )
        {
          v64 = v112;
          sub_403F77((__int64 *)a1, v112, 0x44u, a4, a5);
        }
        else
        {
          sub_407C45((__int64 *)a1, v12, a4, a5);
          v64 = v112;
          sub_403DDC((__int64 *)a1, v112, 0x44u, 5, a4, a5);
        }
        if ( v108 )
          *v97 |= 0x1000000u;
        sub_407DC0((__int64 *)a1, v64, v65, v66, a4, a5);
        sub_405181((__int64 *)a1, a4, a5);
        v67 = (unsigned int)(((int)(*(_DWORD *)v12 << 15) >> 31) - 33537277);
        sub_403E13((__int64 *)a1, v67, a4, a5);
        *(_QWORD *)(v39 + 40) = v110;
        *(_QWORD *)(v39 + 32) = v110;
        v110[1] += 2;
        sub_407D7E((__int64 *)a1, v67, v68, v69, a4, a5);
      }
    }
    else
    {
      v70 = *(_QWORD *)(v12 + 80);
      v71 = *(_QWORD *)(v12 + 88);
      *(_QWORD *)(v39 + 40) = v70;
      *(_QWORD *)(v39 + 32) = v71;
      ++*(_DWORD *)(v70 + 4);
      ++*(_DWORD *)(v71 + 4);
    }
  }
  v72 = v113;
  sub_404CC3((__int64 *)a1, v113, a4, a5);
  *(_QWORD *)(v39 + 80) = *(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80);
  if ( v109 )
  {
    v72 = (unsigned int)v115;
    sub_404C48(a1, v115, (unsigned int)v119, v74, a4, a5);
  }
  else
  {
    if ( v115 >= 0 )
    {
      v72 = (unsigned int)(v115 + a2 + 2);
      sub_404C48(a1, v72, (unsigned int)(a2 + 2 + v119), v74, a4, a5);
    }
    *(_QWORD *)(a1 + 104) += v117 + 32;
  }
  if ( v12 && _bittest((const signed __int32 *)v12, 0xBu) )
  {
    *(_QWORD *)(v39 + 56) = *(_QWORD *)(v12 + 72);
    if ( (a3 & 8) != 0 )
    {
      sub_40CA65(a1, v72, v73);
      --*(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL);
      return 1LL;
    }
    *(_DWORD *)(v39 + 88) |= 8u;
    ++*(_QWORD *)(a1 + 136);
    sub_422318(a1, v72, v73, a4, a5, a6, v74, v75, v76, v96);
    goto LABEL_147;
  }
  *(_DWORD *)(v39 + 88) |= 8u;
  ++*(_QWORD *)(a1 + 136);
  if ( v12 )
    v80 = (*(__int64 (__fastcall **)(__int64, double, double, double))(v12 + 56))(
            a1,
            *(double *)a4.i64,
            *(double *)a5.i64,
            *(double *)a6.i64);
  else
    v80 = (*(__int64 (__fastcall **)(__int64, double, double, double))(v39 + 8))(
            a1,
            *(double *)a4.i64,
            *(double *)a5.i64,
            *(double *)a6.i64);
  v72 = (unsigned int)v80;
  if ( !v80 )
  {
    *(_QWORD *)(a1 + 112) += 16LL;
    goto LABEL_147;
  }
  if ( v80 == 1 )
  {
LABEL_147:
    if ( (a3 & 0x22) != 0 )
    {
      v72 = a3 & 0x20;
      sub_4205E2((__int64 *)a1, v72, a4, a5);
    }
    sub_4121C6((__int64 *)a1, v72, v78, v79, a4, a5);
    v81 = *(_QWORD *)(a1 + 80) + v116;
    v82 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 104) = v81;
    v83 = (__int64 *)(v117 + v81);
    if ( (*(_BYTE *)(v82 - 16) & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(v82 - 8) + 4LL);
    v84 = *(_QWORD *)(v82 - 16);
    v85 = *(_QWORD *)(v82 - 8);
    if ( (*(_BYTE *)v83 & 8) != 0 )
    {
      v86 = (_DWORD *)v83[1];
      *v83 = v84;
      v83[1] = v85;
      v51 = v86[1]-- == 1;
      if ( v51 )
        sub_40CFCD(a1, v86, v82, v84, a4, a5);
    }
    else
    {
      *v83 = v84;
      v83[1] = v85;
    }
    v87 = (unsigned int)(a2 + 1);
    sub_404BCC(a1, v87, v82, v84, a4, a5);
    *(_QWORD *)(a1 + 88) = *(_QWORD *)(a1 + 80) + v102 - v107;
    *(_QWORD *)(a1 + 56) = v98;
    v88 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(v88 + 184) = v101;
    *(_BYTE *)(a1 + 73) = v100;
    *(_DWORD *)(v88 + 200) = v103;
    sub_40CA65(a1, v87, v89);
  }
  else if ( v80 >= 0 )
  {
    sub_401C42((__int64 *)a1, (__int64)"third_party/duktape/duk_js_call.c", 0x60008F3u, "invalid C function rc", a4, a5);
  }
  else
  {
    sub_40BB4A((__int64 *)a1, v80);
  }
  return 0LL;
}
// 42073D: variable 'v9' is possibly undefined
// 42073D: variable 'v10' is possibly undefined
// 42073D: variable 'v11' is possibly undefined
// 42081C: variable 'v21' is possibly undefined
// 42081C: variable 'v22' is possibly undefined
// 420848: variable 'v23' is possibly undefined
// 4208C0: variable 'v27' is possibly undefined
// 4208C0: variable 'v28' is possibly undefined
// 4208D7: variable 'v24' is possibly undefined
// 4208D7: variable 'v25' is possibly undefined
// 420998: variable 'v8' is possibly undefined
// 420A06: variable 'v33' is possibly undefined
// 420A06: variable 'v34' is possibly undefined
// 420A85: variable 'v36' is possibly undefined
// 420A85: variable 'v37' is possibly undefined
// 420AD2: variable 'v32' is possibly undefined
// 420C86: variable 'v48' is possibly undefined
// 420E53: variable 'v57' is possibly undefined
// 420FA4: variable 'v62' is possibly undefined
// 420FA4: variable 'v63' is possibly undefined
// 421044: variable 'v65' is possibly undefined
// 421044: variable 'v66' is possibly undefined
// 42107C: variable 'v68' is possibly undefined
// 42107C: variable 'v69' is possibly undefined
// 4210C2: variable 'v74' is possibly undefined
// 42110E: variable 'v73' is possibly undefined
// 421138: variable 'v75' is possibly undefined
// 421138: variable 'v76' is possibly undefined
// 421138: variable 'v96' is possibly undefined
// 4211B5: variable 'v78' is possibly undefined
// 4211B5: variable 'v79' is possibly undefined
// 421213: variable 'v82' is possibly undefined
// 421213: variable 'v84' is possibly undefined
// 421266: variable 'v89' is possibly undefined
// 40517F: using guessed type __int64 __fastcall sub_40517F(_QWORD, _QWORD, _QWORD, _QWORD);
// 40CA65: using guessed type __int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD);
// 4411DA: using guessed type __int16 word_4411DA;

//----- (0000000000421382) ----------------------------------------------------
__int64 __fastcall sub_421382(__int64 a1, int a2, unsigned int a3, __m128 a4, __m128 a5, __m128 a6)
{
  int v6; // eax

  v6 = sub_404AE7(a1);
  return sub_420642(a1, v6 - (a2 + 2), a3, a4, a5, a6);
}

//----- (00000000004213B7) ----------------------------------------------------
__int64 __fastcall sub_4213B7(
        __int64 a1,
        __int64 (__fastcall *a2)(__int64, __int64),
        __int64 a3,
        int a4,
        int a5,
        __m128 a6,
        __m128 a7)
{
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  unsigned int v14; // er12
  int v15; // eax
  unsigned __int64 v16; // rsi
  __int64 v17; // rcx
  __int64 v18; // rsi
  __int64 v19; // rcx
  __int64 v20; // rax
  _DWORD *v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rdx
  bool v25; // zf
  char v27; // [rsp+0h] [rbp-C8h]
  __int64 v29; // [rsp+40h] [rbp-88h]
  __int64 v30; // [rsp+48h] [rbp-80h]
  __int64 v31; // [rsp+50h] [rbp-78h]
  int v32; // [rsp+58h] [rbp-70h]
  __int64 v34; // [rsp+60h] [rbp-68h]
  char v35; // [rsp+6Bh] [rbp-5Dh]
  unsigned int v36; // [rsp+6Ch] [rbp-5Ch]
  __int64 v37; // [rsp+70h] [rbp-58h]
  __int64 v38[8]; // [rsp+80h] [rbp-48h] BYREF

  v31 = *(_QWORD *)(a1 + 120);
  v30 = *(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 80);
  v7 = *(_QWORD *)(a1 + 64);
  v34 = *(_QWORD *)(v7 + 184);
  v32 = *(_DWORD *)(v7 + 200);
  v35 = *(_BYTE *)(a1 + 73);
  v29 = *(_QWORD *)(a1 + 56);
  v36 = sub_404AE7(a1) - a4;
  v8 = *(_QWORD *)(a1 + 64);
  v9 = *(_QWORD *)(v8 + 128);
  *(_QWORD *)(v8 + 128) = v38;
  v37 = v9;
  ++*(_QWORD *)(a1 + 136);
  if ( (unsigned int)sub_43ACAE(v38, (__int64)a2, v9, v10, v11, v12, v27) )
  {
    v17 = v37;
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 128LL) = v37;
    while ( v31 != *(_QWORD *)(a1 + 120) )
      sub_4121C6((__int64 *)a1, (__int64)a2, v13, v17, a6, a7);
    v18 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(v18 + 184) = v34;
    *(_BYTE *)(a1 + 73) = v35;
    *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 80) + v30;
    sub_406883((__int64 *)a1, (__int128 *)(v18 + 144), a6, a7);
    sub_42056C((__int64 *)a1, v36, a5, 1, a6, a7);
    v20 = *(_QWORD *)(a1 + 64);
    v22 = *(unsigned int *)(v20 + 144);
    v21 = *(_DWORD **)(v20 + 152);
    *(_QWORD *)(v20 + 136) = 0LL;
    *(_DWORD *)(v20 + 144) = 2;
    LOBYTE(v22) = v22 & 8;
    if ( (_BYTE)v22 )
    {
      v25 = v21[1]-- == 1;
      if ( v25 )
        sub_40CFD5(a1, v21, v22, v19, a6, a7);
    }
    v23 = *(_QWORD *)(a1 + 64);
    v24 = *(unsigned int *)(v23 + 160);
    v16 = *(_QWORD *)(v23 + 168);
    *(_DWORD *)(v23 + 160) = 2;
    LOBYTE(v24) = v24 & 8;
    if ( (_BYTE)v24 )
    {
      v25 = (*(_DWORD *)(v16 + 4))-- == 1;
      if ( v25 )
        sub_40CFD5(a1, (_DWORD *)v16, v24, v19, a6, a7);
    }
    v14 = 1;
    --*(_DWORD *)(*(_QWORD *)(a1 + 64) + 108LL);
  }
  else
  {
    v14 = 0;
    sub_420529(a1);
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL) >= *(_DWORD *)(*(_QWORD *)(a1 + 64) + 204LL) )
      sub_42045D((__int64 *)a1, a6, a7);
    ++*(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL);
    v15 = ((__int64 (__fastcall *)(__int64, __int64, double, double))a2)(a1, a3, *(double *)a6.i64, *(double *)a7.i64);
    if ( v15 >= 0 )
    {
      v16 = v36;
      sub_42056C((__int64 *)a1, v36, a5, v15, a6, a7);
      *(_QWORD *)(*(_QWORD *)(a1 + 64) + 184LL) = v34;
      *(_BYTE *)(a1 + 73) = v35;
    }
    else
    {
      v16 = (unsigned int)v15;
      sub_40BB4A((__int64 *)a1, v15);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 128LL) = v37;
  }
  *(_QWORD *)(a1 + 56) = v29;
  *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200LL) = v32;
  --*(_QWORD *)(a1 + 136);
  sub_40CA65(a1, v16, v29);
  return v14;
}
// 42145B: variable 'v10' is possibly undefined
// 42145B: variable 'v11' is possibly undefined
// 42145B: variable 'v12' is possibly undefined
// 42145B: variable 'v27' is possibly undefined
// 421543: variable 'v13' is possibly undefined
// 421543: variable 'v17' is possibly undefined
// 4215FD: variable 'v19' is possibly undefined
// 40CA65: using guessed type __int64 __fastcall sub_40CA65(_QWORD, _QWORD, _QWORD);
// 4213B7: using guessed type _QWORD var_48[8];

//----- (000000000042165E) ----------------------------------------------------
__int64 __fastcall sub_42165E(
        __int64 *a1,
        __int128 *a2,
        __int128 *a3,
        unsigned int a4,
        unsigned int a5,
        __m128 a6,
        __m128 a7)
{
  int v8; // er14
  __int64 v9; // r12
  int v10; // ebx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  int v14; // ebx
  unsigned int *v15; // r12
  __int64 result; // rax
  _DWORD *v17; // rsi
  unsigned int v19; // [rsp+Ch] [rbp-34h]

  v8 = (a5 >> 2) - 20;
  v9 = a4;
  sub_406883(a1, a2, a6, a7);
  sub_406883(a1, a3, a6, a7);
  v10 = sub_405E01(a1, -2, a6, a7);
  v19 = sub_405E01(a1, -1, a6, a7);
  sub_407DE7((__int64)a1, 0xFFFFFFFFLL, v11, v12, a6, a7);
  switch ( v8 )
  {
    case 0:
      v14 = v19 | v10;
      goto LABEL_8;
    case 1:
      v14 = v19 ^ v10;
      goto LABEL_8;
    case 2:
      v14 = v10 << v19;
      goto LABEL_8;
    case 3:
      *(double *)a6.i64 = (double)(int)((unsigned int)v10 >> v19);
      goto LABEL_9;
    case 4:
      v14 = v10 >> v19;
      goto LABEL_8;
    default:
      v14 = v19 & v10;
LABEL_8:
      *(double *)a6.i64 = (double)v14;
LABEL_9:
      v15 = (unsigned int *)(a1[13] + 16 * v9);
      result = *v15;
      v17 = (_DWORD *)*((_QWORD *)v15 + 1);
      *((_QWORD *)v15 + 1) = a6.i64[0];
      *v15 = 0;
      if ( (result & 8) != 0 && v17[1]-- == 1 )
        return sub_40CFCD((__int64)a1, v17, v13, v19, a6, a7);
      return result;
  }
}
// 4216B3: variable 'v11' is possibly undefined
// 4216B3: variable 'v12' is possibly undefined
// 421724: variable 'v13' is possibly undefined

//----- (0000000000421738) ----------------------------------------------------
__int64 __fastcall sub_421738(__int64 *a1, unsigned int a2, __int64 a3, int a4, __m128 a5, __m128 a6)
{
  __int64 v7; // rbx
  __int64 *v8; // rsi
  unsigned int *v9; // rax
  _DWORD *v10; // rsi
  __int64 v11; // rdx
  bool v12; // zf
  __int64 v14; // [rsp+0h] [rbp-20h]

  v7 = (unsigned int)a3;
  v8 = (__int64 *)(a1[13] + 16LL * a2);
  if ( *(_DWORD *)v8 )
    sub_405D6D(a1, v8, a3, a5, a6);
  else
    a5.i64[0] = v8[1];
  if ( a4 != 15 )
    a5 = _mm_xor_ps(a5, (__m128)xmmword_43D2F0);
  v9 = (unsigned int *)(16 * v7 + a1[13]);
  v11 = *v9;
  v10 = (_DWORD *)*((_QWORD *)v9 + 1);
  *((_QWORD *)v9 + 1) = a5.i64[0];
  *v9 = 0;
  LOBYTE(v11) = v11 & 8;
  if ( (_BYTE)v11 && (v12 = v10[1] == 1, --v10[1], v12) )
    return sub_40CFCD((__int64)a1, v10, v11, v14, a5, a6);
  else
    return v14;
}
// 4217A5: variable 'v14' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (00000000004217B1) ----------------------------------------------------
unsigned int *__fastcall sub_4217B1(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  int v7; // er13
  unsigned int *result; // rax
  _DWORD *v9; // rsi
  __int64 v10; // rdx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx

  v7 = a4;
  if ( *(_DWORD *)a2 || *(_DWORD *)a3 )
  {
    sub_406883(a1, (__int128 *)a2, a5, a6);
    sub_406883(a1, (__int128 *)a3, a5, a6);
    sub_406EB2(a1, -2, 0, a5, a6);
    sub_406EB2(a1, -1, 0, a5, a6);
    if ( sub_406515((__int64)a1, -2) || sub_406515((__int64)a1, -1) )
    {
      sub_408E59(a1, a5, a6);
    }
    else
    {
      sub_405D63(a1, a5, a6);
      *(double *)a5.i64 = sub_405CAB(a1, a5, a6) + *(double *)a5.i64;
      sub_407DE7((__int64)a1, 0xFFFFFFFFLL, v14, v15, a5, a6);
      sub_406A1B(a1, a5, a6);
    }
    return (unsigned int *)sub_405057(a1, v7, v12, v13, *(double *)a5.i64, a6);
  }
  else
  {
    *(double *)a5.i64 = *(double *)(a2 + 8) + *(double *)(a3 + 8);
    result = (unsigned int *)(16LL * (unsigned int)a4 + a1[13]);
    v10 = *result;
    v9 = (_DWORD *)*((_QWORD *)result + 1);
    *result = 0;
    LOBYTE(v10) = v10 & 8;
    *((_QWORD *)result + 1) = a5.i64[0];
    if ( (_BYTE)v10 )
    {
      if ( v9[1]-- == 1 )
        return (unsigned int *)sub_40CFCD((__int64)a1, v9, v10, a4, a5, a6);
    }
  }
  return result;
}
// 421895: variable 'v14' is possibly undefined
// 421895: variable 'v15' is possibly undefined
// 4218B8: variable 'v12' is possibly undefined
// 4218B8: variable 'v13' is possibly undefined

//----- (00000000004218C9) ----------------------------------------------------
__int64 __fastcall sub_4218C9(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        unsigned int a5,
        __m128 a6,
        __m128 a7,
        __m128 a8)
{
  unsigned int v9; // er13
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __m128 v13; // xmm0
  unsigned int *v14; // rax
  _DWORD *v15; // rsi
  __int64 v16; // rdx
  bool v17; // zf
  __int64 v19; // [rsp+0h] [rbp-30h]

  v9 = a5 >> 2;
  v10 = a4;
  if ( *(_DWORD *)a2 || *(_DWORD *)a3 )
  {
    sub_406883(a1, (__int128 *)a2, a6, a7);
    sub_406883(a1, (__int128 *)a3, a6, a7);
    sub_405D63(a1, a6, a7);
    v19 = a6.i64[0];
    *(double *)a6.i64 = sub_405CAB(a1, a6, a7);
    sub_407DE7((__int64)a1, a3, v11, v12, a6, a7);
    a8.i64[0] = v19;
    a7.i64[0] = a6.i64[0];
  }
  else
  {
    a8.i64[0] = *(__int64 *)(a2 + 8);
    a7.i64[0] = *(__int64 *)(a3 + 8);
  }
  v13.i64[1] = a8.i64[1];
  if ( v9 == 17 )
  {
    *(double *)v13.i64 = sub_4203F2(*(double *)a8.i64, *(double *)a7.i64);
  }
  else if ( v9 == 18 )
  {
    *(double *)v13.i64 = sub_4203F7(*(double *)a8.i64, *(double *)a7.i64);
  }
  else
  {
    *(double *)v13.i64 = *(double *)a8.i64 * *(double *)a7.i64;
    if ( v9 != 15 )
    {
      if ( v9 == 16 )
      {
        v13.i64[1] = a8.i64[1];
        *(double *)v13.i64 = sub_41D60E(*(double *)a8.i64, (__m128d)a7);
      }
      else
      {
        *(double *)a8.i64 = *(double *)a8.i64 - *(double *)a7.i64;
        v13 = a8;
      }
    }
  }
  v14 = (unsigned int *)(16 * v10 + a1[13]);
  v16 = *v14;
  v15 = (_DWORD *)*((_QWORD *)v14 + 1);
  *((_QWORD *)v14 + 1) = v13.i64[0];
  *v14 = 0;
  LOBYTE(v16) = v16 & 8;
  if ( (_BYTE)v16 && (v17 = v15[1] == 1, --v15[1], v17) )
    return sub_40CFCD((__int64)a1, v15, v16, v19, v13, a7);
  else
    return v19;
}
// 42192D: variable 'v11' is possibly undefined
// 42192D: variable 'v12' is possibly undefined
// 4219AF: variable 'v19' is possibly undefined

//----- (00000000004219BF) ----------------------------------------------------
__int64 __fastcall sub_4219BF(__int64 *a1, char *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  int v6; // er15
  char v7; // r12
  __int64 v8; // rax
  char *v9; // r13
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 result; // rax
  _DWORD *v14; // r8

  v6 = a4 & 1;
  v7 = a4;
  if ( *(_DWORD *)a3 )
  {
    v8 = a1[13];
    v9 = &a2[-v8];
    v10 = (a3 - v8) >> 4;
    sub_405C43(a1, v10, a5, a6);
    a6 = a5;
    *(double *)a5.i64 = *(double *)a5.i64 + 1.0;
    if ( v6 )
    {
      a5.i64[1] = a6.i64[1];
      *(double *)a5.i64 = *(double *)a6.i64 - 1.0;
    }
    sub_406A1B(a1, a5, a6);
    sub_405057(a1, v10, v11, v12, *(double *)a5.i64, a6);
    a2 = &v9[a1[13]];
  }
  else
  {
    a6.i64[0] = *(__int64 *)(a3 + 8);
    a5.i64[1] = a6.i64[1];
    *(double *)a5.i64 = *(double *)a6.i64 + 1.0;
    if ( (a4 & 1) != 0 )
    {
      a5.i64[1] = a6.i64[1];
      *(double *)a5.i64 = *(double *)a6.i64 - 1.0;
    }
    *(_QWORD *)(a3 + 8) = a5.i64[0];
  }
  if ( (v7 & 2) == 0 )
    a6 = a5;
  result = *(unsigned int *)a2;
  v14 = (_DWORD *)*((_QWORD *)a2 + 1);
  *((_QWORD *)a2 + 1) = a6.i64[0];
  *(_DWORD *)a2 = 0;
  if ( (result & 8) != 0 && v14[1]-- == 1 )
    return sub_40CFCD((__int64)a1, v14, a3, a4, a5, a6);
  return result;
}
// 421A5A: variable 'v11' is possibly undefined
// 421A5A: variable 'v12' is possibly undefined
// 421AA8: variable 'a3' is possibly undefined
// 421AA8: variable 'a4' is possibly undefined

//----- (0000000000421ABC) ----------------------------------------------------
__int64 __fastcall sub_421ABC(_QWORD *a1, _QWORD *a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  __int64 result; // rax

  v4 = a2[8];
  v5 = a2[2];
  v6 = *(_QWORD *)(a2[6] + 24LL);
  a1[13] = v4 + a1[10];
  sub_404C48((__int64)a1, *(unsigned __int16 *)(v5 + 96), (_DWORD)v6 + 2 - (unsigned int)(v4 >> 4), v5, a3, a4);
  result = a1[10] + a2[10];
  a1[11] = result;
  return result;
}

//----- (0000000000421B08) ----------------------------------------------------
__int64 __fastcall sub_421B08(_QWORD *a1, __m128 a2, __m128 a3)
{
  _QWORD *v3; // r12
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rsi
  __int64 result; // rax

  v3 = (_QWORD *)a1[15];
  v4 = v3[8];
  v5 = v3[2];
  v6 = v3[9];
  a1[13] = v4 + a1[10];
  sub_404C48((__int64)a1, *(unsigned __int16 *)(v5 + 96), (unsigned __int64)(v6 + 16 - v4) >> 4, v5, a2, a3);
  result = a1[10] + v3[10];
  a1[11] = result;
  return result;
}

//----- (0000000000421B56) ----------------------------------------------------
__int64 __fastcall sub_421B56(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  _QWORD *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  _DWORD *v10; // rsi

  v7 = (_QWORD *)(a2[10] + *(_QWORD *)(a2[15] + 72LL));
  if ( (*(_BYTE *)a3 & 8) != 0 )
  {
    a4 = *(_QWORD *)(a3 + 8);
    ++*(_DWORD *)(a4 + 4);
  }
  v8 = *(_QWORD *)a3;
  v9 = *(_QWORD *)(a3 + 8);
  if ( (*(_BYTE *)v7 & 8) != 0 )
  {
    v10 = (_DWORD *)v7[1];
    *v7 = v8;
    v7[1] = v9;
    if ( v10[1]-- == 1 )
      sub_40CFCD(a1, v10, a3, a4, a5, a6);
  }
  else
  {
    *v7 = v8;
    v7[1] = v9;
  }
  return sub_421B08(a2, a5, a6);
}

//----- (0000000000421BAE) ----------------------------------------------------
unsigned int *__fastcall sub_421BAE(
        __int64 *a1,
        unsigned int a2,
        __int64 a3,
        char a4,
        unsigned int a5,
        __m128 a6,
        __m128 a7)
{
  __int64 v10; // r15
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int128 v16; // xmm2
  unsigned int *result; // rax
  _DWORD *v18; // rdx
  _DWORD *v19; // rsi
  __int64 v20; // rcx

  v10 = a1[15];
  sub_418892(a1, v10, a3, 1u, a6, a7);
  sub_405D63(a1, a6, a7);
  *(double *)a7.i64 = 1.0;
  if ( (a4 & 1) != 0 )
    *(double *)a6.i64 = *(double *)a6.i64 - 1.0;
  else
    *(double *)a6.i64 = *(double *)a6.i64 + 1.0;
  if ( (a4 & 2) != 0 )
  {
    sub_406A1B(a1, a6, a7);
    sub_4188B7(a1, v10, a3, (__int64 *)(a1[14] - 16), a5, a6, a7);
    sub_407DE7((__int64)a1, v10, v13, v14, a6, a7);
  }
  else
  {
    sub_407DE7((__int64)a1, v10, v11, v12, a6, a7);
    sub_406A1B(a1, a6, a7);
    sub_4188B7(a1, v10, a3, (__int64 *)(a1[14] - 16), a5, a6, a7);
  }
  v15 = a1[14];
  v16 = *(_OWORD *)(v15 - 16);
  result = (unsigned int *)(16LL * a2 + a1[13]);
  v18 = (_DWORD *)(v15 - 16);
  v20 = *result;
  v19 = (_DWORD *)*((_QWORD *)result + 1);
  *(_OWORD *)result = v16;
  *v18 = 2;
  a1[14] = (__int64)v18;
  LOBYTE(v20) = v20 & 8;
  if ( (_BYTE)v20 )
  {
    if ( v19[1]-- == 1 )
      return (unsigned int *)sub_40CFCD((__int64)a1, v19, (__int64)v18, v20, a6, a7);
  }
  return result;
}
// 421C27: variable 'v13' is possibly undefined
// 421C27: variable 'v14' is possibly undefined
// 421C36: variable 'v11' is possibly undefined
// 421C36: variable 'v12' is possibly undefined

//----- (0000000000421CC1) ----------------------------------------------------
__int64 __fastcall sub_421CC1(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __m128 a5, __m128 a6)
{
  int v7; // er12
  __int64 v8; // rbx
  _DWORD *v9; // rsi
  bool v10; // zf
  __int64 result; // rax
  __int64 v12; // rcx
  __int64 v13; // rdx
  _DWORD *v14; // rsi

  v7 = a4;
  v8 = 16 * a2 + *(_QWORD *)(a1 + 80);
  if ( (*(_BYTE *)v8 & 8) != 0 )
  {
    v9 = *(_DWORD **)(v8 + 8);
    v10 = v9[1]-- == 1;
    if ( v10 )
      sub_40CFD5(a1, v9, (__int64)a3, a4, a5, a6);
  }
  result = *a3;
  v12 = a3[1];
  v13 = (unsigned int)*a3;
  *(_QWORD *)v8 = *a3;
  *(_QWORD *)(v8 + 8) = v12;
  LOBYTE(v13) = v13 & 8;
  if ( (_BYTE)v13 )
    ++*(_DWORD *)(v12 + 4);
  if ( (*(_BYTE *)(v8 + 16) & 8) != 0 )
  {
    v14 = *(_DWORD **)(v8 + 24);
    v10 = v14[1]-- == 1;
    if ( v10 )
      result = sub_40CFD5(a1, v14, v13, v12, a5, a6);
  }
  *(_DWORD *)(v8 + 16) = 0;
  *(double *)(v8 + 24) = (double)v7;
  return result;
}

//----- (0000000000421D43) ----------------------------------------------------
__int64 __fastcall sub_421D43(_QWORD *a1, __int64 *a2, unsigned int a3, __m128 a4, __m128 a5)
{
  _QWORD *v5; // rbx
  __int64 result; // rax

  v5 = (_QWORD *)a1[15];
  sub_421CC1((__int64)a1, *(_QWORD *)(v5[6] + 24LL), a2, a3, a4, a5);
  sub_421ABC(a1, v5, a4, a5);
  result = v5[6];
  v5[7] = *(_QWORD *)(result + 16) + 4LL;
  *(_DWORD *)(result + 32) &= ~0x20u;
  return result;
}

//----- (0000000000421D90) ----------------------------------------------------
__int64 __fastcall sub_421D90(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 v6; // r13
  __int64 i; // rbx
  __int64 v8; // rax
  int v9; // eax
  __int64 result; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rbx
  bool v16; // zf
  __int64 v17; // r13
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rcx

  v6 = a2;
  for ( i = a1[15]; ; sub_412059((__int64)a1, i, (v9 & 0xFu) - 1, a4, a5, a6) )
  {
    v8 = *(_QWORD *)(i + 48);
    if ( !v8 )
      break;
    v9 = *(_DWORD *)(v8 + 32);
    if ( (v9 & 0xF) == 1 && (v9 & 0x20) != 0 )
    {
      sub_421D43(a1, (__int64 *)(a1[14] - 16), 6u, a5, a6);
      return 0LL;
    }
    a2 = i;
  }
  result = 1LL;
  if ( i == v6 )
    return result;
  if ( (unsigned __int64)a1[16] <= 1 )
  {
    v17 = a1[18];
    sub_4121C6((__int64 *)v17, a2, a3, a4, a5, a6);
    sub_406883((__int64 *)v17, (__int128 *)(a1[14] - 16), a5, a6);
    sub_407C45((__int64 *)v17, (__int64)a1, a5, a6);
    sub_411FBE((__int64)a1, (__int64)a1, v18, v19, a5, a6);
    a1[18] = 0LL;
    v16 = (*(_DWORD *)(v17 + 4))-- == 1;
    if ( v16 )
      sub_40CFE0((__int64)a1, v17, v20, v21, a5, a6);
    *(_BYTE *)(v17 + 73) = 2;
    *(_QWORD *)(a1[8] + 184) = v17;
    sub_421B56((__int64)a1, (_QWORD *)v17, *(_QWORD *)(v17 + 112) - 32LL, v21, a5, a6);
  }
  else
  {
    v11 = *(unsigned int *)(a1[15] + 88);
    if ( (v11 & 0x24) != 0 )
    {
      v11 &= 0x20u;
      sub_4205E2(a1, v11, a5, a6);
    }
    v12 = a1[14];
    v13 = (__int64 *)(a1[10] + *(_QWORD *)(*(_QWORD *)(a1[15] + 24) + 72LL));
    if ( (*(_BYTE *)(v12 - 16) & 8) != 0 )
      ++*(_DWORD *)(*(_QWORD *)(v12 - 8) + 4LL);
    v14 = *(_QWORD *)(v12 - 16);
    v15 = *(_QWORD *)(v12 - 8);
    if ( (*(_BYTE *)v13 & 8) != 0 )
    {
      v11 = v13[1];
      *v13 = v14;
      v13[1] = v15;
      v16 = (*(_DWORD *)(v11 + 4))-- == 1;
      if ( v16 )
        sub_40CFCD((__int64)a1, (_DWORD *)v11, v12, v14, a5, a6);
    }
    else
    {
      *v13 = v14;
      v13[1] = v15;
    }
    sub_4121C6(a1, v11, v12, v14, a5, a6);
    sub_421B08(a1, a5, a6);
  }
  return 0LL;
}
// 421DDE: variable 'a4' is possibly undefined
// 421E6C: variable 'v12' is possibly undefined
// 421E6C: variable 'v14' is possibly undefined
// 421E86: variable 'a3' is possibly undefined
// 421EAA: variable 'v18' is possibly undefined
// 421EAA: variable 'v19' is possibly undefined
// 421EC7: variable 'v20' is possibly undefined
// 421EC7: variable 'v21' is possibly undefined

//----- (0000000000421EFA) ----------------------------------------------------
__int64 __fastcall sub_421EFA(_QWORD *a1, int a2, unsigned int a3, __int64 a4, __m128 a5, __m128 a6)
{
  __int64 i; // r13
  __int64 v8; // rax
  unsigned int v9; // eax
  __int64 v10; // rdx
  __int64 result; // rax
  __int64 v12; // rdx
  __int64 v13[6]; // [rsp+10h] [rbp-30h] BYREF

  for ( i = a1[15]; ; sub_412059((__int64)a1, i, v10, a4, a5, a6) )
  {
    v8 = *(_QWORD *)(i + 48);
    if ( !v8 )
      break;
    v9 = *(_DWORD *)(v8 + 32);
    v10 = v9 & 0xF;
    if ( (_DWORD)v10 == 1 )
    {
      if ( (v9 & 0x20) != 0 )
      {
        *(double *)a5.i64 = (double)a2;
        LODWORD(v13[0]) = 0;
        *(double *)&v13[1] = (double)a2;
        return sub_421D43(a1, v13, a3, a5, a6);
      }
    }
    else if ( (_DWORD)v10 == 2 && a2 == v9 >> 8 )
    {
      v12 = a1[15];
      result = *(_QWORD *)(*(_QWORD *)(v12 + 48) + 16LL) + 4LL * (a3 == 5);
      *(_QWORD *)(v12 + 56) = result;
      return result;
    }
  }
  return sub_401CB7(a1, (__int64)"third_party/duktape/duk_js_executor.c", 1540, a5, a6);
}
// 421F7B: variable 'a4' is possibly undefined

//----- (0000000000421FA0) ----------------------------------------------------
__int64 __fastcall sub_421FA0(__int64 a1, _DWORD *a2, _DWORD *a3, __int64 a4, __m128 a5, __m128 a6, __m128 a7)
{
  _DWORD *v8; // r14
  __int64 v10; // rax
  unsigned int v11; // er13
  __int64 v12; // rbx
  __int64 v13; // rdx
  __int64 v14; // r8
  __int64 v15; // r9
  bool v16; // zf
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // rbx
  int v22; // eax
  _QWORD *v23; // rbx
  __int64 v24; // rax
  __int64 v25; // rax
  _DWORD *v26; // rsi
  __int64 v27; // rdx
  __int64 v28; // rax
  _DWORD *v29; // rsi
  __int64 v30; // rdx
  int v31; // eax

  v8 = a2;
  while ( 1 )
  {
    v10 = *(_QWORD *)(a1 + 64);
    v11 = *(_DWORD *)(v10 + 136);
    if ( v11 == 2 )
    {
      v12 = *(_QWORD *)(a1 + 144);
      if ( !*(_DWORD *)(v10 + 140) )
      {
        sub_4121C6(*(__int64 **)(a1 + 144), (__int64)a2, (__int64)a3, a4, a5, a6);
        sub_421B56(a1, (_QWORD *)v12, *(_QWORD *)(a1 + 64) + 144LL, v18, a5, a6);
        *(_BYTE *)(a1 + 73) = 4;
        *(_QWORD *)(a1 + 144) = 0LL;
        v16 = (*(_DWORD *)(v12 + 4))-- == 1;
        if ( v16 )
          sub_40CAE2(a1, v12, v19, v17, a5, a6);
        *(_BYTE *)(v12 + 73) = 2;
        goto LABEL_28;
      }
      *(_BYTE *)(a1 + 73) = 4;
      *(_QWORD *)(a1 + 144) = 0LL;
      v16 = (*(_DWORD *)(v12 + 4))-- == 1;
      if ( v16 )
      {
        a2 = (_DWORD *)v12;
        sub_40CAE2(a1, v12, (__int64)a3, a4, a5, a6);
      }
      *(_BYTE *)(v12 + 73) = 2;
      v10 = *(_QWORD *)(a1 + 64);
      goto LABEL_23;
    }
    if ( v11 == 3 )
      break;
    if ( v11 != 1 )
    {
      sub_401CB7((__int64 *)a1, (__int64)"third_party/duktape/duk_js_executor.c", 1476, a5, a6);
      return 0;
    }
    while ( 1 )
    {
      v21 = *(_QWORD *)(a1 + 120);
      if ( !v21 )
        break;
      while ( 1 )
      {
        v20 = *(_QWORD *)(v21 + 48);
        if ( !v20 )
          break;
        v22 = *(_DWORD *)(v20 + 32);
        if ( (v22 & 0x10) != 0 )
        {
          v23 = *(_QWORD **)(a1 + 120);
          sub_421CC1(a1, *(_QWORD *)(v23[6] + 24LL), (__int64 *)(*(_QWORD *)(a1 + 64) + 144LL), 1LL, a5, a6);
          sub_421ABC((_QWORD *)a1, v23, a5, a6);
          v24 = v23[6];
          v16 = (*(_BYTE *)(v24 + 32) & 0x40) == 0;
          v23[7] = *(_QWORD *)(v24 + 16);
          if ( !v16 )
            *a3 = 1;
          *(_DWORD *)(v24 + 32) &= ~0x10u;
          goto LABEL_45;
        }
        if ( (v22 & 0x20) != 0 )
        {
          sub_421D43((_QWORD *)a1, (__int64 *)(*(_QWORD *)(a1 + 64) + 144LL), 1u, a5, a6);
          goto LABEL_45;
        }
        a2 = (_DWORD *)v21;
        sub_412059(a1, v21, (__int64)a3, a4, a5, a6);
      }
      if ( (_DWORD *)v21 == v8 )
        return v11;
      sub_4121C6((__int64 *)a1, (__int64)a2, (__int64)a3, a4, a5, a6);
    }
    v12 = *(_QWORD *)(a1 + 144);
    sub_411FBE(a1, (__int64)a2, (__int64)a3, a4, a5, a6);
    *(_QWORD *)(a1 + 144) = 0LL;
    v16 = (*(_DWORD *)(v12 + 4))-- == 1;
    if ( v16 )
    {
      a2 = (_DWORD *)v12;
      sub_40CAE2(a1, v12, (__int64)a3, a4, a5, a6);
    }
    *(_BYTE *)(v12 + 73) = 2;
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 184LL) = v12;
LABEL_24:
    a1 = v12;
  }
  v11 = *(_DWORD *)(v10 + 140);
  v12 = *(_QWORD *)(v10 + 168);
  if ( v11 )
  {
    *(_QWORD *)(v12 + 144) = a1;
    ++*(_DWORD *)(a1 + 4);
    *(_BYTE *)(v12 + 73) = 2;
    *(_BYTE *)(a1 + 73) = 3;
LABEL_23:
    *(_QWORD *)(v10 + 184) = v12;
    *(_DWORD *)(*(_QWORD *)(v12 + 64) + 136LL) = 1;
    goto LABEL_24;
  }
  if ( *(_BYTE *)(v12 + 73) == 4 )
  {
    v13 = *(_QWORD *)(v12 + 80) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 120) + 24LL) + 72LL);
    if ( (*(_BYTE *)(v10 + 144) & 8) != 0 )
    {
      a4 = *(_QWORD *)(v10 + 152);
      ++*(_DWORD *)(a4 + 4);
    }
    v14 = *(_QWORD *)(v10 + 144);
    v15 = *(_QWORD *)(v10 + 152);
    if ( (*(_BYTE *)v13 & 8) != 0 )
    {
      a2 = *(_DWORD **)(v13 + 8);
      *(_QWORD *)v13 = v14;
      *(_QWORD *)(v13 + 8) = v15;
      v16 = a2[1]-- == 1;
      if ( v16 )
        sub_40CFCD(a1, a2, v13, a4, a5, a6);
    }
    else
    {
      *(_QWORD *)v13 = v14;
      *(_QWORD *)(v13 + 8) = v15;
    }
    sub_4121C6((__int64 *)v12, (__int64)a2, v13, a4, a5, a6);
    sub_421B08((_QWORD *)v12, a5, a6);
  }
  else
  {
    sub_4068D1(*(__int64 **)(v10 + 168), (__int64)a2, (__int64)a3, a5, a6);
    sub_406883((__int64 *)v12, (__int128 *)(*(_QWORD *)(a1 + 64) + 144LL), a5, a6);
    if ( !(unsigned int)sub_421382(v12, 1, 8u, a5, a6, a7) )
    {
      sub_401CB7((__int64 *)a1, (__int64)"third_party/duktape/duk_js_executor.c", 1235, a5, a6);
      return v11;
    }
  }
  *(_QWORD *)(v12 + 144) = a1;
  ++*(_DWORD *)(a1 + 4);
  *(_BYTE *)(v12 + 73) = 2;
  *(_BYTE *)(a1 + 73) = 3;
LABEL_28:
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 184LL) = v12;
LABEL_45:
  v25 = *(_QWORD *)(a1 + 64);
  v27 = *(unsigned int *)(v25 + 144);
  v26 = *(_DWORD **)(v25 + 152);
  *(_QWORD *)(v25 + 136) = 0LL;
  *(_DWORD *)(v25 + 144) = 2;
  LOBYTE(v27) = v27 & 8;
  if ( (_BYTE)v27 )
  {
    v16 = v26[1]-- == 1;
    if ( v16 )
      sub_40CFCD(a1, v26, v27, v17, a5, a6);
  }
  v28 = *(_QWORD *)(a1 + 64);
  v30 = *(unsigned int *)(v28 + 160);
  v29 = *(_DWORD **)(v28 + 168);
  *(_DWORD *)(v28 + 160) = 2;
  LOBYTE(v30) = v30 & 8;
  if ( !(_BYTE)v30 )
    return 0;
  v31 = v29[1];
  v11 = v31 - 1;
  v29[1] = v31 - 1;
  if ( v31 != 1 )
    return 0;
  sub_40CFCD(a1, v29, v30, v17, a5, a6);
  return v11;
}
// 42205F: variable 'a4' is possibly undefined
// 422070: variable 'v13' is possibly undefined
// 422082: variable 'a3' is possibly undefined
// 422156: variable 'v18' is possibly undefined
// 422178: variable 'v19' is possibly undefined
// 422178: variable 'v17' is possibly undefined

//----- (0000000000422318) ----------------------------------------------------
__int64 __fastcall sub_422318(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __m128 a4,
        __m128 a5,
        __m128 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        char a10)
{
  unsigned int v10; // ebx
  __int64 *v11; // r12
  unsigned int *v12; // r14
  __int64 v13; // rax
  __int64 *v14; // r12
  _QWORD *v15; // r13
  bool v16; // zf
  __int64 v17; // r14
  int *v18; // rbx
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __m128 *v22; // rsi
  __m128 *v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rax
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // rax
  double v29; // r8
  __int64 v30; // rax
  __int64 v31; // rax
  double *v32; // rax
  double *v33; // rax
  __int64 v34; // rax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  signed int v39; // er13
  __int64 v40; // rdx
  __int64 v41; // rcx
  __int64 v42; // r14
  int v43; // eax
  int v44; // eax
  unsigned int *v45; // r14
  unsigned int v46; // eax
  __int64 v47; // rax
  __int64 v48; // rsi
  __int64 v49; // r13
  __int64 v50; // rdx
  __int64 v51; // rcx
  __int64 v52; // rax
  __int64 v53; // rsi
  int v54; // er9
  int v55; // eax
  _DWORD *v56; // rdx
  int v57; // er9
  int v58; // eax
  _DWORD *v59; // rsi
  int v60; // er9
  int v61; // eax
  int v62; // er9
  int v63; // eax
  __int64 v64; // rsi
  int v65; // eax
  _DWORD *v66; // rdx
  int v67; // eax
  _DWORD *v68; // rsi
  int v69; // eax
  int v70; // eax
  __int64 v71; // rsi
  int v72; // er9
  int v73; // eax
  _DWORD *v74; // rdx
  int v75; // er9
  int v76; // eax
  _DWORD *v77; // rsi
  int v78; // er9
  int v79; // eax
  int v80; // er9
  int v81; // eax
  __int64 v82; // rsi
  int v83; // eax
  _DWORD *v84; // rdx
  int v85; // eax
  _DWORD *v86; // rsi
  int v87; // eax
  int v88; // eax
  __int64 v89; // rsi
  int v90; // er9
  int v91; // eax
  __int64 v92; // rsi
  int v93; // er9
  int v94; // eax
  __int64 v95; // rdx
  int v96; // er9
  int v97; // eax
  int v98; // er9
  int v99; // eax
  __int64 v100; // rsi
  int v101; // er9
  int v102; // eax
  __int64 v103; // rdx
  int v104; // er9
  int v105; // eax
  __int64 v106; // rsi
  int v107; // er9
  int v108; // eax
  int v109; // er9
  int v110; // eax
  __int64 v111; // rsi
  int v112; // er9
  int v113; // eax
  __int64 v114; // rdx
  int v115; // er9
  int v116; // eax
  __int64 v117; // rsi
  int v118; // er9
  int v119; // eax
  int v120; // er9
  int v121; // eax
  __int64 v122; // rsi
  int v123; // er9
  int v124; // eax
  __int64 v125; // rsi
  int v126; // er9
  int v127; // eax
  __int64 v128; // rdx
  int v129; // er9
  int v130; // eax
  int v131; // er9
  int v132; // eax
  __int64 v133; // rdi
  __int64 v134; // rdi
  __int64 v135; // rax
  __int64 v136; // rdx
  __int64 v137; // rax
  __int64 v138; // rdx
  __int64 v139; // rax
  __int64 v140; // rdx
  __int64 v141; // rax
  __int64 v142; // rdx
  __int64 v143; // rax
  __int64 v144; // rdx
  __int64 v145; // rax
  __int64 v146; // rdx
  __int64 v147; // rax
  __int128 *v148; // rdx
  __int64 v149; // rax
  __int128 *v150; // rdx
  __int64 v151; // rax
  __int128 *v152; // rdx
  __int64 v153; // rax
  __int128 *v154; // rdx
  __int64 v155; // rax
  __int128 *v156; // rdx
  __int64 v157; // rax
  __int128 *v158; // rdx
  __int64 v159; // rsi
  int v160; // er9
  int v161; // eax
  __int128 *v162; // rdx
  int v163; // er9
  int v164; // eax
  __int128 *v165; // rsi
  int v166; // er9
  int v167; // eax
  int v168; // er9
  int v169; // eax
  __int64 v170; // rsi
  int v171; // er9
  int v172; // eax
  __int128 *v173; // rdx
  int v174; // er9
  int v175; // eax
  __int128 *v176; // rsi
  int v177; // er9
  int v178; // eax
  int v179; // er9
  int v180; // eax
  __int64 v181; // rax
  __int64 v182; // rax
  __int64 v183; // rax
  __int64 v184; // rax
  __int64 v185; // rax
  __int64 v186; // rax
  __int64 v187; // rax
  __int64 v188; // rax
  __int64 v189; // rax
  __int64 v190; // r14
  __int128 *v191; // rsi
  __int64 v192; // rax
  __int64 v193; // r13
  __int64 v194; // rdx
  __int64 v195; // rcx
  __int64 v196; // rsi
  __int64 *v197; // rsi
  __int64 v198; // rdx
  __int64 v199; // rdx
  __int64 v200; // rcx
  int v201; // eax
  __int64 v202; // rsi
  _DWORD *v203; // rax
  __int128 v204; // xmm3
  __m128 *v205; // rdx
  _DWORD *v206; // rax
  __int128 v207; // xmm4
  __int128 *v208; // rsi
  _DWORD *v209; // rax
  __int128 v210; // xmm5
  _DWORD *v211; // rax
  __int128 v212; // xmm6
  __int64 v213; // rax
  __int64 v214; // r13
  __int64 v215; // r14
  _DWORD *v216; // rax
  __int128 v217; // xmm7
  __int64 v218; // rdx
  __int64 v219; // r14
  __m128 *v220; // rax
  __int64 v221; // r13
  __m128 *v222; // rax
  _DWORD *v223; // rax
  __int128 v224; // xmm3
  __int64 v225; // rdx
  __int64 v226; // rax
  __int64 v227; // rdx
  __int64 v228; // rax
  __int64 v229; // rdx
  __int64 v230; // rax
  _DWORD *v231; // rax
  __int64 v232; // rax
  __int64 v233; // rsi
  int v234; // er9
  int v235; // eax
  _DWORD *v236; // rax
  __int128 *v237; // rsi
  int v238; // er9
  int v239; // eax
  __int64 v240; // rdx
  __int64 v241; // r15
  int v242; // eax
  bool v243; // r14
  char v244; // r8
  int v245; // er9
  __int64 v246; // rax
  _QWORD *v247; // r13
  __int64 v248; // rdx
  __int64 v249; // rcx
  __int64 v250; // rsi
  __int64 v251; // rsi
  _DWORD *v252; // rax
  __int128 v253; // xmm4
  __int64 v254; // rdx
  unsigned int v255; // eax
  unsigned int v256; // ebx
  __int64 v257; // rdx
  __int64 v258; // rcx
  __int64 v259; // rdx
  __int64 v260; // rcx
  _QWORD *v261; // rsi
  __int64 v262; // r13
  _DWORD *v263; // rax
  __int128 v264; // xmm5
  __int64 v265; // rsi
  __int64 v266; // rdx
  __int64 v267; // rcx
  _DWORD *v268; // rax
  __int128 v269; // xmm6
  __int64 v270; // r9
  __int64 *v271; // rcx
  _DWORD *v272; // rax
  __int64 v273; // rsi
  int v274; // er9
  int v275; // eax
  __int64 v276; // rax
  __int64 v277; // rax
  __int64 result; // rax
  __int64 v279; // rax
  _QWORD *v280; // rax
  __int64 v281; // rdx
  __int64 v282; // rax
  __int64 v283; // rdx
  __int64 v284; // rax
  unsigned int v285; // er15
  unsigned int v286; // ebx
  unsigned int v287; // er15
  _QWORD *v288; // rax
  __int64 v289; // rcx
  __int64 v290; // r8
  __int64 v291; // r9
  __int64 v292; // r10
  _QWORD *v293; // r13
  __int64 v294; // rdx
  __int64 v295; // rdx
  __int64 v296; // r14
  int *v297; // rax
  __int64 v298; // r14
  int v299; // eax
  __int64 v300; // r13
  __int64 v301; // rdx
  unsigned int *v302; // rax
  _DWORD *v303; // rsi
  __int64 v304; // rdx
  unsigned int *v305; // rax
  __int64 v306; // r14
  __int64 v307; // r13
  int v308; // eax
  __int64 v309; // rsi
  unsigned int *v310; // rax
  _DWORD *v311; // rsi
  __int64 v312; // rdx
  unsigned int *v313; // rax
  __int64 v314; // r8
  __int64 v315; // rax
  __int64 v316; // rdx
  int i; // esi
  __int64 *v318; // rdi
  __int64 v319; // rax
  __int64 v320; // rdx
  __int64 v321; // rdx
  unsigned int v322; // eax
  __int64 v323; // rbx
  __int64 v324; // rdi
  unsigned int *v325; // rax
  _DWORD *v326; // r8
  unsigned int v327; // er14
  _DWORD *v328; // r15
  __int64 v329; // rdx
  __int64 v330; // rcx
  char v331; // r14
  __int64 v332; // rax
  unsigned int v333; // ebx
  __int64 v334; // rax
  _DWORD *v335; // rax
  __int128 v336; // xmm3
  __int64 v337; // rax
  _DWORD *v338; // rax
  __int128 v339; // xmm4
  unsigned int v340; // er15
  unsigned int v341; // er13
  int v342; // esi
  __int16 v343; // dx
  __int64 v344; // rcx
  unsigned int v345; // er15
  unsigned int v346; // eax
  unsigned int v347; // er13
  unsigned int v348; // ebx
  int v349; // er14
  int v350; // esi
  unsigned int v351; // edx
  __int64 v352; // rdx
  __int64 v353; // rax
  unsigned __int8 v354; // er14^2
  unsigned int v355; // ebx
  __int64 v356; // rdx
  unsigned int v357; // er14
  __int64 v358; // rdx
  __int64 v359; // rcx
  __int64 v360; // rdx
  __int64 v361; // rcx
  __int64 v362; // r8
  __int64 v363; // r9
  unsigned __int8 v364; // er14^2
  unsigned int v365; // ebx
  _BOOL4 v366; // eax
  __int64 v367; // r15
  unsigned int v368; // er14
  unsigned int v369; // eax
  __int64 v370; // rdx
  __int64 v371; // rcx
  _DWORD *v372; // rax
  __int128 v373; // xmm5
  __int64 v374; // rdi
  int v375; // eax
  __int64 v376; // rdx
  char v377; // [rsp-100h] [rbp-100h]
  __int64 v378; // [rsp-D8h] [rbp-D8h]
  int v379; // [rsp-CCh] [rbp-CCh]
  __int64 v380; // [rsp-C8h] [rbp-C8h]
  __int64 v381; // [rsp-C0h] [rbp-C0h]
  double v383; // [rsp-B0h] [rbp-B0h]
  _DWORD *v384; // [rsp-A8h] [rbp-A8h]
  __int64 v385; // [rsp-A0h] [rbp-A0h]
  __int64 v386; // [rsp-98h] [rbp-98h]
  int v387; // [rsp-8Ch] [rbp-8Ch] BYREF
  __int64 v388; // [rsp-88h] [rbp-88h] BYREF
  _QWORD v389[16]; // [rsp-80h] [rbp-80h] BYREF
  void *retaddr; // [rsp+0h] [rbp+0h]

  v389[15] = retaddr;
  v389[9] = &a10;
  v13 = *(_QWORD *)(a1 + 64);
  v387 = 0;
  v385 = v13;
  v384 = *(_DWORD **)(a1 + 120);
  v379 = *(_DWORD *)(v13 + 200);
  v381 = *(_QWORD *)(v13 + 128);
  while ( 1 )
  {
    *(_QWORD *)(v385 + 128) = v389;
    if ( !(unsigned int)sub_43ACAE(v389, a2, a3, (__int64)v389, a8, a9, v377) )
      break;
    a2 = (__int64)v384;
    *(_DWORD *)(v385 + 200) = v379;
    v374 = *(_QWORD *)(v385 + 184);
    *(_QWORD *)(v385 + 128) = v381;
    v375 = sub_421FA0(v374, v384, &v387, v381, a4, a5, a6);
    --*(_DWORD *)(v385 + 108);
    v318 = *(__int64 **)(v385 + 184);
    if ( v375 )
      goto LABEL_403;
    sub_40CA54((__int64)v318, (__int64)v384, v376, v385, a4, a5);
  }
  v14 = *(__int64 **)(*(_QWORD *)(a1 + 64) + 184LL);
  v15 = (_QWORD *)v14[15];
  if ( v387 )
  {
    v16 = v15[5] == 0LL;
    v17 = v15[6];
    v387 = 0;
    if ( v16 )
      sub_418785((__int64)v14, v15, a4, a5);
    v18 = sub_40D66C(v14, -2147483520, a4, a5);
    sub_407C45(v14, (__int64)v18, a4, a5);
    sub_407808(v14, *(_QWORD *)(v17 + 8), a4, a5);
    sub_406883(v14, (__int128 *)(v14[10] + 16LL * *(_QWORD *)(v17 + 24)), a4, a5);
    a2 = 4294967293LL;
    sub_403D6B(v14, -3, 1, a4, a5);
    *((_QWORD *)v18 + 4) = v15[5];
    v15[5] = v18;
    ++v18[1];
    *(_DWORD *)(v17 + 32) |= 0x80u;
    sub_407DA1((__int64)v14, 4294967293LL, v19, v20, a4, a5);
  }
LABEL_12:
  v11 = *(__int64 **)(*(_QWORD *)(a1 + 64) + 184LL);
  v11[7] = (__int64)&v388;
  v25 = v11[15];
  v24 = *(_QWORD *)(v25 + 16);
  v26 = *(_QWORD *)(v24 + 56);
  v388 = *(_QWORD *)(v25 + 56);
  v380 = v26;
  v27 = v26 + 32;
  v386 = v27;
  while ( 2 )
  {
    v12 = (unsigned int *)v388;
LABEL_14:
    v10 = *v12++;
    switch ( (char)v10 )
    {
      case 0:
        v24 = v11[13];
        v388 = (__int64)v12;
        a2 = v24 + ((v10 >> 12) & 0xFFFF0);
        v28 = v24 + ((v10 >> 4) & 0xFF0);
        if ( (*(_BYTE *)a2 & 8) != 0 )
        {
          v24 = *(_QWORD *)(a2 + 8);
          ++*(_DWORD *)(v24 + 4);
        }
        if ( (*(_BYTE *)v28 & 8) == 0 )
        {
          a6 = *(__m128 *)a2;
          *(_OWORD *)v28 = *(_OWORD *)a2;
          continue;
        }
        v29 = *(double *)(v28 + 8);
        a5 = *(__m128 *)a2;
        *(_OWORD *)v28 = *(_OWORD *)a2;
        v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
        if ( !v16 )
          continue;
        goto LABEL_451;
      case 1:
        v24 = v11[13];
        v388 = (__int64)v12;
        v30 = v24 + ((v10 >> 4) & 0xFF0);
        a2 = v24 + ((v10 >> 12) & 0xFFFF0);
        if ( (*(_BYTE *)v30 & 8) != 0 )
        {
          v24 = *(_QWORD *)(v30 + 8);
          ++*(_DWORD *)(v24 + 4);
        }
        if ( (*(_BYTE *)a2 & 8) == 0 )
        {
          *(_OWORD *)a2 = *(_OWORD *)v30;
          continue;
        }
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = *(_OWORD *)v30;
        v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
        if ( !v16 )
          continue;
        goto LABEL_451;
      case 2:
        a2 = v10 >> 8;
        v388 = (__int64)&v12[a2 - 0x800000];
        continue;
      case 3:
        v388 = (__int64)v12;
        a2 = v386 + ((v10 >> 12) & 0xFFFF0);
        v31 = v11[13] + ((v10 >> 4) & 0xFF0);
        if ( (*(_BYTE *)a2 & 8) != 0 )
        {
          v24 = *(_QWORD *)(a2 + 8);
          ++*(_DWORD *)(v24 + 4);
        }
        if ( (*(_BYTE *)v31 & 8) == 0 )
        {
          *(_OWORD *)v31 = *(_OWORD *)a2;
          continue;
        }
        v29 = *(double *)(v31 + 8);
        *(_OWORD *)v31 = *(_OWORD *)a2;
        v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
        if ( !v16 )
          continue;
        goto LABEL_451;
      case 4:
        v388 = (__int64)v12;
        a2 = HIWORD(v10) - 0x8000;
        v32 = (double *)(v11[13] + ((v10 >> 4) & 0xFF0));
        *(double *)a4.i64 = (double)(int)a2;
        v24 = *(unsigned int *)v32;
        v29 = v32[1];
        *(_DWORD *)v32 = 0;
        LOBYTE(v24) = v24 & 8;
        v32[1] = (double)(int)a2;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 5:
        v388 = (__int64)v12;
        v33 = (double *)(v11[13] + ((v10 >> 4) & 0xFF0));
        v24 = *(unsigned int *)v33;
        v29 = v33[1];
        a2 = ((int)v29 << 16) + HIWORD(v10);
        *(_DWORD *)v33 = 0;
        *(double *)a4.i64 = (double)(int)a2;
        LOBYTE(v24) = v24 & 8;
        v33[1] = (double)(int)a2;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 6:
        v34 = v11[13];
        v388 = (__int64)v12;
        a2 = v34 + ((v10 >> 12) & 0xFFFF0);
        if ( (*(_BYTE *)(v34 - 16) & 8) != 0 )
        {
          v24 = *(_QWORD *)(v34 - 8);
          ++*(_DWORD *)(v24 + 4);
        }
        if ( (*(_BYTE *)a2 & 8) != 0 )
        {
          v29 = *(double *)(a2 + 8);
          *(_OWORD *)a2 = *(_OWORD *)(v34 - 16);
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
          {
LABEL_451:
            a2 = *(_QWORD *)&v29;
            sub_40CFCD((__int64)v11, *(_DWORD **)&v29, v24, v27, a4, a5);
          }
        }
        else
        {
          a5 = *(__m128 *)(v34 - 16);
          *(__m128 *)a2 = a5;
        }
        continue;
      case 7:
        v388 = (__int64)v12;
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v35 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 2;
        if ( (v35 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 8:
        v388 = (__int64)v12;
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v36 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 3;
        if ( (v36 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 9:
        v388 = (__int64)v12;
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v37 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = 1;
        if ( (v37 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 10:
        v388 = (__int64)v12;
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v38 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = 0;
        if ( (v38 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 11:
        v265 = v11[15];
        v388 = (__int64)v12;
        sub_418892(v11, v265, *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8), 1u, a4, a5);
        sub_407DA1((__int64)v11, v265, v266, v267, a4, a5);
        v268 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v269 = *((_OWORD *)v268 - 1);
        v268 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v269;
        *v268 = 2;
        v11[14] = (__int64)v268;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 12:
        v388 = (__int64)v12;
        sub_406883(v11, (__int128 *)(v11[13] + 16LL * HIWORD(v10)), a4, a5);
        v39 = ~(unsigned int)sub_405E01(v11, -1, a4, a5);
        sub_407DA1((__int64)v11, 0xFFFFFFFFLL, v40, v41, a4, a5);
        *(double *)a4.i64 = (double)v39;
        v42 = v11[13] + 16LL * BYTE1(v10);
        v43 = *(_DWORD *)v42;
        a2 = *(_QWORD *)(v42 + 8);
        *(_DWORD *)v42 = 0;
        *(double *)(v42 + 8) = (double)v39;
        if ( (v43 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(a2 + 4))-- == 1;
          if ( v16 )
            goto LABEL_59;
        }
        continue;
      case 13:
        v388 = (__int64)v12;
        v44 = sub_4178C9(v11[13] + 16LL * HIWORD(v10));
        v45 = (unsigned int *)(v11[13] + 16LL * BYTE1(v10));
        v24 = *v45;
        a2 = *((_QWORD *)v45 + 1);
        *v45 = 4;
        v45[2] = v44 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(a2 + 4))-- == 1;
          if ( v16 )
LABEL_59:
            sub_40CFCD((__int64)v11, (_DWORD *)a2, v24, v27, a4, a5);
        }
        continue;
      case 14:
        a2 = HIWORD(v10);
        v388 = (__int64)v12;
        sub_421738(v11, a2, BYTE1(v10), 14, a4, a5);
        continue;
      case 15:
        a2 = HIWORD(v10);
        v388 = (__int64)v12;
        sub_421738(v11, a2, BYTE1(v10), 15, a4, a5);
        continue;
      case 16:
        v53 = v11[13];
        v388 = (__int64)v12;
        v54 = sub_417B16(
                v11,
                (_DWORD *)(((v10 >> 12) & 0xFF0) + v53),
                (_DWORD *)(v53 + ((v10 >> 20) & 0xFF0)),
                0,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v55 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v54;
        if ( (v55 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 17:
        v56 = (_DWORD *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v57 = sub_417B16(v11, (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)), v56, 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v58 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v57;
        if ( (v58 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 18:
        v59 = (_DWORD *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v60 = sub_417B16(v11, v59, (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)), 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v61 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v60;
        if ( (v61 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 19:
        v388 = (__int64)v12;
        v62 = sub_417B16(
                v11,
                (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)),
                (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)),
                0,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v63 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v62;
        if ( (v63 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 20:
        v64 = v11[13];
        v388 = (__int64)v12;
        v65 = sub_417B16(
                v11,
                (_DWORD *)(((v10 >> 12) & 0xFF0) + v64),
                (_DWORD *)(v64 + ((v10 >> 20) & 0xFF0)),
                0,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v65 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 21:
        v66 = (_DWORD *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v67 = sub_417B16(v11, (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)), v66, 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v67 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 22:
        v68 = (_DWORD *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v69 = sub_417B16(v11, v68, (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)), 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v69 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 23:
        v388 = (__int64)v12;
        v70 = sub_417B16(
                v11,
                (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)),
                (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)),
                0,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v70 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 24:
        v71 = v11[13];
        v388 = (__int64)v12;
        v72 = sub_417B16(
                0LL,
                (_DWORD *)(((v10 >> 12) & 0xFF0) + v71),
                (_DWORD *)(v71 + ((v10 >> 20) & 0xFF0)),
                2,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v73 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v72;
        if ( (v73 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 25:
        v74 = (_DWORD *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v75 = sub_417B16(0LL, (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)), v74, 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v76 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v75;
        if ( (v76 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 26:
        v77 = (_DWORD *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v78 = sub_417B16(0LL, v77, (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)), 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v79 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v78;
        if ( (v79 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 27:
        v388 = (__int64)v12;
        v80 = sub_417B16(
                0LL,
                (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)),
                (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)),
                2,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v81 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v80;
        if ( (v81 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 28:
        v82 = v11[13];
        v388 = (__int64)v12;
        v83 = sub_417B16(
                0LL,
                (_DWORD *)(((v10 >> 12) & 0xFF0) + v82),
                (_DWORD *)(v82 + ((v10 >> 20) & 0xFF0)),
                2,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v83 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 29:
        v84 = (_DWORD *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v85 = sub_417B16(0LL, (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)), v84, 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v85 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 30:
        v86 = (_DWORD *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v87 = sub_417B16(0LL, v86, (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)), 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v87 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 31:
        v388 = (__int64)v12;
        v88 = sub_417B16(
                0LL,
                (_DWORD *)(v386 + ((v10 >> 12) & 0xFF0)),
                (_DWORD *)(v386 + ((v10 >> 20) & 0xFF0)),
                2,
                a4,
                a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v88 ^ 1;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 32:
        v89 = v11[13];
        v388 = (__int64)v12;
        v90 = sub_417DC2(v11, ((v10 >> 20) & 0xFF0) + v89, v89 + ((v10 >> 12) & 0xFF0), 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v91 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v90;
        if ( (v91 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 33:
        v92 = v11[13] + ((v10 >> 20) & 0xFF0);
        v388 = (__int64)v12;
        v93 = sub_417DC2(v11, v92, v386 + ((v10 >> 12) & 0xFF0), 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v94 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v93;
        if ( (v94 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 34:
        v95 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        v96 = sub_417DC2(v11, v386 + ((v10 >> 20) & 0xFF0), v95, 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v97 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v96;
        if ( (v97 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 35:
        v388 = (__int64)v12;
        v98 = sub_417DC2(v11, v386 + ((v10 >> 20) & 0xFF0), v386 + ((v10 >> 12) & 0xFF0), 0, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v99 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v98;
        if ( (v99 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 36:
        v100 = v11[13];
        v388 = (__int64)v12;
        v101 = sub_417DC2(v11, ((v10 >> 12) & 0xFF0) + v100, v100 + ((v10 >> 20) & 0xFF0), 3, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v102 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v101;
        if ( (v102 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 37:
        v103 = v11[13] + ((v10 >> 20) & 0xFF0);
        v388 = (__int64)v12;
        v104 = sub_417DC2(v11, v386 + ((v10 >> 12) & 0xFF0), v103, 3, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v105 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v104;
        if ( (v105 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 38:
        v106 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        v107 = sub_417DC2(v11, v106, v386 + ((v10 >> 20) & 0xFF0), 3, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v108 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v107;
        if ( (v108 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 39:
        v388 = (__int64)v12;
        v109 = sub_417DC2(v11, v386 + ((v10 >> 12) & 0xFF0), v386 + ((v10 >> 20) & 0xFF0), 3, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v110 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v109;
        if ( (v110 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 40:
        v111 = v11[13];
        v388 = (__int64)v12;
        v112 = sub_417DC2(v11, ((v10 >> 12) & 0xFF0) + v111, v111 + ((v10 >> 20) & 0xFF0), 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v113 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v112;
        if ( (v113 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 41:
        v114 = v11[13] + ((v10 >> 20) & 0xFF0);
        v388 = (__int64)v12;
        v115 = sub_417DC2(v11, v386 + ((v10 >> 12) & 0xFF0), v114, 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v116 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v115;
        if ( (v116 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 42:
        v117 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        v118 = sub_417DC2(v11, v117, v386 + ((v10 >> 20) & 0xFF0), 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v119 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v118;
        if ( (v119 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 43:
        v388 = (__int64)v12;
        v120 = sub_417DC2(v11, v386 + ((v10 >> 12) & 0xFF0), v386 + ((v10 >> 20) & 0xFF0), 2, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v121 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v120;
        if ( (v121 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 44:
        v122 = v11[13];
        v388 = (__int64)v12;
        v123 = sub_417DC2(v11, ((v10 >> 20) & 0xFF0) + v122, v122 + ((v10 >> 12) & 0xFF0), 1, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v124 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v123;
        if ( (v124 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 45:
        v125 = v11[13] + ((v10 >> 20) & 0xFF0);
        v388 = (__int64)v12;
        v126 = sub_417DC2(v11, v125, v386 + ((v10 >> 12) & 0xFF0), 1, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v127 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v126;
        if ( (v127 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 46:
        v128 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        v129 = sub_417DC2(v11, v386 + ((v10 >> 20) & 0xFF0), v128, 1, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v130 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v129;
        if ( (v130 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 47:
        v388 = (__int64)v12;
        v131 = sub_417DC2(v11, v386 + ((v10 >> 20) & 0xFF0), v386 + ((v10 >> 12) & 0xFF0), 1, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v132 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v131;
        if ( (v132 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 48:
        v133 = v11[13];
        v388 = (__int64)v12;
        a2 = (v10 >> 12) & 0xFFFF0;
        if ( (unsigned int)sub_4178C9(a2 + v133) )
          v388 += 4LL;
        continue;
      case 49:
        v388 = (__int64)v12;
        a2 = (v10 >> 12) & 0xFFFF0;
        if ( (unsigned int)sub_4178C9(v386 + a2) )
          v388 += 4LL;
        continue;
      case 50:
        v134 = v11[13];
        v388 = (__int64)v12;
        a2 = (v10 >> 12) & 0xFFFF0;
        if ( !(unsigned int)sub_4178C9(a2 + v134) )
          v388 += 4LL;
        continue;
      case 51:
        v388 = (__int64)v12;
        a2 = (v10 >> 12) & 0xFFFF0;
        if ( !(unsigned int)sub_4178C9(v386 + a2) )
          v388 += 4LL;
        continue;
      case 52:
        v135 = v11[13];
        v388 = (__int64)v12;
        a2 = v135 + ((v10 >> 12) & 0xFF0);
        sub_4217B1(v11, a2, v135 + ((v10 >> 20) & 0xFF0), BYTE1(v10), a4, a5);
        continue;
      case 53:
        v136 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4217B1(v11, a2, v136, BYTE1(v10), a4, a5);
        continue;
      case 54:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4217B1(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), a4, a5);
        continue;
      case 55:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4217B1(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), a4, a5);
        continue;
      case 56:
        v137 = v11[13];
        v388 = (__int64)v12;
        a2 = v137 + ((v10 >> 12) & 0xFF0);
        sub_4218C9(v11, a2, v137 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x38u, a4, a5, a6);
        continue;
      case 57:
        v138 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v138, BYTE1(v10), 0x38u, a4, a5, a6);
        continue;
      case 58:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x38u, a4, a5, a6);
        continue;
      case 59:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x38u, a4, a5, a6);
        continue;
      case 60:
        v139 = v11[13];
        v388 = (__int64)v12;
        a2 = v139 + ((v10 >> 12) & 0xFF0);
        sub_4218C9(v11, a2, v139 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x3Cu, a4, a5, a6);
        continue;
      case 61:
        v140 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v140, BYTE1(v10), 0x3Cu, a4, a5, a6);
        continue;
      case 62:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x3Cu, a4, a5, a6);
        continue;
      case 63:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x3Cu, a4, a5, a6);
        continue;
      case 64:
        v141 = v11[13];
        v388 = (__int64)v12;
        a2 = v141 + ((v10 >> 12) & 0xFF0);
        sub_4218C9(v11, a2, v141 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x40u, a4, a5, a6);
        continue;
      case 65:
        v142 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v142, BYTE1(v10), 0x40u, a4, a5, a6);
        continue;
      case 66:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x40u, a4, a5, a6);
        continue;
      case 67:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x40u, a4, a5, a6);
        continue;
      case 68:
        v143 = v11[13];
        v388 = (__int64)v12;
        a2 = v143 + ((v10 >> 12) & 0xFF0);
        sub_4218C9(v11, a2, v143 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x44u, a4, a5, a6);
        continue;
      case 69:
        v144 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v144, BYTE1(v10), 0x44u, a4, a5, a6);
        continue;
      case 70:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x44u, a4, a5, a6);
        continue;
      case 71:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x44u, a4, a5, a6);
        continue;
      case 72:
        v145 = v11[13];
        v388 = (__int64)v12;
        a2 = v145 + ((v10 >> 12) & 0xFF0);
        sub_4218C9(v11, a2, v145 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x48u, a4, a5, a6);
        continue;
      case 73:
        v146 = v11[13] + ((v10 >> 20) & 0xFF0);
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v146, BYTE1(v10), 0x48u, a4, a5, a6);
        continue;
      case 74:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x48u, a4, a5, a6);
        continue;
      case 75:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_4218C9(v11, a2, v386 + ((v10 >> 20) & 0xFF0), BYTE1(v10), 0x48u, a4, a5, a6);
        continue;
      case 76:
        v147 = v11[13];
        v388 = (__int64)v12;
        a2 = v147 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v147 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x4Cu, a4, a5);
        continue;
      case 77:
        v148 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v148, BYTE1(v10), 0x4Cu, a4, a5);
        continue;
      case 78:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x4Cu, a4, a5);
        continue;
      case 79:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x4Cu, a4, a5);
        continue;
      case 80:
        v149 = v11[13];
        v388 = (__int64)v12;
        a2 = v149 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v149 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x50u, a4, a5);
        continue;
      case 81:
        v150 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v150, BYTE1(v10), 0x50u, a4, a5);
        continue;
      case 82:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x50u, a4, a5);
        continue;
      case 83:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x50u, a4, a5);
        continue;
      case 84:
        v151 = v11[13];
        v388 = (__int64)v12;
        a2 = v151 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v151 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x54u, a4, a5);
        continue;
      case 85:
        v152 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v152, BYTE1(v10), 0x54u, a4, a5);
        continue;
      case 86:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x54u, a4, a5);
        continue;
      case 87:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x54u, a4, a5);
        continue;
      case 88:
        v153 = v11[13];
        v388 = (__int64)v12;
        a2 = v153 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v153 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x58u, a4, a5);
        continue;
      case 89:
        v154 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v154, BYTE1(v10), 0x58u, a4, a5);
        continue;
      case 90:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x58u, a4, a5);
        continue;
      case 91:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x58u, a4, a5);
        continue;
      case 92:
        v155 = v11[13];
        v388 = (__int64)v12;
        a2 = v155 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v155 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x5Cu, a4, a5);
        continue;
      case 93:
        v156 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v156, BYTE1(v10), 0x5Cu, a4, a5);
        continue;
      case 94:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x5Cu, a4, a5);
        continue;
      case 95:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x5Cu, a4, a5);
        continue;
      case 96:
        v157 = v11[13];
        v388 = (__int64)v12;
        a2 = v157 + ((v10 >> 12) & 0xFF0);
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v157 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x60u, a4, a5);
        continue;
      case 97:
        v158 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, v158, BYTE1(v10), 0x60u, a4, a5);
        continue;
      case 98:
        a2 = v11[13] + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x60u, a4, a5);
        continue;
      case 99:
        a2 = v386 + ((v10 >> 12) & 0xFF0);
        v388 = (__int64)v12;
        sub_42165E(v11, (__int128 *)a2, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), BYTE1(v10), 0x60u, a4, a5);
        continue;
      case 100:
        v159 = v11[13];
        v388 = (__int64)v12;
        v160 = sub_417EEF(
                 v11,
                 (__int128 *)(((v10 >> 12) & 0xFF0) + v159),
                 (__int128 *)(v159 + ((v10 >> 20) & 0xFF0)),
                 a4,
                 a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v161 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v160;
        if ( (v161 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 101:
        v162 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v163 = sub_417EEF(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), v162, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v164 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v163;
        if ( (v164 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 102:
        v165 = (__int128 *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v166 = sub_417EEF(v11, v165, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v167 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v166;
        if ( (v167 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 103:
        v388 = (__int64)v12;
        v168 = sub_417EEF(
                 v11,
                 (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)),
                 (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)),
                 a4,
                 a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v169 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v168;
        if ( (v169 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 104:
        v170 = v11[13];
        v388 = (__int64)v12;
        v171 = sub_417EF6(
                 v11,
                 (__int128 *)(((v10 >> 12) & 0xFF0) + v170),
                 (__int128 *)(v170 + ((v10 >> 20) & 0xFF0)),
                 a4,
                 a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v172 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v171;
        if ( (v172 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 105:
        v173 = (__int128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        v174 = sub_417EF6(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), v173, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v175 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v174;
        if ( (v175 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 106:
        v176 = (__int128 *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v177 = sub_417EF6(v11, v176, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v178 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v177;
        if ( (v178 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 107:
        v388 = (__int64)v12;
        v179 = sub_417EF6(
                 v11,
                 (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)),
                 (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)),
                 a4,
                 a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v180 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v179;
        if ( (v180 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 108:
        v202 = v11[13];
        v388 = (__int64)v12;
        sub_40EC01(v11, (__int128 *)(((v10 >> 12) & 0xFF0) + v202), (__m128 *)(v202 + ((v10 >> 20) & 0xFF0)), a4);
        v203 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v204 = *((_OWORD *)v203 - 1);
        v203 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v204;
        *v203 = 2;
        v11[14] = (__int64)v203;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 109:
        v205 = (__m128 *)(v11[13] + ((v10 >> 20) & 0xFF0));
        v388 = (__int64)v12;
        sub_40EC01(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), v205, a4);
        v206 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v207 = *((_OWORD *)v206 - 1);
        v206 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v207;
        *v206 = 2;
        v11[14] = (__int64)v206;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 110:
        v208 = (__int128 *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        sub_40EC01(v11, v208, (__m128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4);
        v209 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v210 = *((_OWORD *)v209 - 1);
        v209 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v210;
        *v209 = 2;
        v11[14] = (__int64)v209;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 111:
        v388 = (__int64)v12;
        sub_40EC01(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), (__m128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4);
        v211 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v212 = *((_OWORD *)v211 - 1);
        v211 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v212;
        *v211 = 2;
        v11[14] = (__int64)v211;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 112:
        v225 = v11[15];
        v226 = v11[13];
        v388 = (__int64)v12;
        a2 = v226 + ((v10 >> 4) & 0xFF0);
        sub_40F7B6(
          v11,
          (__int64 *)a2,
          (__m128 *)(v226 + ((v10 >> 12) & 0xFF0)),
          (__int128 *)(v226 + ((v10 >> 20) & 0xFF0)),
          HIWORD(**(_DWORD **)(v225 + 16)) & 1,
          a4);
        continue;
      case 113:
        v227 = v11[15];
        v228 = v11[13];
        v388 = (__int64)v12;
        a2 = v228 + ((v10 >> 4) & 0xFF0);
        sub_40F7B6(
          v11,
          (__int64 *)a2,
          (__m128 *)(v386 + ((v10 >> 12) & 0xFF0)),
          (__int128 *)(v228 + ((v10 >> 20) & 0xFF0)),
          HIWORD(**(_DWORD **)(v227 + 16)) & 1,
          a4);
        continue;
      case 114:
        v229 = v11[15];
        v230 = v11[13];
        v388 = (__int64)v12;
        a2 = v230 + ((v10 >> 4) & 0xFF0);
        sub_40F7B6(
          v11,
          (__int64 *)a2,
          (__m128 *)(v230 + ((v10 >> 12) & 0xFF0)),
          (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)),
          HIWORD(**(_DWORD **)(v229 + 16)) & 1,
          a4);
        continue;
      case 115:
        v231 = *(_DWORD **)(v11[15] + 16);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v388 = (__int64)v12;
        sub_40F7B6(
          v11,
          (__int64 *)a2,
          (__m128 *)(v386 + ((v10 >> 12) & 0xFF0)),
          (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)),
          HIWORD(*v231) & 1,
          a4);
        continue;
      case 116:
        v232 = v11[15];
        v233 = v11[13];
        v388 = (__int64)v12;
        v234 = sub_41018F(
                 v11,
                 (__int128 *)(((v10 >> 12) & 0xFF0) + v233),
                 (__int128 *)(v233 + ((v10 >> 20) & 0xFF0)),
                 HIWORD(**(_DWORD **)(v232 + 16)) & 1,
                 a4,
                 a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v235 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v234;
        if ( (v235 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 117:
      case 119:
      case -52:
      case -51:
        goto LABEL_14;
      case 118:
        v236 = *(_DWORD **)(v11[15] + 16);
        v237 = (__int128 *)(v11[13] + ((v10 >> 12) & 0xFF0));
        v388 = (__int64)v12;
        v238 = sub_41018F(v11, v237, (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), HIWORD(*v236) & 1, a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v239 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v238;
        if ( (v239 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case 120:
        v181 = v11[13];
        a2 = v181 + ((v10 >> 4) & 0xFF0);
        v388 = (__int64)v12;
        sub_4219BF(v11, (char *)a2, v181 + ((v10 >> 12) & 0xFFFF0), 120LL, a4, a5);
        continue;
      case 121:
        v182 = v11[13];
        a2 = v182 + ((v10 >> 4) & 0xFF0);
        v388 = (__int64)v12;
        sub_4219BF(v11, (char *)a2, v182 + ((v10 >> 12) & 0xFFFF0), 121LL, a4, a5);
        continue;
      case 122:
        v183 = v11[13];
        a2 = v183 + ((v10 >> 4) & 0xFF0);
        v388 = (__int64)v12;
        sub_4219BF(v11, (char *)a2, v183 + ((v10 >> 12) & 0xFFFF0), 122LL, a4, a5);
        continue;
      case 123:
        v184 = v11[13];
        a2 = v184 + ((v10 >> 4) & 0xFF0);
        v388 = (__int64)v12;
        sub_4219BF(v11, (char *)a2, v184 + ((v10 >> 12) & 0xFFFF0), 123LL, a4, a5);
        continue;
      case 124:
        v185 = v11[15];
        a2 = BYTE1(v10);
        v388 = (__int64)v12;
        sub_421BAE(
          v11,
          BYTE1(v10),
          *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8),
          124,
          HIWORD(**(_DWORD **)(v185 + 16)) & 1,
          a4,
          a5);
        continue;
      case 125:
        v186 = v11[15];
        a2 = BYTE1(v10);
        v388 = (__int64)v12;
        sub_421BAE(
          v11,
          BYTE1(v10),
          *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8),
          125,
          HIWORD(**(_DWORD **)(v186 + 16)) & 1,
          a4,
          a5);
        continue;
      case 126:
        v187 = v11[15];
        a2 = BYTE1(v10);
        v388 = (__int64)v12;
        sub_421BAE(
          v11,
          BYTE1(v10),
          *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8),
          126,
          HIWORD(**(_DWORD **)(v187 + 16)) & 1,
          a4,
          a5);
        continue;
      case 127:
        v188 = v11[15];
        a2 = BYTE1(v10);
        v388 = (__int64)v12;
        sub_421BAE(
          v11,
          BYTE1(v10),
          *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8),
          127,
          HIWORD(**(_DWORD **)(v188 + 16)) & 1,
          a4,
          a5);
        continue;
      case -128:
      case -127:
      case -126:
      case -125:
      case -124:
      case -123:
      case -122:
      case -121:
      case -120:
      case -119:
      case -118:
      case -117:
      case -116:
      case -115:
      case -114:
      case -113:
        v189 = v386;
        v388 = (__int64)v12;
        if ( (v10 & 1) == 0 )
          v189 = v11[13];
        v190 = (v10 >> 12) & 0xFF0;
        v191 = (__int128 *)(v189 + v190);
        v192 = v386;
        if ( (v10 & 2) == 0 )
          v192 = v11[13];
        v193 = (v10 >> 20) & 0xFF0;
        sub_40EC01(v11, v191, (__m128 *)(v192 + v193), a4);
        *(double *)a4.i64 = sub_405CAB(v11, a4, a5);
        v383 = *(double *)a4.i64;
        sub_407DA1((__int64)v11, (__int64)v191, v194, v195, a4, a5);
        if ( (v10 & 4) != 0 )
          *(double *)a4.i64 = *(double *)a4.i64 - 1.0;
        else
          *(double *)a4.i64 = *(double *)a4.i64 + 1.0;
        sub_406A1B(v11, a4, a5);
        v196 = v386;
        if ( (v10 & 1) == 0 )
          v196 = v11[13];
        v197 = (__int64 *)(v190 + v196);
        v198 = v386;
        if ( (v10 & 2) == 0 )
          v198 = v11[13];
        sub_40F7B6(
          v11,
          v197,
          (__m128 *)(v193 + v198),
          (__int128 *)(v11[14] - 16),
          HIWORD(**(_DWORD **)(v11[15] + 16)) & 1,
          a4);
        sub_407DA1((__int64)v11, (__int64)v197, v199, v200, a4, a5);
        if ( (v10 & 8) == 0 )
        {
          a4.i64[0] = v378;
          v383 = *(double *)&v378;
        }
        *(double *)a6.i64 = v383;
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v201 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(double *)(a2 + 8) = v383;
        *(_DWORD *)a2 = 0;
        if ( (v201 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -112:
      case -111:
      case -110:
      case -109:
        v240 = v386;
        v388 = (__int64)v12;
        if ( (v10 & 1) == 0 )
          v240 = v11[13];
        v241 = *(_QWORD *)(v240 + ((v10 >> 12) & 0xFF0) + 8);
        v242 = BYTE1(v10) & 0x10;
        v243 = v242 != 0;
        v244 = BYTE1(v10) & 0xF;
        v245 = v242 != 0;
        if ( v242 )
        {
          v246 = v386;
          if ( (v10 & 2) == 0 )
            v246 = v11[13];
          sub_406883(v11, (__int128 *)(v246 + ((v10 >> 20) & 0xFF0)), a4, a5);
          v245 = v243;
          v244 = BYTE1(v10) & 0xF;
        }
        else
        {
          v11[14] += 16LL;
        }
        v247 = (_QWORD *)v11[15];
        a2 = (__int64)v247;
        if ( (unsigned int)sub_418926(v11, v247, v241, (__m128 *)(v11[14] - 16), v244, v245, *(double *)a4.i64, a5)
          && v243 )
        {
          a2 = (__int64)v247;
          sub_4188B7(
            v11,
            (__int64)v247,
            v241,
            (__int64 *)(v11[14] - 16),
            HIWORD(**(_DWORD **)(v11[15] + 16)) & 1,
            a4,
            a5);
        }
        sub_407DA1((__int64)v11, a2, v248, v249, a4, a5);
        continue;
      case -108:
      case -107:
      case -106:
      case -105:
        v250 = v386;
        v388 = (__int64)v12;
        if ( (v10 & 2) == 0 )
          v250 = v11[13];
        sub_406883(v11, (__int128 *)(((v10 >> 20) & 0xFF0) + v250), a4, a5);
        v251 = v386;
        if ( (v10 & 1) == 0 )
          v251 = v11[13];
        sub_406883(v11, (__int128 *)(((v10 >> 12) & 0xFF0) + v251), a4, a5);
        sub_41C395(v11, a4, a5);
        v252 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v253 = *((_OWORD *)v252 - 1);
        v252 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v253;
        *v252 = 2;
        v11[14] = (__int64)v252;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -104:
        v261 = (_QWORD *)v11[15];
        v388 = (__int64)v12;
        v262 = *(_QWORD *)(*(_QWORD *)(v261[2] + 64LL) + 8LL * HIWORD(v10));
        if ( !v261[5] )
        {
          sub_418785((__int64)v11, v261, a4, a5);
          v261 = (_QWORD *)v11[15];
        }
        sub_41843F(v11, v262, v261[4], v261[5], 1, a4, a5);
        v263 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v264 = *((_OWORD *)v263 - 1);
        v263 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v264;
        *v263 = 2;
        v11[14] = (__int64)v263;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -103:
        v388 = (__int64)v12;
        v46 = sub_417F60(v11[13] + ((v10 >> 12) & 0xFFFF0));
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v47 = *(_QWORD *)(v11[71] + 8LL * v46);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 8;
        *(_QWORD *)(a2 + 8) = v47;
        ++*(_DWORD *)(v47 + 4);
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -102:
        v48 = v11[15];
        v388 = (__int64)v12;
        v49 = 58LL;
        if ( (unsigned int)sub_418892(v11, v48, *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8), 0, a4, a5) )
        {
          v49 = (unsigned int)sub_417F60(v11[14] - 32);
          sub_407DE7((__int64)v11, v48, v50, v51, a4, a5);
        }
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v52 = *(_QWORD *)(v11[71] + 8 * v49);
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 8;
        *(_QWORD *)(a2 + 8) = v52;
        ++*(_DWORD *)(v52 + 4);
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -101:
        v270 = v11[15];
        v271 = (__int64 *)(v11[13] + ((v10 >> 4) & 0xFF0));
        v272 = *(_DWORD **)(v270 + 16);
        v388 = (__int64)v12;
        a2 = v270;
        sub_4188B7(v11, v270, *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8), v271, HIWORD(*v272) & 1, a4, a5);
        continue;
      case -100:
        v273 = v11[15];
        v388 = (__int64)v12;
        v274 = sub_4188CF(v11, v273, *(_QWORD *)(v386 + ((v10 >> 12) & 0xFFFF0) + 8), a4, a5);
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v275 = *(_DWORD *)a2;
        v29 = *(double *)(a2 + 8);
        *(_DWORD *)a2 = 4;
        *(_DWORD *)(a2 + 8) = v274;
        if ( (v275 & 8) != 0 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -99:
        v21 = v11[15];
        v388 = (__int64)v12;
        v22 = (__m128 *)(v11[13] + ((v10 >> 12) & 0xFFFF0));
        *(_QWORD *)(v21 + 56) = v12;
        v23 = (__m128 *)v11[14];
        v11[7] = 0LL;
        *v23 = *v22;
        goto LABEL_8;
      case -98:
        v279 = v11[15];
        v388 = (__int64)v12;
        *(_QWORD *)(v279 + 56) = v12;
        v11[14] += 16LL;
        v11[7] = 0LL;
        goto LABEL_11;
      case -97:
        v276 = v11[15];
        v388 = (__int64)v12;
        v22 = (__m128 *)(v386 + ((v10 >> 12) & 0xFFFF0));
        *(_QWORD *)(v276 + 56) = v12;
        v23 = (__m128 *)v11[14];
        v11[7] = 0LL;
        a5 = *v22;
        *v23 = *v22;
LABEL_8:
        if ( (v22->i8[0] & 8) != 0 )
        {
          v24 = v22->i64[1];
          ++*(_DWORD *)(v24 + 4);
        }
        goto LABEL_10;
      case -96:
        v277 = v11[15];
        v27 = v380;
        v388 = (__int64)v12;
        *(_QWORD *)(v277 + 56) = v12;
        v23 = (__m128 *)v11[14];
        a6 = *(__m128 *)(v380 + ((v10 >> 12) & 0xFFFF0) + 32);
        v11[7] = 0LL;
        *v23 = a6;
LABEL_10:
        v11[14] = (__int64)&v23[1];
        goto LABEL_11;
      case -95:
        v388 = (__int64)v12;
        v280 = sub_412166(v11, a4, a5);
        v27 = v11[15];
        v281 = v388;
        v280[3] = 0LL;
        v280[1] = 0LL;
        a2 = *(_QWORD *)(v27 + 48);
        v280[2] = v281;
        v24 = v281 + 8;
        *((_DWORD *)v280 + 8) = (HIWORD(v10) << 8) | 2;
        *v280 = a2;
        *(_QWORD *)(v27 + 48) = v280;
        v388 = v24;
        continue;
      case -94:
        a2 = v11[15];
        v388 = (__int64)v12;
        sub_41214B((__int64)v11, a2);
        continue;
      case -93:
        v282 = v11[15];
        v388 = (__int64)v12;
        a2 = HIWORD(v10);
        LODWORD(v283) = 4;
        *(_QWORD *)(v282 + 56) = v12;
        v11[7] = 0LL;
        goto LABEL_400;
      case -92:
        v284 = v11[15];
        v388 = (__int64)v12;
        a2 = HIWORD(v10);
        LODWORD(v283) = 5;
        *(_QWORD *)(v284 + 56) = v12;
        v11[7] = 0LL;
        goto LABEL_400;
      case -91:
        v285 = v10;
        v286 = HIWORD(v10);
        v388 = (__int64)v12;
        v287 = v285 >> 8;
        sub_404F0A(v11, v286, a4, a5);
        sub_405B55(v11, v286, a4, a5);
        a2 = v286 + 1;
        sub_405B55(v11, a2, a4, a5);
        v288 = sub_412166(v11, a4, a5);
        v292 = v11[13] - v11[10];
        v293 = (_QWORD *)v11[15];
        *((_DWORD *)v288 + 8) = 1;
        v288[1] = 0LL;
        v288[2] = v12;
        v294 = v293[6];
        v288[3] = (v292 >> 4) + v286;
        *v288 = v294;
        v293[6] = v288;
        if ( (v287 & 1) != 0 )
          *((_DWORD *)v288 + 8) = 17;
        if ( (v287 & 2) != 0 )
          *((_DWORD *)v288 + 8) |= 0x20u;
        if ( (v287 & 4) != 0 )
        {
          v295 = v11[14];
          *((_DWORD *)v288 + 8) |= 0x40u;
          v294 = *(_QWORD *)(v295 - 8);
          v288[1] = v294;
        }
        else if ( (v287 & 8) != 0 )
        {
          if ( !v293[5] )
            sub_418785((__int64)v11, v293, a4, a5);
          a2 = 2013266048LL;
          v296 = sub_408411(v11, -1, v294, v289, v290, v291, a4, a5);
          v297 = sub_40D676(v11, 2013266048, a4, a5);
          v294 = v293[5];
          *((_QWORD *)v297 + 7) = v296;
          ++*(_DWORD *)(v296 + 4);
          v297[16] = 1;
          *((_QWORD *)v297 + 4) = v294;
          v293[5] = v297;
          ++v297[1];
          *(_DWORD *)(v293[6] + 32LL) |= 0x80u;
        }
        sub_407DA1((__int64)v11, a2, v294, v289, a4, a5);
        v388 += 8LL;
        continue;
      case -90:
        a2 = v11[15];
        v388 = (__int64)v12;
        v298 = *(_QWORD *)(a2 + 48);
        v299 = *(_DWORD *)(v298 + 32);
        v300 = *(_QWORD *)(v298 + 16);
        v301 = v299 & 0xFFFFFFEF;
        *(_DWORD *)(v298 + 32) = v301;
        if ( (v299 & 0x20) != 0 )
        {
          v302 = (unsigned int *)(v11[10] + 16LL * *(_QWORD *)(v298 + 24));
          v304 = *v302;
          v303 = (_DWORD *)*((_QWORD *)v302 + 1);
          *v302 = 2;
          LOBYTE(v304) = v304 & 8;
          if ( (_BYTE)v304 )
          {
            v16 = v303[1]-- == 1;
            if ( v16 )
              sub_40CFCD((__int64)v11, v303, v304, v27, a4, a5);
          }
          v27 = 0x401C000000000000LL;
          v305 = (unsigned int *)(v11[10] + 16 * (*(_QWORD *)(v298 + 24) + 1LL));
          v24 = *v305;
          a2 = *((_QWORD *)v305 + 1);
          *v305 = 0;
          *((_QWORD *)v305 + 1) = 0x401C000000000000LL;
          LOBYTE(v24) = v24 & 8;
          if ( (_BYTE)v24 )
          {
            v16 = (*(_DWORD *)(a2 + 4))-- == 1;
            if ( v16 )
              sub_40CFCD((__int64)v11, (_DWORD *)a2, v24, 0x401C000000000000LL, a4, a5);
          }
          *(_DWORD *)(v298 + 32) &= ~0x20u;
        }
        else
        {
          sub_412059((__int64)v11, a2, v301, v27, a4, a5);
        }
        v388 = v300 + 4;
        continue;
      case -89:
        v388 = (__int64)v12;
        v306 = v11[15];
        v307 = *(_QWORD *)(v306 + 48);
        v308 = *(_DWORD *)(v307 + 32);
        if ( (v308 & 0x80u) != 0 )
        {
          v309 = *(_QWORD *)(v306 + 40);
          LOBYTE(v308) = v308 & 0x7F;
          v24 = *(_QWORD *)(v309 + 32);
          *(_QWORD *)(v306 + 40) = v24;
          *(_DWORD *)(v307 + 32) = v308;
          ++*(_DWORD *)(v24 + 4);
          v16 = (*(_DWORD *)(v309 + 4))-- == 1;
          if ( v16 )
            sub_40CFE0((__int64)v11, v309, v24, v27, a4, a5);
        }
        if ( (*(_BYTE *)(v307 + 32) & 0x20) != 0 )
        {
          v310 = (unsigned int *)(v11[10] + 16LL * *(_QWORD *)(v307 + 24));
          v312 = *v310;
          v311 = (_DWORD *)*((_QWORD *)v310 + 1);
          *v310 = 2;
          LOBYTE(v312) = v312 & 8;
          if ( (_BYTE)v312 )
          {
            v16 = v311[1]-- == 1;
            if ( v16 )
              sub_40CFCD((__int64)v11, v311, v312, v27, a4, a5);
          }
          v27 = 0x401C000000000000LL;
          v313 = (unsigned int *)(v11[10] + 16 * (*(_QWORD *)(v307 + 24) + 1LL));
          v24 = *v313;
          a2 = *((_QWORD *)v313 + 1);
          *v313 = 0;
          *((_QWORD *)v313 + 1) = 0x401C000000000000LL;
          LOBYTE(v24) = v24 & 8;
          if ( (_BYTE)v24 )
          {
            v16 = (*(_DWORD *)(a2 + 4))-- == 1;
            if ( v16 )
              sub_40CFCD((__int64)v11, (_DWORD *)a2, v24, 0x401C000000000000LL, a4, a5);
          }
          *(_DWORD *)(v307 + 32) &= ~0x20u;
        }
        else
        {
          a2 = v306;
          sub_412059((__int64)v11, v306, v24, v27, a4, a5);
        }
        continue;
      case -88:
        v10 >>= 8;
        v314 = v11[15];
        v388 = (__int64)v12;
        v315 = v11[13] + 16 * (v10 + 1LL);
        *(_QWORD *)(v314 + 56) = v12;
        v11[7] = 0LL;
        v283 = (unsigned int)(int)*(double *)(v315 + 8);
        if ( (_DWORD)v283 != 6 )
        {
          if ( (unsigned int)v283 > 6 )
          {
            if ( (_DWORD)v283 != 7 )
            {
LABEL_401:
              v316 = v315 - 16;
              for ( i = (int)*(double *)(v315 + 8); ; i = 1 )
              {
                sub_40BA4F((__int64)v11, i, v316);
                v318 = v11;
LABEL_403:
                sub_40B99E(v318, a4, a5);
LABEL_404:
                v319 = v11[15];
                v10 >>= 16;
                v388 = (__int64)v12;
                *(_QWORD *)(v319 + 56) = v12;
                v11[7] = 0LL;
                sub_404F0A(v11, v10, a4, a5);
                sub_40B994(v11, v10, v320, a4, a5);
                v316 = v11[14] - 16;
              }
            }
            a2 = v314;
            sub_412059((__int64)v11, v314, v283, v27, a4, a5);
          }
          else
          {
            v27 = (unsigned int)(v283 - 4);
            if ( (unsigned int)v27 > 1 )
              goto LABEL_401;
            a2 = (unsigned int)(int)*(double *)(v315 - 8);
LABEL_400:
            sub_421EFA(v11, a2, v283, v27, a4, a5);
          }
          goto LABEL_12;
        }
        sub_406883(v11, (__int128 *)(v315 - 16), a4, a5);
LABEL_11:
        a2 = (__int64)v384;
        if ( !(unsigned int)sub_421D90(v11, (__int64)v384, v24, v27, a4, a5) )
          goto LABEL_12;
LABEL_352:
        result = v385;
        *(_QWORD *)(v385 + 128) = v381;
        return result;
      case -87:
        goto LABEL_404;
      case -86:
        v388 = (__int64)v12;
        sub_401C42(v11, (__int64)"third_party/duktape/duk_js_executor.c", 0x40013B7u, "invalid lvalue", a4, a5);
        goto LABEL_352;
      case -85:
        v321 = v11[13];
        v322 = v10;
        v323 = 16LL * BYTE1(v10);
        v388 = (__int64)v12;
        a2 = *(_QWORD *)(v321 + v323);
        v324 = *(_QWORD *)(v321 + v323 + 8);
        v325 = (unsigned int *)(v321 + 16LL * HIWORD(v322));
        v27 = *v325;
        v326 = (_DWORD *)*((_QWORD *)v325 + 1);
        v327 = v325[4];
        v328 = (_DWORD *)*((_QWORD *)v325 + 3);
        v24 = (unsigned int)a2;
        *(_QWORD *)v325 = a2;
        *((_QWORD *)v325 + 1) = v324;
        LOBYTE(v24) = a2 & 8;
        if ( (a2 & 8) != 0 )
          ++*(_DWORD *)(v324 + 4);
        LOBYTE(v27) = v27 & 8;
        v325[4] = 2;
        if ( (_BYTE)v27 )
        {
          v16 = v326[1]-- == 1;
          if ( v16 )
          {
            a2 = (__int64)v326;
            sub_40CFCD((__int64)v11, v326, v24, v27, a4, a5);
          }
        }
        if ( (v327 & 8) != 0 )
        {
          v16 = v328[1]-- == 1;
          if ( v16 )
          {
            a2 = (__int64)v328;
            sub_40CFCD((__int64)v11, v328, v24, v27, a4, a5);
          }
        }
        continue;
      case -84:
      case -83:
      case -82:
      case -81:
        v254 = v386;
        v388 = (__int64)v12;
        if ( (v10 & 1) == 0 )
          v254 = v11[13];
        v255 = v10 >> 12;
        v256 = BYTE1(v10);
        sub_418892(v11, v11[15], *(_QWORD *)(v254 + (v255 & 0xFF0) + 8), 1u, a4, a5);
        sub_405057(v11, v256 + 1, v257, v258, *(double *)a4.i64, a5);
        a2 = v256;
        sub_405057(v11, v256, v259, v260, *(double *)a4.i64, a5);
        continue;
      case -80:
      case -79:
      case -78:
      case -77:
      case -76:
      case -75:
      case -74:
      case -73:
        v388 = (__int64)v12;
        sub_404BCC((__int64)v11, HIWORD(v10) + BYTE1(v10) + 2, v24, v27, a4, a5);
        a2 = HIWORD(v10);
        if ( !(unsigned int)sub_4213B2(v11, a2, v10 & 7 | 8) )
          goto LABEL_415;
        goto LABEL_12;
      case -72:
      case -71:
      case -70:
      case -69:
      case -68:
      case -67:
      case -66:
      case -65:
        v388 = (__int64)v12;
        v331 = v10;
        v332 = v11[13] + 16LL * BYTE1(v10);
        v333 = HIWORD(v10);
        sub_404BCC((__int64)v11, v333 + (int)*(double *)(v332 + 8) + 2, v24, v27, a4, a5);
        a2 = v333;
        if ( (unsigned int)sub_4213B2(v11, v333, v331 & 7 | 8u) )
          goto LABEL_12;
LABEL_415:
        a2 = *(unsigned __int16 *)(*(_QWORD *)(v11[15] + 16) + 96LL);
        sub_404BCC((__int64)v11, a2, v329, v330, a4, a5);
        continue;
      case -64:
        v388 = (__int64)v12;
        sub_407095(v11, a4, a5);
        v334 = sub_405B41((__int64)v11, -1);
        sub_40E495(v11, v334, BYTE1(v10), a4, a5);
        v335 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v336 = *((_OWORD *)v335 - 1);
        v335 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v336;
        *v335 = 2;
        v11[14] = (__int64)v335;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -63:
        v388 = (__int64)v12;
        sub_4070BA(v11, a4, a5);
        v337 = sub_405B41((__int64)v11, -1);
        sub_40DF53(v11, v337, 0, BYTE1(v10), 0, 0, a4, a5);
        v338 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v339 = *((_OWORD *)v338 - 1);
        v338 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v339;
        *v338 = 2;
        v11[14] = (__int64)v338;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -62:
      case -61:
        v388 = (__int64)v12;
        v340 = BYTE2(v10);
        if ( (unsigned __int8)v10 == 195 )
          v340 = (int)*(double *)(v11[13] + 16LL * BYTE2(v10) + 8);
        v341 = HIBYTE(v10) + v340;
        do
        {
          sub_404F0A(v11, v340, a4, a5);
          v342 = v340 + 1;
          v340 += 2;
          sub_404F0A(v11, v342, a4, a5);
          a2 = BYTE1(v10);
          sub_403E29(v11, BYTE1(v10), 639, a4, a5);
        }
        while ( v341 > v340 );
        continue;
      case -60:
      case -59:
        v388 = (__int64)v12;
        sub_404F0A(v11, HIWORD(v10), a4, a5);
        sub_404F0A(v11, HIWORD(v10) + 1, a4, a5);
        v343 = 822;
        if ( (unsigned __int8)v10 != 196 )
          v343 = 694;
        a2 = BYTE1(v10);
        sub_403E29(v11, BYTE1(v10), v343, a4, a5);
        continue;
      case -58:
      case -57:
        v344 = v11[13];
        v388 = (__int64)v12;
        v345 = BYTE1(v10);
        v346 = BYTE2(v10);
        a4.i64[0] = *(__int64 *)(v344 + 16LL * BYTE2(v10) + 8);
        if ( (unsigned __int8)v10 == 199 )
          v346 = (int)*(double *)a4.i64;
        v347 = HIBYTE(v10) + v346;
        v348 = v346 + 1;
        v349 = (int)*(double *)(v344 + 16LL * v346 + 8);
        do
        {
          v350 = v348++;
          sub_404F0A(v11, v350, a4, a5);
          v351 = v349++;
          sub_403DB2(v11, v345, v351, 7, a4, a5);
        }
        while ( v347 > v348 );
        a2 = v345;
        sub_406AF7(v11, v345, a4, a5);
        continue;
      case -56:
        v352 = v11[13];
        v388 = (__int64)v12;
        a2 = (v10 >> 12) & 0xFFFF0;
        v353 = *(_QWORD *)(v352 + ((v10 >> 4) & 0xFF0) + 8);
        v24 = (unsigned int)(int)*(double *)(v352 + a2 + 8);
        *(_DWORD *)(v353 + 56) = v24;
        continue;
      case -55:
        v388 = (__int64)v12;
        v354 = BYTE2(v10);
        v355 = HIBYTE(v10);
        v357 = v354;
        if ( (sub_406103((__int64)v11, v355) & 6) != 0 )
        {
          sub_40691D(v11, v355, v356, a4, a5);
        }
        else
        {
          sub_404F0A(v11, v355, a4, a5);
          sub_408290(v11, -1, a4, a5, v360, v361, v362, v363);
          sub_40D757(v11, 0, a4, a5);
        }
        a2 = v357;
        sub_405057(v11, v357, v358, v359, *(double *)a4.i64, a5);
        continue;
      case -54:
        v388 = (__int64)v12;
        v364 = BYTE2(v10);
        v365 = HIBYTE(v10);
        a2 = v365;
        v366 = sub_40653D((__int64)v11, v365);
        v367 = v366;
        v368 = v364;
        if ( v366 )
        {
          sub_404F0A(v11, v365, a4, a5);
          v369 = sub_40DAF3(v11, 0, a4, a5);
          v367 = v369;
          if ( v369 )
            v367 = 1LL;
          else
            v11[14] += 16LL;
          a2 = v368;
          sub_405057(v11, v368, v370, v371, *(double *)a4.i64, a5);
        }
        v388 += 4 * v367;
        continue;
      case -53:
        v388 = (__int64)v12;
        sub_406FCC(v11, a4, a5, a2, v24);
        v372 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 12) & 0xFFFF0);
        v373 = *((_OWORD *)v372 - 1);
        v372 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v373;
        *v372 = 2;
        v11[14] = (__int64)v372;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -50:
        v388 = (__int64)v12;
        sub_401B75(v11, (__int64)"third_party/duktape/duk_js_executor.c", 0x10013DAu, "INVALID opcode (%ld)", v10 >> 8);
        goto LABEL_352;
      case -49:
      case -44:
      case -43:
      case -42:
      case -41:
      case -40:
      case -39:
      case -38:
      case -37:
      case -36:
      case -35:
      case -34:
      case -33:
      case -32:
      case -31:
      case -30:
      case -29:
      case -28:
      case -27:
      case -26:
      case -25:
      case -24:
      case -23:
      case -22:
      case -21:
      case -20:
      case -19:
      case -18:
      case -17:
      case -16:
      case -15:
      case -14:
      case -13:
      case -12:
      case -11:
      case -10:
      case -9:
      case -8:
      case -7:
      case -6:
      case -5:
      case -4:
      case -3:
      case -2:
      case -1:
        v388 = (__int64)v12;
        sub_401CD7(v11, (__int64)"third_party/duktape/duk_js_executor.c", 5168, "invalid opcode", a4, a5);
        goto LABEL_352;
      case -48:
        v213 = v11[13];
        v388 = (__int64)v12;
        v214 = (v10 >> 20) & 0xFF0;
        v215 = (v10 >> 12) & 0xFF0;
        sub_40EC01(v11, (__int128 *)(v213 + v215), (__m128 *)(v213 + v214), a4);
        if ( !sub_4066B4((__int64)v11, v11[14] - 16) )
          sub_401EA7(v11, (__int128 *)(v215 + v11[13]), (__int128 *)(v11[13] + v214), a4, a5);
        v216 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v217 = *((_OWORD *)v216 - 1);
        v216 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v217;
        *v216 = 2;
        v11[14] = (__int64)v216;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -47:
        v218 = v11[13];
        v388 = (__int64)v12;
        v219 = (v10 >> 20) & 0xFF0;
        sub_40EC01(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), (__m128 *)(v219 + v218), a4);
        if ( !sub_4066B4((__int64)v11, v11[14] - 16) )
          sub_401EA7(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), (__int128 *)(v219 + v11[13]), a4, a5);
        v220 = (__m128 *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        a5 = v220[-1];
        --v220;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(__m128 *)a2 = a5;
        v220->i32[0] = 2;
        v11[14] = (__int64)v220;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -46:
        v388 = (__int64)v12;
        v221 = (v10 >> 12) & 0xFF0;
        sub_40EC01(v11, (__int128 *)(v221 + v11[13]), (__m128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4);
        if ( !sub_4066B4((__int64)v11, v11[14] - 16) )
          sub_401EA7(v11, (__int128 *)(v221 + v11[13]), (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4, a5);
        v222 = (__m128 *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        a6 = v222[-1];
        --v222;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(__m128 *)a2 = a6;
        v222->i32[0] = 2;
        v11[14] = (__int64)v222;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
      case -45:
        v388 = (__int64)v12;
        sub_40EC01(v11, (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)), (__m128 *)(v386 + ((v10 >> 20) & 0xFF0)), a4);
        if ( !sub_4066B4((__int64)v11, v11[14] - 16) )
          sub_401EA7(
            v11,
            (__int128 *)(v386 + ((v10 >> 12) & 0xFF0)),
            (__int128 *)(v386 + ((v10 >> 20) & 0xFF0)),
            a4,
            a5);
        v223 = (_DWORD *)v11[14];
        a2 = v11[13] + ((v10 >> 4) & 0xFF0);
        v224 = *((_OWORD *)v223 - 1);
        v223 -= 4;
        v24 = *(unsigned int *)a2;
        v29 = *(double *)(a2 + 8);
        *(_OWORD *)a2 = v224;
        *v223 = 2;
        v11[14] = (__int64)v223;
        LOBYTE(v24) = v24 & 8;
        if ( (_BYTE)v24 )
        {
          v16 = (*(_DWORD *)(*(_QWORD *)&v29 + 4LL))-- == 1;
          if ( v16 )
            goto LABEL_451;
        }
        continue;
    }
  }
}
// 42239C: variable 'a3' is possibly undefined
// 42239C: variable 'a8' is possibly undefined
// 42239C: variable 'a9' is possibly undefined
// 42239C: variable 'v377' is possibly undefined
// 422445: variable 'v19' is possibly undefined
// 422445: variable 'v20' is possibly undefined
// 4224A9: variable 'v24' is possibly undefined
// 4224A9: variable 'v27' is possibly undefined
// 42288F: variable 'v40' is possibly undefined
// 42288F: variable 'v41' is possibly undefined
// 422A1A: variable 'v50' is possibly undefined
// 422A1A: variable 'v51' is possibly undefined
// 424B54: variable 'v194' is possibly undefined
// 424B54: variable 'v195' is possibly undefined
// 424BEC: variable 'v199' is possibly undefined
// 424BEC: variable 'v200' is possibly undefined
// 424BF6: variable 'v378' is possibly undefined
// 425452: variable 'v248' is possibly undefined
// 425452: variable 'v249' is possibly undefined
// 425574: variable 'v257' is possibly undefined
// 425574: variable 'v258' is possibly undefined
// 42557E: variable 'v259' is possibly undefined
// 42557E: variable 'v260' is possibly undefined
// 425655: variable 'v266' is possibly undefined
// 425655: variable 'v267' is possibly undefined
// 4259BF: variable 'v294' is possibly undefined
// 4259BF: variable 'v289' is possibly undefined
// 4259BF: variable 'v290' is possibly undefined
// 4259BF: variable 'v291' is possibly undefined
// 425C0E: variable 'v11' is possibly undefined
// 425C20: variable 'v10' is possibly undefined
// 425C28: variable 'v12' is possibly undefined
// 425C41: variable 'v320' is possibly undefined
// 425D2A: variable 'v329' is possibly undefined
// 425D2A: variable 'v330' is possibly undefined
// 42602C: variable 'v356' is possibly undefined
// 426037: variable 'v358' is possibly undefined
// 426037: variable 'v359' is possibly undefined
// 426051: variable 'v360' is possibly undefined
// 426051: variable 'v361' is possibly undefined
// 426051: variable 'v362' is possibly undefined
// 426051: variable 'v363' is possibly undefined
// 4260C4: variable 'v370' is possibly undefined
// 4260C4: variable 'v371' is possibly undefined
// 4261D6: variable 'v376' is possibly undefined
// 4213B2: using guessed type __int64 __fastcall sub_4213B2(_QWORD, _QWORD, _QWORD);

//----- (00000000004261E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4261E0(__int64 a1, int a2, int a3)
{
  int v3; // eax
  unsigned __int64 result; // rax
  int v5; // ecx
  unsigned int v6; // edx

  v3 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 28) += a3;
  result = (unsigned int)(v3 << a3);
  *(_DWORD *)(a1 + 24) = result | a2;
  while ( 1 )
  {
    v5 = *(_DWORD *)(a1 + 28);
    if ( v5 <= 7 )
      break;
    result = *(_QWORD *)(a1 + 8);
    if ( result >= *(_QWORD *)(a1 + 16) )
    {
      *(_DWORD *)(a1 + 32) = 1;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 8) = result + 1;
      *(_BYTE *)(*(_QWORD *)a1 + result) = v6 >> (v5 - 8);
    }
    *(_DWORD *)(a1 + 28) -= 8;
  }
  return result;
}

//----- (0000000000426227) ----------------------------------------------------
unsigned __int64 __fastcall sub_426227(__int64 a1)
{
  unsigned __int64 result; // rax

  if ( 8 - *(_DWORD *)(a1 + 28) > 0 )
    return sub_4261E0(a1, 0, 8 - *(_DWORD *)(a1 + 28));
  return result;
}

//----- (0000000000426238) ----------------------------------------------------
__int64 __fastcall sub_426238(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40869C(a1, a2, a3);
  sub_4037B9(a1, -65449, a2, a3);
  return sub_405E64(a1, -1, a2, a3);
}

//----- (0000000000426263) ----------------------------------------------------
_DWORD *__fastcall sub_426263(__int64 a1)
{
  _DWORD *result; // rax

  result = 0LL;
  if ( *(_DWORD *)(a1 - 16) == 9 )
  {
    result = *(_DWORD **)(a1 - 8);
    if ( (*result & 0x408040) != (_DWORD)&locret_408000 || result[14] > result[12] )
      return 0LL;
  }
  return result;
}

//----- (000000000042628A) ----------------------------------------------------
__int64 __fastcall sub_42628A(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 result; // rax

  result = sub_426238(a1, a2, a3);
  if ( (int)result < 0 )
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 79, "invalid length", a2, a3);
    return 0LL;
  }
  return result;
}

//----- (00000000004262BB) ----------------------------------------------------
void __fastcall sub_4262BB(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // ebx

  v6 = sub_40370E(a1, 1, a2, a4, a5);
  if ( (unsigned int)sub_40370E(a1, 1, a3, a4, a5) )
  {
    sub_403953(a1, 1, a2, a4, a5);
  }
  else
  {
    sub_403B1D(a1, 1, a2, a4, a5);
    sub_407DBA((__int64)a1);
  }
  if ( v6 )
  {
    sub_403953(a1, 1, a3, a4, a5);
  }
  else
  {
    sub_403B1D(a1, 1, a3, a4, a5);
    sub_407DBA((__int64)a1);
  }
}

//----- (0000000000426341) ----------------------------------------------------
__int64 __fastcall sub_426341(__int64 *a1, int a2, int a3, __m128 a4, __m128 a5)
{
  int v6; // er13
  __int64 v7; // rsi
  int v8; // eax
  __int64 v9; // rdx
  __int64 v10; // rcx
  unsigned int v11; // er13
  _BOOL4 v12; // er13
  _BOOL4 v13; // eax
  double v14; // xmm0_8
  __int64 v15; // r13

  v6 = sub_40370E(a1, 1, a2, a4, a5);
  v7 = 1LL;
  v8 = sub_40370E(a1, 1, a3, a4, a5);
  if ( !v6 )
  {
    LOBYTE(v11) = v8 != 0;
LABEL_7:
    v11 = (unsigned __int8)v11;
    goto LABEL_14;
  }
  if ( !v8 )
  {
LABEL_3:
    v11 = -1;
LABEL_14:
    sub_407DE7((__int64)a1, v7, v9, v10, a4, a5);
    return v11;
  }
  v7 = 0xFFFFFFFFLL;
  v12 = sub_40649F((__int64)a1, -2);
  v13 = sub_40649F((__int64)a1, -1);
  if ( v12 )
  {
    LOBYTE(v11) = !v13;
    goto LABEL_7;
  }
  if ( v13 )
    goto LABEL_3;
  if ( sub_40649F((__int64)a1, 0) )
  {
    v15 = sub_408998(a1, -2, a4, a5);
    v7 = sub_4089F1(a1, a4, a5);
    v11 = sub_417DB2(v15, v7);
    goto LABEL_14;
  }
  v11 = -1;
  sub_404F0A(a1, 0, a4, a5);
  sub_40500F(a1, -3);
  sub_41DA2F(a1, 2, a4, a5);
  v14 = sub_405CAB(a1, a4, a5);
  if ( v14 >= 0.0 )
    v11 = v14 > 0.0;
  sub_407DA6((__int64)a1);
  return v11;
}
// 426443: variable 'v9' is possibly undefined
// 426443: variable 'v10' is possibly undefined

//----- (0000000000426454) ----------------------------------------------------
void __fastcall sub_426454(__int64 *a1, int a2, int a3, __m128 a4)
{
  __m128 v5; // xmm1
  int v6; // esi
  int v7; // er15
  int i; // ebx
  int v9; // er14
  int v10; // esi

  while ( a3 - a2 > 0 )
  {
    *(double *)a4.i64 = sub_41D71B((__int64)a1);
    v5 = a4;
    *(double *)a4.i64 = (double)(a3 - a2 + 1) * *(double *)a4.i64;
    v6 = a2 + (int)*(double *)a4.i64;
    if ( a2 != v6 )
      sub_4262BB(a1, v6, a2, a4, v5);
    v7 = a3;
    for ( i = a2 + 1; i != a2 && i < a3 && (int)sub_426341(a1, i, a2, a4, v5) < 0; ++i )
LABEL_8:
      ;
    do
      v9 = v7--;
    while ( v9 > a2 && (int)sub_426341(a1, a2, v9, a4, v5) < 0 );
    if ( i < v9 )
    {
      sub_4262BB(a1, i, v9, a4, v5);
      goto LABEL_8;
    }
    if ( v9 != a2 )
      sub_4262BB(a1, a2, v9, a4, v5);
    v10 = a2;
    a2 = v9 + 1;
    sub_426454(a1, v10, v7, a4);
  }
}

//----- (000000000042653A) ----------------------------------------------------
__int64 __fastcall sub_42653A(_QWORD *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // er13
  int v4; // ebx
  unsigned int v5; // esi
  unsigned int v6; // esi

  v3 = sub_404AE7((__int64)a1);
  if ( v3 == 1 && sub_4064DB((__int64)a1, 0) )
  {
    *(double *)a2.i64 = sub_40541C((__int64)a1, 0);
    v4 = sub_405E64(a1, 0, a2, a3);
    a3.i64[0] = a2.i64[0];
    *(double *)a2.i64 = (double)v4;
    if ( sub_41D67C((double)v4, *(double *)a3.i64) )
    {
      v5 = 64;
      if ( (unsigned int)v4 <= 0x40 )
        v5 = v4;
      *(_DWORD *)(sub_40715D(a1, v5, a2, a3) + 56) = v4;
    }
    else
    {
      v3 = 0;
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 159, "invalid length", a2, a3);
    }
  }
  else
  {
    v6 = v3;
    v3 = 1;
    sub_407E10(a1, v6, a2, a3);
  }
  return v3;
}

//----- (00000000004265E7) ----------------------------------------------------
__int64 __fastcall sub_4265E7(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  v3 = sub_417FDB(a1[13]);
  sub_406955(a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042660E) ----------------------------------------------------
__int64 __fastcall sub_42660E(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40869C(a1, a2, a3);
  sub_4037B9(a1, -65498, a2, a3);
  if ( sub_4065F2((__int64)a1, -1) )
  {
    sub_40500F(a1, -2);
    sub_41DA64(a1, 0, a2, a3);
    return 1LL;
  }
  else
  {
    sub_404B20(a1, 0, a2, a3);
    return sub_42AEBE(a1, *(double *)a2.i64, a3);
  }
}

//----- (0000000000426670) ----------------------------------------------------
__int64 __fastcall sub_426670(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // er13
  signed int v4; // ebx
  _DWORD *v5; // r14
  _BOOL4 v6; // eax
  _BOOL4 v7; // er15
  __int64 v8; // rax
  int v9; // er14
  signed int v11; // [rsp+0h] [rbp-40h]
  int v12; // [rsp+4h] [rbp-3Ch]
  int v13; // [rsp+8h] [rbp-38h]
  unsigned int v14; // [rsp+Ch] [rbp-34h]

  v3 = 0;
  v4 = 0;
  sub_40869C(a1, a2, a3);
  sub_40500F(a1, 0);
  v11 = sub_404AE7((__int64)a1);
  sub_4070BA(a1, a2, a3);
  while ( 1 )
  {
    if ( v4 >= v11 )
    {
      sub_406AAF(a1, v3, a2, a3);
      sub_403E13(a1, -33532159, a2, a3);
      return 1LL;
    }
    v5 = (_DWORD *)sub_405823((__int64)a1, v4);
    if ( v5 )
    {
      sub_40377C(a1, v4, 0x4Fu, a2, a3);
      v6 = sub_40649F((__int64)a1, -1) ? sub_417FC2((__int64)v5) : sub_405BBB(a1, -1, a2, a3);
      v7 = v6;
      sub_407DA6((__int64)a1);
      if ( v7 )
        break;
    }
    sub_404F0A(a1, v4, a2, a3);
    sub_403DB2(a1, -2, v3, 7, a2, a3);
    v14 = v3 + 1;
    if ( v3 == -1 )
      goto LABEL_22;
LABEL_20:
    v3 = v14;
    ++v4;
  }
  v12 = *v5 & 0x2000000;
  v8 = sub_405CB0(a1, v4, a2, a3);
  v13 = v8;
  if ( (unsigned int)v8 == v8 )
  {
    v14 = v3 + v8;
    v9 = __CFADD__(v3, (_DWORD)v8);
    if ( !__CFADD__(v3, (_DWORD)v8) )
    {
      while ( 2 )
      {
        if ( v9 == v13 )
          goto LABEL_20;
        if ( v12 )
        {
          if ( (unsigned int)sub_403CC0(a1, v4, v9, a2, a3) )
          {
            sub_40370E(a1, v4, v9, a2, a3);
            goto LABEL_17;
          }
        }
        else if ( (unsigned int)sub_40370E(a1, v4, v9, a2, a3) )
        {
LABEL_17:
          sub_403DB2(a1, -2, v9 + v3, 7, a2, a3);
        }
        else
        {
          sub_407DBA((__int64)a1);
        }
        ++v9;
        continue;
      }
    }
  }
LABEL_22:
  sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 349, "invalid length", a2, a3);
  return 0LL;
}

//----- (0000000000426820) ----------------------------------------------------
__int64 __fastcall sub_426820(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er15
  unsigned int v4; // eax
  int v5; // esi
  unsigned int v6; // er12
  unsigned int v7; // er13
  unsigned int v8; // er14
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v3 = sub_41DCD3((__int64)a1);
  sub_404B20(a1, 1u, a2, a3);
  if ( sub_40649F((__int64)a1, 0) )
  {
    sub_407DBA((__int64)a1);
    sub_407826(a1, 0x3Fu, a2, a3);
  }
  else
  {
    sub_408725(a1, 0, a2, a3);
  }
  v4 = sub_426238(a1, a2, a3);
  v5 = 4096;
  if ( v4 <= 0x1000 )
    v5 = v4;
  v6 = v4;
  v7 = 0;
  v8 = 0;
  sub_404E3A(a1, v5 + 4, a2, a3);
  sub_404FD6(a1, a2, a3);
  while ( v8 <= 0xFFF && v7 < v6 )
  {
LABEL_11:
    sub_40370E(a1, 1, v7, a2, a3);
    if ( (sub_406103((__int64)a1, -1) & 6) != 0 )
    {
      sub_407DA6((__int64)a1);
      sub_407963(a1, a2, a3);
    }
    else
    {
      if ( v3 )
      {
        sub_408290(a1, -1, a2, a3, v9, v10, v11, v12);
        sub_4037B9(a1, -65497, a2, a3);
        sub_40500F(a1, -2);
        sub_41DA64(a1, 0, a2, a3);
      }
      sub_408725(a1, -1, a2, a3);
    }
    ++v8;
    ++v7;
  }
  sub_408F0F(a1, v8, a2, a3);
  sub_404FD6(a1, a2, a3);
  sub_40500F(a1, -2);
  if ( v7 < v6 )
  {
    v8 = 1;
    goto LABEL_11;
  }
  return 1LL;
}
// 42691F: variable 'v9' is possibly undefined
// 42691F: variable 'v10' is possibly undefined
// 42691F: variable 'v11' is possibly undefined
// 42691F: variable 'v12' is possibly undefined

//----- (000000000042696F) ----------------------------------------------------
__int64 __fastcall sub_42696F(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v4; // rax
  int v5; // edx
  _DWORD *v6; // rsi
  __int64 result; // rax
  __int64 v8; // rdi
  _OWORD *v9; // rax
  int v10; // eax
  int v11; // er13

  v4 = sub_426263(a1[13]);
  if ( v4 )
  {
    v5 = v4[14];
    v6 = v4;
    result = 0LL;
    if ( !v5 )
      return result;
    v8 = (unsigned int)v6[10];
    v6[14] = v5 - 1;
    v9 = (_OWORD *)(*((_QWORD *)v6 + 3) + 25 * v8 + (-(char)v8 & 7) + 16LL * (unsigned int)(v5 - 1));
    if ( *(_DWORD *)v9 != 7 )
    {
      *(_OWORD *)a1[14] = *v9;
      *(_DWORD *)v9 = 7;
    }
    a1[14] += 16LL;
  }
  else
  {
    v10 = sub_426238(a1, a2, a3);
    if ( !v10 )
    {
      sub_406A68(a1, 0, a2, a3);
      sub_403A07(a1, 87, a2, a3);
      return 0LL;
    }
    v11 = v10 - 1;
    sub_40370E(a1, 0, v10 - 1, a2, a3);
    sub_403B1D(a1, 0, v11, a2, a3);
    sub_406AAF(a1, v11, a2, a3);
    sub_403A07(a1, 87, a2, a3);
  }
  return 1LL;
}

//----- (0000000000426A44) ----------------------------------------------------
__int64 __fastcall sub_426A44(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rax
  __int64 v4; // r9
  __int64 v5; // r8
  int v6; // er10
  bool v7; // cf
  unsigned int v8; // er10
  int v9; // esi
  __int64 v10; // rcx
  __int64 v11; // rdx
  int v12; // ebx
  int v13; // eax
  int v14; // er15
  int v15; // er14
  int i; // er13
  int v18; // edx

  v3 = sub_426263(a1[13]);
  if ( v3 )
  {
    v5 = (a1[14] - v4) >> 4;
    v6 = v3[14];
    v7 = __CFADD__((_DWORD)v5, v6);
    v8 = v5 + v6;
    if ( v7 )
    {
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 538, "invalid length", a2, a3);
    }
    else if ( v8 <= v3[12] )
    {
      v9 = 0;
      v10 = 0LL;
      v11 = *((_QWORD *)v3 + 3) + 25LL * (unsigned int)v3[10] + 16LL * (unsigned int)v3[14] + (-v3[10] & 7);
      while ( v9 < (int)v5 )
      {
        a2 = *(__m128 *)(v4 + v10);
        ++v9;
        *(__m128 *)(v11 + v10) = a2;
        *(_DWORD *)(v4 + v10) = 2;
        v10 += 16LL;
      }
      a1[14] = v4;
      v3[14] = v8;
      sub_406AAF(a1, v8, a2, a3);
      return 1LL;
    }
  }
  v12 = sub_404AE7((__int64)a1);
  v13 = sub_426238(a1, a2, a3);
  v14 = v13 + v12;
  v15 = v13;
  if ( __CFADD__(v13, v12) )
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 612, "invalid length", a2, a3);
    return 0LL;
  }
  for ( i = 0; i < v12; ++i )
  {
    sub_404F0A(a1, i, a2, a3);
    v18 = i + v15;
    sub_403953(a1, -3, v18, a2, a3);
  }
  sub_406AAF(a1, v14, a2, a3);
  sub_404F67(a1, a2, a3);
  sub_403A07(a1, -262057, a2, a3);
  return 1LL;
}
// 426A72: variable 'v4' is possibly undefined

//----- (0000000000426B90) ----------------------------------------------------
__int64 __fastcall sub_426B90(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  v3 = sub_42628A(a1, a2, a3);
  if ( v3 )
    sub_426454(a1, 0, v3 - 1, a2);
  sub_407DA6((__int64)a1);
  return 1LL;
}

//----- (0000000000426BC2) ----------------------------------------------------
__int64 __fastcall sub_426BC2(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // er8
  int v6; // er13
  int v7; // eax
  int v8; // er15
  int v9; // er14
  int v10; // ebx
  int j; // er13
  int m; // er13
  int v14; // edx
  int v15; // [rsp+8h] [rbp-38h]
  int v16; // [rsp+Ch] [rbp-34h]
  signed int i; // [rsp+Ch] [rbp-34h]
  int k; // [rsp+Ch] [rbp-34h]

  v3 = sub_404AE7((__int64)a1);
  if ( v3 > 1 )
  {
    v4 = v3;
    v5 = 1;
  }
  else
  {
    v4 = 2;
    sub_404B20(a1, 2u, a2, a3);
    v5 = 0;
  }
  v16 = v5;
  v6 = sub_42628A(a1, a2, a3);
  v7 = sub_406077(a1, 0, -v6, v6, a2, a3);
  v8 = v7;
  if ( v7 < 0 )
    v8 = v6 + v7;
  v9 = v6 - v8;
  if ( v16 )
    v9 = sub_406077(a1, 1, 0, v9, a2, a3);
  v10 = v4 - 2;
  *(double *)a3.i64 = (double)v10;
  *(double *)a2.i64 = (double)v6 - (double)v9 + (double)v10;
  if ( *(double *)a2.i64 <= 4294967295.0 )
  {
    sub_4070BA(a1, a2, a3);
    for ( i = 0; v9 > i; ++i )
    {
      if ( (unsigned int)sub_40370E(a1, -3, v8 + i, a2, a3) )
        sub_403DB2(a1, -2, i, 7, a2, a3);
      else
        sub_407DBA((__int64)a1);
    }
    sub_406AAF(a1, v9, a2, a3);
    sub_403E13(a1, -33532159, a2, a3);
    v15 = v6 - v9;
    if ( v9 <= v10 )
    {
      if ( v9 < v10 )
      {
        for ( j = v15 - 1; v8 <= j; --j )
        {
          if ( (unsigned int)sub_40370E(a1, -3, v9 + j, a2, a3) )
          {
            sub_403953(a1, -4, v10 + j, a2, a3);
          }
          else
          {
            sub_407DBA((__int64)a1);
            sub_403B1D(a1, -3, v10 + j, a2, a3);
          }
        }
      }
    }
    else
    {
      for ( k = v8; k < v15; ++k )
      {
        if ( (unsigned int)sub_40370E(a1, -3, v9 + k, a2, a3) )
        {
          sub_403953(a1, -4, v10 + k, a2, a3);
        }
        else
        {
          sub_407DBA((__int64)a1);
          sub_403B1D(a1, -3, v10 + k, a2, a3);
        }
      }
      while ( --v6 >= v10 + v15 )
        sub_403B1D(a1, -3, v6, a2, a3);
    }
    for ( m = 0; m < v10; ++m )
    {
      sub_404F0A(a1, m + 2, a2, a3);
      v14 = v8 + m;
      sub_403953(a1, -4, v14, a2, a3);
    }
    sub_406AAF(a1, v10 + v15, a2, a3);
    sub_403A07(a1, -262057, a2, a3);
    return 1LL;
  }
  else
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 1008, "invalid length", a2, a3);
    return 0LL;
  }
}

//----- (0000000000426E2B) ----------------------------------------------------
__int64 __fastcall sub_426E2B(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // ebx
  unsigned int v5; // eax
  __int64 v6; // rdx
  unsigned int v7; // er13
  __int64 v8; // rcx
  int v9; // er14
  int v10; // er15
  unsigned int v12; // [rsp+Ch] [rbp-34h]

  v4 = 0;
  v5 = sub_426238(a1, a3, a4);
  v7 = v5 - 1;
  v8 = v5 >> 1;
  v12 = v5 >> 1;
  while ( v4 != v12 )
  {
    v9 = v7 - v4;
    v10 = sub_40370E(a1, -2, v4, a3, a4);
    if ( (unsigned int)sub_40370E(a1, -3, v7 - v4, a3, a4) )
    {
      sub_403953(a1, -4, v4, a3, a4);
    }
    else
    {
      sub_403B1D(a1, -4, v4, a3, a4);
      sub_407DBA((__int64)a1);
    }
    a2 = 4294967293LL;
    if ( v10 )
    {
      sub_403953(a1, -3, v9, a3, a4);
    }
    else
    {
      sub_403B1D(a1, -3, v9, a3, a4);
      sub_407DBA((__int64)a1);
    }
    ++v4;
  }
  sub_407DA1((__int64)a1, a2, v6, v8, a3, a4);
  return 1LL;
}
// 426ECB: variable 'v6' is possibly undefined
// 426ECB: variable 'v8' is possibly undefined

//----- (0000000000426EE4) ----------------------------------------------------
__int64 __fastcall sub_426EE4(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  int v4; // er13
  int v5; // eax
  int v6; // er14
  unsigned int i; // er8
  int v8; // er15
  unsigned int v10; // [rsp+Ch] [rbp-34h]

  v3 = sub_42628A(a1, a2, a3);
  sub_4070BA(a1, a2, a3);
  v4 = sub_406077(a1, 0, -v3, v3, a2, a3);
  if ( v4 < 0 )
    v4 += v3;
  if ( !sub_40649F((__int64)a1, 1) )
  {
    v5 = sub_406077(a1, 1, -v3, v3, a2, a3);
    v3 += v5;
    if ( v5 >= 0 )
      v3 = v5;
  }
  v6 = 0;
  for ( i = 0; v3 > (int)(v4 + i); i = v8 )
  {
    v10 = i;
    v8 = i + 1;
    if ( (unsigned int)sub_40370E(a1, 2, v4 + i, a2, a3) )
    {
      v6 = v8;
      sub_403DB2(a1, 4, v10, 7, a2, a3);
    }
    else
    {
      sub_407DBA((__int64)a1);
    }
  }
  sub_406AAF(a1, v6, a2, a3);
  sub_403E13(a1, 67131137, a2, a3);
  return 1LL;
}

//----- (0000000000426FD0) ----------------------------------------------------
__int64 __fastcall sub_426FD0(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  int v5; // ebx
  int v6; // er14
  int v7; // er13

  v3 = sub_426238(a1, a2, a3);
  if ( v3 )
  {
    v5 = 1;
    v6 = v3;
    sub_40370E(a1, 0, 0, a2, a3);
    while ( 1 )
    {
      v7 = v5 - 1;
      if ( v5 == v6 )
        break;
      if ( (unsigned int)sub_40370E(a1, 0, v5, a2, a3) )
      {
        sub_403953(a1, 0, v7, a2, a3);
      }
      else
      {
        sub_403B1D(a1, 0, v7, a2, a3);
        sub_407DBA((__int64)a1);
      }
      ++v5;
    }
    sub_403B1D(a1, 0, v7, a2, a3);
    sub_406AAF(a1, v7, a2, a3);
    sub_403A07(a1, 87, a2, a3);
    return 1LL;
  }
  else
  {
    sub_406A68(a1, 0, a2, a3);
    sub_403A07(a1, 87, a2, a3);
    return 0LL;
  }
}

//----- (0000000000427082) ----------------------------------------------------
__int64 __fastcall sub_427082(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  int v4; // eax
  int v5; // er14
  int v6; // ebx
  int v8; // edx

  v3 = sub_404AE7((__int64)a1);
  v4 = sub_426238(a1, a2, a3);
  v5 = v4 + v3;
  v6 = v4;
  if ( __CFADD__(v4, v3) )
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_array.c", 1298, "invalid length", a2, a3);
    return 0LL;
  }
  else
  {
    while ( v6 )
    {
      if ( (unsigned int)sub_40370E(a1, -2, --v6, a2, a3) )
      {
        sub_403953(a1, -3, v3 + v6, a2, a3);
      }
      else
      {
        sub_407DBA((__int64)a1);
        sub_403B1D(a1, -2, v3 + v6, a2, a3);
      }
    }
    while ( v3 != v6 )
    {
      sub_404F0A(a1, v6, a2, a3);
      v8 = v6++;
      sub_403953(a1, -3, v8, a2, a3);
    }
    sub_406AAF(a1, v5, a2, a3);
    sub_404F67(a1, a2, a3);
    sub_403A07(a1, -262057, a2, a3);
    return 1LL;
  }
}

//----- (0000000000427168) ----------------------------------------------------
__int64 __fastcall sub_427168(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er14
  int v4; // er12
  int v5; // eax
  int v6; // esi
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // er12
  __int64 v11; // rsi
  __int64 v12; // rdx
  __int64 v13; // rcx

  v3 = sub_41DCD3((__int64)a1);
  v4 = sub_404AE7((__int64)a1);
  sub_404B20(a1, 2u, a2, a3);
  v5 = sub_42628A(a1, a2, a3);
  if ( v5 )
  {
    v7 = v5;
    if ( v4 <= 1 )
    {
      v10 = 0;
      if ( v3 <= 0 )
        v10 = v5 - 1;
    }
    else
    {
      if ( v3 > 0 )
      {
        v8 = v5;
        v9 = -v5;
      }
      else
      {
        v8 = v5 - 1;
        v9 = ~v5;
      }
      v10 = sub_406077(a1, 1, v9, v8, a2, a3);
      if ( v10 >= 0 )
        goto LABEL_12;
      v10 += v7;
    }
    while ( v10 >= 0 )
    {
LABEL_12:
      if ( v10 >= v7 )
        break;
      v11 = 2LL;
      if ( (unsigned int)sub_40370E(a1, 2, v10, a2, a3) )
      {
        v11 = 0LL;
        if ( (unsigned int)sub_408133((__int64)a1, 0, a2, a3) )
        {
          v6 = v10;
          goto LABEL_16;
        }
      }
      v10 += v3;
      sub_407DA1((__int64)a1, v11, v12, v13, a2, a3);
    }
  }
  v6 = -1;
LABEL_16:
  sub_406A68(a1, v6, a2, a3);
  return 1LL;
}
// 4271EB: variable 'v12' is possibly undefined
// 4271EB: variable 'v13' is possibly undefined

//----- (0000000000427245) ----------------------------------------------------
__int64 __fastcall sub_427245(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  __int64 v4; // rsi
  __int64 v5; // rdx
  int v6; // er14
  int v7; // er15
  unsigned int i; // ebx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  unsigned int v12; // edx
  int v14; // [rsp+Ch] [rbp-34h]

  v3 = sub_41DCD3((__int64)a1);
  v4 = 0LL;
  v14 = sub_426238(a1, a2, a3);
  sub_40661B(a1, 0, a2, a3);
  sub_4070BA(a1, a2, a3);
LABEL_2:
  v6 = 0;
  v7 = 0;
  for ( i = 0; i != v14; ++i )
  {
    v4 = 2LL;
    if ( (unsigned int)sub_40370E(a1, 2, i, a2, a3) )
    {
      sub_404FD6(a1, a2, a3);
      sub_404FDD(a1, a2, a3);
      sub_404FFB(a1, a2, a3);
      sub_406AAF(a1, i, a2, a3);
      sub_404FE7(a1, a2, a3);
      v4 = 3LL;
      sub_41DA64(a1, 3, a2, a3);
      switch ( v3 )
      {
        case 3:
          v6 = i + 1;
          sub_404F67(a1, a2, a3);
          v4 = 4LL;
          sub_403DB2(a1, 4, i, 7, a2, a3);
          break;
        case 4:
          v4 = 0xFFFFFFFFLL;
          if ( (unsigned int)sub_405BBB(a1, -1, a2, a3) )
          {
            sub_404FF1(a1, a2, a3);
            v12 = v7++;
            v4 = 4LL;
            v6 = v7;
            sub_403DB2(a1, 4, v12, 7, a2, a3);
          }
          break;
        default:
          sub_4068D1(a1, 3LL, v9, a2, a3);
          goto LABEL_2;
      }
      sub_407DE7((__int64)a1, v4, v10, v11, a2, a3);
    }
    else
    {
      if ( v3 == 3 )
        v6 = i + 1;
      sub_407DBA((__int64)a1);
    }
  }
  if ( v3 == 2 )
  {
    sub_4068D1(a1, v4, v5, a2, a3);
  }
  else if ( v3 > 2 )
  {
    sub_406AAF(a1, v6, a2, a3);
    sub_403E13(a1, -33532159, a2, a3);
  }
  else if ( v3 )
  {
    sub_4069DC(a1, a2, a3, v4, v5);
  }
  else
  {
    sub_40699D(a1, a2, a3, v4, v5);
  }
  return 1LL;
}
// 427298: variable 'v9' is possibly undefined
// 427391: variable 'v10' is possibly undefined
// 427391: variable 'v11' is possibly undefined
// 4273AB: variable 'v5' is possibly undefined

//----- (00000000004273EF) ----------------------------------------------------
__int64 __fastcall sub_4273EF(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er15
  int v4; // ebx
  unsigned int v5; // er14
  int v6; // er13
  unsigned int i; // ebx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 result; // rax

  v3 = sub_41DCD3((__int64)a1);
  v4 = sub_404AE7((__int64)a1);
  sub_404B20(a1, 2u, a2, a3);
  v5 = sub_426238(a1, a2, a3);
  sub_40661B(a1, 0, a2, a3);
  if ( v4 <= 1 )
  {
    v6 = 0;
  }
  else
  {
    v6 = 1;
    sub_404FDD(a1, a2, a3);
  }
  for ( i = (v3 >> 31) & (v5 - 1); i < v5; i += v3 )
  {
    if ( (unsigned int)sub_403CC0(a1, 2, i, a2, a3) )
    {
      if ( v6 )
      {
        sub_404FD6(a1, a2, a3);
        sub_404F0A(a1, 4, a2, a3);
        sub_40370E(a1, 2, i, a2, a3);
        sub_406AAF(a1, i, a2, a3);
        sub_404FE7(a1, a2, a3);
        sub_41DA2F(a1, 4, a2, a3);
        sub_405057(a1, 4, v8, v9, *(double *)a2.i64, a3);
      }
      else
      {
        v6 = 1;
        sub_40370E(a1, 2, i, a2, a3);
      }
    }
  }
  result = 1LL;
  if ( !v6 )
  {
    sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_array.c", 1640, a2, a3);
    return 0LL;
  }
  return result;
}
// 4274DA: variable 'v8' is possibly undefined
// 4274DA: variable 'v9' is possibly undefined

//----- (0000000000427511) ----------------------------------------------------
__int64 __fastcall sub_427511(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  __int64 v4; // rax
  unsigned int v5; // er13

  v3 = sub_41DCD3((__int64)a1);
  sub_406FB2(a1, a2, a3);
  v4 = sub_40483D((__int64)a1, -1);
  if ( *(_DWORD *)v4 != 4 )
  {
    if ( *(_DWORD *)v4 != 9 || **(_DWORD **)(v4 + 8) >> 27 != 5 )
    {
      v5 = 0;
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_boolean.c", 39, a2, a3);
      return v5;
    }
    sub_403883(a1, -65430, a2, a3);
  }
  v5 = 1;
  if ( v3 )
    sub_408725(a1, -1, a2, a3);
  return v5;
}

//----- (0000000000427598) ----------------------------------------------------
__int64 __fastcall sub_427598(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rax

  sub_405BBB(a1, 0, a2, a3);
  if ( (unsigned int)sub_41DC85((__int64)a1) )
  {
    sub_406FB2(a1, a2, a3);
    v3 = (_DWORD *)sub_405B41((__int64)a1, -1);
    *v3 = *v3 & 0x7FFFFFF | 0x28000000;
    sub_404FD6(a1, a2, a3);
    sub_403E13(a1, -33527296, a2, a3);
  }
  return 1LL;
}

//----- (00000000004275F7) ----------------------------------------------------
_WORD *__fastcall sub_4275F7(__int64 a1, unsigned int a2, char a3)
{
  __int64 v3; // rax
  _BYTE *v4; // rax
  _WORD *result; // rax
  _WORD *v6[3]; // [rsp+8h] [rbp-18h] BYREF

  v3 = *(_QWORD *)(a1 + 8);
  v6[0] = (_WORD *)(v3 + 1);
  if ( a2 > 0x17 )
  {
    if ( a2 > 0xFF )
    {
      if ( a2 > 0xFFFF )
      {
        *(_BYTE *)v3 = a3 + 26;
        sub_42E3EF((_DWORD **)v6, a2);
      }
      else
      {
        *(_BYTE *)v3 = a3 + 25;
        sub_42E3D7(v6, a2);
      }
    }
    else
    {
      *(_BYTE *)v3 = a3 + 24;
      v4 = v6[0]++;
      *v4 = a2;
    }
  }
  else
  {
    *(_BYTE *)v3 = a2 + a3;
  }
  result = v6[0];
  *(_WORD **)(a1 + 8) = v6[0];
  return result;
}

//----- (000000000042766D) ----------------------------------------------------
__int64 __fastcall sub_42766D(__int64 *a1)
{
  return sub_40807C(a1, 6LL, (__int64)"third_party/duktape/duk_bi_cbor.c", 61, "cbor encode error");
}

//----- (0000000000427689) ----------------------------------------------------
unsigned __int64 __fastcall sub_427689(__int64 a1, unsigned __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned __int64 result; // rax
  __int64 v6; // r13
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // r13
  __int64 v9; // rax
  __int64 v10; // rdx

  result = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 8);
  if ( result < a2 )
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = v6 + a2;
    if ( v6 < 0 || __CFADD__(v6, a2) )
      sub_42766D(*(__int64 **)a1);
    v8 = 2 * v6;
    if ( v7 < v8 )
      v7 = v8;
    v9 = sub_41D79F(*(__int64 **)a1, *(_DWORD *)(a1 + 40), v7, a4, a5);
    v10 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v9;
    *(_QWORD *)(a1 + 32) = v7;
    *(_QWORD *)(a1 + 24) = v9 + v7;
    *(_QWORD *)(a1 + 8) = v10 + v9;
    return a3;
  }
  return result;
}

//----- (0000000000427705) ----------------------------------------------------
__int64 __fastcall sub_427705(__int64 *a1)
{
  return sub_40807C(a1, 6LL, (__int64)"third_party/duktape/duk_bi_cbor.c", 669, byte_441B49);
}

//----- (0000000000427721) ----------------------------------------------------
char __fastcall sub_427721(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx

  if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 16) )
    sub_427705(*(__int64 **)a1);
  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = v1 + 1;
  return *(_BYTE *)(v2 + v1);
}

//----- (0000000000427753) ----------------------------------------------------
__int64 __fastcall sub_427753(__int64 a1)
{
  __int64 v1; // rax
  unsigned int v2; // er8

  if ( *(_QWORD *)(a1 + 16) >= *(_QWORD *)(a1 + 24) )
    sub_427705(*(__int64 **)a1);
  v1 = *(_QWORD *)(a1 + 16);
  v2 = 0;
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 8) + v1) == 0xFF )
  {
    v2 = 1;
    *(_QWORD *)(a1 + 16) = v1 + 1;
  }
  return v2;
}

//----- (0000000000427793) ----------------------------------------------------
__int64 __fastcall sub_427793(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r8

  v2 = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)(a1 + 24) - v2 < a2 )
  {
    sub_427705(*(__int64 **)a1);
    return 0LL;
  }
  else
  {
    v3 = v2 + *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 16) = a2 + v2;
    return v3;
  }
}

//----- (00000000004277C9) ----------------------------------------------------
__int16 __fastcall sub_4277C9(__int64 a1)
{
  __int16 result; // ax

  if ( *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) <= 1uLL )
    sub_427705(*(__int64 **)a1);
  result = sub_42E2B3((_WORD *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)));
  *(_QWORD *)(a1 + 16) += 2LL;
  return result;
}

//----- (00000000004277FE) ----------------------------------------------------
__int64 __fastcall sub_4277FE(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16) <= 3uLL )
    sub_427705(*(__int64 **)a1);
  result = sub_42E2B9((unsigned int *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)));
  *(_QWORD *)(a1 + 16) += 4LL;
  return result;
}

//----- (0000000000427833) ----------------------------------------------------
__int64 __fastcall sub_427833(__int64 **a1, char a2, int a3, __m128 a4, __m128 a5)
{
  int v5; // esi
  int v7; // er13
  double v8; // xmm0_8
  __int64 *v9; // rdi

  LOBYTE(v5) = a2 & 0x1F;
  if ( (unsigned __int8)v5 > 0x17u )
  {
    if ( (_BYTE)v5 == 26 )
    {
      v5 = sub_4277FE((__int64)a1);
    }
    else
    {
      if ( (unsigned __int8)v5 > 0x1Au )
      {
        if ( (_BYTE)v5 != 27 )
          return sub_427705(*a1);
        v7 = sub_4277FE((__int64)a1);
        v8 = (double)(int)sub_4277FE((__int64)a1);
        *(double *)a5.i64 = (double)v7 * 4294967296.0;
        if ( a3 )
          v8 = v8 + 1.0;
        *(double *)a4.i64 = v8 + *(double *)a5.i64;
        if ( a3 )
          a4 = _mm_xor_ps(a4, (__m128)xmmword_43D2F0);
        v9 = *a1;
        return sub_406A1B(v9, a4, a5);
      }
      if ( (_BYTE)v5 == 24 )
        v5 = (unsigned __int8)sub_427721((__int64)a1);
      else
        v5 = (unsigned __int16)sub_4277C9((__int64)a1);
    }
  }
  else
  {
    v5 = (unsigned __int8)v5;
  }
  v9 = *a1;
  if ( a3 )
  {
    if ( v5 >= 0 )
      return sub_406A68(v9, ~v5, a4, a5);
    *(double *)a5.i64 = (double)v5;
    *(double *)a4.i64 = -1.0 - (double)v5;
    return sub_406A1B(v9, a4, a5);
  }
  return sub_406AAF(v9, v5, a4, a5);
}
// 427868: conditional instruction was optimized away because si.1==19
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (0000000000427927) ----------------------------------------------------
__int64 __fastcall sub_427927(__int64 **a1, char a2)
{
  unsigned __int8 v2; // si

  v2 = a2 & 0x1F;
  if ( v2 <= 0x17u )
    return v2;
  if ( v2 == 26 )
    return sub_4277FE((__int64)a1);
  if ( v2 > 0x1Au )
  {
    if ( v2 != 27 || (unsigned int)sub_4277FE((__int64)a1) )
    {
      sub_427705(*a1);
      return 0LL;
    }
    return sub_4277FE((__int64)a1);
  }
  if ( v2 == 24 )
    return (unsigned __int8)sub_427721((__int64)a1);
  else
    return (unsigned __int16)sub_4277C9((__int64)a1);
}
// 427927: could not find valid save-restore pair for rbp
// 42794F: conditional instruction was optimized away because si.1==19

//----- (0000000000427990) ----------------------------------------------------
__int64 __fastcall sub_427990(__int64 **a1, char a2, __int64 a3, __m128 a4, __m128 a5)
{
  char v5; // r12
  unsigned __int64 v6; // r12
  __int64 v7; // r13
  __int64 v8; // rax

  v5 = sub_427721((__int64)a1);
  if ( a2 != (v5 & 0xE0) )
    sub_427705(*a1);
  v6 = (unsigned int)sub_427927(a1, v5);
  v7 = sub_427793((__int64)a1, v6);
  v8 = sub_40762B(*a1, v6, 0, a4, a5);
  sub_43AAA0(v8, v7, v6);
  return a3;
}

//----- (00000000004279F8) ----------------------------------------------------
__int64 __fastcall sub_4279F8(__int64 **a1, char a2, __m128 a3, __m128 a4)
{
  int i; // er12
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // r14
  unsigned __int64 v9; // r13
  __int64 v10; // rdx
  __int64 v11; // rcx
  int j; // er15
  __int64 *v13; // rdi
  __int64 v14; // rax
  bool v15; // cf
  __int64 v16; // rdx
  __int64 v17; // rcx
  int v18; // [rsp+Ch] [rbp-44h]
  __int64 v19[7]; // [rsp+18h] [rbp-38h] BYREF

  for ( i = 0; ; ++i )
  {
    result = sub_427753((__int64)a1);
    if ( (_DWORD)result )
      break;
    sub_404E3A(*a1, 1, a3, a4);
    sub_427990(a1, a2, v7, a3, a4);
  }
  if ( !i )
    return sub_40762B(*a1, 0LL, 0, a3, a4);
  if ( i != 1 )
  {
    v8 = 0LL;
    v9 = 0LL;
    v18 = sub_404AE7((__int64)*a1);
    while ( 1 )
    {
      for ( j = v18 - i; ; ++j )
      {
        v13 = *a1;
        if ( v18 <= j )
          break;
        v14 = sub_405563(v13, j, v19, a3, a4);
        v10 = v19[0];
        if ( v8 )
        {
          if ( v19[0] )
            sub_43AAA0(v8, v14, v19[0]);
          v8 += v19[0];
        }
        else
        {
          v15 = __CFADD__(v19[0], v9);
          v9 += v19[0];
          if ( v15 )
            sub_427705(*a1);
        }
      }
      if ( v8 )
        break;
      v8 = sub_40762B(v13, v9, 0, a3, a4);
    }
    sub_405057(v13, v18 - i, v10, v11, *(double *)a3.i64, a4);
    return sub_407D1C(*a1, (_DWORD *)(unsigned int)(i - 1), v16, v17, a3, a4);
  }
  return result;
}
// 427A35: variable 'v7' is possibly undefined
// 427AD4: variable 'v10' is possibly undefined
// 427AD4: variable 'v11' is possibly undefined
// 427AE1: variable 'v16' is possibly undefined
// 427AE1: variable 'v17' is possibly undefined
// 4279F8: using guessed type unsigned __int64 var_38[7];

//----- (0000000000427AF5) ----------------------------------------------------
__int64 __fastcall sub_427AF5(__int64 **a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v5; // rdx
  unsigned __int8 v6; // r13
  char v7; // bl
  char v8; // si
  int v9; // edx
  __int64 result; // rax
  __int64 v11; // rax
  unsigned __int64 v12; // r13
  __int64 v13; // rax
  __int64 v14; // rsi
  int v15; // er13
  __int64 v16; // r14
  int v17; // er15
  __int64 v18; // rsi
  int v19; // ebx
  unsigned __int64 *v20; // rdi
  __int64 *v21; // rsi
  __int64 i; // rcx
  char v23; // bl
  char *v24; // rax
  unsigned int v25; // edx
  char *v26; // rsi
  unsigned int v27; // ebx
  int v28; // edx
  int v29; // ecx
  unsigned int v30; // ecx
  int v31; // eax
  unsigned __int64 v32[10]; // [rsp+10h] [rbp-50h] BYREF

  while ( 2 )
  {
    v6 = sub_427721((__int64)a1);
    v7 = v6 & 0x1F;
    switch ( v6 >> 5 )
    {
      case 1:
        v8 = v6;
        v9 = 1;
        return sub_427833(a1, v8, v9, a3, a4);
      case 2:
        if ( v7 == 31 )
          return sub_4279F8(a1, 64, a3, a4);
        a1[2] = (__int64 *)((char *)a1[2] - 1);
        return sub_427990(a1, 64, v5, a3, a4);
      case 3:
        if ( v7 == 31 )
        {
          sub_4279F8(a1, 96, a3, a4);
          v11 = sub_405563(*a1, -1, v32, a3, a4);
          sub_406B69(*a1, v11, v32[0], a3, a4);
          sub_40511F(*a1, -2, a3, a4);
        }
        else
        {
          v12 = (unsigned int)sub_427927(a1, v6);
          v13 = sub_427793((__int64)a1, v12);
          sub_406B69(*a1, v13, v12, a3, a4);
        }
        result = sub_4065BA((__int64)*a1, -1);
        if ( (_DWORD)result )
          return sub_427705(*a1);
        return result;
      case 4:
        v14 = 4LL;
        sub_404E3A(*a1, 4, a3, a4);
        if ( v7 == 31 )
        {
          v15 = -1;
        }
        else
        {
          v14 = v6;
          v15 = sub_427927(a1, v6);
          if ( v15 == -1 )
            return sub_427705(*a1);
        }
        v16 = 0LL;
        for ( result = sub_4070BA(*a1, a3, a4); ; result = 0x100000000LL )
        {
          v17 = v16;
          if ( v15 == -1 )
          {
            result = sub_427753((__int64)a1);
            if ( (_DWORD)result )
              break;
          }
          if ( (_DWORD)v16 == v15 )
          {
            if ( v7 != 31 )
              return result;
            return sub_427705(*a1);
          }
          ++v16;
          sub_427AF5(a1, v14, a3, a4);
          v14 = 4294967294LL;
          sub_403953(*a1, -2, v17, a3, a4);
          if ( v16 == 0x100000000LL )
            return sub_427705(*a1);
        }
        return result;
      case 5:
        v18 = 4LL;
        sub_404E3A(*a1, 4, a3, a4);
        if ( v7 == 31 )
        {
          v19 = -1;
        }
        else
        {
          v18 = v6;
          v19 = sub_427927(a1, v6);
          if ( v19 == -1 )
            return sub_427705(*a1);
        }
        result = sub_407095(*a1, a3, a4);
        while ( 2 )
        {
          if ( v19 != -1 )
          {
            if ( !v19 )
              return result;
            --v19;
LABEL_37:
            sub_427AF5(a1, v18, a3, a4);
            sub_427AF5(a1, v18, a3, a4);
            v18 = 4294967293LL;
            result = sub_40388B(*a1, -3, a3, a4);
            continue;
          }
          break;
        }
        result = sub_427753((__int64)a1);
        if ( !(_DWORD)result )
          goto LABEL_37;
        return result;
      case 6:
        v20 = v32;
        v21 = qword_441B70;
        for ( i = 8LL; i; --i )
        {
          *(_DWORD *)v20 = *(_DWORD *)v21;
          v21 = (__int64 *)((char *)v21 + 4);
          v20 = (unsigned __int64 *)((char *)v20 + 4);
        }
        v23 = *((_BYTE *)v32 + (v6 & 0x1F));
        if ( v23 < 0 )
          sub_427705(*a1);
        a2 = v23;
        sub_427793((__int64)a1, v23);
        continue;
      case 7:
        switch ( v7 )
        {
          case 20:
            return sub_4069DC(*a1, a3, a4, a2, v5);
          case 21:
            return sub_40699D(*a1, a3, a4, a2, v5);
          case 22:
            return sub_40691D(*a1, a2, v5, a3, a4);
          case 23:
            return sub_4068D1(*a1, a2, v5, a3, a4);
          case 25:
            v24 = (char *)sub_427793((__int64)a1, 2uLL);
            v25 = (unsigned __int8)*v24;
            v26 = v24;
            LODWORD(v24) = (unsigned __int8)v24[1];
            v32[0] = 0LL;
            v25 <<= 8;
            v27 = v25 + (_DWORD)v24;
            v28 = (v25 >> 10) & 0x1F;
            if ( v28 )
            {
              v29 = *v26;
              if ( v28 == 31 )
              {
                HIBYTE(v32[0]) = v29 | 0x7F;
                if ( (v27 & 0x3FF) != 0 )
                  BYTE6(v32[0]) = -8;
                else
                  BYTE6(v32[0]) = -16;
              }
              else
              {
                v30 = (v29 << 18) & 0xC0000 | v29 & 0x80000000;
                v31 = ((v28 + 1008) << 20) + v30 + ((unsigned __int8)v26[1] << 10);
                BYTE5(v32[0]) = (unsigned __int16)(v30 + ((unsigned __int8)v26[1] << 10)) >> 8;
                HIBYTE(v32[0]) = HIBYTE(v31);
                BYTE6(v32[0]) = BYTE2(v31);
              }
            }
            else
            {
              if ( (v27 & 0x3FF) != 0 )
              {
                HIBYTE(v32[0]) = 63;
                BYTE6(v32[0]) = ((v27 >> 6) & 0xF) + 16;
                BYTE5(v32[0]) = 4 * v27;
                nullsub_2(v32, v26);
                *(double *)a3.i64 = *(double *)v32 - 0.00006103515625;
                if ( (v27 & 0x8000) != 0 )
                  a3 = _mm_xor_ps(a3, (__m128)xmmword_43D2F0);
                goto LABEL_63;
              }
              HIBYTE(v32[0]) = *v26 & 0x80;
            }
            nullsub_2(v32, v26);
LABEL_62:
            a3.i64[0] = v32[0];
LABEL_63:
            result = sub_406A1B(*a1, a3, a4);
            break;
          case 26:
            LODWORD(v32[0]) = *(_DWORD *)sub_427793((__int64)a1, 4uLL);
            sub_41D67A(v32);
            *(double *)a3.i64 = *(float *)v32;
            goto LABEL_63;
          case 27:
            v32[0] = *(_QWORD *)sub_427793((__int64)a1, 8uLL);
            sub_41D671(v32);
            goto LABEL_62;
          default:
            return sub_427705(*a1);
        }
        return result;
      default:
        v8 = v6;
        v9 = 0;
        return sub_427833(a1, v8, v9, a3, a4);
    }
  }
}
// 427B6E: variable 'v5' is possibly undefined
// 41D666: using guessed type __int64 __fastcall nullsub_2(_QWORD, _QWORD);
// 41D671: using guessed type __int64 __fastcall sub_41D671(_QWORD);
// 41D67A: using guessed type __int64 __fastcall sub_41D67A(_QWORD);
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 441B70: using guessed type __int64 qword_441B70[3];

//----- (0000000000427EEF) ----------------------------------------------------
__int64 __fastcall sub_427EEF(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 *v8[2]; // [rsp+0h] [rbp-30h] BYREF
  __int64 v9; // [rsp+10h] [rbp-20h]
  __int64 v10[3]; // [rsp+18h] [rbp-18h] BYREF

  v4 = sub_40480A(a1, a2);
  v8[0] = a1;
  v8[1] = (__int64 *)sub_405672(a1, v4, v10, a3, a4);
  v9 = 0LL;
  sub_404E3A(a1, 4, a3, a4);
  sub_427AF5(v8, 4LL, a3, a4);
  if ( v9 != v10[0] )
    sub_40807C(a1, 6LL, (__int64)"third_party/duktape/duk_bi_cbor.c", 1596, "trailing garbage");
  return sub_405057(a1, v4, v5, v6, *(double *)a3.i64, a4);
}
// 427F6A: variable 'v5' is possibly undefined
// 427F6A: variable 'v6' is possibly undefined
// 427EEF: using guessed type __int64 var_18[3];

//----- (0000000000427F79) ----------------------------------------------------
__int64 __fastcall sub_427F79(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // r12
  _BYTE *v5; // rax
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rdi
  __int64 v10; // [rsp+0h] [rbp-20h]
  __int64 v11[3]; // [rsp+8h] [rbp-18h] BYREF

  v4 = sub_40578B((__int64 *)*a1, -1, v11, a2, a3);
  if ( (unsigned int)sub_4065BA(*a1, -1) )
  {
    v5 = (_BYTE *)a1[1];
    *v5 = -96;
    a1[1] = (__int64)(v5 + 1);
  }
  else
  {
    if ( v11[0] > 0xFFFFFFFFuLL )
      sub_42766D((__int64 *)*a1);
    v6 = sub_41C942(v4, v11[0]);
    sub_4275F7((__int64)a1, v11[0], v6 == 0 ? 64 : 96);
    sub_427689((__int64)a1, v11[0], v7, a2, a3);
    v8 = a1[1];
    sub_43AAA0(v8, v4, v11[0]);
    a1[1] = v11[0] + v8;
  }
  return v10;
}
// 427FF4: variable 'v7' is possibly undefined
// 428011: variable 'v10' is possibly undefined
// 427F79: using guessed type unsigned __int64 var_18[3];

//----- (0000000000428018) ----------------------------------------------------
__int64 __fastcall sub_428018(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 v4; // rdx
  __int64 v5; // rsi
  __int64 v6; // rdx
  float *v7; // rcx
  _BYTE *v8; // rax
  bool v9; // zf
  int v10; // edx
  char v11; // dl
  __int64 v12; // rax
  float *v13; // rax
  __int16 v14; // ax
  __int64 v15; // rdx
  float v16; // xmm2_4
  __int64 v17; // rax
  __int64 v18; // rax
  float *v19; // rdx
  float *v20; // rax
  __int64 v21; // rax
  _BOOL4 v22; // eax
  __int64 *v23; // rdi
  float *v24; // r12
  int v25; // edx
  __int64 v26; // rax
  _BYTE *v27; // r13
  __int64 v28; // rax
  __int64 *v29; // rdi
  __int64 v30; // r12
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r12
  __int64 v34; // rdx
  __int64 v35; // rdi
  const char *v36; // rax
  __int64 v38; // [rsp+8h] [rbp-48h]
  __int64 v39; // [rsp+8h] [rbp-48h]
  __int64 v40; // [rsp+10h] [rbp-40h] BYREF
  float *v41[7]; // [rsp+18h] [rbp-38h] BYREF

  sub_404E3A(*(__int64 **)a1, 4, a2, a3);
  sub_427689(a1, 9uLL, v4, a2, a3);
  v5 = 0xFFFFFFFFLL;
  switch ( (unsigned int)sub_40609C(*(_QWORD *)a1, -1) )
  {
    case 1u:
      v8 = *(_BYTE **)(a1 + 8);
      *v8 = -9;
      goto LABEL_51;
    case 2u:
      v8 = *(_BYTE **)(a1 + 8);
      *v8 = -10;
      goto LABEL_51;
    case 3u:
      v5 = 0xFFFFFFFFLL;
      v9 = (unsigned int)sub_4053B6(*(_QWORD *)a1, -1) == 0;
      v8 = *(_BYTE **)(a1 + 8);
      LOBYTE(v10) = !v9;
      v6 = (unsigned int)(v10 - 12);
      *v8 = v6;
      goto LABEL_51;
    case 4u:
      v5 = 0xFFFFFFFFLL;
      *(double *)a2.i64 = sub_40541C(*(_QWORD *)a1, -1);
      v38 = a2.i64[0];
      sub_42F94A(*(double *)a2.i64);
      a3.i64[0] = a2.i64[0];
      if ( !sub_41D67C(*(double *)a2.i64, *(double *)a2.i64) )
        goto LABEL_14;
      if ( (_mm_movemask_pd((__m128d)a3) & 1) != 0 )
      {
        if ( *(double *)a2.i64 >= -4294967296.0 )
        {
          *(double *)a2.i64 = -1.0 - *(double *)a2.i64;
          a3 = 0LL;
          if ( -1.0 - *(double *)&v38 < 0.0 )
          {
            v12 = *(_QWORD *)(a1 + 8);
            *(_WORD *)v12 = -32519;
            *(_BYTE *)(v12 + 2) = 0;
            v13 = (float *)(v12 + 3);
            goto LABEL_52;
          }
          v5 = (unsigned int)(int)*(double *)a2.i64;
          v11 = 32;
          goto LABEL_13;
        }
      }
      else
      {
        *(double *)a2.i64 = 4294967295.0;
        if ( *(double *)&v38 <= 4294967295.0 )
        {
          v5 = (unsigned int)(int)*(double *)&v38;
          v11 = 0;
LABEL_13:
          sub_4275F7(a1, v5, v11);
          return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
        }
      }
LABEL_14:
      v40 = v38;
      nullsub_3(&v40);
      a3.i64[0] = v38;
      v5 = HIBYTE(v40) << 8;
      v14 = (unsigned __int16)(2 * HIWORD(v40)) >> 5;
      if ( (unsigned __int16)(v14 - 1009) <= 0x1Du )
      {
        if ( (v40 & 0xFFFFFFFFFFLL) == 0 && (v40 & 0x30000000000LL) == 0 )
        {
          v15 = *(_QWORD *)(a1 + 8);
          v5 = ((unsigned __int16)(v14 - 1008) << 10)
             + (BYTE5(v40) >> 2)
             + ((BYTE6(v40) << 6) & 0x3C0 | (HIBYTE(v40) << 8) & 0x8000u);
          v41[0] = (float *)(v15 + 1);
          *(_BYTE *)v15 = -7;
          sub_42E3D7((_WORD **)v41, v5);
          goto LABEL_26;
        }
LABEL_19:
        v16 = *(double *)&v38;
        a3.i64[0] = v38;
        if ( sub_41D67C(v16, *(double *)&v38) )
        {
          a2 = (__m128)LODWORD(v16);
          v17 = *(_QWORD *)(a1 + 8);
          v41[0] = (float *)(v17 + 1);
          *(_BYTE *)v17 = -6;
          sub_42E404(v41, v16);
          goto LABEL_26;
        }
        goto LABEL_27;
      }
      if ( (unsigned __int16)(v14 - 897) <= 0xFDu )
        goto LABEL_19;
      if ( v14 != 2047 )
      {
LABEL_27:
        v21 = *(_QWORD *)(a1 + 8);
        a2 = a3;
        v41[0] = (float *)(v21 + 1);
        *(_BYTE *)v21 = -5;
        sub_42E41D((double **)v41, *(double *)a3.i64);
        goto LABEL_26;
      }
      v18 = *(_QWORD *)(a1 + 8);
      v41[0] = (float *)(v18 + 1);
      *(_BYTE *)v18 = -7;
      v19 = v41[0];
      v7 = ++v41[0];
      if ( (_mm_movemask_pd((__m128d)a3) & 1) != 0 )
        *(_BYTE *)v19 = -4;
      else
        *(_BYTE *)v19 = 124;
      v20 = v41[0];
      v6 = (__int64)++v41[0];
      *(_BYTE *)v20 = 0;
LABEL_26:
      v13 = v41[0];
LABEL_52:
      *(_QWORD *)(a1 + 8) = v13;
      return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
    case 5u:
      goto LABEL_49;
    case 6u:
      v22 = sub_4065D7(*(_QWORD *)a1, -1);
      v23 = *(__int64 **)a1;
      if ( v22 )
      {
        v41[0] = (float *)sub_405CB0(v23, 0xFFFFFFFF, a2, a3);
        if ( v41[0] > (float *)0xFFFFFFFFLL )
          sub_42766D(*(__int64 **)a1);
        v5 = LODWORD(v41[0]);
        v24 = 0LL;
        sub_4275F7(a1, (unsigned int)v41[0], 128);
        while ( v24 < v41[0] )
        {
          v25 = (int)v24;
          v5 = 0xFFFFFFFFLL;
          v24 = (float *)((char *)v24 + 1);
          sub_40370E(*(__int64 **)a1, -1, v25, a2, a3);
          sub_428018(a1, a2, a3);
        }
        return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
      }
      if ( (unsigned int)sub_406565((__int64)v23, -1) )
      {
        v26 = sub_405672(*(__int64 **)a1, -1, v41, a2, a3);
LABEL_45:
        v33 = v26;
        if ( v41[0] > (float *)0xFFFFFFFFLL )
          sub_42766D(*(__int64 **)a1);
        sub_4275F7(a1, (unsigned int)v41[0], 64);
        sub_427689(a1, (unsigned __int64)v41[0], v34, a2, a3);
        v35 = *(_QWORD *)(a1 + 8);
        v5 = v33;
        sub_43AAA0(v35, v33, (unsigned __int64)v41[0]);
        *(_QWORD *)(a1 + 8) = (char *)v41[0] + v35;
        return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
      }
      v27 = *(_BYTE **)(a1 + 8);
      v28 = *(_QWORD *)(a1 + 16);
      *v27 = -65;
      v39 = v28;
      v29 = *(__int64 **)a1;
      *(_QWORD *)(a1 + 8) = v27 + 1;
      sub_403FF2(v29, -1, 0x10u, a2, a3);
LABEL_37:
      v30 = 0LL;
      while ( 1 )
      {
        v5 = 0xFFFFFFFFLL;
        if ( !(unsigned int)sub_404025(*(__int64 **)a1, -1, 1, a2, a3) )
          break;
        ++v30;
        sub_40500F(*(__int64 **)a1, -2);
        sub_428018(a1, a2, a3);
        sub_428018(a1, a2, a3);
        if ( v30 == 0x100000000LL )
        {
          sub_42766D(*(__int64 **)a1);
          goto LABEL_37;
        }
      }
      sub_407D7E(*(__int64 **)a1, 0xFFFFFFFFLL, v31, v32, a2, a3);
      if ( (unsigned int)v30 <= 0x17 )
      {
        v27[*(_QWORD *)(a1 + 16) - v39] = v30 - 96;
        return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
      }
      v5 = 1LL;
      sub_427689(a1, 1uLL, v6, a2, a3);
      v8 = *(_BYTE **)(a1 + 8);
      *v8 = -1;
LABEL_51:
      v13 = (float *)(v8 + 1);
      goto LABEL_52;
    case 7u:
      v26 = sub_405563(*(__int64 **)a1, -1, v41, a2, a3);
      goto LABEL_45;
    case 8u:
      v36 = (const char *)sub_408725(*(__int64 **)a1, -1, a2, a3);
      sub_407AA3(*(__int64 **)a1, "(%s)", v36);
      v5 = 4294967294LL;
      sub_40511F(*(__int64 **)a1, -2, a2, a3);
LABEL_49:
      sub_427F79((__int64 *)a1, a2, a3);
      return sub_407D7E(*(__int64 **)a1, v5, v6, (__int64)v7, a2, a3);
    case 9u:
      v8 = *(_BYTE **)(a1 + 8);
      *v8 = -96;
      goto LABEL_51;
    default:
      return sub_42766D(*(__int64 **)a1);
  }
}
// 428041: variable 'v4' is possibly undefined
// 42808F: variable 'v10' is possibly undefined
// 428388: variable 'v31' is possibly undefined
// 428388: variable 'v32' is possibly undefined
// 4283B0: variable 'v6' is possibly undefined
// 4283FD: variable 'v34' is possibly undefined
// 42846D: variable 'v7' is possibly undefined
// 41D665: using guessed type __int64 __fastcall nullsub_3(_QWORD);

//----- (0000000000428481) ----------------------------------------------------
__int64 __fastcall sub_428481(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 *v8; // [rsp+0h] [rbp-40h] BYREF
  __int64 v9; // [rsp+8h] [rbp-38h]
  __int64 v10; // [rsp+10h] [rbp-30h]
  __int64 v11; // [rsp+18h] [rbp-28h]
  __int64 v12; // [rsp+20h] [rbp-20h]
  int v13; // [rsp+28h] [rbp-18h]

  v4 = sub_40480A(a1, a2);
  v8 = a1;
  v13 = sub_404AE7((__int64)a1);
  v12 = 64LL;
  v9 = sub_40762B(a1, 0x40uLL, 1, a3, a4);
  v10 = v9;
  v11 = v9 + 64;
  sub_404F0A(a1, v4, a3, a4);
  sub_428018((__int64)&v8, a3, a4);
  sub_41D79F(v8, v13, v9 - v10, a3, a4);
  return sub_405057(a1, v4, v5, v6, *(double *)a3.i64, a4);
}
// 4284FF: variable 'v5' is possibly undefined
// 4284FF: variable 'v6' is possibly undefined

//----- (0000000000428518) ----------------------------------------------------
__int64 __fastcall sub_428518(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_428481(a1, -1, a2, a3);
  sub_40377C(a1, -1, 0x56u, a2, a3);
  return 1LL;
}

//----- (0000000000428544) ----------------------------------------------------
__int64 __fastcall sub_428544(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_427EEF(a1, -1, a2, a3);
  return 1LL;
}

//----- (0000000000428557) ----------------------------------------------------
__int64 __fastcall sub_428557(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_42EB6E(a1, a2, a3);
  return 1LL;
}

//----- (000000000042856A) ----------------------------------------------------
__int64 __fastcall sub_42856A(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // rcx

  v3 = sub_405DB7(a1, 0, a2, a3);
  sub_42ED6F(a1, v3, a2, a3, v4, v5);
  return 1LL;
}
// 428583: variable 'v4' is possibly undefined
// 428583: variable 'v5' is possibly undefined

//----- (000000000042858F) ----------------------------------------------------
__int64 __fastcall sub_42858F(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // eax
  __int64 v4; // rsi
  __int64 v5; // rdx

  v3 = sub_40548C(a1, 0, a2, a3);
  v4 = v3;
  sub_40C6B4(a1[8], v3, a2, a3);
  sub_40699D(a1, a2, a3, v4, v5);
  return 1LL;
}
// 4285AF: variable 'v5' is possibly undefined

//----- (00000000004285BE) ----------------------------------------------------
__int64 __fastcall sub_4285BE(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40582D(a1, 0, a2, a3);
  if ( (int)sub_404AE7((__int64)a1) <= 1 )
  {
    sub_404524(a1, 0, a2, a3);
    return 1LL;
  }
  else
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_40452E(a1, 0, a2, a3);
    return 0LL;
  }
}

//----- (000000000042860A) ----------------------------------------------------
__int64 __fastcall sub_42860A(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // rax
  int v5; // er8

  v3 = sub_40574F(a1, 0, a2, a3);
  sub_404AC6(a1, 1);
  v4 = (_QWORD *)a1[71];
  if ( v4[112] == v3 )
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_42E8D0(a1, 1, a2, a3);
    return 1LL;
  }
  if ( v4[113] == v3 )
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_42E507(a1, 1, a2, a3);
    return 1LL;
  }
  v5 = 7;
  if ( v4[114] == v3 )
  {
LABEL_8:
    sub_42A276(a1, 1, 2, 3, v5, a2, a3);
    return 1LL;
  }
  if ( v4[115] == v3 )
  {
    v5 = 9;
    goto LABEL_8;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_duktape.c", 104, a2, a3);
  return 0LL;
}

//----- (00000000004286D5) ----------------------------------------------------
__int64 __fastcall sub_4286D5(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // rax

  v3 = sub_40574F(a1, 0, a2, a3);
  sub_404AC6(a1, 1);
  v4 = (_QWORD *)a1[71];
  if ( v4[112] == v3 )
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_42E9AD(a1, 1, a2, a3);
    return 1LL;
  }
  if ( v4[113] == v3 )
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_42E6E3(a1, 1, a2, a3);
    return 1LL;
  }
  if ( v4[114] == v3 || v4[115] == v3 )
  {
    sub_42A197(a1, a2, a3, 1LL, 2);
    return 1LL;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_duktape.c", 143, a2, a3);
  return 0LL;
}

//----- (0000000000428799) ----------------------------------------------------
__int64 __fastcall sub_428799(_QWORD *a1, __m128 a2, __m128 a3)
{
  sub_403FC8(a1, 0, a2, a3);
  return 1LL;
}

//----- (00000000004287AB) ----------------------------------------------------
__int64 __fastcall sub_4287AB(__int64 *a1, unsigned int a2, __m128 a3, __m128 a4, __m128 a5)
{
  int v7; // er14
  int i; // er15
  double v9; // xmm0_8
  char v10; // bl
  int v11; // eax
  __int64 v12; // rdx
  __int64 v13; // rcx
  _DWORD *v14; // rax
  const char *v15; // rdx
  char *v16; // rcx
  _DWORD *v17; // rax
  char *v18; // rdi
  char *v19; // rsi
  __int64 v20; // rdx
  __int64 v21; // rcx
  char *v22; // r8
  char *v23; // r10
  char *v24; // rdi
  char *v25; // rsi
  char *v26; // r9
  char *v27; // r9
  char *v28; // r8
  char *v29; // rdi
  char *v30; // rsi
  char *v31; // r9
  __int64 v32; // rdx
  __int64 v33; // rcx
  const char *v34; // rdx
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // rdx
  __int64 v38; // rcx
  int v39; // eax
  char *v41; // [rsp-8h] [rbp-58h]
  char *v42; // [rsp+8h] [rbp-48h]
  double v43; // [rsp+10h] [rbp-40h]
  const char *v44; // [rsp+10h] [rbp-40h]
  int v45; // [rsp+18h] [rbp-38h]
  signed int v46; // [rsp+1Ch] [rbp-34h]
  unsigned int v47; // [rsp+1Ch] [rbp-34h]

  sub_406FB2(a1, a3, a4);
  sub_403883(a1, -65444, a3, a4);
  v7 = sub_404C73((__int64)a1);
  sub_407826(a1, 0x40u, a3, a4);
  sub_406FB2(a1, a3, a4);
  if ( !sub_4060E2((__int64)a1, v7) )
    goto LABEL_56;
  v45 = 0;
  for ( i = 0; ; i += 2 )
  {
    sub_404E3A(a1, 5, a3, a4);
    sub_40370E(a1, v7, i, a3, a4);
    sub_40370E(a1, v7, i + 1, a3, a4);
    v43 = sub_405CAB(a1, a3, a4);
    a4 = (__m128)0x41F0000000000000uLL;
    v9 = sub_42F9DE(v43, 4294967296.0);
    v46 = sub_41D2A1(v9);
    *(double *)a5.i64 = v43 * 2.328306436538696e-10;
    a3 = a5;
    sub_42F94A(v43 * 2.328306436538696e-10);
    v10 = sub_41D2CA(v43 * 2.328306436538696e-10);
    v11 = sub_40609C((__int64)a1, -2);
    if ( v11 == 6 || v11 == 9 )
    {
      ++v45;
      sub_4037B9(a1, -130979, a5, (__m128)0x41F0000000000000uLL);
      sub_4037B9(a1, -196514, a5, (__m128)0x41F0000000000000uLL);
      v47 = sub_4202D0(a1, -4, v46, a5, (__m128)0x41F0000000000000uLL);
      if ( sub_406529((__int64)a1, -1) )
      {
        if ( !a2 )
          return 1;
        if ( a2 == 1 )
        {
          sub_406AAF(a1, v47, a5, (__m128)0x41F0000000000000uLL);
          return a2;
        }
      }
      v14 = sub_405717((__int64)a1, -2);
      v15 = "[anon]";
      if ( v14 && *(_DWORD **)(a1[71] + 120) != v14 )
        v15 = (const char *)(v14 + 8);
      v44 = v15;
      v16 = (char *)sub_40573B((__int64)a1, -1);
      if ( !v16 )
        v16 = &byte_43DB77;
      v42 = v16;
      v17 = (_DWORD *)sub_405823((__int64)a1, -4);
      if ( v17 )
      {
        if ( (*v17 & 0x1000) != 0 )
        {
          v22 = &byte_43DB77;
          v23 = " preventsyield";
          if ( (v10 & 8) == 0 )
            v23 = &byte_43DB77;
          v24 = " directeval";
          if ( (v10 & 0x10) == 0 )
            v24 = &byte_43DB77;
          v25 = " construct";
          if ( (v10 & 4) == 0 )
            v25 = &byte_43DB77;
          v26 = " tailcall";
          if ( (v10 & 2) == 0 )
            v26 = &byte_43DB77;
          if ( (v10 & 1) != 0 )
            v22 = "use strict" + 3;
          sub_407AA3(a1, "at %s (%s) native%s%s%s%s%s", v44, v42, v22, v26, v25, v24, v23);
        }
        else
        {
          v27 = " preventsyield";
          if ( (v10 & 8) == 0 )
            v27 = &byte_43DB77;
          v28 = " directeval";
          v41 = v27;
          if ( (v10 & 0x10) == 0 )
            v28 = &byte_43DB77;
          v29 = " construct";
          v30 = " tailcall";
          v31 = "use strict" + 3;
          if ( (v10 & 4) == 0 )
            v29 = &byte_43DB77;
          if ( (v10 & 2) == 0 )
            v30 = &byte_43DB77;
          if ( (v10 & 1) == 0 )
            v31 = &byte_43DB77;
          sub_407AA3(a1, "at %s (%s:%lu)%s%s%s%s%s", v44, v42, v47, v31, v30, v29, v28, v41);
        }
      }
      else
      {
        v18 = " preventsyield";
        if ( (v10 & 8) == 0 )
          v18 = &byte_43DB77;
        v19 = " directeval";
        if ( (v10 & 0x10) == 0 )
          v19 = &byte_43DB77;
        sub_407AA3(a1, "at %s light%s%s%s%s%s", v44);
        v20 = (__int64)v19;
        v21 = (__int64)v18;
      }
      sub_405057(a1, -5, v20, v21, *(double *)a5.i64, (__m128)0x41F0000000000000uLL);
      sub_407DF2(a1, a5, (__m128)0x41F0000000000000uLL, 4294967291LL, v32, v33);
      continue;
    }
    if ( v11 != 5 )
      break;
    if ( (v10 & 1) == 0 )
    {
      if ( !a2 )
      {
        sub_407D7E(a1, 4294967294LL, v12, v13, a5, (__m128)0x41F0000000000000uLL);
        return 1;
      }
      if ( a2 == 1 )
      {
        sub_406A68(a1, v46, a5, (__m128)0x41F0000000000000uLL);
        return a2;
      }
    }
    v34 = (const char *)sub_4056B9((__int64)a1, -2);
    if ( !v34 )
      v34 = "null";
    sub_407AA3(a1, "at [anon] (%s:%ld) internal", v34, v46);
    sub_405057(a1, -3, v35, v36, *(double *)a5.i64, (__m128)0x41F0000000000000uLL);
    sub_407D7E(a1, 4294967293LL, v37, v38, a5, (__m128)0x41F0000000000000uLL);
  }
  sub_407DC0(a1, 4294967294LL, v12, v13, a5, (__m128)0x41F0000000000000uLL);
  if ( v45 > 9 )
    sub_407826(a1, 0x41u, a5, (__m128)0x41F0000000000000uLL);
LABEL_56:
  if ( a2 == -1 )
  {
    v39 = sub_404AE7((__int64)a1);
    sub_408F0F(a1, v39 - (v7 + 2), a3, a4);
    return 1;
  }
  else
  {
    return 0;
  }
}
// 428A84: variable 'v20' is possibly undefined
// 428A84: variable 'v21' is possibly undefined
// 428A8C: variable 'v32' is possibly undefined
// 428A8C: variable 'v33' is possibly undefined
// 428AA8: variable 'v12' is possibly undefined
// 428AA8: variable 'v13' is possibly undefined
// 428AFD: variable 'v35' is possibly undefined
// 428AFD: variable 'v36' is possibly undefined
// 428B05: variable 'v37' is possibly undefined
// 428B05: variable 'v38' is possibly undefined
// 43DB77: using guessed type char byte_43DB77;

//----- (0000000000428BB1) ----------------------------------------------------
__int64 __fastcall sub_428BB1(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  v3 = sub_41DCD3((__int64)a1);
  sub_407003(a1, 939540608, v3, a2, a3);
  if ( !sub_40649F((__int64)a1, 0) )
  {
    sub_408725(a1, 0, a2, a3);
    sub_404FD6(a1, a2, a3);
    sub_403E13(a1, -33541115, a2, a3);
  }
  if ( !(unsigned int)sub_41DC85((__int64)a1) )
    sub_40B6EA(a1, (__int64)a1, 0LL, 0, 1, a2, a3);
  return 1LL;
}

//----- (0000000000428C27) ----------------------------------------------------
__int64 __fastcall sub_428C27(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx

  sub_406FB2(a1, a2, a3);
  sub_408496(a1, -1, 640LL, v3, v4, a2, a3);
  sub_4037B9(a1, -65443, a2, a3);
  if ( sub_40649F((__int64)a1, -1) )
  {
    sub_407D7E(a1, 0xFFFFFFFFLL, v5, v6, a2, a3);
    sub_406EC3(a1, (__int64)"Error", 5uLL, a2, a3);
  }
  else
  {
    sub_408725(a1, -1, a2, a3);
  }
  sub_4037B9(a1, -131020, a2, a3);
  if ( sub_40649F((__int64)a1, -1) )
  {
    sub_407D7E(a1, 0xFFFFFFFFLL, v7, v8, a2, a3);
    sub_407963(a1, a2, a3);
  }
  else
  {
    sub_408725(a1, -1, a2, a3);
  }
  if ( sub_405CB0(a1, 0xFFFFFFFE, a2, a3) )
  {
    if ( sub_405CB0(a1, 0xFFFFFFFF, a2, a3) )
    {
      sub_406EC3(a1, 4483429LL, 2uLL, a2, a3);
      sub_40500F(a1, -2);
      sub_408E52(a1, 3, a2, a3);
    }
    else
    {
      sub_407D7E(a1, 0xFFFFFFFFLL, v9, v10, a2, a3);
    }
  }
  return 1LL;
}
// 428C41: variable 'v3' is possibly undefined
// 428C41: variable 'v4' is possibly undefined
// 428C65: variable 'v5' is possibly undefined
// 428C65: variable 'v6' is possibly undefined
// 428CA8: variable 'v7' is possibly undefined
// 428CA8: variable 'v8' is possibly undefined
// 428CE7: variable 'v9' is possibly undefined
// 428CE7: variable 'v10' is possibly undefined

//----- (0000000000428D24) ----------------------------------------------------
__int64 __fastcall sub_428D24(__int64 *a1, __m128 a2, __m128 a3, __m128 a4)
{
  return sub_4287AB(a1, 0xFFFFFFFF, a2, a3, a4);
}

//----- (0000000000428D5B) ----------------------------------------------------
_BYTE *__fastcall sub_428D5B(__int64 a1, unsigned __int64 a2, _BYTE *a3)
{
  unsigned __int64 v3; // r9
  int v4; // esi
  __int64 v5; // r8
  _BYTE *v7; // rax
  unsigned __int64 v8; // rdx
  unsigned __int64 i; // rcx
  __int64 v10; // r10
  unsigned __int64 v11; // rdx
  _BYTE *v12; // rsi
  unsigned __int8 v13; // di
  unsigned __int8 v14; // r10
  char v15; // di
  __int64 v16; // rdx

  v3 = a2;
  v4 = (unsigned __int8)a3 & 1;
  v5 = a1;
  v7 = &a3[-(v4 == 0) + 1];
  v8 = (unsigned int)v3 & 0xFFFFFFFC;
  for ( i = 0LL; i < v8; i += 4LL )
  {
    v7 += 8;
    *((_WORD *)v7 - 4) = word_43EEC0[*(unsigned __int8 *)(v5 + i)];
    *((_WORD *)v7 - 3) = word_43EEC0[*(unsigned __int8 *)(v5 + i + 1)];
    *((_WORD *)v7 - 2) = word_43EEC0[*(unsigned __int8 *)(v5 + i + 2)];
    v10 = *(unsigned __int8 *)(v5 + i + 3);
    *((_WORD *)v7 - 1) = word_43EEC0[v10];
  }
  if ( v4 )
    sub_43ABC2(a3, a3 + 1, 2 * v8);
  v11 = i;
  v12 = v7;
  while ( v11 < v3 )
  {
    v13 = *(_BYTE *)(v5 + v11);
    v12 += 2;
    ++v11;
    v14 = v13;
    v15 = byte_43F2E0[v13 & 0xF];
    *(v12 - 2) = byte_43F2E0[v14 >> 4];
    *(v12 - 1) = v15;
  }
  v16 = 2 * (v3 - i);
  if ( i > v3 )
    v16 = 0LL;
  return &v7[v16];
}
// 428DEC: variable 'i' is possibly undefined
// 428DEF: variable 'v7' is possibly undefined
// 428DF5: variable 'v3' is possibly undefined
// 428DF7: variable 'v5' is possibly undefined
// 43EEC0: using guessed type __int16 word_43EEC0[];

//----- (0000000000428E41) ----------------------------------------------------
_BYTE *__fastcall sub_428E41(__int64 *a1, char a2, __m128 a3, __m128 a4)
{
  _BYTE *result; // rax

  if ( a1[3] == a1[1] )
    sub_41CFE2((__int64 *)*a1, a1 + 1, 1LL, a3, a4);
  result = (_BYTE *)a1[1];
  a1[1] = (__int64)(result + 1);
  *result = a2;
  return result;
}

//----- (0000000000428E7D) ----------------------------------------------------
__int64 __fastcall sub_428E7D(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  unsigned __int64 v7; // rdx
  _BYTE *v9; // rdi
  _BYTE *v10; // rax
  _BYTE *v11; // rdx
  _BYTE *v12; // rax

  v7 = 2 * a3 + 11;
  v9 = *(_BYTE **)(a1 + 8);
  if ( *(_QWORD *)(a1 + 24) - (_QWORD)v9 < v7 )
    v9 = (_BYTE *)sub_41CFE2(*(__int64 **)a1, (_QWORD *)(a1 + 8), v7, a5, a6);
  if ( *(_DWORD *)(a1 + 76) )
  {
    *v9 = 124;
    v10 = sub_428D5B(a2, a3, v9 + 1);
    v11 = v10 + 1;
    *v10 = 124;
  }
  else
  {
    sub_43AAA0((__int64)v9, (__int64)"{\"_buf\":\"", 9uLL);
    v12 = sub_428D5B(a2, a3, v9 + 9);
    v11 = v12 + 2;
    *(_WORD *)v12 = 32034;
  }
  *(_QWORD *)(a1 + 8) = v11;
  return a4;
}

//----- (0000000000428F0A) ----------------------------------------------------
__int64 __fastcall sub_428F0A(__int64 *a1, unsigned int a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v6; // r15
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rdi
  unsigned __int64 v12; // rbx

  sub_428E41(a1, 10, a4, a5);
  if ( a2 )
  {
    v6 = a1[6];
    v7 = a1[1];
    v8 = *(unsigned int *)(v6 + 24);
    v9 = v8 * a2;
    if ( a1[3] - v7 < v9 )
      v7 = sub_41CFE2((__int64 *)*a1, a1 + 1, v9, a4, a5);
    sub_43AAA0(v7, v6 + 32, v8);
    v11 = v10 + v8;
    v12 = v9 - v8;
    while ( v12 >= v8 )
    {
      v12 -= v8;
      sub_43AAA0(v11, v10, v8);
      v11 += v8;
      v8 *= 2LL;
    }
    sub_43AAA0(v11, v10, v12);
    a1[1] = v12 + v11;
  }
  return a3;
}
// 428F6D: variable 'v10' is possibly undefined

//----- (0000000000428FAA) ----------------------------------------------------
__int64 __fastcall sub_428FAA(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  unsigned __int64 v5; // r12

  v5 = *(unsigned int *)(a2 + 24);
  if ( v5 > a1[3] - a1[1] )
    sub_41CFE2((__int64 *)*a1, a1 + 1, v5, a4, a5);
  if ( v5 )
    sub_43AAA0(a1[1], a2 + 32, v5);
  a1[1] += v5;
  return a3;
}

//----- (0000000000428FFB) ----------------------------------------------------
__int64 __fastcall sub_428FFB(__int64 *a1, unsigned int a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 *v6; // rdi
  __int64 v7; // r13
  unsigned __int64 v8; // r12

  v6 = (__int64 *)*a1;
  v7 = *(_QWORD *)(v6[71] + 8LL * a2);
  v8 = *(unsigned int *)(v7 + 24);
  if ( v8 > a1[3] - a1[1] )
    sub_41CFE2(v6, a1 + 1, *(unsigned int *)(v7 + 24), a4, a5);
  if ( v8 )
    sub_43AAA0(a1[1], v7 + 32, v8);
  a1[1] += v8;
  return a3;
}

//----- (0000000000429056) ----------------------------------------------------
__int64 __fastcall sub_429056(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 *v3; // r12
  int v4; // eax
  __int64 result; // rax

  v3 = *(__int64 **)a1;
  sub_404E3A(*(__int64 **)a1, 32, a2, a3);
  v4 = *(_DWORD *)(a1 + 52);
  if ( v4 >= *(_DWORD *)(a1 + 56) )
    return sub_401CE2(v3, (__int64)"third_party/duktape/duk_bi_json.c", 723, "json decode recursion limit", a2, a3);
  result = (unsigned int)(v4 + 1);
  *(_DWORD *)(a1 + 52) = result;
  return result;
}

//----- (000000000042909D) ----------------------------------------------------
__int64 __fastcall sub_42909D(__int64 a1)
{
  return sub_401B75(
           *(__int64 **)a1,
           (__int64)"third_party/duktape/duk_bi_json.c",
           0x50000D7u,
           "invalid json (at offset %ld)",
           *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16));
}

//----- (00000000004290BE) ----------------------------------------------------
char *__fastcall sub_4290BE(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  char *result; // rax
  int v5; // ecx
  unsigned __int8 *v6; // rdx
  int v7; // edx

  LODWORD(result) = 0;
  v5 = 0;
  while ( 1 )
  {
    v6 = *(unsigned __int8 **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v6 + 1;
    v7 = byte_44E328[*v6];
    if ( (v7 & 0x80u) != 0 )
      break;
    ++v5;
    result = (char *)(unsigned int)(v7 + 16 * (_DWORD)result);
    if ( a2 == v5 )
      return result;
  }
  sub_42909D(a1);
  return sub_4290F1(a1, a3, a4);
}

//----- (00000000004290F1) ----------------------------------------------------
char *__fastcall sub_4290F1(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 *v4; // r12
  _BYTE *v5; // rax
  __int64 *v6; // rdi
  _BYTE *v7; // rax
  _BYTE *v8; // rsi
  _BYTE *v9; // rcx
  __int64 v10; // rdi
  _BYTE *v11; // rcx
  __int64 *v12; // rdi
  bool v14; // zf
  unsigned int v15; // eax
  int v16; // esi
  _BYTE *i; // [rsp+8h] [rbp-38h] BYREF
  __int64 v18[6]; // [rsp+10h] [rbp-30h] BYREF

  v4 = *(__int64 **)a1;
  sub_41CF97(*(__int64 **)a1, v18, 0x80uLL, a2, a3);
  for ( i = (_BYTE *)v18[0]; ; sub_42E436(&i, v15) )
  {
LABEL_2:
    v5 = i;
    if ( v18[2] - (__int64)i <= 0x46uLL )
    {
      v6 = *(__int64 **)a1;
      v18[0] = (__int64)i;
      v5 = (_BYTE *)sub_41CFE2(v6, v18, 71LL, a2, a3);
    }
    i = v5;
    v7 = *(_BYTE **)(a1 + 8);
    v8 = v7 + 64;
    while ( 1 )
    {
      v9 = v7;
      v10 = (unsigned __int8)*v7++;
      if ( !byte_4420A0[v10] )
        break;
      v11 = i++;
      *v11 = v10;
      if ( v8 == v7 )
      {
        *(_QWORD *)(a1 + 8) = v8;
        goto LABEL_2;
      }
    }
    if ( (_BYTE)v10 == 34 )
    {
      v12 = *(__int64 **)a1;
      *(_QWORD *)(a1 + 8) = v7;
      v18[0] = (__int64)i;
      sub_41D054(v12, v18, a2, a3);
      return (char *)sub_406BF4(v4, -1, a2, a3);
    }
    if ( (_BYTE)v10 != 92 )
      break;
    *(_QWORD *)(a1 + 8) = v9 + 2;
    LOBYTE(v8) = *v7;
    if ( *v7 > 0x78u )
      goto LABEL_38;
    if ( (unsigned __int8)v8 > 0x6Du )
    {
      LODWORD(v8) = (unsigned __int8)((_BYTE)v8 - 110);
      switch ( (char)v8 )
      {
        case 0:
          v15 = 10;
          continue;
        case 4:
          v15 = 13;
          continue;
        case 6:
          v15 = 9;
          continue;
        case 7:
          v16 = 4;
          break;
        case 10:
          if ( !*(_DWORD *)(a1 + 40) )
            goto LABEL_38;
          v16 = 2;
          break;
        default:
          goto LABEL_38;
      }
LABEL_33:
      v15 = (unsigned int)sub_4290BE(a1, v16, a2, a3);
      continue;
    }
    if ( (_BYTE)v8 == 98 )
    {
      v15 = 8;
    }
    else if ( (unsigned __int8)v8 > 0x62u )
    {
      if ( (_BYTE)v8 != 102 )
        goto LABEL_38;
      v15 = 12;
    }
    else
    {
      if ( (_BYTE)v8 == 85 )
      {
        if ( !*(_DWORD *)(a1 + 40) )
          goto LABEL_38;
        v16 = 8;
        goto LABEL_33;
      }
      if ( (unsigned __int8)v8 > 0x55u )
      {
        v14 = (_BYTE)v8 == 92;
      }
      else
      {
        if ( (_BYTE)v8 == 34 )
          goto LABEL_26;
        v14 = (_BYTE)v8 == 47;
      }
      if ( !v14 )
        goto LABEL_38;
LABEL_26:
      v15 = (unsigned __int8)v8;
    }
  }
  *(_QWORD *)(a1 + 8) = v7;
LABEL_38:
  sub_42909D(a1);
  return sub_429282((_QWORD *)a1, (unsigned int)v8);
}

//----- (0000000000429282) ----------------------------------------------------
char *__fastcall sub_429282(_QWORD *a1, unsigned int a2)
{
  _QWORD *v2; // rbp
  char *result; // rax
  char v4; // cl
  _BYTE *v5; // rdx
  _QWORD *v6; // [rsp-8h] [rbp-8h] BYREF

  for ( result = (char *)(*(_QWORD *)(*(_QWORD *)(*a1 + 568LL) + 8LL * a2) + 33LL); ; ++result )
  {
    v4 = *result;
    if ( !*result )
      break;
    v5 = (_BYTE *)a1[1];
    a1[1] = v5 + 1;
    if ( v4 != *v5 )
    {
      v6 = v2;
      v2 = &v6;
      result = (char *)sub_42909D((__int64)a1);
    }
  }
  return result;
}
// 4292AC: variable 'v2' is possibly undefined

//----- (00000000004292BB) ----------------------------------------------------
__int64 __fastcall sub_4292BB(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 *v3; // r12
  __int64 v4; // rax
  int v5; // er13
  int v6; // er14
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx

  v3 = *(__int64 **)a1;
  sub_404F67(*(__int64 **)a1, a2, a3);
  sub_403616(v3, -3, a2, a3);
  v4 = sub_405823((__int64)v3, -1);
  if ( v4 )
  {
    if ( sub_417FC2(v4) )
    {
      v5 = 0;
      v6 = sub_405CB0(v3, 0xFFFFFFFF, a2, a3);
      while ( v5 != v6 )
      {
        sub_404F67(v3, a2, a3);
        sub_4089F6(v3, v5, a2, a3);
        sub_4292BB(a1, a2, a3);
        if ( sub_40649F((__int64)v3, -1) )
        {
          sub_407D7E(v3, 0xFFFFFFFFLL, v7, v8, a2, a3);
          sub_403B1D(v3, -1, v5, a2, a3);
        }
        else
        {
          sub_403953(v3, -2, v5, a2, a3);
        }
        ++v5;
      }
    }
    else
    {
      sub_403FF2(v3, -1, 0x10u, a2, a3);
      while ( (unsigned int)sub_404025(v3, -1, 0, a2, a3) )
      {
        sub_404FFB(v3, a2, a3);
        sub_404FF1(v3, a2, a3);
        sub_4292BB(a1, a2, a3);
        if ( sub_40649F((__int64)v3, -1) )
        {
          sub_407D7E(v3, 0xFFFFFFFFLL, v11, v12, a2, a3);
          sub_403A0F(v3, -3, a2, a3);
        }
        else
        {
          sub_40388B(v3, -4, a2, a3);
        }
      }
      sub_407D7E(v3, 0xFFFFFFFFLL, v9, v10, a2, a3);
    }
  }
  sub_404F0A(v3, *(_DWORD *)(a1 + 32), a2, a3);
  sub_40500F(v3, -4);
  return sub_41DA64(v3, 2, a2, a3);
}
// 429348: variable 'v7' is possibly undefined
// 429348: variable 'v8' is possibly undefined
// 4293BD: variable 'v11' is possibly undefined
// 4293BD: variable 'v12' is possibly undefined
// 4293E0: variable 'v9' is possibly undefined
// 4293E0: variable 'v10' is possibly undefined

//----- (0000000000429412) ----------------------------------------------------
__int64 __fastcall sub_429412(__int64 a1, unsigned int *a2, __m128 a3, __m128 a4)
{
  __int64 *v4; // r12
  const void *v5; // rax

  --*(_DWORD *)(a1 + 88);
  v4 = *(__int64 **)a1;
  v5 = (const void *)sub_405B41(*(_QWORD *)a1, *a2 - 1);
  if ( *(_DWORD *)(a1 + 88) > 0x3Fu )
  {
    sub_407AA3(v4, "%p", v5);
    sub_403A0F(v4, *(_DWORD *)(a1 + 60), a3, a4);
  }
  return sub_404B20(v4, *a2, a3, a4);
}

//----- (000000000042946B) ----------------------------------------------------
__int64 __fastcall sub_42946B(__int64 a1, _DWORD *a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r10
  __int64 *v5; // r12
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned int v8; // esi
  const void *v9; // rdx
  __int64 v10; // rax
  unsigned int v11; // edx
  __int64 v12; // rsi
  __int64 v13; // rdx
  unsigned int v15; // eax
  __int64 v16; // [rsp-8h] [rbp-20h]

  v16 = v4;
  v5 = *(__int64 **)a1;
  *a2 = sub_404AE7(*(_QWORD *)a1);
  sub_404E3A(v5, 32, a3, a4);
  v6 = sub_405B41((__int64)v5, -1);
  v7 = *(unsigned int *)(a1 + 88);
  v8 = 64;
  v9 = (const void *)v6;
  if ( (unsigned int)v7 <= 0x40 )
    v8 = *(_DWORD *)(a1 + 88);
  v10 = 0LL;
  while ( v8 > (unsigned int)v10 )
  {
    ++v10;
    if ( *(const void **)(a1 + 8 * v10 + 112) == v9 )
    {
      v11 = 100665053;
      return sub_401C42(v5, (__int64)"third_party/duktape/duk_bi_json.c", v11, "cyclic input", a3, a4);
    }
  }
  if ( (unsigned int)v7 > 0x3F )
  {
    sub_407AA3(v5, "%p", v9);
    sub_404F67(v5, a3, a4);
    v12 = *(unsigned int *)(a1 + 60);
    if ( (unsigned int)sub_403BC8(v5, v12, a3, a4) )
    {
      v11 = 100665063;
      return sub_401C42(v5, (__int64)"third_party/duktape/duk_bi_json.c", v11, "cyclic input", a3, a4);
    }
    sub_40699D(v5, a3, a4, v12, v13);
    sub_40388B(v5, *(_DWORD *)(a1 + 60), a3, a4);
  }
  else
  {
    *(_QWORD *)(a1 + 8 * v7 + 120) = v9;
  }
  v15 = *(_DWORD *)(a1 + 88);
  if ( v15 >= *(_DWORD *)(a1 + 92) )
    return sub_401CE2(v5, (__int64)"third_party/duktape/duk_bi_json.c", 1779, "json encode recursion limit", a3, a4);
  *(_DWORD *)(a1 + 88) = v15 + 1;
  return v16;
}
// 42947A: variable 'v4' is possibly undefined
// 429524: variable 'v13' is possibly undefined

//----- (0000000000429568) ----------------------------------------------------
__int64 __fastcall sub_429568(_DWORD *a1, unsigned int a2, _WORD *a3)
{
  unsigned int v3; // eax
  __int16 v4; // cx
  _WORD *v5; // r8
  unsigned int v6; // eax
  char v7; // t0
  _WORD *v8; // rdi
  unsigned int v9; // edx

  if ( a2 > 0xFF )
  {
    v3 = 285813;
    if ( a2 > 0xFFFF )
      v3 = *a1 == 0 ? 546091 : 547925;
  }
  else
  {
    v3 = *a1 == 0 ? 285813 : 154744;
  }
  v4 = v3;
  v5 = a3 + 1;
  v6 = HIWORD(v3);
  v7 = HIBYTE(v4);
  HIBYTE(v4) = v4;
  LOBYTE(v4) = v7;
  v8 = a3 + 1;
  *a3 = v4;
  v9 = v6;
  do
  {
    --v9;
    v8 = (_WORD *)((char *)v8 + 1);
    *((_BYTE *)v8 - 1) = byte_43F2E0[(a2 >> (4 * v9)) & 0xF];
  }
  while ( v9 );
  return (__int64)v5 + v6;
}

//----- (00000000004295DD) ----------------------------------------------------
_BYTE *__fastcall sub_4295DD(__int64 a1, __int64 a2, __m128 a3, __m128 a4)
{
  unsigned __int64 v4; // r13
  __int64 v5; // r12
  __int64 *v6; // r14
  unsigned __int64 v7; // r12
  __int64 v8; // rbx
  char *v9; // rax
  unsigned __int8 *v10; // rbx
  unsigned int v11; // esi
  char v12; // al
  char *v13; // rdx
  char *v14; // rdx
  unsigned int v15; // eax
  unsigned __int64 v17; // [rsp+8h] [rbp-58h]
  unsigned int v18; // [rsp+1Ch] [rbp-44h] BYREF
  unsigned __int8 *v19; // [rsp+20h] [rbp-40h] BYREF
  char *v20; // [rsp+28h] [rbp-38h] BYREF

  v4 = a2 + 32;
  v5 = *(unsigned int *)(a2 + 24);
  v6 = *(__int64 **)a1;
  v19 = (unsigned __int8 *)(a2 + 32);
  v7 = a2 + 32 + v5;
  sub_428E41((__int64 *)a1, 34, a3, a4);
LABEL_2:
  if ( (unsigned __int64)v19 < v7 )
  {
    v8 = v7 - (_QWORD)v19;
    if ( v7 - (unsigned __int64)v19 > 0x40 )
      v8 = 64LL;
    v9 = *(char **)(a1 + 8);
    if ( *(_QWORD *)(a1 + 24) - (_QWORD)v9 < (unsigned __int64)(6 * v8) )
      v9 = (char *)sub_41CFE2(v6, (_QWORD *)(a1 + 8), 6 * v8, a3, a4);
    v20 = v9;
    v17 = (unsigned __int64)&v19[v8];
    while ( 1 )
    {
      while ( 1 )
      {
        v10 = v19;
        if ( (unsigned __int64)v19 >= v17 )
        {
          *(_QWORD *)(a1 + 8) = v20;
          goto LABEL_2;
        }
        ++v19;
        v11 = *v10;
        v12 = byte_4421C0[*v10];
        if ( v12 >= 0 )
        {
          v13 = v20++;
          goto LABEL_13;
        }
        if ( (unsigned __int8)v12 <= 0x9Fu )
          break;
        v14 = v20;
        v12 += 0x80;
        ++v20;
        *v14 = 92;
        v13 = v20++;
LABEL_13:
        *v13 = v12;
      }
      if ( v12 == (char)0x80 )
        break;
      v19 = v10;
      if ( !(unsigned int)sub_41C7A1((__int64)v6, (unsigned __int64 *)&v19, v4, v7, (int *)&v18) )
      {
        v15 = *v10;
        v19 = v10 + 1;
        v18 = v15;
      }
      v11 = v18;
      if ( *(_DWORD *)(a1 + 68) || v18 - 8232 <= 1 )
LABEL_20:
        v20 = (char *)sub_429568((_DWORD *)(a1 + 76), v11, v20);
      else
        sub_42E436(&v20, v18);
    }
    v18 = *v10;
    goto LABEL_20;
  }
  return sub_428E41((__int64 *)a1, 34, a3, a4);
}

//----- (000000000042974E) ----------------------------------------------------
_BYTE *__fastcall sub_42974E(__int64 a1, __int64 a2, __m128 a3, __m128 a4)
{
  unsigned __int64 v5; // rbx
  char *v6; // r14
  _BOOL4 i; // eax
  __int64 v8; // rdx
  int v9; // edi

  if ( *(_DWORD *)(a1 + 72) )
  {
    v5 = a2 + 32 + *(unsigned int *)(a2 + 24);
    if ( a2 + 32 != v5 )
    {
      v6 = (char *)(a2 + 33);
      for ( i = sub_41CAA1(*(char *)(a2 + 32)); i; i = sub_41CADA(v9) )
      {
        if ( (unsigned __int64)v6 >= v5 )
          return (_BYTE *)sub_428FAA((__int64 *)a1, a2, v8, a3, a4);
        v9 = *v6++;
      }
    }
  }
  return sub_4295DD(a1, a2, a3, a4);
}
// 4297A6: variable 'v8' is possibly undefined

//----- (00000000004297BE) ----------------------------------------------------
__int64 __fastcall sub_4297BE(__int64 a1, __m128 a2, __m128 a3)
{
  __int64 *v3; // r12
  int v4; // ebx
  int v5; // er13
  int v6; // er15
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // r9
  _WORD *v10; // rax
  __int64 v12; // [rsp+8h] [rbp-68h]
  __int64 v13; // [rsp+18h] [rbp-58h]
  __int64 v14; // [rsp+20h] [rbp-50h]
  int v15; // [rsp+28h] [rbp-48h]
  int v16; // [rsp+2Ch] [rbp-44h]
  unsigned int v17[13]; // [rsp+3Ch] [rbp-34h] BYREF

  v3 = *(__int64 **)a1;
  sub_42946B(a1, v17, a2, a3);
  v4 = *(_DWORD *)(a1 + 56);
  v16 = v17[0] - 1;
  if ( v4 < 0 )
  {
    sub_404F0A(v3, v17[0] - 1, a2, a3);
    sub_40DC2D(v3, 0x10u, a2, a3);
    v4 = sub_40480A(v3, -1);
  }
  v5 = 0;
  sub_428E41((__int64 *)a1, 123, a2, a3);
  v6 = 0;
  v15 = sub_405CB0(v3, v4, a2, a3);
  while ( v5 != v15 )
  {
    sub_40370E(v3, v4, v5, a2, a3);
    v9 = sub_405B3C((__int64)v3, -1);
    v14 = *(_QWORD *)(a1 + 8);
    v13 = *(_QWORD *)(a1 + 16);
    if ( *(_QWORD *)(a1 + 48) )
    {
      v12 = v9;
      sub_428F0A((__int64 *)a1, *(_DWORD *)(a1 + 88), v8, a2, a3);
      sub_42974E(a1, v12, a2, a3);
      if ( *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 8) <= 1uLL )
        sub_41CFE2(*(__int64 **)a1, (_QWORD *)(a1 + 8), 2LL, a2, a3);
      v10 = *(_WORD **)(a1 + 8);
      *v10 = 8250;
      *(_QWORD *)(a1 + 8) = v10 + 1;
    }
    else
    {
      sub_42974E(a1, v9, a2, a3);
      sub_428E41((__int64 *)a1, 58, a2, a3);
    }
    if ( (unsigned int)sub_429962(a1, v16, a2, a3) )
    {
      v6 = 1;
      sub_428E41((__int64 *)a1, 44, a2, a3);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 16) + v14 - v13;
    }
    ++v5;
  }
  if ( v6 )
  {
    --*(_QWORD *)(a1 + 8);
    if ( *(_QWORD *)(a1 + 48) )
      sub_428F0A((__int64 *)a1, *(_DWORD *)(a1 + 88) - 1, v7, a2, a3);
  }
  sub_428E41((__int64 *)a1, 125, a2, a3);
  return sub_429412(a1, v17, a2, a3);
}
// 429881: variable 'v8' is possibly undefined
// 429935: variable 'v7' is possibly undefined

//----- (0000000000429962) ----------------------------------------------------
__int64 __fastcall sub_429962(__int64 a1, int a2, __m128 a3, __m128 a4)
{
  __int64 *v5; // r12
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rsi
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rsi
  unsigned int v14; // eax
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // er13
  __int64 v18; // rax
  int v19; // ebx
  __int64 v20; // rcx
  char *v21; // rdx
  const char *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  unsigned __int64 v25; // r13
  __int64 *v26; // r15
  int v27; // ebx
  __int64 v28; // rdx
  __int64 v29; // rdx
  __int64 v30; // rax
  __int64 *v31; // r13
  unsigned int v32; // eax
  __int64 v33; // rdx
  int v35; // [rsp+4h] [rbp-7Ch]
  unsigned int v36; // [rsp+8h] [rbp-78h]
  double v37; // [rsp+8h] [rbp-78h]
  unsigned int v38[28]; // [rsp+10h] [rbp-70h] BYREF

  v5 = *(__int64 **)a1;
  sub_40EC01(
    *(__int64 **)a1,
    (__int128 *)(*(_QWORD *)(*(_QWORD *)a1 + 104LL) + 16LL * a2),
    (__m128 *)(*(_QWORD *)(*(_QWORD *)a1 + 112LL) - 16LL),
    a3);
  if ( (unsigned int)sub_406117(v5, -1, a3, a4) )
  {
    sub_4037B9(v5, -65453, a3, a4);
    if ( sub_4065F2((__int64)v5, -1) )
    {
      sub_404FF1(v5, a3, a4);
      sub_405005(v5, a3, a4);
      sub_41DA64(v5, 1, a3, a4);
      sub_405181(v5, a3, a4);
    }
    else
    {
      sub_407D7E(v5, 0xFFFFFFFFLL, v6, v7, a3, a4);
    }
  }
  v8 = *(_QWORD *)(a1 + 40);
  if ( v8 )
  {
    sub_407C45(v5, v8, a3, a4);
    sub_404F0A(v5, a2, a3, a4);
    sub_405005(v5, a3, a4);
    sub_405005(v5, a3, a4);
    v8 = 2LL;
    sub_41DA64(v5, 2, a3, a4);
    sub_405181(v5, a3, a4);
  }
  v9 = v5[14];
  if ( *(_DWORD *)(v9 - 16) != 9 )
  {
LABEL_27:
    v8 = 0xFFFFFFFFLL;
    v17 = sub_406117(v5, -1, a3, a4);
    if ( !v17 )
    {
      v18 = v5[14];
      v19 = *(_DWORD *)(v18 - 16);
      v10 = (unsigned int)(v19 - 2);
      switch ( v19 )
      {
        case 2:
          v8 = *(unsigned int *)(a1 + 100);
          goto LABEL_76;
        case 3:
          goto LABEL_30;
        case 4:
          v8 = 157 - (unsigned int)(*(_DWORD *)(v18 - 8) != 0);
          goto LABEL_76;
        case 5:
          sub_43ABE2((__int64)v38, 0LL, 0x40uLL);
          if ( *(_DWORD *)(a1 + 76) )
          {
            v21 = "(%p)";
            v22 = "(null)";
          }
          else
          {
            v21 = "{\"_ptr\":\"%p\"}";
            v22 = "{\"_ptr\":\"null\"}";
          }
          if ( !v20 )
            v21 = (char *)v22;
          v8 = 63LL;
          sub_438FFB((__int64)v38, 63LL, v21);
          v25 = sub_43AD53(v38);
          if ( v25 > *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 8) )
          {
            v8 = a1 + 8;
            sub_41CFE2(*(__int64 **)a1, (_QWORD *)(a1 + 8), v25, a3, a4);
          }
          if ( v25 )
          {
            v8 = (__int64)v38;
            sub_43AAA0(*(_QWORD *)(a1 + 8), (__int64)v38, v25);
          }
          *(_QWORD *)(a1 + 8) += v25;
          goto LABEL_77;
        case 6:
          goto LABEL_62;
        case 8:
          v8 = *(_QWORD *)(v18 - 8);
          if ( _bittest((const signed __int32 *)v8, 9u) )
            goto LABEL_78;
          sub_4295DD(a1, v8, a3, a4);
          goto LABEL_77;
        case 9:
          if ( !sub_417FC2(*(_QWORD *)(v18 - 8)) )
            goto LABEL_61;
          v26 = *(__int64 **)a1;
          v27 = 0;
          sub_42946B(a1, v38, a3, a4);
          v36 = v38[0] - 1;
          sub_428E41((__int64 *)a1, 91, a3, a4);
          v35 = sub_405CB0(v26, v36, a3, a4);
          while ( v35 != v27 )
          {
            if ( *(_QWORD *)(a1 + 48) )
              sub_428F0A((__int64 *)a1, *(_DWORD *)(a1 + 88), v28, a3, a4);
            sub_4089F6(v26, v27, a3, a4);
            if ( !(unsigned int)sub_429962(a1, v36, a3, a4) )
              sub_428FFB((__int64 *)a1, 0x9Bu, v29, a3, a4);
            ++v27;
            v17 = 1;
            sub_428E41((__int64 *)a1, 44, a3, a4);
          }
          if ( v17 )
          {
            --*(_QWORD *)(a1 + 8);
            if ( *(_QWORD *)(a1 + 48) )
              sub_428F0A((__int64 *)a1, *(_DWORD *)(a1 + 88) - 1, v28, a3, a4);
          }
          sub_428E41((__int64 *)a1, 93, a3, a4);
          v8 = (__int64)v38;
          sub_429412(a1, v38, a3, a4);
          goto LABEL_77;
        case 10:
          if ( *(_DWORD *)(a1 + 84) )
          {
            v30 = *(_QWORD *)(v18 - 8);
            v10 = *(_QWORD *)(v30 + 24);
            v8 = v30 + 32;
            if ( *(char *)v30 < 0 )
              v8 = *(_QWORD *)(v30 + 32);
            goto LABEL_59;
          }
          v8 = 0xFFFFFFFFLL;
          sub_408290(v5, -1, a3, a4, v10, v11, v15, v16);
LABEL_61:
          sub_4297BE(a1, a3, a4);
          goto LABEL_77;
        default:
          v31 = *(__int64 **)a1;
          v37 = *(double *)(*(_QWORD *)(*(_QWORD *)a1 + 112LL) - 8LL);
          v32 = sub_42FB3D(v37);
          *(double *)a3.i64 = v37;
          v10 = _mm_movemask_pd((__m128d)a3) & 1;
          if ( v32 > 1 )
          {
            if ( v32 == 2 && (_DWORD)v10 && *(_DWORD *)(a1 + 84) )
              sub_407826(v31, 0x3Eu, a3, a4);
            else
              sub_41B6BE(v31, 0xAu, 0, 0, a3, a4);
            v8 = sub_405B3C((__int64)v31, -1);
            sub_428FAA((__int64 *)a1, v8, v33, a3, a4);
            goto LABEL_77;
          }
          v8 = 155LL;
          if ( (*(_BYTE *)(a1 + 64) & 0xC) != 0 )
          {
            if ( v32 )
            {
              if ( (_DWORD)v10 )
                v8 = *(unsigned int *)(a1 + 108);
              else
                v8 = *(unsigned int *)(a1 + 112);
            }
            else
            {
              v8 = *(unsigned int *)(a1 + 104);
            }
          }
          break;
      }
      goto LABEL_76;
    }
    goto LABEL_78;
  }
  v10 = *(_QWORD *)(v9 - 8);
  v11 = *(unsigned int *)v10;
  if ( (v11 & 0x2000) != 0 && (*(_BYTE *)(a1 + 64) & 0xC) != 0 )
  {
    v12 = *(_QWORD *)(v10 + 56);
    if ( v12 )
    {
      v11 = *(unsigned int *)(v10 + 72);
      v10 = *(unsigned int *)(v10 + 76);
      if ( (unsigned __int64)(unsigned int)(v11 + v10) <= *(_QWORD *)(v12 + 24) )
      {
        v13 = v12 + 32;
        if ( *(char *)v12 < 0 )
          v13 = *(_QWORD *)(v12 + 32);
        v8 = v11 + v13;
LABEL_59:
        sub_428E7D(a1, v8, v10, v11, a3, a4);
        goto LABEL_77;
      }
    }
LABEL_30:
    v8 = 155LL;
LABEL_76:
    sub_428FFB((__int64 *)a1, v8, v10, a3, a4);
LABEL_77:
    sub_407DC0(v5, v8, v23, v24, a3, a4);
    return 1LL;
  }
  v14 = (unsigned int)v11 >> 27;
  if ( (unsigned int)v11 >> 27 == 12 )
  {
    sub_408725(v5, -1, a3, a4);
    goto LABEL_27;
  }
  if ( v14 > 0xC )
  {
    if ( v14 != 17 )
      goto LABEL_24;
LABEL_23:
    sub_403883(v5, -65430, a3, a4);
    sub_405181(v5, a3, a4);
    goto LABEL_27;
  }
  if ( v14 == 5 )
    goto LABEL_23;
  if ( v14 == 10 )
  {
    *(double *)a3.i64 = sub_405CAB(v5, a3, a4);
    goto LABEL_27;
  }
LABEL_24:
  if ( (v11 & 0x200) == 0 )
    goto LABEL_27;
  if ( (*(_BYTE *)(a1 + 64) & 0xC) != 0 )
  {
LABEL_62:
    v8 = *(unsigned int *)(a1 + 116);
    goto LABEL_76;
  }
LABEL_78:
  sub_407DC0(v5, v8, v10, v11, a3, a4);
  return 0LL;
}
// 4299F0: variable 'v6' is possibly undefined
// 4299F0: variable 'v7' is possibly undefined
// 429B83: variable 'v20' is possibly undefined
// 429C4D: variable 'v28' is possibly undefined
// 429C73: variable 'v29' is possibly undefined
// 429CEB: variable 'v11' is possibly undefined
// 429CFB: variable 'v15' is possibly undefined
// 429CFB: variable 'v16' is possibly undefined
// 429D7E: variable 'v33' is possibly undefined
// 429DB4: variable 'v23' is possibly undefined
// 429DB4: variable 'v24' is possibly undefined
// 429DC3: variable 'v10' is possibly undefined
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (0000000000429DD9) ----------------------------------------------------
unsigned __int8 __fastcall sub_429DD9(__int64 a1)
{
  unsigned __int8 *v1; // rax
  __int64 v2; // rcx
  unsigned __int8 *v3; // rdx

  v1 = *(unsigned __int8 **)(a1 + 8);
  do
  {
    v2 = *v1;
    v3 = v1++;
  }
  while ( byte_441FA0[v2] );
  *(_QWORD *)(a1 + 8) = v1;
  return *v3;
}

//----- (0000000000429DF6) ----------------------------------------------------
unsigned __int8 *__fastcall sub_429DF6(__int64 a1, __m128 a2, __m128 a3)
{
  unsigned __int64 v3; // rbx
  __int64 *v5; // r13
  char v6; // al
  _BYTE *v7; // rsi
  __int64 *v8; // r13
  __int64 v9; // rsi
  unsigned __int8 *i; // rdx
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdi
  _BYTE *j; // rax
  _BYTE *v18; // rax
  _BYTE *k; // rdx
  __int64 v20; // rax
  unsigned __int8 v21; // al
  __int64 *v22; // r15
  unsigned __int8 *v23; // r14
  unsigned __int8 v24; // al
  unsigned int v25; // edx
  unsigned __int8 *result; // rax
  unsigned __int64 v27; // [rsp+8h] [rbp-48h]
  __int64 v28[7]; // [rsp+18h] [rbp-38h] BYREF

  v5 = *(__int64 **)a1;
  v6 = sub_429DD9(a1);
  if ( v6 == 34 )
  {
    sub_4290F1(a1, a2, a3);
    goto LABEL_70;
  }
  if ( (unsigned __int8)(v6 - 48) <= 9u || v6 == 45 )
  {
    v7 = *(_BYTE **)(a1 + 8);
    if ( !*(_DWORD *)(a1 + 40) || v6 != 45 || *v7 != 73 )
    {
      v8 = *(__int64 **)a1;
      v9 = (__int64)(v7 - 1);
      *(_QWORD *)(a1 + 8) = v9;
      for ( i = (unsigned __int8 *)v9; byte_441EA0[*i]; ++i )
        ;
      *(_QWORD *)(a1 + 8) = i;
      sub_406B69(v8, v9, (unsigned __int64)&i[-v9], a2, a3);
      sub_41B6EB(v8, 10, 0x52u, a2, a3);
      if ( (unsigned int)sub_4064EF((__int64)v8, -1) )
        sub_42909D(a1);
      goto LABEL_70;
    }
    sub_429282((_QWORD *)a1, 0x3Du);
    *(double *)a2.i64 = -INFINITY;
LABEL_27:
    sub_406A1B(v5, a2, a3);
    goto LABEL_70;
  }
  switch ( v6 )
  {
    case 't':
      sub_429282((_QWORD *)a1, 0x9Cu);
      sub_40699D(v5, a2, a3, 156LL, v11);
      goto LABEL_70;
    case 'f':
      sub_429282((_QWORD *)a1, 0x9Du);
      sub_4069DC(v5, a2, a3, 157LL, v12);
      goto LABEL_70;
    case 'n':
      sub_429282((_QWORD *)a1, 0x9Bu);
      sub_40691D(v5, 155LL, v13, a2, a3);
      goto LABEL_70;
  }
  if ( *(_DWORD *)(a1 + 40) )
  {
    switch ( v6 )
    {
      case 'u':
        sub_429282((_QWORD *)a1, 0x3Au);
        sub_4068D1(v5, 58LL, v14, a2, a3);
        goto LABEL_70;
      case 'N':
        sub_429282((_QWORD *)a1, 0x3Bu);
        sub_406B26(v5, 59LL, v15, a2, a3);
        goto LABEL_70;
      case 'I':
        sub_429282((_QWORD *)a1, 0x3Cu);
        *(double *)a2.i64 = INFINITY;
        goto LABEL_27;
      case '(':
        v5 = *(__int64 **)a1;
        v16 = *(_QWORD *)(a1 + 8);
        for ( j = (_BYTE *)v16; ; j = (_BYTE *)v3 )
        {
          v3 = (unsigned __int64)(j + 1);
          if ( *j == 41 )
            break;
          if ( !*j )
          {
LABEL_32:
            v16 = a1;
            sub_42909D(a1);
          }
        }
        v28[0] = 0LL;
        sub_43914E(v16, 0x446ABBuLL, v28);
        sub_406F18(v5, v28[0], a2, a3);
        goto LABEL_41;
      case '|':
        v18 = *(_BYTE **)(a1 + 8);
        v5 = *(__int64 **)a1;
        for ( k = v18; ; ++k )
        {
          v3 = (unsigned __int64)(k + 1);
          if ( *k == 124 )
            break;
          if ( !*k )
            goto LABEL_32;
        }
        v27 = k - v18;
        v20 = sub_4076DF(*(__int64 **)a1, k - v18, a2, a3);
        sub_43AAA0(v20, *(_QWORD *)(a1 + 8), v27);
        sub_42E9AD(v5, -1, a2, a3);
LABEL_41:
        *(_QWORD *)(a1 + 8) = v3;
        goto LABEL_70;
    }
  }
  if ( v6 != 123 )
    goto LABEL_60;
  v5 = *(__int64 **)a1;
  v3 = 0LL;
  sub_429056(a1, a2, a3);
  sub_407095(v5, a2, a3);
  while ( 1 )
  {
    v21 = sub_429DD9(a1);
    if ( v21 == 44 && (int)v3 > 0 )
    {
      v21 = sub_429DD9(a1);
      goto LABEL_49;
    }
    if ( v21 == 125 )
      goto LABEL_69;
    if ( (_DWORD)v3 )
      break;
LABEL_49:
    if ( v21 == 34 )
    {
      sub_4290F1(a1, a2, a3);
    }
    else
    {
      if ( !*(_DWORD *)(a1 + 40) || !sub_41CAA1(v21) )
        break;
      v22 = *(__int64 **)a1;
      v23 = (unsigned __int8 *)(*(_QWORD *)(a1 + 8) - 1LL);
      *(_QWORD *)(a1 + 8) = v23;
      while ( sub_41CADA(*v23) )
        ++v23;
      sub_406B69(v22, *(_QWORD *)(a1 + 8), (unsigned __int64)&v23[-*(_QWORD *)(a1 + 8)], a2, a3);
      *(_QWORD *)(a1 + 8) = v23;
    }
    if ( sub_429DD9(a1) != 58 )
      break;
    sub_429DF6(a1, a2, a3);
    v3 = (unsigned int)(v3 + 1);
    sub_403D6B(v5, -3, 7, a2, a3);
  }
  v6 = sub_42909D(a1);
LABEL_60:
  if ( v6 != 91 )
    goto LABEL_32;
  v5 = *(__int64 **)a1;
  v3 = 0LL;
  sub_429056(a1, a2, a3);
  sub_4070BA(v5, a2, a3);
  while ( 2 )
  {
    v24 = sub_429DD9(a1);
    if ( v24 == 44 && (_DWORD)v3 )
    {
LABEL_67:
      sub_429DF6(a1, a2, a3);
      v25 = v3;
      v3 = (unsigned int)(v3 + 1);
      sub_403DB2(v5, -2, v25, 7, a2, a3);
      continue;
    }
    break;
  }
  if ( v24 != 93 )
  {
    if ( (_DWORD)v3 )
      goto LABEL_32;
    --*(_QWORD *)(a1 + 8);
    goto LABEL_67;
  }
  sub_406AF7(v5, -1, a2, a3);
LABEL_69:
  --*(_DWORD *)(a1 + 52);
LABEL_70:
  for ( result = *(unsigned __int8 **)(a1 + 8); byte_441FA0[*result]; ++result )
    ;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}
// 429ED8: variable 'v11' is possibly undefined
// 429EF3: variable 'v12' is possibly undefined
// 429F0E: variable 'v13' is possibly undefined
// 429F33: variable 'v14' is possibly undefined
// 429F4E: variable 'v15' is possibly undefined
// 429FA1: variable 'v3' is possibly undefined
// 429DF6: using guessed type __int64 var_38[7];

//----- (000000000042A197) ----------------------------------------------------
void __fastcall sub_42A197(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, int a5)
{
  int v6; // eax
  int v7; // ecx
  int v8; // er8
  __int64 v9; // rax
  __int64 *v10; // [rsp+0h] [rbp-60h] BYREF
  __int64 v11; // [rsp+8h] [rbp-58h]
  __int64 v12; // [rsp+10h] [rbp-50h]
  __int64 v13; // [rsp+18h] [rbp-48h]
  int v14; // [rsp+20h] [rbp-40h]
  int v15; // [rsp+24h] [rbp-3Ch]
  int v16; // [rsp+28h] [rbp-38h]
  int v17; // [rsp+2Ch] [rbp-34h]
  int v18; // [rsp+30h] [rbp-30h]
  int v19; // [rsp+38h] [rbp-28h]

  sub_43ABE2((__int64)&v10, 0LL, 0x40uLL);
  v16 = v6;
  v15 = v7;
  v18 = v7 & 0xC;
  v10 = a1;
  v19 = 1000;
  v17 = v7 & 8;
  v9 = sub_408998(a1, v8, a2, a3);
  v12 = v9 + 32;
  v11 = v9 + 32;
  v13 = v9 + *(unsigned int *)(v9 + 24) + 32;
  sub_429DF6((__int64)&v10, a2, a3);
  if ( v11 != v13 )
    sub_42909D((__int64)&v10);
  if ( sub_4065F2((__int64)a1, a5) )
  {
    v14 = a5;
    sub_407095(a1, a2, a3);
    sub_404FF1(a1, a2, a3);
    sub_403A07(a1, -131057, a2, a3);
    sub_407826(a1, 0xFu, a2, a3);
    sub_4292BB((__int64)&v10, a2, a3);
    sub_405181(a1, a2, a3);
  }
}
// 42A1C4: variable 'v6' is possibly undefined
// 42A1C9: variable 'v7' is possibly undefined
// 42A1E9: variable 'v8' is possibly undefined

//----- (000000000042A276) ----------------------------------------------------
__int64 __fastcall sub_42A276(__int64 *a1, int a2, int a3, int a4, int a5, __m128 a6, __m128 a7)
{
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // er14
  int v15; // ecx
  _DWORD *v16; // rax
  int v17; // er14
  __int64 v18; // rdx
  __int64 v19; // rcx
  unsigned int *v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // rcx
  _DWORD *v25; // rax
  int v26; // eax
  int v27; // eax
  unsigned int v28; // er13
  __int64 v29; // rdx
  __int64 v30; // rdx
  __int64 v31; // rcx
  __int64 *v33; // [rsp+18h] [rbp-2A8h] BYREF
  __int64 v34; // [rsp+20h] [rbp-2A0h] BYREF
  __int64 v35; // [rsp+28h] [rbp-298h]
  _DWORD *v36; // [rsp+40h] [rbp-280h]
  __int64 v37; // [rsp+48h] [rbp-278h]
  int v38; // [rsp+50h] [rbp-270h]
  int v39; // [rsp+54h] [rbp-26Ch]
  int v40; // [rsp+58h] [rbp-268h]
  int v41; // [rsp+5Ch] [rbp-264h]
  int v42; // [rsp+60h] [rbp-260h]
  int v43; // [rsp+64h] [rbp-25Ch]
  int v44; // [rsp+68h] [rbp-258h]
  int v45; // [rsp+6Ch] [rbp-254h]
  int v46; // [rsp+74h] [rbp-24Ch]
  int v47; // [rsp+78h] [rbp-248h]
  _BYTE v48[20]; // [rsp+7Ch] [rbp-244h]

  v10 = sub_404AE7((__int64)a1);
  sub_43ABE2((__int64)&v33, 0LL, 0x278uLL);
  v41 = v11;
  v12 = a5 & 2;
  v13 = a5 & 8;
  v40 = a5;
  v14 = a5 & 0xC;
  v33 = a1;
  v38 = -1;
  v42 = v12;
  v43 = v15;
  v44 = v13;
  v45 = v14;
  if ( v15 )
  {
    *(_QWORD *)v48 = 0x3B0000003ALL;
    *(_QWORD *)&v48[8] = 0x3C0000003DLL;
    *(_DWORD *)&v48[16] = 121 - (v12 == 0);
  }
  else if ( v13 )
  {
    *(_DWORD *)v48 = 116;
    *(_QWORD *)&v48[4] = 0x7700000075LL;
    *(_QWORD *)&v48[12] = 0x7800000076LL;
  }
  else
  {
    *(_DWORD *)v48 = 155;
  }
  if ( !v14 )
    v47 = 770;
  sub_41CF97(a1, &v34, 0x80uLL, a6, a7);
  v39 = sub_40779C(a1, a6, a7);
  v16 = (_DWORD *)sub_405823((__int64)a1, a3);
  if ( v16 )
  {
    v17 = *v16 & 0x200;
    if ( v17 )
    {
      v36 = v16;
      goto LABEL_23;
    }
    if ( sub_417FC2((__int64)v16) )
    {
      v38 = sub_4070BA(a1, a6, a7);
      sub_403FF2(a1, a3, 0x60u, a6, a7);
      while ( 1 )
      {
        if ( !(unsigned int)sub_404025(a1, -1, 1, a6, a7) )
        {
          sub_407D7E(a1, 0xFFFFFFFFLL, v18, v19, a6, a7);
          break;
        }
        v20 = (unsigned int *)sub_40483D((__int64)a1, -1);
        v22 = *v20;
        if ( (_DWORD)v22 == 8 )
        {
          if ( (**((_DWORD **)v20 + 1) & 0x200) != 0 )
            goto LABEL_21;
LABEL_20:
          sub_408725(a1, -1, a6, a7);
          sub_403953(a1, -4, v17++, a6, a7);
          sub_407D7E(a1, 4294967292LL, v23, v24, a6, a7);
        }
        else
        {
          if ( !(_DWORD)v22 || (_DWORD)v22 == 9 && (((**((_DWORD **)v20 + 1) >> 27) - 10) & 0xFFFFFFFD) == 0 )
            goto LABEL_20;
LABEL_21:
          sub_407DC0(a1, 0xFFFFFFFFLL, v22, v21, a6, a7);
        }
      }
    }
  }
LABEL_23:
  v25 = (_DWORD *)sub_405823((__int64)a1, a4);
  if ( v25 )
  {
    v26 = *v25 >> 27;
    if ( v26 == 10 )
    {
      sub_405C43(a1, a4, a6, a7);
    }
    else if ( v26 == 12 )
    {
      sub_408725(a1, a4, a6, a7);
    }
  }
  if ( sub_4064DB((__int64)a1, a4) )
  {
    v27 = sub_406077(a1, a4, 0, 10, a6, a7);
    sub_406B69(a1, (__int64)"          ", v27, a6, a7);
LABEL_32:
    v37 = sub_405B3C((__int64)a1, -1);
    goto LABEL_33;
  }
  if ( sub_406529((__int64)a1, a4) )
  {
    sub_404F0A(a1, a4, a6, a7);
    sub_409057(a1, -1, 0LL, 0xAuLL, a6, a7);
    goto LABEL_32;
  }
LABEL_33:
  if ( v37 && !*(_DWORD *)(v37 + 24) )
    v37 = 0LL;
  v28 = sub_407095(a1, a6, a7);
  sub_404F0A(a1, a2, a6, a7);
  sub_403A07(a1, -131057, a6, a7);
  sub_407963(a1, a6, a7);
  v46 = 1000;
  if ( (unsigned int)sub_429962((__int64)&v33, v28, a6, a7) )
    sub_406B69(a1, v35, v34 - v35, a6, a7);
  else
    sub_4068D1(a1, v28, v29, a6, a7);
  sub_405057(a1, v10, v30, v31, *(double *)a6.i64, a7);
  return sub_404B20(a1, v10 + 1, a6, a7);
}
// 42A2C5: variable 'v11' is possibly undefined
// 42A2F8: variable 'v15' is possibly undefined
// 42A475: variable 'v23' is possibly undefined
// 42A475: variable 'v24' is possibly undefined
// 42A47F: variable 'v21' is possibly undefined
// 42A489: variable 'v18' is possibly undefined
// 42A489: variable 'v19' is possibly undefined
// 42A5A1: variable 'v29' is possibly undefined
// 42A5C6: variable 'v30' is possibly undefined
// 42A5C6: variable 'v31' is possibly undefined

//----- (000000000042A5E8) ----------------------------------------------------
__int64 __fastcall sub_42A5E8(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_42A197(a1, a2, a3, 0LL, 1);
  return 1LL;
}

//----- (000000000042A601) ----------------------------------------------------
__int64 __fastcall sub_42A601(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_42A276(a1, 0, 1, 2, 0, a2, a3);
  return 1LL;
}

//----- (000000000042A620) ----------------------------------------------------
__m128 __fastcall sub_42A620(__m128 a1)
{
  return _mm_and_ps(a1, (__m128)xmmword_43EEA0);
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000042A641) ----------------------------------------------------
double __fastcall sub_42A641(double a1)
{
  return sqrt(a1);
}

//----- (000000000042A678) ----------------------------------------------------
__int64 __fastcall sub_42A678(__int64 *a1, double (__fastcall *a2)(double, double), __m128 a3, __m128 a4, __m128 a5)
{
  int v5; // ebx
  int v6; // er13
  __int64 v8; // [rsp+8h] [rbp-28h]

  v5 = 0;
  a5.i64[0] = a3.i64[0];
  v6 = sub_404AE7((__int64)a1);
  while ( v5 < v6 )
  {
    sub_405C43(a1, v5, a3, a4);
    v8 = a3.i64[0];
    a4.i64[0] = a3.i64[0];
    if ( (unsigned int)sub_42FB3D(*(double *)a3.i64) && (a3 = a5, (unsigned int)sub_42FB3D(*(double *)a5.i64)) )
    {
      a4.i64[0] = v8;
      a3.i64[1] = a5.i64[1];
      *(double *)a3.i64 = a2(*(double *)a5.i64, *(double *)&v8);
      a5 = a3;
    }
    else
    {
      a5 = (__m128)0x7FF8000000000000uLL;
    }
    ++v5;
  }
  sub_406A1B(a1, a5, a4);
  return 1LL;
}

//----- (000000000042A723) ----------------------------------------------------
double __fastcall sub_42A723(double a1, double a2)
{
  double v2; // xmm3_8
  double result; // xmm0_8

  v2 = a1;
  if ( !sub_41D67C(a1, 0.0) )
    return fmin(v2, a2);
  v2 = a1;
  if ( !sub_41D67C(a2, 0.0) )
    return fmin(v2, a2);
  result = -0.0;
  if ( !(HIDWORD(a2) | HIDWORD(v2)) )
    return 0.0;
  return result;
}

//----- (000000000042A7A1) ----------------------------------------------------
double __fastcall sub_42A7A1(double result)
{
  double v1; // [rsp+8h] [rbp-8h]

  v1 = result;
  if ( (unsigned int)sub_42FB3D(result) > 2 )
  {
    if ( result < -0.5 || result >= 0.5 )
    {
      result = result + 0.5;
      sub_42F94A(v1 + 0.5);
    }
    else if ( result < 0.0 )
    {
      return -0.0;
    }
    else
    {
      return 0.0;
    }
  }
  return result;
}

//----- (000000000042A7F7) ----------------------------------------------------
double __fastcall sub_42A7F7(double a1, double a2, __m128d a3, __m128d a4)
{
  double result; // xmm0_8

  a3.f64[0] = a1;
  a4.f64[0] = a2;
  if ( !sub_41D67C(a1, 0.0) )
    return sub_41D4DE(a3.f64[0], a2);
  a3.f64[0] = a1;
  if ( !sub_41D67C(a2, 0.0) )
    return sub_41D4DE(a3.f64[0], a2);
  result = 0.0;
  if ( (_mm_movemask_pd(a3) & 1) != 0 && (_mm_movemask_pd(a4) & 1) != 0 )
    return -0.0;
  return result;
}

//----- (000000000042A86D) ----------------------------------------------------
__int64 __fastcall sub_42A86D(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  __m128 v4; // xmm0

  v3 = (int)sub_41DCD3((__int64)a1);
  sub_405C43(a1, 0, a2, a3);
  v4 = ((__m128 (__fastcall *)(__m128))funcs_42A889[v3])(a2);
  sub_406A1B(a1, v4, a3);
  return 1LL;
}
// 442300: using guessed type __int64 (__fastcall *funcs_42A889[17])();

//----- (000000000042A8A2) ----------------------------------------------------
__int64 __fastcall sub_42A8A2(__int64 *a1, __m128 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rbx
  __m128 v5; // xmm1

  v4 = (int)sub_41DCD3((__int64)a1);
  sub_405C43(a1, 0, a2, a3);
  sub_405C43(a1, 1, a2, a3);
  v5 = a2;
  a2.i64[1] = a4.i64[1];
  *(double *)a2.i64 = ((double (__fastcall *)(double, double))funcs_42A8DF[v4])(*(double *)a2.i64, *(double *)v5.i64);
  sub_406A1B(a1, a2, v5);
  return 1LL;
}
// 4422E0: using guessed type void (__fastcall *funcs_42A8DF[2])(__m128, double);

//----- (000000000042A8FA) ----------------------------------------------------
__int64 __fastcall sub_42A8FA(__int64 *a1, __m128 a2, __m128 a3, __m128 a4)
{
  *(double *)a2.i64 = -INFINITY;
  return sub_42A678(a1, (double (__fastcall *)(double, double))sub_42A7F7, a2, a3, a4);
}

//----- (000000000042A91E) ----------------------------------------------------
__int64 __fastcall sub_42A91E(__int64 *a1, __m128 a2, __m128 a3)
{
  *(double *)a2.i64 = sub_41D71B((__int64)a1);
  sub_406A1B(a1, a2, a3);
  return 1LL;
}

//----- (000000000042A93F) ----------------------------------------------------
__int64 __fastcall sub_42A93F(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er14
  int v4; // er13
  int v5; // ebx
  __m128 v6; // xmm0
  double v7; // xmm2_8
  int v8; // er13
  int v9; // esi
  double v10; // xmm0_8
  __m128 v11; // xmm3
  double v12; // xmm0_8
  double v14; // [rsp+10h] [rbp-30h]
  double v15; // [rsp+18h] [rbp-28h]

  v3 = 0;
  v4 = 0;
  v15 = 0.0;
  v5 = sub_404AE7((__int64)a1);
  while ( v4 < v5 )
  {
    sub_405C43(a1, v4, a2, a3);
    a3 = _mm_and_ps(a2, (__m128)xmmword_43EEA0);
    a2 = a3;
    if ( (unsigned int)sub_42FB3D(*(double *)a3.i64) )
    {
      *(double *)a2.i64 = sub_41D4DE(v15, *(double *)a3.i64);
      v15 = *(double *)a2.i64;
    }
    else
    {
      v3 = 1;
    }
    ++v4;
  }
  *(double *)a3.i64 = INFINITY;
  v6 = (__m128)0x7FF0000000000000uLL;
  if ( !sub_41D67C(v15, INFINITY) )
  {
    *(double *)v6.i64 = NAN;
    if ( !v3 )
    {
      a3 = 0LL;
      v6 = 0LL;
      if ( !sub_41D67C(v15, 0.0) )
      {
        v7 = 0.0;
        v8 = 0;
        a3 = 0LL;
        while ( v8 < v5 )
        {
          v9 = v8;
          v14 = *(double *)a3.i64;
          ++v8;
          v10 = sub_40541C((__int64)a1, v9);
          v11.i64[1] = a3.i64[1];
          v12 = v10 / v15 * (v10 / v15) - v7;
          *(double *)v11.i64 = *(double *)a3.i64 + v12;
          a3 = v11;
          v7 = v14 + v12 - v14 - v12;
        }
        *(double *)v6.i64 = sqrt(*(double *)a3.i64) * v15;
      }
    }
  }
  sub_406A1B(a1, v6, a3);
  return 1LL;
}
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000042AA6C) ----------------------------------------------------
__int64 __fastcall sub_42AA6C(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_405C43(a1, 0, a2, a3);
  if ( !sub_41D3C3(*(double *)a2.i64) && !sub_41D67C(*(double *)a2.i64, 0.0) )
    sub_406A68(a1, 2 * (*(double *)a2.i64 > 0.0) - 1, a2, (__m128)0LL);
  return 1LL;
}

//----- (000000000042AACA) ----------------------------------------------------
__int64 __fastcall sub_42AACA(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // eax
  int v4; // esi

  v3 = sub_405E64(a1, 0, a2, a3);
  v4 = 16;
  if ( (v3 & 0xFFFF0000) != 0 )
  {
    v3 >>= 16;
    v4 = 0;
  }
  if ( BYTE1(v3) )
    v3 >>= 8;
  else
    v4 += 8;
  if ( (v3 & 0xF0) != 0 )
    v3 >>= 4;
  else
    v4 += 4;
  if ( (v3 & 0xC) != 0 )
    v3 >>= 2;
  else
    v4 += 2;
  if ( (v3 & 2) != 0 )
    v3 >>= 1;
  else
    ++v4;
  sub_406AAF(a1, ((v3 & 1) == 0) + v4, a2, a3);
  return 1LL;
}

//----- (000000000042AB36) ----------------------------------------------------
__int64 __fastcall sub_42AB36(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  int v4; // eax

  v3 = sub_405E64(a1, 0, a2, a3);
  v4 = sub_405E64(a1, 1, a2, a3);
  sub_406A68(a1, v4 * v3, a2, a3);
  return 1LL;
}

//----- (000000000042AB6D) ----------------------------------------------------
double __fastcall sub_42AB6D(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rax

  sub_406FB2(a1, a2, a3);
  if ( sub_4064DB((__int64)a1, -1) )
    return sub_40541C((__int64)a1, -1);
  v3 = (_DWORD *)sub_405823((__int64)a1, -1);
  if ( v3 && *v3 >> 27 == 10 )
  {
    sub_403883(a1, -65430, a2, a3);
    sub_405181(a1, a2, a3);
    return sub_40541C((__int64)a1, -1);
  }
  sub_401C42(a1, (__int64)"third_party/duktape/duk_bi_number.c", 0x6000019u, "number expected", a2, a3);
  return 0.0;
}

//----- (000000000042ABE8) ----------------------------------------------------
__int64 __fastcall sub_42ABE8(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er8
  __int64 result; // rax
  _DWORD *v5; // rax

  if ( !(unsigned int)sub_404AE7((__int64)a1) )
    sub_406A68(a1, 0, a2, a3);
  sub_405C43(a1, 0, a2, a3);
  sub_404B20(a1, 1u, a2, a3);
  v3 = sub_41DC85((__int64)a1);
  result = 1LL;
  if ( v3 )
  {
    sub_406FB2(a1, a2, a3);
    v5 = (_DWORD *)sub_405B41((__int64)a1, -1);
    *v5 = *v5 & 0x7FFFFFF | 0x50000000;
    sub_404FD6(a1, a2, a3);
    sub_403E13(a1, -33527296, a2, a3);
    return 0LL;
  }
  return result;
}

//----- (000000000042AC70) ----------------------------------------------------
__int64 __fastcall sub_42AC70(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_42AB6D(a1, a2, a3);
  return 1LL;
}

//----- (000000000042AC80) ----------------------------------------------------
__int64 __fastcall sub_42AC80(__int64 *a1, __m128 a2, __m128 a3)
{
  unsigned int v3; // esi

  *(double *)a2.i64 = sub_42AB6D(a1, a2, a3);
  v3 = 10;
  if ( !sub_40649F((__int64)a1, 0) )
    v3 = sub_40608A(a1, 0, 2, 36, a2, a3);
  sub_41B6BE(a1, v3, 0, 0, a2, a3);
  return 1LL;
}

//----- (000000000042ACD0) ----------------------------------------------------
__int64 __fastcall sub_42ACD0(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  double v5; // [rsp+8h] [rbp-18h]

  *(double *)a2.i64 = sub_42AB6D(a1, a2, a3);
  v5 = *(double *)a2.i64;
  v3 = sub_40608A(a1, 0, 0, 20, a2, a3);
  if ( (unsigned int)sub_42FB3D(*(double *)a2.i64) <= 1
    || (a3.i64[0] = a2.i64[0], *(double *)a2.i64 >= 1.0e21)
    || (*(double *)a2.i64 = -1.0e21, v5 <= -1.0e21) )
  {
    sub_408725(a1, -1, a2, a3);
  }
  else
  {
    sub_41B6BE(a1, 0xAu, v3, 9, a2, a3);
  }
  return 1LL;
}

//----- (000000000042AD58) ----------------------------------------------------
__int64 __fastcall sub_42AD58(__int64 *a1, __m128 a2, __m128 a3)
{
  _BOOL4 v3; // ebx
  int v4; // eax

  *(double *)a2.i64 = sub_42AB6D(a1, a2, a3);
  v3 = sub_40649F((__int64)a1, 0);
  sub_405DB7(a1, 0, a2, a3);
  if ( (unsigned int)sub_42FB3D(*(double *)a2.i64) > 1 )
  {
    v4 = sub_40608A(a1, 0, 0, 20, a2, a3);
    sub_41B6BE(a1, 0xAu, v4 + 1, 3 - v3, a2, a3);
  }
  else
  {
    sub_408725(a1, -1, a2, a3);
  }
  return 1LL;
}

//----- (000000000042ADD9) ----------------------------------------------------
__int64 __fastcall sub_42ADD9(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  *(double *)a2.i64 = sub_42AB6D(a1, a2, a3);
  if ( sub_40649F((__int64)a1, 0) || (sub_405DB7(a1, 0, a2, a3), (unsigned int)sub_42FB3D(*(double *)a2.i64) <= 1) )
  {
    sub_408725(a1, -1, a2, a3);
  }
  else
  {
    v3 = sub_40608A(a1, 0, 1, 21, a2, a3);
    sub_41B6BE(a1, 0xAu, v3, 5, a2, a3);
  }
  return 1LL;
}

//----- (000000000042AE59) ----------------------------------------------------
__int64 __fastcall sub_42AE59(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  int v4; // ebx

  v3 = sub_4064DB((__int64)a1, 0);
  if ( v3 )
  {
    v4 = sub_41DCD3((__int64)a1);
    *(double *)a2.i64 = sub_40541C((__int64)a1, 0);
    if ( v4 == 1 )
    {
      v3 = sub_41D508((__int64)a1, 0LL, *(double *)a2.i64);
    }
    else if ( v4 == 2 )
    {
      v3 = sub_41D3C3(*(double *)a2.i64);
    }
    else if ( v4 )
    {
      v3 = sub_41D552((__int64)a1, 0LL, *(double *)a2.i64);
    }
    else
    {
      v3 = sub_41D4E3(*(double *)a2.i64);
    }
  }
  sub_406955(a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042AEBE) ----------------------------------------------------
__int64 __fastcall sub_42AEBE(__int64 *a1, double a2, __m128 a3)
{
  sub_4085AE(a1, (__int128 *)(a1[13] - 16), 0, a2, a3);
  return 1LL;
}

//----- (000000000042AED8) ----------------------------------------------------
__int64 __fastcall sub_42AED8(__int64 *a1, __m128 a2, __m128 a3)
{
  __int16 v3; // bx
  int v4; // eax
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9

  v3 = sub_406103((__int64)a1, 0);
  v4 = sub_41DC85((__int64)a1);
  if ( !(v4 | v3 & 6) || (v3 & 0x3F8) != 0 )
    sub_408290(a1, 0, a2, a3, v4 | v3 & 6u, v5, v6, v7);
  else
    sub_407003(a1, 134234240, 3, a2, a3);
  return 1LL;
}
// 42AF01: variable 'v5' is possibly undefined
// 42AF01: variable 'v6' is possibly undefined
// 42AF01: variable 'v7' is possibly undefined

//----- (000000000042AF2C) ----------------------------------------------------
__int64 __fastcall sub_42AF2C(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  int v4; // er13
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v3 = 1;
  v4 = sub_404AF4(a1, 1, a2, a3);
  sub_408290(a1, 0, a2, a3, v5, v6, v7, v8);
  while ( v3 < v4 )
  {
    if ( (sub_406103((__int64)a1, v3) & 6) == 0 )
    {
      sub_408290(a1, v3, a2, a3, v9, v10, v11, v12);
      sub_403FF2(a1, v3, 0x10u, a2, a3);
      while ( (unsigned int)sub_404025(a1, -1, 1, a2, a3) )
        sub_40388B(a1, 0, a2, a3);
    }
    ++v3;
  }
  sub_404B20(a1, 1u, a2, a3);
  return 1LL;
}
// 42AF50: variable 'v5' is possibly undefined
// 42AF50: variable 'v6' is possibly undefined
// 42AF50: variable 'v7' is possibly undefined
// 42AF50: variable 'v8' is possibly undefined
// 42AF71: variable 'v9' is possibly undefined
// 42AF71: variable 'v10' is possibly undefined
// 42AF71: variable 'v11' is possibly undefined
// 42AF71: variable 'v12' is possibly undefined

//----- (000000000042AFBF) ----------------------------------------------------
__int64 __fastcall sub_42AFBF(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  v3 = sub_40816B((__int64)a1, 0, a2, a3);
  sub_406955(a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042AFE9) ----------------------------------------------------
__int64 __fastcall sub_42AFE9(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  int v7; // ebx
  __int64 v8; // r13
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  int v15; // [rsp+8h] [rbp-38h] BYREF
  int v16; // [rsp+Ch] [rbp-34h] BYREF
  const signed __int32 *v17; // [rsp+10h] [rbp-30h] BYREF
  const signed __int32 *v18; // [rsp+18h] [rbp-28h] BYREF

  v7 = 0;
  v8 = sub_408496(a1, 0, 640LL, a6, a7, a2, a3);
  sub_408290(a1, 1, a2, a3, v9, v10, v11, v12);
  while ( 1 )
  {
    sub_404B20(a1, 2u, a2, a3);
    sub_403FF2(a1, 1, 0x14u, a2, a3);
    while ( 1 )
    {
      sub_404B20(a1, 3u, a2, a3);
      if ( !(unsigned int)sub_404025(a1, 2, 1, a2, a3) )
        break;
      sub_410892(a1, 4, &v15, &v16, &v17, &v18, a2, a3);
      if ( v7 )
      {
        v13 = sub_405B3C((__int64)a1, 3);
        sub_410A94(a1, v15, v8, v13, v16, (__int64)v17, a2, a3, (__int64)v18, 1);
      }
    }
    if ( v7 == 1 )
      break;
    v7 = 1;
  }
  sub_404FD6(a1, a2, a3);
  return 1LL;
}
// 42B012: variable 'v9' is possibly undefined
// 42B012: variable 'v10' is possibly undefined
// 42B012: variable 'v11' is possibly undefined
// 42B012: variable 'v12' is possibly undefined

//----- (000000000042B0CF) ----------------------------------------------------
__int64 __fastcall sub_42B0CF(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v11; // [rsp+0h] [rbp-10h]

  sub_40967D(a1, 0, a2, a3);
  v5 = sub_408553(a1, 0, 4LL, v3, v4, a2, a3);
  sub_407074(a1, 134234240, v5, a2, a3);
  if ( sub_40649F((__int64)a1, 1) )
    return 1LL;
  sub_405057(a1, 0, v6, v7, *(double *)a2.i64, a3);
  return sub_42AFE9(a1, a2, a3, 0LL, v8, v11, v9);
}
// 42B0EA: variable 'v3' is possibly undefined
// 42B0EA: variable 'v4' is possibly undefined
// 42B115: variable 'v6' is possibly undefined
// 42B115: variable 'v7' is possibly undefined
// 42B121: variable 'v8' is possibly undefined
// 42B121: variable 'v11' is possibly undefined
// 42B121: variable 'v9' is possibly undefined

//----- (000000000042B130) ----------------------------------------------------
__int64 __fastcall sub_42B130(_QWORD *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  v3 = sub_41DCD3((__int64)a1);
  sub_40405C(a1, 0, v3, a2, a3, v4, v5, v6);
  return 1LL;
}
// 42B149: variable 'v4' is possibly undefined
// 42B149: variable 'v5' is possibly undefined
// 42B149: variable 'v6' is possibly undefined

//----- (000000000042B155) ----------------------------------------------------
__int64 __fastcall sub_42B155(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  __int16 v4; // ax
  int v5; // esi
  __int64 v6; // rsi
  _BOOL4 v7; // er8

  v3 = sub_41DCD3((__int64)a1);
  v4 = sub_406103((__int64)a1, 0);
  if ( (v4 & 0x280) != 0 )
  {
    v5 = 1;
    if ( (v4 & 0x200) == 0 )
      v5 = v3 ^ 1;
  }
  else
  {
    v6 = sub_405823((__int64)a1, 0);
    v7 = 1;
    if ( v6 )
      v7 = sub_4116DD((__int64)a1, v6, v3) != 0;
    v5 = v7;
  }
  sub_406955(a1, v5, a2, a3);
  return 1LL;
}

//----- (000000000042B1CE) ----------------------------------------------------
__int64 __fastcall sub_42B1CE(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40869C(a1, a2, a3);
  sub_4037B9(a1, 82, a2, a3);
  sub_404FD6(a1, a2, a3);
  sub_41DA64(a1, 0, a2, a3);
  return 1LL;
}

//----- (000000000042B206) ----------------------------------------------------
__int64 __fastcall sub_42B206(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_40869C(a1, a2, a3);
  return 1LL;
}

//----- (000000000042B216) ----------------------------------------------------
__int64 __fastcall sub_42B216(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rbx
  __int64 v6; // rax
  int v7; // eax

  v3 = sub_405823((__int64)a1, 0);
  if ( v3 )
  {
    v5 = v3;
    v6 = sub_40869C(a1, a2, a3);
    v7 = sub_40DCA3(a1, *(_QWORD *)(v5 + 32), v6, 0, a2, a3);
    sub_406955(a1, v7, a2, a3);
  }
  else
  {
    sub_4069DC(a1, a2, a3, 0LL, v4);
  }
  return 1LL;
}
// 42B22F: variable 'v4' is possibly undefined

//----- (000000000042B266) ----------------------------------------------------
__int64 __fastcall sub_42B266(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_41162B(a1, 0, a2, a3);
}

//----- (000000000042B277) ----------------------------------------------------
__int64 __fastcall sub_42B277(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdx
  int v9; // eax
  __int64 v10; // rsi

  v3 = sub_41DCD3((__int64)a1);
  if ( v3 )
  {
    if ( v3 > 1 )
      goto LABEL_5;
  }
  else
  {
    sub_40869C(a1, a2, a3);
  }
  sub_408290(a1, 0, a2, a3, v4, v5, v6, v7);
LABEL_5:
  v8 = a1[13];
  v9 = *(_DWORD *)v8;
  if ( *(_DWORD *)v8 == 9 )
  {
    v10 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 32LL);
  }
  else if ( v9 == 10 )
  {
    v10 = a1[62];
  }
  else
  {
    if ( v9 != 6 )
    {
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_object.c", 362, a2, a3);
      return 0LL;
    }
    v10 = a1[25];
  }
  if ( v10 )
    sub_407C45(a1, v10, a2, a3);
  else
    sub_40691D(a1, 0LL, v8, a2, a3);
  return 1LL;
}
// 42B29D: variable 'v4' is possibly undefined
// 42B29D: variable 'v5' is possibly undefined
// 42B29D: variable 'v6' is possibly undefined
// 42B29D: variable 'v7' is possibly undefined

//----- (000000000042B30A) ----------------------------------------------------
__int64 __fastcall sub_42B30A(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax
  __int64 v4; // rcx
  __int64 v5; // r8
  int v6; // ebx
  unsigned int v7; // er13
  char *v8; // rsi
  __int64 v9; // r14
  __int16 v10; // ax
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rdx

  v3 = sub_41DCD3((__int64)a1);
  v6 = v3;
  if ( v3 )
  {
    if ( v3 == 1 )
      sub_406117(a1, 0, a2, a3);
    else
      sub_408553(a1, 0, 640LL, v4, v5, a2, a3);
    v7 = 1;
    sub_406117(a1, 1, a2, a3);
  }
  else
  {
    v7 = 0;
    sub_406FB9(a1, a2, a3);
    sub_40500F(a1, 0);
    if ( !(unsigned int)sub_406117(a1, 1, a2, a3) )
      return v7;
  }
  v8 = 0LL;
  v9 = sub_405823((__int64)a1, 1);
  v10 = sub_406103((__int64)a1, 0);
  if ( (v10 & 0x280) != 0 )
  {
    if ( v9 == a1[((v10 & 0x200) == 0 ? 0x25 : 0) + 25] )
      goto LABEL_18;
LABEL_20:
    if ( v6 == 2 )
    {
      v7 = 1;
      sub_4069DC(a1, a2, a3, (__int64)v8, v11);
    }
    else
    {
      v7 = 0;
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_object.c", 466, a2, a3);
    }
    return v7;
  }
  v12 = sub_405823((__int64)a1, 0);
  v8 = (char *)v12;
  if ( v12 && *(_QWORD *)(v12 + 32) != v9 )
  {
    v14 = v9;
    if ( *v8 < 0 )
    {
      while ( v14 )
      {
        if ( (char *)v14 == v8 )
          goto LABEL_20;
        v14 = *(_QWORD *)(v14 + 32);
      }
      sub_40DCFB((__int64)a1, (__int64)v8, v9, v13, a2, a3);
      goto LABEL_18;
    }
    goto LABEL_20;
  }
LABEL_18:
  sub_404B20(a1, 1u, a2, a3);
  if ( v6 == 2 )
    sub_40699D(a1, a2, a3, 1LL, v15);
  return v7;
}
// 42B373: variable 'v4' is possibly undefined
// 42B373: variable 'v5' is possibly undefined
// 42B400: variable 'v13' is possibly undefined
// 42B41A: variable 'v15' is possibly undefined
// 42B446: variable 'v11' is possibly undefined

//----- (000000000042B457) ----------------------------------------------------
__int64 __fastcall sub_42B457(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r13
  __int64 v7; // r14
  int v8; // eax
  int v10; // [rsp+8h] [rbp-38h] BYREF
  int v11; // [rsp+Ch] [rbp-34h] BYREF
  const signed __int32 *v12; // [rsp+10h] [rbp-30h] BYREF
  const signed __int32 *v13; // [rsp+18h] [rbp-28h] BYREF

  v3 = sub_41DCD3((__int64)a1);
  v6 = sub_408496(a1, 0, 640LL, v4, v5, a2, a3);
  v7 = sub_4089B9(a1, 1, a2, a3);
  sub_40582D(a1, 2, a2, a3);
  sub_410892(a1, 2, &v11, &v10, &v12, &v13, a2, a3);
  v8 = sub_410A94(a1, v11, v6, v7, v10, (__int64)v12, a2, a3, (__int64)v13, v3 ^ 1u);
  if ( v3 )
    sub_406955(a1, v8, a2, a3);
  else
    sub_407C45(a1, v6, a2, a3);
  return 1LL;
}
// 42B47A: variable 'v4' is possibly undefined
// 42B47A: variable 'v5' is possibly undefined

//----- (000000000042B50D) ----------------------------------------------------
__int64 __fastcall sub_42B50D(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  if ( !(unsigned int)sub_41DCD3((__int64)a1) )
    sub_408290(a1, 0, a2, a3, v3, v4, v5, v6);
  sub_410761(a1, -2, a2, a3, v3, v4, v5);
  return 1LL;
}
// 42B525: variable 'v3' is possibly undefined
// 42B525: variable 'v4' is possibly undefined
// 42B525: variable 'v5' is possibly undefined
// 42B525: variable 'v6' is possibly undefined

//----- (000000000042B541) ----------------------------------------------------
__int64 __fastcall sub_42B541(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  _DWORD *v5; // rax
  int v6; // esi

  if ( (unsigned int)sub_41DCD3((__int64)a1) )
    v5 = (_DWORD *)sub_408553(a1, 0, 640LL, v3, v4, a2, a3);
  else
    v5 = (_DWORD *)sub_405823((__int64)a1, 0);
  v6 = 0;
  if ( v5 )
    v6 = (*v5 >> 7) & 1;
  sub_406955(a1, v6, a2, a3);
  return 1LL;
}
// 42B56A: variable 'v3' is possibly undefined
// 42B56A: variable 'v4' is possibly undefined

//----- (000000000042B590) ----------------------------------------------------
__int64 __fastcall sub_42B590(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rcx
  int v12; // eax
  int v14; // eax
  __int64 v15; // [rsp+0h] [rbp-20h] BYREF
  __int64 v16[3]; // [rsp+8h] [rbp-18h] BYREF

  if ( (unsigned int)sub_41DCD3((__int64)a1) == 3 )
    v7 = sub_408496(a1, 0, 640LL, v4, v5, a2, a3);
  else
    v7 = sub_408411(a1, 0, v3, v4, v5, v6, a2, a3);
  if ( (unsigned int)sub_40DE9A(v7, &v15, v16) )
  {
    sub_407C45(a1, v16[0], a2, a3);
    if ( (unsigned int)sub_4037B9(a1, -65461, a2, a3) )
    {
      sub_40500F(a1, -2);
      sub_407C45(a1, v15, a2, a3);
      sub_41DA64(a1, 1, a2, a3);
      sub_40582D(a1, -1, a2, a3);
      v12 = sub_41DCD3((__int64)a1);
      sub_41FF48(a1, v15, dword_442410[v12], a2, a3);
      return 1LL;
    }
    sub_407DC0(a1, 4294901835LL, v8, v9, a2, a3);
    sub_407C45(a1, v15, a2, a3);
    sub_405057(a1, 0, v10, v11, *(double *)a2.i64, a3);
  }
  v14 = sub_41DCD3((__int64)a1);
  return sub_40DC2D(a1, dword_442410[v14], a2, a3);
}
// 42B5B1: variable 'v4' is possibly undefined
// 42B5B1: variable 'v5' is possibly undefined
// 42B5BD: variable 'v3' is possibly undefined
// 42B5BD: variable 'v6' is possibly undefined
// 42B5FA: variable 'v8' is possibly undefined
// 42B5FA: variable 'v9' is possibly undefined
// 42B610: variable 'v10' is possibly undefined
// 42B610: variable 'v11' is possibly undefined
// 442410: using guessed type int dword_442410[];
// 42B590: using guessed type __int64 var_18[3];

//----- (000000000042B68D) ----------------------------------------------------
__int64 __fastcall sub_42B68D(_QWORD *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  __int64 v4; // rsi
  __int64 v5; // rdx
  _DWORD *v6; // rax

  v3 = sub_41DCD3((__int64)a1);
  v4 = 0LL;
  if ( !(unsigned int)sub_406117(a1, 0, a2, a3) )
  {
    v6 = (_DWORD *)sub_40582D(a1, 0, a2, a3);
    *v6 &= ~0x80u;
    v4 = (__int64)v6;
    sub_40E4C4(a1, (__int64)v6, a2, a3);
  }
  if ( v3 == 1 )
    sub_40699D(a1, a2, a3, v4, v5);
  return 1LL;
}
// 42B6DF: variable 'v5' is possibly undefined

//----- (000000000042B6EE) ----------------------------------------------------
__int64 __fastcall sub_42B6EE(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  int v7; // eax

  sub_406FB2(a1, a2, a3);
  sub_40500F(a1, 0);
  sub_408290(a1, 0, a2, a3, v3, v4, v5, v6);
  sub_40661B(a1, 2, a2, a3);
  v7 = sub_41DCD3((__int64)a1);
  sub_403E29(a1, 0, v7 == 0 ? 182 : 310, a2, a3);
  return 0LL;
}
// 42B70C: variable 'v3' is possibly undefined
// 42B70C: variable 'v4' is possibly undefined
// 42B70C: variable 'v5' is possibly undefined
// 42B70C: variable 'v6' is possibly undefined

//----- (000000000042B745) ----------------------------------------------------
__int64 __fastcall sub_42B745(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // rcx
  int v12; // eax

  v3 = 10001;
  sub_406FB2(a1, a2, a3);
  sub_408290(a1, -1, a2, a3, v4, v5, v6, v7);
  while ( !sub_40649F((__int64)a1, -1) )
  {
    sub_404F0A(a1, 0, a2, a3);
    sub_403E24(a1, 1, a2, a3, 0LL, v8, v9);
    if ( !sub_40649F((__int64)a1, -1) )
    {
      v12 = sub_41DCD3((__int64)a1);
      sub_40377C(a1, -1, v12 == 0 ? 73 : 88, a2, a3);
      return 1LL;
    }
    sub_407D7E(a1, 0xFFFFFFFFLL, v10, v11, a2, a3);
    if ( !--v3 )
    {
      sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_object.c", 794, "prototype chain limit", a2, a3);
      return 0LL;
    }
    sub_40447B(a1, -1, a2, a3);
    sub_40511F(a1, -2, a2, a3);
  }
  return 1LL;
}
// 42B75F: variable 'v4' is possibly undefined
// 42B75F: variable 'v5' is possibly undefined
// 42B75F: variable 'v6' is possibly undefined
// 42B75F: variable 'v7' is possibly undefined
// 42B78B: variable 'v8' is possibly undefined
// 42B78B: variable 'v9' is possibly undefined
// 42B7BF: variable 'v10' is possibly undefined
// 42B7BF: variable 'v11' is possibly undefined

//----- (000000000042B80A) ----------------------------------------------------
__int64 __fastcall sub_42B80A(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __m128 a5, __m128 a6)
{
  *(double *)a5.i64 = sub_41DDAA((__int64)a1, a2, a3, a4);
  sub_406A1B(a1, a5, a6);
  return 1LL;
}

//----- (000000000042B82B) ----------------------------------------------------
__int64 __fastcall sub_42B82B(__int64 *a1, __m128 a2, __m128 a3)
{
  if ( (unsigned int)sub_404AE7((__int64)a1) )
    sub_406F59(a1, 0, a2, a3);
  else
    sub_406F18(a1, 0LL, a2, a3);
  sub_404B20(a1, 1u, a2, a3);
  if ( (unsigned int)sub_41DC85((__int64)a1) )
  {
    sub_407003(a1, -2013249408, 36, a2, a3);
    sub_404FD6(a1, a2, a3);
    sub_403E13(a1, -33527296, a2, a3);
  }
  return 1LL;
}

//----- (000000000042B89E) ----------------------------------------------------
__int64 __fastcall sub_42B89E(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  __int64 v4; // rax
  unsigned int v5; // er13

  v3 = sub_41DCD3((__int64)a1);
  sub_406FB2(a1, a2, a3);
  v4 = sub_404A12(a1, -1);
  if ( *(_DWORD *)v4 != 5 )
  {
    if ( *(_DWORD *)v4 != 9 || **(_DWORD **)(v4 + 8) >> 27 != 17 )
    {
      v5 = 0;
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_pointer.c", 74, a2, a3);
      return v5;
    }
    sub_403883(a1, -65430, a2, a3);
  }
  v5 = 1;
  if ( v3 )
    sub_408725(a1, -1, a2, a3);
  return v5;
}

//----- (000000000042B923) ----------------------------------------------------
__int64 __fastcall sub_42B923(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  sub_40582D((__int64 *)a1, 0, a2, a3);
  sub_408725((__int64 *)a1, 1, a2, a3);
  v3 = sub_41018F((__int64 *)a1, *(__int128 **)(a1 + 104), (__int128 *)(*(_QWORD *)(a1 + 104) + 16LL), 0, a2, a3);
  sub_406955((__int64 *)a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042B968) ----------------------------------------------------
__int64 __fastcall sub_42B968(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // ebx

  v3 = sub_404AF4((__int64 *)a1, 2, a2, a3);
  sub_40582D((__int64 *)a1, 0, a2, a3);
  sub_408725((__int64 *)a1, 1, a2, a3);
  if ( v3 <= 2 || (unsigned int)sub_408133(a1, 0, a2, a3) )
  {
    sub_40EC01((__int64 *)a1, *(__int128 **)(a1 + 104), (__m128 *)(*(_QWORD *)(a1 + 104) + 16LL), a2);
    return 1LL;
  }
  else
  {
    sub_401C42((__int64 *)a1, (__int64)"third_party/duktape/duk_bi_reflect.c", 0x100002Au, "unsupported", a2, a3);
    return 0LL;
  }
}

//----- (000000000042B9E3) ----------------------------------------------------
__int64 __fastcall sub_42B9E3(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  sub_40582D((__int64 *)a1, 0, a2, a3);
  sub_408725((__int64 *)a1, 1, a2, a3);
  v3 = sub_40F1DF((__int64 *)a1, *(int **)(a1 + 104), (__int128 *)(*(_QWORD *)(a1 + 104) + 16LL), *(double *)a2.i64, a3);
  sub_406955((__int64 *)a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042BA26) ----------------------------------------------------
__int64 __fastcall sub_42BA26(__int64 a1, __m128 a2, __m128 a3)
{
  int v3; // ebx
  int v5; // eax

  v3 = sub_404AF4((__int64 *)a1, 3, a2, a3);
  sub_40582D((__int64 *)a1, 0, a2, a3);
  sub_408725((__int64 *)a1, 1, a2, a3);
  if ( v3 <= 3 || (unsigned int)sub_408133(a1, 0, a2, a3) )
  {
    v5 = sub_40F7B6(
           (__int64 *)a1,
           *(__int64 **)(a1 + 104),
           (__m128 *)(*(_QWORD *)(a1 + 104) + 16LL),
           (__int128 *)(*(_QWORD *)(a1 + 104) + 32LL),
           0,
           a2);
    sub_406955((__int64 *)a1, v5, a2, a3);
    return 1LL;
  }
  else
  {
    sub_401C42((__int64 *)a1, (__int64)"third_party/duktape/duk_bi_reflect.c", 0x1000056u, "unsupported", a2, a3);
    return 0LL;
  }
}

//----- (000000000042BAB2) ----------------------------------------------------
void __fastcall sub_42BAB2(_QWORD *a1, __m128 a2, __m128 a3)
{
  sub_406FB2(a1, a2, a3);
  sub_405AEC(a1, -1, a2, a3);
  sub_40500F(a1, 0);
}

//----- (000000000042BADF) ----------------------------------------------------
__int64 __fastcall sub_42BADF(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rbx

  v3 = (_DWORD *)sub_405823((__int64)a1, 0);
  if ( (unsigned int)sub_41DC85((__int64)a1) )
  {
    if ( !v3 )
      goto LABEL_13;
    goto LABEL_5;
  }
  if ( !v3 || *v3 >> 27 != 11 )
    goto LABEL_13;
  if ( !sub_40649F((__int64)a1, 1) )
  {
LABEL_5:
    if ( *v3 >> 27 == 11 )
    {
      sub_4037B9(a1, 44, a2, a3);
      if ( sub_40649F((__int64)a1, 1) )
        sub_40377C(a1, 0, 0x30u, a2, a3);
      else
        sub_404FDD(a1, a2, a3);
LABEL_19:
      sub_408725(a1, -2, a2, a3);
      sub_408725(a1, -1, a2, a3);
      sub_41C0B4(a1, a2, a3);
      sub_41C395(a1, a2, a3);
      return 1LL;
    }
LABEL_13:
    if ( sub_40649F((__int64)a1, 0) )
    {
      sub_407963(a1, a2, a3);
    }
    else
    {
      sub_404FD6(a1, a2, a3);
      sub_408725(a1, -1, a2, a3);
    }
    if ( sub_40649F((__int64)a1, 1) )
    {
      sub_407963(a1, a2, a3);
    }
    else
    {
      sub_404FDD(a1, a2, a3);
      sub_408725(a1, -1, a2, a3);
    }
    goto LABEL_19;
  }
  sub_404FD6(a1, a2, a3);
  return 1LL;
}

//----- (000000000042BBFD) ----------------------------------------------------
__int64 __fastcall sub_42BBFD(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_42BAB2(a1, a2, a3);
  sub_42E2A2(a1, a2, a3);
  return 1LL;
}

//----- (000000000042BC1E) ----------------------------------------------------
__int64 __fastcall sub_42BC1E(__int64 *a1, __m128 a2, __m128 a3)
{
  _BOOL4 v3; // eax

  sub_42BAB2(a1, a2, a3);
  sub_42E2A2(a1, a2, a3);
  v3 = sub_4064B3((__int64)a1, -1);
  sub_406955(a1, !v3, a2, a3);
  return 1LL;
}

//----- (000000000042BC5A) ----------------------------------------------------
__int64 __fastcall sub_42BC5A(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_406FB2(a1, a2, a3);
  sub_406EC3(a1, (__int64)"/", 1uLL, a2, a3);
  sub_40377C(a1, 0, 0x2Cu, a2, a3);
  sub_404FF1(a1, a2, a3);
  sub_40377C(a1, 0, 0x30u, a2, a3);
  sub_408E52(a1, 4, a2, a3);
  return 1LL;
}

//----- (000000000042BCB8) ----------------------------------------------------
__int64 __fastcall sub_42BCB8(__int64 *a1, __m128 a2, __m128 a3)
{
  char *v3; // rbx
  __int64 v4; // rdx
  char v6; // [rsp+8h] [rbp-18h] BYREF
  char v7; // [rsp+9h] [rbp-17h] BYREF

  v3 = &v6;
  sub_406FB2(a1, a2, a3);
  sub_40582D(a1, -1, a2, a3);
  if ( (unsigned int)sub_4037C1(a1, 0, 0x1Bu, 0LL, a2, a3) )
  {
    v3 = &v7;
    v6 = 103;
  }
  if ( (unsigned int)sub_4037C1(a1, 0, 0x2Du, 0LL, a2, a3) )
    *v3++ = 105;
  if ( (unsigned int)sub_4037C1(a1, 0, 0x2Eu, 0LL, a2, a3) )
    *v3++ = 109;
  *v3 = 0;
  sub_406D71(a1, (__int64)&v6, v4, a2, a3);
  return 1LL;
}
// 42BD37: variable 'v4' is possibly undefined

//----- (000000000042BD48) ----------------------------------------------------
__int64 __fastcall sub_42BD48(__int64 *a1, __m128 a2, __m128 a3)
{
  _DWORD *v3; // rbx
  unsigned int v4; // er13
  char v5; // bl
  __int64 v6; // rdx
  __int64 v7; // rcx
  int v8; // esi

  sub_406FB2(a1, a2, a3);
  v3 = (_DWORD *)sub_40582D(a1, -1, a2, a3);
  v4 = sub_41DCD3((__int64)a1);
  if ( *v3 >> 27 != 11 )
  {
    if ( (_DWORD *)a1[38] == v3 )
    {
      if ( v4 == 16 )
      {
        sub_406EC3(a1, (__int64)"(?:)", 4uLL, a2, a3);
        return 1;
      }
    }
    else
    {
      sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_regexp.c", 189, a2, a3);
    }
    return 0;
  }
  sub_403883(a1, 101, a2, a3);
  sub_403883(a1, 98, a2, a3);
  v5 = *(_BYTE *)(sub_40574F(a1, -1, a2, a3) + 32);
  sub_407D7E(a1, 0xFFFFFFFFLL, v6, v7, a2, a3);
  if ( v4 == 1 )
  {
    sub_406955(a1, v5 & 2, a2, a3);
    return v4;
  }
  if ( v4 == 2 )
  {
    v8 = v5 & 4;
  }
  else
  {
    if ( v4 )
      return 1;
    v8 = v5 & 1;
  }
  sub_406955(a1, v8, a2, a3);
  return 1;
}
// 42BDA8: variable 'v6' is possibly undefined
// 42BDA8: variable 'v7' is possibly undefined

//----- (000000000042BE33) ----------------------------------------------------
__int64 __fastcall sub_42BE33(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // ebx
  int v5; // er13
  unsigned int v6; // er15
  int v8; // eax
  unsigned int v9; // er15
  unsigned int v10; // [rsp+Ch] [rbp-54h] BYREF
  _BYTE *v11[2]; // [rsp+10h] [rbp-50h] BYREF
  __int64 v12; // [rsp+20h] [rbp-40h]

  v4 = 0;
  v5 = sub_404AE7((__int64)a1);
  sub_41CF97(a1, v11, v5, a3, a4);
  while ( v4 < v5 )
  {
    if ( a2 )
    {
      v10 = 0;
      sub_405C43(a1, v4, a3, a4);
      if ( !(unsigned int)sub_41D5D5((int *)&v10, *(double *)a3.i64) || (v6 = v10, v10 > 0x10FFFF) )
      {
        sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_string.c", 201, "invalid args", a3, a4);
        return 0LL;
      }
      if ( v12 - (unsigned __int64)v11[0] <= 5 )
        sub_41CFE2(a1, v11, 6LL, a3, a4);
      v8 = sub_41C6FA(v6, v11[0]);
    }
    else
    {
      v9 = sub_405E64(a1, v4, a3, a4);
      if ( v12 - (unsigned __int64)v11[0] <= 6 )
        sub_41CFE2(a1, v11, 7LL, a3, a4);
      v8 = sub_41C531(v9, v11[0]);
    }
    ++v4;
    v11[0] += v8;
  }
  sub_41D054(a1, v11, a3, a4);
  sub_406BF4(a1, -1, a3, a4);
  return 1LL;
}

//----- (000000000042BF57) ----------------------------------------------------
__int64 __fastcall sub_42BF57(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, int a5, __m128 a6, __m128 a7)
{
  int v8; // ecx
  char *v10; // rbx
  unsigned __int64 v11; // r13
  char v12; // cl
  char v13; // cl
  int v14; // eax
  int v16; // [rsp+Ch] [rbp-44h]
  char v17; // [rsp+Ch] [rbp-44h]
  char v19; // [rsp+17h] [rbp-39h]
  unsigned __int64 v20; // [rsp+18h] [rbp-38h]

  v8 = *(_DWORD *)(a3 + 24);
  v16 = v8;
  if ( v8 > 0 )
  {
    v10 = (char *)(a2 + 32 + (int)sub_40D015(a1, a2, a4, v8, a6, a7));
    v11 = v16;
    v19 = *(_BYTE *)(a3 + 32);
    v20 = a2 + 32 + *(unsigned int *)(a2 + 24);
    while ( (unsigned __int64)v10 <= v20 && (unsigned __int64)v10 >= a2 + 32 )
    {
      v12 = *v10;
      if ( v19 == *v10 && v20 - (unsigned __int64)v10 >= v11 )
      {
        v17 = *v10;
        v14 = sub_41D6AC(v10, a3 + 32);
        v12 = v17;
        if ( !v14 )
          return a4;
      }
      v13 = v12 & 0xC0;
      if ( a5 )
      {
        if ( v13 != (char)0x80 )
          --a4;
        --v10;
      }
      else
      {
        if ( v13 != (char)0x80 )
          ++a4;
        ++v10;
      }
    }
    return (unsigned int)-1;
  }
  return a4;
}
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);

//----- (000000000042C020) ----------------------------------------------------
__int64 __fastcall sub_42C020(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v6; // [rsp-8h] [rbp-10h]

  v6 = v3;
  sub_407CED(a1, 17, a2, a3);
  sub_404F0A(a1, 0, a2, a3);
  sub_41DBF3(a1, 1, a2, a3);
  return sub_405057(a1, 0, v6, v4, *(double *)a2.i64, a3);
}
// 42C02E: variable 'v3' is possibly undefined
// 42C054: variable 'v4' is possibly undefined

//----- (000000000042C059) ----------------------------------------------------
__int64 __fastcall sub_42C059(__int64 *a1, __m128 a2, __m128 a3)
{
  if ( (unsigned int)sub_4060B0((__int64)a1, 0) != 11 )
    return sub_408998(a1, 0, a2, a3);
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_string.c", 31, a2, a3);
  return 0LL;
}

//----- (000000000042C090) ----------------------------------------------------
__int64 __fastcall sub_42C090(__int64 *a1, __m128 a2, __m128 a3)
{
  const signed __int32 *v3; // r13
  __int64 v4; // rdx
  __int64 v5; // rcx

  if ( (unsigned int)sub_404AE7((__int64)a1) )
  {
    v3 = sub_408A2B(a1, 0, a2, a3);
    if ( _bittest(v3, 9u) && !(unsigned int)sub_41DC85((__int64)a1) )
    {
      sub_408C36(a1, (__int64)v3, a2, a3);
      sub_405057(a1, 0, v4, v5, *(double *)a2.i64, a3);
    }
  }
  else
  {
    sub_407963(a1, a2, a3);
  }
  sub_408725(a1, 0, a2, a3);
  sub_404B20(a1, 1u, a2, a3);
  if ( (unsigned int)sub_41DC85((__int64)a1) )
  {
    sub_407003(a1, 1619017856, 10, a2, a3);
    sub_404FD6(a1, a2, a3);
    sub_403E13(a1, -33527296, a2, a3);
  }
  return 1LL;
}
// 42C0DD: variable 'v4' is possibly undefined
// 42C0DD: variable 'v5' is possibly undefined

//----- (000000000042C137) ----------------------------------------------------
__int64 __fastcall sub_42C137(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_42BE33(a1, 0, a2, a3);
}

//----- (000000000042C148) ----------------------------------------------------
__int64 __fastcall sub_42C148(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax

  sub_406FB2(a1, a2, a3);
  v3 = sub_404A12(a1, -1);
  if ( *(_DWORD *)v3 == 8 )
    goto LABEL_5;
  if ( *(_DWORD *)v3 == 9 && **(_DWORD **)(v3 + 8) >> 27 == 12 )
  {
    sub_403883(a1, -65430, a2, a3);
LABEL_5:
    sub_4057BB(a1, -1, a2, a3);
    return 1LL;
  }
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_string.c", 274, a2, a3);
  return 0LL;
}

//----- (000000000042C1B4) ----------------------------------------------------
__int64 __fastcall sub_42C1B4(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  sub_408A0E(a1, a2, a3);
  v3 = sub_405DB7(a1, 0, a2, a3);
  sub_409057(a1, -1, v3, v3 + 1LL, a2, a3);
  return 1LL;
}

//----- (000000000042C1E9) ----------------------------------------------------
__int64 __fastcall sub_42C1E9(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  __int64 v5; // rdx
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // er14
  __int64 v9; // rdx
  int v10; // ecx
  __int64 result; // rax
  int v12; // eax
  int v13[9]; // [rsp+Ch] [rbp-24h] BYREF

  v4 = sub_408A0E(a1, a3, a4);
  v7 = sub_40314F(v4, a2, v5, v6);
  v8 = sub_405FB5(a1, 0, 0, v7 - 1, v13, a3, a4);
  v10 = sub_41DCD3((__int64)a1);
  if ( v13[0] )
  {
    result = 0LL;
    if ( v10 )
      return result;
    sub_406B26(a1, 0LL, v9, a3, a4);
  }
  else
  {
    v12 = sub_41176B(a1, v4, v8, v10, a3, a4);
    sub_406AAF(a1, v12, a3, a4);
  }
  return 1LL;
}
// 42C205: variable 'v5' is possibly undefined
// 42C205: variable 'v6' is possibly undefined
// 42C239: variable 'v9' is possibly undefined
// 42C1E9: using guessed type int var_24[9];

//----- (000000000042C269) ----------------------------------------------------
__int64 __fastcall sub_42C269(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  int v6; // ecx
  int v7; // er14
  int v8; // ebx
  int v9; // er12
  int v10; // eax

  v4 = sub_408A0E(a1, a3, a4);
  v7 = sub_40314F(v4, a2, v5, v6);
  v8 = v7;
  v9 = sub_406077(a1, 0, 0, v7, a3, a4);
  if ( !sub_40649F((__int64)a1, 1) )
    v8 = sub_406077(a1, 1, 0, v7, a3, a4);
  if ( v8 < v9 )
  {
    v10 = v9;
    v9 = v8;
    v8 = v10;
  }
  sub_409057(a1, -1, v9, v8, a3, a4);
  return 1LL;
}
// 42C27F: variable 'v5' is possibly undefined
// 42C27F: variable 'v6' is possibly undefined

//----- (000000000042C2EB) ----------------------------------------------------
__int64 __fastcall sub_42C2EB(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  int v6; // ecx
  int v7; // er12
  int v8; // er14
  int v9; // ebx

  sub_406FB2(a1, a3, a4);
  v4 = sub_4089F1(a1, a3, a4);
  v7 = sub_40314F(v4, a2, v5, v6);
  v8 = v7;
  v9 = sub_406077(a1, 0, -v7, v7, a3, a4);
  if ( v9 < 0 )
    v9 += v7;
  if ( !sub_40649F((__int64)a1, 1) )
    v8 = sub_406077(a1, 1, 0, v7 - v9, a3, a4) + v9;
  sub_409057(a1, -1, v9, v8, a3, a4);
  return 1LL;
}
// 42C309: variable 'v5' is possibly undefined
// 42C309: variable 'v6' is possibly undefined

//----- (000000000042C375) ----------------------------------------------------
__int64 __fastcall sub_42C375(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  int v6; // ecx
  int v7; // eax
  int v8; // er15
  int v9; // er14
  int v10; // ebx
  int v11; // er13

  v4 = sub_408A0E(a1, a3, a4);
  v7 = sub_40314F(v4, a2, v5, v6);
  v8 = -v7;
  v9 = v7;
  v10 = v7;
  v11 = sub_406077(a1, 0, -v7, v7, a3, a4);
  if ( v11 < 0 )
    v11 += v9;
  if ( !sub_40649F((__int64)a1, 1) )
  {
    v10 = sub_406077(a1, 1, v8, v9, a3, a4);
    if ( v10 < 0 )
      v10 += v9;
  }
  if ( v11 >= v10 )
    v10 = v11;
  sub_409057(a1, -1, v11, v10, a3, a4);
  return 1LL;
}
// 42C38E: variable 'v5' is possibly undefined
// 42C38E: variable 'v6' is possibly undefined

//----- (000000000042C40D) ----------------------------------------------------
__int64 __fastcall sub_42C40D(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13

  v3 = sub_41DCD3((__int64)a1);
  sub_408A0E(a1, a2, a3);
  sub_41CB8C(a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042C43E) ----------------------------------------------------
__int64 __fastcall sub_42C43E(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // ebx
  __int64 v5; // r13
  __int64 v6; // rdx
  int v7; // ecx
  unsigned int v8; // er14
  __int64 v9; // r15
  int v10; // eax
  int v11; // eax

  v4 = sub_41DCD3((__int64)a1);
  v5 = sub_408A0E(a1, a3, a4);
  v8 = sub_40314F(v5, a2, v6, v7);
  v9 = sub_408998(a1, 0, a3, a4);
  sub_405C43(a1, 1, a3, a4);
  v10 = sub_4064EF((__int64)a1, 1);
  if ( !v4 || !v10 )
    v8 = sub_406077(a1, 1, 0, v8, a3, a4);
  v11 = sub_42BF57(a1, v5, v9, v8, v4, a3, a4);
  sub_406A68(a1, v11, a3, a4);
  return 1LL;
}
// 42C467: variable 'v6' is possibly undefined
// 42C467: variable 'v7' is possibly undefined

//----- (000000000042C4EA) ----------------------------------------------------
__int64 __fastcall sub_42C4EA(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r14
  __int64 v10; // rdx
  __int64 v11; // rcx
  int v12; // er13
  __int64 v13; // rdx
  __int64 v14; // rcx
  int v15; // ecx
  __int64 v16; // r14
  __int64 v17; // rax
  __int64 v18; // rdx
  _BYTE *v19; // r15
  __int64 v20; // r13
  unsigned __int64 v21; // r14
  int v22; // eax
  __int64 v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rcx
  unsigned int v26; // er8
  unsigned __int64 v27; // r15
  int v28; // er14
  int v29; // er15
  int v30; // edx
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  unsigned __int64 v35; // r13
  __int64 v36; // r14
  unsigned __int8 *v37; // r13
  int v38; // er8
  unsigned __int8 *v39; // rax
  int v40; // eax
  unsigned __int64 v41; // r15
  int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // er8
  __int64 v45; // r9
  unsigned int v46; // eax
  int v47; // edx
  int v48; // er15
  int v49; // ecx
  int v50; // ecx
  __int64 v51; // rdx
  __int64 v52; // rcx
  __int64 v53; // rax
  unsigned __int64 v54; // r13
  _BYTE *v55; // rax
  unsigned int v56; // er14
  __int64 v57; // rbx
  __int64 v59; // [rsp+0h] [rbp-90h]
  __int64 v60; // [rsp+0h] [rbp-90h]
  int v61; // [rsp+0h] [rbp-90h]
  unsigned __int8 *v62; // [rsp+8h] [rbp-88h]
  unsigned int v63; // [rsp+8h] [rbp-88h]
  __int64 v64; // [rsp+10h] [rbp-80h]
  unsigned int v65; // [rsp+10h] [rbp-80h]
  unsigned __int8 *v66; // [rsp+18h] [rbp-78h]
  unsigned __int64 v67; // [rsp+20h] [rbp-70h]
  int v68; // [rsp+28h] [rbp-68h]
  _BOOL4 v69; // [rsp+2Ch] [rbp-64h]
  int v70; // [rsp+30h] [rbp-60h]
  unsigned int v71; // [rsp+34h] [rbp-5Ch]
  unsigned int v72; // [rsp+38h] [rbp-58h]
  int v73; // [rsp+3Ch] [rbp-54h]
  __int64 v74[2]; // [rsp+40h] [rbp-50h] BYREF
  __int64 v75; // [rsp+50h] [rbp-40h]

  v3 = sub_408A0E(a1, a2, a3);
  sub_41CF97(a1, v74, *(unsigned int *)(v3 + 24), a2, a3);
  if ( sub_405AC3((__int64)a1, 0) )
  {
    v68 = sub_4037C1(a1, 0, 0x1Bu, 0LL, a2, a3);
    v70 = 1;
    if ( v68 )
    {
      sub_406A68(a1, 0, a2, a3);
      sub_403A07(a1, 47, a2, a3);
    }
  }
  else
  {
    sub_408725(a1, 0, a2, a3);
    v68 = 0;
    v70 = 0;
  }
  v69 = sub_4065F2((__int64)a1, 1);
  if ( v69 )
  {
    v67 = 0LL;
    v66 = 0LL;
    v69 = 1;
  }
  else
  {
    v4 = sub_408998(a1, 1, a2, a3);
    v66 = (unsigned __int8 *)(v4 + 32);
    v67 = v4 + 32 + *(unsigned int *)(v4 + 24);
  }
  v72 = 0;
  while ( !v70 )
  {
    v16 = *(unsigned int *)(v3 + 24);
    v17 = sub_405B3C((__int64)a1, 0);
    v18 = *(unsigned int *)(v17 + 24);
    v19 = (_BYTE *)(v3 + 32);
    v20 = v17 + 32;
    v71 = 0;
    v21 = v3 + 32 + v16 - v18;
    while ( 1 )
    {
      if ( (unsigned __int64)v19 > v21 )
        goto LABEL_82;
      v64 = v18;
      v22 = sub_41D6AC(v19, v20);
      v18 = v64;
      v73 = v22;
      if ( !v22 )
        break;
      if ( (*v19 & 0xC0) != 0x80 )
        ++v71;
      ++v19;
    }
    sub_404FD6(a1, a2, a3);
    v9 = sub_405B3C((__int64)a1, -1);
LABEL_22:
    v23 = v3;
    v65 = sub_40D015(a1, v3, v71, v15, a2, a3);
    v26 = v65 - v72;
    v27 = v65 - v72;
    if ( v27 > v75 - v74[0] )
    {
      v23 = (__int64)v74;
      sub_41CFE2(a1, v74, v26, a2, a3);
      v26 = v65 - v72;
    }
    if ( v26 )
    {
      v23 = v3 + v72 + 32;
      sub_43AAA0(v74[0], v23, v27);
    }
    v74[0] += v27;
    v72 = *(_DWORD *)(v9 + 24) + v65;
    if ( !v69 )
    {
      v37 = v66;
      while ( 1 )
      {
        while ( 1 )
        {
          if ( (unsigned __int64)v37 >= v67 )
            goto LABEL_81;
          v38 = *v37;
          v39 = v37 + 1;
          v62 = v37 + 1;
          if ( v38 != 36 )
            goto LABEL_78;
          v23 = v67 - (_QWORD)v39;
          if ( (unsigned __int8 *)v67 == v39 )
            goto LABEL_78;
          v40 = v37[1];
          if ( (_BYTE)v40 != 39 )
            break;
          v42 = sub_40314F(v9, v23, v24, v25);
          v23 = v3;
          v43 = sub_40D015(a1, v3, v71 + v42, v71, a2, a3);
          v44 = *(_DWORD *)(v3 + 24) - v43;
          v45 = v3 + v43 + 32;
          v41 = v44;
          if ( v44 > (unsigned __int64)(v75 - v74[0]) )
          {
            v23 = (__int64)v74;
            v59 = v3 + v43 + 32;
            v63 = *(_DWORD *)(v3 + 24) - v43;
            sub_41CFE2(a1, v74, v44, a2, a3);
            v45 = v59;
            v44 = v63;
          }
          if ( v44 )
          {
            v23 = v45;
            sub_43AAA0(v74[0], v45, v41);
          }
LABEL_60:
          v74[0] += v41;
          v37 += 2;
        }
        if ( (unsigned __int8)v40 > 0x27u )
        {
          if ( (_BYTE)v40 == 96 )
          {
            v41 = v65;
            if ( v65 > (unsigned __int64)(v75 - v74[0]) )
            {
              v23 = (__int64)v74;
              sub_41CFE2(a1, v74, v65, a2, a3);
            }
            if ( v65 )
            {
              v23 = v3 + 32;
              sub_43AAA0(v74[0], v3 + 32, v65);
            }
            goto LABEL_60;
          }
          if ( !v70 )
            goto LABEL_78;
          v46 = v40 - 48;
          if ( v46 > 9 )
            goto LABEL_78;
          --v23;
          v47 = v46;
          v48 = 1;
          if ( v23 )
          {
            v49 = v37[2];
            v23 = (unsigned int)(v49 - 48);
            if ( (unsigned int)v23 <= 9 )
            {
              v50 = v49 + 10 * v46 - 48;
              if ( v73 > v50 )
                v46 = v50;
              v47 = v46;
              v48 = (v73 > v50) + 1;
            }
          }
          if ( v47 <= 0 || v47 >= v73 )
            goto LABEL_78;
          sub_40370E(a1, 4, v47, a2, a3);
          v23 = 0xFFFFFFFFLL;
          if ( sub_406515((__int64)a1, -1) )
          {
            v53 = sub_405B3C((__int64)a1, -1);
            v54 = *(unsigned int *)(v53 + 24);
            v52 = v53;
            if ( v54 > v75 - v74[0] )
            {
              v60 = v53;
              sub_41CFE2(a1, v74, v54, a2, a3);
              v52 = v60;
            }
            v23 = v52 + 32;
            if ( v54 )
              sub_43AAA0(v74[0], v23, v54);
            v74[0] += v54;
          }
          sub_407D7E(a1, v23, v51, v52, a2, a3);
          v37 = &v62[v48];
        }
        else
        {
          if ( (_BYTE)v40 == 36 )
          {
            v38 = 292;
            goto LABEL_78;
          }
          if ( (_BYTE)v40 == 38 )
          {
            v41 = *(unsigned int *)(v9 + 24);
            if ( v41 > v75 - v74[0] )
              sub_41CFE2(a1, v74, *(unsigned int *)(v9 + 24), a2, a3);
            v23 = v9 + 32;
            if ( v41 )
              sub_43AAA0(v74[0], v23, v41);
            goto LABEL_60;
          }
LABEL_78:
          if ( v75 == v74[0] )
          {
            v23 = (__int64)v74;
            v61 = v38;
            sub_41CFE2(a1, v74, 1LL, a2, a3);
            v38 = v61;
          }
          v55 = (_BYTE *)v74[0];
          v24 = ++v74[0];
          *v55 = v38;
          v25 = v38 >> 8;
          v37 = &v62[v25];
        }
      }
    }
    sub_404FDD(a1, a2, a3);
    v28 = sub_404AE7((__int64)a1);
    if ( v70 )
    {
      v29 = 0;
      sub_404E3A(a1, v73 + 2, a2, a3);
      while ( v29 < v73 )
      {
        v30 = v29++;
        sub_40370E(a1, 4, v30, a2, a3);
      }
    }
    else
    {
      sub_404FD6(a1, a2, a3);
    }
    sub_406AAF(a1, v71, a2, a3);
    sub_404FE7(a1, a2, a3);
    v31 = sub_404AE7((__int64)a1);
    sub_41DA2F(a1, v31 - v28, a2, a3);
    v32 = sub_4089F1(a1, a2, a3);
    v35 = *(unsigned int *)(v32 + 24);
    v36 = v32;
    if ( v35 > v75 - v74[0] )
      sub_41CFE2(a1, v74, v35, a2, a3);
    v23 = v36 + 32;
    if ( v35 )
      sub_43AAA0(v74[0], v23, v35);
    v74[0] += v35;
    sub_407D7E(a1, v23, v33, v34, a2, a3);
LABEL_81:
    sub_407D7E(a1, v23, v24, v25, a2, a3);
    if ( !v68 )
      goto LABEL_82;
  }
  sub_404FD6(a1, a2, a3);
  sub_404FE7(a1, a2, a3);
  sub_42E2A2(a1, a2, a3);
  if ( sub_40653D((__int64)a1, -1) )
  {
    sub_4037B9(a1, -65487, a2, a3);
    v71 = sub_40548C(a1, -1, a2, a3);
    sub_407D7E(a1, 0xFFFFFFFFLL, v7, v8, a2, a3);
    sub_40370E(a1, -1, 0, a2, a3);
    v9 = sub_405B3C((__int64)a1, -1);
    sub_407D7E(a1, 0xFFFFFFFFLL, v10, v11, a2, a3);
    if ( !*(_DWORD *)(v9 + 24) )
    {
      sub_4037B9(a1, 47, a2, a3);
      v12 = sub_40548C(a1, -1, a2, a3);
      sub_407D7E(a1, 0xFFFFFFFFLL, v13, v14, a2, a3);
      sub_406AAF(a1, v12 + 1, a2, a3);
      sub_403A07(a1, 47, a2, a3);
    }
    v73 = sub_405CB0(a1, 0xFFFFFFFF, a2, a3);
    goto LABEL_22;
  }
  sub_407D7E(a1, 0xFFFFFFFFLL, v5, v6, a2, a3);
LABEL_82:
  v56 = *(_DWORD *)(v3 + 24) - v72;
  v57 = v3 + v72 + 32;
  if ( v56 > (unsigned __int64)(v75 - v74[0]) )
    sub_41CFE2(a1, v74, v56, a2, a3);
  if ( v56 )
    sub_43AAA0(v74[0], v57, v56);
  v74[0] += v56;
  sub_41D054(a1, v74, a2, a3);
  sub_406BF4(a1, -1, a2, a3);
  return 1LL;
}
// 42C600: variable 'v5' is possibly undefined
// 42C600: variable 'v6' is possibly undefined
// 42C628: variable 'v7' is possibly undefined
// 42C628: variable 'v8' is possibly undefined
// 42C64B: variable 'v10' is possibly undefined
// 42C64B: variable 'v11' is possibly undefined
// 42C675: variable 'v13' is possibly undefined
// 42C675: variable 'v14' is possibly undefined
// 42C71F: variable 'v15' is possibly undefined
// 42C845: variable 'v33' is possibly undefined
// 42C845: variable 'v34' is possibly undefined
// 42C929: variable 'v24' is possibly undefined
// 42C929: variable 'v25' is possibly undefined
// 42CA7B: variable 'v51' is possibly undefined
// 42CA7B: variable 'v52' is possibly undefined
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);

//----- (000000000042CB67) ----------------------------------------------------
__int64 __fastcall sub_42CB67(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // r13
  _BOOL4 v4; // eax
  char v5; // r15
  int v6; // edx
  __int64 v7; // rdx
  __int64 v8; // rcx
  int v9; // er14
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rbx
  int v13; // ecx
  int v14; // er15
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rdx
  int v18; // ecx
  __int64 v19; // rdx
  __int64 v20; // rcx
  int v21; // ecx
  unsigned int v22; // ebx
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // rbx
  int v28; // ecx
  _BYTE *v29; // rcx
  unsigned __int64 v30; // rbx
  int v31; // eax
  int v32; // ecx
  int v33; // er15
  unsigned __int64 v34; // rdx
  __int64 v35; // rdx
  unsigned __int64 v36; // rcx
  __int64 v37; // rsi
  __int64 v38; // rax
  int v39; // edx
  _BYTE *v41; // [rsp+8h] [rbp-68h]
  __int64 v42; // [rsp+10h] [rbp-60h]
  __int64 v43; // [rsp+10h] [rbp-60h]
  unsigned int v44; // [rsp+1Ch] [rbp-54h]
  __int64 v45; // [rsp+20h] [rbp-50h]
  unsigned int v46; // [rsp+28h] [rbp-48h]
  unsigned __int64 v47; // [rsp+28h] [rbp-48h]
  unsigned int v48; // [rsp+30h] [rbp-40h]
  int v49; // [rsp+34h] [rbp-3Ch]
  unsigned int v50; // [rsp+38h] [rbp-38h]
  unsigned __int64 v51; // [rsp+38h] [rbp-38h]

  v3 = sub_408A0E(a1, a2, a3);
  sub_4070BA(a1, a2, a3);
  if ( sub_40649F((__int64)a1, 1) )
  {
    v48 = -1;
  }
  else
  {
    v48 = sub_405E64(a1, 1, a2, a3);
    if ( !v48 )
      return 1LL;
  }
  v4 = sub_40649F((__int64)a1, 0);
  v5 = v4;
  if ( v4 )
  {
    sub_404FE7(a1, a2, a3);
    v6 = 0;
LABEL_41:
    sub_403953(a1, 3, v6, a2, a3);
    return 1LL;
  }
  if ( sub_405AC3((__int64)a1, 0) )
  {
    sub_407CED(a1, 17, a2, a3);
    sub_404FD6(a1, a2, a3);
    sub_41DBF3(a1, 1, a2, a3);
    sub_405057(a1, 0, v7, v8, *(double *)a2.i64, a3);
    v49 = 1;
  }
  else
  {
    sub_408725(a1, 0, a2, a3);
    v49 = 0;
  }
  v50 = 0;
  v9 = 0;
  v45 = v3 + 32;
  while ( 1 )
  {
    if ( v49 )
    {
      sub_404FD6(a1, a2, a3);
      sub_404FE7(a1, a2, a3);
      sub_42E2A9(a1, a2, a3);
      if ( !sub_40653D((__int64)a1, -1) )
      {
        sub_407D7E(a1, 0xFFFFFFFFLL, v10, v11, a2, a3);
        goto LABEL_38;
      }
      sub_4037B9(a1, -65487, a2, a3);
      v12 = (unsigned int)sub_40548C(a1, -1, a2, a3);
      v14 = sub_40D015(a1, v3, v12, v13, a2, a3);
      sub_407D7E(a1, v3, v15, v16, a2, a3);
      if ( v12 == sub_40314F(v3, v3, v17, v18) )
      {
        sub_407D7E(a1, v3, v19, v20, a2, a3);
        v5 = v49;
        goto LABEL_38;
      }
      sub_4037B9(a1, 47, a2, a3);
      v46 = sub_40548C(a1, -1, a2, a3);
      v22 = sub_40D015(a1, v3, v46, v21, a2, a3);
      sub_407D7E(a1, v3, v23, v24, a2, a3);
      if ( v50 == v22 )
      {
        sub_406AAF(a1, v46 + 1, a2, a3);
        sub_403A07(a1, 47, a2, a3);
        sub_407D7E(a1, 47LL, v25, v26, a2, a3);
LABEL_29:
        v33 = v9;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
    v27 = *(unsigned int *)(v3 + 24);
    v42 = sub_405B3C((__int64)a1, 0);
    v44 = *(_DWORD *)(v42 + 24);
    sub_40314F(v42, 0LL, v42, v28);
    v29 = (_BYTE *)(v45 + v50);
    v30 = v45 + v27 - v44;
    if ( v44 )
      break;
    do
    {
      if ( (unsigned __int64)++v29 >= v30 )
      {
        v5 = 1;
        goto LABEL_38;
      }
    }
    while ( (*v29 & 0xC0) == 0x80 );
LABEL_27:
    v32 = (_DWORD)v29 - v45;
    v22 = v32 + v44;
    v14 = v32;
    if ( v50 == v32 + v44 )
    {
      ++v22;
      goto LABEL_29;
    }
LABEL_31:
    v34 = v14 - v50;
    v33 = v9 + 1;
    sub_406B69(a1, v3 + v50 + 32, v34, a2, a3);
    sub_403953(a1, 3, v9, a2, a3);
    if ( v48 <= v9 + 1 )
    {
      if ( v49 )
LABEL_36:
        sub_407D7E(a1, 3LL, v35, v36, a2, a3);
      return 1LL;
    }
    if ( v49 )
    {
      v37 = 4LL;
      v38 = sub_405CB0(a1, 4u, a2, a3);
      v36 = 1LL;
      v51 = v38;
      while ( 1 )
      {
        v33 = v9 + v36;
        if ( v51 <= v36 )
          break;
        v47 = v36;
        sub_40370E(a1, 4, v36, a2, a3);
        v37 = 3LL;
        sub_403953(a1, 3, v33, a2, a3);
        v36 = v47 + 1;
        if ( v9 + (int)v47 + 1 >= v48 )
          goto LABEL_36;
      }
      sub_407D7E(a1, v37, v35, v36, a2, a3);
    }
LABEL_30:
    v9 = v33;
    v50 = v22;
    v5 = 1;
  }
  v43 = v42 + 32;
  while ( (unsigned __int64)v29 <= v30 )
  {
    v41 = v29;
    v31 = sub_41D6AC(v29, v43);
    LODWORD(v29) = (_DWORD)v41;
    if ( !v31 )
      goto LABEL_27;
    v29 = v41 + 1;
  }
LABEL_38:
  v39 = *(_DWORD *)(v3 + 24);
  if ( v39 || (v5 & 1) == 0 )
  {
    sub_406B69(a1, v3 + v50 + 32, v39 - v50, a2, a3);
    v6 = v9;
    goto LABEL_41;
  }
  return 1LL;
}
// 42CC17: variable 'v7' is possibly undefined
// 42CC17: variable 'v8' is possibly undefined
// 42CC7C: variable 'v10' is possibly undefined
// 42CC7C: variable 'v11' is possibly undefined
// 42CCA8: variable 'v13' is possibly undefined
// 42CCB3: variable 'v15' is possibly undefined
// 42CCB3: variable 'v16' is possibly undefined
// 42CCBB: variable 'v17' is possibly undefined
// 42CCBB: variable 'v18' is possibly undefined
// 42CCC8: variable 'v19' is possibly undefined
// 42CCC8: variable 'v20' is possibly undefined
// 42CCF9: variable 'v21' is possibly undefined
// 42CD03: variable 'v23' is possibly undefined
// 42CD03: variable 'v24' is possibly undefined
// 42CD2F: variable 'v25' is possibly undefined
// 42CD2F: variable 'v26' is possibly undefined
// 42CD66: variable 'v28' is possibly undefined
// 42CE88: variable 'v35' is possibly undefined
// 42CE88: variable 'v36' is possibly undefined
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);

//----- (000000000042CEE9) ----------------------------------------------------
__int64 __fastcall sub_42CEE9(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_408A0E(a1, a2, a3);
  sub_42C020(a1, a2, a3);
  sub_404FD6(a1, a2, a3);
  sub_404FDD(a1, a2, a3);
  sub_42E2A2(a1, a2, a3);
  if ( sub_40653D((__int64)a1, -1) )
    sub_4037B9(a1, -65487, a2, a3);
  else
    sub_406A68(a1, -1, a2, a3);
  return 1LL;
}

//----- (000000000042CF4B) ----------------------------------------------------
__int64 __fastcall sub_42CF4B(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // er13
  int v4; // er14
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rdx
  int v8; // ebx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx

  sub_408A0E(a1, a2, a3);
  if ( !sub_405AC3((__int64)a1, 0) )
    sub_42C020(a1, a2, a3);
  if ( (unsigned int)sub_4037C1(a1, 0, 0x1Bu, 0LL, a2, a3) )
  {
    v3 = 0;
    sub_406A68(a1, 0, a2, a3);
    v4 = 0;
    sub_403A07(a1, 47, a2, a3);
    sub_4070BA(a1, a2, a3);
    while ( 1 )
    {
      sub_404FD6(a1, a2, a3);
      sub_404FDD(a1, a2, a3);
      sub_42E2A2(a1, a2, a3);
      if ( !sub_40653D((__int64)a1, -1) )
        break;
      sub_4037B9(a1, 47, a2, a3);
      v8 = sub_405483(a1, -1, a2, a3);
      sub_407D7E(a1, 0xFFFFFFFFLL, v9, v10, a2, a3);
      if ( v4 == v8 )
      {
        sub_406A68(a1, ++v8, a2, a3);
        sub_403A07(a1, 47, a2, a3);
      }
      sub_40370E(a1, -1, 0, a2, a3);
      sub_403953(a1, 2, v3++, a2, a3);
      v4 = v8;
      sub_407D7E(a1, 2LL, v11, v12, a2, a3);
    }
    sub_407D7E(a1, 0xFFFFFFFFLL, v5, v6, a2, a3);
    if ( !v3 )
      sub_40691D(a1, 0xFFFFFFFFLL, v7, a2, a3);
  }
  else
  {
    sub_42E2A2(a1, a2, a3);
  }
  return 1LL;
}
// 42CFEB: variable 'v5' is possibly undefined
// 42CFEB: variable 'v6' is possibly undefined
// 42CFF8: variable 'v7' is possibly undefined
// 42D01C: variable 'v9' is possibly undefined
// 42D01C: variable 'v10' is possibly undefined
// 42D065: variable 'v11' is possibly undefined
// 42D065: variable 'v12' is possibly undefined

//----- (000000000042D07D) ----------------------------------------------------
__int64 __fastcall sub_42D07D(__int64 *a1, __m128 a2, __m128 a3)
{
  int v3; // eax

  sub_408A0E(a1, a2, a3);
  sub_40500F(a1, 0);
  v3 = sub_404AE7((__int64)a1);
  sub_408E52(a1, v3, a2, a3);
  return 1LL;
}

//----- (000000000042D0B2) ----------------------------------------------------
__int64 __fastcall sub_42D0B2(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_408A0E(a1, a2, a3);
  sub_4090EA(a1, 0, a2, a3);
  return 1LL;
}

//----- (000000000042D0D5) ----------------------------------------------------
__int64 __fastcall sub_42D0D5(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // rax
  unsigned __int64 v5; // r13
  __int64 v6; // rbx
  int v7; // eax
  unsigned __int64 v8; // r14
  __int64 v9; // rax
  __int64 v10; // rsi
  unsigned __int64 v11; // r14
  __int64 i; // rdi
  __int64 v14; // rax

  v4 = sub_408A0E(a1, a2, a3);
  v5 = *(unsigned int *)(v4 + 24);
  v6 = v4;
  sub_405C43(a1, 0, a2, a3);
  if ( sub_41D385(*(double *)a2.i64) || (v7 = sub_405483(a1, 0, a2, a3), v7 < 0) || (v8 = v5 * v7, v7) && v8 / v7 != v5 )
  {
    sub_401CE2(a1, (__int64)"third_party/duktape/duk_bi_string.c", 1480, "invalid args", a2, a3);
    return 0LL;
  }
  else
  {
    v9 = sub_4076DF(a1, v8, a2, a3);
    v10 = v6 + 32;
    v11 = v9 + v8;
    for ( i = v9; v5 < v11 - i; v5 = i - v14 )
    {
      sub_43AAA0(i, v10, v5);
      i += v5;
      v10 = v14;
    }
    sub_43AAA0(i, v10, v11 - i);
    sub_406BF4(a1, -1, a2, a3);
    return 1LL;
  }
}
// 42D16D: variable 'v14' is possibly undefined

//----- (000000000042D19A) ----------------------------------------------------
__int64 __fastcall sub_42D19A(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rax
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // r13
  int v7; // eax
  int v8; // esi

  v3 = sub_408A0E(a1, a2, a3);
  v4 = sub_408998(a1, 0, a2, a3);
  v5 = *(unsigned int *)(v3 + 24);
  v6 = *(unsigned int *)(v4 + 24);
  v7 = sub_41D6AC(v3 + 32, v4 + 32);
  v8 = -1;
  if ( v7 >= 0 )
  {
    if ( v7 || v5 > v6 )
      v8 = 1;
    else
      v8 = -(v5 != v6);
  }
  sub_406A68(a1, v8, a2, a3);
  return 1LL;
}
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);

//----- (000000000042D20E) ----------------------------------------------------
__int64 __fastcall sub_42D20E(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // r13
  int v6; // er15
  __int64 v7; // r14
  __int64 v8; // rdx
  int v9; // ecx
  unsigned __int64 v10; // rdi
  int v11; // eax
  __int64 v12; // rdx
  __int64 v13; // rcx
  int v14; // esi
  __int64 v16; // [rsp+8h] [rbp-38h]

  v4 = sub_408A0E(a1, a2, a3);
  v16 = sub_42C059(a1, a2, a3);
  v5 = v4 + 32;
  v6 = sub_41DCD3((__int64)a1);
  v7 = *(unsigned int *)(v16 + 24);
  if ( !sub_40649F((__int64)a1, 1) )
  {
    v11 = sub_40314F(v4, 1LL, v8, v9);
    v12 = (unsigned int)sub_406077(a1, 1, 0, v11, a2, a3);
    v13 = v4 + 32;
    if ( v6 )
      v13 = v5 - v7;
    v10 = v13 + (unsigned int)sub_40D015(a1, v4, v12, v13, a2, a3);
LABEL_7:
    if ( v10 < v5 )
      goto LABEL_8;
    goto LABEL_10;
  }
  if ( v6 )
  {
    v10 = v5 + *(unsigned int *)(v4 + 24) - v7;
    goto LABEL_7;
  }
  v10 = v4 + 32;
LABEL_10:
  if ( v7 + v10 - v5 <= *(unsigned int *)(v4 + 24) )
  {
    v14 = sub_41D6AC(v10, v16 + 32) == 0;
    goto LABEL_12;
  }
LABEL_8:
  v14 = 0;
LABEL_12:
  sub_406955(a1, v14, a2, a3);
  return 1LL;
}
// 42D271: variable 'v8' is possibly undefined
// 42D271: variable 'v9' is possibly undefined
// 41D6AC: using guessed type __int64 __fastcall sub_41D6AC(_QWORD, _QWORD);

//----- (000000000042D2FE) ----------------------------------------------------
__int64 __fastcall sub_42D2FE(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  __int64 v5; // r14
  __int64 v6; // rdx
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // eax
  int v10; // eax

  v4 = sub_408A0E(a1, a3, a4);
  v5 = sub_42C059(a1, a3, a4);
  v8 = sub_40314F(v4, a2, v6, v7);
  v9 = sub_406077(a1, 1, 0, v8, a3, a4);
  v10 = sub_42BF57(a1, v4, v5, v9, 0, a3, a4);
  sub_406955(a1, v10 >= 0, a3, a4);
  return 1LL;
}
// 42D322: variable 'v6' is possibly undefined
// 42D322: variable 'v7' is possibly undefined

//----- (000000000042D369) ----------------------------------------------------
const signed __int32 *__fastcall sub_42D369(__int64 *a1, __int64 a2)
{
  _DWORD *v2; // rsi
  __int64 v3; // rax
  const signed __int32 *result; // rax

  if ( *(_DWORD *)a2 != 9 )
  {
    if ( *(_DWORD *)a2 == 8 )
    {
      result = *(const signed __int32 **)(a2 + 8);
      if ( _bittest(result, 9u) )
        return result;
    }
    return 0LL;
  }
  v2 = *(_DWORD **)(a2 + 8);
  if ( *v2 >> 27 != 14 )
    return 0LL;
  v3 = sub_40E6B8(*a1, (__int64)v2);
  if ( !v3 )
    return 0LL;
  if ( *(_DWORD *)v3 != 8 )
    return 0LL;
  result = *(const signed __int32 **)(v3 + 8);
  if ( !_bittest(result, 9u) )
    return 0LL;
  return result;
}

//----- (000000000042D3B3) ----------------------------------------------------
__int64 __fastcall sub_42D3B3(__int64 *a1, __m128 a2, __m128 a3)
{
  int v4; // er15
  _BOOL4 v5; // eax
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 v8; // rdi
  _BYTE *v9; // r13
  _BYTE *v10; // rbx
  __int64 v11; // rax
  int v12; // ecx
  __int64 v14[7]; // [rsp+8h] [rbp-38h] BYREF

  v4 = sub_41DCD3((__int64)a1);
  v5 = sub_40649F((__int64)a1, 0);
  if ( v4 || !v5 )
  {
    v6 = sub_408821(a1, 0, v14, a2, a3);
  }
  else
  {
    v14[0] = 0LL;
    v6 = 0LL;
  }
  v7 = sub_40762B(a1, v14[0] + 20, 0, a2, a3);
  v8 = v7 + 1;
  v9 = (_BYTE *)v7;
  if ( v14[0] )
    sub_43AAA0(v8, v6, v14[0]);
  v10 = (_BYTE *)(v8 + v14[0]);
  if ( v4 )
  {
    *v9 = 0x80;
  }
  else
  {
    v11 = a1[8];
    v12 = *(_DWORD *)(v11 + 232) + 1;
    *(_DWORD *)(v11 + 232) = v12;
    if ( !v12 )
      ++*(_DWORD *)(v11 + 236);
    v10 += (int)sub_4390BD((__int64)v10, &sub_4424B4, *(unsigned int *)(v11 + 236));
    if ( !v6 )
      *v10++ = -1;
    *v9 = -127;
  }
  sub_406B69(a1, (__int64)v9, v10 - v9, a2, a3);
  return 1LL;
}
// 42D3B3: using guessed type unsigned __int64 var_38[7];

//----- (000000000042D4A7) ----------------------------------------------------
__int64 __fastcall sub_42D4A7(__int64 *a1, __m128 a2, __m128 a3)
{
  const signed __int32 *v3; // rsi
  __int64 result; // rax

  v3 = sub_42D369(a1 + 8, a1[13] - 16);
  result = 4294967290LL;
  if ( v3 )
  {
    if ( (unsigned int)sub_41DCD3((__int64)a1) )
      sub_407808(a1, (__int64)v3, a2, a3);
    else
      sub_408C36(a1, (__int64)v3, a2, a3);
    return 1LL;
  }
  return result;
}

//----- (000000000042D502) ----------------------------------------------------
__int64 __fastcall sub_42D502(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rax
  char v4; // dl
  __int64 result; // rax

  v3 = sub_40574F(a1, 0, a2, a3);
  v4 = *(_BYTE *)(v3 + 32);
  if ( v4 == (char)0x80 )
  {
    sub_406B69(a1, v3 + 33, (unsigned int)(*(_DWORD *)(v3 + 24) - 1), a2, a3);
    return 1LL;
  }
  else
  {
    if ( (unsigned __int8)(v4 + 127) <= 1u )
      return 0LL;
    result = 4294967290LL;
    if ( v4 == -1 )
      return 0LL;
  }
  return result;
}

//----- (000000000042D54A) ----------------------------------------------------
__int64 __fastcall sub_42D54A(__int64 *a1, __m128 a2, __m128 a3)
{
  const signed __int32 *v3; // rsi
  __int64 result; // rax

  v3 = sub_42D369(a1 + 8, a1[13] - 16);
  result = 4294967290LL;
  if ( v3 )
  {
    sub_407808(a1, (__int64)v3, a2, a3);
    return 1LL;
  }
  return result;
}

//----- (000000000042D584) ----------------------------------------------------
__int64 __fastcall sub_42D584(__int64 *a1, __m128 a2, __m128 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // r13
  __int64 v8; // rax

  v7 = sub_408496(a1, 0, 512LL, a6, a7, a2, a3);
  sub_40661B(a1, 0, a2, a3);
  sub_4071BC(a1, 0, a2, a3);
  v8 = sub_405B41((__int64)a1, -1);
  *(_BYTE *)(v8 + 73) = 1;
  sub_407C45((__int64 *)v8, v7, a2, a3);
  return 1LL;
}

//----- (000000000042D5D7) ----------------------------------------------------
__int64 __fastcall sub_42D5D7(__int64 *a1, __m128 a2, __m128 a3)
{
  __int64 v3; // rsi
  _DWORD *v4; // rbx
  int v5; // eax
  __int64 v6; // rdx
  int v7; // er13
  char v8; // al
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rax
  bool v13; // zf
  __int64 v14; // rcx
  __int64 v15; // rbx
  _DWORD *v16; // rsi
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  _DWORD *v21; // rsi

  v3 = 0LL;
  v4 = sub_4058D5(a1, 0, a2, a3);
  v5 = sub_405C10(a1, a2, a3);
  if ( (unsigned __int64)a1[16] > 1 )
  {
    v7 = v5;
    if ( (**(_DWORD **)(*(_QWORD *)(a1[15] + 24) + 16LL) & 0x800) != 0 )
    {
      v8 = *((_BYTE *)v4 + 73);
      if ( v8 == 1 )
      {
        if ( *((_QWORD *)v4 + 16) )
          goto LABEL_25;
        if ( *((_QWORD *)v4 + 14) - *((_QWORD *)v4 + 10) != 16LL )
          goto LABEL_25;
        sub_406883(a1, (__int128 *)(*((_QWORD *)v4 + 14) - 16LL), a2, a3);
        sub_41DD5D(a1, a2, a3);
        v3 = 0xFFFFFFFFLL;
        if ( (*(_DWORD *)sub_40582D(a1, -1, a2, a3) & 0xA00) != 2560 )
          goto LABEL_25;
        sub_407D7E(a1, 0xFFFFFFFFLL, v9, v10, a2, a3);
      }
      else if ( v8 != 4 )
      {
        goto LABEL_25;
      }
      if ( v7 )
        sub_40B994(a1, v3, v6, a2, a3);
      v11 = a1[13];
      v12 = a1[8];
      v13 = (*(_BYTE *)v11 & 8) == 0;
      *(_DWORD *)(v12 + 136) = 3;
      if ( !v13 )
        ++*(_DWORD *)(*(_QWORD *)(v11 + 8) + 4LL);
      v14 = *(_QWORD *)v11;
      v15 = *(_QWORD *)(v11 + 8);
      if ( (*(_BYTE *)(v12 + 160) & 8) != 0 )
      {
        v16 = *(_DWORD **)(v12 + 168);
        *(_QWORD *)(v12 + 160) = v14;
        *(_QWORD *)(v12 + 168) = v15;
        v13 = v16[1]-- == 1;
        if ( v13 )
          sub_40CFCD((__int64)a1, v16, v11, v14, a2, a3);
      }
      else
      {
        *(_QWORD *)(v12 + 160) = v14;
        *(_QWORD *)(v12 + 168) = v15;
      }
      v17 = a1[13];
      v18 = a1[8];
      if ( (*(_BYTE *)(v17 + 16) & 8) != 0 )
        ++*(_DWORD *)(*(_QWORD *)(v17 + 24) + 4LL);
      v19 = *(_QWORD *)(v17 + 16);
      v20 = *(_QWORD *)(v17 + 24);
      if ( (*(_BYTE *)(v18 + 144) & 8) != 0 )
      {
        v21 = *(_DWORD **)(v18 + 152);
        *(_QWORD *)(v18 + 144) = v19;
        *(_QWORD *)(v18 + 152) = v20;
        v13 = v21[1]-- == 1;
        if ( v13 )
          sub_40CFCD((__int64)a1, v21, v17, v19, a2, a3);
      }
      else
      {
        *(_QWORD *)(v18 + 144) = v19;
        *(_QWORD *)(v18 + 152) = v20;
      }
      *(_DWORD *)(a1[8] + 140) = v7;
      sub_40B99E(a1, a2, a3);
    }
  }
LABEL_25:
  sub_401D22(a1, (__int64)"third_party/duktape/duk_bi_thread.c", 200, a2, a3);
  return 0LL;
}
// 42D68D: variable 'v9' is possibly undefined
// 42D68D: variable 'v10' is possibly undefined
// 42D69A: variable 'v6' is possibly undefined

//----- (000000000042D78B) ----------------------------------------------------
__int64 __fastcall sub_42D78B(__int64 *a1, __int64 a2, __m128 a3, __m128 a4)
{
  int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // rcx
  int v7; // ebx
  __int64 v8; // rdx
  __int64 v9; // rax
  bool v10; // zf
  __int64 v11; // r8
  __int64 v12; // r9
  _DWORD *v13; // rsi

  v4 = sub_405C10(a1, a3, a4);
  if ( a1[18] )
  {
    if ( (unsigned __int64)a1[16] > 1 )
    {
      v7 = v4;
      if ( (**(_DWORD **)(*(_QWORD *)(a1[15] + 24) + 16LL) & 0x800) != 0 && a1[17] == 1 )
      {
        if ( v4 )
          sub_40B994(a1, a2, v5, a3, a4);
        v8 = a1[13];
        v9 = a1[8];
        v10 = (*(_BYTE *)v8 & 8) == 0;
        *(_DWORD *)(v9 + 136) = 2;
        if ( !v10 )
        {
          v6 = *(_QWORD *)(v8 + 8);
          ++*(_DWORD *)(v6 + 4);
        }
        v11 = *(_QWORD *)v8;
        v12 = *(_QWORD *)(v8 + 8);
        if ( (*(_BYTE *)(v9 + 144) & 8) != 0 )
        {
          v13 = *(_DWORD **)(v9 + 152);
          *(_QWORD *)(v9 + 144) = v11;
          *(_QWORD *)(v9 + 152) = v12;
          v10 = v13[1]-- == 1;
          if ( v10 )
            sub_40CFCD((__int64)a1, v13, v8, v6, a3, a4);
        }
        else
        {
          *(_QWORD *)(v9 + 144) = v11;
          *(_QWORD *)(v9 + 152) = v12;
        }
        *(_DWORD *)(a1[8] + 140) = v7;
        sub_40B99E(a1, a3, a4);
      }
    }
  }
  sub_401D22(a1, (__int64)"third_party/duktape/duk_bi_thread.c", 317, a3, a4);
  return 0LL;
}
// 42D7E9: variable 'v5' is possibly undefined
// 42D83B: variable 'v6' is possibly undefined

//----- (000000000042D87C) ----------------------------------------------------
__int64 __fastcall sub_42D87C(__int64 *a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  sub_407C63(a1, a4, a5, a2, a3);
  return 1LL;
}

//----- (000000000042D88C) ----------------------------------------------------
__int64 __fastcall sub_42D88C(__int64 *a1, __m128 a2, __m128 a3)
{
  sub_401D12(a1, (__int64)"third_party/duktape/duk_bi_thrower.c", 8, a2, a3);
  return 0LL;
}

//----- (000000000042D8A3) ----------------------------------------------------
__int64 __fastcall sub_42D8A3(__int64 a1, unsigned __int64 *a2, __m128 a3, __m128 a4)
{
  return sub_41C85D(*(__int64 **)a1, a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a3, a4);
}

//----- (000000000042D8B3) ----------------------------------------------------
__int64 __fastcall sub_42D8B3(__int64 a1, unsigned __int64 *a2, __m128 a3, __m128 a4)
{
  unsigned int v4; // eax
  unsigned int v5; // er8

  v4 = sub_41C85D(*(__int64 **)a1, a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a3, a4);
  v5 = v4 >> 1;
  if ( (v4 & 1) != 0 )
    return -v5;
  return v5;
}

//----- (000000000042D8DE) ----------------------------------------------------
_BYTE *__fastcall sub_42D8DE(
        __int64 *a1,
        _BYTE **a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        int a5,
        __m128 a6,
        __m128 a7)
{
  _BYTE *result; // rax

  result = *a2;
  if ( (unsigned __int64)*a2 >= a3 && (unsigned __int64)result <= a4 )
  {
LABEL_3:
    if ( !a5 )
    {
      *a2 = result;
      return result;
    }
    while ( a3 <= (unsigned __int64)--result )
    {
      if ( (*result & 0xC0) != 0x80 )
      {
        --a5;
        goto LABEL_3;
      }
    }
  }
  sub_401CB7(a1, (__int64)"third_party/duktape/duk_regexp_executor.c", 70, a6, a7);
  return 0LL;
}

//----- (000000000042D922) ----------------------------------------------------
__int64 __fastcall sub_42D922(__int64 a1, unsigned __int64 *a2, __m128 a3, __m128 a4)
{
  unsigned __int64 v4; // rcx
  __int64 result; // rax

  v4 = *(_QWORD *)(a1 + 24);
  if ( *a2 >= v4 )
    return 0xFFFFFFFFLL;
  result = sub_41C85D(*(__int64 **)a1, a2, *(_QWORD *)(a1 + 16), v4, a3, a4);
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    return sub_41CD28(*(_QWORD *)a1, result);
  return result;
}

//----- (000000000042D95C) ----------------------------------------------------
__int64 __fastcall sub_42D95C(__int64 *a1, _BYTE *a2, __m128 a3, __m128 a4)
{
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 *v7; // rdi
  _BYTE *v9[3]; // [rsp+8h] [rbp-18h] BYREF

  v5 = a1[3];
  v6 = a1[2];
  v7 = (__int64 *)*a1;
  v9[0] = a2;
  sub_42D8DE(v7, v9, v6, v5, 1, a3, a4);
  return sub_42D922((__int64)a1, (unsigned __int64 *)v9, a3, a4);
}

//----- (000000000042D99B) ----------------------------------------------------
_BYTE *__fastcall sub_42D99B(__int64 a1, unsigned __int64 a2, _BYTE *a3, __m128 a4, __m128 a5)
{
  unsigned int v6; // eax
  const char *v7; // rcx
  int v8; // edx
  unsigned int v9; // eax
  _BYTE *v10; // rax
  int v11; // er13
  int v12; // er12
  bool v13; // zf
  int v14; // edi
  int v15; // er12
  int v16; // er15
  int v17; // er14
  int v18; // eax
  bool v19; // zf
  int v20; // edi
  int v21; // er12
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  __int64 v26; // r12
  _BYTE *v27; // rax
  int v28; // eax
  unsigned int v29; // er12
  unsigned int v30; // er14
  unsigned int v31; // er13
  __int64 v32; // r15
  _BYTE *v33; // rax
  unsigned int v34; // er12
  unsigned int v35; // er13
  int v36; // er14
  __int64 v37; // r15
  _BYTE *v38; // rax
  unsigned int v39; // eax
  __int64 v40; // r12
  _BYTE *v41; // rdx
  __int64 *v42; // rax
  __int64 v43; // r13
  __int64 v44; // r12
  unsigned int v45; // eax
  unsigned __int64 v46; // r13
  __int64 v47; // r12
  __int64 v48; // r14
  unsigned __int64 v49; // rdx
  __int64 v50; // rsi
  __int64 v51; // rdx
  __int64 v52; // rcx
  _BYTE *v53; // r15
  __int64 v54; // rsi
  unsigned __int64 v55; // rdx
  __int64 v56; // rdi
  __int64 v57; // r14
  int v58; // er12
  _BYTE *v59; // rax
  unsigned __int64 v60; // rsi
  __int64 v61; // rdx
  __int64 v62; // rcx
  _BYTE *v63; // r12
  __int64 v64; // rdx
  __int64 v65; // rcx
  __int64 v66; // rax
  __int64 v67; // rsi
  __int64 v68; // r13
  int v69; // er12
  int v71; // [rsp+Ch] [rbp-54h]
  int v72; // [rsp+Ch] [rbp-54h]
  _BYTE *v73; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v74[2]; // [rsp+18h] [rbp-48h] BYREF
  unsigned __int64 v75[7]; // [rsp+28h] [rbp-38h] BYREF

  v74[0] = a2;
  v73 = a3;
  *(double *)a4.i64 = nullsub_1(*(double *)a4.i64, *(double *)a5.i64);
  v6 = *(_DWORD *)(a1 + 60);
  if ( v6 < *(_DWORD *)(a1 + 64) )
  {
    *(_DWORD *)(a1 + 60) = v6 + 1;
    while ( 1 )
    {
      v9 = *(_DWORD *)(a1 + 68);
      if ( v9 >= *(_DWORD *)(a1 + 72) )
        break;
      *(_DWORD *)(a1 + 68) = v9 + 1;
      v10 = (_BYTE *)v74[0]++;
      v11 = (unsigned __int8)*v10;
      switch ( *v10 )
      {
        case 1:
          goto LABEL_83;
        case 2:
          v12 = sub_42D8A3(a1, v74, a4, a5);
          v13 = v12 == (unsigned int)sub_42D922(a1, (unsigned __int64 *)&v73, a4, a5);
          goto LABEL_36;
        case 3:
          v14 = sub_42D922(a1, (unsigned __int64 *)&v73, a4, a5);
          if ( v14 < 0 )
            goto LABEL_84;
          v13 = !sub_41CA82(v14);
          goto LABEL_36;
        case 4:
        case 5:
          v15 = sub_42D8A3(a1, v74, a4, a5);
          v16 = sub_42D922(a1, (unsigned __int64 *)&v73, a4, a5);
          if ( v16 < 0 )
            goto LABEL_84;
          v17 = 0;
          while ( v15 )
          {
            v71 = sub_42D8A3(a1, v74, a4, a5);
            v18 = sub_42D8A3(a1, v74, a4, a5);
            if ( v16 >= v71 && v16 <= v18 )
              v17 = 1;
            --v15;
          }
          if ( v11 == 4 )
          {
            v19 = v17 == 0;
            goto LABEL_33;
          }
          v13 = v17 == 0;
          goto LABEL_36;
        case 6:
          v25 = sub_42D8B3(a1, v74, a4, a5);
          v74[0] += v25;
          continue;
        case 7:
          v26 = (int)sub_42D8B3(a1, v74, a4, a5);
          v27 = sub_42D99B(a1, v74[0], v73, a4, a5);
          if ( v27 )
            goto LABEL_60;
          v74[0] += v26;
          continue;
        case 8:
          v28 = sub_42D8B3(a1, v74, a4, a5);
          v27 = sub_42D99B(a1, v74[0] + v28, v73, a4, a5);
          if ( !v27 )
            continue;
          goto LABEL_60;
        case 9:
          v29 = 0;
          v30 = sub_42D8A3(a1, v74, a4, a5);
          v31 = sub_42D8A3(a1, v74, a4, a5);
          v32 = (int)sub_42D8B3(a1, v74, a4, a5);
          while ( 1 )
          {
            if ( v30 <= v29 )
            {
              v27 = sub_42D99B(a1, v32 + v74[0], v73, a4, a5);
              if ( v27 )
                break;
            }
            v33 = sub_42D99B(a1, v74[0], v73, a4, a5);
            if ( v33 )
            {
              ++v29;
              v73 = v33;
              if ( v31 >= v29 )
                continue;
            }
            goto LABEL_84;
          }
LABEL_60:
          v73 = v27;
LABEL_83:
          --*(_DWORD *)(a1 + 60);
          return v73;
        case 0xA:
          v34 = 0;
          v35 = sub_42D8A3(a1, v74, a4, a5);
          v72 = sub_42D8A3(a1, v74, a4, a5);
          v36 = sub_42D8A3(a1, v74, a4, a5);
          v37 = (int)sub_42D8B3(a1, v74, a4, a5);
          while ( v34 != v72 )
          {
            v38 = sub_42D99B(a1, v74[0], v73, a4, a5);
            if ( !v38 )
              break;
            v73 = v38;
            ++v34;
          }
          while ( 2 )
          {
            if ( v34 < v35 )
              goto LABEL_84;
            v27 = sub_42D99B(a1, v37 + v74[0], v73, a4, a5);
            if ( v27 )
              goto LABEL_60;
            if ( v34 != v35 )
            {
              --v34;
              v73 = sub_42D8DE(*(__int64 **)a1, &v73, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v36, a4, a5);
              continue;
            }
            goto LABEL_84;
          }
        case 0xB:
          v39 = sub_42D8A3(a1, v74, a4, a5);
          if ( *(_DWORD *)(a1 + 56) <= v39 )
            goto LABEL_85;
          v40 = v39;
          v41 = v73;
          v42 = (__int64 *)(*(_QWORD *)(a1 + 48) + 8LL * v39);
          v43 = *v42;
          *v42 = (__int64)v73;
          v27 = sub_42D99B(a1, v74[0], v41, a4, a5);
          if ( v27 )
            goto LABEL_60;
          *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v40) = v43;
          goto LABEL_84;
        case 0xC:
          v44 = (unsigned int)sub_42D8A3(a1, v74, a4, a5);
          v45 = sub_42D8A3(a1, v74, a4, a5);
          if ( (unsigned int)v44 + v45 > *(_DWORD *)(a1 + 56) || !v45 )
            goto LABEL_85;
          v46 = 8LL * v45;
          v47 = 8 * v44;
          sub_404E3A(*(__int64 **)a1, 1, a4, a5);
          v48 = sub_4076DF(*(__int64 **)a1, v46, a4, a5);
          sub_43AAA0(v48, v47 + *(_QWORD *)(a1 + 48), v46);
          sub_43ABE2(v47 + *(_QWORD *)(a1 + 48), 0LL, v49);
          v50 = v74[0];
          v53 = sub_42D99B(a1, v74[0], v73, a4, a5);
          if ( v53 )
          {
            sub_407DA1(*(_QWORD *)a1, v50, v51, v52, a4, a5);
            v73 = v53;
            goto LABEL_83;
          }
          v54 = v48;
          v55 = v46;
          v56 = v47 + *(_QWORD *)(a1 + 48);
          goto LABEL_74;
        case 0xD:
        case 0xE:
          sub_404E3A(*(__int64 **)a1, 1, a4, a5);
          v57 = sub_4076DF(*(__int64 **)a1, 8LL * *(unsigned int *)(a1 + 56), a4, a5);
          sub_43AAA0(v57, *(_QWORD *)(a1 + 48), 8LL * *(unsigned int *)(a1 + 56));
          v58 = sub_42D8B3(a1, v74, a4, a5);
          v59 = sub_42D99B(a1, v74[0], v73, a4, a5);
          if ( v11 == 13 )
          {
            if ( !v59 )
              goto LABEL_73;
          }
          else if ( v59 )
          {
            goto LABEL_73;
          }
          v60 = v74[0] + v58;
          v63 = sub_42D99B(a1, v60, v73, a4, a5);
          if ( v63 )
          {
            sub_407DA1(*(_QWORD *)a1, v60, v61, v62, a4, a5);
            v73 = v63;
            goto LABEL_83;
          }
LABEL_73:
          v56 = *(_QWORD *)(a1 + 48);
          v54 = v57;
          v55 = 8LL * *(unsigned int *)(a1 + 56);
LABEL_74:
          sub_43AAA0(v56, v54, v55);
          sub_407DA1(*(_QWORD *)a1, v54, v64, v65, a4, a5);
          goto LABEL_84;
        case 0xF:
          v66 = 2 * (unsigned int)sub_42D8A3(a1, v74, a4, a5);
          if ( (unsigned int)v66 <= 1 || (unsigned int)(v66 + 1) >= *(_DWORD *)(a1 + 56) )
            goto LABEL_85;
          v67 = *(_QWORD *)(a1 + 48);
          if ( !*(_QWORD *)(v67 + 8 * v66) )
            continue;
          v68 = 8LL * (unsigned int)(v66 + 1);
          if ( !*(_QWORD *)(v67 + v68) )
            continue;
          v75[0] = *(_QWORD *)(v67 + 8 * v66);
          while ( *(_QWORD *)(*(_QWORD *)(a1 + 48) + v68) > v75[0] )
          {
            v69 = sub_42D922(a1, v75, a4, a5);
            if ( v69 != (unsigned int)sub_42D922(a1, (unsigned __int64 *)&v73, a4, a5) )
              goto LABEL_84;
          }
          continue;
        case 0x10:
          if ( *(_QWORD *)(a1 + 16) >= (unsigned __int64)v73 )
            continue;
          if ( (*(_BYTE *)(a1 + 8) & 4) == 0 )
            goto LABEL_84;
          v20 = sub_42D95C((__int64 *)a1, v73, a4, a5);
LABEL_26:
          v19 = !sub_41CA82(v20);
          goto LABEL_33;
        case 0x11:
          v75[0] = (unsigned __int64)v73;
          v20 = sub_42D922(a1, v75, a4, a5);
          if ( v20 < 0 )
            continue;
          if ( (*(_BYTE *)(a1 + 8) & 4) != 0 )
            goto LABEL_26;
          goto LABEL_84;
        case 0x12:
        case 0x13:
          v21 = 0;
          if ( *(_QWORD *)(a1 + 16) < (unsigned __int64)v73 )
          {
            v22 = sub_42D95C((__int64 *)a1, v73, a4, a5);
            v21 = sub_41CD7E(v22);
          }
          v23 = 0;
          if ( *(_QWORD *)(a1 + 24) > (unsigned __int64)v73 )
          {
            v75[0] = (unsigned __int64)v73;
            v24 = sub_42D922(a1, v75, a4, a5);
            v23 = sub_41CD7E(v24);
          }
          if ( v11 == 18 )
          {
            v19 = v23 == v21;
LABEL_33:
            if ( v19 )
              goto LABEL_84;
          }
          else
          {
            v13 = v23 == v21;
LABEL_36:
            if ( !v13 )
            {
LABEL_84:
              --*(_DWORD *)(a1 + 60);
              return 0LL;
            }
          }
          break;
        default:
LABEL_85:
          sub_401CB7(*(__int64 **)a1, (__int64)"third_party/duktape/duk_regexp_executor.c", 670, a4, a5);
          return 0LL;
      }
    }
    v7 = "regexp step limit";
    v8 = 160;
  }
  else
  {
    v7 = "regexp executor recursion limit";
    v8 = 151;
  }
  sub_401CE2(*(__int64 **)a1, (__int64)"third_party/duktape/duk_regexp_executor.c", v8, v7, a4, a5);
  return 0LL;
}
// 42DDFB: variable 'v49' is possibly undefined
// 42DE1B: variable 'v51' is possibly undefined
// 42DE1B: variable 'v52' is possibly undefined
// 42DEBC: variable 'v61' is possibly undefined
// 42DEBC: variable 'v62' is possibly undefined
// 42DEE0: variable 'v64' is possibly undefined
// 42DEE0: variable 'v65' is possibly undefined
// 4205E1: using guessed type double __fastcall nullsub_1(double, double);

//----- (000000000042DF94) ----------------------------------------------------
__int64 __fastcall sub_42DF94(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  __int64 v4; // r13
  __int64 v5; // rcx
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rsi
  __int64 v10; // rdx
  int v11; // ecx
  __int64 v12; // rax
  unsigned int v13; // ebx
  unsigned __int64 v14; // r14
  _BYTE *v15; // r14
  __int64 v16; // rdx
  int v17; // ecx
  unsigned __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  int v22; // er15
  unsigned int v23; // er13
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rsi
  int v26; // edx
  int v27; // [rsp+4h] [rbp-9Ch]
  double v28; // [rsp+8h] [rbp-98h]
  unsigned __int64 v29; // [rsp+18h] [rbp-88h] BYREF
  __int64 *v30; // [rsp+20h] [rbp-80h] BYREF
  int v31; // [rsp+28h] [rbp-78h]
  unsigned __int64 v32; // [rsp+30h] [rbp-70h]
  unsigned __int64 v33; // [rsp+38h] [rbp-68h]
  unsigned __int64 v34; // [rsp+40h] [rbp-60h]
  __int64 v35; // [rsp+48h] [rbp-58h]
  __int64 v36; // [rsp+50h] [rbp-50h]
  unsigned int v37; // [rsp+58h] [rbp-48h]
  int v38; // [rsp+60h] [rbp-40h]
  int v39; // [rsp+68h] [rbp-38h]

  sub_405AEC(a1, -2, a3, a4);
  v4 = sub_408998(a1, -1, a3, a4);
  sub_403883(a1, -130974, a3, a4);
  sub_40574F(a1, -1, a3, a4);
  sub_43ABE2((__int64)&v30, 0LL, 0x50uLL);
  v5 = *(unsigned int *)(v4 + 24);
  v30 = a1;
  v32 = v4 + 32;
  v33 = v5 + v4 + 32;
  v7 = v6 + 32;
  v8 = *(unsigned int *)(v6 + 24);
  v36 = 0LL;
  v38 = 10000;
  v34 = v7;
  v29 = v7;
  v39 = 1000000000;
  v35 = v7 + v8;
  v31 = sub_42D8A3((__int64)&v30, &v29, a3, a4);
  v37 = sub_42D8A3((__int64)&v30, &v29, a3, a4);
  v34 = v29;
  v27 = a2 | v31 & 1;
  sub_40762B(a1, 8LL * v37, 0, a3, a4);
  v36 = sub_40554E(a1, -1, 0LL, a3, a4);
  sub_4037B9(a1, -262097, a3, a4);
  sub_405DB7(a1, -1, a3, a4);
  v9 = 0xFFFFFFFFLL;
  *(double *)a3.i64 = sub_40541C((__int64)a1, -1);
  v28 = *(double *)a3.i64;
  sub_407DA6((__int64)a1);
  if ( v27 )
  {
    a3 = 0LL;
    if ( v28 < 0.0 )
      goto LABEL_17;
    v12 = sub_40314F(v4, 0xFFFFFFFFLL, v10, v11);
    *(double *)a3.i64 = (double)(int)v12;
    if ( v12 < 0 )
    {
      v10 = v12 & 1 | ((unsigned __int64)v12 >> 1);
      *(double *)a3.i64 = (double)(int)v10 + (double)(int)v10;
    }
    v13 = (int)v28;
    if ( v28 > *(double *)a3.i64 )
    {
LABEL_17:
      sub_40691D(a1, v9, v10, a3, a4);
      sub_406A68(a1, 0, a3, a4);
LABEL_18:
      sub_403A07(a1, -393169, a3, a4);
      goto LABEL_19;
    }
  }
  else
  {
    v13 = 0;
  }
  v14 = v32;
  v15 = (_BYTE *)((unsigned int)sub_40D015(a1, v4, v13, v11, a3, a4) + v14);
  while ( 1 )
  {
    v9 = v34;
    if ( sub_42D99B((__int64)&v30, v34, v15, a3, a4) )
      break;
    ++v13;
    v18 = sub_40314F(v4, v9, v16, v17);
    v10 = v13;
    if ( v13 > v18 )
      goto LABEL_17;
    if ( v32 > (unsigned __int64)v15 || v33 <= (unsigned __int64)v15 )
    {
      sub_401CB7(a1, (__int64)"third_party/duktape/duk_regexp_executor.c", 101, a3, a4);
    }
    else
    {
      do
        ++v15;
      while ( v33 > (unsigned __int64)v15 && (*v15 & 0xC0) == 0x80 );
    }
  }
  v22 = 0;
  v23 = 0;
  sub_4070BA(a1, a3, a4);
  sub_406AAF(a1, v13, a3, a4);
  sub_403E13(a1, -33541881, a3, a4);
  sub_405005(a1, a3, a4);
  sub_403E13(a1, -33526777, a3, a4);
  while ( v23 < v37 )
  {
    v24 = v23;
    v25 = *(_QWORD *)(v36 + 8LL * v23);
    if ( v25 && (v24 = *(_QWORD *)(v36 + 8LL * (v23 + 1)), v25 <= v24) && v24 )
    {
      sub_406B69(a1, v25, v24 - v25, a3, a4);
      if ( !v23 )
        v22 = v13 + sub_405CB0(a1, 0xFFFFFFFF, a3, a4);
    }
    else
    {
      sub_4068D1(a1, v25, v24, a3, a4);
    }
    v26 = v23 >> 1;
    v23 += 2;
    sub_403953(a1, -2, v26, a3, a4);
  }
  if ( v27 )
  {
    sub_406AAF(a1, v22, a3, a4);
    goto LABEL_18;
  }
LABEL_19:
  sub_40500F(a1, -5);
  return sub_407D45((__int64)a1, (_DWORD *)4, v19, v20, a3, a4);
}
// 42E011: variable 'v6' is possibly undefined
// 42E0E9: variable 'v10' is possibly undefined
// 42E0E9: variable 'v11' is possibly undefined
// 42E157: variable 'v16' is possibly undefined
// 42E157: variable 'v17' is possibly undefined
// 42E1CE: variable 'v19' is possibly undefined
// 42E1CE: variable 'v20' is possibly undefined

//----- (000000000042E2A2) ----------------------------------------------------
__int64 __fastcall sub_42E2A2(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_42DF94(a1, 0, a2, a3);
}

//----- (000000000042E2A9) ----------------------------------------------------
__int64 __fastcall sub_42E2A9(__int64 *a1, __m128 a2, __m128 a3)
{
  return sub_42DF94(a1, 1, a2, a3);
}

//----- (000000000042E2B3) ----------------------------------------------------
__int16 __fastcall sub_42E2B3(_WORD *a1)
{
  __int16 result; // ax

  LOBYTE(result) = HIBYTE(*a1);
  HIBYTE(result) = *a1;
  return result;
}

//----- (000000000042E2B9) ----------------------------------------------------
__int64 __fastcall sub_42E2B9(unsigned int *a1)
{
  return _byteswap_ulong(*a1);
}

//----- (000000000042E2BE) ----------------------------------------------------
float __fastcall sub_42E2BE(int *a1)
{
  int v2; // [rsp+Ch] [rbp-4h] BYREF

  v2 = *a1;
  sub_41D67A(&v2);
  return *(float *)&v2;
}
// 41D67A: using guessed type __int64 __fastcall sub_41D67A(_QWORD);

//----- (000000000042E2DB) ----------------------------------------------------
double __fastcall sub_42E2DB(__int64 *a1)
{
  __int64 v2; // [rsp+8h] [rbp-8h] BYREF

  v2 = *a1;
  sub_41D671(&v2);
  return *(double *)&v2;
}
// 41D671: using guessed type __int64 __fastcall sub_41D671(_QWORD);

//----- (000000000042E362) ----------------------------------------------------
__int16 __fastcall sub_42E362(_WORD *a1, __int16 a2)
{
  __int16 result; // ax

  LOBYTE(result) = HIBYTE(a2);
  HIBYTE(result) = a2;
  *a1 = result;
  return result;
}

//----- (000000000042E36A) ----------------------------------------------------
void __fastcall sub_42E36A(_DWORD *a1, unsigned int a2)
{
  *a1 = _byteswap_ulong(a2);
}

//----- (000000000042E36F) ----------------------------------------------------
__int64 __fastcall sub_42E36F(float *a1, float a2)
{
  __int64 result; // rax
  int v3[5]; // [rsp+Ch] [rbp-14h] BYREF

  *(float *)v3 = a2;
  sub_41D673((unsigned int *)v3);
  result = (unsigned int)v3[0];
  *a1 = *(float *)v3;
  return result;
}
// 42E36F: using guessed type unsigned int var_14[5];

//----- (000000000042E395) ----------------------------------------------------
__int64 __fastcall sub_42E395(double *a1, double a2)
{
  __int64 result; // rax
  __int64 v3[3]; // [rsp+8h] [rbp-18h] BYREF

  *(double *)v3 = a2;
  sub_41D667((unsigned __int64 *)v3);
  result = v3[0];
  *a1 = *(double *)v3;
  return result;
}
// 42E395: using guessed type unsigned __int64 var_18[3];

//----- (000000000042E3D7) ----------------------------------------------------
__int16 __fastcall sub_42E3D7(_WORD **a1, __int16 a2)
{
  __int16 result; // ax
  _QWORD *v3; // rdx

  result = sub_42E362(*a1, a2);
  *v3 += 2LL;
  return result;
}
// 42E3EA: variable 'v3' is possibly undefined

//----- (000000000042E3EF) ----------------------------------------------------
void __fastcall sub_42E3EF(_DWORD **a1, unsigned int a2)
{
  _QWORD *v2; // rax

  sub_42E36A(*a1, a2);
  *v2 += 4LL;
}
// 42E3FF: variable 'v2' is possibly undefined

//----- (000000000042E404) ----------------------------------------------------
__int64 __fastcall sub_42E404(float **a1, float a2)
{
  __int64 result; // rax

  result = sub_42E36F(*a1, a2);
  ++*a1;
  return result;
}

//----- (000000000042E41D) ----------------------------------------------------
__int64 __fastcall sub_42E41D(double **a1, double a2)
{
  __int64 result; // rax

  result = sub_42E395(*a1, a2);
  ++*a1;
  return result;
}

//----- (000000000042E436) ----------------------------------------------------
__int64 __fastcall sub_42E436(_BYTE **a1, unsigned int a2)
{
  __int64 result; // rax

  result = (int)sub_41C531(a2, *a1);
  *a1 += (int)result;
  return result;
}

//----- (000000000042E46E) ----------------------------------------------------
char __fastcall sub_42E46E(unsigned __int8 *a1, _BYTE *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  char result; // al

  v2 = ((*a1 << 8) + a1[1]) << 8;
  v3 = v2 + a1[2];
  LOBYTE(v2) = byte_442780[(v2 >> 12) & 0x3F];
  *a2 = byte_442780[((*a1 << 8) + (unsigned int)a1[1]) << 8 >> 18];
  a2[1] = v2;
  a2[2] = byte_442780[(v3 >> 6) & 0x3F];
  result = byte_442780[v3 & 0x3F];
  a2[3] = result;
  return result;
}

//----- (000000000042E4BF) ----------------------------------------------------
_QWORD *__fastcall sub_42E4BF(__int64 *a1, int a2, _QWORD *a3, __m128 a4, __m128 a5)
{
  _QWORD *result; // rax
  int v7; // [rsp+34h] [rbp-4h] BYREF

  result = (_QWORD *)sub_405573(a1, a2, a3, 0LL, 0LL, 0LL, a4, a5, &v7);
  if ( !v7 )
    return (_QWORD *)sub_408821(a1, a2, a3, a4, a5);
  if ( !result )
    return a3;
  return result;
}

//----- (000000000042E507) ----------------------------------------------------
__int64 __fastcall sub_42E507(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v5; // er13
  unsigned __int8 *v6; // rbx
  __int64 v8; // rax
  unsigned __int64 v9; // r10
  __int64 v10; // r9
  _BYTE *v11; // r14
  unsigned __int8 *v12; // r11
  unsigned __int8 *v13; // r15
  __int64 v14; // r11
  __int64 v15; // r11
  _BYTE *v16; // rsi
  __int64 v17; // r11
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r10
  __int64 v21; // r11
  unsigned __int64 v22; // rax
  unsigned __int8 *v23; // rbx
  unsigned __int8 *v24; // rdi
  __int64 v25; // r9
  __int64 v26; // r10
  unsigned int v27; // eax
  __int64 v28; // rdx
  unsigned int v29; // eax
  int v30; // edx
  unsigned int v31; // eax
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // [rsp+8h] [rbp-48h]
  __int64 v35[7]; // [rsp+18h] [rbp-38h] BYREF

  v5 = sub_40480A(a1, a2);
  v6 = (unsigned __int8 *)sub_42E4BF(a1, v5, v35, a3, a4);
  if ( v35[0] <= 0xBFFFFFFDuLL )
  {
    v8 = sub_4076DF(a1, 4 * ((v35[0] + 2) / 3uLL), a3, a4);
    v9 = v35[0];
    v10 = v8;
    if ( v35[0] > 0xFuLL )
    {
      v11 = (_BYTE *)v8;
      v12 = v6;
      v13 = &v6[12 * (v35[0] / 0xCuLL)];
      do
      {
        sub_42E46E(v12, v11);
        sub_42E46E((unsigned __int8 *)(v14 + 3), v11 + 4);
        sub_42E46E((unsigned __int8 *)(v15 + 6), v11 + 8);
        v16 = v11 + 12;
        v11 += 16;
        sub_42E46E((unsigned __int8 *)(v17 + 9), v16);
        v12 = (unsigned __int8 *)(v21 + 12);
      }
      while ( v13 != v12 );
      v22 = ((0x2AAAAAAAAAAAAAABLL * ((unsigned __int64)(v18 - 12) >> 2)) & 0x3FFFFFFFFFFFFFFFLL) + 1;
      v10 = 16 * v22 + v19;
      v6 += 12 * v22;
      v9 = v20 - 12 * v22;
    }
    v23 = &v6[v9];
    while ( 1 )
    {
      v24 = &v23[-v9];
      if ( v9 <= 2 )
        break;
      sub_42E46E(v24, (_BYTE *)v10);
      v10 = v25 + 4;
      v9 = v26 - 3;
    }
    if ( v9 == 1 )
    {
      v27 = *v24;
      *(_WORD *)(v10 + 2) = 15677;
      v28 = v27 >> 2;
      LOBYTE(v27) = byte_442780[(16 * (_BYTE)v27) & 0x30];
      *(_BYTE *)v10 = byte_442780[v28];
      *(_BYTE *)(v10 + 1) = v27;
    }
    else if ( v9 == 2 )
    {
      v29 = *v24;
      v30 = v24[1];
      *(_BYTE *)(v10 + 3) = 61;
      v29 <<= 8;
      *(_BYTE *)v10 = byte_442780[v29 >> 10];
      v31 = v29 + v30;
      *(_BYTE *)(v10 + 1) = byte_442780[(v31 >> 4) & 0x3F];
      *(_BYTE *)(v10 + 2) = byte_442780[(4 * (_BYTE)v31) & 0x3C];
    }
    v34 = sub_406BF4(a1, -1, a3, a4);
    sub_405057(a1, v5, v32, v33, *(double *)a3.i64, a4);
    return v34;
  }
  else
  {
    sub_401C42(a1, (__int64)"third_party/duktape/duk_api_codec.c", 0x6000286u, "base64 encode failed", a3, a4);
    return 0LL;
  }
}
// 42E5B9: variable 'v14' is possibly undefined
// 42E5C6: variable 'v15' is possibly undefined
// 42E5D3: variable 'v17' is possibly undefined
// 42E5E0: variable 'v21' is possibly undefined
// 42E5E9: variable 'v18' is possibly undefined
// 42E617: variable 'v19' is possibly undefined
// 42E61D: variable 'v20' is possibly undefined
// 42E637: variable 'v25' is possibly undefined
// 42E63B: variable 'v26' is possibly undefined
// 42E6CB: variable 'v32' is possibly undefined
// 42E6CB: variable 'v33' is possibly undefined
// 42E507: using guessed type unsigned __int64 var_38[7];

//----- (000000000042E6E3) ----------------------------------------------------
__int64 __fastcall sub_42E6E3(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v5; // er12
  unsigned __int8 *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rdx
  unsigned __int8 *v9; // r8
  unsigned __int64 v10; // r9
  int v11; // esi
  int v12; // ecx
  unsigned __int8 *v13; // rsi
  unsigned int v14; // ecx
  int v15; // edi
  __int64 v16; // rdi
  char v17; // er10^2
  __int16 v18; // cx
  char v19; // t0
  __int64 v20; // rcx
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24[5]; // [rsp+8h] [rbp-28h] BYREF

  v5 = sub_40480A(a1, a2);
  v6 = (unsigned __int8 *)sub_42E4BF(a1, v5, v24, a3, a4);
  v7 = sub_40762B(a1, 3 * ((unsigned __int64)v24[0] >> 2) + 6, 1, a3, a4);
  v8 = v7;
  v9 = &v6[v24[0]];
  v10 = (unsigned __int64)&v6[v24[0] - 8];
  while ( v10 >= (unsigned __int64)v6 )
  {
    v11 = ((byte_442680[v6[2]] | ((byte_442680[v6[1]] | (byte_442680[*v6] << 6)) << 6)) << 6) | byte_442680[v6[3]];
    v12 = ((byte_442680[v6[6]] | ((byte_442680[v6[5]] | (byte_442680[v6[4]] << 6)) << 6)) << 6) | byte_442680[v6[7]];
    *(_BYTE *)v8 = BYTE2(v11);
    *(_WORD *)(v8 + 1) = __ROL2__(v11, 8);
    *(_BYTE *)(v8 + 3) = BYTE2(v12);
    *(_WORD *)(v8 + 4) = __ROL2__(v12, 8);
    if ( (v11 | v12) < 0 )
    {
      if ( v11 >= 0 )
      {
        v6 += 4;
        v8 += 3LL;
      }
      break;
    }
    v13 = v6 + 8;
    v8 += 6LL;
LABEL_7:
    v6 = v13;
  }
  v14 = 1;
  while ( 1 )
  {
    if ( v9 <= v6 )
      goto LABEL_15;
    v13 = v6 + 1;
    v15 = byte_442680[*v6];
    if ( v15 < 0 )
      break;
    v14 = v15 + (v14 << 6);
    if ( v14 > 0xFFFFFF )
    {
      v16 = 0LL;
      goto LABEL_20;
    }
LABEL_12:
    ++v6;
  }
  if ( v15 == -1 )
    goto LABEL_12;
  if ( v15 != -2 )
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_api_codec.c", 0x60002ACu, "base64 decode failed", a3, a4);
LABEL_15:
  v16 = 0LL;
  while ( v14 <= 0xFFFFFF )
  {
    v14 <<= 6;
    v16 = (unsigned int)(v16 + 1);
  }
  v13 = v6;
LABEL_20:
  v17 = BYTE2(v14);
  v19 = BYTE1(v14);
  HIBYTE(v18) = v14;
  LOBYTE(v18) = v19;
  *(_WORD *)(v8 + 1) = v18;
  v20 = byte_442660[v16];
  *(_BYTE *)v8 = v17;
  if ( (v20 & 0x80u) != 0LL )
    return sub_401C42(a1, (__int64)"third_party/duktape/duk_api_codec.c", 0x60002ACu, "base64 decode failed", a3, a4);
  v8 += v20;
  while ( v9 > v13 )
  {
    if ( (unsigned int)(byte_442680[*v13] + 2) > 1 )
      goto LABEL_7;
    ++v13;
  }
  sub_41D79F(a1, -1, v8 - v7, a3, a4);
  return sub_405057(a1, v5, v22, v23, *(double *)a3.i64, a4);
}
// 42E8C0: variable 'v22' is possibly undefined
// 42E8C0: variable 'v23' is possibly undefined
// 42E6E3: using guessed type unsigned __int64 var_28[5];

//----- (000000000042E8D0) ----------------------------------------------------
__int64 __fastcall sub_42E8D0(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v5; // er13
  _QWORD *v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v16; // [rsp+8h] [rbp-38h]
  __int64 v17[5]; // [rsp+18h] [rbp-28h] BYREF

  v5 = sub_40480A(a1, a2);
  v6 = sub_42E4BF(a1, v5, v17, a3, a4);
  v7 = sub_4076DF(a1, 2 * v17[0], a3, a4);
  v8 = v17[0];
  v9 = 0LL;
  v10 = v17[0] & 0xFFFFFFFC;
  while ( v9 < v10 )
  {
    v7 += 8LL;
    *(_WORD *)(v7 - 8) = word_43EEC0[*((unsigned __int8 *)v6 + v9)];
    *(_WORD *)(v7 - 6) = word_43EEC0[*((unsigned __int8 *)v6 + v9 + 1)];
    *(_WORD *)(v7 - 4) = word_43EEC0[*((unsigned __int8 *)v6 + v9 + 2)];
    v11 = *((unsigned __int8 *)v6 + v9 + 3);
    v9 += 4LL;
    *(_WORD *)(v7 - 2) = word_43EEC0[v11];
  }
  while ( v8 > v9 )
  {
    v12 = *((unsigned __int8 *)v6 + v9);
    v7 += 2LL;
    ++v9;
    *(_WORD *)(v7 - 2) = word_43EEC0[v12];
  }
  v16 = sub_406BF4(a1, -1, a3, a4);
  sub_405057(a1, v5, v13, v14, *(double *)a3.i64, a4);
  return v16;
}
// 42E999: variable 'v13' is possibly undefined
// 42E999: variable 'v14' is possibly undefined
// 43EEC0: using guessed type __int16 word_43EEC0[];
// 42E8D0: using guessed type unsigned __int64 var_28[5];

//----- (000000000042E9AD) ----------------------------------------------------
__int64 __fastcall sub_42E9AD(__int64 *a1, int a2, __m128 a3, __m128 a4)
{
  int v4; // er13
  _QWORD *v5; // rax
  unsigned __int64 v6; // rbx
  _QWORD *v7; // r12
  _BYTE *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // rsi
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  __int64 v18; // [rsp+0h] [rbp-30h]
  __int64 v19[5]; // [rsp+8h] [rbp-28h] BYREF

  v4 = sub_40480A(a1, a2);
  v5 = sub_42E4BF(a1, v4, v19, a3, a4);
  v6 = v19[0] & 1;
  if ( (v19[0] & 1) != 0 )
  {
LABEL_10:
    sub_401C42(a1, (__int64)"third_party/duktape/duk_api_codec.c", 0x600034Eu, "hex decode failed", a3, a4);
  }
  else
  {
    v7 = v5;
    v8 = (_BYTE *)sub_4076DF(a1, (unsigned __int64)v19[0] >> 1, a3, a4);
    v11 = v19[0] & 0xFFFFFFF8;
    while ( v6 < v11 )
    {
      v8 += 4;
      v12 = byte_44E328[*((unsigned __int8 *)v7 + v6 + 1)] | word_43F0C0[*((unsigned __int8 *)v7 + v6)];
      *(v8 - 4) = v12;
      v13 = byte_44E328[*((unsigned __int8 *)v7 + v6 + 3)] | word_43F0C0[*((unsigned __int8 *)v7 + v6 + 2)];
      *(v8 - 3) = v13;
      v14 = v13 | v12;
      v15 = byte_44E328[*((unsigned __int8 *)v7 + v6 + 5)] | word_43F0C0[*((unsigned __int8 *)v7 + v6 + 4)];
      *(v8 - 2) = v15;
      v16 = v15 | v14;
      v10 = byte_44E328[*((unsigned __int8 *)v7 + v6 + 7)] | (unsigned int)word_43F0C0[*((unsigned __int8 *)v7 + v6 + 6)];
      *(v8 - 1) = byte_44E328[*((unsigned __int8 *)v7 + v6 + 7)] | word_43F0C0[*((unsigned __int8 *)v7 + v6 + 6)];
      v9 = (unsigned int)v10 | v16;
      if ( (int)v9 < 0 )
        goto LABEL_10;
      v6 += 8LL;
    }
    while ( v19[0] > v6 )
    {
      v10 = (unsigned int)byte_44E328[*((unsigned __int8 *)v7 + v6 + 1)];
      v9 = (unsigned int)v10 | (16 * byte_44E328[*((unsigned __int8 *)v7 + v6)]);
      if ( (int)(v10 | (16 * byte_44E328[*((unsigned __int8 *)v7 + v6)])) < 0 )
        goto LABEL_10;
      *v8 = byte_44E328[*((unsigned __int8 *)v7 + v6 + 1)] | (16 * byte_44E328[*((unsigned __int8 *)v7 + v6)]);
      v6 += 2LL;
      ++v8;
    }
    sub_405057(a1, v4, v9, v10, *(double *)a3.i64, a4);
  }
  return v18;
}
// 42EACC: variable 'v9' is possibly undefined
// 42EACC: variable 'v10' is possibly undefined
// 42EAEA: variable 'v18' is possibly undefined
// 43F0C0: using guessed type __int16 word_43F0C0[];
// 42E9AD: using guessed type unsigned __int64 var_28[5];

//----- (000000000042EB6E) ----------------------------------------------------
__int64 __fastcall sub_42EB6E(__int64 *a1, __m128 a2, __m128 a3)
{
  int *v3; // r13
  __int64 v4; // rbx
  int v5; // er8
  __int64 *v6; // rax
  int *v7; // r14
  int v8; // eax
  unsigned __int32 v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  __int64 v15; // rdx
  int v16; // eax
  __int64 v17; // rdx
  const char *i; // r14
  int v19; // er15
  __int64 result; // rax
  __int64 v21; // rdx
  __int64 v22; // rbx
  int v23[3]; // [rsp+8h] [rbp-68h] BYREF
  int v24; // [rsp+14h] [rbp-5Ch]
  int v25; // [rsp+18h] [rbp-58h]
  int v26; // [rsp+1Ch] [rbp-54h]
  int v27; // [rsp+20h] [rbp-50h]
  int v28; // [rsp+24h] [rbp-4Ch]
  __int64 v29; // [rsp+28h] [rbp-48h]
  int v30; // [rsp+30h] [rbp-40h]
  int v31; // [rsp+34h] [rbp-3Ch]
  int v32; // [rsp+38h] [rbp-38h]
  int v33; // [rsp+3Ch] [rbp-34h]

  v3 = v23;
  v4 = 0LL;
  sub_43ABE2((__int64)v23, 255LL, 0x38uLL);
  v6 = sub_404863((__int64)a1, v5);
  v7 = (int *)v6;
  if ( (*(_BYTE *)v6 & 8) != 0 )
    v4 = v6[1];
  v23[0] = sub_406092((unsigned int *)v6);
  v23[1] = *v7;
  sub_40779C(a1, a2, a3);
  if ( v4 )
  {
    sub_406F18(a1, v4, a2, a3);
    sub_403911(a1, -2, (__int64)"hptr", 4uLL, a2, a3);
    v8 = *(_DWORD *)(v4 + 4);
    v33 = 0;
    v23[2] = v8;
    v9 = *(_DWORD *)v4;
    v10 = *(_DWORD *)v4 & 3;
    switch ( v10 )
    {
      case 1:
        if ( (v9 & 0x400000) != 0 )
        {
          v24 = 64;
        }
        else if ( (v9 & 0x800) != 0 )
        {
          v24 = 104;
        }
        else if ( (v9 & 0x1000) != 0 )
        {
          v24 = 72;
        }
        else if ( v9 >> 27 == 18 )
        {
          v11 = *(unsigned __int8 *)(v4 + 73);
          v24 = 576;
          v32 = v11;
        }
        else if ( (v9 & 0x2000) != 0 )
        {
          v24 = 88;
        }
        else
        {
          v24 = 56;
        }
        v25 = *(_DWORD *)v4 >> 27;
        v12 = *(_DWORD *)(v4 + 40);
        v13 = 16 * *(_DWORD *)(v4 + 48);
        v29 = *(_QWORD *)(v4 + 48);
        v14 = *(_DWORD *)(v4 + 52);
        v27 = v12;
        v26 = 25 * v12 + v13 + 4 * v14 + (-v12 & 7);
        v28 = *(_DWORD *)(v4 + 44);
        if ( _bittest((const signed __int32 *)v4, 0xBu) )
        {
          v15 = *(_QWORD *)(v4 + 56);
          v16 = 0;
          if ( v15 )
            v16 = *(_DWORD *)(v15 + 24);
          v30 = v16;
        }
        break;
      case 2:
        v17 = *(_QWORD *)(v4 + 24);
        if ( (v9 & 0x80u) == 0 )
        {
          v24 = v17 + 32;
        }
        else
        {
          if ( (v9 & 0x100) != 0 )
            v33 = 2;
          else
            v33 = 1;
          v24 = 40;
          v31 = v17;
        }
        break;
      case 0:
        v24 = *(_DWORD *)(v4 + 24) + 33;
        break;
    }
  }
  for ( i = "type"; ; i = (const char *)v22 )
  {
    result = sub_43AD53(i);
    v22 = (__int64)&i[result + 1];
    if ( !result )
      break;
    v19 = *v3++;
    if ( v19 >= 0 )
    {
      sub_406D71(a1, (__int64)i, v21, a2, a3);
      sub_406A68(a1, v19, a2, a3);
      sub_40388B(a1, -3, a2, a3);
    }
  }
  return result;
}
// 42EBA3: variable 'v5' is possibly undefined
// 42ED41: variable 'v21' is possibly undefined
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (000000000042ED6F) ----------------------------------------------------
__int64 __fastcall sub_42ED6F(__int64 *a1, __int64 a2, __m128 a3, __m128 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int128 *v8; // r13
  unsigned int v9; // er14
  int v10; // eax

  v6 = sub_412200((__int64)a1, a2);
  if ( !v6 )
    return sub_4068D1(a1, a2, a6, a3, a4);
  v8 = (__int128 *)v6;
  sub_40779C(a1, a3, a4);
  v9 = sub_412000((__int64)a1, (__int64)v8);
  sub_406883(a1, v8, a3, a4);
  sub_406AAF(a1, v9, a3, a4);
  sub_403A07(a1, -196518, a3, a4);
  v10 = sub_4202D0(a1, -1, v9, a3, a4);
  sub_406AAF(a1, v10, a3, a4);
  sub_403A07(a1, -196517, a3, a4);
  return sub_403A07(a1, -130939, a3, a4);
}

//----- (000000000042EE0D) ----------------------------------------------------
double __fastcall sub_42EE0D(double a1)
{
  return (((((0.00003479331075960212 * a1 + 0.0007915349942898145) * a1 - 0.04005553450067941) * a1 + 0.2012125321348629)
         * a1
         - 0.3255658186224009)
        * a1
        + 0.1666666666666667)
       * a1
       / ((((0.07703815055590194 * a1 - 0.6882839716054533) * a1 + 2.020945760233506) * a1 - 2.403394911734414) * a1
        + 1.0);
}

//----- (000000000042EE95) ----------------------------------------------------
void __fastcall sub_42EE95(double a1)
{
  unsigned int v1; // eax

  v1 = HIDWORD(a1) & 0x7FFFFFFF;
  if ( (HIDWORD(a1) & 0x7FFFFFFFu) <= 0x3FEFFFFF )
  {
    if ( v1 > 0x3FDFFFFF )
    {
      if ( a1 >= 0.0 )
        sub_42EE0D((1.0 - a1) * 0.5);
      else
        sub_42EE0D((a1 + 1.0) * 0.5);
    }
    else if ( v1 > 0x3C600000 )
    {
      sub_42EE0D(a1 * a1);
    }
  }
}

//----- (000000000042EFC4) ----------------------------------------------------
double __fastcall sub_42EFC4(double a1)
{
  return (((((0.00003479331075960212 * a1 + 0.0007915349942898145) * a1 - 0.04005553450067941) * a1 + 0.2012125321348629)
         * a1
         - 0.3255658186224009)
        * a1
        + 0.1666666666666667)
       * a1
       / ((((0.07703815055590194 * a1 - 0.6882839716054533) * a1 + 2.020945760233506) * a1 - 2.403394911734414) * a1
        + 1.0);
}

//----- (000000000042F04C) ----------------------------------------------------
__m128 __fastcall sub_42F04C(__m128 a1)
{
  __m128 v1; // xmm3
  unsigned __int32 v2; // eax
  double v3; // xmm3_8
  __int128 v4; // xmm0
  int v5; // edx
  double v6; // xmm0_8
  double v7; // xmm4_8
  unsigned int v8; // eax
  double v9; // xmm3_8
  double v10; // xmm0_8
  double v11; // xmm5_8

  v1 = a1;
  v2 = a1.i32[1] & 0x7FFFFFFF;
  if ( (a1.i32[1] & 0x7FFFFFFFu) <= 0x3FEFFFFF )
  {
    if ( v2 > 0x3FDFFFFF )
    {
      v1 = _mm_and_ps(a1, (__m128)xmmword_43EEA0);
      *(double *)v1.i64 = 0.5 * (1.0 - *(double *)v1.i64);
      v6 = sub_42EFC4(*(double *)v1.i64);
      if ( v8 <= 0x3FEF3332 )
      {
        v11 = 6.123233995736766e-17
            - ((*(double *)v1.i64
              - COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL)
              * COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL))
             / (v7 + COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL))
             + (*(double *)v1.i64
              - COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL)
              * COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL))
             / (v7 + COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL)));
        v9 = 0.7853981633974483;
        v10 = v6 * (v7 + v7)
            - v11
            - (0.7853981633974483
             - (COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL)
              + COERCE_DOUBLE(*(_QWORD *)&v7 & 0xFFFFFFFF00000000LL)));
      }
      else
      {
        v9 = 1.570796326794897;
        v10 = v6 * v7 + v7 + v6 * v7 + v7 - 6.123233995736766e-17;
      }
      *(double *)v1.i64 = v9 - v10;
      if ( v5 < 0 )
        return _mm_xor_ps(v1, (__m128)xmmword_43D2F0);
    }
    else if ( v2 - 0x100000 > 0x3E3FFFFF )
    {
      *(double *)v1.i64 = *(double *)a1.i64 + sub_42EFC4(*(double *)a1.i64 * *(double *)a1.i64) * *(double *)a1.i64;
    }
    return v1;
  }
  else
  {
    if ( a1.i32[0] | (v2 - 1072693248) )
    {
      v3 = *(double *)a1.i64 - *(double *)a1.i64;
      v4 = 0LL;
      *(double *)&v4 = 0.0 / v3;
      return (__m128)v4;
    }
    else
    {
      *(double *)v1.i64 = *(double *)a1.i64 * 1.570796326794897 + 7.52316384526264e-37;
    }
    return v1;
  }
}
// 42F105: variable 'v8' is possibly undefined
// 42F107: variable 'v7' is possibly undefined
// 42F180: variable 'v5' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000042F192) ----------------------------------------------------
void __fastcall sub_42F192(__m128 a1, double a2)
{
  unsigned __int32 v2; // eax
  unsigned int v3; // edx

  if ( (*(_QWORD *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FF0000000000000LL
    && (a1.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FF0000000000000LL )
  {
    if ( LODWORD(a2) | (HIDWORD(a2) - 1072693248) )
    {
      v2 = a1.i32[1] & 0x7FFFFFFF;
      if ( a1.i32[1] & 0x7FFFFFFF | _mm_cvtsi128_si32((__m128i)a1) )
      {
        v3 = HIDWORD(a2) & 0x7FFFFFFF;
        if ( HIDWORD(a2) & 0x7FFFFFFF | LODWORD(a2) )
        {
          if ( v3 != 2146435072
            && v3 + 0x4000000 >= v2
            && v2 != 2146435072
            && (!((a1.i64[0] < 0) & 2 | (HIDWORD(a2) >> 30) & 2) || v2 + 0x4000000 >= v3) )
          {
            *(double *)a1.i64 = *(double *)a1.i64 / a2;
            sub_42F31C(_mm_and_ps(a1, (__m128)xmmword_43EEA0));
          }
        }
      }
    }
    else
    {
      sub_42F31C(a1);
    }
  }
}
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43EEA0: using guessed type __int128 xmmword_43EEA0;

//----- (000000000042F31C) ----------------------------------------------------
__m128 __fastcall sub_42F31C(__m128 result)
{
  unsigned __int64 v1; // rdi
  unsigned __int64 v2; // rcx
  unsigned __int32 v3; // edx
  __int64 v4; // rax
  double v5; // xmm2_8
  double v6; // xmm1_8

  v1 = (unsigned __int64)result.i64[0] >> 63;
  v2 = (unsigned __int64)result.i64[0] >> 63;
  v3 = result.i32[1] & 0x7FFFFFFF;
  if ( (result.i32[1] & 0x7FFFFFFFu) <= 0x440FFFFF )
  {
    if ( v3 > 0x3FDBFFFF )
    {
      result = _mm_and_ps(result, (__m128)xmmword_43EEA0);
      if ( v3 > 0x3FF2FFFF )
      {
        if ( v3 > 0x40037FFF )
        {
          v4 = 3LL;
          *(double *)result.i64 = -1.0 / *(double *)result.i64;
        }
        else
        {
          v4 = 2LL;
          *(double *)result.i64 = (*(double *)result.i64 - 1.5) / (*(double *)result.i64 * 1.5 + 1.0);
        }
      }
      else if ( v3 > 0x3FE5FFFF )
      {
        v4 = 1LL;
        *(double *)result.i64 = (*(double *)result.i64 - 1.0) / (*(double *)result.i64 + 1.0);
      }
      else
      {
        v4 = 0LL;
        *(double *)result.i64 = (*(double *)result.i64 + *(double *)result.i64 - 1.0) / (*(double *)result.i64 + 2.0);
      }
    }
    else
    {
      v4 = -1LL;
      if ( v3 <= 0x3E3FFFFF )
        return result;
    }
    v5 = *(double *)result.i64 * *(double *)result.i64;
    v6 = ((((((0.01628582011536578 * (v5 * v5) + 0.04976877994615932) * (v5 * v5) + 0.06661073137387531) * (v5 * v5)
           + 0.09090887133436507)
          * (v5
           * v5)
          + 0.1428571427250347)
         * (v5
          * v5)
         + 0.3333333333333293)
        * v5
        + ((((-0.03653157274421692 * (v5 * v5) - 0.05833570133790573) * (v5 * v5) - 0.0769187620504483) * (v5 * v5)
          - 0.1111111040546236)
         * (v5
          * v5)
         - 0.1999999999987648)
        * (v5
         * v5))
       * *(double *)result.i64;
    if ( (_DWORD)v4 == -1 )
    {
      *(double *)result.i64 = *(double *)result.i64 - v6;
    }
    else
    {
      *(double *)result.i64 = *(double *)&qword_442940[v4] - (v6 - *(double *)&qword_442920[v4] - *(double *)result.i64);
      if ( (_DWORD)v2 )
        return _mm_xor_ps(result, (__m128)xmmword_43D2F0);
    }
  }
  else if ( (result.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FF0000000000000LL )
  {
    *(double *)result.i64 = -1.570796326794897;
    if ( !(_DWORD)v1 )
      *(double *)result.i64 = 1.570796326794897;
  }
  return result;
}
// 42F31C: could not find valid save-restore pair for rbp
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43EEA0: using guessed type __int128 xmmword_43EEA0;
// 442920: using guessed type __int64 qword_442920[];
// 442940: using guessed type __int64 qword_442940[];

//----- (000000000042F501) ----------------------------------------------------
unsigned __int64 __fastcall sub_42F501(double a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // rax
  double v3; // rdx
  double v4; // xmm2_8
  double v5; // [rsp-10h] [rbp-10h]

  v5 = a1;
  result = HIDWORD(a1) & 0x7FFFFFFF;
  if ( (unsigned int)result <= 0x7FEFFFFF )
  {
    if ( (HIDWORD(a1) & 0x7FF00000) != 0 )
    {
      v2 = (unsigned int)result / 3 + 715094163;
    }
    else
    {
      v5 = 1.801439850948198e16 * a1;
      result = HIDWORD(v5) & 0x7FFFFFFF;
      if ( (HIDWORD(v5) & 0x7FFFFFFF) == 0 )
        return result;
      v2 = (unsigned int)result / 3 + 696219795;
    }
    *(_QWORD *)&v3 = (v2 << 32) | *(_QWORD *)&v5 & 0x8000000000000000LL;
    v4 = v3 * v3 * (v3 / a1);
    return (COERCE__INT64(
              (v4 * (1.621429720105354 * v4 - 1.884979795433772)
             + 1.87595182427177
             + v4 * v4 * v4 * (0.1459961928866124 * v4 - 0.758397934778766))
            * v3)
          + 0x80000000LL) & 0xFFFFFFFFC0000000LL;
  }
  return result;
}
// 42F501: could not find valid save-restore pair for rbp

//----- (000000000042F63A) ----------------------------------------------------
__int64 __fastcall sub_42F63A(double a1)
{
  return (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
}
// 42F63A: could not find valid save-restore pair for rbp

//----- (000000000042F6D7) ----------------------------------------------------
void __fastcall sub_42F6D7(double a1, double a2, double a3, double a4, __m128 a5)
{
  __int64 v5; // rbp
  unsigned int v6; // eax
  double v7; // xmm1_8
  int v8; // eax
  double v9; // [rsp-18h] [rbp-18h] BYREF
  double v10; // [rsp-10h] [rbp-10h]
  __int64 v11; // [rsp-8h] [rbp-8h]

  v11 = v5;
  v6 = HIDWORD(a1) & 0x7FFFFFFF;
  if ( (HIDWORD(a1) & 0x7FFFFFFFu) <= 0x3FE921FB )
  {
    if ( v6 <= 0x3E46A09D )
    {
      v9 = a1 + 1.329227995784916e36;
      return;
    }
    v7 = 0.0;
    goto LABEL_9;
  }
  if ( v6 > 0x7FEFFFFF )
    return;
  v8 = sub_430953(&v9, a1, a2, a3, a4, a5) & 3;
  v7 = v10;
  a1 = v9;
  if ( v8 != 1 )
  {
    if ( v8 == 2 )
    {
      sub_4316BD(v9, v10);
      return;
    }
    if ( !v8 )
    {
LABEL_9:
      sub_4316BD(a1, v7);
      return;
    }
  }
  sub_43149B(1, v9, v10);
}
// 42F6D7: could not find valid save-restore pair for rbp
// 42F6DC: variable 'v5' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (000000000042F775) ----------------------------------------------------
double __fastcall sub_42F775(double result)
{
  __int64 v1; // rdx
  double v2; // rsi
  double v3; // rax
  double v4; // xmm0_8
  double v5; // xmm0_8
  double v6; // xmm2_8
  double v7; // xmm0_8
  double v8; // xmm0_8

  v1 = (*(_QWORD *)&result >> 52) & 0x7FFLL;
  if ( (unsigned int)(v1 - 969) <= 0x3E )
  {
LABEL_11:
    v2 = 184.6649652337873 * result + 6.755399441055744e15;
    *(_QWORD *)&v3 = qword_442A98[2 * (LOBYTE(v2) & 0x7F)] + (*(_QWORD *)&v2 << 45);
    v4 = result
       + -0.005415212348111709 * (v2 - 6.755399441055744e15)
       + (v2 - 6.755399441055744e15) * -1.286402311163835e-14;
    v5 = (v4 * 0.008333335853059549 + 0.0416666808410674) * (v4 * v4 * (v4 * v4))
       + (0.1666666666666589 * v4 + 0.4999999999999679) * (v4 * v4)
       + *(double *)&qword_442A90[2 * (LOBYTE(v2) & 0x7F)]
       + v4;
    if ( (_DWORD)v1 )
      return v5 * v3 + v3;
    if ( SLODWORD(v2) >= 0 )
      return (v5 * COERCE_DOUBLE(*(_QWORD *)&v3 - 0x3F10000000000000LL)
            + COERCE_DOUBLE(*(_QWORD *)&v3 - 0x3F10000000000000LL))
           * 5.486124068793689e303;
    v6 = v5 * COERCE_DOUBLE(*(_QWORD *)&v3 + 0x3FE0000000000000LL);
    v7 = COERCE_DOUBLE(*(_QWORD *)&v3 + 0x3FE0000000000000LL) + v6;
    if ( v7 >= 1.0 )
      return v7 * 2.225073858507201e-308;
    v8 = v7 + 1.0 - (v7 + 1.0) + v6 + COERCE_DOUBLE(*(_QWORD *)&v3 + 0x3FE0000000000000LL) - v7 + v7 + 1.0 - 1.0;
    if ( v8 == 0.0 )
      v8 = 0.0;
    return v8 * 2.225073858507201e-308;
  }
  if ( (int)v1 - 969 < 0 )
    return result + 1.0;
  if ( (unsigned int)v1 <= 0x408 )
  {
    LODWORD(v1) = 0;
    goto LABEL_11;
  }
  if ( result == -INFINITY )
    return 0.0;
  if ( (_DWORD)v1 == 2047 )
    return result + 1.0;
  if ( result < 0.0 )
    return sub_430322(0);
  sub_430315();
  return result;
}
// 442A90: using guessed type __int64 qword_442A90[];
// 442A98: using guessed type __int64 qword_442A98[];

//----- (000000000042F94A) ----------------------------------------------------
__int64 __fastcall sub_42F94A(double a1)
{
  return (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
}
// 42F94A: could not find valid save-restore pair for rbp

//----- (000000000042F9DE) ----------------------------------------------------
double __fastcall sub_42F9DE(double result, double a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 i; // rax
  unsigned __int64 v5; // rax
  __int64 v6; // r8
  __int64 j; // rcx
  __int64 v8; // rsi
  __int64 v9; // rcx
  unsigned __int64 v10; // rax

  v2 = 2LL * *(_QWORD *)&a2;
  if ( !(2LL * *(_QWORD *)&a2) )
    return result * a2 / (result * a2);
  v3 = (*(_QWORD *)&result >> 52) & 0x7FFLL;
  if ( (*(_QWORD *)&a2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FF0000000000000LL || (_DWORD)v3 == 2047 )
    return result * a2 / (result * a2);
  if ( v2 >= 2LL * *(_QWORD *)&result )
  {
    if ( v2 != 2LL * *(_QWORD *)&result )
      return result;
    return result * 0.0;
  }
  if ( (_DWORD)v3 )
  {
    v5 = *(_QWORD *)&result & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
  }
  else
  {
    for ( i = *(_QWORD *)&result << 12; i >= 0; i *= 2LL )
      v3 = (unsigned int)(v3 - 1);
    v5 = *(_QWORD *)&result << (1 - (unsigned __int8)v3);
  }
  v6 = (*(_QWORD *)&a2 >> 52) & 0x7FFLL;
  if ( ((*(_QWORD *)&a2 >> 52) & 0x7FF) != 0 )
  {
    v8 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL | 0x10000000000000LL;
  }
  else
  {
    for ( j = *(_QWORD *)&a2 << 12; j >= 0; j *= 2LL )
      LODWORD(v6) = v6 - 1;
    v8 = *(_QWORD *)&a2 << (1 - (unsigned __int8)v6);
  }
  while ( 1 )
  {
    v9 = v5 - v8;
    if ( (int)v3 <= (int)v6 )
      break;
    if ( v9 >= 0 )
    {
      if ( !v9 )
        return result * 0.0;
      v5 -= v8;
    }
    v5 *= 2LL;
    v3 = (unsigned int)(v3 - 1);
  }
  if ( v9 >= 0 )
  {
    v5 -= v8;
    if ( !v9 )
      return result * 0.0;
  }
  while ( !(v5 >> 52) )
  {
    v5 *= 2LL;
    v3 = (unsigned int)(v3 - 1);
  }
  if ( (int)v3 <= 0 )
    v10 = v5 >> (1 - (unsigned __int8)v3);
  else
    v10 = (v5 - 0x10000000000000LL) | (v3 << 52);
  *(_QWORD *)&result = v10 | *(_QWORD *)&result & 0x8000000000000000LL;
  return result;
}

//----- (000000000042FB3D) ----------------------------------------------------
__int64 __fastcall sub_42FB3D(double a1)
{
  unsigned int v1; // er8

  if ( ((*(_QWORD *)&a1 >> 52) & 0x7FF) != 0 )
  {
    v1 = 4;
    if ( ((*(_QWORD *)&a1 >> 52) & 0x7FF) == 2047 )
      return *(_QWORD *)&a1 << 12 == 0LL;
  }
  else
  {
    return 3 - (unsigned int)(2LL * *(_QWORD *)&a1 == 0);
  }
  return v1;
}

//----- (000000000042FB80) ----------------------------------------------------
double __fastcall sub_42FB80(double result)
{
  double v1; // rax
  int v2; // esi
  unsigned __int64 v3; // rdx
  unsigned int v4; // edx
  double v5; // xmm1_8
  double v6; // xmm5_8
  double v7; // xmm4_8
  double v8; // xmm2_8
  int v9; // eax
  double v10; // rbp

  v1 = result;
  if ( (unsigned int)(HIDWORD(result) - 0x100000) > 0x7FEFFFFF )
  {
    if ( !(2LL * *(_QWORD *)&result) )
      return -1.0 / (result * result);
    if ( result < 0.0 )
      return (result - result) / 0.0;
    v2 = -54;
    v1 = result * 1.801439850948198e16;
    v3 = HIDWORD(COERCE_UNSIGNED_INT64(result * 1.801439850948198e16));
    goto LABEL_10;
  }
  if ( HIDWORD(result) <= 0x7FEFFFFF )
  {
    v2 = 0;
    LODWORD(v3) = HIDWORD(result);
    if ( HIDWORD(result) != 1072693248 || (result = 0.0, *(_QWORD *)&v1 << 32) )
    {
LABEL_10:
      v4 = v3 + 614242;
      v5 = COERCE_DOUBLE(LODWORD(v1) | (((v4 & 0xFFFFF) + 1072079006LL) << 32)) - 1.0;
      v6 = 0.5 * v5 * v5;
      v7 = v5 / (v5 + 2.0) * (v5 / (v5 + 2.0));
      v8 = (((0.1479819860511659 * (v7 * v7) + 0.1818357216161805) * (v7 * v7) + 0.2857142874366239) * (v7 * v7)
          + 0.6666666666666735)
         * v7
         + ((0.1531383769920937 * (v7 * v7) + 0.2222219843214978) * (v7 * v7) + 0.3999999999940942) * (v7 * v7)
         + v6;
      v9 = v2 + (v4 >> 20) - 1023;
      v10 = v5 - v6;
      return 0.3010299956636118 * (double)v9
           - (COERCE_DOUBLE(*(_QWORD *)&v10 & 0xFFFFFFFF00000000LL) * 0.4342944818781689
            + 0.3010299956636118 * (double)v9)
           + COERCE_DOUBLE(*(_QWORD *)&v10 & 0xFFFFFFFF00000000LL) * 0.4342944818781689
           + (v8 * (v5 / (v5 + 2.0)) + v5 - COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v5 - v6) & 0xFFFFFFFF00000000LL) - v6)
           * 0.4342944818781689
           + (COERCE_DOUBLE(*(_QWORD *)&v10 & 0xFFFFFFFF00000000LL)
            + v8 * (v5 / (v5 + 2.0))
            + v5
            - COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v5 - v6) & 0xFFFFFFFF00000000LL)
            - v6)
           * 2.508294671164528e-11
           + (double)v9 * 3.694239077158931e-13
           + COERCE_DOUBLE(*(_QWORD *)&v10 & 0xFFFFFFFF00000000LL) * 0.4342944818781689
           + 0.3010299956636118 * (double)v9;
    }
  }
  return result;
}

//----- (000000000042FD67) ----------------------------------------------------
double __fastcall sub_42FD67(double result)
{
  double v1; // rax
  __int64 v2; // rdx
  double v3; // xmm0_8
  double v4; // xmm2_8
  double v5; // xmm7_8
  double v6; // xmm4_8
  double v7; // xmm0_8
  __int64 v8; // rcx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rax
  double v12; // xmm3_8
  double v13; // xmm2_8
  double v14; // xmm5_8
  double v15; // [rsp-10h] [rbp-10h]

  v1 = result;
  v2 = HIWORD(*(_QWORD *)&result);
  if ( (unsigned __int64)(*(_QWORD *)&result - 0x3FEEA4AF00000000LL) > 0x210A9FFFFFFFFLL )
  {
    if ( (unsigned int)(v2 - 16) > 0x7FDF )
    {
      if ( !(2LL * *(_QWORD *)&result) )
        return -1.0 / 0.0;
      if ( result == INFINITY )
        return result;
      if ( (v2 & 0x8000) != 0 || (HIWORD(result) & 0x7FF0) == 32752 )
        return sub_43030C(result);
      *(_QWORD *)&v1 = COERCE__INT64(result * 4.503599627370496e15) - 0x340000000000000LL;
    }
    v8 = (*(_QWORD *)&v1 - 0x3FE6000000000000LL) >> 52;
    *(_QWORD *)&v15 = *(_QWORD *)&v1 - ((*(_QWORD *)&v1 - 0x3FE6000000000000LL) & 0xFFF0000000000000LL);
    v9 = ((unsigned __int64)(*(_QWORD *)&v1 - 0x3FE6000000000000LL) >> 46) & 0x3F;
    v10 = v9 + 73;
    v11 = 2 * (v9 + 9);
    v12 = (double)(int)v8 + *(double *)&qword_443308[v11];
    v13 = (v15 - *(double *)&qword_443300[2 * v10] - *(double *)&qword_443308[2 * v10]) * *(double *)&qword_443300[v11];
    v14 = COERCE_DOUBLE(*(_QWORD *)&v13 & 0xFFFFFFFF00000000LL) * 1.442695040721446;
    v6 = v14 + v12;
    v7 = v12
       - (v14
        + v12)
       + v14
       + v13 * 1.675171316488651e-10
       + (v13 - COERCE_DOUBLE(*(_QWORD *)&v13 & 0xFFFFFFFF00000000LL)) * 1.442695040721446
       + ((0.2885390073180969 * v13 + -0.3606737595407591) * (v13 * v13)
        + 0.4808983469629985 * v13
        + -0.7213475204444882
        + (0.2061202382173603 * v13 + -0.2404693555628422) * (v13 * v13 * (v13 * v13)))
       * (v13
        * v13);
    return v7 + v6;
  }
  if ( result != 1.0 )
  {
    v3 = result - 1.0;
    v4 = COERCE_DOUBLE(*(_QWORD *)&v3 & 0xFFFFFFFF00000000LL) * 1.442695040721446;
    v5 = (0.4808983469629874 * v3 + -0.7213475204444817) * (v3 * v3);
    v6 = v4 + v5;
    v7 = (((0.1304682681128383 * v3 + -0.1448331657670127) * (v3 * v3) + 0.1603032746063156 * v3 + -0.1803359670532786)
        * (v3
         * v3
         * (v3
          * v3))
        + 0.2885390081805197 * v3
        + -0.360673760222145
        + v3 * v3 * (0.2060992861022954 * v3 + -0.2404491740572886))
       * (v3
        * v3
        * (v3
         * v3))
       + v4
       - (v4
        + v5)
       + v5
       + 1.675171316488651e-10 * v3
       + (v3 - COERCE_DOUBLE(*(_QWORD *)&v3 & 0xFFFFFFFF00000000LL)) * 1.442695040721446;
    return v7 + v6;
  }
  return 0.0;
}
// 42FD67: could not find valid save-restore pair for rbp
// 443300: using guessed type __int64 qword_443300[];
// 443308: using guessed type __int64 qword_443308[];

//----- (000000000043030C) ----------------------------------------------------
double __fastcall sub_43030C(double a1)
{
  return (a1 - a1) / (a1 - a1);
}

//----- (0000000000430315) ----------------------------------------------------
void sub_430315()
{
  JUMPOUT(0x43032FLL);
}
// 43031D: control flows out of bounds to 43032F

//----- (0000000000430322) ----------------------------------------------------
double __fastcall sub_430322(int a1)
{
  double v1; // xmm1_8

  v1 = 1.288229753919427e-231;
  if ( a1 )
    v1 = -1.288229753919427e-231;
  return 1.288229753919427e-231 * v1;
}
// 430322: could not find valid save-restore pair for rbp
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (0000000000430355) ----------------------------------------------------
unsigned __int64 __fastcall sub_430355(unsigned __int64 a1)
{
  unsigned __int64 result; // rax

  result = 0LL;
  if ( ((a1 >> 52) & 0x7FF) > 0x3FE )
  {
    result = 2LL;
    if ( ((a1 >> 52) & 0x7FF) <= 0x433 )
    {
      result = 0LL;
      if ( (a1 & ~(-1LL << (51 - (unsigned __int8)(a1 >> 52)))) == 0 )
        return 2 - ((a1 >> (51 - (unsigned __int8)(a1 >> 52))) & 1);
    }
  }
  return result;
}

//----- (00000000004303AD) ----------------------------------------------------
void __fastcall sub_4303AD(double a1, double a2)
{
  double v2; // rsi
  __int64 v3; // r9
  int v4; // edx
  int v5; // er8
  int v6; // eax
  __int16 v7; // r10
  unsigned int v8; // ecx
  int v9; // edi
  double v10; // xmm0_8
  unsigned __int64 v11; // rax
  double v12; // xmm2_8
  __int64 v13; // xmm3_8
  double v14; // xmm6_8
  double v15; // xmm2_8
  double v16; // xmm7_8
  double v17; // xmm11_8
  double v18; // xmm9_8
  double v19; // xmm8_8
  double v20; // xmm6_8
  unsigned __int64 v21; // rdx
  double v22; // [rsp-38h] [rbp-38h]

  v2 = a1;
  v3 = *(_QWORD *)&a2 >> 52;
  v4 = *(_QWORD *)&a1 >> 52;
  if ( (unsigned int)(v4 - 1) > 0x7FD || (v5 = 0, (unsigned int)(v3 & 0x7FF) - 958 > 0x7F) )
  {
    if ( (unsigned __int64)(2LL * *(_QWORD *)&a2 - 1) > 0xFFDFFFFFFFFFFFFELL )
      return;
    if ( (unsigned __int64)(2LL * *(_QWORD *)&a1 - 1) > 0xFFDFFFFFFFFFFFFELL )
    {
      if ( a1 < 0.0 )
        sub_430355(*(unsigned __int64 *)&a2);
      return;
    }
    v5 = 0;
    if ( a1 < 0.0 )
    {
      v6 = sub_430355(*(unsigned __int64 *)&a2);
      if ( !v6 )
      {
        sub_43030C(a1);
        return;
      }
      if ( v6 == 1 )
        v5 = 0x40000;
      *(_QWORD *)&v2 = *(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL;
      v4 = v7 & 0x7FF;
    }
    v8 = v3 & 0x7FF;
    if ( v8 - 958 > 0x7F )
    {
      if ( v2 != 1.0 && v8 > 0x3BD )
      {
        v9 = 0;
        if ( *(_QWORD *)&v2 <= 0x3FF0000000000000uLL == (unsigned int)v3 <= 0x7FF )
          goto LABEL_25;
        goto LABEL_26;
      }
      return;
    }
    if ( !v4 )
      *(_QWORD *)&v2 = COERCE__INT64(fabs(a1 * 4.503599627370496e15)) - 0x340000000000000LL;
  }
  v10 = (double)((*(_QWORD *)&v2 - 0x3FE6955500000000LL) >> 52);
  v11 = ((unsigned __int64)(*(_QWORD *)&v2 - 0x3FE6955500000000LL) >> 45) & 0x7F;
  *(_QWORD *)&v12 = *(_QWORD *)&v2 - ((*(_QWORD *)&v2 - 0x3FE6955500000000LL) & 0xFFF0000000000000LL);
  v13 = qword_444C88[4 * v11];
  *(_QWORD *)&v22 = (*(_QWORD *)&v12 + 0x80000000LL) & 0xFFFFFFFF00000000LL;
  v14 = v22 * *(double *)&v13 - 1.0;
  v15 = (v12 - v22) * *(double *)&v13;
  v16 = 0.6931471805598903 * v10 + *(double *)&qword_444C98[4 * v11];
  v17 = v14 + v15;
  v18 = (v14 + v15) * -0.5;
  v19 = v14 + v15 + v16;
  v20 = v19
      + v14 * (-0.5 * v14)
      + (((1.000041526367554 * (v14 + v15) + -1.142909628459501) * ((v14 + v15) * v18)
        + -0.6666666663487739 * (v14 + v15)
        + 0.7999999995323976)
       * ((v14 + v15)
        * v18)
       + 0.5000000000000007 * v17
       + -0.6666666666666679)
      * ((v14 + v15)
       * v18
       * v17)
      + v10 * 5.497923018708371e-14
      + *(double *)&qword_444CA0[4 * v11]
      + v17
      + v16
      - v19
      + v15 * (v18 + -0.5 * v14)
      + v14 * (-0.5 * v14)
      + v19
      - (v19
       + v14 * (-0.5 * v14));
  v21 = (COERCE_UNSIGNED_INT64(COERCE_DOUBLE(*(_QWORD *)&a2 & 0xFFFFFFFFF8000000LL) * COERCE_DOUBLE(*(_QWORD *)&v20 & 0xFFFFFFFFF8000000LL)) >> 52) & 0x7FF;
  if ( (unsigned int)(v21 - 969) > 0x3E && (int)v21 - 969 >= 0 && (unsigned int)v21 > 0x408 )
  {
    v9 = v5;
    if ( COERCE__INT64(COERCE_DOUBLE(*(_QWORD *)&a2 & 0xFFFFFFFFF8000000LL) * COERCE_DOUBLE(*(_QWORD *)&v20 & 0xFFFFFFFFF8000000LL)) < 0 )
    {
LABEL_25:
      sub_430322(v9);
      return;
    }
LABEL_26:
    sub_430315();
  }
}
// 4303AD: could not find valid save-restore pair for rbp
// 4304FD: variable 'v7' is possibly undefined
// 430506: variable 'v3' is possibly undefined
// 43079D: variable 'v5' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 43EEA0: using guessed type __int128 xmmword_43EEA0;
// 444C88: using guessed type __int64 qword_444C88[];
// 444C98: using guessed type __int64 qword_444C98[];
// 444CA0: using guessed type __int64 qword_444CA0[];

//----- (0000000000430953) ----------------------------------------------------
__int64 __fastcall sub_430953(double *a1, double a2, double a3, double a4, double a5, __m128 a6)
{
  unsigned int v6; // edx
  __int64 v7; // r12
  double v8; // xmm0_8
  __int64 result; // rax
  double v10; // xmm0_8
  double v11; // xmm0_8
  double v12; // xmm0_8
  double v13; // xmm0_8
  double v14; // xmm0_8
  double v15; // xmm0_8
  double v16; // xmm0_8
  double v17; // xmm0_8
  double v18; // xmm0_8
  double v19; // xmm0_8
  double v20; // xmm0_8
  unsigned int v21; // edx
  double v22; // xmm1_8
  double v23; // xmm3_8
  double v24; // xmm0_8
  double v25; // xmm2_8
  double v26; // xmm0_8
  double v27; // xmm0_8
  double v28; // xmm0_8
  int v29; // eax
  __m128 v30; // xmm0
  int v31; // ecx
  __int64 v32; // [rsp-48h] [rbp-50h]
  double v33[2]; // [rsp-38h] [rbp-40h] BYREF
  double v34[6]; // [rsp-28h] [rbp-30h] BYREF

  v6 = HIDWORD(a2) & 0x7FFFFFFF;
  v7 = *(_QWORD *)&a2 >> 63;
  if ( (HIDWORD(a2) & 0x7FFFFFFFu) <= 0x400F6A7A )
  {
    if ( (HIDWORD(a2) & 0xFFFFF) != 598523 )
    {
      if ( v6 > 0x4002D97C )
      {
        if ( a2 < 0.0 )
        {
          v14 = a2 + 3.141592653468251;
          result = 4294967294LL;
          *a1 = v14 + 1.215420101301238e-10;
          v13 = v14 - (v14 + 1.215420101301238e-10) + 1.215420101301238e-10;
        }
        else
        {
          v12 = a2 - 3.141592653468251;
          result = 2LL;
          *a1 = v12 - 1.215420101301238e-10;
          v13 = v12 - (v12 - 1.215420101301238e-10) - 1.215420101301238e-10;
        }
        a1[1] = v13;
      }
      else
      {
        if ( a2 < 0.0 )
        {
          v11 = a2 + 1.570796326734126;
          result = 0xFFFFFFFFLL;
          *a1 = v11 + 6.077100506506192e-11;
          v10 = v11 - (v11 + 6.077100506506192e-11) + 6.077100506506192e-11;
        }
        else
        {
          v8 = a2 - 1.570796326734126;
          result = 1LL;
          *a1 = v8 - 6.077100506506192e-11;
          v10 = v8 - (v8 - 6.077100506506192e-11) - 6.077100506506192e-11;
        }
        a1[1] = v10;
      }
      return result;
    }
    goto LABEL_25;
  }
  if ( v6 > 0x401C463B )
  {
    if ( v6 > 0x413921FA )
    {
      if ( v6 > 0x7FEFFFFF )
      {
        v27 = a2 - a2;
        result = 0LL;
        a1[1] = v27;
        *a1 = v27;
        return result;
      }
      v32 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL | 0x4160000000000000LL;
      v28 = (double)(int)*(double *)&v32;
      v34[0] = v28;
      v30.i64[1] = a6.i64[1];
      v29 = (int)((*(double *)&v32 - v28) * 16777216.0);
      v34[1] = (double)v29;
      *(double *)v30.i64 = ((*(double *)&v32 - v28) * 16777216.0 - (double)v29) * 16777216.0;
      v34[2] = *(double *)v30.i64;
      if ( *(double *)v30.i64 == 0.0 )
        v31 = v29 != 0;
      else
        v31 = 2;
      result = sub_430D42((__int64)v34, v33, (v6 >> 20) - 1046, v31 + 1, 1, v30, (__m128)0LL);
      v26 = v33[1];
      if ( v7 )
      {
        result = (unsigned int)-(int)result;
        *(_QWORD *)a1 = *(_QWORD *)&v33[0] ^ 0x8000000000000000LL;
        a1[1] = -v26;
        return result;
      }
      *a1 = v33[0];
      goto LABEL_39;
    }
    goto LABEL_25;
  }
  if ( v6 <= 0x4015FDBC )
  {
    if ( v6 != 1074977148 )
    {
      if ( a2 < 0.0 )
      {
        v17 = a2 + 4.712388980202377;
        result = 4294967293LL;
        *a1 = v17 + 1.823130151951858e-10;
        v16 = v17 - (v17 + 1.823130151951858e-10) + 1.823130151951858e-10;
      }
      else
      {
        v15 = a2 - 4.712388980202377;
        result = 3LL;
        *a1 = v15 - 1.823130151951858e-10;
        v16 = v15 - (v15 - 1.823130151951858e-10) - 1.823130151951858e-10;
      }
      a1[1] = v16;
      return result;
    }
LABEL_25:
    v21 = v6 >> 20;
    v22 = 0.6366197723675814 * a2 + 6.755399441055744e15 - 6.755399441055744e15;
    result = (unsigned int)(int)v22;
    v23 = 6.077100506506192e-11 * v22;
    v24 = a2 - 1.570796326734126 * v22;
    if ( (int)(v21 - ((COERCE_UNSIGNED_INT64(v24 - 6.077100506506192e-11 * v22) >> 52) & 0x7FF)) > 16 )
    {
      v25 = v24 - 6.077100506303966e-11 * v22;
      v23 = 2.022266248795951e-21 * v22 - (v24 - v25 - 6.077100506303966e-11 * v22);
      if ( (int)(v21 - ((COERCE_UNSIGNED_INT64(v25 - v23) >> 52) & 0x7FF)) > 49 )
      {
        v24 = v25 - 2.022266248711166e-21 * v22;
        v23 = v22 * 8.4784276603689e-32 - (v25 - v24 - 2.022266248711166e-21 * v22);
        *a1 = v24 - v23;
      }
      else
      {
        *a1 = v25 - v23;
        v24 = v24 - 6.077100506303966e-11 * v22;
      }
    }
    else
    {
      *a1 = v24 - 6.077100506506192e-11 * v22;
    }
    v26 = v24 - *a1 - v23;
LABEL_39:
    a1[1] = v26;
    return result;
  }
  if ( v6 == 1075388923 )
    goto LABEL_25;
  if ( a2 < 0.0 )
  {
    v20 = a2 + 6.283185306936502;
    result = 4294967292LL;
    *a1 = v20 + 2.430840202602477e-10;
    v19 = v20 - (v20 + 2.430840202602477e-10) + 2.430840202602477e-10;
  }
  else
  {
    v18 = a2 - 6.283185306936502;
    result = 4LL;
    *a1 = v18 - 2.430840202602477e-10;
    v19 = v18 - (v18 - 2.430840202602477e-10) - 2.430840202602477e-10;
  }
  a1[1] = v19;
  return result;
}
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (0000000000430D42) ----------------------------------------------------
__int64 __fastcall sub_430D42(__int64 a1, double *a2, int a3, int a4, int a5, __m128 a6, __m128 a7)
{
  __int64 v7; // r9
  int v8; // er10
  __int64 v9; // rax
  int v10; // er12
  int v11; // edx
  __int64 i; // rax
  int v13; // ecx
  __int64 j; // rdx
  double v15; // xmm1_8
  int k; // er14
  int *v17; // rdi
  int v18; // ecx
  double v19; // xmm1_8
  __int64 v20; // rdi
  int v21; // edx
  int v22; // er11
  int v23; // edx
  int v24; // er15
  __int64 v25; // rcx
  int v26; // er11
  int v27; // edi
  int v28; // eax
  int v29; // eax
  __m128 v30; // xmm4
  double v31; // xmm0_8
  int v32; // ebx
  int v33; // edi
  int m; // ecx
  __int64 v35; // r11
  int n; // ecx
  int v37; // edx
  int v38; // edi
  int v39; // eax
  __int64 v40; // rcx
  double v41; // xmm1_8
  __int64 v42; // rcx
  double v43; // xmm0_8
  int v44; // edi
  double v45; // xmm0_8
  int v46; // ecx
  int *v47; // r8
  unsigned __int64 v48; // rax
  double *v49; // rdi
  double v50; // xmm1_8
  double v51; // xmm1_8
  int v52; // edi
  int v53; // er8
  double v54; // xmm0_8
  __int64 ii; // rcx
  double v56; // xmm1_8
  __int64 v57; // rcx
  double v58; // xmm0_8
  double *v59; // rax
  double *v60; // rax
  int v61; // ecx
  double *v62; // rdi
  double v63; // xmm1_8
  int v64; // ecx
  double *v65; // rax
  double v66; // xmm0_8
  __int64 v67; // rax
  double kk; // xmm0_8
  double v69; // xmm2_8
  double v70; // xmm0_8
  double *v71; // rdi
  int jj; // ecx
  double v73; // xmm2_8
  double v74; // xmm0_8
  double v75; // xmm0_8
  unsigned __int64 v76; // xmm2_8
  double v77; // xmm1_8
  int v79; // [rsp+4h] [rbp-28Ch]
  int v80; // [rsp+8h] [rbp-288h]
  __int64 v81; // [rsp+8h] [rbp-288h]
  __int64 v82; // [rsp+10h] [rbp-280h]
  double v83; // [rsp+10h] [rbp-280h]
  double v84; // [rsp+18h] [rbp-278h]
  int v85; // [rsp+18h] [rbp-278h]
  int v87; // [rsp+24h] [rbp-26Ch]
  int v88; // [rsp+28h] [rbp-268h]
  int v89; // [rsp+2Ch] [rbp-264h]
  int v90[60]; // [rsp+30h] [rbp-260h] BYREF
  double v91; // [rsp+120h] [rbp-170h] BYREF
  double v92; // [rsp+128h] [rbp-168h]
  double v93[26]; // [rsp+1C0h] [rbp-D0h] BYREF

  v7 = a1;
  v8 = a4;
  v88 = 0;
  v89 = dword_446810[a5];
  v87 = a4 - 1;
  if ( a3 - 3 >= -23 )
    v88 = (a3 - 3) / 24;
  v9 = 0LL;
  v10 = 24 * ~v88 + a3;
  while ( 1 )
  {
    v11 = v88 - v87 + v9;
    if ( v87 + v89 < (int)v9 )
      break;
    a6 = 0LL;
    if ( v11 >= 0 )
      *(double *)a6.i64 = (double)dword_445D40[v11];
    *(_QWORD *)&v90[2 * v9++ + 20] = a6.i64[0];
  }
  for ( i = 0LL; v89 >= (int)i; ++i )
  {
    a6 = 0LL;
    v13 = v8 + i;
    for ( j = 0LL; ; ++j )
    {
      --v13;
      if ( v87 < (int)j )
        break;
      v15 = *(double *)(a1 + 8 * j);
      *(double *)a6.i64 = *(double *)a6.i64 + v15 * *(double *)&v90[2 * v13 + 20];
    }
    v93[i] = *(double *)a6.i64;
  }
  for ( k = v89; ; k = v39 )
  {
    v17 = v90;
    v18 = k;
    *(double *)a6.i64 = v93[k];
    while ( v18 > 0 )
    {
      --v18;
      ++v17;
      *(double *)a7.i64 = (double)(int)(0.00000005960464477539062 * *(double *)a6.i64);
      *(v17 - 1) = (int)(*(double *)a6.i64 - 16777216.0 * *(double *)a7.i64);
      *(double *)a7.i64 = *(double *)a7.i64 + v93[v18];
      a6 = a7;
    }
    v80 = v8;
    v82 = v7;
    v84 = sub_43140F(v10, *(double *)a6.i64);
    sub_42F94A(v84 * 0.125);
    v7 = v82;
    v8 = v80;
    v19 = v84 - v84 * 0.125 * 8.0;
    v85 = (int)v19;
    *(double *)a7.i64 = v19 - (double)(int)v19;
    if ( v10 > 0 )
    {
      v20 = k - 1;
      v21 = v90[v20] >> (24 - v10);
      LOBYTE(v85) = v21 + v85;
      v22 = v90[v20] - (v21 << (24 - v10));
      v90[v20] = v22;
      v23 = v22 >> (23 - v10);
      goto LABEL_22;
    }
    if ( !v10 )
    {
      v23 = v90[k - 1] >> 23;
LABEL_22:
      v24 = v23;
      if ( v23 <= 0 )
        goto LABEL_41;
      goto LABEL_26;
    }
    v24 = 0;
    if ( *(double *)a7.i64 < 0.5 )
      goto LABEL_41;
    v24 = 2;
LABEL_26:
    LOBYTE(v85) = v85 + 1;
    v25 = 0LL;
    v26 = 0;
    while ( k > (int)v25 )
    {
      v27 = v90[v25];
      if ( v26 )
      {
        v29 = 0xFFFFFF - v27;
        v27 = v26;
        v90[v25] = v29;
      }
      else if ( v27 )
      {
        v28 = 0x1000000 - v27;
        v27 = 1;
        v90[v25] = v28;
      }
      ++v25;
      v26 = v27;
    }
    if ( v10 > 0 )
    {
      if ( v10 == 1 )
      {
        v90[k - 1] &= 0x7FFFFFu;
      }
      else if ( v10 == 2 )
      {
        v90[k - 1] &= 0x3FFFFFu;
      }
    }
    if ( v24 == 2 )
    {
      v30.i64[1] = a6.i64[1];
      *(double *)v30.i64 = 1.0 - *(double *)a7.i64;
      a7 = v30;
      if ( v26 )
      {
        v79 = v80;
        v81 = v82;
        v83 = *(double *)v30.i64;
        v31 = sub_43140F(v10, 1.0);
        v8 = v79;
        v7 = v81;
        *(double *)a7.i64 = v83 - v31;
      }
    }
LABEL_41:
    a6 = 0LL;
    if ( *(double *)a7.i64 != 0.0 )
      break;
    v32 = k - 1;
    v33 = 0;
    for ( m = k - 1; m >= v89; --m )
    {
      v35 = m;
      v33 |= v90[v35];
    }
    if ( v33 )
    {
      while ( 1 )
      {
        v10 -= 24;
        if ( v90[v32] )
          break;
        --v32;
      }
      goto LABEL_61;
    }
    for ( n = 1; !v90[v89 - n]; ++n )
      ;
    v37 = k + 1;
    v38 = k + v8;
    v39 = k + n;
    while ( v39 >= v37 )
    {
      v40 = 0LL;
      *(double *)&v90[2 * v38 + 20] = (double)dword_445D40[v88 + v37];
      a6 = 0LL;
      while ( v87 >= (int)v40 )
      {
        v41 = *(double *)&v90[2 * (v38 - (int)v40) + 20] * *(double *)(v7 + 8 * v40);
        ++v40;
        *(double *)a6.i64 = *(double *)a6.i64 + v41;
      }
      v42 = v37;
      ++v38;
      ++v37;
      v93[v42] = *(double *)a6.i64;
    }
  }
  v43 = sub_43140F(-v10, *(double *)a7.i64);
  if ( v43 < 16777216.0 )
  {
    v32 = k;
    v90[k] = (int)v43;
  }
  else
  {
    v32 = k + 1;
    v10 += 24;
    v44 = (int)(0.00000005960464477539062 * v43);
    v90[k] = (int)(v43 - (double)v44 * 16777216.0);
    v90[k + 1] = v44;
  }
LABEL_61:
  v45 = sub_43140F(v10, 1.0);
  v46 = v32;
  v47 = &v90[v32];
  v48 = 8LL * v32;
  v49 = &v93[v48 / 8];
  while ( v46 >= 0 )
  {
    v50 = (double)*v47;
    --v46;
    --v47;
    --v49;
    v51 = v50 * v45;
    v45 = v45 * 0.00000005960464477539062;
    v49[1] = v51;
  }
  v52 = v32;
  v53 = 0;
  while ( v52 >= 0 )
  {
    v54 = 0.0;
    for ( ii = 0LL; v89 >= (int)ii && (int)ii <= v53; ++ii )
    {
      v56 = v93[v52 + (int)ii] * *(double *)&qword_445D00[ii];
      v54 = v54 + v56;
    }
    v57 = v53;
    --v52;
    ++v53;
    *(&v91 + v57) = v54;
  }
  if ( a5 > 2 )
  {
    if ( a5 == 3 )
    {
      v60 = (double *)((char *)&v91 + v48);
      v61 = v32;
      v62 = v60;
      while ( v61 > 0 )
      {
        --v61;
        v69 = *v62--;
        v70 = *(&v91 + v61);
        v62[1] = v70 - (v70 + v69) + v69;
        *(&v91 + v61) = v70 + v69;
      }
      v71 = v60;
      for ( jj = v32; jj > 1; *(&v91 + jj) = v74 + v73 )
      {
        --jj;
        v73 = *v71--;
        v74 = *(&v91 + jj);
        v71[1] = v74 - (v74 + v73) + v73;
      }
      v75 = 0.0;
      while ( v32 > 1 )
      {
        v75 = v75 + *v60;
        --v32;
        --v60;
      }
      *(double *)&v76 = v91;
      v77 = v92;
      if ( v24 )
      {
        v76 = *(_QWORD *)&v91 ^ 0x8000000000000000LL;
        *(_QWORD *)&v77 = *(_QWORD *)&v92 ^ 0x8000000000000000LL;
        v75 = -v75;
      }
      *a2 = *(double *)&v76;
      a2[1] = v77;
      a2[2] = v75;
    }
  }
  else if ( a5 > 0 )
  {
    v63 = 0.0;
    v64 = v32;
    v65 = (double *)((char *)&v91 + v48);
    while ( v64 >= 0 )
    {
      v63 = v63 + *v65;
      --v64;
      --v65;
    }
    v66 = v63;
    if ( v24 )
      v66 = -v63;
    *a2 = v66;
    v67 = 0LL;
    for ( kk = v91 - v63; v32 >= (int)++v67; kk = kk + *(&v91 + v67) )
      ;
    if ( v24 )
      kk = -kk;
    a2[1] = kk;
  }
  else if ( !a5 )
  {
    v58 = 0.0;
    v59 = (double *)((char *)&v91 + v48);
    while ( v32 >= 0 )
    {
      v58 = v58 + *v59;
      --v32;
      --v59;
    }
    if ( v24 )
      v58 = -v58;
    *a2 = v58;
  }
  return v85 & 7;
}
// 43D2F0: using guessed type __int128 xmmword_43D2F0;
// 445D00: using guessed type __int64 qword_445D00[];
// 445D40: using guessed type int dword_445D40[];
// 446810: using guessed type int dword_446810[];
// 430D42: using guessed type double var_D0[26];

//----- (000000000043140F) ----------------------------------------------------
double __fastcall sub_43140F(int a1, double a2)
{
  int v2; // eax

  if ( a1 <= 1023 )
  {
    v2 = a1;
    if ( a1 < -1022 )
    {
      v2 = a1 + 969;
      a2 = a2 * 2.004168360008973e-292;
      if ( a1 + 969 < -1022 )
      {
        v2 = a1 + 1938;
        a2 = a2 * 2.004168360008973e-292;
        if ( a1 + 1938 < -1022 )
          v2 = -1022;
      }
    }
  }
  else
  {
    v2 = a1 - 1023;
    a2 = a2 * 8.98846567431158e307;
    if ( a1 - 1023 > 1023 )
    {
      v2 = a1 - 2046;
      a2 = a2 * 8.98846567431158e307;
      if ( a1 - 2046 > 1023 )
        v2 = 1023;
    }
  }
  return a2 * COERCE_DOUBLE((unsigned __int64)(unsigned int)(v2 + 1023) << 52);
}

//----- (000000000043149B) ----------------------------------------------------
double __fastcall sub_43149B(int a1, double a2, double a3)
{
  double v3; // xmm4_8
  double v4; // xmm5_8
  double v5; // xmm2_8

  v3 = a2 * a2;
  v4 = a2 * (a2 * a2);
  v5 = (0.000002755731370707007 * (a2 * a2) - 0.0001984126982985795) * (a2 * a2)
     + 0.008333333333322489
     + v3 * v3 * v3 * (1.58969099521155e-10 * (a2 * a2) - 0.00000002505076025340686);
  if ( a1 )
    return a2 - ((0.5 * a3 - v5 * v4) * v3 - a3 + v4 * 0.1666666666666663);
  else
    return a2 + (v5 * v3 - 0.1666666666666663) * v4;
}

//----- (0000000000431539) ----------------------------------------------------
void __fastcall sub_431539(double a1, double a2, double a3, double a4, __m128 a5)
{
  __int64 v5; // rbp
  unsigned int v6; // eax
  double v7; // xmm1_8
  double v8; // xmm1_8
  int v9; // edi
  int v10; // eax
  double v11; // [rsp-18h] [rbp-18h] BYREF
  double v12; // [rsp-10h] [rbp-10h]
  __int64 v13; // [rsp-8h] [rbp-8h]

  v13 = v5;
  v6 = HIDWORD(a1) & 0x7FFFFFFF;
  if ( (HIDWORD(a1) & 0x7FFFFFFFu) > 0x3FE921FB )
  {
    if ( v6 > 0x7FEFFFFF )
      return;
    v10 = sub_430953(&v11, a1, a2, a3, a4, a5) & 3;
    v8 = v12;
    a1 = v11;
    if ( v10 == 1 )
      goto LABEL_16;
    if ( v10 == 2 )
    {
      sub_43149B(1, v11, v12);
      return;
    }
    if ( v10 )
    {
LABEL_16:
      sub_4316BD(v11, v12);
      return;
    }
    v9 = 1;
LABEL_13:
    sub_43149B(v9, a1, v8);
    return;
  }
  if ( v6 > 0x3E4FFFFF )
  {
    v8 = 0.0;
    v9 = 0;
    goto LABEL_13;
  }
  if ( (HIDWORD(a1) & 0x7FF00000) != 0 )
    v7 = a1 + 1.329227995784916e36;
  else
    v7 = a1 * 7.52316384526264e-37;
  v11 = v7;
}
// 431539: could not find valid save-restore pair for rbp
// 43153E: variable 'v5' is possibly undefined
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (00000000004315E8) ----------------------------------------------------
void __fastcall sub_4315E8(
        __m128 a1,
        double a2,
        __m128 a3,
        double a4,
        __m128 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        unsigned __int32 a9)
{
  double v9; // rbp
  __int64 v10; // rdx
  unsigned __int32 v11; // eax
  double v12; // xmm1_8
  double v13; // xmm1_8
  int v14; // edi
  char v15; // al
  double v16[3]; // [rsp-18h] [rbp-18h] BYREF

  v16[2] = v9;
  v10 = a1.u32[1];
  v11 = a1.i32[1] & 0x7FFFFFFF;
  if ( (a1.i32[1] & 0x7FFFFFFFu) > 0x3FE921FB )
  {
    if ( v11 > 0x7FEFFFFF )
      return;
    v15 = sub_430953(v16, *(double *)a1.i64, a2, *(double *)a3.i64, a4, a5);
    v13 = v16[1];
    *(double *)a1.i64 = v16[0];
    v14 = v15 & 1;
    goto LABEL_10;
  }
  if ( v11 > 0x3E3FFFFF )
  {
    v13 = 0.0;
    v14 = 0;
LABEL_10:
    sub_43175D(v14, a1, v13, a3, a7, v10, a9);
    return;
  }
  if ( (a1.i32[1] & 0x7FF00000) != 0 )
    v12 = *(double *)a1.i64 + 1.329227995784916e36;
  else
    v12 = *(double *)a1.i64 * 7.52316384526264e-37;
  v16[0] = v12;
}
// 4315E8: could not find valid save-restore pair for rbp
// 4315ED: variable 'v9' is possibly undefined
// 43165E: variable 'v10' is possibly undefined
// 43165E: variable 'a9' is possibly undefined

//----- (0000000000431665) ----------------------------------------------------
void sub_431665()
{
  ;
}
// 431665: could not find valid save-restore pair for rbp

//----- (00000000004316BD) ----------------------------------------------------
double __fastcall sub_4316BD(double a1, double a2)
{
  double v2; // xmm3_8

  v2 = a1 * a1;
  return 1.0
       - (1.0
        - 0.5 * (a1 * a1))
       - 0.5 * (a1 * a1)
       + (((-1.135964755778819e-11 * (a1 * a1) + 0.000000002087572321298175) * v2 - 0.0000002755731435139066)
        * (v2
         * v2
         * (v2
          * v2))
        + ((0.00002480158728947673 * v2 - 0.001388888888887411) * v2 + 0.0416666666666666) * v2)
       * v2
       - a2 * a1
       + 1.0
       - 0.5 * (a1 * a1);
}

//----- (000000000043175D) ----------------------------------------------------
__m128 __fastcall sub_43175D(int a1, __m128 a2, double a3, __m128 a4, __int64 a5, __int64 a6, unsigned __int32 a7)
{
  unsigned __int32 v8; // edx
  __m128 v9; // xmm1
  double v10; // xmm2_8
  double v11; // xmm0_8
  double v12; // xmm5_8
  double v13; // xmm1_8
  __m128 v14; // xmm3
  double v15; // xmm7_8
  double v16; // xmm0_8
  double v17; // rsi
  double v18; // rax

  v8 = a2.i32[1] & 0x7FFFFFFF;
  if ( (a2.i32[1] & 0x7FFFFFFFu) > 0x3FE59427 )
  {
    a7 = (unsigned __int32)a2.i32[1] >> 31;
    if ( a2.i32[1] < 0 )
    {
      v9 = (__m128)_mm_loadl_epi64((const __m128i *)&xmmword_43D2F0);
      a2 = _mm_xor_ps(a2, v9);
      *(_QWORD *)&a3 ^= v9.i64[0];
    }
    v10 = 0.7853981633974483 - *(double *)a2.i64;
    v11 = 3.061616997868383e-17 - a3;
    a3 = 0.0;
    *(double *)a2.i64 = v11 + v10;
  }
  v12 = *(double *)a2.i64 * *(double *)a2.i64;
  v13 = ((((((-0.00001855863748552755 * (v12 * v12) + 0.00007817944429395571) * (v12 * v12) + 0.0005880412408202641)
          * (v12
           * v12)
          + 0.003592079107591312)
         * (v12
          * v12)
         + 0.02186948829485954)
        * (v12
         * v12)
        + 0.1333333333332012
        + (((((0.00002590730518636337 * (v12 * v12) + 0.00007140724913826082) * (v12 * v12) + 0.0002464631348184699)
           * (v12
            * v12)
           + 0.00145620945432529)
          * (v12
           * v12)
          + 0.0088632398235993)
         * (v12
          * v12)
         + 0.05396825397622605)
        * v12)
       * (*(double *)a2.i64
        * (*(double *)a2.i64
         * *(double *)a2.i64))
       + a3)
      * (*(double *)a2.i64
       * *(double *)a2.i64)
      + a3
      + *(double *)a2.i64 * (*(double *)a2.i64 * *(double *)a2.i64) * 0.3333333333333341;
  v14.i64[1] = a2.i64[1];
  *(double *)v14.i64 = *(double *)a2.i64 + v13;
  if ( v8 <= 0x3FE59427 )
  {
    if ( a1 )
    {
      v15 = COERCE_DOUBLE(v14.i64[0] & 0xFFFFFFFF00000000LL) - *(double *)a2.i64;
      *(_QWORD *)&v16 = v14.i64[0] & 0xFFFFFFFF00000000LL;
      v17 = -1.0 / *(double *)v14.i64;
      *(_QWORD *)&v18 = COERCE_UNSIGNED_INT64(-1.0 / *(double *)v14.i64) & 0xFFFFFFFF00000000LL;
      v14 = (__m128)*(unsigned __int64 *)&v18;
      *(double *)v14.i64 = v18 + (v16 * v18 + 1.0 + (v13 - v15) * v18) * v17;
    }
  }
  else
  {
    v14.i64[1] = a4.i64[1];
    *(double *)v14.i64 = (double)(-2 * a1 + 1)
                       - (*(double *)a2.i64
                        + v13
                        - *(double *)v14.i64 * *(double *)v14.i64 / (*(double *)v14.i64 + (double)(-2 * a1 + 1))
                        + *(double *)a2.i64
                        + v13
                        - *(double *)v14.i64 * *(double *)v14.i64 / (*(double *)v14.i64 + (double)(-2 * a1 + 1)));
    if ( a7 )
      return _mm_xor_ps(v14, (__m128)xmmword_43D2F0);
  }
  return v14;
}
// 43D2F0: using guessed type __int128 xmmword_43D2F0;

//----- (0000000000431916) ----------------------------------------------------
void __fastcall __noreturn sub_431916(__int64 a1, __int64 a2, const char *a3)
{
  __int64 v3; // rdx

  sub_401F8C(a1, a2, a3);
  sub_401FE8(a1, a2, v3);
}
// 431920: variable 'v3' is possibly undefined

//----- (0000000000431925) ----------------------------------------------------
char __fastcall sub_431925(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rdx
  __int64 v4; // r12
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // r12
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rdi

  if ( byte_452040 )
    return byte_452041;
  byte_452040 = 1;
  if ( (dword_44EB70 & 4) != 0 )
  {
    v3 = __readgsqword(0x60u);
    if ( (*(_DWORD *)(v3 + 284) | (unsigned int)(unsigned __int16)((unsigned __int16)*(_DWORD *)(v3 + 280) << 8)) > 0x9FF )
    {
      sub_43727D((__int64)sub_40217D);
      v4 = *(_QWORD *)qword_453AF0;
      v5 = *(_QWORD *)qword_453AF0;
      if ( (unsigned int)sub_402E71(*(_QWORD *)qword_453AF0, a2, v6) == 2 )
      {
        byte_452041 = 1;
        qword_452050 = v4;
        dword_452048 = sub_402E19();
        qword_4490D0(v5, a2, v8, 65001LL);
        qword_449070(v5, a2, &dword_45204C, v4);
        qword_4490D8(v5, a2, dword_45204C | 0x201u, v4);
      }
      v9 = *(_QWORD *)(qword_453AF0 + 24);
      v10 = v9;
      if ( (unsigned int)sub_402E71(v9, a2, v7) == 2
        || (v9 = *(_QWORD *)(qword_453AF0 + 48), v10 = v9, (unsigned int)sub_402E71(v9, a2, v11) == 2) )
      {
        byte_452041 = 1;
        qword_452060 = v9;
        dword_452058 = sub_402E2F();
        qword_4490E0(v10, a2, v12, 65001LL);
        qword_449070(v10, a2, &dword_45205C, v9);
        qword_4490D8(v10, a2, dword_45205C | 5u, v9);
      }
    }
  }
  if ( !byte_452041 )
  {
    v13 = sub_437CA8((__int64)"TERM");
    if ( v13 )
      byte_452041 = (unsigned int)sub_43AD14(v13, "dumb") != 0;
    else
      byte_452041 = (dword_44EB70 & 8) != 0;
  }
  return byte_452041;
}
// 431925: could not find valid save-restore pair for rbp
// 43199B: variable 'v6' is possibly undefined
// 4319C7: variable 'v8' is possibly undefined
// 431A02: variable 'v7' is possibly undefined
// 431A1A: variable 'v11' is possibly undefined
// 431A46: variable 'v12' is possibly undefined
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);
// 449070: using guessed type __int64 (__fastcall *qword_449070)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490D0: using guessed type __int64 (__fastcall *qword_4490D0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490D8: using guessed type __int64 (__fastcall *qword_4490D8)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4490E0: using guessed type __int64 (__fastcall *qword_4490E0)(_QWORD, _QWORD, _QWORD, _QWORD);
// 44EB70: using guessed type int dword_44EB70;
// 452040: using guessed type char byte_452040;
// 452041: using guessed type char byte_452041;
// 452048: using guessed type int dword_452048;
// 45204C: using guessed type int dword_45204C;
// 452050: using guessed type __int64 qword_452050;
// 452058: using guessed type int dword_452058;
// 45205C: using guessed type int dword_45205C;
// 452060: using guessed type __int64 qword_452060;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000431ABE) ----------------------------------------------------
__int64 __fastcall sub_431ABE(_DWORD *a1)
{
  unsigned int v1; // er12
  __int64 i; // r13
  _DWORD *v3; // rdi
  int v4; // eax
  int v5; // eax

  if ( a1 )
  {
    v1 = 0;
    if ( a1[3] != -1 && (a1[1] & (unsigned int)qword_44ECB8) != 0 )
    {
      v1 = a1[2];
      if ( v1 )
      {
        if ( v1 == -1 )
          return 0;
        else
          return (unsigned int)sub_431CE2((__int64)a1, v1);
      }
      else
      {
        while ( a1[4] != a1[5] )
        {
          v5 = sub_431D03((__int64)a1);
          if ( v5 == -1 )
            return (unsigned int)-1;
          v1 += v5;
        }
      }
    }
  }
  else
  {
    v1 = 0;
    for ( i = qword_452080 - 1; i != -1; --i )
    {
      v3 = *(_DWORD **)(qword_452090 + 8 * i);
      if ( v3 )
      {
        v4 = sub_431ABE(v3);
        if ( v4 == -1 )
          return (unsigned int)-1;
        v1 += v4;
      }
    }
  }
  return v1;
}
// 44ECB8: using guessed type __int64 qword_44ECB8;
// 452080: using guessed type __int64 qword_452080;
// 452090: using guessed type __int64 qword_452090;

//----- (0000000000431B90) ----------------------------------------------------
__int64 sub_431B90(__int64 a1, _BYTE *a2, ...)
{
  va_list va; // [rsp+8h] [rbp-C8h] BYREF
  __int64 v4; // [rsp+30h] [rbp-A0h]
  __int64 v5; // [rsp+38h] [rbp-98h]
  __int64 v6; // [rsp+40h] [rbp-90h]

  va_start(va, a2);
  v4 = va_arg(va, _QWORD);
  v5 = va_arg(va, _QWORD);
  v6 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  return sub_431DD4(a1, a2, (__int64)va, v5, v6);
}

//----- (0000000000431C16) ----------------------------------------------------
__int64 __fastcall sub_431C16(char *a1, __int64 a2)
{
  int v2; // er14
  char v4; // dl
  int v5; // eax
  int v6; // ecx
  __int64 (__fastcall *v7)(__int64); // rdx
  unsigned int v8; // eax
  unsigned int v9; // er12
  int v10; // eax

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v4 = *a1;
      if ( !*a1 )
        return (unsigned int)(v2 + 1);
      ++a1;
      *(_BYTE *)(*(_QWORD *)(a2 + 24) + *(unsigned int *)(a2 + 20)) = v4;
      v5 = (*(_DWORD *)(a2 + 32) - 1) & (*(_DWORD *)(a2 + 20) + 1);
      v6 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 20) = v5;
      if ( v5 == v6 || *(_BYTE *)a2 == 2 || *(_BYTE *)a2 == 1 && v4 == 10 )
      {
        v7 = *(__int64 (__fastcall **)(__int64))(a2 + 48);
        if ( v7 )
        {
          v8 = v7(a2);
        }
        else
        {
          if ( v5 != v6 )
            goto LABEL_15;
          v8 = sub_431CDA(a2);
        }
        v9 = v8;
        if ( v8 == -1 )
          break;
      }
LABEL_15:
      ++v2;
    }
  }
  while ( (int)sub_431E0F(a2) == qword_44EBC8 );
  if ( sub_431E05(a2) )
  {
    v10 = qword_44EC20;
    *(_DWORD *)(a2 + 8) = qword_44EC20;
    dword_453D68 = v10;
  }
  return v9;
}
// 44EBC8: using guessed type __int64 qword_44EBC8;
// 44EC20: using guessed type __int64 qword_44EC20;
// 453D68: using guessed type int dword_453D68;

//----- (0000000000431CDA) ----------------------------------------------------
__int64 __fastcall sub_431CDA(__int64 a1)
{
  return sub_431CE2(a1, -1);
}

//----- (0000000000431CE2) ----------------------------------------------------
__int64 __fastcall sub_431CE2(__int64 a1, int a2)
{
  int v2; // eax

  if ( !a2 )
    a2 = -1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 <= 0 )
    v2 = a2;
  *(_DWORD *)(a1 + 8) = v2;
  if ( a2 > 0 )
    dword_453D68 = a2;
  return -1LL;
}
// 453D68: using guessed type int dword_453D68;

//----- (0000000000431D03) ----------------------------------------------------
__int64 __fastcall sub_431D03(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // ebx
  unsigned int v3; // ebx
  __int64 v4; // rax

  v1 = *(unsigned int *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 20);
  if ( (unsigned int)v1 >= v2 )
    v2 = *(_DWORD *)(a1 + 32);
  v3 = v2 - v1;
  v4 = sub_437FE2(*(_DWORD *)(a1 + 12), *(_QWORD *)(a1 + 24) + v1, v3);
  if ( v4 == -1 )
    return sub_431E1D(a1);
  *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 32) - 1) & (*(_DWORD *)(a1 + 16) + v4);
  return v3;
}

//----- (0000000000431D58) ----------------------------------------------------
__int64 __fastcall sub_431D58(int a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // r8
  int v4; // eax
  int v5; // edx
  __int64 (__fastcall *v6)(__int64); // rcx

  v2 = *(_DWORD *)(a2 + 8);
  if ( v2 < 0 )
    return sub_40215C();
  v3 = *(_QWORD *)a2;
  *(_DWORD *)(a2 + 8) = v2 + 1;
  if ( a1 == -1 )
    return sub_431CDA(v3);
  *(_BYTE *)(*(_QWORD *)(v3 + 24) + *(unsigned int *)(v3 + 20)) = a1;
  v4 = (*(_DWORD *)(v3 + 32) - 1) & (*(_DWORD *)(v3 + 20) + 1);
  v5 = *(_DWORD *)(v3 + 16);
  *(_DWORD *)(v3 + 20) = v4;
  if ( v4 != v5 && *(_BYTE *)v3 != 2 && (*(_BYTE *)v3 != 1 || (_BYTE)a1 != 10) )
    return (unsigned __int8)a1;
  v6 = *(__int64 (__fastcall **)(__int64))(v3 + 48);
  if ( v6 )
    return v6(v3);
  if ( v4 == v5 )
    return sub_431CDA(v3);
  else
    return (unsigned __int8)a1;
}

//----- (0000000000431DD4) ----------------------------------------------------
__int64 __fastcall sub_431DD4(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v6; // [rsp+0h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+8h] [rbp-8h]

  v6 = a1;
  v7 = 0;
  result = sub_438B80((__int64 (__fastcall *)())sub_431D58, (__int64)&v6, a2, a3, a5);
  if ( (_DWORD)result != -1 )
    return v7;
  return result;
}

//----- (0000000000431E05) ----------------------------------------------------
_BOOL8 __fastcall sub_431E05(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == -1;
}

//----- (0000000000431E0F) ----------------------------------------------------
__int64 __fastcall sub_431E0F(__int64 a1)
{
  __int64 result; // rax

  result = 0LL;
  if ( *(int *)(a1 + 8) >= 0 )
    return *(unsigned int *)(a1 + 8);
  return result;
}

//----- (0000000000431E1D) ----------------------------------------------------
__int64 __fastcall sub_431E1D(__int64 a1)
{
  return sub_431CE2(a1, dword_453D68);
}
// 453D68: using guessed type int dword_453D68;

//----- (0000000000431EA0) ----------------------------------------------------
double __fastcall sub_431EA0(int a1, int a2)
{
  return (double)(a1 - a2);
}

//----- (0000000000431EA9) ----------------------------------------------------
__int64 __fastcall sub_431EA9(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v5; // [rsp-20h] [rbp-20h] BYREF

  if ( (dword_44EB70 & 4) == 0 )
    return sub_434AC1(a1, a2, a3, a4);
  sub_402EA0((__int64)&v5, (__int64)a2, a3);
  sub_438122((unsigned __int64 *)a1, v5);
  if ( a2 )
    *a2 = 0LL;
  return 0LL;
}
// 44EB70: using guessed type int dword_44EB70;

//----- (0000000000431EF7) ----------------------------------------------------
__int64 __fastcall sub_431EF7(char *a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  unsigned int v3; // ecx

  v1 = 0LL;
  LODWORD(result) = *a1 >> 31;
  do
  {
    v3 = (unsigned __int8)a1[v1++];
    result = v3 | ((_DWORD)result << 8);
  }
  while ( v1 != 4 );
  return result;
}

//----- (0000000000431F12) ----------------------------------------------------
__int64 __fastcall sub_431F12(char *a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  __int64 v3; // rcx

  v1 = 0LL;
  result = (__int64)*a1 >> 63;
  do
  {
    v3 = (unsigned __int8)a1[v1++];
    result = v3 + (result << 8);
  }
  while ( v1 != 8 );
  return result;
}

//----- (0000000000431F31) ----------------------------------------------------
_BYTE *__fastcall sub_431F31(_BYTE *a1, __int64 a2, unsigned __int64 a3)
{
  _BYTE *result; // rax
  __int64 v4; // rcx

  result = a1;
  v4 = 0x3FF080000000001LL;
  while ( 1 )
  {
    LOBYTE(a3) = *result;
    if ( *result <= 0x39u )
    {
      if ( _bittest64(&v4, a3) )
        break;
      a3 = (unsigned int)(a3 - 44);
      if ( (unsigned __int8)a3 <= 1u )
        break;
    }
    ++result;
  }
  return result;
}

//----- (0000000000431F59) ----------------------------------------------------
char *__fastcall sub_431F59(char *a1, int *a2, int a3, int a4)
{
  char *result; // rax
  int v5; // er8
  int v6; // edi

  result = a1;
  if ( a1 )
  {
    v5 = *a1;
    if ( (unsigned __int8)(v5 - 48) <= 9u )
    {
      v6 = 0;
      while ( 1 )
      {
        v6 = 10 * v6 + v5 - 48;
        if ( v6 > a4 )
          break;
        v5 = *++result;
        if ( (unsigned __int8)(v5 - 48) > 9u )
        {
          if ( v6 < a3 )
            return 0LL;
          *a2 = v6;
          return result;
        }
      }
    }
    return 0LL;
  }
  return result;
}

//----- (0000000000431F99) ----------------------------------------------------
char *__fastcall sub_431F99(char *a1)
{
  char *result; // rax
  _DWORD *v2; // r10
  _DWORD *v3; // r10
  _DWORD *v4; // r10
  int v5; // [rsp+Ch] [rbp-4h] BYREF

  result = sub_431F59(a1, &v5, 0, 167);
  if ( !result )
    return 0LL;
  *v2 = 3600 * v5;
  if ( *result == 58 )
  {
    result = sub_431F59(result + 1, &v5, 0, 59);
    if ( !result )
      return 0LL;
    *v3 += 60 * v5;
    if ( *result == 58 )
    {
      result = sub_431F59(result + 1, &v5, 0, 60);
      if ( result )
        *v4 += v5;
    }
  }
  return result;
}
// 431FC4: variable 'v2' is possibly undefined
// 431FE9: variable 'v3' is possibly undefined
// 43200D: variable 'v4' is possibly undefined

//----- (0000000000432012) ----------------------------------------------------
char *__fastcall sub_432012(char *a1)
{
  int v1; // ebx
  char *result; // rax
  _DWORD *v3; // r11

  if ( *a1 == 45 )
  {
    ++a1;
    v1 = 1;
  }
  else
  {
    v1 = 0;
    if ( *a1 == 43 )
      ++a1;
  }
  result = sub_431F99(a1);
  if ( result )
  {
    if ( v1 )
      *v3 = -*v3;
  }
  return result;
}
// 432045: variable 'v3' is possibly undefined

//----- (000000000043204C) ----------------------------------------------------
char *__fastcall sub_43204C(char *a1, _DWORD *a2)
{
  char v2; // al
  int *v3; // rsi
  int v4; // ecx
  int v5; // edx
  char *v6; // rax
  __int64 v7; // r10
  char *result; // rax
  char *v9; // rax
  __int64 v10; // r10
  __int64 v11; // r10

  v2 = *a1;
  if ( *a1 == 74 )
  {
    *a2 = 0;
    ++a1;
    v3 = a2 + 1;
    v4 = 365;
    v5 = 1;
  }
  else
  {
    if ( v2 == 77 )
    {
      *a2 = 2;
      v6 = sub_431F59(a1 + 1, a2 + 3, 1, 12);
      if ( !v6 )
        return 0LL;
      if ( *v6 != 46 )
        return 0LL;
      v9 = sub_431F59(v6 + 1, (int *)(v7 + 8), 1, 5);
      if ( !v9 || *v9 != 46 )
        return 0LL;
      a1 = v9 + 1;
      v3 = (int *)(v10 + 4);
      v4 = 6;
    }
    else
    {
      if ( (unsigned __int8)(v2 - 48) > 9u )
        return 0LL;
      *a2 = 1;
      v3 = a2 + 1;
      v4 = 365;
    }
    v5 = 0;
  }
  result = sub_431F59(a1, v3, v5, v4);
  if ( !result )
    return 0LL;
  if ( *result == 47 )
    return sub_431F99(result + 1);
  *(_DWORD *)(v11 + 16) = 7200;
  return result;
}
// 4320A4: variable 'v7' is possibly undefined
// 4320C5: variable 'v10' is possibly undefined
// 432105: variable 'v11' is possibly undefined

//----- (000000000043210F) ----------------------------------------------------
__int64 __fastcall sub_43210F(__int64 a1, int a2, int *a3, int a4)
{
  _BOOL8 v4; // r8
  int v6; // eax
  __int64 v7; // rdi
  __int64 v8; // rax
  int v9; // ebx
  int v10; // er11
  int v11; // edx
  int v12; // edx
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // edx
  __int64 v17; // r8

  v4 = 0LL;
  if ( (a2 & 3) == 0 )
  {
    v4 = 1LL;
    if ( !(a2 % 100) )
      v4 = a2 % 400 == 0;
  }
  v6 = *a3;
  if ( *a3 == 1 )
  {
    v7 = 86400 * a3[1] + a1;
    return v7 + a4 + (__int64)a3[4];
  }
  if ( v6 != 2 )
  {
    if ( v6 )
    {
      v7 = 0LL;
    }
    else
    {
      v11 = a3[1];
      v7 = 86400 * (v11 - 1) + a1;
      if ( v11 > 59 && v4 )
        v7 += 86400LL;
    }
    return v7 + a4 + (__int64)a3[4];
  }
  v8 = 0LL;
  v9 = a3[3];
  v10 = v9 - 1;
  while ( v10 > (int)v8 )
  {
    v12 = 86400 * dword_446A20[12 * v4 + v8++];
    a1 += v12;
  }
  if ( v9 <= 2 )
    --a2;
  v13 = (a2 % 100 / 4 + a2 % 100 + (26 * ((v9 + 9) % 12 + 1) - 2) / 10 + 1 + a2 / 400 - 2 * (a2 / 100)) % 7;
  v14 = a3[1] - (v13 + (v13 < 0 ? 7 : 0));
  v15 = v14 + (v14 < 0 ? 7 : 0);
  v16 = 1;
  v17 = v10 + 12 * v4;
  while ( a3[2] > v16 && v15 + 7 < dword_446A20[v17] )
  {
    ++v16;
    v15 += 7;
  }
  return 86400 * v15 + a1 + a4 + (__int64)a3[4];
}
// 446A20: using guessed type int dword_446A20[];

//----- (00000000004322A9) ----------------------------------------------------
__int64 __fastcall sub_4322A9(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v3; // rbx
  int *v4; // rax
  int i; // edx
  __int64 v6; // rsi
  __int64 v7; // rcx
  __int64 j; // rdx
  __int64 v9; // rax
  int v10; // er13
  __int64 k; // r12
  __int64 v12; // rax
  __int64 m; // r12
  __int64 v14; // r13

  v3 = (_DWORD *)qword_454098;
  qword_454080[0] = (__int64)&dword_4540B4;
  if ( qword_454098 )
  {
    v4 = (int *)(qword_454098 + 18032);
    qword_454088 = (__int64)&dword_4540B4;
    for ( i = 0; v3[2] > i; ++i )
    {
      v6 = v4[1];
      v7 = *v4;
      v4 += 6;
      qword_454080[v7] = (__int64)v3 + v6 + 24168;
    }
    for ( j = 0LL; v3[1] > (int)j; ++j )
    {
      v9 = *((unsigned __int8 *)v3 + j + 16024);
      qword_454080[v3[6 * v9 + 4508]] = (__int64)v3 + v3[6 * v9 + 4509] + 24168;
    }
    v10 = v3[3];
    for ( k = 0LL; v10 > (int)k; ++k )
    {
      sub_43AD27();
      if ( !v12 )
        *((_BYTE *)v3 + k + 24168) = 95;
    }
    for ( m = 0LL; v3[2] > (int)m; ++m )
    {
      v14 = (__int64)v3 + v3[6 * m + 4509] + 24168;
      if ( (unsigned __int64)sub_43AD53(v14) > 0x10 && (unsigned int)sub_43AD14(v14, "local time zone must be set") )
        *(_BYTE *)(v14 + 16) = 0;
    }
  }
  else
  {
    qword_454088 = (__int64)byte_446A80;
    qword_454080[0] = (__int64)byte_446A80;
  }
  return a3;
}
// 43237A: variable 'v12' is possibly undefined
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 454080: using guessed type __int64 qword_454080[];
// 454088: using guessed type __int64 qword_454088;
// 454098: using guessed type __int64 qword_454098;
// 4540B4: using guessed type int dword_4540B4;

//----- (00000000004323D8) ----------------------------------------------------
__int64 __fastcall sub_4323D8(int a1)
{
  if ( a1 < 0 )
    return (unsigned int)~sub_4323D8(~a1);
  else
    return (unsigned int)(a1 / -100 + (a1 >> 2) + a1 / 400);
}

//----- (0000000000432409) ----------------------------------------------------
__int64 __fastcall sub_432409(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  __int64 v5; // r9
  __int64 v6; // r11
  __int64 v7; // r12
  __int64 v8; // rcx
  int v9; // er8
  int v10; // er14
  __int64 v11; // r10
  __int64 v12; // rsi
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // r13
  int v16; // er8
  __int64 v17; // r10
  __int64 v18; // rax
  __int64 v19; // rdx
  int v20; // edi
  __int64 v21; // r11
  int v22; // er15
  int v23; // er8
  int v24; // ebx
  int v25; // eax
  __int64 v26; // r8
  __int64 v27; // r10
  _BOOL8 v28; // rax
  double v29; // xmm0_8
  int v30; // er10
  __int64 i; // r9
  int v32; // esi
  _BOOL8 v33; // rax
  _BOOL8 v34; // rax
  int v35; // ebx
  _BOOL8 v36; // rax
  int v37; // eax
  int v38; // er8
  int v39; // er10
  unsigned int v40; // eax
  int v41; // edx
  __int64 v42; // r9
  _BOOL8 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rdx
  int v46; // ecx
  __int64 v48; // [rsp+8h] [rbp-38h]

  v4 = 0;
  v5 = a1;
  v6 = a4;
  v7 = a2;
  if ( a3 )
    v4 = *(_DWORD *)a3;
  v8 = a3 + 16LL * (v4 - 1);
  do
  {
    v9 = v4--;
    if ( v4 < 0 )
    {
      v10 = 0;
      v15 = 0LL;
      goto LABEL_15;
    }
    v8 -= 16LL;
  }
  while ( *(_QWORD *)(v8 + 24696) > a1 );
  v10 = 0;
  v11 = v4;
  if ( *(_QWORD *)(v8 + 24696) == a1 )
  {
    if ( v4 || (v10 = 1, *(__int64 *)(a3 + 24688) <= 0) )
    {
      v10 = 0;
      if ( *(_QWORD *)(a3 + 16LL * v4 + 24688) > *(_QWORD *)(16LL * (v9 - 2) + a3 + 24688) )
      {
        do
        {
          v10 = v9 - v4;
          if ( !v4 )
            break;
          v12 = v4--;
          v13 = a3 + 16 * v12;
          v14 = a3 + 16LL * v4;
          if ( *(_QWORD *)(v13 + 24680) != *(_QWORD *)(v14 + 24680) + 1LL )
            break;
        }
        while ( *(_QWORD *)(v13 + 24688) == *(_QWORD *)(v14 + 24688) + 1LL );
      }
    }
  }
  v15 = *(_QWORD *)(16 * v11 + a3 + 24688);
LABEL_15:
  v16 = 1970;
  v48 = v5 / 86400;
  v17 = v5 / 86400;
  while ( 1 )
  {
    if ( v17 >= 0 )
    {
      v28 = 0LL;
      if ( (v16 & 3) == 0 )
      {
        v28 = 1LL;
        if ( !(v16 % 100) )
          v28 = v16 % 400 == 0;
      }
      if ( v17 < dword_446A10[v28] )
        break;
    }
    v18 = v17 / 366;
    v19 = (int)(v17 / 366);
    v20 = v17 / 366;
    if ( v17 / 366 - v19 > 0 || v19 - v18 > 0 )
      return 0LL;
    if ( !(_DWORD)v18 )
      v20 = (v17 >> 63) | 1;
    v22 = v16 + v20;
    if ( v16 > v16 + v20 != v20 < 0 )
      return 0LL;
    v24 = sub_4323D8(v22 - 1);
    v25 = sub_4323D8(v23 - 1);
    v17 = 365 * (v26 - v22) - (v24 - v25) + v27;
    v16 = v22;
  }
  v29 = (double)(86400 * (int)v17) + 0.5;
  v30 = (unsigned int)(int)v29 / 86400LL;
  for ( i = -86400 * (v48 + (unsigned int)(int)v29 / 86400LL) + (unsigned int)(int)v29 + v7 + v5 - v15; i < 0; i += 86400LL )
    --v30;
  while ( i > 86399 )
  {
    i -= 86400LL;
    ++v30;
  }
  while ( v30 < 0 )
  {
    v32 = v16 - 1;
    if ( __OFSUB__(v16, v32) || v16 == v32 )
      return 0LL;
    v33 = 0LL;
    if ( (v32 & 3) == 0 )
    {
      v33 = 1LL;
      if ( !(v32 % 100) )
        v33 = v32 % 400 == 0;
    }
    --v16;
    v30 += dword_446A10[v33];
  }
  while ( 1 )
  {
    v34 = 0LL;
    v35 = v16 & 3;
    if ( (v16 & 3) == 0 )
    {
      v34 = 1LL;
      if ( !(v16 % 100) )
        v34 = v16 % 400 == 0;
    }
    if ( v30 < dword_446A10[v34] )
      break;
    v36 = 0LL;
    if ( (v16 & 3) == 0 )
    {
      v36 = 1LL;
      if ( !(v16 % 100) )
        v36 = v16 % 400 == 0;
    }
    v30 -= dword_446A10[v36];
    if ( __OFSUB__(v16, v16 + 1) && v16 != v16 + 1 )
      return 0LL;
    ++v16;
  }
  *(_DWORD *)(v6 + 20) = v16 - 1900;
  if ( __OFSUB__(v16, v16 - 1900) || v16 == v16 - 1900 )
    return 0LL;
  *(_DWORD *)(v6 + 28) = v30;
  v37 = sub_4323D8(v16 - 1);
  v41 = (v37 + v39 + (v38 - 1970) % 7 - 473) >> 31;
  v40 = v37 + v39 + (v38 - 1970) % 7 - 473;
  *(_DWORD *)(v21 + 24) = __SPAIR64__(v41, v40) % 7 + (__SPAIR64__(v41, v40) % 7 < 0 ? 7 : 0);
  *(_DWORD *)(v21 + 8) = v42 / 3600;
  *(_DWORD *)(v21 + 4) = v42 % 3600 / 60;
  v43 = 0LL;
  *(_DWORD *)v21 = v10 + v42 % 3600 % 60;
  if ( !v35 )
  {
    v43 = 1LL;
    if ( !(v38 % 100) )
      v43 = v38 % 400 == 0;
  }
  v44 = 12 * v43;
  for ( *(_DWORD *)(v21 + 16) = 0; ; *(_DWORD *)(v21 + 16) = v45 + 1 )
  {
    v45 = *(int *)(v21 + 16);
    v46 = dword_446A20[v45 + v44];
    if ( v39 < v46 )
      break;
    v39 -= v46;
  }
  *(_DWORD *)(v21 + 32) = 0;
  *(_QWORD *)(v21 + 40) = v7;
  *(_DWORD *)(v21 + 12) = v39 + 1;
  return v21;
}
// 43256E: variable 'v23' is possibly undefined
// 43257E: variable 'v26' is possibly undefined
// 43258E: variable 'v27' is possibly undefined
// 4325E4: variable 'v5' is possibly undefined
// 43270B: variable 'v6' is possibly undefined
// 432739: variable 'v39' is possibly undefined
// 432725: variable 'v38' is possibly undefined
// 432757: variable 'v21' is possibly undefined
// 43275D: variable 'v42' is possibly undefined
// 446A10: using guessed type int dword_446A10[];
// 446A20: using guessed type int dword_446A20[];

//----- (00000000004327F2) ----------------------------------------------------
__int64 __fastcall sub_4327F2(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // rax

  result = (unsigned int)(a1[5] - a2[5]);
  if ( !(_DWORD)result )
  {
    result = (unsigned int)(a1[4] - a2[4]);
    if ( !(_DWORD)result )
    {
      result = (unsigned int)(a1[3] - a2[3]);
      if ( !(_DWORD)result )
      {
        result = (unsigned int)(a1[2] - a2[2]);
        if ( !(_DWORD)result )
        {
          result = (unsigned int)(a1[1] - a2[1]);
          if ( !(_DWORD)result )
            return (unsigned int)(*a1 - *a2);
        }
      }
    }
  }
  return result;
}

//----- (000000000043281F) ----------------------------------------------------
_BOOL8 __fastcall sub_43281F(__int64 a1, int a2, int a3)
{
  int v3; // eax
  __int64 v4; // rax
  __int64 v5; // rdx

  if ( !a1 )
    return 0LL;
  v3 = a3;
  if ( a2 >= a3 )
    v3 = a2;
  if ( *(_DWORD *)(a1 + 8) > v3
    && (v4 = a1 + 24LL * a2, v5 = a1 + 24LL * a3, *(_QWORD *)(v4 + 18024) == *(_QWORD *)(v5 + 18024))
    && *(_DWORD *)(v4 + 18032) == *(_DWORD *)(v5 + 18032)
    && *(_QWORD *)(v4 + 18040) == *(_QWORD *)(v5 + 18040) )
  {
    return (unsigned int)sub_43AD14(a1 + *(int *)(v4 + 18036) + 24168, a1 + *(int *)(v5 + 18036) + 24168) == 0;
  }
  else
  {
    return 0LL;
  }
}
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);

//----- (00000000004328B2) ----------------------------------------------------
__int64 __fastcall sub_4328B2(int *a1, int *a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // edx

  v3 = *a2;
  if ( *a2 < 0 )
    v4 = ~(~v3 / a3);
  else
    v4 = v3 / a3;
  *a2 -= v4 * a3;
  v5 = *a1;
  v6 = v4 + *a1;
  *a1 = v6;
  return (v5 > v6) ^ (unsigned __int8)(v4 < 0);
}

//----- (00000000004328E9) ----------------------------------------------------
__int64 __fastcall sub_4328E9(
        unsigned int *a1,
        __int64 (__fastcall *a2)(__int64 *a1, __int64 a2, __int64 a3),
        unsigned int a3,
        _DWORD *a4,
        int a5)
{
  unsigned int *v7; // rsi
  unsigned int *v8; // rdi
  __int64 i; // rcx
  int v10; // ebx
  int v11; // eax
  bool v12; // of
  int v13; // ecx
  int v14; // edi
  char v15; // dl
  bool v16; // r8
  _BOOL4 v17; // er13
  int v18; // er9
  int v19; // esi
  _BOOL8 v20; // r14
  int v21; // er9
  int v22; // edi
  char v23; // al
  int v24; // esi
  _BOOL8 v25; // r13
  int v26; // er8
  int v27; // esi
  char j; // di
  _BOOL8 v29; // rax
  int v30; // eax
  unsigned int v31; // eax
  int v32; // eax
  __int64 v33; // r14
  __int64 v34; // r13
  __int64 v35; // rax
  int v36; // eax
  __int64 v37; // rdx
  __int64 v38; // r13
  __int64 v39; // r14
  __int64 v40; // r9
  __int64 v41; // rax
  int v42; // eax
  __int64 v44; // [rsp+0h] [rbp-E0h]
  int v47; // [rsp+18h] [rbp-C8h]
  int v48; // [rsp+1Ch] [rbp-C4h]
  int v49; // [rsp+2Ch] [rbp-B4h] BYREF
  __int64 v50; // [rsp+30h] [rbp-B0h] BYREF
  __int64 v51; // [rsp+38h] [rbp-A8h] BYREF
  unsigned int v52; // [rsp+40h] [rbp-A0h] BYREF
  int v53; // [rsp+44h] [rbp-9Ch] BYREF
  int v54; // [rsp+48h] [rbp-98h] BYREF
  int v55; // [rsp+4Ch] [rbp-94h] BYREF
  int v56; // [rsp+50h] [rbp-90h] BYREF
  int v57; // [rsp+54h] [rbp-8Ch]
  int v58; // [rsp+60h] [rbp-80h]
  int v59[8]; // [rsp+78h] [rbp-68h] BYREF
  int v60; // [rsp+98h] [rbp-48h]

  *a4 = 0;
  v7 = a1;
  v8 = &v52;
  for ( i = 14LL; i; --i )
    *v8++ = *v7++;
  if ( a5 && (unsigned int)sub_4328B2(&v53, (int *)&v52, 60) )
    return -1LL;
  if ( (unsigned int)sub_4328B2(&v54, &v53, 60) )
    return -1LL;
  if ( (unsigned int)sub_4328B2(&v55, &v54, 24) )
    return -1LL;
  v49 = v57;
  v10 = sub_4328B2(&v49, &v56, 12);
  if ( v10 )
    return -1LL;
  v11 = v49 + 1900;
  v12 = v49 + 1900 <= v49;
  v49 += 1900;
  if ( v12 )
    return -1LL;
  v13 = v56;
  v14 = v55;
  v15 = 0;
  v16 = v56 > 1;
  v17 = v56 > 1;
  while ( v14 <= 0 )
  {
    v18 = v11 - 1;
    if ( v11 - 1 >= v11 )
      return -1LL;
    v19 = v17 + v18;
    v20 = 0LL;
    if ( ((v17 + (_BYTE)v18) & 3) == 0 )
    {
      v20 = 1LL;
      if ( !(v19 % 100LL) )
        v20 = v19 % 400LL == 0;
    }
    v15 = 1;
    v14 += dword_446A10[v20];
    --v11;
  }
  if ( v15 )
  {
    v49 = v11;
    v55 = v14;
  }
  v21 = v55;
  v22 = v49;
  v23 = 0;
  while ( v21 > 366 )
  {
    v24 = v16 + v22;
    v25 = 0LL;
    if ( ((v16 + (_BYTE)v22) & 3) == 0 )
    {
      v25 = 1LL;
      if ( !(v24 % 100LL) )
        v25 = v24 % 400LL == 0;
    }
    v21 -= dword_446A10[v25];
    v23 = 1;
    if ( v22 + 1 <= v22 )
      return -1LL;
    ++v22;
  }
  if ( v23 )
  {
    v49 = v22;
    v55 = v21;
  }
  v26 = v55;
  v27 = v49;
  for ( j = 0; ; j = 1 )
  {
    v29 = 0LL;
    if ( (v27 & 3) == 0 )
    {
      v29 = 1LL;
      if ( !(v27 % 100) )
        v29 = v27 % 400 == 0;
    }
    v30 = dword_446A20[12 * v29 + v13];
    if ( v30 >= v26 )
      break;
    ++v13;
    v26 -= v30;
    if ( v13 > 11 )
    {
      if ( __OFSUB__(v27, v27 + 1) && v27 != v27 + 1 )
        return -1LL;
      ++v27;
      v13 = 0;
    }
  }
  if ( j )
  {
    v56 = v13;
    v55 = v26;
  }
  v49 = v27 - 1900;
  if ( v27 - 1900 >= v27 )
    return -1LL;
  v57 = v27 - 1900;
  v31 = v52;
  if ( v52 > 0x3B )
  {
    if ( v27 > 1969 )
    {
      v52 = 0;
      v10 = v31;
    }
    else
    {
      v10 = v52 - 59;
      if ( __OFSUB__(v52, v10) || v52 == v10 )
        return -1LL;
      v52 = 59;
    }
  }
  v32 = 63;
  v33 = 1LL;
  do
  {
    v33 *= 2LL;
    --v32;
  }
  while ( v32 );
  v34 = ~v33;
  while ( 1 )
  {
    v35 = v33 / 2 + v34 / 2;
    if ( v35 >= v33 )
    {
      if ( v35 > v34 )
        v35 = v34;
      v51 = v35;
    }
    else
    {
      v51 = v33;
    }
    if ( !a2(&v51, a3, (__int64)v59) )
    {
      v36 = 2 * (v51 > 0) - 1;
      goto LABEL_57;
    }
    v36 = sub_4327F2(v59, &v52);
    if ( !v36 )
      break;
LABEL_57:
    if ( v51 == v33 )
    {
      v51 = v33 + 1;
      if ( v33 + 1 <= v33 || v33 + 1 == v33 )
        return -1LL;
      ++v33;
    }
    else if ( v51 == v34 )
    {
      v51 = v34 - 1;
      if ( v34 - 1 >= v34 )
        return -1LL;
      --v34;
    }
    if ( v33 > v34 )
      return -1LL;
    v37 = v51;
    if ( v36 > 0 )
    {
      v34 = v51;
      v37 = v33;
    }
    v33 = v37;
  }
  if ( v58 >= 0 && v58 != v60 )
  {
    v38 = qword_454090;
    if ( a2 == sub_433D49 )
      v38 = qword_454098;
    if ( v38 )
    {
      v48 = *(_DWORD *)(v38 + 8) - 1;
      v39 = 24LL * v48;
      while ( v48 >= 0 )
      {
        if ( *(_DWORD *)(v38 + v39 + 18032) == v58 )
        {
          v47 = *(_DWORD *)(v38 + 8) - 1;
          v40 = 24LL * v47;
          while ( v47 >= 0 )
          {
            if ( *(_DWORD *)(v38 + v40 + 18032) != v58 )
            {
              v44 = v40;
              v50 = *(_QWORD *)(v38 + v40 + 18024) + v51 - *(_QWORD *)(v38 + v39 + 18024);
              v41 = a2(&v50, a3, (__int64)v59);
              v40 = v44;
              if ( v41 )
              {
                v42 = sub_4327F2(v59, &v52);
                v40 = v44;
                if ( !v42 && v60 == v58 )
                {
                  v51 = v50;
                  goto LABEL_84;
                }
              }
            }
            --v47;
            v40 -= 24LL;
          }
        }
        --v48;
        v39 -= 24LL;
      }
    }
    return -1LL;
  }
LABEL_84:
  v50 = v51 + v10;
  if ( v51 > v50 != v10 < 0 )
    return -1LL;
  v51 += v10;
  if ( a2(&v51, a3, (__int64)a1) )
    *a4 = 1;
  return v51;
}
// 446A10: using guessed type int dword_446A10[];
// 446A20: using guessed type int dword_446A20[];
// 454090: using guessed type __int64 qword_454090;
// 454098: using guessed type __int64 qword_454098;
// 4328E9: using guessed type _DWORD var_68[8];

//----- (0000000000432E49) ----------------------------------------------------
__int64 __fastcall sub_432E49(
        unsigned int *a1,
        __int64 (__fastcall *a2)(__int64 *a1, __int64 a2, __int64 a3),
        unsigned int a3,
        _DWORD *a4)
{
  __int64 result; // rax

  result = sub_4328E9(a1, a2, a3, a4, 0);
  if ( !*a4 )
    return sub_4328E9(a1, a2, a3, a4, 1);
  return result;
}

//----- (0000000000432E8A) ----------------------------------------------------
__int64 __fastcall sub_432E8A(
        unsigned int *a1,
        __int64 (__fastcall *a2)(__int64 *a1, __int64 a2, __int64 a3),
        unsigned int a3)
{
  __int64 result; // rax
  int v6; // er8
  __int64 v7; // rbx
  int v8; // edx
  __int64 i; // rax
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // rsi
  int v13; // ecx
  __int64 v14; // rsi
  __int64 j; // r9
  __int64 v16; // r15
  __int64 v17; // r10
  unsigned int v18; // edx
  __int64 v19; // r12
  __int64 v20; // [rsp+8h] [rbp-868h]
  __int64 v21; // [rsp+10h] [rbp-860h]
  int v22; // [rsp+1Ch] [rbp-854h]
  int v23[525]; // [rsp+3Ch] [rbp-834h] BYREF

  if ( (int)a1[8] > 1 )
    a1[8] = 1;
  result = sub_432E49(a1, a2, a3, v23);
  v6 = v23[0];
  if ( !v23[0] && (a1[8] & 0x80000000) == 0 )
  {
    v7 = qword_454090;
    if ( a2 == sub_433D49 )
      v7 = qword_454098;
    if ( v7 )
    {
      v8 = *(_DWORD *)(v7 + 8);
      for ( i = 0LL; v8 > (int)i; ++i )
        v23[i + 1] = 0;
      v10 = *(_DWORD *)(v7 + 4) - 1;
      v11 = v7 + v10;
      while ( v10 >= 0 )
      {
        v12 = *(unsigned __int8 *)(v11 + 16024);
        v13 = *(unsigned __int8 *)(v11 + 16024);
        if ( !v23[v12 + 1] )
        {
          v23[v12 + 1] = 1;
          v14 = v6++;
          v23[v14 + 257] = v13;
        }
        --v10;
        --v11;
      }
      for ( j = 0LL; v6 > (int)j; ++j )
      {
        v16 = v23[j + 257];
        if ( *(_DWORD *)(v7 + 24 * v16 + 18032) == a1[8] )
        {
          v17 = 0LL;
          do
          {
            v18 = a1[8];
            v19 = v7 + 24LL * v23[v17 + 257];
            if ( *(_DWORD *)(v19 + 18032) != v18 )
            {
              v20 = v17;
              v21 = j;
              v22 = v6;
              *a1 = *(_DWORD *)(v19 + 18024) + *a1 - *(_DWORD *)(v7 + 24 * v16 + 18024);
              a1[8] = v18 == 0;
              result = sub_432E49(a1, a2, a3, v23);
              if ( v23[0] )
                return result;
              v17 = v20;
              j = v21;
              v6 = v22;
              *a1 = *(_DWORD *)(v7 + 24 * v16 + 18024) + *a1 - *(_DWORD *)(v19 + 18024);
              a1[8] = a1[8] == 0;
            }
            ++v17;
          }
          while ( v6 > (int)v17 );
        }
      }
    }
    return -1LL;
  }
  return result;
}
// 454090: using guessed type __int64 qword_454090;
// 454098: using guessed type __int64 qword_454098;

//----- (000000000043307C) ----------------------------------------------------
__int64 __fastcall sub_43307C(_BYTE *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rax
  __int64 v5; // rbx
  char *v6; // r12
  char *i; // rbx
  char *v8; // rdi
  unsigned __int64 v9; // rdx
  int v10; // er15
  char *j; // r14
  unsigned __int64 v12; // rax
  char *v13; // rdi
  unsigned __int64 v14; // r14
  __int64 v15; // rdx
  char v16; // al
  char *v17; // rax
  char *v18; // rax
  int *v19; // r11
  int v20; // er8
  __int64 *v21; // r10
  __int64 v22; // r9
  __int64 v23; // rdi
  int v24; // er15
  __int64 v25; // rax
  _BOOL8 v26; // rax
  __int64 v27; // rax
  int v28; // eax
  unsigned int v29; // er13
  int v30; // edi
  __int64 v31; // rdx
  __int64 v32; // rax
  __int64 v33; // rax
  int v34; // ecx
  __int64 k; // rax
  __int64 v36; // rsi
  __int64 v37; // r9
  int v38; // er10
  __int64 v39; // rsi
  unsigned __int64 v40; // rdx
  __int64 v41; // rdi
  _BYTE *v42; // rbx
  __int64 v44; // [rsp+0h] [rbp-A0h]
  __int64 *v45; // [rsp+8h] [rbp-98h]
  __int64 v46; // [rsp+10h] [rbp-90h]
  int *v47; // [rsp+28h] [rbp-78h]
  int v48; // [rsp+30h] [rbp-70h]
  _BYTE *v49; // [rsp+38h] [rbp-68h]
  int v50; // [rsp+40h] [rbp-60h]
  int v51; // [rsp+44h] [rbp-5Ch]
  int v52[5]; // [rsp+48h] [rbp-58h] BYREF
  int v53[17]; // [rsp+5Ch] [rbp-44h] BYREF

  v49 = a1;
  if ( (_DWORD)a3 )
  {
    v4 = sub_43AD53(a1);
    v5 = 511LL;
    if ( v4 <= 0x1FF )
      v5 = v4;
    v50 = 0;
    v6 = &a1[v4];
  }
  else
  {
    if ( *a1 == 60 )
    {
      v49 = a1 + 1;
      for ( i = a1 + 1; *i; ++i )
      {
        v8 = i + 1;
        if ( *i == 62 )
          goto LABEL_11;
      }
      return (unsigned int)-1;
    }
    v8 = sub_431F31(a1, a2, a3);
    i = v8;
LABEL_11:
    v5 = i - v49;
    if ( !*v8 )
      return (unsigned int)-1;
    v6 = sub_432012(v8);
    if ( !v6 )
      return (unsigned int)-1;
  }
  v10 = sub_433507("New_York", a2, 0LL);
  if ( v10 )
    *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( !*v6 )
  {
    *(_DWORD *)(a2 + 8) = 1;
    v6 = 0LL;
    *(_QWORD *)(a2 + 18032) = 0LL;
    *(_QWORD *)(a2 + 18024) = -v50;
    v28 = v5;
LABEL_47:
    v14 = 0LL;
    *(_DWORD *)(a2 + 12) = v28 + 1;
    goto LABEL_48;
  }
  if ( *v6 == 60 )
  {
    for ( j = ++v6; ; ++j )
    {
      v12 = (unsigned int)*j;
      if ( !*j )
        break;
      v13 = j + 1;
      if ( (_DWORD)v12 == 62 )
        goto LABEL_22;
    }
    return (unsigned int)-1;
  }
  v12 = (unsigned __int64)sub_431F31(v6, a2, v9);
  v13 = (char *)v12;
  j = (char *)v12;
LABEL_22:
  v14 = j - v6;
  if ( (unsigned __int8)*v13 <= 0x3Bu && (v15 = 0x800100000000001LL, LOBYTE(v12) = *v13, _bittest64(&v15, v12)) )
  {
    v51 = v50 - 3600;
  }
  else
  {
    v13 = sub_432012(v13);
    if ( !v13 )
      return (unsigned int)-1;
  }
  if ( !*v13 && v10 )
    v13 = ",M4.1.0,M10.5.0";
  v16 = *v13;
  if ( *v13 == 44 || v16 == 59 )
  {
    v17 = sub_43204C(v13 + 1, v52);
    if ( !v17 )
      return (unsigned int)-1;
    if ( *v17 != 44 )
      return (unsigned int)-1;
    v18 = sub_43204C(v17 + 1, v53);
    if ( !v18 || *v18 )
      return (unsigned int)-1;
    v20 = v50;
    v21 = (__int64 *)(a2 + 24);
    *(_DWORD *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 18032) = 1;
    v22 = 0LL;
    *(_QWORD *)(a2 + 18056) = 0LL;
    v23 = 0LL;
    v47 = v19;
    *(_QWORD *)(a2 + 18024) = -v51;
    *(_DWORD *)(a2 + 18036) = v5 + 1;
    *(_QWORD *)(a2 + 18048) = -v50;
    while ( 1 )
    {
      v24 = v22 + 1970;
      if ( *(_DWORD *)(a2 + 4) + 2 > 2000 )
        break;
      v44 = v22;
      v45 = v21;
      v48 = v20;
      v46 = sub_43210F(v23, v24, v47, v20);
      v25 = sub_43210F(v23, v24, v53, v51);
      v20 = v48;
      v21 = v45 + 2;
      if ( v46 <= v25 )
      {
        *v45 = v46;
        *(_BYTE *)(a2 + 2 * v44 + 16024) = 0;
        v45[1] = v25;
        *(_BYTE *)(a2 + 2 * v44 + 16025) = 1;
      }
      else
      {
        *v45 = v25;
        *(_BYTE *)(a2 + 2 * v44 + 16024) = 1;
        v45[1] = v46;
        *(_BYTE *)(a2 + 2 * v44 + 16025) = 0;
      }
      *(_DWORD *)(a2 + 4) += 2;
      v26 = 0LL;
      if ( (v24 & 3) == 0 )
      {
        v26 = 1LL;
        if ( !(v24 % 100) )
          v26 = v24 % 400 == 0;
      }
      v22 = v44 + 1;
      v27 = v23 + 86400 * dword_446A10[v26];
      if ( v23 >= v27 )
        break;
      v23 = v27;
    }
  }
  else
  {
    if ( v16 )
      return (unsigned int)-1;
    v30 = *(_DWORD *)(a2 + 4);
    v31 = 0LL;
    while ( v30 > (int)v31 )
    {
      v32 = *(unsigned __int8 *)(a2 + v31++ + 16024);
      v33 = a2 + 24 * v32;
      if ( !*(_DWORD *)(v33 + 18032) )
      {
        v34 = -*(_DWORD *)(v33 + 18024);
        goto LABEL_55;
      }
    }
    v34 = 0;
LABEL_55:
    for ( k = 0LL; v30 > (int)k; ++k )
    {
      v36 = *(unsigned __int8 *)(a2 + k + 16024);
      v37 = a2 + 24 * v36;
      v38 = *(_DWORD *)(v37 + 18032);
      *(_BYTE *)(a2 + k + 16024) = v38;
      if ( !*(_DWORD *)(v37 + 18044) )
        *(_QWORD *)(a2 + 8 * k + 24) += v50 - v34;
      v39 = *(_QWORD *)(a2 + 24 * v36 + 18024);
      if ( !v38 )
        v34 = -(int)v39;
    }
    *(_QWORD *)(a2 + 18032) = 0LL;
    *(_DWORD *)(a2 + 18056) = 1;
    *(_DWORD *)(a2 + 8) = 2;
    *(_QWORD *)(a2 + 18024) = -v50;
    *(_QWORD *)(a2 + 18048) = -v51;
    *(_DWORD *)(a2 + 18060) = v5 + 1;
  }
  v28 = v5;
  if ( !v14 )
    goto LABEL_47;
  *(_DWORD *)(a2 + 12) = v5 + v14 + 2;
LABEL_48:
  if ( *(_DWORD *)(a2 + 12) > 0x200u )
    return (unsigned int)-1;
  v40 = v5;
  v41 = a2 + 24168;
  v42 = (_BYTE *)(a2 + 24168 + v5);
  v29 = 0;
  sub_43A1BD(v41, (__int64)v49, v40);
  *v42 = 0;
  if ( v14 )
  {
    sub_43A1BD((__int64)(v42 + 1), (__int64)v6, v14);
    v42[v14 + 1] = 0;
  }
  return v29;
}
// 433171: variable 'v9' is possibly undefined
// 4331B3: variable 'v50' is possibly undefined
// 433246: variable 'v19' is possibly undefined
// 43324D: variable 'v51' is possibly undefined
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 446A10: using guessed type int dword_446A10[];
// 43307C: using guessed type int var_58[5];
// 43307C: using guessed type int var_44[17];

//----- (0000000000433507) ----------------------------------------------------
__int64 __fastcall sub_433507(char *a1, __int64 a2, __int64 a3)
{
  char *v3; // r13
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  char *v10; // r12
  char v11; // r14
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rsi
  int v16; // eax
  unsigned int v17; // er13
  int v18; // eax
  signed int v19; // eax
  int v20; // eax
  int v21; // er15
  int v22; // er8
  int v23; // er10
  unsigned int v24; // er11
  char *v25; // rdi
  __int64 i; // rsi
  __int64 v27; // rax
  __int64 v28; // r9
  __int64 v29; // rsi
  __int64 v30; // rax
  __int64 v31; // rdx
  char *v32; // r9
  int v33; // ecx
  __int64 v34; // r13
  int v35; // er14
  int v36; // er8
  __int64 v37; // r9
  int v38; // er10
  __int64 v39; // r11
  int v40; // eax
  int v41; // eax
  __int64 j; // rax
  char *v43; // r9
  __int64 *v44; // r13
  signed int v45; // er14
  char *v46; // r11
  __int64 v47; // rax
  __int64 v48; // r11
  int v49; // eax
  __int64 v50; // r11
  __int64 v51; // rax
  char *v52; // r9
  unsigned int v53; // esi
  __int64 v54; // rax
  unsigned int v55; // esi
  __int64 v56; // rdx
  __int64 v57; // rsi
  int v58; // ecx
  __int64 k; // rax
  __int64 v60; // r14
  __int64 v61; // rax
  __int64 v62; // rdx
  _DWORD *v63; // r13
  int v64; // eax
  int v65; // ecx
  __int64 m; // rax
  __int64 v67; // rdx
  char v68; // si
  int v69; // esi
  __int64 v70; // rcx
  __int64 v71; // rax
  _DWORD *v72; // rsi
  __int64 v73; // rcx
  int v74; // eax
  _DWORD *v75; // rdi
  int v76; // edx
  __int64 v77; // rax
  _DWORD *v78; // rsi
  __int64 v79; // rcx
  _DWORD *v80; // rdi
  __int64 v81; // rdi
  char v82; // di
  int v83; // edx
  char v84; // r8
  int v85; // er13
  int v86; // er15
  __int64 v87; // r14
  int v88; // er14
  __int64 v89; // r13
  int v90; // er15
  __int64 v91; // r13
  char v93; // [rsp+0h] [rbp-190h]
  char v94; // [rsp+3Ch] [rbp-154h]
  int v95; // [rsp+48h] [rbp-148h]
  int v96; // [rsp+4Ch] [rbp-144h]
  int v97; // [rsp+50h] [rbp-140h]
  int v98; // [rsp+54h] [rbp-13Ch]
  signed int v99; // [rsp+58h] [rbp-138h]
  char v100[296]; // [rsp+68h] [rbp-128h] BYREF

  v3 = a1;
  v94 = a3;
  v5 = sub_434FB8(1LL, 59048LL, a3);
  if ( !v5 )
    return 0xFFFFFFFFLL;
  v10 = (char *)v5;
  *(_QWORD *)(a2 + 16) = 0LL;
  if ( !a1 )
    goto LABEL_10;
  v11 = *a1;
  if ( *a1 != 58 )
  {
    if ( v11 != 47 )
      goto LABEL_7;
LABEL_10:
    v3 = "GST";
    goto LABEL_11;
  }
  sub_43AD27();
  if ( v12 )
    goto LABEL_10;
LABEL_7:
  sub_43AD27();
  if ( v13 )
    goto LABEL_10;
  if ( v11 == 58 )
    v3 = a1 + 1;
LABEL_11:
  if ( *v3 == 47 )
    goto LABEL_14;
  v14 = sub_43AD53("zip:usr/share/zoneinfo");
  if ( (unsigned __int64)(v14 + sub_43AD53(v3) + 1) <= 0xF7 )
  {
    sub_43A17B((__int64)v100, (__int64)"zip:usr/share/zoneinfo", 0xF8uLL);
    sub_43A117((__int64)v100, (__int64)"/", 0xF8uLL);
    v15 = (__int64)v3;
    v3 = v100;
    sub_43A117((__int64)v100, v15, 0xF8uLL);
LABEL_14:
    v16 = sub_437DD1(v3, qword_44EC98, v6, v7, v8, v9, v93);
    v17 = v16;
    if ( v16 != -1 )
    {
      v98 = sub_437E75(v16, (__int64)v10, 59048LL);
      v18 = sub_437A1A(v17);
      if ( v98 > 0 && v18 >= 0 )
      {
        v95 = 2;
LABEL_18:
        v97 = sub_431EF7(v10 + 24);
        v96 = sub_431EF7(v10 + 20);
        v19 = sub_431EF7(v10 + 28);
        *(_DWORD *)a2 = v19;
        v99 = v19;
        v20 = sub_431EF7(v10 + 32);
        *(_DWORD *)(a2 + 4) = v20;
        v21 = v20;
        *(_DWORD *)(a2 + 8) = sub_431EF7(v10 + 36);
        v24 = sub_431EF7(v10 + 40);
        *(_DWORD *)(a2 + 12) = v24;
        if ( (unsigned int)v21 <= 0x7D0
          && (unsigned int)v99 <= 0x32
          && (unsigned int)(v22 - 1) <= 0xFF
          && v24 <= 0x32
          && (!v97 || v22 == v97)
          && (v22 == v96 || !v96)
          && v98 - 44LL >= (int)(v24 + v96 + v97 + 6 * v22 + v21 * (v23 + 1) + v99 * (v23 + 4)) )
        {
          v25 = v10 + 44;
          for ( i = 0LL; v21 > (int)i; ++i )
          {
            if ( v23 == 4 )
              v27 = (int)sub_431EF7(v25);
            else
              v27 = sub_431F12(v25);
            *(_QWORD *)(a2 + 8 * i + 24) = v27;
            v25 += v28;
          }
          v29 = v23;
          v30 = 0LL;
          v31 = (__int64)&v10[v23 * (__int64)v21 + 44];
          while ( 1 )
          {
            v32 = (char *)(v31 + v30);
            if ( v21 <= (int)v30 )
              break;
            v33 = *(unsigned __int8 *)(v31 + v30);
            *(_BYTE *)(a2 + v30 + 16024) = v33;
            if ( v22 <= v33 )
              goto LABEL_111;
            ++v30;
          }
          v34 = a2 + 18024;
          v35 = 0;
          while ( 1 )
          {
            *(_QWORD *)v34 = (int)sub_431EF7(v32);
            v40 = *(unsigned __int8 *)(v37 + 4);
            *(_DWORD *)(v34 + 8) = v40;
            if ( (unsigned __int8)v40 > 1u )
              break;
            v41 = *(unsigned __int8 *)(v37 + 5);
            v32 = (char *)(v37 + 6);
            *(_DWORD *)(v34 + 12) = v41;
            if ( (int)v39 < v41 )
              break;
            ++v35;
            v34 += 24LL;
            if ( v36 <= v35 )
            {
              for ( j = 0LL; (int)v39 > (int)j; ++j )
                *(_BYTE *)(a2 + j + 24168) = v32[j];
              v43 = &v32[v39];
              v44 = (__int64 *)(a2 + 24680);
              *(_BYTE *)(a2 + v39 + 24168) = 0;
              v45 = 0;
              v46 = v43;
              while ( v99 > v45 )
              {
                if ( v38 == 4 )
                  v47 = (int)sub_431EF7(v46);
                else
                  v47 = sub_431F12(v46);
                *v44 = v47;
                ++v45;
                v44 += 2;
                v49 = sub_431EF7((char *)(v29 + v48));
                v46 = (char *)(v29 + 4 + v50);
                *(v44 - 1) = v49;
              }
              v51 = 0LL;
              v52 = &v43[v99 * (v29 + 4)];
              do
              {
                if ( v97 )
                {
                  v53 = *v52;
                  *(_DWORD *)(a2 + 24 * v51 + 18040) = v53;
                  if ( v53 > 1 )
                    goto LABEL_111;
                  ++v52;
                }
                else
                {
                  *(_DWORD *)(a2 + 24 * v51 + 18040) = 0;
                }
                ++v51;
              }
              while ( v36 > (int)v51 );
              v54 = 0LL;
              do
              {
                if ( v96 )
                {
                  v55 = *v52;
                  *(_DWORD *)(a2 + 24 * v54 + 18044) = v55;
                  if ( v55 > 1 )
                    goto LABEL_111;
                  ++v52;
                }
                else
                {
                  *(_DWORD *)(a2 + 24 * v54 + 18044) = 0;
                }
                ++v54;
              }
              while ( v36 > (int)v54 );
              v56 = 0LL;
              while ( v21 - 2 > (int)v56 )
              {
                v57 = *(_QWORD *)(a2 + 8 * v56 + 24);
                v58 = ++v56;
                if ( v57 > *(_QWORD *)(a2 + 8 * v56 + 24) )
                {
                  *(_DWORD *)(a2 + 4) = v58;
                  break;
                }
              }
              if ( v10[4] )
              {
                v98 -= (_DWORD)v52 - (_DWORD)v10;
                for ( k = 0LL; v98 > (int)k; ++k )
                {
                  LOBYTE(v56) = v52[k];
                  v10[k] = v56;
                }
                if ( v38 != 8 && v95 != 1 )
                {
                  v95 = 1;
                  goto LABEL_18;
                }
              }
              if ( v98 > 2 && (v94 & 1) != 0 && *v10 == 10 )
              {
                v60 = v98 - 1;
                if ( v10[v60] == 10 && v36 + 2 <= 256 )
                {
                  v61 = sub_434FB8(1LL, 25480LL, v56);
                  v63 = (_DWORD *)v61;
                  if ( !v61 )
                    sub_401000(1LL, 25480LL, v62);
                  v10[v60] = 0;
                  if ( !(unsigned int)sub_43307C(v10 + 1, v61, 0LL) && v63[2] == 2 )
                  {
                    v64 = *(_DWORD *)(a2 + 12);
                    v65 = v63[3];
                    if ( v64 + v65 <= 50 )
                    {
                      v63[4509] += v64;
                      v63[4515] += v64;
                      for ( m = 0LL; v65 > (int)m; ++m )
                      {
                        v67 = *(int *)(a2 + 12);
                        *(_DWORD *)(a2 + 12) = v67 + 1;
                        v68 = *((_BYTE *)v63 + m + 24168);
                        *(_BYTE *)(a2 + v67 + 24168) = v68;
                      }
                      v69 = v63[1];
                      v70 = 0LL;
                      while ( 1 )
                      {
                        v71 = (int)v70;
                        if ( v69 <= (int)v70 )
                          break;
                        v81 = *(_QWORD *)&v63[2 * v70++ + 6];
                        if ( v81 > *(_QWORD *)(a2 + 8 * (*(_DWORD *)(a2 + 4) - 1 + 2LL) + 8) )
                        {
                          v82 = *(_BYTE *)(a2 + 8);
                          do
                          {
                            v83 = *(_DWORD *)(a2 + 4);
                            if ( v83 > 1999 )
                              break;
                            *(_QWORD *)(a2 + 8LL * v83 + 24) = *(_QWORD *)&v63[2 * v71 + 6];
                            v84 = *((_BYTE *)v63 + v71++ + 16024);
                            *(_BYTE *)(a2 + v83 + 16024) = v82 + v84;
                            *(_DWORD *)(a2 + 4) = v83 + 1;
                          }
                          while ( v69 > (int)v71 );
                          break;
                        }
                      }
                      v72 = v63 + 4506;
                      v73 = 6LL;
                      v74 = *(_DWORD *)(a2 + 8);
                      v75 = (_DWORD *)(a2 + 24LL * v74 + 18024);
                      v76 = v74 + 2;
                      v77 = 24LL * (v74 + 1);
                      while ( v73 )
                      {
                        *v75++ = *v72++;
                        --v73;
                      }
                      v78 = v63 + 4512;
                      *(_DWORD *)(a2 + 8) = v76;
                      v79 = 6LL;
                      v80 = (_DWORD *)(a2 + v77 + 18024);
                      while ( v79 )
                      {
                        *v80++ = *v78++;
                        --v79;
                      }
                    }
                  }
                  sub_434FBE(v63);
                }
              }
              v85 = *(_DWORD *)(a2 + 4);
              if ( v85 > 1 )
              {
                v86 = *(unsigned __int8 *)(a2 + 16024);
                v87 = 1LL;
                while ( !sub_43281F(a2, *(unsigned __int8 *)(a2 + v87 + 16024), v86)
                     || *(_QWORD *)(a2 + 8 * v87 + 24) - *(_QWORD *)(a2 + 24) != 0x2F0605980LL )
                {
                  if ( v85 <= (int)++v87 )
                    goto LABEL_105;
                }
                *(_DWORD *)(a2 + 16) = 1;
LABEL_105:
                v88 = v85 - 2;
                v89 = v85 - 1;
                v90 = *(unsigned __int8 *)(a2 + v89 + 16024);
                v91 = v89 + 2;
                while ( !sub_43281F(a2, v90, *(unsigned __int8 *)(a2 + v88 + 16024))
                     || *(_QWORD *)(a2 + 8 * v91 + 8) - *(_QWORD *)(a2 + 8LL * v88 + 24) != 0x2F0605980LL )
                {
                  if ( --v88 == -1 )
                    goto LABEL_110;
                }
                *(_DWORD *)(a2 + 20) = 1;
              }
LABEL_110:
              sub_434FBE(v10);
              return 0LL;
            }
          }
        }
      }
    }
  }
LABEL_111:
  sub_434FBE(v10);
  return 0xFFFFFFFFLL;
}
// 433569: variable 'v12' is possibly undefined
// 433583: variable 'v13' is possibly undefined
// 433615: variable 'v6' is possibly undefined
// 433615: variable 'v7' is possibly undefined
// 433615: variable 'v8' is possibly undefined
// 433615: variable 'v9' is possibly undefined
// 433615: variable 'v93' is possibly undefined
// 433726: variable 'v22' is possibly undefined
// 433796: variable 'v23' is possibly undefined
// 4337F7: variable 'v28' is possibly undefined
// 43384C: variable 'v37' is possibly undefined
// 43386D: variable 'v39' is possibly undefined
// 43387D: variable 'v36' is possibly undefined
// 4338CA: variable 'v38' is possibly undefined
// 4338DA: variable 'v48' is possibly undefined
// 4338F0: variable 'v50' is possibly undefined
// 43390E: variable 'v43' is possibly undefined
// 433A65: variable 'v62' is possibly undefined
// 434FB8: using guessed type __int64 __fastcall sub_434FB8(_QWORD, _QWORD, _QWORD);
// 434FBE: using guessed type __int64 __fastcall sub_434FBE(_QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 44EC98: using guessed type __int64 qword_44EC98;

//----- (0000000000433C81) ----------------------------------------------------
__int64 __fastcall sub_433C81(__int64 a1)
{
  __int64 v2; // [rsp+0h] [rbp-10h]

  if ( (unsigned int)sub_433507(byte_446A80, a1, 1LL) )
    return sub_43307C(byte_446A80, a1, 1uLL);
  else
    return v2;
}
// 433CB7: variable 'v2' is possibly undefined

//----- (0000000000433CBC) ----------------------------------------------------
__int64 __fastcall sub_433CBC(__int64 *a1, int a2, __int64 a3)
{
  __int64 v5; // rdi
  __int64 v6; // r14
  __int64 result; // rax
  char *v8; // rdx

  if ( !dword_4540AC )
  {
    dword_4540AC = 1;
    v5 = sub_434FC4(25480LL);
    qword_454090 = v5;
    if ( v5 )
      sub_433C81(v5);
  }
  v6 = qword_454090;
  result = sub_432409(*a1, a2, qword_454090, a3);
  if ( a2 )
  {
    *(_QWORD *)(a3 + 48) = &dword_446A84;
  }
  else
  {
    v8 = (char *)(v6 + 24168);
    if ( !v6 )
      v8 = byte_446A80;
    *(_QWORD *)(a3 + 48) = v8;
  }
  return result;
}
// 434FC4: using guessed type __int64 __fastcall sub_434FC4(_QWORD);
// 446A84: using guessed type int dword_446A84;
// 454090: using guessed type __int64 qword_454090;
// 4540AC: using guessed type int dword_4540AC;

//----- (0000000000433D49) ----------------------------------------------------
__int64 __fastcall sub_433D49(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // r13
  __int64 result; // rax
  int v7; // edx
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 v10; // r12
  __int64 v11; // rdx
  __int64 v12; // r12
  __int64 v13; // r12
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // r12
  int v17; // ecx
  int *v18; // r12
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21[5]; // [rsp+8h] [rbp-28h] BYREF

  v4 = qword_454098;
  v5 = *a1;
  if ( !qword_454098 )
    return sub_433CBC(a1, a2, a3);
  if ( *(_DWORD *)(qword_454098 + 16) && v5 < *(_QWORD *)(qword_454098 + 24)
    || (v7 = *(_DWORD *)(qword_454098 + 4), *(_DWORD *)(qword_454098 + 20))
    && v5 > *(_QWORD *)(qword_454098 + 8LL * (v7 - 1) + 24) )
  {
    v8 = *(_QWORD *)(qword_454098 + 24);
    v21[0] = v5;
    if ( v5 >= v8 )
      v9 = v5 - *(_QWORD *)(qword_454098 + 8LL * (*(_DWORD *)(qword_454098 + 4) - 1) + 24);
    else
      v9 = v8 - v5;
    v10 = (v9 - 1) / 0x2F0605980LL + 1;
    v11 = v5 - 0x2F0605980LL * v10;
    if ( v5 < v8 )
      v11 = v5 + 0x2F0605980LL * v10;
    v21[0] = v11;
    if ( v8 > v11 || *(_QWORD *)(qword_454098 + 8LL * (*(_DWORD *)(qword_454098 + 4) - 1) + 24) < v11 )
      return 0LL;
    result = sub_433D49(v21, a2, a3);
    if ( a3 == result )
    {
      v12 = v5 >= *(_QWORD *)(v4 + 24) ? 400 * v10 : -400 * v10;
      v13 = *(int *)(result + 20) + v12;
      *(_DWORD *)(result + 20) = v13;
      if ( (int)v13 != v13 )
        return 0LL;
    }
  }
  else
  {
    if ( v7 && (v14 = 1, v5 >= *(_QWORD *)(qword_454098 + 24)) )
    {
      while ( v7 > v14 )
      {
        v17 = (v7 + v14) >> 1;
        if ( v5 < *(_QWORD *)(qword_454098 + 8LL * v17 + 24) )
          v7 = (v7 + v14) >> 1;
        else
          v14 = v17 + 1;
      }
      v16 = *(unsigned __int8 *)(qword_454098 + v14 - 1 + 16024);
    }
    else
    {
      v15 = 0LL;
      while ( 1 )
      {
        v16 = (int)v15;
        if ( !*(_DWORD *)(qword_454098 + 24 * v15 + 18032) )
          break;
        if ( *(_DWORD *)(qword_454098 + 8) <= (int)++v15 )
        {
          v16 = 0LL;
          break;
        }
      }
    }
    v18 = (int *)(qword_454098 + 24 * v16);
    result = sub_432409(*a1, v18[4506], qword_454098, a3);
    v19 = v18[4508];
    *(_DWORD *)(a3 + 32) = v19;
    v20 = v4 + v18[4509] + 24168;
    qword_454080[v19] = v20;
    *(_QWORD *)(a3 + 48) = v20;
  }
  return result;
}
// 454080: using guessed type __int64 qword_454080[];
// 454098: using guessed type __int64 qword_454098;
// 433D49: using guessed type __int64 var_28[5];

//----- (0000000000433EF5) ----------------------------------------------------
__int64 __fastcall sub_433EF5(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  char *v4; // r12
  __int64 v5; // rdi
  int v7; // eax
  unsigned __int64 v8; // rax

  v4 = (char *)sub_437CA8((__int64)"TZ");
  if ( v4 )
  {
    if ( dword_4540B0 <= 0 || (a2 = v4, (unsigned int)sub_43AD14(&unk_453F80, v4)) )
    {
      v8 = sub_43AD53(v4);
      dword_4540B0 = v8 <= 0xFF;
      if ( v8 <= 0xFF )
      {
        a2 = v4;
        sub_43A0CE((__int64)&unk_453F80, (__int64)v4);
      }
      if ( !qword_454098 )
      {
        v5 = 25480LL;
        qword_454098 = sub_434FC4(25480LL);
        if ( !qword_454098 )
          return sub_4322A9(v5, (__int64)a2, a4);
      }
      a2 = (char *)qword_454098;
      if ( *v4 )
      {
        v5 = (__int64)v4;
        if ( (unsigned int)sub_433507(v4, qword_454098, 1LL) )
        {
          if ( *v4 == 58 )
          {
LABEL_17:
            v5 = qword_454098;
            sub_433C81(qword_454098);
            return sub_4322A9(v5, (__int64)a2, a4);
          }
          a2 = (char *)qword_454098;
          v5 = (__int64)v4;
          v7 = sub_43307C(v4, qword_454098, 0LL);
LABEL_19:
          if ( !v7 )
            return sub_4322A9(v5, (__int64)a2, a4);
          goto LABEL_17;
        }
      }
      else
      {
        v5 = qword_454098 + 24168;
        *(_QWORD *)qword_454098 = 0LL;
        *((_DWORD *)a2 + 2) = 0;
        *((_QWORD *)a2 + 2253) = 0LL;
        *((_QWORD *)a2 + 2254) = 0LL;
        a2 = byte_446A80;
        sub_43A0CE(v5, (__int64)byte_446A80);
      }
      return sub_4322A9(v5, (__int64)a2, a4);
    }
  }
  else if ( dword_4540B0 >= 0 )
  {
    dword_4540B0 = -1;
    if ( !qword_454098 )
    {
      v5 = 25480LL;
      qword_454098 = sub_434FC4(25480LL);
      if ( !qword_454098 )
        return sub_4322A9(v5, (__int64)a2, a4);
    }
    a2 = (char *)qword_454098;
    v5 = 0LL;
    v7 = sub_433507(0LL, qword_454098, 1LL);
    goto LABEL_19;
  }
  return a4;
}
// 434FC4: using guessed type __int64 __fastcall sub_434FC4(_QWORD);
// 43AD14: using guessed type __int64 __fastcall sub_43AD14(_QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 454098: using guessed type __int64 qword_454098;
// 4540B0: using guessed type int dword_4540B0;

//----- (0000000000434061) ----------------------------------------------------
__int64 __fastcall sub_434061(__int64 *a1, char *a2, __int64 a3, __int64 a4)
{
  sub_433EF5((__int64)a1, a2, a3, a4);
  return sub_433D49(a1, 0LL, (__int64)a2);
}

//----- (000000000043408C) ----------------------------------------------------
__int64 __fastcall sub_43408C(__int64 *a1, __int64 a2)
{
  return sub_433CBC(a1, 0, a2);
}

//----- (0000000000434096) ----------------------------------------------------
__int64 __fastcall sub_434096(unsigned int *a1, char *a2, __int64 a3, __int64 a4)
{
  sub_433EF5((__int64)a1, a2, a3, a4);
  return sub_432E8A(a1, sub_433D49, 0);
}

//----- (00000000004340B8) ----------------------------------------------------
_BYTE *__fastcall sub_4340B8(_BYTE *a1, unsigned __int64 a2, char *a3)
{
  _BYTE *result; // rax
  char v4; // cl

  for ( result = a1; (unsigned __int64)result < a2; ++result )
  {
    v4 = *a3++;
    *result = v4;
    if ( !v4 )
      break;
  }
  return result;
}

//----- (00000000004340D1) ----------------------------------------------------
_BYTE *__fastcall sub_4340D1(_BYTE *a1, unsigned __int64 a2, unsigned int a3, _BYTE *a4)
{
  char v5[28]; // [rsp+4h] [rbp-1Ch] BYREF

  sub_438FFB((__int64)v5, 12LL, a4, a3);
  return sub_4340B8(a1, a2, v5);
}

//----- (0000000000434113) ----------------------------------------------------
_BYTE *__fastcall sub_434113(_BYTE *a1, _BYTE *a2, _BYTE *a3, __int64 a4)
{
  bool v8; // zf
  _BYTE *v9; // rdx
  char v10; // al
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  char *v14; // rcx
  __int64 v15; // rcx
  char *v16; // rdx
  char *v17; // rdx
  int *v18; // rdi
  __int64 v19; // rcx
  char *v20; // rsi
  __int64 v21; // rax
  __int64 v22; // rdx
  char *v23; // r8
  __int64 v24; // rax
  __int64 v25; // rdx
  _BYTE *v26; // rax
  __int64 v27; // rax
  int v28; // eax
  int v29; // ecx
  int v30; // esi
  int v31; // edx
  int v32; // ecx
  int v33; // edx
  int v34; // ecx
  int v35; // ecx
  int v36; // edx
  unsigned __int64 v37; // rsi
  _BYTE *v38; // rdi
  __int64 v39; // rax
  char *v40; // rdx
  __int64 v41; // r8
  int v43[22]; // [rsp+8h] [rbp-58h] BYREF

LABEL_1:
  if ( !*a3 )
    return a1;
  v8 = *a3 == 37;
LABEL_3:
  if ( !v8 )
    goto LABEL_133;
  while ( 1 )
  {
    v9 = a3;
    v10 = *++a3;
    if ( v10 == 98 )
      goto LABEL_77;
    if ( v10 > 98 )
    {
      if ( v10 == 112 )
      {
        v17 = (char *)&word_446A8A;
        if ( *(int *)(a4 + 8) <= 11 )
          v17 = byte_446A8D;
        goto LABEL_76;
      }
      if ( v10 <= 112 )
      {
        if ( v10 == 106 )
        {
          v14 = "%03d";
          v13 = *(_DWORD *)(a4 + 28) + 1;
          goto LABEL_122;
        }
        if ( v10 > 106 )
        {
          if ( v10 != 109 )
          {
            if ( v10 > 109 )
            {
              v17 = "%s: %#lx %s %#lx (%s)\n" + 21;
              if ( v10 != 110 )
                goto LABEL_133;
              goto LABEL_76;
            }
            if ( v10 == 107 )
            {
              v13 = *(_DWORD *)(a4 + 8);
            }
            else
            {
              v13 = *(_DWORD *)(a4 + 8) % 12;
              if ( !v13 )
                v13 = 12;
            }
            goto LABEL_86;
          }
          v13 = *(_DWORD *)(a4 + 16) + 1;
        }
        else
        {
          if ( v10 != 100 )
          {
            if ( v10 <= 100 )
            {
              v15 = a4;
              v16 = "%D %X";
              goto LABEL_114;
            }
            if ( v10 != 101 )
            {
              if ( v10 != 104 )
                goto LABEL_133;
LABEL_77:
              v27 = *(int *)(a4 + 16);
              v17 = byte_446A88;
              if ( (unsigned int)v27 <= 0xB )
                v17 = (char *)qword_446E10 + 4 * v27;
              goto LABEL_76;
            }
            v13 = *(_DWORD *)(a4 + 12);
LABEL_86:
            v14 = "%2d";
            goto LABEL_122;
          }
          v13 = *(_DWORD *)(a4 + 12);
        }
LABEL_121:
        v14 = "%s-%02d-%02d" + 8;
        goto LABEL_122;
      }
      if ( v10 == 118 )
      {
        v15 = a4;
        v16 = "%e-%b-%Y";
        goto LABEL_114;
      }
      if ( v10 <= 118 )
      {
        if ( v10 == 116 )
        {
          v17 = "\t";
          goto LABEL_76;
        }
        if ( v10 <= 116 )
        {
          if ( v10 != 114 )
          {
            if ( v10 != 115 )
              goto LABEL_133;
            v18 = v43;
            v19 = 14LL;
            v20 = (char *)a4;
            while ( v19 )
            {
              *v18 = *(_DWORD *)v20;
              v20 += 4;
              ++v18;
              --v19;
            }
            v21 = sub_434096((unsigned int *)v43, v20, (__int64)v9, 0LL);
            sub_438FFB((__int64)&unk_4540A0, 12LL, "%ld", v21);
            v17 = (char *)&unk_4540A0;
            goto LABEL_76;
          }
          v15 = a4;
          v16 = "%I:%M:%S %p";
          goto LABEL_114;
        }
        v13 = *(_DWORD *)(a4 + 24);
        if ( !v13 )
          v13 = 7;
LABEL_119:
        v14 = "%y-%m-%d" + 6;
LABEL_122:
        v37 = (unsigned __int64)a2;
        v38 = a1;
LABEL_130:
        v26 = sub_4340D1(v38, v37, v13, v14);
        goto LABEL_131;
      }
      if ( v10 == 121 )
      {
        v13 = (*(_DWORD *)(a4 + 20) + 1900) % 100;
        goto LABEL_121;
      }
      if ( v10 <= 121 )
      {
        if ( v10 == 119 )
        {
          v13 = *(_DWORD *)(a4 + 24);
          goto LABEL_119;
        }
LABEL_79:
        v15 = a4;
        v16 = "%m/%d/%y";
LABEL_114:
        v26 = sub_434113(a1, (unsigned __int64)a2, v16, v15);
        goto LABEL_131;
      }
      if ( v10 != 122 )
        goto LABEL_133;
      if ( *(int *)(a4 + 32) >= 0 )
      {
        v40 = (char *)&word_446A92;
        if ( *(__int64 *)(a4 + 40) < 0 )
          v40 = byte_446A90;
        v37 = (unsigned __int64)a2;
        v38 = sub_4340B8(a1, (unsigned __int64)a2, v40);
        v14 = "%04d";
        v13 = 100 * (v41 / 60 / 60) + v41 / 60 % 60;
        goto LABEL_130;
      }
LABEL_135:
      ++a3;
      goto LABEL_1;
    }
    if ( v10 == 82 )
    {
      v15 = a4;
      v16 = "%H:%M";
      goto LABEL_114;
    }
    if ( v10 > 82 )
    {
      if ( v10 == 87 )
      {
        v35 = *(_DWORD *)(a4 + 24);
        v36 = 6;
        if ( v35 )
          v36 = v35 - 1;
        v12 = *(_DWORD *)(a4 + 28) + 7 - v36;
      }
      else
      {
        if ( v10 > 87 )
        {
          if ( v10 == 90 )
          {
            v17 = *(char **)(a4 + 48);
            if ( !v17 )
            {
              v39 = *(int *)(a4 + 32);
              v17 = byte_446A88;
              if ( (unsigned int)v39 <= 1 )
                v17 = (char *)qword_454080[v39];
            }
            goto LABEL_76;
          }
          if ( v10 > 90 )
          {
            if ( v10 != 97 )
              goto LABEL_133;
            v24 = *(int *)(a4 + 24);
            v17 = byte_446A88;
            if ( (unsigned int)v24 <= 6 )
              v17 = &byte_446E87[4 * v24];
            goto LABEL_76;
          }
          if ( v10 != 88 )
          {
            v14 = "%04d";
            v13 = *(_DWORD *)(a4 + 20) + 1900;
            goto LABEL_122;
          }
LABEL_97:
          v15 = a4;
          v16 = "%H:%M:%S";
          goto LABEL_114;
        }
        if ( v10 != 85 )
        {
          if ( v10 <= 85 )
          {
            if ( v10 == 83 )
            {
              v13 = *(_DWORD *)a4;
              v14 = "%s-%02d-%02d" + 8;
              goto LABEL_122;
            }
            goto LABEL_97;
          }
          v29 = *(_DWORD *)(a4 + 24);
          v30 = *(_DWORD *)(a4 + 28);
          v31 = 6;
          if ( v29 )
            v31 = v29 - 1;
          v28 = (v30 + 10 - v31) / 7;
          if ( !v28 )
          {
            v28 = 53;
            v32 = v29 - (v30 - 1);
            if ( v32 != 5 )
            {
              v28 = 52;
              if ( v32 )
              {
                v33 = *(_DWORD *)(a4 + 20);
                v34 = v33 + 1900;
                if ( (v33 & 3) == 0 )
                {
                  v28 = 53;
                  if ( !(v34 % 100) )
                    v28 = 53 - (v34 % 400 != 0);
                }
              }
            }
          }
LABEL_102:
          v14 = "%s-%02d-%02d" + 8;
          v13 = v28;
          goto LABEL_122;
        }
        v12 = *(_DWORD *)(a4 + 28) + 7 - *(_DWORD *)(a4 + 24);
      }
      v11 = 7;
LABEL_101:
      v28 = v12 / v11;
      goto LABEL_102;
    }
    if ( v10 == 68 )
      goto LABEL_79;
    if ( v10 <= 68 )
      break;
    if ( v10 == 73 )
    {
      v13 = *(_DWORD *)(a4 + 8) % 12;
      if ( !v13 )
        v13 = 12;
      goto LABEL_121;
    }
    if ( v10 > 73 )
    {
      if ( v10 != 77 )
      {
        v8 = v10 == 79;
        goto LABEL_3;
      }
      v13 = *(_DWORD *)(a4 + 4);
      goto LABEL_121;
    }
    if ( v10 != 69 )
    {
      if ( v10 != 72 )
        goto LABEL_133;
      v13 = *(_DWORD *)(a4 + 8);
      goto LABEL_121;
    }
  }
  if ( v10 == 66 )
  {
    v25 = *(int *)(a4 + 16);
    v23 = byte_446A88;
    if ( (unsigned int)v25 <= 0xB )
      v23 = &aJanuary[10 * v25];
    goto LABEL_75;
  }
  if ( v10 > 66 )
  {
    v11 = 100;
    v12 = *(_DWORD *)(a4 + 20) + 1900;
    goto LABEL_101;
  }
  if ( v10 )
  {
    if ( v10 != 65 )
      goto LABEL_133;
    v22 = *(int *)(a4 + 24);
    v23 = byte_446A88;
    if ( (unsigned int)v22 <= 6 )
      v23 = &aSunday[10 * v22];
LABEL_75:
    v17 = v23;
LABEL_76:
    v26 = sub_4340B8(a1, (unsigned __int64)a2, v17);
LABEL_131:
    a1 = v26;
    goto LABEL_135;
  }
  a3 = v9;
LABEL_133:
  if ( a1 != a2 )
  {
    *a1++ = *a3;
    goto LABEL_135;
  }
  return a1;
}
// 43418E: conditional instruction was optimized away because al.1==43
// 4341F3: conditional instruction was optimized away because al.1==54
// 434200: conditional instruction was optimized away because al.1==56
// 43421F: conditional instruction was optimized away because al.1==59
// 434266: conditional instruction was optimized away because al.1==63
// 4342A2: conditional instruction was optimized away because al.1==6C
// 43431F: conditional instruction was optimized away because al.1==75
// 43433E: conditional instruction was optimized away because al.1==78
// 434617: variable 'v41' is possibly undefined
// 446A8A: using guessed type __int16 word_446A8A;
// 446A92: using guessed type __int16 word_446A92;
// 446E10: using guessed type __int64 qword_446E10[6];
// 454080: using guessed type __int64 qword_454080[];
// 434113: using guessed type unsigned int var_58[22];

//----- (0000000000434660) ----------------------------------------------------
__int64 __fastcall sub_434660(_BYTE *a1, __int64 a2, _BYTE *a3, __int64 a4)
{
  _BYTE *v4; // rax
  __int64 v5; // r8

  v4 = sub_434113(a1, &a1[a2], a3, a4);
  v5 = 0LL;
  if ( &a1[a2] != v4 )
  {
    *v4 = 0;
    return v4 - a1;
  }
  return v5;
}

//----- (000000000043468F) ----------------------------------------------------
_BYTE *__fastcall sub_43468F(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  int v3; // er14
  unsigned __int8 v7; // al
  __int64 v8; // rax
  char *v9; // rdi
  int v10; // eax
  _DWORD *v11; // r8
  char *v12; // rcx
  int v13; // er15
  __int64 v14; // rdx
  char *v15; // rsi
  int *v16; // rdx
  int v17; // esi
  char *v18; // rax
  unsigned int v19; // edx
  int v20; // ecx
  int v21; // esi
  __int64 v22; // rax
  __int64 v23; // r15
  int v24; // edx
  int v25; // er9
  int v26; // er10
  int v27; // er8
  _BYTE *v28; // rax
  int v29; // ecx
  int v30; // er9
  __int64 v31; // rax
  int v32; // er15
  int v33; // eax
  int v34; // eax
  int v35; // eax
  _DWORD *v37; // [rsp+0h] [rbp-70h]
  __int64 v38; // [rsp+8h] [rbp-68h]
  __int64 v39; // [rsp+10h] [rbp-60h]
  __int64 v40; // [rsp+18h] [rbp-58h]
  char v41; // [rsp+2Ch] [rbp-44h] BYREF
  int v42; // [rsp+30h] [rbp-40h] BYREF
  int v43; // [rsp+34h] [rbp-3Ch] BYREF
  char *v44; // [rsp+38h] [rbp-38h] BYREF

  v3 = 0;
  v42 = 0;
  v43 = 0;
  while ( 1 )
  {
    v7 = *a2;
    if ( !*a2 )
      break;
    if ( v7 == 37 )
    {
      v9 = a2 + 2;
      if ( a2[1] != 43 )
        v9 = a2 + 1;
      v10 = -1;
      if ( (unsigned __int8)(*v9 - 48) <= 9u )
      {
        v10 = sub_43814E(v9, &v44, 10);
        v9 = v44;
      }
      a2 = v9 + 1;
      switch ( *v9 )
      {
        case '%':
          if ( *a1 != 37 )
            return 0LL;
          ++a1;
          continue;
        case 'A':
          v11 = (_DWORD *)(a3 + 24);
          v12 = "Sunday";
          goto LABEL_21;
        case 'B':
          v11 = (_DWORD *)(a3 + 16);
          v12 = "January";
LABEL_21:
          v13 = 10;
          goto LABEL_78;
        case 'C':
          if ( v10 < 0 )
            v10 = 2;
          v16 = &v42;
          v3 |= 2u;
          v17 = 0;
          goto LABEL_66;
        case 'D':
          v14 = a3;
          v15 = "%m/%d/%y";
          goto LABEL_50;
        case 'H':
          v18 = (char *)(a3 + 8);
          v19 = 24;
          goto LABEL_58;
        case 'I':
          v18 = (char *)(a3 + 8);
          v19 = 12;
          goto LABEL_30;
        case 'M':
          v18 = (char *)(a3 + 4);
          v19 = 60;
          goto LABEL_58;
        case 'R':
          v14 = a3;
          v15 = "%H:%M";
          goto LABEL_50;
        case 'S':
          v18 = (char *)a3;
          v19 = 61;
          goto LABEL_58;
        case 'T':
        case 'X':
          v14 = a3;
          v15 = "%H:%M:%S";
          goto LABEL_50;
        case 'U':
        case 'W':
          v18 = &v41;
          v19 = 54;
          goto LABEL_58;
        case 'Y':
          v3 = 0;
          v16 = (int *)(a3 + 20);
          v17 = 1900;
          if ( v10 < 0 )
            v10 = 4;
          goto LABEL_66;
        case 'a':
          v11 = (_DWORD *)(a3 + 24);
          v12 = byte_446E87;
          goto LABEL_19;
        case 'b':
        case 'h':
          v11 = (_DWORD *)(a3 + 16);
          v12 = (char *)qword_446E10;
LABEL_19:
          v13 = 4;
LABEL_78:
          v31 = -v13;
          v32 = 0;
          v40 = v31;
          while ( 1 )
          {
            v37 = v11;
            v39 = (__int64)v12;
            v38 = sub_43AD53(v12);
            v33 = sub_43ACDD((__int64)a1, v39, v38);
            v12 = (char *)(v40 + v39);
            v11 = v37;
            if ( v33 )
              break;
            --v32;
          }
          a1 += v38;
          *v37 = v32;
          continue;
        case 'c':
          v14 = a3;
          v15 = "%a %b %e %T %Y";
          goto LABEL_50;
        case 'd':
        case 'e':
          v18 = (char *)(a3 + 12);
          v19 = 31;
LABEL_30:
          v20 = 1;
          goto LABEL_59;
        case 'j':
          v18 = (char *)(a3 + 28);
          v19 = 366;
          goto LABEL_33;
        case 'm':
          v18 = (char *)(a3 + 16);
          v19 = 12;
LABEL_33:
          v20 = 1;
          v21 = 1;
          goto LABEL_60;
        case 'n':
        case 't':
          while ( 1 )
          {
            v22 = (unsigned __int8)*a1;
            if ( !(_BYTE)v22 || (byte_44E530[v22] & 1) == 0 )
              break;
            ++a1;
          }
          continue;
        case 'p':
          v23 = sub_43AD53(byte_446A8D);
          if ( (unsigned int)sub_43ACDD((__int64)a1, (__int64)byte_446A8D, v23) )
          {
            v23 = sub_43AD53(&word_446A8A);
            if ( (unsigned int)sub_43ACDD((__int64)a1, (__int64)&word_446A8A, v23) )
              return 0LL;
            v24 = *(_DWORD *)(a3 + 8) % 12 + 12;
          }
          else
          {
            v24 = *(_DWORD *)(a3 + 8) % 12;
          }
          *(_DWORD *)(a3 + 8) = v24;
          a1 += v23;
          break;
        case 'r':
          v14 = a3;
          v15 = "%I:%M:%S %p";
          goto LABEL_50;
        case 'w':
          v18 = (char *)(a3 + 24);
          v19 = 7;
LABEL_58:
          v20 = 0;
LABEL_59:
          v21 = 0;
LABEL_60:
          if ( (unsigned __int8)(*a1 - 48) > 9u )
            return 0LL;
          *(_DWORD *)v18 = 0;
          v25 = 1;
          do
          {
            v26 = (char)*a1;
            if ( (unsigned __int8)(*a1 - 48) > 9u )
              break;
            ++a1;
            v25 *= 10;
            *(_DWORD *)v18 = v26 + 10 * *(_DWORD *)v18 - 48;
          }
          while ( (int)(v20 + v19) >= v25 );
          if ( *(_DWORD *)v18 - v20 >= v19 )
            return 0LL;
          *(_DWORD *)v18 -= v21;
          continue;
        case 'x':
          v14 = a3;
          v15 = "%y-%m-%d";
LABEL_50:
          a1 = sub_43468F(a1, v15, v14);
          if ( !a1 )
            return 0LL;
          continue;
        case 'y':
          v16 = &v43;
          v3 |= 1u;
          v17 = 0;
          v10 = 2;
LABEL_66:
          if ( *a1 == 43 )
          {
            ++a1;
            v27 = 0;
          }
          else
          {
            v27 = 0;
            if ( *a1 == 45 )
            {
              ++a1;
              v27 = 1;
            }
          }
          if ( (unsigned __int8)(*a1 - 48) > 9u )
            return 0LL;
          *v16 = 0;
          v28 = &a1[v10];
          while ( 1 )
          {
            v29 = *v16;
            if ( v28 == a1 )
              break;
            v30 = (char)*a1;
            if ( (unsigned __int8)(*a1 - 48) > 9u )
              break;
            ++a1;
            *v16 = v30 + 10 * v29 - 48;
          }
          if ( v27 )
            *v16 = -v29;
          *v16 -= v17;
          continue;
        default:
          return 0LL;
      }
    }
    else
    {
      if ( (byte_44E530[v7] & 1) != 0 )
      {
        while ( 1 )
        {
          v8 = (unsigned __int8)*a1;
          if ( !(_BYTE)v8 || (byte_44E530[v8] & 1) == 0 )
            break;
          ++a1;
        }
      }
      else
      {
        if ( v7 != *a1 )
          return 0LL;
        ++a1;
      }
      ++a2;
    }
  }
  if ( v3 )
  {
    v34 = v43;
    *(_DWORD *)(a3 + 20) = v43;
    if ( (v3 & 2) != 0 )
    {
      v35 = v34 + 100 * v42 - 1900;
LABEL_87:
      *(_DWORD *)(a3 + 20) = v35;
      return a1;
    }
    if ( v34 <= 68 )
    {
      v35 = v34 + 100;
      goto LABEL_87;
    }
  }
  return a1;
}
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 446A8A: using guessed type __int16 word_446A8A;
// 446E10: using guessed type __int64 qword_446E10[6];

//----- (0000000000434AC1) ----------------------------------------------------
__int64 __fastcall sub_434AC1(__int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdx

  if ( a2 )
    *a2 = 0LL;
  v4 = sub_4383A0((__int64)a1, 0LL, 0LL, a4);
  if ( (dword_44EB70 & 8) != 0 && a1 && v4 )
  {
    *a1 = v4;
    a1[1] = v5;
  }
  return 0LL;
}
// 434AED: variable 'v5' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;

//----- (0000000000434AF5) ----------------------------------------------------
__int64 __fastcall sub_434AF5(__int64 a1)
{
  if ( a1 )
  {
    sub_437254(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
    sub_434FBE(a1);
  }
  return 0LL;
}
// 434FBE: using guessed type __int64 __fastcall sub_434FBE(_QWORD);

//----- (0000000000434B23) ----------------------------------------------------
__int64 __fastcall sub_434B23(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // r13
  __int64 *v5; // rax

  v4 = *(unsigned int *)(a1 + 24);
  v5 = sub_434B4A(a1, a2, a3, a4);
  return sub_434EC1((__int64)v5, v4, a2);
}

//----- (0000000000434B4A) ----------------------------------------------------
__int64 *__fastcall sub_434B4A(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  _BYTE *v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  int v9; // eax
  unsigned int v10; // er12
  __int64 v11; // rax
  unsigned __int64 v12; // r13
  __int64 v13; // r14
  _DWORD *v14; // rax
  __int64 *result; // rax

  if ( byte_453CC0 )
    goto LABEL_13;
  if ( dword_44DB80 == 101010256 )
  {
    qword_453CB0 = (__int64)&dword_400000;
    qword_453CB8 = (__int64)&dword_44DB80;
    byte_453CC0 = 1;
LABEL_13:
    result = (__int64 *)qword_453CB8;
    if ( qword_453CB8 )
      return &qword_453CB0;
    return result;
  }
  v4 = (_BYTE *)sub_437BCC((const char *)qword_44EBB0);
  v9 = sub_437DD1(v4, qword_44EC98, v5, v6, v7, v8, a4);
  v10 = v9;
  if ( v9 != -1 )
  {
    v11 = sub_437D19(v9);
    v12 = v11;
    if ( v11 != -1 )
    {
      v13 = sub_43762C(0LL, v11, 1u, 1, v10, 0LL);
      v14 = sub_43A823(v13, v12);
      if ( v14 )
      {
        qword_453CB0 = v13;
        qword_453CB8 = (__int64)v14;
      }
      else
      {
        sub_437254(v13, v12);
      }
    }
    sub_437A1A(v10);
  }
  result = (__int64 *)qword_453CB8;
  byte_453CC0 = 1;
  if ( qword_453CB8 )
    return &qword_453CB0;
  return result;
}
// 434BA7: variable 'v5' is possibly undefined
// 434BA7: variable 'v6' is possibly undefined
// 434BA7: variable 'v7' is possibly undefined
// 434BA7: variable 'v8' is possibly undefined
// 400000: using guessed type int dword_400000;
// 44DB80: using guessed type int dword_44DB80;
// 44EBB0: using guessed type __int64 qword_44EBB0;
// 44EC98: using guessed type __int64 qword_44EC98;
// 453CB0: using guessed type __int64 qword_453CB0;
// 453CB8: using guessed type __int64 qword_453CB8;
// 453CC0: using guessed type char byte_453CC0;

//----- (0000000000434C48) ----------------------------------------------------
__int64 __fastcall sub_434C48(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  char v4[1696]; // [rsp+0h] [rbp-6A0h] BYREF

  if ( sub_43A438(*(_BYTE **)a1, *(_QWORD *)(a1 + 8), a2, a3, (__int64)v4) == -1 )
    return sub_4020DC();
  else
    return 0LL;
}
// 434C48: using guessed type char var_6A0[1696];

//----- (0000000000434C82) ----------------------------------------------------
__int64 __fastcall sub_434C82(_QWORD *a1, int a2)
{
  __int64 v3; // rdi
  __int64 v4; // rdx
  char v5; // cl
  __int64 *v6; // rax
  __int64 v7; // rdx
  char v8; // cl
  __int64 v9; // rdi
  __int64 *v10; // r12
  __int64 v11; // rdx
  __int64 v12; // r15
  __int64 v13; // r14
  __int64 v14; // rdx
  signed int v15; // ebx
  unsigned int v16; // er12
  __int64 v17; // rax
  _QWORD *v18; // r13
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // r15
  unsigned __int64 v22; // rdi
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned int v25; // eax
  char v27[64]; // [rsp+10h] [rbp-40h] BYREF

  v3 = (unsigned int)dword_44EC38;
  sub_437FC9((unsigned int)dword_44EC38, (__int64)&unk_44E630, (__int64)v27);
  v6 = sub_434B4A(v3, (__int64)&unk_44E630, v4, v5);
  if ( !v6 )
  {
    v25 = sub_40212C();
    goto LABEL_14;
  }
  v9 = (__int64)v6;
  v10 = v6;
  v12 = sub_434F19((__int64)v6, a1, v7, v8);
  if ( v12 == -1 )
  {
    v25 = sub_40211C();
LABEL_14:
    v16 = v25;
    goto LABEL_15;
  }
  v13 = *(unsigned int *)(*v10 + v12 + 42);
  v15 = sub_437AA9(v9, (__int64)a1, v11);
  if ( v15 != -1 )
  {
    v17 = sub_434FB8(1LL, 48LL, v14);
    v18 = (_QWORD *)v17;
    if ( v17 )
    {
      *(_DWORD *)(v17 + 24) = v12;
      v19 = *v10;
      v20 = *(unsigned int *)(*v10 + v13 + 22);
      v18[1] = v20;
      if ( (_DWORD)v20 )
      {
        v21 = v13 + 30;
        if ( *(_WORD *)(v19 + v13 + 8) )
        {
          v22 = v20 + 0x1FFFF;
          LOWORD(v22) = 0;
          v18[5] = v22;
          v23 = sub_437240(v22);
          v18[4] = v23;
          *v18 = v23 + 0x8000;
          v16 = sub_434C48(
                  (__int64)v18,
                  (unsigned __int8 *)(*v10
                                    + v21
                                    + *(unsigned __int16 *)(*v10 + v13 + 28)
                                    + *(unsigned __int16 *)(*v10 + v13 + 26)),
                  *(unsigned int *)(*v10 + v13 + 18));
          if ( v16 == -1 )
          {
            sub_434AF5((__int64)v18);
            goto LABEL_15;
          }
        }
        else
        {
          *v18 = v21 + *(unsigned __int16 *)(v19 + v13 + 28) + *(unsigned __int16 *)(v19 + v13 + 26) + v19;
        }
      }
      v16 = v15;
      v24 = qword_453AF0 + 24LL * v15;
      *(_DWORD *)(v24 + 16) = 5;
      *(_QWORD *)v24 = v18;
      *(_DWORD *)(v24 + 20) = a2;
      goto LABEL_15;
    }
  }
  v16 = -1;
LABEL_15:
  sub_437FC9((unsigned int)dword_44EC40, (__int64)v27, 0LL);
  return v16;
}
// 434CAD: variable 'v4' is possibly undefined
// 434CAD: variable 'v5' is possibly undefined
// 434CC4: variable 'v7' is possibly undefined
// 434CC4: variable 'v8' is possibly undefined
// 434CDF: variable 'v11' is possibly undefined
// 434CFF: variable 'v14' is possibly undefined
// 434FB8: using guessed type __int64 __fastcall sub_434FB8(_QWORD, _QWORD, _QWORD);
// 44EC38: using guessed type int dword_44EC38;
// 44EC40: using guessed type int dword_44EC40;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000434E00) ----------------------------------------------------
unsigned __int64 __fastcall sub_434E00(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v2; // r12
  unsigned __int64 result; // rax
  int v4; // er8

  v2 = sub_43AD53(a1) - 4;
  result = -1LL;
  if ( v2 <= 0xF3 )
  {
    v4 = sub_43AA7D(a1, "zip:", 4LL);
    result = -1LL;
    if ( !v4 )
    {
      a2[1] = v2;
      result = v2;
      *a2 = a1 + 4;
    }
  }
  return result;
}
// 43AA7D: using guessed type __int64 __fastcall sub_43AA7D(_QWORD, _QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (0000000000434E5B) ----------------------------------------------------
unsigned __int64 __fastcall sub_434E5B(_QWORD *a1, __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  _QWORD *v4; // r10
  __int64 *v5; // r8
  __int64 v6; // r11
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rax
  __int64 v9; // r9
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rdx

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( a4 == -1LL )
    v7 = a1[2];
  v8 = v7;
  v9 = 0LL;
  while ( v9 != v6 )
  {
    v10 = v4[1];
    if ( v8 >= v10 )
      break;
    v11 = v10 - v8;
    if ( v5[1] <= v11 )
      v11 = v5[1];
    sub_43AAA0(*v5, v8 + *v4, v11);
    v8 = v13 + v12;
  }
  if ( a4 == -1LL )
    v4[2] = v8;
  return v8 - v7;
}
// 434E7F: variable 'v9' is possibly undefined
// 434E7F: variable 'v6' is possibly undefined
// 434E84: variable 'a4' is possibly undefined
// 434E86: variable 'v4' is possibly undefined
// 434E98: variable 'v5' is possibly undefined
// 434EB6: variable 'v13' is possibly undefined
// 434EB6: variable 'v12' is possibly undefined

//----- (0000000000434EC1) ----------------------------------------------------
__int64 __fastcall sub_434EC1(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  __int64 *v6; // rcx
  __int64 v7; // rdx
  int v8; // ecx

  if ( !a1 || !a3 )
    return sub_4020CC();
  sub_43ABE2(a3, 0LL, 0xE0uLL);
  v7 = *v6;
  v8 = 33188;
  if ( *(_BYTE *)(v7 + v5 + 5) == 3 )
    v8 = *(unsigned __int16 *)(v7 + v5 + 40);
  *(_DWORD *)(a3 + 24) = v8;
  *(_QWORD *)(a3 + 48) = *(unsigned int *)(v7 + v5 + 24);
  *(_QWORD *)(a3 + 64) = (unsigned int)(*(_DWORD *)(v7 + v5 + 20) + 511) >> 9;
  return 0LL;
}
// 434EE0: variable 'v6' is possibly undefined
// 434EE8: variable 'v5' is possibly undefined

//----- (0000000000434F19) ----------------------------------------------------
__int64 __fastcall sub_434F19(__int64 a1, _QWORD *a2, __int64 a3, char a4)
{
  __int64 *v4; // r12
  __int64 result; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // r14
  __int64 v8; // rbx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // r15
  int v12; // eax
  __int64 v13; // [rsp+0h] [rbp-40h]
  unsigned __int64 v14; // [rsp+8h] [rbp-38h]

  v4 = sub_434B4A(a1, (__int64)a2, a3, a4);
  result = -1LL;
  if ( v4 )
  {
    v6 = v4[1];
    v7 = 0LL;
    v8 = *(unsigned int *)(v6 + 16);
    v14 = *(unsigned __int16 *)(v6 + 10);
    while ( v14 > v7 )
    {
      v9 = *v4;
      v10 = a2[1];
      v11 = *(unsigned __int16 *)(*v4 + v8 + 28);
      if ( v10 == v11 )
      {
        v13 = *v4;
        v12 = sub_43AA7D(*a2, v9 + v8 + 46, v10);
        v9 = v13;
        if ( !v12 )
          return v8;
      }
      ++v7;
      v8 += *(unsigned __int16 *)(v9 + v8 + 30) + (int)v11 + *(unsigned __int16 *)(v9 + v8 + 32) + 46;
    }
    return -1LL;
  }
  return result;
}
// 43AA7D: using guessed type __int64 __fastcall sub_43AA7D(_QWORD, _QWORD, _QWORD);

//----- (0000000000434FD0) ----------------------------------------------------
__int64 __fastcall sub_434FD0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax

  v3 = a2 & 0xF;
  if ( (a2 & 0xF) != 0 )
    v3 = -((_DWORD)a2 + 16) & 0xF;
  a1[5] = a2 + v3;
  a1[2] = a3 - v3;
  *(_QWORD *)(a2 + v3 + 8) = (a3 - v3) | 1;
  result = qword_4524C0;
  *(_QWORD *)(a2 + a3 + 8) = 80LL;
  a1[6] = result;
  return result;
}
// 4524C0: using guessed type __int64 qword_4524C0;

//----- (0000000000435017) ----------------------------------------------------
__int64 __fastcall sub_435017(__int64 a1)
{
  __int64 v1; // r14
  __int64 v3; // rax
  int v4; // er13
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // r8
  _QWORD *v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  _QWORD *v13; // rcx
  _QWORD *v14; // rdx
  _QWORD *v15; // r9
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rdx
  unsigned __int64 v20; // rdx
  unsigned int v21; // eax
  int v22; // edx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v29; // [rsp+8h] [rbp-38h]

  v1 = 0LL;
  v3 = *(_QWORD *)(a1 + 904);
  if ( v3 )
  {
    if ( (*(_DWORD *)(v3 + 24) & 1) != 0 )
    {
      v4 = *(_DWORD *)(v3 + 24) & 8;
      if ( !v4 )
      {
        v5 = *(_QWORD *)v3;
        v6 = *(_QWORD *)v3 & 0xFLL;
        if ( (*(_QWORD *)v3 & 0xF) != 0 )
          v6 = -(*(_DWORD *)v3 + 16) & 0xF;
        v7 = v5 + v6;
        v1 = 0LL;
        if ( (*(_QWORD *)(v5 + v6 + 8) & 3LL) == 1 )
        {
          v1 = *(_QWORD *)(v3 + 8);
          v8 = *(_QWORD *)(v5 + v6 + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( v7 + v8 < v5 + v1 - 80 )
            goto LABEL_48;
          v9 = *(_QWORD *)(v3 + 16);
          if ( *(_QWORD *)(a1 + 32) == v7 )
          {
            *(_QWORD *)(a1 + 32) = 0LL;
            *(_QWORD *)(a1 + 8) = 0LL;
            goto LABEL_32;
          }
          v10 = *(_QWORD **)(v7 + 24);
          v11 = *(_QWORD *)(v7 + 48);
          if ( v10 != (_QWORD *)v7 )
          {
            v12 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v12 + 24) = v10;
            v10[2] = v12;
            goto LABEL_19;
          }
          v10 = (_QWORD *)v10[5];
          v13 = (_QWORD *)(v7 + 40);
          if ( !v10 )
          {
            v10 = *(_QWORD **)(v7 + 32);
            if ( !v10 )
              goto LABEL_19;
            v13 = (_QWORD *)(v7 + 32);
          }
          v14 = v10;
          do
          {
            do
            {
              v15 = v13;
              v10 = v14;
              v13 = v14 + 5;
              v14 = (_QWORD *)v14[5];
            }
            while ( v14 );
            v14 = (_QWORD *)v10[4];
            v13 = v10 + 4;
          }
          while ( v14 );
          *v15 = 0LL;
LABEL_19:
          if ( v11 )
          {
            v16 = *(unsigned int *)(v7 + 56);
            v17 = a1 + 8 * v16;
            if ( *(_QWORD *)(v17 + 600) == v7 )
            {
              *(_QWORD *)(v17 + 600) = v10;
              if ( !v10 )
              {
                *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v16);
                goto LABEL_32;
              }
            }
            else
            {
              if ( *(_QWORD *)(v11 + 32) == v7 )
                *(_QWORD *)(v11 + 32) = v10;
              else
                *(_QWORD *)(v11 + 40) = v10;
              if ( !v10 )
                goto LABEL_32;
            }
            v18 = *(_QWORD *)(v7 + 32);
            v10[6] = v11;
            if ( v18 )
            {
              v10[4] = v18;
              *(_QWORD *)(v18 + 48) = v10;
            }
            v19 = *(_QWORD *)(v7 + 40);
            if ( v19 )
            {
              v10[5] = v19;
              *(_QWORD *)(v19 + 48) = v10;
            }
          }
LABEL_32:
          v29 = v9;
          if ( !(unsigned int)sub_437254(v5, v1) )
          {
            *(_QWORD *)(a1 + 856) -= v1;
            *(_QWORD *)(a1 + 904) = v29;
            goto LABEL_49;
          }
          v20 = v8 >> 8;
          v21 = v8 >> 8;
          if ( v21 )
          {
            v21 = 31;
            if ( (unsigned int)v20 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v20, v20);
              v21 = ((v8 >> (38 - ((unsigned __int8)v20 ^ 0x1Fu))) & 1) + 2 * (31 - (v20 ^ 0x1F));
            }
          }
          v22 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)(v7 + 56) = v21;
          *(_QWORD *)(v7 + 40) = 0LL;
          *(_QWORD *)(v7 + 32) = 0LL;
          if ( ((1 << v21) & v22) != 0 )
          {
            v23 = *(_QWORD *)(a1 + 8LL * v21 + 600);
            if ( v21 != 31 )
              LOBYTE(v4) = 57 - (v21 >> 1);
            v24 = v8 << v4;
            while ( (*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v8 )
            {
              v25 = v24;
              v24 *= 2LL;
              v26 = (v25 >> 63) + 4;
              if ( !*(_QWORD *)(v23 + 8 * v26) )
              {
                *(_QWORD *)(v23 + 8 * v26) = v7;
                *(_QWORD *)(v7 + 48) = v23;
                goto LABEL_46;
              }
              v23 = *(_QWORD *)(v23 + 8 * v26);
            }
            v27 = *(_QWORD *)(v23 + 16);
            *(_QWORD *)(v27 + 24) = v7;
            *(_QWORD *)(v23 + 16) = v7;
            *(_QWORD *)(v7 + 16) = v27;
            *(_QWORD *)(v7 + 24) = v23;
            *(_QWORD *)(v7 + 48) = 0LL;
          }
          else
          {
            *(_DWORD *)(a1 + 4) = (1 << v21) | v22;
            *(_QWORD *)(a1 + 8LL * v21 + 600) = v7;
            *(_QWORD *)(v7 + 48) = a1 + 8LL * v21 + 600;
LABEL_46:
            *(_QWORD *)(v7 + 24) = v7;
            *(_QWORD *)(v7 + 16) = v7;
          }
LABEL_48:
          v1 = 0LL;
        }
      }
    }
  }
LABEL_49:
  *(_QWORD *)(a1 + 56) = 128LL;
  return v1;
}

//----- (00000000004352D4) ----------------------------------------------------
_BOOL8 __fastcall sub_4352D4(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  _QWORD *v8; // rcx
  unsigned __int64 *v9; // r13
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r9
  int v12; // eax
  unsigned __int64 v13; // r14
  __int64 v14; // rdx

  if ( a2 > 0xFFFFFFFFFFFFFF7FLL || (v3 = a1[5]) == 0 )
  {
LABEL_2:
    v2 = 0LL;
    return v2 != 0;
  }
  v5 = a1[2];
  v6 = a2 + 80;
  if ( v5 > v6 )
  {
    v8 = a1 + 111;
    v9 = a1 + 111;
    while ( 1 )
    {
      v10 = *v9;
      if ( v3 >= *v9 )
      {
        v11 = v9[1];
        if ( v3 < v10 + v11 )
          break;
      }
      v9 = (unsigned __int64 *)v9[2];
      if ( !v9 )
        BUG();
    }
    v12 = *((_DWORD *)v9 + 6);
    if ( (v12 & 8) == 0 && (v12 & 1) != 0 )
    {
      v7 = qword_4524B0 * ((v5 + qword_4524B0 - 1 - v6) / qword_4524B0 - 1);
      if ( v7 <= v11 )
      {
        while ( v10 > (unsigned __int64)v8 || v10 + v11 <= (unsigned __int64)v8 )
        {
          v8 = (_QWORD *)v8[2];
          if ( !v8 )
          {
            v13 = v11 - v7;
            if ( sub_4378A4() == -1 && (unsigned int)sub_437254(v13 + *v9, v7) )
              break;
            if ( v7 )
            {
              v9[1] -= v7;
              v14 = a1[2];
              a1[107] -= v7;
              sub_434FD0(a1, a1[5], v14 - v7);
            }
            goto LABEL_21;
          }
        }
      }
    }
  }
  v7 = 0LL;
LABEL_21:
  v2 = sub_435017((__int64)a1) + v7;
  if ( !v2 )
  {
    if ( a1[2] > a1[6] )
    {
      a1[6] = -1LL;
      return v2 != 0;
    }
    goto LABEL_2;
  }
  return v2 != 0;
}
// 4524B0: using guessed type __int64 qword_4524B0;

//----- (0000000000435410) ----------------------------------------------------
__int64 __fastcall sub_435410(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rdi
  __int64 result; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r8
  __int64 v8; // r12
  unsigned __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  __int64 v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r10
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  _QWORD *v25; // rax
  _QWORD *v26; // rsi
  __int64 v27; // r8
  __int64 v28; // rcx
  _QWORD *v29; // r9
  _QWORD *v30; // rcx
  _QWORD *v31; // r11
  __int64 v32; // rcx
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // rcx
  unsigned __int64 v36; // rcx
  __int64 v37; // rdx
  unsigned __int64 v38; // rsi
  unsigned int v39; // eax
  int v40; // esi
  int v41; // ecx
  __int64 v42; // r8
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rax

  v4 = a2;
  result = *(_QWORD *)(a2 + 8);
  v6 = a3 + a2;
  if ( (result & 1) != 0 )
    goto LABEL_34;
  v7 = *(_QWORD *)v4;
  v4 -= *(_QWORD *)v4;
  if ( (result & 3) == 0 )
  {
    v8 = v7 + a3 + 32;
    result = sub_437254(v4, v8);
    if ( !(_DWORD)result )
      *(_QWORD *)(a1 + 856) -= v8;
    return result;
  }
  a3 += v7;
  if ( *(_QWORD *)(a1 + 32) == v4 )
  {
    result = *(_QWORD *)(v6 + 8);
    if ( (result & 3) == 3 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      *(_QWORD *)(v6 + 8) = result & 0xFFFFFFFFFFFFFFFELL;
      result = a3 | 1;
      *(_QWORD *)(v4 + 8) = a3 | 1;
      *(_QWORD *)v6 = a3;
      return result;
    }
    goto LABEL_34;
  }
  result = *(_QWORD *)(v4 + 24);
  v9 = v7 >> 3;
  if ( v7 <= 0xFF )
  {
    v10 = *(_QWORD *)(v4 + 16);
    if ( v10 == result )
    {
      result = (unsigned int)__ROL4__(-2, v9);
      *(_DWORD *)a1 &= result;
    }
    else
    {
      *(_QWORD *)(v10 + 24) = result;
      *(_QWORD *)(result + 16) = v10;
    }
    goto LABEL_34;
  }
  v11 = *(_QWORD *)(v4 + 48);
  if ( v4 == result )
  {
    result = *(_QWORD *)(v4 + 40);
    v13 = (_QWORD *)(v4 + 40);
    if ( !result )
    {
      result = *(_QWORD *)(v4 + 32);
      if ( !result )
        goto LABEL_19;
      v13 = (_QWORD *)(v4 + 32);
    }
    v14 = result;
    do
    {
      do
      {
        v15 = v13;
        result = v14;
        v13 = (_QWORD *)(v14 + 40);
        v14 = *(_QWORD *)(v14 + 40);
      }
      while ( v14 );
      v14 = *(_QWORD *)(result + 32);
      v13 = (_QWORD *)(result + 32);
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_19;
  }
  v12 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v12 + 24) = result;
  *(_QWORD *)(result + 16) = v12;
LABEL_19:
  if ( !v11 )
    goto LABEL_34;
  v16 = *(unsigned int *)(v4 + 56);
  v17 = a1 + 8 * v16;
  if ( *(_QWORD *)(v17 + 600) == v4 )
  {
    *(_QWORD *)(v17 + 600) = result;
    if ( !result )
    {
      result = (unsigned int)__ROL4__(-2, v16);
      *(_DWORD *)(a1 + 4) &= result;
      goto LABEL_34;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v4 )
      *(_QWORD *)(v11 + 32) = result;
    else
      *(_QWORD *)(v11 + 40) = result;
    if ( !result )
      goto LABEL_34;
  }
  v18 = *(_QWORD *)(v4 + 32);
  *(_QWORD *)(result + 48) = v11;
  if ( v18 )
  {
    *(_QWORD *)(result + 32) = v18;
    *(_QWORD *)(v18 + 48) = result;
  }
  v19 = *(_QWORD *)(v4 + 40);
  if ( v19 )
  {
    *(_QWORD *)(result + 40) = v19;
    *(_QWORD *)(v19 + 48) = result;
  }
LABEL_34:
  v20 = *(_QWORD *)(v6 + 8);
  if ( (v20 & 2) == 0 )
  {
    v21 = *(_QWORD *)(a1 + 32);
    if ( *(_QWORD *)(a1 + 40) == v6 )
    {
      v22 = *(_QWORD *)(a1 + 16) + a3;
      *(_QWORD *)(a1 + 40) = v4;
      *(_QWORD *)(a1 + 16) = v22;
      *(_QWORD *)(v4 + 8) = v22 | 1;
      if ( v4 == v21 )
      {
        *(_QWORD *)(a1 + 32) = 0LL;
        *(_QWORD *)(a1 + 8) = 0LL;
      }
      return result;
    }
    if ( v6 == v21 )
    {
      v23 = *(_QWORD *)(a1 + 8) + a3;
      *(_QWORD *)(a1 + 32) = v4;
      *(_QWORD *)(a1 + 8) = v23;
      result = v23 | 1;
      *(_QWORD *)(v4 + 8) = v23 | 1;
      *(_QWORD *)(v4 + v23) = v23;
      return result;
    }
    v24 = v20 & 0xFFFFFFFFFFFFFFF8LL;
    v25 = *(_QWORD **)(v6 + 24);
    a3 += v24;
    if ( v24 <= 0xF8 )
    {
      v26 = *(_QWORD **)(v6 + 16);
      if ( v26 == v25 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v24 >> 3);
      }
      else
      {
        v26[3] = v25;
        v25[2] = v26;
      }
      goto LABEL_66;
    }
    v27 = *(_QWORD *)(v6 + 48);
    if ( (_QWORD *)v6 != v25 )
    {
      v28 = *(_QWORD *)(v6 + 16);
      *(_QWORD *)(v28 + 24) = v25;
      v25[2] = v28;
      goto LABEL_53;
    }
    v25 = *(_QWORD **)(v6 + 40);
    v29 = (_QWORD *)(v6 + 40);
    if ( !v25 )
    {
      v25 = *(_QWORD **)(v6 + 32);
      if ( !v25 )
        goto LABEL_53;
      v29 = (_QWORD *)(v6 + 32);
    }
    v30 = v25;
    do
    {
      do
      {
        v31 = v29;
        v25 = v30;
        v29 = v30 + 5;
        v30 = (_QWORD *)v30[5];
      }
      while ( v30 );
      v30 = (_QWORD *)v25[4];
      v29 = v25 + 4;
    }
    while ( v30 );
    *v31 = 0LL;
LABEL_53:
    if ( !v27 )
      goto LABEL_66;
    v32 = *(unsigned int *)(v6 + 56);
    v33 = a1 + 8 * v32;
    if ( *(_QWORD *)(v33 + 600) == v6 )
    {
      *(_QWORD *)(v33 + 600) = v25;
      if ( !v25 )
      {
        *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v32);
        goto LABEL_66;
      }
    }
    else
    {
      if ( *(_QWORD *)(v27 + 32) == v6 )
        *(_QWORD *)(v27 + 32) = v25;
      else
        *(_QWORD *)(v27 + 40) = v25;
      if ( !v25 )
        goto LABEL_66;
    }
    v34 = *(_QWORD *)(v6 + 32);
    v25[6] = v27;
    if ( v34 )
    {
      v25[4] = v34;
      *(_QWORD *)(v34 + 48) = v25;
    }
    v35 = *(_QWORD *)(v6 + 40);
    if ( v35 )
    {
      v25[5] = v35;
      *(_QWORD *)(v35 + 48) = v25;
    }
LABEL_66:
    result = a3 | 1;
    *(_QWORD *)(v4 + 8) = a3 | 1;
    *(_QWORD *)(v4 + a3) = a3;
    if ( v4 == v21 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      return result;
    }
    goto LABEL_69;
  }
  *(_QWORD *)(v6 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v4 + 8) = a3 | 1;
  *(_QWORD *)(v4 + a3) = a3;
LABEL_69:
  v36 = a3 >> 3;
  if ( a3 > 0xFF )
  {
    v38 = a3 >> 8;
    v39 = a3 >> 8;
    if ( v39 )
    {
      v39 = 31;
      if ( (unsigned int)v38 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v38, v38);
        v39 = ((a3 >> (38 - ((unsigned __int8)v38 ^ 0x1Fu))) & 1) + 2 * (31 - (v38 ^ 0x1F));
      }
    }
    v40 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v4 + 56) = v39;
    *(_QWORD *)(v4 + 40) = 0LL;
    v41 = 1 << v39;
    *(_QWORD *)(v4 + 32) = 0LL;
    v42 = v39;
    if ( ((1 << v39) & v40) != 0 )
    {
      v43 = 0;
      v44 = *(_QWORD *)(a1 + 8LL * v39 + 600);
      if ( v39 != 31 )
        v43 = 57 - (v39 >> 1);
      v45 = a3 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != a3 )
      {
        v46 = v45;
        v45 *= 2LL;
        result = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * result) )
        {
          *(_QWORD *)(v44 + 8 * result) = v4;
          *(_QWORD *)(v4 + 48) = v44;
          goto LABEL_86;
        }
        v44 = *(_QWORD *)(v44 + 8 * result);
      }
      result = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(result + 24) = v4;
      *(_QWORD *)(v44 + 16) = v4;
      *(_QWORD *)(v4 + 16) = result;
      *(_QWORD *)(v4 + 24) = v44;
      *(_QWORD *)(v4 + 48) = 0LL;
    }
    else
    {
      result = a1 + 8LL * v39 + 600;
      *(_DWORD *)(a1 + 4) = v41 | v40;
      *(_QWORD *)(a1 + 8 * v42 + 600) = v4;
      *(_QWORD *)(v4 + 48) = result;
LABEL_86:
      *(_QWORD *)(v4 + 24) = v4;
      *(_QWORD *)(v4 + 16) = v4;
    }
  }
  else
  {
    result = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    if ( ((1 << v36) & *(_DWORD *)a1) != 0 )
    {
      v37 = *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88);
    }
    else
    {
      *(_DWORD *)a1 |= 1 << v36;
      v37 = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    }
    *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88) = v4;
    *(_QWORD *)(v37 + 24) = v4;
    *(_QWORD *)(v4 + 16) = v37;
    *(_QWORD *)(v4 + 24) = result;
  }
  return result;
}

//----- (000000000043588C) ----------------------------------------------------
unsigned __int64 __fastcall sub_43588C(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  int v2; // esi
  unsigned __int64 v3; // rcx
  unsigned int v4; // eax
  int v5; // ecx
  char *v6; // rdi
  __int128 v7; // rax
  __int64 v8; // r8
  unsigned __int64 v9; // r9
  int v10; // eax
  int v11; // ecx
  __int64 v12; // rdi
  char *v13; // r10
  __int64 v14; // r11
  __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // rdx
  int v19; // er11
  char *v20; // r8
  char *v21; // rcx
  int v22; // edi
  unsigned int v23; // eax
  __int64 v24; // rcx
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r12
  __int64 v28; // rcx
  __int64 v29; // r11
  __int64 v30; // rcx
  _QWORD *v31; // r13
  __int64 v32; // r11
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // r10
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  int v38; // er9
  char *v39; // rdi
  char *v40; // rcx
  unsigned __int64 v41; // rbx
  int v42; // edi
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r9
  unsigned int v45; // esi
  char v46; // cl
  __int64 v47; // r11
  __int64 v48; // r10
  unsigned __int64 i; // rcx
  unsigned __int64 v50; // rdx
  unsigned int v51; // eax
  __int64 v52; // rcx
  __int64 v53; // rsi
  unsigned __int64 v54; // r10
  __int64 v55; // rcx
  __int64 v56; // r8
  __int64 v57; // rcx
  _QWORD *v58; // r11
  __int64 v59; // r8
  __int64 v60; // rcx
  __int64 v61; // rcx
  __int64 v62; // r8
  unsigned __int64 v63; // rcx
  int v64; // edi
  char *v65; // rdx
  char *v66; // rcx
  unsigned __int64 v67; // rsi
  unsigned int v68; // edx
  int v69; // esi
  char v70; // cl
  __int64 v71; // rsi
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // rdx
  __int64 v74; // rdx
  __int64 v75; // rdx
  unsigned __int64 v76; // rcx
  unsigned __int64 *v77; // rsi
  __int64 v78; // rdx
  unsigned __int64 v79; // r12
  unsigned __int64 v80; // r12
  unsigned __int64 v81; // r12
  unsigned __int64 v82; // r9
  __int64 v83; // rax
  __int64 v84; // r10
  _QWORD *v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rsi
  __int64 v88; // rax
  __int64 *v89; // rcx
  char v90; // r11
  __int64 v91; // rcx
  __int64 v92; // rdx
  __int64 v93; // rax
  unsigned __int64 v94; // r8
  __int64 v95; // r8
  unsigned __int64 v96; // rdi
  _QWORD *v97; // rsi
  unsigned __int64 v98; // rbx
  unsigned __int64 v99; // rcx
  _QWORD *v100; // rdi
  __int64 v101; // rdi
  __int64 v102; // rcx
  _QWORD *v103; // r10
  _QWORD *v104; // rcx
  _QWORD *v105; // r12
  __int64 v106; // r10
  int v107; // ecx
  __int64 v108; // rcx
  __int64 v109; // rcx
  unsigned __int64 v110; // rcx
  int v111; // edi
  char *v112; // rdx
  char *v113; // rcx
  unsigned __int64 v114; // rsi
  unsigned int v115; // edx
  int v116; // esi
  __int64 v117; // rsi
  unsigned __int64 v118; // rcx
  unsigned __int64 v119; // rdx
  __int64 v120; // rdx
  __int64 v121; // rdx
  unsigned __int64 v123; // r13
  __int64 v124; // r9
  __int64 v125; // r10
  _QWORD *v126; // r11
  _DWORD *v127; // rdi
  __int64 *v128; // rsi
  __int64 j; // rcx
  _QWORD *v130; // rax
  unsigned __int64 v131; // rsi
  unsigned __int64 v132; // rcx
  char *v133; // rax
  char *v134; // rdx
  unsigned __int64 v135; // rdx
  unsigned int v136; // eax
  int v137; // edx
  char v138; // cl
  __int64 v139; // rdx
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // rax

  if ( a1 <= 0xE0 )
  {
    v1 = 32LL;
    if ( a1 > 0xE )
      v1 = (a1 + 31) & 0xFFFFFFFFFFFFFFF0LL;
    v2 = dword_4520E0;
    v3 = v1 >> 3;
    v4 = (unsigned int)dword_4520E0 >> (v1 >> 3);
    if ( (v4 & 3) != 0 )
    {
      v5 = ((v4 & 1) == 0) + (_DWORD)v3;
      v6 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v5);
      *(_QWORD *)&v7 = *((_QWORD *)v6 + 2);
      v8 = *(_QWORD *)(v7 + 16);
      if ( v6 == (char *)v8 )
      {
        dword_4520E0 &= ~(1 << v5);
      }
      else
      {
        *(_QWORD *)(v8 + 24) = v6;
        *((_QWORD *)v6 + 2) = v8;
      }
      *(_QWORD *)(v7 + 8) = (8 * v5) | 3u;
      *(_QWORD *)(v7 + (unsigned int)(8 * v5) + 8) |= 1uLL;
      return v7 + 16;
    }
    v9 = qword_4520E8[0];
    if ( qword_4520E8[0] < v1 )
    {
      if ( v4 )
      {
        v10 = ((2 * (1 << v3)) | (-2 * (1 << v3))) & (v4 << v3);
        _BitScanForward((unsigned int *)&v3, -v10 & v10);
        v12 = (unsigned int)(8 * v11);
        v13 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v11);
        *(_QWORD *)&v7 = *((_QWORD *)v13 + 2);
        v14 = *(_QWORD *)(v7 + 16);
        if ( v13 == (char *)v14 )
        {
          dword_4520E0 &= ~(1 << v3);
        }
        else
        {
          *(_QWORD *)(v14 + 24) = v13;
          *((_QWORD *)v13 + 2) = v14;
        }
        *((_QWORD *)&v7 + 1) = v7 + v12;
        v15 = v12 - v1;
        if ( v12 - v1 > 0x1F )
        {
          v16 = v1;
          v17 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v16 | 3;
          *(_QWORD *)(v17 + 8) = v15 | 1;
          **((_QWORD **)&v7 + 1) = v15;
          if ( v9 )
          {
            v18 = qword_452100;
            v19 = 1 << (v9 >> 3);
            v20 = (char *)&unk_452128 + 16 * (unsigned int)(v9 >> 3);
            if ( (v19 & dword_4520E0) != 0 )
            {
              v21 = (char *)*((_QWORD *)v20 + 2);
            }
            else
            {
              v21 = (char *)&unk_452128 + 16 * (unsigned int)(v9 >> 3);
              dword_4520E0 |= v19;
            }
            *((_QWORD *)v20 + 2) = qword_452100;
            *((_QWORD *)v21 + 3) = v18;
            *(_QWORD *)(v18 + 16) = v21;
            *(_QWORD *)(v18 + 24) = v20;
          }
          qword_4520E8[0] = v15;
          qword_452100 = v17;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = (8 * (_DWORD)v3) | 3u;
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) |= 1uLL;
        }
        return v7 + 16;
      }
      v22 = dword_4520E4;
      if ( dword_4520E4 )
      {
        _BitScanForward(&v23, dword_4520E4 & -dword_4520E4);
        *(_QWORD *)&v7 = qword_452338[v23];
        v24 = v7;
        v25 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        while ( 1 )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
          {
            *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 40);
            if ( !*((_QWORD *)&v7 + 1) )
              break;
          }
          if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v25 )
          {
            v25 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
            *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
          }
          v24 = *((_QWORD *)&v7 + 1);
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
        v26 = *(_QWORD *)(v7 + 48);
        v27 = v1 + v25;
        if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
        {
          v28 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v28 + 24) = *((_QWORD *)&v7 + 1);
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v28;
          goto LABEL_38;
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
        v29 = v7 + 40;
        if ( !*((_QWORD *)&v7 + 1) )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
            goto LABEL_38;
          v29 = v7 + 32;
        }
        v30 = *((_QWORD *)&v7 + 1);
        do
        {
          do
          {
            v31 = (_QWORD *)v29;
            *((_QWORD *)&v7 + 1) = v30;
            v29 = v30 + 40;
            v30 = *(_QWORD *)(v30 + 40);
          }
          while ( v30 );
          v30 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
          v29 = *((_QWORD *)&v7 + 1) + 32LL;
        }
        while ( v30 );
        *v31 = 0LL;
LABEL_38:
        if ( v26 )
        {
          v32 = *(unsigned int *)(v7 + 56);
          if ( qword_452338[v32] == (_QWORD)v7 )
          {
            qword_4520E8[v32 + 74] = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
            {
LABEL_41:
              v33 = *(_QWORD *)(v7 + 32);
              *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v26;
              if ( v33 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v33;
                *(_QWORD *)(v33 + 48) = *((_QWORD *)&v7 + 1);
              }
              v34 = *(_QWORD *)(v7 + 40);
              if ( v34 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v34;
                *(_QWORD *)(v34 + 48) = *((_QWORD *)&v7 + 1);
              }
              goto LABEL_51;
            }
            dword_4520E4 = v22 & ~(1 << v32);
          }
          else
          {
            if ( *(_QWORD *)(v26 + 32) == (_QWORD)v7 )
              *(_QWORD *)(v26 + 32) = *((_QWORD *)&v7 + 1);
            else
              *(_QWORD *)(v26 + 40) = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
              goto LABEL_41;
          }
        }
LABEL_51:
        if ( v25 > 0x1F )
        {
          v35 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v1 | 3;
          *(_QWORD *)(v35 + 8) = v25 | 1;
          *(_QWORD *)(v35 + v25) = v25;
          if ( v9 )
          {
            v36 = qword_452100;
            v37 = v9 >> 3;
            v38 = 1 << (v9 >> 3);
            v39 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v37);
            if ( (v38 & v2) != 0 )
            {
              v40 = (char *)*((_QWORD *)v39 + 2);
            }
            else
            {
              v40 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v37);
              dword_4520E0 = v38 | v2;
            }
            *((_QWORD *)v39 + 2) = qword_452100;
            *((_QWORD *)v40 + 3) = v36;
            *(_QWORD *)(v36 + 16) = v40;
            *(_QWORD *)(v36 + 24) = v39;
          }
          qword_4520E8[0] = v25;
          qword_452100 = v7 + v1;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = v27 | 3;
          *(_QWORD *)(v7 + v27 + 8) |= 1uLL;
        }
        return v7 + 16;
      }
    }
    goto LABEL_133;
  }
  if ( a1 > 0xFFFFFFFFFFFFFF7FLL )
  {
    v1 = -1LL;
    goto LABEL_133;
  }
  v41 = a1 + 31;
  v42 = dword_4520E4;
  v1 = v41 & 0xFFFFFFFFFFFFFFF0LL;
  if ( !dword_4520E4 )
    goto LABEL_133;
  v43 = v1 >> 8;
  v44 = -(__int64)v1;
  v45 = v1 >> 8;
  if ( v45 )
  {
    v45 = 31;
    if ( (unsigned int)v43 <= 0xFFFF )
    {
      _BitScanReverse((unsigned int *)&v43, v43);
      v45 = ((v1 >> (38 - ((unsigned __int8)v43 ^ 0x1Fu))) & 1) + 2 * (31 - (v43 ^ 0x1F));
    }
  }
  v7 = (unsigned __int64)qword_452338[v45];
  if ( (_QWORD)v7 )
  {
    v46 = 0;
    if ( v45 != 31 )
      v46 = 57 - (v45 >> 1);
    v47 = 0LL;
    v48 = 0LL;
    for ( i = v1 << v46; ; i *= 2LL )
    {
      v50 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      if ( v50 < v44 )
      {
        if ( !v50 )
        {
          *((_QWORD *)&v7 + 1) = v7;
          v44 = 0LL;
          goto LABEL_78;
        }
        v44 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        v48 = v7;
      }
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
      *(_QWORD *)&v7 = *(_QWORD *)(v7 + 8 * ((i >> 63) + 4));
      if ( !*((_QWORD *)&v7 + 1) || *((_QWORD *)&v7 + 1) == (_QWORD)v7 )
        *((_QWORD *)&v7 + 1) = v47;
      if ( !(_QWORD)v7 )
        break;
      v47 = *((_QWORD *)&v7 + 1);
    }
    *(_QWORD *)&v7 = v48;
  }
LABEL_78:
  if ( v7 == 0 )
  {
    if ( (dword_4520E4 & (-2 << v45)) == 0 )
      goto LABEL_133;
    _BitScanForward(&v51, dword_4520E4 & (-2 << v45) & -(dword_4520E4 & (-2 << v45)));
    *((_QWORD *)&v7 + 1) = qword_452338[v51];
    *(_QWORD *)&v7 = 0LL;
  }
  while ( *((_QWORD *)&v7 + 1) )
  {
    if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v44 )
    {
      v44 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
    }
    v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
    if ( !v52 )
      v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL);
    *((_QWORD *)&v7 + 1) = v52;
  }
  if ( (_QWORD)v7 && v44 < qword_4520E8[0] - v1 )
  {
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
    v53 = *(_QWORD *)(v7 + 48);
    v54 = v1 + v44;
    if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
    {
      v55 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v55 + 24) = *((_QWORD *)&v7 + 1);
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v55;
      goto LABEL_98;
    }
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
    v56 = v7 + 40;
    if ( !*((_QWORD *)&v7 + 1) )
    {
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_98;
      v56 = v7 + 32;
    }
    v57 = *((_QWORD *)&v7 + 1);
    do
    {
      do
      {
        v58 = (_QWORD *)v56;
        *((_QWORD *)&v7 + 1) = v57;
        v56 = v57 + 40;
        v57 = *(_QWORD *)(v57 + 40);
      }
      while ( v57 );
      v57 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
      v56 = *((_QWORD *)&v7 + 1) + 32LL;
    }
    while ( v57 );
    *v58 = 0LL;
LABEL_98:
    if ( !v53 )
      goto LABEL_111;
    v59 = *(unsigned int *)(v7 + 56);
    if ( qword_452338[v59] == (_QWORD)v7 )
    {
      qword_4520E8[v59 + 74] = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
      {
        dword_4520E4 = v42 & ~(1 << v59);
        goto LABEL_111;
      }
    }
    else
    {
      if ( *(_QWORD *)(v53 + 32) == (_QWORD)v7 )
        *(_QWORD *)(v53 + 32) = *((_QWORD *)&v7 + 1);
      else
        *(_QWORD *)(v53 + 40) = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_111;
    }
    v60 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v53;
    if ( v60 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v60;
      *(_QWORD *)(v60 + 48) = *((_QWORD *)&v7 + 1);
    }
    v61 = *(_QWORD *)(v7 + 40);
    if ( v61 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v61;
      *(_QWORD *)(v61 + 48) = *((_QWORD *)&v7 + 1);
    }
LABEL_111:
    if ( v44 > 0x1F )
    {
      v62 = v7 + v1;
      v63 = v44 >> 3;
      *(_QWORD *)(v7 + 8) = v1 | 3;
      *(_QWORD *)(v62 + 8) = v44 | 1;
      *(_QWORD *)(v62 + v44) = v44;
      if ( v44 > 0xFF )
      {
        v67 = v44 >> 8;
        v68 = v44 >> 8;
        if ( v68 )
        {
          v68 = 31;
          if ( (unsigned int)v67 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v67, v67);
            v68 = ((v44 >> (38 - ((unsigned __int8)v67 ^ 0x1Fu))) & 1) + 2 * (31 - (v67 ^ 0x1F));
          }
        }
        v69 = dword_4520E4;
        *(_DWORD *)(v62 + 56) = v68;
        *(_QWORD *)(v62 + 40) = 0LL;
        *(_QWORD *)(v62 + 32) = 0LL;
        if ( ((1 << v68) & v69) != 0 )
        {
          v70 = 0;
          v71 = qword_452338[v68];
          if ( v68 != 31 )
            v70 = 57 - (v68 >> 1);
          v72 = v44 << v70;
          while ( v44 != (*(_QWORD *)(v71 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v73 = v72;
            v72 *= 2LL;
            v74 = (v73 >> 63) + 4;
            if ( !*(_QWORD *)(v71 + 8 * v74) )
            {
              *(_QWORD *)(v71 + 8 * v74) = v62;
              *(_QWORD *)(v62 + 48) = v71;
              goto LABEL_130;
            }
            v71 = *(_QWORD *)(v71 + 8 * v74);
          }
          v75 = *(_QWORD *)(v71 + 16);
          *(_QWORD *)(v75 + 24) = v62;
          *(_QWORD *)(v71 + 16) = v62;
          *(_QWORD *)(v62 + 16) = v75;
          *(_QWORD *)(v62 + 24) = v71;
          *(_QWORD *)(v62 + 48) = 0LL;
        }
        else
        {
          qword_452338[v68] = v62;
          dword_4520E4 = (1 << v68) | v69;
          *(_QWORD *)(v62 + 48) = &qword_452338[v68];
LABEL_130:
          *(_QWORD *)(v62 + 24) = v62;
          *(_QWORD *)(v62 + 16) = v62;
        }
      }
      else
      {
        v64 = 1 << v63;
        v65 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v63);
        if ( ((1 << v63) & dword_4520E0) != 0 )
        {
          v66 = (char *)*((_QWORD *)v65 + 2);
        }
        else
        {
          v66 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v63);
          dword_4520E0 |= v64;
        }
        *((_QWORD *)v65 + 2) = v62;
        *((_QWORD *)v66 + 3) = v62;
        *(_QWORD *)(v62 + 16) = v66;
        *(_QWORD *)(v62 + 24) = v65;
      }
    }
    else
    {
      *(_QWORD *)(v7 + 8) = v54 | 3;
      *(_QWORD *)(v7 + v54 + 8) |= 1uLL;
    }
    return v7 + 16;
  }
LABEL_133:
  if ( qword_4520E8[0] >= v1 )
  {
    *(_QWORD *)&v7 = qword_452100;
    v76 = qword_4520E8[0] - v1;
    v77 = (unsigned __int64 *)(qword_452100 + qword_4520E8[0]);
    if ( qword_4520E8[0] - v1 <= 0x1F )
    {
      *((_QWORD *)&v7 + 1) = qword_4520E8[0] | 3;
      qword_4520E8[0] = 0LL;
      qword_452100 = 0LL;
      *(_QWORD *)(v7 + 8) = *((_QWORD *)&v7 + 1);
      v77[1] |= 1uLL;
      return v7 + 16;
    }
    qword_4520E8[0] -= v1;
    qword_452100 += v1;
    *(_QWORD *)(qword_452100 + 8) = v76 | 1;
    *v77 = v76;
LABEL_262:
    *(_QWORD *)(v7 + 8) = v1 | 3;
    return v7 + 16;
  }
  if ( qword_4520F0 > v1 )
  {
    *((_QWORD *)&v7 + 1) = qword_4520F0 - v1;
LABEL_261:
    *(_QWORD *)&v7 = qword_452108;
    qword_4520F0 = *((_QWORD *)&v7 + 1);
    qword_452108 += v1;
    *(_QWORD *)(qword_452108 + 8) = *((_QWORD *)&v7 + 1) | 1LL;
    goto LABEL_262;
  }
  v78 = -qword_4524B0;
  if ( (dword_452450 & 1) != 0 && v1 >= qword_4524B8 )
  {
    if ( qword_4520F0 )
    {
      v79 = v78 & (v1 + qword_4524B0 + 62);
      if ( (!qword_452448 || qword_452438 < qword_452438 + v79 && qword_452448 >= qword_452438 + v79) && v1 < v79 )
      {
        *(_QWORD *)&v7 = sub_437240(v78 & (v1 + qword_4524B0 + 62));
        *(_QWORD *)v7 = 0LL;
        *(_QWORD *)(v7 + 8) = v79 - 32;
        *((_QWORD *)&v7 + 1) = qword_4520F8;
        *(_QWORD *)(v7 + v79 - 24) = 11LL;
        *(_QWORD *)(v7 + v79 - 16) = 0LL;
        if ( !*((_QWORD *)&v7 + 1) || (unsigned __int64)v7 < *((_QWORD *)&v7 + 1) )
          qword_4520F8 = v7;
        v80 = qword_452438 + v79;
        qword_452438 = v80;
        if ( v80 > qword_452440 )
          qword_452440 = v80;
        return v7 + 16;
      }
    }
  }
  v81 = v78 & (v1 + qword_4524B0 + 95);
  if ( v1 < v81 && (!qword_452448 || qword_452438 < v81 + qword_452438 && qword_452448 >= v81 + qword_452438) )
  {
    v82 = sub_437240(v81);
    v83 = v81 + qword_452438;
    qword_452438 += v81;
    if ( qword_452438 > (unsigned __int64)qword_452440 )
      qword_452440 = v83;
    v84 = qword_452108;
    if ( !qword_452108 )
    {
      if ( !qword_4520F8 || v82 < qword_4520F8 )
        qword_4520F8 = v82;
      qword_452458 = v82;
      qword_452460 = v81;
      dword_452470 = 1;
      qword_452118 = 128LL;
      qword_452120 = qword_4524A0;
      v85 = &unk_452128;
      do
      {
        v85[3] = v85;
        v85[2] = v85;
        v85 += 2;
      }
      while ( &unk_452328 != (_UNKNOWN *)v85 );
      v86 = v81 - 80;
      v87 = v82;
      goto LABEL_170;
    }
    v88 = qword_452458;
    if ( v82 == qword_452458 + qword_452460
      && (dword_452470 & 8) == 0
      && (dword_452470 & 1) != 0
      && qword_452108 >= (unsigned __int64)qword_452458
      && v82 > qword_452108 )
    {
      v87 = qword_452108;
      qword_452460 += v81;
      v86 = v81 + qword_4520F0;
LABEL_170:
      sub_434FD0(&dword_4520E0, v87, v86);
LABEL_259:
      if ( v1 < qword_4520F0 )
      {
        *((_QWORD *)&v7 + 1) = qword_4520F0 - v1;
        goto LABEL_261;
      }
      sub_40213C();
      return 0LL;
    }
    if ( v82 < qword_4520F8 )
      qword_4520F8 = v82;
    v89 = &qword_452458;
    if ( qword_452458 != v82 + v81 || (v90 = dword_452470 & 8, (dword_452470 & 8) != 0) || (dword_452470 & 1) == 0 )
    {
      while ( 1 )
      {
        if ( qword_452108 >= (unsigned __int64)*v89 )
        {
          v123 = v89[1] + *v89;
          if ( qword_452108 < v123 )
            break;
        }
        v89 = (__int64 *)v89[2];
        if ( !v89 )
          BUG();
      }
      sub_434FD0(&dword_4520E0, v82, v81 - 80);
      v126[1] = 51LL;
      v127 = v126 + 2;
      v128 = &qword_452458;
      for ( j = 8LL; j; --j )
      {
        *v127 = *(_DWORD *)v128;
        v128 = (__int64 *)((char *)v128 + 4);
        ++v127;
      }
      qword_452468 = (__int64)(v126 + 2);
      v130 = v126 + 7;
      qword_452458 = v124;
      qword_452460 = v81;
      dword_452470 = 1;
      do
        *v130++ = 11LL;
      while ( v123 > (unsigned __int64)v130 );
      if ( (_QWORD *)v125 != v126 )
      {
        v126[1] &= ~1uLL;
        v131 = (unsigned __int64)v126 - v125;
        v132 = ((unsigned __int64)v126 - v125) >> 3;
        *(_QWORD *)(v125 + 8) = ((unsigned __int64)v126 - v125) | 1;
        *v126 = (char *)v126 - v125;
        if ( (unsigned __int64)v126 - v125 > 0xFF )
        {
          v135 = v131 >> 8;
          v136 = v131 >> 8;
          if ( v136 )
          {
            v136 = 31;
            if ( (unsigned int)v135 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v135, v135);
              v136 = ((v131 >> (38 - ((unsigned __int8)v135 ^ 0x1Fu))) & 1) + 2 * (31 - (v135 ^ 0x1F));
            }
          }
          v137 = dword_4520E4;
          *(_DWORD *)(v125 + 56) = v136;
          *(_QWORD *)(v125 + 40) = 0LL;
          *(_QWORD *)(v125 + 32) = 0LL;
          if ( ((1 << v136) & v137) != 0 )
          {
            v138 = 0;
            v139 = qword_452338[v136];
            if ( v136 != 31 )
              v138 = 57 - (v136 >> 1);
            v140 = v131 << v138;
            while ( v131 != (*(_QWORD *)(v139 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
            {
              v141 = v140;
              v140 *= 2LL;
              v142 = (v141 >> 63) + 4;
              if ( !*(_QWORD *)(v139 + 8 * v142) )
              {
                *(_QWORD *)(v139 + 8 * v142) = v125;
                *(_QWORD *)(v125 + 48) = v139;
                goto LABEL_257;
              }
              v139 = *(_QWORD *)(v139 + 8 * v142);
            }
            v143 = *(_QWORD *)(v139 + 16);
            *(_QWORD *)(v143 + 24) = v125;
            *(_QWORD *)(v139 + 16) = v125;
            *(_QWORD *)(v125 + 16) = v143;
            *(_QWORD *)(v125 + 24) = v139;
            *(_QWORD *)(v125 + 48) = 0LL;
          }
          else
          {
            qword_452338[v136] = v125;
            dword_4520E4 = (1 << v136) | v137;
            *(_QWORD *)(v125 + 48) = &qword_452338[v136];
LABEL_257:
            *(_QWORD *)(v125 + 24) = v125;
            *(_QWORD *)(v125 + 16) = v125;
          }
        }
        else
        {
          v133 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v132);
          if ( ((1 << v132) & dword_4520E0) != 0 )
          {
            v134 = (char *)*((_QWORD *)v133 + 2);
          }
          else
          {
            dword_4520E0 |= 1 << v132;
            v134 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v132);
          }
          *((_QWORD *)v133 + 2) = v125;
          *((_QWORD *)v134 + 3) = v125;
          *(_QWORD *)(v125 + 16) = v134;
          *(_QWORD *)(v125 + 24) = v133;
        }
      }
      goto LABEL_259;
    }
    qword_452458 = v82;
    v91 = v88 & 0xF;
    qword_452460 += v81;
    if ( (v88 & 0xF) != 0 )
      v91 = -(char)(v88 + 16) & 0xF;
    v92 = v88 + v91;
    v93 = v82 + v1;
    v94 = v92 - v82 - v1;
    *(_QWORD *)(v82 + 8) = v1 | 3;
    if ( v84 == v92 )
    {
      qword_452108 = v82 + v1;
      qword_4520F0 += v94;
      *(_QWORD *)(v93 + 8) = qword_4520F0 | 1;
      return v82 + 16;
    }
    if ( v92 == qword_452100 )
    {
      v95 = qword_4520E8[0] + v94;
      qword_452100 = v82 + v1;
      qword_4520E8[0] = v95;
      *(_QWORD *)(v93 + 8) = v95 | 1;
      *(_QWORD *)(v93 + v95) = v95;
      return v82 + 16;
    }
    v96 = *(_QWORD *)(v92 + 8);
    if ( (v96 & 3) != 1 )
    {
LABEL_210:
      *(_QWORD *)(v92 + 8) &= ~1uLL;
      v110 = v94 >> 3;
      *(_QWORD *)(v93 + 8) = v94 | 1;
      *(_QWORD *)(v93 + v94) = v94;
      if ( v94 > 0xFF )
      {
        v114 = v94 >> 8;
        v115 = v94 >> 8;
        if ( v115 )
        {
          v115 = 31;
          if ( (unsigned int)v114 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v114, v114);
            v115 = ((v94 >> (38 - ((unsigned __int8)v114 ^ 0x1Fu))) & 1) + 2 * (31 - (v114 ^ 0x1F));
          }
        }
        v116 = dword_4520E4;
        *(_DWORD *)(v93 + 56) = v115;
        *(_QWORD *)(v93 + 40) = 0LL;
        *(_QWORD *)(v93 + 32) = 0LL;
        if ( ((1 << v115) & v116) != 0 )
        {
          v117 = qword_452338[v115];
          if ( v115 != 31 )
            v90 = 57 - (v115 >> 1);
          v118 = v94 << v90;
          while ( v94 != (*(_QWORD *)(v117 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v119 = v118;
            v118 *= 2LL;
            v120 = (v119 >> 63) + 4;
            if ( !*(_QWORD *)(v117 + 8 * v120) )
            {
              *(_QWORD *)(v117 + 8 * v120) = v93;
              *(_QWORD *)(v93 + 48) = v117;
              goto LABEL_227;
            }
            v117 = *(_QWORD *)(v117 + 8 * v120);
          }
          v121 = *(_QWORD *)(v117 + 16);
          *(_QWORD *)(v121 + 24) = v93;
          *(_QWORD *)(v117 + 16) = v93;
          *(_QWORD *)(v93 + 16) = v121;
          *(_QWORD *)(v93 + 24) = v117;
          *(_QWORD *)(v93 + 48) = 0LL;
        }
        else
        {
          qword_452338[v115] = v93;
          dword_4520E4 = (1 << v115) | v116;
          *(_QWORD *)(v93 + 48) = &qword_452338[v115];
LABEL_227:
          *(_QWORD *)(v93 + 24) = v93;
          *(_QWORD *)(v93 + 16) = v93;
        }
      }
      else
      {
        v111 = 1 << v110;
        v112 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v110);
        if ( ((1 << v110) & dword_4520E0) != 0 )
        {
          v113 = (char *)*((_QWORD *)v112 + 2);
        }
        else
        {
          v113 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v110);
          dword_4520E0 |= v111;
        }
        *((_QWORD *)v112 + 2) = v93;
        *((_QWORD *)v113 + 3) = v93;
        *(_QWORD *)(v93 + 16) = v113;
        *(_QWORD *)(v93 + 24) = v112;
      }
      return v82 + 16;
    }
    v97 = *(_QWORD **)(v92 + 24);
    v98 = v96 & 0xFFFFFFFFFFFFFFF8LL;
    v99 = v96 >> 3;
    if ( v96 <= 0xFF )
    {
      v100 = *(_QWORD **)(v92 + 16);
      if ( v100 == v97 )
      {
        dword_4520E0 &= __ROL4__(-2, v99);
      }
      else
      {
        v100[3] = v97;
        v97[2] = v100;
      }
      goto LABEL_209;
    }
    v101 = *(_QWORD *)(v92 + 48);
    if ( (_QWORD *)v92 != v97 )
    {
      v102 = *(_QWORD *)(v92 + 16);
      *(_QWORD *)(v102 + 24) = v97;
      v97[2] = v102;
      goto LABEL_196;
    }
    v97 = *(_QWORD **)(v92 + 40);
    v103 = (_QWORD *)(v92 + 40);
    if ( !v97 )
    {
      v97 = *(_QWORD **)(v92 + 32);
      if ( !v97 )
        goto LABEL_196;
      v103 = (_QWORD *)(v92 + 32);
    }
    v104 = v97;
    do
    {
      do
      {
        v105 = v103;
        v97 = v104;
        v103 = v104 + 5;
        v104 = (_QWORD *)v104[5];
      }
      while ( v104 );
      v104 = (_QWORD *)v97[4];
      v103 = v97 + 4;
    }
    while ( v104 );
    *v105 = 0LL;
LABEL_196:
    if ( v101 )
    {
      v106 = *(unsigned int *)(v92 + 56);
      v107 = *(_DWORD *)(v92 + 56);
      if ( v92 != qword_452338[v106] )
      {
        if ( v92 == *(_QWORD *)(v101 + 32) )
          *(_QWORD *)(v101 + 32) = v97;
        else
          *(_QWORD *)(v101 + 40) = v97;
        if ( !v97 )
          goto LABEL_209;
LABEL_199:
        v108 = *(_QWORD *)(v92 + 32);
        v97[6] = v101;
        if ( v108 )
        {
          v97[4] = v108;
          *(_QWORD *)(v108 + 48) = v97;
        }
        v109 = *(_QWORD *)(v92 + 40);
        if ( v109 )
        {
          v97[5] = v109;
          *(_QWORD *)(v109 + 48) = v97;
        }
        goto LABEL_209;
      }
      qword_4520E8[v106 + 74] = (__int64)v97;
      if ( v97 )
        goto LABEL_199;
      dword_4520E4 &= __ROL4__(-2, v107);
    }
LABEL_209:
    v92 += v98;
    v94 += v98;
    goto LABEL_210;
  }
  return 0LL;
}
// 43660B: variable 'v126' is possibly undefined
// 43662E: variable 'v124' is possibly undefined
// 436659: variable 'v125' is possibly undefined
// 4520E0: using guessed type int dword_4520E0;
// 4520E4: using guessed type int dword_4520E4;
// 4520E8: using guessed type __int64 qword_4520E8[];
// 4520F0: using guessed type __int64 qword_4520F0;
// 4520F8: using guessed type __int64 qword_4520F8;
// 452100: using guessed type __int64 qword_452100;
// 452108: using guessed type __int64 qword_452108;
// 452118: using guessed type __int64 qword_452118;
// 452120: using guessed type __int64 qword_452120;
// 452338: using guessed type __int64 qword_452338[32];
// 452438: using guessed type __int64 qword_452438;
// 452440: using guessed type __int64 qword_452440;
// 452448: using guessed type __int64 qword_452448;
// 452450: using guessed type int dword_452450;
// 452458: using guessed type __int64 qword_452458;
// 452460: using guessed type __int64 qword_452460;
// 452468: using guessed type __int64 qword_452468;
// 452470: using guessed type int dword_452470;
// 4524A0: using guessed type __int64 qword_4524A0;
// 4524B0: using guessed type __int64 qword_4524B0;
// 4524B8: using guessed type __int64 qword_4524B8;

//----- (0000000000436810) ----------------------------------------------------
void __fastcall sub_436810(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  __int64 v7; // rbx
  _QWORD *v8; // rdx
  unsigned __int64 v9; // rcx
  _QWORD *v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  _QWORD *v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // r9
  int v17; // ecx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // r8
  __int64 v22; // r10
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // rsi
  __int64 v28; // r8
  __int64 v29; // rcx
  _QWORD *v30; // r9
  _QWORD *v31; // rcx
  _QWORD *v32; // r11
  __int64 v33; // r9
  int v34; // ecx
  __int64 v35; // rcx
  __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  char *v38; // rax
  char *v39; // rdx
  unsigned __int64 v40; // rsi
  unsigned int v41; // edx
  int v42; // esi
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  __int64 v47; // rdx
  __int64 v48; // rax

  if ( !a1 )
    return;
  v2 = a1 - 16;
  v3 = *(_QWORD *)(a1 - 8);
  v4 = v3 & 0xFFFFFFFFFFFFFFF8LL;
  v5 = v2 + (v3 & 0xFFFFFFFFFFFFFFF8LL);
  if ( (v3 & 1) != 0 )
    goto LABEL_35;
  v6 = *(_QWORD *)(a1 - 16);
  v2 -= v6;
  if ( (v3 & 3) == 0 )
  {
    v7 = v4 + v6 + 32;
    if ( !(unsigned int)sub_437254(v2, v7) )
      qword_452438 -= v7;
    return;
  }
  v4 += v6;
  if ( qword_452100 == v2 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    if ( (v20 & 3) == 3 )
    {
      qword_4520E8[0] = v4;
      *(_QWORD *)(v5 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
      *(_QWORD *)(v2 + 8) = v4 | 1;
      *(_QWORD *)v5 = v4;
      return;
    }
    goto LABEL_35;
  }
  v8 = *(_QWORD **)(v2 + 24);
  v9 = v6 >> 3;
  if ( v6 <= 0xFF )
  {
    v10 = *(_QWORD **)(v2 + 16);
    if ( v10 == v8 )
    {
      dword_4520E0 &= __ROL4__(-2, v9);
    }
    else
    {
      v10[3] = v8;
      v8[2] = v10;
    }
    goto LABEL_35;
  }
  v11 = *(_QWORD *)(v2 + 48);
  if ( (_QWORD *)v2 == v8 )
  {
    v8 = *(_QWORD **)(v2 + 40);
    v13 = (_QWORD *)(v2 + 40);
    if ( !v8 )
    {
      v8 = *(_QWORD **)(v2 + 32);
      if ( !v8 )
        goto LABEL_20;
      v13 = (_QWORD *)(v2 + 32);
    }
    v14 = v8;
    do
    {
      do
      {
        v15 = v13;
        v8 = v14;
        v13 = v14 + 5;
        v14 = (_QWORD *)v14[5];
      }
      while ( v14 );
      v14 = (_QWORD *)v8[4];
      v13 = v8 + 4;
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_20;
  }
  v12 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v12 + 24) = v8;
  v8[2] = v12;
LABEL_20:
  if ( !v11 )
    goto LABEL_35;
  v16 = *(unsigned int *)(v2 + 56);
  v17 = *(_DWORD *)(v2 + 56);
  if ( qword_452338[v16] == v2 )
  {
    qword_4520E8[v16 + 74] = (__int64)v8;
    if ( !v8 )
    {
      dword_4520E4 &= __ROL4__(-2, v17);
      goto LABEL_35;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v2 )
      *(_QWORD *)(v11 + 32) = v8;
    else
      *(_QWORD *)(v11 + 40) = v8;
    if ( !v8 )
      goto LABEL_35;
  }
  v18 = *(_QWORD *)(v2 + 32);
  v8[6] = v11;
  if ( v18 )
  {
    v8[4] = v18;
    *(_QWORD *)(v18 + 48) = v8;
  }
  v19 = *(_QWORD *)(v2 + 40);
  if ( v19 )
  {
    v8[5] = v19;
    *(_QWORD *)(v19 + 48) = v8;
  }
LABEL_35:
  v21 = *(_QWORD *)(v5 + 8);
  if ( (v21 & 2) == 0 )
  {
    v22 = qword_452100;
    if ( qword_452108 == v5 )
    {
      v23 = qword_4520F0 + v4;
      qword_452108 = v2;
      qword_4520F0 = v23;
      *(_QWORD *)(v2 + 8) = v23 | 1;
      if ( v2 == v22 )
      {
        qword_452100 = 0LL;
        qword_4520E8[0] = 0LL;
      }
      if ( v23 > qword_452110 )
        sub_4352D4(&dword_4520E0, 0LL);
      return;
    }
    if ( v5 == qword_452100 )
    {
      v24 = qword_4520E8[0] + v4;
      qword_452100 = v2;
      qword_4520E8[0] = v24;
      *(_QWORD *)(v2 + 8) = v24 | 1;
      *(_QWORD *)(v2 + v24) = v24;
      return;
    }
    v25 = v21 & 0xFFFFFFFFFFFFFFF8LL;
    v26 = *(_QWORD **)(v5 + 24);
    v4 += v25;
    if ( v25 <= 0xF8 )
    {
      v27 = *(_QWORD **)(v5 + 16);
      if ( v27 == v26 )
      {
        dword_4520E0 &= __ROL4__(-2, v25 >> 3);
      }
      else
      {
        v27[3] = v26;
        v26[2] = v27;
      }
      goto LABEL_69;
    }
    v28 = *(_QWORD *)(v5 + 48);
    if ( (_QWORD *)v5 != v26 )
    {
      v29 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v29 + 24) = v26;
      v26[2] = v29;
      goto LABEL_56;
    }
    v26 = *(_QWORD **)(v5 + 40);
    v30 = (_QWORD *)(v5 + 40);
    if ( !v26 )
    {
      v26 = *(_QWORD **)(v5 + 32);
      if ( !v26 )
        goto LABEL_56;
      v30 = (_QWORD *)(v5 + 32);
    }
    v31 = v26;
    do
    {
      do
      {
        v32 = v30;
        v26 = v31;
        v30 = v31 + 5;
        v31 = (_QWORD *)v31[5];
      }
      while ( v31 );
      v31 = (_QWORD *)v26[4];
      v30 = v26 + 4;
    }
    while ( v31 );
    *v32 = 0LL;
LABEL_56:
    if ( !v28 )
      goto LABEL_69;
    v33 = *(unsigned int *)(v5 + 56);
    v34 = *(_DWORD *)(v5 + 56);
    if ( qword_452338[v33] == v5 )
    {
      qword_4520E8[v33 + 74] = (__int64)v26;
      if ( !v26 )
      {
        dword_4520E4 &= __ROL4__(-2, v34);
        goto LABEL_69;
      }
    }
    else
    {
      if ( *(_QWORD *)(v28 + 32) == v5 )
        *(_QWORD *)(v28 + 32) = v26;
      else
        *(_QWORD *)(v28 + 40) = v26;
      if ( !v26 )
        goto LABEL_69;
    }
    v35 = *(_QWORD *)(v5 + 32);
    v26[6] = v28;
    if ( v35 )
    {
      v26[4] = v35;
      *(_QWORD *)(v35 + 48) = v26;
    }
    v36 = *(_QWORD *)(v5 + 40);
    if ( v36 )
    {
      v26[5] = v36;
      *(_QWORD *)(v36 + 48) = v26;
    }
LABEL_69:
    *(_QWORD *)(v2 + 8) = v4 | 1;
    *(_QWORD *)(v2 + v4) = v4;
    if ( v2 == v22 )
    {
      qword_4520E8[0] = v4;
      return;
    }
    goto LABEL_72;
  }
  *(_QWORD *)(v5 + 8) = v21 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v2 + 8) = v4 | 1;
  *(_QWORD *)(v2 + v4) = v4;
LABEL_72:
  v37 = v4 >> 3;
  if ( v4 > 0xFF )
  {
    v40 = v4 >> 8;
    v41 = v4 >> 8;
    if ( v41 )
    {
      v41 = 31;
      if ( (unsigned int)v40 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v40, v40);
        v41 = ((v4 >> (38 - ((unsigned __int8)v40 ^ 0x1Fu))) & 1) + 2 * (31 - (v40 ^ 0x1F));
      }
    }
    v42 = dword_4520E4;
    *(_DWORD *)(v2 + 56) = v41;
    *(_QWORD *)(v2 + 40) = 0LL;
    *(_QWORD *)(v2 + 32) = 0LL;
    if ( ((1 << v41) & v42) != 0 )
    {
      v43 = 0;
      v44 = qword_452338[v41];
      if ( v41 != 31 )
        v43 = 57 - (v41 >> 1);
      v45 = v4 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v4 )
      {
        v46 = v45;
        v45 *= 2LL;
        v47 = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * v47) )
        {
          *(_QWORD *)(v44 + 8 * v47) = v2;
          *(_QWORD *)(v2 + 48) = v44;
          goto LABEL_89;
        }
        v44 = *(_QWORD *)(v44 + 8 * v47);
      }
      v48 = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(v48 + 24) = v2;
      *(_QWORD *)(v44 + 16) = v2;
      *(_QWORD *)(v2 + 16) = v48;
      *(_QWORD *)(v2 + 24) = v44;
      *(_QWORD *)(v2 + 48) = 0LL;
    }
    else
    {
      qword_452338[v41] = v2;
      dword_4520E4 = (1 << v41) | v42;
      *(_QWORD *)(v2 + 48) = &qword_452338[v41];
LABEL_89:
      *(_QWORD *)(v2 + 24) = v2;
      *(_QWORD *)(v2 + 16) = v2;
    }
    if ( !--qword_452118 )
      sub_435017((__int64)&dword_4520E0);
  }
  else
  {
    v38 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v37);
    if ( ((1 << v37) & dword_4520E0) != 0 )
    {
      v39 = (char *)*((_QWORD *)v38 + 2);
    }
    else
    {
      dword_4520E0 |= 1 << v37;
      v39 = (char *)&unk_452128 + 8 * (unsigned int)(2 * v37);
    }
    *((_QWORD *)v38 + 2) = v2;
    *((_QWORD *)v39 + 3) = v2;
    *(_QWORD *)(v2 + 16) = v39;
    *(_QWORD *)(v2 + 24) = v38;
  }
}
// 4520E0: using guessed type int dword_4520E0;
// 4520E4: using guessed type int dword_4520E4;
// 4520E8: using guessed type __int64 qword_4520E8[];
// 4520F0: using guessed type __int64 qword_4520F0;
// 452100: using guessed type __int64 qword_452100;
// 452108: using guessed type __int64 qword_452108;
// 452110: using guessed type __int64 qword_452110;
// 452118: using guessed type __int64 qword_452118;
// 452338: using guessed type __int64 qword_452338[32];
// 452438: using guessed type __int64 qword_452438;

//----- (0000000000436D15) ----------------------------------------------------
void __fastcall sub_436D15(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax

  v2 = 0LL;
  if ( a1 )
  {
    v2 = a2 * a1;
    if ( ((a2 | a1) & 0xFFFFFFFFFFFF0000LL) != 0 && a2 != v2 / a1 )
      v2 = -1LL;
  }
  v3 = sub_43588C(v2);
  if ( v3 )
  {
    if ( (*(_BYTE *)(v3 - 8) & 3) != 0 )
      sub_43ABE2(v3, 0LL, v2);
  }
}

//----- (0000000000436D71) ----------------------------------------------------
__int64 *__fastcall sub_436D71(__int64 a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v3; // r13
  __int64 v6; // rsi
  unsigned __int64 v7; // rdx
  __int64 v8; // r14
  __int64 v9; // rbx
  __int64 v10; // r15
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  bool v13; // cf
  unsigned __int64 v14; // rbx
  bool v15; // cc
  char *v16; // r9
  unsigned __int64 v17; // rdx
  char *v18; // r8
  __int64 v19; // rdi
  __int64 v20; // rsi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rsi
  unsigned __int64 *v24; // rax
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // r8
  char *v29; // rax
  unsigned __int64 v30; // r11
  char *v31; // rdx
  __int64 v32; // r10
  __int64 v33; // rdx
  _QWORD *v34; // rcx
  char *v35; // rdx
  _QWORD *v36; // rbx
  __int64 v37; // rcx
  __int64 v38; // rdx
  __int64 v39; // rdx
  __int64 v40; // rdx
  __int64 v41; // rsi
  char *v42; // rax
  __int64 v43; // rdx

  v3 = a2;
  v6 = a2[1];
  v7 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  if ( (v6 & 3) != 0 )
  {
    v16 = (char *)v3 + v7;
    if ( v7 >= a3 )
    {
      v17 = v7 - a3;
      if ( v17 <= 0x1F )
        return v3;
      v18 = (char *)v3 + a3;
      v19 = v6 & 1 | a3 | 2;
      v20 = (__int64)v18;
      v3[1] = v19;
      *((_QWORD *)v18 + 1) = v17 | 3;
      *((_QWORD *)v16 + 1) |= 1uLL;
LABEL_53:
      sub_435410(a1, v20, v17);
      return v3;
    }
    if ( *(char **)(a1 + 40) == v16 )
    {
      v21 = *(_QWORD *)(a1 + 16) + v7;
      if ( v21 > a3 )
      {
        v3[1] = a3 | v6 & 1 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = (v21 - a3) | 1;
        *(_QWORD *)(a1 + 40) = (char *)v3 + a3;
        *(_QWORD *)(a1 + 16) = v21 - a3;
        return v3;
      }
      return 0LL;
    }
    if ( *(char **)(a1 + 32) == v16 )
    {
      v22 = v7 + *(_QWORD *)(a1 + 8);
      if ( v22 < a3 )
        return 0LL;
      v23 = v6 & 1;
      v24 = (unsigned __int64 *)((char *)v3 + v22);
      v25 = v22 - a3;
      if ( v22 - a3 <= 0x1F )
      {
        v3[1] = v23 | v22 | 2;
        v24[1] |= 1uLL;
        *(_QWORD *)(a1 + 8) = 0LL;
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      else
      {
        v3[1] = a3 | v23 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = v25 | 1;
        *v24 = v25;
        v24[1] &= ~1uLL;
        *(_QWORD *)(a1 + 8) = v25;
        *(_QWORD *)(a1 + 32) = (char *)v3 + a3;
      }
      return v3;
    }
    v26 = *((_QWORD *)v16 + 1);
    if ( (v26 & 2) != 0 )
      return 0LL;
    v27 = v26 & 0xFFFFFFFFFFFFFFF8LL;
    v28 = v7 + v27;
    if ( v7 + v27 < a3 )
      return 0LL;
    v29 = (char *)*((_QWORD *)v16 + 3);
    v30 = v28 - a3;
    if ( v27 <= 0xF8 )
    {
      v31 = (char *)*((_QWORD *)v16 + 2);
      if ( v31 == v29 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v27 >> 3);
      }
      else
      {
        *((_QWORD *)v31 + 3) = v29;
        *((_QWORD *)v29 + 2) = v31;
      }
      goto LABEL_50;
    }
    v32 = *((_QWORD *)v16 + 6);
    if ( v16 != v29 )
    {
      v33 = *((_QWORD *)v16 + 2);
      *(_QWORD *)(v33 + 24) = v29;
      *((_QWORD *)v29 + 2) = v33;
      goto LABEL_37;
    }
    v29 = (char *)*((_QWORD *)v16 + 5);
    v34 = v16 + 40;
    if ( !v29 )
    {
      v29 = (char *)*((_QWORD *)v16 + 4);
      if ( !v29 )
        goto LABEL_37;
      v34 = v16 + 32;
    }
    v35 = v29;
    do
    {
      do
      {
        v36 = v34;
        v29 = v35;
        v34 = v35 + 40;
        v35 = (char *)*((_QWORD *)v35 + 5);
      }
      while ( v35 );
      v35 = (char *)*((_QWORD *)v29 + 4);
      v34 = v29 + 32;
    }
    while ( v35 );
    *v36 = 0LL;
LABEL_37:
    if ( v32 )
    {
      v37 = *((unsigned int *)v16 + 14);
      v38 = a1 + 8 * v37;
      if ( *(char **)(v38 + 600) != v16 )
      {
        if ( *(char **)(v32 + 32) == v16 )
          *(_QWORD *)(v32 + 32) = v29;
        else
          *(_QWORD *)(v32 + 40) = v29;
        if ( !v29 )
          goto LABEL_50;
LABEL_40:
        v39 = *((_QWORD *)v16 + 4);
        *((_QWORD *)v29 + 6) = v32;
        if ( v39 )
        {
          *((_QWORD *)v29 + 4) = v39;
          *(_QWORD *)(v39 + 48) = v29;
        }
        v40 = *((_QWORD *)v16 + 5);
        if ( v40 )
        {
          *((_QWORD *)v29 + 5) = v40;
          *(_QWORD *)(v40 + 48) = v29;
        }
        goto LABEL_50;
      }
      *(_QWORD *)(v38 + 600) = v29;
      if ( v29 )
        goto LABEL_40;
      *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v37);
    }
LABEL_50:
    v41 = v6 & 1;
    v42 = (char *)v3 + v28;
    v43 = v41;
    if ( v30 <= 0x1F )
    {
      v3[1] = v28 | v41 | 2;
      *((_QWORD *)v42 + 1) |= 1uLL;
      return v3;
    }
    v20 = (__int64)v3 + a3;
    v3[1] = a3 | v43 | 2;
    *(__int64 *)((char *)v3 + a3 + 8) = v30 | 3;
    *((_QWORD *)v42 + 1) |= 1uLL;
    v17 = v28 - a3;
    goto LABEL_53;
  }
  if ( a3 <= 0xFF )
    return 0LL;
  if ( v7 < a3 + 8 || v7 - a3 > 2 * qword_4524B0 )
  {
    v8 = *v3;
    v9 = -qword_4524B0 & (qword_4524B0 + a3 + 62);
    v10 = v7 + *v3 + 32;
    v11 = sub_4378A4();
    if ( v11 == -1LL )
      return 0LL;
    v3 = (__int64 *)(v11 + v8);
    v12 = v9 - v8;
    v13 = v11 < *(_QWORD *)(a1 + 24);
    v3[1] = v9 - v8 - 32;
    *(__int64 *)((char *)v3 + v12 - 24) = 11LL;
    *(__int64 *)((char *)v3 + v12 - 16) = 0LL;
    if ( v13 )
      *(_QWORD *)(a1 + 24) = v11;
    v14 = *(_QWORD *)(a1 + 856) + v9 - v10;
    v15 = v14 <= *(_QWORD *)(a1 + 864);
    *(_QWORD *)(a1 + 856) = v14;
    if ( !v15 )
      *(_QWORD *)(a1 + 864) = v14;
  }
  return v3;
}
// 4524B0: using guessed type __int64 qword_4524B0;

//----- (0000000000437100) ----------------------------------------------------
__int64 *__fastcall sub_437100(__int64 a1, unsigned __int64 a2)
{
  __int64 *result; // rax
  unsigned __int64 v3; // rdx
  __int64 *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-18h]

  if ( !a1 )
    return (__int64 *)sub_43588C(a2);
  if ( a2 > 0xFFFFFFFFFFFFFF7FLL )
  {
    sub_40213C();
    return 0LL;
  }
  if ( !a2 )
  {
    sub_436810(a1);
    return 0LL;
  }
  v3 = 32LL;
  if ( a2 > 0xE )
    v3 = (a2 + 31) & 0xFFFFFFFFFFFFFFF0LL;
  v4 = sub_436D71((__int64)&dword_4520E0, (__int64 *)(a1 - 16), v3);
  if ( v4 )
    return v4 + 2;
  result = (__int64 *)sub_43588C(a2);
  if ( result )
  {
    v6 = (__int64)result;
    v5 = (*(_QWORD *)(a1 - 8) & 0xFFFFFFFFFFFFFFF8LL) - 16;
    if ( v5 > a2 )
      v5 = a2;
    sub_43AAA0((__int64)result, a1, v5);
    sub_436810(a1);
    return (__int64 *)v6;
  }
  return result;
}
// 4520E0: using guessed type int dword_4520E0;

//----- (00000000004371B9) ----------------------------------------------------
void __fastcall sub_4371B9(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v3; // rdx

  if ( !qword_4524A0 )
  {
    v2 = 0x10000;
    if ( (unsigned int)dword_453CA8 >= 0x10000 )
      v2 = dword_453CA8;
    v3 = v2 - 1LL;
    if ( (v2 & (unsigned int)v3) != 0 )
      sub_401000(a1, a2, v3);
    qword_4524B0 = v2;
    qword_4524A8 = 4096LL;
    qword_4524B8 = 0x40000LL;
    qword_4524C0 = 10485760LL;
    dword_4524C8 = 5;
    dword_452450 = 5;
    qword_4524A0 = qword_44E000 & 0xFFFFFFFFFFFFFFF0LL | 8;
  }
}
// 44E000: using guessed type __int64 qword_44E000;
// 452450: using guessed type int dword_452450;
// 4524A0: using guessed type __int64 qword_4524A0;
// 4524A8: using guessed type __int64 qword_4524A8;
// 4524B0: using guessed type __int64 qword_4524B0;
// 4524B8: using guessed type __int64 qword_4524B8;
// 4524C0: using guessed type __int64 qword_4524C0;
// 4524C8: using guessed type int dword_4524C8;
// 453CA8: using guessed type int dword_453CA8;

//----- (0000000000437240) ----------------------------------------------------
__int64 __fastcall sub_437240(unsigned __int64 a1)
{
  return sub_437606(a1);
}

//----- (0000000000437254) ----------------------------------------------------
__int64 __fastcall sub_437254(__int64 a1, __int64 a2)
{
  return sub_4378AA(a1, a2);
}

//----- (0000000000437268) ----------------------------------------------------
__int64 (*__fastcall sub_437268(__int64 a1))(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))sub_434FBE;
  if ( sub_434FBE )
    return (__int64 (*)(void))sub_434FBE(a1);
  return result;
}
// 434FBE: using guessed type __int64 __fastcall sub_434FBE(_QWORD);

//----- (000000000043727D) ----------------------------------------------------
__int64 __fastcall sub_43727D(__int64 a1)
{
  _DWORD *v1; // rbx
  __int64 v2; // rax
  __int64 result; // rax
  unsigned int v4; // eax
  _QWORD *v5; // rbx

  v1 = (_DWORD *)qword_4524E0;
  if ( !qword_4524E0 )
  {
    qword_4524E0 = (__int64)&unk_4524E8;
    v1 = &unk_4524E8;
  }
  if ( *v1 == -1 )
  {
    if ( !sub_434FB8 )
      return sub_40213C();
    v2 = sub_434FB8(1LL, 784LL, 0LL);
    if ( !v2 )
      return sub_40213C();
    *(_QWORD *)(v2 + 8) = v1;
    qword_4524E0 = v2;
    v1 = (_DWORD *)v2;
  }
  _BitScanReverse(&v4, ~*v1);
  *v1 |= 1 << v4;
  v5 = &v1[6 * v4];
  result = 0LL;
  v5[2] = a1;
  v5[3] = 0LL;
  v5[4] = 0LL;
  return result;
}
// 434FB8: using guessed type __int64 __fastcall sub_434FB8(_QWORD, _QWORD, _QWORD);
// 4524E0: using guessed type __int64 qword_4524E0;

//----- (000000000043731B) ----------------------------------------------------
__int64 __fastcall sub_43731B(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v4; // rdi
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int *v8; // rcx
  void (__fastcall *v9)(_QWORD); // rdx
  __int64 v10; // r13

LABEL_1:
  while ( 1 )
  {
    v4 = (unsigned int *)qword_4524E0;
    if ( !qword_4524E0 )
      return a3;
    while ( 1 )
    {
      v5 = *v4;
      while ( v5 )
      {
        _BitScanForward((unsigned int *)&v6, v5);
        v7 = (unsigned int)~(1 << v6);
        v5 &= v7;
        if ( !a1 || *(_QWORD *)&v4[6 * v6 + 8] == a1 )
        {
          *v4 &= v7;
          v8 = &v4[6 * v6];
          v9 = (void (__fastcall *)(_QWORD))*((_QWORD *)v8 + 2);
          if ( v9 )
          {
            v9(*((_QWORD *)v8 + 3));
            goto LABEL_1;
          }
        }
      }
      v10 = *((_QWORD *)v4 + 1);
      if ( !a1 )
        break;
      if ( !v10 )
        return a3;
      v4 = (unsigned int *)*((_QWORD *)v4 + 1);
    }
    if ( v10 && sub_434FBE )
      sub_434FBE(v4);
    qword_4524E0 = v10;
  }
}
// 434FBE: using guessed type __int64 __fastcall sub_434FBE(_QWORD);
// 4524E0: using guessed type __int64 qword_4524E0;

//----- (00000000004373B0) ----------------------------------------------------
void __fastcall sub_4373B0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r12
  __int64 v5; // rax
  __int64 v6; // r13
  __int64 *v7; // rsi
  __int64 *v8; // rdi
  __int64 v9; // rcx
  _QWORD v10[9]; // [rsp-48h] [rbp-48h] BYREF

  if ( a3 )
  {
    v4 = qword_453CD0;
    v5 = *a1;
    v10[1] = a2;
    v10[2] = a3;
    v6 = qword_453CD0 + 1;
    v10[0] = v5;
    v10[3] = a1[1];
    if ( qword_453CD0 + 1 >= (unsigned __int64)qword_453CD8 )
    {
      v7 = &qword_453CD8;
      v8 = &qword_453CE0;
      if ( !sub_437453(&qword_453CE0, (unsigned __int64 *)&qword_453CD8, 0x20uLL, 1LL) )
        goto LABEL_9;
    }
    v7 = v10;
    v9 = 8LL;
    v8 = (__int64 *)(qword_453CE0 + 32 * v4);
    while ( v9 )
    {
      *(_DWORD *)v8 = *(_DWORD *)v7;
      v7 = (__int64 *)((char *)v7 + 4);
      v8 = (__int64 *)((char *)v8 + 4);
      --v9;
    }
    qword_453CD0 = v6;
    if ( v4 == -1 )
LABEL_9:
      sub_401000((__int64)v8, (__int64)v7, a3);
    a1[1] = (__int64)sub_43AA20;
  }
}
// 43744D: variable 'a3' is possibly undefined
// 453CD0: using guessed type __int64 qword_453CD0;
// 453CD8: using guessed type __int64 qword_453CD8;
// 453CE0: using guessed type __int64 qword_453CE0;

//----- (0000000000437453) ----------------------------------------------------
char __fastcall sub_437453(__int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r14
  __int64 v15; // rax
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // rcx
  __int64 v18; // rax
  unsigned __int64 v20; // [rsp+0h] [rbp-40h]

  v4 = 0LL;
  sub_437599(*a1);
  if ( sub_437599(*a1) )
    v4 = *a1;
  v10 = *a2;
  if ( *a1 )
  {
    v11 = v10 + (v10 >> 1);
  }
  else
  {
    v11 = 4LL;
    v9 = 0x1F % a3;
    if ( 0x1F / a3 >= 4 )
      v11 = 0x1F / a3;
  }
  if ( v10 )
  {
    v12 = v10 * a3;
    if ( ((v10 | a3) & 0xFFFFFFFFFFFF0000LL) != 0 )
    {
      v9 = v12 % v10;
      if ( a3 != v12 / v10 )
        goto LABEL_24;
    }
  }
  else
  {
    v12 = 0LL;
  }
  v13 = v11 + a4 + 1;
  if ( v11 + a4 == -1LL )
  {
    v14 = 0LL;
    goto LABEL_17;
  }
  v14 = v13 * a3;
  if ( ((v13 | a3) & 0xFFFFFFFFFFFF0000LL) != 0 )
  {
    v9 = v14 % v13;
    if ( a3 != v14 / v13 )
    {
LABEL_24:
      sub_40215C();
      return 0;
    }
  }
LABEL_17:
  v20 = v12;
  if ( !sub_434FCA || (v15 = sub_434FCA(v4, (v14 + 31) & 0xFFFFFFFFFFFFFFE0LL, v9)) == 0 )
  {
    sub_40213C();
    return 0;
  }
  v16 = v20;
  if ( !v4 )
  {
    if ( *a1 )
      sub_43AAA0(v15, *a1, v20);
  }
  sub_43ABE2(v15 + v16, 0LL, v14 - v16);
  *a2 = v17;
  *a1 = v18;
  return 1;
}
// 437537: variable 'v9' is possibly undefined
// 437562: variable 'v15' is possibly undefined
// 437562: variable 'v16' is possibly undefined
// 437570: variable 'v17' is possibly undefined
// 437574: variable 'v18' is possibly undefined
// 434FCA: using guessed type __int64 __fastcall sub_434FCA(_QWORD, _QWORD, _QWORD);

//----- (0000000000437599) ----------------------------------------------------
_BOOL8 __fastcall sub_437599(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdx
  _BOOL8 result; // rax
  bool v4; // al

  if ( (unsigned __int64)(a1 - 0x600000000000LL) <= 0xFFFFFFFFFFFLL )
    return 0LL;
  v1 = a1 >> 16;
  v2 = sub_4379ED(a1 >> 16, (__int64)dword_452808, qword_452800[0]);
  result = 0LL;
  if ( v2 )
  {
    v4 = 1;
    if ( LODWORD(qword_452800[v2]) != (_DWORD)v1 )
      return dword_45280C[2 * v2 - 2] == (_DWORD)v1;
    return v4;
  }
  return result;
}
// 452800: using guessed type __int64 qword_452800[];
// 452808: using guessed type int dword_452808[];
// 45280C: using guessed type int dword_45280C[595];

//----- (0000000000437606) ----------------------------------------------------
__int64 __fastcall sub_437606(unsigned __int64 a1)
{
  return sub_43762C(0LL, a1, 3u, dword_44EC50 | qword_44EC48 | 2, -1, 0LL);
}
// 44EC48: using guessed type __int64 qword_44EC48;
// 44EC50: using guessed type int dword_44EC50;

//----- (000000000043762C) ----------------------------------------------------
__int64 __fastcall sub_43762C(__int64 a1, unsigned __int64 a2, unsigned int a3, int a4, int a5, __int64 a6)
{
  __int64 v6; // r15
  __int64 v8; // r12
  unsigned __int64 v9; // rbx
  int v10; // er14
  int v11; // ecx
  __int64 v12; // rax
  int v13; // esi
  __int64 v14; // rdi
  __int64 v15; // r12
  unsigned int v16; // er13
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // rdx
  __int64 v20; // r14
  __int64 v21; // rsi
  __int64 v22; // r13
  unsigned __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // rax

  v6 = a1;
  v8 = a5;
  v9 = a2;
  v10 = dword_44EB70 & 4;
  if ( (dword_44EB70 & 4) == 0 || a5 == -1 )
  {
    v9 = a2 + 0xFFFF;
    LOWORD(v9) = 0;
  }
  v11 = a4 & 0x10;
  if ( (a4 & 0x10) == 0 )
  {
    if ( !a1 )
    {
      v12 = qword_452800[0];
      v6 = 0x200000000000LL;
      if ( qword_452800[0] )
      {
        do
        {
          --v12;
          v13 = dword_45280C[2 * v12];
          v14 = v13 + 1;
          if ( v14 + (v9 >> 16) <= 0x30000000 && v13 > 536870910 )
          {
            v6 = v14 << 16;
            goto LABEL_12;
          }
        }
        while ( v12 );
        v6 = (__int64)(HIDWORD(qword_452800[qword_452800[0]]) + 1) << 16;
      }
    }
LABEL_12:
    LOWORD(v6) = 0;
  }
  if ( qword_452800[0] == 300 )
    return sub_40213C();
  if ( v11 )
    sub_437254(v6, v9);
  else
    sub_4379ED(((v9 + 0xFFFF) >> 16) + (v6 >> 16) - 1, (__int64)dword_452808, qword_452800[0]);
  v16 = a4 | 0x10;
  if ( v10 )
  {
    v18 = -1LL;
    v19 = (unsigned int)sub_43B03A(a3, v16);
    if ( (_DWORD)v8 != -1 )
      v18 = *(_QWORD *)(qword_453AF0 + 24 * v8);
    v20 = sub_402DC1(v18, (__int64)qword_446EC0, v19, HIDWORD(v9));
    if ( v20 )
    {
      v21 = (unsigned int)sub_437B03(a3, v16);
      v15 = sub_402EB9(v20, v21, a6 >> 32, (unsigned int)a6);
      if ( v15 )
        goto LABEL_27;
      sub_402DA8(v20, v21, -1LL);
    }
    v17 = sub_43B0C6();
  }
  else
  {
    v17 = sub_437A0D(v6, v9, a3, v16);
  }
  v15 = v17;
  v20 = -1LL;
LABEL_27:
  if ( v15 != -1 )
  {
    v22 = v15 >> 16;
    v23 = sub_4379ED(v15 >> 16, (__int64)dword_452808, qword_452800[0]);
    if ( qword_452800[0] > v23 )
    {
      sub_43ABC2(&qword_452800[v23 + 2], (_BYTE *)&unk_4527F8 + 8 * v23 + 16, 8 * (qword_452800[0] - v23));
      sub_43ABC2(&byte_453160[v24], &byte_453158[v24], 8 * (qword_452800[0] - v25));
    }
    ++qword_452800[0];
    dword_452808[2 * v23] = v22;
    qword_453168[v23] = v20;
    dword_45280C[2 * v23] = ((v9 + 0xFFFF) >> 16) + v22 - 1;
  }
  return v15;
}
// 43784A: variable 'v24' is possibly undefined
// 437858: variable 'v25' is possibly undefined
// 437872: variable 'v23' is possibly undefined
// 446EC0: using guessed type __int64 qword_446EC0[2];
// 44EB70: using guessed type int dword_44EB70;
// 452800: using guessed type __int64 qword_452800[];
// 452808: using guessed type int dword_452808[];
// 45280C: using guessed type int dword_45280C[595];
// 453158: using guessed type _BYTE byte_453158[8];
// 453160: using guessed type _BYTE byte_453160[8];
// 453168: using guessed type __int64 qword_453168[303];
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (00000000004378A4) ----------------------------------------------------
// attributes: thunk
__int64 sub_4378A4()
{
  return sub_40214C();
}

//----- (00000000004378AA) ----------------------------------------------------
__int64 __fastcall sub_4378AA(__int64 a1, __int64 a2)
{
  int v2; // er12
  unsigned int v3; // er13
  unsigned __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8

  if ( (unsigned __int64)(a1 - 1) <= 0xFFFFFFFFFFFFFFFDLL && a2 )
  {
    v2 = a1 >> 16;
    v3 = 0;
    v4 = sub_4379ED(
           v2 + (unsigned int)((unsigned __int64)(a2 + 0xFFFF) >> 16) - 1,
           (__int64)dword_452808,
           qword_452800[0]);
    v6 = v4;
    while ( v4 )
    {
      v7 = v4 - 1;
      v8 = (unsigned int)dword_45280C[2 * v4 - 2];
      v9 = (unsigned int)dword_452808[2 * v4 - 2];
      if ( v2 > (int)v8 )
        break;
      v10 = (__int64)(int)v9 << 16;
      if ( (dword_44EB70 & 4) != 0 )
      {
        if ( !(unsigned int)sub_402ECF(v10, v8, v9) )
          v3 = -1;
        if ( !(unsigned int)sub_402DA8(qword_453168[v7], v8, v11) )
          v3 = -1;
      }
      else
      {
        v3 |= sub_4383C0(v10, (__int64)((int)v8 - (int)v9 + 1) << 16, v9, v5);
      }
      v4 = v7;
    }
    if ( v4 < v6 )
    {
      if ( qword_452800[0] > v6 )
      {
        sub_43ABC2(&qword_452800[v4 + 1], &qword_452800[v6 + 1], 8 * (qword_452800[0] - v6));
        sub_43ABC2(&byte_453160[v12], &byte_453160[v13], 8 * (qword_452800[0] - v6));
      }
      qword_452800[0] = qword_452800[0] + v4 - v6;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}
// 437933: variable 'v5' is possibly undefined
// 437954: variable 'v11' is possibly undefined
// 4379AE: variable 'v12' is possibly undefined
// 4379B5: variable 'v13' is possibly undefined
// 4379C8: variable 'v4' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 452800: using guessed type __int64 qword_452800[];
// 452808: using guessed type int dword_452808[];
// 45280C: using guessed type int dword_45280C[595];
// 453160: using guessed type _BYTE byte_453160[8];
// 453168: using guessed type __int64 qword_453168[303];

//----- (00000000004379ED) ----------------------------------------------------
__int64 __fastcall sub_4379ED(int a1, __int64 a2, int a3)
{
  __int64 result; // rax
  int v4; // ecx

  LODWORD(result) = 0;
  while ( a3 > (int)result )
  {
    v4 = (a3 + (int)result) >> 1;
    if ( *(_DWORD *)(a2 + 8LL * v4) > a1 )
      a3 = (a3 + (int)result) >> 1;
    else
      LODWORD(result) = v4 + 1;
  }
  return (int)result;
}

//----- (0000000000437A0D) ----------------------------------------------------
__int64 __fastcall sub_437A0D(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_4383B0(a1, a2, a3, a4);
}

//----- (0000000000437A1A) ----------------------------------------------------
__int64 __fastcall sub_437A1A(unsigned int a1)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  unsigned int v3; // eax
  __int64 v4; // rdx
  unsigned int v6; // [rsp-1Ch] [rbp-1Ch]

  if ( a1 == -1 )
    return 0LL;
  if ( sub_437DB6(a1, 5) )
  {
    v3 = sub_434AF5(*(_QWORD *)(qword_453AF0 + 24LL * (int)a1));
  }
  else if ( (dword_44EB70 & 4) != 0 )
  {
    if ( sub_437DB6(a1, 2) )
      v3 = MEMORY[0](a1);
    else
      v3 = sub_402687(a1, 2LL, v4);
  }
  else
  {
    v3 = sub_438380(a1, 5LL, v1, v2);
  }
  v6 = v3;
  sub_437F99(a1);
  return v6;
}
// 437A64: variable 'v1' is possibly undefined
// 437A64: variable 'v2' is possibly undefined
// 437A8B: variable 'v4' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437AA9) ----------------------------------------------------
unsigned __int64 __fastcall sub_437AA9(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // cl
  unsigned __int64 result; // rax

  do
  {
    v3 = 0;
    for ( result = qword_453AE0; qword_453AE8 > result; ++result )
    {
      a3 = result + 1;
      v3 = 1;
      if ( !*(_DWORD *)(qword_453AF0 + 24 * (result + 1) - 8) )
      {
        qword_453AE0 = result + 1;
        return result;
      }
    }
    if ( v3 )
      qword_453AE0 = result;
  }
  while ( (unsigned int)sub_437D47(qword_453AF0, qword_453AE8, a3) != -1 );
  return -1LL;
}
// 437AF4: variable 'a3' is possibly undefined
// 453AE0: using guessed type __int64 qword_453AE0;
// 453AE8: using guessed type __int64 qword_453AE8;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437B03) ----------------------------------------------------
__int64 __fastcall sub_437B03(char a1, int a2)
{
  return (8 * a1) & 0x20 | (4 * a1) & 4 | (32 * a2) & 0x80000000 | (a2 >> 2) & 0x20000000 | a1 & 2 | (a2 >> 1) & 1;
}

//----- (0000000000437B3E) ----------------------------------------------------
__int64 __fastcall sub_437B3E(int a1, int *a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx

  if ( sub_437DB6(a1, 5) )
    return sub_434B23(*(_QWORD *)(qword_453AF0 + 24LL * a1), (__int64)a2, v2, v3);
  if ( (dword_44EB70 & 4) == 0 )
    return sub_401839((unsigned int)a1, a2, v2, v3);
  if ( sub_437DB6(a1, 1) )
    return sub_402713(*(_QWORD *)(qword_453AF0 + 24LL * a1), (__int64)a2);
  return sub_4020AC();
}
// 437B79: variable 'v2' is possibly undefined
// 437B79: variable 'v3' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437BCC) ----------------------------------------------------
__int64 __fastcall sub_437BCC(const char *a1)
{
  __int64 result; // rax
  _QWORD *v2; // r12
  const char *v3; // r14
  unsigned int v4; // er15
  __int64 v5; // rdx
  __int64 v6; // rbx
  int v7; // eax
  __int64 v8; // [rsp-40h] [rbp-40h]

  result = 0LL;
  if ( a1 != (const char *)-1LL )
  {
    if ( (dword_44EB70 & 4) == 0 )
    {
      v2 = (_QWORD *)qword_44E428;
      if ( !qword_44E428 )
        return result;
      if ( (dword_44EB70 & 8) != 0 )
      {
        if ( a1 )
        {
          v3 = "executable_path";
          if ( a1 != (const char *)qword_44EBB0 )
            v3 = a1;
          v4 = sub_43AD53(v3);
          v5 = v4;
          while ( 1 )
          {
            v6 = *v2;
            if ( !*v2 )
              break;
            v8 = v5;
            v7 = sub_43AD1A(*v2, v3);
            v5 = v8;
            if ( !v7 && *(_BYTE *)(v6 + v8) == 61 )
              return v6 + v4 + 1;
            ++v2;
          }
        }
      }
      else
      {
        while ( *v2 )
        {
          if ( (const char *)*v2 == a1 )
          {
            result = v2[1];
            if ( result )
              return result;
            break;
          }
          v2 += 2;
        }
      }
    }
    result = 0LL;
    if ( (const char *)qword_44EBB0 == a1 )
      return qword_44EB58;
  }
  return result;
}
// 43AD1A: using guessed type __int64 __fastcall sub_43AD1A(_QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 44E428: using guessed type __int64 qword_44E428;
// 44EB58: using guessed type __int64 qword_44EB58;
// 44EB70: using guessed type int dword_44EB70;
// 44EBB0: using guessed type __int64 qword_44EBB0;

//----- (0000000000437CA8) ----------------------------------------------------
__int64 __fastcall sub_437CA8(__int64 a1)
{
  __int64 *v1; // rbx
  __int64 v2; // r13
  __int64 v3; // r12
  __int64 v5; // [rsp+8h] [rbp-28h] BYREF

  v1 = (__int64 *)qword_453CC8;
  v5 = 0LL;
  if ( !qword_453CC8 )
    v1 = &v5;
  v2 = sub_43AD53(a1);
  while ( 1 )
  {
    v3 = *v1;
    if ( !*v1 )
      break;
    if ( !(unsigned int)sub_43AD1A(*v1, a1) && *(_BYTE *)(v3 + v2) == 61 )
    {
      v3 += v2 + 1;
      return v3;
    }
    ++v1;
  }
  return v3;
}
// 43AD1A: using guessed type __int64 __fastcall sub_43AD1A(_QWORD, _QWORD);
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);
// 453CC8: using guessed type __int64 qword_453CC8;

//----- (0000000000437D19) ----------------------------------------------------
__int64 __fastcall sub_437D19(int a1)
{
  char v2[48]; // [rsp+0h] [rbp-E0h] BYREF
  __int64 v3; // [rsp+30h] [rbp-B0h]

  if ( (unsigned int)sub_437B3E(a1, (int *)v2) == -1 )
    return -1LL;
  else
    return v3;
}
// 437D19: using guessed type char var_E0[48];

//----- (0000000000437D47) ----------------------------------------------------
__int64 __fastcall sub_437D47(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax
  unsigned __int64 v6; // rdx

  if ( !sub_434FCA )
    return sub_4020FC();
  v3 = qword_453AE8;
  v4 = qword_453AF0;
  if ( (_UNKNOWN *)qword_453AF0 == &unk_453AF8 )
    v4 = 0LL;
  v5 = sub_434FCA(v4, 48 * qword_453AE8, a3);
  if ( !v5 )
    return sub_40213C();
  v6 = 2 * v3;
  do
  {
    ++v3;
    *(_DWORD *)(v5 + 24 * v3 - 8) = 0;
  }
  while ( v6 > v3 );
  qword_453AF0 = v5;
  qword_453AE8 = v6;
  return 0LL;
}
// 434FCA: using guessed type __int64 __fastcall sub_434FCA(_QWORD, _QWORD, _QWORD);
// 453AE8: using guessed type __int64 qword_453AE8;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437DB6) ----------------------------------------------------
bool __fastcall sub_437DB6(int a1, int a2)
{
  bool result; // al

  result = 0;
  if ( a1 )
    return *(_DWORD *)(qword_453AF0 + 24LL * a1 + 16) == a2;
  return result;
}
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437DD1) ----------------------------------------------------
unsigned __int64 __fastcall sub_437DD1(
        _BYTE *a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        char a7)
{
  unsigned __int64 v8; // rax
  unsigned int v9; // [rsp+Ch] [rbp-84h]
  __int64 v10[2]; // [rsp+18h] [rbp-78h] BYREF
  int v11; // [rsp+28h] [rbp-68h]
  char *v12; // [rsp+30h] [rbp-60h]
  char *v13; // [rsp+38h] [rbp-58h]
  char v14; // [rsp+40h] [rbp-50h] BYREF
  __int64 v15; // [rsp+50h] [rbp-40h]

  v12 = &a7;
  v15 = a3;
  v11 = 16;
  a3 = (unsigned int)a3;
  v13 = &v14;
  if ( !a1 )
    return sub_4020BC();
  if ( sub_434C82 )
  {
    v9 = a3;
    v8 = sub_434E00((__int64)a1, v10);
    a3 = v9;
    if ( v8 != -1LL )
      return sub_434C82(v10, a2);
  }
  if ( (dword_44EB70 & 4) != 0 )
    return sub_402993(a1, a2, a3);
  return sub_4383D0((unsigned int)dword_44EBA8, (__int64)a1, a2, (unsigned int)a3);
}
// 44EB70: using guessed type int dword_44EB70;
// 44EBA8: using guessed type int dword_44EBA8;
// 437DD1: using guessed type _QWORD var_78[2];

//----- (0000000000437E75) ----------------------------------------------------
unsigned __int64 __fastcall sub_437E75(int a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  __int64 v6; // [rsp+0h] [rbp-30h] BYREF
  __int64 v7; // [rsp+8h] [rbp-28h]

  if ( a1 == -1 )
    return (int)sub_4020CC();
  if ( sub_437DB6(a1, 5) )
  {
    v6 = a2;
    v7 = a3;
    return sub_434E5B(*(_QWORD **)(qword_453AF0 + 24LL * a1), &v6, 1LL, 0xFFFFFFFFFFFFFFFFLL);
  }
  else if ( (dword_44EB70 & 4) != 0 )
  {
    if ( sub_437DB6(a1, 1) || sub_437DB6(a1, 4) )
    {
      v6 = a2;
      v7 = a3;
      return sub_402B09((_QWORD *)(qword_453AF0 + 24LL * a1), &v6, 1LL, -1LL);
    }
    else if ( sub_437DB6(a1, 2) )
    {
      v6 = a2;
      v7 = a3;
      return MEMORY[0](qword_453AF0 + 24LL * a1, &v6, 1LL, 0LL, 0LL, 0LL);
    }
    else
    {
      return sub_4020AC();
    }
  }
  else
  {
    return sub_4383E0((unsigned int)a1, a2, a3, v5);
  }
}
// 437EF1: variable 'v5' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437F99) ----------------------------------------------------
void __fastcall sub_437F99(__int64 a1)
{
  __int64 v1; // rax

  if ( (_DWORD)a1 )
  {
    a1 = (int)a1;
    v1 = qword_453AF0 + 24LL * (int)a1;
    if ( qword_453AE0 <= (unsigned __int64)(int)a1 )
      a1 = qword_453AE0;
    *(_DWORD *)(v1 + 16) = 0;
    qword_453AE0 = a1;
  }
}
// 453AE0: using guessed type __int64 qword_453AE0;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000437FC9) ----------------------------------------------------
__int64 __fastcall sub_437FC9(__int64 a1, __int64 a2, __int64 a3)
{
  if ( (dword_44EB70 & 4) != 0 )
    return sub_40214C();
  else
    return qword_44EB78(a1, a2, a3, 8LL);
}
// 44EB70: using guessed type int dword_44EB70;
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000437FE2) ----------------------------------------------------
__int64 __fastcall sub_437FE2(int a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  __int64 v6; // [rsp+0h] [rbp-30h] BYREF
  __int64 v7; // [rsp+8h] [rbp-28h]

  if ( a1 == -1 )
    return (int)sub_4020CC();
  if ( sub_437DB6(a1, 5) )
  {
    v6 = a2;
    v7 = a3;
    return MEMORY[0](*(_QWORD *)(qword_453AF0 + 24LL * a1), &v6, 1LL, -1LL);
  }
  else if ( (dword_44EB70 & 4) != 0 )
  {
    if ( sub_437DB6(a1, 2) )
    {
      v6 = a2;
      v7 = a3;
      return MEMORY[0](qword_453AF0 + 24LL * a1, &v6, 1LL, 0LL, 0LL, 0LL);
    }
    else if ( sub_437DB6(a1, 1) || sub_437DB6(a1, 4) )
    {
      v6 = a2;
      v7 = a3;
      return sub_402B93((_QWORD *)(qword_453AF0 + 24LL * a1), &v6, 1LL, -1LL);
    }
    else
    {
      return sub_4020AC();
    }
  }
  else
  {
    return sub_438400((unsigned int)a1, a2, a3, v5);
  }
}
// 43805E: variable 'v5' is possibly undefined
// 44EB70: using guessed type int dword_44EB70;
// 453AF0: using guessed type __int64 qword_453AF0;

//----- (0000000000438106) ----------------------------------------------------
unsigned __int64 __fastcall sub_438106(__int64 a1)
{
  return (a1 - 0x2B6109100LL) / 0x989680uLL;
}

//----- (0000000000438122) ----------------------------------------------------
unsigned __int64 __fastcall sub_438122(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 result; // rax

  *a1 = (a2 - 116444736000000000LL) / 0x989680uLL;
  result = (a2 - 116444736000000000LL) % 0x989680uLL / 0xA;
  a1[1] = result;
  return result;
}

//----- (000000000043814E) ----------------------------------------------------
__int64 __fastcall sub_43814E(char *a1, char **a2, int a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 result; // rax

  v3 = sub_438178(a1, a2, a3);
  if ( v4 < 0 )
    return 0LL;
  v5 = v3;
  result = -1LL;
  if ( v4 <= 0 )
    return v5;
  return result;
}
// 43815A: variable 'v4' is possibly undefined

//----- (0000000000438178) ----------------------------------------------------
__int64 __fastcall sub_438178(char *a1, char **a2, int a3)
{
  __int64 v6; // rdx
  char v7; // cl
  char v8; // al
  char v9; // al
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // r13
  __int64 i; // r11
  unsigned int v13; // eax
  unsigned int v14; // er9
  unsigned int v15; // edx
  int v16; // eax
  unsigned int v17; // edx
  char v18; // di
  char v19; // si
  __int128 v20; // rax
  __int64 v21; // rcx
  __int64 v23; // [rsp+10h] [rbp-50h]
  char **v24; // [rsp+18h] [rbp-48h]
  int v25; // [rsp+20h] [rbp-40h]
  char v26; // [rsp+27h] [rbp-39h]
  unsigned int v27; // [rsp+28h] [rbp-38h]
  unsigned int v28; // [rsp+2Ch] [rbp-34h]

  while ( 1 )
  {
    v6 = (unsigned __int8)*a1;
    if ( (byte_44E530[v6] & 1) == 0 )
      break;
    ++a1;
  }
  v7 = 0;
  if ( (_BYTE)v6 == 43 )
    goto LABEL_6;
  if ( (_BYTE)v6 == 45 )
  {
    v7 = 1;
LABEL_6:
    ++a1;
  }
  v8 = *a1;
  if ( (unsigned int)(a3 - 2) <= 0x22 )
  {
    if ( v8 == 48 )
      ++a1;
  }
  else
  {
    a3 = 10;
    if ( v8 == 48 )
    {
      v9 = a1[1] & 0xDF;
      if ( v9 == 88 )
      {
        a1 += 2;
        a3 = 16;
      }
      else if ( v9 == 66 )
      {
        a1 += 2;
        a3 = 2;
      }
      else
      {
        ++a1;
        a3 = 8;
      }
    }
  }
  v10 = 0LL;
  v11 = 0LL;
  for ( i = a3; ; v10 = i * v10 + v14 )
  {
    v13 = (unsigned __int8)byte_44E430[(unsigned __int8)*a1];
    if ( !byte_44E430[(unsigned __int8)*a1] || a3 < v13 )
      break;
    v14 = v13 - 1;
    if ( v13 != 1 )
    {
      if ( v11 | v10 )
      {
        _BitScanReverse(&v15, v14);
        v23 = i;
        v25 = a3;
        v24 = a2;
        v26 = v7;
        v27 = v13 - 1;
        v28 = v15 ^ 0x1F;
        v16 = sub_43A8A2(v10, v11);
        v14 = v27;
        v7 = v26;
        a2 = v24;
        a3 = v25;
        i = v23;
        v17 = v16 + (v28 ^ 0x1F);
        if ( v17 > 0x7E )
        {
          if ( v26 )
          {
            if ( v17 == 127
              && (v11 = (v27 + v25 * __PAIR128__(v11, v10)) >> 64,
                  v10 = v27 + v25 * v10,
                  __PAIR128__(v11, v10) == __PAIR128__(0x8000000000000000LL, 0LL)) )
            {
              ++a1;
            }
            else
            {
              v10 = 0LL;
              v11 = 0x8000000000000000LL;
            }
          }
          else
          {
            v10 = -1LL;
            v11 = 0x7FFFFFFFFFFFFFFFLL;
          }
          break;
        }
      }
    }
    ++a1;
    v11 = (i * __PAIR128__(v11, v10) + v14) >> 64;
  }
  v18 = *a1 & 0xDF;
  if ( v18 == 85 )
    ++a1;
  v19 = *a1 & 0xDF;
  if ( v19 == 76 )
    ++a1;
  if ( a2 )
    *a2 = a1;
  *(_QWORD *)&v20 = v10;
  *((_QWORD *)&v20 + 1) = v11;
  if ( v7 )
    v20 = -v20;
  if ( v18 == 85 )
  {
    v21 = v20;
    if ( v19 != 76 )
      v21 = (unsigned int)v20;
    *(_QWORD *)&v20 = v21;
  }
  return v20;
}

//----- (0000000000438380) ----------------------------------------------------
__int64 __fastcall sub_438380(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000438390) ----------------------------------------------------
__int64 __fastcall sub_438390(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004383A0) ----------------------------------------------------
__int64 __fastcall sub_4383A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004383B0) ----------------------------------------------------
__int64 __fastcall sub_4383B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004383C0) ----------------------------------------------------
__int64 __fastcall sub_4383C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004383D0) ----------------------------------------------------
__int64 __fastcall sub_4383D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004383E0) ----------------------------------------------------
__int64 __fastcall sub_4383E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000438400) ----------------------------------------------------
__int64 __fastcall sub_438400(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_44EB78(a1, a2, a3, a4);
}
// 44EB78: using guessed type __int64 (__fastcall *qword_44EB78)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000438410) ----------------------------------------------------
__int64 __fastcall sub_438410(
        __int64 (__fastcall *a1)(__int64, __int64),
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        char a5,
        long double a6)
{
  long double v19; // fst6
  char v20; // fps^1
  unsigned __int64 v26; // rbx
  __int64 i; // rax
  __int64 v28; // rsi
  unsigned __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rdi
  long double v32; // fst5
  __int64 v33; // rax
  long double v34; // fst4
  bool v36; // cc
  __int64 v40; // r8
  unsigned __int64 v41; // rcx
  __int64 v42; // rt2
  __int64 v43; // r8
  __int64 v44; // rcx
  char v45; // dl
  unsigned __int64 j; // rax
  unsigned int v50; // edx
  __int64 result; // rax
  unsigned int v52; // [rsp+0h] [rbp-80h]
  __int16 v53; // [rsp+Eh] [rbp-72h]
  int v54[28]; // [rsp+10h] [rbp-70h]

  _FST7 = a6;
  v19 = fabs(a6);
  if ( v19 > 9.223372036854775807e18 )
  {
    __asm { ffreep  st }
    goto LABEL_5;
  }
  if ( v19 > 1.189731495357231765e4932 )
  {
    __asm { ffreep  st }
LABEL_5:
    v54[0] = 6909542;
    v26 = 3LL;
    goto LABEL_43;
  }
  if ( (a5 & 0x20) != 0 )
  {
    for ( i = 0LL; ; ++i )
    {
      v28 = (unsigned int)i;
      v29 = a3 - i;
      if ( (unsigned int)i > 0x3F || v29 <= 9 )
        break;
      *((_BYTE *)v54 + i) = 48;
    }
  }
  else
  {
    v28 = 0LL;
    v29 = 6LL;
  }
  v30 = dword_446F20[v29];
  v31 = (__int64)v19;
  v32 = (v19 - (long double)(__int64)v19) * (long double)(int)v30;
  v33 = (__int64)v32;
  v34 = v32 - (long double)(__int64)v32;
  if ( v34 <= 0.5 )
  {
    if ( v34 >= 0.5 && (!v33 || (v33 & 1) != 0) )
      ++v33;
  }
  else
  {
    __asm { ffreep  st }
    if ( v30 <= ++v33 )
    {
      ++v31;
      v33 = 0LL;
    }
  }
  if ( v29 )
  {
    __asm
    {
      ffreep  st
      ffreep  st
    }
    LODWORD(v40) = v29;
    while ( 1 )
    {
      v26 = (unsigned int)v28;
      if ( (unsigned int)v28 > 0x3F )
        break;
      v41 = (unsigned int)(v28 + 1);
      v40 = (unsigned int)(v40 - 1);
      v42 = v33 % 10;
      v33 /= 10LL;
      *((_BYTE *)&v53 + ++v28 + 1) = v42 + 48;
      if ( !v33 )
      {
        v43 = v41 + v40;
        while ( 1 )
        {
          v26 = (unsigned int)v41;
          if ( v41 > 0x3F )
            goto LABEL_33;
          LODWORD(v28) = v41 + 1;
          if ( v41 == v43 )
          {
            *((_BYTE *)v54 + (unsigned int)v41) = 46;
            goto LABEL_30;
          }
          *((_BYTE *)v54 + v41++) = 48;
        }
      }
    }
  }
  else
  {
    v36 = v19 - (long double)v31 >= 0.5;
    __asm { ffreep  st }
    if ( v36 )
      v31 -= ((v31 & 1) == 0) - 1LL;
LABEL_30:
    v44 = (unsigned int)v28;
    do
    {
      v26 = (unsigned int)v44;
      if ( (unsigned int)v44 > 0x3F )
        break;
      v26 = (unsigned int)(v44 + 1);
      v45 = v31 % 10 + 48;
      v31 /= 10LL;
      *((_BYTE *)v54 + v44++) = v45;
    }
    while ( v31 );
  }
LABEL_33:
  if ( (a5 & 3) == 1LL && a4 )
  {
    __asm { fxam }
    if ( (v20 & 2) != 0 || (a5 & 0xC) != 0 )
      --a4;
    for ( j = (unsigned int)v26; ; ++j )
    {
      v26 = (unsigned int)j;
      if ( a4 <= j )
        break;
      if ( j > 0x3F )
      {
        __asm { ffreep  st }
        goto LABEL_52;
      }
      *((_BYTE *)v54 + j) = 48;
    }
  }
  if ( (unsigned int)v26 > 0x3F )
  {
    __asm { ffreep  st }
    goto LABEL_52;
  }
LABEL_43:
  __asm
  {
    fxam
    ffreep  st
  }
  if ( (v20 & 2) != 0 )
  {
    *((_BYTE *)v54 + (unsigned int)v26) = 45;
LABEL_49:
    v26 = (unsigned int)(v26 + 1);
    goto LABEL_52;
  }
  if ( (a5 & 4) != 0 )
  {
    *((_BYTE *)v54 + (unsigned int)v26) = 43;
    goto LABEL_49;
  }
  if ( (a5 & 8) != 0 )
  {
    *((_BYTE *)v54 + (unsigned int)v26) = 32;
    goto LABEL_49;
  }
LABEL_52:
  if ( (a5 & 3) != 0 || (unsigned int)v26 >= a4 || (unsigned int)sub_43907A(a1, a2, (int)a4 - (int)v26) != -1 )
  {
    v50 = v26 - 1;
    while ( 1 )
    {
      v52 = v50;
      if ( (unsigned int)a1((unsigned int)*((char *)v54 + v50), a2) == -1 )
        break;
      v50 = v52 - 1;
      if ( !v52 )
      {
        result = 0LL;
        if ( (a5 & 2) != 0 && v26 < a4 )
          return (unsigned int)-((unsigned int)sub_43907A(a1, a2, (int)a4 - (int)v26) == -1);
        return result;
      }
    }
  }
  return 0xFFFFFFFFLL;
}
// 4385CB: variable 'v20' is possibly undefined
// 446F20: using guessed type int dword_446F20[];

//----- (00000000004386B4) ----------------------------------------------------
__int64 __fastcall sub_4386B4(
        __int64 (__fastcall *a1)(__int64, __int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        unsigned int a6,
        unsigned int a7,
        unsigned __int8 a8,
        __int64 a9)
{
  unsigned __int8 v9; // r9
  char v10; // bl
  unsigned int v11; // eax
  __int64 *v12; // rsi
  __int64 v13; // r14
  __int64 v14; // r12
  __int64 *v15; // rsi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // r10
  __int64 v19; // r11
  char v20; // r14
  unsigned int v21; // er12
  __int128 v22; // rax
  unsigned int v23; // ebx
  int v24; // er11
  unsigned int v25; // er13
  int v26; // er15
  __int128 v27; // rax
  __int128 v28; // rax
  __int64 v29; // rdx
  char v30; // r15
  char v31; // r12
  _BYTE *v32; // rax
  _BYTE *v33; // rax
  unsigned int v34; // eax
  bool v35; // zf
  __int64 v36; // rax
  unsigned int i; // er12
  __int64 v39; // rdi
  __int128 v44; // [rsp+30h] [rbp-E0h]
  int v45[49]; // [rsp+4Ch] [rbp-C4h] BYREF

  v9 = a8;
  if ( (a8 & 0x20) != 0 )
    v9 = a8 & 0xFE;
  v10 = v9 & 0x40;
  if ( (v9 & 0x40) == 0 )
    v9 &= 0xF3u;
  v11 = *(_DWORD *)a3;
  if ( (unsigned __int8)a4 <= 0x3Fu )
  {
    if ( v11 > 0x2F )
    {
      v15 = *(__int64 **)(a3 + 8);
      *(_QWORD *)(a3 + 8) = v15 + 1;
    }
    else
    {
      v15 = (__int64 *)(*(_QWORD *)(a3 + 16) + v11);
      *(_DWORD *)a3 = v11 + 8;
    }
    v13 = *v15;
    v14 = 0LL;
  }
  else
  {
    if ( v11 > 0x27 )
    {
      v12 = (__int64 *)((*(_QWORD *)(a3 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
      *(_QWORD *)(a3 + 8) = v12 + 2;
    }
    else
    {
      v12 = (__int64 *)(*(_QWORD *)(a3 + 16) + v11);
      *(_DWORD *)a3 = v11 + 16;
    }
    v13 = *v12;
    v14 = v12[1];
  }
  v16 = (unsigned __int64)((a4 & 0x40) == 0) << a4;
  v17 = (unsigned __int64)((a4 & 0x40) != 0) << a4;
  v18 = v16 - 1;
  v19 = (v16 != 0) + v17 - 1;
  *(_QWORD *)&v44 = (v16 | (v16 - 1)) & v13;
  v20 = 0;
  *((_QWORD *)&v44 + 1) = (v17 | v19) & v14;
  v21 = v9;
  if ( v10 )
  {
    if ( v17 != *((_QWORD *)&v44 + 1) || (v20 = 1, v16 != (_QWORD)v44) )
    {
      v20 = 0;
      if ( v16 & (unsigned __int64)v44 | v17 & *((_QWORD *)&v44 + 1) )
      {
        v20 = 1;
        v22 = -v44;
        *(_QWORD *)&v44 = -(__int64)v44 & (v16 | v18);
        *((_QWORD *)&v44 + 1) = *((_QWORD *)&v22 + 1) & (v17 | v19);
      }
      a4 = v19 & *((_QWORD *)&v44 + 1);
      *(_QWORD *)&v44 = v18 & v44;
      *((_QWORD *)&v44 + 1) &= v19;
    }
  }
  v23 = a7;
  v24 = a5;
  if ( v44 != 0 || (v21 = v9 & 0xEF, v25 = 0, (v9 & 0x20) == 0) )
  {
    v26 = 0;
    v25 = 0;
    do
    {
      if ( v24 )
      {
        v45[0] = v44 & ~(-1 << a5);
        *(_QWORD *)&v28 = ((unsigned __int64)v44 >> v24) | (*((_QWORD *)&v44 + 1) << (64 - (unsigned __int8)v24));
        *((_QWORD *)&v28 + 1) = *((_QWORD *)&v44 + 1) >> v24;
        if ( (v24 & 0x40) != 0 )
          *(_QWORD *)&v28 = *((_QWORD *)&v44 + 1) >> v24;
        if ( (v24 & 0x40) != 0 )
          *((_QWORD *)&v28 + 1) = 0LL;
        v44 = v28;
      }
      else
      {
        *(_QWORD *)&v27 = sub_43A91D(v44, v45);
        v24 = 0;
        v44 = v27;
      }
      if ( (v21 & 0x80u) != 0 && v26 == 3 )
      {
        a4 = v25 + 1;
        v26 = 1;
        *((_BYTE *)&v45[1] + v25) = 44;
      }
      else
      {
        ++v26;
        a4 = v25;
      }
      v25 = a4 + 1;
      *((_BYTE *)&v45[1] + a4) = *(_BYTE *)(a9 + (unsigned int)v45[0]);
    }
    while ( v44 != 0 );
  }
  v29 = v21;
  v30 = v21 & 2;
  if ( (v21 & 2) == 0 )
  {
    v31 = v21 & 1;
    if ( a7 && v31 && (v20 || (v29 & 0xC) != 0) )
      v23 = a7 - 1;
    v32 = (char *)&v45[1] + v25;
    while ( a6 > v25 && v25 <= 0x8F )
    {
      *v32 = 48;
      ++v25;
      ++v32;
    }
    v33 = (char *)&v45[1] + v25;
    while ( v31 && v25 < v23 && v25 <= 0x8F )
    {
      *v33 = 48;
      ++v25;
      ++v33;
    }
  }
  if ( (v29 & 0x10) == 0 )
    goto LABEL_73;
  LOBYTE(a4) = a5 == 4;
  if ( (v29 & 0x20) == 0 && v25 && (v25 == a6 || v25 == v23) )
  {
    v34 = v25 - 1;
    if ( *((_BYTE *)v45 + v25 + 3) == 48 )
    {
      if ( v25 == 1 )
      {
        v25 = 0;
      }
      else if ( a5 == 1 || a5 == 4 )
      {
        v35 = *((_BYTE *)v45 + v25 + 2) == 48;
        v25 -= 2;
        if ( !v35 )
          v25 = v34;
      }
      else
      {
        --v25;
      }
    }
  }
  if ( v25 <= 0x8F && a5 == 4 )
  {
    *((_BYTE *)&v45[1] + v25) = 120;
  }
  else
  {
    if ( a5 != 1 || v25 > 0x8F )
      goto LABEL_71;
    *((_BYTE *)&v45[1] + v25) = 98;
  }
  ++v25;
LABEL_71:
  if ( v25 > 0x8F )
    goto LABEL_81;
  v36 = v25++;
  *((_BYTE *)&v45[1] + v36) = 48;
LABEL_73:
  if ( v25 <= 0x8F )
  {
    if ( v20 )
    {
      *((_BYTE *)&v45[1] + v25) = 45;
LABEL_80:
      ++v25;
      goto LABEL_81;
    }
    if ( (v29 & 4) != 0 )
    {
      *((_BYTE *)&v45[1] + v25) = 43;
      goto LABEL_80;
    }
    if ( (v29 & 8) != 0 )
    {
      *((_BYTE *)&v45[1] + v25) = 32;
      goto LABEL_80;
    }
  }
LABEL_81:
  LOBYTE(v29) = v29 & 3;
  if ( !(_BYTE)v29 && v23 > v25 && (unsigned int)sub_43907A(a1, a2, v23 - v25) == -1 )
    return 0xFFFFFFFFLL;
  for ( i = v25; i; --i )
  {
    v39 = (unsigned int)*((char *)v45 + i + 3);
    if ( ((unsigned int (__fastcall *)(__int64, __int64, __int64, __int64))a1)(v39, a2, v29, a4) == -1 )
      return 0xFFFFFFFFLL;
  }
  if ( v30 && v23 > v25 )
    return (unsigned int)-((unsigned int)sub_43907A(a1, a2, v23 - v25) == -1);
  else
    return 0LL;
}
// 4388B5: variable 'v27' is possibly undefined
// 438B36: variable 'v29' is possibly undefined
// 438B36: variable 'a4' is possibly undefined

//----- (0000000000438B80) ----------------------------------------------------
__int64 __fastcall sub_438B80(__int64 (__fastcall *a1)(), __int64 a2, _BYTE *a3, __int64 a4, __int64 a5)
{
  __int64 (*v7)(); // r12
  int v9; // eax
  char *v10; // rbx
  __int64 v11; // rcx
  char *v12; // rdi
  __int64 v13; // rdx
  __int64 i; // r9
  int v15; // eax
  unsigned int v16; // edx
  __int64 v17; // rax
  unsigned int *v18; // rax
  char v19; // dl
  char *v20; // rax
  unsigned int j; // esi
  int v22; // edi
  unsigned int v23; // edx
  __int64 v24; // rax
  unsigned int *v25; // rax
  unsigned int v26; // er11
  bool v27; // zf
  __int64 v28; // rdi
  __int64 v29; // rsi
  int v30; // eax
  long double *v31; // rax
  long double v32; // fst7
  unsigned int v33; // edx
  double *v34; // rax
  unsigned int v35; // edx
  int *v36; // rax
  int v37; // eax
  int *v38; // rdx
  unsigned __int8 v39; // al
  int *v40; // rax
  unsigned int v41; // edx
  int **v42; // rax
  int v44; // [rsp+14h] [rbp-4Ch]
  char v45; // [rsp+18h] [rbp-48h]
  unsigned int v46; // [rsp+1Ch] [rbp-44h]
  int v47[15]; // [rsp+24h] [rbp-3Ch] BYREF

  v7 = sub_40126D;
  v9 = dword_453D68;
  if ( a1 )
    v7 = a1;
  v46 = dword_453D68;
  while ( *a3 )
  {
    if ( *a3 == 37 )
    {
      v10 = a3 + 1;
      v11 = 0LL;
      while ( 1 )
      {
        LOBYTE(v9) = *v10;
        v12 = v10 + 1;
        if ( *v10 == 44 )
        {
          LOBYTE(v11) = v11 | 0x80;
          goto LABEL_16;
        }
        if ( *v10 > 44 )
          break;
        if ( (_BYTE)v9 == 39 )
          goto LABEL_26;
        if ( (char)v9 > 39 )
        {
          if ( (_BYTE)v9 != 43 )
            goto LABEL_27;
          v11 = (unsigned int)v11 | 4;
        }
        else
        {
          if ( (_BYTE)v9 == 32 )
            goto LABEL_26;
          if ( (_BYTE)v9 != 35 )
            goto LABEL_27;
          v11 = (unsigned int)v11 | 0x10;
        }
LABEL_16:
        ++v10;
      }
      switch ( (_BYTE)v9 )
      {
        case '0':
          v11 = (unsigned int)v11 | 1;
          goto LABEL_16;
        case '`':
          LODWORD(v11) = v11 | 4;
LABEL_26:
          v11 = (unsigned int)v11 | 8;
          goto LABEL_16;
        case '-':
          v11 = (unsigned int)v11 | 2;
          goto LABEL_16;
      }
LABEL_27:
      v13 = (unsigned int)(v9 - 48);
      if ( (unsigned __int8)(v9 - 48) > 9u )
      {
        if ( (_BYTE)v9 == 42 )
        {
          v16 = *(_DWORD *)a4;
          if ( *(_DWORD *)a4 > 0x2Fu )
          {
            v18 = *(unsigned int **)(a4 + 8);
            v13 = (__int64)(v18 + 2);
            *(_QWORD *)(a4 + 8) = v18 + 2;
          }
          else
          {
            v17 = v16;
            v13 = v16 + 8;
            v18 = (unsigned int *)(*(_QWORD *)(a4 + 16) + v17);
            *(_DWORD *)a4 = v13;
          }
          i = *v18;
          if ( (int)i < 0 )
          {
            v11 = (unsigned int)v11 | 2;
            i = (unsigned int)-(int)i;
          }
        }
        else
        {
          v12 = v10;
          i = 0LL;
        }
      }
      else
      {
        for ( i = 0LL; ; i = (unsigned int)(10 * i + v15 - 48) )
        {
          v15 = *v10;
          v13 = (unsigned int)(v15 - 48);
          if ( (unsigned __int8)(*v10 - 48) > 9u )
            break;
          ++v10;
        }
        v12 = v10;
      }
      if ( *v12 == 46 )
      {
        v19 = v12[1];
        v11 = (unsigned int)v11 | 0x20;
        v20 = v12 + 1;
        if ( (unsigned __int8)(v19 - 48) > 9u )
        {
          j = 0;
          if ( v19 == 42 )
          {
            v23 = *(_DWORD *)a4;
            if ( *(_DWORD *)a4 > 0x2Fu )
            {
              v25 = *(unsigned int **)(a4 + 8);
              v13 = (__int64)(v25 + 2);
              *(_QWORD *)(a4 + 8) = v25 + 2;
            }
            else
            {
              v24 = v23;
              v13 = v23 + 8;
              v25 = (unsigned int *)(*(_QWORD *)(a4 + 16) + v24);
              *(_DWORD *)a4 = v13;
            }
            j = 0;
            if ( (*v25 & 0x80000000) == 0 )
              j = *v25;
            v20 = v12 + 2;
          }
        }
        else
        {
          for ( j = 0; ; j = 10 * j + v22 - 48 )
          {
            v22 = *v20;
            v13 = (unsigned int)(v22 - 48);
            if ( (unsigned __int8)(*v20 - 48) > 9u )
              break;
            ++v20;
          }
        }
      }
      else
      {
        v20 = v12;
        j = 0;
      }
      LOBYTE(v13) = *v20;
      if ( *v20 == 106 )
      {
        ++v20;
        v26 = 127;
      }
      else if ( *v20 > 106 )
      {
        if ( (_BYTE)v13 == 108 )
        {
          if ( v20[1] == 108 )
            ++v20;
          goto LABEL_66;
        }
        v26 = 31;
        if ( (_BYTE)v13 != 107 )
        {
          if ( (_BYTE)v13 == 116 )
            goto LABEL_66;
          v27 = (_BYTE)v13 == 122;
LABEL_62:
          if ( v27 )
          {
LABEL_66:
            ++v20;
            v26 = 63;
          }
        }
      }
      else if ( (_BYTE)v13 == 104 )
      {
        if ( v20[1] == 104 )
        {
          v20 += 2;
          v26 = 7;
        }
        else
        {
          ++v20;
          v26 = 15;
        }
      }
      else
      {
        v26 = 31;
        if ( (_BYTE)v13 != 105 )
        {
          if ( (_BYTE)v13 != 76 )
          {
            v27 = (_BYTE)v13 == 90;
            goto LABEL_62;
          }
          goto LABEL_66;
        }
      }
      v28 = (unsigned int)*v20;
      a3 = v20 + 1;
      if ( *v20 == 109 )
      {
        v44 = i;
        v45 = v11;
        v40 = (int *)sub_439554(v46);
        LOBYTE(v11) = v45;
        v38 = v40;
        LODWORD(i) = v44;
        v39 = 34;
        LOBYTE(v26) = 0;
LABEL_120:
        v30 = sub_4391D4(
                (unsigned int (__fastcall *)(_QWORD))v7,
                a2,
                (unsigned __int64)v38,
                v11,
                j,
                (unsigned int)i,
                v26,
                v39);
        goto LABEL_123;
      }
      if ( *v20 > 109 )
      {
        if ( *v20 == 114 )
        {
          LOBYTE(v11) = v11 | 4;
          goto LABEL_115;
        }
        if ( *v20 <= 114 )
        {
          if ( *v20 != 112 )
          {
            if ( *v20 != 113 )
            {
              a5 = 3LL;
              v13 = (__int64)"0123456789abcdef";
              if ( *v20 != 111 )
                goto LABEL_121;
              goto LABEL_101;
            }
LABEL_115:
            LOBYTE(v11) = v11 | 8;
LABEL_116:
            v41 = *(_DWORD *)a4;
            if ( *(_DWORD *)a4 > 0x2Fu )
            {
              v42 = *(int ***)(a4 + 8);
              *(_QWORD *)(a4 + 8) = v42 + 1;
            }
            else
            {
              v42 = (int **)(*(_QWORD *)(a4 + 16) + v41);
              *(_DWORD *)a4 = v41 + 8;
            }
            v38 = *v42;
            v39 = 34;
            goto LABEL_120;
          }
          LOBYTE(v11) = v11 | 1;
          LOBYTE(a5) = 4;
          v13 = (__int64)"0123456789abcdef";
          v26 = 47;
          LODWORD(i) = 12;
          goto LABEL_101;
        }
        if ( *v20 != 117 )
        {
          a5 = 4LL;
          v13 = (__int64)"0123456789abcdef";
          if ( *v20 != 120 )
          {
            if ( *v20 != 115 )
              goto LABEL_121;
            goto LABEL_116;
          }
LABEL_101:
          v30 = sub_4386B4((__int64 (__fastcall *)(__int64, __int64))v7, a2, a4, v26, a5 & 7, j, i, v11, v13);
          goto LABEL_123;
        }
LABEL_98:
        LOBYTE(v11) = v11 & 0xEF;
        LOBYTE(a5) = 0;
LABEL_100:
        v13 = (__int64)"0123456789abcdef";
        goto LABEL_101;
      }
      if ( *v20 == 98 )
      {
        LOBYTE(a5) = 1;
        goto LABEL_100;
      }
      if ( *v20 > 98 )
      {
        if ( *v20 != 100 )
        {
          if ( *v20 <= 100 )
          {
            if ( *v20 != 99 )
              goto LABEL_121;
            v35 = *(_DWORD *)a4;
            if ( *(_DWORD *)a4 > 0x2Fu )
            {
              v36 = *(int **)(a4 + 8);
              *(_QWORD *)(a4 + 8) = v36 + 2;
            }
            else
            {
              v36 = (int *)(*(_QWORD *)(a4 + 16) + v35);
              *(_DWORD *)a4 = v35 + 8;
            }
            v37 = *v36;
            v38 = v47;
            v47[1] = 0;
            v47[0] = v37;
            v39 = 39;
            goto LABEL_120;
          }
          if ( *v20 == 102 )
          {
LABEL_102:
            if ( (_BYTE)v26 == 63 )
            {
              v31 = (long double *)((*(_QWORD *)(a4 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
              *(_QWORD *)(a4 + 8) = v31 + 1;
              v32 = *v31;
            }
            else
            {
              v33 = *(_DWORD *)(a4 + 4);
              if ( v33 > 0xAF )
              {
                v34 = *(double **)(a4 + 8);
                *(_QWORD *)(a4 + 8) = v34 + 1;
              }
              else
              {
                v34 = (double *)(*(_QWORD *)(a4 + 16) + v33);
                *(_DWORD *)(a4 + 4) = v33 + 16;
              }
              v32 = *v34;
            }
            v30 = sub_438410((__int64 (__fastcall *)(__int64, __int64))v7, a2, j, (unsigned int)i, v11, v32);
            goto LABEL_123;
          }
          if ( *v20 != 105 )
            goto LABEL_121;
        }
        LOBYTE(v11) = v11 | 0x40;
        goto LABEL_98;
      }
      if ( *v20 == 70 )
        goto LABEL_102;
      a5 = 4LL;
      v13 = (__int64)"0123456789ABCDEF";
      if ( *v20 == 88 )
        goto LABEL_101;
      if ( *v20 == 37 )
      {
        v29 = a2;
        v28 = 37LL;
        goto LABEL_122;
      }
LABEL_121:
      v29 = a2;
LABEL_122:
      v30 = ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64))v7)(
              v28,
              v29,
              v13,
              v11,
              a5,
              i);
LABEL_123:
      v9 = v30 + 1;
      if ( !v9 )
        return 0xFFFFFFFFLL;
    }
    else
    {
      v9 = ((__int64 (__fastcall *)(_QWORD, __int64))v7)((unsigned int)(char)*a3, a2) + 1;
      if ( !v9 )
        return 0xFFFFFFFFLL;
      ++a3;
    }
  }
  return 0LL;
}
// 438FDA: variable 'a5' is possibly undefined
// 453D68: using guessed type int dword_453D68;

//----- (0000000000438FFB) ----------------------------------------------------
__int64 sub_438FFB(__int64 a1, __int64 a2, _BYTE *a3, ...)
{
  va_list va; // [rsp+8h] [rbp-C8h] BYREF
  __int64 v5; // [rsp+38h] [rbp-98h]
  __int64 v6; // [rsp+40h] [rbp-90h]

  va_start(va, a3);
  v5 = va_arg(va, _QWORD);
  v6 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a3);
  return sub_439652(a1, a2, a3, (__int64)va, v6);
}

//----- (000000000043907A) ----------------------------------------------------
__int64 __fastcall sub_43907A(__int64 (__fastcall *a1)(__int64, __int64), __int64 a2, int a3)
{
  int v3; // er13
  unsigned int v4; // er12

  v3 = 0;
  v4 = 0;
  while ( v3 != a3 )
  {
    ++v3;
    v4 |= a1(32LL, a2);
  }
  return v4;
}

//----- (00000000004390BD) ----------------------------------------------------
__int64 sub_4390BD(__int64 a1, _BYTE *a2, ...)
{
  va_list va; // [rsp+8h] [rbp-C8h] BYREF
  __int64 v4; // [rsp+30h] [rbp-A0h]
  __int64 v5; // [rsp+38h] [rbp-98h]
  __int64 v6; // [rsp+40h] [rbp-90h]

  va_start(va, a2);
  v4 = va_arg(va, _QWORD);
  v5 = va_arg(va, _QWORD);
  v6 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  return sub_439652(a1, 0x7FFFFFFFLL, a2, (__int64)va, v6);
}

//----- (000000000043914E) ----------------------------------------------------
__int64 sub_43914E(__int64 a1, unsigned __int64 a2, ...)
{
  va_list va; // [rsp+8h] [rbp-C8h] BYREF

  va_start(va, a2);
  return sub_4396C3(a1, a2, (int *)va);
}

//----- (00000000004391D4) ----------------------------------------------------
__int64 __fastcall sub_4391D4(
        unsigned int (__fastcall *a1)(_QWORD),
        __int64 a2,
        unsigned __int64 a3,
        char a4,
        unsigned __int64 a5,
        unsigned __int64 a6,
        char a7,
        unsigned __int8 a8)
{
  char v10; // bl
  unsigned __int8 *v11; // r15
  __int64 v12; // rdi
  __int64 result; // rax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  __int64 v17; // rax
  unsigned int v18; // eax
  __int64 v19; // rax
  int v20; // edx
  bool v21; // zf
  unsigned __int64 v22; // rdx
  unsigned int v23; // eax
  unsigned __int64 v24; // [rsp+0h] [rbp-70h]
  unsigned __int64 v25; // [rsp+18h] [rbp-58h]
  _BOOL4 v26; // [rsp+20h] [rbp-50h]
  char v27; // [rsp+27h] [rbp-49h]
  unsigned int v29; // [rsp+34h] [rbp-3Ch] BYREF
  __int64 v30[7]; // [rsp+38h] [rbp-38h] BYREF

  v10 = a4;
  v27 = a7;
  if ( !a3 )
  {
    a3 = (unsigned __int64)"(null)";
    if ( (a4 & 4) != 0 )
      a3 = (unsigned __int64)"NULL";
    v27 = 0;
    v11 = (unsigned __int8 *)a3;
    v10 = a4 & 0x5F | 0x80;
    goto LABEL_13;
  }
  v11 = (unsigned __int8 *)a3;
  if ( (a4 & 4) != 0 )
  {
    if ( a7 == 63 )
    {
      v12 = 76LL;
    }
    else
    {
      if ( a7 != 15 )
      {
LABEL_9:
        if ( ((unsigned int (__fastcall *)(_QWORD, __int64))a1)((unsigned int)(char)a8, a2) == -1 )
          return 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      v12 = 117LL;
    }
    if ( a1(v12) == -1 )
      return 0xFFFFFFFFLL;
    goto LABEL_9;
  }
LABEL_13:
  v14 = -1;
  if ( a5 )
    v14 = a5;
  if ( a6 )
  {
    if ( v27 == 63 )
    {
      v14 = sub_43AE81((__int64)v11, v14);
    }
    else if ( v27 == 15 )
    {
      v14 = sub_43AE6F((__int64)v11, v14);
    }
    else
    {
      v14 = (unsigned int)sub_43AD57((__int64)v11, v14);
    }
  }
  if ( (v10 & 0x20) != 0 && v14 > a5 )
    v14 = a5;
  v25 = v14;
  if ( v14 < a6
    && (v10 & 2) == 0
    && (unsigned int)sub_43907A((__int64 (__fastcall *)(__int64, __int64))a1, a2, (unsigned int)a6 - v14) == -1 )
  {
    return 0xFFFFFFFFLL;
  }
  v26 = (v10 & 0x20) != 0 && (v10 & 0x18) != 0;
  while ( 1 )
  {
    if ( !a5 && (v10 & 0x20) != 0 )
      goto LABEL_34;
    if ( v27 == 15 )
    {
      v15 = *(unsigned __int16 *)v11;
      a3 = *(unsigned __int16 *)v11;
      v29 = v15;
      if ( !(v15 | v26) )
        goto LABEL_34;
      if ( v15 - 1 <= 0xD7FE )
      {
        v11 += 2;
        goto LABEL_67;
      }
      if ( (a3 & 0xFC00) != 0xDC00 )
      {
        v16 = 1;
        if ( (unsigned __int16)a3 > 0xD7FFu )
          v16 = sub_439F54((__int64)v11, &v29);
        if ( !v16 )
          v16 = 1;
        v17 = 2LL * v16;
        goto LABEL_66;
      }
      v11 += 2;
      goto LABEL_77;
    }
    if ( v27 == 63 )
    {
      v18 = *(_DWORD *)v11;
      v11 += 4;
      v29 = v18;
      if ( v18 )
        goto LABEL_67;
      goto LABEL_34;
    }
    a3 = (unsigned int)(char)*v11;
    v19 = *v11;
    if ( (v10 & 0x10) != 0 )
      break;
    v29 = *v11;
    if ( !((unsigned int)v19 | v26) )
      goto LABEL_34;
    if ( (unsigned int)(v19 - 1) <= 0x7E )
      goto LABEL_54;
    v20 = a3 & 0xC0;
    v21 = v20 == 128;
    a3 = (unsigned int)(v20 - 128);
    if ( !v21 )
    {
      v30[0] = 0LL;
      v22 = 7LL;
      if ( (v10 & 0x20) != 0 )
      {
        v22 = a5 - 1;
        if ( a5 - 1 > 7 )
          v22 = 7LL;
      }
      sub_43AAA0((__int64)v30, (__int64)v11, v22);
      if ( (v23 & 0x80u) != 0 )
      {
        LODWORD(v17) = sub_439F72(v11, (int *)&v29);
      }
      else
      {
        v29 = v23;
        LODWORD(v17) = 1;
      }
      if ( (int)v17 <= 0 )
        LODWORD(v17) = 1;
      v17 = (int)v17;
LABEL_66:
      v11 += v17;
LABEL_67:
      if ( (v10 & 8) != 0 )
      {
        if ( v29 <= 0x7F )
        {
          a3 = (unsigned int)sub_43A8B2(v29);
          goto LABEL_75;
        }
        v30[0] = 0LL;
LABEL_73:
        sub_43A2A2(v30, 8uLL, v29, 0);
      }
      else
      {
        v30[0] = 0LL;
        if ( v29 > 0x7F )
          goto LABEL_73;
        LOBYTE(v30[0]) = v29;
      }
      a3 = v30[0];
LABEL_75:
      while ( 1 )
      {
        v24 = a3;
        if ( ((unsigned int (__fastcall *)(_QWORD, __int64))a1)((unsigned __int8)a3, a2) == -1 )
          return 0xFFFFFFFFLL;
        a3 = v24 >> 8;
        if ( !(v24 >> 8) )
          goto LABEL_77;
      }
    }
    ++v11;
LABEL_77:
    --a5;
  }
  if ( *v11 || v26 )
  {
    v29 = *((unsigned __int16 *)qword_447100 + v19);
LABEL_54:
    ++v11;
    goto LABEL_67;
  }
LABEL_34:
  if ( v25 > a6
    || (v10 & 2) == 0
    || (unsigned int)sub_43907A((__int64 (__fastcall *)(__int64, __int64))a1, a2, (int)a6 - (int)v25) != -1 )
  {
    result = 0LL;
    if ( (v10 & 0x84) == 4LL )
      return (unsigned int)-(((unsigned int (__fastcall *)(_QWORD, __int64, unsigned __int64))a1)(a8, a2, a3) == -1);
    return result;
  }
  return 0xFFFFFFFFLL;
}
// 439459: variable 'v23' is possibly undefined
// 43951A: variable 'a3' is possibly undefined
// 43A8B2: using guessed type __int64 __fastcall sub_43A8B2(_QWORD);
// 447100: using guessed type __int64 qword_447100[64];

//----- (0000000000439554) ----------------------------------------------------
void *__fastcall sub_439554(unsigned int a1)
{
  sub_43956E(a1, (__int64)&unk_453D6D, 512LL);
  return &unk_453D6D;
}

//----- (000000000043956E) ----------------------------------------------------
__int64 __fastcall sub_43956E(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned int v4; // eax
  unsigned int v5; // er15
  __int64 v6; // r14
  char *v7; // rdx
  char *v8; // rax
  __int16 v10[124]; // [rsp+18h] [rbp-F8h] BYREF

  v4 = sub_402E8A();
  v5 = dword_453D68;
  v6 = v4;
  if ( (unsigned int)sub_402E03(4608LL, 0LL, a1, 0LL) )
  {
    sub_439FB4((__int64)v10);
    v8 = "%s%s%s:%s%s: " + 12;
    v7 = &byte_43DB77;
    if ( !v10[0] )
      v8 = &byte_43DB77;
  }
  else
  {
    v10[0] = 0;
    v8 = &byte_43DB77;
  }
  sub_438FFB(a2, a3, "E%s/err=%d/errno:%d/GetLastError:%d%s%hs", byte_446A88, a1, v5, v6, v8, v10, v7);
  return 0LL;
}
// 439616: variable 'v7' is possibly undefined
// 43DB77: using guessed type char byte_43DB77;
// 453D68: using guessed type int dword_453D68;
// 43956E: using guessed type __int16 var_F8[124];

//----- (000000000043962C) ----------------------------------------------------
__int64 __fastcall sub_43962C(char a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax

  v2 = a2[1];
  if ( v2 >= a2[2] )
  {
    a2[1] = v2 + 1;
  }
  else
  {
    if ( *a2 )
      *(_BYTE *)(*a2 + v2) = a1;
    ++a2[1];
  }
  return 0LL;
}

//----- (0000000000439652) ----------------------------------------------------
__int64 __fastcall sub_439652(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // rax
  __int64 v7; // [rsp+8h] [rbp-18h] BYREF
  unsigned __int64 v8; // [rsp+10h] [rbp-10h]
  __int64 v9; // [rsp+18h] [rbp-8h]

  v9 = a2;
  v7 = a1;
  v8 = 0LL;
  sub_438B80((__int64 (__fastcall *)())sub_43962C, (__int64)&v7, a3, a4, a5);
  if ( v7 && v9 )
  {
    v5 = v9 - 1;
    if ( v9 - 1 > v8 )
      v5 = v8;
    *(_BYTE *)(v7 + v5) = 0;
  }
  return (unsigned int)v8;
}

//----- (00000000004396A1) ----------------------------------------------------
__int64 __fastcall sub_4396A1(_QWORD *a1)
{
  __int64 v1; // rax
  unsigned int v2; // er8

  v1 = a1[1];
  v2 = *(unsigned __int8 *)(*a1 + v1);
  if ( *(_BYTE *)(*a1 + v1) )
    a1[1] = v1 + 1;
  else
    return (unsigned int)-1;
  return v2;
}

//----- (00000000004396C3) ----------------------------------------------------
__int64 __fastcall sub_4396C3(__int64 a1, unsigned __int64 a2, int *a3)
{
  __int64 v4[2]; // [rsp+0h] [rbp-10h] BYREF

  v4[0] = a1;
  v4[1] = 0LL;
  return sub_4396ED((__int64 (__fastcall *)(__int64))sub_4396A1, (__int64)v4, a2, a3);
}

//----- (00000000004396ED) ----------------------------------------------------
__int64 __fastcall sub_4396ED(__int64 (__fastcall *a1)(__int64), __int64 a2, unsigned __int64 a3, int *a4)
{
  __int64 i; // rdx
  __int64 v6; // rcx
  unsigned int v7; // ebx
  __int64 v8; // rax
  unsigned __int8 v9; // al
  __int64 v10; // rax
  unsigned __int8 v11; // r10
  unsigned int v12; // er12
  unsigned __int64 v13; // rsi
  int v14; // er13
  bool v15; // zf
  unsigned __int64 v16; // rdi
  char v17; // r8
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  char v22; // r8
  char v23; // r15
  unsigned __int64 v24; // r12
  unsigned __int64 v25; // r13
  unsigned __int64 v26; // rsi
  int v27; // edi
  unsigned int v28; // eax
  __int128 v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r9
  unsigned int v32; // edx
  __int64 v33; // rax
  __int64 *v34; // rax
  __int64 v35; // rax
  unsigned __int64 *v36; // rax
  unsigned int v37; // edx
  __int64 v38; // rax
  __int64 *v39; // rax
  unsigned __int64 v40; // r15
  unsigned __int64 v41; // r13
  unsigned int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // eax
  int v45; // er13
  unsigned int v46; // eax
  _WORD *v47; // rdi
  int v48; // eax
  unsigned int v49; // edx
  _QWORD **v50; // rax
  unsigned __int64 *v51; // r12
  int v53; // [rsp+8h] [rbp-88h]
  char v54; // [rsp+Ch] [rbp-84h]
  char v56; // [rsp+28h] [rbp-68h]
  unsigned int v57; // [rsp+28h] [rbp-68h]
  unsigned int v58; // [rsp+2Ch] [rbp-64h]
  unsigned __int64 *v59; // [rsp+30h] [rbp-60h]
  unsigned int v60; // [rsp+38h] [rbp-58h]
  char v61; // [rsp+3Dh] [rbp-53h]
  char v62; // [rsp+3Dh] [rbp-53h]
  char v63; // [rsp+3Dh] [rbp-53h]
  char v64; // [rsp+3Dh] [rbp-53h]
  char v65; // [rsp+3Eh] [rbp-52h]
  char v66; // [rsp+3Eh] [rbp-52h]
  unsigned __int8 v67; // [rsp+3Fh] [rbp-51h]
  unsigned __int8 v68; // [rsp+3Fh] [rbp-51h]
  unsigned __int8 v69; // [rsp+3Fh] [rbp-51h]
  unsigned __int8 v70; // [rsp+3Fh] [rbp-51h]
  __int64 v73; // [rsp+50h] [rbp-40h] BYREF
  unsigned __int64 v74[7]; // [rsp+58h] [rbp-38h] BYREF

  v60 = 0;
  v7 = a1(a2);
  v59 = 0LL;
  v8 = 0LL;
LABEL_2:
  if ( v7 == -1 )
    goto LABEL_179;
  v58 = v8 + 1;
  v9 = *(_BYTE *)(a3 + v8);
  if ( v9 == 13 )
    goto LABEL_11;
  if ( v9 <= 0xDu )
  {
    if ( !v9 )
      return v60;
    if ( (unsigned __int8)(v9 - 9) <= 2u )
    {
LABEL_11:
      while ( (byte_44E530[(unsigned __int8)v7] & 1) != 0 )
        v7 = a1(a2);
      goto LABEL_178;
    }
LABEL_175:
    if ( *(unsigned __int8 *)(a3 + v58 - 1) == v7 )
      v7 = a1(a2);
    else
      v7 = -1;
    goto LABEL_178;
  }
  if ( v9 == 32 )
    goto LABEL_11;
  if ( v9 != 37 )
    goto LABEL_175;
  v10 = v58;
  v56 = 0;
  v11 = 32;
  v65 = 0;
  v61 = 0;
  v12 = 0;
  v67 = 1;
  while ( 1 )
  {
    v13 = a3;
    ++v58;
    v14 = *(unsigned __int8 *)(a3 + v10);
    if ( (_BYTE)v14 == 104 )
    {
      v11 >>= 1;
      v67 = 2;
      goto LABEL_18;
    }
    if ( (unsigned __int8)v14 <= 0x68u )
      break;
    if ( (_BYTE)v14 == 112 )
    {
      v14 = 120;
      LOBYTE(v6) = 16;
      v11 = 48;
      goto LABEL_69;
    }
    if ( (unsigned __int8)v14 > 0x70u )
    {
      if ( (_BYTE)v14 == 117 )
      {
        v22 = 0;
        v23 = 0;
        goto LABEL_78;
      }
      if ( (unsigned __int8)v14 > 0x75u )
      {
        if ( (_BYTE)v14 == 120 )
          goto LABEL_68;
        v15 = (_BYTE)v14 == 122;
      }
      else
      {
        if ( (_BYTE)v14 == 115 )
        {
          if ( v12 )
          {
            v16 = v12 + 1;
            v66 = 0;
          }
          else
          {
            v66 = 0;
            v16 = 32LL;
          }
LABEL_115:
          v74[0] = v16;
          if ( v56 )
          {
            v73 = 0LL;
          }
          else if ( v61 )
          {
            v73 = sub_434FC4(v67 * v16);
            if ( v73 )
            {
              v13 = 16LL;
              v36 = (unsigned __int64 *)sub_434FB8(1LL, 16LL, i);
              if ( v36 )
              {
                i = v73;
                v13 = (unsigned __int64)v59;
                v59 = v36;
                v36[1] = v73;
                *v36 = v13;
              }
            }
          }
          else
          {
            v37 = *a4;
            if ( (unsigned int)*a4 > 0x2F )
            {
              v39 = (__int64 *)*((_QWORD *)a4 + 1);
              i = (__int64)(v39 + 1);
              *((_QWORD *)a4 + 1) = v39 + 1;
            }
            else
            {
              v38 = v37;
              i = v37 + 8;
              v39 = (__int64 *)(*((_QWORD *)a4 + 2) + v38);
              *a4 = i;
            }
            v73 = *v39;
          }
          v40 = 0LL;
          if ( !v73 )
          {
            do
            {
              if ( (byte_44E530[(unsigned __int8)v7] & 1) != 0 )
                break;
              v7 = a1(a2);
            }
            while ( v7 != -1 );
            goto LABEL_178;
          }
          while ( 1 )
          {
LABEL_126:
            if ( !v12 && v61 )
            {
              if ( v40 + 3 < v74[0] || (v13 = (unsigned __int64)v74, sub_437453(&v73, v74, v67, 0LL)) )
                v12 = 0;
              else
                v12 = LODWORD(v74[0]) - 1;
            }
            if ( v7 == -1 || v40 + ((unsigned __int8)v66 ^ 1u) >= v74[0] )
            {
              if ( !v66 )
              {
LABEL_161:
                if ( v74[0] > v40 )
                {
                  if ( v67 == 1 )
                  {
                    *(_BYTE *)(v73 + v40) = 0;
                  }
                  else if ( v67 == 2 )
                  {
                    *(_WORD *)(v73 + 2 * v40) = 0;
                  }
                  else
                  {
                    *(_DWORD *)(v73 + 4 * v40) = 0;
                  }
                }
              }
              ++v60;
              if ( v61 )
              {
                v49 = *a4;
                if ( (unsigned int)*a4 > 0x2F )
                {
                  v50 = (_QWORD **)*((_QWORD *)a4 + 1);
                  *((_QWORD *)a4 + 1) = v50 + 1;
                }
                else
                {
                  v50 = (_QWORD **)(*((_QWORD *)a4 + 2) + v49);
                  *a4 = v49 + 8;
                }
                i = v73;
                **v50 = v73;
              }
              goto LABEL_178;
            }
            if ( !v66 && (byte_44E530[(unsigned __int8)v7] & 1) != 0 )
              goto LABEL_161;
            if ( v67 == 1 )
              break;
            i = v7;
            v13 = 1LL;
            while ( (i & 0xC0) == 128 )
            {
              v42 = a1(a2);
              i = v42;
              if ( v42 == -1 )
                goto LABEL_126;
              v13 = (unsigned int)(v13 + 1);
            }
            if ( (i & 0x80u) == 0LL )
            {
LABEL_151:
              v13 = (unsigned int)(v13 + 1);
              v7 = i;
              if ( (_DWORD)v13 )
              {
                if ( v67 == 2 )
                {
                  v47 = (_WORD *)(2 * v40 + v73);
                  v13 = v74[0] + ~v40;
                  if ( v13 && (unsigned int)i <= 0xD7FF )
                  {
                    *v47 = i;
                    v48 = 1;
                  }
                  else
                  {
                    v48 = sub_439F63(v47, v13, i, v6);
                  }
                  i = (unsigned int)(v48 >> 31);
                  v41 = v40 + (int)abs32(v48);
                }
                else
                {
                  v41 = v40 + 1;
                  *(_DWORD *)(v73 + 4 * v40) = i;
                }
                goto LABEL_159;
              }
            }
            else
            {
              v6 = 1LL;
              _BitScanReverse(&v43, (unsigned __int8)~(_BYTE)i);
              v44 = v43 ^ 0x1F;
              if ( v44 != 31 )
                v6 = v44 ^ 0x1F;
              v57 = 7 - v6;
              v45 = 1 - v13;
              for ( i = (((1 << v6) - 1) | 3) & (unsigned int)i; ; i = (unsigned int)v6 | (v53 << 6) )
              {
                if ( v45 + (int)v13 >= v57 )
                  goto LABEL_151;
                v53 = i;
                v46 = a1(a2);
                v6 = v46;
                if ( v46 == -1 )
                  goto LABEL_126;
                if ( (v46 & 0xC0) != 128 )
                  break;
                v6 = v46 & 0x3F;
                v13 = (unsigned int)(v13 + 1);
              }
              v7 = 65533;
            }
          }
          v41 = v40 + 1;
          *(_BYTE *)(v73 + v40) = v7;
LABEL_159:
          v40 = v41;
          v7 = ((__int64 (__fastcall *)(__int64, unsigned __int64, __int64, __int64))a1)(a2, v13, i, v6);
          goto LABEL_126;
        }
        v15 = (_BYTE)v14 == 116;
      }
      if ( !v15 )
        goto LABEL_64;
      goto LABEL_42;
    }
    if ( (_BYTE)v14 == 109 )
    {
      v61 = 1;
      goto LABEL_18;
    }
    if ( (unsigned __int8)v14 > 0x6Du )
    {
      if ( (_BYTE)v14 != 110 )
      {
        v22 = 0;
        v23 = 0;
        LOBYTE(v6) = 8;
        goto LABEL_80;
      }
LABEL_59:
      if ( v7 == 43 )
      {
        v17 = 0;
        goto LABEL_63;
      }
      v17 = 1;
      if ( v7 == 45 )
      {
LABEL_63:
        v62 = v17;
        v68 = v11;
        v23 = 1;
        v18 = a1(a2);
        v11 = v68;
        v22 = v62;
        v7 = v18;
        LOBYTE(v6) = 10;
LABEL_74:
        if ( v7 == -1 )
          goto LABEL_178;
      }
      else
      {
        v22 = 0;
        v23 = 1;
LABEL_78:
        LOBYTE(v6) = 10;
      }
      goto LABEL_80;
    }
    v11 = 0x80;
    if ( (_BYTE)v14 != 106 )
    {
      if ( (_BYTE)v14 != 108 )
        goto LABEL_64;
      v67 = 4;
LABEL_42:
      v11 = 64;
    }
LABEL_18:
    v10 = v58;
  }
  if ( (unsigned __int8)v14 <= 0x39u )
  {
    if ( (unsigned __int8)v14 > 0x2Fu )
    {
      v12 = 10 * v12 + v14 - 48;
    }
    else
    {
      switch ( (_BYTE)v14 )
      {
        case '\'':
          v65 = 1;
          break;
        case '*':
          v56 = 1;
          break;
        case '%':
          goto LABEL_175;
        default:
          goto LABEL_64;
      }
    }
    goto LABEL_18;
  }
  if ( (_BYTE)v14 == 98 )
  {
    LOBYTE(v6) = 2;
LABEL_69:
    if ( v7 == 48 )
    {
      v63 = v6;
      v69 = v11;
      v20 = a1(a2);
      v11 = v69;
      LOBYTE(v6) = v63;
      v7 = v20;
      if ( v20 == v14 || v20 == v14 + 32 )
      {
        v23 = 0;
        v21 = a1(a2);
        v11 = v69;
        LOBYTE(v6) = v63;
        v7 = v21;
        v22 = 0;
      }
      else
      {
        v22 = 0;
        v23 = 0;
      }
      goto LABEL_74;
    }
    v22 = 0;
    v23 = 0;
LABEL_80:
    v24 = 0LL;
    v25 = 0LL;
    v26 = (unsigned __int8)v6;
    while ( 1 )
    {
      v27 = (unsigned __int8)byte_44E430[(unsigned __int8)v7];
      if ( (_BYTE)v27 && (unsigned __int8)v27 <= (unsigned __int8)v6 )
      {
        v25 = (v27 - 1 + __PAIR128__(v26 * v25 + ((v26 * (unsigned __int128)v24) >> 64), v26 * v24)) >> 64;
        v24 = v27 - 1 + v26 * v24;
      }
      else if ( (_BYTE)v27 != 44 || !v65 )
      {
LABEL_87:
        if ( v56 )
          goto LABEL_178;
        *(_QWORD *)&v29 = (unsigned __int64)(((v11 - 1) & 0x40) == 0) << (v11 - 1);
        *((_QWORD *)&v29 + 1) = (unsigned __int64)(((v11 - 1) & 0x40) != 0) << (v11 - 1);
        v30 = 0LL;
        v31 = 0LL;
        if ( !v23 )
          v30 = (unsigned __int64)(((v11 - 1) & 0x40) != 0) << (v11 - 1);
        if ( !v23 )
          v31 = (unsigned __int64)(((v11 - 1) & 0x40) == 0) << (v11 - 1);
        v6 = v24 & ~((v29 - 1) | v31) | v25 & ~((((v29 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1) | v30);
        if ( v6 )
        {
          v6 = v25 ^ *((_QWORD *)&v29 + 1) | v29 ^ v24;
          if ( v6 || !v23 )
          {
            v19 = sub_40216C();
            goto LABEL_99;
          }
        }
        ++v60;
        if ( v23 && v22 )
        {
          v24 = -(__int64)v24;
          v25 = (unsigned __int128)-(__int128)__PAIR128__(v25, v24) >> 64;
        }
        v32 = *a4;
        if ( (unsigned int)*a4 > 0x2F )
        {
          v34 = (__int64 *)*((_QWORD *)a4 + 1);
          i = (__int64)(v34 + 1);
          *((_QWORD *)a4 + 1) = v34 + 1;
        }
        else
        {
          v33 = v32;
          i = v32 + 8;
          v34 = (__int64 *)(*((_QWORD *)a4 + 2) + v33);
          *a4 = i;
        }
        v35 = *v34;
        if ( v11 == 48 )
          goto LABEL_111;
        if ( v11 <= 0x30u )
        {
          if ( v11 == 16 )
          {
            *(_WORD *)v35 = v24;
          }
          else
          {
            if ( v11 == 32 )
            {
              *(_DWORD *)v35 = v24;
              goto LABEL_178;
            }
LABEL_113:
            *(_BYTE *)v35 = v24;
          }
          goto LABEL_178;
        }
        if ( v11 == 64 )
        {
LABEL_111:
          *(_QWORD *)v35 = v24;
          goto LABEL_178;
        }
        if ( v11 != 0x80 )
          goto LABEL_113;
        *(_QWORD *)v35 = v24;
        *(_QWORD *)(v35 + 8) = v25;
LABEL_178:
        v8 = v58;
        goto LABEL_2;
      }
      v54 = v22;
      v64 = v6;
      v70 = v11;
      v28 = a1(a2);
      v11 = v70;
      LOBYTE(v6) = v64;
      v22 = v54;
      v7 = v28;
      if ( v28 == -1 )
        goto LABEL_87;
    }
  }
  if ( (unsigned __int8)v14 <= 0x62u )
  {
    if ( (_BYTE)v14 == 88 )
    {
      v14 = 120;
LABEL_68:
      LOBYTE(v6) = 16;
      goto LABEL_69;
    }
    v11 = 64;
    if ( (_BYTE)v14 != 90 )
    {
      if ( (_BYTE)v14 != 76 )
        goto LABEL_64;
      v67 = 4;
    }
    goto LABEL_18;
  }
  if ( (_BYTE)v14 == 99 )
  {
    v66 = 1;
    if ( !v12 )
      v12 = 1;
    v16 = v12;
    goto LABEL_115;
  }
  if ( (_BYTE)v14 == 100 )
    goto LABEL_59;
LABEL_64:
  v19 = sub_4020CC();
LABEL_99:
  v60 = v19;
LABEL_179:
  while ( v59 )
  {
    v74[0] = (unsigned __int64)v59;
    v51 = (unsigned __int64 *)*v59;
    if ( v60 == -1 )
      MEMORY[0](v59 + 1);
    MEMORY[0](v74);
    v59 = v51;
  }
  return v60;
}
// 439889: conditional instruction was optimized away because r13.1==6F
// 439E20: conditional instruction was optimized away because %var_51.1==4
// 439BD1: variable 'i' is possibly undefined
// 439DBE: variable 'v6' is possibly undefined
// 434FB8: using guessed type __int64 __fastcall sub_434FB8(_QWORD, _QWORD, _QWORD);
// 434FC4: using guessed type __int64 __fastcall sub_434FC4(_QWORD);

//----- (0000000000439F54) ----------------------------------------------------
__int64 __fastcall sub_439F54(__int64 a1, _DWORD *a2)
{
  return sub_439FDC(a1, a2);
}

//----- (0000000000439F63) ----------------------------------------------------
__int64 __fastcall sub_439F63(_WORD *a1, unsigned __int64 a2, unsigned int a3, char a4)
{
  return sub_43A03D(a1, a2, a3, a4);
}

//----- (0000000000439F72) ----------------------------------------------------
__int64 __fastcall sub_439F72(unsigned __int8 *a1, int *a2)
{
  return sub_43A1F2(a1, a2);
}

//----- (0000000000439F81) ----------------------------------------------------
__int64 __fastcall sub_439F81(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  a1 = (unsigned int)a1;
  v1 = 0LL;
  if ( (unsigned int)a1 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, a1);
    v3 = *(_DWORD *)&byte_446FD3[2 * v2 - 14];
    do
    {
      v4 = a1;
      a1 = (unsigned int)a1 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return a1 | v1;
}
// 439F94: variable 'v2' is possibly undefined

//----- (0000000000439FB4) ----------------------------------------------------
__int64 __fastcall sub_439FB4(__int64 a1)
{
  if ( a1 )
    *(_WORD *)(a1 + 2 * sub_43A0EB(a1, (__int64)&word_447006)) = 0;
  return a1;
}
// 447006: using guessed type __int16 word_447006;

//----- (0000000000439FDC) ----------------------------------------------------
__int64 __fastcall sub_439FDC(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  int v4; // ebx
  int v5; // edx
  int v6; // eax

  LODWORD(result) = 0;
  do
  {
    v3 = (unsigned int)result;
    v4 = result;
    result = (unsigned int)(result + 1);
    v5 = *(unsigned __int16 *)(a1 + 2 * v3);
  }
  while ( (v5 & 0xFC00) == 0xDC00 );
  if ( (v5 & 0xFC00) == 0xD800 )
  {
    v6 = *(unsigned __int16 *)(a1 + 2 * result);
    if ( (v6 & 0xFC00) == 0xDC00 )
    {
      *a2 = (v5 << 10) + v6 - 56613888;
      return (unsigned int)(v4 + 2);
    }
    else
    {
      *a2 = 65533;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *a2 = v5;
  }
  return result;
}

//----- (000000000043A03D) ----------------------------------------------------
__int64 __fastcall sub_43A03D(_WORD *a1, unsigned __int64 a2, unsigned int a3, char a4)
{
  __int64 result; // rax
  __int16 v5; // dx
  unsigned int v6; // edx
  unsigned int v7; // eax

  result = 0LL;
  if ( a2 )
  {
    if ( a3 <= 0x1F && a4 )
    {
      if ( a2 > 1 )
      {
        *a1 = -10240;
        v5 = a3 | 0xDC00;
LABEL_12:
        a1[1] = v5;
        return 2LL;
      }
LABEL_8:
      *a1 = a3;
      return 1LL;
    }
    if ( a3 - 57344 <= 0x1FFF || a3 <= 0xD7FF )
      goto LABEL_8;
    v6 = a3 - 0x10000;
    if ( a2 > 1 && v6 <= 0xFFFFF )
    {
      v7 = v6 >> 10;
      v5 = (v6 & 0x3FF) - 9216;
      *a1 = v7 - 10240;
      goto LABEL_12;
    }
    *a1 = -3;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043A0CE) ----------------------------------------------------
__int64 __fastcall sub_43A0CE(__int64 a1, __int64 a2)
{
  sub_43A84E(a1, a2, 0LL, 0xFFFFFFFFFFFFFFFFLL);
  return a1;
}

//----- (000000000043A0EB) ----------------------------------------------------
__int64 __fastcall sub_43A0EB(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int16 v3; // cx
  unsigned int i; // edx
  __int16 v5; // r8

  for ( result = 0LL; ; ++result )
  {
    v3 = *(_WORD *)(a1 + 2 * result);
    if ( !v3 )
      break;
    for ( i = 0; ; ++i )
    {
      v5 = *(_WORD *)(a2 + 2LL * i);
      if ( !v5 )
        break;
      if ( v3 == v5 )
        return result;
    }
  }
  return result;
}

//----- (000000000043A117) ----------------------------------------------------
char *__fastcall sub_43A117(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  char *v4; // r14
  unsigned __int64 v5; // rax
  char *v6; // r8
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rbx

  v4 = sub_43AD57(a1, a3);
  v5 = sub_43AD53(a2);
  v6 = &v4[v5];
  if ( a3 )
  {
    v7 = a3 - (_QWORD)v4;
    if ( a3 - (unsigned __int64)v4 > v5 )
      v7 = v5;
    v8 = a3 - 1;
    sub_43AAA0((__int64)&v4[a1], a2, v7);
    if ( v8 > (unsigned __int64)v6 )
      v8 = (unsigned __int64)v6;
    *(_BYTE *)(a1 + v8) = 0;
  }
  return v6;
}
// 43A166: variable 'v6' is possibly undefined
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (000000000043A17B) ----------------------------------------------------
void __fastcall sub_43A17B(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rax

  v4 = sub_43AD53(a2);
  if ( a3 )
  {
    if ( v4 <= a3 )
      a3 = v4;
    sub_43AAA0(a1, a2, a3);
    *(_BYTE *)(a1 + a3) = 0;
  }
}
// 43AD53: using guessed type __int64 __fastcall sub_43AD53(_QWORD);

//----- (000000000043A1BD) ----------------------------------------------------
__int64 __fastcall sub_43A1BD(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rax

  sub_43A84E(a1, a2, 0LL, a3);
  if ( v4 )
    sub_43ABE2(v4, 0LL, a1 + a3 - v4);
  return a1;
}
// 43A1D7: variable 'v4' is possibly undefined

//----- (000000000043A1F2) ----------------------------------------------------
__int64 __fastcall sub_43A1F2(unsigned __int8 *a1, int *a2)
{
  __int64 result; // rax
  int i; // edx
  __int64 v4; // rdx
  unsigned int v5; // ebx
  int v6; // ecx
  int v7; // ebx
  unsigned int v8; // er9
  int v9; // er8
  unsigned int v10; // ecx
  unsigned __int8 v11; // al

  result = 1LL;
  for ( i = *a1; (i & 0xC0) == 128; i = a1[v4] )
  {
    v4 = (unsigned int)result;
    result = (unsigned int)(result + 1);
  }
  if ( (i & 0x80u) != 0 )
  {
    v5 = i;
    v6 = 1;
    LOBYTE(v5) = ~(_BYTE)i;
    _BitScanReverse(&v5, v5);
    v7 = v5 ^ 0x1F;
    if ( v7 != 31 )
      v6 = v7 ^ 0x1F;
    v8 = 7 - v6;
    v9 = 1 - result;
    i &= ((1 << v6) - 1) | 3;
    while ( v8 > v9 + (int)result )
    {
      v10 = result + 1;
      v11 = a1[result];
      if ( (v11 & 0xC0) != 0x80 )
      {
        result = 0xFFFFFFFFLL;
        if ( a2 )
          *a2 = 65533;
        return result;
      }
      i = v11 & 0x3F | (i << 6);
      result = v10;
    }
  }
  if ( a2 )
    *a2 = i;
  return result;
}

//----- (000000000043A2A2) ----------------------------------------------------
__int64 __fastcall sub_43A2A2(_BYTE *a1, unsigned __int64 a2, unsigned int a3, int a4)
{
  unsigned __int64 v5; // rdi
  __int64 result; // rax
  __int64 v7; // rdx

  v5 = (int)a3;
  if ( a2 > 1 && a4 != 0 && a3 <= 0x1F )
  {
    *a1 = -64;
    result = 2LL;
    a1[1] = a3 | 0x80;
  }
  else
  {
    if ( a3 > 0x7F )
      v5 = sub_439F81((int)a3);
    v7 = 0LL;
    do
    {
      result = (unsigned int)v7;
      if ( a2 == v7 )
        break;
      a1[v7] = v5;
      result = (unsigned int)++v7;
      v5 >>= 8;
    }
    while ( v5 );
  }
  return result;
}

//----- (000000000043A304) ----------------------------------------------------
unsigned __int64 __fastcall sub_43A304(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, int *a5)
{
  unsigned __int64 v6; // r10
  unsigned int v7; // er9
  unsigned __int64 v8; // rdi
  int v9; // ecx

  v6 = 0LL;
  v7 = (((unsigned __int8)byte_447300[BYTE1(a1)] | ((unsigned __int8)byte_447300[(unsigned __int8)a1] << 8)) << 16) | 0xFFFF;
  while ( v6 < a4 )
  {
    v8 = (v6 + a4) >> 1;
    if ( *(_DWORD *)(a3 + 4 * v8) > v7 )
      a4 = (v6 + a4) >> 1;
    else
      v6 = v8 + 1;
  }
  v9 = *(_DWORD *)(a3 + 4 * v6 - 4) & 0xF;
  *a5 = (*(_DWORD *)(a3 + 4 * v6 - 4) >> 4) & 0xFFF;
  return a1 >> v9;
}

//----- (000000000043A36F) ----------------------------------------------------
__int64 __fastcall sub_43A36F(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rcx
  __int16 *v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax
  int v9; // edi
  __int16 v10; // cx
  __int64 v11; // rdi
  __int64 v12; // rcx
  int v13; // er8
  int v14; // eax
  __int64 v15; // r11
  __int16 v18[16]; // [rsp+2h] [rbp-68h]
  __int16 v19[16]; // [rsp+22h] [rbp-48h]
  __int16 v20[20]; // [rsp+42h] [rbp-28h] BYREF

  v4 = 8LL;
  v5 = v20;
  while ( v4 )
  {
    *(_DWORD *)v5 = 0;
    v5 += 2;
    --v4;
  }
  v6 = 0LL;
  do
  {
    v7 = *(unsigned __int8 *)(a2 + v6++);
    ++v20[v7];
  }
  while ( v6 != a3 );
  v18[0] = 0;
  v19[0] = 0;
  v8 = 1LL;
  v20[0] = 0;
  do
  {
    LOWORD(v7) = v20[v8 - 1];
    LOWORD(v5) = v18[v8 - 1];
    v9 = v7 + (_DWORD)v5;
    v10 = v18[v8 + 15] + v7;
    LODWORD(v5) = 2 * v9;
    v18[v8] = (__int16)v5;
    v19[v8++] = v10;
  }
  while ( v8 != 16 );
  v11 = 0LL;
  do
  {
    v12 = *(unsigned __int8 *)(a2 + v11);
    v13 = *(unsigned __int8 *)(a2 + v11);
    if ( *(_BYTE *)(a2 + v11) )
    {
      v14 = (unsigned __int16)v18[v12];
      v18[v12] = v14 + 1;
      v15 = (unsigned __int16)v19[v12];
      v19[v12] = v15 + 1;
      *(_DWORD *)(a1 + 4 * v15) = (16 * v11) | v13 | (v14 << (32 - v13));
    }
    ++v11;
  }
  while ( a3 != v11 );
  return (unsigned __int16)v19[15];
}
// 43A36F: using guessed type __int16 var_28[20];

//----- (000000000043A438) ----------------------------------------------------
__int64 __fastcall sub_43A438(_BYTE *a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v7; // r12
  __int64 v9; // r9
  char v10; // cl
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  __int64 v16; // rax
  char v17; // cl
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // rax
  __int64 v22; // rsi
  char v23; // cl
  __int64 v24; // rcx
  char v25; // si
  __int64 v26; // rdx
  unsigned int v27; // eax
  char v28; // r10
  __int64 v29; // rax
  char v30; // cl
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // rdx
  unsigned __int8 v33; // al
  int v34; // esi
  char v35; // al
  __int64 v36; // rdx
  char v37; // cl
  int v38; // edx
  __int64 v39; // rdx
  unsigned __int64 v40; // rdx
  __int64 v41; // rax
  char v42; // cl
  unsigned int v43; // er11
  unsigned __int64 v44; // rdx
  int v45; // eax
  unsigned __int64 v46; // r8
  __int64 v47; // rdx
  char v48; // cl
  unsigned __int64 v49; // rdi
  unsigned __int64 v50; // rsi
  __int64 v51; // rax
  char v52; // cl
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // r12
  unsigned __int64 v56; // rax
  char v57; // di
  __int64 v58; // rdx
  char v59; // cl
  __int64 v60; // rdx
  unsigned __int64 v62; // [rsp+0h] [rbp-70h]
  char v63; // [rsp+0h] [rbp-70h]
  unsigned __int64 v64; // [rsp+0h] [rbp-70h]
  unsigned int v65; // [rsp+8h] [rbp-68h]
  unsigned int v66; // [rsp+8h] [rbp-68h]
  __int64 v67; // [rsp+10h] [rbp-60h]
  __int64 v68; // [rsp+18h] [rbp-58h]
  __int64 v69; // [rsp+20h] [rbp-50h]
  unsigned int v70; // [rsp+20h] [rbp-50h]
  unsigned __int64 v71; // [rsp+28h] [rbp-48h]
  int v72[13]; // [rsp+3Ch] [rbp-34h] BYREF

  v7 = 0LL;
  v71 = 0LL;
  v67 = a5 + 224;
  while ( 1 )
  {
    if ( v7 <= 2 )
    {
      v9 = *a3;
      v10 = v7;
      ++a3;
      v7 += 8LL;
      v11 = v71 | (v9 << v10);
      goto LABEL_4;
    }
    v7 -= 3LL;
    v12 = v71 >> 3;
    v13 = (v71 >> 1) & 3;
    if ( (_BYTE)v13 != 1 )
      break;
    sub_401AB7((_BYTE *)(a5 + 1376), &byte_4470F3);
    v15 = v71 >> 3;
    v68 = 32LL;
    v69 = 288LL;
LABEL_36:
    v64 = v15;
    v66 = sub_43A36F(v67, a5 + 1376, v69);
    sub_43A36F(a5 + 96, a5 + v69 + 1376, v68);
    v11 = v64;
    do
    {
      while ( v7 <= 0xF )
      {
        v41 = *a3;
        v42 = v7;
        ++a3;
        v7 += 8LL;
        v11 |= v41 << v42;
      }
      v11 = sub_43A304(v11, v7, v67, v66, v72);
      v7 = v44;
      if ( v72[0] > 0xFFu )
      {
        if ( v72[0] != 256 )
        {
          v45 = v72[0] - 257;
          v46 = (unsigned __int8)byte_4470A0[v72[0] - 257];
          v72[0] -= 257;
          while ( v7 < v46 )
          {
            v47 = *a3;
            v48 = v7;
            ++a3;
            v7 += 8LL;
            v11 |= v47 << v48;
          }
          v49 = v11 >> v46;
          v50 = v7 - v46;
          v70 = (v11 & ~(-1 << v46)) + (unsigned __int16)word_447020[v45];
          while ( v50 <= 0xF )
          {
            v51 = *a3;
            v52 = v50;
            ++a3;
            v50 += 8LL;
            v49 |= v51 << v52;
          }
          v53 = sub_43A304(v49, v50, a5 + 96, v43, v72);
          v55 = v54;
          v56 = (unsigned __int8)byte_4470C0[v72[0]];
          v57 = byte_4470C0[v72[0]];
          while ( v55 < v56 )
          {
            v58 = *a3;
            v59 = v55;
            ++a3;
            v55 += 8LL;
            v53 |= v58 << v59;
          }
          v7 = v55 - v56;
          v60 = (unsigned __int16)word_447060[v72[0]] + ((unsigned int)v53 & ~(-1 << v57));
          v11 = v53 >> v57;
          qmemcpy(a1, &a1[-v60], v70);
          a1 += v70;
        }
      }
      else
      {
        *a1++ = v72[0];
      }
    }
    while ( v72[0] != 256 );
    if ( (v71 & 1) != 0 )
      return 0LL;
LABEL_4:
    v71 = v11;
  }
  if ( (_BYTE)v13 == 2 )
  {
    while ( v7 <= 0xD )
    {
      v16 = *a3;
      v17 = v7;
      ++a3;
      v7 += 8LL;
      v12 |= v16 << v17;
    }
    v7 -= 14LL;
    v69 = (v12 & 0x1F) + 257;
    v18 = ((unsigned int)(v12 >> 10) & 0xF) + 4;
    v19 = v12 >> 5;
    v20 = v12 >> 14;
    v68 = (v19 & 0x1F) + 1;
    v21 = 0LL;
    do
    {
      while ( v7 <= 2 )
      {
        v22 = *a3;
        v23 = v7;
        ++a3;
        v7 += 8LL;
        v20 |= v22 << v23;
      }
      v24 = (unsigned __int8)byte_4470E0[v21++];
      v25 = v20 & 7;
      v20 >>= 3;
      v7 -= 3LL;
      *(_BYTE *)(a5 + v24) = v25;
    }
    while ( v21 < v18 );
    while ( v21 != 19 )
    {
      v26 = (unsigned __int8)byte_4470E0[v21++];
      *(_BYTE *)(a5 + v26) = 0;
    }
    v62 = v20;
    v27 = sub_43A36F(a5 + 20, a5, 19LL);
    v15 = v62;
    v65 = v27;
    v28 = 0;
    while ( 1 )
    {
      while ( v7 <= 0xF )
      {
        v29 = *a3;
        v30 = v7;
        ++a3;
        v7 += 8LL;
        v15 |= v29 << v30;
      }
      v63 = v28;
      v15 = sub_43A304(v15, v7, a5 + 20, v65, v72);
      v7 = v32;
      if ( v72[0] == 17 )
        break;
      if ( v72[0] == 18 )
      {
        v34 = 9;
        v35 = 6;
        goto LABEL_27;
      }
      v28 = v63;
      if ( v72[0] == 16 )
      {
        v33 = 2;
        v34 = 1;
LABEL_28:
        while ( v33 > v7 )
        {
          v36 = *a3;
          v37 = v7;
          ++a3;
          v7 += 8LL;
          v15 |= v36 << v37;
        }
        v7 -= v33;
        v38 = v15 & ~(-1 << v33);
        v15 >>= v33;
        v39 = (unsigned int)(v34 + v38 + 2);
        goto LABEL_32;
      }
      v28 = v72[0];
      v39 = 1LL;
LABEL_32:
      v40 = v31 + v39;
      while ( v31 != v40 )
      {
        ++v31;
        *(_BYTE *)(a5 + v31 + 1375) = v28;
      }
      if ( v68 + v69 <= v31 )
        goto LABEL_36;
    }
    v35 = 2;
    v34 = 1;
LABEL_27:
    v33 = v35 + 1;
    v28 = 0;
    goto LABEL_28;
  }
  v14 = -1LL;
  if ( !(_BYTE)v13 )
  {
    while ( 1 )
      ;
  }
  return v14;
}
// 43A5ED: variable 'v32' is possibly undefined
// 43A65F: variable 'v31' is possibly undefined
// 43A6FB: variable 'v44' is possibly undefined
// 43A78F: variable 'v43' is possibly undefined
// 43A7A0: variable 'v54' is possibly undefined
// 447020: using guessed type __int16 word_447020[];
// 447060: using guessed type __int16 word_447060[];
// 4470F3: using guessed type char byte_4470F3;

//----- (000000000043A823) ----------------------------------------------------
_DWORD *__fastcall sub_43A823(unsigned __int64 a1, unsigned __int64 a2)
{
  _DWORD *result; // rax

  result = (_DWORD *)(a1 + a2 - 22);
  if ( a2 > 0x10016 )
    a1 = a1 + a2 - 65558;
  while ( (unsigned __int64)result >= a1 )
  {
    if ( *result == 101010256 )
      return result;
    result = (_DWORD *)((char *)result - 1);
  }
  return 0LL;
}

//----- (000000000043A84E) ----------------------------------------------------
void __fastcall sub_43A84E(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v5; // rax

  sub_43AD3B();
  if ( v5 )
    sub_43AAA0(a1, a2, v5 - a2 + 1);
  else
    sub_43AAA0(a1, a2, a4);
}
// 43A872: variable 'v5' is possibly undefined

//----- (000000000043A8A2) ----------------------------------------------------
__int64 __fastcall sub_43A8A2(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rax
  __int64 result; // rax

  if ( _BitScanReverse64((unsigned __int64 *)&v3, a2) )
    return (unsigned int)(v3 + 64);
  _BitScanReverse64((unsigned __int64 *)&result, a1);
  return result;
}

//----- (000000000043A8B2) ----------------------------------------------------
#error "43A8C2: switch analysis failed: switch information is incomplete or incorrect (funcsize=22)"

//----- (000000000043A91D) ----------------------------------------------------
unsigned __int64 __fastcall sub_43A91D(__int128 a1, _DWORD *a2)
{
  unsigned __int64 v2; // r10
  unsigned int v3; // er10
  char v4; // r9
  __int64 v5; // rax
  __int64 v6; // r11
  char v8; // cl
  unsigned int v9; // er10
  __int64 v10; // rcx
  unsigned __int64 v11; // rax
  __int128 v12; // rt0
  __int64 v13; // kr00_8

  if ( *((_QWORD *)&a1 + 1) )
  {
    _BitScanReverse64(&v2, *((unsigned __int64 *)&a1 + 1));
    v3 = v2 ^ 0x3F;
    v4 = 125 - v3;
    if ( v3 == 61 )
    {
      v5 = 0LL;
      v6 = 0LL;
    }
    else
    {
      v8 = v3 - 125;
      if ( v3 < 0x3E )
      {
        v6 = (_QWORD)a1 << v8;
        *(_QWORD *)&a1 = (*((_QWORD *)&a1 + 1) << v8) | ((unsigned __int64)a1 >> v4);
        *((_QWORD *)&a1 + 1) >>= v4;
        v5 = 0LL;
      }
      else
      {
        v5 = *((_QWORD *)&a1 + 1) >> v4;
        v6 = 0LL;
        *((_QWORD *)&a1 + 1) = ((unsigned __int64)a1 >> v4) | (*((_QWORD *)&a1 + 1) << (64 - v4));
        *(_QWORD *)&a1 = (_QWORD)a1 << v8;
      }
    }
    v9 = v3 - 125;
    v10 = 0LL;
    do
    {
      *((_QWORD *)&v12 + 1) = v5;
      *(_QWORD *)&v12 = *((_QWORD *)&a1 + 1);
      v11 = v12 >> 63;
      *((_QWORD *)&a1 + 1) = a1 >> 63;
      *((_QWORD *)&v12 + 1) = a1;
      *(_QWORD *)&v12 = v6;
      *(_QWORD *)&a1 = v12 >> 63;
      v6 = (2 * v6) | v10;
      v10 = ((__int64)((9 - __PAIR128__(v11, *((unsigned __int64 *)&a1 + 1))) >> 64) >> 63) & 1;
      v13 = *((_QWORD *)&a1 + 1)
          - (((__int64)((9 - __PAIR128__(v11, *((unsigned __int64 *)&a1 + 1))) >> 64) >> 63) & 0xA);
      v5 = (__PAIR128__(v11, *((unsigned __int64 *)&a1 + 1))
          - (((__int64)((9 - __PAIR128__(v11, *((unsigned __int64 *)&a1 + 1))) >> 64) >> 63) & 0xA)) >> 64;
      *((_QWORD *)&a1 + 1) = v13;
      ++v9;
    }
    while ( v9 );
    if ( a2 )
      *a2 = v13;
    return v10 + 2 * v6;
  }
  else
  {
    if ( a2 )
      *a2 = (unsigned __int64)a1 % 0xA;
    return (unsigned __int64)a1 / 0xA;
  }
}

//----- (000000000043AA20) ----------------------------------------------------
void __fastcall sub_43AA20(__int64 a1, __int64 a2, __int64 a3, __m128 a4, __m128 a5)
{
  __int64 v5; // rbp
  _QWORD *v6; // r8
  void (__fastcall *v7)(__int64); // r9
  __int64 v8; // rdi
  __m128 v12; // [rsp-30h] [rbp-30h]
  __m128 v13; // [rsp-20h] [rbp-20h]
  _QWORD v14[2]; // [rsp-10h] [rbp-10h] BYREF

  if ( --qword_453CD0 < 0 )
    sub_401000(a1, a2, a3);
  v6 = (_QWORD *)(qword_453CE0 + 32 * qword_453CD0);
  v7 = (void (__fastcall *)(__int64))v6[1];
  v8 = v6[2];
  v14[1] = v6[3];
  v14[0] = v5;
  _RBP = (double *)v14;
  __asm { fstp    qword ptr [rbp-40h] }
  *(_RBP - 8) = _RT1;
  __asm { fstp    qword ptr [rbp-30h] }
  *(_RBP - 6) = _RT1;
  v12 = a4;
  v13 = a5;
  v7(v8);
  __asm
  {
    fld     qword ptr [rbp-30h]
    fld     qword ptr [rbp-40h]
  }
}
// 43AA55: inconsistent fpu stack
// 43AA20: could not find valid save-restore pair for rbp
// 43AA4B: variable 'v5' is possibly undefined
// 453CD0: using guessed type __int64 qword_453CD0;
// 453CE0: using guessed type __int64 qword_453CE0;

//----- (000000000043AAA0) ----------------------------------------------------
void __fastcall sub_43AAA0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     ds:qword_44E948[rcx*8] }
}
// 43AAAD: unbalanced stack, ignored a potential tail call

//----- (000000000043AAB4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_43AAB4(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX)
{
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  __int8 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx

  if ( _RDX >= 0x400 )
  {
    if ( _RDX > (unsigned __int64)&dword_400000 )
    {
      *_RDI = _mm_loadu_si128(_RSI);
      v7 = ((unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL) - (_QWORD)_RDI;
      v8 = (unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL;
      v9 = &_RSI->i8[v7];
      v10 = _RDX - v7;
      v11 = 16LL;
      do
      {
        v11 += 16LL;
        _mm_stream_si128((__m128i *)(v8 + v11 - 32), _mm_loadu_si128((const __m128i *)&v9[v11 - 32]));
      }
      while ( v10 > v11 );
      _mm_sfence();
      *(__m128i *)(v8 + v10 - 16) = _mm_loadu_si128((const __m128i *)&v9[v10 - 16]);
    }
    else
    {
      qmemcpy(_RDI, _RSI, _RDX);
    }
  }
  else
  {
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm
      {
        vmovdqu ymm3, ymmword ptr [rsi+rcx-40h]
        vmovdqu ymmword ptr [rdi+rcx-40h], ymm3
      }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 43AB39: positive sp value 8 has been found
// 400000: using guessed type int dword_400000;

//----- (000000000043ABC2) ----------------------------------------------------
void __fastcall sub_43ABC2(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = a3;
  if ( a1 >= a2 )
  {
    a1 = &a1[a3 - 1];
    a2 = &a2[a3 - 1];
  }
  while ( v3 )
  {
    *a1-- = *a2--;
    --v3;
  }
}

//----- (000000000043ABE2) ----------------------------------------------------
void __fastcall sub_43ABE2(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     qword ptr [rbx+rcx*8] }
}
// 43ABF9: unbalanced stack, ignored a potential tail call

//----- (000000000043ABFC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_43ABFC(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3)
{
  if ( _RDX >= 0x400 )
  {
    memset(_RDI, a2, _RDX);
  }
  else
  {
    __asm { vpbroadcastb ymm3, xmm3 }
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm { vmovdqu ymmword ptr [rdi+rcx-40h], ymm3 }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vxorps  ymm3, ymm3, ymm3
    }
  }
}
// 43AC63: positive sp value 10 has been found
// 43ABFC: could not find valid save-restore pair for rbx

//----- (000000000043ACAE) ----------------------------------------------------
__int64 __fastcall sub_43ACAE(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v9; // r12
  __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // r15
  void *retaddr; // [rsp+0h] [rbp+0h]

  *a1 = &a7;
  a1[1] = v7;
  a1[2] = v8;
  a1[3] = v9;
  a1[4] = v10;
  a1[5] = v11;
  a1[6] = v12;
  a1[7] = retaddr;
  return 0LL;
}
// 43ACB6: variable 'v7' is possibly undefined
// 43ACBA: variable 'v8' is possibly undefined
// 43ACBE: variable 'v9' is possibly undefined
// 43ACC2: variable 'v10' is possibly undefined
// 43ACC6: variable 'v11' is possibly undefined
// 43ACCA: variable 'v12' is possibly undefined

//----- (000000000043ACDD) ----------------------------------------------------
__int64 __fastcall sub_43ACDD(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rcx
  int v6; // er8
  int v7; // et0

  if ( a2 != a1 )
  {
    _RBX = &unk_44E640;
    v4 = -1LL;
    while ( a3 != ++v4 )
    {
      _EAX = *(unsigned __int8 *)(a2 + v4);
      __asm { xlat }
      v7 = _EAX;
      _EAX = *(unsigned __int8 *)(a1 + v4);
      v6 = v7;
      __asm { xlat }
      if ( (_BYTE)_EAX != (_BYTE)v7 || !(_BYTE)_EAX )
        return (unsigned int)(_EAX - v6);
    }
  }
  return 0LL;
}

//----- (000000000043AD27) ----------------------------------------------------
void sub_43AD27()
{
  JUMPOUT(0x43AD60LL);
}
// 43AD35: control flows out of bounds to 43AD60

//----- (000000000043AD3B) ----------------------------------------------------
void sub_43AD3B()
{
  JUMPOUT(0x43AD60LL);
}
// 43AD46: control flows out of bounds to 43AD60

//----- (000000000043AD57) ----------------------------------------------------
char *__fastcall sub_43AD57(__int64 a1, unsigned __int64 a2)
{
  bool v3; // cf
  bool v13; // zf
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i si128; // xmm4
  __m128i v18; // xmm4

  _RAX = (const __m128i *)(a1 - 1);
  while ( 1 )
  {
    _RAX = (const __m128i *)((char *)_RAX + 1);
    v3 = a2-- == 0;
    if ( v3 )
      return (char *)_RAX - a1;
    if ( ((unsigned __int8)_RAX & 0x1F) == 0 )
    {
      _XMM0 = _mm_cvtsi32_si128(0);
      _XMM1 = _XMM0;
      _RAX -= 2;
      if ( (byte_44E03C & 0x20) != 0 )
      {
        __asm
        {
          vpbroadcastb ymm0, xmm0
          vpbroadcastb ymm1, xmm1
        }
        while ( 1 )
        {
          _RAX += 2;
          v3 = a2 < 0x20;
          a2 -= 32LL;
          if ( v3 )
            break;
          __asm
          {
            vmovdqa ymm2, ymmword ptr [rax]
            vpcmpeqb ymm3, ymm2, ymm0
            vpcmpeqb ymm2, ymm2, ymm1
            vpor    ymm2, ymm2, ymm3
            vpmovmskb ecx, ymm2
          }
          v13 = !_BitScanForward((unsigned int *)&_RCX, _RCX);
          if ( !v13 )
          {
            __asm { vzeroupper }
            goto LABEL_13;
          }
        }
      }
      else
      {
        v15 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(_XMM0, _XMM0), 224), 0);
        v16 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_unpacklo_epi8(_XMM1, _XMM1), 224), 0);
        while ( 1 )
        {
          _RAX += 2;
          v3 = a2 < 0x20;
          a2 -= 32LL;
          if ( v3 )
            break;
          si128 = _mm_load_si128(_RAX + 1);
          LODWORD(_RCX) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(si128, v15), _mm_cmpeq_epi8(si128, v16)));
          v18 = _mm_load_si128(_RAX);
          v13 = !_BitScanForward(
                   (unsigned int *)&_RCX,
                   _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v18, v15), _mm_cmpeq_epi8(v18, v16))) | ((_DWORD)_RCX << 16));
          if ( !v13 )
          {
LABEL_13:
            _RAX = (const __m128i *)((char *)_RAX + _RCX);
            goto LABEL_4;
          }
        }
      }
      a2 += 32LL;
    }
LABEL_4:
    if ( !_RAX->i8[0] )
      return (char *)_RAX - a1;
  }
}
// 43ADDE: variable '_RCX' is possibly undefined
// 44E03C: using guessed type char byte_44E03C;

//----- (000000000043AE48) ----------------------------------------------------
__int64 __fastcall sub_43AE48(__int64 a1, __int64 a2)
{
  int v2; // eax
  int v3; // edx
  __int64 v4; // rcx

  v2 = 0;
  v3 = 0;
  v4 = 0LL;
  if ( a2 != a1 )
  {
    while ( 1 )
    {
      v2 = *(unsigned __int8 *)(a1 + v4);
      v3 = *(unsigned __int8 *)(a2 + v4);
      if ( !(_BYTE)v2 || (_BYTE)v2 != (_BYTE)v3 )
        break;
      ++v4;
    }
  }
  return (unsigned int)(v2 - v3);
}

//----- (000000000043AE6F) ----------------------------------------------------
__int64 __fastcall sub_43AE6F(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  for ( result = 0LL; (unsigned int)result < a2 && *(_WORD *)(a1 + 2 * result); result = (unsigned int)(result + 1) )
    ;
  return result;
}

//----- (000000000043AE81) ----------------------------------------------------
__int64 __fastcall sub_43AE81(__int64 a1, unsigned int a2)
{
  __int64 result; // rax

  for ( result = 0LL; (unsigned int)result < a2 && *(_DWORD *)(a1 + 4 * result); result = (unsigned int)(result + 1) )
    ;
  return result;
}

//----- (000000000043AE92) ----------------------------------------------------
__int64 __fastcall sub_43AE92(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r8
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 result; // rax

  if ( a1 != a2 && a3 )
  {
    v3 = (a3 >> 4) + 1;
    v4 = -16LL;
    do
    {
      v4 += 16LL;
      if ( !--v3 )
        goto LABEL_7;
      LODWORD(v5) = _mm_movemask_epi8(
                      _mm_cmpeq_epi8(
                        _mm_loadu_si128((const __m128i *)(a1 + v4)),
                        _mm_loadu_si128((const __m128i *)(a2 + v4))))
                  - 0xFFFF;
    }
    while ( !(_DWORD)v5 );
    _BitScanForward((unsigned int *)&v5, v5);
    v4 += v5;
LABEL_7:
    while ( a3 != v4 )
    {
      ++v4;
      result = *(unsigned __int8 *)(a1 + v4 - 1) - (unsigned int)*(unsigned __int8 *)(a2 + v4 - 1);
      if ( (_DWORD)result )
        return result;
    }
  }
  return 0LL;
}
// 43AED4: variable 'v5' is possibly undefined

//----- (000000000043AEF4) ----------------------------------------------------
__int64 __fastcall sub_43AEF4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  int v4; // ebx
  __int64 v5; // rcx

  result = 0LL;
  v4 = 0;
  v5 = 0LL;
  if ( a3 && a2 != a1 )
  {
    while ( (unsigned int)v5 < a3 )
    {
      LODWORD(result) = *(unsigned __int8 *)(a1 + v5);
      v4 = *(unsigned __int8 *)(a2 + v5);
      if ( !(_BYTE)result || (_BYTE)result != (_BYTE)v4 )
        break;
      v5 = (unsigned int)(v5 + 1);
    }
    return (unsigned int)(result - v4);
  }
  return result;
}

//----- (000000000043B001) ----------------------------------------------------
void __fastcall __noreturn sub_43B001(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rcx

  dword_4540B8 |= 4u;
  if ( (dword_44EB70 & 4) != 0 )
  {
    for ( i = (unsigned __int8)a1; ; qword_449040(a1, a2, a3, i) )
      ;
  }
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_43B032);
  __halt();
}
// 43B015: variable 'a3' is possibly undefined
// 43B015: variable 'i' is possibly undefined
// 449040: using guessed type __int64 (__fastcall *qword_449040)(_QWORD, _QWORD, _QWORD, _QWORD);
// 44EB70: using guessed type int dword_44EB70;
// 4540B8: using guessed type int dword_4540B8;

//----- (000000000043B03A) ----------------------------------------------------
__int64 __fastcall sub_43B03A(int a1, int a2)
{
  int v2; // edx

  if ( (a1 & 7) == 7 )
  {
    v2 = 64;
    if ( (a2 & 1) == 0 && qword_44EC48 != (qword_44EC48 & a2) )
      v2 = 128;
  }
  else if ( (a1 & 3) == 3 )
  {
    v2 = 4;
    if ( (a2 & 1) == 0 )
      v2 = 4 * (qword_44EC48 != (qword_44EC48 & a2)) + 4;
  }
  else
  {
    v2 = 32;
    if ( (a1 & 5) != 5 )
    {
      v2 = 16;
      if ( (a1 & 4) == 0 )
        v2 = (a1 & 1) + 1;
    }
  }
  return v2 | (a1 | a2) & 0xDD000000;
}
// 44EC48: using guessed type __int64 qword_44EC48;

//----- (000000000043B0C6) ----------------------------------------------------
__int64 sub_43B0C6()
{
  if ( (dword_44EB70 & 4) == 0 )
    return sub_40214C();
  dword_453D68 = sub_402E8A();
  return -1LL;
}
// 44EB70: using guessed type int dword_44EB70;
// 453D68: using guessed type int dword_453D68;

//----- (000000000043B0EA) ----------------------------------------------------
__int64 __fastcall sub_43B0EA(__int64 a1)
{
  return (*(__int64 (**)(void))(a1 + 56))();
}

// nfuncs=1260 queued=1208 decompiled=1208 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 1208 function(s)"
