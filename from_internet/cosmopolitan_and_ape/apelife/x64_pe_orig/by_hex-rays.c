/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_401000(__int64, unsigned __int64);
__int64 __fastcall sub_4010B0(__int64 *, __int64);
void __noreturn sub_401114();
__int64 sub_40116A();
void sub_4011F2();
__int64 __fastcall sub_4015B0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4015BA(__int64, double, __int64, __int64);
unsigned __int64 sub_401F80();
__int64 __fastcall sub_401FA0(__int64);
__int64 __fastcall sub_402080(__int64);
__int64 __fastcall sub_402090(__int64);
__int64 __fastcall sub_4020A0(__int64, __int64);
void sub_4020E0();
void sub_402140();
void __noreturn sub_4021BE();
void __fastcall __noreturn sub_4021C7(__int64, __int64);
__int64 __fastcall sub_402200();
__int64 sub_402220();
__int64 __fastcall sub_402240();
__int64 (__fastcall **__fastcall sub_40229E())();
unsigned __int64 __fastcall sub_4022D0(__int64, unsigned __int64);
unsigned __int64 __fastcall sub_402350(__int64);
__int64 __fastcall sub_4023B0(__int64, __int64);
__int64 __fastcall sub_402480(__int64, __int64);
void __fastcall sub_4024B0();
int __fastcall sub_4025F2(__int64, unsigned int);
__int64 __fastcall sub_402640(); // weak
__int64 __fastcall sub_4026E0();
void __fastcall sub_40276D();
char *__fastcall sub_4027C0(__int64, __int64);
__int64 __fastcall sub_40283C(int, __int64);
void __fastcall __noreturn sub_40286F(unsigned __int64, __int64, __int64, __int64);
BOOL (__stdcall **sub_40288A())(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
void __fastcall sub_4028C1(double, double, double, double);
void __noreturn sub_402973();
void __fastcall sub_4029AF(double, double, double, double);
__int64 sub_402A84();
__int64 sub_402AB8();
__int64 sub_402ACD();
__int64 sub_402AE2();
__int64 sub_402AF7();
__int64 sub_402B0C();
__int64 sub_402B21();
__int64 sub_402B36();
__int64 sub_402B4B();
__int64 sub_402B60();
__int64 sub_402B75();
__int64 sub_402B8A();
__int64 sub_402B9F();
__int64 sub_402BB4();
__int64 sub_402BC9();
BOOL __fastcall sub_402BDF(LPCWSTR lpNewItem, UINT_PTR uIDNewItem);
HDC __fastcall sub_402BEF();
__int64 __fastcall sub_402BFF(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); // weak
LRESULT __fastcall sub_402C0F(LPARAM, WPARAM);
LRESULT __fastcall sub_402C1F();
BOOL __fastcall sub_402C32();
int __fastcall sub_402C42(__int64, HBRUSH);
HCURSOR sub_402C52();
BOOL __fastcall sub_402C62(UINT, UINT);
HMENU __fastcall sub_402C72();
BOOL __fastcall sub_402C82();
HCURSOR __fastcall sub_402C92();
int __fastcall sub_402CA2(UINT, const WCHAR *);
void __fastcall sub_402CB2();
BOOL __fastcall sub_402CC5(UINT, HRGN);
ATOM __fastcall sub_402CD5();
BOOL sub_402CE8();
LRESULT __fastcall sub_402CF8(LPARAM, WPARAM);
HWND __fastcall sub_402D08();
HCURSOR __fastcall sub_402D1B();
BOOL __fastcall sub_402D2E();
BOOL __fastcall sub_402D3E();
BOOL __fastcall sub_402D4E();
void sub_402D61();
HBITMAP __fastcall sub_402D71(__int64, int);
HDC __fastcall sub_402D81();
BOOL __fastcall sub_402D94();
BOOL __fastcall sub_402DA7();
HGDIOBJ __fastcall sub_402DBA();
BOOL __fastcall sub_402DCA();
int __fastcall sub_402DE0(__int64, INT);
__int64 __fastcall sub_402F50(__int64, unsigned __int64);
__int64 __fastcall sub_402FE0(__int64, unsigned __int64);
__int64 sub_403070();
__int64 sub_403090();
unsigned __int64 __fastcall sub_403110(__int64, unsigned __int64);
int __fastcall sub_403180(__int64);
__int64 __fastcall sub_4031C0();
int sub_40339C();
int sub_4033AC();
int __fastcall sub_4033BC(__int64, INT);
void sub_4033CC();
void sub_4033DC();
int __fastcall sub_4033EC();
int __fastcall sub_4033FC();
__int64 __fastcall sub_403410(__int64);
__int64 __fastcall nullsub_1(_QWORD); // weak
__int64 __fastcall sub_403710(__int64, unsigned __int64);
__int64 __fastcall sub_403720(__int64, unsigned __int64);
__int64 __fastcall sub_403730();
__int64 __fastcall sub_403C50(LPSECURITY_ATTRIBUTES lpProcessAttributes, __int64, struct _SECURITY_ATTRIBUTES *, BOOL);
__int64 __fastcall sub_403D30();
__int64 sub_404000();
void __fastcall sub_404190();
BOOL sub_4042C0();
void __noreturn start();
LPVOID __fastcall sub_404670(__int64, __int64, int, __int64);
__int64 __fastcall sub_404760();
__int64 __fastcall sub_4047D0(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_404B30(__int64, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_404BE0(__int64, int);
__int64 __fastcall sub_404D00(__int64);
__int64 __fastcall sub_404D10(__int64);
void __fastcall HandlerRoutine(DWORD CtrlType, double, double, double);
__int64 __fastcall sub_404ED0();
__int64 __fastcall sub_404F60();
__int64 __fastcall sub_405040(__int64, __int64);
int __fastcall sub_4051D0();
void __fastcall sub_4053A0(__int64);
__int64 __fastcall sub_405500(__int64);
__int64 __fastcall sub_4056C0(__int64, __int64);
__int64 sub_405790();
__int64 __fastcall sub_4057D0(__int64);
__int64 __fastcall sub_405870(__int64, int);
__int64 __fastcall sub_405AC0(__int64, __int64);
__int64 __fastcall sub_405BC0();
__int64 __fastcall sub_405D40();
_OWORD *__fastcall sub_405E00();
unsigned __int64 sub_405E30();
__int64 sub_405E9F();
void sub_405EA5();
BOOL __fastcall sub_405EB5(__int64, HANDLE *);
void sub_405EC5();
void __fastcall sub_405ED5();
BOOL __fastcall sub_405EE5(__int64, HANDLE *);
BOOL __fastcall sub_405EF5();
void sub_405F08();
BOOL __fastcall sub_405F18(DWORD, struct _SECURITY_ATTRIBUTES *);
void sub_405F28();
BOOL __fastcall sub_405F38();
BOOL __fastcall sub_405F4B();
DWORD __fastcall sub_405F5B();
BOOL __fastcall sub_405F6E();
BOOL __fastcall sub_405F7E(DWORD, void *);
DWORD sub_405F8E();
HMODULE __fastcall sub_405F9E();
FARPROC __fastcall sub_405FB1();
void __fastcall sub_405FC1();
void sub_405FD4();
DWORD __fastcall sub_405FE4();
BOOL __fastcall sub_405FF4(DWORD *, DWORD);
DWORD __fastcall sub_406004(DWORD, BOOL);
void sub_406014();
void __fastcall sub_406024(double, double, double, double);
__int64 sub_4060A0();
__int64 sub_4064D0();
__int64 __fastcall sub_406570();
unsigned __int64 __fastcall sub_4065D0();
__int64 __fastcall sub_4066A0();
void __noreturn sub_406750();
__int64 __fastcall sub_4067C0();
__int64 sub_406860();
void __fastcall sub_4068A0(__int64);
__int64 sub_406950();
__int64 sub_406A10();
__int64 sub_406D30();
void __fastcall sub_406E60();
BOOL __fastcall sub_406FA0(__int64);
__int64 sub_407080();
__int64 sub_407100();
void __fastcall sub_407170(__int64, int);
LRESULT __fastcall sub_407200(LPARAM, WPARAM);
void __fastcall sub_407850(__int64);
__int64 __fastcall sub_4078F0(__int64);
void __fastcall sub_407FAA(double, double, double, double);
__int64 __fastcall sub_407FC0(__int64, _BYTE *, __int64, __int64);
int __fastcall sub_408230(__int64, __int64);
__int64 __fastcall sub_408250(__int64, __int64, __int64);
__int64 __fastcall sub_4082B0(__int64, __int64, __int64);
__int64 __fastcall sub_408A60(__int64, __int64, __int64);
__int64 __fastcall sub_409270(__int64, __int64, __int64, __int64);
unsigned __int8 *__fastcall sub_4097E0(__int64, __int8 *);
int __fastcall sub_409CE0();
bool sub_409D70();
void __fastcall __noreturn sub_409DA0(double, double, double, double);
__int64 __fastcall sub_409DB0();
void sub_40A090();
__int64 __fastcall sub_40A100(__int64, __int64);
char sub_40A3F0();
__int64 sub_40A470();
void sub_40A4D0();
void sub_40A4E0();
__int64 __fastcall sub_40A570(__int64, _BYTE *, char *);
__int64 __fastcall sub_40A580(__int64, _BYTE *, char *);
__int64 __fastcall sub_40A810();
__int64 __fastcall sub_40A890();
__int64 __fastcall sub_40A950(__int64);
__int64 __fastcall sub_40AA40();
__int64 __fastcall sub_40AA80();
__int64 __fastcall sub_40AAD0();
__int64 __fastcall sub_40AC60();
__int64 __fastcall sub_40AD00(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_40AD90();
void __fastcall sub_40ADE0(__int64);
__int64 __fastcall sub_40AE80(__int64, __int64, __int64);
__int64 __fastcall sub_40AEC0();
__int64 __fastcall sub_40AF80();
__int64 __fastcall sub_40AFA0(); // weak
void __fastcall sub_40B050(__int64);
void sub_40B0B0();
__int64 __fastcall sub_40B0C0(_QWORD *);
__int64 __fastcall sub_40B110();
__int64 __fastcall sub_40B4AE(__int64);
__int64 __fastcall sub_40B4F0(__int16, _QWORD *);
__int64 __fastcall sub_40B560(signed __int64, char *);
__int64 sub_40B6FB(void); // weak
__int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 sub_40B707(void); // weak
__int64 __fastcall sub_40B70D(_QWORD, _QWORD); // weak
__int64 sub_40B713(void); // weak
__int64 sub_40B720();
void sub_40B7A0();
__int64 __fastcall sub_40B7E0();
__int64 sub_40B8D0();
void __fastcall sub_40B8F0();
__int64 __fastcall sub_40B940();
__int64 __fastcall sub_40BD00();
__int64 __fastcall sub_40BD10();
unsigned __int64 __fastcall sub_40BEA0(__int64, unsigned __int64);
__int64 __fastcall sub_40C5F0();
void __fastcall sub_40DCD0();
__int64 __fastcall sub_40E4E0(); // weak
_QWORD *__fastcall sub_40E5C0(__int64);
_QWORD *__fastcall sub_40E5D0(__int64, unsigned __int64);
_QWORD *__fastcall sub_40EB10(__int64, unsigned __int64);
__int64 __fastcall sub_40ECB0();
unsigned __int64 __fastcall sub_40ED20();
__int64 sub_40ED3D();
__int64 __fastcall sub_40ED60(__int64);
__int64 __fastcall sub_40ED70(__int64, __int64);
__int64 __fastcall sub_40ED90(__int64);
__int64 __fastcall sub_40EDE0(__int64, __int64);
void __fastcall sub_40EE90(unsigned __int64 _RCX, __int64, __int64, __int64);
__int64 __fastcall sub_40EF50(__int64, __int64);
unsigned __int64 __fastcall sub_40EFB0(__int64, unsigned int);
char *sub_40F050();
__int64 (*__fastcall sub_40F140())(void);
__int64 __fastcall sub_40F180(__int64, unsigned __int64);
__int64 __fastcall sub_40F2D0();
__int64 sub_40F340();
__int64 __fastcall sub_40F370(unsigned int, unsigned int, int, __int64);
__int64 sub_40F550();
__int64 __fastcall sub_40F560();
__int64 __fastcall sub_40F5E0(__int64);
__int64 __fastcall sub_40F750(); // weak
__int64 __fastcall sub_40F830();
void __fastcall __noreturn sub_40F84E(__int64, __int64, __int64, __int64);
__int64 (*__fastcall sub_40F867(__int64, __int64, __int64, __int64))(void);
LPVOID __fastcall sub_40F880(__int64, __int64, int, __int64);
__int64 __fastcall sub_40F8B0();
__int64 __fastcall sub_40F900(__int64, unsigned int);
void __fastcall sub_40F960(__int64, int);
__int64 __fastcall sub_40F9A0(__int64, int);
__int64 __fastcall sub_40FBB0(__int64, int, int);
BOOL __fastcall sub_40FD50(__int64 a1, int a2);
__int64 __fastcall sub_40FDD0(__int64);
__int64 __fastcall sub_40FE50(__int64, unsigned __int64 *);
_QWORD *__fastcall sub_40FEF0(__int64, __int64 *);
bool __fastcall sub_40FFA0();
bool __fastcall sub_40FFC0();
__int64 __fastcall sub_40FFE0(__int64, __int64);
__int64 __fastcall sub_410010(__int64, unsigned __int16);
__int64 __fastcall sub_410050(__int64, unsigned int);
void __fastcall sub_410090(__int64, __int64);
__int64 __fastcall sub_4100AE(__int64, __int64);
__int64 __fastcall sub_4100BB(__int64, __int64);
__int64 __fastcall sub_4100E0(__int64);
__int64 __fastcall sub_410160(__int64, __int64);
__int64 __fastcall sub_410260();
__int64 __fastcall sub_4102A0(unsigned __int64);
__int64 __fastcall sub_410390();
bool __fastcall sub_410560(__int64);
__int64 __fastcall sub_410600();
__int64 sub_410650();
__int64 __fastcall sub_4106F0();
__int64 __fastcall sub_410830(__int64);
__int64 __fastcall sub_41088F(__int64);
_BYTE *__fastcall sub_4108B0();
__int64 sub_410930();
__int64 __fastcall sub_410960(__int64);
__int64 __fastcall sub_410A20(__int64);
__int64 __fastcall sub_410A90(__int64, __int64);
int __fastcall sub_410AE0(__int64);
__int64 __fastcall sub_410B10();
bool __fastcall sub_410C20(__int64);
bool __fastcall sub_410C50();
unsigned __int64 __fastcall sub_410C80(__int64, __int64);
void __fastcall sub_410D60(__int64, __int64);
void __fastcall sub_410DB0(__int64, __int64);
void __fastcall sub_410E10(__int64, __int64);
__int64 __fastcall sub_410E90(__int64, unsigned int);
__int64 __fastcall sub_410F70(__int64);
__int64 __fastcall sub_410F90(__int64, unsigned __int64);
__int64 __fastcall sub_411370(__int64, __int64);
char __fastcall sub_411440();
__int64 __fastcall sub_411490(__int64, __int64);
__int64 __fastcall sub_4114B0(__int64, __int64);
__int64 __fastcall sub_4114C0(__int64, __int64);
__int64 __fastcall sub_4117E0(__int64);
void __fastcall sub_411870(__int64);
void __fastcall sub_411930(__int64);
__int64 __fastcall sub_4119F0(__int64, __int64);
__int64 __fastcall sub_411A10(__int64);
__int64 __fastcall sub_411A30(__int64, __int64);
void __fastcall __noreturn sub_411B00(__int64, __int64, __int64);
__int64 __fastcall sub_411D3D();
void __fastcall sub_411D70(__int64, __int64);
__int64 sub_411DA0();
__int64 __fastcall sub_411E40(__int64, __int64);
bool __fastcall sub_411E70();
__int64 __fastcall sub_411EA0(__int64, __int64);
__int64 __fastcall sub_411EE0(__int64, int);
__int64 __fastcall sub_411FA0(__int64, int);
__int64 __fastcall sub_412010(__int64, __int64);
__int64 sub_4120D0();
__int64 __fastcall sub_412114(__int64);
__int64 sub_412150();
__int64 __fastcall sub_4121B0();
__int64 __fastcall sub_4121E0();
__int64 __fastcall sub_412210();
__int64 __fastcall sub_4122D0(__int64, __int64);
__int64 __fastcall sub_4122E0(__int64, __int64);
__int64 __fastcall sub_4122F0(__int64, __int64);
__int64 __fastcall sub_412300(__int64, __int64);
__int64 __fastcall sub_412310(__int64, __int64);
__int64 __fastcall sub_412320(__int64, __int64);
__int64 __fastcall sub_412330(__int64, __int64);
__int64 __fastcall sub_412340(__int64, __int64);
__int64 __fastcall sub_412350(__int64, __int64);
__int64 __fastcall sub_412360(__int64, __int64);
__int64 __fastcall sub_412370(__int64, __int64);
__int64 __fastcall sub_412380(__int64, __int64);
__int64 __fastcall sub_412390(__int64, __int64);
__int64 __fastcall sub_4123B0(__int64, __int64);
__int64 __fastcall sub_4123D0(__int64, __int64);
__int64 __fastcall sub_4123E0(__int64, __int64);
__int64 __fastcall sub_412400(__int64, __int64);
__int64 __fastcall sub_412410(__int64, __int64);
__int64 __fastcall sub_412420(__int64, __int64);
__int64 __fastcall sub_412440(__int64, __int64);
__int64 __fastcall sub_412450(__int64);
unsigned __int64 __fastcall sub_4124A0();
unsigned __int64 __fastcall sub_4124E0();
__int64 __fastcall sub_412530(__int64, int);
unsigned __int64 __fastcall sub_412580();
unsigned __int64 __fastcall sub_412600();
__int64 __fastcall sub_412630(__int64);
__int64 __fastcall sub_412660(__int64, int, char);
__int64 __fastcall sub_412C10(__int64, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_4130C0(unsigned __int8, __int64, unsigned int);
__int64 __fastcall sub_413260(__int64, char *, __int64);
__int64 __fastcall sub_413AC0(__int64, char *, __int64, __int64);
__int64 __fastcall sub_413B40(__int64, __int64);
__int64 __fastcall sub_413BA0(); // weak
__int64 __fastcall sub_413BB0(__int64, int);
__int64 __fastcall sub_413C40(__int64, int);
__int64 __fastcall sub_413CC0(__int64, const char *, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_4142F0(__int64, int);
__int64 __fastcall sub_4145A0(__int64, int);
__int64 __fastcall sub_414600(__int64, char *, __int64);
unsigned __int64 __fastcall sub_414650(unsigned __int64, unsigned __int64, __int64);
void sub_414795();
__int64 __fastcall sub_4147B4();
unsigned __int64 __fastcall sub_4147EA();
void __fastcall sub_414825();
__int64 __fastcall sub_414845();
__int64 sub_414880();
__int64 __fastcall sub_4148D0();
void __fastcall sub_4148F0(unsigned __int64);
__int64 __fastcall sub_414960(__int64, unsigned __int64);
__int64 __fastcall sub_4149F0(char, unsigned int);
char *__fastcall sub_414AB0();
__int64 __fastcall sub_414B60();
__int64 __fastcall sub_414BA0();
__int64 __fastcall sub_414C00(__int64, __int64);
void __fastcall sub_414C50();
__int64 __fastcall sub_414CB0();
void __fastcall sub_414CF0();
__int64 __fastcall sub_414D40();
unsigned __int64 __fastcall sub_414E40(__int64, const __m128i *);
unsigned __int64 __fastcall sub_414FC0(__int64, __int64);
__int64 __fastcall sub_415200(unsigned __int64, const __m128i *);
__int64 __fastcall sub_415240(__int64, char *);
__int64 __fastcall sub_4153F4();
__int64 sub_415409(void); // weak
__int64 sub_415469();
__int64 sub_41547A();
__int64 __fastcall sub_41548B();
void __fastcall sub_4154C0(__int64, unsigned __int64);
void __fastcall sub_4154D7(__int64, unsigned __int64 _RDX);
void __fastcall sub_4155FC(__int64, __int64);
void __fastcall sub_41561F(__int64, unsigned __int64);
void __fastcall sub_41563C(__int64 a1, unsigned __int64 _RDX, __int64 a3, double _XMM3_8);
__int64 __fastcall sub_4156EF(); // weak
char *__fastcall sub_41571A();
void sub_415760();
void sub_41576B();
void sub_415783();
__int64 __fastcall sub_415794(); // weak
char *__fastcall sub_4157A4();
__int64 __fastcall sub_415898(char, __int64);
__int64 __fastcall sub_4158B1();
__int64 __fastcall sub_4158C8();
void __fastcall __noreturn sub_416001();
void __fastcall sub_416040(double, double, double, double);
void __fastcall sub_4160C0(double, double, double, double);
void __fastcall sub_416150(double, double, double, double);
__int64 __fastcall sub_416180();
__int64 __fastcall sub_416220();
__int64 sub_4162A0();
__int64 sub_4162B0();
void sub_4162C8();
__int64 __fastcall sub_416315();
void __fastcall sub_41633B(double, double, double, double);

//-------------------------------------------------------------------------
// Data declarations

char byte_416000 = '\x90'; // weak
char byte_416033[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char asc_417230 = '%'; // weak
const WCHAR off_417744 = 38u; // idb
__int128 xmmword_418700 = 0x100010001000100010001000100010i64; // weak
__int128 xmmword_418710 = 0xFF00FF00FF00FF00FF00FF00FF00FFi64; // weak
const DWORD dwDesiredAccess = 4u; // idb
int dword_418810[] = { 2 }; // weak
char aDevTty[9] = "/dev/tty"; // weak
const struct _SECURITY_ATTRIBUTES ProcessAttributes = { 24u, NULL, 1 }; // idb
char byte_41898B[] = { '0' }; // weak
char asc_4189D1[2] = "?"; // weak
__int128 xmmword_418A20 = 0x7F007F007F007F007F007F007F007Fi64; // weak
__int64 (__fastcall *off_41B008[6])() = { &sub_401F80, &sub_402080, &sub_402090, &sub_4020A0, &sub_4020E0, &sub_402640 }; // weak
_UNKNOWN unk_41B038; // weak
// extern BOOL (__stdcall *AccessCheck)(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
// extern BOOL (__stdcall *DuplicateToken)(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// extern void (__stdcall *MapGenericMask)(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *GetOpenFileNameW)(LPOPENFILENAMEW);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern COLORREF (__stdcall *SetPixel)(HDC hdc, int x, int y, COLORREF color);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateFileMappingNumaW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred);
// extern BOOL (__stdcall *CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *FlushConsoleInputBuffer)(HANDLE hConsoleInput);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *FreeEnvironmentStringsW)(LPWCH penv);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *GetConsoleScreenBufferInfoEx)(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern LPWCH (__stdcall *GetEnvironmentStringsW)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// extern BOOL (__stdcall *GetFileInformationByHandleEx)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern DWORD (__stdcall *GetLastError)();
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *GetProcessTimes)(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern LPVOID (__stdcall *MapViewOfFileExNuma)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetConsoleCP)(UINT wCodePageID);
// extern BOOL (__stdcall *SetConsoleMode)(HANDLE hConsoleHandle, DWORD dwMode);
// extern BOOL (__stdcall *SetConsoleOutputCP)(UINT wCodePageID);
// extern BOOL (__stdcall *SetDefaultDllDirectories)(DWORD DirectoryFlags);
// extern DWORD (__stdcall *SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *AppendMenuW)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// extern HDC (__stdcall *BeginPaint)(HWND hWnd, LPPAINTSTRUCT lpPaint);
// extern LRESULT (__stdcall *DefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LRESULT (__stdcall *DispatchMessageW)(const MSG *lpMsg);
// extern BOOL (__stdcall *EndPaint)(HWND hWnd, const PAINTSTRUCT *lpPaint);
// extern int (__stdcall *FillRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern HCURSOR (__stdcall *GetCursor)();
// extern BOOL (__stdcall *GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern HMENU (__stdcall *GetSystemMenu)(HWND hWnd, BOOL bRevert);
// extern BOOL (__stdcall *GetWindowPlacement)(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
// extern HCURSOR (__stdcall *LoadCursorW)(HINSTANCE hInstance, LPCWSTR lpCursorName);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern BOOL (__stdcall *RedrawWindow)(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// extern ATOM (__stdcall *RegisterClassW)(const WNDCLASSW *lpWndClass);
// extern BOOL (__stdcall *ReleaseCapture)();
// extern LRESULT (__stdcall *SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *SetCapture)(HWND hWnd);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *WSAPoll)(LPWSAPOLLFD fdArray, ULONG fds, INT timeout);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *closesocket)(SOCKET s);
__int64 qword_41C000; // weak
int dword_41C00C; // weak
int dword_41C014; // weak
_UNKNOWN unk_41C020; // weak
char byte_41C023; // weak
char byte_41C03C; // weak
char byte_41C03D; // weak
__int64 qword_41C088; // weak
__int64 (*qword_41C098)(void); // weak
__int64 (__fastcall *qword_41C0A0)(_QWORD, _QWORD); // weak
__int64 (*qword_41C0A8)(void); // weak
__int64 qword_41C378; // weak
char byte_41C380[256]; // weak
__int64 qword_41C710; // weak
int dword_41C718; // weak
__int64 (__fastcall *qword_41C720)(_QWORD, _QWORD); // weak
char byte_41C728[114752]; // weak
char byte_438768[32776]; // weak
__int64 qword_440770; // weak
__int64 qword_440788; // weak
__int64 qword_440790; // weak
int dword_4407A8; // weak
int dword_4407B0; // weak
int dword_4407B8; // weak
int dword_4407C0; // weak
int dword_4407C8; // weak
int dword_4407D0; // weak
int dword_4407D8; // weak
int dword_4407E0; // weak
int dword_4407E8; // weak
int dword_4407F0; // weak
int dword_4407F8; // weak
int dword_440800; // weak
int dword_440808; // weak
int dword_440810; // weak
__int64 qword_440818; // weak
int dword_440820; // weak
int dword_440828; // weak
int dword_440830; // weak
int dword_440838; // weak
int dword_440840; // weak
int dword_440848; // weak
int dword_440850; // weak
int dword_440858; // weak
__int64 qword_440860; // weak
int dword_440868; // weak
int dword_440870; // weak
__int64 qword_440878; // weak
int dword_440880; // weak
int dword_440888; // weak
int dword_440890; // weak
int dword_440898; // weak
int dword_4408A0; // weak
int dword_4408A8; // weak
__int64 qword_4408C8; // weak
int dword_4408D0; // weak
__int64 qword_4408F0; // weak
int dword_440900; // weak
__int64 qword_440908; // weak
__int64 qword_440910; // weak
int dword_440918; // weak
__int64 qword_440920; // weak
__int64 qword_440928; // weak
__int64 qword_440930; // weak
__int64 qword_440938; // weak
__int64 qword_440940; // weak
__int64 qword_440948; // weak
__int64 qword_440950; // weak
__int64 qword_440958; // weak
__int16 word_440960; // weak
__int16 word_440968; // weak
__int16 word_440970; // weak
__int16 word_440978; // weak
__int64 qword_440980; // weak
__int64 qword_440988; // weak
int dword_440990; // weak
int dword_440998; // weak
__int64 qword_4409A0; // weak
__int64 qword_4409A8; // weak
__int64 qword_4409B0; // weak
__int64 qword_4409B8; // weak
int dword_4409C0; // weak
int dword_4409C8; // weak
__int64 qword_4409D0; // weak
__int64 qword_4409E8; // weak
__int64 qword_440A00; // weak
__int64 qword_440A08; // weak
__int64 qword_446038; // weak
_TBYTE tbyte_446040; // weak
_UNKNOWN unk_446260; // weak
__int64 qword_446360; // weak
_UNKNOWN unk_4463A0; // weak
int dword_4463E0; // weak
int dword_4463E4; // weak
__int64 qword_4463E8; // weak
__int64 qword_4463F0; // weak
__int64 qword_446400; // weak
__int64 qword_446408; // weak
__int64 qword_446410; // weak
__int64 qword_446418; // weak
__int64 qword_446420; // weak
__int64 qword_446428; // weak
__int64 qword_446430; // weak
__int64 qword_446438; // weak
__int64 qword_446440; // weak
__int64 qword_446448; // weak
__int64 qword_446450; // weak
__int64 qword_446458; // weak
__int64 qword_446460; // weak
__int64 qword_446468; // weak
__int64 qword_446470; // weak
__int64 qword_446478; // weak
__int64 qword_446480; // weak
__int64 qword_446488; // weak
int dword_446490; // weak
int dword_446494; // weak
int dword_446498; // weak
int dword_44649C; // weak
char byte_4464A0; // weak
char byte_4464A1; // weak
char byte_4464A2; // weak
char byte_4464A3; // weak
char byte_4464A4; // weak
char byte_4464A5; // weak
__int16 word_4464C0; // weak
__int64 qword_446660; // weak
__int64 qword_446668; // weak
__int64 qword_446670; // weak
__int64 qword_4466C0; // weak
__int64 qword_4466C8; // weak
__int64 qword_4466D0; // weak
__int64 qword_4466D8; // weak
__int64 qword_4466E0; // weak
int dword_4466E8; // weak
__int64 qword_446700[]; // weak
__int64 qword_446708[]; // weak
__int64 qword_446710; // weak
__int64 qword_446718; // weak
__int64 qword_446720; // weak
__int64 qword_446728; // weak
__int64 qword_446730; // weak
__int64 qword_446738; // weak
__int64 qword_446740; // weak
_UNKNOWN unk_446748; // weak
_QWORD qword_446758[62]; // weak
_UNKNOWN unk_446948; // weak
__int64 qword_446958[31]; // weak
__int64 qword_446A50; // weak
__int64 qword_446A58; // weak
__int64 qword_446A60; // weak
__int64 qword_446A68; // weak
int dword_446A70; // weak
__int128 xmmword_446A78; // weak
__int128 xmmword_446A88; // weak
__int64 qword_446AC0; // weak
_UNKNOWN unk_446AC8; // weak
char byte_446DE0; // weak
int dword_446EE0; // weak
int dword_446EE8[]; // weak
int dword_446EEC[]; // weak
__int64 qword_446EF0; // weak
int dword_446EF8; // weak
int dword_446EFC; // weak
UINT wCodePageID; // idb
DWORD Mode; // idb
HANDLE hConsoleHandle; // idb
UINT dword_447B18; // idb
DWORD dword_447B1C; // idb
HANDLE qword_447B20; // idb
__int64 qword_447B40; // weak
__int64 qword_447B48; // weak
__int64 qword_447B50; // weak
struct _SYSTEM_INFO SystemInfo; // idb
char byte_447D20; // weak
__int64 qword_447D28; // weak
_TBYTE tbyte_447D30; // weak
_TBYTE tbyte_447D40; // weak
int dword_447D60[128]; // weak
struct _STARTUPINFOW StartupInfo; // idb
_UNKNOWN unk_447FC8; // weak
__int64 qword_447FD0; // weak
__int64 qword_447FD8; // weak
int dword_447FE0; // weak
int dword_447FE4; // weak
int dword_447FE8; // weak
int dword_447FEC; // weak
__int64 qword_447FF0; // weak
__int64 qword_447FF8; // weak
__int64 qword_448000; // weak
char byte_448008; // weak
__int64 qword_448010; // weak
__int64 qword_448018; // weak
int dword_448020; // weak
char byte_448024; // weak
char byte_448025; // weak
char byte_448026; // weak
char byte_448027; // weak


//----- (0000000000401000) ----------------------------------------------------
void __fastcall sub_401000(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  unsigned __int64 v5; // rbx
  _QWORD *v6; // r8
  unsigned __int64 v7; // rax

  if ( v3 < a2 )
  {
    v5 = v3;
    do
    {
      v6 = (_QWORD *)sub_4010B0((__int64 *)0x3220, 454656i64);
      v7 = v5 + 0x4000;
      v5 += 4096i64;
      *v6 = v2 | v7;
    }
    while ( a2 > v5 );
  }
}
// 401003: variable 'v3' is possibly undefined
// 40104C: variable 'v2' is possibly undefined

//----- (00000000004010B0) ----------------------------------------------------
__int64 __fastcall sub_4010B0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  int v3; // esi
  __int64 v5; // rax
  int v6; // ecx
  int v7; // esi
  __int64 *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rax

  v5 = (v2 >> 39) & 0x1FF;
  if ( v3 )
  {
    v6 = 30;
    v7 = -9 * v3 + 30;
    do
    {
      v8 = (__int64 *)(a2 + 8 * v5);
      v9 = *v8;
      if ( !*v8 )
      {
        v10 = *a1 - 4096;
        *a1 = v10;
        v9 = v10 | 3;
        *v8 = v9;
      }
      a2 = v9 & 0x3FFFFFFFFF000i64;
      v11 = v2 >> v6;
      v6 -= 9;
      v5 = v11 & 0x1FF;
    }
    while ( v7 != v6 );
  }
  return a2 + 8 * v5;
}
// 4010B6: variable 'v2' is possibly undefined
// 4010C1: variable 'v3' is possibly undefined

//----- (0000000000401114) ----------------------------------------------------
void __noreturn sub_401114()
{
  if ( (dword_41C718 & 4) == 0 )
  {
    __asm
    {
      syscall; Low latency system call
      syscall; Low latency system call
      syscall; Low latency system call
    }
  }
  sub_416001();
}
// 41C718: using guessed type int dword_41C718;

//----- (000000000040116A) ----------------------------------------------------
__int64 sub_40116A()
{
  return 0i64;
}

//----- (00000000004011F2) ----------------------------------------------------
void sub_4011F2()
{
  __int64 *i; // rdi
  _DWORD *v6; // rdi

  qword_41C000 = __rdtsc();
  i = &qword_41C000 + 1;
  dword_447FEC = 1;
  dword_447FE8 = 1;
  LODWORD(qword_447FD0) = (_DWORD)&unk_447FC8;
  _RAX = 0i64;
  while ( 1 )
  {
    __asm { cpuid }
    *(_DWORD *)i = _RAX;
    v6 = (_DWORD *)i + 1;
    *v6++ = _RBX;
    *v6++ = _RCX;
    *v6 = _RDX;
    for ( i = (__int64 *)(v6 + 1); ; i += 2 )
    {
      _RAX = 1i64;
      if ( *((_BYTE *)&qword_41C000 + 8) )
        break;
    }
  }
}
// 401483: ignored the value written to the shadow area of the succeeding call
// 40156C: ignored the value written to the shadow area of the succeeding call
// 401582: ignored the value written to the shadow area of the succeeding call
// 401599: ignored the value written to the shadow area of the succeeding call
// 401598: ignored the value written to the shadow area of the succeeding call
// 4011F2: could not find valid save-restore pair for rbx
// 4011F2: could not find valid save-restore pair for rdi
// 4011F2: could not find valid save-restore pair for rsi
// 401496: ignored the value written to the shadow area of the succeeding call
// 401246: conditional instruction was optimized away because %0x20.4==1
// 41C000: using guessed type __int64 qword_41C000;
// 41C023: using guessed type char byte_41C023;
// 41C03C: using guessed type char byte_41C03C;
// 440938: using guessed type __int64 qword_440938;
// 440958: using guessed type __int64 qword_440958;
// 442038: using guessed type __int64 qword_442038;
// 444038: using guessed type __int64 qword_444038;
// 446038: using guessed type __int64 qword_446038;
// 447FD0: using guessed type __int64 qword_447FD0;
// 447FE8: using guessed type int dword_447FE8;
// 447FEC: using guessed type int dword_447FEC;
// 448018: using guessed type __int64 qword_448018;

//----- (00000000004015BA) ----------------------------------------------------
__int64 __fastcall sub_4015BA(__int64 a1, double a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  int v5; // edi
  __int64 v6; // rsi
  double v7; // st7
  double v8; // xmm0_8
  double v9; // xmm2_8
  double v10; // xmm3_8
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rcx
  unsigned int v15; // er12
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rax
  int v20; // edx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rcx
  unsigned int *v25; // rdi
  unsigned int *v26; // rdi
  __int64 i; // rcx
  char v28; // si
  unsigned __int64 v29; // rcx
  __int64 v30; // rcx
  __int64 v31; // rdx
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v35; // r15
  __int64 v36; // r14
  int v37; // er14
  __int64 v38; // rax
  int v39; // er15
  __int64 v40; // rax
  __int64 v41; // [rsp+0h] [rbp-D0h]
  double v42; // [rsp+10h] [rbp-C0h]
  int v43; // [rsp+10h] [rbp-C0h]
  _BYTE *v44; // [rsp+20h] [rbp-B0h]
  __int128 v45; // [rsp+50h] [rbp-80h] BYREF
  __int128 v46; // [rsp+60h] [rbp-70h]
  HCURSOR v47; // [rsp+78h] [rbp-58h]
  __int64 v48; // [rsp+80h] [rbp-50h]
  wchar_t *v49; // [rsp+90h] [rbp-40h]

  qword_446360 = v4;
  dword_44649C = 1;
  qword_446438 = 1i64;
  qword_446468 = 80i64;
  qword_446460 = 80i64;
  qword_446478 = 24i64;
  qword_446458 = 24i64;
  qword_446450 = 4096i64;
  qword_446448 = 4096i64;
  while ( 1 )
  {
    v11 = sub_407FC0(a1, "?hNWzw:h:", a3, a4);
    if ( v11 == -1 )
      break;
    if ( v11 == 104 )
    {
      v12 = sub_4145A0(a1, 0);
      if ( v12 < 8 )
        v12 = 8i64;
      qword_446450 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8ui64;
    }
    else if ( v11 > 104 )
    {
      if ( v11 == 119 )
      {
        v13 = sub_4145A0(a1, 0);
        if ( v13 < 8 )
          v13 = 8i64;
        qword_446448 = (v13 + 7) & 0xFFFFFFFFFFFFFFF8ui64;
      }
      else
      {
        if ( v11 != 122 )
          goto LABEL_92;
        ++qword_446440;
      }
    }
    else
    {
      switch ( v11 )
      {
        case 'N':
          byte_4464A3 = 1;
          break;
        case 'W':
          byte_4464A4 = 1;
          break;
        case '?':
          sub_406750();
        default:
LABEL_92:
          sub_406750();
      }
    }
  }
  if ( qword_446408 )
  {
    sub_40F560();
    sub_40F560();
  }
  qword_446408 = sub_4067C0();
  qword_446400 = sub_4067C0();
  if ( dword_447FE8 < v5 && (unsigned int)sub_406A10() == -1 )
  {
    v15 = 1;
    sub_40AD00(
      (unsigned int)(dword_446498 + 1),
      *(_QWORD *)(v6 + 8i64 * dword_447FE8),
      (unsigned int)dword_446494,
      (__int64)"error: failed to load game of life run length encoded (rle) file");
    return v15;
  }
  v15 = dword_41C718 & 4;
  if ( (dword_41C718 & 4) == 0 )
  {
    sub_407100();
    sub_4064D0();
    sub_410A20(v16);
    sub_41571A();
    sub_411A10(v17);
    sub_4154C0(v18, 0x38ui64);
    *((_BYTE *)&v46 + v19) = 1;
    v20 = qword_4409A8 | qword_4409B0 | qword_4409A0;
    *((_BYTE *)&v46 + qword_440A00) = 1;
    HIDWORD(v45) &= ~(v20 | 8);
    DWORD2(v45) = dword_440990 | DWORD2(v45) & ~(dword_440998 | qword_4409D0);
    LODWORD(v45) = dword_4409C0 | v45 & ~(dword_4409C8 | 0x1F8);
    sub_410A90(v21, (__int64)&v45);
    byte_4464A2 = 1;
    sub_41571A();
    sub_411A10(v22);
    sub_40ED60(v23);
    v24 = 10i64;
    v25 = (unsigned int *)&v45 + 2;
    while ( v24 )
    {
      *v25++ = v15;
      --v24;
    }
    *(_QWORD *)&v45 = 4220720i64;
    sub_4114C0(0i64, 0i64);
    v26 = (unsigned int *)&v45 + 2;
    for ( i = 10i64; i; --i )
      *v26++ = v15;
    *(_QWORD *)&v45 = 4220736i64;
    sub_4114C0(0i64, 0i64);
    v28 = dword_446490;
    sub_41571A();
    sub_41571A();
    while ( 1 )
    {
      if ( (v28 & 2) != 0 )
      {
        sub_407100();
        dword_446490 &= ~2u;
        sub_4078F0(v30);
        goto LABEL_32;
      }
      if ( !byte_4464A1 )
        goto LABEL_41;
      qword_41C098();
      if ( v7 > *(double *)&tbyte_446040 )
      {
        LODWORD(v45) = 0;
        DWORD1(v45) = (unsigned __int16)word_440968;
        sub_408230(v29, 0i64);
        if ( ((unsigned __int16)(word_440960 | word_440968) & WORD3(v45)) == 0 )
          break;
      }
LABEL_32:
      v45 = 0i64;
      v46 = 0i64;
      if ( sub_410F90(v29, 0x20ui64) == -1 )
      {
        if ( dword_448020 != qword_440818 )
LABEL_69:
          sub_40286F(v29, v31, v32, v33);
        goto LABEL_35;
      }
      if ( (char)v45 > 32 )
      {
        switch ( (char)v45 )
        {
          case 'M':
            byte_4464A2 = byte_4464A2 == 0;
            sub_411A10(v29);
            goto LABEL_35;
          case 'R':
            sub_41561F(v29, (qword_446448 * qword_446450) >> 3);
            goto LABEL_35;
          case 'j':
          case 'k':
            goto LABEL_88;
          case 'q':
            goto LABEL_69;
          case 's':
LABEL_60:
            v35 = qword_446438;
            v36 = 0i64;
            if ( qword_446438 > 0 )
            {
              do
              {
                sub_4060A0();
                ++v36;
              }
              while ( v36 != v35 );
            }
            goto LABEL_35;
          default:
            goto LABEL_35;
        }
      }
      if ( (char)v45 > 8 )
      {
        switch ( (char)v45 )
        {
          case 9:
          case 32:
            goto LABEL_60;
          case 14:
          case 16:
          case 22:
            goto LABEL_88;
          case 20:
            ++qword_446438;
            break;
          case 27:
            switch ( BYTE1(v45) )
            {
              case 't':
                v40 = qword_446438 - 1;
                if ( qword_446438 - 1 <= 0 )
                  v40 = 1i64;
                qword_446438 = v40;
                goto LABEL_35;
              case 'v':
LABEL_88:
                sub_406570();
                break;
              case '[':
                switch ( BYTE2(v45) )
                {
                  case '5':
                    if ( BYTE3(v45) == 126 )
                      goto LABEL_88;
                    goto LABEL_35;
                  case '6':
                    if ( BYTE3(v45) == 126 )
                      goto LABEL_88;
                    goto LABEL_35;
                  case '<':
                    v44 = (char *)&v45 + 3;
                    v37 = sub_4145A0(v29, 10);
                    if ( BYTE3(v45) == 59 )
                      v44 = (char *)&v45 + 4;
                    sub_4145A0(qword_446458, 10);
                    if ( *v44 == 59 )
                      ++v44;
                    v38 = sub_4145A0(qword_446460, 10);
                    v29 = v41;
                    if ( v38 <= 0 )
                      v38 = 1i64;
                    if ( v38 > v41 )
                      LODWORD(v38) = v41;
                    v39 = v37 | (4 * (*v44 == 109));
                    if ( v39 > 34 )
                    {
                      if ( v39 == 80 )
                      {
                        if ( !byte_4464A3 )
                          goto LABEL_97;
                      }
                      else
                      {
                        if ( v39 <= 80 )
                        {
                          if ( v39 == 64 || v39 == 65 )
                          {
                            sub_406570();
                            sub_406570();
                            goto LABEL_88;
                          }
                          goto LABEL_35;
                        }
                        if ( v39 != 81 )
                          goto LABEL_35;
                        if ( byte_4464A3 )
                        {
LABEL_97:
                          sub_407170(v41, -1);
                          goto LABEL_35;
                        }
                      }
                      sub_407170(v41, 1);
                    }
                    else if ( v39 >= 0 )
                    {
                      switch ( v39 )
                      {
                        case 0:
                          sub_4065D0();
                          break;
                        case 2:
                          byte_4464A1 = 1;
                          qword_446430 = (int)v38 - 1;
                          qword_446428 = v43;
                          qword_446420 = qword_446480;
                          qword_446418 = qword_446470;
                          break;
                        case 4:
                        case 6:
                          byte_4464A1 = 0;
                          break;
                        case 32:
                          sub_406E60();
                          break;
                        case 34:
                          sub_4066A0();
                          break;
                        default:
                          goto LABEL_35;
                      }
                    }
                    break;
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                    goto LABEL_88;
                  default:
                    goto LABEL_35;
                }
                break;
            }
            break;
          default:
            break;
        }
      }
LABEL_35:
      v28 = dword_446490;
      if ( (dword_446490 & 1) != 0 )
        return v15;
    }
    v7 = v42 + 0.04166666666666666;
    *(double *)&tbyte_446040 = v42 + 0.04166666666666666;
LABEL_41:
    sub_4078F0(v29);
    goto LABEL_32;
  }
  sub_41561F(v14, 0x48ui64);
  *((_QWORD *)&v45 + 1) = sub_407FAA;
  *((_QWORD *)&v46 + 1) = sub_405F9E();
  v49 = L"apelife";
  v47 = sub_402C92();
  v48 = 11i64;
  if ( !sub_402CD5()
    || !sub_402BFF(
          13565952,
          (unsigned int)L"Conway's Game of Life",
          0x80000000,
          0x80000000,
          *((__int64 *)&v46 + 1),
          0i64) )
  {
    sub_409DA0(v8, a2, v9, v10);
  }
  sub_402C72();
  sub_402BDF(0i64, 0i64);
  sub_402BDF(L"&Open File...", 0x20ui64);
  sub_402BDF(&off_417744, 0x10ui64);
  sub_402D3E();
  while ( 1 )
  {
    v15 = sub_402C62(0, 0);
    if ( !v15 )
      break;
    sub_402D4E();
    sub_402C1F();
  }
  return v15;
}
// 401A5A: ignored the value written to the shadow area of the succeeding call
// 401A55: ignored the value written to the shadow area of the succeeding call
// 401A53: ignored the value written to the shadow area of the succeeding call
// 401A51: ignored the value written to the shadow area of the succeeding call
// 401D88: ignored the value written to the shadow area of the succeeding call
// 401DDD: ignored the value written to the shadow area of the succeeding call
// 4015D9: variable 'v4' is possibly undefined
// 40164A: variable 'a1' is possibly undefined
// 40164A: variable 'a3' is possibly undefined
// 40164A: variable 'a4' is possibly undefined
// 401776: variable 'v5' is possibly undefined
// 4017AB: variable 'v16' is possibly undefined
// 4017C6: variable 'v17' is possibly undefined
// 4017DF: variable 'v18' is possibly undefined
// 4017E4: variable 'v19' is possibly undefined
// 401854: variable 'v21' is possibly undefined
// 401874: variable 'v22' is possibly undefined
// 40187E: variable 'v23' is possibly undefined
// 401904: variable 'v30' is possibly undefined
// 401921: variable 'v29' is possibly undefined
// 40197A: variable 'v7' is possibly undefined
// 4019C1: variable 'v42' is possibly undefined
// 4019E5: variable 'v14' is possibly undefined
// 401B85: variable 'v6' is possibly undefined
// 401CDB: variable 'v31' is possibly undefined
// 401CDB: variable 'v32' is possibly undefined
// 401CDB: variable 'v33' is possibly undefined
// 401DEE: variable 'v41' is possibly undefined
// 401E68: variable 'v43' is possibly undefined
// 4028BC: variable 'v8' is possibly undefined
// 4028BC: variable 'v9' is possibly undefined
// 4028BC: variable 'v10' is possibly undefined
// 402BFF: using guessed type __int64 __fastcall sub_402BFF(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 417700: using guessed type wchar_t aApelife[8];
// 4177B0: using guessed type wchar_t aConwaySGameOfL[22];
// 41C098: using guessed type __int64 (*qword_41C098)(void);
// 41C718: using guessed type int dword_41C718;
// 440818: using guessed type __int64 qword_440818;
// 440960: using guessed type __int16 word_440960;
// 440968: using guessed type __int16 word_440968;
// 440990: using guessed type int dword_440990;
// 440998: using guessed type int dword_440998;
// 4409A0: using guessed type __int64 qword_4409A0;
// 4409A8: using guessed type __int64 qword_4409A8;
// 4409B0: using guessed type __int64 qword_4409B0;
// 4409C0: using guessed type int dword_4409C0;
// 4409C8: using guessed type int dword_4409C8;
// 4409D0: using guessed type __int64 qword_4409D0;
// 440A00: using guessed type __int64 qword_440A00;
// 446040: using guessed type _TBYTE tbyte_446040;
// 446360: using guessed type __int64 qword_446360;
// 446400: using guessed type __int64 qword_446400;
// 446408: using guessed type __int64 qword_446408;
// 446418: using guessed type __int64 qword_446418;
// 446420: using guessed type __int64 qword_446420;
// 446428: using guessed type __int64 qword_446428;
// 446430: using guessed type __int64 qword_446430;
// 446438: using guessed type __int64 qword_446438;
// 446440: using guessed type __int64 qword_446440;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;
// 446490: using guessed type int dword_446490;
// 446494: using guessed type int dword_446494;
// 446498: using guessed type int dword_446498;
// 44649C: using guessed type int dword_44649C;
// 4464A1: using guessed type char byte_4464A1;
// 4464A2: using guessed type char byte_4464A2;
// 4464A3: using guessed type char byte_4464A3;
// 4464A4: using guessed type char byte_4464A4;
// 447FD8: using guessed type __int64 qword_447FD8;
// 447FE8: using guessed type int dword_447FE8;
// 448020: using guessed type int dword_448020;

//----- (0000000000401F80) ----------------------------------------------------
unsigned __int64 sub_401F80()
{
  unsigned __int64 result; // rax

  qword_447FF0 = 0x102030A0A030201i64;
  result = 0xFFFD03111103FDFFui64;
  qword_447FF8 = 0xFFFD03111103FDFFui64;
  return result;
}
// 447FF0: using guessed type __int64 qword_447FF0;
// 447FF8: using guessed type __int64 qword_447FF8;

//----- (0000000000401FA0) ----------------------------------------------------
__int64 __fastcall sub_401FA0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rdx
  _QWORD *v4; // rax
  __int64 result; // rax

  if ( !qword_446670 )
  {
    qword_446670 = 4482680i64;
    qword_446668 = 8i64;
    sub_40EDE0(a1, 0i64);
  }
  v2 = qword_446660;
  if ( qword_446660 )
  {
    v3 = qword_446660;
    v4 = (_QWORD *)(qword_446670 + 8 * qword_446660 - 8);
    while ( *v4 )
    {
      --v4;
      if ( !--v3 )
        goto LABEL_8;
    }
    *v4 = v1;
    return 0i64;
  }
  else
  {
LABEL_8:
    if ( qword_446660 + 1 < (unsigned __int64)qword_446668 || (unsigned __int8)sub_40F180(1i64, 8ui64) )
    {
      *(_QWORD *)(qword_446670 + 8 * v2) = v1;
      result = (unsigned int)v2;
      qword_446660 = v2 + 1;
    }
    else
    {
      return 0xFFFFFFFFi64;
    }
  }
  return result;
}
// 401FF0: variable 'v1' is possibly undefined
// 446660: using guessed type __int64 qword_446660;
// 446668: using guessed type __int64 qword_446668;
// 446670: using guessed type __int64 qword_446670;

//----- (0000000000402080) ----------------------------------------------------
__int64 __fastcall sub_402080(__int64 a1)
{
  return sub_401FA0(a1);
}

//----- (0000000000402090) ----------------------------------------------------
__int64 __fastcall sub_402090(__int64 a1)
{
  return sub_401FA0(a1);
}

//----- (00000000004020A0) ----------------------------------------------------
__int64 __fastcall sub_4020A0(__int64 a1, __int64 a2)
{
  _BYTE *v2; // r12

  v2 = (_BYTE *)qword_446038;
  if ( (dword_41C718 & 4) != 0 || (unsigned int)sub_4023B0(a1, a2) )
    *v2 = 1;
  return sub_401FA0(a1);
}
// 4020D7: variable 'a1' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 446038: using guessed type __int64 qword_446038;

//----- (00000000004020E0) ----------------------------------------------------
void sub_4020E0()
{
  __int64 *v0; // r12
  __int64 v1; // rax
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  __int64 v4; // rax

  v0 = (__int64 *)qword_448018;
  v1 = sub_40B707();
  v2 = *v0;
  qword_448018 = v1;
  v3 = (_QWORD *)v1;
  if ( v2 )
  {
    do
    {
      sub_40B7A0();
      ++v0;
      *v3++ = v4;
    }
    while ( *v0 );
  }
  *v3 = 0i64;
}
// 40211D: variable 'v4' is possibly undefined
// 40B707: using guessed type __int64 sub_40B707(void);
// 448018: using guessed type __int64 qword_448018;

//----- (0000000000402140) ----------------------------------------------------
void sub_402140()
{
  DWORD dwAllocationGranularity; // eax

  if ( !qword_4466C0 )
  {
    dwAllocationGranularity = 0x10000;
    if ( SystemInfo.dwAllocationGranularity >= 0x10000 )
      dwAllocationGranularity = SystemInfo.dwAllocationGranularity;
    if ( (dwAllocationGranularity & (dwAllocationGranularity - 1)) != 0 )
      sub_4021BE();
    qword_4466D0 = dwAllocationGranularity;
    qword_4466C8 = 4096i64;
    qword_4466D8 = 0x40000i64;
    qword_4466E0 = 10485760i64;
    dword_4466E8 = 5;
    dword_446A70 = 5;
    qword_4466C0 = qword_41C000 & 0xFFFFFFFFFFFFFFF0ui64 | 8;
  }
}
// 41C000: using guessed type __int64 qword_41C000;
// 4466C0: using guessed type __int64 qword_4466C0;
// 4466C8: using guessed type __int64 qword_4466C8;
// 4466D0: using guessed type __int64 qword_4466D0;
// 4466D8: using guessed type __int64 qword_4466D8;
// 4466E0: using guessed type __int64 qword_4466E0;
// 4466E8: using guessed type int dword_4466E8;
// 446A70: using guessed type int dword_446A70;

//----- (00000000004021BE) ----------------------------------------------------
void __noreturn sub_4021BE()
{
  sub_401114();
}

//----- (00000000004021C7) ----------------------------------------------------
void __fastcall __noreturn sub_4021C7(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  unsigned __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9

  sub_40ED3D();
  sub_4015B0(a1, a2);
  sub_40286F(v5, v4, v6, v7);
}
// 4021F3: variable 'v5' is possibly undefined
// 4021F3: variable 'v4' is possibly undefined
// 4021F3: variable 'v6' is possibly undefined
// 4021F3: variable 'v7' is possibly undefined
// 4015B0: using guessed type __int64 __fastcall sub_4015B0(_QWORD, _QWORD);

//----- (0000000000402200) ----------------------------------------------------
__int64 __fastcall sub_402200()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  __int64 v2; // rsi
  __int64 result; // rax

  v2 = v1 - v0;
  if ( v2 > 0 && v0 )
  {
    result = v2 | v0;
    if ( (((unsigned int)v2 | (unsigned int)v0) & 0xFFF) == 0 )
      return sub_402220();
  }
  return result;
}
// 402200: variable 'v1' is possibly undefined
// 402200: variable 'v0' is possibly undefined

//----- (0000000000402220) ----------------------------------------------------
__int64 sub_402220()
{
  __int64 result; // rax

  result = sub_416180();
  if ( (_DWORD)result == -1 )
    sub_401114();
  return result;
}

//----- (0000000000402240) ----------------------------------------------------
__int64 __fastcall sub_402240()
{
  if ( (__int64)sub_4015B0 < (__int64)&byte_416000 )
    sub_402200();
  sub_402200();
  return sub_402200();
}
// 4015B0: using guessed type __int64 __fastcall sub_4015B0(_QWORD, _QWORD);
// 416000: using guessed type char byte_416000;

//----- (000000000040229E) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_40229E())()
{
  __int64 v0; // r14
  __int64 v1; // r15
  __int64 (__fastcall **result)(); // rax
  __int64 (__fastcall **v3)(); // rcx
  __int64 (__fastcall **v4)(); // [rsp-10h] [rbp-10h]
  __int64 v5; // [rsp-8h] [rbp-8h]

  result = off_41B008;
  v3 = (__int64 (__fastcall **)())&unk_41B038;
  while ( v3 != result )
  {
    ((void (__fastcall *)(__int64, __int64))*result)(v1, v0);
    v3 = v4;
    result = (__int64 (__fastcall **)())(v5 + 8);
  }
  return result;
}
// 4022B2: ignored the value written to the shadow area of the succeeding call
// 4022B1: ignored the value written to the shadow area of the succeeding call
// 4022BF: variable 'v1' is possibly undefined
// 4022BF: variable 'v0' is possibly undefined
// 4022C1: variable 'v4' is possibly undefined
// 4022C3: variable 'v5' is possibly undefined
// 41B008: using guessed type __int64 (__fastcall *off_41B008[6])();

//----- (00000000004022D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4022D0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // r8
  __int64 *v7; // rcx
  __int64 *v8; // rdx
  __int64 v9; // r9

  while ( 1 )
  {
    v4 = 2 * a2 + 2;
    result = 2 * a2 + 1;
    v6 = result;
    if ( v2 > result && *(_DWORD *)(v3 + 8 * result) > *(_DWORD *)(v3 + 8 * a2) )
    {
      if ( v2 <= v4 )
        goto LABEL_7;
    }
    else
    {
      if ( v2 <= v4 )
        return result;
      result = a2;
    }
    v6 = result;
    if ( *(_DWORD *)(v3 + 8 * v4) > *(_DWORD *)(v3 + 8 * result) )
    {
      result = 2 * a2 + 2;
      v6 = result;
    }
LABEL_7:
    if ( a2 == result )
      return result;
    v7 = (__int64 *)(v3 + 8 * a2);
    v8 = (__int64 *)(v3 + 8 * v6);
    v9 = *v7;
    *v7 = *v8;
    *v8 = v9;
    a2 = result;
  }
}
// 4022DF: variable 'v2' is possibly undefined
// 4022E5: variable 'v3' is possibly undefined

//----- (0000000000402350) ----------------------------------------------------
unsigned __int64 __fastcall sub_402350(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // rsi
  unsigned __int64 v3; // rbx
  unsigned __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // rax

  v3 = ((unsigned __int64)(v1 - 2) >> 1) + 1;
  do
    result = sub_4022D0(a1, --v3);
  while ( v3 );
  if ( v1 )
  {
    v5 = v1 - 1;
    do
    {
      v6 = v2[v5];
      v2[v5] = *v2;
      *v2 = v6;
      result = sub_4022D0(a1, 0i64);
      --v5;
    }
    while ( v5 != -1 );
  }
  return result;
}
// 402355: variable 'v1' is possibly undefined
// 40236F: variable 'a1' is possibly undefined
// 402388: variable 'v2' is possibly undefined

//----- (00000000004023B0) ----------------------------------------------------
__int64 __fastcall sub_4023B0(__int64 a1, __int64 a2)
{
  int v2; // edi
  unsigned int v3; // er12
  unsigned int v4; // er12
  int v6; // ebx
  __int16 v7; // [rsp+18h] [rbp-E8h]

  v3 = dword_41C718 & 4;
  if ( (dword_41C718 & 4) != 0 )
  {
    v4 = 0;
    if ( sub_410C50() )
      return GetFileType(*(HANDLE *)(qword_447B50 + 24i64 * v2)) == 2;
    return v4;
  }
  else
  {
    v6 = dword_448020;
    if ( (unsigned int)sub_402480(a1, a2) == -1 )
    {
      dword_448020 = v6;
      return v3;
    }
    else
    {
      return (v7 & 0xF000) == 0x2000;
    }
  }
}
// 4023B6: variable 'v2' is possibly undefined
// 402443: variable 'v7' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 447B50: using guessed type __int64 qword_447B50;
// 448020: using guessed type int dword_448020;

//----- (0000000000402480) ----------------------------------------------------
__int64 __fastcall sub_402480(__int64 a1, __int64 a2)
{
  unsigned int v2; // er12

  v2 = sub_4122D0(a1, a2);
  if ( v2 != -1 )
    sub_4024B0();
  return v2;
}

//----- (00000000004024B0) ----------------------------------------------------
void __fastcall sub_4024B0()
{
  int *v0; // rdi
  __int64 v1; // rbx
  int v2; // er13
  __int64 v3; // r12
  __int64 v4; // r11
  __int64 v5; // r10
  __int64 v6; // r8
  __int64 v7; // r15
  __int64 v8; // rbx
  __int64 v9; // r9
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // r13
  int v15; // er14
  __int64 v16; // r12
  __int64 v17; // r15
  __int64 v18; // rbx
  __int64 v19; // r11
  __int64 v20; // r10

  if ( v0 )
  {
    if ( (dword_41C718 & 8) != 0 )
    {
      v1 = v0[6];
      v2 = *((unsigned __int16 *)v0 + 2);
      v3 = *((_QWORD *)v0 + 2);
      v4 = *((_QWORD *)v0 + 12);
      v5 = v0[28];
      *((_QWORD *)v0 + 2) = *((unsigned __int16 *)v0 + 3);
      v6 = *((_QWORD *)v0 + 5);
      v7 = *v0;
      *((_QWORD *)v0 + 5) = v1;
      v8 = *((_QWORD *)v0 + 13);
      v9 = *((_QWORD *)v0 + 4);
      v0[6] = v2;
      v10 = *((_QWORD *)v0 + 6);
      v11 = *((_QWORD *)v0 + 7);
      *(_QWORD *)v0 = v7;
      v12 = *((_QWORD *)v0 + 8);
      *(_QWORD *)(v0 + 7) = v3;
      *((_QWORD *)v0 + 6) = v4;
      v13 = *((_QWORD *)v0 + 9);
      *((_QWORD *)v0 + 7) = v5;
      *((_QWORD *)v0 + 8) = v8;
LABEL_4:
      *((_QWORD *)v0 + 9) = v9;
      *((_QWORD *)v0 + 10) = v6;
      *((_QWORD *)v0 + 11) = v10;
      *((_QWORD *)v0 + 12) = v11;
      *((_QWORD *)v0 + 13) = v12;
      *((_QWORD *)v0 + 14) = v13;
      return;
    }
    if ( (dword_41C718 & 0x20) != 0 )
    {
      v18 = *((_QWORD *)v0 + 14);
      v19 = v0[32];
      v20 = *((_QWORD *)v0 + 15);
      v9 = *((_QWORD *)v0 + 6);
      v6 = *((_QWORD *)v0 + 7);
      v0[6] = *((unsigned __int16 *)v0 + 12);
      v10 = *((_QWORD *)v0 + 8);
      v11 = *((_QWORD *)v0 + 9);
      v12 = *((_QWORD *)v0 + 10);
      v13 = *((_QWORD *)v0 + 11);
      goto LABEL_9;
    }
    if ( (dword_41C718 & 0x10) != 0 )
    {
      v14 = *(_QWORD *)(v0 + 5);
      v15 = *v0;
      v16 = v0[7];
      v9 = *((_QWORD *)v0 + 4);
      v6 = *((_QWORD *)v0 + 5);
      *(_QWORD *)v0 = v0[1];
      v17 = (unsigned int)v0[4];
      v18 = *((_QWORD *)v0 + 10);
      v0[6] = v15;
      v19 = v0[24];
      v20 = *((_QWORD *)v0 + 11);
      *(_QWORD *)(v0 + 7) = v14;
      v10 = *((_QWORD *)v0 + 6);
      v11 = *((_QWORD *)v0 + 7);
      *((_QWORD *)v0 + 2) = v17;
      v12 = *((_QWORD *)v0 + 8);
      v13 = *((_QWORD *)v0 + 9);
      *((_QWORD *)v0 + 5) = v16;
LABEL_9:
      *((_QWORD *)v0 + 6) = v18;
      *((_QWORD *)v0 + 7) = v19;
      *((_QWORD *)v0 + 8) = v20;
      goto LABEL_4;
    }
  }
}
// 4024B3: variable 'v0' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (00000000004025F2) ----------------------------------------------------
int __fastcall sub_4025F2(__int64 a1, unsigned int a2)
{
  UINT (__stdcall *v2)(LPSTR, UINT); // rax
  CHAR *v3; // rdi
  __int64 v4; // rax
  unsigned int v5; // ecx

  LODWORD(v4) = v2(v3, a2);
  v5 = a2;
  if ( a2 <= (unsigned int)v4 )
    v4 = 0i64;
  if ( (unsigned int)v4 > 1 && v3[v4 - 1] != 92 )
  {
    *(_WORD *)&v3[v4] = 92;
    LODWORD(v4) = v4 + 1;
  }
  do
  {
    if ( *v3++ == 92 )
      *(v3 - 1) = 47;
    --v5;
  }
  while ( v5 );
  return v4;
}
// 4025FD: variable 'v2' is possibly undefined
// 4025FD: variable 'v3' is possibly undefined
// 40260E: variable 'v4' is possibly undefined

//----- (0000000000402640) ----------------------------------------------------
__int64 __fastcall sub_402640()
{
  _QWORD *v0; // r15
  _QWORD *v1; // rax
  __int64 v2; // rdx
  __int64 result; // rax

  if ( (dword_41C718 & 0xC) != 0 || (v1 = v0, (v2 = *v0) == 0) )
  {
LABEL_8:
    qword_448010 ^= 0x139408DCBBF7A44ui64;
    if ( (dword_41C718 & 4) != 0 )
    {
      result = sub_405E30();
      qword_448010 ^= result;
    }
    else
    {
      return sub_412210();
    }
  }
  else
  {
    while ( qword_440790 != v2 )
    {
      v2 = v1[2];
      v1 += 2;
      if ( !v2 )
        goto LABEL_8;
    }
    result = v1[1];
    if ( result )
    {
      result = *(_QWORD *)result;
      qword_448010 ^= result;
    }
  }
  return result;
}
// 4026A6: ignored the value written to the shadow area of the succeeding call
// 402640: could not find valid save-restore pair for rbp
// 40264C: variable 'v0' is possibly undefined
// 402640: using guessed type __int64 __fastcall sub_402640();
// 41C718: using guessed type int dword_41C718;
// 440790: using guessed type __int64 qword_440790;
// 448010: using guessed type __int64 qword_448010;

//----- (00000000004026E0) ----------------------------------------------------
__int64 __fastcall sub_4026E0()
{
  __int64 v0; // rdi
  char *v1; // rsi
  __int64 result; // rax
  char *v3; // rcx
  char *v4; // r8
  char *v5; // rdi
  int v6; // edx

  v1 = sub_41571A();
  result = v0;
  if ( v1 )
  {
    v3 = v1 - 1;
    v4 = &v1[v0 - 1];
    v5 = v1 - 1;
    v6 = *v4;
    if ( v6 != 92 && v6 != 47 )
      goto LABEL_7;
    while ( 1 )
    {
      if ( !v5 )
      {
        result += (__int64)(v1 - 1);
        return result;
      }
      v6 = v5[result - 1];
      v3 = v5 - 1;
      if ( v6 != 47 && v6 != 92 )
        break;
      --v5;
    }
    v1 = v5;
    while ( v6 != 47 )
    {
LABEL_7:
      if ( v6 == 92 )
        break;
      if ( !v3 )
        return result;
      v6 = v3[result - 1];
      v1 = v3--;
    }
    result += (__int64)v1;
  }
  return result;
}
// 4026F0: variable 'v0' is possibly undefined

//----- (000000000040276D) ----------------------------------------------------
void __fastcall sub_40276D()
{
  unsigned __int64 v0; // rbx
  __int64 *v1; // rdi
  char *v2; // rsi
  char v3; // cl
  __int64 v4; // rdx
  char v5; // al
  unsigned __int64 v6; // r8
  __int64 v7; // rax

  while ( (unsigned __int64)v1 < v0 )
  {
    v3 = 0;
    v4 = 0i64;
    do
    {
      v5 = *v2++;
      v6 = (unsigned __int64)(v5 & 0x7F) << v3;
      v3 += 7;
      v4 |= v6;
    }
    while ( v5 < 0 );
    if ( (v5 & 0x40) != 0 )
      v4 |= -1i64 << v3;
    v7 = v4;
    if ( *v1 )
      v7 = *v1;
    *v1++ = v7;
  }
}
// 402778: variable 'v1' is possibly undefined
// 402778: variable 'v0' is possibly undefined
// 40277E: variable 'v2' is possibly undefined

//----- (00000000004027C0) ----------------------------------------------------
char *__fastcall sub_4027C0(__int64 a1, __int64 a2)
{
  char *v2; // rdi
  unsigned __int8 *v3; // rsi
  unsigned __int8 *v4; // r8
  unsigned __int64 v5; // rdx
  char *v6; // rdi
  unsigned __int8 *v7; // rsi
  char v8; // cl
  int v9; // ecx
  unsigned __int64 v10; // rcx
  unsigned __int8 *v11; // rsi
  unsigned int v12; // er8
  unsigned __int64 v13; // rcx
  int v14; // er10
  int v15; // er10

  v4 = v3;
  v5 = (unsigned __int64)&v3[a2];
  while ( 1 )
  {
    v11 = v4 + 1;
    v12 = *v4;
    v13 = v12 >> 4;
    if ( (_DWORD)v13 == 15 )
    {
      do
      {
        v14 = *v11++;
        v13 = (unsigned int)(v14 + v13);
      }
      while ( (_BYTE)v14 == 0xFF );
    }
    qmemcpy(v2, v11, v13);
    v7 = &v11[v13];
    v6 = &v2[v13];
    if ( v5 <= (unsigned __int64)v7 )
      break;
    v8 = v12;
    v4 = v7 + 2;
    v9 = v8 & 0xF;
    if ( v9 == 15 )
    {
      do
      {
        v15 = *v4++;
        v9 += v15;
      }
      while ( (_BYTE)v15 == 0xFF );
    }
    v10 = (unsigned int)(v9 + 4);
    qmemcpy(v6, &v6[-*(unsigned __int16 *)v7], v10);
    v2 = &v6[v10];
  }
  return v6;
}
// 4027C0: variable 'v3' is possibly undefined
// 4027D0: variable 'v2' is possibly undefined

//----- (000000000040283C) ----------------------------------------------------
__int64 __fastcall sub_40283C(int a1, __int64 a2)
{
  char v2; // zf
  _QWORD *v3; // rdi
  unsigned __int8 *v4; // rsi
  __int64 v5; // rax

  do
  {
    v5 = *v4++;
    *v3++ = a2 + v5;
    --a1;
  }
  while ( a1 );
  *v3 = a2 + v4[(unsigned __int8)((2 * !v2) | ((byte_41C03D & 2) != 0))];
  return *(_QWORD *)v4;
}
// 402849: variable 'v4' is possibly undefined
// 40284D: variable 'v3' is possibly undefined
// 402840: variable 'v2' is possibly undefined
// 41C03D: using guessed type char byte_41C03D;

//----- (000000000040286F) ----------------------------------------------------
void __fastcall __noreturn sub_40286F(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  sub_40EE90(a1, a2, a3, a4);
  sub_40288A();
  sub_416001();
}
// 402874: ignored the value written to the shadow area of the succeeding call

//----- (000000000040288A) ----------------------------------------------------
BOOL (__stdcall **sub_40288A())(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
{
  return &AccessCheck;
}
// 4028A2: ignored the value written to the shadow area of the succeeding call
// 4028A1: ignored the value written to the shadow area of the succeeding call

//----- (00000000004028C1) ----------------------------------------------------
void __fastcall sub_4028C1(double a1, double a2, double a3, double a4)
{
  __int64 v4; // rcx
  __int64 v5; // rcx

  sub_4029AF(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_412630(v4);
  sub_4160C0(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_412630(v5);
  sub_4160C0(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_412600();
  sub_4160C0(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
}
// 4028F5: variable 'v4' is possibly undefined
// 402929: variable 'v5' is possibly undefined
// 448020: using guessed type int dword_448020;

//----- (0000000000402973) ----------------------------------------------------
void __noreturn sub_402973()
{
  __int64 v0; // rdx
  unsigned __int64 v1; // rcx
  __int64 v2; // r8
  __int64 v3; // r9

  if ( !byte_448024 )
  {
    byte_448024 = 1;
    if ( (unsigned int)sub_410B10() )
      __debugbreak();
    sub_40A090();
    sub_40286F(v1, v0, v2, v3);
  }
  sub_401114();
}
// 4029A5: variable 'v1' is possibly undefined
// 4029A5: variable 'v0' is possibly undefined
// 4029A5: variable 'v2' is possibly undefined
// 4029A5: variable 'v3' is possibly undefined
// 448024: using guessed type char byte_448024;

//----- (00000000004029AF) ----------------------------------------------------
void __fastcall sub_4029AF(double a1, double a2, double a3, double a4)
{
  if ( sub_40A3F0() )
    sub_416150(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
  sub_416150(a1, a2, a3, a4);
}
// 41C710: using guessed type __int64 qword_41C710;

//----- (0000000000402AB8) ----------------------------------------------------
__int64 sub_402AB8()
{
  dword_448020 = dword_4407A8;
  return -1i64;
}
// 4407A8: using guessed type int dword_4407A8;
// 448020: using guessed type int dword_448020;

//----- (0000000000402ACD) ----------------------------------------------------
__int64 sub_402ACD()
{
  dword_448020 = dword_4407D0;
  return -1i64;
}
// 4407D0: using guessed type int dword_4407D0;
// 448020: using guessed type int dword_448020;

//----- (0000000000402AE2) ----------------------------------------------------
__int64 sub_402AE2()
{
  dword_448020 = dword_4407E0;
  return -1i64;
}
// 4407E0: using guessed type int dword_4407E0;
// 448020: using guessed type int dword_448020;

//----- (0000000000402AF7) ----------------------------------------------------
__int64 sub_402AF7()
{
  dword_448020 = dword_440800;
  return -1i64;
}
// 440800: using guessed type int dword_440800;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B0C) ----------------------------------------------------
__int64 sub_402B0C()
{
  dword_448020 = qword_440818;
  return -1i64;
}
// 440818: using guessed type __int64 qword_440818;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B21) ----------------------------------------------------
__int64 sub_402B21()
{
  dword_448020 = dword_440820;
  return -1i64;
}
// 440820: using guessed type int dword_440820;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B36) ----------------------------------------------------
__int64 sub_402B36()
{
  dword_448020 = dword_440830;
  return -1i64;
}
// 440830: using guessed type int dword_440830;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B4B) ----------------------------------------------------
__int64 sub_402B4B()
{
  dword_448020 = dword_440838;
  return -1i64;
}
// 440838: using guessed type int dword_440838;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B60) ----------------------------------------------------
__int64 sub_402B60()
{
  dword_448020 = dword_440848;
  return -1i64;
}
// 440848: using guessed type int dword_440848;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B75) ----------------------------------------------------
__int64 sub_402B75()
{
  dword_448020 = qword_440860;
  return -1i64;
}
// 440860: using guessed type __int64 qword_440860;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B8A) ----------------------------------------------------
__int64 sub_402B8A()
{
  dword_448020 = dword_440868;
  return -1i64;
}
// 440868: using guessed type int dword_440868;
// 448020: using guessed type int dword_448020;

//----- (0000000000402B9F) ----------------------------------------------------
__int64 sub_402B9F()
{
  dword_448020 = dword_440870;
  return -1i64;
}
// 440870: using guessed type int dword_440870;
// 448020: using guessed type int dword_448020;

//----- (0000000000402BB4) ----------------------------------------------------
__int64 sub_402BB4()
{
  dword_448020 = dword_440890;
  return -1i64;
}
// 440890: using guessed type int dword_440890;
// 448020: using guessed type int dword_448020;

//----- (0000000000402BC9) ----------------------------------------------------
__int64 sub_402BC9()
{
  dword_448020 = dword_440898;
  return -1i64;
}
// 440898: using guessed type int dword_440898;
// 448020: using guessed type int dword_448020;

//----- (0000000000402BDF) ----------------------------------------------------
BOOL __fastcall sub_402BDF(LPCWSTR lpNewItem, UINT_PTR uIDNewItem)
{
  HMENU v2; // rdi
  UINT v3; // esi

  return AppendMenuW(v2, v3, uIDNewItem, lpNewItem);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402BEF) ----------------------------------------------------
HDC __fastcall sub_402BEF()
{
  HWND v0; // rdi
  struct tagPAINTSTRUCT *v1; // rsi

  return BeginPaint(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402BFF) ----------------------------------------------------
#error "406078: positive sp value has been found (funcsize=12)"

//----- (0000000000402C0F) ----------------------------------------------------
LRESULT __fastcall sub_402C0F(LPARAM a1, WPARAM a2)
{
  HWND v2; // rdi
  UINT v3; // esi

  return DefWindowProcW(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402C1F) ----------------------------------------------------
LRESULT __fastcall sub_402C1F()
{
  const MSG *v0; // rdi

  return DispatchMessageW(v0);
}
// 402C2A: variable 'v0' is possibly undefined

//----- (0000000000402C32) ----------------------------------------------------
BOOL __fastcall sub_402C32()
{
  HWND v0; // rdi
  const PAINTSTRUCT *v1; // rsi

  return EndPaint(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402C42) ----------------------------------------------------
int __fastcall sub_402C42(__int64 a1, HBRUSH a2)
{
  HDC v2; // rdi
  const RECT *v3; // rsi

  return FillRect(v2, v3, a2);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402C52) ----------------------------------------------------
HCURSOR sub_402C52()
{
  return GetCursor();
}

//----- (0000000000402C62) ----------------------------------------------------
BOOL __fastcall sub_402C62(UINT a1, UINT a2)
{
  struct tagMSG *v2; // rdi
  HWND v3; // rsi

  return GetMessageW(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402C72) ----------------------------------------------------
HMENU __fastcall sub_402C72()
{
  HWND v0; // rdi
  BOOL v1; // esi

  return GetSystemMenu(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402C82) ----------------------------------------------------
BOOL __fastcall sub_402C82()
{
  HWND v0; // rdi
  WINDOWPLACEMENT *v1; // rsi

  return GetWindowPlacement(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402C92) ----------------------------------------------------
HCURSOR __fastcall sub_402C92()
{
  HINSTANCE v0; // rdi
  const WCHAR *v1; // rsi

  return LoadCursorW(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402CA2) ----------------------------------------------------
int __fastcall sub_402CA2(UINT a1, const WCHAR *a2)
{
  HWND v2; // rdi
  const WCHAR *v3; // rsi

  return MessageBoxW(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402CB2) ----------------------------------------------------
void __fastcall sub_402CB2()
{
  int v0; // edi

  PostQuitMessage(v0);
}
// 402CBD: variable 'v0' is possibly undefined

//----- (0000000000402CC5) ----------------------------------------------------
BOOL __fastcall sub_402CC5(UINT a1, HRGN a2)
{
  HWND v2; // rdi
  const RECT *v3; // rsi

  return RedrawWindow(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402CD5) ----------------------------------------------------
ATOM __fastcall sub_402CD5()
{
  const WNDCLASSW *v0; // rdi

  return RegisterClassW(v0);
}
// 402CE0: variable 'v0' is possibly undefined

//----- (0000000000402CE8) ----------------------------------------------------
BOOL sub_402CE8()
{
  return ReleaseCapture();
}

//----- (0000000000402CF8) ----------------------------------------------------
LRESULT __fastcall sub_402CF8(LPARAM a1, WPARAM a2)
{
  HWND v2; // rdi
  UINT v3; // esi

  return SendMessageW(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402D08) ----------------------------------------------------
HWND __fastcall sub_402D08()
{
  HWND v0; // rdi

  return SetCapture(v0);
}
// 402D13: variable 'v0' is possibly undefined

//----- (0000000000402D1B) ----------------------------------------------------
HCURSOR __fastcall sub_402D1B()
{
  HCURSOR v0; // rdi

  return SetCursor(v0);
}
// 402D26: variable 'v0' is possibly undefined

//----- (0000000000402D2E) ----------------------------------------------------
BOOL __fastcall sub_402D2E()
{
  HWND v0; // rdi
  const WCHAR *v1; // rsi

  return SetWindowTextW(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402D3E) ----------------------------------------------------
BOOL __fastcall sub_402D3E()
{
  HWND v0; // rdi
  int v1; // esi

  return ShowWindow(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402D4E) ----------------------------------------------------
BOOL __fastcall sub_402D4E()
{
  const MSG *v0; // rdi

  return TranslateMessage(v0);
}
// 402D59: variable 'v0' is possibly undefined

//----- (0000000000402D61) ----------------------------------------------------
void sub_402D61()
{
  JUMPOUT(0x40606Ai64);
}
// 402D6C: control flows out of bounds to 40606A

//----- (0000000000402D71) ----------------------------------------------------
HBITMAP __fastcall sub_402D71(__int64 a1, int a2)
{
  HDC v2; // rdi
  int v3; // esi

  return CreateCompatibleBitmap(v2, v3, a2);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000402D81) ----------------------------------------------------
HDC __fastcall sub_402D81()
{
  HDC v0; // rdi

  return CreateCompatibleDC(v0);
}
// 402D8C: variable 'v0' is possibly undefined

//----- (0000000000402D94) ----------------------------------------------------
BOOL __fastcall sub_402D94()
{
  HDC v0; // rdi

  return DeleteDC(v0);
}
// 402D9F: variable 'v0' is possibly undefined

//----- (0000000000402DA7) ----------------------------------------------------
BOOL __fastcall sub_402DA7()
{
  void *v0; // rdi

  return DeleteObject(v0);
}
// 402DB2: variable 'v0' is possibly undefined

//----- (0000000000402DBA) ----------------------------------------------------
HGDIOBJ __fastcall sub_402DBA()
{
  HDC v0; // rdi
  void *v1; // rsi

  return SelectObject(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000402DCA) ----------------------------------------------------
BOOL __fastcall sub_402DCA()
{
  struct tagOFNW *v0; // rdi

  return GetOpenFileNameW(v0);
}
// 402DD5: variable 'v0' is possibly undefined

//----- (0000000000402DE0) ----------------------------------------------------
int __fastcall sub_402DE0(__int64 a1, INT a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  char *v4; // r14
  __int64 v5; // r13
  __int64 v6; // r15
  __int16 v7; // bx
  int v8; // er12
  __int64 v9; // rcx
  int result; // eax
  __int64 v11; // rdx
  INT v12; // [rsp+Ch] [rbp-454h]
  __int64 v13; // [rsp+18h] [rbp-448h]
  char v14[1064]; // [rsp+38h] [rbp-428h] BYREF

  if ( v3 > 0x40 )
    return sub_402B21();
  if ( !v3 )
  {
    result = sub_4033BC(a1, a2);
    if ( result != -1 )
      return result;
    return sub_403070();
  }
  v4 = v14;
  v5 = qword_447B50;
  v6 = v2 + 4;
  v7 = word_440970 | word_440968 | word_440978;
  do
  {
    v8 = *(_DWORD *)(v6 - 4);
    if ( !sub_410C50() )
      return sub_402ACD();
    v6 += 8i64;
    v4 += 16;
    *((_QWORD *)v4 - 3) = *(_QWORD *)(v5 + 24i64 * v8);
    *((_WORD *)v4 - 8) = v7 & *(_WORD *)(v6 - 8);
  }
  while ( v6 != v2 + 4 + 8 * v3 );
  result = sub_4033BC(v9, v12);
  v11 = 0i64;
  if ( result == -1 )
    return sub_403070();
  do
  {
    *(_WORD *)(v2 + v11 + 6) = *(_WORD *)&v14[2 * v11 + 2];
    v11 += 8i64;
  }
  while ( v11 != v13 );
  return result;
}
// 402E0C: variable 'v3' is possibly undefined
// 402E3E: variable 'v2' is possibly undefined
// 402EE3: variable 'v9' is possibly undefined
// 402EE3: variable 'v12' is possibly undefined
// 402F0F: variable 'v13' is possibly undefined
// 440968: using guessed type __int16 word_440968;
// 440970: using guessed type __int16 word_440970;
// 440978: using guessed type __int16 word_440978;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000402F50) ----------------------------------------------------
__int64 __fastcall sub_402F50(__int64 a1, unsigned __int64 a2)
{
  int v2; // eax
  unsigned int v4; // [rsp+1Ch] [rbp-124h]

  sub_403110(a1, a2);
  sub_4033CC();
  if ( v2 == -1 )
    return sub_403070();
  else
    return v4;
}
// 402F76: ignored the value written to the shadow area of the succeeding call
// 402F70: ignored the value written to the shadow area of the succeeding call
// 402FAB: ignored the value written to the shadow area of the succeeding call
// 402FA2: ignored the value written to the shadow area of the succeeding call
// 402F8F: ignored the value written to the shadow area of the succeeding call
// 402FB9: variable 'v2' is possibly undefined
// 402FBB: variable 'v4' is possibly undefined

//----- (0000000000402FE0) ----------------------------------------------------
__int64 __fastcall sub_402FE0(__int64 a1, unsigned __int64 a2)
{
  int v2; // eax
  unsigned int v4; // [rsp+Ch] [rbp-124h]

  sub_403110(a1, a2);
  sub_4033DC();
  if ( v2 == -1 )
    return sub_403070();
  else
    return v4;
}
// 40302C: ignored the value written to the shadow area of the succeeding call
// 403023: ignored the value written to the shadow area of the succeeding call
// 403014: ignored the value written to the shadow area of the succeeding call
// 40303A: variable 'v2' is possibly undefined
// 40303C: variable 'v4' is possibly undefined

//----- (0000000000403070) ----------------------------------------------------
__int64 sub_403070()
{
  sub_4033AC();
  dword_448020 = sub_4031C0();
  return -1i64;
}
// 448020: using guessed type int dword_448020;

//----- (0000000000403090) ----------------------------------------------------
__int64 sub_403090()
{
  unsigned int v1; // er13

  if ( !sub_410C50() )
    return (unsigned int)sub_402ACD();
  v1 = 0;
  if ( sub_4033FC() == -1 )
    v1 = sub_403070();
  sub_411440();
  return v1;
}
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000403110) ----------------------------------------------------
unsigned __int64 __fastcall sub_403110(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rax

  v4 = 16i64;
  if ( a2 <= 0x10 )
    v4 = a2;
  if ( !a2 )
    return 0i64;
  v5 = 2147479552i64;
  v6 = 0i64;
  while ( 1 )
  {
    *(_QWORD *)(v2 + 8) = *v3;
    v7 = v3[1];
    if ( v7 >= v5 )
      break;
    *(_DWORD *)v2 = v7;
    ++v6;
    v2 += 16i64;
    v5 -= (unsigned int)v7;
    v3 += 2;
    if ( v4 <= v6 )
      return v6;
  }
  *(_DWORD *)v2 = v5;
  return v6;
}
// 403130: variable 'v2' is possibly undefined
// 40313F: variable 'v3' is possibly undefined

//----- (0000000000403180) ----------------------------------------------------
int __fastcall sub_403180(__int64 a1)
{
  int result; // eax

  sub_40ED60(a1);
  result = sub_4033EC();
  if ( result || word_4464C0 != 514 )
    sub_401114();
  return result;
}
// 4464C0: using guessed type __int16 word_4464C0;

//----- (00000000004031C0) ----------------------------------------------------
__int64 __fastcall sub_4031C0()
{
  unsigned int v0; // edi
  __int64 result; // rax

  if ( v0 <= 0xEA )
  {
    if ( v0 )
    {
      switch ( v0 )
      {
        case 1u:
          result = (unsigned int)dword_440820;
          break;
        case 2u:
        case 3u:
        case 0x12u:
        case 0x35u:
        case 0x43u:
        case 0xA1u:
        case 0xCEu:
          goto LABEL_34;
        case 8u:
        case 0x44u:
          return (unsigned int)dword_440868;
        case 0x13u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x41u:
        case 0x52u:
        case 0x9Eu:
          return (unsigned int)dword_4407B0;
        case 0x32u:
          result = (unsigned int)dword_440888;
          break;
        case 0x33u:
          goto LABEL_39;
        case 0x34u:
          result = (unsigned int)dword_4407B8;
          break;
        case 0x36u:
        case 0x3Au:
          goto LABEL_35;
        case 0x3Bu:
        case 0x40u:
          goto LABEL_37;
        case 0x47u:
          result = (unsigned int)dword_4407C8;
          break;
        case 0x79u:
          result = (unsigned int)dword_4408A8;
          break;
        case 0x7Au:
          return (unsigned int)dword_440800;
        case 0x7Eu:
          goto LABEL_40;
        case 0x91u:
          result = (unsigned int)dword_440880;
          break;
        case 0xE9u:
          goto LABEL_36;
        case 0xEAu:
          return (unsigned int)dword_440840;
        default:
          return v0;
      }
      return result;
    }
    return v0;
  }
  if ( v0 <= 0x5AC )
  {
    if ( v0 <= 0x5A9 )
    {
      if ( v0 > 0x4E8 )
        return v0;
      if ( v0 <= 0x48F )
      {
        result = (unsigned int)dword_440810;
        if ( v0 == 997 )
          return result;
        if ( v0 <= 0x3E5 )
        {
          if ( v0 == 487 )
            return (unsigned int)dword_4407C0;
          if ( v0 == 995 )
            return (unsigned int)qword_440818;
        }
        else
        {
          result = (unsigned int)dword_440800;
          if ( v0 == 998 )
            return result;
        }
        return v0;
      }
      switch ( v0 )
      {
        case 0x490u:
LABEL_34:
          result = (unsigned int)qword_440860;
          break;
        case 0x4BEu:
          return (unsigned int)dword_4407C0;
        case 0x4C9u:
LABEL_39:
          result = (unsigned int)dword_4407F0;
          break;
        case 0x4CAu:
          goto LABEL_36;
        case 0x4CEu:
          result = (unsigned int)dword_440828;
          break;
        case 0x4CFu:
        case 0x4D1u:
          result = (unsigned int)dword_440858;
          break;
        case 0x4D0u:
        case 0x4E8u:
          result = (unsigned int)dword_440808;
          break;
        case 0x4D2u:
          result = (unsigned int)dword_4407F8;
          break;
        case 0x4D3u:
          return (unsigned int)qword_440818;
        case 0x4D4u:
LABEL_37:
          result = (unsigned int)dword_4407E8;
          break;
        default:
          return v0;
      }
      return result;
    }
    return (unsigned int)dword_440868;
  }
  if ( v0 == 10014 )
    return (unsigned int)dword_440800;
  if ( v0 <= 0x271E )
  {
    if ( v0 == 1784 )
      return (unsigned int)dword_440840;
    if ( v0 <= 0x6F8 )
    {
      if ( v0 != 1454 && v0 != 1455 && v0 != 1453 )
        return v0;
    }
    else if ( v0 != 1816 )
    {
      if ( v0 == 10013 )
        return (unsigned int)dword_4407B0;
      return v0;
    }
    return (unsigned int)dword_440868;
  }
  if ( v0 > 0x2775 )
    return v0;
  if ( v0 <= 0x2749 )
  {
    result = (unsigned int)dword_440820;
    if ( v0 == 10022 )
      return result;
    if ( v0 == 10036 )
      return (unsigned int)dword_4407D8;
    return v0;
  }
  switch ( v0 )
  {
    case 0x274Au:
    case 0x2775u:
LABEL_36:
      result = (unsigned int)dword_4408A0;
      break;
    case 0x2753u:
      return (unsigned int)dword_440868;
    case 0x276Bu:
    case 0x276Du:
LABEL_35:
      result = (unsigned int)dword_440850;
      break;
    case 0x276Cu:
LABEL_40:
      result = (unsigned int)dword_440870;
      break;
    default:
      return v0;
  }
  return result;
}
// 4031C6: variable 'v0' is possibly undefined
// 4407B0: using guessed type int dword_4407B0;
// 4407B8: using guessed type int dword_4407B8;
// 4407C0: using guessed type int dword_4407C0;
// 4407C8: using guessed type int dword_4407C8;
// 4407D8: using guessed type int dword_4407D8;
// 4407E8: using guessed type int dword_4407E8;
// 4407F0: using guessed type int dword_4407F0;
// 4407F8: using guessed type int dword_4407F8;
// 440800: using guessed type int dword_440800;
// 440808: using guessed type int dword_440808;
// 440810: using guessed type int dword_440810;
// 440818: using guessed type __int64 qword_440818;
// 440820: using guessed type int dword_440820;
// 440828: using guessed type int dword_440828;
// 440840: using guessed type int dword_440840;
// 440850: using guessed type int dword_440850;
// 440858: using guessed type int dword_440858;
// 440860: using guessed type __int64 qword_440860;
// 440868: using guessed type int dword_440868;
// 440870: using guessed type int dword_440870;
// 440880: using guessed type int dword_440880;
// 440888: using guessed type int dword_440888;
// 4408A0: using guessed type int dword_4408A0;
// 4408A8: using guessed type int dword_4408A8;

//----- (000000000040339C) ----------------------------------------------------
int sub_40339C()
{
  return WSACleanup();
}

//----- (00000000004033AC) ----------------------------------------------------
int sub_4033AC()
{
  return WSAGetLastError();
}

//----- (00000000004033BC) ----------------------------------------------------
int __fastcall sub_4033BC(__int64 a1, INT a2)
{
  struct pollfd *v2; // rdi
  ULONG v3; // esi

  return WSAPoll(v2, v3, a2);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (00000000004033CC) ----------------------------------------------------
void sub_4033CC()
{
  JUMPOUT(0x40606Ai64);
}
// 4033D7: control flows out of bounds to 40606A

//----- (00000000004033DC) ----------------------------------------------------
void sub_4033DC()
{
  JUMPOUT(0x40606Ai64);
}
// 4033E7: control flows out of bounds to 40606A

//----- (00000000004033EC) ----------------------------------------------------
int __fastcall sub_4033EC()
{
  WORD v0; // di
  struct WSAData *v1; // rsi

  return WSAStartup(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (00000000004033FC) ----------------------------------------------------
int __fastcall sub_4033FC()
{
  SOCKET v0; // rdi

  return closesocket(v0);
}
// 403407: variable 'v0' is possibly undefined

//----- (0000000000403410) ----------------------------------------------------
__int64 __fastcall sub_403410(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  __int64 v3; // rcx
  unsigned int v4; // er13
  __int64 v5; // r15
  __int64 i; // r12
  __int64 v7; // rax
  __int64 j; // r12
  __int64 v9; // rax
  int v10; // edx
  int v12; // eax
  __int64 v13; // rdi
  __int64 v14; // rdx
  __int64 v15; // [rsp+0h] [rbp-110h]
  unsigned int v16; // [rsp+1Ch] [rbp-F4h]
  int v17; // [rsp+28h] [rbp-E8h]
  __int64 v18; // [rsp+38h] [rbp-D8h]
  int v19[3]; // [rsp+44h] [rbp-CCh]
  __int64 v20; // [rsp+50h] [rbp-C0h]
  int v21; // [rsp+70h] [rbp-A0h]
  int v22; // [rsp+ACh] [rbp-64h]
  __int64 v23[10]; // [rsp+C0h] [rbp-50h]

  sub_41561F(a1, 0x68ui64);
  v21 = 104;
  v22 = 256;
  v4 = sub_410830(v2);
  if ( v4 != -1 )
  {
    v5 = 0i64;
    for ( i = 0i64; i != 3; ++i )
    {
      v7 = *(int *)(v1 + 4 * i);
      if ( (_DWORD)v7 == -1 )
      {
        BYTE2(v20) = 0;
        LOWORD(v20) = 1;
        v12 = sub_410830(v3);
        v19[i] = v12;
        if ( v12 == -1 || (v17 = v12, !sub_405F18(0, (struct _SECURITY_ATTRIBUTES *)&ProcessAttributes)) )
          v5 = -1i64;
        else
          *(_QWORD *)(qword_447B50 + 24i64 * v17) = v18;
      }
      else
      {
        v3 = qword_447B50;
        v23[i] = *(_QWORD *)(qword_447B50 + 24 * v7);
      }
    }
    if ( v5 != -1 )
    {
      v5 = 0i64;
      if ( (unsigned int)sub_403C50(
                           (LPSECURITY_ATTRIBUTES)&ProcessAttributes,
                           v15,
                           0i64,
                           ((unsigned __int8)(v16 >> 1) ^ 1) & 1) != -1 )
      {
        sub_405EF5();
        v5 = v20;
      }
    }
    for ( j = 0i64; j != 3; ++j )
    {
      if ( *(_DWORD *)(v1 + 4 * j) == -1 )
      {
        v13 = v19[j];
        if ( v5 != -1 )
        {
          v14 = qword_447B50;
          *(_DWORD *)(v1 + 4 * j) = v13;
          *(_QWORD *)(v14 + 24 * v13 + 16) = 1i64;
        }
        sub_405EF5();
      }
    }
    v9 = qword_447B50 + 24i64 * (int)v4;
    v10 = qword_440920;
    *(_DWORD *)(v9 + 16) = 3;
    *(_QWORD *)v9 = v5;
    *(_DWORD *)(v9 + 20) = v10;
  }
  return v4;
}
// 40344C: ignored the value written to the shadow area of the succeeding call
// 403445: ignored the value written to the shadow area of the succeeding call
// 403439: ignored the value written to the shadow area of the succeeding call
// 403430: ignored the value written to the shadow area of the succeeding call
// 403500: ignored the value written to the shadow area of the succeeding call
// 4034FA: ignored the value written to the shadow area of the succeeding call
// 4034F1: ignored the value written to the shadow area of the succeeding call
// 4034E1: ignored the value written to the shadow area of the succeeding call
// 403469: variable 'v2' is possibly undefined
// 403480: variable 'v1' is possibly undefined
// 403501: variable 'v15' is possibly undefined
// 4034D5: variable 'v16' is possibly undefined
// 4035AA: variable 'v3' is possibly undefined
// 40367B: variable 'v18' is possibly undefined
// 440920: using guessed type __int64 qword_440920;
// 447B50: using guessed type __int64 qword_447B50;
// 403410: using guessed type _QWORD var_50[10];
// 403410: using guessed type int var_CC[3];

//----- (0000000000403710) ----------------------------------------------------
__int64 __fastcall sub_403710(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  __int64 result; // rax
  unsigned int v5; // [rsp-3Ch] [rbp-3Ch] BYREF

  if ( !a2 )
    return nullsub_1(sub_406014);
  for ( i = 0i64; i < a2; i += v5 )
  {
    ((void (__fastcall *)(unsigned int *, unsigned __int64, _QWORD))sub_406014)(&v5, a2 - i, 0i64);
    result = v5;
  }
  return result;
}
// 403700: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (0000000000403720) ----------------------------------------------------
__int64 __fastcall sub_403720(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // rbx
  __int64 result; // rax
  unsigned int v5; // [rsp-3Ch] [rbp-3Ch] BYREF

  if ( !a2 )
    return nullsub_1(sub_405FD4);
  for ( i = 0i64; i < a2; i += v5 )
  {
    ((void (__fastcall *)(unsigned int *, unsigned __int64, _QWORD))sub_405FD4)(&v5, a2 - i, 0i64);
    result = v5;
  }
  return result;
}
// 403700: using guessed type __int64 __fastcall nullsub_1(_QWORD);

//----- (0000000000403730) ----------------------------------------------------
__int64 __fastcall sub_403730()
{
  __int64 v0; // rbx
  __int64 v1; // rbp
  __int64 v2; // r12
  __int64 v3; // r13
  __int64 v4; // r14
  __int64 v5; // r15
  __int64 result; // rax
  int v7; // edx
  WCHAR *v8; // rax
  __int64 v9; // r13
  __int64 v10; // rcx
  unsigned int v11; // ebx
  int *v12; // r14
  __int64 v13; // rcx
  __int64 v14; // rcx
  int v15; // er10
  DWORD v16; // edx
  HANDLE FileMappingNumaW; // rax
  __int64 v18; // rcx
  void *v19; // r15
  __int64 v20; // rax
  __int64 v21; // r12
  int v22; // edx
  unsigned __int16 *v23; // rax
  __int64 v24; // rdi
  DWORD v25; // [rsp-114h] [rbp-114h]
  DWORD v26; // [rsp-104h] [rbp-104h] BYREF
  WCHAR v27[48]; // [rsp-A0h] [rbp-A0h] BYREF
  __int64 v28; // [rsp-40h] [rbp-40h]
  char *v29; // [rsp-38h] [rbp-38h]
  __int64 v30; // [rsp-30h] [rbp-30h]
  __int64 v31; // [rsp-28h] [rbp-28h]
  __int64 v32; // [rsp-20h] [rbp-20h]
  __int64 v33; // [rsp-18h] [rbp-18h]
  __int64 v34; // [rsp-10h] [rbp-10h]
  void *v35; // [rsp-8h] [rbp-8h]
  void *retaddr; // [rsp+0h] [rbp+0h]
  char v37; // [rsp+8h] [rbp+8h] BYREF

  v35 = retaddr;
  v34 = v1;
  v33 = v5;
  v32 = v4;
  v31 = v3;
  v30 = v2;
  v29 = &v37;
  v28 = v0;
  result = GetEnvironmentVariableW(L"_FORK", v27, 0x2Cu) - 1;
  if ( (unsigned int)result <= 0x2A )
  {
    v7 = v27[0];
    v8 = v27;
    v9 = 0i64;
    v10 = (unsigned int)v27[0] - 48;
    if ( (unsigned __int16)(v27[0] - 48) <= 9u )
    {
      do
      {
        ++v8;
        v9 = v7 - 48 + 10 * v9;
        v7 = *v8;
        v10 = (unsigned int)(v7 - 48);
      }
      while ( (unsigned __int16)(v7 - 48) <= 9u );
    }
    if ( (_WORD)v7 == 32 )
      goto LABEL_15;
    while ( 1 )
    {
      v11 = 0;
      v12 = dword_446EE8;
      sub_403720(v10, 0x40ui64);
      sub_403720(v13, 4ui64);
      if ( dword_446EE0 )
      {
        do
        {
          sub_403720(v14, 0x18ui64);
          v19 = (void *)((__int64)*v12 << 16);
          v20 = (v12[4] & 7u) - 1;
          v21 = ((__int64)(v12[1] - *v12) << 16) + 0x10000;
          if ( (unsigned int)v20 <= 6 )
          {
            v15 = dword_418810[v20];
            v16 = *(&dwDesiredAccess + v20);
          }
          else
          {
            v16 = 0;
            v15 = 1;
          }
          v25 = v15;
          if ( (v12[5] & 2) != 0 )
          {
            FileMappingNumaW = CreateFileMappingNumaW(
                                 (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                                 0i64,
                                 0x40u,
                                 0,
                                 v21,
                                 0i64,
                                 0xFFFFFFFF);
            *((_QWORD *)v12 + 1) = FileMappingNumaW;
            MapViewOfFileExNuma(FileMappingNumaW, 0x26u, 0, 0, v21, v19, 0xFFFFFFFF);
            sub_403720(v18, v21);
            sub_405FF4(&v26, v25);
          }
          else
          {
            MapViewOfFileExNuma(*((HANDLE *)v12 + 1), v16, 0, 0, v21, v19, 0xFFFFFFFF);
          }
          ++v11;
          v12 += 6;
        }
        while ( dword_446EE0 > v11 );
      }
      sub_403720(v14, 0x2D000ui64);
      sub_405EF5();
      v8 = (WCHAR *)sub_416315();
LABEL_15:
      v22 = v8[1];
      if ( (unsigned __int16)(v22 - 48) <= 9u )
      {
        v23 = v8 + 1;
        v24 = 0i64;
        do
        {
          ++v23;
          v24 = v22 - 48 + 10 * v24;
          v22 = *v23;
        }
        while ( (unsigned __int16)(v22 - 48) <= 9u );
      }
      sub_405EF5();
    }
  }
  return result;
}
// 403730: could not find valid save-restore pair for rbx
// 403730: could not find valid save-restore pair for rbp
// 403730: could not find valid save-restore pair for r12
// 403730: could not find valid save-restore pair for r13
// 403730: could not find valid save-restore pair for r14
// 403730: could not find valid save-restore pair for r15
// 403748: variable 'v1' is possibly undefined
// 40374C: variable 'v5' is possibly undefined
// 40374E: variable 'v4' is possibly undefined
// 403757: variable 'v3' is possibly undefined
// 403759: variable 'v2' is possibly undefined
// 40375D: variable 'v0' is possibly undefined
// 4037E6: variable 'v10' is possibly undefined
// 4037F8: variable 'v13' is possibly undefined
// 40388A: variable 'v18' is possibly undefined
// 4038C5: variable 'v14' is possibly undefined
// 418810: using guessed type int dword_418810[];
// 446EE0: using guessed type int dword_446EE0;
// 446EE8: using guessed type int dword_446EE8[];

//----- (0000000000403C50) ----------------------------------------------------
__int64 __fastcall sub_403C50(
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        __int64 a2,
        struct _SECURITY_ATTRIBUTES *a3,
        BOOL a4)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  WCHAR *v11; // rbx
  __int64 v12; // rax
  struct _SECURITY_ATTRIBUTES *v13; // r8
  unsigned int v14; // er13
  DWORD v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  void *v21; // [rsp-20h] [rbp-240h]
  __int16 ApplicationName[272]; // [rsp+0h] [rbp-220h] BYREF
  DWORD v23; // [rsp+230h] [rbp+10h]
  const WCHAR *lpCurrentDirectory; // [rsp+238h] [rbp+18h]
  struct _STARTUPINFOW *lpStartupInfo; // [rsp+240h] [rbp+20h]
  struct _PROCESS_INFORMATION *lpProcessInformation; // [rsp+248h] [rbp+28h]

  if ( (unsigned int)sub_404D00((__int64)lpProcessAttributes) == -1 || (v11 = (WCHAR *)sub_403D30()) == 0i64 )
  {
    v14 = -1;
  }
  else
  {
    v12 = sub_404000();
    if ( v12 )
    {
      v13 = lpProcessAttributes;
      v14 = 0;
      v21 = (void *)v12;
      v15 = v23;
      BYTE1(v15) = BYTE1(v23) | 4;
      if ( !CreateProcessW(
              (LPCWSTR)ApplicationName,
              v11,
              v13,
              a3,
              a4,
              v15,
              v21,
              lpCurrentDirectory,
              lpStartupInfo,
              lpProcessInformation) )
        v14 = sub_4162A0();
    }
    else
    {
      v14 = -1;
    }
  }
  sub_40B701(v8, v7, v9, v10);
  sub_40B701(v17, v16, v18, v19);
  return v14;
}
// 403CE4: variable 'v8' is possibly undefined
// 403CE4: variable 'v7' is possibly undefined
// 403CE4: variable 'v9' is possibly undefined
// 403CE4: variable 'v10' is possibly undefined
// 403CEC: variable 'v17' is possibly undefined
// 403CEC: variable 'v16' is possibly undefined
// 403CEC: variable 'v18' is possibly undefined
// 403CEC: variable 'v19' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 403C50: using guessed type WCHAR ApplicationName[272];

//----- (0000000000403D30) ----------------------------------------------------
__int64 __fastcall sub_403D30()
{
  __int64 *v0; // rdi
  __int64 v1; // rcx
  __int64 *v2; // r13
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  int v8; // er14
  __int64 v9; // rbx
  __int64 v10; // r12
  unsigned __int64 v11; // rax
  char v12; // dl
  bool v13; // sf
  int v14; // eax
  int v15; // er12
  int v16; // er12
  int v17; // er12
  char *v18; // rdi
  __int64 v20; // [rsp+8h] [rbp-58h]
  unsigned int v21; // [rsp+10h] [rbp-50h]
  __int64 v22; // [rsp+18h] [rbp-48h]
  unsigned __int64 v23; // [rsp+20h] [rbp-40h]
  __int64 v24[7]; // [rsp+28h] [rbp-38h] BYREF

  v1 = *v0;
  v23 = 0i64;
  v24[0] = 0i64;
  if ( !v1 )
  {
    sub_402B21();
    return v22;
  }
  v2 = v0;
  while ( 2 )
  {
    v3 = sub_414BA0();
    v4 = v20;
    if ( *(_BYTE *)(v20 + v3) )
    {
LABEL_4:
      if ( (unsigned int)sub_40B4F0(34, v24) == -1 )
        break;
      v4 = *v2;
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    v9 = 0i64;
    while ( 1 )
    {
      v12 = *(_BYTE *)(v4 + v9);
      if ( v8 )
        break;
      v13 = v12 < 0;
      if ( !v12 )
        goto LABEL_27;
LABEL_13:
      if ( !v13 )
      {
        ++v9;
LABEL_15:
        v10 = 1i64;
        if ( v23 + 1 < v24[0] )
          goto LABEL_9;
        goto LABEL_16;
      }
      v9 += (int)abs32(sub_414D40());
      if ( v21 <= 0xD7FF )
        goto LABEL_15;
      v10 = (int)abs32(sub_4149F0(v4, v21));
      if ( v23 + v10 < v24[0] )
        goto LABEL_9;
LABEL_16:
      if ( !(unsigned __int8)sub_40F180(v10, 2ui64) )
        goto LABEL_33;
LABEL_9:
      sub_4154C0(v4, 2 * v10);
      v11 = v23;
      v23 += v10;
      if ( v11 == -1i64 )
        goto LABEL_33;
      v4 = *v2;
    }
    if ( v12 == 92 )
    {
      v14 = 1 - v9;
      do
      {
        v15 = v14 + v9++;
        v12 = *(_BYTE *)(v4 + v9);
      }
      while ( v12 == 92 );
      v16 = 2 * v15;
    }
    else
    {
      v16 = 0;
    }
    v17 = (v12 == 34) + v16;
    while ( v17 )
    {
      --v17;
      if ( (unsigned int)sub_40B4F0(92, v24) == -1 )
        goto LABEL_33;
    }
    v18 = (char *)(v9 + *v2);
    v13 = *v18 < 0;
    if ( *v18 )
      goto LABEL_13;
LABEL_27:
    if ( v8 && (unsigned int)sub_40B4F0(34, v24) == -1 )
      break;
    if ( !*++v2 )
    {
      if ( (unsigned int)sub_40B4F0(0, v24) == -1 )
        break;
      if ( v23 > 0x4000 )
      {
        sub_402AB8();
        break;
      }
      return v22;
    }
    if ( (unsigned int)sub_40B4F0(32, v24) != -1 )
    {
      if ( !*v2 )
        goto LABEL_4;
      continue;
    }
    break;
  }
LABEL_33:
  sub_40B701(v4, v5, v6, v7);
  return 0i64;
}
// 403D76: ignored the value written to the shadow area of the succeeding call
// 403F47: ignored the value written to the shadow area of the succeeding call
// 403F43: ignored the value written to the shadow area of the succeeding call
// 403FAD: ignored the value written to the shadow area of the succeeding call
// 403FA9: ignored the value written to the shadow area of the succeeding call
// 403D41: variable 'v0' is possibly undefined
// 403D7F: variable 'v20' is possibly undefined
// 403DE3: variable 'v21' is possibly undefined
// 403DEE: variable 'v4' is possibly undefined
// 403F7C: variable 'v5' is possibly undefined
// 403F7C: variable 'v6' is possibly undefined
// 403F7C: variable 'v7' is possibly undefined
// 403FEA: variable 'v22' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000404000) ----------------------------------------------------
__int64 sub_404000()
{
  __int64 *v0; // rax
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 *v5; // rbx
  __int64 v6; // rdi
  __int64 *v7; // r15
  __int64 v8; // r13
  __int64 i; // r14
  __int64 v10; // rbx
  __int64 v11; // r12
  char v12; // al
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned int v18; // [rsp+Ch] [rbp-54h]
  unsigned int v19; // [rsp+18h] [rbp-48h]
  int v20; // [rsp+18h] [rbp-48h]
  __int64 v21; // [rsp+28h] [rbp-38h]

  sub_404190();
  if ( !v0 || (v5 = v0, (v21 = sub_40B6FB()) == 0) )
  {
LABEL_13:
    sub_40B701(v2, v1, v3, v4);
    sub_40B701(v14, v13, v15, v16);
    return 0i64;
  }
  v6 = *v5;
  v7 = v5;
  v8 = 0i64;
  if ( !*v5 )
    goto LABEL_16;
  while ( 2 )
  {
    for ( i = 0i64; ; i += (int)v3 )
    {
      if ( *(char *)(i + v6) >= 0 || (sub_414D40(), v19 <= 0xD7FF) )
      {
        v10 = 1i64;
        v11 = v8 + 1;
        if ( (unsigned __int64)(v8 + 1) < 8 )
          goto LABEL_7;
      }
      else
      {
        v10 = (int)abs32(sub_4149F0(v2, v19));
        v11 = v8 + v10;
        if ( (unsigned __int64)(v8 + v10) < 8 )
          goto LABEL_7;
      }
      v12 = sub_40F180(v10, 2ui64);
      v3 = v18;
      if ( !v12 )
        goto LABEL_13;
LABEL_7:
      sub_4154C0(v2, 2 * v10);
      if ( v8 == -1 )
        goto LABEL_13;
      if ( !v20 )
        break;
      v6 = *v7;
      v8 = v11;
    }
    v6 = v7[1];
    ++v7;
    if ( v6 )
    {
      v8 = v11;
      continue;
    }
    break;
  }
  v4 = v11 + 1;
  if ( (unsigned __int64)(v11 + 1) > 0x7FFF )
  {
    sub_402AB8();
    goto LABEL_13;
  }
LABEL_16:
  sub_40B701(v2, v1, v3, v4);
  return v21;
}
// 404115: ignored the value written to the shadow area of the succeeding call
// 404000: could not find valid save-restore pair for rdi
// 40402D: variable 'v0' is possibly undefined
// 40408B: variable 'v19' is possibly undefined
// 404096: variable 'v2' is possibly undefined
// 4040D4: variable 'v20' is possibly undefined
// 4040D6: variable 'v3' is possibly undefined
// 404122: variable 'v18' is possibly undefined
// 40412E: variable 'v1' is possibly undefined
// 40412E: variable 'v4' is possibly undefined
// 404137: variable 'v14' is possibly undefined
// 404137: variable 'v13' is possibly undefined
// 404137: variable 'v15' is possibly undefined
// 404137: variable 'v16' is possibly undefined
// 40B6FB: using guessed type __int64 sub_40B6FB(void);
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000404190) ----------------------------------------------------
void __fastcall sub_404190()
{
  _QWORD *v0; // rdi
  __int64 v1; // r12
  __int64 v2; // rbx
  __int64 v3; // rcx
  _QWORD *v4; // rax
  __int64 v5; // r8
  unsigned __int8 *v6; // r10
  __int64 v7; // rcx
  unsigned __int8 *v8; // r9
  int v9; // esi
  __int64 v10; // rdi
  int v11; // edx
  _QWORD *v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx

  v1 = 0i64;
  if ( *v0 )
  {
    do
      v2 = v1++;
    while ( v0[v2 + 1] );
    if ( sub_40B707() )
    {
      sub_4154C0(v3, 8 * v2 + 16);
      if ( v1 != 1 )
      {
        v5 = 1i64;
LABEL_6:
        v6 = (unsigned __int8 *)v4[v5];
        v7 = v5;
        do
        {
          v8 = (unsigned __int8 *)v4[v7 - 1];
          v9 = *v6;
          v10 = 0i64;
          v11 = *v8;
          if ( (_BYTE)v11 == (_BYTE)v9 )
          {
            while ( (_BYTE)v11 )
            {
              v9 = v6[++v10];
              v11 = v8[v10];
              if ( (_BYTE)v9 != (_BYTE)v11 )
                goto LABEL_14;
            }
            v12 = &v4[v7];
LABEL_12:
            *v12 = v6;
            v13 = v5 + 1;
            if ( v2 == v5 )
              return;
LABEL_13:
            v5 = v13;
            goto LABEL_6;
          }
LABEL_14:
          v12 = &v4[v7];
          if ( v9 - v11 >= 0 )
            goto LABEL_12;
          v4[v7--] = v8;
        }
        while ( v7 * 8 );
        v13 = v5 + 1;
        *v4 = v6;
        if ( v2 != v5 )
          goto LABEL_13;
      }
    }
  }
  else if ( sub_40B707() )
  {
    sub_4154C0(v14, 8ui64);
  }
}
// 4041A1: variable 'v0' is possibly undefined
// 4041E2: variable 'v3' is possibly undefined
// 404200: variable 'v4' is possibly undefined
// 4042AA: variable 'v14' is possibly undefined
// 40B707: using guessed type __int64 sub_40B707(void);

//----- (00000000004042C0) ----------------------------------------------------
BOOL sub_4042C0()
{
  BOOL result; // eax

  if ( hConsoleHandle )
  {
    SetConsoleCP(wCodePageID);
    result = SetConsoleMode(hConsoleHandle, Mode);
  }
  if ( qword_447B20 )
  {
    SetConsoleOutputCP(dword_447B18);
    return SetConsoleMode(qword_447B20, dword_447B1C);
  }
  return result;
}

//----- (0000000000404330) ----------------------------------------------------
void __noreturn start()
{
  __int64 v0; // rcx
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // rbx
  _QWORD *v3; // r12
  unsigned int v4; // eax
  char *v5; // rdx
  unsigned int v6; // er14
  char v7; // al
  __int64 v8; // rcx
  WCHAR *EnvironmentStringsW; // r13

  SetDefaultDllDirectories(0x800u);
  if ( sub_403180 )
    sub_403180(v0);
  if ( sub_403730 )
    sub_403730();
  dword_41C718 = 4;
  qword_446EF0 = (__int64)CreateFileMappingNumaW(
                            (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                            0i64,
                            0x40u,
                            0,
                            0x20000u,
                            0i64,
                            0xFFFFFFFF);
  v1 = (unsigned __int64)MapViewOfFileExNuma(
                           (HANDLE)qword_446EF0,
                           6u,
                           0,
                           0,
                           0x20000ui64,
                           (LPVOID)0x777000000000i64,
                           0xFFFFFFFF);
  dword_446EF8 = 3;
  v2 = v1;
  dword_446EE8[0] = v1 >> 16;
  v3 = (_QWORD *)(v1 + 73712);
  dword_446EEC[0] = dword_446EE8[0] + 1;
  dword_446EFC = qword_4408C8 | 2;
  dword_446EE0 = 1;
  GetCommandLineW();
  v4 = sub_4047D0((__int64)v3, 0x3FFFi64, 0x200ui64);
  v5 = *(char **)(v2 + 73712);
  v6 = v4;
  v7 = *v5;
  if ( *v5 )
  {
    v8 = 1i64;
    do
    {
      if ( v7 == 92 )
        *v5 = 47;
      v5 = (char *)(v8 + *v3);
      ++v8;
      v7 = *v5;
    }
    while ( *v5 );
  }
  EnvironmentStringsW = GetEnvironmentStringsW();
  sub_404B30((__int64)(v3 + 512), 0x7FFFui64, 0x200ui64);
  FreeEnvironmentStringsW(EnvironmentStringsW);
  v3[1024] = 0i64;
  v3[1025] = 0i64;
  sub_40F84E((__int64)v3, v6, (__int64)(v3 + 512), (__int64)(v3 + 1024));
}
// 40435A: variable 'v0' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 4408C8: using guessed type __int64 qword_4408C8;
// 446EE0: using guessed type int dword_446EE0;
// 446EE8: using guessed type int dword_446EE8[];
// 446EEC: using guessed type int dword_446EEC[];
// 446EF0: using guessed type __int64 qword_446EF0;
// 446EF8: using guessed type int dword_446EF8;
// 446EFC: using guessed type int dword_446EFC;

//----- (0000000000404670) ----------------------------------------------------
LPVOID __fastcall sub_404670(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  SIZE_T v4; // rsi
  __int64 v5; // rcx
  HANDLE FileMappingNumaW; // r12
  DWORD v8; // eax
  LPVOID result; // rax
  LPVOID lpBaseAddress; // [rsp+8h] [rbp-38h]

  v5 = -1i64;
  if ( a3 != -1 )
    v5 = *(_QWORD *)(qword_447B50 + 24i64 * a3);
  FileMappingNumaW = CreateFileMappingNumaW((HANDLE)v5, 0i64, 0x40u, HIDWORD(v4), v4, 0i64, 0xFFFFFFFF);
  if ( !FileMappingNumaW )
    return (LPVOID)sub_4162A0();
  v8 = sub_410600();
  result = MapViewOfFileExNuma(FileMappingNumaW, v8, HIDWORD(a4), a4, v4, lpBaseAddress, 0xFFFFFFFF);
  if ( !result )
  {
    sub_405EF5();
    return (LPVOID)sub_4162A0();
  }
  return result;
}
// 4046D0: variable 'v4' is possibly undefined
// 40470B: variable 'lpBaseAddress' is possibly undefined
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000404760) ----------------------------------------------------
__int64 __fastcall sub_404760()
{
  unsigned __int16 **v0; // rdi
  unsigned __int16 *i; // rdx
  unsigned int v2; // er8
  __int16 v3; // ax

  for ( i = *v0; ; ++i )
  {
    v2 = *i;
    if ( !*i )
      goto LABEL_5;
    v3 = *i & 0xFC00;
    if ( v3 != -9216 )
      break;
  }
  if ( v3 != -10240 )
  {
LABEL_5:
    *v0 = i + 1;
    return v2;
  }
  *v0 = i + 2;
  if ( i[1] )
    return i[1] + ((v2 - 55296) << 10) + 9216;
  else
    return 0i64;
}
// 404760: variable 'v0' is possibly undefined

//----- (00000000004047D0) ----------------------------------------------------
__int64 __fastcall sub_4047D0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  _BYTE *v3; // rsi
  unsigned __int64 v5; // r12
  _BYTE *v6; // rax
  unsigned int v7; // er14
  bool v8; // bl
  unsigned __int64 v9; // rax
  _BYTE *v10; // rdx
  _BYTE *v11; // rax
  unsigned __int64 v12; // rsi
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rdx
  _BYTE *v19; // rax
  bool v20; // cf
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // rdx
  _BYTE *v24; // rax
  unsigned __int64 v25; // rdx
  _BYTE *v26; // rax
  _BYTE *v27; // rax
  _BYTE *v28; // rax
  unsigned __int64 v29; // r13
  _BYTE *v31; // rax
  unsigned int v32; // er8
  __int64 v33; // [rsp+8h] [rbp-68h]
  __int64 v34; // [rsp+10h] [rbp-60h]
  __int64 v35; // [rsp+18h] [rbp-58h]
  _BYTE *v36; // [rsp+28h] [rbp-48h]
  unsigned __int64 v37; // [rsp+30h] [rbp-40h]
  unsigned int v38; // [rsp+38h] [rbp-38h]

  v5 = 0i64;
  v36 = v3;
  v37 = (unsigned __int64)&v3[a2];
  v38 = sub_404760();
  if ( !v38 )
  {
    v31 = v3;
    v32 = 0;
    goto LABEL_55;
  }
  while ( 2 )
  {
    while ( !(unsigned int)sub_4148D0() )
    {
      if ( ++v5 < a3 )
      {
        v6 = v36;
        if ( (unsigned __int64)v36 >= v37 )
          v6 = 0i64;
        *(_QWORD *)(v35 + 8 * v5 - 8) = v6;
      }
      v7 = v38;
      v8 = 0;
      while ( v8 || !(unsigned int)sub_4148D0() )
      {
        if ( v7 != 34 && v7 != 92 )
        {
          v9 = (int)v7;
          if ( v7 > 0x7F )
            v9 = sub_414845();
          do
          {
            v10 = v36;
            if ( (unsigned __int64)v36 >= v37 )
              break;
            ++v36;
            *v10 = v9;
            v9 >>= 8;
          }
          while ( v9 );
          v38 = sub_404760();
          v7 = v38;
          goto LABEL_19;
        }
        v12 = 0i64;
        if ( v38 == 92 )
        {
          do
          {
            v13 = sub_404760();
            v38 = v13;
            ++v12;
          }
          while ( v13 == 92 );
          if ( v13 != 34 )
          {
LABEL_43:
            v25 = v12 - 1;
            if ( !v12 )
            {
              v7 = v38;
              goto LABEL_19;
            }
            do
            {
              v26 = v36;
              if ( (unsigned __int64)v36 < v37 )
              {
                ++v36;
                *v26 = 92;
              }
              --v25;
            }
            while ( v25 != -1i64 );
            goto LABEL_42;
          }
        }
        else if ( v38 != 34 )
        {
          v7 = v38;
          goto LABEL_19;
        }
        do
        {
          v14 = sub_404760();
          v16 = v15;
          v38 = v14;
          v17 = v15 + 1;
        }
        while ( v14 == 34 );
        if ( !v17 )
          goto LABEL_43;
        v18 = v12;
        if ( v12 > 1 )
        {
          do
          {
            v19 = v36;
            if ( (unsigned __int64)v36 < v37 )
            {
              ++v36;
              *v19 = 92;
            }
            v20 = v18 == 2;
            v18 -= 2i64;
          }
          while ( !v20 && v18 != 1 );
          v12 &= 1u;
        }
        if ( v12 )
        {
          v27 = v36;
          if ( (unsigned __int64)v36 < v37 )
          {
            ++v36;
            *v27 = 34;
          }
          if ( !v16 )
            goto LABEL_42;
          v17 = v16;
        }
        if ( v8 )
        {
          v21 = v17 + 1;
          v22 = v17;
        }
        else
        {
          v22 = v17 - 1;
          v21 = v17;
        }
        v23 = 3i64;
        if ( v21 > 2 )
        {
          do
          {
            v24 = v36;
            if ( (unsigned __int64)v36 < v37 )
            {
              ++v36;
              *v24 = 34;
            }
            v23 += 3i64;
          }
          while ( v23 <= v21 );
        }
        v8 = 0xAAAAAAAAAAAAAAABui64 * v22 <= 0x5555555555555555i64;
LABEL_42:
        v7 = v38;
LABEL_19:
        if ( !v7 )
          break;
      }
      v11 = v36;
      if ( (unsigned __int64)v36 < v37 )
      {
        ++v36;
        *v11 = 0;
      }
      if ( !v38 )
      {
        v31 = v36;
        v32 = v5;
        goto LABEL_55;
      }
    }
    v38 = sub_404760();
    if ( v38 )
      continue;
    break;
  }
  v31 = v36;
  v32 = v5;
LABEL_55:
  if ( (unsigned __int64)v31 < v37 )
  {
    v36 = v31 + 1;
    *v31 = 0;
  }
  if ( v34 )
  {
    v28 = &v36[-v33];
    if ( (unsigned __int64)&v36[-v33] > v34 - 1 )
      v28 = (_BYTE *)(v34 - 1);
    v28[v33] = 0;
  }
  if ( a3 )
  {
    v29 = a3 - 1;
    if ( v29 > v5 )
      v29 = v5;
    *(_QWORD *)(v35 + 8 * v29) = 0i64;
  }
  return v32;
}
// 404807: ignored the value written to the shadow area of the succeeding call
// 404803: ignored the value written to the shadow area of the succeeding call
// 4047FF: ignored the value written to the shadow area of the succeeding call
// 40487B: conditional instruction was optimized away because %var_38.4!=0
// 40480B: variable 'v3' is possibly undefined
// 40486D: variable 'v35' is possibly undefined
// 404961: variable 'v15' is possibly undefined
// 404AA8: variable 'v34' is possibly undefined
// 404AB6: variable 'v33' is possibly undefined

//----- (0000000000404B30) ----------------------------------------------------
__int64 __fastcall sub_404B30(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  const __m128i *v3; // rdi
  _BYTE *v4; // rsi
  unsigned __int64 v5; // r15
  unsigned int v6; // er13
  const __m128i *v7; // rbx
  unsigned __int64 v8; // r12
  _BYTE *v9; // r14
  unsigned int v10; // eax
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v14; // [rsp+0h] [rbp-40h]
  unsigned __int64 v15; // [rsp+8h] [rbp-38h]

  v5 = a2;
  v6 = 0;
  v14 = a1;
  v15 = a3;
  if ( a2 )
  {
    v7 = v3;
    v8 = a2 - 1;
    v9 = v4;
    if ( v3->m128i_i16[0] )
    {
      do
      {
        v10 = v6 + 1;
        v5 = (int)v6;
        if ( (int)(v6 + 1) < v15 )
        {
          ++v6;
          *(_QWORD *)(v14 + 8 * v5) = v9;
          v5 = (int)v10;
        }
        v11 = sub_414E40(a1, v7);
        v7 = (const __m128i *)((char *)v7 + 2 * v12);
        v9 += v11 + 1;
        v8 += ~v11;
      }
      while ( v7->m128i_i16[0] );
    }
    else
    {
      v5 = 0i64;
    }
    *v9 = 0;
  }
  if ( v5 < v15 )
    *(_QWORD *)(v14 + 8 * v5) = 0i64;
  return v6;
}
// 404B58: variable 'v3' is possibly undefined
// 404B5F: variable 'v4' is possibly undefined
// 404B76: variable 'v15' is possibly undefined
// 404B7F: variable 'v14' is possibly undefined
// 404B8F: variable 'a1' is possibly undefined
// 404B97: variable 'v12' is possibly undefined

//----- (0000000000404BE0) ----------------------------------------------------
__int64 __fastcall sub_404BE0(__int64 a1, int a2)
{
  char *v2; // rdi
  _WORD *v3; // rsi
  char *v4; // r12
  _WORD *v5; // rbx
  __int64 result; // rax
  __int64 v8; // rdx

  v4 = v2;
  v5 = v3;
  if ( *v2 != 47 )
    goto LABEL_7;
  if ( !(unsigned int)sub_414B60() )
  {
    v8 = (unsigned int)qword_440910 & a2;
    if ( v8 == qword_440938 )
      goto LABEL_17;
    if ( v8 == qword_440958 )
    {
      v4 = &aDevTty[53];
      goto LABEL_7;
    }
  }
  if ( !(unsigned int)sub_414B60() )
  {
    v4 = &aDevTty[42];
    goto LABEL_7;
  }
  if ( !(unsigned int)sub_414B60() )
  {
LABEL_17:
    v4 = &aDevTty[46];
    goto LABEL_7;
  }
  if ( !(unsigned int)sub_414B60() )
    v4 = &aDevTty[53];
LABEL_7:
  result = sub_414FC0(a1, (__int64)v4);
  if ( result == 231 )
    return sub_402B60();
  if ( result )
  {
    do
    {
      if ( *v3 == 47 )
        *v3 = 92;
      ++v3;
    }
    while ( v3 != &v5[result] );
  }
  return result;
}
// 404BF0: variable 'v2' is possibly undefined
// 404BF4: variable 'v3' is possibly undefined
// 404C5B: variable 'a1' is possibly undefined
// 440910: using guessed type __int64 qword_440910;
// 440938: using guessed type __int64 qword_440938;
// 440958: using guessed type __int64 qword_440958;

//----- (0000000000404D00) ----------------------------------------------------
__int64 __fastcall sub_404D00(__int64 a1)
{
  return sub_404BE0(a1, -1);
}

//----- (0000000000404D10) ----------------------------------------------------
__int64 __fastcall sub_404D10(__int64 a1)
{
  void *v1; // rax
  int v2; // eax
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned int v7; // er12
  __int64 v8; // rdx
  __int64 v9; // rcx
  int v11; // eax
  __int64 v12; // [rsp-10h] [rbp-480h]
  __int64 v13; // [rsp-8h] [rbp-478h]
  int v14; // [rsp+Ch] [rbp-464h]
  unsigned int v15; // [rsp+10h] [rbp-460h]
  __int64 v16; // [rsp+20h] [rbp-450h] BYREF
  HANDLE v17[3]; // [rsp+28h] [rbp-448h] BYREF

  sub_41561F(a1, 0x14ui64);
  v17[1] = v1;
  v17[2] = (HANDLE)0x1F01FF001200A0i64;
  sub_405ED5();
  v16 = -1i64;
  v17[0] = (HANDLE)-1i64;
  sub_405EC5();
  if ( v2 )
  {
    GetCurrentProcess();
    if ( sub_405EE5(v3, (HANDLE *)&v16) )
    {
      if ( sub_405EB5(v4, v17) )
      {
        sub_405EA5();
        v5 = v12;
        v6 = v13;
        if ( v11 )
        {
          v7 = v15;
          if ( v15 )
          {
            v7 = 0;
            goto LABEL_4;
          }
          if ( v14 == qword_440770 )
            goto LABEL_4;
        }
      }
    }
  }
  v7 = sub_4162A0();
LABEL_4:
  sub_410160(v6, v5);
  sub_410160(v9, v8);
  return v7;
}
// 404D61: ignored the value written to the shadow area of the succeeding call
// 404D57: ignored the value written to the shadow area of the succeeding call
// 404D4D: ignored the value written to the shadow area of the succeeding call
// 404D43: ignored the value written to the shadow area of the succeeding call
// 404D3B: ignored the value written to the shadow area of the succeeding call
// 404E71: ignored the value written to the shadow area of the succeeding call
// 404E5F: ignored the value written to the shadow area of the succeeding call
// 404D70: variable 'v1' is possibly undefined
// 404DD0: variable 'v2' is possibly undefined
// 404DEF: variable 'v3' is possibly undefined
// 404E06: variable 'v6' is possibly undefined
// 404E06: variable 'v5' is possibly undefined
// 404E11: variable 'v9' is possibly undefined
// 404E11: variable 'v8' is possibly undefined
// 404E3B: variable 'v4' is possibly undefined
// 404E7E: variable 'v12' is possibly undefined
// 404E7F: variable 'v13' is possibly undefined
// 404E82: variable 'v11' is possibly undefined
// 404E88: variable 'v15' is possibly undefined
// 404E94: variable 'v14' is possibly undefined
// 440770: using guessed type __int64 qword_440770;

//----- (0000000000404EB8) ----------------------------------------------------
void __fastcall HandlerRoutine(DWORD CtrlType, double a2, double a3, double a4)
{
  double v4; // xmm0_8

  sub_406024(v4, a2, a3, a4);
}
// 404EBD: variable 'v4' is possibly undefined

//----- (0000000000404ED0) ----------------------------------------------------
__int64 __fastcall sub_404ED0()
{
  int v0; // edi
  __int64 v1; // rbx
  BOOL v2; // eax
  int v3; // er12
  __int64 result; // rax

  v1 = 24i64 * v0;
  if ( *(_DWORD *)(v1 + qword_447B50 + 16) == 1 )
    FlushFileBuffers(*(HANDLE *)(v1 + qword_447B50));
  v2 = sub_405EF5();
  v3 = v2;
  if ( *(_DWORD *)(qword_447B50 + v1 + 16) == 4 )
    v3 = sub_405EF5() && v2;
  result = 0i64;
  if ( !v3 )
    return sub_4162A0();
  return result;
}
// 404ED1: variable 'v0' is possibly undefined
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000404F60) ----------------------------------------------------
__int64 __fastcall sub_404F60()
{
  __int64 v0; // rsi
  BOOL ConsoleMode; // er12
  __int64 v2; // rcx
  int v3; // eax
  char v4; // dl
  int v5; // edx
  DWORD Mode; // [rsp+28h] [rbp-28h] BYREF
  int v8[9]; // [rsp+2Ch] [rbp-24h] BYREF

  ConsoleMode = GetConsoleMode(*(HANDLE *)qword_447B50, &Mode);
  if ( GetConsoleMode(*(HANDLE *)(qword_447B50 + 24), (LPDWORD)v8) || ConsoleMode )
  {
    sub_41561F(v2, 0x38ui64);
    if ( ConsoleMode )
    {
      v4 = Mode;
      if ( (Mode & 2) != 0 )
        *(_DWORD *)(v0 + 12) |= qword_4409A8;
      if ( (v4 & 4) != 0 )
        *(_DWORD *)(v0 + 12) |= 8u;
      if ( (v4 & 1) == 0 )
        return 0i64;
      v5 = *(_DWORD *)(v0 + 12) | qword_4409B0 | qword_4409B8;
      *(_DWORD *)(v0 + 12) = v5;
      if ( !v3 )
        return 0i64;
    }
    else
    {
      if ( !v3 || (Mode & 1) == 0 )
        return 0i64;
      v5 = *(_DWORD *)(v0 + 12) | qword_4409B8 | qword_4409B0;
    }
    *(_DWORD *)(v0 + 12) = v5;
    return 0i64;
  }
  return sub_402BB4();
}
// 404FB2: variable 'v2' is possibly undefined
// 404FCB: variable 'v0' is possibly undefined
// 404FF1: variable 'v3' is possibly undefined
// 4409A8: using guessed type __int64 qword_4409A8;
// 4409B0: using guessed type __int64 qword_4409B0;
// 4409B8: using guessed type __int64 qword_4409B8;
// 447B50: using guessed type __int64 qword_447B50;
// 404F60: using guessed type DWORD var_24[9];

//----- (0000000000405040) ----------------------------------------------------
__int64 __fastcall sub_405040(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  void *v4; // r15
  BOOL ConsoleMode; // ebx
  void *v6; // r14
  unsigned int v7; // er12
  __int64 v8; // rcx
  DWORD v9; // eax
  struct _PEB *v10; // rcx
  int v11; // er9
  unsigned __int16 v12; // dx
  int v13; // eax
  int v14; // edx
  struct _PEB *v15; // rcx
  DWORD Mode; // [rsp+38h] [rbp-38h] BYREF
  int v18[13]; // [rsp+3Ch] [rbp-34h] BYREF

  v4 = *(void **)qword_447B50;
  ConsoleMode = GetConsoleMode(*(HANDLE *)qword_447B50, &Mode);
  v6 = *(void **)(qword_447B50 + 24);
  v7 = GetConsoleMode(v6, (LPDWORD)v18);
  if ( v7 | ConsoleMode )
  {
    if ( ConsoleMode )
    {
      if ( qword_4409E8 == v2 )
        sub_405F38();
      v8 = *(unsigned int *)(a2 + 12);
      v9 = Mode & 0xFFFFFFF8;
      if ( (v8 & qword_4409A8) != 0 )
        v9 = Mode & 0xFFFFFFF8 | 2;
      if ( (v8 & 8) != 0 )
        v9 |= 4u;
      if ( (v8 & (qword_4409B8 | qword_4409B0)) != 0 )
        v9 |= 1u;
      v10 = NtCurrentPeb();
      v11 = v9 | 8;
      v12 = (unsigned __int16)v10->OSMajorVersion << 8;
      Mode = v9 | 8;
      if ( (v10->OSMinorVersion | v12) > 0x9FF )
      {
        Mode = v9 | 0x208;
        v11 = v9 | 0x208;
      }
      SetConsoleMode(v4, v11);
    }
    if ( v7 )
    {
      v13 = v18[0];
      v14 = v18[0] | 3;
      v18[0] |= 3u;
      if ( (*(_BYTE *)(a2 + 4) & 1) == 0 )
      {
        v18[0] = v13 | 0xB;
        v14 = v13 | 0xB;
      }
      v15 = NtCurrentPeb();
      if ( (v15->OSMinorVersion | (unsigned __int16)((unsigned __int16)v15->OSMajorVersion << 8)) > 0x9FF )
      {
        v14 |= 4u;
        v18[0] = v14;
      }
      v7 = 0;
      SetConsoleMode(v6, v14);
    }
  }
  else
  {
    return (unsigned int)sub_402BB4();
  }
  return v7;
}
// 4050AF: variable 'v2' is possibly undefined
// 4409A8: using guessed type __int64 qword_4409A8;
// 4409B0: using guessed type __int64 qword_4409B0;
// 4409B8: using guessed type __int64 qword_4409B8;
// 4409E8: using guessed type __int64 qword_4409E8;
// 447B50: using guessed type __int64 qword_447B50;
// 405040: using guessed type DWORD var_34[13];

//----- (00000000004051D0) ----------------------------------------------------
int __fastcall sub_4051D0()
{
  int v0; // edi
  __int64 v1; // rsi
  int *v2; // r12
  __int64 v3; // rbx
  __int64 v4; // rcx
  int result; // eax
  __int16 v6; // ax
  __int16 dwYCountChars; // dx
  DWORD Mode; // [rsp+0h] [rbp-90h] BYREF
  int v9; // [rsp+4h] [rbp-8Ch] BYREF
  int v10[3]; // [rsp+10h] [rbp-80h] BYREF
  __int16 v11; // [rsp+1Eh] [rbp-72h]
  __int16 v12; // [rsp+20h] [rbp-70h]
  __int16 v13; // [rsp+22h] [rbp-6Eh]
  __int16 v14; // [rsp+24h] [rbp-6Ch]

  v2 = &v9;
  v3 = v0;
  if ( sub_410C50() )
    goto LABEL_6;
LABEL_2:
  if ( sub_410C50() )
  {
LABEL_6:
    while ( !GetConsoleMode(*(HANDLE *)(qword_447B50 + 24 * v3), &Mode) )
    {
      ++v2;
      sub_402BB4();
      if ( v10 == v2 )
        return -1;
LABEL_5:
      v3 = *v2;
      if ( !sub_410C50() )
        goto LABEL_2;
    }
    sub_41561F(v4, 0x60ui64);
    result = sub_405F4B();
    if ( result )
    {
      v6 = v13;
      *(_DWORD *)(v1 + 4) = 0;
      *(_WORD *)(v1 + 2) = v6 + 1 - v11;
      *(_WORD *)v1 = v14 + 1 - v12;
      return 0;
    }
    if ( (StartupInfo.dwFlags & 8) != 0 )
    {
      *(_WORD *)(v1 + 2) = StartupInfo.dwXCountChars;
      dwYCountChars = StartupInfo.dwYCountChars;
      *(_DWORD *)(v1 + 4) = 0;
      *(_WORD *)v1 = dwYCountChars;
      return result;
    }
    sub_4162A0();
  }
  else
  {
    sub_402ACD();
  }
  if ( v10 != ++v2 )
    goto LABEL_5;
  return -1;
}
// 4051FD: ignored the value written to the shadow area of the succeeding call
// 4051F7: ignored the value written to the shadow area of the succeeding call
// 4051EE: variable 'v0' is possibly undefined
// 40529E: variable 'v4' is possibly undefined
// 4052DF: variable 'v1' is possibly undefined
// 447B50: using guessed type __int64 qword_447B50;

//----- (00000000004053A0) ----------------------------------------------------
void __fastcall sub_4053A0(__int64 a1)
{
  int v1; // esi
  __int64 v2; // rax

  if ( (unsigned int)sub_404BE0(a1, v1) != -1 )
  {
    sub_405F08();
    if ( v2 != -1 && (v1 & (unsigned int)qword_440948) != 0 )
      sub_405F28();
  }
}
// 40541A: ignored the value written to the shadow area of the succeeding call
// 4054CE: ignored the value written to the shadow area of the succeeding call
// 4054C7: ignored the value written to the shadow area of the succeeding call
// 4053BB: variable 'v1' is possibly undefined
// 405439: variable 'v2' is possibly undefined
// 440928: using guessed type __int64 qword_440928;
// 440930: using guessed type __int64 qword_440930;
// 440948: using guessed type __int64 qword_440948;
// 440950: using guessed type __int64 qword_440950;

//----- (0000000000405500) ----------------------------------------------------
__int64 __fastcall sub_405500(__int64 a1)
{
  int v1; // esi
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r12
  HANDLE *v5; // r14
  __int64 v6; // rbx
  void *v7; // rax
  __int64 v9; // rbx
  __int64 v10; // rcx
  _QWORD *v11; // r15
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r15
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // [rsp+8h] [rbp-38h]

  v2 = sub_410830(a1);
  v4 = v2;
  if ( v2 == -1 )
    return v4;
  v5 = (HANDLE *)qword_447B50;
  v6 = 24 * v2;
  if ( ((unsigned int)qword_440910 & v1) == qword_440940 && !(unsigned int)sub_414B60() )
  {
    if ( GetFileType(*v5) == 2 && GetFileType(*(HANDLE *)(qword_447B50 + 24)) == 2 )
    {
      v17 = qword_447B50;
      v15 = qword_447B50 + v6;
      *(_QWORD *)v15 = *(_QWORD *)qword_447B50;
      *(_QWORD *)(v15 + 8) = *(_QWORD *)(v17 + 24);
    }
    else
    {
      v11 = (_QWORD *)(v6 + qword_447B50);
      sub_4053A0(v10);
      *v11 = v13;
      if ( v13 == -1 )
        return sub_4162A0();
      v14 = v6 + qword_447B50;
      sub_4053A0(v12);
      v15 = qword_447B50 + v6;
      *(_QWORD *)(v14 + 8) = v16;
    }
    *(_DWORD *)(v15 + 16) = 4;
    *(_DWORD *)(v15 + 20) = v1;
    return v4;
  }
  sub_4053A0(v3);
  v5[(unsigned __int64)v6 / 8] = v7;
  if ( v7 != (void *)-1i64 )
  {
    v9 = qword_447B50 + v6;
    *(_DWORD *)(v9 + 16) = 1;
    *(_DWORD *)(v9 + 20) = v1;
    return v4;
  }
  if ( sub_405F8E() == 80 && (v18 & qword_440928) != 0 && (v18 & qword_440950) != 0 )
    return sub_402B36();
  return sub_4162A0();
}
// 40553F: variable 'v1' is possibly undefined
// 405569: variable 'v3' is possibly undefined
// 40556E: variable 'v7' is possibly undefined
// 405589: variable 'v18' is possibly undefined
// 405636: variable 'v10' is possibly undefined
// 40563B: variable 'v13' is possibly undefined
// 40565C: variable 'v12' is possibly undefined
// 405668: variable 'v16' is possibly undefined
// 440910: using guessed type __int64 qword_440910;
// 440928: using guessed type __int64 qword_440928;
// 440938: using guessed type __int64 qword_440938;
// 440940: using guessed type __int64 qword_440940;
// 440950: using guessed type __int64 qword_440950;
// 440958: using guessed type __int64 qword_440958;
// 447B50: using guessed type __int64 qword_447B50;

//----- (00000000004056C0) ----------------------------------------------------
__int64 __fastcall sub_4056C0(__int64 a1, __int64 a2)
{
  HANDLE *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  BOOL (__stdcall *v5)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED); // r13
  struct _OVERLAPPED *v6; // rax
  __int64 v7; // r8
  void *v8; // rdx
  __int64 result; // rax
  DWORD NumberOfBytesRead; // [rsp+Ch] [rbp-44h] BYREF

  v4 = v3;
  if ( a2 )
  {
    while ( !*(_QWORD *)(v4 + 8) )
    {
      v4 += 16i64;
      if ( !--a2 )
        goto LABEL_10;
    }
    v5 = ReadFile;
    v6 = (struct _OVERLAPPED *)sub_405E00();
    LODWORD(v7) = 2147479552;
    v8 = *(void **)v4;
    if ( *(_QWORD *)(v4 + 8) <= 0x7FFFF000ui64 )
      v7 = *(_QWORD *)(v4 + 8);
  }
  else
  {
LABEL_10:
    v5 = ReadFile;
    v6 = (struct _OVERLAPPED *)sub_405E00();
    LODWORD(v7) = 0;
    v8 = 0i64;
  }
  if ( v5(*v2, v8, v7, &NumberOfBytesRead, v6) )
    return NumberOfBytesRead;
  result = 0i64;
  if ( NtCurrentTeb()->LastErrorValue != 109 )
    return sub_4162A0();
  return result;
}
// 4056CF: variable 'v3' is possibly undefined
// 40571B: variable 'v2' is possibly undefined

//----- (0000000000405790) ----------------------------------------------------
__int64 sub_405790()
{
  __int64 v1; // rax

  if ( (unsigned int)qword_41C0A8() != -1073741515 )
    return 0i64;
  v1 = 16i64;
  do
  {
    _mm_pause();
    --v1;
  }
  while ( v1 );
  return 0i64;
}
// 41C0A8: using guessed type __int64 (*qword_41C0A8)(void);

//----- (00000000004057D0) ----------------------------------------------------
__int64 __fastcall sub_4057D0(__int64 a1)
{
  unsigned int v1; // er12
  __int64 v2; // rax

  v1 = sub_404D00(a1);
  if ( v1 == -1 )
    return v1;
  sub_405F08();
  if ( v2 != -1 )
  {
    v1 = sub_405BC0();
    sub_405EF5();
    return v1;
  }
  return (unsigned int)sub_4162A0();
}
// 405808: ignored the value written to the shadow area of the succeeding call
// 40582B: variable 'v2' is possibly undefined

//----- (0000000000405870) ----------------------------------------------------
__int64 __fastcall sub_405870(__int64 a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // rsi
  __int64 v4; // r14
  _DWORD *v6; // rbx
  __int64 v7; // r14
  DWORD v8; // eax
  __int64 v9; // r15
  __int64 v10; // rcx
  HANDLE CurrentProcess; // rax
  int v12; // er12
  unsigned int v14; // ecx
  __int64 v15; // rdi
  unsigned int v16; // er13
  __int64 i; // rax
  void *v18; // rsi
  __int64 v19; // rdx
  DWORD ExitCode; // [rsp+Ch] [rbp-354h] BYREF
  struct _FILETIME CreationTime; // [rsp+10h] [rbp-350h] BYREF
  struct _FILETIME ExitTime; // [rsp+18h] [rbp-348h] BYREF
  struct _FILETIME KernelTime; // [rsp+20h] [rbp-340h] BYREF
  struct _FILETIME UserTime; // [rsp+28h] [rbp-338h] BYREF
  int v25[64]; // [rsp+30h] [rbp-330h]
  void *hProcess[70]; // [rsp+130h] [rbp-230h]

  v4 = a2;
  v6 = v3;
  if ( v2 == -1 )
  {
    v14 = qword_447B48 - 1;
    if ( (_DWORD)qword_447B48 )
    {
      v15 = qword_447B50;
      v16 = 0;
      for ( i = qword_447B50 + 24i64 * v14; ; i -= 24i64 )
      {
        if ( *(_DWORD *)(i + 16) == 3 )
        {
          v18 = *(void **)i;
          v19 = v16++;
          v25[v19] = v14;
          hProcess[v19] = v18;
          if ( v16 == 64 )
            break;
        }
        --v14;
        if ( v15 == i )
        {
          if ( v16 )
            goto LABEL_4;
          return (unsigned int)sub_402AE2();
        }
      }
      goto LABEL_4;
    }
    return (unsigned int)sub_402AE2();
  }
  if ( !sub_410C50() )
    return (unsigned int)sub_402AE2();
  v25[0] = v2;
  hProcess[0] = *(void **)(qword_447B50 + 24i64 * v2);
LABEL_4:
  v7 = qword_440A08 & v4;
  do
  {
    ExitCode = 259;
    if ( v7 )
    {
      v8 = sub_406004(0, 0);
      if ( v8 == 258 )
        return 0;
    }
    else
    {
      v8 = sub_406004(0xFFFFFFFF, 0);
    }
    if ( v8 != -1 )
    {
      v9 = v8;
      if ( GetExitCodeProcess(hProcess[v8], &ExitCode) )
        continue;
    }
    return (unsigned int)sub_4162A0();
  }
  while ( ExitCode == 259 );
  if ( v6 )
    *v6 = (unsigned __int16)((_WORD)ExitCode << 8);
  if ( a1 )
  {
    sub_41561F(v10, 0x400ui64);
    CurrentProcess = GetCurrentProcess();
    GetProcessTimes(CurrentProcess, &CreationTime, &ExitTime, &KernelTime, &UserTime);
    sub_4124E0();
    sub_4124E0();
  }
  v12 = v25[v9];
  sub_405EF5();
  *(_DWORD *)(qword_447B50 + 24i64 * v12 + 16) = 0;
  return (unsigned int)v12;
}
// 405883: variable 'v3' is possibly undefined
// 405890: variable 'v2' is possibly undefined
// 40596C: variable 'v10' is possibly undefined
// 440A08: using guessed type __int64 qword_440A08;
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;
// 405870: using guessed type int var_330[64];
// 405870: using guessed type HANDLE hProcess[70];

//----- (0000000000405AC0) ----------------------------------------------------
__int64 __fastcall sub_405AC0(__int64 a1, __int64 a2)
{
  HANDLE *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // r12
  __int64 v5; // rbx
  BOOL (__stdcall *v6)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED); // r14
  struct _OVERLAPPED *v7; // rax
  __int64 v8; // r8
  const void *v9; // rdx
  __int64 v10; // r12
  DWORD NumberOfBytesWritten; // [rsp+Ch] [rbp-44h] BYREF

  v4 = a2;
  v5 = v3;
  if ( a2 )
  {
    while ( !*(_QWORD *)(v5 + 8) )
    {
      v5 += 16i64;
      if ( !--v4 )
        goto LABEL_12;
    }
    v6 = WriteFile;
    v7 = (struct _OVERLAPPED *)sub_405E00();
    LODWORD(v8) = 2147479552;
    v9 = *(const void **)v5;
    if ( *(_QWORD *)(v5 + 8) <= 0x7FFFF000ui64 )
      v8 = *(_QWORD *)(v5 + 8);
  }
  else
  {
LABEL_12:
    v6 = WriteFile;
    v4 = 0i64;
    v7 = (struct _OVERLAPPED *)sub_405E00();
    LODWORD(v8) = 0;
    v9 = 0i64;
  }
  if ( !v6(*v2, v9, v8, &NumberOfBytesWritten, v7) )
    return sub_4162A0();
  if ( !NumberOfBytesWritten )
  {
    v10 = v5 + 16 * v4;
    do
      v5 += 16i64;
    while ( v10 != v5 );
  }
  FlushFileBuffers(*v2);
  return NumberOfBytesWritten;
}
// 405AD4: variable 'v3' is possibly undefined
// 405B27: variable 'v2' is possibly undefined

//----- (0000000000405BC0) ----------------------------------------------------
__int64 __fastcall sub_405BC0()
{
  void *v0; // rdi
  __int64 v1; // rsi
  __int64 v2; // rcx
  DWORD FileType; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  __int64 v7; // rdx
  __int64 v8; // rdx
  unsigned __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v15; // [rsp+0h] [rbp-60h] BYREF
  int v16; // [rsp+10h] [rbp-50h]
  unsigned int v17; // [rsp+2Ch] [rbp-34h]
  unsigned int v18; // [rsp+30h] [rbp-30h]
  unsigned int v19; // [rsp+34h] [rbp-2Ch]
  unsigned int v20; // [rsp+38h] [rbp-28h]
  unsigned int v21; // [rsp+3Ch] [rbp-24h]
  unsigned int v22; // [rsp+40h] [rbp-20h]

  if ( !sub_405F6E() )
    return sub_4162A0();
  sub_41561F(v2, 0xE0ui64);
  FileType = GetFileType(v0);
  v5 = (v16 & 1) == 0 ? 448 : 320;
  v4 = v5 | ((_WORD)v16 << 8) & 0x8000;
  BYTE1(v5) |= 0xA0u;
  if ( (v16 & 0x200000) != 0 )
    v4 = v5;
  v6 = 0x4000;
  if ( (v16 & 0x10) == 0 )
  {
    v6 = 24576;
    if ( FileType != 1 )
    {
      v6 = 0x2000;
      if ( FileType != 2 )
      {
        v6 = 4096;
        if ( FileType != 3 )
          v6 = 0;
      }
    }
  }
  *(_DWORD *)(v1 + 24) = v6 | v4;
  *(_QWORD *)(v1 + 72) = sub_4124A0();
  *(_QWORD *)(v1 + 80) = v7;
  *(_QWORD *)(v1 + 88) = sub_4124A0();
  *(_QWORD *)(v1 + 96) = v8;
  v9 = sub_4124A0();
  *(_QWORD *)(v1 + 56) = 4096i64;
  *(_QWORD *)(v1 + 104) = v9;
  v10 = v18;
  *(_QWORD *)(v1 + 112) = v11;
  v12 = v22;
  *(_QWORD *)(v1 + 48) = v19 | (unsigned __int64)(v10 << 32);
  *(_QWORD *)v1 = v17;
  *(_QWORD *)(v1 + 8) = v12 | ((unsigned __int64)v21 << 32);
  *(_QWORD *)(v1 + 16) = v20;
  if ( sub_405F7E(0x10u, &v15) )
    v13 = v15;
  else
    v13 = *(_QWORD *)(v1 + 48);
  *(_QWORD *)(v1 + 64) = ((unsigned __int64)(v13 + 4095) >> 9) & 0x7FFFFFFFFFFFF8i64;
  return 0i64;
}
// 405BF0: variable 'v2' is possibly undefined
// 405BF8: variable 'v0' is possibly undefined
// 405C66: variable 'v1' is possibly undefined
// 405C76: variable 'v7' is possibly undefined
// 405C87: variable 'v8' is possibly undefined
// 405CAC: variable 'v11' is possibly undefined

//----- (0000000000405D40) ----------------------------------------------------
__int64 __fastcall sub_405D40()
{
  const __m128i *v0; // rdi
  __m128i *v1; // rsi
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4[5]; // [rsp+8h] [rbp-28h] BYREF

  if ( v1 )
    *v1 = _mm_loadu_si128(v0);
  v2 = sub_41548B() + 10000000 * v0->m128i_i64[0];
  if ( v2 <= 0 )
    v2 = 1i64;
  v4[0] = -v2;
  if ( (unsigned int)qword_41C0A0(1i64, v4) >> 30 == 3 )
  {
    sub_415469();
    if ( sub_405FE4() == 192 )
      return sub_402B0C();
  }
  result = 0i64;
  if ( v1 )
    *v1 = 0i64;
  return result;
}
// 405D56: variable 'v1' is possibly undefined
// 405D58: variable 'v0' is possibly undefined
// 41C0A0: using guessed type __int64 (__fastcall *qword_41C0A0)(_QWORD, _QWORD);
// 405D40: using guessed type __int64 var_28[5];

//----- (0000000000405E00) ----------------------------------------------------
_OWORD *__fastcall sub_405E00()
{
  __int64 v0; // rdi
  _OWORD *v1; // rsi
  _OWORD *result; // rax

  if ( v0 == -1 )
    return 0i64;
  result = v1;
  v1[1] = 0i64;
  *v1 = 0i64;
  *((_QWORD *)v1 + 2) = v0;
  return result;
}
// 405E04: variable 'v0' is possibly undefined
// 405E0A: variable 'v1' is possibly undefined

//----- (0000000000405E30) ----------------------------------------------------
unsigned __int64 sub_405E30()
{
  unsigned __int64 v0; // r12
  unsigned int (*v1)(void); // rax
  __int64 v3; // [rsp+8h] [rbp-18h]

  v0 = __rdtsc() ^ LODWORD(NtCurrentTeb()->ClientId.UniqueThread) ^ ((unsigned __int64)LODWORD(NtCurrentTeb()->ClientId.UniqueProcess) << 17);
  sub_405F9E();
  v1 = (unsigned int (*)(void))sub_405FB1();
  if ( v1 && v1() )
    v0 ^= HIDWORD(v3) * (int)v3;
  return v0;
}
// 405E8B: variable 'v3' is possibly undefined

//----- (0000000000405E9F) ----------------------------------------------------
__int64 sub_405E9F()
{
  return 3221225781i64;
}

//----- (0000000000405EA5) ----------------------------------------------------
void sub_405EA5()
{
  JUMPOUT(0x406070i64);
}
// 405EB0: control flows out of bounds to 406070

//----- (0000000000405EB5) ----------------------------------------------------
BOOL __fastcall sub_405EB5(__int64 a1, HANDLE *a2)
{
  void *v2; // rdi
  SECURITY_IMPERSONATION_LEVEL v3; // esi

  return DuplicateToken(v2, v3, a2);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000405EC5) ----------------------------------------------------
void sub_405EC5()
{
  JUMPOUT(0x406076i64);
}
// 405ED0: control flows out of bounds to 406076

//----- (0000000000405ED5) ----------------------------------------------------
void __fastcall sub_405ED5()
{
  DWORD *v0; // rdi
  GENERIC_MAPPING *v1; // rsi

  MapGenericMask(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000405EE5) ----------------------------------------------------
BOOL __fastcall sub_405EE5(__int64 a1, HANDLE *a2)
{
  void *v2; // rdi
  DWORD v3; // esi

  return OpenProcessToken(v2, v3, a2);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000405EF5) ----------------------------------------------------
BOOL __fastcall sub_405EF5()
{
  void *v0; // rdi

  return CloseHandle(v0);
}
// 405F00: variable 'v0' is possibly undefined

//----- (0000000000405F08) ----------------------------------------------------
void sub_405F08()
{
  JUMPOUT(0x406070i64);
}
// 405F13: control flows out of bounds to 406070

//----- (0000000000405F18) ----------------------------------------------------
BOOL __fastcall sub_405F18(DWORD a1, struct _SECURITY_ATTRIBUTES *a2)
{
  HANDLE *v2; // rdi
  HANDLE *v3; // rsi

  return CreatePipe(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000405F28) ----------------------------------------------------
void sub_405F28()
{
  JUMPOUT(0x406070i64);
}
// 405F33: control flows out of bounds to 406070

//----- (0000000000405F38) ----------------------------------------------------
BOOL __fastcall sub_405F38()
{
  void *v0; // rdi

  return FlushConsoleInputBuffer(v0);
}
// 405F43: variable 'v0' is possibly undefined

//----- (0000000000405F4B) ----------------------------------------------------
BOOL __fastcall sub_405F4B()
{
  void *v0; // rdi
  struct _CONSOLE_SCREEN_BUFFER_INFOEX *v1; // rsi

  return GetConsoleScreenBufferInfoEx(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000405F5B) ----------------------------------------------------
DWORD __fastcall sub_405F5B()
{
  const WCHAR *v0; // rdi

  return GetFileAttributesW(v0);
}
// 405F66: variable 'v0' is possibly undefined

//----- (0000000000405F6E) ----------------------------------------------------
BOOL __fastcall sub_405F6E()
{
  void *v0; // rdi
  struct _BY_HANDLE_FILE_INFORMATION *v1; // rsi

  return GetFileInformationByHandle(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000405F7E) ----------------------------------------------------
BOOL __fastcall sub_405F7E(DWORD a1, void *a2)
{
  void *v2; // rdi
  FILE_INFO_BY_HANDLE_CLASS v3; // esi

  return GetFileInformationByHandleEx(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000405F8E) ----------------------------------------------------
DWORD sub_405F8E()
{
  return GetLastError();
}

//----- (0000000000405F9E) ----------------------------------------------------
HMODULE __fastcall sub_405F9E()
{
  const CHAR *v0; // rdi

  return GetModuleHandleA(v0);
}
// 405FA9: variable 'v0' is possibly undefined

//----- (0000000000405FB1) ----------------------------------------------------
FARPROC __fastcall sub_405FB1()
{
  HMODULE v0; // rdi
  const CHAR *v1; // rsi

  return GetProcAddress(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000405FC1) ----------------------------------------------------
void __fastcall sub_405FC1()
{
  struct _FILETIME *v0; // rdi

  GetSystemTimeAsFileTime(v0);
}
// 405FCC: variable 'v0' is possibly undefined

//----- (0000000000405FD4) ----------------------------------------------------
void sub_405FD4()
{
  JUMPOUT(0x406076i64);
}
// 405FDF: control flows out of bounds to 406076

//----- (0000000000405FE4) ----------------------------------------------------
DWORD __fastcall sub_405FE4()
{
  DWORD v0; // edi
  BOOL v1; // esi

  return SleepEx(v0, v1);
}
// 40608A: variable 'v0' is possibly undefined
// 40608A: variable 'v1' is possibly undefined

//----- (0000000000405FF4) ----------------------------------------------------
BOOL __fastcall sub_405FF4(DWORD *a1, DWORD a2)
{
  void *v2; // rdi
  SIZE_T v3; // rsi

  return VirtualProtect(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000406004) ----------------------------------------------------
DWORD __fastcall sub_406004(DWORD a1, BOOL a2)
{
  DWORD v2; // edi
  const HANDLE *v3; // rsi

  return WaitForMultipleObjects(v2, v3, a2, a1);
}
// 40608A: variable 'v2' is possibly undefined
// 40608A: variable 'v3' is possibly undefined

//----- (0000000000406014) ----------------------------------------------------
void sub_406014()
{
  JUMPOUT(0x406076i64);
}
// 40601F: control flows out of bounds to 406076

//----- (0000000000406024) ----------------------------------------------------
void __fastcall sub_406024(double a1, double a2, double a3, double a4)
{
  void (__fastcall *v4)(__int64, __int64); // rax
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned __int64 v7; // [rsp-8h] [rbp-120h]

  __readeflags();
  sub_41633B(a1, a2, a3, a4);
  v4(v6, v5);
  sub_4162C8();
  __writeeflags(v7);
}
// 406032: ignored the value written to the shadow area of the succeeding call
// 40604D: variable 'v4' is possibly undefined
// 40604D: variable 'v6' is possibly undefined
// 40604D: variable 'v5' is possibly undefined
// 406058: variable 'v7' is possibly undefined

//----- (00000000004060A0) ----------------------------------------------------
__int64 sub_4060A0()
{
  __int64 v0; // r14
  __int64 v1; // rdx
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rdi
  __int64 v8; // rax
  unsigned __int64 v9; // r8
  __int64 v10; // r10
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // r11
  unsigned __int64 v16; // rax
  __int64 v17; // rsi
  __int64 v18; // r10
  unsigned __int64 v19; // r9
  unsigned __int64 v20; // rsi
  unsigned __int64 v21; // rdi
  __int64 v22; // r11
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r11
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // r13
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // r14
  unsigned __int64 v31; // r10
  __int64 v32; // r8
  unsigned __int64 v33; // rdi
  unsigned __int64 v34; // r13
  unsigned __int64 v35; // r8
  unsigned __int64 v36; // r11
  unsigned __int64 v37; // r14
  unsigned __int64 v38; // r10
  unsigned __int64 v39; // r11
  unsigned __int64 v40; // rdx
  unsigned __int64 v41; // r11
  unsigned __int64 v42; // r13
  unsigned __int64 v43; // r11
  __int64 v44; // rsi
  __int64 result; // rax
  __int64 v46; // [rsp+0h] [rbp-A0h]
  __int64 v47; // [rsp+8h] [rbp-98h]
  __int64 v48; // [rsp+10h] [rbp-90h]
  __int64 v49; // [rsp+18h] [rbp-88h]
  __int64 v50; // [rsp+20h] [rbp-80h]
  __int64 v51; // [rsp+38h] [rbp-68h]
  __int64 v52; // [rsp+40h] [rbp-60h]
  __int64 v53; // [rsp+48h] [rbp-58h]
  unsigned __int64 v54; // [rsp+50h] [rbp-50h]
  __int64 v55; // [rsp+58h] [rbp-48h]
  __int64 v56; // [rsp+60h] [rbp-40h]
  __int64 v57; // [rsp+68h] [rbp-38h]
  __int64 v58; // [rsp+70h] [rbp-30h]

  v0 = qword_446408;
  v49 = qword_446450 >> 3;
  v58 = qword_446448 >> 3;
  v46 = qword_446400;
  if ( qword_446450 >> 3 > 0 )
  {
    v52 = qword_446400;
    v48 = 8 * (qword_446448 >> 3);
    v53 = qword_446408;
    v57 = 0i64;
    v50 = 0i64;
    v47 = qword_446408;
    do
    {
      v1 = v50++;
      if ( v58 > 0 )
      {
        v2 = v49 - 1;
        if ( v1 )
          v2 = v1 - 1;
        v3 = v58 * v2;
        v56 = v58 * v2;
        v4 = 0i64;
        if ( v49 > v50 )
          v4 = v50;
        v55 = v58 * v4;
        v5 = 0i64;
        v51 = v47 + 8 * v58 * v4;
        do
        {
          v18 = v5 - 1;
          v19 = *(_QWORD *)(v53 + 8 * v5);
          v20 = v19 << 8;
          v54 = *(_QWORD *)(v47 + 8 * v3 + 8 * v5);
          v21 = HIBYTE(v54);
          if ( !v5 )
            v18 = v58 - 1;
          v22 = *(_QWORD *)(v47 + 8 * (v18 + v57)) >> 7;
          v23 = (v22 << 8) & 0x101010101010100i64 | ((2 * HIBYTE(v54)) | (v19 << 9)) & 0xFEFEFEFEFEFEFEFEui64 | (*(_QWORD *)(v47 + 8 * (v56 + v18)) >> 63);
          v24 = (2 * v19) & 0xFEFEFEFEFEFEFEFEui64 | v22 & 0x101010101010101i64;
          v25 = v24 & v23;
          v26 = v24 ^ v23;
          v27 = (*(_QWORD *)(v47 + 8 * (v55 + v18)) << 49) & 0x100000000000000i64 | (*(_QWORD *)(v47 + 8 * (v18 + v57)) >> 15) & 0x1010101010101i64 | (2 * (v19 >> 8)) & 0xFEFEFEFEFEFEFEFEui64 | (*(_QWORD *)(v51 + 8 * v5) << 57);
          v28 = v26 & v27;
          v29 = v27 ^ v26;
          v30 = v28 ^ v25;
          v31 = v28;
          v32 = v20 | v21;
          v33 = v29 ^ (v20 | v21);
          v34 = v29 & v32;
          v35 = v29 & v32 ^ v30;
          v36 = v34 & v30 | v31 & v25;
          v37 = *(_QWORD *)(v51 + 8 * v5) << 56;
          v38 = v36;
          ++v5;
          v39 = v37 | (v19 >> 8);
          v40 = v33 ^ v39;
          v41 = v33 & v39;
          v42 = v41 ^ v35;
          v43 = v38 | v35 & v41;
          v44 = (v54 >> 57) | (v20 >> 1) & 0x7F7F7F7F7F7F7F7Fi64;
          if ( v5 < v58 )
          {
            v6 = v57 + v5;
            v7 = v5 + v55;
            v8 = v5 + v56;
          }
          else
          {
            v7 = v55;
            v8 = v56;
            v6 = v57;
          }
          v9 = *(_QWORD *)(v47 + 8 * v6);
          v10 = v9 << 15;
          v9 <<= 7;
          v11 = v44 | v10 & 0x8080808080808000ui64 | (*(_QWORD *)(v47 + 8 * v8) >> 49) & 0x80i64;
          v12 = v40 & v11;
          v13 = v11 ^ v40;
          v14 = v12 ^ v42;
          v15 = v12 & v42 | v43;
          v16 = (v19 >> 1) & 0x7F7F7F7F7F7F7F7Fi64 | v9 & 0x8080808080808080ui64;
          v17 = (*(_QWORD *)(v47 + 8 * v7) << 63) | ((v19 >> 9) | (v37 >> 1)) & 0x7F7F7F7F7F7F7F7Fi64;
          *(_QWORD *)(v52 + 8 * v5 - 8) = ~(v13 & v16 & v14 | v15 | (v16 ^ v13) & (v17 | (v9 >> 8) & 0x80808080808080i64) & (v13 & v16 ^ v14)) & ((v16 ^ v13) & (v17 | (v9 >> 8) & 0x80808080808080i64) ^ v13 & v16 ^ v14) & ((v17 | (v9 >> 8) & 0x80808080808080i64) ^ v16 ^ v13 | v19);
        }
        while ( v5 != v58 );
      }
      v57 += v58;
      v52 += v48;
      v53 += v48;
    }
    while ( v49 != v50 );
    v0 = v47;
  }
  result = v46;
  qword_446400 = v0;
  ++qword_446410;
  qword_446408 = v46;
  return result;
}
// 446400: using guessed type __int64 qword_446400;
// 446408: using guessed type __int64 qword_446408;
// 446410: using guessed type __int64 qword_446410;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;

//----- (00000000004064D0) ----------------------------------------------------
__int64 sub_4064D0()
{
  __int64 v0; // rdx
  __int64 v1; // rax
  __int64 result; // rax

  if ( byte_4464A0 )
  {
    v0 = qword_446470;
    v1 = qword_446480;
  }
  else
  {
    byte_4464A0 = 1;
    v1 = qword_446450 / 2 - qword_446460 / 2;
    qword_446480 = v1;
    v0 = qword_446448 / 2 - qword_446458 / 2;
    qword_446470 = v0;
  }
  result = qword_446460 + v1;
  qword_446468 = qword_446458 + v0;
  qword_446478 = result;
  return result;
}
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;
// 4464A0: using guessed type char byte_4464A0;

//----- (0000000000406570) ----------------------------------------------------
__int64 __fastcall sub_406570()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 result; // rax

  v2 = qword_446460;
  if ( qword_446440 )
    v2 = 2 * qword_446460;
  qword_446480 += v0 << qword_446440;
  qword_446470 += v1 << qword_446440;
  qword_446478 = qword_446480 + (v2 << qword_446440);
  result = qword_446458 << qword_446440;
  qword_446468 = (qword_446458 << qword_446440) + qword_446470;
  return result;
}
// 406589: variable 'v0' is possibly undefined
// 406593: variable 'v1' is possibly undefined
// 446440: using guessed type __int64 qword_446440;
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;

//----- (00000000004065D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4065D0()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  unsigned __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 *v5; // r8
  __int64 v6; // rdx

  result = qword_446440;
  qword_446430 = v0;
  byte_4464A1 = 1;
  qword_446428 = v1;
  byte_4464A5 = 0;
  v3 = qword_446480 + (v0 << ((unsigned __int8)qword_446440 + (qword_446440 != 0)));
  if ( v3 >= 0 )
  {
    v4 = qword_446470 + (v1 << qword_446440);
    if ( qword_446450 > v3 && v4 >= 0 )
    {
      result = qword_446448;
      if ( qword_446448 > v4 )
      {
        v5 = (__int64 *)(qword_446408 + 8 * ((v4 >> 3) + (v3 >> 3) * (qword_446448 >> 3)));
        v6 = *v5;
        result = ((unsigned __int64)*v5 >> (v4 & 7 | (8 * v3) & 0x38)) & 1;
        byte_4464A5 = result;
        if ( (_BYTE)result )
        {
          result = (v4 >> 3) + (v3 >> 3) * (qword_446448 >> 3);
          *(_QWORD *)(qword_446408 + 8 * result) &= __ROL8__(-2i64, v4 & 7 | (8 * v3) & 0x38);
        }
        else
        {
          _bittestandset64(&v6, v4 & 7 | (8 * (_BYTE)v3) & 0x38);
          *v5 = v6;
        }
      }
    }
  }
  return result;
}
// 4065D9: variable 'v0' is possibly undefined
// 4065F1: variable 'v1' is possibly undefined
// 446408: using guessed type __int64 qword_446408;
// 446428: using guessed type __int64 qword_446428;
// 446430: using guessed type __int64 qword_446430;
// 446440: using guessed type __int64 qword_446440;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446470: using guessed type __int64 qword_446470;
// 446480: using guessed type __int64 qword_446480;
// 4464A1: using guessed type char byte_4464A1;
// 4464A5: using guessed type char byte_4464A5;

//----- (00000000004066A0) ----------------------------------------------------
__int64 __fastcall sub_4066A0()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rsi
  __int64 v5; // rcx
  __int64 result; // rax

  v2 = (qword_446430 - v0) << qword_446440;
  v3 = (qword_446428 - v1) << qword_446440;
  if ( qword_446440 )
    v2 *= 2i64;
  if ( byte_4464A3 )
  {
    v2 = -v2;
    v3 = -v3;
  }
  v4 = qword_446478 - qword_446480;
  v5 = qword_446468 - qword_446470;
  qword_446480 = qword_446420 + v2;
  result = v4 + qword_446420 + v2;
  qword_446470 = qword_446418 + v3;
  qword_446478 = result;
  qword_446468 = v5 + qword_446418 + v3;
  return result;
}
// 4066B5: variable 'v0' is possibly undefined
// 4066BB: variable 'v1' is possibly undefined
// 446418: using guessed type __int64 qword_446418;
// 446420: using guessed type __int64 qword_446420;
// 446428: using guessed type __int64 qword_446428;
// 446430: using guessed type __int64 qword_446430;
// 446440: using guessed type __int64 qword_446440;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;
// 4464A3: using guessed type char byte_4464A3;

//----- (0000000000406750) ----------------------------------------------------
void __noreturn sub_406750()
{
  __int64 v0; // rcx
  __int64 v1; // rcx
  __int64 v2; // rcx
  __int64 v3; // rdx
  unsigned __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  sub_41571A();
  sub_411A10(v0);
  sub_41571A();
  sub_411A10(v1);
  sub_41571A();
  sub_411A10(v2);
  sub_40286F(v4, v3, v5, v6);
}
// 406773: variable 'v0' is possibly undefined
// 406790: variable 'v1' is possibly undefined
// 4067AB: variable 'v2' is possibly undefined
// 4067B3: variable 'v4' is possibly undefined
// 4067B3: variable 'v3' is possibly undefined
// 4067B3: variable 'v5' is possibly undefined
// 4067B3: variable 'v6' is possibly undefined

//----- (00000000004067C0) ----------------------------------------------------
__int64 __fastcall sub_4067C0()
{
  unsigned __int64 *v0; // rdi
  unsigned __int64 v1; // rbx
  __int64 v2; // r13

  v1 = ((((qword_446448 * qword_446450) >> 3) + 4095) & 0xFFFFFFFFFFFFF000ui64) + 73727;
  LOWORD(v1) = 0;
  v2 = sub_40F370((unsigned int)qword_4408C8 | 2, 3u, -1, 0i64);
  sub_416180();
  sub_416180();
  if ( v0 )
    *v0 = v1;
  return v2 + 4096;
}
// 406848: variable 'v0' is possibly undefined
// 4408C8: using guessed type __int64 qword_4408C8;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;

//----- (0000000000406860) ----------------------------------------------------
__int64 sub_406860()
{
  __int64 result; // rax

  ++dword_446494;
  result = sub_40AA80();
  if ( (_DWORD)result != -1 && (_DWORD)result == 10 )
  {
    ++dword_446498;
    dword_446494 = 0;
  }
  return result;
}
// 446494: using guessed type int dword_446494;
// 446498: using guessed type int dword_446498;

//----- (00000000004068A0) ----------------------------------------------------
void __fastcall sub_4068A0(__int64 a1)
{
  unsigned int v1; // esi
  int v2; // er8
  unsigned int v3; // er14
  __int64 v4; // rbx
  __int64 v5; // r9
  unsigned int v6; // eax
  __int64 v7; // rax

  v2 = dword_4463E0;
  v3 = v1 + dword_4463E0 + 1;
  if ( v3 <= dword_4463E4 )
    goto LABEL_2;
  v6 = dword_4463E4 + ((unsigned int)dword_4463E4 >> 1);
  if ( v6 < 0x10 )
    v6 = 16;
  if ( v6 >= v3 )
    v3 = v6;
  v7 = sub_40B70D(a1, 16i64);
  if ( v7 )
  {
    qword_4463E8 = v7;
    v2 = dword_4463E0;
    dword_4463E4 = v3;
LABEL_2:
    v4 = v2 + v1;
    dword_4463E0 = v2 + v1;
    sub_4154C0(a1, v1);
    *(_BYTE *)(v5 + v4) = 0;
  }
}
// 4068BD: variable 'v1' is possibly undefined
// 4068E8: variable 'a1' is possibly undefined
// 4068ED: variable 'v5' is possibly undefined
// 40B70D: using guessed type __int64 __fastcall sub_40B70D(_QWORD, _QWORD);
// 4463E0: using guessed type int dword_4463E0;
// 4463E4: using guessed type int dword_4463E4;
// 4463E8: using guessed type __int64 qword_4463E8;

//----- (0000000000406950) ----------------------------------------------------
__int64 sub_406950()
{
  __int64 result; // rax
  int v1; // eax
  __int64 v2; // rcx
  unsigned int v3; // eax
  __int64 v4; // rdx

LABEL_1:
  result = sub_406860();
  if ( (_DWORD)result == -1 )
    return 0xFFFFFFFFi64;
  if ( (_DWORD)result == 35 && dword_446494 == 1 )
  {
    while ( 1 )
    {
      v1 = sub_406860();
      if ( v1 == -1 )
        return 0xFFFFFFFFi64;
      while ( v1 != 13 )
      {
        if ( v1 == 10 )
        {
          if ( dword_4463E0 && *(_BYTE *)qword_4463E8 == 78 && (unsigned int)dword_4463E0 > 2 )
          {
            v3 = dword_4463E0 - 2;
            if ( (unsigned int)(dword_4463E0 - 2) > 0x3F )
              v3 = 63;
            sub_4154C0(v2, v3);
            *((_BYTE *)&qword_446360 + v4) = 0;
          }
          goto LABEL_1;
        }
        sub_4068A0(v2);
        v1 = sub_406860();
        if ( v1 == -1 )
          return 0xFFFFFFFFi64;
      }
    }
  }
  return result;
}
// 406997: ignored the value written to the shadow area of the succeeding call
// 40699A: variable 'v2' is possibly undefined
// 4069FA: variable 'v4' is possibly undefined
// 446360: using guessed type __int64 qword_446360;
// 4463E0: using guessed type int dword_4463E0;
// 4463E8: using guessed type __int64 qword_4463E8;
// 446494: using guessed type int dword_446494;

//----- (0000000000406A10) ----------------------------------------------------
__int64 sub_406A10()
{
  __int64 i; // rbx
  int v1; // eax
  __int64 v2; // rax
  int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // r13
  int v7; // eax
  __int64 v8; // rcx
  int v9; // eax
  __int64 v10; // r15
  __int64 v11; // rdi
  __int64 v12; // r14
  int v13; // eax
  int v14; // ebx
  unsigned int v15; // ecx
  __int64 v16; // rdx
  __int64 j; // rbx
  __int64 v18; // r9
  __int64 v19; // rax
  __int64 v20; // r10
  __int64 v21; // rsi
  __int64 v22; // rdi
  int v23; // eax
  __int64 v24; // [rsp+0h] [rbp-50h]
  __int64 v25; // [rsp+8h] [rbp-48h]
  __int64 v26; // [rsp+10h] [rbp-40h]
  __int64 v27; // [rsp+18h] [rbp-38h]

  dword_446498 = 0;
  sub_40AAD0();
  if ( (unsigned int)sub_406950() == 120
    && (unsigned int)sub_406950() == 32
    && (unsigned int)sub_406950() == 61
    && (unsigned int)sub_406950() == 32 )
  {
    for ( i = 0i64; ; i = v1 + 10 * i - 48 )
    {
      v1 = sub_406950();
      if ( v1 == -1 )
        break;
      if ( (unsigned int)(v1 - 48) > 9 )
      {
        while ( 1 )
        {
          v4 = sub_406950();
          v5 = v4;
          if ( v4 == -1 )
            goto LABEL_9;
          if ( (unsigned int)(v4 - 48) <= 9 )
          {
            v6 = 0i64;
            while ( 1 )
            {
              v6 = v5 + 10 * v6 - 48;
              v7 = sub_406950();
              v5 = v7;
              if ( v7 == -1 )
                goto LABEL_9;
              if ( (unsigned int)(v7 - 48) > 9 )
              {
                while ( v5 != 10 )
                {
                  v9 = sub_406860();
                  v5 = v9;
                  if ( v9 == -1 )
                    goto LABEL_9;
                }
                if ( qword_446450 >= v6 && qword_446448 >= i )
                {
                  v10 = 0i64;
                  v11 = qword_446400;
                  v12 = 0i64;
                  qword_446400 = qword_446408;
                  qword_446408 = v11;
                  sub_41561F(v8, (qword_446448 * qword_446450) >> 3);
                  while ( 1 )
                  {
                    v13 = sub_406950();
                    v14 = v13;
                    if ( v13 == -1 )
                      break;
                    if ( v13 == 33i64 )
                    {
                      sub_40A890();
                      byte_4464A0 = 0;
                      return 0i64;
                    }
                    if ( !(unsigned int)sub_4148D0() )
                    {
                      v15 = v14 - 48;
                      v16 = v27;
                      j = 1i64;
                      if ( v15 <= 9 )
                      {
                        for ( j = v27 - 48; ; j = v23 + 10 * j - 48 )
                        {
                          v23 = sub_406950();
                          v16 = v23;
                          if ( v23 == -1 )
                            break;
                          if ( (unsigned int)(v23 - 48) > 9 )
                            goto LABEL_26;
                        }
                        goto LABEL_9;
                      }
LABEL_26:
                      if ( v16 == 36 )
                      {
                        ++v12;
                        v10 = 0i64;
                        if ( v6 == v12 )
                          v12 = 0i64;
                      }
                      else
                      {
                        if ( v16 != 98 && v16 != 111 )
                          goto LABEL_9;
                        if ( j > 0 )
                        {
                          v18 = qword_446408;
                          v19 = 0i64;
                          v20 = qword_446448 >> 3;
                          do
                          {
                            if ( v24 > v10 )
                            {
                              v21 = v10++;
                            }
                            else
                            {
                              ++v12;
                              v21 = 0i64;
                              v10 = 1i64;
                              if ( v6 == v12 )
                                v12 = 0i64;
                            }
                            if ( v16 == 111 )
                            {
                              v22 = v20 * ((v12 + v26) >> 3) + ((v25 + v21) >> 3);
                              *(_QWORD *)(v18 + 8 * v22) |= 1i64 << ((v25 + v21) & 7 | (8 * (v12 + v26)) & 0x38);
                            }
                            ++v19;
                          }
                          while ( j != v19 );
                        }
                      }
                    }
                  }
                }
                goto LABEL_9;
              }
            }
          }
        }
      }
    }
  }
LABEL_9:
  sub_40A890();
  v2 = qword_446408;
  qword_446408 = qword_446400;
  qword_446400 = v2;
  return 0xFFFFFFFFi64;
}
// 406B63: ignored the value written to the shadow area of the succeeding call
// 406D1A: ignored the value written to the shadow area of the succeeding call
// 406B8D: variable 'v8' is possibly undefined
// 406C0B: variable 'v27' is possibly undefined
// 406C88: variable 'v26' is possibly undefined
// 406C9D: variable 'v25' is possibly undefined
// 406CC8: variable 'v24' is possibly undefined
// 446400: using guessed type __int64 qword_446400;
// 446408: using guessed type __int64 qword_446408;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446498: using guessed type int dword_446498;
// 4464A0: using guessed type char byte_4464A0;

//----- (0000000000406D30) ----------------------------------------------------
__int64 sub_406D30()
{
  __int64 v0; // r11
  __int64 v1; // r10
  __int64 v2; // r9
  __int64 v3; // rax
  unsigned __int64 *v4; // rbx
  __int64 v5; // r12
  unsigned __int64 v6; // rdi
  __int64 v7; // rax
  int v9; // [rsp+Ch] [rbp-64h]
  __int64 v10; // [rsp+10h] [rbp-60h]
  __int64 v11; // [rsp+20h] [rbp-50h]
  __int64 v12; // [rsp+28h] [rbp-48h]
  __int64 v13; // [rsp+30h] [rbp-40h]

  v0 = qword_446468;
  v1 = qword_446480;
  v2 = qword_446470;
  v3 = (qword_446450 * qword_446448) >> 6;
  if ( v3 <= 0 )
  {
    v5 = 0i64;
  }
  else
  {
    v4 = (unsigned __int64 *)qword_446408;
    v5 = 0i64;
    v9 = unk_41C020 & 0x800000;
    v10 = qword_446408 + 8 * v3;
    do
    {
      while ( 1 )
      {
        v6 = *v4;
        if ( !v9 )
          break;
        ++v4;
        v5 += __popcnt(v6);
        if ( (unsigned __int64 *)v10 == v4 )
          return sub_413AC0((__int64)&qword_446360, asc_417230, qword_446410, v5);
      }
      ++v4;
      v11 = v2;
      v12 = v1;
      v13 = v0;
      v7 = sub_40ECB0();
      v2 = v11;
      v1 = v12;
      v0 = v13;
      v5 += v7;
    }
    while ( (unsigned __int64 *)v10 != v4 );
  }
  return sub_413AC0((__int64)&qword_446360, asc_417230, qword_446410, v5);
}
// 406DD4: ignored the value written to the shadow area of the succeeding call
// 406E34: ignored the value written to the shadow area of the succeeding call
// 406E32: ignored the value written to the shadow area of the succeeding call
// 406E30: ignored the value written to the shadow area of the succeeding call
// 406E2A: ignored the value written to the shadow area of the succeeding call
// 406DC8: variable 'v10' is possibly undefined
// 406DD2: variable 'v9' is possibly undefined
// 417230: using guessed type char asc_417230;
// 446360: using guessed type __int64 qword_446360;
// 446408: using guessed type __int64 qword_446408;
// 446410: using guessed type __int64 qword_446410;
// 446440: using guessed type __int64 qword_446440;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;

//----- (0000000000406E60) ----------------------------------------------------
void __fastcall sub_406E60()
{
  __int64 v0; // rax
  __int64 v1; // rdi
  __int64 v2; // rsi
  __int64 v3; // r15
  char v4; // r13
  char v5; // r12
  __int64 v6; // rdi
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // [rsp+8h] [rbp-38h]

  v3 = v2;
  if ( qword_446430 != v1 || qword_446428 != v2 )
  {
    v4 = qword_446440;
    qword_446430 = v1;
    qword_446428 = v2;
    v5 = qword_446440 + (qword_446440 != 0);
    v6 = qword_446480 + (v1 << v5);
    v7 = v6 + (sub_412150() & ~(-1i64 << v5));
    v8 = sub_412150();
    if ( v7 >= 0 )
    {
      v9 = v8 & ~(-1i64 << v4);
      v10 = v9 + (v2 << v4) + v12;
      if ( qword_446450 > v7 && v10 >= 0 && qword_446448 > v10 )
      {
        if ( byte_4464A5 )
        {
          v0 = (v10 >> 3) + (v7 >> 3) * (qword_446448 >> 3);
          *(_QWORD *)(qword_446408 + 8 * v0) &= __ROL8__(-2i64, v10 & 7 | (8 * v7) & 0x38);
        }
        else
        {
          v11 = ((v9 + (v3 << v4) + v12) >> 3) + (v7 >> 3) * (qword_446448 >> 3);
          *(_QWORD *)(qword_446408 + 8 * v11) |= 1i64 << (v10 & 7 | (8 * v7) & 0x38);
        }
      }
    }
  }
}
// 406EB3: ignored the value written to the shadow area of the succeeding call
// 406E66: variable 'v2' is possibly undefined
// 406E7B: variable 'v1' is possibly undefined
// 406F05: variable 'v12' is possibly undefined
// 446408: using guessed type __int64 qword_446408;
// 446428: using guessed type __int64 qword_446428;
// 446430: using guessed type __int64 qword_446430;
// 446440: using guessed type __int64 qword_446440;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446470: using guessed type __int64 qword_446470;
// 446480: using guessed type __int64 qword_446480;
// 4464A5: using guessed type char byte_4464A5;

//----- (0000000000406FA0) ----------------------------------------------------
BOOL __fastcall sub_406FA0(__int64 a1)
{
  const __m128i *v1; // rax
  BOOL result; // eax
  __int64 v3; // rcx
  const __m128i *v4; // [rsp+30h] [rbp-370h]

  sub_41561F(a1, 0x98ui64);
  v4 = v1;
  result = sub_402DCA();
  if ( result )
  {
    sub_414E40(v3, v4);
    if ( (unsigned int)sub_406A10() == -1 )
      sub_402CA2(0x10u, L"Open Failed");
    return sub_402CC5(1u, 0i64);
  }
  return result;
}
// 406FEC: ignored the value written to the shadow area of the succeeding call
// 406FD4: ignored the value written to the shadow area of the succeeding call
// 406FCA: ignored the value written to the shadow area of the succeeding call
// 406FDB: variable 'v1' is possibly undefined
// 40702B: variable 'v3' is possibly undefined
// 417710: using guessed type wchar_t aOpenFailed[12];

//----- (0000000000407080) ----------------------------------------------------
__int64 sub_407080()
{
  __int64 v0; // rcx
  __int64 v1; // rcx
  __int64 v2; // rcx
  __int64 v3; // rcx

  sub_41571A();
  sub_411A10(v0);
  sub_41571A();
  sub_411A10(v1);
  byte_4464A2 = 0;
  sub_41571A();
  sub_411A10(v2);
  return sub_410A90(v3, (__int64)&unk_4463A0);
}
// 40709A: variable 'v0' is possibly undefined
// 4070B5: variable 'v1' is possibly undefined
// 4070D7: variable 'v2' is possibly undefined
// 4070EF: variable 'v3' is possibly undefined
// 4464A2: using guessed type char byte_4464A2;

//----- (0000000000407100) ----------------------------------------------------
__int64 sub_407100()
{
  __int64 result; // rax
  unsigned __int16 v1; // [rsp+8h] [rbp-8h]
  unsigned __int16 v2; // [rsp+Ah] [rbp-6h]

  sub_409CE0();
  qword_446458 = v2;
  qword_446468 = qword_446470 + v2;
  qword_446460 = v1 - 1;
  result = qword_446480 + qword_446460;
  qword_446478 = qword_446480 + qword_446460;
  return result;
}
// 407127: ignored the value written to the shadow area of the succeeding call
// 40711C: ignored the value written to the shadow area of the succeeding call
// 40713B: variable 'v2' is possibly undefined
// 407130: variable 'v1' is possibly undefined
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;

//----- (0000000000407170) ----------------------------------------------------
void __fastcall sub_407170(__int64 a1, int a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rdx

  if ( v2 >= 0 && qword_446460 > v2 && v3 >= 0 && qword_446458 > v3 )
  {
    v4 = 0i64;
    v5 = qword_446440 + a2;
    if ( v5 >= 0 )
      v4 = v5;
    if ( v4 > 14 )
      v4 = 14i64;
    qword_446440 = v4;
    sub_406570();
  }
}
// 407173: variable 'v2' is possibly undefined
// 407181: variable 'v3' is possibly undefined
// 446440: using guessed type __int64 qword_446440;
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;

//----- (0000000000407200) ----------------------------------------------------
LRESULT __fastcall sub_407200(LPARAM a1, WPARAM a2)
{
  unsigned int v2; // esi
  WPARAM v3; // r13
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // rax
  HDC v10; // r13
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  int v14; // ebx
  int v15; // er10
  int v16; // edx
  __int64 v17; // r14
  int v18; // er15
  __int64 v19; // rsi
  __int64 v20; // r11
  __int64 v21; // rcx
  __int64 v22; // rcx
  unsigned int v23; // ecx
  int v24; // er13
  __int64 v25; // r14
  int v26; // er15
  __int64 v27; // rbx
  unsigned int v28; // [rsp+8h] [rbp-A8h]
  int v29; // [rsp+1Ch] [rbp-94h]
  int y; // [rsp+24h] [rbp-8Ch]
  int v31; // [rsp+28h] [rbp-88h]
  int v32; // [rsp+2Ch] [rbp-84h]
  int v33; // [rsp+38h] [rbp-78h]
  int v34; // [rsp+3Ch] [rbp-74h]
  int v35; // [rsp+40h] [rbp-70h]
  int v36; // [rsp+44h] [rbp-6Ch]
  int v37; // [rsp+48h] [rbp-68h]

  if ( v2 > 0x205 )
    return sub_402C0F(a1, a2);
  if ( v2 > 0x1FF )
  {
    switch ( v2 )
    {
      case 0x200u:
        v3 = a2 & 1;
        if ( (a2 & 1) != 0 )
        {
          sub_406E60();
LABEL_21:
          v3 = 0i64;
          sub_402CC5(1u, 0i64);
        }
        else
        {
          if ( (a2 & 2) == 0 )
            return 0i64;
          sub_4066A0();
          sub_402CC5(1u, 0i64);
        }
        break;
      case 0x201u:
        sub_402D08();
        sub_4065D0();
        goto LABEL_21;
      case 0x202u:
        byte_4464A1 = 0;
        v3 = 0i64;
        sub_402CE8();
        return v3;
      case 0x204u:
        qword_4463F0 = (__int64)sub_402C52();
        sub_402D08();
        sub_402C92();
        sub_402D1B();
        byte_4464A1 = 1;
        qword_446428 = (unsigned __int16)v28;
        qword_446430 = HIWORD(v28);
        qword_446420 = qword_446480;
        qword_446418 = qword_446470;
        goto LABEL_24;
      case 0x205u:
        byte_4464A1 = 0;
        v3 = 0i64;
        sub_402D1B();
        sub_402CE8();
        return v3;
      default:
        return sub_402C0F(a1, a2);
    }
    return v3;
  }
  if ( v2 == 15 )
  {
    sub_402BEF();
    v5 = -(qword_446480 + v35);
    v6 = v36 - v34;
    if ( qword_446480 + v35 > 0 )
      LODWORD(v5) = 0;
    v7 = qword_446470 + v34;
    y = v5;
    v8 = -v7;
    if ( v7 > 0 )
      LODWORD(v8) = 0;
    if ( qword_446448 - v7 <= v6 )
      LODWORD(v6) = qword_446448 - v7;
    v31 = v6;
    v9 = qword_446450 - (qword_446480 + v35);
    if ( v9 > v37 - v35 )
      LODWORD(v9) = v37 - v35;
    v32 = v9;
    v10 = sub_402D81();
    sub_402D71(v11, v29);
    sub_402DBA();
    sub_402C42(v12, (HBRUSH)0xB);
    sub_402C42(v13, (HBRUSH)0xC);
    v14 = y;
    if ( y < v32 )
    {
      v15 = v34;
      v16 = v35;
      v17 = y;
      do
      {
        v18 = v8;
        if ( (int)v8 < v31 )
        {
          v19 = (int)v8;
          do
          {
            v20 = v19 + qword_446470 + v15;
            v21 = *(_QWORD *)(qword_446408 + 8 * ((v20 >> 3) + ((v17 + qword_446480 + v16) >> 3) * (qword_446448 >> 3)));
            if ( _bittest64(&v21, v20 & 7 | (8 * ((_BYTE)v17 + (_BYTE)qword_446480 + (_BYTE)v16)) & 0x38) )
            {
              SetPixel(v10, v18, v14, 0);
              v16 = v35;
              v15 = v34;
            }
            ++v18;
            ++v19;
          }
          while ( v18 < v31 );
        }
        ++v14;
        ++v17;
      }
      while ( v14 < v32 );
    }
    sub_402D61();
    sub_402DA7();
    v3 = 0i64;
    sub_402D94();
    sub_406D30();
    sub_414FC0(v22, (__int64)&unk_446260);
    sub_402D2E();
    sub_402C32();
    return v3;
  }
  if ( v2 <= 0xF )
  {
    if ( v2 == 2 )
    {
      v3 = 0i64;
      sub_402CB2();
      return v3;
    }
    if ( v2 == 5 )
    {
      v3 = 0i64;
      qword_446458 = (unsigned __int16)a1;
      qword_446460 = WORD1(a1);
      sub_4064D0();
      return v3;
    }
    return sub_402C0F(a1, a2);
  }
  if ( v2 != 258 )
  {
    if ( v2 - 273 <= 1 )
    {
      if ( (a2 & 0xFFFFFFFFFFFFFFF0ui64) == 16 )
      {
        v3 = 0i64;
        sub_402CA2(0x40u, L"Conway's Game of Life");
        return v3;
      }
      if ( (a2 & 0xFFFFFFFFFFFFFFF0ui64) == 32 )
      {
        sub_406FA0(a1);
        return 0i64;
      }
    }
    return sub_402C0F(a1, a2);
  }
  if ( a2 != 32 )
  {
    if ( a2 > 0x20 )
    {
      if ( a2 != 115 )
      {
        if ( a2 == 116 )
        {
          v23 = a1 & 0x20000000;
          v3 = v23;
          if ( !v23 )
          {
            ++qword_446438;
            return v3;
          }
          if ( qword_446438 - 1 <= 0 )
          {
            qword_446438 = 1i64;
            return 0i64;
          }
          --qword_446438;
        }
        return 0i64;
      }
    }
    else if ( a2 != 9 )
    {
      if ( a2 == 13 )
      {
        if ( sub_402C82() && v33 == 3 )
        {
          sub_402CF8(0i64, 0xF120ui64);
          return 0i64;
        }
        sub_402CF8(0i64, 0xF030ui64);
      }
      return 0i64;
    }
  }
  v24 = (unsigned __int16)a1;
  if ( (_WORD)a1 )
  {
    v25 = qword_446438;
    v26 = 0;
    do
    {
      v27 = 0i64;
      if ( v25 > 0 )
      {
        do
        {
          sub_4060A0();
          ++v27;
        }
        while ( v27 != v25 );
      }
      ++v26;
    }
    while ( v24 != v26 );
  }
LABEL_24:
  sub_402CC5(1u, 0i64);
  return 0i64;
}
// 407389: ignored the value written to the shadow area of the succeeding call
// 4074F7: ignored the value written to the shadow area of the succeeding call
// 407642: ignored the value written to the shadow area of the succeeding call
// 407640: ignored the value written to the shadow area of the succeeding call
// 40763B: ignored the value written to the shadow area of the succeeding call
// 40721D: variable 'v2' is possibly undefined
// 4073CE: variable 'v28' is possibly undefined
// 407439: variable 'v35' is possibly undefined
// 407473: variable 'v36' is possibly undefined
// 407473: variable 'v34' is possibly undefined
// 407455: variable 'v37' is possibly undefined
// 4074EC: variable 'v11' is possibly undefined
// 4074EC: variable 'v29' is possibly undefined
// 407512: variable 'v12' is possibly undefined
// 407526: variable 'v13' is possibly undefined
// 407678: variable 'v22' is possibly undefined
// 4076DC: variable 'v33' is possibly undefined
// 4177B0: using guessed type wchar_t aConwaySGameOfL[22];
// 4463F0: using guessed type __int64 qword_4463F0;
// 446408: using guessed type __int64 qword_446408;
// 446418: using guessed type __int64 qword_446418;
// 446420: using guessed type __int64 qword_446420;
// 446428: using guessed type __int64 qword_446428;
// 446430: using guessed type __int64 qword_446430;
// 446438: using guessed type __int64 qword_446438;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446458: using guessed type __int64 qword_446458;
// 446460: using guessed type __int64 qword_446460;
// 446470: using guessed type __int64 qword_446470;
// 446480: using guessed type __int64 qword_446480;
// 4464A1: using guessed type char byte_4464A1;

//----- (0000000000407850) ----------------------------------------------------
void __fastcall sub_407850(__int64 a1)
{
  int v1; // edi
  unsigned __int8 v2; // si
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx

  if ( *((_DWORD *)&qword_446488 + v2) != v1 )
  {
    sub_4068A0(a1);
    sub_412600();
    sub_4068A0(v3);
    sub_4068A0(v4);
    sub_412600();
    sub_4068A0(v5);
    sub_4068A0(v6);
    *((_DWORD *)&qword_446488 + v2) = v1;
  }
}
// 407859: variable 'v2' is possibly undefined
// 407868: variable 'v1' is possibly undefined
// 40789C: variable 'v3' is possibly undefined
// 4078AB: variable 'v4' is possibly undefined
// 4078C3: variable 'v5' is possibly undefined
// 4078D2: variable 'v6' is possibly undefined
// 446488: using guessed type __int64 qword_446488;

//----- (00000000004078F0) ----------------------------------------------------
__int64 __fastcall sub_4078F0(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // r15
  __int64 v5; // r13
  __int64 v6; // r12
  __int64 v7; // r14
  __int64 v8; // rdx
  __int64 v9; // rbx
  __int64 v10; // rcx
  _BYTE *v11; // rdx
  __int64 v12; // rcx
  char *v13; // r8
  __int64 v14; // rcx
  __int64 v15; // r12
  __int64 v16; // rcx
  __int64 v18; // r12
  signed __int64 v19; // r14
  unsigned __int64 v20; // r13
  signed __int64 v21; // r15
  __int64 v22; // rbx
  __int64 v23; // r8
  signed __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // r11
  __int64 v27; // r12
  bool v28; // cc
  __int64 v29; // r15
  __int64 v30; // r9
  __int64 v31; // rsi
  __int64 v32; // rdi
  _BYTE *v33; // rax
  __int64 v34; // r9
  __int64 v35; // r15
  __int64 v36; // r14
  __int64 v37; // r8
  __int64 v38; // rcx
  __int64 v39; // r15
  __int64 v40; // rbx
  __int64 v41; // rcx
  __int64 v42; // rcx
  unsigned int v43; // esi
  __int64 v44; // rsi
  char v45; // di
  __int64 v46; // rcx
  __int64 v47; // rcx
  __int64 v48; // [rsp+0h] [rbp-70h]
  __int64 v49; // [rsp+10h] [rbp-60h]
  __int64 v50; // [rsp+18h] [rbp-58h]
  unsigned __int8 v51; // [rsp+18h] [rbp-58h]
  __int64 v52; // [rsp+20h] [rbp-50h]
  __int64 v53; // [rsp+20h] [rbp-50h]
  signed __int64 v54; // [rsp+28h] [rbp-48h]
  __int64 v55; // [rsp+30h] [rbp-40h]
  __int64 v56; // [rsp+30h] [rbp-40h]
  signed __int64 v57; // [rsp+38h] [rbp-38h]
  __int64 v58; // [rsp+38h] [rbp-38h]
  __int64 v59; // [rsp+38h] [rbp-38h]

  dword_4463E0 = 0;
  qword_446488 = -1i64;
  sub_4068A0(a1);
  v52 = qword_446440;
  if ( qword_446440 )
  {
    v18 = qword_446480;
    v54 = qword_446470 & 0xFFFFFFFFFFFFFFF0ui64;
    v19 = qword_446480 & 0xFFFFFFFFFFFFFFF0ui64;
    v20 = ((qword_446478 + 15) & 0xFFFFFFFFFFFFFFF0ui64) - (qword_446480 & 0xFFFFFFFFFFFFFFF0ui64);
    v57 = (qword_446478 + 15) & 0xFFFFFFFFFFFFFFF0ui64;
    v21 = (qword_446468 + 15) & 0xFFFFFFFFFFFFFFF0ui64;
    v22 = v21 - (qword_446470 & 0xFFFFFFFFFFFFFFF0ui64);
    v56 = sub_40B6FB();
    if ( v56 )
    {
      v24 = 0i64;
      v25 = v57;
      if ( v19 < 0 )
        v19 = 0i64;
      if ( qword_446450 <= v57 )
        v25 = qword_446450;
      if ( v19 < v25 )
      {
        v26 = v21;
        v48 = v18;
        v27 = v25;
        v28 = v21 <= qword_446448;
        v29 = qword_446408;
        if ( !v28 )
          v26 = qword_446448;
        v58 = qword_446448 >> 3;
        v25 = v54;
        if ( v54 >= 0 )
          v24 = v54;
        v30 = v24;
        v23 = v56 + v22 * (v19 - v49) - v54;
        do
        {
          if ( v26 > v30 )
          {
            v31 = v30;
            do
            {
              v32 = 8i64;
              v25 = *(_QWORD *)(v29 + 8 * (v58 * (v19 >> 3) + (v31 >> 3)));
              v33 = (_BYTE *)(v31 + v23);
              do
              {
                *v33 = -(v25 & 1);
                v33[1] = -((v25 & 2) != 0);
                v33[2] = -((v25 & 4) != 0);
                v33[3] = -((v25 & 8) != 0);
                v33[4] = -((v25 & 0x10) != 0);
                v33[5] = -((v25 & 0x20) != 0);
                v33[6] = -((v25 & 0x40) != 0);
                v3 = (unsigned int)v25;
                v25 = (unsigned __int64)v25 >> 8;
                LOBYTE(v3) = (char)v3 >> 7;
                v33[7] = v3;
                v33 += v22;
                --v32;
              }
              while ( v32 );
              v31 += 8i64;
            }
            while ( v31 < v26 );
          }
          v19 += 8i64;
          v23 += 8 * v22;
        }
        while ( v19 < v27 );
        v18 = v48;
      }
      v34 = 0i64;
      v35 = v22;
      v36 = v20;
      if ( v52 > 0 )
      {
        do
        {
          v59 = v34;
          sub_408250(v36, v56, v35);
          v37 = v35;
          v38 = v36;
          v36 >>= 1;
          v35 >>= 1;
          sub_4082B0(v38, v56, v37);
          v34 = v59 + 1;
        }
        while ( v59 + 1 < qword_446440 );
        v18 = qword_446480;
        v50 = qword_446478;
      }
      if ( v18 < v50 )
      {
        v53 = v22;
        v39 = v49;
        do
        {
          v40 = qword_446470;
          if ( qword_446470 >= qword_446468 )
          {
            v43 = qword_446440;
          }
          else
          {
            do
            {
              if ( v18 >= 0
                && qword_446450 > v18
                && v40 >= 0
                && qword_446448 > v40
                && ((v44 = v56 + ((v40 - v54) >> qword_446440),
                     v18 + (1i64 << qword_446440) >= (unsigned __int64)qword_446478) ? (v45 = *(_BYTE *)(v44 + v53 * ((v18 - v39) >> qword_446440)),
                                                                                        v3 = 0i64) : (v3 = *(unsigned __int8 *)(v44 + v53 * ((v18 + 1 - v39) >> qword_446440)), v45 = v3 | *(_BYTE *)(v44 + v53 * ((v18 - v39) >> qword_446440))),
                    v45) )
              {
                sub_407850(v3);
                v46 = v51;
                if ( byte_4464A4 )
                  v46 = 487 - (unsigned int)(unsigned __int8)(int)((double)v51 * 0.00390625 * 24.0 + 232.0);
                sub_407850(v46);
                sub_4068A0(v47);
              }
              else
              {
                sub_407850(v3);
                sub_407850(v41);
                sub_4068A0(v42);
              }
              v3 = qword_446440;
              v43 = qword_446440;
              v40 += 1i64 << qword_446440;
            }
            while ( v40 < qword_446468 );
          }
          v3 = v43;
          v18 += 2i64 << v43;
        }
        while ( v18 < qword_446478 );
      }
      sub_40B701(v3, v25, v23, v34);
    }
  }
  else
  {
    sub_407850(v1);
    sub_407850(v2);
    v4 = qword_446480;
    v5 = qword_446470;
    v6 = qword_446468;
    v55 = qword_446478;
    if ( qword_446480 < qword_446478 )
    {
      do
      {
        if ( v5 < v6 )
        {
          v7 = v5;
          do
          {
            while ( 1 )
            {
              if ( v4 >= 0 && qword_446450 > v4 && v7 >= 0 && qword_446448 > v7 )
              {
                v8 = *(_QWORD *)(qword_446408 + 8 * ((v7 >> 3) + (v4 >> 3) * (qword_446448 >> 3)));
                if ( _bittest64(&v8, (8 * (_BYTE)v4) & 0x38 | (unsigned int)(v7 & 7)) )
                  break;
              }
              sub_4068A0(v3);
              if ( ++v7 == v6 )
                goto LABEL_12;
            }
            ++v7;
            sub_4068A0(v3);
          }
          while ( v7 != v6 );
        }
LABEL_12:
        ++v4;
      }
      while ( v4 != v55 );
    }
  }
  v9 = 0i64;
  sub_4068A0(v3);
  sub_406D30();
  sub_41571A();
  sub_4068A0(v10);
  v15 = qword_446458 - (int)sub_40A570(v12, v11, v13);
  if ( v15 > 0 )
  {
    do
    {
      ++v9;
      sub_4068A0(v14);
    }
    while ( v15 != v9 );
  }
  sub_4068A0(v14);
  return sub_411A10(v16);
}
// 407EB2: ignored the value written to the shadow area of the succeeding call
// 407B50: ignored the value written to the shadow area of the succeeding call
// 407B1D: ignored the value written to the shadow area of the succeeding call
// 407950: variable 'v1' is possibly undefined
// 407969: variable 'v2' is possibly undefined
// 4079D2: variable 'v3' is possibly undefined
// 407A80: variable 'v10' is possibly undefined
// 407A8A: variable 'v12' is possibly undefined
// 407A8A: variable 'v11' is possibly undefined
// 407A8A: variable 'v13' is possibly undefined
// 407AAE: variable 'v14' is possibly undefined
// 407AE8: variable 'v16' is possibly undefined
// 407BE0: variable 'v49' is possibly undefined
// 407D4F: variable 'v50' is possibly undefined
// 407DC0: variable 'v41' is possibly undefined
// 407DCF: variable 'v42' is possibly undefined
// 407EBA: variable 'v51' is possibly undefined
// 407F0A: variable 'v47' is possibly undefined
// 407F3E: variable 'v25' is possibly undefined
// 407F3E: variable 'v23' is possibly undefined
// 407F3E: variable 'v34' is possibly undefined
// 40B6FB: using guessed type __int64 sub_40B6FB(void);
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 4463E0: using guessed type int dword_4463E0;
// 4463E8: using guessed type __int64 qword_4463E8;
// 446408: using guessed type __int64 qword_446408;
// 446440: using guessed type __int64 qword_446440;
// 446448: using guessed type __int64 qword_446448;
// 446450: using guessed type __int64 qword_446450;
// 446458: using guessed type __int64 qword_446458;
// 446468: using guessed type __int64 qword_446468;
// 446470: using guessed type __int64 qword_446470;
// 446478: using guessed type __int64 qword_446478;
// 446480: using guessed type __int64 qword_446480;
// 446488: using guessed type __int64 qword_446488;
// 4464A4: using guessed type char byte_4464A4;

//----- (0000000000407FAA) ----------------------------------------------------
void __fastcall sub_407FAA(double a1, double a2, double a3, double a4)
{
  sub_406024(a1, a2, a3, a4);
}

//----- (0000000000407FC0) ----------------------------------------------------
__int64 __fastcall sub_407FC0(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4)
{
  int v4; // edi
  __int64 v5; // rsi
  char *v7; // rax
  _BYTE *v8; // rax
  _BYTE *v9; // r15
  unsigned int v10; // er12
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v14; // rcx
  int v15; // edx
  int v16; // eax

  if ( !dword_447FE8 )
    dword_447FE8 = 1;
  if ( !dword_447FE0 )
  {
    v7 = (char *)qword_447FD0;
    if ( *(_BYTE *)qword_447FD0 )
    {
      v9 = (_BYTE *)++qword_447FD0;
      v10 = *v7;
      dword_447FE4 = v10;
      goto LABEL_18;
    }
  }
  dword_447FE0 = 0;
  v8 = *(_BYTE **)(v5 + 8i64 * dword_447FE8);
  if ( dword_447FE8 >= v4 || (qword_447FD0 = (__int64)(v8 + 1), *v8 != 45) )
  {
LABEL_26:
    qword_447FD0 = 4489160i64;
    return (unsigned int)-1;
  }
  v9 = v8 + 2;
  qword_447FD0 = (__int64)(v8 + 2);
  v10 = (char)v8[1];
  dword_447FE4 = v10;
  if ( v10 == 45 )
  {
    if ( v8[2] )
      goto LABEL_11;
    ++dword_447FE8;
    goto LABEL_26;
  }
  if ( !v10 )
  {
    qword_447FD0 = 4489160i64;
    sub_41576B();
    if ( v11 )
    {
      dword_447FE4 = 45;
      v9 = &unk_447FC8;
LABEL_11:
      v10 = 45;
      goto LABEL_12;
    }
    return (unsigned int)-1;
  }
LABEL_18:
  if ( v10 == 58 )
  {
LABEL_19:
    if ( !*v9 )
      ++dword_447FE8;
    if ( dword_447FEC && *a2 != 58 )
    {
      v14 = v10;
      v10 = 63;
      sub_40AD00(v14, qword_41C710, a3, a4);
      return v10;
    }
    return 63;
  }
LABEL_12:
  sub_41576B();
  if ( !v12 )
    goto LABEL_19;
  if ( *(_BYTE *)(v12 + 1) == 58 )
  {
    v15 = dword_447FE8;
    v16 = dword_447FE8 + 1;
    if ( *v9 )
    {
      qword_447FD8 = (__int64)v9;
      goto LABEL_35;
    }
    ++dword_447FE8;
    if ( v4 > v16 )
    {
      qword_447FD8 = *(_QWORD *)(v5 + 8i64 * v16);
      v16 = v15 + 2;
LABEL_35:
      qword_447FD0 = 4489160i64;
      dword_447FE8 = v16;
      return v10;
    }
    qword_447FD0 = 4489160i64;
    if ( *a2 == 58 )
      return 58;
    if ( dword_447FEC )
      sub_40AD00(v10, qword_41C710, a3, a4);
    return 63;
  }
  qword_447FD8 = 0i64;
  if ( !*v9 )
    ++dword_447FE8;
  return v10;
}
// 40801C: variable 'v5' is possibly undefined
// 408023: variable 'v4' is possibly undefined
// 408082: variable 'v11' is possibly undefined
// 4080AC: variable 'v12' is possibly undefined
// 408146: variable 'a3' is possibly undefined
// 408146: variable 'a4' is possibly undefined
// 41C710: using guessed type __int64 qword_41C710;
// 447FD0: using guessed type __int64 qword_447FD0;
// 447FD8: using guessed type __int64 qword_447FD8;
// 447FE0: using guessed type int dword_447FE0;
// 447FE4: using guessed type int dword_447FE4;
// 447FE8: using guessed type int dword_447FE8;
// 447FEC: using guessed type int dword_447FEC;

//----- (0000000000408230) ----------------------------------------------------
int __fastcall sub_408230(__int64 a1, __int64 a2)
{
  if ( (dword_41C718 & 4) != 0 )
    return sub_402DE0(a1, a2);
  else
    return qword_41C720(a1, a2);
}
// 41C718: using guessed type int dword_41C718;
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000408250) ----------------------------------------------------
__int64 __fastcall sub_408250(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v5; // r12
  __int64 i; // rbx
  __int64 v8; // [rsp+8h] [rbp-38h]

  v8 = a2;
  if ( a3 > 1 && a1 > 0 )
  {
    v5 = a2;
    for ( i = 0i64; i != a1; ++i )
    {
      sub_4097E0(a1, (__int8 *)&qword_447FF8);
      v5 += v3;
    }
  }
  return v8;
}
// 40828F: variable 'a1' is possibly undefined
// 408294: variable 'v3' is possibly undefined
// 40829C: variable 'v8' is possibly undefined
// 447FF8: using guessed type __int64 qword_447FF8;

//----- (00000000004082B0) ----------------------------------------------------
__int64 __fastcall sub_4082B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __m128i si128; // xmm4
  __m128i v5; // xmm15
  __m128i v6; // xmm12
  __m128i v7; // xmm13
  __m128i v8; // xmm14
  __m128i v9; // xmm11
  __m128i v10; // xmm15
  __m128i v11; // xmm10
  __m128i v12; // xmm14
  __m128i v13; // xmm13
  __m128i v14; // xmm0
  __m128i v15; // xmm12
  __m128i v16; // xmm9
  __m128i v17; // xmm11
  __m128i v18; // xmm10
  __m128i v19; // xmm9
  __int64 v20; // rax
  __int64 v21; // r10
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // r10
  __int64 v25; // r8
  __int64 v26; // r8
  __int64 v27; // r15
  __int64 v28; // r9
  __int64 v29; // r14
  __int64 v30; // rdx
  __int64 v31; // r13
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rdi
  __int64 v35; // rdi
  __int64 v36; // rsi
  __int64 v37; // rax
  __int64 v38; // rsi
  __int64 v39; // rax
  __int64 v40; // rbx
  __int64 v41; // rax
  __m128i v42; // xmm3
  __m128i v43; // xmm1
  __m128i v44; // xmm0
  __m128i v45; // xmm5
  __m128i v46; // xmm1
  __m128i v47; // xmm0
  __m128i v48; // xmm3
  __m128i v49; // xmm5
  __int64 v50; // rax
  __int16 v51; // r10
  __int64 v52; // rax
  char v53; // r8
  __int16 v54; // dx
  unsigned __int64 v56; // [rsp+8h] [rbp-F8h]
  unsigned __int64 v57; // [rsp+10h] [rbp-F0h]
  unsigned __int64 v58; // [rsp+18h] [rbp-E8h]
  __int64 v59; // [rsp+20h] [rbp-E0h]
  __int64 v60; // [rsp+28h] [rbp-D8h]
  __int64 v61; // [rsp+30h] [rbp-D0h]
  __int64 v62; // [rsp+38h] [rbp-C8h]
  __int64 v63; // [rsp+40h] [rbp-C0h]
  __int64 v64; // [rsp+48h] [rbp-B8h]
  __int64 v65; // [rsp+50h] [rbp-B0h]
  __int64 v66; // [rsp+58h] [rbp-A8h]
  unsigned int v68; // [rsp+68h] [rbp-98h]
  unsigned int v69; // [rsp+6Ch] [rbp-94h]
  int v70; // [rsp+70h] [rbp-90h]
  int v71; // [rsp+74h] [rbp-8Ch]
  __int64 v72; // [rsp+78h] [rbp-88h]
  __int64 v73; // [rsp+80h] [rbp-80h]
  __int64 v74; // [rsp+88h] [rbp-78h]
  __int64 v75; // [rsp+90h] [rbp-70h]
  __int64 v77; // [rsp+A0h] [rbp-60h]
  __int64 v78; // [rsp+A8h] [rbp-58h]
  __int64 v79; // [rsp+B0h] [rbp-50h]
  __int64 v80; // [rsp+B8h] [rbp-48h]
  __m128i v81; // [rsp+C0h] [rbp-40h]

  v64 = v3;
  v60 = (a1 + 1) / 2;
  if ( a1 + 1 > 1 && a3 > 0 )
  {
    v80 = a2;
    si128 = _mm_load_si128((const __m128i *)&xmmword_418710);
    LOWORD(v68) = (char)qword_447FF8;
    v62 = 0i64;
    v70 = (int)((_DWORD)qword_447FF8 << 8) >> 24;
    LOWORD(v69) = (__int16)qword_447FF8 >> 8;
    v5 = _mm_cvtsi32_si128(v68);
    v66 = 16i64;
    v6 = _mm_cvtsi32_si128((int)qword_447FF8 >> 24);
    v72 = qword_447FF8 << 24 >> 56;
    v7 = _mm_cvtsi32_si128(v70);
    v8 = _mm_cvtsi32_si128(v69);
    v71 = (int)qword_447FF8 >> 24;
    v63 = -3i64;
    v73 = qword_447FF8 << 16 >> 56;
    v9 = _mm_cvtsi32_si128(v72);
    v75 = qword_447FF8 >> 56;
    v65 = 0i64;
    v10 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v5, v5), 0);
    v74 = qword_447FF8 << 8 >> 56;
    v11 = _mm_cvtsi32_si128(v73);
    v12 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v8, v8), 0);
    v13 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v7, v7), 0);
    v57 = a3 & 0xFFFFFFFFFFFFFFF0ui64;
    v14 = _mm_cvtsi32_si128(qword_447FF8 >> 56);
    v15 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v6, v6), 0);
    v16 = _mm_cvtsi32_si128(v74);
    v56 = a3 & 0xFFFFFFFFFFFFFFF0ui64;
    v81 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v14, v14), 0);
    v17 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v9, v9), 0);
    v59 = a1 - 1;
    v18 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v11, v11), 0);
    v19 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v16, v16), 0);
    v58 = a3 - 1;
    do
    {
      v20 = v63;
      ++v65;
      v21 = 0i64;
      v22 = 0i64;
      v23 = v63 + 3;
      if ( v63 >= 0 )
        v21 = v63;
      v24 = v64 * v21;
      v25 = v63 + 1;
      if ( v63 + 1 < 0 )
        v25 = 0i64;
      v26 = v64 * v25;
      v27 = a2 + v24;
      if ( v63 + 2 >= 0 )
        v22 = v63 + 2;
      v63 += 2i64;
      v28 = v64 * v22;
      v29 = a2 + v26;
      if ( v23 > v59 )
        v23 = v59;
      v30 = v64 * v23;
      v31 = a2 + v28;
      v61 = a2 + v30;
      v32 = v20 + 4;
      if ( v20 + 4 > v59 )
        v32 = v59;
      v33 = v64 * v32;
      v34 = 2 * v65;
      v77 = a2 + v33;
      if ( 2 * v65 > v59 )
        v34 = v59;
      v35 = v64 * v34;
      v78 = v35 + a2;
      v36 = v20 + 6;
      if ( v20 + 6 > v59 )
        v36 = v59;
      v37 = v20 + 7;
      v38 = v64 * v36;
      if ( v37 > v59 )
        v37 = v59;
      v79 = v38 + a2;
      v39 = v64 * v37;
      v40 = a2 + v39;
      if ( (v26 >= v66 || v62 >= v26 + 16)
        && (v28 >= v66 || v62 >= v28 + 16)
        && (v30 >= v66 || v62 >= v30 + 16)
        && (v33 >= v66 || v62 >= v33 + 16)
        && (v38 >= v66 || v62 >= v38 + 16)
        && (v39 >= v66 || v62 >= v39 + 16)
        && v58 > 0xE
        && (v24 >= v66 || v62 >= v24 + 16)
        && (v35 >= v66 || v62 >= v35 + 16) )
      {
        v41 = 0i64;
        do
        {
          v42 = _mm_loadu_si128((const __m128i *)(v61 + v41));
          v43 = _mm_loadu_si128((const __m128i *)(v27 + v41));
          v44 = _mm_loadu_si128((const __m128i *)(v31 + v41));
          v45 = _mm_add_epi16(
                  _mm_add_epi16(
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v44, (__m128i)0i64), v13),
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v42, (__m128i)0i64), v15)),
                  _mm_add_epi16(
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v43, (__m128i)0i64), v10),
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v29 + v41)), (__m128i)0i64),
                      v12)));
          v46 = _mm_srai_epi16(
                  _mm_add_epi16(
                    _mm_add_epi16(
                      _mm_add_epi16(
                        _mm_add_epi16(
                          _mm_mullo_epi16(_mm_unpacklo_epi8(v43, (__m128i)0i64), v10),
                          _mm_mullo_epi16(
                            _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v29 + v41)), (__m128i)0i64),
                            v12)),
                        _mm_add_epi16(
                          _mm_mullo_epi16(_mm_unpacklo_epi8(v44, (__m128i)0i64), v13),
                          _mm_mullo_epi16(_mm_unpacklo_epi8(v42, (__m128i)0i64), v15))),
                      _mm_add_epi16(
                        _mm_add_epi16(
                          _mm_mullo_epi16(
                            _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v77 + v41)), (__m128i)0i64),
                            v17),
                          _mm_mullo_epi16(
                            _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v78 + v41)), (__m128i)0i64),
                            v18)),
                        (__m128i)xmmword_418700)),
                    _mm_add_epi16(
                      _mm_mullo_epi16(
                        _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v79 + v41)), (__m128i)0i64),
                        v19),
                      _mm_mullo_epi16(
                        _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v40 + v41)), (__m128i)0i64),
                        v81))),
                  5u);
          v47 = _mm_srai_epi16(
                  _mm_add_epi16(
                    _mm_add_epi16(
                      v45,
                      _mm_add_epi16(
                        _mm_add_epi16(
                          _mm_mullo_epi16(
                            _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v77 + v41)), (__m128i)0i64),
                            v17),
                          _mm_mullo_epi16(
                            _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v78 + v41)), (__m128i)0i64),
                            v18)),
                        (__m128i)xmmword_418700)),
                    _mm_add_epi16(
                      _mm_mullo_epi16(
                        _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v79 + v41)), (__m128i)0i64),
                        v19),
                      _mm_mullo_epi16(
                        _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v40 + v41)), (__m128i)0i64),
                        v81))),
                  5u);
          v48 = _mm_packus_epi16(
                  _mm_and_si128(_mm_cmpeq_epi16(_mm_subs_epu16(v46, si128), (__m128i)0i64), si128),
                  _mm_and_si128(_mm_cmpeq_epi16(_mm_subs_epu16(v47, si128), (__m128i)0i64), si128));
          v49 = _mm_packus_epi16(
                  _mm_and_si128(_mm_cmpgt_epi16(v46, si128), si128),
                  _mm_and_si128(_mm_cmpgt_epi16(v47, si128), si128));
          *(__m128i *)(v80 + v41) = _mm_or_si128(
                                      _mm_and_si128(
                                        _mm_packus_epi16(_mm_and_si128(si128, v46), _mm_and_si128(si128, v47)),
                                        v48),
                                      _mm_andnot_si128(
                                        v48,
                                        _mm_or_si128(
                                          v49,
                                          _mm_andnot_si128(
                                            v49,
                                            _mm_packus_epi16(
                                              _mm_andnot_si128(_mm_cmpgt_epi16((__m128i)0i64, v46), si128),
                                              _mm_andnot_si128(_mm_cmpgt_epi16((__m128i)0i64, v47), si128))))));
          v41 += 16i64;
        }
        while ( v57 != v41 );
        v50 = v56;
        if ( a3 != v56 )
        {
          do
          {
            v51 = (__int16)(v75 * *(unsigned __int8 *)(v40 + v50)
                          + v74 * *(unsigned __int8 *)(v79 + v50)
                          + v73 * *(unsigned __int8 *)(v78 + v50)
                          + v72 * *(unsigned __int8 *)(v77 + v50)
                          + v71 * *(unsigned __int8 *)(v61 + v50)
                          + v70 * *(unsigned __int8 *)(v31 + v50)
                          + v68 * *(unsigned __int8 *)(v27 + v50)
                          + v69 * *(unsigned __int8 *)(v29 + v50)
                          + 16) >> 5;
            if ( v51 >= 0 )
            {
              if ( v51 >= 256 )
                LOBYTE(v51) = -1;
            }
            else
            {
              LOBYTE(v51) = 0;
            }
            *(_BYTE *)(v80 + v50++) = v51;
          }
          while ( a3 > v50 );
        }
      }
      else
      {
        v52 = 0i64;
        do
        {
          v53 = 0;
          v54 = (__int16)(v74 * *(unsigned __int8 *)(v79 + v52)
                        + v73 * *(unsigned __int8 *)(v78 + v52)
                        + v72 * *(unsigned __int8 *)(v77 + v52)
                        + v71 * *(unsigned __int8 *)(v61 + v52)
                        + v70 * *(unsigned __int8 *)(v31 + v52)
                        + v68 * *(unsigned __int8 *)(v27 + v52)
                        + v69 * *(unsigned __int8 *)(v29 + v52)
                        + 16
                        + v75 * *(unsigned __int8 *)(v40 + v52)) >> 5;
          if ( v54 >= 0 )
          {
            v53 = -1;
            if ( v54 <= 255 )
              v53 = (__int16)(v74 * *(unsigned __int8 *)(v79 + v52)
                            + v73 * *(unsigned __int8 *)(v78 + v52)
                            + v72 * *(unsigned __int8 *)(v77 + v52)
                            + v71 * *(unsigned __int8 *)(v61 + v52)
                            + v70 * *(unsigned __int8 *)(v31 + v52)
                            + v68 * *(unsigned __int8 *)(v27 + v52)
                            + v69 * *(unsigned __int8 *)(v29 + v52)
                            + 16
                            + v75 * *(unsigned __int8 *)(v40 + v52)) >> 5;
          }
          *(_BYTE *)(v80 + v52++) = v53;
        }
        while ( a3 != v52 );
      }
      v66 += v64;
      v62 += v64;
      v80 += v64;
    }
    while ( v60 > v65 );
  }
  return a2;
}
// 4082D9: variable 'v3' is possibly undefined
// 408355: variable 'v68' is possibly undefined
// 408396: variable 'v69' is possibly undefined
// 418700: using guessed type __int128 xmmword_418700;
// 418710: using guessed type __int128 xmmword_418710;
// 447FF8: using guessed type __int64 qword_447FF8;

//----- (0000000000408A60) ----------------------------------------------------
__int64 __fastcall sub_408A60(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v5; // r12
  __int64 i; // rbx
  __int64 v8; // [rsp+8h] [rbp-38h]

  v8 = a2;
  if ( a3 > 1 && a1 > 0 )
  {
    v5 = a2;
    for ( i = 0i64; i != a1; ++i )
    {
      sub_4097E0(a1, (__int8 *)&qword_447FF0);
      v5 += v3;
    }
  }
  return v8;
}
// 408A9F: variable 'a1' is possibly undefined
// 408AA4: variable 'v3' is possibly undefined
// 408AAC: variable 'v8' is possibly undefined
// 447FF0: using guessed type __int64 qword_447FF0;

//----- (0000000000409270) ----------------------------------------------------
__int64 __fastcall sub_409270(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __m128i si128; // xmm4
  __int64 v6; // rax
  __int64 v7; // r15
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rdx
  bool v11; // sf
  __int64 v12; // r14
  __int64 v13; // r14
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rdi
  __int64 v19; // rdx
  __int64 v20; // r15
  __int64 v21; // r13
  __int64 v22; // rax
  __int64 v23; // r12
  __int64 v24; // rbx
  __m128i v25; // xmm0
  __m128i v26; // xmm15
  __m128i v27; // xmm14
  __int64 v28; // rax
  __m128i v29; // xmm13
  __m128i v30; // xmm12
  __m128i v31; // xmm11
  __m128i v32; // xmm10
  __m128i v33; // xmm9
  __m128i v34; // xmm15
  __m128i v35; // xmm14
  __m128i v36; // xmm13
  __m128i v37; // xmm12
  __m128i v38; // xmm11
  __m128i v39; // xmm10
  __m128i v40; // xmm9
  __m128i v41; // xmm3
  __m128i v42; // xmm1
  __m128i v43; // xmm0
  __m128i v44; // xmm5
  __m128i v45; // xmm1
  __m128i v46; // xmm0
  __m128i v47; // xmm3
  __m128i v48; // xmm5
  signed __int64 v49; // rax
  __int16 v50; // r10
  __int64 v53; // [rsp+18h] [rbp-B8h]
  __int64 v54; // [rsp+48h] [rbp-88h]
  __int64 v55; // [rsp+50h] [rbp-80h]
  unsigned int v56; // [rsp+68h] [rbp-68h]
  unsigned int v57; // [rsp+6Ch] [rbp-64h]
  unsigned int v58; // [rsp+70h] [rbp-60h]
  unsigned int v59; // [rsp+74h] [rbp-5Ch]
  unsigned int v60; // [rsp+78h] [rbp-58h]
  unsigned int v61; // [rsp+7Ch] [rbp-54h]
  unsigned int v62; // [rsp+80h] [rbp-50h]
  unsigned int v63; // [rsp+84h] [rbp-4Ch]
  __int64 v64; // [rsp+88h] [rbp-48h]
  __m128i v65; // [rsp+90h] [rbp-40h]
  __int64 v66; // [rsp+E0h] [rbp+10h]
  __int64 v67; // [rsp+E8h] [rbp+18h]
  char *v68; // [rsp+F0h] [rbp+20h]

  if ( v66 > 0 && v67 > 0 )
  {
    v64 = a2;
    v54 = 0i64;
    si128 = _mm_load_si128((const __m128i *)&xmmword_418710);
    v53 = v66 - 1;
    while ( 1 )
    {
      v6 = v54;
      v7 = v54 + 1;
      v8 = v54 + 2;
      v9 = v54 + 3;
      v10 = v54;
      v12 = v54 - 3;
      v11 = v54 - 3 < 0;
      ++v54;
      if ( v11 )
        v12 = 0i64;
      v13 = a4 + a3 * v12;
      v14 = v10 - 2;
      if ( v14 < 0 )
        v14 = 0i64;
      v55 = a4 + a3 * v14;
      v15 = v6 - 1;
      if ( v6 - 1 < 0 )
        v15 = 0i64;
      v16 = a3 * v15;
      v17 = v66 - 1;
      v18 = a4 + v16;
      if ( v53 > v6 )
        v17 = v6;
      v19 = a3 * v17;
      if ( v53 <= v7 )
        v7 = v66 - 1;
      v20 = a4 + a3 * v7;
      if ( v8 > v53 )
        v8 = v66 - 1;
      v21 = a4 + a3 * v8;
      if ( v9 > v53 )
        v9 = v66 - 1;
      v22 = v6 + 4;
      v23 = a4 + a3 * v9;
      if ( v22 > v53 )
        v22 = v66 - 1;
      v24 = a4 + a3 * v22;
      LOWORD(v56) = *v68;
      LOWORD(v57) = v68[1];
      LOWORD(v58) = v68[2];
      LOWORD(v59) = v68[3];
      LOWORD(v60) = v68[4];
      LOWORD(v61) = v68[5];
      LOWORD(v62) = v68[6];
      LOWORD(v63) = v68[7];
      if ( (unsigned __int64)(v67 - 1) <= 0xE )
        break;
      v25 = _mm_cvtsi32_si128(v63);
      v26 = _mm_cvtsi32_si128(v56);
      v27 = _mm_cvtsi32_si128(v57);
      v28 = 0i64;
      v29 = _mm_cvtsi32_si128(v58);
      v30 = _mm_cvtsi32_si128(v59);
      v31 = _mm_cvtsi32_si128(v60);
      v32 = _mm_cvtsi32_si128(v61);
      v33 = _mm_cvtsi32_si128(v62);
      v34 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v26, v26), 0);
      v35 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v27, v27), 0);
      v36 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v29, v29), 0);
      v65 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v25, v25), 0);
      v37 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v30, v30), 0);
      v38 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v31, v31), 0);
      v39 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v32, v32), 0);
      v40 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v33, v33), 0);
      do
      {
        v41 = _mm_loadu_si128((const __m128i *)(a4 + v19 + v28));
        v42 = _mm_loadu_si128((const __m128i *)(v13 + v28));
        v43 = _mm_loadu_si128((const __m128i *)(v18 + v28));
        v44 = _mm_add_epi16(
                _mm_add_epi16(
                  _mm_add_epi16(
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v43, (__m128i)0i64), v36),
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v41, (__m128i)0i64), v37)),
                  _mm_add_epi16(
                    _mm_mullo_epi16(_mm_unpackhi_epi8(v42, (__m128i)0i64), v34),
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v55 + v28)), (__m128i)0i64),
                      v35))),
                _mm_add_epi16(
                  _mm_add_epi16(
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v20 + v28)), (__m128i)0i64),
                      v38),
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v21 + v28)), (__m128i)0i64),
                      v39)),
                  (__m128i)xmmword_418700));
        v45 = _mm_srai_epi16(
                _mm_add_epi16(
                  _mm_add_epi16(
                    _mm_add_epi16(
                      _mm_add_epi16(
                        _mm_mullo_epi16(_mm_unpacklo_epi8(v42, (__m128i)0i64), v34),
                        _mm_mullo_epi16(
                          _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v55 + v28)), (__m128i)0i64),
                          v35)),
                      _mm_add_epi16(
                        _mm_mullo_epi16(_mm_unpacklo_epi8(v43, (__m128i)0i64), v36),
                        _mm_mullo_epi16(_mm_unpacklo_epi8(v41, (__m128i)0i64), v37))),
                    _mm_add_epi16(
                      _mm_add_epi16(
                        _mm_mullo_epi16(
                          _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v20 + v28)), (__m128i)0i64),
                          v38),
                        _mm_mullo_epi16(
                          _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v21 + v28)), (__m128i)0i64),
                          v39)),
                      (__m128i)xmmword_418700)),
                  _mm_add_epi16(
                    _mm_mullo_epi16(
                      _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v23 + v28)), (__m128i)0i64),
                      v40),
                    _mm_mullo_epi16(
                      _mm_unpacklo_epi8(_mm_loadu_si128((const __m128i *)(v24 + v28)), (__m128i)0i64),
                      v65))),
                5u);
        v46 = _mm_srai_epi16(
                _mm_add_epi16(
                  v44,
                  _mm_add_epi16(
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v23 + v28)), (__m128i)0i64),
                      v40),
                    _mm_mullo_epi16(
                      _mm_unpackhi_epi8(_mm_loadu_si128((const __m128i *)(v24 + v28)), (__m128i)0i64),
                      v65))),
                5u);
        v47 = _mm_packus_epi16(
                _mm_and_si128(_mm_cmpeq_epi16(_mm_subs_epu16(v45, si128), (__m128i)0i64), si128),
                _mm_and_si128(_mm_cmpeq_epi16(_mm_subs_epu16(v46, si128), (__m128i)0i64), si128));
        v48 = _mm_packus_epi16(
                _mm_and_si128(_mm_cmpgt_epi16(v45, si128), si128),
                _mm_and_si128(_mm_cmpgt_epi16(v46, si128), si128));
        *(__m128i *)(v64 + v28) = _mm_or_si128(
                                    _mm_andnot_si128(
                                      v47,
                                      _mm_or_si128(
                                        v48,
                                        _mm_andnot_si128(
                                          v48,
                                          _mm_packus_epi16(
                                            _mm_andnot_si128(_mm_cmpgt_epi16((__m128i)0i64, v45), si128),
                                            _mm_andnot_si128(_mm_cmpgt_epi16((__m128i)0i64, v46), si128))))),
                                    _mm_and_si128(
                                      _mm_packus_epi16(_mm_and_si128(si128, v45), _mm_and_si128(si128, v46)),
                                      v47));
        v28 += 16i64;
      }
      while ( (v67 & 0xFFFFFFFFFFFFFFF0ui64) != v28 );
      v49 = v67 & 0xFFFFFFFFFFFFFFF0ui64;
      if ( v67 != (v67 & 0xFFFFFFFFFFFFFFF0ui64) )
        goto LABEL_28;
LABEL_30:
      v64 += v4;
      if ( v66 == v54 )
        return a2;
    }
    v49 = 0i64;
    do
    {
LABEL_28:
      v50 = (__int16)(v63 * *(unsigned __int8 *)(v24 + v49)
                    + v62 * *(unsigned __int8 *)(v23 + v49)
                    + v61 * *(unsigned __int8 *)(v21 + v49)
                    + v60 * *(unsigned __int8 *)(v20 + v49)
                    + v59 * *(unsigned __int8 *)(a4 + v19 + v49)
                    + v58 * *(unsigned __int8 *)(v18 + v49)
                    + v56 * *(unsigned __int8 *)(v13 + v49)
                    + v57 * *(unsigned __int8 *)(v55 + v49)
                    + 16) >> 5;
      if ( v50 >= 0 )
      {
        if ( v50 >= 256 )
          LOBYTE(v50) = -1;
      }
      else
      {
        LOBYTE(v50) = 0;
      }
      *(_BYTE *)(v64 + v49++) = v50;
    }
    while ( v67 > v49 );
    goto LABEL_30;
  }
  return a2;
}
// 40945D: variable 'v63' is possibly undefined
// 409462: variable 'v56' is possibly undefined
// 409468: variable 'v57' is possibly undefined
// 409470: variable 'v58' is possibly undefined
// 409476: variable 'v59' is possibly undefined
// 40947C: variable 'v60' is possibly undefined
// 409486: variable 'v61' is possibly undefined
// 40948C: variable 'v62' is possibly undefined
// 4097AE: variable 'v4' is possibly undefined
// 418700: using guessed type __int128 xmmword_418700;
// 418710: using guessed type __int128 xmmword_418710;

//----- (00000000004097E0) ----------------------------------------------------
unsigned __int8 *__fastcall sub_4097E0(__int64 a1, __int8 *a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int8 *v3; // rsi
  unsigned __int8 *v4; // r12
  __int8 v5; // al
  __int8 v6; // cl
  __int8 v7; // al
  __int8 v8; // cl
  __int8 v9; // al
  __int8 v10; // cl
  __int8 v11; // al
  unsigned __int8 *v13; // r10
  unsigned __int128 v14; // rax
  unsigned __int128 v15; // rax
  unsigned __int64 v16; // rdx
  unsigned __int8 *v17; // r10
  __m128i si128; // xmm5
  unsigned __int64 v19; // r15
  __int16 v20; // r8
  unsigned __int64 v21; // rbx
  __m128i v22; // xmm4
  __m128i v23; // xmm0
  __m128i v24; // xmm6
  __m128i v25; // xmm3
  __m128i v26; // xmm7
  __m128i v27; // xmm1
  __m128i v28; // xmm0
  __m128i v29; // xmm4
  __m128i v30; // xmm0
  __m128i v31; // xmm0
  __m128i v32; // xmm7
  __m128i v33; // xmm6
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rsi
  unsigned __int128 v36; // rax
  __int64 v37; // rcx
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  unsigned __int8 *v41; // [rsp+0h] [rbp-130h]
  const __m128i *v42; // [rsp+8h] [rbp-128h]
  const __m128i *v43; // [rsp+8h] [rbp-128h]
  __m128i v44; // [rsp+10h] [rbp-120h] BYREF
  __m128i v45; // [rsp+20h] [rbp-110h] BYREF
  __m128i v46; // [rsp+30h] [rbp-100h] BYREF
  __m128i v47; // [rsp+40h] [rbp-F0h] BYREF
  __m128i v48; // [rsp+50h] [rbp-E0h] BYREF
  __m128i v49; // [rsp+60h] [rbp-D0h] BYREF
  __m128i v50; // [rsp+70h] [rbp-C0h] BYREF
  __m128i v51; // [rsp+80h] [rbp-B0h]
  __m128i v52; // [rsp+90h] [rbp-A0h]
  __m128i v53; // [rsp+A0h] [rbp-90h]
  __m128i v54; // [rsp+B0h] [rbp-80h]
  __m128i v55; // [rsp+C0h] [rbp-70h] BYREF
  __m128i v56; // [rsp+D0h] [rbp-60h] BYREF
  __m128i v57; // [rsp+E0h] [rbp-50h] BYREF
  __m128i v58[4]; // [rsp+F0h] [rbp-40h] BYREF

  v4 = v3;
  v5 = a2[1];
  v44.m128i_i8[0] = *a2;
  v44.m128i_i8[1] = v5;
  v44.m128i_i8[2] = v44.m128i_i8[0];
  v44.m128i_i8[3] = v5;
  v44.m128i_i8[4] = v44.m128i_i8[0];
  v44.m128i_i8[5] = v5;
  v44.m128i_i8[6] = v44.m128i_i8[0];
  v44.m128i_i8[7] = v5;
  v44.m128i_i8[8] = v44.m128i_i8[0];
  v44.m128i_i8[9] = v5;
  v44.m128i_i8[10] = v44.m128i_i8[0];
  v44.m128i_i8[11] = v5;
  v44.m128i_i8[12] = v44.m128i_i8[0];
  v44.m128i_i8[13] = v5;
  v44.m128i_i8[14] = v44.m128i_i8[0];
  v6 = a2[2];
  v44.m128i_i8[15] = v5;
  v7 = a2[3];
  v45.m128i_i8[0] = v6;
  v45.m128i_i8[1] = v7;
  v45.m128i_i8[2] = v6;
  v45.m128i_i8[3] = v7;
  v45.m128i_i8[4] = v6;
  v45.m128i_i8[5] = v7;
  v45.m128i_i8[6] = v6;
  v45.m128i_i8[7] = v7;
  v45.m128i_i8[8] = v6;
  v45.m128i_i8[9] = v7;
  v45.m128i_i8[10] = v6;
  v45.m128i_i8[11] = v7;
  v45.m128i_i8[12] = v6;
  v45.m128i_i8[13] = v7;
  v45.m128i_i8[14] = v6;
  v8 = a2[4];
  v45.m128i_i8[15] = v7;
  v9 = a2[5];
  v46.m128i_i8[0] = v8;
  v46.m128i_i8[1] = v9;
  v46.m128i_i8[2] = v8;
  v46.m128i_i8[3] = v9;
  v46.m128i_i8[4] = v8;
  v46.m128i_i8[5] = v9;
  v46.m128i_i8[6] = v8;
  v46.m128i_i8[7] = v9;
  v46.m128i_i8[8] = v8;
  v46.m128i_i8[9] = v9;
  v46.m128i_i8[10] = v8;
  v46.m128i_i8[11] = v9;
  v46.m128i_i8[12] = v8;
  v46.m128i_i8[13] = v9;
  v46.m128i_i8[14] = v8;
  v10 = a2[6];
  v46.m128i_i8[15] = v9;
  v11 = a2[7];
  v47.m128i_i8[0] = v10;
  v47.m128i_i8[1] = v11;
  v47.m128i_i8[2] = v10;
  v47.m128i_i8[3] = v11;
  v47.m128i_i8[4] = v10;
  v47.m128i_i8[5] = v11;
  v47.m128i_i8[6] = v10;
  v47.m128i_i8[7] = v11;
  v47.m128i_i8[8] = v10;
  v47.m128i_i8[9] = v11;
  v47.m128i_i8[10] = v10;
  v47.m128i_i8[11] = v11;
  v47.m128i_i8[12] = v10;
  v47.m128i_i8[13] = v11;
  v47.m128i_i8[14] = v10;
  v47.m128i_i8[15] = v11;
  if ( v2 > 7 )
  {
    v13 = &v3[v2 - 1];
    v14 = 0x101010101010101i64 * (unsigned __int128)*v3;
    v48.m128i_i64[0] = 0x101010101010101i64 * *v3;
    v48.m128i_i64[1] = v48.m128i_i64[0] + *((_QWORD *)&v14 + 1);
    v15 = 0x101010101010101i64 * (unsigned __int128)*v13;
    v49.m128i_i64[0] = 0x101010101010101i64 * *v13;
    v49.m128i_i64[1] = v49.m128i_i64[0] + *((_QWORD *)&v15 + 1);
    v16 = 16i64;
    if ( v2 <= 0x10 )
      v16 = v2;
    sub_4154C0(v49.m128i_i64[0], v16);
    v19 = (v2 + 1) >> 1;
    if ( v19 )
    {
      v20 = unk_41C020;
      v21 = 0i64;
      while ( 1 )
      {
        v34 = v21;
        v21 += 8i64;
        if ( 2 * v34 + 32 <= v2 )
          break;
        v35 = 2 * v34 + 16;
        v36 = 0x101010101010101i64 * (unsigned __int128)*v17;
        v50.m128i_i64[0] = 0x101010101010101i64 * *v17;
        v50.m128i_i64[1] = v50.m128i_i64[0] + *((_QWORD *)&v36 + 1);
        if ( v35 >= v2 )
          goto LABEL_8;
        sub_4154C0(v50.m128i_i64[0], v2 - 2 * v21);
        if ( (v20 & 0x200) == 0 )
        {
LABEL_14:
          sub_415200(0xDui64, &v48);
          sub_415200(0xFui64, &v48);
          sub_415200(1ui64, v42);
          sub_415200(3ui64, v43);
          sub_415240(v37, v44.m128i_i8);
          sub_415240(v38, v45.m128i_i8);
          sub_415240(v39, v46.m128i_i8);
          sub_415240(v40, v47.m128i_i8);
          v20 = unk_41C020;
          si128 = _mm_load_si128((const __m128i *)&xmmword_418700);
          v17 = v41;
          goto LABEL_10;
        }
LABEL_9:
        v22 = _mm_load_si128(&v49);
        v23 = _mm_load_si128(&v48);
        v24 = _mm_load_si128(&v44);
        v25 = _mm_alignr_epi8(_mm_load_si128(&v50), v22, 1);
        v26 = _mm_load_si128(&v45);
        v27 = _mm_alignr_epi8(v22, v23, 15);
        v51 = _mm_alignr_epi8(v22, v23, 13);
        v28 = _mm_alignr_epi8(_mm_load_si128(&v50), v22, 3);
        v52 = v27;
        v29 = _mm_load_si128(&v46);
        v54 = v28;
        v56 = _mm_maddubs_epi16(v27, v26);
        v30 = _mm_maddubs_epi16(v28, _mm_load_si128(&v47));
        v55 = _mm_maddubs_epi16(v51, v24);
        v57 = _mm_maddubs_epi16(v25, v29);
        v58[0] = v30;
LABEL_10:
        v31 = _mm_add_epi16(
                _mm_add_epi16(_mm_add_epi16(_mm_load_si128(&v55), si128), _mm_load_si128(&v56)),
                _mm_load_si128(&v57));
        v32 = _mm_load_si128(&v49);
        v33 = _mm_load_si128(v58);
        v49 = _mm_load_si128(&v50);
        v48 = v32;
        v55 = _mm_srai_epi16(_mm_add_epi16(v31, v33), 5u);
        v53 = _mm_packus_epi16(v55, v55);
        *(_QWORD *)&v4[v21 - 8] = v53.m128i_i64[0];
        if ( v21 >= v19 )
          return v4;
      }
      v50 = _mm_loadu_si128((const __m128i *)&v4[2 * v21]);
LABEL_8:
      if ( (v20 & 0x200) == 0 )
        goto LABEL_14;
      goto LABEL_9;
    }
  }
  return v4;
}
// 409BE7: ignored the value written to the shadow area of the succeeding call
// 409C17: ignored the value written to the shadow area of the succeeding call
// 4097EC: variable 'v3' is possibly undefined
// 4099A2: variable 'v2' is possibly undefined
// 409A5D: variable 'v20' is possibly undefined
// 409B1B: variable 'si128' is possibly undefined
// 409B7F: variable 'v17' is possibly undefined
// 409C40: variable 'v42' is possibly undefined
// 409C5F: variable 'v43' is possibly undefined
// 409C76: variable 'v37' is possibly undefined
// 409C8D: variable 'v38' is possibly undefined
// 409CA4: variable 'v39' is possibly undefined
// 409CB8: variable 'v40' is possibly undefined
// 409CCC: variable 'v41' is possibly undefined
// 418700: using guessed type __int128 xmmword_418700;
// 4097E0: using guessed type __m128i var_40[4];

//----- (0000000000409CE0) ----------------------------------------------------
int __fastcall sub_409CE0()
{
  __int64 v0; // rsi
  __int64 v1; // rcx
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int16 v4; // ax

  if ( !sub_409D70() )
    return sub_410AE0(v1);
  sub_4108B0();
  *(_WORD *)(v0 + 2) = sub_4142F0(v2, 0);
  sub_4108B0();
  v4 = sub_4142F0(v3, 0);
  *(_DWORD *)(v0 + 4) = 0;
  *(_WORD *)v0 = v4;
  return 0;
}
// 409D14: variable 'v2' is possibly undefined
// 409D1E: variable 'v0' is possibly undefined
// 409D3C: variable 'v3' is possibly undefined
// 409D6B: variable 'v1' is possibly undefined

//----- (0000000000409D70) ----------------------------------------------------
bool sub_409D70()
{
  const char *v0; // rsi
  bool result; // al

  v0 = sub_4108B0();
  result = 0;
  if ( v0 )
    return strcmp(v0, "dumb") == 0;
  return result;
}

//----- (0000000000409DA0) ----------------------------------------------------
void __fastcall __noreturn sub_409DA0(double a1, double a2, double a3, double a4)
{
  sub_4028C1(a1, a2, a3, a4);
  sub_402973();
}

//----- (0000000000409DB0) ----------------------------------------------------
__int64 __fastcall sub_409DB0()
{
  _QWORD *v0; // rsi
  char *v1; // rax
  __int64 v2; // r12
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rax
  _QWORD *v6; // rbx
  unsigned __int64 v7; // r14
  __int64 v8; // r15
  __int64 v9; // r13
  int v10; // eax
  __int64 i; // rcx
  __int64 v12; // r15
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r12
  char *j; // r14
  unsigned __int64 v18; // rax
  __int64 v19; // rcx
  char *v20; // rbx
  unsigned __int64 v21; // r15
  __int64 v22; // rcx
  __int64 v24; // [rsp+8h] [rbp-CD8h]
  __int64 *v25; // [rsp+18h] [rbp-CC8h]
  char v26; // [rsp+31h] [rbp-CAFh]
  __int64 v27; // [rsp+34h] [rbp-CACh]
  int v28; // [rsp+3Ch] [rbp-CA4h]
  __int64 v29[128]; // [rsp+40h] [rbp-CA0h] BYREF
  char v30[2208]; // [rsp+440h] [rbp-8A0h] BYREF

  v1 = sub_40F050();
  if ( v1 )
  {
    v2 = (__int64)v1;
    sub_40A4D0();
    if ( v5 )
    {
      v29[0] = 4294503i64;
      v29[1] = 4294513i64;
      v29[2] = 4294516i64;
      v29[3] = v2;
      if ( v0 )
      {
        v24 = 0i64;
        v6 = v0;
        v7 = 4i64;
        v25 = v29;
        v8 = 0i64;
        v9 = 0i64;
        do
        {
          for ( i = v6[1]; !i; i = *(_QWORD *)(*(_QWORD *)(v24 + 16) + 32 * v8 + 24) )
            --v8;
          v25[v7++] = (__int64)&v30[v9];
          v10 = sub_413AC0(i - 1, "%#x", v3, v4);
          v6 = (_QWORD *)*v6;
          v9 += v10 + 1;
        }
        while ( v6 && v7 <= 0x7E );
        v12 = v7;
      }
      else
      {
        v12 = 4i64;
        v25 = v29;
      }
      v29[v12] = 0i64;
      HIDWORD(v27) = -1;
      v28 = 2;
      if ( (unsigned int)sub_40B0C0(v25) != -1 )
      {
LABEL_12:
        while ( 1 )
        {
          v16 = sub_410F70(v13);
          if ( v16 <= 0 )
            break;
          for ( j = v30; ; j = v20 )
          {
            v21 = sub_40B560(15i64, " (discriminator ");
            if ( !v21 )
              break;
            sub_415783();
            v20 = (char *)v18;
            if ( !v18 )
              break;
            if ( v21 < v18 )
              v20 = (char *)(v18 - (*(_BYTE *)(v18 - 1) == 13));
            sub_411A10(v19);
            v16 -= v20 - j;
            if ( !v16 )
              goto LABEL_12;
          }
          sub_411A10(v19);
        }
        sub_410160(v15, v14);
        if ( (unsigned int)sub_4119F0(v22, 0i64) != -1 )
          return (unsigned int)-(v26 != 0);
      }
    }
  }
  return 0xFFFFFFFFi64;
}
// 409DED: variable 'v5' is possibly undefined
// 409E2F: variable 'v0' is possibly undefined
// 409E8E: variable 'v25' is possibly undefined
// 409EA3: variable 'v3' is possibly undefined
// 409EA3: variable 'v4' is possibly undefined
// 409ED3: variable 'v24' is possibly undefined
// 409F7A: variable 'v13' is possibly undefined
// 409FB1: variable 'v18' is possibly undefined
// 409FD6: variable 'v19' is possibly undefined
// 40A022: variable 'v15' is possibly undefined
// 40A022: variable 'v14' is possibly undefined
// 40A036: variable 'v22' is possibly undefined
// 40A049: variable 'v26' is possibly undefined
// 448018: using guessed type __int64 qword_448018;

//----- (000000000040A090) ----------------------------------------------------
void sub_40A090()
{
  __int64 v0; // rax
  __int64 v1; // rcx

  if ( !byte_448025 )
  {
    byte_448025 = 1;
    if ( (unsigned int)sub_409DB0() == -1 )
    {
      v0 = sub_40A470();
      sub_40A100(v1, v0);
    }
    byte_448025 = 0;
  }
}
// 40A0EE: variable 'v1' is possibly undefined
// 448025: using guessed type char byte_448025;

//----- (000000000040A100) ----------------------------------------------------
__int64 __fastcall sub_40A100(__int64 a1, __int64 a2)
{
  __int64 *v2; // rsi
  __int64 *v3; // r15
  __int64 v4; // r12
  __int64 *v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  _BYTE *v8; // r11
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // r10
  __int64 v15; // rsi
  _WORD *v16; // rdi
  __int64 v17; // r15
  __int64 v18; // r11
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  int v21; // edi
  unsigned __int64 v22; // rax
  int v23; // eax
  char *v24; // rax
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // rax
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // r10
  __int64 v32; // [rsp+8h] [rbp-178h]
  __int64 v33; // [rsp+18h] [rbp-168h]
  __int64 v34; // [rsp+20h] [rbp-160h]
  __int64 v35; // [rsp+28h] [rbp-158h]
  __int64 savedregs; // [rsp+180h] [rbp+0h] BYREF

  if ( !a2 )
    return 0xFFFFFFFFi64;
  v3 = v2;
  v32 = 0i64;
  if ( v2 )
  {
    v4 = 0i64;
LABEL_4:
    v5 = v3;
    while ( 1 )
    {
      v17 = v5[1];
      if ( !v17 )
      {
        a1 = *(_QWORD *)(v32 + 16);
        do
        {
          --v4;
          v17 = *(_QWORD *)(a1 + 32 * v4 + 24);
        }
        while ( !v17 );
      }
      v6 = sub_412530(a1, 48);
      sub_4154C0(v7, v6);
      *v8 = 32;
      v10 = sub_412530(v9, 48);
      sub_4154C0(v11, v10);
      *(_BYTE *)(v14 + v12) = 32;
      v15 = *(_QWORD *)(v33 + 32);
      if ( v15 )
      {
        if ( v17 >= 0x400000 && v17 <= 4493312 )
          break;
      }
      v16 = (_WORD *)(v14 + v12 + 8);
      *(_QWORD *)(v14 + v12 + 1) = 0x4E574F4E4B4E55i64;
LABEL_9:
      *v16 = 2573;
      if ( sub_411A10(v13) == -1 )
        return 0xFFFFFFFFi64;
      v5 = (__int64 *)*v5;
      if ( !v5 )
        return 0i64;
    }
    v18 = v33 + 64;
    v19 = *(_QWORD *)(v33 + 32);
    v20 = 0i64;
    v21 = v17 + ~(unsigned int)*(_QWORD *)(v33 + 40);
    while ( v19 > v20 )
    {
      v22 = (v19 + v20) >> 1;
      if ( v21 > *(_DWORD *)(v18 + 8 * v22) )
        v20 = v22 + 1;
      else
        v19 = (v19 + v20) >> 1;
    }
    v23 = 0;
    if ( v20 )
    {
      if ( v15 == v20 || (v23 = v20, v21 < *(_DWORD *)(v18 + 8 * v20)) )
        v23 = v20 - 1;
    }
    v34 = *(_QWORD *)(v33 + 40);
    v35 = v33 + 8i64 * v23;
    v24 = sub_414AB0();
    v26 = v17 - v34 - *(unsigned int *)(v35 + 64);
    if ( v26 < 0 )
    {
      *v24 = 45;
    }
    else
    {
      *v24 = 43;
      if ( !v26 )
      {
LABEL_24:
        v27 = sub_412630(v25);
        sub_4154C0(v28, v27);
        v16 = (_WORD *)(v30 + v29);
        goto LABEL_9;
      }
    }
    *(_WORD *)(v24 + 1) = 30768;
    goto LABEL_24;
  }
  v3 = &savedregs;
  v4 = 0i64;
  if ( &savedregs )
    goto LABEL_4;
  return 0i64;
}
// 40A12F: variable 'v2' is possibly undefined
// 40A173: variable 'a1' is possibly undefined
// 40A185: variable 'v7' is possibly undefined
// 40A18A: variable 'v8' is possibly undefined
// 40A1A8: variable 'v9' is possibly undefined
// 40A1C4: variable 'v11' is possibly undefined
// 40A1C9: variable 'v14' is possibly undefined
// 40A1C9: variable 'v12' is possibly undefined
// 40A1DB: variable 'v33' is possibly undefined
// 40A224: variable 'v13' is possibly undefined
// 40A25B: variable 'v32' is possibly undefined
// 40A34C: variable 'v25' is possibly undefined
// 40A361: variable 'v28' is possibly undefined
// 40A366: variable 'v30' is possibly undefined
// 40A366: variable 'v29' is possibly undefined

//----- (000000000040A3F0) ----------------------------------------------------
char sub_40A3F0()
{
  unsigned int v0; // eax
  const char *v1; // rsi

  LOBYTE(v0) = byte_448026;
  if ( !byte_448027 )
  {
    if ( byte_448026 )
    {
      byte_448027 = 1;
    }
    else
    {
      v1 = sub_4108B0();
      if ( v1 )
      {
        LOBYTE(v0) = strcmp(v1, "dumb") != 0;
        byte_448026 = v0;
      }
      else
      {
        v0 = ((unsigned int)dword_41C718 >> 3) & 1;
        byte_448026 = (dword_41C718 & 8) != 0;
      }
      byte_448027 = 1;
    }
  }
  return v0;
}
// 40A404: ignored the value written to the shadow area of the succeeding call
// 40A3F0: could not find valid save-restore pair for rbp
// 41C718: using guessed type int dword_41C718;
// 448026: using guessed type char byte_448026;
// 448027: using guessed type char byte_448027;

//----- (000000000040A470) ----------------------------------------------------
__int64 sub_40A470()
{
  __int64 result; // rax
  __int64 v1; // rcx
  __int64 v2; // rcx

  if ( byte_448008 )
    return qword_448000;
  byte_448008 = 1;
  if ( sub_40F050() )
  {
    result = sub_40F5E0(v1);
    qword_448000 = result;
    if ( !result )
      return result;
    sub_40EDE0(v2, 0i64);
  }
  return qword_448000;
}
// 40A488: ignored the value written to the shadow area of the succeeding call
// 40A4A0: variable 'v1' is possibly undefined
// 40A4BD: variable 'v2' is possibly undefined
// 448000: using guessed type __int64 qword_448000;
// 448008: using guessed type char byte_448008;

//----- (000000000040A4D0) ----------------------------------------------------
void sub_40A4D0()
{
  sub_40A4E0();
}

//----- (000000000040A4E0) ----------------------------------------------------
void sub_40A4E0()
{
  _BYTE *v0; // rax
  __int64 v1; // rcx

  v0 = sub_4108B0();
  if ( !v0 )
  {
    if ( !sub_410390() )
      return;
LABEL_6:
    sub_40B7A0();
    return;
  }
  if ( *v0 && (unsigned int)sub_4100E0(v1) != -1 )
    goto LABEL_6;
}
// 40A50D: variable 'v1' is possibly undefined

//----- (000000000040A570) ----------------------------------------------------
__int64 __fastcall sub_40A570(__int64 a1, _BYTE *a2, char *a3)
{
  return sub_40A580(a1, a2, a3);
}

//----- (000000000040A580) ----------------------------------------------------
__int64 __fastcall sub_40A580(__int64 a1, _BYTE *a2, char *a3)
{
  unsigned __int8 *v3; // rdi
  __int64 v4; // rsi
  unsigned __int8 *v5; // rax
  unsigned int v6; // er15
  __int64 v7; // r14
  unsigned int v8; // edi
  __int64 v9; // r12
  unsigned int v10; // ecx
  int v11; // er8
  int v12; // edi
  unsigned __int8 *v13; // r13
  unsigned __int8 v14; // al
  unsigned __int8 v15; // si
  unsigned __int8 *v16; // r8
  int v17; // edi
  int v18; // eax
  _BYTE *v20; // rsi
  int v21; // eax
  __int64 v22; // rcx
  int v23; // eax
  _BYTE *v24; // rdx
  __int64 v25; // r14

  if ( !v4 )
    return 0i64;
  v5 = v3 + 1;
  v6 = 0;
  v7 = v4 - 1;
  v8 = *v3;
  if ( !v8 )
    return 0i64;
  while ( 1 )
  {
LABEL_3:
    v9 = v7 - 1;
    if ( v8 - 32 <= 0x5E || v8 == 9 )
    {
      ++v6;
      if ( !v7 )
        return v6;
      goto LABEL_17;
    }
    if ( v8 == 27 )
      break;
    if ( v8 <= 0xBF )
    {
      if ( !v7 )
        return v6;
LABEL_17:
      v8 = *v5;
      if ( !*v5 )
        return v6;
      ++v5;
      --v7;
    }
    else
    {
      if ( v8 <= 0xFB )
      {
        v10 = v8;
        LOBYTE(v10) = ~(_BYTE)v8;
        _BitScanReverse(&v10, v10);
        v11 = 6 - v10;
        v12 = (((1 << v10) - 1) | 3) & v8;
        if ( !v7 )
          return v6;
        v13 = v5 + 1;
        v14 = *v5;
        v15 = v14;
        if ( !v14 )
          return v6;
LABEL_10:
        v16 = &v13[v11 - 1];
        while ( 1 )
        {
          v7 = v9 - 1;
          if ( (v14 & 0xC0) != 128 )
            break;
          v12 = v15 & 0x3F | (v12 << 6);
          if ( v16 == v13 )
            break;
          if ( !v9 )
            return v6;
          v14 = *v13++;
          v15 = v14;
          if ( !v14 )
            return v6;
          --v9;
        }
        goto LABEL_23;
      }
      v17 = v8 & 3;
      if ( !v7 || !*v5 )
        return v6;
      if ( (*v5 & 0xC0) == 128 )
      {
        v25 = v7 - 2;
        v12 = *v5 & 0x3F | (v17 << 6);
        if ( !v9 )
          return v6;
        v13 = v5 + 2;
        v14 = v5[1];
        v15 = v14;
        if ( !v14 )
          return v6;
        v9 = v25;
        v11 = 4;
        goto LABEL_10;
      }
      v13 = v5 + 1;
      v7 -= 2i64;
LABEL_23:
      v18 = sub_40A810();
      if ( v18 < 0 )
        v18 = 0;
      v6 += v18;
      if ( !v9 )
        return v6;
      v8 = *v13;
      v5 = v13 + 1;
      if ( !*v13 )
        return v6;
    }
  }
  if ( v7 )
  {
    v20 = v5 + 1;
    v21 = *v5;
    if ( v21 )
    {
      while ( 1 )
      {
        v22 = v9 - 1;
        if ( v21 == 91 )
          break;
        if ( (unsigned int)(v21 - 32) > 0xF )
        {
          if ( v9 )
          {
            v8 = (unsigned __int8)*v20;
            v5 = v20 + 1;
            if ( *v20 )
            {
              v7 = v9 - 1;
              goto LABEL_3;
            }
          }
          return v6;
        }
        if ( !v9 )
          return v6;
        v21 = (unsigned __int8)*v20++;
        if ( !v21 )
          return v6;
        --v9;
      }
      if ( v9 )
      {
        v23 = (unsigned __int8)*v20;
        v24 = v20 + 1;
        if ( *v20 )
        {
          while ( 1 )
          {
            v7 = v22 - 1;
            if ( (unsigned int)(v23 - 48) > 0xF )
              break;
            if ( !v22 )
              return v6;
            v23 = (unsigned __int8)*v24++;
            if ( !v23 )
              return v6;
            --v22;
          }
          if ( v22 )
          {
            v8 = (unsigned __int8)*v24;
            v5 = v24 + 1;
            if ( *v24 )
              goto LABEL_3;
          }
        }
      }
    }
  }
  return v6;
}
// 40A583: variable 'v4' is possibly undefined
// 40A58A: variable 'v3' is possibly undefined

//----- (000000000040A810) ----------------------------------------------------
__int64 __fastcall sub_40A810()
{
  int v0; // edi
  __int64 result; // rax
  int v2; // ecx

  result = 0i64;
  if ( v0 )
  {
    if ( (unsigned int)(v0 - 127) <= 0x20 || (unsigned int)v0 <= 0x1F )
    {
      return 0xFFFFFFFFi64;
    }
    else
    {
      result = 1i64;
      if ( v0 >= 0 )
      {
        if ( (unsigned int)v0 >= 0xE0200
          || (v2 = (unsigned __int8)byte_41C728[v0 >> 3], result = 0i64, !_bittest(&v2, v0 & 7)) )
        {
          result = 1i64;
          if ( (unsigned int)v0 < 0x40000 )
            return (((int)(unsigned __int8)byte_438768[v0 >> 3] >> (v0 & 7)) & 1u) + 1;
        }
      }
    }
  }
  return result;
}
// 40A814: variable 'v0' is possibly undefined

//----- (000000000040A890) ----------------------------------------------------
__int64 __fastcall sub_40A890()
{
  __int64 v0; // rdi
  unsigned int v1; // er12
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // rdi
  bool v6; // zf
  int v8; // eax
  __int64 v9; // [rsp+8h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-18h]
  __int64 v11; // [rsp+8h] [rbp-18h]

  v1 = 0;
  if ( v0 )
  {
    sub_40AA40();
    sub_40A950(v2);
    v5 = v9;
    if ( *(_DWORD *)(v9 + 36) )
    {
      v6 = *(_BYTE *)(v9 + 1) == 0;
      *(_DWORD *)(v9 + 8) = -1;
      if ( !v6 )
      {
LABEL_4:
        *(_DWORD *)(v5 + 12) = -1;
        v1 = 0;
LABEL_5:
        sub_40F140();
        return v1;
      }
    }
    else
    {
      sub_40F140();
      v5 = v10;
      v6 = *(_BYTE *)(v10 + 1) == 0;
      *(_DWORD *)(v10 + 8) = -1;
      if ( !v6 )
        goto LABEL_4;
    }
    if ( (unsigned int)sub_40ED70(v4, v3) == -1 )
    {
      v8 = dword_448020;
      *(_DWORD *)(v11 + 8) = dword_448020;
    }
    else
    {
      v8 = *(_DWORD *)(v11 + 8);
    }
    if ( v8 == -1 )
    {
      v1 = 0;
    }
    else
    {
      dword_448020 = v8;
      v1 = -1;
    }
    goto LABEL_5;
  }
  return v1;
}
// 40A8A4: variable 'v0' is possibly undefined
// 40A8AF: variable 'v2' is possibly undefined
// 40A8B4: variable 'v9' is possibly undefined
// 40A8F9: variable 'v10' is possibly undefined
// 40A90E: variable 'v4' is possibly undefined
// 40A90E: variable 'v3' is possibly undefined
// 40A91C: variable 'v11' is possibly undefined
// 448020: using guessed type int dword_448020;

//----- (000000000040A950) ----------------------------------------------------
__int64 __fastcall sub_40A950(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // er12
  int v3; // eax
  __int64 v5; // rax
  __int64 v6; // rbx
  unsigned int v7; // er12
  int v8; // eax

  if ( v1 )
  {
    if ( *(_DWORD *)(v1 + 12) == -1 )
    {
      v5 = *(unsigned int *)(v1 + 16);
      v2 = 0;
      if ( (_DWORD)v5 && (unsigned int)v5 < *(_DWORD *)(v1 + 32) )
        *(_BYTE *)(*(_QWORD *)(v1 + 24) + v5) = 0;
      return v2;
    }
    v2 = *(_DWORD *)(v1 + 8);
    if ( !v2 )
    {
      do
      {
        if ( !*(_DWORD *)(v1 + 16) || *(_DWORD *)(v1 + 20) )
          break;
        sub_40ADE0(a1);
        a1 = *(unsigned int *)(v1 + 8);
        if ( v3 != -1 )
          v2 += v3;
      }
      while ( !(_DWORD)a1 );
      return v2;
    }
    return 0;
  }
  if ( !qword_446660 )
    return 0;
  v6 = qword_446660 - 1;
  v7 = 0;
  while ( !*(_QWORD *)(qword_446670 + 8 * v6) )
  {
LABEL_19:
    if ( --v6 == -1 )
      return v7;
  }
  v8 = sub_40A950(a1);
  if ( v8 != -1 )
  {
    v7 += v8;
    goto LABEL_19;
  }
  return (unsigned int)-1;
}
// 40A95A: variable 'v1' is possibly undefined
// 40A991: variable 'v3' is possibly undefined
// 40A9F8: variable 'a1' is possibly undefined
// 446660: using guessed type __int64 qword_446660;
// 446670: using guessed type __int64 qword_446670;

//----- (000000000040AA40) ----------------------------------------------------
__int64 __fastcall sub_40AA40()
{
  __int64 v0; // rdi
  __int64 result; // rax
  _QWORD *i; // rdx

  result = qword_446660;
  if ( qword_446660 )
  {
    for ( i = (_QWORD *)(*(&qword_446660 + 2) + 8 * qword_446660 - 8); *i != v0; --i )
    {
      if ( !--result )
        return result;
    }
    *i = 0i64;
  }
  return result;
}
// 40AA6D: variable 'v0' is possibly undefined
// 446660: using guessed type __int64 qword_446660;

//----- (000000000040AA80) ----------------------------------------------------
__int64 __fastcall sub_40AA80()
{
  __int64 v0; // rdi
  __int64 v1; // rax
  __int64 (*v2)(void); // rax
  __int64 result; // rax
  __int64 v4; // rdx

  v1 = *(unsigned int *)(v0 + 16);
  if ( (unsigned int)v1 < *(_DWORD *)(v0 + 20) )
    goto LABEL_5;
  v2 = *(__int64 (**)(void))(v0 + 40);
  if ( !v2 )
    return sub_40AD90();
  result = v2();
  if ( (_DWORD)result != -1 )
  {
    v1 = *(unsigned int *)(v0 + 16);
LABEL_5:
    v4 = *(_QWORD *)(v0 + 24);
    *(_DWORD *)(v0 + 16) = v1 + 1;
    return *(unsigned __int8 *)(v4 + v1);
  }
  return result;
}
// 40AA8D: variable 'v0' is possibly undefined

//----- (000000000040AAD0) ----------------------------------------------------
__int64 __fastcall sub_40AAD0()
{
  const char *v0; // rdi
  const char *v1; // r12
  unsigned __int64 v2; // rdx
  __int64 v3; // rcx
  bool v4; // cf
  bool v5; // zf
  const char *v6; // rdi
  const char *v7; // rsi
  char v8; // bl
  int v9; // er13
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r12
  int v15; // eax
  bool v16; // cf
  bool v17; // zf
  const char *v18; // rdi
  const char *v19; // rsi
  bool v20; // al

  v1 = v0;
  v2 = qword_440910 & (int)sub_40AC60();
  if ( v2 != qword_440938 )
  {
    if ( qword_440958 != v2 )
    {
LABEL_8:
      v8 = 0;
      v9 = sub_410E90(v3, 0x1B6u);
      goto LABEL_9;
    }
    v4 = *v0 < 0x2Du;
    v5 = *v0 == 45;
    if ( *v0 == 45 )
    {
      v4 = 0;
      v5 = v0[1] == 0;
      if ( !v0[1] )
        goto LABEL_14;
    }
    goto LABEL_4;
  }
  v15 = *(unsigned __int8 *)v0;
  if ( v15 != 45 || v0[1] )
  {
    v16 = v2 < qword_440958;
    v17 = v2 == qword_440958;
    if ( v2 == qword_440958 )
    {
      if ( v15 == 45 && !v0[1] )
        goto LABEL_14;
      v20 = strcmp(v0, "/dev/stdin") != 0;
      v4 = 0;
      v5 = !v20;
      if ( v20 )
      {
LABEL_4:
        v6 = "/dev/stdout";
        v3 = 12i64;
        v7 = v1;
        do
        {
          if ( !v3 )
            break;
          v4 = *v7 < (unsigned int)*v6;
          v5 = *v7++ == *v6++;
          --v3;
        }
        while ( v5 );
        if ( (!v4 && !v5) != v4 )
          goto LABEL_8;
LABEL_14:
        v8 = 1;
        if ( (unsigned int)sub_40AF80() == -1 )
          return 0i64;
LABEL_10:
        v10 = sub_40AEC0();
        v13 = v10;
        if ( v10 )
        {
          *(_BYTE *)(v10 + 1) = v8;
        }
        else
        {
          if ( v8 )
            return 0i64;
          sub_410160(v12, v11);
        }
        return v13;
      }
    }
    else
    {
      v18 = "/dev/stdin";
      v3 = 11i64;
      v19 = v1;
      do
      {
        if ( !v3 )
          break;
        v16 = *v19 < (unsigned int)*v18;
        v17 = *v19++ == *v18++;
        --v3;
      }
      while ( v17 );
      if ( (!v16 && !v17) != v16 )
        goto LABEL_8;
    }
  }
  v8 = 1;
  v9 = sub_40AF80();
LABEL_9:
  if ( v9 != -1 )
    goto LABEL_10;
  return 0i64;
}
// 40AADD: variable 'v0' is possibly undefined
// 40AB38: variable 'v3' is possibly undefined
// 40AC4B: variable 'v12' is possibly undefined
// 40AC4B: variable 'v11' is possibly undefined
// 440910: using guessed type __int64 qword_440910;
// 440938: using guessed type __int64 qword_440938;
// 440958: using guessed type __int64 qword_440958;

//----- (000000000040AC60) ----------------------------------------------------
__int64 __fastcall sub_40AC60()
{
  char *v0; // rdi
  unsigned int v1; // er8
  char v2; // al

  v1 = 0;
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                v2 = *v0++;
                if ( v2 != 114 )
                  break;
                v1 |= qword_440938;
              }
              if ( v2 != 119 )
                break;
              v1 |= qword_440950 | qword_440958 | qword_440928;
            }
            if ( v2 != 97 )
              break;
            v1 |= qword_440958 | qword_440928 | dword_440918;
          }
          if ( v2 != 43 )
            break;
          v1 |= qword_440940;
        }
        if ( v2 != 120 )
          break;
        v1 |= qword_440930;
      }
      if ( v2 != 101 )
        break;
      v1 |= qword_440920;
    }
  }
  while ( v2 );
  return v1;
}
// 40AC88: variable 'v0' is possibly undefined
// 440918: using guessed type int dword_440918;
// 440920: using guessed type __int64 qword_440920;
// 440928: using guessed type __int64 qword_440928;
// 440930: using guessed type __int64 qword_440930;
// 440938: using guessed type __int64 qword_440938;
// 440940: using guessed type __int64 qword_440940;
// 440950: using guessed type __int64 qword_440950;
// 440958: using guessed type __int64 qword_440958;

//----- (000000000040AD00) ----------------------------------------------------
__int64 __fastcall sub_40AD00(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm2
  __int128 v7; // xmm3
  int v9; // [rsp+8h] [rbp-C8h] BYREF
  __int64 v10; // [rsp+30h] [rbp-A0h]
  __int64 v11; // [rsp+38h] [rbp-98h]
  __int64 v12; // [rsp+40h] [rbp-90h]
  __int64 v13; // [rsp+48h] [rbp-88h]
  __int128 v14; // [rsp+50h] [rbp-80h]
  __int128 v15; // [rsp+60h] [rbp-70h]
  __int128 v16; // [rsp+70h] [rbp-60h]
  __int128 v17; // [rsp+80h] [rbp-50h]

  v14 = v4;
  v15 = v5;
  v16 = v6;
  v17 = v7;
  v10 = a2;
  v11 = a1;
  v12 = a3;
  v13 = a4;
  return sub_40AE80(a1, (__int64)&v9, a3);
}
// 40AD78: ignored the value written to the shadow area of the succeeding call
// 40AD6E: ignored the value written to the shadow area of the succeeding call
// 40AD60: ignored the value written to the shadow area of the succeeding call
// 40AD56: ignored the value written to the shadow area of the succeeding call
// 40AD00: variable 'v4' is possibly undefined
// 40AD00: variable 'v5' is possibly undefined
// 40AD00: variable 'v6' is possibly undefined
// 40AD00: variable 'v7' is possibly undefined

//----- (000000000040AD90) ----------------------------------------------------
__int64 __fastcall sub_40AD90()
{
  __int64 v0; // rdi
  int v1; // eax

  v1 = *(_DWORD *)(v0 + 8);
  if ( v1 <= 0 )
    v1 = -1;
  *(_DWORD *)(v0 + 8) = v1;
  return -1i64;
}
// 40ADA0: variable 'v0' is possibly undefined
// 448020: using guessed type int dword_448020;

//----- (000000000040ADE0) ----------------------------------------------------
void __fastcall sub_40ADE0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx
  int v5; // eax

  v2 = sub_411A10(a1);
  if ( v2 == -1 )
  {
    if ( dword_448020 != qword_440818 )
      sub_40B0B0();
  }
  else
  {
    v4 = *(unsigned int *)(v1 + 16);
    if ( v4 == v2 )
    {
      *(_DWORD *)(v1 + 16) = 0;
    }
    else
    {
      sub_4154C0(v3, v4 - v2);
      *(_DWORD *)(v1 + 16) -= v5;
    }
  }
}
// 40AE02: variable 'v1' is possibly undefined
// 40AE18: variable 'v3' is possibly undefined
// 40AE1D: variable 'v5' is possibly undefined
// 440818: using guessed type __int64 qword_440818;
// 448020: using guessed type int dword_448020;

//----- (000000000040AE80) ----------------------------------------------------
__int64 __fastcall sub_40AE80(__int64 a1, __int64 a2, __int64 a3)
{
  char *v3; // rsi
  __int64 result; // rax
  unsigned int v5; // [rsp+8h] [rbp-8h]

  result = sub_413260(a2, v3, a3);
  if ( (_DWORD)result != -1 )
    return v5;
  return result;
}
// 40AE9B: ignored the value written to the shadow area of the succeeding call
// 40AE92: ignored the value written to the shadow area of the succeeding call
// 40AEA2: variable 'v3' is possibly undefined
// 40AEAC: variable 'v5' is possibly undefined

//----- (000000000040AEC0) ----------------------------------------------------
__int64 __fastcall sub_40AEC0()
{
  int v0; // edi
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r12
  int v5; // eax
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9

  v1 = sub_40B6FB();
  v4 = v1;
  if ( v1 )
  {
    *(_DWORD *)(v1 + 12) = v0;
    *(_QWORD *)(v1 + 40) = 4239440i64;
    *(_QWORD *)(v1 + 48) = 4238816i64;
    *(_BYTE *)v1 = (unsigned int)sub_4023B0(v3, v2) != 0;
    v5 = sub_40AC60();
    *(_DWORD *)(v4 + 32) = 4096;
    *(_DWORD *)(v4 + 4) = v5;
    v6 = sub_40B713();
    *(_QWORD *)(v4 + 24) = v6;
    if ( v6 )
    {
      if ( ((unsigned int)qword_440910 & *(_DWORD *)(v4 + 4)) != qword_440938 )
        sub_401FA0(v8);
    }
    else
    {
      v4 = 0i64;
      sub_40B701(v8, v7, v9, v10);
    }
  }
  return v4;
}
// 40AEEB: variable 'v0' is possibly undefined
// 40AF02: variable 'v3' is possibly undefined
// 40AF02: variable 'v2' is possibly undefined
// 40AF50: variable 'v8' is possibly undefined
// 40AF6A: variable 'v7' is possibly undefined
// 40AF6A: variable 'v9' is possibly undefined
// 40AF6A: variable 'v10' is possibly undefined
// 40B6FB: using guessed type __int64 sub_40B6FB(void);
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 40B713: using guessed type __int64 sub_40B713(void);
// 440910: using guessed type __int64 qword_440910;
// 440938: using guessed type __int64 qword_440938;

//----- (000000000040AF80) ----------------------------------------------------
__int64 __fastcall sub_40AF80()
{
  __int64 v0; // rdi
  __int64 result; // rax

  result = *(unsigned int *)(v0 + 12);
  if ( (_DWORD)result == -1 )
    return sub_402ACD();
  return result;
}
// 40AF80: variable 'v0' is possibly undefined

//----- (000000000040AFA0) ----------------------------------------------------
__int64 __fastcall sub_40AFA0()
{
  int v0; // edi
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 (*v4)(void); // rax
  __int64 result; // rax

  v2 = *(unsigned int *)(v1 + 16);
  if ( (unsigned int)v2 >= *(_DWORD *)(v1 + 32) )
    return sub_40AD90();
  v3 = *(_QWORD *)(v1 + 24);
  *(_DWORD *)(v1 + 16) = v2 + 1;
  *(_BYTE *)(v3 + v2) = v0;
  if ( *(_DWORD *)(v1 + 16) == *(_DWORD *)(v1 + 32) )
  {
    v4 = *(__int64 (**)(void))(v1 + 48);
    if ( v4 )
      goto LABEL_7;
    *(_DWORD *)(v1 + 16) = 0;
  }
  else if ( *(_BYTE *)v1 == 2 || v0 == 10 && *(_BYTE *)v1 == 1 )
  {
    v4 = *(__int64 (**)(void))(v1 + 48);
    if ( v4 )
    {
LABEL_7:
      result = v4();
      if ( (_DWORD)result == -1 )
        return result;
    }
  }
  return (unsigned __int8)v0;
}
// 40AFAE: variable 'v1' is possibly undefined
// 40AFC0: variable 'v0' is possibly undefined
// 40AFA0: using guessed type __int64 __fastcall sub_40AFA0();

//----- (000000000040B050) ----------------------------------------------------
void __fastcall sub_40B050(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rax

  v2 = sub_410F70(a1);
  if ( v2 == -1 )
  {
    sub_40B0B0();
  }
  else if ( v2 )
  {
    *(_DWORD *)(v1 + 16) = 0;
    *(_DWORD *)(v1 + 20) = v2;
  }
  else
  {
    sub_40AD90();
  }
}
// 40B077: variable 'v1' is possibly undefined

//----- (000000000040B0B0) ----------------------------------------------------
void sub_40B0B0()
{
  JUMPOUT(0x40ADA0i64);
}
// 40B0B6: control flows out of bounds to 40ADA0
// 448020: using guessed type int dword_448020;

//----- (000000000040B0C0) ----------------------------------------------------
__int64 __fastcall sub_40B0C0(_QWORD *a1)
{
  if ( !*a1 )
    return sub_402B21();
  if ( (dword_41C718 & 4) != 0 )
    return sub_403410((__int64)a1);
  return sub_40B110();
}
// 41C718: using guessed type int dword_41C718;

//----- (000000000040B110) ----------------------------------------------------
__int64 __fastcall sub_40B110()
{
  _DWORD *v0; // rsi
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  unsigned int v5; // er12
  __int64 j; // rbx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 i; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  int v14; // eax
  __int64 v15; // [rsp+0h] [rbp-90h]
  char v16; // [rsp+Ch] [rbp-84h]
  __int64 v17; // [rsp+18h] [rbp-78h]
  __int16 v18; // [rsp+45h] [rbp-4Bh]
  char v19; // [rsp+47h] [rbp-49h]
  __int64 v20; // [rsp+48h] [rbp-48h]
  int v21[2]; // [rsp+50h] [rbp-40h]

  if ( (unsigned __int8)sub_414880() || (unsigned __int8)sub_414880() )
  {
    v20 = 0i64;
    sub_4123B0(0i64, (unsigned int)qword_440938);
    sub_4123D0(v8, 8i64);
    sub_412330(v10, v9);
  }
  v5 = 0;
  if ( *v0 != -1 )
  {
    if ( v0[1] != -1 )
      goto LABEL_5;
LABEL_16:
    v5 |= sub_4100BB(v2, v1);
    if ( v0[2] != -1 )
      goto LABEL_6;
LABEL_17:
    v5 |= sub_4100BB(v2, v1);
    goto LABEL_6;
  }
  v5 = sub_4100BB(v2, v1);
  if ( v0[1] == -1 )
    goto LABEL_16;
LABEL_5:
  if ( v0[2] == -1 )
    goto LABEL_17;
LABEL_6:
  if ( v5 != -1 )
  {
    v5 = sub_40B4AE(v2);
    if ( !v5 )
    {
      if ( (v16 & 1) != 0 )
      {
        if ( (unsigned int)sub_4114B0(v2, v1) == -1 )
          goto LABEL_24;
        v14 = sub_412370(v13, v12);
        if ( v14 == -1 )
          goto LABEL_24;
        if ( v14 > 0 )
          sub_416001();
      }
      for ( i = 0i64; i != 3; ++i )
      {
        if ( v0[i] == -1 )
          sub_412330(1i64, v1);
        sub_412340(v2, v1);
      }
      sub_412350(v2, v15);
LABEL_24:
      sub_401114();
    }
  }
  for ( j = 0i64; j != 3; ++j )
  {
    if ( v0[j] == -1 )
    {
      sub_412330(v2, v1);
      v1 = 1i64;
      v19 = 0;
      v18 = 1;
      if ( v5 == -1 )
        sub_412330(v2, 1i64);
      else
        v0[j] = v21[2 * j + *((char *)&v18 + j)];
    }
  }
  if ( v17 )
    sub_40B701(v2, v1, v3, v4);
  return v5;
}
// 40B141: ignored the value written to the shadow area of the succeeding call
// 40B13A: ignored the value written to the shadow area of the succeeding call
// 40B132: ignored the value written to the shadow area of the succeeding call
// 40B120: ignored the value written to the shadow area of the succeeding call
// 40B23E: conditional instruction was optimized away because eax.4==1
// 40B172: variable 'v0' is possibly undefined
// 40B19D: variable 'v2' is possibly undefined
// 40B1CE: variable 'v17' is possibly undefined
// 40B1D3: variable 'v1' is possibly undefined
// 40B1D3: variable 'v3' is possibly undefined
// 40B1D3: variable 'v4' is possibly undefined
// 40B21D: variable 'v8' is possibly undefined
// 40B225: variable 'v10' is possibly undefined
// 40B225: variable 'v9' is possibly undefined
// 40B340: variable 'v16' is possibly undefined
// 40B3BD: variable 'v15' is possibly undefined
// 40B44E: variable 'v13' is possibly undefined
// 40B44E: variable 'v12' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 40B707: using guessed type __int64 sub_40B707(void);
// 440938: using guessed type __int64 qword_440938;

//----- (000000000040B4AE) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40B4AE(__int64 a1)
{
  int v1; // er12
  __int64 v2; // rcx
  __int64 *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rax
  struct _SECURITY_ATTRIBUTES *v7; // r8
  BOOL v8; // er9
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  int *v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbp
  __int64 v16; // r12
  __int64 result; // rax
  int v18; // [rsp-178h] [rbp-178h]
  unsigned int v19; // [rsp-16Ch] [rbp-16Ch]
  __int64 v20; // [rsp-158h] [rbp-158h]
  _BYTE v21[128]; // [rsp-138h] [rbp-138h]
  int v22; // [rsp-B8h] [rbp-B8h]
  int v23; // [rsp-7Ch] [rbp-7Ch]
  __int64 v24; // [rsp-68h] [rbp-68h]
  __int64 v25; // [rsp-60h] [rbp-60h]
  __int64 v26; // [rsp-58h] [rbp-58h]
  __int64 v27; // [rsp-30h] [rbp-30h]
  void **v28; // [rsp-28h] [rbp-28h]
  __int64 v29; // [rsp-20h] [rbp-20h]
  __int64 v30; // [rsp-18h] [rbp-18h]
  __int64 v31; // [rsp-10h] [rbp-10h]
  __int64 v32; // [rsp-8h] [rbp-8h]
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  if ( (dword_41C718 & 4) != 0 )
  {
    v31 = v32;
    v30 = v15;
    v29 = v16;
    v28 = &retaddr;
    v27 = v14;
    v19 = sub_410830(a1);
    if ( v19 != -1 )
    {
      v1 = sub_4156EF();
      if ( v1 )
      {
        return 0;
      }
      else if ( sub_405F18(0, (struct _SECURITY_ATTRIBUTES *)&ProcessAttributes) )
      {
        v21[sub_412580()] = 32;
        sub_412580();
        sub_40B720();
        sub_41561F(v2, 0x68ui64);
        v4 = *v3;
        v22 = 104;
        v23 = 256;
        v24 = v4;
        v5 = v3[3];
        v6 = v3[6];
        v25 = v5;
        v26 = v6;
        if ( (unsigned int)sub_403C50((LPSECURITY_ATTRIBUTES)&ProcessAttributes, qword_448018, v7, v8) != -1 )
        {
          sub_405EF5();
          sub_405EF5();
          v9 = qword_447B50 + 24i64 * v18;
          *(_DWORD *)(v9 + 16) = 3;
          *(_QWORD *)v9 = v20;
          *(_DWORD *)(v9 + 20) = qword_440920;
          sub_403710(v10, 0x40ui64);
          sub_403710(v11, 4ui64);
          if ( dword_446EE0 > 0 )
          {
            v13 = dword_446EE8;
            do
            {
              sub_403710(v12, 0x18ui64);
              if ( (v13[5] & 2) != 0 )
                sub_403710(v12, ((__int64)(v13[1] - *v13) << 16) + 0x10000);
              ++v1;
              v13 += 6;
            }
            while ( dword_446EE0 > v1 );
          }
          sub_403710(v12, 0x2D000ui64);
          sub_405EF5();
        }
        sub_40F750();
      }
      else
      {
        return (unsigned int)sub_4162A0();
      }
    }
    return v19;
  }
  else
  {
    result = (unsigned int)dword_440900;
    if ( dword_440900 == -1 )
      JUMPOUT(0x4147FCi64);
    if ( (dword_41C718 & 0x38) != 0 )
      __asm { syscall; Low latency system call }
    else
      __asm { syscall; Low latency system call }
  }
  return result;
}
// 40B4CB: positive sp value 8 has been found
// 41480D: control flows out of bounds to 4147FC
// 40B4DD: control flows out of bounds to 4147FA
// 403AF8: ignored the value written to the shadow area of the succeeding call
// 403AF6: ignored the value written to the shadow area of the succeeding call
// 403AEF: ignored the value written to the shadow area of the succeeding call
// 403AE7: ignored the value written to the shadow area of the succeeding call
// 40B4AE: could not find valid save-restore pair for rbx
// 40B4AE: could not find valid save-restore pair for rbp
// 40B4AE: could not find valid save-restore pair for r12
// 4039BD: variable 'v15' is possibly undefined
// 4039C1: variable 'v16' is possibly undefined
// 4039C5: variable 'v14' is possibly undefined
// 403A01: variable 'v19' is possibly undefined
// 403AA7: variable 'v2' is possibly undefined
// 403AAC: variable 'v3' is possibly undefined
// 403AFA: variable 'v7' is possibly undefined
// 403AFA: variable 'v8' is possibly undefined
// 403B24: variable 'v18' is possibly undefined
// 403B56: variable 'v20' is possibly undefined
// 403B68: variable 'v10' is possibly undefined
// 403B7E: variable 'v11' is possibly undefined
// 403BB9: variable 'v12' is possibly undefined
// 40F750: using guessed type __int64 __fastcall sub_40F750();
// 4156EF: using guessed type __int64 __fastcall sub_4156EF();
// 41C718: using guessed type int dword_41C718;
// 440870: using guessed type int dword_440870;
// 440900: using guessed type int dword_440900;
// 440920: using guessed type __int64 qword_440920;
// 446EE0: using guessed type int dword_446EE0;
// 446EE8: using guessed type int dword_446EE8[];
// 447B50: using guessed type __int64 qword_447B50;
// 448018: using guessed type __int64 qword_448018;

//----- (000000000040B4F0) ----------------------------------------------------
__int64 __fastcall sub_40B4F0(__int16 a1, _QWORD *a2)
{
  _QWORD *v2; // rdi
  __int64 *v3; // rsi
  __int64 v5; // rax
  __int64 result; // rax
  char v7; // r8

  v5 = *v3;
  if ( (unsigned __int64)(*v3 + 1) < *a2 )
    goto LABEL_2;
  v7 = sub_40F180(1i64, 2ui64);
  result = 0xFFFFFFFFi64;
  if ( v7 )
  {
    v5 = *v3;
LABEL_2:
    *(_WORD *)(*v2 + 2 * v5) = a1;
    return (*v3)++;
  }
  return result;
}
// 40B509: variable 'v3' is possibly undefined
// 40B515: variable 'v2' is possibly undefined

//----- (000000000040B560) ----------------------------------------------------
__int64 __fastcall sub_40B560(signed __int64 a1, char *a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // r8
  char v7; // r15
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r14
  __int64 v11; // r13
  int v12; // eax
  _QWORD *v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // r8
  _QWORD *v19; // rdi
  char v20; // al
  __int64 v21; // rsi
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rbx
  __int64 v24; // [rsp-40h] [rbp-40h]
  __int64 v25; // [rsp-40h] [rbp-40h]

  if ( a1 > v3 )
    return 0i64;
  v4 = v2;
  if ( !a1 )
    return v4;
  v7 = *a2;
  sub_415783();
  v10 = v8;
  v4 = v8;
  if ( !v8 )
    return v4;
  if ( a1 == 1 )
    return v4;
  v11 = v3 - (v8 - v24);
  if ( a1 < (unsigned __int64)v11 )
  {
    v12 = sub_414960(v9, a1);
    v4 = v10;
    if ( !v12 )
      return v4;
  }
  v14 = (_QWORD *)sub_40B707();
  v18 = v25;
  *v14 = -1i64;
  v19 = v14;
  v14[1] = 0i64;
  if ( a1 > 2 )
  {
    v20 = v7;
    v16 = 0i64;
    v15 = 2i64;
    while ( 1 )
    {
      v21 = v15;
      if ( a2[v15 - 1] == v20 )
      {
        ++v16;
        ++v15;
        v19[v21] = v16;
        if ( a1 <= v15 )
          break;
      }
      else
      {
        if ( v16 <= 0 )
          v19[v15++] = 0i64;
        else
          v16 = v19[v16];
        if ( a1 <= v15 )
          break;
      }
      v20 = a2[v16];
    }
  }
  *(_QWORD *)((char *)v19 + v25 - 8) = 0i64;
  if ( v11 <= 0 )
  {
    v23 = 0i64;
    goto LABEL_25;
  }
  v22 = 0i64;
  v18 = 0i64;
  v15 = 0i64;
  while ( *(_BYTE *)(v10 + v18) != v7 )
  {
    v16 = v19[v15];
    v22 = v18 - v16;
    if ( v15 <= 0 )
      goto LABEL_23;
    v15 = v19[v15];
    if ( v11 <= v18 )
      goto LABEL_24;
LABEL_20:
    v7 = a2[v15];
  }
  if ( a1 == ++v15 )
    goto LABEL_24;
LABEL_23:
  v18 = v15 + v22;
  if ( v11 > (__int64)(v15 + v22) )
    goto LABEL_20;
LABEL_24:
  v23 = v22;
LABEL_25:
  sub_40B701(v16, v15, v18, v17);
  v4 = 0i64;
  if ( v11 > v23 )
    return v10 + v23;
  return v4;
}
// 40B5FB: ignored the value written to the shadow area of the succeeding call
// 40B563: variable 'v3' is possibly undefined
// 40B56A: variable 'v2' is possibly undefined
// 40B59D: variable 'v8' is possibly undefined
// 40B5B6: variable 'v24' is possibly undefined
// 40B5CA: variable 'v9' is possibly undefined
// 40B608: variable 'v25' is possibly undefined
// 40B6B7: variable 'v16' is possibly undefined
// 40B6B7: variable 'v15' is possibly undefined
// 40B6B7: variable 'v17' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 40B707: using guessed type __int64 sub_40B707(void);

//----- (000000000040B720) ----------------------------------------------------
__int64 sub_40B720()
{
  char *v0; // rbx
  char *v1; // r14
  __int64 v2; // rax
  unsigned __int64 v3; // rdx
  char *v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rcx

  v0 = sub_41571A();
  v1 = sub_41571A();
  v2 = sub_40B707();
  v3 = (unsigned __int64)v0;
  v4 = &v0[v2];
  sub_4154C0(v5, v3);
  *v4 = 61;
  sub_4154C0(v6, (unsigned __int64)(v1 + 1));
  return sub_40B7E0();
}
// 40B763: variable 'v5' is possibly undefined
// 40B776: variable 'v6' is possibly undefined
// 40B707: using guessed type __int64 sub_40B707(void);

//----- (000000000040B7A0) ----------------------------------------------------
void sub_40B7A0()
{
  char *v0; // r12
  __int64 v1; // rcx

  v0 = sub_41571A() + 1;
  if ( sub_40B707() )
    sub_4154C0(v1, (unsigned __int64)v0);
}
// 40B7C9: variable 'v1' is possibly undefined
// 40B707: using guessed type __int64 sub_40B707(void);

//----- (000000000040B7E0) ----------------------------------------------------
__int64 __fastcall sub_40B7E0()
{
  __int64 v0; // rdi
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  unsigned int v6; // er13
  int v7; // er12
  __int64 v8; // rbx
  __int64 v10; // r12
  __int64 v11; // r12
  char v12; // [rsp+4h] [rbp-3Ch]
  __int64 v13; // [rsp+8h] [rbp-38h]

  sub_41576B();
  if ( v1 )
  {
    v6 = v1 + 1 - v0;
    v13 = qword_448018;
    if ( *(_QWORD *)qword_448018 )
    {
      v7 = 0;
      v8 = 0i64;
      while ( 1 )
      {
        if ( !(unsigned int)sub_414C00(v3, v6) )
        {
          if ( v12 )
            goto LABEL_8;
          sub_40B701(v3, v2, v4, v5);
          return 0i64;
        }
        v3 = v13;
        v8 = 8i64 * (unsigned int)(v7 + 1);
        if ( !*(_QWORD *)(v13 + v8) )
          break;
        ++v7;
      }
      v10 = (unsigned int)(v7 + 2);
      if ( (unsigned int)v10 > 0x1FF )
        goto LABEL_15;
      v11 = 8 * v10;
    }
    else
    {
      v11 = 8i64;
      v8 = 0i64;
    }
    *(_QWORD *)(v13 + v11) = 0i64;
LABEL_8:
    sub_40B701(v3, v2, v4, v5);
    *(_QWORD *)(qword_448018 + v8) = v0;
    return 0i64;
  }
  else
  {
LABEL_15:
    sub_40B701(v3, v2, v4, v5);
    return sub_402B21();
  }
}
// 40B7F4: ignored the value written to the shadow area of the succeeding call
// 40B8B8: ignored the value written to the shadow area of the succeeding call
// 40B804: variable 'v1' is possibly undefined
// 40B815: variable 'v0' is possibly undefined
// 40B83D: variable 'v13' is possibly undefined
// 40B85D: variable 'v3' is possibly undefined
// 40B86A: variable 'v12' is possibly undefined
// 40B86F: variable 'v2' is possibly undefined
// 40B86F: variable 'v4' is possibly undefined
// 40B86F: variable 'v5' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 448018: using guessed type __int64 qword_448018;

//----- (000000000040B8D0) ----------------------------------------------------
__int64 sub_40B8D0()
{
  sub_40B7A0();
  return sub_40B7E0();
}

//----- (000000000040B8F0) ----------------------------------------------------
void __fastcall sub_40B8F0()
{
  unsigned __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  unsigned __int64 v2; // r12
  __int64 v3; // rax
  __int64 v4; // rcx

  if ( is_mul_ok(v1, v0) )
    v2 = v1 * v0;
  else
    v2 = -1i64;
  v3 = sub_40C5F0();
  if ( v3 )
  {
    if ( (*(_BYTE *)(v3 - 8) & 3) != 0 )
      sub_41561F(v4, v2);
  }
}
// 40B8FD: variable 'v1' is possibly undefined
// 40B8FD: variable 'v0' is possibly undefined
// 40B920: variable 'v4' is possibly undefined

//----- (000000000040B940) ----------------------------------------------------
__int64 __fastcall sub_40B940()
{
  __int64 v0; // rdi
  __int64 v1; // rbx
  __int64 *v2; // rax
  int v3; // edx
  int v4; // er15
  __int64 v5; // r12
  __int64 v7; // rdi
  __int64 v8; // r14
  __int64 v9; // rdx
  unsigned __int64 v10; // r13
  _QWORD *v11; // rdx
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  unsigned __int64 v19; // rax
  __int64 v20; // rsi
  unsigned int v21; // ecx
  int v22; // eax
  int v23; // eax
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rax
  __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  _QWORD *v30; // rax
  _QWORD *v31; // rcx
  _QWORD *v32; // rsi
  __int64 v33; // rcx
  __int64 v34; // rax
  __int64 v35; // [rsp+8h] [rbp-38h]

  v1 = v0;
  v2 = *(__int64 **)(v0 + 904);
  if ( !v2 )
    goto LABEL_3;
  v3 = *((_DWORD *)v2 + 6);
  v4 = v3 & 1;
  if ( (v3 & 1) == 0 || (v3 & 8) != 0 )
    goto LABEL_3;
  v7 = *v2;
  v8 = *v2;
  if ( (*v2 & 0xF) != 0 )
    v8 = v7 + (-(*(_DWORD *)v2 + 16) & 0xF);
  v9 = *(_QWORD *)(v8 + 8);
  v5 = 0i64;
  if ( (v9 & 3) != 1 )
    goto LABEL_4;
  v5 = v2[1];
  v10 = v9 & 0xFFFFFFFFFFFFFFF8ui64;
  if ( v8 + (v9 & 0xFFFFFFFFFFFFFFF8ui64) < v7 + v5 - 80 )
  {
LABEL_3:
    v5 = 0i64;
    goto LABEL_4;
  }
  if ( *(_QWORD *)(v1 + 32) == v8 )
  {
    *(_QWORD *)(v1 + 32) = 0i64;
    *(_QWORD *)(v1 + 8) = 0i64;
    goto LABEL_29;
  }
  v11 = *(_QWORD **)(v8 + 24);
  v12 = *(_QWORD *)(v8 + 48);
  if ( v11 == (_QWORD *)v8 )
  {
    v30 = *(_QWORD **)(v8 + 40);
    v31 = (_QWORD *)(v8 + 40);
    if ( !v30 )
    {
      v30 = *(_QWORD **)(v8 + 32);
      if ( !v30 )
      {
        if ( !v12 )
          goto LABEL_29;
        v11 = 0i64;
        v33 = *(unsigned int *)(v8 + 56);
        v34 = v1 + 8 * v33;
        if ( *(_QWORD *)(v34 + 600) == v8 )
        {
          *(_QWORD *)(v34 + 600) = 0i64;
          *(_DWORD *)(v1 + 4) &= __ROL4__(-2, v33);
          goto LABEL_29;
        }
LABEL_18:
        v15 = *(_QWORD *)(v1 + 24);
        if ( v15 > v12 )
          goto LABEL_60;
        if ( *(_QWORD *)(v12 + 32) == v8 )
          *(_QWORD *)(v12 + 32) = v11;
        else
          *(_QWORD *)(v12 + 40) = v11;
        if ( !v11 )
          goto LABEL_29;
        goto LABEL_22;
      }
      v31 = (_QWORD *)(v8 + 32);
    }
    do
    {
      do
      {
        v32 = v31;
        v11 = v30;
        v31 = v30 + 5;
        v30 = (_QWORD *)v30[5];
      }
      while ( v30 );
      v30 = (_QWORD *)v11[4];
      v31 = v11 + 4;
    }
    while ( v30 );
    if ( *(_QWORD *)(v1 + 24) > (unsigned __int64)v32 )
      goto LABEL_60;
    *v32 = 0i64;
  }
  else
  {
    v13 = *(_QWORD *)(v8 + 16);
    if ( *(_QWORD *)(v1 + 24) > v13 || *(_QWORD *)(v13 + 24) != v8 || v11[2] != v8 )
      goto LABEL_60;
    *(_QWORD *)(v13 + 24) = v11;
    v11[2] = v13;
  }
  if ( !v12 )
    goto LABEL_29;
  v14 = v1 + 8i64 * *(unsigned int *)(v8 + 56);
  if ( *(_QWORD *)(v14 + 600) != v8 )
    goto LABEL_18;
  *(_QWORD *)(v14 + 600) = v11;
  v15 = *(_QWORD *)(v1 + 24);
LABEL_22:
  if ( (unsigned __int64)v11 < v15 )
    goto LABEL_60;
  v16 = *(_QWORD *)(v8 + 32);
  v11[6] = v12;
  if ( v16 )
  {
    if ( v16 < v15 )
      goto LABEL_60;
    v11[4] = v16;
    *(_QWORD *)(v16 + 48) = v11;
  }
  v17 = *(_QWORD *)(v8 + 40);
  if ( v17 )
  {
    if ( v17 < v15 )
      goto LABEL_60;
    v11[5] = v17;
    *(_QWORD *)(v17 + 48) = v11;
  }
LABEL_29:
  if ( (unsigned int)sub_40F560() )
  {
    v18 = 600i64;
    v19 = v10 >> 8;
    v20 = (unsigned int)(v10 >> 8);
    v21 = v10 >> 8;
    if ( v21 )
    {
      if ( (unsigned int)v19 > 0xFFFF )
      {
        v4 = 0x80000000;
        v18 = 848i64;
        v21 = 31;
        v20 = 31i64;
      }
      else
      {
        _BitScanReverse((unsigned int *)&v19, v19);
        v22 = v19 ^ 0x1F;
        v20 = ((unsigned int)(v10 >> (38 - (unsigned __int8)v22)) & 1) + 2 * (31 - v22);
        v21 = ((v10 >> (38 - (unsigned __int8)v22)) & 1) + 2 * (31 - v22);
        v18 = 8 * v20 + 600;
        v4 = 1 << (((v10 >> (38 - (unsigned __int8)v22)) & 1) + 2 * (31 - v22));
      }
    }
    v23 = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(v8 + 56) = v21;
    *(_QWORD *)(v8 + 40) = 0i64;
    *(_QWORD *)(v8 + 32) = 0i64;
    if ( (v4 & v23) != 0 )
    {
      v24 = *(_QWORD *)(v1 + 8 * v20 + 600);
      v25 = v10;
      if ( v21 != 31 )
        v25 = v10 << (57 - (unsigned __int8)(v21 >> 1));
      while ( (*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != v10 )
      {
        v26 = v25;
        v25 *= 2i64;
        v27 = (v26 >> 63) + 4;
        if ( !*(_QWORD *)(v24 + 8 * v27) )
        {
          if ( *(_QWORD *)(v1 + 24) <= v24 + 8 * v27 )
          {
            *(_QWORD *)(v24 + 8 * v27) = v8;
            v5 = 0i64;
            *(_QWORD *)(v8 + 48) = v24;
            *(_QWORD *)(v8 + 24) = v8;
            *(_QWORD *)(v8 + 16) = v8;
            goto LABEL_4;
          }
LABEL_60:
          sub_401114();
        }
        v24 = *(_QWORD *)(v24 + 8 * v27);
      }
      v28 = *(_QWORD *)(v24 + 16);
      v29 = *(_QWORD *)(v1 + 24);
      if ( v29 > v28 || v29 > v24 )
        goto LABEL_60;
      *(_QWORD *)(v28 + 24) = v8;
      v5 = 0i64;
      *(_QWORD *)(v24 + 16) = v8;
      *(_QWORD *)(v8 + 16) = v28;
      *(_QWORD *)(v8 + 24) = v24;
      *(_QWORD *)(v8 + 48) = 0i64;
    }
    else
    {
      v5 = 0i64;
      *(_DWORD *)(v1 + 4) = v23 | v4;
      *(_QWORD *)(v1 + 8 * v20 + 600) = v8;
      *(_QWORD *)(v8 + 48) = v1 + v18;
      *(_QWORD *)(v8 + 24) = v8;
      *(_QWORD *)(v8 + 16) = v8;
    }
  }
  else
  {
    *(_QWORD *)(v1 + 856) -= v5;
    *(_QWORD *)(v1 + 904) = v35;
  }
LABEL_4:
  *(_QWORD *)(v1 + 56) = 128i64;
  return v5;
}
// 40B94D: variable 'v0' is possibly undefined
// 40BABA: variable 'v35' is possibly undefined

//----- (000000000040BD00) ----------------------------------------------------
__int64 __fastcall sub_40BD00()
{
  unsigned __int64 v0; // rsi

  if ( v0 <= 0xFFFFFFFFFFFFFF7Fui64 )
    return sub_40BD10();
  else
    return 0i64;
}
// 40BD07: variable 'v0' is possibly undefined

//----- (000000000040BD10) ----------------------------------------------------
__int64 __fastcall sub_40BD10()
{
  _QWORD *v0; // rdi
  __int64 v1; // rsi
  _QWORD *v2; // r12
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rsi
  _QWORD *v6; // r8
  unsigned __int64 *v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // r9
  int v10; // eax
  unsigned __int64 v11; // r13
  __int64 v12; // r8
  __int64 result; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rax
  __int64 v18; // rsi
  __int64 v19; // rax
  __int64 v20; // rax

  v2 = v0;
  v3 = v0[5];
  if ( !v3 )
    return 0i64;
  v4 = v0[2];
  v5 = v1 + 80;
  if ( v4 > v5 )
  {
    v6 = v0 + 111;
    v7 = v0 + 111;
    while ( 1 )
    {
      v8 = *v7;
      if ( v3 >= *v7 )
      {
        v9 = v7[1];
        if ( v3 < v8 + v9 )
          break;
      }
      v7 = (unsigned __int64 *)v7[2];
      if ( !v7 )
        JUMPOUT(0x402A11i64);
    }
    v10 = *((_DWORD *)v7 + 6);
    if ( (v10 & 8) == 0 && (v10 & 1) != 0 )
    {
      v11 = qword_4466D0 * ((v4 + qword_4466D0 - 1 - v5) / qword_4466D0 - 1);
      if ( v11 <= v9 )
      {
        while ( v8 > (unsigned __int64)v6 || v8 + v9 <= (unsigned __int64)v6 )
        {
          v6 = (_QWORD *)v6[2];
          if ( !v6 )
          {
            if ( (sub_40F550() != -1 || !(unsigned int)sub_40F560()) && v11 )
            {
              v14 = v2[2];
              v15 = v2[5];
              v7[1] -= v11;
              v16 = v14 - v11;
              v2[107] -= v11;
              if ( (v15 & 0xF) != 0 )
              {
                v17 = -((_DWORD)v15 + 16) & 0xF;
                v18 = v15 + v17;
                v19 = v16 - v17;
              }
              else
              {
                v19 = v16;
                v18 = v15;
              }
              v2[2] = v19;
              v2[5] = v18;
              *(_QWORD *)(v18 + 8) = v19 | 1;
              v20 = qword_4466E0;
              *(_QWORD *)(v15 + v16 + 8) = 80i64;
              v2[6] = v20;
              goto LABEL_9;
            }
            break;
          }
        }
      }
    }
  }
  v11 = 0i64;
LABEL_9:
  v12 = sub_40B940();
  result = 1i64;
  if ( !(v12 + v11) )
  {
    if ( v2[2] > v2[6] )
      v2[6] = -1i64;
    return 0i64;
  }
  return result;
}
// 40BE94: control flows out of bounds to 402A11
// 40BD1A: variable 'v0' is possibly undefined
// 40BD2B: variable 'v1' is possibly undefined
// 4466D0: using guessed type __int64 qword_4466D0;
// 4466E0: using guessed type __int64 qword_4466E0;

//----- (000000000040BEA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_40BEA0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // r9
  _QWORD *v10; // r8
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // r11
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 result; // rax
  __int64 v18; // r11
  unsigned __int64 v19; // rax
  _QWORD *v20; // r8
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // r12
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // rax
  unsigned int v29; // ecx
  int v30; // eax
  __int64 v31; // r10
  __int64 v32; // r8
  int v33; // eax
  int v34; // esi
  _QWORD *v35; // rax
  __int64 v36; // r10
  _QWORD *v37; // rax
  __int64 v38; // r10
  __int64 v39; // r12
  unsigned __int64 v40; // rsi
  unsigned __int64 v41; // r8
  unsigned __int64 v42; // rax
  __int64 v43; // rax
  unsigned __int64 v44; // rdx
  unsigned __int64 v45; // rdx
  _QWORD *v46; // rax
  _QWORD *v47; // rcx
  _QWORD *v48; // r10
  _QWORD *v49; // rax
  _QWORD *v50; // rcx
  _QWORD *v51; // r10
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 v54; // rcx
  __int64 v55; // rax

  v4 = v2;
  v5 = v3;
  v6 = a2 + v3;
  v7 = *(_QWORD *)(v5 + 8);
  if ( (v7 & 1) != 0 )
  {
    v9 = *(_QWORD *)(v4 + 24);
    goto LABEL_25;
  }
  v8 = *(_QWORD *)v5;
  v5 -= *(_QWORD *)v5;
  if ( (v7 & 3) == 0 )
  {
    v39 = v8 + a2 + 32;
    result = sub_40F560();
    if ( !(_DWORD)result )
      *(_QWORD *)(v4 + 856) -= v39;
    return result;
  }
  v9 = *(_QWORD *)(v4 + 24);
  a2 += v8;
  if ( v9 > v5 )
    goto LABEL_127;
  if ( *(_QWORD *)(v4 + 32) == v5 )
  {
    v43 = *(_QWORD *)(v6 + 8);
    if ( (v43 & 3) == 3 )
    {
      *(_QWORD *)(v4 + 8) = a2;
      *(_QWORD *)(v6 + 8) = v43 & 0xFFFFFFFFFFFFFFFEui64;
      result = a2 | 1;
      *(_QWORD *)(v5 + 8) = a2 | 1;
      *(_QWORD *)v6 = a2;
      return result;
    }
    goto LABEL_25;
  }
  v10 = *(_QWORD **)(v5 + 24);
  v11 = v8 >> 3;
  if ( v8 <= 0xFF )
  {
    v37 = *(_QWORD **)(v5 + 16);
    v38 = v4 + 8i64 * (unsigned int)(2 * v11) + 72;
    if ( (_QWORD *)v38 == v37 )
    {
      if ( v10 == v37 )
      {
LABEL_68:
        *(_DWORD *)v4 &= __ROL4__(-2, v11);
        goto LABEL_25;
      }
    }
    else
    {
      if ( v9 > (unsigned __int64)v37 || v37[3] != v5 )
        goto LABEL_127;
      if ( v10 == v37 )
        goto LABEL_68;
      if ( (_QWORD *)v38 == v10 )
      {
LABEL_110:
        v37[3] = v10;
        v10[2] = v37;
        goto LABEL_25;
      }
    }
    if ( v9 > (unsigned __int64)v10 || v10[2] != v5 )
      goto LABEL_127;
    goto LABEL_110;
  }
  v12 = *(_QWORD *)(v5 + 48);
  if ( (_QWORD *)v5 == v10 )
  {
    v49 = *(_QWORD **)(v5 + 40);
    v50 = (_QWORD *)(v5 + 40);
    if ( !v49 )
    {
      v49 = *(_QWORD **)(v5 + 32);
      if ( !v49 )
      {
        if ( !v12 )
          goto LABEL_25;
        v10 = 0i64;
        v54 = *(unsigned int *)(v5 + 56);
        v55 = v4 + 8 * v54;
        if ( v5 == *(_QWORD *)(v55 + 600) )
        {
          *(_QWORD *)(v55 + 600) = 0i64;
          *(_DWORD *)(v4 + 4) &= __ROL4__(-2, v54);
          goto LABEL_25;
        }
LABEL_13:
        if ( v9 > v12 )
          goto LABEL_127;
        if ( *(_QWORD *)(v12 + 32) == v5 )
          *(_QWORD *)(v12 + 32) = v10;
        else
          *(_QWORD *)(v12 + 40) = v10;
        if ( !v10 )
          goto LABEL_25;
        goto LABEL_17;
      }
      v50 = (_QWORD *)(v5 + 32);
    }
    do
    {
      do
      {
        v51 = v50;
        v10 = v49;
        v50 = v49 + 5;
        v49 = (_QWORD *)v49[5];
      }
      while ( v49 );
      v49 = (_QWORD *)v10[4];
      v50 = v10 + 4;
    }
    while ( v49 );
    if ( v9 > (unsigned __int64)v51 )
      goto LABEL_127;
    *v51 = 0i64;
  }
  else
  {
    v13 = *(_QWORD *)(v5 + 16);
    if ( v9 > v13 || *(_QWORD *)(v13 + 24) != v5 || v10[2] != v5 )
      goto LABEL_127;
    *(_QWORD *)(v13 + 24) = v10;
    v10[2] = v13;
  }
  if ( !v12 )
    goto LABEL_25;
  v14 = v4 + 8i64 * *(unsigned int *)(v5 + 56);
  if ( *(_QWORD *)(v14 + 600) != v5 )
    goto LABEL_13;
  *(_QWORD *)(v14 + 600) = v10;
LABEL_17:
  if ( v9 > (unsigned __int64)v10 )
    goto LABEL_127;
  v15 = *(_QWORD *)(v5 + 32);
  v10[6] = v12;
  if ( v15 )
  {
    if ( v9 > v15 )
      goto LABEL_127;
    v10[4] = v15;
    *(_QWORD *)(v15 + 48) = v10;
  }
  v16 = *(_QWORD *)(v5 + 40);
  if ( v16 )
  {
    if ( v9 > v16 )
      goto LABEL_127;
    v10[5] = v16;
    *(_QWORD *)(v16 + 48) = v10;
  }
LABEL_25:
  if ( v9 > v6 )
    goto LABEL_127;
  result = *(_QWORD *)(v6 + 8);
  if ( (result & 2) == 0 )
  {
    v18 = *(_QWORD *)(v4 + 32);
    if ( *(_QWORD *)(v4 + 40) == v6 )
    {
      v44 = *(_QWORD *)(v4 + 16) + a2;
      *(_QWORD *)(v4 + 40) = v5;
      *(_QWORD *)(v4 + 16) = v44;
      *(_QWORD *)(v5 + 8) = v44 | 1;
      if ( v18 == v5 )
      {
        *(_QWORD *)(v4 + 32) = 0i64;
        *(_QWORD *)(v4 + 8) = 0i64;
      }
      return result;
    }
    if ( v18 == v6 )
    {
      v45 = *(_QWORD *)(v4 + 8) + a2;
      *(_QWORD *)(v4 + 32) = v5;
      *(_QWORD *)(v4 + 8) = v45;
      result = v45 | 1;
      *(_QWORD *)(v5 + 8) = v45 | 1;
      *(_QWORD *)(v5 + v45) = v45;
      return result;
    }
    v19 = result & 0xFFFFFFFFFFFFFFF8ui64;
    v20 = *(_QWORD **)(v6 + 24);
    a2 += v19;
    v21 = v19 >> 3;
    if ( v19 > 0xF8 )
    {
      v22 = *(_QWORD *)(v6 + 48);
      if ( v20 == (_QWORD *)v6 )
      {
        v46 = *(_QWORD **)(v6 + 40);
        v47 = (_QWORD *)(v6 + 40);
        if ( !v46 )
        {
          v46 = *(_QWORD **)(v6 + 32);
          if ( !v46 )
          {
            if ( !v22 )
              goto LABEL_48;
            v20 = 0i64;
            v52 = *(unsigned int *)(v6 + 56);
            v53 = v4 + 8 * v52;
            if ( *(_QWORD *)(v53 + 600) == v6 )
            {
              *(_QWORD *)(v53 + 600) = 0i64;
              *(_DWORD *)(v4 + 4) &= __ROL4__(-2, v52);
              goto LABEL_48;
            }
LABEL_37:
            if ( v9 > v22 )
              goto LABEL_127;
            if ( *(_QWORD *)(v22 + 32) == v6 )
              *(_QWORD *)(v22 + 32) = v20;
            else
              *(_QWORD *)(v22 + 40) = v20;
            if ( v20 )
            {
LABEL_41:
              if ( (unsigned __int64)v20 < v9 )
                goto LABEL_127;
              v25 = *(_QWORD *)(v6 + 32);
              v20[6] = v22;
              if ( v25 )
              {
                if ( v9 > v25 )
                  goto LABEL_127;
                v20[4] = v25;
                *(_QWORD *)(v25 + 48) = v20;
              }
              v26 = *(_QWORD *)(v6 + 40);
              if ( v26 )
              {
                if ( v9 > v26 )
                  goto LABEL_127;
                v20[5] = v26;
                *(_QWORD *)(v26 + 48) = v20;
              }
            }
LABEL_48:
            result = a2 | 1;
            *(_QWORD *)(v5 + 8) = a2 | 1;
            *(_QWORD *)(v5 + a2) = a2;
            if ( v18 == v5 )
            {
              *(_QWORD *)(v4 + 8) = a2;
              return result;
            }
            goto LABEL_51;
          }
          v47 = (_QWORD *)(v6 + 32);
        }
        do
        {
          do
          {
            v48 = v47;
            v20 = v46;
            v47 = v46 + 5;
            v46 = (_QWORD *)v46[5];
          }
          while ( v46 );
          v46 = (_QWORD *)v20[4];
          v47 = v20 + 4;
        }
        while ( v46 );
        if ( v9 > (unsigned __int64)v48 )
          goto LABEL_127;
        *v48 = 0i64;
      }
      else
      {
        v23 = *(_QWORD *)(v6 + 16);
        if ( v9 > v23 || *(_QWORD *)(v23 + 24) != v6 || v20[2] != v6 )
          goto LABEL_127;
        *(_QWORD *)(v23 + 24) = v20;
        v20[2] = v23;
      }
      if ( !v22 )
        goto LABEL_48;
      v24 = v4 + 8i64 * *(unsigned int *)(v6 + 56);
      if ( *(_QWORD *)(v24 + 600) == v6 )
      {
        *(_QWORD *)(v24 + 600) = v20;
        goto LABEL_41;
      }
      goto LABEL_37;
    }
    v35 = *(_QWORD **)(v6 + 16);
    v36 = v4 + 8i64 * (unsigned int)(2 * v21) + 72;
    if ( (_QWORD *)v36 == v35 )
    {
      if ( v20 == v35 )
      {
LABEL_65:
        *(_DWORD *)v4 &= __ROL4__(-2, v21);
        goto LABEL_48;
      }
    }
    else
    {
      if ( v9 > (unsigned __int64)v35 || v35[3] != v6 )
        goto LABEL_127;
      if ( v20 == v35 )
        goto LABEL_65;
      if ( (_QWORD *)v36 == v20 )
      {
LABEL_105:
        v35[3] = v20;
        v20[2] = v35;
        goto LABEL_48;
      }
    }
    if ( (unsigned __int64)v20 < v9 || v20[2] != v6 )
      goto LABEL_127;
    goto LABEL_105;
  }
  *(_QWORD *)(v6 + 8) = result & 0xFFFFFFFFFFFFFFFEui64;
  *(_QWORD *)(v5 + 8) = a2 | 1;
  *(_QWORD *)(v5 + a2) = a2;
LABEL_51:
  v27 = a2 >> 3;
  if ( a2 <= 0xFF )
  {
    if ( ((1 << v27) & *(_DWORD *)v4) != 0 )
    {
      result = *(_QWORD *)(v4 + 8i64 * (unsigned int)(2 * v27) + 88);
      if ( result < v9 )
        goto LABEL_127;
    }
    else
    {
      *(_DWORD *)v4 |= 1 << v27;
      result = v4 + 8i64 * (unsigned int)(2 * v27) + 72;
    }
    *(_QWORD *)(v4 + 8i64 * (unsigned int)(2 * v27) + 88) = v5;
    *(_QWORD *)(result + 24) = v5;
    *(_QWORD *)(v5 + 16) = result;
    *(_QWORD *)(v5 + 24) = v4 + 8i64 * (unsigned int)(2 * v27) + 72;
    return result;
  }
  v28 = a2 >> 8;
  v29 = a2 >> 8;
  if ( v29 )
  {
    if ( (unsigned int)v28 > 0xFFFF )
    {
      v33 = 0x80000000;
      v32 = 848i64;
      v29 = 31;
      v31 = 31i64;
    }
    else
    {
      _BitScanReverse((unsigned int *)&v28, v28);
      v30 = v28 ^ 0x1F;
      v31 = (unsigned int)((a2 >> (38 - (unsigned __int8)v30)) & 1) + 2 * (31 - v30);
      v29 = ((a2 >> (38 - (unsigned __int8)v30)) & 1) + 2 * (31 - v30);
      v32 = 8 * v31 + 600;
      v33 = 1 << (((a2 >> (38 - (unsigned __int8)v30)) & 1) + 2 * (31 - v30));
    }
  }
  else
  {
    v33 = 1;
    v32 = 600i64;
    v31 = 0i64;
  }
  v34 = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(v5 + 56) = v29;
  *(_QWORD *)(v5 + 40) = 0i64;
  *(_QWORD *)(v5 + 32) = 0i64;
  if ( (v34 & v33) != 0 )
  {
    v40 = *(_QWORD *)(v4 + 8 * v31 + 600);
    v41 = a2;
    if ( v29 != 31 )
      v41 = a2 << (57 - (unsigned __int8)(v29 >> 1));
    while ( (*(_QWORD *)(v40 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != a2 )
    {
      v42 = v41;
      v41 *= 2i64;
      result = (v42 >> 63) + 4;
      if ( !*(_QWORD *)(v40 + 8 * result) )
      {
        if ( v9 <= v40 + 8 * result )
        {
          *(_QWORD *)(v40 + 8 * result) = v5;
          *(_QWORD *)(v5 + 48) = v40;
          *(_QWORD *)(v5 + 24) = v5;
          *(_QWORD *)(v5 + 16) = v5;
          return result;
        }
LABEL_127:
        sub_401114();
      }
      v40 = *(_QWORD *)(v40 + 8 * result);
    }
    result = *(_QWORD *)(v40 + 16);
    if ( v9 <= v40 && v9 <= result )
    {
      *(_QWORD *)(result + 24) = v5;
      *(_QWORD *)(v40 + 16) = v5;
      *(_QWORD *)(v5 + 16) = result;
      *(_QWORD *)(v5 + 24) = v40;
      *(_QWORD *)(v5 + 48) = 0i64;
      return result;
    }
    goto LABEL_127;
  }
  result = v34 | (unsigned int)v33;
  *(_DWORD *)(v4 + 4) = result;
  *(_QWORD *)(v4 + 8 * v31 + 600) = v5;
  *(_QWORD *)(v5 + 48) = v32 + v4;
  *(_QWORD *)(v5 + 24) = v5;
  *(_QWORD *)(v5 + 16) = v5;
  return result;
}
// 40BEA7: variable 'v2' is possibly undefined
// 40BEAA: variable 'v3' is possibly undefined

//----- (000000000040C5F0) ----------------------------------------------------
__int64 __fastcall sub_40C5F0()
{
  unsigned __int64 v0; // rdi
  int v1; // edx
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rbx
  int v4; // eax
  int v5; // ecx
  __int64 v6; // r8
  __int64 v7; // rax
  unsigned __int64 v8; // rdi
  __int64 result; // rax
  unsigned __int64 v10; // rsi
  int v11; // eax
  __int64 v14; // r11
  __int64 v15; // r9
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdi
  __int64 *v18; // rdx
  __int64 v19; // rdi
  unsigned __int64 v20; // rcx
  __int64 v21; // rbx
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // r8
  int v25; // ecx
  unsigned __int64 v26; // rcx
  int v27; // er9
  __int64 v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rdx
  __int64 v31; // r12
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // r13
  unsigned __int64 v34; // rcx
  unsigned __int64 v35; // rdx
  unsigned __int64 v36; // r13
  int v37; // er9
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r8
  unsigned __int64 v42; // rdi
  unsigned __int64 v43; // r12
  unsigned __int64 v44; // r11
  unsigned __int64 v45; // r13
  _QWORD *v46; // rdi
  unsigned __int64 v47; // r14
  unsigned __int64 v48; // rcx
  __int64 v49; // rcx
  unsigned __int64 v50; // rcx
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // rsi
  __int64 v53; // rdi
  unsigned __int64 v54; // rdx
  unsigned __int64 v55; // r12
  __int64 v56; // rdx
  __int64 v57; // rdi
  unsigned __int64 v58; // rsi
  unsigned __int64 *v59; // rdx
  unsigned int v60; // er9
  __int64 v61; // r8
  unsigned __int64 v62; // rdx
  unsigned __int64 v63; // r10
  unsigned __int64 v64; // rsi
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rsi
  __int64 v67; // rdx
  unsigned __int64 v68; // rdx
  __m128i v69; // xmm0
  __int64 v70; // rcx
  __m128i v71; // xmm1
  _QWORD *v72; // rax
  unsigned __int64 v73; // rsi
  unsigned __int64 v74; // rcx
  unsigned __int64 v75; // rax
  unsigned __int64 v76; // r12
  unsigned __int64 v77; // rdx
  unsigned __int64 *v78; // rcx
  unsigned __int64 v79; // rax
  unsigned __int64 v80; // r10
  unsigned __int64 v81; // r11
  unsigned __int64 v82; // r8
  __int64 v83; // rcx
  unsigned __int64 v84; // r12
  __int64 v85; // rdx
  unsigned __int64 v86; // rdi
  __int64 v87; // rdi
  unsigned __int64 v88; // rdx
  __int64 v89; // r8
  unsigned __int64 v90; // r11
  __int64 v91; // r10
  _QWORD *v92; // rcx
  unsigned __int64 v93; // r12
  unsigned __int64 v94; // rdx
  __int64 v95; // rdx
  unsigned __int64 v96; // rdx
  unsigned __int64 v97; // rdx
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // rdx
  char v100; // cl
  unsigned __int64 v101; // rdx
  __int64 v102; // rax
  __int64 v103; // rcx
  __int64 v104; // rax
  _QWORD *v105; // rdx
  unsigned __int64 v106; // rax
  unsigned int v107; // ecx
  __int64 v108; // r9
  __int64 v109; // r8
  int v110; // edx
  int v111; // eax
  int v112; // eax
  int v113; // eax
  unsigned __int64 v116; // rdx
  unsigned int v117; // ecx
  __int64 v118; // r8
  __int64 v119; // r9
  int v120; // esi
  int v121; // edx
  unsigned __int64 v122; // rsi
  unsigned __int64 v123; // r8
  unsigned __int64 v124; // rdx
  __int64 v125; // rdx
  unsigned __int64 v126; // rdx
  unsigned __int64 v127; // rdx
  unsigned __int64 v128; // r8
  unsigned __int64 v129; // rax
  __int64 v130; // rax
  unsigned __int64 v131; // rax
  _QWORD *v132; // rdx
  _QWORD *v133; // rsi
  _QWORD *v134; // r8
  _QWORD *v135; // rcx
  _QWORD *v136; // r9
  _QWORD *v137; // r10
  _QWORD *v138; // rdi
  unsigned __int64 v139; // rbx
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r10
  __int64 v142; // r11
  unsigned __int64 v143; // rsi
  __int64 v144; // rdi
  int v145; // esi
  __int64 v146; // rdx
  __int64 v147; // r8
  __int64 v148; // r10
  unsigned __int64 v149; // rsi
  unsigned __int64 v150; // rdi
  unsigned __int64 v151; // rcx
  __int64 v152; // rcx
  unsigned __int64 v153; // rdx
  unsigned __int64 v154; // r11
  unsigned __int64 v155; // rcx
  __int64 v156; // r10
  unsigned __int64 v157; // r10
  unsigned __int64 v158; // rcx
  unsigned __int64 v159; // rcx
  _QWORD *v160; // r10
  _QWORD *v161; // rcx
  _QWORD *v162; // r12

  if ( v0 > 0xE0 )
  {
    v10 = qword_446708[0];
    if ( v0 > 0xFFFFFFFFFFFFFF7Fui64 )
    {
      if ( qword_446708[0] != -1 )
      {
        v28 = qword_446710;
        v30 = qword_4466D0;
        v3 = -1i64;
        if ( (dword_446A70 & 1) == 0 )
          return 0i64;
LABEL_30:
        v31 = -v30;
        if ( v3 >= qword_4466D8 && v28 )
        {
          v32 = qword_446A68;
          v33 = v31 & (v3 + v30 + 62);
          if ( qword_446A68 )
          {
            v34 = qword_446A58;
            if ( qword_446A68 < v33 + qword_446A58 || qword_446A58 >= v33 + qword_446A58 )
            {
              v55 = (v3 + v30 + 95) & v31;
              if ( v55 <= v3 )
                return 0i64;
LABEL_78:
              if ( v55 + v34 > v34 && v32 >= v55 + v34 )
              {
LABEL_80:
                v16 = sub_40F340();
                v56 = v55 + qword_446A58;
                qword_446A58 += v55;
                if ( qword_446A58 > (unsigned __int64)qword_446A60 )
                  qword_446A60 = v56;
                v57 = qword_446728;
                if ( !qword_446728 )
                {
                  if ( !qword_446718 || v16 < qword_446718 )
                    qword_446718 = v16;
                  *(_QWORD *)&xmmword_446A78 = v16;
                  *((_QWORD *)&xmmword_446A78 + 1) = v55;
                  DWORD2(xmmword_446A88) = 1;
                  qword_446738 = 128i64;
                  qword_446740 = qword_4466C0;
                  v105 = &unk_446748;
                  do
                  {
                    v105[3] = v105;
                    v105[2] = v105;
                    v105 += 2;
                  }
                  while ( &unk_446948 != (_UNKNOWN *)v105 );
                  v76 = v55 - 80;
                  qword_446728 = v16;
                  qword_446710 = v76;
                  *(_QWORD *)(v16 + 8) = v76 | 1;
                  *(_QWORD *)(v16 + v76 + 8) = 80i64;
                  qword_446730 = qword_4466E0;
                  goto LABEL_177;
                }
                v58 = xmmword_446A78;
                if ( v16 == (_QWORD)xmmword_446A78 + *((_QWORD *)&xmmword_446A78 + 1)
                  && (BYTE8(xmmword_446A88) & 8) == 0
                  && (BYTE8(xmmword_446A88) & 1) != 0
                  && qword_446728 >= (unsigned __int64)xmmword_446A78
                  && v16 > qword_446728 )
                {
                  *((_QWORD *)&xmmword_446A78 + 1) += v55;
                  v101 = v55 + qword_446710;
                  if ( (qword_446728 & 0xF) != 0 )
                  {
                    v102 = -((_DWORD)qword_446728 + 16) & 0xF;
                    v103 = qword_446728 + v102;
                    v76 = v101 - v102;
                  }
                  else
                  {
                    v76 = v55 + qword_446710;
                    v103 = qword_446728;
                  }
                  qword_446728 = v103;
                  qword_446710 = v76;
                  *(_QWORD *)(v103 + 8) = v76 | 1;
                  v104 = qword_4466E0;
                  *(_QWORD *)(v57 + v101 + 8) = 80i64;
                  qword_446730 = v104;
LABEL_177:
                  if ( v3 >= v76 )
                  {
                    sub_402B8A();
                    return 0i64;
                  }
                  else
                  {
                    qword_446710 = v76 - v3;
                    result = qword_446728 + 16;
                    qword_446728 += v3;
                    *(_QWORD *)(qword_446728 + 8) = (v76 - v3) | 1;
                    *(_QWORD *)(result - 8) = v3 | 3;
                  }
                  return result;
                }
                if ( v16 < qword_446718 )
                  qword_446718 = v16;
                v59 = (unsigned __int64 *)&xmmword_446A78;
                if ( (_QWORD)xmmword_446A78 != v16 + v55
                  || (LOBYTE(v60) = BYTE8(xmmword_446A88) & 8, (BYTE8(xmmword_446A88) & 8) != 0)
                  || (BYTE8(xmmword_446A88) & 1) == 0 )
                {
                  while ( 1 )
                  {
                    if ( qword_446728 >= v58 )
                    {
                      v66 = v59[1] + v58;
                      if ( qword_446728 < v66 )
                        break;
                    }
                    v59 = (unsigned __int64 *)v59[2];
                    if ( !v59 )
                      JUMPOUT(0x402A1Fi64);
                    v58 = *v59;
                  }
                  v67 = -95i64;
                  if ( (((_BYTE)v66 - 79) & 0xF) != 0 )
                    v67 = ((79 - (_DWORD)v66) & 0xF) - 95i64;
                  v68 = v66 + v67;
                  v69 = _mm_loadu_si128((const __m128i *)&xmmword_446A78);
                  qword_446728 = v16;
                  if ( v68 < v57 + 32 )
                    v68 = v57;
                  qword_446710 = v55 - 80;
                  v70 = qword_4466E0;
                  *(_QWORD *)(v16 + 8) = (v55 - 80) | 1;
                  qword_446730 = v70;
                  *(_QWORD *)(v16 + v55 - 72) = 80i64;
                  *(__m128i *)(v68 + 16) = v69;
                  v71 = _mm_loadu_si128((const __m128i *)&xmmword_446A88);
                  *(_QWORD *)(v68 + 8) = 51i64;
                  *(__m128i *)(v68 + 32) = v71;
                  *((_QWORD *)&xmmword_446A78 + 1) = v55;
                  DWORD2(xmmword_446A88) = 1;
                  *(_QWORD *)&xmmword_446A78 = v16;
                  *(_QWORD *)&xmmword_446A88 = v68 + 16;
                  v72 = (_QWORD *)(v68 + 56);
                  do
                    *v72++ = 11i64;
                  while ( v66 > (unsigned __int64)v72 );
                  if ( v57 == v68 )
                  {
                    v76 = qword_446710;
                  }
                  else
                  {
                    *(_QWORD *)(v68 + 8) &= ~1ui64;
                    v73 = v68 - v57;
                    v74 = (v68 - v57) >> 3;
                    *(_QWORD *)(v57 + 8) = (v68 - v57) | 1;
                    *(_QWORD *)v68 = v68 - v57;
                    if ( v68 - v57 > 0xFF )
                    {
                      v106 = v73 >> 8;
                      v107 = v73 >> 8;
                      if ( v107 )
                      {
                        if ( (unsigned int)v106 > 0xFFFF )
                        {
                          v110 = 0x80000000;
                          v109 = 848i64;
                          v107 = 31;
                          v108 = 31i64;
                        }
                        else
                        {
                          _BitScanReverse((unsigned int *)&v106, v106);
                          v108 = ((v73 >> (38 - ((unsigned __int8)v106 ^ 0x1Fu))) & 1)
                               + 2 * (31 - ((unsigned int)v106 ^ 0x1F));
                          v107 = ((v73 >> (38 - ((unsigned __int8)v106 ^ 0x1Fu))) & 1) + 2 * (31 - (v106 ^ 0x1F));
                          v109 = 8 * v108 + 600;
                          v110 = 1 << (((v73 >> (38 - ((unsigned __int8)v106 ^ 0x1Fu))) & 1) + 2 * (31 - (v106 ^ 0x1F)));
                        }
                      }
                      else
                      {
                        v110 = 1;
                        v109 = 600i64;
                        v108 = (unsigned int)v106;
                      }
                      v111 = HIDWORD(qword_446700[0]);
                      *(_DWORD *)(v57 + 56) = v107;
                      *(_QWORD *)(v57 + 40) = 0i64;
                      *(_QWORD *)(v57 + 32) = 0i64;
                      if ( (v110 & v111) != 0 )
                      {
                        v127 = qword_446958[v108];
                        v128 = v73;
                        if ( v107 != 31 )
                          v128 = v73 << (57 - (unsigned __int8)(v107 >> 1));
                        while ( v73 != (*(_QWORD *)(v127 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
                        {
                          v129 = v128;
                          v128 *= 2i64;
                          v130 = (v129 >> 63) + 4;
                          if ( !*(_QWORD *)(v127 + 8 * v130) )
                          {
                            if ( qword_446718 > v127 + 8 * v130 )
                              goto LABEL_329;
                            *(_QWORD *)(v127 + 8 * v130) = v57;
                            v76 = qword_446710;
                            *(_QWORD *)(v57 + 48) = v127;
                            *(_QWORD *)(v57 + 24) = v57;
                            *(_QWORD *)(v57 + 16) = v57;
                            goto LABEL_177;
                          }
                          v127 = *(_QWORD *)(v127 + 8 * v130);
                        }
                        v131 = *(_QWORD *)(v127 + 16);
                        if ( v131 < qword_446718 || v127 < qword_446718 )
                          goto LABEL_329;
                        *(_QWORD *)(v131 + 24) = v57;
                        v76 = qword_446710;
                        *(_QWORD *)(v127 + 16) = v57;
                        *(_QWORD *)(v57 + 16) = v131;
                        *(_QWORD *)(v57 + 24) = v127;
                        *(_QWORD *)(v57 + 48) = 0i64;
                      }
                      else
                      {
                        qword_446958[v108] = v57;
                        v76 = qword_446710;
                        HIDWORD(qword_446700[0]) = v110 | v111;
                        *(_QWORD *)(v57 + 48) = v109 + 4482816;
                        *(_QWORD *)(v57 + 24) = v57;
                        *(_QWORD *)(v57 + 16) = v57;
                      }
                    }
                    else
                    {
                      if ( ((1 << v74) & qword_446700[0]) != 0 )
                      {
                        v75 = qword_446758[(unsigned int)(2 * v74)];
                        if ( v75 < qword_446718 )
                          goto LABEL_329;
                      }
                      else
                      {
                        LODWORD(qword_446700[0]) |= 1 << v74;
                        v75 = 8i64 * (unsigned int)(2 * v74) + 4482888;
                      }
                      qword_446758[(unsigned int)(2 * v74)] = v57;
                      v76 = qword_446710;
                      *(_QWORD *)(v75 + 24) = v57;
                      *(_QWORD *)(v57 + 16) = v75;
                      *(_QWORD *)(v57 + 24) = 8i64 * (unsigned int)(2 * v74) + 4482888;
                    }
                  }
                  goto LABEL_177;
                }
                *(_QWORD *)&xmmword_446A78 = v16;
                *((_QWORD *)&xmmword_446A78 + 1) += v55;
                if ( (v58 & 0xF) != 0 )
                  v58 += -((_DWORD)v58 + 16) & 0xF;
                v61 = v16 + v3;
                v62 = v58 - v16 - v3;
                *(_QWORD *)(v16 + 8) = v3 | 3;
                if ( v57 == v58 )
                {
                  qword_446728 = v16 + v3;
                  qword_446710 += v62;
                  *(_QWORD *)(v61 + 8) = qword_446710 | 1;
                  return v16 + 16;
                }
                if ( qword_446720 == v58 )
                {
                  v146 = qword_446708[0] + v62;
                  qword_446720 = v16 + v3;
                  qword_446708[0] = v146;
                  *(_QWORD *)(v61 + 8) = v146 | 1;
                  *(_QWORD *)(v61 + v146) = v146;
                  return v16 + 16;
                }
                v63 = *(_QWORD *)(v58 + 8);
                if ( (v63 & 3) != 1 )
                {
                  *(_QWORD *)(v58 + 8) = v63 & 0xFFFFFFFFFFFFFFFEui64;
                  *(_QWORD *)(v61 + 8) = v62 | 1;
                  *(_QWORD *)v58 = v62;
                  v64 = v62 >> 3;
                  if ( v62 <= 0xFF )
                    goto LABEL_95;
LABEL_268:
                  v143 = v62 >> 8;
                  v144 = (unsigned int)(v62 >> 8);
                  if ( (unsigned int)(v62 >> 8) )
                  {
                    v144 = 31i64;
                    if ( (unsigned int)v143 <= 0xFFFF )
                    {
                      _BitScanReverse((unsigned int *)&v143, v143);
                      v144 = ((v62 >> (38 - ((unsigned __int8)v143 ^ 0x1Fu))) & 1)
                           + 2 * (31 - ((unsigned int)v143 ^ 0x1F));
                    }
                  }
                  v145 = HIDWORD(qword_446700[0]);
                  *(_DWORD *)(v61 + 56) = v144;
                  *(_QWORD *)(v61 + 40) = 0i64;
                  *(_QWORD *)(v61 + 32) = 0i64;
                  if ( ((1 << v144) & v145) == 0 )
                  {
                    qword_446958[v144] = v61;
                    HIDWORD(qword_446700[0]) = (1 << v144) | v145;
                    *(_QWORD *)(v61 + 48) = 8 * v144 + 4483416;
                    *(_QWORD *)(v61 + 24) = v61;
                    *(_QWORD *)(v61 + 16) = v61;
                    return v16 + 16;
                  }
                  v149 = qword_446958[(unsigned int)v144];
                  if ( (_DWORD)v144 != 31 )
                    v60 = 57 - ((unsigned int)v144 >> 1);
                  v150 = v62 << v60;
                  while ( 1 )
                  {
                    if ( v62 == (*(_QWORD *)(v149 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
                    {
                      v153 = *(_QWORD *)(v149 + 16);
                      if ( v153 >= qword_446718 && v149 >= qword_446718 )
                      {
                        *(_QWORD *)(v153 + 24) = v61;
                        *(_QWORD *)(v149 + 16) = v61;
                        *(_QWORD *)(v61 + 16) = v153;
                        *(_QWORD *)(v61 + 24) = v149;
                        *(_QWORD *)(v61 + 48) = 0i64;
                        return v16 + 16;
                      }
                      goto LABEL_329;
                    }
                    v151 = v150;
                    v150 *= 2i64;
                    v152 = (v151 >> 63) + 4;
                    if ( !*(_QWORD *)(v149 + 8 * v152) )
                      break;
                    v149 = *(_QWORD *)(v149 + 8 * v152);
                  }
                  if ( qword_446718 <= v149 + 8 * v152 )
                  {
                    *(_QWORD *)(v149 + 8 * v152) = v61;
                    *(_QWORD *)(v61 + 48) = v149;
                    *(_QWORD *)(v61 + 24) = v61;
                    *(_QWORD *)(v61 + 16) = v61;
                    return v16 + 16;
                  }
                  goto LABEL_329;
                }
                v138 = *(_QWORD **)(v58 + 24);
                v139 = v63 & 0xFFFFFFFFFFFFFFF8ui64;
                v140 = v63 >> 3;
                if ( v63 <= 0xFF )
                {
                  v141 = *(_QWORD *)(v58 + 16);
                  v142 = 8i64 * (unsigned int)(2 * v140) + 4482888;
                  if ( v141 != v142 && (v141 < qword_446718 || *(_QWORD *)(v141 + 24) != v58) )
                    goto LABEL_329;
                  if ( (_QWORD *)v141 == v138 )
                  {
                    LODWORD(qword_446700[0]) &= __ROL4__(-2, v140);
                  }
                  else
                  {
                    if ( (_QWORD *)v142 != v138 && (qword_446718 > (unsigned __int64)v138 || v138[2] != v58) )
                      goto LABEL_329;
                    *(_QWORD *)(v141 + 24) = v138;
                    v138[2] = v141;
                  }
                  goto LABEL_267;
                }
                v154 = *(_QWORD *)(v58 + 48);
                if ( v138 != (_QWORD *)v58 )
                {
                  v155 = *(_QWORD *)(v58 + 16);
                  if ( v155 < qword_446718 || *(_QWORD *)(v155 + 24) != v58 || v138[2] != v58 )
                    goto LABEL_329;
                  *(_QWORD *)(v155 + 24) = v138;
                  v138[2] = v155;
                  goto LABEL_296;
                }
                v138 = *(_QWORD **)(v58 + 40);
                if ( v138 )
                {
                  v160 = (_QWORD *)(v58 + 40);
                }
                else
                {
                  v138 = *(_QWORD **)(v58 + 32);
                  if ( !v138 )
                  {
LABEL_296:
                    if ( !v154 )
                      goto LABEL_267;
                    v156 = *(unsigned int *)(v58 + 56);
                    if ( qword_446958[v156] == v58 )
                    {
                      qword_446708[v156 + 74] = (__int64)v138;
                      if ( !v138 )
                      {
                        HIDWORD(qword_446700[0]) &= __ROL4__(-2, v156);
                        goto LABEL_267;
                      }
                    }
                    else
                    {
                      if ( v154 < qword_446718 )
                        goto LABEL_329;
                      if ( *(_QWORD *)(v154 + 32) == v58 )
                        *(_QWORD *)(v154 + 32) = v138;
                      else
                        *(_QWORD *)(v154 + 40) = v138;
                      if ( !v138 )
                        goto LABEL_267;
                    }
                    v157 = qword_446718;
                    if ( (unsigned __int64)v138 < qword_446718 )
                      goto LABEL_329;
                    v158 = *(_QWORD *)(v58 + 32);
                    v138[6] = v154;
                    if ( v158 )
                    {
                      if ( v157 > v158 )
                        goto LABEL_329;
                      v138[4] = v158;
                      *(_QWORD *)(v158 + 48) = v138;
                    }
                    v159 = *(_QWORD *)(v58 + 40);
                    if ( v159 )
                    {
                      if ( v157 > v159 )
                        goto LABEL_329;
                      v138[5] = v159;
                      *(_QWORD *)(v159 + 48) = v138;
                    }
LABEL_267:
                    v62 += v139;
                    *(_QWORD *)(v58 + v139 + 8) &= ~1ui64;
                    v64 = v62 >> 3;
                    *(_QWORD *)(v61 + 8) = v62 | 1;
                    *(_QWORD *)(v61 + v62) = v62;
                    if ( v62 <= 0xFF )
                    {
LABEL_95:
                      if ( ((1 << v64) & qword_446700[0]) != 0 )
                      {
                        v65 = qword_446758[(unsigned int)(2 * v64)];
                        if ( v65 < qword_446718 )
                          goto LABEL_329;
                      }
                      else
                      {
                        v65 = 8i64 * (unsigned int)(2 * v64) + 4482888;
                        LODWORD(qword_446700[0]) |= 1 << v64;
                      }
                      qword_446758[(unsigned int)(2 * v64)] = v61;
                      *(_QWORD *)(v65 + 24) = v61;
                      *(_QWORD *)(v61 + 16) = v65;
                      *(_QWORD *)(v61 + 24) = 8i64 * (unsigned int)(2 * v64) + 4482888;
                      return v16 + 16;
                    }
                    goto LABEL_268;
                  }
                  v160 = (_QWORD *)(v58 + 32);
                }
                v161 = v138;
                do
                {
                  do
                  {
                    v162 = v160;
                    v138 = v161;
                    v160 = v161 + 5;
                    v161 = (_QWORD *)v161[5];
                  }
                  while ( v161 );
                  v161 = (_QWORD *)v138[4];
                  v160 = v138 + 4;
                }
                while ( v161 );
                if ( qword_446718 > (unsigned __int64)v162 )
                  goto LABEL_329;
                *v162 = 0i64;
                goto LABEL_296;
              }
              return 0i64;
            }
          }
          if ( v3 < v33 )
          {
            v16 = sub_40F340();
            *(_QWORD *)(v16 + 8) = v33 - 32;
            v35 = qword_446718;
            *(_QWORD *)v16 = 0i64;
            *(_QWORD *)(v16 + v33 - 24) = 11i64;
            *(_QWORD *)(v16 + v33 - 16) = 0i64;
            if ( !v35 || v16 < v35 )
              qword_446718 = v16;
            v36 = qword_446A58 + v33;
            qword_446A58 = v36;
            if ( v36 > qword_446A60 )
              qword_446A60 = v36;
            return v16 + 16;
          }
        }
LABEL_75:
        v55 = (v3 + v30 + 95) & v31;
        if ( v3 >= v55 )
          return 0i64;
        v32 = qword_446A68;
        if ( !qword_446A68 )
          goto LABEL_80;
        v34 = qword_446A58;
        goto LABEL_78;
      }
      v16 = qword_446720;
      v78 = (unsigned __int64 *)(qword_446720 - 1);
LABEL_117:
      qword_446708[0] = 0i64;
      qword_446720 = 0i64;
      *(_QWORD *)(v16 + 8) = v10;
      v78[1] |= 1ui64;
      return v16 + 16;
    }
    v27 = HIDWORD(qword_446700[0]);
    v3 = (v0 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
    if ( !HIDWORD(qword_446700[0]) )
      goto LABEL_25;
    v79 = v3 >> 8;
    v80 = -(__int64)v3;
    LODWORD(v81) = v3 >> 8;
    if ( (_DWORD)v81 )
    {
      if ( (unsigned int)v79 > 0xFFFF )
      {
        v16 = qword_446A50;
        v82 = (v0 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
        LOBYTE(v81) = 31;
        if ( !qword_446A50 )
          goto LABEL_25;
        goto LABEL_121;
      }
      _BitScanReverse((unsigned int *)&v79, v79);
      v81 = ((v3 >> (38 - ((unsigned __int8)v79 ^ 0x1Fu))) & 1) + 2 * (31 - ((unsigned int)v79 ^ 0x1F));
      v16 = qword_446958[v81];
      if ( !v16 )
      {
LABEL_196:
        v112 = -2 << v81;
        goto LABEL_197;
      }
      v82 = (v0 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
      if ( (_DWORD)v81 == 31 )
      {
LABEL_121:
        v83 = 0i64;
        v84 = 0i64;
        while ( 1 )
        {
          v85 = *(_QWORD *)(v16 + 8);
          v86 = (v85 & 0xFFFFFFFFFFFFFFF8ui64) - v3;
          if ( v86 < v80 )
          {
            if ( !v86 )
            {
              v83 = v16;
              goto LABEL_134;
            }
            v80 = (*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v3;
            v84 = v16;
          }
          v87 = *(_QWORD *)(v16 + 40);
          v16 = *(_QWORD *)(v16 + 8 * ((v82 >> 63) + 4));
          if ( v87 && v87 != v16 )
            v83 = v87;
          if ( !v16 )
            break;
          v82 *= 2i64;
        }
        if ( v83 | v84 )
        {
          if ( !v83 )
          {
            v16 = v84;
            v86 = v80;
            goto LABEL_138;
          }
          v85 = *(_QWORD *)(v83 + 8);
          v16 = v84;
          v86 = v80;
          while ( 1 )
          {
LABEL_134:
            v88 = (v85 & 0xFFFFFFFFFFFFFFF8ui64) - v3;
            if ( v86 > v88 )
            {
              v86 = v88;
              v16 = v83;
            }
            v89 = *(_QWORD *)(v83 + 32);
            if ( !v89 )
            {
              v89 = *(_QWORD *)(v83 + 40);
              if ( !v89 )
                break;
            }
            v85 = *(_QWORD *)(v89 + 8);
            v83 = v89;
          }
LABEL_138:
          if ( v16 && qword_446708[0] - v3 > v86 )
          {
            v90 = qword_446718;
            if ( v16 < qword_446718 )
              goto LABEL_329;
            v91 = v16 + v3;
            v45 = v3 + v86;
            if ( v16 >= v16 + v3 )
              goto LABEL_329;
            v92 = *(_QWORD **)(v16 + 24);
            v93 = *(_QWORD *)(v16 + 48);
            if ( (_QWORD *)v16 == v92 )
            {
              v132 = *(_QWORD **)(v16 + 40);
              v133 = (_QWORD *)(v16 + 40);
              if ( !v132 )
              {
                v132 = *(_QWORD **)(v16 + 32);
                if ( !v132 )
                {
                  if ( !v93 )
                    goto LABEL_160;
                  v147 = *(unsigned int *)(v16 + 56);
                  v92 = 0i64;
                  if ( qword_446958[v147] == v16 )
                  {
                    qword_446708[v147 + 74] = 0i64;
                    HIDWORD(qword_446700[0]) = v27 & ~(1 << v147);
                    goto LABEL_160;
                  }
                  goto LABEL_149;
                }
                v133 = (_QWORD *)(v16 + 32);
              }
              do
              {
                do
                {
                  v134 = v133;
                  v92 = v132;
                  v133 = v132 + 5;
                  v132 = (_QWORD *)v132[5];
                }
                while ( v132 );
                v132 = (_QWORD *)v92[4];
                v133 = v92 + 4;
              }
              while ( v132 );
              if ( qword_446718 > (unsigned __int64)v134 )
                goto LABEL_329;
              *v134 = 0i64;
            }
            else
            {
              v94 = *(_QWORD *)(v16 + 16);
              if ( qword_446718 > v94 || v16 != *(_QWORD *)(v94 + 24) || v16 != v92[2] )
                goto LABEL_329;
              *(_QWORD *)(v94 + 24) = v92;
              v92[2] = v94;
            }
            if ( !v93 )
              goto LABEL_160;
            v95 = *(unsigned int *)(v16 + 56);
            if ( v16 == qword_446958[v95] )
            {
              qword_446708[v95 + 74] = (__int64)v92;
              goto LABEL_153;
            }
LABEL_149:
            if ( v90 > v93 )
              goto LABEL_329;
            if ( v16 == *(_QWORD *)(v93 + 32) )
              *(_QWORD *)(v93 + 32) = v92;
            else
              *(_QWORD *)(v93 + 40) = v92;
            if ( v92 )
            {
LABEL_153:
              if ( v90 > (unsigned __int64)v92 )
                goto LABEL_329;
              v96 = *(_QWORD *)(v16 + 32);
              v92[6] = v93;
              if ( v96 )
              {
                if ( v90 > v96 )
                  goto LABEL_329;
                v92[4] = v96;
                *(_QWORD *)(v96 + 48) = v92;
              }
              v97 = *(_QWORD *)(v16 + 40);
              if ( v97 )
              {
                if ( v90 > v97 )
                  goto LABEL_329;
                v92[5] = v97;
                *(_QWORD *)(v97 + 48) = v92;
              }
            }
LABEL_160:
            if ( v86 <= 0x1F )
              goto LABEL_194;
            *(_QWORD *)(v16 + 8) = v3 | 3;
            v98 = v86 >> 3;
            *(_QWORD *)(v91 + 8) = v86 | 1;
            *(_QWORD *)(v91 + v86) = v86;
            if ( v86 <= 0xFF )
            {
              if ( ((1 << v98) & qword_446700[0]) != 0 )
              {
                v99 = qword_446758[(unsigned int)(2 * v98)];
                if ( v90 > v99 )
                  goto LABEL_329;
              }
              else
              {
                LODWORD(qword_446700[0]) |= 1 << v98;
                v99 = 8i64 * (unsigned int)(2 * v98) + 4482888;
              }
              qword_446758[(unsigned int)(2 * v98)] = v91;
              *(_QWORD *)(v99 + 24) = v91;
              *(_QWORD *)(v91 + 16) = v99;
              *(_QWORD *)(v91 + 24) = 8i64 * (unsigned int)(2 * v98) + 4482888;
              return v16 + 16;
            }
            v116 = v86 >> 8;
            v117 = v86 >> 8;
            if ( v117 )
            {
              if ( (unsigned int)v116 > 0xFFFF )
              {
                v120 = 0x80000000;
                v119 = 848i64;
                v117 = 31;
                v118 = 31i64;
              }
              else
              {
                _BitScanReverse((unsigned int *)&v116, v116);
                v118 = ((v86 >> (38 - ((unsigned __int8)v116 ^ 0x1Fu))) & 1) + 2 * (31 - ((unsigned int)v116 ^ 0x1F));
                v117 = ((v86 >> (38 - ((unsigned __int8)v116 ^ 0x1Fu))) & 1) + 2 * (31 - (v116 ^ 0x1F));
                v119 = 8 * v118 + 600;
                v120 = 1 << (((v86 >> (38 - ((unsigned __int8)v116 ^ 0x1Fu))) & 1) + 2 * (31 - (v116 ^ 0x1F)));
              }
            }
            else
            {
              v120 = 1;
              v119 = 600i64;
              v118 = (unsigned int)v116;
            }
            v121 = HIDWORD(qword_446700[0]);
            *(_DWORD *)(v91 + 56) = v117;
            *(_QWORD *)(v91 + 40) = 0i64;
            *(_QWORD *)(v91 + 32) = 0i64;
            if ( (v120 & v121) == 0 )
            {
              qword_446958[v118] = v91;
              HIDWORD(qword_446700[0]) = v120 | v121;
              *(_QWORD *)(v91 + 48) = v119 + 4482816;
              *(_QWORD *)(v91 + 24) = v91;
              *(_QWORD *)(v91 + 16) = v91;
              return v16 + 16;
            }
            v122 = qword_446958[v118];
            v123 = v86;
            if ( v117 != 31 )
              v123 = v86 << (57 - (unsigned __int8)(v117 >> 1));
            while ( 1 )
            {
              if ( v86 == (*(_QWORD *)(v122 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
              {
                v126 = *(_QWORD *)(v122 + 16);
                if ( v90 <= v122 && v90 <= v126 )
                {
                  *(_QWORD *)(v126 + 24) = v91;
                  *(_QWORD *)(v122 + 16) = v91;
                  *(_QWORD *)(v91 + 16) = v126;
                  *(_QWORD *)(v91 + 24) = v122;
                  *(_QWORD *)(v91 + 48) = 0i64;
                  return v16 + 16;
                }
                goto LABEL_329;
              }
              v124 = v123;
              v123 *= 2i64;
              v125 = (v124 >> 63) + 4;
              if ( !*(_QWORD *)(v122 + 8 * v125) )
                break;
              v122 = *(_QWORD *)(v122 + 8 * v125);
            }
            if ( v90 <= v122 + 8 * v125 )
            {
              *(_QWORD *)(v122 + 8 * v125) = v91;
              *(_QWORD *)(v91 + 48) = v122;
              *(_QWORD *)(v91 + 24) = v91;
              *(_QWORD *)(v91 + 16) = v91;
              return v16 + 16;
            }
LABEL_329:
            sub_401114();
          }
LABEL_25:
          if ( v3 > qword_446708[0] )
            goto LABEL_26;
LABEL_113:
          v16 = qword_446720;
          v77 = v10 - v3;
          v78 = (unsigned __int64 *)(qword_446720 + v10);
          if ( v10 - v3 > 0x1F )
          {
            qword_446708[0] = v10 - v3;
            qword_446720 += v3;
            *(_QWORD *)(qword_446720 + 8) = v77 | 1;
            *v78 = v77;
            *(_QWORD *)(v16 + 8) = v3 | 3;
            return v16 + 16;
          }
          v10 |= 3ui64;
          goto LABEL_117;
        }
        goto LABEL_196;
      }
      v100 = 57 - ((unsigned int)v81 >> 1);
    }
    else
    {
      v16 = qword_446958[0];
      v100 = 57;
      if ( !qword_446958[0] )
      {
        v112 = -2;
LABEL_197:
        v113 = HIDWORD(qword_446700[0]) & v112;
        if ( !v113 )
          goto LABEL_25;
        _EAX = -v113 & v113;
        __asm { tzcnt   eax, eax }
        v83 = qword_446958[_EAX];
        if ( !v83 )
          goto LABEL_25;
        v85 = *(_QWORD *)(v83 + 8);
        v86 = v80;
        v16 = 0i64;
        goto LABEL_134;
      }
    }
    v82 = v3 << v100;
    goto LABEL_121;
  }
  if ( v0 > 0xE )
  {
    v1 = qword_446700[0];
    v3 = (v0 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
    v2 = v3 >> 3;
    v4 = LODWORD(qword_446700[0]) >> (v3 >> 3);
    if ( (v4 & 3) != 0 )
      goto LABEL_4;
LABEL_10:
    v10 = qword_446708[0];
    if ( qword_446708[0] < v3 )
    {
      if ( v4 )
      {
        v11 = ((2 * (1 << v2)) | (-2 * (1 << v2))) & (v4 << v2);
        _EAX = -v11 & v11;
        __asm { tzcnt   ecx, eax }
        v14 = (unsigned int)(8 * _ECX);
        v15 = 8i64 * (unsigned int)(2 * _ECX) + 4482888;
        v16 = qword_446758[2 * _ECX];
        v17 = *(_QWORD *)(v16 + 16);
        if ( v15 == v17 )
        {
          LODWORD(qword_446700[0]) = ~(1 << _ECX) & v1;
        }
        else
        {
          if ( qword_446718 > v17 || *(_QWORD *)(v17 + 24) != v16 )
            goto LABEL_329;
          *(_QWORD *)(v17 + 24) = v15;
          qword_446758[2 * _ECX] = v17;
        }
        v18 = (__int64 *)(v16 + v14);
        v19 = v14 - v3;
        if ( v14 - v3 <= 0x1F )
        {
          *(_QWORD *)(v16 + 8) = (8 * _ECX) | 3u;
          v18[1] |= 1ui64;
          return v16 + 16;
        }
        v20 = v3;
        v21 = v16 + v3;
        *(_QWORD *)(v16 + 8) = v20 | 3;
        *(_QWORD *)(v21 + 8) = v19 | 1;
        *v18 = v19;
        v22 = v10 >> 3;
        if ( v10 )
        {
          v23 = qword_446720;
          v24 = 8i64 * (unsigned int)(2 * v22) + 4482888;
          v25 = 1 << v22;
          if ( (v25 & qword_446700[0]) != 0 )
          {
            v26 = *(_QWORD *)(v24 + 16);
            if ( v26 < qword_446718 )
              goto LABEL_329;
          }
          else
          {
            LODWORD(qword_446700[0]) |= v25;
            v26 = v24;
          }
          *(_QWORD *)(v24 + 16) = qword_446720;
          *(_QWORD *)(v26 + 24) = v23;
          *(_QWORD *)(v23 + 16) = v26;
          *(_QWORD *)(v23 + 24) = v24;
        }
        qword_446708[0] = v19;
        qword_446720 = v21;
        return v16 + 16;
      }
      v37 = HIDWORD(qword_446700[0]);
      if ( HIDWORD(qword_446700[0]) )
      {
        _EAX = HIDWORD(qword_446700[0]) & -HIDWORD(qword_446700[0]);
        __asm { tzcnt   eax, eax }
        v16 = qword_446958[_EAX];
        v40 = v16;
        v41 = (*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v3;
        while ( 1 )
        {
          v42 = *(_QWORD *)(v40 + 32);
          if ( !v42 )
          {
            v42 = *(_QWORD *)(v40 + 40);
            if ( !v42 )
              break;
          }
          if ( (*(_QWORD *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v3 < v41 )
          {
            v41 = (*(_QWORD *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v3;
            v16 = v42;
          }
          v40 = v42;
        }
        v43 = qword_446718;
        if ( qword_446718 > v16 )
          goto LABEL_329;
        v44 = v16 + v3;
        v45 = v3 + v41;
        if ( v16 + v3 <= v16 )
          goto LABEL_329;
        v46 = *(_QWORD **)(v16 + 24);
        v47 = *(_QWORD *)(v16 + 48);
        if ( v46 == (_QWORD *)v16 )
        {
          v135 = *(_QWORD **)(v16 + 40);
          if ( v135 )
          {
            v136 = (_QWORD *)(v16 + 40);
          }
          else
          {
            v135 = *(_QWORD **)(v16 + 32);
            if ( !v135 )
            {
              if ( !v47 )
                goto LABEL_68;
              v148 = *(unsigned int *)(v16 + 56);
              v46 = 0i64;
              if ( v16 == qword_446958[v148] )
              {
                qword_446708[v148 + 74] = 0i64;
                HIDWORD(qword_446700[0]) = v37 & ~(1 << v148);
                goto LABEL_68;
              }
              goto LABEL_57;
            }
            v136 = (_QWORD *)(v16 + 32);
          }
          do
          {
            do
            {
              v137 = v136;
              v46 = v135;
              v136 = v135 + 5;
              v135 = (_QWORD *)v135[5];
            }
            while ( v135 );
            v135 = (_QWORD *)v46[4];
            v136 = v46 + 4;
          }
          while ( v135 );
          if ( qword_446718 > (unsigned __int64)v137 )
            goto LABEL_329;
          *v137 = 0i64;
        }
        else
        {
          v48 = *(_QWORD *)(v16 + 16);
          if ( qword_446718 > v48 || *(_QWORD *)(v48 + 24) != v16 || v46[2] != v16 )
            goto LABEL_329;
          *(_QWORD *)(v48 + 24) = v46;
          v46[2] = v48;
        }
        if ( !v47 )
          goto LABEL_68;
        v49 = *(unsigned int *)(v16 + 56);
        if ( qword_446958[v49] == v16 )
        {
          qword_446708[v49 + 74] = (__int64)v46;
LABEL_61:
          if ( v43 > (unsigned __int64)v46 )
            goto LABEL_329;
          v50 = *(_QWORD *)(v16 + 32);
          v46[6] = v47;
          if ( v50 )
          {
            if ( v43 > v50 )
              goto LABEL_329;
            v46[4] = v50;
            *(_QWORD *)(v50 + 48) = v46;
          }
          v51 = *(_QWORD *)(v16 + 40);
          if ( v51 )
          {
            if ( v43 > v51 )
              goto LABEL_329;
            v46[5] = v51;
            *(_QWORD *)(v51 + 48) = v46;
          }
LABEL_68:
          if ( v41 > 0x1F )
          {
            *(_QWORD *)(v16 + 8) = v3 | 3;
            *(_QWORD *)(v44 + 8) = v41 | 1;
            *(_QWORD *)(v44 + v41) = v41;
            if ( v10 )
            {
              v52 = v10 >> 3;
              v53 = qword_446720;
              if ( ((1 << v52) & v1) != 0 )
              {
                v54 = qword_446758[(unsigned int)(2 * v52)];
                if ( v43 > v54 )
                  goto LABEL_329;
              }
              else
              {
                LODWORD(qword_446700[0]) = (1 << v52) | v1;
                v54 = 8i64 * (unsigned int)(2 * v52) + 4482888;
              }
              qword_446758[(unsigned int)(2 * v52)] = qword_446720;
              *(_QWORD *)(v54 + 24) = v53;
              *(_QWORD *)(v53 + 16) = v54;
              *(_QWORD *)(v53 + 24) = 8i64 * (unsigned int)(2 * v52) + 4482888;
            }
            qword_446708[0] = v41;
            qword_446720 = v16 + v3;
            return v16 + 16;
          }
LABEL_194:
          *(_QWORD *)(v16 + 8) = v45 | 3;
          *(_QWORD *)(v16 + v45 + 8) |= 1ui64;
          return v16 + 16;
        }
LABEL_57:
        if ( v43 > v47 )
          goto LABEL_329;
        if ( *(_QWORD *)(v47 + 32) == v16 )
          *(_QWORD *)(v47 + 32) = v46;
        else
          *(_QWORD *)(v47 + 40) = v46;
        if ( !v46 )
          goto LABEL_68;
        goto LABEL_61;
      }
LABEL_26:
      v28 = qword_446710;
      if ( qword_446710 > v3 )
      {
        qword_446710 -= v3;
        v29 = (v28 - v3) | 1;
        result = qword_446728 + 16;
        qword_446728 += v3;
        *(_QWORD *)(qword_446728 + 8) = v29;
        *(_QWORD *)(result - 8) = v3 | 3;
        return result;
      }
      v30 = qword_4466D0;
      v31 = -qword_4466D0;
      if ( (dword_446A70 & 1) == 0 )
        goto LABEL_75;
      goto LABEL_30;
    }
    goto LABEL_113;
  }
  v1 = qword_446700[0];
  LODWORD(v2) = 4;
  v3 = 32i64;
  v4 = LODWORD(qword_446700[0]) >> 4;
  if ( ((LODWORD(qword_446700[0]) >> 4) & 3) == 0 )
    goto LABEL_10;
LABEL_4:
  v5 = ((v4 & 1) == 0) + (_DWORD)v2;
  v6 = 8i64 * (unsigned int)(2 * v5) + 4482888;
  v7 = qword_446758[2 * v5];
  v8 = *(_QWORD *)(v7 + 16);
  if ( v6 == v8 )
  {
    LODWORD(qword_446700[0]) = v1 & ~(1 << v5);
  }
  else
  {
    if ( qword_446718 > v8 || *(_QWORD *)(v8 + 24) != v7 )
      goto LABEL_329;
    *(_QWORD *)(v8 + 24) = v6;
    qword_446758[2 * v5] = v8;
  }
  *(_QWORD *)(v7 + 8) = (8 * v5) | 3u;
  *(_QWORD *)(v7 + (unsigned int)(8 * v5) + 8) |= 1ui64;
  return v7 + 16;
}
// 40CCEF: control flows out of bounds to 402A1F
// 40C608: variable 'v0' is possibly undefined
// 4466C0: using guessed type __int64 qword_4466C0;
// 4466D0: using guessed type __int64 qword_4466D0;
// 4466D8: using guessed type __int64 qword_4466D8;
// 4466E0: using guessed type __int64 qword_4466E0;
// 446700: using guessed type __int64 qword_446700[];
// 446708: using guessed type __int64 qword_446708[];
// 446710: using guessed type __int64 qword_446710;
// 446718: using guessed type __int64 qword_446718;
// 446720: using guessed type __int64 qword_446720;
// 446728: using guessed type __int64 qword_446728;
// 446730: using guessed type __int64 qword_446730;
// 446738: using guessed type __int64 qword_446738;
// 446740: using guessed type __int64 qword_446740;
// 446758: using guessed type _QWORD qword_446758[62];
// 446958: using guessed type __int64 qword_446958[31];
// 446A50: using guessed type __int64 qword_446A50;
// 446A58: using guessed type __int64 qword_446A58;
// 446A60: using guessed type __int64 qword_446A60;
// 446A68: using guessed type __int64 qword_446A68;
// 446A70: using guessed type int dword_446A70;
// 446A78: using guessed type __int128 xmmword_446A78;
// 446A88: using guessed type __int128 xmmword_446A88;

//----- (000000000040DCD0) ----------------------------------------------------
void __fastcall sub_40DCD0()
{
  __int64 v0; // rdi
  __int64 v1; // rdx
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // r9
  __int64 v4; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rdx
  _QWORD *v8; // r8
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  __int64 v11; // r10
  __int64 v12; // rdx
  __int64 v13; // r11
  unsigned __int64 v14; // rdx
  _QWORD *v15; // r8
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rdx
  __int64 v19; // rdx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rdx
  __int64 v25; // rcx
  int v26; // edx
  __int64 v27; // rsi
  int v28; // edx
  int v29; // er8
  unsigned __int64 v30; // rsi
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // rdx
  __int64 v33; // rdx
  unsigned __int64 v34; // rax
  _QWORD *v35; // rdx
  __int64 v36; // r10
  __int64 v37; // rdx
  unsigned __int64 v38; // r11
  unsigned __int64 v39; // rdx
  __int64 v40; // rdx
  unsigned __int64 v41; // rdx
  unsigned __int64 v42; // rdx
  __int64 v43; // rbx
  unsigned __int64 v44; // rax
  __int64 v45; // rax
  _QWORD *v46; // rdx
  _QWORD *v47; // rcx
  _QWORD *v48; // r10
  _QWORD *v49; // rdx
  _QWORD *v50; // rcx
  _QWORD *v51; // r10

  if ( !v0 )
    return;
  v1 = v0;
  v2 = v0 - 16;
  v3 = qword_446718;
  if ( qword_446718 > v2 )
    goto LABEL_141;
  v4 = *(_QWORD *)(v1 - 8);
  if ( (v4 & 3) == 1 )
    goto LABEL_141;
  v5 = v4 & 0xFFFFFFFFFFFFFFF8ui64;
  v6 = v2 + (v4 & 0xFFFFFFFFFFFFFFF8ui64);
  if ( (v4 & 1) != 0 )
    goto LABEL_13;
  v7 = *(_QWORD *)(v1 - 16);
  v2 -= v7;
  if ( (v4 & 3) == 0 )
  {
    v43 = v5 + v7 + 32;
    if ( !(unsigned int)sub_40F560() )
      qword_446A58 -= v43;
    return;
  }
  v5 += v7;
  if ( qword_446718 > v2 )
LABEL_141:
    JUMPOUT(0x402A33i64);
  if ( qword_446720 == v2 )
  {
    v37 = *(_QWORD *)(v6 + 8);
    if ( (v37 & 3) == 3 )
    {
      qword_446708[0] = v5;
      *(_QWORD *)(v6 + 8) = v37 & 0xFFFFFFFFFFFFFFFEui64;
      *(_QWORD *)(v2 + 8) = v5 | 1;
      *(_QWORD *)v6 = v5;
      return;
    }
    goto LABEL_13;
  }
  v8 = *(_QWORD **)(v2 + 24);
  v9 = v7 >> 3;
  if ( v7 <= 0xFF )
  {
    v10 = *(_QWORD *)(v2 + 16);
    v11 = 8i64 * (unsigned int)(2 * v9) + 4482888;
    if ( v11 != v10 && (qword_446718 > v10 || *(_QWORD *)(v10 + 24) != v2) )
      goto LABEL_140;
    if ( v8 == (_QWORD *)v10 )
    {
      LODWORD(qword_446700[0]) &= __ROL4__(-2, v9);
    }
    else
    {
      if ( (_QWORD *)v11 != v8 && (qword_446718 > (unsigned __int64)v8 || v8[2] != v2) )
        goto LABEL_140;
      *(_QWORD *)(v10 + 24) = v8;
      v8[2] = v10;
    }
    goto LABEL_13;
  }
  v38 = *(_QWORD *)(v2 + 48);
  if ( v8 != (_QWORD *)v2 )
  {
    v39 = *(_QWORD *)(v2 + 16);
    if ( qword_446718 > v39 || *(_QWORD *)(v39 + 24) != v2 || v8[2] != v2 )
      goto LABEL_140;
    *(_QWORD *)(v39 + 24) = v8;
    v8[2] = v39;
    goto LABEL_73;
  }
  v49 = *(_QWORD **)(v2 + 40);
  v50 = (_QWORD *)(v2 + 40);
  if ( v49 )
  {
    do
    {
      do
      {
LABEL_107:
        v51 = v50;
        v8 = v49;
        v50 = v49 + 5;
        v49 = (_QWORD *)v49[5];
      }
      while ( v49 );
      v49 = (_QWORD *)v8[4];
      v50 = v8 + 4;
    }
    while ( v49 );
    if ( qword_446718 > (unsigned __int64)v51 )
      goto LABEL_140;
    *v51 = 0i64;
    goto LABEL_73;
  }
  v49 = *(_QWORD **)(v2 + 32);
  if ( v49 )
  {
    v50 = (_QWORD *)(v2 + 32);
    goto LABEL_107;
  }
  v8 = 0i64;
LABEL_73:
  if ( !v38 )
    goto LABEL_13;
  v40 = *(unsigned int *)(v2 + 56);
  if ( qword_446958[v40] == v2 )
  {
    qword_446700[v40 + 75] = (__int64)v8;
    if ( !v8 )
    {
      HIDWORD(qword_446700[0]) &= __ROL4__(-2, v40);
      goto LABEL_13;
    }
  }
  else
  {
    if ( v3 > v38 )
      goto LABEL_140;
    if ( *(_QWORD *)(v38 + 32) == v2 )
      *(_QWORD *)(v38 + 32) = v8;
    else
      *(_QWORD *)(v38 + 40) = v8;
    if ( !v8 )
      goto LABEL_13;
  }
  if ( v3 > (unsigned __int64)v8 )
    goto LABEL_140;
  v41 = *(_QWORD *)(v2 + 32);
  v8[6] = v38;
  if ( v41 )
  {
    if ( v3 > v41 )
      goto LABEL_140;
    v8[4] = v41;
    *(_QWORD *)(v41 + 48) = v8;
  }
  v42 = *(_QWORD *)(v2 + 40);
  if ( v42 )
  {
    if ( v3 > v42 )
      goto LABEL_140;
    v8[5] = v42;
    *(_QWORD *)(v42 + 48) = v8;
  }
LABEL_13:
  if ( v2 >= v6 )
    goto LABEL_141;
  v12 = *(_QWORD *)(v6 + 8);
  if ( (v12 & 1) == 0 )
    goto LABEL_141;
  if ( (v12 & 2) == 0 )
  {
    v13 = qword_446720;
    if ( qword_446728 == v6 )
    {
      v44 = qword_446710 + v5;
      qword_446728 = v2;
      qword_446710 = v44;
      *(_QWORD *)(v2 + 8) = v44 | 1;
      if ( v13 == v2 )
      {
        qword_446720 = 0i64;
        qword_446708[0] = 0i64;
      }
      if ( v44 > qword_446730 )
        sub_40BD00();
      return;
    }
    if ( qword_446720 == v6 )
    {
      v45 = qword_446708[0] + v5;
      qword_446720 = v2;
      qword_446708[0] = v45;
      *(_QWORD *)(v2 + 8) = v45 | 1;
      *(_QWORD *)(v2 + v45) = v45;
      return;
    }
    v14 = v12 & 0xFFFFFFFFFFFFFFF8ui64;
    v15 = *(_QWORD **)(v6 + 24);
    v5 += v14;
    v16 = v14 >> 3;
    if ( v14 <= 0xF8 )
    {
      v35 = *(_QWORD **)(v6 + 16);
      v36 = 8i64 * (unsigned int)(2 * v16) + 4482888;
      if ( (_QWORD *)v36 != v35 && (v3 > (unsigned __int64)v35 || v35[3] != v6) )
        goto LABEL_140;
      if ( v15 == v35 )
      {
        LODWORD(qword_446700[0]) &= __ROL4__(-2, v16);
      }
      else
      {
        if ( v15 != (_QWORD *)v36 && (v3 > (unsigned __int64)v15 || v15[2] != v6) )
          goto LABEL_140;
        v35[3] = v15;
        v15[2] = v35;
      }
      goto LABEL_64;
    }
    v17 = *(_QWORD *)(v6 + 48);
    if ( v15 != (_QWORD *)v6 )
    {
      v18 = *(_QWORD *)(v6 + 16);
      if ( v3 > v18 || *(_QWORD *)(v18 + 24) != v6 || v15[2] != v6 )
        goto LABEL_140;
      *(_QWORD *)(v18 + 24) = v15;
      v15[2] = v18;
      goto LABEL_24;
    }
    v46 = *(_QWORD **)(v6 + 40);
    v47 = (_QWORD *)(v6 + 40);
    if ( !v46 )
    {
      v46 = *(_QWORD **)(v6 + 32);
      if ( !v46 )
      {
        v15 = 0i64;
LABEL_24:
        if ( !v17 )
          goto LABEL_64;
        v19 = *(unsigned int *)(v6 + 56);
        if ( qword_446958[v19] == v6 )
        {
          qword_446700[v19 + 75] = (__int64)v15;
          if ( !v15 )
          {
            HIDWORD(qword_446700[0]) &= __ROL4__(-2, v19);
            goto LABEL_64;
          }
        }
        else
        {
          if ( v3 > v17 )
            goto LABEL_140;
          if ( *(_QWORD *)(v17 + 32) == v6 )
            *(_QWORD *)(v17 + 32) = v15;
          else
            *(_QWORD *)(v17 + 40) = v15;
          if ( !v15 )
            goto LABEL_64;
        }
        if ( v3 > (unsigned __int64)v15 )
          goto LABEL_140;
        v20 = *(_QWORD *)(v6 + 32);
        v15[6] = v17;
        if ( v20 )
        {
          if ( v3 > v20 )
            goto LABEL_140;
          v15[4] = v20;
          *(_QWORD *)(v20 + 48) = v15;
        }
        v21 = *(_QWORD *)(v6 + 40);
        if ( v21 )
        {
          if ( v3 > v21 )
            goto LABEL_140;
          v15[5] = v21;
          *(_QWORD *)(v21 + 48) = v15;
        }
LABEL_64:
        *(_QWORD *)(v2 + 8) = v5 | 1;
        *(_QWORD *)(v2 + v5) = v5;
        if ( v13 == v2 )
        {
          qword_446708[0] = v5;
          return;
        }
        goto LABEL_38;
      }
      v47 = (_QWORD *)(v6 + 32);
    }
    do
    {
      do
      {
        v48 = v47;
        v15 = v46;
        v47 = v46 + 5;
        v46 = (_QWORD *)v46[5];
      }
      while ( v46 );
      v46 = (_QWORD *)v15[4];
      v47 = v15 + 4;
    }
    while ( v46 );
    if ( v3 > (unsigned __int64)v48 )
      goto LABEL_140;
    *v48 = 0i64;
    goto LABEL_24;
  }
  *(_QWORD *)(v6 + 8) = v12 & 0xFFFFFFFFFFFFFFFEui64;
  *(_QWORD *)(v2 + 8) = v5 | 1;
  *(_QWORD *)(v2 + v5) = v5;
LABEL_38:
  v22 = v5 >> 3;
  if ( v5 > 0xFF )
  {
    v24 = v5 >> 8;
    LODWORD(v25) = v5 >> 8;
    if ( (_DWORD)v25 )
    {
      if ( (unsigned int)v24 > 0xFFFF )
      {
        v28 = 0x80000000;
        v27 = 848i64;
        LODWORD(v25) = 31;
      }
      else
      {
        _BitScanReverse((unsigned int *)&v24, v24);
        v26 = v24 ^ 0x1F;
        v25 = (unsigned int)((v5 >> (38 - (unsigned __int8)v26)) & 1) + 2 * (31 - v26);
        v27 = 8 * v25 + 600;
        v28 = 1 << (((v5 >> (38 - (unsigned __int8)v26)) & 1) + 2 * (31 - v26));
      }
    }
    else
    {
      v28 = 1;
      v27 = 600i64;
    }
    v29 = HIDWORD(qword_446700[0]);
    *(_DWORD *)(v2 + 56) = v25;
    *(_QWORD *)(v2 + 40) = 0i64;
    *(_QWORD *)(v2 + 32) = 0i64;
    if ( (v29 & v28) != 0 )
    {
      v30 = *(_QWORD *)(v27 + 4482816);
      v31 = v5;
      if ( (_DWORD)v25 != 31 )
        v31 = v5 << (57 - (unsigned __int8)((unsigned int)v25 >> 1));
      while ( (*(_QWORD *)(v30 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != v5 )
      {
        v32 = v31;
        v31 *= 2i64;
        v33 = (v32 >> 63) + 4;
        if ( !*(_QWORD *)(v30 + 8 * v33) )
        {
          if ( v3 <= v30 + 8 * v33 )
          {
            *(_QWORD *)(v30 + 8 * v33) = v2;
            *(_QWORD *)(v2 + 48) = v30;
            *(_QWORD *)(v2 + 24) = v2;
            *(_QWORD *)(v2 + 16) = v2;
            goto LABEL_56;
          }
LABEL_140:
          JUMPOUT(0x402A2Ei64);
        }
        v30 = *(_QWORD *)(v30 + 8 * v33);
      }
      v34 = *(_QWORD *)(v30 + 16);
      if ( v3 > v30 || v3 > v34 )
        goto LABEL_140;
      *(_QWORD *)(v34 + 24) = v2;
      *(_QWORD *)(v30 + 16) = v2;
      *(_QWORD *)(v2 + 16) = v34;
      *(_QWORD *)(v2 + 24) = v30;
      *(_QWORD *)(v2 + 48) = 0i64;
    }
    else
    {
      HIDWORD(qword_446700[0]) = v29 | v28;
      *(_QWORD *)(v27 + 4482816) = v2;
      *(_QWORD *)(v2 + 48) = v27 + 4482816;
      *(_QWORD *)(v2 + 24) = v2;
      *(_QWORD *)(v2 + 16) = v2;
    }
LABEL_56:
    if ( !--qword_446738 )
      sub_40B940();
  }
  else
  {
    if ( ((1 << v22) & qword_446700[0]) != 0 )
    {
      v23 = qword_446758[(unsigned int)(2 * v22)];
      if ( v3 > v23 )
        goto LABEL_140;
    }
    else
    {
      LODWORD(qword_446700[0]) |= 1 << v22;
      v23 = 8i64 * (unsigned int)(2 * v22) + 4482888;
    }
    qword_446758[(unsigned int)(2 * v22)] = v2;
    *(_QWORD *)(v23 + 24) = v2;
    *(_QWORD *)(v2 + 16) = v23;
    *(_QWORD *)(v2 + 24) = 8i64 * (unsigned int)(2 * v22) + 4482888;
  }
}
// 40E43F: control flows out of bounds to 402A2E
// 40DCF3: control flows out of bounds to 402A33
// 40DCD3: variable 'v0' is possibly undefined
// 446700: using guessed type __int64 qword_446700[];
// 446708: using guessed type __int64 qword_446708[];
// 446710: using guessed type __int64 qword_446710;
// 446718: using guessed type __int64 qword_446718;
// 446720: using guessed type __int64 qword_446720;
// 446728: using guessed type __int64 qword_446728;
// 446730: using guessed type __int64 qword_446730;
// 446738: using guessed type __int64 qword_446738;
// 446758: using guessed type _QWORD qword_446758[62];
// 446958: using guessed type __int64 qword_446958[31];
// 446A58: using guessed type __int64 qword_446A58;

//----- (000000000040E4E0) ----------------------------------------------------
__int64 __fastcall sub_40E4E0()
{
  __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  unsigned __int64 v2; // rdx
  _QWORD *v3; // rax
  __int64 result; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 v7; // [rsp+8h] [rbp-18h]

  if ( !v0 )
    return sub_40C5F0();
  if ( v1 > 0xFFFFFFFFFFFFFF7Fui64 )
  {
    sub_402B8A();
    return 0i64;
  }
  else if ( v1 )
  {
    v2 = (v1 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
    if ( v1 <= 0xE )
      v2 = 32i64;
    v3 = sub_40E5D0(1i64, v2);
    if ( v3 )
    {
      return (__int64)(v3 + 2);
    }
    else
    {
      result = sub_40C5F0();
      if ( result )
      {
        v6 = (*(_QWORD *)(v0 - 8) & 0xFFFFFFFFFFFFFFF8ui64) - 16;
        if ( v6 > v1 )
          v6 = v1;
        sub_4154C0(v5, v6);
        sub_40DCD0();
        return v7;
      }
    }
  }
  else
  {
    sub_40DCD0();
    return 0i64;
  }
  return result;
}
// 40E4F2: variable 'v0' is possibly undefined
// 40E4FB: variable 'v1' is possibly undefined
// 40E5AA: variable 'v5' is possibly undefined
// 40E5B7: variable 'v7' is possibly undefined
// 40E4E0: using guessed type __int64 __fastcall sub_40E4E0();

//----- (000000000040E5C0) ----------------------------------------------------
_QWORD *__fastcall sub_40E5C0(__int64 a1)
{
  unsigned __int64 v1; // rdi

  if ( (unsigned __int64)qword_4466C8 <= 0x10 )
    return (_QWORD *)sub_40C5F0();
  else
    return sub_40EB10(a1, v1);
}
// 40EAF1: variable 'v1' is possibly undefined
// 4466C8: using guessed type __int64 qword_4466C8;

//----- (000000000040E5D0) ----------------------------------------------------
_QWORD *__fastcall sub_40E5D0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rsi
  __int64 v5; // r12
  _QWORD *v6; // rbx
  __int64 v7; // rsi
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rdx
  char *v10; // rdi
  __int64 v11; // r9
  unsigned __int64 v12; // rdx
  _QWORD *v13; // r14
  unsigned __int64 v15; // r9
  unsigned __int64 v16; // r11
  char *v17; // r8
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // rcx
  __int64 v22; // rcx
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rcx
  __int64 v25; // rsi
  __int64 v26; // rcx
  __int64 v27; // r15
  __int64 v28; // r13
  unsigned __int64 v29; // rax
  __int64 v30; // rdx
  bool v31; // cf
  unsigned __int64 v32; // r13
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rdx
  unsigned __int64 *v36; // rcx
  __int64 v37; // rsi
  unsigned __int64 v38; // rdi
  char *v39; // r9
  __int64 v40; // r13
  _QWORD *v41; // rcx
  _QWORD *v42; // r9
  _QWORD *v43; // r13
  __int64 v44; // r9
  int v45; // ecx
  __int64 v46; // [rsp+8h] [rbp-38h]

  v5 = v2;
  v6 = v3;
  v7 = v3[1];
  v8 = *(_QWORD *)(v2 + 24);
  v9 = v7 & 0xFFFFFFFFFFFFFFF8ui64;
  v10 = (char *)v6 + (v7 & 0xFFFFFFFFFFFFFFF8ui64);
  if ( v8 > (unsigned __int64)v6 )
    goto LABEL_74;
  if ( (v7 & 3) == 1 )
    goto LABEL_74;
  if ( v6 >= (_QWORD *)v10 )
    goto LABEL_74;
  v11 = *((_QWORD *)v10 + 1);
  if ( (v11 & 1) == 0 )
    goto LABEL_74;
  if ( (v7 & 3) != 0 )
  {
    if ( v9 >= a2 )
    {
      v12 = v9 - a2;
      v13 = v6;
      if ( v12 > 0x1F )
      {
        v6[1] = v7 & 1 | a2 | 2;
        *(_QWORD *)((char *)v6 + a2 + 8) = v12 | 3;
        *((_QWORD *)v10 + 1) |= 1ui64;
        sub_40BEA0(a1, v12);
      }
      return v13;
    }
    if ( *(char **)(v5 + 40) == v10 )
    {
      v34 = *(_QWORD *)(v5 + 16) + v9;
      if ( v34 > a2 )
      {
        v35 = v34 - a2;
        v13 = v6;
        v6[1] = v7 & 1 | a2 | 2;
        *(_QWORD *)((char *)v6 + a2 + 8) = v35 | 1;
        *(_QWORD *)(v5 + 40) = (char *)v6 + a2;
        *(_QWORD *)(v5 + 16) = v35;
        return v13;
      }
    }
    else if ( *(char **)(v5 + 32) == v10 )
    {
      v33 = *(_QWORD *)(v5 + 8) + v9;
      if ( v33 >= a2 )
      {
        v36 = (_QWORD *)((char *)v6 + v33);
        v37 = v7 & 1;
        v38 = v33 - a2;
        v13 = v6;
        if ( v33 - a2 <= 0x1F )
        {
          v6[1] = v37 | v33 | 2;
          v36[1] |= 1ui64;
          *(_QWORD *)(v5 + 8) = 0i64;
          *(_QWORD *)(v5 + 32) = 0i64;
        }
        else
        {
          v6[1] = a2 | v37 | 2;
          *(_QWORD *)((char *)v6 + a2 + 8) = v38 | 1;
          *v36 = v38;
          v36[1] &= ~1ui64;
          *(_QWORD *)(v5 + 8) = v38;
          *(_QWORD *)(v5 + 32) = (char *)v6 + a2;
        }
        return v13;
      }
    }
    else if ( (v11 & 2) == 0 )
    {
      v15 = v11 & 0xFFFFFFFFFFFFFFF8ui64;
      v16 = v9 + v15;
      if ( v9 + v15 >= a2 )
      {
        v17 = (char *)*((_QWORD *)v10 + 3);
        v18 = v16 - a2;
        v19 = v15 >> 3;
        if ( v15 > 0xF8 )
        {
          v20 = *((_QWORD *)v10 + 6);
          if ( v17 != v10 )
          {
            v21 = *((_QWORD *)v10 + 2);
            if ( v8 > v21 || *(char **)(v21 + 24) != v10 || *((char **)v17 + 2) != v10 )
              goto LABEL_74;
            *(_QWORD *)(v21 + 24) = v17;
            *((_QWORD *)v17 + 2) = v21;
            goto LABEL_20;
          }
          v41 = (_QWORD *)*((_QWORD *)v10 + 5);
          v42 = v10 + 40;
          if ( v41 )
          {
            do
            {
              do
              {
LABEL_55:
                v43 = v42;
                v17 = (char *)v41;
                v42 = v41 + 5;
                v41 = (_QWORD *)v41[5];
              }
              while ( v41 );
              v41 = (_QWORD *)*((_QWORD *)v17 + 4);
              v42 = v17 + 32;
            }
            while ( v41 );
            if ( v8 > (unsigned __int64)v43 )
              goto LABEL_74;
            *v43 = 0i64;
LABEL_20:
            if ( !v20 )
              goto LABEL_33;
            v22 = v5 + 8i64 * *((unsigned int *)v10 + 14);
            if ( *(char **)(v22 + 600) == v10 )
            {
              *(_QWORD *)(v22 + 600) = v17;
LABEL_26:
              if ( v8 > (unsigned __int64)v17 )
                goto LABEL_74;
              v23 = *((_QWORD *)v10 + 4);
              *((_QWORD *)v17 + 6) = v20;
              if ( v23 )
              {
                if ( v8 > v23 )
                  goto LABEL_74;
                *((_QWORD *)v17 + 4) = v23;
                *(_QWORD *)(v23 + 48) = v17;
              }
              v24 = *((_QWORD *)v10 + 5);
              if ( !v24 )
                goto LABEL_33;
              if ( v8 <= v24 )
              {
                *((_QWORD *)v17 + 5) = v24;
                *(_QWORD *)(v24 + 48) = v17;
                goto LABEL_33;
              }
LABEL_74:
              JUMPOUT(0x402A38i64);
            }
LABEL_22:
            if ( v8 > v20 )
              goto LABEL_74;
            if ( *(char **)(v20 + 32) == v10 )
              *(_QWORD *)(v20 + 32) = v17;
            else
              *(_QWORD *)(v20 + 40) = v17;
            if ( !v17 )
              goto LABEL_33;
            goto LABEL_26;
          }
          v41 = (_QWORD *)*((_QWORD *)v10 + 4);
          if ( v41 )
          {
            v42 = v10 + 32;
            goto LABEL_55;
          }
          if ( v20 )
          {
            v44 = v5 + 8i64 * *((unsigned int *)v10 + 14);
            v45 = *((_DWORD *)v10 + 14);
            v17 = 0i64;
            if ( *(char **)(v44 + 600) != v10 )
              goto LABEL_22;
            *(_QWORD *)(v44 + 600) = 0i64;
            *(_DWORD *)(v5 + 4) &= __ROL4__(-2, v45);
          }
LABEL_33:
          v25 = v7 & 1;
          v26 = (__int64)v6 + v16;
          v13 = v6;
          if ( v18 > 0x1F )
          {
            v6[1] = a2 | v25 | 2;
            *(_QWORD *)((char *)v6 + a2 + 8) = v18 | 3;
            *(_QWORD *)(v26 + 8) |= 1ui64;
            sub_40BEA0(v26, v18);
          }
          else
          {
            v6[1] = v16 | v25 | 2;
            *(_QWORD *)(v26 + 8) |= 1ui64;
          }
          return v13;
        }
        v39 = (char *)*((_QWORD *)v10 + 2);
        v40 = v5 + 8i64 * (unsigned int)(2 * v19) + 72;
        if ( (char *)v40 == v39 )
        {
          if ( v17 == v39 )
          {
LABEL_51:
            *(_DWORD *)v5 &= __ROL4__(-2, v19);
            goto LABEL_33;
          }
        }
        else
        {
          if ( v8 > (unsigned __int64)v39 || *((char **)v39 + 3) != v10 )
            goto LABEL_74;
          if ( v17 == v39 )
            goto LABEL_51;
          if ( (char *)v40 == v17 )
          {
LABEL_65:
            *((_QWORD *)v39 + 3) = v17;
            *((_QWORD *)v17 + 2) = v39;
            goto LABEL_33;
          }
        }
        if ( v8 > (unsigned __int64)v17 || *((char **)v17 + 2) != v10 )
          goto LABEL_74;
        goto LABEL_65;
      }
    }
    return 0i64;
  }
  if ( a2 <= 0xFF )
    return 0i64;
  if ( v9 >= a2 + 8 )
  {
    v13 = v6;
    if ( v9 - a2 <= 2 * qword_4466D0 )
      return v13;
  }
  v27 = *v6;
  v28 = -qword_4466D0 & (qword_4466D0 + a2 + 62);
  v29 = sub_40F550();
  if ( v29 == -1i64 )
    return 0i64;
  v13 = (_QWORD *)(v29 + v27);
  v30 = v28 - v27;
  v31 = v29 < *(_QWORD *)(v5 + 24);
  v13[1] = v28 - v27 - 32;
  *(_QWORD *)((char *)v13 + v30 - 24) = 11i64;
  *(_QWORD *)((char *)v13 + v30 - 16) = 0i64;
  if ( v31 )
    *(_QWORD *)(v5 + 24) = v29;
  v32 = *(_QWORD *)(v5 + 856) + v28 - v46;
  *(_QWORD *)(v5 + 856) = v32;
  if ( v32 > *(_QWORD *)(v5 + 864) )
    *(_QWORD *)(v5 + 864) = v32;
  return v13;
}
// 40EA92: control flows out of bounds to 402A38
// 40E7E1: ignored the value written to the shadow area of the succeeding call
// 40E5DF: variable 'v2' is possibly undefined
// 40E5E3: variable 'v3' is possibly undefined
// 40E830: variable 'v46' is possibly undefined
// 4466D0: using guessed type __int64 qword_4466D0;

//----- (000000000040EB10) ----------------------------------------------------
_QWORD *__fastcall sub_40EB10(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // r12
  _QWORD *v6; // r12
  unsigned __int64 v8; // rax
  bool v9; // cc
  __int64 v10; // rbx
  __int64 v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // rsi
  unsigned __int64 *v14; // r14
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rax
  __int64 v19; // rcx

  v4 = 32i64;
  if ( v3 >= 0x20 )
    v4 = v3;
  if ( (v4 & (v4 - 1)) != 0 )
    v4 = sub_40ED20();
  if ( -128i64 - v4 > a2 )
  {
    v8 = (a2 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
    v9 = a2 <= 0xE;
    v10 = 32i64;
    if ( !v9 )
      v10 = v8;
    v11 = sub_40C5F0();
    if ( v11 )
    {
      v12 = v4 - 1;
      v13 = v11 - 16;
      if ( ((v4 - 1) & v11) != 0 )
      {
        v14 = (unsigned __int64 *)((-(__int64)v4 & (v11 + v12)) - 16);
        v15 = (-(__int64)v4 & (v11 + v12)) - v11;
        if ( v15 <= 0x1F )
        {
          v14 = (unsigned __int64 *)((char *)v14 + v4);
          v15 = (unsigned __int64)v14 - v13;
        }
        v6 = v14 + 2;
        v16 = (*(_QWORD *)(v11 - 8) & 0xFFFFFFFFFFFFFFF8ui64) - v15;
        if ( (*(_QWORD *)(v11 - 8) & 3) != 0 )
        {
          v14[1] = v16 | v14[1] & 1 | 2;
          *(unsigned __int64 *)((char *)v14 + v16 + 8) |= 1ui64;
          v19 = v15 | *(_QWORD *)(v11 - 8) & 1i64 | 2;
          *(_QWORD *)(v11 - 8) = v19;
          *(_QWORD *)(v13 + v15 + 8) |= 1ui64;
          sub_40BEA0(v19, v15);
          v16 = v14[1];
        }
        else
        {
          v17 = *(_QWORD *)(v11 - 16) + v15;
          v14[1] = v16;
          *v14 = v17;
        }
      }
      else
      {
        v16 = *(_QWORD *)(v11 - 8);
        v6 = (_QWORD *)v11;
        v14 = (unsigned __int64 *)(v11 - 16);
      }
      v18 = v16 & 0xFFFFFFFFFFFFFFF8ui64;
      if ( (v16 & 3) != 0 && v10 + 32 < v18 )
      {
        v14[1] = v16 & 1 | v10 | 2;
        *(unsigned __int64 *)((char *)v14 + v10 + 8) = (v18 - v10) | 3;
        *(unsigned __int64 *)((char *)v14 + v18 + 8) |= 1ui64;
        sub_40BEA0((v18 - v10) | 3, v18 - v10);
      }
      return v6;
    }
  }
  else if ( v2 )
  {
    v6 = 0i64;
    sub_402B8A();
    return v6;
  }
  return 0i64;
}
// 40EB27: variable 'v3' is possibly undefined
// 40EB56: variable 'v2' is possibly undefined

//----- (000000000040ECB0) ----------------------------------------------------
__int64 __fastcall sub_40ECB0()
{
  unsigned __int64 v0; // rdi
  unsigned __int64 v1; // rdi
  __int64 v2; // rdi

  v1 = (((v0 - ((v0 >> 1) & 0x5555555555555555i64)) >> 2) & 0x3333333333333333i64)
     + ((v0 - ((v0 >> 1) & 0x5555555555555555i64)) & 0x3333333333333333i64);
  v2 = (v1 + (v1 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
  return ((_BYTE)v2
        + BYTE4(v2)
        + (unsigned __int8)((unsigned int)(v2 + HIDWORD(v2)) >> 16)
        + ((unsigned __int16)(v2 + WORD2(v2) + ((unsigned int)(v2 + HIDWORD(v2)) >> 16)) >> 8)) & 0x7F;
}
// 40ECD0: variable 'v0' is possibly undefined

//----- (000000000040ED20) ----------------------------------------------------
unsigned __int64 __fastcall sub_40ED20()
{
  unsigned __int64 v0; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v2; // rcx

  result = v0;
  if ( v0 > 1 )
  {
    _BitScanReverse64(&v2, v0 - 1);
    return 1i64 << ((unsigned __int8)v2 + 1);
  }
  return result;
}
// 40ED20: variable 'v0' is possibly undefined

//----- (000000000040ED3D) ----------------------------------------------------
__int64 sub_40ED3D()
{
  sub_4011F2();
  sub_40229E();
  return sub_402240();
}

//----- (000000000040ED60) ----------------------------------------------------
__int64 __fastcall sub_40ED60(__int64 a1)
{
  return sub_40EDE0(a1, 0i64);
}

//----- (000000000040ED70) ----------------------------------------------------
__int64 __fastcall sub_40ED70(__int64 a1, __int64 a2)
{
  volatile __int32 *v2; // rdi

  if ( _InterlockedExchange(v2, -1) == -1 )
    return 0i64;
  else
    return sub_410160(a1, a2);
}
// 40ED78: variable 'v2' is possibly undefined

//----- (000000000040ED90) ----------------------------------------------------
__int64 __fastcall sub_40ED90(__int64 a1)
{
  _QWORD *v1; // rdi
  __int64 result; // rax
  unsigned __int64 v3; // rdx
  int v4; // eax

  result = 0i64;
  v3 = *v1 - 1i64;
  if ( v3 <= 0xFFFFFFFFFFFFFFFDui64 )
  {
    *v1 = 0i64;
    v4 = sub_40EF50(a1, v3);
    return v4 | (unsigned int)sub_40F560();
  }
  return result;
}
// 40ED99: variable 'v1' is possibly undefined

//----- (000000000040EDE0) ----------------------------------------------------
__int64 __fastcall sub_40EDE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  int *v5; // rbx
  int v6; // ecx
  unsigned int v7; // eax
  int *v8; // rax
  __int64 v10; // rax

  v5 = (int *)qword_446AC0;
  if ( !qword_446AC0 )
  {
    qword_446AC0 = 4483784i64;
    v5 = (int *)&unk_446AC8;
  }
  v6 = *v5;
  if ( *v5 != -1 )
    goto LABEL_4;
  if ( sub_40B6FB )
  {
    v10 = sub_40B6FB();
    if ( v10 )
    {
      *(_QWORD *)(v10 + 8) = v5;
      v6 = *(_DWORD *)v10;
      v5 = (int *)v10;
      qword_446AC0 = v10;
LABEL_4:
      _BitScanReverse(&v7, ~v6);
      *v5 = v6 | (1 << v7);
      v8 = &v5[6 * v7];
      *((_QWORD *)v8 + 2) = v2;
      *((_QWORD *)v8 + 3) = v3;
      *((_QWORD *)v8 + 4) = a2;
      return 0i64;
    }
  }
  return sub_402B8A();
}
// 40EE1D: variable 'v2' is possibly undefined
// 40EE21: variable 'v3' is possibly undefined
// 40B6FB: using guessed type __int64 sub_40B6FB(void);
// 446AC0: using guessed type __int64 qword_446AC0;

//----- (000000000040EE90) ----------------------------------------------------
void __fastcall sub_40EE90(unsigned __int64 _RCX, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rbx
  unsigned int *v6; // rdi
  __int64 v8; // rax
  void (__fastcall *v9)(unsigned __int64, __int64); // rax
  __int64 v10; // r13

  v5 = v4;
  v6 = (unsigned int *)qword_446AC0;
  if ( qword_446AC0 )
  {
    while ( 2 )
    {
      while ( 1 )
      {
        _RDX = *v6;
        while ( _RDX )
        {
          __asm { tzcnt   ecx, edx }
          _RCX = (unsigned int)_RCX;
          v8 = (unsigned int)~(1 << _RCX);
          _RDX &= v8;
          if ( !v5 || *(_QWORD *)&v6[6 * (unsigned int)_RCX + 8] == v5 )
          {
            *v6 &= v8;
            _RCX = (unsigned __int64)&v6[6 * (unsigned int)_RCX];
            v9 = *(void (__fastcall **)(unsigned __int64, __int64))(_RCX + 16);
            if ( v9 )
            {
              v9(_RCX, _RDX);
              v6 = (unsigned int *)qword_446AC0;
              goto LABEL_8;
            }
          }
        }
        v10 = *((_QWORD *)v6 + 1);
        if ( !v5 )
          break;
        if ( !v10 )
          return;
        v6 = (unsigned int *)*((_QWORD *)v6 + 1);
      }
      if ( v10 && sub_40B701 )
        sub_40B701(_RCX, 0i64, a3, a4);
      qword_446AC0 = v10;
      v6 = (unsigned int *)v10;
LABEL_8:
      if ( v6 )
        continue;
      break;
    }
  }
}
// 40EE9F: variable 'v4' is possibly undefined
// 40EF42: variable '_RCX' is possibly undefined
// 40EF42: variable 'a3' is possibly undefined
// 40EF42: variable 'a4' is possibly undefined
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);
// 446AC0: using guessed type __int64 qword_446AC0;

//----- (000000000040EF50) ----------------------------------------------------
__int64 __fastcall sub_40EF50(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned int v3; // er12
  int v4; // eax
  __int64 result; // rax
  unsigned int v6; // eax

  v3 = 0;
  if ( (unsigned __int64)(*(_QWORD *)(v2 + 8) - 1i64) <= 0xFFFFFFFFFFFFFFFDui64 )
  {
    v6 = sub_40F560();
    *(_QWORD *)(v2 + 8) = -1i64;
    v3 = v6;
  }
  if ( *(_DWORD *)v2 != -1 )
  {
    v4 = sub_410160(a1, a2);
    *(_DWORD *)v2 = -1;
    v3 |= v4;
  }
  result = v3;
  *(_QWORD *)(v2 + 16) = 0i64;
  return result;
}
// 40EF5D: variable 'v2' is possibly undefined
// 40EF72: variable 'a1' is possibly undefined
// 40EF72: variable 'a2' is possibly undefined

//----- (000000000040EFB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_40EFB0(__int64 a1, unsigned int a2)
{
  __int64 v2; // rsi
  int v3; // eax
  __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  __int64 v7; // rax

  *(_QWORD *)(v2 + 8) = -1i64;
  v3 = sub_410E90(a1, a2);
  *(_DWORD *)v2 = v3;
  if ( v3 == -1 )
    goto LABEL_7;
  result = sub_410930();
  *(_QWORD *)(v2 + 16) = result;
  if ( result > 0x7FFFFFFE )
    goto LABEL_7;
  if ( !result )
  {
    *(_QWORD *)(v2 + 8) = 0i64;
    return result;
  }
  v7 = sub_40F370(dword_4408D0 | 2u, 1u, *(_DWORD *)v2, 0i64);
  *(_QWORD *)(v2 + 8) = v7;
  if ( v7 != -1 )
    return 0i64;
LABEL_7:
  sub_40EF50(v5, v4);
  return 0xFFFFFFFFi64;
}
// 40EFBF: variable 'v2' is possibly undefined
// 40F043: variable 'v5' is possibly undefined
// 40F043: variable 'v4' is possibly undefined
// 4408D0: using guessed type int dword_4408D0;
// 440938: using guessed type __int64 qword_440938;

//----- (000000000040F050) ----------------------------------------------------
char *sub_40F050()
{
  __int64 v0; // r12
  char *v2; // rbx
  unsigned int v3; // eax
  bool v4; // cf
  bool v5; // zf
  __int64 v6; // rcx
  const char *v7; // rdi
  const char *v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // rcx
  char v11; // [rsp+0h] [rbp-30h] BYREF
  __int64 v12; // [rsp+8h] [rbp-28h]
  char v13; // [rsp+10h] [rbp-20h] BYREF

  if ( byte_446DE0 )
  {
    return &byte_446DE0;
  }
  else
  {
    v0 = qword_41C710;
    v2 = &v11;
    v12 = sub_4106F0();
    while ( 1 )
    {
      v3 = (unsigned int)sub_41571A();
      v4 = v3 - 5 < 0xED;
      v5 = v3 == 242;
      if ( v3 - 5 <= 0xED )
      {
        v6 = 5i64;
        v7 = ".dbg";
        v8 = (const char *)(v0 + v3 - 4);
        do
        {
          if ( !v6 )
            break;
          v4 = *v8 < (unsigned int)*v7;
          v5 = *v8++ == *v7++;
          --v6;
        }
        while ( v5 );
        if ( (!v4 && !v5) == v4 )
          return (char *)v0;
        sub_4154C0(v6, v3);
        sub_4154C0(v9, 5ui64);
        if ( sub_410560(v10) )
          return &byte_446DE0;
        byte_446DE0 = 0;
      }
      v2 += 8;
      if ( &v13 == v2 )
        break;
      v0 = *(_QWORD *)v2;
    }
    dword_448020 = qword_440860;
    return 0i64;
  }
}
// 40F0EE: variable 'v9' is possibly undefined
// 40F0F8: variable 'v10' is possibly undefined
// 41C710: using guessed type __int64 qword_41C710;
// 440788: using guessed type __int64 qword_440788;
// 440860: using guessed type __int64 qword_440860;
// 446DE0: using guessed type char byte_446DE0;
// 448020: using guessed type int dword_448020;

//----- (000000000040F140) ----------------------------------------------------
__int64 (*__fastcall sub_40F140())(void)
{
  volatile __int64 *v0; // rdi
  __int64 (*result)(void); // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  _InterlockedExchange64(v0, 0i64);
  result = (__int64 (*)(void))sub_40F2D0();
  if ( (_BYTE)result )
    return sub_40F867(v3, v2, v4, v5);
  return result;
}
// 40F14D: variable 'v0' is possibly undefined
// 40F172: variable 'v3' is possibly undefined
// 40F172: variable 'v2' is possibly undefined
// 40F172: variable 'v4' is possibly undefined
// 40F172: variable 'v5' is possibly undefined

//----- (000000000040F180) ----------------------------------------------------
__int64 __fastcall sub_40F180(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  unsigned __int64 *v3; // rsi
  unsigned __int64 *v5; // r13
  __int64 v7; // rcx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rsi
  bool v10; // of
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // r14
  unsigned __int128 v13; // rax
  unsigned __int64 v14; // kr00_8
  unsigned __int64 v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v19; // [rsp+8h] [rbp-38h]

  v5 = v3;
  sub_40F2D0();
  if ( (unsigned __int8)sub_40F2D0() )
  {
    v8 = *v3;
    if ( *v2 )
      goto LABEL_3;
  }
  else
  {
    v8 = *v3;
    if ( *v2 )
    {
LABEL_3:
      v9 = v8 + (v8 >> 1);
      goto LABEL_4;
    }
  }
  v9 = 4i64;
  if ( 0x1F / a2 >= 4 )
    v9 = 0x1F / a2;
LABEL_4:
  v10 = (a2 * (unsigned __int128)v8) >> 64 != 0;
  v11 = a2 * v8;
  if ( v10 || (v12 = v9 + a1 + 1, v14 = a2, v13 = v12 * (unsigned __int128)a2, v15 = v12 * a2, !is_mul_ok(v12, v14)) )
  {
    sub_402BC9();
    return 0i64;
  }
  else if ( sub_40B70D && sub_40B70D(v7, *((_QWORD *)&v13 + 1)) )
  {
    if ( !v19 )
    {
      if ( *v2 )
        sub_4154C0(v16, v11);
    }
    sub_41561F(v16, v15 - v11);
    *v5 = v12;
    *v2 = v17;
    return 1i64;
  }
  else
  {
    sub_402B8A();
    return 0i64;
  }
}
// 40F1FE: ignored the value written to the shadow area of the succeeding call
// 40F190: variable 'v3' is possibly undefined
// 40F1B5: variable 'v2' is possibly undefined
// 40F209: variable 'v7' is possibly undefined
// 40F21B: variable 'v19' is possibly undefined
// 40F22D: variable 'v16' is possibly undefined
// 40F236: variable 'v17' is possibly undefined
// 40B70D: using guessed type __int64 __fastcall sub_40B70D(_QWORD, _QWORD);

//----- (000000000040F2D0) ----------------------------------------------------
__int64 __fastcall sub_40F2D0()
{
  __int64 v0; // rdi
  unsigned int v1; // er12
  __int64 v3; // rbx
  int v4; // eax
  __int64 v5; // rax
  __int64 savedregs; // [rsp+10h] [rbp+0h] BYREF

  v1 = 0;
  if ( ((v0 ^ (unsigned __int64)&savedregs) & 0xFFFFFFFFFFFF0000ui64) != 0 && v0 > 4493312 )
  {
    v3 = v0 >> 16;
    v4 = sub_40F8B0();
    if ( dword_446EE0 > v4 )
    {
      v5 = 24i64 * v4 + 4484832;
      if ( *(_DWORD *)(v5 + 8) <= (int)v3 )
        LOBYTE(v1) = *(_DWORD *)(v5 + 12) >= (int)v3;
    }
  }
  return v1;
}
// 40F2D4: variable 'v0' is possibly undefined
// 446EE0: using guessed type int dword_446EE0;

//----- (000000000040F340) ----------------------------------------------------
__int64 sub_40F340()
{
  return sub_40F370((unsigned int)qword_4408C8 | 2, 3u, -1, 0i64);
}
// 4408C8: using guessed type __int64 qword_4408C8;

//----- (000000000040F370) ----------------------------------------------------
__int64 __fastcall sub_40F370(unsigned int a1, unsigned int a2, int a3, __int64 a4)
{
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbx
  __int64 v10; // r12
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  int v13; // er10
  int v14; // ecx
  int v15; // edx
  __int64 v16; // rax
  int v17; // esi
  int v18; // edi
  LPVOID v19; // rax
  __int64 v20; // rdx
  LPVOID v21; // r15
  int v23; // eax
  __int64 v24; // [rsp+8h] [rbp-38h]

  if ( !v5
    || (v6 = v4, (unsigned __int16)a4 | (unsigned __int16)v4)
    || (unsigned __int64)(v4 + 0x800000000000i64) > 0xFFFFFFFFFFFFi64
    || (((int)a1 & (unsigned __int64)qword_4408C8) == 0) != (a3 != -1)
    || (((unsigned __int8)(a1 >> 1) ^ 1) & 1) != (a1 & 1) )
  {
    JUMPOUT(0x402A42i64);
  }
  v11 = v5 + 0xFFFF;
  v10 = v5;
  LOWORD(v11) = 0;
  if ( a3 == -1 )
    v10 = v11;
  if ( (a1 & 0x10) != 0 )
  {
    v23 = sub_40F830();
    a4 = v24;
    if ( v23 == -1 )
      return -1i64;
  }
  else
  {
    v12 = (unsigned __int64)(v10 + 0xFFFF) >> 16;
    v13 = v12;
    if ( dword_446EE0 <= 0 )
    {
      v18 = v12 + 268468224;
      v14 = 268468224;
    }
    else
    {
      v14 = 268468224;
      v15 = v12 + 268468224;
      v16 = 0i64;
      do
      {
        v17 = dword_446EEC[v16];
        v18 = v15;
        if ( v17 >= v14 )
        {
          if ( dword_446EE8[v16] >= v15 )
            break;
          v14 = v17 + 1;
          v15 = v13 + v17 + 1;
          v18 = v15;
        }
        v16 += 6i64;
      }
      while ( 2 * (3i64 * (unsigned int)(dword_446EE0 - 1) + 3) != v16 );
    }
    v6 = (__int64)v14 << 16;
    if ( v18 > 0x20000000 )
      return sub_402B8A();
  }
  v19 = sub_40F880(a1 | 0x10, a2, a3, a4);
  v21 = v19;
  if ( (LPVOID)v6 != v19 || v19 == (LPVOID)-1i64 )
    return -1i64;
  if ( (unsigned int)sub_40FBB0(v20, (unsigned __int64)(v6 + v10 - 1) >> 16, a2) == -1 )
    JUMPOUT(0x402A3Di64);
  return (__int64)v21;
}
// 40F384: control flows out of bounds to 402A42
// 40F518: control flows out of bounds to 402A3D
// 40F4DB: ignored the value written to the shadow area of the succeeding call
// 40F384: variable 'v5' is possibly undefined
// 40F38D: variable 'v4' is possibly undefined
// 40F4E4: variable 'v24' is possibly undefined
// 40F510: variable 'v20' is possibly undefined
// 4408C8: using guessed type __int64 qword_4408C8;
// 446EE0: using guessed type int dword_446EE0;
// 446EE8: using guessed type int dword_446EE8[];
// 446EEC: using guessed type int dword_446EEC[];

//----- (000000000040F550) ----------------------------------------------------
// attributes: thunk
__int64 sub_40F550()
{
  return sub_402B9F();
}

//----- (000000000040F560) ----------------------------------------------------
__int64 __fastcall sub_40F560()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  __int64 result; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx

  if ( (_WORD)v0 || (unsigned __int64)(v0 + 0x800000000000i64) > 0xFFFFFFFFFFFFi64 || !v1 )
    return sub_402B21();
  result = sub_40F830();
  if ( (_DWORD)result != -1 )
  {
    result = 0i64;
    if ( (dword_41C718 & 4) == 0 )
      return sub_412390(v4, v3);
  }
  return result;
}
// 40F56B: variable 'v0' is possibly undefined
// 40F597: variable 'v1' is possibly undefined
// 40F5DB: variable 'v4' is possibly undefined
// 40F5DB: variable 'v3' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (000000000040F5E0) ----------------------------------------------------
__int64 __fastcall sub_40F5E0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // edx
  __int64 v3; // rcx
  __int64 v4; // r12
  __int64 v5; // rax
  __int64 v6; // r12
  __int64 v7; // rdx
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rsi
  __int64 v11; // rdi
  unsigned int v12; // er13
  unsigned int v13; // ebx
  __int64 v14; // rax
  __int64 v15; // r14
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // [rsp+8h] [rbp-28h]
  __int64 v20; // [rsp+8h] [rbp-28h]
  _QWORD *v21; // [rsp+8h] [rbp-28h]
  __int64 v22; // [rsp+8h] [rbp-28h]
  __int64 v23; // [rsp+8h] [rbp-28h]
  __int64 v24; // [rsp+8h] [rbp-28h]

  if ( v1
    && (sub_40F340(), sub_40F900(v3, v2))
    && (v4 = v19, v5 = sub_40FDD0(a1), (*(_QWORD *)(v4 + 56) = v5) != 0i64)
    && (v6 = sub_40FE50(a1, (unsigned __int64 *)(v20 + 32))) != 0
    && (v7 = v21[4], v21[3] = 0x200000i64, (unsigned __int64)(8 * v7 + 64) <= 0x1FFFFF) )
  {
    sub_40FEF0((__int64)(v21 + 6), v21 + 5);
    v10 = v23;
    v11 = *(_QWORD *)(v23 + 32);
    if ( v11 )
    {
      v12 = 0;
      v13 = 0;
      v14 = 0i64;
      do
      {
        v15 = v6 + 24 * v14;
        if ( sub_40FFC0() )
        {
          v10 = v24;
          v16 = *(_QWORD *)(v15 + 8);
          v17 = *(_QWORD *)(v24 + 40);
          if ( v16 >= v17 && v16 <= *(_QWORD *)(v24 + 48) )
          {
            v18 = v12++;
            v9 = v24 + 8 * v18;
            *(_DWORD *)(v9 + 64) = v16 - v17;
            *(_DWORD *)(v9 + 68) = *(_DWORD *)v15;
          }
        }
        else
        {
          v10 = v24;
        }
        v14 = ++v13;
      }
      while ( (unsigned __int64)v13 < *(_QWORD *)(v10 + 32) );
      v11 = v12;
    }
    *(_QWORD *)(v10 + 32) = v11;
    sub_402350(v9);
  }
  else
  {
    sub_40ED90(a1);
  }
  result = v22;
  if ( v22 == -1 )
    return 0i64;
  return result;
}
// 40F613: ignored the value written to the shadow area of the succeeding call
// 40F5FA: variable 'v1' is possibly undefined
// 40F617: variable 'v3' is possibly undefined
// 40F617: variable 'v2' is possibly undefined
// 40F621: variable 'v19' is possibly undefined
// 40F62F: variable 'a1' is possibly undefined
// 40F64A: variable 'v20' is possibly undefined
// 40F65F: variable 'v21' is possibly undefined
// 40F689: variable 'v22' is possibly undefined
// 40F6C5: variable 'v23' is possibly undefined
// 40F6E0: variable 'v24' is possibly undefined
// 40F743: variable 'v9' is possibly undefined

//----- (000000000040F750) ----------------------------------------------------
__int64 __fastcall sub_40F750()
{
  _BYTE *v0; // rdi
  __int64 v1; // rax
  _QWORD *v2; // rbx
  __int64 v3; // r15
  __int64 v4; // rcx
  char *v5; // r14
  __int64 v6; // r12
  int v7; // er8
  _QWORD *v8; // rax
  _QWORD *v10; // [rsp+8h] [rbp-38h]

  if ( !v0 )
    return sub_402B21();
  if ( !*v0 )
    return sub_402B21();
  sub_41576B();
  if ( v1 )
    return sub_402B21();
  v2 = (_QWORD *)qword_448018;
  if ( qword_448018 )
  {
    v3 = 0i64;
    v5 = sub_41571A();
    while ( 1 )
    {
      v6 = *v2;
      v10 = v2;
      if ( *v2 )
      {
        while ( 1 )
        {
          v7 = sub_414C00(v4, (__int64)v5);
          v8 = v2 + 1;
          if ( !v7 && v5[v6] == 61 )
            break;
          if ( v3 )
            goto LABEL_13;
          v6 = *v8;
          if ( !*v8 )
            return 0i64;
          ++v2;
        }
        --v3;
      }
      else
      {
        if ( !v3 )
          return 0i64;
LABEL_13:
        v10[v3] = v6;
        if ( !*v2 )
          return 0i64;
        v8 = v2 + 1;
      }
      v2 = v8;
    }
  }
  return 0i64;
}
// 40F764: variable 'v0' is possibly undefined
// 40F783: variable 'v1' is possibly undefined
// 40F7BD: variable 'v4' is possibly undefined
// 40F7F9: variable 'v10' is possibly undefined
// 40F750: using guessed type __int64 __fastcall sub_40F750();
// 448018: using guessed type __int64 qword_448018;

//----- (000000000040F830) ----------------------------------------------------
__int64 __fastcall sub_40F830()
{
  __int64 v0; // rdi
  __int64 v1; // rsi

  return sub_40F9A0((__int64)sub_40FD50, (unsigned __int64)(v0 + v1 - 1) >> 16);
}
// 40F830: variable 'v0' is possibly undefined
// 40F830: variable 'v1' is possibly undefined

//----- (000000000040F84E) ----------------------------------------------------
void __fastcall __noreturn sub_40F84E(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  void (__fastcall *v4)(__int64, __int64); // rsi

  v4(a4, a3);
  BUG();
}
// 40F863: variable 'v4' is possibly undefined

//----- (000000000040F867) ----------------------------------------------------
__int64 (*__fastcall sub_40F867(__int64 a1, __int64 a2, __int64 a3, __int64 a4))(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))sub_40B701;
  if ( sub_40B701 )
    return (__int64 (*)(void))sub_40B701(a1, a2, a3, a4);
  return result;
}
// 40B701: using guessed type __int64 __fastcall sub_40B701(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000040F880) ----------------------------------------------------
LPVOID __fastcall sub_40F880(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  if ( (dword_41C718 & 4) != 0 )
    return sub_404670(a1, a2, a3, a4);
  else
    return (LPVOID)sub_4100AE(a1, a2);
}
// 40F890: ignored the value written to the shadow area of the succeeding call
// 41C718: using guessed type int dword_41C718;

//----- (000000000040F8B0) ----------------------------------------------------
__int64 __fastcall sub_40F8B0()
{
  unsigned int *v0; // rdi
  signed int v1; // esi
  unsigned int v2; // edx
  unsigned int v3; // er8

  v2 = *v0;
  v3 = 0;
  while ( v2 > v3 )
  {
    if ( (int)v0[6 * ((v2 + v3) >> 1) + 2] < v1 )
      v3 = ((v2 + v3) >> 1) + 1;
    else
      v2 = (v2 + v3) >> 1;
  }
  if ( v3 && (int)v0[6 * v3 - 3] >= v1 )
    --v3;
  return v3;
}
// 40F8B0: variable 'v0' is possibly undefined
// 40F8D0: variable 'v1' is possibly undefined

//----- (000000000040F900) ----------------------------------------------------
__int64 __fastcall sub_40F900(__int64 a1, unsigned int a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdx
  __int64 v4; // rcx

  if ( (unsigned int)sub_40EFB0(a1, a2) != -1 && sub_40FFA0() )
    return *(_QWORD *)(v2 + 8);
  sub_40EF50(v4, v3);
  return 0i64;
}
// 40F92A: variable 'v2' is possibly undefined
// 40F943: variable 'v4' is possibly undefined
// 40F943: variable 'v3' is possibly undefined

//----- (000000000040F960) ----------------------------------------------------
void __fastcall sub_40F960(__int64 a1, int a2)
{
  int *v2; // rdi
  int v3; // esi
  _DWORD *v4; // rax
  int v5; // er8

  sub_4154C0(*v2 - (v3 + (__int64)a2), 24 * (*v2 - (v3 + (__int64)a2)));
  *v4 -= v5;
}
// 40F983: variable 'v2' is possibly undefined
// 40F963: variable 'v3' is possibly undefined
// 40F996: variable 'v4' is possibly undefined
// 40F996: variable 'v5' is possibly undefined

//----- (000000000040F9A0) ----------------------------------------------------
__int64 __fastcall sub_40F9A0(__int64 a1, int a2)
{
  _DWORD *v2; // rdi
  int v3; // esi
  int v4; // er15
  _DWORD *v5; // r12
  unsigned int v7; // eax
  unsigned int v8; // er13
  unsigned int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // rdx
  _DWORD *v12; // rdi
  __int64 v14; // rdx
  __int64 v15; // rax
  int v16; // [rsp+4h] [rbp-3Ch]
  void (__fastcall *v17)(__int64, _QWORD); // [rsp+8h] [rbp-38h]
  unsigned int v18; // [rsp+8h] [rbp-38h]

  v4 = *v2;
  if ( !*v2 )
    return 0i64;
  v5 = v2;
  v7 = sub_40F8B0();
  v8 = v7;
  if ( v4 == v7 )
    return 0i64;
  if ( v7 )
  {
    if ( v2[6 * v7 + 2] > a2 )
      return 0i64;
  }
  else if ( v2[2] > a2 )
  {
    return 0i64;
  }
  v9 = sub_40F8B0();
  v10 = (unsigned int)v16;
  if ( v4 == v9 || (v11 = v9, v8 < v9) && v2[6 * v9 + 2] > a2 )
    v11 = --v9;
  v12 = &v2[6 * v11];
  if ( v9 != v8 )
  {
    if ( v3 <= v16 || (v14 = v8, v10 = 3i64 * v8, v3 > v5[6 * v8 + 3]) )
    {
LABEL_11:
      if ( a2 < v12[2] || v12[3] <= a2 )
      {
        if ( (dword_41C718 & 4) != 0 )
        {
          if ( v17 )
          {
            v17(v10, v9);
            v9 = v18;
          }
        }
LABEL_22:
        sub_40F960(v10, v9 + 1 - v8);
        return 0i64;
      }
      if ( (dword_41C718 & 4) == 0 )
        goto LABEL_14;
      return sub_402B21();
    }
LABEL_25:
    if ( (dword_41C718 & 4) == 0 )
    {
      ++v8;
      v5[6 * v14 + 3] = v3 - 1;
      if ( v12[2] > a2 || v12[3] <= a2 )
      {
LABEL_15:
        if ( v9 < v8 )
          return 0i64;
        goto LABEL_22;
      }
LABEL_14:
      --v9;
      v12[2] = a2 + 1;
      goto LABEL_15;
    }
    return sub_402B21();
  }
  if ( v3 <= v16 )
    goto LABEL_11;
  v14 = v8;
  v10 = (unsigned int)v5[6 * v8 + 3];
  if ( (int)v10 <= a2 )
  {
    if ( (int)v10 < v3 )
      goto LABEL_11;
    goto LABEL_25;
  }
  if ( v4 != 128 )
  {
    sub_4155FC(v10, 24 * (v4 - (__int64)(int)v8));
    ++*v5;
    *(_DWORD *)(v15 + 12) = v3 - 1;
    *(_DWORD *)(v15 + 32) = a2 + 1;
    return 0i64;
  }
  return sub_402B8A();
}
// 40F9F0: ignored the value written to the shadow area of the succeeding call
// 40FAA2: ignored the value written to the shadow area of the succeeding call
// 40F9B1: variable 'v2' is possibly undefined
// 40F9F8: variable 'v16' is possibly undefined
// 40FA2F: variable 'v3' is possibly undefined
// 40FAA0: variable 'v17' is possibly undefined
// 40FAAF: variable 'v18' is possibly undefined
// 40FABE: variable 'v10' is possibly undefined
// 40FB96: variable 'v15' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (000000000040FBB0) ----------------------------------------------------
__int64 __fastcall sub_40FBB0(__int64 a1, int a2, int a3)
{
  int *v3; // rdi
  int v4; // esi
  int v8; // ebx
  unsigned int v9; // eax
  __int64 v10; // rdx
  int *v11; // rsi
  unsigned int v12; // er8
  __int64 v13; // rax
  int *v15; // rcx
  __int64 v16; // rcx
  int *v17; // rdx
  int v18; // [rsp+Ch] [rbp-34h]
  int v19; // [rsp+Ch] [rbp-34h]

  v8 = v4;
  v9 = sub_40F8B0();
  v10 = *v3;
  if ( v9 && (v11 = &v3[6 * v9 - 6], v11[3] + 1 == v8) && *((_QWORD *)v11 + 2) == a1 && v11[6] == a3 && v11[7] == v18 )
  {
    v11[3] = a2;
    v12 = 0;
    if ( v9 < (unsigned int)v10 )
    {
      v16 = (__int64)&v3[6 * v9];
      if ( a2 + 1 == *(_DWORD *)(v16 + 8) && *(_QWORD *)(v16 + 16) == a1 )
      {
        v17 = &v3[6 * v9];
        if ( v17[6] == a3 && v17[7] == v18 )
        {
          v11[3] = *(_DWORD *)(v16 + 12);
          sub_40F960(v16, 1);
          return 0;
        }
      }
    }
  }
  else if ( v9 < (unsigned int)v10
         && (v15 = &v3[6 * v9], a2 + 1 == v15[2])
         && *((_QWORD *)v15 + 2) == a1
         && v15[6] == a3
         && v15[7] == v18 )
  {
    v15[2] = v8;
    return 0;
  }
  else if ( (_DWORD)v10 == 128 )
  {
    return (unsigned int)sub_402B8A();
  }
  else
  {
    sub_4155FC(8 * (3i64 * (int)v9 + 3), 24 * (v10 - (int)v9));
    ++*v3;
    *(_DWORD *)(v13 + 8) = v8;
    *(_DWORD *)(v13 + 12) = a2;
    *(_QWORD *)(v13 + 16) = a1;
    *(_DWORD *)(v13 + 24) = a3;
    *(_DWORD *)(v13 + 28) = v19;
  }
  return v12;
}
// 40FBCF: ignored the value written to the shadow area of the succeeding call
// 40FBC9: variable 'v4' is possibly undefined
// 40FBD8: variable 'v3' is possibly undefined
// 40FC45: variable 'v13' is possibly undefined
// 40FC57: variable 'v19' is possibly undefined
// 40FC5E: variable 'v12' is possibly undefined
// 40FCA1: variable 'v18' is possibly undefined

//----- (000000000040FD50) ----------------------------------------------------
BOOL __fastcall sub_40FD50(__int64 a1, int a2)
{
  __int64 v2; // rdi
  int v3; // esi
  unsigned __int64 v4; // r12
  int *v5; // rbx
  __int64 v6; // rcx
  BOOL result; // eax

  if ( v3 <= a2 )
  {
    v4 = v2 + 24 * (v3 + (unsigned __int64)(unsigned int)(a2 - v3)) + 32;
    v5 = (int *)(v2 + 24i64 * v3 + 8);
    do
    {
      v6 = *v5;
      v5 += 6;
      UnmapViewOfFile((LPCVOID)(v6 << 16));
      result = sub_405EF5();
    }
    while ( v5 != (int *)v4 );
  }
  return result;
}
// 40FD52: variable 'v3' is possibly undefined
// 40FD6C: variable 'v2' is possibly undefined

//----- (000000000040FDD0) ----------------------------------------------------
__int64 __fastcall sub_40FDD0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned __int16 v2; // ax
  int v3; // ebx
  int v4; // er13
  __int64 v5; // rax

  v2 = *(_WORD *)(v1 + 60);
  if ( !v2 )
    return 0i64;
  v3 = v2 - 1;
  v4 = v2 - 2 - (unsigned __int16)(v2 - 1);
  while ( 1 )
  {
    if ( v3 != *(unsigned __int16 *)(v1 + 62) )
    {
      v5 = sub_410010(a1, v3);
      if ( *(_DWORD *)(v5 + 4) == 3 )
        break;
    }
    if ( --v3 == v4 )
      return 0i64;
  }
  return sub_40FFE0(a1, v5);
}
// 40FDD0: variable 'v1' is possibly undefined
// 40FE12: variable 'a1' is possibly undefined

//----- (000000000040FE50) ----------------------------------------------------
__int64 __fastcall sub_40FE50(__int64 a1, unsigned __int64 *a2)
{
  __int64 v2; // rdi
  __int16 v3; // bx
  int v5; // ebx
  __int64 v6; // rax

  v3 = *(_WORD *)(v2 + 60);
  if ( !v3 )
    return 0i64;
  v5 = (unsigned __int16)(v3 - 1);
  while ( 1 )
  {
    v6 = sub_410010(a1, v5);
    if ( *(_DWORD *)(v6 + 4) == 2 && *(_QWORD *)(v6 + 56) == 24i64 )
      break;
    if ( --v5 == -1 )
      return 0i64;
  }
  if ( a2 )
    *a2 = *(_QWORD *)(v6 + 32) / 0x18ui64;
  return sub_40FFE0(a1, v6);
}
// 40FE5B: variable 'v2' is possibly undefined
// 40FE88: variable 'a1' is possibly undefined

//----- (000000000040FEF0) ----------------------------------------------------
_QWORD *__fastcall sub_40FEF0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  unsigned int v4; // er14
  __int64 v5; // r12
  __int64 v6; // rax
  __int64 v7; // rcx
  _QWORD *result; // rax
  _QWORD *v9; // [rsp+0h] [rbp-40h]
  __int64 *v10; // [rsp+8h] [rbp-38h]

  v10 = a2;
  v9 = (_QWORD *)a1;
  if ( *(_WORD *)(v2 + 56) )
  {
    v3 = 0i64;
    v4 = 0;
    v5 = 0x7FFFFFFFFFFFFFFFi64;
    do
    {
      v6 = sub_410050(a1, v4);
      if ( *(_DWORD *)v6 == 1 )
      {
        v7 = *(_QWORD *)(v6 + 16);
        if ( v5 > v7 )
          v5 = *(_QWORD *)(v6 + 16);
        a1 = *(_QWORD *)(v6 + 40) + v7;
        if ( v3 < a1 )
          v3 = a1;
      }
      ++v4;
    }
    while ( *(unsigned __int16 *)(v2 + 56) > v4 );
  }
  else
  {
    v5 = 0x7FFFFFFFFFFFFFFFi64;
    v3 = 0i64;
  }
  if ( v10 )
    *v10 = v5;
  result = v9;
  if ( v9 )
    *v9 = v3;
  return result;
}
// 40FF01: variable 'v2' is possibly undefined
// 40FF39: variable 'a1' is possibly undefined
// 40FF6E: variable 'v10' is possibly undefined
// 40FF73: variable 'v9' is possibly undefined

//----- (000000000040FFA0) ----------------------------------------------------
bool __fastcall sub_40FFA0()
{
  __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  bool result; // al

  result = 0;
  if ( v1 > 0x3F && *(_DWORD *)v0 == 1179403647 )
    return (*(_BYTE *)(v0 + 4) & 0xFD) == 0;
  return result;
}
// 40FFA6: variable 'v1' is possibly undefined
// 40FFA8: variable 'v0' is possibly undefined

//----- (000000000040FFC0) ----------------------------------------------------
bool __fastcall sub_40FFC0()
{
  __int64 v0; // rdi
  bool result; // al

  result = 0;
  if ( *(_QWORD *)(v0 + 16) )
    return (*(_BYTE *)(v0 + 4) & 0xFu) - 1 <= 1;
  return result;
}
// 40FFC2: variable 'v0' is possibly undefined

//----- (000000000040FFE0) ----------------------------------------------------
__int64 __fastcall sub_40FFE0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // r12

  v3 = v2 + *(_QWORD *)(a2 + 24);
  sub_410090(*(_QWORD *)(a2 + 32), v3);
  return v3;
}
// 40FFF2: variable 'v2' is possibly undefined

//----- (0000000000410010) ----------------------------------------------------
__int64 __fastcall sub_410010(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // r12

  v3 = *(unsigned __int16 *)(v2 + 58);
  v4 = v3 * a2 + v2 + *(_QWORD *)(v2 + 40);
  sub_410090(v3, v4);
  return v4;
}
// 41001D: variable 'v2' is possibly undefined

//----- (0000000000410050) ----------------------------------------------------
__int64 __fastcall sub_410050(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // r12

  v3 = *(unsigned __int16 *)(v2 + 54);
  v4 = v3 * a2 + v2 + *(_QWORD *)(v2 + 32);
  sub_410090(v3, v4);
  return v4;
}
// 41005C: variable 'v2' is possibly undefined

//----- (0000000000410090) ----------------------------------------------------
void __fastcall sub_410090(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi

  if ( v2 > a2 || a1 + a2 > (unsigned __int64)(v3 + v2) )
    sub_401114();
}
// 410097: variable 'v2' is possibly undefined
// 4100A0: variable 'v3' is possibly undefined

//----- (00000000004100AE) ----------------------------------------------------
__int64 __fastcall sub_4100AE(__int64 a1, __int64 a2)
{
  return sub_412300(a1, a2);
}
// 4100B2: ignored the value written to the shadow area of the succeeding call

//----- (00000000004100BB) ----------------------------------------------------
__int64 __fastcall sub_4100BB(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rdi
  __int64 result; // rax
  int v4; // edx

  result = sub_412310(a1, a2);
  if ( (dword_41C718 & 8) != 0 && (_DWORD)result != -1 )
  {
    *v2 = result;
    v2[1] = v4;
    return 0i64;
  }
  return result;
}
// 4100D4: variable 'v2' is possibly undefined
// 4100D6: variable 'v4' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (00000000004100E0) ----------------------------------------------------
__int64 __fastcall sub_4100E0(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // esi
  __int64 result; // rax
  __int64 v4; // rcx

  if ( !v1 )
    return sub_402AF7();
  if ( (dword_41C718 & 4) == 0 )
    return sub_412360(0i64, v2);
  result = sub_404D00(a1);
  if ( (_DWORD)result != -1 )
    return sub_404D10(v4);
  return result;
}
// 4100E3: variable 'v1' is possibly undefined
// 410119: variable 'v4' is possibly undefined
// 410130: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000410160) ----------------------------------------------------
__int64 __fastcall sub_410160(__int64 a1, __int64 a2)
{
  int v2; // edi
  __int64 v3; // rbx
  __int64 result; // rax
  int v5; // eax

  if ( v2 < 0 )
    return sub_402A84();
  v3 = v2;
  if ( v2 >= (unsigned __int64)qword_447B48 )
  {
    if ( (dword_41C718 & 4) != 0 )
    {
LABEL_4:
      result = sub_402ACD();
      goto LABEL_5;
    }
    goto LABEL_10;
  }
  v5 = *(_DWORD *)(qword_447B50 + 24i64 * v2 + 16);
  if ( v5 == 6 || v5 == 7 )
  {
    result = MEMORY[0]();
  }
  else
  {
    if ( (dword_41C718 & 4) == 0 )
    {
LABEL_10:
      result = sub_412330(a1, a2);
      goto LABEL_5;
    }
    if ( v5 == 2 )
    {
      result = sub_403090();
    }
    else
    {
      if ( (unsigned int)(v5 - 3) > 1 && v5 != 1 )
        goto LABEL_4;
      result = sub_404ED0();
    }
  }
LABEL_5:
  if ( v2 < (unsigned __int64)qword_447B48 )
  {
    if ( qword_447B40 <= (unsigned __int64)v2 )
      v3 = qword_447B40;
    *(_DWORD *)(qword_447B50 + 24i64 * v2 + 16) = 0;
    qword_447B40 = v3;
  }
  return result;
}
// 410162: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 447B40: using guessed type __int64 qword_447B40;
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000410260) ----------------------------------------------------
__int64 __fastcall sub_410260()
{
  int v0; // edi
  unsigned int v1; // ebx
  __int64 v2; // rcx

  v1 = (unsigned int)sub_414AB0() - v0;
  if ( !sub_410C20(v2) )
    return (unsigned int)-1;
  return v1;
}
// 41027C: variable 'v0' is possibly undefined
// 41027F: variable 'v2' is possibly undefined

//----- (00000000004102A0) ----------------------------------------------------
__int64 __fastcall sub_4102A0(unsigned __int64 a1)
{
  __int64 v1; // rdi
  __int64 v3; // r13
  char *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  _BYTE *v8; // rdi
  __int64 v9; // rax
  __int64 result; // rax

  v3 = v1;
  v4 = sub_41571A();
  if ( (unsigned __int64)&v4[a1 + 7] > 0xF8 )
    return 0xFFFFFFFFi64;
  sub_4154C0(v5, (unsigned __int64)v4);
  v8 = (_BYTE *)(v1 + v6);
  if ( v6 && *(_BYTE *)(v3 + v6 - 1) != 47 )
    *v8 = 47;
  sub_4154C0(v7, a1);
  sub_4026E0();
  sub_415783();
  if ( v9 )
    return sub_410260();
  result = sub_410260();
  if ( (_DWORD)result == -1 )
    return sub_410260();
  return result;
}
// 4102AE: variable 'v1' is possibly undefined
// 4102D7: variable 'v5' is possibly undefined
// 4102DC: variable 'v6' is possibly undefined
// 4102F0: variable 'v7' is possibly undefined
// 410313: variable 'v9' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000410390) ----------------------------------------------------
__int64 __fastcall sub_410390()
{
  __int64 v0; // rsi
  char *v1; // rax
  unsigned __int64 v2; // r13
  __int64 v3; // rax
  __int64 v4; // r15
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  int v9; // [rsp+Ch] [rbp-144h]

  v1 = sub_41571A();
  if ( !v1 )
  {
    v4 = 0i64;
    sub_402B75();
    return v4;
  }
  v2 = (unsigned __int64)v1;
  sub_415783();
  v4 = v3;
  if ( v3 )
  {
    sub_402B21();
    return 0i64;
  }
  if ( (dword_41C718 & 4) != 0 && ((unsigned int)sub_4102A0(v2) != -1 || (unsigned int)sub_4102A0(v2) != -1)
    || (unsigned int)sub_4102A0(v2) != -1 )
  {
    goto LABEL_5;
  }
  sub_414C50();
  if ( v6 )
    return v4;
  sub_4108B0();
  sub_4148F0(0xF8ui64);
  if ( !v7 )
  {
    if ( (unsigned int)sub_402B8A() == -1 )
      return v4;
LABEL_5:
    v4 = v0;
    dword_448020 = v9;
    return v4;
  }
  while ( 1 )
  {
    v4 = sub_414CB0();
    if ( !v4 )
      return v4;
    sub_41576B();
    if ( !v8 && (unsigned int)sub_4102A0(v2) != -1 )
      goto LABEL_5;
  }
}
// 4103AA: ignored the value written to the shadow area of the succeeding call
// 4103D4: variable 'v3' is possibly undefined
// 41040B: variable 'v0' is possibly undefined
// 41040E: variable 'v9' is possibly undefined
// 410478: variable 'v6' is possibly undefined
// 4104B2: variable 'v7' is possibly undefined
// 410503: variable 'v8' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 448020: using guessed type int dword_448020;

//----- (0000000000410560) ----------------------------------------------------
bool __fastcall sub_410560(__int64 a1)
{
  int v1; // er8
  bool result; // al
  int v3; // eax
  int v4; // ebx

  if ( (dword_41C718 & 4) != 0 )
  {
    v1 = sub_404D00(a1);
    result = 1;
    if ( v1 == -1 )
      return result;
    v3 = sub_405F5B();
  }
  else
  {
    v4 = dword_448020;
    v3 = sub_4117E0(a1);
    if ( v3 == -1 && (dword_448020 == qword_440860 || dword_448020 == qword_440878) )
      dword_448020 = v4;
  }
  return v3 != -1;
}
// 41C718: using guessed type int dword_41C718;
// 440860: using guessed type __int64 qword_440860;
// 440878: using guessed type __int64 qword_440878;
// 448020: using guessed type int dword_448020;

//----- (0000000000410600) ----------------------------------------------------
__int64 __fastcall sub_410600()
{
  char v0; // di
  int v1; // esi
  __int64 result; // rax

  result = (8 * v0) & 0x20 | (4 * v0) & 4 | (32 * v1) & 0x80000000 | v0 & 2 | (v1 >> 2) & 0x20000000;
  if ( (v1 & 2) != 0 && (v0 & 3) == 3 )
    return (unsigned int)result | 1;
  return result;
}
// 41062A: variable 'v0' is possibly undefined
// 410613: variable 'v1' is possibly undefined

//----- (0000000000410650) ----------------------------------------------------
__int64 sub_410650()
{
  __int64 result; // rax

  *(&qword_447B40 + 2) = (__int64)(&qword_447B40 + 3);
  qword_447B40 = 3i64;
  *(&qword_447B40 + 1) = 16i64;
  if ( (dword_41C718 & 2) != 0 )
  {
    *(&qword_447B40 + 3) = 1016i64;
    *(&qword_447B40 + 6) = 1016i64;
    *(&qword_447B40 + 9) = 1016i64;
    result = 5i64;
    *((_DWORD *)&qword_447B40 + 10) = 5;
    *((_DWORD *)&qword_447B40 + 16) = 5;
    *((_DWORD *)&qword_447B40 + 22) = 5;
  }
  else
  {
    *((_DWORD *)&qword_447B40 + 10) = 1;
    *((_DWORD *)&qword_447B40 + 16) = 1;
    *((_DWORD *)&qword_447B40 + 22) = 1;
    *(&qword_447B40 + 3) = (__int64)GetStdHandle(0xFFFFFFF6);
    *(&qword_447B40 + 6) = (__int64)GetStdHandle(0xFFFFFFF5);
    result = (__int64)GetStdHandle(0xFFFFFFF4);
    *(&qword_447B40 + 9) = result;
  }
  return result;
}
// 41C718: using guessed type int dword_41C718;
// 447B40: using guessed type __int64 qword_447B40;

//----- (00000000004106F0) ----------------------------------------------------
__int64 __fastcall sub_4106F0()
{
  __int64 v0; // rdi
  __int64 v1; // r8
  _QWORD *v3; // rsi
  __int64 v4; // r14
  unsigned int v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rbx
  __int64 *v8; // r15
  int v9; // [rsp-44h] [rbp-44h]
  __int64 v10; // [rsp-40h] [rbp-40h]

  v1 = 0i64;
  if ( v0 != -1 )
  {
    if ( (dword_41C718 & 4) == 0 )
    {
      v3 = (_QWORD *)qword_41C378;
      if ( !qword_41C378 )
        return v1;
      if ( (dword_41C718 & 8) != 0 )
      {
        v10 = qword_440788;
        if ( v0 )
        {
          if ( v0 == qword_440788 )
          {
            v4 = *(_QWORD *)qword_41C378;
            v5 = (unsigned int)sub_41571A();
            if ( !v4 )
              return qword_41C710;
          }
          else
          {
            v4 = *(_QWORD *)qword_41C378;
            v5 = (unsigned int)sub_41571A();
            if ( !v4 )
              return v1;
          }
          v7 = v5;
          v8 = v3 + 1;
          while ( (unsigned int)sub_414C00(v6, v7) || *(_BYTE *)(v4 + v7) != 61 )
          {
            v4 = *v8++;
            if ( !v4 )
              goto LABEL_4;
          }
          return v4 + (unsigned int)(v9 + 1);
        }
LABEL_4:
        v1 = 0i64;
        if ( v0 != v10 )
          return v1;
        return qword_41C710;
      }
      while ( *v3 )
      {
        if ( v0 == *v3 )
        {
          v1 = v3[1];
          if ( v1 )
            return v1;
          break;
        }
        v3 += 2;
      }
    }
    v10 = qword_440788;
    goto LABEL_4;
  }
  return 0i64;
}
// 4106F7: variable 'v0' is possibly undefined
// 41072D: variable 'v10' is possibly undefined
// 410737: variable 'v1' is possibly undefined
// 4107A5: variable 'v6' is possibly undefined
// 4107B8: variable 'v9' is possibly undefined
// 41C378: using guessed type __int64 qword_41C378;
// 41C710: using guessed type __int64 qword_41C710;
// 41C718: using guessed type int dword_41C718;
// 440788: using guessed type __int64 qword_440788;

//----- (0000000000410830) ----------------------------------------------------
__int64 __fastcall sub_410830(__int64 a1)
{
  __int64 result; // rax
  _DWORD *v2; // rdx
  char v3; // cl

  result = qword_447B40;
  if ( qword_447B40 >= (unsigned __int64)qword_447B48 )
    return sub_41088F(a1);
  v2 = (_DWORD *)(qword_447B50 + 24 * qword_447B40 + 16);
  v3 = 0;
  while ( *v2 )
  {
    ++result;
    v2 += 6;
    v3 = 1;
    if ( result == qword_447B48 )
    {
      qword_447B40 = qword_447B48;
      return sub_41088F(1i64);
    }
  }
  if ( v3 )
    qword_447B40 = result;
  return result;
}
// 447B40: using guessed type __int64 qword_447B40;
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (000000000041088F) ----------------------------------------------------
__int64 __fastcall sub_41088F(__int64 a1)
{
  return (int)sub_410960(a1);
}

//----- (00000000004108B0) ----------------------------------------------------
_BYTE *__fastcall sub_4108B0()
{
  char *v0; // rdi
  _BYTE *v1; // r8
  _QWORD *i; // rcx
  char v3; // dl
  __int64 v4; // rax
  _BYTE *v6; // rdx

  if ( qword_448018 )
  {
    v1 = *(_BYTE **)qword_448018;
    if ( !*(_QWORD *)qword_448018 )
      return v1;
    for ( i = (_QWORD *)(qword_448018 + 8); ; ++i )
    {
      if ( *v0 )
      {
        v3 = *v0;
        v4 = 0i64;
        while ( v1[v4] == v3 )
        {
          v3 = v0[++v4];
          if ( !v3 )
          {
            v6 = &v1[v4];
            goto LABEL_11;
          }
        }
      }
      else
      {
        v6 = v1;
        v4 = 0i64;
LABEL_11:
        if ( *v6 == 61 )
          return &v1[v4 + 1];
      }
      v1 = (_BYTE *)*i;
      if ( !v1 )
        return v1;
    }
  }
  return 0i64;
}
// 4108C4: variable 'v0' is possibly undefined
// 448018: using guessed type __int64 qword_448018;

//----- (0000000000410930) ----------------------------------------------------
__int64 sub_410930()
{
  bool v0; // zf
  __int64 result; // rax
  __int64 v2; // [rsp+30h] [rbp-B0h]

  v0 = (unsigned int)sub_411DA0() == -1;
  result = -1i64;
  if ( !v0 )
    return v2;
  return result;
}
// 410951: variable 'v2' is possibly undefined

//----- (0000000000410960) ----------------------------------------------------
__int64 __fastcall sub_410960(__int64 a1)
{
  unsigned int v1; // edi
  __int64 result; // rax
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // r12
  __int64 v5; // rax
  _DWORD *v6; // rdx

  result = v1;
  v3 = qword_447B48;
  if ( (int)v1 >= (unsigned __int64)qword_447B48 )
  {
    if ( sub_40B70D )
    {
      v4 = (int)(v1 + 1);
      if ( 2 * qword_447B48 >= v4 )
        v4 = 2 * qword_447B48;
      v5 = sub_40B70D(a1, 0i64);
      if ( v5 )
      {
        v6 = (_DWORD *)(v5 + 24 * v3 + 16);
        do
        {
          ++v3;
          *v6 = 0;
          v6 += 6;
        }
        while ( v4 > v3 );
        qword_447B48 = v4;
        qword_447B50 = v5;
        return v1;
      }
      else
      {
        return sub_402B8A();
      }
    }
    else
    {
      return sub_402B4B();
    }
  }
  return result;
}
// 410964: variable 'v1' is possibly undefined
// 40B70D: using guessed type __int64 __fastcall sub_40B70D(_QWORD, _QWORD);
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000410A20) ----------------------------------------------------
__int64 __fastcall sub_410A20(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rcx
  unsigned int v3; // [rsp+Ch] [rbp-64h]
  char v4[96]; // [rsp+10h] [rbp-60h] BYREF

  if ( (dword_41C718 & 4) != 0 )
    return sub_404F60();
  result = sub_412380(a1, (__int64)v4);
  if ( (_DWORD)result != -1 )
  {
    sub_411930(v2);
    return v3;
  }
  return result;
}
// 410A6F: ignored the value written to the shadow area of the succeeding call
// 410A72: variable 'v2' is possibly undefined
// 410A77: variable 'v3' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 410A20: using guessed type char var_60[96];

//----- (0000000000410A90) ----------------------------------------------------
__int64 __fastcall sub_410A90(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rcx

  if ( (dword_41C718 & 4) != 0 )
    return sub_405040(a1, a2);
  sub_411870(a1);
  return sub_412380(v3, v2);
}
// 410AC0: variable 'v3' is possibly undefined
// 410AC0: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000410AE0) ----------------------------------------------------
int __fastcall sub_410AE0(__int64 a1)
{
  __int64 v1; // rsi

  if ( (dword_41C718 & 4) != 0 )
    return sub_4051D0();
  else
    return sub_412380(a1, v1);
}
// 410AF3: variable 'v1' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000410B10) ----------------------------------------------------
__int64 __fastcall sub_410B10()
{
  char v0; // di
  unsigned int v1; // er12
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rcx
  char v8[1040]; // [rsp+0h] [rbp-410h]

  if ( !v0 && (sub_4108B0() || ((unsigned __int8)dword_41C00C ^ BYTE1(dword_41C014)) == 52) )
    return 0;
  v1 = dword_41C718 & 4;
  if ( (dword_41C718 & 4) == 0 )
  {
    if ( (dword_41C718 & 1) != 0 && (unsigned int)sub_4123B0(0i64, (unsigned int)qword_440938) != -1 )
    {
      v4 = sub_4123D0(v3, 1012i64);
      if ( v4 != -1 )
      {
        v8[v4] = 0;
        sub_414CF0();
        sub_41571A();
        v1 = sub_412450(v7);
      }
      sub_412330(v6, v5);
      return v1;
    }
    return 0;
  }
  return NtCurrentPeb()->BeingDebugged;
}
// 410B22: variable 'v0' is possibly undefined
// 410BC6: variable 'v3' is possibly undefined
// 410C02: variable 'v7' is possibly undefined
// 410C0D: variable 'v6' is possibly undefined
// 410C0D: variable 'v5' is possibly undefined
// 41C00C: using guessed type int dword_41C00C;
// 41C014: using guessed type int dword_41C014;
// 41C718: using guessed type int dword_41C718;
// 440938: using guessed type __int64 qword_440938;
// 410B10: using guessed type char var_410[1040];

//----- (0000000000410C20) ----------------------------------------------------
bool __fastcall sub_410C20(__int64 a1)
{
  int v1; // er8
  bool result; // al
  char v3; // [rsp+18h] [rbp-C8h]

  v1 = sub_4117E0(a1);
  result = 0;
  if ( !v1 )
    return (v3 & 0x49) != 0;
  return result;
}
// 410C41: variable 'v3' is possibly undefined

//----- (0000000000410C50) ----------------------------------------------------
bool __fastcall sub_410C50()
{
  int v0; // edi
  int v1; // esi
  bool result; // al

  result = 0;
  if ( v0 >= 0 && v0 < (unsigned __int64)qword_447B48 )
    return *(_DWORD *)(qword_447B50 + 24i64 * v0 + 16) == v1;
  return result;
}
// 410C54: variable 'v0' is possibly undefined
// 410C74: variable 'v1' is possibly undefined
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000410C80) ----------------------------------------------------
unsigned __int64 __fastcall sub_410C80(__int64 a1, __int64 a2)
{
  double v2; // st7
  int i; // ebx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r13
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rcx
  unsigned __int64 v10; // rax
  double v11; // st7
  double v12; // st5
  unsigned __int64 result; // rax
  unsigned int v14; // edx
  double v15; // [rsp+0h] [rbp-50h]
  double v16; // [rsp+10h] [rbp-40h]

  v2 = 1.0;
  for ( i = 1; i != 5; ++i )
  {
    sub_411490(a1, a2);
    sub_411D70(v5, v4);
    v6 = __rdtsc();
    sub_411EA0(v7, v6);
    sub_411D70(v9, v8);
    v10 = __rdtsc();
    a2 = (unsigned __int64)HIDWORD(v10) << 32;
    v11 = (v2 - v16) * 1000000000.0;
    if ( v6 != v10 )
      v11 = v11 / (double)(v10 - v6);
    v12 = (double)i;
    v2 = (v11 - v15) / v12 + v15;
  }
  *(double *)&tbyte_447D40 = v2;
  sub_411D70(a1, a2);
  *(double *)&tbyte_447D30 = v2;
  result = __rdtsc();
  v14 = HIDWORD(result);
  result = (unsigned int)result;
  byte_447D20 = 1;
  qword_447D28 = (unsigned int)result | ((unsigned __int64)v14 << 32);
  return result;
}
// 410C9B: ignored the value written to the shadow area of the succeeding call
// 410CAB: ignored the value written to the shadow area of the succeeding call
// 410C9E: variable 'a1' is possibly undefined
// 410CA6: variable 'v5' is possibly undefined
// 410CA6: variable 'v4' is possibly undefined
// 410CD0: variable 'v7' is possibly undefined
// 410CD8: variable 'v9' is possibly undefined
// 410CD8: variable 'v8' is possibly undefined
// 410CEC: variable 'v16' is possibly undefined
// 410D07: variable 'v15' is possibly undefined
// 447D20: using guessed type char byte_447D20;
// 447D28: using guessed type __int64 qword_447D28;
// 447D30: using guessed type _TBYTE tbyte_447D30;
// 447D40: using guessed type _TBYTE tbyte_447D40;

//----- (0000000000410D60) ----------------------------------------------------
void __fastcall sub_410D60(__int64 a1, __int64 a2)
{
  if ( !byte_447D20 )
    sub_410C80(a1, a2);
}
// 447D20: using guessed type char byte_447D20;
// 447D40: using guessed type _TBYTE tbyte_447D40;

//----- (0000000000410DB0) ----------------------------------------------------
void __fastcall sub_410DB0(__int64 a1, __int64 a2)
{
  if ( !byte_447D20 )
    sub_410C80(a1, a2);
}
// 447D20: using guessed type char byte_447D20;
// 447D40: using guessed type _TBYTE tbyte_447D40;

//----- (0000000000410E10) ----------------------------------------------------
void __fastcall sub_410E10(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx

  if ( !byte_447D20 )
    sub_410C80(a1, a2);
  v2 = __rdtsc();
  if ( !byte_447D20 )
    sub_410C80(a1, v2);
}
// 410E70: ignored the value written to the shadow area of the succeeding call
// 410E73: variable 'a1' is possibly undefined
// 447D20: using guessed type char byte_447D20;
// 447D28: using guessed type __int64 qword_447D28;
// 447D30: using guessed type _TBYTE tbyte_447D30;
// 447D40: using guessed type _TBYTE tbyte_447D40;

//----- (0000000000410E90) ----------------------------------------------------
__int64 __fastcall sub_410E90(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdi
  unsigned int v3; // esi

  if ( !v2 )
    return sub_402AF7();
  if ( (dword_41C718 & 4) != 0 )
    return sub_405500(a1);
  return sub_4123B0(a2, v3);
}
// 410EC1: variable 'v2' is possibly undefined
// 410F1A: variable 'v3' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000410F70) ----------------------------------------------------
__int64 __fastcall sub_410F70(__int64 a1)
{
  return sub_411370(a1, 1i64);
}
// 410F80: ignored the value written to the shadow area of the succeeding call
// 410F78: ignored the value written to the shadow area of the succeeding call

//----- (0000000000410F90) ----------------------------------------------------
__int64 __fastcall sub_410F90(__int64 a1, unsigned __int64 a2)
{
  _BYTE *v2; // rsi
  __int64 result; // rax
  __int64 v5; // rcx
  int v6; // eax
  unsigned __int64 v7; // r8
  __int64 v8; // r14
  int v9; // er15
  __int64 v10; // rcx
  unsigned __int8 v11; // dl
  __int64 v12; // r15
  __int64 v13; // r14
  __int64 v14; // rcx
  int v15; // edx
  __int64 v16; // rax
  __int64 v17; // r14
  unsigned __int64 v18; // rcx
  int v19; // er14
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // r15
  __int64 v23; // r14
  _BYTE *v24; // r14
  __int64 v25; // [rsp+0h] [rbp-50h]
  unsigned __int64 v26; // [rsp+8h] [rbp-48h]
  __int64 v27; // [rsp+8h] [rbp-48h]
  int v28; // [rsp+8h] [rbp-48h]
  char v29; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v30; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v31; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v32; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v33; // [rsp+1Fh] [rbp-31h]
  char v34; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v35; // [rsp+1Fh] [rbp-31h]
  unsigned __int8 v36; // [rsp+1Fh] [rbp-31h]
  char v37; // [rsp+1Fh] [rbp-31h]
  char v38; // [rsp+1Fh] [rbp-31h]
  char v39; // [rsp+1Fh] [rbp-31h]

  if ( !a2 )
    return sub_402B8A();
  *v2 = 0;
  if ( a2 <= 2 )
    return sub_402B8A();
  if ( sub_410F70(a1) != 1 )
    return -1i64;
  LOBYTE(v6) = v29;
  v2[1] = 0;
  v7 = a2 - 2;
  v8 = 1i64;
  *v2 = v29;
  while ( 1 )
  {
    v9 = v8;
    if ( (v6 & 0x80u) == 0 )
      break;
    v18 = v8 + 2;
    if ( (unsigned __int8)v6 > 0xBFu )
    {
      if ( (unsigned __int8)v6 > 0xFBu )
      {
        if ( a2 <= v18 )
          return sub_402B8A();
        if ( sub_410F70(v18) == 1 )
        {
          v2[(int)v8] = v38;
          v24 = &v2[(int)v8 + 1];
          *v24 = 0;
          if ( a2 <= v9 + 3 )
            return sub_402B8A();
          if ( sub_410F70(v27) == 1 )
          {
            v20 = v25;
            v22 = v28;
            *v24 = v39;
            v19 = 4;
            v2[v25] = 0;
LABEL_31:
            v23 = v22 + (unsigned int)(v19 - 1);
            while ( 1 )
            {
              result = (int)v22;
              if ( v23 == v22 )
                break;
              if ( a2 <= v22 + 2 )
                return sub_402B8A();
              ++v22;
              if ( sub_410F70(v20) != 1 )
                return -1i64;
              *(_WORD *)&v2[v22 - 1] = v35;
            }
            return result;
          }
        }
      }
      else
      {
        _BitScanReverse((unsigned int *)&v6, (unsigned __int8)~(_BYTE)v6);
        v19 = 6 - v6;
        if ( a2 <= v18 )
          return sub_402B8A();
        if ( sub_410F70(v18) == 1 )
        {
          v21 = v9;
          v22 = v9 + 1;
          v2[v21] = v34;
          v2[v22] = 0;
          goto LABEL_31;
        }
      }
      return -1i64;
    }
    if ( v7 == v8 )
      return sub_402B8A();
    ++v8;
    if ( sub_410F70(v18) != 1 )
      return -1i64;
    LOBYTE(v6) = v36;
    v7 = v26;
    *(_WORD *)&v2[v8 - 1] = v36;
  }
  if ( (_BYTE)v6 != 27 )
    return (int)v8;
  if ( a2 <= (int)v8 + 2 )
    return sub_402B8A();
  if ( sub_410F70(v5) != 1 )
    return -1i64;
  v11 = v30;
  v12 = (int)v8 + 1;
  v2[(int)v8] = v30;
  v13 = (int)v12;
  v2[v12] = 0;
  if ( v30 > 0x4Fu )
  {
LABEL_17:
    if ( v11 != 91 )
      return (int)v13;
    if ( a2 <= (int)v13 + 2 )
      return sub_402B8A();
    if ( sub_410F70(v10) == 1 )
    {
      v15 = v32;
      v16 = (int)v13;
      v17 = (int)v13 + 1;
      v2[v16] = v32;
      v2[v17] = 0;
      while ( 1 )
      {
        result = (int)v17;
        if ( (unsigned int)(v15 - 48) > 0xF )
          break;
        if ( a2 <= v17 + 2 )
          return sub_402B8A();
        ++v17;
        if ( sub_410F70(v14) != 1 )
          return -1i64;
        v15 = v33;
        *(_WORD *)&v2[v17 - 1] = v33;
      }
      return result;
    }
    return -1i64;
  }
  while ( v11 <= 0x4Du )
  {
    if ( (unsigned __int8)(v11 - 32) > 0xFu )
      return (int)v13;
    if ( a2 <= v12 + 2 )
      return sub_402B8A();
    ++v12;
    if ( sub_410F70(v10) != 1 )
      return -1i64;
    v11 = v31;
    v13 = (int)v12;
    *(_WORD *)&v2[v12 - 1] = v31;
    if ( v31 > 0x4Fu )
      goto LABEL_17;
  }
  if ( a2 <= (int)v13 + 2 )
    return sub_402B8A();
  if ( sub_410F70(v10) != 1 )
    return -1i64;
  result = (int)v13 + 1;
  v2[v13] = v37;
  v2[result] = 0;
  return result;
}
// 41132C: ignored the value written to the shadow area of the succeeding call
// 411328: ignored the value written to the shadow area of the succeeding call
// 410FC0: variable 'v2' is possibly undefined
// 410FEA: variable 'v29' is possibly undefined
// 411029: variable 'v5' is possibly undefined
// 411038: variable 'v30' is possibly undefined
// 411088: variable 'v10' is possibly undefined
// 411097: variable 'v31' is possibly undefined
// 4110DC: variable 'v32' is possibly undefined
// 4110F8: variable 'v33' is possibly undefined
// 411132: variable 'v14' is possibly undefined
// 4111A7: variable 'v34' is possibly undefined
// 4111C9: variable 'v35' is possibly undefined
// 4111F7: variable 'v20' is possibly undefined
// 41123C: variable 'v36' is possibly undefined
// 411240: variable 'v26' is possibly undefined
// 41128C: variable 'v37' is possibly undefined
// 4112FB: variable 'v38' is possibly undefined
// 411330: variable 'v27' is possibly undefined
// 411343: variable 'v25' is possibly undefined
// 411347: variable 'v28' is possibly undefined
// 41134B: variable 'v39' is possibly undefined

//----- (0000000000411370) ----------------------------------------------------
__int64 __fastcall sub_411370(__int64 a1, __int64 a2)
{
  int v2; // edi
  int v4; // eax

  if ( v2 < 0 || (int)a2 < 0 )
    return (int)sub_402B21();
  if ( v2 >= (unsigned __int64)qword_447B48 )
  {
    if ( (dword_41C718 & 4) != 0 )
      return sub_402ACD();
    return sub_4123E0(a1, a2);
  }
  a1 = 3i64 * v2;
  v4 = *(_DWORD *)(qword_447B50 + 24i64 * v2 + 16);
  if ( v4 == 6 )
    JUMPOUT(0i64);
  if ( v4 == 5 )
    return sub_411EE0(a1, a2);
  if ( (dword_41C718 & 4) == 0 )
    return sub_4123E0(a1, a2);
  if ( v4 == 1 || v4 == 4 )
    return sub_4056C0(-1i64, (int)a2);
  if ( v4 != 2 )
    return sub_402ACD();
  return sub_402F50(0i64, (int)a2);
}
// 411413: control flows out of bounds to 0
// 411376: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000411440) ----------------------------------------------------
char __fastcall sub_411440()
{
  int v0; // edi
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = v0;
  LOBYTE(v2) = sub_411E70();
  if ( (_BYTE)v2 )
  {
    if ( qword_447B40 <= (unsigned __int64)v0 )
      v1 = qword_447B40;
    v2 = qword_447B50 + 24i64 * v0;
    *(_DWORD *)(v2 + 16) = 0;
    qword_447B40 = v1;
  }
  return v2;
}
// 411445: variable 'v0' is possibly undefined
// 447B40: using guessed type __int64 qword_447B40;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000411490) ----------------------------------------------------
__int64 __fastcall sub_411490(__int64 a1, __int64 a2)
{
  if ( (dword_41C718 & 4) != 0 )
    return sub_405790();
  else
    return qword_41C720(a1, a2);
}
// 41C718: using guessed type int dword_41C718;
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004114C0) ----------------------------------------------------
__int64 __fastcall sub_4114C0(__int64 a1, __int64 a2)
{
  int v2; // edi
  __int64 *v3; // rsi
  __int64 v5; // rax
  int v6; // er13
  int v7; // er15
  int v8; // eax
  int v9; // edx
  __int64 v10; // rcx
  __int64 result; // rax
  __int32 v12; // ecx
  __int64 v13; // rdx
  __m128i v14; // xmm3
  __int64 v15; // rdx
  __int64 v16; // rcx
  void (__fastcall __noreturn *v17)(__int64, __int64, __int64); // rax
  __int32 v18; // ecx
  __int64 v19; // rdx
  __m128i v20; // xmm4
  __m128i v21; // [rsp+0h] [rbp-70h] BYREF
  void (__fastcall __noreturn *v22)(__int64, __int64, __int64); // [rsp+10h] [rbp-60h]
  _BYTE v23[20]; // [rsp+18h] [rbp-58h] BYREF

  if ( (unsigned int)(v2 - 1) > 0x7E || v2 == 9 || v2 == qword_440980 )
    return sub_402B21();
  if ( v3 )
  {
    v5 = *v3;
    if ( *v3 > 7 )
    {
      if ( v5 <= 4194311 || v5 > 2151677950i64 )
        return sub_402AF7();
      LODWORD(v5) = v5 - 0x400000;
    }
    v6 = v5;
    if ( (dword_41C718 & 4) == 0 )
    {
      v7 = dword_41C718;
      sub_4154C0(a1, 0x30ui64);
      if ( (v8 & 8) != 0 )
      {
        *(_QWORD *)&v23[8] = 4266752i64;
        v22 = sub_411B00;
        if ( v8 != 16 )
        {
          if ( v8 <= 16 )
          {
            if ( v8 != 8 )
            {
LABEL_15:
              v10 = a2;
LABEL_16:
              result = sub_412420(v10, a2);
              if ( (_DWORD)result == -1 )
                return result;
              if ( !a2 )
              {
LABEL_28:
                if ( !v3 )
                  return result;
                goto LABEL_29;
              }
              if ( v7 == 16 )
              {
                v18 = *(_DWORD *)(a2 + 8);
                v19 = *(int *)(a2 + 12);
                v21 = 0i64;
                v21.m128i_i32[0] = v18;
                v20 = _mm_load_si128(&v21);
                *(_QWORD *)(a2 + 8) = v19;
                *(__m128i *)(a2 + 24) = v20;
              }
              else if ( v7 > 16 )
              {
                if ( v7 == 32 )
                {
                  v16 = *(unsigned int *)(a2 + 8);
                  *(__m128i *)(a2 + 24) = _mm_loadu_si128((const __m128i *)(a2 + 12));
                  *(_QWORD *)(a2 + 8) = v16;
                }
              }
              else if ( v7 == 1 )
              {
                v21 = (__m128i)*(unsigned __int64 *)(a2 + 24);
                *(__m128i *)(a2 + 24) = _mm_load_si128(&v21);
              }
              else if ( v7 == 8 )
              {
                v12 = *(_DWORD *)(a2 + 8);
                v13 = *(int *)(a2 + 12);
                v21 = 0i64;
                v21.m128i_i32[0] = v12;
                v14 = _mm_load_si128(&v21);
                *(_QWORD *)(a2 + 8) = v13;
                *(__m128i *)(a2 + 24) = v14;
              }
LABEL_25:
              v15 = dword_447D60[v2];
              if ( (int)v15 > 7 )
                v15 += 0x400000i64;
              *(_QWORD *)a2 = v15;
              goto LABEL_28;
            }
LABEL_14:
            v9 = *(_DWORD *)v23;
            v7 = 8;
            *(_QWORD *)v23 = *(_QWORD *)&v23[8];
            *(_DWORD *)&v23[12] = v9;
            *(_DWORD *)&v23[8] = *(_DWORD *)&v23[16];
            goto LABEL_15;
          }
          v17 = sub_411B00;
          if ( v7 != 32 )
            goto LABEL_15;
LABEL_50:
          v22 = v17;
          *(__m128i *)&v23[4] = _mm_loadu_si128((const __m128i *)&v23[16]);
          goto LABEL_43;
        }
LABEL_53:
        *(_DWORD *)&v23[4] = *(_DWORD *)v23;
        *(_DWORD *)v23 = *(_DWORD *)&v23[16];
        goto LABEL_43;
      }
      if ( (v8 & 1) != 0 && (qword_440988 & *(_QWORD *)v23) == 0 )
      {
        *(_QWORD *)&v23[8] = 4278224i64;
        *(_QWORD *)v23 |= qword_440988;
      }
      if ( v6 > 7 )
        v22 = (void (__fastcall __noreturn *)(__int64, __int64, __int64))sub_411D3D;
      if ( v8 == 16 )
        goto LABEL_53;
      if ( v8 > 16 )
      {
        if ( v8 != 32 )
          goto LABEL_43;
        v17 = v22;
        goto LABEL_50;
      }
      if ( v8 != 1 && v8 == 8 )
        goto LABEL_14;
LABEL_43:
      v10 = 8i64;
      goto LABEL_16;
    }
    result = 0i64;
    if ( !a2 )
    {
LABEL_29:
      dword_447D60[v2] = v6;
      return result;
    }
    goto LABEL_24;
  }
  v7 = dword_41C718;
  v6 = dword_41C718 & 4;
  if ( (dword_41C718 & 4) == 0 )
  {
    if ( (dword_41C718 & 8) != 0 )
      goto LABEL_15;
    goto LABEL_43;
  }
  v6 = 0;
  result = 0i64;
  if ( a2 )
  {
LABEL_24:
    result = 0i64;
    *(_OWORD *)a2 = 0i64;
    *(_OWORD *)(a2 + 16) = 0i64;
    *(_OWORD *)(a2 + 32) = 0i64;
    goto LABEL_25;
  }
  return result;
}
// 4114C1: variable 'v2' is possibly undefined
// 411502: variable 'v3' is possibly undefined
// 411556: variable 'v8' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 440980: using guessed type __int64 qword_440980;
// 440988: using guessed type __int64 qword_440988;
// 447D60: using guessed type int dword_447D60[128];

//----- (00000000004117E0) ----------------------------------------------------
__int64 __fastcall sub_4117E0(__int64 a1)
{
  __int64 v1; // rsi

  if ( (dword_41C718 & 4) != 0 )
    return sub_4057D0(a1);
  else
    return sub_411E40(0i64, v1);
}
// 41185E: variable 'v1' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000411870) ----------------------------------------------------
void __fastcall sub_411870(__int64 a1)
{
  __int64 v1; // rdi
  _DWORD *v2; // r8
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // rax
  unsigned int *v7; // r8
  __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rax

  if ( (dword_41C718 & 8) != 0 )
  {
    sub_41561F(a1, 0x48ui64);
    v8 = v1 + 32;
    *(_QWORD *)(v8 - 32) = *v7;
    *(_QWORD *)(v8 - 24) = v7[1];
    *(_QWORD *)(v8 - 16) = v7[2];
    v9 = v7[3];
    *(_QWORD *)(v8 - 8) = v9;
    sub_4154C0(v9, 0x14ui64);
    *(_QWORD *)(v11 + 56) = *(unsigned int *)(v10 + 48);
    *(_QWORD *)(v11 + 64) = *(unsigned int *)(v10 + 52);
  }
  else if ( (dword_41C718 & 0x30) != 0 )
  {
    sub_41561F(a1, 0x2Cui64);
    v3 = v1 + 16;
    *(_DWORD *)(v3 - 16) = *v2;
    *(_DWORD *)(v3 - 12) = v2[1];
    *(_DWORD *)(v3 - 8) = v2[2];
    *(_DWORD *)(v3 - 4) = v2[3];
    sub_4154C0(v4, 0x14ui64);
    *(_DWORD *)(v6 + 36) = *(_DWORD *)(v5 + 48);
    *(_DWORD *)(v6 + 40) = *(_DWORD *)(v5 + 52);
  }
}
// 411898: variable 'v1' is possibly undefined
// 411895: variable 'v2' is possibly undefined
// 4118BD: variable 'v4' is possibly undefined
// 4118C2: variable 'v5' is possibly undefined
// 4118C6: variable 'v6' is possibly undefined
// 4118E7: variable 'v7' is possibly undefined
// 411918: variable 'v10' is possibly undefined
// 41191C: variable 'v11' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000411930) ----------------------------------------------------
void __fastcall sub_411930(__int64 a1)
{
  __int64 v1; // rdi
  _QWORD *v2; // r8
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // rax
  _DWORD *v7; // r8
  __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rax

  if ( (dword_41C718 & 8) != 0 )
  {
    sub_41561F(a1, 0x38ui64);
    v3 = v1 + 16;
    *(_DWORD *)(v3 - 16) = *v2;
    *(_DWORD *)(v3 - 12) = v2[1];
    *(_DWORD *)(v3 - 8) = v2[2];
    *(_DWORD *)(v3 - 4) = v2[3];
    sub_4154C0(v4, 0x14ui64);
    *(_DWORD *)(v6 + 48) = *(_QWORD *)(v5 + 56);
    *(_DWORD *)(v6 + 52) = *(_QWORD *)(v5 + 64);
  }
  else if ( (dword_41C718 & 0x30) != 0 )
  {
    sub_41561F(a1, 0x38ui64);
    v8 = v1 + 16;
    *(_DWORD *)(v8 - 16) = *v7;
    *(_DWORD *)(v8 - 12) = v7[1];
    *(_DWORD *)(v8 - 8) = v7[2];
    *(_DWORD *)(v8 - 4) = v7[3];
    sub_4154C0(v9, 0x14ui64);
    *(_DWORD *)(v11 + 48) = *(_DWORD *)(v10 + 36);
    *(_DWORD *)(v11 + 52) = *(_DWORD *)(v10 + 40);
  }
  else
  {
    sub_4154C0(a1, 0x38ui64);
  }
}
// 411952: variable 'v1' is possibly undefined
// 41194F: variable 'v2' is possibly undefined
// 411977: variable 'v4' is possibly undefined
// 41197C: variable 'v5' is possibly undefined
// 411980: variable 'v6' is possibly undefined
// 41199F: variable 'v7' is possibly undefined
// 4119C7: variable 'v9' is possibly undefined
// 4119CC: variable 'v10' is possibly undefined
// 4119D0: variable 'v11' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (00000000004119F0) ----------------------------------------------------
__int64 __fastcall sub_4119F0(__int64 a1, __int64 a2)
{
  if ( (dword_41C718 & 4) != 0 )
    return sub_405870(0i64, a2);
  else
    return qword_41C720(0i64, a2);
}
// 41C718: using guessed type int dword_41C718;
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000411A10) ----------------------------------------------------
__int64 __fastcall sub_411A10(__int64 a1)
{
  return sub_411A30(a1, 1i64);
}
// 411A20: ignored the value written to the shadow area of the succeeding call
// 411A18: ignored the value written to the shadow area of the succeeding call

//----- (0000000000411A30) ----------------------------------------------------
__int64 __fastcall sub_411A30(__int64 a1, __int64 a2)
{
  int v2; // edi
  int v4; // eax

  if ( v2 < 0 || (int)a2 < 0 )
    return (int)sub_402B21();
  if ( v2 >= (unsigned __int64)qword_447B48 )
  {
    if ( (dword_41C718 & 4) != 0 )
      return sub_402ACD();
    return sub_412440(a1, a2);
  }
  a1 = 3i64 * v2;
  v4 = *(_DWORD *)(qword_447B50 + 24i64 * v2 + 16);
  if ( v4 == 6 )
    JUMPOUT(0i64);
  if ( v4 == 5 )
    return sub_411FA0(a1, a2);
  if ( (dword_41C718 & 4) == 0 )
    return sub_412440(a1, a2);
  if ( v4 == 1 || v4 == 4 )
    return sub_405AC0(-1i64, (int)a2);
  if ( v4 != 2 )
    return sub_402ACD();
  return sub_402FE0(0i64, (int)a2);
}
// 411AD3: control flows out of bounds to 0
// 411A36: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000411B00) ----------------------------------------------------
void __fastcall __noreturn sub_411B00(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rdx

  sub_41561F(a1, 0x438ui64);
  if ( a3 )
  {
    v4 = *(_QWORD *)(a3 + 48);
    if ( v4 )
    {
      v5 = *(_QWORD *)(a3 + 40);
      if ( v5 > 0xF && v5 > 0xB7 )
        sub_4154C0(*(unsigned int *)(v4 + 4), 0x40ui64);
      if ( *(_QWORD *)(a3 + 40) > 0x2C7ui64 )
        sub_4154C0(*(unsigned int *)(v4 + 208), 0x180ui64);
    }
  }
  while ( 1 )
  {
    sub_411D3D();
    __asm { syscall; Low latency system call }
  }
}
// 411C3D: ignored the value written to the shadow area of the succeeding call
// 411CA8: variable 'v4' is possibly undefined

//----- (0000000000411D3D) ----------------------------------------------------
__int64 __fastcall sub_411D3D()
{
  char v0; // di
  int v1; // eax

  v1 = dword_447D60[v0 & 0x7F];
  if ( v1 < 8 )
    return 0i64;
  ((void (*)(void))(unsigned int)(v1 + 0x400000))();
  return 1i64;
}
// 411D41: variable 'v0' is possibly undefined
// 447D60: using guessed type int dword_447D60[128];

//----- (0000000000411D70) ----------------------------------------------------
void __fastcall sub_411D70(__int64 a1, __int64 a2)
{
  sub_412010(a1, a2);
}

//----- (0000000000411DA0) ----------------------------------------------------
__int64 sub_411DA0()
{
  __int64 v0; // rdx
  __int64 v1; // rcx

  if ( sub_410C50() )
    JUMPOUT(0i64);
  if ( (dword_41C718 & 4) == 0 )
    return sub_402480(v1, v0);
  if ( sub_410C50() )
    return sub_405BC0();
  return sub_402ACD();
}
// 411E07: control flows out of bounds to 0
// 411E3B: variable 'v1' is possibly undefined
// 411E3B: variable 'v0' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000411E40) ----------------------------------------------------
__int64 __fastcall sub_411E40(__int64 a1, __int64 a2)
{
  unsigned int v2; // er12

  v2 = sub_4122E0(a1, a2);
  if ( v2 != -1 )
    sub_4024B0();
  return v2;
}

//----- (0000000000411E70) ----------------------------------------------------
bool __fastcall sub_411E70()
{
  int v0; // edi
  bool result; // al

  result = 0;
  if ( v0 >= 0 && v0 < (unsigned __int64)qword_447B48 )
    return *(_DWORD *)(qword_447B50 + 24i64 * v0 + 16) != 0;
  return result;
}
// 411E74: variable 'v0' is possibly undefined
// 447B48: using guessed type __int64 qword_447B48;
// 447B50: using guessed type __int64 qword_447B50;

//----- (0000000000411EA0) ----------------------------------------------------
__int64 __fastcall sub_411EA0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi

  if ( !v2 )
    return sub_402AF7();
  if ( (dword_41C718 & 4) != 0 )
    return sub_405D40();
  if ( (dword_41C718 & 8) != 0 )
    return sub_4120D0();
  return qword_41C720(a1, a2);
}
// 411EA3: variable 'v2' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000411EE0) ----------------------------------------------------
__int64 __fastcall sub_411EE0(__int64 a1, int a2)
{
  __int64 *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rcx
  unsigned __int8 v7; // al
  __int64 v8; // r9
  __int64 v9; // r8
  __int64 v10; // r10
  unsigned __int8 v11; // al
  unsigned __int8 v12; // al
  _QWORD *v13; // rdx

  v4 = a2;
  if ( a2 > 0 )
  {
    v5 = (_QWORD *)(v3 + 8);
    do
    {
      if ( *v5 )
      {
        while ( 1 )
        {
          v6 = *v2;
          v7 = __inbyte(*v2 + 5);
          if ( (v7 & 1) != 0 )
            break;
          _mm_pause();
        }
        v8 = 0i64;
        v9 = 0i64;
        v10 = 0i64;
        while ( 1 )
        {
          ++v8;
          v12 = __inbyte(v6);
          v13 = (_QWORD *)(v3 + 16 * v10);
          *(_BYTE *)(*v13 + v9++) = v12;
          if ( v13[1] == v9 )
          {
            if ( v4 == ++v10 )
              return v8;
            v9 = 0i64;
          }
          v6 = *v2;
          v11 = __inbyte(*v2 + 5);
          if ( (v11 & 1) == 0 )
            return v8;
        }
      }
      v5 += 2;
    }
    while ( v5 != (_QWORD *)(v3 + 16i64 * (unsigned int)(a2 - 1) + 24) );
  }
  return 0i64;
}
// 411EF3: variable 'v3' is possibly undefined
// 411F22: variable 'v2' is possibly undefined

//----- (0000000000411FA0) ----------------------------------------------------
__int64 __fastcall sub_411FA0(__int64 a1, int a2)
{
  __int64 *v2; // rdi
  _QWORD *v3; // rsi
  __int64 result; // rax
  _QWORD *v5; // r9
  __int64 v6; // rcx
  unsigned __int64 v7; // r8
  __int64 v8; // r10
  unsigned __int8 v9; // al

  result = a2;
  v5 = v3;
  if ( a2 )
  {
    result = 0i64;
    do
    {
      if ( v5[1] )
      {
        v6 = *v2;
        v7 = 0i64;
        v8 = result + 1;
        do
        {
          while ( 1 )
          {
            v9 = __inbyte(v6 + 5);
            if ( (v9 & 0x20) != 0 )
              break;
            _mm_pause();
            v6 = *v2;
          }
          __outbyte(v6, *(_BYTE *)(*v5 + v7));
          result = v8 + v7++;
        }
        while ( v5[1] > v7 );
      }
      v5 += 2;
    }
    while ( &v3[2 * a2] != v5 );
  }
  return result;
}
// 411FA3: variable 'v3' is possibly undefined
// 411FBF: variable 'v2' is possibly undefined

//----- (0000000000412010) ----------------------------------------------------
__int64 __fastcall sub_412010(__int64 a1, __int64 a2)
{
  unsigned __int64 *v2; // rsi
  __int64 result; // rax
  unsigned __int64 v4; // rdx

  if ( (dword_41C718 & 4) != 0 )
  {
    sub_405FC1();
    *v2 = sub_4124A0();
    result = 0i64;
    v2[1] = v4;
  }
  else if ( (dword_41C718 & 8) != 0 )
  {
    if ( v2 )
    {
      *v2 = 0i64;
      v2[1] = 0i64;
      result = sub_412114(a1);
      v2[1] *= 1000i64;
    }
    else
    {
      return sub_412114(a1);
    }
  }
  else
  {
    if ( v2 )
    {
      *v2 = 0i64;
      v2[1] = 0i64;
    }
    return sub_412320(a1, a2);
  }
  return result;
}
// 41202E: variable 'v2' is possibly undefined
// 4120A0: variable 'v4' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (00000000004120D0) ----------------------------------------------------
__int64 sub_4120D0()
{
  sub_41547A();
  return sub_412400(0i64, 0i64);
}
// 412104: ignored the value written to the shadow area of the succeeding call
// 4120EF: ignored the value written to the shadow area of the succeeding call

//----- (0000000000412114) ----------------------------------------------------
__int64 __fastcall sub_412114(__int64 a1)
{
  __int64 *v1; // rdi
  _QWORD *v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rdx

  if ( v2 )
    *v2 = 0i64;
  v3 = sub_4122F0(a1, 0i64);
  if ( (dword_41C718 & 8) != 0 && v1 && v3 )
  {
    *v1 = v3;
    v1[1] = v4;
  }
  return 0i64;
}
// 41211B: variable 'v2' is possibly undefined
// 412136: variable 'v1' is possibly undefined
// 412140: variable 'v4' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000412150) ----------------------------------------------------
__int64 sub_412150()
{
  unsigned __int64 v1; // [rsp+8h] [rbp-8h]

  if ( (byte_41C023 & 0x40) != 0 )
    return sub_4121B0();
  if ( (dword_41C718 & 4) != 0 )
    v1 = sub_405E30();
  else
    sub_412210();
  return v1 ^ sub_4121E0();
}
// 412182: variable 'v1' is possibly undefined
// 41C023: using guessed type char byte_41C023;
// 41C718: using guessed type int dword_41C718;

//----- (00000000004121B0) ----------------------------------------------------
__int64 __fastcall sub_4121B0()
{
  bool v0; // cf
  __int64 v1; // rax

LABEL_1:
  v1 = 10i64;
  while ( 1 )
  {
    __asm { rdrand  r8 }
    if ( v0 )
      return _R8;
    v0 = v1-- == 0;
    if ( !v1 )
    {
      _mm_pause();
      goto LABEL_1;
    }
  }
}
// 4121BC: variable 'v0' is possibly undefined

//----- (00000000004121E0) ----------------------------------------------------
__int64 __fastcall sub_4121E0()
{
  _QWORD *v0; // rdi
  __int64 result; // rax

  result = ((*v0 ^ (*v0 << 13)) >> 7) ^ *v0 ^ (*v0 << 13) ^ ((((*v0 ^ (*v0 << 13)) >> 7) ^ *v0 ^ (*v0 << 13)) << 17);
  *v0 = result;
  return result;
}
// 4121E0: variable 'v0' is possibly undefined

//----- (0000000000412210) ----------------------------------------------------
__int64 __fastcall sub_412210()
{
  unsigned __int64 v0; // rdi
  __int64 v1; // rsi
  unsigned int v2; // er13
  unsigned __int64 v4; // rbx
  __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // r12
  __int64 v8; // rax

  if ( (dword_41C718 & 4) != 0 )
    return (unsigned int)sub_402B9F();
  v4 = v0;
  v2 = sub_4123B0(0i64, (unsigned int)qword_440938);
  if ( v2 == -1 )
    return v2;
  v7 = v0 + v1;
  if ( v0 < v0 + v1 )
  {
    while ( 1 )
    {
      v8 = sub_4123D0(v6, v7 - v4);
      if ( v8 == -1 || !v8 )
        break;
      v4 += v8;
      if ( v7 <= v4 )
        goto LABEL_11;
    }
    v2 = -1;
    sub_412330(v6, v5);
    return v2;
  }
LABEL_11:
  sub_412330(v6, v5);
  return (unsigned int)-(v7 != v4);
}
// 412246: variable 'v0' is possibly undefined
// 412266: variable 'v1' is possibly undefined
// 412289: variable 'v6' is possibly undefined
// 41229D: variable 'v5' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 440938: using guessed type __int64 qword_440938;

//----- (00000000004122D0) ----------------------------------------------------
__int64 __fastcall sub_4122D0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004122E0) ----------------------------------------------------
__int64 __fastcall sub_4122E0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004122F0) ----------------------------------------------------
__int64 __fastcall sub_4122F0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412300) ----------------------------------------------------
__int64 __fastcall sub_412300(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412310) ----------------------------------------------------
__int64 __fastcall sub_412310(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412320) ----------------------------------------------------
__int64 __fastcall sub_412320(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412330) ----------------------------------------------------
__int64 __fastcall sub_412330(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412340) ----------------------------------------------------
__int64 __fastcall sub_412340(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412350) ----------------------------------------------------
__int64 __fastcall sub_412350(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412360) ----------------------------------------------------
__int64 __fastcall sub_412360(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412370) ----------------------------------------------------
__int64 __fastcall sub_412370(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412380) ----------------------------------------------------
__int64 __fastcall sub_412380(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412390) ----------------------------------------------------
__int64 __fastcall sub_412390(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004123B0) ----------------------------------------------------
__int64 __fastcall sub_4123B0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004123D0) ----------------------------------------------------
__int64 __fastcall sub_4123D0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (00000000004123E0) ----------------------------------------------------
__int64 __fastcall sub_4123E0(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412400) ----------------------------------------------------
__int64 __fastcall sub_412400(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412410) ----------------------------------------------------
__int64 __fastcall sub_412410(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412420) ----------------------------------------------------
__int64 __fastcall sub_412420(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412440) ----------------------------------------------------
__int64 __fastcall sub_412440(__int64 a1, __int64 a2)
{
  return qword_41C720(a1, a2);
}
// 41C720: using guessed type __int64 (__fastcall *qword_41C720)(_QWORD, _QWORD);

//----- (0000000000412450) ----------------------------------------------------
__int64 __fastcall sub_412450(__int64 a1)
{
  __int128 v1; // rax

  *(_QWORD *)&v1 = sub_4142F0(a1, 10);
  if ( (__int128)__PAIR128__(-1i64, 0xFFFFFFFF7FFFFFFFui64) >= v1 )
  {
    *(_QWORD *)&v1 = 0x80000000i64;
  }
  else if ( v1 >= 0x80000000i64 )
  {
    *(_QWORD *)&v1 = 0x7FFFFFFFi64;
  }
  return v1;
}
// 412477: variable 'v1' is possibly undefined

//----- (00000000004124A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4124A0()
{
  unsigned __int64 v0; // rdi

  return v0 / 0x989680 - 0x2B6109100i64;
}
// 4124BA: variable 'v0' is possibly undefined

//----- (00000000004124E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4124E0()
{
  _QWORD *v0; // rdi
  unsigned __int64 v1; // rsi
  unsigned __int64 v2; // rsi
  unsigned __int64 result; // rax

  *v0 = v1 / 0x989680 - 0x2B6109100i64;
  v2 = v1 % 0x989680;
  result = 0xCCCCCCCCCCCCCCCDui64 * v2;
  v0[1] = v2 / 0xA;
  return result;
}
// 4124FA: variable 'v1' is possibly undefined
// 412508: variable 'v0' is possibly undefined

//----- (0000000000412530) ----------------------------------------------------
__int64 __fastcall sub_412530(__int64 a1, int a2)
{
  unsigned __int64 v2; // rdi
  _BYTE *v3; // rsi
  bool v4; // zf
  int v5; // ecx
  _BYTE *v6; // rdx

  v4 = (_BYTE)a2 == 0;
  v5 = a2;
  v6 = v3;
  if ( v4 )
  {
    *v3 = 0;
    return 0i64;
  }
  else
  {
    do
    {
      v5 -= 4;
      *v6++ = byte_41898B[(v2 >> v5) & 0xF];
    }
    while ( (_BYTE)v5 );
    *v6 = 0;
    return v6 - v3;
  }
}
// 412534: variable 'v3' is possibly undefined
// 41254A: variable 'v2' is possibly undefined

//----- (0000000000412580) ----------------------------------------------------
unsigned __int64 __fastcall sub_412580()
{
  unsigned __int64 v0; // rdi
  __int64 v1; // rsi
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 i; // rax
  char v6; // dl

  v2 = 0i64;
  do
  {
    v3 = v2++;
    *(_BYTE *)(v1 + v2 - 1) = v0 % 0xA + 48;
    v4 = v0;
    v0 /= 0xAui64;
  }
  while ( v4 > 9 );
  *(_BYTE *)(v1 + v2) = 0;
  for ( i = 0i64; i < v3; --v3 )
  {
    v6 = *(_BYTE *)(v1 + i);
    *(_BYTE *)(v1 + i++) = *(_BYTE *)(v1 + v3);
    *(_BYTE *)(v1 + v3) = v6;
  }
  return v2;
}
// 4125AE: variable 'v0' is possibly undefined
// 4125B4: variable 'v1' is possibly undefined

//----- (0000000000412600) ----------------------------------------------------
unsigned __int64 __fastcall sub_412600()
{
  __int64 v0; // rdi
  _BYTE *v1; // rsi

  if ( v0 >= 0 )
    return sub_412580();
  *v1 = 45;
  return sub_412580() + 1;
}
// 412607: variable 'v0' is possibly undefined
// 412609: variable 'v1' is possibly undefined

//----- (0000000000412630) ----------------------------------------------------
__int64 __fastcall sub_412630(__int64 a1)
{
  unsigned __int64 v1; // rdi
  int v2; // edx
  unsigned __int64 v3; // rdx

  v2 = 4;
  if ( v1 )
  {
    _BitScanReverse64(&v3, v1);
    v2 = ((_BYTE)v3 + 4) & 0xFC;
  }
  return sub_412530(a1, v2);
}
// 41263C: variable 'v1' is possibly undefined

//----- (0000000000412660) ----------------------------------------------------
__int64 __fastcall sub_412660(__int64 a1, int a2, char a3)
{
  unsigned int (*v3)(void); // rdi
  __int64 v4; // r15
  unsigned int (*v5)(void); // r12
  long double v7; // st6
  char v9; // fps^1
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rbx
  int v15; // er13
  int v16; // er15
  __int64 v17; // rcx
  __int64 result; // rax
  long double v19; // st5
  double v20; // st6
  unsigned __int64 v21; // rdi
  long double v22; // st4
  __int64 v23; // r9
  long double v24; // st3
  bool v25; // cf
  long double v26; // st6
  __int64 v27; // rax
  unsigned int v28; // ecx
  double v29; // st6
  int i; // er8
  __int64 v31; // rax
  _BYTE *v32; // r10
  char *v33; // rax
  long double v34; // [rsp+10h] [rbp-C0h]
  unsigned int v35; // [rsp+20h] [rbp-B0h]
  unsigned __int64 v36; // [rsp+48h] [rbp-88h]
  __int16 v38; // [rsp+5Eh] [rbp-72h]
  int v39[28]; // [rsp+60h] [rbp-70h] BYREF
  double v40; // [rsp+E0h] [rbp+10h]

  v4 = a3 & 3;
  v5 = v3;
  v36 = a1;
  _ST7 = v40;
  v7 = fabs(v40);
  if ( v7 > NAN )
    goto LABEL_5;
  if ( v40 != 0.0 )
  {
    if ( (int)sub_4147B4() > 63 )
    {
      _ST7 = v40;
LABEL_5:
      v39[0] = 6909542;
      LODWORD(v13) = 3;
LABEL_6:
      __asm { fxam }
      if ( (v9 & 2) != 0 )
      {
        v14 = (unsigned int)(v13 + 1);
        *((_BYTE *)v39 + (unsigned int)v13) = 45;
      }
      else if ( (a3 & 4) != 0 )
      {
        v14 = (unsigned int)(v13 + 1);
        *((_BYTE *)v39 + (unsigned int)v13) = 43;
      }
      else
      {
        v14 = (unsigned int)v13;
        if ( (a3 & 8) != 0 )
        {
          v14 = (unsigned int)(v13 + 1);
          *((_BYTE *)v39 + (unsigned int)v13) = 32;
        }
      }
      goto LABEL_9;
    }
    _ST7 = v40;
  }
  if ( (a3 & 0x20) != 0 )
  {
    v27 = 1i64;
    if ( a2 > 14 )
    {
      do
      {
        v28 = v27;
        *((_BYTE *)&v38 + v27 + 1) = 48;
        --a2;
        ++v27;
        if ( v28 > 0x3F )
        {
          v29 = _ST7;
          goto LABEL_44;
        }
      }
      while ( a2 > 14 );
      v29 = _ST7;
LABEL_44:
      v35 = v28;
      sub_414795();
      a1 = v35;
      _ST7 = v29;
      v19 = v34;
      v20 = (double)a2;
    }
    else
    {
      sub_414795();
      a1 = 0i64;
      v19 = v7;
      v20 = (double)a2;
    }
  }
  else
  {
    v19 = v7;
    v20 = 1000000.0;
    a1 = 0i64;
    a2 = 6;
  }
  v21 = (__int64)v19;
  v22 = (v19 - (double)(__int64)v19) * v20;
  v23 = (__int64)v22;
  v24 = v22 - (double)(__int64)v22;
  if ( v24 <= 0.5 )
  {
    v26 = v19;
    if ( v24 >= 0.5 && (!v23 || (v23 & 1) != 0) )
      ++v23;
  }
  else
  {
    v25 = (double)++v23 < v20;
    v26 = v19;
    if ( !v25 )
    {
      ++v21;
      v23 = 0i64;
    }
  }
  if ( a2 )
  {
    for ( i = a2; ; --i )
    {
      v14 = (unsigned int)a1;
      if ( (unsigned int)a1 > 0x3F )
        break;
      v14 = (unsigned int)(a1 + 1);
      *((_BYTE *)v39 + a1) = v23 % 10 + 48;
      v23 /= 10i64;
      ++a1;
      if ( !v23 )
      {
        if ( (_DWORD)v14 == 64 )
          break;
        if ( i == 1 )
        {
LABEL_67:
          *((_BYTE *)v39 + v14) = 46;
          a1 = (unsigned int)(v14 + 1);
          goto LABEL_29;
        }
        v32 = (char *)v39 + (unsigned int)v14;
        v33 = (char *)v39 + (unsigned int)v14 + i - 2 + 1;
        while ( 1 )
        {
          v14 = (unsigned int)(v14 + 1);
          *v32 = 48;
          if ( (_DWORD)v14 == 64 )
            break;
          if ( ++v32 == v33 )
            goto LABEL_67;
        }
        if ( v4 != 1 )
          goto LABEL_9;
        if ( v36 )
          goto LABEL_52;
        goto LABEL_11;
      }
    }
  }
  else
  {
    if ( v26 - (double)(__int64)v21 >= 0.5 )
      v21 -= ((v21 & 1) == 0) - 1i64;
LABEL_29:
    while ( 1 )
    {
      v14 = (unsigned int)a1;
      if ( (unsigned int)a1 > 0x3F )
        break;
      LODWORD(v13) = a1 + 1;
      *((_BYTE *)v39 + a1) = v21 % 0xA + 48;
      v21 /= 0xAui64;
      ++a1;
      if ( !v21 )
      {
        if ( v4 != 1 )
          goto LABEL_32;
        v14 = (unsigned int)v13;
        goto LABEL_51;
      }
    }
  }
  if ( v4 != 1 )
  {
LABEL_9:
    if ( !v4 && (unsigned int)v14 < v36 && (unsigned int)sub_413B40(a1, v36 - (unsigned int)v14) == -1 )
      return 0xFFFFFFFFi64;
    goto LABEL_11;
  }
LABEL_51:
  if ( !v36 )
    goto LABEL_68;
LABEL_52:
  __asm { fxam }
  if ( (v9 & 2) != 0 || (a3 & 0xC) != 0 )
    --v36;
  v31 = (unsigned int)v14;
  if ( v36 <= (unsigned int)v14 )
  {
LABEL_68:
    LODWORD(v13) = v14;
    goto LABEL_32;
  }
  v13 = (unsigned int)(v14 + 1);
  if ( (unsigned int)v14 <= 0x3F )
  {
    while ( 1 )
    {
      *((_BYTE *)v39 + v31) = 48;
      a1 = (unsigned int)v31;
      v14 = (unsigned int)v13;
      if ( v36 <= v13 )
        break;
      ++v31;
      ++v13;
      if ( (unsigned int)v31 > 0x3F )
        goto LABEL_12;
    }
LABEL_32:
    if ( (unsigned int)v13 > 0x3F )
    {
      v14 = (unsigned int)v13;
      goto LABEL_9;
    }
    goto LABEL_6;
  }
LABEL_11:
  LODWORD(a1) = v14 - 1;
LABEL_12:
  v15 = a1 - 1;
  v16 = a1 - v14;
  while ( v5() != -1 )
  {
    if ( v16 == v15 )
    {
      result = 0i64;
      if ( (a3 & 2) != 0 && v14 < v36 )
        return (unsigned int)-((unsigned int)sub_413B40(v17, v36 - v14) == -1);
      return result;
    }
    --v15;
  }
  return 0xFFFFFFFFi64;
}
// 4126D1: ignored the value written to the shadow area of the succeeding call
// 4129D5: ignored the value written to the shadow area of the succeeding call
// 4129C3: ignored the value written to the shadow area of the succeeding call
// 412BCE: ignored the value written to the shadow area of the succeeding call
// 412676: variable 'v3' is possibly undefined
// 412715: variable 'v9' is possibly undefined
// 412930: variable 'a1' is possibly undefined
// 4129F0: variable 'v34' is possibly undefined
// 412A07: variable 'v17' is possibly undefined

//----- (0000000000412C10) ----------------------------------------------------
__int64 __fastcall sub_412C10(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int (__fastcall *v4)(__int64, __int64, __int64, __int64); // rdi
  __int64 v6; // rdx
  unsigned int (__fastcall *v7)(__int64, __int64, __int64, __int64); // r12
  bool v8; // zf
  int v9; // ebx
  unsigned int v10; // er14
  unsigned __int64 v11; // r10
  unsigned int v12; // er13
  unsigned __int64 v13; // r11
  __int64 v14; // rsi
  __int64 v15; // rcx
  unsigned __int64 v16; // rax
  __int64 v17; // rdi
  bool v18; // si
  bool v19; // al
  char *v20; // rax
  char *v21; // rax
  char v22; // al
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rcx
  unsigned int v28; // er15
  __int64 v29; // rax
  unsigned int v30; // esi
  __int64 v31; // rax
  __int64 v32; // rax
  unsigned int (__fastcall *v33)(__int64, __int64, __int64, __int64); // [rsp+10h] [rbp-E0h]
  char v34; // [rsp+18h] [rbp-D8h]
  int v35; // [rsp+1Ch] [rbp-D4h]
  char v36; // [rsp+1Ch] [rbp-D4h]
  int v37[52]; // [rsp+20h] [rbp-D0h] BYREF
  unsigned int v38; // [rsp+100h] [rbp+10h]
  unsigned int v39; // [rsp+108h] [rbp+18h]
  char v40; // [rsp+110h] [rbp+20h]
  __int64 v41; // [rsp+118h] [rbp+28h]

  v6 = a1;
  v7 = v4;
  v34 = a3;
  if ( a2 | a1 || (v8 = (v40 & 0x20) == 0, v40 &= ~0x10u, v8) )
  {
    v9 = 0;
    v33 = v4;
    v10 = 0;
    v11 = a2;
    v12 = a4;
    v35 = ~(-1 << a4);
    v13 = a1;
    do
    {
      if ( v12 )
      {
        a3 = 0i64;
        v14 = v35 & (unsigned int)v11;
        v11 = (v11 >> v12) | (v13 << (64 - (unsigned __int8)v12));
        v13 >>= v12;
        if ( (v12 & 0x40) != 0 )
          v11 = v13;
        if ( (v12 & 0x40) != 0 )
          v13 = 0i64;
      }
      else
      {
        v16 = sub_414650(0i64, 0xAui64, (__int64)v37);
        v14 = (unsigned int)v37[0];
        v11 = v16;
        v13 = v6;
      }
      v15 = v10 + 1;
      if ( v9 == 3 && v40 < 0 )
      {
        v17 = v10;
        v9 = 1;
        v10 += 2;
        *((_BYTE *)&v37[4] + v17) = 44;
      }
      else
      {
        ++v9;
        v15 = v10++;
      }
      *((_BYTE *)&v37[4] + v15) = *(_BYTE *)(v41 + v14);
    }
    while ( v11 | v13 );
    a4 = v12;
    v7 = v33;
  }
  else
  {
    v10 = 0;
  }
  v36 = v40 & 2;
  if ( (v40 & 2) == 0 )
  {
    v6 = v40 & 1;
    v18 = v10 <= 0x8F;
    v19 = v10 <= 0x8F && v10 < v38;
    if ( v39 )
    {
      if ( (_BYTE)v6 )
      {
        if ( v34 || (v40 & 0xC) != 0 )
          --v39;
        if ( !v19 )
        {
LABEL_24:
          if ( v10 < v39 && v18 )
          {
            v6 = v39;
            v21 = (char *)&v37[4] + v10;
            do
            {
              ++v10;
              *v21++ = 48;
            }
            while ( v10 < v39 && v10 <= 0x8F );
          }
          goto LABEL_29;
        }
      }
      else if ( !v19 )
      {
        goto LABEL_29;
      }
    }
    else if ( !v19 )
    {
LABEL_22:
      if ( !(_BYTE)v6 )
        goto LABEL_29;
      v18 = v10 <= 0x8F;
      goto LABEL_24;
    }
    v20 = (char *)&v37[4] + v10;
    do
    {
      ++v10;
      *v20++ = 48;
    }
    while ( v38 > v10 && v10 <= 0x8F );
    goto LABEL_22;
  }
LABEL_29:
  if ( (v40 & 0x10) == 0 )
    goto LABEL_36;
  v22 = (_DWORD)a4 == 4;
  if ( (v40 & 0x20) != 0 )
    goto LABEL_31;
  if ( !v10 )
  {
    v6 = 1i64;
    goto LABEL_32;
  }
  LOBYTE(v6) = v10 == v39 || v38 == v10;
  if ( !(_BYTE)v6 || (v30 = v10 - 1, *((_BYTE *)&v37[3] + v10 + 3) != 48) )
  {
LABEL_31:
    LOBYTE(v6) = v10 <= 0x8F;
    v22 &= v10 <= 0x8F;
    goto LABEL_32;
  }
  if ( v10 == 1 )
  {
    v10 = 0;
LABEL_32:
    if ( v22 )
    {
      v23 = v10++;
      *((_BYTE *)&v37[4] + v23) = 120;
    }
    else if ( (_DWORD)a4 == 1 && (_BYTE)v6 )
    {
      v31 = v10++;
      *((_BYTE *)&v37[4] + v31) = 98;
    }
    goto LABEL_34;
  }
  LOBYTE(v6) = v22 | ((_DWORD)a4 == 1);
  if ( (_BYTE)v6 )
  {
    v8 = *((_BYTE *)&v37[3] + v10 + 2) == 48;
    v10 -= 2;
    if ( !v8 )
    {
      v10 = v30;
      LOBYTE(v6) = v30 <= 0x8F;
      v22 &= v30 <= 0x8F;
    }
    goto LABEL_32;
  }
  --v10;
LABEL_34:
  if ( v10 > 0x8F )
    goto LABEL_43;
  v24 = v10++;
  *((_BYTE *)&v37[4] + v24) = 48;
LABEL_36:
  if ( v10 <= 0x8F )
  {
    if ( v34 )
    {
      v25 = v10++;
      *((_BYTE *)&v37[4] + v25) = 45;
LABEL_39:
      v26 = v40 & 3;
      if ( (v40 & 3) == 0 && v39 > v10 && (unsigned int)sub_413B40(v26, v39 - v10) == -1 )
        return 0xFFFFFFFFi64;
      goto LABEL_46;
    }
    if ( (v40 & 4) != 0 )
    {
      v32 = v10++;
      *((_BYTE *)&v37[4] + v32) = 43;
      goto LABEL_39;
    }
    if ( (v40 & 8) != 0 )
    {
      v29 = v10++;
      *((_BYTE *)&v37[4] + v29) = 32;
      goto LABEL_39;
    }
  }
LABEL_43:
  v26 = v40 & 3;
  if ( (v40 & 3) == 0 && v39 > v10 && (unsigned int)sub_413B40(v26, v39 - v10) == -1 )
    return 0xFFFFFFFFi64;
  if ( v10 )
  {
LABEL_46:
    v28 = 0;
    while ( v7(v26, v6, a3, a4) != -1 )
    {
      if ( ++v28 >= v10 )
        goto LABEL_51;
    }
    return 0xFFFFFFFFi64;
  }
  v28 = 0;
LABEL_51:
  if ( v36 && v39 > v28 )
    return (unsigned int)-((unsigned int)sub_413B40(v26, v39 - v28) == -1);
  else
    return 0i64;
}
// 412C25: variable 'v4' is possibly undefined
// 412CA1: variable 'v35' is possibly undefined
// 412D0E: variable 'v6' is possibly undefined
// 412D33: variable 'v33' is possibly undefined
// 412E58: variable 'v34' is possibly undefined
// 412EEA: variable 'v26' is possibly undefined
// 412EEA: variable 'a3' is possibly undefined
// 412EEA: variable 'a4' is possibly undefined
// 412F07: variable 'v36' is possibly undefined

//----- (00000000004130C0) ----------------------------------------------------
__int64 __fastcall sub_4130C0(unsigned __int8 a1, __int64 a2, unsigned int a3)
{
  char v3; // al
  unsigned int v4; // er8
  __int64 *v5; // r10
  __int64 v6; // r15
  __int64 v7; // r8
  __int64 *v8; // r10
  unsigned __int64 v9; // r13
  __int64 v10; // r12
  __int128 v11; // rcx
  __int128 v12; // rcx
  __int64 v13; // r11
  unsigned __int64 v14; // r10
  __int64 v15; // r8
  __int64 v17; // r13
  __int128 v18; // [rsp+0h] [rbp-50h]
  char v20; // [rsp+68h] [rbp+18h]

  v3 = v20;
  if ( (v20 & 0x20) != 0 )
    v3 = v20 & 0xFE;
  v4 = *(_DWORD *)a2;
  if ( a1 <= 0x3Fu )
  {
    if ( v4 > 0x2F )
    {
      v8 = *(__int64 **)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v8 + 1;
    }
    else
    {
      v8 = (__int64 *)(*(_QWORD *)(a2 + 16) + v4);
      *(_DWORD *)a2 = v4 + 8;
    }
    v6 = *v8;
    v7 = 0i64;
  }
  else
  {
    if ( v4 > 0x27 )
    {
      v5 = (__int64 *)((*(_QWORD *)(a2 + 8) + 15i64) & 0xFFFFFFFFFFFFFFF0ui64);
      *(_QWORD *)(a2 + 8) = v5 + 2;
    }
    else
    {
      v5 = (__int64 *)(*(_QWORD *)(a2 + 16) + v4);
      *(_DWORD *)a2 = v4 + 16;
    }
    v6 = *v5;
    v7 = v5[1];
  }
  v9 = 1ui64 >> (64 - a1);
  v10 = 1i64 << a1;
  if ( (a1 & 0x40) != 0 )
    v9 = 1i64 << a1;
  if ( (a1 & 0x40) != 0 )
    v10 = 0i64;
  *(_QWORD *)&v11 = v10;
  *((_QWORD *)&v11 + 1) = v9;
  v12 = v11 + 0xFFFFFFFFFFFFFFFFui64;
  v18 = v12 + __PAIR128__(-1i64, 0i64);
  *((_QWORD *)&v12 + 1) = v9 | (*((_QWORD *)&v12 + 1) - 1i64);
  v13 = *((_QWORD *)&v12 + 1) & v7;
  v14 = (v10 | v12) & v6;
  v15 = 0i64;
  if ( (v3 & 0x40) != 0 )
  {
    v15 = 1i64;
    if ( v14 ^ v10 | v13 ^ v9 )
    {
      v15 = 0i64;
      if ( v14 & v10 | v13 & v9 )
      {
        v15 = 1i64;
        v17 = (unsigned __int128)-(__int128)__PAIR128__(v13, v14) >> 64;
        v14 = -(__int64)v14 & (v10 | v12);
        v13 = v17 & *((_QWORD *)&v12 + 1);
      }
      v13 &= *((_QWORD *)&v18 + 1);
      v14 &= v18;
    }
  }
  return sub_412C10(v13, v14, v15, a3);
}
// 4131E3: ignored the value written to the shadow area of the succeeding call
// 4131DD: ignored the value written to the shadow area of the succeeding call
// 4131E2: ignored the value written to the shadow area of the succeeding call
// 4131D4: ignored the value written to the shadow area of the succeeding call

//----- (0000000000413260) ----------------------------------------------------
__int64 __fastcall sub_413260(__int64 a1, char *a2, __int64 a3)
{
  __int64 (*v3)(); // rdi
  __int64 (*v4)(); // rbx
  char v5; // di
  char *v6; // r15
  char *v8; // r15
  __int64 v9; // rcx
  char v10; // al
  char *v11; // rsi
  __int64 v12; // r9
  unsigned __int64 v13; // rdx
  char v14; // al
  _BYTE *v15; // rdi
  unsigned __int8 v16; // si
  bool v18; // cc
  unsigned int v19; // eax
  unsigned int v20; // eax
  const char **v21; // rdi
  unsigned int v22; // eax
  unsigned int *v23; // rdx
  int v24; // edi
  char *v25; // rsi
  unsigned int v26; // eax
  int v27; // eax
  unsigned int v28; // edx
  unsigned int *v29; // rax
  const char *v30; // r10
  int v31; // edi
  int v32; // [rsp+2Ch] [rbp-34h] BYREF

  v4 = sub_40116A;
  if ( v3 )
    v4 = v3;
  v5 = *a2;
  if ( !*a2 )
    return 0i64;
  v6 = a2;
  while ( 2 )
  {
    if ( v5 != 37 )
    {
      if ( (unsigned int)v4() == -1 )
        return 0xFFFFFFFFi64;
      ++v6;
      goto LABEL_7;
    }
    v8 = v6 + 1;
    v9 = 0i64;
    while ( 1 )
    {
      v10 = *v8;
      v11 = v8 + 1;
      if ( *v8 == 44 )
      {
        LOBYTE(v9) = v9 | 0x80;
        goto LABEL_13;
      }
      if ( v10 > 44 )
        break;
      if ( v10 == 39 )
        goto LABEL_23;
      if ( v10 <= 39 )
      {
        if ( v10 == 32 )
          goto LABEL_23;
        if ( v10 != 35 )
          goto LABEL_29;
        v9 = (unsigned int)v9 | 0x10;
      }
      else
      {
        if ( v10 != 43 )
        {
          if ( v10 == 42 )
          {
            v22 = *(_DWORD *)a1;
            if ( *(_DWORD *)a1 > 0x2Fu )
            {
              v23 = *(unsigned int **)(a1 + 8);
              *(_QWORD *)(a1 + 8) = v23 + 2;
            }
            else
            {
              v23 = (unsigned int *)(*(_QWORD *)(a1 + 16) + v22);
              *(_DWORD *)a1 = v22 + 8;
            }
            v12 = *v23;
            if ( (int)v12 < 0 )
            {
              v9 = (unsigned int)v9 | 2;
              v12 = (unsigned int)-(int)v12;
            }
            v10 = *++v8;
            goto LABEL_139;
          }
LABEL_29:
          v12 = 0i64;
          goto LABEL_30;
        }
        v9 = (unsigned int)v9 | 4;
      }
LABEL_13:
      ++v8;
    }
    switch ( v10 )
    {
      case '0':
        v9 = (unsigned int)v9 | 1;
        goto LABEL_13;
      case '`':
        LODWORD(v9) = v9 | 4;
LABEL_23:
        v9 = (unsigned int)v9 | 8;
        goto LABEL_13;
      case '-':
        v9 = (unsigned int)v9 | 2;
        goto LABEL_13;
    }
    v31 = v10;
    v12 = 0i64;
    if ( (unsigned int)(v10 - 48) <= 9 )
    {
      v12 = 0i64;
      if ( (unsigned __int8)(v10 - 48) <= 9u )
      {
        while ( 1 )
        {
          v8 = v11;
          v12 = (unsigned int)(v31 + 10 * v12 - 48);
          v10 = *v11;
          if ( (unsigned __int8)(*v11 - 48) > 9u )
            break;
          ++v11;
          v31 = v10;
        }
      }
    }
LABEL_139:
    if ( v10 != 46 )
      goto LABEL_30;
    v24 = v8[1];
    v9 = (unsigned int)v9 | 0x20;
    v25 = v8 + 1;
    v10 = v8[1];
    if ( (unsigned int)(v24 - 48) <= 9 )
    {
      if ( (unsigned __int8)(v24 - 48) <= 9u )
      {
        LODWORD(v13) = 0;
        while ( 1 )
        {
          ++v25;
          v13 = (unsigned int)(v24 + 10 * v13 - 48);
          v10 = *v25;
          if ( (unsigned __int8)(*v25 - 48) > 9u )
            break;
          v24 = v10;
        }
        v8 = v25;
        goto LABEL_31;
      }
LABEL_142:
      ++v8;
LABEL_30:
      v13 = 0i64;
      goto LABEL_31;
    }
    if ( (_BYTE)v24 != 42 )
      goto LABEL_142;
    v28 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 > 0x2Fu )
    {
      v29 = *(unsigned int **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = v29 + 2;
    }
    else
    {
      v29 = (unsigned int *)(*(_QWORD *)(a1 + 16) + v28);
      *(_DWORD *)a1 = v28 + 8;
    }
    a3 = *v29;
    v13 = 0i64;
    if ( (int)a3 >= 0 )
      v13 = *v29;
    v10 = v8[2];
    v8 += 2;
LABEL_31:
    if ( v10 == 106 )
    {
      v14 = v8[1];
      v15 = v8 + 1;
      v16 = 127;
      goto LABEL_36;
    }
    if ( v10 > 106 )
    {
      if ( v10 == 108 )
      {
        v14 = v8[1];
        if ( v14 == 108 )
        {
          v14 = v8[2];
          v6 = v8 + 3;
          v18 = v14 <= 111;
          if ( v14 == 111 )
          {
LABEL_72:
            v16 = 63;
LABEL_162:
            LOBYTE(a3) = 3;
            goto LABEL_43;
          }
          goto LABEL_60;
        }
LABEL_59:
        v6 = v8 + 2;
        v18 = v14 <= 111;
        if ( v14 == 111 )
          goto LABEL_72;
LABEL_60:
        if ( v18 )
        {
          if ( v14 != 99 )
          {
            if ( v14 <= 99 )
            {
              if ( v14 != 88 )
              {
                if ( v14 > 88 )
                {
                  a3 = 1i64;
                  v16 = 63;
                  if ( v14 == 98 )
                    goto LABEL_43;
                  goto LABEL_66;
                }
                if ( v14 == 37 )
                  goto LABEL_85;
                if ( v14 != 70 )
                  goto LABEL_66;
LABEL_93:
                *(_QWORD *)(a1 + 8) = ((*(_QWORD *)(a1 + 8) + 15i64) & 0xFFFFFFFFFFFFFFF0ui64) + 16;
                goto LABEL_94;
              }
              v16 = 63;
LABEL_150:
              LOBYTE(a3) = 4;
              goto LABEL_43;
            }
            if ( v14 == 105 )
              goto LABEL_120;
            if ( v14 > 105 )
              goto LABEL_89;
            if ( v14 != 100 )
            {
              if ( v14 == 102 )
                goto LABEL_93;
              goto LABEL_66;
            }
LABEL_120:
            v16 = 63;
LABEL_55:
            LOBYTE(a3) = 0;
            goto LABEL_43;
          }
          v26 = *(_DWORD *)a1;
          LODWORD(v9) = v9 | 0x20;
          if ( *(_DWORD *)a1 > 0x2Fu )
          {
LABEL_177:
            v13 = *(_QWORD *)(a1 + 8);
            *(_QWORD *)(a1 + 8) = v13 + 8;
            goto LABEL_146;
          }
LABEL_145:
          v13 = *(_QWORD *)(a1 + 16) + v26;
          *(_DWORD *)a1 = v26 + 8;
LABEL_146:
          v27 = *(_DWORD *)v13;
          LODWORD(v13) = 1;
          v30 = (const char *)&v32;
          v32 = v27;
          goto LABEL_112;
        }
        if ( v14 == 115 )
          goto LABEL_109;
        if ( v14 <= 115 )
        {
          if ( v14 == 113 )
            goto LABEL_108;
          if ( v14 != 114 )
            goto LABEL_115;
LABEL_107:
          LODWORD(v9) = v9 | 4;
LABEL_108:
          LODWORD(v9) = v9 | 8;
LABEL_109:
          v20 = *(_DWORD *)a1;
          if ( *(_DWORD *)a1 > 0x2Fu )
          {
            v21 = *(const char ***)(a1 + 8);
            *(_QWORD *)(a1 + 8) = v21 + 1;
          }
          else
          {
            v21 = (const char **)(*(_QWORD *)(a1 + 16) + v20);
            *(_DWORD *)a1 = v20 + 8;
          }
          v30 = *v21;
LABEL_112:
          if ( sub_413CC0 && (unsigned int)sub_413CC0((int)v9, v30, (int)v13, (int)v12) != -1 )
            goto LABEL_7;
          return 0xFFFFFFFFi64;
        }
        if ( v14 == 117 )
        {
          v16 = 63;
          LOBYTE(a3) = 0;
          goto LABEL_43;
        }
        if ( v14 != 120 )
          goto LABEL_66;
        v16 = 63;
LABEL_101:
        LOBYTE(a3) = 4;
        goto LABEL_43;
      }
      if ( v10 != 107 && (v10 == 116 || v10 == 122) )
      {
LABEL_58:
        v14 = v8[1];
        goto LABEL_59;
      }
      v6 = v8 + 1;
      if ( v10 == 109 )
        goto LABEL_90;
      if ( v10 > 109 )
      {
        if ( v10 == 114 )
          goto LABEL_107;
        if ( v10 <= 114 )
        {
          switch ( v10 )
          {
            case 'p':
LABEL_116:
              LOBYTE(a3) = 4;
              v16 = 47;
              goto LABEL_43;
            case 'q':
              goto LABEL_108;
            case 'o':
              v16 = 31;
              goto LABEL_162;
          }
          goto LABEL_66;
        }
        if ( v10 == 117 )
        {
          v16 = 31;
          goto LABEL_55;
        }
        if ( v10 != 120 )
        {
          if ( v10 == 115 )
            goto LABEL_109;
          goto LABEL_66;
        }
        v16 = 31;
        goto LABEL_101;
      }
LABEL_48:
      if ( v10 == 98 )
      {
        LOBYTE(a3) = 1;
        v16 = 31;
        goto LABEL_43;
      }
      if ( v10 <= 98 )
      {
        if ( v10 == 70 )
          goto LABEL_103;
        if ( v10 != 88 )
        {
          if ( v10 == 37 )
          {
LABEL_85:
            if ( ((unsigned int (__fastcall *)(__int64, unsigned __int64, __int64, __int64))v4)(v9, v13, a3, v12) == -1 )
              return 0xFFFFFFFFi64;
            goto LABEL_7;
          }
          goto LABEL_66;
        }
        v16 = 31;
        goto LABEL_150;
      }
      if ( v10 == 100 )
        goto LABEL_54;
      if ( v10 > 100 )
      {
        if ( v10 == 102 )
          goto LABEL_103;
        if ( v10 != 105 )
          goto LABEL_66;
LABEL_54:
        v16 = 31;
        goto LABEL_55;
      }
LABEL_144:
      v26 = *(_DWORD *)a1;
      LODWORD(v9) = v9 | 0x20;
      if ( *(_DWORD *)a1 > 0x2Fu )
        goto LABEL_177;
      goto LABEL_145;
    }
    if ( v10 != 104 )
    {
      if ( v10 != 105 && (v10 == 76 || v10 == 90) )
        goto LABEL_58;
      v6 = v8 + 1;
      goto LABEL_48;
    }
    v14 = v8[1];
    v15 = v8 + 1;
    v16 = 15;
    if ( v14 == 104 )
    {
      v14 = v8[2];
      v15 = v8 + 2;
      v16 = 7;
    }
LABEL_36:
    v6 = v15 + 1;
    if ( v14 == 111 )
      goto LABEL_162;
    if ( v14 > 111 )
    {
      if ( v14 == 115 )
        goto LABEL_109;
      if ( v14 <= 115 )
      {
        if ( v14 == 113 )
          goto LABEL_108;
        if ( v14 == 114 )
          goto LABEL_107;
LABEL_115:
        if ( v14 == 112 )
          goto LABEL_116;
      }
      else
      {
        if ( v14 == 117 )
          goto LABEL_55;
        if ( v14 == 120 )
          goto LABEL_101;
      }
      goto LABEL_66;
    }
    if ( v14 == 99 )
      goto LABEL_144;
    if ( v14 <= 99 )
    {
      if ( v14 == 88 )
        goto LABEL_150;
      if ( v14 <= 88 )
      {
        if ( v14 == 37 )
          goto LABEL_85;
        if ( v14 == 70 )
          goto LABEL_103;
      }
      else
      {
        a3 = 1i64;
        if ( v14 == 98 )
        {
LABEL_43:
          if ( !sub_4130C0 || (unsigned int)sub_4130C0(v16, a1, a3 & 7) == -1 )
            return 0xFFFFFFFFi64;
LABEL_7:
          v5 = *v6;
          if ( !*v6 )
            return 0i64;
          continue;
        }
      }
LABEL_66:
      if ( ((unsigned int (__fastcall *)(__int64, unsigned __int64, __int64, __int64))v4)(v9, v13, a3, v12) == -1 )
        return 0xFFFFFFFFi64;
      v5 = *v6;
      if ( !*v6 )
        return 0i64;
      continue;
    }
    break;
  }
  if ( v14 == 105 )
    goto LABEL_55;
  if ( v14 > 105 )
  {
LABEL_89:
    if ( v14 != 109 )
      goto LABEL_66;
LABEL_90:
    v30 = "?";
    goto LABEL_112;
  }
  if ( v14 == 100 )
    goto LABEL_55;
  if ( v14 != 102 )
    goto LABEL_66;
LABEL_103:
  v19 = *(_DWORD *)(a1 + 4);
  if ( v19 <= 0xAF )
    *(_DWORD *)(a1 + 4) = v19 + 16;
  else
    *(_QWORD *)(a1 + 8) += 8i64;
LABEL_94:
  if ( sub_412660 && (unsigned int)sub_412660((int)v12, v13, v9) != -1 )
    goto LABEL_7;
  return 0xFFFFFFFFi64;
}
// 4133E5: ignored the value written to the shadow area of the succeeding call
// 4133E1: ignored the value written to the shadow area of the succeeding call
// 4133DA: ignored the value written to the shadow area of the succeeding call
// 41362D: ignored the value written to the shadow area of the succeeding call
// 4136F8: ignored the value written to the shadow area of the succeeding call
// 4136EE: ignored the value written to the shadow area of the succeeding call
// 4135CE: ignored the value written to the shadow area of the succeeding call
// 4135CA: ignored the value written to the shadow area of the succeeding call
// 4135C4: ignored the value written to the shadow area of the succeeding call
// 413852: conditional instruction was optimized away because al.1==63
// 413280: variable 'v3' is possibly undefined
// 4134BA: variable 'a3' is possibly undefined
// 448020: using guessed type int dword_448020;

//----- (0000000000413AC0) ----------------------------------------------------
__int64 __fastcall sub_413AC0(__int64 a1, char *a2, __int64 a3, __int64 a4)
{
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm2
  __int128 v7; // xmm3
  int v9; // [rsp+8h] [rbp-C8h] BYREF
  __int64 v10; // [rsp+38h] [rbp-98h]
  __int64 v11; // [rsp+40h] [rbp-90h]
  __int64 v12; // [rsp+48h] [rbp-88h]
  __int128 v13; // [rsp+50h] [rbp-80h]
  __int128 v14; // [rsp+60h] [rbp-70h]
  __int128 v15; // [rsp+70h] [rbp-60h]
  __int128 v16; // [rsp+80h] [rbp-50h]

  v11 = a3;
  v12 = a4;
  v13 = v4;
  v14 = v5;
  v15 = v6;
  v16 = v7;
  v10 = a1;
  return sub_414600((__int64)&v9, a2, a3);
}
// 413B31: ignored the value written to the shadow area of the succeeding call
// 413B27: ignored the value written to the shadow area of the succeeding call
// 413B19: ignored the value written to the shadow area of the succeeding call
// 413B0F: ignored the value written to the shadow area of the succeeding call
// 413AC0: variable 'v4' is possibly undefined
// 413AC0: variable 'v5' is possibly undefined
// 413AC0: variable 'v6' is possibly undefined
// 413AC0: variable 'v7' is possibly undefined

//----- (0000000000413B40) ----------------------------------------------------
__int64 __fastcall sub_413B40(__int64 a1, __int64 a2)
{
  __int64 (*v2)(void); // rdi
  int v3; // er13
  unsigned int v4; // er12
  int v5; // ebx

  if ( a2 )
  {
    v3 = a2;
    v4 = 0;
    v5 = 0;
    do
    {
      ++v5;
      v4 |= v2();
    }
    while ( v3 != v5 );
  }
  else
  {
    return 0;
  }
  return v4;
}
// 413B73: variable 'v2' is possibly undefined

//----- (0000000000413BA0) ----------------------------------------------------
__int64 __fastcall sub_413BA0()
{
  __int64 (*v0)(void); // rdi

  return v0();
}
// 413BA5: variable 'v0' is possibly undefined
// 413BA0: using guessed type __int64 __fastcall sub_413BA0();

//----- (0000000000413BB0) ----------------------------------------------------
__int64 __fastcall sub_413BB0(__int64 a1, int a2)
{
  unsigned int (*v2)(void); // rdi
  unsigned __int64 v3; // rbx
  unsigned __int64 v5; // rbx

  if ( (a2 & 0xFFFFFF80) != 0 )
  {
    v3 = sub_414845();
    while ( v2() != -1 )
    {
      v3 >>= 8;
      if ( !v3 )
        return 0i64;
    }
  }
  else
  {
    v5 = (int)sub_415409();
    while ( v2() != -1 )
    {
      v5 >>= 8;
      if ( !v5 )
        return 0i64;
    }
  }
  return 0xFFFFFFFFi64;
}
// 413BE4: variable 'v2' is possibly undefined
// 415409: using guessed type __int64 sub_415409(void);

//----- (0000000000413C40) ----------------------------------------------------
__int64 __fastcall sub_413C40(__int64 a1, int a2)
{
  __int64 (*v2)(void); // rdi
  __int64 result; // rax
  unsigned __int64 v4; // rbx

  if ( (a2 & 0xFFFFFF80) == 0 )
    return v2();
  v4 = sub_414845();
  while ( 1 )
  {
    result = v2();
    if ( (_DWORD)result == -1 )
      break;
    v4 >>= 8;
    if ( !v4 )
      return 0i64;
  }
  return result;
}
// 413C6A: variable 'v2' is possibly undefined

//----- (0000000000413CC0) ----------------------------------------------------
__int64 __fastcall sub_413CC0(__int64 a1, const char *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned int (*v4)(void); // rdi
  unsigned int (*v5)(void); // r13
  const char *v7; // r14
  char v8; // r12
  unsigned int v9; // eax
  __int64 v11; // rdx
  char *v12; // rax
  char *v13; // r8
  unsigned int v14; // eax
  __int64 v15; // r9
  unsigned __int64 v16; // rax
  __int64 v17; // rdx
  int v18; // er10
  __int64 v19; // rdi
  const char *v20; // rax
  char v21; // cl
  unsigned __int64 v22; // r8
  const char *v23; // rax
  const char *v24; // rbx
  int v26; // eax
  unsigned __int64 v27; // [rsp+8h] [rbp-58h]
  unsigned __int64 v28; // [rsp+8h] [rbp-58h]
  __int64 v29; // [rsp+8h] [rbp-58h]
  unsigned __int8 v30; // [rsp+12h] [rbp-4Eh]
  unsigned __int8 v31; // [rsp+14h] [rbp-4Ch]
  unsigned int v32; // [rsp+14h] [rbp-4Ch]
  unsigned __int8 v33; // [rsp+14h] [rbp-4Ch]
  unsigned __int8 v34; // [rsp+18h] [rbp-48h]
  char v35; // [rsp+18h] [rbp-48h]
  char v36; // [rsp+18h] [rbp-48h]
  char v37; // [rsp+18h] [rbp-48h]
  unsigned __int64 v38; // [rsp+18h] [rbp-48h]
  char v39; // [rsp+18h] [rbp-48h]
  char v40; // [rsp+20h] [rbp-40h]
  unsigned __int64 v41; // [rsp+28h] [rbp-38h]
  unsigned int (*v42)(void); // [rsp+28h] [rbp-38h]
  unsigned __int64 v43; // [rsp+28h] [rbp-38h]
  char v44; // [rsp+70h] [rbp+10h]

  v5 = v4;
  v40 = a1;
  if ( !a2 )
  {
    v23 = "(null)";
    if ( (a1 & 4) != 0 )
      v23 = "NULL";
    v11 = 0i64;
    v8 = 0;
    v7 = v23;
    v40 = a1 & 0x5F | 0x80;
    goto LABEL_65;
  }
  v7 = a2;
  v8 = v44;
  if ( (a1 & 4) == 0 )
  {
    v11 = a1 & 0x20;
    if ( v44 != 15 && v44 != 63 )
      goto LABEL_65;
LABEL_8:
    if ( (v40 & 8) != 0 )
      goto LABEL_66;
    v42 = (unsigned int (*)(void))sub_413C40;
LABEL_10:
    if ( v8 == 63 )
      goto LABEL_68;
    goto LABEL_11;
  }
  if ( v44 == 63 || v44 == 15 )
  {
    if ( v4() == -1 )
      return 0xFFFFFFFFi64;
    v43 = v38;
    if ( v4() == -1 )
      return 0xFFFFFFFFi64;
    a4 = v43;
    v11 = v40 & 0x20;
    goto LABEL_8;
  }
  v41 = a4;
  v9 = v4();
  a4 = v41;
  if ( v9 == -1 )
    return 0xFFFFFFFFi64;
  v11 = v40 & 0x20;
LABEL_65:
  if ( (v40 & 8) == 0 )
  {
    v42 = (unsigned int (*)(void))sub_413BA0;
    goto LABEL_10;
  }
LABEL_66:
  v42 = (unsigned int (*)(void))sub_413BB0;
  LOBYTE(a1) = v11 != 0;
  v13 = 0i64;
  if ( v11 )
  {
    if ( !a4 )
      goto LABEL_24;
    v14 = a3;
    if ( v8 == 63 )
      goto LABEL_17;
    goto LABEL_14;
  }
  if ( v8 != 63 )
  {
LABEL_11:
    if ( v8 == 15 )
    {
      a3 = (int)sub_4158B1();
    }
    else
    {
      v12 = sub_4157A4();
      v13 = (char *)v34;
      a1 = v31;
      a4 = v27;
      a3 = (unsigned __int64)v12;
    }
    v14 = a3;
    if ( !a4 )
      goto LABEL_24;
LABEL_14:
    if ( v8 != 15 && sub_40A580 )
    {
      v14 = sub_40A580(a1, sub_40A580, v13);
      a4 = v28;
      a1 = v33;
      LOBYTE(v13) = v37;
    }
    goto LABEL_17;
  }
LABEL_68:
  v14 = sub_4158C8();
  a3 = (int)v14;
  if ( !a4 )
    goto LABEL_24;
LABEL_17:
  if ( v14 >= a4 )
  {
LABEL_24:
    if ( !(_BYTE)v13 )
    {
      if ( !a3 )
        goto LABEL_45;
      v32 = 0;
      v16 = a3 - 1;
      goto LABEL_27;
    }
    v32 = 0;
    goto LABEL_71;
  }
  v32 = a4 - v14;
  if ( (_DWORD)a4 == v14 )
  {
    if ( !(_BYTE)v13 )
    {
      if ( !a3 )
        goto LABEL_45;
      goto LABEL_83;
    }
LABEL_71:
    a1 = (unsigned int)a1 ^ 1;
    v24 = &v7[a3];
    v36 = a1;
    while ( v7 != v24 )
    {
      if ( !*(unsigned __int8 *)v7++ )
      {
        if ( v36 )
          break;
      }
      if ( v42() == -1 )
        return 0xFFFFFFFFi64;
    }
LABEL_42:
    if ( !v32 )
      goto LABEL_45;
    v15 = v40 & 2;
    goto LABEL_44;
  }
  v15 = v40 & 2;
  if ( (v40 & 2) == 0 )
  {
    v26 = sub_413B40(a1, v32);
    LOBYTE(v13) = v39;
    v15 = v29;
    a1 = v30;
    if ( v26 == -1 )
      return 0xFFFFFFFFi64;
  }
  if ( (_BYTE)v13 )
    goto LABEL_71;
  if ( a3 )
  {
LABEL_83:
    v16 = a3 - 1;
LABEL_27:
    a1 = (unsigned int)a1 ^ 1;
    v35 = a1;
    while ( 1 )
    {
      if ( v8 == 15 )
      {
        v17 = *(unsigned __int16 *)v7;
        a1 = v17;
        if ( !*(_WORD *)v7 && v35 )
          goto LABEL_42;
        LOWORD(a1) = v17 & 0xFC00;
        if ( (v17 & 0xFC00) == 0xD800 )
        {
          if ( !v16 )
            goto LABEL_42;
          a3 -= 2i64;
          v17 = (unsigned int)((((_DWORD)v17 - 55296) << 10) + v17 + 9216);
        }
        else
        {
          v7 += 2;
          a3 = v16;
        }
        goto LABEL_40;
      }
      if ( v8 == 63 )
        break;
      v17 = *(unsigned __int8 *)v7;
      a1 = (unsigned int)*v7;
      if ( !*v7 && v35 )
        goto LABEL_42;
      if ( (v17 & 0xFFFFFF80) == 0 )
      {
        ++v7;
        goto LABEL_54;
      }
      if ( (*v7 & 0xC0) != 128 )
      {
        if ( (unsigned int)v17 > 0xFB )
        {
          LODWORD(v17) = *v7 & 3;
          if ( v16 <= 4 )
            goto LABEL_42;
          a3 = v16 - 5;
          v18 = 5;
          goto LABEL_37;
        }
        _BitScanReverse((unsigned int *)&a1, (unsigned __int8)~*v7);
        v18 = 6 - a1;
        v22 = (unsigned int)(6 - a1);
        v17 = (((1 << a1) - 1) | 3) & (unsigned int)v17;
        if ( v22 > v16 )
          goto LABEL_42;
        a3 = v16 - v22;
        if ( v18 )
        {
LABEL_37:
          v19 = (unsigned int)(v18 - 1);
          v20 = v7 + 1;
          do
          {
            v21 = *v20++;
            a1 = v21 & 0x3F;
            v17 = (unsigned int)a1 | ((_DWORD)v17 << 6);
          }
          while ( v20 != &v7[v19 + 2] );
          v7 += v19 + 2;
        }
        else
        {
          ++v7;
        }
LABEL_40:
        if ( ((unsigned int (__fastcall *)(__int64, __int64))v42)(a1, v17) == -1 )
          return 0xFFFFFFFFi64;
        goto LABEL_41;
      }
      ++v7;
      a3 = v16;
LABEL_41:
      v16 = a3 - 1;
      if ( !a3 )
        goto LABEL_42;
    }
    v17 = *(unsigned int *)v7;
    if ( !(_DWORD)v17 && v35 )
      goto LABEL_42;
    v7 += 4;
    if ( !(_DWORD)v17 )
      goto LABEL_42;
LABEL_54:
    a3 = v16;
    goto LABEL_40;
  }
LABEL_44:
  if ( v15 && (unsigned int)sub_413B40(a1, v32) == -1 )
    return 0xFFFFFFFFi64;
LABEL_45:
  if ( (v40 & 0x84) == 4i64 )
    return (unsigned int)-(((unsigned int (__fastcall *)(__int64))v5)(a1) == -1);
  else
    return 0i64;
}
// 413D95: ignored the value written to the shadow area of the succeeding call
// 413D92: ignored the value written to the shadow area of the succeeding call
// 413D8E: ignored the value written to the shadow area of the succeeding call
// 4141ED: ignored the value written to the shadow area of the succeeding call
// 4141EA: ignored the value written to the shadow area of the succeeding call
// 4141E0: ignored the value written to the shadow area of the succeeding call
// 4142C9: ignored the value written to the shadow area of the succeeding call
// 4142C5: ignored the value written to the shadow area of the succeeding call
// 4142C2: ignored the value written to the shadow area of the succeeding call
// 4140E7: ignored the value written to the shadow area of the succeeding call
// 4140E4: ignored the value written to the shadow area of the succeeding call
// 4140DA: ignored the value written to the shadow area of the succeeding call
// 413CCD: variable 'v4' is possibly undefined
// 413D9E: variable 'v34' is possibly undefined
// 413DA3: variable 'v31' is possibly undefined
// 413DA7: variable 'v27' is possibly undefined
// 413DB3: variable 'a4' is possibly undefined
// 4141F1: variable 'a1' is possibly undefined
// 4141F1: variable 'v13' is possibly undefined
// 4141F3: variable 'v28' is possibly undefined
// 4141F7: variable 'v33' is possibly undefined
// 4141FB: variable 'v37' is possibly undefined
// 413E7A: variable 'v35' is possibly undefined
// 413F17: variable 'v32' is possibly undefined
// 414130: variable 'v36' is possibly undefined
// 414229: variable 'v38' is possibly undefined
// 4142D2: variable 'v39' is possibly undefined
// 4142D7: variable 'v29' is possibly undefined
// 4142DE: variable 'v30' is possibly undefined
// 413BA0: using guessed type __int64 __fastcall sub_413BA0();

//----- (00000000004142F0) ----------------------------------------------------
__int64 __fastcall sub_4142F0(__int64 a1, int a2)
{
  unsigned __int8 *v2; // rdi
  unsigned __int8 *i; // rbx
  unsigned __int8 v5; // r13
  unsigned int v6; // er10
  unsigned int v7; // ecx
  __int64 v8; // r8
  unsigned int v9; // ecx
  __int64 v10; // r12
  unsigned __int64 v11; // r13
  __int64 v12; // r11
  unsigned int v13; // edx
  int v14; // eax
  unsigned __int8 *v15; // r9
  unsigned int v16; // edx
  unsigned int v17; // eax
  __int64 v18; // kr00_8
  __int128 v19; // rax
  unsigned __int8 *v20; // rbx
  unsigned __int8 **v22; // [rsp+0h] [rbp-60h]
  unsigned __int8 *v23; // [rsp+8h] [rbp-58h]
  __int128 v24; // [rsp+10h] [rbp-50h]
  char v25; // [rsp+23h] [rbp-3Dh]
  unsigned int v26; // [rsp+24h] [rbp-3Ch]
  unsigned int v27; // [rsp+28h] [rbp-38h]
  unsigned int v28; // [rsp+2Ch] [rbp-34h]

  for ( i = v2; ; ++i )
  {
    v5 = *i;
    if ( !(unsigned int)sub_4148D0() )
      break;
  }
  v25 = 0;
  if ( v5 != 43 )
  {
    if ( v5 != 45 )
      goto LABEL_8;
    v25 = 1;
  }
  v5 = *++i;
LABEL_8:
  v6 = a2;
  if ( (unsigned int)(a2 - 2) <= 0x22 )
  {
    if ( v5 == 48 )
      v5 = *++i;
  }
  else
  {
    v6 = 10;
    a2 = 10;
    if ( v5 == 48 )
    {
      v5 = i[1];
      if ( (v5 & 0xDF) == 88 )
      {
        v5 = i[2];
        v6 = 16;
        i += 2;
        a2 = 16;
      }
      else if ( (i[1] & 0xDF) == 66 )
      {
        v5 = i[2];
        v6 = 2;
        i += 2;
        a2 = 2;
      }
      else
      {
        ++i;
        v6 = 8;
        a2 = 8;
      }
    }
  }
  v7 = (unsigned __int8)byte_41C380[v5];
  if ( v7 <= v6 && byte_41C380[v5] )
  {
    v8 = a2;
    v9 = v7 - 1;
    v10 = 0i64;
    v11 = 0i64;
    v12 = v8 >> 63;
    while ( 1 )
    {
      v15 = i + 1;
      v17 = (unsigned __int8)byte_41C380[i[1]];
      v18 = v8 * v10 + v9;
      v11 = (__PAIR128__(v12, v8) * __PAIR128__(v11, v10) + v9) >> 64;
      v10 = v18;
      if ( !byte_41C380[i[1]] || v17 > v6 )
        goto LABEL_19;
      v9 = v17 - 1;
      if ( v17 != 1 && __PAIR128__(v11, v18) != 0 )
      {
        _BitScanReverse(&v13, v9);
        v26 = v6;
        v27 = v17 - 1;
        v28 = v13 ^ 0x1F;
        v14 = sub_4153F4();
        v9 = v27;
        v6 = v26;
        v12 = *((_QWORD *)&v24 + 1);
        v8 = v24;
        v15 = v23;
        v16 = v14 + (v28 ^ 0x1F);
        if ( v16 > 0x7E )
          break;
      }
      i = v15;
    }
    if ( v25 )
    {
      if ( v16 == 127 )
      {
        v20 = i + 2;
        if ( !(((__int64)v24 * v18 + v27) | ((v24 * __PAIR128__(v11, v18) + v27) >> 64) ^ 0x8000000000000000ui64) )
          v15 = v20;
      }
      v11 = 0x8000000000000000ui64;
      v10 = 0i64;
      if ( !v22 )
        goto LABEL_31;
    }
    else
    {
      v10 = -1i64;
      v11 = 0x7FFFFFFFFFFFFFFFi64;
      if ( !v22 )
      {
LABEL_31:
        *(_QWORD *)&v19 = v10;
        return v19;
      }
    }
    goto LABEL_20;
  }
  v15 = i;
  v10 = 0i64;
  v11 = 0i64;
LABEL_19:
  if ( v22 )
LABEL_20:
    *v22 = v15;
  *(_QWORD *)&v19 = v10;
  *((_QWORD *)&v19 + 1) = v11;
  if ( v25 )
    return -v19;
  return v19;
}
// 4143CD: ignored the value written to the shadow area of the succeeding call
// 4143C9: ignored the value written to the shadow area of the succeeding call
// 4143C2: ignored the value written to the shadow area of the succeeding call
// 414300: variable 'v2' is possibly undefined
// 4143EA: variable 'v24' is possibly undefined
// 4143F5: variable 'v23' is possibly undefined
// 41444F: variable 'v22' is possibly undefined

//----- (00000000004145A0) ----------------------------------------------------
__int64 __fastcall sub_4145A0(__int64 a1, int a2)
{
  __int128 v2; // rax

  *(_QWORD *)&v2 = sub_4142F0(a1, a2);
  if ( *((__int64 *)&v2 + 1) < ((unsigned __int64)v2 < 0x8000000000000000ui64) - 1i64 )
  {
    *(_QWORD *)&v2 = 0x8000000000000000ui64;
  }
  else if ( 0x7FFFFFFFFFFFFFFFi64 < v2 )
  {
    *(_QWORD *)&v2 = 0x7FFFFFFFFFFFFFFFi64;
  }
  return v2;
}
// 4145BD: variable 'v2' is possibly undefined

//----- (0000000000414600) ----------------------------------------------------
__int64 __fastcall sub_414600(__int64 a1, char *a2, __int64 a3)
{
  unsigned __int64 v3; // rax
  __int64 v5; // [rsp+0h] [rbp-20h]
  unsigned __int64 v6; // [rsp+8h] [rbp-18h]
  __int64 v7; // [rsp+10h] [rbp-10h]

  sub_413260(a1, a2, a3);
  if ( v7 )
  {
    v3 = v7 - 1;
    if ( v6 <= v7 - 1 )
      v3 = v6;
    *(_BYTE *)(v5 + v3) = 0;
  }
  return (unsigned int)v6;
}
// 414619: ignored the value written to the shadow area of the succeeding call
// 414611: ignored the value written to the shadow area of the succeeding call
// 414608: ignored the value written to the shadow area of the succeeding call
// 41462D: variable 'v7' is possibly undefined
// 41463B: variable 'v6' is possibly undefined
// 414640: variable 'v5' is possibly undefined

//----- (0000000000414650) ----------------------------------------------------
unsigned __int64 __fastcall sub_414650(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int128 v3; // rdi
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // r9
  int v7; // ecx
  unsigned __int64 v8; // rdi
  __int64 v9; // rsi
  unsigned __int64 result; // rax
  unsigned __int64 v11; // r9
  __int128 v12; // rax
  __int128 v13; // rax
  __int128 v14; // rt0
  unsigned __int128 v15; // rtt
  unsigned __int128 v16; // rtt
  __m128i v17; // [rsp-28h] [rbp-28h] BYREF

  v5 = *((_QWORD *)&v3 + 1);
  v4 = v3;
  if ( v3 < __PAIR128__(a1, a2) )
  {
    if ( a3 )
      *(_OWORD *)a3 = v3;
    return 0i64;
  }
  else
  {
    *(_QWORD *)&v3 = a1;
    if ( a1 )
    {
      _BitScanReverse64(&a1, a1);
      _BitScanReverse64(&v6, *((unsigned __int64 *)&v3 + 1));
      v7 = (a1 ^ 0x3F) - (v6 ^ 0x3F);
      v8 = ((_QWORD)v3 << v7) | (a2 >> (64 - (unsigned __int8)v7));
      v9 = a2 << v7;
      if ( (v7 & 0x40) != 0 )
        v8 = a2 << v7;
      if ( (v7 & 0x40) != 0 )
        v9 = 0i64;
      result = 0i64;
      if ( v7 >= 0 )
      {
        v11 = 0i64;
        do
        {
          *(_QWORD *)&v12 = v9;
          *((_QWORD *)&v12 + 1) = v8;
          v13 = v12 + 0xFFFFFFFFFFFFFFFFui64;
          --*((_QWORD *)&v13 + 1);
          *((_QWORD *)&v13 + 1) = (__int64)((v13 - __PAIR128__(v5, v4)) >> 64) >> 63;
          v11 = BYTE8(v13) & 1 | (2 * v11);
          *(_QWORD *)&v13 = *((_QWORD *)&v13 + 1);
          *((_QWORD *)&v13 + 1) &= v8;
          *(_QWORD *)&v13 = v9 & v13;
          v5 = (__PAIR128__(v5, v4) - v13) >> 64;
          v4 -= v13;
          --v7;
          *(_QWORD *)&v14 = v9;
          *((_QWORD *)&v14 + 1) = v8;
          v9 = v14 >> 1;
          v8 >>= 1;
        }
        while ( v7 != -1 );
        result = v11;
      }
      if ( a3 )
      {
        *(_QWORD *)a3 = v4;
        *(_QWORD *)(a3 + 8) = v5;
      }
    }
    else
    {
      v17.m128i_i64[1] = 0i64;
      if ( a2 > *((_QWORD *)&v3 + 1) )
      {
        *(_QWORD *)&v16 = v4;
        *((_QWORD *)&v16 + 1) = *((_QWORD *)&v3 + 1);
        result = v16 / a2;
        v17.m128i_i64[0] = v16 % a2;
      }
      else
      {
        *(_QWORD *)&v15 = v4;
        *((_QWORD *)&v15 + 1) = *((_QWORD *)&v3 + 1) % a2;
        result = v15 / a2;
        v17.m128i_i64[0] = v15 % a2;
      }
      if ( a3 )
        *(__m128i *)a3 = _mm_load_si128(&v17);
    }
  }
  return result;
}
// 41465F: variable 'v3' is possibly undefined

//----- (0000000000414795) ----------------------------------------------------
void sub_414795()
{
  double v2; // [rsp+10h] [rbp+10h]

  _ST6 = v2 * 3.3219280948873626258;
  __asm { frndint }
}

//----- (00000000004147B4) ----------------------------------------------------
__int64 __fastcall sub_4147B4()
{
  double v3; // [rsp+18h] [rbp+10h]

  __asm { fxtract }
  return (unsigned int)(int)v3;
}

//----- (00000000004147EA) ----------------------------------------------------
unsigned __int64 __fastcall sub_4147EA()
{
  unsigned __int64 result; // rax

  __asm { syscall; Low latency system call }
  if ( result >= 0xFFFFFFFFFFFFF001ui64 )
  {
    dword_448020 = -(int)result;
    return -1i64;
  }
  return result;
}
// 4147F7: variable 'result' is possibly undefined
// 448020: using guessed type int dword_448020;

//----- (0000000000414825) ----------------------------------------------------
void __fastcall sub_414825()
{
  char v0; // cf

  __asm { syscall; Low latency system call }
  if ( v0 )
    JUMPOUT(0x4147FCi64);
}
// 41482C: control flows out of bounds to 4147FC
// 41482C: variable 'v0' is possibly undefined

//----- (0000000000414845) ----------------------------------------------------
__int64 __fastcall sub_414845()
{
  __int64 v0; // rdi
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  v0 = (unsigned int)v0;
  v1 = 0i64;
  if ( (unsigned int)v0 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, v0);
    v3 = *(_DWORD *)&asc_4189D1[2 * v2 + 1];
    do
    {
      v4 = v0;
      v0 = (unsigned int)v0 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return v0 | v1;
}
// 414849: variable 'v0' is possibly undefined
// 414855: variable 'v2' is possibly undefined

//----- (0000000000414880) ----------------------------------------------------
__int64 sub_414880()
{
  char *v0; // rax
  __int64 v1; // rcx
  unsigned __int64 v2; // r9
  unsigned int v3; // er10

  sub_41571A();
  v0 = sub_41571A();
  if ( v2 < (unsigned __int64)v0 )
    return 0i64;
  LOBYTE(v3) = (unsigned int)sub_414960(v1, (unsigned __int64)v0) == 0;
  return v3;
}
// 414898: ignored the value written to the shadow area of the succeeding call
// 414880: could not find valid save-restore pair for rbp
// 414896: variable 'v2' is possibly undefined
// 4148A6: variable 'v1' is possibly undefined
// 4148B2: variable 'v3' is possibly undefined

//----- (00000000004148D0) ----------------------------------------------------
__int64 __fastcall sub_4148D0()
{
  int v0; // edi

  return (v0 == 32) | (unsigned __int8)((unsigned int)(v0 - 9) <= 4);
}
// 4148DC: variable 'v0' is possibly undefined

//----- (00000000004148F0) ----------------------------------------------------
void __fastcall sub_4148F0(unsigned __int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // rax
  __int64 v4; // rcx

  sub_415783();
  if ( v3 )
    sub_4154C0(v4, v3 - v1 + 1);
  else
    sub_4154C0(v4, a1);
}
// 414916: variable 'v3' is possibly undefined
// 414925: variable 'v4' is possibly undefined
// 414918: variable 'v1' is possibly undefined

//----- (0000000000414960) ----------------------------------------------------
__int64 __fastcall sub_414960(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v6; // r8
  __int64 result; // rax

  if ( !a2 )
    return 0i64;
  v4 = 0i64;
  while ( 1 )
  {
    v6 = v4;
    v4 += 16i64;
    if ( v4 > a2 )
      break;
    if ( _mm_movemask_epi8(
           _mm_cmpeq_epi8(
             _mm_loadu_si128((const __m128i *)(v2 + v4 - 16)),
             _mm_loadu_si128((const __m128i *)(v3 + v4 - 16))))
       - 0xFFFF )
    {
      __asm { tzcnt   eax, eax }
      return *(unsigned __int8 *)(v2 + v6 + _EAX) - (unsigned int)*(unsigned __int8 *)(v3 + v6 + _EAX);
    }
  }
  if ( v6 >= a2 )
    return 0i64;
  do
  {
    result = *(unsigned __int8 *)(v2 + v6) - (unsigned int)*(unsigned __int8 *)(v3 + v6);
    if ( (_DWORD)result )
      break;
    ++v6;
  }
  while ( a2 != v6 );
  return result;
}
// 414970: variable 'v2' is possibly undefined
// 414976: variable 'v3' is possibly undefined

//----- (00000000004149F0) ----------------------------------------------------
__int64 __fastcall sub_4149F0(char a1, unsigned int a2)
{
  _WORD *v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 result; // rax
  __int16 v5; // ax
  unsigned int v6; // edx

  result = 0i64;
  if ( v3 )
  {
    if ( a2 <= 0x1F && a1 )
    {
      v5 = a2;
      if ( v3 <= 1 )
      {
LABEL_5:
        *v2 = v5;
        return 1i64;
      }
      result = 2i64;
      *v2 = -10240;
      v2[1] = a2 | 0xDC00;
    }
    else
    {
      if ( a2 - 57344 <= 0x1FFF || a2 <= 0xD7FF )
      {
        v5 = a2;
        goto LABEL_5;
      }
      v6 = a2 - 0x10000;
      if ( v3 <= 1 || v6 > 0xFFFFF )
      {
        *v2 = -3;
        return 0xFFFFFFFFi64;
      }
      else
      {
        v2[1] = (v6 & 0x3FF) - 9216;
        *v2 = (v6 >> 10) - 10240;
        return 2i64;
      }
    }
  }
  return result;
}
// 4149F5: variable 'v3' is possibly undefined
// 414A10: variable 'v2' is possibly undefined

//----- (0000000000414AB0) ----------------------------------------------------
char *__fastcall sub_414AB0()
{
  __int64 v0; // rdi
  char *v1; // rsi
  char *v2; // rcx
  __int64 v3; // rax
  char v4; // dl
  char *v5; // r8
  __m128i v7; // xmm1
  char v8; // dl
  __int64 v9; // rax
  _BYTE *v10; // rdi
  char *v11; // rax
  char v12; // dl
  _BYTE *v13; // r8

  v2 = v1;
  v3 = (unsigned __int8)v1 & 0xF;
  if ( ((unsigned __int8)v1 & 0xF) != 0 )
  {
    v3 = 0i64;
    do
    {
      v4 = v1[v3];
      v5 = (char *)(v0 + v3);
      *(_BYTE *)(v0 + v3) = v4;
      if ( !v4 )
        return v5;
      v2 = &v1[++v3];
    }
    while ( (((_BYTE)v1 + (_BYTE)v3) & 0xF) != 0 );
  }
  while ( 1 )
  {
    v7 = _mm_loadu_si128((const __m128i *)&v1[v3]);
    v5 = (char *)(v0 + v3);
    if ( _mm_movemask_epi8(_mm_cmpeq_epi8(v7, (__m128i)0i64)) )
      break;
    *(__m128i *)(v0 + v3) = v7;
    v3 += 16i64;
    v2 = &v1[v3];
  }
  v8 = *v2;
  *v5 = *v2;
  if ( !v8 )
    return v5;
  v9 = v3 + 1;
  v10 = (_BYTE *)(v9 + v0);
  v11 = &v1[v9];
  do
  {
    v12 = *v11;
    v13 = v10;
    ++v11;
    *v10++ = v12;
  }
  while ( v12 );
  return v13;
}
// 414AB4: variable 'v1' is possibly undefined
// 414AE1: variable 'v0' is possibly undefined

//----- (0000000000414B60) ----------------------------------------------------
__int64 __fastcall sub_414B60()
{
  unsigned __int8 *v0; // rdi
  unsigned __int8 *v1; // rsi
  unsigned __int8 v2; // cl
  int v3; // edx
  __int64 v4; // rax

  if ( v0 == v1 )
    return 0i64;
  v2 = *v0;
  v3 = *v1;
  v4 = 0i64;
  if ( *v0 == (_BYTE)v3 )
  {
    while ( (_BYTE)v3 )
    {
      v2 = v0[++v4];
      v3 = v1[v4];
      if ( v2 != (_BYTE)v3 )
        return (unsigned int)v2 - v3;
    }
    v3 = 0;
  }
  return (unsigned int)v2 - v3;
}
// 414B63: variable 'v0' is possibly undefined
// 414B63: variable 'v1' is possibly undefined

//----- (0000000000414BA0) ----------------------------------------------------
__int64 __fastcall sub_414BA0()
{
  char *v0; // rdi
  char *v1; // rsi
  char v2; // cl
  __int64 v3; // r8
  char v4; // al
  __int64 v5; // rdx

  v2 = *v0;
  v3 = 0i64;
  if ( *v0 )
  {
    v3 = 0i64;
    while ( 1 )
    {
      v4 = *v1;
      LODWORD(v5) = 0;
      if ( *v1 )
        break;
LABEL_8:
      v2 = v0[++v3];
      if ( !v2 )
        return v3;
    }
    while ( v2 != v4 )
    {
      v5 = (unsigned int)(v5 + 1);
      v4 = v1[v5];
      if ( !v4 )
        goto LABEL_8;
    }
  }
  return v3;
}
// 414BA0: variable 'v0' is possibly undefined
// 414BB8: variable 'v1' is possibly undefined

//----- (0000000000414C00) ----------------------------------------------------
__int64 __fastcall sub_414C00(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rdi
  unsigned __int8 *v3; // rsi
  unsigned __int8 v4; // r8
  int v5; // ecx
  __int64 v6; // rdx
  __int64 v7; // rax

  if ( v2 == v3 || !a2 )
    return 0i64;
  v4 = *v2;
  v5 = *v3;
  v6 = a2 - 1;
  v7 = 0i64;
  if ( *v2 == (_BYTE)v5 )
  {
    while ( (_BYTE)v5 )
    {
      if ( v7 != v6 )
      {
        v4 = v2[++v7];
        v5 = v3[v7];
        if ( v4 == (_BYTE)v5 )
          continue;
      }
      return (unsigned int)v4 - v5;
    }
    v5 = 0;
  }
  return (unsigned int)v4 - v5;
}
// 414C03: variable 'v2' is possibly undefined
// 414C03: variable 'v3' is possibly undefined

//----- (0000000000414C50) ----------------------------------------------------
void __fastcall sub_414C50()
{
  _BYTE *v0; // rdi
  char *v1; // rsi
  char v2; // cl
  _BYTE *v3; // r8
  char v4; // al
  __int64 v5; // rdx

  if ( *v1 )
  {
    if ( v1[1] )
    {
      v2 = *v0;
      if ( *v0 )
      {
        v3 = v0;
LABEL_5:
        v4 = *v1;
        LODWORD(v5) = 0;
        while ( v2 != v4 )
        {
          v5 = (unsigned int)(v5 + 1);
          v4 = v1[v5];
          if ( !v4 )
          {
            v2 = *++v3;
            if ( v2 )
              goto LABEL_5;
            return;
          }
        }
      }
    }
    else
    {
      sub_41576B();
    }
  }
}
// 414C50: variable 'v1' is possibly undefined
// 414C5F: variable 'v0' is possibly undefined

//----- (0000000000414CB0) ----------------------------------------------------
__int64 __fastcall sub_414CB0()
{
  __int64 *v0; // rdi
  __int64 v1; // r12
  __int64 v2; // rax
  __int64 v3; // rdx

  v1 = *v0;
  if ( *v0 )
  {
    v2 = sub_414BA0();
    v3 = 0i64;
    if ( *(_BYTE *)(v1 + v2) )
    {
      *(_BYTE *)(v1 + v2) = 0;
      v3 = v1 + v2 + 1;
    }
    *v0 = v3;
  }
  return v1;
}
// 414CB7: variable 'v0' is possibly undefined

//----- (0000000000414CF0) ----------------------------------------------------
void __fastcall sub_414CF0()
{
  __int64 v0; // rdi
  char *v1; // rsi
  char v2; // r8
  __int64 v3; // rdx
  char v4; // cl

  if ( *v1 )
  {
    if ( v1[1] )
    {
      do
      {
        v2 = *v1;
        v3 = 0i64;
        while ( 1 )
        {
          v4 = *(_BYTE *)(v0 + v3);
          if ( !v4 || v4 != v2 )
            break;
          v2 = v1[++v3];
          if ( !v2 )
            return;
        }
        ++v0;
      }
      while ( *(_BYTE *)(v0 - 1) );
    }
    else
    {
      sub_41576B();
    }
  }
}
// 414CF0: variable 'v1' is possibly undefined
// 414D1B: variable 'v0' is possibly undefined

//----- (0000000000414D40) ----------------------------------------------------
__int64 __fastcall sub_414D40()
{
  unsigned __int8 *v0; // rdi
  unsigned int *v1; // rsi
  __int64 v2; // rax
  unsigned int v3; // ebx
  unsigned int v4; // edx
  __int64 result; // rax
  unsigned __int8 v6; // al
  unsigned int v7; // ecx
  unsigned int v8; // er8
  unsigned int v9; // er9
  __int64 v10; // rcx

  v2 = 1i64;
  v3 = *v0;
  if ( (v3 & 0xC0) == 0x80 )
  {
    while ( 1 )
    {
      v4 = v2 + 1;
      v6 = v0[v2];
      if ( (v6 & 0xC0) != 0x80 )
        break;
      v2 = v4;
    }
    v3 = v6;
    if ( v6 <= 0x7Fu )
      goto LABEL_3;
  }
  else
  {
    v4 = 1;
    if ( v3 <= 0x7F )
    {
LABEL_3:
      if ( v1 )
        *v1 = v3;
      return v4;
    }
  }
  if ( v3 > 0xFB )
  {
    v3 &= 3u;
    v8 = 6;
  }
  else
  {
    v7 = v3;
    LOBYTE(v7) = ~(_BYTE)v3;
    _BitScanReverse(&v7, v7);
    v8 = 7 - v7;
    v3 &= ((1 << v7) - 1) | 3;
    if ( v7 == 7 || v7 == 6 )
      goto LABEL_3;
  }
  v9 = 1 - v4;
  while ( 1 )
  {
    v10 = v4++;
    if ( (v0[v10] & 0xC0) != 0x80 )
      break;
    v3 = v0[v10] & 0x3F | (v3 << 6);
    if ( v8 <= v9 + v4 )
      goto LABEL_3;
  }
  result = 0xFFFFFFFFi64;
  if ( v1 )
    *v1 = 65533;
  return result;
}
// 414D50: variable 'v0' is possibly undefined
// 414D6C: variable 'v1' is possibly undefined

//----- (0000000000414E40) ----------------------------------------------------
unsigned __int64 __fastcall sub_414E40(__int64 a1, const __m128i *a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  const __m128i *v4; // r10
  unsigned __int64 v5; // r8
  __int64 v6; // r9
  unsigned __int64 v7; // rcx
  __int64 v8; // rbx
  const __m128i *v9; // rax
  __m128i si128; // xmm3
  int v11; // edi
  __int64 v12; // r11
  __int16 v13; // ax
  __int16 v14; // ax
  unsigned __int64 v15; // rax
  unsigned __int64 i; // rdx
  unsigned __int64 v17; // r11
  __m128i v18; // xmm0
  __m128i v19; // xmm1
  __int16 *v20; // rdx
  int v22; // edx
  __int64 v23; // rbx
  __m128i v24[2]; // [rsp+0h] [rbp-20h] BYREF

  v4 = a2;
  v5 = 0i64;
  v6 = v2;
  v7 = 0i64;
  v8 = 0i64;
  v9 = a2;
  si128 = _mm_load_si128((const __m128i *)&xmmword_418A20);
  if ( ((unsigned __int8)a2 & 0xF) == 0 )
    goto LABEL_13;
  while ( 1 )
  {
    v11 = a2->m128i_u16[0];
    v12 = v8 + 1;
    v13 = a2->m128i_i16[0];
    if ( !a2->m128i_i16[0] )
    {
LABEL_19:
      if ( v3 <= v7 )
        return v5;
      goto LABEL_20;
    }
LABEL_3:
    v14 = v13 & 0xFC00;
    if ( v14 != -9216 )
      break;
LABEL_12:
    v8 = v12;
    v7 = v5;
    a2 = (const __m128i *)((char *)v4 + 2 * v12);
    v9 = a2;
    if ( ((unsigned __int8)a2 & 0xF) == 0 )
    {
LABEL_13:
      v17 = v5 + 8;
      v24[0] = 0i64;
      if ( v3 > v5 + 8 )
      {
        v18 = 0i64;
        while ( 1 )
        {
          v19 = _mm_loadu_si128(v9);
          a2 = v9;
          v5 = v7;
          if ( _mm_movemask_epi8(_mm_andnot_si128(_mm_cmpgt_epi16(v19, si128), _mm_cmpgt_epi16(v19, v18))) != 0xFFFF )
            break;
          ++v9;
          v8 += 8i64;
          *(_QWORD *)(v6 + v7) = _mm_packs_epi16(v19, v19).m128i_u64[0];
          v7 += 8i64;
          if ( v17 + 8 >= v3 )
          {
            v20 = &v4->m128i_i16[v8];
            v7 = v17;
            v5 = v17;
            v11 = (unsigned __int16)*v20;
            v12 = v8 + 1;
            v13 = *v20;
            if ( *v20 )
              goto LABEL_3;
            goto LABEL_19;
          }
          v18 = _mm_load_si128(v24);
          v17 += 8i64;
        }
      }
    }
  }
  if ( v14 != -10240 )
  {
LABEL_5:
    v15 = v11;
    if ( (unsigned int)v11 > 0x7F )
      v15 = sub_414845();
    if ( v15 )
    {
      for ( i = v5 + 1; i < v3; ++i )
      {
        *(_BYTE *)(v6 + i - 1) = v15;
        v15 >>= 8;
        v5 = i;
        if ( !v15 )
          break;
      }
    }
    goto LABEL_12;
  }
  v22 = v4->m128i_u16[v12];
  v23 = v8 + 2;
  if ( v4->m128i_i16[v12] )
  {
    v12 = v23;
    v11 = v22 + (v11 << 10) - 56613888;
    goto LABEL_5;
  }
  if ( v3 > v7 )
LABEL_20:
    *(_BYTE *)(v6 + v7) = 0;
  return v5;
}
// 414E47: variable 'v2' is possibly undefined
// 414EA7: variable 'v5' is possibly undefined
// 414EAE: variable 'v3' is possibly undefined
// 414EC1: variable 'v6' is possibly undefined
// 414ECF: variable 'v12' is possibly undefined
// 414ED5: variable 'v4' is possibly undefined
// 418A20: using guessed type __int128 xmmword_418A20;
// 414E40: using guessed type __m128i var_20[2];

//----- (0000000000414FC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_414FC0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  unsigned __int64 result; // rax
  __int64 v6; // rdx
  unsigned __int8 *v7; // rcx
  unsigned __int64 v8; // r12
  unsigned __int8 *v9; // r9
  unsigned __int8 v10; // r9
  __int64 v11; // r13
  unsigned __int8 v12; // cl
  unsigned int v13; // er8
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // r8
  __m128i v17; // xmm0
  int v18; // er9
  __int64 v19; // rcx
  __int64 v20; // r13
  unsigned int v21; // er9
  char v22; // r9
  unsigned int v23; // er9
  unsigned int v24; // ecx

  result = 0i64;
  v6 = 0i64;
LABEL_2:
  v7 = (unsigned __int8 *)(a2 + v6);
  v8 = result;
  v9 = (unsigned __int8 *)(a2 + v6);
  if ( (((_BYTE)a2 + (_BYTE)v6) & 0xF) == 0 )
    goto LABEL_10;
  while ( 1 )
  {
LABEL_3:
    v10 = *v9;
    v11 = v6 + 1;
    v12 = v10;
    if ( (v10 & 0xC0) == 128 )
    {
      ++v6;
      goto LABEL_2;
    }
    v13 = v10;
    if ( (v10 & 0x80) == 0 )
      break;
    if ( v10 > 0xFBu )
    {
      v18 = 5;
      v13 = v12 & 3;
      goto LABEL_18;
    }
    _BitScanReverse(&v24, (unsigned __int8)~v10);
    v13 = (((1 << v24) - 1) | 3) & v10;
    v18 = 6 - v24;
    if ( v24 == 6 )
      break;
LABEL_18:
    v19 = v6 + 2;
    v20 = v6 + (unsigned int)(v18 - 1) + 3;
    do
    {
      v22 = *(_BYTE *)(a2 + v19 - 1);
      v6 = v19;
      if ( !v22 )
        goto LABEL_21;
      v21 = (v13 << 6) | v22 & 0x3F;
      ++v19;
      v13 = v21;
    }
    while ( v20 != v6 + 1 );
    if ( !v21 )
      goto LABEL_21;
    if ( v21 <= 0xFFFF )
    {
      v11 = v6;
      goto LABEL_6;
    }
    v23 = v21 - 0x10000;
    v14 = 65533i64;
    if ( v23 <= 0xFFFFF )
      v14 = ((v23 >> 10) + 55296) | (((v13 & 0x3FF) + 56320) << 16);
LABEL_8:
    while ( 1 )
    {
      v15 = result++;
      if ( v3 <= result )
        break;
      *(_WORD *)(v2 + 2 * result - 2) = v14;
      v14 >>= 16;
      if ( !v14 )
        goto LABEL_2;
    }
    result = v15;
    v7 = (unsigned __int8 *)(a2 + v6);
    v9 = (unsigned __int8 *)(a2 + v6);
    v8 = v15;
    if ( (((_BYTE)a2 + (_BYTE)v6) & 0xF) == 0 )
    {
LABEL_10:
      v16 = result + 16;
      if ( v3 > result + 16 )
      {
        while ( 1 )
        {
          v17 = _mm_loadu_si128((const __m128i *)(a2 + v6));
          v9 = v7;
          result = v8;
          if ( _mm_movemask_epi8(_mm_cmpgt_epi8(v17, (__m128i)0i64)) != 0xFFFF )
            break;
          v6 += 16i64;
          *(__m128i *)(v2 + 2 * v8) = _mm_unpacklo_epi8(v17, (__m128i)0i64);
          v8 += 16i64;
          *(__m128i *)(v2 + 2 * v16 - 16) = _mm_unpackhi_epi8(v17, (__m128i)0i64);
          if ( v3 <= v16 + 16 )
          {
            v9 = (unsigned __int8 *)(a2 + v6);
            v8 = v16;
            result = v16;
            goto LABEL_3;
          }
          v16 += 16i64;
          v7 = (unsigned __int8 *)(a2 + v6);
        }
      }
    }
  }
  if ( v13 )
  {
LABEL_6:
    v14 = v13;
    v6 = v11;
    goto LABEL_8;
  }
LABEL_21:
  if ( v3 > v8 )
    *(_WORD *)(v2 + 2 * v8) = 0;
  return result;
}
// 415040: variable 'v2' is possibly undefined
// 415055: variable 'v3' is possibly undefined

//----- (0000000000415200) ----------------------------------------------------
__int64 __fastcall sub_415200(unsigned __int64 a1, const __m128i *a2)
{
  __m128i *v2; // rdi
  const __m128i *v3; // rsi
  __int64 result; // rax
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __int128 v7[3]; // [rsp+0h] [rbp-30h] BYREF

  result = 32i64;
  v5 = _mm_loadu_si128(a2);
  v6 = _mm_loadu_si128(v3);
  if ( a1 >= 2 )
    a1 = 2i64;
  v7[2] = 0i64;
  v7[0] = (__int128)v5;
  v7[1] = (__int128)v6;
  *v2 = _mm_loadu_si128((const __m128i *)&v7[a1]);
  return result;
}
// 415219: variable 'v3' is possibly undefined
// 415233: variable 'v2' is possibly undefined

//----- (0000000000415240) ----------------------------------------------------
__int64 __fastcall sub_415240(__int64 a1, char *a2)
{
  __int16 *v2; // rdi
  unsigned __int8 *v3; // rsi
  int v4; // eax
  __int16 v5; // cx
  int v6; // eax
  __int16 v7; // cx
  int v8; // eax
  __int16 v9; // cx
  int v10; // eax
  __int16 v11; // cx
  int v12; // eax
  __int16 v13; // cx
  int v14; // eax
  __int16 v15; // cx
  int v16; // eax
  __int16 v17; // cx
  int v18; // ecx
  int v19; // eax
  __int16 v20; // dx
  __int64 result; // rax

  v4 = *a2 * *v3 + v3[1] * a2[1];
  v5 = 0x7FFF;
  if ( v4 <= 0x7FFF )
  {
    v5 = 0x8000;
    if ( v4 >= -32768 )
      v5 = *a2 * *v3 + v3[1] * a2[1];
  }
  *v2 = v5;
  v6 = v3[2] * a2[2] + v3[3] * a2[3];
  v7 = 0x7FFF;
  if ( v6 <= 0x7FFF )
  {
    v7 = 0x8000;
    if ( v6 >= -32768 )
      v7 = v3[2] * a2[2] + v3[3] * a2[3];
  }
  v2[1] = v7;
  v8 = a2[4] * v3[4] + v3[5] * a2[5];
  v9 = 0x7FFF;
  if ( v8 <= 0x7FFF )
  {
    v9 = 0x8000;
    if ( v8 >= -32768 )
      v9 = a2[4] * v3[4] + v3[5] * a2[5];
  }
  v2[2] = v9;
  v10 = a2[6] * v3[6] + v3[7] * a2[7];
  v11 = 0x7FFF;
  if ( v10 <= 0x7FFF )
  {
    v11 = 0x8000;
    if ( v10 >= -32768 )
      v11 = a2[6] * v3[6] + v3[7] * a2[7];
  }
  v2[3] = v11;
  v12 = a2[8] * v3[8] + v3[9] * a2[9];
  v13 = 0x7FFF;
  if ( v12 <= 0x7FFF )
  {
    v13 = 0x8000;
    if ( v12 >= -32768 )
      v13 = a2[8] * v3[8] + v3[9] * a2[9];
  }
  v2[4] = v13;
  v14 = a2[10] * v3[10] + v3[11] * a2[11];
  v15 = 0x7FFF;
  if ( v14 <= 0x7FFF )
  {
    v15 = 0x8000;
    if ( v14 >= -32768 )
      v15 = a2[10] * v3[10] + v3[11] * a2[11];
  }
  v2[5] = v15;
  v16 = a2[12] * v3[12] + v3[13] * a2[13];
  v17 = 0x7FFF;
  if ( v16 <= 0x7FFF )
  {
    v17 = 0x8000;
    if ( v16 >= -32768 )
      v17 = a2[12] * v3[12] + v3[13] * a2[13];
  }
  v2[6] = v17;
  v18 = v3[15] * a2[15];
  v19 = a2[14] * v3[14];
  v20 = 0x7FFF;
  result = (unsigned int)(v18 + v19);
  if ( (int)result <= 0x7FFF )
  {
    v20 = 0x8000;
    if ( (int)result >= -32768 )
      v20 = result;
  }
  v2[7] = v20;
  return result;
}
// 415243: variable 'v3' is possibly undefined
// 415271: variable 'v2' is possibly undefined

//----- (00000000004153F4) ----------------------------------------------------
__int64 __fastcall sub_4153F4()
{
  unsigned __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  __int64 v3; // rax
  __int64 result; // rax

  if ( _BitScanReverse64((unsigned __int64 *)&v3, v1) )
    return (unsigned int)(v3 + 64);
  _BitScanReverse64((unsigned __int64 *)&result, v0);
  return result;
}
// 4153F8: variable 'v1' is possibly undefined
// 4153FE: variable 'v0' is possibly undefined

//----- (0000000000415409) ----------------------------------------------------
#error "41541D: switch analysis failed: switch information is incomplete or incorrect (funcsize=22)"

//----- (0000000000415469) ----------------------------------------------------
__int64 sub_415469()
{
  return sub_415898(11, 0x346DC5D63886594Bi64);
}

//----- (000000000041547A) ----------------------------------------------------
__int64 sub_41547A()
{
  return sub_415898(7, 0x20C49BA5E353F7CFi64);
}

//----- (000000000041548B) ----------------------------------------------------
__int64 __fastcall sub_41548B()
{
  __int64 v0; // rdi

  return v0 / 100;
}
// 4154A7: variable 'v0' is possibly undefined

//----- (00000000004154C0) ----------------------------------------------------
void __fastcall sub_4154C0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx

  v2 = 32i64;
  if ( a2 < 0x20 )
    v2 = a2;
  __asm { jmp     qword_41C500[rcx*8] }
}
// 4154D0: unbalanced stack, ignored a potential tail call

//----- (00000000004154D7) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_4154D7(__int64 a1, unsigned __int64 _RDX)
{
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  __int8 *v11; // rsi
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx

  if ( _RDX >= 0x400 )
  {
    if ( _RDX > qword_41C088 )
    {
      *_RDI = _mm_loadu_si128(_RSI);
      v9 = ((unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0ui64) - (_QWORD)_RDI;
      v10 = (unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0ui64;
      v11 = &_RSI->m128i_i8[v9];
      v12 = _RDX - v9;
      v13 = 16i64;
      do
      {
        v13 += 16i64;
        _mm_stream_si128((__m128i *)(v10 + v13 - 32), _mm_loadu_si128((const __m128i *)&v11[v13 - 32]));
      }
      while ( v12 > v13 );
      _mm_sfence();
      *(__m128i *)(v10 + v12 - 16) = _mm_loadu_si128((const __m128i *)&v11[v12 - 16]);
    }
    else
    {
      qmemcpy(_RDI, _RSI, _RDX);
    }
  }
  else
  {
    __asm { vmovdqu ymm4, ymmword ptr [rsi+rdx-20h] }
    _RCX = 32i64;
    do
    {
      _RCX += 32i64;
      __asm
      {
        vmovdqu ymm3, ymmword ptr [rsi+rcx-40h]
        vmovdqu ymmword ptr [rdi+rcx-40h], ymm3
      }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm4
      vpxor   ymm4, ymm4, ymm4
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 415564: positive sp value 8 has been found
// 4154D7: could not find valid save-restore pair for rbp
// 4155A3: variable '_RDI' is possibly undefined
// 4155A3: variable '_RSI' is possibly undefined
// 41C088: using guessed type __int64 qword_41C088;

//----- (00000000004155FC) ----------------------------------------------------
void __fastcall sub_4155FC(__int64 a1, __int64 a2)
{
  _BYTE *v2; // rdi
  _BYTE *v3; // rsi
  __int64 v4; // rcx

  v4 = a2;
  if ( v2 >= v3 )
  {
    v2 = &v2[a2 - 1];
    v3 = &v3[a2 - 1];
  }
  while ( v4 )
  {
    *v2-- = *v3--;
    --v4;
  }
}
// 415608: variable 'v2' is possibly undefined
// 415608: variable 'v3' is possibly undefined

//----- (000000000041561F) ----------------------------------------------------
void __fastcall sub_41561F(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx

  v2 = 32i64;
  if ( a2 < 0x20 )
    v2 = a2;
  __asm { jmp     qword ptr [rbx+rcx*8] }
}
// 415639: unbalanced stack, ignored a potential tail call

//----- (000000000041563C) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_41563C(__int64 a1, unsigned __int64 _RDX, __int64 a3, double _XMM3_8)
{
  char v5; // si

  if ( _RDX >= 0x400 )
  {
    memset(_RDI, v5, _RDX);
  }
  else
  {
    __asm { vpbroadcastb ymm3, xmm3 }
    _RCX = 32i64;
    do
    {
      _RCX += 32i64;
      __asm { vmovdqu ymmword ptr [rdi+rcx-40h], ymm3 }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 4156A4: positive sp value 10 has been found
// 41563C: could not find valid save-restore pair for rbx
// 41563C: could not find valid save-restore pair for rbp
// 41563C: inconsistent variable size for 'xmm3_8.8(_XMM3_8)'

//----- (00000000004156EF) ----------------------------------------------------
__int64 __fastcall sub_4156EF()
{
  __int64 v0; // rbx
  __int64 v1; // rbp
  _QWORD *v2; // rdi
  __int64 v3; // r12
  __int64 v4; // r13
  __int64 v5; // r14
  __int64 v6; // r15
  void *retaddr; // [rsp+0h] [rbp+0h]
  char v9; // [rsp+8h] [rbp+8h] BYREF

  *v2 = &v9;
  v2[1] = v0;
  v2[2] = v1;
  v2[3] = v3;
  v2[4] = v4;
  v2[5] = v5;
  v2[6] = v6;
  v2[7] = retaddr;
  return 0i64;
}
// 4156F4: variable 'v2' is possibly undefined
// 4156F7: variable 'v0' is possibly undefined
// 4156FB: variable 'v1' is possibly undefined
// 4156FF: variable 'v3' is possibly undefined
// 415703: variable 'v4' is possibly undefined
// 415707: variable 'v5' is possibly undefined
// 41570B: variable 'v6' is possibly undefined
// 4156EF: using guessed type __int64 __fastcall sub_4156EF();

//----- (000000000041571A) ----------------------------------------------------
char *__fastcall sub_41571A()
{
  __int64 v0; // rdi
  const __m128i *v1; // rax
  bool i; // zf
  __int64 v3; // rdx

  v1 = (const __m128i *)(v0 & 0xFFFFFFFFFFFFFFF0ui64);
  for ( i = !_BitScanForward(
               (unsigned int *)&v3,
               (unsigned int)_mm_movemask_epi8(
                               _mm_cmpeq_epi8(
                                 _mm_load_si128((const __m128i *)(v0 & 0xFFFFFFFFFFFFFFF0ui64)),
                                 (__m128i)0i64)) >> (v0 & 0xF) << (v0 & 0xF));
        i;
        i = !_BitScanForward((unsigned int *)&v3, _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v1), (__m128i)0i64))) )
  {
    ++v1;
  }
  return (char *)v1 + v3 - v0;
}
// 415726: variable 'v0' is possibly undefined
// 415758: variable 'v3' is possibly undefined

//----- (0000000000415760) ----------------------------------------------------
void sub_415760()
{
  JUMPOUT(0x415772i64);
}
// 415768: control flows out of bounds to 415772

//----- (000000000041576B) ----------------------------------------------------
void sub_41576B()
{
  JUMPOUT(0x4157B1i64);
}
// 41577D: control flows out of bounds to 4157B1

//----- (0000000000415783) ----------------------------------------------------
void sub_415783()
{
  JUMPOUT(0x4157B1i64);
}
// 415792: control flows out of bounds to 4157B1

//----- (0000000000415794) ----------------------------------------------------
__int64 __fastcall sub_415794()
{
  __int64 v0; // rdi
  __int64 result; // rax

  result = 0i64;
  if ( v0 )
    JUMPOUT(0x4157ACi64);
  return result;
}
// 4157A0: control flows out of bounds to 4157AC
// 4157A0: variable 'v0' is possibly undefined
// 415794: using guessed type __int64 __fastcall sub_415794();

//----- (00000000004157A4) ----------------------------------------------------
char *__fastcall sub_4157A4()
{
  __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  bool v3; // cf
  bool v13; // zf
  __m128i v15; // xmm0
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm1
  __m128i si128; // xmm4
  __m128i v20; // xmm4

  _RAX = (const __m128i *)(v0 - 1);
  while ( 1 )
  {
    _RAX = (const __m128i *)((char *)_RAX + 1);
    v3 = v1-- == 0;
    if ( v3 )
      return (char *)_RAX - v0;
    if ( ((unsigned __int8)_RAX & 0x1F) == 0 )
    {
      _XMM0 = _mm_cvtsi32_si128(0);
      _XMM1 = _XMM0;
      _RAX -= 2;
      if ( (byte_41C03C & 0x20) != 0 )
      {
        __asm
        {
          vpbroadcastb ymm0, xmm0
          vpbroadcastb ymm1, xmm1
        }
        while ( 1 )
        {
          _RAX += 2;
          v3 = v1 < 0x20;
          v1 -= 32i64;
          if ( v3 )
            break;
          __asm
          {
            vmovdqa ymm2, ymmword ptr [rax]
            vpcmpeqb ymm3, ymm2, ymm0
            vpcmpeqb ymm2, ymm2, ymm1
            vpor    ymm2, ymm2, ymm3
            vpmovmskb ecx, ymm2
          }
          v13 = !_BitScanForward((unsigned int *)&_RCX, _RCX);
          if ( !v13 )
          {
            __asm { vzeroupper }
            goto LABEL_13;
          }
        }
      }
      else
      {
        v15 = _mm_unpacklo_epi8(_XMM0, _XMM0);
        v16 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v15, v15), 0);
        v17 = _mm_unpacklo_epi8(_XMM1, _XMM1);
        v18 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v17, v17), 0);
        while ( 1 )
        {
          _RAX += 2;
          v3 = v1 < 0x20;
          v1 -= 32i64;
          if ( v3 )
            break;
          si128 = _mm_load_si128(_RAX + 1);
          LODWORD(_RCX) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(si128, v16), _mm_cmpeq_epi8(si128, v18)));
          v20 = _mm_load_si128(_RAX);
          v13 = !_BitScanForward(
                   (unsigned int *)&_RCX,
                   _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v20, v16), _mm_cmpeq_epi8(v20, v18))) | ((_DWORD)_RCX << 16));
          if ( !v13 )
          {
LABEL_13:
            _RAX = (const __m128i *)((char *)_RAX + _RCX);
            goto LABEL_4;
          }
        }
      }
      v1 += 32i64;
    }
LABEL_4:
    if ( !_RAX->m128i_i8[0] )
      return (char *)_RAX - v0;
  }
}
// 4157B1: variable 'v0' is possibly undefined
// 4157B9: variable 'v1' is possibly undefined
// 415830: variable '_RCX' is possibly undefined
// 41C03C: using guessed type char byte_41C03C;

//----- (0000000000415898) ----------------------------------------------------
__int64 __fastcall sub_415898(char a1, __int64 a2)
{
  __int64 v2; // rdi

  return ((__int64)((unsigned __int128)(a2 * (__int128)v2) >> 64) >> a1) - (v2 >> 63);
}
// 41589F: variable 'v2' is possibly undefined

//----- (00000000004158B1) ----------------------------------------------------
__int64 __fastcall sub_4158B1()
{
  __int64 v0; // rdi
  unsigned int v1; // esi
  __int64 result; // rax

  for ( result = 0i64; (unsigned int)result < v1 && *(_WORD *)(v0 + 2 * result); result = (unsigned int)(result + 1) )
    ;
  return result;
}
// 4158B9: variable 'v1' is possibly undefined
// 4158BB: variable 'v0' is possibly undefined

//----- (00000000004158C8) ----------------------------------------------------
__int64 __fastcall sub_4158C8()
{
  __int64 v0; // rdi
  unsigned int v1; // esi
  __int64 result; // rax

  for ( result = 0i64; (unsigned int)result < v1 && *(_DWORD *)(v0 + 4 * result); result = (unsigned int)(result + 1) )
    ;
  return result;
}
// 4158D0: variable 'v1' is possibly undefined
// 4158D2: variable 'v0' is possibly undefined

//----- (0000000000416001) ----------------------------------------------------
void __fastcall __noreturn sub_416001()
{
  unsigned __int8 v0; // di

  if ( (dword_41C718 & 4) != 0 )
    ExitProcess(v0);
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_416033);
  __halt();
}
// 416012: variable 'v0' is possibly undefined
// 41C718: using guessed type int dword_41C718;

//----- (0000000000416040) ----------------------------------------------------
void __fastcall sub_416040(double a1, double a2, double a3, double a4)
{
  const void *v4; // rdi
  DWORD v5; // esi
  HANDLE StdHandle; // r12
  DWORD NumberOfBytesWritten; // [rsp+Ch] [rbp-124h] BYREF

  sub_41633B(a1, a2, a3, a4);
  StdHandle = GetStdHandle(0xFFFFFFF4);
  WriteFile(StdHandle, v4, v5, &NumberOfBytesWritten, 0i64);
  FlushFileBuffers(StdHandle);
  sub_4162C8();
}
// 416090: variable 'v4' is possibly undefined
// 416090: variable 'v5' is possibly undefined

//----- (00000000004160C0) ----------------------------------------------------
void __fastcall sub_4160C0(double a1, double a2, double a3, double a4)
{
  unsigned __int64 v4; // r9

  if ( WriteFile == (BOOL (__stdcall *)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))sub_40116A || !WriteFile )
  {
    v4 = qword_440908;
    if ( qword_440908 <= 0 )
      v4 = (-(__int64)((dword_41C718 & 8) == 0) & 0xFFFFFFFFFE000000ui64) + 33554436;
    __asm { syscall; Low latency system call }
    if ( v4 == -1i64 && !dword_41C718 && !qword_440908 )
      __asm { syscall; Low latency system call }
  }
  else
  {
    sub_416040(a1, a2, a3, a4);
  }
}
// 4160DA: ignored the value written to the shadow area of the succeeding call
// 4160C0: could not find valid save-restore pair for rbp
// 41C718: using guessed type int dword_41C718;
// 440908: using guessed type __int64 qword_440908;

//----- (0000000000416150) ----------------------------------------------------
void __fastcall sub_416150(double a1, double a2, double a3, double a4)
{
  _BYTE *v4; // rdi
  __int64 v5; // rsi

  v5 = 0i64;
  if ( *v4 )
  {
    do
      ++v5;
    while ( v4[v5] );
  }
  sub_4160C0(a1, a2, a3, a4);
}
// 416153: variable 'v4' is possibly undefined

//----- (0000000000416180) ----------------------------------------------------
__int64 __fastcall sub_416180()
{
  void *v0; // rdi
  SIZE_T v1; // rsi
  __int64 result; // rax
  DWORD v3; // eax
  int flOldProtect[5]; // [rsp+Ch] [rbp-14h] BYREF

  if ( (dword_41C718 & 4) != 0 )
  {
    v3 = sub_416220();
    if ( VirtualProtect(v0, v1, v3, (PDWORD)flOldProtect) )
      return 0i64;
    LODWORD(result) = sub_4162A0();
  }
  else
  {
    LODWORD(result) = qword_4408F0;
    __asm { syscall; Low latency system call }
    if ( (unsigned __int64)qword_4408F0 > 0xFFFFFFFFFFFFF000ui64 )
    {
      dword_448020 = -(int)qword_4408F0;
      return 0xFFFFFFFFi64;
    }
  }
  return (unsigned int)result;
}
// 4161FA: variable 'v0' is possibly undefined
// 4161FA: variable 'v1' is possibly undefined
// 41C718: using guessed type int dword_41C718;
// 4408F0: using guessed type __int64 qword_4408F0;
// 448020: using guessed type int dword_448020;
// 416180: using guessed type DWORD flOldProtect[5];

//----- (0000000000416220) ----------------------------------------------------
__int64 __fastcall sub_416220()
{
  int v0; // edi
  int v1; // esi
  int v2; // eax
  int v3; // esi

  v2 = v1;
  if ( (v0 & 7) != 7 )
  {
    v3 = 4;
    if ( (v0 & 3) != 3 )
    {
      v3 = 32;
      if ( (v0 & 5) != 5 )
      {
        v3 = (v0 & 1) + 1;
        if ( (v0 & 4) != 0 )
          v3 = 16;
      }
    }
    return v3 | (v0 | v2) & 0xDD000000;
  }
  v3 = 64;
  if ( (v2 & 1) != 0 )
    return v3 | (v0 | v2) & 0xDD000000;
  if ( qword_4408C8 != (qword_4408C8 & v2) )
    v3 = 128;
  return v3 | (v0 | v2) & 0xDD000000;
}
// 416222: variable 'v1' is possibly undefined
// 416224: variable 'v0' is possibly undefined
// 4408C8: using guessed type __int64 qword_4408C8;

//----- (00000000004162A0) ----------------------------------------------------
__int64 sub_4162A0()
{
  if ( (dword_41C718 & 4) != 0 )
    return sub_4162B0();
  else
    return sub_402B9F();
}
// 41C718: using guessed type int dword_41C718;

//----- (00000000004162B0) ----------------------------------------------------
__int64 sub_4162B0()
{
  dword_448020 = sub_405F8E();
  return -1i64;
}
// 448020: using guessed type int dword_448020;

//----- (00000000004162C8) ----------------------------------------------------
void sub_4162C8()
{
  ;
}

//----- (0000000000416315) ----------------------------------------------------
__int64 __fastcall sub_416315()
{
  __int64 v0; // rdi

  return (*(__int64 (**)(void))(v0 + 56))();
}
// 416338: variable 'v0' is possibly undefined

//----- (000000000041633B) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_41633B(double a1, double a2, double a3, double a4)
{
  _OWORD *v4; // rdi
  __int128 v5; // xmm4
  __int128 v6; // xmm5
  __int128 v7; // xmm6
  __int128 v8; // xmm7
  __int128 v9; // xmm8
  __int128 v10; // xmm9
  __int128 v11; // xmm10
  __int128 v12; // xmm11
  __int128 v13; // xmm12
  __int128 v14; // xmm13
  __int128 v15; // xmm14
  __int128 v16; // xmm15

  *(v4 - 8) = *(_OWORD *)&a1;
  *(v4 - 7) = *(_OWORD *)&a2;
  *(v4 - 6) = *(_OWORD *)&a3;
  *(v4 - 5) = *(_OWORD *)&a4;
  *(v4 - 4) = v5;
  *(v4 - 3) = v6;
  *(v4 - 2) = v7;
  *(v4 - 1) = v8;
  *v4 = v9;
  v4[1] = v10;
  v4[2] = v11;
  v4[3] = v12;
  v4[4] = v13;
  v4[5] = v14;
  v4[6] = v15;
  v4[7] = v16;
}
// 41633B: inconsistent variable size for 'xmm0_8.8'
// 41633B: inconsistent variable size for 'xmm1_8.8'
// 41633B: inconsistent variable size for 'xmm2_8.8'
// 41633B: inconsistent variable size for 'xmm3_8.8'

// nfuncs=425 queued=416 decompiled=416 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 416 function(s)"
