/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2);
__int64 __fastcall sub_400748(int, int);
void __fastcall __noreturn sub_401000(__int64, __int64, __int64);
__int64 __fastcall sub_401158(unsigned __int64, int, __int64, __int64 *);
void sub_4012F0();
__int64 sub_401460();
void __fastcall sub_401466(__int64, __int64);
__int64 __fastcall sub_4014BA(__int64, __int64, __int64);
__int64 __fastcall sub_40150F(_QWORD *, unsigned __int8 *, __int64, int);
void __fastcall __noreturn sub_40153D(unsigned int, __int64, __int64);
__int64 sub_401556();
__int64 sub_401566();
__int64 __fastcall sub_4017B1(unsigned __int16 **);
unsigned __int64 __fastcall sub_4017DC(__int64, unsigned int);
__int64 __fastcall sub_40180C(unsigned __int16 *, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_401A19(__int64, __int64, __int64);
__int64 __fastcall sub_401A32(__int64, __int64, __int64, __int64);
__int64 sub_401A48();
__int64 __fastcall sub_401A5E(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_401A74(__int64, __int64, __int64);
__int64 sub_401ACC(void); // weak
__int64 __fastcall sub_401AD2(_QWORD *, __int64, __int64);
__int64 __fastcall sub_401B19(__int64);
_BOOL8 __fastcall sub_401DD6(_QWORD *, unsigned __int64);
__int64 __fastcall sub_401F12(__int64, __int64, unsigned __int64);
unsigned __int64 __fastcall sub_40238E(unsigned __int64);
void __fastcall sub_403312(__int64);
void __fastcall sub_403817(unsigned __int64, __int64);
__int64 *__fastcall sub_403873(__int64, __int64 *, unsigned __int64);
__int64 *__fastcall sub_403C02(__int64 a1, unsigned __int64 a2);
void __fastcall sub_403CBB(__int64, __int64);
__int64 __fastcall sub_403D42(__int64);
__int64 __fastcall sub_403D56(__int64, __int64);
__int64 __fastcall sub_403D6A(__int64);
__int64 sub_404008();
__int64 __fastcall sub_40400E(__int64, __int64);
__int64 __fastcall sub_4041E6(__int64, __int64, __int64);
__int64 __fastcall sub_40427B(int, __int64, int);
__int64 sub_40429B();
__int64 __fastcall sub_4042A8(char, int);
__int64 sub_4042F0();
__int64 sub_404300();
__int64 __fastcall sub_404310(); // weak
__int64 __fastcall sub_40436D(__int64, _DWORD *);
__int64 __fastcall sub_40437C(__int64);
__int64 __fastcall sub_4043AF(__int64, _DWORD *);
void __fastcall sub_404420(__int64, __int64, unsigned __int64);
void __fastcall sub_404434(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX);
void __fastcall sub_404542(_BYTE *, _BYTE *, __int64);
void __fastcall sub_404562(__int64, __int64, unsigned __int64);
void __fastcall sub_40457C(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3);
__int64 __fastcall sub_404690(__int64, __int64, unsigned int);
void __fastcall __noreturn sub_4046C1(__int64, __int64, __int64);
__int64 __fastcall sub_4046FA(int, int);
__int64 sub_404786();

//-------------------------------------------------------------------------
// Data declarations

int dword_400000 = -17958193; // weak
char byte_4046F2[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
__int64 qword_4047C0[2] = { 24LL, 0LL }; // weak
char byte_4047E7[2] = { '\x01', '\xC0' }; // weak
__int64 (__fastcall *qword_405010)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x4AD8LL; // weak
__int64 (__fastcall *qword_405018)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x4AE6LL; // weak
__int64 (__fastcall *qword_405030)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x4B20LL; // weak
__int64 (*qword_405070)(void) = (__int64 (*)(void))0x4BD4LL; // weak
__int64 qword_405078 = 19428LL; // weak
__int64 (__fastcall *qword_405088)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x4C04LL; // weak
__int64 (__fastcall *qword_405098)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x4C36LL; // weak
__int64 qword_436000; // weak
char byte_43603D; // weak
int dword_4362B8; // weak
__int64 (*qword_4362C0)(void); // weak
int dword_436340; // weak
int dword_436348; // weak
__int64 qword_436360; // weak
int dword_436368; // weak
int dword_4363E0; // weak
int dword_4363E4; // weak
__int64 qword_4363E8[]; // weak
__int64 qword_4363F0; // weak
__int64 qword_4363F8; // weak
__int64 qword_436400; // weak
__int64 qword_436408; // weak
__int64 qword_436410; // weak
__int64 qword_436418; // weak
__int64 qword_436420; // weak
_UNKNOWN unk_436428; // weak
_UNKNOWN unk_436628; // weak
__int64 qword_436638[32]; // weak
__int64 qword_436738; // weak
__int64 qword_436740; // weak
__int64 qword_436748; // weak
int dword_436750; // weak
__int64 qword_436758; // weak
__int64 qword_436760; // weak
__int64 qword_436768; // weak
int dword_436770; // weak
__int64 qword_4367A0; // weak
__int64 qword_4367A8; // weak
__int64 qword_4367B0; // weak
__int64 qword_4367B8; // weak
__int64 qword_4367C0; // weak
int dword_4367C8; // weak
__int64 qword_4367E0; // weak
_UNKNOWN unk_436AF8; // weak
__int64 qword_436B00[]; // weak
int dword_436B08[]; // weak
int dword_436B0C[595]; // weak
_BYTE byte_437458[8]; // weak
_BYTE byte_437460[8]; // weak
__int64 qword_437468[303]; // weak
_UNKNOWN unk_437DE0; // weak
int dword_437FA8; // weak
int dword_437FB0; // weak
int dword_437FB4; // weak


//----- (0000000000400675) ----------------------------------------------------
void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2)
{
  unsigned __int8 v2; // al

  while ( 1 )
  {
    v2 = __inbyte(a2 + 5);
    if ( (v2 & 0x20) != 0 )
      break;
    _mm_pause();
  }
  __outbyte(a2, a1);
}

//----- (0000000000400748) ----------------------------------------------------
__int64 __fastcall sub_400748(int a1, int a2)
{
  qmemcpy((void *)(a1 & 0xFFFF8000), (const void *)(unsigned int)(a1 - a2), a1 - a2 - (a1 & 0xFFFF8000));
  return (unsigned int)(a1 - a2);
}

//----- (0000000000401000) ----------------------------------------------------
void __fastcall __noreturn sub_401000(__int64 a1, __int64 a2, __int64 a3)
{
  dword_437FB4 |= 2u;
  if ( (dword_4362B8 & 4) == 0 )
  {
    a3 = 0LL;
    __asm
    {
      syscall; Low latency system call
      syscall; Low latency system call
    }
    a2 = 6LL;
    __asm { syscall; Low latency system call }
  }
  sub_4046C1(134LL, a2, a3);
}
// 4362B8: using guessed type int dword_4362B8;
// 437FB4: using guessed type int dword_437FB4;

//----- (0000000000401158) ----------------------------------------------------
__int64 __fastcall sub_401158(unsigned __int64 a1, int a2, __int64 a3, __int64 *a4)
{
  char i; // cl
  __int64 v6; // rax
  __int64 *v8; // rdx
  __int64 v9; // rax

  for ( i = 39; ; i -= 9 )
  {
    --a2;
    v6 = (a1 >> i) & 0x1FF;
    if ( a2 == -1 )
      break;
    v8 = (__int64 *)(a3 + 8 * v6);
    if ( !*v8 )
    {
      v9 = *a4 - 4096;
      *a4 = v9;
      *v8 = v9 | 3;
    }
    a3 = *v8 & 0x3FFFFFFFFF000LL;
  }
  return a3 + 8 * v6;
}

//----- (000000000040129E) ----------------------------------------------------
#error "40129E: function frame is wrong (funcsize=0)"

//----- (00000000004012F0) ----------------------------------------------------
void sub_4012F0()
{
  __int64 *i; // rdi
  _DWORD *v6; // rdi

  qword_436000 = __rdtsc();
  i = &qword_436000 + 1;
  _RAX = 0LL;
  while ( 1 )
  {
    __asm { cpuid }
    *(_DWORD *)i = _RAX;
    v6 = (_DWORD *)i + 1;
    *v6++ = _RBX;
    *v6++ = _RCX;
    *v6 = _RDX;
    for ( i = (__int64 *)(v6 + 1); ; i += 2 )
    {
      _RAX = 1LL;
      if ( *((_BYTE *)&qword_436000 + 8) )
        break;
    }
  }
}
// 4012F0: could not find valid save-restore pair for rbx
// 40132B: conditional instruction was optimized away because %0x10.4==1
// 405080: using guessed type __int64 (__fastcall *qword_405080)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 436000: using guessed type __int64 qword_436000;

//----- (0000000000401460) ----------------------------------------------------
__int64 sub_401460()
{
  return 42LL;
}

//----- (0000000000401466) ----------------------------------------------------
void __fastcall sub_401466(__int64 a1, __int64 a2)
{
  sub_403CBB(a1, a2);
}

//----- (00000000004014BA) ----------------------------------------------------
__int64 __fastcall sub_4014BA(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rbp
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 result; // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_405078;
  unk_437DE0 = 3LL;
  *((_QWORD *)&unk_437DE0 + 2) = (char *)&unk_437DE0 + 24;
  *((_QWORD *)&unk_437DE0 + 1) = 16LL;
  *((_DWORD *)&unk_437DE0 + 10) = 1;
  *((_DWORD *)&unk_437DE0 + 16) = 1;
  *((_DWORD *)&unk_437DE0 + 22) = 1;
  *((_QWORD *)&unk_437DE0 + 3) = v3(a1, a2, a3, -10LL);
  *((_QWORD *)&unk_437DE0 + 6) = v3(a1, a2, v4, -11LL);
  result = v3(a1, a2, v5, -12LL);
  *((_QWORD *)&unk_437DE0 + 9) = result;
  return result;
}
// 4014F7: variable 'v4' is possibly undefined
// 401500: variable 'v5' is possibly undefined
// 405078: using guessed type __int64 qword_405078;

//----- (000000000040150F) ----------------------------------------------------
__int64 __fastcall sub_40150F(_QWORD *a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  char v4; // zf
  __int64 v5; // rax

  do
  {
    v5 = *a2++;
    *a1++ = a3 + v5;
    --a4;
  }
  while ( a4 );
  *a1 = a3 + a2[(unsigned __int8)((2 * !v4) | ((byte_43603D & 2) != 0))];
  return *(_QWORD *)a2;
}
// 40150F: variable 'v4' is possibly undefined
// 43603D: using guessed type char byte_43603D;

//----- (000000000040153D) ----------------------------------------------------
void __fastcall __noreturn sub_40153D(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx

  sub_4041E6(0LL, a2, a3);
  sub_4046C1(a1, a2, v3);
}
// 401551: variable 'v3' is possibly undefined

//----- (0000000000401556) ----------------------------------------------------
__int64 sub_401556()
{
  dword_437FB0 = dword_436340;
  return -1LL;
}
// 436340: using guessed type int dword_436340;
// 437FB0: using guessed type int dword_437FB0;

//----- (0000000000401566) ----------------------------------------------------
__int64 sub_401566()
{
  dword_437FB0 = dword_436348;
  return -1LL;
}
// 436348: using guessed type int dword_436348;
// 437FB0: using guessed type int dword_437FB0;

//----- (00000000004017B1) ----------------------------------------------------
__int64 __fastcall sub_4017B1(unsigned __int16 **a1)
{
  unsigned __int16 **v1; // rdx
  unsigned __int16 *v2; // rdi
  int v3; // eax
  unsigned int v4; // eax
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  v3 = *v2;
  if ( (unsigned __int16)v3 > 0xD7FFu )
  {
    v4 = sub_40436D((__int64)v2, (_DWORD *)v1 + 6);
  }
  else
  {
    *((_DWORD *)v1 + 6) = v3;
    v4 = 1;
  }
  result = 2LL * v4;
  *v1 = (unsigned __int16 *)((char *)*v1 + result);
  return result;
}
// 4017D8: variable 'v1' is possibly undefined

//----- (00000000004017DC) ----------------------------------------------------
unsigned __int64 __fastcall sub_4017DC(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  _BYTE *v5; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 16);
  result = (int)a2;
  if ( a2 > 0x7F )
    result = sub_40437C(a2);
  do
  {
    v5 = *(_BYTE **)(v2 + 8);
    if ( v3 <= (unsigned __int64)v5 )
      break;
    *(_QWORD *)(v2 + 8) = v5 + 1;
    *v5 = result;
    result >>= 8;
  }
  while ( result );
  return result;
}
// 4017F2: variable 'v2' is possibly undefined
// 4017F9: variable 'v3' is possibly undefined

//----- (000000000040180C) ----------------------------------------------------
__int64 __fastcall sub_40180C(unsigned __int16 *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // r10
  __int64 v7; // r10
  __int64 v8; // r11
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r10
  unsigned __int64 v12; // rax
  bool v13; // r14
  unsigned __int64 v14; // r12
  __int64 v15; // r9
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  __int64 v18; // r9
  bool v19; // cf
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // r12
  unsigned __int64 v24; // [rsp+0h] [rbp-60h]
  unsigned __int16 *v26; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v27; // [rsp+18h] [rbp-48h]
  unsigned __int64 v28; // [rsp+20h] [rbp-40h]
  unsigned int v29; // [rsp+28h] [rbp-38h]

  v4 = 0x100002600LL;
  v5 = 0LL;
  v26 = a1;
  v27 = a2;
  v28 = a2 + a3;
  sub_4017B1(&v26);
LABEL_2:
  if ( v29 )
  {
    while ( 1 )
    {
      if ( !v29 )
        goto LABEL_7;
      if ( v29 > 0x20 || !_bittest64(&v4, v29) )
        break;
      sub_4017B1(&v26);
    }
    if ( ++v5 < v6 )
    {
      v12 = v27;
      if ( v27 >= v28 )
        v12 = 0LL;
      *(_QWORD *)(a4 + 8 * v5 - 8) = v12;
    }
    v13 = 0;
    while ( 1 )
    {
      if ( !v29 )
      {
LABEL_45:
        sub_4017DC((__int64)&v26, 0);
        goto LABEL_2;
      }
      if ( v13 || v29 > 0x20 )
      {
        if ( v29 != 34 && v29 != 92 )
          goto LABEL_44;
        v14 = 0LL;
        while ( v29 == 92 )
        {
          ++v14;
          sub_4017B1(&v26);
        }
        v15 = 0LL;
        while ( v29 == 34 )
        {
          sub_4017B1(&v26);
          v15 = v16 + 1;
        }
        v17 = v14;
        if ( v15 )
        {
          while ( v17 > 1 )
          {
            v24 = v17;
            sub_4017DC((__int64)&v26, 0x5Cu);
            v17 = v24 - 2;
          }
          if ( (v14 & 1) == 0 || (sub_4017DC((__int64)&v26, 0x22u), (v15 = v18 - 1) != 0) )
          {
            v19 = !v13;
            v20 = 3LL;
            v21 = v15 - v19;
            v22 = v21 + 1;
            while ( v22 >= v20 )
            {
              v20 += 3LL;
              sub_4017DC((__int64)&v26, 0x22u);
            }
            v13 = v21 % 3 == 0;
          }
        }
        else
        {
          while ( --v14 != -1LL )
            sub_4017DC((__int64)&v26, 0x5Cu);
        }
      }
      else
      {
        if ( _bittest64(&v4, v29) )
          goto LABEL_45;
LABEL_44:
        sub_4017DC((__int64)&v26, v29);
        sub_4017B1(&v26);
      }
    }
  }
LABEL_7:
  sub_4017DC((__int64)&v26, 0);
  if ( v8 )
  {
    v9 = v8 - 1;
    v10 = v27 - a2;
    if ( v27 - a2 > v9 )
      v10 = v9;
    *(_BYTE *)(a2 + v10) = 0;
  }
  if ( v7 )
  {
    v11 = v7 - 1;
    if ( v11 > v5 )
      v11 = v5;
    *(_QWORD *)(a4 + 8 * v11) = 0LL;
  }
  return (unsigned int)v5;
}
// 401880: variable 'v8' is possibly undefined
// 40189C: variable 'v7' is possibly undefined
// 4018C3: variable 'v6' is possibly undefined
// 401938: variable 'v16' is possibly undefined
// 401994: variable 'v18' is possibly undefined
// 4019A7: variable 'v15' is possibly undefined
// 4019D2: variable 'v21' is possibly undefined

//----- (0000000000401A19) ----------------------------------------------------
__int64 __fastcall sub_401A19(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_405010(a1, a2, a3, a1);
}
// 405010: using guessed type __int64 (__fastcall *qword_405010)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401A32) ----------------------------------------------------
__int64 __fastcall sub_401A32(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_405018(a1, a2, a2, a1, a3, a4);
}
// 405018: using guessed type __int64 (__fastcall *qword_405018)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401A48) ----------------------------------------------------
__int64 sub_401A48()
{
  return qword_405070();
}
// 405070: using guessed type __int64 (*qword_405070)(void);

//----- (0000000000401A5E) ----------------------------------------------------
__int64 __fastcall sub_401A5E(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_405088(a1, a2, a2, a1, a3, a4);
}
// 405088: using guessed type __int64 (__fastcall *qword_405088)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401A74) ----------------------------------------------------
__int64 __fastcall sub_401A74(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_405098(a1, a2, a3, a1);
}
// 405098: using guessed type __int64 (__fastcall *qword_405098)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401AD2) ----------------------------------------------------
__int64 __fastcall sub_401AD2(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax

  v3 = a2 & 0xF;
  if ( (a2 & 0xF) != 0 )
    v3 = -((_DWORD)a2 + 16) & 0xF;
  a1[5] = a2 + v3;
  a1[2] = a3 - v3;
  *(_QWORD *)(a2 + v3 + 8) = (a3 - v3) | 1;
  result = qword_4367C0;
  *(_QWORD *)(a2 + a3 + 8) = 80LL;
  a1[6] = result;
  return result;
}
// 4367C0: using guessed type __int64 qword_4367C0;

//----- (0000000000401B19) ----------------------------------------------------
__int64 __fastcall sub_401B19(__int64 a1)
{
  __int64 v1; // r14
  __int64 v3; // rax
  int v4; // er13
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // r8
  _QWORD *v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  _QWORD *v13; // rcx
  _QWORD *v14; // rdx
  _QWORD *v15; // r9
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rdx
  unsigned __int64 v20; // rdx
  unsigned int v21; // eax
  int v22; // edx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v29; // [rsp+8h] [rbp-38h]

  v1 = 0LL;
  v3 = *(_QWORD *)(a1 + 904);
  if ( v3 )
  {
    if ( (*(_DWORD *)(v3 + 24) & 1) != 0 )
    {
      v4 = *(_DWORD *)(v3 + 24) & 8;
      if ( !v4 )
      {
        v5 = *(_QWORD *)v3;
        v6 = *(_QWORD *)v3 & 0xFLL;
        if ( (*(_QWORD *)v3 & 0xF) != 0 )
          v6 = -(*(_DWORD *)v3 + 16) & 0xF;
        v7 = v5 + v6;
        v1 = 0LL;
        if ( (*(_QWORD *)(v5 + v6 + 8) & 3LL) == 1 )
        {
          v1 = *(_QWORD *)(v3 + 8);
          v8 = *(_QWORD *)(v5 + v6 + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( v7 + v8 < v5 + v1 - 80 )
            goto LABEL_48;
          v9 = *(_QWORD *)(v3 + 16);
          if ( *(_QWORD *)(a1 + 32) == v7 )
          {
            *(_QWORD *)(a1 + 32) = 0LL;
            *(_QWORD *)(a1 + 8) = 0LL;
            goto LABEL_32;
          }
          v10 = *(_QWORD **)(v7 + 24);
          v11 = *(_QWORD *)(v7 + 48);
          if ( v10 != (_QWORD *)v7 )
          {
            v12 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v12 + 24) = v10;
            v10[2] = v12;
            goto LABEL_19;
          }
          v10 = (_QWORD *)v10[5];
          v13 = (_QWORD *)(v7 + 40);
          if ( !v10 )
          {
            v10 = *(_QWORD **)(v7 + 32);
            if ( !v10 )
              goto LABEL_19;
            v13 = (_QWORD *)(v7 + 32);
          }
          v14 = v10;
          do
          {
            do
            {
              v15 = v13;
              v10 = v14;
              v13 = v14 + 5;
              v14 = (_QWORD *)v14[5];
            }
            while ( v14 );
            v14 = (_QWORD *)v10[4];
            v13 = v10 + 4;
          }
          while ( v14 );
          *v15 = 0LL;
LABEL_19:
          if ( v11 )
          {
            v16 = *(unsigned int *)(v7 + 56);
            v17 = a1 + 8 * v16;
            if ( *(_QWORD *)(v17 + 600) == v7 )
            {
              *(_QWORD *)(v17 + 600) = v10;
              if ( !v10 )
              {
                *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v16);
                goto LABEL_32;
              }
            }
            else
            {
              if ( *(_QWORD *)(v11 + 32) == v7 )
                *(_QWORD *)(v11 + 32) = v10;
              else
                *(_QWORD *)(v11 + 40) = v10;
              if ( !v10 )
                goto LABEL_32;
            }
            v18 = *(_QWORD *)(v7 + 32);
            v10[6] = v11;
            if ( v18 )
            {
              v10[4] = v18;
              *(_QWORD *)(v18 + 48) = v10;
            }
            v19 = *(_QWORD *)(v7 + 40);
            if ( v19 )
            {
              v10[5] = v19;
              *(_QWORD *)(v19 + 48) = v10;
            }
          }
LABEL_32:
          v29 = v9;
          if ( !(unsigned int)sub_403D56(v5, v1) )
          {
            *(_QWORD *)(a1 + 856) -= v1;
            *(_QWORD *)(a1 + 904) = v29;
            goto LABEL_49;
          }
          v20 = v8 >> 8;
          v21 = v8 >> 8;
          if ( v21 )
          {
            v21 = 31;
            if ( (unsigned int)v20 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v20, v20);
              v21 = ((v8 >> (38 - ((unsigned __int8)v20 ^ 0x1Fu))) & 1) + 2 * (31 - (v20 ^ 0x1F));
            }
          }
          v22 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)(v7 + 56) = v21;
          *(_QWORD *)(v7 + 40) = 0LL;
          *(_QWORD *)(v7 + 32) = 0LL;
          if ( ((1 << v21) & v22) != 0 )
          {
            v23 = *(_QWORD *)(a1 + 8LL * v21 + 600);
            if ( v21 != 31 )
              LOBYTE(v4) = 57 - (v21 >> 1);
            v24 = v8 << v4;
            while ( (*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v8 )
            {
              v25 = v24;
              v24 *= 2LL;
              v26 = (v25 >> 63) + 4;
              if ( !*(_QWORD *)(v23 + 8 * v26) )
              {
                *(_QWORD *)(v23 + 8 * v26) = v7;
                *(_QWORD *)(v7 + 48) = v23;
                goto LABEL_46;
              }
              v23 = *(_QWORD *)(v23 + 8 * v26);
            }
            v27 = *(_QWORD *)(v23 + 16);
            *(_QWORD *)(v27 + 24) = v7;
            *(_QWORD *)(v23 + 16) = v7;
            *(_QWORD *)(v7 + 16) = v27;
            *(_QWORD *)(v7 + 24) = v23;
            *(_QWORD *)(v7 + 48) = 0LL;
          }
          else
          {
            *(_DWORD *)(a1 + 4) = (1 << v21) | v22;
            *(_QWORD *)(a1 + 8LL * v21 + 600) = v7;
            *(_QWORD *)(v7 + 48) = a1 + 8LL * v21 + 600;
LABEL_46:
            *(_QWORD *)(v7 + 24) = v7;
            *(_QWORD *)(v7 + 16) = v7;
          }
LABEL_48:
          v1 = 0LL;
        }
      }
    }
  }
LABEL_49:
  *(_QWORD *)(a1 + 56) = 128LL;
  return v1;
}

//----- (0000000000401DD6) ----------------------------------------------------
_BOOL8 __fastcall sub_401DD6(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  _QWORD *v8; // rcx
  unsigned __int64 *v9; // r13
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r9
  int v12; // eax
  unsigned __int64 v13; // r14
  __int64 v14; // rdx

  if ( a2 > 0xFFFFFFFFFFFFFF7FLL || (v3 = a1[5]) == 0 )
  {
LABEL_2:
    v2 = 0LL;
    return v2 != 0;
  }
  v5 = a1[2];
  v6 = a2 + 80;
  if ( v5 > v6 )
  {
    v8 = a1 + 111;
    v9 = a1 + 111;
    while ( 1 )
    {
      v10 = *v9;
      if ( v3 >= *v9 )
      {
        v11 = v9[1];
        if ( v3 < v10 + v11 )
          break;
      }
      v9 = (unsigned __int64 *)v9[2];
      if ( !v9 )
        BUG();
    }
    v12 = *((_DWORD *)v9 + 6);
    if ( (v12 & 8) == 0 && (v12 & 1) != 0 )
    {
      v7 = qword_4367B0 * ((v5 + qword_4367B0 - 1 - v6) / qword_4367B0 - 1);
      if ( v7 <= v11 )
      {
        while ( v10 > (unsigned __int64)v8 || v10 + v11 <= (unsigned __int64)v8 )
        {
          v8 = (_QWORD *)v8[2];
          if ( !v8 )
          {
            v13 = v11 - v7;
            if ( sub_404008() == -1 && (unsigned int)sub_403D56(v13 + *v9, v7) )
              break;
            if ( v7 )
            {
              v9[1] -= v7;
              v14 = a1[2];
              a1[107] -= v7;
              sub_401AD2(a1, a1[5], v14 - v7);
            }
            goto LABEL_21;
          }
        }
      }
    }
  }
  v7 = 0LL;
LABEL_21:
  v2 = sub_401B19((__int64)a1) + v7;
  if ( !v2 )
  {
    if ( a1[2] > a1[6] )
    {
      a1[6] = -1LL;
      return v2 != 0;
    }
    goto LABEL_2;
  }
  return v2 != 0;
}
// 4367B0: using guessed type __int64 qword_4367B0;

//----- (0000000000401F12) ----------------------------------------------------
__int64 __fastcall sub_401F12(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rdi
  __int64 result; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r8
  __int64 v8; // r12
  unsigned __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  __int64 v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r10
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  _QWORD *v25; // rax
  _QWORD *v26; // rsi
  __int64 v27; // r8
  __int64 v28; // rcx
  _QWORD *v29; // r9
  _QWORD *v30; // rcx
  _QWORD *v31; // r11
  __int64 v32; // rcx
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // rcx
  unsigned __int64 v36; // rcx
  __int64 v37; // rdx
  unsigned __int64 v38; // rsi
  unsigned int v39; // eax
  int v40; // esi
  int v41; // ecx
  __int64 v42; // r8
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rax

  v4 = a2;
  result = *(_QWORD *)(a2 + 8);
  v6 = a3 + a2;
  if ( (result & 1) != 0 )
    goto LABEL_34;
  v7 = *(_QWORD *)v4;
  v4 -= *(_QWORD *)v4;
  if ( (result & 3) == 0 )
  {
    v8 = v7 + a3 + 32;
    result = sub_403D56(v4, v8);
    if ( !(_DWORD)result )
      *(_QWORD *)(a1 + 856) -= v8;
    return result;
  }
  a3 += v7;
  if ( *(_QWORD *)(a1 + 32) == v4 )
  {
    result = *(_QWORD *)(v6 + 8);
    if ( (result & 3) == 3 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      *(_QWORD *)(v6 + 8) = result & 0xFFFFFFFFFFFFFFFELL;
      result = a3 | 1;
      *(_QWORD *)(v4 + 8) = a3 | 1;
      *(_QWORD *)v6 = a3;
      return result;
    }
    goto LABEL_34;
  }
  result = *(_QWORD *)(v4 + 24);
  v9 = v7 >> 3;
  if ( v7 <= 0xFF )
  {
    v10 = *(_QWORD *)(v4 + 16);
    if ( v10 == result )
    {
      result = (unsigned int)__ROL4__(-2, v9);
      *(_DWORD *)a1 &= result;
    }
    else
    {
      *(_QWORD *)(v10 + 24) = result;
      *(_QWORD *)(result + 16) = v10;
    }
    goto LABEL_34;
  }
  v11 = *(_QWORD *)(v4 + 48);
  if ( v4 == result )
  {
    result = *(_QWORD *)(v4 + 40);
    v13 = (_QWORD *)(v4 + 40);
    if ( !result )
    {
      result = *(_QWORD *)(v4 + 32);
      if ( !result )
        goto LABEL_19;
      v13 = (_QWORD *)(v4 + 32);
    }
    v14 = result;
    do
    {
      do
      {
        v15 = v13;
        result = v14;
        v13 = (_QWORD *)(v14 + 40);
        v14 = *(_QWORD *)(v14 + 40);
      }
      while ( v14 );
      v14 = *(_QWORD *)(result + 32);
      v13 = (_QWORD *)(result + 32);
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_19;
  }
  v12 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v12 + 24) = result;
  *(_QWORD *)(result + 16) = v12;
LABEL_19:
  if ( !v11 )
    goto LABEL_34;
  v16 = *(unsigned int *)(v4 + 56);
  v17 = a1 + 8 * v16;
  if ( *(_QWORD *)(v17 + 600) == v4 )
  {
    *(_QWORD *)(v17 + 600) = result;
    if ( !result )
    {
      result = (unsigned int)__ROL4__(-2, v16);
      *(_DWORD *)(a1 + 4) &= result;
      goto LABEL_34;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v4 )
      *(_QWORD *)(v11 + 32) = result;
    else
      *(_QWORD *)(v11 + 40) = result;
    if ( !result )
      goto LABEL_34;
  }
  v18 = *(_QWORD *)(v4 + 32);
  *(_QWORD *)(result + 48) = v11;
  if ( v18 )
  {
    *(_QWORD *)(result + 32) = v18;
    *(_QWORD *)(v18 + 48) = result;
  }
  v19 = *(_QWORD *)(v4 + 40);
  if ( v19 )
  {
    *(_QWORD *)(result + 40) = v19;
    *(_QWORD *)(v19 + 48) = result;
  }
LABEL_34:
  v20 = *(_QWORD *)(v6 + 8);
  if ( (v20 & 2) == 0 )
  {
    v21 = *(_QWORD *)(a1 + 32);
    if ( *(_QWORD *)(a1 + 40) == v6 )
    {
      v22 = *(_QWORD *)(a1 + 16) + a3;
      *(_QWORD *)(a1 + 40) = v4;
      *(_QWORD *)(a1 + 16) = v22;
      *(_QWORD *)(v4 + 8) = v22 | 1;
      if ( v4 == v21 )
      {
        *(_QWORD *)(a1 + 32) = 0LL;
        *(_QWORD *)(a1 + 8) = 0LL;
      }
      return result;
    }
    if ( v6 == v21 )
    {
      v23 = *(_QWORD *)(a1 + 8) + a3;
      *(_QWORD *)(a1 + 32) = v4;
      *(_QWORD *)(a1 + 8) = v23;
      result = v23 | 1;
      *(_QWORD *)(v4 + 8) = v23 | 1;
      *(_QWORD *)(v4 + v23) = v23;
      return result;
    }
    v24 = v20 & 0xFFFFFFFFFFFFFFF8LL;
    v25 = *(_QWORD **)(v6 + 24);
    a3 += v24;
    if ( v24 <= 0xF8 )
    {
      v26 = *(_QWORD **)(v6 + 16);
      if ( v26 == v25 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v24 >> 3);
      }
      else
      {
        v26[3] = v25;
        v25[2] = v26;
      }
      goto LABEL_66;
    }
    v27 = *(_QWORD *)(v6 + 48);
    if ( (_QWORD *)v6 != v25 )
    {
      v28 = *(_QWORD *)(v6 + 16);
      *(_QWORD *)(v28 + 24) = v25;
      v25[2] = v28;
      goto LABEL_53;
    }
    v25 = *(_QWORD **)(v6 + 40);
    v29 = (_QWORD *)(v6 + 40);
    if ( !v25 )
    {
      v25 = *(_QWORD **)(v6 + 32);
      if ( !v25 )
        goto LABEL_53;
      v29 = (_QWORD *)(v6 + 32);
    }
    v30 = v25;
    do
    {
      do
      {
        v31 = v29;
        v25 = v30;
        v29 = v30 + 5;
        v30 = (_QWORD *)v30[5];
      }
      while ( v30 );
      v30 = (_QWORD *)v25[4];
      v29 = v25 + 4;
    }
    while ( v30 );
    *v31 = 0LL;
LABEL_53:
    if ( !v27 )
      goto LABEL_66;
    v32 = *(unsigned int *)(v6 + 56);
    v33 = a1 + 8 * v32;
    if ( *(_QWORD *)(v33 + 600) == v6 )
    {
      *(_QWORD *)(v33 + 600) = v25;
      if ( !v25 )
      {
        *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v32);
        goto LABEL_66;
      }
    }
    else
    {
      if ( *(_QWORD *)(v27 + 32) == v6 )
        *(_QWORD *)(v27 + 32) = v25;
      else
        *(_QWORD *)(v27 + 40) = v25;
      if ( !v25 )
        goto LABEL_66;
    }
    v34 = *(_QWORD *)(v6 + 32);
    v25[6] = v27;
    if ( v34 )
    {
      v25[4] = v34;
      *(_QWORD *)(v34 + 48) = v25;
    }
    v35 = *(_QWORD *)(v6 + 40);
    if ( v35 )
    {
      v25[5] = v35;
      *(_QWORD *)(v35 + 48) = v25;
    }
LABEL_66:
    result = a3 | 1;
    *(_QWORD *)(v4 + 8) = a3 | 1;
    *(_QWORD *)(v4 + a3) = a3;
    if ( v4 == v21 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      return result;
    }
    goto LABEL_69;
  }
  *(_QWORD *)(v6 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v4 + 8) = a3 | 1;
  *(_QWORD *)(v4 + a3) = a3;
LABEL_69:
  v36 = a3 >> 3;
  if ( a3 > 0xFF )
  {
    v38 = a3 >> 8;
    v39 = a3 >> 8;
    if ( v39 )
    {
      v39 = 31;
      if ( (unsigned int)v38 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v38, v38);
        v39 = ((a3 >> (38 - ((unsigned __int8)v38 ^ 0x1Fu))) & 1) + 2 * (31 - (v38 ^ 0x1F));
      }
    }
    v40 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v4 + 56) = v39;
    *(_QWORD *)(v4 + 40) = 0LL;
    v41 = 1 << v39;
    *(_QWORD *)(v4 + 32) = 0LL;
    v42 = v39;
    if ( ((1 << v39) & v40) != 0 )
    {
      v43 = 0;
      v44 = *(_QWORD *)(a1 + 8LL * v39 + 600);
      if ( v39 != 31 )
        v43 = 57 - (v39 >> 1);
      v45 = a3 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != a3 )
      {
        v46 = v45;
        v45 *= 2LL;
        result = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * result) )
        {
          *(_QWORD *)(v44 + 8 * result) = v4;
          *(_QWORD *)(v4 + 48) = v44;
          goto LABEL_86;
        }
        v44 = *(_QWORD *)(v44 + 8 * result);
      }
      result = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(result + 24) = v4;
      *(_QWORD *)(v44 + 16) = v4;
      *(_QWORD *)(v4 + 16) = result;
      *(_QWORD *)(v4 + 24) = v44;
      *(_QWORD *)(v4 + 48) = 0LL;
    }
    else
    {
      result = a1 + 8LL * v39 + 600;
      *(_DWORD *)(a1 + 4) = v41 | v40;
      *(_QWORD *)(a1 + 8 * v42 + 600) = v4;
      *(_QWORD *)(v4 + 48) = result;
LABEL_86:
      *(_QWORD *)(v4 + 24) = v4;
      *(_QWORD *)(v4 + 16) = v4;
    }
  }
  else
  {
    result = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    if ( ((1 << v36) & *(_DWORD *)a1) != 0 )
    {
      v37 = *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88);
    }
    else
    {
      *(_DWORD *)a1 |= 1 << v36;
      v37 = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    }
    *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88) = v4;
    *(_QWORD *)(v37 + 24) = v4;
    *(_QWORD *)(v4 + 16) = v37;
    *(_QWORD *)(v4 + 24) = result;
  }
  return result;
}

//----- (000000000040238E) ----------------------------------------------------
unsigned __int64 __fastcall sub_40238E(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  int v2; // esi
  unsigned __int64 v3; // rcx
  unsigned int v4; // eax
  int v5; // ecx
  char *v6; // rdi
  __int128 v7; // rax
  __int64 v8; // r8
  unsigned __int64 v9; // r9
  int v10; // eax
  int v11; // ecx
  __int64 v12; // rdi
  char *v13; // r10
  __int64 v14; // r11
  __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // rdx
  int v19; // er11
  char *v20; // r8
  char *v21; // rcx
  int v22; // edi
  unsigned int v23; // eax
  __int64 v24; // rcx
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r12
  __int64 v28; // rcx
  __int64 v29; // r11
  __int64 v30; // rcx
  _QWORD *v31; // r13
  __int64 v32; // r11
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // r10
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  int v38; // er9
  char *v39; // rdi
  char *v40; // rcx
  unsigned __int64 v41; // rbx
  int v42; // edi
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r9
  unsigned int v45; // esi
  char v46; // cl
  __int64 v47; // r11
  __int64 v48; // r10
  unsigned __int64 i; // rcx
  unsigned __int64 v50; // rdx
  unsigned int v51; // eax
  __int64 v52; // rcx
  __int64 v53; // rsi
  unsigned __int64 v54; // r10
  __int64 v55; // rcx
  __int64 v56; // r8
  __int64 v57; // rcx
  _QWORD *v58; // r11
  __int64 v59; // r8
  __int64 v60; // rcx
  __int64 v61; // rcx
  __int64 v62; // r8
  unsigned __int64 v63; // rcx
  int v64; // edi
  char *v65; // rdx
  char *v66; // rcx
  unsigned __int64 v67; // rsi
  unsigned int v68; // edx
  int v69; // esi
  char v70; // cl
  __int64 v71; // rsi
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // rdx
  __int64 v74; // rdx
  __int64 v75; // rdx
  unsigned __int64 v76; // rcx
  unsigned __int64 *v77; // rsi
  __int64 v78; // rdx
  unsigned __int64 v79; // r12
  unsigned __int64 v80; // r12
  unsigned __int64 v81; // r12
  unsigned __int64 v82; // r9
  __int64 v83; // rax
  __int64 v84; // r10
  _QWORD *v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rsi
  __int64 v88; // rax
  __int64 *v89; // rcx
  char v90; // r11
  __int64 v91; // rcx
  __int64 v92; // rdx
  __int64 v93; // rax
  unsigned __int64 v94; // r8
  __int64 v95; // r8
  unsigned __int64 v96; // rdi
  _QWORD *v97; // rsi
  unsigned __int64 v98; // rbx
  unsigned __int64 v99; // rcx
  _QWORD *v100; // rdi
  __int64 v101; // rdi
  __int64 v102; // rcx
  _QWORD *v103; // r10
  _QWORD *v104; // rcx
  _QWORD *v105; // r12
  __int64 v106; // r10
  int v107; // ecx
  __int64 v108; // rcx
  __int64 v109; // rcx
  unsigned __int64 v110; // rcx
  int v111; // edi
  char *v112; // rdx
  char *v113; // rcx
  unsigned __int64 v114; // rsi
  unsigned int v115; // edx
  int v116; // esi
  __int64 v117; // rsi
  unsigned __int64 v118; // rcx
  unsigned __int64 v119; // rdx
  __int64 v120; // rdx
  __int64 v121; // rdx
  unsigned __int64 v123; // r13
  __int64 v124; // r9
  __int64 v125; // r10
  _QWORD *v126; // r11
  _DWORD *v127; // rdi
  __int64 *v128; // rsi
  __int64 j; // rcx
  _QWORD *v130; // rax
  unsigned __int64 v131; // rsi
  unsigned __int64 v132; // rcx
  char *v133; // rax
  char *v134; // rdx
  unsigned __int64 v135; // rdx
  unsigned int v136; // eax
  int v137; // edx
  char v138; // cl
  __int64 v139; // rdx
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // rax

  if ( a1 <= 0xE0 )
  {
    v1 = 32LL;
    if ( a1 > 0xE )
      v1 = (a1 + 31) & 0xFFFFFFFFFFFFFFF0LL;
    v2 = dword_4363E0;
    v3 = v1 >> 3;
    v4 = (unsigned int)dword_4363E0 >> (v1 >> 3);
    if ( (v4 & 3) != 0 )
    {
      v5 = ((v4 & 1) == 0) + (_DWORD)v3;
      v6 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v5);
      *(_QWORD *)&v7 = *((_QWORD *)v6 + 2);
      v8 = *(_QWORD *)(v7 + 16);
      if ( v6 == (char *)v8 )
      {
        dword_4363E0 &= ~(1 << v5);
      }
      else
      {
        *(_QWORD *)(v8 + 24) = v6;
        *((_QWORD *)v6 + 2) = v8;
      }
      *(_QWORD *)(v7 + 8) = (8 * v5) | 3u;
      *(_QWORD *)(v7 + (unsigned int)(8 * v5) + 8) |= 1uLL;
      return v7 + 16;
    }
    v9 = qword_4363E8[0];
    if ( qword_4363E8[0] < v1 )
    {
      if ( v4 )
      {
        v10 = ((2 * (1 << v3)) | (-2 * (1 << v3))) & (v4 << v3);
        _BitScanForward((unsigned int *)&v3, -v10 & v10);
        v12 = (unsigned int)(8 * v11);
        v13 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v11);
        *(_QWORD *)&v7 = *((_QWORD *)v13 + 2);
        v14 = *(_QWORD *)(v7 + 16);
        if ( v13 == (char *)v14 )
        {
          dword_4363E0 &= ~(1 << v3);
        }
        else
        {
          *(_QWORD *)(v14 + 24) = v13;
          *((_QWORD *)v13 + 2) = v14;
        }
        *((_QWORD *)&v7 + 1) = v7 + v12;
        v15 = v12 - v1;
        if ( v12 - v1 > 0x1F )
        {
          v16 = v1;
          v17 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v16 | 3;
          *(_QWORD *)(v17 + 8) = v15 | 1;
          **((_QWORD **)&v7 + 1) = v15;
          if ( v9 )
          {
            v18 = qword_436400;
            v19 = 1 << (v9 >> 3);
            v20 = (char *)&unk_436428 + 16 * (unsigned int)(v9 >> 3);
            if ( (v19 & dword_4363E0) != 0 )
            {
              v21 = (char *)*((_QWORD *)v20 + 2);
            }
            else
            {
              v21 = (char *)&unk_436428 + 16 * (unsigned int)(v9 >> 3);
              dword_4363E0 |= v19;
            }
            *((_QWORD *)v20 + 2) = qword_436400;
            *((_QWORD *)v21 + 3) = v18;
            *(_QWORD *)(v18 + 16) = v21;
            *(_QWORD *)(v18 + 24) = v20;
          }
          qword_4363E8[0] = v15;
          qword_436400 = v17;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = (8 * (_DWORD)v3) | 3u;
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) |= 1uLL;
        }
        return v7 + 16;
      }
      v22 = dword_4363E4;
      if ( dword_4363E4 )
      {
        _BitScanForward(&v23, dword_4363E4 & -dword_4363E4);
        *(_QWORD *)&v7 = qword_436638[v23];
        v24 = v7;
        v25 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        while ( 1 )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
          {
            *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 40);
            if ( !*((_QWORD *)&v7 + 1) )
              break;
          }
          if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v25 )
          {
            v25 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
            *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
          }
          v24 = *((_QWORD *)&v7 + 1);
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
        v26 = *(_QWORD *)(v7 + 48);
        v27 = v1 + v25;
        if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
        {
          v28 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v28 + 24) = *((_QWORD *)&v7 + 1);
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v28;
          goto LABEL_38;
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
        v29 = v7 + 40;
        if ( !*((_QWORD *)&v7 + 1) )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
            goto LABEL_38;
          v29 = v7 + 32;
        }
        v30 = *((_QWORD *)&v7 + 1);
        do
        {
          do
          {
            v31 = (_QWORD *)v29;
            *((_QWORD *)&v7 + 1) = v30;
            v29 = v30 + 40;
            v30 = *(_QWORD *)(v30 + 40);
          }
          while ( v30 );
          v30 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
          v29 = *((_QWORD *)&v7 + 1) + 32LL;
        }
        while ( v30 );
        *v31 = 0LL;
LABEL_38:
        if ( v26 )
        {
          v32 = *(unsigned int *)(v7 + 56);
          if ( qword_436638[v32] == (_QWORD)v7 )
          {
            qword_4363E8[v32 + 74] = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
            {
LABEL_41:
              v33 = *(_QWORD *)(v7 + 32);
              *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v26;
              if ( v33 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v33;
                *(_QWORD *)(v33 + 48) = *((_QWORD *)&v7 + 1);
              }
              v34 = *(_QWORD *)(v7 + 40);
              if ( v34 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v34;
                *(_QWORD *)(v34 + 48) = *((_QWORD *)&v7 + 1);
              }
              goto LABEL_51;
            }
            dword_4363E4 = v22 & ~(1 << v32);
          }
          else
          {
            if ( *(_QWORD *)(v26 + 32) == (_QWORD)v7 )
              *(_QWORD *)(v26 + 32) = *((_QWORD *)&v7 + 1);
            else
              *(_QWORD *)(v26 + 40) = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
              goto LABEL_41;
          }
        }
LABEL_51:
        if ( v25 > 0x1F )
        {
          v35 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v1 | 3;
          *(_QWORD *)(v35 + 8) = v25 | 1;
          *(_QWORD *)(v35 + v25) = v25;
          if ( v9 )
          {
            v36 = qword_436400;
            v37 = v9 >> 3;
            v38 = 1 << (v9 >> 3);
            v39 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v37);
            if ( (v38 & v2) != 0 )
            {
              v40 = (char *)*((_QWORD *)v39 + 2);
            }
            else
            {
              v40 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v37);
              dword_4363E0 = v38 | v2;
            }
            *((_QWORD *)v39 + 2) = qword_436400;
            *((_QWORD *)v40 + 3) = v36;
            *(_QWORD *)(v36 + 16) = v40;
            *(_QWORD *)(v36 + 24) = v39;
          }
          qword_4363E8[0] = v25;
          qword_436400 = v7 + v1;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = v27 | 3;
          *(_QWORD *)(v7 + v27 + 8) |= 1uLL;
        }
        return v7 + 16;
      }
    }
    goto LABEL_133;
  }
  if ( a1 > 0xFFFFFFFFFFFFFF7FLL )
  {
    v1 = -1LL;
    goto LABEL_133;
  }
  v41 = a1 + 31;
  v42 = dword_4363E4;
  v1 = v41 & 0xFFFFFFFFFFFFFFF0LL;
  if ( !dword_4363E4 )
    goto LABEL_133;
  v43 = v1 >> 8;
  v44 = -(__int64)v1;
  v45 = v1 >> 8;
  if ( v45 )
  {
    v45 = 31;
    if ( (unsigned int)v43 <= 0xFFFF )
    {
      _BitScanReverse((unsigned int *)&v43, v43);
      v45 = ((v1 >> (38 - ((unsigned __int8)v43 ^ 0x1Fu))) & 1) + 2 * (31 - (v43 ^ 0x1F));
    }
  }
  v7 = (unsigned __int64)qword_436638[v45];
  if ( (_QWORD)v7 )
  {
    v46 = 0;
    if ( v45 != 31 )
      v46 = 57 - (v45 >> 1);
    v47 = 0LL;
    v48 = 0LL;
    for ( i = v1 << v46; ; i *= 2LL )
    {
      v50 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      if ( v50 < v44 )
      {
        if ( !v50 )
        {
          *((_QWORD *)&v7 + 1) = v7;
          v44 = 0LL;
          goto LABEL_78;
        }
        v44 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        v48 = v7;
      }
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
      *(_QWORD *)&v7 = *(_QWORD *)(v7 + 8 * ((i >> 63) + 4));
      if ( !*((_QWORD *)&v7 + 1) || *((_QWORD *)&v7 + 1) == (_QWORD)v7 )
        *((_QWORD *)&v7 + 1) = v47;
      if ( !(_QWORD)v7 )
        break;
      v47 = *((_QWORD *)&v7 + 1);
    }
    *(_QWORD *)&v7 = v48;
  }
LABEL_78:
  if ( v7 == 0 )
  {
    if ( (dword_4363E4 & (-2 << v45)) == 0 )
      goto LABEL_133;
    _BitScanForward(&v51, dword_4363E4 & (-2 << v45) & -(dword_4363E4 & (-2 << v45)));
    *((_QWORD *)&v7 + 1) = qword_436638[v51];
    *(_QWORD *)&v7 = 0LL;
  }
  while ( *((_QWORD *)&v7 + 1) )
  {
    if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v44 )
    {
      v44 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
    }
    v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
    if ( !v52 )
      v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL);
    *((_QWORD *)&v7 + 1) = v52;
  }
  if ( (_QWORD)v7 && v44 < qword_4363E8[0] - v1 )
  {
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
    v53 = *(_QWORD *)(v7 + 48);
    v54 = v1 + v44;
    if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
    {
      v55 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v55 + 24) = *((_QWORD *)&v7 + 1);
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v55;
      goto LABEL_98;
    }
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
    v56 = v7 + 40;
    if ( !*((_QWORD *)&v7 + 1) )
    {
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_98;
      v56 = v7 + 32;
    }
    v57 = *((_QWORD *)&v7 + 1);
    do
    {
      do
      {
        v58 = (_QWORD *)v56;
        *((_QWORD *)&v7 + 1) = v57;
        v56 = v57 + 40;
        v57 = *(_QWORD *)(v57 + 40);
      }
      while ( v57 );
      v57 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
      v56 = *((_QWORD *)&v7 + 1) + 32LL;
    }
    while ( v57 );
    *v58 = 0LL;
LABEL_98:
    if ( !v53 )
      goto LABEL_111;
    v59 = *(unsigned int *)(v7 + 56);
    if ( qword_436638[v59] == (_QWORD)v7 )
    {
      qword_4363E8[v59 + 74] = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
      {
        dword_4363E4 = v42 & ~(1 << v59);
        goto LABEL_111;
      }
    }
    else
    {
      if ( *(_QWORD *)(v53 + 32) == (_QWORD)v7 )
        *(_QWORD *)(v53 + 32) = *((_QWORD *)&v7 + 1);
      else
        *(_QWORD *)(v53 + 40) = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_111;
    }
    v60 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v53;
    if ( v60 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v60;
      *(_QWORD *)(v60 + 48) = *((_QWORD *)&v7 + 1);
    }
    v61 = *(_QWORD *)(v7 + 40);
    if ( v61 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v61;
      *(_QWORD *)(v61 + 48) = *((_QWORD *)&v7 + 1);
    }
LABEL_111:
    if ( v44 > 0x1F )
    {
      v62 = v7 + v1;
      v63 = v44 >> 3;
      *(_QWORD *)(v7 + 8) = v1 | 3;
      *(_QWORD *)(v62 + 8) = v44 | 1;
      *(_QWORD *)(v62 + v44) = v44;
      if ( v44 > 0xFF )
      {
        v67 = v44 >> 8;
        v68 = v44 >> 8;
        if ( v68 )
        {
          v68 = 31;
          if ( (unsigned int)v67 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v67, v67);
            v68 = ((v44 >> (38 - ((unsigned __int8)v67 ^ 0x1Fu))) & 1) + 2 * (31 - (v67 ^ 0x1F));
          }
        }
        v69 = dword_4363E4;
        *(_DWORD *)(v62 + 56) = v68;
        *(_QWORD *)(v62 + 40) = 0LL;
        *(_QWORD *)(v62 + 32) = 0LL;
        if ( ((1 << v68) & v69) != 0 )
        {
          v70 = 0;
          v71 = qword_436638[v68];
          if ( v68 != 31 )
            v70 = 57 - (v68 >> 1);
          v72 = v44 << v70;
          while ( v44 != (*(_QWORD *)(v71 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v73 = v72;
            v72 *= 2LL;
            v74 = (v73 >> 63) + 4;
            if ( !*(_QWORD *)(v71 + 8 * v74) )
            {
              *(_QWORD *)(v71 + 8 * v74) = v62;
              *(_QWORD *)(v62 + 48) = v71;
              goto LABEL_130;
            }
            v71 = *(_QWORD *)(v71 + 8 * v74);
          }
          v75 = *(_QWORD *)(v71 + 16);
          *(_QWORD *)(v75 + 24) = v62;
          *(_QWORD *)(v71 + 16) = v62;
          *(_QWORD *)(v62 + 16) = v75;
          *(_QWORD *)(v62 + 24) = v71;
          *(_QWORD *)(v62 + 48) = 0LL;
        }
        else
        {
          qword_436638[v68] = v62;
          dword_4363E4 = (1 << v68) | v69;
          *(_QWORD *)(v62 + 48) = &qword_436638[v68];
LABEL_130:
          *(_QWORD *)(v62 + 24) = v62;
          *(_QWORD *)(v62 + 16) = v62;
        }
      }
      else
      {
        v64 = 1 << v63;
        v65 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v63);
        if ( ((1 << v63) & dword_4363E0) != 0 )
        {
          v66 = (char *)*((_QWORD *)v65 + 2);
        }
        else
        {
          v66 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v63);
          dword_4363E0 |= v64;
        }
        *((_QWORD *)v65 + 2) = v62;
        *((_QWORD *)v66 + 3) = v62;
        *(_QWORD *)(v62 + 16) = v66;
        *(_QWORD *)(v62 + 24) = v65;
      }
    }
    else
    {
      *(_QWORD *)(v7 + 8) = v54 | 3;
      *(_QWORD *)(v7 + v54 + 8) |= 1uLL;
    }
    return v7 + 16;
  }
LABEL_133:
  if ( qword_4363E8[0] >= v1 )
  {
    *(_QWORD *)&v7 = qword_436400;
    v76 = qword_4363E8[0] - v1;
    v77 = (unsigned __int64 *)(qword_436400 + qword_4363E8[0]);
    if ( qword_4363E8[0] - v1 <= 0x1F )
    {
      *((_QWORD *)&v7 + 1) = qword_4363E8[0] | 3;
      qword_4363E8[0] = 0LL;
      qword_436400 = 0LL;
      *(_QWORD *)(v7 + 8) = *((_QWORD *)&v7 + 1);
      v77[1] |= 1uLL;
      return v7 + 16;
    }
    qword_4363E8[0] -= v1;
    qword_436400 += v1;
    *(_QWORD *)(qword_436400 + 8) = v76 | 1;
    *v77 = v76;
LABEL_262:
    *(_QWORD *)(v7 + 8) = v1 | 3;
    return v7 + 16;
  }
  if ( qword_4363F0 > v1 )
  {
    *((_QWORD *)&v7 + 1) = qword_4363F0 - v1;
LABEL_261:
    *(_QWORD *)&v7 = qword_436408;
    qword_4363F0 = *((_QWORD *)&v7 + 1);
    qword_436408 += v1;
    *(_QWORD *)(qword_436408 + 8) = *((_QWORD *)&v7 + 1) | 1LL;
    goto LABEL_262;
  }
  v78 = -qword_4367B0;
  if ( (dword_436750 & 1) != 0 && v1 >= qword_4367B8 )
  {
    if ( qword_4363F0 )
    {
      v79 = v78 & (v1 + qword_4367B0 + 62);
      if ( (!qword_436748 || qword_436738 < qword_436738 + v79 && qword_436748 >= qword_436738 + v79) && v1 < v79 )
      {
        *(_QWORD *)&v7 = sub_403D42(v78 & (v1 + qword_4367B0 + 62));
        *(_QWORD *)v7 = 0LL;
        *(_QWORD *)(v7 + 8) = v79 - 32;
        *((_QWORD *)&v7 + 1) = qword_4363F8;
        *(_QWORD *)(v7 + v79 - 24) = 11LL;
        *(_QWORD *)(v7 + v79 - 16) = 0LL;
        if ( !*((_QWORD *)&v7 + 1) || (unsigned __int64)v7 < *((_QWORD *)&v7 + 1) )
          qword_4363F8 = v7;
        v80 = qword_436738 + v79;
        qword_436738 = v80;
        if ( v80 > qword_436740 )
          qword_436740 = v80;
        return v7 + 16;
      }
    }
  }
  v81 = v78 & (v1 + qword_4367B0 + 95);
  if ( v1 < v81 && (!qword_436748 || qword_436738 < v81 + qword_436738 && qword_436748 >= v81 + qword_436738) )
  {
    v82 = sub_403D42(v81);
    v83 = v81 + qword_436738;
    qword_436738 += v81;
    if ( qword_436738 > (unsigned __int64)qword_436740 )
      qword_436740 = v83;
    v84 = qword_436408;
    if ( !qword_436408 )
    {
      if ( !qword_4363F8 || v82 < qword_4363F8 )
        qword_4363F8 = v82;
      qword_436758 = v82;
      qword_436760 = v81;
      dword_436770 = 1;
      qword_436418 = 128LL;
      qword_436420 = qword_4367A0;
      v85 = &unk_436428;
      do
      {
        v85[3] = v85;
        v85[2] = v85;
        v85 += 2;
      }
      while ( &unk_436628 != (_UNKNOWN *)v85 );
      v86 = v81 - 80;
      v87 = v82;
      goto LABEL_170;
    }
    v88 = qword_436758;
    if ( v82 == qword_436758 + qword_436760
      && (dword_436770 & 8) == 0
      && (dword_436770 & 1) != 0
      && qword_436408 >= (unsigned __int64)qword_436758
      && v82 > qword_436408 )
    {
      v87 = qword_436408;
      qword_436760 += v81;
      v86 = v81 + qword_4363F0;
LABEL_170:
      sub_401AD2(&dword_4363E0, v87, v86);
LABEL_259:
      if ( v1 < qword_4363F0 )
      {
        *((_QWORD *)&v7 + 1) = qword_4363F0 - v1;
        goto LABEL_261;
      }
      sub_401556();
      return 0LL;
    }
    if ( v82 < qword_4363F8 )
      qword_4363F8 = v82;
    v89 = &qword_436758;
    if ( qword_436758 != v82 + v81 || (v90 = dword_436770 & 8, (dword_436770 & 8) != 0) || (dword_436770 & 1) == 0 )
    {
      while ( 1 )
      {
        if ( qword_436408 >= (unsigned __int64)*v89 )
        {
          v123 = v89[1] + *v89;
          if ( qword_436408 < v123 )
            break;
        }
        v89 = (__int64 *)v89[2];
        if ( !v89 )
          BUG();
      }
      sub_401AD2(&dword_4363E0, v82, v81 - 80);
      v126[1] = 51LL;
      v127 = v126 + 2;
      v128 = &qword_436758;
      for ( j = 8LL; j; --j )
      {
        *v127 = *(_DWORD *)v128;
        v128 = (__int64 *)((char *)v128 + 4);
        ++v127;
      }
      qword_436768 = (__int64)(v126 + 2);
      v130 = v126 + 7;
      qword_436758 = v124;
      qword_436760 = v81;
      dword_436770 = 1;
      do
        *v130++ = 11LL;
      while ( v123 > (unsigned __int64)v130 );
      if ( (_QWORD *)v125 != v126 )
      {
        v126[1] &= ~1uLL;
        v131 = (unsigned __int64)v126 - v125;
        v132 = ((unsigned __int64)v126 - v125) >> 3;
        *(_QWORD *)(v125 + 8) = ((unsigned __int64)v126 - v125) | 1;
        *v126 = (char *)v126 - v125;
        if ( (unsigned __int64)v126 - v125 > 0xFF )
        {
          v135 = v131 >> 8;
          v136 = v131 >> 8;
          if ( v136 )
          {
            v136 = 31;
            if ( (unsigned int)v135 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v135, v135);
              v136 = ((v131 >> (38 - ((unsigned __int8)v135 ^ 0x1Fu))) & 1) + 2 * (31 - (v135 ^ 0x1F));
            }
          }
          v137 = dword_4363E4;
          *(_DWORD *)(v125 + 56) = v136;
          *(_QWORD *)(v125 + 40) = 0LL;
          *(_QWORD *)(v125 + 32) = 0LL;
          if ( ((1 << v136) & v137) != 0 )
          {
            v138 = 0;
            v139 = qword_436638[v136];
            if ( v136 != 31 )
              v138 = 57 - (v136 >> 1);
            v140 = v131 << v138;
            while ( v131 != (*(_QWORD *)(v139 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
            {
              v141 = v140;
              v140 *= 2LL;
              v142 = (v141 >> 63) + 4;
              if ( !*(_QWORD *)(v139 + 8 * v142) )
              {
                *(_QWORD *)(v139 + 8 * v142) = v125;
                *(_QWORD *)(v125 + 48) = v139;
                goto LABEL_257;
              }
              v139 = *(_QWORD *)(v139 + 8 * v142);
            }
            v143 = *(_QWORD *)(v139 + 16);
            *(_QWORD *)(v143 + 24) = v125;
            *(_QWORD *)(v139 + 16) = v125;
            *(_QWORD *)(v125 + 16) = v143;
            *(_QWORD *)(v125 + 24) = v139;
            *(_QWORD *)(v125 + 48) = 0LL;
          }
          else
          {
            qword_436638[v136] = v125;
            dword_4363E4 = (1 << v136) | v137;
            *(_QWORD *)(v125 + 48) = &qword_436638[v136];
LABEL_257:
            *(_QWORD *)(v125 + 24) = v125;
            *(_QWORD *)(v125 + 16) = v125;
          }
        }
        else
        {
          v133 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v132);
          if ( ((1 << v132) & dword_4363E0) != 0 )
          {
            v134 = (char *)*((_QWORD *)v133 + 2);
          }
          else
          {
            dword_4363E0 |= 1 << v132;
            v134 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v132);
          }
          *((_QWORD *)v133 + 2) = v125;
          *((_QWORD *)v134 + 3) = v125;
          *(_QWORD *)(v125 + 16) = v134;
          *(_QWORD *)(v125 + 24) = v133;
        }
      }
      goto LABEL_259;
    }
    qword_436758 = v82;
    v91 = v88 & 0xF;
    qword_436760 += v81;
    if ( (v88 & 0xF) != 0 )
      v91 = -(char)(v88 + 16) & 0xF;
    v92 = v88 + v91;
    v93 = v82 + v1;
    v94 = v92 - v82 - v1;
    *(_QWORD *)(v82 + 8) = v1 | 3;
    if ( v84 == v92 )
    {
      qword_436408 = v82 + v1;
      qword_4363F0 += v94;
      *(_QWORD *)(v93 + 8) = qword_4363F0 | 1;
      return v82 + 16;
    }
    if ( v92 == qword_436400 )
    {
      v95 = qword_4363E8[0] + v94;
      qword_436400 = v82 + v1;
      qword_4363E8[0] = v95;
      *(_QWORD *)(v93 + 8) = v95 | 1;
      *(_QWORD *)(v93 + v95) = v95;
      return v82 + 16;
    }
    v96 = *(_QWORD *)(v92 + 8);
    if ( (v96 & 3) != 1 )
    {
LABEL_210:
      *(_QWORD *)(v92 + 8) &= ~1uLL;
      v110 = v94 >> 3;
      *(_QWORD *)(v93 + 8) = v94 | 1;
      *(_QWORD *)(v93 + v94) = v94;
      if ( v94 > 0xFF )
      {
        v114 = v94 >> 8;
        v115 = v94 >> 8;
        if ( v115 )
        {
          v115 = 31;
          if ( (unsigned int)v114 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v114, v114);
            v115 = ((v94 >> (38 - ((unsigned __int8)v114 ^ 0x1Fu))) & 1) + 2 * (31 - (v114 ^ 0x1F));
          }
        }
        v116 = dword_4363E4;
        *(_DWORD *)(v93 + 56) = v115;
        *(_QWORD *)(v93 + 40) = 0LL;
        *(_QWORD *)(v93 + 32) = 0LL;
        if ( ((1 << v115) & v116) != 0 )
        {
          v117 = qword_436638[v115];
          if ( v115 != 31 )
            v90 = 57 - (v115 >> 1);
          v118 = v94 << v90;
          while ( v94 != (*(_QWORD *)(v117 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v119 = v118;
            v118 *= 2LL;
            v120 = (v119 >> 63) + 4;
            if ( !*(_QWORD *)(v117 + 8 * v120) )
            {
              *(_QWORD *)(v117 + 8 * v120) = v93;
              *(_QWORD *)(v93 + 48) = v117;
              goto LABEL_227;
            }
            v117 = *(_QWORD *)(v117 + 8 * v120);
          }
          v121 = *(_QWORD *)(v117 + 16);
          *(_QWORD *)(v121 + 24) = v93;
          *(_QWORD *)(v117 + 16) = v93;
          *(_QWORD *)(v93 + 16) = v121;
          *(_QWORD *)(v93 + 24) = v117;
          *(_QWORD *)(v93 + 48) = 0LL;
        }
        else
        {
          qword_436638[v115] = v93;
          dword_4363E4 = (1 << v115) | v116;
          *(_QWORD *)(v93 + 48) = &qword_436638[v115];
LABEL_227:
          *(_QWORD *)(v93 + 24) = v93;
          *(_QWORD *)(v93 + 16) = v93;
        }
      }
      else
      {
        v111 = 1 << v110;
        v112 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v110);
        if ( ((1 << v110) & dword_4363E0) != 0 )
        {
          v113 = (char *)*((_QWORD *)v112 + 2);
        }
        else
        {
          v113 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v110);
          dword_4363E0 |= v111;
        }
        *((_QWORD *)v112 + 2) = v93;
        *((_QWORD *)v113 + 3) = v93;
        *(_QWORD *)(v93 + 16) = v113;
        *(_QWORD *)(v93 + 24) = v112;
      }
      return v82 + 16;
    }
    v97 = *(_QWORD **)(v92 + 24);
    v98 = v96 & 0xFFFFFFFFFFFFFFF8LL;
    v99 = v96 >> 3;
    if ( v96 <= 0xFF )
    {
      v100 = *(_QWORD **)(v92 + 16);
      if ( v100 == v97 )
      {
        dword_4363E0 &= __ROL4__(-2, v99);
      }
      else
      {
        v100[3] = v97;
        v97[2] = v100;
      }
      goto LABEL_209;
    }
    v101 = *(_QWORD *)(v92 + 48);
    if ( (_QWORD *)v92 != v97 )
    {
      v102 = *(_QWORD *)(v92 + 16);
      *(_QWORD *)(v102 + 24) = v97;
      v97[2] = v102;
      goto LABEL_196;
    }
    v97 = *(_QWORD **)(v92 + 40);
    v103 = (_QWORD *)(v92 + 40);
    if ( !v97 )
    {
      v97 = *(_QWORD **)(v92 + 32);
      if ( !v97 )
        goto LABEL_196;
      v103 = (_QWORD *)(v92 + 32);
    }
    v104 = v97;
    do
    {
      do
      {
        v105 = v103;
        v97 = v104;
        v103 = v104 + 5;
        v104 = (_QWORD *)v104[5];
      }
      while ( v104 );
      v104 = (_QWORD *)v97[4];
      v103 = v97 + 4;
    }
    while ( v104 );
    *v105 = 0LL;
LABEL_196:
    if ( v101 )
    {
      v106 = *(unsigned int *)(v92 + 56);
      v107 = *(_DWORD *)(v92 + 56);
      if ( v92 != qword_436638[v106] )
      {
        if ( v92 == *(_QWORD *)(v101 + 32) )
          *(_QWORD *)(v101 + 32) = v97;
        else
          *(_QWORD *)(v101 + 40) = v97;
        if ( !v97 )
          goto LABEL_209;
LABEL_199:
        v108 = *(_QWORD *)(v92 + 32);
        v97[6] = v101;
        if ( v108 )
        {
          v97[4] = v108;
          *(_QWORD *)(v108 + 48) = v97;
        }
        v109 = *(_QWORD *)(v92 + 40);
        if ( v109 )
        {
          v97[5] = v109;
          *(_QWORD *)(v109 + 48) = v97;
        }
        goto LABEL_209;
      }
      qword_4363E8[v106 + 74] = (__int64)v97;
      if ( v97 )
        goto LABEL_199;
      dword_4363E4 &= __ROL4__(-2, v107);
    }
LABEL_209:
    v92 += v98;
    v94 += v98;
    goto LABEL_210;
  }
  return 0LL;
}
// 40310D: variable 'v126' is possibly undefined
// 403130: variable 'v124' is possibly undefined
// 40315B: variable 'v125' is possibly undefined
// 4363E0: using guessed type int dword_4363E0;
// 4363E4: using guessed type int dword_4363E4;
// 4363E8: using guessed type __int64 qword_4363E8[];
// 4363F0: using guessed type __int64 qword_4363F0;
// 4363F8: using guessed type __int64 qword_4363F8;
// 436400: using guessed type __int64 qword_436400;
// 436408: using guessed type __int64 qword_436408;
// 436418: using guessed type __int64 qword_436418;
// 436420: using guessed type __int64 qword_436420;
// 436638: using guessed type __int64 qword_436638[32];
// 436738: using guessed type __int64 qword_436738;
// 436740: using guessed type __int64 qword_436740;
// 436748: using guessed type __int64 qword_436748;
// 436750: using guessed type int dword_436750;
// 436758: using guessed type __int64 qword_436758;
// 436760: using guessed type __int64 qword_436760;
// 436768: using guessed type __int64 qword_436768;
// 436770: using guessed type int dword_436770;
// 4367A0: using guessed type __int64 qword_4367A0;
// 4367B0: using guessed type __int64 qword_4367B0;
// 4367B8: using guessed type __int64 qword_4367B8;

//----- (0000000000403312) ----------------------------------------------------
void __fastcall sub_403312(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  __int64 v7; // rbx
  _QWORD *v8; // rdx
  unsigned __int64 v9; // rcx
  _QWORD *v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  _QWORD *v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // r9
  int v17; // ecx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // r8
  __int64 v22; // r10
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // rsi
  __int64 v28; // r8
  __int64 v29; // rcx
  _QWORD *v30; // r9
  _QWORD *v31; // rcx
  _QWORD *v32; // r11
  __int64 v33; // r9
  int v34; // ecx
  __int64 v35; // rcx
  __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  char *v38; // rax
  char *v39; // rdx
  unsigned __int64 v40; // rsi
  unsigned int v41; // edx
  int v42; // esi
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  __int64 v47; // rdx
  __int64 v48; // rax

  if ( !a1 )
    return;
  v2 = a1 - 16;
  v3 = *(_QWORD *)(a1 - 8);
  v4 = v3 & 0xFFFFFFFFFFFFFFF8LL;
  v5 = v2 + (v3 & 0xFFFFFFFFFFFFFFF8LL);
  if ( (v3 & 1) != 0 )
    goto LABEL_35;
  v6 = *(_QWORD *)(a1 - 16);
  v2 -= v6;
  if ( (v3 & 3) == 0 )
  {
    v7 = v4 + v6 + 32;
    if ( !(unsigned int)sub_403D56(v2, v7) )
      qword_436738 -= v7;
    return;
  }
  v4 += v6;
  if ( qword_436400 == v2 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    if ( (v20 & 3) == 3 )
    {
      qword_4363E8[0] = v4;
      *(_QWORD *)(v5 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
      *(_QWORD *)(v2 + 8) = v4 | 1;
      *(_QWORD *)v5 = v4;
      return;
    }
    goto LABEL_35;
  }
  v8 = *(_QWORD **)(v2 + 24);
  v9 = v6 >> 3;
  if ( v6 <= 0xFF )
  {
    v10 = *(_QWORD **)(v2 + 16);
    if ( v10 == v8 )
    {
      dword_4363E0 &= __ROL4__(-2, v9);
    }
    else
    {
      v10[3] = v8;
      v8[2] = v10;
    }
    goto LABEL_35;
  }
  v11 = *(_QWORD *)(v2 + 48);
  if ( (_QWORD *)v2 == v8 )
  {
    v8 = *(_QWORD **)(v2 + 40);
    v13 = (_QWORD *)(v2 + 40);
    if ( !v8 )
    {
      v8 = *(_QWORD **)(v2 + 32);
      if ( !v8 )
        goto LABEL_20;
      v13 = (_QWORD *)(v2 + 32);
    }
    v14 = v8;
    do
    {
      do
      {
        v15 = v13;
        v8 = v14;
        v13 = v14 + 5;
        v14 = (_QWORD *)v14[5];
      }
      while ( v14 );
      v14 = (_QWORD *)v8[4];
      v13 = v8 + 4;
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_20;
  }
  v12 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v12 + 24) = v8;
  v8[2] = v12;
LABEL_20:
  if ( !v11 )
    goto LABEL_35;
  v16 = *(unsigned int *)(v2 + 56);
  v17 = *(_DWORD *)(v2 + 56);
  if ( qword_436638[v16] == v2 )
  {
    qword_4363E8[v16 + 74] = (__int64)v8;
    if ( !v8 )
    {
      dword_4363E4 &= __ROL4__(-2, v17);
      goto LABEL_35;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v2 )
      *(_QWORD *)(v11 + 32) = v8;
    else
      *(_QWORD *)(v11 + 40) = v8;
    if ( !v8 )
      goto LABEL_35;
  }
  v18 = *(_QWORD *)(v2 + 32);
  v8[6] = v11;
  if ( v18 )
  {
    v8[4] = v18;
    *(_QWORD *)(v18 + 48) = v8;
  }
  v19 = *(_QWORD *)(v2 + 40);
  if ( v19 )
  {
    v8[5] = v19;
    *(_QWORD *)(v19 + 48) = v8;
  }
LABEL_35:
  v21 = *(_QWORD *)(v5 + 8);
  if ( (v21 & 2) == 0 )
  {
    v22 = qword_436400;
    if ( qword_436408 == v5 )
    {
      v23 = qword_4363F0 + v4;
      qword_436408 = v2;
      qword_4363F0 = v23;
      *(_QWORD *)(v2 + 8) = v23 | 1;
      if ( v2 == v22 )
      {
        qword_436400 = 0LL;
        qword_4363E8[0] = 0LL;
      }
      if ( v23 > qword_436410 )
        sub_401DD6(&dword_4363E0, 0LL);
      return;
    }
    if ( v5 == qword_436400 )
    {
      v24 = qword_4363E8[0] + v4;
      qword_436400 = v2;
      qword_4363E8[0] = v24;
      *(_QWORD *)(v2 + 8) = v24 | 1;
      *(_QWORD *)(v2 + v24) = v24;
      return;
    }
    v25 = v21 & 0xFFFFFFFFFFFFFFF8LL;
    v26 = *(_QWORD **)(v5 + 24);
    v4 += v25;
    if ( v25 <= 0xF8 )
    {
      v27 = *(_QWORD **)(v5 + 16);
      if ( v27 == v26 )
      {
        dword_4363E0 &= __ROL4__(-2, v25 >> 3);
      }
      else
      {
        v27[3] = v26;
        v26[2] = v27;
      }
      goto LABEL_69;
    }
    v28 = *(_QWORD *)(v5 + 48);
    if ( (_QWORD *)v5 != v26 )
    {
      v29 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v29 + 24) = v26;
      v26[2] = v29;
      goto LABEL_56;
    }
    v26 = *(_QWORD **)(v5 + 40);
    v30 = (_QWORD *)(v5 + 40);
    if ( !v26 )
    {
      v26 = *(_QWORD **)(v5 + 32);
      if ( !v26 )
        goto LABEL_56;
      v30 = (_QWORD *)(v5 + 32);
    }
    v31 = v26;
    do
    {
      do
      {
        v32 = v30;
        v26 = v31;
        v30 = v31 + 5;
        v31 = (_QWORD *)v31[5];
      }
      while ( v31 );
      v31 = (_QWORD *)v26[4];
      v30 = v26 + 4;
    }
    while ( v31 );
    *v32 = 0LL;
LABEL_56:
    if ( !v28 )
      goto LABEL_69;
    v33 = *(unsigned int *)(v5 + 56);
    v34 = *(_DWORD *)(v5 + 56);
    if ( qword_436638[v33] == v5 )
    {
      qword_4363E8[v33 + 74] = (__int64)v26;
      if ( !v26 )
      {
        dword_4363E4 &= __ROL4__(-2, v34);
        goto LABEL_69;
      }
    }
    else
    {
      if ( *(_QWORD *)(v28 + 32) == v5 )
        *(_QWORD *)(v28 + 32) = v26;
      else
        *(_QWORD *)(v28 + 40) = v26;
      if ( !v26 )
        goto LABEL_69;
    }
    v35 = *(_QWORD *)(v5 + 32);
    v26[6] = v28;
    if ( v35 )
    {
      v26[4] = v35;
      *(_QWORD *)(v35 + 48) = v26;
    }
    v36 = *(_QWORD *)(v5 + 40);
    if ( v36 )
    {
      v26[5] = v36;
      *(_QWORD *)(v36 + 48) = v26;
    }
LABEL_69:
    *(_QWORD *)(v2 + 8) = v4 | 1;
    *(_QWORD *)(v2 + v4) = v4;
    if ( v2 == v22 )
    {
      qword_4363E8[0] = v4;
      return;
    }
    goto LABEL_72;
  }
  *(_QWORD *)(v5 + 8) = v21 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v2 + 8) = v4 | 1;
  *(_QWORD *)(v2 + v4) = v4;
LABEL_72:
  v37 = v4 >> 3;
  if ( v4 > 0xFF )
  {
    v40 = v4 >> 8;
    v41 = v4 >> 8;
    if ( v41 )
    {
      v41 = 31;
      if ( (unsigned int)v40 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v40, v40);
        v41 = ((v4 >> (38 - ((unsigned __int8)v40 ^ 0x1Fu))) & 1) + 2 * (31 - (v40 ^ 0x1F));
      }
    }
    v42 = dword_4363E4;
    *(_DWORD *)(v2 + 56) = v41;
    *(_QWORD *)(v2 + 40) = 0LL;
    *(_QWORD *)(v2 + 32) = 0LL;
    if ( ((1 << v41) & v42) != 0 )
    {
      v43 = 0;
      v44 = qword_436638[v41];
      if ( v41 != 31 )
        v43 = 57 - (v41 >> 1);
      v45 = v4 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v4 )
      {
        v46 = v45;
        v45 *= 2LL;
        v47 = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * v47) )
        {
          *(_QWORD *)(v44 + 8 * v47) = v2;
          *(_QWORD *)(v2 + 48) = v44;
          goto LABEL_89;
        }
        v44 = *(_QWORD *)(v44 + 8 * v47);
      }
      v48 = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(v48 + 24) = v2;
      *(_QWORD *)(v44 + 16) = v2;
      *(_QWORD *)(v2 + 16) = v48;
      *(_QWORD *)(v2 + 24) = v44;
      *(_QWORD *)(v2 + 48) = 0LL;
    }
    else
    {
      qword_436638[v41] = v2;
      dword_4363E4 = (1 << v41) | v42;
      *(_QWORD *)(v2 + 48) = &qword_436638[v41];
LABEL_89:
      *(_QWORD *)(v2 + 24) = v2;
      *(_QWORD *)(v2 + 16) = v2;
    }
    if ( !--qword_436418 )
      sub_401B19((__int64)&dword_4363E0);
  }
  else
  {
    v38 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v37);
    if ( ((1 << v37) & dword_4363E0) != 0 )
    {
      v39 = (char *)*((_QWORD *)v38 + 2);
    }
    else
    {
      dword_4363E0 |= 1 << v37;
      v39 = (char *)&unk_436428 + 8 * (unsigned int)(2 * v37);
    }
    *((_QWORD *)v38 + 2) = v2;
    *((_QWORD *)v39 + 3) = v2;
    *(_QWORD *)(v2 + 16) = v39;
    *(_QWORD *)(v2 + 24) = v38;
  }
}
// 4363E0: using guessed type int dword_4363E0;
// 4363E4: using guessed type int dword_4363E4;
// 4363E8: using guessed type __int64 qword_4363E8[];
// 4363F0: using guessed type __int64 qword_4363F0;
// 436400: using guessed type __int64 qword_436400;
// 436408: using guessed type __int64 qword_436408;
// 436410: using guessed type __int64 qword_436410;
// 436418: using guessed type __int64 qword_436418;
// 436638: using guessed type __int64 qword_436638[32];
// 436738: using guessed type __int64 qword_436738;

//----- (0000000000403817) ----------------------------------------------------
void __fastcall sub_403817(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax

  v2 = 0LL;
  if ( a1 )
  {
    v2 = a2 * a1;
    if ( ((a2 | a1) & 0xFFFFFFFFFFFF0000LL) != 0 && a2 != v2 / a1 )
      v2 = -1LL;
  }
  v3 = sub_40238E(v2);
  if ( v3 )
  {
    if ( (*(_BYTE *)(v3 - 8) & 3) != 0 )
      sub_404562(v3, 0LL, v2);
  }
}

//----- (0000000000403873) ----------------------------------------------------
__int64 *__fastcall sub_403873(__int64 a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v3; // r13
  __int64 v6; // rsi
  unsigned __int64 v7; // rdx
  __int64 v8; // r14
  __int64 v9; // rbx
  __int64 v10; // r15
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  bool v13; // cf
  unsigned __int64 v14; // rbx
  bool v15; // cc
  char *v16; // r9
  unsigned __int64 v17; // rdx
  char *v18; // r8
  __int64 v19; // rdi
  __int64 v20; // rsi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rsi
  unsigned __int64 *v24; // rax
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // r8
  char *v29; // rax
  unsigned __int64 v30; // r11
  char *v31; // rdx
  __int64 v32; // r10
  __int64 v33; // rdx
  _QWORD *v34; // rcx
  char *v35; // rdx
  _QWORD *v36; // rbx
  __int64 v37; // rcx
  __int64 v38; // rdx
  __int64 v39; // rdx
  __int64 v40; // rdx
  __int64 v41; // rsi
  char *v42; // rax
  __int64 v43; // rdx

  v3 = a2;
  v6 = a2[1];
  v7 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  if ( (v6 & 3) != 0 )
  {
    v16 = (char *)v3 + v7;
    if ( v7 >= a3 )
    {
      v17 = v7 - a3;
      if ( v17 <= 0x1F )
        return v3;
      v18 = (char *)v3 + a3;
      v19 = v6 & 1 | a3 | 2;
      v20 = (__int64)v18;
      v3[1] = v19;
      *((_QWORD *)v18 + 1) = v17 | 3;
      *((_QWORD *)v16 + 1) |= 1uLL;
LABEL_53:
      sub_401F12(a1, v20, v17);
      return v3;
    }
    if ( *(char **)(a1 + 40) == v16 )
    {
      v21 = *(_QWORD *)(a1 + 16) + v7;
      if ( v21 > a3 )
      {
        v3[1] = a3 | v6 & 1 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = (v21 - a3) | 1;
        *(_QWORD *)(a1 + 40) = (char *)v3 + a3;
        *(_QWORD *)(a1 + 16) = v21 - a3;
        return v3;
      }
      return 0LL;
    }
    if ( *(char **)(a1 + 32) == v16 )
    {
      v22 = v7 + *(_QWORD *)(a1 + 8);
      if ( v22 < a3 )
        return 0LL;
      v23 = v6 & 1;
      v24 = (unsigned __int64 *)((char *)v3 + v22);
      v25 = v22 - a3;
      if ( v22 - a3 <= 0x1F )
      {
        v3[1] = v23 | v22 | 2;
        v24[1] |= 1uLL;
        *(_QWORD *)(a1 + 8) = 0LL;
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      else
      {
        v3[1] = a3 | v23 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = v25 | 1;
        *v24 = v25;
        v24[1] &= ~1uLL;
        *(_QWORD *)(a1 + 8) = v25;
        *(_QWORD *)(a1 + 32) = (char *)v3 + a3;
      }
      return v3;
    }
    v26 = *((_QWORD *)v16 + 1);
    if ( (v26 & 2) != 0 )
      return 0LL;
    v27 = v26 & 0xFFFFFFFFFFFFFFF8LL;
    v28 = v7 + v27;
    if ( v7 + v27 < a3 )
      return 0LL;
    v29 = (char *)*((_QWORD *)v16 + 3);
    v30 = v28 - a3;
    if ( v27 <= 0xF8 )
    {
      v31 = (char *)*((_QWORD *)v16 + 2);
      if ( v31 == v29 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v27 >> 3);
      }
      else
      {
        *((_QWORD *)v31 + 3) = v29;
        *((_QWORD *)v29 + 2) = v31;
      }
      goto LABEL_50;
    }
    v32 = *((_QWORD *)v16 + 6);
    if ( v16 != v29 )
    {
      v33 = *((_QWORD *)v16 + 2);
      *(_QWORD *)(v33 + 24) = v29;
      *((_QWORD *)v29 + 2) = v33;
      goto LABEL_37;
    }
    v29 = (char *)*((_QWORD *)v16 + 5);
    v34 = v16 + 40;
    if ( !v29 )
    {
      v29 = (char *)*((_QWORD *)v16 + 4);
      if ( !v29 )
        goto LABEL_37;
      v34 = v16 + 32;
    }
    v35 = v29;
    do
    {
      do
      {
        v36 = v34;
        v29 = v35;
        v34 = v35 + 40;
        v35 = (char *)*((_QWORD *)v35 + 5);
      }
      while ( v35 );
      v35 = (char *)*((_QWORD *)v29 + 4);
      v34 = v29 + 32;
    }
    while ( v35 );
    *v36 = 0LL;
LABEL_37:
    if ( v32 )
    {
      v37 = *((unsigned int *)v16 + 14);
      v38 = a1 + 8 * v37;
      if ( *(char **)(v38 + 600) != v16 )
      {
        if ( *(char **)(v32 + 32) == v16 )
          *(_QWORD *)(v32 + 32) = v29;
        else
          *(_QWORD *)(v32 + 40) = v29;
        if ( !v29 )
          goto LABEL_50;
LABEL_40:
        v39 = *((_QWORD *)v16 + 4);
        *((_QWORD *)v29 + 6) = v32;
        if ( v39 )
        {
          *((_QWORD *)v29 + 4) = v39;
          *(_QWORD *)(v39 + 48) = v29;
        }
        v40 = *((_QWORD *)v16 + 5);
        if ( v40 )
        {
          *((_QWORD *)v29 + 5) = v40;
          *(_QWORD *)(v40 + 48) = v29;
        }
        goto LABEL_50;
      }
      *(_QWORD *)(v38 + 600) = v29;
      if ( v29 )
        goto LABEL_40;
      *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v37);
    }
LABEL_50:
    v41 = v6 & 1;
    v42 = (char *)v3 + v28;
    v43 = v41;
    if ( v30 <= 0x1F )
    {
      v3[1] = v28 | v41 | 2;
      *((_QWORD *)v42 + 1) |= 1uLL;
      return v3;
    }
    v20 = (__int64)v3 + a3;
    v3[1] = a3 | v43 | 2;
    *(__int64 *)((char *)v3 + a3 + 8) = v30 | 3;
    *((_QWORD *)v42 + 1) |= 1uLL;
    v17 = v28 - a3;
    goto LABEL_53;
  }
  if ( a3 <= 0xFF )
    return 0LL;
  if ( v7 < a3 + 8 || v7 - a3 > 2 * qword_4367B0 )
  {
    v8 = *v3;
    v9 = -qword_4367B0 & (qword_4367B0 + a3 + 62);
    v10 = v7 + *v3 + 32;
    v11 = sub_404008();
    if ( v11 == -1LL )
      return 0LL;
    v3 = (__int64 *)(v11 + v8);
    v12 = v9 - v8;
    v13 = v11 < *(_QWORD *)(a1 + 24);
    v3[1] = v9 - v8 - 32;
    *(__int64 *)((char *)v3 + v12 - 24) = 11LL;
    *(__int64 *)((char *)v3 + v12 - 16) = 0LL;
    if ( v13 )
      *(_QWORD *)(a1 + 24) = v11;
    v14 = *(_QWORD *)(a1 + 856) + v9 - v10;
    v15 = v14 <= *(_QWORD *)(a1 + 864);
    *(_QWORD *)(a1 + 856) = v14;
    if ( !v15 )
      *(_QWORD *)(a1 + 864) = v14;
  }
  return v3;
}
// 4367B0: using guessed type __int64 qword_4367B0;

//----- (0000000000403C02) ----------------------------------------------------
__int64 *__fastcall sub_403C02(__int64 a1, unsigned __int64 a2)
{
  __int64 *result; // rax
  unsigned __int64 v3; // rdx
  __int64 *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-18h]

  if ( !a1 )
    return (__int64 *)sub_40238E(a2);
  if ( a2 > 0xFFFFFFFFFFFFFF7FLL )
  {
    sub_401556();
    return 0LL;
  }
  if ( !a2 )
  {
    sub_403312(a1);
    return 0LL;
  }
  v3 = 32LL;
  if ( a2 > 0xE )
    v3 = (a2 + 31) & 0xFFFFFFFFFFFFFFF0LL;
  v4 = sub_403873((__int64)&dword_4363E0, (__int64 *)(a1 - 16), v3);
  if ( v4 )
    return v4 + 2;
  result = (__int64 *)sub_40238E(a2);
  if ( result )
  {
    v6 = (__int64)result;
    v5 = (*(_QWORD *)(a1 - 8) & 0xFFFFFFFFFFFFFFF8LL) - 16;
    if ( v5 > a2 )
      v5 = a2;
    sub_404420((__int64)result, a1, v5);
    sub_403312(a1);
    return (__int64 *)v6;
  }
  return result;
}
// 4363E0: using guessed type int dword_4363E0;

//----- (0000000000403CBB) ----------------------------------------------------
void __fastcall sub_403CBB(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v3; // rdx

  if ( !qword_4367A0 )
  {
    v2 = 0x10000;
    if ( (unsigned int)dword_437FA8 >= 0x10000 )
      v2 = dword_437FA8;
    v3 = v2 - 1LL;
    if ( (v2 & (unsigned int)v3) != 0 )
      sub_401000(a1, a2, v3);
    qword_4367B0 = v2;
    qword_4367A8 = 4096LL;
    qword_4367B8 = 0x40000LL;
    qword_4367C0 = 10485760LL;
    dword_4367C8 = 5;
    dword_436750 = 5;
    qword_4367A0 = qword_436000 & 0xFFFFFFFFFFFFFFF0LL | 8;
  }
}
// 436000: using guessed type __int64 qword_436000;
// 436750: using guessed type int dword_436750;
// 4367A0: using guessed type __int64 qword_4367A0;
// 4367A8: using guessed type __int64 qword_4367A8;
// 4367B0: using guessed type __int64 qword_4367B0;
// 4367B8: using guessed type __int64 qword_4367B8;
// 4367C0: using guessed type __int64 qword_4367C0;
// 4367C8: using guessed type int dword_4367C8;
// 437FA8: using guessed type int dword_437FA8;

//----- (0000000000403D42) ----------------------------------------------------
__int64 __fastcall sub_403D42(__int64 a1)
{
  return sub_403D6A(a1);
}

//----- (0000000000403D56) ----------------------------------------------------
__int64 __fastcall sub_403D56(__int64 a1, __int64 a2)
{
  return sub_40400E(a1, a2);
}

//----- (0000000000403D6A) ----------------------------------------------------
__int64 __fastcall sub_403D6A(__int64 a1)
{
  __int64 v1; // r15
  int v2; // er13
  int v3; // er14
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  int v6; // esi
  __int64 v7; // rdi
  __int64 v8; // r12
  int v9; // er13
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r14
  __int64 v13; // rsi
  __int64 v14; // r13
  unsigned __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax

  v1 = 0LL;
  v2 = dword_436368 | qword_436360 | 2;
  v3 = dword_4362B8 & 4;
  v4 = a1 + 0xFFFF;
  LOWORD(v4) = 0;
  if ( (((unsigned __int8)dword_436368 | (unsigned __int8)qword_436360) & 0x10) == 0 )
  {
    v5 = qword_436B00[0];
    v1 = 0x200000000000LL;
    if ( qword_436B00[0] )
    {
      do
      {
        --v5;
        v6 = dword_436B0C[2 * v5];
        v7 = v6 + 1;
        if ( v7 + (v4 >> 16) <= 0x30000000 && v6 > 536870910 )
        {
          v1 = v7 << 16;
          goto LABEL_8;
        }
      }
      while ( v5 );
      v1 = (__int64)(HIDWORD(qword_436B00[qword_436B00[0]]) + 1) << 16;
    }
LABEL_8:
    LOWORD(v1) = 0;
  }
  if ( qword_436B00[0] == 300 )
    return sub_401556();
  if ( (((unsigned __int8)dword_436368 | (unsigned __int8)qword_436360) & 0x10) != 0 )
    sub_403D56(v1, v4);
  else
    sub_40427B(((v4 + 0xFFFF) >> 16) + (v1 >> 16) - 1, (__int64)dword_436B08, qword_436B00[0]);
  v9 = v2 | 0x10;
  if ( v3 )
  {
    v11 = (unsigned int)sub_4046FA(3, v9);
    v12 = sub_401A32(-1LL, (__int64)qword_4047C0, v11, HIDWORD(v4));
    if ( v12 )
    {
      v13 = (unsigned int)sub_4042A8(3, v9);
      v8 = sub_401A5E(v12, v13, 0LL, 0LL);
      if ( v8 )
        goto LABEL_21;
      sub_401A19(v12, v13, -1LL);
    }
    v10 = sub_404786();
  }
  else
  {
    v10 = sub_40429B();
  }
  v8 = v10;
  v12 = -1LL;
LABEL_21:
  if ( v8 != -1 )
  {
    v14 = v8 >> 16;
    v15 = sub_40427B(v8 >> 16, (__int64)dword_436B08, qword_436B00[0]);
    if ( qword_436B00[0] > v15 )
    {
      sub_404542(&qword_436B00[v15 + 2], (_BYTE *)&unk_436AF8 + 8 * v15 + 16, 8 * (qword_436B00[0] - v15));
      sub_404542(&byte_437460[v16], &byte_437458[v16], 8 * (qword_436B00[0] - v17));
    }
    ++qword_436B00[0];
    dword_436B08[2 * v15] = v14;
    qword_437468[v15] = v12;
    dword_436B0C[2 * v15] = ((v4 + 0xFFFF) >> 16) + v14 - 1;
  }
  return v8;
}
// 403DC5: conditional instruction was optimized away because er12.4==FFFFFFFF
// 403DE3: conditional instruction was optimized away because rdi.8==0
// 403EDA: conditional instruction was optimized away because er12.4==FFFFFFFF
// 403FAE: variable 'v16' is possibly undefined
// 403FBC: variable 'v17' is possibly undefined
// 403FD6: variable 'v15' is possibly undefined
// 4047C0: using guessed type __int64 qword_4047C0[2];
// 4362B8: using guessed type int dword_4362B8;
// 436360: using guessed type __int64 qword_436360;
// 436368: using guessed type int dword_436368;
// 436B00: using guessed type __int64 qword_436B00[];
// 436B08: using guessed type int dword_436B08[];
// 436B0C: using guessed type int dword_436B0C[595];
// 437458: using guessed type _BYTE byte_437458[8];
// 437460: using guessed type _BYTE byte_437460[8];
// 437468: using guessed type __int64 qword_437468[303];

//----- (0000000000404008) ----------------------------------------------------
// attributes: thunk
__int64 sub_404008()
{
  return sub_401566();
}

//----- (000000000040400E) ----------------------------------------------------
__int64 __fastcall sub_40400E(__int64 a1, __int64 a2)
{
  int v2; // er12
  unsigned int v3; // er13
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8

  if ( (unsigned __int64)(a1 - 1) <= 0xFFFFFFFFFFFFFFFDLL && a2 )
  {
    v2 = a1 >> 16;
    v3 = 0;
    v4 = sub_40427B(
           v2 + (unsigned int)((unsigned __int64)(a2 + 0xFFFF) >> 16) - 1,
           (__int64)dword_436B08,
           qword_436B00[0]);
    v5 = v4;
    while ( v4 )
    {
      v6 = v4 - 1;
      v7 = (unsigned int)dword_436B0C[2 * v4 - 2];
      if ( v2 > (int)v7 )
        break;
      if ( (dword_4362B8 & 4) != 0 )
      {
        v8 = (unsigned int)dword_436B08[2 * v4 - 2];
        if ( !(unsigned int)sub_401A74((__int64)(int)v8 << 16, v7, v8) )
          v3 = -1;
        if ( !(unsigned int)sub_401A19(qword_437468[v6], v7, v9) )
          v3 = -1;
      }
      else
      {
        v3 |= sub_404300();
      }
      v4 = v6;
    }
    if ( v4 < v5 )
    {
      if ( qword_436B00[0] > v5 )
      {
        sub_404542(&qword_436B00[v4 + 1], &qword_436B00[v5 + 1], 8 * (qword_436B00[0] - v5));
        sub_404542(&byte_437460[v10], &byte_437460[v11], 8 * (qword_436B00[0] - v5));
      }
      qword_436B00[0] = qword_436B00[0] + v4 - v5;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}
// 4040B8: variable 'v9' is possibly undefined
// 404112: variable 'v10' is possibly undefined
// 404119: variable 'v11' is possibly undefined
// 40412C: variable 'v4' is possibly undefined
// 4362B8: using guessed type int dword_4362B8;
// 436B00: using guessed type __int64 qword_436B00[];
// 436B08: using guessed type int dword_436B08[];
// 436B0C: using guessed type int dword_436B0C[595];
// 437460: using guessed type _BYTE byte_437460[8];
// 437468: using guessed type __int64 qword_437468[303];

//----- (00000000004041E6) ----------------------------------------------------
__int64 __fastcall sub_4041E6(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v4; // rdi
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int *v8; // rcx
  void (__fastcall *v9)(_QWORD); // rdx
  __int64 v10; // r13

LABEL_1:
  while ( 1 )
  {
    v4 = (unsigned int *)qword_4367E0;
    if ( !qword_4367E0 )
      return a3;
    while ( 1 )
    {
      v5 = *v4;
      while ( v5 )
      {
        _BitScanForward((unsigned int *)&v6, v5);
        v7 = (unsigned int)~(1 << v6);
        v5 &= v7;
        if ( !a1 || *(_QWORD *)&v4[6 * v6 + 8] == a1 )
        {
          *v4 &= v7;
          v8 = &v4[6 * v6];
          v9 = (void (__fastcall *)(_QWORD))*((_QWORD *)v8 + 2);
          if ( v9 )
          {
            v9(*((_QWORD *)v8 + 3));
            goto LABEL_1;
          }
        }
      }
      v10 = *((_QWORD *)v4 + 1);
      if ( !a1 )
        break;
      if ( !v10 )
        return a3;
      v4 = (unsigned int *)*((_QWORD *)v4 + 1);
    }
    if ( v10 && sub_401ACC )
      sub_401ACC();
    qword_4367E0 = v10;
  }
}
// 401ACC: using guessed type __int64 sub_401ACC(void);
// 4367E0: using guessed type __int64 qword_4367E0;

//----- (000000000040427B) ----------------------------------------------------
__int64 __fastcall sub_40427B(int a1, __int64 a2, int a3)
{
  __int64 result; // rax
  int v4; // ecx

  LODWORD(result) = 0;
  while ( a3 > (int)result )
  {
    v4 = (a3 + (int)result) >> 1;
    if ( *(_DWORD *)(a2 + 8LL * v4) > a1 )
      a3 = (a3 + (int)result) >> 1;
    else
      LODWORD(result) = v4 + 1;
  }
  return (int)result;
}

//----- (000000000040429B) ----------------------------------------------------
__int64 sub_40429B()
{
  return sub_4042F0();
}

//----- (00000000004042A8) ----------------------------------------------------
__int64 __fastcall sub_4042A8(char a1, int a2)
{
  return (8 * a1) & 0x20 | (4 * a1) & 4 | (32 * a2) & 0x80000000 | (a2 >> 2) & 0x20000000 | a1 & 2 | (a2 >> 1) & 1;
}

//----- (00000000004042F0) ----------------------------------------------------
__int64 sub_4042F0()
{
  return qword_4362C0();
}
// 4362C0: using guessed type __int64 (*qword_4362C0)(void);

//----- (0000000000404300) ----------------------------------------------------
__int64 sub_404300()
{
  return qword_4362C0();
}
// 4362C0: using guessed type __int64 (*qword_4362C0)(void);

//----- (0000000000404310) ----------------------------------------------------
__int64 __fastcall sub_404310()
{
  __int16 v0; // ax
  __int64 result; // rax

  result = (unsigned int)v0;
  if ( (int)result < 0 )
  {
    dword_437FB0 = dword_436348;
    return -1LL;
  }
  else
  {
    __asm { syscall; Low latency system call }
  }
  return result;
}
// 404322: conditional instruction was optimized away because rax.8<80000000u
// 404310: variable 'v0' is possibly undefined
// 404310: using guessed type __int64 __fastcall sub_404310();
// 436348: using guessed type int dword_436348;
// 437FB0: using guessed type int dword_437FB0;

//----- (000000000040436D) ----------------------------------------------------
__int64 __fastcall sub_40436D(__int64 a1, _DWORD *a2)
{
  return sub_4043AF(a1, a2);
}

//----- (000000000040437C) ----------------------------------------------------
__int64 __fastcall sub_40437C(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  a1 = (unsigned int)a1;
  v1 = 0LL;
  if ( (unsigned int)a1 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, a1);
    v3 = *(_DWORD *)&byte_4047E7[2 * v2 - 14];
    do
    {
      v4 = a1;
      a1 = (unsigned int)a1 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return a1 | v1;
}
// 40438F: variable 'v2' is possibly undefined

//----- (00000000004043AF) ----------------------------------------------------
__int64 __fastcall sub_4043AF(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  int v4; // ebx
  int v5; // edx
  int v6; // eax

  LODWORD(result) = 0;
  do
  {
    v3 = (unsigned int)result;
    v4 = result;
    result = (unsigned int)(result + 1);
    v5 = *(unsigned __int16 *)(a1 + 2 * v3);
  }
  while ( (v5 & 0xFC00) == 0xDC00 );
  if ( (v5 & 0xFC00) == 0xD800 )
  {
    v6 = *(unsigned __int16 *)(a1 + 2 * result);
    if ( (v6 & 0xFC00) == 0xDC00 )
    {
      *a2 = (v5 << 10) + v6 - 56613888;
      return (unsigned int)(v4 + 2);
    }
    else
    {
      *a2 = 65533;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *a2 = v5;
  }
  return result;
}

//----- (0000000000404420) ----------------------------------------------------
void __fastcall sub_404420(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     ds:qword_436098[rcx*8] }
}
// 40442D: unbalanced stack, ignored a potential tail call

//----- (0000000000404434) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_404434(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX)
{
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  __int8 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx

  if ( _RDX >= 0x400 )
  {
    if ( _RDX > (unsigned __int64)&dword_400000 )
    {
      *_RDI = _mm_loadu_si128(_RSI);
      v7 = ((unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL) - (_QWORD)_RDI;
      v8 = (unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL;
      v9 = &_RSI->i8[v7];
      v10 = _RDX - v7;
      v11 = 16LL;
      do
      {
        v11 += 16LL;
        _mm_stream_si128((__m128i *)(v8 + v11 - 32), _mm_loadu_si128((const __m128i *)&v9[v11 - 32]));
      }
      while ( v10 > v11 );
      _mm_sfence();
      *(__m128i *)(v8 + v10 - 16) = _mm_loadu_si128((const __m128i *)&v9[v10 - 16]);
    }
    else
    {
      qmemcpy(_RDI, _RSI, _RDX);
    }
  }
  else
  {
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm
      {
        vmovdqu ymm3, ymmword ptr [rsi+rcx-40h]
        vmovdqu ymmword ptr [rdi+rcx-40h], ymm3
      }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 4044B9: positive sp value 8 has been found
// 400000: using guessed type int dword_400000;

//----- (0000000000404542) ----------------------------------------------------
void __fastcall sub_404542(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = a3;
  if ( a1 >= a2 )
  {
    a1 = &a1[a3 - 1];
    a2 = &a2[a3 - 1];
  }
  while ( v3 )
  {
    *a1-- = *a2--;
    --v3;
  }
}

//----- (0000000000404562) ----------------------------------------------------
void __fastcall sub_404562(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     qword ptr [rbx+rcx*8] }
}
// 404579: unbalanced stack, ignored a potential tail call

//----- (000000000040457C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40457C(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3)
{
  if ( _RDX >= 0x400 )
  {
    memset(_RDI, a2, _RDX);
  }
  else
  {
    __asm { vpbroadcastb ymm3, xmm3 }
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm { vmovdqu ymmword ptr [rdi+rcx-40h], ymm3 }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vxorps  ymm3, ymm3, ymm3
    }
  }
}
// 4045E3: positive sp value 10 has been found
// 40457C: could not find valid save-restore pair for rbx

//----- (0000000000404690) ----------------------------------------------------
__int64 __fastcall sub_404690(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  int v4; // ebx
  __int64 v5; // rcx

  result = 0LL;
  v4 = 0;
  v5 = 0LL;
  if ( a3 && a2 != a1 )
  {
    while ( (unsigned int)v5 < a3 )
    {
      LODWORD(result) = *(unsigned __int8 *)(a1 + v5);
      v4 = *(unsigned __int8 *)(a2 + v5);
      if ( !(_BYTE)result || (_BYTE)result != (_BYTE)v4 )
        break;
      v5 = (unsigned int)(v5 + 1);
    }
    return (unsigned int)(result - v4);
  }
  return result;
}

//----- (00000000004046C1) ----------------------------------------------------
void __fastcall __noreturn sub_4046C1(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rcx

  dword_437FB4 |= 4u;
  if ( (dword_4362B8 & 4) != 0 )
  {
    for ( i = (unsigned __int8)a1; ; qword_405030(a1, a2, a3, i) )
      ;
  }
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_4046F2);
  __halt();
}
// 4046D5: variable 'a3' is possibly undefined
// 4046D5: variable 'i' is possibly undefined
// 405030: using guessed type __int64 (__fastcall *qword_405030)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4362B8: using guessed type int dword_4362B8;
// 437FB4: using guessed type int dword_437FB4;

//----- (00000000004046FA) ----------------------------------------------------
__int64 __fastcall sub_4046FA(int a1, int a2)
{
  int v2; // edx

  if ( (a1 & 7) == 7 )
  {
    v2 = 64;
    if ( (a2 & 1) == 0 && qword_436360 != (qword_436360 & a2) )
      v2 = 128;
  }
  else if ( (a1 & 3) == 3 )
  {
    v2 = 4;
    if ( (a2 & 1) == 0 )
      v2 = 4 * (qword_436360 != (qword_436360 & a2)) + 4;
  }
  else
  {
    v2 = 32;
    if ( (a1 & 5) != 5 )
    {
      v2 = 16;
      if ( (a1 & 4) == 0 )
        v2 = (a1 & 1) + 1;
    }
  }
  return v2 | (a1 | a2) & 0xDD000000;
}
// 436360: using guessed type __int64 qword_436360;

//----- (0000000000404786) ----------------------------------------------------
__int64 sub_404786()
{
  if ( (dword_4362B8 & 4) == 0 )
    return sub_401566();
  dword_437FB0 = sub_401A48();
  return -1LL;
}
// 4362B8: using guessed type int dword_4362B8;
// 437FB0: using guessed type int dword_437FB0;

// nfuncs=57 queued=55 decompiled=55 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 55 function(s)"
