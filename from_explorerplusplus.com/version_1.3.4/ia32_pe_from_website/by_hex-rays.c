/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_401000@<eax>(unsigned int@<ecx>, wchar_t *@<ebx>, wchar_t *Format, ...);
// int __userpurge sub_401060@<eax>(_WORD *@<ebx>, unsigned int@<esi>, int);
INT_PTR __stdcall sub_401090(LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
int __fastcall sub_4011B0(unsigned int, int, _WORD *);
int __stdcall sub_4011E0(int, int, DWORD dwErrCode); // idb
FARPROC __stdcall sub_401310(int);
int sub_401360();
int (__stdcall *__stdcall sub_4015A0(int a1, int a2))(int, int);
int __stdcall sub_4015E0(int);
HMODULE __stdcall sub_401690(const WCHAR *);
HMODULE __stdcall sub_4016A0(const CHAR *);
FARPROC __stdcall sub_4016B0(DWORD dwErrCode);
// FARPROC __userpurge sub_4017B0@<eax>(int@<ebx>, int, LPCSTR lpProcName);
HMODULE __stdcall sub_401850(const WCHAR *);
HMODULE __stdcall sub_401860(const CHAR *);
FARPROC __stdcall sub_401870(int);
int __stdcall sub_4018B0(int, int, int, int, DWORD dwErrCode); // idb
FARPROC __stdcall sub_4019E0(DWORD dwErrCode);
int __stdcall sub_401AE0(DWORD dwErrCode); // idb
void __thiscall sub_401C00(std::exception *this);
std::exception *__thiscall sub_401C10(std::exception *this, struct exception *);
void *__thiscall sub_401C30(void *this, char);
int __stdcall sub_401C60(int, int, int, DWORD dwErrCode); // idb
void __thiscall sub_401D90(_DWORD *this);
int __stdcall sub_401E20(int, _DWORD *);
// int __userpurge sub_402000@<eax>(unsigned int@<edx>, unsigned int@<ecx>, int@<esi>, _DWORD *);
int __thiscall sub_402030(void *Src, int); // idb
__int16 __thiscall sub_4020F0(int this, __int16);
int __thiscall sub_4022E0(int this, unsigned __int16);
__int16 __thiscall sub_402350(int this);
int *__thiscall sub_4023C0(int this, int *, __int64, int, char);
int *__thiscall sub_4025A0(int this, int *, __int64, int, int, int, int, char);
char *__thiscall sub_4026E0(_DWORD *this, char);
void *__thiscall sub_402710(void *this, char);
_DWORD *__stdcall sub_402740(_DWORD *, int);
// _DWORD *__usercall sub_4027E0@<eax>(int@<esi>);
int *__thiscall sub_402840(void *this, int *, int, int, int, char, int, _DWORD *, bool *);
_DWORD *__thiscall sub_402AE0(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, _WORD *);
_DWORD *__thiscall sub_402C50(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, int *);
_DWORD *__thiscall sub_402DB0(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, _DWORD *);
_DWORD *__thiscall sub_402F00(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, _DWORD *);
_DWORD *__thiscall sub_403050(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, _DWORD *);
_DWORD *__thiscall sub_4031E0(void *this, _DWORD *, int, int, int, char, _DWORD **, _DWORD *, _DWORD *);
// _DWORD *__userpurge sub_403370@<eax>(_Cvtvec *@<ecx>, double@<st0>, _DWORD *, int, int, int, char, int, _DWORD *, float *);
// _DWORD *__userpurge sub_403470@<eax>(_Cvtvec *@<ecx>, double X@<st0>, _DWORD *, int, int, int, char, int, _DWORD *, double *);
_DWORD *__thiscall sub_403580(_Cvtvec *this, _DWORD *, int, int, int, char, int, _DWORD *, double *);
int *__thiscall sub_403690(void *this, int a2, int a3, int a4, int a5, char a6, _DWORD **a7, _DWORD *a8, int *a9);
void *__thiscall sub_403810(void *this, char);
_DWORD *__stdcall sub_403840(_DWORD *);
// int *__userpurge sub_403930@<eax>(unsigned int@<eax>, int@<esi>, void *Src);
int __cdecl sub_403A20(int, _BYTE *, int, _WORD *, __int16, int);
int __cdecl sub_403FF0(_Cvtvec *, _WORD *, int, int, int, int);
int __thiscall sub_4051A0(void *this, int);
int __thiscall sub_4051C0(void *this, int);
_DWORD *__thiscall sub_405200(_DWORD *this, _DWORD *);
_DWORD *__thiscall sub_405250(_DWORD *this, _DWORD *);
_DWORD *__thiscall sub_4052B0(_DWORD *this, _DWORD *);
void *__thiscall sub_405310(void *this, char);
_DWORD *__thiscall sub_405360(_DWORD *this, size_t Size, char);
int __thiscall sub_405410(_DWORD **this);
int *__fastcall sub_4054C0(int *, int, unsigned int, unsigned __int16);
int __cdecl sub_405580(int, _WORD *, int *, int, _DWORD **, int);
_BYTE *__thiscall sub_406890(_BYTE *this);
int __thiscall sub_4068F0(void *this, int);
void __thiscall sub_406910(void **this);
_DWORD *__thiscall sub_406940(_DWORD *this, size_t Size, char);
_DWORD *__thiscall sub_406A00(_DWORD *this, _DWORD *, unsigned int, unsigned int);
int *__fastcall sub_406B10(int *a1, int a2, int a3, unsigned int a4, unsigned __int16 a5);
void __thiscall sub_406B70(_BYTE *this);
__int16 __thiscall sub_406BD0(_WORD *this);
struct std::locale::facet *__cdecl sub_406C30(int);
struct std::locale::facet *__cdecl sub_406D70(int);
int __cdecl sub_406EB0(int, int, size_t Size, int); // idb
int __cdecl sub_407260(int, int);
int __cdecl sub_4072C0(_DWORD *, int);
int __thiscall sub_407380(int this, int);
int __cdecl sub_4073D0(_DWORD *, int);
__int16 __thiscall sub_4074A0(unsigned int this, int, char);
_BYTE *__cdecl sub_407690(const char *);
wchar_t *__cdecl sub_4076D0(char *, int, _Cvtvec *);
char *__cdecl sub_407790(char *, unsigned __int16, unsigned int);
char __thiscall sub_4077D0(_DWORD *this, int, size_t Size, char);
_DWORD *__thiscall sub_407810(_DWORD *this, unsigned int, unsigned int);
_DWORD *__thiscall sub_4078A0(_DWORD *this, _DWORD *, unsigned int, void *);
void *__stdcall sub_407990(size_t Size);
void *__thiscall sub_4079E0(int this, void *, size_t Size);
BOOL __thiscall sub_407B50(void *this, void *, char);
_DWORD *__thiscall sub_407C00(_DWORD *this, void *Src, size_t Size);
_DWORD *__thiscall sub_407D00(_DWORD *this, void *Src);
unsigned __int16 __cdecl sub_407D40(int a1, int a2, _Cvtvec *a3);
void __thiscall sub_407D70(void *this, char, size_t Size);
// void __usercall sub_407DF0(_DWORD *@<esi>);
double __cdecl sub_407E80(float, int Y);
void *__thiscall sub_407EA0(void *this, char);
int __stdcall sub_407ED0(int);
__int64 sub_407EE0();
__int64 __thiscall sub_407EF0(int this, void *, int, int);
__int64 __thiscall sub_407FF0(_DWORD **this);
__int64 __thiscall sub_408010(int this, void *Src, int, int);
_DWORD *__stdcall sub_408100(_DWORD *, int, int, int, int);
_DWORD *__stdcall sub_408130(_DWORD *, int, int, int, int, int, int, int);
void *__thiscall sub_408160(void *this, int, int, int);
void __thiscall sub_408180(_DWORD *this);
char *__thiscall sub_408200(struct std::ios_base *this, char);
int __thiscall sub_408250(LPCRITICAL_SECTION *this);
void __thiscall sub_408260(LPCRITICAL_SECTION *this);
int sub_408270();
// int __usercall sub_408280@<eax>(int@<esi>);
// int __thiscall std::locale::id::operator unsigned int(_DWORD); weak
int __thiscall sub_408320(int *this, unsigned int);
void *__thiscall sub_408360(void *this, char);
const wchar_t *__thiscall sub_4083A0(int this, wchar_t *, wchar_t *, __int16 *);
unsigned __int16 *__thiscall sub_4083C0(void *this, int, unsigned __int16 *, unsigned __int16 *);
unsigned __int16 *__thiscall sub_408400(void *this, int, unsigned __int16 *, unsigned __int16 *);
wchar_t *__thiscall sub_408440(char *this, wchar_t *, wchar_t *);
wchar_t __thiscall sub_408480(int this, wchar_t);
wchar_t *__thiscall sub_4084A0(char *this, wchar_t *, wchar_t *);
wchar_t __thiscall sub_4084E0(int this, wchar_t);
// _BYTE *__userpurge sub_408500@<eax>(int@<ecx>, _BYTE *, _BYTE *, mbstate_t);
int __thiscall sub_408570(int this, char);
wchar_t *__thiscall sub_4085B0(char *this, wchar_t *, wchar_t *, char, char *);
char __thiscall sub_408620(int this, wchar_t, char);
_Cvtvec *__thiscall sub_408670(int this, int);
struct std::_Locinfo *__thiscall sub_4086C0(struct std::_Locinfo *this, char *Locale);
void __thiscall sub_408790(std::_Lockit *this);
int __cdecl sub_408840(_DWORD *, int);
struct std::locale::facet *__cdecl sub_408900(int);
// void __thiscall std::locale::facet::_Incref(std::locale::facet *__hidden this); idb
_DWORD *__thiscall sub_408A70(_DWORD **this, _DWORD *);
int __fastcall sub_408AB0(int);
void __thiscall sub_408B00(int *this);
int __thiscall sub_408B50(_DWORD **this);
__int64 __thiscall sub_408B80(_DWORD **this);
int sub_408BA0();
// int __usercall sub_408BB0@<eax>(int **@<eax>);
BOOL __thiscall sub_408C40(int this, __int16, wchar_t);
std::exception *__thiscall sub_408C80(std::exception *this, struct exception *);
std::exception *__thiscall sub_408CB0(std::exception *this, struct exception *);
void *__thiscall sub_408CE0(void *this, char);
std::exception *__thiscall sub_408D10(std::exception *this, struct exception *);
void __cdecl __noreturn sub_408D30(char *); // idb
char __stdcall sub_408E00(int);
struct std::ios_base *__thiscall sub_408FC0(struct std::ios_base *this, char);
void __thiscall sub_409000(int this);
void *__cdecl sub_409030(void *, void *Src, int);
_DWORD *__thiscall sub_409050(_DWORD *this, unsigned int, unsigned int);
int __thiscall sub_4090E0(int this, _DWORD *, unsigned int, unsigned int);
void *__stdcall sub_4091E0(char *);
void __thiscall sub_409240(int this, unsigned int, const void *);
void __thiscall sub_4093C0(void *this, char, int);
BOOL __thiscall sub_409410(void *this, int, char);
__int64 __thiscall sub_4094D0(_DWORD *this, unsigned int);
_DWORD *__fastcall sub_4094F0(_DWORD *a1, int a2, void *Src, int a4);
_DWORD *__thiscall sub_4095E0(_DWORD *this, void *Src);
int __stdcall sub_409630(DWORD dwErrCode); // idb
int __stdcall sub_409750(int, int, int, DWORD dwErrCode); // idb
_DWORD *__thiscall sub_409880(_DWORD *this);
// int __userpurge sub_409890@<eax>(_DWORD *@<edi>, int);
// int __usercall sub_409920@<eax>(int@<esi>);
// int __usercall sub_409970@<eax>(_DWORD *@<ecx>, _DWORD *@<ebx>);
unsigned int __thiscall sub_409A10(_DWORD *this);
unsigned int __thiscall sub_409A60(int this, unsigned int);
void *__fastcall sub_409B40(unsigned int);
void __fastcall sub_409B90(_DWORD *, _DWORD *);
// int __usercall sub_409CA0@<eax>(_DWORD *@<eax>, int@<ecx>, _DWORD *@<ebx>);
// _DWORD *__usercall sub_409CF0@<eax>(_DWORD *result@<eax>, _DWORD *@<ebx>);
int __cdecl sub_409D50(_DWORD *, int);
_DWORD *__thiscall sub_409E30(_DWORD *this, _DWORD *);
int __stdcall sub_409E60(DWORD dwErrCode); // idb
int __stdcall sub_409F80(int, int, DWORD dwErrCode); // idb
void __thiscall sub_40A0B0(void *); // idb
void __thiscall sub_40A110(void *); // idb
// void __usercall sub_40A140(int@<ebx>);
// _DWORD *__userpurge sub_40A1A0@<eax>(_DWORD *@<ebx>, int@<edi>, void *);
char *__stdcall sub_40A200(char *, int, int);
int __stdcall sub_40A2D0(DWORD dwErrCode); // idb
int __fastcall sub_40A3F0(int, _DWORD *);
// _DWORD *__usercall sub_40A410@<eax>(_DWORD *@<esi>);
// _DWORD *__usercall sub_40A470@<eax>(_DWORD *@<esi>);
// void __usercall sub_40A4D0(void **@<esi>);
char **__stdcall sub_40A550(char *, int, int);
// void __usercall sub_40A5B0(int@<ebx>);
// void __usercall sub_40A600(int@<ebx>);
// void __usercall sub_40A660(int@<esi>);
// void __usercall sub_40A700(int@<esi>);
int __stdcall sub_40A890(int);
int __stdcall sub_40A8A0(int);
int __stdcall sub_40A8B0(int);
int __stdcall sub_40A8C0(int);
int __stdcall sub_40A8D0(int);
int __stdcall sub_40A8E0(int);
int __stdcall sub_40A8F0(int, _DWORD *, int *);
int __stdcall sub_40A900(int, _DWORD *, int *);
int __stdcall sub_40A910(int, _DWORD *, int *);
HMODULE __stdcall sub_40A920(LPCWSTR lpLibFileName);
int __fastcall sub_40AA20(_DWORD *, _DWORD *);
void *__thiscall sub_40AA90(void *this, char);
// char *__usercall sub_40AAD0@<eax>(int@<eax>, int@<edi>);
int *__cdecl sub_40AB10(_DWORD *, _DWORD *);
_DWORD *__fastcall sub_40ABC0(int a1, void *a2, _DWORD *a3);
// _DWORD *__userpurge sub_40ABF0@<eax>(_DWORD *@<edi>, int@<esi>, void *);
char ***__stdcall sub_40AC30(char ***, int **);
char ***__stdcall sub_40ACF0(char ***, int **);
char ***__stdcall sub_40ADB0(char ***, int **);
// char **__usercall sub_40AE70@<eax>(int@<eax>, int@<edi>);
// _DWORD *__usercall sub_40AEB0@<eax>(_DWORD *@<esi>);
// char *__usercall sub_40AF30@<eax>(int@<eax>, int@<edi>);
void *__thiscall sub_40AF70(void *this, void *Src);
char **__stdcall sub_40AFF0(char *, int, int);
// void __usercall sub_40B060(int@<ebx>);
char *__stdcall sub_40B0E0(char *, int, int);
// _DWORD *__usercall sub_40B1A0@<eax>(unsigned __int16 *@<edx>, _DWORD *@<esi>, _DWORD *);
void *__thiscall sub_40B1F0(void *this, void *Src);
// _DWORD *__userpurge sub_40B220@<eax>(unsigned int@<eax>, _DWORD *@<ecx>, void *Src);
// _DWORD *__userpurge sub_40B350@<eax>(unsigned int@<eax>, _DWORD *@<esi>, _DWORD *, unsigned int);
int __stdcall sub_40B4B0(int, char *, int, int, int); // idb
int __stdcall sub_40B580(int, char *, int, int, int); // idb
int __thiscall sub_40B650(_DWORD *this, int);
int __stdcall sub_40B6E0(int, char *, int, int, int); // idb
// char **__usercall sub_40B7B0@<eax>(int@<eax>, int@<edi>);
// char ***__usercall sub_40B7F0@<eax>(int **@<eax>, char ***@<ecx>);
// int __userpurge sub_40B820@<eax>(char ***@<esi>, int, int, int);
int __stdcall sub_40B870(int, char *, int, int, int); // idb
// int __usercall sub_40B950@<eax>(int result@<eax>, int@<edi>);
int __stdcall sub_40B980(_DWORD *);
void *__thiscall sub_40B9F0(void *this, char);
void *__thiscall sub_40BA20(void *this, char);
_DWORD *__stdcall sub_40BA50(_DWORD *);
void *__thiscall sub_40BB00(void *this, char);
// void __usercall sub_40BB60(int@<eax>);
int *__stdcall sub_40BB80(int *, int);
void __stdcall sub_40BD70(int *);
// int *__userpurge sub_40BE20@<eax>(int *@<eax>, const unsigned __int16 *@<edi>, unsigned int);
_DWORD *__stdcall sub_40BE70(_DWORD *);
int __thiscall sub_40BF20(_DWORD *this);
// _DWORD *__usercall sub_40BFB0@<eax>(int@<eax>, _DWORD *@<ecx>);
// void __usercall sub_40C000(int@<eax>);
char *__thiscall sub_40C050(struct std::ios_base *this, char a2);
char *__thiscall sub_40C090(struct std::ios_base *this, char);
// _DWORD *__userpurge sub_40C0F0@<eax>(unsigned int@<eax>, _DWORD *@<esi>, unsigned int, _DWORD *, unsigned int, unsigned int);
// _DWORD *__userpurge sub_40C420@<eax>(unsigned int a1@<eax>, int a2, void *Src, int a4);
int __stdcall sub_40C610(int *, _WORD *, unsigned int);
// _DWORD *__userpurge sub_40C6D0@<eax>(_DWORD *@<esi>, int);
_DWORD *__thiscall sub_40C810(void *this, _DWORD *, int, _DWORD *, int, unsigned __int16, unsigned __int8);
int __thiscall sub_40CA60(void *this, int, int, int, int, int, int);
int __thiscall sub_40CAE0(void *this, int, int, int, int, int, int);
int __thiscall sub_40CB60(void *this, int, int, int, int, int, int, int);
int __thiscall sub_40CBF0(void *this, int, int, int, int, int, int, int);
int __thiscall sub_40CC80(void *this, int, int, int, int, int, double);
int __thiscall sub_40CE90(void *this, int, int, int, int, int, double);
int __thiscall sub_40D090(void *this, int, int, int, int, int, const void *);
_DWORD *__thiscall sub_40D100(_DWORD *this, void *Src, int);
_DWORD *__cdecl sub_40D130(int, int, int, int, int, int, void *Buf, int, int, int, size_t MaxCount);
_BYTE *__cdecl sub_40D790(int, _BYTE *, _BYTE *, __int16);
int __cdecl sub_40D820(int, int, int, int, int, int, void *Buf, int); // idb
_DWORD *__cdecl sub_40DB10(int, _DWORD *, int, _DWORD *, unsigned __int16 *, int);
_DWORD *__cdecl sub_40DB80(int, _DWORD *, int, _DWORD *, int, int);
_DWORD *__thiscall sub_40DBF0(_DWORD *this, void *Src, size_t Size);
_DWORD *__cdecl sub_40DD10(int, _DWORD *, int, _DWORD *, char *, int);
int __cdecl sub_40DDE0(int, int, int, int, void *Buf, size_t MaxCount, int); // idb
_DWORD *__thiscall sub_40DE80(_DWORD *this, int);
_DWORD *__thiscall sub_40DEE0(_DWORD *this, int, int, size_t Size);
// _DWORD *__usercall sub_40DFD0@<eax>(_DWORD *@<eax>, _DWORD *@<ecx>, _DWORD *@<esi>);
struct std::locale::facet *__cdecl sub_40E010(int);
// int __userpurge sub_40E150@<eax>(int@<eax>, unsigned int@<edx>, int *@<esi>, int, int);
int __cdecl sub_40E1A0(_DWORD *, int);
char __cdecl sub_40E260(int, unsigned __int16 *, int *, int);
// int __userpurge sub_40E400@<eax>(int@<eax>, unsigned int@<ebx>, int@<edi>, int, int);
int __stdcall sub_40E4B0(_DWORD *);
// void __usercall sub_40E570(int@<eax>);
// int __userpurge sub_40E5C0@<eax>(int@<eax>, int@<edx>, int@<esi>, int, int, char, int);
_DWORD *__thiscall sub_40E6A0(int this, _DWORD *, unsigned __int16 *, unsigned __int16 *, int);
// bool __usercall sub_40E970@<al>(char a1@<cl>, int a2@<ebx>, int a3@<esi>);
// int __usercall sub_40EAA0@<eax>(int@<ecx>, unsigned __int16 **@<esi>);
char __thiscall sub_40EC40(_DWORD *this);
// _DWORD *__userpurge sub_40EDF0@<eax>(unsigned int@<eax>, _DWORD *@<esi>, int);
// _DWORD *__usercall sub_40EE60@<eax>(int@<ebx>, int@<edi>);
// _DWORD *__userpurge sub_40EEE0@<eax>(int@<esi>, int);
// int __usercall sub_40EF40@<eax>(_DWORD *@<esi>);
__int16 __thiscall sub_40EFA0(void *this, int);
// int __usercall sub_40F010@<eax>(int@<eax>, __int16@<di>, __int16@<si>);
// void __usercall sub_40F060(int@<ebx>);
void *__thiscall sub_40F100(void *this, char);
// struct std::locale::facet *__usercall sub_40F130@<eax>(int@<ebx>);
// struct std::locale::facet *__usercall sub_40F1E0@<eax>(int@<ebx>);
// unsigned int __usercall sub_40F290@<eax>(unsigned int@<eax>, int *@<edi>);
// int __userpurge sub_40F360@<eax>(int@<edx>, int@<ecx>, int@<esi>, int);
int __thiscall sub_40F380(const _Collvec *this, wchar_t *, wchar_t *, wchar_t *, wchar_t *);
int __fastcall sub_40F3B0(_Collvec *, int, int, wchar_t *, _Collvec *);
int __stdcall sub_40F4A0(unsigned __int16 *, unsigned __int16 *);
// _DWORD *__usercall sub_40F4D0@<eax>(int@<eax>, _DWORD *@<edi>);
// unsigned int __usercall sub_40F500@<eax>(int *@<ecx>, int@<ebx>);
unsigned int __thiscall sub_40F570(int *this, unsigned int);
void *__fastcall sub_40F660(unsigned int);
BOOL __thiscall sub_40F6C0(int *this, int a2, int a3);
// _DWORD *__usercall sub_40FB50@<eax>(unsigned __int16 *@<eax>, __int16@<dx>, unsigned __int16 *@<ecx>, _DWORD *@<esi>, int, unsigned __int16 *, int, char);
__int16 **__cdecl sub_40FBE0(__int16 **, __int16 *, __int16 *, unsigned int *);
// char __usercall sub_40FC50@<al>(int@<ecx>, unsigned __int16@<si>);
// char __usercall sub_40FC80@<al>(int *@<edx>, void *@<ecx>, unsigned __int16);
BOOL __fastcall sub_40FF30(int, int);
// int __usercall sub_40FF70@<eax>(int@<eax>);
// char __usercall sub_40FFC0@<al>(int@<eax>);
// BOOL __usercall sub_4102E0@<eax>(int@<eax>);
// _DWORD *__usercall sub_410320@<eax>(int@<esi>);
// _DWORD *__userpurge sub_410370@<eax>(int@<edi>, int);
struct std::locale::facet *__cdecl sub_410420(int *);
std::exception *__thiscall sub_410560(std::exception *this, struct exception *);
int __cdecl sub_410580(_Collvec **, void *);
// char __userpurge sub_410680@<al>(int@<eax>, int@<esi>, int);
// char __userpurge sub_410720@<al>(int *@<ebx>, _DWORD *, char, int);
char __stdcall sub_410910(int *, int);
bool __thiscall sub_410AC0(int this);
// _DWORD *__usercall sub_410B40@<eax>(__int16@<ax>, int@<edx>, char@<cl>, _DWORD *@<esi>, int, unsigned __int16 *, unsigned __int16 *, unsigned __int16 *);
// int *__usercall sub_410BE0@<eax>(unsigned __int16 *@<eax>, unsigned __int16 *@<ebx>, int *, int, unsigned __int16 *, int, char);
int *__cdecl sub_410C60(int *, int, unsigned __int16 *, unsigned __int16 *, unsigned __int16 *, int, char);
// int *__usercall sub_410E20@<eax>(__int16 *@<edx>, int *, int, _WORD *, __int16 *, int, char);
_DWORD *__thiscall sub_410EA0(void *this, _DWORD *, int, int);
// int __userpurge sub_410FA0@<eax>(int@<eax>, int@<ecx>, int);
// _BYTE *__usercall sub_411010@<eax>(_DWORD *@<edi>);
// char __usercall sub_411080@<al>(int@<eax>);
// char __usercall sub_411150@<al>(_DWORD *@<eax>);
// unsigned __int16 *__usercall sub_411200@<eax>(unsigned __int16 **@<eax>);
// _DWORD *__usercall sub_411340@<eax>(int@<esi>);
// _DWORD *__usercall sub_411390@<eax>(int@<esi>);
// _DWORD *__usercall sub_4113E0@<eax>(int@<esi>);
// int __userpurge sub_411430@<eax>(_DWORD *@<eax>, int);
// int __usercall sub_4114E0@<eax>(int result@<eax>, int@<ecx>);
BOOL __thiscall sub_411500(int *this, unsigned __int16, unsigned __int16);
// int *__usercall sub_4115E0@<eax>(int *@<edi>, int, unsigned __int16 *, unsigned __int16 *, unsigned __int16 *, int, char);
int *__cdecl sub_411670(int *, int, unsigned __int16 *, unsigned __int16 *, unsigned __int16 *, int, char);
int *__cdecl sub_411830(int *, int, _WORD *, _WORD *, _WORD *, int, char);
bool __thiscall sub_4118C0(void *this);
// char __userpurge sub_4118E0@<al>(int@<edi>, char);
// char __usercall sub_411AF0@<al>(int@<esi>);
int __stdcall sub_411C60(int);
// _DWORD *__usercall sub_411CB0@<eax>(_DWORD *a1@<esi>);
// _DWORD *__usercall sub_411D20@<eax>(char a1@<al>, _DWORD *a2@<esi>);
// _DWORD *__usercall sub_411D50@<eax>(int@<esi>);
// _DWORD *__userpurge sub_411DC0@<eax>(int@<esi>, int);
// _DWORD *__userpurge sub_411E20@<eax>(_DWORD *@<esi>, int, int, char);
// _DWORD *__usercall sub_411F20@<eax>(int@<esi>);
void *__thiscall sub_411F80(void *this, char);
void __stdcall sub_411FB0(void **, int, int, int);
// int __usercall sub_412020@<eax>(int@<eax>, int@<ecx>, int@<ebx>);
// int __usercall sub_4120F0@<eax>(int@<esi>);
// char __usercall sub_4121D0@<al>(int@<eax>);
// char __usercall sub_4122D0@<al>(__int16@<ax>, int@<ecx>);
// char __usercall sub_412330@<al>(__int16@<ax>, int@<ecx>);
// int __userpurge sub_412360@<eax>(int@<ebx>, int, unsigned __int16 *, char);
// int __userpurge sub_412560@<eax>(int@<eax>, int@<ecx>, _DWORD *);
_DWORD *__thiscall sub_412700(_DWORD *this, char);
// _BYTE *__usercall sub_4127F0@<eax>(int@<eax>, _DWORD *@<ecx>);
// int __userpurge sub_412870@<eax>(_DWORD *@<eax>, int);
// int __usercall sub_412910@<eax>(unsigned __int16 *@<eax>, unsigned __int16 **@<ecx>);
// int __usercall sub_412AA0@<eax>(int@<eax>);
// _BYTE *__userpurge sub_412B30@<eax>(int@<eax>, int, int);
void __thiscall sub_412BD0(int this, void *Src, int, int, int);
void __fastcall sub_412D60(_WORD *, _WORD *, int, unsigned int);
// _WORD *__userpurge sub_412F00@<eax>(unsigned int **@<eax>, unsigned int@<ebx>, _WORD *, _WORD *);
_DWORD *__fastcall sub_412F70(void *a1, void *a2, int a3, _DWORD *a4);
// _WORD *__userpurge sub_413070@<eax>(int@<esi>, _WORD *, _WORD *);
// _WORD *__usercall sub_4130E0@<eax>(_WORD *result@<eax>, _WORD *, _WORD *);
// int __usercall sub_413110@<eax>(int@<eax>, _WORD *, __int16 *);
int __fastcall sub_4131B0(int, void *, void **, int, int);
// int __userpurge sub_413220@<eax>(int@<eax>, int@<esi>, void *, void *Src, int);
_DWORD *__thiscall sub_413350(void *this, _DWORD *);
_DWORD *__thiscall sub_4133A0(_DWORD *this, int, size_t Size, char);
char *__thiscall sub_4134A0(struct std::ios_base *this, char);
int __thiscall sub_4134F0(int *this);
int __stdcall sub_413550(int **);
void *__thiscall sub_4135E0(void *this, char);
void *__thiscall sub_413610(void *this, char);
void __thiscall sub_413640(void **this);
// int *__usercall sub_4138C0@<eax>(unsigned __int16 *@<ebx>, int *, int *, int *);
// int __userpurge sub_413950@<eax>(unsigned int@<eax>, int@<edx>, int@<esi>, int, int, int);
bool __cdecl sub_4139C0(int a1, int a2, int *a3, int a4);
void __stdcall sub_413AA0(int ***, int ***);
// _DWORD *__usercall sub_413C10@<eax>(unsigned __int16 *a1@<ecx>, unsigned __int16 *a2@<ebx>, _DWORD *a3, int *a4, unsigned __int16 *a5, int *a6);
// char __usercall sub_413DD0@<al>(unsigned __int16 *a1@<edx>, unsigned __int16 *a2@<ecx>, _DWORD *a3, int *a4, int a5, int a6);
// int **__usercall sub_413F80@<eax>(unsigned __int16 *@<eax>, int **, unsigned __int16 *, int *);
// int **__usercall sub_413FF0@<eax>(int@<edi>, int **, int *, unsigned __int16 *, unsigned __int16 *);
int **__cdecl sub_414110(int **, int, int *, unsigned __int16 *, unsigned __int16 *);
// int **__usercall sub_414350@<eax>(unsigned __int16 *@<eax>, int **@<esi>);
// int __userpurge sub_4143A0@<eax>(int@<eax>, int@<edx>, int@<ecx>, int@<esi>, int, char, int);
int *__thiscall sub_414440(int *this, unsigned int, unsigned int, unsigned __int16);
unsigned __int16 *__thiscall sub_414550(int this, unsigned __int16 *a2, unsigned __int16 *a3, int a4);
// bool __usercall sub_414860@<al>(char a1@<cl>, int a2@<ebx>, int a3@<esi>);
BOOL __thiscall sub_414990(int *this, int a2, int a3);
// unsigned __int16 *__usercall sub_414E20@<eax>(char@<al>, unsigned __int16 *@<edx>, __int16@<bx>, _WORD *, unsigned __int16 *, unsigned __int16 *, int *);
__int16 *__cdecl sub_414E80(__int16 *, __int16 *, _DWORD *);
// char __userpurge sub_414F00@<al>(int@<eax>, int@<esi>, int);
// char __userpurge sub_414FB0@<al>(int *@<ebx>, _DWORD *, char, int);
char __stdcall sub_4151A0(__int16 **, int);
bool __thiscall sub_415330(int this);
unsigned __int16 *__cdecl sub_4153D0(int, unsigned __int16 *, _WORD *, int *, char);
unsigned __int16 *__cdecl sub_415600(int a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, char a6);
// _WORD *__usercall sub_4157B0@<eax>(__int16 *@<edx>, _WORD *@<ecx>, __int16 *@<edi>, _WORD *@<esi>, int, char);
// int __usercall sub_415800@<eax>(int result@<eax>, int@<ecx>, int@<esi>);
// char **__usercall sub_415830@<eax>(int@<ebx>, char **@<esi>);
// int __usercall sub_415870@<eax>(int@<ecx>, int@<esi>);
// int __usercall sub_4158A0@<eax>(int@<ecx>, int@<esi>);
_DWORD *__thiscall sub_4158D0(_DWORD *this);
_DWORD *__stdcall sub_415920(_DWORD *);
// void __usercall sub_415B50(void **@<esi>);
int __thiscall sub_415CD0(void *this, int);
char ***__stdcall sub_415D90(char ***, int **);
char ***__stdcall sub_415E50(char ***, int **);
// _DWORD *__usercall sub_415F10@<eax>(int@<esi>);
// _DWORD *__userpurge sub_415F40@<eax>(char *@<eax>, _DWORD *@<esi>, unsigned int);
// char **__userpurge sub_416060@<eax>(char **@<esi>, char *, int);
// _DWORD *__usercall sub_4160E0@<eax>(char *@<eax>, _DWORD *@<edi>, _DWORD *);
int __stdcall sub_416130(int, char *, int, int, int); // idb
int __stdcall sub_416200(int, int, DWORD dwErrCode); // idb
int __stdcall sub_416330(DWORD dwErrCode); // idb
FARPROC __stdcall sub_416450(DWORD dwErrCode);
int __thiscall sub_416550(_DWORD *this);
// int __userpurge sub_4166A0@<eax>(int@<eax>, unsigned int *);
// void __usercall sub_416710(int@<esi>);
void *__thiscall sub_416770(void *this, int);
void *__thiscall sub_4167F0(void *this, char);
// _DWORD *__usercall sub_416820@<eax>(_DWORD *@<eax>, _DWORD *@<edi>);
// void __usercall sub_4168A0(_DWORD *@<edi>);
// int __usercall sub_416900@<eax>(_DWORD *@<ebx>, _DWORD *@<esi>);
int __stdcall sub_4169E0(int *, _DWORD *);
// _DWORD *__userpurge sub_416AF0@<eax>(_DWORD *a1@<edi>, _DWORD *a2, int a3, int a4);
unsigned int __thiscall sub_416BA0(_DWORD *this);
int __stdcall sub_416C10(int, char *); // idb
// void __usercall sub_416D20(int@<ebx>);
unsigned int __thiscall sub_416D80(int this, unsigned int);
// int __usercall sub_416E70@<eax>(_DWORD *@<esi>);
void *__fastcall sub_416ED0(unsigned int);
void __fastcall sub_416F30(unsigned int, int *, void **, void **);
// _DWORD *__usercall sub_417180@<eax>(_DWORD *@<esi>, void *, int, int, int, int, int, int, int, int, int, int);
void __thiscall sub_417240(_DWORD *this, _DWORD **);
std::exception *__thiscall sub_4172F0(std::exception *this, struct exception *);
int __stdcall sub_417310(int, int, int, void *); // idb
void __stdcall sub_417420(int);
// _DWORD *__userpurge sub_4174D0@<eax>(_DWORD *@<ebx>, int@<edi>, void *);
int __fastcall sub_417530(int, int, int, int, int);
int __thiscall sub_4175A0(_DWORD **this, int);
int *__cdecl sub_4175F0(int, int, int, int, void *, int, int, int, int, int);
bool __cdecl sub_417730(int a1, int a2, int *a3, int a4);
// int __usercall sub_417810@<eax>(int result@<eax>, _DWORD *@<edx>, _DWORD *@<ecx>);
// _DWORD *__usercall sub_417830@<eax>(_DWORD *result@<eax>, _DWORD *@<edx>, _DWORD *@<ecx>);
// _DWORD *__usercall sub_417860@<eax>(_DWORD *result@<eax>, _DWORD *@<edx>, _DWORD *@<ecx>);
// int __usercall sub_417880@<eax>(int@<eax>, int@<ecx>);
char **__thiscall sub_4178F0(_DWORD *this, char *, int);
// void __usercall sub_4179C0(int@<esi>);
// _DWORD *__userpurge sub_417A20@<eax>(_DWORD *@<eax>, int *@<ebx>, _DWORD *);
// int __userpurge sub_417AD0@<eax>(char ***@<esi>, int, int, int);
// void __usercall sub_417B20(int@<esi>);
int *__stdcall sub_417B50(void **, int, int, int);
int *__thiscall sub_417BC0(int this, void *Src, int, int, int);
// _DWORD *__usercall sub_417D70@<eax>(_DWORD *result@<eax>, _DWORD *, _DWORD *);
// int __usercall sub_417DA0@<eax>(int@<eax>, _DWORD *, int *);
// BSTR **__userpurge sub_417E40@<eax>(const OLECHAR *@<edi>, BSTR **);
// void __usercall sub_417EE0(int *@<edi>);
void *__thiscall sub_417F40(void *this, char);
void *__thiscall sub_417F70(void *this, char);
int __stdcall sub_417FA0(int, char *); // idb
void *__cdecl sub_418090(void *, int, int);
HWND __stdcall sub_418180(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPVOID lpParam);
int __stdcall sub_4182B0(LPCWSTR lpClassName, HINSTANCE hInstance); // idb
_DWORD *__thiscall sub_4183D0(_DWORD *this, char);
__int16 __stdcall sub_418400(DWORD dwErrCode);
void *__thiscall sub_418500(void *this, char);
int __stdcall sub_418540(DWORD dwErrCode); // idb
// _DWORD *__usercall sub_418660@<eax>(_DWORD *@<eax>);
void sub_4186B0();
// _DWORD *__userpurge sub_418730@<eax>(_DWORD *@<edi>, void *);
__int16 *__stdcall sub_4187F0(char *);
// _DWORD *__userpurge sub_4188E0@<eax>(int *@<ebx>, _DWORD *);
// int __usercall sub_4189A0@<eax>(int@<ebx>, char **@<esi>);
int __stdcall sub_418A00(int, int, int, void *); // idb
void __stdcall sub_418B10(int);
int __fastcall sub_418BC0(int, int, int, int, int);
int __thiscall sub_418C30(_DWORD **this, int);
int __stdcall sub_418C80(int, double); // idb
_DWORD *__fastcall sub_418E70(int *, int, _DWORD *);
_DWORD *__thiscall sub_418F30(int **this, _DWORD *, int *);
// int __userpurge sub_418FD0@<eax>(int@<ebx>, char *@<edi>, _WORD *);
int *__cdecl sub_419050(int *, const unsigned __int16 *);
// int *__userpurge sub_419320@<eax>(int *@<ebx>, int *);
int __thiscall sub_4193A0(_DWORD *this, int);
// _DWORD *__userpurge sub_4193D0@<eax>(int@<edi>, _DWORD *, int *);
void *__thiscall sub_419470(void *this, int);
void **__thiscall sub_4194F0(void **this, void *Src);
_BYTE *__thiscall sub_419560(_BYTE *this, char);
// std::_Lockit *__userpurge sub_4195A0@<eax>(const char *@<edi>, std::_Lockit *);
struct std::locale::_Locimp **__stdcall sub_419640(struct std::locale::_Locimp **, const char *);
// char **__userpurge sub_419770@<eax>(char **@<esi>, char *, int);
int *__stdcall sub_4197D0(int *, int);
void *__cdecl sub_4199C0(void *, int);
// _DWORD *__usercall sub_419A80@<eax>(_DWORD *@<eax>, _DWORD *@<ecx>, _DWORD *@<edi>);
// unsigned int __userpurge sub_419B10@<eax>(int@<eax>, _DWORD *);
// _DWORD *__usercall sub_419BC0@<eax>(_DWORD *result@<eax>, int *@<edx>);
// int __usercall sub_419BE0@<eax>(int@<ebx>);
// _DWORD *__usercall sub_419D30@<eax>(int@<eax>, _DWORD *@<esi>);
_DWORD *__thiscall sub_419DC0(_DWORD *this);
// unsigned int __usercall sub_419E20@<eax>(int *@<eax>);
// char **__userpurge sub_419E70@<eax>(char **@<esi>, char *, int);
// unsigned int __userpurge sub_419EF0@<eax>(int@<esi>, unsigned int);
void *__fastcall sub_419F70(unsigned int);
int *__stdcall sub_419FD0(void **, int, int, int);
int *__thiscall sub_41A040(int this, void *Src, int, int, int);
char ***__stdcall sub_41A1F0(char ***, int **);
char **__stdcall sub_41A2B0(char *, int, int);
int __stdcall sub_41A320(int, char *, int, int, int); // idb
LONG __stdcall sub_41A3F0(int);
int __stdcall sub_41A400(int, _DWORD *, _DWORD *);
LONG __stdcall sub_41A410(int);
void *__thiscall sub_41A420(void *this, char);
// int __usercall sub_41A450@<eax>(int@<esi>);
char **__stdcall sub_41A4A0(char *, int, int);
int sub_41A510();
int __stdcall sub_41A5A0(int, _DWORD *, _DWORD *);
int __stdcall sub_41A5E0(int);
int __stdcall sub_41A600(void *); // idb
// int __userpurge sub_41A630@<eax>(_DWORD *@<eax>, int@<esi>, int);
// void __usercall sub_41A6E0(int@<esi>);
int __stdcall sub_41A750(HWND hWnd, int, int, int); // idb
int __fastcall sub_41A7C0(int, unsigned int, HWND hWnd, UINT Msg, LPARAM lParam);
// unsigned int __usercall sub_41AC60@<eax>(char *@<eax>, _DWORD *@<ebx>, int@<edi>);
void __stdcall sub_41ACB0(_DWORD *);
// unsigned int __usercall sub_41AD00@<eax>(int@<edx>, int@<edi>);
void *__fastcall sub_41AE20(unsigned int);
// char *__usercall sub_41AE70@<eax>(char *result@<eax>, char *@<edx>, char *@<ebx>);
__int16 __stdcall sub_41AEA0(WNDCLASSW *lpWndClass);
int __fastcall sub_41AFA0(_DWORD *, _DWORD *, HDC hdc);
// BOOL __userpurge sub_41B160@<eax>(int@<eax>, HDC hdc, int, int);
BOOL __thiscall sub_41B240(void *this, HDC, int, int);
// void __usercall sub_41B250(int@<ecx>, HDC@<ebx>);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
// BOOL __usercall sub_41B350@<eax>(char *@<eax>);
void __thiscall sub_41B3D0(int this, int);
// LONG __userpurge sub_41B650@<eax>(HDC@<edi>, int@<esi>, LONG);
// int __userpurge sub_41B7E0@<eax>(int@<esi>, int);
// HWND __userpurge sub_41B910@<eax>(int@<esi>, int);
// LRESULT __usercall sub_41BA00@<eax>(WPARAM@<ebx>, int@<edi>, LPARAM@<esi>);
// _WORD *__userpurge sub_41BA80@<eax>(int@<eax>, int);
// BOOL __usercall sub_41BB40@<eax>(unsigned int@<ebx>, int@<esi>);
char *sub_41BBB0();
// int __userpurge sub_41BBF0@<eax>(int@<eax>, int@<edi>, int *);
_DWORD *__thiscall sub_41BCF0(_DWORD *this, char);
// _DWORD *__userpurge sub_41BD30@<eax>(_DWORD *@<esi>, int);
ATOM sub_41BD90();
int __stdcall sub_41BDF0(HWND hWnd, int, WPARAM wParam, LPARAM lParam); // idb
// int __userpurge sub_41BE70@<eax>(HWND hWnd@<ecx>, UINT@<ebx>, int@<edi>, WPARAM wParam, LPARAM lParam);
// BOOL __usercall sub_41BF50@<eax>(HWND@<esi>);
int __thiscall sub_41C030(int this, int);
// DWORD_PTR __userpurge sub_41C0F0@<eax>(HWND hWnd@<ecx>, DWORD_PTR@<esi>, int, int, int);
// void __usercall sub_41C3B0(int@<esi>);
LRESULT __stdcall pfnSubclass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData); // idb
// LRESULT __userpurge sub_41C4D0@<eax>(UINT@<eax>, int@<ecx>, HWND hWnd, WPARAM wParam, unsigned int);
// int __usercall sub_41C6D0@<eax>(IDropSource *@<eax>, int@<ecx>);
// int __usercall sub_41C730@<eax>(int@<eax>);
int __thiscall sub_41C770(_DWORD *this);
// HRESULT __userpurge sub_41C970@<eax>(const ITEMIDLIST *@<eax>, LPARAM, int);
// void __userpurge sub_41CA20(ULONG_PTR@<ebx>, int);
// int __usercall sub_41CB00@<eax>(_DWORD *@<eax>);
void __stdcall pfnAPC(ULONG_PTR Parameter); // idb
int __stdcall sub_41CCE0(int, int, int);
// int __userpurge sub_41CD00@<eax>(int@<ebx>, int@<esi>, int);
void __fastcall sub_41CED0(LPARAM, int, LPCITEMIDLIST pidl, int);
// int __usercall sub_41D430@<eax>(int@<esi>);
DWORD __stdcall sub_41D500(LPVOID lpThreadParameter); // idb
int __stdcall sub_41D530(int, void *Block); // idb
// LRESULT __usercall sub_41D6C0@<eax>(LPARAM lParam@<ecx>, LPCWSTR pszPath@<edx>, int@<ebx>);
// LRESULT __userpurge sub_41D850@<eax>(const WCHAR *@<ecx>, int@<edi>, LPARAM lParam);
// LPITEMIDLIST __usercall sub_41D9D0@<eax>(LPARAM@<eax>, int@<esi>);
// LPARAM __userpurge sub_41DA20@<eax>(int@<esi>, int);
// LPARAM __userpurge sub_41DBD0@<eax>(int@<edi>, LPCITEMIDLIST pidl2, int);
// LPARAM __usercall sub_41DD00@<eax>(int@<ecx>, int@<ebx>);
// LPARAM __usercall sub_41E080@<eax>(wchar_t *String1@<ecx>, int@<ebx>);
LRESULT __thiscall sub_41E2B0(int this, LPARAM lParam);
// int __userpurge sub_41E380@<eax>(int@<ecx>, int@<edi>, int);
DWORD __stdcall sub_41E6D0(LPVOID lpThreadParameter); // idb
char **__thiscall sub_41E750(LPCWSTR lpFileName, int);
int __stdcall sub_41E8B0(int, int, _DWORD *);
int __stdcall sub_41E8D0(int);
int __stdcall sub_41E8F0(void *); // idb
// LPARAM __usercall sub_41E920@<eax>(int@<esi>);
LPARAM __thiscall sub_41EA00(int this, LPARAM lParam);
// HRESULT __userpurge sub_41EBC0@<eax>(IDropSource *@<esi>, int, struct IDropSourceVtbl *);
// void __usercall sub_41ECB0(void **@<esi>);
// char **__usercall sub_41ECF0@<eax>(int@<eax>, int@<edi>);
// int __usercall sub_41ED30@<eax>(__int64@<edx:eax>, _DWORD *@<ebx>);
unsigned int __thiscall sub_41ED90(_DWORD *this);
char **__stdcall sub_41EE00(char *, int, int);
char *sub_41EE70();
// char **__userpurge sub_41EEB0@<eax>(char **@<esi>, char *, int);
unsigned int __thiscall sub_41EF20(int this, unsigned int);
void *__fastcall sub_41F010(unsigned int);
// _DWORD *__userpurge sub_41F070@<eax>(int@<ebx>, _DWORD *, int, const void *);
// char *__usercall sub_41F0F0@<eax>(char *result@<eax>, char *@<edx>, char *@<ebx>);
// int __usercall sub_41F120@<eax>(int@<eax>, char *, char *);
int __stdcall sub_41F240(int);
int __stdcall sub_41F250(int);
int __stdcall sub_41F260(int, int, _DWORD *);
// void __usercall sub_41F270(int@<ebx>);
// void __usercall sub_41F3E0(const WCHAR *@<ecx>, int@<esi>);
void __fastcall sub_41F4D0(int, wchar_t *);
// void __userpurge sub_41F6B0(int@<eax>, LPCWSTR lpString2);
void __cdecl sub_41F8D0(LPCWSTR pszMore, int, int);
// void __userpurge sub_41F960(int@<esi>, int, int);
void __fastcall sub_41FA40(int, const WCHAR *);
void __fastcall sub_41FBB0(int, const WCHAR *, LPARAM);
// LPARAM __userpurge sub_41FE20@<eax>(const WCHAR *a1@<ecx>, int a2@<esi>, LPARAM a3);
LRESULT __thiscall sub_41FF80(int this, LPARAM lParam, LPCITEMIDLIST pidl1);
// LRESULT __usercall sub_4200D0@<eax>(int@<eax>, int@<ecx>);
// void __usercall sub_420100(int@<ebx>, LPARAM@<esi>);
char **__stdcall sub_4201B0(char *, int, int);
int __stdcall sub_420220(int, int, char, LONG, LONG, _DWORD *);
void __stdcall sub_420410(HWND, UINT, UINT_PTR, DWORD); // idb
// int __userpurge sub_420430@<eax>(LONG *@<eax>, int@<esi>, char, char);
void __stdcall sub_4204B0(HWND, UINT, UINT_PTR, DWORD); // idb
int __stdcall sub_4204E0(int, int, struct tagPOINT Point, int); // idb
BOOL __fastcall sub_420630(int, LPARAM, int);
int __stdcall sub_420740(int);
int __stdcall sub_420790(int, int *, int, LONG, LONG, int *);
int __stdcall sub_420900(int, int, int);
int __stdcall sub_420950(int, int);
int __stdcall sub_420960(int);
int __stdcall sub_420970(int, _DWORD *, _DWORD *);
int __stdcall sub_420980(int);
int __stdcall sub_420990(int, _DWORD *, _DWORD *);
int __stdcall sub_4209A0(int, _DWORD *, _DWORD *);
int __stdcall sub_4209B0(int);
int __stdcall sub_4209C0(int);
int __stdcall sub_4209D0(int);
int __stdcall sub_4209E0(int);
int __stdcall sub_4209F0(int);
int __stdcall sub_420A00(int);
int __stdcall sub_420A10(int, _DWORD *, _DWORD *);
// char **__userpurge sub_420A20@<eax>(char **@<esi>, char *, int);
// _DWORD *__usercall sub_420AA0@<eax>(_DWORD *@<eax>, _DWORD *@<esi>);
_DWORD *__thiscall sub_420B30(_DWORD *this);
_DWORD *__thiscall sub_420C60(_DWORD *this);
_DWORD *__thiscall sub_420C90(_DWORD *this);
_DWORD *__thiscall sub_420CC0(_DWORD *this);
_DWORD *__thiscall sub_420CF0(_DWORD *this);
int *__thiscall sub_420D20(int *this, int *, int, _DWORD *, int, int, int);
_DWORD *__thiscall sub_420D60(_DWORD *this, int, int, int, int, int, int, void *, int, int, int, int, int, int);
int __stdcall sub_420F80(int, __int64);
// void __usercall sub_421010(int@<esi>);
void *__thiscall sub_4210A0(void *this, char);
// int __usercall sub_421100@<eax>(int@<ebx>);
// _DWORD *__userpurge sub_4212C0@<eax>(_DWORD *@<ebx>, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, void *, int, int, int, void *, int, int, int, int);
int *__thiscall sub_4214B0(int *this);
// void __usercall sub_421830(int *@<esi>);
_DWORD *__stdcall sub_421860(_DWORD *);
// int *__userpurge sub_421990@<eax>(int *@<eax>, int *@<ecx>, int *@<edi>, int, _DWORD *);
// _DWORD *__userpurge sub_421A10@<eax>(unsigned __int16 *@<eax>, int, _DWORD *, int, _DWORD *, int, int, int, unsigned __int16 *);
int __thiscall sub_421C40(const char *this, int, int, int, int, int, struct tm *Timeptr, char, char);
void *__thiscall sub_421E30(void *this, char);
int __thiscall sub_421E60(_DWORD *this, int);
void *__thiscall sub_421F30(void *this, char);
_DWORD *__thiscall sub_421F70(_DWORD *this, _DWORD *);
// void __usercall sub_422050(void *Src@<ecx>, int *@<edi>);
unsigned int __thiscall sub_422130(int *this, unsigned int a2);
unsigned int __thiscall sub_422240(int *this);
BOOL __cdecl sub_4222C0(int, int);
// struct std::locale::_Locimp **__userpurge sub_4222E0@<eax>(struct std::locale::facet *@<ebx>, struct std::locale::_Locimp **@<esi>, int *);
// int *__usercall sub_4223A0@<eax>(int *@<edi>, int *);
// void __usercall sub_422640(_DWORD *@<eax>, const unsigned __int16 *@<ebx>, _DWORD *);
struct std::locale::facet *__cdecl sub_4226A0(int);
// void __usercall sub_4227E0(int@<eax>, int@<edi>);
void __thiscall sub_422820(_DWORD *this);
int *__stdcall sub_4228B0(int *, int, int);
int __fastcall sub_422AA0(_DWORD *, int, _DWORD **, int, int *, int, int);
int __cdecl sub_4231F0(_DWORD *, int);
_DWORD *__stdcall sub_4232A0(_DWORD *);
// _DWORD *__usercall sub_423340@<eax>(int@<eax>, _DWORD *@<ecx>);
char *__thiscall sub_423360(_DWORD *this, char);
int __stdcall sub_423390(int, int);
// _DWORD *__usercall sub_423430@<eax>(_QWORD *@<eax>, _DWORD *@<ebx>, char);
// _DWORD *__usercall sub_4234B0@<eax>(_QWORD *@<eax>, _DWORD *@<esi>);
_DWORD *__thiscall sub_4234F0(_DWORD *this, int, void *Block);
// int __usercall sub_423540@<eax>(unsigned int *@<eax>, unsigned int *@<ecx>);
void __thiscall sub_423680(_DWORD *this, void *Block);
char __cdecl sub_4236C0(int *);
int __cdecl sub_423770(int *);
void __cdecl sub_423870(_DWORD *, int, int, int, int, int);
// void __usercall sub_423900(int *@<eax>, _DWORD *, int *);
// void __usercall sub_423970(int *@<eax>, _DWORD *);
// void __usercall sub_4239C0(_DWORD *@<eax>, _DWORD *, int *);
_DWORD *__cdecl sub_423A20(_DWORD *, int, int, int);
_DWORD *__cdecl sub_423B70(_DWORD *, int);
// _DWORD *__usercall sub_423CB0@<eax>(_DWORD *@<edi>, _DWORD *@<esi>);
_DWORD *__thiscall sub_423D20(_DWORD *this, _DWORD *, _WORD *, _WORD *);
int __cdecl sub_423DA0(int, int, int);
// _DWORD *__usercall sub_423E70@<eax>(unsigned __int16 *@<eax>, unsigned __int16 *@<ebx>, _DWORD *, int, _DWORD *);
int __cdecl sub_423EE0(_DWORD *, _DWORD *, int);
_DWORD *__cdecl sub_423F90(int, void *);
void __cdecl sub_424030(_DWORD *, int, int, int, int, int);
// void __usercall sub_4240C0(_DWORD *@<esi>, int, int, int, int);
// void __usercall sub_424150(_DWORD *@<ecx>, int *@<edi>);
void __cdecl sub_424230(int, int, int, int, int, int, int, int, int);
// _DWORD *__usercall sub_424480@<eax>(_DWORD *result@<eax>, int *@<ecx>);
// void __usercall sub_4244A0(int@<esi>);
int __thiscall sub_424510(_DWORD *this);
// _WORD *__usercall sub_424530@<eax>(int *@<eax>, int *);
_DWORD *__cdecl sub_4245D0(_DWORD *, int, int ************, int, int, int ************, int, int);
void __cdecl sub_4246B0(int, int, int, int, int, int, int, int, int);
void __cdecl sub_4248D0(int, int, int, int, int, int, int *);
// _DWORD *__usercall sub_424AB0@<eax>(int@<ecx>, int@<edi>, _DWORD *@<esi>);
// int __userpurge sub_424B00@<eax>(int *@<eax>, int, int, void *Src, int);
_DWORD *__stdcall sub_424BF0(_DWORD *, int, int **********, int, int, int **********, int, int);
// unsigned int __usercall sub_424CD0@<eax>(int@<eax>, int *);
unsigned int __cdecl sub_424D70(int *);
// _DWORD *__usercall sub_424E00@<eax>(_DWORD *result@<eax>);
// unsigned int __userpurge sub_424E30@<eax>(int@<eax>, _WORD *);
// int __usercall sub_424EE0@<eax>(int@<ebx>);
// _DWORD *__usercall sub_425030@<eax>(_DWORD *@<ebx>, int *@<esi>, int, int);
_WORD *__stdcall sub_4250C0(int *, int, int, int, _WORD *, _WORD *, int);
_DWORD *__stdcall sub_4252E0(_DWORD *, int, int ********, int, int, int ********, int, int, int);
// _WORD *__userpurge sub_4253C0@<eax>(_DWORD *a1@<eax>, _WORD *a2);
// _DWORD *__userpurge sub_425470@<eax>(int@<eax>, _DWORD *@<esi>, int);
unsigned int __cdecl sub_4254F0(int ***, int, unsigned int, int ***, int, unsigned int);
_DWORD *__cdecl sub_425570(_DWORD *a1, _DWORD **a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
_DWORD *__stdcall sub_4256D0(_DWORD *, int, int, int ******, int, int, int ******, int, int);
unsigned int __fastcall sub_4257B0(_WORD *, _WORD *, int *, int, int, int, int);
unsigned int __cdecl sub_4259B0(int, int, unsigned int, int, unsigned int);
int __cdecl sub_425A30(_DWORD *, int, int, _DWORD *, int, int);
_DWORD *__thiscall sub_425AC0(_DWORD *this, int, int, int ****, int, int, int ****, int, int, int);
int __cdecl sub_425C00(int, unsigned int, int, int, int, unsigned int);
// _DWORD *__userpurge sub_425D30@<eax>(_DWORD *@<edi>, int **, int, int, int **, int, int);
_WORD *__stdcall sub_425E10(void *, int, int, int, int, int, int, int);
void **__stdcall sub_425FC0(void **);
// struct std::locale::_Locimp *__userpurge sub_425FE0@<eax>(int@<edi>, struct std::locale::_Locimp *);
_DWORD *__thiscall sub_426070(ULONG_PTR dwData, int);
// int __userpurge sub_4265A0@<eax>(char *@<eax>, _DWORD *@<edi>, char *, char *);
// int __userpurge sub_4266B0@<eax>(const ITEMIDLIST *@<ecx>, int@<esi>, const ITEMIDLIST *, _WORD *);
char **__stdcall sub_4269E0(char *, int, int);
char **__stdcall sub_426A50(char *, int, int);
// void __cdecl __noreturn std::_Xlength_error(const char *); idb
// void __cdecl __noreturn std::_Xout_of_range(const char *); idb
std::exception *__thiscall sub_426B1B(std::exception *this, struct exception *);
// void __cdecl __noreturn std::_Xruntime_error(const char *); idb
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); idb
int __thiscall sub_426C5F(_DWORD *this);
int __thiscall sub_426C63(_DWORD *this);
int (__thiscall **sub_426C67())(void *, char);
void *__thiscall sub_426C6D(void *this, char);
// __int16 __cdecl _Getwctype(wchar_t, const _Ctypevec *);
// const wchar_t *__cdecl _Getwctypes(const wchar_t *, const wchar_t *, __int16 *, const _Ctypevec *);
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
// void __cdecl std::locale::facet::_Facet_Register(struct std::locale::facet *); idb
int sub_426E4C();
// void __cdecl std::locale::_Locimp::_Locimp_dtor(struct std::locale::_Locimp *); idb
// int __thiscall unknown_libname_3(_DWORD); weak
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale); idb
// struct std::locale::_Locimp *__cdecl std::locale::_Init(); idb
// const struct std::locale *__cdecl std::locale::classic(); idb
// int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *, const _Cvtvec *);
// _Cvtvec *__cdecl _Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Mbrtowc(wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
// wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
// wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
// _DWORD __thiscall std::_Mutex::_Mutex(std::_Mutex *__hidden this); idb
// void __thiscall std::_Mutex::~_Mutex(std::_Mutex *__hidden this); idb
// int __cdecl _Stoulx(int, int, size_t MaxCount, int); idb
// int __cdecl _Stolx(int, int, size_t MaxCount, int); idb
// int __cdecl _Stollx(int, int, size_t MaxCount, int); idb
// int __cdecl _Stoullx(int, int, size_t MaxCount, int); idb
// int __cdecl _Stofx(char *String, char **EndPtr, int, int); idb
// int __cdecl _Stodx(char *String, char **EndPtr, int, int); idb
// double __cdecl _Stoldx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl operator new[](unsigned int); idb
// _DWORD __cdecl std::setw(_DWORD, _DWORD, _DWORD); weak
bool __cdecl __uncaught_exception(); // idb
std::exception *__thiscall sub_427BCA(std::exception *this, int);
// void __noreturn unknown_libname_4(void); weak
// void __cdecl __noreturn std::tr1::_Xbad(_DWORD); weak
std::exception *__thiscall sub_427C4B(std::exception *this, struct exception *);
void *__thiscall sub_427C71(void *this, char);
// int __cdecl _Wcscoll(const wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *, const _Collvec *);
// size_t __cdecl _Wcsxfrm(wchar_t *String1, wchar_t *End1, const wchar_t *, const wchar_t *, const _Collvec *);
// _Collvec __cdecl _Getcoll();
char sub_427EA5();
int sub_427EA8();
// int std::ctype<char>::_Tidy(void); weak
void *__thiscall sub_427FE7(void *this, char);
// void __cdecl std::locale::_Locimp::_Locimp_Addfac(struct std::locale::_Locimp *, struct std::locale::facet *, unsigned int); idb
// _DWORD __stdcall std::numpunct<char>::_Init(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_6(_DWORD); weak
int __thiscall sub_428376(_BYTE *this, int);
// int __cdecl std::ctype<char>::_Getcat(void *, int); idb
int __cdecl sub_4284EC(_DWORD *, int);
int __cdecl sub_428576(_DWORD *, int);
void *__thiscall sub_428600(void *this, char);
int __cdecl sub_42862D(void *, int); // idb
// _DWORD __cdecl std::codecvt<char,char,int>::_Getcat(_DWORD, _DWORD); weak
struct std::locale::facet *__cdecl sub_428828(int *);
struct std::locale::facet *__cdecl sub_4288C5(int *);
struct std::locale::facet *__cdecl sub_428962(int *);
struct std::locale::facet *__cdecl sub_4289FF(int *);
struct std::locale::facet *__cdecl sub_428A9C(int *);
// struct std::locale::_Locimp *__cdecl std::locale::_Locimp::_Makeloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
// void __cdecl std::locale::_Locimp::_Locimp_ctor(struct std::locale::_Locimp *, const struct std::locale::_Locimp *); idb
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, int, const char *Locale); idb
// _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
_DWORD *__thiscall sub_429D6C(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, _WORD *a9);
_DWORD *__thiscall sub_429E3B(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, int *a9);
_DWORD *__thiscall sub_42A1D0(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, _DWORD *a9);
// int __cdecl std::num_put<char,std::ostreambuf_iterator<char>>::_Fput(int, int, int, int, int, char, void *Buf, int, int, int, int); idb
int __thiscall sub_42B0B9(void *this, int, int, int, int, char, double);
int __thiscall sub_42B279(void *this, int, int, int, int, char, double);
// int __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); idb
// int __cdecl unknown_libname_20(LPCRITICAL_SECTION lpCriticalSection); idb
void __cdecl sub_42B623(LPCRITICAL_SECTION lpCriticalSection);
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); idb
// int __cdecl unknown_libname_22(char *Str, int, _Cvtvec *); idb
// int __thiscall unknown_libname_23(_DWORD, _DWORD); weak
// int unknown_libname_24(void); weak
char sub_42B913();
int sub_42B916();
// _DWORD __stdcall unknown_libname_38(char); weak
int __stdcall sub_42BD36(char);
// int __stdcall unknown_libname_39(wchar_t, char); idb
int __stdcall sub_42BDBC(wchar_t, char);
// _DWORD __cdecl unknown_libname_44(_DWORD, _DWORD, char, _DWORD); weak
// _DWORD __cdecl std::_LStrcoll<unsigned short>(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_42C08A(int, int, int, int);
void *__thiscall sub_42C0AE(void *this, char);
int __thiscall sub_42C113(_DWORD *this);
// int unknown_libname_49(void); weak
void *__thiscall sub_42C144(void *this, char);
// _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, _DWORD); weak
_DWORD *__cdecl sub_42C360(_DWORD *, int, int, int, int);
// _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_53(void *, char, int); idb
// _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_54(_DWORD); weak
int __thiscall sub_42C7CF(_BYTE *this, int);
// const char *__thiscall std::_Locinfo::_Getdays(std::_Locinfo *__hidden this); idb
// const char *__thiscall std::_Locinfo::_Getmonths(std::_Locinfo *__hidden this); idb
// _DWORD __cdecl std::codecvt<wchar_t,char,int>::_Getcat(_DWORD, _DWORD); weak
// _DWORD __cdecl std::codecvt<wchar_t,char,int>::_Getcat(_DWORD, _DWORD); weak
// _DWORD __cdecl std::ctype<wchar_t>::_Getcat(_DWORD, _DWORD); weak
int __cdecl sub_42CA0D(_DWORD *, int);
int __cdecl sub_42CA8C(_DWORD *, int);
int __cdecl sub_42CB16(_DWORD *, int);
int __cdecl sub_42CBA0(_DWORD *, int);
int __cdecl sub_42CC2A(_DWORD *, int);
void *__thiscall sub_42CCB9(void *this, char);
int __cdecl sub_42CCE6(_DWORD *, int);
int __cdecl sub_42CD70(_DWORD *, int);
int __cdecl sub_42CDEF(_DWORD *, int);
int __cdecl sub_42CE79(_DWORD *, int);
int __cdecl sub_42CF03(_DWORD *, int);
int __thiscall sub_42CF8B(int this, std::_Locinfo *);
int __thiscall sub_42D06F(int this, std::_Locinfo *);
// _DWORD __stdcall unknown_libname_55(_DWORD, _DWORD); weak
struct std::locale::facet *__cdecl sub_42D2FF(int *);
struct std::locale::facet *__cdecl sub_42D39C(int *);
struct std::locale::facet *__cdecl sub_42D439(int *);
struct std::locale::facet *__cdecl sub_42D4D6(int *);
struct std::locale::facet *__cdecl sub_42D573(int *);
struct std::locale::facet *__cdecl sub_42D610(int *);
struct std::locale::facet *__cdecl sub_42D6AD(int *);
struct std::locale::facet *__cdecl sub_42D74A(int *);
struct std::locale::facet *__cdecl sub_42D7E7(int *);
struct std::locale::facet *__cdecl sub_42D884(int *);
struct std::locale::facet *__cdecl sub_42D921(int *);
struct std::locale::facet *__cdecl sub_42D9BE(int *);
struct std::locale::facet *__cdecl sub_42DA5B(int *);
int __cdecl sub_42DAF8(void *, int); // idb
void *__thiscall sub_42DB8D(void *this, char);
int __cdecl sub_42DBBA(_DWORD *, int);
_DWORD *__thiscall sub_42DC51(_DWORD *this, std::_Locinfo *, int);
void *__thiscall sub_42DC84(void *this, char);
int __cdecl sub_42DCB1(void *, int); // idb
void *__thiscall sub_42DD33(void *this, char);
int __cdecl sub_42DD60(_DWORD *, int);
int __cdecl sub_42DDF5(_DWORD *, int);
_DWORD *__thiscall sub_42DE8C(_DWORD *this, std::_Locinfo *, int);
int __thiscall sub_42DEBF(_DWORD *this);
void *__thiscall sub_42DEC3(void *this, char);
int __cdecl sub_42DEF0(_DWORD *, int);
// _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
struct std::locale::facet *__cdecl sub_42E6AF(int *);
struct std::locale::facet *__cdecl sub_42E74C(int *);
struct std::locale::facet *__cdecl sub_42E7E9(int *);
struct std::locale::facet *__cdecl sub_42E886(int *);
struct std::locale::facet *__cdecl sub_42E923(int *);
struct std::locale::facet *__cdecl sub_42E9C0(int *);
_DWORD *__thiscall sub_42F5F5(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, int a9);
// _DWORD __stdcall std::wstring::append(_DWORD, _DWORD); weak
// _DWORD __stdcall std::wstring::assign(_DWORD, _DWORD, _DWORD); weak
int __thiscall sub_430215(_DWORD *this, unsigned int, int);
// int __cdecl std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>(int, int, size_t Size, int); idb
_DWORD *__stdcall sub_430685(_DWORD *, int, int, int, _DWORD *);
int *__thiscall sub_4306A1(int *this, int *, int, int, int, int, int, _DWORD *, int);
int *__thiscall sub_4306E1(int *this, int *, int, int, int, int, int, _DWORD *, int);
int *__thiscall sub_430CE1(void *this, int *, int, int, int, int, int, _DWORD *, _DWORD *, char, int);
// _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(int, int, int, int, int, __int16, void *Buf, int, int, int, int); idb
_DWORD *__thiscall sub_4320BA(void **this, _DWORD *);
_DWORD *__thiscall sub_432283(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, _WORD *a9);
_DWORD *__thiscall sub_432352(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, int *a9);
_DWORD *__thiscall sub_43292B(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, _DWORD *a9);
int __thiscall sub_4329E1(void *this, int, int, int, int, __int16, double);
int __thiscall sub_432BA1(void *this, int, int, int, int, __int16, double);
int __cdecl sub_432DD7(_Collvec **, void *);
// _DWORD __stdcall std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD); weak
struct std::locale::facet *__cdecl sub_433E10(int *);
void __cdecl sub_433EAD(std::_Locinfo *, void *, struct std::locale::_Locimp *, int);
void __cdecl sub_43448A(std::_Locinfo *, int, struct std::locale::_Locimp *, int);
_DWORD *__stdcall sub_434BBB(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, int a9);
// _DWORD __stdcall std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD); weak
_DWORD *__stdcall sub_4362C5(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, int a9);
// int unknown_libname_73(void); weak
// int __thiscall unknown_libname_74(_DWORD); weak
// int __thiscall unknown_libname_75(_DWORD, _DWORD); weak
int __stdcall sub_4363FB(int, int);
char __thiscall sub_436401(_BYTE *this);
char __thiscall sub_436405(_BYTE *this);
// int unknown_libname_77(void); weak
void *__thiscall sub_436436(void *this, char);
// _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, _DWORD); weak
int __cdecl sub_4365F5(_DWORD *, int);
int __cdecl sub_436674(_DWORD *, int);
int __cdecl sub_4366FE(_DWORD *, int);
int __cdecl sub_436788(_DWORD *, int);
int __thiscall sub_436810(_DWORD *this, std::_Locinfo *);
struct std::locale::facet *__cdecl sub_436887(int *);
struct std::locale::facet *__cdecl sub_436924(int *);
struct std::locale::facet *__cdecl sub_4369C1(int *);
struct std::locale::facet *__cdecl sub_436A5E(int *);
void *__thiscall sub_436AFB(void *this, char);
int __cdecl sub_436B28(_DWORD *, int);
int __cdecl sub_436BBD(_DWORD *, int);
_DWORD *__thiscall sub_436C54(_DWORD *this, std::_Locinfo *, int);
void *__thiscall sub_436C87(void *this, char);
int __cdecl sub_436CB4(_DWORD *, int);
struct std::locale::facet *__cdecl sub_436FBF(int *);
struct std::locale::facet *__cdecl sub_43705C(int *);
struct std::locale::facet *__cdecl sub_4370F9(int *);
_DWORD *__thiscall sub_4376E7(_DWORD *this, unsigned int, char);
_DWORD *__thiscall sub_437BDF(void **this, _DWORD *);
int __cdecl sub_437BFB(_Collvec **, void *);
struct std::locale::facet *__cdecl sub_437CB2(int *);
// _DWORD __stdcall std::money_get<char,std::istreambuf_iterator<char>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD); weak
_DWORD *__stdcall sub_439175(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, _DWORD *a9);
// int _Getdateorder(void); weak
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// int __cdecl _vsnwprintf(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
void __thiscall sub_43959D(struct type_info *this);
void *__thiscall sub_4395AD(void *this, char);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void __cdecl operator delete(void *); idb
// void *__cdecl realloc(void *Block, size_t Size);
// void *__cdecl operator new(size_t Size); idb
// void __thiscall std::exception::_Tidy(std::exception *__hidden this); idb
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); idb
void __thiscall sub_4398D8(std::exception *this);
std::exception *__thiscall sub_4398E3(std::exception *this, char *);
void *__thiscall sub_439901(void *this, char);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct exception *); idb
std::exception *__thiscall sub_43994D(std::exception *this, struct exception *);
// void __cdecl operator delete[](void *); idb
// int __cdecl atexit(void (__cdecl *)());
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// double __cdecl ldexp(double X, int Y);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// struct lconv *__cdecl localeconv();
// int __cdecl _wtoi(const wchar_t *String);
// int sprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// errno_t __cdecl static memmove_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// char *__cdecl strchr(const char *Str, int Val);
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// errno_t __cdecl _itow_s(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// div_t __cdecl div(int Numerator, int Denominator);
// errno_t __cdecl static memcpy_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// wchar_t *__cdecl wcstok_s(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// void *__cdecl _Gettnames();
// size_t __cdecl _Strftime(char *Buffer, size_t Max_size, const char *Format, const struct tm *Timeptr, void *Lc_time_arg);
// int __cdecl iswalpha(wint_t C);
// wint_t __cdecl towupper(wint_t C);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// int *__cdecl _errno();
void __thiscall sub_43E087(std::exception *this);
void *__thiscall sub_43E092(void *this, char);
std::exception *__thiscall sub_43EC6D(std::exception *this, struct exception *);
// void *__cdecl memset(void *, int Val, size_t Size);
void *__cdecl sub_44161F(void *);
// void __cdecl _invalid_parameter_noinfo();
// void __cdecl type_info::_Type_info_dtor(struct type_info *); idb
void *__cdecl sub_441D40(void *);
int sub_442102();
// int _encoded_null(void); weak
void *__cdecl sub_443911(void *);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_443962();
void *sub_444126();
void __cdecl sub_44414C(); // idb
int __cdecl sub_4448F1(_DWORD *);
int __cdecl sub_44491E(_DWORD *);
int __cdecl sub_44494B(_DWORD *);
int *sub_444978();
int *sub_44497E();
int *sub_444984();
void **sub_44498A();
void *sub_444F1C();
char **sub_444F22();
PVOID sub_447CF8();
void sub_447EA8();
void **sub_44888F();
int __cdecl sub_448E92(int);
int __cdecl sub_448FFC(int, int, int);
int sub_44934C();
int __cdecl sub_44A81D(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_44A8C5(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_44ACD7(unsigned __int16 *, _DWORD *);
int __cdecl sub_44B228(unsigned __int16 *, _DWORD *);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl flsall(_DWORD); weak
int sub_44C272();
HANDLE sub_44D77C();
void __stdcall __noreturn sub_44DFE0(int);
HLOCAL __thiscall sub_44E000(_DWORD *this);
void __cdecl __noreturn sub_44E030(int, int);
_DWORD *__thiscall sub_44E070(_DWORD *this, int);
void *__thiscall sub_44E0B0(void *this, char);
// int __userpurge sub_44E100@<eax>(HWND@<esi>, int *);
int __stdcall sub_44E1C0(int, int, int);
// BOOL __userpurge sub_44E1F0@<eax>(int@<ebx>, int);
int __stdcall sub_44E300(int);
// _DWORD *__userpurge sub_44E360@<eax>(WPARAM@<esi>, LONG *);
// int __userpurge sub_44E7F0@<eax>(_DWORD *@<esi>, LPARAM *);
int __stdcall sub_44E9B0(int, char, LONG, LONG, int *);
int __stdcall sub_44EA90(char *, int, int, int, int, int); // idb
void __thiscall sub_44ED10(int this, _DWORD **, LONG *);
int __stdcall sub_44EEE0(int *, int *, int, int, int, int *);
int __thiscall sub_44F1A0(_DWORD *this, int);
int __stdcall sub_44F1E0(int, int, int);
int __stdcall sub_44F2A0(int, int, int);
// int __usercall sub_44F360@<eax>(_WORD *@<edi>, int@<esi>);
void __fastcall sub_44F3F0(int, _WORD *, int);
// int __userpurge sub_44F590@<eax>(int@<ecx>, int@<edi>, _WORD *);
// int __userpurge sub_44F650@<eax>(int@<ecx>, _WORD *@<ebx>, int@<edi>, int);
int __thiscall sub_44F7B0(_DWORD *this, int, _WORD *);
// int __usercall sub_44F8C0@<eax>(int@<eax>, wchar_t *@<edx>, int@<ecx>);
WPARAM __fastcall sub_44F920(WPARAM, _DWORD *, const WCHAR *);
// int __userpurge sub_44FBB0@<eax>(int@<ecx>, int@<edi>, int, _WORD *);
// int __userpurge sub_44FCC0@<eax>(int@<edx>, _WORD *@<ecx>, int@<edi>, int);
// int __userpurge sub_44FDE0@<eax>(int@<ecx>, int@<edi>, _WORD *);
int __fastcall sub_44FEA0(int, int, _WORD *);
int __fastcall sub_44FF60(_WORD *, int, int);
// int __userpurge sub_450160@<eax>(int@<ecx>, int@<edi>, int, _WORD *);
void __fastcall sub_450270(_WORD *, int, int);
_WORD *__fastcall sub_450330(int, int, int);
WPARAM __fastcall sub_450580(int, _DWORD *);
// LRESULT __usercall sub_450A10@<eax>(int@<esi>);
LRESULT __thiscall sub_450B30(int this);
LRESULT __thiscall sub_450B80(int this, WPARAM wParam);
void __stdcall sub_450BD0(HWND, UINT, UINT_PTR, DWORD); // idb
// void __usercall sub_450C00(_DWORD *@<eax>, const WCHAR *@<ebx>);
// void __usercall sub_450C70(_DWORD *@<eax>, const WCHAR *@<ebx>);
LRESULT __thiscall sub_450CE0(int this, int, LPCWSTR pszMore);
void __thiscall sub_450DD0(int this, int, int, UINT_PTR nIDEvent, int);
void __thiscall sub_450EC0(_BYTE *this, const WCHAR *);
// _DWORD *__userpurge sub_451240@<eax>(int@<esi>, const WCHAR *);
void __thiscall sub_451530(ULONG_PTR dwData, int);
void __thiscall sub_451810(int this);
// int __usercall sub_451B60@<eax>(int@<eax>, int@<ecx>, int@<esi>);
// int __usercall sub_451BA0@<eax>(int@<edx>, int@<ecx>, int@<esi>);
// int __usercall sub_451D00@<eax>(int@<edx>, int@<ecx>, int@<esi>);
// int __usercall sub_451E60@<eax>(int@<eax>, int@<ecx>, _DWORD *@<ebx>);
// int __userpurge sub_451EF0@<eax>(int@<eax>, int@<ecx>, _DWORD *);
// int __userpurge sub_452000@<eax>(int@<ecx>, int@<esi>, int);
// int __userpurge sub_452260@<eax>(int@<ecx>, int@<esi>, int);
// int __userpurge sub_452480@<eax>(int@<ecx>, int@<esi>, int);
// int __usercall sub_4525A0@<eax>(int@<eax>, int@<ecx>, _DWORD *@<ebx>);
int __fastcall sub_452680(int, int, int, int);
// LONG __userpurge sub_452A30@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3);
// int __usercall sub_452AD0@<eax>(int@<edx>, int@<ecx>, int@<esi>);
int __fastcall sub_452EF0(int, int, _DWORD *, int);
// LONG __userpurge sub_453120@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3);
// LONG __userpurge sub_4531C0@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3);
// int __userpurge sub_453260@<eax>(int@<ecx>, int@<esi>, int);
int __fastcall sub_453390(int, _DWORD *, int);
int __fastcall sub_4535E0(int, int, int);
// int __usercall sub_453890@<eax>(int@<edx>, int@<ecx>, int@<edi>);
// int __userpurge sub_4539C0@<eax>(int@<ecx>, int@<esi>, int, int);
// int __userpurge sub_453B80@<eax>(int@<ecx>, int@<esi>, int, int);
// int __userpurge sub_453D50@<eax>(int@<ecx>, int@<edi>, int);
// int __userpurge sub_453E90@<eax>(int@<ecx>, int@<esi>, int);
// int __userpurge sub_454060@<eax>(int@<ecx>, int@<esi>, int);
// int __userpurge sub_454190@<eax>(int@<ecx>, int@<esi>, int);
int __stdcall sub_454310(int, int, _DWORD *);
int __thiscall sub_454360(WPARAM wParam, int); // idb
// void __usercall sub_4543E0(LPARAM@<edi>, int@<esi>);
// WCHAR *__usercall sub_4544A0@<eax>(int@<eax>, _DWORD *@<ecx>);
HRESULT __thiscall sub_454590(void *this, int a2, int a3);
// int __usercall sub_4545E0@<eax>(LPCITEMIDLIST pidl@<ecx>, int@<ebx>);
// int __userpurge sub_454890@<eax>(LPITEMIDLIST *@<eax>, int@<ecx>, _DWORD *@<edi>, int);
// BOOL __usercall sub_454980@<eax>(int@<eax>, int@<esi>);
int __thiscall sub_454A00(int this, LPCITEMIDLIST pidl, int);
int __thiscall sub_454CD0(_WORD *this, _DWORD *, int);
// int __usercall sub_454DC0@<eax>(int@<eax>);
// LRESULT __userpurge sub_454F50@<eax>(WPARAM@<edi>, int@<esi>, WPARAM wParam, LPARAM);
// LRESULT __userpurge sub_455040@<eax>(int@<esi>, WPARAM wParam, int);
// int __userpurge sub_4550F0@<eax>(HWND hWnd@<ecx>, WPARAM@<edi>, _DWORD *@<esi>, int);
// int __userpurge sub_455170@<eax>(HWND hWnd@<ecx>, WPARAM@<edi>, _DWORD *@<esi>, int);
// void __userpurge sub_455210(WPARAM@<ebx>, int@<esi>, LPARAM);
// int __userpurge sub_4552E0@<eax>(WPARAM@<edi>, _DWORD *@<esi>, LPARAM);
int __thiscall sub_455370(_DWORD *this);
// int __userpurge sub_455380@<eax>(int@<edi>, WPARAM wParam, int);
// int __userpurge sub_4554A0@<eax>(int@<edi>, WPARAM wParam, int);
// int __userpurge sub_4555C0@<eax>(int@<edi>, WPARAM wParam, int);
// int __userpurge sub_4556E0@<eax>(int@<edi>, WPARAM wParam, int);
// void __usercall sub_455810(int@<esi>);
// void __usercall sub_455870(int@<esi>);
// _DWORD **__usercall sub_4558D0@<eax>(int@<esi>);
// int __usercall sub_455A40@<eax>(int@<esi>);
int __thiscall sub_455B80(_DWORD **this, int);
// int __usercall sub_455C00@<eax>(int@<esi>);
// _DWORD **__usercall sub_455D20@<eax>(int@<eax>);
// int __userpurge sub_455DC0@<eax>(int@<esi>, WPARAM wParam, int);
// int __userpurge sub_455EE0@<eax>(int@<esi>, HWND hWnd, WPARAM wParam, int);
// void __userpurge sub_456060(int@<esi>, WPARAM wParam, int);
// int __userpurge sub_456230@<eax>(_DWORD *@<ebx>, HWND@<edi>, WPARAM@<esi>, LPARAM);
// int __userpurge sub_456290@<eax>(int@<eax>, _DWORD *);
// int __userpurge sub_456330@<eax>(int@<eax>, _DWORD *);
int **__thiscall sub_4563D0(int **this, char ***);
// int __userpurge sub_4564B0@<eax>(WPARAM@<ebx>, int@<esi>, HWND hWnd, int, int);
// int __userpurge sub_4565D0@<eax>(WPARAM@<ebx>, _DWORD *@<esi>, HWND hWnd, LPARAM, int);
// int __userpurge sub_456700@<eax>(int@<edi>, HWND hWnd, WPARAM wParam, int);
// int __userpurge sub_456840@<eax>(int@<ecx>, WPARAM@<ebx>, int@<esi>, HWND hWnd, int);
// int __userpurge sub_456970@<eax>(WPARAM@<edi>, _DWORD *@<esi>, LPARAM);
// int __userpurge sub_456A10@<eax>(WPARAM@<ebx>, _DWORD *@<esi>, LPARAM);
// int __userpurge sub_456A90@<eax>(WPARAM@<ebx>, int@<esi>, HWND hWnd, int, int);
// LRESULT __userpurge sub_456C60@<eax>(int@<esi>, WPARAM wParam, int);
int ***__thiscall sub_456D80(void *this, int ***);
// void __userpurge sub_456E00(int@<esi>, WPARAM wParam, int, int);
// int __userpurge sub_457050@<eax>(HWND hWnd@<ecx>, _DWORD *@<ebx>, WPARAM wParam, int);
// int __userpurge sub_457210@<eax>(WPARAM@<ebx>, HWND@<edi>, _DWORD *@<esi>, LPARAM);
int __thiscall sub_4572C0(_DWORD *this);
void __stdcall sub_4574E0(ULONG_PTR Parameter); // idb
int __thiscall sub_4574F0(void *this, int, WPARAM wParam, int);
// void __userpurge sub_4582C0(LPARAM@<ecx>, int@<eax>, int@<edx>, WPARAM wParam);
int __stdcall sub_458930(int);
void __stdcall sub_458A80(ULONG_PTR Parameter); // idb
int __thiscall sub_458AA0(_DWORD *this);
// void __userpurge sub_458AB0(int@<esi>, LPCWSTR lpString1);
int __thiscall sub_458C00(_DWORD *this);
BOOL __thiscall sub_458C10(_DWORD *this);
int __thiscall sub_458C30(_DWORD *this, int);
int __thiscall sub_458C40(_DWORD *this);
int __thiscall sub_458C50(_DWORD *this);
int __thiscall sub_458C60(_DWORD *this);
int __thiscall sub_458C70(_DWORD *this);
int __thiscall sub_458C80(_DWORD *this, int);
BOOL __thiscall sub_458C90(_DWORD *this);
int __thiscall sub_458CB0(_DWORD *this);
int __thiscall sub_458CC0(_DWORD *this, int);
int __thiscall sub_458CD0(_DWORD *this);
_DWORD *__thiscall sub_458CE0(_DWORD *this, _DWORD *);
int __thiscall sub_458D10(_DWORD *this);
int __thiscall sub_458D20(_DWORD *this);
int __thiscall sub_458D30(_DWORD *this);
int __thiscall sub_458D40(_DWORD *this);
int __thiscall sub_458E00(_DWORD *this, WPARAM wParam);
int __thiscall sub_458E90(_DWORD *this, WPARAM wParam);
int __thiscall sub_458F10(_DWORD *this, LPARAM);
int __thiscall sub_458F70(_DWORD *this);
int __thiscall sub_459000(_DWORD *this);
int __thiscall sub_459010(_DWORD *this);
int __thiscall sub_459020(_DWORD *this, int);
int __thiscall sub_459030(_DWORD *this, int);
BOOL __thiscall sub_459040(int this, LPARAM);
int __thiscall sub_4590F0(_DWORD *this);
LPITEMIDLIST __thiscall sub_459100(_DWORD *this, LPARAM);
int __thiscall sub_459190(_DWORD *this, LPARAM);
int __thiscall sub_4591E0(_DWORD *this, LPARAM);
// int __userpurge sub_459230@<eax>(_DWORD *@<esi>, LPCWSTR lpString2);
LRESULT __thiscall sub_4592D0(_DWORD *this, LPCWSTR lpString2);
int __thiscall sub_459320(_DWORD *this);
int __stdcall sub_459330(int, int, int);
int __thiscall sub_459340(_DWORD **this);
int __thiscall sub_459350(_DWORD **this);
int __thiscall sub_459360(_DWORD **this);
int __thiscall sub_459370(_DWORD **this);
BOOL __thiscall sub_459380(_DWORD **this);
BOOL __thiscall sub_4593A0(_DWORD **this);
int __thiscall sub_4593C0(_DWORD **this, int, _DWORD *, int, int);
LPITEMIDLIST __thiscall sub_459410(LPCITEMIDLIST *this);
BOOL __thiscall sub_459420(int this, int, int);
int __thiscall sub_4594B0(_DWORD *this, int);
int __thiscall sub_4594D0(_DWORD *this, PCWSTR psz1, int);
int __thiscall sub_459530(_DWORD *this, LPARAM);
LPITEMIDLIST __thiscall sub_459590(int this, LPCITEMIDLIST pidl);
int __thiscall sub_459720(_DWORD *this);
BOOL __fastcall sub_459790(int csidl, int);
int __thiscall sub_4597E0(const ITEMIDLIST **this);
_DWORD *__thiscall sub_459850(_DWORD *this);
int __thiscall sub_4598B0(HWND *this, int);
BOOL __thiscall sub_459940(_DWORD *this);
int __thiscall sub_4599D0(int this, LPARAM, WCHAR *);
char **__thiscall sub_459A90(_DWORD **this, int);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
// unsigned int __usercall sub_459B20@<eax>(int@<ebx>);
int __thiscall sub_459C90(void *this, _WORD *, unsigned int);
// int __usercall sub_459CC0@<eax>(int@<edi>);
// char **__userpurge sub_459D50@<eax>(WPARAM@<ebx>, int@<esi>, int);
void __thiscall sub_459E10(int this);
// int __usercall sub_45A280@<eax>(void *@<eax>, _DWORD *@<ecx>);
void __stdcall sub_45A340(int);
WPARAM __thiscall sub_45A3C0(HWND *this, WPARAM wParam, int a3);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD, _DWORD); weak
int __thiscall sub_45A4E0(const WCHAR *this, int, _WORD *);
_WORD *__thiscall sub_45A520(_DWORD *this, LPARAM, _WORD *);
int __thiscall sub_45A5C0(_DWORD *this, int, int, LPCWSTR lpString);
int __thiscall sub_45A630(_DWORD *this, LPARAM, _WORD *, unsigned int);
void __thiscall sub_45A6C0(_DWORD *this);
// int __usercall sub_45A700@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>);
// LPARAM __userpurge sub_45A9B0@<eax>(int@<edi>, int);
void __stdcall sub_45AAD0(ULONG_PTR Parameter); // idb
// void __usercall sub_45AC70(int@<eax>, ULONG_PTR@<edi>);
// void __usercall sub_45AD50(const WCHAR *@<ecx>, int@<esi>);
void __fastcall sub_45AFD0(int);
// void __noreturn std::vector<void *>::_Xlen(void); weak
int **__thiscall sub_45B0F0(int this, int *);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
// LRESULT __usercall sub_45B1C0@<eax>(LRESULT result@<eax>);
// int __usercall sub_45B280@<eax>(int@<ecx>, int@<ebx>);
int __thiscall sub_45B340(_DWORD *this, LPARAM);
// _DWORD *__usercall sub_45B3C0@<eax>(int@<esi>);
void __thiscall sub_45B5C0(HWND *this, _DWORD *);
_DWORD *__thiscall sub_45B650(void *this, _DWORD **);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
void __thiscall sub_45B7E0(int this, int **, int);
// LRESULT __usercall sub_45B9E0@<eax>(ULONG_PTR@<eax>);
// LRESULT __usercall sub_45BAD0@<eax>(ULONG_PTR@<esi>);
LRESULT __thiscall sub_45BB40(_DWORD *this, int);
_WORD *__thiscall sub_45BB60(_DWORD *this, int);
void __thiscall sub_45BBC0(const WCHAR *this, int, int);
// BOOL __usercall sub_45BD00@<eax>(HDC@<ebx>, void *@<edi>);
// int __usercall sub_45BD90@<eax>(_DWORD *@<eax>);
// BOOL __userpurge sub_45BE20@<eax>(HDC@<ebx>, int@<esi>, int);
int __thiscall sub_45BEE0(HWND *this, int, int, void *);
void __stdcall sub_45C020(ULONG_PTR Parameter); // idb
// void __usercall sub_45C240(char *@<eax>, ULONG_PTR@<edi>);
// int __usercall sub_45C300@<eax>(int@<edi>);
// LRESULT __usercall sub_45C3C0@<eax>(int@<esi>);
int __thiscall sub_45C4C0(_DWORD *this);
int __thiscall sub_45C4D0(_DWORD *this);
LPITEMIDLIST __thiscall sub_45C4E0(_DWORD *this, int);
LPITEMIDLIST __thiscall sub_45C510(_DWORD *this, int);
// int __usercall sub_45C540@<eax>(int result@<eax>, int@<edx>);
int __thiscall sub_45C570(int this, LPCITEMIDLIST pidl);
int __stdcall sub_45C5C0(int);
BOOL __thiscall sub_45C630(_DWORD *this, HWND, int *, int);
int __stdcall sub_45C780(void *); // idb
int __stdcall sub_45C7B0(int, _DWORD *, _DWORD *);
char **__thiscall sub_45C7F0(_DWORD *this, int);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
char **__thiscall sub_45C880(_DWORD *this, int);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
LPITEMIDLIST __thiscall sub_45C920(_DWORD *this, int);
// LRESULT __usercall sub_45C9E0@<eax>(int@<esi>);
int __thiscall sub_45CAA0(_DWORD *this, int);
int __thiscall sub_45CAB0(_DWORD *this, int);
int __thiscall sub_45CAC0(_DWORD *this);
int __thiscall sub_45CAD0(_DWORD *this, int);
int __thiscall sub_45CAE0(_DWORD *this);
int __thiscall sub_45CAF0(_DWORD *this, int);
int __thiscall sub_45CB00(_DWORD *this, int);
int __thiscall sub_45CB10(_DWORD *this);
int __thiscall sub_45CB20(_DWORD *this, int);
int __thiscall sub_45CB30(_DWORD *this);
int __thiscall sub_45CB40(_DWORD *this, int);
int __thiscall sub_45CB50(_DWORD *this);
int __thiscall sub_45CB60(_DWORD *this, int);
int __thiscall sub_45CB70(_DWORD *this);
int __thiscall sub_45CB80(_DWORD *this, int);
int __thiscall sub_45CB90(_DWORD *this);
int __thiscall sub_45CBB0(_DWORD *this, int);
int __thiscall sub_45CBC0(_DWORD *this);
int __thiscall sub_45CC00(_DWORD *this, int);
int __thiscall sub_45CC10(_DWORD *this);
int __thiscall sub_45CC20(_DWORD *this, _DWORD *);
int *__thiscall sub_45CC50(_DWORD *this);
int __thiscall sub_45CD40(_DWORD *this);
int __thiscall sub_45CD50(_DWORD *this, int);
int __thiscall sub_45CD70(_DWORD *this, _DWORD *);
int __thiscall sub_45CD90(_DWORD *this, _DWORD *);
BOOL __thiscall sub_45CDC0(_DWORD *this);
int __stdcall sub_45CDD0(int);
LRESULT __thiscall sub_45CDF0(_DWORD *this);
int __stdcall sub_45CE50(int, _DWORD *, _DWORD *);
void __stdcall sub_45CEF0(int);
int __stdcall sub_45D510(void *); // idb
// int ***__userpurge sub_45D540@<eax>(int@<ebx>, int ***);
LRESULT __thiscall sub_45D5E0(_DWORD *this, int);
// int __userpurge sub_45D780@<eax>(int@<esi>, int, int, int, int, int);
// int __usercall sub_45DFE0@<eax>(int *@<edi>, int, int, int, int, int);
// LRESULT __userpurge sub_45E060@<eax>(int@<eax>, int);
// LRESULT __userpurge sub_45E220@<eax>(WPARAM@<edi>, _DWORD *@<esi>, int);
// LRESULT __usercall sub_45E360@<eax>(int@<esi>);
int __thiscall sub_45E4F0(ULONG_PTR dwData, int); // idb
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
int __stdcall sub_45E5D0(int, int);
int __stdcall sub_45E5E0(int);
int __stdcall sub_45E600(int, int);
LONG __stdcall sub_45E620(int);
int __stdcall sub_45E640(_DWORD *, int, _DWORD *, _DWORD *);
int __stdcall sub_45E700(int, _DWORD *, _DWORD *);
// void __usercall sub_45E760(int@<esi>);
LONG __stdcall sub_45E7A0(void *);
int __stdcall sub_45E7D0(int, void *, int, int); // idb
int __cdecl sub_45E980(void *, int, int, int); // idb
void __stdcall sub_45EA30(ULONG_PTR Parameter); // idb
void __stdcall sub_45EA50(ULONG_PTR Parameter); // idb
void __stdcall __noreturn sub_45EAE0(ULONG_PTR Parameter);
void __stdcall __noreturn sub_45EB00(LPVOID lpThreadParameter);
int __stdcall sub_45EB20(int);
int __thiscall sub_45EB70(int this, int);
// void __usercall sub_45EBF0(int@<eax>);
void __stdcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped); // idb
// void __usercall sub_45ED90(int@<esi>);
// int __usercall sub_45EE40@<eax>(int@<esi>);
// int __usercall sub_45EEF0@<eax>(int *@<edi>);
int __thiscall sub_45EF60(int this, int, int, int, int, int, int);
int __thiscall sub_45F0C0(int this, int, int, int, int, void *);
int __stdcall sub_45F250(void *); // idb
int __stdcall sub_45F280(int, _DWORD *, _DWORD *);
// BOOL __userpurge sub_45F380@<eax>(int@<edi>, UINT iFile);
LRESULT __stdcall sub_45F470(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData); // idb
// int __usercall sub_45F4E0@<eax>(int@<edi>, int@<esi>);
HRESULT __stdcall sub_45F570(LPSTGMEDIUM a1);
// int __userpurge sub_45F620@<eax>(_WORD *a1@<ecx>, const WCHAR *a2@<esi>, const WCHAR *a3);
// void __usercall sub_45F7F0(_DWORD *@<esi>);
// int __usercall sub_45F8F0@<eax>(int@<edi>);
void __thiscall sub_45FA40(void *Src, int);
int __thiscall sub_45FC80(int this);
DWORD __stdcall sub_460100(LPVOID lpThreadParameter); // idb
// int __userpurge sub_4601D0@<eax>(int@<edi>, int, int, int);
void __thiscall sub_4603C0(_DWORD *this, HDROP *, int, char);
int __thiscall sub_460890(char **this, DWORD, int);
int __thiscall sub_460BF0(void *this, int, int);
int __fastcall sub_460DA0(int, int, int);
// int __userpurge sub_460EF0@<eax>(int *@<ebx>, int, int);
// int __userpurge sub_461720@<eax>(int@<eax>, _DWORD *, int, char);
void __thiscall sub_461780(int *this, DWORD, int *);
// void __userpurge sub_461A40(int@<eax>, int@<edx>, int *@<ecx>, _DWORD *, _DWORD *, int, int, int, int, int);
int __stdcall sub_461AB0(int, int);
int __stdcall sub_461AD0(int, int);
int __stdcall sub_461AF0(int, _DWORD *);
int __stdcall sub_461B10(int, _DWORD *);
int __stdcall sub_461B30(int, int, int, int);
int __stdcall sub_461B50(int, int);
int __stdcall sub_461B60(int, int);
int __stdcall sub_461B70(int, int, int, int, int);
int __stdcall sub_461B80(int, int, int);
int __stdcall sub_461BB0(int, int, int);
// HANDLE __usercall sub_461BC0@<eax>(int@<eax>, int@<ebx>, _DWORD *@<edi>);
LONG __stdcall sub_461CB0(int);
int __stdcall sub_461CD0(int, __int16 *);
int __stdcall sub_461D50(_DWORD *, __int16 *, _DWORD *);
int __stdcall sub_461E10(int, _DWORD *, _DWORD *);
void __stdcall sub_461EA0(_DWORD *);
int __stdcall sub_461F40(int, int *, int *, int);
LONG __stdcall sub_462000(void *);
_DWORD *__stdcall sub_462030(_DWORD *, int *, int *);
// int __usercall sub_462160@<eax>(_DWORD *@<esi>, int *, int *);
int __stdcall sub_4621E0(int, int, int);
// void __usercall sub_462390(int@<eax>);
// int __userpurge sub_4623B0@<eax>(int@<esi>, int);
// void __usercall sub_462410(int@<esi>);
// void __usercall sub_4624E0(int@<esi>);
// _DWORD *__userpurge sub_462710@<eax>(int@<eax>, unsigned int@<ecx>, int);
int __fastcall sub_462790(int, unsigned int, int);
int __stdcall sub_462810(int, int, HMENU hMenu, HMENU, int); // idb
void __stdcall sub_462A10(HMENU hMenu);
// void __userpurge sub_462B50(HMENU@<esi>, int);
void __stdcall sub_462C80(void **);
int **__stdcall sub_462DB0(int **, const ITEMIDLIST *, int, int);
LRESULT __stdcall sub_463030(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData); // idb
// char __userpurge sub_463280@<al>(HMENU hMenu@<ecx>, int@<eax>, HWND@<ebx>, _DWORD *@<edi>, int);
// int __usercall sub_463340@<eax>(int@<edi>, UINT *@<esi>);
// int __usercall sub_463500@<eax>(int@<edi>);
void __stdcall sub_463980(int *);
int __thiscall sub_463A50(char ***this, int);
void __thiscall sub_463D00(int ***this, int);
// void __usercall sub_463F50(int *@<edi>);
// int __userpurge sub_463FD0@<eax>(HWND@<ecx>, int **@<edi>, int, void *);
LSTATUS __cdecl sub_464130(HKEY, _DWORD **);
// LSTATUS __usercall sub_464270@<eax>(int@<ecx>, int@<edi>, HKEY);
// LSTATUS __usercall sub_464420@<eax>(_DWORD *@<edi>, HKEY hKey, LPCWSTR lpValueName, int, int, int, int, int);
// BOOL __usercall sub_464560@<eax>(const WCHAR *@<eax>);
// int __usercall sub_4645D0@<eax>(int@<eax>, int@<esi>, int);
// int __usercall sub_464660@<eax>(int@<eax>, int, OLECHAR *psz, OLECHAR *, OLECHAR *);
LPVOID sub_4647D0();
// int __usercall sub_464840@<eax>(int@<eax>);
// int __usercall sub_464940@<eax>(int@<eax>, int, int, OLECHAR *psz, OLECHAR *);
// HRESULT __usercall sub_464A60@<eax>(int@<eax>, int@<edi>, OLECHAR *psz, OLECHAR *);
HFONT __cdecl sub_464B40(int);
// unsigned int *__usercall sub_464D20@<eax>(int@<eax>, unsigned int *@<ebx>);
// void __usercall sub_464E30(int@<edx>, int@<ecx>, int, _DWORD **);
// void __userpurge sub_464FA0(int@<ebx>, int@<edi>, int);
// LSTATUS __usercall sub_4650C0@<eax>(HKEY@<edx>, int@<esi>);
// void __userpurge sub_465170(int@<esi>, HKEY hKey);
// int __userpurge sub_465280@<eax>(int result@<eax>, int@<ebx>, int);
// int __usercall sub_4653E0@<eax>(int result@<eax>, int@<edx>);
HWND __cdecl sub_4654C0(HWND hWndParent);
HWND __cdecl sub_465600(HWND hWndParent);
// HANDLE __usercall sub_4656B0@<eax>(HWND@<edi>, WCHAR *@<esi>);
void __stdcall sub_465880(void *Block);
int __fastcall sub_465940(int, int, int);
// int __usercall sub_465C50@<eax>(_DWORD *@<ebx>, int@<edi>);
// _WORD *__usercall sub_465D30@<eax>(int@<ebx>, _DWORD *@<edi>);
// _WORD *__usercall sub_465E20@<eax>(char *@<ebx>, _DWORD *@<edi>);
int __thiscall sub_465F90(_DWORD *this, _DWORD *);
// int __usercall sub_466000@<eax>(int@<ebx>, _DWORD *@<edi>);
// _DWORD *__usercall sub_4660A0@<eax>(_DWORD *result@<eax>);
// int __usercall sub_4660F0@<eax>(char *@<ebx>, int@<esi>);
// int __usercall sub_466190@<eax>(const ITEMIDLIST *@<edi>, const ITEMIDLIST *@<esi>);
// int __usercall sub_466220@<eax>(char@<al>, char, int);
BOOL __cdecl sub_466280(LPCWSTR lpSrc, LPWSTR lpDest);
// int __usercall sub_4663F0@<eax>(const ITEMIDLIST *@<edi>);
// int __usercall sub_466430@<eax>(ITEMIDLIST *@<eax>, LPITEMIDLIST *@<ebx>);
HRESULT __cdecl sub_4664A0(int csidl, LPWSTR pszBuf);
// BOOL __usercall sub_466570@<eax>(const WCHAR *@<eax>, HWND@<edx>, void *@<ecx>, const WCHAR *, const WCHAR *);
// HRESULT __usercall sub_4665C0@<eax>(const ITEMIDLIST *a1@<eax>, int a2@<edi>);
// HRESULT __usercall sub_466630@<eax>(const ITEMIDLIST *a1@<edi>, WCHAR *pszBuf, int a3);
// HRESULT __usercall sub_4666D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<edi>, const WCHAR *a5, int a6);
// HRESULT __usercall sub_466830@<eax>(const ITEMIDLIST *a1@<eax>, IShellFolder **a2@<esi>);
// int __usercall sub_466900@<eax>(const WCHAR *@<esi>, WCHAR *);
// int __usercall sub_466EA0@<eax>(const OLECHAR *@<edi>, HMODULE *);
int __cdecl sub_467080(int);
int __cdecl sub_4672A0(int, void *);
// int __usercall sub_467360@<eax>(LPCWSTR lpSrc@<ecx>, int@<ebx>, WCHAR *@<edi>);
// int __usercall sub_467490@<eax>(int@<eax>, int, LPCITEMIDLIST pidl, void *, int);
// BOOL __usercall sub_467670@<eax>(_DWORD *@<eax>);
// HRESULT __usercall sub_4676F0@<eax>(const ITEMIDLIST *a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4, int a5, _WORD *a6);
// HRESULT __usercall sub_467810@<eax>(LPITEMIDLIST *a1@<ebx>, int a2@<edi>);
HRESULT __cdecl sub_4678E0(void *, int);
int __thiscall sub_467A90(const ITEMIDLIST *this);
// HRESULT __usercall sub_467B20@<eax>(int a1@<eax>, int a2@<esi>);
// HRESULT __usercall sub_467B70@<eax>(int a1@<eax>, WCHAR *a2@<esi>, int a3);
int __cdecl sub_467BD0(int, void *, int); // idb
// int __userpurge sub_467DC0@<eax>(int@<eax>, int@<edx>, _WORD *@<ecx>, int);
int __fastcall sub_467E40(_BYTE *, int);
// HWND __usercall sub_467F60@<eax>(HWND a1@<ebx>, HWND hWnd);
// LRESULT __usercall sub_468000@<eax>(HWND@<edi>, int, LPARAM lParam);
int __cdecl sub_468090(int, int, _DWORD *);
int __cdecl sub_4681A0(LPCWSTR lptstrFilename, int, int); // idb
// __int16 __usercall sub_468240@<ax>(const WCHAR *@<ebx>);
int __cdecl sub_4682E0(int);
// LONG __usercall sub_468320@<eax>(int@<eax>, HWND@<edi>, int);
// int __usercall sub_468480@<eax>(const WCHAR *@<eax>);
// wchar_t *__usercall sub_4684D0@<eax>(int@<eax>);
// BOOL __usercall sub_468540@<eax>(LPCWSTR lpSrcStr@<ecx>, const WCHAR *@<eax>, int);
// LRESULT __usercall sub_4686B0@<eax>(HWND@<esi>, WPARAM wParam, WPARAM);
// LRESULT __usercall sub_468800@<eax>(HWND@<edi>, int wParam, int);
// LRESULT __usercall sub_468B50@<eax>(HWND@<edi>, int wParam, int);
// BOOL __usercall sub_468F10@<eax>(HWND@<eax>, const WCHAR *@<edx>, WCHAR *@<ecx>);
DWORD __cdecl sub_468F80(LPCWSTR lpFileName);
// HANDLE __usercall sub_4691C0@<eax>(int@<ecx>, const WCHAR *@<ebx>, DWORD dwProcessId);
// HINSTANCE __usercall sub_469350@<eax>(const WCHAR *@<esi>);
// LRESULT __usercall sub_4693F0@<eax>(HWND@<edi>, LPARAM *@<esi>);
// int __usercall sub_469690@<eax>(HWND@<edi>);
// int __usercall sub_469710@<eax>(HWND@<esi>);
// int __usercall sub_469760@<eax>(HWND@<esi>);
// BOOL __usercall sub_4697F0@<eax>(HWND@<edi>, HWND@<esi>);
int __cdecl sub_4698A0(_BYTE *);
// HRESULT __usercall sub_469970@<eax>(const ITEMIDLIST *@<edx>, int@<esi>, _WORD *);
// HRESULT __usercall sub_469A10@<eax>(int a1@<edi>, int a2@<esi>, _WORD *a3);
BOOL __cdecl sub_469A50(LPCWSTR lpString, int, int);
// int __usercall sub_469B90@<eax>(int@<ecx>, HWND@<edi>);
int __cdecl sub_469C60(int, int);
DWORD __cdecl sub_469F20(int, int);
// int __usercall sub_46A1B0@<eax>(const WCHAR *@<edx>, _WORD *@<ecx>, int);
int __thiscall sub_46A360(wchar_t *this);
int __cdecl sub_46A4F0(int);
// int __usercall sub_46A6F0@<eax>(__int16@<dx>, _WORD *@<ecx>, unsigned int);
// DWORD __usercall sub_46A7C0@<eax>(_WORD *@<edi>, LPCWSTR lpFileName);
wchar_t *__cdecl sub_46A840(unsigned int a1, int a2);
int __thiscall sub_46A930(LPCWSTR lpFileName); // idb
// int __usercall sub_46AA40@<eax>(char *@<ecx>, LARGE_INTEGER *@<ebx>);
// int __usercall sub_46AB90@<eax>(_WORD *@<ecx>, int@<edi>, FILETIME *lpFileTime, int);
// int __usercall sub_46AE30@<eax>(int@<ecx>, const WCHAR *@<ebx>, _WORD *);
// void __usercall sub_46AFA0(HWND@<ebx>, _DWORD *);
DWORD __cdecl sub_46B010(int);
void __cdecl sub_46B2E0(unsigned int, int, int, unsigned __int64);
int sub_46B8C0();
int sub_46B8D0();
int sub_46B8E0();
int __stdcall sub_46B8F0(int, int, int);
int __stdcall sub_46B900(int);
int __stdcall sub_46B910(int);
int __stdcall sub_46B920(int, int);
int __stdcall sub_46B930(int, int);
int __stdcall sub_46B940(int);
int sub_46B950();
int __fastcall sub_46B9C0(unsigned int, int, int, HWND hWnd, int);
INT_PTR __stdcall DialogFunc(HWND, UINT, WPARAM, LPARAM); // idb
// HWND __userpurge sub_46C0D0@<eax>(LPARAM@<esi>, int);
// INT_PTR __usercall sub_46C110@<eax>(LPARAM@<eax>);
BOOL sub_46C150();
int __cdecl sub_46C3F0(_DWORD *);
// int __usercall sub_46C800@<eax>(int@<edi>);
// int __usercall sub_46C930@<eax>(int@<edi>);
// HRESULT __usercall sub_46CAE0@<eax>(int@<esi>);
int __stdcall sub_46CC10(int);
int __stdcall sub_46CC30(int, int, _DWORD *);
// int __userpurge sub_46CCF0@<eax>(int result@<eax>, int@<edi>, int);
// int __usercall sub_46CED0@<eax>(int@<ecx>, int@<edi>);
int __stdcall sub_46CEE0(_DWORD *);
void __fastcall sub_46CF00(int, int, int);
// int __userpurge sub_46D110@<eax>(int@<ebx>, int@<edi>, int);
// int __usercall sub_46D1C0@<eax>(int@<edx>, int@<ecx>, int@<ebx>);
// int __userpurge sub_46D3D0@<eax>(int@<eax>, int@<edi>, int);
int __thiscall sub_46D480(int *this);
// _DWORD *__userpurge sub_46D4A0@<eax>(const WCHAR *@<eax>, const WCHAR *@<edi>, _DWORD *, _DWORD *);
int __fastcall sub_46D6E0(int, int, int);
int __thiscall sub_46EC80(int *this);
unsigned int __fastcall sub_46EC90(int, const WCHAR *, const WCHAR *, const WCHAR *lpWideCharStr);
// void __userpurge sub_46FDB0(int@<ecx>, int@<esi>, int);
void __thiscall sub_470000(void *this, int, int, OLECHAR *);
// void __userpurge sub_4701C0(int@<edi>, OLECHAR **, int);
int __thiscall sub_470280(void *this, int);
// void __userpurge sub_4704F0(int@<esi>, void *);
void __fastcall sub_470550(_DWORD **, OLECHAR *, int *, int, int);
// void __usercall sub_470790(_DWORD **@<ebx>, int *@<edi>, int@<esi>);
// int __userpurge sub_470830@<eax>(int *@<eax>, _DWORD **, int);
void __thiscall sub_4708E0(void *this, int, int, OLECHAR *);
void __fastcall sub_470E30(int, int, void *);
// int __userpurge sub_470F90@<eax>(int@<ebx>, int, int);
int __fastcall sub_471330(int, int);
// void __usercall sub_4713E0(int@<edx>, int@<ecx>, int *@<ebx>);
// int __userpurge sub_471B40@<eax>(int *@<eax>, int@<edi>, int);
// int __usercall sub_471BF0@<eax>(int result@<eax>, int@<ebx>);
void __thiscall sub_471CF0(int this);
int __thiscall sub_471D10(int this);
int __thiscall sub_471D30(int this);
void __thiscall sub_471D50(int this);
void __thiscall sub_471D60(int this);
int __thiscall sub_471D70(int *this);
int __thiscall sub_471D80(int *this);
int __fastcall sub_471D90(int, _DWORD *);
int __thiscall sub_472020(void *this, int);
int __thiscall sub_472230(int this);
// void __usercall sub_472240(int@<edx>, int@<ecx>, int@<ebx>);
void __thiscall sub_472460(int *this);
void __thiscall sub_472480(_DWORD *this, int);
// int __usercall sub_472860@<eax>(int result@<eax>, _DWORD *@<esi>);
int __thiscall sub_472900(int this);
// int __userpurge sub_472910@<eax>(int@<edi>, int);
// int __usercall sub_472D80@<eax>(int result@<eax>, int@<edi>);
int __thiscall sub_473030(int *this);
// int __usercall sub_473040@<eax>(int@<ecx>, int@<edi>);
int __thiscall sub_473050(void *this, int);
int __thiscall sub_473F10(int this);
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
int __thiscall sub_474110(unsigned __int16 *this);
// __int16 __usercall sub_4746F0@<ax>(HINSTANCE@<esi>);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
// LRESULT __usercall sub_474E70@<eax>(int@<esi>);
// BOOL __userpurge sub_474F60@<eax>(int@<ebx>, HWND);
// LRESULT __usercall sub_475080@<eax>(int@<esi>);
// LRESULT __usercall sub_475130@<eax>(int@<esi>);
int __fastcall sub_4751D0(int, int);
HRESULT __thiscall sub_4752B0(_DWORD **this);
// int __usercall sub_475620@<eax>(int@<ecx>, int@<esi>);
// void __usercall sub_4758B0(int@<esi>);
// void __usercall sub_4759F0(int@<eax>);
// LRESULT __usercall sub_475AF0@<eax>(int@<eax>);
// int __userpurge sub_475B30@<eax>(int@<edx>, WPARAM@<ebx>, int@<edi>, int, DWORD dwErrCode);
int __stdcall sub_475BA0(int, int, WPARAM, DWORD, int, int);
HWND __thiscall sub_475BD0(HWND hWndParent, int, int);
// HRESULT __usercall sub_475D00@<eax>(DWORD@<edi>);
// HRESULT __usercall sub_475E30@<eax>(DWORD@<esi>);
// LRESULT __usercall sub_475ED0@<eax>(int@<esi>);
// void __usercall sub_476010(DWORD@<esi>);
int __fastcall sub_4760B0(WPARAM, int, int, int, LPARAM lParam);
int __stdcall sub_476380(int, int, int, LPARAM lParam, int, int); // idb
LRESULT __thiscall sub_4763A0(DWORD dwErrCode);
// HWND __usercall sub_476620@<eax>(DWORD@<edi>);
int __thiscall sub_476770(HICON *this);
int __thiscall sub_476780(HWND *this);
int __thiscall sub_4767A0(int this);
// LRESULT __userpurge sub_476840@<eax>(int@<edi>, const WCHAR *);
char **__stdcall sub_476910(_DWORD *, char **);
int *sub_476A70();
int *sub_476B60();
int __fastcall sub_476BD0(int, int, int, int);
HRESULT __thiscall sub_476C70(int this, int, int);
LSTATUS __thiscall sub_476CB0(const WCHAR *this, HKEY hKey);
int __thiscall sub_476D00(int this);
void __thiscall sub_476E80(_DWORD *this, LPCWSTR lpString1, void *Src);
int __thiscall sub_476FD0(BYTE *this, HKEY hKey);
BOOL __thiscall sub_477060(int this);
int __thiscall sub_4771E0(HWND *this, __int16, int);
// int __usercall sub_477230@<eax>(int@<eax>, int@<ecx>);
// UINT_PTR __usercall sub_4772A0@<eax>(UINT_PTR result@<eax>, int@<edx>);
// LRESULT __usercall sub_477310@<eax>(int@<esi>);
// void __usercall sub_477350(int@<esi>);
// void __userpurge sub_4773D0(int@<esi>, int);
void __thiscall sub_477490(_DWORD *this);
// int __userpurge sub_477690@<eax>(DWORD@<ebx>, _DWORD *@<edi>, int, unsigned int, int);
int __stdcall sub_4777C0(int, unsigned int, int, DWORD, int, _DWORD *);
LRESULT __thiscall sub_4777F0(int this);
int __thiscall sub_477950(int this, int);
void __thiscall sub_477BF0(_DWORD *this, int);
void __thiscall sub_477EB0(int this);
void __thiscall sub_478000(int this);
void __stdcall sub_478110(int, LPARAM lParam, int);
// BOOL __usercall sub_478440@<eax>(int@<eax>, _DWORD *@<ecx>);
// BOOL __usercall sub_478570@<eax>(int@<ebx>);
// int __usercall sub_478630@<eax>(int@<ebx>, int@<edi>);
// int __usercall sub_478750@<eax>(UINT_PTR@<ecx>, _DWORD *@<eax>);
int __stdcall sub_478900(int, int, int, DWORD dwErrCode, int, int); // idb
int __thiscall sub_478970(_DWORD *this);
// LRESULT __usercall sub_478980@<eax>(int@<esi>);
// WPARAM __usercall sub_4789F0@<eax>(unsigned int@<ecx>, int@<edi>);
// HWND __usercall sub_478AE0@<eax>(int@<esi>);
// HWND __userpurge sub_478B00@<eax>(int@<esi>, unsigned int);
// BOOL __usercall sub_478B80@<eax>(int@<eax>, HMENU@<esi>);
LRESULT __stdcall sub_478C40(int);
// int __userpurge sub_478CB0@<eax>(int@<edi>, int@<esi>, int, int);
// _DWORD *__userpurge sub_478D80@<eax>(int@<eax>, int@<ecx>, HICON hIcon);
// int __userpurge sub_478DD0@<eax>(int@<ecx>, int *@<ebx>, int);
HGDIOBJ __thiscall sub_478F50(HWND *this, int);
void __thiscall sub_4791F0(_DWORD *this, WPARAM wParam, void *, int, int, int, int, int, int, int);
// void __userpurge sub_479330(int@<esi>, int);
// void __usercall sub_4793C0(WPARAM wParam@<ecx>, int@<eax>);
// int __userpurge sub_479400@<eax>(LPARAM@<eax>, int@<edx>, WPARAM@<ecx>, int);
// void __userpurge sub_479660(int@<eax>, WPARAM wParam);
// void __userpurge sub_479710(int@<eax>, int@<edi>, WPARAM wParam);
// void __usercall sub_479780(int@<ebx>, WPARAM@<esi>);
int __fastcall sub_4797C0(int, const ITEMIDLIST *, WPARAM wParam, int);
int __stdcall sub_479920(int);
int __thiscall sub_4799A0(_DWORD *this, int, WPARAM wParam);
// HWND __userpurge sub_479A30@<eax>(int@<eax>, int);
// HWND __usercall sub_479BD0@<eax>(int@<esi>);
void __thiscall sub_479C00(_DWORD **this, int);
// int __userpurge sub_479C50@<eax>(int@<ebx>, WPARAM wParam);
// HWND __userpurge sub_479F80@<eax>(LRESULT@<edi>, int@<esi>, int);
// HWND __usercall sub_479FD0@<eax>(LRESULT@<edi>, int@<esi>);
// HWND __userpurge sub_47A020@<eax>(int@<esi>, int);
LRESULT __thiscall sub_47A090(int this, int);
LRESULT __stdcall sub_47A3E0(int, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM, int);
LRESULT __stdcall sub_47A800(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
__int16 __stdcall sub_47A860(DWORD);
void __fastcall sub_47A8C0(int, void *, unsigned int);
// void __userpurge sub_47AC20(int@<esi>, unsigned int);
int __fastcall sub_47ACC0(int, HWND, unsigned int, HMENU wParam, unsigned int lParam);
int __stdcall sub_47AFE0(HWND, unsigned int, HMENU, unsigned int, int, int);
HMODULE __thiscall sub_47B000(_DWORD *this, char *, int);
int __fastcall sub_47B180(int *, int, const ITEMIDLIST *, int *, const void *, int);
int __fastcall sub_47B6C0(int, const WCHAR *, int *, const void *);
// HWND __usercall sub_47B7B0@<eax>(DWORD@<esi>);
int __stdcall sub_47B8F0(int);
void __stdcall TimerFunc(HWND, UINT, UINT_PTR, DWORD); // idb
// void __userpurge sub_47B980(int@<eax>, int);
int __stdcall sub_47BA20(int, int, char, LONG, LONG, _DWORD *);
int __stdcall sub_47BD80(int, int *, int, LONG, LONG, _DWORD *);
int __stdcall sub_47BEC0(int, char, LONG, LONG, int *);
// BOOL __usercall sub_47C090@<eax>(int@<esi>);
LRESULT __thiscall sub_47C1A0(int this, int, LPARAM lParam, int);
int __thiscall sub_47C2E0(HGDIOBJ *this);
int __thiscall sub_47C2F0(HWND *this);
HGDIOBJ __thiscall sub_47C300(HWND *this, int, HDC hdc);
HRESULT __thiscall sub_47C350(OLECHAR *this, int, int);
LSTATUS __thiscall sub_47C3B0(const WCHAR *this, HKEY hKey);
// int __usercall sub_47C430@<eax>(int@<esi>);
// int __usercall sub_47C4B0@<eax>(int@<esi>);
int __thiscall sub_47C540(int this, int);
void __stdcall sub_47C5D0(int);
// int __userpurge sub_47C6A0@<eax>(int@<esi>, int, void *, int, int, int, int, int, int, void *, int, int, int, int, int, int, void *, int, int, int, int, int, int, int);
void __thiscall sub_47C7C0(_DWORD *this, LPCWSTR lpString1, void *);
LSTATUS __fastcall sub_47C910(int, int, HKEY hKey);
int *sub_47C990();
// void __usercall sub_47CA40(int@<esi>);
int __thiscall sub_47CB80(int this);
int *sub_47CC30();
// void __userpurge sub_47CCA0(int@<ecx>, void *@<ebx>, int);
// void __userpurge sub_47CE20(int@<esi>, void *, _QWORD *);
// LRESULT __usercall sub_47CFB0@<eax>(int@<eax>);
DWORD __stdcall sub_47D070(LPVOID lpThreadParameter); // idb
void __thiscall sub_47D090(int this);
int __thiscall sub_47D500(int this, unsigned int, int);
int __thiscall sub_47D5E0(int this);
// int __userpurge sub_47DB90@<eax>(int@<ecx>, int@<esi>, void *, int, int, int, int, int, int);
HRESULT __fastcall sub_47DC80(LPCITEMIDLIST *, const WCHAR *, int, LPCITEMIDLIST pidl, int, int);
void __thiscall sub_47DE70(_DWORD *this, LPCITEMIDLIST pidl1, int, int);
void __stdcall sub_47DF70(int, int, int *, HMENU);
int __thiscall sub_47E0A0(_DWORD *this, LPCITEMIDLIST pidl1, int, int, PCWSTR psz1);
int __thiscall sub_47E6C0(HWND *this);
int __thiscall sub_47E6D0(int this, _DWORD *);
int __thiscall sub_47E800(int this);
// void __usercall sub_47E860(int@<eax>);
// BOOL __usercall sub_47E920@<eax>(int@<ebx>);
int __thiscall sub_47ECE0(HWND *this, unsigned __int16, int);
// char **__usercall sub_47EE10@<eax>(int@<edi>);
// BOOL __usercall sub_47EFB0@<eax>(int@<esi>);
int __thiscall sub_47F1A0(int this);
int *sub_47F480();
int __thiscall sub_47F4C0(void *this, int, void *, int, int);
int __thiscall sub_47F650(_DWORD *this, LPCWSTR lpString1, wchar_t *String);
LSTATUS __thiscall sub_47F680(BYTE *this, HKEY hKey);
LSTATUS __thiscall sub_47F6B0(_DWORD *this, HKEY hKey);
// void __usercall sub_47F740(int@<edi>, int@<esi>);
int __thiscall sub_47F850(HICON *this);
int __thiscall sub_47F860(HWND *this);
int __thiscall sub_47F870(void *this, int);
HRESULT __thiscall sub_47F890(int *this, int, int);
LRESULT __thiscall sub_47F900(void *this, int);
int __thiscall sub_47FAC0(int this);
char **__stdcall sub_47FB60(_DWORD *, char **);
// void __usercall sub_47FEB0(_DWORD *@<edi>);
int *sub_47FEE0();
int __thiscall sub_47FF30(int this);
int __thiscall sub_480570(void *this, int, int, int, int, int, int, int, int, int);
void __fastcall sub_480660(int, int);
// LRESULT __usercall sub_4808B0@<eax>(int@<esi>);
// BOOL __usercall sub_480910@<eax>(int@<esi>);
int __thiscall sub_480970(HWND *this, unsigned int, int);
// void __usercall sub_480AB0(int@<edi>, int@<esi>);
int __thiscall sub_480B70(HICON *this);
int __thiscall sub_480B80(HWND *this);
int __thiscall sub_480B90(void *this, int);
int __thiscall sub_480BB0(int this);
char **__stdcall sub_480C50(_DWORD *, char **);
int __thiscall sub_480FA0(int this);
int *sub_481280();
// int __usercall sub_4812C0@<eax>(int@<edx>, int@<ecx>, int@<esi>);
void __stdcall sub_481330(int);
int __thiscall sub_4815B0(int this, unsigned __int16, int);
int __thiscall sub_4816A0(HWND *this);
int __stdcall sub_4816B0(HWND hWnd, int, int, LPARAM lParam); // idb
UINT __thiscall sub_4816E0(int this);
// LRESULT __usercall sub_481880@<eax>(int@<edi>);
int __thiscall sub_4819A0(void *this, int, int);
int __thiscall sub_481AE0(void *this, int, int);
int __stdcall sub_481C60(void *, int, int);
char **__stdcall sub_481CB0(_DWORD *, char **);
// void __usercall sub_4820E0(int@<edi>);
int *sub_482160();
void __stdcall sub_482370(int);
// int __userpurge sub_4823E0@<eax>(int@<esi>, int, int, int, int, int, int, int);
char **__thiscall sub_482500(int this, int, int, unsigned int);
void __thiscall sub_482780(_DWORD **this, LPCITEMIDLIST pidl1, int, int);
int __thiscall sub_482820(_DWORD **this, LPCITEMIDLIST pidl1, int, int, PCWSTR psz1);
BOOL __thiscall sub_482890(HINSTANCE *this, LPCITEMIDLIST pidl1, int, int, int);
int *sub_482970();
int __thiscall sub_4829E0(void *this, int, int, int);
void __stdcall sub_482B60(int);
int __thiscall sub_482CC0(void *); // idb
int __thiscall sub_482CE0(int this);
void __thiscall sub_483350(int this, LPCWSTR lpString1, wchar_t *String);
void __thiscall sub_483610(int this, int, int);
void __thiscall sub_483980(int this, HKEY hKey);
void __thiscall sub_483C00(int this, HKEY hKey);
int __thiscall sub_483F30(int this, int);
// void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD); weak
int __thiscall sub_484240(WPARAM wParam, int); // idb
// HANDLE __userpurge sub_484670@<eax>(int@<ecx>, int@<esi>, LPCWSTR pszDir);
void __thiscall sub_4849D0(int this, WPARAM wParam);
LONG __stdcall sub_484B50(int);
DWORD __stdcall sub_484C60(LPVOID lpThreadParameter); // idb
void __thiscall sub_484C80(int this);
int __thiscall sub_4854B0(int this, unsigned __int16, int);
int __thiscall sub_4856A0(HWND *this);
int __thiscall sub_4856B0(int this);
// void __usercall sub_485710(_DWORD *@<eax>);
int __thiscall sub_485750(int this);
int *sub_485830();
// int __userpurge sub_485870@<eax>(int@<edx>, int@<ecx>, int@<esi>, int);
// BOOL __usercall sub_4858F0@<eax>(int@<esi>);
int __thiscall sub_485A00(HWND *this, unsigned __int16, int);
// int __usercall sub_485A90@<eax>(HKEY hKey@<ecx>, int@<esi>);
// int __usercall sub_485B00@<eax>(HKEY hKey@<ecx>, int@<esi>);
// int __usercall sub_485B70@<eax>(HKEY hKey@<ecx>, int@<esi>);
// LSTATUS __usercall sub_485BE0@<eax>(int@<eax>, HKEY@<edx>);
// LSTATUS __usercall sub_485C40@<eax>(int@<eax>, HKEY@<edx>);
// LSTATUS __usercall sub_485CA0@<eax>(int@<eax>, HKEY@<edx>);
LSTATUS __thiscall sub_485D00(void *this, HKEY hKey, LPCWSTR lpString, int Value);
// LSTATUS __usercall sub_485DF0@<eax>(_DWORD *@<esi>);
// LSTATUS __usercall sub_485E60@<eax>(int@<esi>);
int sub_486920();
// int __usercall sub_486980@<eax>(BYTE *@<esi>);
LSTATUS __thiscall sub_4869E0(_DWORD **this);
LSTATUS __thiscall sub_4869F0(int *this);
LSTATUS __thiscall sub_486A00(BYTE *this);
LSTATUS __thiscall sub_486BC0(HWND *this);
LSTATUS __fastcall sub_486D60(int Value, HKEY hKey, int);
// void __userpurge sub_486E50(int@<esi>, HKEY hKey, LPCWSTR lpValueName);
// void __userpurge sub_486EC0(int@<esi>, HKEY hKey, LPCWSTR lpValueName);
// _DWORD **__usercall sub_486F30@<eax>(_DWORD **@<ebx>, _DWORD **@<edi>);
LSTATUS __thiscall sub_486F70(void *this, HKEY hKey, LPCWSTR lpString, int Value);
// LSTATUS __usercall sub_487150@<eax>(void *@<esi>);
LSTATUS __thiscall sub_487210(HWND **this);
LSTATUS __thiscall sub_487220(void **this);
LSTATUS __thiscall sub_487230(BYTE **this);
LSTATUS __thiscall sub_487240(HKEY hKey, int);
// LSTATUS __usercall sub_487490@<eax>(int@<edi>);
// LSTATUS __usercall sub_4875D0@<eax>(int@<edi>);
LSTATUS __stdcall sub_487C70(HKEY hKey, int);
// LSTATUS __usercall sub_487F80@<eax>(int@<esi>);
LSTATUS __thiscall sub_488000(int this);
LSTATUS __thiscall sub_488910(int *this);
LSTATUS __thiscall sub_488920(int *this);
LSTATUS __thiscall sub_488930(_DWORD *this);
LSTATUS __thiscall sub_488970(int *this);
LSTATUS __thiscall sub_488980(int *this);
char **__fastcall sub_488990(LPCWSTR lpValueName, int *, HKEY hKey);
char **__fastcall sub_488A80(LPCWSTR lpValueName, int *, HKEY hKey);
void __stdcall sub_488B70(_DWORD *);
void __thiscall sub_4892B0(_DWORD **this);
LSTATUS __thiscall sub_4892C0(_DWORD *this);
LSTATUS __thiscall sub_489430(_DWORD **this);
LSTATUS __thiscall sub_489440(HKEY this, int);
// LSTATUS __usercall sub_489710@<eax>(HKEY@<ecx>, int@<esi>);
LSTATUS __thiscall sub_489780(HKEY this);
LSTATUS __thiscall sub_489790(void *this);
LSTATUS __thiscall sub_489A90(void *this);
LSTATUS __thiscall sub_489DB0(void **this);
LSTATUS __thiscall sub_489DC0(void **this);
int __stdcall sub_489DD0(int);
int __thiscall sub_48B300(int *this);
// LRESULT __usercall sub_48B360@<eax>(HWND@<edi>);
// LRESULT __userpurge sub_48B420@<eax>(HWND@<eax>, int);
int __stdcall sub_48B4B0(int, HWND hDlg, int); // idb
HWND __thiscall sub_48B5E0(HWND *this, HWND hDlg);
HWND __stdcall sub_48B6B0(int, HWND hWnd);
HWND __thiscall sub_48B760(HWND hDlg, int);
int __fastcall sub_48B8B0(HWND, int);
WPARAM __thiscall sub_48B940(_DWORD *this, int, HWND hDlg);
// BOOL __usercall sub_48BA70@<eax>(int@<ecx>, HWND@<edi>);
_WORD *__stdcall sub_48BAD0(HWND hDlg, int);
LRESULT __stdcall sub_48BC20(HWND hDlg, WPARAM wParam);
// HWND __userpurge sub_48BD20@<eax>(LPARAM@<esi>, int, HWND hWnd, WPARAM wParam);
// HWND __userpurge sub_48BE10@<eax>(HWND@<edi>, LPARAM);
BOOL __thiscall sub_48BE50(HWND hDlg, int);
// int __userpurge sub_48C100@<eax>(HWND hDlg@<ecx>, _DWORD *@<edx>, HMENU@<ebx>, int);
int __stdcall sub_48C3B0(HWND hDlg, UINT, WPARAM, LPARAM); // idb
// BOOL __usercall sub_48C3E0@<eax>(HWND@<esi>);
// BOOL __usercall sub_48C410@<eax>(HWND@<eax>);
// LRESULT __usercall sub_48C490@<eax>(HWND@<ebx>, const ITEMIDLIST *@<esi>);
int __stdcall sub_48C510(HWND hWnd, int, int, int); // idb
int __stdcall sub_48C540(HWND, int, int);
__int16 __fastcall sub_48C560(LPCWSTR pszMore, int, int);
LRESULT __stdcall sub_48C710(int, HWND hDlg);
// void __usercall sub_48C910(HWND@<edi>);
// int __userpurge sub_48CA70@<eax>(unsigned int@<eax>, HWND@<esi>, unsigned __int16, int);
int __stdcall sub_48CD30(HWND, unsigned int, unsigned __int16, int);
// int __userpurge sub_48CD60@<eax>(unsigned int@<eax>, HWND@<edx>, unsigned int@<ecx>, WPARAM wParam);
int __stdcall sub_48D5B0(HWND, unsigned int, unsigned int, WPARAM);
int __fastcall sub_48D5E0(HWND hDlg, unsigned int, int, int);
int __stdcall sub_48DC00(HWND hDlg, int, int, int); // idb
// int __userpurge sub_48DC30@<eax>(unsigned int@<ecx>, HWND@<esi>, unsigned __int16, int);
int __stdcall sub_48E080(HWND, unsigned int, unsigned __int16, int);
int __thiscall sub_48E0B0(WPARAM wParam, int, __int16, int); // idb
int __stdcall sub_48E650(WPARAM wParam, int, __int16, int); // idb
// HWND __usercall sub_48E680@<eax>(int@<esi>);
int __thiscall sub_48E920(_DWORD *this);
int __thiscall sub_48E930(_DWORD *this);
void __stdcall sub_48E940(int);
// int __usercall sub_48E980@<eax>(int@<ecx>, int@<edi>, int@<esi>);
// int __usercall sub_48EA10@<eax>(int@<ecx>, int@<edi>, int@<esi>);
// int __userpurge sub_48EAA0@<eax>(int@<eax>, int);
// BOOL __usercall sub_48EBA0@<eax>(int@<eax>, int@<esi>);
// unsigned int __userpurge sub_48EBF0@<eax>(int@<edi>, int, LPARAM);
// int __usercall sub_48EC70@<eax>(int@<esi>);
// int __usercall sub_48ECA0@<eax>(int@<eax>);
// WPARAM __userpurge sub_48ECC0@<eax>(WPARAM result@<eax>, int);
// LONG __usercall sub_48ECF0@<eax>(int@<eax>);
// void __usercall sub_48EE00(int csidl@<ecx>, UINT@<ebx>, HMENU@<esi>);
// HWND __usercall sub_48EEF0@<eax>(int@<eax>);
// HWND __usercall sub_48EFB0@<eax>(int@<esi>);
// int __usercall sub_48F030@<eax>(int@<ecx>, int@<edi>, int@<esi>);
int __thiscall sub_48F090(UINT *this, int);
// unsigned int __usercall sub_48F0C0@<eax>(int a1@<ebx>);
// LRESULT __userpurge sub_48F100@<eax>(int@<esi>, int);
// HWND __usercall sub_48F160@<eax>(WPARAM wParam@<ecx>, int@<edx>, LPARAM@<esi>);
// LRESULT __usercall sub_48F1A0@<eax>(int@<edi>, _DWORD *@<esi>);
// int __userpurge sub_48F210@<eax>(int@<esi>, int nWidth, int);
// BOOL __userpurge sub_48F5A0@<eax>(int@<esi>, int);
// BOOL __usercall sub_48F5E0@<eax>(int@<esi>);
// void __userpurge sub_48F6D0(int@<ebx>, ITEMIDLIST *@<esi>, const WCHAR *);
// void __userpurge sub_48F7A0(int@<eax>, int, int, int);
_DWORD *__fastcall sub_48F820(UINT item, HMENU hmenu, int);
// BOOL __usercall sub_48F860@<eax>(HMENU@<edi>, UINT@<esi>);
int sub_48F8E0();
void __stdcall sub_48F9C0(ULONG_PTR Parameter); // idb
void __stdcall sub_48F9D0(ULONG_PTR Parameter); // idb
void __stdcall __noreturn sub_48F9E0(LPVOID lpThreadParameter);
// int __usercall sub_48F9F0@<eax>(int@<ebx>);
BOOL __thiscall sub_48FAE0(HWND *this);
int __thiscall sub_48FB40(_DWORD *this);
// int __usercall sub_48FB60@<eax>(int@<edi>, int@<esi>);
// int __usercall sub_48FC40@<eax>(int@<eax>);
void __stdcall sub_48FCC0(HMENU hmenu, int);
BOOL __thiscall sub_48FD90(_DWORD **this);
void __thiscall sub_48FE90(int this);
// HRESULT __userpurge sub_48FFD0@<eax>(int a1@<edi>, int a2, int a3, int a4, int a5);
// HRESULT __userpurge sub_490020@<eax>(int a1@<edi>, int a2, int a3);
// LRESULT __userpurge sub_490070@<eax>(int@<esi>, int);
HWND __thiscall sub_4900F0(int this);
void __thiscall sub_490280(int this);
void sub_4903B0();
// int __usercall sub_490550@<eax>(int@<esi>);
void __stdcall sub_490600(int);
void __stdcall sub_490690(int);
void __stdcall sub_4906F0(int);
// int __usercall sub_490750@<eax>(_DWORD *@<edi>);
// int __userpurge sub_490840@<eax>(int@<ecx>, int@<edi>, int@<esi>, int);
// int __usercall sub_4908C0@<eax>(int@<ecx>, int@<edi>, int@<esi>);
// char **__usercall sub_490940@<eax>(int@<ebx>);
// char **__usercall sub_4909E0@<eax>(int@<ebx>);
// char **__usercall sub_490A80@<eax>(int@<ebx>);
// char **__usercall sub_490B20@<eax>(int@<ebx>);
// char **__usercall sub_490BC0@<eax>(int@<ebx>);
// char **__usercall sub_490C60@<eax>(int@<ebx>);
// char **__usercall sub_490D00@<eax>(int@<ebx>);
void __fastcall sub_490DF0(int, int);
// void __usercall sub_490E60(_DWORD *@<ecx>, _DWORD *@<edi>);
// void __usercall sub_490FA0(int@<edi>);
HINSTANCE __thiscall sub_491180(_DWORD *this);
int __fastcall sub_4916A0(int, _DWORD *);
// LRESULT __usercall sub_491870@<eax>(int@<esi>);
// int __usercall sub_491A30@<eax>(int@<esi>);
void __thiscall sub_491AC0(void *this);
void *__thiscall sub_4921A0(int this);
// void __usercall sub_492290(int@<eax>, int@<ecx>);
void __thiscall sub_4922E0(int this);
// void __usercall sub_492490(int@<eax>);
void __thiscall sub_4924F0(HWND *this);
// void __usercall sub_492670(int@<eax>, int@<ecx>);
// void __usercall sub_492740(unsigned int@<eax>, int@<ecx>);
int __thiscall sub_492870(_DWORD *this, unsigned int);
int __thiscall sub_4928D0(int this, const ITEMIDLIST *, int, int, int, int);
int __fastcall sub_492F40(int, const ITEMIDLIST *, int);
// void __userpurge sub_4934A0(int@<esi>, int);
int __fastcall sub_493570(int, const ITEMIDLIST *, int, int);
void __thiscall sub_4935D0(int *this, LPCITEMIDLIST pidl2, int, int);
// HWND __usercall sub_4938E0@<eax>(DWORD@<ebx>);
int __thiscall sub_493CF0(_DWORD *this);
int __stdcall sub_493D00(int);
int __stdcall sub_493F00(int);
// BOOL __usercall sub_494260@<eax>(const WCHAR *@<edi>);
// BOOL __usercall sub_4943A0@<eax>(int@<ecx>, int *@<edi>, int@<esi>);
int __fastcall sub_494470(int, int, _DWORD *);
void __cdecl sub_494510(int, int, int, void *Block);
void __cdecl sub_494560(int, int, _DWORD *);
BOOL __fastcall sub_4945B0(int csidl, int);
// int __usercall sub_494600@<eax>(int@<edi>);
// int __usercall sub_494670@<eax>(_DWORD *@<eax>);
// HRESULT __userpurge sub_4946F0@<eax>(int a1@<eax>, int a2);
// HRESULT __userpurge sub_494780@<eax>(int a1@<eax>, int a2);
// LRESULT __userpurge sub_494810@<eax>(LPARAM@<edi>, HWND@<esi>, const WCHAR *pszPath);
// void __userpurge sub_4948B0(int@<edi>, int);
// int __usercall sub_4949B0@<eax>(int@<esi>);
// HWND __usercall sub_4949E0@<eax>(int@<esi>);
// LRESULT __usercall sub_494AB0@<eax>(int@<ecx>, HWND@<edi>);
// _DWORD *__usercall sub_494C50@<eax>(_DWORD *result@<eax>);
// void __usercall sub_494E80(int@<esi>);
int __stdcall sub_494FD0(int);
// int __userpurge sub_495230@<eax>(LPARAM lParam@<ecx>, HWND *a2@<esi>, WPARAM wParam);
// void __usercall sub_495530(_DWORD *@<ebx>);
// void __usercall sub_4959C0(int@<eax>);
void __thiscall sub_495AA0(int *this);
void __thiscall sub_495B40(int this, int);
// int __userpurge sub_495DD0@<eax>(unsigned int@<ebx>, int@<edi>, int);
// int __userpurge sub_495E60@<eax>(_WORD *@<edi>, LPCWSTR lpDirectoryName);
// LRESULT __usercall sub_495FD0@<eax>(int@<esi>);
LRESULT __thiscall sub_496160(_DWORD *this);
// void __usercall sub_4968D0(int@<esi>);
// void __usercall sub_496B80(int@<eax>);
// int __usercall sub_496BE0@<eax>(int@<esi>);
int __fastcall sub_496E90(int, int);
// BOOL __usercall sub_4971A0@<eax>(int@<esi>);
LRESULT __thiscall sub_497230(int this, int, LPARAM lParam, int);
int __thiscall sub_497360(HICON *this);
int __thiscall sub_497370(HWND *this);
int __thiscall sub_497380(int this);
char **__stdcall sub_497410(_DWORD *, char **);
int *sub_4978A0();
// int __usercall sub_4978E0@<eax>(int@<esi>);
void __stdcall sub_497940(int);
// LRESULT __usercall sub_497A20@<eax>(int@<edi>);
DWORD __stdcall sub_497C70(LPVOID lpThreadParameter); // idb
// int __userpurge sub_497C90@<eax>(int@<edi>, int, void *, int, int, int, int, int, int, void *, int, int);
// LRESULT __userpurge sub_497DE0@<eax>(int@<ebx>, char);
// int __userpurge sub_497E90@<eax>(int@<edx>, int@<esi>, void *, int, int, int, int, int, int, void *, int, int, int);
// void __usercall sub_498020(int@<esi>);
void __thiscall sub_498160(int this);
int __thiscall sub_498320(int this, unsigned __int16, int);
int __thiscall sub_4983A0(void *this);
int __thiscall sub_498C00(_DWORD *this, LPCWSTR lpString1, wchar_t *String);
LSTATUS __thiscall sub_498C60(BYTE *this, HKEY hKey);
LSTATUS __thiscall sub_498CC0(int this, HKEY hKey);
int __thiscall sub_498D40(HICON *this);
int __thiscall sub_498D60(HWND *this);
HRESULT __thiscall sub_498D70(int *this, int, int);
LRESULT __thiscall sub_498DE0(int this);
char **__stdcall sub_498EB0(_DWORD *, char **);
int *sub_499070();
int __thiscall sub_499100(int this);
int __thiscall sub_4994F0(void *this, int, void *, int, int, int);
// void __userpurge sub_499640(int *@<edi>, void *, int, int, int, int, int, int, LPCWSTR, int, int, int, int, int, int, int);
void __thiscall sub_499C20(_DWORD *this);
int __thiscall sub_49A150(int this, int, int);
// int __usercall sub_49A5C0@<eax>(int@<eax>);
// int __usercall sub_49A6A0@<eax>(int@<eax>);
// LRESULT __usercall sub_49A780@<eax>(int@<esi>);
// char **__usercall sub_49AD80@<eax>(int@<esi>);
// LRESULT __usercall sub_49B450@<eax>(int@<esi>);
int __thiscall sub_49B6A0(_DWORD **this, int, int);
// void __usercall sub_49B6D0(int@<eax>);
void __thiscall sub_49B7C0(_DWORD *this);
// int __usercall sub_49B900@<eax>(int@<ebx>, _DWORD *@<esi>);
// int __userpurge sub_49BA70@<eax>(int@<eax>, int);
// int __userpurge sub_49BA90@<eax>(int@<eax>, int *);
// LRESULT __userpurge sub_49BB50@<eax>(int@<esi>, unsigned int);
// LRESULT __usercall sub_49BBF0@<eax>(char@<bl>, unsigned int@<edi>, int@<esi>);
// HWND __userpurge sub_49BC80@<eax>(int@<ebx>, HWND hWndParent);
void __thiscall sub_49BD50(int this, int *);
void __fastcall sub_49C010(_DWORD *, int, wchar_t *);
// LRESULT __userpurge sub_49C160@<eax>(int@<esi>, unsigned int);
HMENU __thiscall sub_49C330(_DWORD *this);
unsigned int __fastcall sub_49C530(_DWORD *a1, int a2);
void __thiscall sub_49C620(char ***this);
// int __userpurge sub_49C860@<eax>(int@<ecx>, HWND@<esi>, int, int, DWORD dwErrCode);
int __stdcall sub_49CAB0(HWND, int, int, DWORD, int, int);
// int __userpurge sub_49CAE0@<eax>(DWORD@<esi>, int);
void __thiscall sub_49CB90(HWND hWnd, int, int);
HRESULT __thiscall sub_49CDA0(char *this);
// HRESULT __userpurge sub_49CEE0@<eax>(int a1@<esi>, int a2);
void __thiscall sub_49D190(_DWORD *this);
// void __usercall sub_49D460(int@<ebx>);
void __thiscall sub_49D660(int this);
void __thiscall sub_49D950(int this, void *);
LPDATAOBJECT __thiscall sub_49DB50(int this, int, struct IDropSourceVtbl *);
void __thiscall sub_49E070(int this, int);
BOOL __thiscall sub_49E2E0(int this, int);
// void __usercall sub_49E480(LONG *@<ebx>, int@<edi>);
int __fastcall sub_49E5A0(int, int);
int __thiscall sub_49E9B0(int, int); // idb
LRESULT __fastcall sub_49EF70(int, HWND, UINT Msg, WPARAM wParam, unsigned int lParam);
LRESULT __stdcall sub_49F510(HWND hWnd, int, int, int);
// LONG __usercall sub_49F540@<eax>(int@<eax>, int@<ebx>);
int __stdcall sub_49F7B0(int, int);
int __stdcall sub_49F7C0(int, int, int);
LONG __stdcall sub_49F810(int);
LONG __stdcall sub_49F840(void *);
int __stdcall sub_49F8D0(int, _DWORD *, _DWORD *);
int __thiscall sub_49F930(HWND *this);
int __thiscall sub_49F940(HWND *this, int);
int __thiscall sub_49F990(HWND *this, __int16, int);
int __thiscall sub_49F9C0(_DWORD *this);
// void __usercall sub_49F9E0(_DWORD *@<eax>);
// int __usercall sub_49FA00@<eax>(int result@<eax>, int@<edx>);
int __thiscall sub_49FA40(HICON *this);
int __thiscall sub_49FA50(HWND *this);
int __thiscall sub_49FA60(int this);
// void __usercall sub_49FAC0(_DWORD *@<eax>);
char **__stdcall sub_49FAE0(_DWORD *, char **);
int *sub_49FC40();
int *sub_49FCF0();
int __fastcall sub_49FD60(int, int, int);
void __thiscall sub_49FE00(_DWORD **this, int, int);
LSTATUS __thiscall sub_49FE30(_DWORD **this, HKEY);
int __thiscall sub_49FE50(int this);
void __thiscall sub_4A0040(_DWORD *this, int, void *Src);
LSTATUS __thiscall sub_4A0140(void *this, HKEY);
// BOOL __usercall sub_4A0160@<eax>(int@<esi>);
int __thiscall sub_4A03D0(HWND *this, __int16, int);
int __stdcall sub_4A0400(int, int, int);
int __stdcall sub_4A0430(int, _DWORD *);
int __stdcall sub_4A0450(int, int, int, int);
int __stdcall sub_4A0460(int, int, int);
int __stdcall sub_4A0470(int);
int __stdcall sub_4A0480(int, int, int, int);
int __stdcall sub_4A0490(int, int);
int __stdcall sub_4A04A0(int);
int __stdcall sub_4A04B0(int, int, int, int, int, int);
int __stdcall sub_4A04C0(int);
int __stdcall sub_4A04D0(int, int);
int __stdcall sub_4A04E0(int, int);
int __stdcall sub_4A04F0(int, int);
int __stdcall sub_4A0500(int, int);
int __stdcall sub_4A0510(int, int);
int __stdcall sub_4A0520(int, LPCITEMIDLIST pidl2, int, int); // idb
int __stdcall sub_4A0570(int, int);
int __stdcall sub_4A0580(int, int, int);
int __stdcall sub_4A0590(int, int);
int __stdcall sub_4A05A0(int);
int __stdcall sub_4A05C0(int, int, _DWORD *);
// _DWORD *__usercall sub_4A0610@<eax>(_DWORD *result@<eax>);
// _DWORD *__usercall sub_4A0780@<eax>(_DWORD *result@<eax>);
int __stdcall sub_4A08C0(int);
int __stdcall sub_4A08E0(int, int, _DWORD *, _DWORD *);
int __stdcall sub_4A0960(void *); // idb
HMENU __thiscall sub_4A0990(_DWORD *this, int);
int __stdcall sub_4A0BC0(int, _DWORD *, int *);
void __stdcall sub_4A0C10(int);
int __stdcall sub_4A1220(void *); // idb
// int __userpurge sub_4A1250@<eax>(int@<esi>, int);
// LRESULT __usercall sub_4A1E40@<eax>(int@<esi>);
// int __userpurge sub_4A1EF0@<eax>(int@<edi>, const WCHAR *);
// LRESULT __userpurge sub_4A1FD0@<eax>(int@<edi>, const WCHAR *);
// LRESULT __usercall sub_4A2080@<eax>(int@<ebx>, const WCHAR *@<edi>);
void __thiscall sub_4A2230(HWND *this);
// int __userpurge sub_4A2490@<eax>(int@<ebx>, int@<esi>, int, int, DWORD dwErrCode);
int __stdcall sub_4A2550(int, int, int, DWORD, int, int);
// LRESULT __usercall sub_4A25D0@<eax>(HWND hWnd@<ecx>, HWND@<esi>);
// UINT __usercall sub_4A2770@<eax>(HWND@<esi>);
// BOOL __usercall sub_4A28D0@<eax>(int@<edi>, HWND@<esi>);
// LRESULT __usercall sub_4A2A10@<eax>(DWORD@<edi>);
BOOL __thiscall sub_4A2B10(HWND hWnd, int);
int __fastcall sub_4A2F60(unsigned int, HWND, unsigned int, HWND hWnd);
int __stdcall sub_4A3300(HWND, UINT, WPARAM, LPARAM); // idb
int __thiscall sub_4A3330(_DWORD *this, LPCWSTR lpString1, wchar_t *String);
LSTATUS __thiscall sub_4A3360(BYTE *this, HKEY hKey);
LSTATUS __thiscall sub_4A3390(_DWORD *this, HKEY hKey);
int __thiscall sub_4A33E0(HICON *this);
int __thiscall sub_4A33F0(HWND *this);
HGDIOBJ __thiscall sub_4A3400(HWND *this, int, HDC hdc);
HRESULT __thiscall sub_4A3450(int *this, int, int);
int __thiscall sub_4A3490(int this);
char **__stdcall sub_4A3550(_DWORD *, char **);
// void __usercall sub_4A3850(_DWORD *@<eax>);
int *sub_4A3890();
BOOL __thiscall sub_4A38E0(int this);
// BOOL __usercall sub_4A3990@<eax>(int@<esi>);
int __thiscall sub_4A3A10(HWND *this, __int16, int);
int __thiscall sub_4A3A40(void *this, int, void *, int, int, int);
int __thiscall sub_4A3B90(void *this);
int __thiscall sub_4A4080(HICON *this);
int __thiscall sub_4A4090(HWND *this);
int __thiscall sub_4A40A0(int this);
char **__stdcall sub_4A4100(_DWORD *, char **);
// void __usercall sub_4A43B0(_DWORD *@<eax>);
WPARAM __thiscall sub_4A43F0(HWND hWnd, int, int);
int *sub_4A4570();
// int __usercall sub_4A45B0@<eax>(int@<edx>, int@<ecx>, int@<esi>);
// void __usercall sub_4A4620(int@<ecx>, WPARAM@<ebx>);
// HWND __usercall sub_4A4880@<eax>(int@<esi>);
int __thiscall sub_4A48C0(void *this, int);
HWND __thiscall sub_4A48F0(int this);
_DWORD *__stdcall sub_4A4A30(int, int);
void __thiscall sub_4A4AB0(int this);
int __thiscall sub_4A4C90(HWND *this, unsigned __int16, int);
int __thiscall sub_4A4D50(int this);
LSTATUS __thiscall sub_4A50A0(BYTE *this, HKEY hKey);
LSTATUS __thiscall sub_4A5100(const BYTE *this, HKEY hKey);
int __thiscall sub_4A5160(HWND *this);
int __thiscall sub_4A5180(int this);
HRESULT __thiscall sub_4A5200(unsigned __int8 *this, int, int);
int *sub_4A5390();
int *sub_4A5410();
// int __usercall sub_4A54A0@<eax>(int@<esi>);
int __stdcall sub_4A5590(HWND hWnd, int, HDC hDC, DWORD dwErrCode, int, int); // idb
int __thiscall sub_4A5620(DWORD dwErrCode); // idb
void __thiscall sub_4A5800(int this, LPCWSTR lpString2, wchar_t *String);
// BOOL __usercall sub_4A5B10@<eax>(int@<esi>);
int __thiscall sub_4A5C10(HWND *this, unsigned int, int);
int __stdcall sub_4A5CB0(int);
int __stdcall sub_4A5CF0(int, int, LONG, LONG, _DWORD *);
int __stdcall sub_4A5E00(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __stdcall sub_4A5F90(int);
int __stdcall sub_4A5FB0(int, int, _DWORD *);
int __stdcall sub_4A5FE0(void *); // idb
int __stdcall sub_4A6050(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
// int __usercall sub_4A63A0@<eax>(void *@<ebx>, HWND@<esi>);
HWND __thiscall sub_4A6420(HWND *this, int a2);
int __fastcall sub_4A6570(int, int);
// WPARAM __userpurge sub_4A65C0@<eax>(HWND a1@<edi>, int a2);
// int __userpurge sub_4A6620@<eax>(int@<edi>, LPARAM);
// HWND __userpurge sub_4A6700@<eax>(int a1@<ecx>, int a2@<esi>, LPARAM a3);
// HRESULT __userpurge sub_4A6780@<eax>(int a1@<esi>, LPCWSTR lpSrc, int a3, int a4);
int __thiscall sub_4A6820(void *this, HWND hWnd, int, int, int);
int __thiscall sub_4A6960(_DWORD *this, HWND);
int __thiscall sub_4A6A90(void *this, HWND, LPARAM, _DWORD *);
_DWORD *__thiscall sub_4A6BE0(HWND *this, int);
int __thiscall sub_4A6D20(void *this, HMENU hmenu, UINT item, UINT uPosition);
// int __usercall sub_4A6FC0@<eax>(HMENU *@<esi>);
int __thiscall sub_4A70B0(int this, WPARAM wParam);
// int __userpurge sub_4A7130@<eax>(int@<esi>, WPARAM wParam, int);
// int __userpurge sub_4A71D0@<eax>(UINT@<edx>, _WORD *@<esi>, HMENU hmenu);
// WPARAM __userpurge sub_4A7250@<eax>(LPARAM@<esi>, WPARAM wParam);
int __thiscall sub_4A7300(HWND *this, int, int, int, DWORD dwErrCode);
int __stdcall sub_4A73F0(int, int, int, DWORD dwErrCode, int, int); // idb
// INT_PTR __usercall sub_4A7410@<eax>(LPARAM@<eax>);
// _DWORD *__usercall sub_4A7440@<eax>(HWND *@<esi>);
// WPARAM __userpurge sub_4A74D0@<eax>(LPARAM a1@<esi>, WPARAM wParam);
// BOOL __usercall sub_4A7580@<eax>(int@<edi>);
// int __usercall sub_4A7640@<eax>(int@<eax>);
// int __usercall sub_4A77E0@<eax>(int@<eax>);
// int __usercall sub_4A7980@<eax>(int@<esi>);
// int __usercall sub_4A7A70@<eax>(int@<eax>);
// UINT __userpurge sub_4A7C00@<eax>(int@<ebx>, HMENU);
// char **__usercall sub_4A7D10@<eax>(int@<edi>);
void __stdcall sub_4A8290(int);
// BOOL __usercall sub_4A84E0@<eax>(int@<eax>);
// HWND __usercall sub_4A85C0@<eax>(HWND@<esi>);
// HWND __usercall sub_4A8630@<eax>(int@<ebx>, HWND@<edi>);
// LRESULT __userpurge sub_4A86C0@<eax>(int@<edi>, WPARAM wParam);
// HWND __usercall sub_4A87B0@<eax>(int a1@<edi>, int a2@<esi>);
// void __usercall sub_4A8890(int@<edi>);
// void __usercall sub_4A8A10(WPARAM wParam@<ecx>, int@<esi>);
// BOOL __usercall sub_4A8B40@<eax>(int@<eax>, HWND@<esi>);
HRESULT __thiscall sub_4A8BD0(int this);
void __fastcall sub_4A8D10(int, const WCHAR *, WPARAM wParam);
_DWORD *__stdcall sub_4A8DD0(int, int, int, int);
// BOOL __usercall sub_4A8ED0@<eax>(int@<ecx>, HWND@<ebx>);
// int __usercall sub_4A8F80@<eax>(HWND@<edi>);
// int __userpurge sub_4A9060@<eax>(HWND hDlg@<ecx>, int@<eax>, __int16);
int __stdcall sub_4A90D0(HWND hDlg, int, __int16, int); // idb
// int __userpurge sub_4A9100@<eax>(HWND hDlg@<ecx>, int@<eax>, __int16);
int __stdcall sub_4A9180(HWND hDlg, int, __int16, int); // idb
// INT_PTR __userpurge sub_4A91B0@<eax>(LPARAM@<esi>, WPARAM wParam);
// INT_PTR __usercall sub_4A9210@<eax>(LPARAM@<eax>);
int __stdcall sub_4A9270(int);
int __stdcall sub_4A9290(int a1, int a2, int a3, int a4, _DWORD *a5);
int __stdcall sub_4A92C0(int a1, int *a2, int a3, int a4, int a5, _DWORD *a6);
int __stdcall sub_4A9340(int);
int __stdcall sub_4A9360(int, int, _DWORD *);
int __stdcall sub_4A93D0(void *); // idb
int __stdcall sub_4A9400(int, int, int, LONG, LONG, _DWORD *);
// int __usercall sub_4A96F0@<eax>(int@<eax>, int@<edx>, _WORD *@<ecx>);
// BOOL __usercall sub_4A97C0@<eax>(HWND@<esi>);
BOOL __thiscall sub_4A9D60(HWND hDlg, int);
BOOL __fastcall sub_4AA100(int, HWND, int);
INT_PTR __fastcall sub_4AA320(LPARAM dwInitParam, HWND hWndParent);
int __thiscall sub_4AA3E0(HWND hWndParent, int, __int16, int); // idb
int __stdcall sub_4AA4F0(HWND hWndParent, UINT, WPARAM, LPARAM); // idb
// int __usercall sub_4AA520@<eax>(int@<eax>, int@<edx>, _WORD *@<ecx>);
int __thiscall sub_4AA620(int this);
int __thiscall sub_4AA640(HWND *this, int);
int __thiscall sub_4AA690(HWND *this, __int16, int);
// int __usercall sub_4AA6C0@<eax>(unsigned int@<edx>, _WORD *@<ecx>, _DWORD *@<edi>);
// void __usercall sub_4AA720(_DWORD *@<eax>);
// int __usercall sub_4AA740@<eax>(int result@<eax>, int@<edx>);
int __thiscall sub_4AA770(int this);
LONG __thiscall sub_4AA960(HWND *this, int, int);
// void __usercall sub_4AAAD0(int@<esi>);
// int __usercall sub_4AAB10@<eax>(HWND hWnd@<ecx>, int ***@<edx>, int@<edi>);
// BOOL __usercall sub_4AAC80@<eax>(int@<eax>);
void __thiscall sub_4AAFA0(_DWORD **this);
void __thiscall sub_4AB090(int this, WPARAM wParam, int);
void __thiscall sub_4AB1F0(int this, int);
BOOL __thiscall sub_4AB3E0(int this);
// BOOL __userpurge sub_4AB810@<eax>(HMENU@<esi>, int);
// int __userpurge sub_4ABFC0@<eax>(LPCWSTR pszPath@<ecx>, int@<edx>, int@<esi>, WPARAM wParam);
// void __userpurge sub_4AC150(int@<esi>, int);
// void __usercall sub_4AC380(int@<eax>);
// void __usercall sub_4AC440(int@<eax>);
// void __usercall sub_4AC470(int@<esi>);
// HWND __usercall sub_4AC4A0@<eax>(int@<esi>);
// void __usercall sub_4AC4D0(int@<eax>, HWND *@<ecx>);
// void __usercall sub_4AC560(int@<eax>, void *@<edi>);
// void __usercall sub_4AC590(int@<eax>);
// void __usercall sub_4AC5F0(int@<ecx>, int@<esi>);
// void __usercall sub_4AC8B0(_DWORD *@<esi>);
// void __usercall sub_4AC8E0(int@<eax>);
BOOL __cdecl sub_4AC910(int);
BOOL __thiscall sub_4ACA40(void *this);
// int __usercall sub_4ACB60@<eax>(const WCHAR *@<edx>, int@<ecx>, const WCHAR *lpString);
int sub_4ACD40();
void __stdcall sub_4ACF20(_DWORD *);
int __stdcall sub_4AD000(int, int, LPCITEMIDLIST pidl, void *, int, int); // idb
LRESULT __fastcall sub_4AD310(LPARAM lParam, UINT uMsg, int, int, WPARAM wParam);
LRESULT __stdcall sub_4AD620(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData); // idb
// int __userpurge sub_4AD640@<eax>(DWORD_PTR dwRefData@<ecx>, int@<ebx>, int@<edi>, int, int, int, int, int);
// BOOL __usercall sub_4AD850@<eax>(int@<edx>, HWND@<ecx>, LPITEMIDLIST *@<ebx>);
// HRESULT __usercall sub_4AD8F0@<eax>(int a1@<ebx>, int a2@<edi>, const WCHAR *a3@<esi>, int a4, _WORD *a5);
// HRESULT __usercall sub_4ADA30@<eax>(_DWORD *@<eax>, _DWORD *@<edi>, _DWORD *);
// int __usercall sub_4ADAF0@<eax>(const WCHAR *@<esi>, _WORD *);
// int __usercall sub_4ADC50@<eax>(int *@<eax>, int *@<ecx>);
HANDLE __cdecl sub_4ADD50(int);
_WORD *__cdecl sub_4ADF80(_DWORD **);
// int __usercall sub_4AE060@<eax>(_DWORD **@<eax>, HWND, int);
// BOOL __usercall sub_4AE0D0@<eax>(int@<edx>, HWND@<ecx>, _DWORD *@<edi>);
int __cdecl sub_4AE160(int, int);
// HRESULT __usercall sub_4AE530@<eax>(LPDATAOBJECT *@<edi>, void *, int, int, void *);
// HRESULT __usercall sub_4AE660@<eax>(LPDATAOBJECT *@<edi>, void *);
// HRESULT __usercall sub_4AE6E0@<eax>(LPDATAOBJECT *@<edi>, void *);
// BOOL __usercall sub_4AE760@<eax>(int@<edx>, _DWORD **@<ecx>, HWND, void **);
int __cdecl sub_4AE8C0(void *);
// _WORD *__usercall sub_4AFAF0@<eax>(_DWORD *@<eax>);
// HWND __usercall sub_4AFB50@<eax>(_DWORD *@<esi>);
// void __usercall sub_4AFBE0(int@<edi>);
void __thiscall sub_4B06D0(_DWORD *this);
// BOOL __userpurge sub_4B08A0@<eax>(HWND@<esi>, HWND *);
// BOOL __userpurge sub_4B09D0@<eax>(HWND@<esi>, HWND *);
// LRESULT __userpurge sub_4B0B40@<eax>(HWND@<esi>, int);
int __stdcall sub_4B0C50(HWND hDlg, int, __int16, int); // idb
// LRESULT __userpurge sub_4B0CE0@<eax>(HWND@<esi>, int);
int __stdcall sub_4B0E20(HWND hDlg, int, __int16, int); // idb
// void __usercall sub_4B0EB0(int@<esi>);
int __cdecl sub_4B0F60(int, int *, int *, _DWORD *);
DWORD __stdcall sub_4B1210(LPVOID lpThreadParameter); // idb
// BOOL __usercall sub_4B1280@<eax>(HWND@<edi>);
HWND __thiscall sub_4B13B0(HWND hDlg, int);
int __stdcall sub_4B1510(HWND hDlg, UINT, WPARAM, LPARAM); // idb
void __fastcall sub_4B1590(int nPos, HMENU hMenu, int);
int __fastcall sub_4B1640(DWORD, int *);
int __thiscall sub_4B21A0(int this, HWND, unsigned int);
int __fastcall sub_4B44F0(WPARAM wParam, unsigned int, int, int, UINT Msg);
int __stdcall sub_4B4E00(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
// int __userpurge sub_4B4EF0@<eax>(int@<eax>, int, int, WPARAM wParam, LPARAM lParam);
int __stdcall sub_4B5000(int, int, WPARAM wParam, LPARAM lParam, int, int); // idb
int sub_4B551A();
int sub_4BC810();
int sub_4BC870();
int sub_4BC8D0();
int __fastcall sub_4BC930(int);
int sub_4BC950();
int sub_4BC990();
int sub_4BC9D0();
int sub_4BCA30();
int sub_4BCA90();
int sub_4BCAF0();
int sub_4BCB4D();
int sub_4BCB59();
int sub_4BCB65();
int sub_4BCB71();
int sub_4BCB87();
int sub_4BCB93();
int sub_4BCB9F();
int sub_4BCBB5();
void __cdecl sub_4BCBD0(); // idb
void __cdecl sub_4BCBE0(); // idb
void __cdecl sub_4BCBF0(); // idb
void __cdecl sub_4BCC00(); // idb
void __cdecl sub_4BCC50(); // idb
void __cdecl sub_4BCCA0(); // idb
void __cdecl sub_4BCCD0(); // idb
void __cdecl sub_4BCCE0(); // idb
void __cdecl sub_4BCCF0(); // idb
void __cdecl sub_4BCD00(); // idb
void __cdecl sub_4BCD10(); // idb
void __cdecl sub_4BCD20(); // idb
void __cdecl sub_4BCD30(); // idb
void __cdecl sub_4BCD40(); // idb
void __cdecl sub_4BCD50(); // idb
void __cdecl sub_4BCD80(); // idb
void __cdecl sub_4BCDA0(); // idb
void __cdecl sub_4BCDB0(); // idb
void __cdecl sub_4BCDD0(); // idb
void __cdecl sub_4BCDF0(); // idb
void __cdecl sub_4BCE40(); // idb
void __cdecl sub_4BCE88(); // idb
void __cdecl sub_4BCE93(); // idb
void __cdecl sub_4BCE9E(); // idb
void __cdecl sub_4BCEA9(); // idb
void __cdecl sub_4BCEB3(); // idb
void __cdecl sub_4BCEBD(); // idb
void __cdecl sub_4BCEC7(); // idb
void __cdecl sub_4BCEDB(); // idb
void __cdecl sub_4BCEEF(); // idb
void __cdecl sub_4BCEF9(); // idb
void __cdecl sub_4BCF03(); // idb
// int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetPathGradientPointCount(_DWORD, _DWORD); weak
// int __stdcall GdipSetPathGradientSurroundColorsWithCount(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipSetPathGradientCenterColor(_DWORD, _DWORD); weak
// int __stdcall GdipSetPathGradientCenterPointI(_DWORD, _DWORD); weak
// int __stdcall GdipCreatePathGradientFromPath(_DWORD, _DWORD); weak
// int __stdcall GdipAddPathRectangleI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipDeletePath(_DWORD); weak
// int __stdcall GdipCreatePath(_DWORD, _DWORD); weak
// int __stdcall GdipDrawLineI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipDisposeImage(_DWORD); weak
// int __stdcall GdipCreatePen1(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipDeleteGraphics(_DWORD); weak
// int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipCloneBrush(_DWORD, _DWORD); weak
// int __stdcall GdipDeleteBrush(_DWORD); weak
// int __stdcall GdipCreateSolidFill(_DWORD, _DWORD); weak
// int __stdcall GdipDeletePen(_DWORD); weak
// int __stdcall GdiplusShutdown(_DWORD); weak
// int __stdcall GdipGetAllPropertyItems(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetPropertySize(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageHeight(_DWORD, _DWORD); weak
// int __stdcall GdipCreateHBITMAPFromBitmap(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageWidth(_DWORD, _DWORD); weak
// int __stdcall GdipGetImagePixelFormat(_DWORD, _DWORD); weak
// int __stdcall GdipGetImageHorizontalResolution(_DWORD, _DWORD); weak
// int __stdcall GdipFillRectangleI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageVerticalResolution(_DWORD, _DWORD); weak
// int __stdcall GdipCloneImage(_DWORD, _DWORD); weak
// int __stdcall GdipLoadImageFromFile(_DWORD, _DWORD); weak
// int __stdcall GdipFree(_DWORD); weak
// int __stdcall GdipAlloc(_DWORD); weak
// int __stdcall GdipCreateFromHDC(_DWORD, _DWORD); weak
// int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4B7C50; // weak
// extern BOOL (__stdcall *ConvertSidToStringSidW)(PSID Sid, LPWSTR *StringSid);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern BOOL (__stdcall *CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern BOOL (__stdcall *LookupAccountSidW)(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern DWORD (__stdcall *GetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *LookupPrivilegeValueW)(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern BOOL (__stdcall *ImageList_Draw)(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);
// extern BOOL (__stdcall *SetWindowSubclass)(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
// extern BOOL (__stdcall *RemoveWindowSubclass)(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass);
// extern LRESULT (__stdcall *DefSubclassProc)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *GetSaveFileNameW)(LPOPENFILENAMEW);
// extern BOOL (__stdcall *SetBrushOrgEx)(HDC hdc, int x, int y, LPPOINT lppt);
// extern BOOL (__stdcall *StretchBlt)(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *BitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern int (__stdcall *SetStretchBltMode)(HDC hdc, int mode);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern BOOL (__stdcall *GetBitmapDimensionEx)(HBITMAP hbit, LPSIZE lpsize);
// extern BOOL (__stdcall *GetTextExtentPoint32W)(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// extern HFONT (__stdcall *CreateFontIndirectW)(const LOGFONTW *lplf);
// extern HFONT (__stdcall *CreateFontW)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
// extern BOOL (__stdcall *TextOutW)(HDC hdc, int x, int y, LPCWSTR lpString, int c);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern HBRUSH (__stdcall *CreateSolidBrush)(COLORREF color);
// extern int (__stdcall *GetObjectW)(HANDLE h, int c, LPVOID pv);
// extern BOOL (__stdcall *SetBitmapDimensionEx)(HBITMAP hbm, int w, int h, LPSIZE lpsz);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern ULONG (__stdcall *GetAdaptersAddresses)(ULONG Family, ULONG Flags, PVOID Reserved, PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern DWORD (__stdcall *GetVersion)();
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern DWORD (__stdcall *GetLastError)();
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// extern DWORD (__stdcall *GetLogicalDriveStringsW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern LONG (__stdcall *InterlockedIncrement)(volatile LONG *lpAddend);
// extern LONG (__stdcall *InterlockedDecrement)(volatile LONG *lpAddend);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern DWORD (__stdcall *GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern BOOL (__stdcall *GetComputerNameW)(LPWSTR lpBuffer, LPDWORD nSize);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *GlobalMemoryStatusEx)(LPMEMORYSTATUSEX lpBuffer);
// extern BOOL (__stdcall *GetDiskFreeSpaceExW)(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// extern BOOL (__stdcall *GetVolumeInformationW)(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern DWORD (__stdcall *SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
// extern DWORD (__stdcall *QueueUserAPC)(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *SetCurrentDirectoryW)(LPCWSTR lpPathName);
// extern int (__stdcall *GetLocaleInfoW)(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD ProcessorFeature);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern LONG (__stdcall *CompareFileTime)(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern BOOL (__stdcall *CancelIo)(HANDLE hFile);
// extern BOOL (__stdcall *ReadDirectoryChangesW)(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern SIZE_T (__stdcall *GlobalSize)(HGLOBAL hMem);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *CreateHardLinkW)(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern BOOL (__stdcall *LocalFileTimeToFileTime)(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *CreateDirectoryW)(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern int (__stdcall *CompareStringW)(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *SetFileValidData)(HANDLE hFile, LONGLONG ValidDataLength);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *GetDiskFreeSpaceW)(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// extern LANGID (__stdcall *GetUserDefaultLangID)();
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *TzSpecificLocalTimeToSystemTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
// extern BOOL (__stdcall *SystemTimeToTzSpecificLocalTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern DWORD (__stdcall *WNetGetUniversalNameW)(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern UINT (__stdcall *ILGetSize)(LPCITEMIDLIST pidl);
// extern LPITEMIDLIST (__stdcall *SHBrowseForFolderW)(LPBROWSEINFOW lpbi);
// extern BOOL (__stdcall *ShellExecuteExW)(SHELLEXECUTEINFOW *pExecInfo);
// extern BOOL (__stdcall *ILIsParent)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
// extern ULONG (__stdcall *SHChangeNotifyRegister)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, const SHChangeNotifyEntry *pshcne);
// extern HRESULT (__stdcall *SHGetFolderLocation)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPITEMIDLIST *ppidl);
// extern HRESULT (__stdcall *SHBindToParent)(LPCITEMIDLIST pidl, const IID *const riid, void **ppv, LPCITEMIDLIST *ppidlLast);
// extern BOOL (__stdcall *ILRemoveLastID)(LPITEMIDLIST pidl);
// extern LPITEMIDLIST (__stdcall *ILClone)(LPCITEMIDLIST pidl);
// extern HRESULT (__stdcall *SHGetDesktopFolder)(IShellFolder **ppshf);
// extern HRESULT (__stdcall *SHGetImageList)(int iImageList, const IID *const riid, void **ppvObj);
// extern LPITEMIDLIST (__stdcall *ILCombine)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
// extern DWORD_PTR (__stdcall *SHGetFileInfoW)(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
// extern BOOL (__stdcall *Shell_GetImageLists)(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);
// extern LPITEMIDLIST (__stdcall *ILFindLastID)(LPCITEMIDLIST pidl);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern UINT (__stdcall *DragQueryFileW)(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
// extern BOOL (__stdcall *SHGetSpecialFolderPathW)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
// extern int (__stdcall *SHFileOperationW)(LPSHFILEOPSTRUCTW lpFileOp);
// extern BOOL (__stdcall *SHGetPathFromIDListW)(LPCITEMIDLIST pidl, LPWSTR pszPath);
// extern void (__stdcall *SHFreeNameMappings)(HANDLE hNameMappings);
// extern HRESULT (__stdcall *SHGetFolderPathW)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
// extern PWSTR (__stdcall *StrCatW)(PWSTR psz1, PCWSTR psz2);
// extern LPWSTR (__stdcall *PathRemoveBackslashW)(LPWSTR pszPath);
// extern void (__stdcall *PathStripPathW)(LPWSTR pszPath);
// extern void (__stdcall *PathRemoveExtensionW)(LPWSTR pszPath);
// extern BOOL (__stdcall *PathIsDirectoryW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathRenameExtensionW)(LPWSTR pszPath, LPCWSTR pszExt);
// extern HRESULT (__stdcall *SHStrDupW)(LPCWSTR psz, LPWSTR *ppwsz);
// extern BOOL (__stdcall *PathIsRelativeW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathIsURLW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathCanonicalizeW)(LPWSTR pszBuf, LPCWSTR pszPath);
// extern HRESULT (__stdcall *StrRetToBufW)(STRRET *pstr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf);
// extern HRESULT (__stdcall *SHAutoComplete)(HWND hwndEdit, DWORD dwFlags);
// extern BOOL (__stdcall *PathIsSameRootW)(LPCWSTR pszPath1, LPCWSTR pszPath2);
// extern int (__stdcall *StrCmpIW)(PCWSTR psz1, PCWSTR psz2);
// extern void (__stdcall *PathRemoveBlanksW)(LPWSTR pszPath);
// extern LSTATUS (__stdcall *SHDeleteKeyW)(HKEY hkey, LPCWSTR pszSubKey);
// extern BOOL (__stdcall *PathIsRootW)(LPCWSTR pszPath);
// extern int (__stdcall *StrCmpW)(PCWSTR psz1, PCWSTR psz2);
// extern BOOL (__stdcall *PathIsUNCW)(LPCWSTR pszPath);
// extern LPWSTR (__stdcall *PathCombineW)(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
// extern int (__stdcall *StrCmpLogicalW)(PCWSTR psz1, PCWSTR psz2);
// extern BOOL (__stdcall *PathRemoveFileSpecW)(LPWSTR pszPath);
// extern LPWSTR (__stdcall *PathFindExtensionW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathAppendW)(LPWSTR pszPath, LPCWSTR pszMore);
// extern PWSTR (__stdcall *StrChrW)(PCWSTR pszStart, WCHAR wMatch);
// extern BOOL (__stdcall *PathStripToRootW)(LPWSTR pszPath);
// extern UINT (__stdcall *RegisterWindowMessageW)(LPCWSTR lpString);
// extern BOOL (__stdcall *IsClipboardFormatAvailable)(UINT format);
// extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu);
// extern BOOL (__stdcall *AppendMenuW)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// extern HDEVNOTIFY (__stdcall *RegisterDeviceNotificationW)(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);
// extern BOOL (__stdcall *UnregisterDeviceNotification)(HDEVNOTIFY Handle);
// extern HBRUSH (__stdcall *GetSysColorBrush)(int nIndex);
// extern BOOL (__stdcall *SetRect)(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);
// extern BOOL (__stdcall *DrawIconEx)(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
// extern BOOL (__stdcall *PostMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *SetClipboardViewer)(HWND hWndNewViewer);
// extern BOOL (__stdcall *RedrawWindow)(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern BOOL (__stdcall *ChangeClipboardChain)(HWND hWndRemove, HWND hWndNewNext);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *GetCursorPos)(LPPOINT lpPoint);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *EndPaint)(HWND hWnd, const PAINTSTRUCT *lpPaint);
// extern HDC (__stdcall *BeginPaint)(HWND hWnd, LPPAINTSTRUCT lpPaint);
// extern BOOL (__stdcall *GetUpdateRect)(HWND hWnd, LPRECT lpRect, BOOL bErase);
// extern ATOM (__stdcall *RegisterClassW)(const WNDCLASSW *lpWndClass);
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *DrawEdge)(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);
// extern UINT (__stdcall *GetMenuState)(HMENU hMenu, UINT uId, UINT uFlags);
// extern BOOL (__stdcall *ClientToScreen)(HWND hWnd, LPPOINT lpPoint);
// extern int (__stdcall *FrameRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern BOOL (__stdcall *IntersectRect)(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern BOOL (__stdcall *SetMenuInfo)(HMENU, LPCMENUINFO);
// extern HMENU (__stdcall *CreatePopupMenu)();
// extern UINT (__stdcall *GetMenuItemID)(HMENU hMenu, int nPos);
// extern BOOL (__stdcall *GetWindowPlacement)(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern UINT_PTR (__stdcall *SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// extern BOOL (__stdcall *KillTimer)(HWND hWnd, UINT_PTR uIDEvent);
// extern HWND (__stdcall *CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern DWORD (__stdcall *GetSysColor)(int nIndex);
// extern DWORD (__stdcall *GetTabbedTextExtentW)(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions);
// extern int (__stdcall *GetMenuStringW)(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags);
// extern ATOM (__stdcall *RegisterClassExW)(const WNDCLASSEXW *);
// extern BOOL (__stdcall *CloseClipboard)();
// extern HANDLE (__stdcall *SetClipboardData)(UINT uFormat, HANDLE hMem);
// extern BOOL (__stdcall *EmptyClipboard)();
// extern BOOL (__stdcall *OpenClipboard)(HWND hWndNewOwner);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern HWND (__stdcall *CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern BOOL (__stdcall *IsIconic)(HWND hWnd);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern LRESULT (__stdcall *DefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LONG (__stdcall *SetWindowLongW)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern HCURSOR (__stdcall *LoadCursorW)(HINSTANCE hInstance, LPCWSTR lpCursorName);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *TrackPopupMenu)(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// extern HMENU (__stdcall *LoadMenuW)(HINSTANCE hInstance, LPCWSTR lpMenuName);
// extern BOOL (__stdcall *DestroyMenu)(HMENU hMenu);
// extern BOOL (__stdcall *SetForegroundWindow)(HWND hWnd);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern LRESULT (__stdcall *CallWindowProcW)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *PtInRect)(const RECT *lprc, POINT pt);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern BOOL (__stdcall *GetIconInfo)(HICON hIcon, PICONINFO piconinfo);
// extern DWORD (__stdcall *CheckMenuItem)(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
// extern BOOL (__stdcall *CheckMenuRadioItem)(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags);
// extern LONG (__stdcall *GetWindowLongW)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *GetFocus)();
// extern UINT (__stdcall *GetDlgItemInt)(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned);
// extern BOOL (__stdcall *SetDlgItemInt)(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);
// extern HICON (__stdcall *LoadIconW)(HINSTANCE hInstance, LPCWSTR lpIconName);
// extern DWORD (__stdcall *SetClassLongW)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern int (__stdcall *FillRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *InvalidateRect)(HWND hWnd, const RECT *lpRect, BOOL bErase);
// extern BOOL (__stdcall *InsertMenuW)(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// extern HMENU (__stdcall *CreateMenu)();
// extern int (__stdcall *GetMenuItemCount)(HMENU hMenu);
// extern DWORD (__stdcall *GetMessagePos)();
// extern BOOL (__stdcall *SetMenuItemInfoW)(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii);
// extern HMENU (__stdcall *GetSubMenu)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern BOOL (__stdcall *DeleteMenu)(HMENU hMenu, UINT uPosition, UINT uFlags);
// extern BOOL (__stdcall *GetMenuItemInfoW)(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii);
// extern BOOL (__stdcall *InsertMenuItemW)(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi);
// extern int (__stdcall *GetWindowTextW)(HWND hWnd, LPWSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *CheckDlgButton)(HWND hDlg, int nIDButton, UINT uCheck);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *ScreenToClient)(HWND hWnd, LPPOINT lpPoint);
// extern BOOL (__stdcall *InflateRect)(LPRECT lprc, int dx, int dy);
// extern int (__stdcall *MapWindowPoints)(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
// extern BOOL (__stdcall *OffsetRect)(LPRECT lprc, int dx, int dy);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern INT_PTR (__stdcall *DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern UINT (__stdcall *IsDlgButtonChecked)(HWND hDlg, int nIDButton);
// extern int (__stdcall *GetWindowTextLengthW)(HWND hWnd);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern BOOL (__stdcall *SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
// extern BOOL (__stdcall *DestroyIcon)(HICON hIcon);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern BOOL (__stdcall *SetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// extern UINT (__stdcall *GetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
// extern int (__stdcall *LoadStringW)(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// extern LRESULT (__stdcall *SendDlgItemMessageW)(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HBITMAP (__stdcall *LoadBitmapW)(HINSTANCE hInstance, LPCWSTR lpBitmapName);
// extern LRESULT (__stdcall *SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *LoadImageW)(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
// extern BOOL (__stdcall *PrintWindow)(HWND hwnd, HDC hdcBlt, UINT nFlags);
// extern BOOL (__stdcall *GetMenuBarInfo)(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi);
// extern DWORD (__stdcall *GetClassLongW)(HWND hWnd, int nIndex);
// extern BOOL (__stdcall *UnregisterClassW)(LPCWSTR lpClassName, HINSTANCE hInstance);
// extern BOOL (__stdcall *ReleaseCapture)();
// extern HWND (__stdcall *SetCapture)(HWND hWnd);
// extern HWND (__stdcall *GetCapture)();
// extern HWND (__stdcall *WindowFromPoint)(POINT Point);
// extern HWND (__stdcall *FindWindowExW)(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);
// extern HICON (__stdcall *CopyIcon)(HICON hIcon);
// extern UINT (__stdcall *RegisterClipboardFormatW)(LPCWSTR lpszFormat);
// extern HWND (__stdcall *FindWindowW)(LPCWSTR lpClassName, LPCWSTR lpWindowName);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *SetWindowPlacement)(HWND hWnd, const WINDOWPLACEMENT *lpwndpl);
// extern HACCEL (__stdcall *LoadAcceleratorsW)(HINSTANCE hInstance, LPCWSTR lpTableName);
// extern BOOL (__stdcall *GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern LRESULT (__stdcall *DispatchMessageW)(const MSG *lpMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern int (__stdcall *TranslateAcceleratorW)(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern BOOL (__stdcall *IsDialogMessageW)(HWND hDlg, LPMSG lpMsg);
// extern BOOL (__stdcall *ExpandEnvironmentStringsForUserW)(HANDLE hToken, LPCWSTR lpSrc, LPWSTR lpDest, DWORD dwSize);
// extern HRESULT (__stdcall *SetWindowTheme)(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList);
// extern BOOL (__stdcall *GetFileVersionInfoW)(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
// extern BOOL (__stdcall *VerQueryValueW)(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
// extern DWORD (__stdcall *GetFileVersionInfoSizeW)(LPCWSTR lptstrFilename, LPDWORD lpdwHandle);
// extern BOOL (__stdcall *PlaySoundW)(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
// extern BOOL (__stdcall *OpenPrinterW)(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);
// extern BOOL (__stdcall *GetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);
// extern BOOL (__stdcall *ClosePrinter)(HANDLE hPrinter);
// extern void (__stdcall *OleUninitialize)();
// extern HRESULT (__stdcall *OleInitialize)(LPVOID pvReserved);
// extern HRESULT (__stdcall *CreateStreamOnHGlobal)(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
// extern LPVOID (__stdcall *CoTaskMemAlloc)(SIZE_T cb);
// extern HRESULT (__stdcall *RevokeDragDrop)(HWND hwnd);
// extern HRESULT (__stdcall *OleFlushClipboard)();
// extern HRESULT (__stdcall *OleIsCurrentClipboard)(LPDATAOBJECT pDataObj);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
// extern HRESULT (__stdcall *OleGetClipboard)(LPDATAOBJECT *ppDataObj);
// extern HRESULT (__stdcall *DoDragDrop)(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect);
// extern HRESULT (__stdcall *CLSIDFromString)(LPCOLESTR lpsz, LPCLSID pclsid);
// extern HRESULT (__stdcall *OleSetClipboard)(LPDATAOBJECT pDataObj);
// extern HANDLE (__stdcall *OleDuplicateData)(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags);
// extern HRESULT (__stdcall *StgCreateStorageEx)(const WCHAR *pwcsName, DWORD grfMode, DWORD stgfmt, DWORD grfAttrs, STGOPTIONS *pStgOptions, PSECURITY_DESCRIPTOR pSecurityDescriptor, const IID *const riid, void **ppObjectOpen);
// extern void (__stdcall *CoTaskMemFree)(LPVOID pv);
// extern HRESULT (__stdcall *RegisterDragDrop)(HWND hwnd, LPDROPTARGET pDropTarget);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern void (__stdcall *ReleaseStgMedium)(LPSTGMEDIUM);
_DWORD dword_4BD7CC[4] = { 136418, 0, 192, 1174405120 }; // weak
_DWORD dword_4BD7DC[4] = { 136419, 0, 192, 1174405120 }; // weak
_UNKNOWN unk_4BD7EC; // weak
const IID stru_4BD7FC = { 136422u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_4BD80C; // weak
_UNKNOWN unk_4BD81C; // weak
const IID stru_4BD82C = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_4BD83C; // weak
_DWORD dword_4BD84C[4] = { -1998348672, 298792312, 551342, 1645358635 }; // weak
_UNKNOWN unk_4BD85C; // weak
const IID rclsid = { 1180116874u, 16667u, 4562u, { 131u, 154u, 0u, 192u, 79u, 217u, 24u, 208u } }; // idb
_DWORD dword_4BD87C[4] = { -840489552, 1159318729, 1563590289, -827000206 }; // weak
_UNKNOWN unk_4BD88C; // weak
const IID riid = { 3730569094u, 18298u, 4562u, { 131u, 157u, 0u, 192u, 79u, 217u, 24u, 208u } }; // idb
_UNKNOWN unk_4BD8AC; // weak
const IID stru_4BD8BC = { 3292383128u, 38353u, 19434u, { 144u, 48u, 187u, 153u, 226u, 152u, 58u, 26u } }; // idb
_DWORD dword_4BD8CC[4] = { -592412708, 1159478197, 1721155216, -1328021948 }; // weak
const IID stru_4BD8DC = { 1664278207u, 34741u, 18032u, { 144u, 192u, 94u, 87u, 180u, 8u, 164u, 158u } }; // idb
const IID stru_4BD8EC = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID stru_4BD8FC = { 1459483460u, 64877u, 4560u, { 149u, 138u, 0u, 96u, 151u, 201u, 160u, 144u } }; // idb
const IID stru_4BD90C = { 2012286192u, 15797u, 18790u, { 181u, 32u, 183u, 197u, 79u, 211u, 94u, 214u } }; // idb
const IID stru_4BD91C = { 758409409u, 13991u, 17334u, { 172u, 36u, 211u, 240u, 47u, 217u, 96u, 122u } }; // idb
_DWORD dword_4BD92C[4] = { 1834041537, 298742838, -1442827136, -100048896 }; // weak
_DWORD dword_4BD93C[4] = { 289, 0, 192, 1174405120 }; // weak
_UNKNOWN unk_4BD94C; // weak
const IID stru_4BD95C = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID stru_4BD96C = { 1189828902u, 22574u, 16407u, { 159u, 223u, 232u, 153u, 141u, 170u, 9u, 80u } }; // idb
_UNKNOWN unk_4BD97C; // weak
const IID stru_4BD98C = { 1446162852u, 58250u, 16394u, { 146u, 138u, 212u, 205u, 99u, 35u, 2u, 149u } }; // idb
_UNKNOWN unk_4BD99C; // weak
_DWORD dword_4BD9AC[4] = { 1032521104, 299038353, 1610656142, -732176489 }; // weak
_UNKNOWN unk_4BD9BC; // weak
const IID stru_4BD9CC = { 11u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_4BD9DC; // weak
_DWORD dword_4BD9EC[4] = { 259, 0, 192, 1174405120 }; // weak
_DWORD dword_4BD9FC[4] = { 270, 0, 192, 1174405120 }; // weak
void *std::logic_error::`vftable' = &sub_408CE0; // weak
void *std::length_error::`vftable' = &sub_408CE0; // weak
void *std::out_of_range::`vftable' = &sub_427C71; // weak
void *std::runtime_error::`vftable' = &sub_408CE0; // weak
void *std::error_category::`vftable' = &sub_426C6D; // weak
void *std::bad_alloc::`vftable' = &sub_401C30; // weak
void *std::locale::facet::`vftable' = &sub_403810; // weak
void *std::locale::_Locimp::`vftable' = &sub_419470; // weak
void *std::tr1::regex_error::`vftable' = &sub_427C71; // weak
void *std::ctype<char>::`vftable' = &sub_427FE7; // weak
void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_42C0AE; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_42C0AE; // weak
void *std::numpunct<char>::`vftable' = &sub_428600; // weak
void *std::codecvt<wchar_t,char,int>::`vftable' = &sub_42C0AE; // weak
void *std::codecvt<unsigned short,char,int>::`vftable' = &sub_42C0AE; // weak
void *std::ctype<wchar_t>::`vftable' = &sub_408360; // weak
void *std::ctype<unsigned short>::`vftable' = &std::ctype<wchar_t>::`scalar deleting destructor'; // weak
void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_421F30; // weak
void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_403810; // weak
void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_403810; // weak
void *std::collate<wchar_t>::`vftable' = &sub_403810; // weak
void *std::messages<wchar_t>::`vftable' = &sub_42C0AE; // weak
void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_42C0AE; // weak
void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_42C0AE; // weak
void *std::_Mpunct<wchar_t>::`vftable' = &sub_42DB8D; // weak
void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_42C0AE; // weak
void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_42C0AE; // weak
void *std::collate<unsigned short>::`vftable' = &sub_42C0AE; // weak
void *std::messages<unsigned short>::`vftable' = &sub_42C0AE; // weak
void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_42C0AE; // weak
void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_42C0AE; // weak
void *std::_Mpunct<unsigned short>::`vftable' = &sub_42DD33; // weak
void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_42C144; // weak
void *std::numpunct<wchar_t>::`vftable' = &sub_405310; // weak
void *std::numpunct<unsigned short>::`vftable' = &sub_42CCB9; // weak
void *std::moneypunct<wchar_t,0>::`vftable' = &sub_42DB8D; // weak
void *std::moneypunct<wchar_t,1>::`vftable' = &sub_42DB8D; // weak
void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_42DC84; // weak
void *std::moneypunct<unsigned short,0>::`vftable' = &sub_42DD33; // weak
void *std::moneypunct<unsigned short,1>::`vftable' = &sub_42DD33; // weak
void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_42DEC3; // weak
void *std::collate<char>::`vftable' = &sub_42C0AE; // weak
void *std::messages<char>::`vftable' = &sub_42C0AE; // weak
void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_42C0AE; // weak
void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_42C0AE; // weak
void *std::_Mpunct<char>::`vftable' = &sub_436AFB; // weak
void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_436436; // weak
void *std::moneypunct<char,0>::`vftable' = &sub_436AFB; // weak
void *std::moneypunct<char,1>::`vftable' = &sub_436AFB; // weak
void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_436C87; // weak
void *type_info::`vftable' = &sub_4395AD; // weak
void *std::exception::`vftable' = &sub_439901; // weak
void *std::bad_cast::`vftable' = &sub_439901; // weak
void *std::bad_exception::`vftable' = &sub_43E092; // weak
int (__thiscall *off_4C1054)(void *, char) = &sub_44E0B0; // weak
_UNKNOWN unk_4C1058; // weak
_UNKNOWN unk_4C11EE; // weak
_UNKNOWN unk_4C11EF; // weak
_UNKNOWN unk_4C1504; // weak
_UNKNOWN unk_4C1508; // weak
_UNKNOWN unk_4C150C; // weak
_UNKNOWN unk_4C1510; // weak
_UNKNOWN unk_4C1514; // weak
_UNKNOWN unk_4C1518; // weak
_UNKNOWN unk_4C1520; // weak
_UNKNOWN unk_4C1524; // weak
_UNKNOWN unk_4C1528; // weak
_UNKNOWN unk_4C1534; // weak
_UNKNOWN unk_4C1538; // weak
_UNKNOWN unk_4C153C; // weak
_UNKNOWN unk_4C1540; // weak
_UNKNOWN unk_4C1598; // weak
_UNKNOWN unk_4C15A8; // weak
void *off_4C1610 = &unk_4D0057; // weak
void *off_4C162C = &unk_4D0057; // weak
void *off_4C1640 = &unk_4D0057; // weak
void *off_4C1650 = &unk_4D0057; // weak
void *off_4C1668 = &unk_4D0057; // weak
void *off_4C1688 = &unk_4D0057; // weak
void *off_4C169C = &unk_4D0057; // weak
void *off_4C16B8 = &unk_4D0057; // weak
void *off_4C16D0 = &unk_4D0057; // weak
void *off_4C16E8 = &unk_4D0057; // weak
void *off_4C16FC = &unk_4D0057; // weak
void *off_4C1718 = &unk_4D0057; // weak
void *off_4C1730 = &unk_4D0057; // weak
void *off_4C1754 = &unk_4D0057; // weak
void *off_4C1778 = &unk_4D0057; // weak
void *off_4C1788 = &unk_4D0057; // weak
void *off_4C17B8 = &unk_4D0057; // weak
void *off_4C17E0 = &unk_4D0057; // weak
void *off_4C1810 = &unk_4D0057; // weak
int dword_4C1854 = 1; // weak
int dword_4C1868 = 1; // weak
int dword_4C18D4 = 1; // weak
int dword_4C18DC = 1; // weak
int dword_4C18F4 = 1; // weak
int dword_4C190C = 1; // weak
_UNKNOWN unk_4C2094; // weak
_UNKNOWN unk_4C20D8; // weak
_UNKNOWN unk_4C20DC; // weak
const WCHAR Data = 0u; // idb
_UNKNOWN unk_4C2A8C; // weak
_UNKNOWN unk_4C2D50; // weak
_UNKNOWN unk_4C2E38; // weak
_UNKNOWN unk_4C2E74; // weak
const WCHAR word_4C3054 = 0u; // idb
const WCHAR word_4C3074 = 0u; // idb
const WCHAR word_4C3094 = 0u; // idb
const WCHAR word_4C30C0 = 0u; // idb
const WCHAR word_4C30E4 = 0u; // idb
const WCHAR WindowName = 0u; // idb
_UNKNOWN unk_4C31A8; // weak
_UNKNOWN unk_4C32C0; // weak
_UNKNOWN unk_4C3334; // weak
_UNKNOWN unk_4C33A0; // weak
const OLECHAR word_4C4908 = 0u; // idb
int dword_4C60E8[20] =
{
  45002,
  45003,
  45004,
  45005,
  45006,
  45007,
  45008,
  45009,
  45010,
  45011,
  45012,
  45013,
  45014,
  45015,
  45017,
  45018,
  45019,
  45020,
  45021,
  45022
}; // weak
const WCHAR word_4C615C = 0u; // idb
_UNKNOWN unk_4C61D4; // weak
const WCHAR word_4C6298 = 0u; // idb
_UNKNOWN unk_4C629C; // weak
_UNKNOWN unk_4C6358; // weak
const WCHAR word_4C6388 = 0u; // idb
_UNKNOWN unk_4C63BC; // weak
const WCHAR word_4C6450 = 0u; // idb
const WCHAR word_4C6C68 = 0u; // idb
const WCHAR word_4C6F6C = 0u; // idb
const WCHAR word_4C6F80 = 0u; // idb
_UNKNOWN unk_4C6F84; // weak
const WCHAR word_4C9048 = 0u; // idb
int dword_4C9F88[] = { 1 }; // weak
wchar_t aBytes_0[6] = L"Bytes"; // weak
_UNKNOWN unk_4CA4A0; // weak
WCHAR word_4CA564[2] = { 0u, 0u }; // weak
WCHAR word_4CA5BC[2] = { 0u, 0u }; // weak
WCHAR word_4CA5F8[2] = { 0u, 0u }; // weak
_UNKNOWN unk_4CA5FC; // weak
_UNKNOWN unk_4CA6B8; // weak
_UNKNOWN unk_4CA6BC; // weak
_UNKNOWN unk_4CA6D8; // weak
_UNKNOWN unk_4CA6DC; // weak
_UNKNOWN unk_4CA7D8; // weak
_UNKNOWN unk_4CA830; // weak
_UNKNOWN unk_4CA834; // weak
_UNKNOWN unk_4CA838; // weak
_UNKNOWN unk_4CA998; // weak
_UNKNOWN unk_4CAA7C; // weak
_UNKNOWN unk_4CAC54; // weak
_UNKNOWN unk_4CB068; // weak
WCHAR word_4CB07C[2] = { 0u, 0u }; // weak
WCHAR word_4CB080[2] = { 0u, 0u }; // weak
const WCHAR word_4CB0B0 = 0u; // idb
_UNKNOWN unk_4CB0C8; // weak
_UNKNOWN unk_4CB0CC; // weak
_UNKNOWN unk_4CB0F8; // weak
_UNKNOWN unk_4CB540; // weak
_UNKNOWN unk_4CB5CC; // weak
void *CAboutDialog::`vftable' = &sub_4AA770; // weak
int (__stdcall *off_4CB834)(int) = &sub_401850; // weak
int (__stdcall *off_4CB878)(int) = &sub_401690; // weak
void *Explorerplusplus::CApplicationToolbarDrop::`vftable' = &sub_4A9360; // weak
int (__stdcall *off_4CB8E8)(int) = &sub_401690; // weak
void *Explorerplusplus::CBookmarkToolbarDrop::`vftable' = &sub_4A5FB0; // weak
char byte_4CB954[] = { '0' }; // weak
const char byte_4CB965[3] = { '\0', '\0', '\0' }; // idb
void *std::wstringbuf::`vftable' = &sub_402710; // weak
void *std::wistringstream::`vftable' = &sub_4026E0; // weak
_UNKNOWN unk_4CB9B0; // weak
void *CColorRuleDialog::`vftable' = &sub_4A5620; // weak
void *CColorRuleDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *std::ios_base::`vftable' = &sub_408FC0; // weak
void *std::wios::`vftable' = &sub_408FC0; // weak
void *std::wstreambuf::`vftable' = &sub_407EA0; // weak
void *std::wistream::`vftable' = &sub_408200; // weak
void *std::system_error::`vftable' = &sub_408CE0; // weak
void *std::ios_base::failure::`vftable' = &sub_408CE0; // weak
void *CCustomizeColorsDialog::`vftable' = &sub_4A4D50; // weak
void *CCustomizeColorsDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CDestroyFilesDialog::`vftable' = &sub_4A3B90; // weak
void *CDestroyFilesDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *Explorerplusplus::`vftable' = &sub_4A0BC0; // weak
void *Explorerplusplus::`vftable' = &sub_40A8F0; // weak
void *Explorerplusplus::`vftable' = &sub_40A900; // weak
void *Explorerplusplus::`vftable' = &sub_40A910; // weak
void *Explorerplusplus::`vftable' = &sub_49B6A0; // weak
void *Explorerplusplus::`vftable' = &sub_47DF70; // weak
void *Explorerplusplus::`vftable' = &sub_48E940; // weak
void *Explorerplusplus::`vftable' = &sub_48E930; // weak
void *Explorerplusplus::CLoadSaveRegistry::`vftable' = &sub_4A05C0; // weak
void *CFilterDialog::`vftable' = &sub_49FE50; // weak
void *CFilterDialogPersistentSettings::`vftable' = &sub_40AA90; // weak
void *CHelpFileMissingDialog::`vftable' = &sub_49F9C0; // weak
void *CDropSource::`vftable' = &sub_49F8D0; // weak
wchar_t *off_4CBE08 = L"alnum"; // weak
int dword_4CBE0C[] = { 5 }; // weak
__int16 word_4CBE10[] = { 263 }; // weak
_BYTE byte_4CBEC8[4] = { 108, 100, 0, 0 }; // weak
_BYTE byte_4CBECC[4] = { 108, 117, 0, 0 }; // weak
_BYTE byte_4CBED0[4] = { 76, 100, 0, 0 }; // weak
_BYTE byte_4CBED4[4] = { 76, 117, 0, 0 }; // weak
void *std::wiostream::`vftable' = &sub_40C090; // weak
void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable' = &sub_40C050; // weak
_UNKNOWN unk_4CBF50; // weak
void *std::tr1::_Node_base::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Root_node::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_end_group::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_assert::`vftable' = &sub_40B9F0; // weak
void *std::tr1::_Node_capture::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_back::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_endif::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_if::`vftable' = &sub_40BB00; // weak
void *std::tr1::_Node_end_rep::`vftable' = &sub_40BA20; // weak
void *std::tr1::_Node_rep::`vftable' = &sub_40BA20; // weak
void *CMassRenameDialog::`vftable' = &sub_499100; // weak
void *CMassRenameDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable' = &sub_40F100; // weak
void *std::tr1::_Node_str<wchar_t>::`vftable' = &sub_411F80; // weak
void *std::wostream::`vftable' = &sub_4134A0; // weak
void *CMergeFilesDialog::`vftable' = &sub_4983A0; // weak
void *CMergeFilesDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CMergeFiles::`vftable' = &sub_4135E0; // weak
void *Gdiplus::Image::`vftable' = &sub_4183D0; // weak
void *CRenameTabDialog::`vftable' = &sub_485750; // weak
void *CRenameTabDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CSearchDialog::`vftable' = &sub_482CE0; // weak
void *CSearchDialog::`vftable' = &sub_482890; // weak
void *CSearchDialogPersistentSettings::`vftable' = &sub_4167F0; // weak
void *CSearch::`vftable' = &sub_416770; // weak
void *CSelectColumnsDialog::`vftable' = &sub_480FA0; // weak
void *CSelectColumnsDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CSetDefaultColumnsDialog::`vftable' = &sub_47FF30; // weak
void *CSetDefaultColumnsDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CSetFileAttributesDialog::`vftable' = &sub_47F1A0; // weak
void *CSetFileAttributesDialogPersistentSettings::`vftable' = &sub_413610; // weak
void *CSplitFileDialog::`vftable' = &sub_47D5E0; // weak
void *CSplitFileDialogPersistentSettings::`vftable' = &sub_417F70; // weak
void *CSplitFile::`vftable' = &sub_417F40; // weak
_UNKNOWN unk_4CC2B8; // weak
void *Gdiplus::Bitmap::`vftable' = &sub_4183D0; // weak
void *CWildcardSelectDialog::`vftable' = &sub_476D00; // weak
void *CWildcardSelectDialogPersistentSettings::`vftable' = &sub_418500; // weak
void *Explorerplusplus::CLoadSaveXML::`vftable' = &sub_46CC30; // weak
void *CBaseDialog::`vftable' = &sub_46B950; // weak
void *CDialogSettings::`vftable' = &sub_413610; // weak
const IID stru_4CC3E4 = { 691257217u, 31542u, 4562u, { 178u, 14u, 0u, 192u, 79u, 152u, 62u, 96u } }; // idb
const IID stru_4CC3F4 = { 4110913330u, 50513u, 4563u, { 137u, 185u, 0u, 0u, 248u, 31u, 226u, 33u } }; // idb
void *Gdiplus::Brush::`vftable' = &sub_41BCF0; // weak
void *CDataObject::`vftable' = &sub_461E10; // weak
void *CDataObject::`vftable' = &sub_41A400; // weak
void *CDropHandler::`vftable' = &sub_41A420; // weak
void *CReferenceCount::`vftable' = &sub_41A420; // weak
void *CDirectoryMonitor::`vftable' = &sub_45F280; // weak
void *CEnumFormatEtc::`vftable' = &sub_45E700; // weak
void *CDisplayWindow::`vftable' = &sub_41A5A0; // weak
const WCHAR word_4CC4F8 = 0u; // idb
void *Gdiplus::PathGradientBrush::`vftable' = &sub_41BCF0; // weak
void *CMyTreeView::`vftable' = &sub_41E8B0; // weak
void *CMyTreeView::`vftable' = &sub_41F260; // weak
void *CFolderView::`vftable' = &sub_45CE50; // weak
void *CFolderView::`vftable' = &sub_420A10; // weak
void *CFolderView::`vftable' = &sub_420970; // weak
void *CFolderView::`vftable' = &sub_420990; // weak
void *CFolderView::`vftable' = &sub_4209A0; // weak
void *CFolderView::`vftable' = &sub_44ED10; // weak
void *CPathManager::`vftable' = &sub_45C7B0; // weak
_UNKNOWN unk_4CC9BE; // weak
wchar_t aT[3] = L"%T"; // weak
wchar_t aHMS[9] = L"%H:%M:%S"; // weak
wchar_t aR[3] = L"%R"; // weak
wchar_t aHM[6] = L"%H:%M"; // weak
void *std::wostringstream::`vftable' = &sub_423360; // weak
_UNKNOWN unk_4CCA3C; // weak
void *boost::date_time::date_facet<boost::gregorian::date,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_421E30; // weak
void *boost::date_time::time_facet<boost::posix_time::ptime,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_4210A0; // weak
_UNKNOWN unk_4D4138; // weak
const _ThrowInfo _TI1_AV_com_error__ = { 0u, &sub_44E000, NULL, &_CTA1_AV_com_error__ }; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &sub_401C00, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &sub_408C70, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI4_AVfailure_ios_base_std__ = { 0u, &sub_408C70, NULL, &_CTA4_AVfailure_ios_base_std__ }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, &sub_4398D8, NULL, &_CTA2_AVbad_cast_std__ }; // idb
const _ThrowInfo _TI2_AVlogic_error_std__ = { 0u, &sub_408C70, NULL, &_CTA2_AVlogic_error_std__ }; // idb
int (__thiscall *off_4DE0C8)(void *, char) = &off_4BDA70; // weak
int (__thiscall *off_4DE0D0)(void *, char) = &off_4BDAA4; // weak
int (__thiscall *off_4DE0D8)(void *, char) = &off_4BDAC8; // weak
LONG Addend = -1; // idb
int dword_4DF530 = 28800; // weak
int dword_4DF534 = 1; // weak
int dword_4DF538 = -3600; // weak
void *off_4DF5C0 = &unk_4DF540; // weak
char *off_4DF5E0[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_4DF690; // weak
void *off_4DF7F8 = &unk_4F24C0; // weak
int dword_4DFB00 = 1024; // weak
int dword_4DFB04 = -1023; // weak
int dword_4DFB08 = 53; // weak
int dword_4DFB0C = 11; // weak
int dword_4DFB10 = 64; // weak
int dword_4DFB14 = 1023; // weak
int dword_4DFB18 = 128; // weak
int dword_4DFB1C = -127; // weak
int dword_4DFB20 = 24; // weak
int dword_4DFB24 = 8; // weak
int dword_4DFB28 = 32; // weak
int dword_4DFB2C = 127; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFE; // idb
int (__cdecl *off_4DFDF0)(_DWORD, _DWORD) = &sub_44E030; // weak
int dword_4DFE4C = 1; // weak
_UNKNOWN unk_4DFE5C; // weak
int dword_4DFE68 = -1; // weak
_UNKNOWN unk_4DFE70; // weak
_UNKNOWN unk_4DFE84; // weak
_UNKNOWN unk_4DFE98; // weak
WCHAR aName_2[] = L"Name"; // idb
int dword_4E0358[] = { 1 }; // weak
DWORD dword_4E1C98 = 1451230793u; // idb
DWORD dwStyle = 1442889728u; // idb
int dword_4E5A60[] = { 1 }; // weak
int dword_4E5A64[] = { 1 }; // weak
int dword_4E5A68[] = { 150 }; // weak
int dword_4E5CC4[] = { 1 }; // weak
int dword_4E5CC8[] = { 1 }; // weak
DWORD dword_4E5CDC = 1174405376u; // idb
int dword_4E5CE0[] = { 1 }; // weak
int dword_4E5CE4[] = { 1 }; // weak
int dword_4E5D28[] = { 1 }; // weak
int dword_4E5D2C[] = { 1 }; // weak
int dword_4E5D70[] = { 1 }; // weak
int dword_4E5D74[] = { 1 }; // weak
int dword_4E5DB8[] = { 1 }; // weak
int dword_4E5DBC[] = { 1 }; // weak
int dword_4E5DE8[] = { 1 }; // weak
int dword_4E5DEC[] = { 1 }; // weak
int dword_4E5E80[] = { 1 }; // weak
int dword_4E5E84[] = { 1 }; // weak
int dword_4E60E4[] = { 1 }; // weak
int dword_4E60E8[] = { 1 }; // weak
int dword_4E6110[] = { 1 }; // weak
int dword_4E6114[] = { 1 }; // weak
int dword_4E6158[] = { 1 }; // weak
int dword_4E615C[] = { 1 }; // weak
int dword_4E61A0[] = { 1 }; // weak
int dword_4E61A4[] = { 1 }; // weak
int dword_4E61E8[] = { 1 }; // weak
int dword_4E61EC[] = { 1 }; // weak
int dword_4E6218[] = { 1 }; // weak
int dword_4E621C[] = { 1 }; // weak
_UNKNOWN unk_4E715C; // weak
_UNKNOWN unk_4E76A8; // weak
_UNKNOWN unk_4E76C0; // weak
_UNKNOWN unk_4E76C8; // weak
_UNKNOWN unk_4E76E0; // weak
_UNKNOWN unk_4E76F0; // weak
_UNKNOWN unk_4E76F8; // weak
int dword_4EB2DC = 10000; // weak
int dword_4ECD00 = -1; // weak
int dword_4EDBB4 = 2; // weak
wchar_t *off_4EDBDC[10] =
{
  L"bmp",
  L"ico",
  L"gif",
  L"jpg",
  L"exf",
  L"png",
  L"tif",
  L"wmf",
  L"emf",
  L"tiff"
}; // weak
OLECHAR aYes_0[] = L"yes"; // idb
wchar_t aNo_0[3] = L"no"; // weak
void *off_4EE024 = &asc_4CC8C0; // idb
wchar_t *off_4EE028[6] = { L"%f", L"%F", L"%s", L"%H", L"%O", L"%+" }; // weak
wchar_t *off_4EE02C[5] = { L"%F", L"%s", L"%H", L"%O", L"%+" }; // weak
wchar_t *off_4EE030[4] = { L"%s", L"%H", L"%O", L"%+" }; // weak
wchar_t *off_4EE034[3] = { L"%H", L"%O", L"%+" }; // weak
wchar_t *off_4EE038[2] = { L"%O", L"%+" }; // weak
wchar_t *off_4EE03C = L"%+"; // weak
void *off_4EE040 = &unk_4CC7EC; // weak
void *off_4EE044 = &unk_4CC7E8; // weak
struct _RTL_CRITICAL_SECTION stru_4EE098 = { NULL, 0, 0, NULL, NULL, 0u }; // idb
_UNKNOWN unk_4EE0F8; // weak
int dword_4EE100 = 0; // weak
int dword_4EE108 = 0; // weak
_UNKNOWN unk_4EE10C; // weak
_UNKNOWN unk_4EE110; // weak
int dword_4EE114 = 0; // weak
_UNKNOWN unk_4EE118; // weak
int dword_4EE11C = 0; // weak
_UNKNOWN unk_4EE120; // weak
_UNKNOWN unk_4EE124; // weak
_DWORD dword_4EE220[3]; // weak
int dword_4EE230; // weak
int dword_4EE234; // weak
int dword_4EE238; // weak
int dword_4EE23C; // weak
int dword_4EE240; // weak
_DWORD dword_4EE248[3]; // weak
_UNKNOWN unk_4EE254; // weak
_UNKNOWN unk_4EE2A0; // weak
_UNKNOWN unk_4EE2A1; // weak
int dword_4EE2A4; // weak
int dword_4EE2A8; // weak
int dword_4EE2AC; // weak
int dword_4EE2B0; // weak
int dword_4EE2B4; // weak
int dword_4EE2B8; // weak
int dword_4EE2BC; // weak
int dword_4EE2C0; // weak
int dword_4EE2C4; // weak
int dword_4EE2C8; // weak
int dword_4EE2CC; // weak
int dword_4EE2D0; // weak
int dword_4EE2D4; // weak
int dword_4EE2D8; // weak
int dword_4EE2DC; // weak
int dword_4EE2E0; // weak
int dword_4EE2E4; // weak
int dword_4EE2E8; // weak
int dword_4EE2EC; // weak
int dword_4EE2F0; // weak
_UNKNOWN unk_4EE2F4; // weak
_UNKNOWN unk_4EE2F8; // weak
_UNKNOWN unk_4EE2FC; // weak
_UNKNOWN unk_4EE300; // weak
_UNKNOWN unk_4EE304; // weak
_UNKNOWN unk_4EE308; // weak
_UNKNOWN unk_4EE30C; // weak
_UNKNOWN unk_4EE310; // weak
_UNKNOWN unk_4EE314; // weak
_UNKNOWN unk_4EE318; // weak
_UNKNOWN unk_4EE31C; // weak
_UNKNOWN unk_4EE320; // weak
_UNKNOWN unk_4EE324; // weak
_UNKNOWN unk_4EE328; // weak
_UNKNOWN unk_4EE32C; // weak
_UNKNOWN unk_4EE330; // weak
_UNKNOWN unk_4EE334; // weak
int dword_4EE338; // weak
int dword_4EE33C; // weak
int dword_4EE340; // weak
int dword_4EE344; // weak
int dword_4EE348; // weak
int dword_4EE34C; // weak
int dword_4EE350; // weak
int dword_4EE354; // weak
_UNKNOWN unk_4EE358; // weak
_UNKNOWN unk_4EE35C; // weak
_UNKNOWN unk_4EE360; // weak
_UNKNOWN unk_4EE364; // weak
_UNKNOWN unk_4EE368; // weak
_UNKNOWN unk_4EE36C; // weak
_UNKNOWN unk_4EE370; // weak
_UNKNOWN unk_4EE374; // weak
_DWORD dword_4EE378[3]; // weak
PVOID dword_4EE6CC; // idb
PVOID dword_4EED3C; // idb
PVOID dword_4EED58; // idb
PVOID dword_4EF098; // idb
int dword_4EF0E8; // weak
PVOID dword_4EF0EC; // idb
PVOID dword_4EF0F0; // idb
PVOID dword_4EF0F4; // idb
PVOID dword_4EF0F8; // idb
PVOID dword_4EF0FC; // idb
_UNKNOWN unk_4EF10C; // weak
int dword_4EF110; // weak
int dword_4EF114; // weak
int dword_4EF118; // weak
_UNKNOWN unk_4EF11C; // weak
HMODULE hModule; // idb
int dword_4EF124; // weak
int dword_4EF128; // weak
int dword_4EF12C; // weak
int dword_4EF130; // weak
int dword_4EF134; // weak
WPARAM dword_4EF138; // idb
int dword_4EF13C; // weak
int dword_4EF140; // weak
int dword_4EF144; // weak
HICON dword_4EF148; // idb
WPARAM dword_4EF14C; // idb
WPARAM wParam; // idb
int dword_4EF154; // weak
int dword_4EF158; // weak
int dword_4EF160; // weak
int dword_4EF164; // weak
int dword_4EF16C; // weak
int dword_4EF170; // weak
int dword_4EF178; // weak
int dword_4EF17C; // weak
int dword_4EF184; // weak
int dword_4EF188; // weak
int dword_4EF190; // weak
int dword_4EF194; // weak
HWND dword_4EF19C; // idb
struct _RTL_CRITICAL_SECTION stru_4EF1A0; // idb
WNDPROC lpPrevWndFunc; // idb
HICON hIcon; // idb
_UNKNOWN unk_4EF1C0; // weak
int dword_4EF3C8; // weak
HMENU hMenu; // idb
int dword_4EF3D4; // weak
LPARAM dword_4EF3D8; // idb
HINSTANCE hInstance; // idb
_UNKNOWN unk_4EF3E0; // weak
HWND hWnd; // idb
HWND hDlg; // idb
LPVOID lpBuffer; // idb
HIMAGELIST himl; // idb
int dword_4EF434; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
DWORD ThreadId; // idb
struct _RTL_CRITICAL_SECTION stru_4EF464; // idb
int dword_4EF47C; // weak
int dword_4EF480; // weak
int dword_4EF484; // weak
struct _RTL_CRITICAL_SECTION stru_4EF488; // idb
int dword_4EF4A0; // weak
int dword_4EF4A4; // weak
int dword_4EF4A8; // weak
HWND dword_4EF4AC; // idb
int dword_4EF4B0; // weak
int dword_4EF4DC; // weak
int dword_4EF508; // weak
int dword_4EF534; // weak
int dword_4EF538; // weak
LPARAM lParam; // idb
int dword_4EF568; // weak
int dword_4EF594; // weak
int dword_4EF5C0; // weak
int dword_4EF5C4; // weak
int dword_4EF5C8; // weak
int dword_4EF694; // weak
int dword_4EF6C0; // weak
void *dword_4EF6EC; // idb
int dword_4EF6F0; // weak
void *dword_4EF6F8; // idb
int dword_4EF6FC; // weak
char *dword_4EF704; // idb
int dword_4EF708; // weak
__int16 word_4EF710; // weak
void *dword_4EF714; // idb
int dword_4EF718; // weak
void *dword_4EF720; // idb
int dword_4EF724; // weak
int dword_4EF728; // weak
int dword_4EF730; // weak
int dword_4EF734; // weak
float flt_4EF738; // weak
__int16 word_4EF73C; // weak
int dword_4EF740; // weak
int dword_4EF744; // weak
int dword_4EF748; // weak
int dword_4EF74C; // weak
__int16 word_4EF750; // weak
int dword_4EF754; // weak
int dword_4EF758; // weak
int dword_4EF75C; // weak
int dword_4EF760; // weak
char *dword_4EF764; // idb
int dword_4EF768; // weak
char *dword_4EF770; // idb
int dword_4EF774; // weak
char *dword_4EF77C; // idb
int dword_4EF780; // weak
char *dword_4EF788; // idb
int dword_4EF78C; // weak
LPARAM dwInitParam; // idb
int dword_4EF798; // weak
int dword_4EF79C; // weak
int dword_4EF7A0; // weak
int dword_4EF7A4; // weak
_UNKNOWN unk_4EF7A8; // weak
int dword_4EF7AC; // weak
int dword_4EF7B0; // weak
int dword_4EF7B4; // weak
int dword_4EF7B8; // weak
int dword_4EF7BC; // weak
int dword_4EF7C0; // weak
int dword_4EF7C4; // weak
int dword_4EF7C8; // weak
int dword_4EF7CC; // weak
int dword_4EF7D0; // weak
int dword_4EF7D4; // weak
int dword_4EF7D8; // weak
int dword_4EF7DC; // weak
int dword_4EF7E0; // idb
int dword_4EF7E4; // weak
int dword_4EF7E8; // weak
int dword_4EF7EC; // weak
int dword_4EF7F0; // weak
int dword_4EF7F4; // weak
int dword_4EF7F8; // weak
int dword_4EF7FC; // weak
int dword_4EF800; // weak
int dword_4EF804; // idb
_UNKNOWN unk_4EF808; // weak
int (__stdcall *dword_4EF80C)(_DWORD); // weak
int dword_4EF810; // weak
int dword_4EF814; // idb
int dword_4EF818; // weak
int dword_4EF81C; // weak
int dword_4EF820; // weak
int dword_4EF824; // weak
int dword_4EF828; // weak
int dword_4EF82C; // weak
int dword_4EF830; // weak
int dword_4EF834; // weak
int dword_4EF838; // weak
int dword_4EF83C; // weak
int dword_4EF840; // weak
int dword_4EFC80; // weak
__int64 qword_4EFC84; // weak
OLECHAR Buffer[64]; // weak
_UNKNOWN unk_4EFD10; // weak
WCHAR word_4F0110; // idb
wchar_t word_4F0318[13]; // weak
__int16 word_4F0332; // weak
_UNKNOWN unk_4F0338; // weak
int dword_4F03B8; // weak
int dword_4F05D8; // weak
int dword_4F07F4; // weak
int dword_4F07F8; // weak
int dword_4F0A18; // weak
int dword_4F0C34; // weak
int dword_4F0C38; // weak
int dword_4F0C3C; // weak
int dword_4F0C40; // weak
int dword_4F0E60; // weak
int dword_4F107C; // weak
int dword_4F1080; // weak
int dword_4F1088; // weak
int dword_4F12A4; // weak
int dword_4F12A8; // weak
int dword_4F14C8; // weak
int dword_4F16E4; // weak
int dword_4F16E8; // weak
int dword_4F16EC; // weak
int dword_4F16F0; // weak
int dword_4F16F4; // weak
int dword_4F16F8; // weak
int dword_4F16FC; // weak
int dword_4F1700; // weak
int dword_4F1704; // weak
int dword_4F1708; // weak
int dword_4F170C; // weak
int dword_4F1710; // weak
int dword_4F1714; // weak
int dword_4F1718; // weak
int dword_4F171C; // weak
int dword_4F1720; // weak
int dword_4F1724; // weak
int dword_4F1728; // weak
_UNKNOWN unk_4F1944; // weak
void *dword_4F1B44; // idb
int dword_4F1B48; // weak
int dword_4F1B50; // weak
int dword_4F1B54; // weak
int dword_4F1B58; // weak
int dword_4F1B60; // weak
_UNKNOWN unk_4F1D7C; // weak
int dword_4F1F84; // weak
int dword_4F1F88; // weak
int dword_4F1F90; // weak
int dword_4F1F94; // weak
int dword_4F1F98; // weak
int dword_4F1F9C; // weak
int dword_4F1FA0; // weak
int dword_4F1FA4; // weak
int dword_4F1FA8; // weak
int dword_4F1FAC; // weak
int dword_4F1FB0; // weak
int dword_4F1FB4; // weak
int dword_4F1FB8; // weak
int dword_4F1FC0; // weak
int dword_4F1FC4; // weak
int dword_4F1FC8; // weak
int dword_4F1FCC; // weak
int dword_4F1FD0; // weak
int dword_4F1FD4; // weak
int dword_4F1FD8; // weak
int dword_4F1FE0; // weak
void *dword_4F21FC; // idb
int dword_4F2200; // weak
int dword_4F2208; // weak
int dword_4F220C; // weak
int dword_4F2210; // weak
int dword_4F2214; // weak
int dword_4F2218; // weak
int dword_4F221C; // weak
int dword_4F2220; // weak
int dword_4F2224; // weak
int dword_4F2228; // weak
int dword_4F222C; // weak
int dword_4F2230; // weak
__int16 word_4F244C[8]; // weak
int dword_4F245C; // weak
int dword_4F2460; // weak
__int16 word_4F2468[8]; // weak
int dword_4F2478; // weak
int dword_4F247C; // weak
int dword_4F2484; // weak
int dword_4F2488; // weak
int dword_4F248C; // weak
int dword_4F2490; // weak
int dword_4F2494; // weak
_UNKNOWN unk_4F2498; // weak
_UNKNOWN unk_4F249C; // weak
_UNKNOWN unk_4F24A0; // weak
int dword_4F24A4; // weak
unsigned int dword_4F24A8; // idb
int dword_4F24B4; // weak
int dword_4F34C4; // weak
int dword_4F35E0; // weak


//----- (00401000) --------------------------------------------------------
int __usercall sub_401000@<eax>(unsigned int a1@<ecx>, wchar_t *a2@<ebx>, wchar_t *Format, ...)
{
  int result; // eax
  unsigned int v4; // esi
  int v5; // edi
  int v6; // eax
  va_list Args; // [esp+Ch] [ebp+Ch] BYREF

  va_start(Args, Format);
  result = 0;
  if ( !a1 || a1 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = a1 - 1;
    v5 = 0;
    v6 = _vsnwprintf(a2, a1 - 1, Format, Args);
    if ( v6 < 0 || v6 > v4 )
    {
      a2[v4] = 0;
      return -2147024774;
    }
    else if ( v6 == v4 )
    {
      result = 0;
      a2[v4] = 0;
      return result;
    }
    return v5;
  }
  return result;
}

//----- (00401060) --------------------------------------------------------
int __userpurge sub_401060@<eax>(_WORD *a1@<ebx>, unsigned int a2@<esi>, int a3)
{
  int result; // eax
  int v4; // [esp+4h] [ebp-4h] BYREF

  result = sub_4AA6C0(a2, a1, &v4);
  if ( result >= 0 )
    return sub_4AA520(a2 - v4, a3, &a1[v4]);
  return result;
}

//----- (00401090) --------------------------------------------------------
INT_PTR __stdcall sub_401090(LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
  HINSTANCE v4; // esi
  BOOL v6; // edi
  int v7; // esi
  FARPROC v8; // eax
  int v9; // [esp+10h] [ebp-20h] BYREF
  INT_PTR v10; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  LPARAM dwInitParama; // [esp+44h] [ebp+14h]

  v4 = hInstance;
  v10 = -1;
  v9 = 0;
  if ( !dword_4EF798 && !sub_4015E0((int)&v9) )
    return -1;
  ms_exc.registration.TryLevel = 0;
  v10 = DialogBoxParamW(v4, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 )
  {
    v6 = v10 == -1;
    if ( v10 == -1 )
      dwInitParama = GetLastError();
    else
      dwInitParama = 0;
    v7 = v9;
    v8 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v8 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v8 )
        goto LABEL_12;
      dword_4EF118 = (int)v8;
    }
    ((void (__stdcall *)(_DWORD, int))v8)(0, v7);
LABEL_12:
    if ( v6 )
      SetLastError(dwInitParama);
  }
  return v10;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (004011B0) --------------------------------------------------------
int __fastcall sub_4011B0(unsigned int a1, int a2, _WORD *a3)
{
  int result; // eax

  result = 0;
  if ( !a1 || a1 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    return sub_4A96F0(a1, a2, a3);
  return result;
}

//----- (004011E0) --------------------------------------------------------
int __stdcall sub_4011E0(int a1, int a2, DWORD dwErrCode)
{
  int v3; // edi
  int (__stdcall *v4)(int, int, DWORD); // esi
  FARPROC v6; // eax
  int v7; // esi
  FARPROC v8; // eax
  int v9; // [esp+14h] [ebp-20h] BYREF
  int v10; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+44h] [ebp+10h]

  v3 = -1;
  v10 = -1;
  v4 = (int (__stdcall *)(int, int, DWORD))dword_4EF114;
  v9 = 0;
  if ( !dword_4EF798 && !sub_4015E0((int)&v9) )
    return -1;
  ms_exc.registration.TryLevel = 0;
  if ( !v4 )
  {
    v6 = sub_4016B0((DWORD)"ImageList_Add");
    v4 = (int (__stdcall *)(int, int, DWORD))v6;
    if ( !v6 )
      goto LABEL_8;
    dword_4EF114 = (int)v6;
  }
  v3 = v4(a1, a2, dwErrCode);
  v10 = v3;
LABEL_8:
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 )
  {
    if ( v3 == -1 )
      dwErrCodea = GetLastError();
    else
      dwErrCodea = 0;
    v7 = v9;
    v8 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v8 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v8 )
        goto LABEL_16;
      dword_4EF118 = (int)v8;
    }
    ((void (__stdcall *)(_DWORD, int))v8)(0, v7);
LABEL_16:
    if ( v3 == -1 )
      SetLastError(dwErrCodea);
  }
  return v3;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF114: using guessed type int dword_4EF114;
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (00401310) --------------------------------------------------------
FARPROC __stdcall sub_401310(int a1)
{
  FARPROC result; // eax

  result = (FARPROC)dword_4EF134;
  if ( !dword_4EF134 )
  {
    result = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "QueryActCtxW");
    if ( !result )
      return result;
    dword_4EF134 = (int)result;
  }
  return (FARPROC)((int (__stdcall *)(int, int *, _DWORD, int, int, int, _DWORD))result)(
                    -2147483632,
                    &dword_4ECD00,
                    0,
                    1,
                    a1,
                    8,
                    0);
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4ECD00: using guessed type int dword_4ECD00;
// 4EF134: using guessed type int dword_4EF134;

//----- (00401360) --------------------------------------------------------
int sub_401360()
{
  int v0; // esi
  int v1; // eax
  FARPROC v2; // eax
  FARPROC v3; // eax
  DWORD LastError; // eax
  FARPROC v5; // eax
  int v7[8]; // [esp+10h] [ebp-280h] BYREF
  int v8[8]; // [esp+30h] [ebp-260h] BYREF
  int v9; // [esp+50h] [ebp-240h] BYREF
  HMODULE hModule; // [esp+58h] [ebp-238h] BYREF
  int v11; // [esp+5Ch] [ebp-234h] BYREF
  WCHAR Filename[260]; // [esp+60h] [ebp-230h] BYREF
  int v13; // [esp+268h] [ebp-28h]
  CPPEH_RECORD ms_exc; // [esp+278h] [ebp-18h]

  v0 = 0;
  v11 = 0;
  if ( dword_4EF798 || dword_4ECD00 != -1 )
    return 1;
  if ( !sub_401310((int)&v9) )
    return v0;
  v1 = v9;
  if ( v9 )
    goto LABEL_22;
  v2 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "GetModuleHandleExW");
  if ( !v2 )
    return v0;
  if ( !((int (__stdcall *)(int, int *, HMODULE *))v2)(6, &dword_4ECD00, &hModule) )
    return v0;
  v13 = 0;
  if ( !GetModuleFileNameW(hModule, Filename, 0x105u) )
    return v0;
  if ( (_WORD)v13 )
  {
    SetLastError(0x6Fu);
    return v0;
  }
  v8[0] = 32;
  v8[1] = 136;
  v8[2] = (int)Filename;
  v8[5] = 3;
  v8[7] = (int)hModule;
  v3 = (FARPROC)dword_4EF130;
  if ( dword_4EF130 )
    goto LABEL_14;
  v3 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "CreateActCtxW");
  if ( v3 )
  {
    dword_4EF130 = (int)v3;
LABEL_14:
    v1 = ((int (__stdcall *)(int *))v3)(v8);
    goto LABEL_15;
  }
  v1 = -1;
LABEL_15:
  v9 = v1;
  if ( v1 != -1 )
  {
LABEL_21:
    dword_4EF79C = 1;
LABEL_22:
    dword_4ECD00 = v1;
    if ( !sub_4015A0(v1, (int)&v11) )
      return 1;
    ms_exc.registration.TryLevel = 0;
    v7[0] = 64;
    v5 = (FARPROC)dword_4EF12C;
    if ( !dword_4EF12C )
    {
      v5 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "FindActCtxSectionStringW");
      if ( !v5 )
      {
LABEL_28:
        ms_exc.registration.TryLevel = -2;
        sub_401870(v11);
        return 1;
      }
      dword_4EF12C = (int)v5;
    }
    if ( ((int (__stdcall *)(_DWORD, _DWORD, int, const WCHAR *, int *))v5)(0, 0, 2, L"Comctl32.dll", v7) )
      LoadLibraryW(L"Comctl32.dll");
    goto LABEL_28;
  }
  LastError = GetLastError();
  if ( LastError == 1812 || LastError == 1813 || LastError == 1815 || LastError == 1814 )
  {
    v1 = 0;
    v9 = 0;
    goto LABEL_21;
  }
  return v0;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4ECD00: using guessed type int dword_4ECD00;
// 4EF12C: using guessed type int dword_4EF12C;
// 4EF130: using guessed type int dword_4EF130;
// 4EF798: using guessed type int dword_4EF798;
// 4EF79C: using guessed type int dword_4EF79C;
// 401360: using guessed type int var_280[8];

//----- (004015A0) --------------------------------------------------------
int (__stdcall *__stdcall sub_4015A0(int a1, int a2))(int, int)
{
  int (__stdcall *result)(int, int); // eax

  result = (int (__stdcall *)(int, int))dword_4EF128;
  if ( !dword_4EF128 )
  {
    result = (int (__stdcall *)(int, int))sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "ActivateActCtx");
    if ( !result )
      return result;
    dword_4EF128 = (int)result;
  }
  return (int (__stdcall *)(int, int))result(a1, a2);
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF128: using guessed type int dword_4EF128;

//----- (004015E0) --------------------------------------------------------
int __stdcall sub_4015E0(int a1)
{
  int result; // eax
  FARPROC v2; // eax
  int v3; // esi
  DWORD LastError; // eax

  if ( dword_4EF7A0 )
    OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n");
  if ( dword_4EF798 )
    return 1;
  if ( dword_4EF7A0 || sub_401360() )
  {
    v2 = (FARPROC)dword_4EF128;
    v3 = dword_4ECD00;
    if ( !dword_4EF128 )
    {
      v2 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "ActivateActCtx");
      if ( !v2 )
        goto LABEL_11;
      dword_4EF128 = (int)v2;
    }
    if ( ((int (__stdcall *)(int, int))v2)(v3, a1) )
      return 1;
  }
LABEL_11:
  LastError = GetLastError();
  if ( LastError != 127 && LastError != 126 && LastError != 120 )
    return 0;
  result = 1;
  dword_4EF798 = 1;
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4ECD00: using guessed type int dword_4ECD00;
// 4EF128: using guessed type int dword_4EF128;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7A0: using guessed type int dword_4EF7A0;

//----- (00401690) --------------------------------------------------------
HMODULE __stdcall sub_401690(const WCHAR *a1)
{
  return LoadLibraryW(a1);
}

//----- (004016A0) --------------------------------------------------------
HMODULE __stdcall sub_4016A0(const CHAR *a1)
{
  return LoadLibraryA(a1);
}

//----- (004016B0) --------------------------------------------------------
FARPROC __stdcall sub_4016B0(DWORD dwErrCode)
{
  FARPROC v1; // edi
  int v2; // esi
  int v4; // esi
  FARPROC v5; // eax
  int v6; // [esp+10h] [ebp-24h] BYREF
  int v7; // [esp+14h] [ebp-20h]
  FARPROC v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v1 = 0;
  v8 = 0;
  v2 = 0;
  v7 = 0;
  v6 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( dword_4EF798 || (v2 = sub_4015E0((int)&v6), (v7 = v2) != 0) )
  {
    v1 = sub_4017B0((int)&off_4CB878, (int)&unk_4EF10C, (LPCSTR)dwErrCode);
    v8 = v1;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 && v2 )
  {
    if ( v1 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v4 = v6;
    v5 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v5 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v5 )
        goto LABEL_13;
      dword_4EF118 = (int)v5;
    }
    ((void (__stdcall *)(_DWORD, int))v5)(0, v4);
LABEL_13:
    if ( !v1 )
      SetLastError(dwErrCodea);
  }
  return v1;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4CB878: using guessed type int (__stdcall *off_4CB878)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (004017B0) --------------------------------------------------------
FARPROC __userpurge sub_4017B0@<eax>(int a1@<ebx>, int a2, LPCSTR lpProcName)
{
  FARPROC ProcAddress; // esi
  HMODULE v4; // eax

  ProcAddress = 0;
  if ( !dword_4EF124 )
  {
    if ( (GetVersion() & 0x80000000) != 0 )
    {
      GetFileAttributesW(L"???.???");
      hModule = GetModuleHandleA("Unicows.dll");
    }
    dword_4EF124 = 1;
  }
  if ( !hModule || (ProcAddress = GetProcAddress(hModule, lpProcName)) == 0 )
  {
    v4 = *(HMODULE *)a2;
    if ( *(_DWORD *)a2 )
      return GetProcAddress(v4, lpProcName);
    if ( (GetVersion() & 0x80000000) == 0 )
      v4 = (HMODULE)(*(int (__stdcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    else
      v4 = (HMODULE)(*(int (__stdcall **)(_DWORD))(a1 + 8))(*(_DWORD *)(a1 + 12));
    if ( v4 )
    {
      *(_DWORD *)a2 = v4;
      return GetProcAddress(v4, lpProcName);
    }
  }
  return ProcAddress;
}
// 4EF124: using guessed type int dword_4EF124;

//----- (00401850) --------------------------------------------------------
HMODULE __stdcall sub_401850(const WCHAR *a1)
{
  return GetModuleHandleW(a1);
}

//----- (00401860) --------------------------------------------------------
HMODULE __stdcall sub_401860(const CHAR *a1)
{
  return GetModuleHandleA(a1);
}

//----- (00401870) --------------------------------------------------------
FARPROC __stdcall sub_401870(int a1)
{
  FARPROC result; // eax

  result = (FARPROC)dword_4EF118;
  if ( !dword_4EF118 )
  {
    result = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
    if ( !result )
      return result;
    dword_4EF118 = (int)result;
  }
  return (FARPROC)((int (__stdcall *)(_DWORD, int))result)(0, a1);
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;

//----- (004018B0) --------------------------------------------------------
int __stdcall sub_4018B0(int a1, int a2, int a3, int a4, DWORD dwErrCode)
{
  int v5; // edi
  int (__stdcall *v6)(int, int, int, int, DWORD); // esi
  int result; // eax
  FARPROC v8; // eax
  int v9; // esi
  FARPROC v10; // eax
  int v11; // [esp+14h] [ebp-20h] BYREF
  int v12; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+4Ch] [ebp+18h]

  v5 = 0;
  v12 = 0;
  v6 = (int (__stdcall *)(int, int, int, int, DWORD))dword_4EF110;
  v11 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v11)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v6 )
    {
      v8 = sub_4016B0((DWORD)"ImageList_Create");
      v6 = (int (__stdcall *)(int, int, int, int, DWORD))v8;
      if ( !v8 )
        goto LABEL_7;
      dword_4EF110 = (int)v8;
    }
    v5 = v6(a1, a2, a3, a4, dwErrCode);
    v12 = v5;
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v5;
    if ( v5 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v9 = v11;
    v10 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v10 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v10 )
        goto LABEL_15;
      dword_4EF118 = (int)v10;
    }
    ((void (__stdcall *)(_DWORD, int))v10)(0, v9);
LABEL_15:
    if ( !v5 )
      SetLastError(dwErrCodea);
    return v5;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF110: using guessed type int dword_4EF110;
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (004019E0) --------------------------------------------------------
FARPROC __stdcall sub_4019E0(DWORD dwErrCode)
{
  FARPROC v1; // edi
  int v2; // esi
  int v4; // esi
  FARPROC v5; // eax
  int v6; // [esp+10h] [ebp-24h] BYREF
  int v7; // [esp+14h] [ebp-20h]
  FARPROC v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v1 = 0;
  v8 = 0;
  v2 = 0;
  v7 = 0;
  v6 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( dword_4EF798 || (v2 = sub_4015E0((int)&v6), (v7 = v2) != 0) )
  {
    v1 = sub_4017B0((int)&off_4CB8E8, (int)&unk_4EF7A8, (LPCSTR)dwErrCode);
    v8 = v1;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 && v2 )
  {
    if ( v1 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v4 = v6;
    v5 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v5 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v5 )
        goto LABEL_13;
      dword_4EF118 = (int)v5;
    }
    ((void (__stdcall *)(_DWORD, int))v5)(0, v4);
LABEL_13:
    if ( !v1 )
      SetLastError(dwErrCodea);
  }
  return v1;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4CB8E8: using guessed type int (__stdcall *off_4CB8E8)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (00401AE0) --------------------------------------------------------
int __stdcall sub_401AE0(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  int result; // eax
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v8 = 0;
  v1 = (int (__stdcall *)(DWORD))dword_4EF7A4;
  v7 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v7)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v1 )
    {
      v3 = sub_4019E0((DWORD)"GetOpenFileNameW");
      v1 = (int (__stdcall *)(DWORD))v3;
      if ( !v3 )
        goto LABEL_7;
      dword_4EF7A4 = (int)v3;
    }
    v8 = v1(dwErrCode);
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v8;
    v4 = v8 == 0;
    if ( v8 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_15;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_15:
    if ( v4 )
      SetLastError(dwErrCodea);
    return v8;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7A4: using guessed type int dword_4EF7A4;

//----- (00401C00) --------------------------------------------------------
void __thiscall sub_401C00(std::exception *this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_4398D8(this);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401C10) --------------------------------------------------------
std::exception *__thiscall sub_401C10(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401C30) --------------------------------------------------------
void *__thiscall sub_401C30(void *this, char a2)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_4398D8((std::exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401C60) --------------------------------------------------------
int __stdcall sub_401C60(int a1, int a2, int a3, DWORD dwErrCode)
{
  int v4; // edi
  int (__stdcall *v5)(int, int, int, DWORD); // esi
  int result; // eax
  FARPROC v7; // eax
  int v8; // esi
  FARPROC v9; // eax
  int v10; // [esp+10h] [ebp-20h] BYREF
  int v11; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  DWORD dwErrCodea; // [esp+44h] [ebp+14h]

  v4 = 0;
  v11 = 0;
  v5 = (int (__stdcall *)(int, int, int, DWORD))dword_4EF7B4;
  v10 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v10)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v5 )
    {
      v7 = sub_4016B0((DWORD)"DefSubclassProc");
      v5 = (int (__stdcall *)(int, int, int, DWORD))v7;
      if ( !v7 )
        goto LABEL_7;
      dword_4EF7B4 = (int)v7;
    }
    v4 = v5(a1, a2, a3, dwErrCode);
    v11 = v4;
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v4;
    if ( v4 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v8 = v10;
    v9 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v9 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v9 )
        goto LABEL_15;
      dword_4EF118 = (int)v9;
    }
    ((void (__stdcall *)(_DWORD, int))v9)(0, v8);
LABEL_15:
    if ( !v4 )
      SetLastError(dwErrCodea);
    return v4;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7B4: using guessed type int dword_4EF7B4;

//----- (00401D90) --------------------------------------------------------
void __thiscall sub_401D90(_DWORD *this)
{
  _DWORD *v1; // esi
  struct std::ios_base *v2; // [esp+Ch] [ebp-10h]

  v2 = (struct std::ios_base *)(this + 22);
  *(_DWORD *)((char *)v2 + *(_DWORD *)(*this + 4) - 88) = &std::wistringstream::`vftable';
  v1 = this + 4;
  this[4] = &std::wstringbuf::`vftable';
  sub_4027E0((int)(this + 4));
  sub_408180((_DWORD *)v2 - 18);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v2 - 22) + 4) - 16) = &std::wistream::`vftable';
  *(_DWORD *)v2 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v2);
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CB9AC: using guessed type void *std::wistringstream::`vftable';
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';

//----- (00401E20) --------------------------------------------------------
int __stdcall sub_401E20(int a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // edx
  _DWORD *v4; // eax
  struct std::locale::facet *v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  void (__thiscall ***v9)(_DWORD, int); // edi
  int v10; // eax
  int v11; // ecx
  int v12; // edx
  _DWORD *v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v18; // [esp+0h] [ebp-48h] BYREF
  char v19[4]; // [esp+10h] [ebp-38h] BYREF
  int v20; // [esp+14h] [ebp-34h]
  int v21; // [esp+18h] [ebp-30h]
  char v22; // [esp+1Ch] [ebp-2Ch]
  int v23; // [esp+24h] [ebp-24h] BYREF
  int v24; // [esp+28h] [ebp-20h] BYREF
  int v25; // [esp+2Ch] [ebp-1Ch] BYREF
  struct std::locale::facet *v26; // [esp+30h] [ebp-18h]
  int v27[2]; // [esp+34h] [ebp-14h] BYREF
  int v28; // [esp+44h] [ebp-4h]

  v27[1] = (int)&v18;
  v27[0] = 0;
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
  v21 = a1;
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v28 = 0;
  v22 = sub_408E00(a1);
  v28 = 1;
  if ( v22 )
  {
    v3 = *(_DWORD *)a1;
    v25 = 0;
    v4 = sub_408A70((_DWORD **)(a1 + *(_DWORD *)(v3 + 4)), &v24);
    LOBYTE(v28) = 2;
    v5 = sub_406C30((int)v4);
    LOBYTE(v28) = 1;
    v6 = v24;
    v26 = v5;
    if ( v24 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v23, 0);
      v7 = *(_DWORD *)(v6 + 4);
      if ( v7 && v7 != -1 )
        *(_DWORD *)(v6 + 4) = v7 - 1;
      v8 = -(*(_DWORD *)(v6 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)&v23);
      v9 = (void (__thiscall ***)(_DWORD, int))(v6 & v8);
      if ( v9 )
        (**v9)(v9, 1);
    }
    LOBYTE(v28) = 3;
    v10 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v11 = *(_DWORD *)(v10 + a1 + 56);
    LOBYTE(v23) = 1;
    LOBYTE(v20) = v11 == 0;
    (*(void (__thiscall **)(struct std::locale::facet *, char *, int, int, _DWORD, int, int, int *, int *))(*(_DWORD *)v26 + 32))(
      v26,
      v19,
      v11,
      v20,
      0,
      v23,
      a1 + v10,
      v27,
      &v25);
    v28 = 1;
    v12 = v27[0];
    if ( (v27[0] & 2) != 0 )
    {
      v12 = v27[0] | 2;
      v27[0] |= 2u;
    }
    else
    {
      *a2 = v25;
    }
  }
  else
  {
    v12 = v27[0];
  }
  v13 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4));
  if ( v12 )
  {
    v14 = v12 | v13[3];
    if ( !v13[14] )
      LOBYTE(v14) = v14 | 4;
    v15 = v14 & 0x17;
    v13[3] = v15;
    if ( (v15 & v13[4]) != 0 )
      sub_408D30(0);
  }
  v28 = -1;
  v16 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
  if ( v16 )
    (*(void (**)(void))(*(_DWORD *)v16 + 8))();
  return a1;
}
// 401E20: using guessed type char var_38[4];

//----- (00402000) --------------------------------------------------------
int __userpurge sub_402000@<eax>(unsigned int a1@<edx>, unsigned int a2@<ecx>, int a3@<esi>, _DWORD *a4)
{
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 7;
  *(_WORD *)a3 = 0;
  sub_4090E0(a3, a4, a1, a2);
  return a3;
}

//----- (00402030) --------------------------------------------------------
int __thiscall sub_402030(void *Src, int a2)
{
  unsigned int v3; // eax

  *(_DWORD *)a2 = &unk_4CB9B0;
  *(_DWORD *)(a2 + 88) = &std::wios::`vftable';
  sub_402740((_DWORD *)a2, a2 + 16);
  *(_DWORD *)(a2 + *(_DWORD *)(*(_DWORD *)a2 + 4)) = &std::wistringstream::`vftable';
  sub_403840((_DWORD *)(a2 + 16));
  *(_DWORD *)(a2 + 16) = &std::wstringbuf::`vftable';
  v3 = *((_DWORD *)Src + 4);
  if ( *((_DWORD *)Src + 5) >= 8u )
    Src = *(void **)Src;
  *(_DWORD *)(a2 + 76) = 0;
  *(_DWORD *)(a2 + 80) = 2;
  if ( v3 )
    sub_403930(v3, a2 + 16, Src);
  return a2;
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CB9AC: using guessed type void *std::wistringstream::`vftable';
// 4CBAD4: using guessed type void *std::wios::`vftable';

//----- (004020F0) --------------------------------------------------------
__int16 __thiscall sub_4020F0(int this, __int16 a2)
{
  unsigned int *v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // ecx
  int v6; // eax
  __int16 result; // ax
  unsigned int v8; // edi
  _DWORD *v9; // ecx
  _WORD **v10; // esi
  __int16 *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // eax
  int v14; // edi
  void *v15; // ecx
  int *v16; // eax
  int *v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edx
  _DWORD *v22; // eax
  _WORD **v23; // esi
  __int16 *v24; // ecx
  void *v25; // [esp+8h] [ebp-8h]
  unsigned int v26; // [esp+Ch] [ebp-4h]

  if ( (*(_BYTE *)(this + 64) & 8) != 0 )
  {
    v3 = *(unsigned int **)(this + 36);
    v4 = *v3;
    if ( *v3 )
    {
      v5 = *(_DWORD *)(this + 60);
      if ( v4 < v5 )
      {
        v6 = v4 + 2 * **(_DWORD **)(this + 52) - v5;
        *v3 = v5;
        **(_DWORD **)(this + 52) = v6 >> 1;
      }
    }
  }
  result = a2;
  if ( a2 == -1 )
    return 0;
  v8 = **(_DWORD **)(this + 36);
  if ( v8 )
  {
    v9 = *(_DWORD **)(this + 52);
    if ( v8 < v8 + 2 * *v9 )
    {
      --*v9;
      v10 = *(_WORD ***)(this + 36);
      v11 = (*v10)++;
      *v11 = a2;
      return result;
    }
  }
  if ( (*(_BYTE *)(this + 64) & 2) != 0 )
    return -1;
  if ( v8 )
    v12 = (int)(v8 + 2 * **(_DWORD **)(this + 52) - **(_DWORD **)(this + 16)) >> 1;
  else
    v12 = 0;
  v13 = v12 >> 1;
  if ( v12 >> 1 >= 0x20 )
  {
    if ( !v13 )
      return -1;
  }
  else
  {
    v13 = 32;
  }
  do
  {
    if ( 0x7FFFFFFF - v13 >= v12 )
      break;
    v13 >>= 1;
  }
  while ( v13 );
  if ( !v13 )
    return -1;
  v26 = v12 + v13;
  v14 = (int)sub_4091E0((char *)(v12 + v13));
  v15 = **(void ***)(this + 16);
  v25 = v15;
  if ( v12 )
  {
    memcpy_0((void *)v14, v15, 2 * v12);
    v15 = v25;
    v17 = *(int **)(this + 36);
    *(_DWORD *)(this + 60) = v14 + 2 * ((*(_DWORD *)(this + 60) - (int)v25) >> 1);
    v18 = *v17;
    **(_DWORD **)(this + 20) = v14 + 2 * ((**(_DWORD **)(this + 20) - (int)v25) >> 1);
    v19 = v14 + 2 * ((v18 - (int)v25) >> 1);
    **(_DWORD **)(this + 36) = v19;
    **(_DWORD **)(this + 52) = (int)(v14 + 2 * v26 - v19) >> 1;
    if ( (*(_BYTE *)(this + 64) & 4) == 0 )
    {
      v20 = **(_DWORD **)(this + 36);
      v21 = v14 + 2 * ((**(_DWORD **)(this + 32) - (int)v25) >> 1);
      **(_DWORD **)(this + 16) = v14;
      **(_DWORD **)(this + 32) = v21;
      **(_DWORD **)(this + 48) = (v20 - v21 + 2) >> 1;
      goto LABEL_28;
    }
    goto LABEL_26;
  }
  v16 = *(int **)(this + 20);
  *(_DWORD *)(this + 60) = v14;
  *v16 = v14;
  **(_DWORD **)(this + 36) = v14;
  **(_DWORD **)(this + 52) = (int)(2 * v26) >> 1;
  if ( (*(_BYTE *)(this + 64) & 4) != 0 )
  {
LABEL_26:
    **(_DWORD **)(this + 16) = v14;
    **(_DWORD **)(this + 32) = 0;
    **(_DWORD **)(this + 48) = v14 >> 1;
    goto LABEL_28;
  }
  **(_DWORD **)(this + 16) = v14;
  **(_DWORD **)(this + 32) = v14;
  **(_DWORD **)(this + 48) = 1;
LABEL_28:
  if ( (*(_BYTE *)(this + 64) & 1) != 0 )
    operator delete(v15);
  v22 = *(_DWORD **)(this + 52);
  *(_DWORD *)(this + 64) |= 1u;
  --*v22;
  v23 = *(_WORD ***)(this + 36);
  v24 = (*v23)++;
  result = a2;
  *v24 = a2;
  return result;
}
// 4021F0: conditional instruction was optimized away because ebx.4!=0

//----- (004022E0) --------------------------------------------------------
int __thiscall sub_4022E0(int this, unsigned __int16 a2)
{
  unsigned int v2; // eax

  v2 = **(_DWORD **)(this + 32);
  if ( !v2
    || v2 <= **(_DWORD **)(this + 16)
    || a2 != 0xFFFF && a2 != *(_WORD *)(v2 - 2) && (*(_BYTE *)(this + 64) & 2) != 0 )
  {
    return 0xFFFF;
  }
  ++**(_DWORD **)(this + 48);
  **(_DWORD **)(this + 32) -= 2;
  if ( a2 == 0xFFFF )
    return 0;
  ***(_WORD ***)(this + 32) = a2;
  return a2;
}

//----- (00402350) --------------------------------------------------------
__int16 __thiscall sub_402350(int this)
{
  unsigned int *v1; // edx
  unsigned int v2; // esi
  int *v4; // edi
  unsigned int v5; // eax

  v1 = *(unsigned int **)(this + 32);
  v2 = *v1;
  if ( !*v1 )
    return -1;
  v4 = *(int **)(this + 48);
  if ( v2 < v2 + 2 * *v4 )
    return *(_WORD *)v2;
  if ( (*(_BYTE *)(this + 64) & 4) != 0 )
    return -1;
  v5 = **(_DWORD **)(this + 36);
  if ( !v5 || v5 <= v2 && *(_DWORD *)(this + 60) <= v2 )
    return -1;
  if ( *(_DWORD *)(this + 60) < v5 )
    *(_DWORD *)(this + 60) = v5;
  *v4 = (int)(*(_DWORD *)(this + 60) - *v1) >> 1;
  return ***(_WORD ***)(this + 32);
}

//----- (004023C0) --------------------------------------------------------
int *__thiscall sub_4023C0(int this, int *a2, __int64 a3, int a4, char a5)
{
  unsigned int *v5; // edx
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // esi
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // esi
  int v16; // esi
  int *result; // eax

  v5 = *(unsigned int **)(this + 36);
  v6 = *v5;
  if ( *v5 && *(_DWORD *)(this + 60) < v6 )
    *(_DWORD *)(this + 60) = v6;
  if ( (a5 & 1) == 0 || (v7 = **(_DWORD **)(this + 32)) == 0 )
  {
    if ( (a5 & 2) != 0 && *v5 )
    {
      if ( a4 == 2 )
      {
        v8 = (unsigned __int64)(((*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16)) >> 1) + a3) >> 32;
        v9 = ((*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16)) >> 1) + a3;
      }
      else if ( a4 == 1 )
      {
        v8 = (unsigned __int64)(((int)(*v5 - **(_DWORD **)(this + 16)) >> 1) + a3) >> 32;
        v9 = ((int)(*v5 - **(_DWORD **)(this + 16)) >> 1) + a3;
      }
      else if ( a4 )
      {
        v9 = -1;
        v8 = -1;
      }
      else
      {
        v8 = HIDWORD(a3);
        v9 = a3;
      }
      if ( v8 >= 0 )
      {
        v15 = **(_DWORD **)(this + 16);
        if ( __SPAIR64__(v8, v9) <= (*(_DWORD *)(this + 60) - v15) >> 1 )
        {
          v16 = v9 + ((int)(v15 - *v5) >> 1);
          **(_DWORD **)(this + 52) -= v16;
          **(_DWORD **)(this + 36) += 2 * v16;
          goto LABEL_33;
        }
      }
    }
    else
    {
      v8 = HIDWORD(a3);
      v9 = a3;
      if ( !a3 )
        goto LABEL_33;
    }
LABEL_32:
    v9 = -1;
    v8 = -1;
    goto LABEL_33;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( (a5 & 2) == 0 )
      {
        v8 = (unsigned __int64)(((v7 - **(_DWORD **)(this + 16)) >> 1) + a3) >> 32;
        v9 = ((v7 - **(_DWORD **)(this + 16)) >> 1) + a3;
        goto LABEL_14;
      }
    }
    else if ( !a4 )
    {
      v8 = HIDWORD(a3);
      v9 = a3;
      goto LABEL_14;
    }
    v9 = -1;
    v8 = -1;
    goto LABEL_14;
  }
  v8 = (unsigned __int64)(((*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16)) >> 1) + a3) >> 32;
  v9 = ((*(_DWORD *)(this + 60) - **(_DWORD **)(this + 16)) >> 1) + a3;
LABEL_14:
  if ( v8 < 0 )
    goto LABEL_32;
  v10 = **(_DWORD **)(this + 16);
  if ( __SPAIR64__(v8, v9) > (*(_DWORD *)(this + 60) - v10) >> 1 )
    goto LABEL_32;
  v11 = v9 + ((v10 - v7) >> 1);
  **(_DWORD **)(this + 48) -= v11;
  **(_DWORD **)(this + 32) += 2 * v11;
  if ( (a5 & 2) != 0 )
  {
    v12 = **(_DWORD **)(this + 36);
    if ( v12 )
    {
      v13 = **(_DWORD **)(this + 32);
      v14 = v12 + 2 * **(_DWORD **)(this + 52);
      **(_DWORD **)(this + 36) = v13;
      **(_DWORD **)(this + 52) = (v14 - v13) >> 1;
    }
  }
LABEL_33:
  result = a2;
  *a2 = v9;
  a2[1] = v8;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}

//----- (004025A0) --------------------------------------------------------
int *__thiscall sub_4025A0(int this, int *a2, __int64 a3, int a4, int a5, int a6, int a7, char a8)
{
  unsigned int *v8; // esi
  int v9; // ebx
  int v10; // edi
  unsigned int v11; // eax
  int v12; // esi
  int v13; // esi
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // esi
  int v18; // esi
  int *result; // eax
  int v20; // [esp+Ch] [ebp-4h]
  unsigned int v21; // [esp+Ch] [ebp-4h]

  v8 = *(unsigned int **)(this + 36);
  v11 = *v8;
  v9 = (unsigned __int64)(a3 + a4) >> 32;
  v10 = a3 + a4;
  if ( *v8 && *(_DWORD *)(this + 60) < v11 )
    *(_DWORD *)(this + 60) = v11;
  if ( v10 != -1 || v9 != -1 )
  {
    if ( (a8 & 1) != 0 && (v20 = **(_DWORD **)(this + 32)) != 0 )
    {
      if ( v9 >= 0 )
      {
        v12 = **(_DWORD **)(this + 16);
        if ( __SPAIR64__(v9, v10) <= (*(_DWORD *)(this + 60) - v12) >> 1 )
        {
          v13 = v10 + ((v12 - v20) >> 1);
          **(_DWORD **)(this + 48) -= v13;
          **(_DWORD **)(this + 32) += 2 * v13;
          if ( (a8 & 2) != 0 )
          {
            v14 = **(_DWORD **)(this + 36);
            if ( v14 )
            {
              v15 = **(_DWORD **)(this + 32);
              v16 = v14 + 2 * **(_DWORD **)(this + 52);
              **(_DWORD **)(this + 36) = v15;
              **(_DWORD **)(this + 52) = (v16 - v15) >> 1;
            }
          }
          goto LABEL_19;
        }
      }
    }
    else if ( (a8 & 2) != 0 )
    {
      v21 = *v8;
      if ( *v8 )
      {
        if ( v9 >= 0 )
        {
          v17 = **(_DWORD **)(this + 16);
          if ( __SPAIR64__(v9, v10) <= (*(_DWORD *)(this + 60) - v17) >> 1 )
          {
            v18 = v10 + ((int)(v17 - v21) >> 1);
            **(_DWORD **)(this + 52) -= v18;
            **(_DWORD **)(this + 36) += 2 * v18;
            goto LABEL_19;
          }
        }
      }
    }
    v9 = -1;
    v10 = -1;
  }
LABEL_19:
  result = a2;
  *a2 = v10;
  a2[1] = v9;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  return result;
}

//----- (004026E0) --------------------------------------------------------
char *__thiscall sub_4026E0(_DWORD *this, char a2)
{
  _DWORD *v2; // esi

  v2 = this - 22;
  sub_401D90(this - 22);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return (char *)v2;
}

//----- (00402710) --------------------------------------------------------
void *__thiscall sub_402710(void *this, char a2)
{
  *(_DWORD *)this = &std::wstringbuf::`vftable';
  sub_4027E0((int)this);
  sub_408180(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';

//----- (00402740) --------------------------------------------------------
_DWORD *__stdcall sub_402740(_DWORD *a1, int a2)
{
  int v2; // edx
  char *v3; // esi
  int v4; // eax

  *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 + 4)) = &std::wistream::`vftable';
  v2 = *a1;
  a1[2] = 0;
  a1[3] = 0;
  v3 = (char *)a1 + *(_DWORD *)(v2 + 4);
  sub_407DF0(v3);
  *((_DWORD *)v3 + 14) = a2;
  *((_DWORD *)v3 + 15) = 0;
  *((_WORD *)v3 + 32) = sub_405410((_DWORD **)v3);
  if ( !*((_DWORD *)v3 + 14) )
  {
    v4 = *((_DWORD *)v3 + 3) & 0x13 | 4;
    *((_DWORD *)v3 + 3) = v4;
    if ( (v4 & *((_DWORD *)v3 + 4)) != 0 )
      sub_408D30(0);
  }
  return a1;
}
// 4CBB1C: using guessed type void *std::wistream::`vftable';

//----- (004027E0) --------------------------------------------------------
_DWORD *__usercall sub_4027E0@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax

  if ( (*(_BYTE *)(a1 + 64) & 1) != 0 )
    operator delete(**(void ***)(a1 + 16));
  **(_DWORD **)(a1 + 16) = 0;
  **(_DWORD **)(a1 + 32) = 0;
  **(_DWORD **)(a1 + 48) = 0;
  **(_DWORD **)(a1 + 20) = 0;
  result = *(_DWORD **)(a1 + 36);
  *result = 0;
  **(_DWORD **)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 64) &= ~1u;
  *(_DWORD *)(a1 + 60) = 0;
  return result;
}

//----- (00402840) --------------------------------------------------------
int *__thiscall sub_402840(void *this, int *a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, bool *a9)
{
  int v9; // esi
  bool v10; // zf
  _DWORD *v12; // eax
  struct std::locale::facet *v13; // eax
  int v14; // edi
  struct std::locale::facet *v15; // ebx
  int v16; // eax
  int v17; // esi
  void (__thiscall ***v18)(_DWORD, int); // esi
  _DWORD *v19; // eax
  int v20; // edx
  _DWORD *v21; // eax
  unsigned int v22; // esi
  void **v23; // eax
  int v24; // ebx
  _DWORD *v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // edi
  int v29; // eax
  int v30; // esi
  void (__thiscall ***v31)(_DWORD, int); // esi
  int v32; // ecx
  _DWORD *v33; // eax
  int *result; // eax
  char v35[4]; // [esp+10h] [ebp-70h] BYREF
  bool *v36; // [esp+14h] [ebp-6Ch]
  int v37; // [esp+18h] [ebp-68h] BYREF
  int v38; // [esp+1Ch] [ebp-64h] BYREF
  int *v39; // [esp+20h] [ebp-60h]
  char v40[4]; // [esp+24h] [ebp-5Ch] BYREF
  int v41; // [esp+28h] [ebp-58h] BYREF
  _DWORD *v42; // [esp+2Ch] [ebp-54h]
  int v43; // [esp+30h] [ebp-50h] BYREF
  void *v44[5]; // [esp+34h] [ebp-4Ch] BYREF
  unsigned int v45; // [esp+48h] [ebp-38h]
  int v46; // [esp+50h] [ebp-30h] BYREF
  void *v47[5]; // [esp+54h] [ebp-2Ch] BYREF
  unsigned int v48; // [esp+68h] [ebp-18h]
  int v49; // [esp+7Ch] [ebp-4h]

  v9 = a7;
  v10 = (*(_DWORD *)(a7 + 20) & 0x4000) == 0;
  v39 = a2;
  v42 = a8;
  v36 = a9;
  v43 = -1;
  if ( v10 )
  {
    v41 = 0;
    v25 = sub_408A70((_DWORD **)a7, &v37);
    v49 = 4;
    v26 = sub_403A20((int)this, &v46, (int)&a3, &a5, *(_DWORD *)(v9 + 20), (int)v25);
    v27 = _Stoulx((int)&v46, (int)&v38, v26, (int)&v41);
    v49 = -1;
    v28 = v37;
    v24 = v27;
    if ( v37 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v40, 0);
      v29 = *(_DWORD *)(v28 + 4);
      if ( v29 && v29 != -1 )
        *(_DWORD *)(v28 + 4) = v29 - 1;
      v30 = -(*(_DWORD *)(v28 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v40);
      v31 = (void (__thiscall ***)(_DWORD, int))(v28 & v30);
      if ( v31 )
        (**v31)(v31, 1);
    }
    if ( (int *)v38 == &v46 || v41 || (unsigned int)v24 > 1 )
      v24 = v43;
  }
  else
  {
    v12 = sub_408A70((_DWORD **)a7, &v43);
    v49 = 0;
    v13 = sub_406D70((int)v12);
    v49 = -1;
    v14 = v43;
    v15 = v13;
    if ( v43 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v35, 0);
      v16 = *(_DWORD *)(v14 + 4);
      if ( v16 && v16 != -1 )
        *(_DWORD *)(v14 + 4) = v16 - 1;
      v17 = -(*(_DWORD *)(v14 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v35);
      v18 = (void (__thiscall ***)(_DWORD, int))(v14 & v17);
      if ( v18 )
        (**v18)(v18, 1);
    }
    v45 = 7;
    v44[4] = (void *)1;
    v44[0] = 0;
    v49 = 1;
    v19 = (_DWORD *)sub_4051A0(v15, (int)v47);
    LOBYTE(v49) = 2;
    sub_406A00(v44, v19, 0, 0xFFFFFFFF);
    LOBYTE(v49) = 1;
    if ( v48 >= 8 )
      operator delete(v47[0]);
    sub_4054C0((int *)v44, v20, 1u, 0);
    v21 = (_DWORD *)sub_4051C0(v15, (int)v47);
    LOBYTE(v49) = 3;
    sub_406A00(v44, v21, 0, 0xFFFFFFFF);
    LOBYTE(v49) = 1;
    if ( v48 >= 8 )
      operator delete(v47[0]);
    v22 = v45;
    v23 = (void **)v44[0];
    if ( v45 < 8 )
      v23 = v44;
    v24 = sub_406EB0((int)&a3, (int)&a5, 2u, (int)v23);
    v49 = -1;
    if ( v22 >= 8 )
      operator delete(v44[0]);
  }
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v32 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_32;
  }
  else if ( a5 )
  {
LABEL_32:
    v33 = v42;
    goto LABEL_33;
  }
  v33 = v42;
  *v42 |= 1u;
LABEL_33:
  if ( v24 >= 0 )
    *v36 = v24 != 0;
  else
    *v33 |= 2u;
  result = v39;
  *v39 = v32;
  result[1] = a4;
  return result;
}
// 40294E: variable 'v20' is possibly undefined
// 402840: using guessed type char var_70[4];
// 402840: using guessed type char var_5C[4];

//----- (00402AE0) --------------------------------------------------------
_DWORD *__thiscall sub_402AE0(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        _WORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // ebx
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  int *v17; // edi
  unsigned int v18; // esi
  int v19; // ecx
  _DWORD *v20; // eax
  _DWORD *result; // eax
  int v22; // [esp+10h] [ebp-4Ch] BYREF
  int v23; // [esp+14h] [ebp-48h] BYREF
  _DWORD *v24; // [esp+18h] [ebp-44h]
  _WORD *v25; // [esp+1Ch] [ebp-40h]
  char v26[4]; // [esp+20h] [ebp-3Ch] BYREF
  int v27; // [esp+24h] [ebp-38h] BYREF
  _DWORD *v28; // [esp+28h] [ebp-34h]
  char v29; // [esp+2Ch] [ebp-30h] BYREF
  int v30; // [esp+2Dh] [ebp-2Fh] BYREF
  int v31; // [esp+58h] [ebp-4h]

  v9 = a7;
  v24 = a2;
  v28 = a8;
  v25 = a9;
  v27 = 0;
  v11 = sub_408A70(a7, &v22);
  v31 = 0;
  v12 = sub_403A20((int)this, &v29, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v31 = -1;
  if ( v22 )
  {
    v13 = v22;
    std::_Lockit::_Lockit((std::_Lockit *)v26, 0);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 && v14 != -1 )
      *(_DWORD *)(v13 + 4) = v14 - 1;
    v15 = -(*(_DWORD *)(v13 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v26);
    v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
    if ( v16 )
      (**v16)(v16, 1);
  }
  v17 = &v30;
  if ( v29 != 45 )
    v17 = (int *)&v29;
  v18 = _Stoulx((int)v17, (int)&v23, v12, (int)&v27);
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v19 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_15;
LABEL_23:
    v20 = v28;
    *v28 |= 1u;
    goto LABEL_16;
  }
  if ( !a5 )
    goto LABEL_23;
LABEL_15:
  v20 = v28;
LABEL_16:
  if ( (int *)v23 == v17 || v27 || v18 > 0xFFFF )
  {
    *v20 |= 2u;
  }
  else
  {
    if ( v29 == 45 )
      v18 = -v18;
    *v25 = v18;
  }
  result = v24;
  *v24 = v19;
  result[1] = a4;
  return result;
}
// 402AE0: using guessed type char var_3C[4];

//----- (00402C50) --------------------------------------------------------
_DWORD *__thiscall sub_402C50(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        int *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // ebx
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  int *v17; // edi
  int v18; // esi
  int v19; // ecx
  _DWORD *v20; // eax
  _DWORD *result; // eax
  int v22; // [esp+10h] [ebp-4Ch] BYREF
  int v23; // [esp+14h] [ebp-48h] BYREF
  _DWORD *v24; // [esp+18h] [ebp-44h]
  int *v25; // [esp+1Ch] [ebp-40h]
  char v26[4]; // [esp+20h] [ebp-3Ch] BYREF
  int v27; // [esp+24h] [ebp-38h] BYREF
  _DWORD *v28; // [esp+28h] [ebp-34h]
  char v29; // [esp+2Ch] [ebp-30h] BYREF
  int v30; // [esp+2Dh] [ebp-2Fh] BYREF
  int v31; // [esp+58h] [ebp-4h]

  v9 = a7;
  v24 = a2;
  v28 = a8;
  v25 = a9;
  v27 = 0;
  v11 = sub_408A70(a7, &v22);
  v31 = 0;
  v12 = sub_403A20((int)this, &v29, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v31 = -1;
  if ( v22 )
  {
    v13 = v22;
    std::_Lockit::_Lockit((std::_Lockit *)v26, 0);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 && v14 != -1 )
      *(_DWORD *)(v13 + 4) = v14 - 1;
    v15 = -(*(_DWORD *)(v13 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v26);
    v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
    if ( v16 )
      (**v16)(v16, 1);
  }
  v17 = &v30;
  if ( v29 != 45 )
    v17 = (int *)&v29;
  v18 = _Stoulx((int)v17, (int)&v23, v12, (int)&v27);
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v19 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_15;
LABEL_22:
    v20 = v28;
    *v28 |= 1u;
    goto LABEL_16;
  }
  if ( !a5 )
    goto LABEL_22;
LABEL_15:
  v20 = v28;
LABEL_16:
  if ( (int *)v23 == v17 || v27 )
  {
    *v20 |= 2u;
  }
  else
  {
    if ( v29 == 45 )
      v18 = -v18;
    *v25 = v18;
  }
  result = v24;
  *v24 = v19;
  result[1] = a4;
  return result;
}
// 402C50: using guessed type char var_3C[4];

//----- (00402DB0) --------------------------------------------------------
_DWORD *__thiscall sub_402DB0(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  int v17; // ecx
  _DWORD *v18; // eax
  int v20; // [esp+10h] [ebp-4Ch] BYREF
  int v21; // [esp+14h] [ebp-48h] BYREF
  int v22; // [esp+18h] [ebp-44h]
  _DWORD *v23; // [esp+1Ch] [ebp-40h]
  char v24[4]; // [esp+20h] [ebp-3Ch] BYREF
  int v25; // [esp+24h] [ebp-38h] BYREF
  _DWORD *v26; // [esp+28h] [ebp-34h]
  char v27[32]; // [esp+2Ch] [ebp-30h] BYREF
  int v28; // [esp+58h] [ebp-4h]

  v9 = a7;
  v23 = a9;
  v26 = a8;
  v25 = 0;
  v11 = sub_408A70(a7, &v20);
  v28 = 0;
  v12 = sub_403A20((int)this, v27, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v22 = _Stolx((int)v27, (int)&v21, v12, (int)&v25);
  v28 = -1;
  if ( v20 )
  {
    v13 = v20;
    std::_Lockit::_Lockit((std::_Lockit *)v24, 0);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 && v14 != -1 )
      *(_DWORD *)(v13 + 4) = v14 - 1;
    v15 = -(*(_DWORD *)(v13 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v24);
    v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
    if ( v16 )
      (**v16)(v16, 1);
  }
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v17 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_13;
LABEL_18:
    v18 = v26;
    *v26 |= 1u;
    goto LABEL_14;
  }
  if ( !a5 )
    goto LABEL_18;
LABEL_13:
  v18 = v26;
LABEL_14:
  if ( (char *)v21 == v27 || v25 )
    *v18 |= 2u;
  else
    *v23 = v22;
  a2[1] = a4;
  *a2 = v17;
  return a2;
}
// 402DB0: using guessed type _BYTE var_30[32];
// 402DB0: using guessed type char var_3C[4];

//----- (00402F00) --------------------------------------------------------
_DWORD *__thiscall sub_402F00(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  int v17; // ecx
  _DWORD *v18; // eax
  int v20; // [esp+10h] [ebp-4Ch] BYREF
  int v21; // [esp+14h] [ebp-48h] BYREF
  int v22; // [esp+18h] [ebp-44h]
  _DWORD *v23; // [esp+1Ch] [ebp-40h]
  char v24[4]; // [esp+20h] [ebp-3Ch] BYREF
  int v25; // [esp+24h] [ebp-38h] BYREF
  _DWORD *v26; // [esp+28h] [ebp-34h]
  char v27[32]; // [esp+2Ch] [ebp-30h] BYREF
  int v28; // [esp+58h] [ebp-4h]

  v9 = a7;
  v23 = a9;
  v26 = a8;
  v25 = 0;
  v11 = sub_408A70(a7, &v20);
  v28 = 0;
  v12 = sub_403A20((int)this, v27, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v22 = _Stoulx((int)v27, (int)&v21, v12, (int)&v25);
  v28 = -1;
  if ( v20 )
  {
    v13 = v20;
    std::_Lockit::_Lockit((std::_Lockit *)v24, 0);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 && v14 != -1 )
      *(_DWORD *)(v13 + 4) = v14 - 1;
    v15 = -(*(_DWORD *)(v13 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v24);
    v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
    if ( v16 )
      (**v16)(v16, 1);
  }
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v17 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_13;
LABEL_18:
    v18 = v26;
    *v26 |= 1u;
    goto LABEL_14;
  }
  if ( !a5 )
    goto LABEL_18;
LABEL_13:
  v18 = v26;
LABEL_14:
  if ( (char *)v21 == v27 || v25 )
    *v18 |= 2u;
  else
    *v23 = v22;
  a2[1] = a4;
  *a2 = v17;
  return a2;
}
// 402F00: using guessed type _BYTE var_30[32];
// 402F00: using guessed type char var_3C[4];

//----- (00403050) --------------------------------------------------------
_DWORD *__thiscall sub_403050(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // edi
  int v15; // eax
  int v16; // esi
  void (__thiscall ***v17)(_DWORD, int); // esi
  int v18; // ecx
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *result; // eax
  _DWORD *v22; // [esp+Ch] [ebp-58h]
  int v23; // [esp+10h] [ebp-54h] BYREF
  int v24; // [esp+14h] [ebp-50h] BYREF
  _DWORD *v25; // [esp+18h] [ebp-4Ch]
  _DWORD *v26; // [esp+1Ch] [ebp-48h]
  int v27; // [esp+20h] [ebp-44h] BYREF
  int v28; // [esp+24h] [ebp-40h]
  int v29; // [esp+28h] [ebp-3Ch]
  char v30[4]; // [esp+2Ch] [ebp-38h] BYREF
  char v31[32]; // [esp+30h] [ebp-34h] BYREF
  int v32; // [esp+60h] [ebp-4h]

  v9 = a7;
  v26 = a2;
  v22 = a8;
  v25 = a9;
  v23 = 0;
  v11 = sub_408A70(a7, &v27);
  v32 = 0;
  v12 = sub_403A20((int)this, v31, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v28 = _Stollx((int)v31, (int)&v24, v12, (int)&v23);
  v32 = -1;
  v29 = v13;
  if ( v27 )
  {
    v14 = v27;
    std::_Lockit::_Lockit((std::_Lockit *)v30, 0);
    v15 = *(_DWORD *)(v14 + 4);
    if ( v15 && v15 != -1 )
      *(_DWORD *)(v14 + 4) = v15 - 1;
    v16 = -(*(_DWORD *)(v14 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v30);
    v17 = (void (__thiscall ***)(_DWORD, int))(v14 & v16);
    if ( v17 )
      (**v17)(v17, 1);
  }
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v18 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_13;
LABEL_18:
    v19 = v22;
    *v22 |= 1u;
    goto LABEL_14;
  }
  if ( !a5 )
    goto LABEL_18;
LABEL_13:
  v19 = v22;
LABEL_14:
  if ( (char *)v24 == v31 || v23 )
  {
    *v19 |= 2u;
  }
  else
  {
    v20 = v25;
    *v25 = v28;
    v20[1] = v29;
  }
  result = v26;
  *v26 = v18;
  result[1] = a4;
  return result;
}
// 403100: variable 'v13' is possibly undefined
// 403050: using guessed type _BYTE var_34[32];
// 403050: using guessed type char var_38[4];

//----- (004031E0) --------------------------------------------------------
_DWORD *__thiscall sub_4031E0(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // edi
  int v15; // eax
  int v16; // esi
  void (__thiscall ***v17)(_DWORD, int); // esi
  int v18; // ecx
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *result; // eax
  _DWORD *v22; // [esp+Ch] [ebp-58h]
  int v23; // [esp+10h] [ebp-54h] BYREF
  int v24; // [esp+14h] [ebp-50h] BYREF
  _DWORD *v25; // [esp+18h] [ebp-4Ch]
  _DWORD *v26; // [esp+1Ch] [ebp-48h]
  int v27; // [esp+20h] [ebp-44h] BYREF
  int v28; // [esp+24h] [ebp-40h]
  int v29; // [esp+28h] [ebp-3Ch]
  char v30[4]; // [esp+2Ch] [ebp-38h] BYREF
  char v31[32]; // [esp+30h] [ebp-34h] BYREF
  int v32; // [esp+60h] [ebp-4h]

  v9 = a7;
  v26 = a2;
  v22 = a8;
  v25 = a9;
  v23 = 0;
  v11 = sub_408A70(a7, &v27);
  v32 = 0;
  v12 = sub_403A20((int)this, v31, (int)&a3, &a5, (__int16)v9[5], (int)v11);
  v28 = _Stoullx((int)v31, (int)&v24, v12, (int)&v23);
  v32 = -1;
  v29 = v13;
  if ( v27 )
  {
    v14 = v27;
    std::_Lockit::_Lockit((std::_Lockit *)v30, 0);
    v15 = *(_DWORD *)(v14 + 4);
    if ( v15 && v15 != -1 )
      *(_DWORD *)(v14 + 4) = v15 - 1;
    v16 = -(*(_DWORD *)(v14 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v30);
    v17 = (void (__thiscall ***)(_DWORD, int))(v14 & v16);
    if ( v17 )
      (**v17)(v17, 1);
  }
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v18 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_13;
LABEL_18:
    v19 = v22;
    *v22 |= 1u;
    goto LABEL_14;
  }
  if ( !a5 )
    goto LABEL_18;
LABEL_13:
  v19 = v22;
LABEL_14:
  if ( (char *)v24 == v31 || v23 )
  {
    *v19 |= 2u;
  }
  else
  {
    v20 = v25;
    *v25 = v28;
    v20[1] = v29;
  }
  result = v26;
  *v26 = v18;
  result[1] = a4;
  return result;
}
// 403290: variable 'v13' is possibly undefined
// 4031E0: using guessed type _BYTE var_34[32];
// 4031E0: using guessed type char var_38[4];

//----- (00403370) --------------------------------------------------------
_DWORD *__userpurge sub_403370@<eax>(
        _Cvtvec *a1@<ecx>,
        double a2@<st0>,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        char a7,
        int a8,
        _DWORD *a9,
        float *a10)
{
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // eax
  char *EndPtr; // [esp+14h] [ebp-54h] BYREF
  float *v15; // [esp+18h] [ebp-50h]
  int v16; // [esp+1Ch] [ebp-4Ch] BYREF
  float v17; // [esp+20h] [ebp-48h]
  float v18; // [esp+24h] [ebp-44h] BYREF
  char String[60]; // [esp+28h] [ebp-40h] BYREF

  v10 = a9;
  v15 = a10;
  v16 = 0;
  v18 = 0.0;
  v11 = sub_403FF0(a1, String, (int)&a4, (int)&a6, a8, (int)&v18);
  _Stofx(String, &EndPtr, v11, (int)&v16);
  v17 = a2;
  if ( v18 != 0.0 )
  {
    v18 = ldexp(v17, 4 * LODWORD(v18));
    v17 = v18;
  }
  if ( !(_BYTE)a5 )
    sub_406BD0(&a4);
  if ( !a7 )
    sub_406BD0(&a6);
  v12 = a4;
  if ( !a4 )
  {
    if ( a6 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( a6 )
LABEL_11:
    *v10 |= 1u;
LABEL_12:
  if ( EndPtr == String || v16 )
    *v10 |= 2u;
  else
    *v15 = v17;
  *a3 = v12;
  a3[1] = a5;
  return a3;
}

//----- (00403470) --------------------------------------------------------
_DWORD *__userpurge sub_403470@<eax>(
        _Cvtvec *a1@<ecx>,
        double X@<st0>,
        _DWORD *a3,
        int a4,
        int a5,
        int a6,
        char a7,
        int a8,
        _DWORD *a9,
        double *a10)
{
  _DWORD *v10; // edi
  int v11; // eax
  int v12; // eax
  int v14; // [esp+34h] [ebp-58h] BYREF
  int v15; // [esp+38h] [ebp-54h] BYREF
  char *EndPtr; // [esp+3Ch] [ebp-50h] BYREF
  double *v17; // [esp+40h] [ebp-4Ch]
  double v18; // [esp+44h] [ebp-48h]
  char String[60]; // [esp+4Ch] [ebp-40h] BYREF

  v10 = a9;
  v17 = a10;
  v15 = 0;
  v14 = 0;
  v11 = sub_403FF0(a1, String, (int)&a4, (int)&a6, a8, (int)&v14);
  _Stodx(String, &EndPtr, v11, (int)&v15);
  v18 = X;
  if ( v14 )
    v18 = ldexp(X, 4 * v14);
  if ( !(_BYTE)a5 )
    sub_406BD0(&a4);
  if ( !a7 )
    sub_406BD0(&a6);
  v12 = a4;
  if ( !a4 )
  {
    if ( a6 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( a6 )
LABEL_11:
    *v10 |= 1u;
LABEL_12:
  if ( EndPtr == String || v15 )
    *v10 |= 2u;
  else
    *v17 = v18;
  *a3 = v12;
  a3[1] = a5;
  return a3;
}

//----- (00403580) --------------------------------------------------------
_DWORD *__thiscall sub_403580(
        _Cvtvec *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        char a6,
        int a7,
        _DWORD *a8,
        double *a9)
{
  _DWORD *v9; // edi
  int v10; // eax
  double X; // st7
  int v12; // eax
  int v14; // [esp+34h] [ebp-58h] BYREF
  int v15; // [esp+38h] [ebp-54h] BYREF
  __int16 *v16; // [esp+3Ch] [ebp-50h] BYREF
  double *v17; // [esp+40h] [ebp-4Ch]
  double v18; // [esp+44h] [ebp-48h]
  __int16 v19[30]; // [esp+4Ch] [ebp-40h] BYREF

  v9 = a8;
  v17 = a9;
  v15 = 0;
  v14 = 0;
  v10 = sub_403FF0(this, v19, (int)&a3, (int)&a5, a7, (int)&v14);
  X = _Stoldx(v19, &v16, v10, &v15);
  v18 = X;
  if ( v14 )
    v18 = ldexp(X, 4 * v14);
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v12 = a3;
  if ( !a3 )
  {
    if ( a5 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( a5 )
LABEL_11:
    *v9 |= 1u;
LABEL_12:
  if ( v16 == v19 || v15 )
    *v9 |= 2u;
  else
    *v17 = v18;
  *a2 = v12;
  a2[1] = a4;
  return a2;
}
// 427B7D: using guessed type double __cdecl _Stoldx(_DWORD, _DWORD, _DWORD, _DWORD);
// 403580: using guessed type _WORD var_40[30];

//----- (00403690) --------------------------------------------------------
int *__thiscall sub_403690(void *this, int a2, int a3, int a4, int a5, char a6, _DWORD **a7, _DWORD *a8, int *a9)
{
  int *v9; // edi
  _DWORD *v11; // eax
  int v12; // ebx
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  int v17; // esi
  int v18; // ecx
  _DWORD *v19; // eax
  _DWORD *v21; // [esp+14h] [ebp-58h]
  int v22; // [esp+18h] [ebp-54h] BYREF
  int v23; // [esp+1Ch] [ebp-50h] BYREF
  int v24; // [esp+20h] [ebp-4Ch] BYREF
  int *v25; // [esp+24h] [ebp-48h]
  int v26; // [esp+28h] [ebp-44h]
  int *v27; // [esp+30h] [ebp-3Ch]
  char v28[4]; // [esp+34h] [ebp-38h] BYREF
  char v29[32]; // [esp+38h] [ebp-34h] BYREF
  int v30; // [esp+68h] [ebp-4h]

  v9 = (int *)a2;
  v21 = a8;
  v25 = (int *)a2;
  v27 = a9;
  v22 = 0;
  v11 = sub_408A70(a7, &v23);
  v30 = 0;
  v12 = sub_403A20((int)this, v29, (int)&a3, &a5, 2048, (int)v11);
  v30 = -1;
  if ( v23 )
  {
    v13 = v23;
    std::_Lockit::_Lockit((std::_Lockit *)v28, 0);
    v14 = *(_DWORD *)(v13 + 4);
    if ( v14 && v14 != -1 )
      *(_DWORD *)(v13 + 4) = v14 - 1;
    v15 = -(*(_DWORD *)(v13 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v28);
    v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
    if ( v16 )
      (**v16)(v16, 1);
    v9 = v25;
  }
  v17 = _Stoulx((int)v29, (int)&v24, v12, (int)&v22);
  v26 = 0;
  if ( !(_BYTE)a4 )
    sub_406BD0(&a3);
  if ( !a6 )
    sub_406BD0(&a5);
  v18 = a3;
  if ( a3 )
  {
    if ( !a5 )
      goto LABEL_14;
LABEL_19:
    v19 = v21;
    *v21 |= 1u;
    goto LABEL_15;
  }
  if ( !a5 )
    goto LABEL_19;
LABEL_14:
  v19 = v21;
LABEL_15:
  if ( (char *)v24 == v29 || v22 )
    *v19 |= 2u;
  else
    *v27 = v17;
  *v9 = v18;
  v9[1] = a4;
  return v9;
}
// 403690: using guessed type _BYTE var_34[32];
// 403690: using guessed type char var_38[4];

//----- (00403810) --------------------------------------------------------
void *__thiscall sub_403810(void *this, char a2)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';

//----- (00403840) --------------------------------------------------------
_DWORD *__stdcall sub_403840(_DWORD *a1)
{
  _DWORD *v1; // edi
  int v2; // ebx
  int v3; // eax
  char v5[4]; // [esp+10h] [ebp-10h] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  *a1 = &std::wstreambuf::`vftable';
  std::_Mutex::_Mutex((std::_Mutex *)(a1 + 1));
  v6 = 0;
  v1 = operator new(4u);
  if ( v1 )
  {
    *v1 = std::locale::_Init();
    v2 = sub_426E4C();
    std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
    v3 = *(_DWORD *)(v2 + 4);
    if ( v3 != -1 )
      *(_DWORD *)(v2 + 4) = v3 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)v5);
  }
  else
  {
    v1 = 0;
  }
  a1[4] = a1 + 2;
  a1[8] = a1 + 6;
  a1[9] = a1 + 7;
  a1[14] = v1;
  a1[5] = a1 + 3;
  a1[12] = a1 + 10;
  a1[13] = a1 + 11;
  a1[3] = 0;
  *(_DWORD *)a1[9] = 0;
  *(_DWORD *)a1[13] = 0;
  *(_DWORD *)a1[4] = 0;
  *(_DWORD *)a1[8] = 0;
  *(_DWORD *)a1[12] = 0;
  return a1;
}
// 4CBADC: using guessed type void *std::wstreambuf::`vftable';
// 403840: using guessed type char var_10[4];

//----- (00403930) --------------------------------------------------------
int *__userpurge sub_403930@<eax>(unsigned int a1@<eax>, int a2@<esi>, void *Src)
{
  int *result; // eax
  int v5; // edi
  signed int v6; // ebx
  bool v7; // zf
  int v8; // ecx
  int v9; // ebx
  int pExceptionObject[3]; // [esp+4h] [ebp-Ch] BYREF

  result = (int *)(*(_DWORD *)(a2 + 64) & 6);
  if ( (_BYTE)result != 6 )
  {
    v5 = 0;
    if ( a1 )
    {
      if ( a1 > 0x7FFFFFFF || (v5 = (int)operator new(2 * a1)) == 0 )
      {
        Src = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&Src);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
    v6 = 2 * a1;
    memcpy_0((void *)v5, Src, v6);
    v7 = (*(_BYTE *)(a2 + 64) & 4) == 0;
    result = (int *)(v6 + v5);
    *(_DWORD *)(a2 + 60) = v6 + v5;
    if ( v7 )
    {
      **(_DWORD **)(a2 + 16) = v5;
      **(_DWORD **)(a2 + 32) = v5;
      **(_DWORD **)(a2 + 48) = v6 >> 1;
    }
    v8 = *(_DWORD *)(a2 + 64);
    if ( (v8 & 2) == 0 )
    {
      if ( (v8 & 0x10) == 0 )
        result = (int *)v5;
      **(_DWORD **)(a2 + 20) = v5;
      v9 = v6 - (_DWORD)result;
      **(_DWORD **)(a2 + 36) = result;
      result = *(int **)(a2 + 52);
      *result = (v5 + v9) >> 1;
      if ( !**(_DWORD **)(a2 + 32) )
      {
        **(_DWORD **)(a2 + 16) = v5;
        result = *(int **)(a2 + 32);
        *result = 0;
        **(_DWORD **)(a2 + 48) = v5 >> 1;
      }
    }
    *(_DWORD *)(a2 + 64) |= 1u;
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00403A20) --------------------------------------------------------
int __cdecl sub_403A20(int a1, _BYTE *a2, int a3, _WORD *a4, __int16 a5, int a6)
{
  struct std::locale::facet *v6; // edi
  _Cvtvec *v7; // edi
  bool v8; // zf
  _DWORD *v9; // ebx
  __int16 v10; // bx
  _BYTE *v11; // eax
  __int16 v12; // bx
  int v13; // eax
  _DWORD *v14; // ebx
  size_t v15; // edi
  __int16 v16; // bx
  __int16 v17; // bx
  int v18; // ebx
  _DWORD **v19; // ecx
  __int16 **v20; // eax
  __int16 v21; // ax
  _WORD *v22; // edx
  int v23; // ecx
  __int16 **v24; // eax
  __int16 v25; // ax
  _DWORD **v26; // ecx
  void **v27; // eax
  __int16 **v28; // eax
  __int16 v29; // ax
  void **v30; // eax
  void **v31; // eax
  void **v32; // eax
  _DWORD **v33; // ecx
  int *v34; // eax
  __int16 **v35; // ecx
  __int16 *v36; // eax
  __int16 v37; // ax
  void **v38; // edx
  void *v39; // edi
  unsigned int v40; // esi
  char v41; // cl
  void **v42; // eax
  void **v43; // eax
  _BYTE *v44; // eax
  int v46; // [esp-18h] [ebp-A0h]
  wchar_t v47; // [esp-Ch] [ebp-94h]
  __int16 v48; // [esp+18h] [ebp-70h]
  wchar_t v49[2]; // [esp+1Ch] [ebp-6Ch] BYREF
  _WORD *v50; // [esp+20h] [ebp-68h]
  _BYTE *v51; // [esp+24h] [ebp-64h]
  mbstate_t v52; // [esp+28h] [ebp-60h] BYREF
  char v53; // [esp+33h] [ebp-55h]
  wchar_t v54[2]; // [esp+34h] [ebp-54h] BYREF
  unsigned __int8 v55; // [esp+3Bh] [ebp-4Dh]
  char v56[4]; // [esp+3Ch] [ebp-4Ch] BYREF
  void *v57[5]; // [esp+40h] [ebp-48h] BYREF
  unsigned int v58; // [esp+54h] [ebp-34h]
  void *v59[5]; // [esp+5Ch] [ebp-2Ch] BYREF
  unsigned int v60; // [esp+70h] [ebp-18h]
  int v61; // [esp+84h] [ebp-4h]

  v51 = a2;
  v50 = a4;
  v6 = sub_406D70(a6);
  sub_4068F0(v6, (int)v57);
  v61 = 0;
  if ( v57[4] )
    v48 = (*(int (__thiscall **)(struct std::locale::facet *))(*(_DWORD *)v6 + 8))(v6);
  else
    v48 = 0;
  v7 = (_Cvtvec *)(a1 + 8);
  *(_DWORD *)v49 = 0;
  *(_DWORD *)&v52._Byte = 0;
  v56[0] = 48;
  _Mbrtowc(v49, v56, 1u, (mbstate_t *)&v52._Byte, (const _Cvtvec *)(a1 + 8));
  v8 = *(_BYTE *)(a3 + 4) == 0;
  *(_DWORD *)&v52._Byte = v51;
  if ( v8 )
    sub_406BD0((_WORD *)a3);
  v9 = v50;
  if ( !*((_BYTE *)v50 + 4) )
    sub_406BD0(v50);
  if ( *(_DWORD *)a3 )
  {
    if ( *v9 )
      goto LABEL_21;
  }
  else if ( !*v9 )
  {
    goto LABEL_21;
  }
  if ( !*(_BYTE *)(a3 + 4) )
    sub_406BD0((_WORD *)a3);
  v10 = *(_WORD *)(a3 + 6);
  *(_DWORD *)v54 = 0;
  v52._Wchar = 0;
  v56[0] = 43;
  _Mbrtowc(v54, v56, 1u, &v52, v7);
  if ( v10 == v54[0] )
  {
    v11 = v51;
    *v51 = 43;
LABEL_20:
    *(_DWORD *)&v52._Byte = v11 + 1;
    sub_406890((_BYTE *)a3);
    goto LABEL_21;
  }
  if ( !*(_BYTE *)(a3 + 4) )
    sub_406BD0((_WORD *)a3);
  v12 = *(_WORD *)(a3 + 6);
  *(_DWORD *)v54 = 0;
  v52._Wchar = 0;
  v56[0] = 45;
  _Mbrtowc(v54, v56, 1u, &v52, v7);
  if ( v12 == v54[0] )
  {
    v11 = v51;
    *v51 = 45;
    goto LABEL_20;
  }
LABEL_21:
  v13 = a5 & 0xE00;
  if ( v13 == 1024 )
  {
    wcscpy(v54, L"\b");
  }
  else if ( v13 == 2048 )
  {
    wcscpy(v54, L"\x10");
  }
  else
  {
    *(_DWORD *)v54 = v13 != 0 ? 0xA : 0;
  }
  v8 = *(_BYTE *)(a3 + 4) == 0;
  v55 = 0;
  v53 = 0;
  if ( v8 )
    sub_406BD0((_WORD *)a3);
  v14 = v50;
  if ( !*((_BYTE *)v50 + 4) )
    sub_406BD0(v50);
  if ( *(_DWORD *)a3 )
  {
    if ( *v14 )
      goto LABEL_32;
  }
  else if ( !*v14 )
  {
    goto LABEL_32;
  }
  if ( !*(_BYTE *)(a3 + 4) )
    sub_406BD0((_WORD *)a3);
  if ( *(_WORD *)(a3 + 6) == v49[0] )
  {
    v55 = 1;
    sub_406890((_BYTE *)a3);
    if ( (unsigned __int8)sub_407260(a3, (int)v14) )
    {
      if ( !*(_BYTE *)(a3 + 4) )
        sub_406BD0((_WORD *)a3);
      v16 = *(_WORD *)(a3 + 6);
      *(_DWORD *)v49 = 0;
      v52._Wchar = 0;
      v56[0] = 120;
      _Mbrtowc(v49, v56, 1u, &v52, v7);
      if ( v16 == v49[0] )
        goto LABEL_47;
      if ( !*(_BYTE *)(a3 + 4) )
        sub_406BD0((_WORD *)a3);
      v17 = *(_WORD *)(a3 + 6);
      if ( v17 == sub_407D40(88, 0, v7) )
      {
LABEL_47:
        if ( !*(_DWORD *)v54 || *(_DWORD *)v54 == 16 )
        {
          wcscpy(v54, L"\x10");
          v55 = 0;
          sub_406890((_BYTE *)a3);
          goto LABEL_34;
        }
      }
    }
    if ( !*(_DWORD *)v54 )
    {
      wcscpy(v54, L"\b");
      goto LABEL_34;
    }
    goto LABEL_33;
  }
LABEL_32:
  if ( !*(_DWORD *)v54 )
  {
LABEL_51:
    v15 = 10;
    goto LABEL_52;
  }
LABEL_33:
  if ( *(_DWORD *)v54 == 10 )
    goto LABEL_51;
LABEL_34:
  v15 = *(_DWORD *)v54 != 8 ? 22 : 8;
LABEL_52:
  v60 = 15;
  LOWORD(v59[0]) = v55;
  v59[4] = (void *)1;
  LOBYTE(v61) = 1;
  v18 = 0;
  while ( 1 )
  {
    if ( !*(_BYTE *)(a3 + 4) )
    {
      v19 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v20 = (__int16 **)v19[8], !*v20) || (int)*v19[12] <= 0 ? (v21 = ((int (__thiscall *)(_DWORD **))(*v19)[6])(v19)) : (v21 = **v20),
            v21 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v21;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    v22 = v50;
    if ( !*((_BYTE *)v50 + 4) )
    {
      v23 = *(_DWORD *)v50;
      if ( !*(_DWORD *)v50
        || ((v24 = *(__int16 ***)(v23 + 32), !*v24) || **(int **)(v23 + 48) <= 0 ? (v25 = (*(int (__thiscall **)(int))(*(_DWORD *)v23 + 24))(v23)) : (v25 = **v24),
            v22 = v50,
            v25 == -1) )
      {
        *(_DWORD *)v22 = 0;
      }
      else
      {
        v50[3] = v25;
      }
      *((_BYTE *)v22 + 4) = 1;
    }
    v26 = *(_DWORD ***)a3;
    if ( *(_DWORD *)a3 )
    {
      if ( *(_DWORD *)v22 )
        goto LABEL_75;
    }
    else if ( !*(_DWORD *)v22 )
    {
      goto LABEL_75;
    }
    if ( !*(_BYTE *)(a3 + 4) )
    {
      if ( !v26
        || ((v28 = (__int16 **)v26[8], !*v28) || (int)*v26[12] <= 0 ? (v29 = ((int (__thiscall *)(_DWORD **))(*v26)[6])(v26)) : (v29 = **v28),
            v29 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v29;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    v47 = *(_WORD *)(a3 + 6);
    v56[0] = 0;
    v52._Wchar = 0;
    _Wcrtomb(v56, v47, &v52, (const _Cvtvec *)(a1 + 8));
    v46 = v56[0];
    **(_BYTE **)&v52._Byte = v56[0];
    if ( !memchr("0123456789abcdefABCDEF", v46, v15) )
      break;
    if ( (v53 || **(_BYTE **)&v52._Byte != 48) && *(_DWORD *)&v52._Byte < (unsigned int)(v51 + 31) )
    {
      ++*(_DWORD *)&v52._Byte;
      v53 = 1;
    }
    v30 = (void **)v59[0];
    v55 = 1;
    if ( v60 < 0x10 )
      v30 = v59;
    if ( *((_BYTE *)v30 + v18) != 127 )
    {
      v31 = (void **)v59[0];
      if ( v60 < 0x10 )
        v31 = v59;
      ++*((_BYTE *)v31 + v18);
    }
LABEL_110:
    v33 = *(_DWORD ***)a3;
    if ( !*(_DWORD *)a3
      || (!*v33[8] || (v34 = v33[12], *v34 <= 0) ? (v37 = ((int (__thiscall *)(_DWORD **))(*v33)[7])(v33)) : (--*v34, v35 = (__int16 **)v33[8], v36 = *v35, ++*v35, v37 = *v36),
          v37 == -1) )
    {
      *(_DWORD *)a3 = 0;
      *(_BYTE *)(a3 + 4) = 1;
    }
    else
    {
      *(_BYTE *)(a3 + 4) = 0;
    }
  }
  v32 = (void **)v59[0];
  if ( v60 < 0x10 )
    v32 = v59;
  if ( *((_BYTE *)v32 + v18) && v48 )
  {
    if ( !*(_BYTE *)(a3 + 4) )
      sub_406BD0((_WORD *)a3);
    if ( *(_WORD *)(a3 + 6) == v48 )
    {
      sub_405360(v59, 1u, 0);
      ++v18;
      goto LABEL_110;
    }
  }
LABEL_75:
  if ( v18 )
  {
    v27 = (void **)v59[0];
    if ( v60 < 0x10 )
      v27 = v59;
    if ( *((char *)v27 + v18) <= 0 )
      v55 = 0;
    else
      ++v18;
  }
  v38 = (void **)v57[0];
  if ( v58 < 0x10 )
    v38 = v57;
  v39 = v59[0];
  v40 = v60;
  if ( v55 )
  {
    while ( v18 )
    {
      v41 = *(_BYTE *)v38;
      if ( *(_BYTE *)v38 == 127 )
        break;
      if ( --v18 )
      {
        v42 = (void **)v59[0];
        if ( v60 < 0x10 )
          v42 = v59;
        if ( v41 != *((_BYTE *)v42 + v18) )
          goto LABEL_136;
      }
      if ( !v18 )
      {
        v43 = (void **)v59[0];
        if ( v60 < 0x10 )
          v43 = v59;
        if ( v41 < *(char *)v43 )
          goto LABEL_136;
      }
      if ( *((char *)v38 + 1) > 0 )
        v38 = (void **)((char *)v38 + 1);
    }
    v44 = *(_BYTE **)&v52._Byte;
    if ( !v53 )
    {
      **(_BYTE **)&v52._Byte = 48;
      ++v44;
    }
  }
  else
  {
LABEL_136:
    v44 = v51;
  }
  *v44 = 0;
  if ( v40 >= 0x10 )
    operator delete(v39);
  if ( v58 >= 0x10 )
    operator delete(v57[0]);
  return *(_DWORD *)v54;
}
// 403A20: using guessed type char var_4C[4];

//----- (00403FF0) --------------------------------------------------------
int __cdecl sub_403FF0(_Cvtvec *a1, _WORD *a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  _DWORD *v8; // eax
  unsigned int Wchar; // ebx
  int v10; // eax
  int v11; // edi
  void (__thiscall ***v12)(_DWORD, int); // edi
  int v13; // edi
  const _Cvtvec *p_Isclocale; // ebx
  bool v15; // zf
  __int16 v16; // di
  int v17; // eax
  __int16 v18; // di
  int v19; // edi
  void **v20; // eax
  void **v21; // eax
  unsigned int v22; // ebx
  int v23; // edi
  char *v24; // ecx
  void **v25; // eax
  void **v26; // eax
  void **v27; // eax
  void **v28; // eax
  void **v29; // edx
  char v30; // cl
  void **v31; // eax
  void **v32; // eax
  int v33; // ebx
  _DWORD *v34; // ecx
  int *v35; // ebx
  char *v36; // eax
  _DWORD *v37; // ecx
  __int16 **v38; // eax
  __int16 v39; // ax
  __int16 **v40; // eax
  __int16 v41; // ax
  wchar_t v42; // bx
  char *v43; // eax
  int v44; // ecx
  __int16 **v45; // eax
  __int16 v46; // ax
  _DWORD *v47; // ecx
  __int16 **v48; // eax
  __int16 v49; // ax
  __int16 v50; // di
  char v51; // dl
  char *v52; // eax
  _DWORD *v53; // ecx
  __int16 **v54; // eax
  __int16 v55; // ax
  int v56; // ecx
  __int16 **v57; // eax
  __int16 v58; // ax
  _DWORD *v59; // ecx
  wchar_t v60; // bx
  char *v61; // eax
  __int16 **v62; // eax
  __int16 v63; // ax
  _DWORD **v64; // ecx
  int *v65; // eax
  __int16 **v66; // ecx
  __int16 *v67; // eax
  __int16 v68; // ax
  int *v69; // edi
  _DWORD *v70; // ecx
  __int16 **v71; // eax
  __int16 v72; // ax
  int v73; // ecx
  __int16 **v74; // eax
  __int16 v75; // ax
  _DWORD *v76; // ecx
  _DWORD *v77; // ecx
  __int16 **v78; // eax
  __int16 v79; // ax
  __int16 **v80; // eax
  __int16 v81; // ax
  _DWORD *v82; // ecx
  __int16 **v83; // eax
  __int16 v84; // ax
  _DWORD *v85; // ecx
  __int16 **v86; // eax
  __int16 v87; // ax
  char *v88; // eax
  _DWORD **v89; // ecx
  int *v90; // edx
  __int16 **v91; // ecx
  __int16 *v92; // eax
  __int16 v93; // ax
  int v94; // ecx
  __int16 **v95; // eax
  __int16 v96; // ax
  _DWORD *v97; // ecx
  __int16 **v98; // eax
  __int16 v99; // ax
  _Cvtvec *v100; // ebx
  __int16 v101; // di
  _DWORD *v102; // ecx
  __int16 **v103; // eax
  __int16 v104; // ax
  __int16 v105; // di
  char *v106; // eax
  _DWORD **v107; // ecx
  int *v108; // eax
  __int16 **v109; // ecx
  __int16 *v110; // eax
  __int16 v111; // ax
  _DWORD *v112; // ecx
  __int16 **v113; // eax
  __int16 v114; // ax
  int v115; // edi
  int v116; // ecx
  __int16 **v117; // eax
  __int16 v118; // ax
  _DWORD *v119; // ecx
  __int16 **v120; // eax
  __int16 v121; // ax
  __int16 v122; // di
  char *v123; // eax
  _DWORD *v124; // ecx
  int *v125; // edx
  _WORD **v126; // ecx
  __int16 *v127; // eax
  __int16 v128; // ax
  _DWORD *v129; // ecx
  __int16 **v130; // eax
  __int16 v131; // ax
  __int16 v132; // di
  char *v133; // eax
  int *v134; // edx
  _WORD **v135; // ecx
  __int16 *v136; // eax
  int *v137; // edi
  char i; // bl
  _DWORD *v139; // ecx
  __int16 **v140; // eax
  __int16 v141; // ax
  int v142; // ecx
  __int16 **v143; // eax
  __int16 v144; // ax
  _DWORD *v145; // ecx
  char *v146; // ebx
  int v147; // edi
  _DWORD *v148; // ecx
  __int16 **v149; // eax
  __int16 v150; // ax
  __int16 **v151; // eax
  __int16 v152; // ax
  _DWORD **v153; // ecx
  int *v154; // edx
  __int16 **v155; // ecx
  __int16 *v156; // eax
  __int16 v157; // ax
  int v158; // edx
  int v159; // ecx
  __int16 **v160; // eax
  __int16 v161; // ax
  _DWORD *v162; // ecx
  char *v163; // eax
  __int16 **v164; // eax
  __int16 v165; // ax
  _DWORD *v166; // ecx
  __int16 **v167; // eax
  __int16 v168; // ax
  _DWORD **v169; // ecx
  int *v170; // eax
  __int16 **v171; // ecx
  __int16 *v172; // eax
  __int16 v173; // ax
  bool v174; // cf
  mbstate_t v175; // [esp+10h] [ebp-80h] BYREF
  _Cvtvec *v176; // [esp+18h] [ebp-78h]
  mbstate_t v177; // [esp+1Ch] [ebp-74h] BYREF
  int v178; // [esp+24h] [ebp-6Ch]
  wchar_t v179[2]; // [esp+28h] [ebp-68h] BYREF
  mbstate_t v180; // [esp+2Ch] [ebp-64h] BYREF
  wchar_t v181[2]; // [esp+34h] [ebp-5Ch] BYREF
  char v182[4]; // [esp+38h] [ebp-58h] BYREF
  char *v183; // [esp+3Ch] [ebp-54h]
  char v184[4]; // [esp+40h] [ebp-50h] BYREF
  char v185[4]; // [esp+44h] [ebp-4Ch] BYREF
  void *v186[5]; // [esp+48h] [ebp-48h] BYREF
  unsigned int v187; // [esp+5Ch] [ebp-34h]
  void *v188[5]; // [esp+64h] [ebp-2Ch] BYREF
  unsigned int v189; // [esp+78h] [ebp-18h]
  int v190; // [esp+8Ch] [ebp-4h]

  v176 = a1;
  v6 = *(_DWORD *)(a5 + 20) & 0x3000;
  *(_DWORD *)&v175._Byte = a2;
  *(_DWORD *)&v180._Byte = a4;
  if ( v6 == 12288 )
    return sub_405580((int)v176, a2, (int *)a3, a4, (_DWORD **)a5, a6);
  v8 = sub_408A70((_DWORD **)a5, &v177);
  v190 = 0;
  *(_DWORD *)v181 = sub_406D70((int)v8);
  v190 = -1;
  if ( v177._Wchar )
  {
    Wchar = v177._Wchar;
    std::_Lockit::_Lockit((std::_Lockit *)&v177._Byte, 0);
    v10 = *(_DWORD *)(Wchar + 4);
    if ( v10 && v10 != -1 )
      *(_DWORD *)(Wchar + 4) = v10 - 1;
    v11 = -(*(_DWORD *)(Wchar + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v177._Byte);
    v12 = (void (__thiscall ***)(_DWORD, int))(Wchar & v11);
    if ( v12 )
      (**v12)(v12, 1);
  }
  v13 = *(_DWORD *)&v180._Byte;
  sub_4068F0(*(void **)v181, (int)v186);
  p_Isclocale = (const _Cvtvec *)&v176->_Isclocale;
  v190 = 1;
  *(_DWORD *)v179 = 0;
  *(_DWORD *)&v177._Byte = 0;
  v182[0] = 48;
  v176 = (_Cvtvec *)((char *)v176 + 8);
  _Mbrtowc(v179, v182, 1u, (mbstate_t *)&v177._Byte, v176);
  v15 = *(_BYTE *)(a3 + 4) == 0;
  v183 = *(char **)&v175._Byte;
  v182[0] = 0;
  if ( v15 )
    sub_406BD0((_WORD *)a3);
  if ( !*(_BYTE *)(v13 + 4) )
    sub_406BD0((_WORD *)v13);
  if ( *(_DWORD *)a3 )
  {
    if ( *(_DWORD *)v13 )
      goto LABEL_26;
  }
  else if ( !*(_DWORD *)v13 )
  {
    goto LABEL_26;
  }
  if ( !*(_BYTE *)(a3 + 4) )
    sub_406BD0((_WORD *)a3);
  v16 = *(_WORD *)(a3 + 6);
  *(_DWORD *)&v177._Byte = 0;
  v180._Wchar = 0;
  v185[0] = 43;
  _Mbrtowc(&v177._Byte, v185, 1u, &v180, p_Isclocale);
  if ( v16 == v177._Byte )
  {
    v17 = *(_DWORD *)&v175._Byte;
    **(_BYTE **)&v175._Byte = 43;
  }
  else
  {
    if ( !*(_BYTE *)(a3 + 4) )
      sub_406BD0((_WORD *)a3);
    v18 = *(_WORD *)(a3 + 6);
    *(_DWORD *)&v177._Byte = 0;
    v180._Wchar = 0;
    v185[0] = 45;
    _Mbrtowc(&v177._Byte, v185, 1u, &v180, p_Isclocale);
    if ( v18 != v177._Byte )
      goto LABEL_26;
    v17 = *(_DWORD *)&v175._Byte;
    **(_BYTE **)&v175._Byte = 45;
  }
  v183 = (char *)(v17 + 1);
  sub_406890((_BYTE *)a3);
LABEL_26:
  v19 = 0;
  v185[0] = 0;
  v178 = 0;
  v180._Wchar = 0;
  v20 = (void **)v186[0];
  if ( v187 < 0x10 )
    v20 = v186;
  if ( *(_BYTE *)v20 == 127 )
    goto LABEL_91;
  v21 = (void **)v186[0];
  if ( v187 < 0x10 )
    v21 = v186;
  if ( *(char *)v21 <= 0 )
  {
LABEL_91:
    while ( 1 )
    {
      v33 = *(_DWORD *)&v180._Byte;
      if ( !*(_BYTE *)(a3 + 4) )
        sub_406BD0((_WORD *)a3);
      if ( !*(_BYTE *)(v33 + 4) )
        sub_406BD0((_WORD *)v33);
      v34 = *(_DWORD **)a3;
      if ( *(_DWORD *)a3 )
      {
        if ( *(_DWORD *)v33 )
          goto LABEL_97;
      }
      else if ( !*(_DWORD *)v33 )
      {
        goto LABEL_97;
      }
      if ( !*(_BYTE *)(a3 + 4) )
      {
        if ( !v34
          || ((v40 = (__int16 **)v34[8], !*v40) || *(int *)v34[12] <= 0 ? (v41 = (*(int (__thiscall **)(_DWORD *))(*v34 + 24))(v34)) : (v41 = **v40),
              v41 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          *(_WORD *)(a3 + 6) = v41;
        }
        *(_BYTE *)(a3 + 4) = 1;
      }
      v42 = v179[0];
      if ( v179[0] > *(_WORD *)(a3 + 6) )
        goto LABEL_97;
      if ( !*(_BYTE *)(a3 + 4) )
        sub_406BD0((_WORD *)a3);
      if ( *(unsigned __int16 *)(a3 + 6) > v42 + 9 )
      {
LABEL_97:
        v178 = v19;
        goto LABEL_98;
      }
      if ( v19 < 36 )
      {
        if ( !*(_BYTE *)(a3 + 4) )
          sub_406BD0((_WORD *)a3);
        if ( *(_WORD *)(a3 + 6) != v42 || v19 )
        {
          if ( !*(_BYTE *)(a3 + 4) )
            sub_406BD0((_WORD *)a3);
          v43 = v183;
          *v183 = *(_BYTE *)(a3 + 6) - v42 + 48;
          v183 = v43 + 1;
          ++v19;
        }
        v185[0] = 1;
        sub_406890((_BYTE *)a3);
      }
      else
      {
        ++v180._Wchar;
        v185[0] = 1;
        sub_406890((_BYTE *)a3);
      }
    }
  }
  if ( v186[4] )
    *(_DWORD *)&v177._Byte = (*(unsigned __int16 (__thiscall **)(_DWORD))(**(_DWORD **)v181 + 8))(*(_DWORD *)v181);
  else
    *(_DWORD *)&v177._Byte = 0;
  v22 = 15;
  v189 = 15;
  v188[4] = (void *)1;
  LOWORD(v188[0]) = 0;
  LOBYTE(v190) = 2;
  v23 = 0;
  if ( !(unsigned __int8)sub_407260(a3, *(int *)&v180._Byte) )
    goto LABEL_73;
  while ( 1 )
  {
    if ( !*(_BYTE *)(a3 + 4) )
      sub_406BD0((_WORD *)a3);
    if ( v179[0] > *(_WORD *)(a3 + 6) )
      break;
    if ( !*(_BYTE *)(a3 + 4) )
      sub_406BD0((_WORD *)a3);
    if ( *(unsigned __int16 *)(a3 + 6) > v179[0] + 9 )
      break;
    v185[0] = 1;
    if ( v178 < 36 )
    {
      if ( !*(_BYTE *)(a3 + 4) )
        sub_406BD0((_WORD *)a3);
      if ( *(_WORD *)(a3 + 6) != v179[0] || v178 )
      {
        if ( !*(_BYTE *)(a3 + 4) )
          sub_406BD0((_WORD *)a3);
        v24 = v183;
        *v183 = *(_WORD *)(a3 + 6) - LOBYTE(v179[0]) + 48;
        ++v178;
        v183 = v24 + 1;
      }
    }
    else
    {
      ++v180._Wchar;
    }
    v25 = (void **)v188[0];
    if ( v22 < 0x10 )
      v25 = v188;
    if ( *((_BYTE *)v25 + v23) == 127 )
      goto LABEL_66;
    v26 = (void **)v188[0];
    if ( v22 < 0x10 )
      v26 = v188;
    ++*((_BYTE *)v26 + v23);
LABEL_65:
    v22 = v189;
LABEL_66:
    sub_406890((_BYTE *)a3);
    if ( !(unsigned __int8)sub_407260(a3, *(int *)&v180._Byte) )
      goto LABEL_67;
  }
  v27 = (void **)v188[0];
  if ( v22 < 0x10 )
    v27 = v188;
  if ( *((_BYTE *)v27 + v23) && v177._Byte )
  {
    if ( !*(_BYTE *)(a3 + 4) )
      sub_406BD0((_WORD *)a3);
    if ( *(_WORD *)(a3 + 6) == v177._Byte )
    {
      sub_405360(v188, 1u, 0);
      ++v23;
      goto LABEL_65;
    }
  }
LABEL_67:
  if ( v23 )
  {
    v28 = (void **)v188[0];
    if ( v22 < 0x10 )
      v28 = v188;
    if ( *((char *)v28 + v23) <= 0 )
      v182[0] = 1;
    else
      ++v23;
  }
LABEL_73:
  v29 = (void **)v186[0];
  if ( v187 < 0x10 )
    v29 = v186;
  if ( !v182[0] )
  {
    while ( v23 )
    {
      v30 = *(_BYTE *)v29;
      if ( *(_BYTE *)v29 == 127 )
        break;
      if ( --v23 )
      {
        v31 = (void **)v188[0];
        if ( v22 < 0x10 )
          v31 = v188;
        if ( v30 != *((_BYTE *)v31 + v23) )
          goto LABEL_88;
      }
      if ( !v23 )
      {
        v32 = (void **)v188[0];
        if ( v22 < 0x10 )
          v32 = v188;
        if ( v30 < *(char *)v32 )
        {
LABEL_88:
          v182[0] = 1;
          break;
        }
      }
      if ( *((char *)v29 + 1) > 0 )
        v29 = (void **)((char *)v29 + 1);
    }
  }
  LOBYTE(v190) = 1;
  if ( v22 >= 0x10 )
    operator delete(v188[0]);
LABEL_98:
  v35 = *(int **)&v180._Byte;
  if ( v185[0] && !v178 )
  {
    v36 = v183;
    *v183 = 48;
    v183 = v36 + 1;
  }
  if ( !*(_BYTE *)(a3 + 4) )
  {
    v37 = *(_DWORD **)a3;
    if ( !*(_DWORD *)a3
      || ((v38 = (__int16 **)v37[8], !*v38) || *(int *)v37[12] <= 0 ? (v39 = (*(int (__thiscall **)(_DWORD *))(*v37 + 24))(v37)) : (v39 = **v38),
          v39 == -1) )
    {
      *(_DWORD *)a3 = 0;
    }
    else
    {
      *(_WORD *)(a3 + 6) = v39;
    }
    *(_BYTE *)(a3 + 4) = 1;
  }
  if ( !*((_BYTE *)v35 + 4) )
  {
    v44 = *v35;
    if ( !*v35
      || ((v45 = *(__int16 ***)(v44 + 32), !*v45) || **(int **)(v44 + 48) <= 0 ? (v46 = (*(int (__thiscall **)(int))(*(_DWORD *)v44 + 24))(v44)) : (v46 = **v45),
          v46 == -1) )
    {
      *v35 = 0;
    }
    else
    {
      *((_WORD *)v35 + 3) = v46;
    }
    *((_BYTE *)v35 + 4) = 1;
  }
  v47 = *(_DWORD **)a3;
  if ( *(_DWORD *)a3 )
  {
    if ( !*v35 )
      goto LABEL_150;
  }
  else if ( *v35 )
  {
LABEL_150:
    if ( !*(_BYTE *)(a3 + 4) )
    {
      if ( !v47
        || ((v48 = (__int16 **)v47[8], !*v48) || *(int *)v47[12] <= 0 ? (v49 = (*(int (__thiscall **)(_DWORD *))(*v47 + 24))(v47)) : (v49 = **v48),
            v49 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v49;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    v50 = *(_WORD *)(a3 + 6);
    if ( v50 == (*(unsigned __int16 (**)(void))(**(_DWORD **)v181 + 4))() )
    {
      v51 = *localeconv()->decimal_point;
      v52 = v183;
      *v183 = v51;
      v183 = v52 + 1;
      sub_406890((_BYTE *)a3);
    }
  }
  if ( v178 )
  {
    v60 = v179[0];
    goto LABEL_209;
  }
  while ( 2 )
  {
    if ( !*(_BYTE *)(a3 + 4) )
    {
      v53 = *(_DWORD **)a3;
      if ( !*(_DWORD *)a3
        || ((v54 = (__int16 **)v53[8], !*v54) || *(int *)v53[12] <= 0 ? (v55 = (*(int (__thiscall **)(_DWORD *))(*v53 + 24))(v53)) : (v55 = **v54),
            v55 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v55;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    if ( !*((_BYTE *)v35 + 4) )
    {
      v56 = *v35;
      if ( !*v35
        || ((v57 = *(__int16 ***)(v56 + 32), !*v57) || **(int **)(v56 + 48) <= 0 ? (v58 = (*(int (__thiscall **)(int))(*(_DWORD *)v56 + 24))(v56)) : (v58 = **v57),
            v58 == -1) )
      {
        *v35 = 0;
      }
      else
      {
        *((_WORD *)v35 + 3) = v58;
      }
      *((_BYTE *)v35 + 4) = 1;
    }
    v59 = *(_DWORD **)a3;
    if ( !*(_DWORD *)a3 )
    {
      if ( !*v35 )
        break;
      goto LABEL_189;
    }
    if ( !*v35 )
    {
LABEL_189:
      if ( !*(_BYTE *)(a3 + 4) )
      {
        if ( !v59
          || ((v62 = (__int16 **)v59[8], !*v62) || *(int *)v59[12] <= 0 ? (v63 = (*(int (__thiscall **)(_DWORD *))(*v59 + 24))(v59)) : (v63 = **v62),
              v63 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          *(_WORD *)(a3 + 6) = v63;
        }
        *(_BYTE *)(a3 + 4) = 1;
      }
      v60 = v179[0];
      if ( *(_WORD *)(a3 + 6) != v179[0] )
        goto LABEL_186;
      v64 = *(_DWORD ***)a3;
      --v180._Wchar;
      v185[0] = 1;
      if ( !v64
        || (!*v64[8] || (v65 = v64[12], *v65 <= 0) ? (v68 = ((int (__thiscall *)(_DWORD **))(*v64)[7])(v64)) : (--*v65, v66 = (__int16 **)v64[8], v67 = *v66, ++*v66, v68 = *v67),
            v68 == -1) )
      {
        v35 = *(int **)&v180._Byte;
        *(_DWORD *)a3 = 0;
        *(_BYTE *)(a3 + 4) = 1;
      }
      else
      {
        v35 = *(int **)&v180._Byte;
        *(_BYTE *)(a3 + 4) = 0;
      }
      continue;
    }
    break;
  }
  v60 = v179[0];
LABEL_186:
  if ( (v180._Wchar & 0x80000000) != 0 )
  {
    v61 = v183;
    *v183 = 48;
    ++v180._Wchar;
    v183 = v61 + 1;
  }
LABEL_209:
  v69 = *(int **)&v180._Byte;
  *(_DWORD *)v181 = v178;
  while ( 1 )
  {
    if ( !*(_BYTE *)(a3 + 4) )
    {
      v70 = *(_DWORD **)a3;
      if ( !*(_DWORD *)a3
        || ((v71 = (__int16 **)v70[8], !*v71) || *(int *)v70[12] <= 0 ? (v72 = (*(int (__thiscall **)(_DWORD *))(*v70 + 24))(v70)) : (v72 = **v71),
            v72 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v72;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    if ( !*((_BYTE *)v69 + 4) )
    {
      v73 = *v69;
      if ( !*v69
        || ((v74 = *(__int16 ***)(v73 + 32), !*v74) || **(int **)(v73 + 48) <= 0 ? (v75 = (*(int (__thiscall **)(int))(*(_DWORD *)v73 + 24))(v73)) : (v75 = **v74),
            v75 == -1) )
      {
        *v69 = 0;
      }
      else
      {
        *((_WORD *)v69 + 3) = v75;
      }
      *((_BYTE *)v69 + 4) = 1;
    }
    v76 = *(_DWORD **)a3;
    if ( *(_DWORD *)a3 )
    {
      if ( *v69 )
        break;
    }
    else if ( !*v69 )
    {
      break;
    }
    if ( !*(_BYTE *)(a3 + 4) )
    {
      if ( !v76
        || ((v80 = (__int16 **)v76[8], !*v80) || *(int *)v76[12] <= 0 ? (v81 = (*(int (__thiscall **)(_DWORD *))(*v76 + 24))(v76)) : (v81 = **v80),
            v81 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v81;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    if ( v60 > *(_WORD *)(a3 + 6) )
      break;
    if ( !*(_BYTE *)(a3 + 4) )
    {
      v82 = *(_DWORD **)a3;
      if ( !*(_DWORD *)a3
        || ((v83 = (__int16 **)v82[8], !*v83) || *(int *)v82[12] <= 0 ? (v84 = (*(int (__thiscall **)(_DWORD *))(*v82 + 24))(v82)) : (v84 = **v83),
            v84 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v84;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    if ( *(unsigned __int16 *)(a3 + 6) > v60 + 9 )
      break;
    if ( *(int *)v181 < 36 )
    {
      if ( !*(_BYTE *)(a3 + 4) )
      {
        v85 = *(_DWORD **)a3;
        if ( !*(_DWORD *)a3
          || ((v86 = (__int16 **)v85[8], !*v86) || *(int *)v85[12] <= 0 ? (v87 = (*(int (__thiscall **)(_DWORD *))(*v85 + 24))(v85)) : (v87 = **v86),
              v87 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          *(_WORD *)(a3 + 6) = v87;
        }
        *(_BYTE *)(a3 + 4) = 1;
      }
      v88 = v183;
      *v183 = *(_BYTE *)(a3 + 6) - v60 + 48;
      ++*(_DWORD *)v181;
      v183 = v88 + 1;
    }
    v89 = *(_DWORD ***)a3;
    v185[0] = 1;
    if ( !v89
      || (!*v89[8] || (v90 = v89[12], *v90 <= 0) ? (v93 = ((int (__thiscall *)(_DWORD **))(*v89)[7])(v89)) : (--*v90, v91 = (__int16 **)v89[8], v92 = *v91, ++*v91, v93 = *v92),
          v93 == -1) )
    {
      *(_DWORD *)a3 = 0;
      *(_BYTE *)(a3 + 4) = 1;
    }
    else
    {
      *(_BYTE *)(a3 + 4) = 0;
    }
  }
  if ( v185[0] )
  {
    if ( !*(_BYTE *)(a3 + 4) )
    {
      v77 = *(_DWORD **)a3;
      if ( !*(_DWORD *)a3
        || ((v78 = (__int16 **)v77[8], !*v78) || *(int *)v77[12] <= 0 ? (v79 = (*(int (__thiscall **)(_DWORD *))(*v77 + 24))(v77)) : (v79 = **v78),
            v79 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        *(_WORD *)(a3 + 6) = v79;
      }
      *(_BYTE *)(a3 + 4) = 1;
    }
    if ( !*((_BYTE *)v69 + 4) )
    {
      v94 = *v69;
      if ( !*v69
        || ((v95 = *(__int16 ***)(v94 + 32), !*v95) || **(int **)(v94 + 48) <= 0 ? (v96 = (*(int (__thiscall **)(int))(*(_DWORD *)v94 + 24))(v94)) : (v96 = **v95),
            v96 == -1) )
      {
        *v69 = 0;
      }
      else
      {
        *((_WORD *)v69 + 3) = v96;
      }
      *((_BYTE *)v69 + 4) = 1;
    }
    v97 = *(_DWORD **)a3;
    if ( *(_DWORD *)a3 )
    {
      if ( !*v69 )
        goto LABEL_300;
    }
    else if ( *v69 )
    {
LABEL_300:
      if ( !*(_BYTE *)(a3 + 4) )
      {
        if ( !v97
          || ((v98 = (__int16 **)v97[8], !*v98) || *(int *)v97[12] <= 0 ? (v99 = (*(int (__thiscall **)(_DWORD *))(*v97 + 24))(v97)) : (v99 = **v98),
              v99 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          *(_WORD *)(a3 + 6) = v99;
        }
        *(_BYTE *)(a3 + 4) = 1;
      }
      v100 = v176;
      v101 = *(_WORD *)(a3 + 6);
      *(_DWORD *)v181 = 0;
      v177._Wchar = 0;
      v184[0] = 101;
      _Mbrtowc(v181, v184, 1u, &v177, v176);
      if ( v101 == v181[0] )
        goto LABEL_322;
      if ( !*(_BYTE *)(a3 + 4) )
      {
        v102 = *(_DWORD **)a3;
        if ( !*(_DWORD *)a3
          || ((v103 = (__int16 **)v102[8], !*v103) || *(int *)v102[12] <= 0 ? (v104 = (*(int (__thiscall **)(_DWORD *))(*v102 + 24))(v102)) : (v104 = **v103),
              v104 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          *(_WORD *)(a3 + 6) = v104;
        }
        *(_BYTE *)(a3 + 4) = 1;
      }
      v105 = *(_WORD *)(a3 + 6);
      *(_DWORD *)v181 = 0;
      v177._Wchar = 0;
      v184[0] = 69;
      _Mbrtowc(v181, v184, 1u, &v177, v100);
      if ( v105 == v181[0] )
      {
LABEL_322:
        v106 = v183;
        *v183 = 101;
        v107 = *(_DWORD ***)a3;
        v183 = v106 + 1;
        if ( !v107
          || (!*v107[8] || (v108 = v107[12], *v108 <= 0) ? (v111 = ((int (__thiscall *)(_DWORD **))(*v107)[7])(v107)) : (--*v108, v109 = (__int16 **)v107[8], v110 = *v109, ++*v109, v111 = *v110),
              v111 == -1) )
        {
          *(_DWORD *)a3 = 0;
          *(_BYTE *)(a3 + 4) = 1;
        }
        else
        {
          *(_BYTE *)(a3 + 4) = 0;
        }
        v15 = *(_BYTE *)(a3 + 4) == 0;
        v185[0] = 0;
        v178 = 0;
        if ( v15 )
        {
          v112 = *(_DWORD **)a3;
          if ( !*(_DWORD *)a3
            || ((v113 = (__int16 **)v112[8], !*v113) || *(int *)v112[12] <= 0 ? (v114 = (*(int (__thiscall **)(_DWORD *))(*v112 + 24))(v112)) : (v114 = **v113),
                v114 == -1) )
          {
            *(_DWORD *)a3 = 0;
          }
          else
          {
            *(_WORD *)(a3 + 6) = v114;
          }
          *(_BYTE *)(a3 + 4) = 1;
        }
        v115 = *(_DWORD *)&v180._Byte;
        if ( !*(_BYTE *)(*(_DWORD *)&v180._Byte + 4) )
        {
          v116 = **(_DWORD **)&v180._Byte;
          if ( !**(_DWORD **)&v180._Byte
            || ((v117 = *(__int16 ***)(v116 + 32), !*v117) || **(int **)(v116 + 48) <= 0 ? (v118 = (*(int (__thiscall **)(int))(*(_DWORD *)v116 + 24))(v116)) : (v118 = **v117),
                v118 == -1) )
          {
            *(_DWORD *)v115 = 0;
          }
          else
          {
            *(_WORD *)(v115 + 6) = v118;
          }
          *(_BYTE *)(v115 + 4) = 1;
        }
        v119 = *(_DWORD **)a3;
        if ( *(_DWORD *)a3 )
        {
          if ( !*(_DWORD *)v115 )
            goto LABEL_354;
        }
        else if ( *(_DWORD *)v115 )
        {
LABEL_354:
          if ( !*(_BYTE *)(a3 + 4) )
          {
            if ( !v119
              || ((v120 = (__int16 **)v119[8], !*v120) || *(int *)v119[12] <= 0 ? (v121 = (*(int (__thiscall **)(_DWORD *))(*v119 + 24))(v119)) : (v121 = **v120),
                  v121 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v121;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          v122 = *(_WORD *)(a3 + 6);
          v184[0] = 43;
          *(_DWORD *)v181 = 0;
          v177._Wchar = 0;
          _Mbrtowc(v181, v184, 1u, &v177, v176);
          if ( v122 == v181[0] )
          {
            v123 = v183;
            *v183 = 43;
            v124 = *(_DWORD **)a3;
            v183 = v123 + 1;
            if ( v124 )
            {
              if ( *(_DWORD *)v124[8] )
              {
                v125 = (int *)v124[12];
                if ( *v125 > 0 )
                {
                  --*v125;
                  v126 = (_WORD **)v124[8];
                  v127 = (*v126)++;
                  v128 = *v127;
                  goto LABEL_385;
                }
              }
LABEL_384:
              v128 = (*(int (__thiscall **)(_DWORD *))(*v124 + 28))(v124);
              goto LABEL_385;
            }
            goto LABEL_387;
          }
          if ( !*(_BYTE *)(a3 + 4) )
          {
            v129 = *(_DWORD **)a3;
            if ( !*(_DWORD *)a3
              || ((v130 = (__int16 **)v129[8], !*v130) || *(int *)v129[12] <= 0 ? (v131 = (*(int (__thiscall **)(_DWORD *))(*v129 + 24))(v129)) : (v131 = **v130),
                  v131 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v131;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          v132 = *(_WORD *)(a3 + 6);
          *(_DWORD *)v181 = 0;
          v175._Wchar = 0;
          v184[0] = 45;
          _Mbrtowc(v181, v184, 1u, &v175, v176);
          if ( v132 == v181[0] )
          {
            v133 = v183;
            *v183 = 45;
            v124 = *(_DWORD **)a3;
            v183 = v133 + 1;
            if ( !v124 )
              goto LABEL_387;
            if ( !*(_DWORD *)v124[8] )
              goto LABEL_384;
            v134 = (int *)v124[12];
            if ( *v134 <= 0 )
              goto LABEL_384;
            --*v134;
            v135 = (_WORD **)v124[8];
            v136 = (*v135)++;
            v128 = *v136;
LABEL_385:
            if ( v128 == -1 )
            {
LABEL_387:
              *(_BYTE *)(a3 + 4) = 1;
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_BYTE *)(a3 + 4) = 0;
            }
          }
        }
        v137 = *(int **)&v180._Byte;
        for ( i = v185[0]; ; i = 1 )
        {
          if ( !*(_BYTE *)(a3 + 4) )
          {
            v139 = *(_DWORD **)a3;
            if ( !*(_DWORD *)a3
              || ((v140 = (__int16 **)v139[8], !*v140) || *(int *)v139[12] <= 0 ? (v141 = (*(int (__thiscall **)(_DWORD *))(*v139 + 24))(v139)) : (v141 = **v140),
                  v141 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v141;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          if ( !*((_BYTE *)v137 + 4) )
          {
            v142 = *v137;
            if ( !*v137
              || ((v143 = *(__int16 ***)(v142 + 32), !*v143) || **(int **)(v142 + 48) <= 0 ? (v144 = (*(int (__thiscall **)(int))(*(_DWORD *)v142 + 24))(v142)) : (v144 = **v143),
                  v144 == -1) )
            {
              *v137 = 0;
            }
            else
            {
              *((_WORD *)v137 + 3) = v144;
            }
            *((_BYTE *)v137 + 4) = 1;
          }
          v145 = *(_DWORD **)a3;
          if ( *(_DWORD *)a3 )
          {
            if ( *v137 )
              break;
          }
          else if ( !*v137 )
          {
            break;
          }
          if ( !*(_BYTE *)(a3 + 4) )
          {
            if ( !v145
              || ((v151 = (__int16 **)v145[8], !*v151) || *(int *)v145[12] <= 0 ? (v152 = (*(int (__thiscall **)(_DWORD *))(*v145 + 24))(v145)) : (v152 = **v151),
                  v152 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v152;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          if ( *(_WORD *)(a3 + 6) != v179[0] )
            break;
          v153 = *(_DWORD ***)a3;
          if ( !*(_DWORD *)a3
            || (!*v153[8] || (v154 = v153[12], *v154 <= 0) ? (v157 = ((int (__thiscall *)(_DWORD **))(*v153)[7])(v153)) : (--*v154, v155 = (__int16 **)v153[8], v156 = *v155, ++*v155, v157 = *v156),
                v157 == -1) )
          {
            *(_DWORD *)a3 = 0;
            *(_BYTE *)(a3 + 4) = 1;
          }
          else
          {
            *(_BYTE *)(a3 + 4) = 0;
          }
        }
        v185[0] = i;
        v15 = i == 0;
        v146 = v183;
        if ( !v15 )
        {
          *v183 = 48;
          ++v146;
        }
        v147 = v178;
        while ( 1 )
        {
          if ( !*(_BYTE *)(a3 + 4) )
          {
            v148 = *(_DWORD **)a3;
            if ( !*(_DWORD *)a3
              || ((v149 = (__int16 **)v148[8], !*v149) || *(int *)v148[12] <= 0 ? (v150 = (*(int (__thiscall **)(_DWORD *))(*v148 + 24))(v148)) : (v150 = **v149),
                  v150 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v150;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          v158 = *(_DWORD *)&v180._Byte;
          if ( !*(_BYTE *)(*(_DWORD *)&v180._Byte + 4) )
          {
            v159 = **(_DWORD **)&v180._Byte;
            if ( !**(_DWORD **)&v180._Byte
              || ((v160 = *(__int16 ***)(v159 + 32), !*v160) || **(int **)(v159 + 48) <= 0 ? (v161 = (*(int (__thiscall **)(int))(*(_DWORD *)v159 + 24))(v159)) : (v161 = **v160),
                  v161 == -1) )
            {
              v158 = *(_DWORD *)&v180._Byte;
              **(_DWORD **)&v180._Byte = 0;
            }
            else
            {
              v158 = *(_DWORD *)&v180._Byte;
              *(_WORD *)(*(_DWORD *)&v180._Byte + 6) = v161;
            }
            *(_BYTE *)(v158 + 4) = 1;
          }
          v162 = *(_DWORD **)a3;
          if ( *(_DWORD *)a3 )
          {
            if ( *(_DWORD *)v158 )
              break;
          }
          else if ( !*(_DWORD *)v158 )
          {
            break;
          }
          if ( !*(_BYTE *)(a3 + 4) )
          {
            if ( !v162
              || ((v164 = (__int16 **)v162[8], !*v164) || *(int *)v162[12] <= 0 ? (v165 = (*(int (__thiscall **)(_DWORD *))(*v162 + 24))(v162)) : (v165 = **v164),
                  v165 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v165;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          if ( v179[0] > *(_WORD *)(a3 + 6) )
            break;
          if ( !*(_BYTE *)(a3 + 4) )
          {
            v166 = *(_DWORD **)a3;
            if ( !*(_DWORD *)a3
              || ((v167 = (__int16 **)v166[8], !*v167) || *(int *)v166[12] <= 0 ? (v168 = (*(int (__thiscall **)(_DWORD *))(*v166 + 24))(v166)) : (v168 = **v167),
                  v168 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              *(_WORD *)(a3 + 6) = v168;
            }
            *(_BYTE *)(a3 + 4) = 1;
          }
          if ( *(unsigned __int16 *)(a3 + 6) > v179[0] + 9 )
            break;
          if ( v147 < 8 )
          {
            if ( !*(_BYTE *)(a3 + 4) )
              sub_406BD0((_WORD *)a3);
            *v146++ = *(_BYTE *)(a3 + 6) - LOBYTE(v179[0]) + 48;
            ++v147;
          }
          v169 = *(_DWORD ***)a3;
          v185[0] = 1;
          if ( !v169
            || (!*v169[8] || (v170 = v169[12], *v170 <= 0) ? (v173 = ((int (__thiscall *)(_DWORD **))(*v169)[7])(v169)) : (--*v170, v171 = (__int16 **)v169[8], v172 = *v171, ++*v171, v173 = *v172),
                v173 == -1) )
          {
            *(_DWORD *)a3 = 0;
            *(_BYTE *)(a3 + 4) = 1;
          }
          else
          {
            *(_BYTE *)(a3 + 4) = 0;
          }
        }
        v183 = v146;
      }
    }
  }
  if ( !v182[0] && v185[0] )
    v163 = v183;
  else
    v163 = *(char **)&v175._Byte;
  v174 = v187 < 0x10;
  *v163 = 0;
  if ( !v174 )
    operator delete(v186[0]);
  return v180._Wchar;
}
// 403FF0: using guessed type char var_58[4];
// 403FF0: using guessed type char var_4C[4];
// 403FF0: using guessed type char var_50[4];

//----- (004051A0) --------------------------------------------------------
int __thiscall sub_4051A0(void *this, int a2)
{
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 16))(this, a2);
  return a2;
}

//----- (004051C0) --------------------------------------------------------
int __thiscall sub_4051C0(void *this, int a2)
{
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 20))(this, a2);
  return a2;
}

//----- (00405200) --------------------------------------------------------
_DWORD *__thiscall sub_405200(_DWORD *this, _DWORD *a2)
{
  void *v2; // ecx

  v2 = (void *)this[2];
  a2[5] = 15;
  a2[4] = 0;
  *(_BYTE *)a2 = 0;
  sub_407C00(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (00405250) --------------------------------------------------------
_DWORD *__thiscall sub_405250(_DWORD *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = (void *)this[4];
  a2[5] = 7;
  a2[4] = 0;
  *(_WORD *)a2 = 0;
  sub_4094F0(a2, (int)v2, v2, wcslen((const unsigned __int16 *)v2));
  return a2;
}

//----- (004052B0) --------------------------------------------------------
_DWORD *__thiscall sub_4052B0(_DWORD *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = (void *)this[5];
  a2[5] = 7;
  a2[4] = 0;
  *(_WORD *)a2 = 0;
  sub_4094F0(a2, (int)v2, v2, wcslen((const unsigned __int16 *)v2));
  return a2;
}

//----- (00405310) --------------------------------------------------------
void *__thiscall sub_405310(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 2);
  *(_DWORD *)this = &std::numpunct<wchar_t>::`vftable';
  operator delete[](v4);
  operator delete[](*((void **)this + 4));
  operator delete[](*((void **)this + 5));
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE084: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (00405360) --------------------------------------------------------
_DWORD *__thiscall sub_405360(_DWORD *this, size_t Size, char a3)
{
  size_t v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // ecx
  bool v7; // cf
  _DWORD *result; // eax

  v4 = this[4];
  if ( -1 - v4 <= Size )
    std::_Xlength_error("string too long");
  if ( !Size )
    return this;
  v5 = v4 + Size;
  if ( v4 + Size == -1 )
    std::_Xlength_error("string too long");
  v6 = this[5];
  if ( v6 < v5 )
  {
    sub_4079E0((int)this, (void *)(v4 + Size), v4);
    if ( v5 )
    {
LABEL_8:
      sub_4077D0(this, this[4], Size, a3);
      v7 = this[5] < 0x10u;
      this[4] = v5;
      if ( !v7 )
      {
        *(_BYTE *)(*this + v5) = 0;
        return this;
      }
      *((_BYTE *)this + v5) = 0;
    }
    return this;
  }
  if ( v5 )
    goto LABEL_8;
  this[4] = 0;
  if ( v6 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (00405410) --------------------------------------------------------
int __thiscall sub_405410(_DWORD **this)
{
  _DWORD *v1; // eax
  struct std::locale::facet *v2; // eax
  int v3; // edi
  struct std::locale::facet *v4; // ebx
  int v5; // eax
  int v6; // esi
  void (__thiscall ***v7)(_DWORD, int); // esi
  char v9[4]; // [esp+14h] [ebp-14h] BYREF
  int v10; // [esp+18h] [ebp-10h] BYREF
  int v11; // [esp+24h] [ebp-4h]

  v1 = sub_408A70(this, &v10);
  v11 = 0;
  v2 = sub_408900((int)v1);
  v11 = -1;
  v3 = v10;
  v4 = v2;
  if ( v10 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 && v5 != -1 )
      *(_DWORD *)(v3 + 4) = v5 - 1;
    v6 = -(*(_DWORD *)(v3 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v9);
    v7 = (void (__thiscall ***)(_DWORD, int))(v3 & v6);
    if ( v7 )
      (**v7)(v7, 1);
  }
  return (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v4 + 40))(v4, 32);
}
// 405410: using guessed type char var_14[4];

//----- (004054C0) --------------------------------------------------------
int *__fastcall sub_4054C0(int *a1, int a2, unsigned int a3, unsigned __int16 a4)
{
  const void *v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // ecx
  bool v8; // cf
  int *result; // eax

  v5 = (const void *)a1[4];
  if ( -1 - (int)v5 <= a3 )
    std::_Xlength_error("string too long");
  if ( !a3 )
    return a1;
  v6 = (unsigned int)v5 + a3;
  if ( (unsigned int)v5 + a3 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v7 = a1[5];
  if ( v7 < v6 )
  {
    sub_409240((int)a1, (unsigned int)v5 + a3, v5);
    if ( v6 )
    {
LABEL_8:
      sub_406B10(a1, a2, a1[4], a3, a4);
      v8 = (unsigned int)a1[5] < 8;
      a1[4] = v6;
      if ( !v8 )
      {
        *(_WORD *)(*a1 + 2 * v6) = 0;
        return a1;
      }
      *((_WORD *)a1 + v6) = 0;
    }
    return a1;
  }
  if ( v6 )
    goto LABEL_8;
  a1[4] = 0;
  if ( v7 < 8 )
  {
    result = a1;
    *(_WORD *)a1 = 0;
  }
  else
  {
    *(_WORD *)*a1 = 0;
    return a1;
  }
  return result;
}
// 40551D: variable 'a2' is possibly undefined

//----- (00405580) --------------------------------------------------------
int __cdecl sub_405580(int a1, _WORD *a2, int *a3, int a4, _DWORD **a5, int a6)
{
  _WORD *v6; // ebx
  int *v7; // esi
  _DWORD *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // esi
  void (__thiscall ***v12)(_DWORD, int); // esi
  bool v13; // zf
  int v14; // edi
  __int16 v15; // di
  __int16 v16; // di
  _WORD *v17; // eax
  unsigned __int16 v18; // bx
  _BYTE *v19; // eax
  _Cvtvec *v20; // ebx
  __int16 v21; // di
  __int16 v22; // di
  void **v23; // eax
  void **v24; // eax
  int v25; // ebx
  void **v26; // eax
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // eax
  int v31; // edi
  _WORD *v32; // eax
  void **v33; // eax
  void **v34; // eax
  void **v35; // eax
  int v36; // esi
  void **v37; // edx
  char v38; // cl
  void **v39; // eax
  void **v40; // eax
  _WORD *v41; // eax
  int *v42; // edi
  int v43; // ecx
  __int16 **v44; // eax
  __int16 v45; // ax
  int v46; // ecx
  __int16 **v47; // eax
  __int16 v48; // ax
  int v49; // ecx
  __int16 **v50; // eax
  __int16 v51; // ax
  int v52; // ecx
  __int16 **v53; // eax
  __int16 v54; // ax
  int v55; // ecx
  int v56; // esi
  int v57; // edx
  int v58; // eax
  int v59; // edi
  _WORD *v60; // eax
  _DWORD **v61; // ecx
  int *v62; // edx
  __int16 **v63; // ecx
  __int16 *v64; // eax
  __int16 v65; // ax
  int *v66; // ebx
  int v67; // ecx
  __int16 **v68; // eax
  __int16 v69; // ax
  int v70; // ecx
  __int16 **v71; // eax
  __int16 v72; // ax
  __int16 v73; // si
  char *decimal_point; // ecx
  _WORD *v75; // eax
  _DWORD **v76; // ecx
  int *v77; // edx
  __int16 **v78; // ecx
  __int16 *v79; // eax
  __int16 v80; // ax
  int i; // esi
  int v82; // ecx
  __int16 **v83; // eax
  __int16 v84; // ax
  int v85; // ecx
  __int16 **v86; // eax
  __int16 v87; // ax
  int v88; // ecx
  _WORD *v89; // eax
  unsigned __int16 v90; // si
  int v91; // ecx
  __int16 **v92; // eax
  __int16 v93; // ax
  __int16 **v94; // eax
  __int16 v95; // ax
  _DWORD **v96; // ecx
  int *v97; // edx
  __int16 **v98; // ecx
  __int16 *v99; // eax
  __int16 v100; // ax
  int v101; // ecx
  __int16 **v102; // eax
  __int16 v103; // ax
  int v104; // ecx
  int v105; // ecx
  __int16 **v106; // eax
  __int16 v107; // ax
  __int16 **v108; // eax
  __int16 v109; // ax
  int v110; // ecx
  int v111; // eax
  int v112; // edx
  int v113; // eax
  char v114; // dl
  _WORD *v115; // eax
  _DWORD **v116; // ecx
  int *v117; // edx
  __int16 **v118; // ecx
  __int16 *v119; // eax
  __int16 v120; // ax
  int v121; // esi
  int v122; // ecx
  __int16 **v123; // eax
  __int16 v124; // ax
  int v125; // ecx
  __int16 **v126; // eax
  __int16 v127; // ax
  _Cvtvec *v128; // ebx
  __int16 v129; // si
  int v130; // ecx
  __int16 **v131; // eax
  __int16 v132; // ax
  __int16 v133; // si
  _WORD *v134; // eax
  _DWORD **v135; // ecx
  int *v136; // eax
  __int16 **v137; // ecx
  __int16 *v138; // eax
  __int16 v139; // ax
  int v140; // ecx
  __int16 **v141; // eax
  __int16 v142; // ax
  int v143; // esi
  int v144; // ecx
  __int16 **v145; // eax
  __int16 v146; // ax
  int v147; // ecx
  __int16 **v148; // eax
  __int16 v149; // ax
  __int16 v150; // si
  _WORD *v151; // eax
  _DWORD *v152; // ecx
  int *v153; // eax
  _WORD **v154; // ecx
  __int16 *v155; // eax
  __int16 v156; // ax
  int v157; // ecx
  __int16 **v158; // eax
  __int16 v159; // ax
  __int16 v160; // si
  _WORD *v161; // eax
  int *v162; // eax
  _WORD **v163; // ecx
  __int16 *v164; // eax
  int *v165; // esi
  int v166; // ecx
  __int16 **v167; // eax
  __int16 v168; // ax
  int v169; // ecx
  __int16 **v170; // eax
  __int16 v171; // ax
  int v172; // ecx
  _WORD *v173; // esi
  int v174; // ebx
  int v175; // ecx
  __int16 **v176; // eax
  __int16 v177; // ax
  __int16 **v178; // eax
  __int16 v179; // ax
  int v180; // edx
  int v181; // ecx
  __int16 **v182; // eax
  __int16 v183; // ax
  bool v184; // cf
  unsigned int *v185; // edx
  unsigned int Wchar; // eax
  int v188; // [esp+10h] [ebp-90h] BYREF
  unsigned int *v189; // [esp+14h] [ebp-8Ch]
  _WORD *v190; // [esp+18h] [ebp-88h]
  _Cvtvec *v191; // [esp+1Ch] [ebp-84h]
  wchar_t v192[2]; // [esp+20h] [ebp-80h] BYREF
  wchar_t v193[2]; // [esp+24h] [ebp-7Ch] BYREF
  mbstate_t v194; // [esp+28h] [ebp-78h] BYREF
  mbstate_t v195; // [esp+30h] [ebp-70h] BYREF
  wchar_t v196[2]; // [esp+38h] [ebp-68h] BYREF
  wchar_t v197[2]; // [esp+3Ch] [ebp-64h] BYREF
  mbstate_t v198; // [esp+40h] [ebp-60h] BYREF
  _WORD *v199; // [esp+48h] [ebp-58h]
  char v200[4]; // [esp+4Ch] [ebp-54h] BYREF
  char v201[4]; // [esp+50h] [ebp-50h] BYREF
  char v202[4]; // [esp+54h] [ebp-4Ch] BYREF
  void *v203[5]; // [esp+58h] [ebp-48h] BYREF
  unsigned int v204; // [esp+6Ch] [ebp-34h]
  void *v205[5]; // [esp+74h] [ebp-2Ch] BYREF
  unsigned int v206; // [esp+88h] [ebp-18h]
  int v207; // [esp+9Ch] [ebp-4h]

  v6 = a2;
  v7 = a3;
  *(_DWORD *)&v198._Byte = a4;
  v190 = a2;
  *(_DWORD *)&v194._Byte = a3;
  v189 = (unsigned int *)a6;
  v8 = sub_408A70(a5, &v188);
  v207 = 0;
  *(_DWORD *)v196 = sub_406D70((int)v8);
  v207 = -1;
  if ( v188 )
  {
    v9 = v188;
    std::_Lockit::_Lockit((std::_Lockit *)&v198, 0);
    v10 = *(_DWORD *)(v9 + 4);
    if ( v10 && v10 != -1 )
      *(_DWORD *)(v9 + 4) = v10 - 1;
    v11 = -(*(_DWORD *)(v9 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v198);
    v12 = (void (__thiscall ***)(_DWORD, int))(v9 & v11);
    if ( v12 )
      (**v12)(v12, 1);
    v6 = v190;
    v7 = *(int **)&v194._Byte;
  }
  sub_4068F0(*(void **)v196, (int)v203);
  v207 = 1;
  *(_DWORD *)v197 = 0;
  v198._Wchar = 0;
  v201[0] = 48;
  v191 = (_Cvtvec *)(a1 + 8);
  _Mbrtowc(v197, v201, 1u, &v198, (const _Cvtvec *)(a1 + 8));
  *(_DWORD *)v193 = 0;
  v198._Wchar = 0;
  v201[0] = 97;
  _Mbrtowc(v193, v201, 1u, &v198, (const _Cvtvec *)(a1 + 8));
  *(_DWORD *)v192 = 0;
  v198._Wchar = 0;
  v201[0] = 65;
  _Mbrtowc(v192, v201, 1u, &v198, (const _Cvtvec *)(a1 + 8));
  v13 = *((_BYTE *)v7 + 4) == 0;
  v199 = v6;
  v201[0] = 0;
  if ( v13 )
    sub_406BD0(v7);
  v14 = *(_DWORD *)&v198._Byte;
  if ( !*(_BYTE *)(*(_DWORD *)&v198._Byte + 4) )
    sub_406BD0(*(_WORD **)&v198._Byte);
  if ( *v7 )
  {
    if ( *(_DWORD *)v14 )
      goto LABEL_26;
  }
  else if ( !*(_DWORD *)v14 )
  {
    goto LABEL_26;
  }
  if ( !*((_BYTE *)v7 + 4) )
    sub_406BD0(v7);
  v15 = *((_WORD *)v7 + 3);
  v198._Wchar = 0;
  v195._Wchar = 0;
  v202[0] = 43;
  _Mbrtowc((wchar_t *)&v198, v202, 1u, &v195, v191);
  if ( v15 == LOWORD(v198._Wchar) )
  {
    *(_BYTE *)v6 = 43;
  }
  else
  {
    if ( !*((_BYTE *)v7 + 4) )
      sub_406BD0(v7);
    v16 = *((_WORD *)v7 + 3);
    v198._Wchar = 0;
    v195._Wchar = 0;
    v202[0] = 45;
    _Mbrtowc((wchar_t *)&v198, v202, 1u, &v195, v191);
    if ( v16 != LOWORD(v198._Wchar) )
      goto LABEL_25;
    *(_BYTE *)v6 = 45;
  }
  v199 = (_WORD *)((char *)v6 + 1);
  sub_406890(v7);
LABEL_25:
  v14 = *(_DWORD *)&v198._Byte;
LABEL_26:
  v17 = v199;
  *v199 = 30768;
  v199 = v17 + 1;
  v202[0] = 0;
  *(_DWORD *)&v195._Byte = 0;
  v195._Wchar = 0;
  if ( !*((_BYTE *)v7 + 4) )
    sub_406BD0(v7);
  if ( !*(_BYTE *)(v14 + 4) )
    sub_406BD0((_WORD *)v14);
  if ( *v7 )
  {
    if ( *(_DWORD *)v14 )
      goto LABEL_47;
  }
  else if ( !*(_DWORD *)v14 )
  {
    goto LABEL_47;
  }
  if ( !*((_BYTE *)v7 + 4) )
    sub_406BD0(v7);
  v18 = v197[0];
  if ( *((_WORD *)v7 + 3) != v197[0] )
    goto LABEL_48;
  v19 = sub_406890(v7);
  if ( !(unsigned __int8)sub_407260((int)v19, v14) )
    goto LABEL_45;
  if ( !*((_BYTE *)v7 + 4) )
    sub_406BD0(v7);
  v20 = v191;
  v21 = *((_WORD *)v7 + 3);
  v198._Wchar = 0;
  v194._Wchar = 0;
  v200[0] = 120;
  _Mbrtowc((wchar_t *)&v198, v200, 1u, &v194, v191);
  if ( v21 == LOWORD(v198._Wchar) )
    goto LABEL_44;
  if ( !*((_BYTE *)v7 + 4) )
    sub_406BD0(v7);
  v22 = *((_WORD *)v7 + 3);
  if ( v22 == sub_407D40(88, 0, v20) )
LABEL_44:
    sub_406890(v7);
  else
LABEL_45:
    v202[0] = 1;
  v14 = *(_DWORD *)&v198._Byte;
LABEL_47:
  v18 = v197[0];
LABEL_48:
  v23 = (void **)v203[0];
  if ( v204 < 0x10 )
    v23 = v203;
  if ( *(_BYTE *)v23 == 127 )
    goto LABEL_521;
  v24 = (void **)v203[0];
  if ( v204 < 0x10 )
    v24 = v203;
  if ( *(char *)v24 <= 0 )
  {
LABEL_521:
    while ( 1 )
    {
      if ( !*((_BYTE *)v7 + 4) )
      {
        v46 = *v7;
        if ( !*v7
          || ((v47 = *(__int16 ***)(v46 + 32), !*v47) || **(int **)(v46 + 48) <= 0 ? (v48 = (*(int (__thiscall **)(int))(*(_DWORD *)v46 + 24))(v46)) : (v48 = **v47),
              v48 == -1) )
        {
          *v7 = 0;
        }
        else
        {
          *((_WORD *)v7 + 3) = v48;
        }
        *((_BYTE *)v7 + 4) = 1;
      }
      if ( !*(_BYTE *)(v14 + 4) )
      {
        v49 = *(_DWORD *)v14;
        if ( !*(_DWORD *)v14
          || ((v50 = *(__int16 ***)(v49 + 32), !*v50) || **(int **)(v49 + 48) <= 0 ? (v51 = (*(int (__thiscall **)(int))(*(_DWORD *)v49 + 24))(v49)) : (v51 = **v50),
              v51 == -1) )
        {
          *(_DWORD *)v14 = 0;
        }
        else
        {
          *(_WORD *)(v14 + 6) = v51;
        }
        *(_BYTE *)(v14 + 4) = 1;
      }
      v52 = *v7;
      if ( *v7 )
      {
        if ( *(_DWORD *)v14 )
          goto LABEL_122;
      }
      else if ( !*(_DWORD *)v14 )
      {
        goto LABEL_122;
      }
      if ( !*((_BYTE *)v7 + 4) )
      {
        if ( !v52
          || ((v53 = *(__int16 ***)(v52 + 32), !*v53) || **(int **)(v52 + 48) <= 0 ? (v54 = (*(int (__thiscall **)(int))(*(_DWORD *)v52 + 24))(v52)) : (v54 = **v53),
              v54 == -1) )
        {
          *v7 = 0;
        }
        else
        {
          *((_WORD *)v7 + 3) = v54;
        }
        *((_BYTE *)v7 + 4) = 1;
      }
      v55 = *((unsigned __int16 *)v7 + 3);
      if ( v18 > (unsigned __int16)v55 || v55 > v18 + 9 )
      {
        if ( v193[0] > (unsigned __int16)v55 || (v57 = v193[0], v58 = *((unsigned __int16 *)v7 + 3), v55 > v193[0] + 5) )
        {
          if ( v192[0] > (unsigned __int16)v55 )
            goto LABEL_122;
          v57 = v192[0];
          v58 = *((unsigned __int16 *)v7 + 3);
          if ( v55 > v192[0] + 5 )
            goto LABEL_122;
        }
        v56 = v58 - v57 + 10;
      }
      else
      {
        v56 = v55 - v18;
      }
      if ( v56 < 0 )
        goto LABEL_122;
      v59 = *(_DWORD *)&v194._Byte;
      if ( *(int *)&v195._Byte < 36 )
      {
        if ( !*(_BYTE *)(*(_DWORD *)&v194._Byte + 4) )
          sub_406BD0(*(_WORD **)&v194._Byte);
        if ( *(_WORD *)(v59 + 6) != v18 || *(_DWORD *)&v195._Byte )
        {
          v60 = v199;
          *(_BYTE *)v199 = byte_4CB954[v56];
          ++*(_DWORD *)&v195._Byte;
          v199 = (_WORD *)((char *)v60 + 1);
        }
      }
      else
      {
        ++v195._Wchar;
      }
      v61 = *(_DWORD ***)v59;
      v202[0] = 1;
      if ( !v61
        || (!*v61[8] || (v62 = v61[12], *v62 <= 0) ? (v65 = ((int (__thiscall *)(_DWORD **))(*v61)[7])(v61)) : (--*v62, v63 = (__int16 **)v61[8], v64 = *v63, ++*v63, v65 = *v64),
            v65 == -1) )
      {
        *(_DWORD *)v59 = 0;
        *(_BYTE *)(v59 + 4) = 1;
      }
      else
      {
        *(_BYTE *)(v59 + 4) = 0;
      }
      v7 = *(int **)&v194._Byte;
      v14 = *(_DWORD *)&v198._Byte;
    }
  }
  if ( v203[4] )
    v198._Wchar = (*(unsigned __int16 (__thiscall **)(_DWORD))(**(_DWORD **)v196 + 8))(*(_DWORD *)v196);
  else
    v198._Wchar = 0;
  v206 = 15;
  v205[4] = (void *)1;
  LOWORD(v205[0]) = 0;
  LOBYTE(v207) = 2;
  v25 = 0;
  while ( 1 )
  {
    if ( !*((_BYTE *)v7 + 4) )
      sub_406BD0(v7);
    if ( !*(_BYTE *)(v14 + 4) )
      sub_406BD0((_WORD *)v14);
    if ( *v7 )
    {
      if ( *(_DWORD *)v14 )
        goto LABEL_64;
    }
    else if ( !*(_DWORD *)v14 )
    {
      goto LABEL_64;
    }
    if ( !*((_BYTE *)v7 + 4) )
      sub_406BD0(v7);
    v27 = *((unsigned __int16 *)v7 + 3);
    if ( v197[0] <= (unsigned __int16)v27 && v27 <= v197[0] + 9 )
    {
      v28 = v27 - v197[0];
      goto LABEL_80;
    }
    if ( v193[0] > (unsigned __int16)v27 || (v29 = v193[0], v30 = *((unsigned __int16 *)v7 + 3), v27 > v193[0] + 5) )
    {
      if ( v192[0] > (unsigned __int16)v27 )
        break;
      v29 = v192[0];
      v30 = *((unsigned __int16 *)v7 + 3);
      if ( v27 > v192[0] + 5 )
        break;
    }
    v28 = v30 - v29 + 10;
LABEL_80:
    if ( v28 < 0 )
      break;
    v31 = *(_DWORD *)&v194._Byte;
    v202[0] = 1;
    if ( *(int *)&v195._Byte < 36 )
    {
      if ( !*(_BYTE *)(*(_DWORD *)&v194._Byte + 4) )
        sub_406BD0(*(_WORD **)&v194._Byte);
      if ( *(_WORD *)(v31 + 6) != v197[0] || *(_DWORD *)&v195._Byte )
      {
        v32 = v199;
        *(_BYTE *)v199 = byte_4CB954[v28];
        ++*(_DWORD *)&v195._Byte;
        v199 = (_WORD *)((char *)v32 + 1);
      }
    }
    else
    {
      ++v195._Wchar;
    }
    v33 = (void **)v205[0];
    if ( v206 < 0x10 )
      v33 = v205;
    if ( *((_BYTE *)v33 + v25) == 127 )
    {
LABEL_102:
      sub_406890((_BYTE *)v31);
      v7 = *(int **)&v194._Byte;
      v14 = *(_DWORD *)&v198._Byte;
    }
    else
    {
      v34 = (void **)v205[0];
      if ( v206 < 0x10 )
        v34 = v205;
      ++*((_BYTE *)v34 + v25);
      sub_406890((_BYTE *)v31);
      v7 = *(int **)&v194._Byte;
      v14 = *(_DWORD *)&v198._Byte;
    }
  }
  v35 = (void **)v205[0];
  if ( v206 < 0x10 )
    v35 = v205;
  if ( *((_BYTE *)v35 + v25) && LOWORD(v198._Wchar) )
  {
    v36 = *(_DWORD *)&v194._Byte;
    if ( !*(_BYTE *)(*(_DWORD *)&v194._Byte + 4) )
      sub_406BD0(*(_WORD **)&v194._Byte);
    if ( *(_WORD *)(v36 + 6) == LOWORD(v198._Wchar) )
    {
      sub_405360(v205, 1u, 0);
      ++v25;
      v31 = v36;
      goto LABEL_102;
    }
  }
LABEL_64:
  if ( v25 )
  {
    v26 = (void **)v205[0];
    if ( v206 < 0x10 )
      v26 = v205;
    if ( *((char *)v26 + v25) <= 0 )
      v201[0] = 1;
    else
      ++v25;
  }
  v37 = (void **)v203[0];
  if ( v204 < 0x10 )
    v37 = v203;
  if ( !v201[0] )
  {
    while ( v25 )
    {
      v38 = *(_BYTE *)v37;
      if ( *(_BYTE *)v37 == 127 )
        break;
      if ( --v25 )
      {
        v39 = (void **)v205[0];
        if ( v206 < 0x10 )
          v39 = v205;
        if ( v38 != *((_BYTE *)v39 + v25) )
          goto LABEL_119;
      }
      if ( !v25 )
      {
        v40 = (void **)v205[0];
        if ( v206 < 0x10 )
          v40 = v205;
        if ( v38 < *(char *)v40 )
        {
LABEL_119:
          v201[0] = 1;
          break;
        }
      }
      if ( *((char *)v37 + 1) > 0 )
        v37 = (void **)((char *)v37 + 1);
    }
  }
  LOBYTE(v207) = 1;
  if ( v206 >= 0x10 )
    operator delete(v205[0]);
LABEL_122:
  if ( v202[0] && !*(_DWORD *)&v195._Byte )
  {
    v41 = v199;
    *(_BYTE *)v199 = 48;
    v199 = (_WORD *)((char *)v41 + 1);
  }
  v42 = *(int **)&v194._Byte;
  if ( !*(_BYTE *)(*(_DWORD *)&v194._Byte + 4) )
  {
    v43 = **(_DWORD **)&v194._Byte;
    if ( !**(_DWORD **)&v194._Byte
      || ((v44 = *(__int16 ***)(v43 + 32), !*v44) || **(int **)(v43 + 48) <= 0 ? (v45 = (*(int (__thiscall **)(int))(*(_DWORD *)v43 + 24))(v43)) : (v45 = **v44),
          v45 == -1) )
    {
      *v42 = 0;
    }
    else
    {
      *((_WORD *)v42 + 3) = v45;
    }
    *((_BYTE *)v42 + 4) = 1;
  }
  v66 = *(int **)&v198._Byte;
  if ( !*(_BYTE *)(*(_DWORD *)&v198._Byte + 4) )
  {
    v67 = **(_DWORD **)&v198._Byte;
    if ( !**(_DWORD **)&v198._Byte
      || ((v68 = *(__int16 ***)(v67 + 32), !*v68) || **(int **)(v67 + 48) <= 0 ? (v69 = (*(int (__thiscall **)(int))(*(_DWORD *)v67 + 24))(v67)) : (v69 = **v68),
          v69 == -1) )
    {
      *v66 = 0;
    }
    else
    {
      *((_WORD *)v66 + 3) = v69;
    }
    *((_BYTE *)v66 + 4) = 1;
  }
  v70 = *v42;
  if ( *v42 )
  {
    if ( !*v66 )
      goto LABEL_208;
  }
  else if ( *v66 )
  {
LABEL_208:
    if ( !*((_BYTE *)v42 + 4) )
    {
      if ( !v70
        || ((v71 = *(__int16 ***)(v70 + 32), !*v71) || **(int **)(v70 + 48) <= 0 ? (v72 = (*(int (__thiscall **)(int))(*(_DWORD *)v70 + 24))(v70)) : (v72 = **v71),
            v72 == -1) )
      {
        *v42 = 0;
      }
      else
      {
        *((_WORD *)v42 + 3) = v72;
      }
      *((_BYTE *)v42 + 4) = 1;
    }
    v73 = *((_WORD *)v42 + 3);
    if ( v73 == (*(unsigned __int16 (**)(void))(**(_DWORD **)v196 + 4))() )
    {
      decimal_point = localeconv()->decimal_point;
      v75 = v199;
      *(_BYTE *)v199 = *decimal_point;
      v76 = (_DWORD **)*v42;
      v199 = (_WORD *)((char *)v75 + 1);
      if ( !v76
        || (!*v76[8] || (v77 = v76[12], *v77 <= 0) ? (v80 = ((int (__thiscall *)(_DWORD **))(*v76)[7])(v76)) : (--*v77, v78 = (__int16 **)v76[8], v79 = *v78, ++*v78, v80 = *v79),
            v80 == -1) )
      {
        *v42 = 0;
        *((_BYTE *)v42 + 4) = 1;
      }
      else
      {
        *((_BYTE *)v42 + 4) = 0;
      }
    }
  }
  if ( !*(_DWORD *)&v195._Byte )
  {
    for ( i = v195._Wchar; ; --i )
    {
      if ( !*((_BYTE *)v42 + 4) )
      {
        v82 = *v42;
        if ( !*v42
          || ((v83 = *(__int16 ***)(v82 + 32), !*v83) || **(int **)(v82 + 48) <= 0 ? (v84 = (*(int (__thiscall **)(int))(*(_DWORD *)v82 + 24))(v82)) : (v84 = **v83),
              v84 == -1) )
        {
          *v42 = 0;
        }
        else
        {
          *((_WORD *)v42 + 3) = v84;
        }
        *((_BYTE *)v42 + 4) = 1;
      }
      if ( !*((_BYTE *)v66 + 4) )
      {
        v85 = *v66;
        if ( !*v66
          || ((v86 = *(__int16 ***)(v85 + 32), !*v86) || **(int **)(v85 + 48) <= 0 ? (v87 = (*(int (__thiscall **)(int))(*(_DWORD *)v85 + 24))(v85)) : (v87 = **v86),
              v87 == -1) )
        {
          *v66 = 0;
        }
        else
        {
          *((_WORD *)v66 + 3) = v87;
        }
        *((_BYTE *)v66 + 4) = 1;
      }
      v88 = *v42;
      if ( *v42 )
      {
        if ( *v66 )
          break;
      }
      else if ( !*v66 )
      {
        break;
      }
      if ( !*((_BYTE *)v42 + 4) )
      {
        if ( !v88
          || ((v94 = *(__int16 ***)(v88 + 32), !*v94) || **(int **)(v88 + 48) <= 0 ? (v95 = (*(int (__thiscall **)(int))(*(_DWORD *)v88 + 24))(v88)) : (v95 = **v94),
              v95 == -1) )
        {
          *v42 = 0;
        }
        else
        {
          *((_WORD *)v42 + 3) = v95;
        }
        *((_BYTE *)v42 + 4) = 1;
      }
      if ( *((_WORD *)v42 + 3) != v197[0] )
        break;
      v96 = (_DWORD **)*v42;
      v202[0] = 1;
      if ( !v96
        || (!*v96[8] || (v97 = v96[12], *v97 <= 0) ? (v100 = ((int (__thiscall *)(_DWORD **))(*v96)[7])(v96)) : (--*v97, v98 = (__int16 **)v96[8], v99 = *v98, ++*v98, v100 = *v99),
            v100 == -1) )
      {
        *v42 = 0;
        *((_BYTE *)v42 + 4) = 1;
      }
      else
      {
        *((_BYTE *)v42 + 4) = 0;
      }
    }
    v195._Wchar = i;
    if ( i < 0 )
    {
      v89 = v199;
      *(_BYTE *)v199 = 48;
      v199 = (_WORD *)((char *)v89 + 1);
      v195._Wchar = i + 1;
    }
  }
  v90 = v192[0];
  while ( 2 )
  {
    if ( !*((_BYTE *)v42 + 4) )
    {
      v91 = *v42;
      if ( !*v42
        || ((v92 = *(__int16 ***)(v91 + 32), !*v92) || **(int **)(v91 + 48) <= 0 ? (v93 = (*(int (__thiscall **)(int))(*(_DWORD *)v91 + 24))(v91)) : (v93 = **v92),
            v93 == -1) )
      {
        *v42 = 0;
      }
      else
      {
        *((_WORD *)v42 + 3) = v93;
      }
      *((_BYTE *)v42 + 4) = 1;
    }
    if ( !*((_BYTE *)v66 + 4) )
    {
      v101 = *v66;
      if ( !*v66
        || ((v102 = *(__int16 ***)(v101 + 32), !*v102) || **(int **)(v101 + 48) <= 0 ? (v103 = (*(int (__thiscall **)(int))(*(_DWORD *)v101 + 24))(v101)) : (v103 = **v102),
            v103 == -1) )
      {
        *v66 = 0;
      }
      else
      {
        *((_WORD *)v66 + 3) = v103;
      }
      *((_BYTE *)v66 + 4) = 1;
    }
    v104 = *v42;
    if ( *v42 )
    {
      if ( *v66 )
        goto LABEL_296;
    }
    else if ( !*v66 )
    {
      goto LABEL_296;
    }
    if ( !*((_BYTE *)v42 + 4) )
    {
      if ( !v104
        || ((v108 = *(__int16 ***)(v104 + 32), !*v108) || **(int **)(v104 + 48) <= 0 ? (v109 = (*(int (__thiscall **)(int))(*(_DWORD *)v104 + 24))(v104)) : (v109 = **v108),
            v109 == -1) )
      {
        *v42 = 0;
      }
      else
      {
        *((_WORD *)v42 + 3) = v109;
      }
      *((_BYTE *)v42 + 4) = 1;
    }
    v110 = *((unsigned __int16 *)v42 + 3);
    if ( v197[0] <= (unsigned __int16)v110 )
    {
      v66 = *(int **)&v198._Byte;
      if ( v110 <= v197[0] + 9 )
      {
        v111 = v110 - v197[0];
LABEL_321:
        if ( v111 < 0 )
          goto LABEL_296;
        if ( *(int *)&v195._Byte < 36 )
        {
          v114 = byte_4CB954[v111];
          v115 = v199;
          *(_BYTE *)v199 = v114;
          ++*(_DWORD *)&v195._Byte;
          v199 = (_WORD *)((char *)v115 + 1);
        }
        v116 = (_DWORD **)*v42;
        v202[0] = 1;
        if ( !v116
          || (!*v116[8] || (v117 = v116[12], *v117 <= 0) ? (v120 = ((int (__thiscall *)(_DWORD **))(*v116)[7])(v116)) : (--*v117, v118 = (__int16 **)v116[8], v119 = *v118, ++*v118, v120 = *v119),
              v120 == -1) )
        {
          *v42 = 0;
          *((_BYTE *)v42 + 4) = 1;
        }
        else
        {
          *((_BYTE *)v42 + 4) = 0;
        }
        continue;
      }
    }
    break;
  }
  if ( v193[0] <= (unsigned __int16)v110
    && (v112 = v193[0], v113 = *((unsigned __int16 *)v42 + 3), v66 = *(int **)&v198._Byte, v110 <= v193[0] + 5)
    || v90 <= (unsigned __int16)v110 && (v112 = v90, v113 = *((unsigned __int16 *)v42 + 3), v113 <= v90 + 5) )
  {
    v111 = v113 - v112 + 10;
    goto LABEL_321;
  }
LABEL_296:
  if ( v202[0] )
  {
    if ( !*((_BYTE *)v42 + 4) )
    {
      v105 = *v42;
      if ( !*v42
        || ((v106 = *(__int16 ***)(v105 + 32), !*v106) || **(int **)(v105 + 48) <= 0 ? (v107 = (*(int (__thiscall **)(int))(*(_DWORD *)v105 + 24))(v105)) : (v107 = **v106),
            v107 == -1) )
      {
        *v42 = 0;
      }
      else
      {
        *((_WORD *)v42 + 3) = v107;
      }
      *((_BYTE *)v42 + 4) = 1;
    }
    v121 = *(_DWORD *)&v198._Byte;
    if ( !*(_BYTE *)(*(_DWORD *)&v198._Byte + 4) )
    {
      v122 = **(_DWORD **)&v198._Byte;
      if ( !**(_DWORD **)&v198._Byte
        || ((v123 = *(__int16 ***)(v122 + 32), !*v123) || **(int **)(v122 + 48) <= 0 ? (v124 = (*(int (__thiscall **)(int))(*(_DWORD *)v122 + 24))(v122)) : (v124 = **v123),
            v124 == -1) )
      {
        *(_DWORD *)v121 = 0;
      }
      else
      {
        *(_WORD *)(v121 + 6) = v124;
      }
      *(_BYTE *)(v121 + 4) = 1;
    }
    v125 = *v42;
    if ( *v42 )
    {
      if ( !*(_DWORD *)v121 )
        goto LABEL_351;
    }
    else if ( *(_DWORD *)v121 )
    {
LABEL_351:
      if ( !*((_BYTE *)v42 + 4) )
      {
        if ( !v125
          || ((v126 = *(__int16 ***)(v125 + 32), !*v126) || **(int **)(v125 + 48) <= 0 ? (v127 = (*(int (__thiscall **)(int))(*(_DWORD *)v125 + 24))(v125)) : (v127 = **v126),
              v127 == -1) )
        {
          *v42 = 0;
        }
        else
        {
          *((_WORD *)v42 + 3) = v127;
        }
        *((_BYTE *)v42 + 4) = 1;
      }
      v128 = v191;
      v129 = *((_WORD *)v42 + 3);
      *(_DWORD *)v196 = 0;
      v194._Wchar = 0;
      v200[0] = 112;
      _Mbrtowc(v196, v200, 1u, &v194, v191);
      if ( v129 == v196[0] )
        goto LABEL_373;
      if ( !*((_BYTE *)v42 + 4) )
      {
        v130 = *v42;
        if ( !*v42
          || ((v131 = *(__int16 ***)(v130 + 32), !*v131) || **(int **)(v130 + 48) <= 0 ? (v132 = (*(int (__thiscall **)(int))(*(_DWORD *)v130 + 24))(v130)) : (v132 = **v131),
              v132 == -1) )
        {
          *v42 = 0;
        }
        else
        {
          *((_WORD *)v42 + 3) = v132;
        }
        *((_BYTE *)v42 + 4) = 1;
      }
      v133 = *((_WORD *)v42 + 3);
      *(_DWORD *)v196 = 0;
      v194._Wchar = 0;
      v200[0] = 80;
      _Mbrtowc(v196, v200, 1u, &v194, v128);
      if ( v133 == v196[0] )
      {
LABEL_373:
        v134 = v199;
        *(_BYTE *)v199 = 112;
        v135 = (_DWORD **)*v42;
        v199 = (_WORD *)((char *)v134 + 1);
        if ( !v135
          || (!*v135[8] || (v136 = v135[12], *v136 <= 0) ? (v139 = ((int (__thiscall *)(_DWORD **))(*v135)[7])(v135)) : (--*v136, v137 = (__int16 **)v135[8], v138 = *v137, ++*v137, v139 = *v138),
              v139 == -1) )
        {
          *v42 = 0;
          *((_BYTE *)v42 + 4) = 1;
        }
        else
        {
          *((_BYTE *)v42 + 4) = 0;
        }
        v13 = *((_BYTE *)v42 + 4) == 0;
        v202[0] = 0;
        *(_DWORD *)&v195._Byte = 0;
        if ( v13 )
        {
          v140 = *v42;
          if ( !*v42
            || ((v141 = *(__int16 ***)(v140 + 32), !*v141) || **(int **)(v140 + 48) <= 0 ? (v142 = (*(int (__thiscall **)(int))(*(_DWORD *)v140 + 24))(v140)) : (v142 = **v141),
                v142 == -1) )
          {
            *v42 = 0;
          }
          else
          {
            *((_WORD *)v42 + 3) = v142;
          }
          *((_BYTE *)v42 + 4) = 1;
        }
        v143 = *(_DWORD *)&v198._Byte;
        if ( !*(_BYTE *)(*(_DWORD *)&v198._Byte + 4) )
        {
          v144 = **(_DWORD **)&v198._Byte;
          if ( !**(_DWORD **)&v198._Byte
            || ((v145 = *(__int16 ***)(v144 + 32), !*v145) || **(int **)(v144 + 48) <= 0 ? (v146 = (*(int (__thiscall **)(int))(*(_DWORD *)v144 + 24))(v144)) : (v146 = **v145),
                v146 == -1) )
          {
            *(_DWORD *)v143 = 0;
          }
          else
          {
            *(_WORD *)(v143 + 6) = v146;
          }
          *(_BYTE *)(v143 + 4) = 1;
        }
        v147 = *v42;
        if ( *v42 )
        {
          if ( !*(_DWORD *)v143 )
            goto LABEL_405;
        }
        else if ( *(_DWORD *)v143 )
        {
LABEL_405:
          if ( !*((_BYTE *)v42 + 4) )
          {
            if ( !v147
              || ((v148 = *(__int16 ***)(v147 + 32), !*v148) || **(int **)(v147 + 48) <= 0 ? (v149 = (*(int (__thiscall **)(int))(*(_DWORD *)v147 + 24))(v147)) : (v149 = **v148),
                  v149 == -1) )
            {
              *v42 = 0;
            }
            else
            {
              *((_WORD *)v42 + 3) = v149;
            }
            *((_BYTE *)v42 + 4) = 1;
          }
          v150 = *((_WORD *)v42 + 3);
          *(_DWORD *)v196 = 0;
          v194._Wchar = 0;
          v200[0] = 43;
          _Mbrtowc(v196, v200, 1u, &v194, v128);
          if ( v150 == v196[0] )
          {
            v151 = v199;
            *(_BYTE *)v199 = 43;
            v152 = (_DWORD *)*v42;
            v199 = (_WORD *)((char *)v151 + 1);
            if ( v152 )
            {
              if ( *(_DWORD *)v152[8] )
              {
                v153 = (int *)v152[12];
                if ( *v153 > 0 )
                {
                  --*v153;
                  v154 = (_WORD **)v152[8];
                  v155 = (*v154)++;
                  v156 = *v155;
                  goto LABEL_436;
                }
              }
LABEL_435:
              v156 = (*(int (__thiscall **)(_DWORD *))(*v152 + 28))(v152);
              goto LABEL_436;
            }
            goto LABEL_438;
          }
          if ( !*((_BYTE *)v42 + 4) )
          {
            v157 = *v42;
            if ( !*v42
              || ((v158 = *(__int16 ***)(v157 + 32), !*v158) || **(int **)(v157 + 48) <= 0 ? (v159 = (*(int (__thiscall **)(int))(*(_DWORD *)v157 + 24))(v157)) : (v159 = **v158),
                  v159 == -1) )
            {
              *v42 = 0;
            }
            else
            {
              *((_WORD *)v42 + 3) = v159;
            }
            *((_BYTE *)v42 + 4) = 1;
          }
          v160 = *((_WORD *)v42 + 3);
          *(_DWORD *)v196 = 0;
          v194._Wchar = 0;
          v200[0] = 45;
          _Mbrtowc(v196, v200, 1u, &v194, v128);
          if ( v160 == v196[0] )
          {
            v161 = v199;
            *(_BYTE *)v199 = 45;
            v152 = (_DWORD *)*v42;
            v199 = (_WORD *)((char *)v161 + 1);
            if ( !v152 )
              goto LABEL_438;
            if ( !*(_DWORD *)v152[8] )
              goto LABEL_435;
            v162 = (int *)v152[12];
            if ( *v162 <= 0 )
              goto LABEL_435;
            --*v162;
            v163 = (_WORD **)v152[8];
            v164 = (*v163)++;
            v156 = *v164;
LABEL_436:
            if ( v156 == -1 )
            {
LABEL_438:
              *((_BYTE *)v42 + 4) = 1;
              *v42 = 0;
            }
            else
            {
              *((_BYTE *)v42 + 4) = 0;
            }
          }
        }
        v165 = *(int **)&v198._Byte;
        while ( 1 )
        {
          if ( !*((_BYTE *)v42 + 4) )
          {
            v166 = *v42;
            if ( !*v42
              || ((v167 = *(__int16 ***)(v166 + 32), !*v167) || **(int **)(v166 + 48) <= 0 ? (v168 = (*(int (__thiscall **)(int))(*(_DWORD *)v166 + 24))(v166)) : (v168 = **v167),
                  v168 == -1) )
            {
              *v42 = 0;
            }
            else
            {
              *((_WORD *)v42 + 3) = v168;
            }
            *((_BYTE *)v42 + 4) = 1;
          }
          if ( !*((_BYTE *)v165 + 4) )
          {
            v169 = *v165;
            if ( !*v165
              || ((v170 = *(__int16 ***)(v169 + 32), !*v170) || **(int **)(v169 + 48) <= 0 ? (v171 = (*(int (__thiscall **)(int))(*(_DWORD *)v169 + 24))(v169)) : (v171 = **v170),
                  v171 == -1) )
            {
              *v165 = 0;
            }
            else
            {
              *((_WORD *)v165 + 3) = v171;
            }
            *((_BYTE *)v165 + 4) = 1;
          }
          v172 = *v42;
          if ( *v42 )
          {
            if ( *v165 )
              break;
          }
          else if ( !*v165 )
          {
            break;
          }
          if ( !*((_BYTE *)v42 + 4) )
          {
            if ( !v172
              || ((v178 = *(__int16 ***)(v172 + 32), !*v178) || **(int **)(v172 + 48) <= 0 ? (v179 = (*(int (__thiscall **)(int))(*(_DWORD *)v172 + 24))(v172)) : (v179 = **v178),
                  v179 == -1) )
            {
              *v42 = 0;
            }
            else
            {
              *((_WORD *)v42 + 3) = v179;
            }
            *((_BYTE *)v42 + 4) = 1;
          }
          if ( *((_WORD *)v42 + 3) != v197[0] )
            break;
          v202[0] = 1;
          sub_406890(v42);
        }
        v173 = v199;
        if ( v202[0] )
        {
          *(_BYTE *)v199 = 48;
          v173 = (_WORD *)((char *)v173 + 1);
        }
        v174 = *(_DWORD *)&v195._Byte;
        while ( 1 )
        {
          if ( !*((_BYTE *)v42 + 4) )
          {
            v175 = *v42;
            if ( !*v42
              || ((v176 = *(__int16 ***)(v175 + 32), !*v176) || **(int **)(v175 + 48) <= 0 ? (v177 = (*(int (__thiscall **)(int))(*(_DWORD *)v175 + 24))(v175)) : (v177 = **v176),
                  v177 == -1) )
            {
              *v42 = 0;
            }
            else
            {
              *((_WORD *)v42 + 3) = v177;
            }
            *((_BYTE *)v42 + 4) = 1;
          }
          v180 = *(_DWORD *)&v198._Byte;
          if ( !*(_BYTE *)(*(_DWORD *)&v198._Byte + 4) )
          {
            v181 = **(_DWORD **)&v198._Byte;
            if ( !**(_DWORD **)&v198._Byte
              || ((v182 = *(__int16 ***)(v181 + 32), !*v182) || **(int **)(v181 + 48) <= 0 ? (v183 = (*(int (__thiscall **)(int))(*(_DWORD *)v181 + 24))(v181)) : (v183 = **v182),
                  v180 = *(_DWORD *)&v198._Byte,
                  v183 == -1) )
            {
              *(_DWORD *)v180 = 0;
            }
            else
            {
              *(_WORD *)(*(_DWORD *)&v198._Byte + 6) = v183;
            }
            *(_BYTE *)(v180 + 4) = 1;
          }
          if ( *v42 )
          {
            if ( *(_DWORD *)v180 )
              break;
          }
          else if ( !*(_DWORD *)v180 )
          {
            break;
          }
          if ( !*((_BYTE *)v42 + 4) )
            sub_406BD0(v42);
          if ( v197[0] > *((_WORD *)v42 + 3) )
            break;
          if ( !*((_BYTE *)v42 + 4) )
            sub_406BD0(v42);
          if ( *((unsigned __int16 *)v42 + 3) > v197[0] + 9 )
            break;
          if ( v174 < 8 )
          {
            if ( !*((_BYTE *)v42 + 4) )
              sub_406BD0(v42);
            v173 = (_WORD *)((char *)v173 + 1);
            *((_BYTE *)v173 - 1) = *((_BYTE *)v42 + 6) - LOBYTE(v197[0]) + 48;
            ++v174;
          }
          v202[0] = 1;
          sub_406890(v42);
        }
        v199 = v173;
      }
    }
  }
  if ( v201[0] || !v202[0] )
    v199 = v190;
  v184 = v204 < 0x10;
  v185 = v189;
  Wchar = v195._Wchar;
  *(_BYTE *)v199 = 0;
  *v185 = Wchar;
  if ( !v184 )
    operator delete(v203[0]);
  return 0;
}
// 405580: using guessed type char var_50[4];
// 405580: using guessed type char var_4C[4];
// 405580: using guessed type char var_54[4];

//----- (00406890) --------------------------------------------------------
_BYTE *__thiscall sub_406890(_BYTE *this)
{
  _DWORD **v2; // ecx
  int *v3; // edx
  __int16 **v4; // ecx
  __int16 *v5; // eax
  __int16 v6; // ax

  v2 = *(_DWORD ***)this;
  if ( !v2
    || (!*v2[8] || (v3 = v2[12], *v3 <= 0) ? (v6 = ((int (__thiscall *)(_DWORD **))(*v2)[7])(v2)) : (--*v3, v4 = (__int16 **)v2[8], v5 = *v4, ++*v4, v6 = *v5),
        v6 == -1) )
  {
    *(_DWORD *)this = 0;
    this[4] = 1;
    return this;
  }
  else
  {
    this[4] = 0;
    return this;
  }
}

//----- (004068F0) --------------------------------------------------------
int __thiscall sub_4068F0(void *this, int a2)
{
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 12))(this, a2);
  return a2;
}

//----- (00406910) --------------------------------------------------------
void __thiscall sub_406910(void **this)
{
  operator delete[](this[2]);
  operator delete[](this[4]);
  operator delete[](this[5]);
}

//----- (00406940) --------------------------------------------------------
_DWORD *__thiscall sub_406940(_DWORD *this, size_t Size, char a3)
{
  size_t v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // eax
  bool v7; // cf

  if ( Size == -1 )
    std::_Xlength_error("string too long");
  v4 = this[5];
  if ( v4 < Size )
  {
    sub_4079E0((int)this, (void *)Size, this[4]);
    if ( !Size )
      return this;
LABEL_5:
    if ( Size == 1 )
    {
      if ( this[5] < 0x10u )
        *(_BYTE *)this = a3;
      else
        *(_BYTE *)*this = a3;
    }
    else
    {
      if ( this[5] < 0x10u )
        v6 = this;
      else
        v6 = (_DWORD *)*this;
      memset(v6, a3, Size);
    }
    v7 = this[5] < 0x10u;
    this[4] = Size;
    if ( !v7 )
    {
      *(_BYTE *)(*this + Size) = 0;
      return this;
    }
    *((_BYTE *)this + Size) = 0;
    return this;
  }
  if ( Size )
    goto LABEL_5;
  this[4] = 0;
  if ( v4 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}
// 40695C: conditional instruction was optimized away because %Size.4!=FFFFFFFF

//----- (00406A00) --------------------------------------------------------
_DWORD *__thiscall sub_406A00(_DWORD *this, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v4; // edx
  unsigned int v5; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  char *v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ecx
  _DWORD *v12; // ecx
  _DWORD *result; // eax
  _DWORD *v14; // eax
  bool v15; // cf

  v4 = a2;
  v5 = a2[4];
  if ( v5 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = a4;
  v8 = v5 - a3;
  if ( v8 < a4 )
    v7 = v8;
  v9 = (char *)this[4];
  if ( -1 - (int)v9 <= v7 )
    std::_Xlength_error("string too long");
  if ( !v7 )
    return this;
  v10 = (unsigned int)&v9[v7];
  if ( (unsigned int)&v9[v7] > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v11 = this[5];
  if ( v11 < v10 )
  {
    sub_409240((int)this, (unsigned int)&v9[v7], v9);
    v4 = a2;
    if ( v10 )
    {
LABEL_12:
      if ( v4[5] < 8u )
        v12 = v4;
      else
        v12 = (_DWORD *)*v4;
      if ( this[5] < 8u )
        v14 = this;
      else
        v14 = (_DWORD *)*this;
      memcpy_0((char *)v14 + 2 * this[4], (char *)v12 + 2 * a3, 2 * v7);
      v15 = this[5] < 8u;
      this[4] = v10;
      if ( !v15 )
      {
        *(_WORD *)(*this + 2 * v10) = 0;
        return this;
      }
      *((_WORD *)this + v10) = 0;
    }
    return this;
  }
  if ( v10 )
    goto LABEL_12;
  this[4] = 0;
  if ( v11 < 8 )
  {
    result = this;
    *(_WORD *)this = 0;
  }
  else
  {
    *(_WORD *)*this = 0;
    return this;
  }
  return result;
}

//----- (00406B10) --------------------------------------------------------
int *__fastcall sub_406B10(int *a1, int a2, int a3, unsigned int a4, unsigned __int16 a5)
{
  int *result; // eax
  char *v6; // edi
  unsigned __int16 *v7; // edi
  unsigned int i; // ecx

  result = a1;
  if ( a4 == 1 )
  {
    if ( (unsigned int)a1[5] >= 8 )
      result = (int *)*a1;
    *((_WORD *)result + a3) = a5;
  }
  else
  {
    if ( (unsigned int)a1[5] >= 8 )
      result = (int *)*a1;
    v6 = (char *)result + 2 * a3;
    if ( a4 )
    {
      result = (int *)((a5 << 16) | a5);
      memset32(v6, (int)result, a4 >> 1);
      v7 = (unsigned __int16 *)&v6[4 * (a4 >> 1)];
      for ( i = a4 & 1; i; --i )
        *v7++ = a5;
    }
  }
  return result;
}

//----- (00406B70) --------------------------------------------------------
void __thiscall sub_406B70(_BYTE *this)
{
  _DWORD **v2; // ecx
  int *v3; // edx
  __int16 **v4; // ecx
  __int16 *v5; // eax
  __int16 v6; // ax

  v2 = *(_DWORD ***)this;
  if ( !v2
    || (!*v2[8] || (v3 = v2[12], *v3 <= 0) ? (v6 = ((int (__thiscall *)(_DWORD **))(*v2)[7])(v2)) : (--*v3, v4 = (__int16 **)v2[8], v5 = *v4, ++*v4, v6 = *v5),
        v6 == -1) )
  {
    *(_DWORD *)this = 0;
    this[4] = 1;
  }
  else
  {
    this[4] = 0;
  }
}

//----- (00406BD0) --------------------------------------------------------
__int16 __thiscall sub_406BD0(_WORD *this)
{
  int v2; // ecx
  __int16 **v3; // eax
  __int16 result; // ax

  v2 = *(_DWORD *)this;
  if ( !v2
    || ((v3 = *(__int16 ***)(v2 + 32), !*v3) || **(int **)(v2 + 48) <= 0 ? (result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 24))(v2)) : (result = **v3),
        result == -1) )
  {
    result = this[3];
    *(_DWORD *)this = 0;
    *((_BYTE *)this + 4) = 1;
  }
  else
  {
    this[3] = result;
    *((_BYTE *)this + 4) = 1;
  }
  return result;
}

//----- (00406C30) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_406C30(int a1)
{
  int v1; // ebx
  int v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF7C8;
  v13 = (struct std::locale::facet *)dword_4EF7C8;
  if ( !dword_4F248C )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4F248C )
      dword_4F248C = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4F248C;
  v4 = *(_DWORD *)a1;
  if ( (unsigned int)dword_4F248C >= *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4F248C);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_4072C0(&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF7C8 = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF7C8: using guessed type int dword_4EF7C8;
// 4F248C: using guessed type int dword_4F248C;
// 406C30: using guessed type char var_18[4];
// 406C30: using guessed type char var_14[4];

//----- (00406D70) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_406D70(int a1)
{
  int v1; // ebx
  int v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF7CC;
  v13 = (struct std::locale::facet *)dword_4EF7CC;
  if ( !dword_4F2488 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4F2488 )
      dword_4F2488 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4F2488;
  v4 = *(_DWORD *)a1;
  if ( (unsigned int)dword_4F2488 >= *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4F2488);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_4073D0(&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF7CC = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF7CC: using guessed type int dword_4EF7CC;
// 4F2488: using guessed type int dword_4F2488;
// 406D70: using guessed type char var_18[4];
// 406D70: using guessed type char var_14[4];

//----- (00406EB0) --------------------------------------------------------
int __cdecl sub_406EB0(int a1, int a2, size_t Size, int a4)
{
  size_t v4; // edi
  int v5; // ecx
  __int16 v6; // ax
  int v7; // edx
  int v8; // esi
  size_t v9; // edi
  _WORD *v10; // ecx
  __int16 v11; // ax
  void **v12; // eax
  void **v13; // eax
  __int16 v14; // ax
  _DWORD **v15; // ecx
  __int16 **v16; // eax
  __int16 v17; // ax
  int v18; // ecx
  __int16 **v19; // eax
  __int16 v20; // ax
  _DWORD **v21; // ecx
  char v22; // cl
  void **v23; // eax
  __int16 **v24; // eax
  __int16 v25; // ax
  _DWORD **v26; // ecx
  __int16 **v27; // eax
  __int16 v28; // ax
  int v29; // ecx
  __int16 **v30; // eax
  __int16 v31; // ax
  _DWORD **v32; // ecx
  int *v34; // eax
  __int16 **v35; // ecx
  __int16 *v36; // eax
  __int16 v37; // ax
  int v38; // [esp+10h] [ebp-3Ch]
  unsigned int v39; // [esp+14h] [ebp-38h]
  char v40; // [esp+1Fh] [ebp-2Dh]
  void *v41[5]; // [esp+20h] [ebp-2Ch] BYREF
  unsigned int v42; // [esp+34h] [ebp-18h]
  int v43; // [esp+48h] [ebp-4h]

  v4 = Size;
  v5 = 0;
  if ( *(_WORD *)a4 )
  {
    v6 = *(_WORD *)a4;
    do
    {
      if ( v6 == *(_WORD *)a4 )
        ++v4;
      v6 = *(_WORD *)(a4 + 2 * v5++ + 2);
    }
    while ( v6 );
    Size = v4;
  }
  v42 = 15;
  v41[4] = 0;
  LOBYTE(v41[0]) = 0;
  sub_406940(v41, v4, 0);
  v7 = a2;
  v43 = 0;
  v38 = -2;
  v39 = 1;
  while ( 2 )
  {
    v8 = 0;
    v9 = 0;
    v40 = 0;
    if ( !Size )
      break;
    do
    {
      v10 = (_WORD *)a4;
      v11 = *(_WORD *)(a4 + 2 * v8);
      if ( v11 )
      {
        do
        {
          if ( v11 == *(_WORD *)a4 )
            break;
          v11 = *(_WORD *)(a4 + 2 * v8++ + 2);
        }
        while ( v11 );
        v10 = (_WORD *)a4;
      }
      v12 = (void **)v41[0];
      if ( v42 < 0x10 )
        v12 = v41;
      if ( !*((_BYTE *)v12 + v9) )
      {
        v8 += v39;
        v14 = v10[v8];
        if ( v14 == *v10 || !v14 )
        {
          v22 = v39;
          if ( v39 >= 0x7F )
            v22 = 127;
          v23 = (void **)v41[0];
          if ( v42 < 0x10 )
            v23 = v41;
          v38 = v9;
          goto LABEL_65;
        }
        if ( !*(_BYTE *)(a1 + 4) )
        {
          v15 = *(_DWORD ***)a1;
          if ( !*(_DWORD *)a1
            || ((v16 = (__int16 **)v15[8], !*v16) || (int)*v15[12] <= 0 ? (v17 = ((int (__thiscall *)(_DWORD **))(*v15)[6])(v15)) : (v17 = **v16),
                v7 = a2,
                v17 == -1) )
          {
            *(_DWORD *)a1 = 0;
          }
          else
          {
            *(_WORD *)(a1 + 6) = v17;
          }
          *(_BYTE *)(a1 + 4) = 1;
        }
        if ( !*(_BYTE *)(v7 + 4) )
        {
          v18 = *(_DWORD *)v7;
          if ( !*(_DWORD *)v7
            || ((v19 = *(__int16 ***)(v18 + 32), !*v19) || **(int **)(v18 + 48) <= 0 ? (v20 = (*(int (__thiscall **)(int))(*(_DWORD *)v18 + 24))(v18)) : (v20 = **v19),
                v7 = a2,
                v20 == -1) )
          {
            *(_DWORD *)v7 = 0;
          }
          else
          {
            *(_WORD *)(a2 + 6) = v20;
          }
          *(_BYTE *)(v7 + 4) = 1;
        }
        v21 = *(_DWORD ***)a1;
        if ( *(_DWORD *)a1 )
        {
          if ( *(_DWORD *)v7 )
            goto LABEL_43;
        }
        else if ( !*(_DWORD *)v7 )
        {
LABEL_43:
          v22 = v39;
          if ( v39 >= 0x7F )
            v22 = 127;
          v23 = (void **)v41[0];
          if ( v42 < 0x10 )
            v23 = v41;
LABEL_65:
          *((_BYTE *)v23 + v9) = v22;
          goto LABEL_66;
        }
        if ( !*(_BYTE *)(a1 + 4) )
        {
          if ( !v21
            || ((v24 = (__int16 **)v21[8], !*v24) || (int)*v21[12] <= 0 ? (v25 = ((int (__thiscall *)(_DWORD **))(*v21)[6])(v21)) : (v25 = **v24),
                v7 = a2,
                v25 == -1) )
          {
            *(_DWORD *)a1 = 0;
          }
          else
          {
            *(_WORD *)(a1 + 6) = v25;
          }
          *(_BYTE *)(a1 + 4) = 1;
        }
        if ( *(_WORD *)(a4 + 2 * v8) == *(_WORD *)(a1 + 6) )
        {
          v40 = 1;
          goto LABEL_66;
        }
        goto LABEL_43;
      }
      v13 = (void **)v41[0];
      if ( v42 < 0x10 )
        v13 = v41;
      v8 += *((char *)v13 + v9);
LABEL_66:
      ++v9;
    }
    while ( v9 < Size );
    if ( v40 )
    {
      if ( !*(_BYTE *)(a1 + 4) )
      {
        v26 = *(_DWORD ***)a1;
        if ( !*(_DWORD *)a1
          || ((v27 = (__int16 **)v26[8], !*v27) || (int)*v26[12] <= 0 ? (v28 = ((int (__thiscall *)(_DWORD **))(*v26)[6])(v26),
                                                                         v7 = a2) : (v28 = **v27),
              v28 == -1) )
        {
          *(_DWORD *)a1 = 0;
        }
        else
        {
          *(_WORD *)(a1 + 6) = v28;
        }
        *(_BYTE *)(a1 + 4) = 1;
      }
      if ( !*(_BYTE *)(v7 + 4) )
      {
        v29 = *(_DWORD *)v7;
        if ( !*(_DWORD *)v7
          || ((v30 = *(__int16 ***)(v29 + 32), !*v30) || **(int **)(v29 + 48) <= 0 ? (v31 = (*(int (__thiscall **)(int))(*(_DWORD *)v29 + 24))(v29),
                                                                                      v7 = a2) : (v31 = **v30),
              v31 == -1) )
        {
          *(_DWORD *)v7 = 0;
        }
        else
        {
          *(_WORD *)(v7 + 6) = v31;
        }
        *(_BYTE *)(v7 + 4) = 1;
      }
      v32 = *(_DWORD ***)a1;
      if ( *(_DWORD *)a1 )
      {
        if ( !*(_DWORD *)v7 )
        {
LABEL_94:
          ++v39;
          if ( !v32
            || (!*v32[8] || (v34 = v32[12], *v34 <= 0) ? (v37 = ((int (__thiscall *)(_DWORD **))(*v32)[7])(v32), v7 = a2) : (--*v34, v35 = (__int16 **)v32[8], v36 = *v35, ++*v35, v37 = *v36),
                v37 == -1) )
          {
            *(_DWORD *)a1 = 0;
            *(_BYTE *)(a1 + 4) = 1;
            v38 = -1;
          }
          else
          {
            *(_BYTE *)(a1 + 4) = 0;
            v38 = -1;
          }
          continue;
        }
      }
      else if ( *(_DWORD *)v7 )
      {
        goto LABEL_94;
      }
    }
    break;
  }
  if ( v42 >= 0x10 )
    operator delete(v41[0]);
  return v38;
}

//----- (00407260) --------------------------------------------------------
int __cdecl sub_407260(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 4) )
    sub_406BD0((_WORD *)a1);
  if ( !*(_BYTE *)(a2 + 4) )
    sub_406BD0((_WORD *)a2);
  if ( *(_DWORD *)a1 )
  {
    if ( !*(_DWORD *)a2 )
      return 1;
  }
  else if ( *(_DWORD *)a2 )
  {
    return 1;
  }
  return 0;
}

//----- (004072C0) --------------------------------------------------------
int __cdecl sub_4072C0(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  char *v4; // eax
  int v5; // edx
  _Cvtvec *v7; // [esp+0h] [ebp-40h]
  char v8[36]; // [esp+Ch] [ebp-34h] BYREF
  void *v9; // [esp+30h] [ebp-10h]
  int v10; // [esp+3Ch] [ebp-4h]

  v2 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x10u);
    v9 = v3;
    v10 = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v4 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v4 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v4);
      v2 = 1;
      v3[1] = 0;
      *v3 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v3[2] = _Getcvt(v7);
      v3[3] = v5;
    }
    else
    {
      v3 = 0;
    }
    v10 = -1;
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 40733B: variable 'v7' is possibly undefined
// 407343: variable 'v5' is possibly undefined
// 4BDDF4: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00407380) --------------------------------------------------------
int __thiscall sub_407380(int this, int a2)
{
  if ( !*(_BYTE *)(this + 4) )
    sub_406BD0((_WORD *)this);
  if ( !*(_BYTE *)(a2 + 4) )
    sub_406BD0((_WORD *)a2);
  if ( *(_DWORD *)this )
  {
    if ( !*(_DWORD *)a2 )
      return 0;
  }
  else if ( *(_DWORD *)a2 )
  {
    return 0;
  }
  return 1;
}

//----- (004073D0) --------------------------------------------------------
int __cdecl sub_4073D0(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  char *v4; // eax
  struct std::_Locinfo *v5; // eax
  char v7[36]; // [esp+10h] [ebp-38h] BYREF
  void *v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]
  int v10; // [esp+44h] [ebp-4h]

  v2 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x18u);
    v8 = v3;
    v10 = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v4 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v4 = (char *)(*(_DWORD *)a2 + 28);
      v5 = sub_4086C0((struct std::_Locinfo *)v7, v4);
      v2 = 1;
      v9 = 1;
      v3[1] = 0;
      v10 = 2;
      *v3 = &std::numpunct<wchar_t>::`vftable';
      sub_4074A0((unsigned int)v3, (int)v5, 1);
    }
    else
    {
      v3 = 0;
    }
    *a1 = v3;
    v10 = -1;
    if ( (v2 & 1) != 0 )
      sub_408790((std::_Lockit *)v7);
  }
  return 4;
}
// 4BE084: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (004074A0) --------------------------------------------------------
__int16 __thiscall sub_4074A0(unsigned int this, int a2, char a3)
{
  struct lconv *v4; // eax
  unsigned int v5; // edi
  _BYTE *v6; // ecx
  int v7; // edx
  _Cvtvec *v8; // eax
  int v9; // edx
  int v10; // edx
  _Cvtvec *v11; // eax
  int Isclocale; // edi
  unsigned __int8 *v13; // ecx
  unsigned int v14; // edx
  _Cvtvec *v15; // eax
  unsigned int v16; // edx
  unsigned __int8 *v17; // edx
  __int16 result; // ax
  unsigned int v19; // edx
  _Cvtvec *v20; // eax
  unsigned int v21; // edx
  _Cvtvec *v22; // [esp+0h] [ebp-40h] BYREF
  _Cvtvec v23; // [esp+14h] [ebp-2Ch] BYREF

  *(_DWORD *)&v23._Isleadbyte[16] = &v22;
  v23._Mbcurmax = this;
  v4 = localeconv();
  *(_DWORD *)&v23._Isleadbyte[28] = 0;
  v23._Isclocale = (int)v4;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  if ( a3 )
    *(_DWORD *)&v23._Isleadbyte[8] = byte_4CB965;
  else
    *(_DWORD *)&v23._Isleadbyte[8] = v4->grouping;
  _Getcvt(v22);
  v5 = strlen(*(const char **)&v23._Isleadbyte[8]) + 1;
  *(_DWORD *)&v23._Isleadbyte[4] = operator new[](v5);
  v6 = *(_BYTE **)&v23._Isleadbyte[4];
  while ( v5 )
  {
    v7 = *(_DWORD *)&v23._Isleadbyte[8];
    *v6 = **(_BYTE **)&v23._Isleadbyte[8];
    --v5;
    ++v6;
    *(_DWORD *)&v23._Isleadbyte[8] = v7 + 1;
  }
  *(_DWORD *)(this + 8) = *(_DWORD *)&v23._Isleadbyte[4];
  v8 = _Getcvt(v22);
  *(_DWORD *)&v23._Isleadbyte[4] = v9;
  *(_DWORD *)v23._Isleadbyte = v8;
  *(_DWORD *)(this + 16) = sub_4076D0("false", 0, (_Cvtvec *)v23._Isleadbyte);
  *(_DWORD *)v23._Isleadbyte = _Getcvt(v22);
  *(_DWORD *)&v23._Isleadbyte[4] = v10;
  *(_DWORD *)(this + 20) = sub_4076D0("true", 0, (_Cvtvec *)v23._Isleadbyte);
  v11 = _Getcvt(v22);
  Isclocale = v23._Isclocale;
  v13 = *(unsigned __int8 **)v23._Isclocale;
  v23._Page = (unsigned int)v11;
  v23._Mbcurmax = v14;
  v23._Isleadbyte[12] = *v13;
  *(_DWORD *)&v23._Isleadbyte[8] = 0;
  v23._Isclocale = 0;
  _Mbrtowc((wchar_t *)&v23._Isleadbyte[8], (const char *)&v23._Isleadbyte[12], 1u, (mbstate_t *)&v23._Isclocale, &v23);
  *(_WORD *)(this + 12) = *(_WORD *)&v23._Isleadbyte[8];
  v15 = _Getcvt(v22);
  v23._Mbcurmax = v16;
  v17 = *(unsigned __int8 **)(Isclocale + 4);
  v23._Page = (unsigned int)v15;
  v23._Isleadbyte[12] = *v17;
  *(_DWORD *)&v23._Isleadbyte[8] = 0;
  v23._Isclocale = 0;
  result = _Mbrtowc(
             (wchar_t *)&v23._Isleadbyte[8],
             (const char *)&v23._Isleadbyte[12],
             1u,
             (mbstate_t *)&v23._Isclocale,
             &v23);
  *(_WORD *)(this + 14) = *(_WORD *)&v23._Isleadbyte[8];
  if ( a3 )
  {
    v23._Page = (unsigned int)_Getcvt(v22);
    v23._Mbcurmax = v19;
    a3 = 46;
    *(_DWORD *)&v23._Isleadbyte[8] = 0;
    v23._Isclocale = 0;
    _Mbrtowc((wchar_t *)&v23._Isleadbyte[8], &a3, 1u, (mbstate_t *)&v23._Isclocale, &v23);
    *(_WORD *)(this + 12) = *(_WORD *)&v23._Isleadbyte[8];
    v20 = _Getcvt(v22);
    v23._Mbcurmax = v21;
    v23._Page = (unsigned int)v20;
    a3 = 44;
    *(_DWORD *)&v23._Isleadbyte[8] = 0;
    v23._Isclocale = 0;
    _Mbrtowc((wchar_t *)&v23._Isleadbyte[8], &a3, 1u, (mbstate_t *)&v23._Isclocale, &v23);
    result = *(_WORD *)&v23._Isleadbyte[8];
    *(_WORD *)(this + 14) = *(_WORD *)&v23._Isleadbyte[8];
  }
  return result;
}
// 40753E: variable 'v9' is possibly undefined
// 40756B: variable 'v10' is possibly undefined
// 407586: variable 'v14' is possibly undefined
// 4075BB: variable 'v16' is possibly undefined
// 407606: variable 'v19' is possibly undefined
// 407632: variable 'v21' is possibly undefined

//----- (00407690) --------------------------------------------------------
_BYTE *__cdecl sub_407690(const char *a1)
{
  const char *v1; // edi
  unsigned int v2; // kr00_4
  unsigned int v3; // esi
  _BYTE *result; // eax

  v1 = a1;
  v2 = strlen(a1);
  v3 = v2 + 1;
  result = operator new[](v2 + 1);
  if ( v2 != -1 )
  {
    do
    {
      v1[result - a1] = *v1;
      ++v1;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (004076D0) --------------------------------------------------------
wchar_t *__cdecl sub_4076D0(char *a1, int a2, _Cvtvec *a3)
{
  char *v3; // ebx
  int v4; // esi
  size_t v5; // edi
  int v6; // eax
  int v7; // esi
  wchar_t *v8; // ebx
  wchar_t *v9; // edi
  int v10; // eax
  size_t i; // [esp+Ch] [ebp-10h]
  mbstate_t v13; // [esp+10h] [ebp-Ch] BYREF
  wchar_t v14; // [esp+18h] [ebp-4h] BYREF

  v3 = a1;
  v4 = 0;
  *(_DWORD *)&v13._Byte = 0;
  v5 = strlen(a1) + 1;
  for ( i = v5; v5; v5 -= v6 )
  {
    v6 = _Mbrtowc(&v14, v3, v5, (mbstate_t *)&v13._Byte, a3);
    if ( v6 <= 0 )
      break;
    v3 += v6;
    ++v4;
  }
  v7 = v4 + 1;
  v8 = (wchar_t *)operator new[](2 * v7);
  v9 = v8;
  for ( v13._Wchar = 0; v7; --v7 )
  {
    v10 = _Mbrtowc(v9, a1, i, &v13, a3);
    if ( v10 <= 0 )
      break;
    a1 += v10;
    ++v9;
  }
  *v9 = 0;
  return v8;
}

//----- (00407790) --------------------------------------------------------
char *__cdecl sub_407790(char *a1, unsigned __int16 a2, unsigned int a3)
{
  char *v3; // edi
  unsigned int i; // ecx

  if ( !a3 )
    return a1;
  memset32(a1, (a2 << 16) | a2, a3 >> 1);
  v3 = &a1[4 * (a3 >> 1)];
  for ( i = a3 & 1; i; --i )
  {
    *(_WORD *)v3 = a2;
    v3 += 2;
  }
  return a1;
}

//----- (004077D0) --------------------------------------------------------
char __thiscall sub_4077D0(_DWORD *this, int a2, size_t Size, char a4)
{
  char result; // al

  if ( Size == 1 )
  {
    if ( this[5] >= 0x10u )
      this = (_DWORD *)*this;
    result = a4;
    *((_BYTE *)this + a2) = a4;
  }
  else
  {
    if ( this[5] >= 0x10u )
      this = (_DWORD *)*this;
    return (unsigned __int8)memset((char *)this + a2, a4, Size);
  }
  return result;
}

//----- (00407810) --------------------------------------------------------
_DWORD *__thiscall sub_407810(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // ebx
  _DWORD *v9; // edx
  unsigned int v10; // eax
  bool v11; // cf

  v4 = this[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  v5 = a3;
  v6 = v4 - a2;
  if ( v6 < a3 )
    v5 = v6;
  if ( v5 )
  {
    v7 = this[5];
    if ( v7 < 0x10 )
      v8 = this;
    else
      v8 = (_DWORD *)*this;
    if ( v7 < 0x10 )
      v9 = this;
    else
      v9 = (_DWORD *)*this;
    memcpy((char *)v9 + a2, (char *)v8 + a2 + v5, v6 - v5);
    v10 = this[4] - v5;
    v11 = this[5] < 0x10u;
    this[4] = v10;
    if ( !v11 )
    {
      *(_BYTE *)(*this + v10) = 0;
      return this;
    }
    *((_BYTE *)this + v10) = 0;
  }
  return this;
}

//----- (004078A0) --------------------------------------------------------
_DWORD *__thiscall sub_4078A0(_DWORD *this, _DWORD *a2, unsigned int a3, void *a4)
{
  _DWORD *v5; // ecx
  unsigned int v6; // edi
  void *v7; // edi
  _DWORD *result; // eax
  unsigned int v9; // eax
  _DWORD *v10; // eax
  bool v11; // cf

  v5 = a2;
  v6 = a2[4];
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = (void *)(v6 - a3);
  if ( a4 < v7 )
    v7 = a4;
  if ( this == a2 )
  {
    sub_407810(this, (unsigned int)v7 + a3, 0xFFFFFFFF);
    sub_407810(this, 0, a3);
    return this;
  }
  if ( v7 == (void *)-1 )
    std::_Xlength_error("string too long");
  v9 = this[5];
  if ( v9 < (unsigned int)v7 )
  {
    sub_4079E0((int)this, v7, this[4]);
    v5 = a2;
    if ( !v7 )
      return this;
LABEL_11:
    if ( v5[5] >= 0x10u )
      v5 = (_DWORD *)*v5;
    if ( this[5] < 0x10u )
      v10 = this;
    else
      v10 = (_DWORD *)*this;
    memcpy_0(v10, (char *)v5 + a3, (size_t)v7);
    v11 = this[5] < 0x10u;
    this[4] = v7;
    if ( !v11 )
    {
      *((_BYTE *)v7 + *this) = 0;
      return this;
    }
    *((_BYTE *)v7 + (_DWORD)this) = 0;
    return this;
  }
  if ( v7 )
    goto LABEL_11;
  this[4] = 0;
  if ( v9 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (00407990) --------------------------------------------------------
void *__stdcall sub_407990(size_t Size)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = 0;
  if ( Size )
  {
    result = operator new(Size);
    if ( !result )
    {
      Size = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&Size);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004079E0) --------------------------------------------------------
void *__thiscall sub_4079E0(int this, void *a2, size_t Size)
{
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  const void *v8; // eax
  void *result; // eax
  int v10; // [esp+0h] [ebp-38h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-28h] BYREF
  char *v12[6]; // [esp+20h] [ebp-18h] BYREF
  void *v13; // [esp+40h] [ebp+8h]

  v12[2] = (char *)&v10;
  v3 = this;
  v12[1] = (char *)this;
  v4 = (unsigned int)a2 | 0xF;
  if ( ((unsigned int)a2 | 0xF) == -1 )
  {
    v4 = (unsigned int)a2;
  }
  else
  {
    v5 = *(_DWORD *)(this + 20);
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > -2 - v6 )
        v4 = -2;
    }
  }
  v7 = 0;
  v12[5] = 0;
  if ( v4 != -1 )
  {
    v7 = operator new(v4 + 1);
    if ( !v7 )
    {
      v12[0] = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v12);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  v13 = v7;
  if ( Size )
  {
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v8 = (const void *)v3;
    else
      v8 = *(const void **)v3;
    memcpy_0(v13, v8, Size);
  }
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    operator delete(*(void **)v3);
  result = v13;
  *(_BYTE *)v3 = 0;
  *(_DWORD *)v3 = v13;
  *(_DWORD *)(v3 + 20) = v4;
  *(_DWORD *)(v3 + 16) = Size;
  if ( v4 >= 0x10 )
    v3 = (int)v13;
  *(_BYTE *)(v3 + Size) = 0;
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00407B50) --------------------------------------------------------
BOOL __thiscall sub_407B50(void *this, void *a2, char a3)
{
  void *v3; // ebx
  _DWORD *v4; // esi
  unsigned int v5; // eax
  void *v7; // edi
  _DWORD *v8; // ebx

  v3 = a2;
  v4 = this;
  if ( a2 == (void *)-1 )
    std::_Xlength_error("string too long");
  v5 = *((_DWORD *)this + 5);
  if ( v5 >= (unsigned int)a2 )
  {
    if ( a3 && (unsigned int)a2 < 0x10 )
    {
      v7 = (void *)*((_DWORD *)this + 4);
      if ( a2 < v7 )
        v7 = a2;
      if ( v5 >= 0x10 )
      {
        v8 = *(_DWORD **)this;
        if ( v7 )
          memcpy_0(this, v8, (size_t)v7);
        operator delete(v8);
        v3 = a2;
      }
      v4[4] = v7;
      v4[5] = 15;
      *((_BYTE *)v4 + (_DWORD)v7) = 0;
      return v3 != 0;
    }
    else
    {
      if ( !a2 )
      {
        *((_DWORD *)this + 4) = 0;
        if ( v5 >= 0x10 )
          v4 = *(_DWORD **)this;
        *(_BYTE *)v4 = 0;
      }
      return a2 != 0;
    }
  }
  else
  {
    sub_4079E0((int)this, a2, *((_DWORD *)this + 4));
    return a2 != 0;
  }
}

//----- (00407C00) --------------------------------------------------------
_DWORD *__thiscall sub_407C00(_DWORD *this, void *Src, size_t Size)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *result; // eax
  size_t v8; // eax
  _DWORD *v9; // eax
  bool v10; // cf

  if ( Src )
  {
    v4 = this[5];
    v5 = v4 < 0x10 ? this : (_DWORD *)*this;
    if ( Src >= v5 )
    {
      v6 = v4 < 0x10 ? this : (_DWORD *)*this;
      if ( (char *)v6 + this[4] > Src )
      {
        if ( v4 < 0x10 )
          return sub_4078A0(this, this, (_BYTE *)Src - (_BYTE *)this, (void *)Size);
        else
          return sub_4078A0(this, this, (unsigned int)Src - *this, (void *)Size);
      }
    }
  }
  if ( Size == -1 )
    std::_Xlength_error("string too long");
  v8 = this[5];
  if ( v8 < Size )
  {
    sub_4079E0((int)this, (void *)Size, this[4]);
    if ( !Size )
      return this;
LABEL_17:
    if ( this[5] < 0x10u )
      v9 = this;
    else
      v9 = (_DWORD *)*this;
    memcpy_0(v9, Src, Size);
    v10 = this[5] < 0x10u;
    this[4] = Size;
    if ( !v10 )
    {
      *(_BYTE *)(*this + Size) = 0;
      return this;
    }
    *((_BYTE *)this + Size) = 0;
    return this;
  }
  if ( Size )
    goto LABEL_17;
  this[4] = 0;
  if ( v8 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (00407D00) --------------------------------------------------------
_DWORD *__thiscall sub_407D00(_DWORD *this, void *Src)
{
  this[5] = 15;
  this[4] = 0;
  *(_BYTE *)this = 0;
  sub_407C00(this, Src, strlen((const char *)Src));
  return this;
}

//----- (00407D40) --------------------------------------------------------
unsigned __int16 __cdecl sub_407D40(int a1, int a2, _Cvtvec *a3)
{
  mbstate_t v4; // [esp+0h] [ebp-8h] BYREF

  *(_DWORD *)&v4._Byte = 0;
  v4._Wchar = 0;
  _Mbrtowc(&v4._Byte, (const char *)&a1, 1u, &v4, a3);
  return v4._Byte;
}

//----- (00407D70) --------------------------------------------------------
void __thiscall sub_407D70(void *this, char a2, size_t Size)
{
  void *v4; // ebx

  if ( a2 && *((_DWORD *)this + 5) >= 0x10u )
  {
    v4 = *(void **)this;
    if ( Size )
      memcpy_0(this, v4, Size);
    operator delete(v4);
  }
  *((_DWORD *)this + 4) = Size;
  *((_DWORD *)this + 5) = 15;
  *((_BYTE *)this + Size) = 0;
}

//----- (00407DF0) --------------------------------------------------------
void __usercall sub_407DF0(_DWORD *a1@<esi>)
{
  _DWORD *v1; // ebx
  int v2; // eax
  char v3[4]; // [esp+8h] [ebp-8h] BYREF
  int v4; // [esp+Ch] [ebp-4h]

  a1[12] = 0;
  a1[2] = 0;
  a1[4] = 0;
  a1[5] = 513;
  a1[6] = 6;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[3] = 0;
  v1 = operator new(4u);
  if ( v1 )
  {
    *v1 = std::locale::_Init();
    v4 = sub_426E4C();
    std::_Lockit::_Lockit((std::_Lockit *)v3, 0);
    v2 = *(_DWORD *)(v4 + 4);
    if ( v2 != -1 )
      *(_DWORD *)(v4 + 4) = v2 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)v3);
    a1[12] = v1;
  }
  else
  {
    a1[12] = 0;
  }
}
// 407DF0: using guessed type char var_8[4];

//----- (00407E80) --------------------------------------------------------
double __cdecl sub_407E80(float a1, int Y)
{
  return (float)ldexp(a1, Y);
}

//----- (00407EA0) --------------------------------------------------------
void *__thiscall sub_407EA0(void *this, char a2)
{
  sub_408180(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00407ED0) --------------------------------------------------------
int __stdcall sub_407ED0(int a1)
{
  return 0xFFFF;
}

//----- (00407EE0) --------------------------------------------------------
__int64 sub_407EE0()
{
  return 0i64;
}

//----- (00407EF0) --------------------------------------------------------
__int64 __thiscall sub_407EF0(int this, void *a2, int a3, int a4)
{
  int v4; // edi
  __int64 v5; // rax
  int v6; // ebx
  int v7; // esi
  unsigned __int64 v8; // kr00_8
  __int16 v9; // cx
  unsigned __int64 v10; // kr08_8
  __int64 v13; // [esp+10h] [ebp-8h]

  v4 = a4;
  v13 = 0i64;
  if ( __SPAIR64__(a4, a3) > 0 )
  {
    do
    {
      v5 = sub_408B80((_DWORD **)this);
      v6 = HIDWORD(v5);
      v7 = v5;
      if ( v5 <= 0 )
      {
        v9 = (*(int (__thiscall **)(int))(*(_DWORD *)this + 28))(this);
        if ( v9 == -1 )
          return v13;
        ++v13;
        *(_WORD *)a2 = v9;
        a2 = (char *)a2 + 2;
        v4 = (__PAIR64__(v4, a3) - 1) >> 32;
        v10 = __PAIR64__(v4, a3 - 1);
        a4 = HIDWORD(v10);
        a3 = v10;
      }
      else
      {
        if ( __SPAIR64__(v4, a3) < v5 )
        {
          v7 = a3;
          v6 = v4;
        }
        memcpy_0(a2, **(const void ***)(this + 32), 2 * v7);
        a2 = (char *)a2 + 2 * v7;
        v13 += __PAIR64__(v6, v7);
        v8 = __PAIR64__(a4, a3) - __PAIR64__(v6, v7);
        a4 = HIDWORD(v8);
        a3 = v8;
        **(_DWORD **)(this + 48) -= v7;
        **(_DWORD **)(this + 32) += 2 * v7;
        v4 = a4;
      }
    }
    while ( v4 > 0 || v4 >= 0 && a3 );
  }
  return v13;
}

//----- (00407FF0) --------------------------------------------------------
__int64 __thiscall sub_407FF0(_DWORD **this)
{
  if ( *this[9] )
    return (int)*this[13];
  else
    return 0i64;
}

//----- (00408010) --------------------------------------------------------
__int64 __thiscall sub_408010(int this, void *Src, int a3, int a4)
{
  int v4; // edi
  __int64 v5; // rax
  int v6; // ebx
  int v7; // esi
  unsigned __int64 v8; // kr00_8
  unsigned __int64 v9; // kr10_8
  __int64 v12; // [esp+10h] [ebp-8h]

  v4 = a4;
  v12 = 0i64;
  if ( __SPAIR64__(a4, a3) > 0 )
  {
    do
    {
      v5 = sub_407FF0((_DWORD **)this);
      v6 = HIDWORD(v5);
      v7 = v5;
      if ( v5 <= 0 )
      {
        if ( (*(unsigned __int16 (__thiscall **)(int, _DWORD))(*(_DWORD *)this + 12))(this, *(unsigned __int16 *)Src) == 0xFFFF )
          return v12;
        Src = (char *)Src + 2;
        ++v12;
        v4 = (__PAIR64__(v4, a3) - 1) >> 32;
        v9 = __PAIR64__(v4, a3 - 1);
        a4 = HIDWORD(v9);
        a3 = v9;
      }
      else
      {
        if ( __SPAIR64__(v4, a3) < v5 )
        {
          v7 = a3;
          v6 = v4;
        }
        memcpy_0(**(void ***)(this + 36), Src, 2 * v7);
        Src = (char *)Src + 2 * v7;
        v12 += __PAIR64__(v6, v7);
        v8 = __PAIR64__(a4, a3) - __PAIR64__(v6, v7);
        a4 = HIDWORD(v8);
        a3 = v8;
        **(_DWORD **)(this + 52) -= v7;
        **(_DWORD **)(this + 36) += 2 * v7;
        v4 = a4;
      }
    }
    while ( v4 > 0 || v4 >= 0 && a3 );
  }
  return v12;
}

//----- (00408100) --------------------------------------------------------
_DWORD *__stdcall sub_408100(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  return result;
}

//----- (00408130) --------------------------------------------------------
_DWORD *__stdcall sub_408130(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = -1;
  a1[1] = -1;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  return result;
}

//----- (00408160) --------------------------------------------------------
void *__thiscall sub_408160(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (00408180) --------------------------------------------------------
void __thiscall sub_408180(_DWORD *this)
{
  _DWORD *v1; // esi
  int *v2; // ebx
  int v3; // edi
  int v4; // eax
  int v5; // esi
  void (__thiscall ***v6)(_DWORD, int); // esi
  char v7[4]; // [esp+8h] [ebp-8h] BYREF
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  v1 = this;
  v2 = (int *)this[14];
  v8 = this;
  *this = &std::wstreambuf::`vftable';
  if ( v2 )
  {
    v3 = *v2;
    if ( *v2 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
      v4 = *(_DWORD *)(v3 + 4);
      if ( v4 && v4 != -1 )
        *(_DWORD *)(v3 + 4) = v4 - 1;
      v5 = -(*(_DWORD *)(v3 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v7);
      v6 = (void (__thiscall ***)(_DWORD, int))(v3 & v5);
      if ( v6 )
        (**v6)(v6, 1);
      v1 = v8;
    }
    operator delete(v2);
  }
  std::_Mutex::~_Mutex((std::_Mutex *)(v1 + 1));
}
// 4CBADC: using guessed type void *std::wstreambuf::`vftable';
// 408180: using guessed type char var_8[4];

//----- (00408200) --------------------------------------------------------
char *__thiscall sub_408200(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 16;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 4) + 4) - 16) = &std::wistream::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return v2;
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';

//----- (00408250) --------------------------------------------------------
int __thiscall sub_408250(LPCRITICAL_SECTION *this)
{
  return unknown_libname_20(this[1]);
}

//----- (00408260) --------------------------------------------------------
void __thiscall sub_408260(LPCRITICAL_SECTION *this)
{
  sub_42B623(this[1]);
}

//----- (00408270) --------------------------------------------------------
int sub_408270()
{
  return 0;
}

//----- (00408280) --------------------------------------------------------
int __usercall sub_408280@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // eax

  v1 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v2 = 0;
  if ( (*(_BYTE *)(v1 + a1 + 12) & 6) == 0
    && (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + a1 + 56) + 52))(*(_DWORD *)(v1 + a1 + 56)) == -1 )
  {
    v2 = 4;
  }
  v3 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4));
  if ( v2 )
  {
    v4 = v2 | v3[3];
    if ( !v3[14] )
      LOBYTE(v4) = v4 | 4;
    v5 = v4 & 0x17;
    v3[3] = v5;
    if ( (v5 & v3[4]) != 0 )
      sub_408D30(0);
  }
  return a1;
}

//----- (00408320) --------------------------------------------------------
int __thiscall sub_408320(int *this, unsigned int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // eax

  v2 = *this;
  if ( a2 >= *(_DWORD *)(v2 + 12) )
  {
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * a2);
    if ( result )
      return result;
  }
  if ( *(_BYTE *)(v2 + 20) )
  {
    v4 = sub_426E4C();
    if ( a2 >= *(_DWORD *)(v4 + 12) )
      return 0;
    else
      return *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * a2);
  }
  return result;
}

//----- (00408360) --------------------------------------------------------
void *__thiscall sub_408360(void *this, char a2)
{
  bool v3; // zf

  v3 = *((_DWORD *)this + 5) == 0;
  *(_DWORD *)this = &std::ctype<wchar_t>::`vftable';
  if ( !v3 )
    free(*((void **)this + 4));
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDD78: using guessed type void *std::ctype<wchar_t>::`vftable';

//----- (004083A0) --------------------------------------------------------
const wchar_t *__thiscall sub_4083A0(int this, wchar_t *a2, wchar_t *a3, __int16 *a4)
{
  return _Getwctypes(a2, a3, a4, (const _Ctypevec *)(this + 8));
}

//----- (004083C0) --------------------------------------------------------
unsigned __int16 *__thiscall sub_4083C0(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // esi

  for ( i = a3; i != a4; ++i )
  {
    if ( (*(unsigned __int8 (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 8))(this, a2, *i) )
      break;
  }
  return i;
}

//----- (00408400) --------------------------------------------------------
unsigned __int16 *__thiscall sub_408400(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // esi

  for ( i = a3; i != a4; ++i )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 8))(this, a2, *i) )
      break;
  }
  return i;
}

//----- (00408440) --------------------------------------------------------
wchar_t *__thiscall sub_408440(char *this, wchar_t *a2, wchar_t *a3)
{
  wchar_t *v3; // esi
  const _Ctypevec *v4; // edi

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Towlower(*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (00408480) --------------------------------------------------------
wchar_t __thiscall sub_408480(int this, wchar_t a2)
{
  return _Towlower(a2, (const _Ctypevec *)(this + 8));
}

//----- (004084A0) --------------------------------------------------------
wchar_t *__thiscall sub_4084A0(char *this, wchar_t *a2, wchar_t *a3)
{
  wchar_t *v3; // esi
  const _Ctypevec *v4; // edi

  v3 = a2;
  if ( a2 != a3 )
  {
    v4 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Towupper(*v3, v4);
      ++v3;
    }
    while ( v3 != a3 );
  }
  return v3;
}

//----- (004084E0) --------------------------------------------------------
wchar_t __thiscall sub_4084E0(int this, wchar_t a2)
{
  return _Towupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (00408500) --------------------------------------------------------
_BYTE *__userpurge sub_408500@<eax>(int a1@<ecx>, _BYTE *a2, _BYTE *a3, mbstate_t a4)
{
  _BYTE *v4; // ebx
  _BYTE *v5; // esi
  _WORD *Wchar; // edi
  bool v7; // sf
  __int16 v8; // ax
  _Cvtvec *v10; // [esp+8h] [ebp-4h]

  v4 = a3;
  v5 = a2;
  if ( a2 != a3 )
  {
    Wchar = (_WORD *)a4._Wchar;
    v10 = (_Cvtvec *)(a1 + 24);
    do
    {
      LOBYTE(a2) = *v5;
      a4._Wchar = 0;
      v7 = _Mbrtowc((wchar_t *)&a3, (const char *)&a2, 1u, &a4, v10) < 0;
      v8 = -1;
      if ( !v7 )
        v8 = (__int16)a3;
      *Wchar = v8;
      ++v5;
      ++Wchar;
    }
    while ( v5 != v4 );
  }
  return v5;
}

//----- (00408570) --------------------------------------------------------
int __thiscall sub_408570(int this, char a2)
{
  bool v2; // sf
  int result; // eax
  mbstate_t v4; // [esp+0h] [ebp-8h] BYREF

  v4._Wchar = 0;
  v2 = _Mbrtowc(&v4._Byte, &a2, 1u, &v4, (const _Cvtvec *)(this + 24)) < 0;
  result = 0xFFFF;
  if ( !v2 )
    return v4._Byte;
  return result;
}

//----- (004085B0) --------------------------------------------------------
wchar_t *__thiscall sub_4085B0(char *this, wchar_t *a2, wchar_t *a3, char a4, char *a5)
{
  wchar_t *v5; // esi
  bool v7; // zf
  char Byte; // al
  wchar_t v10; // [esp-Ch] [ebp-2Ch]
  _Cvtvec *v11; // [esp+Ch] [ebp-14h]
  mbstate_t v12; // [esp+10h] [ebp-10h] BYREF

  v5 = a2;
  if ( a2 != a3 )
  {
    v11 = (_Cvtvec *)(this + 24);
    do
    {
      v10 = *v5;
      v12._Wchar = 0;
      v7 = _Wcrtomb((char *)&v12._Byte, v10, &v12, v11) == 1;
      Byte = a4;
      if ( v7 )
        Byte = v12._Byte;
      *a5 = Byte;
      ++v5;
      ++a5;
    }
    while ( v5 != a3 );
  }
  return v5;
}

//----- (00408620) --------------------------------------------------------
char __thiscall sub_408620(int this, wchar_t a2, char a3)
{
  bool v3; // zf
  char result; // al
  mbstate_t v5; // [esp+0h] [ebp-10h] BYREF

  v5._Wchar = 0;
  v3 = _Wcrtomb((char *)&v5._Byte, a2, &v5, (const _Cvtvec *)(this + 24)) == 1;
  result = a3;
  if ( v3 )
    return v5._Byte;
  return result;
}

//----- (00408670) --------------------------------------------------------
_Cvtvec *__thiscall sub_408670(int this, int a2)
{
  _Cvtvec *result; // eax
  int v4; // edx
  _Cvtvec *v5; // [esp+0h] [ebp-18h]
  _Ctypevec v6; // [esp+8h] [ebp-10h] BYREF

  *(_Ctypevec *)(this + 8) = *_Getctype(&v6);
  result = _Getcvt(v5);
  *(_DWORD *)(this + 24) = result;
  *(_DWORD *)(this + 28) = v4;
  return result;
}
// 4086A0: variable 'v5' is possibly undefined
// 4086A8: variable 'v4' is possibly undefined

//----- (004086C0) --------------------------------------------------------
struct std::_Locinfo *__thiscall sub_4086C0(struct std::_Locinfo *this, char *Locale)
{
  int pExceptionObject[4]; // [esp+Ch] [ebp-1Ch] BYREF
  int v5; // [esp+24h] [ebp-4h]

  pExceptionObject[3] = (int)this;
  std::_Lockit::_Lockit(this, 0);
  v5 = 0;
  *((_DWORD *)this + 1) = 0;
  *((_BYTE *)this + 8) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_BYTE *)this + 24) = 0;
  *((_DWORD *)this + 7) = 0;
  *((_BYTE *)this + 32) = 0;
  LOBYTE(v5) = 4;
  if ( !Locale )
  {
    Locale = "bad locale name";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&Locale);
    pExceptionObject[0] = (int)&std::runtime_error::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor(this, Locale);
  return this;
}
// 4BDA34: using guessed type void *std::runtime_error::`vftable';

//----- (00408790) --------------------------------------------------------
void __thiscall sub_408790(std::_Lockit *this)
{
  std::_Locinfo::_Locinfo_dtor(this);
  if ( *((_DWORD *)this + 7) )
    free(*((void **)this + 7));
  *((_DWORD *)this + 7) = 0;
  if ( *((_DWORD *)this + 5) )
    free(*((void **)this + 5));
  *((_DWORD *)this + 5) = 0;
  if ( *((_DWORD *)this + 3) )
    free(*((void **)this + 3));
  *((_DWORD *)this + 3) = 0;
  if ( *((_DWORD *)this + 1) )
    free(*((void **)this + 1));
  *((_DWORD *)this + 1) = 0;
  std::_Lockit::~_Lockit(this);
}

//----- (00408840) --------------------------------------------------------
int __cdecl sub_408840(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  char *v4; // eax
  struct std::_Locinfo *v5; // eax
  char v7[36]; // [esp+Ch] [ebp-34h] BYREF
  void *v8; // [esp+30h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-4h]

  v2 = 0;
  v8 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x20u);
    v8 = v3;
    v9 = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v4 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v4 = (char *)(*(_DWORD *)a2 + 28);
      v5 = sub_4086C0((struct std::_Locinfo *)v7, v4);
      v2 = 1;
      v3[1] = 0;
      *v3 = &std::ctype<wchar_t>::`vftable';
      sub_408670((int)v3, (int)v5);
    }
    else
    {
      v3 = 0;
    }
    v9 = -1;
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_408790((std::_Lockit *)v7);
  }
  return 2;
}
// 4BDD78: using guessed type void *std::ctype<wchar_t>::`vftable';

//----- (00408900) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_408900(int a1)
{
  int v1; // ebx
  int v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF7D0;
  v13 = (struct std::locale::facet *)dword_4EF7D0;
  if ( !dword_4EE114 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4EE114 )
      dword_4EE114 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4EE114;
  v4 = *(_DWORD *)a1;
  if ( (unsigned int)dword_4EE114 >= *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4EE114);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_408840(&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF7D0 = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EE114: using guessed type int dword_4EE114;
// 4EF7D0: using guessed type int dword_4EF7D0;
// 408900: using guessed type char var_18[4];
// 408900: using guessed type char var_14[4];

//----- (00408A70) --------------------------------------------------------
_DWORD *__thiscall sub_408A70(_DWORD **this, _DWORD *a2)
{
  int v2; // esi
  _DWORD *v3; // edi
  int v4; // eax

  v2 = *this[12];
  v3 = a2;
  *a2 = v2;
  std::_Lockit::_Lockit((std::_Lockit *)&a2, 0);
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 != -1 )
    *(_DWORD *)(v2 + 4) = v4 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&a2);
  return v3;
}

//----- (00408AB0) --------------------------------------------------------
int __fastcall sub_408AB0(int a1)
{
  int v2; // eax
  int v3; // esi
  char v5[4]; // [esp+8h] [ebp-4h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 && v2 != -1 )
    *(_DWORD *)(a1 + 4) = v2 - 1;
  v3 = *(_DWORD *)(a1 + 4) == 0 ? a1 : 0;
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return v3;
}
// 408AB0: using guessed type char var_4[4];

//----- (00408B00) --------------------------------------------------------
void __thiscall sub_408B00(int *this)
{
  int v1; // edi
  int v2; // eax
  int v3; // esi
  void (__thiscall ***v4)(_DWORD, int); // esi
  char v5[4]; // [esp+4h] [ebp-4h] BYREF

  v1 = *this;
  if ( *this )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
    v2 = *(_DWORD *)(v1 + 4);
    if ( v2 && v2 != -1 )
      *(_DWORD *)(v1 + 4) = v2 - 1;
    v3 = -(*(_DWORD *)(v1 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v5);
    v4 = (void (__thiscall ***)(_DWORD, int))(v1 & v3);
    if ( v4 )
      (**v4)(v4, 1);
  }
}
// 408B00: using guessed type char var_4[4];

//----- (00408B50) --------------------------------------------------------
int __thiscall sub_408B50(_DWORD **this)
{
  unsigned __int16 **v3; // esi
  unsigned __int16 *v4; // eax

  if ( ((unsigned __int16 (__thiscall *)(_DWORD **))(*this)[6])(this) == 0xFFFF )
    return 0xFFFF;
  --*this[12];
  v3 = (unsigned __int16 **)this[8];
  v4 = (*v3)++;
  return *v4;
}

//----- (00408B80) --------------------------------------------------------
__int64 __thiscall sub_408B80(_DWORD **this)
{
  if ( *this[8] )
    return (int)*this[12];
  else
    return 0i64;
}

//----- (00408BA0) --------------------------------------------------------
int sub_408BA0()
{
  return 0xFFFF;
}

//----- (00408BB0) --------------------------------------------------------
int __usercall sub_408BB0@<eax>(int **a1@<eax>)
{
  int *v2; // ecx
  int *v3; // esi
  unsigned __int16 *v4; // eax
  int *v6; // edx
  int *v7; // eax
  __int16 *v8; // ecx
  __int16 v9; // ax
  int *v10; // eax

  if ( !*a1[8] )
    goto LABEL_6;
  v2 = a1[12];
  if ( *v2 > 1 )
  {
    --*v2;
    v3 = a1[8];
    v4 = (unsigned __int16 *)(*v3 + 2);
    *v3 = (int)v4;
    return *v4;
  }
  v6 = a1[12];
  if ( *v6 > 0 )
  {
    --*v6;
    v7 = a1[8];
    v8 = (__int16 *)*v7;
    *v7 += 2;
    v9 = *v8;
  }
  else
  {
LABEL_6:
    v9 = ((int (__thiscall *)(int **))(*a1)[7])(a1);
  }
  if ( v9 == -1 )
    return 0xFFFF;
  v10 = a1[8];
  if ( *v10 && *a1[12] > 0 )
    return *(unsigned __int16 *)*v10;
  else
    return ((unsigned __int16 (__thiscall *)(int **))(*a1)[6])(a1);
}
// 408BD9: conditional instruction was optimized away because eax.4!=0

//----- (00408C40) --------------------------------------------------------
BOOL __thiscall sub_408C40(int this, __int16 a2, wchar_t a3)
{
  return ((unsigned __int16)_Getwctype(a3, (const _Ctypevec *)(this + 8)) & (unsigned __int16)a2) != 0;
}

//----- (00408C80) --------------------------------------------------------
std::exception *__thiscall sub_408C80(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::system_error::`vftable';
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *(_DWORD *)this = &std::ios_base::failure::`vftable';
  return this;
}
// 4CBB24: using guessed type void *std::system_error::`vftable';
// 4CBB30: using guessed type void *std::ios_base::failure::`vftable';

//----- (00408CB0) --------------------------------------------------------
std::exception *__thiscall sub_408CB0(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::system_error::`vftable';
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  return this;
}
// 4CBB24: using guessed type void *std::system_error::`vftable';

//----- (00408CE0) --------------------------------------------------------
void *__thiscall sub_408CE0(void *this, char a2)
{
  sub_4398D8((std::exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00408D10) --------------------------------------------------------
std::exception *__thiscall sub_408D10(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 4BDA34: using guessed type void *std::runtime_error::`vftable';

//----- (00408D30) --------------------------------------------------------
void __cdecl __noreturn sub_408D30(char *a1)
{
  int v1; // ecx
  int v2; // eax
  int (__thiscall **v3)(void *, char); // edi
  int (__thiscall **v4)(void *, char); // edi
  int (__thiscall **v5)(void *, char); // edi
  int pExceptionObject[3]; // [esp+8h] [ebp-14h] BYREF
  int v7; // [esp+14h] [ebp-8h]
  int (__thiscall **v8)(void *, char); // [esp+18h] [ebp-4h]

  if ( (_BYTE)a1 )
    _CxxThrowException(0, 0);
  v2 = *(_DWORD *)(v1 + 12) & *(_DWORD *)(v1 + 16);
  if ( (v2 & 4) != 0 )
  {
    v3 = sub_426C67();
    a1 = "ios_base::badbit set";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    v7 = 1;
    v8 = v3;
    pExceptionObject[0] = (int)&std::ios_base::failure::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
  }
  if ( (v2 & 2) != 0 )
  {
    v4 = sub_426C67();
    a1 = "ios_base::failbit set";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    v7 = 1;
    v8 = v4;
    pExceptionObject[0] = (int)&std::ios_base::failure::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
  }
  v5 = sub_426C67();
  a1 = "ios_base::eofbit set";
  std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
  v7 = 1;
  v8 = v5;
  pExceptionObject[0] = (int)&std::ios_base::failure::`vftable';
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
}
// 408D4A: variable 'v1' is possibly undefined
// 4CBB30: using guessed type void *std::ios_base::failure::`vftable';

//----- (00408E00) --------------------------------------------------------
char __stdcall sub_408E00(int a1)
{
  int v1; // ecx
  int v2; // eax
  _DWORD *v3; // ecx
  int v4; // ecx
  int v5; // edx
  _DWORD *v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // ecx
  unsigned __int16 **v9; // eax
  unsigned __int16 v10; // ax
  int v11; // ecx
  int v12; // eax
  _DWORD *v13; // ecx
  char v14; // al
  int v15; // eax
  int v17; // eax
  int v18; // eax
  int v19; // [esp+0h] [ebp-24h] BYREF
  int v20[2]; // [esp+10h] [ebp-14h] BYREF
  int v21; // [esp+20h] [ebp-4h]

  v20[1] = (int)&v19;
  v1 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v2 = *(_DWORD *)(v1 + a1 + 12);
  v3 = (_DWORD *)(a1 + v1);
  if ( !v2 )
  {
    v4 = v3[15];
    if ( v4 )
      sub_408280(v4);
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    if ( (*(_DWORD *)(v5 + a1 + 20) & 1) != 0 )
    {
      v6 = sub_408A70((_DWORD **)(a1 + v5), v20);
      v21 = 0;
      v7 = sub_408900((int)v6);
      sub_408B00(v20);
      v21 = 1;
      v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
      v9 = *(unsigned __int16 ***)(v8 + 32);
      if ( *v9 && **(int **)(v8 + 48) > 0 )
        v10 = **v9;
      else
        v10 = (*(int (__thiscall **)(int))(*(_DWORD *)v8 + 24))(v8);
      while ( v10 != 0xFFFF )
      {
        if ( !(*(unsigned __int8 (__thiscall **)(struct std::locale::facet *, int, _DWORD))(*(_DWORD *)v7 + 8))(
                v7,
                72,
                v10) )
          goto LABEL_15;
        v10 = sub_408BB0(*(int ***)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56));
      }
      v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
      v12 = *(_DWORD *)(v11 + a1 + 12);
      v13 = (_DWORD *)(a1 + v11);
      v14 = v12 | 1;
      if ( !v13[14] )
        v14 |= 4u;
      v15 = v14 & 0x17;
      v13[3] = v15;
      if ( (v15 & v13[4]) != 0 )
        sub_408D30(0);
LABEL_15:
      v21 = -1;
    }
    v3 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4));
    if ( !v3[3] )
      return 1;
  }
  v17 = v3[3] | 2;
  if ( !v3[14] )
    v17 = v3[3] | 6;
  v18 = v17 & 0x17;
  v3[3] = v18;
  if ( (v18 & v3[4]) != 0 )
    sub_408D30(0);
  return 0;
}

//----- (00408FC0) --------------------------------------------------------
struct std::ios_base *__thiscall sub_408FC0(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';

//----- (00409000) --------------------------------------------------------
void __thiscall sub_409000(int this)
{
  if ( *(_DWORD *)(this + 20) >= 8u )
    operator delete(*(void **)this);
  *(_DWORD *)(this + 20) = 7;
  *(_DWORD *)(this + 16) = 0;
  *(_WORD *)this = 0;
}

//----- (00409030) --------------------------------------------------------
void *__cdecl sub_409030(void *a1, void *Src, int a3)
{
  return memcpy(a1, Src, 2 * a3);
}

//----- (00409050) --------------------------------------------------------
_DWORD *__thiscall sub_409050(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // ebx
  _DWORD *v9; // edx
  unsigned int v10; // eax
  bool v11; // cf

  v4 = this[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  v5 = a3;
  v6 = v4 - a2;
  if ( v6 < a3 )
    v5 = v6;
  if ( v5 )
  {
    v7 = this[5];
    if ( v7 < 8 )
      v8 = this;
    else
      v8 = (_DWORD *)*this;
    if ( v7 < 8 )
      v9 = this;
    else
      v9 = (_DWORD *)*this;
    memcpy((char *)v9 + 2 * a2, (char *)v8 + 2 * a2 + 2 * v5, 2 * (v6 - v5));
    v10 = this[4] - v5;
    v11 = this[5] < 8u;
    this[4] = v10;
    if ( !v11 )
    {
      *(_WORD *)(*this + 2 * v10) = 0;
      return this;
    }
    *((_WORD *)this + v10) = 0;
  }
  return this;
}

//----- (004090E0) --------------------------------------------------------
int __thiscall sub_4090E0(int this, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  _DWORD *v5; // ecx
  unsigned int v6; // edi
  unsigned int v7; // edi
  int result; // eax
  unsigned int v9; // eax
  void *v10; // eax
  int v11; // ebx
  bool v12; // cf

  v5 = a2;
  v6 = a2[4];
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = v6 - a3;
  if ( a4 < v7 )
    v7 = a4;
  if ( (_DWORD *)this == a2 )
  {
    sub_409050((_DWORD *)this, a3 + v7, 0xFFFFFFFF);
    sub_409050((_DWORD *)this, 0, a3);
    return this;
  }
  if ( v7 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v9 = *(_DWORD *)(this + 20);
  if ( v9 < v7 )
  {
    sub_409240(this, v7, *(const void **)(this + 16));
    v5 = a2;
    if ( !v7 )
      return this;
LABEL_11:
    if ( v5[5] >= 8u )
      v5 = (_DWORD *)*v5;
    if ( *(_DWORD *)(this + 20) < 8u )
      v10 = (void *)this;
    else
      v10 = *(void **)this;
    v11 = 2 * v7;
    memcpy_0(v10, (char *)v5 + 2 * a3, 2 * v7);
    v12 = *(_DWORD *)(this + 20) < 8u;
    *(_DWORD *)(this + 16) = v7;
    if ( !v12 )
    {
      *(_WORD *)(v11 + *(_DWORD *)this) = 0;
      return this;
    }
    *(_WORD *)(v11 + this) = 0;
    return this;
  }
  if ( v7 )
    goto LABEL_11;
  *(_DWORD *)(this + 16) = 0;
  if ( v9 < 8 )
  {
    result = this;
    *(_WORD *)this = 0;
  }
  else
  {
    **(_WORD **)this = 0;
    return this;
  }
  return result;
}

//----- (004091E0) --------------------------------------------------------
void *__stdcall sub_4091E0(char *a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = 0;
  if ( a1 )
  {
    if ( (unsigned int)a1 > 0x7FFFFFFF || (result = operator new(2 * (_DWORD)a1)) == 0 )
    {
      a1 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00409240) --------------------------------------------------------
void __thiscall sub_409240(int this, unsigned int a2, const void *a3)
{
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  unsigned int v8; // ecx
  void *v9; // ebx
  const void *v10; // ecx
  const void *v11; // eax
  int v12; // [esp+0h] [ebp-34h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-24h] BYREF
  char *v14[6]; // [esp+1Ch] [ebp-18h] BYREF

  v14[2] = (char *)&v12;
  v3 = this;
  v14[1] = (char *)this;
  v4 = a2 | 7;
  if ( (a2 | 7) <= 0x7FFFFFFE )
  {
    v5 = *(_DWORD *)(this + 20);
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > 2147483646 - v6 )
        v4 = 2147483646;
    }
  }
  else
  {
    v4 = a2;
  }
  v7 = 0;
  v8 = v4 + 1;
  v14[5] = 0;
  if ( v4 != -1 && (v8 > 0x7FFFFFFF || (v7 = operator new(2 * v8)) == 0) )
  {
    v14[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v14);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v9 = v7;
  v10 = a3;
  if ( a3 )
  {
    if ( *(_DWORD *)(v3 + 20) < 8u )
      v11 = (const void *)v3;
    else
      v11 = *(const void **)v3;
    memcpy_0(v9, v11, 2 * (_DWORD)a3);
    v10 = a3;
  }
  if ( *(_DWORD *)(v3 + 20) >= 8u )
  {
    operator delete(*(void **)v3);
    v10 = a3;
  }
  *(_DWORD *)v3 = v9;
  *(_DWORD *)(v3 + 20) = v4;
  *(_DWORD *)(v3 + 16) = v10;
  if ( v4 >= 8 )
    v3 = (int)v9;
  *(_WORD *)(v3 + 2 * (_DWORD)v10) = 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004093C0) --------------------------------------------------------
void __thiscall sub_4093C0(void *this, char a2, int a3)
{
  void *v4; // ebx

  if ( a2 && *((_DWORD *)this + 5) >= 8u )
  {
    v4 = *(void **)this;
    if ( a3 )
      memcpy_0(this, v4, 2 * a3);
    operator delete(v4);
  }
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = 7;
  *((_WORD *)this + a3) = 0;
}

//----- (00409410) --------------------------------------------------------
BOOL __thiscall sub_409410(void *this, int a2, char a3)
{
  int v3; // ebx
  _DWORD *v4; // esi
  unsigned int v5; // eax
  unsigned int v7; // edi
  _DWORD *v8; // ebx

  v3 = a2;
  v4 = this;
  if ( (unsigned int)a2 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v5 = *((_DWORD *)this + 5);
  if ( v5 >= a2 )
  {
    if ( a3 && (unsigned int)a2 < 8 )
    {
      v7 = *((_DWORD *)this + 4);
      if ( a2 < v7 )
        v7 = a2;
      if ( v5 >= 8 )
      {
        v8 = *(_DWORD **)this;
        if ( v7 )
          memcpy_0(this, v8, 2 * v7);
        operator delete(v8);
        v3 = a2;
      }
      v4[4] = v7;
      v4[5] = 7;
      *((_WORD *)v4 + v7) = 0;
      return v3 != 0;
    }
    else
    {
      if ( !a2 )
      {
        *((_DWORD *)this + 4) = 0;
        if ( v5 >= 8 )
          v4 = *(_DWORD **)this;
        *(_WORD *)v4 = 0;
      }
      return a2 != 0;
    }
  }
  else
  {
    sub_409240((int)this, a2, *((const void **)this + 4));
    return a2 != 0;
  }
}

//----- (004094D0) --------------------------------------------------------
__int64 __thiscall sub_4094D0(_DWORD *this, unsigned int a2)
{
  __int64 result; // rax
  bool v3; // cf

  result = a2;
  v3 = this[5] < 8u;
  this[4] = a2;
  if ( !v3 )
    this = (_DWORD *)*this;
  *((_WORD *)this + a2) = 0;
  return result;
}

//----- (004094F0) --------------------------------------------------------
_DWORD *__fastcall sub_4094F0(_DWORD *a1, int a2, void *Src, int a4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  _DWORD *v6; // ecx
  _DWORD *v7; // ecx
  _DWORD *result; // eax
  unsigned int v9; // eax
  void *v10; // eax
  int v11; // ebx
  bool v12; // cf

  v4 = a1;
  if ( !Src )
    goto LABEL_13;
  v5 = a1[5];
  if ( v5 >= 8 )
    a1 = (_DWORD *)*a1;
  if ( Src < a1 || (v5 < 8 ? (v6 = v4) : (v6 = (_DWORD *)*v4), (char *)v6 + 2 * v4[4] <= Src) )
  {
LABEL_13:
    if ( (unsigned int)a4 > 0x7FFFFFFE )
      std::_Xlength_error("string too long");
    v9 = v4[5];
    if ( v9 >= a4 )
    {
      if ( !a4 )
      {
        v4[4] = 0;
        if ( v9 < 8 )
        {
          result = v4;
          *(_WORD *)v4 = 0;
        }
        else
        {
          *(_WORD *)*v4 = 0;
          return v4;
        }
        return result;
      }
    }
    else
    {
      sub_409240((int)v4, a4, (const void *)v4[4]);
      if ( !a4 )
        return v4;
    }
    if ( v4[5] < 8u )
      v10 = v4;
    else
      v10 = (void *)*v4;
    v11 = 2 * a4;
    memcpy_0(v10, Src, 2 * a4);
    v12 = v4[5] < 8u;
    v4[4] = a4;
    if ( !v12 )
    {
      *(_WORD *)(v11 + *v4) = 0;
      return v4;
    }
    *(_WORD *)((char *)v4 + v11) = 0;
    return v4;
  }
  if ( v5 < 8 )
    v7 = v4;
  else
    v7 = (_DWORD *)*v4;
  return (_DWORD *)sub_4090E0((int)v4, v4, ((_BYTE *)Src - (_BYTE *)v7) >> 1, a4);
}

//----- (004095E0) --------------------------------------------------------
_DWORD *__thiscall sub_4095E0(_DWORD *this, void *Src)
{
  this[5] = 7;
  this[4] = 0;
  *(_WORD *)this = 0;
  sub_4094F0(this, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
  return this;
}

//----- (00409630) --------------------------------------------------------
int __stdcall sub_409630(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  int result; // eax
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+10h] [ebp-20h] BYREF
  int v8; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  DWORD dwErrCodea; // [esp+38h] [ebp+8h]

  v8 = 0;
  v1 = (int (__stdcall *)(DWORD))dword_4EF7C0;
  v7 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v7)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v1 )
    {
      v3 = sub_4019E0((DWORD)"ChooseColorW");
      v1 = (int (__stdcall *)(DWORD))v3;
      if ( !v3 )
        goto LABEL_7;
      dword_4EF7C0 = (int)v3;
    }
    v8 = v1(dwErrCode);
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v8;
    v4 = v8 == 0;
    if ( v8 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_15;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_15:
    if ( v4 )
      SetLastError(dwErrCodea);
    return v8;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7C0: using guessed type int dword_4EF7C0;

//----- (00409750) --------------------------------------------------------
int __stdcall sub_409750(int a1, int a2, int a3, DWORD dwErrCode)
{
  int v4; // edi
  int (__stdcall *v5)(int, int, int, DWORD); // esi
  int result; // eax
  FARPROC v7; // eax
  int v8; // esi
  FARPROC v9; // eax
  int v10; // [esp+10h] [ebp-20h] BYREF
  int v11; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  DWORD dwErrCodea; // [esp+44h] [ebp+14h]

  v4 = 0;
  v11 = 0;
  v5 = (int (__stdcall *)(int, int, int, DWORD))dword_4EF7C4;
  v10 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v10)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v5 )
    {
      v7 = sub_4016B0((DWORD)"SetWindowSubclass");
      v5 = (int (__stdcall *)(int, int, int, DWORD))v7;
      if ( !v7 )
        goto LABEL_7;
      dword_4EF7C4 = (int)v7;
    }
    v4 = v5(a1, a2, a3, dwErrCode);
    v11 = v4;
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v4;
    if ( v4 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v8 = v10;
    v9 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v9 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v9 )
        goto LABEL_15;
      dword_4EF118 = (int)v9;
    }
    ((void (__stdcall *)(_DWORD, int))v9)(0, v8);
LABEL_15:
    if ( !v4 )
      SetLastError(dwErrCodea);
    return v4;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7C4: using guessed type int dword_4EF7C4;

//----- (00409880) --------------------------------------------------------
_DWORD *__thiscall sub_409880(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  if ( this[5] >= 8u )
    return (_DWORD *)*this;
  return result;
}

//----- (00409890) --------------------------------------------------------
int __userpurge sub_409890@<eax>(_DWORD *a1@<edi>, int a2)
{
  *(_DWORD *)(a2 + 20) = 7;
  *(_DWORD *)(a2 + 16) = 0;
  *(_WORD *)a2 = 0;
  sub_4090E0(a2, a1, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 48) = 7;
  *(_DWORD *)(a2 + 44) = 0;
  *(_WORD *)(a2 + 28) = 0;
  sub_4090E0(a2 + 28, a1 + 7, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 56) = a1[14];
  *(_DWORD *)(a2 + 60) = a1[15];
  return a2;
}

//----- (00409920) --------------------------------------------------------
int __usercall sub_409920@<eax>(int a1@<esi>)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 48) >= 8u )
    operator delete(*(void **)(a1 + 28));
  *(_DWORD *)(a1 + 48) = 7;
  *(_DWORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 28) = 0;
  if ( *(_DWORD *)(a1 + 20) >= 8u )
    operator delete(*(void **)a1);
  result = 0;
  *(_DWORD *)(a1 + 20) = 7;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)a1 = 0;
  return result;
}

//----- (00409970) --------------------------------------------------------
int __usercall sub_409970@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<ebx>)
{
  _DWORD *v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // esi
  int result; // eax

  v2 = a1;
  v3 = a2[1];
  if ( (unsigned int)a1 >= v3 || *a2 > (unsigned int)a1 )
  {
    if ( v3 == a2[2] )
      sub_409A10(a2);
    result = a2[1];
  }
  else
  {
    v4 = (unsigned int)a1 - *a2;
    if ( v3 == a2[2] )
      sub_409A10(a2);
    result = a2[1];
    v2 = (_DWORD *)(*a2 + (v4 & 0xFFFFFFC0));
  }
  if ( result )
    result = sub_409890(v2, result);
  a2[1] += 64;
  return result;
}

//----- (00409A10) --------------------------------------------------------
unsigned int __thiscall sub_409A10(_DWORD *this)
{
  unsigned int v1; // eax
  unsigned int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edx

  v1 = (this[1] - *this) >> 6;
  if ( v1 > 0x3FFFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v1 + 1;
  v3 = (this[2] - *this) >> 6;
  if ( result > v3 )
  {
    if ( 0x3FFFFFF - (v3 >> 1) >= v3 )
      v4 = (v3 >> 1) + v3;
    else
      v4 = 0;
    if ( v4 < result )
      v4 = result;
    return sub_409A60((int)this, v4);
  }
  return result;
}

//----- (00409A60) --------------------------------------------------------
unsigned int __thiscall sub_409A60(int this, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int result; // eax
  void *v5; // eax
  int v6; // edi
  char *v7; // edi
  _DWORD *v8; // [esp-Ch] [ebp-30h]
  int v9; // [esp+0h] [ebp-24h] BYREF
  void *v10; // [esp+10h] [ebp-14h]
  int *v11; // [esp+14h] [ebp-10h]
  int v12; // [esp+20h] [ebp-4h]

  v11 = &v9;
  v3 = a2;
  if ( a2 > 0x3FFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 6;
  if ( result < a2 )
  {
    v5 = sub_409B40(a2);
    v12 = 0;
    v8 = *(_DWORD **)(this + 4);
    v10 = v5;
    sub_409D50(v8, (int)v5);
    v6 = *(_DWORD *)(this + 4) - *(_DWORD *)this;
    if ( *(_DWORD *)this )
    {
      sub_409CF0(*(_DWORD **)this, *(_DWORD **)(this + 4));
      operator delete(*(void **)this);
      v3 = a2;
    }
    result = (unsigned int)v10;
    v7 = (char *)v10 + (v6 & 0xFFFFFFC0);
    *(_DWORD *)(this + 8) = (char *)v10 + 64 * v3;
    *(_DWORD *)(this + 4) = v7;
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (00409B40) --------------------------------------------------------
void *__fastcall sub_409B40(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x3FFFFFF || (result = operator new(a1 << 6)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00409B90) --------------------------------------------------------
void __fastcall sub_409B90(_DWORD *a1, _DWORD *a2)
{
  int v4; // eax
  void *v5[7]; // [esp+14h] [ebp-58h] BYREF
  void *v6[5]; // [esp+30h] [ebp-3Ch] BYREF
  unsigned int v7; // [esp+44h] [ebp-28h]
  int v8; // [esp+4Ch] [ebp-20h]
  int v9; // [esp+50h] [ebp-1Ch]
  int v10; // [esp+68h] [ebp-4h]

  sub_409890(a1, (int)v5);
  v10 = 0;
  sub_4090E0((int)a1, a2, 0, 0xFFFFFFFF);
  sub_4090E0((int)(a1 + 7), a2 + 7, 0, 0xFFFFFFFF);
  a1[14] = a2[14];
  a1[15] = a2[15];
  sub_4090E0((int)a2, v5, 0, 0xFFFFFFFF);
  sub_4090E0((int)(a2 + 7), v6, 0, 0xFFFFFFFF);
  v4 = v9;
  a2[14] = v8;
  a2[15] = v4;
  if ( v7 >= 8 )
    operator delete(v6[0]);
  v7 = 7;
  v6[4] = 0;
  LOWORD(v6[0]) = 0;
  if ( v5[5] >= (void *)8 )
    operator delete(v5[0]);
}

//----- (00409CA0) --------------------------------------------------------
int __usercall sub_409CA0@<eax>(_DWORD *a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>)
{
  _DWORD *v4; // esi
  int v5; // eax

  if ( a1 != a3 )
  {
    v4 = a1 + 14;
    do
    {
      sub_4090E0(a2, v4 - 14, 0, 0xFFFFFFFF);
      sub_4090E0(a2 + 28, v4 - 7, 0, 0xFFFFFFFF);
      *(_DWORD *)(a2 + 56) = *v4;
      v5 = v4[1];
      v4 += 16;
      *(_DWORD *)(a2 + 60) = v5;
      a2 += 64;
    }
    while ( v4 - 14 != a3 );
  }
  return a2;
}

//----- (00409CF0) --------------------------------------------------------
_DWORD *__usercall sub_409CF0@<eax>(_DWORD *result@<eax>, _DWORD *a2@<ebx>)
{
  _DWORD *v2; // esi

  if ( result != a2 )
  {
    v2 = result + 12;
    do
    {
      if ( *v2 >= 8u )
        operator delete((void *)*(v2 - 5));
      *v2 = 7;
      *(v2 - 1) = 0;
      *((_WORD *)v2 - 10) = 0;
      if ( *(v2 - 7) >= 8u )
        operator delete((void *)*(v2 - 12));
      result = 0;
      *(v2 - 7) = 7;
      *(v2 - 8) = 0;
      *((_WORD *)v2 - 24) = 0;
      v2 += 16;
    }
    while ( v2 - 12 != a2 );
  }
  return result;
}

//----- (00409D50) --------------------------------------------------------
int __cdecl sub_409D50(_DWORD *a1, int a2)
{
  _DWORD *v2; // ecx
  int v3; // esi
  _DWORD *v4; // edi
  _DWORD v6[7]; // [esp+0h] [ebp-28h] BYREF
  int v7; // [esp+24h] [ebp-4h]

  v6[6] = v6;
  v3 = a2;
  v4 = v2;
  v6[5] = a2;
  v7 = 0;
  while ( v4 != a1 )
  {
    v6[4] = v3;
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      *(_DWORD *)(v3 + 20) = 7;
      *(_DWORD *)(v3 + 16) = 0;
      *(_WORD *)v3 = 0;
      sub_4090E0(v3, v4, 0, 0xFFFFFFFF);
      LOBYTE(v7) = 2;
      *(_DWORD *)(v3 + 48) = 7;
      *(_DWORD *)(v3 + 44) = 0;
      *(_WORD *)(v3 + 28) = 0;
      sub_4090E0(v3 + 28, v4 + 7, 0, 0xFFFFFFFF);
      *(_DWORD *)(v3 + 56) = v4[14];
      *(_DWORD *)(v3 + 60) = v4[15];
    }
    v3 += 64;
    LOBYTE(v7) = 0;
    v4 += 16;
  }
  return v3;
}
// 409D7E: variable 'v2' is possibly undefined

//----- (00409E30) --------------------------------------------------------
_DWORD *__thiscall sub_409E30(_DWORD *this, _DWORD *a2)
{
  this[5] = 7;
  this[4] = 0;
  *(_WORD *)this = 0;
  sub_4090E0((int)this, a2, 0, 0xFFFFFFFF);
  return this;
}

//----- (00409E60) --------------------------------------------------------
int __stdcall sub_409E60(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  int result; // eax
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v8 = 0;
  v1 = (int (__stdcall *)(DWORD))dword_4EF7D8;
  v7 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v7)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v1 )
    {
      v3 = sub_4016B0((DWORD)"ImageList_Destroy");
      v1 = (int (__stdcall *)(DWORD))v3;
      if ( !v3 )
        goto LABEL_7;
      dword_4EF7D8 = (int)v3;
    }
    v8 = v1(dwErrCode);
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v8;
    v4 = v8 == 0;
    if ( v8 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_15;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_15:
    if ( v4 )
      SetLastError(dwErrCodea);
    return v8;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7D8: using guessed type int dword_4EF7D8;

//----- (00409F80) --------------------------------------------------------
int __stdcall sub_409F80(int a1, int a2, DWORD dwErrCode)
{
  int v3; // edi
  int (__stdcall *v4)(int, int, DWORD); // esi
  int result; // eax
  FARPROC v6; // eax
  int v7; // esi
  FARPROC v8; // eax
  int v9; // [esp+14h] [ebp-20h] BYREF
  int v10; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+44h] [ebp+10h]

  v3 = 0;
  v10 = 0;
  v4 = (int (__stdcall *)(int, int, DWORD))dword_4EF7D4;
  v9 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v9)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v4 )
    {
      v6 = sub_4016B0((DWORD)"ImageList_GetIcon");
      v4 = (int (__stdcall *)(int, int, DWORD))v6;
      if ( !v6 )
        goto LABEL_7;
      dword_4EF7D4 = (int)v6;
    }
    v3 = v4(a1, a2, dwErrCode);
    v10 = v3;
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v3;
    if ( v3 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v7 = v9;
    v8 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v8 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v8 )
        goto LABEL_15;
      dword_4EF118 = (int)v8;
    }
    ((void (__stdcall *)(_DWORD, int))v8)(0, v7);
LABEL_15:
    if ( !v3 )
      SetLastError(dwErrCodea);
    return v3;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7D4: using guessed type int dword_4EF7D4;

//----- (0040A0B0) --------------------------------------------------------
void __thiscall sub_40A0B0(void *this)
{
  _DWORD *v2; // eax
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  char *v4; // [esp+10h] [ebp-4h] BYREF

  *((_DWORD *)this + 1) = 0;
  v2 = operator new(0x24u);
  if ( !v2 )
  {
    v4 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)this = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)this + 4) = *(_DWORD *)this;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A110) --------------------------------------------------------
void __thiscall sub_40A110(void *this)
{
  sub_40A140((int)this);
  operator delete(*(void **)this);
}

//----- (0040A140) --------------------------------------------------------
void __usercall sub_40A140(int a1@<ebx>)
{
  void **v1; // esi
  void **v2; // edi

  v1 = **(void ****)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(void ***)a1 )
  {
    do
    {
      v2 = (void **)*v1;
      if ( (unsigned int)v1[7] >= 8 )
        operator delete(v1[2]);
      v1[7] = (void *)7;
      v1[6] = 0;
      *((_WORD *)v1 + 4) = 0;
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *(void ***)a1 );
  }
}

//----- (0040A1A0) --------------------------------------------------------
_DWORD *__userpurge sub_40A1A0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>, void *a3)
{
  void *v4; // eax
  void *v6; // [esp+Ch] [ebp+8h]

  v4 = *(void **)a3;
  v6 = *(void **)a3;
  if ( a3 != *(void **)a2 )
  {
    **((_DWORD **)a3 + 1) = *(_DWORD *)a3;
    *(_DWORD *)(*(_DWORD *)a3 + 4) = *((_DWORD *)a3 + 1);
    if ( *((_DWORD *)a3 + 7) >= 8u )
      operator delete(*((void **)a3 + 2));
    *((_DWORD *)a3 + 7) = 7;
    *((_DWORD *)a3 + 6) = 0;
    *((_WORD *)a3 + 4) = 0;
    operator delete(a3);
    v4 = v6;
    --*(_DWORD *)(a2 + 4);
  }
  *a1 = v4;
  return a1;
}

//----- (0040A200) --------------------------------------------------------
char *__stdcall sub_40A200(char *a1, int a2, int a3)
{
  char *v3; // esi
  int v4; // edx
  _WORD *v5; // ecx
  _DWORD *v6; // eax
  int v8; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[5]; // [esp+10h] [ebp-20h] BYREF
  int v10; // [esp+2Ch] [ebp-4h]

  pExceptionObject[4] = (int)&v8;
  v3 = (char *)operator new(0x24u);
  pExceptionObject[3] = (int)v3;
  if ( !v3 )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v10 = 0;
  v4 = a2;
  *(_DWORD *)v3 = a1;
  v5 = v3 + 8;
  *((_DWORD *)v3 + 1) = v4;
  a1 = v3 + 8;
  a2 = (int)(v3 + 8);
  LOBYTE(v10) = 1;
  if ( v3 != (char *)-8 )
  {
    *((_DWORD *)v3 + 6) = 0;
    v6 = (_DWORD *)a3;
    *((_DWORD *)v3 + 7) = 7;
    *v5 = 0;
    sub_4090E0((int)v5, v6, 0, 0xFFFFFFFF);
  }
  return v3;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A2D0) --------------------------------------------------------
int __stdcall sub_40A2D0(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  int result; // eax
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v8 = 0;
  v1 = (int (__stdcall *)(DWORD))dword_4EF7DC;
  v7 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v7)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v1 )
    {
      v3 = sub_4019E0((DWORD)"ChooseFontW");
      v1 = (int (__stdcall *)(DWORD))v3;
      if ( !v3 )
        goto LABEL_7;
      dword_4EF7DC = (int)v3;
    }
    v8 = v1(dwErrCode);
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v8;
    v4 = v8 == 0;
    if ( v8 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_15;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_15:
    if ( v4 )
      SetLastError(dwErrCodea);
    return v8;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF7DC: using guessed type int dword_4EF7DC;

//----- (0040A3F0) --------------------------------------------------------
int __fastcall sub_40A3F0(int a1, _DWORD *a2)
{
  return (unsigned __int8)BYTE2(*a2) | ((((unsigned __int8)*a2 << 8) | (unsigned __int8)BYTE1(*a2)) << 8);
}

//----- (0040A410) --------------------------------------------------------
_DWORD *__usercall sub_40A410@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v4; // [esp+Ch] [ebp-4h] BYREF

  a1[1] = 0;
  v1 = operator new(0x14u);
  if ( !v1 )
  {
    v4 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v1;
  *v1 = v1;
  *(_DWORD *)(*a1 + 4) = *a1;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A470) --------------------------------------------------------
_DWORD *__usercall sub_40A470@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v4; // [esp+Ch] [ebp-4h] BYREF

  a1[1] = 0;
  v1 = operator new(0xCu);
  if ( !v1 )
  {
    v4 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v1;
  *v1 = v1;
  *(_DWORD *)(*a1 + 4) = *a1;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A4D0) --------------------------------------------------------
void __usercall sub_40A4D0(void **a1@<esi>)
{
  if ( *a1 )
  {
    sub_409CF0(*a1, a1[1]);
    operator delete(*a1);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

//----- (0040A550) --------------------------------------------------------
char **__stdcall sub_40A550(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0xCu);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    result[2] = *(char **)a3;
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040A5B0) --------------------------------------------------------
void __usercall sub_40A5B0(int a1@<ebx>)
{
  _DWORD *v1; // edi
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      sub_40A700((int)(v1 + 3));
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *(_DWORD **)a1 );
  }
}

//----- (0040A600) --------------------------------------------------------
void __usercall sub_40A600(int a1@<ebx>)
{
  _DWORD *v1; // edi
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      sub_40A660((int)(v1 + 2));
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *(_DWORD **)a1 );
  }
}

//----- (0040A660) --------------------------------------------------------
void __usercall sub_40A660(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi

  v1 = *(_DWORD ***)(a1 + 524);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 524) + 4) = *(_DWORD *)(a1 + 524);
  *(_DWORD *)(a1 + 528) = 0;
  if ( v2 != *(_DWORD **)(a1 + 524) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 524) );
  }
  operator delete(*(void **)(a1 + 524));
  v4 = *(_DWORD ***)(a1 + 512);
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 512) + 4) = *(_DWORD *)(a1 + 512);
  *(_DWORD *)(a1 + 516) = 0;
  if ( v5 != *(_DWORD **)(a1 + 512) )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != *(_DWORD **)(a1 + 512) );
  }
  operator delete(*(void **)(a1 + 512));
}

//----- (0040A700) --------------------------------------------------------
void __usercall sub_40A700(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  _DWORD **v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  _DWORD **v10; // ecx
  _DWORD *v11; // eax
  _DWORD *v12; // edi
  _DWORD **v13; // ecx
  _DWORD *v14; // eax
  _DWORD *v15; // edi
  _DWORD **v16; // ecx
  _DWORD *v17; // eax
  _DWORD *v18; // edi
  _DWORD **v19; // ecx
  _DWORD *v20; // eax
  _DWORD *v21; // edi

  v1 = *(_DWORD ***)(a1 + 80);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 80) + 4) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 84) = 0;
  if ( v2 != *(_DWORD **)(a1 + 80) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 80) );
  }
  operator delete(*(void **)(a1 + 80));
  v4 = *(_DWORD ***)(a1 + 68);
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 68) + 4) = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 72) = 0;
  if ( v5 != *(_DWORD **)(a1 + 68) )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != *(_DWORD **)(a1 + 68) );
  }
  operator delete(*(void **)(a1 + 68));
  v7 = *(_DWORD ***)(a1 + 56);
  v8 = *v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 60) = 0;
  if ( v8 != *(_DWORD **)(a1 + 56) )
  {
    do
    {
      v9 = (_DWORD *)*v8;
      operator delete(v8);
      v8 = v9;
    }
    while ( v9 != *(_DWORD **)(a1 + 56) );
  }
  operator delete(*(void **)(a1 + 56));
  v10 = *(_DWORD ***)(a1 + 44);
  v11 = *v10;
  *v10 = v10;
  *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 48) = 0;
  if ( v11 != *(_DWORD **)(a1 + 44) )
  {
    do
    {
      v12 = (_DWORD *)*v11;
      operator delete(v11);
      v11 = v12;
    }
    while ( v12 != *(_DWORD **)(a1 + 44) );
  }
  operator delete(*(void **)(a1 + 44));
  v13 = *(_DWORD ***)(a1 + 32);
  v14 = *v13;
  *v13 = v13;
  *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 36) = 0;
  if ( v14 != *(_DWORD **)(a1 + 32) )
  {
    do
    {
      v15 = (_DWORD *)*v14;
      operator delete(v14);
      v14 = v15;
    }
    while ( v15 != *(_DWORD **)(a1 + 32) );
  }
  operator delete(*(void **)(a1 + 32));
  v16 = *(_DWORD ***)(a1 + 20);
  v17 = *v16;
  *v16 = v16;
  *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 24) = 0;
  if ( v17 != *(_DWORD **)(a1 + 20) )
  {
    do
    {
      v18 = (_DWORD *)*v17;
      operator delete(v17);
      v17 = v18;
    }
    while ( v18 != *(_DWORD **)(a1 + 20) );
  }
  operator delete(*(void **)(a1 + 20));
  v19 = *(_DWORD ***)(a1 + 8);
  v20 = *v19;
  *v19 = v19;
  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  if ( v20 != *(_DWORD **)(a1 + 8) )
  {
    do
    {
      v21 = (_DWORD *)*v20;
      operator delete(v20);
      v20 = v21;
    }
    while ( v21 != *(_DWORD **)(a1 + 8) );
  }
  operator delete(*(void **)(a1 + 8));
}

//----- (0040A890) --------------------------------------------------------
int __stdcall sub_40A890(int a1)
{
  return sub_4A1220((void *)(a1 - 4));
}

//----- (0040A8A0) --------------------------------------------------------
int __stdcall sub_40A8A0(int a1)
{
  return sub_4A1220((void *)(a1 - 8));
}

//----- (0040A8B0) --------------------------------------------------------
int __stdcall sub_40A8B0(int a1)
{
  return sub_4A1220((void *)(a1 - 12));
}

//----- (0040A8C0) --------------------------------------------------------
int __stdcall sub_40A8C0(int a1)
{
  return sub_4A08C0(a1 - 4);
}

//----- (0040A8D0) --------------------------------------------------------
int __stdcall sub_40A8D0(int a1)
{
  return sub_4A08C0(a1 - 8);
}

//----- (0040A8E0) --------------------------------------------------------
int __stdcall sub_40A8E0(int a1)
{
  return sub_4A08C0(a1 - 12);
}

//----- (0040A8F0) --------------------------------------------------------
int __stdcall sub_40A8F0(int a1, _DWORD *a2, int *a3)
{
  return sub_4A0BC0(a1 - 4, a2, a3);
}

//----- (0040A900) --------------------------------------------------------
int __stdcall sub_40A900(int a1, _DWORD *a2, int *a3)
{
  return sub_4A0BC0(a1 - 8, a2, a3);
}

//----- (0040A910) --------------------------------------------------------
int __stdcall sub_40A910(int a1, _DWORD *a2, int *a3)
{
  return sub_4A0BC0(a1 - 12, a2, a3);
}

//----- (0040A920) --------------------------------------------------------
HMODULE __stdcall sub_40A920(LPCWSTR lpLibFileName)
{
  HMODULE result; // eax
  BOOL v2; // edi
  int v3; // esi
  FARPROC v4; // eax
  int v5; // [esp+14h] [ebp-20h] BYREF
  HMODULE LibraryW; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  LPCWSTR lpLibFileNamea; // [esp+3Ch] [ebp+8h]

  LibraryW = 0;
  v5 = 0;
  if ( dword_4EF798 || (result = (HMODULE)sub_4015E0((int)&v5)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    LibraryW = LoadLibraryW(lpLibFileName);
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return LibraryW;
    v2 = LibraryW == 0;
    if ( LibraryW )
      lpLibFileNamea = 0;
    else
      lpLibFileNamea = (LPCWSTR)GetLastError();
    v3 = v5;
    v4 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v4 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v4 )
        goto LABEL_11;
      dword_4EF118 = (int)v4;
    }
    ((void (__stdcall *)(_DWORD, int))v4)(0, v3);
LABEL_11:
    if ( v2 )
      SetLastError((DWORD)lpLibFileNamea);
    return LibraryW;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (0040AA20) --------------------------------------------------------
int __fastcall sub_40AA20(_DWORD *a1, _DWORD *a2)
{
  unsigned int v2; // eax

  v2 = 16;
  while ( *a2 == *a1 )
  {
    v2 -= 4;
    ++a1;
    ++a2;
    if ( v2 < 4 )
      return 1;
  }
  return 0;
}

//----- (0040AA90) --------------------------------------------------------
void *__thiscall sub_40AA90(void *this, char a2)
{
  void **v3; // ebx

  v3 = (void **)((char *)this + 540);
  *(_DWORD *)this = &CFilterDialogPersistentSettings::`vftable';
  sub_40A140((int)this + 540);
  operator delete(*v3);
  *(_DWORD *)this = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CBDA4: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (0040AAD0) --------------------------------------------------------
char *__usercall sub_40AAD0@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v2; // esi
  char *result; // eax
  int v4; // ecx

  v2 = *(char **)a2;
  result = sub_40A200(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), a1);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 153391688 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  **((_DWORD **)result + 1) = result;
  return result;
}

//----- (0040AB10) --------------------------------------------------------
int *__cdecl sub_40AB10(_DWORD *a1, _DWORD *a2)
{
  int *result; // eax
  int *v3; // ecx
  int v4; // edx
  int v5; // esi
  int v6; // edi
  int v7; // edx
  int v8; // edx
  int v9; // [esp+1Ch] [ebp-14h]

  result = a2 + 2;
  v3 = a1 + 2;
  if ( a1 + 2 != a2 + 2 )
  {
    v4 = *v3;
    v5 = a1[3];
    v6 = a1[4];
    v9 = a1[5];
    *v3 = *result;
    a1[3] = a2[3];
    a1[4] = a2[4];
    a1[5] = a2[5];
    *result = v4;
    a2[3] = v5;
    a2[4] = v6;
    a2[5] = v9;
    v7 = a1[6];
    a1[6] = a2[6];
    a2[6] = v7;
    v8 = a1[7];
    a1[7] = a2[7];
    a2[7] = v8;
  }
  return result;
}

//----- (0040ABC0) --------------------------------------------------------
_DWORD *__fastcall sub_40ABC0(int a1, void *a2, _DWORD *a3)
{
  return sub_4094F0(a3, (int)a2, a2, wcslen((const unsigned __int16 *)a2));
}

//----- (0040ABF0) --------------------------------------------------------
_DWORD *__userpurge sub_40ABF0@<eax>(_DWORD *a1@<edi>, int a2@<esi>, void *a3)
{
  void *v4; // ecx
  void *v6; // [esp+8h] [ebp+8h]

  v4 = *(void **)a3;
  v6 = *(void **)a3;
  if ( a3 == *(void **)a2 )
  {
    *a1 = v4;
  }
  else
  {
    **((_DWORD **)a3 + 1) = *(_DWORD *)a3;
    *(_DWORD *)(*(_DWORD *)a3 + 4) = *((_DWORD *)a3 + 1);
    operator delete(a3);
    --*(_DWORD *)(a2 + 4);
    *a1 = v6;
  }
  return a1;
}

//----- (0040AC30) --------------------------------------------------------
char ***__stdcall sub_40AC30(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0x24u);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_40B6E0((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040ACF0) --------------------------------------------------------
char ***__stdcall sub_40ACF0(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0xCu);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_40B4B0((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040ADB0) --------------------------------------------------------
char ***__stdcall sub_40ADB0(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0x460u);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_40B580((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040AE70) --------------------------------------------------------
char **__usercall sub_40AE70@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v2; // esi
  char **result; // eax
  int v4; // ecx

  v2 = *(char **)a2;
  result = sub_40AFF0(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), a1);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 3862379 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0040AEB0) --------------------------------------------------------
_DWORD *__usercall sub_40AEB0@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v4; // [esp+Ch] [ebp-4h] BYREF

  a1[1] = 0;
  v1 = operator new(0x40u);
  if ( !v1 )
  {
    v4 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v1;
  *v1 = v1;
  *(_DWORD *)(*a1 + 4) = *a1;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040AF30) --------------------------------------------------------
char *__usercall sub_40AF30@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v2; // esi
  char *result; // eax
  int v4; // ecx

  v2 = *(char **)a2;
  result = sub_40B0E0(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), a1);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 76695843 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  **((_DWORD **)result + 1) = result;
  return result;
}

//----- (0040AF70) --------------------------------------------------------
void *__thiscall sub_40AF70(void *this, void *Src)
{
  if ( this != Src )
  {
    if ( *((_DWORD *)this + 5) >= 8u )
      operator delete(*(void **)this);
    *((_DWORD *)this + 5) = 7;
    *((_DWORD *)this + 4) = 0;
    *(_WORD *)this = 0;
    if ( *((_DWORD *)Src + 5) >= 8u )
    {
      *(_DWORD *)this = *(_DWORD *)Src;
      *(_DWORD *)Src = 0;
    }
    else
    {
      memcpy(this, Src, 2 * *((_DWORD *)Src + 4) + 2);
    }
    *((_DWORD *)this + 4) = *((_DWORD *)Src + 4);
    *((_DWORD *)this + 5) = *((_DWORD *)Src + 5);
    *((_DWORD *)Src + 5) = 7;
    *((_DWORD *)Src + 4) = 0;
    *(_WORD *)Src = 0;
  }
  return this;
}

//----- (0040AFF0) --------------------------------------------------------
char **__stdcall sub_40AFF0(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x460u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x458u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040B060) --------------------------------------------------------
void __usercall sub_40B060(int a1@<ebx>)
{
  void **v1; // esi
  void **v2; // edi

  v1 = **(void ****)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(void ***)a1 )
  {
    do
    {
      v2 = (void **)*v1;
      if ( (unsigned int)v1[14] >= 8 )
        operator delete(v1[9]);
      v1[14] = (void *)7;
      v1[13] = 0;
      *((_WORD *)v1 + 18) = 0;
      if ( (unsigned int)v1[7] >= 8 )
        operator delete(v1[2]);
      v1[7] = (void *)7;
      v1[6] = 0;
      *((_WORD *)v1 + 4) = 0;
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *(void ***)a1 );
  }
}

//----- (0040B0E0) --------------------------------------------------------
char *__stdcall sub_40B0E0(char *a1, int a2, int a3)
{
  char *v3; // eax
  char *v4; // esi
  int v5; // ecx
  int v7; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[5]; // [esp+10h] [ebp-20h] BYREF
  int v9; // [esp+2Ch] [ebp-4h]

  pExceptionObject[4] = (int)&v7;
  v3 = (char *)operator new(0x40u);
  v4 = v3;
  pExceptionObject[3] = (int)v3;
  if ( !v3 )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v9 = 0;
  v5 = a2;
  *(_DWORD *)v3 = a1;
  *((_DWORD *)v3 + 1) = v5;
  a1 = v3 + 8;
  a2 = (int)(v3 + 8);
  LOBYTE(v9) = 1;
  if ( v3 != (char *)-8 )
    sub_40B650((_DWORD *)a3, (int)(v3 + 8));
  return v4;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040B1A0) --------------------------------------------------------
_DWORD *__usercall sub_40B1A0@<eax>(unsigned __int16 *a1@<edx>, _DWORD *a2@<esi>, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = sub_40B220(wcslen(a1), a3, a1);
  a2[5] = 7;
  a2[4] = 0;
  *(_WORD *)a2 = 0;
  sub_40AF70(a2, v3);
  return a2;
}

//----- (0040B1F0) --------------------------------------------------------
void *__thiscall sub_40B1F0(void *this, void *Src)
{
  *((_DWORD *)this + 5) = 7;
  *((_DWORD *)this + 4) = 0;
  *(_WORD *)this = 0;
  sub_40AF70(this, Src);
  return this;
}

//----- (0040B220) --------------------------------------------------------
_DWORD *__userpurge sub_40B220@<eax>(unsigned int a1@<eax>, _DWORD *a2@<ecx>, void *Src)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  _DWORD *v6; // ecx
  _DWORD *result; // eax
  const void *v8; // eax
  unsigned int v9; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // eax
  void *v12; // ecx
  _DWORD *v13; // eax
  size_t v14; // edi
  void *v15; // eax

  v4 = a2;
  if ( Src )
  {
    v5 = a2[5];
    if ( v5 >= 8 )
      a2 = (_DWORD *)*a2;
    if ( Src >= a2 )
    {
      v6 = v5 < 8 ? v4 : (_DWORD *)*v4;
      if ( (char *)v6 + 2 * v4[4] > Src )
      {
        if ( v5 < 8 )
          return sub_40B350(a1, v4, v4, ((_BYTE *)Src - (_BYTE *)v4) >> 1);
        else
          return sub_40B350(a1, v4, v4, ((int)Src - *v4) >> 1);
      }
    }
  }
  v8 = (const void *)v4[4];
  if ( -1 - (int)v8 <= a1 )
    std::_Xlength_error("string too long");
  if ( !a1 )
    return v4;
  v9 = (unsigned int)v8 + a1;
  if ( (unsigned int)v8 + a1 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v10 = v4[5];
  if ( v10 < v9 )
  {
    sub_409240((int)v4, (unsigned int)v8 + a1, v8);
    if ( v9 )
    {
LABEL_19:
      v11 = v4[5];
      if ( v11 < 8 )
        v12 = v4;
      else
        v12 = (void *)*v4;
      if ( v11 < 8 )
        v13 = v4;
      else
        v13 = (_DWORD *)*v4;
      v14 = 2 * a1;
      sub_409030((char *)v13 + v14, v12, v4[4]);
      if ( v4[5] < 8u )
        v15 = v4;
      else
        v15 = (void *)*v4;
      memcpy_0(v15, Src, v14);
      sub_4094D0(v4, v9);
    }
    return v4;
  }
  if ( v9 )
    goto LABEL_19;
  v4[4] = 0;
  if ( v10 < 8 )
  {
    result = v4;
    *(_WORD *)v4 = 0;
  }
  else
  {
    *(_WORD *)*v4 = 0;
    return v4;
  }
  return result;
}

//----- (0040B350) --------------------------------------------------------
_DWORD *__userpurge sub_40B350@<eax>(unsigned int a1@<eax>, _DWORD *a2@<esi>, _DWORD *a3, unsigned int a4)
{
  unsigned int v5; // eax
  unsigned int v6; // eax
  char *v7; // eax
  char *v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *result; // eax
  _DWORD *v13; // eax
  unsigned int v14; // edx
  unsigned int v15; // eax
  _DWORD *v16; // ecx
  _DWORD *v17; // ecx
  _DWORD *v18; // eax
  unsigned int v19; // [esp+4h] [ebp-4h]

  v5 = a3[4];
  if ( v5 < a4 )
    std::_Xout_of_range("invalid string position");
  v6 = v5 - a4;
  if ( v6 < a1 )
    a1 = v6;
  v7 = (char *)a2[4];
  if ( -1 - (int)v7 <= a1 )
    std::_Xlength_error("string too long");
  if ( !a1 )
    return a2;
  v8 = &v7[a1];
  v19 = (unsigned int)&v7[a1];
  if ( (unsigned int)&v7[a1] > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v9 = a2[5];
  if ( v9 < (unsigned int)v8 )
  {
    sub_409240((int)a2, (unsigned int)&v7[a1], v7);
    if ( !v8 )
      return a2;
LABEL_11:
    v10 = a2[5];
    if ( v10 < 8 )
      v11 = a2;
    else
      v11 = (_DWORD *)*a2;
    if ( v10 < 8 )
      v13 = a2;
    else
      v13 = (_DWORD *)*a2;
    sub_409030((char *)v13 + 2 * a1, v11, a2[4]);
    if ( a2 == a3 )
    {
      v14 = a4 + a1;
      if ( !a4 )
        v14 = 0;
      v15 = a2[5];
      if ( v15 < 8 )
        v16 = a2;
      else
        v16 = (_DWORD *)*a2;
      if ( v15 < 8 )
        sub_409030(a2, (char *)v16 + 2 * v14, a1);
      else
        sub_409030((void *)*a2, (char *)v16 + 2 * v14, a1);
    }
    else
    {
      if ( a3[5] < 8u )
        v17 = a3;
      else
        v17 = (_DWORD *)*a3;
      if ( a2[5] < 8u )
        v18 = a2;
      else
        v18 = (_DWORD *)*a2;
      memcpy_0(v18, (char *)v17 + 2 * a4, 2 * a1);
    }
    sub_4094D0(a2, v19);
    return a2;
  }
  if ( v8 )
    goto LABEL_11;
  a2[4] = 0;
  if ( v9 < 8 )
  {
    result = a2;
    *(_WORD *)a2 = 0;
  }
  else
  {
    *(_WORD *)*a2 = 0;
    return a2;
  }
  return result;
}

//----- (0040B4B0) --------------------------------------------------------
int __stdcall sub_40B4B0(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char **v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_40A550(a2, *((_DWORD *)a2 + 1), result + 8);
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 1073741822 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    *(_DWORD *)v6[1] = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (0040B580) --------------------------------------------------------
int __stdcall sub_40B580(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char **v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_40AFF0(a2, *((_DWORD *)a2 + 1), result + 8);
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 3862379 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    *(_DWORD *)v6[1] = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (0040B650) --------------------------------------------------------
int __thiscall sub_40B650(_DWORD *this, int a2)
{
  *(_DWORD *)(a2 + 20) = 7;
  *(_DWORD *)(a2 + 16) = 0;
  *(_WORD *)a2 = 0;
  sub_4090E0(a2, this, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 48) = 7;
  *(_DWORD *)(a2 + 44) = 0;
  *(_WORD *)(a2 + 28) = 0;
  sub_4090E0(a2 + 28, this + 7, 0, 0xFFFFFFFF);
  return a2;
}

//----- (0040B6E0) --------------------------------------------------------
int __stdcall sub_40B6E0(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char *v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_40A200(a2, *((_DWORD *)a2 + 1), result + 8);
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 153391688 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    **((_DWORD **)v6 + 1) = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (0040B7B0) --------------------------------------------------------
char **__usercall sub_40B7B0@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v2; // esi
  char **result; // eax
  int v4; // ecx

  v2 = *(char **)a2;
  result = sub_40A550(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), a1);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0040B7F0) --------------------------------------------------------
char ***__usercall sub_40B7F0@<eax>(int **a1@<eax>, char ***a2@<ecx>)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( a2 != (char ***)a1 )
    sub_40B820(a2, **a1, (int)*a1, v4);
  return a2;
}
// 40B805: variable 'v4' is possibly undefined

//----- (0040B820) --------------------------------------------------------
int __userpurge sub_40B820@<eax>(char ***a1@<esi>, int a2, int a3, int a4)
{
  char *v4; // eax
  char **v5; // edi

  v4 = **a1;
  **a1 = (char *)*a1;
  (*a1)[1] = (char *)*a1;
  a1[1] = 0;
  if ( v4 != (char *)*a1 )
  {
    do
    {
      v5 = *(char ***)v4;
      operator delete(v4);
      v4 = (char *)v5;
    }
    while ( v5 != *a1 );
  }
  return sub_40B870((int)a1, **a1, a2, a3, a3);
}

//----- (0040B870) --------------------------------------------------------
int __stdcall sub_40B870(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char **v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_41EEB0((char **)(result + 8), a2, *((_DWORD *)a2 + 1));
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    *(_DWORD *)v6[1] = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (0040B950) --------------------------------------------------------
int __usercall sub_40B950@<eax>(int result@<eax>, int a2@<edi>)
{
  int i; // esi
  _DWORD *v3; // eax
  int (__thiscall ***v4)(_DWORD, int); // ecx

  for ( i = result; i != a2; result = (**v4)(v4, 1) )
  {
    if ( !i )
      break;
    v3 = (_DWORD *)(i + 12);
    v4 = (int (__thiscall ***)(_DWORD, int))i;
    i = *(_DWORD *)(i + 12);
    *v3 = 0;
  }
  return result;
}

//----- (0040B980) --------------------------------------------------------
int __stdcall sub_40B980(_DWORD *a1)
{
  int i; // esi
  _DWORD *v2; // eax
  int (__thiscall ***v3)(_DWORD, int); // ecx
  int result; // eax

  *a1 = &std::tr1::_Node_assert::`vftable';
  for ( i = a1[5]; i; result = (**v3)(v3, 1) )
  {
    v2 = (_DWORD *)(i + 12);
    v3 = (int (__thiscall ***)(_DWORD, int))i;
    i = *(_DWORD *)(i + 12);
    *v2 = 0;
  }
  *a1 = &std::tr1::_Node_base::`vftable';
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';
// 4CBF74: using guessed type void *std::tr1::_Node_assert::`vftable';

//----- (0040B9F0) --------------------------------------------------------
void *__thiscall sub_40B9F0(void *this, char a2)
{
  sub_40B980(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0040BA20) --------------------------------------------------------
void *__thiscall sub_40BA20(void *this, char a2)
{
  *(_DWORD *)this = &std::tr1::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (0040BA50) --------------------------------------------------------
_DWORD *__stdcall sub_40BA50(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // edi
  _DWORD *v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  _DWORD *result; // eax

  v1 = a1;
  *a1 = &std::tr1::_Node_if::`vftable';
  v2 = a1[6];
  if ( v2 )
  {
    while ( 1 )
    {
      v3 = (_DWORD *)(v2 + 24);
      v4 = v2;
      v2 = *(_DWORD *)(v2 + 24);
      *v3 = 0;
      v5 = v1[5];
      while ( v4 != v5 )
      {
        if ( !v4 )
          break;
        v6 = (_DWORD *)(v4 + 12);
        v7 = (void (__thiscall ***)(_DWORD, int))v4;
        v4 = *(_DWORD *)(v4 + 12);
        *v6 = 0;
        (**v7)(v7, 1);
      }
      if ( !v2 )
        break;
      v1 = a1;
    }
    result = a1;
    *a1 = &std::tr1::_Node_base::`vftable';
  }
  else
  {
    *a1 = &std::tr1::_Node_base::`vftable';
  }
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';
// 4CBF94: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (0040BB00) --------------------------------------------------------
void *__thiscall sub_40BB00(void *this, char a2)
{
  sub_40BA50(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0040BB60) --------------------------------------------------------
void __usercall sub_40BB60(int a1@<eax>)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(a1 + 96);
  sub_40BF20((_DWORD *)(a1 + 96));
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';

//----- (0040BB80) --------------------------------------------------------
int *__stdcall sub_40BB80(int *a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  struct std::locale::facet *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // esi
  void (__thiscall ***v12)(_DWORD, int); // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // esi
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  _DWORD v22[6]; // [esp+0h] [ebp-40h] BYREF
  bool v23; // [esp+18h] [ebp-28h]
  int v24; // [esp+1Ch] [ebp-24h] BYREF
  char v25[4]; // [esp+20h] [ebp-20h] BYREF
  int v26; // [esp+24h] [ebp-1Ch] BYREF
  int v27; // [esp+28h] [ebp-18h]
  struct std::locale::facet *v28; // [esp+2Ch] [ebp-14h]
  _DWORD *v29; // [esp+30h] [ebp-10h]
  int v30; // [esp+3Ch] [ebp-4h]

  v29 = v22;
  v2 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  v3 = 0;
  v27 = 0;
  v22[5] = a1;
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v30 = 0;
  v4 = *(_DWORD *)(*a1 + 4);
  if ( !*(int *)((char *)a1 + v4 + 12) )
  {
    v5 = *(int *)((char *)a1 + v4 + 60);
    if ( v5 )
      sub_408280(v5);
  }
  v6 = *a1;
  v23 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 12) == 0;
  v30 = 1;
  if ( v23 )
  {
    v7 = sub_408A70((_DWORD **)((char *)a1 + *(_DWORD *)(v6 + 4)), &v26);
    LOBYTE(v30) = 2;
    v8 = sub_40E010((int)v7);
    LOBYTE(v30) = 1;
    v9 = v26;
    v28 = v8;
    if ( v26 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v25, 0);
      v10 = *(_DWORD *)(v9 + 4);
      if ( v10 && v10 != -1 )
        *(_DWORD *)(v9 + 4) = v10 - 1;
      v11 = -(*(_DWORD *)(v9 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v25);
      v12 = (void (__thiscall ***)(_DWORD, int))(v9 & v11);
      if ( v12 )
        (**v12)(v12, 1);
    }
    v13 = *a1;
    LOBYTE(v30) = 3;
    v14 = *(_DWORD *)(v13 + 4);
    v15 = *(int *)((char *)a1 + v14 + 56);
    v16 = *(_DWORD *)v28;
    LOBYTE(v24) = 0;
    (*(void (__thiscall **)(struct std::locale::facet *, int *, int, int, char *, _DWORD, int))(v16 + 28))(
      v28,
      &v24,
      v24,
      v15,
      (char *)a1 + v14,
      *(unsigned __int16 *)((char *)a1 + v14 + 64),
      a2);
    v3 = 4;
    if ( !(_BYTE)v24 )
      v3 = v27;
    v30 = 1;
  }
  v17 = (int *)((char *)a1 + *(_DWORD *)(*a1 + 4));
  if ( v3 )
  {
    v18 = v3 | v17[3];
    if ( !v17[14] )
      LOBYTE(v18) = v18 | 4;
    v19 = v18 & 0x17;
    v17[3] = v19;
    if ( (v19 & v17[4]) != 0 )
      sub_408D30(0);
  }
  v30 = 5;
  if ( !__uncaught_exception() )
    sub_4134F0(a1);
  v30 = -1;
  v20 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  if ( v20 )
    (*(void (**)(void))(*(_DWORD *)v20 + 8))();
  return a1;
}
// 40BB80: using guessed type char var_20[4];

//----- (0040BD70) --------------------------------------------------------
void __stdcall sub_40BD70(int *a1)
{
  int *v1; // esi
  int v2; // eax
  int v4; // edi
  int v5; // eax
  int v6; // esi
  void (__thiscall ***v7)(_DWORD, int); // esi

  v1 = a1;
  v2 = *a1;
  if ( *a1 )
  {
    if ( (*(_DWORD *)(v2 + 28))-- == 1 )
      sub_40B950(*v1, 0);
  }
  *v1 = 0;
  v4 = v1[3];
  if ( v4 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v5 = *(_DWORD *)(v4 + 4);
    if ( v5 && v5 != -1 )
      *(_DWORD *)(v4 + 4) = v5 - 1;
    v6 = -(*(_DWORD *)(v4 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    v7 = (void (__thiscall ***)(_DWORD, int))(v4 & v6);
    if ( v7 )
      (**v7)(v7, 1);
  }
}

//----- (0040BE20) --------------------------------------------------------
int *__userpurge sub_40BE20@<eax>(int *a1@<eax>, const unsigned __int16 *a2@<edi>, unsigned int a3)
{
  if ( !a2 )
    std::tr1::_Xbad(13);
  sub_40E150((int)&a2[wcslen(a2)], a3, a1, (int)a2, a3);
  return a1;
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (0040BE70) --------------------------------------------------------
_DWORD *__stdcall sub_40BE70(_DWORD *a1)
{
  *a1 = &unk_4CBF50;
  a1[4] = &unk_4CCA3C;
  a1[24] = &std::wios::`vftable';
  sub_402740(a1, (int)(a1 + 6));
  *(_DWORD *)((char *)a1 + *(_DWORD *)(a1[4] + 4) + 16) = &std::wostream::`vftable';
  *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 + 4)) = &std::wiostream::`vftable';
  *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 + 4)) = &std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
  sub_403840(a1 + 6);
  a1[6] = &std::wstringbuf::`vftable';
  a1[21] = 0;
  a1[22] = 0;
  return a1;
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBAD4: using guessed type void *std::wios::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CBF4C: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (0040BF20) --------------------------------------------------------
int __thiscall sub_40BF20(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 24) + 4) - 96) = &std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
  v1 = this - 18;
  *(this - 18) = &std::wstringbuf::`vftable';
  sub_4027E0((int)(this - 18));
  sub_408180(v1);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(v1 - 6) + 4) - 24) = &std::wiostream::`vftable';
  result = *(_DWORD *)(*(v1 - 2) + 4);
  *(_DWORD *)((char *)v1 + result - 8) = &std::wostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(v1 - 6) + 4) - 24) = &std::wistream::`vftable';
  return result;
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CBF4C: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (0040BFB0) --------------------------------------------------------
_DWORD *__usercall sub_40BFB0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  sub_40C6D0(a2, a1 + 24);
  return a2;
}

//----- (0040C000) --------------------------------------------------------
void __usercall sub_40C000(int a1@<eax>)
{
  int v1; // edi
  int v2; // eax
  int v3; // esi
  void (__thiscall ***v4)(_DWORD, int); // esi
  char v5[4]; // [esp+4h] [ebp-4h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
    v2 = *(_DWORD *)(v1 + 4);
    if ( v2 && v2 != -1 )
      *(_DWORD *)(v1 + 4) = v2 - 1;
    v3 = -(*(_DWORD *)(v1 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v5);
    v4 = (void (__thiscall ***)(_DWORD, int))(v1 & v3);
    if ( v4 )
      (**v4)(v4, 1);
  }
}
// 40C000: using guessed type char var_4[4];

//----- (0040C050) --------------------------------------------------------
char *__thiscall sub_40C050(struct std::ios_base *this, char a2)
{
  char *v2; // edi

  v2 = (char *)this - 96;
  sub_40BF20(this);
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return v2;
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';

//----- (0040C090) --------------------------------------------------------
char *__thiscall sub_40C090(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 24;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24) = &std::wiostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::wostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24) = &std::wistream::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return v2;
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (0040C0F0) --------------------------------------------------------
_DWORD *__userpurge sub_40C0F0@<eax>(
        unsigned int a1@<eax>,
        _DWORD *a2@<esi>,
        unsigned int a3,
        _DWORD *a4,
        unsigned int a5,
        unsigned int a6)
{
  char *v6; // ecx
  unsigned int v8; // edx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // edx
  _DWORD *v13; // eax
  unsigned int v14; // eax
  _DWORD *v15; // ecx
  _DWORD *v16; // eax
  _DWORD *v17; // ecx
  _DWORD *v18; // eax
  unsigned int v19; // eax
  _DWORD *v20; // ecx
  _DWORD *v21; // eax
  unsigned int v22; // eax
  _DWORD *v23; // ecx
  _DWORD *v24; // eax
  unsigned int v25; // eax
  _DWORD *v26; // ecx
  _DWORD *v27; // eax
  unsigned int v28; // eax
  _DWORD *v29; // ecx
  unsigned int v30; // eax
  _DWORD *v31; // ecx
  _DWORD *v32; // eax
  unsigned int v33; // eax
  _DWORD *v34; // edx
  _DWORD *v35; // ecx
  char *v36; // eax
  _DWORD *v37; // ecx
  _DWORD *v38; // eax
  unsigned int v39; // eax
  _DWORD *v40; // ecx
  _DWORD *v41; // eax
  unsigned int v42; // eax
  _DWORD *v43; // ecx
  _DWORD *v44; // eax
  bool v45; // cf
  _DWORD *result; // eax
  char *v47; // [esp-8h] [ebp-14h]
  int v48; // [esp-4h] [ebp-10h]
  unsigned int v49; // [esp+8h] [ebp-4h]
  unsigned int v50; // [esp+18h] [ebp+Ch]
  int v51; // [esp+20h] [ebp+14h]

  v6 = (char *)a2[4];
  if ( (unsigned int)v6 < a1 || (v8 = a4[4], v8 < a5) )
    std::_Xout_of_range("invalid string position");
  if ( (unsigned int)&v6[-a1] < a3 )
    a3 = (unsigned int)&v6[-a1];
  v9 = v8 - a5;
  if ( v9 < a6 )
    a6 = v9;
  if ( -1 - a6 <= (unsigned int)&v6[-a3] )
    std::_Xlength_error("string too long");
  v10 = a6;
  v49 = (unsigned int)&v6[-a1 - a3];
  v11 = (unsigned int)&v6[a6 - a3];
  v51 = v11;
  if ( (unsigned int)v6 < v11 )
  {
    if ( v11 > 0x7FFFFFFE )
      std::_Xlength_error("string too long");
    v12 = a2[5];
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        a2[4] = 0;
        if ( v12 < 8 )
          v13 = a2;
        else
          v13 = (_DWORD *)*a2;
        *(_WORD *)v13 = 0;
      }
    }
    else
    {
      sub_409240((int)a2, v11, v6);
    }
  }
  if ( a2 == a4 )
  {
    if ( v10 > a3 )
    {
      if ( a5 > a1 )
      {
        v50 = a1 + a3;
        v30 = a2[5];
        if ( a1 + a3 > a5 )
        {
          if ( v30 < 8 )
            v37 = a2;
          else
            v37 = (_DWORD *)*a2;
          if ( v30 < 8 )
            v38 = a2;
          else
            v38 = (_DWORD *)*a2;
          sub_409030((char *)v38 + 2 * a1, (char *)v37 + 2 * a5, a3);
          v39 = a2[5];
          if ( v39 < 8 )
            v40 = a2;
          else
            v40 = (_DWORD *)*a2;
          if ( v39 < 8 )
            v41 = a2;
          else
            v41 = (_DWORD *)*a2;
          sub_409030((char *)v41 + 2 * v10 + 2 * a1, (char *)v40 + 2 * v50, v49);
          v42 = a2[5];
          if ( v42 < 8 )
            v43 = a2;
          else
            v43 = (_DWORD *)*a2;
          if ( v42 < 8 )
            v44 = a2;
          else
            v44 = (_DWORD *)*a2;
          v48 = v10 - a3;
          v47 = (char *)v43 + 2 * v10 + 2 * a5;
          v36 = (char *)v44 + 2 * v50;
        }
        else
        {
          if ( v30 < 8 )
            v31 = a2;
          else
            v31 = (_DWORD *)*a2;
          if ( v30 < 8 )
            v32 = a2;
          else
            v32 = (_DWORD *)*a2;
          sub_409030((char *)v32 + 2 * a1 + 2 * v10, (char *)v31 + 2 * v50, v49);
          v33 = a2[5];
          if ( v33 < 8 )
            v34 = a2;
          else
            v34 = (_DWORD *)*a2;
          if ( v33 < 8 )
            v35 = a2;
          else
            v35 = (_DWORD *)*a2;
          v48 = v10;
          v47 = (char *)v34 + 2 * v10 + 2 * (a5 - a3);
          v36 = (char *)v35 + 2 * a1;
        }
        sub_409030(v36, v47, v48);
      }
      else
      {
        v25 = a2[5];
        if ( v25 < 8 )
          v26 = a2;
        else
          v26 = (_DWORD *)*a2;
        if ( v25 < 8 )
          v27 = a2;
        else
          v27 = (_DWORD *)*a2;
        sub_409030((char *)v27 + 2 * a1 + 2 * v10, (char *)v26 + 2 * a1 + 2 * a3, v49);
        v28 = a2[5];
        if ( v28 < 8 )
          v29 = a2;
        else
          v29 = (_DWORD *)*a2;
        if ( v28 < 8 )
          sub_409030((char *)a2 + 2 * a1, (char *)v29 + 2 * a5, v10);
        else
          sub_409030((void *)(*a2 + 2 * a1), (char *)v29 + 2 * a5, v10);
      }
    }
    else
    {
      v19 = a2[5];
      if ( v19 < 8 )
        v20 = a2;
      else
        v20 = (_DWORD *)*a2;
      if ( v19 < 8 )
        v21 = a2;
      else
        v21 = (_DWORD *)*a2;
      sub_409030((char *)v21 + 2 * a1, (char *)v20 + 2 * a5, v10);
      v22 = a2[5];
      if ( v22 < 8 )
        v23 = a2;
      else
        v23 = (_DWORD *)*a2;
      if ( v22 < 8 )
        v24 = a2;
      else
        v24 = (_DWORD *)*a2;
      sub_409030((char *)v24 + 2 * v10 + 2 * a1, (char *)v23 + 2 * a1 + 2 * a3, v49);
    }
  }
  else
  {
    v14 = a2[5];
    if ( v14 < 8 )
      v15 = a2;
    else
      v15 = (_DWORD *)*a2;
    if ( v14 < 8 )
      v16 = a2;
    else
      v16 = (_DWORD *)*a2;
    memcpy((char *)v16 + 2 * a1 + 2 * v10, (char *)v15 + 2 * a1 + 2 * a3, 2 * v49);
    v17 = a4;
    if ( a4[5] >= 8u )
      v17 = (_DWORD *)*a4;
    if ( a2[5] < 8u )
      v18 = a2;
    else
      v18 = (_DWORD *)*a2;
    memcpy_0((char *)v18 + 2 * a1, (char *)v17 + 2 * a5, 2 * v10);
  }
  v45 = a2[5] < 8u;
  a2[4] = v51;
  if ( v45 )
  {
    result = a2;
    *((_WORD *)a2 + v51) = 0;
  }
  else
  {
    *(_WORD *)(*a2 + 2 * v51) = 0;
    return a2;
  }
  return result;
}

//----- (0040C420) --------------------------------------------------------
_DWORD *__userpurge sub_40C420@<eax>(unsigned int a1@<eax>, int a2, void *Src, int a4)
{
  unsigned int v5; // ebx
  unsigned int v6; // edx
  unsigned int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  _DWORD *result; // eax
  unsigned int v11; // ecx
  unsigned int v12; // edx
  int v13; // eax
  unsigned int v14; // edi
  int v15; // ecx
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+10h] [ebp-4h]
  int v23; // [esp+10h] [ebp-4h]

  v5 = 2;
  if ( !Src
    || ((v6 = *(_DWORD *)(a1 + 20), v6 < 8) ? (v7 = a1) : (v7 = *(_DWORD *)a1),
        (unsigned int)Src < v7
     || (v6 < 8 ? (v8 = a1) : (v8 = *(_DWORD *)a1), v8 + 2 * *(_DWORD *)(a1 + 16) <= (unsigned int)Src)) )
  {
    v11 = *(_DWORD *)(a1 + 16);
    if ( v11 < a2 )
      std::_Xout_of_range("invalid string position");
    if ( v11 - a2 < 2 )
      v5 = v11 - a2;
    v12 = a4;
    if ( -1 - a4 <= v11 - v5 )
      std::_Xlength_error("string too long");
    v13 = v11 - a2 - v5;
    v21 = v13;
    if ( a4 < v5 )
    {
      v14 = *(_DWORD *)(a1 + 20);
      if ( v14 < 8 )
        v15 = a1;
      else
        v15 = *(_DWORD *)a1;
      if ( v14 < 8 )
        v22 = a1;
      else
        v22 = *(_DWORD *)a1;
      memcpy((void *)(v22 + 2 * (a4 + a2)), (const void *)(v15 + 2 * (a2 + v5)), 2 * v13);
      v12 = a4;
    }
    if ( v12 || v5 )
    {
      v16 = v12 + *(_DWORD *)(a1 + 16) - v5;
      if ( v16 > 0x7FFFFFFE )
        std::_Xlength_error("string too long");
      v17 = *(_DWORD *)(a1 + 20);
      if ( v17 >= v16 )
      {
        if ( !v16 )
        {
          *(_DWORD *)(a1 + 16) = 0;
          if ( v17 < 8 )
          {
            result = (_DWORD *)a1;
            *(_WORD *)a1 = 0;
          }
          else
          {
            **(_WORD **)a1 = 0;
            return (_DWORD *)a1;
          }
          return result;
        }
        goto LABEL_34;
      }
      sub_409240(a1, v16, *(const void **)(a1 + 16));
      v12 = a4;
      if ( v16 )
      {
LABEL_34:
        if ( v5 < v12 )
        {
          v18 = *(_DWORD *)(a1 + 20);
          if ( v18 < 8 )
            v19 = a1;
          else
            v19 = *(_DWORD *)a1;
          if ( v18 < 8 )
            v23 = a1;
          else
            v23 = *(_DWORD *)a1;
          sub_409030((void *)(v23 + 2 * (v12 + a2)), (void *)(v19 + 2 * (a2 + v5)), v21);
          v12 = a4;
        }
        if ( *(_DWORD *)(a1 + 20) < 8u )
          v20 = a1;
        else
          v20 = *(_DWORD *)a1;
        memcpy_0((void *)(v20 + 2 * a2), Src, 2 * v12);
        *(_DWORD *)(a1 + 16) = v16;
        if ( *(_DWORD *)(a1 + 20) >= 8u )
        {
          *(_WORD *)(*(_DWORD *)a1 + 2 * v16) = 0;
          return (_DWORD *)a1;
        }
        *(_WORD *)(a1 + 2 * v16) = 0;
      }
    }
    return (_DWORD *)a1;
  }
  if ( v6 < 8 )
    v9 = a1;
  else
    v9 = *(_DWORD *)a1;
  return sub_40C0F0(a2, (_DWORD *)a1, 2u, (_DWORD *)a1, ((int)Src - v9) >> 1, a4);
}

//----- (0040C610) --------------------------------------------------------
int __stdcall sub_40C610(int *a1, _WORD *a2, unsigned int a3)
{
  _WORD *v3; // ebx
  unsigned int v4; // esi
  unsigned int v6; // eax
  unsigned int v7; // edi
  int *v8; // eax
  unsigned int v9; // ecx
  _WORD *v10; // edx
  int *v11; // ecx
  int *v12; // ecx
  int *v13; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = a3;
  if ( !a3 )
    return 0;
  v6 = a1[4];
  if ( v6 && a3 <= v6 )
  {
    v7 = 1 - a3 + v6;
    if ( (unsigned int)a1[5] < 8 )
      v8 = a1;
    else
      v8 = (int *)*a1;
    while ( 1 )
    {
      v13 = v8;
      v9 = v7;
      if ( !v7 )
        break;
      while ( *(_WORD *)v8 != *v3 )
      {
        v8 = (int *)((char *)v8 + 2);
        if ( !--v9 )
          return -1;
      }
      if ( !v8 )
        break;
      v10 = v3;
      v11 = v8;
      if ( !v4 )
        goto LABEL_16;
      while ( *(_WORD *)v11 == *v10 )
      {
        v11 = (int *)((char *)v11 + 2);
        ++v10;
        if ( !--v4 )
          goto LABEL_16;
      }
      if ( (*(_WORD *)v11 < *v10 ? 0xFFFFFFFE : 0) == -1 )
      {
LABEL_16:
        v12 = a1;
        if ( (unsigned int)a1[5] >= 8 )
          v12 = (int *)*a1;
        return ((char *)v8 - (char *)v12) >> 1;
      }
      v4 = a3;
      v3 = a2;
      v7 += -1 - (((char *)v8 - (char *)v13) >> 1);
      v8 = (int *)((char *)v8 + 2);
    }
  }
  return -1;
}

//----- (0040C6D0) --------------------------------------------------------
_DWORD *__userpurge sub_40C6D0@<eax>(_DWORD *a1@<esi>, int a2)
{
  int v2; // ecx
  unsigned int *v3; // edx
  unsigned int v4; // edx
  unsigned int v5; // ecx
  void *v6; // eax
  _DWORD *v7; // ecx
  void *v9; // [esp-8h] [ebp-60h]
  int v10; // [esp-4h] [ebp-5Ch]
  void *v11[5]; // [esp+10h] [ebp-48h] BYREF
  unsigned int v12; // [esp+24h] [ebp-34h]
  void *Src[4]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v14; // [esp+3Ch] [ebp-1Ch]
  unsigned int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+54h] [ebp-4h]

  v2 = *(_DWORD *)(a2 + 64);
  if ( (v2 & 2) == 0 )
  {
    v3 = *(unsigned int **)(a2 + 36);
    if ( *v3 )
    {
      v4 = *v3;
      v5 = *(_DWORD *)(a2 + 60);
      if ( v5 < v4 )
        v5 = v4;
      v6 = **(void ***)(a2 + 20);
      v15 = 7;
      v14 = 0;
      LOWORD(Src[0]) = 0;
      sub_4094F0(Src, 0, v6, (int)(v5 - (_DWORD)v6) >> 1);
      v16 = 0;
      goto LABEL_6;
    }
  }
  if ( (v2 & 4) == 0 )
  {
    v7 = *(_DWORD **)(a2 + 32);
    if ( *v7 )
    {
      v10 = (*v7 + 2 * **(_DWORD **)(a2 + 48) - **(_DWORD **)(a2 + 16)) >> 1;
      v9 = **(void ***)(a2 + 16);
      v15 = 7;
      v14 = 0;
      LOWORD(Src[0]) = 0;
      sub_4094F0(Src, 0, v9, v10);
      v16 = 1;
LABEL_6:
      a1[5] = 7;
      a1[4] = 0;
      *(_WORD *)a1 = 0;
      sub_40AF70(a1, Src);
      if ( v15 >= 8 )
        operator delete(Src[0]);
      return a1;
    }
  }
  v12 = 7;
  v11[4] = 0;
  LOWORD(v11[0]) = 0;
  v16 = 2;
  a1[5] = 7;
  a1[4] = 0;
  *(_WORD *)a1 = 0;
  sub_40AF70(a1, v11);
  if ( v12 >= 8 )
    operator delete(v11[0]);
  return a1;
}

//----- (0040C810) --------------------------------------------------------
_DWORD *__thiscall sub_40C810(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        int a5,
        unsigned __int16 a6,
        unsigned __int8 a7)
{
  bool v7; // zf
  _DWORD *v10; // eax
  struct std::locale::facet *v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // edi
  void (__thiscall ***v15)(_DWORD, int); // edi
  void *v16; // eax
  void *v17; // eax
  unsigned int v18; // edi
  int v19; // ecx
  int v20; // edi
  int *v21; // eax
  unsigned __int16 *v22; // eax
  int *v23; // eax
  int v24; // ecx
  _DWORD *v25; // eax
  _DWORD *v26; // esi
  int v27; // [esp+14h] [ebp-68h]
  struct std::locale::facet *v28; // [esp+18h] [ebp-64h] BYREF
  _DWORD *v29; // [esp+20h] [ebp-5Ch]
  int v30; // [esp+24h] [ebp-58h] BYREF
  int v31[2]; // [esp+28h] [ebp-54h] BYREF
  void *v32[4]; // [esp+30h] [ebp-4Ch] BYREF
  unsigned int v33; // [esp+40h] [ebp-3Ch]
  unsigned int v34; // [esp+44h] [ebp-38h]
  void *v35[5]; // [esp+4Ch] [ebp-30h] BYREF
  unsigned int v36; // [esp+60h] [ebp-1Ch]
  int v37; // [esp+78h] [ebp-4h]

  v7 = (*(_DWORD *)(a5 + 20) & 0x4000) == 0;
  v29 = a2;
  if ( v7 )
  {
    (*(void (__thiscall **)(void *, _DWORD *, int, _DWORD *, int, _DWORD, _DWORD))(*(_DWORD *)this + 28))(
      this,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7);
    return a2;
  }
  v10 = sub_408A70((_DWORD **)a5, &v30);
  v37 = 0;
  v11 = sub_406D70((int)v10);
  v37 = -1;
  v12 = v30;
  v28 = v11;
  if ( v30 )
  {
    v27 = v30;
    std::_Lockit::_Lockit((std::_Lockit *)v31, 0);
    v13 = *(_DWORD *)(v12 + 4);
    if ( v13 && v13 != -1 )
      *(_DWORD *)(v12 + 4) = v13 - 1;
    v14 = -(*(_DWORD *)(v12 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v31);
    v15 = (void (__thiscall ***)(_DWORD, int))(v27 & v14);
    if ( v15 )
      (**v15)(v15, 1);
  }
  v34 = 7;
  v33 = 0;
  LOWORD(v32[0]) = 0;
  v37 = 1;
  if ( a7 )
  {
    v16 = (void *)sub_4051C0(v28, (int)v35);
    LOBYTE(v37) = 2;
    sub_40AF70(v32, v16);
    LOBYTE(v37) = 1;
    if ( v36 < 8 )
      goto LABEL_14;
  }
  else
  {
    v17 = (void *)sub_4051A0(v28, (int)v35);
    LOBYTE(v37) = 3;
    sub_40AF70(v32, v17);
    LOBYTE(v37) = 1;
    if ( v36 < 8 )
      goto LABEL_14;
  }
  operator delete(v35[0]);
LABEL_14:
  v18 = *(_DWORD *)(a5 + 32);
  v19 = v33;
  if ( *(__int64 *)(a5 + 32) <= 0 || v18 <= v33 )
    v20 = 0;
  else
    v20 = v18 - v33;
  if ( (*(_DWORD *)(a5 + 20) & 0x1C0) != 64 )
  {
    v21 = sub_40DB80((int)this, v31, a3, a4, a6, v20);
    v19 = v33;
    a3 = *v21;
    a4 = (_DWORD *)v21[1];
    v20 = 0;
  }
  v22 = (unsigned __int16 *)v32[0];
  if ( v34 < 8 )
    v22 = (unsigned __int16 *)v32;
  v23 = sub_40DB10((int)this, &v28, a3, a4, v22, v19);
  v24 = *v23;
  v25 = (_DWORD *)v23[1];
  *(_DWORD *)(a5 + 32) = 0;
  *(_DWORD *)(a5 + 36) = 0;
  v26 = v29;
  sub_40DB80((int)this, v29, v24, v25, a6, v20);
  if ( v34 >= 8 )
    operator delete(v32[0]);
  return v26;
}
// 40C810: using guessed type _DWORD var_54[2];

//----- (0040CA60) --------------------------------------------------------
int __thiscall sub_40CA60(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  const char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_40D790((int)this, v11, byte_4CBEC8, *(_DWORD *)(a5 + 20));
  v9 = sprintf_s(Buffer, 0x40u, v8, a7);
  sub_40D820((int)this, a2, a3, a4, a5, a6, Buffer, v9);
  return a2;
}
// 4CBEC8: using guessed type _BYTE byte_4CBEC8[4];
// 40CA60: using guessed type char var_50[8];

//----- (0040CAE0) --------------------------------------------------------
int __thiscall sub_40CAE0(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  const char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_40D790((int)this, v11, byte_4CBECC, *(_DWORD *)(a5 + 20));
  v9 = sprintf_s(Buffer, 0x40u, v8, a7);
  sub_40D820((int)this, a2, a3, a4, a5, a6, Buffer, v9);
  return a2;
}
// 4CBECC: using guessed type _BYTE byte_4CBECC[4];
// 40CAE0: using guessed type char var_50[8];

//----- (0040CB60) --------------------------------------------------------
int __thiscall sub_40CB60(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_40D790((int)this, v12, byte_4CBED0, *(_DWORD *)(a5 + 20));
  v10 = sprintf_s(Buffer, 0x40u, v9, a7, a8);
  sub_40D820((int)this, a2, a3, a4, a5, a6, Buffer, v10);
  return a2;
}
// 4CBED0: using guessed type _BYTE byte_4CBED0[4];
// 40CB60: using guessed type char var_50[8];

//----- (0040CBF0) --------------------------------------------------------
int __thiscall sub_40CBF0(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char Buffer[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_40D790((int)this, v12, byte_4CBED4, *(_DWORD *)(a5 + 20));
  v10 = sprintf_s(Buffer, 0x40u, v9, a7, a8);
  sub_40D820((int)this, a2, a3, a4, a5, a6, Buffer, v10);
  return a2;
}
// 4CBED4: using guessed type _BYTE byte_4CBED4[4];
// 40CBF0: using guessed type char var_50[8];

//----- (0040CC80) --------------------------------------------------------
int __thiscall sub_40CC80(void *this, int a2, int a3, int a4, int a5, int a6, double a7)
{
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // esi
  double v10; // st7
  int v11; // ecx
  unsigned int v12; // esi
  int v13; // edx
  double v14; // st7
  double v15; // st6
  double v16; // st5
  double v17; // st4
  double v18; // st5
  double v19; // rt2
  double v20; // rtt
  double v21; // st4
  double v22; // rt0
  double v23; // st5
  double v24; // st7
  double v25; // st5
  double v26; // rt1
  bool v27; // cf
  double v28; // rt2
  double v29; // st5
  double v30; // st6
  double v31; // st5
  char *v32; // eax
  int v33; // edx
  char v34; // cl
  int v35; // eax
  char v37; // [esp+37h] [ebp-91h]
  unsigned int v38; // [esp+38h] [ebp-90h]
  int v39; // [esp+3Ch] [ebp-8Ch]
  char Format; // [esp+48h] [ebp-80h] BYREF
  char v42; // [esp+49h] [ebp-7Fh] BYREF
  char v43; // [esp+4Ah] [ebp-7Eh] BYREF
  char Buffer[116]; // [esp+50h] [ebp-78h] BYREF

  v7 = *(_DWORD *)(a5 + 28);
  v8 = 0;
  if ( *(__int64 *)(a5 + 24) > 0 || (*(_DWORD *)(a5 + 20) & 0x2000) != 0 )
  {
    v9 = *(_DWORD *)(a5 + 24);
  }
  else
  {
    v9 = 6;
    v7 = 0;
  }
  if ( v7 < 0 || v7 <= 0 && v9 <= 0x24 )
    v39 = v9;
  else
    v39 = 36;
  v10 = a7;
  v11 = (__PAIR64__(v7, v9) - v39) >> 32;
  v12 = v9 - v39;
  v13 = *(_DWORD *)(a5 + 20);
  v38 = 0;
  if ( (v13 & 0x3000) == 0x2000 && a7 != 0.5 * a7 )
  {
    if ( a7 >= 0.0 )
    {
      v37 = 0;
      v15 = a7;
      v14 = 0.0;
    }
    else
    {
      v14 = 0.0;
      v37 = 1;
      v15 = -a7;
    }
    v16 = 1.0e35;
    v17 = 1.0e10;
    if ( v15 >= 1.0e35 )
    {
      while ( v38 < 0x1388 )
      {
        v15 = v15 / v17;
        v38 += 10;
        v20 = v17;
        v21 = v16;
        v18 = v20;
        if ( v21 > v15 )
          goto LABEL_20;
        v19 = v21;
        v17 = v18;
        v16 = v19;
      }
    }
    v18 = v17;
LABEL_20:
    v22 = v18;
    v23 = v14;
    v24 = v22;
    if ( v23 < v15 && v11 >= 0 && (v11 > 0 || v12 >= 0xA) )
    {
      v25 = 1.0e-35;
      while ( v25 >= v15 && v8 < 0x1388 )
      {
        v27 = __CFADD__(v12, -10);
        v12 -= 10;
        v28 = v25;
        v29 = v15;
        v30 = v28;
        v11 = v27 + v11 - 1;
        v31 = v29 * v24;
        v8 += 10;
        if ( v11 <= 0 && (v11 < 0 || v12 < 0xA) )
        {
          v15 = v31;
          break;
        }
        v26 = v31;
        v25 = v30;
        v15 = v26;
      }
    }
    v10 = v15;
    if ( v37 )
      v10 = -v15;
  }
  Format = 37;
  v32 = &v42;
  if ( (v13 & 0x20) != 0 )
  {
    v42 = 43;
    v32 = &v43;
  }
  if ( (v13 & 0x10) != 0 )
    *v32++ = 35;
  v33 = v13 & 0x3000;
  *(_WORD *)v32 = 10798;
  if ( v33 == 0x2000 )
  {
    v34 = 102;
  }
  else if ( v33 == 12288 )
  {
    v34 = 97;
  }
  else
  {
    v34 = 2 * (v33 != 4096) + 101;
  }
  v32[2] = v34;
  v32[3] = 0;
  v35 = sprintf_s(Buffer, 0x6Cu, &Format, v39, v10);
  sub_40D130((int)this, a2, a3, a4, a5, a6, Buffer, v38, v8, v12, v35);
  return a2;
}

//----- (0040CE90) --------------------------------------------------------
int __thiscall sub_40CE90(void *this, int a2, int a3, int a4, int a5, int a6, double a7)
{
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // esi
  int v10; // ecx
  unsigned int v11; // esi
  int v12; // edx
  double v13; // st6
  double v14; // st5
  double v15; // st4
  double v16; // st5
  double v17; // rt0
  double v18; // rt1
  double v19; // st4
  double v20; // st7
  double v21; // st5
  double v22; // rtt
  bool v23; // cf
  double v24; // rt0
  double v25; // st5
  double v26; // st6
  double v27; // st5
  double v28; // st7
  char *v29; // eax
  int v30; // edx
  char v31; // cl
  int v32; // eax
  char v34; // [esp+37h] [ebp-91h]
  unsigned int v35; // [esp+38h] [ebp-90h]
  int v36; // [esp+3Ch] [ebp-8Ch]
  char Format; // [esp+48h] [ebp-80h] BYREF
  char v39; // [esp+49h] [ebp-7Fh] BYREF
  char v40; // [esp+4Ah] [ebp-7Eh] BYREF
  char Buffer[116]; // [esp+50h] [ebp-78h] BYREF

  v7 = *(_DWORD *)(a5 + 28);
  v8 = 0;
  if ( *(__int64 *)(a5 + 24) > 0 || (*(_DWORD *)(a5 + 20) & 0x2000) != 0 )
  {
    v9 = *(_DWORD *)(a5 + 24);
  }
  else
  {
    v9 = 6;
    v7 = 0;
  }
  if ( v7 < 0 || v7 <= 0 && v9 <= 0x24 )
    v36 = v9;
  else
    v36 = 36;
  v10 = (__PAIR64__(v7, v9) - v36) >> 32;
  v11 = v9 - v36;
  v12 = *(_DWORD *)(a5 + 20);
  v35 = 0;
  if ( (v12 & 0x3000) == 0x2000 )
  {
    v13 = a7;
    if ( a7 >= 0.0 )
    {
      v34 = 0;
    }
    else
    {
      v34 = 1;
      v13 = -a7;
    }
    v14 = 1.0e35;
    v15 = 1.0e10;
    if ( v13 >= 1.0e35 )
    {
      while ( v35 < 0x1388 )
      {
        v13 = v13 / v15;
        v35 += 10;
        v18 = v15;
        v19 = v14;
        v16 = v18;
        if ( v19 > v13 )
          goto LABEL_19;
        v17 = v19;
        v15 = v16;
        v14 = v17;
      }
    }
    v16 = v15;
LABEL_19:
    v20 = v16;
    if ( v13 > 0.0 && v10 >= 0 && (v10 > 0 || v11 >= 0xA) )
    {
      v21 = 1.0e-35;
      while ( v21 >= v13 && v8 < 0x1388 )
      {
        v23 = __CFADD__(v11, -10);
        v11 -= 10;
        v24 = v21;
        v25 = v13;
        v26 = v24;
        v10 = v23 + v10 - 1;
        v27 = v25 * v20;
        v8 += 10;
        if ( v10 <= 0 && (v10 < 0 || v11 < 0xA) )
        {
          v13 = v27;
          break;
        }
        v22 = v27;
        v21 = v26;
        v13 = v22;
      }
    }
    v28 = v13;
    if ( v34 )
      v28 = -v13;
  }
  else
  {
    v28 = a7;
  }
  Format = 37;
  v29 = &v39;
  if ( (v12 & 0x20) != 0 )
  {
    v39 = 43;
    v29 = &v40;
  }
  if ( (v12 & 0x10) != 0 )
    *v29++ = 35;
  v30 = v12 & 0x3000;
  *(_WORD *)v29 = 10798;
  v29[2] = 76;
  if ( v30 == 0x2000 )
  {
    v31 = 102;
  }
  else if ( v30 == 12288 )
  {
    v31 = 97;
  }
  else
  {
    v31 = 2 * (v30 != 4096) + 101;
  }
  v29[3] = v31;
  v29[4] = 0;
  v32 = sprintf_s(Buffer, 0x6Cu, &Format, v36, v28);
  sub_40D130((int)this, a2, a3, a4, a5, a6, Buffer, v35, v8, v11, v32);
  return a2;
}

//----- (0040D090) --------------------------------------------------------
int __thiscall sub_40D090(void *this, int a2, int a3, int a4, int a5, int a6, const void *a7)
{
  int v8; // eax
  char Buffer[68]; // [esp+10h] [ebp-48h] BYREF

  v8 = sprintf_s(Buffer, 0x40u, "%p", a7);
  sub_40D820((int)this, a2, a3, a4, a5, a6, Buffer, v8);
  return a2;
}

//----- (0040D100) --------------------------------------------------------
_DWORD *__thiscall sub_40D100(_DWORD *this, void *Src, int a3)
{
  this[5] = 7;
  this[4] = 0;
  *(_WORD *)this = 0;
  sub_4094F0(this, (int)Src, Src, a3);
  return this;
}

//----- (0040D130) --------------------------------------------------------
_DWORD *__cdecl sub_40D130(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        void *Buf,
        int a8,
        int a9,
        int a10,
        size_t MaxCount)
{
  int v11; // ebx
  char *v12; // esi
  _DWORD *v13; // eax
  int v14; // ecx
  int v15; // eax
  char v16; // al
  void **v17; // eax
  void **v18; // ecx
  int v19; // ebx
  void **v20; // ebx
  const char *v21; // eax
  int v22; // esi
  int v23; // eax
  unsigned int v24; // ecx
  size_t v25; // eax
  int v26; // eax
  int *v27; // eax
  int *v28; // eax
  _BYTE *v29; // eax
  size_t v30; // eax
  size_t v31; // ebx
  int v32; // eax
  int *v33; // eax
  unsigned __int16 v34; // ax
  int *v35; // eax
  int *v36; // eax
  _BYTE *v37; // eax
  int v38; // ebx
  int v39; // eax
  int *v40; // eax
  char *v41; // ecx
  int *v42; // eax
  int v43; // eax
  int *v44; // eax
  int v45; // ecx
  int v46; // edx
  _DWORD *v47; // esi
  _DWORD *v48; // eax
  size_t v50; // [esp+10h] [ebp-8Ch]
  _BYTE *v51; // [esp+14h] [ebp-88h]
  int v52; // [esp+14h] [ebp-88h]
  mbstate_t v54; // [esp+1Ch] [ebp-80h] BYREF
  size_t v55; // [esp+24h] [ebp-78h]
  char v56[4]; // [esp+28h] [ebp-74h] BYREF
  char Control[4]; // [esp+2Ch] [ebp-70h] BYREF
  int v58[2]; // [esp+30h] [ebp-6Ch] BYREF
  wchar_t v59[2]; // [esp+38h] [ebp-64h] BYREF
  size_t v60; // [esp+3Ch] [ebp-60h]
  int v61; // [esp+40h] [ebp-5Ch]
  struct std::locale::facet *v62; // [esp+44h] [ebp-58h]
  _DWORD *v63; // [esp+48h] [ebp-54h]
  int v64; // [esp+4Ch] [ebp-50h] BYREF
  char *Str[4]; // [esp+50h] [ebp-4Ch] BYREF
  size_t v66; // [esp+60h] [ebp-3Ch]
  unsigned int v67; // [esp+64h] [ebp-38h]
  void *v68[5]; // [esp+6Ch] [ebp-30h] BYREF
  unsigned int v69; // [esp+80h] [ebp-1Ch]
  int v70; // [esp+98h] [ebp-4h]
  int v71; // [esp+ACh] [ebp+10h]
  _DWORD *v72; // [esp+B0h] [ebp+14h]

  v11 = MaxCount;
  v12 = (char *)Buf;
  v63 = (_DWORD *)a2;
  v60 = a9;
  v55 = a8;
  v61 = a5;
  v50 = MaxCount;
  v13 = sub_408A70((_DWORD **)a5, &v64);
  v70 = 0;
  v62 = sub_406D70((int)v13);
  v70 = -1;
  if ( v64 )
  {
    *(_DWORD *)&v54._Byte = v64;
    std::_Lockit::_Lockit((std::_Lockit *)&v54, 0);
    v14 = *(_DWORD *)&v54._Byte;
    v15 = *(_DWORD *)(*(_DWORD *)&v54._Byte + 4);
    if ( v15 && v15 != -1 )
      *(_DWORD *)(*(_DWORD *)&v54._Byte + 4) = v15 - 1;
    *(_DWORD *)&v54._Byte = *(_DWORD *)(v14 + 4) == 0 ? v14 : 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v54);
    if ( *(_DWORD *)&v54._Byte )
      (***(void (__thiscall ****)(_DWORD, int))&v54._Byte)(*(_DWORD *)&v54._Byte, 1);
  }
  sub_4068F0(v62, (int)v68);
  v70 = 1;
  *(_DWORD *)&v54._Byte = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *))(*(_DWORD *)v62 + 8))(v62);
  v67 = 15;
  v66 = 0;
  LOBYTE(Str[0]) = 0;
  LOBYTE(v70) = 2;
  *(_DWORD *)v59 = 0;
  v54._Wchar = 0;
  v56[0] = 48;
  _Mbrtowc(v59, v56, 1u, &v54, (const _Cvtvec *)(a1 + 8));
  v16 = *(_BYTE *)Buf;
  if ( *(_BYTE *)Buf == 43 || (v54._Wchar = 0, v16 == 45) )
    v54._Wchar = 1;
  Control[0] = *localeconv()->decimal_point;
  strcpy(&Control[1], "e");
  v58[0] = (int)memchr(Buf, 101, MaxCount);
  v51 = memchr(Buf, Control[0], MaxCount);
  if ( !v51 )
    a10 = 0;
  v17 = (void **)v68[0];
  v18 = (void **)v68[0];
  if ( v69 < 0x10 )
    v18 = v68;
  if ( *(_BYTE *)v18 != 127 )
  {
    if ( v69 < 0x10 )
      v17 = v68;
    if ( *(char *)v17 > 0 )
    {
      sub_40DBF0(Str, Buf, MaxCount);
      v19 = v58[0];
      if ( v58[0] )
      {
        if ( !v51 )
        {
          sub_405360(Str, v55, 48);
          v55 = 0;
        }
        sub_4133A0(Str, v19 - (_DWORD)Buf, a10, 48);
      }
      else
      {
        sub_405360(Str, a10, 48);
      }
      if ( v51 )
      {
        sub_4133A0(Str, v51 - (_BYTE *)Buf + 1, v60, 48);
        sub_4133A0(Str, v51 - (_BYTE *)Buf, v55, 48);
        v60 = 0;
      }
      else
      {
        sub_405360(Str, v55, 48);
      }
      v20 = (void **)v68[0];
      v55 = 0;
      if ( v69 < 0x10 )
        v20 = v68;
      v21 = Str[0];
      if ( v67 < 0x10 )
        v21 = (const char *)Str;
      v22 = strcspn(v21, Control);
      for ( LOBYTE(v23) = *(_BYTE *)v20; *(_BYTE *)v20 != 127; LOBYTE(v23) = *(_BYTE *)v20 )
      {
        if ( (char)v23 <= 0 )
          break;
        v23 = (char)v23;
        if ( (char)v23 >= v22 - v54._Wchar )
          break;
        v22 -= v23;
        sub_4133A0(Str, v22, 1u, 0);
        if ( *((char *)v20 + 1) > 0 )
          v20 = (void **)((char *)v20 + 1);
      }
      v12 = Str[0];
      if ( v67 < 0x10 )
        v12 = (char *)Str;
      a10 = 0;
      v50 = v66;
      v11 = v66;
    }
  }
  v24 = *(_DWORD *)(v61 + 32);
  v25 = v55 + v60 + v11 + a10;
  if ( *(__int64 *)(v61 + 32) <= 0 || v24 <= v25 )
    v52 = 0;
  else
    v52 = v24 - v25;
  v26 = *(_DWORD *)(v61 + 20) & 0x1C0;
  if ( v26 != 64 )
  {
    if ( v26 == 256 && v54._Wchar )
    {
      v27 = sub_40DD10(a1, v58, a3, (_DWORD *)a4, v12, 1);
      a3 = *v27;
      ++v12;
      --v11;
      a4 = v27[1];
      v50 = v11;
    }
    v28 = sub_40DB80(a1, v58, a3, (_DWORD *)a4, a6, v52);
    a3 = *v28;
    a4 = v28[1];
    v52 = 0;
  }
  v29 = memchr(v12, Control[0], v11);
  if ( v29 )
  {
    v30 = v29 - v12;
    v31 = v30 + 1;
    v32 = sub_40DDE0(a1, (int)v58, a3, a4, v12, v30, *(int *)&v54._Byte);
    v33 = sub_40DB80(a1, v58, *(_DWORD *)v32, *(_DWORD **)(v32 + 4), *(int *)v59, v55);
    v71 = *v33;
    v72 = (_DWORD *)v33[1];
    v34 = (*(int (__thiscall **)(struct std::locale::facet *))(*(_DWORD *)v62 + 4))(v62);
    v35 = sub_40DB80(a1, v58, v71, v72, v34, 1);
    v36 = sub_40DB80(a1, v58, *v35, (_DWORD *)v35[1], *(int *)v59, v60);
    v12 += v31;
    v50 -= v31;
    v11 = v50;
    a3 = *v36;
    a4 = v36[1];
  }
  v37 = memchr(v12, 101, v11);
  if ( v37 )
  {
    v38 = v37 - v12 + 1;
    v39 = sub_40DDE0(a1, (int)v58, a3, a4, v12, v37 - v12, *(int *)&v54._Byte);
    v40 = sub_40DB80(a1, v58, *(_DWORD *)v39, *(_DWORD **)(v39 + 4), *(int *)v59, a10);
    a10 = 0;
    v41 = "E";
    if ( (*(_BYTE *)(v61 + 20) & 4) == 0 )
      v41 = "e";
    v42 = sub_40DD10(a1, v58, *v40, (_DWORD *)v40[1], v41, 1);
    v12 += v38;
    v11 = v50 - v38;
    a3 = *v42;
    a4 = v42[1];
  }
  v43 = sub_40DDE0(a1, (int)v58, a3, a4, v12, v11, *(int *)&v54._Byte);
  v44 = sub_40DB80(a1, v58, *(_DWORD *)v43, *(_DWORD **)(v43 + 4), *(int *)v59, a10);
  v46 = v61;
  v47 = v63;
  v45 = *v44;
  v48 = (_DWORD *)v44[1];
  *(_DWORD *)(v61 + 32) = 0;
  *(_DWORD *)(v46 + 36) = 0;
  sub_40DB80(a1, v47, v45, v48, a6, v52);
  if ( v67 >= 0x10 )
    operator delete(Str[0]);
  v67 = 15;
  v66 = 0;
  LOBYTE(Str[0]) = 0;
  if ( v69 >= 0x10 )
    operator delete(v68[0]);
  return v47;
}
// 40D130: using guessed type char var_74[4];

//----- (0040D790) --------------------------------------------------------
_BYTE *__cdecl sub_40D790(int a1, _BYTE *a2, _BYTE *a3, __int16 a4)
{
  _BYTE *result; // eax
  _BYTE *v5; // ecx
  _BYTE *v6; // ecx
  int v7; // esi
  char v8; // dl

  result = a2;
  *a2 = 37;
  v5 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v5 = 43;
    v5 = a2 + 2;
  }
  if ( (a4 & 8) != 0 )
    *v5++ = 35;
  if ( *a3 == 76 )
  {
    *(_WORD *)v5 = 13897;
    v5[2] = 52;
    v6 = v5 + 3;
  }
  else
  {
    *v5 = *a3;
    v6 = v5 + 1;
  }
  v7 = a4 & 0xE00;
  if ( v7 == 1024 )
  {
    *v6 = 111;
    v6[1] = 0;
  }
  else
  {
    if ( v7 == 2048 )
      v8 = ~(8 * a4) & 0x20 | 0x58;
    else
      v8 = a3[1];
    *v6 = v8;
    v6[1] = 0;
  }
  return result;
}

//----- (0040D820) --------------------------------------------------------
int __cdecl sub_40D820(int a1, int a2, int a3, int a4, int a5, int a6, void *Buf, int a8)
{
  char *v8; // ebx
  _DWORD *v9; // eax
  struct std::locale::facet *v10; // eax
  int v11; // edi
  int v12; // eax
  int v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // esi
  char v15; // al
  char v16; // al
  void **v17; // edx
  void **v18; // eax
  void **v19; // eax
  int v20; // esi
  int v21; // eax
  unsigned int v22; // esi
  int v23; // esi
  int v24; // eax
  int *v25; // eax
  int *v26; // eax
  unsigned __int16 v27; // ax
  int v28; // ebx
  int *v29; // eax
  int v30; // edx
  int v31; // esi
  _DWORD *v33; // [esp-14h] [ebp-80h]
  int v34; // [esp-10h] [ebp-7Ch]
  void *v35; // [esp-Ch] [ebp-78h]
  int v36; // [esp-4h] [ebp-70h]
  unsigned int MaxCount; // [esp+14h] [ebp-58h]
  int v38; // [esp+18h] [ebp-54h]
  int v39[2]; // [esp+1Ch] [ebp-50h] BYREF
  int v40; // [esp+24h] [ebp-48h]
  int v41; // [esp+28h] [ebp-44h]
  int v42; // [esp+2Ch] [ebp-40h] BYREF
  _DWORD *v43; // [esp+30h] [ebp-3Ch]
  int v44; // [esp+34h] [ebp-38h] BYREF
  void *v45[5]; // [esp+3Ch] [ebp-30h] BYREF
  unsigned int v46; // [esp+50h] [ebp-1Ch]
  int v47; // [esp+68h] [ebp-4h]
  _DWORD *v48; // [esp+80h] [ebp+14h]

  v8 = (char *)Buf;
  v40 = a1;
  v43 = (_DWORD *)a2;
  v41 = a5;
  MaxCount = a8;
  v9 = sub_408A70((_DWORD **)a5, &v42);
  v47 = 0;
  v10 = sub_406D70((int)v9);
  v47 = -1;
  v11 = v42;
  v44 = (int)v10;
  if ( v42 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v39, 0);
    v12 = *(_DWORD *)(v11 + 4);
    if ( v12 && v12 != -1 )
      *(_DWORD *)(v11 + 4) = v12 - 1;
    v13 = -(*(_DWORD *)(v11 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v39);
    v14 = (void (__thiscall ***)(_DWORD, int))(v11 & v13);
    if ( v14 )
      (**v14)(v14, 1);
  }
  sub_4068F0((void *)v44, (int)v45);
  v47 = 1;
  v15 = *(_BYTE *)Buf;
  if ( *(_BYTE *)Buf == 43 || v15 == 45 )
  {
    v38 = 1;
  }
  else if ( v15 == 48 && ((v16 = *((_BYTE *)Buf + 1), v16 == 120) || v16 == 88) )
  {
    v38 = 2;
  }
  else
  {
    v38 = 0;
  }
  v17 = (void **)v45[0];
  v18 = (void **)v45[0];
  if ( v46 < 0x10 )
    v18 = v45;
  if ( *(_BYTE *)v18 != 127 )
  {
    v19 = (void **)v45[0];
    if ( v46 < 0x10 )
      v19 = v45;
    if ( *(char *)v19 > 0 )
    {
      if ( v46 < 0x10 )
        v17 = v45;
      v20 = a8;
      LOBYTE(v21) = *(_BYTE *)v17;
      for ( v39[0] = (int)v17; (_BYTE)v21 != 127; LOBYTE(v21) = *(_BYTE *)v21 )
      {
        if ( (char)v21 <= 0 )
          break;
        v21 = (char)v21;
        if ( (char)v21 >= (unsigned int)(v20 - v38) )
          break;
        v20 -= v21;
        memmove_s((char *)Buf + v20 + 1, MaxCount - v20 + 1, (char *)Buf + v20, MaxCount - v20 + 1);
        v21 = v39[0];
        ++MaxCount;
        *((_BYTE *)Buf + v20) = 0;
        if ( *(char *)(v21 + 1) > 0 )
          v39[0] = ++v21;
      }
    }
  }
  v22 = *(_DWORD *)(v41 + 32);
  if ( *(__int64 *)(v41 + 32) <= 0 || v22 <= MaxCount )
    v23 = 0;
  else
    v23 = v22 - MaxCount;
  v24 = *(_DWORD *)(v41 + 20) & 0x1C0;
  if ( v24 != 64 )
  {
    if ( v24 == 256 )
    {
      v26 = sub_40DD10(v40, v39, a3, (_DWORD *)a4, (char *)Buf, v38);
      v8 = (char *)Buf + v38;
      MaxCount -= v38;
      v25 = sub_40DB80(v40, v39, *v26, (_DWORD *)v26[1], a6, v23);
    }
    else
    {
      v25 = sub_40DB80(v40, v39, a3, (_DWORD *)a4, a6, v23);
    }
    a3 = *v25;
    a4 = v25[1];
    v23 = 0;
  }
  v27 = (*(int (__thiscall **)(int))(*(_DWORD *)v44 + 8))(v44);
  v35 = v8;
  v28 = v40;
  v29 = (int *)sub_40DDE0(v40, (int)&v44, a3, a4, v35, MaxCount, v27);
  v30 = v41;
  v36 = v23;
  v31 = (int)v43;
  v34 = *v29;
  v33 = v43;
  v48 = (_DWORD *)v29[1];
  *(_DWORD *)(v41 + 32) = 0;
  *(_DWORD *)(v30 + 36) = 0;
  sub_40DB80(v28, v33, v34, v48, a6, v36);
  if ( v46 >= 0x10 )
    operator delete(v45[0]);
  return v31;
}
// 40D820: using guessed type _DWORD var_50[2];

//----- (0040DB10) --------------------------------------------------------
_DWORD *__cdecl sub_40DB10(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int a6)
{
  _DWORD *v6; // ecx
  int i; // ebx
  unsigned __int16 v9; // dx
  int *v10; // eax
  _WORD **v11; // eax
  unsigned __int16 *v12; // ecx
  unsigned __int16 v13; // ax
  _DWORD *result; // eax

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( !v6 )
      goto LABEL_8;
    v9 = *a5;
    if ( *(_DWORD *)v6[9] && (v10 = (int *)v6[13], *v10 > 0) )
    {
      --*v10;
      v11 = (_WORD **)v6[9];
      v12 = (*v11)++;
      *v12 = v9;
      v13 = v9;
    }
    else
    {
      v13 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v6 + 12))(v6, *a5);
    }
    v6 = a4;
    if ( v13 == 0xFFFF )
LABEL_8:
      LOBYTE(a3) = 1;
    ++a5;
  }
  result = a2;
  *a2 = a3;
  a2[1] = v6;
  return result;
}

//----- (0040DB80) --------------------------------------------------------
_DWORD *__cdecl sub_40DB80(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6)
{
  _DWORD *v6; // ecx
  int i; // edi
  int *v8; // eax
  _WORD **v9; // eax
  _WORD *v10; // ecx
  __int16 v11; // ax
  _DWORD *result; // eax

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( v6 )
    {
      if ( *(_DWORD *)v6[9] && (v8 = (int *)v6[13], *v8 > 0) )
      {
        --*v8;
        v9 = (_WORD **)v6[9];
        v10 = (*v9)++;
        *v10 = a5;
        v11 = a5;
      }
      else
      {
        v11 = (*(int (__thiscall **)(_DWORD *, int))(*v6 + 12))(v6, a5);
      }
      v6 = a4;
      if ( v11 != -1 )
        continue;
    }
    LOBYTE(a3) = 1;
  }
  result = a2;
  *a2 = a3;
  a2[1] = v6;
  return result;
}

//----- (0040DBF0) --------------------------------------------------------
_DWORD *__thiscall sub_40DBF0(_DWORD *this, void *Src, size_t Size)
{
  void *v3; // edx
  unsigned int v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *result; // eax
  size_t v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ecx
  _DWORD *v12; // eax
  bool v13; // cf

  v3 = Src;
  if ( Src )
  {
    v5 = this[5];
    v6 = v5 < 0x10 ? this : (_DWORD *)*this;
    if ( Src >= v6 )
    {
      v7 = v5 < 0x10 ? this : (_DWORD *)*this;
      if ( (char *)v7 + this[4] > Src )
      {
        if ( v5 < 0x10 )
          return sub_40DEE0(this, (int)this, (_BYTE *)Src - (_BYTE *)this, Size);
        else
          return sub_40DEE0(this, (int)this, (int)Src - *this, Size);
      }
    }
  }
  v9 = this[4];
  if ( -1 - v9 <= Size )
    std::_Xlength_error("string too long");
  if ( !Size )
    return this;
  v10 = v9 + Size;
  if ( v9 + Size == -1 )
    std::_Xlength_error("string too long");
  v11 = this[5];
  if ( v11 < v10 )
  {
    sub_4079E0((int)this, (void *)(v9 + Size), v9);
    v3 = Src;
    if ( v10 )
    {
LABEL_20:
      if ( this[5] < 0x10u )
        v12 = this;
      else
        v12 = (_DWORD *)*this;
      memcpy_0((char *)v12 + this[4], v3, Size);
      v13 = this[5] < 0x10u;
      this[4] = v10;
      if ( !v13 )
      {
        *(_BYTE *)(*this + v10) = 0;
        return this;
      }
      *((_BYTE *)this + v10) = 0;
    }
    return this;
  }
  if ( v10 )
    goto LABEL_20;
  this[4] = 0;
  if ( v11 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (0040DD10) --------------------------------------------------------
_DWORD *__cdecl sub_40DD10(int a1, _DWORD *a2, int a3, _DWORD *a4, char *a5, int a6)
{
  _DWORD *v7; // ecx
  wchar_t v8; // dx
  int *v9; // ebx
  _WORD **v10; // eax
  wchar_t *v11; // ecx
  wchar_t v12; // ax
  _DWORD *result; // eax
  mbstate_t v14; // [esp+4h] [ebp-10h] BYREF
  wchar_t v15[2]; // [esp+Ch] [ebp-8h] BYREF
  char v16[4]; // [esp+10h] [ebp-4h] BYREF

  if ( a6 )
  {
    *(_DWORD *)&v14._Byte = a1 + 8;
    do
    {
      v16[0] = *a5;
      *(_DWORD *)v15 = 0;
      v14._Wchar = 0;
      _Mbrtowc(v15, v16, 1u, &v14, *(const _Cvtvec **)&v14._Byte);
      v7 = a4;
      if ( !a4 )
        goto LABEL_9;
      v8 = v15[0];
      if ( *(_DWORD *)a4[9] && (v9 = (int *)a4[13], *v9 > 0) )
      {
        --*v9;
        v10 = (_WORD **)a4[9];
        v11 = (*v10)++;
        *v11 = v8;
        v12 = v8;
      }
      else
      {
        v12 = (*(int (__stdcall **)(_DWORD))(*a4 + 12))(*(_DWORD *)v15);
      }
      v7 = a4;
      if ( v12 == 0xFFFF )
LABEL_9:
        LOBYTE(a3) = 1;
      ++a5;
      --a6;
    }
    while ( a6 );
    result = a2;
    *a2 = a3;
    a2[1] = v7;
  }
  else
  {
    result = a2;
    *a2 = a3;
    a2[1] = a4;
  }
  return result;
}
// 40DD10: using guessed type char var_4[4];

//----- (0040DDE0) --------------------------------------------------------
int __cdecl sub_40DDE0(int a1, int a2, int a3, int a4, void *Buf, size_t MaxCount, int a7)
{
  _BYTE *v9; // eax
  int v10; // esi
  int *v11; // eax
  char *v12; // edi
  size_t v13; // ebx
  int *v14; // eax
  int v15; // edx
  int v17; // [esp+10h] [ebp-10h] BYREF
  int v18; // [esp+18h] [ebp-8h] BYREF

  while ( 1 )
  {
    v9 = memchr(Buf, 0, MaxCount);
    v10 = v9 ? v9 - (_BYTE *)Buf : MaxCount;
    v11 = sub_40DD10(a1, &v17, a3, (_DWORD *)a4, (char *)Buf, v10);
    a3 = *v11;
    v12 = (char *)Buf + v10;
    v13 = MaxCount - v10;
    a4 = v11[1];
    if ( !v13 )
      break;
    if ( (_WORD)a7 )
    {
      v14 = sub_40DB80(a1, &v18, *v11, (_DWORD *)v11[1], a7, 1);
      a3 = *v14;
      a4 = v14[1];
    }
    Buf = v12 + 1;
    MaxCount = v13 - 1;
  }
  v15 = *v11;
  *(_DWORD *)(a2 + 4) = v11[1];
  *(_DWORD *)a2 = v15;
  return a2;
}

//----- (0040DE80) --------------------------------------------------------
_DWORD *__thiscall sub_40DE80(_DWORD *this, int a2)
{
  _DWORD **v3; // ecx
  int *v4; // edx
  _WORD **v5; // ecx
  _WORD *v6; // eax
  __int16 v7; // ax

  v3 = (_DWORD **)this[1];
  if ( !v3
    || (!*v3[9] || (v4 = v3[13], *v4 <= 0) ? (v7 = ((int (__thiscall *)(_DWORD **, int))(*v3)[3])(v3, a2)) : (--*v4, v5 = (_WORD **)v3[9], v6 = *v5, ++*v5, *v6 = a2, v7 = a2),
        v7 == -1) )
  {
    *(_BYTE *)this = 1;
  }
  return this;
}

//----- (0040DEE0) --------------------------------------------------------
_DWORD *__thiscall sub_40DEE0(_DWORD *this, int a2, int a3, size_t Size)
{
  _DWORD *v4; // edx
  unsigned int v5; // eax
  unsigned int v7; // ebx
  size_t v8; // eax
  size_t v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ecx
  _DWORD *v12; // ecx
  _DWORD *result; // eax
  _DWORD *v14; // eax
  bool v15; // cf

  v4 = (_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 16);
  if ( v5 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = Size;
  v8 = v5 - a3;
  if ( v8 < Size )
    v7 = v8;
  v9 = this[4];
  if ( -1 - v9 <= v7 )
    std::_Xlength_error("string too long");
  if ( !v7 )
    return this;
  v10 = v9 + v7;
  if ( v9 + v7 == -1 )
    std::_Xlength_error("string too long");
  v11 = this[5];
  if ( v11 < v10 )
  {
    sub_4079E0((int)this, (void *)(v9 + v7), v9);
    v4 = (_DWORD *)a2;
    if ( v10 )
    {
LABEL_12:
      if ( v4[5] < 0x10u )
        v12 = v4;
      else
        v12 = (_DWORD *)*v4;
      if ( this[5] < 0x10u )
        v14 = this;
      else
        v14 = (_DWORD *)*this;
      memcpy_0((char *)v14 + this[4], (char *)v12 + a3, v7);
      v15 = this[5] < 0x10u;
      this[4] = v10;
      if ( !v15 )
      {
        *(_BYTE *)(*this + v10) = 0;
        return this;
      }
      *((_BYTE *)this + v10) = 0;
    }
    return this;
  }
  if ( v10 )
    goto LABEL_12;
  this[4] = 0;
  if ( v11 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (0040DFD0) --------------------------------------------------------
_DWORD *__usercall sub_40DFD0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<esi>)
{
  _DWORD *v3; // eax

  v3 = sub_406A00(a2, a1, 0, 0xFFFFFFFF);
  a3[5] = 7;
  a3[4] = 0;
  *(_WORD *)a3 = 0;
  sub_40AF70(a3, v3);
  return a3;
}

//----- (0040E010) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_40E010(int a1)
{
  int v1; // ebx
  int v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF7E4;
  v13 = (struct std::locale::facet *)dword_4EF7E4;
  if ( !dword_4F2494 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4F2494 )
      dword_4F2494 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4F2494;
  v4 = *(_DWORD *)a1;
  if ( (unsigned int)dword_4F2494 >= *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4F2494);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_40E1A0(&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF7E4 = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF7E4: using guessed type int dword_4EF7E4;
// 4F2494: using guessed type int dword_4F2494;
// 40E010: using guessed type char var_18[4];
// 40E010: using guessed type char var_14[4];

//----- (0040E150) --------------------------------------------------------
int __userpurge sub_40E150@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<esi>, int a4, int a5)
{
  int v5; // eax
  int v6; // ebx
  int result; // eax
  int v9[18]; // [esp+8h] [ebp-48h] BYREF

  sub_40E400(a4, a2, (int)v9, (int)(a3 + 1), a1);
  v5 = sub_40E4B0(v9);
  v6 = v5;
  if ( v5 )
    ++*(_DWORD *)(v5 + 28);
  result = *a3;
  if ( *a3 )
  {
    if ( (*(_DWORD *)(result + 28))-- == 1 )
      result = sub_40B950(*a3, 0);
  }
  *a3 = v6;
  return result;
}
// 40E150: using guessed type _DWORD var_48[18];

//----- (0040E1A0) --------------------------------------------------------
int __cdecl sub_40E1A0(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  char *v4; // eax
  int v5; // edx
  _Cvtvec *v7; // [esp+0h] [ebp-40h]
  char v8[36]; // [esp+Ch] [ebp-34h] BYREF
  _DWORD *v9; // [esp+30h] [ebp-10h]
  int v10; // [esp+3Ch] [ebp-4h]

  v2 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x10u);
    v9 = v3;
    v10 = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v4 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v4 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v4);
      v2 = 1;
      v3[1] = 0;
      *v3 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v3[2] = _Getcvt(v7);
      v3[3] = v5;
    }
    else
    {
      v3 = 0;
    }
    v10 = -1;
    *a1 = v3;
    if ( (v2 & 1) != 0 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 40E21B: variable 'v7' is possibly undefined
// 40E223: variable 'v5' is possibly undefined
// 4BDE28: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0040E260) --------------------------------------------------------
char __cdecl sub_40E260(int a1, unsigned __int16 *a2, int *a3, int a4)
{
  int *v4; // ecx
  int v5; // eax
  int *v6; // ebx
  unsigned __int16 *v9; // eax
  unsigned __int16 *v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // esi
  int v15; // [esp-8h] [ebp-270h]
  int v16; // [esp-4h] [ebp-26Ch]
  int v17; // [esp+10h] [ebp-258h] BYREF
  char v18; // [esp+17h] [ebp-251h]
  char v19[536]; // [esp+18h] [ebp-250h] BYREF
  unsigned __int16 *v20; // [esp+230h] [ebp-38h]
  unsigned int v21; // [esp+23Ch] [ebp-2Ch]
  int v22; // [esp+24Ch] [ebp-1Ch]
  int v23; // [esp+264h] [ebp-4h]
  unsigned __int16 *i; // [esp+270h] [ebp+8h]

  v5 = *a3;
  v6 = v4;
  if ( !*a3 )
    return 0;
  v16 = *(_DWORD *)(v5 + 20);
  v15 = *(_DWORD *)(v5 + 24);
  v18 = 0;
  sub_40E5C0(v5, 0, (int)v19, a1, (int)a2, v15, v16);
  v23 = 0;
  if ( sub_40E970(0, (int)v6, (int)v19) )
    goto LABEL_9;
  if ( (unsigned __int16 *)a1 != a2 )
  {
    v21 = v21 & 0xFFFFDEFF | 0x100;
    v9 = (unsigned __int16 *)*sub_40E6A0((int)v19, &v17, (unsigned __int16 *)(a1 + 2), a2, 0);
    v10 = a2;
    for ( i = v9; v9 != a2; i = v9 )
    {
      v20 = v9;
      if ( sub_40E970(0, (int)v6, (int)v19) )
        goto LABEL_9;
      v9 = (unsigned __int16 *)*sub_40E6A0((int)v19, &v17, i + 1, a2, 0);
      v10 = a2;
    }
    v20 = v10;
    if ( sub_40E970(0, (int)v6, (int)v19) )
    {
LABEL_9:
      v18 = 1;
      if ( v6 )
      {
        *v6 = a4;
        v6[5] = a1;
      }
    }
  }
  v23 = -1;
  v11 = v22;
  if ( v22 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v17, 0);
    v12 = *(_DWORD *)(v11 + 4);
    if ( v12 && v12 != -1 )
      *(_DWORD *)(v11 + 4) = v12 - 1;
    v13 = -(*(_DWORD *)(v11 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v17);
    v14 = (void (__thiscall ***)(_DWORD, int))(v11 & v13);
    if ( v14 )
      (**v14)(v14, 1);
  }
  return v18;
}
// 40E293: variable 'v4' is possibly undefined
// 40E260: using guessed type _DWORD var_258;

//----- (0040E400) --------------------------------------------------------
int __userpurge sub_40E400@<eax>(int a1@<eax>, unsigned int a2@<ebx>, int a3@<edi>, int a4, int a5)
{
  int v5; // ecx
  unsigned int v6; // eax
  int v7; // eax

  *(_DWORD *)a3 = a1;
  *(_DWORD *)(a3 + 4) = a1;
  *(_DWORD *)(a3 + 8) = a5;
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 0;
  sub_40EDF0(a2, (_DWORD *)(a3 + 24), a4);
  v6 = a2 & 0x3F;
  *(_DWORD *)(a3 + 52) = a4;
  *(_DWORD *)(a3 + 56) = a2;
  if ( v6 == 1 || (a2 & 0x3F) == 0 )
  {
    v7 = 142040571;
  }
  else
  {
    switch ( v6 )
    {
      case 2u:
        v7 = 1845494528;
        break;
      case 4u:
        v7 = 1887436827;
        break;
      case 8u:
        v7 = 1904320539;
        break;
      case 0x10u:
        v7 = 1846018820;
        break;
      default:
        v5 = v6 != 32;
        v7 = (v5 - 1) & 0x7088001F;
        break;
    }
  }
  *(_DWORD *)(a3 + 68) = v7;
  if ( (v7 & 0x40000000) != 0 )
    *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8) |= 8u;
  sub_40EAA0(v5, (unsigned __int16 **)a3);
  return a3;
}
// 40E498: variable 'v5' is possibly undefined

//----- (0040E4B0) --------------------------------------------------------
int __stdcall sub_40E4B0(_DWORD *a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  int result; // eax
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  v1 = a1 + 6;
  v4[7] = 0;
  v2 = sub_40EEE0((int)(a1 + 6), 0);
  sub_40EC40(a1);
  if ( *a1 != a1[2] )
    std::tr1::_Xbad(14);
  sub_40EE60((int)v2, (int)v1);
  result = sub_40EF40(v1);
  *(_DWORD *)(result + 20) = a1[14];
  *(_DWORD *)(result + 24) = a1[3] + 1;
  return result;
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (0040E570) --------------------------------------------------------
void __usercall sub_40E570(int a1@<eax>)
{
  int v1; // edi
  int v2; // eax
  int v3; // esi
  void (__thiscall ***v4)(_DWORD, int); // esi
  char v5[4]; // [esp+4h] [ebp-4h] BYREF

  v1 = *(_DWORD *)(a1 + 564);
  if ( v1 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
    v2 = *(_DWORD *)(v1 + 4);
    if ( v2 && v2 != -1 )
      *(_DWORD *)(v1 + 4) = v2 - 1;
    v3 = -(*(_DWORD *)(v1 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v5);
    v4 = (void (__thiscall ***)(_DWORD, int))(v1 & v3);
    if ( v4 )
      (**v4)(v4, 1);
  }
}
// 40E570: using guessed type char var_4[4];

//----- (0040E5C0) --------------------------------------------------------
int __userpurge sub_40E5C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>, int a4, int a5, char a6, int a7)
{
  _DWORD *v8; // eax
  int i; // ecx
  _DWORD *v10; // eax
  int j; // ecx
  int v12; // eax
  bool v13; // al
  int v14; // edi
  int v15; // eax

  *(_DWORD *)a3 = 0;
  v8 = (_DWORD *)(a3 + 8);
  for ( i = 31; i >= 0; --i )
  {
    *v8 = 0;
    v8[1] = 0;
    v8 += 2;
  }
  *(_DWORD *)(a3 + 264) = 0;
  v10 = (_DWORD *)(a3 + 272);
  for ( j = 31; j >= 0; --j )
  {
    *v10 = 0;
    v10[1] = 0;
    v10 += 2;
  }
  *(_DWORD *)(a3 + 528) = 0;
  *(_DWORD *)(a3 + 532) = a5;
  v12 = a7;
  *(_DWORD *)(a3 + 536) = a4;
  *(_DWORD *)(a3 + 540) = a1;
  *(_DWORD *)(a3 + 544) = v12;
  *(_DWORD *)(a3 + 548) = a2;
  *(_BYTE *)(a3 + 552) = 0;
  *(_BYTE *)(a3 + 554) = a6;
  v13 = (*(_BYTE *)(a1 + 8) & 8) != 0 && (a2 & 0x10) == 0;
  *(_BYTE *)(a3 + 555) = v13;
  *(_DWORD *)(a3 + 556) = 0;
  *(_DWORD *)(a3 + 560) = 0;
  *(_DWORD *)(a3 + 564) = std::locale::_Init();
  v14 = sub_426E4C();
  std::_Lockit::_Lockit((std::_Lockit *)&a7, 0);
  v15 = *(_DWORD *)(v14 + 4);
  if ( v15 != -1 )
    *(_DWORD *)(v14 + 4) = v15 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&a7);
  return a3;
}

//----- (0040E6A0) --------------------------------------------------------
_DWORD *__thiscall sub_40E6A0(int this, _DWORD *a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5)
{
  int v5; // ebx
  unsigned __int16 *v6; // edi
  _DWORD *result; // eax
  unsigned __int16 **v8; // eax
  int v9; // esi
  unsigned int *v10; // eax
  char v11; // al
  unsigned int v12; // eax
  int v13; // esi
  int v14; // ecx
  _WORD *v15; // eax
  _WORD *i; // ecx
  int *v17; // edx
  int v18; // esi
  unsigned __int16 **v19; // eax
  char v20[4]; // [esp+10h] [ebp-10h] BYREF
  __int16 *v21; // [esp+14h] [ebp-Ch] BYREF
  int v22; // [esp+18h] [ebp-8h] BYREF
  _DWORD *v23; // [esp+1Ch] [ebp-4h]
  unsigned __int16 v24; // [esp+34h] [ebp+14h]

  v5 = a5;
  v23 = (_DWORD *)this;
  if ( !a5 )
    v5 = *(_DWORD *)(this + 540);
  v6 = a3;
  if ( a3 == a4 )
    goto LABEL_12;
  while ( 2 )
  {
    if ( !v5 )
    {
LABEL_12:
      result = a2;
      *a2 = v6;
      return result;
    }
    switch ( *(_DWORD *)(v5 + 4) )
    {
      case 1:
      case 8:
      case 9:
      case 0xD:
      case 0xE:
      case 0x14:
        v5 = *(_DWORD *)(v5 + 12);
        continue;
      case 2:
        if ( (*(_BYTE *)(this + 548) & 1) != 0 )
          goto LABEL_9;
        do
        {
          if ( *(v6 - 1) == 10 )
            break;
          ++v6;
        }
        while ( v6 != a4 );
        goto LABEL_12;
      case 3:
        if ( (*(_BYTE *)(this + 548) & 2) != 0 )
        {
LABEL_9:
          result = a2;
          *a2 = a4;
          return result;
        }
        while ( *v6 != 10 )
        {
          if ( ++v6 == a4 )
          {
            result = a2;
            *a2 = v6;
            return result;
          }
        }
        goto LABEL_12;
      case 6:
        while ( 1 )
        {
          v8 = (unsigned __int16 **)sub_40FB50(
                                      *(unsigned __int16 **)(v5 + 28),
                                      v23[136],
                                      (unsigned __int16 *)(*(_DWORD *)(v5 + 28) + 2),
                                      &v22,
                                      (int)v6,
                                      v6 + 1,
                                      (int)(v23 + 139),
                                      (v23[137] & 0x80) != 0);
          v6 = a3;
          if ( *v8 != a3 )
            break;
          v6 = a3 + 1;
          a3 = v6;
          if ( v6 == a4 )
          {
            result = a2;
            *a2 = v6;
            return result;
          }
        }
        goto LABEL_12;
      case 7:
        goto LABEL_20;
      case 0xC:
      case 0x15:
        v5 = 0;
        continue;
      case 0x10:
        v18 = v5;
        do
        {
          if ( !v18 )
            break;
          v19 = (unsigned __int16 **)sub_40E6A0((int)v23, v20, v6, a4, *(_DWORD *)(v18 + 12));
          v6 = a3;
          a4 = *v19;
          v18 = *(_DWORD *)(v18 + 24);
        }
        while ( a3 != *v19 );
        result = a2;
        *a2 = a4;
        return result;
      default:
        goto LABEL_12;
    }
  }
  do
  {
LABEL_20:
    v9 = *v6;
    v10 = *(unsigned int **)(v5 + 20);
    v24 = *v6;
    if ( v10 && *sub_40FBE0(&v21, (__int16 *)v6, (__int16 *)v6 + 1, v10) != (__int16 *)v6 )
    {
      v11 = 1;
      goto LABEL_48;
    }
    if ( *(_DWORD *)(v5 + 32) )
    {
      if ( (v23[136] & 0x800) != 0 )
      {
        v6 = a3;
        LOWORD(v9) = sub_40EFA0(v23 + 139, v9);
      }
      if ( sub_40FC50(*(_DWORD *)(v5 + 32), v9) )
      {
        v11 = 1;
        goto LABEL_48;
      }
      LOWORD(v9) = v24;
    }
    v12 = (unsigned __int16)v9;
    if ( dword_4EF7E8 > (unsigned __int16)v9 || (unsigned __int16)v9 >= 0x100u )
    {
      if ( *(_DWORD *)(v5 + 28) )
      {
        v14 = *(_DWORD *)(v5 + 28);
        v15 = *(_WORD **)(v14 + 8);
        for ( i = &v15[*(_DWORD *)(v14 + 4)]; v15 != i; ++v15 )
        {
          if ( *v15 == (_WORD)v9 )
            break;
        }
        if ( v15 != (_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 28) + 8) + 2 * *(_DWORD *)(*(_DWORD *)(v5 + 28) + 4)) )
        {
          v11 = 1;
          goto LABEL_48;
        }
      }
      if ( *(_WORD *)(v5 + 36) )
      {
        v6 = a3;
        if ( (unsigned __int8)sub_40F010((int)(v23 + 139), *(_WORD *)(v5 + 36), v9) )
        {
          v11 = 1;
          goto LABEL_48;
        }
        LOWORD(v9) = v24;
      }
      v17 = *(int **)(v5 + 40);
      if ( v17 )
      {
        v6 = a3;
        if ( sub_40FC80(v17, v23 + 139, v9) )
        {
          v11 = 1;
          goto LABEL_48;
        }
      }
    }
    else
    {
      v13 = *(_DWORD *)(v5 + 24);
      if ( v13 && ((unsigned __int8)(1 << (v12 & 7)) & *(_BYTE *)((v12 >> 3) + v13)) != 0 )
      {
        v11 = 1;
        goto LABEL_48;
      }
    }
    v11 = 0;
LABEL_48:
    if ( v11 != (*(_BYTE *)(v5 + 8) & 1) )
      goto LABEL_12;
    a3 = ++v6;
  }
  while ( v6 != a4 );
  result = a2;
  *a2 = v6;
  return result;
}
// 4EF7E8: using guessed type int dword_4EF7E8;
// 40E6A0: using guessed type char var_10[4];

//----- (0040E970) --------------------------------------------------------
bool __usercall sub_40E970@<al>(char a1@<cl>, int a2@<ebx>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  bool result; // al
  _DWORD *v6; // edi
  unsigned int v7; // ecx
  int v8; // eax
  _DWORD *v9; // edi
  unsigned int v10; // [esp+4h] [ebp-8h]
  _DWORD *v11; // [esp+8h] [ebp-4h]

  v3 = *(_DWORD *)(a3 + 536);
  v4 = *(_DWORD *)(a3 + 540);
  *(_DWORD *)(a3 + 528) = v3;
  *(_DWORD *)a3 = v3;
  *(_BYTE *)(a3 + 568) = a1;
  *(_DWORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 553) = a2 != 0;
  *(_BYTE *)(a3 + 552) = 0;
  result = sub_40F6C0((int *)a3, v4, 0);
  if ( result )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)(a2 + 4);
      sub_40F290(*(unsigned __int8 *)(a3 + 554), (int *)(a2 + 4));
      LOBYTE(v7) = 0;
      v10 = 0;
      if ( *(_BYTE *)(a3 + 554) )
      {
        v8 = 0;
        v11 = (_DWORD *)(a3 + 276);
        do
        {
          if ( ((1 << v7) & *(_DWORD *)(a3 + 268)) != 0 )
          {
            *(_BYTE *)(v8 + *v6 + 8) = 1;
            *(_DWORD *)(v8 + *v6) = *(v11 - 1);
            *(_DWORD *)(v8 + *v6 + 4) = *v11;
          }
          else
          {
            *(_BYTE *)(v8 + *v6 + 8) = 0;
            *(_DWORD *)(v8 + *v6) = *(_DWORD *)(a3 + 532);
            *(_DWORD *)(v8 + *v6 + 4) = *(_DWORD *)(a3 + 532);
          }
          v11 += 2;
          v7 = v10 + 1;
          v8 += 12;
          v10 = v7;
        }
        while ( v7 < *(unsigned __int8 *)(a3 + 554) );
      }
      v9 = (_DWORD *)*v6;
      *(_DWORD *)a2 = *(_DWORD *)(a3 + 528);
      *(_BYTE *)(a2 + 28) = 1;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a3 + 528);
      *(_DWORD *)(a2 + 24) = *v9;
      *(_BYTE *)(a2 + 40) = 1;
      *(_DWORD *)(a2 + 32) = v9[1];
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(a3 + 532);
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a3 + 532);
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 532);
    }
    return 1;
  }
  return result;
}

//----- (0040EAA0) --------------------------------------------------------
int __usercall sub_40EAA0@<eax>(int a1@<ecx>, unsigned __int16 **a2@<esi>)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  bool v5; // zf

  if ( *a2 == a2[2] )
  {
    v2 = 0xFFFF;
    *((_WORD *)a2 + 31) = -1;
  }
  else
  {
    v3 = **a2;
    a1 = 0xFFFF;
    *((_WORD *)a2 + 31) = v3;
    if ( (_WORD)v3 == 0xFFFF )
    {
      v2 = -1;
    }
    else if ( strchr("()$^.*+?[]|\\-{},:=!\n\r\b", v3) )
    {
      v2 = *((unsigned __int16 *)a2 + 31);
    }
    else
    {
      v2 = 0;
    }
  }
  a2[16] = (unsigned __int16 *)v2;
  result = *((unsigned __int16 *)a2 + 31) - 10;
  switch ( *((_WORD *)a2 + 31) )
  {
    case 0xA:
      if ( ((_BYTE)a2[17] & 4) != 0 && !a2[4] )
        a2[16] = (unsigned __int16 *)124;
      return result;
    case 0x24:
      if ( ((unsigned int)a2[17] & 0x2000000) != 0 )
      {
        result = (int)(*a2 + 1);
        if ( (unsigned __int16 *)result != a2[2] && *(_WORD *)result != 10 )
          a2[16] = 0;
      }
      return result;
    case 0x28:
    case 0x29:
      v5 = ((_BYTE)a2[17] & 8) == 0;
      goto LABEL_27;
    case 0x2A:
      if ( ((unsigned int)a2[17] & 0x4000000) != 0 )
      {
        result = sub_4102E0((int)(a2 + 6));
        if ( (_BYTE)result )
          a2[16] = 0;
      }
      return result;
    case 0x2B:
    case 0x3F:
      v5 = ((_BYTE)a2[17] & 1) == 0;
      goto LABEL_27;
    case 0x5C:
      result = sub_40FF30(a1, (int)a2);
      if ( (_BYTE)result )
      {
        result = (*a2)[1];
        *((_WORD *)a2 + 31) = result;
        a2[16] = (unsigned __int16 *)result;
      }
      return result;
    case 0x5E:
      if ( ((unsigned int)a2[17] & 0x2000000) == 0 )
        return result;
      result = sub_4102E0((int)(a2 + 6));
      v5 = (_BYTE)result == 0;
LABEL_27:
      if ( v5 )
        a2[16] = 0;
      return result;
    case 0x7B:
    case 0x7D:
      v5 = ((_BYTE)a2[17] & 0x10) == 0;
      goto LABEL_27;
    case 0x7C:
      v5 = ((_BYTE)a2[17] & 2) == 0;
      goto LABEL_27;
    default:
      return result;
  }
}
// 40EB08: variable 'a1' is possibly undefined

//----- (0040EC40) --------------------------------------------------------
char __thiscall sub_40EC40(_DWORD *this)
{
  unsigned __int16 **v1; // esi
  _DWORD *v2; // eax
  int v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  _DWORD *v6; // edi
  unsigned __int16 *v7; // eax
  int v8; // ecx
  unsigned __int16 *v9; // eax
  _DWORD *v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // ebx
  int v14; // eax
  int v16; // [esp+Ch] [ebp-14h]
  int v18; // [esp+14h] [ebp-Ch]
  _DWORD *v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ch] [ebp-4h]

  v1 = (unsigned __int16 **)this;
  v18 = this[7];
  LOBYTE(v2) = sub_40FFC0((int)this);
  if ( !(_BYTE)v2 )
  {
    if ( v1[16] != (unsigned __int16 *)124 )
      return (char)v2;
    v3 = (int)(v1 + 6);
    v4 = sub_410320(v3);
    sub_40EE60((int)v4, v3);
    v1 = (unsigned __int16 **)this;
  }
  v5 = v1 + 6;
  v16 = (int)(v1 + 6);
  v2 = sub_410370((int)(v1 + 6), v18);
  v6 = v2;
  v19 = v2;
  if ( v1[16] == (unsigned __int16 *)124 )
  {
    while ( 1 )
    {
      v7 = *v1;
      v8 = (int)v1[2];
      if ( *v1 != (unsigned __int16 *)v8 )
      {
        if ( *v7 == 92 )
        {
          if ( (v9 = v7 + 1, v9 != (unsigned __int16 *)v8)
            && ((_BYTE)v1[17] & 8) == 0
            && ((v8 = *v9, v8 == 40) || v8 == 41)
            || ((_BYTE)v1[17] & 0x10) == 0 && ((v8 = *v9, v8 == 123) || v8 == 125) )
          {
            *v1 = v9;
          }
        }
        ++*v1;
      }
      sub_40EAA0(v8, v1);
      if ( !sub_40FFC0((int)v1) )
      {
        v10 = operator new(0x14u);
        if ( v10 )
        {
          *v10 = &std::tr1::_Node_base::`vftable';
          v10[1] = 8;
          v10[2] = 0;
          v10[3] = 0;
          v10[4] = 0;
        }
        else
        {
          v10 = 0;
        }
        v10[4] = v5[1];
        v11 = *(_DWORD *)(v5[1] + 12);
        if ( v11 )
        {
          v10[3] = v11;
          *(_DWORD *)(*(_DWORD *)(v5[1] + 12) + 16) = v10;
        }
        *(_DWORD *)(v5[1] + 12) = v10;
        v5[1] = v10;
        sub_40EE60((int)v10, v16);
        v6 = v19;
      }
      v12 = v6[3];
      v13 = *(_DWORD *)(v18 + 12);
      v6[3] = 0;
      v20 = v12;
      v14 = *(_DWORD *)(v16 + 4);
      *(_DWORD *)(v16 + 4) = v6;
      v6[3] = 0;
      for ( *(_DWORD *)(v14 + 12) = v6; *(_DWORD *)(v13 + 24); v13 = *(_DWORD *)(v13 + 24) )
        ;
      v2 = operator new(0x1Cu);
      if ( v2 )
      {
        v2[1] = 16;
        v2[2] = 0;
        v2[3] = 0;
        v2[4] = 0;
        *v2 = &std::tr1::_Node_if::`vftable';
        v2[5] = v6;
        v2[6] = 0;
      }
      else
      {
        v2 = 0;
      }
      *(_DWORD *)(v13 + 24) = v2;
      v2[3] = v20;
      LOBYTE(v2) = (_BYTE)this;
      *(_DWORD *)(v20 + 16) = *(_DWORD *)(v13 + 24);
      if ( this[16] != 124 )
        break;
      v5 = (_DWORD *)v16;
      v1 = (unsigned __int16 **)this;
    }
  }
  return (char)v2;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';
// 4CBF94: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (0040EDF0) --------------------------------------------------------
_DWORD *__userpurge sub_40EDF0@<eax>(unsigned int a1@<eax>, _DWORD *a2@<esi>, int a3)
{
  _DWORD *v4; // eax

  v4 = operator new(0x20u);
  if ( v4 )
  {
    v4[1] = 20;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 0;
    *v4 = &std::tr1::_Root_node::`vftable';
    v4[7] = 0;
  }
  else
  {
    v4 = 0;
  }
  a2[2] = 0;
  a2[3] = a1;
  *a2 = v4;
  a2[1] = v4;
  a2[4] = a3;
  a2[6] = ~(unsigned __int8)(a1 >> 9) & 4;
  a2[5] = ~(unsigned __int16)(a1 >> 3) & 0x100;
  return a2;
}
// 4CBF64: using guessed type void *std::tr1::_Root_node::`vftable';

//----- (0040EE60) --------------------------------------------------------
_DWORD *__usercall sub_40EE60@<eax>(int a1@<ebx>, int a2@<edi>)
{
  int v2; // eax
  int v3; // esi
  _DWORD *result; // eax
  int v5; // ecx

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 == 8 )
  {
    v3 = 9;
  }
  else if ( v2 == 10 )
  {
    v3 = 12;
  }
  else
  {
    v3 = 2 * (v2 != 11) + 12;
  }
  result = operator new(0x18u);
  if ( result )
  {
    result[1] = v3;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_end_group::`vftable';
    result[5] = a1;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( v5 )
  {
    result[3] = v5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12) = result;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}
// 4CBF6C: using guessed type void *std::tr1::_Node_end_group::`vftable';

//----- (0040EEE0) --------------------------------------------------------
_DWORD *__userpurge sub_40EEE0@<eax>(int a1@<esi>, int a2)
{
  _DWORD *result; // eax
  int v3; // ecx

  result = operator new(0x18u);
  if ( result )
  {
    result[1] = 13;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_capture::`vftable';
    result[5] = a2;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v3 )
  {
    result[3] = v3;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF7C: using guessed type void *std::tr1::_Node_capture::`vftable';

//----- (0040EF40) --------------------------------------------------------
int __usercall sub_40EF40@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // eax
  int v2; // ecx

  v1 = operator new(0x14u);
  if ( v1 )
  {
    *v1 = &std::tr1::_Node_base::`vftable';
    v1[1] = 21;
    v1[2] = 0;
    v1[3] = 0;
    v1[4] = 0;
  }
  else
  {
    v1 = 0;
  }
  v1[4] = a1[1];
  v2 = *(_DWORD *)(a1[1] + 12);
  if ( v2 )
  {
    v1[3] = v2;
    *(_DWORD *)(*(_DWORD *)(a1[1] + 12) + 16) = v1;
  }
  *(_DWORD *)(a1[1] + 12) = v1;
  a1[1] = v1;
  return *a1;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (0040EFA0) --------------------------------------------------------
__int16 __thiscall sub_40EFA0(void *this, int a2)
{
  struct std::locale::facet *v2; // eax
  void **v3; // eax
  __int16 v4; // si
  void *v6[5]; // [esp+8h] [ebp-20h] BYREF
  unsigned int v7; // [esp+1Ch] [ebp-Ch]

  v2 = sub_40F130((int)this);
  sub_40F360((int)&a2 + 2, (int)v2, (int)v6, (int)&a2);
  if ( v6[4] == (void *)1 )
  {
    v3 = (void **)v6[0];
    if ( v7 < 8 )
      v3 = v6;
    v4 = *(_WORD *)v3;
  }
  else
  {
    v4 = a2;
  }
  if ( v7 >= 8 )
    operator delete(v6[0]);
  return v4;
}

//----- (0040F010) --------------------------------------------------------
int __usercall sub_40F010@<eax>(int a1@<eax>, __int16 a2@<di>, __int16 a3@<si>)
{
  struct std::locale::facet *v3; // eax
  struct std::locale::facet *v5; // eax

  if ( a2 == -1 )
    return a3 == 95
        || (v5 = sub_40F1E0(a1),
            (*(unsigned __int8 (__thiscall **)(struct std::locale::facet *, int, __int16))(*(_DWORD *)v5 + 8))(
              v5,
              263,
              a3));
  v3 = sub_40F1E0(a1);
  return (*(int (__thiscall **)(struct std::locale::facet *, __int16, __int16))(*(_DWORD *)v3 + 8))(v3, a2, a3);
}

//----- (0040F060) --------------------------------------------------------
void __usercall sub_40F060(int a1@<ebx>)
{
  _DWORD *v1; // esi
  void *v2; // edi
  void *v3; // eax
  void **v4; // esi
  void **v5; // esi
  _DWORD *v6; // esi
  void *v7; // edi
  void *v8; // ecx

  v1 = *(_DWORD **)(a1 + 20);
  *(_DWORD *)a1 = &std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';
  while ( v1 )
  {
    v2 = v1;
    v3 = (void *)v1[3];
    v1 = (_DWORD *)v1[4];
    free(v3);
    operator delete(v2);
  }
  operator delete(*(void **)(a1 + 24));
  v4 = *(void ***)(a1 + 28);
  if ( v4 )
  {
    free(v4[2]);
    operator delete(v4);
  }
  v5 = *(void ***)(a1 + 32);
  if ( v5 )
  {
    free(v5[2]);
    operator delete(v5);
  }
  v6 = *(_DWORD **)(a1 + 40);
  while ( v6 )
  {
    v7 = v6;
    v8 = (void *)v6[3];
    v6 = (_DWORD *)v6[4];
    free(v8);
    operator delete(v7);
  }
  *(_DWORD *)a1 = &std::tr1::_Node_base::`vftable';
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';
// 4CBFFC: using guessed type void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';

//----- (0040F100) --------------------------------------------------------
void *__thiscall sub_40F100(void *this, char a2)
{
  sub_40F060((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0040F130) --------------------------------------------------------
struct std::locale::facet *__usercall sub_40F130@<eax>(int a1@<ebx>)
{
  int *v1; // eax
  struct std::locale::facet *result; // eax
  int v3; // edi
  int v4; // eax
  int v5; // esi
  void (__thiscall ***v6)(_DWORD, int); // esi
  char v7[4]; // [esp+Ch] [ebp-14h] BYREF
  int v8; // [esp+10h] [ebp-10h] BYREF
  int v9; // [esp+1Ch] [ebp-4h]

  if ( !*(_DWORD *)a1 )
  {
    v1 = sub_40F4D0(a1, &v8);
    v9 = 0;
    result = sub_410420(v1);
    v9 = -1;
    v3 = v8;
    *(_DWORD *)a1 = result;
    if ( !v3 )
      return result;
    std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
    v4 = *(_DWORD *)(v3 + 4);
    if ( v4 && v4 != -1 )
      *(_DWORD *)(v3 + 4) = v4 - 1;
    v5 = -(*(_DWORD *)(v3 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v7);
    v6 = (void (__thiscall ***)(_DWORD, int))(v3 & v5);
    if ( v6 )
      (**v6)(v6, 1);
  }
  return *(struct std::locale::facet **)a1;
}
// 40F130: using guessed type char var_14[4];

//----- (0040F1E0) --------------------------------------------------------
struct std::locale::facet *__usercall sub_40F1E0@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  struct std::locale::facet *result; // eax
  int v3; // edi
  int v4; // eax
  int v5; // esi
  void (__thiscall ***v6)(_DWORD, int); // esi
  char v7[4]; // [esp+Ch] [ebp-14h] BYREF
  int v8; // [esp+10h] [ebp-10h] BYREF
  int v9; // [esp+1Ch] [ebp-4h]

  if ( !*(_DWORD *)(a1 + 4) )
  {
    v1 = sub_40F4D0(a1, &v8);
    v9 = 0;
    result = sub_408900((int)v1);
    v9 = -1;
    v3 = v8;
    *(_DWORD *)(a1 + 4) = result;
    if ( !v3 )
      return result;
    std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
    v4 = *(_DWORD *)(v3 + 4);
    if ( v4 && v4 != -1 )
      *(_DWORD *)(v3 + 4) = v4 - 1;
    v5 = -(*(_DWORD *)(v3 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v7);
    v6 = (void (__thiscall ***)(_DWORD, int))(v3 & v5);
    if ( v6 )
      (**v6)(v6, 1);
  }
  return *(struct std::locale::facet **)(a1 + 4);
}
// 40F1E0: using guessed type char var_14[4];

//----- (0040F290) --------------------------------------------------------
unsigned int __usercall sub_40F290@<eax>(unsigned int a1@<eax>, int *a2@<edi>)
{
  unsigned int result; // eax

  result = (a2[1] - *a2) / 12;
  if ( result <= a1 )
  {
    if ( result >= a1 )
      return result;
    sub_40F500(a2, a1 - result);
    sub_4114E0(a2[1], a1 - (a2[1] - *a2) / 12);
    result = a2[1] + 12 * (a1 - (a2[1] - *a2) / 12);
  }
  else
  {
    result = *a2 + 12 * a1;
    if ( result == a2[1] )
      return result;
  }
  a2[1] = result;
  return result;
}

//----- (0040F360) --------------------------------------------------------
int __userpurge sub_40F360@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4)
{
  (*(void (__thiscall **)(int, int, int, int, _DWORD))(*(_DWORD *)a2 + 8))(a2, a3, a4, a1, 0);
  return a3;
}

//----- (0040F380) --------------------------------------------------------
int __thiscall sub_40F380(const _Collvec *this, wchar_t *a2, wchar_t *a3, wchar_t *a4, wchar_t *a5)
{
  return _Wcscoll(a2, a3, a4, a5, this + 1);
}

//----- (0040F3B0) --------------------------------------------------------
int __fastcall sub_40F3B0(_Collvec *a1, int a2, int a3, wchar_t *a4, _Collvec *a5)
{
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  int v9; // edx
  wchar_t *v10; // eax
  unsigned int v11; // ecx
  _Collvec *v13; // [esp+30h] [ebp+10h]

  *(_DWORD *)(a3 + 20) = 7;
  *(_DWORD *)(a3 + 16) = 0;
  *(_WORD *)a3 = 0;
  v6 = ((char *)a5 - (char *)a4) >> 1;
  if ( v6 )
  {
    v13 = a1 + 1;
    do
    {
      v7 = *(_DWORD *)(a3 + 16);
      if ( v6 > v7 )
        sub_4054C0((int *)a3, a2, v6 - v7, 0);
      else
        sub_409050((_DWORD *)a3, v6, 0xFFFFFFFF);
      v8 = *(_DWORD *)(a3 + 20);
      if ( v8 < 8 )
        v9 = a3;
      else
        v9 = *(_DWORD *)a3;
      if ( v8 < 8 )
        v10 = (wchar_t *)a3;
      else
        v10 = *(wchar_t **)a3;
      v6 = _Wcsxfrm(v10, (wchar_t *)(v9 + 2 * *(_DWORD *)(a3 + 16)), a4, (const wchar_t *)a5, v13);
    }
    while ( v6 > *(_DWORD *)(a3 + 16) && v6 );
  }
  v11 = *(_DWORD *)(a3 + 16);
  if ( v6 > v11 )
    sub_4054C0((int *)a3, a2, v6 - v11, 0);
  else
    sub_409050((_DWORD *)a3, v6, 0xFFFFFFFF);
  return a3;
}
// 40F429: variable 'a2' is possibly undefined

//----- (0040F4A0) --------------------------------------------------------
int __stdcall sub_40F4A0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2; // ecx
  int result; // eax
  int v4; // esi

  v2 = a1;
  for ( result = 0; v2 != a2; result = v4 + __ROL4__(result, 8) )
    v4 = *v2++;
  return result;
}

//----- (0040F4D0) --------------------------------------------------------
_DWORD *__usercall sub_40F4D0@<eax>(int a1@<eax>, _DWORD *a2@<edi>)
{
  int v2; // esi
  int v3; // eax
  char v5[4]; // [esp+4h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a1 + 8);
  *a2 = v2;
  std::_Lockit::_Lockit((std::_Lockit *)v5, 0);
  v3 = *(_DWORD *)(v2 + 4);
  if ( v3 != -1 )
    *(_DWORD *)(v2 + 4) = v3 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v5);
  return a2;
}
// 40F4D0: using guessed type char var_4[4];

//----- (0040F500) --------------------------------------------------------
unsigned int __usercall sub_40F500@<eax>(int *a1@<ecx>, int a2@<ebx>)
{
  unsigned int v2; // esi
  unsigned int v3; // esi
  unsigned int result; // eax
  unsigned int v5; // eax

  v2 = (a1[1] - *a1) / 12;
  if ( 357913941 - a2 < v2 )
    std::_Xlength_error("vector<T> too long");
  v3 = a2 + v2;
  result = (a1[2] - *a1) / 12;
  if ( v3 > result )
  {
    if ( 357913941 - (result >> 1) >= result )
      v5 = (result >> 1) + result;
    else
      v5 = 0;
    if ( v5 < v3 )
      v5 = v3;
    return sub_40F570(a1, v5);
  }
  return result;
}

//----- (0040F570) --------------------------------------------------------
unsigned int __thiscall sub_40F570(int *this, unsigned int a2)
{
  unsigned int result; // eax
  void *v4; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // esi
  int v8; // [esp+0h] [ebp-24h] BYREF
  void *v9; // [esp+10h] [ebp-14h]
  int *v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+20h] [ebp-4h]

  v10 = &v8;
  if ( a2 > 0x15555555 )
    std::_Xlength_error("vector<T> too long");
  result = (this[2] - *this) / 12;
  if ( result < a2 )
  {
    v4 = sub_40F660(a2);
    v11 = 0;
    v5 = this[1];
    v6 = *this;
    v9 = v4;
    sub_415800((int)v4, v6, v5);
    v7 = (this[1] - *this) / 12;
    if ( *this )
      operator delete((void *)*this);
    result = (unsigned int)v9;
    this[2] = (int)v9 + 12 * a2;
    this[1] = result + 12 * v7;
    *this = result;
  }
  return result;
}

//----- (0040F660) --------------------------------------------------------
void *__fastcall sub_40F660(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x15555555 || (result = operator new(12 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0040F6C0) --------------------------------------------------------
BOOL __thiscall sub_40F6C0(int *this, int a2, int a3)
{
  int v3; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v8; // al
  int v9; // eax
  char v10; // al
  unsigned __int16 *v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  bool v15; // zf
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  unsigned __int16 *v20; // esi
  int v21; // eax
  int v22; // esi
  char v23; // al
  int v24; // ecx
  int v26; // ecx
  int v27; // [esp-8h] [ebp-48h]
  bool v28; // [esp+12h] [ebp-2Eh]
  char v29; // [esp+13h] [ebp-2Dh]
  char *v30; // [esp+14h] [ebp-2Ch] BYREF
  int v31; // [esp+18h] [ebp-28h] BYREF
  int v32; // [esp+20h] [ebp-20h] BYREF
  int v33; // [esp+28h] [ebp-18h]
  int v34; // [esp+30h] [ebp-10h]
  int pExceptionObject[3]; // [esp+34h] [ebp-Ch] BYREF

  v3 = a2;
  v28 = 0;
  if ( !a2 )
    return !v28;
  while ( 2 )
  {
    v5 = *(_DWORD *)(v3 + 4);
    switch ( v5 )
    {
      case 1:
      case 8:
      case 9:
      case 17:
      case 20:
        goto LABEL_63;
      case 2:
        v6 = this[137];
        if ( (v6 & 0x101) == 1 )
          goto LABEL_68;
        if ( (v6 & 0x100) != 0 || *this != this[132] )
          v28 = *(_WORD *)(*this - 2) != 10;
        goto LABEL_63;
      case 3:
        if ( (this[137] & 2) == 0 && (*this == this[133] || *(_WORD *)*this == 10) )
          goto LABEL_63;
        goto LABEL_68;
      case 4:
        v7 = this[137];
        if ( (v7 & 4) != 0 && *this == this[132] || (v7 & 8) != 0 && *this == this[133] )
        {
          v8 = 0;
        }
        else
        {
          if ( *this == this[132] && (v7 & 0x100) == 0
            || *(unsigned __int16 *)(*this - 2) != (char)*(_WORD *)(*this - 2)
            || (v29 = 1,
                !strchr(
                   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_",
                   *(unsigned __int16 *)(*this - 2))) )
          {
            v29 = 0;
          }
          v10 = 0;
          if ( *this != this[133] )
          {
            v9 = *(unsigned __int16 *)*this;
            if ( v9 == (char)v9 )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v9) )
                v10 = 1;
            }
          }
          v8 = v29 != v10;
        }
        if ( v8 != (*(_BYTE *)(v3 + 8) & 1) )
          goto LABEL_63;
        goto LABEL_68;
      case 5:
        v11 = (unsigned __int16 *)*this;
        if ( *this == this[133] )
          goto LABEL_68;
        v12 = *v11;
        if ( v12 == 10 || v12 == 13 )
          goto LABEL_68;
        *this = (int)(v11 + 1);
        goto LABEL_63;
      case 6:
        v13 = *sub_40FB50(
                 *(unsigned __int16 **)(v3 + 28),
                 this[136],
                 (unsigned __int16 *)(*(_DWORD *)(v3 + 28) + 2 * *(_DWORD *)(v3 + 24)),
                 &v31,
                 *this,
                 (unsigned __int16 *)this[133],
                 (int)(this + 139),
                 (this[137] & 0x80) != 0);
        if ( v13 == *this )
          goto LABEL_68;
        *this = v13;
        goto LABEL_63;
      case 7:
        if ( *this == this[133] || !sub_410910(this, v3) )
          goto LABEL_68;
        v28 = 0;
        goto LABEL_64;
      case 10:
      case 11:
        v14 = this[1];
        v15 = v5 == 11;
        v16 = *(_DWORD *)(v3 + 20);
        v30 = (char *)*this;
        v34 = v14;
        if ( (unsigned __int8)sub_40F6C0(this, v16, 0) != v15 )
        {
          *this = (int)v30;
LABEL_63:
          if ( v28 )
            goto LABEL_69;
LABEL_64:
          if ( !v3 )
            return !v28;
          v3 = *(_DWORD *)(v3 + 12);
          if ( !v3 )
            return !v28;
          continue;
        }
        v26 = v34;
        *this = (int)v30;
        this[1] = v26;
LABEL_68:
        v28 = 1;
LABEL_69:
        if ( *((char *)this + 548) >= 0 || *this != this[133] )
          return !v28;
        qmemcpy(this + 66, this, 0x108u);
        return 1;
      case 12:
        goto LABEL_62;
      case 13:
        this[2 * *(_DWORD *)(v3 + 20) + 2] = *this;
        goto LABEL_63;
      case 14:
        v17 = *(_DWORD *)(v3 + 20);
        if ( *((_BYTE *)this + 553) || *(_DWORD *)(v17 + 20) )
        {
          v18 = *this;
          this[1] |= 1 << *(_DWORD *)(v17 + 20);
          this[2 * *(_DWORD *)(v17 + 20) + 3] = v18;
        }
        goto LABEL_63;
      case 15:
        v19 = *(_DWORD *)(v3 + 20);
        if ( ((1 << v19) & this[1]) == 0 )
          goto LABEL_63;
        v20 = (unsigned __int16 *)this[2 * v19 + 2];
        v21 = *this;
        v30 = (char *)this[2 * v19 + 3];
        if ( v20 != (unsigned __int16 *)v30 )
        {
          v21 = *sub_410B40(
                   this[136],
                   (int)(this + 139),
                   (this[137] & 0x80) != 0,
                   &v32,
                   *this,
                   (unsigned __int16 *)this[133],
                   v20,
                   (unsigned __int16 *)v30);
          if ( v21 == *this )
            goto LABEL_68;
        }
        *this = v21;
        goto LABEL_63;
      case 16:
        if ( !sub_410680(v3, (int)this, a3) )
          v28 = 1;
        goto LABEL_62;
      case 18:
        if ( !sub_410720(this, (_DWORD *)v3, (*(_DWORD *)(v3 + 8) & 2) != 0, a3) )
          v28 = 1;
        goto LABEL_62;
      case 19:
        if ( a3 > 0 )
        {
          v22 = *this;
          v27 = *(_DWORD *)(v3 + 12);
          v33 = this[1];
          v23 = sub_40F6C0(this, v27, a3);
          v24 = v33;
          v28 = v23 == 0;
          *this = v22;
          this[1] = v24;
        }
        goto LABEL_62;
      case 21:
        if ( (this[137] & 0x2020) != 0 && this[132] == *this || *((_BYTE *)this + 568) && *this != this[133] )
        {
          v28 = 1;
        }
        else if ( !*((_BYTE *)this + 552) || sub_410AC0((int)this) )
        {
          qmemcpy(this + 66, this, 0x108u);
          *((_BYTE *)this + 552) = 1;
        }
LABEL_62:
        v3 = 0;
        goto LABEL_63;
      default:
        v30 = "corrupted regex pattern";
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v30);
        pExceptionObject[0] = (int)&std::logic_error::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVlogic_error_std__);
    }
  }
}
// 4BDA10: using guessed type void *std::logic_error::`vftable';

//----- (0040FB50) --------------------------------------------------------
_DWORD *__usercall sub_40FB50@<eax>(
        unsigned __int16 *a1@<eax>,
        __int16 a2@<dx>,
        unsigned __int16 *a3@<ecx>,
        _DWORD *a4@<esi>,
        int a5,
        unsigned __int16 *a6,
        int a7,
        char a8)
{
  int v9; // [esp+Ch] [ebp-4h] BYREF

  *a4 = a6;
  if ( (a2 & 0x800) != 0 )
  {
    *a4 = *sub_410BE0(a1, a3, &v9, a5, a6, a7, a8);
    return a4;
  }
  else
  {
    if ( (a2 & 0x100) != 0 )
    {
      *a4 = *sub_410C60(&v9, a5, a6, a1, a3, a7, a8);
    }
    else
    {
      LOBYTE(v9) = 0;
      *a4 = *sub_410E20((__int16 *)a1, &v9, a5, a6, (__int16 *)a3, v9, a8);
    }
    return a4;
  }
}

//----- (0040FBE0) --------------------------------------------------------
__int16 **__cdecl sub_40FBE0(__int16 **a1, __int16 *a2, __int16 *a3, unsigned int *a4)
{
  unsigned int *v4; // ecx
  int v5; // edi
  int v6; // eax
  unsigned int v7; // ebx
  __int16 *v8; // esi
  unsigned int v9; // edx
  _WORD *v10; // ecx
  __int16 v11; // di
  __int16 *v12; // edx
  __int16 **result; // eax
  int v14; // [esp+Ch] [ebp-4h]

  v4 = a4;
  if ( a4 )
  {
    while ( 1 )
    {
      v5 = v4[2];
      v6 = 0;
      v14 = v5;
      if ( v5 > 0 )
        break;
LABEL_13:
      a4 = (unsigned int *)v4[4];
      if ( !a4 )
        goto LABEL_14;
      v4 = (unsigned int *)v4[4];
    }
    v7 = *v4;
    while ( 1 )
    {
      v8 = a2;
      v9 = 0;
      if ( v7 )
      {
        v10 = (_WORD *)(v4[3] + 2 * v6);
        do
        {
          v11 = *v8++;
          if ( v11 != *v10 )
            break;
          ++v9;
          ++v10;
        }
        while ( v9 < v7 );
        v4 = a4;
        v5 = v14;
      }
      v12 = a3;
      if ( v8 == a3 )
        break;
      v6 += v7;
      if ( v6 >= v5 )
        goto LABEL_13;
    }
  }
  else
  {
LABEL_14:
    v12 = a2;
  }
  result = a1;
  *a1 = v12;
  return result;
}

//----- (0040FC50) --------------------------------------------------------
char __usercall sub_40FC50@<al>(int a1@<ecx>, unsigned __int16 a2@<si>)
{
  int v2; // edx
  int v3; // eax
  unsigned __int16 *i; // ecx

  v2 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  if ( v2 <= 0 )
    return 0;
  for ( i = *(unsigned __int16 **)(a1 + 8); *i > a2 || a2 > i[1]; i += 2 )
  {
    v3 += 2;
    if ( v3 >= v2 )
      return 0;
  }
  return 1;
}

//----- (0040FC80) --------------------------------------------------------
char __usercall sub_40FC80@<al>(int *a1@<edx>, void *a2@<ecx>, unsigned __int16 a3)
{
  int *v3; // ebx
  _DWORD *v4; // eax
  void **v5; // ecx
  int v6; // ecx
  void **v7; // eax
  void **v8; // esi
  void **v9; // eax
  unsigned int v10; // edx
  void **v11; // ecx
  int v12; // eax
  int v15; // [esp+18h] [ebp-6Ch]
  int *v16; // [esp+1Ch] [ebp-68h]
  void *v17[5]; // [esp+20h] [ebp-64h] BYREF
  unsigned int v18; // [esp+34h] [ebp-50h]
  void *v19[4]; // [esp+3Ch] [ebp-48h] BYREF
  unsigned int v20; // [esp+4Ch] [ebp-38h]
  unsigned int v21; // [esp+50h] [ebp-34h]
  void *v22[4]; // [esp+58h] [ebp-2Ch] BYREF
  unsigned int v23; // [esp+68h] [ebp-1Ch]
  unsigned int v24; // [esp+6Ch] [ebp-18h]
  int v25; // [esp+80h] [ebp-4h]

  v3 = a1;
  v16 = a1;
  v24 = 7;
  v23 = 0;
  LOWORD(v22[0]) = 0;
  v25 = 1;
  v21 = 7;
  v19[0] = (void *)a3;
  v20 = 1;
  v4 = sub_410EA0(a2, v17, (int)v19, (int)v19 + 2);
  LOBYTE(v25) = 2;
  sub_40AF70(v19, v4);
  LOBYTE(v25) = 1;
  if ( v18 >= 8 )
    operator delete(v17[0]);
  if ( !v3 )
  {
LABEL_33:
    if ( v21 >= 8 )
      operator delete(v19[0]);
    v21 = 7;
    v20 = 0;
    LOWORD(v19[0]) = 0;
    if ( v24 >= 8 )
      operator delete(v22[0]);
    return 0;
  }
  while ( 1 )
  {
    v15 = 0;
    if ( v3[2] > 0 )
      break;
LABEL_32:
    v3 = (int *)v3[4];
    v16 = v3;
    if ( !v3 )
      goto LABEL_33;
  }
  while ( 1 )
  {
    sub_4094F0(v22, v3[3] + 2 * v15, (void *)(v3[3] + 2 * v15), *v3);
    v5 = (void **)v22[0];
    if ( v24 < 8 )
      v5 = v22;
    v6 = (int)v5 + 2 * v23;
    v7 = (void **)v22[0];
    if ( v24 < 8 )
      v7 = v22;
    v8 = (void **)sub_410EA0(a2, v17, (int)v7, v6);
    if ( v22 != v8 )
    {
      if ( v24 >= 8 )
        operator delete(v22[0]);
      v24 = 7;
      v23 = 0;
      LOWORD(v22[0]) = 0;
      if ( (unsigned int)v8[5] >= 8 )
      {
        v22[0] = *v8;
        *v8 = 0;
      }
      else
      {
        memcpy(v22, v8, 2 * (_DWORD)v8[4] + 2);
      }
      v23 = (unsigned int)v8[4];
      v24 = (unsigned int)v8[5];
      v8[5] = (void *)7;
      v8[4] = 0;
      *(_WORD *)v8 = 0;
    }
    LOBYTE(v25) = 1;
    if ( v18 >= 8 )
      operator delete(v17[0]);
    v9 = (void **)v19[0];
    if ( v21 < 8 )
      v9 = v19;
    v10 = v23;
    if ( v23 >= v20 )
      v10 = v20;
    v11 = (void **)v22[0];
    if ( v24 < 8 )
      v11 = v22;
    if ( v10 )
      break;
LABEL_28:
    if ( v23 >= v20 )
    {
      v12 = v23 != v20;
      goto LABEL_30;
    }
LABEL_31:
    v15 += *v3;
    if ( v15 >= v3[2] )
      goto LABEL_32;
  }
  while ( *(_WORD *)v11 == *(_WORD *)v9 )
  {
    v11 = (void **)((char *)v11 + 2);
    v9 = (void **)((char *)v9 + 2);
    if ( !--v10 )
    {
      v3 = v16;
      goto LABEL_28;
    }
  }
  v12 = *(_WORD *)v11 < *(_WORD *)v9 ? -1 : 1;
  v3 = v16;
LABEL_30:
  if ( v12 )
    goto LABEL_31;
  if ( v21 >= 8 )
    operator delete(v19[0]);
  v21 = 7;
  v20 = 0;
  LOWORD(v19[0]) = 0;
  if ( v24 >= 8 )
    operator delete(v22[0]);
  return 1;
}
// 40FED8: conditional instruction was optimized away because eax.4 is in (==1|==FFFFFFFF)

//----- (0040FF30) --------------------------------------------------------
BOOL __fastcall sub_40FF30(int a1, int a2)
{
  unsigned __int16 *v2; // eax
  int v3; // ecx
  int v4; // eax
  BOOL result; // eax

  v2 = (unsigned __int16 *)(*(_DWORD *)a2 + 2);
  result = 1;
  if ( v2 == *(unsigned __int16 **)(a2 + 8) || (*(_BYTE *)(a2 + 68) & 8) != 0 || (v3 = *v2, v3 != 40) && v3 != 41 )
  {
    if ( (*(_BYTE *)(a2 + 68) & 0x10) != 0 )
      return 0;
    v4 = *v2;
    if ( v4 != 123 && v4 != 125 )
      return 0;
  }
  return result;
}

//----- (0040FF70) --------------------------------------------------------
int __usercall sub_40FF70@<eax>(int a1@<eax>)
{
  unsigned __int16 *v2; // eax
  int v3; // ecx
  unsigned __int16 *v4; // eax

  v2 = *(unsigned __int16 **)a1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v2 != (unsigned __int16 *)v3 )
  {
    if ( *v2 == 92 )
    {
      if ( (v4 = v2 + 1, v4 != (unsigned __int16 *)v3)
        && (*(_BYTE *)(a1 + 68) & 8) == 0
        && ((v3 = *v4, v3 == 40) || v3 == 41)
        || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v3 = *v4, v3 == 123) || v3 == 125) )
      {
        *(_DWORD *)a1 = v4;
      }
    }
    *(_DWORD *)a1 += 2;
  }
  return sub_40EAA0(v3, (unsigned __int16 **)a1);
}

//----- (0040FFC0) --------------------------------------------------------
char __usercall sub_40FFC0@<al>(int a1@<eax>)
{
  char result; // al
  int v3; // ecx
  _DWORD *v4; // eax
  int v5; // ecx
  unsigned __int16 *v6; // eax
  int v7; // ecx
  unsigned __int16 *v8; // eax
  unsigned __int16 *v9; // eax
  int v10; // ecx
  unsigned __int16 *v11; // eax
  unsigned __int16 *v12; // eax
  int v13; // ecx
  unsigned __int16 *v14; // eax
  unsigned __int16 *v15; // eax
  unsigned __int16 *v16; // eax
  char v17; // bl

  result = 0;
  if ( *(_DWORD *)(a1 + 64) != 0xFFFF )
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 64);
      if ( v3 == 124 )
        return result;
      if ( v3 == 41 )
      {
        if ( *(_DWORD *)(a1 + 16) )
          return result;
        if ( (*(_DWORD *)(a1 + 68) & 0x10000000) == 0 )
          std::tr1::_Xbad(5);
      }
      if ( v3 == 46 )
        break;
      switch ( v3 )
      {
        case '\\':
          v9 = *(unsigned __int16 **)a1;
          v10 = *(_DWORD *)(a1 + 8);
          if ( *(_DWORD *)a1 != v10 )
          {
            if ( *v9 == 92 )
            {
              if ( (v11 = v9 + 1, v11 != (unsigned __int16 *)v10)
                && (*(_BYTE *)(a1 + 68) & 8) == 0
                && ((v10 = *v11, v10 == 40) || v10 == 41)
                || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v10 = *v11, v10 == 123) || v10 == 125) )
              {
                *(_DWORD *)a1 = v11;
              }
            }
            *(_DWORD *)a1 += 2;
          }
          sub_40EAA0(v10, (unsigned __int16 **)a1);
          if ( (*(_DWORD *)(a1 + 68) & 0x80) != 0 && *(_WORD *)(a1 + 62) == 98 )
          {
            sub_4113E0(a1 + 24);
            sub_40FF70(a1);
          }
          else
          {
            if ( (*(_DWORD *)(a1 + 68) & 0x80) == 0 || *(_WORD *)(a1 + 62) != 66 )
            {
              sub_411080(a1);
              goto LABEL_72;
            }
            sub_4113E0(a1 + 24);
            *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8) ^= 1u;
            sub_40FF70(a1);
          }
          break;
        case '[':
          v12 = *(unsigned __int16 **)a1;
          v13 = *(_DWORD *)(a1 + 8);
          if ( *(_DWORD *)a1 != v13 )
          {
            if ( *v12 == 92 )
            {
              if ( (v14 = v12 + 1, v14 != (unsigned __int16 *)v13)
                && (*(_BYTE *)(a1 + 68) & 8) == 0
                && ((v13 = *v14, v13 == 40) || v13 == 41)
                || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v13 = *v14, v13 == 123) || v13 == 125) )
              {
                *(_DWORD *)a1 = v14;
              }
            }
            *(_DWORD *)a1 += 2;
          }
          sub_40EAA0(v13, (unsigned __int16 **)a1);
          sub_411010((_DWORD *)a1);
          if ( *(_DWORD *)(a1 + 64) != 93 )
            std::tr1::_Xbad(4);
          v15 = *(unsigned __int16 **)a1;
          v7 = *(_DWORD *)(a1 + 8);
          if ( *(_DWORD *)a1 != v7 )
          {
            if ( *v15 == 92 )
            {
              if ( (v16 = v15 + 1, v16 != (unsigned __int16 *)v7)
                && (*(_BYTE *)(a1 + 68) & 8) == 0
                && ((v7 = *v16, v7 == 40) || v7 == 41)
                || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v7 = *v16, v7 == 123) || v7 == 125) )
              {
                *(_DWORD *)a1 = v16;
              }
            }
            *(_DWORD *)a1 += 2;
          }
          goto LABEL_24;
        case '(':
          sub_40FF70(a1);
          v17 = sub_411150((_DWORD *)a1);
          sub_410FA0(a1, 5, 41);
          if ( v17 )
            goto LABEL_72;
          break;
        case '^':
          sub_411340(a1 + 24);
          sub_40FF70(a1);
          break;
        case '$':
          sub_411390(a1 + 24);
          sub_40FF70(a1);
          break;
        case '*':
        case '+':
        case '?':
        case '{':
          std::tr1::_Xbad(10);
        default:
          if ( v3 == 125 && (*(_DWORD *)(a1 + 68) & 0x10000000) == 0 )
            std::tr1::_Xbad(6);
          if ( v3 == 93 && (*(_DWORD *)(a1 + 68) & 0x10000000) == 0 )
            std::tr1::_Xbad(4);
          sub_411430((_DWORD *)(a1 + 24), *(unsigned __int16 *)(a1 + 62));
          sub_40FF70(a1);
          goto LABEL_72;
      }
LABEL_73:
      result = 1;
      if ( *(_DWORD *)(a1 + 64) == 0xFFFF )
        return result;
    }
    v4 = operator new(0x14u);
    if ( v4 )
    {
      *v4 = &std::tr1::_Node_base::`vftable';
      v4[1] = 5;
      v4[2] = 0;
      v4[3] = 0;
      v4[4] = 0;
    }
    else
    {
      v4 = 0;
    }
    v4[4] = *(_DWORD *)(a1 + 28);
    v5 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 12);
    if ( v5 )
    {
      v4[3] = v5;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 28) + 12) + 16) = v4;
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 12) = v4;
    *(_DWORD *)(a1 + 28) = v4;
    v6 = *(unsigned __int16 **)a1;
    v7 = *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)a1 != v7 )
    {
      if ( *v6 == 92 )
      {
        if ( (v8 = v6 + 1, v8 != (unsigned __int16 *)v7)
          && (*(_BYTE *)(a1 + 68) & 8) == 0
          && ((v7 = *v8, v7 == 40) || v7 == 41)
          || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v7 = *v8, v7 == 123) || v7 == 125) )
        {
          *(_DWORD *)a1 = v8;
        }
      }
      *(_DWORD *)a1 += 2;
    }
LABEL_24:
    sub_40EAA0(v7, (unsigned __int16 **)a1);
LABEL_72:
    sub_411200((unsigned __int16 **)a1);
    goto LABEL_73;
  }
  return result;
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (004102E0) --------------------------------------------------------
BOOL __usercall sub_4102E0@<eax>(int a1@<eax>)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  BOOL result; // eax

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(v1 + 4);
  result = 1;
  if ( v2 != 20 && v2 != 8 && v2 != 13 )
  {
    if ( v2 != 2 )
      return 0;
    v3 = *(_DWORD *)(*(_DWORD *)(v1 + 16) + 4);
    if ( v3 != 20 && v3 != 8 && v3 != 13 )
      return 0;
  }
  return result;
}

//----- (00410320) --------------------------------------------------------
_DWORD *__usercall sub_410320@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = operator new(0x14u);
  if ( result )
  {
    *result = &std::tr1::_Node_base::`vftable';
    result[1] = 8;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (00410370) --------------------------------------------------------
_DWORD *__userpurge sub_410370@<eax>(int a1@<edi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // eax
  _DWORD *v5; // eax
  int v6; // ecx

  v2 = operator new(0x14u);
  if ( v2 )
  {
    v2[1] = 17;
    v2[2] = 0;
    v2[3] = 0;
    v2[4] = 0;
    *v2 = &std::tr1::_Node_endif::`vftable';
    v3 = v2;
  }
  else
  {
    v3 = 0;
  }
  v3[4] = *(_DWORD *)(a1 + 4);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v4 )
  {
    v3[3] = v4;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = v3;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = v3;
  *(_DWORD *)(a1 + 4) = v3;
  v5 = operator new(0x1Cu);
  if ( v5 )
  {
    v5[1] = 16;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    *v5 = &std::tr1::_Node_if::`vftable';
    v5[5] = v3;
    v5[6] = 0;
  }
  else
  {
    v5 = 0;
  }
  v6 = *(_DWORD *)(a2 + 12);
  v5[4] = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(*(_DWORD *)(v6 + 16) + 12) = v5;
  v5[3] = v6;
  *(_DWORD *)(v6 + 16) = v5;
  return v3;
}
// 4CBF8C: using guessed type void *std::tr1::_Node_endif::`vftable';
// 4CBF94: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (00410420) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_410420(int *a1)
{
  int v1; // ebx
  int *v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF7F0;
  v13 = (struct std::locale::facet *)dword_4EF7F0;
  if ( !dword_4F2490 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4F2490 )
      dword_4F2490 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4F2490;
  v4 = *a1;
  if ( (unsigned int)dword_4F2490 >= *(_DWORD *)(*a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4F2490);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_410580((_Collvec **)&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF7F0 = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF7F0: using guessed type int dword_4EF7F0;
// 4F2490: using guessed type int dword_4F2490;
// 410420: using guessed type char var_18[4];
// 410420: using guessed type char var_14[4];

//----- (00410560) --------------------------------------------------------
std::exception *__thiscall sub_410560(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 4BDA10: using guessed type void *std::logic_error::`vftable';

//----- (00410580) --------------------------------------------------------
int __cdecl sub_410580(_Collvec **a1, void *a2)
{
  int v2; // ebx
  _Collvec *v3; // esi
  char *v4; // eax
  bool v5; // cf
  char v7[36]; // [esp+10h] [ebp-5Ch] BYREF
  void *v8; // [esp+34h] [ebp-38h]
  _Collvec **v9; // [esp+38h] [ebp-34h]
  int v10; // [esp+3Ch] [ebp-30h]
  void *v11[7]; // [esp+40h] [ebp-2Ch] BYREF
  int v12; // [esp+68h] [ebp-4h]

  v2 = 0;
  v9 = a1;
  v10 = 0;
  if ( a1 && !*a1 )
  {
    v3 = (_Collvec *)operator new(0x10u);
    v8 = v3;
    v12 = 0;
    if ( v3 )
    {
      v4 = (char *)sub_413350(a2, v11);
      LOBYTE(v12) = 1;
      v5 = *((_DWORD *)v4 + 5) < 0x10u;
      v10 = 1;
      if ( !v5 )
        v4 = *(char **)v4;
      sub_4086C0((struct std::_Locinfo *)v7, v4);
      v2 = 3;
      v3->_LocaleName = 0;
      v3->_Page = (unsigned int)&std::collate<wchar_t>::`vftable';
      v3[1] = _Getcoll();
    }
    else
    {
      v3 = 0;
    }
    v12 = 2;
    *v9 = v3;
    if ( (v2 & 2) != 0 )
    {
      v2 &= ~2u;
      v10 = v2;
      sub_408790((std::_Lockit *)v7);
    }
    if ( (v2 & 1) != 0 && v11[5] >= (void *)0x10 )
      operator delete(v11[0]);
  }
  return 1;
}
// 4BDE50: using guessed type void *std::collate<wchar_t>::`vftable';

//----- (00410680) --------------------------------------------------------
char __userpurge sub_410680@<al>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int *v9; // eax
  int v10; // ecx
  int v11; // edx
  char result; // al
  int v13; // [esp+8h] [ebp-1Ch] BYREF
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+10h] [ebp-14h] BYREF
  int v16; // [esp+14h] [ebp-10h]
  int v17; // [esp+18h] [ebp-Ch]
  char v18; // [esp+1Fh] [ebp-5h]

  v3 = a1;
  v5 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v4 = v13;
  v14 = v5;
  v15 = v13;
  v16 = v5;
  v18 = 0;
  v17 = -1;
  if ( a1 )
  {
    do
    {
      v6 = v14;
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 4) = v6;
      if ( sub_40F6C0((int *)a2, *(_DWORD *)(v3 + 12), a3) )
      {
        if ( !*(_BYTE *)(a2 + 555) )
          return 1;
        v7 = (*(_DWORD *)a2 - v4) >> 1;
        if ( v17 < v7 )
        {
          v8 = *(_DWORD *)(a2 + 4);
          v15 = *(_DWORD *)a2;
          v16 = v8;
          v17 = v7;
        }
        v18 = 1;
      }
      v3 = *(_DWORD *)(v3 + 24);
    }
    while ( v3 );
    v9 = &v15;
    if ( v18 )
      goto LABEL_10;
  }
  v9 = &v13;
LABEL_10:
  v10 = *v9;
  v11 = v9[1];
  result = v18;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 4) = v11;
  return result;
}

//----- (00410720) --------------------------------------------------------
char __userpurge sub_410720@<al>(int *a1@<ebx>, _DWORD *a2, char a3, int a4)
{
  bool v4; // cc
  int v5; // ecx
  int v6; // edi
  int v7; // esi
  int v8; // eax
  char result; // al
  int v10; // edx
  int *v11; // edi
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // esi
  char v18; // cl
  int *v19; // eax
  int v20; // edx
  int v21; // [esp-8h] [ebp-144h]
  int v22; // [esp+Ch] [ebp-130h]
  int v23; // [esp+10h] [ebp-12Ch] BYREF
  int v24; // [esp+14h] [ebp-128h]
  int v25; // [esp+18h] [ebp-124h]
  int *v26; // [esp+1Ch] [ebp-120h]
  int v27; // [esp+20h] [ebp-11Ch]
  char v28; // [esp+27h] [ebp-115h]
  char v29[268]; // [esp+28h] [ebp-114h] BYREF

  v4 = a2[6] <= 0;
  v5 = a1[1];
  v6 = *a1;
  v26 = a2;
  v23 = v6;
  v24 = v5;
  v27 = 0;
  if ( v4 )
  {
LABEL_5:
    v8 = *a1;
    qmemcpy(v29, a1, 0x108u);
    v25 = v8;
    v21 = *(_DWORD *)(v26[5] + 12);
    v28 = 0;
    if ( !sub_40F6C0(a1, v21, a4) )
      goto LABEL_10;
    if ( a3 )
    {
      qmemcpy(v29, a1, 0x108u);
      v28 = 1;
LABEL_10:
      while ( 1 )
      {
        v11 = v26;
        v12 = v26[7];
        if ( v12 != -1 )
        {
          v13 = v27++;
          if ( v13 >= v12 )
            break;
        }
        v14 = v24;
        *a1 = v25;
        a1[1] = v14;
        v15 = v11[7];
        if ( v15 < 0 || v15 > v27 )
          v16 = -1;
        else
          v16 = 1;
        if ( !sub_40F6C0(a1, v11[3], v16) )
          break;
        v17 = *a1;
        v22 = *a1;
        if ( sub_40F6C0(a1, *(_DWORD *)(v11[5] + 12), a4) )
        {
          if ( !a3 )
            return 1;
          qmemcpy(v29, a1, 0x108u);
          v17 = v22;
          v28 = 1;
        }
        if ( v25 == v17 )
          break;
        v25 = v17;
      }
      v18 = v28;
      v19 = (int *)v29;
      if ( !v28 )
        v19 = &v23;
      v20 = *v19;
      a1[1] = v19[1];
      result = v18;
      *a1 = v20;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( !sub_40F6C0(a1, v26[3], -1) )
        break;
      if ( v7 != *a1 && ++v27 < v26[6] )
        continue;
      goto LABEL_5;
    }
    v10 = v24;
    *a1 = v6;
    a1[1] = v10;
    return 0;
  }
  return result;
}

//----- (00410910) --------------------------------------------------------
char __stdcall sub_410910(int *a1, int a2)
{
  int *v2; // esi
  int v3; // edi
  struct std::locale::facet *v4; // eax
  int v5; // ebx
  __int16 *v6; // edi
  unsigned int *v7; // eax
  __int16 *v8; // eax
  char v9; // al
  unsigned __int16 v10; // di
  int v11; // ecx
  int v12; // edx
  int v13; // eax
  unsigned __int16 *v14; // ecx
  int v15; // edi
  bool v16; // zf
  int v17; // ecx
  _WORD *v18; // eax
  _WORD *i; // ecx
  __int16 v20; // di
  int *v21; // edx
  int v23; // [esp+10h] [ebp-8h]
  int v24; // [esp+14h] [ebp-4h]

  v2 = a1;
  v3 = *(unsigned __int16 *)*a1;
  v24 = v3;
  if ( (a1[136] & 0x100) != 0 )
  {
    v4 = sub_40F1E0((int)(a1 + 139));
    v24 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v4 + 24))(v4, v3);
  }
  v5 = a2;
  v6 = (__int16 *)*a1;
  v7 = *(unsigned int **)(a2 + 20);
  v23 = *a1 + 2;
  if ( v7 )
  {
    v8 = *sub_40FBE0((__int16 **)&a2, v6, (__int16 *)a1[133], v7);
    if ( v8 != v6 )
    {
      v23 = (int)v8;
      v9 = 1;
      goto LABEL_33;
    }
  }
  if ( *(_DWORD *)(v5 + 32) )
  {
    v10 = (a1[136] & 0x800) != 0 ? sub_40EFA0(a1 + 139, v24) : v24;
    v11 = *(_DWORD *)(v5 + 32);
    v12 = *(_DWORD *)(v11 + 4);
    v13 = 0;
    if ( v12 > 0 )
    {
      v14 = *(unsigned __int16 **)(v11 + 8);
      while ( *v14 > v10 || v10 > v14[1] )
      {
        v13 += 2;
        v14 += 2;
        if ( v13 >= v12 )
          goto LABEL_15;
      }
      goto LABEL_31;
    }
  }
LABEL_15:
  if ( dword_4EF7EC > (unsigned __int16)v24 || (unsigned __int16)v24 >= 0x100u )
  {
    if ( *(_DWORD *)(v5 + 28) )
    {
      v17 = *(_DWORD *)(v5 + 28);
      v18 = *(_WORD **)(v17 + 8);
      for ( i = &v18[*(_DWORD *)(v17 + 4)]; v18 != i; ++v18 )
      {
        if ( *v18 == (_WORD)v24 )
          break;
      }
      if ( v18 != (_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 28) + 8) + 2 * *(_DWORD *)(*(_DWORD *)(v5 + 28) + 4)) )
      {
        v9 = 1;
        goto LABEL_33;
      }
    }
    v20 = *(_WORD *)(v5 + 36);
    if ( v20 )
    {
      v2 = a1;
      if ( (unsigned __int8)sub_40F010((int)(a1 + 139), v20, v24) )
      {
        v9 = 1;
        goto LABEL_33;
      }
    }
    v21 = *(int **)(v5 + 40);
    if ( !v21 )
      goto LABEL_32;
    v16 = sub_40FC80(v21, v2 + 139, v24) == 0;
  }
  else
  {
    v15 = *(_DWORD *)(v5 + 24);
    if ( !v15 )
      goto LABEL_32;
    v16 = ((unsigned __int8)(1 << (v24 & 7)) & *(_BYTE *)(((unsigned __int16)v24 >> 3) + v15)) == 0;
  }
  if ( !v16 )
  {
LABEL_31:
    v9 = 1;
    goto LABEL_33;
  }
LABEL_32:
  v9 = 0;
LABEL_33:
  if ( v9 == (*(_BYTE *)(v5 + 8) & 1) )
    return 0;
  *v2 = v23;
  return 1;
}
// 4EF7EC: using guessed type int dword_4EF7EC;

//----- (00410AC0) --------------------------------------------------------
bool __thiscall sub_410AC0(int this)
{
  int v1; // eax
  int v2; // edx
  _DWORD *i; // esi
  int v5; // edx
  int v6; // eax

  v1 = 0;
  v2 = 1;
  if ( !*(_BYTE *)(this + 554) )
    return 0;
  for ( i = (_DWORD *)(this + 8); ; i += 2 )
  {
    if ( (v2 & *(_DWORD *)(this + 268)) != 0 && (v2 & *(_DWORD *)(this + 4)) != 0 )
    {
      if ( i[66] != *i )
      {
        v5 = *(_DWORD *)(this + 8 * v1 + 272);
        v6 = *(_DWORD *)(this + 8 * v1 + 8);
        return (int)((v5 - *(_DWORD *)(this + 528)) & 0xFFFFFFFE) < (int)((v6 - *(_DWORD *)(this + 528)) & 0xFFFFFFFE);
      }
      if ( i[67] != i[1] )
        break;
    }
    ++v1;
    v2 *= 2;
    if ( v1 >= *(unsigned __int8 *)(this + 554) )
      return 0;
  }
  v5 = *(_DWORD *)(this + 8 * v1 + 276);
  v6 = *(_DWORD *)(this + 8 * v1 + 12);
  return (int)((v5 - *(_DWORD *)(this + 528)) & 0xFFFFFFFE) < (int)((v6 - *(_DWORD *)(this + 528)) & 0xFFFFFFFE);
}

//----- (00410B40) --------------------------------------------------------
_DWORD *__usercall sub_410B40@<eax>(
        __int16 a1@<ax>,
        int a2@<edx>,
        char a3@<cl>,
        _DWORD *a4@<esi>,
        int a5,
        unsigned __int16 *a6,
        unsigned __int16 *a7,
        unsigned __int16 *a8)
{
  int v9; // [esp+4h] [ebp-4h] BYREF

  *a4 = a6;
  if ( (a1 & 0x800) != 0 )
  {
    *a4 = *sub_4115E0(&v9, a5, a6, a7, a8, a2, a3);
    return a4;
  }
  else
  {
    if ( (a1 & 0x100) != 0 )
    {
      *a4 = *sub_411670(&v9, a5, a6, a7, a8, a2, a3);
    }
    else
    {
      LOBYTE(v9) = 0;
      *a4 = *sub_411830(&v9, a5, a6, a7, a8, v9, a3);
    }
    return a4;
  }
}

//----- (00410BE0) --------------------------------------------------------
int *__usercall sub_410BE0@<eax>(
        unsigned __int16 *a1@<eax>,
        unsigned __int16 *a2@<ebx>,
        int *a3,
        int a4,
        unsigned __int16 *a5,
        int a6,
        char a7)
{
  unsigned __int16 *v7; // ecx
  unsigned __int16 *v9; // eax
  int v10; // edi
  unsigned __int16 v11; // cx
  int *result; // eax
  bool v13; // zf
  int *v14; // eax
  int v15; // ecx
  int v16; // [esp+8h] [ebp-4h] BYREF

  v7 = a5;
  v9 = (unsigned __int16 *)a4;
  v10 = a4;
  v16 = a4;
  if ( (unsigned __int16 *)a4 != a5 )
  {
    while ( a1 != a2 )
    {
      v11 = *a1;
      a4 = (int)(v9 + 1);
      ++a1;
      if ( !sub_411500(&a6, *v9, v11) )
      {
        result = a3;
        *a3 = v10;
        return result;
      }
      v9 = (unsigned __int16 *)a4;
      v7 = a5;
      if ( (unsigned __int16 *)a4 == a5 )
        goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_5:
  if ( a1 == a2 )
  {
LABEL_6:
    result = a3;
    *a3 = a4;
    return result;
  }
  if ( !a7 || (v13 = v9 == v7, v14 = &a4, !v13) )
    v14 = &v16;
  v15 = *v14;
  result = a3;
  *a3 = v15;
  return result;
}

//----- (00410C60) --------------------------------------------------------
int *__cdecl sub_410C60(
        int *a1,
        int a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        unsigned __int16 *a5,
        int a6,
        char a7)
{
  unsigned __int16 *v7; // eax
  unsigned __int16 *v8; // ecx
  bool v9; // zf
  struct std::locale::facet **v10; // ebx
  _DWORD *v11; // eax
  struct std::locale::facet *v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  struct std::locale::facet **v17; // ebx
  _DWORD *v18; // eax
  struct std::locale::facet *v19; // eax
  int v20; // edi
  int v21; // eax
  int v22; // esi
  void (__thiscall ***v23)(_DWORD, int); // esi
  __int16 v24; // ax
  int *v25; // eax
  int v26; // ecx
  int *result; // eax
  int v28; // [esp+14h] [ebp-28h]
  char v29[4]; // [esp+18h] [ebp-24h] BYREF
  int v30; // [esp+1Ch] [ebp-20h] BYREF
  int v31; // [esp+20h] [ebp-1Ch]
  char v32[4]; // [esp+24h] [ebp-18h] BYREF
  int v33; // [esp+28h] [ebp-14h] BYREF
  int v34; // [esp+2Ch] [ebp-10h] BYREF
  int v35; // [esp+38h] [ebp-4h]

  v7 = (unsigned __int16 *)a2;
  v8 = a3;
  v34 = a2;
  if ( (unsigned __int16 *)a2 == a3 )
  {
LABEL_19:
    if ( a4 != a5 )
    {
      if ( !a7 || (v9 = v7 == v8, v25 = &a2, !v9) )
        v25 = &v34;
      goto LABEL_25;
    }
  }
  else
  {
    while ( a4 != a5 )
    {
      v28 = *a4;
      a2 = (int)(v7 + 1);
      v9 = *(_DWORD *)(a6 + 4) == 0;
      v10 = (struct std::locale::facet **)(a6 + 4);
      v31 = *v7;
      if ( v9 )
      {
        v11 = sub_40F4D0(a6, &v33);
        v35 = 0;
        v12 = sub_408900((int)v11);
        v35 = -1;
        v13 = v33;
        *v10 = v12;
        if ( v13 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v32, 0);
          v14 = *(_DWORD *)(v13 + 4);
          if ( v14 && v14 != -1 )
            *(_DWORD *)(v13 + 4) = v14 - 1;
          v15 = -(*(_DWORD *)(v13 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v32);
          v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
          if ( v16 )
            (**v16)(v16, 1);
        }
      }
      v31 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v10 + 24))(*v10, v31);
      v17 = (struct std::locale::facet **)(a6 + 4);
      if ( !*(_DWORD *)(a6 + 4) )
      {
        v18 = sub_40F4D0(a6, &v30);
        v35 = 1;
        v19 = sub_408900((int)v18);
        v35 = -1;
        v20 = v30;
        *v17 = v19;
        if ( v20 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v29, 0);
          v21 = *(_DWORD *)(v20 + 4);
          if ( v21 && v21 != -1 )
            *(_DWORD *)(v20 + 4) = v21 - 1;
          v22 = -(*(_DWORD *)(v20 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v29);
          v23 = (void (__thiscall ***)(_DWORD, int))(v20 & v22);
          if ( v23 )
            (**v23)(v23, 1);
        }
      }
      v24 = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v17 + 24))(*v17, v28);
      ++a4;
      if ( (_WORD)v31 != v24 )
      {
        v26 = v34;
        goto LABEL_26;
      }
      v7 = (unsigned __int16 *)a2;
      v8 = a3;
      if ( (unsigned __int16 *)a2 == a3 )
        goto LABEL_19;
    }
  }
  v25 = &a2;
LABEL_25:
  v26 = *v25;
LABEL_26:
  result = a1;
  *a1 = v26;
  return result;
}
// 410C60: using guessed type char var_18[4];
// 410C60: using guessed type char var_24[4];

//----- (00410E20) --------------------------------------------------------
int *__usercall sub_410E20@<eax>(__int16 *a1@<edx>, int *a2, int a3, _WORD *a4, __int16 *a5, int a6, char a7)
{
  _WORD *v7; // ecx
  int v8; // ebx
  __int16 v9; // ax
  _WORD *v10; // esi
  int *result; // eax
  bool v12; // zf
  int *v13; // ecx
  int v14; // [esp+Ch] [ebp-4h] BYREF

  v7 = (_WORD *)a3;
  v8 = a3;
  v14 = a3;
  if ( (_WORD *)a3 != a4 )
  {
    while ( a1 != a5 )
    {
      v9 = *a1;
      v10 = v7++;
      a3 = (int)v7;
      ++a1;
      if ( *v10 != v9 )
      {
        result = a2;
        *a2 = v8;
        return result;
      }
      if ( v7 == a4 )
        goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_5:
  if ( a1 == a5 )
  {
LABEL_6:
    result = a2;
    *a2 = a3;
    return result;
  }
  if ( !a7 || (v12 = v7 == a4, v13 = &a3, !v12) )
    v13 = &v14;
  result = a2;
  *a2 = *v13;
  return result;
}

//----- (00410EA0) --------------------------------------------------------
_DWORD *__thiscall sub_410EA0(void *this, _DWORD *a2, int a3, int a4)
{
  _DWORD *result; // eax
  void *v6; // edi
  int v7; // esi
  struct std::locale::facet *v8; // eax
  struct std::locale::facet *v9; // eax
  void *v10; // eax
  void *v11; // esi
  void *v12; // [esp+14h] [ebp-48h] BYREF
  int v13; // [esp+18h] [ebp-44h]
  int v14; // [esp+1Ch] [ebp-40h]
  int v15; // [esp+24h] [ebp-38h]
  void *v16; // [esp+28h] [ebp-34h]
  void *v17[7]; // [esp+2Ch] [ebp-30h] BYREF
  int v18; // [esp+58h] [ebp-4h]

  result = a2;
  a2[5] = 7;
  a2[4] = 0;
  v16 = a2;
  *(_WORD *)a2 = 0;
  v18 = 0;
  v15 = 1;
  if ( a3 != a4 )
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    sub_411FB0(&v12, a3, a4, (int)v16);
    v18 = 1;
    v6 = v12;
    v7 = (v13 - (int)v12) >> 1;
    v8 = sub_40F1E0((int)this);
    (*(void (__thiscall **)(struct std::locale::facet *, void *, int))(*(_DWORD *)v8 + 20))(v8, v6, (int)v6 + 2 * v7);
    v9 = sub_40F130((int)this);
    v10 = (void *)sub_40F360((int)v6 + 2 * v7, (int)v9, (int)v17, (int)v6);
    LOBYTE(v18) = 2;
    v11 = v16;
    sub_40AF70(v16, v10);
    if ( v17[5] >= (void *)8 )
      operator delete(v17[0]);
    if ( v6 )
      operator delete(v6);
    return v11;
  }
  return result;
}

//----- (00410FA0) --------------------------------------------------------
int __userpurge sub_410FA0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  unsigned __int16 *v4; // eax
  int v5; // ecx
  unsigned __int16 *v6; // eax

  if ( *(_DWORD *)(a1 + 64) != a3 )
    std::tr1::_Xbad(a2);
  v4 = *(unsigned __int16 **)a1;
  v5 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 != v5 )
  {
    if ( *v4 == 92 )
    {
      if ( (v6 = v4 + 1, v6 != (unsigned __int16 *)v5)
        && (*(_BYTE *)(a1 + 68) & 8) == 0
        && ((v5 = *v6, v5 == 40) || v5 == 41)
        || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v5 = *v6, v5 == 123) || v5 == 125) )
      {
        *(_DWORD *)a1 = v6;
      }
    }
    *(_DWORD *)a1 += 2;
  }
  return sub_40EAA0(v5, (unsigned __int16 **)a1);
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411010) --------------------------------------------------------
_BYTE *__usercall sub_411010@<eax>(_DWORD *a1@<edi>)
{
  _DWORD *v1; // eax
  int v2; // esi
  _BYTE *result; // eax
  int v4; // eax
  unsigned __int16 *v5; // eax
  int v6; // ecx
  unsigned __int16 *v7; // eax
  int v8; // edi
  int v9; // eax
  __int16 v10; // ax
  void *v11; // ecx
  int v12; // eax
  int v13; // eax
  _DWORD *v14; // esi

  sub_411D50((int)(a1 + 6));
  if ( a1[16] == 94 )
  {
    *(_DWORD *)(a1[7] + 8) ^= 1u;
    sub_40FF70((int)a1);
  }
  if ( (a1[17] & 0x20000000) != 0 && a1[16] == 93 )
  {
    if ( dword_4EF7F4 <= 93 )
    {
      sub_4127F0(93, a1 + 6);
      sub_40FF70((int)a1);
      v1 = a1;
      goto LABEL_9;
    }
    sub_412870(a1 + 6, 93);
    sub_40FF70((int)a1);
  }
  v1 = a1;
LABEL_9:
  v2 = (int)v1;
  result = (_BYTE *)sub_4120F0((int)v1);
  if ( !result )
    return result;
  while ( result == (_BYTE *)2 )
  {
LABEL_38:
    result = (_BYTE *)sub_4120F0(v2);
    if ( !result )
      return result;
  }
  v4 = *(unsigned __int16 *)(v2 + 60);
  if ( !(_WORD)v4 && (*(_DWORD *)(v2 + 68) & 0x100000) == 0 )
    std::tr1::_Xbad(2);
  if ( *(_DWORD *)(v2 + 64) != 45 )
  {
    if ( dword_4EF7F4 > v4 || (unsigned __int16)v4 >= 0x100u )
      sub_412870((_DWORD *)(v2 + 24), *(unsigned __int16 *)(v2 + 60));
    else
      sub_4127F0(v4, (_DWORD *)(v2 + 24));
    goto LABEL_38;
  }
  v5 = *(unsigned __int16 **)v2;
  v6 = *(_DWORD *)(v2 + 8);
  if ( *(_DWORD *)v2 != v6 )
  {
    if ( *v5 == 92 )
    {
      if ( (v7 = v5 + 1, v7 != (unsigned __int16 *)v6)
        && (*(_BYTE *)(v2 + 68) & 8) == 0
        && ((v6 = *v7, v6 == 40) || v6 == 41)
        || (*(_BYTE *)(v2 + 68) & 0x10) == 0 && ((v6 = *v7, v6 == 123) || v6 == 125) )
      {
        *(_DWORD *)v2 = v7;
      }
    }
    *(_DWORD *)v2 += 2;
  }
  sub_40EAA0(v6, (unsigned __int16 **)v2);
  v8 = *(unsigned __int16 *)(v2 + 60);
  v9 = sub_4120F0(v2);
  if ( v9 )
  {
    if ( v9 == 2 )
      std::tr1::_Xbad(8);
    if ( (*(_DWORD *)(v2 + 56) & 0x800) != 0 )
    {
      v10 = sub_40EFA0(*(void **)(v2 + 52), *(unsigned __int16 *)(v2 + 60));
      v11 = *(void **)(v2 + 52);
      *(_WORD *)(v2 + 60) = v10;
      v8 = (unsigned __int16)sub_40EFA0(v11, v8);
    }
    if ( *(_WORD *)(v2 + 60) < (unsigned __int16)v8 )
      std::tr1::_Xbad(8);
    v12 = v2 + 24;
    LOWORD(v12) = *(_WORD *)(v2 + 60);
    sub_412560(v12, v8, (_DWORD *)(v2 + 24));
    goto LABEL_38;
  }
  v13 = *(unsigned __int16 *)(v2 + 60);
  v14 = (_DWORD *)(v2 + 24);
  if ( dword_4EF7F4 > v13 || (unsigned __int16)v13 >= 0x100u )
    sub_412870(v14, v13);
  else
    sub_4127F0(v13, v14);
  if ( dword_4EF7F4 > 45 )
    return (_BYTE *)sub_412870(v14, 45);
  else
    return sub_4127F0(45, v14);
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);
// 4EF7F4: using guessed type int dword_4EF7F4;

//----- (00411080) --------------------------------------------------------
char __usercall sub_411080@<al>(int a1@<eax>)
{
  unsigned int v2; // eax
  char result; // al

  if ( (*(_DWORD *)(a1 + 68) & 0x100) == 0 || sub_412020(0x7FFFFFFF, a1, 10) == 0x7FFFFFFF )
  {
    if ( sub_411AF0(a1) )
    {
      return sub_411430((_DWORD *)(a1 + 24), *(unsigned __int16 *)(a1 + 60));
    }
    else
    {
      if ( (*(_DWORD *)(a1 + 68) & 0x20000) == 0 )
        goto LABEL_16;
      result = sub_4118E0(a1, 1);
      if ( !result )
        goto LABEL_16;
    }
  }
  else
  {
    v2 = *(unsigned __int16 *)(a1 + 60);
    if ( !(_WORD)v2 )
    {
      if ( (*(_DWORD *)(a1 + 68) & 0x100000) != 0 )
        return sub_411430((_DWORD *)(a1 + 24), 0);
LABEL_16:
      std::tr1::_Xbad(2);
    }
    if ( (*(_DWORD *)(a1 + 68) & 0x200) != 0 && (unsigned __int16)v2 > 9u
      || *(_DWORD *)(a1 + 12) < v2
      || ((1 << v2) & *(_DWORD *)(a1 + 20)) == 0 )
    {
      std::tr1::_Xbad(3);
    }
    return (unsigned __int8)sub_411DC0(a1 + 24, v2);
  }
  return result;
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411150) --------------------------------------------------------
char __usercall sub_411150@<al>(_DWORD *a1@<eax>)
{
  int v2; // eax
  int v3; // edi

  v2 = a1[17];
  ++a1[4];
  if ( (v2 & 0x8000000) == 0 && a1[16] == 41 )
    std::tr1::_Xbad(5);
  if ( (v2 & 0x20) == 0 || a1[16] != 63 )
  {
    if ( (a1[14] & 0x200) == 0 )
    {
      sub_411C60((int)a1);
      --a1[4];
      return 1;
    }
LABEL_13:
    sub_411CB0(a1);
    --a1[4];
    return 1;
  }
  sub_40FF70((int)a1);
  v3 = a1[16];
  sub_40FF70((int)a1);
  switch ( v3 )
  {
    case ':':
      goto LABEL_13;
    case '!':
      sub_411D20(1, a1);
      --a1[4];
      return 0;
    case '=':
      sub_411D20(0, a1);
      --a1[4];
      return 0;
    default:
      std::tr1::_Xbad(14);
  }
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411200) --------------------------------------------------------
unsigned __int16 *__usercall sub_411200@<eax>(unsigned __int16 **a1@<eax>)
{
  unsigned __int16 *result; // eax
  int v3; // ebx
  int v4; // edi
  unsigned __int16 *v5; // eax
  unsigned __int16 *v6; // ecx
  unsigned __int16 *v7; // eax

  result = a1[16];
  v3 = 0;
  v4 = -1;
  if ( result == (unsigned __int16 *)42 )
    goto LABEL_19;
  if ( result != (unsigned __int16 *)43 )
  {
    if ( result == (unsigned __int16 *)63 )
    {
      v4 = 1;
      goto LABEL_19;
    }
    if ( result != (unsigned __int16 *)123 )
      return result;
    sub_40FF70((int)a1);
    if ( sub_412020(0x7FFFFFFF, (int)a1, 10) == 0x7FFFFFFF )
      std::tr1::_Xbad(7);
    v3 = *((unsigned __int16 *)a1 + 30);
    if ( a1[16] == (unsigned __int16 *)44 )
    {
      sub_40FF70((int)a1);
      if ( a1[16] == (unsigned __int16 *)125 )
      {
LABEL_16:
        if ( v4 == -1 || v4 >= v3 )
          goto LABEL_19;
LABEL_18:
        std::tr1::_Xbad(7);
      }
      if ( !sub_4118C0(a1) )
        std::tr1::_Xbad(7);
      v4 = *((unsigned __int16 *)a1 + 30);
    }
    else
    {
      v4 = *((unsigned __int16 *)a1 + 30);
    }
    if ( a1[16] != (unsigned __int16 *)125 )
      goto LABEL_18;
    goto LABEL_16;
  }
  v3 = 1;
LABEL_19:
  *((_DWORD *)a1[7] + 2) |= 4u;
  v5 = *a1;
  v6 = a1[2];
  if ( *a1 != v6 )
  {
    if ( *v5 == 92 )
    {
      if ( (v7 = v5 + 1, v7 != v6)
        && ((_BYTE)a1[17] & 8) == 0
        && ((v6 = (unsigned __int16 *)*v7, v6 == (unsigned __int16 *)40) || v6 == (unsigned __int16 *)41)
        || ((_BYTE)a1[17] & 0x10) == 0
        && ((v6 = (unsigned __int16 *)*v7, v6 == (unsigned __int16 *)123) || v6 == (unsigned __int16 *)125) )
      {
        *a1 = v7;
      }
    }
    ++*a1;
  }
  sub_40EAA0((int)v6, a1);
  if ( ((unsigned int)a1[17] & 0x400) == 0 || a1[16] != (unsigned __int16 *)63 )
    return (unsigned __int16 *)sub_411E20(a1 + 6, v3, v4, 1);
  sub_40FF70((int)a1);
  return (unsigned __int16 *)sub_411E20(a1 + 6, v3, v4, 0);
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411340) --------------------------------------------------------
_DWORD *__usercall sub_411340@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = operator new(0x14u);
  if ( result )
  {
    *result = &std::tr1::_Node_base::`vftable';
    result[1] = 2;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (00411390) --------------------------------------------------------
_DWORD *__usercall sub_411390@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = operator new(0x14u);
  if ( result )
  {
    *result = &std::tr1::_Node_base::`vftable';
    result[1] = 3;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (004113E0) --------------------------------------------------------
_DWORD *__usercall sub_4113E0@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = operator new(0x14u);
  if ( result )
  {
    *result = &std::tr1::_Node_base::`vftable';
    result[1] = 4;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (00411430) --------------------------------------------------------
int __userpurge sub_411430@<eax>(_DWORD *a1@<eax>, int a2)
{
  int v3; // eax
  int v4; // eax
  struct std::locale::facet *v5; // eax
  int v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // ebx
  void *v9; // eax
  int result; // eax

  v3 = a1[1];
  if ( *(_DWORD *)(v3 + 4) != 6 || (*(_BYTE *)(v3 + 8) & 4) != 0 )
    sub_411F20((int)a1);
  v4 = a1[3];
  if ( (v4 & 0x100) != 0 )
  {
    v5 = sub_40F1E0(a1[4]);
    LOWORD(a2) = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v5 + 24))(v5, a2);
  }
  else if ( (v4 & 0x800) != 0 )
  {
    LOWORD(a2) = sub_40EFA0((void *)a1[4], a2);
  }
  v6 = a1[1];
  v7 = *(_DWORD *)(v6 + 24);
  if ( *(_DWORD *)(v6 + 20) <= v7 )
  {
    v8 = v7 + 16;
    v9 = realloc(*(void **)(v6 + 28), 2 * (v7 + 16));
    if ( !v9 )
      unknown_libname_4();
    *(_DWORD *)(v6 + 28) = v9;
    *(_DWORD *)(v6 + 20) = v8;
  }
  result = *(_DWORD *)(v6 + 28);
  *(_WORD *)(result + 2 * (*(_DWORD *)(v6 + 24))++) = a2;
  return result;
}
// 427BF6: using guessed type void __noreturn unknown_libname_4(void);

//----- (004114E0) --------------------------------------------------------
int __usercall sub_4114E0@<eax>(int result@<eax>, int a2@<ecx>)
{
  for ( ; a2; result += 12 )
  {
    if ( result )
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
      *(_BYTE *)(result + 8) = 0;
    }
    --a2;
  }
  return result;
}

//----- (00411500) --------------------------------------------------------
BOOL __thiscall sub_411500(int *this, unsigned __int16 a2, unsigned __int16 a3)
{
  int v4; // ebx
  struct std::locale::facet *v5; // eax
  void **v6; // eax
  __int16 v7; // ax
  int v8; // ebx
  struct std::locale::facet *v9; // eax
  void **v10; // eax
  __int16 v11; // si
  __int16 v13; // [esp+Ch] [ebp-48h]
  int v14; // [esp+10h] [ebp-44h] BYREF
  int v15; // [esp+14h] [ebp-40h] BYREF
  void *v16[5]; // [esp+18h] [ebp-3Ch] BYREF
  unsigned int v17; // [esp+2Ch] [ebp-28h]
  void *v18[4]; // [esp+34h] [ebp-20h] BYREF
  int v19; // [esp+44h] [ebp-10h]
  unsigned int v20; // [esp+48h] [ebp-Ch]

  v4 = *this;
  v14 = a2;
  v5 = sub_40F130(v4);
  sub_40F360((int)&v14 + 2, (int)v5, (int)v18, (int)&v14);
  if ( v19 == 1 )
  {
    v6 = (void **)v18[0];
    if ( v20 < 8 )
      v6 = v18;
    v7 = *(_WORD *)v6;
  }
  else
  {
    v7 = v14;
  }
  v13 = v7;
  if ( v20 >= 8 )
    operator delete(v18[0]);
  v8 = *this;
  v20 = 7;
  v19 = 0;
  LOWORD(v18[0]) = 0;
  v15 = a3;
  v9 = sub_40F130(v8);
  sub_40F360((int)&v15 + 2, (int)v9, (int)v16, (int)&v15);
  if ( v16[4] == (void *)1 )
  {
    v10 = (void **)v16[0];
    if ( v17 < 8 )
      v10 = v16;
    v11 = *(_WORD *)v10;
  }
  else
  {
    v11 = v15;
  }
  if ( v17 >= 8 )
    operator delete(v16[0]);
  return v13 == v11;
}

//----- (004115E0) --------------------------------------------------------
int *__usercall sub_4115E0@<eax>(
        int *a1@<edi>,
        int a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        unsigned __int16 *a5,
        int a6,
        char a7)
{
  unsigned __int16 *v7; // eax
  unsigned __int16 *v8; // ecx
  int v9; // esi
  unsigned __int16 *v10; // edx
  bool v12; // zf
  int *v13; // eax
  int v14; // [esp+4h] [ebp-4h] BYREF

  v7 = (unsigned __int16 *)a2;
  v8 = a3;
  v9 = a2;
  v14 = a2;
  if ( (unsigned __int16 *)a2 != a3 )
  {
    while ( a4 != a5 )
    {
      v10 = a4++;
      a2 = (int)(v7 + 1);
      if ( !sub_411500(&a6, *v7, *v10) )
      {
        *a1 = v9;
        return a1;
      }
      v7 = (unsigned __int16 *)a2;
      v8 = a3;
      if ( (unsigned __int16 *)a2 == a3 )
        goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_5:
  if ( a4 == a5 )
  {
LABEL_6:
    *a1 = a2;
    return a1;
  }
  if ( !a7 || (v12 = v7 == v8, v13 = &a2, !v12) )
    v13 = &v14;
  *a1 = *v13;
  return a1;
}

//----- (00411670) --------------------------------------------------------
int *__cdecl sub_411670(
        int *a1,
        int a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        unsigned __int16 *a5,
        int a6,
        char a7)
{
  unsigned __int16 *v7; // eax
  unsigned __int16 *v8; // ecx
  unsigned __int16 *v9; // edx
  bool v10; // zf
  struct std::locale::facet **v11; // ebx
  _DWORD *v12; // eax
  struct std::locale::facet *v13; // eax
  int v14; // edi
  int v15; // eax
  int v16; // esi
  void (__thiscall ***v17)(_DWORD, int); // esi
  struct std::locale::facet **v18; // ebx
  _DWORD *v19; // eax
  struct std::locale::facet *v20; // eax
  int v21; // edi
  int v22; // eax
  int v23; // esi
  void (__thiscall ***v24)(_DWORD, int); // esi
  __int16 v25; // ax
  int *v26; // eax
  int v27; // ecx
  int *result; // eax
  int v29; // [esp+14h] [ebp-28h]
  char v30[4]; // [esp+18h] [ebp-24h] BYREF
  int v31; // [esp+1Ch] [ebp-20h] BYREF
  int v32; // [esp+20h] [ebp-1Ch]
  char v33[4]; // [esp+24h] [ebp-18h] BYREF
  int v34; // [esp+28h] [ebp-14h] BYREF
  int v35; // [esp+2Ch] [ebp-10h] BYREF
  int v36; // [esp+38h] [ebp-4h]

  v7 = (unsigned __int16 *)a2;
  v8 = a3;
  v35 = a2;
  if ( (unsigned __int16 *)a2 == a3 )
  {
LABEL_19:
    if ( a4 != a5 )
    {
      if ( !a7 || (v10 = v7 == v8, v26 = &a2, !v10) )
        v26 = &v35;
      goto LABEL_25;
    }
  }
  else
  {
    while ( a4 != a5 )
    {
      v9 = a4++;
      a2 = (int)(v7 + 1);
      v29 = *v9;
      v10 = *(_DWORD *)(a6 + 4) == 0;
      v11 = (struct std::locale::facet **)(a6 + 4);
      v32 = *v7;
      if ( v10 )
      {
        v12 = sub_40F4D0(a6, &v34);
        v36 = 0;
        v13 = sub_408900((int)v12);
        v36 = -1;
        v14 = v34;
        *v11 = v13;
        if ( v14 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v33, 0);
          v15 = *(_DWORD *)(v14 + 4);
          if ( v15 && v15 != -1 )
            *(_DWORD *)(v14 + 4) = v15 - 1;
          v16 = -(*(_DWORD *)(v14 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v33);
          v17 = (void (__thiscall ***)(_DWORD, int))(v14 & v16);
          if ( v17 )
            (**v17)(v17, 1);
        }
      }
      v32 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v11 + 24))(*v11, v32);
      v18 = (struct std::locale::facet **)(a6 + 4);
      if ( !*(_DWORD *)(a6 + 4) )
      {
        v19 = sub_40F4D0(a6, &v31);
        v36 = 1;
        v20 = sub_408900((int)v19);
        v36 = -1;
        v21 = v31;
        *v18 = v20;
        if ( v21 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v30, 0);
          v22 = *(_DWORD *)(v21 + 4);
          if ( v22 && v22 != -1 )
            *(_DWORD *)(v21 + 4) = v22 - 1;
          v23 = -(*(_DWORD *)(v21 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v30);
          v24 = (void (__thiscall ***)(_DWORD, int))(v21 & v23);
          if ( v24 )
            (**v24)(v24, 1);
        }
      }
      v25 = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v18 + 24))(*v18, v29);
      if ( (_WORD)v32 != v25 )
      {
        v27 = v35;
        goto LABEL_26;
      }
      v7 = (unsigned __int16 *)a2;
      v8 = a3;
      if ( (unsigned __int16 *)a2 == a3 )
        goto LABEL_19;
    }
  }
  v26 = &a2;
LABEL_25:
  v27 = *v26;
LABEL_26:
  result = a1;
  *a1 = v27;
  return result;
}
// 411670: using guessed type char var_18[4];
// 411670: using guessed type char var_24[4];

//----- (00411830) --------------------------------------------------------
int *__cdecl sub_411830(int *a1, int a2, _WORD *a3, _WORD *a4, _WORD *a5, int a6, char a7)
{
  _WORD *v7; // ecx
  _WORD *v8; // edx
  int v9; // eax
  _WORD *v10; // esi
  _WORD *v11; // edi
  int *result; // eax
  bool v13; // zf
  int *v14; // ecx
  int v15; // [esp+Ch] [ebp-4h] BYREF

  v7 = (_WORD *)a2;
  v8 = a4;
  v9 = a2;
  v15 = a2;
  if ( (_WORD *)a2 != a3 )
  {
    while ( v8 != a5 )
    {
      v10 = v8;
      v11 = v7;
      ++v8;
      ++v7;
      a4 = v8;
      a2 = (int)v7;
      if ( *v11 != *v10 )
      {
        *a1 = v9;
        return a1;
      }
      if ( v7 == a3 )
        goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_5:
  if ( v8 == a5 )
  {
LABEL_6:
    result = a1;
    *a1 = a2;
    return result;
  }
  if ( !a7 || (v13 = v7 == a3, v14 = &a2, !v13) )
    v14 = &v15;
  result = a1;
  *a1 = *v14;
  return result;
}

//----- (004118C0) --------------------------------------------------------
bool __thiscall sub_4118C0(void *this)
{
  return sub_412020(0x7FFFFFFF, (int)this, 10) != 0x7FFFFFFF;
}

//----- (004118E0) --------------------------------------------------------
char __userpurge sub_4118E0@<al>(int a1@<edi>, char a2)
{
  unsigned __int16 v2; // ax
  int v3; // ebx
  int v5; // esi
  int v6; // esi
  struct std::locale::facet *v7; // eax

  v2 = sub_412360(
         *(_DWORD *)(a1 + 52),
         *(_DWORD *)a1,
         (unsigned __int16 *)(*(_DWORD *)a1 + 2),
         (*(_DWORD *)(a1 + 56) & 0x100) != 0);
  v3 = v2;
  if ( !v2 )
    return 0;
  if ( a2 )
    sub_411D50(a1 + 24);
  v5 = *(_DWORD *)(a1 + 28);
  sub_412B30(*(_DWORD *)(a1 + 40), v5, v3);
  *(_WORD *)(v5 + 36) |= v3;
  v6 = *(unsigned __int16 *)(a1 + 62);
  v7 = sub_40F1E0(*(_DWORD *)(a1 + 52));
  if ( (*(unsigned __int8 (__thiscall **)(struct std::locale::facet *, int, int))(*(_DWORD *)v7 + 8))(v7, 1, v6) )
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8) ^= 1u;
  sub_40FF70(a1);
  return 1;
}

//----- (00411AF0) --------------------------------------------------------
char __usercall sub_411AF0@<al>(int a1@<esi>)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  int v4; // edi
  struct std::locale::facet *v5; // eax

  if ( (*(_DWORD *)(a1 + 68) & 0x10000) != 0 && sub_4122D0(*(_WORD *)(a1 + 62), a1) )
    goto LABEL_8;
  v1 = *(_DWORD *)(a1 + 68);
  if ( (v1 & 0x8000) != 0 )
  {
    v2 = *(unsigned __int16 *)(a1 + 62);
    if ( v2 == 97 )
    {
      *(_WORD *)(a1 + 60) = 7;
      sub_40FF70(a1);
      return 1;
    }
    if ( v2 == 98 )
    {
      *(_WORD *)(a1 + 60) = 8;
LABEL_8:
      sub_40FF70(a1);
      return 1;
    }
  }
  v3 = *(unsigned __int16 *)(a1 + 62);
  if ( v3 == 99 && (v1 & 0x40000) != 0 )
  {
    sub_40FF70(a1);
    v4 = *(unsigned __int16 *)(a1 + 62);
    v5 = sub_40F1E0(*(_DWORD *)(a1 + 52));
    if ( !(*(unsigned __int8 (__thiscall **)(struct std::locale::facet *, int, int))(*(_DWORD *)v5 + 8))(v5, 259, v4) )
      std::tr1::_Xbad(2);
    *(_WORD *)(a1 + 60) = *(_BYTE *)(a1 + 62) & 0x1F;
    sub_40FF70(a1);
    return 1;
  }
  if ( v3 == 120 && (v1 & 0x1000) != 0 )
  {
    sub_40FF70(a1);
    if ( !sub_412020(2, a1, 16) )
      return 1;
LABEL_25:
    std::tr1::_Xbad(2);
  }
  if ( v3 == 117 && (v1 & 0x800) != 0 )
  {
    sub_40FF70(a1);
    if ( !sub_412020(4, a1, 16) )
      return 1;
    goto LABEL_25;
  }
  if ( (v1 & 0x2000) != 0 && sub_412020(3, a1, 8) != 3 )
  {
    if ( *(_WORD *)(a1 + 60) )
      return 1;
    goto LABEL_25;
  }
  return sub_4121D0(a1);
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411C60) --------------------------------------------------------
int __stdcall sub_411C60(int a1)
{
  _DWORD *v1; // ebx
  int result; // eax

  if ( ++*(_DWORD *)(a1 + 12) >= 0x20u )
    std::tr1::_Xbad(11);
  v1 = sub_40EEE0(a1 + 24, *(_DWORD *)(a1 + 12));
  sub_40EC40((_DWORD *)a1);
  sub_40EE60((int)v1, a1 + 24);
  result = a1;
  *(_DWORD *)(a1 + 20) |= 1 << v1[5];
  return result;
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00411CB0) --------------------------------------------------------
_DWORD *__usercall sub_411CB0@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // eax
  int v2; // ebx
  int v3; // eax

  v1 = operator new(0x14u);
  if ( v1 )
  {
    *v1 = &std::tr1::_Node_base::`vftable';
    v1[1] = 8;
    v1[2] = 0;
    v1[3] = 0;
    v1[4] = 0;
    v2 = (int)v1;
  }
  else
  {
    v2 = 0;
  }
  *(_DWORD *)(v2 + 16) = a1[7];
  v3 = *(_DWORD *)(a1[7] + 12);
  if ( v3 )
  {
    *(_DWORD *)(v2 + 12) = v3;
    *(_DWORD *)(*(_DWORD *)(a1[7] + 12) + 16) = v2;
  }
  *(_DWORD *)(a1[7] + 12) = v2;
  a1[7] = v2;
  sub_40EC40(a1);
  return sub_40EE60(v2, (int)(a1 + 6));
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (00411D20) --------------------------------------------------------
_DWORD *__usercall sub_411D20@<eax>(char a1@<al>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // ebx
  _DWORD *result; // eax

  v2 = sub_412700(a2 + 6, a1);
  sub_40EC40(a2);
  result = sub_40EE60((int)v2, (int)(a2 + 6));
  a2[7] = v2;
  return result;
}

//----- (00411D50) --------------------------------------------------------
_DWORD *__usercall sub_411D50@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // edx

  result = operator new(0x2Cu);
  if ( result )
  {
    result[1] = 7;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    *((_WORD *)result + 18) = 0;
    result[10] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBFFC: using guessed type void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';

//----- (00411DC0) --------------------------------------------------------
_DWORD *__userpurge sub_411DC0@<eax>(int a1@<esi>, int a2)
{
  _DWORD *result; // eax
  int v3; // ecx

  result = operator new(0x18u);
  if ( result )
  {
    result[1] = 15;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_back::`vftable';
    result[5] = a2;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v3 )
  {
    result[3] = v3;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CBF84: using guessed type void *std::tr1::_Node_back::`vftable';

//----- (00411E20) --------------------------------------------------------
_DWORD *__userpurge sub_411E20@<eax>(_DWORD *a1@<esi>, int a2, int a3, char a4)
{
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // ecx
  _DWORD *v8; // edi
  _DWORD *result; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  int v13; // [esp+0h] [ebp-4h]

  v4 = (_DWORD *)a1[1];
  if ( v4[1] == 6 && v4[6] != 1 )
  {
    v5 = v4[6] - 1;
    v4[6] = v5;
    sub_411430(a1, *(unsigned __int16 *)(v4[7] + 2 * v5));
  }
  v13 = a1[1];
  v6 = operator new(0x18u);
  if ( v6 )
  {
    v7 = a1[2] + 1;
    a1[2] = v7;
    v6[1] = 19;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    *v6 = &std::tr1::_Node_end_rep::`vftable';
    v6[5] = v7;
    v8 = v6;
  }
  else
  {
    v8 = 0;
  }
  result = operator new(0x20u);
  if ( result )
  {
    result[2] = a4 != 0 ? 2 : 0;
    result[1] = 18;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_rep::`vftable';
    result[5] = v8;
    result[6] = a2;
    result[7] = a3;
  }
  else
  {
    result = 0;
  }
  v8[4] = a1[1];
  v10 = *(_DWORD *)(a1[1] + 12);
  if ( v10 )
  {
    v8[3] = v10;
    *(_DWORD *)(*(_DWORD *)(a1[1] + 12) + 16) = v8;
  }
  v11 = v13;
  *(_DWORD *)(a1[1] + 12) = v8;
  a1[1] = v8;
  v12 = *(_DWORD *)(v13 + 4);
  if ( v12 == 9 || v12 == 14 )
    v11 = *(_DWORD *)(v13 + 20);
  *(_DWORD *)(*(_DWORD *)(v11 + 16) + 12) = result;
  result[4] = *(_DWORD *)(v11 + 16);
  *(_DWORD *)(v11 + 16) = result;
  result[3] = v11;
  return result;
}
// 4CBF9C: using guessed type void *std::tr1::_Node_end_rep::`vftable';
// 4CBFA4: using guessed type void *std::tr1::_Node_rep::`vftable';

//----- (00411F20) --------------------------------------------------------
_DWORD *__usercall sub_411F20@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = operator new(0x20u);
  if ( result )
  {
    result[1] = 6;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    *result = &std::tr1::_Node_str<wchar_t>::`vftable';
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
  }
  else
  {
    result = 0;
  }
  result[4] = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( v2 )
  {
    result[3] = v2;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) + 16) = result;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = result;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}
// 4CC004: using guessed type void *std::tr1::_Node_str<wchar_t>::`vftable';

//----- (00411F80) --------------------------------------------------------
void *__thiscall sub_411F80(void *this, char a2)
{
  free(*((void **)this + 7));
  *(_DWORD *)this = &std::tr1::_Node_base::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';

//----- (00411FB0) --------------------------------------------------------
void __stdcall sub_411FB0(void **a1, int a2, int a3, int a4)
{
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  v4[7] = 0;
  sub_412BD0((int)a1, *a1, a2, a3, (int)a1);
}

//----- (00412020) --------------------------------------------------------
int __usercall sub_412020@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // edi
  unsigned int v5; // eax
  unsigned int v6; // eax
  __int16 v7; // cx
  unsigned __int16 *v8; // eax
  int v9; // ecx
  unsigned __int16 *v10; // eax

  v3 = a1;
  *(_WORD *)(a2 + 60) = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v5 = *(unsigned __int16 *)(a2 + 62);
      if ( a3 == 8 )
      {
        if ( (unsigned __int16)(v5 - 48) > 7u )
          return v3;
      }
      else if ( (unsigned __int16)v5 < 0x30u || v5 > 0x39 )
      {
        if ( a3 != 16 )
          return v3;
        if ( (unsigned __int16)(v5 - 97) > 5u )
        {
          if ( (unsigned __int16)(v5 - 65) > 5u )
            return v3;
          v6 = v5 - 55;
        }
        else
        {
          v6 = v5 - 87;
        }
        goto LABEL_12;
      }
      v6 = v5 - 48;
LABEL_12:
      if ( v6 != -1 )
      {
        v7 = v6 + a3 * *(_WORD *)(a2 + 60);
        v8 = *(unsigned __int16 **)a2;
        *(_WORD *)(a2 + 60) = v7;
        v9 = *(_DWORD *)(a2 + 8);
        --v3;
        if ( v8 != (unsigned __int16 *)v9 )
        {
          if ( *v8 == 92 )
          {
            if ( (v10 = v8 + 1, v10 != (unsigned __int16 *)v9)
              && (*(_BYTE *)(a2 + 68) & 8) == 0
              && ((v9 = *v10, v9 == 40) || v9 == 41)
              || (*(_BYTE *)(a2 + 68) & 0x10) == 0 && ((v9 = *v10, v9 == 123) || v9 == 125) )
            {
              *(_DWORD *)a2 = v10;
            }
          }
          *(_DWORD *)a2 += 2;
        }
        sub_40EAA0(v9, (unsigned __int16 **)a2);
        if ( v3 )
          continue;
      }
      return v3;
    }
  }
  return v3;
}

//----- (004120F0) --------------------------------------------------------
int __usercall sub_4120F0@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  unsigned __int16 *v4; // edi

  v1 = *(_DWORD *)(a1 + 64);
  switch ( v1 )
  {
    case 0x5C:
      sub_40FF70(a1);
      v2 = *(_DWORD *)(a1 + 68);
      if ( (v2 & 0x200000) != 0 )
        return sub_412AA0(a1);
      if ( ((v2 & 0x10000) == 0 || !sub_4122D0(*(_WORD *)(a1 + 62), a1))
        && ((*(_DWORD *)(a1 + 68) & 0x8000) == 0 || !sub_412330(*(_WORD *)(a1 + 62), a1)) )
      {
        *(_WORD *)(a1 + 60) = 92;
        return 1;
      }
      goto LABEL_18;
    case 0x5B:
      sub_40FF70(a1);
      v4 = *(unsigned __int16 **)(a1 + 64);
      if ( v4 == (unsigned __int16 *)58 || v4 == (unsigned __int16 *)61 || v4 == (unsigned __int16 *)46 )
      {
        sub_40FF70(a1);
        sub_412910(v4, (unsigned __int16 **)a1);
        sub_410FA0(a1, 4, 93);
        return 2;
      }
      else
      {
        *(_WORD *)(a1 + 60) = 91;
        return 1;
      }
    case 0x5D:
    case 0xFFFF:
      return 0;
    default:
      *(_WORD *)(a1 + 60) = *(_WORD *)(a1 + 62);
LABEL_18:
      sub_40FF70(a1);
      return 1;
  }
}

//----- (004121D0) --------------------------------------------------------
char __usercall sub_4121D0@<al>(int a1@<eax>)
{
  int v2; // edi
  struct std::locale::facet *v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  unsigned __int16 *v7; // eax
  unsigned __int16 *v8; // eax

  if ( (*(_DWORD *)(a1 + 68) & 0x400000) == 0
    || (v2 = *(unsigned __int16 *)(a1 + 62),
        v3 = sub_40F1E0(*(_DWORD *)(a1 + 52)),
        (*(unsigned __int8 (__thiscall **)(struct std::locale::facet *, int, int))(*(_DWORD *)v3 + 8))(v3, 263, v2))
    || (v4 = *(unsigned __int16 *)(a1 + 62), v4 == 95) )
  {
    v5 = *(_DWORD *)(a1 + 68);
    if ( (v5 & 0x400000) != 0
      || (v4 = *(unsigned __int16 *)(a1 + 62), v4 != 46)
      && v4 != 91
      && v4 != 92
      && v4 != 42
      && v4 != 124
      && v4 != 94
      && v4 != 36 )
    {
      if ( (v5 & 0x800000) == 0
        || (v4 = *(unsigned __int16 *)(a1 + 62), v4 != 40) && v4 != 41 && v4 != 43 && v4 != 63 && v4 != 123 && v4 != 125 )
      {
        if ( (v5 & 0x1000000) == 0 )
          return 0;
        v4 = *(unsigned __int16 *)(a1 + 62);
        if ( v4 != 34 && v4 != 47 )
          return 0;
      }
    }
  }
  v6 = *(_DWORD *)(a1 + 8);
  *(_WORD *)(a1 + 60) = v4;
  v7 = *(unsigned __int16 **)a1;
  if ( *(_DWORD *)a1 != v6 )
  {
    if ( *v7 == 92 )
    {
      if ( (v8 = v7 + 1, v8 != (unsigned __int16 *)v6)
        && (*(_BYTE *)(a1 + 68) & 8) == 0
        && ((v6 = *v8, v6 == 40) || v6 == 41)
        || (*(_BYTE *)(a1 + 68) & 0x10) == 0 && ((v6 = *v8, v6 == 123) || v6 == 125) )
      {
        *(_DWORD *)a1 = v8;
      }
    }
    *(_DWORD *)a1 += 2;
  }
  sub_40EAA0(v6, (unsigned __int16 **)a1);
  return 1;
}

//----- (004122D0) --------------------------------------------------------
char __usercall sub_4122D0@<al>(__int16 a1@<ax>, int a2@<ecx>)
{
  char result; // al

  switch ( a1 )
  {
    case 'f':
      result = 1;
      *(_WORD *)(a2 + 60) = 12;
      break;
    case 'n':
      *(_WORD *)(a2 + 60) = 10;
      return 1;
    case 'r':
      result = 1;
      *(_WORD *)(a2 + 60) = 13;
      break;
    case 't':
      *(_WORD *)(a2 + 60) = 9;
      return 1;
    case 'v':
      result = 1;
      *(_WORD *)(a2 + 60) = 11;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (00412330) --------------------------------------------------------
char __usercall sub_412330@<al>(__int16 a1@<ax>, int a2@<ecx>)
{
  char result; // al

  if ( a1 == 97 )
  {
    result = 1;
    *(_WORD *)(a2 + 60) = 7;
  }
  else if ( a1 == 98 )
  {
    *(_WORD *)(a2 + 60) = 8;
    return 1;
  }
  else
  {
    return 0;
  }
  return result;
}

//----- (00412360) --------------------------------------------------------
int __userpurge sub_412360@<eax>(int a1@<ebx>, int a2, unsigned __int16 *a3, char a4)
{
  int v4; // edx
  int v5; // eax
  wchar_t **v6; // ecx
  wchar_t *v7; // ecx
  unsigned __int16 *v8; // esi
  unsigned __int16 *v9; // edx
  bool v10; // zf
  _DWORD *v11; // eax
  struct std::locale::facet *v12; // eax
  int v13; // edi
  int v14; // eax
  int v15; // esi
  void (__thiscall ***v16)(_DWORD, int); // esi
  unsigned __int16 v17; // ax
  _DWORD *v18; // eax
  struct std::locale::facet *v19; // eax
  int v20; // edi
  int v21; // eax
  int v22; // esi
  void (__thiscall ***v23)(_DWORD, int); // esi
  __int16 v24; // ax
  int result; // eax
  int v26; // [esp+10h] [ebp-34h]
  char v27[4]; // [esp+14h] [ebp-30h] BYREF
  int v28; // [esp+18h] [ebp-2Ch] BYREF
  int v29; // [esp+1Ch] [ebp-28h]
  char v30[4]; // [esp+20h] [ebp-24h] BYREF
  int v31; // [esp+24h] [ebp-20h] BYREF
  unsigned __int16 *v32; // [esp+28h] [ebp-1Ch]
  wchar_t *v33; // [esp+2Ch] [ebp-18h]
  int v34; // [esp+30h] [ebp-14h]
  int v35; // [esp+34h] [ebp-10h]
  int v36; // [esp+40h] [ebp-4h]

  v4 = 0;
  v35 = 0;
  if ( L"alnum" )
  {
    v5 = 0;
    v6 = &off_4CBE08;
    do
    {
      v7 = *v6;
      v8 = a3;
      v32 = &v7[dword_4CBE0C[v5]];
      v33 = v7;
      v9 = (unsigned __int16 *)a2;
      v34 = a2;
      if ( (unsigned __int16 *)a2 == a3 )
        goto LABEL_23;
      while ( v7 != v32 )
      {
        v10 = *(_DWORD *)(a1 + 4) == 0;
        v26 = *v7;
        v29 = *v9;
        if ( v10 )
        {
          v11 = sub_40F4D0(a1, &v31);
          v36 = 0;
          v12 = sub_408900((int)v11);
          v36 = -1;
          v13 = v31;
          *(_DWORD *)(a1 + 4) = v12;
          if ( v13 )
          {
            std::_Lockit::_Lockit((std::_Lockit *)v30, 0);
            v14 = *(_DWORD *)(v13 + 4);
            if ( v14 && v14 != -1 )
              *(_DWORD *)(v13 + 4) = v14 - 1;
            v15 = -(*(_DWORD *)(v13 + 4) == 0);
            std::_Lockit::~_Lockit((std::_Lockit *)v30);
            v16 = (void (__thiscall ***)(_DWORD, int))(v13 & v15);
            if ( v16 )
              (**v16)(v16, 1);
          }
        }
        v17 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 4) + 24))(*(_DWORD *)(a1 + 4), v29);
        v10 = *(_DWORD *)(a1 + 4) == 0;
        v29 = v17;
        if ( v10 )
        {
          v18 = sub_40F4D0(a1, &v28);
          v36 = 1;
          v19 = sub_408900((int)v18);
          v36 = -1;
          v20 = v28;
          *(_DWORD *)(a1 + 4) = v19;
          if ( v20 )
          {
            std::_Lockit::_Lockit((std::_Lockit *)v27, 0);
            v21 = *(_DWORD *)(v20 + 4);
            if ( v21 && v21 != -1 )
              *(_DWORD *)(v20 + 4) = v21 - 1;
            v22 = -(*(_DWORD *)(v20 + 4) == 0);
            std::_Lockit::~_Lockit((std::_Lockit *)v27);
            v23 = (void (__thiscall ***)(_DWORD, int))(v20 & v22);
            if ( v23 )
              (**v23)(v23, 1);
          }
        }
        v24 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 4) + 24))(*(_DWORD *)(a1 + 4), v26);
        v9 = (unsigned __int16 *)(v34 + 2);
        v7 = v33 + 1;
        v34 += 2;
        ++v33;
        if ( (_WORD)v29 != v24 )
          goto LABEL_24;
        v8 = a3;
        if ( v9 == a3 )
          goto LABEL_23;
      }
      if ( v9 == v8 )
      {
LABEL_23:
        if ( v7 == v32 )
        {
          v4 = v35;
          break;
        }
      }
LABEL_24:
      v4 = v35 + 1;
      v5 = 3 * (v35 + 1);
      v10 = (&off_4CBE08)[v5] == 0;
      v6 = &(&off_4CBE08)[v5];
      ++v35;
    }
    while ( !v10 );
  }
  result = 0;
  if ( (&off_4CBE08)[3 * v4] )
    result = (unsigned __int16)word_4CBE10[6 * v4];
  if ( a4 )
  {
    if ( (result & 3) != 0 )
      return result | 3;
  }
  return result;
}
// 4CAF94: using guessed type wchar_t aAlnum[6];
// 4CBE08: using guessed type wchar_t *off_4CBE08;
// 4CBE0C: using guessed type int dword_4CBE0C[];
// 4CBE10: using guessed type __int16 word_4CBE10[];
// 412360: using guessed type char var_24[4];
// 412360: using guessed type char var_30[4];

//----- (00412560) --------------------------------------------------------
int __userpurge sub_412560@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  struct std::locale::facet *v5; // eax
  struct std::locale::facet *v6; // eax
  int v7; // ebx
  _DWORD *v8; // eax
  _BYTE *v9; // eax
  int result; // eax
  _DWORD *v11; // eax
  int v12; // ebx
  unsigned int v13; // eax
  void *v14; // eax
  int v15; // esi
  unsigned int v16; // eax
  unsigned int v17; // ebx
  void *v18; // eax
  int i; // [esp+Ch] [ebp-8h]
  unsigned int v20; // [esp+10h] [ebp-4h]

  if ( (a3[3] & 0x100) != 0 )
  {
    v5 = sub_40F1E0(a3[4]);
    a2 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v5 + 24))(v5, a2);
    v6 = sub_40F1E0(a3[4]);
    LOWORD(a1) = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v6 + 24))(v6, a1);
  }
  v7 = a3[1];
  for ( i = v7; (unsigned __int16)a2 <= (unsigned __int16)a1; ++a2 )
  {
    if ( (unsigned __int16)a1 >= (int)a3[5] )
      break;
    if ( !*(_DWORD *)(v7 + 24) )
    {
      v8 = operator new(0x20u);
      if ( v8 )
      {
        *v8 = 0;
        v8[1] = 0;
        v8[2] = 0;
        v8[3] = 0;
        v8[4] = 0;
        v8[5] = 0;
        v8[6] = 0;
        v8[7] = 0;
      }
      else
      {
        v8 = 0;
      }
      *(_DWORD *)(v7 + 24) = v8;
    }
    v9 = (_BYTE *)(((unsigned __int16)a2 >> 3) + *(_DWORD *)(v7 + 24));
    *v9 |= 1 << (a2 & 7);
    if ( (_WORD)a2 == (_WORD)a1 )
      break;
  }
  result = (unsigned __int16)a2;
  if ( (unsigned __int16)a1 - (unsigned __int16)a2 >= a3[6] )
  {
    if ( !*(_DWORD *)(v7 + 32) )
    {
      v11 = operator new(0xCu);
      if ( v11 )
      {
        *v11 = 0;
        v11[1] = 0;
        v11[2] = 0;
      }
      else
      {
        v11 = 0;
      }
      *(_DWORD *)(v7 + 32) = v11;
    }
    v12 = *(_DWORD *)(v7 + 32);
    v13 = *(_DWORD *)(v12 + 4);
    if ( *(_DWORD *)v12 <= v13 )
    {
      v20 = v13 + 16;
      v14 = realloc(*(void **)(v12 + 8), 2 * (v13 + 16));
      if ( !v14 )
        unknown_libname_4();
      *(_DWORD *)(v12 + 8) = v14;
      *(_DWORD *)v12 = v20;
    }
    *(_WORD *)(*(_DWORD *)(v12 + 8) + 2 * (*(_DWORD *)(v12 + 4))++) = a2;
    v15 = *(_DWORD *)(i + 32);
    v16 = *(_DWORD *)(v15 + 4);
    if ( *(_DWORD *)v15 <= v16 )
    {
      v17 = v16 + 16;
      v18 = realloc(*(void **)(v15 + 8), 2 * (v16 + 16));
      if ( !v18 )
        unknown_libname_4();
      *(_DWORD *)(v15 + 8) = v18;
      *(_DWORD *)v15 = v17;
    }
    result = *(_DWORD *)(v15 + 8);
    *(_WORD *)(result + 2 * (*(_DWORD *)(v15 + 4))++) = a1;
  }
  else
  {
    for ( ; (unsigned __int16)a2 <= (unsigned __int16)a1; ++a2 )
    {
      result = sub_412870(a3, a2);
      if ( (_WORD)a2 == (_WORD)a1 )
        break;
    }
  }
  return result;
}
// 427BF6: using guessed type void __noreturn unknown_libname_4(void);

//----- (00412700) --------------------------------------------------------
_DWORD *__thiscall sub_412700(_DWORD *this, char a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // eax
  int v6; // ecx
  _DWORD v8[8]; // [esp+0h] [ebp-20h] BYREF

  v8[4] = v8;
  v3 = operator new(0x18u);
  if ( v3 )
  {
    v3[2] = 0;
    v3[3] = 0;
    v3[4] = 0;
    *v3 = &std::tr1::_Node_assert::`vftable';
    v3[5] = 0;
    v4 = v3;
    v3[1] = (a2 != 0) + 10;
  }
  else
  {
    v4 = 0;
  }
  v8[7] = 0;
  v5 = operator new(0x14u);
  if ( v5 )
  {
    *v5 = &std::tr1::_Node_base::`vftable';
    v5[1] = 1;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
  }
  else
  {
    v5 = 0;
  }
  v4[4] = this[1];
  v6 = *(_DWORD *)(this[1] + 12);
  if ( v6 )
  {
    v4[3] = v6;
    *(_DWORD *)(*(_DWORD *)(this[1] + 12) + 16) = v4;
  }
  *(_DWORD *)(this[1] + 12) = v4;
  v4[5] = v5;
  v5[4] = v4;
  this[1] = v5;
  return v4;
}
// 4CBF5C: using guessed type void *std::tr1::_Node_base::`vftable';
// 4CBF74: using guessed type void *std::tr1::_Node_assert::`vftable';

//----- (004127F0) --------------------------------------------------------
_BYTE *__usercall sub_4127F0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  struct std::locale::facet *v4; // eax
  int v5; // esi
  _DWORD *v6; // eax
  _BYTE *result; // eax

  if ( (a2[3] & 0x100) != 0 )
  {
    v4 = sub_40F1E0(a2[4]);
    LOWORD(a1) = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v4 + 24))(v4, a1);
  }
  v5 = a2[1];
  if ( !*(_DWORD *)(v5 + 24) )
  {
    v6 = operator new(0x20u);
    if ( v6 )
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      v6[3] = 0;
      v6[4] = 0;
      v6[5] = 0;
      v6[6] = 0;
      v6[7] = 0;
    }
    else
    {
      v6 = 0;
    }
    *(_DWORD *)(v5 + 24) = v6;
  }
  result = (_BYTE *)(((unsigned __int16)a1 >> 3) + *(_DWORD *)(v5 + 24));
  *result |= 1 << (a1 & 7);
  return result;
}

//----- (00412870) --------------------------------------------------------
int __userpurge sub_412870@<eax>(_DWORD *a1@<eax>, int a2)
{
  struct std::locale::facet *v3; // eax
  int v4; // esi
  _DWORD *v5; // eax
  int v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // ebx
  void *v9; // eax
  int result; // eax

  if ( (a1[3] & 0x100) != 0 )
  {
    v3 = sub_40F1E0(a1[4]);
    LOWORD(a2) = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v3 + 24))(v3, a2);
  }
  v4 = a1[1];
  if ( !*(_DWORD *)(v4 + 28) )
  {
    v5 = operator new(0xCu);
    if ( v5 )
    {
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    else
    {
      v5 = 0;
    }
    *(_DWORD *)(v4 + 28) = v5;
  }
  v6 = *(_DWORD *)(v4 + 28);
  v7 = *(_DWORD *)(v6 + 4);
  if ( *(_DWORD *)v6 <= v7 )
  {
    v8 = v7 + 16;
    v9 = realloc(*(void **)(v6 + 8), 2 * (v7 + 16));
    if ( !v9 )
      unknown_libname_4();
    *(_DWORD *)(v6 + 8) = v9;
    *(_DWORD *)v6 = v8;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_WORD *)(*(_DWORD *)(v6 + 8) + 2 * result) = a2;
  ++*(_DWORD *)(v6 + 4);
  return result;
}
// 427BF6: using guessed type void __noreturn unknown_libname_4(void);

//----- (00412910) --------------------------------------------------------
int __usercall sub_412910@<eax>(unsigned __int16 *a1@<eax>, unsigned __int16 **a2@<ecx>)
{
  unsigned __int16 *v3; // ebx
  unsigned __int16 *v5; // eax
  unsigned __int16 *v6; // ecx
  unsigned __int16 *v7; // eax
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // di
  unsigned __int16 *v10; // ebx
  unsigned __int16 *v11; // eax
  unsigned __int16 *v12; // ecx
  unsigned __int16 *v13; // eax
  unsigned int v15; // [esp+Ch] [ebp-4h]

  v3 = *a2;
  v15 = 0;
  if ( a2[16] == (unsigned __int16 *)0xFFFF )
    goto LABEL_16;
  do
  {
    if ( a2[16] == a1 )
      break;
    v5 = *a2;
    v6 = a2[2];
    if ( *a2 != v6 )
    {
      if ( *v5 == 92 )
      {
        if ( (v7 = v5 + 1, v7 != v6)
          && ((_BYTE)a2[17] & 8) == 0
          && ((v6 = (unsigned __int16 *)*v7, v6 == (unsigned __int16 *)40) || v6 == (unsigned __int16 *)41)
          || ((_BYTE)a2[17] & 0x10) == 0
          && ((v6 = (unsigned __int16 *)*v7, v6 == (unsigned __int16 *)123) || v6 == (unsigned __int16 *)125) )
        {
          *a2 = v7;
        }
      }
      ++*a2;
    }
    sub_40EAA0((int)v6, a2);
    ++v15;
  }
  while ( a2[16] != (unsigned __int16 *)0xFFFF );
  if ( a2[16] == (unsigned __int16 *)0xFFFF )
  {
LABEL_16:
    if ( a1 == (unsigned __int16 *)46 )
      std::tr1::_Xbad(0);
    std::tr1::_Xbad(a1 != (unsigned __int16 *)58 ? 14 : 1);
  }
  if ( a1 == (unsigned __int16 *)58 )
  {
    v8 = sub_412360((int)a2[13], (int)v3, *a2, ((unsigned int)a2[14] & 0x100) != 0);
    v9 = v8;
    if ( !v8 )
      std::tr1::_Xbad(1);
    v10 = a2[7];
    sub_412B30((int)a2[10], (int)v10, v8);
    v10[18] |= v9;
  }
  else if ( a1 == (unsigned __int16 *)61 )
  {
    if ( v3 == *a2 )
      std::tr1::_Xbad(0);
    sub_412D60(*a2, v3, (int)(a2 + 6), v15);
  }
  else if ( a1 == (unsigned __int16 *)46 )
  {
    if ( v3 == *a2 )
      std::tr1::_Xbad(0);
    sub_412F00((unsigned int **)a2[7] + 5, v15, v3, *a2);
  }
  v11 = *a2;
  v12 = a2[2];
  if ( *a2 != v12 )
  {
    if ( *v11 == 92 )
    {
      if ( (v13 = v11 + 1, v13 != v12)
        && ((_BYTE)a2[17] & 8) == 0
        && ((v12 = (unsigned __int16 *)*v13, v12 == (unsigned __int16 *)40) || v12 == (unsigned __int16 *)41)
        || ((_BYTE)a2[17] & 0x10) == 0
        && ((v12 = (unsigned __int16 *)*v13, v12 == (unsigned __int16 *)123) || v12 == (unsigned __int16 *)125) )
      {
        *a2 = v13;
      }
    }
    ++*a2;
  }
  return sub_40EAA0((int)v12, a2);
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00412AA0) --------------------------------------------------------
int __usercall sub_412AA0@<eax>(int a1@<eax>)
{
  int v2; // eax

  v2 = *(_DWORD *)(a1 + 68);
  if ( (v2 & 0x4000) != 0 && *(_WORD *)(a1 + 62) == 92 )
  {
    *(_WORD *)(a1 + 60) = 92;
    sub_40FF70(a1);
    return 1;
  }
  else if ( (v2 & 0x20000) != 0 && sub_4118E0(a1, 0) )
  {
    return 2;
  }
  else if ( sub_412020(0x7FFFFFFF, a1, 10) == 0x7FFFFFFF )
  {
    return sub_411AF0(a1) != 0;
  }
  else
  {
    if ( *(_WORD *)(a1 + 60) )
      std::tr1::_Xbad(2);
    return 1;
  }
}
// 427C29: using guessed type void __cdecl __noreturn std::tr1::_Xbad(_DWORD);

//----- (00412B30) --------------------------------------------------------
_BYTE *__userpurge sub_412B30@<eax>(int a1@<eax>, int a2, int a3)
{
  int i; // esi
  struct std::locale::facet *v5; // eax
  _BYTE *result; // eax
  struct std::locale::facet *v7; // eax
  _DWORD *v8; // eax

  for ( i = 0; i < 256; ++i )
  {
    if ( (_WORD)a3 != 0xFFFF )
    {
      v5 = sub_40F1E0(a1);
      result = (_BYTE *)(*(int (__thiscall **)(struct std::locale::facet *, int, int))(*(_DWORD *)v5 + 8))(v5, a3, i);
      goto LABEL_6;
    }
    if ( (unsigned __int16)i != 95 )
    {
      v7 = sub_40F1E0(a1);
      result = (_BYTE *)(*(int (__thiscall **)(struct std::locale::facet *, int, _DWORD))(*(_DWORD *)v7 + 8))(
                          v7,
                          263,
                          (unsigned __int16)i);
LABEL_6:
      if ( !(_BYTE)result )
        continue;
    }
    if ( !*(_DWORD *)(a2 + 24) )
    {
      v8 = operator new(0x20u);
      if ( v8 )
      {
        *v8 = 0;
        v8[1] = 0;
        v8[2] = 0;
        v8[3] = 0;
        v8[4] = 0;
        v8[5] = 0;
        v8[6] = 0;
        v8[7] = 0;
      }
      else
      {
        v8 = 0;
      }
      *(_DWORD *)(a2 + 24) = v8;
    }
    result = (_BYTE *)(((unsigned int)i >> 3) + *(_DWORD *)(a2 + 24));
    *result |= 1 << (i & 7);
  }
  return result;
}

//----- (00412BD0) --------------------------------------------------------
void __thiscall sub_412BD0(int this, void *Src, int a3, int a4, int a5)
{
  unsigned int v6; // edi
  _WORD *v7; // eax
  void *v8; // edx
  int v9; // ecx
  char *v10; // ebx
  unsigned int v11; // ecx
  char *v12; // ecx
  void *v13; // edx
  size_t v14; // ebx
  char *v15; // eax
  _WORD *v16; // eax
  unsigned int v17; // edi
  void *v18; // eax
  char *v19; // edx
  char *v20; // eax
  int v21; // edi
  const void *v22; // [esp-8h] [ebp-30h]
  int v23; // [esp+0h] [ebp-28h] BYREF
  void *v24; // [esp+10h] [ebp-18h]
  char *v25; // [esp+14h] [ebp-14h]
  int *v26; // [esp+18h] [ebp-10h]
  int v27; // [esp+24h] [ebp-4h]

  v26 = &v23;
  v6 = (a4 - a3) >> 1;
  if ( v6 )
  {
    v7 = *(_WORD **)(this + 4);
    v8 = *(void **)this;
    v9 = ((int)v7 - *(_DWORD *)this) >> 1;
    if ( 0x7FFFFFFF - v9 < v6 )
      std::_Xlength_error("vector<T> too long");
    v10 = (char *)(v9 + v6);
    v11 = (*(_DWORD *)(this + 8) - (int)v8) >> 1;
    if ( v11 >= (unsigned int)v10 )
    {
      sub_4130E0(v7, (_WORD *)a3, (_WORD *)a4);
      v20 = *(char **)(this + 4);
      v21 = 2 * v6;
      if ( Src != v20 && v20 != &v20[v21] )
        sub_413110((int)v20, Src, (__int16 *)&v20[v21]);
      *(_DWORD *)(this + 4) += v21;
    }
    else
    {
      if ( 0x7FFFFFFF - (v11 >> 1) >= v11 )
      {
        v12 = (char *)((v11 >> 1) + v11);
        v25 = v12;
      }
      else
      {
        v25 = 0;
        v12 = 0;
      }
      if ( v12 < v10 )
      {
        v25 = v10;
        v12 = v10;
      }
      v13 = sub_4091E0(v12);
      v27 = 0;
      v14 = 2 * (((int)Src - *(_DWORD *)this) >> 1);
      v22 = *(const void **)this;
      v24 = v13;
      v15 = (char *)memcpy(v13, v22, v14);
      v16 = sub_4130E0(&v15[v14], (_WORD *)a3, (_WORD *)a4);
      memcpy(v16, Src, 2 * ((*(_DWORD *)(this + 4) - (int)Src) >> 1));
      v17 = ((*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 1) + v6;
      if ( *(_DWORD *)this )
        operator delete(*(void **)this);
      v18 = v24;
      v19 = (char *)v24 + 2 * v17;
      *(_DWORD *)(this + 8) = (char *)v24 + 2 * (_DWORD)v25;
      *(_DWORD *)(this + 4) = v19;
      *(_DWORD *)this = v18;
    }
  }
}

//----- (00412D60) --------------------------------------------------------
void __fastcall sub_412D60(_WORD *a1, _WORD *a2, int a3, unsigned int a4)
{
  int v4; // esi
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // ecx
  void **v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edx
  int v11; // eax
  bool v12; // bl
  int v13; // esi
  _DWORD *v14; // eax
  int v17; // [esp+1Ch] [ebp-54h] BYREF
  int v18; // [esp+20h] [ebp-50h]
  int v19; // [esp+24h] [ebp-4Ch]
  void *v20[7]; // [esp+28h] [ebp-48h] BYREF
  void *v21[4]; // [esp+44h] [ebp-2Ch] BYREF
  unsigned int v22; // [esp+54h] [ebp-1Ch]
  unsigned int v23; // [esp+58h] [ebp-18h]
  int v24; // [esp+6Ch] [ebp-4h]

  v4 = a3;
  v18 = *(_DWORD *)(a3 + 4);
  sub_412F70(a1, a2, *(_DWORD *)(a3 + 16), v21);
  v5 = 0;
  v24 = 0;
  v19 = 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)(v4 + 16);
    v17 = (unsigned __int16)v5;
    v7 = sub_412F70((char *)&v17 + 2, &v17, v6, v20);
    v8 = (void **)v21[0];
    if ( v23 < 8 )
      v8 = v21;
    v9 = v7[4];
    v10 = v9;
    if ( v9 >= v22 )
      v10 = v22;
    if ( v7[5] >= 8u )
      v7 = (_DWORD *)*v7;
    if ( v10 )
    {
      while ( *(_WORD *)v7 == *(_WORD *)v8 )
      {
        v7 = (_DWORD *)((char *)v7 + 2);
        v8 = (void **)((char *)v8 + 2);
        if ( !--v10 )
        {
          v5 = v19;
          goto LABEL_13;
        }
      }
      v11 = *(_WORD *)v7 < *(_WORD *)v8 ? -1 : 1;
      v5 = v19;
    }
    else
    {
LABEL_13:
      v11 = v9 >= v22 ? v9 != v22 : -1;
    }
    v12 = v11 == 0;
    LOBYTE(v24) = 0;
    if ( v20[5] >= (void *)8 )
      operator delete(v20[0]);
    if ( v12 )
    {
      v13 = v18;
      if ( !*(_DWORD *)(v18 + 24) )
      {
        v14 = operator new(0x20u);
        if ( v14 )
        {
          *v14 = 0;
          v14[1] = 0;
          v14[2] = 0;
          v14[3] = 0;
          v14[4] = 0;
          v14[5] = 0;
          v14[6] = 0;
          v14[7] = 0;
        }
        else
        {
          v14 = 0;
        }
        *(_DWORD *)(v13 + 24) = v14;
      }
      *(_BYTE *)(((unsigned int)v5 >> 3) + *(_DWORD *)(v13 + 24)) |= 1 << (v5 & 7);
    }
    v19 = ++v5;
    if ( v5 >= 256 )
      break;
    v4 = a3;
  }
  sub_412F00((unsigned int **)(v18 + 40), a4, a2, a1);
  if ( v23 >= 8 )
    operator delete(v21[0]);
}
// 412E23: conditional instruction was optimized away because eax.4 is in (==1|==FFFFFFFF)

//----- (00412F00) --------------------------------------------------------
_WORD *__userpurge sub_412F00@<eax>(unsigned int **a1@<eax>, unsigned int a2@<ebx>, _WORD *a3, _WORD *a4)
{
  unsigned int **v4; // esi
  unsigned int *v5; // edi
  unsigned int *v6; // eax
  unsigned int *v7; // eax

  v4 = a1;
  v5 = *a1;
  if ( !*a1 )
    goto LABEL_6;
  do
  {
    v6 = *v4;
    if ( a2 >= **v4 )
      break;
    v4 = (unsigned int **)(v6 + 4);
  }
  while ( v6[4] );
  v5 = *v4;
  if ( !*v4 || a2 != *v5 )
  {
LABEL_6:
    v7 = (unsigned int *)operator new(0x14u);
    if ( v7 )
    {
      *v7 = a2;
      v7[1] = 0;
      v7[2] = 0;
      v7[3] = 0;
    }
    else
    {
      v7 = 0;
    }
    *v4 = v7;
    v7[4] = (unsigned int)v5;
  }
  return sub_413070((int)(*v4 + 1), a3, a4);
}

//----- (00412F70) --------------------------------------------------------
_DWORD *__fastcall sub_412F70(void *a1, void *a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax
  void *v5; // edi
  int v6; // esi
  struct std::locale::facet *v7; // eax
  struct std::locale::facet *v8; // eax
  void *v9; // eax
  void *v10; // esi
  void *v11; // [esp+14h] [ebp-44h] BYREF
  int v12; // [esp+18h] [ebp-40h]
  int v13; // [esp+1Ch] [ebp-3Ch]
  int v14; // [esp+24h] [ebp-34h]
  void *v15; // [esp+28h] [ebp-30h]
  void *v16[7]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v17; // [esp+54h] [ebp-4h]

  result = a4;
  a4[5] = 7;
  a4[4] = 0;
  v15 = a4;
  *(_WORD *)a4 = 0;
  v17 = 0;
  v14 = 1;
  if ( a2 != a1 )
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    sub_4131B0((int)&v11, a2, &v11, (int)a1, (int)v15);
    v17 = 1;
    v5 = v11;
    v6 = (v12 - (int)v11) >> 1;
    v7 = sub_40F1E0(a3);
    (*(void (__thiscall **)(struct std::locale::facet *, void *, int))(*(_DWORD *)v7 + 20))(v7, v5, (int)v5 + 2 * v6);
    v8 = sub_40F130(a3);
    v9 = (void *)sub_40F360((int)v5 + 2 * v6, (int)v8, (int)v16, (int)v5);
    LOBYTE(v17) = 2;
    v10 = v15;
    sub_40AF70(v15, v9);
    if ( v16[5] >= (void *)8 )
      operator delete(v16[0]);
    if ( v5 )
      operator delete(v5);
    return v10;
  }
  return result;
}

//----- (00413070) --------------------------------------------------------
_WORD *__userpurge sub_413070@<eax>(int a1@<esi>, _WORD *a2, _WORD *a3)
{
  _WORD *result; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edi
  void *v6; // ebx
  __int16 v7; // [esp+0h] [ebp-4h]

  for ( result = a2; result != a3; a2 = result )
  {
    v7 = *result;
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)a1 <= v4 )
    {
      v5 = v4 + 16;
      v6 = realloc(*(void **)(a1 + 8), 2 * (v4 + 16));
      if ( !v6 )
        unknown_libname_4();
      result = a2;
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)a1 = v5;
    }
    ++result;
    *(_WORD *)(*(_DWORD *)(a1 + 8) + 2 * (*(_DWORD *)(a1 + 4))++) = v7;
  }
  return result;
}
// 427BF6: using guessed type void __noreturn unknown_libname_4(void);

//----- (004130E0) --------------------------------------------------------
_WORD *__usercall sub_4130E0@<eax>(_WORD *result@<eax>, _WORD *a2, _WORD *a3)
{
  _WORD *i; // ecx

  for ( i = a2; i != a3; ++result )
  {
    if ( result )
      *result = *i;
    ++i;
  }
  return result;
}

//----- (00413110) --------------------------------------------------------
int __usercall sub_413110@<eax>(int a1@<eax>, _WORD *a2, __int16 *a3)
{
  _WORD *v3; // edx
  __int16 *v4; // ebx
  int v5; // edi
  int result; // eax
  int v7; // esi
  int v8; // edx
  __int16 *v9; // edx
  __int16 *v10; // ecx
  __int16 *v11; // esi
  __int16 v12; // dx
  int v13; // edx
  __int16 *v14; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = a3;
  v5 = (a1 - (int)a2) >> 1;
  result = a3 - a2;
  v7 = v5;
  if ( v5 )
  {
    do
    {
      v8 = result % v7;
      result = v7;
      v7 = v8;
    }
    while ( v8 );
    v3 = a2;
  }
  if ( result < a3 - a2 && result > 0 )
  {
    v9 = &v3[result];
    v14 = v9;
    do
    {
      v10 = &v9[v5];
      v11 = v9;
      if ( v10 == v4 )
        v10 = a2;
      do
      {
        v12 = *v11;
        *v11 = *v10;
        v4 = a3;
        *v10 = v12;
        v13 = a3 - v10;
        v11 = v10;
        if ( v5 >= v13 )
          v10 = &a2[v5 - v13];
        else
          v10 += v5;
      }
      while ( v10 != v14 );
      --result;
      v9 = --v14;
    }
    while ( result > 0 );
  }
  return result;
}

//----- (004131B0) --------------------------------------------------------
int __fastcall sub_4131B0(int a1, void *a2, void **a3, int a4, int a5)
{
  _DWORD v6[8]; // [esp+0h] [ebp-20h] BYREF

  v6[4] = v6;
  v6[7] = 0;
  return sub_413220(a4, (int)a3, *a3, a2, (int)a3);
}

//----- (00413220) --------------------------------------------------------
int __userpurge sub_413220@<eax>(int a1@<eax>, int a2@<esi>, void *a3, void *Src, int a5)
{
  int result; // eax
  unsigned int v6; // edx
  int v7; // eax
  char *v8; // edx
  unsigned int v9; // eax
  char *v10; // eax
  char *v11; // ebx
  size_t v12; // edi
  char *v13; // eax
  char *v14; // eax
  int v15; // edi
  int v16; // edi
  int v17; // [esp+0h] [ebp-Ch]
  int v18; // [esp+4h] [ebp-8h]
  char *v19; // [esp+8h] [ebp-4h]

  result = (a1 - (int)Src) >> 1;
  v6 = result;
  v18 = result;
  v17 = result;
  if ( result )
  {
    v7 = (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 1;
    if ( 0x7FFFFFFF - v7 < v6 )
      std::_Xlength_error("vector<T> too long");
    v8 = (char *)(v7 + v6);
    v9 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)a2) >> 1;
    if ( v9 >= (unsigned int)v8 )
    {
      v16 = 2 * v18;
      memcpy(*(void **)(a2 + 4), Src, 2 * v18);
      result = *(_DWORD *)(a2 + 4);
      if ( a3 != (void *)result && result != 2 * v18 + result )
        result = sub_413110(result, a3, (__int16 *)(v16 + result));
      *(_DWORD *)(a2 + 4) += v16;
    }
    else
    {
      if ( 0x7FFFFFFF - (v9 >> 1) >= v9 )
      {
        v10 = (char *)((v9 >> 1) + v9);
        v19 = v10;
      }
      else
      {
        v19 = 0;
        v10 = 0;
      }
      if ( v10 < v8 )
      {
        v19 = v8;
        v10 = v8;
      }
      v11 = (char *)sub_4091E0(v10);
      v12 = 2 * (((int)a3 - *(_DWORD *)a2) >> 1);
      v13 = (char *)memcpy(v11, *(const void **)a2, v12) + v12;
      v14 = (char *)memcpy(v13, Src, 2 * v18);
      memcpy(&v14[2 * v18], a3, 2 * ((*(_DWORD *)(a2 + 4) - (int)a3) >> 1));
      v15 = ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 1) + v17;
      if ( *(_DWORD *)a2 )
        operator delete(*(void **)a2);
      result = (int)&v11[2 * (_DWORD)v19];
      *(_DWORD *)a2 = v11;
      *(_DWORD *)(a2 + 8) = result;
      *(_DWORD *)(a2 + 4) = &v11[2 * v15];
    }
  }
  return result;
}

//----- (00413350) --------------------------------------------------------
_DWORD *__thiscall sub_413350(void *this, _DWORD *a2)
{
  void *v2; // edx

  v2 = *(void **)(*(_DWORD *)this + 24);
  if ( !v2 )
    v2 = (void *)(*(_DWORD *)this + 28);
  a2[5] = 15;
  a2[4] = 0;
  *(_BYTE *)a2 = 0;
  sub_407C00(a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (004133A0) --------------------------------------------------------
_DWORD *__thiscall sub_4133A0(_DWORD *this, int a2, size_t Size, char a4)
{
  size_t v5; // eax
  void *v6; // edi
  unsigned int v7; // ecx
  unsigned int v8; // eax
  _DWORD *v9; // ecx
  _DWORD *result; // eax
  _DWORD *v11; // eax
  bool v12; // cf

  v5 = this[4];
  if ( v5 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( -1 - v5 <= Size )
    std::_Xlength_error("string too long");
  if ( !Size )
    return this;
  v6 = (void *)(v5 + Size);
  if ( v5 + Size == -1 )
    std::_Xlength_error("string too long");
  v7 = this[5];
  if ( v7 < (unsigned int)v6 )
  {
    sub_4079E0((int)this, v6, v5);
    if ( v6 )
    {
LABEL_10:
      v8 = this[5];
      if ( v8 < 0x10 )
        v9 = this;
      else
        v9 = (_DWORD *)*this;
      if ( v8 < 0x10 )
        v11 = this;
      else
        v11 = (_DWORD *)*this;
      memcpy((char *)v11 + a2 + Size, (char *)v9 + a2, this[4] - a2);
      sub_4077D0(this, a2, Size, a4);
      v12 = this[5] < 0x10u;
      this[4] = v6;
      if ( !v12 )
      {
        *((_BYTE *)v6 + *this) = 0;
        return this;
      }
      *((_BYTE *)v6 + (_DWORD)this) = 0;
    }
    return this;
  }
  if ( v6 )
    goto LABEL_10;
  this[4] = 0;
  if ( v7 < 0x10 )
  {
    result = this;
    *(_BYTE *)this = 0;
  }
  else
  {
    *(_BYTE *)*this = 0;
    return this;
  }
  return result;
}

//----- (004134A0) --------------------------------------------------------
char *__thiscall sub_4134A0(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::wostream::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return v2;
}
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (004134F0) --------------------------------------------------------
int __thiscall sub_4134F0(int *this)
{
  int result; // eax
  _DWORD v2[8]; // [esp+0h] [ebp-20h] BYREF

  v2[4] = v2;
  v2[7] = 0;
  result = *this;
  if ( (*((_BYTE *)this + *(_DWORD *)(*this + 4) + 20) & 2) != 0 )
    return sub_408280((int)this);
  return result;
}

//----- (00413550) --------------------------------------------------------
int __stdcall sub_413550(int **a1)
{
  int result; // eax

  if ( !__uncaught_exception() )
    sub_4134F0(*a1);
  result = *(int *)((char *)*a1 + *(_DWORD *)(**a1 + 4) + 56);
  if ( result )
    return (*(int (**)(void))(*(_DWORD *)result + 8))();
  return result;
}

//----- (004135E0) --------------------------------------------------------
void *__thiscall sub_4135E0(void *this, char a2)
{
  sub_4978E0((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00413610) --------------------------------------------------------
void *__thiscall sub_413610(void *this, char a2)
{
  *(_DWORD *)this = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (00413640) --------------------------------------------------------
void __thiscall sub_413640(void **this)
{
  void **v1; // edi
  bool v2; // cf
  unsigned int v3; // ebx
  _DWORD *v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  unsigned int v9; // edi
  void **v10; // esi
  int **v11; // eax
  int v12; // ecx
  int v13; // eax
  void **v14; // eax
  void *v15; // ecx
  int v16; // ecx
  int ***v17; // esi
  void **v18; // esi
  unsigned int v19; // ebx
  int pExceptionObject[3]; // [esp+10h] [ebp-168h] BYREF
  char *v21; // [esp+1Ch] [ebp-15Ch] BYREF
  void **v22; // [esp+20h] [ebp-158h]
  void *v23; // [esp+24h] [ebp-154h] BYREF
  char *v24; // [esp+28h] [ebp-150h]
  _DWORD v25[3]; // [esp+30h] [ebp-148h] BYREF
  char v26; // [esp+3Ch] [ebp-13Ch] BYREF
  int **v27; // [esp+150h] [ebp-28h] BYREF
  int v28; // [esp+174h] [ebp-4h]

  v1 = this;
  v2 = (unsigned int)this[1] < 2;
  v22 = this;
  if ( !v2 )
  {
    v3 = 0;
    v24 = 0;
    v4 = operator new(0x24u);
    if ( !v4 )
    {
      v21 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v4 = v4;
    v23 = v4;
    v4[1] = v4;
    v28 = 0;
    `eh vector constructor iterator'(v25, 0xCu, 26, sub_40A0B0, sub_40A110);
    LOBYTE(v28) = 1;
    if ( v1[1] )
    {
      do
      {
        v5 = **(_DWORD **)*v1;
        v6 = *(_DWORD *)*v1;
        v7 = *(_DWORD *)v23;
        if ( &v23 != v1 )
        {
          if ( v24 == (char *)153391688 )
            std::_Xlength_error("list<T> too long");
          ++v24;
          v1[1] = (char *)v1[1] - 1;
        }
        **(_DWORD **)(v6 + 4) = v5;
        **(_DWORD **)(v5 + 4) = v7;
        **(_DWORD **)(v7 + 4) = v6;
        v8 = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v7 + 4) = *(_DWORD *)(v5 + 4);
        v9 = 0;
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(v6 + 4);
        *(_DWORD *)(v6 + 4) = v8;
        if ( !v3 )
          goto LABEL_15;
        v10 = (void **)v25;
        do
        {
          if ( !v10[1] )
            break;
          sub_413AA0((int ***)v10, (int ***)&v23);
          if ( v10 != &v23 )
          {
            v11 = (int **)*v10;
            v12 = (int)v24;
            *v10 = v23;
            v23 = v11;
            v13 = (int)v10[1];
            v10[1] = (void *)v12;
            v24 = (char *)v13;
          }
          ++v9;
          v10 += 3;
        }
        while ( v9 < v3 );
        if ( v9 == 25 )
        {
          sub_413AA0(&v27, (int ***)&v23);
        }
        else
        {
LABEL_15:
          v14 = (void **)&v25[3 * v9];
          if ( v14 != &v23 )
          {
            v15 = *v14;
            *v14 = v23;
            v23 = v15;
            v16 = (int)v14[1];
            v14[1] = v24;
            v24 = (char *)v16;
          }
          if ( v9 == v3 )
            ++v3;
        }
        v1 = v22;
      }
      while ( v22[1] );
    }
    if ( v3 > 1 )
    {
      v17 = (int ***)&v26;
      v22 = (void **)(v3 - 1);
      do
      {
        sub_413AA0(v17, v17 - 3);
        v17 += 3;
        v22 = (void **)((char *)v22 - 1);
      }
      while ( v22 );
    }
    v18 = &v23 + 3 * v3;
    if ( v1 != v18 )
    {
      v19 = (unsigned int)v18[1];
      if ( v19 )
        sub_413950(v19, (int)v1, (int)v18, *(_DWORD *)*v1, *(_DWORD *)*v18, (int)*v18);
    }
    LOBYTE(v28) = 0;
    `eh vector destructor iterator'(v25, 0xCu, 26, sub_40A110);
    sub_40A140((int)&v23);
    operator delete(v23);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004138C0) --------------------------------------------------------
int *__usercall sub_4138C0@<eax>(unsigned __int16 *a1@<ebx>, int *a2, int *a3, int *a4)
{
  int *v4; // eax
  unsigned int v5; // ecx
  int *v6; // edx
  unsigned __int16 *v7; // edx
  _DWORD v9[4]; // [esp+Ch] [ebp-10h] BYREF

  v4 = a3;
  a2[5] = 7;
  a2[4] = 0;
  *(_WORD *)a2 = 0;
  v9[3] = 0;
  v5 = a3[5];
  if ( v5 < 8 )
    v6 = a3;
  else
    v6 = (int *)*a3;
  v7 = (unsigned __int16 *)v6 + a3[4];
  if ( v5 >= 8 )
    v4 = (int *)*a3;
  sub_413C10((unsigned __int16 *)v4, a1, v9, a2, v7, a4);
  return a2;
}

//----- (00413950) --------------------------------------------------------
int __userpurge sub_413950@<eax>(unsigned int a1@<eax>, int a2@<edx>, int a3@<esi>, int a4, int a5, int a6)
{
  int v6; // ecx
  int v7; // ecx
  int result; // eax

  if ( a2 != a3 )
  {
    v6 = *(_DWORD *)(a2 + 4);
    if ( 153391688 - v6 < a1 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a2 + 4) = a1 + v6;
    *(_DWORD *)(a3 + 4) -= a1;
  }
  **(_DWORD **)(a5 + 4) = a6;
  **(_DWORD **)(a6 + 4) = a4;
  **(_DWORD **)(a4 + 4) = a5;
  v7 = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a6 + 4);
  result = a6;
  *(_DWORD *)(a6 + 4) = *(_DWORD *)(a5 + 4);
  *(_DWORD *)(a5 + 4) = v7;
  return result;
}

//----- (004139C0) --------------------------------------------------------
bool __cdecl sub_4139C0(int a1, int a2, int *a3, int a4)
{
  bool v5; // al
  int v6; // edi
  bool v7; // bl
  int v8; // eax
  int v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // esi
  char v11[4]; // [esp+14h] [ebp-254h] BYREF
  char v12[564]; // [esp+18h] [ebp-250h] BYREF
  int v13; // [esp+24Ch] [ebp-1Ch]
  int v14; // [esp+264h] [ebp-4h]

  if ( !*a3 )
    return 0;
  sub_40E5C0(*a3, a4, (int)v12, a1, a2, *(_DWORD *)(*a3 + 24), *(_DWORD *)(*a3 + 20));
  v14 = 0;
  v5 = sub_40E970(1, 0, (int)v12);
  v14 = -1;
  v6 = v13;
  v7 = v5;
  if ( v13 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
    v8 = *(_DWORD *)(v6 + 4);
    if ( v8 && v8 != -1 )
      *(_DWORD *)(v6 + 4) = v8 - 1;
    v9 = -(*(_DWORD *)(v6 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v11);
    v10 = (void (__thiscall ***)(_DWORD, int))(v6 & v9);
    if ( v10 )
      (**v10)(v10, 1);
  }
  return v7;
}
// 4139C0: using guessed type char var_254[4];

//----- (00413AA0) --------------------------------------------------------
void __stdcall sub_413AA0(int ***a1, int ***a2)
{
  int ***v2; // ebx
  int ***v3; // edx
  int **v4; // ecx
  int *v5; // esi
  int **v6; // eax
  int *v7; // edi
  const WCHAR *v8; // ecx
  const WCHAR *v9; // eax
  int v10; // ebx
  PCWSTR psz2[5]; // [esp+10h] [ebp-54h] BYREF
  unsigned int v12; // [esp+24h] [ebp-40h]
  PCWSTR psz1[4]; // [esp+2Ch] [ebp-38h] BYREF
  int v14; // [esp+3Ch] [ebp-28h]
  unsigned int v15; // [esp+40h] [ebp-24h]
  int **v16; // [esp+48h] [ebp-1Ch]
  int **v17; // [esp+4Ch] [ebp-18h]
  int *v18; // [esp+50h] [ebp-14h]
  bool v19; // [esp+57h] [ebp-Dh]
  int v20; // [esp+60h] [ebp-4h]

  v2 = a2;
  v3 = a1;
  if ( a2 != a1 )
  {
    v4 = *a1;
    v5 = **a1;
    v6 = *a2;
    v7 = **a2;
    v16 = v4;
    v18 = v5;
    v17 = v6;
    if ( v5 == (int *)v4 )
    {
LABEL_19:
      if ( v7 != (int *)v6 )
        sub_413950((unsigned int)v2[1], (int)v3, (int)v2, (int)v4, (int)v7, (int)v6);
    }
    else
    {
      while ( v7 != (int *)v6 )
      {
        LOWORD(psz2[0]) = 0;
        v12 = 7;
        psz2[4] = 0;
        sub_4090E0((int)psz2, v5 + 2, 0, 0xFFFFFFFF);
        v20 = 0;
        v15 = 7;
        v14 = 0;
        LOWORD(psz1[0]) = 0;
        sub_4090E0((int)psz1, v7 + 2, 0, 0xFFFFFFFF);
        v20 = -1;
        v8 = psz2[0];
        if ( v12 < 8 )
          v8 = (const WCHAR *)psz2;
        v9 = psz1[0];
        if ( v15 < 8 )
          v9 = (const WCHAR *)psz1;
        v19 = StrCmpLogicalW(v9, v8) <= 0;
        if ( v15 >= 8 )
          operator delete((void *)psz1[0]);
        v15 = 7;
        v14 = 0;
        LOWORD(psz1[0]) = 0;
        if ( v12 >= 8 )
          operator delete((void *)psz2[0]);
        if ( v19 )
        {
          v10 = *v7;
          sub_413950(1u, (int)a1, (int)a2, (int)v5, (int)v7, *v7);
          v7 = (int *)v10;
        }
        else
        {
          v18 = (int *)*v5;
        }
        v6 = v17;
        if ( v18 == (int *)v16 )
        {
          v4 = v16;
          v2 = a2;
          v3 = a1;
          goto LABEL_19;
        }
        v5 = v18;
      }
    }
  }
}

//----- (00413C10) --------------------------------------------------------
_DWORD *__usercall sub_413C10@<eax>(
        unsigned __int16 *a1@<ecx>,
        unsigned __int16 *a2@<ebx>,
        _DWORD *a3,
        int *a4,
        unsigned __int16 *a5,
        int *a6)
{
  unsigned __int16 *v6; // esi
  unsigned int v7; // ecx
  unsigned __int16 *v8; // eax
  unsigned __int16 *v9; // edx
  unsigned __int16 *v10; // eax
  int **v11; // eax
  unsigned __int16 *v12; // eax
  unsigned __int16 *v13; // edx
  unsigned __int16 *v14; // eax
  int *v15; // edi
  int *v16; // ecx
  unsigned __int16 *v17; // edx
  int *v18; // ecx
  int v19; // eax
  int v21; // [esp+Ch] [ebp-54h] BYREF
  void *v22; // [esp+10h] [ebp-50h]
  int v23; // [esp+14h] [ebp-4Ch]
  int v24; // [esp+18h] [ebp-48h]
  unsigned __int16 *v25; // [esp+20h] [ebp-40h]
  unsigned __int16 *v26; // [esp+24h] [ebp-3Ch]
  char v27; // [esp+28h] [ebp-38h]
  int v28; // [esp+2Ch] [ebp-34h]
  int v29; // [esp+30h] [ebp-30h]
  char v30; // [esp+34h] [ebp-2Ch]
  int v31[2]; // [esp+38h] [ebp-28h] BYREF
  char v32; // [esp+40h] [ebp-20h]
  int *v33; // [esp+44h] [ebp-1Ch] BYREF
  int *v34; // [esp+48h] [ebp-18h] BYREF
  int *v35; // [esp+4Ch] [ebp-14h] BYREF
  int v36; // [esp+50h] [ebp-10h]
  int v37; // [esp+5Ch] [ebp-4h]

  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31[0] = 0;
  v31[1] = 0;
  v32 = 0;
  v37 = 0;
  v36 = 0;
  v6 = a1;
  if ( sub_413DD0(a5, a1, &v21, a6, 0, (int)a1) )
  {
    while ( 1 )
    {
      sub_413F80(v25, &v35, v26, a4);
      v7 = *((_DWORD *)a2 + 5);
      if ( (v36 & 0x400) != 0 )
      {
        if ( v7 < 8 )
          v8 = a2;
        else
          v8 = *(unsigned __int16 **)a2;
        v9 = &v8[*((_DWORD *)a2 + 4)];
        if ( v7 < 8 )
          v10 = a2;
        else
          v10 = *(unsigned __int16 **)a2;
        v11 = sub_413FF0((int)&v21, &v34, v35, v10, v9);
      }
      else
      {
        if ( v7 < 8 )
          v12 = a2;
        else
          v12 = *(unsigned __int16 **)a2;
        v13 = &v12[*((_DWORD *)a2 + 4)];
        if ( v7 < 8 )
          v14 = a2;
        else
          v14 = *(unsigned __int16 **)a2;
        v11 = sub_414110(&v33, (int)&v21, v35, v14, v13);
      }
      v15 = (int *)v22;
      a4 = *v11;
      v16 = v31;
      if ( (v23 - (int)v22) / 12 )
        v16 = (int *)v22;
      v6 = (unsigned __int16 *)v16[1];
      v17 = a5;
      if ( v6 == a5 )
        break;
      v18 = v31;
      if ( (v23 - (int)v22) / 12 )
        v18 = (int *)v22;
      else
        v15 = v31;
      if ( *v18 == v15[1] )
      {
        v19 = 0x2000;
      }
      else
      {
        v19 = 0;
        v36 |= 0x100u;
      }
      if ( !sub_413DD0(a5, v6, &v21, a6, v36 | v19, (int)v6) )
        goto LABEL_27;
    }
  }
  else
  {
LABEL_27:
    v15 = (int *)v22;
    v17 = a5;
  }
  sub_413F80(v6, &v35, v17, a4);
  *a3 = v35;
  if ( v15 )
    operator delete(v15);
  return a3;
}

//----- (00413DD0) --------------------------------------------------------
char __usercall sub_413DD0@<al>(
        unsigned __int16 *a1@<edx>,
        unsigned __int16 *a2@<ecx>,
        _DWORD *a3,
        int *a4,
        int a5,
        int a6)
{
  int v6; // eax
  unsigned __int16 *v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // esi
  int v15; // [esp-8h] [ebp-278h]
  int v16; // [esp-4h] [ebp-274h]
  unsigned __int16 *v17; // [esp+14h] [ebp-25Ch] BYREF
  unsigned __int16 *v18; // [esp+18h] [ebp-258h]
  char v19; // [esp+1Fh] [ebp-251h]
  char v20[536]; // [esp+20h] [ebp-250h] BYREF
  unsigned __int16 *v21; // [esp+238h] [ebp-38h]
  unsigned int v22; // [esp+244h] [ebp-2Ch]
  int v23; // [esp+254h] [ebp-1Ch]
  int v24; // [esp+26Ch] [ebp-4h]

  v6 = *a4;
  v18 = a2;
  if ( !v6 )
    return 0;
  v16 = *(_DWORD *)(v6 + 20);
  v15 = *(_DWORD *)(v6 + 24);
  v17 = a2;
  v19 = 0;
  sub_4143A0(v6, (int)a1, a5, (int)v20, (int)a2, v15, v16);
  v24 = 0;
  if ( sub_414860(0, (int)a3, (int)v20) )
    goto LABEL_12;
  if ( v18 != a1 && (a5 & 0x40) == 0 )
  {
    v22 = v22 & 0xFFFFDEFF | 0x100;
    v9 = sub_414550((int)v20, v18 + 1, a1, 0);
    v18 = v9;
    if ( v9 != a1 )
    {
      while ( 1 )
      {
        v21 = v9;
        if ( sub_414860(0, (int)a3, (int)v20) )
          goto LABEL_12;
        v18 = sub_414550((int)v20, v18 + 1, a1, 0);
        if ( v18 == a1 )
          break;
        v9 = v18;
      }
    }
    v21 = a1;
    if ( sub_414860(0, (int)a3, (int)v20) )
    {
LABEL_12:
      v19 = 1;
      if ( a3 )
      {
        v10 = (int)v17;
        *a3 = a6;
        a3[5] = v10;
      }
    }
  }
  v24 = -1;
  v11 = v23;
  if ( v23 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v17, 0);
    v12 = *(_DWORD *)(v11 + 4);
    if ( v12 && v12 != -1 )
      *(_DWORD *)(v11 + 4) = v12 - 1;
    v13 = -(*(_DWORD *)(v11 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v17);
    v14 = (void (__thiscall ***)(_DWORD, int))(v11 & v13);
    if ( v14 )
      (**v14)(v14, 1);
  }
  return v19;
}

//----- (00413F80) --------------------------------------------------------
int **__usercall sub_413F80@<eax>(unsigned __int16 *a1@<eax>, int **a2, unsigned __int16 *a3, int *a4)
{
  int **result; // eax
  unsigned int v6; // edx
  int *v7; // eax
  int v8; // eax
  int *v9; // edx

  result = a2;
  if ( a1 == a3 )
  {
    *a2 = a4;
  }
  else
  {
    do
    {
      v6 = a4[5];
      if ( v6 < 8 )
        v7 = a4;
      else
        v7 = (int *)*a4;
      v8 = (int)v7 + 2 * a4[4];
      if ( v6 < 8 )
        v9 = a4;
      else
        v9 = (int *)*a4;
      if ( v8 )
        v8 = (v8 - (int)v9) >> 1;
      sub_414440(a4, v8, 1u, *a1++);
    }
    while ( a1 != a3 );
    result = a2;
    *a2 = a4;
  }
  return result;
}

//----- (00413FF0) --------------------------------------------------------
int **__usercall sub_413FF0@<eax>(int a1@<edi>, int **a2, int *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 *v5; // eax
  int **v6; // ebx
  unsigned __int16 *v7; // esi
  int *v8; // ecx
  int v9; // edx
  unsigned __int16 v10; // si
  unsigned int v11; // edx
  int v12; // eax
  unsigned int v13; // edx
  unsigned __int16 **v14; // eax
  int v15; // eax
  int v16; // edx
  int *v18; // [esp+8h] [ebp-8h] BYREF
  int *v19; // [esp+Ch] [ebp-4h] BYREF

  v5 = a4;
  v6 = a2;
  v7 = a5;
  if ( a4 == a5 )
  {
    *a2 = a3;
    return a2;
  }
  else
  {
    v8 = a3;
    do
    {
      v9 = *v5;
      if ( v9 == 38 )
      {
        sub_413F80(**(unsigned __int16 ***)(a1 + 4), &v19, *(unsigned __int16 **)(*(_DWORD *)(a1 + 4) + 4), v8);
        v8 = v19;
        v5 = a4 + 1;
        a3 = v19;
        ++a4;
      }
      else
      {
        if ( v9 != 92 )
          goto LABEL_6;
        if ( ++v5 == v7 )
          break;
        v13 = *v5;
        if ( (unsigned __int16)v13 >= 0x30u && v13 <= 0x39 )
        {
          a4 = v5 + 1;
          v14 = (unsigned __int16 **)(*(_DWORD *)(a1 + 4) + 4 * (3 * *v5 - 144));
          sub_413F80(*v14, &v18, v14[1], v8);
          v8 = v18;
          a3 = v18;
        }
        else
        {
LABEL_6:
          a4 = v5 + 1;
          v10 = *v5;
          v11 = v8[5];
          if ( v11 < 8 )
            v12 = (int)v8;
          else
            v12 = *v8;
          v15 = v12 + 2 * v8[4];
          if ( v11 < 8 )
            v16 = (int)v8;
          else
            v16 = *v8;
          if ( v15 )
            v15 = (v15 - v16) >> 1;
          sub_414440(v8, v15, 1u, v10);
          v6 = a2;
          v8 = a3;
        }
        v5 = a4;
      }
      v7 = a5;
    }
    while ( v5 != a5 );
    *v6 = v8;
    return v6;
  }
}

//----- (00414110) --------------------------------------------------------
int **__cdecl sub_414110(int **a1, int a2, int *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 *v5; // edx
  int *v6; // ecx
  unsigned __int16 *v7; // esi
  unsigned int v8; // edx
  unsigned __int16 v9; // si
  int v10; // eax
  int v11; // eax
  int *v12; // edx
  unsigned __int16 *v13; // esi
  unsigned int v14; // eax
  unsigned int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // edi
  unsigned __int16 *v20; // eax
  unsigned int v21; // eax
  unsigned __int16 *v22; // eax
  int v23; // ebx
  int **result; // eax
  int *v25; // [esp+4h] [ebp-14h] BYREF
  int *v26; // [esp+8h] [ebp-10h] BYREF
  int v27; // [esp+Ch] [ebp-Ch] BYREF
  int *v28; // [esp+10h] [ebp-8h] BYREF
  int *v29; // [esp+14h] [ebp-4h] BYREF
  unsigned __int16 *v30; // [esp+2Ch] [ebp+14h]

  v5 = a5;
  v6 = a3;
  v7 = a4;
  if ( a4 != a5 )
  {
    while ( 1 )
    {
      if ( *v7 != 36 )
      {
        v30 = v7 + 1;
        v8 = v6[5];
        v9 = *v7;
        if ( v8 < 8 )
          v10 = (int)v6;
        else
          v10 = *v6;
        v11 = v10 + 2 * v6[4];
        if ( v8 < 8 )
          v12 = v6;
        else
          v12 = (int *)*v6;
        if ( v11 )
          sub_414440(v6, (v11 - (int)v12) >> 1, 1u, v9);
        else
          sub_414440(v6, 0, 1u, v9);
        v6 = a3;
        goto LABEL_39;
      }
      v13 = v7 + 1;
      if ( v13 == v5 )
        goto LABEL_41;
      v14 = *v13;
      if ( v14 == 36 )
      {
        v15 = v6[5];
        if ( v15 < 8 )
          v16 = (int)v6;
        else
          v16 = *v6;
        v17 = v16 + 2 * v6[4];
        if ( v15 < 8 )
          v18 = (int)v6;
        else
          v18 = *v6;
        if ( v17 )
          v17 = (v17 - v18) >> 1;
        sub_414440(v6, v17, 1u, 0x24u);
        v6 = a3;
        v7 = v13 + 1;
        goto LABEL_40;
      }
      if ( v14 == 96 )
      {
        sub_413F80(*(unsigned __int16 **)(a2 + 20), &v29, *(unsigned __int16 **)(a2 + 24), v6);
        v6 = v29;
        v7 = v13 + 1;
        a3 = v29;
      }
      else if ( v14 == 39 )
      {
        sub_413F80(*(unsigned __int16 **)(a2 + 32), &v28, *(unsigned __int16 **)(a2 + 36), v6);
        v6 = v28;
        v7 = v13 + 1;
        a3 = v28;
      }
      else
      {
        if ( v14 == 38 )
        {
          v19 = 0;
          v7 = v13 + 1;
          v30 = v7;
        }
        else
        {
          if ( (unsigned __int16)v14 < 0x30u || v14 > 0x39 )
          {
            v27 = 36;
            v26 = v6;
            sub_414350((unsigned __int16 *)&v27, &v26);
            v30 = v13 + 1;
            v26 = a3;
            sub_414350(v13, &v26);
            v6 = a3;
            goto LABEL_39;
          }
          v20 = v13;
          v7 = v13 + 1;
          v30 = v7;
          v19 = *v20 - 48;
          if ( v7 != v5 )
          {
            v21 = *v7;
            if ( (unsigned __int16)v21 >= 0x30u && v21 <= 0x39 )
            {
              v22 = v7++;
              v30 = v7;
              v19 = *v22 + 10 * v19 - 48;
            }
          }
          if ( v19 < 0 )
            goto LABEL_40;
        }
        v23 = *(_DWORD *)(a2 + 4);
        if ( v19 < (*(_DWORD *)(a2 + 8) - v23) / 12 )
        {
          sub_413F80(*(unsigned __int16 **)(v23 + 12 * v19), &v25, *(unsigned __int16 **)(v23 + 12 * v19 + 4), v6);
          v6 = v25;
          a3 = v25;
LABEL_39:
          v7 = v30;
        }
      }
LABEL_40:
      v5 = a5;
      if ( v7 == a5 )
      {
LABEL_41:
        result = a1;
        *a1 = v6;
        return result;
      }
    }
  }
  result = a1;
  *a1 = a3;
  return result;
}

//----- (00414350) --------------------------------------------------------
int **__usercall sub_414350@<eax>(unsigned __int16 *a1@<eax>, int **a2@<esi>)
{
  int *v2; // ecx
  unsigned int v3; // edx
  unsigned __int16 v4; // di
  int *v5; // eax
  char *v6; // eax
  int *v7; // edx

  v2 = *a2;
  v3 = (*a2)[5];
  v4 = *a1;
  if ( v3 < 8 )
    v5 = *a2;
  else
    v5 = (int *)*v2;
  v6 = (char *)v5 + 2 * v2[4];
  if ( v3 < 8 )
    v7 = *a2;
  else
    v7 = (int *)*v2;
  if ( v6 )
    sub_414440(v2, (v6 - (char *)v7) >> 1, 1u, v4);
  else
    sub_414440(v2, 0, 1u, v4);
  return a2;
}

//----- (004143A0) --------------------------------------------------------
int __userpurge sub_4143A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>, int a5, char a6, int a7)
{
  char v7; // dl
  bool v8; // al
  int v9; // edi
  int v10; // eax

  *(_DWORD *)(a4 + 532) = a2;
  *(_DWORD *)(a4 + 536) = a5;
  *(_DWORD *)(a4 + 544) = a7;
  v7 = a6;
  *(_DWORD *)(a4 + 540) = a1;
  *(_DWORD *)(a4 + 548) = a3;
  *(_BYTE *)(a4 + 552) = 0;
  *(_BYTE *)(a4 + 554) = v7;
  v8 = (*(_BYTE *)(a1 + 8) & 8) != 0 && (a3 & 0x10) == 0;
  *(_BYTE *)(a4 + 555) = v8;
  *(_DWORD *)(a4 + 556) = 0;
  *(_DWORD *)(a4 + 560) = 0;
  *(_DWORD *)(a4 + 564) = std::locale::_Init();
  v9 = sub_426E4C();
  std::_Lockit::_Lockit((std::_Lockit *)&a5, 0);
  v10 = *(_DWORD *)(v9 + 4);
  if ( v10 != -1 )
    *(_DWORD *)(v9 + 4) = v10 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&a5);
  return a4;
}

//----- (00414440) --------------------------------------------------------
int *__thiscall sub_414440(int *this, unsigned int a2, unsigned int a3, unsigned __int16 a4)
{
  const void *v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // ecx
  unsigned int v8; // eax
  int *v9; // ecx
  int *result; // eax
  int *v11; // eax
  int v12; // edx
  bool v13; // cf

  v5 = (const void *)this[4];
  if ( (unsigned int)v5 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( -1 - (int)v5 <= a3 )
    std::_Xlength_error("string too long");
  if ( !a3 )
    return this;
  v6 = (unsigned int)v5 + a3;
  if ( (unsigned int)v5 + a3 > 0x7FFFFFFE )
    std::_Xlength_error("string too long");
  v7 = this[5];
  if ( v7 < v6 )
  {
    sub_409240((int)this, v6, v5);
    if ( v6 )
    {
LABEL_10:
      v8 = this[5];
      if ( v8 < 8 )
        v9 = this;
      else
        v9 = (int *)*this;
      if ( v8 < 8 )
        v11 = this;
      else
        v11 = (int *)*this;
      memcpy((char *)v11 + 2 * a2 + 2 * a3, (char *)v9 + 2 * a2, 2 * (this[4] - a2));
      sub_406B10(this, v12, a2, a3, a4);
      v13 = (unsigned int)this[5] < 8;
      this[4] = v6;
      if ( !v13 )
      {
        *(_WORD *)(*this + 2 * v6) = 0;
        return this;
      }
      *((_WORD *)this + v6) = 0;
    }
    return this;
  }
  if ( v6 )
    goto LABEL_10;
  this[4] = 0;
  if ( v7 < 8 )
  {
    result = this;
    *(_WORD *)this = 0;
  }
  else
  {
    *(_WORD *)*this = 0;
    return this;
  }
  return result;
}
// 414513: variable 'v12' is possibly undefined

//----- (00414550) --------------------------------------------------------
unsigned __int16 *__thiscall sub_414550(int this, unsigned __int16 *a2, unsigned __int16 *a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // edx
  unsigned __int16 *v6; // ebx
  int v8; // eax
  int v9; // edx
  unsigned __int16 *v10; // ecx
  unsigned __int16 *v11; // esi
  unsigned __int16 *v12; // eax
  int v13; // esi
  _DWORD *v14; // eax
  char v15; // al
  unsigned __int16 v16; // dx
  int v17; // eax
  bool v18; // zf
  int v19; // ecx
  _WORD *v20; // eax
  _WORD *i; // ecx
  char v22; // al
  int *v23; // eax
  int v24; // esi
  __int16 *v25; // eax
  int v26; // [esp+Ch] [ebp-8h]
  bool v28; // [esp+1Ch] [ebp+8h]
  __int16 v29; // [esp+1Ch] [ebp+8h]

  v4 = a4;
  v5 = (_DWORD *)this;
  if ( !a4 )
  {
    a4 = *(_DWORD *)(this + 540);
    v4 = a4;
  }
  v6 = a2;
  if ( a2 != a3 )
  {
    while ( 2 )
    {
      if ( v4 )
      {
        switch ( *(_DWORD *)(v4 + 4) )
        {
          case 1:
          case 8:
          case 9:
          case 0xD:
          case 0xE:
          case 0x14:
            a4 = *(_DWORD *)(v4 + 12);
            v4 = a4;
            continue;
          case 2:
            if ( (*(_BYTE *)(this + 548) & 1) != 0 )
              return a3;
            do
            {
              if ( *(v6 - 1) == 10 )
                break;
              ++v6;
            }
            while ( v6 != a3 );
            return v6;
          case 3:
            if ( (*(_BYTE *)(this + 548) & 2) != 0 )
              return a3;
            break;
          case 6:
            while ( 2 )
            {
              v8 = v5[137];
              v9 = v5[136];
              v10 = *(unsigned __int16 **)(v4 + 28);
              v28 = (v8 & 0x80) != 0;
              v11 = v6 + 1;
              if ( (v9 & 0x800) != 0 )
              {
                v12 = sub_4153D0((int)v6, v6 + 1, v10 + 1, (int *)(this + 556), v28);
              }
              else if ( (v9 & 0x100) != 0 )
              {
                v12 = sub_415600((int)v6, v6 + 1, v10, v10 + 1, this + 556, v28);
              }
              else
              {
                LOBYTE(v26) = 0;
                v12 = sub_4157B0((__int16 *)v10, v6, (__int16 *)v10 + 1, v11, v26, v28);
                v4 = a4;
              }
              if ( v12 != v6 )
                return v6;
              ++v6;
              if ( v11 != a3 )
              {
                v5 = (_DWORD *)this;
                continue;
              }
              break;
            }
            return v11;
          case 7:
            while ( 2 )
            {
              v13 = *v6;
              v14 = *(_DWORD **)(v4 + 20);
              v29 = *v6;
              if ( !v14 )
                goto LABEL_31;
              if ( sub_414E80((__int16 *)v6, (__int16 *)v6 + 1, v14) != (__int16 *)v6 )
              {
                v15 = 1;
                goto LABEL_56;
              }
              v5 = (_DWORD *)this;
LABEL_31:
              if ( !*(_DWORD *)(v4 + 32) )
                goto LABEL_37;
              if ( (v5[136] & 0x800) != 0 )
                LOWORD(v13) = sub_40EFA0(v5 + 139, v13);
              if ( sub_40FC50(*(_DWORD *)(v4 + 32), v13) )
              {
                v15 = 1;
                goto LABEL_56;
              }
              LOWORD(v13) = v29;
LABEL_37:
              v16 = v29;
              if ( dword_4EF7F8 > (unsigned __int16)v13 || (unsigned __int16)v29 >= 0x100u )
              {
                if ( *(_DWORD *)(v4 + 28) )
                {
                  v19 = *(_DWORD *)(v4 + 28);
                  v20 = *(_WORD **)(v19 + 8);
                  for ( i = &v20[*(_DWORD *)(v19 + 4)]; v20 != i; ++v20 )
                  {
                    if ( *v20 == v29 )
                      break;
                  }
                  if ( v20 != (_WORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 28) + 8) + 2
                                                                              * *(_DWORD *)(*(_DWORD *)(v4 + 28) + 4)) )
                  {
                    v15 = 1;
                    goto LABEL_56;
                  }
                }
                if ( *(_WORD *)(v4 + 36) )
                {
                  v22 = sub_40F010(this + 556, *(_WORD *)(v4 + 36), v29);
                  v4 = a4;
                  if ( v22 )
                  {
                    v15 = 1;
                    goto LABEL_56;
                  }
                  v16 = v29;
                }
                v23 = *(int **)(v4 + 40);
                if ( !v23 )
                  goto LABEL_55;
                v18 = sub_40FC80(v23, (void *)(this + 556), v16) == 0;
              }
              else
              {
                v17 = *(_DWORD *)(v4 + 24);
                if ( !v17 )
                  goto LABEL_55;
                v18 = ((unsigned __int8)(1 << (v13 & 7)) & *(_BYTE *)(((unsigned __int16)v13 >> 3) + v17)) == 0;
              }
              if ( !v18 )
              {
                v15 = 1;
                goto LABEL_56;
              }
LABEL_55:
              v15 = 0;
LABEL_56:
              if ( v15 != (*(_BYTE *)(v4 + 8) & 1) )
                return v6;
              if ( ++v6 != a3 )
              {
                v5 = (_DWORD *)this;
                continue;
              }
              return v6;
            }
          case 0xC:
          case 0x15:
            a4 = 0;
            v4 = 0;
            continue;
          case 0x10:
            v24 = v4;
            while ( v24 )
            {
              v25 = sub_414550((int)v5, a2, a3, *(_DWORD *)(v24 + 12));
              v24 = *(_DWORD *)(v24 + 24);
              a3 = (unsigned __int16 *)v25;
              if ( a2 == (unsigned __int16 *)v25 )
                break;
              v5 = (_DWORD *)this;
            }
            return a3;
          default:
            return v6;
        }
        while ( *v6 != 10 )
        {
          if ( ++v6 == a3 )
            return v6;
        }
      }
      break;
    }
  }
  return v6;
}
// 414675: variable 'v26' is possibly undefined
// 4EF7F8: using guessed type int dword_4EF7F8;

//----- (00414860) --------------------------------------------------------
bool __usercall sub_414860@<al>(char a1@<cl>, int a2@<ebx>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edx
  bool result; // al
  _DWORD *v6; // edi
  unsigned int v7; // ecx
  int v8; // eax
  _DWORD *v9; // edi
  unsigned int v10; // [esp+4h] [ebp-8h]
  _DWORD *v11; // [esp+8h] [ebp-4h]

  v3 = *(_DWORD *)(a3 + 536);
  v4 = *(_DWORD *)(a3 + 540);
  *(_DWORD *)(a3 + 528) = v3;
  *(_DWORD *)a3 = v3;
  *(_BYTE *)(a3 + 568) = a1;
  *(_DWORD *)(a3 + 4) = 0;
  *(_BYTE *)(a3 + 553) = a2 != 0;
  *(_BYTE *)(a3 + 552) = 0;
  result = sub_414990((int *)a3, v4, 0);
  if ( result )
  {
    if ( a2 )
    {
      v6 = (_DWORD *)(a2 + 4);
      sub_40F290(*(unsigned __int8 *)(a3 + 554), (int *)(a2 + 4));
      LOBYTE(v7) = 0;
      v10 = 0;
      if ( *(_BYTE *)(a3 + 554) )
      {
        v8 = 0;
        v11 = (_DWORD *)(a3 + 276);
        do
        {
          if ( ((1 << v7) & *(_DWORD *)(a3 + 268)) != 0 )
          {
            *(_BYTE *)(v8 + *v6 + 8) = 1;
            *(_DWORD *)(v8 + *v6) = *(v11 - 1);
            *(_DWORD *)(v8 + *v6 + 4) = *v11;
          }
          else
          {
            *(_BYTE *)(v8 + *v6 + 8) = 0;
            *(_DWORD *)(v8 + *v6) = *(_DWORD *)(a3 + 532);
            *(_DWORD *)(v8 + *v6 + 4) = *(_DWORD *)(a3 + 532);
          }
          v11 += 2;
          v7 = v10 + 1;
          v8 += 12;
          v10 = v7;
        }
        while ( v7 < *(unsigned __int8 *)(a3 + 554) );
      }
      v9 = (_DWORD *)*v6;
      *(_DWORD *)a2 = *(_DWORD *)(a3 + 528);
      *(_BYTE *)(a2 + 28) = 1;
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a3 + 528);
      *(_DWORD *)(a2 + 24) = *v9;
      *(_BYTE *)(a2 + 40) = 1;
      *(_DWORD *)(a2 + 32) = v9[1];
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(a3 + 532);
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a3 + 532);
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 532);
    }
    return 1;
  }
  return result;
}

//----- (00414990) --------------------------------------------------------
BOOL __thiscall sub_414990(int *this, int a2, int a3)
{
  int v3; // edi
  int *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v8; // al
  char v9; // bl
  int v10; // eax
  char v11; // al
  unsigned __int16 *v12; // ecx
  int v13; // eax
  unsigned __int16 *v14; // eax
  bool v15; // zf
  int v16; // eax
  int v17; // eax
  __int16 *v18; // ecx
  int v19; // eax
  unsigned __int16 *v20; // edx
  unsigned __int16 *v21; // ecx
  __int16 *v22; // ebx
  char v23; // al
  int v24; // ecx
  int v26; // edx
  int v27; // [esp-8h] [ebp-40h]
  int v28; // [esp-8h] [ebp-40h]
  bool v29; // [esp+Fh] [ebp-29h]
  char *v31; // [esp+14h] [ebp-24h] BYREF
  char *v32; // [esp+1Ch] [ebp-1Ch]
  int v33; // [esp+20h] [ebp-18h]
  int v34; // [esp+28h] [ebp-10h]
  int pExceptionObject[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v3 = a2;
  v4 = this;
  v29 = 0;
  if ( !a2 )
    return !v29;
  while ( 2 )
  {
    v5 = *(_DWORD *)(v3 + 4);
    switch ( v5 )
    {
      case 1:
      case 8:
      case 9:
      case 17:
      case 20:
        goto LABEL_64;
      case 2:
        v6 = v4[137];
        if ( (v6 & 0x101) == 1 )
          goto LABEL_69;
        if ( (v6 & 0x100) != 0 || *v4 != v4[132] )
          v29 = *(_WORD *)(*v4 - 2) != 10;
        goto LABEL_64;
      case 3:
        if ( (v4[137] & 2) == 0 && (*v4 == v4[133] || *(_WORD *)*v4 == 10) )
          goto LABEL_64;
        goto LABEL_69;
      case 4:
        v7 = v4[137];
        if ( (v7 & 4) != 0 && *v4 == v4[132] || (v7 & 8) != 0 && *v4 == v4[133] )
        {
          v8 = 0;
        }
        else
        {
          v9 = (*v4 != v4[132] || (v7 & 0x100) != 0)
            && *(unsigned __int16 *)(*v4 - 2) == (char)*(_WORD *)(*v4 - 2)
            && strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", *(unsigned __int16 *)(*v4 - 2));
          v11 = 0;
          if ( *v4 != v4[133] )
          {
            v10 = *(unsigned __int16 *)*v4;
            if ( v10 == (char)v10 )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v10) )
                v11 = 1;
            }
          }
          v8 = v9 != v11;
        }
        if ( v8 != (*(_BYTE *)(v3 + 8) & 1) )
          goto LABEL_64;
        goto LABEL_69;
      case 5:
        v12 = (unsigned __int16 *)*v4;
        if ( *v4 == v4[133] )
          goto LABEL_69;
        v13 = *v12;
        if ( v13 == 10 || v13 == 13 )
          goto LABEL_69;
        *v4 = (int)(v12 + 1);
        goto LABEL_64;
      case 6:
        v14 = sub_414E20(
                (v4[137] & 0x80) != 0,
                *(unsigned __int16 **)(v3 + 28),
                v4[136],
                (_WORD *)*v4,
                (unsigned __int16 *)v4[133],
                (unsigned __int16 *)(*(_DWORD *)(v3 + 28) + 2 * *(_DWORD *)(v3 + 24)),
                v4 + 139);
        if ( v14 == (unsigned __int16 *)*v4 )
          goto LABEL_69;
        *v4 = (int)v14;
        goto LABEL_64;
      case 7:
        if ( *v4 == v4[133] || !sub_4151A0((__int16 **)v4, v3) )
          goto LABEL_69;
        v29 = 0;
        goto LABEL_65;
      case 10:
      case 11:
        v31 = (char *)*v4;
        v15 = v5 == 11;
        v16 = v4[1];
        v27 = *(_DWORD *)(v3 + 20);
        v32 = v31;
        v33 = v16;
        if ( (unsigned __int8)sub_414990(v4, v27, 0) != v15 )
        {
          *v4 = (int)v31;
LABEL_64:
          if ( v29 )
            goto LABEL_70;
LABEL_65:
          if ( !v3 )
            return !v29;
          v3 = *(_DWORD *)(v3 + 12);
          if ( !v3 )
            return !v29;
          continue;
        }
        v26 = v33;
        *v4 = (int)v32;
        v4[1] = v26;
LABEL_69:
        v29 = 1;
LABEL_70:
        if ( *((char *)v4 + 548) >= 0 || *v4 != v4[133] )
          return !v29;
        qmemcpy(v4 + 66, this, 0x108u);
        return 1;
      case 12:
        goto LABEL_63;
      case 13:
        v4[2 * *(_DWORD *)(v3 + 20) + 2] = *v4;
        goto LABEL_64;
      case 14:
        v17 = *(_DWORD *)(v3 + 20);
        if ( *((_BYTE *)v4 + 553) || *(_DWORD *)(v17 + 20) )
        {
          v18 = (__int16 *)*v4;
          v4[1] |= 1 << *(_DWORD *)(v17 + 20);
          v4[2 * *(_DWORD *)(v17 + 20) + 3] = (int)v18;
        }
        goto LABEL_64;
      case 15:
        if ( ((1 << *(_DWORD *)(v3 + 20)) & v4[1]) == 0 )
          goto LABEL_64;
        v19 = *(_DWORD *)(v3 + 20);
        v20 = (unsigned __int16 *)v4[2 * v19 + 2];
        v21 = (unsigned __int16 *)*v4;
        v31 = (char *)v4[2 * v19 + 3];
        if ( v20 != (unsigned __int16 *)v31 )
        {
          v21 = sub_414E20(
                  (v4[137] & 0x80) != 0,
                  v20,
                  v4[136],
                  v21,
                  (unsigned __int16 *)v4[133],
                  (unsigned __int16 *)v31,
                  v4 + 139);
          if ( v21 == (unsigned __int16 *)*v4 )
            goto LABEL_69;
        }
        *v4 = (int)v21;
        goto LABEL_64;
      case 16:
        if ( !sub_414F00(v3, (int)v4, a3) )
          v29 = 1;
        goto LABEL_63;
      case 18:
        if ( !sub_414FB0(v4, (_DWORD *)v3, (*(_DWORD *)(v3 + 8) & 2) != 0, a3) )
          v29 = 1;
        goto LABEL_63;
      case 19:
        if ( a3 > 0 )
        {
          v22 = (__int16 *)*v4;
          v28 = *(_DWORD *)(v3 + 12);
          v34 = v4[1];
          v23 = sub_414990(v4, v28, a3);
          v24 = v34;
          v29 = v23 == 0;
          *v4 = (int)v22;
          v4[1] = v24;
        }
        goto LABEL_63;
      case 21:
        if ( (v4[137] & 0x2020) != 0 && v4[132] == *v4 || *((_BYTE *)v4 + 568) && *v4 != v4[133] )
        {
          v29 = 1;
        }
        else if ( !*((_BYTE *)v4 + 552) || sub_415330((int)v4) )
        {
          qmemcpy(v4 + 66, this, 0x108u);
          *((_BYTE *)this + 552) = 1;
          v4 = this;
        }
LABEL_63:
        v3 = 0;
        goto LABEL_64;
      default:
        v31 = "corrupted regex pattern";
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v31);
        pExceptionObject[0] = (int)&std::logic_error::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVlogic_error_std__);
    }
  }
}
// 4BDA10: using guessed type void *std::logic_error::`vftable';

//----- (00414E20) --------------------------------------------------------
unsigned __int16 *__usercall sub_414E20@<eax>(
        char a1@<al>,
        unsigned __int16 *a2@<edx>,
        __int16 a3@<bx>,
        _WORD *a4,
        unsigned __int16 *a5,
        unsigned __int16 *a6,
        int *a7)
{
  unsigned __int16 *v7; // esi

  v7 = a5;
  if ( (a3 & 0x800) != 0 )
    return sub_4153D0((int)a4, a5, a6, a7, a1);
  if ( (a3 & 0x100) != 0 )
    return sub_415600((int)a4, a5, a2, a6, (int)a7, a1);
  LOBYTE(a5) = 0;
  return sub_4157B0((__int16 *)a2, a4, (__int16 *)a6, v7, (int)a5, a1);
}

//----- (00414E80) --------------------------------------------------------
__int16 *__cdecl sub_414E80(__int16 *a1, __int16 *a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // ebx
  unsigned int v6; // esi
  __int16 *v7; // edi
  unsigned int v8; // ecx
  _WORD *v9; // edx
  __int16 v10; // ax
  int v12; // [esp+Ch] [ebp-4h]

  v3 = a3;
  if ( !a3 )
    return a1;
  while ( 1 )
  {
    v4 = v3[2];
    v5 = 0;
    v12 = v4;
    if ( v4 > 0 )
      break;
LABEL_11:
    v3 = (_DWORD *)v3[4];
    a3 = v3;
    if ( !v3 )
      return a1;
  }
  v6 = *v3;
  while ( 1 )
  {
    v7 = a1;
    v8 = 0;
    if ( v6 )
    {
      v9 = (_WORD *)(v3[3] + 2 * v5);
      do
      {
        v10 = *v7++;
        if ( v10 != *v9 )
          break;
        ++v8;
        ++v9;
      }
      while ( v8 < v6 );
      v3 = a3;
      v4 = v12;
    }
    if ( v7 == a2 )
      return a2;
    v5 += v6;
    if ( v5 >= v4 )
      goto LABEL_11;
  }
}

//----- (00414F00) --------------------------------------------------------
char __userpurge sub_414F00@<al>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx
  int v4; // edi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int *v9; // eax
  int v10; // ecx
  int v11; // edx
  char result; // al
  int v13; // [esp+8h] [ebp-1Ch] BYREF
  int v14; // [esp+Ch] [ebp-18h]
  int v15; // [esp+10h] [ebp-14h] BYREF
  int v16; // [esp+14h] [ebp-10h]
  int v17; // [esp+18h] [ebp-Ch]
  char v18; // [esp+1Fh] [ebp-5h]

  v4 = a1;
  v5 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v3 = v13;
  v14 = v5;
  v15 = v13;
  v16 = v5;
  v18 = 0;
  v17 = -1;
  if ( a1 )
  {
    do
    {
      v6 = v14;
      *(_DWORD *)a2 = v3;
      *(_DWORD *)(a2 + 4) = v6;
      if ( sub_414990((int *)a2, *(_DWORD *)(v4 + 12), a3) )
      {
        if ( !*(_BYTE *)(a2 + 555) )
          return 1;
        v7 = (*(_DWORD *)a2 - v3) >> 1;
        if ( v17 < v7 )
        {
          v8 = *(_DWORD *)(a2 + 4);
          v15 = *(_DWORD *)a2;
          v16 = v8;
          v17 = v7;
        }
        v18 = 1;
      }
      v4 = *(_DWORD *)(v4 + 24);
    }
    while ( v4 );
    v9 = &v15;
    if ( v18 )
      goto LABEL_10;
  }
  v9 = &v13;
LABEL_10:
  v10 = *v9;
  v11 = v9[1];
  result = v18;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 4) = v11;
  return result;
}

//----- (00414FB0) --------------------------------------------------------
char __userpurge sub_414FB0@<al>(int *a1@<ebx>, _DWORD *a2, char a3, int a4)
{
  bool v4; // cc
  int v5; // ecx
  int v6; // edi
  int v7; // esi
  int v8; // eax
  char result; // al
  int v10; // edx
  int *v11; // edi
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // esi
  char v18; // cl
  int *v19; // eax
  int v20; // edx
  int v21; // [esp-8h] [ebp-144h]
  int v22; // [esp+Ch] [ebp-130h]
  int v23; // [esp+10h] [ebp-12Ch] BYREF
  int v24; // [esp+14h] [ebp-128h]
  int v25; // [esp+18h] [ebp-124h]
  int *v26; // [esp+1Ch] [ebp-120h]
  int v27; // [esp+20h] [ebp-11Ch]
  char v28; // [esp+27h] [ebp-115h]
  char v29[268]; // [esp+28h] [ebp-114h] BYREF

  v4 = a2[6] <= 0;
  v5 = a1[1];
  v6 = *a1;
  v26 = a2;
  v23 = v6;
  v24 = v5;
  v27 = 0;
  if ( v4 )
  {
LABEL_5:
    v8 = *a1;
    qmemcpy(v29, a1, 0x108u);
    v25 = v8;
    v21 = *(_DWORD *)(v26[5] + 12);
    v28 = 0;
    if ( !sub_414990(a1, v21, a4) )
      goto LABEL_10;
    if ( a3 )
    {
      qmemcpy(v29, a1, 0x108u);
      v28 = 1;
LABEL_10:
      while ( 1 )
      {
        v11 = v26;
        v12 = v26[7];
        if ( v12 != -1 )
        {
          v13 = v27++;
          if ( v13 >= v12 )
            break;
        }
        v14 = v24;
        *a1 = v25;
        a1[1] = v14;
        v15 = v11[7];
        if ( v15 < 0 || v15 > v27 )
          v16 = -1;
        else
          v16 = 1;
        if ( !sub_414990(a1, v11[3], v16) )
          break;
        v17 = *a1;
        v22 = *a1;
        if ( sub_414990(a1, *(_DWORD *)(v11[5] + 12), a4) )
        {
          if ( !a3 )
            return 1;
          qmemcpy(v29, a1, 0x108u);
          v17 = v22;
          v28 = 1;
        }
        if ( v25 == v17 )
          break;
        v25 = v17;
      }
      v18 = v28;
      v19 = (int *)v29;
      if ( !v28 )
        v19 = &v23;
      v20 = *v19;
      a1[1] = v19[1];
      result = v18;
      *a1 = v20;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( !sub_414990(a1, v26[3], -1) )
        break;
      if ( v7 != *a1 && ++v27 < v26[6] )
        continue;
      goto LABEL_5;
    }
    v10 = v24;
    *a1 = v6;
    a1[1] = v10;
    return 0;
  }
  return result;
}

//----- (004151A0) --------------------------------------------------------
char __stdcall sub_4151A0(__int16 **a1, int a2)
{
  int v2; // esi
  struct std::locale::facet *v3; // eax
  __int16 *v4; // edi
  _DWORD *v5; // eax
  __int16 *v6; // eax
  char v7; // al
  unsigned __int16 v8; // di
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  unsigned __int16 *v12; // ecx
  int v13; // edi
  bool v14; // zf
  int v15; // ecx
  _WORD *v16; // eax
  _WORD *i; // ecx
  __int16 v18; // di
  int *v19; // edx
  __int16 *v21; // [esp+Ch] [ebp-4h]

  v2 = (unsigned __int16)**a1;
  if ( ((unsigned int)a1[136] & 0x100) != 0 )
  {
    v3 = sub_40F1E0((int)(a1 + 139));
    v2 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)v3 + 24))(v3, v2);
  }
  v4 = *a1;
  v5 = *(_DWORD **)(a2 + 20);
  v21 = *a1 + 1;
  if ( v5 )
  {
    v6 = sub_414E80(v4, a1[133], v5);
    if ( v6 != v4 )
    {
      v21 = v6;
      v7 = 1;
      goto LABEL_33;
    }
  }
  if ( *(_DWORD *)(a2 + 32) )
  {
    v8 = ((unsigned int)a1[136] & 0x800) != 0 ? sub_40EFA0(a1 + 139, v2) : v2;
    v9 = *(_DWORD *)(a2 + 32);
    v10 = *(_DWORD *)(v9 + 4);
    v11 = 0;
    if ( v10 > 0 )
    {
      v12 = *(unsigned __int16 **)(v9 + 8);
      while ( *v12 > v8 || v8 > v12[1] )
      {
        v11 += 2;
        v12 += 2;
        if ( v11 >= v10 )
          goto LABEL_15;
      }
      goto LABEL_31;
    }
  }
LABEL_15:
  if ( dword_4EF7FC > (unsigned __int16)v2 || (unsigned __int16)v2 >= 0x100u )
  {
    if ( *(_DWORD *)(a2 + 28) )
    {
      v15 = *(_DWORD *)(a2 + 28);
      v16 = *(_WORD **)(v15 + 8);
      for ( i = &v16[*(_DWORD *)(v15 + 4)]; v16 != i; ++v16 )
      {
        if ( *v16 == (_WORD)v2 )
          break;
      }
      if ( v16 != (_WORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 28) + 8) + 2 * *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4)) )
      {
        v7 = 1;
        goto LABEL_33;
      }
    }
    v18 = *(_WORD *)(a2 + 36);
    if ( v18 && (unsigned __int8)sub_40F010((int)(a1 + 139), v18, v2) )
    {
      v7 = 1;
      goto LABEL_33;
    }
    v19 = *(int **)(a2 + 40);
    if ( !v19 )
      goto LABEL_32;
    v14 = sub_40FC80(v19, a1 + 139, v2) == 0;
  }
  else
  {
    v13 = *(_DWORD *)(a2 + 24);
    if ( !v13 )
      goto LABEL_32;
    v14 = ((unsigned __int8)(1 << (v2 & 7)) & *(_BYTE *)(((unsigned __int16)v2 >> 3) + v13)) == 0;
  }
  if ( !v14 )
  {
LABEL_31:
    v7 = 1;
    goto LABEL_33;
  }
LABEL_32:
  v7 = 0;
LABEL_33:
  if ( v7 == (*(_BYTE *)(a2 + 8) & 1) )
    return 0;
  *a1 = v21;
  return 1;
}
// 4EF7FC: using guessed type int dword_4EF7FC;

//----- (00415330) --------------------------------------------------------
bool __thiscall sub_415330(int this)
{
  int v1; // eax
  int v2; // edx
  _DWORD *i; // esi

  v1 = 0;
  v2 = 1;
  if ( !*(_BYTE *)(this + 554) )
    return 0;
  for ( i = (_DWORD *)(this + 8); ; i += 2 )
  {
    if ( (v2 & *(_DWORD *)(this + 268)) != 0 && (v2 & *(_DWORD *)(this + 4)) != 0 )
    {
      if ( i[66] != *i )
        return (int)((*(_DWORD *)(this + 8 * v1 + 272) - *(_DWORD *)(this + 528)) & 0xFFFFFFFE) < (int)((*(_DWORD *)(this + 8 * v1 + 8) - *(_DWORD *)(this + 528)) & 0xFFFFFFFE);
      if ( i[67] != i[1] )
        break;
    }
    ++v1;
    v2 *= 2;
    if ( v1 >= *(unsigned __int8 *)(this + 554) )
      return 0;
  }
  return (int)((*(_DWORD *)(this + 8 * v1 + 276) - *(_DWORD *)(this + 528)) & 0xFFFFFFFE) < (int)((*(_DWORD *)(this + 8 * v1 + 12)
                                                                                                 - *(_DWORD *)(this + 528)) & 0xFFFFFFFE);
}

//----- (004153D0) --------------------------------------------------------
unsigned __int16 *__cdecl sub_4153D0(int a1, unsigned __int16 *a2, _WORD *a3, int *a4, char a5)
{
  _WORD *v5; // ecx
  unsigned __int16 *result; // eax
  unsigned __int16 v7; // cx
  int *v8; // eax
  struct std::locale::facet *v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // esi
  void (__thiscall ***v13)(_DWORD, int); // esi
  void **v14; // eax
  int v15; // eax
  int *v16; // eax
  struct std::locale::facet *v17; // eax
  int v18; // edi
  int v19; // eax
  int v20; // esi
  void (__thiscall ***v21)(_DWORD, int); // esi
  void **v22; // eax
  __int16 v23; // si
  unsigned __int16 v24; // [esp+10h] [ebp-74h]
  int v25; // [esp+14h] [ebp-70h] BYREF
  char v26[4]; // [esp+18h] [ebp-6Ch] BYREF
  char v27[4]; // [esp+1Ch] [ebp-68h] BYREF
  int v28; // [esp+20h] [ebp-64h] BYREF
  int v29; // [esp+24h] [ebp-60h]
  int v30; // [esp+28h] [ebp-5Ch]
  int v31; // [esp+2Ch] [ebp-58h] BYREF
  int v32; // [esp+30h] [ebp-54h] BYREF
  _WORD *v33; // [esp+34h] [ebp-50h]
  unsigned __int16 *v34; // [esp+38h] [ebp-4Ch]
  void *v35[4]; // [esp+3Ch] [ebp-48h] BYREF
  int v36; // [esp+4Ch] [ebp-38h]
  unsigned int v37; // [esp+50h] [ebp-34h]
  void *v38[4]; // [esp+58h] [ebp-2Ch] BYREF
  int v39; // [esp+68h] [ebp-1Ch]
  unsigned int v40; // [esp+6Ch] [ebp-18h]
  int v41; // [esp+80h] [ebp-4h]

  result = (unsigned __int16 *)a1;
  v34 = (unsigned __int16 *)a1;
  v33 = v5;
  v30 = a1;
  if ( (unsigned __int16 *)a1 == a2 )
  {
LABEL_33:
    if ( v5 != a3 && (!a5 || result != a2) )
      return (unsigned __int16 *)v30;
  }
  else
  {
    while ( v5 != a3 )
    {
      v7 = *v5;
      v31 = *result;
      v24 = v7;
      if ( !*a4 )
      {
        v8 = sub_40F4D0((int)a4, &v28);
        v41 = 0;
        v9 = sub_410420(v8);
        v41 = -1;
        v10 = v28;
        *a4 = (int)v9;
        if ( v10 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v26, 0);
          v11 = *(_DWORD *)(v10 + 4);
          if ( v11 && v11 != -1 )
            *(_DWORD *)(v10 + 4) = v11 - 1;
          v12 = -(*(_DWORD *)(v10 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v26);
          v13 = (void (__thiscall ***)(_DWORD, int))(v10 & v12);
          if ( v13 )
            (**v13)(v13, 1);
        }
      }
      sub_40F360((int)&v31 + 2, *a4, (int)v38, (int)&v31);
      if ( v39 == 1 )
      {
        v14 = (void **)v38[0];
        if ( v40 < 8 )
          v14 = v38;
        v15 = *(unsigned __int16 *)v14;
      }
      else
      {
        v15 = (unsigned __int16)v31;
      }
      v29 = v15;
      if ( v40 >= 8 )
        operator delete(v38[0]);
      v40 = 7;
      v39 = 0;
      LOWORD(v38[0]) = 0;
      v32 = v24;
      if ( !*a4 )
      {
        v16 = sub_40F4D0((int)a4, &v25);
        v41 = 1;
        v17 = sub_410420(v16);
        v41 = -1;
        v18 = v25;
        *a4 = (int)v17;
        if ( v18 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v27, 0);
          v19 = *(_DWORD *)(v18 + 4);
          if ( v19 && v19 != -1 )
            *(_DWORD *)(v18 + 4) = v19 - 1;
          v20 = -(*(_DWORD *)(v18 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v27);
          v21 = (void (__thiscall ***)(_DWORD, int))(v18 & v20);
          if ( v21 )
            (**v21)(v21, 1);
        }
      }
      sub_40F360((int)&v32 + 2, *a4, (int)v35, (int)&v32);
      if ( v36 == 1 )
      {
        v22 = (void **)v35[0];
        if ( v37 < 8 )
          v22 = v35;
        v23 = *(_WORD *)v22;
      }
      else
      {
        v23 = v32;
      }
      if ( v37 >= 8 )
        operator delete(v35[0]);
      ++v34;
      ++v33;
      v37 = 7;
      v36 = 0;
      LOWORD(v35[0]) = 0;
      if ( (_WORD)v29 != v23 )
        return (unsigned __int16 *)v30;
      v5 = v33;
      result = v34;
      if ( v34 == a2 )
        goto LABEL_33;
    }
  }
  return result;
}
// 415401: variable 'v5' is possibly undefined
// 4153D0: using guessed type char var_6C[4];
// 4153D0: using guessed type char var_68[4];

//----- (00415600) --------------------------------------------------------
unsigned __int16 *__cdecl sub_415600(
        int a1,
        unsigned __int16 *a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        int a5,
        char a6)
{
  unsigned __int16 *v6; // ecx
  unsigned __int16 *v7; // eax
  bool v8; // zf
  struct std::locale::facet **v9; // ebx
  _DWORD *v10; // eax
  struct std::locale::facet *v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // esi
  void (__thiscall ***v15)(_DWORD, int); // esi
  struct std::locale::facet **v16; // ebx
  _DWORD *v17; // eax
  struct std::locale::facet *v18; // eax
  int v19; // edi
  int v20; // eax
  int v21; // esi
  void (__thiscall ***v22)(_DWORD, int); // esi
  __int16 v23; // ax
  unsigned __int16 *result; // eax
  int v25; // [esp+10h] [ebp-28h]
  char v26[4]; // [esp+14h] [ebp-24h] BYREF
  int v27; // [esp+18h] [ebp-20h] BYREF
  int v28; // [esp+1Ch] [ebp-1Ch]
  char v29[4]; // [esp+20h] [ebp-18h] BYREF
  int v30; // [esp+24h] [ebp-14h] BYREF
  int v31; // [esp+28h] [ebp-10h]
  int v32; // [esp+34h] [ebp-4h]

  v6 = (unsigned __int16 *)a1;
  v7 = a2;
  v31 = a1;
  if ( (unsigned __int16 *)a1 != a2 )
  {
    while ( a3 != a4 )
    {
      v25 = *a3;
      v8 = *(_DWORD *)(a5 + 4) == 0;
      v9 = (struct std::locale::facet **)(a5 + 4);
      v28 = *v6;
      if ( v8 )
      {
        v10 = sub_40F4D0(a5, &v30);
        v32 = 0;
        v11 = sub_408900((int)v10);
        v32 = -1;
        v12 = v30;
        *v9 = v11;
        if ( v12 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v29, 0);
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 && v13 != -1 )
            *(_DWORD *)(v12 + 4) = v13 - 1;
          v14 = -(*(_DWORD *)(v12 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v29);
          v15 = (void (__thiscall ***)(_DWORD, int))(v12 & v14);
          if ( v15 )
            (**v15)(v15, 1);
        }
      }
      v28 = (*(unsigned __int16 (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v9 + 24))(*v9, v28);
      v16 = (struct std::locale::facet **)(a5 + 4);
      if ( !*(_DWORD *)(a5 + 4) )
      {
        v17 = sub_40F4D0(a5, &v27);
        v32 = 1;
        v18 = sub_408900((int)v17);
        v32 = -1;
        v19 = v27;
        *v16 = v18;
        if ( v19 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v26, 0);
          v20 = *(_DWORD *)(v19 + 4);
          if ( v20 && v20 != -1 )
            *(_DWORD *)(v19 + 4) = v20 - 1;
          v21 = -(*(_DWORD *)(v19 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v26);
          v22 = (void (__thiscall ***)(_DWORD, int))(v19 & v21);
          if ( v22 )
            (**v22)(v22, 1);
        }
      }
      v23 = (*(int (__thiscall **)(struct std::locale::facet *, int))(*(_DWORD *)*v16 + 24))(*v16, v25);
      ++a3;
      v6 = (unsigned __int16 *)(a1 + 2);
      a1 += 2;
      if ( (_WORD)v28 != v23 )
        return (unsigned __int16 *)v31;
      v7 = a2;
      if ( v6 == a2 )
        goto LABEL_19;
    }
    return v6;
  }
LABEL_19:
  if ( a3 == a4 )
    return v6;
  if ( !a6 )
    return (unsigned __int16 *)v31;
  v8 = v6 == v7;
  result = v6;
  if ( !v8 )
    return (unsigned __int16 *)v31;
  return result;
}
// 415600: using guessed type char var_18[4];
// 415600: using guessed type char var_24[4];

//----- (004157B0) --------------------------------------------------------
_WORD *__usercall sub_4157B0@<eax>(
        __int16 *a1@<edx>,
        _WORD *a2@<ecx>,
        __int16 *a3@<edi>,
        _WORD *a4@<esi>,
        int a5,
        char a6)
{
  __int16 v6; // ax
  __int16 v7; // bx
  _WORD *result; // eax
  _WORD *v9; // [esp+4h] [ebp-4h]

  v9 = a2;
  if ( a2 != a4 )
  {
    while ( a1 != a3 )
    {
      v6 = *a2;
      v7 = *a1;
      ++a2;
      ++a1;
      if ( v6 != v7 )
        return v9;
      if ( a2 == a4 )
        goto LABEL_5;
    }
    return a2;
  }
LABEL_5:
  if ( a1 == a3 )
    return a2;
  if ( !a6 )
    return v9;
  result = a2;
  if ( a2 != a4 )
    return v9;
  return result;
}

//----- (00415800) --------------------------------------------------------
int __usercall sub_415800@<eax>(int result@<eax>, int a2@<ecx>, int a3@<esi>)
{
  for ( ; a2 != a3; result += 12 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)a2;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
      *(_BYTE *)(result + 8) = *(_BYTE *)(a2 + 8);
    }
    a2 += 12;
  }
  return result;
}

//----- (00415830) --------------------------------------------------------
char **__usercall sub_415830@<eax>(int a1@<ebx>, char **a2@<esi>)
{
  char *v2; // edi
  char **result; // eax
  int v4; // ecx

  v2 = *(char **)a1;
  result = sub_41EEB0(a2, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 == 357913940 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (00415870) --------------------------------------------------------
int __usercall sub_415870@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int ImageHeight; // eax
  int v4; // [esp-8h] [ebp-Ch]
  int v5; // [esp+0h] [ebp-4h] BYREF

  v5 = a1;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = 0;
  ImageHeight = GdipGetImageHeight(v4, &v5);
  if ( ImageHeight )
    *(_DWORD *)(a2 + 8) = ImageHeight;
  return v5;
}
// 4BD694: using guessed type int __stdcall GdipGetImageHeight(_DWORD, _DWORD);

//----- (004158A0) --------------------------------------------------------
int __usercall sub_4158A0@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int ImageWidth; // eax
  int v4; // [esp-8h] [ebp-Ch]
  int v5; // [esp+0h] [ebp-4h] BYREF

  v5 = a1;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = 0;
  ImageWidth = GdipGetImageWidth(v4, &v5);
  if ( ImageWidth )
    *(_DWORD *)(a2 + 8) = ImageWidth;
  return v5;
}
// 4BD69C: using guessed type int __stdcall GdipGetImageWidth(_DWORD, _DWORD);

//----- (004158D0) --------------------------------------------------------
_DWORD *__thiscall sub_4158D0(_DWORD *this)
{
  int v2; // eax
  _DWORD *result; // eax
  int v4; // ecx
  int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp+4h] [ebp-4h] BYREF

  v5 = this[1];
  v6 = 0;
  v2 = GdipCloneImage(v5, &v6);
  if ( v2 )
    this[2] = v2;
  result = (_DWORD *)GdipAlloc(16);
  if ( !result )
    return 0;
  v4 = v6;
  result[2] = this[2];
  *result = &Gdiplus::Image::`vftable';
  result[1] = v4;
  return result;
}
// 4BD6B0: using guessed type int __stdcall GdipCloneImage(_DWORD, _DWORD);
// 4BD6BC: using guessed type int __stdcall GdipAlloc(_DWORD);
// 4CC06C: using guessed type void *Gdiplus::Image::`vftable';

//----- (00415920) --------------------------------------------------------
_DWORD *__stdcall sub_415920(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v9[3]; // [esp+Ch] [ebp-3Ch] BYREF
  int v10[3]; // [esp+18h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+24h] [ebp-24h] BYREF
  char *v12; // [esp+30h] [ebp-18h] BYREF
  char *v13; // [esp+34h] [ebp-14h] BYREF
  char *v14; // [esp+38h] [ebp-10h] BYREF
  int v15; // [esp+44h] [ebp-4h]

  a1[1] = 0;
  v1 = operator new(0x14u);
  if ( !v1 )
  {
    v12 = 0;
    std::exception::exception((std::exception *)v9, (const char *const *)&v12);
    v9[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v9, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v1;
  *v1 = v1;
  *(_DWORD *)(*a1 + 4) = *a1;
  v15 = 0;
  a1[4] = 0;
  v2 = operator new(0x14u);
  if ( !v2 )
  {
    v13 = 0;
    std::exception::exception((std::exception *)v10, (const char *const *)&v13);
    v10[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v10, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[3] = v2;
  *v2 = v2;
  *(_DWORD *)(a1[3] + 4) = a1[3];
  LOBYTE(v15) = 1;
  a1[7] = 0;
  v3 = operator new(0x14u);
  if ( !v3 )
  {
    v14 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[6] = v3;
  *v3 = v3;
  *(_DWORD *)(a1[6] + 4) = a1[6];
  LOBYTE(v15) = 2;
  a1[10] = 0;
  v4 = operator new(0x14u);
  if ( !v4 )
  {
    v13 = 0;
    std::exception::exception((std::exception *)v10, (const char *const *)&v13);
    v10[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v10, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[9] = v4;
  *v4 = v4;
  *(_DWORD *)(a1[9] + 4) = a1[9];
  LOBYTE(v15) = 3;
  a1[13] = 0;
  v5 = operator new(0x14u);
  if ( !v5 )
  {
    v14 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[12] = v5;
  *v5 = v5;
  *(_DWORD *)(a1[12] + 4) = a1[12];
  LOBYTE(v15) = 4;
  a1[16] = 0;
  v6 = operator new(0x14u);
  if ( !v6 )
  {
    v13 = 0;
    std::exception::exception((std::exception *)v10, (const char *const *)&v13);
    v10[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v10, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[15] = v6;
  *v6 = v6;
  *(_DWORD *)(a1[15] + 4) = a1[15];
  LOBYTE(v15) = 5;
  a1[19] = 0;
  v7 = operator new(0x14u);
  if ( !v7 )
  {
    v14 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[18] = v7;
  *v7 = v7;
  *(_DWORD *)(a1[18] + 4) = a1[18];
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00415B50) --------------------------------------------------------
void __usercall sub_415B50(void **a1@<esi>)
{
  void ***v1; // ecx
  void **v2; // eax
  void **v3; // edi
  void ***v4; // ecx
  void **v5; // eax
  void **v6; // edi
  void ***v7; // ecx
  void **v8; // eax
  void **v9; // edi
  void ***v10; // ecx
  void **v11; // eax
  void **v12; // edi
  void ***v13; // ecx
  void **v14; // eax
  void **v15; // edi
  void ***v16; // ecx
  void **v17; // eax
  void **v18; // edi
  void **v19; // eax
  void **v20; // edi

  v1 = (void ***)a1[18];
  v2 = *v1;
  *v1 = (void **)v1;
  *((_DWORD *)a1[18] + 1) = a1[18];
  a1[19] = 0;
  if ( v2 != a1[18] )
  {
    do
    {
      v3 = (void **)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != a1[18] );
  }
  operator delete(a1[18]);
  v4 = (void ***)a1[15];
  v5 = *v4;
  *v4 = (void **)v4;
  *((_DWORD *)a1[15] + 1) = a1[15];
  a1[16] = 0;
  if ( v5 != a1[15] )
  {
    do
    {
      v6 = (void **)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != a1[15] );
  }
  operator delete(a1[15]);
  v7 = (void ***)a1[12];
  v8 = *v7;
  *v7 = (void **)v7;
  *((_DWORD *)a1[12] + 1) = a1[12];
  a1[13] = 0;
  if ( v8 != a1[12] )
  {
    do
    {
      v9 = (void **)*v8;
      operator delete(v8);
      v8 = v9;
    }
    while ( v9 != a1[12] );
  }
  operator delete(a1[12]);
  v10 = (void ***)a1[9];
  v11 = *v10;
  *v10 = (void **)v10;
  *((_DWORD *)a1[9] + 1) = a1[9];
  a1[10] = 0;
  if ( v11 != a1[9] )
  {
    do
    {
      v12 = (void **)*v11;
      operator delete(v11);
      v11 = v12;
    }
    while ( v12 != a1[9] );
  }
  operator delete(a1[9]);
  v13 = (void ***)a1[6];
  v14 = *v13;
  *v13 = (void **)v13;
  *((_DWORD *)a1[6] + 1) = a1[6];
  a1[7] = 0;
  if ( v14 != a1[6] )
  {
    do
    {
      v15 = (void **)*v14;
      operator delete(v14);
      v14 = v15;
    }
    while ( v15 != a1[6] );
  }
  operator delete(a1[6]);
  v16 = (void ***)a1[3];
  v17 = *v16;
  *v16 = (void **)v16;
  *((_DWORD *)a1[3] + 1) = a1[3];
  a1[4] = 0;
  if ( v17 != a1[3] )
  {
    do
    {
      v18 = (void **)*v17;
      operator delete(v17);
      v17 = v18;
    }
    while ( v18 != a1[3] );
  }
  operator delete(a1[3]);
  v19 = *(void ***)*a1;
  *(_DWORD *)*a1 = *a1;
  *((_DWORD *)*a1 + 1) = *a1;
  a1[1] = 0;
  if ( v19 != *a1 )
  {
    do
    {
      v20 = (void **)*v19;
      operator delete(v19);
      v19 = v20;
    }
    while ( v20 != *a1 );
  }
  operator delete(*a1);
}

//----- (00415CD0) --------------------------------------------------------
int __thiscall sub_415CD0(void *this, int a2)
{
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = *((_DWORD *)this + 1);
  sub_415D90((char ***)(a2 + 8), (int **)this + 2);
  sub_415D90((char ***)(a2 + 20), (int **)this + 5);
  sub_415D90((char ***)(a2 + 32), (int **)this + 8);
  sub_415D90((char ***)(a2 + 44), (int **)this + 11);
  sub_415D90((char ***)(a2 + 56), (int **)this + 14);
  sub_415D90((char ***)(a2 + 68), (int **)this + 17);
  sub_415D90((char ***)(a2 + 80), (int **)this + 20);
  return a2;
}

//----- (00415D90) --------------------------------------------------------
char ***__stdcall sub_415D90(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0x14u);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_40B870((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00415E50) --------------------------------------------------------
char ***__stdcall sub_415E50(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0x1Cu);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_416130((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00415F10) --------------------------------------------------------
_DWORD *__usercall sub_415F10@<eax>(int a1@<esi>)
{
  _DWORD *result; // eax
  _DWORD *v2; // edi

  result = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( result != *(_DWORD **)a1 )
  {
    do
    {
      v2 = (_DWORD *)*result;
      operator delete(result);
      result = v2;
    }
    while ( v2 != *(_DWORD **)a1 );
  }
  return result;
}

//----- (00415F40) --------------------------------------------------------
_DWORD *__userpurge sub_415F40@<eax>(char *a1@<eax>, _DWORD *a2@<esi>, unsigned int a3)
{
  unsigned int v4; // ecx
  char *v5; // eax
  _DWORD *v6; // eax
  char *v7; // eax
  _DWORD *result; // eax
  char *v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // edi
  unsigned int v12; // ecx
  _DWORD *v13; // eax
  bool v14; // cf

  if ( !a1
    || ((v4 = a2[5], v4 < 8) ? (v5 = (char *)a2) : (v5 = (char *)*a2),
        a1 < v5 || (v4 < 8 ? (v6 = a2) : (v6 = (_DWORD *)*a2), (char *)v6 + 2 * a2[4] <= a1)) )
  {
    v9 = (char *)a2[4];
    v10 = a3;
    if ( -1 - (int)v9 <= a3 )
      std::_Xlength_error("string too long");
    if ( a3 )
    {
      v11 = (unsigned int)&v9[a3];
      if ( (unsigned int)&v9[a3] > 0x7FFFFFFE )
        std::_Xlength_error("string too long");
      v12 = a2[5];
      if ( v12 >= v11 )
      {
        if ( !v11 )
        {
          a2[4] = 0;
          if ( v12 < 8 )
          {
            result = a2;
            *(_WORD *)a2 = 0;
          }
          else
          {
            *(_WORD *)*a2 = 0;
            return a2;
          }
          return result;
        }
        goto LABEL_21;
      }
      sub_409240((int)a2, (unsigned int)&v9[a3], v9);
      v10 = a3;
      if ( v11 )
      {
LABEL_21:
        if ( a2[5] < 8u )
          v13 = a2;
        else
          v13 = (_DWORD *)*a2;
        memcpy_0((char *)v13 + 2 * a2[4], a1, 2 * v10);
        v14 = a2[5] < 8u;
        a2[4] = v11;
        if ( !v14 )
        {
          *(_WORD *)(*a2 + 2 * v11) = 0;
          return a2;
        }
        *((_WORD *)a2 + v11) = 0;
      }
    }
    return a2;
  }
  if ( v4 < 8 )
    v7 = (char *)a2;
  else
    v7 = (char *)*a2;
  return sub_406A00(a2, a2, (a1 - v7) >> 1, a3);
}

//----- (00416060) --------------------------------------------------------
char **__userpurge sub_416060@<eax>(char **a1@<esi>, char *a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x1Cu);
  if ( !result )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a3;
  *result = a2;
  result[1] = v4;
  if ( result != (char **)-8 )
  {
    result[2] = *a1;
    result[3] = a1[1];
    result[4] = a1[2];
    result[5] = a1[3];
    result[6] = a1[4];
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004160E0) --------------------------------------------------------
_DWORD *__usercall sub_4160E0@<eax>(char *a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = sub_415F40(a1, a3, wcslen((const unsigned __int16 *)a1));
  a2[5] = 7;
  a2[4] = 0;
  *(_WORD *)a2 = 0;
  sub_40AF70(a2, v3);
  return a2;
}

//----- (00416130) --------------------------------------------------------
int __stdcall sub_416130(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char **v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_416060((char **)(result + 8), a2, *((_DWORD *)a2 + 1));
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 214748363 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    *(_DWORD *)v6[1] = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (00416200) --------------------------------------------------------
int __stdcall sub_416200(int a1, int a2, DWORD dwErrCode)
{
  int v3; // edi
  int (__stdcall *v4)(int, int, DWORD); // esi
  int result; // eax
  FARPROC v6; // eax
  int v7; // esi
  FARPROC v8; // eax
  int v9; // [esp+14h] [ebp-20h] BYREF
  int v10; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+44h] [ebp+10h]

  v3 = 0;
  v10 = 0;
  v4 = (int (__stdcall *)(int, int, DWORD))dword_4EF800;
  v9 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v9)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v4 )
    {
      v6 = sub_4016B0((DWORD)"ImageList_GetIconSize");
      v4 = (int (__stdcall *)(int, int, DWORD))v6;
      if ( !v6 )
        goto LABEL_7;
      dword_4EF800 = (int)v6;
    }
    v3 = v4(a1, a2, dwErrCode);
    v10 = v3;
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v3;
    if ( v3 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v7 = v9;
    v8 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v8 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v8 )
        goto LABEL_15;
      dword_4EF118 = (int)v8;
    }
    ((void (__stdcall *)(_DWORD, int))v8)(0, v7);
LABEL_15:
    if ( !v3 )
      SetLastError(dwErrCodea);
    return v3;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF800: using guessed type int dword_4EF800;

//----- (00416330) --------------------------------------------------------
int __stdcall sub_416330(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v8 = -1;
  v1 = (int (__stdcall *)(DWORD))dword_4EF810;
  v7 = 0;
  if ( !dword_4EF798 && !sub_4015E0((int)&v7) )
    return -1;
  ms_exc.registration.TryLevel = 0;
  if ( !v1 )
  {
    v3 = sub_416450((DWORD)"PropertySheetW");
    v1 = (int (__stdcall *)(DWORD))v3;
    if ( !v3 )
      goto LABEL_8;
    dword_4EF810 = (int)v3;
  }
  v8 = v1(dwErrCode);
LABEL_8:
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 )
  {
    v4 = v8 == -1;
    if ( v8 == -1 )
      dwErrCodea = GetLastError();
    else
      dwErrCodea = 0;
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_16;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_16:
    if ( v4 )
      SetLastError(dwErrCodea);
  }
  return v8;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF810: using guessed type int dword_4EF810;

//----- (00416450) --------------------------------------------------------
FARPROC __stdcall sub_416450(DWORD dwErrCode)
{
  FARPROC v1; // edi
  int v2; // esi
  int v4; // esi
  FARPROC v5; // eax
  int v6; // [esp+10h] [ebp-24h] BYREF
  int v7; // [esp+14h] [ebp-20h]
  FARPROC v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v1 = 0;
  v8 = 0;
  v2 = 0;
  v7 = 0;
  v6 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( dword_4EF798 || (v2 = sub_4015E0((int)&v6), (v7 = v2) != 0) )
  {
    v1 = sub_4017B0((int)&off_4CB878, (int)&unk_4EF808, (LPCSTR)dwErrCode);
    v8 = v1;
  }
  ms_exc.registration.TryLevel = -2;
  if ( !dword_4EF798 && v2 )
  {
    if ( v1 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v4 = v6;
    v5 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v5 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v5 )
        goto LABEL_13;
      dword_4EF118 = (int)v5;
    }
    ((void (__stdcall *)(_DWORD, int))v5)(0, v4);
LABEL_13:
    if ( !v1 )
      SetLastError(dwErrCodea);
  }
  return v1;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4CB878: using guessed type int (__stdcall *off_4CB878)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (00416550) --------------------------------------------------------
int __thiscall sub_416550(_DWORD *this)
{
  int (__stdcall *v2)(_DWORD); // ebx
  int result; // eax
  FARPROC v4; // eax
  int v5; // eax
  BOOL v6; // edi
  int v7; // esi
  FARPROC v8; // eax
  DWORD dwErrCode; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h] BYREF
  int v11; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  v11 = 0;
  v2 = dword_4EF80C;
  v10 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v10)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v2 )
    {
      v4 = sub_416450((DWORD)"CreatePropertySheetPageW");
      if ( !v4 )
        goto LABEL_13;
      dword_4EF80C = (int (__stdcall *)(_DWORD))v4;
    }
    v5 = this[1];
    if ( dword_4EF798 )
    {
      if ( (v5 & 0x4000) != 0 )
        this[1] = v5 & 0xFFFFBFFF;
    }
    else if ( (v5 & 0x4000) == 0 && *this >= 0x34u )
    {
      this[1] = v5 | 0x4000;
      this[12] = dword_4ECD00;
    }
    v11 = dword_4EF80C(this);
LABEL_13:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v11;
    v6 = v11 == 0;
    if ( v11 )
      dwErrCode = 0;
    else
      dwErrCode = GetLastError();
    v7 = v10;
    v8 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v8 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v8 )
        goto LABEL_21;
      dword_4EF118 = (int)v8;
    }
    ((void (__stdcall *)(_DWORD, int))v8)(0, v7);
LABEL_21:
    if ( v6 )
      SetLastError(dwErrCode);
    return v11;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4ECD00: using guessed type int dword_4ECD00;
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF80C: using guessed type int (__stdcall *dword_4EF80C)(_DWORD);

//----- (004166A0) --------------------------------------------------------
int __userpurge sub_4166A0@<eax>(int a1@<eax>, unsigned int *a2)
{
  unsigned int v2; // ecx
  int result; // eax

  v2 = BYTE1(a1) | ((a1 | 0xFFFFFF00) << 8);
  result = BYTE2(a1);
  *a2 = result | (v2 << 8);
  return result;
}

//----- (00416710) --------------------------------------------------------
void __usercall sub_416710(int a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 20) >= 8u )
    operator delete(*(void **)a1);
  *(_DWORD *)(a1 + 20) = 7;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)a1 = 0;
}

//----- (00416770) --------------------------------------------------------
void *__thiscall sub_416770(void *this, int a2)
{
  *(_DWORD *)this = &CSearch::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 1088));
  sub_40BD70((int *)this + 268);
  *(_DWORD *)this = &CReferenceCount::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CC16C: using guessed type void *CSearch::`vftable';
// 4CC488: using guessed type void *CReferenceCount::`vftable';

//----- (004167F0) --------------------------------------------------------
void *__thiscall sub_4167F0(void *this, char a2)
{
  sub_4820E0((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00416820) --------------------------------------------------------
_DWORD *__usercall sub_416820@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edi>)
{
  unsigned int v2; // ecx
  int v4; // esi
  _DWORD *v5; // ecx
  _DWORD *result; // eax

  v2 = a2[1];
  if ( (unsigned int)a1 >= v2 || *a2 > (unsigned int)a1 )
  {
    if ( v2 == a2[2] )
      sub_416BA0(a2);
    result = (_DWORD *)a2[1];
    if ( result )
    {
      *result = *a1;
      result[1] = a1[1];
      result[2] = a1[2];
    }
  }
  else
  {
    v4 = ((int)a1 - *a2) / 12;
    if ( v2 == a2[2] )
      sub_416BA0(a2);
    v5 = (_DWORD *)(*a2 + 12 * v4);
    result = (_DWORD *)a2[1];
    if ( result )
    {
      *result = *v5;
      result[1] = v5[1];
      result[2] = v5[2];
      a2[1] += 12;
      return result;
    }
  }
  a2[1] += 12;
  return result;
}

//----- (004168A0) --------------------------------------------------------
void __usercall sub_4168A0(_DWORD *a1@<edi>)
{
  int v1; // esi
  void *v2; // [esp+8h] [ebp-4h] BYREF

  sub_416D20((int)(a1 + 1));
  v1 = a1[4];
  v2 = (void *)a1[1];
  if ( v1 != a1[5] )
    a1[5] = v1;
  sub_416F30(0x10u, a1 + 4, (void **)a1[4], &v2);
  a1[8] = 7;
  a1[9] = 8;
}

//----- (00416900) --------------------------------------------------------
int __usercall sub_416900@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<esi>)
{
  int v2; // edi
  int result; // eax
  int v4; // ecx

  v2 = a2[4];
  result = (a2[1] - *a2) / 28;
  if ( result == v2 )
  {
    if ( v2 )
    {
      sub_4090E0(a2[3], a1, 0, 0xFFFFFFFF);
      a2[3] += 28;
      result = a2[3];
      if ( result == a2[1] )
        a2[3] = *a2;
      a2[2] = a2[3];
    }
  }
  else
  {
    v4 = a2[3];
    if ( v4 )
    {
      *(_DWORD *)(v4 + 20) = 7;
      *(_DWORD *)(v4 + 16) = 0;
      *(_WORD *)v4 = 0;
      sub_4090E0(v4, a1, 0, 0xFFFFFFFF);
    }
    a2[3] += 28;
    result = a2[3];
    if ( result == a2[1] )
      a2[3] = *a2;
    ++a2[4];
  }
  return result;
}

//----- (004169E0) --------------------------------------------------------
int __stdcall sub_4169E0(int *a1, _DWORD *a2)
{
  int v2; // edi
  int v3; // ebx
  int result; // eax
  bool v5; // zf
  int v6; // ecx
  _DWORD v7[7]; // [esp+0h] [ebp-28h] BYREF
  int v8; // [esp+24h] [ebp-4h]

  v7[6] = v7;
  v8 = 0;
  v2 = *a1;
  v3 = a1[4];
  result = (a1[1] - *a1) / 28;
  if ( result == v3 )
  {
    if ( v3 )
    {
      if ( a1[2] == v2 )
        a1[2] = a1[1];
      a1[2] -= 28;
      sub_4090E0(a1[2], a2, 0, 0xFFFFFFFF);
      result = a1[2];
      a1[3] = result;
    }
  }
  else
  {
    if ( a1[2] == v2 )
    {
      result = a1[1];
      a1[2] = result;
    }
    v5 = a1[2] == 28;
    a1[2] -= 28;
    v6 = a1[2];
    v7[5] = v6;
    v7[4] = v6;
    LOBYTE(v8) = 1;
    if ( !v5 )
    {
      *(_DWORD *)(v6 + 20) = 7;
      *(_DWORD *)(v6 + 16) = 0;
      *(_WORD *)v6 = 0;
      result = sub_4090E0(v6, a2, 0, 0xFFFFFFFF);
    }
    ++a1[4];
  }
  return result;
}

//----- (00416AF0) --------------------------------------------------------
_DWORD *__userpurge sub_416AF0@<eax>(_DWORD *a1@<edi>, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  _DWORD *v5; // esi
  int v6; // esi

  v4 = a4;
  v5 = (_DWORD *)(a4 + 28);
  if ( a4 + 28 == a1[1] )
    v5 = (_DWORD *)*a1;
  while ( v5 != (_DWORD *)a1[3] )
  {
    sub_4090E0(v4, v5, 0, 0xFFFFFFFF);
    v4 = (int)v5;
    v5 += 7;
    if ( v5 == (_DWORD *)a1[1] )
      v5 = (_DWORD *)*a1;
  }
  if ( a1[3] == *a1 )
    a1[3] = a1[1];
  a1[3] -= 28;
  v6 = a1[3];
  if ( *(_DWORD *)(v6 + 20) >= 8u )
    operator delete(*(void **)v6);
  *(_DWORD *)(v6 + 20) = 7;
  *(_DWORD *)(v6 + 16) = 0;
  *(_WORD *)v6 = 0;
  --a1[4];
  if ( a1[3] == a4 )
  {
    a3 = (int)a1;
    a4 = 0;
  }
  a2[1] = a4;
  *a2 = a3;
  return a2;
}

//----- (00416BA0) --------------------------------------------------------
unsigned int __thiscall sub_416BA0(_DWORD *this)
{
  unsigned int v1; // esi
  unsigned int result; // eax
  unsigned int v3; // eax

  if ( (unsigned int)((this[1] - *this) / 12) > 0x15555554 )
    std::_Xlength_error("vector<T> too long");
  v1 = (this[1] - *this) / 12 + 1;
  result = (this[2] - *this) / 12;
  if ( v1 > result )
  {
    if ( 357913941 - (result >> 1) >= result )
      v3 = (result >> 1) + result;
    else
      v3 = 0;
    if ( v3 < v1 )
      v3 = (this[1] - *this) / 12 + 1;
    return sub_416D80((int)this, v3);
  }
  return result;
}

//----- (00416C10) --------------------------------------------------------
int __stdcall sub_416C10(int a1, char *a2)
{
  _DWORD *v2; // eax
  char *v3; // eax
  int v4; // edi
  int pExceptionObject[3]; // [esp+10h] [ebp-18h] BYREF
  int v7; // [esp+24h] [ebp-4h]

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = operator new(0x28u);
  if ( !v2 )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 4) = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  v7 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  LOBYTE(v7) = 1;
  v3 = *(char **)(a1 + 4);
  *(float *)(a1 + 40) = 1.0;
  v4 = *(_DWORD *)(a1 + 16);
  a2 = v3;
  if ( v4 != *(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = v4;
  sub_416F30(0x10u, (int *)(a1 + 16), *(void ***)(a1 + 16), (void **)&a2);
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 36) = 8;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00416D20) --------------------------------------------------------
void __usercall sub_416D20(int a1@<ebx>)
{
  void **v1; // esi
  void **v2; // edi

  v1 = **(void ****)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(void ***)a1 )
  {
    do
    {
      v2 = (void **)*v1;
      if ( (unsigned int)v1[8] >= 8 )
        operator delete(v1[3]);
      v1[8] = (void *)7;
      v1[7] = 0;
      *((_WORD *)v1 + 6) = 0;
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *(void ***)a1 );
  }
}

//----- (00416D80) --------------------------------------------------------
unsigned int __thiscall sub_416D80(int this, unsigned int a2)
{
  unsigned int result; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // ecx
  int v7; // edi
  int v8; // [esp+0h] [ebp-24h] BYREF
  void *v9; // [esp+10h] [ebp-14h]
  int *v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+20h] [ebp-4h]

  v10 = &v8;
  if ( a2 > 0x15555555 )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(this + 8) - *(_DWORD *)this) / 12;
  if ( result < a2 )
  {
    v4 = sub_40F660(a2);
    v11 = 0;
    v5 = *(_DWORD **)(this + 4);
    v6 = *(_DWORD **)this;
    v9 = v4;
    sub_417830(v4, v5, v6);
    v7 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) / 12;
    if ( *(_DWORD *)this )
      operator delete(*(void **)this);
    result = (unsigned int)v9;
    *(_DWORD *)(this + 8) = (char *)v9 + 12 * a2;
    *(_DWORD *)(this + 4) = result + 12 * v7;
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (00416E70) --------------------------------------------------------
int __usercall sub_416E70@<eax>(_DWORD *a1@<esi>)
{
  unsigned int i; // ebx
  int v2; // edi
  int result; // eax

  for ( i = 0; i < a1[4]; ++i )
  {
    v2 = a1[2];
    if ( *(_DWORD *)(v2 + 20) >= 8u )
      operator delete(*(void **)v2);
    *(_DWORD *)(v2 + 20) = 7;
    *(_DWORD *)(v2 + 16) = 0;
    *(_WORD *)v2 = 0;
    a1[2] += 28;
    result = a1[2];
    if ( result == a1[1] )
      a1[2] = *a1;
  }
  return result;
}

//----- (00416ED0) --------------------------------------------------------
void *__fastcall sub_416ED0(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x9249249 || (result = operator new(28 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00416F30) --------------------------------------------------------
void __fastcall sub_416F30(unsigned int a1, int *a2, void **a3, void **a4)
{
  char *v6; // ebx
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // eax
  void *v12; // eax
  int v13; // ebx
  unsigned int v14; // ecx
  void *v15; // ebx
  unsigned int v16; // edi
  unsigned int v17; // esi
  void **i; // eax
  unsigned int v19; // eax
  void **v20; // edi
  _DWORD *v21; // eax
  void **v22; // ecx
  void **v23; // eax
  int v24; // ebx
  void *v25; // edx
  void **v26; // eax
  int v27; // [esp+0h] [ebp-28h] BYREF
  void *v28; // [esp+10h] [ebp-18h] BYREF
  unsigned int v29; // [esp+14h] [ebp-14h]
  int *v30; // [esp+18h] [ebp-10h]
  int v31; // [esp+24h] [ebp-4h]
  unsigned int v32; // [esp+34h] [ebp+Ch]

  v30 = &v27;
  if ( a1 )
  {
    v6 = (char *)a2[1];
    v7 = *a2;
    v8 = (int)&v6[-*a2] >> 2;
    if ( 0x3FFFFFFF - v8 < a1 )
      std::_Xlength_error("vector<T> too long");
    v9 = v8 + a1;
    v10 = (a2[2] - v7) >> 2;
    if ( v10 >= v9 )
    {
      if ( (v6 - (char *)a3) >> 2 >= a1 )
      {
        v28 = *a4;
        v19 = 4 * a1;
        v20 = (void **)&v6[-4 * a1];
        v32 = v19;
        v21 = sub_417860(v6, v6, v20);
        v22 = a3;
        a2[1] = (int)v21;
        v23 = v20;
        if ( a3 != v20 )
        {
          v24 = v6 - (char *)v20;
          do
          {
            v25 = *--v23;
            *(void **)((char *)v23 + v24) = v25;
            v22 = a3;
          }
          while ( a3 != v23 );
        }
        v26 = v22;
        if ( v22 != (void **)((char *)v22 + v32) )
        {
          do
            *v26++ = v28;
          while ( v26 != (void **)((char *)a3 + v32) );
        }
      }
      else
      {
        v28 = *a4;
        sub_417860(&a3[a1], v6, a3);
        v31 = 2;
        sub_417810(a1 - ((a2[1] - (int)a3) >> 2), &v28, (_DWORD *)a2[1]);
        a2[1] += 4 * a1;
        v17 = a2[1] - 4 * a1;
        for ( i = a3; i != (void **)v17; ++i )
          *i = v28;
      }
    }
    else
    {
      if ( 0x3FFFFFFF - (v10 >> 1) >= v10 )
      {
        v11 = (v10 >> 1) + v10;
        v29 = v11;
      }
      else
      {
        v29 = 0;
        v11 = 0;
      }
      if ( v11 < v9 )
      {
        v29 = v9;
        v11 = v9;
      }
      v12 = sub_419F70(v11);
      v13 = (int)a3 - *a2;
      v28 = v12;
      v13 >>= 2;
      v31 = 0;
      sub_417810(a1, a4, (_DWORD *)v12 + v13);
      sub_417860(v28, a3, (_DWORD *)*a2);
      v14 = v13 + a1;
      v15 = v28;
      sub_417860((_DWORD *)v28 + v14, (_DWORD *)a2[1], a3);
      v16 = ((a2[1] - *a2) >> 2) + a1;
      if ( *a2 )
        operator delete((void *)*a2);
      a2[2] = (int)v15 + 4 * v29;
      a2[1] = (int)v15 + 4 * v16;
      *a2 = (int)v15;
    }
  }
}

//----- (00417180) --------------------------------------------------------
_DWORD *__usercall sub_417180@<eax>(
        _DWORD *a1@<esi>,
        void *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12)
{
  int v12; // ecx
  bool v13; // cf
  int v15; // [esp-10h] [ebp-50h] BYREF
  void *v16[4]; // [esp+0h] [ebp-40h] BYREF
  int v17; // [esp+10h] [ebp-30h]
  int v18; // [esp+14h] [ebp-2Ch]
  int v19; // [esp+24h] [ebp-1Ch]
  int v20; // [esp+28h] [ebp-18h]
  void **v21; // [esp+2Ch] [ebp-14h]
  int v22; // [esp+3Ch] [ebp-4h]

  v21 = v16;
  v22 = 0;
  v17 = 0;
  v18 = 7;
  LOWORD(v16[0]) = 0;
  sub_4090E0((int)v16, &a2, 0, 0xFFFFFFFF);
  v21 = (void **)&v15;
  sub_4175F0(a9, a10, a11, a12, v16[0], (int)v16[1], (int)v16[2], (int)v16[3], v17, v18);
  v12 = v20;
  v13 = (unsigned int)a7 < 8;
  a9 = v19;
  a10 = v20;
  *a1 = v19;
  a1[1] = v12;
  if ( !v13 )
    operator delete(a2);
  return a1;
}

//----- (00417240) --------------------------------------------------------
void __thiscall sub_417240(_DWORD *this, _DWORD **a2)
{
  _DWORD *v2; // edi
  _DWORD *i; // [esp+10h] [ebp-30h]
  void *v5[5]; // [esp+14h] [ebp-2Ch] BYREF
  unsigned int v6; // [esp+28h] [ebp-18h]
  int v7; // [esp+3Ch] [ebp-4h]

  v2 = (_DWORD *)**a2;
  for ( i = *a2; v2 != i; v2 = (_DWORD *)*v2 )
  {
    LOWORD(v5[0]) = 0;
    v6 = 7;
    v5[4] = 0;
    sub_4090E0((int)v5, v2 + 2, 0, 0xFFFFFFFF);
    v7 = 0;
    sub_416900(v5, this);
    v7 = -1;
    if ( v6 >= 8 )
      operator delete(v5[0]);
  }
}

//----- (004172F0) --------------------------------------------------------
std::exception *__thiscall sub_4172F0(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 4BDA1C: using guessed type void *std::length_error::`vftable';

//----- (00417310) --------------------------------------------------------
int __stdcall sub_417310(int a1, int a2, int a3, void *a4)
{
  div_t v4; // rax
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // esi
  int v11; // ecx
  _DWORD *v12; // edi
  void *v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int result; // eax
  int v18; // ecx

  v4 = div(*(_DWORD *)a3, 127773);
  v4.rem = 16807 * v4.rem - 2836 * v4.quot + (16807 * v4.rem - 2836 * v4.quot < 0 ? 0x7FFFFFFF : 0);
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 32);
  v7 = v4.rem & v6;
  if ( *(_DWORD *)(a1 + 36) <= (v4.rem & v6) )
    v7 += -1 - (v6 >> 1);
  v8 = *(_DWORD *)(a1 + 16);
  v9 = *(_DWORD *)(v8 + 8 * v7);
  v10 = *(_DWORD *)(a1 + 4);
  v11 = v8 + 8 * v7;
  v12 = (_DWORD *)(a1 + 4);
  if ( v10 == v9 || (v10 = **(_DWORD **)(v11 + 4), v10 == v9) )
  {
LABEL_7:
    v13 = a4;
    if ( v10 != *(_DWORD *)a4 )
    {
      sub_417530(a1 + 4, a1 + 4, v10, (int)a4, *(_DWORD *)a4);
      v13 = a4;
      v5 = a1;
    }
    v14 = *(_DWORD *)(v5 + 16);
    v15 = *(_DWORD *)(v14 + 8 * v7);
    v16 = v14 + 8 * v7;
    a3 = (int)v13;
    if ( v15 == *v12 )
    {
      *(_DWORD *)v16 = v13;
      *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) = a3;
    }
    else if ( v15 == v10 )
    {
      *(_DWORD *)v16 = v13;
    }
    else
    {
      v18 = **(_DWORD **)(v16 + 4);
      *(_DWORD *)(v16 + 4) = v18;
      if ( v18 != a3 )
        *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) + 4);
    }
    sub_417420(a1);
    result = a2;
    *(_DWORD *)a2 = a4;
    *(_BYTE *)(result + 4) = 1;
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(v10 + 4);
      if ( *(_DWORD *)(v10 + 8) == *(_DWORD *)a3 )
        break;
      if ( v10 == v9 )
        goto LABEL_7;
    }
    sub_4174D0(&a1, (int)v12, a4);
    result = a2;
    *(_DWORD *)a2 = v10;
    *(_BYTE *)(result + 4) = 0;
  }
  return result;
}

//----- (00417420) --------------------------------------------------------
void __stdcall sub_417420(int a1)
{
  double v1; // st7
  unsigned int v2; // esi
  int i; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // [esp-8h] [ebp-14h]
  float v7; // [esp+8h] [ebp-4h] BYREF

  v1 = *(float *)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 36);
  v7 = (double)*(unsigned int *)(a1 + 8) / (double)v2;
  if ( v7 > v1 )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( v2 >= 0x1FFFFFFF )
        break;
      v2 *= 2;
    }
    v4 = *(_DWORD *)(a1 + 20);
    v5 = *(_DWORD *)(a1 + 16);
    v7 = *(float *)(a1 + 4);
    if ( v5 != v4 )
      *(_DWORD *)(a1 + 20) = v5;
    sub_416F30(2 * v2, (int *)(a1 + 16), *(void ***)(a1 + 16), (void **)&v7);
    v6 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 32) = v2 - 1;
    *(_DWORD *)(a1 + 36) = v2;
    sub_4175A0((_DWORD **)a1, v6);
  }
}

//----- (004174D0) --------------------------------------------------------
_DWORD *__userpurge sub_4174D0@<eax>(_DWORD *a1@<ebx>, int a2@<edi>, void *a3)
{
  void *v4; // eax
  void *v6; // [esp+Ch] [ebp+8h]

  v4 = *(void **)a3;
  v6 = *(void **)a3;
  if ( a3 != *(void **)a2 )
  {
    **((_DWORD **)a3 + 1) = *(_DWORD *)a3;
    *(_DWORD *)(*(_DWORD *)a3 + 4) = *((_DWORD *)a3 + 1);
    if ( *((_DWORD *)a3 + 8) >= 8u )
      operator delete(*((void **)a3 + 3));
    *((_DWORD *)a3 + 8) = 7;
    *((_DWORD *)a3 + 7) = 0;
    *((_WORD *)a3 + 6) = 0;
    operator delete(a3);
    v4 = v6;
    --*(_DWORD *)(a2 + 4);
  }
  *a1 = v4;
  return a1;
}

//----- (00417530) --------------------------------------------------------
int __fastcall sub_417530(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v6; // ecx
  int result; // eax

  if ( a2 != a1 )
  {
    v5 = *(_DWORD *)(a2 + 4);
    if ( v5 == 134217726 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a2 + 4) = v5 + 1;
    --*(_DWORD *)(a1 + 4);
  }
  **(_DWORD **)(a4 + 4) = a5;
  **(_DWORD **)(a5 + 4) = a3;
  **(_DWORD **)(a3 + 4) = a4;
  v6 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a5 + 4);
  result = a5;
  *(_DWORD *)(a5 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a4 + 4) = v6;
  return result;
}

//----- (004175A0) --------------------------------------------------------
int __thiscall sub_4175A0(_DWORD **this, int a2)
{
  int result; // eax
  bool v4; // bl
  void *v5; // [esp-8h] [ebp-14h]
  int v6; // [esp+4h] [ebp-8h] BYREF
  int v7; // [esp+14h] [ebp+8h]

  result = a2;
  if ( *this[1] != a2 )
  {
    v7 = *(_DWORD *)(a2 + 4);
    do
    {
      v5 = (void *)*this[1];
      v4 = v5 == (void *)v7;
      result = sub_417310((int)this, (int)&v6, (int)v5 + 8, v5);
    }
    while ( !v4 );
  }
  return result;
}

//----- (004175F0) --------------------------------------------------------
int *__cdecl sub_4175F0(int a1, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ecx
  int *v11; // esi
  _DWORD *v12; // eax
  _WORD *v13; // eax
  int v14; // edx
  void **v15; // ecx
  int v16; // eax
  bool v17; // bl
  int v18; // ecx
  void *v20[4]; // [esp+10h] [ebp-2Ch] BYREF
  unsigned int v21; // [esp+20h] [ebp-1Ch]
  unsigned int v22; // [esp+24h] [ebp-18h]
  int *v23; // [esp+2Ch] [ebp-10h]
  int v24; // [esp+38h] [ebp-4h]

  v11 = (int *)v10;
  v23 = (int *)v10;
  v24 = 0;
  v12 = (_DWORD *)a2;
  if ( a2 == a4 )
  {
    v18 = a1;
  }
  else
  {
    do
    {
      LOWORD(v20[0]) = 0;
      v22 = 7;
      v21 = 0;
      sub_4090E0((int)v20, v12, 0, 0xFFFFFFFF);
      v13 = a5;
      if ( (unsigned int)a10 < 8 )
        v13 = &a5;
      v14 = v21;
      if ( v21 >= a9 )
        v14 = a9;
      v15 = (void **)v20[0];
      if ( v22 < 8 )
        v15 = v20;
      if ( v14 )
      {
        while ( *(_WORD *)v15 == *v13 )
        {
          v15 = (void **)((char *)v15 + 2);
          ++v13;
          if ( !--v14 )
            goto LABEL_13;
        }
        v16 = *(_WORD *)v15 < *v13 ? -1 : 1;
      }
      else
      {
LABEL_13:
        if ( v21 >= a9 )
          v16 = v21 != a9;
        else
          v16 = -1;
      }
      v17 = v16 == 0;
      LOBYTE(v24) = 0;
      if ( v22 >= 8 )
        operator delete(v20[0]);
      v12 = (_DWORD *)a2;
      v18 = a1;
      if ( v17 )
        break;
      v12 = (_DWORD *)(a2 + 28);
      a2 = (int)v12;
      if ( v12 == *(_DWORD **)(a1 + 4) )
      {
        v12 = *(_DWORD **)a1;
        a2 = *(_DWORD *)a1;
      }
      if ( v12 == *(_DWORD **)(a1 + 12) )
      {
        v12 = 0;
        a2 = 0;
      }
    }
    while ( v12 != (_DWORD *)a4 );
    v11 = v23;
  }
  *v11 = v18;
  v11[1] = (int)v12;
  if ( (unsigned int)a10 >= 8 )
    operator delete(a5);
  return v11;
}
// 417699: conditional instruction was optimized away because eax.4 is in (==1|==FFFFFFFF)
// 417618: variable 'v10' is possibly undefined

//----- (00417730) --------------------------------------------------------
bool __cdecl sub_417730(int a1, int a2, int *a3, int a4)
{
  bool v5; // al
  int v6; // edi
  bool v7; // bl
  int v8; // eax
  int v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // esi
  char v11[4]; // [esp+14h] [ebp-254h] BYREF
  char v12[564]; // [esp+18h] [ebp-250h] BYREF
  int v13; // [esp+24Ch] [ebp-1Ch]
  int v14; // [esp+264h] [ebp-4h]

  if ( !*a3 )
    return 0;
  sub_4143A0(*a3, a2, a4, (int)v12, a1, *(_DWORD *)(*a3 + 24), *(_DWORD *)(*a3 + 20));
  v14 = 0;
  v5 = sub_414860(1, 0, (int)v12);
  v14 = -1;
  v6 = v13;
  v7 = v5;
  if ( v13 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
    v8 = *(_DWORD *)(v6 + 4);
    if ( v8 && v8 != -1 )
      *(_DWORD *)(v6 + 4) = v8 - 1;
    v9 = -(*(_DWORD *)(v6 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v11);
    v10 = (void (__thiscall ***)(_DWORD, int))(v6 & v9);
    if ( v10 )
      (**v10)(v10, 1);
  }
  return v7;
}
// 417730: using guessed type char var_254[4];

//----- (00417810) --------------------------------------------------------
int __usercall sub_417810@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  for ( ; result; --result )
  {
    if ( a3 )
      *a3 = *a2;
    ++a3;
  }
  return result;
}

//----- (00417830) --------------------------------------------------------
_DWORD *__usercall sub_417830@<eax>(_DWORD *result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  for ( ; a3 != a2; result += 3 )
  {
    if ( result )
    {
      *result = *a3;
      result[1] = a3[1];
      result[2] = a3[2];
    }
    a3 += 3;
  }
  return result;
}

//----- (00417860) --------------------------------------------------------
_DWORD *__usercall sub_417860@<eax>(_DWORD *result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  for ( ; a3 != a2; ++result )
  {
    if ( result )
      *result = *a3;
    ++a3;
  }
  return result;
}

//----- (00417880) --------------------------------------------------------
int __usercall sub_417880@<eax>(int a1@<eax>, int a2@<ecx>)
{
  unsigned int v2; // ecx
  _DWORD *v4; // esi
  unsigned int v5; // eax

  v2 = *(_DWORD *)(a2 + 4);
  if ( !v2 )
    return **(_DWORD **)a1 + 28 * *(_DWORD *)(*(_DWORD *)a1 + 16);
  v4 = *(_DWORD **)a1;
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 8);
  if ( v2 >= v5 )
    return *v4 + 28 * ((int)(v2 - v5) / 28);
  else
    return v2 + 28 * ((int)(v4[1] - v5) / 28);
}

//----- (004178F0) --------------------------------------------------------
char **__thiscall sub_4178F0(_DWORD *this, char *a2, int a3)
{
  char **v4; // eax
  char **v5; // esi
  int v6; // ecx
  _DWORD *v7; // eax
  int v9; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[5]; // [esp+10h] [ebp-20h] BYREF
  int v11; // [esp+2Ch] [ebp-4h]

  pExceptionObject[4] = (int)&v9;
  v4 = (char **)operator new(0x28u);
  v5 = v4;
  pExceptionObject[3] = (int)v4;
  if ( !v4 )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v11 = 0;
  v6 = a3;
  *v4 = a2;
  v7 = v4 + 2;
  v5[1] = (char *)v6;
  a2 = (char *)(v5 + 2);
  a3 = (int)(v5 + 2);
  LOBYTE(v11) = 1;
  if ( v7 )
  {
    *v7 = *this;
    v5[8] = (char *)7;
    v5[7] = 0;
    *((_WORD *)v5 + 6) = 0;
    sub_40AF70(v5 + 3, this + 1);
  }
  return v5;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004179C0) --------------------------------------------------------
void __usercall sub_4179C0(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi

  if ( *(_DWORD *)(a1 + 16) )
    operator delete(*(void **)(a1 + 16));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v1 = *(_DWORD ***)(a1 + 4);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 8) = 0;
  if ( v2 != *(_DWORD **)(a1 + 4) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 4) );
  }
  operator delete(*(void **)(a1 + 4));
}

//----- (00417A20) --------------------------------------------------------
_DWORD *__userpurge sub_417A20@<eax>(_DWORD *a1@<eax>, int *a2@<ebx>, _DWORD *a3)
{
  div_t v4; // rax
  unsigned int v5; // eax
  int v6; // ecx
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  int v9; // edx
  _DWORD *i; // eax
  _DWORD *v11; // ecx
  int v12; // ecx
  _DWORD *result; // eax
  _DWORD *v14; // [esp+Ch] [ebp-4h]

  v4 = div(*a2, 127773);
  v5 = (16807 * v4.rem - 2836 * v4.quot + (16807 * v4.rem - 2836 * v4.quot < 0 ? 0x7FFFFFFF : 0)) & a1[8];
  if ( a1[9] <= v5 )
    v5 += -1 - (a1[8] >> 1);
  v6 = a1[4];
  v7 = *(_DWORD **)(v6 + 8 * v5);
  v8 = (_DWORD *)a1[1];
  v9 = v6 + 8 * v5;
  for ( i = v7; ; i = (_DWORD *)*i )
  {
    if ( v7 == v8 )
      v11 = v8;
    else
      v11 = **(_DWORD ***)(v9 + 4);
    if ( i == v11 )
    {
      result = a3;
      *a3 = v8;
      return result;
    }
    v12 = i[2];
    if ( v12 == *a2 )
      break;
  }
  v14 = i;
  result = a3;
  if ( *a2 == v12 )
    *a3 = v14;
  else
    *a3 = v8;
  return result;
}

//----- (00417AD0) --------------------------------------------------------
int __userpurge sub_417AD0@<eax>(char ***a1@<esi>, int a2, int a3, int a4)
{
  char *v4; // eax
  char **v5; // edi

  v4 = **a1;
  **a1 = (char *)*a1;
  (*a1)[1] = (char *)*a1;
  a1[1] = 0;
  if ( v4 != (char *)*a1 )
  {
    do
    {
      v5 = *(char ***)v4;
      operator delete(v4);
      v4 = (char *)v5;
    }
    while ( v5 != *a1 );
  }
  return sub_40B580((int)a1, **a1, a2, a3, a3);
}

//----- (00417B20) --------------------------------------------------------
void __usercall sub_417B20(int a1@<esi>)
{
  if ( *(_DWORD *)a1 )
    operator delete(*(void **)a1);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
}

//----- (00417B50) --------------------------------------------------------
int *__stdcall sub_417B50(void **a1, int a2, int a3, int a4)
{
  _DWORD v5[8]; // [esp+0h] [ebp-20h] BYREF

  v5[4] = v5;
  v5[7] = 0;
  return sub_417BC0((int)a1, *a1, a2, a3, (int)a1);
}

//----- (00417BC0) --------------------------------------------------------
int *__thiscall sub_417BC0(int this, void *Src, int a3, int a4, int a5)
{
  int *result; // eax
  unsigned int v7; // edi
  int v8; // ecx
  unsigned int v9; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  void *v12; // edx
  size_t v13; // ebx
  char *v14; // eax
  _DWORD *v15; // eax
  unsigned int v16; // edi
  char *v17; // edx
  unsigned int v18; // edi
  const void *v19; // [esp-8h] [ebp-30h]
  int v20; // [esp+0h] [ebp-28h] BYREF
  void *v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  int *v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+24h] [ebp-4h]

  v23 = &v20;
  result = (int *)a3;
  v7 = 0;
  if ( a3 != a4 )
  {
    do
    {
      result = (int *)*result;
      ++v7;
    }
    while ( result != (int *)a4 );
    if ( v7 )
    {
      v8 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
      if ( 0x3FFFFFFF - v8 < v7 )
        std::_Xlength_error("vector<T> too long");
      v9 = v8 + v7;
      v10 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
      if ( v10 >= v9 )
      {
        sub_417D70(*(_DWORD **)(this + 4), (_DWORD *)a3, (_DWORD *)a4);
        result = *(int **)(this + 4);
        v18 = v7;
        if ( Src != result && result != &result[v18] )
          result = (int *)sub_417DA0((int)result, Src, &result[v18]);
        *(_DWORD *)(this + 4) += v18 * 4;
      }
      else
      {
        if ( 0x3FFFFFFF - (v10 >> 1) >= v10 )
        {
          v11 = (v10 >> 1) + v10;
          v22 = v11;
        }
        else
        {
          v22 = 0;
          v11 = 0;
        }
        if ( v11 < v9 )
        {
          v22 = v9;
          v11 = v9;
        }
        v12 = sub_419F70(v11);
        v24 = 0;
        v13 = 4 * (((int)Src - *(_DWORD *)this) >> 2);
        v19 = *(const void **)this;
        v21 = v12;
        v14 = (char *)memcpy(v12, v19, v13);
        v15 = sub_417D70(&v14[v13], (_DWORD *)a3, (_DWORD *)a4);
        memcpy(v15, Src, 4 * ((*(_DWORD *)(this + 4) - (int)Src) >> 2));
        v16 = ((*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2) + v7;
        if ( *(_DWORD *)this )
          operator delete(*(void **)this);
        result = (int *)v21;
        v17 = (char *)v21 + 4 * v16;
        *(_DWORD *)(this + 8) = (char *)v21 + 4 * v22;
        *(_DWORD *)(this + 4) = v17;
        *(_DWORD *)this = result;
      }
    }
  }
  return result;
}

//----- (00417D70) --------------------------------------------------------
_DWORD *__usercall sub_417D70@<eax>(_DWORD *result@<eax>, _DWORD *a2, _DWORD *a3)
{
  _DWORD *i; // ecx

  for ( i = a2; i != a3; ++result )
  {
    if ( result )
      *result = i[2];
    i = (_DWORD *)*i;
  }
  return result;
}

//----- (00417DA0) --------------------------------------------------------
int __usercall sub_417DA0@<eax>(int a1@<eax>, _DWORD *a2, int *a3)
{
  _DWORD *v3; // edx
  int *v4; // ebx
  int v5; // edi
  int result; // eax
  int v7; // esi
  int v8; // edx
  int *v9; // edx
  int *v10; // ecx
  int *v11; // esi
  int v12; // edx
  int v13; // edx
  int *v14; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = a3;
  v5 = (a1 - (int)a2) >> 2;
  result = a3 - a2;
  v7 = v5;
  if ( v5 )
  {
    do
    {
      v8 = result % v7;
      result = v7;
      v7 = v8;
    }
    while ( v8 );
    v3 = a2;
  }
  if ( result < a3 - a2 && result > 0 )
  {
    v9 = &v3[result];
    v14 = v9;
    do
    {
      v10 = &v9[v5];
      v11 = v9;
      if ( v10 == v4 )
        v10 = a2;
      do
      {
        v12 = *v11;
        *v11 = *v10;
        v4 = a3;
        *v10 = v12;
        v13 = a3 - v10;
        v11 = v10;
        if ( v5 >= v13 )
          v10 = &a2[v5 - v13];
        else
          v10 += v5;
      }
      while ( v10 != v14 );
      --result;
      v9 = --v14;
    }
    while ( result > 0 );
  }
  return result;
}

//----- (00417E40) --------------------------------------------------------
BSTR **__userpurge sub_417E40@<eax>(const OLECHAR *a1@<edi>, BSTR **a2)
{
  BSTR *v2; // eax
  BSTR *v3; // esi
  BSTR v4; // eax
  BSTR **result; // eax

  v2 = (BSTR *)operator new(0xCu);
  v3 = v2;
  if ( v2 )
  {
    v2[1] = 0;
    v2[2] = (BSTR)1;
    v4 = SysAllocString(a1);
    *v3 = v4;
    if ( !v4 && a1 )
      sub_44DFE0(-2147024882);
  }
  else
  {
    v3 = 0;
  }
  result = a2;
  *a2 = v3;
  if ( !v3 )
    sub_44DFE0(-2147024882);
  return result;
}

//----- (00417EE0) --------------------------------------------------------
void __usercall sub_417EE0(int *a1@<edi>)
{
  int v1; // esi

  v1 = *a1;
  if ( *a1 )
  {
    if ( !InterlockedDecrement((volatile LONG *)(v1 + 8)) && v1 )
    {
      if ( *(_DWORD *)v1 )
        SysFreeString(*(BSTR *)v1);
      if ( *(_DWORD *)(v1 + 4) )
        operator delete[](*(void **)(v1 + 4));
      operator delete((void *)v1);
    }
    *a1 = 0;
  }
}

//----- (00417F40) --------------------------------------------------------
void *__thiscall sub_417F40(void *this, char a2)
{
  sub_47C4B0((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00417F70) --------------------------------------------------------
void *__thiscall sub_417F70(void *this, char a2)
{
  sub_47C430((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00417FA0) --------------------------------------------------------
int __stdcall sub_417FA0(int a1, char *a2)
{
  _DWORD *v2; // eax
  char *v3; // eax
  int v4; // edi
  int pExceptionObject[3]; // [esp+10h] [ebp-18h] BYREF
  int v7; // [esp+24h] [ebp-4h]

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = operator new(0x10u);
  if ( !v2 )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 4) = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  v7 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  LOBYTE(v7) = 1;
  v3 = *(char **)(a1 + 4);
  *(float *)(a1 + 40) = 1.0;
  v4 = *(_DWORD *)(a1 + 16);
  a2 = v3;
  if ( v4 != *(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = v4;
  sub_416F30(0x10u, (int *)(a1 + 16), *(void ***)(a1 + 16), (void **)&a2);
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 36) = 8;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00418090) --------------------------------------------------------
void *__cdecl sub_418090(void *a1, int a2, int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // eax
  bool v5; // cf
  _WORD *v6; // eax

  *((_DWORD *)a1 + 5) = 7;
  *((_DWORD *)a1 + 4) = 0;
  *(_WORD *)a1 = 0;
  v3 = *((_DWORD *)a1 + 4);
  v4 = *(_DWORD *)(a2 + 16) + wcslen((const unsigned __int16 *)a3);
  if ( v3 <= v4 && *((_DWORD *)a1 + 5) != v4 && sub_409410(a1, v4, 1) )
  {
    v5 = *((_DWORD *)a1 + 5) < 8u;
    *((_DWORD *)a1 + 4) = v3;
    if ( v5 )
      v6 = a1;
    else
      v6 = *(_WORD **)a1;
    v6[v3] = 0;
  }
  sub_406A00(a1, (_DWORD *)a2, 0, 0xFFFFFFFF);
  sub_415F40((char *)a3, a1, wcslen((const unsigned __int16 *)a3));
  return a1;
}

//----- (00418180) --------------------------------------------------------
HWND __stdcall sub_418180(
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HINSTANCE hInstance,
        LPVOID lpParam)
{
  HWND result; // eax
  HWND Window; // eax
  HWND v12; // edi
  FARPROC v13; // eax
  HINSTANCE v14; // [esp+10h] [ebp-20h] BYREF
  HWND v15; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  BOOL hWndParenta; // [esp+54h] [ebp+24h]
  HINSTANCE hInstancea; // [esp+58h] [ebp+28h]
  LPVOID lpParama; // [esp+5Ch] [ebp+2Ch]

  v15 = 0;
  v14 = 0;
  if ( dword_4EF798 || (result = (HWND)sub_4015E0((int)&v14)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    Window = CreateWindowExW(
               0,
               lpClassName,
               lpWindowName,
               dwStyle,
               X,
               Y,
               nWidth,
               nHeight,
               hWndParent,
               0,
               hInstance,
               lpParam);
    v12 = Window;
    v15 = Window;
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v12;
    hWndParenta = Window == 0;
    if ( Window )
      lpParama = 0;
    else
      lpParama = (LPVOID)GetLastError();
    hInstancea = v14;
    v13 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v13 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v13 )
        goto LABEL_11;
      dword_4EF118 = (int)v13;
    }
    ((void (__stdcall *)(_DWORD, HINSTANCE))v13)(0, hInstancea);
LABEL_11:
    if ( hWndParenta )
      SetLastError((DWORD)lpParama);
    return v12;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (004182B0) --------------------------------------------------------
int __stdcall sub_4182B0(LPCWSTR lpClassName, HINSTANCE hInstance)
{
  int result; // eax
  BOOL v3; // edi
  int v4; // esi
  FARPROC v5; // eax
  int v6; // [esp+10h] [ebp-20h] BYREF
  BOOL v7; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]
  HINSTANCE hInstancea; // [esp+3Ch] [ebp+Ch]

  v7 = 0;
  v6 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v6)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    v7 = UnregisterClassW(lpClassName, hInstance);
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v7;
    v3 = !v7;
    if ( v7 )
      hInstancea = 0;
    else
      hInstancea = (HINSTANCE)GetLastError();
    v4 = v6;
    v5 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v5 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v5 )
        goto LABEL_11;
      dword_4EF118 = (int)v5;
    }
    ((void (__stdcall *)(_DWORD, int))v5)(0, v4);
LABEL_11:
    if ( v3 )
      SetLastError((DWORD)hInstancea);
    return v7;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (004183D0) --------------------------------------------------------
_DWORD *__thiscall sub_4183D0(_DWORD *this, char a2)
{
  int v4; // [esp-4h] [ebp-8h]

  v4 = this[1];
  *this = &Gdiplus::Image::`vftable';
  GdipDisposeImage(v4);
  if ( (a2 & 1) != 0 )
    GdipFree(this);
  return this;
}
// 4BD668: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 4BD6B8: using guessed type int __stdcall GdipFree(_DWORD);
// 4CC06C: using guessed type void *Gdiplus::Image::`vftable';

//----- (00418400) --------------------------------------------------------
__int16 __stdcall sub_418400(DWORD dwErrCode)
{
  int v1; // eax
  BOOL v2; // edi
  int v3; // esi
  FARPROC v4; // eax
  int v6; // [esp+14h] [ebp-20h] BYREF
  int v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v7 = 0;
  v6 = 0;
  if ( dword_4EF798 || (v1 = sub_4015E0((int)&v6)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    v7 = RegisterClassExW((const WNDCLASSEXW *)dwErrCode);
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
    {
LABEL_13:
      LOWORD(v1) = v7;
      return v1;
    }
    v2 = (_WORD)v7 == 0;
    if ( (_WORD)v7 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v3 = v6;
    v4 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v4 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v4 )
        goto LABEL_11;
      dword_4EF118 = (int)v4;
    }
    ((void (__stdcall *)(_DWORD, int))v4)(0, v3);
LABEL_11:
    if ( v2 )
      SetLastError(dwErrCodea);
    goto LABEL_13;
  }
  return v1;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (00418500) --------------------------------------------------------
void *__thiscall sub_418500(void *this, char a2)
{
  void **v3; // ebx

  v3 = (void **)((char *)this + 1052);
  *(_DWORD *)this = &CWildcardSelectDialogPersistentSettings::`vftable';
  sub_40A140((int)this + 1052);
  operator delete(*v3);
  *(_DWORD *)this = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CC310: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (00418540) --------------------------------------------------------
int __stdcall sub_418540(DWORD dwErrCode)
{
  int (__stdcall *v1)(DWORD); // esi
  int result; // eax
  FARPROC v3; // eax
  BOOL v4; // edi
  int v5; // esi
  FARPROC v6; // eax
  int v7; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  DWORD dwErrCodea; // [esp+3Ch] [ebp+8h]

  v8 = 0;
  v1 = (int (__stdcall *)(DWORD))dword_4EF81C;
  v7 = 0;
  if ( dword_4EF798 || (result = sub_4015E0((int)&v7)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    if ( !v1 )
    {
      v3 = sub_4016B0((DWORD)"InitCommonControlsEx");
      v1 = (int (__stdcall *)(DWORD))v3;
      if ( !v3 )
        goto LABEL_7;
      dword_4EF81C = (int)v3;
    }
    v8 = v1(dwErrCode);
LABEL_7:
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
      return v8;
    v4 = v8 == 0;
    if ( v8 )
      dwErrCodea = 0;
    else
      dwErrCodea = GetLastError();
    v5 = v7;
    v6 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v6 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v6 )
        goto LABEL_15;
      dword_4EF118 = (int)v6;
    }
    ((void (__stdcall *)(_DWORD, int))v6)(0, v5);
LABEL_15:
    if ( v4 )
      SetLastError(dwErrCodea);
    return v8;
  }
  return result;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;
// 4EF81C: using guessed type int dword_4EF81C;

//----- (00418660) --------------------------------------------------------
_DWORD *__usercall sub_418660@<eax>(_DWORD *a1@<eax>)
{
  bool v2; // zf

  v2 = a1[3] == 0;
  *a1 = &Explorerplusplus::CLoadSaveXML::`vftable';
  if ( v2 )
  {
    sub_46C800((int)a1);
  }
  else if ( a1[5] )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)a1[4] + 8))(a1[4]);
    a1[4] = 0;
    operator delete(a1);
    return a1;
  }
  operator delete(a1);
  return a1;
}
// 4CC344: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (004186B0) --------------------------------------------------------
void sub_4186B0()
{
  void **v0; // eax
  void *v1; // ecx
  void **v2; // esi

  if ( dword_4EF720 )
    operator delete(dword_4EF720);
  dword_4EF720 = 0;
  dword_4EF724 = 0;
  dword_4EF728 = 0;
  v0 = *(void ***)dword_4EF714;
  *(_DWORD *)dword_4EF714 = dword_4EF714;
  *((_DWORD *)dword_4EF714 + 1) = dword_4EF714;
  v1 = dword_4EF714;
  dword_4EF718 = 0;
  if ( v0 != dword_4EF714 )
  {
    do
    {
      v2 = (void **)*v0;
      operator delete(v0);
      v1 = dword_4EF714;
      v0 = v2;
    }
    while ( v2 != dword_4EF714 );
  }
  operator delete(v1);
}
// 4EF718: using guessed type int dword_4EF718;
// 4EF724: using guessed type int dword_4EF724;
// 4EF728: using guessed type int dword_4EF728;

//----- (00418730) --------------------------------------------------------
_DWORD *__userpurge sub_418730@<eax>(_DWORD *a1@<edi>, void *a2)
{
  div_t v2; // rax
  unsigned int v3; // eax
  int *v4; // ecx
  int v5; // esi

  v2 = div(*((_DWORD *)a2 + 2), 127773);
  v3 = (16807 * v2.rem - 2836 * v2.quot + (16807 * v2.rem - 2836 * v2.quot < 0 ? 0x7FFFFFFF : 0)) & dword_4EF730;
  if ( dword_4EF734 <= v3 )
    v3 += -1 - ((unsigned int)dword_4EF730 >> 1);
  v4 = (int *)a2;
  if ( *((void **)dword_4EF720 + 2 * v3 + 1) == a2 )
  {
    if ( *((void **)dword_4EF720 + 2 * v3) == a2 )
    {
      *((_DWORD *)dword_4EF720 + 2 * v3) = dword_4EF714;
      *((_DWORD *)dword_4EF720 + 2 * v3 + 1) = dword_4EF714;
    }
    else
    {
      *((_DWORD *)dword_4EF720 + 2 * v3 + 1) = *((_DWORD *)a2 + 1);
    }
  }
  else
  {
    if ( *((void **)dword_4EF720 + 2 * v3) != a2 )
      goto LABEL_10;
    *((_DWORD *)dword_4EF720 + 2 * v3) = *(_DWORD *)a2;
  }
  v4 = (int *)a2;
LABEL_10:
  v5 = *v4;
  if ( v4 != dword_4EF714 )
  {
    *(_DWORD *)v4[1] = v5;
    *(_DWORD *)(*v4 + 4) = v4[1];
    operator delete(v4);
    --dword_4EF718;
  }
  *a1 = v5;
  return a1;
}
// 4EF718: using guessed type int dword_4EF718;
// 4EF730: using guessed type int dword_4EF730;
// 4EF734: using guessed type int dword_4EF734;

//----- (004187F0) --------------------------------------------------------
__int16 *__stdcall sub_4187F0(char *a1)
{
  __int16 v1; // cx
  _DWORD *v2; // eax
  int pExceptionObject[7]; // [esp+8h] [ebp-1Ch] BYREF

  v1 = *(_WORD *)a1;
  pExceptionObject[3] = (int)&word_4EF710;
  word_4EF710 = v1;
  dword_4EF718 = 0;
  v2 = operator new(0x10u);
  if ( !v2 )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF714 = v2;
  *v2 = v2;
  *((_DWORD *)dword_4EF714 + 1) = dword_4EF714;
  pExceptionObject[6] = 1;
  dword_4EF720 = 0;
  dword_4EF724 = 0;
  dword_4EF728 = 0;
  flt_4EF738 = 1.0;
  a1 = (char *)dword_4EF714;
  sub_416F30(0x10u, (int *)&dword_4EF720, 0, (void **)&a1);
  dword_4EF730 = 7;
  dword_4EF734 = 8;
  return &word_4EF710;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4EF710: using guessed type __int16 word_4EF710;
// 4EF718: using guessed type int dword_4EF718;
// 4EF724: using guessed type int dword_4EF724;
// 4EF728: using guessed type int dword_4EF728;
// 4EF730: using guessed type int dword_4EF730;
// 4EF734: using guessed type int dword_4EF734;
// 4EF738: using guessed type float flt_4EF738;

//----- (004188E0) --------------------------------------------------------
_DWORD *__userpurge sub_4188E0@<eax>(int *a1@<ebx>, _DWORD *a2)
{
  div_t v2; // rax
  unsigned int v3; // eax
  _DWORD *i; // edx
  _DWORD *v5; // ecx
  int v6; // ecx
  _DWORD *result; // eax

  v2 = div(*a1, 127773);
  v3 = (16807 * v2.rem - 2836 * v2.quot + (16807 * v2.rem - 2836 * v2.quot < 0 ? 0x7FFFFFFF : 0)) & dword_4EF730;
  if ( dword_4EF734 <= v3 )
    v3 += -1 - ((unsigned int)dword_4EF730 >> 1);
  for ( i = (_DWORD *)*((_DWORD *)dword_4EF720 + 2 * v3); ; i = (_DWORD *)*i )
  {
    if ( *((void **)dword_4EF720 + 2 * v3) == dword_4EF714 )
      v5 = dword_4EF714;
    else
      v5 = (_DWORD *)**((_DWORD **)dword_4EF720 + 2 * v3 + 1);
    if ( i == v5 )
    {
      result = a2;
      *a2 = dword_4EF714;
      return result;
    }
    v6 = i[2];
    if ( v6 == *a1 )
      break;
  }
  result = a2;
  if ( *a1 == v6 )
    *a2 = i;
  else
    *a2 = dword_4EF714;
  return result;
}
// 4EF730: using guessed type int dword_4EF730;
// 4EF734: using guessed type int dword_4EF734;

//----- (004189A0) --------------------------------------------------------
int __usercall sub_4189A0@<eax>(int a1@<ebx>, char **a2@<esi>)
{
  int v2; // edi
  char **v3; // eax

  v2 = *(_DWORD *)dword_4EF714;
  v3 = sub_419770(a2, *(char **)dword_4EF714, *(_DWORD *)(*(_DWORD *)dword_4EF714 + 4));
  if ( dword_4EF718 == 536870910 )
    std::_Xlength_error("list<T> too long");
  ++dword_4EF718;
  *(_DWORD *)(v2 + 4) = v3;
  *(_DWORD *)v3[1] = v3;
  sub_418A00((int)&word_4EF710, a1, *(_DWORD *)dword_4EF714 + 8, *(void **)dword_4EF714);
  return a1;
}
// 4EF710: using guessed type __int16 word_4EF710;
// 4EF718: using guessed type int dword_4EF718;

//----- (00418A00) --------------------------------------------------------
int __stdcall sub_418A00(int a1, int a2, int a3, void *a4)
{
  div_t v4; // rax
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // ebx
  int v11; // ecx
  _DWORD *v12; // esi
  void *v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int result; // eax
  int v18; // ecx

  v4 = div(*(_DWORD *)a3, 127773);
  v4.rem = 16807 * v4.rem - 2836 * v4.quot + (16807 * v4.rem - 2836 * v4.quot < 0 ? 0x7FFFFFFF : 0);
  v5 = a1;
  v6 = *(_DWORD *)(a1 + 32);
  v7 = v4.rem & v6;
  if ( *(_DWORD *)(a1 + 36) <= (v4.rem & v6) )
    v7 += -1 - (v6 >> 1);
  v8 = *(_DWORD *)(a1 + 16);
  v9 = *(_DWORD *)(v8 + 8 * v7);
  v10 = *(_DWORD *)(a1 + 4);
  v11 = v8 + 8 * v7;
  v12 = (_DWORD *)(a1 + 4);
  if ( v10 == v9 || (v10 = **(_DWORD **)(v11 + 4), v10 == v9) )
  {
LABEL_7:
    v13 = a4;
    if ( v10 != *(_DWORD *)a4 )
    {
      sub_418BC0(a1 + 4, a1 + 4, v10, (int)a4, *(_DWORD *)a4);
      v13 = a4;
      v5 = a1;
    }
    v14 = *(_DWORD *)(v5 + 16);
    v15 = *(_DWORD *)(v14 + 8 * v7);
    v16 = v14 + 8 * v7;
    a3 = (int)v13;
    if ( v15 == *v12 )
    {
      *(_DWORD *)v16 = v13;
      *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) = a3;
    }
    else if ( v15 == v10 )
    {
      *(_DWORD *)v16 = v13;
    }
    else
    {
      v18 = **(_DWORD **)(v16 + 4);
      *(_DWORD *)(v16 + 4) = v18;
      if ( v18 != a3 )
        *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 16) + 8 * v7 + 4) + 4);
    }
    sub_418B10(a1);
    result = a2;
    *(_DWORD *)a2 = a4;
    *(_BYTE *)(result + 4) = 1;
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(v10 + 4);
      if ( *(_DWORD *)(v10 + 8) == *(_DWORD *)a3 )
        break;
      if ( v10 == v9 )
        goto LABEL_7;
    }
    sub_40ABF0(&a1, (int)v12, a4);
    result = a2;
    *(_DWORD *)a2 = v10;
    *(_BYTE *)(result + 4) = 0;
  }
  return result;
}

//----- (00418B10) --------------------------------------------------------
void __stdcall sub_418B10(int a1)
{
  double v1; // st7
  unsigned int v2; // esi
  int i; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // [esp-8h] [ebp-14h]
  float v7; // [esp+8h] [ebp-4h] BYREF

  v1 = *(float *)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 36);
  v7 = (double)*(unsigned int *)(a1 + 8) / (double)v2;
  if ( v7 > v1 )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( v2 >= 0x1FFFFFFF )
        break;
      v2 *= 2;
    }
    v4 = *(_DWORD *)(a1 + 20);
    v5 = *(_DWORD *)(a1 + 16);
    v7 = *(float *)(a1 + 4);
    if ( v5 != v4 )
      *(_DWORD *)(a1 + 20) = v5;
    sub_416F30(2 * v2, (int *)(a1 + 16), *(void ***)(a1 + 16), (void **)&v7);
    v6 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 32) = v2 - 1;
    *(_DWORD *)(a1 + 36) = v2;
    sub_418C30((_DWORD **)a1, v6);
  }
}

//----- (00418BC0) --------------------------------------------------------
int __fastcall sub_418BC0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v6; // ecx
  int result; // eax

  if ( a2 != a1 )
  {
    v5 = *(_DWORD *)(a2 + 4);
    if ( v5 == 536870910 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a2 + 4) = v5 + 1;
    --*(_DWORD *)(a1 + 4);
  }
  **(_DWORD **)(a4 + 4) = a5;
  **(_DWORD **)(a5 + 4) = a3;
  **(_DWORD **)(a3 + 4) = a4;
  v6 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a5 + 4);
  result = a5;
  *(_DWORD *)(a5 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a4 + 4) = v6;
  return result;
}

//----- (00418C30) --------------------------------------------------------
int __thiscall sub_418C30(_DWORD **this, int a2)
{
  int result; // eax
  bool v4; // bl
  void *v5; // [esp-8h] [ebp-14h]
  int v6; // [esp+4h] [ebp-8h] BYREF
  int v7; // [esp+14h] [ebp+8h]

  result = a2;
  if ( *this[1] != a2 )
  {
    v7 = *(_DWORD *)(a2 + 4);
    do
    {
      v5 = (void *)*this[1];
      v4 = v5 == (void *)v7;
      result = sub_418A00((int)this, (int)&v6, (int)v5 + 8, v5);
    }
    while ( !v4 );
  }
  return result;
}

//----- (00418C80) --------------------------------------------------------
int __stdcall sub_418C80(int a1, double a2)
{
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  _DWORD *v6; // eax
  struct std::locale::facet *v7; // eax
  int v8; // esi
  struct std::locale::facet *v9; // ebx
  int v10; // eax
  int v11; // esi
  void (__thiscall ***v12)(_DWORD, int); // esi
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  _DWORD v22[6]; // [esp+8h] [ebp-44h] BYREF
  bool v23; // [esp+20h] [ebp-2Ch]
  int v24; // [esp+24h] [ebp-28h]
  char v25[4]; // [esp+28h] [ebp-24h] BYREF
  int v26; // [esp+2Ch] [ebp-20h]
  int v27; // [esp+30h] [ebp-1Ch] BYREF
  int v28; // [esp+34h] [ebp-18h]
  _DWORD *v29; // [esp+3Ch] [ebp-10h]
  int v30; // [esp+48h] [ebp-4h]

  v29 = v22;
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
  v28 = 0;
  v22[5] = a1;
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v30 = 0;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  if ( !*(_DWORD *)(v3 + a1 + 12) )
  {
    v4 = *(_DWORD *)(v3 + a1 + 60);
    if ( v4 )
      sub_408280(v4);
  }
  v5 = *(_DWORD *)a1;
  v23 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 12) == 0;
  v30 = 1;
  if ( v23 )
  {
    v6 = sub_408A70((_DWORD **)(a1 + *(_DWORD *)(v5 + 4)), &v27);
    LOBYTE(v30) = 2;
    v7 = sub_40E010((int)v6);
    LOBYTE(v30) = 1;
    v8 = v27;
    v9 = v7;
    if ( v27 )
    {
      v26 = v27;
      std::_Lockit::_Lockit((std::_Lockit *)v25, 0);
      v10 = *(_DWORD *)(v8 + 4);
      if ( v10 && v10 != -1 )
        *(_DWORD *)(v8 + 4) = v10 - 1;
      v11 = -(*(_DWORD *)(v8 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v25);
      v12 = (void (__thiscall ***)(_DWORD, int))(v26 & v11);
      if ( v12 )
        (**v12)(v12, 1);
    }
    LOBYTE(v30) = 3;
    v13 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v14 = *(_DWORD *)(v13 + a1 + 56);
    v15 = *(unsigned __int16 *)(v13 + a1 + 64);
    v16 = *(_DWORD *)v9;
    LOBYTE(v24) = 0;
    (*(void (__thiscall **)(struct std::locale::facet *, double *, int, int, int, int, _DWORD, _DWORD))(v16 + 12))(
      v9,
      &a2,
      v24,
      v14,
      a1 + v13,
      v15,
      LODWORD(a2),
      HIDWORD(a2));
    if ( LOBYTE(a2) )
      v28 = 4;
    v30 = 1;
  }
  v17 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4));
  if ( v28 )
  {
    v18 = v28 | v17[3];
    if ( !v17[14] )
      LOBYTE(v18) = v18 | 4;
    v19 = v18 & 0x17;
    v17[3] = v19;
    if ( (v19 & v17[4]) != 0 )
      sub_408D30(0);
  }
  v30 = 5;
  if ( !__uncaught_exception() )
    sub_4134F0((int *)a1);
  v30 = -1;
  v20 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56);
  if ( v20 )
    (*(void (**)(void))(*(_DWORD *)v20 + 8))();
  return a1;
}
// 418C80: using guessed type char var_24[4];

//----- (00418E70) --------------------------------------------------------
_DWORD *__fastcall sub_418E70(int *a1, int a2, _DWORD *a3)
{
  int **v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // esi
  void (__thiscall ***v9)(_DWORD, int); // esi
  char v11[4]; // [esp+Ch] [ebp-18h] BYREF
  int v12; // [esp+10h] [ebp-14h] BYREF
  int v13; // [esp+14h] [ebp-10h]
  int v14; // [esp+20h] [ebp-4h]

  v13 = 0;
  sub_4193D0(a2, a3, a1);
  v14 = 0;
  v5 = *(int ***)(a2 + 56);
  v13 = 1;
  if ( v5 )
  {
    sub_418F30(v5, &v12, a1);
    v6 = v12;
    if ( v12 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
      v7 = *(_DWORD *)(v6 + 4);
      if ( v7 && v7 != -1 )
        *(_DWORD *)(v6 + 4) = v7 - 1;
      v8 = -(*(_DWORD *)(v6 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v11);
      v9 = (void (__thiscall ***)(_DWORD, int))(v6 & v8);
      if ( v9 )
        (**v9)(v9, 1);
    }
  }
  return a3;
}
// 418E70: using guessed type char var_18[4];

//----- (00418F30) --------------------------------------------------------
_DWORD *__thiscall sub_418F30(int **this, _DWORD *a2, int *a3)
{
  int v4; // esi
  int v5; // eax
  char v7[4]; // [esp+14h] [ebp-10h] BYREF
  int v8; // [esp+20h] [ebp-4h]

  v8 = 0;
  v4 = *this[14];
  *a2 = v4;
  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v5 = *(_DWORD *)(v4 + 4);
  if ( v5 != -1 )
    *(_DWORD *)(v4 + 4) = v5 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  v8 = 0;
  ((void (__thiscall *)(int **, int *))(*this)[14])(this, a3);
  sub_419320(this[14], a3);
  return a2;
}
// 418F30: using guessed type char var_10[4];

//----- (00418FD0) --------------------------------------------------------
int __userpurge sub_418FD0@<eax>(int a1@<ebx>, char *a2@<edi>, _WORD *a3)
{
  int v3; // eax
  int v4; // ecx
  char *v5; // eax
  char *i; // esi
  _WORD *v7; // eax
  int v8; // ecx

  v3 = *((_DWORD *)a2 + 4);
  if ( !v3 )
    return -1;
  v4 = v3 - 1;
  if ( *((_DWORD *)a2 + 5) < 8u )
    v5 = a2;
  else
    v5 = *(char **)a2;
  for ( i = &v5[2 * v4]; ; i -= 2 )
  {
    v7 = a3;
    v8 = a1;
    if ( !a1 )
      break;
    while ( *v7 != *(_WORD *)i )
    {
      ++v7;
      if ( !--v8 )
        goto LABEL_9;
    }
    if ( i == (char *)sub_409880(a2) )
      return -1;
  }
LABEL_9:
  if ( *((_DWORD *)a2 + 5) < 8u )
    return (i - a2) >> 1;
  else
    return (int)&i[-*(_DWORD *)a2] >> 1;
}

//----- (00419050) --------------------------------------------------------
int *__cdecl sub_419050(int *a1, const unsigned __int16 *a2)
{
  int v2; // edx
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ebx
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // eax
  _DWORD *v12; // ecx
  int v13; // edx
  int *v14; // eax
  _WORD **v15; // ecx
  _WORD *v16; // eax
  __int16 v17; // ax
  int v18; // ecx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  _DWORD *v22; // ecx
  int v23; // eax
  int v24; // eax
  bool v25; // al
  int *v26; // esi
  int v27; // ecx
  int v29; // et0
  int v30; // eax
  _DWORD *v31; // ecx
  int v32; // edx
  int *v33; // eax
  _WORD **v34; // ecx
  _WORD *v35; // eax
  __int16 v36; // ax
  int v37; // et0
  int v38; // [esp+0h] [ebp-38h] BYREF
  int *v39; // [esp+10h] [ebp-28h]
  bool v40; // [esp+14h] [ebp-24h]
  int v41; // [esp+1Ch] [ebp-1Ch]
  unsigned int v42; // [esp+20h] [ebp-18h]
  int v43; // [esp+24h] [ebp-14h]
  int *v44; // [esp+28h] [ebp-10h]
  int v45; // [esp+34h] [ebp-4h]

  v44 = &v38;
  v43 = 0;
  v42 = wcslen(a2);
  v2 = *(_DWORD *)(*a1 + 4);
  v3 = *(int *)((char *)a1 + v2 + 36);
  v4 = *(int *)((char *)a1 + v2 + 32);
  if ( __SPAIR64__(v3, v4) <= 0 || __SPAIR64__(v3, v4) <= v42 )
  {
    v5 = 0;
    v41 = 0;
  }
  else
  {
    v41 = (__PAIR64__(v3, v4) - v42) >> 32;
    v5 = v4 - v42;
  }
  v6 = *(int *)((char *)a1 + v2 + 56);
  v39 = a1;
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v45 = 0;
  v7 = *(_DWORD *)(*a1 + 4);
  if ( !*(int *)((char *)a1 + v7 + 12) )
  {
    v8 = *(int *)((char *)a1 + v7 + 60);
    if ( v8 )
      sub_408280(v8);
  }
  v9 = *(_DWORD *)(*a1 + 4);
  v40 = *(int *)((char *)a1 + v9 + 12) == 0;
  v45 = 1;
  if ( v40 )
  {
    LOBYTE(v45) = 2;
    if ( (*(int *)((char *)a1 + v9 + 20) & 0x1C0) == 64 )
      goto LABEL_23;
    while ( v41 >= 0 && (v41 > 0 || v5) )
    {
      v11 = *(_DWORD *)(*a1 + 4);
      v12 = *(_DWORD **)((char *)a1 + v11 + 56);
      v13 = *(unsigned __int16 *)((char *)a1 + v11 + 64);
      if ( *(_DWORD *)v12[9] && (v14 = (int *)v12[13], *v14 > 0) )
      {
        --*v14;
        v15 = (_WORD **)v12[9];
        v16 = (*v15)++;
        *v16 = v13;
        v17 = v13;
      }
      else
      {
        v17 = (*(int (__thiscall **)(_DWORD *, int))(*v12 + 12))(v12, v13);
      }
      if ( v17 == -1 )
      {
        v43 |= 4u;
        break;
      }
      v29 = (__PAIR64__(v41, v5--) - 1) >> 32;
      v41 = v29;
    }
    if ( !v43 )
    {
LABEL_23:
      v18 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
      v19 = (*(int (__thiscall **)(int, const unsigned __int16 *, unsigned int, _DWORD))(*(_DWORD *)v18 + 36))(
              v18,
              a2,
              v42,
              0);
      if ( v19 == v42 && !v20 )
      {
        while ( v41 >= 0 && (v41 > 0 || v5) )
        {
          v30 = *(_DWORD *)(*a1 + 4);
          v31 = *(_DWORD **)((char *)a1 + v30 + 56);
          v32 = *(unsigned __int16 *)((char *)a1 + v30 + 64);
          if ( *(_DWORD *)v31[9] && (v33 = (int *)v31[13], *v33 > 0) )
          {
            --*v33;
            v34 = (_WORD **)v31[9];
            v35 = (*v34)++;
            *v35 = v32;
            v36 = v32;
          }
          else
          {
            v36 = (*(int (__thiscall **)(_DWORD *, int))(*v31 + 12))(v31, v32);
          }
          if ( v36 == -1 )
          {
            v43 |= 4u;
            break;
          }
          v37 = (__PAIR64__(v41, v5--) - 1) >> 32;
          v41 = v37;
        }
      }
      else
      {
        v43 = 4;
      }
    }
    v21 = *(_DWORD *)(*a1 + 4);
    *(int *)((char *)a1 + v21 + 32) = 0;
    *(int *)((char *)a1 + v21 + 36) = 0;
    v45 = 1;
    v10 = v43;
  }
  else
  {
    v10 = 4;
  }
  v22 = (int *)((char *)a1 + *(_DWORD *)(*a1 + 4));
  if ( v10 )
  {
    v23 = v10 | v22[3];
    if ( !v22[14] )
      LOBYTE(v23) = v23 | 4;
    v24 = v23 & 0x17;
    v22[3] = v24;
    if ( (v24 & v22[4]) != 0 )
      sub_408D30(0);
  }
  v45 = 4;
  v25 = __uncaught_exception();
  v26 = v39;
  if ( !v25 )
    sub_4134F0(v39);
  v45 = -1;
  v27 = *(int *)((char *)v26 + *(_DWORD *)(*v26 + 4) + 56);
  if ( v27 )
    (*(void (**)(void))(*(_DWORD *)v27 + 8))();
  return a1;
}
// 4190BB: conditional instruction was optimized away because ecx.4>=0
// 4191C4: variable 'v20' is possibly undefined

//----- (00419320) --------------------------------------------------------
int *__userpurge sub_419320@<eax>(int *a1@<ebx>, int *a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // esi
  void (__thiscall ***v5)(_DWORD, int); // esi
  int v6; // esi
  int v7; // eax
  char v9[4]; // [esp+4h] [ebp-4h] BYREF

  v2 = *a1;
  if ( *a1 != *a2 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
    v3 = *(_DWORD *)(v2 + 4);
    if ( v3 && v3 != -1 )
      *(_DWORD *)(v2 + 4) = v3 - 1;
    v4 = -(*(_DWORD *)(v2 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v9);
    v5 = (void (__thiscall ***)(_DWORD, int))(v2 & v4);
    if ( v5 )
      (**v5)(v5, 1);
    v6 = *a2;
    *a1 = *a2;
    std::_Lockit::_Lockit((std::_Lockit *)&a2, 0);
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 != -1 )
      *(_DWORD *)(v6 + 4) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a2);
  }
  return a1;
}
// 419320: using guessed type char var_4[4];

//----- (004193A0) --------------------------------------------------------
int __thiscall sub_4193A0(_DWORD *this, int a2)
{
  int **i; // esi
  int result; // eax

  for ( i = (int **)this[11]; i; i = (int **)*i )
    result = ((int (__cdecl *)(int, _DWORD *, int *))i[2])(a2, this, i[1]);
  return result;
}

//----- (004193D0) --------------------------------------------------------
_DWORD *__userpurge sub_4193D0@<eax>(int a1@<edi>, _DWORD *a2, int *a3)
{
  int v3; // esi
  int v4; // eax
  int **i; // esi
  char v7[4]; // [esp+10h] [ebp-10h] BYREF
  int v8; // [esp+1Ch] [ebp-4h]

  v8 = 0;
  v3 = **(_DWORD **)(a1 + 48);
  *a2 = v3;
  std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
  v4 = *(_DWORD *)(v3 + 4);
  if ( v4 != -1 )
    *(_DWORD *)(v3 + 4) = v4 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v7);
  v8 = 0;
  sub_419320(*(int **)(a1 + 48), a3);
  for ( i = *(int ***)(a1 + 44); i; i = (int **)*i )
    ((void (__cdecl *)(int, int, int *))i[2])(1, a1, i[1]);
  return a2;
}
// 4193D0: using guessed type char var_10[4];

//----- (00419470) --------------------------------------------------------
void *__thiscall sub_419470(void *this, int a2)
{
  *(_DWORD *)this = &std::locale::_Locimp::`vftable';
  std::locale::_Locimp::_Locimp_dtor((struct std::locale::_Locimp *)this);
  if ( *((_DWORD *)this + 6) )
    free(*((void **)this + 6));
  *((_DWORD *)this + 6) = 0;
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDB04: using guessed type void *std::locale::_Locimp::`vftable';

//----- (004194F0) --------------------------------------------------------
void **__thiscall sub_4194F0(void **this, void *Src)
{
  _BYTE *i; // eax
  size_t v4; // edi
  void *v5; // eax

  if ( *this == Src )
    return this;
  if ( *this )
    free(*this);
  *this = 0;
  if ( !Src )
    return this;
  for ( i = Src; *i; ++i )
    ;
  v4 = i - (_BYTE *)Src + 1;
  v5 = malloc(v4);
  *this = v5;
  if ( v5 )
    memcpy_0(v5, Src, v4);
  return this;
}

//----- (00419560) --------------------------------------------------------
_BYTE *__thiscall sub_419560(_BYTE *this, char a2)
{
  void **v3; // ecx

  this[20] = a2;
  v3 = (void **)(this + 24);
  *((_DWORD *)this + 1) = 1;
  *(_DWORD *)this = &std::locale::_Locimp::`vftable';
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *v3 = 0;
  *((_BYTE *)v3 + 4) = 0;
  sub_4194F0(v3, (void *)"*");
  return this;
}
// 4BDB04: using guessed type void *std::locale::_Locimp::`vftable';

//----- (004195A0) --------------------------------------------------------
std::_Lockit *__userpurge sub_4195A0@<eax>(const char *a1@<edi>, std::_Lockit *a2)
{
  int pExceptionObject[3]; // [esp+Ch] [ebp-1Ch] BYREF
  char *v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  std::_Lockit::_Lockit(a2, 0);
  v5 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_BYTE *)a2 + 8) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_BYTE *)a2 + 16) = 0;
  *((_DWORD *)a2 + 5) = 0;
  *((_BYTE *)a2 + 24) = 0;
  *((_DWORD *)a2 + 7) = 0;
  *((_BYTE *)a2 + 32) = 0;
  LOBYTE(v5) = 4;
  if ( !a1 )
  {
    v4 = "bad locale name";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::runtime_error::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor(a2, 63, a1);
  return a2;
}
// 4BDA34: using guessed type void *std::runtime_error::`vftable';

//----- (00419640) --------------------------------------------------------
struct std::locale::_Locimp **__stdcall sub_419640(struct std::locale::_Locimp **a1, const char *a2)
{
  void *v2; // eax
  struct std::locale::_Locimp *v3; // esi
  const char *v4; // eax
  int v6; // [esp+0h] [ebp-44h] BYREF
  char v7[28]; // [esp+10h] [ebp-34h] BYREF
  const char *v8; // [esp+2Ch] [ebp-18h]
  char v9; // [esp+30h] [ebp-14h] BYREF
  int *v10; // [esp+34h] [ebp-10h]
  int v11; // [esp+40h] [ebp-4h]

  v10 = &v6;
  v2 = operator new(0x20u);
  v3 = (struct std::locale::_Locimp *)v2;
  if ( v2 )
  {
    *((_DWORD *)v2 + 1) = 1;
    *(_DWORD *)v2 = &std::locale::_Locimp::`vftable';
    *((_DWORD *)v2 + 2) = 0;
    *((_DWORD *)v2 + 3) = 0;
    *((_DWORD *)v2 + 4) = 0;
    *((_BYTE *)v2 + 20) = 0;
    *((_DWORD *)v2 + 6) = 0;
    *((_BYTE *)v2 + 28) = 0;
    sub_4194F0((void **)v2 + 6, (void *)"*");
  }
  else
  {
    v3 = 0;
  }
  *a1 = v3;
  v11 = 0;
  std::locale::_Init();
  sub_4195A0(a2, (std::_Lockit *)v7);
  LOBYTE(v11) = 1;
  v4 = v8;
  if ( !v8 )
    v4 = &v9;
  if ( !strcmp(v4, "*") )
    std::_Xruntime_error("bad locale name");
  std::locale::_Locimp::_Makeloc((const struct std::_Locinfo *)v7, 63, *a1, 0);
  LOBYTE(v11) = 0;
  sub_408790((std::_Lockit *)v7);
  return a1;
}
// 4BDB04: using guessed type void *std::locale::_Locimp::`vftable';

//----- (00419770) --------------------------------------------------------
char **__userpurge sub_419770@<eax>(char **a1@<esi>, char *a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x10u);
  if ( !result )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a3;
  *result = a2;
  result[1] = v4;
  if ( result != (char **)-8 )
  {
    result[2] = *a1;
    result[3] = a1[1];
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004197D0) --------------------------------------------------------
int *__stdcall sub_4197D0(int *a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  struct std::locale::facet *v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // esi
  void (__thiscall ***v12)(_DWORD, int); // esi
  int v13; // eax
  int v14; // edx
  int v15; // esi
  _DWORD *v16; // ecx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  _DWORD v21[6]; // [esp+0h] [ebp-40h] BYREF
  bool v22; // [esp+18h] [ebp-28h]
  int v23; // [esp+1Ch] [ebp-24h] BYREF
  char v24[4]; // [esp+20h] [ebp-20h] BYREF
  int v25; // [esp+24h] [ebp-1Ch] BYREF
  int v26; // [esp+28h] [ebp-18h]
  struct std::locale::facet *v27; // [esp+2Ch] [ebp-14h]
  _DWORD *v28; // [esp+30h] [ebp-10h]
  int v29; // [esp+3Ch] [ebp-4h]

  v28 = v21;
  v2 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  v3 = 0;
  v26 = 0;
  v21[5] = a1;
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  v29 = 0;
  v4 = *(_DWORD *)(*a1 + 4);
  if ( !*(int *)((char *)a1 + v4 + 12) )
  {
    v5 = *(int *)((char *)a1 + v4 + 60);
    if ( v5 )
      sub_408280(v5);
  }
  v6 = *a1;
  v22 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 12) == 0;
  v29 = 1;
  if ( v22 )
  {
    v7 = sub_408A70((_DWORD **)((char *)a1 + *(_DWORD *)(v6 + 4)), &v25);
    LOBYTE(v29) = 2;
    v8 = sub_40E010((int)v7);
    LOBYTE(v29) = 1;
    v9 = v25;
    v27 = v8;
    if ( v25 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v24, 0);
      v10 = *(_DWORD *)(v9 + 4);
      if ( v10 && v10 != -1 )
        *(_DWORD *)(v9 + 4) = v10 - 1;
      v11 = -(*(_DWORD *)(v9 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v24);
      v12 = (void (__thiscall ***)(_DWORD, int))(v9 & v11);
      if ( v12 )
        (**v12)(v12, 1);
    }
    LOBYTE(v29) = 3;
    v13 = *(_DWORD *)(*a1 + 4);
    v14 = *(int *)((char *)a1 + v13 + 56);
    v15 = *(_DWORD *)v27;
    LOBYTE(v23) = 0;
    (*(void (__thiscall **)(struct std::locale::facet *, int *, int, int, char *, _DWORD, int))(v15 + 24))(
      v27,
      &v23,
      v23,
      v14,
      (char *)a1 + v13,
      *(unsigned __int16 *)((char *)a1 + v13 + 64),
      a2);
    v3 = 4;
    if ( !(_BYTE)v23 )
      v3 = v26;
    v29 = 1;
  }
  v16 = (int *)((char *)a1 + *(_DWORD *)(*a1 + 4));
  if ( v3 )
  {
    v17 = v3 | v16[3];
    if ( !v16[14] )
      LOBYTE(v17) = v17 | 4;
    v18 = v17 & 0x17;
    v16[3] = v18;
    if ( (v18 & v16[4]) != 0 )
      sub_408D30(0);
  }
  v29 = 5;
  if ( !__uncaught_exception() )
    sub_4134F0(a1);
  v29 = -1;
  v19 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  if ( v19 )
    (*(void (**)(void))(*(_DWORD *)v19 + 8))();
  return a1;
}
// 4197D0: using guessed type char var_20[4];

//----- (004199C0) --------------------------------------------------------
void *__cdecl sub_4199C0(void *a1, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // eax
  bool v4; // cf
  _WORD *v5; // eax

  *((_DWORD *)a1 + 5) = 7;
  *((_DWORD *)a1 + 4) = 0;
  *(_WORD *)a1 = 0;
  v2 = *((_DWORD *)a1 + 4);
  v3 = *(_DWORD *)(a2 + 16) + 22;
  if ( v2 <= v3 && *((_DWORD *)a1 + 5) != v3 && sub_409410(a1, v3, 1) )
  {
    v4 = *((_DWORD *)a1 + 5) < 8u;
    *((_DWORD *)a1 + 4) = v2;
    if ( v4 )
      v5 = a1;
    else
      v5 = *(_WORD **)a1;
    v5[v2] = 0;
  }
  sub_415F40((char *)L"Directory\r\n---------\r\n", a1, 0x16u);
  sub_406A00(a1, (_DWORD *)a2, 0, 0xFFFFFFFF);
  return a1;
}
// 4C2C74: using guessed type wchar_t aDirectory[23];

//----- (00419A80) --------------------------------------------------------
_DWORD *__usercall sub_419A80@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<ecx>, _DWORD *a3@<edi>)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  _DWORD *v6; // eax
  _DWORD *v8; // eax

  v4 = a2[4];
  v5 = a1[4];
  if ( v5 <= a2[5] - v4 || a1[5] - v5 < v4 )
  {
    v8 = sub_406A00(a2, a1, 0, 0xFFFFFFFF);
    a3[5] = 7;
    a3[4] = 0;
    *(_WORD *)a3 = 0;
    sub_40AF70(a3, v8);
    return a3;
  }
  else
  {
    v6 = sub_40B350(0xFFFFFFFF, a1, a2, 0);
    a3[5] = 7;
    a3[4] = 0;
    *(_WORD *)a3 = 0;
    sub_40AF70(a3, v6);
    return a3;
  }
}

//----- (00419B10) --------------------------------------------------------
unsigned int __userpurge sub_419B10@<eax>(int a1@<eax>, _DWORD *a2)
{
  int v3; // eax
  unsigned int v4; // edi
  unsigned int result; // eax
  unsigned int v6; // esi
  _DWORD *v7; // edi
  int pExceptionObject[3]; // [esp+8h] [ebp-10h] BYREF
  char *v9; // [esp+14h] [ebp-4h] BYREF

  v3 = *(_DWORD *)(a1 + 16);
  if ( (((_BYTE)v3 + *(_BYTE *)(a1 + 12)) & 1) == 0 && *(_DWORD *)(a1 + 8) <= (unsigned int)(v3 + 2) >> 1 )
    sub_419BE0(a1);
  v4 = *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 12);
  result = *(_DWORD *)(a1 + 8);
  v6 = v4 >> 1;
  if ( result <= v4 >> 1 )
    v6 -= result;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) )
  {
    result = (unsigned int)operator new(0x10u);
    if ( !result )
    {
      v9 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v9);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) = result;
  }
  v7 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) + 8 * (v4 & 1));
  if ( v7 )
  {
    result = (unsigned int)a2;
    *v7 = *a2;
    v7[1] = a2[1];
  }
  ++*(_DWORD *)(a1 + 16);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00419BC0) --------------------------------------------------------
_DWORD *__usercall sub_419BC0@<eax>(_DWORD *result@<eax>, int *a2@<edx>)
{
  int v2; // ecx
  int v3; // edx

  v2 = a2[3] + a2[4];
  v3 = *a2;
  result[1] = 0;
  *result = v3;
  result[2] = v2;
  return result;
}

//----- (00419BE0) --------------------------------------------------------
int __usercall sub_419BE0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // eax
  unsigned int v2; // ecx
  unsigned int v3; // edi
  int v4; // esi
  char *v5; // eax
  const void *v6; // ecx
  char *v7; // edx
  unsigned int v8; // ecx
  char *v9; // edi
  size_t v10; // esi
  char *v11; // eax
  int result; // eax
  size_t v13; // [esp+4h] [ebp-10h]
  char *v14; // [esp+Ch] [ebp-8h]
  unsigned int v15; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  v15 = 1;
  if ( v1 == 0xFFFFFFF )
    std::_Xlength_error("deque<T> too long");
  v2 = v1 >> 1;
  if ( v1 >> 1 >= 8 )
  {
    if ( v2 <= 1 )
      goto LABEL_8;
  }
  else
  {
    v2 = 8;
  }
  if ( v1 <= 0xFFFFFFF - v2 )
    v15 = v2;
LABEL_8:
  v3 = *(_DWORD *)(a1 + 12) >> 1;
  v4 = 4 * v3;
  v14 = (char *)sub_419F70(v1 + v15);
  v13 = 4 * ((int)(4 * *(_DWORD *)(a1 + 8) - 4 * v3) >> 2);
  v5 = (char *)memcpy(&v14[4 * v3], (const void *)(4 * v3 + *(_DWORD *)(a1 + 4)), v13) + v13;
  v6 = *(const void **)(a1 + 4);
  if ( v3 > v15 )
  {
    memcpy(v5, v6, 4 * ((int)(4 * v15) >> 2));
    v10 = 4 * ((int)(v4 - 4 * v15) >> 2);
    v11 = (char *)memcpy(v14, (const void *)(4 * v15 + *(_DWORD *)(a1 + 4)), v10);
    v8 = v15;
    v9 = &v11[v10];
    goto LABEL_14;
  }
  v7 = (char *)memcpy(v5, v6, 4 * (v4 >> 2)) + 4 * (v4 >> 2);
  if ( v15 != v3 )
    memset(v7, 0, 4 * (v15 - v3));
  if ( v3 )
  {
    v8 = v3;
    v9 = v14;
LABEL_14:
    memset(v9, 0, 4 * v8);
  }
  result = *(_DWORD *)(a1 + 4);
  if ( result )
    operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 8) += v15;
  *(_DWORD *)(a1 + 4) = v14;
  return result;
}
// 419CFE: conditional instruction was optimized away because %var_4.4!=0

//----- (00419D30) --------------------------------------------------------
_DWORD *__usercall sub_419D30@<eax>(int a1@<eax>, _DWORD *a2@<esi>)
{
  _DWORD *v3; // eax
  _DWORD **v4; // ebx
  _DWORD ***v5; // eax
  int v6; // edi
  _DWORD *v7; // ebx
  char v9[4]; // [esp+8h] [ebp-4h] BYREF

  v3 = *(_DWORD **)a1;
  v4 = 0;
  if ( v3 )
  {
    v5 = (_DWORD ***)*v3;
    if ( v5 )
    {
      v4 = *v5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v9, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v9);
    }
  }
  v6 = *(_DWORD *)(a1 + 8) - 1;
  *a2 = 0;
  a2[1] = 0;
  if ( v4 )
  {
    v7 = *v4;
    if ( !v7 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v9, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v9);
      a2[2] = v6;
      return a2;
    }
    *a2 = *v7;
  }
  a2[2] = v6;
  return a2;
}
// 419D30: using guessed type char var_4[4];

//----- (00419DC0) --------------------------------------------------------
_DWORD *__thiscall sub_419DC0(_DWORD *this)
{
  int v2; // eax
  _DWORD *result; // eax
  int v4; // ecx
  int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp+4h] [ebp-4h] BYREF

  v5 = this[1];
  v6 = 0;
  v2 = GdipCloneBrush(v5, &v6);
  if ( v2 )
    this[2] = v2;
  result = (_DWORD *)GdipAlloc(12);
  if ( result )
  {
    v4 = v6;
    result[2] = this[2];
    *result = &Gdiplus::Brush::`vftable';
    result[1] = v4;
  }
  else
  {
    GdipDeleteBrush(v6);
    return 0;
  }
  return result;
}
// 4BD678: using guessed type int __stdcall GdipCloneBrush(_DWORD, _DWORD);
// 4BD67C: using guessed type int __stdcall GdipDeleteBrush(_DWORD);
// 4BD6BC: using guessed type int __stdcall GdipAlloc(_DWORD);
// 4CC41C: using guessed type void *Gdiplus::Brush::`vftable';

//----- (00419E20) --------------------------------------------------------
unsigned int __usercall sub_419E20@<eax>(int *a1@<eax>)
{
  int v2; // edx
  unsigned int v3; // eax
  unsigned int result; // eax
  unsigned int v5; // ecx
  unsigned int v6; // ecx

  v2 = *a1;
  v3 = (a1[1] - *a1) >> 2;
  if ( v3 > 0x3FFFFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v3 + 1;
  v5 = (a1[2] - v2) >> 2;
  if ( result > v5 )
  {
    if ( 0x3FFFFFFF - (v5 >> 1) >= v5 )
      v6 = (v5 >> 1) + v5;
    else
      v6 = 0;
    if ( v6 < result )
      v6 = result;
    return sub_419EF0((int)a1, v6);
  }
  return result;
}

//----- (00419E70) --------------------------------------------------------
char **__userpurge sub_419E70@<eax>(char **a1@<esi>, char *a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x20u);
  if ( !result )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a3;
  *result = a2;
  result[1] = v4;
  if ( result != (char **)-8 )
  {
    result[2] = *a1;
    result[3] = a1[1];
    result[4] = a1[2];
    result[5] = a1[3];
    result[6] = a1[4];
    result[7] = a1[5];
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00419EF0) --------------------------------------------------------
unsigned int __userpurge sub_419EF0@<eax>(int a1@<esi>, unsigned int a2)
{
  unsigned int result; // eax
  char *v3; // ebx
  int v4; // edi

  if ( a2 > 0x3FFFFFFF )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) >> 2;
  if ( result < a2 )
  {
    v3 = (char *)sub_419F70(a2);
    memcpy(v3, *(const void **)a1, 4 * ((*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2));
    v4 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 2;
    if ( *(_DWORD *)a1 )
      operator delete(*(void **)a1);
    result = (unsigned int)&v3[4 * a2];
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 8) = result;
    *(_DWORD *)(a1 + 4) = &v3[4 * v4];
  }
  return result;
}

//----- (00419F70) --------------------------------------------------------
void *__fastcall sub_419F70(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x3FFFFFFF || (result = operator new(4 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00419FD0) --------------------------------------------------------
int *__stdcall sub_419FD0(void **a1, int a2, int a3, int a4)
{
  _DWORD v5[8]; // [esp+0h] [ebp-20h] BYREF

  v5[4] = v5;
  v5[7] = 0;
  return sub_41A040((int)a1, *a1, a2, a3, (int)a1);
}

//----- (0041A040) --------------------------------------------------------
int *__thiscall sub_41A040(int this, void *Src, int a3, int a4, int a5)
{
  int *result; // eax
  unsigned int v7; // edi
  int v8; // ecx
  unsigned int v9; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  void *v12; // edx
  size_t v13; // ebx
  char *v14; // eax
  _DWORD *v15; // eax
  unsigned int v16; // edi
  char *v17; // edx
  unsigned int v18; // edi
  const void *v19; // [esp-8h] [ebp-30h]
  int v20; // [esp+0h] [ebp-28h] BYREF
  void *v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  int *v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+24h] [ebp-4h]

  v23 = &v20;
  result = (int *)a3;
  v7 = 0;
  if ( a3 != a4 )
  {
    do
    {
      result = (int *)*result;
      ++v7;
    }
    while ( result != (int *)a4 );
    if ( v7 )
    {
      v8 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
      if ( 0x3FFFFFFF - v8 < v7 )
        std::_Xlength_error("vector<T> too long");
      v9 = v8 + v7;
      v10 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
      if ( v10 >= v9 )
      {
        sub_417D70(*(_DWORD **)(this + 4), (_DWORD *)a3, (_DWORD *)a4);
        result = *(int **)(this + 4);
        v18 = v7;
        if ( Src != result && result != &result[v18] )
          result = (int *)sub_417DA0((int)result, Src, &result[v18]);
        *(_DWORD *)(this + 4) += v18 * 4;
      }
      else
      {
        if ( 0x3FFFFFFF - (v10 >> 1) >= v10 )
        {
          v11 = (v10 >> 1) + v10;
          v22 = v11;
        }
        else
        {
          v22 = 0;
          v11 = 0;
        }
        if ( v11 < v9 )
        {
          v22 = v9;
          v11 = v9;
        }
        v12 = sub_419F70(v11);
        v24 = 0;
        v13 = 4 * (((int)Src - *(_DWORD *)this) >> 2);
        v19 = *(const void **)this;
        v21 = v12;
        v14 = (char *)memcpy(v12, v19, v13);
        v15 = sub_417D70(&v14[v13], (_DWORD *)a3, (_DWORD *)a4);
        memcpy(v15, Src, 4 * ((*(_DWORD *)(this + 4) - (int)Src) >> 2));
        v16 = ((*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2) + v7;
        if ( *(_DWORD *)this )
          operator delete(*(void **)this);
        result = (int *)v21;
        v17 = (char *)v21 + 4 * v16;
        *(_DWORD *)(this + 8) = (char *)v21 + 4 * v22;
        *(_DWORD *)(this + 4) = v17;
        *(_DWORD *)this = result;
      }
    }
  }
  return result;
}

//----- (0041A1F0) --------------------------------------------------------
char ***__stdcall sub_41A1F0(char ***a1, int **a2)
{
  char **v2; // eax
  int v4; // [esp+0h] [ebp-30h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v6[5]; // [esp+1Ch] [ebp-14h] BYREF

  v6[1] = (char *)&v4;
  a1[1] = 0;
  v2 = (char **)operator new(0x1Cu);
  if ( !v2 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = (char *)v2;
  (*a1)[1] = (char *)*a1;
  v6[4] = (char *)1;
  sub_41A320((int)a1, **a1, **a2, (int)*a2, (int)a1);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041A2B0) --------------------------------------------------------
char **__stdcall sub_41A2B0(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x28u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x20u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041A320) --------------------------------------------------------
int __stdcall sub_41A320(int a1, char *a2, int a3, int a4, int a5)
{
  int result; // eax
  char **v6; // eax
  int v7; // ecx
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  result = a3;
  v8[4] = a3;
  v8[8] = 0;
  while ( result != a4 )
  {
    v6 = sub_416060((char **)(result + 8), a2, *((_DWORD *)a2 + 1));
    v7 = *(_DWORD *)(a1 + 4);
    if ( v7 == 214748363 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v7 + 1;
    *((_DWORD *)a2 + 1) = v6;
    *(_DWORD *)v6[1] = v6;
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (0041A3F0) --------------------------------------------------------
LONG __stdcall sub_41A3F0(int a1)
{
  return sub_461CB0(a1 - 4);
}

//----- (0041A400) --------------------------------------------------------
int __stdcall sub_41A400(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_461E10(a1 - 4, a2, a3);
}

//----- (0041A410) --------------------------------------------------------
LONG __stdcall sub_41A410(int a1)
{
  return sub_462000((void *)(a1 - 4));
}

//----- (0041A420) --------------------------------------------------------
void *__thiscall sub_41A420(void *this, char a2)
{
  *(_DWORD *)this = &CReferenceCount::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4CC488: using guessed type void *CReferenceCount::`vftable';

//----- (0041A450) --------------------------------------------------------
int __usercall sub_41A450@<eax>(int a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 40) >= 8u )
    operator delete(*(void **)(a1 + 20));
  *(_DWORD *)(a1 + 40) = 7;
  *(_DWORD *)(a1 + 36) = 0;
  *(_WORD *)(a1 + 20) = 0;
  sub_40A140(a1 + 8);
  operator delete(*(void **)(a1 + 8));
  operator delete((void *)a1);
  return a1;
}

//----- (0041A4A0) --------------------------------------------------------
char **__stdcall sub_41A4A0(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x250u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x248u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041A510) --------------------------------------------------------
int sub_41A510()
{
  WNDCLASSW WndClass; // [esp+8h] [ebp-38h] BYREF
  int v2[4]; // [esp+30h] [ebp-10h] BYREF

  v2[0] = 1;
  memset(&v2[1], 0, 12);
  WndClass.style = 0;
  WndClass.lpfnWndProc = (WNDPROC)sub_41A750;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = GetModuleHandleW(0);
  WndClass.hIcon = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = 0;
  WndClass.lpszMenuName = 0;
  WndClass.lpszClassName = L"DisplayWindow";
  if ( !sub_41AEA0(&WndClass) )
    return 0;
  GdiplusStartup(&dword_4EF434, v2, 0);
  return 1;
}
// 4BD6C4: using guessed type int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD);
// 4EF434: using guessed type int dword_4EF434;

//----- (0041A5A0) --------------------------------------------------------
int __stdcall sub_41A5A0(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = 0;
  if ( !sub_40AA20(&stru_4BD95C, a2) )
    return -2147467262;
  *a3 = a1;
  if ( !a1 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}

//----- (0041A5E0) --------------------------------------------------------
int __stdcall sub_41A5E0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (0041A600) --------------------------------------------------------
int __stdcall sub_41A600(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    sub_41A6E0((int)a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (0041A630) --------------------------------------------------------
int __userpurge sub_41A630@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax

  *(_DWORD *)a2 = &CDisplayWindow::`vftable';
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 568) = -16777216;
  *(_DWORD *)(a2 + 572) = -16777216;
  ++dword_4EF508;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = a3;
  v3 = a1[4];
  *(_DWORD *)(a2 + 564) = 0;
  *(_DWORD *)(a2 + 748) = v3;
  *(_DWORD *)(a2 + 16) = 20;
  *(_DWORD *)(a2 + 20) = 80;
  *(_DWORD *)(a2 + 568) = *a1;
  *(_DWORD *)(a2 + 572) = a1[1];
  *(_DWORD *)(a2 + 12) = a1[2];
  v4 = a1[3];
  *(_DWORD *)(a2 + 608) = 0;
  *(_DWORD *)(a2 + 612) = 0;
  *(_DWORD *)(a2 + 616) = 0;
  *(_DWORD *)(a2 + 620) = 0;
  *(_DWORD *)(a2 + 752) = v4;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a2 + 584));
  return a2;
}
// 4CC4E8: using guessed type void *CDisplayWindow::`vftable';
// 4EF508: using guessed type int dword_4EF508;

//----- (0041A6E0) --------------------------------------------------------
void __usercall sub_41A6E0(int a1@<esi>)
{
  HDC v1; // [esp-4h] [ebp-4h]

  v1 = *(HDC *)(a1 + 716);
  *(_DWORD *)a1 = &CDisplayWindow::`vftable';
  DeleteDC(v1);
  DeleteObject(*(HGDIOBJ *)(a1 + 744));
  DestroyIcon(*(HICON *)(a1 + 748));
  if ( !--dword_4EF508 )
    GdiplusShutdown(dword_4EF434);
  if ( *(_DWORD *)(a1 + 28) )
    operator delete(*(void **)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
}
// 4BD688: using guessed type int __stdcall GdiplusShutdown(_DWORD);
// 4CC4E8: using guessed type void *CDisplayWindow::`vftable';
// 4EF434: using guessed type int dword_4EF434;
// 4EF508: using guessed type int dword_4EF508;

//----- (0041A750) --------------------------------------------------------
int __stdcall sub_41A750(HWND hWnd, int a2, int a3, int a4)
{
  int WindowLongW; // esi
  int result; // eax
  _DWORD *v6; // ebx
  void *v7; // esi
  int v8; // eax

  WindowLongW = GetWindowLongW(hWnd, -21);
  if ( a2 == 1 )
  {
    v6 = *(_DWORD **)a4;
    v7 = operator new(0x548u);
    if ( v7 )
      v8 = sub_41A630(v6, (int)v7, (int)hWnd);
    else
      v8 = 0;
    WindowLongW = v8;
    SetWindowLongW(hWnd, -21, v8);
    return sub_41A7C0(WindowLongW, a3, hWnd, a2, a4);
  }
  result = a2 - 2;
  if ( a2 != 2 )
    return sub_41A7C0(WindowLongW, a3, hWnd, a2, a4);
  return result;
}

//----- (0041A7C0) --------------------------------------------------------
int __fastcall sub_41A7C0(int a1, unsigned int a2, HWND hWnd, UINT Msg, LPARAM lParam)
{
  HWND v5; // ebx
  LPARAM v6; // esi
  HDC v8; // eax
  HDC v9; // eax
  HDC v10; // esi
  int result; // eax
  char *v12; // eax
  int v13; // edx
  __int16 v14; // cx
  int v15; // ecx
  _WORD *v16; // eax
  int v17; // edx
  int v18; // edi
  __int16 v19; // cx
  HDC v20; // esi
  HDC DC; // esi
  HWND v22; // [esp-10h] [ebp-4B0h]
  struct tagRECT v24; // [esp+18h] [ebp-488h] BYREF
  struct tagRECT v25; // [esp+28h] [ebp-478h] BYREF
  struct tagRECT Rect; // [esp+38h] [ebp-468h] BYREF
  struct tagRECT v27; // [esp+48h] [ebp-458h] BYREF
  struct tagPAINTSTRUCT Paint; // [esp+58h] [ebp-448h] BYREF
  char v29[1028]; // [esp+98h] [ebp-408h] BYREF

  v5 = hWnd;
  v6 = lParam;
  if ( Msg > 0x8066 )
  {
    switch ( Msg )
    {
      case 0x8067u:
        return sub_40A3F0(a1, (_DWORD *)(a1 + 572));
      case 0x8068u:
        sub_4166A0(a2, (unsigned int *)(a1 + 572));
        DC = GetDC(hWnd);
        GetClientRect(hWnd, &v24);
        sub_41AFA0(&v24, (_DWORD *)a1, DC);
        ReleaseDC(hWnd, DC);
        RedrawWindow(hWnd, 0, 0, 1u);
        v6 = lParam;
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x806Bu:
        return sub_40A3F0(a1, (_DWORD *)(a1 + 568));
      case 0x806Cu:
        sub_4166A0(a2, (unsigned int *)(a1 + 568));
        v20 = GetDC(hWnd);
        GetClientRect(hWnd, &v24);
        sub_41AFA0(&v24, (_DWORD *)a1, v20);
        ReleaseDC(hWnd, v20);
        RedrawWindow(hWnd, 0, 0, 1u);
        v6 = lParam;
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x806Eu:
        sub_41B160(a1, (HDC)a2, lParam, lParam);
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x806Fu:
        *(_DWORD *)a2 = *(_DWORD *)(a1 + 752);
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x8070u:
        v22 = *(HWND *)(a1 + 8);
        *(_DWORD *)(a1 + 752) = a2;
        RedrawWindow(v22, 0, 0, 1u);
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x8071u:
        return *(_DWORD *)(a1 + 12);
      case 0x8072u:
        *(_DWORD *)(a1 + 12) = a2;
        RedrawWindow(*(HWND *)(a1 + 8), 0, 0, 1u);
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x8073u:
        if ( !lParam )
          goto LABEL_28;
        v12 = v29;
        v13 = 512;
        while ( v13 != -2147483134 )
        {
          v14 = *(_WORD *)&v12[lParam - (_DWORD)v29];
          if ( !v14 )
            break;
          *(_WORD *)v12 = v14;
          v12 += 2;
          if ( !--v13 )
          {
            v12 -= 2;
            break;
          }
        }
        *(_WORD *)v12 = 0;
        sub_41AC60(v29, (_DWORD *)(a1 + 28), a1);
        v5 = hWnd;
        v6 = lParam;
LABEL_28:
        RedrawWindow(v5, 0, 0, 1u);
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x8074u:
        sub_41ACB0((_DWORD *)(a1 + 28));
        return DefWindowProcW(v5, Msg, a2, v6);
      case 0x8075u:
        v15 = 0;
        if ( !lParam )
          goto LABEL_35;
        if ( a2 >= (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28)) >> 10 )
          goto LABEL_35;
        v16 = *(_WORD **)(a1 + 28);
        if ( v16 == *(_WORD **)(a1 + 32) )
          goto LABEL_35;
        break;
      default:
        return DefWindowProcW(v5, Msg, a2, v6);
    }
    while ( v15 != a2 )
    {
      v16 += 512;
      ++v15;
      if ( v16 == *(_WORD **)(a1 + 32) )
        goto LABEL_35;
    }
    v17 = 512;
    v18 = lParam - (_DWORD)v16;
    while ( v17 != -2147483134 )
    {
      v19 = *(_WORD *)((char *)v16 + v18);
      if ( !v19 )
        break;
      *v16++ = v19;
      if ( !--v17 )
      {
        --v16;
        break;
      }
    }
    *v16 = 0;
    goto LABEL_35;
  }
  if ( Msg == 32870 )
  {
    *(_DWORD *)(a1 + 612) = lParam;
    if ( lParam )
      sub_41BA80(a1, a2);
LABEL_35:
    RedrawWindow(hWnd, 0, 0, 1u);
    return DefWindowProcW(v5, Msg, a2, v6);
  }
  if ( Msg > 0x200 )
  {
    switch ( Msg )
    {
      case 0x201u:
        sub_41B910(a1, lParam);
        v6 = lParam;
        break;
      case 0x202u:
        *(_DWORD *)(a1 + 564) = 0;
        ReleaseCapture();
        break;
      case 0x205u:
        sub_41BA00(a2, a1, lParam);
        v5 = hWnd;
        break;
    }
    return DefWindowProcW(v5, Msg, a2, v6);
  }
  if ( Msg == 512 )
    return sub_41B7E0(a1, lParam);
  switch ( Msg )
  {
    case 1u:
      v8 = GetDC(hWnd);
      *(_DWORD *)(a1 + 716) = CreateCompatibleDC(v8);
      return DefWindowProcW(v5, Msg, a2, v6);
    case 5u:
      sub_41BB40(lParam, a1);
      v5 = hWnd;
      v6 = lParam;
      return DefWindowProcW(v5, Msg, a2, v6);
    case 0xFu:
      GetUpdateRect(hWnd, &Rect, 0);
      GetClientRect(hWnd, &v24);
      v9 = BeginPaint(hWnd, &Paint);
      sub_41B160(a1, v9, (int)&v24, (int)&Rect);
      EndPaint(hWnd, &Paint);
      return DefWindowProcW(v5, Msg, a2, v6);
    case 0x14u:
      v10 = GetDC(hWnd);
      GetUpdateRect(hWnd, &v27, 0);
      GetClientRect(hWnd, &v25);
      sub_41B160(a1, v10, (int)&v25, (int)&v27);
      ReleaseDC(hWnd, v10);
      result = 1;
      break;
    default:
      return DefWindowProcW(v5, Msg, a2, v6);
  }
  return result;
}
// 41A9D4: conditional instruction was optimized away because edx.4!=0
// 41AA80: conditional instruction was optimized away because edx.4!=0

//----- (0041AC60) --------------------------------------------------------
unsigned int __usercall sub_41AC60@<eax>(char *a1@<eax>, _DWORD *a2@<ebx>, int a3@<edi>)
{
  unsigned int result; // eax
  unsigned int v5; // esi
  char *v6; // edi

  result = a2[1];
  if ( (unsigned int)a1 >= result || *a2 > (unsigned int)a1 )
  {
    if ( result == a2[2] )
      result = sub_41AD00((int)a2, a3);
  }
  else
  {
    v5 = (unsigned int)&a1[-*a2];
    if ( result == a2[2] )
      result = sub_41AD00((int)a2, a3);
    a1 = (char *)(*a2 + (v5 & 0xFFFFFC00));
  }
  v6 = (char *)a2[1];
  if ( v6 )
    qmemcpy(v6, a1, 0x400u);
  a2[1] += 1024;
  return result;
}

//----- (0041ACB0) --------------------------------------------------------
void __stdcall sub_41ACB0(_DWORD *a1)
{
  if ( *a1 != a1[1] )
    a1[1] = *a1;
}
// 41ACB0: could not find valid save-restore pair for edi
// 41ACB0: could not find valid save-restore pair for esi

//----- (0041AD00) --------------------------------------------------------
unsigned int __usercall sub_41AD00@<eax>(int a1@<edx>, int a2@<edi>)
{
  unsigned int v2; // eax
  unsigned int result; // eax
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // edi
  char *v8; // eax
  char *v9; // ebx
  char *v10; // edx
  int v11; // ebx
  unsigned int v12; // ebx
  _DWORD v13[4]; // [esp-24h] [ebp-28h] BYREF
  unsigned int v14; // [esp-14h] [ebp-18h]
  _DWORD *v15; // [esp-10h] [ebp-14h]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-10h]
  void *v17; // [esp-8h] [ebp-Ch]
  int v18; // [esp-4h] [ebp-8h]
  int v19; // [esp+0h] [ebp-4h]

  v2 = (*(_DWORD *)(a1 + 4) - *(_DWORD *)a1) >> 10;
  if ( v2 > 0x3FFFFE )
    std::_Xlength_error("vector<T> too long");
  result = v2 + 1;
  v4 = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) >> 10;
  if ( result > v4 )
  {
    v18 = a2;
    if ( 0x3FFFFF - (v4 >> 1) >= v4 )
      v5 = (v4 >> 1) + v4;
    else
      v5 = 0;
    if ( v5 < result )
      v5 = result;
    v18 = -1;
    v17 = &loc_4B7C50;
    ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
    v13[2] = v19;
    v15 = v13;
    v6 = v5;
    if ( v5 > 0x3FFFFF )
      std::_Xlength_error("vector<T> too long");
    result = (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) >> 10;
    if ( result < v5 )
    {
      v8 = (char *)sub_41AE20(v5);
      v18 = 0;
      v9 = *(char **)(a1 + 4);
      v10 = *(char **)a1;
      v14 = (unsigned int)v8;
      sub_41AE70(v8, v10, v9);
      v11 = *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
      if ( *(_DWORD *)a1 )
        operator delete(*(void **)a1);
      result = v14;
      v12 = v14 + (v11 & 0xFFFFFC00);
      *(_DWORD *)(a1 + 8) = v14 + (v6 << 10);
      *(_DWORD *)(a1 + 4) = v12;
      *(_DWORD *)a1 = result;
    }
  }
  return result;
}

//----- (0041AE20) --------------------------------------------------------
void *__fastcall sub_41AE20(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x3FFFFF || (result = operator new(a1 << 10)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041AE70) --------------------------------------------------------
char *__usercall sub_41AE70@<eax>(char *result@<eax>, char *a2@<edx>, char *a3@<ebx>)
{
  for ( ; a2 != a3; result += 1024 )
  {
    if ( result )
      qmemcpy(result, a2, 0x400u);
    a2 += 1024;
  }
  return result;
}

//----- (0041AEA0) --------------------------------------------------------
__int16 __stdcall sub_41AEA0(WNDCLASSW *lpWndClass)
{
  int v1; // eax
  BOOL v2; // edi
  int v3; // esi
  FARPROC v4; // eax
  int v6; // [esp+14h] [ebp-20h] BYREF
  int v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]
  WNDCLASSW *lpWndClassa; // [esp+3Ch] [ebp+8h]

  v7 = 0;
  v6 = 0;
  if ( dword_4EF798 || (v1 = sub_4015E0((int)&v6)) != 0 )
  {
    ms_exc.registration.TryLevel = 0;
    v7 = RegisterClassW(lpWndClass);
    ms_exc.registration.TryLevel = -2;
    if ( dword_4EF798 )
    {
LABEL_13:
      LOWORD(v1) = v7;
      return v1;
    }
    v2 = (_WORD)v7 == 0;
    if ( (_WORD)v7 )
      lpWndClassa = 0;
    else
      lpWndClassa = (WNDCLASSW *)GetLastError();
    v3 = v6;
    v4 = (FARPROC)dword_4EF118;
    if ( !dword_4EF118 )
    {
      v4 = sub_4017B0((int)&off_4CB834, (int)&unk_4EF11C, "DeactivateActCtx");
      if ( !v4 )
        goto LABEL_11;
      dword_4EF118 = (int)v4;
    }
    ((void (__stdcall *)(_DWORD, int))v4)(0, v3);
LABEL_11:
    if ( v2 )
      SetLastError((DWORD)lpWndClassa);
    goto LABEL_13;
  }
  return v1;
}
// 4CB834: using guessed type int (__stdcall *off_4CB834)(int);
// 4EF118: using guessed type int dword_4EF118;
// 4EF798: using guessed type int dword_4EF798;

//----- (0041AFA0) --------------------------------------------------------
int __fastcall sub_41AFA0(_DWORD *a1, _DWORD *a2, HDC hdc)
{
  void *v5; // eax
  HBITMAP CompatibleBitmap; // eax
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // edi
  HDC v12; // ebx
  int Pen1; // eax
  HDC v15; // [esp+4h] [ebp-64h]
  int v16; // [esp+4h] [ebp-64h]
  int v17; // [esp+4h] [ebp-64h]
  int v18; // [esp+8h] [ebp-60h]
  void **v19; // [esp+20h] [ebp-48h] BYREF
  HDC v20; // [esp+24h] [ebp-44h]
  int v21; // [esp+28h] [ebp-40h]
  int v22; // [esp+2Ch] [ebp-3Ch]
  int v23; // [esp+30h] [ebp-38h]
  int v24[2]; // [esp+34h] [ebp-34h] BYREF
  int v25[2]; // [esp+3Ch] [ebp-2Ch] BYREF
  int v26; // [esp+44h] [ebp-24h] BYREF
  int v27; // [esp+48h] [ebp-20h]
  int v28; // [esp+4Ch] [ebp-1Ch]
  int v29; // [esp+50h] [ebp-18h] BYREF
  int v30; // [esp+54h] [ebp-14h] BYREF
  int v31; // [esp+64h] [ebp-4h]

  v26 = 0;
  v27 = GdipCreatePath(0, &v26);
  v31 = 0;
  v5 = (void *)a2[186];
  v24[0] = 0;
  v24[1] = 0;
  v29 = 1;
  if ( v5 )
    DeleteObject(v5);
  CompatibleBitmap = CreateCompatibleBitmap(hdc, a1[2] - *a1, a1[3] - a1[1]);
  v15 = (HDC)a2[179];
  a2[186] = CompatibleBitmap;
  SelectObject(v15, CompatibleBitmap);
  v16 = a2[179];
  v30 = 0;
  v23 = GdipCreateFromHDC(v16, &v30);
  v22 = v30;
  v7 = a1[3] - a1[1];
  v28 = a1[2] - *a1;
  v8 = GdipAddPathRectangleI(v26, 0, 0, v28, v7);
  if ( v8 )
    v27 = v8;
  v19 = &Gdiplus::PathGradientBrush::`vftable';
  hdc = 0;
  v21 = GdipCreatePathGradientFromPath(v26, &hdc);
  v20 = hdc;
  LOBYTE(v31) = 2;
  v9 = GdipSetPathGradientCenterPointI(hdc, v24);
  if ( v9 )
    v21 = v9;
  v10 = GdipSetPathGradientCenterColor(hdc, a2[142]);
  if ( v10 )
    v21 = v10;
  sub_41BBF0((int)(a2 + 143), (int)&v19, &v29);
  v11 = v30;
  v18 = v7;
  v12 = v20;
  GdipFillRectangleI(v30, v20, 0, 0, v28, v18);
  v25[0] = 0;
  Pen1 = GdipCreatePen1(-8355712, 1.0, 0, v25);
  v17 = a1[2];
  v25[1] = Pen1;
  GdipDrawLineI(v11, v25[0], 0, 0, v17, 0);
  GdipDeletePen(v25[0]);
  GdipDeleteBrush(v12);
  GdipDeleteGraphics(v11);
  return GdipDeletePath(v26);
}
// 4BD64C: using guessed type int __stdcall GdipSetPathGradientCenterColor(_DWORD, _DWORD);
// 4BD650: using guessed type int __stdcall GdipSetPathGradientCenterPointI(_DWORD, _DWORD);
// 4BD654: using guessed type int __stdcall GdipCreatePathGradientFromPath(_DWORD, _DWORD);
// 4BD658: using guessed type int __stdcall GdipAddPathRectangleI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD65C: using guessed type int __stdcall GdipDeletePath(_DWORD);
// 4BD660: using guessed type int __stdcall GdipCreatePath(_DWORD, _DWORD);
// 4BD664: using guessed type int __stdcall GdipDrawLineI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD66C: using guessed type int __stdcall GdipCreatePen1(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BD670: using guessed type int __stdcall GdipDeleteGraphics(_DWORD);
// 4BD67C: using guessed type int __stdcall GdipDeleteBrush(_DWORD);
// 4BD684: using guessed type int __stdcall GdipDeletePen(_DWORD);
// 4BD6A8: using guessed type int __stdcall GdipFillRectangleI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD6C0: using guessed type int __stdcall GdipCreateFromHDC(_DWORD, _DWORD);
// 4CC528: using guessed type void *Gdiplus::PathGradientBrush::`vftable';

//----- (0041B160) --------------------------------------------------------
BOOL __userpurge sub_41B160@<eax>(int a1@<eax>, HDC hdc, int a3, int a4)
{
  int v5; // ebx
  HDC CompatibleDC; // edi
  HBITMAP ho; // [esp+Ch] [ebp-4h]

  v5 = a3;
  CompatibleDC = CreateCompatibleDC(hdc);
  ho = CreateCompatibleBitmap(hdc, *(_DWORD *)(a3 + 8) - *(_DWORD *)a3, *(_DWORD *)(a3 + 12) - *(_DWORD *)(a3 + 4));
  SelectObject(CompatibleDC, ho);
  BitBlt(
    CompatibleDC,
    *(_DWORD *)a4,
    *(_DWORD *)(a4 + 4),
    *(_DWORD *)(v5 + 8),
    *(_DWORD *)(v5 + 12),
    *(HDC *)(a1 + 716),
    *(_DWORD *)a4,
    *(_DWORD *)(a4 + 4),
    0xCC0020u);
  sub_41B650(CompatibleDC, a1, *(_DWORD *)(a1 + 20));
  DrawIconEx(CompatibleDC, 20, 20, *(HICON *)(a1 + 748), 48, 48, 0, 0, 3u);
  if ( *(_DWORD *)(a1 + 612) )
  {
    sub_41B250(a1, CompatibleDC);
    v5 = a3;
  }
  BitBlt(
    hdc,
    *(_DWORD *)a4,
    *(_DWORD *)(a4 + 4),
    *(_DWORD *)(v5 + 8),
    *(_DWORD *)(v5 + 12),
    CompatibleDC,
    *(_DWORD *)a4,
    *(_DWORD *)(a4 + 4),
    0xCC0020u);
  DeleteDC(CompatibleDC);
  return DeleteObject(ho);
}

//----- (0041B240) --------------------------------------------------------
BOOL __thiscall sub_41B240(void *this, HDC a2, int a3, int a4)
{
  return sub_41B160((int)this, a2, a3, a4);
}

//----- (0041B250) --------------------------------------------------------
void __usercall sub_41B250(int a1@<ecx>, HDC a2@<ebx>)
{
  HDC CompatibleDC; // esi
  HGDIOBJ h; // [esp+8h] [ebp-18h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  if ( *(_DWORD *)(a1 + 616) )
  {
    if ( !*(_DWORD *)(a1 + 620) )
    {
      GetClientRect(*(HWND *)(a1 + 8), &Rect);
      CompatibleDC = CreateCompatibleDC(a2);
      h = SelectObject(CompatibleDC, *(HGDIOBJ *)(a1 + 608));
      BitBlt(
        a2,
        *(_DWORD *)(a1 + 624),
        10,
        Rect.right - *(_DWORD *)(a1 + 624) - Rect.left,
        Rect.bottom - Rect.top - 20,
        CompatibleDC,
        0,
        0,
        0xCC0020u);
      SelectObject(CompatibleDC, h);
      DeleteDC(CompatibleDC);
    }
  }
  else
  {
    sub_41B350((char *)a1);
  }
}

//----- (0041B310) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  int v1; // edi
  HANDLE CurrentThread; // eax

  v1 = *(_DWORD *)lpThreadParameter;
  CoInitializeEx(0, 2u);
  CurrentThread = GetCurrentThread();
  SetThreadPriority(CurrentThread, -1);
  sub_41B3D0(v1, (int)lpThreadParameter);
  CoUninitialize();
  return 0;
}

//----- (0041B350) --------------------------------------------------------
BOOL __usercall sub_41B350@<eax>(char *a1@<eax>)
{
  char *v1; // edi
  char **v2; // eax
  HANDLE Thread; // eax
  int v5; // [esp-4h] [ebp-14h]
  char *v6[2]; // [esp+8h] [ebp-8h] BYREF

  v1 = dword_4EF764;
  v5 = *((_DWORD *)dword_4EF764 + 1);
  v6[0] = a1;
  v6[1] = 0;
  v2 = sub_419770(v6, dword_4EF764, v5);
  if ( dword_4EF768 == 536870910 )
    std::_Xlength_error("list<T> too long");
  ++dword_4EF768;
  *((_DWORD *)v1 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  Thread = CreateThread(0, 0, StartAddress, (LPVOID)(*((_DWORD *)dword_4EF764 + 1) + 8), 0, 0);
  return CloseHandle(Thread);
}
// 4EF768: using guessed type int dword_4EF768;

//----- (0041B3D0) --------------------------------------------------------
void __thiscall sub_41B3D0(int this, int a2)
{
  LPITEMIDLIST v3; // ebx
  const ITEMIDLIST *ID; // eax
  int v5; // edi
  int v6; // eax
  HWND v7; // [esp+64h] [ebp-27Ch]
  int v8; // [esp+80h] [ebp-260h] BYREF
  LPCITEMIDLIST pidl; // [esp+84h] [ebp-25Ch] BYREF
  LPVOID v10; // [esp+88h] [ebp-258h] BYREF
  int v11; // [esp+8Ch] [ebp-254h] BYREF
  int v12; // [esp+90h] [ebp-250h] BYREF
  IShellFolder *ppshf; // [esp+94h] [ebp-24Ch] BYREF
  int v14; // [esp+98h] [ebp-248h] BYREF
  int v15; // [esp+9Ch] [ebp-244h]
  HANDLE h; // [esp+A0h] [ebp-240h] BYREF
  char v17[4]; // [esp+A4h] [ebp-23Ch] BYREF
  char pv[4]; // [esp+A8h] [ebp-238h] BYREF
  int v19; // [esp+ACh] [ebp-234h]
  int v20; // [esp+B0h] [ebp-230h]
  struct tagRECT Rect; // [esp+C0h] [ebp-220h] BYREF
  char v22[524]; // [esp+D0h] [ebp-210h] BYREF

  v8 = 0;
  ppshf = 0;
  v12 = 0;
  pidl = 0;
  v10 = 0;
  *(_DWORD *)(this + 616) = 1;
  *(_DWORD *)(this + 620) = 1;
  if ( sub_467810((LPITEMIDLIST *)&pidl, this + 44) >= 0 )
  {
    v3 = ILClone(pidl);
    ILRemoveLastID(v3);
    ID = ILFindLastID(pidl);
    v10 = ILClone(ID);
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      if ( ppshf->lpVtbl->BindToObject(ppshf, v3, 0, &stru_4BD7FC, (void **)&v12) >= 0 )
      {
        if ( (*(int (__stdcall **)(int, _DWORD, int, LPVOID *, void *, _DWORD, int *))(*(_DWORD *)v12 + 40))(
               v12,
               0,
               1,
               &v10,
               &unk_4BD8AC,
               0,
               &v8) >= 0 )
        {
          GetClientRect(*(HWND *)(this + 8), &Rect);
          v14 = Rect.bottom - Rect.top - 20;
          v15 = v14;
          v11 = 584;
          if ( (*(int (__stdcall **)(int, char *, int, char *, int *, int, int *))(*(_DWORD *)v8 + 12))(
                 v8,
                 v22,
                 260,
                 v17,
                 &v14,
                 32,
                 &v11) >= 0
            && (*(int (__stdcall **)(int, HANDLE *))(*(_DWORD *)v8 + 16))(v8, &h) >= 0 )
          {
            GetObjectW(h, 24, pv);
            DeleteObject(h);
            v11 = 588;
            v5 = Rect.bottom - Rect.top - 20;
            v15 = v5;
            v14 = (int)((double)v19 / (double)v20 * (double)v5);
            *(_DWORD *)(this + 576) = v14;
            v6 = v8;
            *(_DWORD *)(this + 580) = v5;
            (*(void (__stdcall **)(int, char *, int, char *, int *, int, int *))(*(_DWORD *)v6 + 12))(
              v6,
              v22,
              260,
              v17,
              &v14,
              32,
              &v11);
            if ( (*(int (__stdcall **)(int, int))(*(_DWORD *)v8 + 16))(v8, this + 608) < 0 )
            {
              *(_DWORD *)(this + 620) = 1;
              *(_DWORD *)(this + 608) = 0;
            }
            else
            {
              EnterCriticalSection((LPCRITICAL_SECTION)(this + 584));
              if ( !*(_DWORD *)(a2 + 4) )
              {
                v7 = *(HWND *)(this + 8);
                *(_DWORD *)(this + 620) = 0;
                InvalidateRect(v7, 0, 0);
              }
              LeaveCriticalSection((LPCRITICAL_SECTION)(this + 584));
            }
          }
          (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
      }
      ppshf->lpVtbl->Release(ppshf);
    }
    CoTaskMemFree((LPVOID)pidl);
    CoTaskMemFree(v3);
    CoTaskMemFree(v10);
  }
}
// 41B3D0: using guessed type char var_23C[4];
// 41B3D0: using guessed type char pv[4];

//----- (0041B650) --------------------------------------------------------
LONG __userpurge sub_41B650@<eax>(HDC a1@<edi>, int a2@<esi>, LONG a3)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  const WCHAR *v6; // ebx
  int v7; // eax
  int v8; // ecx
  __int64 v9; // rax
  int v10; // edx
  int v11; // eax
  const WCHAR *v12; // ebx
  int v13; // eax
  int v14; // eax
  LONG result; // eax
  void *v16; // [esp-4h] [ebp-50h]
  struct tagSIZE psizl; // [esp+8h] [ebp-44h] BYREF
  int v18; // [esp+10h] [ebp-3Ch]
  unsigned int v19; // [esp+14h] [ebp-38h]
  LONG v20; // [esp+18h] [ebp-34h]
  int v21; // [esp+1Ch] [ebp-30h]
  LONG cx; // [esp+20h] [ebp-2Ch]
  struct tagRECT Rect; // [esp+24h] [ebp-28h] BYREF
  struct tagRECT rc; // [esp+34h] [ebp-18h] BYREF

  v16 = *(void **)(a2 + 752);
  v21 = 0;
  cx = 0;
  SelectObject(a1, v16);
  SetBkMode(a1, 1);
  SetTextColor(a1, *(_DWORD *)(a2 + 12));
  GetClientRect(*(HWND *)(a2 + 8), &Rect);
  v3 = *(_DWORD *)(a2 + 32);
  v20 = a3;
  v4 = *(_DWORD *)(a2 + 28);
  v5 = (v3 - v4) >> 10;
  v19 = 0;
  if ( v5 )
  {
    v18 = 0;
    do
    {
      if ( v5 <= v19 )
        goto LABEL_11;
      v6 = (const WCHAR *)(v4 + v18);
      v7 = lstrlenW((LPCWSTR)(v4 + v18));
      GetTextExtentPoint32W(a1, v6, v7, &psizl);
      v8 = *(_DWORD *)(a2 + 16);
      v9 = v8 + psizl.cy * (v21 + 1) - Rect.bottom;
      if ( (int)((HIDWORD(v9) ^ v9) - HIDWORD(v9)) < 10 )
      {
        v20 += cx + 50;
        cx = 0;
        v21 = 0;
      }
      if ( cx <= psizl.cx )
        cx = psizl.cx;
      rc.left = v20;
      rc.top = v8 + v21 * psizl.cy;
      rc.right = v20 + psizl.cx;
      v10 = *(_DWORD *)(a2 + 32);
      rc.bottom = psizl.cy + rc.top;
      v11 = *(_DWORD *)(a2 + 28);
      if ( (v10 - v11) >> 10 <= v19 )
LABEL_11:
        std::_Xout_of_range("invalid vector<T> subscript");
      v12 = (const WCHAR *)(v11 + v18);
      SelectObject(a1, *(HGDIOBJ *)(a2 + 752));
      SetBkMode(a1, 1);
      SetTextColor(a1, *(_DWORD *)(a2 + 12));
      v13 = lstrlenW(v12);
      DrawTextW(a1, v12, v13, &rc, 0x800u);
      v4 = *(_DWORD *)(a2 + 28);
      v14 = *(_DWORD *)(a2 + 32);
      ++v21;
      v18 += 1024;
      v5 = (v14 - v4) >> 10;
      ++v19;
    }
    while ( v19 < v5 );
  }
  result = cx;
  *(_DWORD *)(a2 + 624) = v20 + cx + 50;
  return result;
}

//----- (0041B7E0) --------------------------------------------------------
int __userpurge sub_41B7E0@<eax>(int a1@<esi>, int a2)
{
  HWND Parent; // eax
  LONG right; // ebx
  HWND v5; // eax
  HCURSOR CursorW; // eax
  HCURSOR v7; // eax
  HWND v8; // [esp-10h] [ebp-54h]
  HWND v9; // [esp-8h] [ebp-4Ch]
  WPARAM v10; // [esp-8h] [ebp-4Ch]
  struct tagRECT v11; // [esp+Ch] [ebp-38h] BYREF
  struct tagRECT Rect; // [esp+1Ch] [ebp-28h] BYREF
  struct tagRECT rc; // [esp+2Ch] [ebp-18h] BYREF

  v9 = *(HWND *)(a1 + 8);
  rc.right = (__int16)a2;
  GetClientRect(v9, &Rect);
  Parent = GetParent(*(HWND *)(a1 + 8));
  GetClientRect(Parent, &v11);
  right = rc.right;
  if ( *(_DWORD *)(a1 + 564) )
  {
    if ( qword_4EFC84 == __PAIR64__(SHIWORD(a2), rc.right) )
      return 0;
    v10 = Rect.bottom - SHIWORD(a2);
    v8 = *(HWND *)(a1 + 8);
    LODWORD(qword_4EFC84) = rc.right;
    HIDWORD(qword_4EFC84) = SHIWORD(a2);
    v5 = GetParent(v8);
    SendMessageW(v5, 0x8064u, v10, 0);
  }
  if ( SHIWORD(a2) <= Rect.top + 5 )
  {
    CursorW = LoadCursorW(0, (LPCWSTR)0x7F85);
    SetCursor(CursorW);
  }
  if ( *(_DWORD *)(a1 + 612) )
  {
    SetRect(&rc, *(_DWORD *)(a1 + 624), 10, *(_DWORD *)(a1 + 624) + *(_DWORD *)(a1 + 576), *(_DWORD *)(a1 + 580) + 10);
    if ( PtInRect(&rc, (POINT)__PAIR64__(SHIWORD(a2), right)) )
    {
      v7 = LoadCursorW(0, (LPCWSTR)0x7F89);
      SetCursor(v7);
    }
  }
  return 1;
}
// 4EFC84: using guessed type __int64 qword_4EFC84;

//----- (0041B910) --------------------------------------------------------
HWND __userpurge sub_41B910@<eax>(int a1@<esi>, int a2)
{
  HWND result; // eax
  HCURSOR CursorW; // eax
  HCURSOR v4; // eax
  HWND v5; // [esp-4h] [ebp-38h]
  struct tagRECT rc; // [esp+Ch] [ebp-28h] BYREF
  struct tagRECT Rect; // [esp+1Ch] [ebp-18h] BYREF

  result = (HWND)GetClientRect(*(HWND *)(a1 + 8), &Rect);
  if ( SHIWORD(a2) <= Rect.top + 5 )
  {
    CursorW = LoadCursorW(0, (LPCWSTR)0x7F85);
    SetCursor(CursorW);
    v5 = *(HWND *)(a1 + 8);
    *(_DWORD *)(a1 + 564) = 1;
    SetFocus(v5);
    result = SetCapture(*(HWND *)(a1 + 8));
  }
  if ( *(_DWORD *)(a1 + 612) )
  {
    SetRect(&rc, *(_DWORD *)(a1 + 624), 10, *(_DWORD *)(a1 + 624) + *(_DWORD *)(a1 + 576), *(_DWORD *)(a1 + 580) + 10);
    result = (HWND)PtInRect(&rc, (POINT)__PAIR64__(SHIWORD(a2), (__int16)a2));
    if ( result )
    {
      v4 = LoadCursorW(0, (LPCWSTR)0x7F89);
      SetCursor(v4);
      return (HWND)ShellExecuteW(*(HWND *)(a1 + 8), L"open", (LPCWSTR)(a1 + 44), 0, 0, 5);
    }
  }
  return result;
}

//----- (0041BA00) --------------------------------------------------------
LRESULT __usercall sub_41BA00@<eax>(WPARAM a1@<ebx>, int a2@<edi>, LPARAM a3@<esi>)
{
  HWND Parent; // eax
  HWND v5; // eax
  POINT v6; // [esp-8h] [ebp-20h]
  RECT rc; // [esp+4h] [ebp-14h] BYREF

  rc.left = 20;
  rc.top = 20;
  v6.y = SHIWORD(a3);
  *(_QWORD *)&rc.right = 0x4400000044i64;
  v6.x = (__int16)a3;
  if ( PtInRect(&rc, v6) )
  {
    Parent = GetParent(*(HWND *)(a2 + 8));
    return SendMessageW(Parent, 0x8065u, a1, a3);
  }
  else
  {
    v5 = GetParent(*(HWND *)(a2 + 8));
    return SendMessageW(v5, 0x8066u, a1, a3);
  }
}

//----- (0041BA80) --------------------------------------------------------
_WORD *__userpurge sub_41BA80@<eax>(int a1@<eax>, int a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // edi
  char *i; // eax
  _WORD *result; // eax
  int v6; // edx
  int v7; // esi
  __int16 v8; // cx

  v3 = (struct _RTL_CRITICAL_SECTION *)(a1 + 584);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 584));
  for ( i = *(char **)dword_4EF764; i != dword_4EF764; i = *(char **)i )
    *((_DWORD *)i + 3) = 1;
  LeaveCriticalSection(v3);
  if ( *(_DWORD *)(a1 + 608) )
    DeleteObject(*(HGDIOBJ *)(a1 + 608));
  *(_DWORD *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 580) = 0;
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 620) = 0;
  result = (_WORD *)(a1 + 44);
  v6 = 260;
  v7 = a2 - (a1 + 44);
  while ( v6 != -2147483386 )
  {
    v8 = *(_WORD *)((char *)result + v7);
    if ( !v8 )
      break;
    *result++ = v8;
    if ( !--v6 )
    {
      *(result - 1) = 0;
      return result;
    }
  }
  *result = 0;
  return result;
}
// 41BB18: conditional instruction was optimized away because edx.4!=0

//----- (0041BB40) --------------------------------------------------------
BOOL __usercall sub_41BB40@<eax>(unsigned int a1@<ebx>, int a2@<esi>)
{
  HDC DC; // edi
  struct tagRECT rc; // [esp+4h] [ebp-14h] BYREF

  DC = GetDC(*(HWND *)(a2 + 8));
  SetRect(&rc, 0, 0, (unsigned __int16)a1, HIWORD(a1));
  sub_41AFA0(&rc, (_DWORD *)a2, DC);
  ReleaseDC(*(HWND *)(a2 + 8), DC);
  return RedrawWindow(*(HWND *)(a2 + 8), 0, 0, 1u);
}

//----- (0041BBB0) --------------------------------------------------------
char *sub_41BBB0()
{
  char *result; // eax
  char *v1; // esi

  result = *(char **)dword_4EF764;
  *(_DWORD *)dword_4EF764 = dword_4EF764;
  *((_DWORD *)dword_4EF764 + 1) = dword_4EF764;
  dword_4EF768 = 0;
  if ( result != dword_4EF764 )
  {
    do
    {
      v1 = *(char **)result;
      operator delete(result);
      result = v1;
    }
    while ( v1 != dword_4EF764 );
  }
  return result;
}
// 4EF768: using guessed type int dword_4EF768;

//----- (0041BBF0) --------------------------------------------------------
int __userpurge sub_41BBF0@<eax>(int a1@<eax>, int a2@<edi>, int *a3)
{
  int PathGradientPointCount; // eax
  int v5; // eax
  _DWORD *v6; // eax
  void *v7; // esi
  int result; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // [esp+8h] [ebp-8h] BYREF
  int v13; // [esp+Ch] [ebp-4h] BYREF

  if ( !a1 || !a3 )
    goto LABEL_17;
  PathGradientPointCount = GdipGetPathGradientPointCount(*(_DWORD *)(a2 + 4), &v12);
  if ( PathGradientPointCount )
    *(_DWORD *)(a2 + 8) = PathGradientPointCount;
  v5 = *a3;
  if ( *a3 <= v12 && v12 > 0 )
  {
    v13 = *a3;
    v6 = operator new(4 * v5);
    v7 = v6;
    if ( v6 )
    {
      v9 = 0;
      if ( v13 > 0 )
      {
        v10 = a1 - (_DWORD)v6;
        do
        {
          *v6 = *(_DWORD *)((char *)v6 + v10);
          ++v9;
          ++v6;
        }
        while ( v9 < v13 );
      }
      v11 = GdipSetPathGradientSurroundColorsWithCount(*(_DWORD *)(a2 + 4), v7, &v13);
      if ( v11 )
        *(_DWORD *)(a2 + 8) = v11;
      if ( !*(_DWORD *)(a2 + 8) )
        *a3 = v13;
      operator delete(v7);
      return *(_DWORD *)(a2 + 8);
    }
    else
    {
      result = 3;
      *(_DWORD *)(a2 + 8) = 3;
    }
  }
  else
  {
LABEL_17:
    result = 2;
    *(_DWORD *)(a2 + 8) = 2;
  }
  return result;
}
// 4BD644: using guessed type int __stdcall GdipGetPathGradientPointCount(_DWORD, _DWORD);
// 4BD648: using guessed type int __stdcall GdipSetPathGradientSurroundColorsWithCount(_DWORD, _DWORD, _DWORD);

//----- (0041BCF0) --------------------------------------------------------
_DWORD *__thiscall sub_41BCF0(_DWORD *this, char a2)
{
  int v4; // [esp-4h] [ebp-8h]

  v4 = this[1];
  *this = &Gdiplus::Brush::`vftable';
  GdipDeleteBrush(v4);
  if ( (a2 & 1) != 0 )
    GdipFree(this);
  return this;
}
// 4BD67C: using guessed type int __stdcall GdipDeleteBrush(_DWORD);
// 4BD6B8: using guessed type int __stdcall GdipFree(_DWORD);
// 4CC41C: using guessed type void *Gdiplus::Brush::`vftable';

//----- (0041BD30) --------------------------------------------------------
_DWORD *__userpurge sub_41BD30@<eax>(_DWORD *a1@<esi>, int a2)
{
  bool v2; // zf
  _DWORD *result; // eax
  struct _OSVERSIONINFOW VersionInformation; // [esp+0h] [ebp-118h] BYREF

  *a1 = a2;
  a1[2] = 0;
  VersionInformation.dwOSVersionInfoSize = 276;
  v2 = !GetVersionExW(&VersionInformation);
  result = a1;
  if ( !v2 )
    a1[1] = VersionInformation.dwMajorVersion;
  return result;
}

//----- (0041BD90) --------------------------------------------------------
ATOM sub_41BD90()
{
  WNDCLASSW WndClass; // [esp+8h] [ebp-28h] BYREF

  WndClass.style = 0;
  WndClass.lpfnWndProc = (WNDPROC)sub_41BDF0;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = GetModuleHandleW(0);
  WndClass.hIcon = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = GetSysColorBrush(15);
  WndClass.lpszMenuName = 0;
  WndClass.lpszClassName = L"Holder";
  return RegisterClassW(&WndClass);
}

//----- (0041BDF0) --------------------------------------------------------
int __stdcall sub_41BDF0(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam)
{
  _DWORD *WindowLongW; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // eax

  WindowLongW = (_DWORD *)GetWindowLongW(hWnd, -21);
  if ( a2 == 1 )
  {
    v6 = operator new(0xCu);
    if ( v6 )
      v7 = sub_41BD30(v6, (int)hWnd);
    else
      v7 = 0;
    WindowLongW = v7;
    SetWindowLongW(hWnd, -21, (LONG)v7);
    return sub_41BE70(hWnd, a2, (int)WindowLongW, wParam, lParam);
  }
  if ( a2 != 2 )
    return sub_41BE70(hWnd, a2, (int)WindowLongW, wParam, lParam);
  if ( WindowLongW )
  {
    WindowLongW[2] = 0;
    operator delete(WindowLongW);
  }
  return 0;
}

//----- (0041BE70) --------------------------------------------------------
int __userpurge sub_41BE70@<eax>(HWND hWnd@<ecx>, UINT a2@<ebx>, int a3@<edi>, WPARAM wParam, LPARAM lParam)
{
  HCURSOR CursorW; // eax
  HWND v8; // [esp-4h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+4h] [ebp-14h] BYREF

  if ( a2 > 0x201 )
  {
    if ( a2 == 514 )
    {
      *(_DWORD *)(a3 + 8) = 0;
      ReleaseCapture();
    }
  }
  else
  {
    switch ( a2 )
    {
      case 0x201u:
        GetClientRect(*(HWND *)a3, &Rect);
        if ( (__int16)lParam >= Rect.right - 10 )
        {
          CursorW = LoadCursorW(0, (LPCWSTR)0x7F84);
          SetCursor(CursorW);
          v8 = *(HWND *)a3;
          *(_DWORD *)(a3 + 8) = 1;
          SetFocus(v8);
          SetCapture(*(HWND *)a3);
        }
        break;
      case 0xFu:
        sub_41BF50(hWnd);
        break;
      case 0x200u:
        return sub_41C030(a3, lParam);
    }
  }
  return DefWindowProcW(hWnd, a2, wParam, lParam);
}

//----- (0041BF50) --------------------------------------------------------
BOOL __usercall sub_41BF50@<eax>(HWND a1@<esi>)
{
  HDC v1; // edi
  HFONT v2; // ebx
  int v3; // eax
  int pvParam[31]; // [esp+8h] [ebp-2D0h] BYREF
  LOGFONTW lf; // [esp+84h] [ebp-254h] BYREF
  struct tagPAINTSTRUCT Paint; // [esp+200h] [ebp-D8h] BYREF
  struct tagRECT Rect; // [esp+240h] [ebp-98h] BYREF
  WCHAR String[66]; // [esp+250h] [ebp-88h] BYREF

  GetClientRect(a1, &Rect);
  v1 = BeginPaint(a1, &Paint);
  pvParam[0] = 500;
  SystemParametersInfoW(0x29u, 0x1F4u, pvParam, 0);
  lf.lfWeight = 400;
  v2 = CreateFontIndirectW(&lf);
  SelectObject(v1, v2);
  GetWindowTextW(a1, String, 64);
  SetBkMode(v1, 1);
  v3 = lstrlenW(String);
  TextOutW(v1, 5, 2, String, v3);
  DeleteObject(v2);
  return EndPaint(a1, &Paint);
}
// 41BF50: using guessed type int pvParam[31];

//----- (0041C030) --------------------------------------------------------
int __thiscall sub_41C030(int this, int a2)
{
  HWND Parent; // eax
  HCURSOR CursorW; // eax
  HWND v6; // [esp-10h] [ebp-34h]
  HWND v7; // [esp-8h] [ebp-2Ch]
  struct tagRECT Rect; // [esp+Ch] [ebp-18h] BYREF

  GetClientRect(*(HWND *)this, &Rect);
  if ( *(_DWORD *)(this + 8) )
  {
    if ( dword_4EFC80 != a2 )
    {
      v7 = *(HWND *)this;
      v6 = *(HWND *)this;
      dword_4EFC80 = a2;
      Parent = GetParent(v6);
      SendMessageW(Parent, 0x812Cu, (WPARAM)v7, (__int16)a2);
      return 1;
    }
  }
  else if ( (__int16)a2 >= Rect.right - 10 )
  {
    CursorW = LoadCursorW(0, (LPCWSTR)0x7F84);
    SetCursor(CursorW);
  }
  return 0;
}
// 4EFC80: using guessed type int dword_4EFC80;

//----- (0041C0F0) --------------------------------------------------------
DWORD_PTR __userpurge sub_41C0F0@<eax>(HWND hWnd@<ecx>, DWORD_PTR a2@<esi>, int a3, int a4, int a5)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  void *v9; // edi
  HANDLE Thread; // eax
  int v12[4]; // [esp+10h] [ebp-2ECh] BYREF
  int pExceptionObject[3]; // [esp+20h] [ebp-2DCh] BYREF
  char *v14; // [esp+2Ch] [ebp-2D0h] BYREF
  char *v15; // [esp+30h] [ebp-2CCh] BYREF
  SHFILEINFOW psfi; // [esp+34h] [ebp-2C8h] BYREF
  int v17; // [esp+2F8h] [ebp-4h]

  *(_DWORD *)a2 = &CMyTreeView::`vftable';
  *(_DWORD *)(a2 + 4) = &CMyTreeView::`vftable';
  v12[3] = a2;
  *(_DWORD *)(a2 + 636) = 0;
  v6 = operator new(0x214u);
  if ( !v6 )
  {
    v15 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v15);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a2 + 632) = v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(a2 + 632) + 4) = *(_DWORD *)(a2 + 632);
  v17 = 0;
  *(_DWORD *)(a2 + 648) = 0;
  v7 = operator new(0x214u);
  if ( !v7 )
  {
    v14 = 0;
    std::exception::exception((std::exception *)v12, (const char *const *)&v14);
    v12[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v12, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a2 + 644) = v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a2 + 644) + 4) = *(_DWORD *)(a2 + 644);
  LOBYTE(v17) = 1;
  *(_DWORD *)(a2 + 1204) = 0;
  v8 = operator new(0x218u);
  if ( !v8 )
  {
    v15 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v15);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a2 + 1200) = v8;
  *v8 = v8;
  *(_DWORD *)(*(_DWORD *)(a2 + 1200) + 4) = *(_DWORD *)(a2 + 1200);
  LOBYTE(v17) = 2;
  *(_DWORD *)(a2 + 12) = hWnd;
  *(_DWORD *)(a2 + 16) = a3;
  SetWindowSubclass(hWnd, pfnSubclass, 0, a2);
  InitializeCriticalSection((LPCRITICAL_SECTION)(a2 + 656));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a2 + 556));
  InitializeCriticalSection(&CriticalSection);
  *(_DWORD *)(a2 + 580) = a5;
  *(_DWORD *)(a2 + 24) = a4;
  v9 = malloc(0x190u);
  *(_DWORD *)(a2 + 584) = v9;
  *(_DWORD *)(a2 + 588) = malloc(0x320u);
  *(_DWORD *)(a2 + 592) = 100;
  memset(v9, 0, 0x190u);
  SHGetFileInfoW(L"dummy", 0x90u, &psfi, 0x2B4u, 0x4010u);
  *(_DWORD *)(a2 + 596) = psfi.iIcon;
  sub_41C770((_DWORD *)a2);
  *(_DWORD *)(a2 + 612) = 0;
  *(_DWORD *)(a2 + 616) = 0;
  *(_DWORD *)(a2 + 620) = 0;
  *(_DWORD *)(a2 + 552) = 1;
  if ( CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)(a2 + 600)) >= 0 )
  {
    (***(void (__stdcall ****)(_DWORD, void *, DWORD_PTR))(a2 + 600))(*(_DWORD *)(a2 + 600), &unk_4BD88C, a2 + 604);
    RegisterDragDrop(*(HWND *)(a2 + 12), (LPDROPTARGET)a2);
  }
  *(_DWORD *)(a2 + 1212) = 0;
  Thread = CreateThread(0, 0, sub_41E6D0, (LPVOID)a2, 0, 0);
  CloseHandle(Thread);
  *(_DWORD *)(a2 + 8) = 0;
  return a2;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC554: using guessed type void *CMyTreeView::`vftable';
// 4CC574: using guessed type void *CMyTreeView::`vftable';

//----- (0041C3B0) --------------------------------------------------------
void __usercall sub_41C3B0(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  _DWORD **v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // edi

  *(_DWORD *)a1 = &CMyTreeView::`vftable';
  *(_DWORD *)(a1 + 4) = &CMyTreeView::`vftable';
  v1 = *(_DWORD ***)(a1 + 1200);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 1200) + 4) = *(_DWORD *)(a1 + 1200);
  *(_DWORD *)(a1 + 1204) = 0;
  if ( v2 != *(_DWORD **)(a1 + 1200) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 1200) );
  }
  operator delete(*(void **)(a1 + 1200));
  v4 = *(_DWORD ***)(a1 + 644);
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 644) + 4) = *(_DWORD *)(a1 + 644);
  *(_DWORD *)(a1 + 648) = 0;
  if ( v5 != *(_DWORD **)(a1 + 644) )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != *(_DWORD **)(a1 + 644) );
  }
  operator delete(*(void **)(a1 + 644));
  v7 = *(_DWORD ***)(a1 + 632);
  v8 = *v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a1 + 632) + 4) = *(_DWORD *)(a1 + 632);
  *(_DWORD *)(a1 + 636) = 0;
  if ( v8 != *(_DWORD **)(a1 + 632) )
  {
    do
    {
      v9 = (_DWORD *)*v8;
      operator delete(v8);
      v8 = v9;
    }
    while ( v9 != *(_DWORD **)(a1 + 632) );
  }
  operator delete(*(void **)(a1 + 632));
}
// 4CC554: using guessed type void *CMyTreeView::`vftable';
// 4CC574: using guessed type void *CMyTreeView::`vftable';

//----- (0041C4B0) --------------------------------------------------------
LRESULT __stdcall pfnSubclass(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  return sub_41C4D0(uMsg, dwRefData, hWnd, wParam, lParam);
}

//----- (0041C4D0) --------------------------------------------------------
LRESULT __userpurge sub_41C4D0@<eax>(UINT a1@<eax>, int a2@<ecx>, HWND hWnd, WPARAM wParam, unsigned int a5)
{
  DWORD MessagePos; // eax
  UINT v9; // eax
  UINT v10; // eax
  HWND v11; // ecx
  HWND v12; // [esp-10h] [ebp-60h]
  HWND v13; // [esp-10h] [ebp-60h]
  HWND v14; // [esp-Ch] [ebp-5Ch]
  struct tagPOINT Points; // [esp+10h] [ebp-40h] BYREF
  LPARAM lParam; // [esp+18h] [ebp-38h] BYREF
  unsigned int y; // [esp+1Ch] [ebp-34h]
  char v18; // [esp+20h] [ebp-30h]
  LPARAM v19; // [esp+24h] [ebp-2Ch]
  LPARAM v20[10]; // [esp+28h] [ebp-28h] BYREF

  if ( a1 > 0x200 )
  {
    v9 = a1 - 516;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( v10 )
      {
        if ( v10 == 20 )
          return sub_41E380(wParam, a2, a5);
      }
      else
      {
        *(_DWORD *)(a2 + 616) = 0;
        *(_DWORD *)(a2 + 620) = 0;
      }
    }
    else if ( (wParam & 2) != 0 && (wParam & 0x11) == 0 )
    {
      v11 = *(HWND *)(a2 + 12);
      y = HIWORD(a5);
      lParam = (unsigned __int16)a5;
      SendMessageW(v11, 0x1111u, 0, (LPARAM)&lParam);
      if ( (v18 & 1) == 0 )
        *(_DWORD *)(a2 + 620) = 1;
    }
  }
  else if ( a1 == 512 )
  {
    if ( !*(_DWORD *)(a2 + 612) && !*(_DWORD *)(a2 + 616) )
    {
      if ( *(_DWORD *)(a2 + 620) )
      {
        if ( (wParam & 2) != 0 && (wParam & 0x11) == 0 )
        {
          MessagePos = GetMessagePos();
          Points.x = (__int16)MessagePos;
          v14 = *(HWND *)(a2 + 12);
          Points.y = SHIWORD(MessagePos);
          MapWindowPoints(0, v14, &Points, 1u);
          lParam = Points.x;
          v12 = *(HWND *)(a2 + 12);
          y = Points.y;
          SendMessageW(v12, 0x1111u, 0, (LPARAM)&lParam);
          if ( (v18 & 1) == 0 )
          {
            v13 = *(HWND *)(a2 + 12);
            v20[0] = 20;
            v20[1] = v19;
            if ( SendMessageW(v13, 0x113Eu, 0, (LPARAM)v20) )
            {
              if ( sub_41EBC0((IDropSource *)a2, v20[9], (struct IDropSourceVtbl *)1) == 262401 )
                *(_DWORD *)(a2 + 616) = 1;
            }
          }
        }
      }
    }
  }
  else if ( a1 > 0x4E )
  {
    if ( a1 == 275 )
      sub_41F270(a2);
  }
  else
  {
    switch ( a1 )
    {
      case 0x4Eu:
        return sub_41C6D0((IDropSource *)a2, a5);
      case 7u:
        SendMessageW(*(HWND *)(a2 + 16), 0x8048u, 0, 0);
        break;
      case 0x20u:
        return sub_41C730(a2);
    }
  }
  return DefSubclassProc(hWnd, a1, wParam, a5);
}

//----- (0041C6D0) --------------------------------------------------------
int __usercall sub_41C6D0@<eax>(IDropSource *a1@<eax>, int a2@<ecx>)
{
  int v3; // eax
  _DWORD *v4; // edi

  v3 = *(_DWORD *)(a2 + 8);
  if ( v3 == -456 )
  {
    sub_41EBC0(a1, *(_DWORD *)(a2 + 92), 0);
    return 0;
  }
  if ( v3 != -452 )
    return 0;
  v4 = (_DWORD *)(a2 + 12);
  if ( (*(_BYTE *)(a2 + 12) & 2) != 0 )
  {
    *(IDropSource *)(a2 + 36) = a1[149];
    *(IDropSource *)(a2 + 40) = a1[149];
    sub_41CA20((ULONG_PTR)a1, (int)v4);
  }
  *v4 |= 0x1000u;
  return 0;
}

//----- (0041C730) --------------------------------------------------------
int __usercall sub_41C730@<eax>(int a1@<eax>)
{
  HCURSOR v1; // eax
  HCURSOR CursorW; // eax

  if ( *(int *)(a1 + 8) <= 0 )
  {
    CursorW = LoadCursorW(0, (LPCWSTR)0x7F00);
    SetCursor(CursorW);
    return 0;
  }
  else
  {
    v1 = LoadCursorW(0, (LPCWSTR)0x7F8A);
    SetCursor(v1);
    return 1;
  }
}

//----- (0041C770) --------------------------------------------------------
int __thiscall sub_41C770(_DWORD *this)
{
  int v2; // esi
  LPARAM v3; // ebx
  int v4; // esi
  HWND v6; // [esp-10h] [ebp-778h]
  LPARAM lParam[2]; // [esp+10h] [ebp-758h] BYREF
  char v8[56]; // [esp+18h] [ebp-750h] BYREF
  int v9[14]; // [esp+50h] [ebp-718h] BYREF
  _DWORD *v10; // [esp+88h] [ebp-6E0h]
  LPVOID pv; // [esp+8Ch] [ebp-6DCh] BYREF
  IShellFolder *ppshf; // [esp+90h] [ebp-6D8h] BYREF
  LPITEMIDLIST ppidl; // [esp+94h] [ebp-6D4h] BYREF
  SHFILEINFOW psfi; // [esp+98h] [ebp-6D0h] BYREF
  WCHAR pszBuf[260]; // [esp+350h] [ebp-418h] BYREF
  WCHAR String[262]; // [esp+558h] [ebp-210h] BYREF

  v6 = (HWND)this[3];
  v10 = this;
  ppshf = 0;
  ppidl = 0;
  SendMessageW(v6, 0x1101u, 0, -65536);
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) < 0 )
    return 0;
  sub_4664A0(0, pszBuf);
  pv = 0;
  if ( sub_467810((LPITEMIDLIST *)&pv, (int)pszBuf) >= 0 )
    sub_466630((const ITEMIDLIST *)pv, String, 1);
  CoTaskMemFree(pv);
  SHGetFileInfoW(&ppidl->mkid.cb, 0, &psfi, 0, 0x4008u);
  v2 = sub_41D430((int)this);
  v3 = (LPARAM)v10;
  *(_DWORD *)(v10[147] + 8 * v2) = ILClone(ppidl);
  *(_DWORD *)(*(_DWORD *)(v3 + 584) + 4 * v2) = 1;
  v9[0] = 103;
  v9[4] = (int)String;
  v9[5] = lstrlenW(String);
  v9[6] = psfi.iIcon;
  v9[7] = psfi.iIcon;
  v9[9] = v2;
  lParam[0] = 0;
  lParam[1] = -65534;
  v9[8] = 1;
  qmemcpy(v8, v9, sizeof(v8));
  v4 = SendMessageW(*(HWND *)(v3 + 12), 0x1132u, 0, (LPARAM)lParam);
  if ( v4 )
  {
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      sub_41CED0(v3, (int)ppshf, ppidl, v4);
      SendMessageW(*(HWND *)(v3 + 12), 0x1102u, 2u, v4);
      ppshf->lpVtbl->Release(ppshf);
    }
  }
  CoTaskMemFree(ppidl);
  return v4;
}

//----- (0041C970) --------------------------------------------------------
HRESULT __userpurge sub_41C970@<eax>(const ITEMIDLIST *a1@<eax>, LPARAM a2, int a3)
{
  HRESULT result; // eax
  int v5; // esi
  HRESULT v6; // eax
  HRESULT v7; // esi
  IShellFolder *ppshf; // [esp+Ch] [ebp-Ch] BYREF
  LPITEMIDLIST ppidl; // [esp+10h] [ebp-8h] BYREF
  IShellFolder *v10; // [esp+14h] [ebp-4h] BYREF

  ppshf = 0;
  v10 = 0;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    ppidl = 0;
    if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 && (v5 = sub_466190(a1, ppidl), CoTaskMemFree(ppidl), v5) )
      v6 = SHGetDesktopFolder(&v10);
    else
      v6 = ppshf->lpVtbl->BindToObject(ppshf, a1, 0, &stru_4BD7FC, (void **)&v10);
    v7 = v6;
    if ( v6 >= 0 )
    {
      sub_41CED0(a2, (int)v10, a1, a3);
      v10->lpVtbl->Release(v10);
    }
    ppshf->lpVtbl->Release(ppshf);
    return v7;
  }
  return result;
}

//----- (0041CA20) --------------------------------------------------------
void __userpurge sub_41CA20(ULONG_PTR a1@<ebx>, int a2)
{
  char *v2; // ecx
  char *v3; // eax
  char *v4; // edi
  char **v5; // eax
  char *v6[3]; // [esp+Ch] [ebp-44h] BYREF
  LPARAM lParam[14]; // [esp+18h] [ebp-38h] BYREF

  EnterCriticalSection(&CriticalSection);
  v2 = *(char **)(a2 + 4);
  v6[0] = *(char **)(a1 + 12);
  v6[2] = v2;
  lParam[0] = 20;
  lParam[1] = (LPARAM)v2;
  SendMessageW((HWND)v6[0], 0x113Eu, 0, (LPARAM)lParam);
  v3 = (char *)ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(a1 + 588) + 8 * lParam[9]));
  v4 = dword_4EF770;
  v6[1] = v3;
  v5 = sub_41EEB0(v6, dword_4EF770, *((_DWORD *)dword_4EF770 + 1));
  if ( dword_4EF774 == 357913940 )
    std::_Xlength_error("list<T> too long");
  ++dword_4EF774;
  *((_DWORD *)v4 + 1) = v5;
  *(_DWORD *)v5[1] = v5;
  if ( dword_4EF534 == dword_4EF538 )
  {
    ++dword_4EF538;
    QueueUserAPC(pfnAPC, *(HANDLE *)(a1 + 580), a1);
  }
  LeaveCriticalSection(&CriticalSection);
}
// 4EF534: using guessed type int dword_4EF534;
// 4EF538: using guessed type int dword_4EF538;
// 4EF774: using guessed type int dword_4EF774;

//----- (0041CB00) --------------------------------------------------------
int __usercall sub_41CB00@<eax>(_DWORD *a1@<eax>)
{
  char *v3; // ecx
  char *v4; // eax

  EnterCriticalSection(&CriticalSection);
  if ( dword_4EF774 )
  {
    v3 = dword_4EF770;
    v4 = (char *)*((_DWORD *)dword_4EF770 + 1);
    *a1 = *((_DWORD *)v4 + 2);
    a1[1] = *((_DWORD *)v4 + 3);
    a1[2] = *((_DWORD *)v4 + 4);
    if ( v4 != v3 )
    {
      **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
      *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
      operator delete(v4);
      --dword_4EF774;
    }
    LeaveCriticalSection(&CriticalSection);
    return 1;
  }
  else
  {
    ++dword_4EF534;
    dword_4DFE4C = 1;
    LeaveCriticalSection(&CriticalSection);
    return 0;
  }
}
// 4DFE4C: using guessed type int dword_4DFE4C;
// 4EF534: using guessed type int dword_4EF534;
// 4EF774: using guessed type int dword_4EF774;

//----- (0041CB90) --------------------------------------------------------
void __stdcall pfnAPC(ULONG_PTR Parameter)
{
  HWND v1; // edi
  HWND v2; // ebx
  int v3; // esi
  char *v4; // eax
  HWND hWnd[2]; // [esp+Ch] [ebp-2F4h] BYREF
  LPARAM v6; // [esp+14h] [ebp-2ECh]
  LPARAM lParam[10]; // [esp+18h] [ebp-2E8h] BYREF
  SHFILEINFOW psfi; // [esp+40h] [ebp-2C0h] BYREF

  if ( sub_41CB00(hWnd) )
  {
    v1 = hWnd[1];
    v2 = hWnd[0];
    do
    {
      if ( SHGetFileInfoW((LPCWSTR)v1, 0, &psfi, 0x2B4u, 0x148u) )
      {
        lParam[6] = psfi.iIcon;
        lParam[7] = psfi.iIcon;
        lParam[0] = 50;
        lParam[1] = v6;
        if ( psfi.iIcon >> 24 )
        {
          lParam[0] = 58;
          lParam[2] = psfi.iIcon >> 24 << 8;
          lParam[3] = 3840;
        }
        SendMessageW(v2, 0x113Fu, 0, (LPARAM)lParam);
        DestroyIcon(psfi.hIcon);
        CoTaskMemFree(v1);
      }
      EnterCriticalSection(&CriticalSection);
      if ( dword_4EF774 )
      {
        v4 = (char *)*((_DWORD *)dword_4EF770 + 1);
        v2 = (HWND)*((_DWORD *)v4 + 2);
        v1 = (HWND)*((_DWORD *)v4 + 3);
        v6 = *((_DWORD *)v4 + 4);
        if ( v4 != dword_4EF770 )
        {
          **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
          *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
          operator delete(v4);
          --dword_4EF774;
        }
        v3 = 1;
      }
      else
      {
        v3 = 0;
        ++dword_4EF534;
        dword_4DFE4C = 1;
      }
      LeaveCriticalSection(&CriticalSection);
    }
    while ( v3 );
  }
}
// 4DFE4C: using guessed type int dword_4DFE4C;
// 4EF534: using guessed type int dword_4EF534;
// 4EF774: using guessed type int dword_4EF774;

//----- (0041CCE0) --------------------------------------------------------
int __stdcall sub_41CCE0(int a1, int a2, int a3)
{
  return sub_41CD00(a2, a3, a1);
}

//----- (0041CD00) --------------------------------------------------------
int __userpurge sub_41CD00@<eax>(int a1@<ebx>, int a2@<esi>, int a3)
{
  WCHAR pszPath[260]; // [esp+8h] [ebp-620h] BYREF
  WCHAR String2[260]; // [esp+210h] [ebp-418h] BYREF
  WCHAR v6[262]; // [esp+418h] [ebp-210h] BYREF

  sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * a3), pszPath, 0x8000);
  sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * a1), String2, 0x8000);
  if ( PathIsRootW(pszPath) && !PathIsRootW(String2) )
    return -1;
  if ( !PathIsRootW(pszPath) && PathIsRootW(String2) )
    return 1;
  if ( PathIsRootW(pszPath) && PathIsRootW(String2) )
    return lstrcmpiW(pszPath, String2);
  if ( !SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 588) + 8 * a3), v6)
    && SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 588) + 8 * a1), v6) )
  {
    return -1;
  }
  if ( SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 588) + 8 * a3), v6)
    && !SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 588) + 8 * a1), v6) )
  {
    return 1;
  }
  sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * a3), pszPath, 1);
  sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * a1), String2, 1);
  return StrCmpLogicalW(pszPath, String2);
}

//----- (0041CED0) --------------------------------------------------------
void __fastcall sub_41CED0(LPARAM a1, int a2, LPCITEMIDLIST pidl, int a4)
{
  const ITEMIDLIST *v4; // edi
  int v5; // ebx
  int v6; // esi
  int v7; // esi
  bool v8; // zf
  int v9; // eax
  int v10; // eax
  int (__stdcall *v11)(int, int, LPCITEMIDLIST *, LPITEMIDLIST *); // ecx
  LPITEMIDLIST v12; // edi
  int v13; // esi
  char *v14; // eax
  int v15; // esi
  __int16 v16; // cx
  const WCHAR *v17; // esi
  const WCHAR *v18; // edi
  const WCHAR *v19; // ebx
  int v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // esi
  LPITEMIDLIST v23; // eax
  int v24; // edx
  HANDLE Thread; // eax
  HWND v26; // [esp-10h] [ebp-A28h]
  STRRET pstr; // [esp+10h] [ebp-A08h] BYREF
  LPARAM lParam[2]; // [esp+118h] [ebp-900h] BYREF
  char v29[56]; // [esp+120h] [ebp-8F8h] BYREF
  int v30[14]; // [esp+15Ch] [ebp-8BCh] BYREF
  int v31; // [esp+194h] [ebp-884h] BYREF
  LPARAM v32[3]; // [esp+198h] [ebp-880h] BYREF
  LPVOID pv; // [esp+1A4h] [ebp-874h]
  void *v34; // [esp+1A8h] [ebp-870h] BYREF
  const WCHAR *v35; // [esp+1ACh] [ebp-86Ch]
  int v36; // [esp+1B0h] [ebp-868h]
  LPARAM v37; // [esp+1B8h] [ebp-860h]
  LPCITEMIDLIST v38; // [esp+1BCh] [ebp-85Ch]
  int v39; // [esp+1C0h] [ebp-858h] BYREF
  LPITEMIDLIST v40; // [esp+1C4h] [ebp-854h] BYREF
  BOOL v41; // [esp+1C8h] [ebp-850h]
  int v42; // [esp+1CCh] [ebp-84Ch]
  int v43; // [esp+1D0h] [ebp-848h] BYREF
  LPARAM v44; // [esp+1D4h] [ebp-844h]
  LPITEMIDLIST ppidl; // [esp+1D8h] [ebp-840h] BYREF
  LPCITEMIDLIST pidl2; // [esp+1DCh] [ebp-83Ch] BYREF
  char v47[520]; // [esp+1E0h] [ebp-838h] BYREF
  int v48; // [esp+3E8h] [ebp-630h]
  __int16 v49[260]; // [esp+3F0h] [ebp-628h] BYREF
  WCHAR pszPath[260]; // [esp+5F8h] [ebp-420h] BYREF
  WCHAR pszBuf[260]; // [esp+800h] [ebp-218h] BYREF
  int v52; // [esp+A14h] [ebp-4h]

  v4 = pidl;
  v5 = a1;
  v37 = a4;
  v6 = a2;
  v44 = a1;
  v42 = a2;
  v38 = pidl;
  v43 = 0;
  v40 = 0;
  pidl2 = 0;
  v41 = !SHGetPathFromIDListW(pidl, pszPath);
  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
  {
    v7 = sub_466190(pidl, ppidl);
    CoTaskMemFree(ppidl);
    v8 = v7 == 0;
    v6 = v42;
    if ( !v8 )
      v41 = 1;
  }
  sub_466630(pidl, pszPath, 0x8000);
  sub_466630(pidl, (WCHAR *)v49, 0x8000);
  if ( SHGetFolderLocation(0, 17, 0, 0, &v40) >= 0 )
  {
    sub_466190(pidl, v40);
    CoTaskMemFree(v40);
    v6 = v42;
  }
  SendMessageW(*(HWND *)(v5 + 12), 0xBu, 0, 0);
  v9 = 32;
  if ( *(_DWORD *)(v5 + 552) )
    v9 = 160;
  v10 = (*(int (__stdcall **)(int, _DWORD, int, int *))(*(_DWORD *)v6 + 16))(v6, 0, v9, &v43);
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v52 = 0;
  if ( v10 >= 0 && v43 )
  {
    v39 = 1;
    if ( !(*(int (__stdcall **)(int, int, LPCITEMIDLIST *, int *))(*(_DWORD *)v43 + 12))(v43, 1, &pidl2, &v39) )
    {
      while ( 1 )
      {
        if ( v39 != 1 )
          goto LABEL_32;
        v11 = *(int (__stdcall **)(int, int, LPCITEMIDLIST *, LPITEMIDLIST *))(*(_DWORD *)v6 + 36);
        ppidl = (LPITEMIDLIST)1610612736;
        if ( v11(v6, 1, &pidl2, &ppidl) >= 0
          && ((unsigned int)ppidl & 0x20000000) != 0
          && (*(int (__stdcall **)(int, LPCITEMIDLIST, _DWORD, STRRET *))(*(_DWORD *)v6 + 44))(v6, pidl2, 0, &pstr) >= 0 )
        {
          break;
        }
LABEL_31:
        CoTaskMemFree((LPVOID)pidl2);
        if ( (*(int (__stdcall **)(int, int, LPCITEMIDLIST *, int *))(*(_DWORD *)v43 + 12))(v43, 1, &pidl2, &v39) )
          goto LABEL_32;
      }
      StrRetToBufW(&pstr, pidl2, pszBuf, 0x104u);
      v12 = ILCombine(v4, pidl2);
      pv = v12;
      v13 = sub_41D430(v5);
      *(_DWORD *)(*(_DWORD *)(v5 + 588) + 8 * v13) = ILClone(v12);
      *(_DWORD *)(*(_DWORD *)(v5 + 588) + 8 * v13 + 4) = ILClone(pidl2);
      v14 = v47;
      v48 = v13;
      v15 = 260;
      while ( v15 != -2147483386 )
      {
        v16 = *((_WORD *)v14 + 784);
        if ( !v16 )
          break;
        *(_WORD *)v14 = v16;
        v14 += 2;
        if ( !--v15 )
        {
          v14 -= 2;
          break;
        }
      }
      *(_WORD *)v14 = 0;
      if ( v41 )
      {
        sub_41ED30((unsigned int)v47, &v34);
LABEL_30:
        CoTaskMemFree(pv);
        v5 = v44;
        v4 = v38;
        v6 = v42;
        goto LABEL_31;
      }
      v17 = v35;
      v18 = (const WCHAR *)v34;
      if ( ((char *)v35 - (_BYTE *)v34) / 524 )
      {
        v17 = v35 - 262;
        if ( StrCmpLogicalW(pszBuf, v35 - 262) >= 0 )
        {
LABEL_26:
          if ( v17 != v18 )
          {
LABEL_28:
            v17 += 262;
            goto LABEL_29;
          }
        }
        else
        {
          while ( v17 != v18 )
          {
            v17 -= 262;
            if ( StrCmpLogicalW(pszBuf, v17) >= 0 )
              goto LABEL_26;
          }
        }
        if ( StrCmpLogicalW(pszBuf, v17) > 0 )
          goto LABEL_28;
      }
LABEL_29:
      sub_41F070((int)&v34, &v31, (int)v17, v47);
      goto LABEL_30;
    }
LABEL_32:
    (*(void (__stdcall **)(int))(*(_DWORD *)v43 + 8))(v43);
    v19 = (const WCHAR *)v34;
    if ( v34 != v35 )
    {
      do
      {
        v30[6] = -1;
        v30[7] = -1;
        v20 = *((_DWORD *)v19 + 130);
        lParam[0] = v37;
        v30[9] = v20;
        lParam[1] = -65534;
        v30[0] = 103;
        v30[4] = (int)v19;
        v30[8] = 1;
        qmemcpy(v29, v30, sizeof(v29));
        SendMessageW(*(HWND *)(v44 + 12), 0x1132u, 0, (LPARAM)lParam);
        v19 += 262;
      }
      while ( v19 != v35 );
    }
    if ( v41 )
    {
      v32[0] = v37;
      v26 = *(HWND *)(v44 + 12);
      v32[1] = (LPARAM)sub_41CCE0;
      v32[2] = v44;
      SendMessageW(v26, 0x1115u, 0, (LPARAM)v32);
    }
    v4 = v38;
    v5 = v44;
  }
  SendMessageW(*(HWND *)(v5 + 12), 0xBu, 1u, 0);
  v21 = malloc(0x14u);
  v22 = v21;
  if ( v21 )
  {
    *v21 = *(_DWORD *)(v5 + 12);
    v23 = ILClone(v4);
    v24 = v37;
    v22[2] = v23;
    v22[1] = v24;
    v22[3] = v5;
    Thread = CreateThread(0, 0, sub_41D500, v22, 0, &ThreadId);
    CloseHandle(Thread);
  }
  if ( v34 )
    operator delete(v34);
}
// 41D196: conditional instruction was optimized away because esi.4!=0
// 41CED0: using guessed type WCHAR var_628[260];

//----- (0041D430) --------------------------------------------------------
int __usercall sub_41D430@<eax>(int a1@<esi>)
{
  int v1; // edx
  int result; // eax
  _DWORD *v3; // ecx
  void *v4; // eax
  int v5; // edx
  void *v6; // ecx
  void *v7; // eax
  bool v8; // zf
  int v9; // ecx

  v1 = *(_DWORD *)(a1 + 592);
  result = 0;
  if ( v1 <= 0 )
  {
LABEL_5:
    v4 = realloc(*(void **)(a1 + 584), 4 * v1 + 400);
    v5 = *(_DWORD *)(a1 + 592);
    v6 = *(void **)(a1 + 588);
    *(_DWORD *)(a1 + 584) = v4;
    v7 = realloc(v6, 8 * v5 + 800);
    v8 = *(_DWORD *)(a1 + 584) == 0;
    *(_DWORD *)(a1 + 588) = v7;
    if ( v8 || !v7 )
    {
      return -1;
    }
    else
    {
      result = *(_DWORD *)(a1 + 592);
      *(_DWORD *)(a1 + 592) = result + 100;
      v9 = result;
      if ( !__OFSUB__(result, result + 100) )
      {
        do
          *(_DWORD *)(*(_DWORD *)(a1 + 584) + 4 * v9++) = 0;
        while ( v9 < *(_DWORD *)(a1 + 592) );
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 584) + 4 * result) = 1;
    }
  }
  else
  {
    v3 = *(_DWORD **)(a1 + 584);
    while ( *v3 )
    {
      ++result;
      ++v3;
      if ( result >= v1 )
        goto LABEL_5;
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 584) + 4 * result) = 1;
  }
  return result;
}

//----- (0041D500) --------------------------------------------------------
DWORD __stdcall sub_41D500(LPVOID lpThreadParameter)
{
  int v1; // edi

  v1 = *((_DWORD *)lpThreadParameter + 3);
  CoInitializeEx(0, 2u);
  sub_41D530(v1, lpThreadParameter);
  CoUninitialize();
  return 0;
}

//----- (0041D530) --------------------------------------------------------
int __stdcall sub_41D530(int a1, void *Block)
{
  LRESULT (__stdcall *v2)(HWND, UINT, WPARAM, LPARAM); // ebx
  void *v3; // esi
  HWND v4; // ecx
  LPARAM i; // edi
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  ITEMIDLIST *v9; // esi
  HWND v11; // [esp-10h] [ebp-58h]
  HWND v12; // [esp-10h] [ebp-58h]
  void *ppv; // [esp+10h] [ebp-38h] BYREF
  LPCITEMIDLIST pidl; // [esp+14h] [ebp-34h]
  LPCITEMIDLIST ppidlLast; // [esp+18h] [ebp-30h] BYREF
  int v16; // [esp+1Ch] [ebp-2Ch] BYREF
  LPARAM lParam[9]; // [esp+20h] [ebp-28h] BYREF
  int v18; // [esp+44h] [ebp-4h]

  v2 = SendMessageW;
  v3 = Block;
  v4 = *(HWND *)Block;
  ppv = 0;
  pidl = 0;
  ppidlLast = 0;
  for ( i = SendMessageW(v4, 0x110Au, 4u, *((_DWORD *)Block + 1)); i; i = SendMessageW(*(HWND *)v3, 0x110Au, 1u, i) )
  {
    v11 = *(HWND *)v3;
    v16 = 0x80000000;
    lParam[0] = 20;
    lParam[1] = i;
    if ( v2(v11, 0x113Eu, 0, (LPARAM)lParam) )
    {
      v6 = v18;
      v7 = 0;
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 556));
      v8 = a1;
      if ( v6 < *(_DWORD *)(a1 + 592) && *(_DWORD *)(*(_DWORD *)(a1 + 584) + 4 * v6) == 1 )
      {
        pidl = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(a1 + 588) + 8 * v18));
        v8 = a1;
        v7 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(v8 + 556));
      if ( v7 )
      {
        v9 = (ITEMIDLIST *)pidl;
        if ( SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast) >= 0
          && (*(int (__stdcall **)(void *, int, LPCITEMIDLIST *, int *))(*(_DWORD *)ppv + 36))(ppv, 1, &ppidlLast, &v16) >= 0 )
        {
          if ( (v16 & 0x80000000) != 0x80000000 )
          {
            v12 = *(HWND *)Block;
            lParam[0] = 64;
            lParam[8] = 0;
            SendMessageW(v12, 0x113Fu, 0, (LPARAM)lParam);
          }
          (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
        }
        CoTaskMemFree(v9);
      }
      v3 = Block;
    }
    v2 = SendMessageW;
  }
  CoTaskMemFree(*((LPVOID *)v3 + 2));
  free(v3);
  return 0;
}

//----- (0041D6C0) --------------------------------------------------------
LRESULT __usercall sub_41D6C0@<eax>(LPARAM lParam@<ecx>, LPCWSTR pszPath@<edx>, int a3@<ebx>)
{
  LPARAM v6; // esi
  DWORD FileAttributesW; // edi
  int v8; // edi
  HWND v9; // [esp-10h] [ebp-270h]
  HWND v10; // [esp-10h] [ebp-270h]
  LPARAM lParama[14]; // [esp+Ch] [ebp-254h] BYREF
  LPCWSTR lpString1; // [esp+44h] [ebp-21Ch]
  int v13; // [esp+48h] [ebp-218h]
  int v14; // [esp+4Ch] [ebp-214h]
  WCHAR FileName[262]; // [esp+50h] [ebp-210h] BYREF

  lpString1 = pszPath;
  v14 = 0;
  if ( PathIsRootW(pszPath) )
    return sub_41D850(pszPath, a3, lParam);
  v6 = SendMessageW(*(HWND *)(a3 + 12), 0x110Au, 4u, lParam);
  if ( !v6 )
    return -65535;
  v13 = -65535;
  while ( 1 )
  {
    v9 = *(HWND *)(a3 + 12);
    lParama[0] = 20;
    lParama[1] = v6;
    SendMessageW(v9, 0x113Eu, 0, (LPARAM)lParama);
    sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a3 + 588) + 8 * lParama[9]), FileName, 0x8000);
    FileAttributesW = GetFileAttributesW(FileName);
    if ( PathIsRootW(FileName) || (FileAttributesW & 0x40000000) != 0 || lstrcmpiW(lpString1, FileName) >= 0 )
    {
      v8 = v14;
    }
    else
    {
      v8 = v13;
      v14 = v13;
    }
    v10 = *(HWND *)(a3 + 12);
    v13 = v6;
    v6 = SendMessageW(v10, 0x110Au, 1u, v6);
    if ( !v6 )
      break;
    if ( v8 )
      return v8;
  }
  if ( !v8 )
  {
    v14 = -65534;
    return -65534;
  }
  return v8;
}

//----- (0041D850) --------------------------------------------------------
LRESULT __userpurge sub_41D850@<eax>(const WCHAR *a1@<ecx>, int a2@<edi>, LPARAM lParam)
{
  LPARAM v3; // esi
  LRESULT result; // eax
  const ITEMIDLIST *v5; // ebx
  HWND v6; // [esp-4h] [ebp-378h]
  HWND v7; // [esp-4h] [ebp-378h]
  int v8; // [esp+14h] [ebp-360h]
  void *ppv; // [esp+18h] [ebp-35Ch] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+1Ch] [ebp-358h] BYREF
  LPCWSTR lpString1; // [esp+20h] [ebp-354h]
  LPARAM v12[14]; // [esp+24h] [ebp-350h] BYREF
  STRRET pstr; // [esp+5Ch] [ebp-318h] BYREF
  WCHAR pszBuf[262]; // [esp+164h] [ebp-210h] BYREF

  v6 = *(HWND *)(a2 + 12);
  lpString1 = a1;
  v3 = SendMessageW(v6, 0x110Au, 4u, lParam);
  if ( !v3 )
    return -65535;
  v8 = -65535;
  while ( 1 )
  {
    v7 = *(HWND *)(a2 + 12);
    v12[0] = 20;
    v12[1] = v3;
    SendMessageW(v7, 0x113Eu, 0, (LPARAM)v12);
    v5 = *(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * v12[9]);
    if ( v5 )
    {
      ppv = 0;
      ppidlLast = 0;
      if ( SHBindToParent(v5, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(
               ppv,
               ppidlLast,
               0x8000,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v5, pszBuf, 0x104u);
        (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
      }
    }
    if ( !PathIsRootW(pszBuf) || lstrcmpW(lpString1, pszBuf) < 0 )
      break;
    v8 = v3;
    result = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 1u, v3);
    v3 = result;
    if ( !result )
      return result;
  }
  return v8;
}

//----- (0041D9D0) --------------------------------------------------------
LPITEMIDLIST __usercall sub_41D9D0@<eax>(LPARAM a1@<eax>, int a2@<esi>)
{
  HWND v3; // [esp-10h] [ebp-48h]
  LPARAM lParam[14]; // [esp+0h] [ebp-38h] BYREF

  v3 = *(HWND *)(a2 + 12);
  lParam[0] = 20;
  lParam[1] = a1;
  SendMessageW(v3, 0x113Eu, 0, (LPARAM)lParam);
  return ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 588) + 8 * lParam[9]));
}

//----- (0041DA20) --------------------------------------------------------
LPARAM __userpurge sub_41DA20@<eax>(int a1@<esi>, int a2)
{
  WCHAR *v2; // eax
  int v3; // edx
  WCHAR v4; // cx
  LPARAM v5; // eax
  LPARAM v6; // edi
  WCHAR *v7; // eax
  WCHAR v8; // cx
  HWND v10; // [esp-10h] [ebp-66Ch]
  LPARAM lParam[10]; // [esp+8h] [ebp-654h] BYREF
  LPCITEMIDLIST pidl2; // [esp+30h] [ebp-62Ch] BYREF
  int v13; // [esp+34h] [ebp-628h]
  WCHAR String2[260]; // [esp+38h] [ebp-624h] BYREF
  WCHAR String1[260]; // [esp+240h] [ebp-41Ch] BYREF
  WCHAR pszPath[262]; // [esp+448h] [ebp-214h] BYREF

  v2 = pszPath;
  pidl2 = 0;
  v3 = 260;
  while ( v3 != -2147483386 )
  {
    v4 = *(WCHAR *)((char *)v2 + a2 - (_DWORD)pszPath);
    if ( !v4 )
      break;
    *v2++ = v4;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  PathRemoveFileSpecW(pszPath);
  if ( sub_467810((LPITEMIDLIST *)&pidl2, (int)pszPath) < 0 )
    return sub_41DD00(a2, a1);
  v5 = sub_41DBD0(a1, pidl2, 1);
  if ( !v5 )
    return sub_41DD00(a2, a1);
  v6 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 4u, v5);
  v7 = String1;
  v13 = 260;
  while ( v13 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v7 + a2 - (_DWORD)String1);
    if ( !v8 )
      break;
    *v7++ = v8;
    if ( !--v13 )
    {
      --v7;
      break;
    }
  }
  *v7 = 0;
  PathStripPathW(String1);
  if ( !v6 )
    return sub_41DD00(a2, a1);
  while ( 1 )
  {
    v10 = *(HWND *)(a1 + 12);
    lParam[0] = 17;
    lParam[1] = v6;
    lParam[4] = (LPARAM)String2;
    lParam[5] = 260;
    SendMessageW(v10, 0x113Eu, 0, (LPARAM)lParam);
    if ( !lstrcmpW(String1, String2) )
      break;
    v6 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 1u, v6);
    if ( !v6 )
      return sub_41DD00(a2, a1);
  }
  return v6;
}
// 41DA71: conditional instruction was optimized away because edx.4!=0
// 41DB1E: conditional instruction was optimized away because %var_628.4!=0

//----- (0041DBD0) --------------------------------------------------------
LPARAM __userpurge sub_41DBD0@<eax>(int a1@<edi>, LPCITEMIDLIST pidl2, int a3)
{
  HWND v3; // eax
  LRESULT i; // eax
  LPARAM v5; // esi
  bool v6; // zf
  HWND v8; // [esp-8h] [ebp-60h]
  WPARAM v9; // [esp+0h] [ebp-58h]
  LPARAM v10; // [esp+4h] [ebp-54h]
  IShellFolder *ppshf; // [esp+10h] [ebp-48h] BYREF
  int v12; // [esp+14h] [ebp-44h]
  const ITEMIDLIST *v13; // [esp+18h] [ebp-40h]
  LPCITEMIDLIST *v14; // [esp+1Ch] [ebp-3Ch]
  LPARAM lParam[14]; // [esp+20h] [ebp-38h] BYREF

  v3 = *(HWND *)(a1 + 12);
  v10 = 0;
  v9 = 0;
LABEL_2:
  for ( i = SendMessageW(v3, 0x110Au, v9, v10); ; i = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 4u, v5) )
  {
    v5 = i;
    v8 = *(HWND *)(a1 + 12);
    lParam[0] = 20;
    lParam[1] = i;
    SendMessageW(v8, 0x113Eu, 0, (LPARAM)lParam);
    if ( !v5 )
      break;
    v14 = (LPCITEMIDLIST *)(*(_DWORD *)(a1 + 588) + 8 * lParam[9]);
    v13 = *v14;
    if ( v13 )
    {
      if ( pidl2 )
      {
        ppshf = 0;
        v12 = 0;
        if ( SHGetDesktopFolder(&ppshf) >= 0 )
        {
          if ( !(unsigned __int16)ppshf->lpVtbl->CompareIDs(ppshf, 0, v13, pidl2) )
            v12 = 1;
          ppshf->lpVtbl->Release(ppshf);
          if ( v12 )
            break;
        }
      }
    }
    v6 = !ILIsParent(*v14, pidl2, 0);
    v3 = *(HWND *)(a1 + 12);
    v10 = v5;
    if ( v6 )
    {
      v9 = 1;
      goto LABEL_2;
    }
    if ( !SendMessageW(v3, 0x110Au, 4u, v5) )
    {
      if ( a3 )
        return 0;
      SendMessageW(*(HWND *)(a1 + 12), 0x1102u, 2u, v5);
    }
  }
  return v5;
}

//----- (0041DD00) --------------------------------------------------------
LPARAM __usercall sub_41DD00@<eax>(int a1@<ecx>, int a2@<ebx>)
{
  WCHAR *v2; // eax
  int v3; // edx
  int v4; // esi
  WCHAR v5; // cx
  LPARAM v6; // esi
  LPARAM v7; // esi
  wchar_t *v9; // eax
  __int16 *v10; // ecx
  int v11; // edx
  int v12; // edi
  __int16 v13; // ax
  int v14; // edx
  __int16 *v15; // eax
  HWND v16; // [esp-10h] [ebp-680h]
  HWND v17; // [esp-10h] [ebp-680h]
  HWND v18; // [esp-10h] [ebp-680h]
  HWND v19; // [esp-10h] [ebp-680h]
  LPARAM lParam; // [esp+Ch] [ebp-664h] BYREF
  LPARAM v21; // [esp+10h] [ebp-660h]
  __int16 *v22; // [esp+1Ch] [ebp-654h]
  int v23; // [esp+20h] [ebp-650h]
  int v24; // [esp+30h] [ebp-640h]
  LPITEMIDLIST ppidl; // [esp+44h] [ebp-62Ch] BYREF
  wchar_t *Context; // [esp+48h] [ebp-628h] BYREF
  PCWSTR v27; // [esp+4Ch] [ebp-624h]
  WCHAR pszPath[260]; // [esp+50h] [ebp-620h] BYREF
  WCHAR psz2[260]; // [esp+258h] [ebp-418h] BYREF
  __int16 psz1[262]; // [esp+460h] [ebp-210h] BYREF

  v2 = pszPath;
  ppidl = 0;
  Context = 0;
  v3 = 260;
  v4 = a1 - (_DWORD)pszPath;
  while ( v3 != -2147483386 )
  {
    v5 = *(WCHAR *)((char *)v2 + v4);
    if ( !v5 )
      break;
    *v2++ = v5;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  PathRemoveBackslashW(pszPath);
  SHGetFolderLocation(0, 17, 0, 0, &ppidl);
  v6 = sub_41DBD0(a2, ppidl, 0);
  CoTaskMemFree(ppidl);
  v7 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 4u, v6);
  if ( !v7 )
    return 0;
  v9 = wcstok_s(pszPath, L"\\", &Context);
  v10 = psz1;
  v11 = 260;
  v12 = (char *)v9 - (char *)psz1;
  while ( v11 != -2147483386 )
  {
    v13 = *(__int16 *)((char *)v10 + v12);
    if ( !v13 )
      break;
    *v10++ = v13;
    if ( !--v11 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  v14 = 260;
  v15 = psz1;
  while ( *v15 )
  {
    ++v15;
    if ( !--v14 )
      goto LABEL_18;
  }
  sub_4AA520(v14, (int)L"\\", &psz1[260 - v14]);
LABEL_18:
  v16 = *(HWND *)(a2 + 12);
  lParam = 20;
  v21 = v7;
  SendMessageW(v16, 0x113Eu, 0, (LPARAM)&lParam);
  sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * v24), psz2, 0x8000);
  while ( StrCmpIW((PCWSTR)psz1, psz2) )
  {
    v7 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 1u, v7);
    if ( !v7 )
      return 0;
    v17 = *(HWND *)(a2 + 12);
    lParam = 4;
    v21 = v7;
    SendMessageW(v17, 0x113Eu, 0, (LPARAM)&lParam);
    sub_466630(*(const ITEMIDLIST **)(*(_DWORD *)(a2 + 588) + 8 * v24), psz2, 0x8000);
  }
  lParam = 1;
  v27 = wcstok_s(0, L"\\", &Context);
  if ( v27 )
  {
    while ( SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 4u, v7) )
    {
      v7 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 4u, v7);
      v18 = *(HWND *)(a2 + 12);
      v22 = psz1;
      v23 = 260;
      v21 = v7;
      SendMessageW(v18, 0x113Eu, 0, (LPARAM)&lParam);
      while ( StrCmpIW(v27, (PCWSTR)psz1) )
      {
        v7 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 1u, v7);
        if ( !v7 )
          return 0;
        v19 = *(HWND *)(a2 + 12);
        v22 = psz1;
        v23 = 260;
        v21 = v7;
        SendMessageW(v19, 0x113Eu, 0, (LPARAM)&lParam);
      }
      v27 = wcstok_s(0, L"\\", &Context);
      if ( !v27 )
        return v7;
    }
    return 0;
  }
  return v7;
}
// 41DD54: conditional instruction was optimized away because edx.4!=0
// 41DE11: conditional instruction was optimized away because edx.4!=0
// 41DE36: conditional instruction was optimized away because edx.4!=0
// 41DD00: using guessed type WCHAR psz1[262];

//----- (0041E080) --------------------------------------------------------
LPARAM __usercall sub_41E080@<eax>(wchar_t *String1@<ecx>, int a2@<ebx>)
{
  int v3; // eax
  wchar_t *v5; // eax
  int v6; // edx
  wchar_t v7; // cx
  wchar_t *v8; // esi
  wchar_t *v9; // eax
  LPARAM v10; // esi
  HWND v11; // [esp-10h] [ebp-888h]
  HWND v12; // [esp-10h] [ebp-888h]
  LPARAM lParam[14]; // [esp+Ch] [ebp-86Ch] BYREF
  int v14; // [esp+44h] [ebp-834h]
  wchar_t *Context; // [esp+48h] [ebp-830h] BYREF
  LPCWSTR lpString2; // [esp+4Ch] [ebp-82Ch]
  WCHAR String1a[260]; // [esp+50h] [ebp-828h] BYREF
  WCHAR pszPath[260]; // [esp+258h] [ebp-620h] BYREF
  wchar_t v19[260]; // [esp+460h] [ebp-418h] BYREF
  WCHAR String[262]; // [esp+668h] [ebp-210h] BYREF

  Context = 0;
  SHGetFolderPathW(0, 0, 0, 0, pszPath);
  v3 = lstrlenW(pszPath);
  if ( wcsncmp(String1, pszPath, v3) )
    return 0;
  v5 = v19;
  v6 = 260;
  while ( v6 != -2147483386 )
  {
    v7 = *(wchar_t *)((char *)v5 + (char *)String1 - (char *)v19);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  SHGetFolderPathW(0, 0, 0, 0, String);
  v8 = &v19[lstrlenW(String)];
  lpString2 = (LPCWSTR)lstrlenW(String1);
  if ( (int)lpString2 > lstrlenW(String) )
    ++v8;
  Context = 0;
  v9 = wcstok_s(v8, L"\\", &Context);
  v11 = *(HWND *)(a2 + 12);
  lpString2 = v9;
  v10 = SendMessageW(v11, 0x110Au, 0, 0);
  if ( lpString2 )
  {
    while ( 1 )
    {
      v10 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 4u, v10);
      v14 = 0;
      if ( !v10 )
        return 0;
      while ( !v14 )
      {
        v12 = *(HWND *)(a2 + 12);
        lParam[0] = 1;
        lParam[1] = v10;
        lParam[4] = (LPARAM)String1a;
        lParam[5] = 260;
        SendMessageW(v12, 0x113Eu, 0, (LPARAM)lParam);
        if ( lstrcmpW(String1a, lpString2) )
          v10 = SendMessageW(*(HWND *)(a2 + 12), 0x110Au, 1u, v10);
        else
          v14 = 1;
        if ( !v10 )
        {
          if ( !v14 )
            return 0;
          break;
        }
      }
      lpString2 = wcstok_s(Context, L"\\", &Context);
      if ( !lpString2 )
        return v10;
    }
  }
  return v10;
}
// 41E120: conditional instruction was optimized away because edx.4!=0

//----- (0041E2B0) --------------------------------------------------------
LRESULT __thiscall sub_41E2B0(int this, LPARAM lParam)
{
  LRESULT result; // eax
  LPARAM i; // edi
  LPVOID *v5; // ebx
  HWND v6; // [esp-10h] [ebp-5Ch]
  LPARAM v7[9]; // [esp+10h] [ebp-3Ch] BYREF
  int v8; // [esp+34h] [ebp-18h]

  result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 4u, lParam);
  for ( i = result; result; i = result )
  {
    v6 = *(HWND *)(this + 12);
    v7[0] = 84;
    v7[1] = i;
    SendMessageW(v6, 0x113Eu, 0, (LPARAM)v7);
    if ( v7[8] )
      sub_41E2B0(this, i);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 556));
    v5 = (LPVOID *)(*(_DWORD *)(this + 588) + 8 * v8);
    CoTaskMemFree(*v5);
    CoTaskMemFree(v5[1]);
    *(_DWORD *)(*(_DWORD *)(this + 584) + 4 * v8) = 0;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 556));
    result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 1u, i);
  }
  return result;
}

//----- (0041E380) --------------------------------------------------------
int __userpurge sub_41E380@<eax>(int a1@<ecx>, int a2@<edi>, int a3)
{
  unsigned int v3; // eax
  __int16 i; // cx
  LPARAM v5; // ebx
  int result; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // esi
  _WORD *v9; // edx
  int v10; // esi
  _WORD *v11; // eax
  unsigned int v12; // eax
  __int16 j; // cx
  LPARAM v14; // ebx
  HWND v15; // ecx
  HWND v16; // [esp-10h] [ebp-51Ch]
  LPARAM lParam; // [esp+Ch] [ebp-500h] BYREF
  LPARAM v18; // [esp+10h] [ebp-4FCh]
  __int16 *v19; // [esp+1Ch] [ebp-4F0h]
  int iIcon; // [esp+24h] [ebp-4E8h]
  int v21; // [esp+28h] [ebp-4E4h]
  int v22; // [esp+34h] [ebp-4D8h]
  SHFILEINFOW psfi; // [esp+38h] [ebp-4D4h] BYREF
  __int16 v24[262]; // [esp+2F0h] [ebp-21Ch] BYREF
  WCHAR pszPath[4]; // [esp+4FCh] [ebp-10h] BYREF

  v22 = a3;
  switch ( a1 )
  {
    case 32768:
      if ( *(_DWORD *)(a3 + 4) != 2 )
        goto LABEL_8;
      v3 = *(_DWORD *)(a3 + 12);
      for ( i = 0; (v3 & 1) == 0; ++i )
        v3 >>= 1;
      sub_401000(4u, pszPath, L"%c:\\", (unsigned __int16)(i + 65));
      if ( (*(_BYTE *)(v22 + 16) & 1) != 0 )
      {
        v5 = sub_41DD00((int)pszPath, a2);
        if ( v5 )
        {
          SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u);
          sub_467B70((int)pszPath, (WCHAR *)v24, 1);
          iIcon = psfi.iIcon;
          v21 = psfi.iIcon;
          v16 = *(HWND *)(a2 + 12);
          lParam = 51;
          v18 = v5;
          v19 = v24;
          SendMessageW(v16, 0x113Fu, 0, (LPARAM)&lParam);
        }
        goto LABEL_8;
      }
      sub_41FA40(a2, pszPath);
      sub_41E750(pszPath, a2);
      result = 0;
      break;
    case 32769:
      if ( *(_DWORD *)(a3 + 4) == 6 )
      {
        v7 = *(_DWORD **)(a2 + 1200);
        v8 = (_DWORD *)*v7;
        if ( (_DWORD *)*v7 != v7 )
        {
          while ( v8[132] != *(_DWORD *)(a3 + 12) )
          {
            v8 = (_DWORD *)*v8;
            if ( v8 == v7 )
              return 1;
          }
          (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a2 + 24) + 20))(*(_DWORD *)(a2 + 24), v8[133]);
          v9 = v8 + 2;
          *(_DWORD *)(a2 + 1212) = 1;
          v10 = 260;
          v11 = (_WORD *)(a2 + 1216);
          while ( v10 != -2147483386 && *v9 )
          {
            *v11++ = *v9++;
            if ( !--v10 )
            {
              *(v11 - 1) = 0;
              return 1;
            }
          }
          *v11 = 0;
        }
      }
      result = 1;
      break;
    case 32772:
      if ( *(_DWORD *)(a3 + 4) == 2 )
      {
        v12 = *(_DWORD *)(a3 + 12);
        for ( j = 0; (v12 & 1) == 0; ++j )
          v12 >>= 1;
        sub_401000(4u, pszPath, L"%c:\\", (unsigned __int16)(j + 65));
        if ( (*(_BYTE *)(v22 + 16) & 1) != 0 )
        {
          v14 = sub_41DD00((int)pszPath, a2);
          if ( v14 )
          {
            SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u);
            sub_467B70((int)pszPath, (WCHAR *)v24, 1);
            v15 = *(HWND *)(a2 + 12);
            iIcon = psfi.iIcon;
            v21 = psfi.iIcon;
            lParam = 51;
            v18 = v14;
            v19 = v24;
            SendMessageW(v15, 0x113Fu, 0, (LPARAM)&lParam);
            return 1;
          }
        }
        else
        {
          sub_4200D0((int)pszPath, a2);
        }
      }
      else if ( *(_DWORD *)(a3 + 4) == 6 )
      {
        UnregisterDeviceNotification(*(HDEVNOTIFY *)(a3 + 16));
        return 1;
      }
      result = 1;
      break;
    default:
LABEL_8:
      result = 0;
      break;
  }
  return result;
}
// 41E55E: conditional instruction was optimized away because esi.4!=0
// 4CC544: using guessed type wchar_t aC[5];
// 41E380: using guessed type WCHAR var_21C[262];

//----- (0041E6D0) --------------------------------------------------------
DWORD __stdcall sub_41E6D0(LPVOID lpThreadParameter)
{
  DWORD LogicalDriveStringsW; // esi
  DWORD result; // eax
  WCHAR *v3; // edi
  const WCHAR *v4; // esi
  int v5; // eax
  bool v6; // zf

  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0);
  result = (DWORD)malloc(2 * LogicalDriveStringsW + 2);
  v3 = (WCHAR *)result;
  if ( result )
  {
    if ( GetLogicalDriveStringsW(LogicalDriveStringsW, (LPWSTR)result) )
    {
      v4 = v3;
      if ( *v3 )
      {
        do
        {
          sub_41E750(v4, (int)lpThreadParameter);
          v5 = lstrlenW(v4);
          v6 = v4[v5 + 1] == 0;
          v4 += v5 + 1;
        }
        while ( !v6 );
      }
    }
    free(v3);
    return 1;
  }
  return result;
}

//----- (0041E750) --------------------------------------------------------
char **__thiscall sub_41E750(LPCWSTR lpFileName, int a2)
{
  char **result; // eax
  _WORD *v4; // eax
  int v5; // edi
  _WORD *v6; // ecx
  __int16 v7; // dx
  int v8; // ebx
  int v9; // eax
  char *v10; // eax
  int v11; // edx
  int v12; // esi
  __int16 v13; // cx
  void *v14; // [esp-Ch] [ebp-268h]
  char **v15; // [esp+14h] [ebp-248h]
  int v16; // [esp+14h] [ebp-248h]
  char v17[520]; // [esp+18h] [ebp-244h] BYREF
  int v18; // [esp+220h] [ebp-3Ch]
  int v19; // [esp+224h] [ebp-38h]
  int NotificationFilter[11]; // [esp+228h] [ebp-34h] BYREF

  result = (char **)GetDriveTypeW(lpFileName);
  if ( result != (char **)4 )
  {
    result = (char **)CreateFileW(lpFileName, 1u, 7u, 0, 3u, 0x42000000u, 0);
    v15 = result;
    if ( result != (char **)-1 )
    {
      v4 = malloc(0x20Cu);
      v5 = 260;
      v6 = v4;
      while ( v5 != -2147483386 )
      {
        v7 = *(_WORD *)((char *)v6 + (char *)lpFileName - (char *)v4);
        if ( !v7 )
          break;
        *v6++ = v7;
        if ( !--v5 )
        {
          --v6;
          break;
        }
      }
      v8 = (int)v15;
      *v6 = 0;
      *((_DWORD *)v4 + 130) = a2;
      v9 = (*(int (__thiscall **)(_DWORD, char **, LPCWSTR, int, void (__cdecl *)(LPCWSTR, int, int), int, _WORD *))(**(_DWORD **)(a2 + 24) + 12))(
             *(_DWORD *)(a2 + 24),
             v15,
             lpFileName,
             2,
             sub_41F8D0,
             1,
             v4);
      v14 = *(void **)(a2 + 12);
      v16 = v9;
      NotificationFilter[0] = 44;
      NotificationFilter[1] = 6;
      NotificationFilter[3] = v8;
      result = (char **)RegisterDeviceNotificationW(v14, NotificationFilter, 0);
      if ( result )
      {
        v10 = v17;
        v11 = 260;
        v12 = (char *)lpFileName - v17;
        while ( v11 != -2147483386 )
        {
          v13 = *(_WORD *)&v10[v12];
          if ( !v13 )
            break;
          *(_WORD *)v10 = v13;
          v10 += 2;
          if ( !--v11 )
          {
            v10 -= 2;
            break;
          }
        }
        *(_WORD *)v10 = 0;
        v19 = v16;
        v18 = v8;
        return sub_41ECF0((int)v17, a2 + 1200);
      }
    }
  }
  return result;
}
// 41E7E0: conditional instruction was optimized away because edi.4!=0
// 41E870: conditional instruction was optimized away because edx.4!=0

//----- (0041E8B0) --------------------------------------------------------
int __stdcall sub_41E8B0(int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  return -2147467262;
}

//----- (0041E8D0) --------------------------------------------------------
int __stdcall sub_41E8D0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

//----- (0041E8F0) --------------------------------------------------------
int __stdcall sub_41E8F0(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 5))-- == 1;
  result = *((_DWORD *)a1 + 5);
  if ( v1 )
  {
    sub_41C3B0((int)a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (0041E920) --------------------------------------------------------
LPARAM __usercall sub_41E920@<eax>(int a1@<esi>)
{
  LPARAM v1; // ebx
  LPARAM v2; // eax
  HWND v4; // [esp-10h] [ebp-310h]
  HWND v5; // [esp-10h] [ebp-310h]
  LPARAM lParam; // [esp+8h] [ebp-2F8h] BYREF
  LPARAM v7; // [esp+Ch] [ebp-2F4h]
  int iIcon; // [esp+20h] [ebp-2E0h]
  int v9; // [esp+24h] [ebp-2DCh]
  int v10; // [esp+2Ch] [ebp-2D4h]
  SHFILEINFOW psfi; // [esp+40h] [ebp-2C0h] BYREF

  v1 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 0, 0);
  v4 = *(HWND *)(a1 + 12);
  lParam = 20;
  v7 = v1;
  SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
  SHGetFileInfoW(*(LPCWSTR *)(*(_DWORD *)(a1 + 588) + 8 * v10), 0, &psfi, 0x2B4u, 0x4008u);
  v5 = *(HWND *)(a1 + 12);
  lParam = 50;
  v7 = v1;
  iIcon = psfi.iIcon;
  v9 = psfi.iIcon;
  SendMessageW(v5, 0x113Fu, 0, (LPARAM)&lParam);
  v2 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 4u, v1);
  return sub_41EA00(a1, v2);
}

//----- (0041EA00) --------------------------------------------------------
LPARAM __thiscall sub_41EA00(int this, LPARAM lParam)
{
  LPARAM v3; // ebx
  HWND v4; // ecx
  LPARAM result; // eax
  LPARAM v6; // eax
  HWND v7; // [esp-10h] [ebp-30Ch]
  HWND v8; // [esp-10h] [ebp-30Ch]
  HWND v9; // [esp-10h] [ebp-30Ch]
  LPARAM v10; // [esp+Ch] [ebp-2F0h] BYREF
  LPARAM v11; // [esp+10h] [ebp-2ECh]
  int iIcon; // [esp+24h] [ebp-2D8h]
  int v13; // [esp+28h] [ebp-2D4h]
  int v14; // [esp+30h] [ebp-2CCh]
  LPARAM v15; // [esp+34h] [ebp-2C8h]
  SHFILEINFOW psfi; // [esp+38h] [ebp-2C4h] BYREF

  v15 = lParam;
  v3 = SendMessageW(*(HWND *)(this + 12), 0x110Au, 1u, lParam);
  v7 = *(HWND *)(this + 12);
  v10 = 20;
  v11 = lParam;
  SendMessageW(v7, 0x113Eu, 0, (LPARAM)&v10);
  SHGetFileInfoW(*(LPCWSTR *)(*(_DWORD *)(this + 588) + 8 * v14), 0, &psfi, 0x2B4u, 0x4008u);
  v4 = *(HWND *)(this + 12);
  iIcon = psfi.iIcon;
  v13 = psfi.iIcon;
  v10 = 50;
  v11 = v15;
  SendMessageW(v4, 0x113Fu, 0, (LPARAM)&v10);
  result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 4u, v15);
  if ( result )
    result = sub_41EA00(this, result);
  if ( v3 )
  {
    do
    {
      v8 = *(HWND *)(this + 12);
      v10 = 20;
      v11 = v3;
      SendMessageW(v8, 0x113Eu, 0, (LPARAM)&v10);
      SHGetFileInfoW(*(LPCWSTR *)(*(_DWORD *)(this + 588) + 8 * v14), 0, &psfi, 0x2B4u, 0x4008u);
      v9 = *(HWND *)(this + 12);
      v10 = 50;
      v11 = v3;
      iIcon = psfi.iIcon;
      v13 = psfi.iIcon;
      SendMessageW(v9, 0x113Fu, 0, (LPARAM)&v10);
      v6 = SendMessageW(*(HWND *)(this + 12), 0x110Au, 4u, v3);
      if ( v6 )
        sub_41EA00(this, v6);
      result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 1u, v3);
      v3 = result;
    }
    while ( result );
  }
  return result;
}

//----- (0041EBC0) --------------------------------------------------------
HRESULT __userpurge sub_41EBC0@<eax>(IDropSource *a1@<esi>, int a2, struct IDropSourceVtbl *a3)
{
  HRESULT result; // eax
  HRESULT v4; // edi
  LPDATAOBJECT v5; // eax
  IDataObject *v6; // [esp-10h] [ebp-38h]
  int v7[2]; // [esp+Ch] [ebp-1Ch] BYREF
  DWORD pdwEffect; // [esp+14h] [ebp-14h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+18h] [ebp-10h] BYREF
  LPVOID ppv; // [esp+1Ch] [ebp-Ch] BYREF
  void *v11; // [esp+20h] [ebp-8h] BYREF
  LPDATAOBJECT pDataObj; // [esp+24h] [ebp-4h] BYREF

  pDataObj = 0;
  ppv = 0;
  v11 = 0;
  ppidlLast = 0;
  v7[0] = 0;
  v7[1] = 0;
  result = CoCreateInstance(&rclsid, 0, 0x17u, &riid, &ppv);
  if ( result >= 0 )
  {
    v4 = SHBindToParent(*((LPCITEMIDLIST *)&a1[147].lpVtbl->QueryInterface + 2 * a2), &stru_4BD7FC, &v11, &ppidlLast);
    if ( v4 >= 0 )
    {
      (*(void (__stdcall **)(void *, struct IDropSourceVtbl *, int, LPCITEMIDLIST *, _DWORD *, _DWORD, LPDATAOBJECT *))(*(_DWORD *)v11 + 40))(
        v11,
        a1[3].lpVtbl,
        1,
        &ppidlLast,
        dword_4BD9FC,
        0,
        &pDataObj);
      (*(void (__stdcall **)(LPVOID, struct IDropSourceVtbl *, int *, LPDATAOBJECT))(*(_DWORD *)ppv + 16))(
        ppv,
        a1[3].lpVtbl,
        v7,
        pDataObj);
      v6 = pDataObj;
      a1[157].lpVtbl = a3;
      v4 = DoDragDrop(v6, a1 + 1, 7u, &pdwEffect);
      v5 = pDataObj;
      a1[153].lpVtbl = 0;
      v5->lpVtbl->Release(v5);
      (*(void (__stdcall **)(void *))(*(_DWORD *)v11 + 8))(v11);
    }
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    return v4;
  }
  return result;
}
// 4BD9FC: using guessed type _DWORD dword_4BD9FC[4];

//----- (0041ECB0) --------------------------------------------------------
void __usercall sub_41ECB0(void **a1@<esi>)
{
  void **v1; // eax
  void **v2; // edi

  v1 = *(void ***)*a1;
  *(_DWORD *)*a1 = *a1;
  *((_DWORD *)*a1 + 1) = *a1;
  a1[1] = 0;
  if ( v1 != *a1 )
  {
    do
    {
      v2 = (void **)*v1;
      operator delete(v1);
      v1 = v2;
    }
    while ( v2 != *a1 );
  }
  operator delete(*a1);
}

//----- (0041ECF0) --------------------------------------------------------
char **__usercall sub_41ECF0@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v2; // esi
  char **result; // eax
  int v4; // ecx

  v2 = *(char **)a2;
  result = sub_41EE00(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), a1);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 == 8134406 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 4) = v4 + 1;
  *((_DWORD *)v2 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0041ED30) --------------------------------------------------------
int __usercall sub_41ED30@<eax>(__int64 a1@<edx:eax>, _DWORD *a2@<ebx>)
{
  unsigned int v2; // ecx
  char *v3; // esi
  int v4; // esi
  char *v5; // edi

  v2 = a2[1];
  v3 = (char *)a1;
  if ( (unsigned int)a1 >= v2 || (LODWORD(a1) = *a2, *a2 > (unsigned int)v3) )
  {
    if ( v2 == a2[2] )
      LODWORD(a1) = sub_41ED90(a2);
  }
  else
  {
    a1 = 1049152317i64 * (int)&v3[-a1];
    v4 = (SHIDWORD(a1) >> 7) + (HIDWORD(a1) >> 31);
    if ( v2 == a2[2] )
      LODWORD(a1) = sub_41ED90(a2);
    v3 = (char *)(*a2 + 524 * v4);
  }
  v5 = (char *)a2[1];
  if ( v5 )
    qmemcpy(v5, v3, 0x20Cu);
  a2[1] += 524;
  return a1;
}

//----- (0041ED90) --------------------------------------------------------
unsigned int __thiscall sub_41ED90(_DWORD *this)
{
  unsigned int v1; // esi
  unsigned int result; // eax
  unsigned int v3; // eax

  if ( (unsigned int)((this[1] - *this) / 524) > 0x7D1195 )
    std::_Xlength_error("vector<T> too long");
  v1 = (this[1] - *this) / 524 + 1;
  result = (this[2] - *this) / 524;
  if ( v1 > result )
  {
    if ( 8196502 - (result >> 1) >= result )
      v3 = (result >> 1) + result;
    else
      v3 = 0;
    if ( v3 < v1 )
      v3 = (this[1] - *this) / 524 + 1;
    return sub_41EF20((int)this, v3);
  }
  return result;
}

//----- (0041EE00) --------------------------------------------------------
char **__stdcall sub_41EE00(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x218u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x210u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041EE70) --------------------------------------------------------
char *sub_41EE70()
{
  char *result; // eax
  char *v1; // esi

  result = *(char **)dword_4EF770;
  *(_DWORD *)dword_4EF770 = dword_4EF770;
  *((_DWORD *)dword_4EF770 + 1) = dword_4EF770;
  dword_4EF774 = 0;
  if ( result != dword_4EF770 )
  {
    do
    {
      v1 = *(char **)result;
      operator delete(result);
      result = v1;
    }
    while ( v1 != dword_4EF770 );
  }
  return result;
}
// 4EF774: using guessed type int dword_4EF774;

//----- (0041EEB0) --------------------------------------------------------
char **__userpurge sub_41EEB0@<eax>(char **a1@<esi>, char *a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x14u);
  if ( !result )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a3;
  *result = a2;
  result[1] = v4;
  if ( result != (char **)-8 )
  {
    result[2] = *a1;
    result[3] = a1[1];
    result[4] = a1[2];
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041EF20) --------------------------------------------------------
unsigned int __thiscall sub_41EF20(int this, unsigned int a2)
{
  unsigned int result; // eax
  void *v4; // eax
  char *v5; // ebx
  char *v6; // edx
  int v7; // ebx
  void *v8; // ecx
  char *v9; // ebx
  int v10; // [esp+0h] [ebp-24h] BYREF
  void *v11; // [esp+10h] [ebp-14h]
  int *v12; // [esp+14h] [ebp-10h]
  int v13; // [esp+20h] [ebp-4h]

  v12 = &v10;
  if ( a2 > 0x7D1196 )
    std::_Xlength_error("vector<T> too long");
  result = (*(_DWORD *)(this + 8) - *(_DWORD *)this) / 524;
  if ( result < a2 )
  {
    v4 = sub_41F010(a2);
    v13 = 0;
    v5 = *(char **)(this + 4);
    v6 = *(char **)this;
    v11 = v4;
    sub_41F0F0((char *)v4, v6, v5);
    v7 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) / 524;
    if ( *(_DWORD *)this )
      operator delete(*(void **)this);
    v8 = v11;
    result = (unsigned int)v11 + 524 * a2;
    v9 = (char *)v11 + 524 * v7;
    *(_DWORD *)(this + 8) = result;
    *(_DWORD *)(this + 4) = v9;
    *(_DWORD *)this = v8;
  }
  return result;
}

//----- (0041F010) --------------------------------------------------------
void *__fastcall sub_41F010(unsigned int a1)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( a1 )
  {
    if ( a1 > 0x7D1196 || (result = operator new(524 * a1)) == 0 )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041F070) --------------------------------------------------------
_DWORD *__userpurge sub_41F070@<eax>(int a1@<ebx>, _DWORD *a2, int a3, const void *a4)
{
  int v4; // esi
  void *v5; // edi
  int v6; // esi
  int v7; // edx
  int v8; // eax
  char *v9; // ecx
  _DWORD *result; // eax

  v4 = (a3 - *(_DWORD *)a1) / 524;
  if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)(a1 + 8) )
    sub_41ED90((_DWORD *)a1);
  v5 = *(void **)(a1 + 4);
  if ( v5 )
    qmemcpy(v5, a4, 0x20Cu);
  *(_DWORD *)(a1 + 4) += 524;
  v6 = 524 * v4;
  v7 = *(_DWORD *)(a1 + 4);
  v8 = v7 - 524;
  v9 = (char *)(v6 + *(_DWORD *)a1);
  if ( v9 != (char *)(v7 - 524) && v8 != v7 )
    sub_41F120(v8, v9, *(char **)(a1 + 4));
  result = a2;
  *a2 = v6 + *(_DWORD *)a1;
  return result;
}

//----- (0041F0F0) --------------------------------------------------------
char *__usercall sub_41F0F0@<eax>(char *result@<eax>, char *a2@<edx>, char *a3@<ebx>)
{
  for ( ; a2 != a3; result += 524 )
  {
    if ( result )
      qmemcpy(result, a2, 0x20Cu);
    a2 += 524;
  }
  return result;
}

//----- (0041F120) --------------------------------------------------------
int __usercall sub_41F120@<eax>(int a1@<eax>, char *a2, char *a3)
{
  char *v3; // ebx
  int v4; // ecx
  int result; // eax
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  int v11; // eax
  char v12[524]; // [esp+Ch] [ebp-220h] BYREF
  char *v13; // [esp+218h] [ebp-14h]
  int v14; // [esp+21Ch] [ebp-10h]
  int v15; // [esp+220h] [ebp-Ch]
  char *i; // [esp+224h] [ebp-8h]
  int v17; // [esp+228h] [ebp-4h]

  v3 = a2;
  v4 = (a1 - (int)a2) / 524;
  result = (a3 - a2) / 524;
  v14 = v4;
  v17 = result;
  v6 = v4;
  if ( v4 )
  {
    do
    {
      v7 = result % v6;
      v17 = v6;
      result = v6;
      v6 = v7;
    }
    while ( v7 );
  }
  if ( result < (a3 - a2) / 524 && result > 0 )
  {
    v8 = 524 * v4;
    v9 = &a2[524 * result];
    v15 = v8;
    for ( i = v9; ; v9 = i )
    {
      v10 = &v9[v8];
      if ( v10 != a3 )
        v3 = v10;
      while ( 1 )
      {
        qmemcpy(v12, v9, sizeof(v12));
        qmemcpy(v9, v3, 0x20Cu);
        qmemcpy(v3, v12, 0x20Cu);
        v11 = (a3 - v3) / 524;
        v13 = v3;
        if ( v14 >= v11 )
          v3 = &a2[524 * (v14 - v11)];
        else
          v3 += v15;
        if ( v3 == i )
          break;
        v9 = v13;
      }
      i -= 524;
      result = v17 - 1;
      v17 = result;
      if ( result <= 0 )
        break;
      v3 = a2;
      v8 = v15;
    }
  }
  return result;
}

//----- (0041F240) --------------------------------------------------------
int __stdcall sub_41F240(int a1)
{
  return sub_41E8F0((void *)(a1 - 4));
}

//----- (0041F250) --------------------------------------------------------
int __stdcall sub_41F250(int a1)
{
  return sub_41E8D0(a1 - 4);
}

//----- (0041F260) --------------------------------------------------------
int __stdcall sub_41F260(int a1, int a2, _DWORD *a3)
{
  return sub_41E8B0(a1 - 4, a2, a3);
}

//----- (0041F270) --------------------------------------------------------
void __usercall sub_41F270(int a1@<ebx>)
{
  struct _RTL_CRITICAL_SECTION *v1; // edi
  _DWORD *v2; // eax
  WCHAR *v3; // edx
  int v4; // esi
  _WORD *v5; // eax
  _DWORD **v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // [esp+10h] [ebp-220h]
  _DWORD *v10; // [esp+14h] [ebp-21Ch]
  WCHAR String2[266]; // [esp+18h] [ebp-218h] BYREF

  v1 = (struct _RTL_CRITICAL_SECTION *)(a1 + 656);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 656));
  KillTimer(*(HWND *)(a1 + 12), 0);
  v2 = *(_DWORD **)(a1 + 632);
  v9 = v2;
  v10 = (_DWORD *)*v2;
  if ( (_DWORD *)*v2 != v2 )
  {
    do
    {
      qmemcpy(String2, v10 + 2, 0x20Cu);
      switch ( *(_DWORD *)&String2[260] )
      {
        case 1:
          sub_41F3E0(String2, a1);
          break;
        case 2:
          sub_41F4D0(a1, String2);
          break;
        case 4:
          v3 = String2;
          v4 = 260;
          v5 = (_WORD *)(a1 + 680);
          while ( v4 != -2147483386 && *v3 )
          {
            *v5++ = *v3++;
            if ( !--v4 )
            {
              *(v5 - 1) = 0;
              goto LABEL_12;
            }
          }
          *v5 = 0;
          break;
        case 5:
          sub_41F6B0(a1, String2);
          break;
        default:
          break;
      }
LABEL_12:
      v10 = (_DWORD *)*v10;
    }
    while ( v10 != v9 );
    v1 = (struct _RTL_CRITICAL_SECTION *)(a1 + 656);
  }
  v6 = *(_DWORD ***)(a1 + 632);
  v7 = *v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 632) + 4) = *(_DWORD *)(a1 + 632);
  *(_DWORD *)(a1 + 636) = 0;
  if ( v7 != *(_DWORD **)(a1 + 632) )
  {
    do
    {
      v8 = (_DWORD *)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while ( v8 != *(_DWORD **)(a1 + 632) );
  }
  LeaveCriticalSection(v1);
}
// 41F33F: conditional instruction was optimized away because esi.4!=0

//----- (0041F3E0) --------------------------------------------------------
void __usercall sub_41F3E0(const WCHAR *a1@<ecx>, int a2@<esi>)
{
  int *v3; // eax
  int v4; // edx
  int v5; // edi
  __int16 v6; // cx
  int v7; // edi
  int v8; // ecx
  char **v9; // eax
  int v10; // ecx
  LPVOID pv; // [esp+Ch] [ebp-21Ch] BYREF
  int v12[133]; // [esp+10h] [ebp-218h] BYREF

  pv = 0;
  if ( sub_467810((LPITEMIDLIST *)&pv, (int)a1) < 0 )
  {
    v3 = v12;
    v4 = 260;
    v5 = (char *)a1 - (char *)v12;
    while ( v4 != -2147483386 )
    {
      v6 = *(_WORD *)((char *)v3 + v5);
      if ( !v6 )
        break;
      *(_WORD *)v3 = v6;
      v3 = (int *)((char *)v3 + 2);
      if ( !--v4 )
      {
        v3 = (int *)((char *)v3 - 2);
        break;
      }
    }
    v7 = *(_DWORD *)(a2 + 644);
    v8 = *(_DWORD *)(v7 + 4);
    *(_WORD *)v3 = 0;
    v12[130] = 1;
    v9 = sub_4201B0((char *)v7, v8, (int)v12);
    v10 = *(_DWORD *)(a2 + 648);
    if ( v10 == 8196501 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a2 + 648) = v10 + 1;
    *(_DWORD *)(v7 + 4) = v9;
    *(_DWORD *)v9[1] = v9;
  }
  else
  {
    sub_41FA40(a2, a1);
    CoTaskMemFree(pv);
  }
}
// 41F465: conditional instruction was optimized away because edx.4!=0

//----- (0041F4D0) --------------------------------------------------------
void __fastcall sub_41F4D0(int a1, wchar_t *a2)
{
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  LPARAM v7; // eax
  LPARAM v8; // esi
  LPARAM v9; // eax
  LPARAM v10; // esi
  LPARAM v11; // esi
  void **v12; // eax
  WCHAR *v13; // esi
  LPARAM v14; // [esp+Ch] [ebp-224h]
  LPARAM v16; // [esp+14h] [ebp-21Ch]
  LPVOID pv; // [esp+1Ch] [ebp-214h] BYREF
  WCHAR pszPath[262]; // [esp+20h] [ebp-210h] BYREF

  v4 = pszPath;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v4 + (char *)a2 - (char *)pszPath);
    if ( !v6 )
      break;
    *v4++ = v6;
    if ( !--v5 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathRemoveFileSpecW(pszPath);
  pv = (LPVOID)sub_41E080(pszPath, a1);
  v7 = sub_41E080(a2, a1);
  v8 = v7;
  v16 = v7;
  if ( v7 )
  {
    sub_41E2B0(a1, v7);
    SendMessageW(*(HWND *)(a1 + 12), 0x1101u, 0, v8);
  }
  v14 = sub_41DA20(a1, (int)a2);
  if ( v14 )
  {
    v9 = sub_41DA20(a1, (int)a2);
    v10 = v9;
    if ( v9 )
    {
      sub_41E2B0(a1, v9);
      SendMessageW(*(HWND *)(a1 + 12), 0x1101u, 0, v10);
    }
  }
  sub_420100(a1, (LPARAM)pv);
  pv = 0;
  if ( sub_467810((LPITEMIDLIST *)&pv, (int)pszPath) < 0 )
  {
    v11 = 0;
  }
  else
  {
    v11 = sub_41DBD0(a1, (LPCITEMIDLIST)pv, 1);
    CoTaskMemFree(pv);
  }
  sub_420100(a1, v11);
  if ( !v16 && !v14 )
  {
    v12 = *(void ***)(a1 + 644);
    v13 = (WCHAR *)*v12;
    if ( *v12 != v12 )
    {
      while ( lstrcmpW(a2, v13 + 4) )
      {
        v13 = *(WCHAR **)v13;
        if ( v13 == *(WCHAR **)(a1 + 644) )
          return;
      }
      if ( v13 != *(WCHAR **)(a1 + 644) )
      {
        **((_DWORD **)v13 + 1) = *(_DWORD *)v13;
        *(_DWORD *)(*(_DWORD *)v13 + 4) = *((_DWORD *)v13 + 1);
        operator delete(v13);
        --*(_DWORD *)(a1 + 648);
      }
    }
  }
}
// 41F530: conditional instruction was optimized away because edx.4!=0

//----- (0041F6B0) --------------------------------------------------------
void __userpurge sub_41F6B0(int a1@<eax>, LPCWSTR lpString2)
{
  int v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // edi
  LPARAM v7; // eax
  LRESULT v8; // esi
  HWND Parent; // eax
  void **v10; // eax
  WCHAR *v11; // edi
  _WORD *v12; // eax
  int v13; // edx
  __int16 v14; // cx
  const WCHAR **v15; // eax
  const WCHAR *v16; // esi
  WCHAR *v17; // esi
  char **v18; // eax
  int v19; // ecx
  HWND v20; // [esp-10h] [ebp-C4h]
  LPARAM v21[14]; // [esp+10h] [ebp-A4h] BYREF
  char v22[40]; // [esp+48h] [ebp-6Ch] BYREF
  LPARAM lParam[10]; // [esp+78h] [ebp-3Ch] BYREF
  LPARAM v24; // [esp+A0h] [ebp-14h]
  int v25; // [esp+A4h] [ebp-10h]
  LPCWSTR lpString1; // [esp+A8h] [ebp-Ch]
  int v27; // [esp+ACh] [ebp-8h]

  v3 = a1 + 680;
  lpString1 = (LPCWSTR)(a1 + 680);
  v4 = sub_41E080((wchar_t *)(a1 + 680), a1);
  v27 = v4;
  if ( v4 )
    sub_41FE20(lpString2, a1, v4);
  v5 = sub_41DD00(v3, a1);
  v6 = v5;
  v25 = v5;
  if ( v5 )
  {
    sub_41FE20(lpString2, a1, v5);
    v7 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 9u, 0);
    v24 = v7;
    if ( v7 == v6 )
    {
LABEL_8:
      lParam[1] = v7;
      v20 = *(HWND *)(a1 + 12);
      lParam[0] = 4;
      v8 = SendMessageW(v20, 0x113Eu, 0, (LPARAM)lParam);
      Parent = GetParent(*(HWND *)(a1 + 12));
      if ( v8 && Parent )
      {
        v21[2] = -451;
        v21[3] = 0;
        qmemcpy(v22, lParam, sizeof(v22));
        SendMessageW(Parent, 0x4Eu, 0, (LPARAM)v21);
        v6 = v25;
      }
    }
    else
    {
      while ( v7 )
      {
        v7 = SendMessageW(*(HWND *)(a1 + 12), 0x110Au, 3u, v7);
        if ( v7 == v6 )
        {
          v7 = v24;
          goto LABEL_8;
        }
      }
    }
  }
  if ( !v27 && !v6 )
  {
    v10 = *(void ***)(a1 + 644);
    v11 = (WCHAR *)*v10;
    if ( *v10 != v10 )
    {
      while ( lstrcmpW(lpString1, v11 + 4) )
      {
        v11 = *(WCHAR **)v11;
        if ( v11 == *(WCHAR **)(a1 + 644) )
          return;
      }
      v12 = v11 + 4;
      v13 = 260;
      while ( v13 != -2147483386 )
      {
        v14 = *(_WORD *)((char *)v12 + (char *)lpString2 - (char *)(v11 + 4));
        if ( !v14 )
          break;
        *v12++ = v14;
        if ( !--v13 )
        {
          --v12;
          break;
        }
      }
      *v12 = 0;
      v15 = *(const WCHAR ***)(a1 + 632);
      v16 = *v15;
      if ( *v15 != (const WCHAR *)v15 )
      {
        while ( *((_DWORD *)v16 + 132) != 5 || lstrcmpW(v16 + 4, lpString2) )
        {
          v16 = *(const WCHAR **)v16;
          if ( v16 == *(const WCHAR **)(a1 + 632) )
            goto LABEL_30;
        }
        v17 = *(WCHAR **)v16;
        v18 = sub_4201B0((char *)v17, *((_DWORD *)v17 + 1), (int)(v11 + 4));
        v19 = *(_DWORD *)(a1 + 636);
        if ( v19 == 8196501 )
          std::_Xlength_error("list<T> too long");
        *(_DWORD *)(a1 + 636) = v19 + 1;
        *((_DWORD *)v17 + 1) = v18;
        *(_DWORD *)v18[1] = v18;
      }
LABEL_30:
      if ( v11 != *(WCHAR **)(a1 + 644) )
      {
        **((_DWORD **)v11 + 1) = *(_DWORD *)v11;
        *(_DWORD *)(*(_DWORD *)v11 + 4) = *((_DWORD *)v11 + 1);
        operator delete(v11);
        --*(_DWORD *)(a1 + 648);
      }
    }
  }
}
// 41F812: conditional instruction was optimized away because edx.4!=0

//----- (0041F8D0) --------------------------------------------------------
void __cdecl sub_41F8D0(LPCWSTR pszMore, int a2, int a3)
{
  int v3; // esi
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  v3 = *(_DWORD *)(a3 + 520);
  v4 = pszPath;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v4 + a3 - (_DWORD)pszPath);
    if ( !v6 )
      break;
    *v4++ = v6;
    if ( !--v5 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathAppendW(pszPath, pszMore);
  sub_41F960(v3, a2, (int)pszPath);
}
// 41F923: conditional instruction was optimized away because edx.4!=0

//----- (0041F960) --------------------------------------------------------
void __userpurge sub_41F960(int a1@<esi>, int a2, int a3)
{
  int *v3; // eax
  int v4; // edi
  __int16 v5; // cx
  int v6; // edi
  char **v7; // eax
  int v8; // ecx
  int v9; // [esp-8h] [ebp-220h]
  int v10[131]; // [esp+8h] [ebp-210h] BYREF

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 656));
  SetTimer(*(HWND *)(a1 + 12), 0, 0x1F4u, 0);
  v3 = v10;
  v4 = 260;
  while ( v4 != -2147483386 )
  {
    v5 = *(_WORD *)((char *)v3 + a3 - (_DWORD)v10);
    if ( !v5 )
      break;
    *(_WORD *)v3 = v5;
    v3 = (int *)((char *)v3 + 2);
    if ( !--v4 )
    {
      v3 = (int *)((char *)v3 - 2);
      break;
    }
  }
  v6 = *(_DWORD *)(a1 + 632);
  *(_WORD *)v3 = 0;
  v9 = *(_DWORD *)(v6 + 4);
  v10[130] = a2;
  v7 = sub_4201B0((char *)v6, v9, (int)v10);
  v8 = *(_DWORD *)(a1 + 636);
  if ( v8 == 8196501 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 636) = v8 + 1;
  *(_DWORD *)(v6 + 4) = v7;
  *(_DWORD *)v7[1] = v7;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 656));
}
// 41F9D0: conditional instruction was optimized away because edi.4!=0

//----- (0041FA40) --------------------------------------------------------
void __fastcall sub_41FA40(int a1, const WCHAR *a2)
{
  LPARAM v4; // eax
  WCHAR *v5; // eax
  int v6; // edx
  int v7; // esi
  WCHAR v8; // cx
  LPARAM v9; // esi
  LPARAM v10; // edi
  LPITEMIDLIST ppidl; // [esp+14h] [ebp-214h] BYREF
  WCHAR pszPath[262]; // [esp+18h] [ebp-210h] BYREF

  if ( PathIsRootW(a2) )
  {
    ppidl = 0;
    if ( !SHGetFolderLocation(0, 17, 0, 0, &ppidl) )
    {
      v4 = sub_41DBD0(a1, ppidl, 1);
      if ( v4 )
        sub_41FBB0(a1, a2, v4);
      CoTaskMemFree(ppidl);
    }
    return;
  }
  v5 = pszPath;
  v6 = 260;
  v7 = (char *)a2 - (char *)pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v5 + v7);
    if ( !v8 )
      break;
    *v5++ = v8;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  PathRemoveFileSpecW(pszPath);
  v9 = sub_41E080(pszPath, a1);
  ppidl = 0;
  if ( sub_467810(&ppidl, (int)pszPath) < 0 )
  {
    v10 = 0;
LABEL_13:
    if ( !v9 )
      return;
    goto LABEL_14;
  }
  v10 = sub_41DBD0(a1, ppidl, 1);
  CoTaskMemFree(ppidl);
  if ( !v10 )
    goto LABEL_13;
LABEL_14:
  sub_41FBB0(a1, a2, v10);
  if ( v9 )
    sub_41FBB0(a1, a2, v9);
}
// 41FB01: conditional instruction was optimized away because edx.4!=0

//----- (0041FBB0) --------------------------------------------------------
void __fastcall sub_41FBB0(int a1, const WCHAR *a2, LPARAM a3)
{
  int v5; // ebx
  LPITEMIDLIST v6; // eax
  LPITEMIDLIST v7; // eax
  int v8; // ebx
  HWND v9; // [esp-10h] [ebp-584h]
  HWND v10; // [esp-10h] [ebp-584h]
  LPARAM v11[2]; // [esp+10h] [ebp-564h] BYREF
  char v12[56]; // [esp+18h] [ebp-55Ch] BYREF
  LPARAM lParam[14]; // [esp+54h] [ebp-520h] BYREF
  BOOL v14; // [esp+8Ch] [ebp-4E8h]
  int v15; // [esp+90h] [ebp-4E4h] BYREF
  LPARAM v16; // [esp+94h] [ebp-4E0h]
  LPCITEMIDLIST ppidlLast; // [esp+98h] [ebp-4DCh] BYREF
  void *ppv; // [esp+9Ch] [ebp-4D8h] BYREF
  int v19; // [esp+A0h] [ebp-4D4h]
  LPCITEMIDLIST pidl; // [esp+A4h] [ebp-4D0h] BYREF
  SHFILEINFOW psfi; // [esp+A8h] [ebp-4CCh] BYREF
  __int16 v22[262]; // [esp+360h] [ebp-214h] BYREF

  v16 = a3;
  v19 = a1;
  ppv = 0;
  pidl = 0;
  ppidlLast = 0;
  if ( sub_467810((LPITEMIDLIST *)&pidl, (int)a2) >= 0 )
  {
    v9 = *(HWND *)(a1 + 12);
    lParam[0] = 72;
    lParam[1] = v16;
    if ( SendMessageW(v9, 0x113Eu, 0, (LPARAM)lParam) )
    {
      if ( lParam[8] && (lParam[2] & 0x20) != 0 )
      {
        SHGetFileInfoW(a2, 0, &psfi, 0x2B4u, 0x4000u);
        if ( SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
        {
          v15 = 0x80000000;
          if ( (*(int (__stdcall **)(void *, int, LPCITEMIDLIST *, int *))(*(_DWORD *)ppv + 36))(
                 ppv,
                 1,
                 &ppidlLast,
                 &v15) >= 0 )
          {
            v14 = (v15 & 0x80000000) == 0x80000000;
            v5 = sub_41D430(a1);
            v6 = ILClone(pidl);
            *(_DWORD *)(*(_DWORD *)(v19 + 588) + 8 * v5) = v6;
            v7 = ILClone(ppidlLast);
            *(_DWORD *)(*(_DWORD *)(v19 + 588) + 8 * v5 + 4) = v7;
            sub_467B70((int)a2, (WCHAR *)v22, 0);
            lParam[8] = v14;
            lParam[4] = (LPARAM)v22;
            lParam[0] = 103;
            lParam[6] = psfi.iIcon;
            lParam[7] = psfi.iIcon;
            lParam[9] = v5;
            if ( v16 )
            {
              v8 = v19;
              v11[0] = v16;
              v11[1] = sub_41D6C0(v16, a2, v19);
              qmemcpy(v12, lParam, sizeof(v12));
              SendMessageW(*(HWND *)(v8 + 12), 0x1132u, 0, (LPARAM)v11);
            }
          }
          (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
        }
      }
      else
      {
        v10 = *(HWND *)(a1 + 12);
        lParam[0] = 64;
        lParam[1] = v16;
        lParam[8] = 1;
        SendMessageW(v10, 0x113Fu, 0, (LPARAM)lParam);
      }
    }
    CoTaskMemFree((LPVOID)pidl);
  }
}
// 41FBB0: using guessed type WCHAR var_214[262];

//----- (0041FE20) --------------------------------------------------------
LPARAM __userpurge sub_41FE20@<eax>(const WCHAR *a1@<ecx>, int a2@<esi>, LPARAM a3)
{
  LPARAM result; // eax
  HWND v5; // ecx
  LPVOID *v6; // ebx
  WCHAR *v7; // eax
  int v8; // edx
  int v9; // edi
  WCHAR v10; // cx
  const ITEMIDLIST *v11; // edi
  HWND v12; // edx
  LPARAM v13; // ebx
  LPARAM lParam; // [esp+8h] [ebp-50Ch] BYREF
  LPARAM v15; // [esp+Ch] [ebp-508h]
  WCHAR *v16; // [esp+18h] [ebp-4FCh]
  int iIcon; // [esp+20h] [ebp-4F4h]
  int v18; // [esp+24h] [ebp-4F0h]
  int v19; // [esp+2Ch] [ebp-4E8h]
  LPARAM v20; // [esp+40h] [ebp-4D4h]
  LPCWSTR v21; // [esp+44h] [ebp-4D0h]
  SHFILEINFOW psfi; // [esp+48h] [ebp-4CCh] BYREF
  WCHAR pszPath[262]; // [esp+300h] [ebp-214h] BYREF

  result = a3;
  v20 = a3;
  v21 = a1;
  if ( a3 )
  {
    v5 = *(HWND *)(a2 + 12);
    v15 = a3;
    lParam = 4;
    result = SendMessageW(v5, 0x113Eu, 0, (LPARAM)&lParam);
    if ( result )
    {
      v6 = (LPVOID *)(*(_DWORD *)(a2 + 588) + 8 * v19);
      CoTaskMemFree(*v6);
      v7 = pszPath;
      v8 = 260;
      v9 = (char *)a1 - (char *)pszPath;
      while ( v8 != -2147483386 )
      {
        v10 = *(WCHAR *)((char *)v7 + v9);
        if ( !v10 )
          break;
        *v7++ = v10;
        if ( !--v8 )
        {
          --v7;
          break;
        }
      }
      *v7 = 0;
      PathStripPathW(pszPath);
      result = sub_467810((LPITEMIDLIST *)v6, (int)v21);
      v11 = (const ITEMIDLIST *)*v6;
      if ( result >= 0 )
      {
        SHGetFileInfoW(v21, 0, &psfi, 0x2B4u, 0x4000u);
        v12 = *(HWND *)(a2 + 12);
        v13 = v20;
        v16 = pszPath;
        lParam = 51;
        v15 = v20;
        iIcon = psfi.iIcon;
        v18 = psfi.iIcon;
        SendMessageW(v12, 0x113Fu, 0, (LPARAM)&lParam);
        return sub_41FF80(a2, v13, v11);
      }
    }
  }
  return result;
}
// 41FEC6: conditional instruction was optimized away because edx.4!=0

//----- (0041FF80) --------------------------------------------------------
LRESULT __thiscall sub_41FF80(int this, LPARAM lParam, LPCITEMIDLIST pidl1)
{
  LRESULT (__stdcall *v3)(HWND, UINT, WPARAM, LPARAM); // ebx
  LRESULT result; // eax
  int v6; // edi
  LPARAM i; // edi
  int v8; // ebx
  HWND v9; // [esp-10h] [ebp-58h]
  HWND v10; // [esp-10h] [ebp-58h]
  LPARAM v11; // [esp+10h] [ebp-38h] BYREF
  LRESULT v12; // [esp+14h] [ebp-34h]
  int v13; // [esp+34h] [ebp-14h]
  LRESULT lParama; // [esp+50h] [ebp+8h]

  v3 = SendMessageW;
  result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 4u, lParam);
  lParama = result;
  if ( result )
  {
    v12 = result;
    v9 = *(HWND *)(this + 12);
    v11 = 4;
    result = SendMessageW(v9, 0x113Eu, 0, (LPARAM)&v11);
    if ( result )
    {
      v6 = 8 * v13;
      CoTaskMemFree(*(LPVOID *)(8 * v13 + *(_DWORD *)(this + 588)));
      *(_DWORD *)(v6 + *(_DWORD *)(this + 588)) = ILCombine(pidl1, *(LPCITEMIDLIST *)(*(_DWORD *)(this + 588) + v6 + 4));
      sub_41FF80(this, lParama, *(LPCITEMIDLIST *)(*(_DWORD *)(this + 588) + v6));
      result = SendMessageW(*(HWND *)(this + 12), 0x110Au, 1u, lParama);
      for ( i = result; result; i = result )
      {
        v10 = *(HWND *)(this + 12);
        v11 = 4;
        v12 = i;
        if ( v3(v10, 0x113Eu, 0, (LPARAM)&v11) )
        {
          v8 = 8 * v13;
          CoTaskMemFree(*(LPVOID *)(8 * v13 + *(_DWORD *)(this + 588)));
          *(_DWORD *)(v8 + *(_DWORD *)(this + 588)) = ILCombine(
                                                        pidl1,
                                                        *(LPCITEMIDLIST *)(*(_DWORD *)(this + 588) + v8 + 4));
          sub_41FF80(this, i, *(LPCITEMIDLIST *)(*(_DWORD *)(this + 588) + v8));
          v3 = SendMessageW;
        }
        result = v3(*(HWND *)(this + 12), 0x110Au, 1u, i);
      }
    }
  }
  return result;
}

//----- (004200D0) --------------------------------------------------------
LRESULT __usercall sub_4200D0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  LRESULT result; // eax
  LPARAM v4; // edi

  result = sub_41DA20(a2, a1);
  v4 = result;
  if ( result )
  {
    sub_41E2B0(a2, result);
    return SendMessageW(*(HWND *)(a2 + 12), 0x1101u, 0, v4);
  }
  return result;
}

//----- (00420100) --------------------------------------------------------
void __usercall sub_420100(int a1@<ebx>, LPARAM a2@<esi>)
{
  HWND v2; // [esp-10h] [ebp-40h]
  HWND v3; // [esp-10h] [ebp-40h]
  HWND v4; // [esp-10h] [ebp-40h]
  LPARAM lParam; // [esp+4h] [ebp-2Ch] BYREF
  LPARAM v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+24h] [ebp-Ch]
  int v8; // [esp+28h] [ebp-8h]
  int v9; // [esp+2Ch] [ebp-4h] BYREF

  if ( a2 )
  {
    v2 = *(HWND *)(a1 + 12);
    v9 = 0x80000000;
    lParam = 20;
    v6 = a2;
    if ( SendMessageW(v2, 0x113Eu, 0, (LPARAM)&lParam) )
    {
      if ( sub_4665C0(*(const ITEMIDLIST **)(*(_DWORD *)(a1 + 588) + 8 * v8), (int)&v9) >= 0 )
      {
        if ( (v9 & 0x80000000) == 0x80000000 )
        {
          v7 = 1;
        }
        else
        {
          v3 = *(HWND *)(a1 + 12);
          v7 = 0;
          SendMessageW(v3, 0x1102u, 1u, a2);
        }
        v4 = *(HWND *)(a1 + 12);
        lParam = 64;
        v6 = a2;
        SendMessageW(v4, 0x113Fu, 0, (LPARAM)&lParam);
      }
    }
  }
}

//----- (004201B0) --------------------------------------------------------
char **__stdcall sub_4201B0(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x214u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x20Cu);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00420220) --------------------------------------------------------
int __stdcall sub_420220(int a1, int a2, char a3, LONG a4, LONG a5, _DWORD *a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // edi
  LONG v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  _DWORD *v13; // edx
  LONG v14; // edx
  LPARAM v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // edi
  HWND v19; // [esp-10h] [ebp-64h]
  HWND v20; // [esp-8h] [ebp-5Ch]
  char *v21; // [esp+14h] [ebp-40h] BYREF
  void *v22[3]; // [esp+18h] [ebp-3Ch] BYREF
  int pExceptionObject[3]; // [esp+24h] [ebp-30h] BYREF
  struct tagPOINT Point; // [esp+30h] [ebp-24h] BYREF
  int v25; // [esp+38h] [ebp-1Ch]
  int v26; // [esp+3Ch] [ebp-18h]
  int v27; // [esp+40h] [ebp-14h]
  int v28; // [esp+50h] [ebp-4h]

  *(_DWORD *)(a1 + 608) = a2;
  *(_DWORD *)(a1 + 612) = 1;
  v22[1] = 0;
  v6 = operator new(0x1Cu);
  if ( !v6 )
  {
    v21 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v6 = v6;
  v22[0] = v6;
  v6[1] = v6;
  v28 = 0;
  sub_45F8F0((int)v22);
  v7 = v22[0];
  v8 = *(_DWORD **)v22[0];
  if ( *(void **)v22[0] == v22[0] )
  {
LABEL_5:
    v13 = a6;
    *(_DWORD *)(a1 + 624) = 0;
    *v13 = 0;
  }
  else
  {
    while ( 1 )
    {
      v9 = v8[2];
      v10 = v8[4];
      Point.y = v8[3];
      v11 = v8[6];
      Point.x = v9;
      v12 = v8[5];
      v25 = v10;
      v27 = v11;
      v26 = v12;
      if ( !(*(int (__stdcall **)(int, struct tagPOINT *))(*(_DWORD *)a2 + 20))(a2, &Point) )
        break;
      v8 = (_DWORD *)*v8;
      if ( v8 == v7 )
        goto LABEL_5;
    }
    v14 = a5;
    Point.x = a4;
    v20 = *(HWND *)(a1 + 12);
    *(_DWORD *)(a1 + 624) = 1;
    Point.y = v14;
    ScreenToClient(v20, &Point);
    v15 = SendMessageW(*(HWND *)(a1 + 12), 0x1111u, 0, (LPARAM)&Point);
    if ( v15 )
      sub_420630(a1, v15, *(_DWORD *)(a1 + 608));
  }
  v19 = *(HWND *)(a1 + 12);
  lParam = 0;
  SetTimer(v19, 2u, 0x3E8u, sub_420410);
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)(a1 + 628) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *(_DWORD *)(a1 + 628) = 1;
  }
  (*(void (__stdcall **)(_DWORD, _DWORD, int, LONG *, _DWORD))(**(_DWORD **)(a1 + 604) + 12))(
    *(_DWORD *)(a1 + 604),
    *(_DWORD *)(a1 + 12),
    a2,
    &a4,
    *a6);
  v16 = (_DWORD *)*v7;
  *v7 = v7;
  v7[1] = v7;
  if ( v16 != v7 )
  {
    do
    {
      v17 = (_DWORD *)*v16;
      operator delete(v16);
      v16 = v17;
    }
    while ( v17 != v7 );
  }
  operator delete(v7);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00420410) --------------------------------------------------------
void __stdcall sub_420410(HWND hWnd, UINT a2, UINT_PTR a3, DWORD a4)
{
  dword_4EF568 = 1;
  KillTimer(hWnd, 2u);
}
// 4EF568: using guessed type int dword_4EF568;

//----- (00420430) --------------------------------------------------------
int __userpurge sub_420430@<eax>(LONG *a1@<eax>, int a2@<esi>, char a3, char a4)
{
  LONG v4; // edx
  LPARAM v5; // eax
  int v6; // eax
  HWND v8; // [esp-8h] [ebp-18h]
  struct tagPOINT Point; // [esp+0h] [ebp-10h] BYREF

  v4 = a1[1];
  Point.x = *a1;
  v8 = *(HWND *)(a2 + 12);
  Point.y = v4;
  ScreenToClient(v8, &Point);
  v5 = SendMessageW(*(HWND *)(a2 + 12), 0x1111u, 0, (LPARAM)&Point);
  if ( v5 && (v6 = sub_420630(a2, v5, *(_DWORD *)(a2 + 608)), *(_DWORD *)(a2 + 624)) )
    return sub_466220(a3, a4, v6);
  else
    return 0;
}

//----- (004204B0) --------------------------------------------------------
void __stdcall sub_4204B0(HWND hWnd, UINT a2, UINT_PTR a3, DWORD a4)
{
  SendMessageW(hWnd, 0x1102u, 2u, lParam);
  KillTimer(hWnd, 1u);
}

//----- (004204E0) --------------------------------------------------------
int __stdcall sub_4204E0(int a1, int a2, struct tagPOINT Point, int a4)
{
  int *v4; // edi
  int v5; // eax
  HWND v7; // [esp-10h] [ebp-40h]
  HWND v8; // [esp-10h] [ebp-40h]
  LPARAM lParam[2]; // [esp+Ch] [ebp-24h] BYREF
  char v10; // [esp+14h] [ebp-1Ch]
  LPARAM v11; // [esp+18h] [ebp-18h]
  struct tagRECT Rect; // [esp+1Ch] [ebp-14h] BYREF

  v4 = (int *)a4;
  v5 = sub_420430(&Point.x, a1, a2, *(_DWORD *)a4);
  *v4 = v5;
  (*(void (__stdcall **)(_DWORD, struct tagPOINT *, int))(**(_DWORD **)(a1 + 604) + 20))(
    *(_DWORD *)(a1 + 604),
    &Point,
    v5);
  ScreenToClient(*(HWND *)(a1 + 12), &Point);
  if ( dword_4EF568 )
  {
    GetClientRect(*(HWND *)(a1 + 12), &Rect);
    if ( Point.x >= 10 )
    {
      if ( Point.x > Rect.right - 10 )
        SendMessageW(*(HWND *)(a1 + 12), 0x114u, 1u, 0);
    }
    else
    {
      SendMessageW(*(HWND *)(a1 + 12), 0x114u, 0, 0);
    }
    if ( Point.y >= 10 )
    {
      if ( Point.y > Rect.bottom - 10 )
        SendMessageW(*(HWND *)(a1 + 12), 0x115u, 1u, 0);
    }
    else
    {
      SendMessageW(*(HWND *)(a1 + 12), 0x115u, 0, 0);
    }
  }
  lParam[0] = Point.x;
  v7 = *(HWND *)(a1 + 12);
  lParam[1] = Point.y;
  SendMessageW(v7, 0x1111u, 0, (LPARAM)lParam);
  if ( (v10 & 1) == 0 )
  {
    if ( v11 )
    {
      SendMessageW(*(HWND *)(a1 + 12), 0x110Bu, 8u, v11);
      if ( ::lParam != v11 )
      {
        v8 = *(HWND *)(a1 + 12);
        ::lParam = v11;
        SetTimer(v8, 1u, 0x320u, sub_4204B0);
      }
    }
  }
  return 0;
}
// 4EF568: using guessed type int dword_4EF568;

//----- (00420630) --------------------------------------------------------
BOOL __fastcall sub_420630(int a1, LPARAM a2, int a3)
{
  int (__stdcall *v5)(int, __int16 *, char *); // edx
  BOOL IsSameRootW; // ebx
  HDROP v7; // eax
  ITEMIDLIST *v8; // edi
  char v10[4]; // [esp+Ch] [ebp-440h] BYREF
  HGLOBAL hMem; // [esp+10h] [ebp-43Ch]
  __int16 v12; // [esp+18h] [ebp-434h] BYREF
  int v13; // [esp+1Ch] [ebp-430h]
  int v14; // [esp+20h] [ebp-42Ch]
  int v15; // [esp+24h] [ebp-428h]
  int v16; // [esp+28h] [ebp-424h]
  HDROP hDrop; // [esp+2Ch] [ebp-420h]
  WCHAR pszPath1[260]; // [esp+30h] [ebp-41Ch] BYREF
  WCHAR szFile[262]; // [esp+238h] [ebp-214h] BYREF

  v12 = 15;
  v14 = 1;
  v16 = 1;
  v5 = *(int (__stdcall **)(int, __int16 *, char *))(*(_DWORD *)a3 + 12);
  IsSameRootW = 0;
  v13 = 0;
  v15 = -1;
  if ( !v5(a3, &v12, v10) )
  {
    v7 = (HDROP)GlobalLock(hMem);
    hDrop = v7;
    if ( v7 )
    {
      if ( (int)DragQueryFileW(v7, 0xFFFFFFFF, 0, 0) > 0 )
      {
        v8 = sub_41D9D0(a2, a1);
        if ( v8 )
        {
          DragQueryFileW(hDrop, 0, szFile, 0x104u);
          sub_466630(v8, pszPath1, 0x8000);
          IsSameRootW = PathIsSameRootW(pszPath1, szFile);
          CoTaskMemFree(v8);
        }
      }
      GlobalUnlock(hMem);
    }
  }
  return IsSameRootW;
}
// 420630: using guessed type char var_440[4];

//----- (00420740) --------------------------------------------------------
int __stdcall sub_420740(int a1)
{
  HWND v2; // [esp-8h] [ebp-Ch]

  SendMessageW(*(HWND *)(a1 + 12), 0x110Bu, 8u, 0);
  v2 = *(HWND *)(a1 + 12);
  dword_4EF568 = 0;
  *(_DWORD *)(a1 + 612) = 0;
  KillTimer(v2, 1u);
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 604) + 16))(*(_DWORD *)(a1 + 604));
  return 0;
}
// 4EF568: using guessed type int dword_4EF568;

//----- (00420790) --------------------------------------------------------
int __stdcall sub_420790(int a1, int *a2, int a3, LONG a4, LONG a5, int *a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  int v8; // esi
  void (__stdcall *v9)(int, int *, LONG *, int); // ecx
  HWND v11; // [esp-8h] [ebp-248h]
  int v12; // [esp-4h] [ebp-244h]
  int *v13; // [esp+10h] [ebp-230h]
  ITEMIDLIST *pv; // [esp+14h] [ebp-22Ch]
  struct tagPOINT Point; // [esp+18h] [ebp-228h] BYREF
  char v16; // [esp+20h] [ebp-220h]
  LPARAM v17; // [esp+24h] [ebp-21Ch]
  __int16 v18[266]; // [esp+28h] [ebp-218h] BYREF

  v13 = a6;
  KillTimer(*(HWND *)(a1 + 12), 1u);
  Point.x = a4;
  v11 = *(HWND *)(a1 + 12);
  Point.y = a5;
  ScreenToClient(v11, &Point);
  SendMessageW(*(HWND *)(a1 + 12), 0x1111u, 0, (LPARAM)&Point);
  if ( (v16 & 1) == 0 && v17 && *(_DWORD *)(a1 + 624) )
  {
    pv = sub_41D9D0(v17, a1);
    sub_466630(pv, (WCHAR *)v18, 0x8000);
    v6 = operator new(0x30u);
    if ( v6 )
    {
      v6[1] = 1;
      *v6 = &CDropHandler::`vftable';
      v7 = v6;
    }
    else
    {
      v7 = 0;
    }
    sub_461A40(a3, *(_DWORD *)(a1 + 628), a2, v7, v13, *(_DWORD *)(a1 + 12), (int)v18, 0, a4, a5);
    if ( !InterlockedDecrement(v7 + 1) && v7 )
      (*(void (__thiscall **)(_DWORD *, int))*v7)(v7, 1);
    CoTaskMemFree(pv);
  }
  SendMessageW(*(HWND *)(a1 + 12), 0x110Bu, 8u, 0);
  *(_DWORD *)(a1 + 612) = 0;
  v8 = *(_DWORD *)(a1 + 604);
  v12 = *v13;
  v9 = *(void (__stdcall **)(int, int *, LONG *, int))(*(_DWORD *)v8 + 24);
  dword_4EF568 = 0;
  v9(v8, a2, &a4, v12);
  return 0;
}
// 4CC480: using guessed type void *CDropHandler::`vftable';
// 4EF568: using guessed type int dword_4EF568;
// 420790: using guessed type WCHAR var_218[266];

//----- (00420900) --------------------------------------------------------
int __stdcall sub_420900(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx

  v3 = *(_DWORD *)(a1 + 624);
  v4 = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( (a3 & 2) == 0 )
        return 262400;
      v4 = *(_DWORD *)(a1 + 624);
    }
  }
  else
  {
    if ( (a3 & 1) == 0 )
      return 262400;
    v4 = 2;
  }
  if ( a2 == 1 || (v4 & a3) != 0 )
    return 262401;
  else
    return 0;
}

//----- (00420950) --------------------------------------------------------
int __stdcall sub_420950(int a1, int a2)
{
  return 262402;
}

//----- (00420960) --------------------------------------------------------
int __stdcall sub_420960(int a1)
{
  return sub_45CDD0(a1 - 12);
}

//----- (00420970) --------------------------------------------------------
int __stdcall sub_420970(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_45CE50(a1 - 8, a2, a3);
}

//----- (00420980) --------------------------------------------------------
int __stdcall sub_420980(int a1)
{
  return sub_45CDD0(a1 - 16);
}

//----- (00420990) --------------------------------------------------------
int __stdcall sub_420990(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_45CE50(a1 - 12, a2, a3);
}

//----- (004209A0) --------------------------------------------------------
int __stdcall sub_4209A0(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_45CE50(a1 - 16, a2, a3);
}

//----- (004209B0) --------------------------------------------------------
int __stdcall sub_4209B0(int a1)
{
  return sub_45D510((void *)(a1 - 4));
}

//----- (004209C0) --------------------------------------------------------
int __stdcall sub_4209C0(int a1)
{
  return sub_45D510((void *)(a1 - 8));
}

//----- (004209D0) --------------------------------------------------------
int __stdcall sub_4209D0(int a1)
{
  return sub_45D510((void *)(a1 - 12));
}

//----- (004209E0) --------------------------------------------------------
int __stdcall sub_4209E0(int a1)
{
  return sub_45CDD0(a1 - 4);
}

//----- (004209F0) --------------------------------------------------------
int __stdcall sub_4209F0(int a1)
{
  return sub_45D510((void *)(a1 - 16));
}

//----- (00420A00) --------------------------------------------------------
int __stdcall sub_420A00(int a1)
{
  return sub_45CDD0(a1 - 8);
}

//----- (00420A10) --------------------------------------------------------
int __stdcall sub_420A10(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_45CE50(a1 - 4, a2, a3);
}

//----- (00420A20) --------------------------------------------------------
char **__userpurge sub_420A20@<eax>(char **a1@<esi>, char *a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x18u);
  if ( !result )
  {
    a2 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a2);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a3;
  *result = a2;
  result[1] = v4;
  if ( result != (char **)-8 )
  {
    result[2] = *a1;
    result[3] = a1[1];
    result[4] = a1[2];
    result[5] = a1[3];
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00420AA0) --------------------------------------------------------
_DWORD *__usercall sub_420AA0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<esi>)
{
  unsigned int v3; // ecx
  __int64 v4; // rax
  unsigned int v5; // ecx

  v3 = a1[1];
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  a2[6] = 0;
  a2[7] = 0;
  v4 = __SPAIR64__(v3, *a1) / 3600000000i64;
  v5 = a1[1];
  a2[2] = abs32(v4);
  a2[1] = abs32(__SPAIR64__(v5, *a1) / 60000000 % 60);
  *a2 = abs32(*(_QWORD *)a1 / 1000000i64 % 60);
  a2[8] = -1;
  return a2;
}

//----- (00420B30) --------------------------------------------------------
_DWORD *__thiscall sub_420B30(_DWORD *this)
{
  int v3[28]; // [esp-98h] [ebp-E8h] BYREF
  void **v4; // [esp-28h] [ebp-78h]
  void *v5; // [esp-24h] [ebp-74h] BYREF
  int v6; // [esp-20h] [ebp-70h]
  int v7; // [esp-1Ch] [ebp-6Ch]
  int v8; // [esp-18h] [ebp-68h]
  void *v9[4]; // [esp-14h] [ebp-64h] BYREF
  int v10; // [esp-4h] [ebp-54h]
  void **v11; // [esp+10h] [ebp-40h]
  _DWORD *v12; // [esp+14h] [ebp-3Ch]
  void **v13; // [esp+18h] [ebp-38h]
  int v14[2]; // [esp+1Ch] [ebp-34h] BYREF
  void *v15[5]; // [esp+24h] [ebp-2Ch] BYREF
  unsigned int v16; // [esp+38h] [ebp-18h]
  int v17; // [esp+4Ch] [ebp-4h]

  v10 = 0;
  v12 = this;
  v11 = v9;
  sub_4214B0((int *)v9);
  v17 = 1;
  v13 = &v5;
  v14[1] = (int)&v5;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v4 = &v5;
  sub_423DA0((int)v14, (int)&unk_4CC9BE, (int)&v5);
  LOBYTE(v17) = 2;
  v14[0] = (int)v3;
  sub_421860(v3);
  v17 = -1;
  sub_4212C0(
    this,
    v3[0],
    v3[1],
    v3[2],
    v3[3],
    v3[4],
    v3[5],
    v3[6],
    v3[7],
    v3[8],
    v3[9],
    v3[10],
    v3[11],
    v3[12],
    v3[13],
    v3[14],
    v3[15],
    v3[16],
    v3[17],
    v3[18],
    v3[19],
    v3[20],
    v3[21],
    v3[22],
    v3[23],
    v3[24],
    v3[25],
    v3[26],
    v3[27],
    (int)v4,
    v5,
    v6,
    v7,
    v8,
    v9[0],
    (int)v9[1],
    (int)v9[2],
    (int)v9[3],
    v10);
  v17 = 3;
  *this = &boost::date_time::time_facet<boost::posix_time::ptime,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  v16 = 7;
  v15[4] = 0;
  LOWORD(v15[0]) = 0;
  sub_4094F0(v15, (int)off_4EE024, off_4EE024, wcslen((const unsigned __int16 *)off_4EE024));
  LOBYTE(v17) = 4;
  sub_4160E0((char *)L"%O:%M:%S%F", this + 76, v15);
  if ( v16 >= 8 )
    operator delete(v15[0]);
  return this;
}
// 4CC828: using guessed type wchar_t aOMSF[11];
// 4CCA60: using guessed type void *boost::date_time::time_facet<boost::posix_time::ptime,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00420C60) --------------------------------------------------------
_DWORD *__thiscall sub_420C60(_DWORD *this)
{
  return sub_4094F0(this + 2, 0, L"%Y%m%dT%H%M%S%F%q", wcslen(L"%Y%m%dT%H%M%S%F%q"));
}
// 4CC89C: using guessed type wchar_t aYMDtHMSFQ[18];

//----- (00420C90) --------------------------------------------------------
_DWORD *__thiscall sub_420C90(_DWORD *this)
{
  return sub_4094F0(this + 2, 0, L"%Y-%m-%d %H:%M:%S%F%Q", wcslen(L"%Y-%m-%d %H:%M:%S%F%Q"));
}
// 4CC870: using guessed type wchar_t aYMDHMSFQ[22];

//----- (00420CC0) --------------------------------------------------------
_DWORD *__thiscall sub_420CC0(_DWORD *this)
{
  return sub_4094F0(this + 2, 0, L"%Y%m%d", wcslen(L"%Y%m%d"));
}
// 4CC9E0: using guessed type wchar_t aYMD[7];

//----- (00420CF0) --------------------------------------------------------
_DWORD *__thiscall sub_420CF0(_DWORD *this)
{
  return sub_4094F0(this + 2, 0, L"%Y-%m-%d", wcslen(L"%Y-%m-%d"));
}
// 4CC9F0: using guessed type wchar_t aYMD_0[9];

//----- (00420D20) --------------------------------------------------------
int *__thiscall sub_420D20(int *this, int *a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  int *result; // eax
  int v8; // [esp+8h] [ebp-8h] BYREF

  sub_421990(this + 56, &a7, &v8, a3, a4);
  result = a2;
  *a2 = a3;
  a2[1] = (int)a4;
  return result;
}

//----- (00420D60) --------------------------------------------------------
_DWORD *__thiscall sub_420D60(
        _DWORD *this,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        void *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14)
{
  unsigned __int16 *v15; // esi
  _DWORD *v16; // eax
  struct std::locale::facet *v17; // eax
  int v18; // edi
  int v19; // eax
  int v20; // esi
  void (__thiscall ***v21)(_DWORD, int); // esi
  _DWORD *v23; // [esp-1Ch] [ebp-44h]
  _DWORD **v24; // [esp-10h] [ebp-38h]
  unsigned __int16 *v25; // [esp-4h] [ebp-2Ch]
  int v26; // [esp+10h] [ebp-18h] BYREF
  _DWORD *v27; // [esp+14h] [ebp-14h]
  _DWORD **v28; // [esp+18h] [ebp-10h] BYREF
  int v29; // [esp+24h] [ebp-4h]

  v27 = (_DWORD *)a2;
  v28 = (_DWORD **)a5;
  v29 = 0;
  if ( (this[73] - this[72]) / 28 )
    sub_422640((_DWORD *)(this[72] + 28 * *(_DWORD *)(a7 + 24)), L"%A", &a8);
  if ( (this[69] - this[68]) / 28 )
    sub_422640((_DWORD *)(this[68] + 28 * *(_DWORD *)(a7 + 24)), L"%a", &a8);
  if ( (this[65] - this[64]) / 28 )
    sub_422640((_DWORD *)(this[64] + 28 * *(_DWORD *)(a7 + 16)), L"%B", &a8);
  if ( (this[61] - this[60]) / 28 )
    sub_422640((_DWORD *)(this[60] + 28 * *(_DWORD *)(a7 + 16)), L"%b", &a8);
  v15 = (unsigned __int16 *)a8;
  if ( (unsigned int)a13 < 8 )
    v15 = (unsigned __int16 *)&a8;
  v16 = sub_408A70(v28, &v26);
  LOBYTE(v29) = 1;
  v25 = &v15[a12];
  v24 = v28;
  v23 = v27;
  v17 = sub_4226A0((int)v16);
  sub_421A10(v15, (int)v17, v23, a3, (_DWORD *)a4, (int)v24, a6, a7, v25);
  LOBYTE(v29) = 0;
  v18 = v26;
  if ( v26 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v28, 0);
    v19 = *(_DWORD *)(v18 + 4);
    if ( v19 && v19 != -1 )
      *(_DWORD *)(v18 + 4) = v19 - 1;
    v20 = -(*(_DWORD *)(v18 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v28);
    v21 = (void (__thiscall ***)(_DWORD, int))(v18 & v20);
    if ( v21 )
      (**v21)(v21, 1);
  }
  if ( (unsigned int)a13 >= 8 )
    operator delete(a8);
  return v27;
}
// 4CC9C0: using guessed type wchar_t aA[3];
// 4CC9C8: using guessed type wchar_t aA_0[3];
// 4CC9D0: using guessed type wchar_t aB[3];
// 4CC9D8: using guessed type wchar_t aB_0[3];

//----- (00420F80) --------------------------------------------------------
int __stdcall sub_420F80(int a1, __int64 a2)
{
  __int64 v2; // rax
  int result; // eax
  __int64 v4; // rdi

  v2 = 1000000 * a2 / 1000000;
  if ( v2 < 0 )
  {
    v4 = -(__int64)abs64(v2);
    result = a1;
    *(_QWORD *)a1 = v4;
  }
  else
  {
    LODWORD(v2) = a1;
    *(_DWORD *)a1 = 1000000 * a2 / 1000000;
    *(_DWORD *)(a1 + 4) = HIDWORD(v2);
  }
  return result;
}

//----- (00421010) --------------------------------------------------------
void __usercall sub_421010(int a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 108) >= 8u )
    operator delete(*(void **)(a1 + 88));
  *(_DWORD *)(a1 + 108) = 7;
  *(_DWORD *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 88) = 0;
  if ( *(_DWORD *)(a1 + 80) >= 8u )
    operator delete(*(void **)(a1 + 60));
  *(_DWORD *)(a1 + 80) = 7;
  *(_DWORD *)(a1 + 76) = 0;
  *(_WORD *)(a1 + 60) = 0;
  if ( *(_DWORD *)(a1 + 52) >= 8u )
    operator delete(*(void **)(a1 + 32));
  *(_DWORD *)(a1 + 52) = 7;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 32) = 0;
  if ( *(_DWORD *)(a1 + 24) >= 8u )
    operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 7;
  *(_WORD *)(a1 + 4) = 0;
}

//----- (004210A0) --------------------------------------------------------
void *__thiscall sub_4210A0(void *this, char a2)
{
  if ( *((_DWORD *)this + 81) >= 8u )
    operator delete(*((void **)this + 76));
  *((_DWORD *)this + 81) = 7;
  *((_DWORD *)this + 80) = 0;
  *((_WORD *)this + 152) = 0;
  sub_421100((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00421100) --------------------------------------------------------
int __usercall sub_421100@<eax>(int a1@<ebx>)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 288);
  if ( v1 )
  {
    sub_4227E0(v1, *(_DWORD *)(a1 + 292));
    operator delete(*(void **)(a1 + 288));
  }
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  v2 = *(_DWORD *)(a1 + 272);
  if ( v2 )
  {
    sub_4227E0(v2, *(_DWORD *)(a1 + 276));
    operator delete(*(void **)(a1 + 272));
  }
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  v3 = *(_DWORD *)(a1 + 256);
  if ( v3 )
  {
    sub_4227E0(v3, *(_DWORD *)(a1 + 260));
    operator delete(*(void **)(a1 + 256));
  }
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  v4 = *(_DWORD *)(a1 + 240);
  if ( v4 )
  {
    sub_4227E0(v4, *(_DWORD *)(a1 + 244));
    operator delete(*(void **)(a1 + 240));
  }
  *(_DWORD *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 244) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  v5 = *(_DWORD *)(a1 + 224);
  if ( v5 )
  {
    sub_4227E0(v5, *(_DWORD *)(a1 + 228));
    operator delete(*(void **)(a1 + 224));
  }
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  v6 = *(_DWORD *)(a1 + 208);
  if ( v6 )
  {
    sub_4227E0(v6, *(_DWORD *)(a1 + 212));
    operator delete(*(void **)(a1 + 208));
  }
  *(_DWORD *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 212) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  sub_421010(a1 + 92);
  if ( *(_DWORD *)(a1 + 84) >= 8u )
    operator delete(*(void **)(a1 + 64));
  *(_DWORD *)(a1 + 84) = 7;
  *(_DWORD *)(a1 + 80) = 0;
  *(_WORD *)(a1 + 64) = 0;
  if ( *(_DWORD *)(a1 + 56) >= 8u )
    operator delete(*(void **)(a1 + 36));
  result = 0;
  *(_DWORD *)(a1 + 56) = 7;
  *(_DWORD *)(a1 + 52) = 0;
  *(_WORD *)(a1 + 36) = 0;
  if ( *(_DWORD *)(a1 + 28) >= 8u )
    operator delete(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 28) = 7;
  *(_DWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(_DWORD *)a1 = &std::locale::facet::`vftable';
  return result;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';

//----- (004212C0) --------------------------------------------------------
_DWORD *__userpurge sub_4212C0@<eax>(
        _DWORD *a1@<ebx>,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        void *a31,
        int a32,
        int a33,
        int a34,
        void *a35,
        int a36,
        int a37,
        int a38,
        int a39)
{
  a1[1] = a39;
  *a1 = &boost::date_time::date_facet<boost::gregorian::date,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  a1[7] = 7;
  a1[6] = 0;
  *((_WORD *)a1 + 4) = 0;
  sub_4094F0(a1 + 2, (int)L"Y-%b-%d %H:%M:%S%F %z", L"%Y-%b-%d %H:%M:%S%F %z", wcslen(L"%Y-%b-%d %H:%M:%S%F %z"));
  a1[14] = 7;
  a1[13] = 0;
  *((_WORD *)a1 + 18) = 0;
  sub_4094F0(a1 + 9, (int)L"b", L"%b", wcslen(L"%b"));
  a1[21] = 7;
  a1[20] = 0;
  *((_WORD *)a1 + 32) = 0;
  sub_4094F0(a1 + 16, (int)L"a", L"%a", wcslen(L"%a"));
  sub_421E60(&a2, (int)(a1 + 23));
  sub_421F70(&a35, a1 + 52);
  sub_421F70(&a31, a1 + 56);
  a1[60] = 0;
  a1[61] = 0;
  a1[62] = 0;
  a1[64] = 0;
  a1[65] = 0;
  a1[66] = 0;
  a1[68] = 0;
  a1[69] = 0;
  a1[70] = 0;
  a1[72] = 0;
  a1[73] = 0;
  a1[74] = 0;
  sub_421010((int)&a2);
  if ( a31 )
  {
    sub_4227E0((int)a31, a32);
    operator delete(a31);
  }
  a31 = 0;
  a32 = 0;
  a33 = 0;
  if ( a35 )
  {
    sub_4227E0((int)a35, a36);
    operator delete(a35);
  }
  return a1;
}
// 4CC840: using guessed type wchar_t aYBDHMSFZ[23];
// 4CC9C8: using guessed type wchar_t aA_0[3];
// 4CC9D8: using guessed type wchar_t aB_0[3];
// 4CCA48: using guessed type void *boost::date_time::date_facet<boost::gregorian::date,wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (004214B0) --------------------------------------------------------
int *__thiscall sub_4214B0(int *this)
{
  void *Src[4]; // [esp+14h] [ebp-2Ch] BYREF
  int v4; // [esp+24h] [ebp-1Ch]
  unsigned int v5; // [esp+28h] [ebp-18h]
  int v6; // [esp+3Ch] [ebp-4h]

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  v6 = 0;
  sub_422130(this, 9u);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"irst", L"first", wcslen(L"first"));
  LOBYTE(v6) = 1;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"econd", L"second", wcslen(L"second"));
  LOBYTE(v6) = 2;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  v5 = 7;
  v4 = 0;
  LOWORD(Src[0]) = 0;
  sub_4094F0(Src, (int)L"hird", L"third", wcslen(L"third"));
  LOBYTE(v6) = 3;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"ourth", L"fourth", wcslen(L"fourth"));
  LOBYTE(v6) = 4;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"ifth", L"fifth", wcslen(L"fifth"));
  LOBYTE(v6) = 5;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  v5 = 7;
  v4 = 0;
  LOWORD(Src[0]) = 0;
  sub_4094F0(Src, (int)L"ast", L"last", wcslen(L"last"));
  LOBYTE(v6) = 6;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"efore", L"before", wcslen(L"before"));
  LOBYTE(v6) = 7;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v5 = 7;
  v4 = 0;
  sub_4094F0(Src, (int)L"fter", L"after", wcslen(L"after"));
  LOBYTE(v6) = 8;
  sub_422050(Src, this);
  LOBYTE(v6) = 0;
  if ( v5 >= 8 )
    operator delete(Src[0]);
  v5 = 7;
  v4 = 0;
  LOWORD(Src[0]) = 0;
  sub_4094F0(Src, (int)L"f", L"of", wcslen(L"of"));
  LOBYTE(v6) = 9;
  sub_422050(Src, this);
  if ( v5 >= 8 )
    operator delete(Src[0]);
  return this;
}
// 4CC8D0: using guessed type wchar_t aFirst[6];
// 4CC8DC: using guessed type wchar_t aSecond[7];
// 4CC8EC: using guessed type wchar_t aThird[6];
// 4CC8F8: using guessed type wchar_t aFourth[7];
// 4CC908: using guessed type wchar_t aFifth[6];
// 4CC914: using guessed type wchar_t aLast[5];
// 4CC920: using guessed type wchar_t aBefore[7];
// 4CC930: using guessed type wchar_t aAfter[6];
// 4CC93C: using guessed type wchar_t aOf[3];

//----- (00421830) --------------------------------------------------------
void __usercall sub_421830(int *a1@<esi>)
{
  if ( *a1 )
  {
    sub_4227E0(*a1, a1[1]);
    operator delete((void *)*a1);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

//----- (00421860) --------------------------------------------------------
_DWORD *__stdcall sub_421860(_DWORD *a1)
{
  *a1 = 1;
  a1[6] = 7;
  a1[5] = 0;
  *((_WORD *)a1 + 2) = 0;
  sub_4094F0(a1 + 1, 0, L"/", wcslen(L"/"));
  a1[13] = 7;
  a1[12] = 0;
  *((_WORD *)a1 + 16) = 0;
  sub_4094F0(a1 + 8, (unsigned __int16)L"", L"[", wcslen(L"["));
  a1[20] = 7;
  a1[19] = 0;
  *((_WORD *)a1 + 30) = 0;
  sub_4094F0(a1 + 15, (unsigned __int16)L"", L")", wcslen(L")"));
  a1[27] = 7;
  a1[26] = 0;
  *((_WORD *)a1 + 44) = 0;
  sub_4094F0(a1 + 22, 0, L"]", wcslen(L"]"));
  return a1;
}
// 4CC944: using guessed type wchar_t asc_4CC944[2];
// 4CC948: using guessed type wchar_t asc_4CC948[2];
// 4CC94C: using guessed type wchar_t asc_4CC94C[2];
// 4CC950: using guessed type wchar_t asc_4CC950[2];

//----- (00421990) --------------------------------------------------------
int *__userpurge sub_421990@<eax>(int *a1@<eax>, int *a2@<ecx>, int *a3@<edi>, int a4, _DWORD *a5)
{
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  unsigned __int16 *v9; // ebx
  int v11; // [esp+8h] [ebp-8h] BYREF

  v5 = *a1;
  v6 = *a2;
  if ( *a2 < (unsigned int)((a1[1] - *a1) / 28) )
  {
    v7 = v5 + 28 * v6;
    if ( *(_DWORD *)(v7 + 20) < 8u )
      v8 = v5 + 28 * v6;
    else
      v8 = *(_DWORD *)v7;
    v9 = (unsigned __int16 *)(v8 + 2 * *(_DWORD *)(v7 + 16));
    if ( *(_DWORD *)(v7 + 20) >= 8u )
      v7 = *(_DWORD *)v7;
    sub_423E70((unsigned __int16 *)v7, v9, &v11, a4, a5);
  }
  a3[1] = (int)a5;
  *a3 = a4;
  return a3;
}

//----- (00421A10) --------------------------------------------------------
_DWORD *__userpurge sub_421A10@<eax>(
        unsigned __int16 *a1@<eax>,
        int a2,
        _DWORD *a3,
        int a4,
        _DWORD *a5,
        int a6,
        int a7,
        int a8,
        unsigned __int16 *a9)
{
  const _Cvtvec *v10; // edi
  unsigned __int16 *v11; // ebx
  _DWORD *v12; // ecx
  wchar_t v13; // dx
  unsigned __int16 v14; // dx
  int *v15; // ebx
  _WORD **v16; // eax
  unsigned __int16 *v17; // ecx
  unsigned __int16 v18; // ax
  char v19; // bl
  int *v20; // eax
  _DWORD *result; // eax
  int *v22; // esi
  _WORD **v23; // eax
  wchar_t *v24; // ecx
  wchar_t v25; // ax
  _DWORD *v26; // ecx
  unsigned __int16 v27; // [esp-Ch] [ebp-34h]
  unsigned __int16 v28; // [esp-Ch] [ebp-34h]
  char v29[4]; // [esp+Ch] [ebp-1Ch] BYREF
  wchar_t v30[2]; // [esp+10h] [ebp-18h] BYREF
  int v31; // [esp+14h] [ebp-14h]
  mbstate_t v32; // [esp+18h] [ebp-10h] BYREF
  int v33; // [esp+20h] [ebp-8h] BYREF

  *(_DWORD *)v30 = 0;
  v32._Wchar = 0;
  v10 = (const _Cvtvec *)(a2 + 12);
  v29[0] = 37;
  _Mbrtowc(v30, v29, 1u, &v32, (const _Cvtvec *)(a2 + 12));
  v11 = a9;
  if ( a1 == a9 )
    goto LABEL_30;
  v12 = a5;
  while ( 1 )
  {
    v13 = v30[0];
    if ( *a1 != v30[0] )
    {
      if ( !v12 )
        goto LABEL_10;
      v14 = *a1;
      if ( *(_DWORD *)v12[9] && (v15 = (int *)v12[13], *v15 > 0) )
      {
        --*v15;
        v16 = (_WORD **)v12[9];
        v17 = (*v16)++;
        *v17 = v14;
        v18 = v14;
      }
      else
      {
        v18 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v12 + 12))(v12, *a1);
      }
      v12 = a5;
      if ( v18 == 0xFFFF )
LABEL_10:
        LOBYTE(a4) = 1;
      goto LABEL_19;
    }
    if ( ++a1 == v11 )
    {
      if ( v12 )
      {
        if ( *(_DWORD *)v12[9] && (v22 = (int *)v12[13], *v22 > 0) )
        {
          --*v22;
          v23 = (_WORD **)v12[9];
          v24 = (*v23)++;
          *v24 = v13;
          v25 = v13;
        }
        else
        {
          v25 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v12 + 12))(v12, *(_DWORD *)v30);
        }
        if ( v25 != 0xFFFF )
          goto LABEL_30;
        v12 = a5;
      }
      result = a3;
      LOBYTE(a4) = 1;
      *a3 = a4;
      a3[1] = v12;
      return result;
    }
    v27 = *a1;
    v29[0] = 0;
    *(_DWORD *)&v32._Byte = 0;
    _Wcrtomb(v29, v27, (mbstate_t *)&v32._Byte, v10);
    v19 = v29[0];
    LOBYTE(v32._Wchar) = v29[0];
    LOBYTE(v31) = 0;
    if ( v29[0] == 69 || v29[0] == 79 || v29[0] == 81 || v29[0] == 35 )
      break;
LABEL_18:
    v20 = (int *)(*(int (__thiscall **)(int, int *, int, _DWORD *, int, int, int, unsigned int, int))(*(_DWORD *)a2 + 4))(
                   a2,
                   &v33,
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   v32._Wchar,
                   v31);
    a4 = *v20;
    v12 = (_DWORD *)v20[1];
    a5 = v12;
LABEL_19:
    v11 = a9;
    if ( ++a1 == a9 )
    {
      result = a3;
      *a3 = a4;
      a3[1] = v12;
      return result;
    }
  }
  if ( ++a1 != a9 )
  {
    v28 = *a1;
    LOBYTE(v31) = v29[0];
    v29[0] = 0;
    *(_DWORD *)&v32._Byte = 0;
    _Wcrtomb(v29, v28, (mbstate_t *)&v32._Byte, v10);
    LOBYTE(v32._Wchar) = v29[0];
    goto LABEL_18;
  }
  sub_40DE80(&a4, *(int *)v30);
  sub_40DE80(&a4, (unsigned __int16)v19);
LABEL_30:
  result = a3;
  v26 = a5;
  *a3 = a4;
  a3[1] = v26;
  return result;
}
// 421A10: using guessed type char var_1C[4];

//----- (00421C40) --------------------------------------------------------
int __thiscall sub_421C40(
        const char *this,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        struct tm *Timeptr,
        char a8,
        char a9)
{
  char v9; // al
  size_t i; // edi
  char *v11; // ecx
  size_t v12; // esi
  char **v13; // eax
  size_t v14; // esi
  const char *v15; // ebx
  int v16; // eax
  int v17; // ecx
  wchar_t v18; // dx
  int *v19; // ebx
  _WORD **v20; // eax
  wchar_t *v21; // ecx
  wchar_t v22; // ax
  bool v23; // cf
  int v24; // esi
  wchar_t v26[2]; // [esp+10h] [ebp-48h] BYREF
  _Cvtvec *v27; // [esp+14h] [ebp-44h]
  mbstate_t v28; // [esp+18h] [ebp-40h] BYREF
  const char *v29; // [esp+20h] [ebp-38h]
  char *Buffer[4]; // [esp+24h] [ebp-34h] BYREF
  size_t Max_size; // [esp+34h] [ebp-24h]
  unsigned int v32; // [esp+38h] [ebp-20h]
  char Format[4]; // [esp+40h] [ebp-18h] BYREF
  char v34; // [esp+44h] [ebp-14h]
  int v35; // [esp+54h] [ebp-4h]

  v29 = this;
  *(_DWORD *)&v28._Byte = a2;
  strcpy(Format, "!%x");
  v34 = 0;
  v32 = 15;
  Max_size = 0;
  LOBYTE(Buffer[0]) = 0;
  v35 = 0;
  v9 = a9;
  if ( a9 )
    Format[3] = a8;
  else
    v9 = a8;
  Format[2] = v9;
  for ( i = 16; ; i *= 2 )
  {
    sub_405360(Buffer, i, 0);
    v11 = Buffer[0];
    if ( v32 < 0x10 )
      v11 = (char *)Buffer;
    v12 = _Strftime(v11, Max_size, Format, Timeptr, *((void **)v29 + 2));
    if ( v12 )
      break;
  }
  v13 = (char **)Buffer[0];
  v14 = v12 - 1;
  v28._Wchar = 0;
  if ( v32 < 0x10 )
    v13 = Buffer;
  v15 = (char *)v13 + 1;
  if ( v14 )
  {
    v27 = (_Cvtvec *)(v29 + 12);
    while ( 2 )
    {
      v16 = _Mbrtowc(v26, v15, v14, &v28, v27);
      switch ( v16 )
      {
        case -3:
          v16 = 0;
          goto LABEL_17;
        case -2:
        case -1:
          v23 = v32 < 0x10;
          v24 = *(_DWORD *)&v28._Byte;
          **(_DWORD **)&v28._Byte = a3;
          *(_DWORD *)(v24 + 4) = a4;
          if ( !v23 )
            goto LABEL_30;
          return v24;
        case 0:
          if ( !v26[0] )
            v16 = strlen(v15) + 1;
          goto LABEL_17;
        default:
LABEL_17:
          v17 = a4;
          v15 += v16;
          v14 -= v16;
          v29 = v15;
          if ( !a4 )
            goto LABEL_23;
          v18 = v26[0];
          if ( **(_DWORD **)(a4 + 36) && (v19 = *(int **)(a4 + 52), *v19 > 0) )
          {
            --*v19;
            v20 = *(_WORD ***)(a4 + 36);
            v21 = (*v20)++;
            *v21 = v18;
            v22 = v18;
          }
          else
          {
            v22 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)a4 + 12))(*(_DWORD *)v26);
          }
          v15 = v29;
          v17 = a4;
          if ( v22 == 0xFFFF )
LABEL_23:
            LOBYTE(a3) = 1;
          if ( !v14 )
            goto LABEL_29;
          continue;
      }
    }
  }
  v17 = a4;
LABEL_29:
  v23 = v32 < 0x10;
  v24 = *(_DWORD *)&v28._Byte;
  **(_DWORD **)&v28._Byte = a3;
  *(_DWORD *)(v24 + 4) = v17;
  if ( !v23 )
LABEL_30:
    operator delete(Buffer[0]);
  return v24;
}

//----- (00421E30) --------------------------------------------------------
void *__thiscall sub_421E30(void *this, char a2)
{
  sub_421100((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00421E60) --------------------------------------------------------
int __thiscall sub_421E60(_DWORD *this, int a2)
{
  *(_DWORD *)a2 = *this;
  *(_DWORD *)(a2 + 24) = 7;
  *(_DWORD *)(a2 + 20) = 0;
  *(_WORD *)(a2 + 4) = 0;
  sub_4090E0(a2 + 4, this + 1, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 52) = 7;
  *(_DWORD *)(a2 + 48) = 0;
  *(_WORD *)(a2 + 32) = 0;
  sub_4090E0(a2 + 32, this + 8, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 80) = 7;
  *(_DWORD *)(a2 + 76) = 0;
  *(_WORD *)(a2 + 60) = 0;
  sub_4090E0(a2 + 60, this + 15, 0, 0xFFFFFFFF);
  *(_DWORD *)(a2 + 108) = 7;
  *(_DWORD *)(a2 + 104) = 0;
  *(_WORD *)(a2 + 88) = 0;
  sub_4090E0(a2 + 88, this + 22, 0, 0xFFFFFFFF);
  return a2;
}

//----- (00421F30) --------------------------------------------------------
void *__thiscall sub_421F30(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 2);
  *(_DWORD *)this = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  free(v4);
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDDE8: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00421F70) --------------------------------------------------------
_DWORD *__thiscall sub_421F70(_DWORD *this, _DWORD *a2)
{
  int v3; // ecx
  unsigned int v4; // edi
  char *v5; // eax
  _DWORD v7[8]; // [esp+0h] [ebp-20h] BYREF

  v7[4] = v7;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = this[1] - *this;
  v4 = v3 / 28;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if ( v3 / 28 )
  {
    if ( v4 > 0x9249249 )
      std::_Xlength_error("vector<T> too long");
    v5 = (char *)sub_416ED0(v3 / 28);
    a2[2] = &v5[28 * v4];
    v7[7] = 0;
    *a2 = v5;
    a2[1] = v5;
    a2[1] = sub_423EE0((_DWORD *)*this, (_DWORD *)this[1], (int)v5);
  }
  return a2;
}

//----- (00422050) --------------------------------------------------------
void __usercall sub_422050(void *Src@<ecx>, int *a2@<edi>)
{
  unsigned int v3; // ecx
  int v4; // esi
  void *v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // ecx

  v3 = a2[1];
  if ( (unsigned int)Src >= v3 || *a2 > (unsigned int)Src )
  {
    if ( v3 == a2[2] )
      sub_422240(a2);
    v7 = (_DWORD *)a2[1];
    if ( v7 )
    {
      v7[5] = 7;
      v7[4] = 0;
      *(_WORD *)v7 = 0;
      sub_40AF70(v7, Src);
    }
  }
  else
  {
    v4 = ((int)Src - *a2) / 28;
    if ( v3 == a2[2] )
      sub_422240(a2);
    v5 = (void *)(*a2 + 28 * v4);
    v6 = (_DWORD *)a2[1];
    if ( v6 )
    {
      v6[5] = 7;
      v6[4] = 0;
      *(_WORD *)v6 = 0;
      sub_40AF70(v6, v5);
    }
  }
  a2[1] += 28;
}

//----- (00422130) --------------------------------------------------------
unsigned int __thiscall sub_422130(int *this, unsigned int a2)
{
  unsigned int result; // eax
  void *v4; // eax
  int v5; // ebx
  int v6; // [esp-Ch] [ebp-30h]
  int v7; // [esp+0h] [ebp-24h] BYREF
  void *v8; // [esp+10h] [ebp-14h]
  int *v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+20h] [ebp-4h]

  v9 = &v7;
  if ( a2 > 0x9249249 )
    std::_Xlength_error("vector<T> too long");
  result = (this[2] - *this) / 28;
  if ( result < a2 )
  {
    v4 = sub_416ED0(a2);
    v10 = 0;
    v6 = this[1];
    v8 = v4;
    sub_423F90(v6, v4);
    v5 = (this[1] - *this) / 28;
    if ( *this )
    {
      sub_4227E0(*this, this[1]);
      operator delete((void *)*this);
    }
    result = (unsigned int)v8;
    this[2] = (int)v8 + 28 * a2;
    this[1] = result + 28 * v5;
    *this = result;
  }
  return result;
}

//----- (00422240) --------------------------------------------------------
unsigned int __thiscall sub_422240(int *this)
{
  unsigned int v1; // esi
  unsigned int result; // eax
  unsigned int v3; // eax

  if ( (unsigned int)((this[1] - *this) / 28) > 0x9249248 )
    std::_Xlength_error("vector<T> too long");
  v1 = (this[1] - *this) / 28 + 1;
  result = (this[2] - *this) / 28;
  if ( v1 > result )
  {
    if ( 153391689 - (result >> 1) >= result )
      v3 = (result >> 1) + result;
    else
      v3 = 0;
    if ( v3 < v1 )
      v3 = (this[1] - *this) / 28 + 1;
    return sub_422130(this, v3);
  }
  return result;
}

//----- (004222C0) --------------------------------------------------------
BOOL __cdecl sub_4222C0(int a1, int a2)
{
  return !a1 && a2 == 0x80000000;
}

//----- (004222E0) --------------------------------------------------------
struct std::locale::_Locimp **__userpurge sub_4222E0@<eax>(
        struct std::locale::facet *a1@<ebx>,
        struct std::locale::_Locimp **a2@<esi>,
        int *a3)
{
  struct std::locale::_Locimp *v3; // eax
  struct std::locale::_Locimp *v4; // eax

  v3 = (struct std::locale::_Locimp *)operator new(0x20u);
  if ( v3 )
    v4 = sub_425FE0(*a3, v3);
  else
    v4 = 0;
  *a2 = v4;
  if ( a1 )
  {
    if ( !dword_4F24A8 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&a3, 0);
      if ( !dword_4F24A8 )
        dword_4F24A8 = ++dword_4EE108;
      std::_Lockit::~_Lockit((std::_Lockit *)&a3);
    }
    std::locale::_Locimp::_Locimp_Addfac(*a2, a1, dword_4F24A8);
  }
  return a2;
}
// 4EE108: using guessed type int dword_4EE108;

//----- (004223A0) --------------------------------------------------------
int *__usercall sub_4223A0@<eax>(int *a1@<edi>, int *a2)
{
  char *v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int *v6; // eax
  char v7; // al
  unsigned int v8; // ebx
  int v9; // eax
  int v10; // esi
  void (__thiscall ***v11)(_DWORD, int); // esi
  _DWORD **v12; // esi
  int *v13; // eax
  _DWORD *v14; // eax
  unsigned int v15; // ebx
  int v16; // eax
  void **v17; // ecx
  _DWORD *v18; // eax
  int *v19; // eax
  int v20; // ebx
  int v21; // eax
  int v22; // esi
  void (__thiscall ***v23)(_DWORD, int); // esi
  int v24; // ebx
  int v25; // eax
  int v26; // esi
  void (__thiscall ***v27)(_DWORD, int); // esi
  int v28; // eax
  int v29; // esi
  void (__thiscall ***v30)(_DWORD, int); // esi
  int v32; // [esp-10h] [ebp-5Ch]
  unsigned __int16 v33; // [esp+10h] [ebp-3Ch]
  int v34; // [esp+14h] [ebp-38h] BYREF
  int v35; // [esp+18h] [ebp-34h]
  char v36[4]; // [esp+1Ch] [ebp-30h] BYREF
  void *v37; // [esp+20h] [ebp-2Ch] BYREF
  int v38; // [esp+24h] [ebp-28h] BYREF
  int v39; // [esp+28h] [ebp-24h] BYREF
  struct std::locale::_Locimp *v40; // [esp+2Ch] [ebp-20h] BYREF
  char *v41; // [esp+30h] [ebp-1Ch]
  void *v42; // [esp+34h] [ebp-18h] BYREF
  char v43; // [esp+3Bh] [ebp-11h]
  int v44; // [esp+48h] [ebp-4h]

  if ( a1 )
    v2 = (char *)a1 + *(_DWORD *)(*a1 + 4);
  else
    v2 = 0;
  v3 = *((_DWORD *)v2 + 5);
  v41 = v2;
  v33 = v3;
  v44 = 0;
  v4 = *a1;
  v35 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  v5 = *(_DWORD *)(v4 + 4);
  LOBYTE(v34) = 0;
  v6 = sub_408A70((_DWORD **)((char *)a1 + v5), &v40);
  v7 = sub_4236C0(v6);
  v8 = (unsigned int)v40;
  v43 = v7;
  if ( v40 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v42, 0);
    v9 = *(_DWORD *)(v8 + 4);
    if ( v9 && v9 != -1 )
      *(_DWORD *)(v8 + 4) = v9 - 1;
    v10 = -(*(_DWORD *)(v8 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v42);
    v11 = (void (__thiscall ***)(_DWORD, int))(v8 & v10);
    if ( v11 )
      (**v11)(v11, 1);
  }
  if ( v43 )
  {
    v12 = (_DWORD **)((char *)a1 + *(_DWORD *)(*a1 + 4));
    v13 = sub_408A70(v12, &v40);
    LOBYTE(v44) = 1;
    v32 = *(unsigned __int16 *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 64);
    v14 = (_DWORD *)sub_423770(v13);
    sub_422AA0(v14, (int)v36, v12, v32, a2, v34, v35);
    LOBYTE(v44) = 0;
    v15 = (unsigned int)v40;
    if ( !v40 )
      goto LABEL_38;
    std::_Lockit::_Lockit((std::_Lockit *)&v42, 0);
    v16 = *(_DWORD *)(v15 + 4);
    if ( v16 && v16 != -1 )
      *(_DWORD *)(v15 + 4) = v16 - 1;
    v17 = &v42;
    goto LABEL_36;
  }
  v18 = operator new(0x14Cu);
  v37 = v18;
  LOBYTE(v44) = 2;
  if ( v18 )
    v42 = sub_420B30(v18);
  else
    v42 = 0;
  v19 = sub_408A70((_DWORD **)((char *)a1 + *(_DWORD *)(*a1 + 4)), &v39);
  LOBYTE(v44) = 3;
  sub_4222E0((struct std::locale::facet *)v42, &v40, v19);
  LOBYTE(v44) = 5;
  v20 = v39;
  if ( v39 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v38, 0);
    v21 = *(_DWORD *)(v20 + 4);
    if ( v21 && v21 != -1 )
      *(_DWORD *)(v20 + 4) = v21 - 1;
    v22 = -(*(_DWORD *)(v20 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v38);
    v23 = (void (__thiscall ***)(_DWORD, int))(v20 & v22);
    if ( v23 )
      (**v23)(v23, 1);
  }
  sub_418E70((int *)&v40, (int)a1 + *(_DWORD *)(*a1 + 4), &v38);
  v24 = v38;
  if ( v38 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v37, 0);
    v25 = *(_DWORD *)(v24 + 4);
    if ( v25 && v25 != -1 )
      *(_DWORD *)(v24 + 4) = v25 - 1;
    v26 = -(*(_DWORD *)(v24 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v37);
    v27 = (void (__thiscall ***)(_DWORD, int))(v24 & v26);
    if ( v27 )
      (**v27)(v27, 1);
  }
  sub_422AA0(
    v42,
    (int)&v34,
    (_DWORD **)((char *)a1 + *(_DWORD *)(*a1 + 4)),
    *(unsigned __int16 *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 64),
    a2,
    v34,
    v35);
  LOBYTE(v44) = 0;
  v15 = (unsigned int)v40;
  if ( v40 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v37, 0);
    v28 = *(_DWORD *)(v15 + 4);
    if ( v28 && v28 != -1 )
      *(_DWORD *)(v15 + 4) = v28 - 1;
    v17 = &v37;
LABEL_36:
    v29 = -(*(_DWORD *)(v15 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v17);
    v30 = (void (__thiscall ***)(_DWORD, int))(v15 & v29);
    if ( v30 )
      (**v30)(v30, 1);
  }
LABEL_38:
  *((_DWORD *)v41 + 5) = v33;
  return a1;
}
// 4223A0: using guessed type struct std::locale::facet *var_18;
// 4223A0: using guessed type char var_30[4];

//----- (00422640) --------------------------------------------------------
void __usercall sub_422640(_DWORD *a1@<eax>, const unsigned __int16 *a2@<ebx>, _DWORD *a3)
{
  int *v3; // eax
  _DWORD v4[3]; // [esp+Ch] [ebp-Ch] BYREF

  v3 = sub_423CB0(v4, a1);
  sub_423870(a3, (int)a2, (int)&a2[wcslen(a2)], v4[2], *v3, v3[1]);
}

//----- (004226A0) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_4226A0(int a1)
{
  int v1; // ebx
  int v2; // edi
  unsigned int v3; // esi
  int v4; // eax
  struct std::locale::facet *v5; // ecx
  int v6; // eax
  struct std::locale::facet *v7; // esi
  int v8; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v11[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::locale::facet *v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
  v14 = 0;
  v1 = dword_4EF820;
  v13 = (struct std::locale::facet *)dword_4EF820;
  if ( !dword_4F24A4 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4F24A4 )
      dword_4F24A4 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
  }
  v2 = a1;
  v3 = dword_4F24A4;
  v4 = *(_DWORD *)a1;
  if ( (unsigned int)dword_4F24A4 >= *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v5 = 0;
  }
  else
  {
    v5 = *(struct std::locale::facet **)(*(_DWORD *)(v4 + 8) + 4 * dword_4F24A4);
    if ( v5 )
    {
LABEL_11:
      v7 = v5;
LABEL_12:
      if ( v7 )
        goto LABEL_20;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v4 + 20) )
    goto LABEL_11;
  v6 = sub_426E4C();
  if ( v3 < *(_DWORD *)(v6 + 12) )
  {
    v7 = *(struct std::locale::facet **)(*(_DWORD *)(v6 + 8) + 4 * v3);
    goto LABEL_12;
  }
LABEL_13:
  if ( v1 )
  {
    v7 = (struct std::locale::facet *)v1;
  }
  else
  {
    if ( sub_4231F0(&v13, v2) == -1 )
    {
      sub_4398E3((std::exception *)pExceptionObject, "bad cast");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v7 = v13;
    dword_4EF820 = (int)v13;
    std::_Lockit::_Lockit((std::_Lockit *)&a1, 0);
    v8 = *((_DWORD *)v7 + 1);
    if ( v8 != -1 )
      *((_DWORD *)v7 + 1) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&a1);
    std::locale::facet::_Facet_Register(v7);
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v11);
  return v7;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF820: using guessed type int dword_4EF820;
// 4F24A4: using guessed type int dword_4F24A4;
// 4226A0: using guessed type char var_18[4];
// 4226A0: using guessed type char var_14[4];

//----- (004227E0) --------------------------------------------------------
void __usercall sub_4227E0(int a1@<eax>, int a2@<edi>)
{
  int i; // esi

  for ( i = a1; i != a2; i += 28 )
  {
    if ( *(_DWORD *)(i + 20) >= 8u )
      operator delete(*(void **)i);
    *(_DWORD *)(i + 20) = 7;
    *(_DWORD *)(i + 16) = 0;
    *(_WORD *)i = 0;
  }
}

//----- (00422820) --------------------------------------------------------
void __thiscall sub_422820(_DWORD *this)
{
  struct std::ios_base *v1; // [esp+Ch] [ebp-10h]

  v1 = (struct std::ios_base *)(this + 20);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 80) = &std::wostringstream::`vftable';
  this[1] = &std::wstringbuf::`vftable';
  sub_4027E0((int)(this + 1));
  sub_408180((_DWORD *)v1 - 19);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 20) + 4) - 80) = &std::wostream::`vftable';
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';
// 4CCA38: using guessed type void *std::wostringstream::`vftable';

//----- (004228B0) --------------------------------------------------------
int *__stdcall sub_4228B0(int *a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  struct std::locale::facet *v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  void (__thiscall ***v13)(_DWORD, int); // esi
  int v14; // ecx
  int v15; // edx
  int v16; // esi
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v22; // [esp-Ch] [ebp-50h]
  _DWORD v23[6]; // [esp+0h] [ebp-44h] BYREF
  bool v24; // [esp+18h] [ebp-2Ch]
  int v25; // [esp+1Ch] [ebp-28h]
  char v26[4]; // [esp+20h] [ebp-24h] BYREF
  int v27; // [esp+24h] [ebp-20h] BYREF
  int v28; // [esp+28h] [ebp-1Ch]
  struct std::locale::facet *v29; // [esp+2Ch] [ebp-18h]
  _DWORD *v30; // [esp+34h] [ebp-10h]
  int v31; // [esp+40h] [ebp-4h]

  v30 = v23;
  v3 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  v4 = 0;
  v28 = 0;
  v23[5] = a1;
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v31 = 0;
  v5 = *(_DWORD *)(*a1 + 4);
  if ( !*(int *)((char *)a1 + v5 + 12) )
  {
    v6 = *(int *)((char *)a1 + v5 + 60);
    if ( v6 )
      sub_408280(v6);
  }
  v7 = *a1;
  v24 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 12) == 0;
  v31 = 1;
  if ( v24 )
  {
    v8 = sub_408A70((_DWORD **)((char *)a1 + *(_DWORD *)(v7 + 4)), &v27);
    LOBYTE(v31) = 2;
    v9 = sub_40E010((int)v8);
    LOBYTE(v31) = 1;
    v10 = v27;
    v29 = v9;
    if ( v27 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v26, 0);
      v11 = *(_DWORD *)(v10 + 4);
      if ( v11 && v11 != -1 )
        *(_DWORD *)(v10 + 4) = v11 - 1;
      v12 = -(*(_DWORD *)(v10 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)v26);
      v13 = (void (__thiscall ***)(_DWORD, int))(v10 & v12);
      if ( v13 )
        (**v13)(v13, 1);
    }
    LOBYTE(v31) = 3;
    v14 = *(_DWORD *)(*a1 + 4);
    v15 = *(int *)((char *)a1 + v14 + 56);
    v16 = *(_DWORD *)v29;
    v22 = *(unsigned __int16 *)((char *)a1 + v14 + 64);
    LOBYTE(v25) = 0;
    (*(void (__thiscall **)(struct std::locale::facet *, int *, int, int, char *, int, int, int))(v16 + 20))(
      v29,
      &a2,
      v25,
      v15,
      (char *)a1 + v14,
      v22,
      a2,
      a3);
    v4 = 4;
    if ( !(_BYTE)a2 )
      v4 = v28;
    v31 = 1;
  }
  v17 = (int *)((char *)a1 + *(_DWORD *)(*a1 + 4));
  if ( v4 )
  {
    v18 = v4 | v17[3];
    if ( !v17[14] )
      LOBYTE(v18) = v18 | 4;
    v19 = v18 & 0x17;
    v17[3] = v19;
    if ( (v19 & v17[4]) != 0 )
      sub_408D30(0);
  }
  v31 = 5;
  if ( !__uncaught_exception() )
    sub_4134F0(a1);
  v31 = -1;
  v20 = *(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56);
  if ( v20 )
    (*(void (**)(void))(*(_DWORD *)v20 + 8))();
  return a1;
}
// 4228B0: using guessed type char var_24[4];

//----- (00422AA0) --------------------------------------------------------
int __fastcall sub_422AA0(_DWORD *a1, int a2, _DWORD **a3, int a4, int *a5, int a6, int a7)
{
  int v7; // eax
  int v9; // edx
  int v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  struct std::locale::facet *v15; // eax
  unsigned __int16 v16; // si
  int v17; // kr14_4
  int v18; // edx
  int v19; // edx
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  struct std::locale::facet *v23; // eax
  unsigned __int16 v24; // si
  int v25; // edx
  _DWORD v27[4]; // [esp-1Ch] [ebp-108h] BYREF
  int v28; // [esp-Ch] [ebp-F8h]
  int v29; // [esp-8h] [ebp-F4h]
  int v30; // [esp-4h] [ebp-F0h]
  _DWORD *v31; // [esp+14h] [ebp-D8h]
  int v32; // [esp+18h] [ebp-D4h]
  _DWORD **v33; // [esp+1Ch] [ebp-D0h]
  unsigned int v34[2]; // [esp+20h] [ebp-CCh] BYREF
  int v35[2]; // [esp+28h] [ebp-C4h] BYREF
  int *v36; // [esp+30h] [ebp-BCh]
  void *v37[9]; // [esp+34h] [ebp-B8h] BYREF
  void *v38[4]; // [esp+58h] [ebp-94h] BYREF
  int v39; // [esp+68h] [ebp-84h]
  unsigned int v40; // [esp+6Ch] [ebp-80h]
  void *v41[4]; // [esp+74h] [ebp-78h] BYREF
  int v42; // [esp+84h] [ebp-68h]
  unsigned int v43; // [esp+88h] [ebp-64h]
  int v44; // [esp+90h] [ebp-5Ch] BYREF
  void *v45[4]; // [esp+98h] [ebp-54h] BYREF
  int v46; // [esp+A8h] [ebp-44h]
  unsigned int v47; // [esp+ACh] [ebp-40h]
  void *v48[5]; // [esp+BCh] [ebp-30h] BYREF
  unsigned int v49; // [esp+D0h] [ebp-1Ch]
  int v50; // [esp+E8h] [ebp-4h]

  v7 = *a5;
  v9 = a5[1];
  v31 = a1;
  v32 = a2;
  v33 = a3;
  v36 = a5;
  if ( !v7 && v9 == 0x80000000 || v7 == -1 && v9 == 0x7FFFFFFF || v7 == -2 && v9 == 0x7FFFFFFF )
  {
    if ( v7 == -2 && v9 == 0x7FFFFFFF )
    {
      v10 = 0;
    }
    else if ( v7 || v9 != 0x80000000 )
    {
      if ( v7 != -1 || (v10 = 2, v9 != 0x7FFFFFFF) )
        v10 = 5;
    }
    else
    {
      v10 = 1;
    }
    (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD **, int, int))(*a1 + 12))(a1, a2, a6, a7, a3, a4, v10);
  }
  else
  {
    v49 = 7;
    v48[4] = 0;
    LOWORD(v48[0]) = 0;
    sub_4090E0((int)v48, a1 + 76, 0, 0xFFFFFFFF);
    v50 = 0;
    v34[0] = 0;
    v34[1] = 0;
    if ( sub_423540((unsigned int *)a5, v34) == -1 )
    {
      sub_423900((int *)&off_4EE040, v48, (int *)&off_4EE024);
      sub_423900((int *)&off_4EE040, v48, (int *)&off_4EE03C);
    }
    else
    {
      LOBYTE(v35[0]) = 0;
      sub_4240C0(
        v48,
        (int)off_4EE024,
        (int)off_4EE024 + 2 * wcslen((const unsigned __int16 *)off_4EE024),
        v35[0],
        v35[0]);
      sub_423900((int *)&off_4EE044, v48, (int *)&off_4EE03C);
    }
    sub_424030(v48, (int)L"%T", (int)&aT[wcslen(L"%T")], v35[0], (int)L"%H:%M:%S", (int)&aHMS[wcslen(L"%H:%M:%S")]);
    sub_424030(v48, (int)L"%R", (int)&aR[wcslen(L"%R")], v35[0], (int)L"%H:%M", (int)&aHM[wcslen(L"%H:%M")]);
    v40 = 7;
    v39 = 0;
    LOWORD(v38[0]) = 0;
    LOBYTE(v50) = 1;
    if ( sub_40C610((int *)v48, off_4EE038[0], wcslen(off_4EE038[0])) != -1 )
    {
      v11 = sub_4234B0(a5, v45);
      LOBYTE(v50) = 2;
      sub_40AF70(v38, v11);
      LOBYTE(v50) = 1;
      if ( v47 >= 8 )
        operator delete(v45[0]);
      sub_4239C0(v38, v48, (int *)off_4EE038);
    }
    if ( sub_40C610((int *)v48, off_4EE034[0], wcslen(off_4EE034[0])) != -1 )
    {
      if ( !v39 )
      {
        v12 = sub_4234B0(a5, v45);
        LOBYTE(v50) = 3;
        sub_40AF70(v38, v12);
        LOBYTE(v50) = 1;
        if ( v47 >= 8 )
          operator delete(v45[0]);
      }
      sub_4239C0(v38, v48, (int *)off_4EE034);
    }
    v43 = 7;
    v42 = 0;
    LOWORD(v41[0]) = 0;
    LOBYTE(v50) = 4;
    if ( sub_40C610((int *)v48, off_4EE030[0], wcslen(off_4EE030[0])) != -1 )
    {
      v13 = sub_423430(v36, &v37[2], 0);
      LOBYTE(v50) = 5;
      sub_40AF70(v41, v13);
      if ( v37[7] >= (void *)8 )
        operator delete(v37[2]);
      v14 = sub_408A70(v33, v35);
      LOBYTE(v50) = 6;
      v15 = sub_406D70((int)v14);
      v16 = (*(int (__thiscall **)(struct std::locale::facet *))(*(_DWORD *)v15 + 4))(v15);
      LOBYTE(v50) = 4;
      sub_408B00(v35);
      LOWORD(v45[0]) = 0;
      v47 = 7;
      v46 = 0;
      v17 = wcslen(L"%S");
      sub_4094F0(v45, v18, L"%S", v17);
      LOBYTE(v50) = 7;
      sub_4054C0((int *)v45, v19, 1u, v16);
      sub_406A00(v45, v41, 0, 0xFFFFFFFF);
      sub_4239C0(v45, v48, (int *)off_4EE030);
      LOBYTE(v50) = 4;
      if ( v47 >= 8 )
        operator delete(v45[0]);
    }
    if ( sub_40C610((int *)v48, off_4EE028[0], wcslen(off_4EE028[0])) != -1 )
    {
      if ( !v42 )
      {
        v20 = sub_423430(v36, &v37[2], 0);
        LOBYTE(v50) = 8;
        sub_40AF70(v41, v20);
        LOBYTE(v50) = 4;
        if ( v37[7] >= (void *)8 )
          operator delete(v37[2]);
      }
      sub_4239C0(v41, v48, (int *)off_4EE028);
    }
    if ( sub_40C610((int *)v48, off_4EE02C[0], wcslen(off_4EE02C[0])) != -1 )
    {
      v21 = sub_423430(v36, &v37[2], 1);
      LOBYTE(v50) = 9;
      sub_40AF70(v41, v21);
      LOBYTE(v50) = 4;
      if ( v37[7] >= (void *)8 )
        operator delete(v37[2]);
      if ( v42 )
      {
        v22 = sub_408A70(v33, v35);
        LOBYTE(v50) = 10;
        v23 = sub_406D70((int)v22);
        v24 = (*(int (__thiscall **)(struct std::locale::facet *))(*(_DWORD *)v23 + 4))(v23);
        sub_408B00(v35);
        v47 = 7;
        v46 = 0;
        LOWORD(v45[0]) = 0;
        LOBYTE(v50) = 11;
        sub_4054C0((int *)v45, v25, 1u, v24);
        sub_406A00(v45, v41, 0, 0xFFFFFFFF);
        sub_4239C0(v45, v48, (int *)off_4EE02C);
        LOBYTE(v50) = 4;
        if ( v47 >= 8 )
          operator delete(v45[0]);
      }
      else
      {
        sub_423970((int *)off_4EE02C, v48);
      }
    }
    qmemcpy(v37, sub_420AA0(v36, &v44), sizeof(v37));
    v35[0] = (int)v27;
    v29 = 7;
    v28 = 0;
    LOWORD(v27[0]) = 0;
    sub_4090E0((int)v27, v48, 0, 0xFFFFFFFF);
    a2 = v32;
    (*(void (__thiscall **)(_DWORD *, int, int, int, _DWORD **, int, void **, _DWORD, _DWORD, _DWORD, _DWORD, int, int, int))(*v31 + 16))(
      v31,
      v32,
      a6,
      a7,
      v33,
      a4,
      v37,
      v27[0],
      v27[1],
      v27[2],
      v27[3],
      v28,
      v29,
      v30);
    if ( v43 >= 8 )
      operator delete(v41[0]);
    v43 = 7;
    v42 = 0;
    LOWORD(v41[0]) = 0;
    if ( v40 >= 8 )
      operator delete(v38[0]);
    v40 = 7;
    v39 = 0;
    LOWORD(v38[0]) = 0;
    if ( v49 >= 8 )
      operator delete(v48[0]);
  }
  return a2;
}
// 422F08: variable 'v18' is possibly undefined
// 422F17: variable 'v19' is possibly undefined
// 4230AA: variable 'v25' is possibly undefined
// 4CC808: using guessed type wchar_t aS[3];
// 4CCA04: using guessed type wchar_t aT[3];
// 4CCA0C: using guessed type wchar_t aHMS[9];
// 4CCA20: using guessed type wchar_t aR[3];
// 4CCA28: using guessed type wchar_t aHM[6];
// 4EE028: using guessed type wchar_t *off_4EE028[6];
// 4EE02C: using guessed type wchar_t *off_4EE02C[5];
// 4EE030: using guessed type wchar_t *off_4EE030[4];
// 4EE034: using guessed type wchar_t *off_4EE034[3];
// 4EE038: using guessed type wchar_t *off_4EE038[2];
// 4EE03C: using guessed type wchar_t *off_4EE03C;
// 4EE040: using guessed type void *off_4EE040;
// 4EE044: using guessed type void *off_4EE044;

//----- (004231F0) --------------------------------------------------------
int __cdecl sub_4231F0(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // esi
  char *v4; // eax
  struct std::_Locinfo *v5; // eax
  _DWORD *v6; // eax
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v2 = 0;
  v9 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x14u);
    v10 = 0;
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v4 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v4 = (char *)(*(_DWORD *)a2 + 28);
      v5 = sub_4086C0((struct std::_Locinfo *)v8, v4);
      v2 = 1;
      v6 = sub_4234F0(v3, (int)v5, 0);
    }
    else
    {
      v6 = 0;
    }
    v10 = -1;
    *a1 = v6;
    if ( (v2 & 1) != 0 )
      sub_408790((std::_Lockit *)v8);
  }
  return 5;
}

//----- (004232A0) --------------------------------------------------------
_DWORD *__stdcall sub_4232A0(_DWORD *a1)
{
  *a1 = &unk_4CCA3C;
  a1[20] = &std::wios::`vftable';
  sub_423390((int)a1, (int)(a1 + 1));
  *(_DWORD *)((char *)a1 + *(_DWORD *)(*a1 + 4)) = &std::wostringstream::`vftable';
  sub_403840(a1 + 1);
  a1[1] = &std::wstringbuf::`vftable';
  a1[16] = 0;
  a1[17] = 4;
  return a1;
}
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBAD4: using guessed type void *std::wios::`vftable';
// 4CCA38: using guessed type void *std::wostringstream::`vftable';

//----- (00423340) --------------------------------------------------------
_DWORD *__usercall sub_423340@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  sub_40C6D0(a2, a1 + 4);
  return a2;
}

//----- (00423360) --------------------------------------------------------
char *__thiscall sub_423360(_DWORD *this, char a2)
{
  _DWORD *v2; // esi

  v2 = this - 20;
  sub_422820(this - 20);
  if ( (a2 & 1) != 0 )
    operator delete(v2);
  return (char *)v2;
}

//----- (00423390) --------------------------------------------------------
int __stdcall sub_423390(int a1, int a2)
{
  int v2; // esi
  __int16 v3; // ax
  bool v4; // zf
  int v5; // eax

  *(_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)a1 + 4)) = &std::wostream::`vftable';
  v2 = a1 + *(_DWORD *)(*(_DWORD *)a1 + 4);
  sub_407DF0((_DWORD *)v2);
  *(_DWORD *)(v2 + 56) = a2;
  *(_DWORD *)(v2 + 60) = 0;
  v3 = sub_405410((_DWORD **)v2);
  v4 = *(_DWORD *)(v2 + 56) == 0;
  *(_WORD *)(v2 + 64) = v3;
  if ( v4 )
  {
    v5 = *(_DWORD *)(v2 + 12) & 0x13 | 4;
    *(_DWORD *)(v2 + 12) = v5;
    if ( (v5 & *(_DWORD *)(v2 + 16)) != 0 )
      sub_408D30(0);
  }
  return a1;
}
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (00423430) --------------------------------------------------------
_DWORD *__usercall sub_423430@<eax>(_QWORD *a1@<eax>, _DWORD *a2@<ebx>, char a3)
{
  __int64 v3; // rdi

  LODWORD(v3) = (unsigned __int64)(*a1 % 1000000i64) >> 32;
  HIDWORD(v3) = *a1 % 1000000i64;
  if ( !a3 || v3 )
  {
    sub_423A20(
      a2,
      (((int)v3 >> 31) ^ HIDWORD(v3)) - ((int)v3 >> 31),
      (__PAIR64__(((int)v3 >> 31) ^ (unsigned int)v3, (unsigned int)((int)v3 >> 31) ^ HIDWORD(v3))
     - __PAIR64__((int)v3 >> 31, (int)v3 >> 31)) >> 32,
      6);
    return a2;
  }
  else
  {
    a2[5] = 7;
    a2[4] = 0;
    *(_WORD *)a2 = 0;
    return a2;
  }
}

//----- (004234B0) --------------------------------------------------------
_DWORD *__usercall sub_4234B0@<eax>(_QWORD *a1@<eax>, _DWORD *a2@<esi>)
{
  sub_423B70(a2, abs32(*a1 / 3600000000i64));
  return a2;
}

//----- (004234F0) --------------------------------------------------------
_DWORD *__thiscall sub_4234F0(_DWORD *this, int a2, void *Block)
{
  int v4; // edx
  void **v5; // eax
  _Cvtvec *v7; // [esp+0h] [ebp-4h]

  this[1] = Block;
  *this = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  this[2] = 0;
  this[3] = _Getcvt(v7);
  this[4] = v4;
  v5 = sub_425FC0(&Block);
  this[2] = *v5;
  *v5 = 0;
  free(Block);
  return this;
}
// 423509: variable 'v7' is possibly undefined
// 423518: variable 'v4' is possibly undefined
// 4BDDE8: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (00423540) --------------------------------------------------------
int __usercall sub_423540@<eax>(unsigned int *a1@<eax>, unsigned int *a2@<ecx>)
{
  unsigned int v2; // ebx
  int v3; // eax
  unsigned int v4; // esi
  signed int v5; // edi
  int v7; // [esp+14h] [ebp-4h]

  v2 = *a1;
  v3 = a1[1];
  v7 = v3;
  if ( (v2 || v3 != 0x80000000) && (v2 != -1 || v3 != 0x7FFFFFFF) )
  {
    if ( v2 == -2 && v3 == 0x7FFFFFFF )
    {
LABEL_41:
      if ( *a2 == -2 && a2[1] == 0x7FFFFFFF )
        return 0;
      return 2;
    }
    v4 = *a2;
    v5 = a2[1];
    if ( (*a2 || v5 != 0x80000000) && (v4 != -1 || v5 != 0x7FFFFFFF) && (v4 != -2 || v5 != 0x7FFFFFFF) )
      goto LABEL_34;
  }
  if ( v2 == -2 && v3 == 0x7FFFFFFF )
    goto LABEL_41;
  v4 = *a2;
  v5 = a2[1];
  if ( *a2 != -2 || v5 != 0x7FFFFFFF )
  {
    if ( !v2 && v3 == 0x80000000 && (v4 || v5 != v3) )
      return -1;
    if ( v4 == -1 && v5 == 0x7FFFFFFF )
    {
      if ( v2 != -1 || v3 != 0x7FFFFFFF )
        return -1;
    }
    else if ( v2 != -1 || v3 != 0x7FFFFFFF )
    {
LABEL_30:
      if ( v4 || v5 != 0x80000000 )
        goto LABEL_34;
      if ( sub_4222C0(v2, v3) )
      {
        v3 = v7;
LABEL_34:
        if ( v3 > v5 )
          return 1;
        if ( v3 < v5 || v2 < v4 )
          return -1;
        return v3 >= v5 && (v3 > v5 || v2 > v4);
      }
      return 1;
    }
    if ( v4 != -1 || v5 != 0x7FFFFFFF )
      return 1;
    goto LABEL_30;
  }
  return 2;
}

//----- (00423680) --------------------------------------------------------
void __thiscall sub_423680(_DWORD *this, void *Block)
{
  int v3; // edx
  void **v4; // eax
  _Cvtvec *v5; // [esp+0h] [ebp-4h]

  this[3] = _Getcvt(v5);
  this[4] = v3;
  v4 = sub_425FC0(&Block);
  this[2] = *v4;
  *v4 = 0;
  free(Block);
}
// 423686: variable 'v5' is possibly undefined
// 423695: variable 'v3' is possibly undefined

//----- (004236C0) --------------------------------------------------------
char __cdecl sub_4236C0(int *a1)
{
  int v1; // eax
  unsigned int v2; // esi
  int v3; // ecx
  int v4; // eax
  char v6[4]; // [esp+0h] [ebp-8h] BYREF
  char v7[4]; // [esp+4h] [ebp-4h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  if ( !dword_4F24A8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v7, 0);
    if ( !dword_4F24A8 )
      dword_4F24A8 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v7);
  }
  v1 = *a1;
  v2 = dword_4F24A8;
  if ( dword_4F24A8 >= *(_DWORD *)(*a1 + 12) )
  {
    v3 = 0;
  }
  else
  {
    v3 = *(_DWORD *)(*(_DWORD *)(v1 + 8) + 4 * dword_4F24A8);
    if ( v3 )
      goto LABEL_13;
  }
  if ( *(_BYTE *)(v1 + 20) )
  {
    v4 = sub_426E4C();
    if ( v2 >= *(_DWORD *)(v4 + 12) )
    {
LABEL_11:
      std::_Lockit::~_Lockit((std::_Lockit *)v6);
      return 0;
    }
    v3 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v2);
  }
  if ( !v3 )
    goto LABEL_11;
LABEL_13:
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return 1;
}
// 4EE108: using guessed type int dword_4EE108;
// 4236C0: using guessed type char var_8[4];
// 4236C0: using guessed type char var_4[4];

//----- (00423770) --------------------------------------------------------
int __cdecl sub_423770(int *a1)
{
  int v1; // edi
  unsigned int v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // esi
  char pExceptionObject[12]; // [esp+Ch] [ebp-20h] BYREF
  char v9[4]; // [esp+18h] [ebp-14h] BYREF
  char v10[4]; // [esp+1Ch] [ebp-10h] BYREF
  int v11; // [esp+28h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
  v11 = 0;
  v1 = dword_4EF824;
  if ( !dword_4F24A8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v10, 0);
    if ( !dword_4F24A8 )
      dword_4F24A8 = ++dword_4EE108;
    std::_Lockit::~_Lockit((std::_Lockit *)v10);
  }
  v2 = dword_4F24A8;
  v3 = *a1;
  if ( dword_4F24A8 >= *(_DWORD *)(*a1 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * dword_4F24A8);
    if ( v4 )
    {
LABEL_11:
      v6 = v4;
LABEL_12:
      if ( v6 )
        goto LABEL_15;
      goto LABEL_13;
    }
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_11;
  v5 = sub_426E4C();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4 * v2);
    goto LABEL_12;
  }
LABEL_13:
  if ( !v1 )
  {
    sub_4398E3((std::exception *)pExceptionObject, "bad cast");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
  }
  v6 = v1;
LABEL_15:
  v11 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v9);
  return v6;
}
// 4EE108: using guessed type int dword_4EE108;
// 4EF824: using guessed type int dword_4EF824;
// 423770: using guessed type char var_14[4];
// 423770: using guessed type char var_10[4];

//----- (00423870) --------------------------------------------------------
void __cdecl sub_423870(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // ecx
  _WORD *v9; // ecx
  int *v10; // eax
  int v11; // ecx
  int v12; // edx
  _DWORD v13[4]; // [esp+18h] [ebp-10h] BYREF

  v6 = a1;
  v7 = a1[5];
  if ( v7 < 8 )
    v8 = a1;
  else
    v8 = (_DWORD *)*a1;
  v9 = (_WORD *)v8 + a1[4];
  if ( v7 >= 8 )
    v6 = (_DWORD *)*a1;
  v10 = sub_423D20(&a2, v13, v6, v9);
  v11 = *v10;
  v12 = v10[1];
  v13[3] = a6;
  if ( v11 != v12 )
    sub_424230(a2, a3, a4, a5, a6, v11, v12, a5, a6);
}

//----- (00423900) --------------------------------------------------------
void __usercall sub_423900(int *a1@<eax>, _DWORD *a2, int *a3)
{
  int v3; // edx
  _WORD *v4; // eax
  _WORD *v5; // esi
  int v7; // edi
  _WORD *v8; // eax
  int v10; // [esp+14h] [ebp-4h]

  v3 = *a1;
  v4 = (_WORD *)*a1;
  v5 = v4 + 1;
  while ( *v4++ )
    ;
  v7 = v3 + 2 * (v4 - v5);
  v8 = (_WORD *)*a3;
  while ( *v8++ )
    ;
  sub_424030(a2, *a3, *a3 + 2 * (((int)v8 - *a3 - 2) >> 1), v10, v3, v7);
}
// 423958: variable 'v10' is possibly undefined

//----- (00423970) --------------------------------------------------------
void __usercall sub_423970(int *a1@<eax>, _DWORD *a2)
{
  int v2; // ecx
  _WORD *v3; // eax
  _WORD *v4; // esi
  int v6; // [esp+Ch] [ebp-8h]
  int v7; // [esp+10h] [ebp-4h]

  v2 = *a1;
  v3 = (_WORD *)*a1;
  LOBYTE(v7) = 0;
  v4 = v3 + 1;
  while ( *v3++ )
    ;
  sub_4240C0(a2, v2, v2 + 2 * (v3 - v4), v6, v7);
}
// 4239AB: variable 'v6' is possibly undefined
// 4239AB: variable 'v7' is possibly undefined

//----- (004239C0) --------------------------------------------------------
void __usercall sub_4239C0(_DWORD *a1@<eax>, _DWORD *a2, int *a3)
{
  int *v3; // eax
  int v4; // esi
  int v5; // edi
  _WORD *v6; // eax
  _DWORD v8[2]; // [esp+10h] [ebp-8h] BYREF

  v3 = sub_423CB0(v8, a1);
  v4 = v3[1];
  v5 = *v3;
  v6 = (_WORD *)*a3;
  while ( *v6++ )
    ;
  sub_423870(a2, *a3, *a3 + 2 * (((int)v6 - *a3 - 2) >> 1), v8[1], v5, v4);
}

//----- (00423A20) --------------------------------------------------------
_DWORD *__cdecl sub_423A20(_DWORD *a1, int a2, int a3, int a4)
{
  int *v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // esi
  void (__thiscall ***v8)(_DWORD, int); // esi
  int v9; // eax
  char v11[16]; // [esp+10h] [ebp-C0h] BYREF
  int v12[38]; // [esp+20h] [ebp-B0h] BYREF
  char v13[4]; // [esp+B8h] [ebp-18h] BYREF
  int v14; // [esp+BCh] [ebp-14h] BYREF
  int v15; // [esp+C0h] [ebp-10h]
  int v16; // [esp+CCh] [ebp-4h]

  v15 = 0;
  sub_4232A0(v12);
  v16 = 1;
  v4 = (int *)std::locale::classic();
  sub_418E70(v4, (int)v12 + *(_DWORD *)(v12[0] + 4), &v14);
  v5 = v14;
  if ( v14 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v13, 0);
    v6 = *(_DWORD *)(v5 + 4);
    if ( v6 && v6 != -1 )
      *(_DWORD *)(v5 + 4) = v6 - 1;
    v7 = -(*(_DWORD *)(v5 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v13);
    v8 = (void (__thiscall ***)(_DWORD, int))(v5 & v7);
    if ( v8 )
      (**v8)(v8, 1);
  }
  v9 = std::setw(v11, a4, a4 >> 31);
  (*(void (__cdecl **)(char *, _DWORD, _DWORD))v9)(
    (char *)v12 + *(_DWORD *)(v12[0] + 4),
    *(_DWORD *)(v9 + 8),
    *(_DWORD *)(v9 + 12));
  *(_WORD *)((char *)&v12[16] + *(_DWORD *)(v12[0] + 4)) = 48;
  sub_4228B0(v12, a2, a3);
  sub_423340((int)v12, a1);
  v15 = 1;
  LOBYTE(v16) = 0;
  sub_422820(v12);
  return a1;
}
// 427BA9: using guessed type _DWORD __cdecl std::setw(_DWORD, _DWORD, _DWORD);
// 423A20: using guessed type char var_18[4];
// 423A20: using guessed type char var_C0[16];

//----- (00423B70) --------------------------------------------------------
_DWORD *__cdecl sub_423B70(_DWORD *a1, int a2)
{
  int *v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // esi
  void (__thiscall ***v6)(_DWORD, int); // esi
  int v7; // eax
  char v9[16]; // [esp+10h] [ebp-C0h] BYREF
  int v10[38]; // [esp+20h] [ebp-B0h] BYREF
  char v11[4]; // [esp+B8h] [ebp-18h] BYREF
  int v12; // [esp+BCh] [ebp-14h] BYREF
  int v13; // [esp+C0h] [ebp-10h]
  int v14; // [esp+CCh] [ebp-4h]

  v13 = 0;
  sub_4232A0(v10);
  v14 = 1;
  v2 = (int *)std::locale::classic();
  sub_418E70(v2, (int)v10 + *(_DWORD *)(v10[0] + 4), &v12);
  v3 = v12;
  if ( v12 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v11, 0);
    v4 = *(_DWORD *)(v3 + 4);
    if ( v4 && v4 != -1 )
      *(_DWORD *)(v3 + 4) = v4 - 1;
    v5 = -(*(_DWORD *)(v3 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)v11);
    v6 = (void (__thiscall ***)(_DWORD, int))(v3 & v5);
    if ( v6 )
      (**v6)(v6, 1);
  }
  v7 = std::setw(v9, 2, 0);
  (*(void (__cdecl **)(char *, _DWORD, _DWORD))v7)(
    (char *)v10 + *(_DWORD *)(v10[0] + 4),
    *(_DWORD *)(v7 + 8),
    *(_DWORD *)(v7 + 12));
  *(_WORD *)((char *)&v10[16] + *(_DWORD *)(v10[0] + 4)) = 48;
  sub_40BB80(v10, a2);
  sub_423340((int)v10, a1);
  v13 = 1;
  LOBYTE(v14) = 0;
  sub_422820(v10);
  return a1;
}
// 427BA9: using guessed type _DWORD __cdecl std::setw(_DWORD, _DWORD, _DWORD);
// 423B70: using guessed type char var_18[4];
// 423B70: using guessed type char var_C0[16];

//----- (00423CB0) --------------------------------------------------------
_DWORD *__usercall sub_423CB0@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>)
{
  _DWORD *v2; // eax
  void *v4[5]; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v5; // [esp+14h] [ebp-8h]

  v5 = 7;
  v4[4] = 0;
  LOWORD(v4[0]) = 0;
  sub_4090E0((int)v4, a2, 0, 0xFFFFFFFF);
  if ( v5 >= 8 )
    operator delete(v4[0]);
  if ( a2[5] < 8u )
    v2 = a2;
  else
    v2 = (_DWORD *)*a2;
  *a1 = v2;
  if ( a2[5] < 8u )
    a1[1] = (char *)a2 + 2 * a2[4];
  else
    a1[1] = *a2 + 2 * a2[4];
  return a1;
}

//----- (00423D20) --------------------------------------------------------
_DWORD *__thiscall sub_423D20(_DWORD *this, _DWORD *a2, _WORD *a3, _WORD *a4)
{
  _DWORD *result; // eax
  _WORD *v5; // edi
  _WORD *v6; // edx
  _WORD *v7; // ebx
  _WORD *v8; // ecx
  _WORD *v9; // [esp+Ch] [ebp-4h]

  result = a2;
  v5 = a3;
  if ( a3 != a4 )
  {
    v6 = (_WORD *)*this;
    v7 = (_WORD *)this[1];
    v9 = (_WORD *)*this;
    while ( v6 != v7 )
    {
      v8 = v5;
      if ( v5 != a4 )
      {
        while ( v6 != v7 )
        {
          if ( *v8 == *v6 )
          {
            ++v8;
            ++v6;
            if ( v8 != a4 )
              continue;
          }
          goto LABEL_9;
        }
LABEL_12:
        result = a2;
        *a2 = v5;
        a2[1] = v8;
        return result;
      }
LABEL_9:
      if ( v6 == v7 )
        goto LABEL_12;
      result = a2;
      if ( ++v5 == a4 )
        break;
      v6 = v9;
    }
  }
  result[1] = a4;
  *result = a4;
  return result;
}

//----- (00423DA0) --------------------------------------------------------
int __cdecl sub_423DA0(int a1, int a2, int a3)
{
  char *v3; // ecx
  int result; // eax
  char *v5; // esi
  void *v6[5]; // [esp+14h] [ebp-2Ch] BYREF
  unsigned int v7; // [esp+28h] [ebp-18h]
  int v8; // [esp+3Ch] [ebp-4h]

  result = a1;
  v5 = v3;
  if ( v3 == (char *)a2 )
  {
    *(_DWORD *)a1 = a3;
  }
  else
  {
    do
    {
      LOWORD(v6[0]) = 0;
      v7 = 7;
      v6[4] = 0;
      sub_4094F0(v6, (int)(v5 + 2), v5, wcslen((const unsigned __int16 *)v5));
      v8 = 0;
      sub_424150(v6, (int *)a3);
      v8 = -1;
      if ( v7 >= 8 )
        operator delete(v6[0]);
      v5 += 34;
    }
    while ( v5 != (char *)a2 );
    result = a1;
    *(_DWORD *)a1 = a3;
  }
  return result;
}
// 423DCE: variable 'v3' is possibly undefined

//----- (00423E70) --------------------------------------------------------
_DWORD *__usercall sub_423E70@<eax>(
        unsigned __int16 *a1@<eax>,
        unsigned __int16 *a2@<ebx>,
        _DWORD *a3,
        int a4,
        _DWORD *a5)
{
  _DWORD *v5; // ecx
  unsigned __int16 *i; // edi
  unsigned __int16 v7; // dx
  int *v8; // eax
  _WORD **v9; // eax
  unsigned __int16 *v10; // ecx
  unsigned __int16 v11; // ax
  _DWORD *result; // eax

  v5 = a5;
  for ( i = a1; i != a2; ++i )
  {
    if ( v5 )
    {
      v7 = *i;
      if ( *(_DWORD *)v5[9] && (v8 = (int *)v5[13], *v8 > 0) )
      {
        --*v8;
        v9 = (_WORD **)v5[9];
        v10 = (*v9)++;
        *v10 = v7;
        v11 = v7;
      }
      else
      {
        v11 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v5 + 12))(v5, *i);
      }
      v5 = a5;
      if ( v11 != 0xFFFF )
        continue;
    }
    LOBYTE(a4) = 1;
  }
  result = a3;
  *a3 = a4;
  a3[1] = v5;
  return result;
}

//----- (00423EE0) --------------------------------------------------------
int __cdecl sub_423EE0(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // esi
  _DWORD *v4; // eax
  _DWORD v6[8]; // [esp+0h] [ebp-2Ch] BYREF
  int v7; // [esp+28h] [ebp-4h]

  v6[7] = v6;
  v3 = a3;
  v7 = 0;
  v4 = a1;
  v6[6] = a3;
  while ( v4 != a2 )
  {
    v6[5] = v3;
    v6[4] = v3;
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      *(_DWORD *)(v3 + 20) = 7;
      *(_DWORD *)(v3 + 16) = 0;
      *(_WORD *)v3 = 0;
      sub_4090E0(v3, v4, 0, 0xFFFFFFFF);
      v4 = a1;
    }
    v3 += 28;
    v4 += 7;
    LOBYTE(v7) = 0;
    a1 = v4;
  }
  return v3;
}

//----- (00423F90) --------------------------------------------------------
_DWORD *__cdecl sub_423F90(int a1, void *a2)
{
  char *v2; // ecx
  _DWORD *v3; // esi
  char *v4; // edi
  _DWORD v6[7]; // [esp+0h] [ebp-28h] BYREF
  int v7; // [esp+24h] [ebp-4h]

  v6[6] = v6;
  v3 = a2;
  v4 = v2;
  v6[5] = a2;
  v7 = 0;
  while ( v4 != (char *)a1 )
  {
    v6[4] = v3;
    LOBYTE(v7) = 1;
    if ( v3 )
    {
      v3[5] = 7;
      v3[4] = 0;
      *(_WORD *)v3 = 0;
      sub_40AF70(v3, v4);
    }
    v3 += 7;
    LOBYTE(v7) = 0;
    v4 += 28;
  }
  return v3;
}
// 423FBE: variable 'v2' is possibly undefined

//----- (00424030) --------------------------------------------------------
void __cdecl sub_424030(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // ecx
  _WORD *v9; // ecx
  int *v10; // eax
  int v11; // ecx
  int v12; // edx
  _DWORD v13[4]; // [esp+18h] [ebp-10h] BYREF

  v6 = a1;
  v7 = a1[5];
  if ( v7 < 8 )
    v8 = a1;
  else
    v8 = (_DWORD *)*a1;
  v9 = (_WORD *)v8 + a1[4];
  if ( v7 >= 8 )
    v6 = (_DWORD *)*a1;
  v10 = sub_423D20(&a2, v13, v6, v9);
  v11 = *v10;
  v12 = v10[1];
  v13[3] = a6;
  if ( v11 != v12 )
    sub_4246B0(a2, a3, a4, a5, a6, v11, v12, a5, a6);
}

//----- (004240C0) --------------------------------------------------------
void __usercall sub_4240C0(_DWORD *a1@<esi>, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // edx
  _DWORD *v6; // eax
  _WORD *v7; // ecx
  _DWORD *v8; // eax
  int *v9; // eax
  int v10; // ecx
  int *v11; // edx
  int v12; // [esp+14h] [ebp-Ch] BYREF
  int v13; // [esp+1Ch] [ebp-4h]

  v5 = a1[5];
  if ( v5 < 8 )
    v6 = a1;
  else
    v6 = (_DWORD *)*a1;
  v7 = (_WORD *)v6 + a1[4];
  if ( v5 < 8 )
    v8 = a1;
  else
    v8 = (_DWORD *)*a1;
  v9 = sub_423D20(&a2, &v12, v8, v7);
  v10 = *v9;
  v11 = (int *)v9[1];
  LOBYTE(v13) = a5;
  if ( (int *)v10 != v11 )
    sub_4248D0(a2, a3, a4, v13, a5, v10, v11);
}

//----- (00424150) --------------------------------------------------------
void __usercall sub_424150(_DWORD *a1@<ecx>, int *a2@<edi>)
{
  unsigned int v3; // ecx
  int v4; // esi
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // ecx

  v3 = a2[1];
  if ( (unsigned int)a1 >= v3 || *a2 > (unsigned int)a1 )
  {
    if ( v3 == a2[2] )
      sub_422240(a2);
    v7 = a2[1];
    if ( v7 )
    {
      *(_DWORD *)(v7 + 20) = 7;
      *(_DWORD *)(v7 + 16) = 0;
      *(_WORD *)v7 = 0;
      sub_4090E0(v7, a1, 0, 0xFFFFFFFF);
    }
  }
  else
  {
    v4 = ((int)a1 - *a2) / 28;
    if ( v3 == a2[2] )
      sub_422240(a2);
    v5 = (_DWORD *)(*a2 + 28 * v4);
    v6 = a2[1];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 20) = 7;
      *(_DWORD *)(v6 + 16) = 0;
      *(_WORD *)v6 = 0;
      sub_4090E0(v6, v5, 0, 0xFFFFFFFF);
    }
  }
  a2[1] += 28;
}

//----- (00424230) --------------------------------------------------------
void __cdecl sub_424230(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int *v9; // ecx
  int *v10; // esi
  int v11; // ebx
  _WORD *v12; // edi
  _DWORD *v13; // eax
  unsigned int v14; // eax
  int v15; // ecx
  int *v16; // eax
  int *v17; // eax
  int *v18; // eax
  int *v19; // eax
  unsigned int v20; // edx
  int *v21; // eax
  char *v22; // ecx
  int *v23; // edi
  int v24; // eax
  int *v25; // eax
  int v26; // [esp-1Ch] [ebp-90h]
  int ************v27[3]; // [esp-18h] [ebp-8Ch] BYREF
  int ************v28[8]; // [esp-Ch] [ebp-80h] BYREF
  void *v29[4]; // [esp+14h] [ebp-60h] BYREF
  int v30; // [esp+24h] [ebp-50h]
  _WORD *v31; // [esp+2Ch] [ebp-48h]
  _WORD *v32; // [esp+30h] [ebp-44h]
  int v33; // [esp+34h] [ebp-40h] BYREF
  int v34; // [esp+38h] [ebp-3Ch]
  int *v35; // [esp+3Ch] [ebp-38h]
  int pExceptionObject[3]; // [esp+40h] [ebp-34h] BYREF
  int v37; // [esp+4Ch] [ebp-28h] BYREF
  char *v38; // [esp+54h] [ebp-20h] BYREF
  int v39; // [esp+58h] [ebp-1Ch] BYREF
  int v40; // [esp+5Ch] [ebp-18h]
  void *Src; // [esp+60h] [ebp-14h]
  int v42; // [esp+70h] [ebp-4h]

  v10 = v9;
  v11 = a6;
  v12 = (_WORD *)a7;
  v31 = (_WORD *)a6;
  v32 = (_WORD *)a7;
  v33 = a8;
  v34 = a9;
  v35 = &a4;
  v29[0] = 0;
  v13 = operator new(8u);
  if ( !v13 )
  {
    v38 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v38);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v29[0] = v13;
  *v13 = 0;
  v13[1] = 0;
  *(_DWORD *)v29[0] = v29;
  memset(&v29[1], 0, 12);
  v30 = 0;
  v42 = 0;
  v14 = v10[5];
  if ( v14 < 8 )
    v15 = (int)v10;
  else
    v15 = *v10;
  v40 = v15;
  if ( v14 < 8 )
    v16 = v10;
  else
    v16 = (int *)*v10;
  Src = v16;
  while ( (_WORD *)v11 != v12 )
  {
    sub_424B00((int *)v29, (int)&v39, v40, Src, v11);
    v40 = v39;
    Src = v12;
    sub_424530(&v33, (int *)v29);
    if ( (unsigned int)v10[5] < 8 )
      v17 = v10;
    else
      v17 = (int *)*v10;
    v18 = sub_423D20(&a1, &v37, v12, (_WORD *)v17 + v10[4]);
    v12 = (_WORD *)v18[1];
    v31 = (_WORD *)*v18;
    v11 = (int)v31;
    v32 = v12;
    if ( v31 != v12 )
    {
      v33 = a4;
      v34 = a5;
    }
  }
  if ( (unsigned int)v10[5] < 8 )
    v19 = v10;
  else
    v19 = (int *)*v10;
  sub_424B00((int *)v29, (int)&v39, v40, Src, (int)v19 + 2 * v10[4]);
  if ( v30 )
  {
    v39 = (int)v28;
    sub_419BC0(v28, (int *)v29);
    LOBYTE(v42) = 1;
    v39 = (int)v27;
    sub_424480(v27, (int *)v29);
    if ( (unsigned int)v10[5] < 8 )
      v25 = v10;
    else
      v25 = (int *)*v10;
    v26 = (int)v25 + 2 * v10[4];
    LOBYTE(v42) = 0;
    sub_4245D0(v10, v26, v27[0], (int)v27[1], (int)v27[2], v28[0], (int)v28[1], (int)v28[2]);
  }
  else
  {
    v20 = v10[5];
    if ( v20 < 8 )
      v21 = v10;
    else
      v21 = (int *)*v10;
    v22 = (char *)v21 + 2 * v10[4];
    if ( v20 < 8 )
      v23 = v10;
    else
      v23 = (int *)*v10;
    if ( v39 )
      v24 = (v39 - (int)v23) >> 1;
    else
      v24 = 0;
    if ( v22 )
      sub_409050(v10, v24, (int)&v22[-v39] >> 1);
    else
      sub_409050(v10, v24, 0);
  }
  sub_4244A0((int)v29);
  operator delete(v29[0]);
}
// 424258: variable 'v9' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00424480) --------------------------------------------------------
_DWORD *__usercall sub_424480@<eax>(_DWORD *result@<eax>, int *a2@<ecx>)
{
  int v2; // edx
  int v3; // ecx

  v2 = a2[3];
  v3 = *a2;
  result[1] = 0;
  *result = v3;
  result[2] = v2;
  return result;
}

//----- (004244A0) --------------------------------------------------------
void __usercall sub_4244A0(int a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  int v3; // eax
  bool v4; // zf
  void **v5; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( v1 )
  {
    do
    {
      if ( v1 )
      {
        *(_DWORD *)(a1 + 16) = --v1;
        if ( !v1 )
          *(_DWORD *)(a1 + 12) = 0;
      }
    }
    while ( *(_DWORD *)(a1 + 16) );
  }
  v2 = *(_DWORD *)(a1 + 8);
  while ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    --v2;
    v4 = *(_DWORD *)(v3 + 4 * v2) == 0;
    v5 = (void **)(v3 + 4 * v2);
    if ( !v4 )
      operator delete(*v5);
  }
  if ( *(_DWORD *)(a1 + 4) )
    operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
}

//----- (00424510) --------------------------------------------------------
int __thiscall sub_424510(_DWORD *this)
{
  int result; // eax

  result = this[4];
  if ( result )
  {
    this[4] = --result;
    if ( !result )
      this[3] = 0;
  }
  return result;
}

//----- (00424530) --------------------------------------------------------
_WORD *__usercall sub_424530@<eax>(int *a1@<eax>, int *a2)
{
  _WORD *v2; // ebx
  int *****v3; // esi
  int **v4; // edi
  int ***v5; // eax
  int v6; // ecx
  int *v7; // edi
  int v9; // [esp-18h] [ebp-4Ch] BYREF
  int v10; // [esp-14h] [ebp-48h]
  int *v11; // [esp-Ch] [ebp-40h]
  _WORD *v12; // [esp-8h] [ebp-3Ch]
  int *v13; // [esp-4h] [ebp-38h]
  int v14[5]; // [esp+10h] [ebp-24h] BYREF
  int v15; // [esp+24h] [ebp-10h]
  int *v16; // [esp+2Ch] [ebp-8h] BYREF
  char v17[4]; // [esp+30h] [ebp-4h] BYREF

  v2 = (_WORD *)a1[1];
  v16 = (int *)*a1;
  v3 = (int *****)sub_419BC0(v14, a2);
  v4 = 0;
  if ( *v3 )
  {
    v5 = **v3;
    if ( v5 )
    {
      v4 = *v5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v17, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v17);
    }
  }
  v6 = (int)v3[2];
  v13 = v16;
  v12 = v2;
  v11 = v16;
  v15 = v6;
  v16 = &v9;
  v9 = 0;
  v10 = 0;
  if ( v4 )
  {
    v7 = *v4;
    if ( v7 )
    {
      v9 = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v16, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v16);
    }
  }
  return sub_4250C0(a2, v9, v10, v15, v11, v12, (int)v13);
}
// 424530: using guessed type int var_24[5];
// 424530: using guessed type char var_4[4];

//----- (004245D0) --------------------------------------------------------
_DWORD *__cdecl sub_4245D0(_DWORD *a1, int a2, int ************a3, int a4, int a5, int ************a6, int a7, int a8)
{
  int **********v9; // [esp-Ch] [ebp-38h] BYREF
  int v10; // [esp-8h] [ebp-34h]
  int **********v11; // [esp+0h] [ebp-2Ch] BYREF
  int v12; // [esp+4h] [ebp-28h]
  int v13; // [esp+8h] [ebp-24h]
  int ***********v14; // [esp+18h] [ebp-14h] BYREF
  char v15[4]; // [esp+1Ch] [ebp-10h] BYREF
  int v16; // [esp+28h] [ebp-4h]

  v11 = 0;
  v12 = 0;
  v14 = &v11;
  if ( a6 )
  {
    if ( *a6 )
    {
      v11 = **a6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v15);
    }
  }
  v13 = a8;
  v16 = 0;
  v9 = 0;
  v10 = 0;
  v14 = &v9;
  if ( a3 )
  {
    if ( *a3 )
    {
      v9 = **a3;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v14, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v14);
    }
  }
  v16 = -1;
  return sub_424BF0(a1, a2, v9, v10, a5, v11, v12, v13);
}
// 4245D0: using guessed type char var_10[4];

//----- (004246B0) --------------------------------------------------------
void __cdecl sub_4246B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int *v9; // ecx
  int *v10; // esi
  int v11; // ebx
  _WORD *v12; // edi
  _DWORD *v13; // eax
  unsigned int v14; // eax
  int v15; // ecx
  int *v16; // eax
  int *v17; // eax
  int *v18; // eax
  int *v19; // eax
  unsigned int v20; // edx
  int *v21; // eax
  char *v22; // ecx
  int *v23; // edi
  int v24; // eax
  int *v25; // eax
  int v26; // [esp-1Ch] [ebp-90h]
  int ************v27[3]; // [esp-18h] [ebp-8Ch] BYREF
  int ************v28[8]; // [esp-Ch] [ebp-80h] BYREF
  void *v29[4]; // [esp+14h] [ebp-60h] BYREF
  int v30; // [esp+24h] [ebp-50h]
  _WORD *v31; // [esp+2Ch] [ebp-48h]
  _WORD *v32; // [esp+30h] [ebp-44h]
  int v33; // [esp+34h] [ebp-40h] BYREF
  int v34; // [esp+38h] [ebp-3Ch]
  int *v35; // [esp+3Ch] [ebp-38h]
  int pExceptionObject[3]; // [esp+40h] [ebp-34h] BYREF
  int v37; // [esp+4Ch] [ebp-28h] BYREF
  char *v38; // [esp+54h] [ebp-20h] BYREF
  int v39; // [esp+58h] [ebp-1Ch] BYREF
  int v40; // [esp+5Ch] [ebp-18h]
  void *Src; // [esp+60h] [ebp-14h]
  int v42; // [esp+70h] [ebp-4h]

  v10 = v9;
  v11 = a6;
  v12 = (_WORD *)a7;
  v31 = (_WORD *)a6;
  v32 = (_WORD *)a7;
  v33 = a8;
  v34 = a9;
  v35 = &a4;
  v29[0] = 0;
  v13 = operator new(8u);
  if ( !v13 )
  {
    v38 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v38);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v29[0] = v13;
  *v13 = 0;
  v13[1] = 0;
  *(_DWORD *)v29[0] = v29;
  memset(&v29[1], 0, 12);
  v30 = 0;
  v42 = 0;
  v14 = v10[5];
  if ( v14 < 8 )
    v15 = (int)v10;
  else
    v15 = *v10;
  v40 = v15;
  if ( v14 < 8 )
    v16 = v10;
  else
    v16 = (int *)*v10;
  Src = v16;
  while ( (_WORD *)v11 != v12 )
  {
    sub_424B00((int *)v29, (int)&v39, v40, Src, v11);
    v40 = v39;
    Src = v12;
    sub_424CD0((int)&v33, (int *)v29);
    if ( (unsigned int)v10[5] < 8 )
      v17 = v10;
    else
      v17 = (int *)*v10;
    v18 = sub_423D20(&a1, &v37, v12, (_WORD *)v17 + v10[4]);
    v12 = (_WORD *)v18[1];
    v31 = (_WORD *)*v18;
    v11 = (int)v31;
    v32 = v12;
    if ( v31 != v12 )
    {
      v33 = a4;
      v34 = a5;
    }
  }
  if ( (unsigned int)v10[5] < 8 )
    v19 = v10;
  else
    v19 = (int *)*v10;
  sub_424B00((int *)v29, (int)&v39, v40, Src, (int)v19 + 2 * v10[4]);
  if ( v30 )
  {
    v39 = (int)v28;
    sub_419BC0(v28, (int *)v29);
    LOBYTE(v42) = 1;
    v39 = (int)v27;
    sub_424480(v27, (int *)v29);
    if ( (unsigned int)v10[5] < 8 )
      v25 = v10;
    else
      v25 = (int *)*v10;
    v26 = (int)v25 + 2 * v10[4];
    LOBYTE(v42) = 0;
    sub_4245D0(v10, v26, v27[0], (int)v27[1], (int)v27[2], v28[0], (int)v28[1], (int)v28[2]);
  }
  else
  {
    v20 = v10[5];
    if ( v20 < 8 )
      v21 = v10;
    else
      v21 = (int *)*v10;
    v22 = (char *)v21 + 2 * v10[4];
    if ( v20 < 8 )
      v23 = v10;
    else
      v23 = (int *)*v10;
    if ( v39 )
      v24 = (v39 - (int)v23) >> 1;
    else
      v24 = 0;
    if ( v22 )
      sub_409050(v10, v24, (int)&v22[-v39] >> 1);
    else
      sub_409050(v10, v24, 0);
  }
  sub_4244A0((int)v29);
  operator delete(v29[0]);
}
// 4246D8: variable 'v9' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004248D0) --------------------------------------------------------
void __cdecl sub_4248D0(int a1, int a2, int a3, int a4, int a5, int a6, int *a7)
{
  int *v7; // ecx
  int *v8; // esi
  int v9; // ebx
  int *v10; // edi
  _DWORD *v11; // eax
  unsigned int v12; // eax
  int v13; // edx
  int *v14; // eax
  int *v15; // eax
  int *v16; // eax
  int *v17; // ecx
  unsigned int v18; // edx
  int *v19; // eax
  char *v20; // ecx
  int *v21; // edi
  int v22; // eax
  int *v23; // eax
  int v24; // [esp-1Ch] [ebp-78h]
  int ************v25[3]; // [esp-18h] [ebp-74h] BYREF
  int ************v26[7]; // [esp-Ch] [ebp-68h] BYREF
  void *v27[4]; // [esp+10h] [ebp-4Ch] BYREF
  int v28; // [esp+20h] [ebp-3Ch]
  int pExceptionObject[3]; // [esp+28h] [ebp-34h] BYREF
  int v30; // [esp+34h] [ebp-28h] BYREF
  char *v31; // [esp+3Ch] [ebp-20h] BYREF
  int v32; // [esp+40h] [ebp-1Ch] BYREF
  int *v33; // [esp+44h] [ebp-18h]
  int v34; // [esp+48h] [ebp-14h] BYREF
  int v35; // [esp+58h] [ebp-4h]

  v8 = v7;
  v9 = a6;
  v10 = a7;
  v27[0] = 0;
  v11 = operator new(8u);
  if ( !v11 )
  {
    v31 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v31);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v27[0] = v11;
  *v11 = 0;
  v11[1] = 0;
  *(_DWORD *)v27[0] = v27;
  memset(&v27[1], 0, 12);
  v28 = 0;
  v35 = 0;
  v12 = v8[5];
  if ( v12 < 8 )
    v13 = (int)v8;
  else
    v13 = *v8;
  if ( v12 < 8 )
    v14 = v8;
  else
    v14 = (int *)*v8;
  while ( (int *)v9 != v10 )
  {
    sub_424B00((int *)v27, (int)&v34, v13, v14, v9);
    v32 = v34;
    v33 = v10;
    sub_424D70((int *)v27);
    if ( (unsigned int)v8[5] < 8 )
      v15 = v8;
    else
      v15 = (int *)*v8;
    v16 = sub_423D20(&a1, &v30, v10, (_WORD *)v15 + v8[4]);
    v9 = *v16;
    v10 = (int *)v16[1];
    v14 = v33;
    v13 = v32;
  }
  if ( (unsigned int)v8[5] < 8 )
    v17 = v8;
  else
    v17 = (int *)*v8;
  sub_424B00((int *)v27, (int)&v32, v13, v14, (int)v17 + 2 * v8[4]);
  if ( v28 )
  {
    v32 = (int)v26;
    sub_419BC0(v26, (int *)v27);
    LOBYTE(v35) = 1;
    v32 = (int)v25;
    sub_424480(v25, (int *)v27);
    if ( (unsigned int)v8[5] < 8 )
      v23 = v8;
    else
      v23 = (int *)*v8;
    v24 = (int)v23 + 2 * v8[4];
    LOBYTE(v35) = 0;
    sub_4245D0(v8, v24, v25[0], (int)v25[1], (int)v25[2], v26[0], (int)v26[1], (int)v26[2]);
  }
  else
  {
    v18 = v8[5];
    if ( v18 < 8 )
      v19 = v8;
    else
      v19 = (int *)*v8;
    v20 = (char *)v19 + 2 * v8[4];
    if ( v18 < 8 )
      v21 = v8;
    else
      v21 = (int *)*v8;
    if ( v32 )
      v22 = (v32 - (int)v21) >> 1;
    else
      v22 = 0;
    if ( v20 )
      sub_409050(v8, v22, (int)&v20[-v32] >> 1);
    else
      sub_409050(v8, v22, 0);
  }
  sub_4244A0((int)v27);
  operator delete(v27[0]);
}
// 4248F8: variable 'v7' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00424AB0) --------------------------------------------------------
_DWORD *__usercall sub_424AB0@<eax>(int a1@<ecx>, int a2@<edi>, _DWORD *a3@<esi>)
{
  _DWORD *v3; // eax
  int v5; // [esp+0h] [ebp-4h] BYREF

  v5 = a1;
  *a3 = 0;
  a3[1] = 0;
  if ( *(_DWORD *)a2 )
  {
    v3 = **(_DWORD ***)a2;
    if ( !v3 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v5, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v5);
      a3[2] = *(_DWORD *)(a2 + 8);
      return a3;
    }
    *a3 = *v3;
  }
  a3[2] = *(_DWORD *)(a2 + 8);
  return a3;
}

//----- (00424B00) --------------------------------------------------------
int __userpurge sub_424B00@<eax>(int *a1@<eax>, int a2, int a3, void *Src, int a5)
{
  char *v6; // ebx
  int result; // eax
  _WORD *v8; // edi
  int **v9; // eax
  int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // ebx
  int v17; // eax
  int v18[3]; // [esp+8h] [ebp-10h] BYREF
  void *v19; // [esp+14h] [ebp-4h] BYREF

  sub_425030(&v19, a1, a3, (int)Src);
  if ( a1[4] )
  {
    v8 = v19;
    if ( v19 != (void *)a5 )
    {
      do
      {
        sub_424E30((int)a1, v8);
        v9 = (int **)sub_424480(v18, a1);
        if ( *v9 )
          v10 = **v9;
        else
          v10 = 0;
        v11 = (unsigned int)v9[2];
        v12 = *(_DWORD *)(v10 + 8);
        v13 = v11 >> 3;
        v14 = v11 & 7;
        if ( v12 <= v13 )
          v13 -= v12;
        *v8 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * v13) + 2 * v14);
        v15 = a1[4];
        if ( v15 )
        {
          v16 = a1[2];
          if ( 8 * v16 <= (unsigned int)++a1[3] )
            a1[3] = 0;
          v17 = v15 - 1;
          a1[4] = v17;
          if ( !v17 )
            a1[3] = 0;
        }
        ++v8;
      }
      while ( v8 != (_WORD *)a5 );
    }
    result = a2;
    *(_DWORD *)a2 = v8;
  }
  else
  {
    v6 = (char *)v19;
    if ( v19 == Src )
    {
      result = a2;
      *(_DWORD *)a2 = a5;
    }
    else
    {
      memcpy(v19, Src, 2 * ((a5 - (int)Src) >> 1));
      result = a2;
      *(_DWORD *)a2 = &v6[2 * ((a5 - (int)Src) >> 1)];
    }
  }
  return result;
}
// 424B00: using guessed type int var_10[3];

//----- (00424BF0) --------------------------------------------------------
_DWORD *__stdcall sub_424BF0(_DWORD *a1, int a2, int **********a3, int a4, int a5, int **********a6, int a7, int a8)
{
  int ********v9; // [esp-1Ch] [ebp-38h] BYREF
  int v10; // [esp-18h] [ebp-34h]
  int ********v11; // [esp-10h] [ebp-2Ch] BYREF
  int v12; // [esp-Ch] [ebp-28h]
  int v13; // [esp-8h] [ebp-24h]
  int v14; // [esp-4h] [ebp-20h]
  int *********v15; // [esp+8h] [ebp-14h] BYREF
  char v16[4]; // [esp+Ch] [ebp-10h] BYREF
  int v17; // [esp+18h] [ebp-4h]

  v14 = a2;
  v11 = 0;
  v12 = 0;
  v15 = &v11;
  if ( a6 )
  {
    if ( *a6 )
    {
      v11 = **a6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v16, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v16);
    }
  }
  v13 = a8;
  v17 = 0;
  v9 = 0;
  v10 = 0;
  v15 = &v9;
  if ( a3 )
  {
    if ( *a3 )
    {
      v9 = **a3;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v15);
    }
  }
  v17 = -1;
  return sub_4252E0(a1, a2, v9, v10, a5, v11, v12, v13, v14);
}
// 424BF0: using guessed type char var_10[4];

//----- (00424CD0) --------------------------------------------------------
unsigned int __usercall sub_424CD0@<eax>(int a1@<eax>, int *a2)
{
  _WORD *v2; // ecx
  int *****v3; // esi
  int **v4; // edi
  int ***v5; // eax
  int v6; // ebx
  int *v7; // edi
  int v9; // [esp-10h] [ebp-34h] BYREF
  int v10; // [esp-Ch] [ebp-30h]
  _WORD *v11; // [esp-4h] [ebp-28h]
  int v12[3]; // [esp+Ch] [ebp-18h] BYREF
  _WORD *v13; // [esp+18h] [ebp-Ch]
  _WORD *v14; // [esp+1Ch] [ebp-8h]
  int *v15; // [esp+20h] [ebp-4h] BYREF

  v2 = *(_WORD **)(a1 + 4);
  v13 = *(_WORD **)a1;
  v14 = v2;
  v3 = (int *****)sub_419BC0(v12, a2);
  v4 = 0;
  if ( *v3 )
  {
    v5 = **v3;
    if ( v5 )
    {
      v4 = *v5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v15);
    }
  }
  v6 = (int)v3[2];
  v11 = v13;
  v15 = &v9;
  v9 = 0;
  v10 = 0;
  if ( v4 )
  {
    v7 = *v4;
    if ( v7 )
    {
      v9 = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v15);
    }
  }
  return sub_4257B0(v14, v13, a2, v9, v10, v6, (int)v11);
}
// 424CD0: using guessed type int var_18[3];

//----- (00424D70) --------------------------------------------------------
unsigned int __cdecl sub_424D70(int *a1)
{
  int *****v1; // esi
  int **v2; // edi
  int ***v3; // eax
  int v4; // ebx
  int *v5; // edi
  int v7; // [esp-10h] [ebp-2Ch] BYREF
  int v8; // [esp-Ch] [ebp-28h]
  int *v9; // [esp-4h] [ebp-20h]
  int v10[3]; // [esp+Ch] [ebp-10h] BYREF
  int *v11; // [esp+18h] [ebp-4h] BYREF

  v1 = (int *****)sub_419BC0(v10, a1);
  v2 = 0;
  if ( *v1 )
  {
    v3 = **v1;
    if ( v3 )
    {
      v2 = *v3;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v11, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v11);
    }
  }
  v4 = (int)v1[2];
  v9 = v11;
  v11 = &v7;
  v7 = 0;
  v8 = 0;
  if ( v2 )
  {
    v5 = *v2;
    if ( v5 )
    {
      v7 = *v5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v11, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v11);
    }
  }
  return sub_4257B0(0, 0, a1, v7, v8, v4, (int)v9);
}
// 424D70: using guessed type int var_10[3];

//----- (00424E00) --------------------------------------------------------
_DWORD *__usercall sub_424E00@<eax>(_DWORD *result@<eax>)
{
  int v1; // ecx
  int v2; // ecx

  v1 = result[4];
  if ( v1 )
  {
    if ( (unsigned int)(8 * result[2]) <= ++result[3] )
      result[3] = 0;
    v2 = v1 - 1;
    result[4] = v2;
    if ( !v2 )
      result[3] = 0;
  }
  return result;
}

//----- (00424E30) --------------------------------------------------------
unsigned int __userpurge sub_424E30@<eax>(int a1@<eax>, _WORD *a2)
{
  int v3; // eax
  unsigned int v4; // edi
  unsigned int result; // eax
  unsigned int v6; // esi
  _WORD *v7; // edi
  int pExceptionObject[3]; // [esp+8h] [ebp-10h] BYREF
  char *v9; // [esp+14h] [ebp-4h] BYREF

  v3 = *(_DWORD *)(a1 + 16);
  if ( (((_BYTE)v3 + *(_BYTE *)(a1 + 12)) & 7) == 0 && *(_DWORD *)(a1 + 8) <= (unsigned int)(v3 + 8) >> 3 )
    sub_424EE0(a1);
  v4 = *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 12);
  result = *(_DWORD *)(a1 + 8);
  v6 = v4 >> 3;
  if ( result <= v4 >> 3 )
    v6 -= result;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) )
  {
    result = (unsigned int)operator new(0x10u);
    if ( !result )
    {
      v9 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v9);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) = result;
  }
  v7 = (_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * v6) + 2 * (v4 & 7));
  if ( v7 )
  {
    result = (unsigned int)a2;
    *v7 = *a2;
  }
  ++*(_DWORD *)(a1 + 16);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00424EE0) --------------------------------------------------------
int __usercall sub_424EE0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // eax
  unsigned int v2; // ecx
  unsigned int v3; // edi
  int v4; // esi
  char *v5; // eax
  const void *v6; // ecx
  char *v7; // edx
  unsigned int v8; // ecx
  char *v9; // edi
  size_t v10; // esi
  char *v11; // eax
  int result; // eax
  size_t v13; // [esp+4h] [ebp-10h]
  char *v14; // [esp+Ch] [ebp-8h]
  unsigned int v15; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 8);
  v15 = 1;
  if ( v1 == 0xFFFFFFF )
    std::_Xlength_error("deque<T> too long");
  v2 = v1 >> 1;
  if ( v1 >> 1 >= 8 )
  {
    if ( v2 <= 1 )
      goto LABEL_8;
  }
  else
  {
    v2 = 8;
  }
  if ( v1 <= 0xFFFFFFF - v2 )
    v15 = v2;
LABEL_8:
  v3 = *(_DWORD *)(a1 + 12) >> 3;
  v4 = 4 * v3;
  v14 = (char *)sub_419F70(v1 + v15);
  v13 = 4 * ((int)(4 * *(_DWORD *)(a1 + 8) - 4 * v3) >> 2);
  v5 = (char *)memcpy(&v14[4 * v3], (const void *)(4 * v3 + *(_DWORD *)(a1 + 4)), v13) + v13;
  v6 = *(const void **)(a1 + 4);
  if ( v3 > v15 )
  {
    memcpy(v5, v6, 4 * ((int)(4 * v15) >> 2));
    v10 = 4 * ((int)(v4 - 4 * v15) >> 2);
    v11 = (char *)memcpy(v14, (const void *)(4 * v15 + *(_DWORD *)(a1 + 4)), v10);
    v8 = v15;
    v9 = &v11[v10];
    goto LABEL_14;
  }
  v7 = (char *)memcpy(v5, v6, 4 * (v4 >> 2)) + 4 * (v4 >> 2);
  if ( v15 != v3 )
    memset(v7, 0, 4 * (v15 - v3));
  if ( v3 )
  {
    v8 = v3;
    v9 = v14;
LABEL_14:
    memset(v9, 0, 4 * v8);
  }
  result = *(_DWORD *)(a1 + 4);
  if ( result )
    operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 8) += v15;
  *(_DWORD *)(a1 + 4) = v14;
  return result;
}
// 424FFF: conditional instruction was optimized away because %var_4.4!=0

//----- (00425030) --------------------------------------------------------
_DWORD *__usercall sub_425030@<eax>(_DWORD *a1@<ebx>, int *a2@<esi>, int a3, int a4)
{
  bool v4; // zf
  int **v5; // eax
  int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // eax
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v16[3]; // [esp+0h] [ebp-Ch] BYREF

  v4 = a2[4] == 0;
  for ( *a1 = a3; !v4; *a1 = v11 + 2 )
  {
    if ( *a1 == a4 )
      break;
    v5 = (int **)sub_424480(v16, a2);
    if ( *v5 )
      v6 = **v5;
    else
      v6 = 0;
    v7 = (unsigned int)v5[2];
    v8 = *(_DWORD *)(v6 + 8);
    v9 = v7 >> 3;
    v10 = v7 & 7;
    if ( v8 <= v9 )
      v9 -= v8;
    v11 = *a1;
    *(_WORD *)*a1 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * v9) + 2 * v10);
    v12 = a2[4];
    if ( v12 )
    {
      v13 = a2[2];
      if ( 8 * v13 <= (unsigned int)++a2[3] )
        a2[3] = 0;
      v14 = v12 - 1;
      a2[4] = v14;
      if ( !v14 )
        a2[3] = 0;
    }
    v4 = a2[4] == 0;
  }
  return a1;
}
// 425030: using guessed type int var_C[3];

//----- (004250C0) --------------------------------------------------------
_WORD *__stdcall sub_4250C0(int *a1, int a2, int a3, int a4, _WORD *a5, _WORD *a6, int a7)
{
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  _WORD *result; // eax
  unsigned int v10; // esi
  int v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  char *v16; // edx
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  int v19; // [esp-28h] [ebp-A4h]
  _DWORD **v20[2]; // [esp-24h] [ebp-A0h] BYREF
  int v21; // [esp-1Ch] [ebp-98h]
  int ***v22; // [esp-18h] [ebp-94h] BYREF
  int v23; // [esp-14h] [ebp-90h]
  unsigned int v24; // [esp-10h] [ebp-8Ch]
  int ***v25; // [esp-Ch] [ebp-88h] BYREF
  int v26; // [esp-8h] [ebp-84h]
  unsigned int v27; // [esp-4h] [ebp-80h]
  int v28; // [esp+0h] [ebp-7Ch] BYREF
  char v29; // [esp+10h] [ebp-6Ch] BYREF
  int v30[3]; // [esp+1Ch] [ebp-60h] BYREF
  int v31[3]; // [esp+28h] [ebp-54h] BYREF
  char v32; // [esp+34h] [ebp-48h] BYREF
  int v33[3]; // [esp+40h] [ebp-3Ch] BYREF
  int v34[3]; // [esp+4Ch] [ebp-30h] BYREF
  int v35[3]; // [esp+58h] [ebp-24h] BYREF
  unsigned int v36; // [esp+64h] [ebp-18h]
  unsigned int v37; // [esp+68h] [ebp-14h]
  int *v38; // [esp+6Ch] [ebp-10h]
  int v39; // [esp+78h] [ebp-4h]

  v38 = &v28;
  v7 = sub_424480(v35, a1);
  v8 = a1[4];
  v37 = a4 - v7[2];
  result = a5;
  v10 = v8;
  v36 = v8;
  if ( a5 != a6 )
  {
    if ( v37 > v8 >> 1 )
    {
      v39 = 5;
      while ( result != a6 )
      {
        sub_424E30((int)a1, result);
        result = ++a5;
      }
      v39 = -1;
      sub_419BC0(&v25, a1);
      v21 = v36;
      v39 = 7;
      v17 = sub_424480(v31, a1);
      sub_425470((int)v17, &v22, v21);
      v19 = v37;
      LOBYTE(v39) = 8;
      v18 = sub_424480(v30, a1);
      sub_425470((int)v18, v20, v19);
      v16 = &v29;
      v39 = -1;
    }
    else
    {
      v39 = 0;
      while ( result != a6 )
      {
        sub_4253C0(a1, result);
        result = ++a5;
      }
      v39 = -1;
      v11 = a1[4] - v10;
      v12 = sub_424480(v35, a1);
      sub_425470((int)v12, &v25, v11);
      v39 = 2;
      sub_424480(&v22, a1);
      v39 = -1;
      sub_4254F0(v22, v23, v24, v25, v26, v27);
      v24 = v37;
      v23 = v11;
      v13 = sub_424480(v35, a1);
      v14 = sub_425470((int)v13, v34, v23);
      sub_425470((int)v14, &v25, v24);
      v39 = 3;
      v15 = sub_424480(v33, a1);
      sub_425470((int)v15, &v22, v11);
      LOBYTE(v39) = 4;
      sub_424480(v20, a1);
      v16 = &v32;
      v39 = -1;
    }
    return sub_425570(v16, v20[0], (int)v20[1], v21, (int)v22, v23, v24, (int)v25, v26, v27);
  }
  return result;
}
// 4250C0: using guessed type _DWORD var_24[3];
// 4250C0: using guessed type int var_30[3];
// 4250C0: using guessed type int var_3C[3];
// 4250C0: using guessed type int var_54[3];
// 4250C0: using guessed type int var_60[3];

//----- (004252E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_DWORD *__stdcall sub_4252E0(
        _DWORD *a1,
        int a2,
        int ********a3,
        int a4,
        int a5,
        int ********a6,
        int a7,
        int a8,
        int a9)
{
  int ******v10; // [esp-20h] [ebp-48h] BYREF
  int v11; // [esp-1Ch] [ebp-44h]
  int ******v12; // [esp-14h] [ebp-3Ch] BYREF
  int v13; // [esp-10h] [ebp-38h]
  int v14; // [esp-Ch] [ebp-34h]
  int *******v15; // [esp+14h] [ebp-14h] BYREF
  char v16[4]; // [esp+18h] [ebp-10h] BYREF
  int v17; // [esp+24h] [ebp-4h]

  v12 = 0;
  v13 = 0;
  v15 = &v12;
  if ( a6 )
  {
    if ( *a6 )
    {
      v12 = **a6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v16, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v16);
    }
  }
  v14 = a8;
  v17 = 0;
  v10 = 0;
  v11 = 0;
  v15 = &v10;
  if ( a3 )
  {
    if ( *a3 )
    {
      v10 = **a3;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v15);
    }
  }
  v17 = -1;
  return sub_4256D0(a1, a2, a2, v10, v11, a5, v12, v13, v14);
}
// 4253B1: positive sp value 14 has been found
// 4252E0: using guessed type char var_10[4];

//----- (004253C0) --------------------------------------------------------
_WORD *__userpurge sub_4253C0@<eax>(_DWORD *a1@<eax>, _WORD *a2)
{
  int v3; // edi
  unsigned int v4; // edi
  unsigned int v5; // esi
  void *v6; // eax
  _WORD *result; // eax
  int pExceptionObject[3]; // [esp+8h] [ebp-10h] BYREF
  char *v9; // [esp+14h] [ebp-4h] BYREF

  if ( (a1[3] & 7) == 0 && a1[2] <= (unsigned int)(a1[4] + 8) >> 3 )
    sub_424EE0((int)a1);
  v3 = a1[3];
  if ( !v3 )
    v3 = 8 * a1[2];
  v4 = v3 - 1;
  v5 = v4 >> 3;
  if ( !*(_DWORD *)(a1[1] + 4 * (v4 >> 3)) )
  {
    v6 = operator new(0x10u);
    if ( !v6 )
    {
      v9 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v9);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_DWORD *)(a1[1] + 4 * v5) = v6;
  }
  result = (_WORD *)(*(_DWORD *)(a1[1] + 4 * v5) + 2 * (v4 & 7));
  if ( result )
    *result = *a2;
  ++a1[4];
  a1[3] = v4;
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00425470) --------------------------------------------------------
_DWORD *__userpurge sub_425470@<eax>(int a1@<eax>, _DWORD *a2@<esi>, int a3)
{
  _DWORD *v4; // eax
  _DWORD **v5; // ebx
  _DWORD ***v6; // eax
  int v7; // edi
  _DWORD *v8; // ebx
  char v10[4]; // [esp+8h] [ebp-4h] BYREF

  v4 = *(_DWORD **)a1;
  v5 = 0;
  if ( v4 )
  {
    v6 = (_DWORD ***)*v4;
    if ( v6 )
    {
      v5 = *v6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v10, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v10);
    }
  }
  v7 = a3 + *(_DWORD *)(a1 + 8);
  *a2 = 0;
  a2[1] = 0;
  if ( v5 )
  {
    v8 = *v5;
    if ( !v8 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&a3, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&a3);
      a2[2] = v7;
      return a2;
    }
    *a2 = *v8;
  }
  a2[2] = v7;
  return a2;
}
// 425470: using guessed type char var_4[4];

//----- (004254F0) --------------------------------------------------------
unsigned int __cdecl sub_4254F0(int ***a1, int a2, unsigned int a3, int ***a4, int a5, unsigned int a6)
{
  int v6; // ecx
  int *v7; // eax
  int v8; // eax
  int *v9; // eax
  int v11; // [esp-8h] [ebp-10h]
  char v12[4]; // [esp+4h] [ebp-4h] BYREF

  if ( !a4 )
    goto LABEL_5;
  if ( !*a4 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
    v6 = 0;
    goto LABEL_7;
  }
  v7 = **a4;
  if ( v7 )
    v6 = *v7;
  else
LABEL_5:
    v6 = 0;
LABEL_7:
  v11 = v6;
  if ( !a1 )
  {
LABEL_11:
    v8 = 0;
    return sub_4259B0(a6, v8, a3, v11, a6);
  }
  if ( *a1 )
  {
    v9 = **a1;
    if ( v9 )
    {
      v8 = *v9;
      return sub_4259B0(a6, v8, a3, v11, a6);
    }
    goto LABEL_11;
  }
  std::_Lockit::_Lockit((std::_Lockit *)v12, 3);
  std::_Lockit::~_Lockit((std::_Lockit *)v12);
  v8 = 0;
  return sub_4259B0(a6, v8, a3, v11, a6);
}
// 4254F0: using guessed type char var_4[4];

//----- (00425570) --------------------------------------------------------
_DWORD *__cdecl sub_425570(_DWORD *a1, _DWORD **a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ecx
  int v11; // ecx
  int v12; // ebx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  _DWORD *v17; // esi
  _DWORD **v18; // eax
  _DWORD *v19; // eax
  _DWORD *v21[3]; // [esp-18h] [ebp-78h] BYREF
  _DWORD *v22[7]; // [esp-Ch] [ebp-6Ch] BYREF
  int v23[4]; // [esp+10h] [ebp-50h] BYREF
  int v24[4]; // [esp+20h] [ebp-40h] BYREF
  int *v25; // [esp+30h] [ebp-30h] BYREF
  int v26; // [esp+38h] [ebp-28h]
  unsigned int v27; // [esp+48h] [ebp-18h]
  _DWORD **v28; // [esp+4Ch] [ebp-14h]
  int v29; // [esp+50h] [ebp-10h]
  int v30; // [esp+5Ch] [ebp-4h]

  v10 = a4;
  if ( a4 != a7 && a7 != a10 )
  {
    sub_424AB0(a4, (int)&a8, &v25);
    if ( v25 )
      v29 = *v25;
    else
      v29 = 0;
    v27 = v26;
    sub_424AB0(v26, (int)&a5, v24);
    if ( v24[0] )
      v28 = *(_DWORD ***)v24[0];
    else
      v28 = 0;
    v12 = v24[2];
    sub_424AB0(v11, (int)&a2, v23);
    if ( v23[0] )
      v13 = *(_DWORD *)v23[0];
    else
      v13 = 0;
    sub_425C00(v13, v23[2], (int)v28, v12, v29, v27);
    v28 = v22;
    sub_424AB0(v14, (int)&a8, v22);
    v30 = 0;
    v28 = v21;
    sub_424AB0(v15, (int)&a5, v21);
    v30 = -1;
    v16 = sub_425A30(v21[0], (int)v21[1], (int)v21[2], v22[0], (int)v22[1], (int)v22[2]);
    v10 = v16 + a4;
    a4 += v16;
  }
  v17 = a1;
  v18 = a2;
  *a1 = 0;
  v17[1] = 0;
  if ( v18 )
  {
    v19 = *v18;
    if ( !v19 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&a1, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&a1);
      v17[2] = a4;
      return v17;
    }
    *v17 = *v19;
  }
  v17[2] = v10;
  return v17;
}
// 4255F8: variable 'v11' is possibly undefined
// 42562C: variable 'v14' is possibly undefined
// 425643: variable 'v15' is possibly undefined

//----- (004256D0) --------------------------------------------------------
_DWORD *__stdcall sub_4256D0(_DWORD *a1, int a2, int a3, int ******a4, int a5, int a6, int ******a7, int a8, int a9)
{
  int ****v10; // [esp-1Ch] [ebp-38h] BYREF
  int v11; // [esp-18h] [ebp-34h]
  int ****v12; // [esp-10h] [ebp-2Ch] BYREF
  int v13; // [esp-Ch] [ebp-28h]
  int v14; // [esp-8h] [ebp-24h]
  int v15; // [esp-4h] [ebp-20h]
  int *****v16; // [esp+8h] [ebp-14h] BYREF
  char v17[4]; // [esp+Ch] [ebp-10h] BYREF
  int v18; // [esp+18h] [ebp-4h]

  v15 = a3;
  v12 = 0;
  v13 = 0;
  v16 = &v12;
  if ( a7 )
  {
    if ( *a7 )
    {
      v12 = **a7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v17, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v17);
    }
  }
  v14 = a9;
  v18 = 0;
  v10 = 0;
  v11 = 0;
  v16 = &v10;
  if ( a4 )
  {
    if ( *a4 )
    {
      v10 = **a4;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v16, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v16);
    }
  }
  v18 = -1;
  return sub_425AC0(a1, a2, a3, v10, v11, a6, v12, v13, v14, v15);
}
// 4256D0: using guessed type char var_10[4];

//----- (004257B0) --------------------------------------------------------
unsigned int __fastcall sub_4257B0(_WORD *a1, _WORD *a2, int *a3, int a4, int a5, int a6, int a7)
{
  unsigned int result; // eax
  int v10; // ebx
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  char *v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  int v18; // [esp-28h] [ebp-A4h]
  _DWORD **v19[2]; // [esp-24h] [ebp-A0h] BYREF
  int v20; // [esp-1Ch] [ebp-98h]
  int ***v21; // [esp-18h] [ebp-94h] BYREF
  int v22; // [esp-14h] [ebp-90h]
  unsigned int v23; // [esp-10h] [ebp-8Ch]
  int ***v24; // [esp-Ch] [ebp-88h] BYREF
  int v25; // [esp-8h] [ebp-84h]
  unsigned int v26; // [esp-4h] [ebp-80h]
  int v27; // [esp+0h] [ebp-7Ch] BYREF
  char v28; // [esp+10h] [ebp-6Ch] BYREF
  int v29[3]; // [esp+1Ch] [ebp-60h] BYREF
  int v30[3]; // [esp+28h] [ebp-54h] BYREF
  char v31; // [esp+34h] [ebp-48h] BYREF
  int v32[3]; // [esp+40h] [ebp-3Ch] BYREF
  int v33[3]; // [esp+4Ch] [ebp-30h] BYREF
  int v34[3]; // [esp+58h] [ebp-24h] BYREF
  unsigned int v35; // [esp+64h] [ebp-18h]
  int v36; // [esp+68h] [ebp-14h]
  int *v37; // [esp+6Ch] [ebp-10h]
  int v38; // [esp+78h] [ebp-4h]

  v37 = &v27;
  v35 = a6 - sub_424480(v34, a3)[2];
  result = a3[4];
  v36 = result;
  if ( a2 != a1 )
  {
    if ( v35 > result >> 1 )
    {
      v38 = 5;
      while ( a2 != a1 )
        sub_424E30((int)a3, a2++);
      v38 = -1;
      sub_419BC0(&v24, a3);
      v20 = v36;
      v38 = 7;
      v16 = sub_424480(v30, a3);
      sub_425470((int)v16, &v21, v20);
      v18 = v35;
      LOBYTE(v38) = 8;
      v17 = sub_424480(v29, a3);
      sub_425470((int)v17, v19, v18);
      v15 = &v28;
      v38 = -1;
    }
    else
    {
      v38 = 0;
      while ( a2 != a1 )
        sub_4253C0(a3, a2++);
      v38 = -1;
      v10 = a3[4] - v36;
      v11 = sub_424480(v34, a3);
      sub_425470((int)v11, &v24, v10);
      v38 = 2;
      sub_424480(&v21, a3);
      v38 = -1;
      sub_4254F0(v21, v22, v23, v24, v25, v26);
      v23 = v35;
      v22 = v10;
      v12 = sub_424480(v34, a3);
      v13 = sub_425470((int)v12, v33, v22);
      sub_425470((int)v13, &v24, v23);
      v38 = 3;
      v14 = sub_424480(v32, a3);
      sub_425470((int)v14, &v21, v10);
      LOBYTE(v38) = 4;
      sub_424480(v19, a3);
      v15 = &v31;
      v38 = -1;
    }
    return (unsigned int)sub_425570(v15, v19[0], (int)v19[1], v20, (int)v21, v22, v23, (int)v24, v25, v26);
  }
  return result;
}
// 4257B0: using guessed type _DWORD var_24[3];
// 4257B0: using guessed type int var_30[3];
// 4257B0: using guessed type int var_3C[3];
// 4257B0: using guessed type int var_54[3];
// 4257B0: using guessed type int var_60[3];

//----- (004259B0) --------------------------------------------------------
unsigned int __cdecl sub_4259B0(int a1, int a2, unsigned int a3, int a4, unsigned int a5)
{
  unsigned int result; // eax
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // esi
  int v10; // ecx
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // eax
  __int16 *v14; // ecx
  __int16 *v15; // eax
  __int16 v16; // dx
  unsigned int v17; // [esp+24h] [ebp+18h]

  result = a3;
  v6 = a5;
  if ( a3 != a5 )
  {
    do
    {
      v7 = v6 - 1;
      v17 = v7;
      if ( result == v7 )
        break;
      v8 = *(_DWORD *)(a4 + 8);
      v9 = v7 >> 3;
      v10 = v7 & 7;
      if ( v8 <= v9 )
        v9 -= v8;
      v11 = *(_DWORD *)(a2 + 8);
      v12 = result >> 3;
      v13 = result & 7;
      if ( v11 <= v12 )
        v12 -= v11;
      v14 = (__int16 *)(*(_DWORD *)(*(_DWORD *)(a4 + 4) + 4 * v9) + 2 * v10);
      v15 = (__int16 *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v12) + 2 * v13);
      v16 = *v15;
      *v15 = *v14;
      *v14 = v16;
      v6 = v17;
      result = a3 + 1;
      a3 = result;
    }
    while ( result != v17 );
  }
  return result;
}

//----- (00425A30) --------------------------------------------------------
int __cdecl sub_425A30(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6)
{
  char v7[4]; // [esp+8h] [ebp-14h] BYREF
  char v8[4]; // [esp+Ch] [ebp-10h] BYREF
  int v9; // [esp+18h] [ebp-4h]

  if ( a4 && !*a4 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v8, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)v8);
  }
  v9 = 0;
  if ( a1 && !*a1 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v7, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)v7);
  }
  return a6 - a3;
}
// 425A30: using guessed type char var_10[4];
// 425A30: using guessed type char var_14[4];

//----- (00425AC0) --------------------------------------------------------
_DWORD *__thiscall sub_425AC0(
        _DWORD *this,
        int a2,
        int a3,
        int ****a4,
        int a5,
        int a6,
        int ****a7,
        int a8,
        int a9,
        int a10)
{
  _DWORD *v11; // edx
  int v12; // eax
  int v13; // ecx
  int **v15; // [esp-Ch] [ebp-58h] BYREF
  int v16; // [esp-8h] [ebp-54h]
  int **v17; // [esp+0h] [ebp-4Ch] BYREF
  int v18; // [esp+4h] [ebp-48h]
  int v19; // [esp+8h] [ebp-44h]
  char v20[4]; // [esp+18h] [ebp-34h] BYREF
  int ***v21; // [esp+1Ch] [ebp-30h] BYREF
  void *v22[7]; // [esp+20h] [ebp-2Ch] BYREF
  int v23; // [esp+48h] [ebp-4h]

  v17 = 0;
  v18 = 0;
  v21 = &v17;
  if ( a7 )
  {
    if ( *a7 )
    {
      v17 = **a7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v20, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v20);
    }
  }
  v19 = a9;
  v23 = 0;
  v15 = 0;
  v16 = 0;
  v21 = &v15;
  if ( a4 )
  {
    if ( *a4 )
    {
      v15 = **a4;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v21, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v21);
    }
  }
  v23 = -1;
  sub_425D30(v22, v15, v16, a6, v17, v18, v19);
  v23 = 1;
  if ( this[5] < 8u )
    v11 = this;
  else
    v11 = (_DWORD *)*this;
  v12 = a2;
  if ( a3 )
    v13 = (a3 - a2) >> 1;
  else
    v13 = 0;
  if ( a2 )
    v12 = (a2 - (int)v11) >> 1;
  sub_40C0F0(v12, this, v13, v22, 0, 0xFFFFFFFF);
  if ( v22[5] >= (void *)8 )
    operator delete(v22[0]);
  return this;
}
// 425AC0: using guessed type char var_34[4];

//----- (00425C00) --------------------------------------------------------
int __cdecl sub_425C00(int a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6)
{
  unsigned int v6; // esi
  unsigned int v7; // edi
  int result; // eax
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // ebx
  int *v13; // eax
  int v14; // edi
  unsigned int v15; // ecx
  unsigned int v16; // edx
  unsigned int v17; // esi
  int v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // ebx
  unsigned int v21; // edx
  int v22; // esi
  __int16 v23; // bx
  _WORD *v24; // esi
  __int16 *v25; // edx
  __int16 v26; // ax
  int *v27; // eax
  unsigned int v28; // [esp+14h] [ebp-34h]
  int v29[2]; // [esp+18h] [ebp-30h] BYREF
  int v30[2]; // [esp+20h] [ebp-28h] BYREF
  int v31[2]; // [esp+28h] [ebp-20h] BYREF
  int v32; // [esp+30h] [ebp-18h]
  unsigned int v33; // [esp+3Ch] [ebp-Ch]
  unsigned int v34; // [esp+40h] [ebp-8h]
  int v35; // [esp+44h] [ebp-4h]

  v6 = a2;
  v7 = a6;
  v35 = a4 - a2;
  result = a6 - a2;
  v34 = a6 - a2;
  if ( a2 > a6 )
    v34 = a6 - a2;
  v9 = v35;
  if ( v35 )
  {
    do
    {
      v10 = result % v9;
      result = v9;
      v9 = v10;
    }
    while ( v10 );
    v34 = result;
  }
  if ( result < (int)(a6 - a2) && result > 0 )
  {
    while ( 1 )
    {
      v11 = result + v6;
      v28 = v11;
      v32 = a1;
      v12 = v11;
      if ( v11 + v35 == v7 )
      {
        v13 = &a1;
      }
      else
      {
        v31[1] = v11 + v35;
        v33 = v11;
        v31[0] = a1;
        v13 = v31;
      }
      v14 = *v13;
      v15 = v13[1];
      do
      {
        v16 = *(_DWORD *)(v14 + 8);
        v17 = v15 >> 3;
        v18 = v15 & 7;
        if ( v16 <= v15 >> 3 )
          v17 -= v16;
        v19 = v12;
        v33 = v12 & 7;
        v20 = *(_DWORD *)(v32 + 8);
        v21 = v19 >> 3;
        if ( v20 <= v21 )
          v21 -= v20;
        v22 = *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4 * v17);
        v23 = *(_WORD *)(v22 + 2 * v18);
        v24 = (_WORD *)(v22 + 2 * v18);
        v25 = (__int16 *)(*(_DWORD *)(*(_DWORD *)(v32 + 4) + 4 * v21) + 2 * v33);
        v26 = *v25;
        *v25 = v23;
        *v24 = v26;
        v6 = a2;
        v32 = v14;
        v12 = v15;
        if ( v35 >= (int)(a6 - v15) )
        {
          v29[0] = a1;
          v33 = a2;
          v29[1] = v35 + a2 - (a6 - v15);
          v27 = v29;
        }
        else
        {
          v33 = v15;
          v30[0] = v14;
          v30[1] = v35 + v15;
          v27 = v30;
        }
        v15 = v27[1];
        v14 = *v27;
      }
      while ( v15 != v28 );
      result = v34 - 1;
      v34 = result;
      if ( result <= 0 )
        break;
      v7 = a6;
    }
  }
  return result;
}

//----- (00425D30) --------------------------------------------------------
_DWORD *__userpurge sub_425D30@<eax>(_DWORD *a1@<edi>, int **a2, int a3, int a4, int **a5, int a6, int a7)
{
  int v8; // [esp-1Ch] [ebp-3Ch] BYREF
  int v9; // [esp-18h] [ebp-38h]
  int v10; // [esp-10h] [ebp-30h] BYREF
  int v11; // [esp-Ch] [ebp-2Ch]
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp-4h] [ebp-24h]
  int *v14; // [esp+Ch] [ebp-14h] BYREF
  char v15[4]; // [esp+10h] [ebp-10h] BYREF
  int v16; // [esp+1Ch] [ebp-4h]

  a1[5] = 7;
  a1[4] = 0;
  *(_WORD *)a1 = 0;
  v13 = a7;
  v10 = 0;
  v11 = 0;
  v14 = &v10;
  if ( a5 )
  {
    if ( *a5 )
    {
      v10 = **a5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v15);
    }
  }
  v12 = a7;
  v16 = 0;
  v8 = 0;
  v9 = 0;
  v14 = &v8;
  if ( a2 )
  {
    if ( *a2 )
    {
      v8 = **a2;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v14, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v14);
    }
  }
  v16 = -1;
  sub_425E10(a1, v8, v9, a4, v10, v11, v12, v13);
  return a1;
}
// 425D30: using guessed type char var_10[4];

//----- (00425E10) --------------------------------------------------------
_WORD *__stdcall sub_425E10(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *v8; // edi
  unsigned int v9; // ecx
  _WORD *result; // eax
  unsigned int v11; // esi
  bool v12; // cf
  _DWORD **v13; // esi
  unsigned int v14; // edx
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // [esp+0h] [ebp-38h] BYREF
  _DWORD *v18; // [esp+10h] [ebp-28h]
  char v19[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  char v20[4]; // [esp+20h] [ebp-18h] BYREF
  char v21[4]; // [esp+24h] [ebp-14h] BYREF
  int *v22; // [esp+28h] [ebp-10h]
  int v23; // [esp+34h] [ebp-4h]

  v22 = &v17;
  v8 = 0;
  if ( a5 )
  {
    if ( *(_DWORD *)a5 )
    {
      v8 = **(_DWORD ***)a5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v21, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v21);
    }
  }
  v23 = 0;
  v18 = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)a2 )
    {
      v18 = **(_DWORD ***)a2;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)v20, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)v20);
    }
  }
  v9 = a4;
  v23 = -1;
  if ( v8 && !*v8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v20, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)v20);
    v9 = a4;
  }
  v23 = 1;
  if ( v18 && !*v18 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    v9 = a4;
  }
  result = (_WORD *)(a7 - a4);
  v23 = -1;
  v11 = *((_DWORD *)a1 + 4);
  if ( v11 <= a7 - a4 && *((_WORD **)a1 + 5) != result )
  {
    result = (_WORD *)sub_409410(a1, (int)result, 1);
    if ( (_BYTE)result )
    {
      v12 = *((_DWORD *)a1 + 5) < 8u;
      *((_DWORD *)a1 + 4) = v11;
      if ( v12 )
        result = a1;
      else
        result = *(_WORD **)a1;
      result[v11] = 0;
    }
    v9 = a4;
  }
  v23 = 2;
  while ( v9 != a7 )
  {
    if ( a2 )
      v13 = *(_DWORD ***)a2;
    else
      v13 = 0;
    v14 = (unsigned int)v13[2];
    v15 = v9 >> 3;
    v16 = v9 & 7;
    if ( v14 <= v15 )
      v15 -= v14;
    result = sub_4054C0((int *)a1, (int)v13[1], 1u, *(_WORD *)(v13[1][v15] + 2 * v16));
    v9 = ++a4;
  }
  return result;
}
// 425E10: using guessed type char var_14[4];
// 425E10: using guessed type char var_18[4];
// 425E10: using guessed type char var_1C[4];

//----- (00425FC0) --------------------------------------------------------
void **__stdcall sub_425FC0(void **a1)
{
  *a1 = _Gettnames();
  return a1;
}

//----- (00425FE0) --------------------------------------------------------
struct std::locale::_Locimp *__userpurge sub_425FE0@<eax>(int a1@<edi>, struct std::locale::_Locimp *a2)
{
  void *v2; // eax

  *((_DWORD *)a2 + 1) = 1;
  *(_DWORD *)a2 = &std::locale::_Locimp::`vftable';
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = *(_DWORD *)(a1 + 12);
  *((_DWORD *)a2 + 4) = *(_DWORD *)(a1 + 16);
  *((_BYTE *)a2 + 20) = *(_BYTE *)(a1 + 20);
  v2 = *(void **)(a1 + 24);
  if ( !v2 )
    v2 = (void *)(a1 + 28);
  *((_DWORD *)a2 + 6) = 0;
  *((_BYTE *)a2 + 28) = 0;
  sub_4194F0((void **)a2 + 6, v2);
  std::locale::_Locimp::_Locimp_ctor(a2, (const struct std::locale::_Locimp *)a1);
  return a2;
}
// 4BDB04: using guessed type void *std::locale::_Locimp::`vftable';

//----- (00426070) --------------------------------------------------------
_DWORD *__thiscall sub_426070(ULONG_PTR dwData, int a2)
{
  LRESULT v3; // ebx
  int v4; // eax
  bool v5; // zf
  int v6; // eax
  _DWORD *result; // eax
  HWND v8; // edi
  LONG WindowLongW; // eax
  int *v10; // eax
  int *v11; // edi
  HWND v12; // edi
  LONG v13; // eax
  int v14; // ebx
  WCHAR *v15; // eax
  int v16; // edx
  WCHAR v17; // cx
  int *v18; // ebx
  WPARAM v19; // edi
  WPARAM v20; // eax
  ITEMIDLIST *v21; // edi
  const ITEMIDLIST *v22; // eax
  HWND v23; // ecx
  int v24; // edi
  char **v25; // eax
  int v26; // ecx
  _DWORD **v27; // ecx
  _DWORD *v28; // edi
  HWND v29; // [esp-10h] [ebp-2C4h]
  HWND v30; // [esp-10h] [ebp-2C4h]
  LPARAM v31[13]; // [esp+Ch] [ebp-2A8h] BYREF
  LPARAM lParam[13]; // [esp+40h] [ebp-274h] BYREF
  LPARAM v33[2]; // [esp+74h] [ebp-240h] BYREF
  LRESULT v34; // [esp+7Ch] [ebp-238h]
  const ITEMIDLIST *v35; // [esp+80h] [ebp-234h]
  LPARAM v36; // [esp+84h] [ebp-230h] BYREF
  LPARAM v37; // [esp+88h] [ebp-22Ch]
  int v38; // [esp+8Ch] [ebp-228h]
  IShellFolder *ppshf; // [esp+90h] [ebp-224h] BYREF
  WPARAM v40; // [esp+94h] [ebp-220h]
  int v41; // [esp+98h] [ebp-21Ch]
  int *v42; // [esp+9Ch] [ebp-218h]
  WCHAR pszPath[262]; // [esp+A0h] [ebp-214h] BYREF

  v29 = *(HWND *)(dwData + 28);
  v41 = 0;
  v3 = SendMessageW(v29, 0x1004u, 0, 0);
  v4 = *(_DWORD *)(dwData + 832);
  *(_DWORD *)(dwData + 840) = v4;
  v5 = v3 + v4 == 0;
  v6 = v3 + v4;
  v34 = v3;
  if ( v5 )
  {
    if ( *(_DWORD *)(dwData + 2188) == v6 )
      result = (_DWORD *)SendMessageW(*(HWND *)(dwData + 32), 0x80C9u, *(_DWORD *)(dwData + 776), 1);
    else
      result = (_DWORD *)SendMessageW(*(HWND *)(dwData + 32), 0x80CAu, *(_DWORD *)(dwData + 776), 1);
    *(_DWORD *)(dwData + 680) = 0;
  }
  else
  {
    if ( !*(_DWORD *)(dwData + 2188) )
      SendMessageW(*(HWND *)(dwData + 32), 0x80C9u, *(_DWORD *)(dwData + 776), 0);
    SendMessageW(*(HWND *)(dwData + 28), 0x102Fu, v3 + *(_DWORD *)(dwData + 840), 0);
    lParam[0] = 7;
    if ( a2 )
      lParam[0] = 263;
    v5 = *(_DWORD *)(dwData + 736) == 0;
    lParam[2] = 0;
    if ( !v5 )
    {
      v8 = *(HWND *)(dwData + 28);
      WindowLongW = GetWindowLongW(v8, -16);
      if ( (WindowLongW & 0x100) != 0 )
        WindowLongW &= ~0x100u;
      SetWindowLongW(v8, -16, WindowLongW);
    }
    v10 = *(int **)(dwData + 828);
    v11 = (int *)*v10;
    v42 = v11;
    if ( v11 != v10 )
    {
      while ( 1 )
      {
        v18 = v11 + 3;
        if ( sub_454980(v11[3], dwData) )
        {
          v24 = *(_DWORD *)(dwData + 1152);
          v25 = sub_40A550((char *)v24, *(_DWORD *)(v24 + 4), (int)v18);
          v26 = *(_DWORD *)(dwData + 1156);
          if ( v26 == 1073741822 )
            std::_Xlength_error("list<T> too long");
          *(_DWORD *)(dwData + 1156) = v26 + 1;
          *(_DWORD *)(v24 + 4) = v25;
          *(_DWORD *)v25[1] = v25;
        }
        else
        {
          lParam[1] = v11[2];
          lParam[5] = (LPARAM)sub_4544A0(*v18, (_DWORD *)dwData);
          lParam[7] = -1;
          lParam[8] = *v18;
          if ( a2 )
            lParam[10] = sub_450580(*v18, (_DWORD *)dwData);
          v19 = SendMessageW(*(HWND *)(dwData + 28), 0x104Du, 0, (LPARAM)lParam);
          v40 = v19;
          if ( v42[4] && *(_DWORD *)(dwData + 636) != 4 )
          {
            v20 = v42[5];
            if ( v20 == -1 )
            {
              v36 = 0;
              v37 = 0;
            }
            else
            {
              SendMessageW(*(HWND *)(dwData + 28), 0x1010u, v20, (LPARAM)&v36);
            }
            v33[0] = v36;
            v30 = *(HWND *)(dwData + 28);
            v33[1] = v37;
            SendMessageW(v30, 0x1031u, v19, (LPARAM)v33);
          }
          if ( *(_DWORD *)(dwData + 636) == 5 )
          {
            sub_45E220(v19, (_DWORD *)dwData, *v18);
            v19 = v40;
          }
          if ( *(_DWORD *)(dwData + 844) )
          {
            v21 = ILCombine(*(LPCITEMIDLIST *)(dwData + 76), *(LPCITEMIDLIST *)(560 * *v18 + *(_DWORD *)(dwData + 52)));
            v22 = *(const ITEMIDLIST **)(dwData + 848);
            v35 = v22;
            if ( v21 )
            {
              if ( v22 )
              {
                ppshf = 0;
                v38 = 0;
                if ( SHGetDesktopFolder(&ppshf) >= 0 )
                {
                  if ( !(unsigned __int16)ppshf->lpVtbl->CompareIDs(ppshf, 0, v21, v35) )
                    v38 = 1;
                  ppshf->lpVtbl->Release(ppshf);
                  if ( v38 )
                    *(_DWORD *)(dwData + 844) = 0;
                }
              }
            }
            *(_DWORD *)(dwData + 852) = v40;
            CoTaskMemFree(v21);
            v19 = v40;
          }
          if ( (*(_BYTE *)(592 * *v18 + *(_DWORD *)(dwData + 48)) & 2) != 0 )
          {
            v23 = *(HWND *)(dwData + 28);
            v31[4] = 4;
            v31[3] = 4;
            SendMessageW(v23, 0x102Bu, v19, (LPARAM)v31);
          }
          *(_QWORD *)(dwData + 608) += __PAIR64__(
                                         *(_DWORD *)(*(_DWORD *)(dwData + 48) + 592 * *v18 + 28),
                                         *(_DWORD *)(*(_DWORD *)(dwData + 48) + 592 * *v18 + 32));
          ++v41;
        }
        v42 = (int *)*v42;
        if ( v42 == *(int **)(dwData + 828) )
          break;
        v11 = v42;
      }
      v3 = v34;
    }
    if ( *(_DWORD *)(dwData + 736) )
    {
      v12 = *(HWND *)(dwData + 28);
      v13 = GetWindowLongW(v12, -16);
      if ( (v13 & 0x100) == 0 )
        v13 |= 0x100u;
      SetWindowLongW(v12, -16, v13);
    }
    v5 = *(_DWORD *)(dwData + 636) == 4;
    *(_DWORD *)(dwData + 680) = v41 + v3;
    if ( v5 )
    {
      v14 = 0;
      QueueUserAPC(sub_458A80, *(HANDLE *)(dwData + 60), dwData);
      v15 = pszPath;
      v16 = 260;
      while ( v16 != -2147483386 )
      {
        v17 = *(WCHAR *)((char *)v15 + dwData - (_DWORD)pszPath + 88);
        if ( !v17 )
          break;
        *v15++ = v17;
        if ( !--v16 )
        {
          --v15;
          break;
        }
      }
      *v15 = 0;
      PathStripToRootW(pszPath);
      if ( GetDriveTypeW(pszPath) == 2 || GetDriveTypeW(pszPath) == 4 )
        v14 = 1;
      if ( *(_DWORD *)(dwData + 660) && (!*(_DWORD *)(dwData + 664) || !v14) )
        QueueUserAPC(sub_4574E0, *(HANDLE *)(dwData + 64), dwData);
    }
    sub_459E10(dwData);
    v27 = *(_DWORD ***)(dwData + 828);
    result = *v27;
    *v27 = v27;
    *(_DWORD *)(*(_DWORD *)(dwData + 828) + 4) = *(_DWORD *)(dwData + 828);
    *(_DWORD *)(dwData + 832) = 0;
    if ( result != *(_DWORD **)(dwData + 828) )
    {
      do
      {
        v28 = (_DWORD *)*result;
        operator delete(result);
        result = v28;
      }
      while ( v28 != *(_DWORD **)(dwData + 828) );
    }
    *(_DWORD *)(dwData + 840) = 0;
  }
  return result;
}
// 4264E2: conditional instruction was optimized away because edx.4!=0

//----- (004265A0) --------------------------------------------------------
int __userpurge sub_4265A0@<eax>(char *a1@<eax>, _DWORD *a2@<edi>, char *a3, char *a4)
{
  int v4; // ebx
  char **v5; // eax
  int v6; // ecx
  char *v7; // ebx
  int v8; // esi
  char **v9; // eax
  int v10; // ecx
  int v11; // esi
  char **v12; // eax
  int v13; // ecx
  int v15; // [esp-8h] [ebp-20h]
  int v16; // [esp-8h] [ebp-20h]
  int v17; // [esp-4h] [ebp-1Ch]
  char *v18[4]; // [esp+8h] [ebp-10h] BYREF

  if ( a1 == (char *)-1 )
    v18[0] = (char *)(a2[210] + a2[170] - 1);
  else
    v18[0] = a1;
  v4 = a2[207];
  v18[1] = a3;
  v17 = *(_DWORD *)(v4 + 4);
  v18[2] = a4;
  v18[3] = a1 - 1;
  v5 = sub_420A20(v18, (char *)v4, v17);
  v6 = a2[208];
  if ( v6 == 268435454 )
    std::_Xlength_error("list<T> too long");
  a2[208] = v6 + 1;
  *(_DWORD *)(v4 + 4) = v5;
  v7 = v18[0];
  *(_DWORD *)v5[1] = v5;
  v8 = a2[220];
  v15 = *(_DWORD *)(v8 + 4);
  a3 = v7;
  v9 = sub_40A550((char *)v8, v15, (int)&a3);
  v10 = a2[221];
  if ( v10 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  a2[221] = v10 + 1;
  *(_DWORD *)(v8 + 4) = v9;
  *(_DWORD *)v9[1] = v9;
  v11 = a2[230];
  v16 = *(_DWORD *)(v11 + 4);
  a3 = v7;
  v12 = sub_40A550((char *)v11, v16, (int)&a3);
  v13 = a2[231];
  if ( v13 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  a2[231] = v13 + 1;
  *(_DWORD *)(v11 + 4) = v12;
  *(_DWORD *)v12[1] = v12;
  return 0;
}

//----- (004266B0) --------------------------------------------------------
int __userpurge sub_4266B0@<eax>(const ITEMIDLIST *a1@<ecx>, int a2@<esi>, const ITEMIDLIST *a3, _WORD *a4)
{
  int v4; // edi
  void *v5; // eax
  void *v6; // ecx
  void *v7; // eax
  size_t v8; // edx
  void *v9; // eax
  int v10; // ecx
  int i; // eax
  int v13; // eax
  int v14; // edi
  _WORD *v15; // ecx
  int v16; // ebx
  _WORD *v17; // eax
  ITEMIDLIST *v18; // ebx
  bool v19; // zf
  int v20; // eax
  WCHAR *v21; // edx
  HANDLE FirstFileW; // eax
  int v23; // ebx
  _WORD *v24; // eax
  int v25; // eax
  _WORD *v26; // edx
  _WORD *v27; // ecx
  int v28; // [esp+Ch] [ebp-214h]
  int pidla; // [esp+10h] [ebp-210h]
  WCHAR pszPath[260]; // [esp+14h] [ebp-20Ch] BYREF

  ++*(_DWORD *)(a2 + 840);
  v4 = *(_DWORD *)(a2 + 696);
  if ( *(_DWORD *)(a2 + 840) + *(_DWORD *)(a2 + 680) > v4 - 1 )
  {
    if ( v4 <= 5000 )
      *(_DWORD *)(a2 + 696) = v4 <= 1000 ? v4 + 250 : v4 + 1000;
    else
      *(_DWORD *)(a2 + 696) = v4 + 5000;
    v5 = realloc(*(void **)(a2 + 48), 592 * *(_DWORD *)(a2 + 696));
    v6 = *(void **)(a2 + 52);
    *(_DWORD *)(a2 + 48) = v5;
    v7 = realloc(v6, 560 * *(_DWORD *)(a2 + 696));
    v8 = 4 * *(_DWORD *)(a2 + 696);
    *(_DWORD *)(a2 + 52) = v7;
    v9 = realloc(*(void **)(a2 + 720), v8);
    v10 = *(_DWORD *)(a2 + 696);
    *(_DWORD *)(a2 + 720) = v9;
    for ( i = v4; i < v10; ++i )
      *(_DWORD *)(*(_DWORD *)(a2 + 720) + 4 * i) = 0;
    *(_DWORD *)(a2 + 700) = 0;
    if ( !*(_DWORD *)(a2 + 48) || !*(_DWORD *)(a2 + 52) )
      return -2147024882;
  }
  *(_DWORD *)(a2 + 872) = *(_DWORD *)(a2 + 680) + *(_DWORD *)(a2 + 840);
  v13 = sub_458F70((_DWORD *)a2);
  v14 = 560 * v13;
  v28 = v13;
  *(_DWORD *)(v14 + *(_DWORD *)(a2 + 52)) = ILClone(a1);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + v14 + 528) = 0;
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + v14 + 532) = 0;
  v15 = a4;
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + v14 + 540) = 0;
  v16 = 260;
  v17 = (_WORD *)(*(_DWORD *)(a2 + 52) + v14 + 4);
  while ( v16 != -2147483386 && *v15 )
  {
    *v17++ = *v15++;
    if ( !--v16 )
    {
      --v17;
      break;
    }
  }
  *v17 = 0;
  v18 = ILCombine(a3, a1);
  SHGetPathFromIDListW(v18, pszPath);
  CoTaskMemFree(v18);
  v19 = !PathIsRootW(pszPath);
  v20 = *(_DWORD *)(a2 + 52);
  v21 = pszPath;
  if ( !v19 )
  {
    *(_DWORD *)(v20 + v14 + 544) = 1;
    v23 = 4;
    v24 = (_WORD *)(*(_DWORD *)(a2 + 52) + v14 + 548);
    while ( v23 != -2147483642 && *v21 )
    {
      *v24++ = *v21++;
      if ( !--v23 )
      {
        *(v24 - 1) = 0;
        goto LABEL_26;
      }
    }
    *v24 = 0;
    goto LABEL_26;
  }
  *(_DWORD *)(v20 + v14 + 544) = 0;
  FirstFileW = FindFirstFileW(pszPath, (LPWIN32_FIND_DATAW)(*(_DWORD *)(a2 + 48) + 592 * v28));
  if ( FirstFileW == (HANDLE)-1 )
  {
LABEL_26:
    v25 = 592 * v28;
    v26 = a4;
    pidla = 260;
    v27 = (_WORD *)(*(_DWORD *)(a2 + 48) + 592 * v28 + 44);
    while ( pidla != -2147483386 && *v26 )
    {
      *v27++ = *v26++;
      if ( !--pidla )
      {
        --v27;
        break;
      }
    }
    *v27 = 0;
    *(_DWORD *)(*(_DWORD *)(a2 + 48) + v25 + 32) = 0;
    *(_DWORD *)(*(_DWORD *)(a2 + 48) + v25 + 28) = 0;
    *(_DWORD *)(v25 + *(_DWORD *)(a2 + 48)) = 16;
    *(_DWORD *)(*(_DWORD *)(a2 + 52) + v14 + 524) = 0;
    return v28;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + v14 + 524) = 1;
  FindClose(FirstFileW);
  return v28;
}
// 426856: conditional instruction was optimized away because ebx.4!=0
// 42692A: conditional instruction was optimized away because ebx.4!=0
// 426993: conditional instruction was optimized away because %pidl.4!=0

//----- (004269E0) --------------------------------------------------------
char **__stdcall sub_4269E0(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x210u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x208u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00426A50) --------------------------------------------------------
char **__stdcall sub_426A50(char *a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // edx
  int pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  result = (char **)operator new(0x410u);
  if ( !result )
  {
    a1 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = (char *)a2;
  *result = a1;
  result[1] = v4;
  if ( result != (char **)-8 )
    qmemcpy(result + 2, (const void *)a3, 0x408u);
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00426B1B) --------------------------------------------------------
std::exception *__thiscall sub_426B1B(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 4BDA28: using guessed type void *std::out_of_range::`vftable';

//----- (00426C5F) --------------------------------------------------------
int __thiscall sub_426C5F(_DWORD *this)
{
  return this[1];
}

//----- (00426C63) --------------------------------------------------------
int __thiscall sub_426C63(_DWORD *this)
{
  return this[2];
}

//----- (00426C67) --------------------------------------------------------
int (__thiscall **sub_426C67())(void *, char)
{
  return &off_4DE0D0;
}
// 4DE0D0: using guessed type int (__thiscall *off_4DE0D0)(void *, char);

//----- (00426C6D) --------------------------------------------------------
void *__thiscall sub_426C6D(void *this, char a2)
{
  *(_DWORD *)this = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDA4C: using guessed type void *std::error_category::`vftable';

//----- (00426E4C) --------------------------------------------------------
int sub_426E4C()
{
  return dword_4EE100;
}
// 4EE100: using guessed type int dword_4EE100;

//----- (00427BCA) --------------------------------------------------------
std::exception *__thiscall sub_427BCA(std::exception *this, int a2)
{
  char *v4; // [esp+4h] [ebp-4h] BYREF

  v4 = "regular expression error";
  std::exception::exception(this, (const char *const *)&v4);
  *((_DWORD *)this + 3) = a2;
  *(_DWORD *)this = &std::tr1::regex_error::`vftable';
  return this;
}
// 4BDBC0: using guessed type void *std::tr1::regex_error::`vftable';

//----- (00427C4B) --------------------------------------------------------
std::exception *__thiscall sub_427C4B(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::tr1::regex_error::`vftable';
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  return this;
}
// 4BDBC0: using guessed type void *std::tr1::regex_error::`vftable';

//----- (00427C71) --------------------------------------------------------
void *__thiscall sub_427C71(void *this, char a2)
{
  sub_4398D8((std::exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00427EA5) --------------------------------------------------------
char sub_427EA5()
{
  return 1;
}

//----- (00427EA8) --------------------------------------------------------
int sub_427EA8()
{
  return 1;
}

//----- (00427FE7) --------------------------------------------------------
void *__thiscall sub_427FE7(void *this, char a2)
{
  *(_DWORD *)this = &std::ctype<char>::`vftable';
  std::ctype<char>::_Tidy();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 427EE1: using guessed type int std::ctype<char>::_Tidy(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDBE8: using guessed type void *std::ctype<char>::`vftable';

//----- (00428376) --------------------------------------------------------
int __thiscall sub_428376(_BYTE *this, int a2)
{
  if ( !this[4] )
    unknown_libname_6(this);
  if ( !*(_BYTE *)(a2 + 4) )
    unknown_libname_6(a2);
  if ( *(_DWORD *)this )
  {
    if ( !*(_DWORD *)a2 )
      return 0;
  }
  else if ( *(_DWORD *)a2 )
  {
    return 0;
  }
  return 1;
}
// 428350: using guessed type int __thiscall unknown_libname_6(_DWORD);

//----- (004284EC) --------------------------------------------------------
int __cdecl sub_4284EC(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::num_get<char,std::istreambuf_iterator<char>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 42854A: variable 'v7' is possibly undefined
// 428552: variable 'v4' is possibly undefined
// 4BDC10: using guessed type void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00428576) --------------------------------------------------------
int __cdecl sub_428576(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 4285D4: variable 'v7' is possibly undefined
// 4285DC: variable 'v4' is possibly undefined
// 4BDC44: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (00428600) --------------------------------------------------------
void *__thiscall sub_428600(void *this, char a2)
{
  *(_DWORD *)this = &std::numpunct<char>::`vftable';
  unknown_libname_24();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 42B8A5: using guessed type int unknown_libname_24(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDC90: using guessed type void *std::numpunct<char>::`vftable';

//----- (0042862D) --------------------------------------------------------
int __cdecl sub_42862D(void *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // ecx
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*(_DWORD *)a1 )
  {
    v2 = operator new(0x18u);
    v9 = 0;
    if ( v2 )
    {
      v3 = *(char **)(*(_DWORD *)a2 + 24);
      if ( !v3 )
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      v8 = 1;
      v9 = 2;
      *v2 = &std::numpunct<char>::`vftable';
      std::numpunct<char>::_Init(v4, 1);
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *(_DWORD *)a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 4;
}
// 428236: using guessed type _DWORD __stdcall std::numpunct<char>::_Init(_DWORD, _DWORD);
// 4BDC90: using guessed type void *std::numpunct<char>::`vftable';

//----- (00428828) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_428828(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE230;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE230;
  v2 = std::locale::id::operator unsigned int(&unk_4EE10C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( std::ctype<char>::_Getcat(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE230 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE230: using guessed type int dword_4EE230;
// 428828: using guessed type char var_14[4];

//----- (004288C5) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_4288C5(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE234;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE234;
  v2 = std::locale::id::operator unsigned int(&unk_4F2498);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_4284EC(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE234 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE234: using guessed type int dword_4EE234;
// 4288C5: using guessed type char var_14[4];

//----- (00428962) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_428962(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE238;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE238;
  v2 = std::locale::id::operator unsigned int(&unk_4F24A0);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_428576(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE238 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE238: using guessed type int dword_4EE238;
// 428962: using guessed type char var_14[4];

//----- (004289FF) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_4289FF(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE23C;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE23C;
  v2 = std::locale::id::operator unsigned int(&unk_4F249C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42862D(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE23C = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE23C: using guessed type int dword_4EE23C;
// 4289FF: using guessed type char var_14[4];

//----- (00428A9C) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_428A9C(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE240;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE240;
  v2 = std::locale::id::operator unsigned int(&unk_4EE254);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( std::codecvt<char,char,int>::_Getcat(&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE240 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4286B7: using guessed type _DWORD __cdecl std::codecvt<char,char,int>::_Getcat(_DWORD, _DWORD);
// 4EE240: using guessed type int dword_4EE240;
// 428A9C: using guessed type char var_14[4];

//----- (00429D6C) --------------------------------------------------------
_DWORD *__thiscall sub_429D6C(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        _DWORD **a7,
        _DWORD *a8,
        _WORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v10; // edi
  _WORD *v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  size_t v14; // eax
  size_t v15; // esi
  char *v16; // eax
  unsigned int v17; // esi
  _DWORD *result; // eax
  int v19; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v20; // [esp+14h] [ebp-40h]
  int v21; // [esp+18h] [ebp-3Ch] BYREF
  int v22; // [esp+1Ch] [ebp-38h] BYREF
  int v23; // [esp+20h] [ebp-34h]
  char v24; // [esp+24h] [ebp-30h] BYREF
  char v25; // [esp+25h] [ebp-2Fh] BYREF
  int v26; // [esp+50h] [ebp-4h]

  v9 = a7;
  v10 = a8;
  v11 = a9;
  v22 = 0;
  v20 = a2;
  v23 = (int)this;
  v12 = sub_408A70(a7, &v21);
  v13 = v9[5];
  v26 = 0;
  v14 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(v23, &v24, &a3, &a5, v13, v12);
  v26 = -1;
  v15 = v14;
  sub_408B00(&v21);
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v23 = (int)v16;
  v17 = _Stoulx((int)v16, (int)&v19, v15, (int)&v22);
  if ( (unsigned __int8)sub_428376(&a3, (int)&a5) )
    *v10 |= 1u;
  if ( v19 == v23 || v22 || v17 > 0xFFFF )
  {
    *v10 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v11 = v17;
  }
  result = v20;
  *v20 = a3;
  result[1] = a4;
  return result;
}
// 429318: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00429E3B) --------------------------------------------------------
_DWORD *__thiscall sub_429E3B(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, int *a9)
{
  _DWORD **v9; // esi
  _DWORD *v10; // edi
  int *v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  size_t v14; // eax
  size_t v15; // esi
  char *v16; // eax
  int v17; // esi
  _DWORD *result; // eax
  int v19; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v20; // [esp+14h] [ebp-40h]
  int v21; // [esp+18h] [ebp-3Ch] BYREF
  int v22; // [esp+1Ch] [ebp-38h] BYREF
  int v23; // [esp+20h] [ebp-34h]
  char v24; // [esp+24h] [ebp-30h] BYREF
  char v25; // [esp+25h] [ebp-2Fh] BYREF
  int v26; // [esp+50h] [ebp-4h]

  v9 = a7;
  v10 = a8;
  v11 = a9;
  v22 = 0;
  v20 = a2;
  v23 = (int)this;
  v12 = sub_408A70(a7, &v21);
  v13 = v9[5];
  v26 = 0;
  v14 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(v23, &v24, &a3, &a5, v13, v12);
  v26 = -1;
  v15 = v14;
  sub_408B00(&v21);
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v23 = (int)v16;
  v17 = _Stoulx((int)v16, (int)&v19, v15, (int)&v22);
  if ( (unsigned __int8)sub_428376(&a3, (int)&a5) )
    *v10 |= 1u;
  if ( v19 == v23 || v22 )
  {
    *v10 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v11 = v17;
  }
  result = v20;
  *v20 = a3;
  result[1] = a4;
  return result;
}
// 429318: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042A1D0) --------------------------------------------------------
_DWORD *__thiscall sub_42A1D0(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // eax
  size_t v12; // eax
  int v13; // eax
  int v15; // [esp+10h] [ebp-44h] BYREF
  int v16; // [esp+14h] [ebp-40h] BYREF
  int v17; // [esp+18h] [ebp-3Ch] BYREF
  int v18; // [esp+1Ch] [ebp-38h]
  size_t MaxCount; // [esp+20h] [ebp-34h]
  int v20[11]; // [esp+24h] [ebp-30h] BYREF
  int v21; // [esp+50h] [ebp-4h]

  v9 = a8;
  v10 = a9;
  v17 = 0;
  MaxCount = (size_t)this;
  v11 = sub_408A70(a7, &v16);
  v21 = 0;
  v12 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(MaxCount, v20, &a3, &a5, 2048, v11);
  v21 = -1;
  MaxCount = v12;
  sub_408B00(&v16);
  v13 = _Stoulx((int)v20, (int)&v15, MaxCount, (int)&v17);
  MaxCount = 0;
  v18 = v13;
  if ( (unsigned __int8)sub_428376(&a3, (int)&a5) )
    *v9 |= 1u;
  if ( (int *)v15 == v20 || v17 )
    *v9 |= 2u;
  else
    *v10 = v18;
  *a2 = a3;
  a2[1] = a4;
  return a2;
}
// 429318: using guessed type _DWORD __cdecl std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042B0B9) --------------------------------------------------------
int __thiscall sub_42B0B9(void *this, int a2, int a3, int a4, int a5, char a6, double a7)
{
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  double v10; // st7
  int v11; // ecx
  unsigned int v12; // ebx
  int v13; // et0
  double v14; // st7
  double v15; // st6
  double v16; // st5
  double v17; // st4
  double v18; // st5
  double v19; // rt2
  double v20; // rtt
  double v21; // st4
  double v22; // rt0
  double v23; // st5
  double v24; // st7
  bool v25; // cf
  const char *v26; // eax
  int v27; // eax
  int v30; // [esp+1Ch] [ebp-88h]
  unsigned int v31; // [esp+20h] [ebp-84h]
  unsigned int v32; // [esp+24h] [ebp-80h]
  char v33; // [esp+2Bh] [ebp-79h]
  char Buffer[108]; // [esp+2Ch] [ebp-78h] BYREF
  char v35[4]; // [esp+98h] [ebp-Ch] BYREF
  int v36; // [esp+9Ch] [ebp-8h]

  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v8) <= 0 && (*(_DWORD *)(a5 + 20) & 0x2000) == 0 )
  {
    v8 = 6;
    v7 = 0;
  }
  v9 = v8;
  v36 = v7;
  if ( v7 < 0 || v7 <= 0 && v8 <= 0x24 )
    v30 = v8;
  else
    v30 = 36;
  v10 = a7;
  v11 = *(_DWORD *)(a5 + 20);
  v13 = (__PAIR64__(v36, v9) - v30) >> 32;
  v12 = v9 - v30;
  v36 = v13;
  v32 = 0;
  v31 = 0;
  if ( (v11 & 0x3000) == 0x2000 && a7 != 0.5 * a7 )
  {
    if ( a7 >= 0.0 )
    {
      v33 = 0;
      v15 = a7;
      v14 = 0.0;
    }
    else
    {
      v14 = 0.0;
      v33 = 1;
      v15 = -a7;
    }
    v16 = 1.0e35;
    v17 = 1.0e10;
    if ( v15 >= 1.0e35 )
    {
      while ( v32 < 0x1388 )
      {
        v15 = v15 / v17;
        v32 += 10;
        v20 = v17;
        v21 = v16;
        v18 = v20;
        if ( v21 > v15 )
          goto LABEL_19;
        v19 = v21;
        v17 = v18;
        v16 = v19;
      }
    }
    v18 = v17;
LABEL_19:
    v22 = v18;
    v23 = v14;
    v24 = v22;
    if ( v23 < v15 && v36 >= 0 )
    {
      if ( v36 > 0 )
      {
LABEL_23:
        while ( v15 <= 1.0e-35 && v31 < 0x1388 )
        {
          v25 = __CFADD__(v12, -10);
          v12 -= 10;
          v15 = v15 * v24;
          v36 = v25 + v36 - 1;
          v31 += 10;
          if ( v36 <= 0 )
          {
            if ( v36 >= 0 )
              goto LABEL_22;
            break;
          }
        }
      }
      else
      {
LABEL_22:
        if ( v12 >= 0xA )
          goto LABEL_23;
      }
    }
    v10 = v15;
    if ( v33 )
      v10 = -v15;
  }
  v26 = (const char *)unknown_libname_44(this, v35, 0, v11);
  v27 = sprintf_s(Buffer, 0x6Cu, v26, v30, v10);
  std::num_put<char,std::ostreambuf_iterator<char>>::_Fput((int)this, a2, a3, a4, a5, a6, Buffer, v32, v31, v12, v27);
  return a2;
}
// 42BF12: using guessed type _DWORD __cdecl unknown_libname_44(_DWORD, _DWORD, char, _DWORD);
// 42B0B9: using guessed type char var_C[4];

//----- (0042B279) --------------------------------------------------------
int __thiscall sub_42B279(void *this, int a2, int a3, int a4, int a5, char a6, double a7)
{
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  int v10; // ecx
  unsigned int v11; // ebx
  int v12; // et0
  double v13; // st6
  double v14; // st5
  double v15; // st4
  double v16; // st5
  double v17; // rt0
  double v18; // rt1
  double v19; // st4
  bool v20; // cf
  double v21; // st7
  const char *v22; // eax
  int v23; // eax
  int v26; // [esp+1Ch] [ebp-88h]
  unsigned int v27; // [esp+20h] [ebp-84h]
  unsigned int v28; // [esp+24h] [ebp-80h]
  char v29; // [esp+2Bh] [ebp-79h]
  char Buffer[108]; // [esp+2Ch] [ebp-78h] BYREF
  char v31[4]; // [esp+98h] [ebp-Ch] BYREF
  int v32; // [esp+9Ch] [ebp-8h]

  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v8) <= 0 && (*(_DWORD *)(a5 + 20) & 0x2000) == 0 )
  {
    v8 = 6;
    v7 = 0;
  }
  v9 = v8;
  v32 = v7;
  if ( v7 < 0 || v7 <= 0 && v8 <= 0x24 )
    v26 = v8;
  else
    v26 = 36;
  v10 = *(_DWORD *)(a5 + 20);
  v12 = (__PAIR64__(v32, v9) - v26) >> 32;
  v11 = v9 - v26;
  v32 = v12;
  v28 = 0;
  v27 = 0;
  if ( (v10 & 0x3000) == 0x2000 )
  {
    v13 = a7;
    if ( a7 >= 0.0 )
    {
      v29 = 0;
    }
    else
    {
      v29 = 1;
      v13 = -a7;
    }
    v14 = 1.0e35;
    v15 = 1.0e10;
    if ( v13 >= 1.0e35 )
    {
      while ( v28 < 0x1388 )
      {
        v13 = v13 / v15;
        v28 += 10;
        v18 = v15;
        v19 = v14;
        v16 = v18;
        if ( v19 > v13 )
          goto LABEL_18;
        v17 = v19;
        v15 = v16;
        v14 = v17;
      }
    }
    v16 = v15;
LABEL_18:
    if ( v13 > 0.0 && v32 >= 0 )
    {
      if ( v32 > 0 )
      {
LABEL_22:
        while ( v13 <= 1.0e-35 && v27 < 0x1388 )
        {
          v20 = __CFADD__(v11, -10);
          v11 -= 10;
          v13 = v13 * v16;
          v32 = v20 + v32 - 1;
          v27 += 10;
          if ( v32 <= 0 )
          {
            if ( v32 >= 0 )
              goto LABEL_21;
            break;
          }
        }
      }
      else
      {
LABEL_21:
        if ( v11 >= 0xA )
          goto LABEL_22;
      }
    }
    v21 = v13;
    if ( v29 )
      v21 = -v13;
  }
  else
  {
    v21 = a7;
  }
  v22 = (const char *)unknown_libname_44(this, v31, 76, v10);
  v23 = sprintf_s(Buffer, 0x6Cu, v22, v26, v21);
  std::num_put<char,std::ostreambuf_iterator<char>>::_Fput((int)this, a2, a3, a4, a5, a6, Buffer, v28, v27, v11, v23);
  return a2;
}
// 42BF12: using guessed type _DWORD __cdecl unknown_libname_44(_DWORD, _DWORD, char, _DWORD);
// 42B279: using guessed type char var_C[4];

//----- (0042B623) --------------------------------------------------------
void __cdecl sub_42B623(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (0042B913) --------------------------------------------------------
char sub_42B913()
{
  return 0;
}

//----- (0042B916) --------------------------------------------------------
int sub_42B916()
{
  return 5;
}

//----- (0042BD36) --------------------------------------------------------
int __stdcall sub_42BD36(char a1)
{
  return unknown_libname_38(a1);
}
// 42BD00: using guessed type _DWORD __stdcall unknown_libname_38(char);

//----- (0042BDBC) --------------------------------------------------------
int __stdcall sub_42BDBC(wchar_t a1, char a2)
{
  return unknown_libname_39(a1, a2);
}

//----- (0042C08A) --------------------------------------------------------
int __stdcall sub_42C08A(int a1, int a2, int a3, int a4)
{
  return std::_LStrcoll<unsigned short>(a1, a2, a3, a4);
}
// 42C011: using guessed type _DWORD __cdecl std::_LStrcoll<unsigned short>(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042C0AE) --------------------------------------------------------
void *__thiscall sub_42C0AE(void *this, char a2)
{
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';

//----- (0042C113) --------------------------------------------------------
int __thiscall sub_42C113(_DWORD *this)
{
  return this[7];
}

//----- (0042C144) --------------------------------------------------------
void *__thiscall sub_42C144(void *this, char a2)
{
  unknown_libname_49();
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 42C128: using guessed type int unknown_libname_49(void);

//----- (0042C360) --------------------------------------------------------
_DWORD *__cdecl sub_42C360(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax

  for ( ; a5; --a5 )
    sub_40DE80(&a2, a4);
  result = a1;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (0042C7CF) --------------------------------------------------------
int __thiscall sub_42C7CF(_BYTE *this, int a2)
{
  if ( !this[4] )
    unknown_libname_54(this);
  if ( !*(_BYTE *)(a2 + 4) )
    unknown_libname_54(a2);
  if ( *(_DWORD *)this )
  {
    if ( !*(_DWORD *)a2 )
      return 0;
  }
  else if ( *(_DWORD *)a2 )
  {
    return 0;
  }
  return 1;
}
// 42C79F: using guessed type int __thiscall unknown_libname_54(_DWORD);

//----- (0042CA0D) --------------------------------------------------------
int __cdecl sub_42CA0D(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  bool v4; // zf
  char v6[36]; // [esp+10h] [ebp-34h] BYREF
  int v7; // [esp+34h] [ebp-10h]
  int v8; // [esp+40h] [ebp-4h]

  v7 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(8u);
    v8 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v6, v3);
      v2[1] = 0;
      v7 = 1;
      *v2 = &std::messages<wchar_t>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v8 = -1;
    v4 = (v7 & 1) == 0;
    *a1 = v2;
    if ( !v4 )
      sub_408790((std::_Lockit *)v6);
  }
  return 6;
}
// 4BDE64: using guessed type void *std::messages<wchar_t>::`vftable';

//----- (0042CA8C) --------------------------------------------------------
int __cdecl sub_42CA8C(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 42CAEA: variable 'v7' is possibly undefined
// 42CAF2: variable 'v4' is possibly undefined
// 4BDE78: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0042CB16) --------------------------------------------------------
int __cdecl sub_42CB16(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 42CB74: variable 'v7' is possibly undefined
// 42CB7C: variable 'v4' is possibly undefined
// 4BDE88: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0042CBA0) --------------------------------------------------------
int __cdecl sub_42CBA0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 42CBFE: variable 'v7' is possibly undefined
// 42CC06: variable 'v4' is possibly undefined
// 4BDEC4: using guessed type void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (0042CC2A) --------------------------------------------------------
int __cdecl sub_42CC2A(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 4;
}
// 42CC88: variable 'v7' is possibly undefined
// 42CC90: variable 'v4' is possibly undefined
// 4BDEF8: using guessed type void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0042CCB9) --------------------------------------------------------
void *__thiscall sub_42CCB9(void *this, char a2)
{
  *(_DWORD *)this = &std::numpunct<unsigned short>::`vftable';
  unknown_libname_24();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 42B8A5: using guessed type int unknown_libname_24(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE0A0: using guessed type void *std::numpunct<unsigned short>::`vftable';

//----- (0042CCE6) --------------------------------------------------------
int __cdecl sub_42CCE6(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // ecx
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x18u);
    v9 = 0;
    if ( v2 )
    {
      v3 = *(char **)(*(_DWORD *)a2 + 24);
      if ( !v3 )
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      v8 = 1;
      v9 = 2;
      *v2 = &std::numpunct<unsigned short>::`vftable';
      std::numpunct<wchar_t>::_Init(v4, 1);
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 4;
}
// 42C1D6: using guessed type _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BE0A0: using guessed type void *std::numpunct<unsigned short>::`vftable';

//----- (0042CD70) --------------------------------------------------------
int __cdecl sub_42CD70(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  bool v4; // zf
  char v6[36]; // [esp+10h] [ebp-34h] BYREF
  int v7; // [esp+34h] [ebp-10h]
  int v8; // [esp+40h] [ebp-4h]

  v7 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(8u);
    v8 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v6, v3);
      v2[1] = 0;
      v7 = 1;
      *v2 = &std::messages<unsigned short>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v8 = -1;
    v4 = (v7 & 1) == 0;
    *a1 = v2;
    if ( !v4 )
      sub_408790((std::_Lockit *)v6);
  }
  return 6;
}
// 4BDF34: using guessed type void *std::messages<unsigned short>::`vftable';

//----- (0042CDEF) --------------------------------------------------------
int __cdecl sub_42CDEF(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 42CE4D: variable 'v7' is possibly undefined
// 42CE55: variable 'v4' is possibly undefined
// 4BDF48: using guessed type void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (0042CE79) --------------------------------------------------------
int __cdecl sub_42CE79(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 42CED7: variable 'v7' is possibly undefined
// 42CEDF: variable 'v4' is possibly undefined
// 4BDF58: using guessed type void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0042CF03) --------------------------------------------------------
int __cdecl sub_42CF03(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x14u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      *v2 = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v8 = 1;
      v2[2] = 0;
      unknown_libname_75(v2, v4);
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 5;
}
// 436387: using guessed type int __thiscall unknown_libname_75(_DWORD, _DWORD);
// 4BDF94: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0042CF8B) --------------------------------------------------------
int __thiscall sub_42CF8B(int this, std::_Locinfo *a2)
{
  int v3; // edx
  char *v4; // eax
  char *v5; // eax
  int result; // eax
  _Cvtvec *v7; // [esp+0h] [ebp-24h]

  *(_DWORD *)(this + 20) = _Getcvt(v7);
  *(_DWORD *)(this + 24) = v3;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v4 = (char *)std::_Locinfo::_Getdays(a2);
  *(_DWORD *)(this + 8) = sub_4076D0(v4, 0, (_Cvtvec *)(this + 20));
  v5 = (char *)std::_Locinfo::_Getmonths(a2);
  *(_DWORD *)(this + 12) = sub_4076D0(v5, 0, (_Cvtvec *)(this + 20));
  result = _Getdateorder();
  *(_DWORD *)(this + 16) = result;
  return result;
}
// 42CF9C: variable 'v7' is possibly undefined
// 42CFAD: variable 'v3' is possibly undefined
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4393A5: using guessed type int _Getdateorder(void);

//----- (0042D06F) --------------------------------------------------------
int __thiscall sub_42D06F(int this, std::_Locinfo *a2)
{
  int v3; // edx
  char *v4; // eax
  char *v5; // eax
  int result; // eax
  _Cvtvec *v7; // [esp+0h] [ebp-24h]

  *(_DWORD *)(this + 20) = _Getcvt(v7);
  *(_DWORD *)(this + 24) = v3;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v4 = (char *)std::_Locinfo::_Getdays(a2);
  *(_DWORD *)(this + 8) = unknown_libname_22(v4, 0, (_Cvtvec *)(this + 20));
  v5 = (char *)std::_Locinfo::_Getmonths(a2);
  *(_DWORD *)(this + 12) = unknown_libname_22(v5, 0, (_Cvtvec *)(this + 20));
  result = _Getdateorder();
  *(_DWORD *)(this + 16) = result;
  return result;
}
// 42D080: variable 'v7' is possibly undefined
// 42D091: variable 'v3' is possibly undefined
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4393A5: using guessed type int _Getdateorder(void);

//----- (0042D2FF) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D2FF(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2A4;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2A4;
  v2 = std::locale::id::operator unsigned int(&unk_4EE120);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( std::ctype<wchar_t>::_Getcat(&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2A4 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 42C986: using guessed type _DWORD __cdecl std::ctype<wchar_t>::_Getcat(_DWORD, _DWORD);
// 4EE2A4: using guessed type int dword_4EE2A4;
// 42D2FF: using guessed type char var_14[4];

//----- (0042D39C) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D39C(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2A8;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2A8;
  v2 = std::locale::id::operator unsigned int(&unk_4EE310);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CA0D(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2A8 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2A8: using guessed type int dword_4EE2A8;
// 42D39C: using guessed type char var_14[4];

//----- (0042D439) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D439(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2AC;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2AC;
  v2 = std::locale::id::operator unsigned int(&unk_4EE328);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CA8C(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2AC = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2AC: using guessed type int dword_4EE2AC;
// 42D439: using guessed type char var_14[4];

//----- (0042D4D6) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D4D6(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2B0;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2B0;
  v2 = std::locale::id::operator unsigned int(&unk_4EE32C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CB16(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2B0 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2B0: using guessed type int dword_4EE2B0;
// 42D4D6: using guessed type char var_14[4];

//----- (0042D573) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D573(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2B4;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2B4;
  v2 = std::locale::id::operator unsigned int(&unk_4EE118);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( std::codecvt<wchar_t,char,int>::_Getcat(&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2B4 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 42C872: using guessed type _DWORD __cdecl std::codecvt<wchar_t,char,int>::_Getcat(_DWORD, _DWORD);
// 4EE2B4: using guessed type int dword_4EE2B4;
// 42D573: using guessed type char var_14[4];

//----- (0042D610) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D610(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2B8;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2B8;
  v2 = std::locale::id::operator unsigned int(&unk_4EE324);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CBA0(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2B8 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2B8: using guessed type int dword_4EE2B8;
// 42D610: using guessed type char var_14[4];

//----- (0042D6AD) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D6AD(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2BC;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2BC;
  v2 = std::locale::id::operator unsigned int(&unk_4EE31C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CC2A(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2BC = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2BC: using guessed type int dword_4EE2BC;
// 42D6AD: using guessed type char var_14[4];

//----- (0042D74A) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D74A(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2C0;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2C0;
  v2 = std::locale::id::operator unsigned int(&unk_4EE318);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CCE6(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2C0 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2C0: using guessed type int dword_4EE2C0;
// 42D74A: using guessed type char var_14[4];

//----- (0042D7E7) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D7E7(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2C4;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2C4;
  v2 = std::locale::id::operator unsigned int(&unk_4EE30C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CD70(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2C4 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2C4: using guessed type int dword_4EE2C4;
// 42D7E7: using guessed type char var_14[4];

//----- (0042D884) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D884(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2C8;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2C8;
  v2 = std::locale::id::operator unsigned int(&unk_4EE2F4);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CDEF(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2C8 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2C8: using guessed type int dword_4EE2C8;
// 42D884: using guessed type char var_14[4];

//----- (0042D921) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D921(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2CC;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2CC;
  v2 = std::locale::id::operator unsigned int(&unk_4EE330);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CE79(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2CC = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2CC: using guessed type int dword_4EE2CC;
// 42D921: using guessed type char var_14[4];

//----- (0042D9BE) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42D9BE(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2D0;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2D0;
  v2 = std::locale::id::operator unsigned int(&unk_4EE304);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42CF03(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2D0 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2D0: using guessed type int dword_4EE2D0;
// 42D9BE: using guessed type char var_14[4];

//----- (0042DA5B) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42DA5B(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2D4;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2D4;
  v2 = std::locale::id::operator unsigned int(&unk_4EE110);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( std::codecvt<wchar_t,char,int>::_Getcat(&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2D4 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 42C8FC: using guessed type _DWORD __cdecl std::codecvt<wchar_t,char,int>::_Getcat(_DWORD, _DWORD);
// 4EE2D4: using guessed type int dword_4EE2D4;
// 42DA5B: using guessed type char var_14[4];

//----- (0042DAF8) --------------------------------------------------------
int __cdecl sub_42DAF8(void *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*(_DWORD *)a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v8 = 1;
      v2[1] = 0;
      v9 = 2;
      *v2 = &std::_Mpunct<wchar_t>::`vftable';
      *((_BYTE *)v2 + 40) = 0;
      std::_Mpunct<wchar_t>::_Init(v4, 1);
      *v2 = &std::moneypunct<wchar_t,0>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *(_DWORD *)a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 42C38B: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BDE98: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4BE0BC: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';

//----- (0042DB8D) --------------------------------------------------------
void *__thiscall sub_42DB8D(void *this, char a2)
{
  *(_DWORD *)this = &std::_Mpunct<wchar_t>::`vftable';
  unknown_libname_73();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 436344: using guessed type int unknown_libname_73(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDE98: using guessed type void *std::_Mpunct<wchar_t>::`vftable';

//----- (0042DBBA) --------------------------------------------------------
int __cdecl sub_42DBBA(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      v8 = 1;
      *((_BYTE *)v2 + 40) = 1;
      v9 = 2;
      *v2 = &std::_Mpunct<wchar_t>::`vftable';
      std::_Mpunct<wchar_t>::_Init(v4, 1);
      *v2 = &std::moneypunct<wchar_t,1>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 42C38B: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BDE98: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4BE0E8: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';

//----- (0042DC51) --------------------------------------------------------
_DWORD *__thiscall sub_42DC51(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
  sub_42CF8B((int)this, a2);
  return this;
}
// 4BE114: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0042DC84) --------------------------------------------------------
void *__thiscall sub_42DC84(void *this, char a2)
{
  *(_DWORD *)this = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
  unknown_libname_74(this);
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE114: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0042DCB1) --------------------------------------------------------
int __cdecl sub_42DCB1(void *a1, int a2)
{
  char *v3; // eax
  std::_Locinfo *v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]
  _DWORD *v11; // [esp+4Ch] [ebp+8h]

  v9 = 0;
  if ( a1 && !*(_DWORD *)a1 )
  {
    v11 = operator new(0x1Cu);
    v10 = 0;
    if ( v11 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v8, v3);
      LOBYTE(v10) = 1;
      v9 = 1;
      v5 = sub_42DC51(v11, v4, 0);
    }
    else
    {
      v5 = 0;
    }
    v10 = -1;
    v6 = (v9 & 1) == 0;
    *(_DWORD *)a1 = v5;
    if ( !v6 )
      sub_408790((std::_Lockit *)v8);
  }
  return 5;
}

//----- (0042DD33) --------------------------------------------------------
void *__thiscall sub_42DD33(void *this, char a2)
{
  *(_DWORD *)this = &std::_Mpunct<unsigned short>::`vftable';
  unknown_libname_73();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 436344: using guessed type int unknown_libname_73(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BDF68: using guessed type void *std::_Mpunct<unsigned short>::`vftable';

//----- (0042DD60) --------------------------------------------------------
int __cdecl sub_42DD60(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v8 = 1;
      v2[1] = 0;
      v9 = 2;
      *v2 = &std::_Mpunct<unsigned short>::`vftable';
      *((_BYTE *)v2 + 40) = 0;
      std::_Mpunct<wchar_t>::_Init(v4, 1);
      *v2 = &std::moneypunct<unsigned short,0>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 42C61C: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BDF68: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 4BE138: using guessed type void *std::moneypunct<unsigned short,0>::`vftable';

//----- (0042DDF5) --------------------------------------------------------
int __cdecl sub_42DDF5(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      v8 = 1;
      *((_BYTE *)v2 + 40) = 1;
      v9 = 2;
      *v2 = &std::_Mpunct<unsigned short>::`vftable';
      std::_Mpunct<wchar_t>::_Init(v4, 1);
      *v2 = &std::moneypunct<unsigned short,1>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 42C61C: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BDF68: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 4BE164: using guessed type void *std::moneypunct<unsigned short,1>::`vftable';

//----- (0042DE8C) --------------------------------------------------------
_DWORD *__thiscall sub_42DE8C(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
  sub_42D06F((int)this, a2);
  return this;
}
// 4BE190: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (0042DEBF) --------------------------------------------------------
int __thiscall sub_42DEBF(_DWORD *this)
{
  return this[4];
}

//----- (0042DEC3) --------------------------------------------------------
void *__thiscall sub_42DEC3(void *this, char a2)
{
  *(_DWORD *)this = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
  unknown_libname_74(this);
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE190: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (0042DEF0) --------------------------------------------------------
int __cdecl sub_42DEF0(_DWORD *a1, int a2)
{
  char *v3; // eax
  std::_Locinfo *v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]
  _DWORD *v11; // [esp+4Ch] [ebp+8h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v11 = operator new(0x1Cu);
    v10 = 0;
    if ( v11 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v8, v3);
      LOBYTE(v10) = 1;
      v9 = 1;
      v5 = sub_42DE8C(v11, v4, 0);
    }
    else
    {
      v5 = 0;
    }
    v10 = -1;
    v6 = (v9 & 1) == 0;
    *a1 = v5;
    if ( !v6 )
      sub_408790((std::_Lockit *)v8);
  }
  return 5;
}

//----- (0042E6AF) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E6AF(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2D8;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2D8;
  v2 = std::locale::id::operator unsigned int(&unk_4EE314);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DAF8(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2D8 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2D8: using guessed type int dword_4EE2D8;
// 42E6AF: using guessed type char var_14[4];

//----- (0042E74C) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E74C(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2DC;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2DC;
  v2 = std::locale::id::operator unsigned int(&unk_4EE2FC);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DBBA(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2DC = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2DC: using guessed type int dword_4EE2DC;
// 42E74C: using guessed type char var_14[4];

//----- (0042E7E9) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E7E9(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2E0;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2E0;
  v2 = std::locale::id::operator unsigned int(&unk_4EE300);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DCB1(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2E0 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2E0: using guessed type int dword_4EE2E0;
// 42E7E9: using guessed type char var_14[4];

//----- (0042E886) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E886(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2E4;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2E4;
  v2 = std::locale::id::operator unsigned int(&unk_4EE320);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DD60(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2E4 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2E4: using guessed type int dword_4EE2E4;
// 42E886: using guessed type char var_14[4];

//----- (0042E923) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E923(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2E8;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2E8;
  v2 = std::locale::id::operator unsigned int(&unk_4EE334);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DDF5(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2E8 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2E8: using guessed type int dword_4EE2E8;
// 42E923: using guessed type char var_14[4];

//----- (0042E9C0) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_42E9C0(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2EC;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2EC;
  v2 = std::locale::id::operator unsigned int(&unk_4EE2F8);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_42DEF0(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2EC = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2EC: using guessed type int dword_4EE2EC;
// 42E9C0: using guessed type char var_14[4];

//----- (0042F5F5) --------------------------------------------------------
_DWORD *__thiscall sub_42F5F5(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, int a9)
{
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // esi
  _DWORD *result; // eax
  int v13; // [esp+0h] [ebp-4h] BYREF

  v13 = 0;
  v9 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 2035, &v13);
  v10 = a8;
  *a8 |= v9;
  if ( (*v10 & 2) == 0 )
  {
    v11 = v13;
    if ( v13 < 1900 )
    {
      if ( v13 > 135 )
        *v10 |= 2u;
    }
    else
    {
      v11 = v13 - 1900;
    }
    *(_DWORD *)(a9 + 20) = v11;
  }
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 42E3B2: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00430215) --------------------------------------------------------
int __thiscall sub_430215(_DWORD *this, unsigned int a2, int a3)
{
  unsigned int v3; // edx

  v3 = this[4];
  if ( a2 > v3 )
    return std::wstring::append(a2 - v3, a3);
  else
    return unknown_libname_55(a2, -1);
}
// 42D178: using guessed type _DWORD __stdcall unknown_libname_55(_DWORD, _DWORD);
// 42F8A1: using guessed type _DWORD __stdcall std::wstring::append(_DWORD, _DWORD);

//----- (00430685) --------------------------------------------------------
_DWORD *__stdcall sub_430685(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5)
{
  sub_409E30(a1, a5);
  return a1;
}

//----- (004306A1) --------------------------------------------------------
int *__thiscall sub_4306A1(int *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, int a9)
{
  int v9; // eax
  int *result; // eax

  v9 = sub_406EB0((int)&a3, (int)&a5, 0, this[2]);
  if ( v9 >= 0 )
    *(_DWORD *)(a9 + 24) = v9 >> 1;
  else
    *a8 |= 2u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}

//----- (004306E1) --------------------------------------------------------
int *__thiscall sub_4306E1(int *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, int a9)
{
  int v9; // eax
  int *result; // eax

  v9 = sub_406EB0((int)&a3, (int)&a5, 0, this[3]);
  if ( v9 >= 0 )
    *(_DWORD *)(a9 + 16) = v9 >> 1;
  else
    *a8 |= 2u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}

//----- (00430CE1) --------------------------------------------------------
int *__thiscall sub_430CE1(
        void *this,
        int *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        _DWORD *a8,
        _DWORD *a9,
        char a10,
        int a11)
{
  _DWORD *v11; // esi
  int v12; // eax
  int *v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int *result; // eax
  int v18; // [esp-8h] [ebp-64h]
  int v19; // [esp-8h] [ebp-64h]
  _DWORD *v20; // [esp-4h] [ebp-60h]
  _DWORD *v21; // [esp-4h] [ebp-60h]
  char v22[8]; // [esp+8h] [ebp-54h] BYREF
  char v23[8]; // [esp+10h] [ebp-4Ch] BYREF
  char v24[8]; // [esp+18h] [ebp-44h] BYREF
  char v25[8]; // [esp+20h] [ebp-3Ch] BYREF
  char v26[8]; // [esp+28h] [ebp-34h] BYREF
  char v27[8]; // [esp+30h] [ebp-2Ch] BYREF
  char v28[8]; // [esp+38h] [ebp-24h] BYREF
  int v29[2]; // [esp+40h] [ebp-1Ch] BYREF
  int v30[2]; // [esp+48h] [ebp-14h] BYREF
  int v31[2]; // [esp+50h] [ebp-Ch] BYREF
  int v32; // [esp+58h] [ebp-4h] BYREF

  v11 = a8;
  v32 = 0;
  switch ( a10 )
  {
    case 'A':
    case 'a':
      (*(void (__thiscall **)(void *, int *, int, int, int, int, int, _DWORD *, _DWORD *))(*(_DWORD *)this + 16))(
        this,
        v31,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
      a3 = v31[0];
      v12 = v31[1];
      goto LABEL_3;
    case 'B':
    case 'b':
    case 'h':
      (*(void (__thiscall **)(void *, int *, int, int, int, int, int, _DWORD *, _DWORD *))(*(_DWORD *)this + 20))(
        this,
        v30,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
      a3 = v30[0];
      v12 = v30[1];
      goto LABEL_3;
    case 'C':
      *v11 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32);
      if ( (*(_BYTE *)v11 & 2) != 0 )
        break;
      v14 = 100 * (v32 - 19);
      goto LABEL_9;
    case 'D':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v27,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%m / %d / %y");
      goto LABEL_6;
    case 'H':
      v21 = a9 + 2;
      v19 = 23;
      goto LABEL_15;
    case 'I':
      v21 = a9 + 2;
      v19 = 11;
      goto LABEL_15;
    case 'M':
      v21 = a9 + 1;
      goto LABEL_21;
    case 'R':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v24,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%H : %M");
      goto LABEL_6;
    case 'S':
      v21 = a9;
LABEL_21:
      v19 = 59;
      goto LABEL_15;
    case 'T':
    case 'X':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v23,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%H : %M : S");
      goto LABEL_6;
    case 'U':
    case 'W':
      v21 = a9 + 7;
      v19 = 53;
      goto LABEL_15;
    case 'Y':
      (*(void (__thiscall **)(void *, int *, int, int, int, int, int, _DWORD *, _DWORD *))(*(_DWORD *)this + 24))(
        this,
        v29,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
      a3 = v29[0];
      v12 = v29[1];
      goto LABEL_3;
    case 'c':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v28,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%b %d %H : %M : %S %Y");
      goto LABEL_6;
    case 'd':
    case 'e':
      v20 = a9 + 3;
      v18 = 31;
      goto LABEL_11;
    case 'j':
      v20 = a9 + 7;
      v18 = 366;
LABEL_11:
      v15 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, v18, v20);
      goto LABEL_12;
    case 'm':
      *v11 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 1, 12, &v32);
      if ( (*(_BYTE *)v11 & 2) == 0 )
        a9[4] = v32 - 1;
      break;
    case 'n':
    case 't':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v26,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     " ");
      goto LABEL_6;
    case 'p':
      v16 = std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>((int)&a3, (int)&a5, 0, (int)":AM:am:PM:pm");
      if ( v16 < 0 )
        goto LABEL_36;
      a9[2] += 12 * v16;
      break;
    case 'r':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v25,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%I : %M : %S %p");
      goto LABEL_6;
    case 'w':
      v21 = a9 + 6;
      v19 = 6;
LABEL_15:
      v15 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, v19, v21);
LABEL_12:
      *v11 |= v15;
      break;
    case 'x':
      v13 = (int *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                     v22,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     "%d / %m / %y");
LABEL_6:
      a3 = *v13;
      v12 = v13[1];
LABEL_3:
      a4 = v12;
      break;
    case 'y':
      *v11 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(this, &a3, &a5, 0, 99, &v32);
      if ( (*(_BYTE *)v11 & 2) == 0 )
      {
        v14 = v32;
        if ( v32 < 69 )
          v14 = v32 + 100;
LABEL_9:
        a9[5] = v14;
      }
      break;
    default:
LABEL_36:
      *v11 |= 2u;
      break;
  }
  if ( (unsigned __int8)sub_42C7CF(&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 42E27C: using guessed type _DWORD __stdcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42E3B2: using guessed type _DWORD __cdecl std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 430CE1: using guessed type char var_24[8];
// 430CE1: using guessed type char var_2C[8];
// 430CE1: using guessed type char var_34[8];
// 430CE1: using guessed type char var_3C[8];
// 430CE1: using guessed type char var_44[8];
// 430CE1: using guessed type char var_4C[8];
// 430CE1: using guessed type char var_54[8];

//----- (004320BA) --------------------------------------------------------
_DWORD *__thiscall sub_4320BA(void **this, _DWORD *a2)
{
  sub_4095E0(a2, this[6]);
  return a2;
}

//----- (00432283) --------------------------------------------------------
_DWORD *__thiscall sub_432283(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        _DWORD **a7,
        _DWORD *a8,
        _WORD *a9)
{
  _DWORD **v9; // esi
  _DWORD *v10; // edi
  _WORD *v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  size_t v14; // eax
  size_t v15; // esi
  char *v16; // eax
  unsigned int v17; // esi
  _DWORD *result; // eax
  int v19; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v20; // [esp+14h] [ebp-40h]
  int v21; // [esp+18h] [ebp-3Ch] BYREF
  int v22; // [esp+1Ch] [ebp-38h] BYREF
  int v23; // [esp+20h] [ebp-34h]
  char v24; // [esp+24h] [ebp-30h] BYREF
  char v25; // [esp+25h] [ebp-2Fh] BYREF
  int v26; // [esp+50h] [ebp-4h]

  v9 = a7;
  v10 = a8;
  v11 = a9;
  v22 = 0;
  v20 = a2;
  v23 = (int)this;
  v12 = sub_408A70(a7, &v21);
  v13 = v9[5];
  v26 = 0;
  v14 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(v23, &v24, &a3, &a5, v13, v12);
  v26 = -1;
  v15 = v14;
  sub_408B00(&v21);
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v23 = (int)v16;
  v17 = _Stoulx((int)v16, (int)&v19, v15, (int)&v22);
  if ( (unsigned __int8)sub_42C7CF(&a3, (int)&a5) )
    *v10 |= 1u;
  if ( v19 == v23 || v22 || v17 > 0xFFFF )
  {
    *v10 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v11 = v17;
  }
  result = v20;
  *v20 = a3;
  result[1] = a4;
  return result;
}
// 431120: using guessed type _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00432352) --------------------------------------------------------
_DWORD *__thiscall sub_432352(void *this, _DWORD *a2, int a3, int a4, int a5, int a6, _DWORD **a7, _DWORD *a8, int *a9)
{
  _DWORD **v9; // esi
  _DWORD *v10; // edi
  int *v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  size_t v14; // eax
  size_t v15; // esi
  char *v16; // eax
  int v17; // esi
  _DWORD *result; // eax
  int v19; // [esp+10h] [ebp-44h] BYREF
  _DWORD *v20; // [esp+14h] [ebp-40h]
  int v21; // [esp+18h] [ebp-3Ch] BYREF
  int v22; // [esp+1Ch] [ebp-38h] BYREF
  int v23; // [esp+20h] [ebp-34h]
  char v24; // [esp+24h] [ebp-30h] BYREF
  char v25; // [esp+25h] [ebp-2Fh] BYREF
  int v26; // [esp+50h] [ebp-4h]

  v9 = a7;
  v10 = a8;
  v11 = a9;
  v22 = 0;
  v20 = a2;
  v23 = (int)this;
  v12 = sub_408A70(a7, &v21);
  v13 = v9[5];
  v26 = 0;
  v14 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(v23, &v24, &a3, &a5, v13, v12);
  v26 = -1;
  v15 = v14;
  sub_408B00(&v21);
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v23 = (int)v16;
  v17 = _Stoulx((int)v16, (int)&v19, v15, (int)&v22);
  if ( (unsigned __int8)sub_42C7CF(&a3, (int)&a5) )
    *v10 |= 1u;
  if ( v19 == v23 || v22 )
  {
    *v10 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v11 = v17;
  }
  result = v20;
  *v20 = a3;
  result[1] = a4;
  return result;
}
// 431120: using guessed type _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043292B) --------------------------------------------------------
_DWORD *__thiscall sub_43292B(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        _DWORD **a7,
        _DWORD *a8,
        _DWORD *a9)
{
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // eax
  size_t v12; // eax
  int v13; // eax
  int v15; // [esp+10h] [ebp-44h] BYREF
  int v16; // [esp+14h] [ebp-40h] BYREF
  int v17; // [esp+18h] [ebp-3Ch] BYREF
  int v18; // [esp+1Ch] [ebp-38h]
  size_t MaxCount; // [esp+20h] [ebp-34h]
  int v20[11]; // [esp+24h] [ebp-30h] BYREF
  int v21; // [esp+50h] [ebp-4h]

  v9 = a8;
  v10 = a9;
  v17 = 0;
  MaxCount = (size_t)this;
  v11 = sub_408A70(a7, &v16);
  v21 = 0;
  v12 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(MaxCount, v20, &a3, &a5, 2048, v11);
  v21 = -1;
  MaxCount = v12;
  sub_408B00(&v16);
  v13 = _Stoulx((int)v20, (int)&v15, MaxCount, (int)&v17);
  MaxCount = 0;
  v18 = v13;
  if ( (unsigned __int8)sub_42C7CF(&a3, (int)&a5) )
    *v9 |= 1u;
  if ( (int *)v15 == v20 || v17 )
    *v9 |= 2u;
  else
    *v10 = v18;
  *a2 = a3;
  a2[1] = a4;
  return a2;
}
// 431120: using guessed type _DWORD __cdecl std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004329E1) --------------------------------------------------------
int __thiscall sub_4329E1(void *this, int a2, int a3, int a4, int a5, __int16 a6, double a7)
{
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  double v10; // st7
  int v11; // ecx
  unsigned int v12; // ebx
  int v13; // et0
  double v14; // st7
  double v15; // st6
  double v16; // st5
  double v17; // st4
  double v18; // st5
  double v19; // rt2
  double v20; // rtt
  double v21; // st4
  double v22; // rt0
  double v23; // st5
  double v24; // st7
  bool v25; // cf
  const char *v26; // eax
  int v27; // eax
  int v30; // [esp+1Ch] [ebp-88h]
  unsigned int v31; // [esp+20h] [ebp-84h]
  unsigned int v32; // [esp+24h] [ebp-80h]
  char v33; // [esp+2Bh] [ebp-79h]
  char Buffer[108]; // [esp+2Ch] [ebp-78h] BYREF
  char v35[4]; // [esp+98h] [ebp-Ch] BYREF
  int v36; // [esp+9Ch] [ebp-8h]

  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v8) <= 0 && (*(_DWORD *)(a5 + 20) & 0x2000) == 0 )
  {
    v8 = 6;
    v7 = 0;
  }
  v9 = v8;
  v36 = v7;
  if ( v7 < 0 || v7 <= 0 && v8 <= 0x24 )
    v30 = v8;
  else
    v30 = 36;
  v10 = a7;
  v11 = *(_DWORD *)(a5 + 20);
  v13 = (__PAIR64__(v36, v9) - v30) >> 32;
  v12 = v9 - v30;
  v36 = v13;
  v32 = 0;
  v31 = 0;
  if ( (v11 & 0x3000) == 0x2000 && a7 != 0.5 * a7 )
  {
    if ( a7 >= 0.0 )
    {
      v33 = 0;
      v15 = a7;
      v14 = 0.0;
    }
    else
    {
      v14 = 0.0;
      v33 = 1;
      v15 = -a7;
    }
    v16 = 1.0e35;
    v17 = 1.0e10;
    if ( v15 >= 1.0e35 )
    {
      while ( v32 < 0x1388 )
      {
        v15 = v15 / v17;
        v32 += 10;
        v20 = v17;
        v21 = v16;
        v18 = v20;
        if ( v21 > v15 )
          goto LABEL_19;
        v19 = v21;
        v17 = v18;
        v16 = v19;
      }
    }
    v18 = v17;
LABEL_19:
    v22 = v18;
    v23 = v14;
    v24 = v22;
    if ( v23 < v15 && v36 >= 0 )
    {
      if ( v36 > 0 )
      {
LABEL_23:
        while ( v15 <= 1.0e-35 && v31 < 0x1388 )
        {
          v25 = __CFADD__(v12, -10);
          v12 -= 10;
          v15 = v15 * v24;
          v36 = v25 + v36 - 1;
          v31 += 10;
          if ( v36 <= 0 )
          {
            if ( v36 >= 0 )
              goto LABEL_22;
            break;
          }
        }
      }
      else
      {
LABEL_22:
        if ( v12 >= 0xA )
          goto LABEL_23;
      }
    }
    v10 = v15;
    if ( v33 )
      v10 = -v15;
  }
  v26 = (const char *)unknown_libname_44(this, v35, 0, v11);
  v27 = sprintf_s(Buffer, 0x6Cu, v26, v30, v10);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(
    (int)this,
    a2,
    a3,
    a4,
    a5,
    a6,
    Buffer,
    v32,
    v31,
    v12,
    v27);
  return a2;
}
// 42BF12: using guessed type _DWORD __cdecl unknown_libname_44(_DWORD, _DWORD, char, _DWORD);
// 4329E1: using guessed type char var_C[4];

//----- (00432BA1) --------------------------------------------------------
int __thiscall sub_432BA1(void *this, int a2, int a3, int a4, int a5, __int16 a6, double a7)
{
  int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // ebx
  int v10; // ecx
  unsigned int v11; // ebx
  int v12; // et0
  double v13; // st6
  double v14; // st5
  double v15; // st4
  double v16; // st5
  double v17; // rt0
  double v18; // rt1
  double v19; // st4
  bool v20; // cf
  double v21; // st7
  const char *v22; // eax
  int v23; // eax
  int v26; // [esp+1Ch] [ebp-88h]
  unsigned int v27; // [esp+20h] [ebp-84h]
  unsigned int v28; // [esp+24h] [ebp-80h]
  char v29; // [esp+2Bh] [ebp-79h]
  char Buffer[108]; // [esp+2Ch] [ebp-78h] BYREF
  char v31[4]; // [esp+98h] [ebp-Ch] BYREF
  int v32; // [esp+9Ch] [ebp-8h]

  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v8) <= 0 && (*(_DWORD *)(a5 + 20) & 0x2000) == 0 )
  {
    v8 = 6;
    v7 = 0;
  }
  v9 = v8;
  v32 = v7;
  if ( v7 < 0 || v7 <= 0 && v8 <= 0x24 )
    v26 = v8;
  else
    v26 = 36;
  v10 = *(_DWORD *)(a5 + 20);
  v12 = (__PAIR64__(v32, v9) - v26) >> 32;
  v11 = v9 - v26;
  v32 = v12;
  v28 = 0;
  v27 = 0;
  if ( (v10 & 0x3000) == 0x2000 )
  {
    v13 = a7;
    if ( a7 >= 0.0 )
    {
      v29 = 0;
    }
    else
    {
      v29 = 1;
      v13 = -a7;
    }
    v14 = 1.0e35;
    v15 = 1.0e10;
    if ( v13 >= 1.0e35 )
    {
      while ( v28 < 0x1388 )
      {
        v13 = v13 / v15;
        v28 += 10;
        v18 = v15;
        v19 = v14;
        v16 = v18;
        if ( v19 > v13 )
          goto LABEL_18;
        v17 = v19;
        v15 = v16;
        v14 = v17;
      }
    }
    v16 = v15;
LABEL_18:
    if ( v13 > 0.0 && v32 >= 0 )
    {
      if ( v32 > 0 )
      {
LABEL_22:
        while ( v13 <= 1.0e-35 && v27 < 0x1388 )
        {
          v20 = __CFADD__(v11, -10);
          v11 -= 10;
          v13 = v13 * v16;
          v32 = v20 + v32 - 1;
          v27 += 10;
          if ( v32 <= 0 )
          {
            if ( v32 >= 0 )
              goto LABEL_21;
            break;
          }
        }
      }
      else
      {
LABEL_21:
        if ( v11 >= 0xA )
          goto LABEL_22;
      }
    }
    v21 = v13;
    if ( v29 )
      v21 = -v13;
  }
  else
  {
    v21 = a7;
  }
  v22 = (const char *)unknown_libname_44(this, v31, 76, v10);
  v23 = sprintf_s(Buffer, 0x6Cu, v22, v26, v21);
  std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::_Fput(
    (int)this,
    a2,
    a3,
    a4,
    a5,
    a6,
    Buffer,
    v28,
    v27,
    v11,
    v23);
  return a2;
}
// 42BF12: using guessed type _DWORD __cdecl unknown_libname_44(_DWORD, _DWORD, char, _DWORD);
// 432BA1: using guessed type char var_C[4];

//----- (00432DD7) --------------------------------------------------------
int __cdecl sub_432DD7(_Collvec **a1, void *a2)
{
  _Collvec *v2; // esi
  char *v3; // eax
  bool v4; // cf
  char v6[36]; // [esp+10h] [ebp-58h] BYREF
  void *v7; // [esp+34h] [ebp-34h]
  int v8; // [esp+38h] [ebp-30h]
  int v9[10]; // [esp+3Ch] [ebp-2Ch] BYREF
  int v10; // [esp+64h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = (_Collvec *)operator new(0x10u);
    v7 = v2;
    v10 = 0;
    if ( v2 )
    {
      v3 = (char *)sub_413350(a2, v9);
      v4 = *((_DWORD *)v3 + 5) < 0x10u;
      LOBYTE(v10) = 1;
      v8 = 1;
      if ( !v4 )
        v3 = *(char **)v3;
      sub_4086C0((struct std::_Locinfo *)v6, v3);
      v2->_LocaleName = 0;
      v8 = 3;
      v2->_Page = (unsigned int)&std::collate<unsigned short>::`vftable';
      v2[1] = _Getcoll();
    }
    else
    {
      v2 = 0;
    }
    v10 = 2;
    *a1 = v2;
    if ( (v8 & 2) != 0 )
    {
      v8 &= ~2u;
      sub_408790((std::_Lockit *)v6);
    }
    if ( (v8 & 1) != 0 )
      sub_407D70(v9, 1, 0);
  }
  return 1;
}
// 4BDF20: using guessed type void *std::collate<unsigned short>::`vftable';
// 432DD7: using guessed type _DWORD var_2C[10];

//----- (00433E10) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_433E10(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE2F0;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE2F0;
  v2 = std::locale::id::operator unsigned int(&unk_4EE308);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_432DD7((_Collvec **)&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE2F0 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE2F0: using guessed type int dword_4EE2F0;
// 433E10: using guessed type char var_14[4];

//----- (00433EAD) --------------------------------------------------------
void __cdecl sub_433EAD(std::_Locinfo *a1, void *a2, struct std::locale::_Locimp *a3, int a4)
{
  struct std::locale::facet *v4; // eax
  struct std::locale::facet *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // esi
  struct std::locale::facet *v8; // eax
  struct std::locale::facet *v9; // eax
  struct std::locale::facet *v10; // esi
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // esi
  struct std::locale::facet *v14; // eax
  struct std::locale::facet *v15; // eax
  struct std::locale::facet *v16; // esi
  int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // esi
  struct std::locale::facet *v20; // eax
  int *v21; // edi
  struct std::locale::facet *v22; // eax
  struct std::locale::facet *v23; // esi
  unsigned int v24; // eax
  unsigned int v25; // esi
  struct std::locale::facet *v26; // eax
  _Collvec *v27; // eax
  struct std::locale::facet *v28; // esi
  unsigned int v29; // eax
  unsigned int v30; // esi
  struct std::locale::facet *v31; // eax
  struct std::locale::facet *v32; // eax
  struct std::locale::facet *v33; // esi
  unsigned int v34; // eax
  unsigned int v35; // esi
  struct std::locale::facet *v36; // eax
  struct std::locale::facet *v37; // eax
  struct std::locale::facet *v38; // esi
  int v39; // edx
  unsigned int v40; // eax
  unsigned int v41; // esi
  struct std::locale::facet *v42; // eax
  struct std::locale::facet *v43; // eax
  struct std::locale::facet *v44; // esi
  int v45; // edx
  unsigned int v46; // eax
  unsigned int v47; // esi
  struct std::locale::facet *v48; // eax
  struct std::locale::facet *v49; // eax
  struct std::locale::facet *v50; // esi
  unsigned int v51; // eax
  unsigned int v52; // esi
  struct std::locale::facet *v53; // eax
  struct std::locale::facet *v54; // eax
  struct std::locale::facet *v55; // esi
  unsigned int v56; // eax
  unsigned int v57; // esi
  struct std::locale::facet *v58; // eax
  _DWORD *v59; // ecx
  struct std::locale::facet *v60; // esi
  unsigned int v61; // eax
  unsigned int v62; // esi
  struct std::locale::facet *v63; // eax
  struct std::locale::facet *v64; // eax
  struct std::locale::facet *v65; // esi
  unsigned int v66; // eax
  unsigned int v67; // esi
  struct std::locale::facet *v68; // eax
  struct std::locale::facet *v69; // eax
  struct std::locale::facet *v70; // esi
  int v71; // edx
  unsigned int v72; // eax
  unsigned int v73; // esi
  struct std::locale::facet *v74; // eax
  _Cvtvec *v75; // [esp+0h] [ebp-28h]

  if ( ((unsigned __int8)a2 & 2) != 0 )
  {
    if ( a4 )
    {
      v7 = std::locale::id::operator unsigned int(&dword_4EE114);
      v8 = sub_408900(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v8, v7);
    }
    else
    {
      v4 = (struct std::locale::facet *)operator new(0x20u);
      v5 = v4;
      if ( v4 )
      {
        *((_DWORD *)v4 + 1) = 0;
        *(_DWORD *)v4 = &std::ctype<wchar_t>::`vftable';
        sub_408670((int)v4, (int)a1);
      }
      else
      {
        v5 = 0;
      }
      v6 = std::locale::id::operator unsigned int(&dword_4EE114);
      std::locale::_Locimp::_Locimp_Addfac(a3, v5, v6);
    }
  }
  if ( ((unsigned __int8)a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v13 = std::locale::id::operator unsigned int(&dword_4F248C);
      v14 = sub_406C30(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v14, v13);
    }
    else
    {
      v9 = (struct std::locale::facet *)operator new(0x10u);
      v10 = v9;
      if ( v9 )
      {
        *((_DWORD *)v9 + 1) = 0;
        *(_DWORD *)v9 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v9 + 2) = _Getcvt(v75);
        *((_DWORD *)v10 + 3) = v11;
      }
      else
      {
        v10 = 0;
      }
      v12 = std::locale::id::operator unsigned int(&dword_4F248C);
      std::locale::_Locimp::_Locimp_Addfac(a3, v10, v12);
    }
  }
  if ( ((unsigned __int8)a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v19 = std::locale::id::operator unsigned int(&dword_4F2494);
      v20 = sub_40E010(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v20, v19);
    }
    else
    {
      v15 = (struct std::locale::facet *)operator new(0x10u);
      v16 = v15;
      if ( v15 )
      {
        *((_DWORD *)v15 + 1) = 0;
        *(_DWORD *)v15 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v15 + 2) = _Getcvt(v75);
        *((_DWORD *)v16 + 3) = v17;
      }
      else
      {
        v16 = 0;
      }
      v18 = std::locale::id::operator unsigned int(&dword_4F2494);
      std::locale::_Locimp::_Locimp_Addfac(a3, v16, v18);
    }
    v21 = (int *)a4;
    if ( a4 )
    {
      v25 = std::locale::id::operator unsigned int(&dword_4F2488);
      v26 = sub_406D70(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v26, v25);
    }
    else
    {
      v22 = (struct std::locale::facet *)operator new(0x18u);
      v23 = v22;
      if ( v22 )
      {
        *((_DWORD *)v22 + 1) = 0;
        *(_DWORD *)v22 = &std::numpunct<wchar_t>::`vftable';
        sub_4074A0((unsigned int)v22, (int)a1, 0);
      }
      else
      {
        v23 = 0;
      }
      v24 = std::locale::id::operator unsigned int(&dword_4F2488);
      std::locale::_Locimp::_Locimp_Addfac(a3, v23, v24);
    }
  }
  else
  {
    v21 = (int *)a4;
  }
  if ( ((1 << sub_410580(0, 0) >> 1) & (unsigned int)a2) != 0 )
  {
    if ( v21 )
    {
      v30 = std::locale::id::operator unsigned int(&dword_4F2490);
      v31 = sub_410420(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v31, v30);
    }
    else
    {
      v27 = (_Collvec *)operator new(0x10u);
      v28 = (struct std::locale::facet *)v27;
      if ( v27 )
      {
        v27->_LocaleName = 0;
        v27->_Page = (unsigned int)&std::collate<wchar_t>::`vftable';
        v27[1] = _Getcoll();
      }
      else
      {
        v28 = 0;
      }
      v29 = std::locale::id::operator unsigned int(&dword_4F2490);
      std::locale::_Locimp::_Locimp_Addfac(a3, v28, v29);
    }
  }
  if ( ((unsigned __int8)a2 & 0x20) != 0 )
  {
    if ( v21 )
    {
      v35 = std::locale::id::operator unsigned int(&unk_4EE310);
      v36 = sub_42D39C(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v36, v35);
    }
    else
    {
      v32 = (struct std::locale::facet *)operator new(8u);
      if ( v32 )
      {
        *((_DWORD *)v32 + 1) = 0;
        *(_DWORD *)v32 = &std::messages<wchar_t>::`vftable';
        v33 = v32;
      }
      else
      {
        v33 = 0;
      }
      v34 = std::locale::id::operator unsigned int(&unk_4EE310);
      std::locale::_Locimp::_Locimp_Addfac(a3, v33, v34);
    }
  }
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    if ( v21 )
    {
      v41 = std::locale::id::operator unsigned int(&unk_4EE328);
      v42 = sub_42D439(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v42, v41);
    }
    else
    {
      v37 = (struct std::locale::facet *)operator new(0x10u);
      v38 = v37;
      if ( v37 )
      {
        *((_DWORD *)v37 + 1) = 0;
        *(_DWORD *)v37 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v37 + 2) = _Getcvt(v75);
        *((_DWORD *)v38 + 3) = v39;
      }
      else
      {
        v38 = 0;
      }
      v40 = std::locale::id::operator unsigned int(&unk_4EE328);
      std::locale::_Locimp::_Locimp_Addfac(a3, v38, v40);
    }
  }
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    if ( v21 )
    {
      v47 = std::locale::id::operator unsigned int(&unk_4EE32C);
      v48 = sub_42D4D6(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v48, v47);
    }
    else
    {
      v43 = (struct std::locale::facet *)operator new(0x10u);
      v44 = v43;
      if ( v43 )
      {
        *((_DWORD *)v43 + 1) = 0;
        *(_DWORD *)v43 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v43 + 2) = _Getcvt(v75);
        *((_DWORD *)v44 + 3) = v45;
      }
      else
      {
        v44 = 0;
      }
      v46 = std::locale::id::operator unsigned int(&unk_4EE32C);
      std::locale::_Locimp::_Locimp_Addfac(a3, v44, v46);
    }
  }
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    if ( a4 )
    {
      v52 = std::locale::id::operator unsigned int(&unk_4EE314);
      v53 = sub_42E6AF((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v53, v52);
    }
    else
    {
      v49 = (struct std::locale::facet *)operator new(0x34u);
      v50 = v49;
      if ( v49 )
      {
        *((_DWORD *)v49 + 1) = 0;
        *(_DWORD *)v49 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v49 + 40) = 0;
        std::_Mpunct<wchar_t>::_Init(a1, 0);
        *(_DWORD *)v50 = &std::moneypunct<wchar_t,0>::`vftable';
      }
      else
      {
        v50 = 0;
      }
      v51 = std::locale::id::operator unsigned int(&unk_4EE314);
      std::locale::_Locimp::_Locimp_Addfac(a3, v50, v51);
    }
    if ( a4 )
    {
      v57 = std::locale::id::operator unsigned int(&unk_4EE2FC);
      v58 = sub_42E74C((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v58, v57);
    }
    else
    {
      v54 = (struct std::locale::facet *)operator new(0x34u);
      v55 = v54;
      if ( v54 )
      {
        *((_DWORD *)v54 + 1) = 0;
        *(_DWORD *)v54 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v54 + 40) = 1;
        std::_Mpunct<wchar_t>::_Init(a1, 0);
        *(_DWORD *)v55 = &std::moneypunct<wchar_t,1>::`vftable';
      }
      else
      {
        v55 = 0;
      }
      v56 = std::locale::id::operator unsigned int(&unk_4EE2FC);
      std::locale::_Locimp::_Locimp_Addfac(a3, v55, v56);
    }
  }
  if ( ((unsigned __int8)a2 & 0x10) != 0 )
  {
    if ( a4 )
    {
      v62 = std::locale::id::operator unsigned int(&unk_4EE300);
      v63 = sub_42E7E9((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v63, v62);
    }
    else
    {
      v59 = operator new(0x1Cu);
      if ( v59 )
        v60 = (struct std::locale::facet *)sub_42DC51(v59, a1, 0);
      else
        v60 = 0;
      v61 = std::locale::id::operator unsigned int(&unk_4EE300);
      std::locale::_Locimp::_Locimp_Addfac(a3, v60, v61);
    }
  }
  if ( ((unsigned __int8)a2 & 0x10) != 0 )
  {
    if ( a4 )
    {
      v67 = std::locale::id::operator unsigned int(&dword_4F24A4);
      v68 = sub_4226A0(a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v68, v67);
    }
    else
    {
      v64 = (struct std::locale::facet *)operator new(0x14u);
      v65 = v64;
      if ( v64 )
      {
        *((_DWORD *)v64 + 1) = 0;
        *(_DWORD *)v64 = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_DWORD *)v64 + 2) = 0;
        sub_423680(v64, a1);
      }
      else
      {
        v65 = 0;
      }
      v66 = std::locale::id::operator unsigned int(&dword_4F24A4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v65, v66);
    }
  }
  if ( ((unsigned __int8)a2 & 2) != 0 )
  {
    if ( a4 )
    {
      v73 = std::locale::id::operator unsigned int(&unk_4EE118);
      v74 = sub_42D573((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v74, v73);
    }
    else
    {
      v69 = (struct std::locale::facet *)operator new(0x10u);
      v70 = v69;
      if ( v69 )
      {
        *((_DWORD *)v69 + 1) = 0;
        *(_DWORD *)v69 = &std::codecvt<wchar_t,char,int>::`vftable';
        *((_DWORD *)v69 + 2) = _Getcvt(v75);
        *((_DWORD *)v70 + 3) = v71;
      }
      else
      {
        v70 = 0;
      }
      v72 = std::locale::id::operator unsigned int(&unk_4EE118);
      std::locale::_Locimp::_Locimp_Addfac(a3, v70, v72);
    }
  }
}
// 434009: conditional instruction was optimized away because edi.4 is in (1..FF)
// 4342BE: conditional instruction was optimized away because %var_10.4 is in (1..FF)
// 433F51: variable 'v75' is possibly undefined
// 433F59: variable 'v11' is possibly undefined
// 433FC6: variable 'v17' is possibly undefined
// 43418B: variable 'v39' is possibly undefined
// 4341F2: variable 'v45' is possibly undefined
// 434443: variable 'v71' is possibly undefined
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 42C38B: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 4BDD30: using guessed type void *std::codecvt<wchar_t,char,int>::`vftable';
// 4BDD78: using guessed type void *std::ctype<wchar_t>::`vftable';
// 4BDDE8: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 4BDDF4: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 4BDE28: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 4BDE50: using guessed type void *std::collate<wchar_t>::`vftable';
// 4BDE64: using guessed type void *std::messages<wchar_t>::`vftable';
// 4BDE78: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 4BDE88: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 4BDE98: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 4BE084: using guessed type void *std::numpunct<wchar_t>::`vftable';
// 4BE0BC: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';
// 4BE0E8: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';
// 4EE114: using guessed type int dword_4EE114;
// 4F2488: using guessed type int dword_4F2488;
// 4F248C: using guessed type int dword_4F248C;
// 4F2490: using guessed type int dword_4F2490;
// 4F2494: using guessed type int dword_4F2494;
// 4F24A4: using guessed type int dword_4F24A4;

//----- (0043448A) --------------------------------------------------------
void __cdecl sub_43448A(std::_Locinfo *a1, int a2, struct std::locale::_Locimp *a3, int a4)
{
  struct std::locale::facet *v4; // eax
  struct std::locale::facet *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // esi
  struct std::locale::facet *v8; // eax
  struct std::locale::facet *v9; // eax
  struct std::locale::facet *v10; // esi
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // esi
  struct std::locale::facet *v14; // eax
  struct std::locale::facet *v15; // eax
  struct std::locale::facet *v16; // esi
  int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // esi
  struct std::locale::facet *v20; // eax
  int *v21; // edi
  struct std::locale::facet *v22; // eax
  struct std::locale::facet *v23; // esi
  unsigned int v24; // eax
  unsigned int v25; // esi
  struct std::locale::facet *v26; // eax
  _Collvec *v27; // eax
  struct std::locale::facet *v28; // esi
  unsigned int v29; // eax
  unsigned int v30; // esi
  struct std::locale::facet *v31; // eax
  struct std::locale::facet *v32; // eax
  struct std::locale::facet *v33; // esi
  unsigned int v34; // eax
  unsigned int v35; // esi
  struct std::locale::facet *v36; // eax
  struct std::locale::facet *v37; // eax
  struct std::locale::facet *v38; // esi
  int v39; // edx
  unsigned int v40; // eax
  unsigned int v41; // esi
  struct std::locale::facet *v42; // eax
  struct std::locale::facet *v43; // eax
  struct std::locale::facet *v44; // esi
  int v45; // edx
  unsigned int v46; // eax
  unsigned int v47; // esi
  struct std::locale::facet *v48; // eax
  struct std::locale::facet *v49; // eax
  struct std::locale::facet *v50; // esi
  unsigned int v51; // eax
  unsigned int v52; // esi
  struct std::locale::facet *v53; // eax
  struct std::locale::facet *v54; // eax
  struct std::locale::facet *v55; // esi
  unsigned int v56; // eax
  unsigned int v57; // esi
  struct std::locale::facet *v58; // eax
  _DWORD *v59; // ecx
  struct std::locale::facet *v60; // esi
  unsigned int v61; // eax
  unsigned int v62; // esi
  struct std::locale::facet *v63; // eax
  struct std::locale::facet *v64; // eax
  struct std::locale::facet *v65; // esi
  unsigned int v66; // eax
  unsigned int v67; // esi
  struct std::locale::facet *v68; // eax
  struct std::locale::facet *v69; // eax
  struct std::locale::facet *v70; // esi
  int v71; // edx
  unsigned int v72; // eax
  unsigned int v73; // esi
  struct std::locale::facet *v74; // eax
  _Cvtvec *v75; // [esp+0h] [ebp-28h]

  if ( (a2 & 2) != 0 )
  {
    if ( a4 )
    {
      v7 = std::locale::id::operator unsigned int(&unk_4EE120);
      v8 = sub_42D2FF((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v8, v7);
    }
    else
    {
      v4 = (struct std::locale::facet *)operator new(0x20u);
      v5 = v4;
      if ( v4 )
      {
        *((_DWORD *)v4 + 1) = 0;
        *(_DWORD *)v4 = &std::ctype<unsigned short>::`vftable';
        unknown_libname_23(v4, a1);
      }
      else
      {
        v5 = 0;
      }
      v6 = std::locale::id::operator unsigned int(&unk_4EE120);
      std::locale::_Locimp::_Locimp_Addfac(a3, v5, v6);
    }
  }
  if ( (a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v13 = std::locale::id::operator unsigned int(&unk_4EE324);
      v14 = sub_42D610((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v14, v13);
    }
    else
    {
      v9 = (struct std::locale::facet *)operator new(0x10u);
      v10 = v9;
      if ( v9 )
      {
        *((_DWORD *)v9 + 1) = 0;
        *(_DWORD *)v9 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v9 + 2) = _Getcvt(v75);
        *((_DWORD *)v10 + 3) = v11;
      }
      else
      {
        v10 = 0;
      }
      v12 = std::locale::id::operator unsigned int(&unk_4EE324);
      std::locale::_Locimp::_Locimp_Addfac(a3, v10, v12);
    }
  }
  if ( (a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v19 = std::locale::id::operator unsigned int(&unk_4EE31C);
      v20 = sub_42D6AD((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v20, v19);
    }
    else
    {
      v15 = (struct std::locale::facet *)operator new(0x10u);
      v16 = v15;
      if ( v15 )
      {
        *((_DWORD *)v15 + 1) = 0;
        *(_DWORD *)v15 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v15 + 2) = _Getcvt(v75);
        *((_DWORD *)v16 + 3) = v17;
      }
      else
      {
        v16 = 0;
      }
      v18 = std::locale::id::operator unsigned int(&unk_4EE31C);
      std::locale::_Locimp::_Locimp_Addfac(a3, v16, v18);
    }
    v21 = (int *)a4;
    if ( a4 )
    {
      v25 = std::locale::id::operator unsigned int(&unk_4EE318);
      v26 = sub_42D74A((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v26, v25);
    }
    else
    {
      v22 = (struct std::locale::facet *)operator new(0x18u);
      v23 = v22;
      if ( v22 )
      {
        *((_DWORD *)v22 + 1) = 0;
        *(_DWORD *)v22 = &std::numpunct<unsigned short>::`vftable';
        std::numpunct<wchar_t>::_Init(a1, 0);
      }
      else
      {
        v23 = 0;
      }
      v24 = std::locale::id::operator unsigned int(&unk_4EE318);
      std::locale::_Locimp::_Locimp_Addfac(a3, v23, v24);
    }
  }
  else
  {
    v21 = (int *)a4;
  }
  if ( ((1 << sub_432DD7(0, 0) >> 1) & a2) != 0 )
  {
    if ( v21 )
    {
      v30 = std::locale::id::operator unsigned int(&unk_4EE308);
      v31 = sub_433E10(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v31, v30);
    }
    else
    {
      v27 = (_Collvec *)operator new(0x10u);
      v28 = (struct std::locale::facet *)v27;
      if ( v27 )
      {
        v27->_LocaleName = 0;
        v27->_Page = (unsigned int)&std::collate<unsigned short>::`vftable';
        v27[1] = _Getcoll();
      }
      else
      {
        v28 = 0;
      }
      v29 = std::locale::id::operator unsigned int(&unk_4EE308);
      std::locale::_Locimp::_Locimp_Addfac(a3, v28, v29);
    }
  }
  if ( (a2 & 0x20) != 0 )
  {
    if ( v21 )
    {
      v35 = std::locale::id::operator unsigned int(&unk_4EE30C);
      v36 = sub_42D7E7(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v36, v35);
    }
    else
    {
      v32 = (struct std::locale::facet *)operator new(8u);
      if ( v32 )
      {
        *((_DWORD *)v32 + 1) = 0;
        *(_DWORD *)v32 = &std::messages<unsigned short>::`vftable';
        v33 = v32;
      }
      else
      {
        v33 = 0;
      }
      v34 = std::locale::id::operator unsigned int(&unk_4EE30C);
      std::locale::_Locimp::_Locimp_Addfac(a3, v33, v34);
    }
  }
  if ( (a2 & 4) != 0 )
  {
    if ( v21 )
    {
      v41 = std::locale::id::operator unsigned int(&unk_4EE2F4);
      v42 = sub_42D884(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v42, v41);
    }
    else
    {
      v37 = (struct std::locale::facet *)operator new(0x10u);
      v38 = v37;
      if ( v37 )
      {
        *((_DWORD *)v37 + 1) = 0;
        *(_DWORD *)v37 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v37 + 2) = _Getcvt(v75);
        *((_DWORD *)v38 + 3) = v39;
      }
      else
      {
        v38 = 0;
      }
      v40 = std::locale::id::operator unsigned int(&unk_4EE2F4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v38, v40);
    }
  }
  if ( (a2 & 4) != 0 )
  {
    if ( v21 )
    {
      v47 = std::locale::id::operator unsigned int(&unk_4EE330);
      v48 = sub_42D921(v21);
      std::locale::_Locimp::_Locimp_Addfac(a3, v48, v47);
    }
    else
    {
      v43 = (struct std::locale::facet *)operator new(0x10u);
      v44 = v43;
      if ( v43 )
      {
        *((_DWORD *)v43 + 1) = 0;
        *(_DWORD *)v43 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v43 + 2) = _Getcvt(v75);
        *((_DWORD *)v44 + 3) = v45;
      }
      else
      {
        v44 = 0;
      }
      v46 = std::locale::id::operator unsigned int(&unk_4EE330);
      std::locale::_Locimp::_Locimp_Addfac(a3, v44, v46);
    }
  }
  if ( (a2 & 4) != 0 )
  {
    if ( a4 )
    {
      v52 = std::locale::id::operator unsigned int(&unk_4EE320);
      v53 = sub_42E886((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v53, v52);
    }
    else
    {
      v49 = (struct std::locale::facet *)operator new(0x34u);
      v50 = v49;
      if ( v49 )
      {
        *((_DWORD *)v49 + 1) = 0;
        *(_DWORD *)v49 = &std::_Mpunct<unsigned short>::`vftable';
        *((_BYTE *)v49 + 40) = 0;
        std::_Mpunct<wchar_t>::_Init(a1, 0);
        *(_DWORD *)v50 = &std::moneypunct<unsigned short,0>::`vftable';
      }
      else
      {
        v50 = 0;
      }
      v51 = std::locale::id::operator unsigned int(&unk_4EE320);
      std::locale::_Locimp::_Locimp_Addfac(a3, v50, v51);
    }
    if ( a4 )
    {
      v57 = std::locale::id::operator unsigned int(&unk_4EE334);
      v58 = sub_42E923((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v58, v57);
    }
    else
    {
      v54 = (struct std::locale::facet *)operator new(0x34u);
      v55 = v54;
      if ( v54 )
      {
        *((_DWORD *)v54 + 1) = 0;
        *(_DWORD *)v54 = &std::_Mpunct<unsigned short>::`vftable';
        *((_BYTE *)v54 + 40) = 1;
        std::_Mpunct<wchar_t>::_Init(a1, 0);
        *(_DWORD *)v55 = &std::moneypunct<unsigned short,1>::`vftable';
      }
      else
      {
        v55 = 0;
      }
      v56 = std::locale::id::operator unsigned int(&unk_4EE334);
      std::locale::_Locimp::_Locimp_Addfac(a3, v55, v56);
    }
  }
  if ( (a2 & 0x10) != 0 )
  {
    if ( a4 )
    {
      v62 = std::locale::id::operator unsigned int(&unk_4EE2F8);
      v63 = sub_42E9C0((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v63, v62);
    }
    else
    {
      v59 = operator new(0x1Cu);
      if ( v59 )
        v60 = (struct std::locale::facet *)sub_42DE8C(v59, a1, 0);
      else
        v60 = 0;
      v61 = std::locale::id::operator unsigned int(&unk_4EE2F8);
      std::locale::_Locimp::_Locimp_Addfac(a3, v60, v61);
    }
  }
  if ( (a2 & 0x10) != 0 )
  {
    if ( a4 )
    {
      v67 = std::locale::id::operator unsigned int(&unk_4EE304);
      v68 = sub_42D9BE((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v68, v67);
    }
    else
    {
      v64 = (struct std::locale::facet *)operator new(0x14u);
      v65 = v64;
      if ( v64 )
      {
        *((_DWORD *)v64 + 1) = 0;
        *(_DWORD *)v64 = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
        *((_DWORD *)v64 + 2) = 0;
        unknown_libname_75(v64, a1);
      }
      else
      {
        v65 = 0;
      }
      v66 = std::locale::id::operator unsigned int(&unk_4EE304);
      std::locale::_Locimp::_Locimp_Addfac(a3, v65, v66);
    }
  }
  if ( (a2 & 2) != 0 )
  {
    if ( a4 )
    {
      v73 = std::locale::id::operator unsigned int(&unk_4EE110);
      v74 = sub_42DA5B((int *)a4);
      std::locale::_Locimp::_Locimp_Addfac(a3, v74, v73);
    }
    else
    {
      v69 = (struct std::locale::facet *)operator new(0x10u);
      v70 = v69;
      if ( v69 )
      {
        *((_DWORD *)v69 + 1) = 0;
        *(_DWORD *)v69 = &std::codecvt<unsigned short,char,int>::`vftable';
        *((_DWORD *)v69 + 2) = _Getcvt(v75);
        *((_DWORD *)v70 + 3) = v71;
      }
      else
      {
        v70 = 0;
      }
      v72 = std::locale::id::operator unsigned int(&unk_4EE110);
      std::locale::_Locimp::_Locimp_Addfac(a3, v70, v72);
    }
  }
}
// 4345E6: conditional instruction was optimized away because edi.4 is in (1..FF)
// 43489B: conditional instruction was optimized away because %var_10.4 is in (1..FF)
// 43452E: variable 'v75' is possibly undefined
// 434536: variable 'v11' is possibly undefined
// 4345A3: variable 'v17' is possibly undefined
// 434768: variable 'v39' is possibly undefined
// 4347CF: variable 'v45' is possibly undefined
// 434A20: variable 'v71' is possibly undefined
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 42B86C: using guessed type int __thiscall unknown_libname_23(_DWORD, _DWORD);
// 42C1D6: using guessed type _DWORD __stdcall std::numpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 42C61C: using guessed type _DWORD __stdcall std::_Mpunct<wchar_t>::_Init(_DWORD, _DWORD);
// 436387: using guessed type int __thiscall unknown_libname_75(_DWORD, _DWORD);
// 4BDD54: using guessed type void *std::codecvt<unsigned short,char,int>::`vftable';
// 4BDDB0: using guessed type void *std::ctype<unsigned short>::`vftable';
// 4BDEC4: using guessed type void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
// 4BDEF8: using guessed type void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
// 4BDF20: using guessed type void *std::collate<unsigned short>::`vftable';
// 4BDF34: using guessed type void *std::messages<unsigned short>::`vftable';
// 4BDF48: using guessed type void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
// 4BDF58: using guessed type void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
// 4BDF68: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 4BDF94: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
// 4BE0A0: using guessed type void *std::numpunct<unsigned short>::`vftable';
// 4BE138: using guessed type void *std::moneypunct<unsigned short,0>::`vftable';
// 4BE164: using guessed type void *std::moneypunct<unsigned short,1>::`vftable';

//----- (00434BBB) --------------------------------------------------------
_DWORD *__stdcall sub_434BBB(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, int a9)
{
  _DWORD *v9; // esi
  int v10; // ebx
  _DWORD v12[11]; // [esp+10h] [ebp-2Ch] BYREF

  v9 = a8;
  v10 = a9;
  std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(v12, &a2, &a4, a6, a7);
  v12[10] = 0;
  if ( (unsigned __int8)sub_407380((int)&a2, (int)&a4) )
    *v9 |= 1u;
  if ( v12[4] )
    sub_4090E0(v10, v12, 0, 0xFFFFFFFF);
  else
    *v9 |= 2u;
  *a1 = a2;
  a1[1] = a3;
  sub_4093C0(v12, 1, 0);
  return a1;
}
// 432E8E: using guessed type _DWORD __stdcall std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD);

//----- (004362C5) --------------------------------------------------------
_DWORD *__stdcall sub_4362C5(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, int a9)
{
  _DWORD *v9; // esi
  char v11[16]; // [esp+10h] [ebp-2Ch] BYREF
  int v12; // [esp+20h] [ebp-1Ch]
  int v13; // [esp+38h] [ebp-4h]

  v9 = a8;
  std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(v11, &a2, &a4, a6, a7);
  v13 = 0;
  if ( (unsigned __int8)sub_42C7CF(&a2, (int)&a4) )
    *v9 |= 1u;
  if ( v12 )
    std::wstring::assign(v11, 0, -1);
  else
    *v9 |= 2u;
  *a1 = a2;
  a1[1] = a3;
  unknown_libname_53(v11, 1, 0);
  return a1;
}
// 42FFFB: using guessed type _DWORD __stdcall std::wstring::assign(_DWORD, _DWORD, _DWORD);
// 4357C6: using guessed type _DWORD __stdcall std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD);

//----- (004363FB) --------------------------------------------------------
int __stdcall sub_4363FB(int a1, int a2)
{
  return -1;
}

//----- (00436401) --------------------------------------------------------
char __thiscall sub_436401(_BYTE *this)
{
  return this[12];
}

//----- (00436405) --------------------------------------------------------
char __thiscall sub_436405(_BYTE *this)
{
  return this[13];
}

//----- (00436436) --------------------------------------------------------
void *__thiscall sub_436436(void *this, char a2)
{
  unknown_libname_77();
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43641A: using guessed type int unknown_libname_77(void);

//----- (004365F5) --------------------------------------------------------
int __cdecl sub_4365F5(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  bool v4; // zf
  char v6[36]; // [esp+10h] [ebp-34h] BYREF
  int v7; // [esp+34h] [ebp-10h]
  int v8; // [esp+40h] [ebp-4h]

  v7 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(8u);
    v8 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v6, v3);
      v2[1] = 0;
      v7 = 1;
      *v2 = &std::messages<char>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v8 = -1;
    v4 = (v7 & 1) == 0;
    *a1 = v2;
    if ( !v4 )
      sub_408790((std::_Lockit *)v6);
  }
  return 6;
}
// 4BE240: using guessed type void *std::messages<char>::`vftable';

//----- (00436674) --------------------------------------------------------
int __cdecl sub_436674(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_get<char,std::istreambuf_iterator<char>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 4366D2: variable 'v7' is possibly undefined
// 4366DA: variable 'v4' is possibly undefined
// 4BE254: using guessed type void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (004366FE) --------------------------------------------------------
int __cdecl sub_4366FE(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  int v4; // edx
  bool v5; // zf
  _Cvtvec *v7; // [esp+0h] [ebp-44h]
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x10u);
    v10 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      sub_4086C0((struct std::_Locinfo *)v8, v3);
      v2[1] = 0;
      v9 = 1;
      *v2 = &std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v2[2] = _Getcvt(v7);
      v2[3] = v4;
    }
    else
    {
      v2 = 0;
    }
    v10 = -1;
    v5 = (v9 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v8);
  }
  return 3;
}
// 43675C: variable 'v7' is possibly undefined
// 436764: variable 'v4' is possibly undefined
// 4BE264: using guessed type void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (00436788) --------------------------------------------------------
int __cdecl sub_436788(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x14u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      *v2 = &std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v8 = 1;
      v2[2] = 0;
      unknown_libname_75(v2, v4);
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 5;
}
// 436387: using guessed type int __thiscall unknown_libname_75(_DWORD, _DWORD);
// 4BE2A0: using guessed type void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (00436810) --------------------------------------------------------
int __thiscall sub_436810(_DWORD *this, std::_Locinfo *a2)
{
  int v3; // edx
  const char *v4; // eax
  const char *v5; // eax
  int result; // eax
  _Cvtvec *v7; // [esp+0h] [ebp-24h]

  this[5] = _Getcvt(v7);
  this[6] = v3;
  this[2] = 0;
  this[3] = 0;
  v4 = std::_Locinfo::_Getdays(a2);
  this[2] = sub_407690(v4);
  v5 = std::_Locinfo::_Getmonths(a2);
  this[3] = sub_407690(v5);
  result = _Getdateorder();
  this[4] = result;
  return result;
}
// 436821: variable 'v7' is possibly undefined
// 436832: variable 'v3' is possibly undefined
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4393A5: using guessed type int _Getdateorder(void);

//----- (00436887) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_436887(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE338;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE338;
  v2 = std::locale::id::operator unsigned int(&unk_4EE374);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_4365F5(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE338 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE338: using guessed type int dword_4EE338;
// 436887: using guessed type char var_14[4];

//----- (00436924) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_436924(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE33C;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE33C;
  v2 = std::locale::id::operator unsigned int(&unk_4EE364);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_436674(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE33C = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE33C: using guessed type int dword_4EE33C;
// 436924: using guessed type char var_14[4];

//----- (004369C1) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_4369C1(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE340;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE340;
  v2 = std::locale::id::operator unsigned int(&unk_4EE360);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_4366FE(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE340 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE340: using guessed type int dword_4EE340;
// 4369C1: using guessed type char var_14[4];

//----- (00436A5E) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_436A5E(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE344;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE344;
  v2 = std::locale::id::operator unsigned int(&unk_4EE368);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_436788(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE344 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE344: using guessed type int dword_4EE344;
// 436A5E: using guessed type char var_14[4];

//----- (00436AFB) --------------------------------------------------------
void *__thiscall sub_436AFB(void *this, char a2)
{
  *(_DWORD *)this = &std::_Mpunct<char>::`vftable';
  unknown_libname_73();
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 436344: using guessed type int unknown_libname_73(void);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE274: using guessed type void *std::_Mpunct<char>::`vftable';

//----- (00436B28) --------------------------------------------------------
int __cdecl sub_436B28(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v8 = 1;
      v2[1] = 0;
      v9 = 2;
      *v2 = &std::_Mpunct<char>::`vftable';
      *((_BYTE *)v2 + 40) = 0;
      std::_Mpunct<char>::_Init(v4, 1);
      *v2 = &std::moneypunct<char,0>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 4364B4: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, _DWORD);
// 4BE274: using guessed type void *std::_Mpunct<char>::`vftable';
// 4BE2AC: using guessed type void *std::moneypunct<char,0>::`vftable';

//----- (00436BBD) --------------------------------------------------------
int __cdecl sub_436BBD(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  char *v3; // eax
  struct std::_Locinfo *v4; // eax
  bool v5; // zf
  char v7[36]; // [esp+10h] [ebp-34h] BYREF
  int v8; // [esp+34h] [ebp-10h]
  int v9; // [esp+40h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = operator new(0x34u);
    v9 = 0;
    if ( v2 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v7, v3);
      v2[1] = 0;
      v8 = 1;
      *((_BYTE *)v2 + 40) = 1;
      v9 = 2;
      *v2 = &std::_Mpunct<char>::`vftable';
      std::_Mpunct<char>::_Init(v4, 1);
      *v2 = &std::moneypunct<char,1>::`vftable';
    }
    else
    {
      v2 = 0;
    }
    v9 = -1;
    v5 = (v8 & 1) == 0;
    *a1 = v2;
    if ( !v5 )
      sub_408790((std::_Lockit *)v7);
  }
  return 3;
}
// 4364B4: using guessed type _DWORD __stdcall std::_Mpunct<char>::_Init(_DWORD, _DWORD);
// 4BE274: using guessed type void *std::_Mpunct<char>::`vftable';
// 4BE2D8: using guessed type void *std::moneypunct<char,1>::`vftable';

//----- (00436C54) --------------------------------------------------------
_DWORD *__thiscall sub_436C54(_DWORD *this, std::_Locinfo *a2, int a3)
{
  this[1] = a3;
  *this = &std::time_get<char,std::istreambuf_iterator<char>>::`vftable';
  sub_436810(this, a2);
  return this;
}
// 4BE304: using guessed type void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00436C87) --------------------------------------------------------
void *__thiscall sub_436C87(void *this, char a2)
{
  *(_DWORD *)this = &std::time_get<char,std::istreambuf_iterator<char>>::`vftable';
  unknown_libname_74(this);
  *(_DWORD *)this = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 43636E: using guessed type int __thiscall unknown_libname_74(_DWORD);
// 4BDAFC: using guessed type void *std::locale::facet::`vftable';
// 4BE304: using guessed type void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00436CB4) --------------------------------------------------------
int __cdecl sub_436CB4(_DWORD *a1, int a2)
{
  char *v3; // eax
  std::_Locinfo *v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  char v8[36]; // [esp+10h] [ebp-34h] BYREF
  int v9; // [esp+34h] [ebp-10h]
  int v10; // [esp+40h] [ebp-4h]
  _DWORD *v11; // [esp+4Ch] [ebp+8h]

  v9 = 0;
  if ( a1 && !*a1 )
  {
    v11 = operator new(0x1Cu);
    v10 = 0;
    if ( v11 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a2 + 24) )
        v3 = *(char **)(*(_DWORD *)a2 + 24);
      else
        v3 = (char *)(*(_DWORD *)a2 + 28);
      v4 = sub_4086C0((struct std::_Locinfo *)v8, v3);
      LOBYTE(v10) = 1;
      v9 = 1;
      v5 = sub_436C54(v11, v4, 0);
    }
    else
    {
      v5 = 0;
    }
    v10 = -1;
    v6 = (v9 & 1) == 0;
    *a1 = v5;
    if ( !v6 )
      sub_408790((std::_Lockit *)v8);
  }
  return 5;
}

//----- (00436FBF) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_436FBF(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE348;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE348;
  v2 = std::locale::id::operator unsigned int(&unk_4EE370);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_436B28(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE348 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE348: using guessed type int dword_4EE348;
// 436FBF: using guessed type char var_14[4];

//----- (0043705C) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_43705C(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE34C;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE34C;
  v2 = std::locale::id::operator unsigned int(&unk_4EE36C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_436BBD(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE34C = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE34C: using guessed type int dword_4EE34C;
// 43705C: using guessed type char var_14[4];

//----- (004370F9) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_4370F9(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE350;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE350;
  v2 = std::locale::id::operator unsigned int(&unk_4EE358);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_436CB4(&v7, (int)a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE350 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE350: using guessed type int dword_4EE350;
// 4370F9: using guessed type char var_14[4];

//----- (004376E7) --------------------------------------------------------
_DWORD *__thiscall sub_4376E7(_DWORD *this, unsigned int a2, char a3)
{
  unsigned int v3; // edx

  v3 = this[4];
  if ( a2 > v3 )
    return sub_405360(this, a2 - v3, a3);
  else
    return sub_407810(this, a2, 0xFFFFFFFF);
}

//----- (00437BDF) --------------------------------------------------------
_DWORD *__thiscall sub_437BDF(void **this, _DWORD *a2)
{
  sub_407D00(a2, this[6]);
  return a2;
}

//----- (00437BFB) --------------------------------------------------------
int __cdecl sub_437BFB(_Collvec **a1, void *a2)
{
  _Collvec *v2; // esi
  char *v3; // eax
  bool v4; // cf
  char v6[36]; // [esp+10h] [ebp-58h] BYREF
  _Collvec *v7; // [esp+34h] [ebp-34h]
  int v8; // [esp+38h] [ebp-30h]
  int v9[10]; // [esp+3Ch] [ebp-2Ch] BYREF
  int v10; // [esp+64h] [ebp-4h]

  v8 = 0;
  if ( a1 && !*a1 )
  {
    v2 = (_Collvec *)operator new(0x10u);
    v7 = v2;
    v10 = 0;
    if ( v2 )
    {
      v3 = (char *)sub_413350(a2, v9);
      v4 = *((_DWORD *)v3 + 5) < 0x10u;
      LOBYTE(v10) = 1;
      v8 = 1;
      if ( !v4 )
        v3 = *(char **)v3;
      sub_4086C0((struct std::_Locinfo *)v6, v3);
      v2->_LocaleName = 0;
      v8 = 3;
      v2->_Page = (unsigned int)&std::collate<char>::`vftable';
      v2[1] = _Getcoll();
    }
    else
    {
      v2 = 0;
    }
    v10 = 2;
    *a1 = v2;
    if ( (v8 & 2) != 0 )
    {
      v8 &= ~2u;
      sub_408790((std::_Lockit *)v6);
    }
    if ( (v8 & 1) != 0 )
      sub_407D70(v9, 1, 0);
  }
  return 1;
}
// 4BE22C: using guessed type void *std::collate<char>::`vftable';
// 437BFB: using guessed type _DWORD var_2C[10];

//----- (00437CB2) --------------------------------------------------------
struct std::locale::facet *__cdecl sub_437CB2(int *a1)
{
  int v1; // esi
  unsigned int v2; // eax
  struct std::locale::facet *v3; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-20h] BYREF
  char v6[4]; // [esp+1Ch] [ebp-14h] BYREF
  std::locale::facet *v7; // [esp+20h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v6, 0);
  v1 = dword_4EE354;
  v8 = 0;
  v7 = (std::locale::facet *)dword_4EE354;
  v2 = std::locale::id::operator unsigned int(&unk_4EE35C);
  v3 = (struct std::locale::facet *)sub_408320(a1, v2);
  if ( !v3 )
  {
    if ( v1 )
    {
      v3 = (struct std::locale::facet *)v1;
    }
    else
    {
      if ( sub_437BFB((_Collvec **)&v7, a1) == -1 )
      {
        sub_4398E3((std::exception *)pExceptionObject, "bad cast");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
      }
      v3 = v7;
      dword_4EE354 = (int)v7;
      std::locale::facet::_Incref(v7);
      std::locale::facet::_Facet_Register(v3);
    }
  }
  v8 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v6);
  return v3;
}
// 4082E0: using guessed type int __thiscall std::locale::id::operator unsigned int(_DWORD);
// 4EE354: using guessed type int dword_4EE354;
// 437CB2: using guessed type char var_14[4];

//----- (00439175) --------------------------------------------------------
_DWORD *__stdcall sub_439175(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v9; // esi
  _DWORD *v10; // ebx
  _DWORD v12[11]; // [esp+10h] [ebp-2Ch] BYREF

  v9 = a8;
  v10 = a9;
  std::money_get<char,std::istreambuf_iterator<char>>::_Getmfld(v12, &a2, &a4, a6, a7);
  v12[10] = 0;
  if ( (unsigned __int8)sub_428376(&a2, (int)&a4) )
    *v9 |= 1u;
  if ( v12[4] )
    sub_4078A0(v10, v12, 0, (void *)0xFFFFFFFF);
  else
    *v9 |= 2u;
  *a1 = a2;
  a1[1] = a3;
  sub_407D70(v12, 1, 0);
  return a1;
}
// 438185: using guessed type _DWORD __stdcall std::money_get<char,std::istreambuf_iterator<char>>::_Getmfld(_DWORD, _DWORD, _DWORD, char, _DWORD);

//----- (0043959D) --------------------------------------------------------
void __thiscall sub_43959D(struct type_info *this)
{
  *(_DWORD *)this = &type_info::`vftable';
  type_info::_Type_info_dtor(this);
}
// 4BE328: using guessed type void *type_info::`vftable';

//----- (004395AD) --------------------------------------------------------
void *__thiscall sub_4395AD(void *this, char a2)
{
  sub_43959D((struct type_info *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (004398D8) --------------------------------------------------------
void __thiscall sub_4398D8(std::exception *this)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy(this);
}
// 4BE330: using guessed type void *std::exception::`vftable';

//----- (004398E3) --------------------------------------------------------
std::exception *__thiscall sub_4398E3(std::exception *this, char *a2)
{
  std::exception::exception(this, (const char *const *)&a2);
  *(_DWORD *)this = &std::bad_cast::`vftable';
  return this;
}
// 4BE350: using guessed type void *std::bad_cast::`vftable';

//----- (00439901) --------------------------------------------------------
void *__thiscall sub_439901(void *this, char a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy((std::exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BE330: using guessed type void *std::exception::`vftable';

//----- (0043994D) --------------------------------------------------------
std::exception *__thiscall sub_43994D(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_cast::`vftable';
  return this;
}
// 4BE350: using guessed type void *std::bad_cast::`vftable';

//----- (0043E087) --------------------------------------------------------
void __thiscall sub_43E087(std::exception *this)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_4398D8(this);
}
// 4BECFC: using guessed type void *std::bad_exception::`vftable';

//----- (0043E092) --------------------------------------------------------
void *__thiscall sub_43E092(void *this, char a2)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_4398D8((std::exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4BECFC: using guessed type void *std::bad_exception::`vftable';

//----- (0043EC6D) --------------------------------------------------------
std::exception *__thiscall sub_43EC6D(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 4BECFC: using guessed type void *std::bad_exception::`vftable';

//----- (0044161F) --------------------------------------------------------
void *__cdecl sub_44161F(void *a1)
{
  void *result; // eax

  result = a1;
  dword_4EE6CC = a1;
  return result;
}

//----- (00441D40) --------------------------------------------------------
void *__cdecl sub_441D40(void *a1)
{
  void *result; // eax

  result = a1;
  dword_4EED3C = a1;
  return result;
}

//----- (00442102) --------------------------------------------------------
int sub_442102()
{
  dword_4F35E0 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 4F35E0: using guessed type int dword_4F35E0;

//----- (00443911) --------------------------------------------------------
void *__cdecl sub_443911(void *a1)
{
  void *result; // eax

  result = a1;
  dword_4EED58 = a1;
  return result;
}

//----- (00443962) --------------------------------------------------------
int sub_443962()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (00444126) --------------------------------------------------------
void *sub_444126()
{
  return &unk_4D4138;
}

//----- (0044414C) --------------------------------------------------------
void __cdecl sub_44414C()
{
  ;
}

//----- (004448F1) --------------------------------------------------------
int __cdecl sub_4448F1(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4DF534;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4DF534: using guessed type int dword_4DF534;

//----- (0044491E) --------------------------------------------------------
int __cdecl sub_44491E(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4DF538;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4DF538: using guessed type int dword_4DF538;

//----- (0044494B) --------------------------------------------------------
int __cdecl sub_44494B(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4DF530;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4DF530: using guessed type int dword_4DF530;

//----- (00444978) --------------------------------------------------------
int *sub_444978()
{
  return &dword_4DF534;
}
// 4DF534: using guessed type int dword_4DF534;

//----- (0044497E) --------------------------------------------------------
int *sub_44497E()
{
  return &dword_4DF538;
}
// 4DF538: using guessed type int dword_4DF538;

//----- (00444984) --------------------------------------------------------
int *sub_444984()
{
  return &dword_4DF530;
}
// 4DF530: using guessed type int dword_4DF530;

//----- (0044498A) --------------------------------------------------------
void **sub_44498A()
{
  return &off_4DF5C0;
}
// 4DF5C0: using guessed type void *off_4DF5C0;

//----- (00444F1C) --------------------------------------------------------
void *sub_444F1C()
{
  return &unk_4DF690;
}

//----- (00444F22) --------------------------------------------------------
char **sub_444F22()
{
  return off_4DF5E0;
}
// 4DF5E0: using guessed type char *off_4DF5E0[44];

//----- (00447CF8) --------------------------------------------------------
PVOID sub_447CF8()
{
  return DecodePointer(dword_4EF098);
}

//----- (00447EA8) --------------------------------------------------------
void sub_447EA8()
{
  dword_4F34C4 = 0;
}
// 4F34C4: using guessed type int dword_4F34C4;

//----- (0044888F) --------------------------------------------------------
void **sub_44888F()
{
  return &off_4DF7F8;
}
// 4DF7F8: using guessed type void *off_4DF7F8;

//----- (00448E92) --------------------------------------------------------
int __cdecl sub_448E92(int a1)
{
  int result; // eax

  result = a1;
  dword_4EF0E8 = a1;
  return result;
}
// 4EF0E8: using guessed type int dword_4EF0E8;

//----- (00448FFC) --------------------------------------------------------
int __cdecl sub_448FFC(int a1, int a2, int a3)
{
  HMODULE LibraryW; // eax
  HMODULE v4; // ebx
  int (__stdcall *MessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationW)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v10)(void); // edi
  int (__stdcall *v11)(int, int, char *, int, char *); // eax
  int (__stdcall *v12)(int, int, char *, int, char *); // ebx
  int v13; // eax
  int (*v14)(void); // eax
  int (__stdcall *v15)(int); // eax
  int (__stdcall *v16)(int, int, int, int); // eax
  char v18[4]; // [esp+Ch] [ebp-24h] BYREF
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  PVOID v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  char v23[12]; // [esp+20h] [ebp-10h] BYREF

  v19 = a1;
  v20 = a2;
  v22 = 0;
  v21 = (PVOID)_encoded_null();
  if ( !dword_4EF0EC )
  {
    LibraryW = LoadLibraryW(L"USER32.DLL");
    v4 = LibraryW;
    if ( !LibraryW )
      return 0;
    MessageBoxW = (int (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))GetProcAddress(LibraryW, "MessageBoxW");
    if ( !MessageBoxW )
      return 0;
    dword_4EF0EC = EncodePointer(MessageBoxW);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v4, "GetActiveWindow");
    dword_4EF0F0 = EncodePointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v4, "GetLastActivePopup");
    dword_4EF0F4 = EncodePointer(GetLastActivePopup);
    GetUserObjectInformationW = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v4,
                                                                                          "GetUserObjectInformationW");
    dword_4EF0FC = EncodePointer(GetUserObjectInformationW);
    if ( dword_4EF0FC )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v4, "GetProcessWindowStation");
      dword_4EF0F8 = EncodePointer(GetProcessWindowStation);
    }
  }
  if ( dword_4EF0F8 == v21
    || dword_4EF0FC == v21
    || (v10 = (int (*)(void))DecodePointer(dword_4EF0F8),
        v11 = (int (__stdcall *)(int, int, char *, int, char *))DecodePointer(dword_4EF0FC),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, v23, 12, v18) && (v23[8] & 1) != 0 )
  {
    if ( dword_4EF0F0 != v21 )
    {
      v14 = (int (*)(void))DecodePointer(dword_4EF0F0);
      if ( v14 )
      {
        v22 = v14();
        if ( v22 )
        {
          if ( dword_4EF0F4 != v21 )
          {
            v15 = (int (__stdcall *)(int))DecodePointer(dword_4EF0F4);
            if ( v15 )
              v22 = v15(v22);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))DecodePointer(dword_4EF0EC);
  if ( v16 )
    return v16(v22, v19, v20, a3);
  return 0;
}
// 442E9B: using guessed type int _encoded_null(void);
// 448FFC: using guessed type char var_24[4];

//----- (0044934C) --------------------------------------------------------
int sub_44934C()
{
  return 0;
}

//----- (0044A81D) --------------------------------------------------------
int __cdecl sub_44A81D(int a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_44ACD7((unsigned __int16 *)v11, (_DWORD *)a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 44B779: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 44A81D: using guessed type char var_28[4];
// 44A81D: using guessed type unsigned __int16 var_10[6];

//----- (0044A8C5) --------------------------------------------------------
int __cdecl sub_44A8C5(int a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_44B228((unsigned __int16 *)v11, (_DWORD *)a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 44B779: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 44A8C5: using guessed type char var_28[4];
// 44A8C5: using guessed type unsigned __int16 var_10[6];

//----- (0044ACD7) --------------------------------------------------------
int __cdecl sub_44ACD7(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_4DFB08 - 1;
    v53 = v3;
    v59 = dword_4DFB08 / 32;
    v9 = &v74 + dword_4DFB08 / 32;
    v51 = 31 - dword_4DFB08 % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_4DFB08 / 32;
      for ( i = (~(-1 << (31 - dword_4DFB08 % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_4DFB04 - dword_4DFB08 )
    {
      if ( v3 > dword_4DFB04 )
      {
        if ( v3 < dword_4DFB00 )
        {
          v5 = dword_4DFB14 + v3;
          v74 &= ~0x80000000;
          v44 = dword_4DFB0C / 32;
          v45 = dword_4DFB0C % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_4DFB0C / 32;
          v40 = dword_4DFB0C % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_4DFB00 + dword_4DFB14;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_4DFB04 - v53) / 32;
      v76 = v73;
      v18 = (dword_4DFB04 - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_4DFB08 - 1;
      v23 = dword_4DFB08 / 32;
      v52 = dword_4DFB08 / 32;
      v24 = &v74 + dword_4DFB08 / 32;
      v55 = 31 - dword_4DFB08 % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_4DFB08 % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_4DFB0C + 1) / 32;
      v35 = (dword_4DFB0C + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_4DFB0C));
  if ( dword_4DFB10 == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_4DFB10 == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 4DFB00: using guessed type int dword_4DFB00;
// 4DFB04: using guessed type int dword_4DFB04;
// 4DFB08: using guessed type int dword_4DFB08;
// 4DFB0C: using guessed type int dword_4DFB0C;
// 4DFB10: using guessed type int dword_4DFB10;
// 4DFB14: using guessed type int dword_4DFB14;

//----- (0044B228) --------------------------------------------------------
int __cdecl sub_44B228(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_4DFB20 - 1;
    v53 = v3;
    v59 = dword_4DFB20 / 32;
    v9 = &v74 + dword_4DFB20 / 32;
    v51 = 31 - dword_4DFB20 % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_4DFB20 / 32;
      for ( i = (~(-1 << (31 - dword_4DFB20 % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_4DFB1C - dword_4DFB20 )
    {
      if ( v3 > dword_4DFB1C )
      {
        if ( v3 < dword_4DFB18 )
        {
          v5 = dword_4DFB2C + v3;
          v74 &= ~0x80000000;
          v44 = dword_4DFB24 / 32;
          v45 = dword_4DFB24 % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_4DFB24 / 32;
          v40 = dword_4DFB24 % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_4DFB18 + dword_4DFB2C;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_4DFB1C - v53) / 32;
      v76 = v73;
      v18 = (dword_4DFB1C - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_4DFB20 - 1;
      v23 = dword_4DFB20 / 32;
      v52 = dword_4DFB20 / 32;
      v24 = &v74 + dword_4DFB20 / 32;
      v55 = 31 - dword_4DFB20 % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_4DFB20 % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_4DFB24 + 1) / 32;
      v35 = (dword_4DFB24 + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_4DFB24));
  if ( dword_4DFB28 == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_4DFB28 == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 4DFB18: using guessed type int dword_4DFB18;
// 4DFB1C: using guessed type int dword_4DFB1C;
// 4DFB20: using guessed type int dword_4DFB20;
// 4DFB24: using guessed type int dword_4DFB24;
// 4DFB28: using guessed type int dword_4DFB28;
// 4DFB2C: using guessed type int dword_4DFB2C;

//----- (0044C272) --------------------------------------------------------
int sub_44C272()
{
  return flsall(1);
}
// 44C198: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (0044D77C) --------------------------------------------------------
HANDLE sub_44D77C()
{
  HANDLE result; // eax

  result = hObject;
  if ( hObject != (HANDLE)-1 && hObject != (HANDLE)-2 )
    return (HANDLE)CloseHandle(hObject);
  return result;
}

//----- (0044DFE0) --------------------------------------------------------
void __stdcall __noreturn sub_44DFE0(int a1)
{
  off_4DFDF0(a1, 0);
}
// 4DFDF0: using guessed type int (__cdecl *off_4DFDF0)(_DWORD, _DWORD);

//----- (0044E000) --------------------------------------------------------
HLOCAL __thiscall sub_44E000(_DWORD *this)
{
  HLOCAL result; // eax
  void *v3; // esi

  result = (HLOCAL)this[2];
  *this = &off_4C1054;
  if ( result )
    result = (HLOCAL)(*(int (__stdcall **)(HLOCAL))(*(_DWORD *)result + 8))(result);
  v3 = (void *)this[3];
  if ( v3 )
    return LocalFree(v3);
  return result;
}
// 4C1054: using guessed type int (__thiscall *off_4C1054)(void *, char);

//----- (0044E030) --------------------------------------------------------
void __cdecl __noreturn sub_44E030(int a1, int a2)
{
  int pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  pExceptionObject[0] = (int)&off_4C1054;
  pExceptionObject[1] = a1;
  pExceptionObject[2] = a2;
  pExceptionObject[3] = 0;
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI1_AV_com_error__);
}
// 4C1054: using guessed type int (__thiscall *off_4C1054)(void *, char);

//----- (0044E070) --------------------------------------------------------
_DWORD *__thiscall sub_44E070(_DWORD *this, int a2)
{
  int v3; // edx

  *this = &off_4C1054;
  this[1] = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  this[2] = v3;
  this[3] = 0;
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v3);
  return this;
}
// 4C1054: using guessed type int (__thiscall *off_4C1054)(void *, char);

//----- (0044E0B0) --------------------------------------------------------
void *__thiscall sub_44E0B0(void *this, char a2)
{
  int v3; // eax

  v3 = *((_DWORD *)this + 2);
  *(_DWORD *)this = &off_4C1054;
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  if ( *((_DWORD *)this + 3) )
    LocalFree(*((HLOCAL *)this + 3));
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4C1054: using guessed type int (__thiscall *off_4C1054)(void *, char);

//----- (0044E100) --------------------------------------------------------
int __userpurge sub_44E100@<eax>(HWND a1@<esi>, int *a2)
{
  LONG WindowLongW; // ebx
  int result; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-18h] BYREF

  WindowLongW = GetWindowLongW(a1, -16);
  result = GetClientRect(a1, &Rect);
  if ( (WindowLongW & 0x100000) != 0 )
  {
    result = *a2;
    if ( *a2 >= 20 )
    {
      if ( result > Rect.right - 20 )
        result = SendMessageW(a1, 0x1014u, 0xAu, 0);
    }
    else
    {
      result = SendMessageW(a1, 0x1014u, 0xFFFFFFF6, 0);
    }
  }
  if ( (WindowLongW & 0x200000) != 0 )
  {
    result = a2[1];
    if ( result >= 20 )
    {
      if ( result > Rect.bottom - 20 )
        return SendMessageW(a1, 0x1014u, 0, 10);
    }
    else
    {
      return SendMessageW(a1, 0x1014u, 0, -10);
    }
  }
  return result;
}

//----- (0044E1C0) --------------------------------------------------------
int __stdcall sub_44E1C0(int a1, int a2, int a3)
{
  return *(_DWORD *)(560 * a1 + *(_DWORD *)(a3 + 52) + 556) - *(_DWORD *)(560 * a2 + *(_DWORD *)(a3 + 52) + 556);
}

//----- (0044E1F0) --------------------------------------------------------
BOOL __userpurge sub_44E1F0@<eax>(int a1@<ebx>, int a2)
{
  int (__stdcall *v2)(int, __int16 *, char *); // edx
  BOOL IsSameRootW; // esi
  HDROP v4; // eax
  HDROP v5; // edi
  char v7[4]; // [esp+4h] [ebp-434h] BYREF
  HGLOBAL hMem; // [esp+8h] [ebp-430h]
  __int16 v9; // [esp+10h] [ebp-428h] BYREF
  int v10; // [esp+14h] [ebp-424h]
  int v11; // [esp+18h] [ebp-420h]
  int v12; // [esp+1Ch] [ebp-41Ch]
  int v13; // [esp+20h] [ebp-418h]
  WCHAR szFile[260]; // [esp+24h] [ebp-414h] BYREF
  WCHAR pszPath1[260]; // [esp+22Ch] [ebp-20Ch] BYREF

  v2 = *(int (__stdcall **)(int, __int16 *, char *))(*(_DWORD *)a2 + 12);
  v9 = 15;
  v11 = 1;
  v13 = 1;
  IsSameRootW = 0;
  v10 = 0;
  v12 = -1;
  if ( v2(a2, &v9, v7) )
    return 0;
  v4 = (HDROP)GlobalLock(hMem);
  v5 = v4;
  if ( v4 )
  {
    if ( (int)DragQueryFileW(v4, 0xFFFFFFFF, 0, 0) > 0 )
    {
      DragQueryFileW(v5, 0, szFile, 0x104u);
      (*(void (__thiscall **)(int, int, WCHAR *))(*(_DWORD *)(a1 + 8) + 52))(a1 + 8, 260, pszPath1);
      IsSameRootW = PathIsSameRootW(pszPath1, szFile);
    }
    GlobalUnlock(hMem);
  }
  return IsSameRootW;
}
// 44E1F0: using guessed type char var_434[4];

//----- (0044E300) --------------------------------------------------------
int __stdcall sub_44E300(int a1)
{
  HWND v2; // [esp-10h] [ebp-50h]
  WPARAM v3; // [esp-8h] [ebp-48h]
  LPARAM lParam[13]; // [esp+Ch] [ebp-34h] BYREF

  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 1056) + 16))(*(_DWORD *)(a1 + 1056));
  sub_4693F0(*(HWND *)(a1 + 12), 0);
  if ( *(_DWORD *)(a1 + 1104) )
  {
    v3 = *(_DWORD *)(a1 + 1116);
    v2 = *(HWND *)(a1 + 12);
    lParam[4] = 2;
    lParam[3] = 0;
    SendMessageW(v2, 0x102Bu, v3, (LPARAM)lParam);
  }
  *(_DWORD *)(a1 + 20) = 0;
  return 0;
}

//----- (0044E360) --------------------------------------------------------
_DWORD *__userpurge sub_44E360@<eax>(WPARAM a1@<esi>, LONG *a2)
{
  LONG v2; // edx
  HWND v3; // edi
  LONG WindowLongW; // eax
  _DWORD *v5; // ecx
  _DWORD *result; // eax
  int v7; // ebx
  signed int v8; // ebx
  LPARAM i; // ebx
  int v10; // eax
  WPARAM v11; // ebx
  LRESULT v12; // eax
  LRESULT v13; // eax
  HWND v14; // edx
  int v15; // eax
  LRESULT v16; // eax
  HWND v17; // edx
  int v18; // edx
  HWND v19; // edi
  LONG v20; // eax
  HWND v21; // [esp-10h] [ebp-E4h]
  HWND v22; // [esp-10h] [ebp-E4h]
  HWND v23; // [esp-10h] [ebp-E4h]
  HWND v24; // [esp-10h] [ebp-E4h]
  HWND v25; // [esp-10h] [ebp-E4h]
  HWND v26; // [esp-10h] [ebp-E4h]
  HWND v27; // [esp-10h] [ebp-E4h]
  HWND v28; // [esp-8h] [ebp-DCh]
  WPARAM v29; // [esp-8h] [ebp-DCh]
  LPARAM *v30; // [esp-4h] [ebp-D8h]
  LPARAM v31[8]; // [esp+Ch] [ebp-C8h] BYREF
  int v32; // [esp+2Ch] [ebp-A8h]
  int v33[2]; // [esp+40h] [ebp-94h] BYREF
  LPARAM v34[2]; // [esp+48h] [ebp-8Ch] BYREF
  LPARAM v35[2]; // [esp+50h] [ebp-84h] BYREF
  int v36[2]; // [esp+58h] [ebp-7Ch] BYREF
  LPARAM lParam; // [esp+60h] [ebp-74h] BYREF
  int v38; // [esp+64h] [ebp-70h]
  LPARAM v39[3]; // [esp+68h] [ebp-6Ch] BYREF
  LONG x; // [esp+74h] [ebp-60h]
  LONG y; // [esp+78h] [ebp-5Ch]
  int v42; // [esp+7Ch] [ebp-58h]
  LPARAM v43; // [esp+80h] [ebp-54h] BYREF
  int v44; // [esp+84h] [ebp-50h]
  _DWORD *v45; // [esp+88h] [ebp-4Ch]
  int v46; // [esp+8Ch] [ebp-48h]
  int v47; // [esp+90h] [ebp-44h]
  BOOL v48; // [esp+94h] [ebp-40h]
  int v49; // [esp+98h] [ebp-3Ch]
  struct tagPOINT Point; // [esp+9Ch] [ebp-38h] BYREF
  WPARAM v51; // [esp+A4h] [ebp-30h]
  struct tagPOINT v52; // [esp+A8h] [ebp-2Ch] BYREF
  char v53; // [esp+B0h] [ebp-24h]
  WPARAM wParam; // [esp+B4h] [ebp-20h]
  LPARAM v55[2]; // [esp+BCh] [ebp-18h] BYREF
  int v56; // [esp+C4h] [ebp-10h]
  LONG v57; // [esp+C8h] [ebp-Ch]

  v2 = a2[1];
  Point.x = *a2;
  v28 = *(HWND *)(a1 + 28);
  Point.y = v2;
  ScreenToClient(v28, &Point);
  if ( *(_DWORD *)(a1 + 736) )
  {
    v3 = *(HWND *)(a1 + 28);
    WindowLongW = GetWindowLongW(v3, -16);
    if ( (WindowLongW & 0x100) != 0 )
      WindowLongW &= ~0x100u;
    SetWindowLongW(v3, -16, WindowLongW);
  }
  v5 = *(_DWORD **)(a1 + 1088);
  result = (_DWORD *)*v5;
  v45 = result;
  if ( result != v5 )
  {
    while ( 1 )
    {
      v7 = (*(int (__thiscall **)(WPARAM, _DWORD *))(*(_DWORD *)(a1 + 8) + 180))(a1 + 8, result + 2);
      v46 = v7;
      if ( v7 == -1 )
        goto LABEL_54;
      if ( *(_DWORD *)(a1 + 636) == 4 )
      {
        v8 = 0;
        v21 = *(HWND *)(a1 + 28);
        v48 = 1;
        v47 = 0;
        v51 = 0;
        v49 = SendMessageW(v21, 0x1004u, 0, 0);
        if ( v49 > 0 )
        {
          while ( 1 )
          {
            SendMessageW(*(HWND *)(a1 + 28), 0x1010u, v8, (LPARAM)&lParam);
            if ( v48 )
            {
              if ( Point.y - v38 < 0 )
                break;
            }
            if ( v8 == v49 - 1 )
              v47 = v49;
            ++v8;
            v48 = Point.y - v38 > 0;
            if ( v8 >= v49 )
              goto LABEL_18;
          }
          v47 = v8 - 1;
        }
LABEL_18:
        for ( i = 0; i < v49; ++i )
        {
          v22 = *(HWND *)(a1 + 28);
          v31[0] = 4;
          v31[1] = i;
          v31[2] = 0;
          if ( SendMessageW(v22, 0x104Bu, 0, (LPARAM)v31) )
          {
            if ( i == v46 )
            {
              *(_DWORD *)(*(_DWORD *)(a1 + 52) + 560 * v32 + 556) = v47;
            }
            else
            {
              v10 = v51;
              if ( v51 == v47 )
                v10 = ++v51;
              *(_DWORD *)(*(_DWORD *)(a1 + 52) + 560 * v32 + 556) = v10;
            }
          }
          ++v51;
        }
        SendMessageW(*(HWND *)(a1 + 28), 0x1030u, a1, (LPARAM)sub_44E1C0);
      }
      else
      {
        if ( *(_DWORD *)(a1 + 736) )
        {
          v52 = Point;
          v23 = *(HWND *)(a1 + 28);
          v48 = 0;
          v49 = 0;
          v11 = SendMessageW(v23, 0x1012u, 0, (LPARAM)&v52);
          v51 = v11;
          if ( v11 == -1 || (v53 & 0xE) == 0 )
          {
            x = Point.x;
            v25 = *(HWND *)(a1 + 28);
            v39[0] = 64;
            y = Point.y;
            v42 = 38;
            v11 = SendMessageW(v25, 0x1053u, 0xFFFFFFFF, (LPARAM)v39);
            if ( v11 == -1 )
            {
              x = Point.x;
              v26 = *(HWND *)(a1 + 28);
              v39[0] = 64;
              y = Point.y;
              v42 = 37;
              v11 = SendMessageW(v26, 0x1053u, 0xFFFFFFFF, (LPARAM)v39);
            }
            v27 = *(HWND *)(a1 + 28);
            v55[0] = 0;
            SendMessageW(v27, 0x100Eu, v11, (LPARAM)v55);
            if ( Point.x > v55[0] + (v56 - v55[0]) / 2 )
            {
              if ( Point.y > v57 )
              {
                v12 = SendMessageW(*(HWND *)(a1 + 28), 0x100Cu, v11, 512);
                if ( v12 != -1 )
                  v11 = v12;
              }
              v48 = 1;
            }
            v13 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
            v14 = *(HWND *)(a1 + 28);
            v51 = v13;
            v55[0] = 0;
            SendMessageW(v14, 0x100Eu, v13 - 1, (LPARAM)v55);
            v15 = (v56 - v55[0]) / 2;
            if ( Point.x <= v15 + v55[0] || Point.x >= v15 + v56 + 2 || Point.y <= v55[1] )
            {
              if ( !v48 )
              {
                v16 = SendMessageW(*(HWND *)(a1 + 28), 0x100Cu, v11, 1024);
                if ( v16 == -1 )
                  v49 = 1;
                else
                  v11 = v16;
              }
            }
            else
            {
              v11 = v51 - 1;
            }
          }
          else
          {
            v24 = *(HWND *)(a1 + 28);
            v55[0] = 0;
            SendMessageW(v24, 0x100Eu, wParam, (LPARAM)v55);
            if ( Point.x - v55[0] <= (v56 - v55[0]) / 2 )
            {
              v11 = SendMessageW(*(HWND *)(a1 + 28), 0x100Cu, v11, 1024);
              if ( v11 == -1 )
                v11 = v51;
              v49 = SendMessageW(*(HWND *)(a1 + 28), 0x100Cu, v11, 1024) == -1;
            }
          }
          SendMessageW(*(HWND *)(a1 + 28), 0x1010u, v11, (LPARAM)&v43);
          if ( v49 )
          {
            v33[1] = v44;
            v17 = *(HWND *)(a1 + 28);
            v33[0] = 0;
            SendMessageW(v17, 0x1031u, v46, (LPARAM)v33);
            goto LABEL_54;
          }
          v36[0] = v43 + 1;
          v30 = v36;
          v36[1] = v44;
          v29 = v46;
        }
        else
        {
          SendMessageW(*(HWND *)(a1 + 28), 0x1029u, 0, (LPARAM)v34);
          v18 = v34[1] - *(_DWORD *)(a1 + 1108);
          v30 = v35;
          v35[0] = Point.x + v34[0] - *(_DWORD *)(a1 + 1104);
          v35[1] = Point.y + v18;
          v29 = v7;
        }
        SendMessageW(*(HWND *)(a1 + 28), 0x1031u, v29, (LPARAM)v30);
      }
LABEL_54:
      result = (_DWORD *)*v45;
      v45 = result;
      if ( result == *(_DWORD **)(a1 + 1088) )
        break;
      result = v45;
    }
  }
  if ( *(_DWORD *)(a1 + 736) )
  {
    v19 = *(HWND *)(a1 + 28);
    v20 = GetWindowLongW(v19, -16);
    if ( (v20 & 0x100) == 0 )
      v20 |= 0x100u;
    result = (_DWORD *)SetWindowLongW(v19, -16, v20);
  }
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 1116) = 0;
  return result;
}

//----- (0044E7F0) --------------------------------------------------------
int __userpurge sub_44E7F0@<eax>(_DWORD *a1@<esi>, LPARAM *a2)
{
  LPARAM v2; // eax
  LRESULT (__stdcall *v3)(HWND, UINT, WPARAM, LPARAM); // ebx
  int v4; // edi
  int result; // eax
  bool v6; // zf
  _DWORD **v7; // eax
  _DWORD *v8; // edi
  char v9; // al
  HWND v10; // [esp-10h] [ebp-A0h]
  HWND v11; // [esp-10h] [ebp-A0h]
  HWND v12; // [esp-10h] [ebp-A0h]
  WPARAM v13; // [esp-8h] [ebp-98h]
  WPARAM v14; // [esp-8h] [ebp-98h]
  LPARAM v15[8]; // [esp+8h] [ebp-88h] BYREF
  int v16; // [esp+28h] [ebp-68h]
  LPARAM v17[3]; // [esp+3Ch] [ebp-54h] BYREF
  int v18; // [esp+48h] [ebp-48h]
  int v19; // [esp+4Ch] [ebp-44h]
  int v20; // [esp+70h] [ebp-20h]
  int v21; // [esp+74h] [ebp-1Ch]
  LPARAM lParam[2]; // [esp+78h] [ebp-18h] BYREF
  char v23; // [esp+80h] [ebp-10h]
  WPARAM wParam; // [esp+84h] [ebp-Ch]

  v2 = a2[1];
  v3 = SendMessageW;
  lParam[0] = *a2;
  lParam[1] = v2;
  v10 = (HWND)a1[7];
  v20 = 0;
  v21 = 0;
  v4 = -1;
  result = SendMessageW(v10, 0x1012u, 0, (LPARAM)lParam);
  if ( (v23 & 1) == 0 )
  {
    result = wParam;
    if ( wParam != -1 )
    {
      v11 = (HWND)a1[7];
      v15[0] = 4;
      v15[1] = wParam;
      v15[2] = 0;
      SendMessageW(v11, 0x104Bu, 0, (LPARAM)v15);
      result = v16;
      v4 = v16;
      if ( v16 != -1 )
      {
        v6 = a1[282] == 0;
        v21 = 1;
        if ( v6 )
          goto LABEL_9;
        result = wParam;
        if ( wParam == a1[283] )
          return result;
      }
    }
  }
  if ( a1[282] && a1[280] )
  {
    v13 = a1[283];
    v12 = (HWND)a1[7];
    v19 = 2;
    v18 = 0;
    result = SendMessageW(v12, 0x102Bu, v13, (LPARAM)v17);
  }
LABEL_9:
  v6 = v21 == 0;
  a1[282] = 0;
  if ( !v6 && (*(_BYTE *)(592 * v4 + a1[12]) & 0x10) != 0 )
  {
    if ( !a1[279] )
      goto LABEL_18;
    v7 = (_DWORD **)a1[272];
    v8 = *v7;
    if ( *v7 == v7 )
      goto LABEL_18;
    do
    {
      result = (*(int (__thiscall **)(_DWORD *, _DWORD *))(a1[2] + 180))(a1 + 2, v8 + 2);
      if ( wParam == result )
        v20 = 1;
      v8 = (_DWORD *)*v8;
    }
    while ( v8 != (_DWORD *)a1[272] );
    if ( !v20 )
    {
      v3 = SendMessageW;
LABEL_18:
      v9 = v3((HWND)a1[7], 0x102Cu, wParam, 2);
      v14 = wParam;
      v19 = 2;
      v18 = 2;
      a1[280] = (v9 & 2) != 2;
      v3((HWND)a1[7], 0x102Bu, v14, (LPARAM)v17);
      result = wParam;
      a1[283] = wParam;
      a1[282] = 1;
    }
  }
  return result;
}

//----- (0044E9B0) --------------------------------------------------------
int __stdcall sub_44E9B0(int a1, char a2, LONG a3, LONG a4, int *a5)
{
  int v5; // eax
  int v6; // ecx
  struct tagPOINT *p_Point; // esi
  struct tagPOINT Point; // [esp+Ch] [ebp-1Ch] BYREF
  struct tagRECT Rect; // [esp+14h] [ebp-14h] BYREF

  if ( *(_DWORD *)(a1 + 1096) )
    v5 = sub_466220(a2, *a5, *(_DWORD *)(a1 + 1108));
  else
    v5 = 0;
  *a5 = v5;
  Point.y = a4;
  v6 = *(_DWORD *)(a1 + 1056);
  Point.x = a3;
  (*(void (__stdcall **)(int, struct tagPOINT *, int))(*(_DWORD *)v6 + 20))(v6, &Point, v5);
  ScreenToClient(*(HWND *)(a1 + 12), &Point);
  GetClientRect(*(HWND *)(a1 + 12), &Rect);
  sub_44E100(*(HWND *)(a1 + 12), &Point.x);
  sub_44E7F0((_DWORD *)(a1 - 16), &Point.x);
  if ( *(_DWORD *)(a1 + 1096) )
  {
    if ( *(_DWORD *)(a1 + 1112) )
      p_Point = 0;
    else
      p_Point = &Point;
    sub_4693F0(*(HWND *)(a1 + 12), &p_Point->x);
  }
  return 0;
}

//----- (0044EA90) --------------------------------------------------------
int __stdcall sub_44EA90(char *a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // esi
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // ebx
  _DWORD *v10; // edi
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  _DWORD *v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // edi
  BOOL v18; // eax
  bool v19; // zf
  int *v20; // ebx
  int v21; // ecx
  int v22; // ecx
  int v24; // [esp-4h] [ebp-54h]
  int v25; // [esp-4h] [ebp-54h]
  int v26[5]; // [esp+10h] [ebp-40h] BYREF
  int pExceptionObject[3]; // [esp+24h] [ebp-2Ch] BYREF
  void *v28[3]; // [esp+30h] [ebp-20h] BYREF
  int v29[2]; // [esp+3Ch] [ebp-14h] BYREF
  int v30; // [esp+4Ch] [ebp-4h]

  v6 = a1;
  *((_DWORD *)a1 + 5) = 1;
  *((_DWORD *)v6 + 276) = 0;
  *((_DWORD *)v6 + 279) = -1;
  if ( !*((_DWORD *)v6 + 156) || *((_DWORD *)v6 + 275) )
  {
    v28[1] = 0;
    v8 = operator new(0x1Cu);
    if ( !v8 )
    {
      a1 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&a1);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v8 = v8;
    v28[0] = v8;
    v8[1] = v8;
    v30 = 0;
    sub_45F8F0((int)v28);
    v9 = v28[0];
    v10 = *(_DWORD **)v28[0];
    if ( *(void **)v28[0] == v28[0] )
    {
LABEL_8:
      v15 = (_DWORD *)a6;
      *((_DWORD *)v6 + 274) = 0;
      *v15 = 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = v10[2];
        v12 = v10[4];
        v26[1] = v10[3];
        v13 = v10[6];
        v26[0] = v11;
        v14 = v10[5];
        v26[2] = v12;
        v26[4] = v13;
        v26[3] = v14;
        if ( !(*(int (__stdcall **)(int, int *))(*(_DWORD *)a2 + 20))(a2, v26) )
          break;
        v10 = (_DWORD *)*v10;
        if ( v10 == v9 )
          goto LABEL_8;
      }
      v24 = a2;
      *((_DWORD *)v6 + 274) = 1;
      v18 = sub_44E1F0((int)(v6 - 16), v24);
      v19 = *((_DWORD *)v6 + 274) == 0;
      v20 = (int *)a6;
      *((_DWORD *)v6 + 277) = v18;
      v21 = *v20;
      if ( v19 )
      {
        *v20 = 0;
        v9 = v28[0];
      }
      else if ( ((a3 & 8) != 0 && (a3 & 4) != 0 || (a3 & 0x20) != 0) && (v21 & 4) != 0 )
      {
        *v20 = 4;
        v9 = v28[0];
      }
      else if ( (a3 & 4) != 0 && (v21 & 2) != 0 )
      {
        *v20 = 2;
        v9 = v28[0];
      }
      else if ( (a3 & 8) == 8 && (v21 & 1) != 0 )
      {
        *v20 = 1;
        v9 = v28[0];
      }
      else if ( v18 && (v21 & 2) != 0 )
      {
        *v20 = 2;
        v9 = v28[0];
      }
      else if ( (v21 & 1) != 0 )
      {
        *v20 = 1;
        v9 = v28[0];
      }
      else
      {
        if ( (v21 & 2) != 0 )
          *v20 = 2;
        else
          *v20 &= 4u;
        v9 = v28[0];
      }
    }
    v30 = -1;
    v16 = (_DWORD *)*v9;
    *v9 = v9;
    v9[1] = v9;
    if ( v16 != v9 )
    {
      do
      {
        v17 = (_DWORD *)*v16;
        operator delete(v16);
        v16 = v17;
      }
      while ( v17 != v9 );
    }
    operator delete(v9);
  }
  else
  {
    v7 = (_DWORD *)a6;
    *((_DWORD *)v6 + 274) = 0;
    *v7 = 0;
  }
  if ( (a3 & 1) != 0 )
  {
    *((_DWORD *)v6 + 271) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *((_DWORD *)v6 + 271) = 1;
  }
  v29[1] = a5;
  v25 = *(_DWORD *)a6;
  v22 = *((_DWORD *)v6 + 3);
  v29[0] = a4;
  (*(void (__stdcall **)(_DWORD, int, int, int *, int))(**((_DWORD **)v6 + 264) + 12))(
    *((_DWORD *)v6 + 264),
    v22,
    a2,
    v29,
    v25);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0044ED10) --------------------------------------------------------
void __thiscall sub_44ED10(int this, _DWORD **a2, LONG *a3)
{
  LONG v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  void **v7; // esi
  WCHAR *v8; // eax
  int v9; // edx
  int v10; // esi
  WCHAR v11; // cx
  int v12; // esi
  char **v13; // eax
  int v14; // ecx
  HWND v15; // [esp-8h] [ebp-274h]
  struct tagPOINT Point; // [esp+14h] [ebp-258h] BYREF
  _DWORD *i; // [esp+1Ch] [ebp-250h]
  LPARAM lParam[2]; // [esp+20h] [ebp-24Ch] BYREF
  void *v19[5]; // [esp+28h] [ebp-244h] BYREF
  unsigned int v20; // [esp+3Ch] [ebp-230h]
  WCHAR pszPath[260]; // [esp+44h] [ebp-228h] BYREF
  int v22; // [esp+24Ch] [ebp-20h]
  int v23; // [esp+250h] [ebp-1Ch]
  int v24; // [esp+268h] [ebp-4h]

  if ( !*(_DWORD *)(this + 1108) )
  {
    SendMessageW(*(HWND *)(this + 8), 0x1029u, 0, (LPARAM)lParam);
    v4 = a3[1];
    Point.x = *a3;
    v15 = *(HWND *)(this + 8);
    Point.y = v4;
    ScreenToClient(v15, &Point);
    v23 = lParam[1] + Point.y;
    v5 = *a2;
    v22 = lParam[0] + Point.x;
    v6 = (_DWORD *)*v5;
    for ( i = v5; v6 != i; v6 = (_DWORD *)*v6 )
    {
      LOWORD(v19[0]) = 0;
      v20 = 7;
      v19[4] = 0;
      sub_4090E0((int)v19, v6 + 2, 0, 0xFFFFFFFF);
      v24 = 0;
      v7 = (void **)v19[0];
      if ( v20 < 8 )
        v7 = v19;
      v8 = pszPath;
      v9 = 260;
      v10 = (char *)v7 - (char *)pszPath;
      while ( v9 != -2147483386 )
      {
        v11 = *(WCHAR *)((char *)v8 + v10);
        if ( !v11 )
          break;
        *v8++ = v11;
        if ( !--v9 )
        {
          --v8;
          break;
        }
      }
      *v8 = 0;
      PathStripPathW(pszPath);
      v12 = *(_DWORD *)(this + 1056);
      v13 = sub_41EE00((char *)v12, *(_DWORD *)(v12 + 4), (int)pszPath);
      v14 = *(_DWORD *)(this + 1060);
      if ( v14 == 8134406 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(this + 1060) = v14 + 1;
      *(_DWORD *)(v12 + 4) = v13;
      *(_DWORD *)v13[1] = v13;
      v24 = -1;
      if ( v20 >= 8 )
        operator delete(v19[0]);
    }
  }
}
// 44EE30: conditional instruction was optimized away because edx.4!=0

//----- (0044EEE0) --------------------------------------------------------
int __stdcall sub_44EEE0(int *a1, int *a2, int a3, int a4, int a5, int *a6)
{
  int v6; // eax
  void (__stdcall *v7)(int, int *, int **, int); // eax
  void (__thiscall *v8)(int *, int, WCHAR *); // eax
  int v9; // ecx
  HDROP v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // ebx
  int *v13; // eax
  int v15; // [esp+8h] [ebp-298h]
  HWND v16; // [esp+8h] [ebp-298h]
  HWND v17; // [esp+8h] [ebp-298h]
  WPARAM v18; // [esp+10h] [ebp-290h]
  int v19; // [esp+14h] [ebp-28Ch]
  int *v20; // [esp+24h] [ebp-27Ch] BYREF
  int *v21; // [esp+28h] [ebp-278h]
  int *v22[2]; // [esp+2Ch] [ebp-274h] BYREF
  __int16 v23; // [esp+34h] [ebp-26Ch] BYREF
  int v24; // [esp+38h] [ebp-268h]
  int v25; // [esp+3Ch] [ebp-264h]
  int v26; // [esp+40h] [ebp-260h]
  int v27; // [esp+44h] [ebp-25Ch]
  char v28[4]; // [esp+48h] [ebp-258h] BYREF
  HGLOBAL hMem; // [esp+4Ch] [ebp-254h]
  LPARAM lParam[13]; // [esp+54h] [ebp-24Ch] BYREF
  WCHAR pszPath[266]; // [esp+88h] [ebp-218h] BYREF

  v19 = *a6;
  v23 = 15;
  v25 = 1;
  v27 = 1;
  v6 = a1[264];
  v24 = 0;
  v26 = -1;
  v15 = v6;
  v7 = *(void (__stdcall **)(int, int *, int **, int))(*(_DWORD *)v6 + 24);
  v22[0] = a2;
  v7(v15, a2, &v20, v19);
  if ( a1[276] )
  {
    v18 = a1[279];
    v16 = (HWND)a1[3];
    lParam[4] = 2;
    lParam[3] = 0;
    SendMessageW(v16, 0x102Bu, v18, (LPARAM)lParam);
  }
  v8 = *(void (__thiscall **)(int *, int, WCHAR *))(*(a1 - 2) + 52);
  v20 = (int *)a4;
  v21 = (int *)a5;
  a1[5] = 0;
  v8(a1 - 2, 261, pszPath);
  if ( a1[278] )
  {
    v9 = a1[279];
    v17 = (HWND)a1[3];
    lParam[0] = 4;
    lParam[1] = v9;
    lParam[2] = 0;
    SendMessageW(v17, 0x104Bu, 0, (LPARAM)lParam);
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + a1[8] + 44));
  }
  pszPath[lstrlenW(pszPath) + 1] = 0;
  if ( a1[274] )
  {
    if ( !a1[271]
      && a1[275]
      && !a1[278]
      && !(*(int (__stdcall **)(int *, __int16 *, char *))(*a2 + 12))(a2, &v23, v28)
      && (v10 = (HDROP)GlobalLock(hMem)) != 0
      && (DragQueryFileW(v10, 0xFFFFFFFF, 0, 0), a1[274])
      && sub_466220(a3, *a6, a1[277]) == 2 )
    {
      v22[0] = v20;
      v22[1] = v21;
      sub_44E360((WPARAM)(a1 - 4), (LONG *)v22);
    }
    else
    {
      v11 = operator new(0x30u);
      if ( v11 )
      {
        v11[1] = 1;
        *v11 = &CDropHandler::`vftable';
        v12 = v11;
      }
      else
      {
        v12 = 0;
      }
      if ( a1 == (int *)16 )
        v13 = 0;
      else
        v13 = a1 + 1;
      sub_461A40(a3, a1[271], v22[0], v12, a6, a1[3], (int)pszPath, (int)v13, a4, a5);
      if ( !a1[278] )
        sub_469710((HWND)a1[3]);
      if ( !InterlockedDecrement(v12 + 1) && v12 )
        (*(void (__thiscall **)(_DWORD *, int))*v12)(v12, 1);
    }
  }
  sub_4693F0((HWND)a1[3], 0);
  return 0;
}
// 4CC480: using guessed type void *CDropHandler::`vftable';
// 44EEE0: using guessed type char var_258[4];

//----- (0044F1A0) --------------------------------------------------------
int __thiscall sub_44F1A0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[183] = a2;
  return result;
}

//----- (0044F1E0) --------------------------------------------------------
int __stdcall sub_44F1E0(int a1, int a2, int a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // eax
  const WCHAR *v5; // ebx
  _DWORD *v6; // eax
  const WCHAR *v7; // edi
  int result; // eax

  v3 = *(_DWORD **)dword_4EF6C0;
  v4 = **(_DWORD ***)dword_4EF6C0;
  if ( v4 == *(_DWORD **)dword_4EF6C0 )
  {
LABEL_4:
    v5 = 0;
  }
  else
  {
    while ( v4[258] != a1 )
    {
      v4 = (_DWORD *)*v4;
      if ( v4 == v3 )
        goto LABEL_4;
    }
    v5 = (const WCHAR *)(v4 + 2);
  }
  v6 = **(_DWORD ***)dword_4EF6C0;
  if ( v6 == v3 )
  {
LABEL_8:
    v7 = 0;
  }
  else
  {
    while ( v6[258] != a2 )
    {
      v6 = (_DWORD *)*v6;
      if ( v6 == v3 )
        goto LABEL_8;
    }
    v7 = (const WCHAR *)(v6 + 2);
  }
  if ( lstrcmpiW(v5, L"Unspecified") || !lstrcmpiW(v7, L"Unspecified") )
  {
    if ( !lstrcmpiW(v5, L"Unspecified") || lstrcmpiW(v7, L"Unspecified") )
    {
      if ( lstrcmpiW(v5, L"Unspecified") || (result = lstrcmpiW(v7, L"Unspecified")) != 0 )
        result = StrCmpLogicalW(v5, v7);
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = 1;
  }
  if ( !dword_4EF4A8 )
    return -result;
  return result;
}
// 4EF4A8: using guessed type int dword_4EF4A8;
// 4EF6C0: using guessed type int dword_4EF6C0;

//----- (0044F2A0) --------------------------------------------------------
int __stdcall sub_44F2A0(int a1, int a2, int a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // eax
  const WCHAR *v5; // ebx
  _DWORD *v6; // eax
  const WCHAR *v7; // edi
  int result; // eax

  v3 = *(_DWORD **)dword_4EF6C0;
  v4 = **(_DWORD ***)dword_4EF6C0;
  if ( v4 == *(_DWORD **)dword_4EF6C0 )
  {
LABEL_4:
    v5 = 0;
  }
  else
  {
    while ( v4[258] != a1 )
    {
      v4 = (_DWORD *)*v4;
      if ( v4 == v3 )
        goto LABEL_4;
    }
    v5 = (const WCHAR *)(v4 + 2);
  }
  v6 = **(_DWORD ***)dword_4EF6C0;
  if ( v6 == v3 )
  {
LABEL_8:
    v7 = 0;
  }
  else
  {
    while ( v6[258] != a2 )
    {
      v6 = (_DWORD *)*v6;
      if ( v6 == v3 )
        goto LABEL_8;
    }
    v7 = (const WCHAR *)(v6 + 2);
  }
  if ( lstrcmpiW(v5, L"Other") || !lstrcmpiW(v7, L"Other") )
  {
    if ( !lstrcmpiW(v5, L"Other") || lstrcmpiW(v7, L"Other") )
    {
      if ( lstrcmpiW(v5, L"Other") || (result = lstrcmpiW(v7, L"Other")) != 0 )
        result = StrCmpLogicalW(v5, v7);
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = 1;
  }
  if ( !dword_4EF4A8 )
    return -result;
  return result;
}
// 4EF4A8: using guessed type int dword_4EF4A8;
// 4EF6C0: using guessed type int dword_4EF6C0;

//----- (0044F360) --------------------------------------------------------
int __usercall sub_44F360@<eax>(_WORD *a1@<edi>, int a2@<esi>)
{
  IP_ADAPTER_ADDRESSES_LH *v2; // eax
  ULONG SizePointer; // [esp+4h] [ebp-48h] BYREF
  WCHAR Buffer[32]; // [esp+8h] [ebp-44h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  SizePointer = 0;
  GetAdaptersAddresses(0, 0, 0, 0, &SizePointer);
  v2 = (IP_ADAPTER_ADDRESSES_LH *)malloc(SizePointer);
  GetAdaptersAddresses(0, 0, 0, v2, &SizePointer);
  LoadStringW(*(HINSTANCE *)(a2 + 80), 0, Buffer, 32);
  return sub_4A96F0(512, (int)Buffer, a1);
}

//----- (0044F3F0) --------------------------------------------------------
void __fastcall sub_44F3F0(int a1, _WORD *a2, int a3)
{
  int v3; // edx
  const ITEMIDLIST *v4; // ecx
  ITEMIDLIST *v5; // ebx
  WCHAR *v6; // eax
  int v7; // edx
  WCHAR v8; // cx
  int v9; // edx
  WCHAR v10; // cx
  STRRET pstr; // [esp+8h] [ebp-534h] BYREF
  _WORD *v12; // [esp+114h] [ebp-428h]
  LPCITEMIDLIST ppidlLast; // [esp+118h] [ebp-424h] BYREF
  void *ppv; // [esp+11Ch] [ebp-420h] BYREF
  WCHAR pszBuf[260]; // [esp+120h] [ebp-41Ch] BYREF
  WCHAR FileSystemNameBuffer[262]; // [esp+328h] [ebp-214h] BYREF

  v12 = a2;
  v3 = *(_DWORD *)(a1 + 52);
  v4 = *(const ITEMIDLIST **)(a1 + 76);
  ppv = 0;
  ppidlLast = 0;
  v5 = ILCombine(v4, *(LPCITEMIDLIST *)(560 * a3 + v3));
  SHBindToParent(v5, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  if ( !PathIsRootW(pszBuf) )
  {
    v6 = FileSystemNameBuffer;
    v9 = 260;
    while ( v9 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v6 + (char *)L"Unspecified" - (char *)FileSystemNameBuffer);
      if ( !v10 )
        break;
      *v6++ = v10;
      if ( !--v9 )
      {
LABEL_15:
        --v6;
        goto LABEL_16;
      }
    }
    goto LABEL_16;
  }
  if ( !GetVolumeInformationW(pszBuf, 0, 0, 0, 0, 0, FileSystemNameBuffer, 0x104u) || !FileSystemNameBuffer[0] )
  {
    v6 = FileSystemNameBuffer;
    v7 = 260;
    while ( v7 != -2147483386 )
    {
      v8 = *(WCHAR *)((char *)v6 + (char *)L"Unspecified" - (char *)FileSystemNameBuffer);
      if ( !v8 )
        break;
      *v6++ = v8;
      if ( !--v7 )
        goto LABEL_15;
    }
LABEL_16:
    *v6 = 0;
  }
  sub_4A96F0(512, (int)FileSystemNameBuffer, v12);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  CoTaskMemFree(v5);
}
// 44F542: conditional instruction was optimized away because edx.4!=0
// 4C140C: using guessed type wchar_t aUnspecified_5[12];
// 4C1424: using guessed type wchar_t aUnspecified_6[12];

//----- (0044F590) --------------------------------------------------------
int __userpurge sub_44F590@<eax>(int a1@<ecx>, int a2@<edi>, _WORD *a3)
{
  WCHAR *v3; // eax
  int v5; // esi
  WCHAR v6; // cx
  LPWSTR ExtensionW; // eax
  const wchar_t *v8; // edx
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  v3 = pszPath;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v3 + a2 + 88 - (_DWORD)pszPath);
    if ( !v6 )
      break;
    *v3++ = v6;
    if ( !--v5 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a1 + *(_DWORD *)(a2 + 48) + 44));
  ExtensionW = PathFindExtensionW(pszPath);
  v8 = L"None";
  if ( *ExtensionW )
    v8 = ExtensionW;
  return sub_4A96F0(512, (int)v8, a3);
}
// 44F5E2: conditional instruction was optimized away because esi.4!=0
// 4C1400: using guessed type wchar_t aNone[5];

//----- (0044F650) --------------------------------------------------------
int __userpurge sub_44F650@<eax>(int a1@<ecx>, _WORD *a2@<ebx>, int a3@<edi>, int a4)
{
  const FILETIME *v5; // eax
  int v6; // eax
  int v8[11]; // [esp+8h] [ebp-5Ch]
  struct _FILETIME LocalFileTime; // [esp+34h] [ebp-30h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+3Ch] [ebp-28h] BYREF
  struct _SYSTEMTIME v11; // [esp+4Ch] [ebp-18h] BYREF

  v8[0] = (int)L"Today";
  v8[1] = (int)L"Yesterday";
  v8[2] = (int)L"This Week";
  v8[3] = (int)L"Last Week";
  v8[4] = (int)L"This Month";
  v8[5] = (int)L"Last Month";
  v8[6] = (int)L"This Year";
  v8[7] = (int)L"Last Year";
  v8[8] = (int)L"Two Years Ago";
  v8[9] = (int)L"Long ago";
  v8[10] = (int)L"Unspecified";
  GetLocalTime(&SystemTime);
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v5 = (const FILETIME *)(592 * a1 + *(_DWORD *)(a3 + 48) + 20);
    }
    else
    {
      if ( a4 != 2 )
        goto LABEL_8;
      v5 = (const FILETIME *)(592 * a1 + *(_DWORD *)(a3 + 48) + 12);
    }
  }
  else
  {
    v5 = (const FILETIME *)(592 * a1 + *(_DWORD *)(a3 + 48) + 4);
  }
  FileTimeToLocalFileTime(v5, &LocalFileTime);
LABEL_8:
  FileTimeToSystemTime(&LocalFileTime, &v11);
  if ( v11.wYear == SystemTime.wYear )
  {
    if ( v11.wMonth == SystemTime.wMonth )
    {
      if ( v11.wDay == SystemTime.wDay )
      {
        v6 = 0;
      }
      else if ( v11.wDay == SystemTime.wDay - 1 )
      {
        v6 = 1;
      }
      else
      {
        v6 = (v11.wDay < SystemTime.wDay - 7) + 3;
      }
    }
    else
    {
      v6 = (v11.wMonth != SystemTime.wMonth - 1) + 5;
    }
  }
  else if ( v11.wYear == SystemTime.wYear - 1 )
  {
    v6 = 6;
  }
  else
  {
    v6 = (v11.wYear != SystemTime.wYear - 2) + 7;
  }
  return sub_4A96F0(512, v8[v6], a2);
}
// 4C12A8: using guessed type wchar_t aToday[6];
// 4C12B4: using guessed type wchar_t aYesterday[10];
// 4C12C8: using guessed type wchar_t aThisWeek[10];
// 4C12DC: using guessed type wchar_t aLastWeek[10];
// 4C12F0: using guessed type wchar_t aThisMonth[11];
// 4C1308: using guessed type wchar_t aLastMonth[11];
// 4C1320: using guessed type wchar_t aThisYear[10];
// 4C1334: using guessed type wchar_t aLastYear[10];
// 4C1348: using guessed type wchar_t aTwoYearsAgo[14];
// 4C1364: using guessed type wchar_t aLongAgo[9];
// 4C1378: using guessed type wchar_t aUnspecified_7[12];

//----- (0044F7B0) --------------------------------------------------------
int __thiscall sub_44F7B0(_DWORD *this, int a2, _WORD *a3)
{
  int v3; // edx
  bool v4; // zf
  int v5; // esi
  long double v6; // st7
  long double v7; // st6
  int v9[6]; // [esp+8h] [ebp-3Ch]
  _WORD *v10; // [esp+20h] [ebp-24h]
  int v11[7]; // [esp+24h] [ebp-20h]

  v3 = this[12];
  v10 = a3;
  v4 = (*(_BYTE *)(592 * a2 + v3) & 0x10) == 0;
  v9[0] = (int)L"Folders";
  v9[1] = (int)L"Tiny";
  v9[2] = (int)L"Small";
  v9[3] = (int)L"Medium";
  v9[4] = (int)L"Large";
  v9[5] = (int)L"Huge";
  v11[1] = 0;
  v11[2] = 0;
  v11[3] = 0x8000;
  v11[4] = 102400;
  v11[5] = 0x100000;
  v11[6] = 10485760;
  if ( v4 )
  {
    v5 = 5;
    v6 = pow(2.0, 32.0) * (double)*(unsigned int *)(592 * a2 + v3 + 28) + (double)*(unsigned int *)(592 * a2 + v3 + 32);
    if ( v6 < 10485760.0 )
    {
      do
      {
        if ( v5 <= 0 )
          break;
        v7 = (double)v11[v5--];
      }
      while ( v7 > v6 );
    }
  }
  else
  {
    v5 = 0;
  }
  return sub_4A96F0(512, v9[v5], v10);
}
// 4C1204: using guessed type wchar_t aFolders[8];
// 4C1214: using guessed type wchar_t aTiny[5];
// 4C1220: using guessed type wchar_t aSmall[6];
// 4C122C: using guessed type wchar_t aMedium[7];
// 4C123C: using guessed type wchar_t aLarge[6];
// 4C1248: using guessed type wchar_t aHuge[5];

//----- (0044F8C0) --------------------------------------------------------
int __usercall sub_44F8C0@<eax>(int a1@<eax>, wchar_t *a2@<edx>, int a3@<ecx>)
{
  wint_t v4; // si
  wint_t v5; // ax

  v4 = *(_WORD *)(560 * a1 + *(_DWORD *)(a3 + 52) + 4);
  if ( !iswalpha(v4) )
    return sub_4A96F0(512, (int)L"Other", a2);
  v5 = towupper(v4);
  return sub_401000(0x200u, a2, L"%c", v5);
}
// 4C11F0: using guessed type wchar_t aC_0[3];
// 4C11F8: using guessed type wchar_t aOther_6[6];

//----- (0044F920) --------------------------------------------------------
WPARAM __fastcall sub_44F920(WPARAM a1, _DWORD *a2, const WCHAR *a3)
{
  const WCHAR **v4; // eax
  const WCHAR *v5; // esi
  int v6; // ebx
  LPCWSTR v7; // esi
  int *v8; // eax
  int v9; // edx
  int v10; // esi
  __int16 v11; // cx
  WPARAM v12; // ecx
  bool v13; // cf
  HWND v14; // ecx
  int v15; // esi
  int v16; // ecx
  char **v17; // eax
  int v18; // ecx
  unsigned int v19; // eax
  HWND v20; // edi
  int v22[10]; // [esp+Ch] [ebp-990h] BYREF
  WPARAM wParam[3]; // [esp+34h] [ebp-968h] BYREF
  int v24; // [esp+40h] [ebp-95Ch]
  __int16 *v25; // [esp+44h] [ebp-958h]
  int v26; // [esp+54h] [ebp-948h]
  int v27; // [esp+58h] [ebp-944h]
  int v28; // [esp+5Ch] [ebp-940h]
  WPARAM v29; // [esp+64h] [ebp-938h]
  WPARAM v30; // [esp+68h] [ebp-934h]
  LPCWSTR lpString1; // [esp+6Ch] [ebp-930h]
  int v32[258]; // [esp+70h] [ebp-92Ch] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+478h] [ebp-524h] BYREF
  __int16 v34[514]; // [esp+590h] [ebp-40Ch] BYREF

  lpString1 = a3;
  v4 = (const WCHAR **)a2[284];
  v5 = *v4;
  v29 = a1;
  if ( v5 == (const WCHAR *)v4 )
  {
LABEL_4:
    v6 = a2[287];
    v7 = lpString1;
    v8 = v32;
    a2[287] = v6 + 1;
    v30 = v6;
    v9 = 512;
    v10 = (char *)v7 - (char *)v32;
    while ( v9 != -2147483134 )
    {
      v11 = *(_WORD *)((char *)v8 + v10);
      if ( !v11 )
        break;
      *(_WORD *)v8 = v11;
      v8 = (int *)((char *)v8 + 2);
      if ( !--v9 )
      {
        v8 = (int *)((char *)v8 - 2);
        break;
      }
    }
    v15 = a2[284];
    v16 = *(_DWORD *)(v15 + 4);
    *(_WORD *)v8 = 0;
    v32[256] = v6;
    v32[257] = 1;
    v17 = sub_426A50((char *)v15, v16, (int)v32);
    v18 = a2[285];
    if ( v18 == 4161789 )
      std::_Xlength_error("list<T> too long");
    a2[285] = v18 + 1;
    *(_DWORD *)(v15 + 4) = v17;
    *(_DWORD *)v17[1] = v17;
    v19 = a2[157];
    if ( v19 < 6 )
    {
      if ( v19 < 5 )
        goto LABEL_18;
      sub_401000(0x200u, (wchar_t *)v34, L"%s", lpString1);
    }
    else
    {
      sub_401000(0x200u, (wchar_t *)v34, L"%s (%d)", lpString1, 1);
    }
    v6 = v30;
LABEL_18:
    wParam[2] = 40;
    v24 = 17;
    v25 = v34;
    v26 = v6;
    v27 = 0;
    VersionInformation.dwOSVersionInfoSize = 276;
    if ( GetVersionExW(&VersionInformation) && VersionInformation.dwMajorVersion > 5 )
    {
      v24 |= 4u;
      v28 = 8;
    }
    v20 = (HWND)a2[7];
    wParam[0] = v29;
    wParam[1] = (WPARAM)v20;
    SendMessageW(v20, 0x109Fu, (WPARAM)wParam, 0);
    return v30;
  }
  while ( lstrcmpiW(lpString1, v5 + 4) )
  {
    v5 = *(const WCHAR **)v5;
    if ( v5 == (const WCHAR *)a2[284] )
      goto LABEL_4;
  }
  v12 = *((_DWORD *)v5 + 258);
  ++*((_DWORD *)v5 + 259);
  v13 = a2[157] < 6u;
  v30 = v12;
  if ( !v13 )
  {
    sub_401000(0x200u, (wchar_t *)v34, L"%s (%d)", lpString1, *((_DWORD *)v5 + 259));
    v22[2] = (int)v34;
    v14 = (HWND)a2[7];
    v22[0] = 40;
    v22[1] = 1;
    SendMessageW(v14, 0x1093u, v30, (LPARAM)v22);
  }
  return v30;
}
// 44FA48: conditional instruction was optimized away because edx.4!=0
// 4C11C8: using guessed type wchar_t aSD[8];
// 4C11D8: using guessed type wchar_t aSD_0[8];
// 4C11E8: using guessed type wchar_t aS_0[3];
// 44F920: using guessed type wchar_t var_40C[514];

//----- (0044FBB0) --------------------------------------------------------
int __userpurge sub_44FBB0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, _WORD *a4)
{
  WCHAR *v4; // eax
  int v6; // esi
  WCHAR v7; // cx
  char *v8; // eax
  int v9; // edx
  __int16 v10; // cx
  _WORD *v12; // [esp+Ch] [ebp-614h]
  char v13[1024]; // [esp+10h] [ebp-610h] BYREF
  WCHAR pszPath[262]; // [esp+410h] [ebp-210h] BYREF

  v12 = a4;
  v4 = pszPath;
  v6 = 260;
  while ( v6 != -2147483386 )
  {
    v7 = *(WCHAR *)((char *)v4 + a2 + 88 - (_DWORD)pszPath);
    if ( !v7 )
      break;
    *v4++ = v7;
    if ( !--v6 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a1 + *(_DWORD *)(a2 + 48) + 44));
  if ( !sub_469C60((int)pszPath, a3) )
  {
    v8 = v13;
    v9 = 512;
    while ( v9 != -2147483134 )
    {
      v10 = *(_WORD *)&v8[(char *)L"Other" - v13];
      if ( !v10 )
        break;
      *(_WORD *)v8 = v10;
      v8 += 2;
      if ( !--v9 )
      {
        v8 -= 2;
        break;
      }
    }
    *(_WORD *)v8 = 0;
  }
  return sub_4A96F0(512, (int)v13, v12);
}
// 44FC02: conditional instruction was optimized away because esi.4!=0
// 44FC80: conditional instruction was optimized away because edx.4!=0
// 4C13F4: using guessed type wchar_t aOther_5[6];

//----- (0044FCC0) --------------------------------------------------------
int __userpurge sub_44FCC0@<eax>(int a1@<edx>, _WORD *a2@<ecx>, int a3@<edi>, int a4)
{
  WCHAR *v4; // eax
  int v5; // esi
  WCHAR v6; // cx
  __int16 *v7; // eax
  int v8; // edx
  __int16 v9; // cx
  __int16 v12[512]; // [esp+10h] [ebp-60Ch] BYREF
  WCHAR pszPath[260]; // [esp+410h] [ebp-20Ch] BYREF

  v4 = pszPath;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v4 + a3 + 88 - (_DWORD)pszPath);
    if ( !v6 )
      break;
    *v4++ = v6;
    if ( !--v5 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a1 + *(_DWORD *)(a3 + 48) + 44));
  if ( !sub_46A1B0(pszPath, v12, a4) )
  {
    v7 = v12;
    v8 = 512;
    while ( v8 != -2147483134 )
    {
      v9 = *(__int16 *)((char *)v7 + (char *)L"Unspecified" - (char *)v12);
      if ( !v9 )
        break;
      *v7++ = v9;
      if ( !--v8 )
      {
        --v7;
        break;
      }
    }
    *v7 = 0;
  }
  return sub_4A96F0(512, (int)v12, a2);
}
// 44FD20: conditional instruction was optimized away because esi.4!=0
// 44FDA0: conditional instruction was optimized away because edx.4!=0
// 4C13DC: using guessed type wchar_t aUnspecified_8[12];
// 44FCC0: using guessed type _WORD var_60C[512];

//----- (0044FDE0) --------------------------------------------------------
int __userpurge sub_44FDE0@<eax>(int a1@<ecx>, int a2@<edi>, _WORD *a3)
{
  WCHAR *v3; // eax
  int v5; // esi
  WCHAR v6; // cx
  int v8[256]; // [esp+10h] [ebp-614h] BYREF
  WCHAR pszPath[262]; // [esp+410h] [ebp-214h] BYREF

  v3 = pszPath;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v3 + a2 + 88 - (_DWORD)pszPath);
    if ( !v6 )
      break;
    *v3++ = v6;
    if ( !--v5 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a1 + *(_DWORD *)(a2 + 48) + 44));
  sub_46A4F0((int)v8);
  return sub_4A96F0(512, (int)v8, a3);
}
// 44FE32: conditional instruction was optimized away because esi.4!=0

//----- (0044FEA0) --------------------------------------------------------
int __fastcall sub_44FEA0(int a1, int a2, _WORD *a3)
{
  WCHAR *v5; // eax
  int v6; // esi
  int v7; // edx
  WCHAR v8; // cx
  _WORD *v10; // [esp+Ch] [ebp-258h]
  WCHAR pszPath[260]; // [esp+10h] [ebp-254h] BYREF
  __int16 v12[34]; // [esp+218h] [ebp-4Ch] BYREF

  v10 = a3;
  v5 = pszPath;
  v6 = 260;
  v7 = a1 + 88 - (_DWORD)pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v5 + v7);
    if ( !v8 )
      break;
    *v5++ = v8;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a2 + *(_DWORD *)(a1 + 48) + 44));
  sub_46A7C0(v12, pszPath);
  return sub_4A96F0(512, (int)v12, v10);
}
// 44FEF5: conditional instruction was optimized away because esi.4!=0
// 44FEA0: using guessed type _WORD var_4C[34];

//----- (0044FF60) --------------------------------------------------------
int __fastcall sub_44FF60(_WORD *a1, int a2, int a3)
{
  ITEMIDLIST *v4; // esi
  BOOL DiskFreeSpace; // esi
  __int16 *v6; // eax
  int v7; // edx
  __int16 v8; // cx
  STRRET pstr; // [esp+10h] [ebp-54Ch] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+118h] [ebp-444h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+120h] [ebp-43Ch] BYREF
  int v13; // [esp+12Ch] [ebp-430h]
  _WORD *v14; // [esp+130h] [ebp-42Ch]
  LPCITEMIDLIST pidl1; // [esp+134h] [ebp-428h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+138h] [ebp-424h] BYREF
  void *ppv; // [esp+13Ch] [ebp-420h] BYREF
  WCHAR pszBuf[260]; // [esp+140h] [ebp-41Ch] BYREF
  __int16 v19[262]; // [esp+348h] [ebp-214h] BYREF

  v14 = a1;
  v13 = a3;
  pidl1 = 0;
  ppv = 0;
  ppidlLast = 0;
  sub_467810((LPITEMIDLIST *)&pidl1, a3 + 88);
  v4 = ILCombine(pidl1, *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
  SHBindToParent(v4, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree((LPVOID)pidl1);
  CoTaskMemFree(v4);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  if ( !PathIsRootW(pszBuf)
    || (DiskFreeSpace = GetDiskFreeSpaceExW(pszBuf, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes),
        sub_401000(
          0x104u,
          (wchar_t *)v19,
          L"%I64d%% free",
          10 * (100 * TotalNumberOfFreeBytes.QuadPart / TotalNumberOfBytes.QuadPart / 0xA)),
        !DiskFreeSpace) )
  {
    v6 = v19;
    v7 = 260;
    while ( v7 != -2147483386 )
    {
      v8 = *(__int16 *)((char *)v6 + (char *)L"Unspecified" - (char *)v19);
      if ( !v8 )
        break;
      *v6++ = v8;
      if ( !--v7 )
      {
        --v6;
        break;
      }
    }
    *v6 = 0;
  }
  return sub_4A96F0(512, (int)v19, v14);
}
// 450120: conditional instruction was optimized away because edx.4!=0
// 4C13A8: using guessed type wchar_t aI64dFree[13];
// 4C13C4: using guessed type wchar_t aUnspecified_9[12];
// 44FF60: using guessed type wchar_t var_214[262];

//----- (00450160) --------------------------------------------------------
int __userpurge sub_450160@<eax>(int a1@<ecx>, int a2@<edi>, int a3, _WORD *a4)
{
  WCHAR *v4; // eax
  int v6; // esi
  WCHAR v7; // cx
  char *v8; // eax
  int v9; // edx
  __int16 v10; // cx
  _WORD *v12; // [esp+8h] [ebp-610h]
  char v13[1024]; // [esp+Ch] [ebp-60Ch] BYREF
  WCHAR pszPath[260]; // [esp+40Ch] [ebp-20Ch] BYREF

  v12 = a4;
  v4 = pszPath;
  v6 = 260;
  while ( v6 != -2147483386 )
  {
    v7 = *(WCHAR *)((char *)v4 + a2 + 88 - (_DWORD)pszPath);
    if ( !v7 )
      break;
    *v4++ = v7;
    if ( !--v6 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592 * a1 + *(_DWORD *)(a2 + 48) + 44));
  if ( sub_469F20((int)pszPath, a3) == -1 )
  {
    v8 = v13;
    v9 = 512;
    while ( v9 != -2147483134 )
    {
      v10 = *(_WORD *)&v8[(char *)L"Unspecified" - v13];
      if ( !v10 )
        break;
      *(_WORD *)v8 = v10;
      v8 += 2;
      if ( !--v9 )
      {
        v8 -= 2;
        break;
      }
    }
    *(_WORD *)v8 = 0;
  }
  return sub_4A96F0(512, (int)v13, v12);
}
// 4501B2: conditional instruction was optimized away because esi.4!=0
// 450230: conditional instruction was optimized away because edx.4!=0
// 4C1390: using guessed type wchar_t aUnspecified_10[12];

//----- (00450270) --------------------------------------------------------
void __fastcall sub_450270(_WORD *a1, int a2, int a3)
{
  LPITEMIDLIST v4; // esi
  LPCITEMIDLIST pidl1; // [esp+14h] [ebp-2BCh] BYREF
  SHFILEINFOW psfi; // [esp+18h] [ebp-2B8h] BYREF

  pidl1 = 0;
  sub_467810((LPITEMIDLIST *)&pidl1, a3 + 88);
  v4 = ILCombine(pidl1, *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
  SHGetFileInfoW(&v4->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
  sub_4A96F0(512, (int)psfi.szTypeName, a1);
  CoTaskMemFree(v4);
  CoTaskMemFree((LPVOID)pidl1);
}

//----- (00450330) --------------------------------------------------------
_WORD *__fastcall sub_450330(int a1, int a2, int a3)
{
  ITEMIDLIST *v4; // esi
  BOOL DiskFreeSpace; // ebx
  int v6; // eax
  int v7; // ecx
  _WORD *result; // eax
  int v9; // edx
  int v10; // esi
  __int16 v11; // cx
  STRRET pstr; // [esp+10h] [ebp-38Ch] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+118h] [ebp-284h] BYREF
  int v14[5]; // [esp+124h] [ebp-278h]
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+138h] [ebp-264h] BYREF
  _WORD *v16; // [esp+144h] [ebp-258h]
  int v17; // [esp+148h] [ebp-254h]
  LPCITEMIDLIST ppidlLast; // [esp+14Ch] [ebp-250h] BYREF
  LPCITEMIDLIST pidl1; // [esp+150h] [ebp-24Ch] BYREF
  void *ppv; // [esp+154h] [ebp-248h] BYREF
  int v21; // [esp+158h] [ebp-244h]
  int v22[11]; // [esp+15Ch] [ebp-240h] BYREF
  WCHAR pszBuf[262]; // [esp+188h] [ebp-214h] BYREF

  v16 = (_WORD *)a3;
  v17 = a1;
  ppv = 0;
  pidl1 = 0;
  ppidlLast = 0;
  v14[0] = (int)L"Unspecified";
  v14[1] = (int)L"Small";
  v14[2] = (int)L"Medium";
  v14[3] = (int)L"Huge";
  v14[4] = (int)L"Gigantic";
  v21 = 0;
  memset(v22, 0, 12);
  v22[3] = 0x40000000;
  v22[4] = 0;
  v22[5] = 0;
  v22[6] = 5;
  v22[7] = 0;
  v22[8] = 25;
  sub_467810((LPITEMIDLIST *)&pidl1, a1 + 88);
  v4 = ILCombine(pidl1, *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(v17 + 52)));
  SHBindToParent(v4, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  if ( !PathIsRootW(pszBuf) )
    goto LABEL_6;
  DiskFreeSpace = GetDiskFreeSpaceExW(pszBuf, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes);
  CoTaskMemFree((LPVOID)pidl1);
  CoTaskMemFree(v4);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  v6 = 4;
  if ( TotalNumberOfBytes.HighPart < 0x19 )
  {
    do
    {
      if ( v6 <= 0 )
        break;
      --v6;
    }
    while ( TotalNumberOfBytes.QuadPart < __PAIR64__(v22[2 * v6], v22[2 * v6 - 1]) );
  }
  v7 = v6;
  if ( !DiskFreeSpace )
LABEL_6:
    v7 = 0;
  result = v16;
  v9 = 512;
  v10 = v14[v7] - (_DWORD)v16;
  while ( v9 != -2147483134 )
  {
    v11 = *(_WORD *)((char *)result + v10);
    if ( !v11 )
      break;
    *result++ = v11;
    if ( !--v9 )
    {
      *(result - 1) = 0;
      return result;
    }
  }
  *result = 0;
  return result;
}
// 45054A: conditional instruction was optimized away because edx.4!=0
// 4C1254: using guessed type wchar_t aUnspecified_11[12];
// 4C126C: using guessed type wchar_t aSmall_0[6];
// 4C1278: using guessed type wchar_t aMedium_0[7];
// 4C1288: using guessed type wchar_t aHuge_0[5];
// 4C1294: using guessed type wchar_t aGigantic[9];

//----- (00450580) --------------------------------------------------------
WPARAM __fastcall sub_450580(int a1, _DWORD *a2)
{
  int (__stdcall *v4)(int, int, int); // ecx
  int v5; // eax
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-45Ch] BYREF
  int v8[11]; // [esp+14h] [ebp-454h]
  struct _SYSTEMTIME v9; // [esp+40h] [ebp-428h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+50h] [ebp-418h] BYREF
  __int16 v11[514]; // [esp+60h] [ebp-408h] BYREF

  v4 = 0;
  switch ( a2[158] )
  {
    case 1:
    case 0xC:
      sub_44F8C0(a1, (wchar_t *)v11, (int)a2);
      goto LABEL_40;
    case 2:
      sub_44F650(a1, v11, (int)a2, 1);
      goto LABEL_40;
    case 3:
      sub_44F7B0(a2, a1, v11);
      goto LABEL_40;
    case 4:
    case 0x23:
      sub_450270(v11, a1, (int)a2);
      goto LABEL_40;
    case 5:
      sub_450330((int)a2, a1, (int)v11);
      goto LABEL_40;
    case 6:
      sub_44FF60(v11, a1, (int)a2);
      v4 = sub_44F1E0;
      return sub_44F920((WPARAM)v4, a2, (const WCHAR *)v11);
    case 7:
      sub_450160(a1, (int)a2, 6, v11);
      goto LABEL_40;
    case 0xA:
      sub_44FEA0((int)a2, a1, v11);
      goto LABEL_40;
    case 0xD:
      sub_44FDE0(a1, (int)a2, v11);
      goto LABEL_40;
    case 0xE:
      sub_44FCC0(a1, v11, (int)a2, (int)L"ProductName");
      goto LABEL_40;
    case 0xF:
      sub_44FCC0(a1, v11, (int)a2, (int)L"CompanyName");
      goto LABEL_40;
    case 0x10:
      sub_44FCC0(a1, v11, (int)a2, (int)L"FileDescription");
      goto LABEL_40;
    case 0x11:
      sub_44FCC0(a1, v11, (int)a2, (int)L"FileVersion");
      goto LABEL_40;
    case 0x12:
      sub_44FCC0(a1, v11, (int)a2, (int)L"ProductVersion");
      goto LABEL_40;
    case 0x15:
      sub_44F590(a1, (int)a2, v11);
      goto LABEL_40;
    case 0x16:
      sub_44F650(a1, v11, (int)a2, 0);
      goto LABEL_40;
    case 0x17:
      v8[0] = (int)L"Today";
      v8[1] = (int)L"Yesterday";
      v8[2] = (int)L"This Week";
      v8[3] = (int)L"Last Week";
      v8[4] = (int)L"This Month";
      v8[5] = (int)L"Last Month";
      v8[6] = (int)L"This Year";
      v8[7] = (int)L"Last Year";
      v8[8] = (int)L"Two Years Ago";
      v8[9] = (int)L"Long ago";
      v8[10] = (int)L"Unspecified";
      GetLocalTime(&SystemTime);
      FileTimeToLocalFileTime((const FILETIME *)(592 * a1 + a2[12] + 12), &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &v9);
      if ( v9.wYear == SystemTime.wYear )
      {
        if ( v9.wMonth == SystemTime.wMonth )
        {
          if ( v9.wDay == SystemTime.wDay )
          {
            v5 = 0;
          }
          else if ( v9.wDay == SystemTime.wDay - 1 )
          {
            v5 = 1;
          }
          else
          {
            v5 = (v9.wDay < SystemTime.wDay - 7) + 3;
          }
        }
        else
        {
          v5 = (v9.wMonth != SystemTime.wMonth - 1) + 5;
        }
      }
      else if ( v9.wYear == SystemTime.wYear - 1 )
      {
        v5 = 6;
      }
      else
      {
        v5 = (v9.wYear != SystemTime.wYear - 2) + 7;
      }
      sub_4A96F0(512, v8[v5], v11);
      goto LABEL_40;
    case 0x18:
      sub_450160(a1, (int)a2, 2, v11);
      goto LABEL_40;
    case 0x19:
      sub_450160(a1, (int)a2, 3, v11);
      goto LABEL_40;
    case 0x1A:
      sub_450160(a1, (int)a2, 4, v11);
      goto LABEL_40;
    case 0x1B:
      sub_450160(a1, (int)a2, 5, v11);
      goto LABEL_40;
    case 0x1D:
      sub_44FBB0(a1, (int)a2, 272, v11);
      goto LABEL_40;
    case 0x1E:
      sub_44FBB0(a1, (int)a2, 306, v11);
      goto LABEL_40;
    case 0x1F:
      sub_44FBB0(a1, (int)a2, 256, v11);
      goto LABEL_40;
    case 0x20:
      sub_44FBB0(a1, (int)a2, 257, v11);
      goto LABEL_40;
    case 0x22:
      sub_44F3F0((int)a2, v11, a1);
      goto LABEL_40;
    case 0x28:
      sub_44F360(v11, (int)a2);
LABEL_40:
      v4 = sub_44F2A0;
      break;
    default:
      return sub_44F920((WPARAM)v4, a2, (const WCHAR *)v11);
  }
  return sub_44F920((WPARAM)v4, a2, (const WCHAR *)v11);
}
// 4C1140: using guessed type wchar_t aProductname[12];
// 4C1158: using guessed type wchar_t aCompanyname[12];
// 4C1170: using guessed type wchar_t aFiledescriptio[16];
// 4C1190: using guessed type wchar_t aFileversion[12];
// 4C11A8: using guessed type wchar_t aProductversion[15];
// 4C12A8: using guessed type wchar_t aToday[6];
// 4C12B4: using guessed type wchar_t aYesterday[10];
// 4C12C8: using guessed type wchar_t aThisWeek[10];
// 4C12DC: using guessed type wchar_t aLastWeek[10];
// 4C12F0: using guessed type wchar_t aThisMonth[11];
// 4C1308: using guessed type wchar_t aLastMonth[11];
// 4C1320: using guessed type wchar_t aThisYear[10];
// 4C1334: using guessed type wchar_t aLastYear[10];
// 4C1348: using guessed type wchar_t aTwoYearsAgo[14];
// 4C1364: using guessed type wchar_t aLongAgo[9];
// 4C1378: using guessed type wchar_t aUnspecified_7[12];
// 450580: using guessed type wchar_t var_408[514];

//----- (00450A10) --------------------------------------------------------
LRESULT __usercall sub_450A10@<eax>(int a1@<esi>)
{
  _DWORD **v1; // eax
  _DWORD *v2; // ecx
  int v3; // eax
  LPARAM v4; // edi
  WPARAM v5; // eax
  HWND v6; // ecx
  HWND v8; // [esp-10h] [ebp-88h]
  LRESULT v9; // [esp+8h] [ebp-70h]
  _DWORD *v10; // [esp+Ch] [ebp-6Ch]
  LPARAM lParam[13]; // [esp+10h] [ebp-68h] BYREF
  LPARAM v12[13]; // [esp+44h] [ebp-34h] BYREF

  SendMessageW(*(HWND *)(a1 + 28), 0x10A0u, 0, 0);
  SendMessageW(*(HWND *)(a1 + 28), 0x109Du, 1u, 0);
  v9 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  SendMessageW(*(HWND *)(a1 + 28), 0xBu, 0, 0);
  v1 = *(_DWORD ***)(a1 + 1136);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 1136) + 4) = *(_DWORD *)(a1 + 1136);
  *(_DWORD *)(a1 + 1140) = 0;
  if ( v2 != *(_DWORD **)(a1 + 1136) )
  {
    do
    {
      v10 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v10;
    }
    while ( v10 != *(_DWORD **)(a1 + 1136) );
  }
  v3 = *(_DWORD *)(a1 + 744);
  dword_4EF6C0 = a1 + 1136;
  v4 = 0;
  *(_DWORD *)(a1 + 1148) = 0;
  for ( dword_4EF4A8 = v3; v4 < v9; ++v4 )
  {
    v8 = *(HWND *)(a1 + 28);
    lParam[0] = 4;
    lParam[1] = v4;
    lParam[2] = 0;
    SendMessageW(v8, 0x104Bu, 0, (LPARAM)lParam);
    v12[0] = 256;
    v12[1] = v4;
    v12[2] = 0;
    v5 = sub_450580(lParam[8], (_DWORD *)a1);
    v6 = *(HWND *)(a1 + 28);
    v12[10] = v5;
    SendMessageW(v6, 0x104Cu, 0, (LPARAM)v12);
  }
  return SendMessageW(*(HWND *)(a1 + 28), 0xBu, 1u, 0);
}
// 4EF4A8: using guessed type int dword_4EF4A8;
// 4EF6C0: using guessed type int dword_4EF6C0;

//----- (00450B30) --------------------------------------------------------
LRESULT __thiscall sub_450B30(int this)
{
  BOOL v2; // eax

  v2 = *(_DWORD *)(this + 732) == 0;
  *(_DWORD *)(this + 732) = v2;
  if ( v2 )
    return sub_450A10(this - 8);
  SendMessageW(*(HWND *)(this + 20), 0x109Du, 0, 0);
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this - 8) + 16))(this - 8, *(_DWORD *)(this + 624));
}

//----- (00450B80) --------------------------------------------------------
LRESULT __thiscall sub_450B80(int this, WPARAM wParam)
{
  *(_DWORD *)(this + 732) = wParam;
  if ( wParam )
    return sub_450A10(this - 8);
  SendMessageW(*(HWND *)(this + 20), 0x109Du, 0, 0);
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this - 8) + 16))(this - 8, *(_DWORD *)(this + 624));
}

//----- (00450BD0) --------------------------------------------------------
void __stdcall sub_450BD0(HWND hWnd, UINT a2, UINT_PTR uIDEvent, DWORD a4)
{
  KillTimer(hWnd, uIDEvent);
  SendMessageW(hWnd, 0x8033u, uIDEvent, 0);
}

//----- (00450C00) --------------------------------------------------------
void __usercall sub_450C00(_DWORD *a1@<eax>, const WCHAR *a2@<ebx>)
{
  void **v3; // eax
  WCHAR *v4; // edi

  v3 = (void **)a1[204];
  v4 = (WCHAR *)*v3;
  if ( *v3 == v3 )
  {
LABEL_4:
    dword_4EF4A4 = sub_459230(a1, a2);
  }
  else
  {
    while ( lstrcmpW(a2, v4 + 4) )
    {
      v4 = *(WCHAR **)v4;
      if ( v4 == (WCHAR *)a1[204] )
        goto LABEL_4;
    }
    dword_4EF694 = 1;
    if ( v4 != (WCHAR *)a1[204] )
    {
      **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
      *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
      operator delete(v4);
      --a1[205];
    }
  }
}
// 4EF4A4: using guessed type int dword_4EF4A4;
// 4EF694: using guessed type int dword_4EF694;

//----- (00450C70) --------------------------------------------------------
void __usercall sub_450C70(_DWORD *a1@<eax>, const WCHAR *a2@<ebx>)
{
  void **v3; // eax
  WCHAR *v4; // edi
  int v5; // eax

  v3 = (void **)a1[204];
  v4 = (WCHAR *)*v3;
  if ( *v3 == v3 )
  {
LABEL_4:
    v5 = sub_459230(a1, a2);
    if ( v5 != -1 )
      sub_4543E0(v5, (int)a1);
  }
  else
  {
    while ( lstrcmpW(a2, v4 + 4) )
    {
      v4 = *(WCHAR **)v4;
      if ( v4 == (WCHAR *)a1[204] )
        goto LABEL_4;
    }
    if ( v4 != (WCHAR *)a1[204] )
    {
      **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
      *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
      operator delete(v4);
      --a1[205];
    }
  }
}

//----- (00450CE0) --------------------------------------------------------
LRESULT __thiscall sub_450CE0(int this, int a2, LPCWSTR pszMore)
{
  LRESULT result; // eax
  WCHAR *v5; // eax
  int v6; // edx
  int v7; // esi
  WCHAR v8; // cx
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  if ( a2 == 4 )
  {
    v5 = pszPath;
    v6 = 260;
    v7 = this + 80 - (_DWORD)pszPath;
    while ( v6 != -2147483386 )
    {
      v8 = *(WCHAR *)((char *)v5 + v7);
      if ( !v8 )
        break;
      *v5++ = v8;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    *v5 = 0;
    PathStripPathW(pszPath);
    result = lstrcmpW(pszPath, pszMore) == 0;
    *(_DWORD *)(this + 640) = result;
  }
  else
  {
    result = a2 - 5;
    if ( a2 == 5 )
    {
      if ( *(_DWORD *)(this + 640) )
      {
        PathRemoveFileSpecW((LPWSTR)(this + 80));
        PathAppendW((LPWSTR)(this + 80), pszMore);
        return SendMessageW(*(HWND *)(this + 24), 0x8011u, 0, 0);
      }
    }
  }
  return result;
}
// 450D80: conditional instruction was optimized away because edx.4!=0

//----- (00450DD0) --------------------------------------------------------
void __thiscall sub_450DD0(int this, int a2, int a3, UINT_PTR nIDEvent, int a5)
{
  struct _RTL_CRITICAL_SECTION *v6; // ebx
  int *v7; // eax
  int v8; // edx
  __int16 v9; // cx
  int v10; // esi
  char **v11; // eax
  int v12; // ecx
  int v13; // [esp-8h] [ebp-230h]
  int v14[133]; // [esp+10h] [ebp-218h] BYREF

  v6 = (struct _RTL_CRITICAL_SECTION *)(this + 772);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 772));
  SetTimer(*(HWND *)(this + 24), nIDEvent, 0xC8u, sub_450BD0);
  v7 = v14;
  v8 = 260;
  while ( v8 != -2147483386 )
  {
    v9 = *(_WORD *)((char *)v7 + a3 - (_DWORD)v14);
    if ( !v9 )
      break;
    *(_WORD *)v7 = v9;
    v7 = (int *)((char *)v7 + 2);
    if ( !--v8 )
    {
      v7 = (int *)((char *)v7 - 2);
      break;
    }
  }
  v10 = *(_DWORD *)(this + 796);
  *(_WORD *)v7 = 0;
  v14[130] = a2;
  v13 = *(_DWORD *)(v10 + 4);
  v14[131] = a5;
  v11 = sub_41EE00((char *)v10, v13, (int)v14);
  v12 = *(_DWORD *)(this + 800);
  if ( v12 == 8134406 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 800) = v12 + 1;
  *(_DWORD *)(v10 + 4) = v11;
  *(_DWORD *)v11[1] = v11;
  LeaveCriticalSection(v6);
}
// 450E44: conditional instruction was optimized away because edx.4!=0

//----- (00450EC0) --------------------------------------------------------
void __thiscall sub_450EC0(_BYTE *this, const WCHAR *a2)
{
  int v2; // esi
  WCHAR *v3; // eax
  int v4; // edx
  int v5; // edi
  WCHAR v6; // cx
  int v7; // edi
  LPITEMIDLIST v8; // eax
  _DWORD *v9; // esi
  __int16 *v10; // ecx
  int v11; // ebx
  _WORD *v12; // eax
  LPARAM v13; // ebx
  int v14; // edx
  LPCWSTR v15; // ecx
  int v16; // edi
  _WORD *v17; // eax
  HWND v18; // edx
  WPARAM v19; // edi
  int v20; // ebx
  LPCWSTR v21; // ecx
  int v22; // edi
  _WORD *v23; // eax
  LPCWSTR v24; // ecx
  int v25; // edi
  _WORD *v26; // eax
  HWND v27; // [esp-10h] [ebp-754h]
  LPARAM lParam[6]; // [esp+Ch] [ebp-738h] BYREF
  LPARAM v29[13]; // [esp+24h] [ebp-720h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+58h] [ebp-6ECh] BYREF
  void *ppv; // [esp+5Ch] [ebp-6E8h] BYREF
  _BYTE *v32; // [esp+60h] [ebp-6E4h]
  LPCITEMIDLIST pidl; // [esp+64h] [ebp-6E0h] BYREF
  LPCWSTR pszMore; // [esp+68h] [ebp-6DCh]
  LPARAM v35; // [esp+6Ch] [ebp-6D8h]
  SHFILEINFOW psfi; // [esp+70h] [ebp-6D4h] BYREF
  __int16 v37[260]; // [esp+328h] [ebp-41Ch] BYREF
  WCHAR pszPath[262]; // [esp+530h] [ebp-214h] BYREF

  pszMore = a2;
  v2 = dword_4EF4A4;
  v32 = this;
  v35 = dword_4EF4A4;
  ppv = 0;
  pidl = 0;
  ppidlLast = 0;
  if ( dword_4EF4A4 != -1 )
  {
    v3 = pszPath;
    v4 = 260;
    v5 = this + 88 - (_BYTE *)pszPath;
    while ( v4 != -2147483386 )
    {
      v6 = *(WCHAR *)((char *)v3 + v5);
      if ( !v6 )
        break;
      *v3++ = v6;
      if ( !--v4 )
      {
        --v3;
        break;
      }
    }
    *v3 = 0;
    PathAppendW(pszPath, pszMore);
    if ( sub_467810((LPITEMIDLIST *)&pidl, (int)pszPath) < 0 )
    {
      v20 = (int)v32;
      v21 = pszMore;
      v22 = 260;
      v23 = (_WORD *)(560 * v2 + *((_DWORD *)v32 + 13) + 4);
      while ( v22 != -2147483386 && *v21 )
      {
        *v23++ = *v21++;
        if ( !--v22 )
        {
          --v23;
          break;
        }
      }
      *v23 = 0;
      v24 = pszMore;
      v25 = 260;
      v26 = (_WORD *)(592 * v2 + *(_DWORD *)(v20 + 48) + 44);
      while ( v25 != -2147483386 && *v24 )
      {
        *v26++ = *v24++;
        if ( !--v25 )
        {
          --v26;
          break;
        }
      }
      *v26 = 0;
    }
    else
    {
      if ( SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
      {
        if ( sub_467B70((int)pszPath, (WCHAR *)v37, 32769) >= 0 )
        {
          v7 = 560 * v35;
          v8 = ILClone(ppidlLast);
          v9 = v32;
          *(_DWORD *)(v7 + *((_DWORD *)v32 + 13)) = v8;
          v10 = v37;
          v11 = 260;
          v12 = (_WORD *)(v9[13] + v7 + 4);
          while ( v11 != -2147483386 && *v10 )
          {
            *v12++ = *v10++;
            if ( !--v11 )
            {
              --v12;
              break;
            }
          }
          v13 = v35;
          v14 = 592 * v35;
          *v12 = 0;
          v15 = pszMore;
          v16 = 260;
          v17 = (_WORD *)(v14 + v9[12] + 44);
          while ( v16 != -2147483386 && *v15 )
          {
            *v17++ = *v15++;
            if ( !--v16 )
            {
              --v17;
              break;
            }
          }
          *v17 = 0;
          if ( SHGetFileInfoW(&pidl->mkid.cb, 0, &psfi, 0x2B4u, 0x148u) )
          {
            v18 = (HWND)v9[7];
            lParam[2] = v13;
            lParam[0] = 1;
            v19 = SendMessageW(v18, 0x1053u, 0xFFFFFFFF, (LPARAM)lParam);
            if ( v19 != -1 )
            {
              v29[7] = psfi.iIcon;
              v29[0] = 11;
              v29[1] = v19;
              v29[2] = 0;
              v29[5] = (LPARAM)sub_4544A0(v35, v9);
              v27 = (HWND)v9[7];
              v29[4] = 3840;
              v29[3] = (psfi.iIcon >> 16) & 0xFFFFFF00;
              SendMessageW(v27, 0x104Cu, 0, (LPARAM)v29);
              if ( sub_454980(v35, (int)v9) )
                sub_459D50(v19, (int)v9, v35);
            }
            DestroyIcon(psfi.hIcon);
          }
        }
        (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
      }
      CoTaskMemFree((LPVOID)pidl);
    }
  }
}
// 450F43: conditional instruction was optimized away because edx.4!=0
// 451018: conditional instruction was optimized away because ebx.4!=0
// 451064: conditional instruction was optimized away because edi.4!=0
// 4511D2: conditional instruction was optimized away because edi.4!=0
// 451216: conditional instruction was optimized away because edi.4!=0
// 4EF4A4: using guessed type int dword_4EF4A4;
// 450EC0: using guessed type WCHAR var_41C[260];

//----- (00451240) --------------------------------------------------------
_DWORD *__userpurge sub_451240@<eax>(int a1@<esi>, const WCHAR *a2)
{
  int v2; // edx
  WPARAM v3; // ebx
  _DWORD *result; // eax
  _DWORD *v5; // edi
  LPARAM v6; // edi
  int v7; // edi
  HWND v8; // edx
  int v9; // eax
  unsigned int v10; // ecx
  int v11; // eax
  bool v12; // cf
  WCHAR *v13; // eax
  WCHAR v14; // cx
  HWND v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  _DWORD **v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // edi
  HWND v22; // [esp-10h] [ebp-29Ch]
  HWND v23; // [esp-10h] [ebp-29Ch]
  LPARAM lParam[13]; // [esp+8h] [ebp-284h] BYREF
  int v25[3]; // [esp+3Ch] [ebp-250h] BYREF
  int v26; // [esp+48h] [ebp-244h]
  int v27; // [esp+4Ch] [ebp-240h]
  LPCWSTR lpString2; // [esp+70h] [ebp-21Ch]
  int v29; // [esp+74h] [ebp-218h]
  WCHAR pszPath[262]; // [esp+78h] [ebp-214h] BYREF

  v2 = *(_DWORD *)(a1 + 8);
  lpString2 = a2;
  v3 = (*(int (__thiscall **)(int, const WCHAR *))(v2 + 180))(a1 + 8, a2);
  if ( v3 == -1 )
  {
    result = *(_DWORD **)(a1 + 828);
    v5 = (_DWORD *)*result;
    if ( (_DWORD *)*result == result )
      return result;
    while ( 1 )
    {
      result = (_DWORD *)lstrcmpW((LPCWSTR)(592 * v5[3] + *(_DWORD *)(a1 + 48) + 44), lpString2);
      if ( !result )
        break;
      v5 = (_DWORD *)*v5;
      if ( v5 == *(_DWORD **)(a1 + 828) )
        return result;
    }
    v6 = v5[3];
  }
  else
  {
    v22 = *(HWND *)(a1 + 28);
    lParam[0] = 4;
    lParam[1] = v3;
    lParam[2] = 0;
    result = (_DWORD *)SendMessageW(v22, 0x104Bu, 0, (LPARAM)lParam);
    if ( !result )
      return result;
    v6 = lParam[8];
  }
  if ( v6 != -1 )
  {
    v7 = 592 * v6;
    v8 = *(HWND *)(a1 + 28);
    v9 = v7 + *(_DWORD *)(a1 + 48);
    v10 = *(_DWORD *)(v9 + 32);
    v11 = *(_DWORD *)(v9 + 28);
    v12 = *(_DWORD *)(a1 + 608) < v10;
    *(_DWORD *)(a1 + 608) -= v10;
    *(_DWORD *)(a1 + 612) -= v12 + v11;
    if ( SendMessageW(v8, 0x102Cu, v3, 2) == 2 )
      *(_QWORD *)(a1 + 616) -= __PAIR64__(
                                 *(_DWORD *)(*(_DWORD *)(a1 + 48) + v7 + 28),
                                 *(_DWORD *)(*(_DWORD *)(a1 + 48) + v7 + 32));
    v13 = pszPath;
    v29 = 260;
    while ( v29 != -2147483386 )
    {
      v14 = *(WCHAR *)((char *)v13 + a1 + 88 - (_DWORD)pszPath);
      if ( !v14 )
        break;
      *v13++ = v14;
      if ( !--v29 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
    PathAppendW(pszPath, lpString2);
    lpString2 = (LPCWSTR)FindFirstFileW(pszPath, (LPWIN32_FIND_DATAW)(v7 + *(_DWORD *)(a1 + 48)));
    if ( lpString2 == (LPCWSTR)-1 )
    {
      result = 0;
      *(_DWORD *)(v7 + *(_DWORD *)(a1 + 48) + 32) = 0;
      *(_DWORD *)(v7 + *(_DWORD *)(a1 + 48) + 28) = 0;
    }
    else
    {
      v15 = *(HWND *)(a1 + 28);
      v16 = v7 + *(_DWORD *)(a1 + 48);
      v17 = *(_DWORD *)(v16 + 32);
      v18 = *(_DWORD *)(v16 + 28);
      v12 = __CFADD__(v17, *(_DWORD *)(a1 + 608));
      *(_DWORD *)(a1 + 608) += v17;
      *(_DWORD *)(a1 + 612) += v18 + v12;
      if ( SendMessageW(v15, 0x102Cu, v3, 2) == 2 )
        *(_QWORD *)(a1 + 616) += __PAIR64__(
                                   *(_DWORD *)(*(_DWORD *)(a1 + 48) + v7 + 28),
                                   *(_DWORD *)(*(_DWORD *)(a1 + 48) + v7 + 32));
      v23 = *(HWND *)(a1 + 28);
      if ( (*(_BYTE *)(v7 + *(_DWORD *)(a1 + 48)) & 2) != 0 )
      {
        v27 = 4;
        v26 = 4;
      }
      else
      {
        v27 = 4;
        v26 = 0;
      }
      SendMessageW(v23, 0x102Bu, v3, (LPARAM)v25);
      if ( *(_DWORD *)(a1 + 636) == 4 )
      {
        v19 = *(_DWORD ***)(a1 + 964);
        v29 = 0;
        if ( v19 )
        {
          v20 = *v19;
          v21 = (_DWORD *)*v20;
          if ( (_DWORD *)*v20 != v20 )
          {
            do
            {
              if ( v21[3] )
                sub_4582C0(v29++, a1, v21[2], v3);
              v21 = (_DWORD *)*v21;
            }
            while ( v21 != **(_DWORD ***)(a1 + 964) );
          }
        }
      }
      return (_DWORD *)FindClose((HANDLE)lpString2);
    }
  }
  return result;
}
// 4513AE: conditional instruction was optimized away because %var_218.4!=0
// 451240: using guessed type LPARAM var_250[3];

//----- (00451530) --------------------------------------------------------
void __thiscall sub_451530(ULONG_PTR dwData, int a2)
{
  WCHAR *v3; // eax
  int v4; // edi
  ULONG_PTR v5; // edx
  WCHAR v6; // cx
  int v7; // eax
  bool v8; // zf
  const WCHAR **v9; // eax
  const WCHAR *v10; // edi
  char *v11; // ebx
  char *v12; // eax
  char *v13; // eax
  int *v14; // eax
  int v15; // edx
  int v16; // edi
  __int16 v17; // cx
  int v18; // edi
  int v19; // ecx
  char **v20; // eax
  int v21; // ecx
  LPCITEMIDLIST ppidlLast; // [esp+10h] [ebp-73Ch] BYREF
  int v23; // [esp+14h] [ebp-738h]
  void *ppv; // [esp+18h] [ebp-734h] BYREF
  LPCITEMIDLIST pidl; // [esp+1Ch] [ebp-730h] BYREF
  LPCWSTR pszMore; // [esp+20h] [ebp-72Ch]
  STRRET pstr; // [esp+24h] [ebp-728h] BYREF
  int v28[130]; // [esp+12Ch] [ebp-620h] BYREF
  WCHAR pszPath[260]; // [esp+334h] [ebp-418h] BYREF
  WCHAR pszBuf[262]; // [esp+53Ch] [ebp-210h] BYREF

  pszMore = (LPCWSTR)a2;
  v3 = pszPath;
  ppv = 0;
  pidl = 0;
  ppidlLast = 0;
  v23 = 0;
  v4 = 260;
  v5 = dwData + 88 - (_DWORD)pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v3 + v5);
    if ( !v6 )
      break;
    *v3++ = v6;
    if ( !--v4 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  PathAppendW(pszPath, pszMore);
  if ( sub_467810((LPITEMIDLIST *)&pidl, (int)pszPath) < 0 )
    goto LABEL_25;
  if ( SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
  {
    if ( *(_DWORD *)(dwData + 640) )
      v7 = (*(int (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 1, &pstr);
    else
      v7 = (*(int (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(
             ppv,
             ppidlLast,
             32769,
             &pstr);
    if ( v7 >= 0 )
    {
      StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
      v8 = *(_DWORD *)(dwData + 1080) == 0;
      v23 = 0;
      if ( !v8 )
      {
        v9 = *(const WCHAR ***)(dwData + 1076);
        v10 = *v9;
        if ( *v9 != (const WCHAR *)v9 )
        {
          while ( lstrcmpW(pszBuf, v10 + 4) )
          {
            v10 = *(const WCHAR **)v10;
            if ( v10 == *(const WCHAR **)(dwData + 1076) )
              goto LABEL_18;
          }
          v23 = 1;
        }
      }
LABEL_18:
      if ( !*(_DWORD *)(dwData + 772) || v23 )
      {
        v13 = (char *)sub_4266B0(ppidlLast, dwData, *(const ITEMIDLIST **)(dwData + 76), pszBuf);
        sub_4265A0((char *)0xFFFFFFFF, (_DWORD *)dwData, v13, 0);
      }
      else
      {
        v11 = (char *)sub_4266B0(ppidlLast, dwData, *(const ITEMIDLIST **)(dwData + 76), pszBuf);
        v12 = (char *)sub_45A9B0(dwData, (int)v11);
        sub_4265A0(v12, (_DWORD *)dwData, v11, (char *)1);
      }
      sub_426070(dwData, *(_DWORD *)(dwData + 740));
      v23 = 1;
    }
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  }
  CoTaskMemFree((LPVOID)pidl);
  if ( !v23 )
  {
LABEL_25:
    v14 = v28;
    v15 = 260;
    v16 = (char *)pszMore - (char *)v28;
    while ( v15 != -2147483386 )
    {
      v17 = *(_WORD *)((char *)v14 + v16);
      if ( !v17 )
        break;
      *(_WORD *)v14 = v17;
      v14 = (int *)((char *)v14 + 2);
      if ( !--v15 )
      {
        v14 = (int *)((char *)v14 - 2);
        break;
      }
    }
    v18 = *(_DWORD *)(dwData + 816);
    v19 = *(_DWORD *)(v18 + 4);
    *(_WORD *)v14 = 0;
    v20 = sub_4269E0((char *)v18, v19, (int)v28);
    v21 = *(_DWORD *)(dwData + 820);
    if ( v21 == 8259551 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(dwData + 820) = v21 + 1;
    *(_DWORD *)(v18 + 4) = v20;
    *(_DWORD *)v20[1] = v20;
  }
}
// 4515A0: conditional instruction was optimized away because edi.4!=0
// 451770: conditional instruction was optimized away because edx.4!=0

//----- (00451810) --------------------------------------------------------
void __thiscall sub_451810(int this)
{
  int v1; // ebx
  void (__stdcall *v2)(HWND, UINT, WPARAM, LPARAM); // esi
  _DWORD *v3; // eax
  _BYTE *v4; // ecx
  WPARAM v5; // eax
  _DWORD **v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  void **v9; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // eax
  WPARAM v12; // eax
  WPARAM v13; // esi
  HWND v14; // ecx
  _DWORD *v15; // esi
  HWND v16; // [esp-10h] [ebp-280h]
  int v18; // [esp+10h] [ebp-260h]
  _DWORD *v19; // [esp+14h] [ebp-25Ch]
  int v20; // [esp+18h] [ebp-258h]
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+1Ch] [ebp-254h]
  _DWORD *v22; // [esp+20h] [ebp-250h]
  LPARAM lParam[3]; // [esp+24h] [ebp-24Ch] BYREF
  int v24; // [esp+30h] [ebp-240h]
  int v25; // [esp+34h] [ebp-23Ch]
  int v26[133]; // [esp+58h] [ebp-218h] BYREF

  v1 = this;
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(this + 772);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 772));
  v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
  v20 = *(_DWORD *)(v1 + 836);
  SendMessageW(*(HWND *)(v1 + 20), 0xBu, 0, 0);
  v3 = *(_DWORD **)(v1 + 796);
  v22 = v3;
  v19 = (_DWORD *)*v3;
  if ( (_DWORD *)*v3 != v3 )
  {
    do
    {
      qmemcpy(v26, v19 + 2, 0x210u);
      if ( v26[131] == *(_DWORD *)(v1 + 720) )
      {
        switch ( v26[130] )
        {
          case 1:
            sub_451530(v1 - 8, (int)v26);
            break;
          case 2:
            sub_450C70((_DWORD *)(v1 - 8), (const WCHAR *)v26);
            v1 = this;
            break;
          case 3:
            sub_451240(v1 - 8, (const WCHAR *)v26);
            break;
          case 4:
            sub_450C00((_DWORD *)(v1 - 8), (const WCHAR *)v26);
            v1 = this;
            break;
          case 5:
            v4 = (_BYTE *)(v1 - 8);
            if ( dword_4EF694 )
            {
              sub_451530((ULONG_PTR)v4, (int)v26);
              dword_4EF694 = 0;
            }
            else
            {
              sub_450EC0(v4, (const WCHAR *)v26);
            }
            break;
          default:
            break;
        }
      }
      v19 = (_DWORD *)*v19;
    }
    while ( v19 != v22 );
    v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
  }
  v2(*(HWND *)(v1 + 20), 0xBu, 1u, 0);
  v5 = *(_DWORD *)(v1 + 716);
  if ( v5 != -1 )
  {
    if ( !((LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))v2)(*(HWND *)(v1 + 20), 0x10B6u, v5, 0) )
      v2(*(HWND *)(v1 + 20), 0x1013u, *(_DWORD *)(v1 + 716), 1);
    *(_DWORD *)(v1 + 716) = -1;
  }
  v2(*(HWND *)(v1 + 24), 0x80CCu, *(_DWORD *)(v1 + 768), 0);
  if ( v20 && !*(_DWORD *)(v1 + 836) )
    v2(*(HWND *)(v1 + 24), 0x80C8u, 0, *(_DWORD *)(v1 + 844));
  v6 = *(_DWORD ***)(v1 + 796);
  v7 = *v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(v1 + 796) + 4) = *(_DWORD *)(v1 + 796);
  *(_DWORD *)(v1 + 800) = 0;
  if ( v7 != *(_DWORD **)(v1 + 796) )
  {
    do
    {
      v8 = (_DWORD *)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while ( v8 != *(_DWORD **)(v1 + 796) );
  }
  v9 = *(void ***)(v1 + 848);
  v18 = 0;
  v10 = *v9;
  if ( *v9 != v9 )
  {
    do
    {
      v11 = v10 + 2;
      if ( v10[7] >= 8u )
        v11 = (_DWORD *)*v11;
      v12 = (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)v1 + 180))(v1, v11);
      v13 = v12;
      if ( v12 == -1 )
      {
        v10 = (_DWORD *)*v10;
      }
      else
      {
        v16 = *(HWND *)(v1 + 20);
        v25 = 2;
        v24 = 2;
        SendMessageW(v16, 0x102Bu, v12, (LPARAM)lParam);
        if ( !v18 )
        {
          v14 = *(HWND *)(v1 + 20);
          v25 = 1;
          v24 = 1;
          SendMessageW(v14, 0x102Bu, v13, (LPARAM)lParam);
          SendMessageW(*(HWND *)(v1 + 20), 0x1013u, v13, 1);
          v18 = 1;
        }
        v15 = (_DWORD *)*v10;
        if ( v10 != *(_DWORD **)(v1 + 848) )
        {
          *(_DWORD *)v10[1] = v15;
          *(_DWORD *)(*v10 + 4) = v10[1];
          if ( v10[7] >= 8u )
            operator delete((void *)v10[2]);
          v10[7] = 7;
          v10[6] = 0;
          *((_WORD *)v10 + 4) = 0;
          operator delete(v10);
          --*(_DWORD *)(v1 + 852);
        }
        v10 = v15;
      }
    }
    while ( v10 != *(_DWORD **)(v1 + 848) );
  }
  LeaveCriticalSection(lpCriticalSection);
}
// 4EF694: using guessed type int dword_4EF694;

//----- (00451B60) --------------------------------------------------------
int __usercall sub_451B60@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<esi>)
{
  ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a1 + *(_DWORD *)(a3 + 52)));
  ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
  (*(void (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
  return 0;
}

//----- (00451BA0) --------------------------------------------------------
int __usercall sub_451BA0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int v4; // edx
  int v5; // eax
  int v6; // edi
  int v7; // edi
  int v8; // eax
  LPITEMIDLIST v10; // edi
  LPITEMIDLIST v11; // [esp-14h] [ebp-590h]
  int v12; // [esp+Ch] [ebp-570h]
  SHFILEINFOW v13; // [esp+10h] [ebp-56Ch] BYREF
  SHFILEINFOW psfi; // [esp+2C4h] [ebp-2B8h] BYREF

  v4 = *(_DWORD *)(a3 + 48);
  v12 = a1;
  v5 = v4 + 592 * a2;
  v6 = v4 + 592 * a1;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return -1;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
    v8 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1;
    v11 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
    v10 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * v12 + *(_DWORD *)(a3 + 52)));
    SHGetFileInfoW(&v11->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
    SHGetFileInfoW(&v10->mkid.cb, 0, &v13, 0x2B4u, 0x408u);
    v7 = lstrcmpW(psfi.szTypeName, v13.szTypeName);
    v8 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
  }
  if ( !v8 )
    return -v7;
  return v7;
}

//----- (00451D00) --------------------------------------------------------
int __usercall sub_451D00@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int v4; // edx
  int v5; // eax
  int v6; // edi
  int v7; // edi
  int v8; // eax
  LPITEMIDLIST v10; // edi
  LPITEMIDLIST v11; // [esp-14h] [ebp-590h]
  int v12; // [esp+Ch] [ebp-570h]
  SHFILEINFOW v13; // [esp+10h] [ebp-56Ch] BYREF
  SHFILEINFOW psfi; // [esp+2C4h] [ebp-2B8h] BYREF

  v4 = *(_DWORD *)(a3 + 48);
  v12 = a1;
  v5 = v4 + 592 * a2;
  v6 = v4 + 592 * a1;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return -1;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
    v8 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1;
    v11 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
    v10 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * v12 + *(_DWORD *)(a3 + 52)));
    SHGetFileInfoW(&v11->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
    SHGetFileInfoW(&v10->mkid.cb, 0, &v13, 0x2B4u, 0x408u);
    v7 = lstrcmpW(psfi.szTypeName, v13.szTypeName);
    v8 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
  }
  if ( !v8 )
    return -v7;
  return v7;
}

//----- (00451E60) --------------------------------------------------------
int __usercall sub_451E60@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>)
{
  int v3; // edx
  int v4; // ecx
  int v5; // esi
  int v6; // esi

  v3 = a3[12];
  v4 = v3 + 592 * a2;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
    {
      v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
      if ( !(*(int (__thiscall **)(_DWORD *))(*a3 + 40))(a3) )
        return -v6;
      return v6;
    }
    else
    {
      return -1;
    }
  }
  else if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    return 1;
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *))(*a3 + 40))(a3);
    return 0;
  }
}

//----- (00451EF0) --------------------------------------------------------
int __userpurge sub_451EF0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3)
{
  BOOL v4; // ebx
  BOOL v5; // eax
  int v6; // esi
  DWORD v7; // ebx
  BYTE *v8; // edi
  BYTE *v9; // ebx
  HANDLE hPrinter; // [esp+Ch] [ebp-Ch] BYREF
  HANDLE phPrinter; // [esp+10h] [ebp-8h] BYREF
  DWORD pcbNeeded; // [esp+14h] [ebp-4h] BYREF

  v4 = OpenPrinterW((LPWSTR)(560 * a1 + a3[13] + 4), &phPrinter, 0);
  v5 = OpenPrinterW((LPWSTR)(560 * a2 + a3[13] + 4), &hPrinter, 0);
  if ( v4 )
  {
    if ( v5 )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v7 = pcbNeeded;
      v8 = (BYTE *)malloc(pcbNeeded);
      GetPrinterW(phPrinter, 2u, v8, v7, &pcbNeeded);
      GetPrinterW(hPrinter, 2u, 0, 0, &pcbNeeded);
      v9 = (BYTE *)malloc(pcbNeeded);
      GetPrinterW(hPrinter, 2u, v9, pcbNeeded, &pcbNeeded);
      v6 = *((_DWORD *)v8 + 19) < *((_DWORD *)v9 + 19);
      free(v8);
      free(v9);
    }
    else
    {
      v6 = -1;
    }
  }
  else
  {
    v6 = v5;
  }
  if ( !(*(int (__thiscall **)(_DWORD *))(*a3 + 40))(a3) )
    return -v6;
  return v6;
}

//----- (00452000) --------------------------------------------------------
int __userpurge sub_452000@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v4; // ecx
  int v5; // edi
  ITEMIDLIST *v6; // ebx
  int v7; // eax
  const ITEMIDLIST *v8; // edx
  BOOL IsRootW; // eax
  int result; // eax
  LPITEMIDLIST v11; // edi
  LPITEMIDLIST v12; // ebx
  bool v13; // zf
  ITEMIDLIST *pva; // [esp+28h] [ebp-A9Ch]
  LPVOID pvb; // [esp+28h] [ebp-A9Ch]
  int pv; // [esp+28h] [ebp-A9Ch]
  void *ppv; // [esp+2Ch] [ebp-A98h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+30h] [ebp-A94h] BYREF
  STRRET pstr; // [esp+34h] [ebp-A90h] BYREF
  SHFILEINFOW psfi; // [esp+13Ch] [ebp-988h] BYREF
  SHFILEINFOW v21; // [esp+3F4h] [ebp-6D0h] BYREF
  WCHAR pszPath[260]; // [esp+6ACh] [ebp-418h] BYREF
  WCHAR pszBuf[262]; // [esp+8B4h] [ebp-210h] BYREF

  v4 = *(_DWORD *)(a2 + 52);
  v5 = 560 * a1;
  ppv = 0;
  ppidlLast = 0;
  v6 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(v4 + v5));
  SHBindToParent(v6, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v6);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  v7 = *(_DWORD *)(a2 + 52);
  v8 = *(const ITEMIDLIST **)(a2 + 76);
  ppv = 0;
  pva = ILCombine(v8, *(LPCITEMIDLIST *)(v7 + 560 * a3));
  SHBindToParent(pva, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(pva);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  ppv = 0;
  pvb = (LPVOID)PathIsRootW(pszBuf);
  IsRootW = PathIsRootW(pszPath);
  if ( pvb )
  {
    if ( !IsRootW )
      return -1;
  }
  else if ( IsRootW )
  {
    return 1;
  }
  v11 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 52) + v5));
  v12 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 52) + 560 * a3));
  SHGetFileInfoW(&v11->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
  SHGetFileInfoW(&v12->mkid.cb, 0, &v21, 0x2B4u, 0x408u);
  pv = lstrcmpW(psfi.szTypeName, v21.szTypeName);
  CoTaskMemFree(v11);
  CoTaskMemFree(v12);
  v13 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) == 0;
  result = pv;
  if ( v13 )
    return -pv;
  return result;
}

//----- (00452260) --------------------------------------------------------
int __userpurge sub_452260@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  ITEMIDLIST *v4; // ebx
  int v5; // eax
  const ITEMIDLIST *v6; // edx
  ITEMIDLIST *v7; // edi
  BOOL IsRootW; // ebx
  BOOL v9; // eax
  BOOL VolumeInformationW; // ebx
  bool v11; // zf
  int result; // eax
  void *ppv; // [esp+28h] [ebp-5ACh] BYREF
  int v14; // [esp+2Ch] [ebp-5A8h]
  LPCITEMIDLIST ppidlLast; // [esp+30h] [ebp-5A4h] BYREF
  STRRET pstr; // [esp+34h] [ebp-5A0h] BYREF
  WCHAR String2[32]; // [esp+13Ch] [ebp-498h] BYREF
  WCHAR FileSystemNameBuffer[32]; // [esp+17Ch] [ebp-458h] BYREF
  WCHAR pszBuf[260]; // [esp+1BCh] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+3C4h] [ebp-210h] BYREF

  ppidlLast = 0;
  ppv = 0;
  v14 = 0;
  v4 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(560 * a3 + *(_DWORD *)(a2 + 52)));
  SHBindToParent(v4, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v4);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  v5 = *(_DWORD *)(a2 + 52);
  v6 = *(const ITEMIDLIST **)(a2 + 76);
  ppv = 0;
  v7 = ILCombine(v6, *(LPCITEMIDLIST *)(560 * a1 + v5));
  SHBindToParent(v7, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(v7);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  ppv = 0;
  IsRootW = PathIsRootW(pszBuf);
  v9 = PathIsRootW(pszPath);
  if ( IsRootW )
  {
    if ( !v9 )
    {
      v14 = -1;
      goto LABEL_10;
    }
    VolumeInformationW = GetVolumeInformationW(pszBuf, 0, 0, 0, 0, 0, FileSystemNameBuffer, 0x20u);
    v9 = GetVolumeInformationW(pszPath, 0, 0, 0, 0, 0, String2, 0x20u);
    if ( VolumeInformationW )
    {
      if ( v9 )
        v14 = lstrcmpW(FileSystemNameBuffer, String2);
      else
        v14 = -1;
      goto LABEL_10;
    }
  }
  if ( v9 )
    v14 = 1;
LABEL_10:
  v11 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) == 0;
  result = v14;
  if ( v11 )
    return -v14;
  return result;
}

//----- (00452480) --------------------------------------------------------
int __userpurge sub_452480@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  const WCHAR *v8; // ebx
  const WCHAR *v9; // edi
  const WCHAR *ExtensionW; // eax
  int v11; // edi
  const WCHAR *lpString1; // [esp+8h] [ebp-418h]
  __int16 v13[260]; // [esp+Ch] [ebp-414h] BYREF
  __int16 pszDest[260]; // [esp+214h] [ebp-20Ch] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    v8 = (const WCHAR *)(v4 + 44);
    PathCombineW((LPWSTR)pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    v9 = (const WCHAR *)(v5 + 44);
    PathCombineW((LPWSTR)v13, (LPCWSTR)(a2 + 88), v9);
    lpString1 = PathFindExtensionW(v8);
    ExtensionW = PathFindExtensionW(v9);
    v6 = lstrcmpW(lpString1, ExtensionW);
  }
  v11 = v6;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v11;
  return v11;
}
// 452480: using guessed type WCHAR pszDest[260];
// 452480: using guessed type WCHAR var_414[260];

//----- (004525A0) --------------------------------------------------------
int __usercall sub_4525A0@<eax>(int a1@<eax>, int a2@<ecx>, _DWORD *a3@<ebx>)
{
  int v3; // eax
  int v4; // esi
  int v5; // edi
  BOOL v6; // ecx
  int v7; // esi
  int v8; // eax

  v3 = 592 * a1;
  v4 = 592 * a2;
  v5 = a3[12];
  v6 = (*(_DWORD *)(592 * a2 + v5) & 0x10) == 16;
  if ( (*(_DWORD *)(v5 + v3) & 0x10) == 16 )
  {
    if ( !v6 )
      return -1;
    v7 = StrCmpIW((PCWSTR)(v5 + v3 + 44), (PCWSTR)(v4 + v5 + 44));
    v8 = (*(int (__thiscall **)(_DWORD *))(*a3 + 40))(a3);
  }
  else
  {
    if ( v6 )
      return 1;
    v7 = lstrcmpW((LPCWSTR)(v5 + v3 + 564), (LPCWSTR)(v5 + v4 + 564));
    v8 = (*(int (__thiscall **)(_DWORD *))(*a3 + 40))(a3);
  }
  if ( !v8 )
    return -v7;
  return v7;
}

//----- (00452680) --------------------------------------------------------
int __fastcall sub_452680(int a1, int a2, int a3, int a4)
{
  ITEMIDLIST *v6; // ebx
  ITEMIDLIST *v7; // esi
  BOOL v8; // eax
  ULARGE_INTEGER v10; // rax
  DWORD LowPart; // ecx
  DWORD HighPart; // esi
  bool v13; // cf
  bool v14; // cc
  void *v15; // [esp+20h] [ebp-554h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+24h] [ebp-550h] BYREF
  void *ppv; // [esp+28h] [ebp-54Ch] BYREF
  LPCITEMIDLIST pidl; // [esp+2Ch] [ebp-548h] BYREF
  BOOL IsRootW; // [esp+30h] [ebp-544h]
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+34h] [ebp-540h] BYREF
  ULARGE_INTEGER v21; // [esp+3Ch] [ebp-538h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+44h] [ebp-530h] BYREF
  ULARGE_INTEGER v23; // [esp+4Ch] [ebp-528h] BYREF
  STRRET pstr; // [esp+54h] [ebp-520h] BYREF
  WCHAR pszBuf[260]; // [esp+15Ch] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+364h] [ebp-210h] BYREF

  ppv = 0;
  v15 = 0;
  ppidlLast = 0;
  pidl = 0;
  v6 = ILCombine(*(LPCITEMIDLIST *)(a1 + 76), *(LPCITEMIDLIST *)(560 * a3 + *(_DWORD *)(a1 + 52)));
  SHBindToParent(v6, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  v7 = ILCombine(*(LPCITEMIDLIST *)(a1 + 76), *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a1 + 52)));
  SHBindToParent(v7, &stru_4BD7FC, &v15, &pidl);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)v15 + 44))(v15, pidl, 0x8000, &pstr);
  StrRetToBufW(&pstr, pidl, pszPath, 0x104u);
  IsRootW = PathIsRootW(pszBuf);
  v8 = PathIsRootW(pszPath);
  if ( !IsRootW )
    return v8;
  if ( !v8 )
    return -1;
  GetDiskFreeSpaceExW(pszBuf, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes);
  GetDiskFreeSpaceExW(pszPath, 0, &v21, &v23);
  CoTaskMemFree(v7);
  CoTaskMemFree(v6);
  (*(void (__stdcall **)(void *))(*(_DWORD *)v15 + 8))(v15);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  if ( a4 )
  {
    v10 = TotalNumberOfBytes;
    HighPart = v21.HighPart;
    LowPart = v21.LowPart;
  }
  else
  {
    v10 = TotalNumberOfFreeBytes;
    HighPart = v23.HighPart;
    LowPart = v23.LowPart;
  }
  if ( v10.LowPart == LowPart )
  {
    v13 = v10.HighPart < HighPart;
    v14 = v10.HighPart <= HighPart;
    if ( v10.HighPart == HighPart )
      return 0;
  }
  else
  {
    v13 = v10.HighPart < HighPart;
    v14 = v10.HighPart <= HighPart;
  }
  if ( v13 || v14 && v10.LowPart <= LowPart )
    return -1;
  return 1;
}

//----- (00452A30) --------------------------------------------------------
LONG __userpurge sub_452A30@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3)
{
  int v3; // ecx
  int v4; // eax
  BOOL v5; // edx
  BOOL v6; // ecx
  LONG v8; // esi

  v3 = a2[12];
  v4 = 592 * a1;
  v5 = (*(_DWORD *)(v3 + v4) & 0x10) == 16;
  v6 = (*(_DWORD *)(592 * a3 + v3) & 0x10) == 16;
  if ( v5 )
  {
    if ( !v6 )
      return -1;
  }
  else if ( v6 )
  {
    return 1;
  }
  v8 = CompareFileTime((const FILETIME *)(a2[12] + v4 + 20), (const FILETIME *)(a2[12] + 592 * a3 + 20));
  if ( !(*(int (__thiscall **)(_DWORD *))(*a2 + 40))(a2) )
    return -v8;
  return v8;
}

//----- (00452AD0) --------------------------------------------------------
int __usercall sub_452AD0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int v5; // ecx
  int v6; // ecx
  BOOL IsRootW; // eax
  int v9; // eax
  BOOL v10; // ecx
  BOOL v11; // eax
  LPITEMIDLIST v12; // edi
  LPITEMIDLIST v13; // ebx
  int v14; // edi
  void *ppv; // [esp+28h] [ebp-FC4h] BYREF
  LPCWSTR pszPath; // [esp+2Ch] [ebp-FC0h]
  LPCITEMIDLIST ppidlLast; // [esp+30h] [ebp-FBCh] BYREF
  LPCITEMIDLIST pidl; // [esp+34h] [ebp-FB8h] BYREF
  void *v19; // [esp+38h] [ebp-FB4h] BYREF
  LPCITEMIDLIST v20; // [esp+3Ch] [ebp-FB0h] BYREF
  void *v21; // [esp+40h] [ebp-FACh] BYREF
  STRRET pstr; // [esp+44h] [ebp-FA8h] BYREF
  STRRET v23; // [esp+14Ch] [ebp-EA0h] BYREF
  SHFILEINFOW psfi; // [esp+254h] [ebp-D98h] BYREF
  SHFILEINFOW v25; // [esp+50Ch] [ebp-AE0h] BYREF
  WCHAR v26[260]; // [esp+7C4h] [ebp-828h] BYREF
  WCHAR v27[260]; // [esp+9CCh] [ebp-620h] BYREF
  WCHAR v28[260]; // [esp+BD4h] [ebp-418h] BYREF
  WCHAR pszBuf[262]; // [esp+DDCh] [ebp-210h] BYREF

  v21 = 0;
  v19 = 0;
  pidl = 0;
  v20 = 0;
  if ( *(_DWORD *)(a3 + 640) )
  {
    v5 = *(_DWORD *)(a3 + 52);
    ppv = 0;
    ppidlLast = 0;
    pszPath = (LPCWSTR)ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a2 + v5));
    SHBindToParent((LPCITEMIDLIST)pszPath, &stru_4BD7FC, &ppv, &ppidlLast);
    (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x408u);
    CoTaskMemFree((LPVOID)pszPath);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    v6 = *(_DWORD *)(a3 + 52);
    ppv = 0;
    pszPath = (LPCWSTR)ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a1 + v6));
    SHBindToParent((LPCITEMIDLIST)pszPath, &stru_4BD7FC, &ppv, &ppidlLast);
    (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
    StrRetToBufW(&pstr, ppidlLast, v27, 0x104u);
    SHGetFileInfoW(pszPath, 0, &v25, 0x2B4u, 0x408u);
    CoTaskMemFree((LPVOID)pszPath);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    ppv = 0;
    pszPath = (LPCWSTR)PathIsRootW(pszBuf);
    IsRootW = PathIsRootW(v27);
    if ( pszPath )
    {
      if ( IsRootW )
        return lstrcmpW(psfi.szTypeName, v25.szTypeName);
      else
        return -1;
    }
    if ( IsRootW )
      return 1;
  }
  v9 = *(_DWORD *)(a3 + 48);
  v10 = (*(_DWORD *)(592 * a2 + v9) & 0x10) == 16;
  v11 = (*(_DWORD *)(592 * a1 + v9) & 0x10) == 16;
  if ( v10 )
  {
    if ( !v11 )
      return -1;
  }
  else if ( v11 )
  {
    return 1;
  }
  v12 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a2 + *(_DWORD *)(a3 + 52)));
  v13 = ILCombine(*(LPCITEMIDLIST *)(a3 + 76), *(LPCITEMIDLIST *)(560 * a1 + *(_DWORD *)(a3 + 52)));
  SHGetFileInfoW(&v12->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
  SHGetFileInfoW(&v13->mkid.cb, 0, &v25, 0x2B4u, 0x408u);
  SHBindToParent(v12, &stru_4BD7FC, &v21, &pidl);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)v21 + 44))(v21, pidl, 0x8000, &v23);
  StrRetToBufW(&v23, pidl, v26, 0x104u);
  SHBindToParent(v13, &stru_4BD7FC, &v19, &v20);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)v19 + 44))(v19, v20, 0x8000, &v23);
  StrRetToBufW(&v23, v20, v28, 0x104u);
  PathIsRootW(v26);
  PathIsRootW(v28);
  (*(void (__stdcall **)(void *))(*(_DWORD *)v19 + 8))(v19);
  (*(void (__stdcall **)(void *))(*(_DWORD *)v21 + 8))(v21);
  CoTaskMemFree(v13);
  CoTaskMemFree(v12);
  v14 = lstrcmpW(psfi.szTypeName, v25.szTypeName);
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3) )
    return -v14;
  return v14;
}

//----- (00452EF0) --------------------------------------------------------
int __fastcall sub_452EF0(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // edi
  _DWORD *v7; // ebx
  int v8; // eax
  long double v10; // st7
  long double v11; // st7
  int v12; // edx
  int v13; // esi
  _DWORD *v14; // ecx
  long double v15; // st7
  long double v16; // st7

  v4 = a3[12];
  v5 = (_DWORD *)(v4 + 592 * a1);
  v6 = (_DWORD *)(v4 + 592 * a4);
  if ( (*v5 & 0x10) == 16 )
  {
    if ( (*v6 & 0x10) != 16 )
      return -1;
    v7 = a3;
    v8 = a3[13];
    if ( *(_DWORD *)(560 * a1 + v8 + 540) )
    {
      if ( !*(_DWORD *)(560 * a4 + v8 + 540) )
        return -1;
      v7 = a3;
    }
    else if ( *(_DWORD *)(560 * a4 + v8 + 540) )
    {
      return 1;
    }
    v10 = pow(2.0, 32.0);
    v11 = (double)(unsigned int)v5[7] * v10
        + (double)(unsigned int)v5[8]
        - (v10 * (double)(unsigned int)v6[7]
         + (double)(unsigned int)v6[8]);
    if ( v11 <= 0.0 )
    {
      v12 = *v7;
      if ( v11 >= 0.0 )
        v13 = 0;
      else
        v13 = -1;
      v14 = v7;
    }
    else
    {
      v12 = *v7;
      v13 = 1;
      v14 = v7;
    }
  }
  else
  {
    if ( (*v6 & 0x10) == 16 )
      return 1;
    v15 = pow(2.0, 32.0);
    v16 = (double)(unsigned int)v5[7] * v15
        + (double)(unsigned int)v5[8]
        - (v15 * (double)(unsigned int)v6[7]
         + (double)(unsigned int)v6[8]);
    if ( v16 <= 0.0 )
    {
      if ( v16 >= 0.0 )
        v13 = 0;
      else
        v13 = -1;
    }
    else
    {
      v13 = 1;
    }
    v14 = a3;
    v12 = *a3;
  }
  if ( !(*(int (__thiscall **)(_DWORD *))(v12 + 40))(v14) )
    return -v13;
  return v13;
}
// 452F81: conditional instruction was optimized away because ecx.4!=0

//----- (00453120) --------------------------------------------------------
LONG __userpurge sub_453120@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3)
{
  int v3; // ecx
  int v4; // eax
  BOOL v5; // edx
  BOOL v6; // ecx
  LONG v8; // esi

  v3 = a2[12];
  v4 = 592 * a1;
  v5 = (*(_DWORD *)(v3 + v4) & 0x10) == 16;
  v6 = (*(_DWORD *)(592 * a3 + v3) & 0x10) == 16;
  if ( v5 )
  {
    if ( !v6 )
      return -1;
  }
  else if ( v6 )
  {
    return 1;
  }
  v8 = CompareFileTime((const FILETIME *)(a2[12] + v4 + 12), (const FILETIME *)(a2[12] + 592 * a3 + 12));
  if ( !(*(int (__thiscall **)(_DWORD *))(*a2 + 40))(a2) )
    return -v8;
  return v8;
}

//----- (004531C0) --------------------------------------------------------
LONG __userpurge sub_4531C0@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3)
{
  int v3; // ecx
  int v4; // eax
  BOOL v5; // edx
  BOOL v6; // ecx
  LONG v8; // esi

  v3 = a2[12];
  v4 = 592 * a1;
  v5 = (*(_DWORD *)(v3 + v4) & 0x10) == 16;
  v6 = (*(_DWORD *)(592 * a3 + v3) & 0x10) == 16;
  if ( v5 )
  {
    if ( !v6 )
      return -1;
  }
  else if ( v6 )
  {
    return 1;
  }
  v8 = CompareFileTime((const FILETIME *)(a2[12] + v4 + 4), (const FILETIME *)(a2[12] + 592 * a3 + 4));
  if ( !(*(int (__thiscall **)(_DWORD *))(*a2 + 40))(a2) )
    return -v8;
  return v8;
}

//----- (00453260) --------------------------------------------------------
int __userpurge sub_453260@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // edi
  int v7; // eax
  DWORD v9; // edi
  WCHAR FileName[260]; // [esp+8h] [ebp-414h] BYREF
  WCHAR pszDest[260]; // [esp+210h] [ebp-20Ch] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2);
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    PathCombineW(FileName, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    v9 = sub_468F80(pszDest);
    v6 = v9 - sub_468F80(FileName);
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2);
  }
  if ( !v7 )
    return -v6;
  return v6;
}

//----- (00453390) --------------------------------------------------------
int __fastcall sub_453390(int a1, _DWORD *a2, int a3)
{
  int v4; // edx
  int v5; // esi
  char v6; // al
  int v7; // edi
  char v8; // dl
  int v9; // esi
  int v10; // eax
  _DWORD *v11; // ecx
  long double v13; // st7
  unsigned __int64 v14; // rax
  double v15; // st6
  unsigned int v16; // ebx
  WCHAR *v17; // eax
  int v18; // esi
  int v19; // edx
  WCHAR v20; // cx
  unsigned int v21; // edi
  DWORD v22; // esi
  unsigned int v23; // eax
  unsigned int v24; // ecx
  signed __int64 v25; // kr18_8
  DWORD BytesPerSector; // [esp+10h] [ebp-230h] BYREF
  int v27; // [esp+14h] [ebp-22Ch]
  __int64 v28; // [esp+18h] [ebp-228h]
  _DWORD *v29; // [esp+20h] [ebp-220h]
  int SectorsPerCluster[2]; // [esp+24h] [ebp-21Ch] BYREF
  unsigned int v31; // [esp+2Ch] [ebp-214h]
  WCHAR pszPath[262]; // [esp+30h] [ebp-210h] BYREF

  v4 = a2[12];
  v5 = v4 + 592 * a3;
  v6 = *(_DWORD *)v5 & 0x10;
  v7 = v4 + 592 * a1;
  v8 = *(_DWORD *)v7 & 0x10;
  v29 = a2;
  if ( v6 == 16 )
  {
    if ( v8 != 16 )
      return -1;
    v9 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v7 + 44));
    v10 = *a2;
    v11 = a2;
  }
  else
  {
    if ( v8 == 16 )
      return 1;
    v13 = pow(2.0, 32.0);
    v14 = (unsigned __int64)((double)*(unsigned int *)(v5 + 28) * v13 + (double)*(unsigned int *)(v5 + 32));
    v15 = (double)*(unsigned int *)(v7 + 28);
    v31 = HIDWORD(v14);
    v16 = v14;
    v28 = (unsigned __int64)(v13 * v15 + (double)*(unsigned int *)(v7 + 32));
    v17 = pszPath;
    v18 = 260;
    v19 = (char *)(v29 + 22) - (char *)pszPath;
    while ( v18 != -2147483386 )
    {
      v20 = *(WCHAR *)((char *)v17 + v19);
      if ( !v20 )
        break;
      *v17++ = v20;
      if ( !--v18 )
      {
        --v17;
        break;
      }
    }
    *v17 = 0;
    PathStripToRootW(pszPath);
    GetDiskFreeSpaceW(pszPath, (LPDWORD)SectorsPerCluster, &BytesPerSector, 0, 0);
    v21 = v31;
    v22 = BytesPerSector * SectorsPerCluster[0];
    if ( v31 | v16 )
    {
      v27 = 0;
      v21 = (v22 - __SPAIR64__(v31, v16) % v22 + __PAIR64__(v31, v16)) >> 32;
      v16 += v22 - __SPAIR64__(v31, v16) % v22;
    }
    v24 = HIDWORD(v28);
    v23 = v28;
    if ( v28 )
    {
      v27 = 0;
      v28 += v22 - v28 % v22;
      v24 = HIDWORD(v28);
      v23 = v28;
    }
    v25 = __PAIR64__(v21, v16) - __PAIR64__(v24, v23);
    if ( (((__PAIR64__(v21, v16) - __PAIR64__(v24, v23)) >> 32) & 0x80000000) != 0i64
      || (__SPAIR64__(v21, v16) < __SPAIR64__(v24, v23) || HIDWORD(v25) == 0) && !(_DWORD)v25 )
    {
      if ( v25 >= 0 )
        v9 = 0;
      else
        v9 = -1;
    }
    else
    {
      v9 = 1;
    }
    v11 = v29;
    v10 = *v29;
  }
  if ( !(*(int (__thiscall **)(_DWORD *))(v10 + 40))(v11) )
    return -v9;
  return v9;
}
// 4534E5: conditional instruction was optimized away because esi.4!=0
// 453390: using guessed type DWORD SectorsPerCluster[2];

//----- (004535E0) --------------------------------------------------------
int __fastcall sub_4535E0(int a1, int a2, int a3)
{
  int v4; // edi
  const ITEMIDLIST *v5; // edx
  ITEMIDLIST *v6; // edi
  int v7; // ecx
  ITEMIDLIST *v8; // edi
  BOOL v9; // eax
  int v11; // eax
  int v12; // edi
  void *ppv; // [esp+28h] [ebp-530h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+2Ch] [ebp-52Ch] BYREF
  int v15; // [esp+30h] [ebp-528h]
  BOOL IsRootW; // [esp+34h] [ebp-524h]
  STRRET pstr; // [esp+38h] [ebp-520h] BYREF
  WCHAR pszBuf[260]; // [esp+140h] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+348h] [ebp-210h] BYREF

  v4 = a2;
  v15 = a2;
  if ( !*(_DWORD *)(a1 + 640) )
    goto LABEL_9;
  v5 = *(const ITEMIDLIST **)(a1 + 76);
  ppidlLast = 0;
  ppv = 0;
  v6 = ILCombine(v5, *(LPCITEMIDLIST *)(560 * v4 + *(_DWORD *)(a1 + 52)));
  SHBindToParent(v6, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v6);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  v7 = *(_DWORD *)(a1 + 52);
  ppv = 0;
  v8 = ILCombine(*(LPCITEMIDLIST *)(a1 + 76), *(LPCITEMIDLIST *)(560 * a3 + v7));
  SHBindToParent(v8, &stru_4BD7FC, &ppv, &ppidlLast);
  (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(v8);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  ppv = 0;
  IsRootW = PathIsRootW(pszBuf);
  v9 = PathIsRootW(pszPath);
  if ( !IsRootW )
  {
    if ( v9 )
      return 1;
    v4 = v15;
LABEL_9:
    sub_4664A0(10, pszBuf);
    if ( !StrCmpW((PCWSTR)(a1 + 88), pszBuf) )
      goto LABEL_14;
    v11 = *(_DWORD *)(a1 + 48);
    if ( (*(_DWORD *)(592 * v4 + v11) & 0x10) != 0 && (*(_BYTE *)(592 * a3 + v11) & 0x10) == 0 )
      return -1;
    if ( (*(_DWORD *)(592 * v4 + v11) & 0x10) == 16 || (*(_BYTE *)(592 * a3 + v11) & 0x10) == 0 )
    {
LABEL_14:
      v12 = StrCmpLogicalW((PCWSTR)(560 * v4 + *(_DWORD *)(a1 + 52) + 4), (PCWSTR)(560 * a3 + *(_DWORD *)(a1 + 52) + 4));
      if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a1 + 40))(a1) )
        return -v12;
      return v12;
    }
    return 1;
  }
  if ( !v9 )
    return -1;
  PathStripToRootW(pszBuf);
  PathStripToRootW(pszPath);
  return lstrcmpW(pszBuf, pszPath);
}

//----- (00453890) --------------------------------------------------------
int __usercall sub_453890@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>)
{
  int v4; // edx
  int v5; // eax
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v10; // esi
  int v11; // [esp+Ch] [ebp-808h]
  WCHAR String2[512]; // [esp+10h] [ebp-804h] BYREF
  WCHAR String1[512]; // [esp+410h] [ebp-404h] BYREF

  v4 = *(_DWORD *)(a3 + 48);
  v11 = a1;
  v5 = v4 + 592 * a2;
  v6 = v4 + 592 * a1;
  v7 = (*(_DWORD *)v6 & 0x10) == 16;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return -1;
    v8 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1;
    sub_4676F0(*(const ITEMIDLIST **)(a3 + 76), v7, v6, *(_DWORD *)(a3 + 32), *(_DWORD *)(a3 + 52) + 560 * a2, String1);
    sub_4676F0(*(const ITEMIDLIST **)(a3 + 76), v7, v6, *(_DWORD *)(a3 + 32), *(_DWORD *)(a3 + 52) + 560 * v11, String2);
    v8 = lstrcmpW(String1, String2);
  }
  v10 = v8;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3) )
    return -v10;
  return v10;
}

//----- (004539C0) --------------------------------------------------------
int __userpurge sub_4539C0@<eax>(int a1@<ecx>, int a2@<esi>, int a3, int a4)
{
  int v4; // edx
  int v5; // eax
  int v6; // edi
  int v7; // eax
  int v9; // edi
  WCHAR v10[260]; // [esp+8h] [ebp-C18h] BYREF
  WCHAR pszDest[260]; // [esp+210h] [ebp-A10h] BYREF
  __int16 String2[512]; // [esp+418h] [ebp-808h] BYREF
  __int16 String1[514]; // [esp+818h] [ebp-408h] BYREF

  v4 = *(_DWORD *)(a2 + 48);
  v5 = v4 + 592 * a3;
  v6 = v4 + 592 * a1;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return -1;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    PathCombineW(v10, (LPCWSTR)(a2 + 88), (LPCWSTR)(v6 + 44));
    sub_469C60((int)pszDest, a4);
    sub_469C60((int)v10, a4);
    v7 = lstrcmpW((LPCWSTR)String1, (LPCWSTR)String2);
  }
  v9 = v7;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v9;
  return v9;
}
// 4539C0: using guessed type WCHAR String1[514];
// 4539C0: using guessed type WCHAR String2[512];

//----- (00453B80) --------------------------------------------------------
int __userpurge sub_453B80@<eax>(int a1@<ecx>, int a2@<esi>, int a3, int a4)
{
  int v4; // edx
  int v5; // eax
  int v6; // edi
  int v7; // eax
  int v9; // edi
  __int16 String1[512]; // [esp+8h] [ebp-C14h] BYREF
  __int16 String2[512]; // [esp+408h] [ebp-814h] BYREF
  WCHAR pszDest[260]; // [esp+808h] [ebp-414h] BYREF
  WCHAR v13[260]; // [esp+A10h] [ebp-20Ch] BYREF

  v4 = *(_DWORD *)(a2 + 48);
  v5 = v4 + 592 * a3;
  v6 = v4 + 592 * a1;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return -1;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    PathCombineW(v13, (LPCWSTR)(a2 + 88), (LPCWSTR)(v6 + 44));
    sub_469F20((int)pszDest, a4);
    sub_469F20((int)v13, a4);
    v7 = lstrcmpW((LPCWSTR)String1, (LPCWSTR)String2);
  }
  v9 = v7;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v9;
  return v9;
}
// 453B80: using guessed type WCHAR String1[512];
// 453B80: using guessed type WCHAR String2[512];

//----- (00453D50) --------------------------------------------------------
int __userpurge sub_453D50@<eax>(int a1@<ecx>, int a2@<edi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi
  int v6; // eax
  int v8; // esi
  WCHAR String1[260]; // [esp+8h] [ebp-824h] BYREF
  WCHAR pszDest[260]; // [esp+210h] [ebp-61Ch] BYREF
  WCHAR String2[260]; // [esp+418h] [ebp-414h] BYREF
  WCHAR v12[260]; // [esp+620h] [ebp-20Ch] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    PathCombineW(v12, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    sub_4AD8F0(0, a2, pszDest, 1, String1);
    sub_4AD8F0(0, a2, v12, 1, String2);
    v6 = lstrcmpW(String1, String2);
  }
  v8 = v6;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v8;
  return v8;
}

//----- (00453E90) --------------------------------------------------------
int __userpurge sub_453E90@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // edi
  int v7; // eax
  WCHAR String1[512]; // [esp+8h] [ebp-C14h] BYREF
  WCHAR String2[512]; // [esp+408h] [ebp-814h] BYREF
  WCHAR pszDest[260]; // [esp+808h] [ebp-414h] BYREF
  WCHAR v12[260]; // [esp+A10h] [ebp-20Ch] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2);
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    PathCombineW(v12, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    sub_46A1B0(pszDest, String1, (int)L"ProductName");
    sub_46A1B0(v12, String2, (int)L"ProductName");
    v6 = lstrcmpW(String1, String2);
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2);
  }
  if ( !v7 )
    return -v6;
  return v6;
}
// 4C1440: using guessed type wchar_t aProductname_0[12];
// 4C1458: using guessed type wchar_t aProductname_1[12];

//----- (00454060) --------------------------------------------------------
int __userpurge sub_454060@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v8; // edi
  __int16 String2[512]; // [esp+8h] [ebp-C1Ch] BYREF
  WCHAR String1[512]; // [esp+408h] [ebp-81Ch] BYREF
  __int16 pszDest[260]; // [esp+808h] [ebp-41Ch] BYREF
  __int16 FileName[262]; // [esp+A10h] [ebp-214h] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    PathCombineW((LPWSTR)pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    PathCombineW((LPWSTR)FileName, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    sub_46A4F0((int)String1);
    sub_46A4F0((int)String1);
    v6 = lstrcmpW(String1, (LPCWSTR)String2);
  }
  v8 = v6;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v8;
  return v8;
}
// 454060: using guessed type WCHAR pszDest[260];
// 454060: using guessed type WCHAR FileName[262];
// 454060: using guessed type WCHAR String2[512];

//----- (00454190) --------------------------------------------------------
int __userpurge sub_454190@<eax>(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v8; // edi
  WCHAR String1[32]; // [esp+8h] [ebp-498h] BYREF
  WCHAR String2[32]; // [esp+48h] [ebp-458h] BYREF
  WCHAR pszDest[260]; // [esp+88h] [ebp-418h] BYREF
  WCHAR FileName[262]; // [esp+290h] [ebp-210h] BYREF

  v3 = *(_DWORD *)(a2 + 48);
  v4 = v3 + 592 * a3;
  v5 = v3 + 592 * a1;
  if ( (*(_DWORD *)v4 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v5 & 0x10) != 16 )
      return -1;
    v6 = StrCmpIW((PCWSTR)(v4 + 44), (PCWSTR)(v5 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v5 & 0x10) == 16 )
      return 1;
    PathCombineW(pszDest, (LPCWSTR)(a2 + 88), (LPCWSTR)(v4 + 44));
    PathCombineW(FileName, (LPCWSTR)(a2 + 88), (LPCWSTR)(v5 + 44));
    sub_46A7C0(String1, pszDest);
    sub_46A7C0(String2, FileName);
    v6 = lstrcmpW(String1, String2);
  }
  v8 = v6;
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)a2 + 40))(a2) )
    return -v8;
  return v8;
}

//----- (00454310) --------------------------------------------------------
int __stdcall sub_454310(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  result = sub_45A700(a1, a3, a2);
  if ( !result )
    return StrCmpLogicalW((PCWSTR)(560 * a1 + a3[13] + 4), (PCWSTR)(560 * a2 + a3[13] + 4));
  return result;
}

//----- (00454360) --------------------------------------------------------
int __thiscall sub_454360(WPARAM wParam, int a2)
{
  bool v3; // zf

  v3 = *(_DWORD *)(wParam + 740) == 0;
  *(_DWORD *)(wParam + 632) = a2;
  if ( !v3 )
  {
    SendMessageW(*(HWND *)(wParam + 28), 0x109Du, 0, 0);
    SendMessageW(*(HWND *)(wParam + 28), 0x10A0u, 0, 0);
    SendMessageW(*(HWND *)(wParam + 28), 0x109Du, 1u, 0);
    (*(void (__thiscall **)(WPARAM, int))(*(_DWORD *)(wParam + 8) + 104))(wParam + 8, 1);
  }
  SendMessageW(*(HWND *)(wParam + 28), 0x1030u, wParam, (LPARAM)sub_454310);
  if ( *(_DWORD *)(wParam + 636) == 4 )
    sub_455A40(wParam);
  return 0;
}

//----- (004543E0) --------------------------------------------------------
void __usercall sub_4543E0(LPARAM a1@<edi>, int a2@<esi>)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  bool v5; // cf
  WPARAM v6; // eax
  LRESULT v7; // eax
  HWND v8; // [esp-10h] [ebp-30h]
  LPARAM lParam[6]; // [esp+8h] [ebp-18h] BYREF

  if ( a1 != -1 )
  {
    CoTaskMemFree(*(LPVOID *)(560 * a1 + *(_DWORD *)(a2 + 52)));
    v2 = *(_DWORD *)(a2 + 48) + 592 * a1;
    v3 = *(_DWORD *)(v2 + 32);
    v4 = *(_DWORD *)(v2 + 28);
    v5 = *(_DWORD *)(a2 + 608) < v3;
    *(_DWORD *)(a2 + 608) -= v3;
    *(_DWORD *)(a2 + 612) -= v5 + v4;
    v8 = *(HWND *)(a2 + 28);
    lParam[0] = 1;
    lParam[2] = a1;
    v6 = SendMessageW(v8, 0x1053u, 0xFFFFFFFF, (LPARAM)lParam);
    if ( v6 != -1 )
      SendMessageW(*(HWND *)(a2 + 28), 0x1008u, v6, 0);
    *(_DWORD *)(*(_DWORD *)(a2 + 720) + 4 * a1) = 0;
    v7 = SendMessageW(*(HWND *)(a2 + 28), 0x1004u, 0, 0);
    --*(_DWORD *)(a2 + 680);
    if ( !v7 && !*(_DWORD *)(a2 + 2188) )
      SendMessageW(*(HWND *)(a2 + 32), 0x80C9u, *(_DWORD *)(a2 + 776), 1);
  }
}

//----- (004544A0) --------------------------------------------------------
WCHAR *__usercall sub_4544A0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  int v3; // ebx
  const WCHAR *ExtensionW; // eax
  WCHAR *v6; // edx
  int v7; // esi
  WCHAR *v8; // eax

  v3 = 0;
  if ( a2[192] )
  {
    if ( (*(_BYTE *)(592 * a1 + a2[12]) & 0x10) == 0 )
    {
      ExtensionW = PathFindExtensionW((LPCWSTR)(560 * a1 + a2[13] + 4));
      if ( *ExtensionW )
      {
        if ( !lstrcmpiW(ExtensionW, L".lnk") )
          v3 = 1;
      }
    }
  }
  if ( a2[190] && !v3 )
    return (WCHAR *)(560 * a1 + a2[13] + 4);
  v6 = (WCHAR *)(560 * a1 + a2[13] + 4);
  if ( *v6 == 46 || (*(_BYTE *)(592 * a1 + a2[12]) & 0x10) != 0 )
    return (WCHAR *)(560 * a1 + a2[13] + 4);
  v7 = 260;
  v8 = &word_4F0110;
  while ( v7 != -2147483386 && *v6 )
  {
    *v8++ = *v6++;
    if ( !--v7 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathRemoveExtensionW(&word_4F0110);
  return &word_4F0110;
}
// 454552: conditional instruction was optimized away because esi.4!=0

//----- (00454590) --------------------------------------------------------
HRESULT __thiscall sub_454590(void *this, int a2, int a3)
{
  HRESULT result; // eax
  int v5; // esi
  LPVOID pv; // [esp+Ch] [ebp-4h] BYREF

  pv = 0;
  result = sub_467810((LPITEMIDLIST *)&pv, a2);
  if ( result >= 0 )
  {
    v5 = (*(int (__thiscall **)(void *, LPVOID, int))(*(_DWORD *)this + 12))(this, pv, a3);
    CoTaskMemFree(pv);
    return v5;
  }
  return result;
}

//----- (004545E0) --------------------------------------------------------
int __usercall sub_4545E0@<eax>(LPCITEMIDLIST pidl@<ecx>, int a2@<ebx>)
{
  const ITEMIDLIST *v2; // esi
  BOOL v3; // eax
  LPCITEMIDLIST v4; // edi
  int v5; // esi
  HRESULT v6; // eax
  int v7; // edi
  SHCONTF v8; // eax
  int v9; // eax
  char *v10; // eax
  STRRET pstr; // [esp+8h] [ebp-540h] BYREF
  int v13; // [esp+110h] [ebp-438h] BYREF
  IShellFolder *ppshf; // [esp+114h] [ebp-434h] BYREF
  int v15; // [esp+118h] [ebp-430h] BYREF
  int v16; // [esp+11Ch] [ebp-42Ch]
  LPCITEMIDLIST pidla; // [esp+120h] [ebp-428h]
  LPITEMIDLIST ppidl; // [esp+124h] [ebp-424h] BYREF
  IShellFolder *v19; // [esp+128h] [ebp-420h] BYREF
  LPCITEMIDLIST v20; // [esp+12Ch] [ebp-41Ch] BYREF
  __int16 pszPath[260]; // [esp+130h] [ebp-418h] BYREF
  WCHAR pszBuf[262]; // [esp+338h] [ebp-210h] BYREF

  v2 = pidl;
  pidla = pidl;
  ppshf = 0;
  v19 = 0;
  v15 = 0;
  v20 = 0;
  v16 = 0;
  v3 = !SHGetPathFromIDListW(pidl, (LPWSTR)pszPath);
  *(_DWORD *)(a2 + 640) = v3;
  if ( v3 )
    sub_459CC0(a2);
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    ppidl = 0;
    if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
    {
      v4 = pidla;
      v5 = sub_466190(pidla, ppidl);
      CoTaskMemFree(ppidl);
      if ( v5 )
      {
        v6 = SHGetDesktopFolder(&v19);
        v2 = v4;
LABEL_9:
        v7 = v6;
        *(_DWORD *)(a2 + 76) = ILClone(v2);
        if ( v7 >= 0 )
        {
          v8 = 96;
          if ( *(_DWORD *)(a2 + 756) )
            v8 = 224;
          if ( v19->lpVtbl->EnumObjects(v19, *(HWND *)(a2 + 32), v8, (IEnumIDList **)&v15) >= 0 && v15 )
          {
            v13 = 1;
            while ( !(*(int (__stdcall **)(int, int, LPCITEMIDLIST *, int *))(*(_DWORD *)v15 + 12))(v15, 1, &v20, &v13) )
            {
              if ( v13 != 1 )
                break;
              ppidl = (LPITEMIDLIST)0x20000000;
              v19->lpVtbl->GetAttributesOf(v19, 1, &v20, (SFGAOF *)&ppidl);
              if ( *(_DWORD *)(a2 + 640) || ((unsigned int)ppidl & 0x20000000) != 0 )
                v9 = v19->lpVtbl->GetDisplayNameOf(v19, v20, 1, &pstr);
              else
                v9 = v19->lpVtbl->GetDisplayNameOf(v19, v20, 32769, &pstr);
              if ( v9 >= 0 )
              {
                StrRetToBufW(&pstr, v20, pszBuf, 0x104u);
                v10 = (char *)sub_4266B0(v20, a2, v2, pszBuf);
                sub_4265A0((char *)0xFFFFFFFF, (_DWORD *)a2, v10, 0);
                ++v16;
                v2 = pidla;
              }
              CoTaskMemFree((LPVOID)v20);
            }
            (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
          }
          v19->lpVtbl->Release(v19);
        }
        ppshf->lpVtbl->Release(ppshf);
        return v16;
      }
      v2 = v4;
    }
    v6 = ppshf->lpVtbl->BindToObject(ppshf, v2, 0, &stru_4BD7FC, (void **)&v19);
    goto LABEL_9;
  }
  return v16;
}
// 4545E0: using guessed type WCHAR pszPath[260];

//----- (00454890) --------------------------------------------------------
int __userpurge sub_454890@<eax>(LPITEMIDLIST *a1@<eax>, int a2@<ecx>, _DWORD *a3@<edi>, int a4)
{
  ITEMIDLIST *v6; // esi
  int v8; // edx
  ITEMIDLIST *v9; // eax
  int v10; // edx

  if ( (a4 & 0x1000) == 0 )
  {
    if ( (a4 & 0x2000) != 0 )
    {
      sub_466430(*(ITEMIDLIST **)(a2 + 76), a1);
      goto LABEL_11;
    }
    if ( (a4 & 0x4000) != 0 )
    {
      if ( !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 56) + 12))(*(_DWORD *)(a2 + 56)) )
        goto LABEL_8;
      v8 = **(_DWORD **)(a2 + 56);
      *a3 = 0;
      v9 = (ITEMIDLIST *)(*(int (__stdcall **)(int))(v8 + 44))(-1);
    }
    else
    {
      if ( (a4 & 0x8000) == 0 )
      {
        if ( a1 )
          goto LABEL_11;
        return -2147024809;
      }
      if ( !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 56) + 16))(*(_DWORD *)(a2 + 56)) )
      {
LABEL_8:
        SetFocus(*(HWND *)(a2 + 28));
        return -2147467259;
      }
      v10 = **(_DWORD **)(a2 + 56);
      *a3 = 0;
      v9 = (ITEMIDLIST *)(*(int (__stdcall **)(int))(v10 + 44))(1);
    }
    *a1 = v9;
    goto LABEL_11;
  }
  if ( !a1 )
    return -2147024809;
  v6 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *a1);
  *a1 = ILClone(v6);
  CoTaskMemFree(v6);
LABEL_11:
  if ( (a4 & 0x8000000) != 0 )
    *a3 = 0;
  return sub_467A90(*a1) != 0 ? 0 : -2147467259;
}

//----- (00454980) --------------------------------------------------------
BOOL __usercall sub_454980@<eax>(int a1@<eax>, int a2@<esi>)
{
  BOOL result; // eax
  BOOL v4; // ebx

  result = 0;
  v4 = 0;
  if ( *(_DWORD *)(a2 + 2188) && (*(_BYTE *)(592 * a1 + *(_DWORD *)(a2 + 48)) & 0x10) == 0 )
    result = !sub_469A50((LPCWSTR)(a2 + 1164), 560 * a1 + *(_DWORD *)(a2 + 52) + 4, *(_DWORD *)(a2 + 2192));
  if ( *(_DWORD *)(a2 + 764) )
    v4 = (*(_DWORD *)(592 * a1 + *(_DWORD *)(a2 + 48)) & 4) == 4;
  if ( result || v4 )
    return 1;
  return result;
}

//----- (00454A00) --------------------------------------------------------
int __thiscall sub_454A00(int this, LPCITEMIDLIST pidl, int a3)
{
  HCURSOR CursorW; // eax
  LPITEMIDLIST v5; // eax
  bool v6; // zf
  int v7; // esi
  HCURSOR v8; // eax
  int **v10; // eax
  int *v11; // ecx
  int v12; // edi
  _WORD *v13; // eax
  int v14; // edx
  __int16 v15; // cx
  const ITEMIDLIST *v16; // ecx
  HCURSOR v17; // eax
  LPVOID pv; // [esp+10h] [ebp-220h] BYREF
  int v19; // [esp+14h] [ebp-21Ch] BYREF
  int *v20; // [esp+18h] [ebp-218h]
  int v21; // [esp+1Ch] [ebp-214h]
  __int16 lParam[262]; // [esp+20h] [ebp-210h] BYREF

  v21 = this;
  v19 = 1;
  CursorW = LoadCursorW(0, (LPCWSTR)0x7F02);
  SetCursor(CursorW);
  v5 = ILClone(pidl);
  v6 = *(_DWORD *)(this + 636) == 0;
  pv = v5;
  if ( !v6 )
    sub_4558D0(this - 8);
  v7 = this - 8;
  if ( sub_454890((LPITEMIDLIST *)&pv, this - 8, &v19, a3) )
  {
    v8 = LoadCursorW(0, (LPCWSTR)0x7F00);
    SetCursor(v8);
    return -2147467259;
  }
  else
  {
    *(_DWORD *)(this + 2188) = 1;
    sub_45A340(this - 8);
    EnterCriticalSection(&stru_4EF464);
    LeaveCriticalSection(&stru_4EF464);
    sub_455870(v7);
    sub_455810(v7);
    *(_DWORD *)(this + 2188) = 0;
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 772));
    v10 = *(int ***)(this + 808);
    v11 = *v10;
    *v10 = (int *)v10;
    *(_DWORD *)(*(_DWORD *)(this + 808) + 4) = *(_DWORD *)(this + 808);
    *(_DWORD *)(this + 812) = 0;
    if ( v11 != *(int **)(this + 808) )
    {
      do
      {
        v20 = (int *)*v11;
        operator delete(v11);
        v11 = v20;
      }
      while ( v20 != *(int **)(this + 808) );
    }
    sub_40A140(this + 848);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 772));
    sub_466630((const ITEMIDLIST *)pv, (WCHAR *)lParam, 0x8000);
    v12 = v21;
    SendMessageW(*(HWND *)(v21 + 24), 0x8037u, *(_DWORD *)(v21 + 768), (LPARAM)lParam);
    v13 = (_WORD *)(v12 + 80);
    v14 = 260;
    while ( v14 != -2147483386 )
    {
      v15 = *(_WORD *)((char *)v13 + (_DWORD)&lParam[-40] - v12);
      if ( !v15 )
        break;
      *v13++ = v15;
      if ( !--v14 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
    if ( v19 )
      (*(void (__thiscall **)(_DWORD, LPVOID))(**(_DWORD **)(v12 + 48) + 32))(*(_DWORD *)(v12 + 48), pv);
    if ( *(_DWORD *)(v12 + 636) )
      sub_45B3C0(v7);
    v16 = (const ITEMIDLIST *)pv;
    *(_DWORD *)(v12 + 672) = 0;
    sub_4545E0(v16, v7);
    CoTaskMemFree(pv);
    SendMessageW(*(HWND *)(v12 + 20), 0xBu, 0, 0);
    SendMessageW(*(HWND *)(v12 + 20), 0x1009u, 0, 0);
    *(_DWORD *)(v12 + 680) = 0;
    *(_DWORD *)(v12 + 684) = 0;
    *(_DWORD *)(v12 + 600) = 0;
    *(_DWORD *)(v12 + 604) = 0;
    *(_DWORD *)(v12 + 608) = 0;
    *(_DWORD *)(v12 + 612) = 0;
    sub_455C00(v7);
    sub_45E060(v7, *(_DWORD *)(v12 + 628));
    sub_426070(v7, 0);
    sub_459B20(v7);
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v7 + 16))(v7, *(_DWORD *)(v12 + 624));
    SendMessageW(*(HWND *)(v12 + 20), 0x1013u, 0, 0);
    SendMessageW(*(HWND *)(v12 + 20), 0xBu, 1u, 0);
    *(_DWORD *)(v12 + 636) = 1;
    v17 = LoadCursorW(0, (LPCWSTR)0x7F00);
    SetCursor(v17);
    ++*(_DWORD *)(v12 + 720);
    return 0;
  }
}
// 454BA4: conditional instruction was optimized away because edx.4!=0
// 454A00: using guessed type WCHAR lParam[262];

//----- (00454CD0) --------------------------------------------------------
int __thiscall sub_454CD0(_WORD *this, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // edi
  int v5; // edx
  int v6; // ebx
  __int16 v7; // si

  result = 0;
  v4 = 0;
  v5 = 32;
  v6 = a3 - (_DWORD)this;
  while ( v5 != -2147483614 )
  {
    v7 = *(_WORD *)((char *)this + v6);
    if ( !v7 )
      break;
    *this++ = v7;
    ++v4;
    if ( !--v5 )
    {
      --this;
      --v4;
      result = -2147024774;
      break;
    }
  }
  *this = 0;
  if ( a2 )
    *a2 = v4;
  return result;
}
// 454D05: conditional instruction was optimized away because edx.4!=0

//----- (00454DC0) --------------------------------------------------------
int __usercall sub_454DC0@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
      result = 1;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 3;
      break;
    case 3:
      result = 2;
      break;
    case 4:
      result = 10;
      break;
    case 5:
      result = 11;
      break;
    case 6:
      result = 12;
      break;
    case 7:
      result = 13;
      break;
    case 8:
      result = 14;
      break;
    case 9:
      result = 15;
      break;
    case 10:
      result = 16;
      break;
    case 11:
      result = 17;
      break;
    case 12:
      result = 18;
      break;
    case 13:
      result = 19;
      break;
    case 14:
      result = 20;
      break;
    case 15:
      result = 21;
      break;
    case 16:
      result = 22;
      break;
    case 17:
      result = 23;
      break;
    case 18:
      result = 24;
      break;
    case 19:
      result = 25;
      break;
    case 20:
      result = 26;
      break;
    case 21:
      result = 27;
      break;
    case 22:
      result = 7;
      break;
    case 23:
      result = 29;
      break;
    case 24:
      result = 30;
      break;
    case 25:
      result = 31;
      break;
    case 26:
      result = 32;
      break;
    case 27:
      result = 33;
      break;
    case 28:
      result = 5;
      break;
    case 29:
      result = 6;
      break;
    case 30:
      result = 34;
      break;
    case 31:
      result = 35;
      break;
    case 32:
      result = 9;
      break;
    case 33:
      result = 8;
      break;
    case 34:
      result = 36;
      break;
    case 35:
      result = 37;
      break;
    case 36:
      result = 38;
      break;
    case 37:
      result = 39;
      break;
    case 38:
      result = 40;
      break;
  }
  return result;
}

//----- (00454F50) --------------------------------------------------------
LRESULT __userpurge sub_454F50@<eax>(WPARAM a1@<edi>, int a2@<esi>, WPARAM wParam, LPARAM a4)
{
  UINT v4; // eax
  WPARAM v5; // eax
  HWND v6; // eax
  HWND v8; // [esp-10h] [ebp-F0h]
  LPARAM v9[11]; // [esp+8h] [ebp-D8h] BYREF
  LPARAM lParam[8]; // [esp+34h] [ebp-ACh] BYREF
  WPARAM v11; // [esp+54h] [ebp-8Ch]
  WCHAR Buffer[66]; // [esp+58h] [ebp-88h] BYREF

  v4 = SendMessageW(*(HWND *)(a2 + 32), 0x80CBu, a1, 0);
  LoadStringW(*(HINSTANCE *)(a2 + 80), v4, Buffer, 64);
  lParam[0] = 6;
  lParam[3] = (LPARAM)Buffer;
  lParam[2] = a4;
  if ( a1 == 3 || a1 == 6 || a1 == 29 || a1 == 30 )
  {
    lParam[0] = 7;
    lParam[1] = 1;
  }
  v5 = SendMessageW(*(HWND *)(a2 + 28), 0x1061u, wParam, (LPARAM)lParam);
  v8 = *(HWND *)(a2 + 28);
  v11 = v5;
  v6 = (HWND)SendMessageW(v8, 0x101Fu, 0, 0);
  v9[0] = 8;
  v9[6] = a1;
  return SendMessageW(v6, 0x120Cu, v11, (LPARAM)v9);
}

//----- (00455040) --------------------------------------------------------
LRESULT __userpurge sub_455040@<eax>(int a1@<esi>, WPARAM wParam, int a3)
{
  IP_ADAPTER_ADDRESSES_LH *v3; // edi
  LPARAM lParam[13]; // [esp+8h] [ebp-7Ch] BYREF
  ULONG SizePointer; // [esp+3Ch] [ebp-48h] BYREF
  WCHAR Buffer[32]; // [esp+40h] [ebp-44h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  SizePointer = 0;
  GetAdaptersAddresses(0, 0, 0, 0, &SizePointer);
  v3 = (IP_ADAPTER_ADDRESSES_LH *)malloc(SizePointer);
  GetAdaptersAddresses(0, 0, 0, v3, &SizePointer);
  free(v3);
  LoadStringW(*(HINSTANCE *)(a1 + 80), 0, Buffer, 32);
  lParam[2] = a3;
  lParam[5] = (LPARAM)Buffer;
  return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)lParam);
}

//----- (004550F0) --------------------------------------------------------
int __userpurge sub_4550F0@<eax>(HWND hWnd@<ecx>, WPARAM a2@<edi>, _DWORD *a3@<esi>, int a4)
{
  LPWSTR ExtensionW; // eax
  bool v5; // zf
  HWND v6; // ecx
  LPARAM v8[5]; // [esp+4h] [ebp-68h] BYREF
  void *v9; // [esp+18h] [ebp-54h]
  LPARAM lParam[13]; // [esp+38h] [ebp-34h] BYREF

  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    ExtensionW = PathFindExtensionW((LPCWSTR)(592 * lParam[8] + a3[12] + 44));
    v5 = *ExtensionW == 46;
    v6 = (HWND)a3[7];
    v8[2] = a4;
    if ( v5 )
      v9 = ExtensionW + 1;
    else
      v9 = &unk_4C1534;
    SendMessageW(v6, 0x1074u, a2, (LPARAM)v8);
  }
  return a3[170];
}

//----- (00455170) --------------------------------------------------------
int __userpurge sub_455170@<eax>(HWND hWnd@<ecx>, WPARAM a2@<edi>, _DWORD *a3@<esi>, int a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  HWND v8; // [esp-10h] [ebp-7Ch]
  LPARAM v9[13]; // [esp+4h] [ebp-68h] BYREF
  LPARAM lParam[8]; // [esp+38h] [ebp-34h] BYREF
  int v11; // [esp+58h] [ebp-14h]

  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v4 = lstrlenW((LPCWSTR)(592 * v11 + a3[12] + 564));
    v5 = a3[12];
    v9[2] = a4;
    if ( v4 <= 0 )
      v6 = 592 * v11 + v5 + 44;
    else
      v6 = 592 * v11 + v5 + 564;
    v8 = (HWND)a3[7];
    v9[5] = v6;
    SendMessageW(v8, 0x1074u, a2, (LPARAM)v9);
  }
  return a3[170];
}

//----- (00455210) --------------------------------------------------------
void __userpurge sub_455210(WPARAM a1@<ebx>, int a2@<esi>, LPARAM a3)
{
  LPITEMIDLIST v3; // edi
  HWND v4; // [esp-14h] [ebp-334h]
  HWND v5; // [esp-10h] [ebp-330h]
  LPARAM v6[13]; // [esp+0h] [ebp-320h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-2ECh] BYREF
  SHFILEINFOW psfi; // [esp+68h] [ebp-2B8h] BYREF

  v5 = *(HWND *)(a2 + 28);
  lParam[0] = 4;
  lParam[1] = a1;
  lParam[2] = 0;
  if ( SendMessageW(v5, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v3 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(560 * lParam[8] + *(_DWORD *)(a2 + 52)));
    SHGetFileInfoW(&v3->mkid.cb, 0, &psfi, 0x2B4u, 0x408u);
    v6[2] = a3;
    v4 = *(HWND *)(a2 + 28);
    v6[5] = (LPARAM)psfi.szTypeName;
    SendMessageW(v4, 0x1074u, a1, (LPARAM)v6);
    CoTaskMemFree(v3);
  }
}

//----- (004552E0) --------------------------------------------------------
int __userpurge sub_4552E0@<eax>(WPARAM a1@<edi>, _DWORD *a2@<esi>, LPARAM a3)
{
  HWND v4; // [esp-10h] [ebp-504h]
  LPARAM lParam[13]; // [esp+0h] [ebp-4F4h] BYREF
  SHFILEINFOW psfi; // [esp+34h] [ebp-4C0h] BYREF
  WCHAR pszPath[260]; // [esp+2E8h] [ebp-20Ch] BYREF

  (*(void (__thiscall **)(_DWORD *, WPARAM, WCHAR *))(a2[2] + 48))(a2 + 2, a1, pszPath);
  SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x400u);
  lParam[2] = a3;
  v4 = (HWND)a2[7];
  lParam[5] = (LPARAM)psfi.szTypeName;
  SendMessageW(v4, 0x1074u, a1, (LPARAM)lParam);
  return a2[170];
}

//----- (00455370) --------------------------------------------------------
int __thiscall sub_455370(_DWORD *this)
{
  return *(_DWORD *)(this[239] + 4);
}

//----- (00455380) --------------------------------------------------------
int __userpurge sub_455380@<eax>(int a1@<edi>, WPARAM wParam, int a3)
{
  HWND v3; // ecx
  int result; // eax
  BYTE *v5; // esi
  void *v6; // eax
  LPARAM v7[13]; // [esp+0h] [ebp-B8h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-84h] BYREF
  int v9; // [esp+68h] [ebp-50h] BYREF
  HANDLE phPrinter; // [esp+6Ch] [ebp-4Ch] BYREF
  DWORD pcbNeeded; // [esp+70h] [ebp-48h] BYREF
  __int16 v12[32]; // [esp+74h] [ebp-44h] BYREF

  memset(v12, 0, sizeof(v12));
  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    if ( OpenPrinterW((LPWSTR)(560 * lParam[8] + *(_DWORD *)(a1 + 52) + 4), &phPrinter, 0) )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v5 = (BYTE *)malloc(pcbNeeded);
      if ( GetPrinterW(phPrinter, 2u, v5, pcbNeeded, &pcbNeeded) )
      {
        v6 = (void *)*((_DWORD *)v5 + 4);
        if ( !v6 )
          v6 = &unk_4C15A8;
        sub_454CD0(v12, &v9, (int)v6);
      }
      free(v5);
    }
    v7[2] = a3;
    v7[5] = (LPARAM)v12;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v7);
  }
  return result;
}

//----- (004554A0) --------------------------------------------------------
int __userpurge sub_4554A0@<eax>(int a1@<edi>, WPARAM wParam, int a3)
{
  HWND v3; // ecx
  int result; // eax
  BYTE *v5; // esi
  void *v6; // eax
  LPARAM v7[13]; // [esp+0h] [ebp-B8h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-84h] BYREF
  int v9; // [esp+68h] [ebp-50h] BYREF
  HANDLE phPrinter; // [esp+6Ch] [ebp-4Ch] BYREF
  DWORD pcbNeeded; // [esp+70h] [ebp-48h] BYREF
  __int16 v12[32]; // [esp+74h] [ebp-44h] BYREF

  memset(v12, 0, sizeof(v12));
  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    if ( OpenPrinterW((LPWSTR)(560 * lParam[8] + *(_DWORD *)(a1 + 52) + 4), &phPrinter, 0) )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v5 = (BYTE *)malloc(pcbNeeded);
      if ( GetPrinterW(phPrinter, 2u, v5, pcbNeeded, &pcbNeeded) )
      {
        v6 = (void *)*((_DWORD *)v5 + 6);
        if ( !v6 )
          v6 = &unk_4C15A8;
        sub_454CD0(v12, &v9, (int)v6);
      }
      free(v5);
    }
    v7[2] = a3;
    v7[5] = (LPARAM)v12;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v7);
  }
  return result;
}

//----- (004555C0) --------------------------------------------------------
int __userpurge sub_4555C0@<eax>(int a1@<edi>, WPARAM wParam, int a3)
{
  HWND v3; // ecx
  int result; // eax
  BYTE *v5; // esi
  void *v6; // eax
  LPARAM v7[13]; // [esp+0h] [ebp-B8h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-84h] BYREF
  int v9; // [esp+68h] [ebp-50h] BYREF
  HANDLE phPrinter; // [esp+6Ch] [ebp-4Ch] BYREF
  DWORD pcbNeeded; // [esp+70h] [ebp-48h] BYREF
  __int16 v12[32]; // [esp+74h] [ebp-44h] BYREF

  memset(v12, 0, sizeof(v12));
  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    if ( OpenPrinterW((LPWSTR)(560 * lParam[8] + *(_DWORD *)(a1 + 52) + 4), &phPrinter, 0) )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v5 = (BYTE *)malloc(pcbNeeded);
      if ( GetPrinterW(phPrinter, 2u, v5, pcbNeeded, &pcbNeeded) )
      {
        v6 = (void *)*((_DWORD *)v5 + 5);
        if ( !v6 )
          v6 = &unk_4C15A8;
        sub_454CD0(v12, &v9, (int)v6);
      }
      free(v5);
    }
    v7[2] = a3;
    v7[5] = (LPARAM)v12;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v7);
  }
  return result;
}

//----- (004556E0) --------------------------------------------------------
int __userpurge sub_4556E0@<eax>(int a1@<edi>, WPARAM wParam, int a3)
{
  HWND v3; // ecx
  int result; // eax
  BYTE *v5; // esi
  wchar_t *v6; // eax
  LPARAM v7[13]; // [esp+0h] [ebp-B8h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-84h] BYREF
  int v9; // [esp+68h] [ebp-50h] BYREF
  DWORD pcbNeeded; // [esp+6Ch] [ebp-4Ch] BYREF
  HANDLE phPrinter; // [esp+70h] [ebp-48h] BYREF
  __int16 v12[32]; // [esp+74h] [ebp-44h] BYREF

  memset(v12, 0, sizeof(v12));
  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    if ( OpenPrinterW((LPWSTR)(560 * lParam[8] + *(_DWORD *)(a1 + 52) + 4), &phPrinter, 0) )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v5 = (BYTE *)malloc(pcbNeeded);
      if ( GetPrinterW(phPrinter, 2u, v5, pcbNeeded, &pcbNeeded) )
      {
        v6 = sub_4684D0(*((_DWORD *)v5 + 18));
        if ( !v6 )
          v6 = (wchar_t *)&unk_4C15A8;
        sub_454CD0(v12, &v9, (int)v6);
      }
      free(v5);
      ClosePrinter(phPrinter);
    }
    v7[2] = a3;
    v7[5] = (LPARAM)v12;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v7);
  }
  return result;
}

//----- (00455810) --------------------------------------------------------
void __usercall sub_455810(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 932));
  v1 = *(_DWORD ***)(a1 + 920);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 920) + 4) = *(_DWORD *)(a1 + 920);
  *(_DWORD *)(a1 + 924) = 0;
  if ( v2 != *(_DWORD **)(a1 + 920) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 920) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 932));
}

//----- (00455870) --------------------------------------------------------
void __usercall sub_455870(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 892));
  v1 = *(_DWORD ***)(a1 + 880);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 880) + 4) = *(_DWORD *)(a1 + 880);
  *(_DWORD *)(a1 + 884) = 0;
  if ( v2 != *(_DWORD **)(a1 + 880) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 880) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 892));
}

//----- (004558D0) --------------------------------------------------------
_DWORD **__usercall sub_4558D0@<eax>(int a1@<esi>)
{
  WPARAM v1; // ebx
  _DWORD **result; // eax
  _DWORD **v3; // edx
  _DWORD *i; // edi
  _DWORD **v5; // [esp+Ch] [ebp-214h]
  WCHAR psz2[262]; // [esp+10h] [ebp-210h] BYREF

  v1 = 0;
  sub_4664A0(3, psz2);
  result = (_DWORD **)StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( !result )
  {
    v3 = (_DWORD **)(a1 + 992);
LABEL_14:
    v5 = v3;
    goto LABEL_15;
  }
  sub_4664A0(17, psz2);
  result = (_DWORD **)StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( !result )
  {
    v3 = (_DWORD **)(a1 + 980);
    goto LABEL_14;
  }
  sub_4664A0(10, psz2);
  result = (_DWORD **)StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( !result )
  {
    v3 = (_DWORD **)(a1 + 1004);
    goto LABEL_14;
  }
  sub_4664A0(4, psz2);
  result = (_DWORD **)StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( !result )
  {
    v3 = (_DWORD **)(a1 + 1016);
    goto LABEL_14;
  }
  if ( sub_459790(49, a1) )
  {
    result = (_DWORD **)(a1 + 1028);
    v5 = (_DWORD **)(a1 + 1028);
  }
  else
  {
    result = (_DWORD **)sub_459790(18, a1);
    if ( !result )
    {
      v3 = (_DWORD **)(a1 + 968);
      goto LABEL_14;
    }
    v5 = (_DWORD **)(a1 + 1040);
  }
LABEL_15:
  if ( *(_DWORD *)(a1 + 636) == 4 )
  {
    result = (_DWORD **)*v5;
    for ( i = (_DWORD *)**v5; i != *v5; i = (_DWORD *)*i )
    {
      if ( i[3] )
      {
        result = (_DWORD **)SendMessageW(*(HWND *)(a1 + 28), 0x101Du, v1, 0);
        i[4] = result;
        ++v1;
      }
    }
  }
  return result;
}

//----- (00455A40) --------------------------------------------------------
int __usercall sub_455A40@<eax>(int a1@<esi>)
{
  WPARAM v1; // edi
  LRESULT v2; // eax
  _DWORD *v3; // ecx
  HWND v4; // edx
  _DWORD *v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // ecx
  unsigned int v9; // eax
  int v10; // eax
  WPARAM v11; // edi
  int result; // eax
  HWND v13; // [esp-10h] [ebp-50h]
  LPARAM lParam[5]; // [esp+8h] [ebp-38h] BYREF
  unsigned int v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+34h] [ebp-Ch]
  HWND hWnd; // [esp+38h] [ebp-8h]
  WPARAM wParam; // [esp+3Ch] [ebp-4h]

  v1 = 0;
  v13 = *(HWND *)(a1 + 28);
  wParam = 0;
  v16 = -1;
  v2 = SendMessageW(v13, 0x101Fu, 0, 0);
  v3 = **(_DWORD ***)(a1 + 964);
  v4 = (HWND)v2;
  v5 = (_DWORD *)*v3;
  hWnd = v4;
  if ( v5 == v3 )
    goto LABEL_13;
  while ( !v5[3] )
  {
LABEL_5:
    v5 = (_DWORD *)*v5;
    if ( v5 == **(_DWORD ***)(a1 + 964) )
      goto LABEL_13;
  }
  if ( *(_DWORD *)(a1 + 1064) != v5[2] )
  {
    ++v1;
    goto LABEL_5;
  }
  lParam[0] = 4;
  SendMessageW(v4, 0x120Bu, v1, (LPARAM)lParam);
  if ( (v15 & 0x400) != 0 )
  {
    v6 = v15 & 0xFFFFFBFF;
    goto LABEL_11;
  }
  if ( (v15 & 0x200) != 0 )
  {
    v6 = v15 & 0xFFFFFDFF;
LABEL_11:
    v15 = v6;
  }
  SendMessageW(hWnd, 0x120Cu, v1, (LPARAM)lParam);
  v4 = hWnd;
LABEL_13:
  v7 = **(_DWORD ***)(a1 + 964);
  v8 = (_DWORD *)*v7;
  if ( (_DWORD *)*v7 == v7 )
    goto LABEL_23;
  while ( 2 )
  {
    if ( !v8[3] )
    {
LABEL_20:
      v8 = (_DWORD *)*v8;
      if ( v8 == **(_DWORD ***)(a1 + 964) )
        goto LABEL_23;
      continue;
    }
    break;
  }
  v9 = v8[2] - 1;
  if ( v9 > 0x26 )
    v10 = 0;
  else
    v10 = sub_454DC0(v9);
  if ( v10 != *(_DWORD *)(a1 + 632) )
  {
    ++wParam;
    goto LABEL_20;
  }
  v16 = v8[2];
LABEL_23:
  v11 = wParam;
  lParam[0] = 4;
  SendMessageW(v4, 0x120Bu, wParam, (LPARAM)lParam);
  if ( *(_DWORD *)(a1 + 744) )
    v15 |= 0x400u;
  else
    v15 |= 0x200u;
  SendMessageW(hWnd, 0x120Cu, v11, (LPARAM)lParam);
  result = v16;
  *(_DWORD *)(a1 + 1064) = v16;
  return result;
}
// 455B18: variable 'v8' is possibly undefined
// 455B41: variable 'v4' is possibly undefined

//----- (00455B80) --------------------------------------------------------
int __thiscall sub_455B80(_DWORD **this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // eax
  int v5; // edx
  int v6; // edi
  _DWORD *i; // ebx
  _DWORD *v8; // ecx

  v3 = (_DWORD *)*this[239];
  v4 = (_DWORD *)*v3;
  v5 = 0;
  v6 = 0;
  for ( i = 0; v4 != v3; v4 = (_DWORD *)*v4 )
  {
    if ( v4[3] )
    {
      if ( v5 == a2 )
      {
        v8 = (_DWORD *)v4[2];
        if ( (unsigned int)v8 - 1 > 0x26 )
          v6 = 0;
        else
          v6 = sub_454DC0((int)v8 - 1);
        i = v8;
        break;
      }
      ++v5;
    }
  }
  if ( this[264] == i )
    ((void (__thiscall *)(_DWORD **))(*this)[58])(this);
  return ((int (__thiscall *)(_DWORD **, int))(*(this - 2))[4])(this - 2, v6);
}
// 455BC9: variable 'v8' is possibly undefined

//----- (00455C00) --------------------------------------------------------
int __usercall sub_455C00@<eax>(int a1@<esi>)
{
  int result; // eax
  bool v2; // zf
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(3, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 88), psz2) )
  {
    sub_4664A0(17, psz2);
    if ( StrCmpW((PCWSTR)(a1 + 88), psz2) )
    {
      sub_4664A0(10, psz2);
      if ( StrCmpW((PCWSTR)(a1 + 88), psz2) )
      {
        sub_4664A0(4, psz2);
        if ( StrCmpW((PCWSTR)(a1 + 88), psz2) )
        {
          if ( sub_459790(49, a1) )
          {
            result = a1 + 1028;
          }
          else
          {
            v2 = !sub_459790(18, a1);
            result = a1 + 1040;
            if ( v2 )
              result = a1 + 968;
          }
        }
        else
        {
          result = a1 + 1016;
        }
      }
      else
      {
        result = a1 + 1004;
      }
    }
    else
    {
      result = a1 + 980;
    }
  }
  else
  {
    result = a1 + 992;
  }
  if ( *(_DWORD *)(a1 + 964) != result )
  {
    *(_DWORD *)(a1 + 964) = result;
    *(_DWORD *)(a1 + 1052) = 0;
  }
  return result;
}

//----- (00455D20) --------------------------------------------------------
_DWORD **__usercall sub_455D20@<eax>(int a1@<eax>)
{
  _DWORD **result; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  char *v5; // edi
  WPARAM v6; // [esp+Ch] [ebp-4h]

  result = *(_DWORD ***)(a1 + 964);
  v6 = 0;
  *(_DWORD *)(a1 + 1060) = 0;
  if ( result )
  {
    v3 = *result;
    v4 = (_DWORD *)*v3;
    if ( (_DWORD *)*v3 != v3 )
    {
      do
      {
        if ( v4[3] )
        {
          sub_454F50(v4[2], a1, v6++, v4[4]);
          ++*(_DWORD *)(a1 + 1060);
        }
        v4 = (_DWORD *)*v4;
      }
      while ( v4 != **(_DWORD ***)(a1 + 964) );
    }
    result = *(_DWORD ***)(a1 + 1060);
    v5 = (char *)result + *(_DWORD *)(a1 + 1056);
    if ( (int)v5 >= (int)result )
    {
      do
        result = (_DWORD **)SendMessageW(*(HWND *)(a1 + 28), 0x101Cu, (WPARAM)v5--, 0);
      while ( (int)v5 >= *(_DWORD *)(a1 + 1060) );
    }
    *(_DWORD *)(a1 + 1056) = *(_DWORD *)(a1 + 1060);
  }
  return result;
}

//----- (00455DC0) --------------------------------------------------------
int __userpurge sub_455DC0@<eax>(int a1@<esi>, WPARAM wParam, int a3)
{
  HWND v3; // ecx
  int result; // eax
  BYTE *v5; // edi
  LPARAM v6[13]; // [esp+0h] [ebp-B4h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-80h] BYREF
  HANDLE phPrinter; // [esp+68h] [ebp-4Ch] BYREF
  DWORD pcbNeeded; // [esp+6Ch] [ebp-48h] BYREF
  wchar_t v10[32]; // [esp+70h] [ebp-44h] BYREF

  memset(v10, 0, sizeof(v10));
  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    if ( OpenPrinterW((LPWSTR)(560 * lParam[8] + *(_DWORD *)(a1 + 52) + 4), &phPrinter, 0) )
    {
      GetPrinterW(phPrinter, 2u, 0, 0, &pcbNeeded);
      v5 = (BYTE *)malloc(pcbNeeded);
      if ( GetPrinterW(phPrinter, 2u, v5, pcbNeeded, &pcbNeeded) )
        sub_401000(0x20u, v10, L"%d", *((_DWORD *)v5 + 19));
      free(v5);
    }
    v6[2] = a3;
    v6[5] = (LPARAM)v10;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v6);
  }
  return result;
}
// 4C1548: using guessed type wchar_t aD[3];

//----- (00455EE0) --------------------------------------------------------
int __userpurge sub_455EE0@<eax>(int a1@<esi>, HWND hWnd, WPARAM wParam, int a4)
{
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  int v7; // ecx
  HANDLE FileW; // eax
  void *v9; // ebx
  DWORD nNumberOfLinks; // eax
  BOOL FileInformationByHandle; // edi
  HWND v13; // eax
  LPARAM lParam[13]; // [esp+0h] [ebp-2B4h] BYREF
  struct _BY_HANDLE_FILE_INFORMATION v15; // [esp+34h] [ebp-280h] BYREF
  WCHAR pszPath[260]; // [esp+68h] [ebp-24Ch] BYREF
  __int16 v17[32]; // [esp+270h] [ebp-44h] BYREF

  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v4 = pszPath;
    v5 = 260;
    while ( v5 != -2147483386 )
    {
      v6 = *(WCHAR *)((char *)v4 + a1 + 88 - (_DWORD)pszPath);
      if ( !v6 )
        break;
      *v4++ = v6;
      if ( !--v5 )
      {
        --v4;
        break;
      }
    }
    v7 = *(_DWORD *)(a1 + 48);
    *v4 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + v7 + 44));
    FileW = CreateFileW(pszPath, 0x80u, 1u, 0, 3u, 0, 0);
    v9 = FileW;
    if ( FileW == (HANDLE)-1
      || (FileInformationByHandle = GetFileInformationByHandle(FileW, &v15), CloseHandle(v9), !FileInformationByHandle) )
    {
      nNumberOfLinks = 0;
    }
    else
    {
      nNumberOfLinks = v15.nNumberOfLinks;
      if ( v15.nNumberOfLinks == -1 )
      {
        v15.ftCreationTime.dwHighDateTime = a4;
        v13 = *(HWND *)(a1 + 28);
        v15.ftLastWriteTime.dwLowDateTime = (DWORD)&unk_4C1528;
        SendMessageW(v13, 0x1074u, wParam, (LPARAM)&v15);
        return *(_DWORD *)(a1 + 680);
      }
    }
    sub_401000(0x20u, (wchar_t *)v17, L"%ld", nNumberOfLinks);
    v15.ftCreationTime.dwHighDateTime = a4;
    v15.ftLastWriteTime.dwLowDateTime = (DWORD)v17;
    SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)&v15);
  }
  return *(_DWORD *)(a1 + 680);
}
// 455F63: conditional instruction was optimized away because edx.4!=0
// 4C152C: using guessed type wchar_t aLd[4];
// 455EE0: using guessed type wchar_t var_44[32];

//----- (00456060) --------------------------------------------------------
void __userpurge sub_456060(int a1@<esi>, WPARAM wParam, int a3)
{
  WPARAM v3; // edi
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  HWND v7; // [esp-10h] [ebp-5B0h]
  STRRET pstr; // [esp+8h] [ebp-598h] BYREF
  LPARAM lParam[13]; // [esp+114h] [ebp-48Ch] BYREF
  int v10[2]; // [esp+148h] [ebp-458h] BYREF
  int v11; // [esp+150h] [ebp-450h]
  WCHAR *v12; // [esp+15Ch] [ebp-444h]
  LPVOID pv; // [esp+17Ch] [ebp-424h]
  LPCITEMIDLIST ppidlLast; // [esp+180h] [ebp-420h] BYREF
  void *ppv; // [esp+184h] [ebp-41Ch] BYREF
  WCHAR pszBuf[260]; // [esp+188h] [ebp-418h] BYREF
  WCHAR FileSystemNameBuffer[262]; // [esp+390h] [ebp-210h] BYREF

  v3 = wParam;
  v7 = *(HWND *)(a1 + 28);
  ppv = 0;
  ppidlLast = 0;
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(v7, 0x104Bu, 0, (LPARAM)lParam) )
  {
    pv = ILCombine(*(LPCITEMIDLIST *)(a1 + 76), *(LPCITEMIDLIST *)(*(_DWORD *)(a1 + 52) + 560 * lParam[8]));
    SHBindToParent((LPCITEMIDLIST)pv, &stru_4BD7FC, &ppv, &ppidlLast);
    (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    if ( PathIsRootW(pszBuf) )
    {
      if ( !GetVolumeInformationW(pszBuf, 0, 0, 0, 0, 0, FileSystemNameBuffer, 0x104u) )
      {
        v4 = FileSystemNameBuffer;
        v5 = 260;
        while ( v5 != -2147483386 )
        {
          v6 = *(WCHAR *)((char *)v4 + &unk_4C1510 - (_UNKNOWN *)FileSystemNameBuffer);
          if ( !v6 )
            break;
          *v4++ = v6;
          if ( !--v5 )
          {
            --v4;
            break;
          }
        }
        v3 = wParam;
        *v4 = 0;
      }
      v11 = a3;
      v12 = FileSystemNameBuffer;
    }
    else
    {
      v11 = a3;
      v12 = (WCHAR *)&unk_4C1514;
    }
    SendMessageW(*(HWND *)(a1 + 28), 0x1074u, v3, (LPARAM)v10);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    CoTaskMemFree(pv);
  }
}
// 4561B3: conditional instruction was optimized away because edx.4!=0
// 456060: using guessed type LPARAM var_458[2];

//----- (00456230) --------------------------------------------------------
int __userpurge sub_456230@<eax>(_DWORD *a1@<ebx>, HWND a2@<edi>, WPARAM a3@<esi>, LPARAM a4)
{
  LPARAM v5[13]; // [esp+0h] [ebp-68h] BYREF
  LPARAM lParam[13]; // [esp+34h] [ebp-34h] BYREF

  lParam[0] = 4;
  lParam[2] = 0;
  lParam[1] = a3;
  if ( SendMessageW(a2, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v5[2] = a4;
    v5[5] = (LPARAM)sub_4544A0(lParam[8], a1);
    SendMessageW(a2, 0x1074u, a3, (LPARAM)v5);
  }
  return a1[170];
}

//----- (00456290) --------------------------------------------------------
int __userpurge sub_456290@<eax>(int a1@<eax>, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // ebx
  _DWORD *v5; // edi
  void *v6; // [esp-8h] [ebp-10h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(a1 + 932);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 932));
  SetEvent(*(HANDLE *)(a1 + 956));
  if ( *(_DWORD *)(a1 + 924) )
  {
    v5 = *(_DWORD **)(*(_DWORD *)(a1 + 920) + 4);
    v6 = *(void **)(a1 + 956);
    *a2 = v5[2];
    ResetEvent(v6);
    if ( v5 != *(_DWORD **)(a1 + 920) )
    {
      *(_DWORD *)v5[1] = *v5;
      *(_DWORD *)(*v5 + 4) = v5[1];
      operator delete(v5);
      --*(_DWORD *)(a1 + 924);
    }
    LeaveCriticalSection(v3);
    return 1;
  }
  else
  {
    LeaveCriticalSection(v3);
    return 0;
  }
}

//----- (00456330) --------------------------------------------------------
int __userpurge sub_456330@<eax>(int a1@<eax>, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // ebx
  int v5; // ecx
  _DWORD **v6; // edi

  v3 = (struct _RTL_CRITICAL_SECTION *)(a1 + 892);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 892));
  if ( *(_DWORD *)(a1 + 884) )
  {
    v5 = *(_DWORD *)(a1 + 880);
    v6 = *(_DWORD ***)v5;
    *a2 = *(_DWORD *)(*(_DWORD *)v5 + 8);
    ResetEvent(*(HANDLE *)(a1 + 916));
    if ( v6 != *(_DWORD ***)(a1 + 880) )
    {
      *v6[1] = *v6;
      (*v6)[1] = v6[1];
      operator delete(v6);
      --*(_DWORD *)(a1 + 884);
    }
    LeaveCriticalSection(v3);
    return 1;
  }
  else
  {
    SetEvent(*(HANDLE *)(a1 + 916));
    LeaveCriticalSection(v3);
    return 0;
  }
}

//----- (004563D0) --------------------------------------------------------
int **__thiscall sub_4563D0(int **this, char ***a2)
{
  int **result; // eax

  sub_4558D0((int)(this - 2));
  if ( a2 + 6 != (char ***)(this + 246) )
    sub_40B820(a2 + 6, *this[246], (int)this[246], (int)a2);
  if ( a2 + 3 != (char ***)(this + 243) )
    sub_40B820(a2 + 3, *this[243], (int)this[243], (int)a2);
  if ( a2 + 18 != (char ***)(this + 258) )
    sub_40B820(a2 + 18, *this[258], (int)this[258], (int)a2);
  if ( a2 + 15 != (char ***)(this + 255) )
    sub_40B820(a2 + 15, *this[255], (int)this[255], (int)a2);
  if ( a2 + 12 != (char ***)(this + 252) )
    sub_40B820(a2 + 12, *this[252], (int)this[252], (int)a2);
  if ( a2 != (char ***)(this + 240) )
    sub_40B820(a2, *this[240], (int)this[240], (int)a2);
  result = this + 249;
  if ( a2 + 9 != (char ***)(this + 249) )
    return (int **)sub_40B820(a2 + 9, **result, (int)*result, (int)a2);
  return result;
}

//----- (004564B0) --------------------------------------------------------
int __userpurge sub_4564B0@<eax>(WPARAM a1@<ebx>, int a2@<esi>, HWND hWnd, int a4, int a5)
{
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  int v8; // ecx
  LPARAM lParam[13]; // [esp+8h] [ebp-67Ch] BYREF
  int v11[2]; // [esp+3Ch] [ebp-648h] BYREF
  int v12; // [esp+44h] [ebp-640h]
  char *v13; // [esp+50h] [ebp-634h]
  char v14; // [esp+70h] [ebp-614h] BYREF
  WCHAR pszPath[262]; // [esp+470h] [ebp-214h] BYREF

  lParam[0] = 4;
  lParam[1] = a1;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v5 = pszPath;
    v6 = 260;
    while ( v6 != -2147483386 )
    {
      v7 = *(WCHAR *)((char *)v5 + a2 + 88 - (_DWORD)pszPath);
      if ( !v7 )
        break;
      *v5++ = v7;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    v8 = *(_DWORD *)(a2 + 48);
    *v5 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + v8 + 44));
    if ( sub_469C60((int)pszPath, a5) )
    {
      v12 = a4;
      v13 = &v14;
    }
    else
    {
      v12 = a4;
      v13 = (char *)&unk_4C153C;
    }
    SendMessageW(*(HWND *)(a2 + 28), 0x1074u, a1, (LPARAM)v11);
  }
  return *(_DWORD *)(a2 + 680);
}
// 456530: conditional instruction was optimized away because edx.4!=0
// 4564B0: using guessed type LPARAM var_648[2];

//----- (004565D0) --------------------------------------------------------
int __userpurge sub_4565D0@<eax>(WPARAM a1@<ebx>, _DWORD *a2@<esi>, HWND hWnd, LPARAM a4, int a5)
{
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  int v8; // ecx
  bool v9; // zf
  HWND v10; // edx
  HWND v11; // eax
  LPARAM lParam[13]; // [esp+0h] [ebp-674h] BYREF
  LPARAM v14[5]; // [esp+34h] [ebp-640h] BYREF
  char *v15; // [esp+48h] [ebp-62Ch]
  char v16; // [esp+68h] [ebp-60Ch] BYREF
  WCHAR pszPath[260]; // [esp+468h] [ebp-20Ch] BYREF

  lParam[0] = 4;
  lParam[1] = a1;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v5 = pszPath;
    v6 = 260;
    while ( v6 != -2147483386 )
    {
      v7 = *(WCHAR *)((char *)v5 + (char *)(a2 + 22) - (char *)pszPath);
      if ( !v7 )
        break;
      *v5++ = v7;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    v8 = a2[12];
    *v5 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + v8 + 44));
    v9 = sub_469F20((int)pszPath, a5) == -1;
    v14[2] = a4;
    if ( v9 )
    {
      v10 = (HWND)a2[7];
      v15 = (char *)&unk_4C1538;
      SendMessageW(v10, 0x1074u, a1, (LPARAM)v14);
    }
    else
    {
      v11 = (HWND)a2[7];
      v15 = &v16;
      SendMessageW(v11, 0x1074u, a1, (LPARAM)v14);
    }
  }
  return a2[170];
}
// 456650: conditional instruction was optimized away because edx.4!=0

//----- (00456700) --------------------------------------------------------
int __userpurge sub_456700@<eax>(int a1@<edi>, HWND hWnd, WPARAM wParam, int a4)
{
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  int v7; // ecx
  HWND v8; // ecx
  LPARAM lParam[13]; // [esp+0h] [ebp-47Ch] BYREF
  LPARAM v11[2]; // [esp+34h] [ebp-448h] BYREF
  int v12; // [esp+3Ch] [ebp-440h]
  __int16 *v13; // [esp+48h] [ebp-434h]
  __int16 v14[260]; // [esp+68h] [ebp-414h] BYREF
  WCHAR pszPath[260]; // [esp+270h] [ebp-20Ch] BYREF

  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v4 = pszPath;
    v5 = 260;
    while ( v5 != -2147483386 )
    {
      v6 = *(WCHAR *)((char *)v4 + a1 + 88 - (_DWORD)pszPath);
      if ( !v6 )
        break;
      *v4++ = v6;
      if ( !--v5 )
      {
        --v4;
        break;
      }
    }
    v7 = *(_DWORD *)(a1 + 48);
    *v4 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + v7 + 44));
    if ( sub_4AD8F0(0, a1, pszPath, 1, v14) < 0 )
    {
      v12 = a4;
      v8 = *(HWND *)(a1 + 28);
      v13 = (__int16 *)&unk_4C1524;
      SendMessageW(v8, 0x1074u, wParam, (LPARAM)v11);
    }
    else
    {
      v12 = a4;
      v13 = v14;
      SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)v11);
    }
  }
  return *(_DWORD *)(a1 + 680);
}
// 456784: conditional instruction was optimized away because edx.4!=0
// 456700: using guessed type _WORD var_414[260];

//----- (00456840) --------------------------------------------------------
int __userpurge sub_456840@<eax>(int a1@<ecx>, WPARAM a2@<ebx>, int a3@<esi>, HWND hWnd, int a5)
{
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  int v8; // ecx
  LPARAM lParam[13]; // [esp+0h] [ebp-678h] BYREF
  int v11[2]; // [esp+34h] [ebp-644h] BYREF
  int v12; // [esp+3Ch] [ebp-63Ch]
  __int16 *v13; // [esp+48h] [ebp-630h]
  int v14; // [esp+68h] [ebp-610h]
  __int16 v15[512]; // [esp+6Ch] [ebp-60Ch] BYREF
  WCHAR pszPath[260]; // [esp+46Ch] [ebp-20Ch] BYREF

  v14 = a1;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v5 = pszPath;
    v6 = 260;
    while ( v6 != -2147483386 )
    {
      v7 = *(WCHAR *)((char *)v5 + a3 + 88 - (_DWORD)pszPath);
      if ( !v7 )
        break;
      *v5++ = v7;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    v8 = *(_DWORD *)(a3 + 48);
    *v5 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592 * lParam[8] + v8 + 44));
    if ( sub_46A1B0(pszPath, v15, v14) )
    {
      v12 = a5;
      v13 = v15;
    }
    else
    {
      v12 = a5;
      v13 = (__int16 *)&unk_4C1520;
    }
    SendMessageW(*(HWND *)(a3 + 28), 0x1074u, a2, (LPARAM)v11);
  }
  return *(_DWORD *)(a3 + 680);
}
// 4568C6: conditional instruction was optimized away because edx.4!=0
// 456840: using guessed type _WORD var_60C[512];
// 456840: using guessed type LPARAM var_644[2];

//----- (00456970) --------------------------------------------------------
int __userpurge sub_456970@<eax>(WPARAM a1@<edi>, _DWORD *a2@<esi>, LPARAM a3)
{
  HWND v4; // [esp-10h] [ebp-65Ch]
  LPARAM lParam[13]; // [esp+4h] [ebp-648h] BYREF
  char v6[1024]; // [esp+38h] [ebp-614h] BYREF
  __int16 FileName[262]; // [esp+438h] [ebp-214h] BYREF

  memset(v6, 0, sizeof(v6));
  if ( (*(int (__thiscall **)(_DWORD *, WPARAM, __int16 *))(a2[2] + 48))(a2 + 2, a1, FileName) >= 0 )
  {
    sub_46A4F0((int)v6);
    lParam[2] = a3;
    v4 = (HWND)a2[7];
    lParam[5] = (LPARAM)v6;
    SendMessageW(v4, 0x1074u, a1, (LPARAM)lParam);
  }
  return a2[170];
}
// 456970: using guessed type WCHAR FileName[262];

//----- (00456A10) --------------------------------------------------------
int __userpurge sub_456A10@<eax>(WPARAM a1@<ebx>, _DWORD *a2@<esi>, LPARAM a3)
{
  HWND v4; // [esp-10h] [ebp-29Ch]
  LPARAM lParam[13]; // [esp+4h] [ebp-288h] BYREF
  WCHAR FileName[260]; // [esp+38h] [ebp-254h] BYREF
  __int16 v7[34]; // [esp+240h] [ebp-4Ch] BYREF

  if ( (*(int (__thiscall **)(_DWORD *, WPARAM, WCHAR *))(a2[2] + 48))(a2 + 2, a1, FileName) >= 0 )
  {
    sub_46A7C0(v7, FileName);
    lParam[2] = a3;
    v4 = (HWND)a2[7];
    lParam[5] = (LPARAM)v7;
    SendMessageW(v4, 0x1074u, a1, (LPARAM)lParam);
  }
  return a2[170];
}
// 456A10: using guessed type _WORD var_4C[34];

//----- (00456A90) --------------------------------------------------------
int __userpurge sub_456A90@<eax>(WPARAM a1@<ebx>, int a2@<esi>, HWND hWnd, int a4, int a5)
{
  int v5; // eax
  int v7[2]; // [esp+8h] [ebp-F4h] BYREF
  int v8; // [esp+10h] [ebp-ECh]
  __int16 *v9; // [esp+1Ch] [ebp-E0h]
  LPARAM lParam[8]; // [esp+3Ch] [ebp-C0h] BYREF
  int v11; // [esp+5Ch] [ebp-A0h]
  __int16 v12[66]; // [esp+70h] [ebp-8Ch] BYREF

  lParam[0] = 4;
  lParam[1] = a1;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        v5 = sub_46AB90(v12, 64, (FILETIME *)(592 * v11 + *(_DWORD *)(a2 + 48) + 4), *(_DWORD *)(a2 + 748));
      }
      else
      {
        if ( a5 != 2 )
          goto LABEL_10;
        v5 = sub_46AB90(v12, 64, (FILETIME *)(592 * v11 + *(_DWORD *)(a2 + 48) + 12), *(_DWORD *)(a2 + 748));
      }
    }
    else
    {
      v5 = sub_46AB90(v12, 64, (FILETIME *)(592 * v11 + *(_DWORD *)(a2 + 48) + 20), *(_DWORD *)(a2 + 748));
    }
    if ( v5 != -1 )
    {
      v8 = a4;
      v9 = v12;
LABEL_11:
      SendMessageW(*(HWND *)(a2 + 28), 0x1074u, a1, (LPARAM)v7);
      return *(_DWORD *)(a2 + 680);
    }
LABEL_10:
    v8 = a4;
    v9 = (__int16 *)&unk_4C1518;
    goto LABEL_11;
  }
  return *(_DWORD *)(a2 + 680);
}
// 456A90: using guessed type _WORD var_8C[66];
// 456A90: using guessed type LPARAM var_F4[2];

//----- (00456C60) --------------------------------------------------------
LRESULT __userpurge sub_456C60@<eax>(int a1@<esi>, WPARAM wParam, int a3)
{
  int v3; // edi
  HWND v5; // [esp-10h] [ebp-450h]
  LPARAM lParam[2]; // [esp+8h] [ebp-438h] BYREF
  int v7; // [esp+10h] [ebp-430h]
  __int16 *v8; // [esp+1Ch] [ebp-424h]
  int v9; // [esp+28h] [ebp-418h]
  __int16 String[512]; // [esp+3Ch] [ebp-404h] BYREF

  v3 = 0;
  v5 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  lParam[1] = wParam;
  v7 = 0;
  if ( SendMessageW(v5, 0x104Bu, 0, (LPARAM)lParam)
    && sub_4676F0(
         *(const ITEMIDLIST **)(a1 + 76),
         wParam,
         a1,
         *(_DWORD *)(a1 + 32),
         *(_DWORD *)(a1 + 52) + 560 * v9,
         String) >= 0 )
  {
    if ( lstrlenW((LPCWSTR)String) > 0 )
    {
      do
      {
        if ( String[v3] == 10 )
          String[v3] = 32;
        ++v3;
      }
      while ( v3 < lstrlenW((LPCWSTR)String) );
    }
    v7 = a3;
    v8 = String;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)lParam);
  }
  else
  {
    v7 = a3;
    v8 = (__int16 *)&unk_4C1540;
    return SendMessageW(*(HWND *)(a1 + 28), 0x1074u, wParam, (LPARAM)lParam);
  }
}
// 456C60: using guessed type WCHAR String[512];

//----- (00456D80) --------------------------------------------------------
int ***__thiscall sub_456D80(void *this, int ***a2)
{
  sub_45D540((int)this + 984, a2 + 6);
  sub_45D540((int)this + 972, a2 + 3);
  sub_45D540((int)this + 1032, a2 + 18);
  sub_45D540((int)this + 1020, a2 + 15);
  sub_45D540((int)this + 1008, a2 + 12);
  sub_45D540((int)this + 960, a2);
  return sub_45D540((int)this + 996, a2 + 9);
}

//----- (00456E00) --------------------------------------------------------
void __userpurge sub_456E00(int a1@<esi>, WPARAM wParam, int a3, int a4)
{
  WPARAM v4; // edi
  char *v5; // eax
  int v6; // edx
  __int16 v7; // cx
  HWND v8; // [esp-10h] [ebp-3FCh]
  STRRET pstr; // [esp+8h] [ebp-3E4h] BYREF
  LPARAM lParam[13]; // [esp+110h] [ebp-2DCh] BYREF
  int v11[2]; // [esp+144h] [ebp-2A8h] BYREF
  int v12; // [esp+14Ch] [ebp-2A0h]
  char *v13; // [esp+158h] [ebp-294h]
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+178h] [ebp-274h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+180h] [ebp-26Ch] BYREF
  LPVOID pv; // [esp+18Ch] [ebp-260h]
  LPCITEMIDLIST ppidlLast; // [esp+190h] [ebp-25Ch] BYREF
  void *ppv; // [esp+194h] [ebp-258h] BYREF
  WCHAR pszBuf[260]; // [esp+198h] [ebp-254h] BYREF
  char v20[68]; // [esp+3A0h] [ebp-4Ch] BYREF

  v4 = wParam;
  v8 = *(HWND *)(a1 + 28);
  ppv = 0;
  ppidlLast = 0;
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(v8, 0x104Bu, 0, (LPARAM)lParam) )
  {
    pv = ILCombine(*(LPCITEMIDLIST *)(a1 + 76), *(LPCITEMIDLIST *)(*(_DWORD *)(a1 + 52) + 560 * lParam[8]));
    SHBindToParent((LPCITEMIDLIST)pv, &stru_4BD7FC, &ppv, &ppidlLast);
    (*(void (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, 0x8000, &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    if ( PathIsRootW(pszBuf) )
    {
      if ( GetDiskFreeSpaceExW(pszBuf, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) )
      {
        if ( a4 )
          sub_46B2E0(0x20u, *(_DWORD *)(a1 + 672), *(_DWORD *)(a1 + 676), TotalNumberOfBytes.QuadPart);
        else
          sub_46B2E0(0x20u, *(_DWORD *)(a1 + 672), *(_DWORD *)(a1 + 676), TotalNumberOfFreeBytes.QuadPart);
        v12 = a3;
        v13 = v20;
      }
      else
      {
        v5 = v20;
        v6 = 32;
        while ( v6 != -2147483614 )
        {
          v7 = *(_WORD *)&v5[&unk_4C1508 - (_UNKNOWN *)v20];
          if ( !v7 )
            break;
          *(_WORD *)v5 = v7;
          v5 += 2;
          if ( !--v6 )
          {
            v5 -= 2;
            break;
          }
        }
        v4 = wParam;
        *(_WORD *)v5 = 0;
        v12 = a3;
        v13 = v20;
      }
    }
    else
    {
      v12 = a3;
      v13 = (char *)&unk_4C150C;
    }
    SendMessageW(*(HWND *)(a1 + 28), 0x1074u, v4, (LPARAM)v11);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    CoTaskMemFree(pv);
  }
}
// 456FD1: conditional instruction was optimized away because edx.4!=0
// 456E00: using guessed type LPARAM var_2A8[2];

//----- (00457050) --------------------------------------------------------
int __userpurge sub_457050@<eax>(HWND hWnd@<ecx>, _DWORD *a2@<ebx>, WPARAM wParam, int a4)
{
  HWND v4; // edi
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  char *v8; // eax
  int v9; // edx
  __int16 v10; // cx
  int v11; // edi
  DWORD v12; // ecx
  unsigned int v13; // esi
  unsigned __int64 v15; // [esp-8h] [ebp-2D8h]
  LPARAM v16[13]; // [esp+Ch] [ebp-2C4h] BYREF
  LPARAM lParam[8]; // [esp+40h] [ebp-290h] BYREF
  int v18; // [esp+60h] [ebp-270h]
  DWORD BytesPerSector; // [esp+74h] [ebp-25Ch] BYREF
  DWORD SectorsPerCluster; // [esp+78h] [ebp-258h] BYREF
  HWND v21; // [esp+7Ch] [ebp-254h]
  WCHAR pszPath[260]; // [esp+80h] [ebp-250h] BYREF
  char v23[68]; // [esp+288h] [ebp-48h] BYREF

  v4 = hWnd;
  v21 = hWnd;
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v5 = pszPath;
    v6 = 260;
    while ( v6 != -2147483386 )
    {
      v7 = *(WCHAR *)((char *)v5 + (char *)(a2 + 22) - (char *)pszPath);
      if ( !v7 )
        break;
      *v5++ = v7;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    *v5 = 0;
    PathStripToRootW(pszPath);
    if ( (*(_BYTE *)(592 * v18 + a2[12]) & 0x10) != 0 )
    {
      v8 = v23;
      v9 = 32;
      while ( v9 != -2147483614 )
      {
        v10 = *(_WORD *)&v8[&unk_4C1504 - (_UNKNOWN *)v23];
        if ( !v10 )
          break;
        *(_WORD *)v8 = v10;
        v8 += 2;
        if ( !--v9 )
        {
          *((_WORD *)v8 - 1) = 0;
          goto LABEL_18;
        }
      }
      *(_WORD *)v8 = 0;
    }
    else
    {
      GetDiskFreeSpaceW(pszPath, &SectorsPerCluster, &BytesPerSector, 0, 0);
      v11 = a2[12] + 592 * v18;
      v12 = BytesPerSector * SectorsPerCluster;
      v13 = *(_DWORD *)(v11 + 32);
      if ( v13 && v13 % v12 )
        v13 += v12 - v13 % v12;
      HIDWORD(v15) = *(_DWORD *)(v11 + 28);
      LODWORD(v15) = v13;
      sub_46B2E0(0x20u, a2[168], a2[169], v15);
      v4 = v21;
    }
LABEL_18:
    v16[2] = a4;
    v16[5] = (LPARAM)v23;
    SendMessageW(v4, 0x1074u, wParam, (LPARAM)v16);
  }
  return a2[170];
}
// 4570E0: conditional instruction was optimized away because edx.4!=0
// 457149: conditional instruction was optimized away because edx.4!=0

//----- (00457210) --------------------------------------------------------
int __userpurge sub_457210@<eax>(WPARAM a1@<ebx>, HWND a2@<edi>, _DWORD *a3@<esi>, LPARAM a4)
{
  int v4; // ecx
  int v5; // eax
  unsigned __int64 v7; // [esp-8h] [ebp-BCh]
  LPARAM v8[13]; // [esp+0h] [ebp-B4h] BYREF
  LPARAM lParam[8]; // [esp+34h] [ebp-80h] BYREF
  int v10; // [esp+54h] [ebp-60h]
  char v11; // [esp+68h] [ebp-4Ch] BYREF

  lParam[0] = 4;
  lParam[2] = 0;
  lParam[1] = a1;
  if ( SendMessageW(a2, 0x104Bu, 0, (LPARAM)lParam) )
  {
    v4 = a3[12];
    v5 = 592 * v10;
    if ( (*(_BYTE *)(592 * v10 + v4) & 0x10) == 0 )
    {
      HIDWORD(v7) = *(_DWORD *)(v5 + a3[12] + 28);
      LODWORD(v7) = *(_DWORD *)(v5 + v4 + 32);
      sub_46B2E0(0x20u, a3[168], a3[169], v7);
      v8[2] = a4;
      v8[5] = (LPARAM)&v11;
      SendMessageW(a2, 0x1074u, a1, (LPARAM)v8);
    }
  }
  return a3[170];
}

//----- (004572C0) --------------------------------------------------------
int __thiscall sub_4572C0(_DWORD *this)
{
  void (__stdcall *v2)(HWND, UINT, WPARAM, LPARAM); // ebx
  LPARAM v3; // edi
  _DWORD **v4; // edx
  _DWORD *v5; // eax
  int v6; // ecx
  int v7; // eax
  HWND v9; // [esp-10h] [ebp-328h]
  HWND v10; // [esp-10h] [ebp-328h]
  HWND v11; // [esp-10h] [ebp-328h]
  _DWORD *v12; // [esp+Ch] [ebp-30Ch]
  LPARAM v13; // [esp+10h] [ebp-308h]
  WPARAM wParam; // [esp+14h] [ebp-304h] BYREF
  int v15; // [esp+18h] [ebp-300h] BYREF
  int v16; // [esp+1Ch] [ebp-2FCh]
  int v17; // [esp+24h] [ebp-2F4h] BYREF
  int v18; // [esp+28h] [ebp-2F0h] BYREF
  LPARAM v19[8]; // [esp+2Ch] [ebp-2ECh] BYREF
  int v20; // [esp+4Ch] [ebp-2CCh]
  LPARAM lParam[13]; // [esp+60h] [ebp-2B8h] BYREF
  LPARAM v22[13]; // [esp+94h] [ebp-284h] BYREF
  char v23; // [esp+C8h] [ebp-250h] BYREF
  char v24[524]; // [esp+108h] [ebp-210h] BYREF

  v13 = 0;
  if ( sub_456290((int)this, &wParam) )
  {
    v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
    do
    {
      v3 = wParam;
      v9 = (HWND)this[7];
      lParam[0] = 4;
      lParam[1] = wParam;
      lParam[2] = 0;
      v2(v9, 0x104Bu, 0, (LPARAM)lParam);
      if ( (*(_BYTE *)(592 * lParam[8] + this[12]) & 0x10) != 0 )
      {
        v4 = (_DWORD **)this[241];
        v5 = (_DWORD *)**v4;
        v12 = v5;
        if ( v5 != *v4 )
        {
          while ( 1 )
          {
            if ( v5[3] )
            {
              if ( v5[2] == 3 )
              {
                v10 = (HWND)this[7];
                v19[0] = 4;
                v19[1] = v3;
                v19[2] = 0;
                if ( ((LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))v2)(v10, 0x104Bu, 0, (LPARAM)v19) )
                {
                  (*(void (__thiscall **)(_DWORD *, LPARAM, char *))(this[2] + 48))(this + 2, v3, v24);
                  sub_4B0F60((int)v24, &v18, &v17, &v15);
                  if ( *(_DWORD *)(this[180] + 4 * v20) == 1 )
                  {
                    v6 = v15;
                    *(_DWORD *)(592 * v20 + this[12] + 32) = v15;
                    v7 = v16;
                    *(_DWORD *)(592 * v20 + this[12] + 28) = v16;
                    *(_DWORD *)(this[13] + 560 * v20 + 540) = 1;
                    sub_46B2E0(0x20u, this[168], this[169], __PAIR64__(v7, v6));
                    v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
                    v22[2] = v13;
                    v11 = (HWND)this[7];
                    v22[5] = (LPARAM)&v23;
                    SendMessageW(v11, 0x1074u, v3, (LPARAM)v22);
                  }
                }
                v5 = v12;
              }
              if ( v5[3] )
                ++v13;
            }
            v12 = (_DWORD *)*v5;
            if ( *v5 == *(_DWORD *)this[241] )
              break;
            v5 = (_DWORD *)*v5;
          }
        }
      }
      v13 = 0;
    }
    while ( sub_456290((int)this, &wParam) );
  }
  sub_455A40((int)this);
  return 0;
}

//----- (004574E0) --------------------------------------------------------
void __stdcall sub_4574E0(ULONG_PTR Parameter)
{
  sub_4572C0((_DWORD *)Parameter);
}

//----- (004574F0) --------------------------------------------------------
int __thiscall sub_4574F0(void *this, int a2, WPARAM wParam, int a4)
{
  int result; // eax
  WCHAR *v6; // eax
  int v7; // edx
  int v8; // esi
  WCHAR v9; // cx
  int v10; // esi
  int v11; // ecx
  void *v12; // esi
  void *v13; // ebx
  __int16 *v14; // eax
  int v15; // edx
  int v16; // esi
  __int16 v17; // cx
  _DWORD *v18; // eax
  int v19; // edx
  struct std::locale::facet *v20; // ebx
  int *v21; // eax
  int *v22; // eax
  void *v23; // ebx
  int *v24; // eax
  int v25; // edx
  void *v26; // eax
  char *v27; // eax
  char *v28; // esi
  __int16 *v29; // eax
  int v30; // edx
  int v31; // esi
  __int16 v32; // cx
  int v33; // edx
  __int16 v34; // cx
  __int16 v35; // cx
  int v36; // edx
  int v37; // esi
  __int16 v38; // cx
  int v39; // edx
  int v40; // esi
  __int16 v41; // cx
  int v42; // edx
  int v43; // esi
  __int16 v44; // cx
  int v45; // edx
  int v46; // esi
  __int16 v47; // cx
  int v48; // edx
  int v49; // esi
  __int16 v50; // cx
  int v51; // edx
  int v52; // esi
  __int16 v53; // cx
  int v54; // edx
  int v55; // esi
  __int16 v56; // cx
  int v57; // edx
  int v58; // esi
  __int16 v59; // cx
  int v60; // edx
  int v61; // esi
  __int16 v62; // cx
  int v63; // edx
  int v64; // esi
  __int16 v65; // cx
  int v66; // edx
  int v67; // esi
  __int16 v68; // cx
  int v69; // edx
  int v70; // esi
  __int16 v71; // cx
  int v72; // edx
  int v73; // esi
  __int16 v74; // cx
  int v75; // edx
  int v76; // esi
  __int16 v77; // cx
  int v78; // edx
  int v79; // esi
  __int16 v80; // cx
  int v81; // edx
  int v82; // esi
  __int16 v83; // cx
  int v84; // edx
  int v85; // esi
  __int16 v86; // cx
  int v87; // edx
  int v88; // esi
  __int16 v89; // cx
  int v90; // edx
  int v91; // esi
  __int16 v92; // cx
  int v93; // edx
  int v94; // esi
  __int16 v95; // cx
  HWND v96; // eax
  HWND v97; // [esp-10h] [ebp-5B4h]
  int v98[4]; // [esp+10h] [ebp-594h] BYREF
  int v99[38]; // [esp+20h] [ebp-584h] BYREF
  LPARAM v100[13]; // [esp+B8h] [ebp-4ECh] BYREF
  LPARAM lParam[13]; // [esp+ECh] [ebp-4B8h] BYREF
  char v102[12]; // [esp+120h] [ebp-484h] BYREF
  int v103; // [esp+12Ch] [ebp-478h] BYREF
  struct std::locale::_Locimp *v104; // [esp+130h] [ebp-474h] BYREF
  int v105; // [esp+134h] [ebp-470h] BYREF
  void *Block; // [esp+138h] [ebp-46Ch] BYREF
  void *v107; // [esp+13Ch] [ebp-468h] BYREF
  int v108; // [esp+140h] [ebp-464h] BYREF
  void *v109; // [esp+144h] [ebp-460h] BYREF
  int v110; // [esp+14Ch] [ebp-458h]
  void *v111; // [esp+150h] [ebp-454h] BYREF
  char v112[8]; // [esp+154h] [ebp-450h] BYREF
  int v113; // [esp+15Ch] [ebp-448h]
  __int16 *v114; // [esp+168h] [ebp-43Ch]
  int v115[7]; // [esp+16Ch] [ebp-438h] BYREF
  WCHAR pszPath[260]; // [esp+188h] [ebp-41Ch] BYREF
  __int16 v117[256]; // [esp+390h] [ebp-214h] BYREF
  int v118; // [esp+5A0h] [ebp-4h]

  v110 = a2;
  v97 = *(HWND *)(a2 + 28);
  v111 = 0;
  v107 = 0;
  Block = 0;
  v109 = 0;
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  result = SendMessageW(v97, 0x104Bu, 0, (LPARAM)lParam);
  if ( result )
  {
    v6 = pszPath;
    v7 = 260;
    v8 = v110 + 88 - (_DWORD)pszPath;
    while ( v7 != -2147483386 )
    {
      v9 = *(WCHAR *)((char *)v6 + v8);
      if ( !v9 )
        break;
      *v6++ = v9;
      if ( !--v7 )
      {
        --v6;
        break;
      }
    }
    v10 = v110;
    v11 = *(_DWORD *)(v110 + 48);
    *v6 = 0;
    PathAppendW(pszPath, (LPCWSTR)(v11 + 592 * lParam[8] + 44));
    switch ( (unsigned int)this )
    {
      case 0u:
        if ( sub_468090((int)pszPath, (int)L"Bitrate", &Block) < 0 )
          goto LABEL_163;
        v12 = Block;
        sub_401000(0x100u, (wchar_t *)v117, L"%d bps", *(_DWORD *)Block);
        free(v12);
        goto LABEL_162;
      case 1u:
        if ( sub_468090((int)pszPath, (int)L"Copyright", &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v15 = 256;
        v16 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v15 != -2147483390 )
        {
          v17 = *(__int16 *)((char *)v14 + v16);
          if ( !v17 )
            break;
          *v14++ = v17;
          if ( !--v15 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 2u:
        if ( sub_468090((int)pszPath, (int)L"Duration", &v107) < 0 )
          goto LABEL_163;
        v18 = operator new(0x14Cu);
        v109 = v18;
        v118 = 0;
        if ( v18 )
          v20 = (struct std::locale::facet *)sub_420B30(v18);
        else
          v20 = 0;
        v118 = -1;
        sub_4094F0((_DWORD *)v20 + 76, v19, L"%H:%M:%S", 8);
        sub_40BE70(v98);
        v118 = 1;
        v21 = sub_408A70((_DWORD **)((char *)v98 + *(_DWORD *)(v98[0] + 4)), &v105);
        LOBYTE(v118) = 2;
        v22 = (int *)sub_4222E0(v20, &v104, v21);
        LOBYTE(v118) = 3;
        sub_418E70(v22, (int)v98 + *(_DWORD *)(v98[0] + 4), &v103);
        sub_408B00(&v103);
        sub_408B00((int *)&v104);
        LOBYTE(v118) = 1;
        sub_408B00(&v105);
        v23 = v107;
        v24 = (int *)sub_420F80((int)v102, *(_QWORD *)v107 / 0xAui64);
        v25 = *v24;
        v26 = (void *)v24[1];
        v108 = v25;
        v109 = v26;
        sub_4223A0(v99, &v108);
        v27 = (char *)sub_40BFB0((int)v98, v115);
        if ( *((_DWORD *)v27 + 5) < 8u )
          v28 = v27;
        else
          v28 = *(char **)v27;
        v29 = v117;
        v30 = 256;
        v31 = v28 - (char *)v117;
        while ( v30 != -2147483390 )
        {
          v32 = *(__int16 *)((char *)v29 + v31);
          if ( !v32 )
            break;
          *v29++ = v32;
          if ( !--v30 )
          {
            --v29;
            break;
          }
        }
        *v29 = 0;
        sub_409000((int)v115);
        free(v23);
        v118 = -1;
        sub_40BB60((int)v98);
        goto LABEL_162;
      case 3u:
        if ( sub_468090((int)pszPath, (int)L"Is_Protected", &v109) < 0 )
          goto LABEL_163;
        v13 = v109;
        v14 = v117;
        v33 = 256;
        if ( *(_DWORD *)v109 )
        {
          while ( v33 != -2147483390 )
          {
            v34 = *(__int16 *)((char *)v14 + (char *)L"Yes" - (char *)v117);
            if ( !v34 )
              break;
            *v14++ = v34;
            if ( !--v33 )
              goto LABEL_160;
          }
        }
        else
        {
          while ( v33 != -2147483390 )
          {
            v35 = *(__int16 *)((char *)v14 + (char *)L"No" - (char *)v117);
            if ( !v35 )
              break;
            *v14++ = v35;
            if ( !--v33 )
              goto LABEL_160;
          }
        }
        goto LABEL_161;
      case 4u:
        if ( sub_468090((int)pszPath, (int)L"Rating", &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v36 = 256;
        v37 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v36 != -2147483390 )
        {
          v38 = *(__int16 *)((char *)v14 + v37);
          if ( !v38 )
            break;
          *v14++ = v38;
          if ( !--v36 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 5u:
        if ( sub_468090((int)pszPath, (int)&off_4C1668, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v39 = 256;
        v40 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v39 != -2147483390 )
        {
          v41 = *(__int16 *)((char *)v14 + v40);
          if ( !v41 )
            break;
          *v14++ = v41;
          if ( !--v39 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 6u:
        if ( sub_468090((int)pszPath, (int)&off_4C1610, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v42 = 256;
        v43 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v42 != -2147483390 )
        {
          v44 = *(__int16 *)((char *)v14 + v43);
          if ( !v44 )
            break;
          *v14++ = v44;
          if ( !--v42 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 7u:
        if ( sub_468090((int)pszPath, (int)&off_4C1754, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v45 = 256;
        v46 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v45 != -2147483390 )
        {
          v47 = *(__int16 *)((char *)v14 + v46);
          if ( !v47 )
            break;
          *v14++ = v47;
          if ( !--v45 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 8u:
        if ( sub_468090((int)pszPath, (int)&off_4C1650, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v48 = 256;
        v49 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v48 != -2147483390 )
        {
          v50 = *(__int16 *)((char *)v14 + v49);
          if ( !v50 )
            break;
          *v14++ = v50;
          if ( !--v48 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 9u:
        if ( sub_468090((int)pszPath, (int)&off_4C169C, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v51 = 256;
        v52 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v51 != -2147483390 )
        {
          v53 = *(__int16 *)((char *)v14 + v52);
          if ( !v53 )
            break;
          *v14++ = v53;
          if ( !--v51 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xAu:
        if ( sub_468090((int)pszPath, (int)&off_4C16D0, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v54 = 256;
        v55 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v54 != -2147483390 )
        {
          v56 = *(__int16 *)((char *)v14 + v55);
          if ( !v56 )
            break;
          *v14++ = v56;
          if ( !--v54 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xBu:
        if ( sub_468090((int)pszPath, (int)&off_4C162C, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v57 = 256;
        v58 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v57 != -2147483390 )
        {
          v59 = *(__int16 *)((char *)v14 + v58);
          if ( !v59 )
            break;
          *v14++ = v59;
          if ( !--v57 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xCu:
        if ( sub_468090((int)pszPath, (int)&off_4C1718, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v60 = 256;
        v61 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v60 != -2147483390 )
        {
          v62 = *(__int16 *)((char *)v14 + v61);
          if ( !v62 )
            break;
          *v14++ = v62;
          if ( !--v60 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xDu:
        if ( sub_468090((int)pszPath, (int)&off_4C1810, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v63 = 256;
        v64 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v63 != -2147483390 )
        {
          v65 = *(__int16 *)((char *)v14 + v64);
          if ( !v65 )
            break;
          *v14++ = v65;
          if ( !--v63 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xEu:
        if ( sub_468090((int)pszPath, (int)&off_4C17E0, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v66 = 256;
        v67 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v66 != -2147483390 )
        {
          v68 = *(__int16 *)((char *)v14 + v67);
          if ( !v68 )
            break;
          *v14++ = v68;
          if ( !--v66 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0xFu:
        if ( sub_468090((int)pszPath, (int)&off_4C17B8, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v69 = 256;
        v70 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v69 != -2147483390 )
        {
          v71 = *(__int16 *)((char *)v14 + v70);
          if ( !v71 )
            break;
          *v14++ = v71;
          if ( !--v69 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x10u:
        if ( sub_468090((int)pszPath, (int)&off_4C1778, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v72 = 256;
        v73 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v72 != -2147483390 )
        {
          v74 = *(__int16 *)((char *)v14 + v73);
          if ( !v74 )
            break;
          *v14++ = v74;
          if ( !--v72 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x11u:
        if ( sub_468090((int)pszPath, (int)&off_4C1730, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v75 = 256;
        v76 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v75 != -2147483390 )
        {
          v77 = *(__int16 *)((char *)v14 + v76);
          if ( !v77 )
            break;
          *v14++ = v77;
          if ( !--v75 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x12u:
        if ( sub_468090((int)pszPath, (int)&off_4C1788, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v78 = 256;
        v79 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v78 != -2147483390 )
        {
          v80 = *(__int16 *)((char *)v14 + v79);
          if ( !v80 )
            break;
          *v14++ = v80;
          if ( !--v78 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x13u:
        if ( sub_468090((int)pszPath, (int)&off_4C16E8, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v81 = 256;
        v82 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v81 != -2147483390 )
        {
          v83 = *(__int16 *)((char *)v14 + v82);
          if ( !v83 )
            break;
          *v14++ = v83;
          if ( !--v81 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x14u:
        if ( sub_468090((int)pszPath, (int)&off_4C16B8, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v84 = 256;
        v85 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v84 != -2147483390 )
        {
          v86 = *(__int16 *)((char *)v14 + v85);
          if ( !v86 )
            break;
          *v14++ = v86;
          if ( !--v84 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x15u:
        if ( sub_468090((int)pszPath, (int)&off_4C16FC, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v87 = 256;
        v88 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v87 != -2147483390 )
        {
          v89 = *(__int16 *)((char *)v14 + v88);
          if ( !v89 )
            break;
          *v14++ = v89;
          if ( !--v87 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x16u:
        if ( sub_468090((int)pszPath, (int)&off_4C1688, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v90 = 256;
        v91 = (_BYTE *)v111 - (_BYTE *)v117;
        while ( v90 != -2147483390 )
        {
          v92 = *(__int16 *)((char *)v14 + v91);
          if ( !v92 )
            break;
          *v14++ = v92;
          if ( !--v90 )
            goto LABEL_160;
        }
        goto LABEL_161;
      case 0x17u:
        if ( sub_468090((int)pszPath, (int)&off_4C1640, &v111) < 0 )
          goto LABEL_163;
        v13 = v111;
        v14 = v117;
        v93 = 256;
        v94 = (_BYTE *)v111 - (_BYTE *)v117;
        break;
      default:
LABEL_163:
        v100[2] = a4;
        v96 = *(HWND *)(v10 + 28);
        v100[5] = (LPARAM)&unk_4C1598;
        return SendMessageW(v96, 0x1074u, wParam, (LPARAM)v100);
    }
    while ( v93 != -2147483390 )
    {
      v95 = *(__int16 *)((char *)v14 + v94);
      if ( !v95 )
        break;
      *v14++ = v95;
      if ( !--v93 )
      {
LABEL_160:
        --v14;
        break;
      }
    }
LABEL_161:
    *v14 = 0;
    free(v13);
LABEL_162:
    v113 = a4;
    v114 = v117;
    return SendMessageW(*(HWND *)(v110 + 28), 0x1074u, wParam, (LPARAM)v112);
  }
  return result;
}
// 4575B3: conditional instruction was optimized away because edx.4!=0
// 457823: conditional instruction was optimized away because edx.4!=0
// 4581BB: conditional instruction was optimized away because edx.4!=0
// 457707: variable 'v19' is possibly undefined
// 4C1564: using guessed type wchar_t aDBps[7];
// 4C1574: using guessed type wchar_t aHMS_1[9];
// 4C1588: using guessed type wchar_t aYes[4];
// 4C1590: using guessed type wchar_t aNo[3];
// 4C15AC: using guessed type wchar_t aDuration[9];
// 4C15C0: using guessed type wchar_t aBitrate[8];
// 4C15D0: using guessed type wchar_t aIsProtected[13];
// 4C15EC: using guessed type wchar_t aRating[7];
// 4C15FC: using guessed type wchar_t aCopyright[10];
// 4C1610: using guessed type void *off_4C1610;
// 4C162C: using guessed type void *off_4C162C;
// 4C1640: using guessed type void *off_4C1640;
// 4C1650: using guessed type void *off_4C1650;
// 4C1668: using guessed type void *off_4C1668;
// 4C1688: using guessed type void *off_4C1688;
// 4C169C: using guessed type void *off_4C169C;
// 4C16B8: using guessed type void *off_4C16B8;
// 4C16D0: using guessed type void *off_4C16D0;
// 4C16E8: using guessed type void *off_4C16E8;
// 4C16FC: using guessed type void *off_4C16FC;
// 4C1718: using guessed type void *off_4C1718;
// 4C1730: using guessed type void *off_4C1730;
// 4C1754: using guessed type void *off_4C1754;
// 4C1778: using guessed type void *off_4C1778;
// 4C1788: using guessed type void *off_4C1788;
// 4C17B8: using guessed type void *off_4C17B8;
// 4C17E0: using guessed type void *off_4C17E0;
// 4C1810: using guessed type void *off_4C1810;
// 4574F0: using guessed type wchar_t var_214[256];
// 4574F0: using guessed type char var_484[12];
// 4574F0: using guessed type int var_584[38];
// 4574F0: using guessed type _DWORD var_438[7];
// 4574F0: using guessed type char var_450[8];

//----- (004582C0) --------------------------------------------------------
void __userpurge sub_4582C0(LPARAM a1@<ecx>, int a2@<eax>, int a3@<edx>, WPARAM wParam)
{
  switch ( a3 )
  {
    case 1:
      sub_456230((_DWORD *)a2, *(HWND *)(a2 + 28), wParam, a1);
      break;
    case 2:
      sub_4552E0(wParam, (_DWORD *)a2, a1);
      break;
    case 3:
      sub_457210(wParam, *(HWND *)(a2 + 28), (_DWORD *)a2, a1);
      break;
    case 4:
      sub_456A90(wParam, a2, *(HWND *)(a2 + 28), a1, 0);
      break;
    case 5:
      sub_456A10(wParam, (_DWORD *)a2, a1);
      break;
    case 6:
      sub_457050(*(HWND *)(a2 + 28), (_DWORD *)a2, wParam, a1);
      break;
    case 7:
      sub_455170(*(HWND *)(a2 + 28), wParam, (_DWORD *)a2, a1);
      break;
    case 8:
      sub_456970(wParam, (_DWORD *)a2, a1);
      break;
    case 9:
      sub_456840((int)L"ProductName", wParam, a2, *(HWND *)(a2 + 28), a1);
      break;
    case 10:
      sub_456840((int)L"CompanyName", wParam, a2, *(HWND *)(a2 + 28), a1);
      break;
    case 11:
      sub_456840((int)L"FileDescription", wParam, a2, *(HWND *)(a2 + 28), a1);
      break;
    case 12:
      sub_456840((int)L"FileVersion", wParam, a2, *(HWND *)(a2 + 28), a1);
      break;
    case 13:
      sub_456840((int)L"ProductVersion", wParam, a2, *(HWND *)(a2 + 28), a1);
      break;
    case 14:
      sub_456700(a2, *(HWND *)(a2 + 28), wParam, a1);
      break;
    case 15:
      sub_455EE0(a2, *(HWND *)(a2 + 28), wParam, a1);
      break;
    case 16:
      sub_4550F0(*(HWND *)(a2 + 28), wParam, (_DWORD *)a2, a1);
      break;
    case 17:
      sub_456A90(wParam, a2, *(HWND *)(a2 + 28), a1, 1);
      break;
    case 18:
      sub_456A90(wParam, a2, *(HWND *)(a2 + 28), a1, 2);
      break;
    case 19:
      sub_4565D0(wParam, (_DWORD *)a2, *(HWND *)(a2 + 28), a1, 2);
      break;
    case 20:
      sub_4565D0(wParam, (_DWORD *)a2, *(HWND *)(a2 + 28), a1, 3);
      break;
    case 21:
      sub_4565D0(wParam, (_DWORD *)a2, *(HWND *)(a2 + 28), a1, 4);
      break;
    case 22:
      sub_4565D0(wParam, (_DWORD *)a2, *(HWND *)(a2 + 28), a1, 5);
      break;
    case 23:
      sub_4565D0(wParam, (_DWORD *)a2, *(HWND *)(a2 + 28), a1, 6);
      break;
    case 24:
      sub_4564B0(wParam, a2, *(HWND *)(a2 + 28), a1, 272);
      break;
    case 25:
      sub_4564B0(wParam, a2, *(HWND *)(a2 + 28), a1, 36867);
      break;
    case 26:
      sub_4564B0(wParam, a2, *(HWND *)(a2 + 28), a1, 256);
      break;
    case 27:
      sub_4564B0(wParam, a2, *(HWND *)(a2 + 28), a1, 257);
      break;
    case 28:
      sub_456C60(a2, wParam, a1);
      break;
    case 29:
      sub_456E00(a2, wParam, a1, 1);
      break;
    case 30:
      sub_456E00(a2, wParam, a1, 0);
      break;
    case 31:
      sub_456060(a2, wParam, a1);
      break;
    case 32:
      sub_455210(wParam, a2, a1);
      break;
    case 35:
      sub_455DC0(a2, wParam, a1);
      break;
    case 36:
      sub_4556E0(a2, wParam, a1);
      break;
    case 37:
      sub_4555C0(a2, wParam, a1);
      break;
    case 38:
      sub_4554A0(a2, wParam, a1);
      break;
    case 39:
      sub_455040(a2, wParam, a1);
      break;
    case 40:
      sub_4574F0(0, a2, wParam, a1);
      break;
    case 41:
      sub_4574F0((void *)1, a2, wParam, a1);
      break;
    case 42:
      sub_4574F0((void *)2, a2, wParam, a1);
      break;
    case 43:
      sub_4574F0((void *)3, a2, wParam, a1);
      break;
    case 44:
      sub_4574F0((void *)4, a2, wParam, a1);
      break;
    case 45:
      sub_4574F0((void *)5, a2, wParam, a1);
      break;
    case 46:
      sub_4574F0((void *)6, a2, wParam, a1);
      break;
    case 47:
      sub_4574F0((void *)7, a2, wParam, a1);
      break;
    case 48:
      sub_4574F0((void *)8, a2, wParam, a1);
      break;
    case 49:
      sub_4574F0((void *)9, a2, wParam, a1);
      break;
    case 50:
      sub_4574F0((void *)0xA, a2, wParam, a1);
      break;
    case 51:
      sub_4574F0((void *)0xB, a2, wParam, a1);
      break;
    case 52:
      sub_4574F0((void *)0xC, a2, wParam, a1);
      break;
    case 53:
      sub_4574F0((void *)0xD, a2, wParam, a1);
      break;
    case 54:
      sub_4574F0((void *)0xE, a2, wParam, a1);
      break;
    case 55:
      sub_4574F0((void *)0xF, a2, wParam, a1);
      break;
    case 56:
      sub_4574F0((void *)0x10, a2, wParam, a1);
      break;
    case 57:
      sub_4574F0((void *)0x11, a2, wParam, a1);
      break;
    case 58:
      sub_4574F0((void *)0x12, a2, wParam, a1);
      break;
    case 59:
      sub_4574F0((void *)0x13, a2, wParam, a1);
      break;
    case 60:
      sub_4574F0((void *)0x14, a2, wParam, a1);
      break;
    case 61:
      sub_4574F0((void *)0x15, a2, wParam, a1);
      break;
    case 62:
      sub_4574F0((void *)0x16, a2, wParam, a1);
      break;
    case 63:
      sub_4574F0((void *)0x17, a2, wParam, a1);
      break;
    case 64:
      sub_455380(a2, wParam, a1);
      break;
    default:
      return;
  }
}
// 4C147C: using guessed type wchar_t aProductname_2[12];
// 4C1494: using guessed type wchar_t aCompanyname_0[12];
// 4C14AC: using guessed type wchar_t aFiledescriptio_0[16];
// 4C14CC: using guessed type wchar_t aFileversion_0[12];
// 4C14E4: using guessed type wchar_t aProductversion_0[15];

//----- (00458930) --------------------------------------------------------
int __stdcall sub_458930(int a1)
{
  LPARAM v1; // ebx
  char **v2; // eax
  char **v3; // edi
  int **v4; // eax
  char *v5; // esi
  char *v6; // eax
  char *v7; // esi
  int pExceptionObject[3]; // [esp+10h] [ebp-2Ch] BYREF
  char **v10[3]; // [esp+1Ch] [ebp-20h] BYREF
  char *v11; // [esp+28h] [ebp-14h] BYREF
  WPARAM wParam[4]; // [esp+2Ch] [ebp-10h] BYREF

  v1 = 0;
  v10[1] = 0;
  v2 = (char **)operator new(0x14u);
  if ( !v2 )
  {
    v11 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v11);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v3 = v2;
  *v2 = (char *)v2;
  v10[0] = v2;
  v2[1] = (char *)v2;
  wParam[3] = 0;
  v4 = *(int ***)(a1 + 964);
  if ( v10 != (char ***)v4 )
  {
    sub_40B820(v10, **v4, (int)*v4, a1);
    v3 = v10[0];
  }
  if ( sub_456330(a1, wParam) )
  {
    while ( !*(_DWORD *)(a1 + 2196) )
    {
      v3 = v10[0];
      v5 = *v10[0];
      if ( *v10[0] != (char *)v10[0] )
      {
        while ( !*(_DWORD *)(a1 + 2196) )
        {
          if ( *((_DWORD *)v5 + 3) )
            sub_4582C0(v1++, a1, *((_DWORD *)v5 + 2), wParam[0]);
          v5 = *(char **)v5;
          v3 = v10[0];
          if ( v5 == (char *)v10[0] )
            goto LABEL_11;
        }
        break;
      }
LABEL_11:
      v1 = 0;
      if ( !sub_456330(a1, wParam) )
        goto LABEL_12;
    }
    v3 = v10[0];
  }
  else
  {
LABEL_12:
    sub_455A40(a1);
  }
  v6 = *v3;
  *v3 = (char *)v3;
  v3[1] = (char *)v3;
  if ( v6 != (char *)v3 )
  {
    do
    {
      v7 = *(char **)v6;
      operator delete(v6);
      v6 = v7;
    }
    while ( v7 != (char *)v3 );
  }
  operator delete(v3);
  return 1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00458A80) --------------------------------------------------------
void __stdcall sub_458A80(ULONG_PTR Parameter)
{
  sub_458930(Parameter);
}

//----- (00458AA0) --------------------------------------------------------
int __thiscall sub_458AA0(_DWORD *this)
{
  return this[180];
}

//----- (00458AB0) --------------------------------------------------------
void __userpurge sub_458AB0(int a1@<esi>, LPCWSTR lpString1)
{
  LPARAM v2; // ebx
  int v3; // eax
  LPARAM v4; // ebx
  int v5; // edx
  unsigned int v6; // ecx
  int v7; // eax
  bool v8; // cf
  HWND v9; // ecx
  WPARAM v10; // eax
  LRESULT v11; // eax
  HWND v12; // [esp-14h] [ebp-64h]
  LPARAM lParam[8]; // [esp+4h] [ebp-4Ch] BYREF
  LPARAM v14; // [esp+24h] [ebp-2Ch]
  LPARAM v15[6]; // [esp+38h] [ebp-18h] BYREF

  v2 = 0;
  if ( *(int *)(a1 + 680) > 0 )
  {
    while ( 1 )
    {
      v12 = *(HWND *)(a1 + 28);
      lParam[0] = 4;
      lParam[1] = v2;
      lParam[2] = 0;
      SendMessageW(v12, 0x104Bu, 0, (LPARAM)lParam);
      v3 = 560 * v14 + *(_DWORD *)(a1 + 52);
      if ( *(_DWORD *)(v3 + 544) )
      {
        if ( !lstrcmpW(lpString1, (LPCWSTR)(v3 + 548)) )
          break;
      }
      if ( ++v2 >= *(_DWORD *)(a1 + 680) )
        return;
    }
    v4 = v14;
    if ( v14 != -1 )
    {
      CoTaskMemFree(*(LPVOID *)(560 * v14 + *(_DWORD *)(a1 + 52)));
      v5 = *(_DWORD *)(a1 + 48);
      v6 = *(_DWORD *)(592 * v4 + v5 + 32);
      v7 = *(_DWORD *)(592 * v4 + v5 + 28);
      v8 = *(_DWORD *)(a1 + 608) < v6;
      *(_DWORD *)(a1 + 608) -= v6;
      v9 = *(HWND *)(a1 + 28);
      v15[0] = 1;
      *(_DWORD *)(a1 + 612) -= v8 + v7;
      v15[2] = v4;
      v10 = SendMessageW(v9, 0x1053u, 0xFFFFFFFF, (LPARAM)v15);
      if ( v10 != -1 )
        SendMessageW(*(HWND *)(a1 + 28), 0x1008u, v10, 0);
      *(_DWORD *)(*(_DWORD *)(a1 + 720) + 4 * v4) = 0;
      v11 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
      --*(_DWORD *)(a1 + 680);
      if ( !v11 && !*(_DWORD *)(a1 + 2188) )
        SendMessageW(*(HWND *)(a1 + 32), 0x80C9u, *(_DWORD *)(a1 + 776), 1);
    }
  }
}

//----- (00458C00) --------------------------------------------------------
int __thiscall sub_458C00(_DWORD *this)
{
  return this[7];
}

//----- (00458C10) --------------------------------------------------------
BOOL __thiscall sub_458C10(_DWORD *this)
{
  BOOL result; // eax

  result = this[187] == 0;
  this[187] = result;
  return result;
}

//----- (00458C30) --------------------------------------------------------
int __thiscall sub_458C30(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[187] = a2;
  return result;
}

//----- (00458C40) --------------------------------------------------------
int __thiscall sub_458C40(_DWORD *this)
{
  return this[187];
}

//----- (00458C50) --------------------------------------------------------
int __thiscall sub_458C50(_DWORD *this)
{
  return this[182];
}

//----- (00458C60) --------------------------------------------------------
int __thiscall sub_458C60(_DWORD *this)
{
  return this[184];
}

//----- (00458C70) --------------------------------------------------------
int __thiscall sub_458C70(_DWORD *this)
{
  return this[184];
}

//----- (00458C80) --------------------------------------------------------
int __thiscall sub_458C80(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[184] = a2;
  return result;
}

//----- (00458C90) --------------------------------------------------------
BOOL __thiscall sub_458C90(_DWORD *this)
{
  BOOL result; // eax

  result = this[184] == 0;
  this[184] = result;
  return result;
}

//----- (00458CB0) --------------------------------------------------------
int __thiscall sub_458CB0(_DWORD *this)
{
  return this[546];
}

//----- (00458CC0) --------------------------------------------------------
int __thiscall sub_458CC0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[546] = a2;
  return result;
}

//----- (00458CD0) --------------------------------------------------------
int __thiscall sub_458CD0(_DWORD *this)
{
  return this[545];
}

//----- (00458CE0) --------------------------------------------------------
_DWORD *__thiscall sub_458CE0(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = this[150];
  a2[1] = this[151];
  a2[2] = this[152];
  a2[3] = this[153];
  return result;
}

//----- (00458D10) --------------------------------------------------------
int __thiscall sub_458D10(_DWORD *this)
{
  return this[170] + this[171];
}

//----- (00458D20) --------------------------------------------------------
int __thiscall sub_458D20(_DWORD *this)
{
  return this[171];
}

//----- (00458D30) --------------------------------------------------------
int __thiscall sub_458D30(_DWORD *this)
{
  return this[170];
}

//----- (00458D40) --------------------------------------------------------
int __thiscall sub_458D40(_DWORD *this)
{
  return this[168];
}

//----- (00458E00) --------------------------------------------------------
int __thiscall sub_458E00(_DWORD *this, WPARAM wParam)
{
  HWND v4; // [esp-10h] [ebp-84h]
  HWND v5; // [esp-10h] [ebp-84h]
  LPARAM v6[13]; // [esp+Ch] [ebp-68h] BYREF
  LPARAM lParam[13]; // [esp+40h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam) )
  {
    if ( (*(_BYTE *)(592 * lParam[8] + this[10]) & 2) != 0 )
      return 0;
    v5 = (HWND)this[5];
    v6[4] = 4;
    v6[3] = 0;
    SendMessageW(v5, 0x102Bu, wParam, (LPARAM)v6);
  }
  return 1;
}

//----- (00458E90) --------------------------------------------------------
int __thiscall sub_458E90(_DWORD *this, WPARAM wParam)
{
  HWND v4; // [esp-10h] [ebp-84h]
  HWND v5; // [esp-10h] [ebp-84h]
  LPARAM v6[13]; // [esp+Ch] [ebp-68h] BYREF
  LPARAM lParam[13]; // [esp+40h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  if ( SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam) )
  {
    if ( (*(_BYTE *)(592 * lParam[8] + this[10]) & 2) != 0 )
      return 0;
    v5 = (HWND)this[5];
    v6[4] = 4;
    v6[3] = 4;
    SendMessageW(v5, 0x102Bu, wParam, (LPARAM)v6);
  }
  return 1;
}

//----- (00458F10) --------------------------------------------------------
int __thiscall sub_458F10(_DWORD *this, LPARAM a2)
{
  HWND v4; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam) )
    return *(_DWORD *)(560 * lParam[8] + this[11] + 524);
  else
    return 0;
}

//----- (00458F70) --------------------------------------------------------
int __thiscall sub_458F70(_DWORD *this)
{
  int result; // eax
  int v2; // edi
  _DWORD *v3; // edx
  _DWORD *v4; // edx

  result = this[175];
  if ( result >= this[174] )
  {
LABEL_5:
    result = 0;
    if ( (int)this[175] <= 0 )
    {
LABEL_9:
      this[175] = 0;
      return -1;
    }
    else
    {
      v4 = (_DWORD *)this[180];
      while ( *v4 )
      {
        ++result;
        ++v4;
        if ( result >= this[175] )
          goto LABEL_9;
      }
      *(_DWORD *)(this[180] + 4 * result) = 1;
      this[175] = result;
    }
  }
  else
  {
    v2 = this[180];
    v3 = (_DWORD *)(v2 + 4 * result);
    while ( *v3 )
    {
      ++result;
      ++v3;
      if ( result >= this[174] )
        goto LABEL_5;
    }
    *(_DWORD *)(v2 + 4 * result) = 1;
    this[175] = result;
  }
  return result;
}

//----- (00459000) --------------------------------------------------------
int __thiscall sub_459000(_DWORD *this)
{
  return this[175];
}

//----- (00459010) --------------------------------------------------------
int __thiscall sub_459010(_DWORD *this)
{
  return this[174];
}

//----- (00459020) --------------------------------------------------------
int __thiscall sub_459020(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[175] = a2;
  return result;
}

//----- (00459030) --------------------------------------------------------
int __thiscall sub_459030(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[174] = a2;
  return result;
}

//----- (00459040) --------------------------------------------------------
BOOL __thiscall sub_459040(int this, LPARAM a2)
{
  HWND v4; // [esp-10h] [ebp-54h]
  LPARAM lParam[13]; // [esp+4h] [ebp-40h] BYREF
  int v6; // [esp+38h] [ebp-Ch] BYREF
  LPVOID pv; // [esp+3Ch] [ebp-8h] BYREF
  IShellFolder *ppshf; // [esp+40h] [ebp-4h] BYREF

  ppshf = 0;
  pv = 0;
  lParam[2] = 0;
  v4 = *(HWND *)(this + 20);
  v6 = 32;
  lParam[0] = 4;
  lParam[1] = a2;
  SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam);
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    pv = ILCombine(*(LPCITEMIDLIST *)(this + 68), *(LPCITEMIDLIST *)(560 * lParam[8] + *(_DWORD *)(this + 44)));
    ppshf->lpVtbl->GetAttributesOf(ppshf, 1, (LPCITEMIDLIST *)&pv, (SFGAOF *)&v6);
    ppshf->lpVtbl->Release(ppshf);
    CoTaskMemFree(pv);
  }
  return (v6 & 0x20) == 32;
}

//----- (004590F0) --------------------------------------------------------
int __thiscall sub_4590F0(_DWORD *this)
{
  return this[158];
}

//----- (00459100) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_459100(_DWORD *this, LPARAM a2)
{
  HWND v4; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam) )
    return ILClone(*(LPCITEMIDLIST *)(560 * lParam[8] + this[11]));
  else
    return 0;
}

//----- (00459190) --------------------------------------------------------
int __thiscall sub_459190(_DWORD *this, LPARAM a2)
{
  HWND v4; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam);
  return this[10] + 592 * lParam[8];
}

//----- (004591E0) --------------------------------------------------------
int __thiscall sub_4591E0(_DWORD *this, LPARAM a2)
{
  HWND v4; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v4 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam);
  return *(_DWORD *)(592 * lParam[8] + this[10]);
}

//----- (00459230) --------------------------------------------------------
int __userpurge sub_459230@<eax>(_DWORD *a1@<esi>, LPCWSTR lpString2)
{
  LPARAM v2; // edi
  HWND v4; // [esp-10h] [ebp-4Ch]
  LPARAM lParam[8]; // [esp+8h] [ebp-34h] BYREF
  int v6; // [esp+28h] [ebp-14h]

  v2 = 0;
  if ( (int)a1[170] <= 0 )
    return -1;
  while ( 1 )
  {
    v4 = (HWND)a1[7];
    lParam[0] = 4;
    lParam[1] = v2;
    lParam[2] = 0;
    SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam);
    if ( !lstrcmpW((LPCWSTR)(592 * v6 + a1[12] + 44), lpString2)
      || !lstrcmpW((LPCWSTR)(592 * v6 + a1[12] + 564), lpString2) )
    {
      break;
    }
    if ( ++v2 >= a1[170] )
      return -1;
  }
  return v6;
}

//----- (004592D0) --------------------------------------------------------
LRESULT __thiscall sub_4592D0(_DWORD *this, LPCWSTR lpString2)
{
  int v3; // eax
  HWND v5; // [esp-10h] [ebp-30h]
  LPARAM lParam[6]; // [esp+8h] [ebp-18h] BYREF

  v3 = sub_459230(this - 2, lpString2);
  if ( v3 == -1 )
    return -1;
  v5 = (HWND)this[5];
  lParam[0] = 1;
  lParam[2] = v3;
  return SendMessageW(v5, 0x1053u, 0xFFFFFFFF, (LPARAM)lParam);
}

//----- (00459320) --------------------------------------------------------
int __thiscall sub_459320(_DWORD *this)
{
  return this[186];
}

//----- (00459330) --------------------------------------------------------
int __stdcall sub_459330(int a1, int a2, int a3)
{
  return 0;
}

//----- (00459340) --------------------------------------------------------
int __thiscall sub_459340(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 36))(this[12]);
}

//----- (00459350) --------------------------------------------------------
int __thiscall sub_459350(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 40))(this[12]);
}

//----- (00459360) --------------------------------------------------------
int __thiscall sub_459360(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 28))(this[12]);
}

//----- (00459370) --------------------------------------------------------
int __thiscall sub_459370(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 24))(this[12]);
}

//----- (00459380) --------------------------------------------------------
BOOL __thiscall sub_459380(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 16))(this[12]) != 0;
}

//----- (004593A0) --------------------------------------------------------
BOOL __thiscall sub_4593A0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[12] + 12))(this[12]) != 0;
}

//----- (004593C0) --------------------------------------------------------
int __thiscall sub_4593C0(_DWORD **this, int a2, _DWORD *a3, int a4, int a5)
{
  int v6; // eax

  v6 = (*(int (__thiscall **)(_DWORD *, int, int, int))(*this[12] + 20))(this[12], a2, a4, a5);
  if ( !v6 )
    return -2147467259;
  if ( a5 )
    v6 = -v6;
  *a3 = (*(int (__thiscall **)(_DWORD *, int))(*this[12] + 36))(this[12], v6);
  return 0;
}

//----- (00459410) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_459410(LPCITEMIDLIST *this)
{
  return ILClone(this[17]);
}

//----- (00459420) --------------------------------------------------------
BOOL __thiscall sub_459420(int this, int a2, int a3)
{
  _DWORD *v3; // esi
  BOOL result; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi

  v3 = (_DWORD *)(*(_DWORD *)(this + 40) + 592 * a2);
  result = (*v3 & 0x10) == 16;
  v5 = v3[8];
  v6 = v3[7];
  if ( a3 )
  {
    if ( result )
      ++*(_DWORD *)(this + 684);
    else
      ++*(_DWORD *)(this + 680);
    *(_QWORD *)(this + 608) += __PAIR64__(v6, v5);
  }
  else
  {
    if ( result )
      --*(_DWORD *)(this + 684);
    else
      --*(_DWORD *)(this + 680);
    *(_QWORD *)(this + 608) -= __PAIR64__(v6, v5);
  }
  return result;
}

//----- (004594B0) --------------------------------------------------------
int __thiscall sub_4594B0(_DWORD *this, int a2)
{
  this[154] = a2;
  return 0;
}

//----- (004594D0) --------------------------------------------------------
int __thiscall sub_4594D0(_DWORD *this, PCWSTR psz1, int a3)
{
  int v4; // ebx
  int v5; // esi

  v4 = 0;
  if ( StrCmpW(psz1, (PCWSTR)(this[9] + 44)) )
  {
    v5 = 0;
    do
    {
      v5 += 592;
      ++v4;
    }
    while ( StrCmpW(psz1, (PCWSTR)(this[9] + v5 + 44)) );
  }
  if ( (*(_BYTE *)(592 * v4 + this[9]) & 2) != 0 )
    *(_DWORD *)a3 &= 0x8000u;
  return 0;
}

//----- (00459530) --------------------------------------------------------
int __thiscall sub_459530(_DWORD *this, LPARAM a2)
{
  HWND v3; // ecx
  LPARAM lParam[13]; // [esp+8h] [ebp-34h] BYREF

  if ( a2 == -1 )
    return 0;
  v3 = (HWND)this[5];
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( !SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam) )
    return 0;
  else
    return this[10] + 592 * lParam[8];
}

//----- (00459590) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_459590(int this, LPCITEMIDLIST pidl)
{
  const ITEMIDLIST *v2; // ebx
  WPARAM v4; // edi
  ITEMIDLIST *v5; // ebx
  LPITEMIDLIST result; // eax
  HWND v7; // [esp-10h] [ebp-26Ch]
  LPARAM lParam[13]; // [esp+Ch] [ebp-250h] BYREF
  LRESULT v9; // [esp+40h] [ebp-21Ch]
  int v10; // [esp+44h] [ebp-218h]
  IShellFolder *ppshf; // [esp+48h] [ebp-214h] BYREF
  const ITEMIDLIST *v12; // [esp+4Ch] [ebp-210h]
  __int16 v13[260]; // [esp+50h] [ebp-20Ch] BYREF

  v2 = pidl;
  v12 = pidl;
  sub_466630(pidl, (WCHAR *)v13, 1);
  v4 = 0;
  v9 = SendMessageW(*(HWND *)(this + 20), 0x1004u, 0, 0);
  if ( v9 <= 0 )
  {
LABEL_10:
    *(_DWORD *)(this + 836) = 1;
    result = ILClone(v2);
    *(_DWORD *)(this + 840) = result;
  }
  else
  {
    while ( 1 )
    {
      v7 = *(HWND *)(this + 20);
      lParam[0] = 4;
      lParam[1] = v4;
      lParam[2] = 0;
      SendMessageW(v7, 0x104Bu, 0, (LPARAM)lParam);
      v5 = ILCombine(*(LPCITEMIDLIST *)(this + 68), *(LPCITEMIDLIST *)(560 * lParam[8] + *(_DWORD *)(this + 44)));
      if ( v12 )
      {
        if ( v5 )
        {
          ppshf = 0;
          v10 = 0;
          if ( SHGetDesktopFolder(&ppshf) >= 0 )
          {
            if ( !(unsigned __int16)ppshf->lpVtbl->CompareIDs(ppshf, 0, v12, v5) )
              v10 = 1;
            ppshf->lpVtbl->Release(ppshf);
            if ( v10 )
              break;
          }
        }
      }
      CoTaskMemFree(v5);
      if ( (int)++v4 >= v9 )
      {
        v2 = v12;
        goto LABEL_10;
      }
    }
    CoTaskMemFree(v5);
    return (LPITEMIDLIST)SendMessageW(*(HWND *)(this + 20), 0x1076u, v4, 0);
  }
  return result;
}
// 459590: using guessed type WCHAR var_20C[260];

//----- (00459720) --------------------------------------------------------
int __thiscall sub_459720(_DWORD *this)
{
  HWND v2; // ebx
  BOOL v3; // edi
  LONG WindowLongW; // eax

  v2 = (HWND)this[5];
  v3 = this[182] == 0;
  this[182] = v3;
  WindowLongW = GetWindowLongW(v2, -16);
  if ( v3 )
  {
    if ( (WindowLongW & 0x100) == 0 )
    {
      SetWindowLongW(v2, -16, WindowLongW | 0x100);
      return this[182];
    }
  }
  else if ( (WindowLongW & 0x100) != 0 )
  {
    WindowLongW &= ~0x100u;
  }
  SetWindowLongW(v2, -16, WindowLongW);
  return this[182];
}

//----- (00459790) --------------------------------------------------------
BOOL __fastcall sub_459790(int csidl, int a2)
{
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(csidl, psz2);
  return StrCmpW((PCWSTR)(a2 + 88), psz2) == 0;
}

//----- (004597E0) --------------------------------------------------------
int __thiscall sub_4597E0(const ITEMIDLIST **this)
{
  int v1; // esi
  LPITEMIDLIST ppidl; // [esp+8h] [ebp-4h] BYREF

  v1 = 0;
  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
  {
    if ( (*(int (__thiscall **)(const ITEMIDLIST **))&(*this)[48].mkid.cb)(this) && !sub_466190(this[17], ppidl) )
    {
      CoTaskMemFree(ppidl);
      return 0;
    }
    v1 = 1;
    CoTaskMemFree(ppidl);
  }
  return v1;
}

//----- (00459850) --------------------------------------------------------
_DWORD *__thiscall sub_459850(_DWORD *this)
{
  _DWORD **v2; // ecx
  _DWORD *result; // eax
  _DWORD *v4; // edi

  v2 = (_DWORD **)this[270];
  result = *v2;
  *v2 = v2;
  *(_DWORD *)(this[270] + 4) = this[270];
  this[271] = 0;
  if ( result != (_DWORD *)this[270] )
  {
    do
    {
      v4 = (_DWORD *)*result;
      operator delete(result);
      result = v4;
    }
    while ( v4 != (_DWORD *)this[270] );
  }
  this[277] = 0;
  return result;
}

//----- (004598B0) --------------------------------------------------------
int __thiscall sub_4598B0(HWND *this, int a2)
{
  WPARAM v3; // edi
  HWND v4; // ecx
  LPARAM lParam[3]; // [esp+8h] [ebp-34h] BYREF
  int v7; // [esp+14h] [ebp-28h]
  int v8; // [esp+18h] [ebp-24h]

  v3 = (*((int (__thiscall **)(HWND *, int))*this + 45))(this, a2);
  if ( v3 == -1 )
    return 0;
  v4 = this[5];
  v8 = 1;
  v7 = 1;
  SendMessageW(v4, 0x102Bu, v3, (LPARAM)lParam);
  v8 = 2;
  v7 = 2;
  SendMessageW(this[5], 0x102Bu, v3, (LPARAM)lParam);
  SendMessageW(this[5], 0x1013u, v3, 0);
  return 1;
}

//----- (00459940) --------------------------------------------------------
BOOL __thiscall sub_459940(_DWORD *this)
{
  const ITEMIDLIST *v1; // edi
  int v2; // esi
  LPITEMIDLIST ppidl; // [esp+8h] [ebp-4h] BYREF

  v1 = (const ITEMIDLIST *)this[17];
  v2 = 0;
  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
  {
    v2 = sub_466190(v1, ppidl);
    CoTaskMemFree(ppidl);
  }
  return v2 == 0;
}

//----- (004599D0) --------------------------------------------------------
int __thiscall sub_4599D0(int this, LPARAM a2, WCHAR *a3)
{
  HWND v4; // edx
  ITEMIDLIST *v5; // edi
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v4 = *(HWND *)(this + 20);
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( !SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam) )
    return -2147467259;
  v5 = ILCombine(*(LPCITEMIDLIST *)(this + 68), *(LPCITEMIDLIST *)(560 * lParam[8] + *(_DWORD *)(this + 44)));
  sub_466630(v5, a3, 0x8000);
  CoTaskMemFree(v5);
  return 0;
}

//----- (00459A90) --------------------------------------------------------
char **__thiscall sub_459A90(_DWORD **this, int a2)
{
  char **result; // eax
  _DWORD *v3; // ebx
  char **v4; // edi
  unsigned int v5; // eax
  int v6; // eax
  char *v7; // esi
  char *v8; // ecx
  char *v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-10h] [ebp-18h]
  _DWORD **v11; // [esp+4h] [ebp-4h]

  result = (char **)*this[239];
  v3 = *result;
  v11 = this;
  if ( *result != (char *)result )
  {
    v4 = (char **)a2;
    do
    {
      if ( v3[3] )
      {
        v5 = v3[2] - 1;
        if ( v5 > 0x26 )
          v6 = 0;
        else
          v6 = sub_454DC0(v5);
        v7 = *v4;
        v10 = *((_DWORD *)*v4 + 1);
        v9 = *v4;
        a2 = v6;
        result = sub_40A550(v9, v10, (int)&a2);
        v8 = v4[1];
        if ( v8 == (char *)1073741822 )
          std::vector<void *>::_Xlen(a2);
        v4[1] = v8 + 1;
        *((_DWORD *)v7 + 1) = result;
        *(_DWORD *)result[1] = result;
        this = v11;
      }
      v3 = (_DWORD *)*v3;
    }
    while ( v3 != (_DWORD *)*this[239] );
  }
  return result;
}
// 459B0E: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (00459B20) --------------------------------------------------------
unsigned int __usercall sub_459B20@<eax>(int a1@<ebx>)
{
  unsigned int result; // eax
  BOOL v2; // eax
  int v3; // ecx
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(3, psz2);
  result = StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( result )
  {
    sub_4664A0(17, psz2);
    result = StrCmpW((PCWSTR)(a1 + 88), psz2);
    if ( result )
    {
      sub_4664A0(10, psz2);
      result = StrCmpW((PCWSTR)(a1 + 88), psz2);
      if ( result )
      {
        sub_4664A0(4, psz2);
        result = StrCmpW((PCWSTR)(a1 + 88), psz2);
        if ( result )
        {
          v2 = sub_459790(49, a1);
          v3 = *(_DWORD *)(a1 + 632);
          if ( v2 )
          {
            result = 0;
            while ( v3 != *(int *)((char *)&dword_4C190C + result) )
            {
              result += 4;
              if ( result >= 0x10 )
                goto LABEL_25;
            }
          }
          else
          {
            result = 0;
            while ( v3 != *(int *)((char *)&dword_4C1868 + result) )
            {
              result += 4;
              if ( result >= 0x6C )
              {
LABEL_25:
                *(_DWORD *)(a1 + 632) = 1;
                return result;
              }
            }
          }
        }
        else
        {
          while ( *(_DWORD *)(a1 + 632) != *(int *)((char *)&dword_4C1854 + result) )
          {
            result += 4;
            if ( result >= 0x14 )
              goto LABEL_25;
          }
        }
      }
      else
      {
        while ( *(_DWORD *)(a1 + 632) != *(int *)((char *)&dword_4C18F4 + result) )
        {
          result += 4;
          if ( result >= 0x18 )
            goto LABEL_25;
        }
      }
    }
    else
    {
      while ( *(_DWORD *)(a1 + 632) != *(int *)((char *)&dword_4C18DC + result) )
      {
        result += 4;
        if ( result >= 0x18 )
          goto LABEL_25;
      }
    }
  }
  else
  {
    while ( *(_DWORD *)(a1 + 632) != *(int *)((char *)&dword_4C18D4 + result) )
    {
      result += 4;
      if ( result >= 8 )
        goto LABEL_25;
    }
  }
  return result;
}
// 4C1854: using guessed type int dword_4C1854;
// 4C1868: using guessed type int dword_4C1868;
// 4C18D4: using guessed type int dword_4C18D4;
// 4C18DC: using guessed type int dword_4C18DC;
// 4C18F4: using guessed type int dword_4C18F4;
// 4C190C: using guessed type int dword_4C190C;

//----- (00459C90) --------------------------------------------------------
int __thiscall sub_459C90(void *this, _WORD *a2, unsigned int a3)
{
  int result; // eax

  result = a3;
  if ( a3 )
  {
    if ( a3 <= 0x7FFFFFFF )
      return sub_4A96F0(a3, (int)this + 1156, a2);
  }
  return result;
}

//----- (00459CC0) --------------------------------------------------------
int __usercall sub_459CC0@<eax>(int a1@<edi>)
{
  int result; // eax
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(10, psz2);
  result = StrCmpW((PCWSTR)(a1 + 88), psz2);
  if ( result )
  {
    sub_4664A0(0, psz2);
    result = StrCmpW((PCWSTR)(a1 + 88), psz2);
    if ( !result )
      *(_DWORD *)(a1 + 640) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 640) = 1;
  }
  return result;
}

//----- (00459D50) --------------------------------------------------------
char **__userpurge sub_459D50@<eax>(WPARAM a1@<ebx>, int a2@<esi>, int a3)
{
  int v3; // edi
  int v4; // eax
  int v5; // edi
  unsigned int v6; // ecx
  int v7; // eax
  bool v8; // cf
  HWND v9; // ecx
  int v10; // edi
  char **result; // eax
  int v12; // ecx

  v3 = a3;
  if ( SendMessageW(*(HWND *)(a2 + 28), 0x102Cu, a1, 2) == 2 )
    *(_QWORD *)(a2 + 616) -= __PAIR64__(
                               *(_DWORD *)(592 * v3 + *(_DWORD *)(a2 + 48) + 28),
                               *(_DWORD *)(592 * v3 + *(_DWORD *)(a2 + 48) + 32));
  v4 = *(_DWORD *)(a2 + 48);
  v5 = 592 * v3;
  v6 = *(_DWORD *)(v4 + v5 + 32);
  v7 = *(_DWORD *)(v4 + v5 + 28);
  v8 = *(_DWORD *)(a2 + 608) < v6;
  *(_DWORD *)(a2 + 608) -= v6;
  v9 = *(HWND *)(a2 + 28);
  *(_DWORD *)(a2 + 612) -= v8 + v7;
  SendMessageW(v9, 0x1008u, a1, 0);
  --*(_DWORD *)(a2 + 680);
  v10 = *(_DWORD *)(a2 + 1152);
  result = sub_40A550((char *)v10, *(_DWORD *)(v10 + 4), (int)&a3);
  v12 = *(_DWORD *)(a2 + 1156);
  if ( v12 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a2 + 1156) = v12 + 1;
  *(_DWORD *)(v10 + 4) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (00459E10) --------------------------------------------------------
void __thiscall sub_459E10(int this)
{
  _DWORD **v2; // ecx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  HWND v5; // edi
  LONG WindowLongW; // eax
  void **v7; // eax
  LPARAM *v8; // ebx
  WPARAM v9; // eax
  LPARAM v10; // ebx
  int v11; // ebx
  WPARAM v12; // ebx
  WPARAM v13; // eax
  WPARAM v14; // eax
  WPARAM v15; // eax
  int v16; // eax
  WPARAM v17; // eax
  LPARAM v18; // ecx
  void *v19; // eax
  HWND v20; // esi
  LONG v21; // eax
  HWND v22; // [esp-10h] [ebp-D8h]
  HWND v23; // [esp-10h] [ebp-D8h]
  HWND v24; // [esp-10h] [ebp-D8h]
  HWND v25; // [esp-10h] [ebp-D8h]
  HWND v26; // [esp-10h] [ebp-D8h]
  HWND v27; // [esp-10h] [ebp-D8h]
  HWND v28; // [esp-10h] [ebp-D8h]
  HWND v29; // [esp-10h] [ebp-D8h]
  HWND v30; // [esp-10h] [ebp-D8h]
  LPARAM v31[3]; // [esp+Ch] [ebp-BCh] BYREF
  int v32; // [esp+18h] [ebp-B0h]
  int v33; // [esp+1Ch] [ebp-ACh]
  LPARAM v34[2]; // [esp+40h] [ebp-88h] BYREF
  LPARAM v35[2]; // [esp+48h] [ebp-80h] BYREF
  LPARAM v36[2]; // [esp+50h] [ebp-78h] BYREF
  LPARAM lParam[2]; // [esp+58h] [ebp-70h] BYREF
  LPARAM v38[3]; // [esp+60h] [ebp-68h] BYREF
  int v39; // [esp+6Ch] [ebp-5Ch]
  LPARAM v40; // [esp+70h] [ebp-58h]
  int v41; // [esp+74h] [ebp-54h]
  LPARAM v42; // [esp+78h] [ebp-50h] BYREF
  LPARAM v43; // [esp+7Ch] [ebp-4Ch]
  int v44; // [esp+80h] [ebp-48h]
  LPARAM v45; // [esp+88h] [ebp-40h]
  LRESULT v46; // [esp+8Ch] [ebp-3Ch]
  BOOL v47; // [esp+90h] [ebp-38h]
  WPARAM v48; // [esp+94h] [ebp-34h]
  void *v49; // [esp+98h] [ebp-30h]
  WPARAM v50; // [esp+9Ch] [ebp-2Ch]
  LPARAM v51[2]; // [esp+A0h] [ebp-28h] BYREF
  char v52; // [esp+A8h] [ebp-20h]
  WPARAM wParam; // [esp+ACh] [ebp-1Ch]
  LPARAM v54[2]; // [esp+B4h] [ebp-14h] BYREF
  int v55; // [esp+BCh] [ebp-Ch]
  LPARAM v56; // [esp+C0h] [ebp-8h]

  if ( *(_DWORD *)(this + 636) == 4 )
  {
    v2 = *(_DWORD ***)(this + 1076);
    v3 = *v2;
    *v2 = v2;
    *(_DWORD *)(*(_DWORD *)(this + 1076) + 4) = *(_DWORD *)(this + 1076);
    *(_DWORD *)(this + 1080) = 0;
    if ( v3 != *(_DWORD **)(this + 1076) )
    {
      do
      {
        v4 = (_DWORD *)*v3;
        operator delete(v3);
        v3 = v4;
      }
      while ( v4 != *(_DWORD **)(this + 1076) );
    }
  }
  else if ( *(_DWORD *)(this + 1080) )
  {
    if ( *(_DWORD *)(this + 736) )
    {
      v5 = *(HWND *)(this + 28);
      WindowLongW = GetWindowLongW(v5, -16);
      if ( (WindowLongW & 0x100) != 0 )
        WindowLongW &= ~0x100u;
      SetWindowLongW(v5, -16, WindowLongW);
    }
    v7 = *(void ***)(this + 1076);
    v8 = (LPARAM *)*v7;
    v49 = v8;
    if ( v8 != (LPARAM *)v7 )
    {
      while ( 1 )
      {
        v9 = (*(int (__thiscall **)(int, LPARAM *))(*(_DWORD *)(this + 8) + 180))(this + 8, v8 + 2);
        v48 = v9;
        if ( v9 == -1 )
        {
          v49 = (void *)*v8;
        }
        else
        {
          *(_DWORD *)(this + 724) = v9;
          if ( *(_DWORD *)(this + 736) )
          {
            v10 = v8[132];
            v44 = 0;
            v47 = 0;
            v22 = *(HWND *)(this + 28);
            v45 = *((_DWORD *)v49 + 133);
            SendMessageW(v22, 0x1029u, 0, (LPARAM)lParam);
            v11 = v10 - lParam[0];
            v45 -= lParam[1];
            v51[1] = v45;
            v23 = *(HWND *)(this + 28);
            v51[0] = v11;
            v50 = SendMessageW(v23, 0x1012u, 0, (LPARAM)v51);
            if ( v50 == -1 || (v52 & 0xE) == 0 )
            {
              v25 = *(HWND *)(this + 28);
              v38[0] = 64;
              v39 = v11;
              v40 = v45;
              v41 = 38;
              v14 = SendMessageW(v25, 0x1053u, 0xFFFFFFFF, (LPARAM)v38);
              v50 = v14;
              if ( v14 == -1 )
              {
                v26 = *(HWND *)(this + 28);
                v38[0] = 64;
                v39 = v11;
                v40 = v45;
                v41 = 37;
                v14 = SendMessageW(v26, 0x1053u, 0xFFFFFFFF, (LPARAM)v38);
                v50 = v14;
              }
              v27 = *(HWND *)(this + 28);
              v54[0] = 0;
              SendMessageW(v27, 0x100Eu, v14, (LPARAM)v54);
              if ( v11 > v54[0] + (v55 - v54[0]) / 2 )
              {
                if ( v45 > v56 )
                {
                  v15 = SendMessageW(*(HWND *)(this + 28), 0x100Cu, v50, 512);
                  if ( v15 != -1 )
                    v50 = v15;
                }
                v44 = 1;
              }
              v46 = SendMessageW(*(HWND *)(this + 28), 0x1004u, 0, 0);
              v28 = *(HWND *)(this + 28);
              v54[0] = 0;
              SendMessageW(v28, 0x100Eu, v46 - 1, (LPARAM)v54);
              v16 = (v55 - v54[0]) / 2;
              if ( v11 <= v16 + v54[0] || v11 >= v16 + v55 + 2 || v45 <= v54[1] )
              {
                if ( !v44 )
                {
                  v17 = SendMessageW(*(HWND *)(this + 28), 0x100Cu, v50, 1024);
                  if ( v17 == -1 )
                    v47 = 1;
                  else
                    v50 = v17;
                }
              }
              else
              {
                v50 = v46 - 1;
              }
            }
            else
            {
              v24 = *(HWND *)(this + 28);
              v54[0] = 0;
              SendMessageW(v24, 0x100Eu, wParam, (LPARAM)v54);
              if ( v11 - v54[0] <= (v55 - v54[0]) / 2 )
              {
                v12 = v50;
                v13 = SendMessageW(*(HWND *)(this + 28), 0x100Cu, v50, 1024);
                v50 = v13;
                if ( v13 == -1 )
                {
                  v50 = v12;
                  v13 = v12;
                }
                v47 = SendMessageW(*(HWND *)(this + 28), 0x100Cu, v13, 1024) == -1;
              }
            }
            SendMessageW(*(HWND *)(this + 28), 0x1010u, v50, (LPARAM)&v42);
            if ( v47 )
            {
              v36[1] = v43;
              v29 = *(HWND *)(this + 28);
              v36[0] = 0;
              SendMessageW(v29, 0x1031u, v48, (LPARAM)v36);
            }
            else
            {
              v34[0] = v42 + 1;
              v34[1] = v43;
              SendMessageW(*(HWND *)(this + 28), 0x1031u, v48, (LPARAM)v34);
            }
            v8 = (LPARAM *)v49;
          }
          else
          {
            v18 = v8[133];
            v35[0] = v8[132];
            v30 = *(HWND *)(this + 28);
            v35[1] = v18;
            SendMessageW(v30, 0x1031u, v9, (LPARAM)v35);
          }
          v33 = 2;
          v32 = 2;
          SendMessageW(*(HWND *)(this + 28), 0x102Bu, v48, (LPARAM)v31);
          v33 = 1;
          v32 = 1;
          SendMessageW(*(HWND *)(this + 28), 0x102Bu, v48, (LPARAM)v31);
          v19 = (void *)*v8;
          v46 = *v8;
          if ( v8 != *(LPARAM **)(this + 1076) )
          {
            *(_DWORD *)v8[1] = v19;
            *(_DWORD *)(*v8 + 4) = v8[1];
            operator delete(v8);
            v19 = (void *)v46;
            --*(_DWORD *)(this + 1080);
          }
          v49 = v19;
        }
        if ( v49 == *(void **)(this + 1076) )
          break;
        v8 = (LPARAM *)v49;
      }
    }
    if ( *(_DWORD *)(this + 736) )
    {
      v20 = *(HWND *)(this + 28);
      v21 = GetWindowLongW(v20, -16);
      if ( (v21 & 0x100) == 0 )
        v21 |= 0x100u;
      SetWindowLongW(v20, -16, v21);
    }
  }
}

//----- (0045A280) --------------------------------------------------------
int __usercall sub_45A280@<eax>(void *a1@<eax>, _DWORD *a2@<ecx>)
{
  char *v5; // esi
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  void *v9; // edx

  EnterCriticalSection(&stru_4EF488);
  if ( a1 )
    SetEvent(a1);
  if ( dword_4EF78C )
  {
    v5 = (char *)*((_DWORD *)dword_4EF788 + 1);
    v6 = *((_DWORD *)v5 + 3);
    v7 = *((_DWORD *)v5 + 4);
    *a2 = *((_DWORD *)v5 + 2);
    v8 = *((_DWORD *)v5 + 5);
    a2[1] = v6;
    v9 = (void *)*((_DWORD *)v5 + 6);
    a2[2] = v7;
    a2[3] = v8;
    a2[4] = v9;
    ResetEvent(v9);
    if ( v5 != dword_4EF788 )
    {
      **((_DWORD **)v5 + 1) = *(_DWORD *)v5;
      *(_DWORD *)(*(_DWORD *)v5 + 4) = *((_DWORD *)v5 + 1);
      operator delete(v5);
      --dword_4EF78C;
    }
    LeaveCriticalSection(&stru_4EF488);
    return 1;
  }
  else
  {
    ++dword_4EF480;
    dword_4EF484 = 1;
    LeaveCriticalSection(&stru_4EF488);
    return 0;
  }
}
// 4EF480: using guessed type int dword_4EF480;
// 4EF484: using guessed type int dword_4EF484;
// 4EF78C: using guessed type int dword_4EF78C;

//----- (0045A340) --------------------------------------------------------
void __stdcall sub_45A340(int a1)
{
  char *v1; // eax
  char *v2; // esi
  char *v3; // edi

  EnterCriticalSection(&stru_4EF488);
  v1 = dword_4EF788;
  v2 = *(char **)dword_4EF788;
  while ( v2 != v1 )
  {
    if ( *((_DWORD *)v2 + 2) == *(_DWORD *)(a1 + 28) )
    {
      CoTaskMemFree(*((LPVOID *)v2 + 3));
      v1 = dword_4EF788;
      v3 = *(char **)v2;
      if ( v2 != dword_4EF788 )
      {
        **((_DWORD **)v2 + 1) = v3;
        *(_DWORD *)(*(_DWORD *)v2 + 4) = *((_DWORD *)v2 + 1);
        operator delete(v2);
        v1 = dword_4EF788;
        --dword_4EF78C;
      }
      v2 = v3;
    }
    else
    {
      v2 = *(char **)v2;
    }
  }
  LeaveCriticalSection(&stru_4EF488);
}
// 4EF78C: using guessed type int dword_4EF78C;

//----- (0045A3C0) --------------------------------------------------------
WPARAM __thiscall sub_45A3C0(HWND *this, WPARAM wParam, int a3)
{
  WPARAM result; // eax
  WPARAM i; // edi
  HWND v6; // ebx
  char **v7; // eax
  HWND v8; // ecx
  LPARAM v9[2]; // [esp+10h] [ebp-220h] BYREF
  LPARAM lParam[2]; // [esp+18h] [ebp-218h] BYREF
  int v11[131]; // [esp+20h] [ebp-210h] BYREF

  if ( wParam != -1 )
  {
    SendMessageW(this[5], 0x1010u, wParam, (LPARAM)lParam);
    SendMessageW(this[5], 0x1029u, 0, (LPARAM)v9);
    this[274] = (HWND)(v9[0] + *(_DWORD *)a3 - lParam[0]);
    this[275] = (HWND)(v9[1] + *(_DWORD *)(a3 + 4) - lParam[1]);
  }
  result = SendMessageW(this[5], 0x100Cu, 0xFFFFFFFF, 2);
  for ( i = result; result != -1; i = result )
  {
    (*((void (__thiscall **)(HWND *, WPARAM, int, int *))*this + 16))(this, i, 260, v11);
    v6 = this[270];
    v7 = sub_4269E0((char *)v6, *((_DWORD *)v6 + 1), (int)v11);
    v8 = this[271];
    if ( v8 == (HWND)8259551 )
      std::vector<void *>::_Xlen(wParam, a3);
    this[271] = (HWND)((char *)v8 + 1);
    *((_DWORD *)v6 + 1) = v7;
    *(_DWORD *)v7[1] = v7;
    result = SendMessageW(this[5], 0x100Cu, i, 2);
  }
  this[277] = (HWND)1;
  return result;
}
// 45A4D4: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD, _DWORD);

//----- (0045A4E0) --------------------------------------------------------
int __thiscall sub_45A4E0(const WCHAR *this, int a2, _WORD *a3)
{
  const WCHAR *v3; // esi

  v3 = this + 40;
  if ( a2 >= lstrlenW(this + 40) + 1 && a2 && (unsigned int)a2 <= 0x7FFFFFFF )
    sub_4A96F0(a2, (int)v3, a3);
  return lstrlenW(v3);
}

//----- (0045A520) --------------------------------------------------------
_WORD *__thiscall sub_45A520(_DWORD *this, LPARAM a2, _WORD *a3)
{
  _WORD *v4; // edx
  _WORD *result; // eax
  int v6; // esi
  HWND v7; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v7 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  SendMessageW(v7, 0x104Bu, 0, (LPARAM)lParam);
  v4 = (_WORD *)(592 * lParam[8] + this[10] + 44);
  result = a3;
  v6 = 260;
  while ( v6 != -2147483386 && *v4 )
  {
    *result++ = *v4++;
    if ( !--v6 )
    {
      *(result - 1) = 0;
      return result;
    }
  }
  *result = 0;
  return result;
}
// 45A59D: conditional instruction was optimized away because esi.4!=0

//----- (0045A5C0) --------------------------------------------------------
int __thiscall sub_45A5C0(_DWORD *this, int a2, int a3, LPCWSTR lpString)
{
  HWND v6; // [esp-10h] [ebp-48h]
  LPARAM lParam[13]; // [esp+4h] [ebp-34h] BYREF

  v6 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  SendMessageW(v6, 0x104Bu, 0, (LPARAM)lParam);
  if ( a3 && (unsigned int)a3 <= 0x7FFFFFFF )
    sub_4A96F0(a3, 592 * lParam[8] + this[10] + 44, lpString);
  return lstrlenW(lpString);
}

//----- (0045A630) --------------------------------------------------------
int __thiscall sub_45A630(_DWORD *this, LPARAM a2, _WORD *a3, unsigned int a4)
{
  HWND v6; // [esp-10h] [ebp-48h]
  LPARAM lParam[8]; // [esp+4h] [ebp-34h] BYREF
  int v8; // [esp+24h] [ebp-14h]

  v6 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( !SendMessageW(v6, 0x104Bu, 0, (LPARAM)lParam) || a4 < lstrlenW((LPCWSTR)(592 * v8 + this[10] + 44)) + 1 )
    return -2147467259;
  if ( a4 )
  {
    if ( a4 <= 0x7FFFFFFF )
      sub_4A96F0(a4, 592 * v8 + this[10] + 44, a3);
  }
  return 0;
}

//----- (0045A6C0) --------------------------------------------------------
void __thiscall sub_45A6C0(_DWORD *this)
{
  sub_45A340((int)this);
  EnterCriticalSection(&stru_4EF464);
  LeaveCriticalSection(&stru_4EF464);
  sub_455870((int)this);
  sub_455810((int)this);
  this[10] = 1;
}

//----- (0045A700) --------------------------------------------------------
int __usercall sub_45A700@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int result; // eax

  switch ( a2[158] )
  {
    case 1:
      result = sub_4535E0((int)a2, a1, a3);
      break;
    case 2:
      result = sub_452A30(a1, a2, a3);
      break;
    case 3:
      result = sub_452EF0(a1, (int)a2, a2, a3);
      break;
    case 4:
      result = sub_452AD0(a3, a1, (int)a2);
      break;
    case 5:
      result = sub_452680((int)a2, a3, a1, 1);
      break;
    case 6:
      result = sub_452680((int)a2, a3, a1, 0);
      break;
    case 7:
      result = sub_453B80(a3, (int)a2, a1, 6);
      break;
    case 8:
    case 9:
      (*(void (__thiscall **)(_DWORD *))(*a2 + 40))(a2);
      goto LABEL_9;
    case 0xA:
      result = sub_454190(a3, (int)a2, a1);
      break;
    case 0xB:
      result = sub_453390(a3, a2, a1);
      break;
    case 0xC:
      result = sub_4525A0(a1, a3, a2);
      break;
    case 0xD:
      result = sub_454060(a3, (int)a2, a1);
      break;
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
      result = sub_453E90(a3, (int)a2, a1);
      break;
    case 0x13:
      result = sub_453D50(a3, (int)a2, a1);
      break;
    case 0x14:
      result = sub_453260(a3, (int)a2, a1);
      break;
    case 0x15:
      result = sub_452480(a3, (int)a2, a1);
      break;
    case 0x16:
      result = sub_4531C0(a1, a2, a3);
      break;
    case 0x17:
      result = sub_453120(a1, a2, a3);
      break;
    case 0x18:
      result = sub_453B80(a3, (int)a2, a1, 2);
      break;
    case 0x19:
      result = sub_453B80(a3, (int)a2, a1, 3);
      break;
    case 0x1A:
      result = sub_453B80(a3, (int)a2, a1, 4);
      break;
    case 0x1B:
      result = sub_453B80(a3, (int)a2, a1, 5);
      break;
    case 0x1D:
      result = sub_4539C0(a3, (int)a2, a1, 272);
      break;
    case 0x1E:
      result = sub_4539C0(a3, (int)a2, a1, 306);
      break;
    case 0x1F:
      result = sub_4539C0(a3, (int)a2, a1, 256);
      break;
    case 0x20:
      result = sub_4539C0(a3, (int)a2, a1, 257);
      break;
    case 0x21:
      result = sub_453890(a3, a1, (int)a2);
      break;
    case 0x22:
      result = sub_452260(a3, (int)a2, a1);
      break;
    case 0x23:
      result = sub_452000(a1, (int)a2, a3);
      break;
    case 0x24:
      result = sub_451EF0(a1, a3, a2);
      break;
    case 0x25:
      result = sub_451E60(a3, a1, a2);
      break;
    case 0x26:
      result = sub_451D00(a3, a1, (int)a2);
      break;
    case 0x27:
      result = sub_451BA0(a3, a1, (int)a2);
      break;
    case 0x28:
      result = sub_451B60(a1, a3, (int)a2);
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}

//----- (0045A9B0) --------------------------------------------------------
LPARAM __userpurge sub_45A9B0@<eax>(int a1@<edi>, int a2)
{
  LPARAM v2; // ebx
  int v3; // esi
  int v4; // esi
  int v5; // eax
  LPARAM result; // eax
  HWND v7; // [esp-10h] [ebp-54h]
  LPARAM lParam[8]; // [esp+Ch] [ebp-38h] BYREF
  int v9; // [esp+2Ch] [ebp-18h]
  LRESULT v10; // [esp+40h] [ebp-4h]

  v2 = 0;
  v3 = 1;
  v10 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  do
  {
    if ( v2 >= v10 )
      break;
    v3 = 0;
    v7 = *(HWND *)(a1 + 28);
    lParam[0] = 4;
    lParam[1] = v2;
    lParam[2] = 0;
    if ( SendMessageW(v7, 0x104Bu, 0, (LPARAM)lParam) )
    {
      v4 = v9;
      v5 = sub_45A700(a2, (_DWORD *)a1, v9);
      if ( !v5 )
        v5 = StrCmpLogicalW(
               (PCWSTR)(560 * a2 + *(_DWORD *)(a1 + 52) + 4),
               (PCWSTR)(560 * v4 + *(_DWORD *)(a1 + 52) + 4));
      v3 = v5;
    }
    ++v2;
  }
  while ( v3 > 0 );
  if ( v2 - 1 != v10 - 1 )
    return v2 - 1;
  result = v2;
  if ( v3 <= 0 )
    return v2 - 1;
  return result;
}

//----- (0045AAD0) --------------------------------------------------------
void __stdcall sub_45AAD0(ULONG_PTR Parameter)
{
  HWND v1; // ebx
  HWND v2; // edi
  int v3; // esi
  char *v4; // esi
  LPARAM v5; // edx
  void *v6; // [esp-10h] [ebp-310h]
  LPARAM lParam[13]; // [esp+0h] [ebp-300h] BYREF
  HWND hWnd[2]; // [esp+34h] [ebp-2CCh] BYREF
  LPARAM v9; // [esp+3Ch] [ebp-2C4h]
  int v10; // [esp+40h] [ebp-2C0h]
  HANDLE hEvent; // [esp+44h] [ebp-2BCh]
  SHFILEINFOW psfi; // [esp+48h] [ebp-2B8h] BYREF

  EnterCriticalSection(&stru_4EF488);
  dword_4EF484 = 0;
  LeaveCriticalSection(&stru_4EF488);
  if ( sub_45A280(0, hWnd) )
  {
    v1 = hWnd[0];
    v2 = hWnd[1];
    do
    {
      v3 = 0;
      if ( SHGetFileInfoW((LPCWSTR)v2, 0, &psfi, 0x2B4u, 0x148u) )
      {
        lParam[7] = psfi.iIcon;
        lParam[0] = 10;
        lParam[1] = v9;
        lParam[2] = 0;
        lParam[4] = 3840;
        lParam[3] = (psfi.iIcon >> 16) & 0xFFFFFF00;
        SendMessageW(v1, 0x104Cu, 0, (LPARAM)lParam);
        DestroyIcon(psfi.hIcon);
        CoTaskMemFree(v2);
      }
      EnterCriticalSection(&stru_4EF488);
      if ( hEvent )
        SetEvent(hEvent);
      if ( dword_4EF78C )
      {
        v4 = (char *)*((_DWORD *)dword_4EF788 + 1);
        v5 = *((_DWORD *)v4 + 4);
        v1 = (HWND)*((_DWORD *)v4 + 2);
        v2 = (HWND)*((_DWORD *)v4 + 3);
        v10 = *((_DWORD *)v4 + 5);
        v6 = (void *)*((_DWORD *)v4 + 6);
        v9 = v5;
        hEvent = v6;
        ResetEvent(v6);
        if ( v4 != dword_4EF788 )
        {
          **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
          *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
          operator delete(v4);
          --dword_4EF78C;
        }
        v3 = 1;
      }
      else
      {
        ++dword_4EF480;
        dword_4EF484 = 1;
      }
      LeaveCriticalSection(&stru_4EF488);
    }
    while ( v3 );
  }
}
// 4EF480: using guessed type int dword_4EF480;
// 4EF484: using guessed type int dword_4EF484;
// 4EF78C: using guessed type int dword_4EF78C;

//----- (0045AC70) --------------------------------------------------------
void __usercall sub_45AC70(int a1@<eax>, ULONG_PTR a2@<edi>)
{
  int v3; // edx
  char *v4; // ecx
  int v5; // eax
  char *v6; // eax
  char *v7; // ebx
  int v8; // ecx
  char **v9; // eax
  char *v10[5]; // [esp+8h] [ebp-14h] BYREF

  EnterCriticalSection(&stru_4EF488);
  v3 = 560 * *(_DWORD *)(a1 + 32);
  v4 = *(char **)(a1 + 4);
  v10[0] = *(char **)(a2 + 28);
  v5 = *(_DWORD *)(a2 + 52);
  v10[2] = v4;
  v6 = (char *)ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(v3 + v5));
  v7 = dword_4EF788;
  v8 = *((_DWORD *)dword_4EF788 + 1);
  v10[1] = v6;
  v10[4] = *(char **)(a2 + 84);
  v9 = sub_416060(v10, dword_4EF788, v8);
  if ( dword_4EF78C == 214748363 )
    std::_Xlength_error("list<T> too long");
  ++dword_4EF78C;
  *((_DWORD *)v7 + 1) = v9;
  *(_DWORD *)v9[1] = v9;
  if ( dword_4EF480 == dword_4EF47C )
  {
    ++dword_4EF47C;
    QueueUserAPC(sub_45AAD0, *(HANDLE *)(a2 + 60), a2);
  }
  LeaveCriticalSection(&stru_4EF488);
}
// 4EF47C: using guessed type int dword_4EF47C;
// 4EF480: using guessed type int dword_4EF480;
// 4EF78C: using guessed type int dword_4EF78C;

//----- (0045AD50) --------------------------------------------------------
void __usercall sub_45AD50(const WCHAR *a1@<ecx>, int a2@<esi>)
{
  const WCHAR *v2; // edi
  int v3; // ebx
  LPITEMIDLIST v4; // edi
  int v5; // ecx
  __int16 *v6; // edx
  int v7; // ebx
  _WORD *v8; // eax
  int v9; // ecx
  HWND v10; // [esp-10h] [ebp-528h]
  HWND v11; // [esp-10h] [ebp-528h]
  LPARAM lParam; // [esp+8h] [ebp-510h] BYREF
  int v13; // [esp+Ch] [ebp-50Ch]
  int v14; // [esp+10h] [ebp-508h]
  int v15; // [esp+1Ch] [ebp-4FCh]
  int iIcon; // [esp+24h] [ebp-4F4h]
  int v17; // [esp+28h] [ebp-4F0h]
  LPVOID v18; // [esp+3Ch] [ebp-4DCh]
  int v19; // [esp+40h] [ebp-4D8h]
  int v20; // [esp+44h] [ebp-4D4h]
  LPCWSTR pszPath; // [esp+48h] [ebp-4D0h]
  LPVOID v22; // [esp+4Ch] [ebp-4CCh] BYREF
  int v23; // [esp+50h] [ebp-4C8h]
  LPVOID pv; // [esp+54h] [ebp-4C4h] BYREF
  SHFILEINFOW psfi; // [esp+58h] [ebp-4C0h] BYREF
  __int16 v26[260]; // [esp+30Ch] [ebp-20Ch] BYREF

  v2 = a1;
  pszPath = a1;
  v22 = 0;
  v23 = -1;
  v19 = -1;
  if ( a1 )
  {
    pv = 0;
    if ( sub_467810((LPITEMIDLIST *)&pv, (int)a1) >= 0 )
      sub_466630((const ITEMIDLIST *)pv, (WCHAR *)v26, 1);
    CoTaskMemFree(pv);
    v2 = pszPath;
  }
  if ( sub_467810((LPITEMIDLIST *)&v22, (int)v2) >= 0 )
  {
    v3 = 0;
    if ( *(int *)(a2 + 680) > 0 )
    {
      while ( 1 )
      {
        v10 = *(HWND *)(a2 + 28);
        lParam = 4;
        v13 = v3;
        v14 = 0;
        SendMessageW(v10, 0x104Bu, 0, (LPARAM)&lParam);
        v4 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(560 * v17 + *(_DWORD *)(a2 + 52)));
        v18 = v22;
        if ( v22 )
        {
          if ( v4 )
          {
            pv = 0;
            v20 = 0;
            if ( SHGetDesktopFolder((IShellFolder **)&pv) >= 0 )
            {
              if ( !(*(unsigned __int16 (__stdcall **)(LPVOID, _DWORD, LPVOID, LPITEMIDLIST))(*(_DWORD *)pv + 28))(
                      pv,
                      0,
                      v18,
                      v4) )
                v20 = 1;
              (*(void (__stdcall **)(LPVOID))(*(_DWORD *)pv + 8))(pv);
              if ( v20 )
                break;
            }
          }
        }
        CoTaskMemFree(v4);
        if ( ++v3 >= *(_DWORD *)(a2 + 680) )
          goto LABEL_16;
      }
      v23 = v3;
      v19 = v17;
      CoTaskMemFree(v4);
    }
LABEL_16:
    CoTaskMemFree(v22);
    if ( v23 != -1 )
    {
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u);
      v5 = 560 * v19;
      v6 = v26;
      v7 = 260;
      v8 = (_WORD *)(*(_DWORD *)(a2 + 52) + 560 * v19 + 4);
      while ( v7 != -2147483386 && *v6 )
      {
        *v8++ = *v6++;
        if ( !--v7 )
        {
          --v8;
          break;
        }
      }
      *v8 = 0;
      v13 = v23;
      iIcon = psfi.iIcon;
      v9 = *(_DWORD *)(a2 + 52) + v5 + 4;
      v11 = *(HWND *)(a2 + 28);
      lParam = 3;
      v14 = 0;
      v15 = v9;
      SendMessageW(v11, 0x104Cu, 0, (LPARAM)&lParam);
    }
  }
}
// 45AF62: conditional instruction was optimized away because ebx.4!=0
// 45AD50: using guessed type WCHAR var_20C[260];

//----- (0045AFD0) --------------------------------------------------------
void __fastcall sub_45AFD0(int a1)
{
  bool v1; // cc
  ULONG_PTR v2; // edi
  int v3; // ecx
  char *v4; // eax
  char *v5; // ebx
  char *v6; // ecx
  char **v7; // eax
  void *v8; // ecx
  HWND v9; // [esp-1Ch] [ebp-6Ch]
  int v10; // [esp-10h] [ebp-60h]
  LPARAM lParam; // [esp+0h] [ebp-50h] BYREF
  char *v12; // [esp+4h] [ebp-4Ch]
  int v13; // [esp+8h] [ebp-48h]
  int v14; // [esp+20h] [ebp-30h]
  char *v15[5]; // [esp+34h] [ebp-1Ch] BYREF
  int v16; // [esp+48h] [ebp-8h]
  char *v17; // [esp+4Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 672) <= 0;
  v16 = a1;
  v17 = 0;
  if ( !v1 )
  {
    v2 = a1 - 8;
    while ( 1 )
    {
      v12 = v17;
      v9 = *(HWND *)(a1 + 20);
      lParam = 4;
      v13 = 0;
      SendMessageW(v9, 0x104Bu, 0, (LPARAM)&lParam);
      EnterCriticalSection(&stru_4EF488);
      v15[0] = *(char **)(v2 + 28);
      v3 = *(_DWORD *)(v2 + 52);
      v15[2] = v12;
      v4 = (char *)ILCombine(*(LPCITEMIDLIST *)(v2 + 76), *(LPCITEMIDLIST *)(560 * v14 + v3));
      v5 = dword_4EF788;
      v6 = *(char **)(v2 + 84);
      v10 = *((_DWORD *)dword_4EF788 + 1);
      v15[1] = v4;
      v15[4] = v6;
      v7 = sub_416060(v15, dword_4EF788, v10);
      if ( dword_4EF78C == 214748363 )
        std::vector<void *>::_Xlen();
      ++dword_4EF78C;
      *((_DWORD *)v5 + 1) = v7;
      *(_DWORD *)v7[1] = v7;
      if ( dword_4EF480 == dword_4EF47C )
      {
        v8 = *(void **)(v2 + 60);
        ++dword_4EF47C;
        QueueUserAPC(sub_45AAD0, v8, v2);
      }
      LeaveCriticalSection(&stru_4EF488);
      if ( (int)++v17 >= *(_DWORD *)(v16 + 672) )
        break;
      a1 = v16;
    }
  }
}
// 45B0DB: using guessed type void __noreturn std::vector<void *>::_Xlen(void);
// 4EF47C: using guessed type int dword_4EF47C;
// 4EF480: using guessed type int dword_4EF480;
// 4EF78C: using guessed type int dword_4EF78C;

//----- (0045B0F0) --------------------------------------------------------
int **__thiscall sub_45B0F0(int this, int *a2)
{
  int **result; // eax
  int v3; // edi
  WPARAM v4; // esi
  char *v5; // eax
  char *v6; // ecx
  int v7; // ebx
  char **v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // [esp-Ch] [ebp-24h]
  char *v12[3]; // [esp+4h] [ebp-14h] BYREF
  int v13; // [esp+10h] [ebp-8h]
  WPARAM wParam; // [esp+14h] [ebp-4h]

  result = **(int ****)(this + 956);
  v3 = (int)*result;
  v13 = this;
  wParam = 0;
  if ( (int **)v3 != result )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(this + 628) == 4 && *(_DWORD *)(v3 + 12) )
      {
        v4 = wParam;
        *(_DWORD *)(v3 + 16) = SendMessageW(*(HWND *)(this + 20), 0x101Du, wParam, 0);
        wParam = v4 + 1;
      }
      v5 = *(char **)(v3 + 12);
      v6 = *(char **)(v3 + 16);
      v12[0] = *(char **)(v3 + 8);
      v7 = *a2;
      v12[1] = v5;
      v11 = *(_DWORD *)(v7 + 4);
      v12[2] = v6;
      v8 = sub_41EEB0(v12, (char *)v7, v11);
      v9 = a2[1];
      if ( v9 == 357913940 )
        std::vector<void *>::_Xlen(a2);
      a2[1] = v9 + 1;
      v10 = v13;
      *(_DWORD *)(v7 + 4) = v8;
      *(_DWORD *)v8[1] = v8;
      v3 = *(_DWORD *)v3;
      result = *(int ***)(v10 + 956);
      if ( (int *)v3 == *result )
        break;
      this = v10;
    }
  }
  return result;
}
// 45B1A7: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (0045B1C0) --------------------------------------------------------
LRESULT __usercall sub_45B1C0@<eax>(LRESULT result@<eax>)
{
  int v1; // esi
  signed int i; // ebx
  HWND v3; // [esp-10h] [ebp-50h]
  LPARAM lParam[8]; // [esp+Ch] [ebp-34h] BYREF
  int v5; // [esp+2Ch] [ebp-14h]

  v1 = result;
  if ( *(_DWORD *)(result + 2188) )
  {
    for ( i = SendMessageW(*(HWND *)(result + 28), 0x1004u, 0, 0) - 1; i >= 0; --i )
    {
      v3 = *(HWND *)(v1 + 28);
      lParam[0] = 4;
      lParam[1] = i;
      lParam[2] = 0;
      SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam);
      if ( (*(_BYTE *)(592 * v5 + *(_DWORD *)(v1 + 48)) & 0x10) == 0
        && !sub_469A50((LPCWSTR)(v1 + 1164), 560 * v5 + *(_DWORD *)(v1 + 52) + 4, *(_DWORD *)(v1 + 2192)) )
      {
        sub_459D50(i, v1, v5);
      }
    }
    return SendMessageW(*(HWND *)(v1 + 32), 0x8011u, 0, 0);
  }
  return result;
}

//----- (0045B280) --------------------------------------------------------
int __usercall sub_45B280@<eax>(int a1@<ecx>, int a2@<ebx>)
{
  int v2; // esi
  ITEMIDLIST *v3; // edi
  SHFILEINFOW psfi; // [esp+8h] [ebp-4C0h] BYREF
  WCHAR pszPath[260]; // [esp+2BCh] [ebp-20Ch] BYREF

  v2 = 560 * a1;
  v3 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(*(_DWORD *)(a2 + 52) + 560 * a1));
  sub_466630(v3, pszPath, 0x8000);
  CoTaskMemFree(v3);
  if ( !*(_DWORD *)(*(_DWORD *)(a2 + 52) + v2 + 528) )
  {
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u);
    *(_DWORD *)(*(_DWORD *)(a2 + 52) + v2 + 528) = 1;
    *(_DWORD *)(*(_DWORD *)(a2 + 52) + v2 + 536) = psfi.iIcon;
  }
  return sub_409F80(*(_DWORD *)(a2 + 44), *(_DWORD *)(*(_DWORD *)(a2 + 52) + v2 + 536), 0);
}

//----- (0045B340) --------------------------------------------------------
int __thiscall sub_45B340(_DWORD *this, LPARAM a2)
{
  int v3; // edx
  HWND v5; // [esp-10h] [ebp-48h]
  LPARAM lParam[8]; // [esp+4h] [ebp-34h] BYREF
  int v7; // [esp+24h] [ebp-14h]

  v5 = (HWND)this[5];
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  SendMessageW(v5, 0x104Bu, 0, (LPARAM)lParam);
  v3 = this[11];
  if ( *(_DWORD *)(560 * v7 + v3 + 528) )
    return sub_409F80(this[9], *(_DWORD *)(560 * v7 + v3 + 536), 0);
  else
    return sub_45B280(v7, (int)(this - 2));
}

//----- (0045B3C0) --------------------------------------------------------
_DWORD *__usercall sub_45B3C0@<eax>(int a1@<esi>)
{
  int v1; // edi
  int v2; // ebx
  DWORD v3; // ebx
  int v4; // eax
  LPARAM v5; // eax
  _DWORD **v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  void *v9; // eax
  size_t v10; // edx
  void *v11; // eax
  void *v12; // eax
  int v13; // ecx
  int i; // eax
  _DWORD **v15; // ecx
  _DWORD *v16; // eax
  _DWORD *v17; // edi
  _DWORD **v18; // ecx
  _DWORD *result; // eax
  _DWORD *v20; // edi
  void *v21; // [esp-18h] [ebp-24h]
  size_t v22; // [esp-14h] [ebp-20h]
  void *v23; // [esp-8h] [ebp-14h]
  void *v24; // [esp-4h] [ebp-10h]

  v1 = 0;
  if ( *(int *)(a1 + 696) > 0 )
  {
    v2 = 0;
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 720) + 4 * v1) == 1 )
        CoTaskMemFree(*(LPVOID *)(*(_DWORD *)(a1 + 52) + v2));
      ++v1;
      v2 += 560;
    }
    while ( v1 < *(_DWORD *)(a1 + 696) );
  }
  if ( *(_DWORD *)(a1 + 636) == 6 )
  {
    EnterCriticalSection(&stru_4EF464);
    v3 = SendMessageW(*(HWND *)(a1 + 28), 0x1002u, 0, 0);
    v4 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
    v5 = sub_4018B0(120, 120, 32, v4, v4 + 100);
    SendMessageW(*(HWND *)(a1 + 28), 0x1003u, 0, v5);
    sub_409E60(v3);
    LeaveCriticalSection(&stru_4EF464);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 780));
  v6 = *(_DWORD ***)(a1 + 804);
  v7 = *v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 804) + 4) = *(_DWORD *)(a1 + 804);
  *(_DWORD *)(a1 + 808) = 0;
  if ( v7 != *(_DWORD **)(a1 + 804) )
  {
    do
    {
      v8 = (_DWORD *)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while ( v8 != *(_DWORD **)(a1 + 804) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 780));
  v23 = *(void **)(a1 + 48);
  *(_DWORD *)(a1 + 696) = 250;
  v9 = realloc(v23, 0x24220u);
  v10 = 560 * *(_DWORD *)(a1 + 696);
  *(_DWORD *)(a1 + 48) = v9;
  v11 = realloc(*(void **)(a1 + 52), v10);
  v22 = 4 * *(_DWORD *)(a1 + 696);
  v21 = *(void **)(a1 + 720);
  *(_DWORD *)(a1 + 52) = v11;
  v12 = realloc(v21, v22);
  v13 = *(_DWORD *)(a1 + 696);
  *(_DWORD *)(a1 + 720) = v12;
  for ( i = 0; i < v13; ++i )
    *(_DWORD *)(*(_DWORD *)(a1 + 720) + 4 * i) = 0;
  v24 = *(void **)(a1 + 76);
  *(_DWORD *)(a1 + 700) = 0;
  CoTaskMemFree(v24);
  v15 = *(_DWORD ***)(a1 + 1152);
  v16 = *v15;
  *v15 = v15;
  *(_DWORD *)(*(_DWORD *)(a1 + 1152) + 4) = *(_DWORD *)(a1 + 1152);
  *(_DWORD *)(a1 + 1156) = 0;
  if ( v16 != *(_DWORD **)(a1 + 1152) )
  {
    do
    {
      v17 = (_DWORD *)*v16;
      operator delete(v16);
      v16 = v17;
    }
    while ( v17 != *(_DWORD **)(a1 + 1152) );
  }
  v18 = *(_DWORD ***)(a1 + 828);
  result = *v18;
  *v18 = v18;
  *(_DWORD *)(*(_DWORD *)(a1 + 828) + 4) = *(_DWORD *)(a1 + 828);
  *(_DWORD *)(a1 + 832) = 0;
  if ( result == *(_DWORD **)(a1 + 828) )
  {
    *(_DWORD *)(a1 + 868) = 0;
  }
  else
  {
    do
    {
      v20 = (_DWORD *)*result;
      operator delete(result);
      result = v20;
    }
    while ( v20 != *(_DWORD **)(a1 + 828) );
    *(_DWORD *)(a1 + 868) = 0;
  }
  return result;
}

//----- (0045B5C0) --------------------------------------------------------
void __thiscall sub_45B5C0(HWND *this, _DWORD *a2)
{
  HWND *v3; // edi
  int v4; // eax

  if ( this[157] == (HWND)6 )
  {
    v3 = this - 2;
    v4 = sub_45BEE0(this - 2, 0, a2[11], 0);
    a2[3] |= 0x1000u;
    a2[10] = v4;
    if ( !this[8] )
      sub_45C240((char *)a2[11], (ULONG_PTR)v3);
  }
  else
  {
    if ( (a2[3] & 2) != 0 )
    {
      if ( ((_BYTE)this[10][148 * a2[11]] & 0x10) != 0 )
        a2[10] = this[176];
      else
        a2[10] = this[177];
      if ( !this[8] )
        sub_45AC70((int)(a2 + 3), (ULONG_PTR)(this - 2));
    }
    a2[3] |= 0x1000u;
  }
}

//----- (0045B650) --------------------------------------------------------
_DWORD *__thiscall sub_45B650(void *this, _DWORD **a2)
{
  _DWORD *result; // eax
  _DWORD *v4; // ecx
  void **v5; // eax
  WPARAM v6; // esi
  HWND v7; // eax
  int v8; // esi
  char *v9; // eax
  int v10; // ecx
  HWND v11; // [esp-10h] [ebp-C0h]
  LPARAM v12[13]; // [esp+10h] [ebp-A0h] BYREF
  LPARAM lParam[13]; // [esp+44h] [ebp-6Ch] BYREF
  _DWORD *v14; // [esp+78h] [ebp-38h]
  int v15; // [esp+7Ch] [ebp-34h]
  _DWORD **v16; // [esp+80h] [ebp-30h]
  void *v17[5]; // [esp+84h] [ebp-2Ch] BYREF
  unsigned int v18; // [esp+98h] [ebp-18h]
  int v19; // [esp+ACh] [ebp-4h]

  v15 = 0;
  sub_40A140((int)this + 848);
  result = *a2;
  v4 = (_DWORD *)**a2;
  v14 = result;
  v16 = (_DWORD **)v4;
  if ( v4 != result )
  {
    while ( 1 )
    {
      LOWORD(v17[0]) = 0;
      v18 = 7;
      v17[4] = 0;
      sub_4090E0((int)v17, v4 + 2, 0, 0xFFFFFFFF);
      v19 = 0;
      v5 = (void **)v17[0];
      if ( v18 < 8 )
        v5 = v17;
      v6 = (*(int (__thiscall **)(void *, void **))(*(_DWORD *)this + 180))(this, v5);
      if ( v6 == -1 )
      {
        v8 = *((_DWORD *)this + 212);
        v9 = sub_40A200((char *)v8, *(_DWORD *)(v8 + 4), (int)v17);
        v10 = *((_DWORD *)this + 213);
        if ( v10 == 153391688 )
          std::vector<void *>::_Xlen(a2);
        *((_DWORD *)this + 213) = v10 + 1;
        *(_DWORD *)(v8 + 4) = v9;
        **((_DWORD **)v9 + 1) = v9;
      }
      else
      {
        v7 = (HWND)*((_DWORD *)this + 5);
        lParam[4] = 2;
        lParam[3] = 2;
        SendMessageW(v7, 0x102Bu, v6, (LPARAM)lParam);
        if ( !v15 )
        {
          v11 = (HWND)*((_DWORD *)this + 5);
          v12[4] = 1;
          v12[3] = 1;
          SendMessageW(v11, 0x102Bu, v6, (LPARAM)v12);
          SendMessageW(*((HWND *)this + 5), 0x1013u, v6, 0);
          v15 = 1;
        }
      }
      v19 = -1;
      if ( v18 >= 8 )
        operator delete(v17[0]);
      result = *v16;
      v16 = (_DWORD **)result;
      if ( result == v14 )
        break;
      v4 = v16;
    }
  }
  return result;
}
// 45B7D0: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (0045B7E0) --------------------------------------------------------
void __thiscall sub_45B7E0(int this, int **a2, int a3)
{
  int **v3; // edi
  int *v5; // ecx
  int *v6; // esi
  WPARAM v7; // edx
  unsigned int v8; // eax
  int v9; // eax
  int *v10; // eax
  unsigned int v11; // eax
  int v12; // eax
  _DWORD *v13; // ecx
  _DWORD *v14; // eax
  WPARAM i; // edi
  _DWORD *v16; // ecx
  _DWORD *v17; // eax
  signed int j; // edi
  _DWORD *v19; // ecx
  _DWORD *v20; // eax
  char ***v21; // esi
  int *v22; // edx
  char *v23; // eax
  char *v24; // edi
  int *v25; // [esp+Ch] [ebp-Ch]
  int v26; // [esp+Ch] [ebp-Ch]
  int v27; // [esp+10h] [ebp-8h]
  int v28; // [esp+10h] [ebp-8h]
  int v29; // [esp+14h] [ebp-4h]

  v3 = a2;
  v5 = *a2;
  v6 = (int *)**a2;
  v7 = 0;
  v29 = 0;
  v27 = 0;
  v25 = v6;
  if ( v6 != *a2 )
  {
    while ( 1 )
    {
      if ( !v6[3] )
      {
        v8 = v6[2] - 1;
        v9 = v8 > 0x26 ? 0 : sub_454DC0(v8);
        if ( v9 == *(_DWORD *)(this + 624) )
        {
          v10 = (int *)*v5;
          if ( (int *)*v5 != v5 )
          {
            while ( !v10[3] )
            {
              v10 = (int *)*v10;
              if ( v10 == v5 )
                goto LABEL_17;
            }
            v11 = v10[2] - 1;
            if ( v11 > 0x26 )
              v12 = 0;
            else
              v12 = sub_454DC0(v11);
            *(_DWORD *)(this + 624) = v12;
            v29 = 1;
          }
        }
      }
LABEL_17:
      v13 = **(_DWORD ***)(this + 956);
      v14 = (_DWORD *)*v13;
      for ( i = v6[2]; v14 != v13; v14 = (_DWORD *)*v14 )
      {
        if ( v14[2] == i )
          break;
      }
      if ( v6[3] )
      {
        if ( *(_DWORD *)(this + 628) == 4 )
        {
          v16 = **(_DWORD ***)(this + 956);
          v17 = (_DWORD *)*v16;
          if ( (_DWORD *)*v16 != v16 )
          {
            do
            {
              if ( v17[2] == i )
                break;
              v17 = (_DWORD *)*v17;
            }
            while ( v17 != **(_DWORD ***)(this + 956) );
          }
          if ( !v17[3] )
          {
            sub_454F50(i, this - 8, v7, v6[4]);
            for ( j = 0; j < *(_DWORD *)(this + 672); ++j )
              sub_4582C0(v27, this - 8, v25[2], j);
            v6 = v25;
          }
        }
        ++v27;
      }
      else
      {
        v19 = **(_DWORD ***)(this + 956);
        v20 = (_DWORD *)*v19;
        if ( (_DWORD *)*v19 != v19 )
        {
          do
          {
            if ( v20[2] == i )
              break;
            v20 = (_DWORD *)*v20;
          }
          while ( v20 != **(_DWORD ***)(this + 956) );
        }
        if ( v20[3] )
          SendMessageW(*(HWND *)(this + 20), 0x101Cu, v7, 0);
      }
      v3 = a2;
      v5 = *a2;
      v25 = (int *)*v6;
      if ( (int *)*v6 == *a2 )
        break;
      v6 = (int *)*v6;
      v7 = v27;
    }
  }
  v21 = *(char ****)(this + 956);
  if ( v21 != (char ***)v3 )
  {
    v22 = *v3;
    v26 = **v3;
    v23 = **v21;
    **v21 = (char *)*v21;
    (*v21)[1] = (char *)*v21;
    v28 = (int)v22;
    v21[1] = 0;
    if ( v23 != (char *)*v21 )
    {
      do
      {
        v24 = *(char **)v23;
        operator delete(v23);
        v23 = v24;
      }
      while ( v24 != (char *)*v21 );
      v22 = (int *)v28;
    }
    sub_40B870((int)v21, **v21, v26, (int)v22, v29);
  }
  if ( v29 )
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)(this - 8) + 16))(this - 8, *(_DWORD *)(this + 624));
  *(_DWORD *)(this + 1044) = 0;
}
// 45B838: variable 'v5' is possibly undefined
// 45B8C7: variable 'v7' is possibly undefined

//----- (0045B9E0) --------------------------------------------------------
LRESULT __usercall sub_45B9E0@<eax>(ULONG_PTR a1@<eax>)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  char *v4; // eax
  char *v5; // ecx
  int v6; // eax
  char **v7; // eax
  int v8; // ecx
  _DWORD **v9; // ecx
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  int v13; // [esp-4h] [ebp-24h]
  int v14; // [esp+Ch] [ebp-14h]
  char *v15[4]; // [esp+10h] [ebp-10h] BYREF

  v2 = *(_DWORD **)(a1 + 1152);
  v3 = (_DWORD *)*v2;
  if ( (_DWORD *)*v2 != v2 )
  {
    v15[2] = (char *)1;
    do
    {
      v4 = (char *)sub_45A9B0(a1, v3[2]);
      v5 = (char *)v3[2];
      v15[0] = v4;
      v15[3] = v4 - 1;
      v6 = *(_DWORD *)(a1 + 828);
      v13 = *(_DWORD *)(v6 + 4);
      v15[1] = v5;
      v14 = v6;
      v7 = sub_420A20(v15, (char *)v6, v13);
      v8 = *(_DWORD *)(a1 + 832);
      if ( v8 == 268435454 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 832) = v8 + 1;
      *(_DWORD *)(v14 + 4) = v7;
      *(_DWORD *)v7[1] = v7;
      v3 = (_DWORD *)*v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 1152) );
  }
  v9 = *(_DWORD ***)(a1 + 1152);
  v10 = *v9;
  *v9 = v9;
  *(_DWORD *)(*(_DWORD *)(a1 + 1152) + 4) = *(_DWORD *)(a1 + 1152);
  *(_DWORD *)(a1 + 1156) = 0;
  if ( v10 != *(_DWORD **)(a1 + 1152) )
  {
    do
    {
      v11 = (_DWORD *)*v10;
      operator delete(v10);
      v10 = v11;
    }
    while ( v11 != *(_DWORD **)(a1 + 1152) );
  }
  sub_426070(a1, *(_DWORD *)(a1 + 740));
  return SendMessageW(*(HWND *)(a1 + 32), 0x8011u, 0, 0);
}

//----- (0045BAD0) --------------------------------------------------------
LRESULT __usercall sub_45BAD0@<eax>(ULONG_PTR a1@<esi>)
{
  if ( *(_DWORD *)(a1 + 2188) )
  {
    sub_45B1C0(a1);
    return SendMessageW(*(HWND *)(a1 + 32), 0x80CAu, *(_DWORD *)(a1 + 776), 1);
  }
  else
  {
    sub_45B9E0(a1);
    if ( *(_DWORD *)(a1 + 680) )
      return SendMessageW(*(HWND *)(a1 + 32), 0x80CAu, *(_DWORD *)(a1 + 776), 0);
    else
      return SendMessageW(*(HWND *)(a1 + 32), 0x80C9u, *(_DWORD *)(a1 + 776), 1);
  }
}

//----- (0045BB40) --------------------------------------------------------
LRESULT __thiscall sub_45BB40(_DWORD *this, int a2)
{
  this[545] = a2;
  return sub_45BAD0((ULONG_PTR)(this - 2));
}

//----- (0045BB60) --------------------------------------------------------
_WORD *__thiscall sub_45BB60(_DWORD *this, int a2)
{
  _WORD *result; // eax
  int v3; // esi
  __int16 v4; // dx
  _DWORD *v5; // esi

  result = this + 289;
  v3 = 512;
  while ( v3 != -2147483134 )
  {
    v4 = *(_WORD *)((char *)result + a2 - (_DWORD)(this + 289));
    if ( !v4 )
      break;
    *result++ = v4;
    if ( !--v3 )
    {
      --result;
      break;
    }
  }
  *result = 0;
  if ( this[545] )
  {
    v5 = this - 2;
    sub_45B9E0((ULONG_PTR)(this - 2));
    return (_WORD *)sub_45BAD0((ULONG_PTR)v5);
  }
  return result;
}
// 45BB95: conditional instruction was optimized away because esi.4!=0

//----- (0045BBC0) --------------------------------------------------------
void __thiscall sub_45BBC0(const WCHAR *this, int a2, int a3)
{
  unsigned int v4; // eax
  __int16 j; // cx
  const WCHAR *v6; // esi
  unsigned int v7; // eax
  __int16 i; // cx
  WCHAR psz2[260]; // [esp+4h] [ebp-214h] BYREF
  WCHAR String1[4]; // [esp+20Ch] [ebp-Ch] BYREF

  sub_4664A0(17, psz2);
  if ( !StrCmpW(this + 40, psz2) )
  {
    if ( a2 == 0x8000 )
    {
      if ( *(_DWORD *)(a3 + 4) != 2 )
        return;
      v7 = *(_DWORD *)(a3 + 12);
      for ( i = 0; (v7 & 1) == 0; ++i )
        v7 >>= 1;
      sub_401000(4u, String1, L"%c:\\", (unsigned __int16)(i + 65));
      if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
      {
        v6 = this - 4;
LABEL_14:
        sub_45AD50(String1, (int)v6);
        return;
      }
      sub_451530((ULONG_PTR)(this - 4), (int)String1);
    }
    else if ( a2 == 32772 && *(_DWORD *)(a3 + 4) == 2 )
    {
      v4 = *(_DWORD *)(a3 + 12);
      for ( j = 0; (v4 & 1) == 0; ++j )
        v4 >>= 1;
      sub_401000(4u, String1, L"%c:\\", (unsigned __int16)(j + 65));
      v6 = this - 4;
      if ( (*(_BYTE *)(a3 + 16) & 1) == 0 )
      {
        sub_458AB0((int)v6, String1);
        return;
      }
      goto LABEL_14;
    }
  }
}
// 4C191C: using guessed type wchar_t aC_2[5];
// 4C1928: using guessed type wchar_t aC_1[5];

//----- (0045BD00) --------------------------------------------------------
BOOL __usercall sub_45BD00@<eax>(HDC a1@<ebx>, void *a2@<edi>)
{
  HDC CompatibleDC; // esi
  char pv[4]; // [esp+4h] [ebp-1Ch] BYREF
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  HGDIOBJ h; // [esp+1Ch] [ebp-4h]

  CompatibleDC = CreateCompatibleDC(a1);
  h = SelectObject(CompatibleDC, a2);
  GetObjectW(a2, 24, pv);
  BitBlt(a1, (120 - v5) / 2, (120 - v6) / 2, 120, 120, CompatibleDC, 0, 0, 0xCC0020u);
  SelectObject(CompatibleDC, h);
  return DeleteDC(CompatibleDC);
}
// 45BD00: using guessed type char pv[4];

//----- (0045BD90) --------------------------------------------------------
int __usercall sub_45BD90@<eax>(_DWORD *a1@<eax>)
{
  char *v3; // ecx
  char *v4; // eax

  EnterCriticalSection(&stru_4EF464);
  if ( dword_4EF780 )
  {
    v3 = dword_4EF77C;
    v4 = (char *)*((_DWORD *)dword_4EF77C + 1);
    *a1 = *((_DWORD *)v4 + 2);
    a1[1] = *((_DWORD *)v4 + 3);
    a1[2] = *((_DWORD *)v4 + 4);
    a1[3] = *((_DWORD *)v4 + 5);
    a1[4] = *((_DWORD *)v4 + 6);
    if ( v4 != v3 )
    {
      **((_DWORD **)v4 + 1) = *(_DWORD *)v4;
      *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
      operator delete(v4);
      --dword_4EF780;
    }
    LeaveCriticalSection(&stru_4EF464);
    return 1;
  }
  else
  {
    ++dword_4EF5C8;
    LeaveCriticalSection(&stru_4EF464);
    return 0;
  }
}
// 4EF5C8: using guessed type int dword_4EF5C8;
// 4EF780: using guessed type int dword_4EF780;

//----- (0045BE20) --------------------------------------------------------
BOOL __userpurge sub_45BE20@<eax>(HDC a1@<ebx>, int a2@<esi>, int a3)
{
  LPITEMIDLIST v3; // eax
  HICON v4; // edi
  DWORD dwErrCode; // [esp+4h] [ebp-2C8h] BYREF
  int v7; // [esp+8h] [ebp-2C4h] BYREF
  SHFILEINFOW psfi; // [esp+Ch] [ebp-2C0h] BYREF

  v3 = ILCombine(*(LPCITEMIDLIST *)(a2 + 76), *(LPCITEMIDLIST *)(560 * a3 + *(_DWORD *)(a2 + 52)));
  SHGetFileInfoW(&v3->mkid.cb, 0, &psfi, 0x2B4u, 0x4008u);
  v4 = (HICON)sub_409F80(*(_DWORD *)(a2 + 44), psfi.iIcon, 0);
  sub_416200(*(_DWORD *)(a2 + 44), (int)&v7, (DWORD)&dwErrCode);
  DrawIconEx(a1, (120 - v7) / 2, (int)(120 - dwErrCode) / 2, v4, 0, 0, 0, 0, 3u);
  return DestroyIcon(v4);
}

//----- (0045BEE0) --------------------------------------------------------
int __thiscall sub_45BEE0(HWND *this, int a2, int a3, void *a4)
{
  HDC DC; // edi
  HDC CompatibleDC; // ebx
  LRESULT v7; // eax
  HBRUSH SolidBrush; // eax
  int v9; // eax
  int v10; // esi
  HGDIOBJ h; // [esp+Ch] [ebp-24h]
  HBITMAP ho; // [esp+14h] [ebp-1Ch]
  RECT rc; // [esp+1Ch] [ebp-14h] BYREF

  DC = GetDC(this[7]);
  CompatibleDC = CreateCompatibleDC(DC);
  ho = CreateCompatibleBitmap(DC, 120, 120);
  h = SelectObject(CompatibleDC, ho);
  v7 = SendMessageW(this[7], 0x1000u, 0, 0);
  SolidBrush = CreateSolidBrush(v7);
  rc.left = 0;
  rc.top = 0;
  rc.right = 120;
  rc.bottom = 120;
  FillRect(CompatibleDC, &rc, SolidBrush);
  if ( a2 )
  {
    if ( a2 == 1 )
      sub_45BD00(CompatibleDC, a4);
  }
  else
  {
    sub_45BE20(CompatibleDC, (int)this, a3);
  }
  SelectObject(CompatibleDC, h);
  DeleteDC(CompatibleDC);
  ReleaseDC(this[7], DC);
  v9 = SendMessageW(this[7], 0x1002u, 0, 0);
  v10 = sub_4011E0(v9, (int)ho, 0);
  DeleteObject(ho);
  return v10;
}

//----- (0045C020) --------------------------------------------------------
void __stdcall sub_45C020(ULONG_PTR Parameter)
{
  const ITEMIDLIST *v1; // esi
  LPITEMIDLIST v2; // edi
  const ITEMIDLIST *ID; // eax
  int v4; // eax
  HWND v5; // edi
  LPARAM v6; // esi
  LRESULT v7; // eax
  int v8; // [esp+58h] [ebp-29Ch] BYREF
  IShellFolder *ppshf; // [esp+5Ch] [ebp-298h] BYREF
  LPVOID pv; // [esp+60h] [ebp-294h] BYREF
  int v11; // [esp+64h] [ebp-290h] BYREF
  HGDIOBJ ho; // [esp+68h] [ebp-28Ch] BYREF
  HWND *v13; // [esp+6Ch] [ebp-288h]
  int v14; // [esp+70h] [ebp-284h] BYREF
  ITEMIDLIST *v15; // [esp+74h] [ebp-280h]
  int v16[2]; // [esp+78h] [ebp-27Ch] BYREF
  HWND hWnd; // [esp+80h] [ebp-274h] BYREF
  LPCITEMIDLIST pidl; // [esp+84h] [ebp-270h]
  LPARAM v19; // [esp+88h] [ebp-26Ch]
  int v20; // [esp+8Ch] [ebp-268h]
  char v21[4]; // [esp+94h] [ebp-260h] BYREF
  LPARAM lParam[6]; // [esp+98h] [ebp-25Ch] BYREF
  LPARAM v23[13]; // [esp+B0h] [ebp-244h] BYREF
  char v24[524]; // [esp+E4h] [ebp-210h] BYREF

  v13 = (HWND *)Parameter;
  v8 = 0;
  ppshf = 0;
  v11 = 0;
  pv = 0;
  if ( !*(_DWORD *)(Parameter + 40) && sub_45BD90(&hWnd) )
  {
    do
    {
      v1 = pidl;
      v2 = ILClone(pidl);
      v15 = v2;
      ILRemoveLastID(v2);
      ID = ILFindLastID(v1);
      pv = ILClone(ID);
      if ( SHGetDesktopFolder(&ppshf) >= 0 )
      {
        if ( ppshf->lpVtbl->BindToObject(ppshf, v2, 0, &stru_4BD7FC, (void **)&v11) >= 0 )
        {
          if ( (*(int (__stdcall **)(int, _DWORD, int, LPVOID *, void *, _DWORD, int *))(*(_DWORD *)v11 + 40))(
                 v11,
                 0,
                 1,
                 &pv,
                 &unk_4BD8AC,
                 0,
                 &v8) >= 0 )
          {
            v16[0] = 120;
            v16[1] = 120;
            v14 = 520;
            (*(void (__stdcall **)(int, char *, int, char *, int *, int, int *))(*(_DWORD *)v8 + 12))(
              v8,
              v24,
              260,
              v21,
              v16,
              32,
              &v14);
            if ( (*(int (__stdcall **)(int, HGDIOBJ *))(*(_DWORD *)v8 + 16))(v8, &ho) >= 0 )
            {
              v4 = sub_45BEE0(v13, 1, 0, ho);
              v5 = hWnd;
              v6 = v4;
              lParam[0] = 1;
              lParam[2] = v19;
              v7 = SendMessageW(hWnd, 0x1053u, 0xFFFFFFFF, (LPARAM)lParam);
              if ( v7 != -1 )
              {
                v23[0] = 2;
                v23[1] = v7;
                v23[2] = 0;
                v23[7] = v6;
                SendMessageW(v5, 0x104Cu, 0, (LPARAM)v23);
                *(_DWORD *)(v20 + 532) = 1;
              }
              DeleteObject(ho);
              v2 = v15;
            }
            (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
          }
          (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
        }
        ppshf->lpVtbl->Release(ppshf);
      }
      CoTaskMemFree(v2);
      CoTaskMemFree(pv);
    }
    while ( sub_45BD90(&hWnd) );
  }
}
// 45C020: using guessed type char var_260[4];
// 45C020: using guessed type char var_210[524];

//----- (0045C240) --------------------------------------------------------
void __usercall sub_45C240(char *a1@<eax>, ULONG_PTR a2@<edi>)
{
  char *v3; // eax
  int v4; // ecx
  const ITEMIDLIST *v5; // edx
  char *v6; // eax
  char *v7; // ebx
  int v8; // ecx
  char *v9; // edx
  char **v10; // eax
  int v11; // [esp-4h] [ebp-20h]
  char *v12[5]; // [esp+8h] [ebp-14h] BYREF

  EnterCriticalSection(&stru_4EF464);
  v3 = *(char **)(a2 + 28);
  v4 = *(_DWORD *)(a2 + 52);
  v12[2] = a1;
  a1 = (char *)(560 * (_DWORD)a1);
  v5 = *(const ITEMIDLIST **)&a1[v4];
  v12[0] = v3;
  v6 = (char *)ILCombine(*(LPCITEMIDLIST *)(a2 + 76), v5);
  v7 = dword_4EF77C;
  v8 = *(_DWORD *)(a2 + 52);
  v9 = *(char **)(a2 + 84);
  v12[1] = v6;
  v11 = *((_DWORD *)dword_4EF77C + 1);
  v12[3] = &a1[v8];
  v12[4] = v9;
  v10 = sub_416060(v12, dword_4EF77C, v11);
  if ( dword_4EF780 == 214748363 )
    std::_Xlength_error("list<T> too long");
  ++dword_4EF780;
  *((_DWORD *)v7 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  if ( dword_4EF5C8 == dword_4EF5C4 )
  {
    ++dword_4EF5C4;
    QueueUserAPC(sub_45C020, *(HANDLE *)(a2 + 60), a2);
  }
  LeaveCriticalSection(&stru_4EF464);
}
// 4EF5C4: using guessed type int dword_4EF5C4;
// 4EF5C8: using guessed type int dword_4EF5C8;
// 4EF780: using guessed type int dword_4EF780;

//----- (0045C300) --------------------------------------------------------
int __usercall sub_45C300@<eax>(int a1@<edi>)
{
  LPARAM i; // esi
  DWORD v2; // eax
  int result; // eax
  HWND v4; // [esp-10h] [ebp-50h]
  LPARAM lParam[13]; // [esp+8h] [ebp-38h] BYREF
  LRESULT v6; // [esp+3Ch] [ebp-4h]

  SendMessageW(*(HWND *)(a1 + 28), 0x1036u, 0x8000u, 0);
  SendMessageW(*(HWND *)(a1 + 28), 0x1035u, 0, -1);
  v6 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  EnterCriticalSection(&stru_4EF464);
  LeaveCriticalSection(&stru_4EF464);
  for ( i = 0; i < v6; ++i )
  {
    v4 = *(HWND *)(a1 + 28);
    lParam[0] = 2;
    lParam[1] = i;
    lParam[2] = 0;
    lParam[7] = -1;
    SendMessageW(v4, 0x104Cu, 0, (LPARAM)lParam);
  }
  v2 = SendMessageW(*(HWND *)(a1 + 28), 0x1002u, 0, 0);
  result = sub_409E60(v2);
  *(_DWORD *)(a1 + 960) = 0;
  return result;
}

//----- (0045C3C0) --------------------------------------------------------
LRESULT __usercall sub_45C3C0@<eax>(int a1@<esi>)
{
  int v1; // ebx
  LRESULT v2; // eax
  LPARAM v3; // eax
  LRESULT result; // eax
  LPARAM i; // ebx
  HWND v6; // [esp-10h] [ebp-58h]
  HWND v7; // [esp-10h] [ebp-58h]
  LPARAM lParam[13]; // [esp+Ch] [ebp-3Ch] BYREF
  int v9; // [esp+40h] [ebp-8h]
  void *ppvObj; // [esp+44h] [ebp-4h] BYREF

  v1 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  v9 = v1;
  ppvObj = 0;
  SHGetImageList(0, &stru_4BD96C, &ppvObj);
  SendMessageW(*(HWND *)(a1 + 28), 0x1003u, 0, (LPARAM)ppvObj);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppvObj + 8))(ppvObj);
  v2 = SendMessageW(*(HWND *)(a1 + 28), 0x1002u, 0, 0);
  v6 = *(HWND *)(a1 + 28);
  *(_DWORD *)(a1 + 44) = v2;
  SendMessageW(v6, 0x1036u, 0x8000u, 0x8000);
  SendMessageW(*(HWND *)(a1 + 28), 0x1035u, 0, 9175180);
  v3 = sub_4018B0(120, 120, 32, v1, v1 + 100);
  result = SendMessageW(*(HWND *)(a1 + 28), 0x1003u, 0, v3);
  for ( i = 0; i < v9; ++i )
  {
    v7 = *(HWND *)(a1 + 28);
    lParam[0] = 2;
    lParam[1] = i;
    lParam[2] = 0;
    lParam[7] = -1;
    result = SendMessageW(v7, 0x104Cu, 0, (LPARAM)lParam);
  }
  *(_DWORD *)(a1 + 960) = 1;
  return result;
}

//----- (0045C4C0) --------------------------------------------------------
int __thiscall sub_45C4C0(_DWORD *this)
{
  return this[3] - this[2];
}

//----- (0045C4D0) --------------------------------------------------------
int __thiscall sub_45C4D0(_DWORD *this)
{
  return this[2] - 1;
}

//----- (0045C4E0) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_45C4E0(_DWORD *this, int a2)
{
  int v2; // eax

  v2 = a2 + this[2];
  if ( v2 < 0 || v2 > this[3] )
    return 0;
  else
    return ILClone(*(LPCITEMIDLIST *)(this[5] + 4 * v2 - 4));
}

//----- (0045C510) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_45C510(_DWORD *this, int a2)
{
  int v2; // eax

  v2 = a2 + this[2];
  if ( v2 < 0 || v2 > this[3] )
    return 0;
  this[2] = v2;
  return ILClone(*(LPCITEMIDLIST *)(this[5] + 4 * v2 - 4));
}

//----- (0045C540) --------------------------------------------------------
int __usercall sub_45C540@<eax>(int result@<eax>, int a2@<edx>)
{
  for ( ; result < *(_DWORD *)(a2 + 12) - 1; ++result )
    *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4 * result) = *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4 * result + 4);
  --*(_DWORD *)(a2 + 12);
  return result;
}

//----- (0045C570) --------------------------------------------------------
int __thiscall sub_45C570(int this, LPCITEMIDLIST pidl)
{
  int v3; // eax
  int v4; // eax
  int result; // eax

  v3 = *(_DWORD *)(this + 16);
  if ( *(_DWORD *)(this + 8) >= v3 - 1 )
  {
    v4 = v3 + 10;
    *(_DWORD *)(this + 16) = v4;
    *(_DWORD *)(this + 20) = realloc(*(void **)(this + 20), 4 * v4);
  }
  *(_DWORD *)(*(_DWORD *)(this + 20) + 4 * (*(_DWORD *)(this + 8))++) = ILClone(pidl);
  result = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (0045C5C0) --------------------------------------------------------
int __stdcall sub_45C5C0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (0045C630) --------------------------------------------------------
BOOL __thiscall sub_45C630(_DWORD *this, HWND a2, int *a3, int a4)
{
  int v5; // eax
  int v6; // esi
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v12; // [esp+Ch] [ebp-224h]
  int v13; // [esp+Ch] [ebp-224h]
  int v14; // [esp+10h] [ebp-220h]
  int v15; // [esp+10h] [ebp-220h]
  HMENU hMenu; // [esp+14h] [ebp-21Ch]
  WCHAR NewItem[262]; // [esp+20h] [ebp-210h] BYREF

  hMenu = CreatePopupMenu();
  if ( a4 )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 12))(this);
    v5 = this[2];
    v6 = v5 - 1;
    v12 = v5 - 1;
    if ( v5 <= 10 )
    {
      v14 = 0;
      v7 = 0;
    }
    else
    {
      v7 = v5 - 10;
      v14 = v7;
    }
    v8 = v6 - 1;
    if ( v8 >= v7 )
    {
      do
      {
        sub_466630(*(const ITEMIDLIST **)(this[5] + 4 * v8), NewItem, 1);
        AppendMenuW(hMenu, 0, v12 - v8--, NewItem);
      }
      while ( v8 >= v14 );
    }
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
    v9 = this[3];
    v10 = this[2];
    if ( v9 - v10 > 10 )
      v9 = v10 + 10;
    v13 = v9;
    if ( v10 < v9 )
    {
      v15 = 1 - v10;
      do
      {
        sub_466630(*(const ITEMIDLIST **)(this[5] + 4 * v10), NewItem, 1);
        AppendMenuW(hMenu, 0, v10 + v15, NewItem);
        ++v10;
      }
      while ( v10 < v13 );
    }
  }
  return TrackPopupMenu(hMenu, 0x100u, *a3, a3[1], 0, a2, 0);
}

//----- (0045C780) --------------------------------------------------------
int __stdcall sub_45C780(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    *(_DWORD *)a1 = &CPathManager::`vftable';
    operator delete(a1);
    return 0;
  }
  return result;
}
// 4CC7B8: using guessed type void *CPathManager::`vftable';

//----- (0045C7B0) --------------------------------------------------------
int __stdcall sub_45C7B0(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = 0;
  if ( !sub_40AA20(&stru_4BD95C, a2) )
    return -2147467262;
  *a3 = a1;
  if ( !a1 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}

//----- (0045C7F0) --------------------------------------------------------
char **__thiscall sub_45C7F0(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  char **result; // eax
  int v4; // ebx
  char **v5; // edi
  LPITEMIDLIST v6; // eax
  char *v7; // esi
  char *v8; // ecx
  char *v9; // [esp-10h] [ebp-20h]
  int v10; // [esp-Ch] [ebp-1Ch]
  char **v12; // [esp+Ch] [ebp-4h]

  v2 = this;
  (*(void (__thiscall **)(_DWORD *))(*this + 16))(this);
  result = (char **)v2[3];
  v4 = v2[2];
  if ( (int)result - v4 > 10 )
    result = (char **)(v4 + 10);
  v12 = result;
  if ( v4 < (int)result )
  {
    v5 = (char **)a2;
    while ( 1 )
    {
      v6 = ILClone(*(LPCITEMIDLIST *)(v2[5] + 4 * v4));
      v7 = *v5;
      v10 = *((_DWORD *)*v5 + 1);
      v9 = *v5;
      a2 = (int)v6;
      result = sub_40A550(v9, v10, (int)&a2);
      v8 = v5[1];
      if ( v8 == (char *)1073741822 )
        std::vector<void *>::_Xlen(a2);
      v5[1] = v8 + 1;
      *((_DWORD *)v7 + 1) = result;
      ++v4;
      *(_DWORD *)result[1] = result;
      if ( v4 >= (int)v12 )
        break;
      v2 = this;
    }
  }
  return result;
}
// 45C870: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (0045C880) --------------------------------------------------------
char **__thiscall sub_45C880(_DWORD *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // edi
  char **result; // eax
  int v5; // edi
  int *v6; // ebx
  LPITEMIDLIST v7; // eax
  int v8; // esi
  int v9; // ecx
  int v11; // [esp+Ch] [ebp-4h]

  v2 = this;
  (*(void (__thiscall **)(_DWORD *))(*this + 12))(this);
  v3 = v2[2];
  if ( v3 <= 10 )
  {
    v11 = 0;
    result = 0;
  }
  else
  {
    result = (char **)(v3 - 10);
    v11 = v3 - 10;
  }
  v5 = v3 - 2;
  if ( v5 >= (int)result )
  {
    v6 = (int *)a2;
    while ( 1 )
    {
      v7 = ILClone(*(LPCITEMIDLIST *)(v2[5] + 4 * v5));
      v8 = *v6;
      a2 = (int)v7;
      result = sub_40A550((char *)v8, *(_DWORD *)(v8 + 4), (int)&a2);
      v9 = v6[1];
      if ( v9 == 1073741822 )
        std::vector<void *>::_Xlen(a2);
      v6[1] = v9 + 1;
      *(_DWORD *)(v8 + 4) = result;
      --v5;
      *(_DWORD *)result[1] = result;
      if ( v5 < v11 )
        break;
      v2 = this;
    }
  }
  return result;
}
// 45C90D: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (0045C920) --------------------------------------------------------
LPITEMIDLIST __thiscall sub_45C920(_DWORD *this, int a2)
{
  int v3; // eax

  v3 = a2 + this[2];
  if ( v3 < 0 || v3 > this[3] )
    return 0;
  if ( !sub_467A90(*(const ITEMIDLIST **)(this[5] + 4 * v3 - 4)) )
  {
    CoTaskMemFree(*(LPVOID *)(this[5] + 4 * (a2 + this[2]) - 4));
    sub_45C540(a2 + this[2] - 1, (int)this);
    return 0;
  }
  this[2] += a2;
  return ILClone(*(LPCITEMIDLIST *)(this[5] + 4 * this[2] - 4));
}

//----- (0045C9E0) --------------------------------------------------------
LRESULT __usercall sub_45C9E0@<eax>(int a1@<esi>)
{
  HWND v1; // ecx
  HWND v3; // [esp-10h] [ebp-60h]
  HWND v4; // [esp-10h] [ebp-60h]
  HWND v5; // [esp-10h] [ebp-60h]
  LPARAM lParam[3]; // [esp+4h] [ebp-4Ch] BYREF
  void *v7; // [esp+10h] [ebp-40h]
  LPARAM v8[10]; // [esp+24h] [ebp-2Ch] BYREF

  v3 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  v7 = &unk_4C2094;
  SendMessageW(v3, 0x1061u, 1u, (LPARAM)lParam);
  v4 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  v7 = &unk_4C20D8;
  SendMessageW(v4, 0x1061u, 2u, (LPARAM)lParam);
  v5 = *(HWND *)(a1 + 28);
  lParam[0] = 4;
  v7 = &unk_4C20DC;
  SendMessageW(v5, 0x1061u, 3u, (LPARAM)lParam);
  v1 = *(HWND *)(a1 + 28);
  v8[1] = 2;
  v8[5] = 2;
  v8[0] = 40;
  v8[2] = 0;
  return SendMessageW(v1, 0x10A2u, 0, (LPARAM)v8);
}

//----- (0045CAA0) --------------------------------------------------------
int __thiscall sub_45CAA0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[167] = a2;
  return result;
}

//----- (0045CAB0) --------------------------------------------------------
int __thiscall sub_45CAB0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[166] = a2;
  return result;
}

//----- (0045CAC0) --------------------------------------------------------
int __thiscall sub_45CAC0(_DWORD *this)
{
  return this[191];
}

//----- (0045CAD0) --------------------------------------------------------
int __thiscall sub_45CAD0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[191] = a2;
  return result;
}

//----- (0045CAE0) --------------------------------------------------------
int __thiscall sub_45CAE0(_DWORD *this)
{
  return this[185];
}

//----- (0045CAF0) --------------------------------------------------------
int __thiscall sub_45CAF0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[185] = a2;
  return result;
}

//----- (0045CB00) --------------------------------------------------------
int __thiscall sub_45CB00(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[164] = a2;
  return result;
}

//----- (0045CB10) --------------------------------------------------------
int __thiscall sub_45CB10(_DWORD *this)
{
  return this[163];
}

//----- (0045CB20) --------------------------------------------------------
int __thiscall sub_45CB20(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[163] = a2;
  return result;
}

//----- (0045CB30) --------------------------------------------------------
int __thiscall sub_45CB30(_DWORD *this)
{
  return this[190];
}

//----- (0045CB40) --------------------------------------------------------
int __thiscall sub_45CB40(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[190] = a2;
  return result;
}

//----- (0045CB50) --------------------------------------------------------
int __thiscall sub_45CB50(_DWORD *this)
{
  return this[188];
}

//----- (0045CB60) --------------------------------------------------------
int __thiscall sub_45CB60(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[188] = a2;
  return result;
}

//----- (0045CB70) --------------------------------------------------------
int __thiscall sub_45CB70(_DWORD *this)
{
  return this[189];
}

//----- (0045CB80) --------------------------------------------------------
int __thiscall sub_45CB80(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[189] = a2;
  return result;
}

//----- (0045CB90) --------------------------------------------------------
int __thiscall sub_45CB90(_DWORD *this)
{
  (*(void (__thiscall **)(_DWORD *, _DWORD, int))(this[1] + 12))(this + 1, this[18], 134217729);
  return 0;
}

//----- (0045CBB0) --------------------------------------------------------
int __thiscall sub_45CBB0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[20] = a2;
  return result;
}

//----- (0045CBC0) --------------------------------------------------------
int __thiscall sub_45CBC0(_DWORD *this)
{
  return this[186];
}

//----- (0045CC00) --------------------------------------------------------
int __thiscall sub_45CC00(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[194] = a2;
  return result;
}

//----- (0045CC10) --------------------------------------------------------
int __thiscall sub_45CC10(_DWORD *this)
{
  return this[194];
}

//----- (0045CC20) --------------------------------------------------------
int __thiscall sub_45CC20(_DWORD *this, _DWORD *a2)
{
  int result; // eax

  this[188] = *a2;
  this[185] = a2[2];
  result = a2[3];
  this[163] = result;
  return result;
}

//----- (0045CC50) --------------------------------------------------------
int *__thiscall sub_45CC50(_DWORD *this)
{
  dword_4EF83C = this[182];
  dword_4EF840 = this[186];
  dword_4EF838 = this[187];
  dword_4EF834 = this[183];
  dword_4EF830 = this[184];
  dword_4EF828 = this[156];
  dword_4EF82C = this[157];
  return &dword_4EF828;
}
// 4EF828: using guessed type int dword_4EF828;
// 4EF82C: using guessed type int dword_4EF82C;
// 4EF830: using guessed type int dword_4EF830;
// 4EF834: using guessed type int dword_4EF834;
// 4EF838: using guessed type int dword_4EF838;
// 4EF83C: using guessed type int dword_4EF83C;
// 4EF840: using guessed type int dword_4EF840;

//----- (0045CD40) --------------------------------------------------------
int __thiscall sub_45CD40(_DWORD *this)
{
  return this[185];
}

//----- (0045CD50) --------------------------------------------------------
int __thiscall sub_45CD50(_DWORD *this, int a2)
{
  this[158] = a2;
  return 0;
}

//----- (0045CD70) --------------------------------------------------------
int __thiscall sub_45CD70(_DWORD *this, _DWORD *a2)
{
  *a2 = this[158];
  return 0;
}

//----- (0045CD90) --------------------------------------------------------
int __thiscall sub_45CD90(_DWORD *this, _DWORD *a2)
{
  if ( !a2 )
    return -2147024809;
  *a2 = this[159];
  return 0;
}

//----- (0045CDC0) --------------------------------------------------------
BOOL __thiscall sub_45CDC0(_DWORD *this)
{
  return this[184] != 0;
}

//----- (0045CDD0) --------------------------------------------------------
int __stdcall sub_45CDD0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = result;
  return result;
}

//----- (0045CDF0) --------------------------------------------------------
LRESULT __thiscall sub_45CDF0(_DWORD *this)
{
  HWND v1; // edi
  BOOL v2; // esi
  LPARAM v3; // eax

  v1 = (HWND)this[5];
  v2 = this[186] == 0;
  this[186] = v2;
  v3 = SendMessageW(v1, 0x1037u, 0, 0);
  if ( v2 )
    return SendMessageW(v1, 0x1036u, 0, v3 | 1);
  if ( (v3 & 1) != 0 )
    v3 &= ~1u;
  return SendMessageW(v1, 0x1036u, 0, v3);
}

//----- (0045CE50) --------------------------------------------------------
int __stdcall sub_45CE50(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax
  int v4; // ecx

  *a3 = 0;
  if ( sub_40AA20(dword_4BD87C, a2) )
  {
    v3 = a1;
    *a3 = a1;
    goto LABEL_14;
  }
  if ( !sub_40AA20(dword_4BD7DC, a2) )
  {
    if ( sub_40AA20(dword_4BD7CC, a2) )
    {
      v3 = a1;
      if ( a1 )
      {
        v4 = a1 + 8;
        goto LABEL_13;
      }
    }
    else
    {
      if ( !sub_40AA20(&stru_4BD7FC, a2) )
        return -2147467262;
      v3 = a1;
      if ( a1 )
      {
        v4 = a1 + 12;
        goto LABEL_13;
      }
    }
LABEL_12:
    v4 = 0;
    goto LABEL_13;
  }
  v3 = a1;
  if ( !a1 )
    goto LABEL_12;
  v4 = a1 + 4;
LABEL_13:
  *a3 = v4;
LABEL_14:
  if ( *a3 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v3);
    return 0;
  }
  return -2147467262;
}
// 4BD7CC: using guessed type _DWORD dword_4BD7CC[4];
// 4BD7DC: using guessed type _DWORD dword_4BD7DC[4];
// 4BD87C: using guessed type _DWORD dword_4BD87C[4];

//----- (0045CEF0) --------------------------------------------------------
void __stdcall sub_45CEF0(int a1)
{
  LRESULT v2; // edi
  LPARAM i; // ebx
  int v4; // eax
  _DWORD **v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  _DWORD **v8; // ecx
  _DWORD *v9; // eax
  _DWORD *v10; // ebx
  _DWORD **v11; // ecx
  _DWORD *v12; // eax
  _DWORD *v13; // ebx
  _DWORD **v14; // ecx
  _DWORD *v15; // eax
  _DWORD *v16; // ebx
  _DWORD **v17; // ecx
  _DWORD *v18; // eax
  _DWORD *v19; // ebx
  _DWORD **v20; // ecx
  _DWORD *v21; // eax
  _DWORD *v22; // ebx
  _DWORD **v23; // ecx
  _DWORD *v24; // eax
  _DWORD *v25; // ebx
  _DWORD **v26; // ecx
  _DWORD *v27; // eax
  _DWORD *v28; // ebx
  _DWORD **v29; // ecx
  _DWORD *v30; // eax
  _DWORD *v31; // ebx
  _DWORD **v32; // ecx
  _DWORD *v33; // eax
  _DWORD *v34; // ebx
  _DWORD **v35; // ecx
  _DWORD *v36; // eax
  _DWORD *v37; // ebx
  _DWORD **v38; // ecx
  _DWORD *v39; // eax
  _DWORD *v40; // ebx
  _DWORD **v41; // ecx
  _DWORD *v42; // eax
  _DWORD *v43; // ebx
  _DWORD **v44; // ecx
  _DWORD *v45; // eax
  _DWORD *v46; // ebx
  _DWORD **v47; // ecx
  _DWORD *v48; // eax
  _DWORD *v49; // ebx
  _DWORD **v50; // ecx
  _DWORD *v51; // eax
  _DWORD *v52; // edi
  HWND v53; // [esp-10h] [ebp-60h]
  LPARAM lParam[16]; // [esp+10h] [ebp-40h] BYREF

  *(_DWORD *)a1 = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 4) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 8) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 12) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 16) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 20) = &CFolderView::`vftable';
  lParam[15] = 16;
  sub_45A340(a1);
  EnterCriticalSection(&stru_4EF464);
  LeaveCriticalSection(&stru_4EF464);
  sub_455870(a1);
  sub_455810(a1);
  WaitForSingleObject(*(HANDLE *)(a1 + 84), 0xFFFFFFFF);
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 1072) + 8))(*(_DWORD *)(a1 + 1072));
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 1068) + 8))(*(_DWORD *)(a1 + 1068));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 932));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 892));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 780));
  v2 = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  for ( i = 0; i < v2; ++i )
  {
    v53 = *(HWND *)(a1 + 28);
    lParam[0] = 4;
    lParam[1] = i;
    lParam[2] = 0;
    SendMessageW(v53, 0x104Bu, 0, (LPARAM)lParam);
    CoTaskMemFree(*(LPVOID *)(560 * lParam[8] + *(_DWORD *)(a1 + 52)));
  }
  CoTaskMemFree(*(LPVOID *)(a1 + 76));
  v4 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 868) = 0;
  *(_DWORD *)(a1 + 872) = 0;
  (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
  free(*(void **)(a1 + 720));
  free(*(void **)(a1 + 52));
  free(*(void **)(a1 + 48));
  v5 = *(_DWORD ***)(a1 + 1152);
  v6 = *v5;
  *v5 = v5;
  *(_DWORD *)(*(_DWORD *)(a1 + 1152) + 4) = *(_DWORD *)(a1 + 1152);
  *(_DWORD *)(a1 + 1156) = 0;
  if ( v6 != *(_DWORD **)(a1 + 1152) )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      operator delete(v6);
      v6 = v7;
    }
    while ( v7 != *(_DWORD **)(a1 + 1152) );
  }
  operator delete(*(void **)(a1 + 1152));
  v8 = *(_DWORD ***)(a1 + 1136);
  v9 = *v8;
  *v8 = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 1136) + 4) = *(_DWORD *)(a1 + 1136);
  *(_DWORD *)(a1 + 1140) = 0;
  if ( v9 != *(_DWORD **)(a1 + 1136) )
  {
    do
    {
      v10 = (_DWORD *)*v9;
      operator delete(v9);
      v9 = v10;
    }
    while ( v10 != *(_DWORD **)(a1 + 1136) );
  }
  operator delete(*(void **)(a1 + 1136));
  v11 = *(_DWORD ***)(a1 + 1088);
  v12 = *v11;
  *v11 = v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) = *(_DWORD *)(a1 + 1088);
  *(_DWORD *)(a1 + 1092) = 0;
  if ( v12 != *(_DWORD **)(a1 + 1088) )
  {
    do
    {
      v13 = (_DWORD *)*v12;
      operator delete(v12);
      v12 = v13;
    }
    while ( v13 != *(_DWORD **)(a1 + 1088) );
  }
  operator delete(*(void **)(a1 + 1088));
  v14 = *(_DWORD ***)(a1 + 1076);
  v15 = *v14;
  *v14 = v14;
  *(_DWORD *)(*(_DWORD *)(a1 + 1076) + 4) = *(_DWORD *)(a1 + 1076);
  *(_DWORD *)(a1 + 1080) = 0;
  if ( v15 != *(_DWORD **)(a1 + 1076) )
  {
    do
    {
      v16 = (_DWORD *)*v15;
      operator delete(v15);
      v15 = v16;
    }
    while ( v16 != *(_DWORD **)(a1 + 1076) );
  }
  operator delete(*(void **)(a1 + 1076));
  v17 = *(_DWORD ***)(a1 + 1040);
  v18 = *v17;
  *v17 = v17;
  *(_DWORD *)(*(_DWORD *)(a1 + 1040) + 4) = *(_DWORD *)(a1 + 1040);
  *(_DWORD *)(a1 + 1044) = 0;
  if ( v18 != *(_DWORD **)(a1 + 1040) )
  {
    do
    {
      v19 = (_DWORD *)*v18;
      operator delete(v18);
      v18 = v19;
    }
    while ( v19 != *(_DWORD **)(a1 + 1040) );
  }
  operator delete(*(void **)(a1 + 1040));
  v20 = *(_DWORD ***)(a1 + 1028);
  v21 = *v20;
  *v20 = v20;
  *(_DWORD *)(*(_DWORD *)(a1 + 1028) + 4) = *(_DWORD *)(a1 + 1028);
  *(_DWORD *)(a1 + 1032) = 0;
  if ( v21 != *(_DWORD **)(a1 + 1028) )
  {
    do
    {
      v22 = (_DWORD *)*v21;
      operator delete(v21);
      v21 = v22;
    }
    while ( v22 != *(_DWORD **)(a1 + 1028) );
  }
  operator delete(*(void **)(a1 + 1028));
  v23 = *(_DWORD ***)(a1 + 1016);
  v24 = *v23;
  *v23 = v23;
  *(_DWORD *)(*(_DWORD *)(a1 + 1016) + 4) = *(_DWORD *)(a1 + 1016);
  *(_DWORD *)(a1 + 1020) = 0;
  if ( v24 != *(_DWORD **)(a1 + 1016) )
  {
    do
    {
      v25 = (_DWORD *)*v24;
      operator delete(v24);
      v24 = v25;
    }
    while ( v25 != *(_DWORD **)(a1 + 1016) );
  }
  operator delete(*(void **)(a1 + 1016));
  v26 = *(_DWORD ***)(a1 + 1004);
  v27 = *v26;
  *v26 = v26;
  *(_DWORD *)(*(_DWORD *)(a1 + 1004) + 4) = *(_DWORD *)(a1 + 1004);
  *(_DWORD *)(a1 + 1008) = 0;
  if ( v27 != *(_DWORD **)(a1 + 1004) )
  {
    do
    {
      v28 = (_DWORD *)*v27;
      operator delete(v27);
      v27 = v28;
    }
    while ( v28 != *(_DWORD **)(a1 + 1004) );
  }
  operator delete(*(void **)(a1 + 1004));
  v29 = *(_DWORD ***)(a1 + 992);
  v30 = *v29;
  *v29 = v29;
  *(_DWORD *)(*(_DWORD *)(a1 + 992) + 4) = *(_DWORD *)(a1 + 992);
  *(_DWORD *)(a1 + 996) = 0;
  if ( v30 != *(_DWORD **)(a1 + 992) )
  {
    do
    {
      v31 = (_DWORD *)*v30;
      operator delete(v30);
      v30 = v31;
    }
    while ( v31 != *(_DWORD **)(a1 + 992) );
  }
  operator delete(*(void **)(a1 + 992));
  v32 = *(_DWORD ***)(a1 + 980);
  v33 = *v32;
  *v32 = v32;
  *(_DWORD *)(*(_DWORD *)(a1 + 980) + 4) = *(_DWORD *)(a1 + 980);
  *(_DWORD *)(a1 + 984) = 0;
  if ( v33 != *(_DWORD **)(a1 + 980) )
  {
    do
    {
      v34 = (_DWORD *)*v33;
      operator delete(v33);
      v33 = v34;
    }
    while ( v34 != *(_DWORD **)(a1 + 980) );
  }
  operator delete(*(void **)(a1 + 980));
  v35 = *(_DWORD ***)(a1 + 968);
  v36 = *v35;
  *v35 = v35;
  *(_DWORD *)(*(_DWORD *)(a1 + 968) + 4) = *(_DWORD *)(a1 + 968);
  *(_DWORD *)(a1 + 972) = 0;
  if ( v36 != *(_DWORD **)(a1 + 968) )
  {
    do
    {
      v37 = (_DWORD *)*v36;
      operator delete(v36);
      v36 = v37;
    }
    while ( v37 != *(_DWORD **)(a1 + 968) );
  }
  operator delete(*(void **)(a1 + 968));
  v38 = *(_DWORD ***)(a1 + 920);
  v39 = *v38;
  *v38 = v38;
  *(_DWORD *)(*(_DWORD *)(a1 + 920) + 4) = *(_DWORD *)(a1 + 920);
  *(_DWORD *)(a1 + 924) = 0;
  if ( v39 != *(_DWORD **)(a1 + 920) )
  {
    do
    {
      v40 = (_DWORD *)*v39;
      operator delete(v39);
      v39 = v40;
    }
    while ( v40 != *(_DWORD **)(a1 + 920) );
  }
  operator delete(*(void **)(a1 + 920));
  v41 = *(_DWORD ***)(a1 + 880);
  v42 = *v41;
  *v41 = v41;
  *(_DWORD *)(*(_DWORD *)(a1 + 880) + 4) = *(_DWORD *)(a1 + 880);
  *(_DWORD *)(a1 + 884) = 0;
  if ( v42 != *(_DWORD **)(a1 + 880) )
  {
    do
    {
      v43 = (_DWORD *)*v42;
      operator delete(v42);
      v42 = v43;
    }
    while ( v43 != *(_DWORD **)(a1 + 880) );
  }
  operator delete(*(void **)(a1 + 880));
  sub_40A140(a1 + 856);
  operator delete(*(void **)(a1 + 856));
  v44 = *(_DWORD ***)(a1 + 828);
  v45 = *v44;
  *v44 = v44;
  *(_DWORD *)(*(_DWORD *)(a1 + 828) + 4) = *(_DWORD *)(a1 + 828);
  *(_DWORD *)(a1 + 832) = 0;
  if ( v45 != *(_DWORD **)(a1 + 828) )
  {
    do
    {
      v46 = (_DWORD *)*v45;
      operator delete(v45);
      v45 = v46;
    }
    while ( v46 != *(_DWORD **)(a1 + 828) );
  }
  operator delete(*(void **)(a1 + 828));
  v47 = *(_DWORD ***)(a1 + 816);
  v48 = *v47;
  *v47 = v47;
  *(_DWORD *)(*(_DWORD *)(a1 + 816) + 4) = *(_DWORD *)(a1 + 816);
  *(_DWORD *)(a1 + 820) = 0;
  if ( v48 != *(_DWORD **)(a1 + 816) )
  {
    do
    {
      v49 = (_DWORD *)*v48;
      operator delete(v48);
      v48 = v49;
    }
    while ( v49 != *(_DWORD **)(a1 + 816) );
  }
  operator delete(*(void **)(a1 + 816));
  v50 = *(_DWORD ***)(a1 + 804);
  v51 = *v50;
  *v50 = v50;
  *(_DWORD *)(*(_DWORD *)(a1 + 804) + 4) = *(_DWORD *)(a1 + 804);
  *(_DWORD *)(a1 + 808) = 0;
  if ( v51 != *(_DWORD **)(a1 + 804) )
  {
    do
    {
      v52 = (_DWORD *)*v51;
      operator delete(v51);
      v51 = v52;
    }
    while ( v52 != *(_DWORD **)(a1 + 804) );
  }
  operator delete(*(void **)(a1 + 804));
}
// 4CC58C: using guessed type void *CFolderView::`vftable';
// 4CC5CC: using guessed type void *CFolderView::`vftable';
// 4CC5E4: using guessed type void *CFolderView::`vftable';
// 4CC778: using guessed type void *CFolderView::`vftable';
// 4CC790: using guessed type void *CFolderView::`vftable';
// 4CC7B0: using guessed type void *CFolderView::`vftable';

//----- (0045D510) --------------------------------------------------------
int __stdcall sub_45D510(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 6))-- == 1;
  result = *((_DWORD *)a1 + 6);
  if ( v1 )
  {
    sub_45CEF0((int)a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (0045D540) --------------------------------------------------------
int ***__userpurge sub_45D540@<eax>(int a1@<ebx>, int ***a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int ***result; // eax
  int *i; // edi
  char *v6; // ecx
  char *v7; // edx
  char *v8; // eax
  char **v9; // eax
  int v10; // ecx
  int v11; // [esp-4h] [ebp-1Ch]
  char *v12[3]; // [esp+8h] [ebp-10h] BYREF
  char *v13; // [esp+14h] [ebp-4h]

  v2 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v2 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  result = (int ***)*a2;
  for ( i = **a2; i != (int *)*a2; result = a2 )
  {
    v6 = (char *)i[2];
    v7 = (char *)i[3];
    v12[2] = (char *)i[4];
    v8 = *(char **)a1;
    v12[0] = v6;
    v11 = *((_DWORD *)v8 + 1);
    v12[1] = v7;
    v13 = v8;
    v9 = sub_41EEB0(v12, v8, v11);
    v10 = *(_DWORD *)(a1 + 4);
    if ( v10 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v10 + 1;
    *((_DWORD *)v13 + 1) = v9;
    *(_DWORD *)v9[1] = v9;
    i = (int *)*i;
  }
  return result;
}

//----- (0045D5E0) --------------------------------------------------------
LRESULT __thiscall sub_45D5E0(_DWORD *this, int a2)
{
  _WORD *v3; // eax
  int v4; // edx
  int v5; // ebx
  __int16 v6; // cx
  int v7; // edi
  HWND v8; // esi
  LPARAM v9; // eax

  this[182] = *(_DWORD *)(a2 + 20);
  this[186] = *(_DWORD *)(a2 + 24);
  this[187] = *(_DWORD *)(a2 + 16);
  this[183] = *(_DWORD *)(a2 + 12);
  this[184] = *(_DWORD *)(a2 + 8);
  this[156] = *(_DWORD *)a2;
  this[157] = *(_DWORD *)(a2 + 4);
  this[545] = *(_DWORD *)(a2 + 28);
  this[546] = *(_DWORD *)(a2 + 32);
  this[163] = *(_DWORD *)(a2 + 36);
  this[164] = *(_DWORD *)(a2 + 40);
  this[189] = *(_DWORD *)(a2 + 44);
  this[190] = *(_DWORD *)(a2 + 48);
  this[166] = *(_DWORD *)(a2 + 52);
  v3 = this + 289;
  this[167] = *(_DWORD *)(a2 + 56);
  v4 = 512;
  v5 = a2 + 60 - (_DWORD)(this + 289);
  while ( v4 != -2147483134 )
  {
    v6 = *(_WORD *)((char *)v3 + v5);
    if ( !v6 )
      break;
    *v3++ = v6;
    if ( !--v4 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  sub_45D540((int)(this + 246), *(int ****)(a2 + 1092));
  sub_45D540((int)(this + 243), *(int ****)(a2 + 1088));
  sub_45D540((int)(this + 258), *(int ****)(a2 + 1108));
  sub_45D540((int)(this + 255), *(int ****)(a2 + 1104));
  sub_45D540((int)(this + 252), *(int ****)(a2 + 1100));
  sub_45D540((int)(this + 240), *(int ****)(a2 + 1084));
  sub_45D540((int)(this + 249), *(int ****)(a2 + 1096));
  v7 = this[186];
  v8 = (HWND)this[5];
  v9 = SendMessageW(v8, 0x1037u, 0, 0);
  if ( v7 )
    return SendMessageW(v8, 0x1036u, 0, v9 | 1);
  if ( (v9 & 1) != 0 )
    v9 &= ~1u;
  return SendMessageW(v8, 0x1036u, 0, v9);
}
// 45D6A1: conditional instruction was optimized away because edx.4!=0

//----- (0045D780) --------------------------------------------------------
int __userpurge sub_45D780@<eax>(int a1@<esi>, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // ebx
  HWND v25; // ebx
  LONG WindowLongW; // eax
  HWND v27; // ebx
  LPARAM v28; // eax
  int v29; // ebx
  int i; // eax
  int v32; // [esp+10h] [ebp-3FCh]
  int v33; // [esp+10h] [ebp-3FCh]
  int v34[3]; // [esp+14h] [ebp-3F8h] BYREF
  int pExceptionObject[3]; // [esp+20h] [ebp-3ECh] BYREF
  char *v36; // [esp+2Ch] [ebp-3E0h] BYREF
  char *v37; // [esp+30h] [ebp-3DCh] BYREF
  SHFILEINFOW psfi; // [esp+34h] [ebp-3D8h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+2E8h] [ebp-124h] BYREF
  int v40; // [esp+408h] [ebp-4h]

  *(_DWORD *)a1 = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 4) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 8) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 12) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 16) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 20) = &CFolderView::`vftable';
  *(_DWORD *)(a1 + 808) = 0;
  v6 = operator new(0x218u);
  if ( !v6 )
    goto LABEL_45;
  *(_DWORD *)(a1 + 804) = v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 804) + 4) = *(_DWORD *)(a1 + 804);
  v40 = 0;
  *(_DWORD *)(a1 + 820) = 0;
  v7 = operator new(0x210u);
  if ( !v7 )
    goto LABEL_44;
  *(_DWORD *)(a1 + 816) = v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a1 + 816) + 4) = *(_DWORD *)(a1 + 816);
  LOBYTE(v40) = 1;
  *(_DWORD *)(a1 + 832) = 0;
  v8 = operator new(0x18u);
  if ( !v8 )
    goto LABEL_43;
  *(_DWORD *)(a1 + 828) = v8;
  *v8 = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 828) + 4) = *(_DWORD *)(a1 + 828);
  LOBYTE(v40) = 2;
  *(_DWORD *)(a1 + 860) = 0;
  v9 = operator new(0x24u);
  if ( !v9 )
    goto LABEL_42;
  *(_DWORD *)(a1 + 856) = v9;
  *v9 = v9;
  *(_DWORD *)(*(_DWORD *)(a1 + 856) + 4) = *(_DWORD *)(a1 + 856);
  LOBYTE(v40) = 3;
  *(_DWORD *)(a1 + 884) = 0;
  v10 = operator new(0xCu);
  if ( !v10 )
    goto LABEL_41;
  *(_DWORD *)(a1 + 880) = v10;
  *v10 = v10;
  *(_DWORD *)(*(_DWORD *)(a1 + 880) + 4) = *(_DWORD *)(a1 + 880);
  LOBYTE(v40) = 4;
  *(_DWORD *)(a1 + 924) = 0;
  v11 = operator new(0xCu);
  if ( !v11 )
    goto LABEL_46;
  *(_DWORD *)(a1 + 920) = v11;
  *v11 = v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 920) + 4) = *(_DWORD *)(a1 + 920);
  LOBYTE(v40) = 5;
  *(_DWORD *)(a1 + 972) = 0;
  v12 = operator new(0x14u);
  if ( !v12 )
    goto LABEL_45;
  *(_DWORD *)(a1 + 968) = v12;
  *v12 = v12;
  *(_DWORD *)(*(_DWORD *)(a1 + 968) + 4) = *(_DWORD *)(a1 + 968);
  LOBYTE(v40) = 6;
  *(_DWORD *)(a1 + 984) = 0;
  v13 = operator new(0x14u);
  if ( !v13 )
    goto LABEL_44;
  *(_DWORD *)(a1 + 980) = v13;
  *v13 = v13;
  *(_DWORD *)(*(_DWORD *)(a1 + 980) + 4) = *(_DWORD *)(a1 + 980);
  LOBYTE(v40) = 7;
  *(_DWORD *)(a1 + 996) = 0;
  v14 = operator new(0x14u);
  if ( !v14 )
    goto LABEL_43;
  *(_DWORD *)(a1 + 992) = v14;
  *v14 = v14;
  *(_DWORD *)(*(_DWORD *)(a1 + 992) + 4) = *(_DWORD *)(a1 + 992);
  LOBYTE(v40) = 8;
  *(_DWORD *)(a1 + 1008) = 0;
  v15 = operator new(0x14u);
  if ( !v15 )
    goto LABEL_42;
  *(_DWORD *)(a1 + 1004) = v15;
  *v15 = v15;
  *(_DWORD *)(*(_DWORD *)(a1 + 1004) + 4) = *(_DWORD *)(a1 + 1004);
  LOBYTE(v40) = 9;
  *(_DWORD *)(a1 + 1020) = 0;
  v16 = operator new(0x14u);
  if ( !v16 )
    goto LABEL_41;
  *(_DWORD *)(a1 + 1016) = v16;
  *v16 = v16;
  *(_DWORD *)(*(_DWORD *)(a1 + 1016) + 4) = *(_DWORD *)(a1 + 1016);
  LOBYTE(v40) = 10;
  *(_DWORD *)(a1 + 1032) = 0;
  v17 = operator new(0x14u);
  if ( !v17 )
  {
LABEL_46:
    v36 = 0;
    std::exception::exception((std::exception *)v34, (const char *const *)&v36);
    v34[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v34, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1028) = v17;
  *v17 = v17;
  *(_DWORD *)(*(_DWORD *)(a1 + 1028) + 4) = *(_DWORD *)(a1 + 1028);
  LOBYTE(v40) = 11;
  *(_DWORD *)(a1 + 1044) = 0;
  v18 = operator new(0x14u);
  if ( !v18 )
  {
LABEL_45:
    v37 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v37);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1040) = v18;
  *v18 = v18;
  *(_DWORD *)(*(_DWORD *)(a1 + 1040) + 4) = *(_DWORD *)(a1 + 1040);
  LOBYTE(v40) = 12;
  *(_DWORD *)(a1 + 1080) = 0;
  v19 = operator new(0x218u);
  if ( !v19 )
  {
LABEL_44:
    v36 = 0;
    std::exception::exception((std::exception *)v34, (const char *const *)&v36);
    v34[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v34, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1076) = v19;
  *v19 = v19;
  *(_DWORD *)(*(_DWORD *)(a1 + 1076) + 4) = *(_DWORD *)(a1 + 1076);
  LOBYTE(v40) = 13;
  *(_DWORD *)(a1 + 1092) = 0;
  v20 = operator new(0x210u);
  if ( !v20 )
  {
LABEL_43:
    v37 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v37);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1088) = v20;
  *v20 = v20;
  *(_DWORD *)(*(_DWORD *)(a1 + 1088) + 4) = *(_DWORD *)(a1 + 1088);
  LOBYTE(v40) = 14;
  *(_DWORD *)(a1 + 1140) = 0;
  v21 = operator new(0x410u);
  if ( !v21 )
  {
LABEL_42:
    v36 = 0;
    std::exception::exception((std::exception *)v34, (const char *const *)&v36);
    v34[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v34, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1136) = v21;
  *v21 = v21;
  *(_DWORD *)(*(_DWORD *)(a1 + 1136) + 4) = *(_DWORD *)(a1 + 1136);
  LOBYTE(v40) = 15;
  *(_DWORD *)(a1 + 1156) = 0;
  v22 = operator new(0xCu);
  if ( !v22 )
  {
LABEL_41:
    v37 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v37);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 1152) = v22;
  *v22 = v22;
  *(_DWORD *)(*(_DWORD *)(a1 + 1152) + 4) = *(_DWORD *)(a1 + 1152);
  LOBYTE(v40) = 16;
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a2;
  if ( CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)(a1 + 1068)) >= 0 )
  {
    (***(void (__stdcall ****)(_DWORD, void *, int))(a1 + 1068))(*(_DWORD *)(a1 + 1068), &unk_4BD88C, a1 + 1072);
    RegisterDragDrop(*(HWND *)(a1 + 28), (LPDROPTARGET)(a1 + 16));
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
  }
  *(_DWORD *)(a1 + 48) = malloc(0x24220u);
  *(_DWORD *)(a1 + 52) = malloc(0x222E0u);
  *(_DWORD *)(a1 + 696) = 250;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) )
    *(_DWORD *)(a1 + 628) = VersionInformation.dwMajorVersion;
  v23 = operator new(0x18u);
  v24 = v23;
  if ( v23 )
  {
    *v23 = &CPathManager::`vftable';
    v23[1] = 1;
    v23[2] = 0;
    v23[4] = 10;
    v23[5] = malloc(0x28u);
    v24[3] = 0;
  }
  else
  {
    v24 = 0;
  }
  *(_DWORD *)(a1 + 632) = 1;
  *(_DWORD *)(a1 + 636) = 1;
  *(_DWORD *)(a1 + 744) = 1;
  *(_DWORD *)(a1 + 736) = 1;
  *(_DWORD *)(a1 + 748) = 1;
  *(_DWORD *)(a1 + 752) = 1;
  *(_DWORD *)(a1 + 760) = 1;
  *(_DWORD *)(a1 + 56) = v24;
  *(_DWORD *)(a1 + 740) = 0;
  *(_DWORD *)(a1 + 644) = 0;
  *(_DWORD *)(a1 + 2188) = 0;
  *(_DWORD *)(a1 + 2192) = 0;
  *(_DWORD *)(a1 + 756) = 0;
  *(_DWORD *)(a1 + 764) = 0;
  *(_DWORD *)(a1 + 768) = 0;
  *(_DWORD *)(a1 + 1052) = 0;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_DWORD *)(a1 + 1116) = 0;
  *(_DWORD *)(a1 + 640) = 0;
  *(_DWORD *)(a1 + 960) = 0;
  *(_DWORD *)(a1 + 1056) = 0;
  *(_DWORD *)(a1 + 704) = -1;
  *(_DWORD *)(a1 + 708) = -1;
  *(_DWORD *)(a1 + 868) = 0;
  *(_DWORD *)(a1 + 872) = 0;
  *(_DWORD *)(a1 + 656) = 0;
  *(_DWORD *)(a1 + 964) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 1060) = 0;
  *(_DWORD *)(a1 + 668) = 0;
  *(_DWORD *)(a1 + 844) = 0;
  *(_DWORD *)(a1 + 724) = -1;
  *(_DWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  sub_45D5E0((_DWORD *)(a1 + 8), a4);
  v25 = *(HWND *)(a1 + 28);
  v32 = *(_DWORD *)(a1 + 736);
  WindowLongW = GetWindowLongW(v25, -16);
  if ( v32 )
  {
    if ( (WindowLongW & 0x100) == 0 )
      WindowLongW |= 0x100u;
  }
  else if ( (WindowLongW & 0x100) != 0 )
  {
    WindowLongW &= ~0x100u;
  }
  SetWindowLongW(v25, -16, WindowLongW);
  v27 = *(HWND *)(a1 + 28);
  v33 = *(_DWORD *)(a1 + 752);
  v28 = SendMessageW(v27, 0x1037u, 0, 0);
  if ( v33 )
  {
    v28 |= 1u;
  }
  else if ( (v28 & 1) != 0 )
  {
    v28 &= ~1u;
  }
  SendMessageW(v27, 0x1036u, 0, v28);
  v29 = *(_DWORD *)(a1 + 696);
  *(_DWORD *)(a1 + 840) = 0;
  *(_DWORD *)(a1 + 720) = malloc(4 * v29);
  for ( i = 0; i < v29; ++i )
    *(_DWORD *)(*(_DWORD *)(a1 + 720) + 4 * i) = 0;
  *(_DWORD *)(a1 + 700) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 780));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 892));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 932));
  if ( !dword_4EF5C0 )
  {
    InitializeCriticalSection(&stru_4EF464);
    dword_4EF5C0 = 1;
  }
  *(_DWORD *)(a1 + 876) = 1;
  *(_DWORD *)(a1 + 60) = a5;
  *(_DWORD *)(a1 + 64) = a6;
  SHGetFileInfoW(L"dummy", 0x90u, &psfi, 0x2B4u, 0x4010u);
  *(_DWORD *)(a1 + 712) = psfi.iIcon;
  SHGetFileInfoW(L"dummy", 0x80u, &psfi, 0x2B4u, 0x4010u);
  *(_DWORD *)(a1 + 716) = psfi.iIcon;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  if ( !dword_4EF594 )
  {
    dword_4EF480 = 0;
    dword_4EF47C = 0;
    dword_4EF484 = 1;
    InitializeCriticalSection(&stru_4EF488);
    dword_4EF4A0 = 0;
    dword_4EF594 = 1;
  }
  *(_DWORD *)(a1 + 84) = CreateEventW(0, 1, 1, 0);
  *(_DWORD *)(a1 + 916) = CreateEventW(0, 1, 1, 0);
  *(_DWORD *)(a1 + 956) = CreateEventW(0, 1, 1, 0);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC58C: using guessed type void *CFolderView::`vftable';
// 4CC5CC: using guessed type void *CFolderView::`vftable';
// 4CC5E4: using guessed type void *CFolderView::`vftable';
// 4CC778: using guessed type void *CFolderView::`vftable';
// 4CC790: using guessed type void *CFolderView::`vftable';
// 4CC7B0: using guessed type void *CFolderView::`vftable';
// 4CC7B8: using guessed type void *CPathManager::`vftable';
// 4EF47C: using guessed type int dword_4EF47C;
// 4EF480: using guessed type int dword_4EF480;
// 4EF484: using guessed type int dword_4EF484;
// 4EF4A0: using guessed type int dword_4EF4A0;
// 4EF594: using guessed type int dword_4EF594;
// 4EF5C0: using guessed type int dword_4EF5C0;

//----- (0045DFE0) --------------------------------------------------------
int __usercall sub_45DFE0@<eax>(int *a1@<edi>, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // eax
  int result; // eax

  v6 = operator new(0x898u);
  if ( v6 )
  {
    result = sub_45D780((int)v6, a2, a3, a4, a5, a6);
    *a1 = result;
  }
  else
  {
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0045E060) --------------------------------------------------------
LRESULT __userpurge sub_45E060@<eax>(int a1@<eax>, int a2)
{
  bool v3; // zf
  HWND v4; // ebx
  LPARAM v5; // eax
  int v7; // [esp-Ch] [ebp-20h]
  void *ppvObj; // [esp+10h] [ebp-4h] BYREF
  int v9; // [esp+1Ch] [ebp+8h]

  switch ( a2 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      v7 = 0;
      goto LABEL_5;
    case 7:
      v7 = 4;
      goto LABEL_5;
    case 8:
      v7 = 2;
LABEL_5:
      ppvObj = 0;
      SHGetImageList(v7, &stru_4BD96C, &ppvObj);
      SendMessageW(*(HWND *)(a1 + 28), 0x1003u, 0, (LPARAM)ppvObj);
      (*(void (__stdcall **)(void *))(*(_DWORD *)ppvObj + 8))(ppvObj);
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 636) == 5 && a2 != 5 )
  {
    SendMessageW(*(HWND *)(a1 + 28), 0x101Cu, 3u, 0);
    SendMessageW(*(HWND *)(a1 + 28), 0x101Cu, 2u, 0);
    SendMessageW(*(HWND *)(a1 + 28), 0x101Cu, 1u, 0);
  }
  switch ( a2 )
  {
    case 1:
    case 7:
    case 8:
      goto LABEL_18;
    case 2:
      ppvObj = (void *)2;
      break;
    case 3:
      ppvObj = (void *)3;
      break;
    case 4:
      v3 = *(_DWORD *)(a1 + 1052) == 0;
      ppvObj = (void *)1;
      if ( v3 )
      {
        sub_455D20(a1);
        *(_DWORD *)(a1 + 1052) = 1;
      }
      break;
    case 5:
      ppvObj = (void *)4;
      sub_45C9E0(a1);
      break;
    case 6:
      v3 = *(_DWORD *)(a1 + 960) == 0;
      ppvObj = 0;
      if ( v3 )
        sub_45C3C0(a1);
      break;
    default:
      a2 = 1;
LABEL_18:
      ppvObj = 0;
      break;
  }
  v4 = *(HWND *)(a1 + 28);
  *(_DWORD *)(a1 + 636) = a2;
  if ( a2 == 4 )
  {
    v9 = *(_DWORD *)(a1 + 752);
    v5 = SendMessageW(v4, 0x1037u, 0, 0);
    if ( v9 )
    {
      v5 |= 1u;
      goto LABEL_23;
    }
  }
  else
  {
    v5 = SendMessageW(v4, 0x1037u, 0, 0);
  }
  if ( (v5 & 1) != 0 )
    v5 &= ~1u;
LABEL_23:
  SendMessageW(v4, 0x1036u, 0, v5);
  return SendMessageW(*(HWND *)(a1 + 28), 0x108Eu, (WPARAM)ppvObj, 0);
}

//----- (0045E220) --------------------------------------------------------
LRESULT __userpurge sub_45E220@<eax>(WPARAM a1@<edi>, _DWORD *a2@<esi>, int a3)
{
  HWND v3; // edx
  int v4; // ecx
  LRESULT result; // eax
  HWND v6; // [esp-10h] [ebp-56Ch]
  HWND v7; // [esp-10h] [ebp-56Ch]
  unsigned __int64 v8; // [esp-8h] [ebp-564h]
  LPARAM v9[2]; // [esp+4h] [ebp-558h] BYREF
  int v10; // [esp+Ch] [ebp-550h]
  WCHAR *szTypeName; // [esp+18h] [ebp-544h]
  LPARAM lParam[4]; // [esp+38h] [ebp-524h] BYREF
  int v13[2]; // [esp+48h] [ebp-514h] BYREF
  SHFILEINFOW psfi; // [esp+50h] [ebp-50Ch] BYREF
  WCHAR pszPath[260]; // [esp+308h] [ebp-254h] BYREF
  char v16; // [esp+510h] [ebp-4Ch] BYREF

  v3 = (HWND)a2[7];
  v13[1] = 2;
  lParam[2] = 2;
  v13[0] = 1;
  lParam[0] = 16;
  lParam[1] = a1;
  lParam[3] = (LPARAM)v13;
  SendMessageW(v3, 0x10A4u, 0, (LPARAM)lParam);
  (*(void (__thiscall **)(_DWORD *, WPARAM, WCHAR *))(a2[2] + 48))(a2 + 2, a1, pszPath);
  SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x400u);
  v6 = (HWND)a2[7];
  v10 = 1;
  szTypeName = psfi.szTypeName;
  SendMessageW(v6, 0x1074u, a1, (LPARAM)v9);
  v4 = a2[12];
  result = 592 * a3;
  if ( (*(_BYTE *)(592 * a3 + v4) & 0x10) == 0 )
  {
    HIDWORD(v8) = *(_DWORD *)(result + a2[12] + 28);
    LODWORD(v8) = *(_DWORD *)(result + v4 + 32);
    sub_46B2E0(0x20u, a2[168], a2[169], v8);
    v7 = (HWND)a2[7];
    v10 = 2;
    szTypeName = (WCHAR *)&v16;
    return SendMessageW(v7, 0x1074u, a1, (LPARAM)v9);
  }
  return result;
}

//----- (0045E360) --------------------------------------------------------
LRESULT __usercall sub_45E360@<eax>(int a1@<esi>)
{
  LRESULT result; // eax
  signed int v2; // edi
  int v3; // edx
  HWND v4; // [esp-10h] [ebp-5A8h]
  HWND v5; // [esp-10h] [ebp-5A8h]
  HWND v6; // [esp-10h] [ebp-5A8h]
  HWND v7; // [esp-10h] [ebp-5A8h]
  LPARAM v8; // [esp+8h] [ebp-590h]
  LRESULT i; // [esp+Ch] [ebp-58Ch]
  int v10[2]; // [esp+10h] [ebp-588h] BYREF
  LPARAM v11[4]; // [esp+18h] [ebp-580h] BYREF
  LPARAM v12[2]; // [esp+28h] [ebp-570h] BYREF
  int v13; // [esp+30h] [ebp-568h]
  WCHAR *szTypeName; // [esp+3Ch] [ebp-55Ch]
  LPARAM lParam[13]; // [esp+5Ch] [ebp-53Ch] BYREF
  SHFILEINFOW psfi; // [esp+90h] [ebp-508h] BYREF
  char v17; // [esp+348h] [ebp-250h] BYREF
  WCHAR pszPath[262]; // [esp+388h] [ebp-210h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 28), 0x1004u, 0, 0);
  v2 = 0;
  for ( i = result; v2 < i; ++v2 )
  {
    v4 = *(HWND *)(a1 + 28);
    lParam[0] = 4;
    lParam[1] = v2;
    lParam[2] = 0;
    result = SendMessageW(v4, 0x104Bu, 0, (LPARAM)lParam);
    if ( result )
    {
      v8 = lParam[8];
      v10[1] = 2;
      v11[2] = 2;
      v5 = *(HWND *)(a1 + 28);
      v10[0] = 1;
      v11[0] = 16;
      v11[1] = v2;
      v11[3] = (LPARAM)v10;
      SendMessageW(v5, 0x10A4u, 0, (LPARAM)v11);
      (*(void (__thiscall **)(int, signed int, WCHAR *))(*(_DWORD *)(a1 + 8) + 48))(a1 + 8, v2, pszPath);
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x400u);
      v6 = *(HWND *)(a1 + 28);
      v13 = 1;
      szTypeName = psfi.szTypeName;
      SendMessageW(v6, 0x1074u, v2, (LPARAM)v12);
      v3 = *(_DWORD *)(a1 + 48);
      result = 592 * v8;
      if ( (*(_BYTE *)(592 * v8 + v3) & 0x10) == 0 )
      {
        sub_46B2E0(
          0x20u,
          *(_DWORD *)(a1 + 672),
          *(_DWORD *)(a1 + 676),
          __PAIR64__(*(_DWORD *)(result + v3 + 28), *(_DWORD *)(result + v3 + 32)));
        v7 = *(HWND *)(a1 + 28);
        v13 = 2;
        szTypeName = (WCHAR *)&v17;
        result = SendMessageW(v7, 0x1074u, v2, (LPARAM)v12);
      }
    }
  }
  return result;
}

//----- (0045E4F0) --------------------------------------------------------
int __thiscall sub_45E4F0(ULONG_PTR dwData, int a2)
{
  int v2; // ebx
  int v4; // eax
  int v6; // ebx
  int i; // ebx
  int v8; // edi
  char **v9; // eax
  int v10; // ecx
  int v11; // [esp-Ch] [ebp-14h]

  v2 = a2;
  v4 = *(_DWORD *)(dwData + 636);
  if ( a2 == v4 )
    return 1;
  if ( v4 == 6 && a2 != 6 )
    sub_45C300(dwData);
  sub_45E060(dwData, v2);
  v6 = v2 - 4;
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      sub_45E360(dwData);
      return 0;
    }
  }
  else
  {
    for ( i = 0; i < *(_DWORD *)(dwData + 680); *(_DWORD *)v9[1] = v9 )
    {
      v8 = *(_DWORD *)(dwData + 880);
      v11 = *(_DWORD *)(v8 + 4);
      a2 = i;
      v9 = sub_40A550((char *)v8, v11, (int)&a2);
      v10 = *(_DWORD *)(dwData + 884);
      if ( v10 == 1073741822 )
        std::vector<void *>::_Xlen(a2);
      *(_DWORD *)(dwData + 884) = v10 + 1;
      *(_DWORD *)(v8 + 4) = v9;
      ++i;
    }
    QueueUserAPC(sub_458A80, *(HANDLE *)(dwData + 60), dwData);
    if ( *(_DWORD *)(dwData + 660) )
      QueueUserAPC(sub_4574E0, *(HANDLE *)(dwData + 64), dwData);
  }
  return 0;
}
// 45E5C1: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);

//----- (0045E5D0) --------------------------------------------------------
int __stdcall sub_45E5D0(int a1, int a2)
{
  return -2147467263;
}

//----- (0045E5E0) --------------------------------------------------------
int __stdcall sub_45E5E0(int a1)
{
  *(_DWORD *)(a1 + 20) = 0;
  return 0;
}

//----- (0045E600) --------------------------------------------------------
int __stdcall sub_45E600(int a1, int a2)
{
  *(_DWORD *)(a1 + 20) += a2;
  return 0;
}

//----- (0045E620) --------------------------------------------------------
LONG __stdcall sub_45E620(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 + 4));
}

//----- (0045E640) --------------------------------------------------------
int __stdcall sub_45E640(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // edx
  _DWORD *v6; // ecx
  _DWORD *v7; // esi
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // esi

  v4 = a1[5];
  if ( v4 < a1[6] )
  {
    v6 = (_DWORD *)a1[2];
    v7 = (_DWORD *)*v6;
    v8 = 0;
    if ( (_DWORD *)*v6 != v6 )
    {
      while ( v8 != v4 )
      {
        v7 = (_DWORD *)*v7;
        ++v8;
        if ( v7 == v6 )
          goto LABEL_15;
      }
      *a3 = v7[2];
      a3[1] = v7[3];
      a3[2] = v7[4];
      a3[3] = v7[5];
      a3[4] = v7[6];
      if ( v7[3] )
      {
        v9 = CoTaskMemAlloc(0x10u);
        a3[1] = v9;
        if ( !v9 )
          return 1;
        v10 = (_DWORD *)v7[3];
        if ( v10 )
        {
          *v9 = *v10;
          v9[1] = v10[1];
          v9[2] = v10[2];
          v9[3] = v10[3];
        }
        else
        {
          a3[1] = 0;
        }
      }
    }
LABEL_15:
    ++a1[5];
    if ( a4 )
      *a4 = 1;
    return 0;
  }
  else
  {
    if ( a4 )
      *a4 = 0;
    return 1;
  }
}

//----- (0045E700) --------------------------------------------------------
int __stdcall sub_45E700(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = 0;
  if ( !sub_40AA20(dword_4BD9EC, a2) && !sub_40AA20(&stru_4BD95C, a2) )
    return -2147467262;
  *a3 = a1;
  if ( !a1 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}
// 4BD9EC: using guessed type _DWORD dword_4BD9EC[4];

//----- (0045E760) --------------------------------------------------------
void __usercall sub_45E760(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi

  *(_DWORD *)a1 = &CEnumFormatEtc::`vftable';
  v1 = *(_DWORD ***)(a1 + 8);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  if ( v2 != *(_DWORD **)(a1 + 8) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 8) );
  }
  operator delete(*(void **)(a1 + 8));
}
// 4CC4AC: using guessed type void *CEnumFormatEtc::`vftable';

//----- (0045E7A0) --------------------------------------------------------
LONG __stdcall sub_45E7A0(void *a1)
{
  LONG result; // eax

  result = InterlockedDecrement((volatile LONG *)a1 + 1);
  if ( !result )
  {
    if ( a1 )
    {
      sub_45E760((int)a1);
      operator delete(a1);
    }
    return 0;
  }
  return result;
}

//----- (0045E7D0) --------------------------------------------------------
int __stdcall sub_45E7D0(int a1, void *a2, int a3, int a4)
{
  _DWORD *v4; // eax
  void ***v5; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // esi
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  _DWORD *v11; // eax
  char **v12; // eax
  int v13; // ecx
  void **v14; // ecx
  void *v15; // eax
  void **v16; // esi
  int v18; // [esp-4h] [ebp-60h]
  char *v19; // [esp+24h] [ebp-38h] BYREF
  _DWORD *v20; // [esp+28h] [ebp-34h]
  int v21; // [esp+2Ch] [ebp-30h]
  int v22; // [esp+30h] [ebp-2Ch]
  int v23; // [esp+34h] [ebp-28h]
  int pExceptionObject[3]; // [esp+38h] [ebp-24h] BYREF
  char *v25; // [esp+44h] [ebp-18h] BYREF
  _DWORD *v26; // [esp+48h] [ebp-14h]
  char *v27; // [esp+4Ch] [ebp-10h]
  int v28; // [esp+58h] [ebp-4h]

  v28 = 0;
  *(_DWORD *)a1 = &CEnumFormatEtc::`vftable';
  *(_DWORD *)(a1 + 12) = 0;
  v4 = operator new(0x1Cu);
  if ( !v4 )
  {
    v25 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 8) = v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) = *(_DWORD *)(a1 + 8);
  LOBYTE(v28) = 1;
  v5 = (void ***)a2;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 20) = 0;
  v6 = *(_DWORD **)a2;
  v26 = a2;
  if ( v6 != a2 )
  {
    do
    {
      v7 = (_DWORD *)v6[3];
      v8 = v6[4];
      v19 = (char *)v6[2];
      v9 = v6[5];
      v20 = v7;
      v10 = v6[6];
      v21 = v8;
      v22 = v9;
      v23 = v10;
      if ( v7 )
      {
        v11 = CoTaskMemAlloc(0x10u);
        v20 = v11;
        if ( v11 )
        {
          *v11 = *v7;
          v11[1] = v7[1];
          v11[2] = v7[2];
          v11[3] = v7[3];
        }
      }
      else
      {
        v20 = 0;
      }
      v18 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4);
      v27 = *(char **)(a1 + 8);
      v12 = sub_416060(&v19, v27, v18);
      v13 = *(_DWORD *)(a1 + 12);
      if ( v13 == 214748363 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 12) = v13 + 1;
      *((_DWORD *)v27 + 1) = v12;
      *(_DWORD *)v12[1] = v12;
      v6 = (_DWORD *)*v6;
    }
    while ( v6 != v26 );
    v5 = (void ***)a2;
  }
  *(_DWORD *)(a1 + 24) = a3;
  v14 = *v5;
  *v5 = (void **)v5;
  *((_DWORD *)a2 + 1) = a2;
  v15 = a2;
  if ( v14 != a2 )
  {
    do
    {
      v16 = (void **)*v14;
      operator delete(v14);
      v15 = a2;
      v14 = v16;
    }
    while ( v16 != a2 );
  }
  operator delete(v15);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC4AC: using guessed type void *CEnumFormatEtc::`vftable';

//----- (0045E980) --------------------------------------------------------
int __cdecl sub_45E980(void *a1, int a2, int a3, int a4)
{
  char **v4; // esi
  int v5; // eax
  void ***v6; // ecx
  void **v7; // eax
  void *v8; // ecx
  void **v9; // esi
  char **v11[10]; // [esp-Ch] [ebp-28h] BYREF

  v11[9] = (char **)1;
  v4 = (char **)operator new(0x1Cu);
  v11[6] = v4;
  if ( v4 )
  {
    v11[5] = (char **)v11;
    sub_41A1F0(v11, (int **)&a1);
    v5 = sub_45E7D0((int)v4, v11[0], (int)v11[1], (int)v11[2]);
  }
  else
  {
    v5 = 0;
  }
  v6 = (void ***)a1;
  *(_DWORD *)a4 = v5;
  v7 = *v6;
  *v6 = (void **)v6;
  *((_DWORD *)a1 + 1) = a1;
  v8 = a1;
  a2 = 0;
  if ( v7 != a1 )
  {
    do
    {
      v9 = (void **)*v7;
      operator delete(v7);
      v8 = a1;
      v7 = v9;
    }
    while ( v9 != a1 );
  }
  operator delete(v8);
  return 0;
}

//----- (0045EA30) --------------------------------------------------------
void __stdcall sub_45EA30(ULONG_PTR Parameter)
{
  CancelIo((HANDLE)Parameter);
  CloseHandle((HANDLE)Parameter);
}

//----- (0045EA50) --------------------------------------------------------
void __stdcall sub_45EA50(ULONG_PTR Parameter)
{
  void *v1; // edi
  void *v2; // eax
  BOOL DirectoryChangesW; // eax
  int v4; // [esp-14h] [ebp-1Ch]
  DWORD v5; // [esp-10h] [ebp-18h]

  v1 = *(void **)(Parameter + 16);
  if ( v1 == (void *)-1 )
  {
    free(*(void **)(Parameter + 40));
  }
  else
  {
    v2 = malloc(0x3E80u);
    v5 = *(_DWORD *)(Parameter + 564);
    v4 = *(_DWORD *)(Parameter + 568);
    *(_DWORD *)(Parameter + 8) = v2;
    DirectoryChangesW = ReadDirectoryChangesW(
                          v1,
                          v2,
                          0x3E80u,
                          v4,
                          v5,
                          0,
                          (LPOVERLAPPED)(Parameter + 20),
                          CompletionRoutine);
    *(_DWORD *)(Parameter + 576) = DirectoryChangesW;
    if ( !DirectoryChangesW )
    {
      free(*(void **)(Parameter + 8));
      CancelIo(*(HANDLE *)(Parameter + 16));
      CloseHandle(*(HANDLE *)(Parameter + 16));
    }
  }
}

//----- (0045EAE0) --------------------------------------------------------
void __stdcall __noreturn sub_45EAE0(ULONG_PTR Parameter)
{
  SetEvent(*(HANDLE *)(Parameter + 52));
  ExitThread(0);
}

//----- (0045EB00) --------------------------------------------------------
void __stdcall __noreturn sub_45EB00(LPVOID lpThreadParameter)
{
  SetErrorMode(1u);
  while ( 1 )
    SleepEx(0xFFFFFFFF, 1);
}

//----- (0045EB20) --------------------------------------------------------
int __stdcall sub_45EB20(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (0045EB70) --------------------------------------------------------
int __thiscall sub_45EB70(int this, int a2)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // eax

  if ( a2 < 0 )
    return 0;
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v4 = *(_DWORD **)(this + 16);
  v5 = (_DWORD *)*v4;
  if ( (_DWORD *)*v4 != v4 )
  {
    while ( v5[147] != a2 )
    {
      v5 = (_DWORD *)*v5;
      if ( v5 == v4 )
        goto LABEL_9;
    }
    if ( v5[146] )
      QueueUserAPC(sub_45EA30, *(HANDLE *)(this + 12), v5[6]);
  }
LABEL_9:
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  return 1;
}

//----- (0045EBF0) --------------------------------------------------------
void __usercall sub_45EBF0(int a1@<eax>)
{
  int v2; // edi
  void **v3; // ecx
  void **v4; // eax
  void *v5; // esi

  v2 = *(_DWORD *)(a1 + 4);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 40));
  EnterCriticalSection((LPCRITICAL_SECTION)(v2 + 28));
  v3 = *(void ***)(v2 + 16);
  v4 = (void **)*v3;
  if ( *v3 != v3 )
  {
    v5 = *(void **)(a1 + 580);
    while ( v4[147] != v5 )
    {
      v4 = (void **)*v4;
      if ( v4 == v3 )
        goto LABEL_8;
    }
    if ( v4 != v3 )
    {
      *(_DWORD *)v4[1] = *v4;
      *((_DWORD *)*v4 + 1) = v4[1];
      operator delete(v4);
      --*(_DWORD *)(v2 + 20);
    }
  }
LABEL_8:
  LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 28));
}

//----- (0045EC70) --------------------------------------------------------
void __stdcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
{
  HANDLE hEvent; // edi
  int *v4; // esi
  int i; // eax
  unsigned int v6; // edx
  unsigned int v7; // edx
  __int16 v8[260]; // [esp+0h] [ebp-20Ch] BYREF

  if ( dwErrorCode )
  {
    if ( dwErrorCode == 995 )
      sub_45EBF0((int)lpOverlapped->hEvent);
  }
  else if ( dwNumberOfBytesTransfered )
  {
    hEvent = lpOverlapped->hEvent;
    if ( hEvent )
    {
      v4 = (int *)*((_DWORD *)hEvent + 2);
      if ( (unsigned int)v4[2] >> 1 == 0x7FFFFFFF )
        v8[0] = 0;
      else
        sub_467DC0(260, (unsigned int)v4[2] >> 1, v8, (int)(v4 + 3));
      (*(void (__cdecl **)(__int16 *, int, _DWORD))hEvent)(v8, v4[1], *((_DWORD *)hEvent + 10));
      for ( i = *v4; *v4; i = *v4 )
      {
        v6 = *(int *)((char *)v4 + i + 8);
        v4 = (int *)((char *)v4 + i);
        v7 = v6 >> 1;
        if ( v7 <= 0x7FFFFFFE )
          sub_467DC0(260, v7, v8, (int)(v4 + 3));
        else
          v8[0] = 0;
        (*(void (__cdecl **)(__int16 *, int, _DWORD))hEvent)(v8, v4[1], *((_DWORD *)hEvent + 10));
      }
      free(*((void **)hEvent + 2));
      *((_DWORD *)hEvent + 2) = 0;
      sub_45EA50((ULONG_PTR)hEvent);
    }
  }
}

//----- (0045ED90) --------------------------------------------------------
void __usercall sub_45ED90(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  void *v7; // [esp-4h] [ebp-10h]
  ULONG_PTR v8; // [esp+0h] [ebp-Ch]

  v7 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &CDirectoryMonitor::`vftable';
  QueueUserAPC((PAPCFUNC)sub_45EAE0, v7, v8);
  CloseHandle(*(HANDLE *)(a1 + 12));
  WaitForSingleObject(*(HANDLE *)(a1 + 52), 0xFFFFFFFF);
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 28));
  v1 = *(_DWORD ***)(a1 + 16);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  if ( v2 != *(_DWORD **)(a1 + 16) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 16) );
  }
  CloseHandle(*(HANDLE *)(a1 + 52));
  v4 = *(_DWORD ***)(a1 + 16);
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  if ( v5 != *(_DWORD **)(a1 + 16) )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != *(_DWORD **)(a1 + 16) );
  }
  operator delete(*(void **)(a1 + 16));
}
// 45EDA2: variable 'v8' is possibly undefined
// 4CC490: using guessed type void *CDirectoryMonitor::`vftable';

//----- (0045EE40) --------------------------------------------------------
int __usercall sub_45EE40@<eax>(int a1@<esi>)
{
  _DWORD *v1; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v4; // [esp+Ch] [ebp-4h] BYREF

  *(_DWORD *)a1 = &CDirectoryMonitor::`vftable';
  *(_DWORD *)(a1 + 20) = 0;
  v1 = operator new(0x250u);
  if ( !v1 )
  {
    v4 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 16) = v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 12) = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_45EB00, 0, 0, (LPDWORD)(a1 + 8));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 28));
  *(_DWORD *)(a1 + 52) = CreateEventW(0, 1, 0, 0);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC490: using guessed type void *CDirectoryMonitor::`vftable';

//----- (0045EEF0) --------------------------------------------------------
int __usercall sub_45EEF0@<eax>(int *a1@<edi>)
{
  void *v1; // eax
  int result; // eax

  v1 = operator new(0x3Cu);
  if ( v1 )
  {
    *a1 = sub_45EE40((int)v1);
    return 0;
  }
  else
  {
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (0045EF60) --------------------------------------------------------
int __thiscall sub_45EF60(int this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  int v9; // edx
  char *v10; // eax
  int v11; // edi
  __int16 v12; // cx
  int v13; // edi
  char **v14; // eax
  int v15; // ecx
  int v16[11]; // [esp+10h] [ebp-250h] BYREF
  char v17[520]; // [esp+3Ch] [ebp-224h] BYREF
  int v18; // [esp+244h] [ebp-1Ch]
  int v19; // [esp+248h] [ebp-18h]
  int v20; // [esp+24Ch] [ebp-14h]
  int v21; // [esp+254h] [ebp-Ch]

  if ( !a3 )
    return -1;
  v16[3] = *(_DWORD *)(this + 12);
  v18 = a4;
  v9 = *(_DWORD *)(this + 56);
  v16[0] = a5;
  v16[1] = this;
  v21 = v9;
  v16[10] = a7;
  v19 = a6;
  v20 = 0;
  SetErrorMode(1u);
  v10 = v17;
  v11 = 260;
  while ( v11 != -2147483386 )
  {
    v12 = *(_WORD *)&v10[a3 - (_DWORD)v17];
    if ( !v12 )
      break;
    *(_WORD *)v10 = v12;
    v10 += 2;
    if ( !--v11 )
    {
      v10 -= 2;
      break;
    }
  }
  *(_WORD *)v10 = 0;
  v16[4] = a2;
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v13 = *(_DWORD *)(this + 16);
  v14 = sub_41A4A0((char *)v13, *(_DWORD *)(v13 + 4), (int)v16);
  v15 = *(_DWORD *)(this + 20);
  if ( v15 == 7354395 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 20) = v15 + 1;
  *(_DWORD *)(v13 + 4) = v14;
  *(_DWORD *)v14[1] = v14;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 44) = *(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 8;
  QueueUserAPC(sub_45EA50, *(HANDLE *)(this + 12), *(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 8);
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  result = *(_DWORD *)(this + 56);
  *(_DWORD *)(this + 56) = result + 1;
  return result;
}
// 45F020: conditional instruction was optimized away because edi.4!=0

//----- (0045F0C0) --------------------------------------------------------
int __thiscall sub_45F0C0(int this, int a2, int a3, int a4, int a5, void *a6)
{
  int v7; // edx
  WCHAR *v8; // eax
  int v9; // edi
  WCHAR v10; // cx
  int result; // eax
  int v12; // edi
  char **v13; // eax
  int v14; // ecx
  int v15[4]; // [esp+10h] [ebp-250h] BYREF
  HANDLE FileW; // [esp+20h] [ebp-240h]
  void *v17; // [esp+38h] [ebp-228h]
  WCHAR FileName[260]; // [esp+3Ch] [ebp-224h] BYREF
  int v19; // [esp+244h] [ebp-1Ch]
  int v20; // [esp+248h] [ebp-18h]
  int v21; // [esp+24Ch] [ebp-14h]
  int v22; // [esp+254h] [ebp-Ch]

  if ( !a2 )
    return -1;
  v15[3] = *(_DWORD *)(this + 12);
  v19 = a3;
  v7 = *(_DWORD *)(this + 56);
  v15[0] = a4;
  v15[1] = this;
  v22 = v7;
  v17 = a6;
  v20 = a5;
  v21 = 0;
  SetErrorMode(1u);
  v8 = FileName;
  v9 = 260;
  while ( v9 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)v8 + a2 - (_DWORD)FileName);
    if ( !v10 )
      break;
    *v8++ = v10;
    if ( !--v9 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  FileW = CreateFileW(FileName, 1u, 7u, 0, 3u, 0x42000000u, 0);
  if ( FileW == (HANDLE)-1 )
  {
    free(a6);
    return -1;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v12 = *(_DWORD *)(this + 16);
  v13 = sub_41A4A0((char *)v12, *(_DWORD *)(v12 + 4), (int)v15);
  v14 = *(_DWORD *)(this + 20);
  if ( v14 == 7354395 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 20) = v14 + 1;
  *(_DWORD *)(v12 + 4) = v13;
  *(_DWORD *)v13[1] = v13;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 44) = *(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 8;
  QueueUserAPC(sub_45EA50, *(HANDLE *)(this + 12), *(_DWORD *)(*(_DWORD *)(this + 16) + 4) + 8);
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  result = *(_DWORD *)(this + 56);
  *(_DWORD *)(this + 56) = result + 1;
  return result;
}
// 45F170: conditional instruction was optimized away because edi.4!=0

//----- (0045F250) --------------------------------------------------------
int __stdcall sub_45F250(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    sub_45ED90((int)a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (0045F280) --------------------------------------------------------
int __stdcall sub_45F280(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = 0;
  if ( !sub_40AA20(&stru_4BD95C, a2) )
    return -2147467262;
  *a3 = a1;
  if ( !a1 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}

//----- (0045F380) --------------------------------------------------------
BOOL __userpurge sub_45F380@<eax>(int a1@<edi>, UINT iFile)
{
  int v2; // eax
  BOOL IsSameRootW; // esi
  HDROP v4; // eax
  HDROP v5; // ebx
  __int16 v7; // [esp+4h] [ebp-22Ch] BYREF
  int v8; // [esp+8h] [ebp-228h]
  int v9; // [esp+Ch] [ebp-224h]
  int v10; // [esp+10h] [ebp-220h]
  int v11; // [esp+14h] [ebp-21Ch]
  STGMEDIUM v12; // [esp+18h] [ebp-218h] BYREF
  WCHAR szFile[260]; // [esp+24h] [ebp-20Ch] BYREF

  v7 = 15;
  v9 = 1;
  v11 = 1;
  v2 = *(_DWORD *)(a1 + 8);
  IsSameRootW = 0;
  v8 = 0;
  v10 = -1;
  if ( !(*(int (__stdcall **)(int, __int16 *, STGMEDIUM *))(*(_DWORD *)v2 + 12))(v2, &v7, &v12) )
  {
    v4 = (HDROP)GlobalLock(v12.hBitmap);
    v5 = v4;
    if ( v4 )
    {
      if ( (int)iFile < (int)DragQueryFileW(v4, 0xFFFFFFFF, 0, 0) )
      {
        DragQueryFileW(v5, iFile, szFile, 0x104u);
        IsSameRootW = PathIsSameRootW(*(LPCWSTR *)(a1 + 40), szFile);
      }
      GlobalUnlock(v12.hBitmap);
    }
    ReleaseStgMedium(&v12);
  }
  return IsSameRootW;
}

//----- (0045F470) --------------------------------------------------------
LRESULT __stdcall sub_45F470(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  if ( uMsg != 32769 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)wParam + 28))(
    *(_DWORD *)wParam,
    *(_DWORD *)(wParam + 4),
    0,
    *(_DWORD *)(wParam + 8));
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)wParam + 8))(*(_DWORD *)wParam);
  RemoveWindowSubclass(hWnd, sub_45F470, 0x2710u);
  return 0;
}

//----- (0045F4E0) --------------------------------------------------------
int __usercall sub_45F4E0@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // ebx
  int v3; // eax
  int v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+4h] [ebp-14h]
  STGMEDIUM v7; // [esp+Ch] [ebp-Ch] BYREF

  v2 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = -1;
  v3 = (*(int (__stdcall **)(int, int))(*(_DWORD *)a1 + 20))(v5, v6);
  *(_DWORD *)(a2 + 12) = v2;
  if ( v3 || (*(int (__stdcall **)(int, int, STGMEDIUM *))(*(_DWORD *)a1 + 12))(a1, a2, &v7) )
    return 0;
  ReleaseStgMedium(&v7);
  return 1;
}
// 45F4F8: variable 'v5' is possibly undefined
// 45F4F8: variable 'v6' is possibly undefined

//----- (0045F570) --------------------------------------------------------
HRESULT __stdcall sub_45F570(LPSTGMEDIUM a1)
{
  HRESULT v1; // esi
  unsigned int *v2; // eax
  unsigned int *v3; // edi
  const ITEMIDLIST *v4; // eax
  _DWORD *v5; // ebx
  unsigned int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h] BYREF
  IShellFolder *v9; // [esp+14h] [ebp-4h] BYREF

  v1 = 0;
  v2 = (unsigned int *)GlobalLock(a1->hBitmap);
  v3 = v2;
  if ( v2 )
  {
    v4 = (const ITEMIDLIST *)((char *)v2 + v2[1]);
    v9 = 0;
    v1 = sub_466830(v4, &v9);
    if ( v1 >= 0 )
    {
      v8 = 0;
      v7 = 0;
      if ( *v3 )
      {
        v5 = v3 + 2;
        do
        {
          v1 = v9->lpVtbl->BindToStorage(v9, (LPCITEMIDLIST)((char *)v3 + *v5), 0, &stru_4BD9CC, (void **)&v8);
          if ( v1 >= 0 )
            (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
          ++v5;
          ++v7;
        }
        while ( v7 < *v3 );
      }
      v9->lpVtbl->Release(v9);
    }
    GlobalUnlock(a1->hBitmap);
  }
  ReleaseStgMedium(a1);
  return v1;
}

//----- (0045F620) --------------------------------------------------------
int __userpurge sub_45F620@<eax>(_WORD *a1@<ecx>, const WCHAR *a2@<esi>, const WCHAR *a3)
{
  int i; // edi
  int v4; // eax
  HANDLE FileW; // edi
  int v6; // eax
  _WORD *v7; // eax
  int v8; // edi
  char *v9; // edx
  __int16 v10; // cx
  struct _FILETIME FileTime; // [esp+8h] [ebp-844h] BYREF
  FILETIME v13; // [esp+10h] [ebp-83Ch] BYREF
  _WORD *v14; // [esp+18h] [ebp-834h]
  LPCWSTR pszDir; // [esp+1Ch] [ebp-830h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+20h] [ebp-82Ch] BYREF
  WCHAR pszFile[260]; // [esp+30h] [ebp-81Ch] BYREF
  WCHAR pszDest[260]; // [esp+238h] [ebp-614h] BYREF
  __int16 String[514]; // [esp+440h] [ebp-40Ch] BYREF

  pszDir = a3;
  v14 = a1;
  GetLocalTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  LocalFileTimeToFileTime(&FileTime, &v13);
  sub_46AB90(String, 512, &v13, 0);
  for ( i = 0; i < lstrlenW((LPCWSTR)String); ++i )
  {
    v4 = (unsigned __int16)String[i];
    if ( v4 == 47 )
    {
      String[i] = 45;
    }
    else if ( v4 == 58 )
    {
      String[i] = 46;
    }
  }
  sub_401000(0x104u, pszFile, L"Clipboard Text (%s).txt", String);
  PathCombineW(pszDest, pszDir, pszFile);
  FileW = CreateFileW(pszDest, 0x40000000u, 0, 0, 1u, 0x80u, 0);
  if ( FileW == (HANDLE)-1 )
    return -2147467259;
  v6 = lstrlenW(a2);
  WriteFile(FileW, a2, 2 * v6, (LPDWORD)&pszDir, 0);
  CloseHandle(FileW);
  v7 = v14;
  v8 = 260;
  v9 = (char *)((char *)pszDest - (char *)v14);
  while ( v8 != -2147483386 )
  {
    v10 = *(_WORD *)((char *)v7 + (_DWORD)v9);
    if ( !v10 )
      break;
    *v7++ = v10;
    if ( !--v8 )
    {
      *(v7 - 1) = 0;
      return 0;
    }
  }
  *v7 = 0;
  return 0;
}
// 45F7BB: conditional instruction was optimized away because edi.4!=0
// 4C2A90: using guessed type wchar_t aClipboardTextS[24];
// 45F620: using guessed type WCHAR String[514];

//----- (0045F7F0) --------------------------------------------------------
void __usercall sub_45F7F0(_DWORD *a1@<esi>)
{
  int v1; // edi
  LPVOID pv; // [esp+8h] [ebp-14h] BYREF
  IShellFolder *ppshf; // [esp+Ch] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-Ch] BYREF
  int v5; // [esp+14h] [ebp-8h] BYREF
  int v6; // [esp+18h] [ebp-4h] BYREF

  v1 = a1[10];
  ppshf = 0;
  v4 = 0;
  v6 = 0;
  pv = 0;
  if ( sub_467810((LPITEMIDLIST *)&pv, v1) >= 0 )
  {
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      if ( ppshf->lpVtbl->BindToObject(ppshf, (LPCITEMIDLIST)pv, 0, &stru_4BD7FC, (void **)&v4) >= 0 )
      {
        v5 = a1[7];
        if ( (*(int (__stdcall **)(int, _DWORD, void *, int *))(*(_DWORD *)v4 + 32))(v4, a1[8], &unk_4BD94C, &v6) >= 0 )
        {
          (*(void (__stdcall **)(int, _DWORD, int, _DWORD, _DWORD, int *))(*(_DWORD *)v6 + 12))(
            v6,
            a1[2],
            2,
            a1[5],
            a1[6],
            &v5);
          v5 = a1[7];
          (*(void (__stdcall **)(int, _DWORD, _DWORD, _DWORD, _DWORD, int *))(*(_DWORD *)v6 + 24))(
            v6,
            a1[2],
            a1[4],
            a1[5],
            a1[6],
            &v5);
          (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 20))(v6);
          (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
      }
      ppshf->lpVtbl->Release(ppshf);
    }
    CoTaskMemFree(pv);
  }
}

//----- (0045F8F0) --------------------------------------------------------
int __usercall sub_45F8F0@<eax>(int a1@<edi>)
{
  char *v1; // ebx
  char **v2; // eax
  int v3; // ecx
  char *v4; // ebx
  char **v5; // eax
  int v6; // ecx
  char *v7; // ebx
  char **v8; // eax
  int v9; // ecx
  char *v10; // ebx
  char **v11; // eax
  int v12; // ecx
  char *v13; // ebx
  char **v14; // eax
  int v15; // ecx
  char *v16; // ebx
  char **v17; // eax
  int v18; // ecx

  v1 = *(char **)a1;
  v2 = sub_416060((char **)&unk_4DFE5C, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v3 + 1;
  *((_DWORD *)v1 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v4 = *(char **)a1;
  v5 = sub_416060((char **)&word_4EF73C, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v6 = *(_DWORD *)(a1 + 4);
  if ( v6 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v6 + 1;
  *((_DWORD *)v4 + 1) = v5;
  *(_DWORD *)v5[1] = v5;
  v7 = *(char **)a1;
  v8 = sub_416060((char **)&word_4EF750, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v9 = *(_DWORD *)(a1 + 4);
  if ( v9 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v9 + 1;
  *((_DWORD *)v7 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v10 = *(char **)a1;
  v11 = sub_416060((char **)&unk_4DFE70, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v12 = *(_DWORD *)(a1 + 4);
  if ( v12 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v12 + 1;
  *((_DWORD *)v10 + 1) = v11;
  *(_DWORD *)v11[1] = v11;
  v13 = *(char **)a1;
  v14 = sub_416060((char **)&unk_4DFE84, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v15 = *(_DWORD *)(a1 + 4);
  if ( v15 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v15 + 1;
  *((_DWORD *)v13 + 1) = v14;
  *(_DWORD *)v14[1] = v14;
  v16 = *(char **)a1;
  v17 = sub_416060((char **)&unk_4DFE98, *(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4));
  v18 = *(_DWORD *)(a1 + 4);
  if ( v18 == 214748363 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 4) = v18 + 1;
  *((_DWORD *)v16 + 1) = v17;
  *(_DWORD *)v17[1] = v17;
  return 0;
}
// 4EF73C: using guessed type __int16 word_4EF73C;
// 4EF750: using guessed type __int16 word_4EF750;

//----- (0045FA40) --------------------------------------------------------
void __thiscall sub_45FA40(void *Src, int a2)
{
  WCHAR *v3; // eax
  int v4; // edx
  int v5; // esi
  WCHAR v6; // cx
  WCHAR *p_Srca; // eax
  int v8; // edx
  int v9; // esi
  WCHAR v10; // cx
  void *v11[5]; // [esp+10h] [ebp-474h] BYREF
  unsigned int v12; // [esp+24h] [ebp-460h]
  void *v13[4]; // [esp+2Ch] [ebp-458h] BYREF
  int v14; // [esp+3Ch] [ebp-448h]
  unsigned int v15; // [esp+40h] [ebp-444h]
  void *v16[4]; // [esp+48h] [ebp-43Ch] BYREF
  int v17; // [esp+58h] [ebp-42Ch]
  unsigned int v18; // [esp+5Ch] [ebp-428h]
  WCHAR Srca; // [esp+64h] [ebp-420h] BYREF
  __int16 v20; // [esp+66h] [ebp-41Eh] BYREF
  WCHAR pszPath[260]; // [esp+26Ch] [ebp-218h] BYREF
  int v22; // [esp+480h] [ebp-4h]

  v3 = pszPath;
  v4 = 260;
  v5 = (_BYTE *)Src - (_BYTE *)pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v3 + v5);
    if ( !v6 )
      break;
    *v3++ = v6;
    if ( !--v4 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  PathStripPathW(pszPath);
  PathRenameExtensionW(pszPath, L".lnk");
  p_Srca = &Srca;
  v8 = 260;
  v9 = *(_DWORD *)(a2 + 40) - (_DWORD)&Srca;
  while ( v8 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)p_Srca + v9);
    if ( !v10 )
      break;
    *p_Srca++ = v10;
    if ( !--v8 )
    {
      --p_Srca;
      break;
    }
  }
  *p_Srca = 0;
  PathAppendW(&Srca, pszPath);
  v12 = 7;
  v11[4] = 0;
  LOWORD(v11[0]) = 0;
  sub_4094F0(v11, 0, &unk_4C2A8C, 0);
  v22 = 0;
  LOWORD(v16[0]) = 0;
  v18 = 7;
  v17 = 0;
  sub_4094F0(v16, (int)&v20, &Srca, wcslen(&Srca));
  LOBYTE(v22) = 1;
  LOWORD(v13[0]) = 0;
  v15 = 7;
  v14 = 0;
  sub_4094F0(v13, (int)Src + 2, Src, wcslen((const unsigned __int16 *)Src));
  LOBYTE(v22) = 2;
  sub_4ADA30(v13, v11, v16);
  if ( v15 >= 8 )
    operator delete(v13[0]);
  v15 = 7;
  v14 = 0;
  LOWORD(v13[0]) = 0;
  if ( v18 >= 8 )
    operator delete(v16[0]);
  v18 = 7;
  v17 = 0;
  LOWORD(v16[0]) = 0;
  if ( v12 >= 8 )
    operator delete(v11[0]);
}
// 45FAA1: conditional instruction was optimized away because edx.4!=0
// 45FB00: conditional instruction was optimized away because edx.4!=0

//----- (0045FC80) --------------------------------------------------------
int __thiscall sub_45FC80(int this)
{
  _DWORD **v2; // esi
  WCHAR *v3; // edi
  FILEOP_FLAGS v4; // cx
  bool v5; // cf
  HWND v6; // edx
  const WCHAR *v7; // eax
  char *v8; // eax
  _DWORD **v9; // ebx
  _DWORD *v10; // edi
  void **v11; // esi
  WCHAR *p_pszPath; // eax
  int v13; // edx
  int v14; // esi
  WCHAR v15; // cx
  char *v16; // esi
  char *v17; // eax
  void *hNameMappings; // eax
  char *v19; // eax
  char *v20; // ebx
  WCHAR *v21; // edx
  int v22; // esi
  WCHAR *v23; // eax
  const WCHAR *v24; // eax
  WCHAR *v25; // edx
  int v26; // esi
  WCHAR *v27; // eax
  int pExceptionObject[3]; // [esp+10h] [ebp-4A8h] BYREF
  struct _SHFILEOPSTRUCTW FileOp; // [esp+1Ch] [ebp-49Ch] BYREF
  int v31; // [esp+3Ch] [ebp-47Ch]
  char *v32; // [esp+40h] [ebp-478h] BYREF
  int v33; // [esp+44h] [ebp-474h]
  int v34; // [esp+48h] [ebp-470h]
  _DWORD *v35; // [esp+4Ch] [ebp-46Ch]
  char *v36; // [esp+50h] [ebp-468h] BYREF
  int v37; // [esp+54h] [ebp-464h]
  int v38; // [esp+5Ch] [ebp-45Ch]
  void *v39[5]; // [esp+60h] [ebp-458h] BYREF
  unsigned int v40; // [esp+74h] [ebp-444h]
  void *v41[5]; // [esp+7Ch] [ebp-43Ch] BYREF
  unsigned int v42; // [esp+90h] [ebp-428h]
  WCHAR String1[260]; // [esp+98h] [ebp-420h] BYREF
  WCHAR pszPath; // [esp+2A0h] [ebp-218h] BYREF
  __int16 v45; // [esp+2A2h] [ebp-216h] BYREF
  int v46; // [esp+4B4h] [ebp-4h]

  v2 = (_DWORD **)(this + 8);
  v31 = this;
  v3 = sub_4ADF80((_DWORD **)(this + 8));
  v4 = 32;
  if ( *(_DWORD *)(this + 52) )
    v4 = 40;
  v5 = *(_DWORD *)(this + 40) < 8u;
  v6 = *(HWND *)(this + 4);
  FileOp.wFunc = (*(_DWORD *)(this + 48) != 0) + 1;
  v7 = (const WCHAR *)(this + 20);
  FileOp.hwnd = v6;
  FileOp.pFrom = v3;
  if ( !v5 )
    v7 = *(const WCHAR **)v7;
  FileOp.fFlags = v4;
  FileOp.pTo = v7;
  if ( SHFileOperationW(&FileOp) || (v34 = 1, FileOp.fAnyOperationsAborted) )
    v34 = 0;
  free(v3);
  if ( v34 )
  {
    v37 = 0;
    v8 = (char *)operator new(0x24u);
    if ( !v8 )
    {
      v32 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v32);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v36 = v8;
    *(_DWORD *)v8 = v8;
    *((_DWORD *)v36 + 1) = v36;
    v46 = 0;
    v9 = (_DWORD **)*v2;
    v10 = (_DWORD *)**v2;
    if ( v10 != *v2 )
    {
      do
      {
        v42 = 7;
        v41[4] = 0;
        LOWORD(v41[0]) = 0;
        sub_4090E0((int)v41, v10 + 2, 0, 0xFFFFFFFF);
        LOBYTE(v46) = 1;
        v11 = (void **)v41[0];
        if ( v42 < 8 )
          v11 = v41;
        p_pszPath = &pszPath;
        v13 = 260;
        v14 = (char *)v11 - (char *)&pszPath;
        while ( v13 != -2147483386 )
        {
          v15 = *(WCHAR *)((char *)p_pszPath + v14);
          if ( !v15 )
            break;
          *p_pszPath++ = v15;
          if ( !--v13 )
          {
            --p_pszPath;
            break;
          }
        }
        *p_pszPath = 0;
        PathStripPathW(&pszPath);
        v40 = 7;
        v39[4] = 0;
        LOWORD(v39[0]) = 0;
        sub_4094F0(v39, (int)&pszPath, &pszPath, wcslen(&pszPath));
        LOBYTE(v46) = 2;
        v16 = v36 + 4;
        v17 = sub_40A200(v36, *((_DWORD *)v36 + 1), (int)v39);
        if ( v37 == 153391688 )
          std::_Xlength_error("list<T> too long");
        ++v37;
        *(_DWORD *)v16 = v17;
        **((_DWORD **)v17 + 1) = v17;
        if ( v40 >= 8 )
          operator delete(v39[0]);
        LOBYTE(v46) = 0;
        if ( v42 >= 8 )
          operator delete(v41[0]);
        v10 = (_DWORD *)*v10;
      }
      while ( v10 != v9 );
    }
    hNameMappings = FileOp.hNameMappings;
    if ( FileOp.hNameMappings )
    {
      v35 = FileOp.hNameMappings;
      v33 = 0;
      if ( *(int *)FileOp.hNameMappings > 0 )
      {
        v19 = v36;
        v38 = 0;
        do
        {
          v20 = *(char **)v19;
          if ( *(char **)v19 != v19 )
          {
            while ( 1 )
            {
              v21 = *(WCHAR **)(v38 + v35[1]);
              v22 = 260;
              v23 = String1;
              while ( v22 != -2147483386 && *v21 )
              {
                *v23++ = *v21++;
                if ( !--v22 )
                {
                  --v23;
                  break;
                }
              }
              *v23 = 0;
              PathStripPathW(String1);
              v24 = (const WCHAR *)(v20 + 8);
              if ( *((_DWORD *)v20 + 7) >= 8u )
                v24 = *(const WCHAR **)v24;
              if ( !lstrcmpW(String1, v24) )
                break;
              v20 = *(char **)v20;
              v19 = v36;
              if ( v20 == v36 )
                goto LABEL_45;
            }
            v25 = *(WCHAR **)(v38 + v35[1] + 4);
            v26 = 260;
            v27 = &pszPath;
            while ( v26 != -2147483386 && *v25 )
            {
              *v27++ = *v25++;
              if ( !--v26 )
              {
                --v27;
                break;
              }
            }
            *v27 = 0;
            PathStripPathW(&pszPath);
            sub_4094F0((_DWORD *)v20 + 2, (int)&v45, &pszPath, wcslen(&pszPath));
            v19 = v36;
          }
LABEL_45:
          v38 += 16;
          ++v33;
        }
        while ( v33 < *v35 );
        hNameMappings = FileOp.hNameMappings;
      }
      SHFreeNameMappings(hNameMappings);
    }
    if ( *(_DWORD *)(v31 + 60) )
      (***(void (__thiscall ****)(_DWORD, char **, int))(v31 + 60))(*(_DWORD *)(v31 + 60), &v36, v31 + 64);
    sub_40A140((int)&v36);
    operator delete(v36);
  }
  return v34;
}
// 45FE00: conditional instruction was optimized away because edx.4!=0
// 45FF6C: conditional instruction was optimized away because esi.4!=0
// 45FFF7: conditional instruction was optimized away because esi.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00460100) --------------------------------------------------------
DWORD __stdcall sub_460100(LPVOID lpThreadParameter)
{
  int v1; // edi
  bool v2; // zf
  void (__thiscall ***v3)(_DWORD, int); // edi
  WPARAM wParam; // [esp+Ch] [ebp-Ch] BYREF
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  CoInitializeEx(0, 2u);
  v1 = sub_45FC80((int)lpThreadParameter);
  CoUninitialize();
  wParam = *((_DWORD *)lpThreadParameter + 14);
  if ( v1 )
  {
    v2 = *((_DWORD *)lpThreadParameter + 12) == 0;
    v6 = 0;
    v7 = !v2 + 1;
  }
  else
  {
    v6 = -2147467259;
    v7 = 0;
  }
  SendMessageW(*((HWND *)lpThreadParameter + 1), 0x8001u, (WPARAM)&wParam, 0);
  v3 = *(void (__thiscall ****)(_DWORD, int))lpThreadParameter;
  if ( !InterlockedDecrement((volatile LONG *)(*(_DWORD *)lpThreadParameter + 4)) && v3 )
    (**v3)(v3, 1);
  if ( *((_DWORD *)lpThreadParameter + 10) >= 8u )
    operator delete(*((void **)lpThreadParameter + 5));
  *((_DWORD *)lpThreadParameter + 9) = 0;
  *((_DWORD *)lpThreadParameter + 10) = 7;
  *((_WORD *)lpThreadParameter + 10) = 0;
  sub_40A140((int)lpThreadParameter + 8);
  operator delete(*((void **)lpThreadParameter + 2));
  operator delete(lpThreadParameter);
  return 0;
}

//----- (004601D0) --------------------------------------------------------
int __userpurge sub_4601D0@<eax>(int a1@<edi>, int a2, int a3, int a4)
{
  int result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // eax
  char ***v9; // ebx
  _WORD *v10; // eax
  _WORD *v11; // ebx
  int (__stdcall ***v13)(_DWORD, _DWORD *, int *); // eax
  HANDLE Thread; // eax
  int pExceptionObject[3]; // [esp+Ch] [ebp-28h] BYREF
  void *v16; // [esp+18h] [ebp-1Ch]
  char *v17; // [esp+1Ch] [ebp-18h] BYREF
  int v18; // [esp+20h] [ebp-14h] BYREF
  int v19; // [esp+24h] [ebp-10h] BYREF
  int v20; // [esp+30h] [ebp-4h]
  void **v21; // [esp+3Ch] [ebp+8h]

  result = *(_DWORD *)(a2 + 4);
  if ( result )
  {
    v5 = operator new(0x48u);
    v6 = v5;
    v16 = v5;
    v20 = 0;
    if ( v5 )
    {
      v5[3] = 0;
      v7 = operator new(0x24u);
      if ( !v7 )
      {
        v17 = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      v6[2] = v7;
      *v7 = v7;
      *(_DWORD *)(v6[2] + 4) = v6[2];
      v6[10] = 7;
      v6[9] = 0;
      *((_WORD *)v6 + 10) = 0;
    }
    else
    {
      v6 = 0;
    }
    v20 = -1;
    *v6 = a1;
    v9 = (char ***)(v6 + 2);
    v6[1] = *(_DWORD *)(a1 + 32);
    if ( v6 + 2 != (_DWORD *)a2 )
    {
      v21 = *(void ***)a2;
      v16 = **(void ***)a2;
      sub_40A140((int)v9);
      sub_40B6E0((int)(v6 + 2), **v9, (int)v16, (int)v21, (int)v21);
    }
    v10 = *(_WORD **)(a1 + 40);
    v11 = v10 + 1;
    while ( *v10++ )
      ;
    sub_4094F0(v6 + 5, *(_DWORD *)(a1 + 40), *(void **)(a1 + 40), v10 - v11);
    v6[12] = a3;
    v6[13] = a4;
    v6[14] = 0;
    v6[15] = *(_DWORD *)(a1 + 12);
    v6[16] = *(_DWORD *)(a1 + 20);
    v6[17] = *(_DWORD *)(a1 + 24);
    v13 = *(int (__stdcall ****)(_DWORD, _DWORD *, int *))(a1 + 8);
    v19 = 0;
    v18 = 0;
    if ( !(**v13)(v13, dword_4BD9AC, &v19) )
    {
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)v19 + 16))(v19, &v18);
      if ( v18 )
      {
LABEL_15:
        (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)v19 + 20))(v19, 0);
        v6[14] = v19;
        InterlockedIncrement((volatile LONG *)(a1 + 4));
        SetWindowSubclass(*(HWND *)(a1 + 32), sub_45F470, 0x2710u, 0);
        Thread = CreateThread(0, 0, sub_460100, v6, 0, 0);
        return CloseHandle(Thread);
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)v19 + 8))(v19);
    }
    if ( v18 )
      goto LABEL_15;
    sub_45FC80((int)v6);
    return sub_41A450((int)v6);
  }
  return result;
}
// 4BD9AC: using guessed type _DWORD dword_4BD9AC[4];
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004603C0) --------------------------------------------------------
void __thiscall sub_4603C0(_DWORD *this, HDROP *a2, int a3, char a4)
{
  _DWORD *v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // ebx
  int v11; // edx
  WCHAR *v12; // eax
  WCHAR v13; // cx
  char v14; // bl
  BOOL v15; // eax
  int v16; // ecx
  int v17; // edx
  char v18; // al
  int v19; // edx
  WCHAR *v20; // eax
  WCHAR v21; // cx
  char *v22; // eax
  int v23; // edi
  HDROP v24; // [esp-10h] [ebp-6BCh]
  int pExceptionObject[3]; // [esp+10h] [ebp-69Ch] BYREF
  int v26[3]; // [esp+1Ch] [ebp-690h] BYREF
  int v27; // [esp+28h] [ebp-684h]
  _DWORD *v28; // [esp+2Ch] [ebp-680h]
  char *v29; // [esp+30h] [ebp-67Ch] BYREF
  _DWORD *v30; // [esp+34h] [ebp-678h]
  unsigned int v31; // [esp+38h] [ebp-674h]
  void *v32; // [esp+3Ch] [ebp-670h] BYREF
  int v33; // [esp+40h] [ebp-66Ch]
  void *v34; // [esp+48h] [ebp-664h] BYREF
  int v35; // [esp+4Ch] [ebp-660h]
  HDROP *v36; // [esp+54h] [ebp-658h]
  int v37; // [esp+58h] [ebp-654h]
  int v38; // [esp+5Ch] [ebp-650h]
  char *FileW; // [esp+60h] [ebp-64Ch] BYREF
  UINT iFile; // [esp+64h] [ebp-648h]
  void *v41[4]; // [esp+68h] [ebp-644h] BYREF
  int v42; // [esp+78h] [ebp-634h]
  unsigned int v43; // [esp+7Ch] [ebp-630h]
  WCHAR v44[260]; // [esp+84h] [ebp-628h] BYREF
  WCHAR pszPath[260]; // [esp+28Ch] [ebp-420h] BYREF
  WCHAR szFile[260]; // [esp+494h] [ebp-218h] BYREF
  int v47; // [esp+6A8h] [ebp-4h]

  v38 = (int)this;
  v36 = a2;
  v35 = 0;
  v5 = operator new(0x24u);
  v6 = (int)v5;
  v28 = v5;
  if ( !v5 )
  {
    FileW = 0;
    std::exception::exception((std::exception *)v26, (const char *const *)&FileW);
    v26[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v26, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v5 = v5;
  v34 = v5;
  v5[1] = v5;
  v47 = 0;
  v33 = 0;
  v7 = operator new(0x24u);
  v8 = (int)v7;
  v30 = v7;
  if ( !v7 )
  {
    v29 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v29);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v7 = v7;
  v32 = v7;
  v7[1] = v7;
  LOBYTE(v47) = 1;
  v9 = this[11];
  v24 = *v36;
  v37 = v9;
  FileW = (char *)DragQueryFileW(v24, 0xFFFFFFFF, 0, 0);
  iFile = 0;
  if ( (int)FileW <= 0 )
    goto LABEL_52;
  v10 = 520;
  v27 = 520;
  v31 = 1040;
  while ( 2 )
  {
    DragQueryFileW(*v36, iFile, szFile, 0x104u);
    v11 = 260;
    v12 = pszPath;
    while ( v11 != -2147483386 )
    {
      v13 = *(WCHAR *)((char *)v12 + v10);
      if ( !v13 )
        break;
      *v12++ = v13;
      if ( !--v11 )
      {
        --v12;
        break;
      }
    }
    *v12 = 0;
    PathRemoveFileSpecW(pszPath);
    if ( !lstrcmpiW(*(LPCWSTR *)(v38 + 40), pszPath) )
      v37 = 1;
    if ( a3 )
    {
      v14 = a4;
    }
    else
    {
      v15 = sub_45F380(v38, iFile);
      v16 = *(_DWORD *)(v38 + 16);
      v17 = *(_DWORD *)(v38 + 28);
      if ( ((v16 & 8) != 0 && (v16 & 4) != 0 || (v16 & 0x20) != 0) && (v17 & 4) != 0 )
      {
        v18 = 4;
      }
      else if ( (v16 & 4) != 0 && (v17 & 2) != 0 )
      {
        v18 = 2;
      }
      else if ( (*(_DWORD *)(v38 + 16) & 8) == 8 && (v17 & 1) != 0 )
      {
        v18 = 1;
      }
      else if ( v15 && (v17 & 2) != 0 )
      {
        v18 = 2;
      }
      else if ( (v17 & 1) != 0 )
      {
        v18 = 1;
      }
      else if ( (v17 & 2) != 0 )
      {
        v18 = 2;
      }
      else
      {
        v18 = v17 & 4;
      }
      v6 = (int)v28;
      v8 = (int)v30;
      v14 = v18;
    }
    v19 = 260;
    v20 = v44;
    while ( v19 != -2147483386 )
    {
      v21 = v20[v31 / 2];
      if ( !v21 )
        break;
      *v20++ = v21;
      if ( !--v19 )
      {
        --v20;
        break;
      }
    }
    *v20 = 0;
    PathStripPathW(v44);
    if ( (v14 & 2) != 0 )
    {
      v43 = 7;
      v42 = 0;
      LOWORD(v41[0]) = 0;
      sub_4094F0(v41, (int)szFile, szFile, wcslen(szFile));
      LOBYTE(v47) = 2;
      v22 = sub_40A200((char *)v8, *(_DWORD *)(v8 + 4), (int)v41);
      if ( v33 != 153391688 )
      {
        ++v33;
        *(_DWORD *)(v8 + 4) = v22;
        goto LABEL_46;
      }
LABEL_53:
      std::_Xlength_error("list<T> too long");
    }
    if ( (v14 & 1) == 0 )
    {
      if ( (v14 & 4) != 0 )
        sub_45FA40(szFile, v38);
      goto LABEL_50;
    }
    v43 = 7;
    v42 = 0;
    LOWORD(v41[0]) = 0;
    sub_4094F0(v41, (int)szFile, szFile, wcslen(szFile));
    LOBYTE(v47) = 3;
    v22 = sub_40A200((char *)v6, *(_DWORD *)(v6 + 4), (int)v41);
    if ( v35 == 153391688 )
      goto LABEL_53;
    ++v35;
    *(_DWORD *)(v6 + 4) = v22;
LABEL_46:
    **((_DWORD **)v22 + 1) = v22;
    LOBYTE(v47) = 1;
    if ( v43 >= 8 )
      operator delete(v41[0]);
LABEL_50:
    if ( (int)++iFile < (int)FileW )
    {
      v10 = v27;
      continue;
    }
    break;
  }
  v9 = v37;
LABEL_52:
  v23 = v38;
  sub_4601D0(v38, (int)&v34, 1, v9);
  sub_4601D0(v23, (int)&v32, 0, v9);
  sub_40A140((int)&v32);
  operator delete(v32);
  sub_40A140((int)&v34);
  operator delete(v34);
}
// 460513: conditional instruction was optimized away because edx.4!=0
// 46061B: conditional instruction was optimized away because edx.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00460890) --------------------------------------------------------
int __thiscall sub_460890(char **this, DWORD a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // esi
  int i; // edi
  int v6; // eax
  char *v7; // ebx
  SIZE_T v8; // eax
  HANDLE v9; // esi
  WCHAR *p_pszPath; // eax
  int v11; // esi
  WCHAR v12; // dx
  char **v13; // edi
  char *v14; // esi
  char *v15; // eax
  char *v16; // ecx
  struct _FILETIME FileTime; // [esp+10h] [ebp-A88h] BYREF
  DWORD NumberOfBytesWritten; // [esp+18h] [ebp-A80h] BYREF
  FILETIME v20; // [esp+1Ch] [ebp-A7Ch] BYREF
  STGMEDIUM v21; // [esp+24h] [ebp-A74h] BYREF
  char **v22; // [esp+30h] [ebp-A68h]
  _DWORD *v23; // [esp+34h] [ebp-A64h]
  HANDLE hFile; // [esp+38h] [ebp-A60h]
  int v25; // [esp+3Ch] [ebp-A5Ch]
  DWORD nNumberOfBytesToWrite; // [esp+40h] [ebp-A58h]
  struct _SYSTEMTIME SystemTime; // [esp+44h] [ebp-A54h] BYREF
  void *v28[5]; // [esp+54h] [ebp-A44h] BYREF
  unsigned int v29; // [esp+68h] [ebp-A30h]
  WCHAR pszFile[260]; // [esp+70h] [ebp-A28h] BYREF
  WCHAR pszDest[260]; // [esp+278h] [ebp-820h] BYREF
  __int16 String[512]; // [esp+480h] [ebp-618h] BYREF
  WCHAR pszPath; // [esp+880h] [ebp-218h] BYREF
  _BYTE v34[534]; // [esp+882h] [ebp-216h] BYREF

  v22 = this;
  nNumberOfBytesToWrite = a2;
  v3 = (*(int (__stdcall **)(int, void *, STGMEDIUM *))(*(_DWORD *)a3 + 12))(a3, &unk_4DFE98, &v21);
  v25 = v3;
  if ( !v3 )
  {
    v4 = GlobalLock(v21.hBitmap);
    v23 = v4;
    if ( v4 )
    {
      GetLocalTime(&SystemTime);
      SystemTimeToFileTime(&SystemTime, &FileTime);
      LocalFileTimeToFileTime(&FileTime, &v20);
      sub_46AB90(String, 512, &v20, 0);
      for ( i = 0; i < lstrlenW((LPCWSTR)String); ++i )
      {
        v6 = (unsigned __int16)String[i];
        if ( v6 == 47 )
        {
          String[i] = 45;
        }
        else if ( v6 == 58 )
        {
          String[i] = 46;
        }
      }
      sub_401000(0x104u, pszFile, L"Clipboard Image (%s).bmp", String);
      PathCombineW(pszDest, *(LPCWSTR *)(nNumberOfBytesToWrite + 40), pszFile);
      hFile = CreateFileW(pszDest, 0x40000000u, 0, 0, 1u, 0x80u, 0);
      if ( hFile != (HANDLE)-1 )
      {
        nNumberOfBytesToWrite = GlobalSize(v21.hBitmap) + 14;
        v7 = (char *)operator new[](nNumberOfBytesToWrite);
        *(_WORD *)v7 = 19778;
        *(_DWORD *)(v7 + 2) = *v4;
        *(_DWORD *)(v7 + 6) = 0;
        *(_DWORD *)(v7 + 10) = 14;
        qmemcpy(v7 + 14, v4, 0x28u);
        v8 = GlobalSize(v21.hBitmap);
        memcpy_0(v7 + 54, v23 + 10, v8 - 40);
        v9 = hFile;
        WriteFile(hFile, v7, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
        CloseHandle(v9);
        operator delete[](v7);
        p_pszPath = &pszPath;
        v11 = 260;
        while ( v11 != -2147483386 )
        {
          v12 = *(p_pszPath - 772);
          if ( !v12 )
            break;
          *p_pszPath++ = v12;
          if ( !--v11 )
          {
            --p_pszPath;
            break;
          }
        }
        *p_pszPath = 0;
        PathStripPathW(&pszPath);
        LOWORD(v28[0]) = 0;
        v29 = 7;
        v28[4] = 0;
        sub_4094F0(v28, (int)v34, &pszPath, wcslen(&pszPath));
        *(_DWORD *)&v34[530] = 0;
        v13 = v22;
        v14 = *v22;
        v15 = sub_40A200(*v22, *((_DWORD *)*v22 + 1), (int)v28);
        v16 = v13[1];
        if ( v16 == (char *)153391688 )
          std::_Xlength_error("list<T> too long");
        v13[1] = v16 + 1;
        *((_DWORD *)v14 + 1) = v15;
        **((_DWORD **)v15 + 1) = v15;
        if ( v29 >= 8 )
          operator delete(v28[0]);
      }
      GlobalUnlock(v21.hBitmap);
      v3 = v25;
    }
    ReleaseStgMedium(&v21);
  }
  return v3;
}
// 460AF2: conditional instruction was optimized away because esi.4!=0
// 4C2A4C: using guessed type wchar_t aClipboardImage[25];
// 460890: using guessed type WCHAR String[512];

//----- (00460BF0) --------------------------------------------------------
int __thiscall sub_460BF0(void *this, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  const char *v5; // eax
  const CHAR *v6; // edi
  WCHAR *v7; // esi
  WCHAR *v8; // eax
  int v9; // edx
  WCHAR v10; // cx
  STGMEDIUM v11; // [esp+10h] [ebp-450h] BYREF
  void *v12; // [esp+1Ch] [ebp-444h]
  int v13; // [esp+20h] [ebp-440h]
  void *v14[7]; // [esp+24h] [ebp-43Ch] BYREF
  char v15[520]; // [esp+40h] [ebp-420h] BYREF
  WCHAR pszPath[260]; // [esp+248h] [ebp-218h] BYREF
  int v17; // [esp+45Ch] [ebp-4h]

  v12 = this;
  v13 = a2;
  result = (*(int (__stdcall **)(int, void *, STGMEDIUM *))(*(_DWORD *)a3 + 12))(a3, &unk_4DFE70, &v11);
  v4 = result;
  if ( !result )
  {
    v5 = (const char *)GlobalLock(v11.hBitmap);
    v6 = v5;
    if ( v5 )
    {
      v7 = (WCHAR *)operator new[](2 * (strlen(v5) + 1));
      MultiByteToWideChar(0, 0, v6, -1, v7, strlen(v6) + 1);
      v4 = sub_45F620(v15, v7, *(const WCHAR **)(v13 + 40));
      if ( !v4 )
      {
        v8 = pszPath;
        v9 = 260;
        while ( v9 != -2147483386 )
        {
          v10 = *(v8 - 260);
          if ( !v10 )
            break;
          *v8++ = v10;
          if ( !--v9 )
          {
            --v8;
            break;
          }
        }
        *v8 = 0;
        PathStripPathW(pszPath);
        sub_4095E0(v14, pszPath);
        v17 = 0;
        sub_40AAD0((int)v14, (int)v12);
        if ( v14[5] >= (void *)8 )
          operator delete(v14[0]);
      }
      operator delete[](v7);
      GlobalUnlock(v11.hBitmap);
    }
    ReleaseStgMedium(&v11);
    return v4;
  }
  return result;
}
// 460D00: conditional instruction was optimized away because edx.4!=0
// 460BF0: using guessed type char var_420[520];

//----- (00460DA0) --------------------------------------------------------
int __fastcall sub_460DA0(int a1, int a2, int a3)
{
  int result; // eax
  int v6; // esi
  const WCHAR *v7; // eax
  WCHAR *v8; // eax
  int v9; // edx
  WCHAR v10; // cx
  STGMEDIUM v11; // [esp+10h] [ebp-44Ch] BYREF
  void *v12[7]; // [esp+1Ch] [ebp-440h] BYREF
  char v13[520]; // [esp+38h] [ebp-424h] BYREF
  WCHAR pszPath[260]; // [esp+240h] [ebp-21Ch] BYREF
  int v15; // [esp+458h] [ebp-4h]

  result = (*(int (__stdcall **)(int, void *, STGMEDIUM *))(*(_DWORD *)a3 + 12))(a3, &unk_4DFE84, &v11);
  v6 = result;
  if ( !result )
  {
    v7 = (const WCHAR *)GlobalLock(v11.hBitmap);
    if ( v7 )
    {
      v6 = sub_45F620(v13, v7, *(const WCHAR **)(a1 + 40));
      if ( !v6 )
      {
        v8 = pszPath;
        v9 = 260;
        while ( v9 != -2147483386 )
        {
          v10 = *(v8 - 260);
          if ( !v10 )
            break;
          *v8++ = v10;
          if ( !--v9 )
          {
            --v8;
            break;
          }
        }
        *v8 = 0;
        PathStripPathW(pszPath);
        sub_4095E0(v12, pszPath);
        v15 = 0;
        sub_40AAD0((int)v12, a2);
        if ( v12[5] >= (void *)8 )
          operator delete(v12[0]);
      }
      GlobalUnlock(v11.hBitmap);
    }
    ReleaseStgMedium(&v11);
    return v6;
  }
  return result;
}
// 460E60: conditional instruction was optimized away because edx.4!=0
// 460DA0: using guessed type char var_424[520];

//----- (00460EF0) --------------------------------------------------------
int __userpurge sub_460EF0@<eax>(int *a1@<ebx>, int a2, int a3)
{
  int v3; // ecx
  int v4; // esi
  _DWORD *v5; // eax
  FILETIME *v6; // ecx
  DWORD dwLowDateTime; // eax
  __int16 v8; // ax
  int v9; // ecx
  int v10; // esi
  int (__stdcall *v11)(int *, __int16 *); // eax
  int v12; // eax
  __int16 *v13; // edx
  int v14; // esi
  int (__stdcall *v15)(int *, __int16 *); // eax
  int v16; // eax
  int v17; // esi
  int (__stdcall *v18)(int *, __int16 *); // eax
  int v19; // eax
  WCHAR *v20; // eax
  int v21; // edx
  int v22; // esi
  WCHAR v23; // cx
  int v24; // esi
  WCHAR *v25; // esi
  DWORD v26; // esi
  SIZE_T v27; // eax
  const void *v28; // esi
  SIZE_T v29; // eax
  WCHAR *v30; // eax
  int v31; // edx
  int v32; // esi
  WCHAR v33; // cx
  HANDLE FileW; // esi
  WCHAR *p_Src; // eax
  int v36; // esi
  WCHAR v37; // dx
  char *v38; // esi
  char *v39; // eax
  int v40; // ecx
  HGLOBAL v41; // esi
  void (__stdcall *v42)(int *, __int16 *, int *, _DWORD); // edx
  STGMEDIUM v44; // [esp+10h] [ebp-780h] BYREF
  STGMEDIUM v45; // [esp+1Ch] [ebp-774h] BYREF
  STGMEDIUM v46; // [esp+28h] [ebp-768h] BYREF
  char v47[4]; // [esp+34h] [ebp-75Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+38h] [ebp-758h] BYREF
  __int16 v49; // [esp+3Ch] [ebp-754h] BYREF
  int v50; // [esp+40h] [ebp-750h]
  int v51; // [esp+44h] [ebp-74Ch]
  int v52; // [esp+48h] [ebp-748h]
  int v53; // [esp+4Ch] [ebp-744h]
  int v54[3]; // [esp+50h] [ebp-740h] BYREF
  STGMEDIUM v55; // [esp+5Ch] [ebp-734h] BYREF
  _DWORD *v56; // [esp+68h] [ebp-728h]
  __int16 v57; // [esp+6Ch] [ebp-724h] BYREF
  int v58; // [esp+70h] [ebp-720h]
  int v59; // [esp+74h] [ebp-71Ch]
  int v60; // [esp+78h] [ebp-718h]
  int v61; // [esp+7Ch] [ebp-714h]
  __int16 v62; // [esp+80h] [ebp-710h] BYREF
  int v63; // [esp+84h] [ebp-70Ch]
  int v64; // [esp+88h] [ebp-708h]
  int v65; // [esp+8Ch] [ebp-704h]
  int v66; // [esp+90h] [ebp-700h]
  __int16 v67; // [esp+94h] [ebp-6FCh] BYREF
  int v68; // [esp+98h] [ebp-6F8h]
  int v69; // [esp+9Ch] [ebp-6F4h]
  int v70; // [esp+A0h] [ebp-6F0h]
  int v71; // [esp+A4h] [ebp-6ECh]
  FILETIME *lpLastWriteTime; // [esp+A8h] [ebp-6E8h]
  int v73; // [esp+ACh] [ebp-6E4h]
  DWORD dwFlagsAndAttributes; // [esp+B0h] [ebp-6E0h]
  FILETIME *lpCreationTime; // [esp+B4h] [ebp-6DCh]
  FILETIME *lpLastAccessTime; // [esp+B8h] [ebp-6D8h]
  int v77; // [esp+BCh] [ebp-6D4h]
  DWORD nNumberOfBytesToWrite; // [esp+C0h] [ebp-6D0h]
  void *ppObjectOpen; // [esp+C4h] [ebp-6CCh] BYREF
  int v80; // [esp+C8h] [ebp-6C8h]
  STGMEDIUM v81; // [esp+CCh] [ebp-6C4h] BYREF
  int v82; // [esp+D8h] [ebp-6B8h]
  LPCVOID lpBuffer; // [esp+DCh] [ebp-6B4h]
  _DWORD *i; // [esp+E0h] [ebp-6B0h]
  HRESULT v85; // [esp+E4h] [ebp-6ACh]
  char v86[8]; // [esp+E8h] [ebp-6A8h] BYREF
  size_t Size; // [esp+F0h] [ebp-6A0h]
  int v88[7]; // [esp+130h] [ebp-660h] BYREF
  void *v89[4]; // [esp+14Ch] [ebp-644h] BYREF
  int v90; // [esp+15Ch] [ebp-634h]
  unsigned int v91; // [esp+160h] [ebp-630h]
  WCHAR pszPath[260]; // [esp+168h] [ebp-628h] BYREF
  WCHAR Src; // [esp+370h] [ebp-420h] BYREF
  __int16 v94; // [esp+372h] [ebp-41Eh] BYREF
  WCHAR FileName[260]; // [esp+578h] [ebp-218h] BYREF
  int v96; // [esp+78Ch] [ebp-4h]

  v3 = *a1;
  v80 = a3;
  v4 = (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(v3 + 12))(a1, &word_4EF73C, &v55);
  v85 = v4;
  if ( v4 )
    return v4;
  v5 = GlobalLock(v55.hBitmap);
  v56 = v5;
  if ( !v5 )
    goto LABEL_72;
  lpCreationTime = 0;
  lpLastAccessTime = 0;
  lpLastWriteTime = 0;
  dwFlagsAndAttributes = 128;
  nNumberOfBytesToWrite = 0;
  v82 = 0;
  if ( !*v5 )
    goto LABEL_71;
  v6 = (FILETIME *)(v5 + 1);
  for ( i = v5 + 1; ; v6 = (FILETIME *)i )
  {
    dwLowDateTime = v6->dwLowDateTime;
    if ( (v6->dwLowDateTime & 4) != 0 )
      dwFlagsAndAttributes = v6[4].dwHighDateTime;
    if ( (dwLowDateTime & 0x40) != 0 )
      nNumberOfBytesToWrite = v6[8].dwHighDateTime;
    if ( (dwLowDateTime & 8) != 0 )
      lpCreationTime = v6 + 5;
    if ( (dwLowDateTime & 0x10) != 0 )
      lpLastAccessTime = v6 + 6;
    if ( (dwLowDateTime & 0x20) != 0 )
      lpLastWriteTime = v6 + 7;
    memset(&v81, 0, sizeof(v81));
    v73 = 0;
    v77 = 0;
    lpBuffer = 0;
    v67 = RegisterClipboardFormatW(L"FileContents");
    v71 = 1;
    v70 = v82;
    v69 = 1;
    v68 = 0;
    v62 = RegisterClipboardFormatW(L"FileContents");
    v66 = 4;
    v65 = v82;
    v64 = 1;
    v63 = 0;
    v8 = RegisterClipboardFormatW(L"FileContents");
    v9 = *a1;
    v10 = v70;
    v57 = v8;
    v60 = v82;
    v11 = *(int (__stdcall **)(int *, __int16 *))(v9 + 20);
    v61 = 8;
    v59 = 1;
    v58 = 0;
    v70 = -1;
    v12 = v11(a1, &v67);
    v70 = v10;
    if ( v12 || (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*a1 + 12))(a1, &v67, &v44) )
    {
      v14 = v65;
      v15 = *(int (__stdcall **)(int *, __int16 *))(*a1 + 20);
      v65 = -1;
      v16 = v15(a1, &v62);
      v65 = v14;
      if ( v16 || (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*a1 + 12))(a1, &v62, &v45) )
      {
        v17 = v60;
        v18 = *(int (__stdcall **)(int *, __int16 *))(*a1 + 20);
        v60 = -1;
        v19 = v18(a1, &v57);
        v60 = v17;
        if ( v19 || (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*a1 + 12))(a1, &v57, &v46) )
          goto LABEL_69;
        ReleaseStgMedium(&v46);
        v13 = &v57;
      }
      else
      {
        ReleaseStgMedium(&v45);
        v13 = &v62;
      }
    }
    else
    {
      ReleaseStgMedium(&v44);
      v13 = &v67;
    }
    v85 = (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*a1 + 12))(a1, v13, &v81);
    if ( !v85 )
    {
      switch ( v81.tymed )
      {
        case 1u:
          v27 = GlobalSize(v81.hBitmap);
          lpBuffer = malloc(v27);
          if ( lpBuffer )
          {
            if ( (*(_BYTE *)i & 0x40) == 0 )
              nNumberOfBytesToWrite = GlobalSize(v81.hBitmap);
            v28 = GlobalLock(v81.hBitmap);
            if ( v28 )
            {
              v29 = GlobalSize(v81.hBitmap);
              memcpy_0((void *)lpBuffer, v28, v29);
              GlobalUnlock(v81.hBitmap);
              v77 = 1;
            }
          }
          break;
        case 4u:
          v85 = (*(int (__stdcall **)(HBITMAP, char *, int))(*(_DWORD *)v81.hBitmap + 48))(v81.hBitmap, v86, 1);
          if ( !v85 )
          {
            v26 = Size;
            lpBuffer = malloc(Size);
            if ( lpBuffer )
            {
              if ( (*(_BYTE *)i & 0x40) == 0 )
                nNumberOfBytesToWrite = v26;
              (*(void (__stdcall **)(HBITMAP, LPCVOID, DWORD, char *))(*(_DWORD *)v81.hBitmap + 12))(
                v81.hBitmap,
                lpBuffer,
                v26,
                v47);
              v77 = 1;
            }
          }
          break;
        case 8u:
          v20 = pszPath;
          v21 = 260;
          v22 = *(_DWORD *)(a2 + 40) - (_DWORD)pszPath;
          while ( v21 != -2147483386 )
          {
            v23 = *(WCHAR *)((char *)v20 + v22);
            if ( !v23 )
              break;
            *v20++ = v23;
            if ( !--v21 )
            {
              --v20;
              break;
            }
          }
          v24 = (int)i;
          *v20 = 0;
          v25 = (WCHAR *)(v24 + 72);
          PathAppendW(pszPath, v25);
          ppObjectOpen = 0;
          v85 = StgCreateStorageEx(pszPath, 0x11002u, 0, 0, 0, 0, &stru_4BD9CC, &ppObjectOpen);
          if ( !v85 )
          {
            v85 = (*(int (__stdcall **)(HBITMAP, _DWORD, _DWORD, _DWORD, void *))(*(_DWORD *)v81.hBitmap + 28))(
                    v81.hBitmap,
                    0,
                    0,
                    0,
                    ppObjectOpen);
            if ( !v85 )
            {
              v85 = (*(int (__stdcall **)(void *, _DWORD))(*(_DWORD *)ppObjectOpen + 36))(ppObjectOpen, 0);
              if ( !v85 )
              {
                sub_4095E0(v88, v25);
                v96 = 0;
                sub_40AAD0((int)v88, v80);
                v96 = -1;
                sub_409000((int)v88);
                v73 = 1;
              }
            }
            (*(void (__stdcall **)(void *))(*(_DWORD *)ppObjectOpen + 8))(ppObjectOpen);
          }
          break;
      }
      ReleaseStgMedium(&v81);
      if ( v77 && !v73 )
      {
        v30 = FileName;
        v31 = 260;
        v32 = *(_DWORD *)(a2 + 40) - (_DWORD)FileName;
        while ( v31 != -2147483386 )
        {
          v33 = *(WCHAR *)((char *)v30 + v32);
          if ( !v33 )
            break;
          *v30++ = v33;
          if ( !--v31 )
          {
            --v30;
            break;
          }
        }
        *v30 = 0;
        PathAppendW(FileName, (LPCWSTR)i + 36);
        FileW = CreateFileW(FileName, 0x40000000u, 0, 0, 2u, dwFlagsAndAttributes, 0);
        if ( FileW != (HANDLE)-1 )
        {
          SetFileTime(FileW, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
          WriteFile(FileW, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
          CloseHandle(FileW);
          p_Src = &Src;
          v36 = 260;
          while ( v36 != -2147483386 )
          {
            v37 = p_Src[260];
            if ( !v37 )
              break;
            *p_Src++ = v37;
            if ( !--v36 )
            {
              --p_Src;
              break;
            }
          }
          *p_Src = 0;
          PathStripPathW(&Src);
          LOWORD(v89[0]) = 0;
          v91 = 7;
          v90 = 0;
          sub_4094F0(v89, (int)&v94, &Src, wcslen(&Src));
          v96 = 1;
          v38 = *(char **)v80;
          v39 = sub_40A200(*(char **)v80, *(_DWORD *)(*(_DWORD *)v80 + 4), (int)v89);
          v40 = *(_DWORD *)(v80 + 4);
          if ( v40 == 153391688 )
            std::_Xlength_error("list<T> too long");
          *(_DWORD *)(v80 + 4) = v40 + 1;
          *((_DWORD *)v38 + 1) = v39;
          **((_DWORD **)v39 + 1) = v39;
          v96 = -1;
          if ( v91 >= 8 )
            operator delete(v89[0]);
          v91 = 7;
          v90 = 0;
          LOWORD(v89[0]) = 0;
        }
        v49 = RegisterClipboardFormatW(L"Performed DropEffect");
        v50 = 0;
        v51 = 1;
        v52 = -1;
        v53 = 1;
        v41 = GlobalAlloc(2u, 4u);
        *(_DWORD *)GlobalLock(v41) = 1;
        GlobalUnlock(v41);
        v42 = *(void (__stdcall **)(int *, __int16 *, int *, _DWORD))(*a1 + 28);
        v54[0] = 1;
        v54[2] = 0;
        v54[1] = (int)v41;
        v42(a1, &v49, v54, 0);
      }
      if ( lpBuffer )
        free((void *)lpBuffer);
    }
LABEL_69:
    i += 148;
    if ( (unsigned int)++v82 >= *v56 )
      break;
  }
  v4 = v85;
LABEL_71:
  GlobalUnlock(v55.hBitmap);
LABEL_72:
  ReleaseStgMedium(&v55);
  return v4;
}
// 461233: conditional instruction was optimized away because edx.4!=0
// 461471: conditional instruction was optimized away because edx.4!=0
// 461530: conditional instruction was optimized away because esi.4!=0
// 4EF73C: using guessed type __int16 word_4EF73C;
// 460EF0: using guessed type _DWORD var_660[7];
// 460EF0: using guessed type char var_6A8[8];
// 460EF0: using guessed type char var_75C[4];

//----- (00461720) --------------------------------------------------------
int __userpurge sub_461720@<eax>(int a1@<eax>, _DWORD *a2, int a3, char a4)
{
  int result; // eax
  STGMEDIUM v5; // [esp+4h] [ebp-10h] BYREF
  HDROP v6; // [esp+10h] [ebp-4h] BYREF

  result = (*(int (__stdcall **)(int, void *, STGMEDIUM *))(*(_DWORD *)a1 + 12))(a1, &unk_4DFE5C, &v5);
  if ( !result )
  {
    v6 = (HDROP)GlobalLock(v5.hBitmap);
    if ( v6 )
    {
      sub_4603C0(a2, &v6, a3, a4);
      GlobalUnlock(v5.hBitmap);
    }
    ReleaseStgMedium(&v5);
    return 0;
  }
  return result;
}

//----- (00461780) --------------------------------------------------------
void __thiscall sub_461780(int *this, DWORD a2, int *a3)
{
  int v4; // ecx
  int v5; // edx
  char v6; // bl
  int (__stdcall *v7)(int *, __int16 *, STGMEDIUM *); // eax
  int *v8; // eax
  int v9; // eax
  _DWORD *v10; // eax
  int v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // eax
  __int16 v16; // [esp+14h] [ebp-5Ch] BYREF
  int v17; // [esp+18h] [ebp-58h]
  int v18; // [esp+1Ch] [ebp-54h]
  int v19; // [esp+20h] [ebp-50h]
  int v20; // [esp+24h] [ebp-4Ch]
  STGMEDIUM v21; // [esp+28h] [ebp-48h] BYREF
  int pExceptionObject[3]; // [esp+34h] [ebp-3Ch] BYREF
  STGMEDIUM v23; // [esp+40h] [ebp-30h] BYREF
  void *v24; // [esp+4Ch] [ebp-24h] BYREF
  int v25; // [esp+50h] [ebp-20h]
  int v26[2]; // [esp+58h] [ebp-18h] BYREF
  char *v27[4]; // [esp+60h] [ebp-10h] BYREF
  int v28; // [esp+7Ch] [ebp+Ch]

  v4 = *a3;
  v5 = a3[1];
  v6 = 0;
  v28 = 0;
  v26[0] = v4;
  v26[1] = v5;
  v16 = RegisterClipboardFormatW(L"Preferred DropEffect");
  v20 = 1;
  v18 = 1;
  v7 = *(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*this + 12);
  v19 = -1;
  v17 = 0;
  if ( !v7(this, &v16, &v23) )
  {
    v8 = (int *)GlobalLock(v23.hBitmap);
    if ( v8 )
    {
      v9 = *v8;
      if ( v9 )
      {
        v6 = v9;
        v28 = 1;
        GlobalUnlock(v23.hBitmap);
      }
    }
    ReleaseStgMedium(&v23);
  }
  v25 = 0;
  v10 = operator new(0x24u);
  if ( !v10 )
  {
    v27[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v27);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v24 = v10;
  *v10 = v10;
  *((_DWORD *)v24 + 1) = v24;
  v27[3] = 0;
  v11 = dword_4DFE68;
  dword_4DFE68 = -1;
  v12 = (*(int (__stdcall **)(int *, void *))(*this + 20))(this, &unk_4DFE5C);
  dword_4DFE68 = v11;
  if ( v12 || (*(int (__stdcall **)(int *, void *, STGMEDIUM *))(*this + 12))(this, &unk_4DFE5C, &v21) )
  {
    v14 = dword_4EF75C;
    dword_4EF75C = -1;
    v15 = (*(int (__stdcall **)(int *, __int16 *))(*this + 20))(this, &word_4EF750);
    dword_4EF75C = v14;
    if ( v15 || (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*this + 12))(this, &word_4EF750, &v21) )
    {
      if ( sub_45F4E0((int)this, (int)&word_4EF73C) )
      {
        v13 = sub_460EF0(this, a2, (int)&v24);
      }
      else if ( sub_45F4E0((int)this, (int)&unk_4DFE84) )
      {
        v13 = sub_460DA0(a2, (int)&v24, (int)this);
      }
      else if ( sub_45F4E0((int)this, (int)&unk_4DFE70) )
      {
        v13 = sub_460BF0(&v24, a2, (int)this);
      }
      else
      {
        if ( !sub_45F4E0((int)this, (int)&unk_4DFE98) )
          goto LABEL_26;
        v13 = sub_460890((char **)&v24, a2, (int)this);
      }
    }
    else
    {
      ReleaseStgMedium(&v21);
      if ( (*(int (__stdcall **)(int *, __int16 *, STGMEDIUM *))(*this + 12))(this, &word_4EF750, &v21) )
        goto LABEL_26;
      v13 = sub_45F570(&v21);
    }
  }
  else
  {
    ReleaseStgMedium(&v21);
    v13 = sub_461720((int)this, (_DWORD *)a2, v28, v6);
  }
  if ( !v13 && v25 && *(_DWORD *)(a2 + 12) )
    (***(void (__thiscall ****)(_DWORD, void **, int *))(a2 + 12))(*(_DWORD *)(a2 + 12), &v24, v26);
LABEL_26:
  sub_40A140((int)&v24);
  operator delete(v24);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4DFE68: using guessed type int dword_4DFE68;
// 4EF73C: using guessed type __int16 word_4EF73C;
// 4EF750: using guessed type __int16 word_4EF750;
// 4EF75C: using guessed type int dword_4EF75C;

//----- (00461A40) --------------------------------------------------------
void __userpurge sub_461A40(
        int a1@<eax>,
        int a2@<edx>,
        int *a3@<ecx>,
        _DWORD *a4,
        _DWORD *a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10)
{
  a4[5] = a9;
  a4[4] = a1;
  a4[6] = a10;
  a4[2] = a3;
  a4[7] = *a5;
  a4[8] = a6;
  a4[10] = a7;
  a4[9] = a2;
  a4[3] = a8;
  a4[11] = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      sub_45F7F0(a4);
  }
  else
  {
    sub_461780(a3, (DWORD)a4, a4 + 5);
  }
}

//----- (00461AB0) --------------------------------------------------------
int __stdcall sub_461AB0(int a1, int a2)
{
  *(_DWORD *)(a1 + 20) = 1;
  return 0;
}

//----- (00461AD0) --------------------------------------------------------
int __stdcall sub_461AD0(int a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
  return 0;
}

//----- (00461AF0) --------------------------------------------------------
int __stdcall sub_461AF0(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

//----- (00461B10) --------------------------------------------------------
int __stdcall sub_461B10(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 24);
  return 0;
}

//----- (00461B30) --------------------------------------------------------
int __stdcall sub_461B30(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)(a1 + 20) = 0;
  return 0;
}

//----- (00461B50) --------------------------------------------------------
int __stdcall sub_461B50(int a1, int a2)
{
  return -2147221501;
}

//----- (00461B60) --------------------------------------------------------
int __stdcall sub_461B60(int a1, int a2)
{
  return -2147221501;
}

//----- (00461B70) --------------------------------------------------------
int __stdcall sub_461B70(int a1, int a2, int a3, int a4, int a5)
{
  return -2147467263;
}

//----- (00461B80) --------------------------------------------------------
int __stdcall sub_461B80(int a1, int a2, int a3)
{
  if ( !a3 )
    return -2147024809;
  *(_DWORD *)(a3 + 4) = 0;
  return -2147467263;
}

//----- (00461BB0) --------------------------------------------------------
int __stdcall sub_461BB0(int a1, int a2, int a3)
{
  return -2147221399;
}

//----- (00461BC0) --------------------------------------------------------
HANDLE __usercall sub_461BC0@<eax>(int a1@<eax>, int a2@<ebx>, _DWORD *a3@<edi>)
{
  HANDLE result; // eax

  *a3 = *(_DWORD *)a1;
  a3[2] = 0;
  if ( *(_DWORD *)(a1 + 8) )
  {
    a3[2] = *(_DWORD *)(a1 + 8);
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 8) + 4))(*(_DWORD *)(a1 + 8));
  }
  result = (HANDLE)(*(_DWORD *)(a2 + 16) - 1);
  switch ( *(_DWORD *)(a2 + 16) )
  {
    case 1:
    case 2:
    case 0x10:
    case 0x20:
    case 0x40:
      result = OleDuplicateData(*(HANDLE *)(a1 + 4), *(_WORD *)a2, 0);
      a3[1] = result;
      break;
    case 4:
    case 8:
      a3[1] = *(_DWORD *)(a1 + 4);
      result = (HANDLE)(*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 4) + 4))(*(_DWORD *)(a1 + 4));
      break;
    default:
      return result;
  }
  return result;
}

//----- (00461CB0) --------------------------------------------------------
LONG __stdcall sub_461CB0(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 + 8));
}

//----- (00461CD0) --------------------------------------------------------
int __stdcall sub_461CD0(int a1, __int16 *a2)
{
  _DWORD *v3; // edx
  _DWORD *v4; // eax
  __int16 v5; // bx
  int v6[8]; // [esp+0h] [ebp-20h] BYREF

  if ( !a2 )
    return -2147024809;
  v3 = *(_DWORD **)(a1 + 12);
  v4 = (_DWORD *)*v3;
  if ( (_DWORD *)*v3 == v3 )
    return -2147221404;
  v5 = *a2;
  while ( 1 )
  {
    qmemcpy(v6, v4 + 2, sizeof(v6));
    if ( LOWORD(v6[0]) == v5 && (v6[4] & *((_DWORD *)a2 + 4)) != 0 && v6[2] == *((_DWORD *)a2 + 2) )
      break;
    v4 = (_DWORD *)*v4;
    if ( v4 == v3 )
      return -2147221404;
  }
  return 0;
}

//----- (00461D50) --------------------------------------------------------
int __stdcall sub_461D50(_DWORD *a1, __int16 *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  _DWORD *v5; // eax
  __int16 v6; // bx
  int v7[8]; // [esp+10h] [ebp-20h] BYREF

  if ( !a2 || !a3 )
    return -2147024809;
  if ( (*(int (__stdcall **)(_DWORD *, __int16 *))(*a1 + 20))(a1, a2) == -2147221404 )
    return -2147221404;
  v4 = (_DWORD *)a1[3];
  v5 = (_DWORD *)*v4;
  if ( (_DWORD *)*v4 == v4 )
    return -2147221404;
  v6 = *a2;
  while ( 1 )
  {
    qmemcpy(v7, v5 + 2, sizeof(v7));
    if ( LOWORD(v7[0]) == v6 && (v7[4] & *((_DWORD *)a2 + 4)) != 0 && v7[2] == *((_DWORD *)a2 + 2) )
      break;
    v5 = (_DWORD *)*v5;
    if ( v5 == v4 )
      return -2147221404;
  }
  sub_461BC0((int)&v7[5], (int)v7, a3);
  return 0;
}

//----- (00461E10) --------------------------------------------------------
int __stdcall sub_461E10(int a1, _DWORD *a2, _DWORD *a3)
{
  int v4; // ecx

  if ( !a3 )
    return -2147467261;
  *a3 = 0;
  if ( sub_40AA20(dword_4BD9FC, a2) || sub_40AA20(&stru_4BD95C, a2) )
  {
    v4 = a1;
    *a3 = a1;
  }
  else
  {
    if ( !sub_40AA20(dword_4BD9AC, a2) )
      return -2147467262;
    v4 = a1;
    if ( a1 )
      *a3 = a1 + 4;
    else
      *a3 = 0;
  }
  if ( *a3 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 4))(v4);
    return 0;
  }
  return -2147467262;
}
// 4BD9AC: using guessed type _DWORD dword_4BD9AC[4];
// 4BD9FC: using guessed type _DWORD dword_4BD9FC[4];

//----- (00461EA0) --------------------------------------------------------
void __stdcall sub_461EA0(_DWORD *a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // [esp+Ch] [ebp-24h]
  _DWORD v8[8]; // [esp+10h] [ebp-20h] BYREF

  v1 = a1;
  *a1 = &CDataObject::`vftable';
  a1[1] = &CDataObject::`vftable';
  v2 = (_DWORD *)a1[3];
  v3 = (_DWORD *)*v2;
  v7 = v2;
  if ( (_DWORD *)*v2 != v2 )
  {
    do
    {
      qmemcpy(v8, v3 + 2, sizeof(v8));
      ReleaseStgMedium((LPSTGMEDIUM)&v8[5]);
      v3 = (_DWORD *)*v3;
    }
    while ( v3 != v7 );
    v1 = a1;
  }
  v4 = (_DWORD **)v1[3];
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(v1[3] + 4) = v1[3];
  v1[4] = 0;
  if ( v5 != (_DWORD *)v1[3] )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != (_DWORD *)v1[3] );
  }
  operator delete((void *)v1[3]);
}
// 4CC428: using guessed type void *CDataObject::`vftable';
// 4CC45C: using guessed type void *CDataObject::`vftable';

//----- (00461F40) --------------------------------------------------------
int __stdcall sub_461F40(int a1, int *a2, int *a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // ecx
  int v9; // edx
  int v10; // esi
  char **v11; // eax
  int v12; // ecx
  int v14[5]; // [esp+10h] [ebp-20h] BYREF
  int v15[3]; // [esp+24h] [ebp-Ch] BYREF

  if ( !a2 || !a3 )
    return -2147024809;
  v4 = a2[1];
  v14[0] = *a2;
  v5 = a2[2];
  v14[1] = v4;
  v6 = a2[3];
  v14[2] = v5;
  v7 = a2[4];
  v14[3] = v6;
  v14[4] = v7;
  if ( a4 )
  {
    v8 = a3[1];
    v15[0] = *a3;
    v9 = a3[2];
    v15[1] = v8;
    v15[2] = v9;
  }
  else
  {
    sub_461BC0((int)a3, (int)a2, v15);
  }
  v10 = *(_DWORD *)(a1 + 12);
  v11 = sub_41A2B0((char *)v10, *(_DWORD *)(v10 + 4), (int)v14);
  v12 = *(_DWORD *)(a1 + 16);
  if ( v12 == 134217726 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 16) = v12 + 1;
  *(_DWORD *)(v10 + 4) = v11;
  *(_DWORD *)v11[1] = v11;
  return 0;
}

//----- (00462000) --------------------------------------------------------
LONG __stdcall sub_462000(void *a1)
{
  LONG result; // eax

  result = InterlockedDecrement((volatile LONG *)a1 + 2);
  if ( !result )
  {
    if ( a1 )
    {
      sub_461EA0(a1);
      operator delete(a1);
    }
    return 0;
  }
  return result;
}

//----- (00462030) --------------------------------------------------------
_DWORD *__stdcall sub_462030(_DWORD *a1, int *a2, int *a3)
{
  _DWORD *v3; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  char **v14; // eax
  int v15; // ecx
  int v17[8]; // [esp+10h] [ebp-44h] BYREF
  int pExceptionObject[3]; // [esp+30h] [ebp-24h] BYREF
  char *v19; // [esp+3Ch] [ebp-18h] BYREF
  int v20; // [esp+40h] [ebp-14h]
  int v21; // [esp+50h] [ebp-4h]
  int v22; // [esp+64h] [ebp+10h]

  *a1 = &CDataObject::`vftable';
  a1[1] = &CDataObject::`vftable';
  a1[4] = 0;
  v3 = operator new(0x28u);
  if ( !v3 )
  {
    v19 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v19);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[3] = v3;
  *v3 = v3;
  *(_DWORD *)(a1[3] + 4) = a1[3];
  v21 = 0;
  v20 = 0;
  a1[2] = 1;
  do
  {
    v6 = a2[1];
    v7 = a2[2];
    v17[0] = *a2;
    v8 = a2[3];
    v17[1] = v6;
    v9 = a2[4];
    v17[2] = v7;
    v10 = *a3;
    v17[3] = v8;
    v11 = a3[1];
    v17[4] = v9;
    v12 = a3[2];
    v17[5] = v10;
    v17[6] = v11;
    v13 = a1[3];
    v17[7] = v12;
    v22 = v13;
    v14 = sub_41A2B0((char *)v13, *(_DWORD *)(v13 + 4), (int)v17);
    v15 = a1[4];
    if ( v15 == 134217726 )
      std::_Xlength_error("list<T> too long");
    a1[4] = v15 + 1;
    *(_DWORD *)(v22 + 4) = v14;
    *(_DWORD *)v14[1] = v14;
    a2 += 5;
    a3 += 3;
    ++v20;
  }
  while ( v20 < 2 );
  a1[7] = 0;
  a1[6] = 0;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC428: using guessed type void *CDataObject::`vftable';
// 4CC45C: using guessed type void *CDataObject::`vftable';

//----- (00462160) --------------------------------------------------------
int __usercall sub_462160@<eax>(_DWORD *a1@<esi>, int *a2, int *a3)
{
  _DWORD *v3; // eax
  int result; // eax

  v3 = operator new(0x20u);
  if ( v3 )
  {
    *a1 = sub_462030(v3, a2, a3);
    return 0;
  }
  else
  {
    result = 0;
    *a1 = 0;
  }
  return result;
}

//----- (004621E0) --------------------------------------------------------
int __stdcall sub_4621E0(int a1, int a2, int a3)
{
  int *v4; // eax
  int *v5; // ebx
  int *v6; // ecx
  int *v7; // eax
  int v8; // edi
  int *v9; // eax
  int *v10; // esi
  char **v11; // eax
  char **v12[3]; // [esp-10h] [ebp-74h] BYREF
  int v13; // [esp-4h] [ebp-68h]
  int *v14; // [esp+10h] [ebp-54h]
  char ***v15; // [esp+14h] [ebp-50h]
  char *v16; // [esp+18h] [ebp-4Ch] BYREF
  int *v17; // [esp+1Ch] [ebp-48h] BYREF
  int v18; // [esp+20h] [ebp-44h]
  int pExceptionObject[3]; // [esp+28h] [ebp-3Ch] BYREF
  char *v20[12]; // [esp+34h] [ebp-30h] BYREF

  if ( !a3 )
    return -2147024809;
  if ( a2 != 1 )
    return -2147467263;
  v18 = 0;
  v4 = (int *)operator new(0x1Cu);
  v5 = v4;
  if ( !v4 )
  {
    v16 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v16);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v4 = (int)v4;
  v17 = v4;
  v4[1] = (int)v4;
  v20[11] = 0;
  v6 = *(int **)(a1 + 12);
  v7 = (int *)*v6;
  v15 = (char ***)v6;
  v14 = v7;
  if ( v7 != v6 )
  {
    while ( 1 )
    {
      qmemcpy(v20, v7 + 2, 0x20u);
      v11 = sub_416060(v20, (char *)v5, v5[1]);
      if ( v18 == 214748363 )
        std::_Xlength_error("list<T> too long");
      ++v18;
      v5[1] = (int)v11;
      *(_DWORD *)v11[1] = v11;
      v14 = (int *)*v14;
      if ( v14 == (int *)v15 )
        break;
      v7 = v14;
    }
  }
  v13 = a3;
  v15 = v12;
  sub_41A1F0(v12, &v17);
  v8 = sub_45E980(v12[0], (int)v12[1], (int)v12[2], v13);
  v9 = (int *)*v5;
  *v5 = (int)v5;
  v5[1] = (int)v5;
  if ( v9 != v5 )
  {
    do
    {
      v10 = (int *)*v9;
      operator delete(v9);
      v9 = v10;
    }
    while ( v10 != v5 );
  }
  operator delete(v5);
  return v8;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00462390) --------------------------------------------------------
void __usercall sub_462390(int a1@<eax>)
{
  void **v1; // ebx

  v1 = (void **)(a1 + 12);
  sub_40A140(a1 + 12);
  operator delete(*v1);
}

//----- (004623B0) --------------------------------------------------------
int __userpurge sub_4623B0@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  int pExceptionObject[3]; // [esp+4h] [ebp-10h] BYREF
  char *v5; // [esp+10h] [ebp-4h] BYREF

  *(_DWORD *)(a1 + 16) = 0;
  v2 = operator new(0x24u);
  if ( !v2 )
  {
    v5 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 12) = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00462410) --------------------------------------------------------
void __usercall sub_462410(int a1@<esi>)
{
  WPARAM v1; // eax
  WPARAM v2; // ebx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  LPARAM *v5; // eax
  _DWORD *i; // [esp+4h] [ebp-24h]
  LPARAM lParam[5]; // [esp+8h] [ebp-20h] BYREF
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = 0;
  if ( v1 )
  {
    SendMessageW(*(HWND *)a1, 0x404u, v1, *(_DWORD *)(a1 + 8));
    operator delete(*(void **)(a1 + 8));
    v3 = *(_DWORD **)(a1 + 12);
    v4 = (_DWORD *)*v3;
    for ( i = v3; v4 != i; v4 = (_DWORD *)*v4 )
    {
      LOWORD(lParam[0]) = 0;
      v8 = 7;
      lParam[4] = 0;
      sub_4090E0((int)lParam, v4 + 2, 0, 0xFFFFFFFF);
      v5 = (LPARAM *)lParam[0];
      if ( v8 < 8 )
        v5 = lParam;
      SendMessageW(*(HWND *)a1, 0x40Bu, v2++, (LPARAM)v5);
      if ( v8 >= 8 )
        operator delete((void *)lParam[0]);
    }
    *(_DWORD *)(a1 + 4) = 0;
    sub_40A140(a1 + 12);
    *(_BYTE *)(a1 + 24) = 0;
  }
}

//----- (004624E0) --------------------------------------------------------
void __usercall sub_4624E0(int a1@<esi>)
{
  signed int v1; // ebx
  void *v2; // eax
  int v3; // edi
  char *v4; // eax
  int v5; // ecx
  HWND v6; // [esp-10h] [ebp-450h]
  LPARAM lParam; // [esp+Ch] [ebp-434h] BYREF
  WPARAM wParam; // [esp+10h] [ebp-430h]
  void *v9[5]; // [esp+14h] [ebp-42Ch] BYREF
  unsigned int v10; // [esp+28h] [ebp-418h]
  __int16 Src[512]; // [esp+30h] [ebp-410h] BYREF
  int v12; // [esp+43Ch] [ebp-4h]

  if ( !*(_BYTE *)(a1 + 24) )
  {
    v1 = SendMessageW(*(HWND *)a1, 0x406u, 0, 0);
    v2 = operator new[](4 * v1);
    *(_DWORD *)(a1 + 8) = v2;
    SendMessageW(*(HWND *)a1, 0x406u, v1, (LPARAM)v2);
    for ( wParam = 0; (int)wParam < v1; ++wParam )
    {
      SendMessageW(*(HWND *)a1, 0x40Du, wParam, (LPARAM)Src);
      v10 = 7;
      v9[4] = 0;
      LOWORD(v9[0]) = 0;
      sub_4094F0(v9, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
      v12 = 0;
      v3 = *(_DWORD *)(a1 + 12);
      v4 = sub_40A200((char *)v3, *(_DWORD *)(v3 + 4), (int)v9);
      v5 = *(_DWORD *)(a1 + 16);
      if ( v5 == 153391688 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 16) = v5 + 1;
      *(_DWORD *)(v3 + 4) = v4;
      **((_DWORD **)v4 + 1) = v4;
      v12 = -1;
      if ( v10 >= 8 )
        operator delete(v9[0]);
    }
    v6 = *(HWND *)a1;
    *(_DWORD *)(a1 + 4) = v1;
    lParam = -1;
    SendMessageW(v6, 0x404u, 1u, (LPARAM)&lParam);
    *(_BYTE *)(a1 + 24) = 1;
  }
}
// 4624E0: using guessed type unsigned __int16 Src[512];

//----- (00462710) --------------------------------------------------------
_DWORD *__userpurge sub_462710@<eax>(int a1@<eax>, unsigned int a2@<ecx>, int a3)
{
  _DWORD *v3; // ebx
  _DWORD *result; // eax
  int *v5; // esi
  unsigned int v6; // edi
  unsigned int v7; // edx
  unsigned __int8 v8; // cl
  int v9; // edx
  int (__stdcall *v10)(int *, int *); // ecx
  int v11[3]; // [esp+4h] [ebp-24h] BYREF
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]

  v3 = *(_DWORD **)(a1 + 12);
  result = (_DWORD *)*v3;
  if ( (_DWORD *)*v3 != v3 )
  {
    while ( 1 )
    {
      v5 = (int *)result[5];
      v6 = result[7];
      v12 = result[2];
      v13 = result[3];
      v14 = result[4];
      v7 = result[6];
      if ( a2 >= v7 && a2 < v6 )
        break;
      result = (_DWORD *)*result;
      if ( result == v3 )
        return result;
    }
    v8 = a2 - v7;
    v9 = *v5;
    v11[1] = 0;
    v13 = 0;
    v14 = 0;
    v12 = v8;
    v10 = *(int (__stdcall **)(int *, int *))(v9 + 16);
    v11[0] = 36;
    v11[2] = a3;
    v15 = 5;
    return (_DWORD *)v10(v5, v11);
  }
  return result;
}

//----- (00462790) --------------------------------------------------------
int __fastcall sub_462790(int a1, unsigned int a2, int a3)
{
  _DWORD *v3; // ebx
  _DWORD *v4; // ecx
  int result; // eax
  unsigned int v6; // esi
  int v7; // edi

  v3 = *(_DWORD **)(a1 + 12);
  v4 = (_DWORD *)*v3;
  result = -2147467259;
  if ( (_DWORD *)*v3 != v3 )
  {
    while ( 1 )
    {
      v6 = v4[6];
      v7 = v4[5];
      if ( a2 >= v6 && a2 < v4[7] )
        break;
      v4 = (_DWORD *)*v4;
      if ( v4 == v3 )
        return -2147467259;
    }
    if ( !v7 )
      return -2147467259;
    return (*(int (__stdcall **)(int, unsigned int, int, _DWORD, int, int))(*(_DWORD *)v7 + 20))(
             v7,
             a2 - v6,
             5,
             0,
             a3,
             512);
  }
  return result;
}

//----- (00462810) --------------------------------------------------------
int __stdcall sub_462810(int a1, int a2, HMENU hMenu, HMENU a4, int a5)
{
  unsigned int v5; // edx
  UINT MenuItemID; // eax
  int result; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // ecx
  int v10; // esi
  int v11; // eax
  char v12; // [esp+1Bh] [ebp-1h]
  int v13; // [esp+24h] [ebp+8h]

  v5 = -1;
  v12 = 0;
  switch ( a2 )
  {
    case 43:
    case 44:
      v5 = *((_DWORD *)a4 + 2);
      break;
    case 279:
      MenuItemID = GetMenuItemID(hMenu, 0);
      goto LABEL_5;
    case 288:
      MenuItemID = GetMenuItemID(a4, 0);
      v12 = 1;
LABEL_5:
      v5 = MenuItemID;
      break;
    default:
      break;
  }
  result = -2147467259;
  if ( v5 != -1 )
  {
    v8 = *(_DWORD **)(a1 + 12);
    v9 = (_DWORD *)*v8;
    v13 = (int)v8;
    if ( (_DWORD *)*v8 != v8 )
    {
      while ( 1 )
      {
        v10 = v9[2];
        v11 = v9[3];
        if ( v5 >= v9[6] && v5 < v9[7] )
          break;
        v9 = (_DWORD *)*v9;
        if ( v9 == (_DWORD *)v13 )
          return -2147467259;
      }
      if ( v10 )
      {
        return (*(int (__stdcall **)(int, int, HMENU, HMENU, int))(*(_DWORD *)v10 + 28))(v10, a2, hMenu, a4, a5);
      }
      else
      {
        if ( !v11 || v12 )
          return -2147467259;
        return (*(int (__stdcall **)(int, int, HMENU, HMENU))(*(_DWORD *)v11 + 24))(v11, a2, hMenu, a4);
      }
    }
  }
  return result;
}

//----- (00462A10) --------------------------------------------------------
void __stdcall sub_462A10(HMENU hMenu)
{
  int *v1; // esi
  int v2; // edi
  char v3; // bl
  _DWORD *v4; // eax
  int v5; // ebx
  int *v6; // edi
  struct tagMENUITEMINFOW mii; // [esp+14h] [ebp-58h] BYREF
  void *v8; // [esp+44h] [ebp-28h] BYREF
  int *v9; // [esp+48h] [ebp-24h]
  int *v10; // [esp+4Ch] [ebp-20h]
  int i; // [esp+54h] [ebp-18h] BYREF
  bool v12; // [esp+5Bh] [ebp-11h]
  int v13; // [esp+68h] [ebp-4h]

  v1 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v13 = 0;
  v2 = 0;
  v3 = 0;
  for ( i = 0; v2 < GetMenuItemCount(hMenu); i = v2 )
  {
    mii.cbSize = 48;
    mii.fMask = 256;
    GetMenuItemInfoW(hMenu, v2, 1, &mii);
    v12 = (mii.fType & 0x800) != 0;
    if ( v3 && (mii.fType & 0x800) != 0 )
    {
      if ( &i >= v1 || (v4 = v8, v8 > &i) )
      {
        if ( v1 == v10 )
        {
          sub_419E20((int *)&v8);
          v1 = v9;
        }
        if ( v1 )
          *v1 = v2;
      }
      else
      {
        v5 = ((char *)&i - (_BYTE *)v8) >> 2;
        if ( v1 == v10 )
        {
          sub_419E20((int *)&v8);
          v1 = v9;
          v4 = v8;
        }
        if ( v1 )
          *v1 = v4[v5];
      }
      v9 = ++v1;
    }
    v3 = v12;
    ++v2;
  }
  v6 = (int *)v8;
  if ( v1 != v8 )
  {
    do
      DeleteMenu(hMenu, *--v1, 0x400u);
    while ( v1 != v6 );
  }
  if ( v6 )
    operator delete(v6);
}

//----- (00462B50) --------------------------------------------------------
void __userpurge sub_462B50(HMENU a1@<esi>, int a2)
{
  int v2; // ebx
  int v3; // edi
  int **v4; // eax
  int *v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // edi
  MENUITEMINFOW mi; // [esp+8h] [ebp-3Ch] BYREF
  int v11; // [esp+38h] [ebp-Ch]
  int *v12; // [esp+3Ch] [ebp-8h]

  v2 = -1;
  v3 = 0;
  if ( GetMenuItemCount(a1) > 0 )
  {
    while ( GetMenuItemID(a1, v3) != 40060 )
    {
      if ( ++v3 >= GetMenuItemCount(a1) )
        goto LABEL_6;
    }
    v2 = v3;
  }
LABEL_6:
  mi.cbSize = 48;
  mi.fMask = 256;
  mi.fType = 2048;
  InsertMenuItemW(a1, v2 + 1, 1, &mi);
  InsertMenuItemW(a1, v2 + 2, 1, &mi);
  v4 = *(int ***)(a2 + 12);
  v11 = v2 + 2;
  v5 = *v4;
  v6 = 0;
  v12 = v5;
  if ( v5 != (int *)v4 )
  {
    while ( 1 )
    {
      v7 = v5[5];
      if ( v7 )
      {
        v8 = (*(int (__stdcall **)(int, HMENU, int, int, int, int))(*(_DWORD *)v7 + 12))(v7, a1, v11, v6 + 1, 1000, 4);
        if ( v8 >= 0 )
        {
          if ( (_WORD)v8 )
          {
            v5[6] = v6 + 1;
            v5[7] = (unsigned __int16)v8 + v6 + 1;
            v6 += (unsigned __int16)v8;
            v11 = -1;
            v9 = 0;
            if ( GetMenuItemCount(a1) > 0 )
            {
              while ( GetMenuItemID(a1, v9) != 40060 )
              {
                if ( ++v9 >= GetMenuItemCount(a1) )
                  goto LABEL_17;
              }
              v11 = v9;
            }
LABEL_17:
            v5 = v12;
            v11 += 2;
          }
        }
      }
      v12 = (int *)*v5;
      if ( v12 == *(int **)(a2 + 12) )
        break;
      v5 = v12;
    }
  }
  sub_462A10(a1);
}

//----- (00462C80) --------------------------------------------------------
void __stdcall sub_462C80(void **a1)
{
  _DWORD *v1; // ebx
  _DWORD *i; // esi
  int v3; // eax
  void *v4; // esi
  HMODULE v5; // ebx
  void ***v6; // ecx
  void **v7; // eax
  void **v8; // esi
  void **v9; // eax
  void **v10; // esi
  void *j; // [esp+28h] [ebp-10h]

  v1 = a1[3];
  for ( i = (_DWORD *)*v1; i != v1; i = (_DWORD *)*i )
  {
    v3 = i[5];
    if ( v3 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  }
  v4 = *(void **)*a1;
  for ( j = *a1; v4 != j; v4 = *(void **)v4 )
  {
    v5 = (HMODULE)*((_DWORD *)v4 + 2);
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)v4 + 3) + 8))(*((_DWORD *)v4 + 3));
    if ( v5 )
      FreeLibrary(v5);
  }
  v6 = (void ***)a1[3];
  v7 = *v6;
  *v6 = (void **)v6;
  *((_DWORD *)a1[3] + 1) = a1[3];
  a1[4] = 0;
  if ( v7 != a1[3] )
  {
    do
    {
      v8 = (void **)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while ( v8 != a1[3] );
  }
  operator delete(a1[3]);
  v9 = *(void ***)*a1;
  *(_DWORD *)*a1 = *a1;
  *((_DWORD *)*a1 + 1) = *a1;
  a1[1] = 0;
  if ( v9 != *a1 )
  {
    do
    {
      v10 = (void **)*v9;
      operator delete(v9);
      v9 = v10;
    }
    while ( v10 != *a1 );
  }
  operator delete(*a1);
}

//----- (00462DB0) --------------------------------------------------------
int **__stdcall sub_462DB0(int **a1, const ITEMIDLIST *a2, int a3, int a4)
{
  int *v4; // eax
  int *v5; // eax
  int v6; // eax
  int v7; // edi
  int (__stdcall ***v9)(_DWORD, void *, char **); // esi
  int (__stdcall **v10)(_DWORD, void *, int *); // ecx
  int (__stdcall *v11)(_DWORD, void *, int *); // eax
  int (__stdcall *v12)(_DWORD, void *, int *); // edx
  int v13; // eax
  int v14; // eax
  int *v15; // edi
  char **v16; // eax
  int *v17; // ecx
  int v18; // [esp-4h] [ebp-6Ch]
  char *v19[3]; // [esp+14h] [ebp-54h] BYREF
  int v20[3]; // [esp+20h] [ebp-48h] BYREF
  int pExceptionObject[3]; // [esp+2Ch] [ebp-3Ch] BYREF
  char *v22; // [esp+38h] [ebp-30h] BYREF
  char *v23; // [esp+3Ch] [ebp-2Ch] BYREF
  int v24[2]; // [esp+40h] [ebp-28h] BYREF
  char *v25; // [esp+48h] [ebp-20h] BYREF
  char *v26; // [esp+4Ch] [ebp-1Ch] BYREF
  char *v27; // [esp+50h] [ebp-18h] BYREF
  int v28; // [esp+54h] [ebp-14h] BYREF
  int v29; // [esp+58h] [ebp-10h] BYREF
  int v30; // [esp+64h] [ebp-4h]

  a1[1] = 0;
  v4 = (int *)operator new(0x10u);
  if ( !v4 )
  {
    v23 = 0;
    std::exception::exception((std::exception *)v20, (const char *const *)&v23);
    v20[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v20, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (int)v4;
  (*a1)[1] = (int)*a1;
  v30 = 0;
  a1[4] = 0;
  v5 = (int *)operator new(0x20u);
  if ( !v5 )
  {
    v22 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v22);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  a1[3] = v5;
  *v5 = (int)v5;
  a1[3][1] = (int)a1[3];
  LOBYTE(v30) = 1;
  v24[0] = 1610612736;
  sub_4665C0(a2, (int)v24);
  if ( (v24[0] & 0x20000000) != 0 && (v24[0] & 0x40000000) != 0 )
  {
    v6 = 1;
  }
  else if ( (v24[0] & 0x20000000) == 0 || (v24[0] & 0x40000000) != 0 )
  {
    v6 = 2;
  }
  else
  {
    v6 = 0;
  }
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      sub_467080((int)a1);
      v7 = **a1;
      v23 = (char *)*a1;
      v24[0] = v7;
      if ( (char *)v7 != v23 )
      {
        while ( 1 )
        {
          v9 = *(int (__stdcall ****)(_DWORD, void *, char **))(v7 + 12);
          v10 = (int (__stdcall **)(_DWORD, void *, int *))*v9;
          v24[1] = *(_DWORD *)(v7 + 8);
          v11 = *v10;
          v29 = 0;
          if ( v11(v9, &unk_4BD80C, &v29) >= 0 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            (*(void (__stdcall **)(int, const ITEMIDLIST *, int, _DWORD))(*(_DWORD *)v29 + 12))(v29, a2, a3, 0);
            (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
            if ( a4 )
            {
              v12 = (int (__stdcall *)(_DWORD, void *, int *))**v9;
              v28 = 0;
              if ( v12(v9, &unk_4C1058, &v28) >= 0 )
              {
                (*(void (__stdcall **)(int, int))(*(_DWORD *)v28 + 12))(v28, a4);
                (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
              }
            }
            v13 = (**v9)(v9, &unk_4BD85C, &v25);
            v20[0] = (int)v25;
            if ( v13 < 0 || !v25 )
            {
              v14 = (**v9)(v9, &unk_4BD81C, &v26);
              v20[0] = (int)v26;
              if ( v14 < 0 || !v26 )
              {
                (**v9)(v9, &unk_4BD7EC, &v27);
                v20[0] = (int)v27;
              }
            }
            v20[1] = 0;
            v20[2] = 0;
            v15 = a1[3];
            v19[2] = v27;
            v18 = v15[1];
            v19[1] = v26;
            v19[0] = v25;
            v16 = sub_419E70(v19, (char *)v15, v18);
            v17 = a1[4];
            if ( v17 == (int *)178956969 )
              std::_Xlength_error("list<T> too long");
            a1[4] = (int *)((char *)v17 + 1);
            v15[1] = (int)v16;
            v7 = v24[0];
            *(_DWORD *)v16[1] = v16;
          }
          v24[0] = *(_DWORD *)v7;
          if ( (char *)v24[0] == v23 )
            break;
          v7 = v24[0];
        }
      }
    }
  }
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00463030) --------------------------------------------------------
LRESULT __stdcall sub_463030(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  LRESULT result; // eax
  int v7; // [esp+Ch] [ebp-40Ch] BYREF
  HWND hWnda; // [esp+10h] [ebp-408h]
  LPARAM v9[256]; // [esp+14h] [ebp-404h] BYREF

  hWnda = hWnd;
  switch ( uMsg )
  {
    case 0x2Bu:
    case 0x2Cu:
    case 0x117u:
    case 0x120u:
      if ( sub_462810(dwRefData, uMsg, (HMENU)wParam, (HMENU)lParam, (int)&v7) < 0 )
        goto LABEL_11;
      if ( uMsg == 279 )
        goto LABEL_16;
      if ( uMsg == 44 || uMsg == 43 )
        result = 1;
      else
        result = v7;
      break;
    case 0x11Fu:
      if ( HIWORD(wParam) == 0xFFFF && !lParam )
      {
        sub_462410(*(_DWORD *)(dwRefData + 32));
        goto LABEL_11;
      }
      sub_4624E0(*(_DWORD *)(dwRefData + 32));
      if ( (unsigned int)(unsigned __int16)wParam < *(_DWORD *)(dwRefData + 24)
        || (unsigned int)(unsigned __int16)wParam > *(_DWORD *)(dwRefData + 28)
        || sub_462790(dwRefData, (unsigned __int16)wParam, (int)v9) )
      {
        goto LABEL_11;
      }
      SendMessageW(**(HWND **)(dwRefData + 32), 0x40Bu, 0, (LPARAM)v9);
LABEL_16:
      result = 0;
      break;
    default:
LABEL_11:
      result = DefSubclassProc(hWnda, uMsg, wParam, lParam);
      break;
  }
  return result;
}

//----- (00463280) --------------------------------------------------------
char __userpurge sub_463280@<al>(HMENU hMenu@<ecx>, int a2@<eax>, HWND a3@<ebx>, _DWORD *a4@<edi>, int a5)
{
  unsigned int v6; // esi

  if ( !a3 || !hMenu )
    return 0;
  a4[6] = 1;
  a4[7] = 1000;
  a4[8] = a2;
  sub_462B50(hMenu, (int)a4);
  SetWindowSubclass(a3, sub_463030, 1u, (DWORD_PTR)a4);
  v6 = TrackPopupMenu(hMenu, 0x142u, *(_DWORD *)a5, *(_DWORD *)(a5 + 4), 0, a3, 0);
  RemoveWindowSubclass(a3, sub_463030, 1u);
  if ( v6 )
  {
    if ( v6 <= 0x3E8 )
    {
      sub_462710((int)a4, v6, (int)a3);
      return 1;
    }
    SendMessageW(a3, 0x111u, (unsigned __int16)v6, 0);
  }
  return 1;
}
// 4632EE: conditional instruction was optimized away because esi.4!=0

//----- (00463340) --------------------------------------------------------
int __usercall sub_463340@<eax>(int a1@<edi>, UINT *a2@<esi>)
{
  HDC CompatibleDC; // ebx
  void *StockObject; // eax
  INT v5; // ecx
  WCHAR v6; // ax
  int v7; // eax
  int v8; // eax
  DWORD TabbedTextExtentW; // eax
  int v10; // ecx
  int v11; // eax
  HMENU v12; // [esp-10h] [ebp-2D8h]
  UINT v13; // [esp-Ch] [ebp-2D4h]
  int v14; // [esp-8h] [ebp-2D0h]
  HWND v15; // [esp-4h] [ebp-2CCh]
  HGDIOBJ v16; // [esp-4h] [ebp-2CCh]
  struct tagMENUITEMINFOW mii; // [esp+8h] [ebp-2C0h] BYREF
  int v18; // [esp+38h] [ebp-290h]
  HDC hDC; // [esp+3Ch] [ebp-28Ch]
  HGDIOBJ ho; // [esp+40h] [ebp-288h]
  INT nTabStopPositions; // [esp+44h] [ebp-284h] BYREF
  int pvParam[56]; // [esp+48h] [ebp-280h] BYREF
  LOGFONTW lf; // [esp+128h] [ebp-1A0h] BYREF
  WCHAR String[66]; // [esp+240h] [ebp-88h] BYREF

  v13 = a2[2];
  v12 = *(HMENU *)(a1 + 4);
  mii.cbSize = 48;
  mii.fMask = 256;
  GetMenuItemInfoW(v12, v13, 0, &mii);
  if ( (mii.fType & 0x800) != 0 )
  {
    a2[3] = 0;
    a2[4] = 5;
    return 1;
  }
  else
  {
    v15 = *(HWND *)a1;
    nTabStopPositions = 0;
    v18 = 0;
    hDC = GetDC(v15);
    CompatibleDC = CreateCompatibleDC(hDC);
    pvParam[0] = 500;
    if ( SystemParametersInfoW(0x29u, 0x1F4u, pvParam, 0) )
      StockObject = CreateFontIndirectW(&lf);
    else
      StockObject = GetStockObject(13);
    ho = StockObject;
    SelectObject(CompatibleDC, StockObject);
    GetMenuStringW(*(HMENU *)(a1 + 4), a2[2], String, 64, 0);
    v5 = nTabStopPositions;
    v6 = String[nTabStopPositions];
    if ( v6 )
    {
      do
      {
        if ( v6 == 9 )
          break;
        v6 = String[++v5];
      }
      while ( v6 );
      nTabStopPositions = v5;
    }
    v7 = 1;
    if ( String[v5] != 9 )
      v7 = v18;
    v14 = v7;
    v8 = lstrlenW(String);
    TabbedTextExtentW = GetTabbedTextExtentW(CompatibleDC, String, v8, v14, &nTabStopPositions);
    v10 = (unsigned __int16)TabbedTextExtentW + 22;
    v11 = HIWORD(TabbedTextExtentW) + 4;
    a2[3] = v10;
    if ( v11 <= 20 )
      v11 = 20;
    v16 = ho;
    a2[4] = v11;
    DeleteObject(v16);
    DeleteDC(CompatibleDC);
    ReleaseDC(*(HWND *)a1, hDC);
    return 1;
  }
}
// 463340: using guessed type int pvParam[56];

//----- (00463500) --------------------------------------------------------
int __usercall sub_463500@<eax>(int a1@<edi>)
{
  bool v1; // zf
  DWORD SysColor; // ebx
  LONG *v3; // esi
  LONG v4; // edx
  LONG v5; // ecx
  LONG v6; // edx
  int v7; // ebx
  DWORD v8; // eax
  HBRUSH SolidBrush; // ebx
  UINT MenuState; // ebx
  DWORD v11; // eax
  LONG v12; // ecx
  LONG v13; // edx
  WCHAR *v14; // eax
  __int16 v15; // cx
  int v16; // edx
  int v17; // edx
  __int16 v18; // cx
  __int16 *v19; // eax
  LONG v20; // ecx
  int v21; // ebx
  LONG v22; // eax
  LONG v23; // ecx
  int v24; // eax
  LONG v25; // ecx
  LONG v26; // eax
  LONG v27; // ecx
  int v28; // eax
  HMENU v30; // [esp-10h] [ebp-220h]
  UINT v31; // [esp-Ch] [ebp-21Ch]
  int v32; // [esp-8h] [ebp-218h]
  struct tagMENUITEMINFOW mii; // [esp+8h] [ebp-208h] BYREF
  int v34; // [esp+3Ch] [ebp-1D4h]
  HGDIOBJ v35; // [esp+44h] [ebp-1CCh]
  int v36; // [esp+4Ch] [ebp-1C4h] BYREF
  int v37; // [esp+50h] [ebp-1C0h]
  HGDIOBJ ho; // [esp+54h] [ebp-1BCh] BYREF
  struct tagRECT v39; // [esp+58h] [ebp-1B8h] BYREF
  struct tagRECT v40; // [esp+68h] [ebp-1A8h] BYREF
  struct tagRECT rc; // [esp+78h] [ebp-198h] BYREF
  WCHAR String[64]; // [esp+88h] [ebp-188h] BYREF
  __int16 v43[64]; // [esp+108h] [ebp-108h] BYREF
  __int16 chText[66]; // [esp+188h] [ebp-88h] BYREF

  v1 = (*(_BYTE *)(a1 + 12) & 3) == 0;
  v37 = 0;
  if ( !v1 )
  {
    if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
    {
      SysColor = GetSysColor(29);
      ho = CreateSolidBrush(0);
      v3 = (LONG *)(a1 + 28);
      FrameRect(*(HDC *)(a1 + 24), (const RECT *)(a1 + 28), (HBRUSH)ho);
      DeleteObject(ho);
      v4 = *(_DWORD *)(a1 + 28);
      v5 = *(_DWORD *)(a1 + 36);
      rc.top = *(_DWORD *)(a1 + 32);
      rc.left = v4;
      v6 = *(_DWORD *)(a1 + 40);
      rc.right = v5;
      rc.bottom = v6;
      InflateRect(&rc, -1, -1);
      v36 = 0;
      GdipCreateSolidFill(
        BYTE2(SysColor) | ((BYTE1(SysColor) | (((unsigned __int8)SysColor | 0x6400) << 8)) << 8),
        &v36);
      v7 = v36;
      v32 = *(_DWORD *)(a1 + 24);
      v34 = v36;
      ho = 0;
      GdipCreateFromHDC(v32, &ho);
      v35 = ho;
      GdipFillRectangleI(ho, v7, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top);
      GdipDeleteGraphics(v35);
      GdipDeleteBrush(v7);
    }
    else
    {
      v8 = GetSysColor(4);
      SolidBrush = CreateSolidBrush(v8);
      v3 = (LONG *)(a1 + 28);
      FillRect(*(HDC *)(a1 + 24), (const RECT *)(a1 + 28), SolidBrush);
      DeleteObject(SolidBrush);
    }
    SetBkMode(*(HDC *)(a1 + 24), 1);
    MenuState = GetMenuState(*(HMENU *)(a1 + 20), *(_DWORD *)(a1 + 8), 0);
    if ( (MenuState & 1) != 0 )
    {
      v11 = GetSysColor(17);
      SetTextColor(*(HDC *)(a1 + 24), v11);
    }
    if ( (MenuState & 0x800) != 0 && (MenuState & 0x10) == 0 || MenuState == -1 )
    {
      v12 = v3[1];
      v13 = v3[2];
      rc.left = *v3;
      rc.bottom = v3[3];
      rc.right = v13;
      rc.top = v12;
      OffsetRect(&rc, 0, (rc.bottom - v12) / 2);
      DrawEdge(*(HDC *)(a1 + 24), &rc, 6u, 2u);
    }
    if ( (MenuState & 8) != 0 )
      ImageList_Draw(himl, 21, *(HDC *)(a1 + 24), *v3 + 2, *(_DWORD *)(a1 + 32) + 2, 0);
    v31 = *(_DWORD *)(a1 + 8);
    v30 = *(HMENU *)(a1 + 20);
    mii.cbSize = 48;
    mii.fMask = 32;
    GetMenuItemInfoW(v30, v31, 0, &mii);
    if ( *(_DWORD *)(mii.dwItemData + 4) )
      ImageList_Draw(himl, *(_DWORD *)mii.dwItemData, *(HDC *)(a1 + 24), *v3 + 2, *(_DWORD *)(a1 + 32) + 2, 0);
    GetMenuStringW(*(HMENU *)(a1 + 20), *(_DWORD *)(a1 + 8), String, 64, 0);
    v14 = String;
    if ( String[0] )
    {
      v15 = String[0];
      do
      {
        if ( v15 == 9 )
          break;
        v16 = v37;
        ++v14;
        chText[v37] = v15;
        v15 = *v14;
        v37 = v16 + 1;
      }
      while ( v15 );
    }
    chText[v37] = 0;
    v17 = 0;
    if ( *v14 == 9 )
    {
      v18 = v14[1];
      v19 = (__int16 *)(v14 + 1);
      if ( v18 )
      {
        do
        {
          ++v19;
          v43[v17] = v18;
          v18 = *v19;
          ++v17;
        }
        while ( *v19 );
      }
    }
    v20 = *v3;
    v21 = *(_DWORD *)(a1 + 16);
    v43[v17] = 0;
    v22 = v3[2];
    v39.top = v3[1];
    v39.left = v20;
    v23 = v3[3];
    v39.right = v22;
    v39.bottom = v23;
    OffsetRect(&v39, 22, 0);
    v24 = lstrlenW((LPCWSTR)chText);
    DrawTextW(*(HDC *)(a1 + 24), (LPCWSTR)chText, v24, &v39, ((v21 & 0x100) << 12) | 0x64);
    v25 = *v3;
    v26 = v3[2];
    v40.top = v3[1];
    v40.left = v25;
    v27 = v3[3];
    v40.right = v26;
    v40.bottom = v27;
    InflateRect(&v40, -10, 0);
    v28 = lstrlenW((LPCWSTR)v43);
    DrawTextW(*(HDC *)(a1 + 24), (LPCWSTR)v43, v28, &v40, 0x100026u);
  }
  return 1;
}
// 4BD670: using guessed type int __stdcall GdipDeleteGraphics(_DWORD);
// 4BD67C: using guessed type int __stdcall GdipDeleteBrush(_DWORD);
// 4BD680: using guessed type int __stdcall GdipCreateSolidFill(_DWORD, _DWORD);
// 4BD6A8: using guessed type int __stdcall GdipFillRectangleI(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD6C0: using guessed type int __stdcall GdipCreateFromHDC(_DWORD, _DWORD);
// 463500: using guessed type WCHAR chText[66];
// 463500: using guessed type WCHAR var_108[64];

//----- (00463980) --------------------------------------------------------
void __stdcall sub_463980(int *a1)
{
  _DWORD *v1; // eax
  int **v2; // eax
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // eax
  int v7; // ecx
  int *v8; // eax
  int v9; // ecx
  void *v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13[3]; // [esp+Ch] [ebp-2Ch] BYREF
  _DWORD v14[8]; // [esp+18h] [ebp-20h] BYREF

  v14[7] = 0;
  while ( a1[4] )
  {
    v1 = sub_419BC0(v14, a1);
    v2 = (int **)sub_419D30((int)v1, v13);
    if ( *v2 )
      v3 = **v2;
    else
      v3 = 0;
    v4 = (unsigned int)v2[2];
    v5 = *(_DWORD *)(v3 + 8);
    v6 = v4 >> 1;
    v7 = v4 & 1;
    if ( v5 <= v6 )
      v6 -= v5;
    v8 = (int *)(*(_DWORD *)(*(_DWORD *)(v3 + 4) + 4 * v6) + 8 * v7);
    v9 = *v8;
    v10 = (void *)v8[1];
    v14[3] = v9;
    v11 = a1[4];
    if ( v11 )
    {
      v12 = v11 - 1;
      a1[4] = v12;
      if ( !v12 )
        a1[3] = 0;
    }
    operator delete(v10);
  }
  sub_4244A0((int)a1);
  operator delete((void *)*a1);
  *a1 = 0;
}
// 463980: using guessed type int var_2C[3];

//----- (00463A50) --------------------------------------------------------
int __thiscall sub_463A50(char ***this, int a2)
{
  _DWORD *v3; // eax
  int v4; // edi
  _DWORD *v5; // eax
  char **v6; // eax
  char *v7; // esi
  _DWORD *v8; // esi
  int v9; // esi
  char *v10; // eax
  int v11; // ecx
  int pExceptionObject[3]; // [esp+14h] [ebp-A0h] BYREF
  int v14; // [esp+20h] [ebp-94h]
  int v15; // [esp+24h] [ebp-90h] BYREF
  void *v16; // [esp+28h] [ebp-8Ch]
  char *v17; // [esp+2Ch] [ebp-88h] BYREF
  void *v18[5]; // [esp+30h] [ebp-84h] BYREF
  unsigned int v19; // [esp+44h] [ebp-70h]
  void *v20; // [esp+4Ch] [ebp-68h] BYREF
  int v21; // [esp+5Ch] [ebp-58h]
  unsigned int v22; // [esp+60h] [ebp-54h]
  void *v23[5]; // [esp+68h] [ebp-4Ch] BYREF
  unsigned int v24; // [esp+7Ch] [ebp-38h]
  void *v25[4]; // [esp+84h] [ebp-30h] BYREF
  int v26; // [esp+94h] [ebp-20h]
  unsigned int v27; // [esp+98h] [ebp-1Ch]
  int v28; // [esp+B0h] [ebp-4h]

  v14 = a2;
  v3 = operator new(0xCu);
  v4 = (int)v3;
  v16 = v3;
  v28 = 0;
  if ( v3 )
  {
    v3[1] = 0;
    v5 = operator new(0x40u);
    if ( !v5 )
    {
      v17 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_DWORD *)v4 = v5;
    *v5 = v5;
    *(_DWORD *)(*(_DWORD *)v4 + 4) = *(_DWORD *)v4;
  }
  else
  {
    v4 = 0;
  }
  v28 = -1;
  v6 = *this;
  v7 = **this;
  v16 = v6;
  v17 = v7;
  if ( v7 != (char *)v6 )
  {
    while ( 1 )
    {
      v8 = v7 + 8;
      v24 = 7;
      v23[4] = 0;
      LOWORD(v23[0]) = 0;
      sub_4090E0((int)v23, v8, 0, 0xFFFFFFFF);
      v28 = 1;
      LOWORD(v25[0]) = 0;
      v27 = 7;
      v26 = 0;
      sub_4090E0((int)v25, v8 + 7, 0, 0xFFFFFFFF);
      v28 = 2;
      if ( sub_4ADC50((int *)v25, (int *)v23) )
      {
        v19 = 7;
        v18[4] = 0;
        LOWORD(v18[0]) = 0;
        v22 = 7;
        v21 = 0;
        LOWORD(v20) = 0;
        LOBYTE(v28) = 3;
        sub_4090E0((int)v18, v23, 0, 0xFFFFFFFF);
        sub_4090E0((int)&v20, v25, 0, 0xFFFFFFFF);
        v9 = *(_DWORD *)v4;
        v10 = sub_40B0E0(*(char **)v4, *(_DWORD *)(*(_DWORD *)v4 + 4), (int)v18);
        v11 = *(_DWORD *)(v4 + 4);
        if ( v11 == 76695843 )
          std::_Xlength_error("list<T> too long");
        *(_DWORD *)(v4 + 4) = v11 + 1;
        *(_DWORD *)(v9 + 4) = v10;
        **((_DWORD **)v10 + 1) = v10;
        if ( v22 >= 8 )
          operator delete(v20);
        v22 = 7;
        v21 = 0;
        LOWORD(v20) = 0;
        if ( v19 >= 8 )
          operator delete(v18[0]);
      }
      v28 = -1;
      if ( v27 >= 8 )
        operator delete(v25[0]);
      v27 = 7;
      v26 = 0;
      LOWORD(v25[0]) = 0;
      if ( v24 >= 8 )
        operator delete(v23[0]);
      v17 = *(char **)v17;
      if ( v17 == v16 )
        break;
      v7 = v17;
    }
  }
  if ( *(_DWORD *)(v4 + 4) )
  {
    v15 = 0;
    v16 = (void *)v4;
    sub_419B10(v14, &v15);
    return 1;
  }
  else
  {
    sub_40B060(v4);
    operator delete(*(void **)v4);
    operator delete((void *)v4);
    return 0;
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00463D00) --------------------------------------------------------
void __thiscall sub_463D00(int ***this, int a2)
{
  char *v3; // eax
  char *v4; // esi
  int **v5; // eax
  int *v6; // edi
  _DWORD *v7; // edi
  char *v8; // eax
  int pExceptionObject[3]; // [esp+10h] [ebp-ACh] BYREF
  int v10; // [esp+1Ch] [ebp-A0h]
  int *v11; // [esp+20h] [ebp-9Ch]
  char *v12; // [esp+24h] [ebp-98h] BYREF
  void *v13; // [esp+28h] [ebp-94h] BYREF
  int v14; // [esp+2Ch] [ebp-90h]
  int *v15; // [esp+34h] [ebp-88h]
  void *v16[5]; // [esp+38h] [ebp-84h] BYREF
  unsigned int v17; // [esp+4Ch] [ebp-70h]
  void *v18; // [esp+54h] [ebp-68h] BYREF
  int v19; // [esp+64h] [ebp-58h]
  unsigned int v20; // [esp+68h] [ebp-54h]
  void *v21[5]; // [esp+70h] [ebp-4Ch] BYREF
  unsigned int v22; // [esp+84h] [ebp-38h]
  void *v23[4]; // [esp+8Ch] [ebp-30h] BYREF
  int v24; // [esp+9Ch] [ebp-20h]
  unsigned int v25; // [esp+A0h] [ebp-1Ch]
  int v26; // [esp+B8h] [ebp-4h]

  v10 = a2;
  v14 = 0;
  v3 = (char *)operator new(0x40u);
  v4 = v3;
  if ( !v3 )
  {
    v12 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)v3 = v3;
  v13 = v3;
  *((_DWORD *)v3 + 1) = v3;
  v26 = 0;
  v5 = *this;
  v6 = **this;
  v11 = (int *)v5;
  v15 = v6;
  if ( v6 != (int *)v5 )
  {
    while ( 1 )
    {
      v7 = v6 + 2;
      LOWORD(v21[0]) = 0;
      v22 = 7;
      v21[4] = 0;
      sub_4090E0((int)v21, v7, 0, 0xFFFFFFFF);
      LOBYTE(v26) = 1;
      v25 = 7;
      v24 = 0;
      LOWORD(v23[0]) = 0;
      sub_4090E0((int)v23, v7 + 7, 0, 0xFFFFFFFF);
      v17 = 7;
      v16[4] = 0;
      LOWORD(v16[0]) = 0;
      v20 = 7;
      v19 = 0;
      LOWORD(v18) = 0;
      LOBYTE(v26) = 3;
      sub_4090E0((int)v16, v23, 0, 0xFFFFFFFF);
      sub_4090E0((int)&v18, v21, 0, 0xFFFFFFFF);
      v8 = sub_40B0E0(v4, *((_DWORD *)v4 + 1), (int)v16);
      if ( v14 == 76695843 )
        std::_Xlength_error("list<T> too long");
      ++v14;
      *((_DWORD *)v4 + 1) = v8;
      **((_DWORD **)v8 + 1) = v8;
      if ( v20 >= 8 )
        operator delete(v18);
      v20 = 7;
      v19 = 0;
      LOWORD(v18) = 0;
      if ( v17 >= 8 )
        operator delete(v16[0]);
      LOBYTE(v26) = 0;
      if ( v25 >= 8 )
        operator delete(v23[0]);
      v25 = 7;
      v24 = 0;
      LOWORD(v23[0]) = 0;
      if ( v22 >= 8 )
        operator delete(v21[0]);
      v15 = (int *)*v15;
      if ( v15 == v11 )
        break;
      v6 = v15;
    }
  }
  sub_463A50((char ***)&v13, v10);
  sub_40B060((int)&v13);
  operator delete(v13);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00463F50) --------------------------------------------------------
void __usercall sub_463F50(int *a1@<edi>)
{
  _DWORD *v1; // eax
  int **v2; // eax
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  unsigned int v6; // eax
  int v7; // ecx
  int v8; // eax
  int ***v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13[3]; // [esp+8h] [ebp-18h] BYREF
  int v14[3]; // [esp+14h] [ebp-Ch] BYREF

  if ( a1[4] )
  {
    v1 = sub_419BC0(v14, a1);
    v2 = (int **)sub_419D30((int)v1, v13);
    if ( *v2 )
      v3 = **v2;
    else
      v3 = 0;
    v4 = (unsigned int)v2[2];
    v5 = *(_DWORD *)(v3 + 8);
    v6 = v4 >> 1;
    v7 = v4 & 1;
    if ( v5 <= v6 )
      v6 -= v5;
    v8 = *(_DWORD *)(*(_DWORD *)(v3 + 4) + 4 * v6);
    v9 = *(int ****)(v8 + 8 * v7 + 4);
    v10 = *(_DWORD *)(v8 + 8 * v7);
    v11 = a1[4];
    if ( v11 )
    {
      v12 = v11 - 1;
      a1[4] = v12;
      if ( !v12 )
        a1[3] = 0;
    }
    if ( !v10 )
      sub_463D00(v9, (int)a1);
    operator delete(v9);
  }
}
// 463F50: using guessed type int var_C[3];
// 463F50: using guessed type int var_18[3];

//----- (00463FD0) --------------------------------------------------------
int __userpurge sub_463FD0@<eax>(HWND a1@<ecx>, int **a2@<edi>, int a3, void *a4)
{
  int result; // eax
  int v5; // esi
  char ***v6; // eax
  char ***v7; // eax
  int v8[2]; // [esp+8h] [ebp-14h] BYREF
  int v9; // [esp+18h] [ebp-4h]

  result = sub_4AE060(a2, a1, (int)a4);
  v5 = result;
  if ( result )
  {
    v6 = (char ***)operator new(0xCu);
    v9 = 0;
    if ( v6 )
      v7 = sub_40AC30(v6, a2);
    else
      v7 = 0;
    v9 = -1;
    v8[1] = (int)v7;
    v8[0] = 3;
    sub_419B10(a3, v8);
    return v5;
  }
  return result;
}

//----- (00464130) --------------------------------------------------------
LSTATUS __cdecl sub_464130(HKEY a1, _DWORD **a2)
{
  int v2; // ecx
  _DWORD *v3; // esi
  int v4; // edi
  const WCHAR *v5; // ebx
  int v6; // eax
  LSTATUS v7; // ebx
  int v9; // [esp+Ch] [ebp-12Ch]
  _DWORD *v10; // [esp+14h] [ebp-124h]
  LPCWSTR lpString[5]; // [esp+18h] [ebp-120h] BYREF
  unsigned int v12; // [esp+2Ch] [ebp-10Ch]
  WCHAR ValueName[128]; // [esp+34h] [ebp-104h] BYREF

  v3 = (_DWORD *)**a2;
  v4 = 0;
  v9 = v2;
  v10 = *a2;
  if ( v3 == *a2 )
    return 0;
  while ( 1 )
  {
    v12 = 7;
    lpString[4] = 0;
    LOWORD(lpString[0]) = 0;
    sub_4090E0((int)lpString, v3 + 2, 0, 0xFFFFFFFF);
    sub_401000(0x80u, ValueName, L"%s%d", v9, v4);
    v5 = lpString[0];
    ++v4;
    if ( v12 < 8 )
      v5 = (const WCHAR *)lpString;
    v6 = lstrlenW(v5);
    v7 = RegSetValueExW(a1, ValueName, 0, 1u, (const BYTE *)v5, 2 * v6);
    if ( v7 )
      break;
    if ( v12 >= 8 )
      operator delete((void *)lpString[0]);
    v3 = (_DWORD *)*v3;
    if ( v3 == v10 )
      return 0;
  }
  if ( v12 >= 8 )
    operator delete((void *)lpString[0]);
  return v7;
}
// 464158: variable 'v2' is possibly undefined
// 4C2B64: using guessed type wchar_t aSD_1[5];

//----- (00464270) --------------------------------------------------------
LSTATUS __usercall sub_464270@<eax>(int a1@<ecx>, int a2@<edi>, HKEY a3)
{
  int v3; // esi
  LSTATUS result; // eax
  DWORD v5; // ecx
  char *v6; // esi
  char *v7; // eax
  int v8; // ecx
  DWORD Type; // [esp+10h] [ebp-53Ch] BYREF
  HKEY hKey; // [esp+14h] [ebp-538h]
  DWORD cbData; // [esp+18h] [ebp-534h] BYREF
  int v13; // [esp+1Ch] [ebp-530h]
  void *v14[5]; // [esp+20h] [ebp-52Ch] BYREF
  unsigned int v15; // [esp+34h] [ebp-518h]
  BYTE Data[2]; // [esp+3Ch] [ebp-510h] BYREF
  __int16 v18; // [esp+3Eh] [ebp-50Eh] BYREF
  WCHAR ValueName[128]; // [esp+43Ch] [ebp-110h] BYREF
  int v20; // [esp+548h] [ebp-4h]

  hKey = a3;
  v13 = 0;
  while ( 1 )
  {
    v3 = v13;
    sub_401000(0x80u, ValueName, L"%s%d", a1, v13);
    v13 = v3 + 1;
    cbData = 512;
    result = RegQueryValueExW(hKey, ValueName, 0, &Type, Data, &cbData);
    v5 = cbData;
    if ( cbData && Type == 1 )
    {
      if ( *(_WORD *)&Data[2 * cbData - 2] )
      {
        if ( cbData >= 0x200 )
          v5 = 512;
        *(_WORD *)&Data[2 * v5] = 0;
      }
    }
    else
    {
      *(_WORD *)Data = 0;
    }
    if ( result )
      break;
    LOWORD(v14[0]) = 0;
    v15 = 7;
    v14[4] = 0;
    sub_4094F0(v14, (int)&v18, Data, wcslen((const unsigned __int16 *)Data));
    v20 = 0;
    v6 = *(char **)a2;
    v7 = sub_40A200(*(char **)a2, *(_DWORD *)(*(_DWORD *)a2 + 4), (int)v14);
    v8 = *(_DWORD *)(a2 + 4);
    if ( v8 == 153391688 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a2 + 4) = v8 + 1;
    *((_DWORD *)v6 + 1) = v7;
    **((_DWORD **)v7 + 1) = v7;
    v20 = -1;
    if ( v15 >= 8 )
      operator delete(v14[0]);
  }
  return result;
}
// 4C2BB8: using guessed type wchar_t aSD_2[5];

//----- (00464420) --------------------------------------------------------
LSTATUS __usercall sub_464420@<eax>(
        _DWORD *a1@<edi>,
        HKEY hKey,
        LPCWSTR lpValueName,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  const WCHAR *p_lpValueName; // ecx
  LSTATUS v9; // esi
  DWORD v10; // eax
  DWORD Type; // [esp+8h] [ebp-418h] BYREF
  DWORD cbData; // [esp+Ch] [ebp-414h] BYREF
  BYTE Data[2]; // [esp+10h] [ebp-410h] BYREF
  _BYTE v15[1038]; // [esp+12h] [ebp-40Eh] BYREF

  *(_DWORD *)&v15[1034] = 0;
  p_lpValueName = lpValueName;
  if ( (unsigned int)a8 < 8 )
    p_lpValueName = (const WCHAR *)&lpValueName;
  cbData = 512;
  v9 = RegQueryValueExW(hKey, p_lpValueName, 0, &Type, Data, &cbData);
  v10 = cbData;
  if ( cbData && Type == 1 )
  {
    if ( *(_WORD *)&Data[2 * cbData - 2] )
    {
      if ( cbData >= 0x200 )
        v10 = 512;
      *(_WORD *)&Data[2 * v10] = 0;
    }
  }
  else
  {
    *(_WORD *)Data = 0;
  }
  if ( !v9 )
    sub_4094F0(a1, (int)v15, Data, wcslen((const unsigned __int16 *)Data));
  if ( (unsigned int)a8 >= 8 )
    operator delete((void *)lpValueName);
  return v9;
}

//----- (00464560) --------------------------------------------------------
BOOL __usercall sub_464560@<eax>(const WCHAR *a1@<eax>)
{
  return lstrcmpW(a1, L"yes") == 0;
}

//----- (004645D0) --------------------------------------------------------
int __usercall sub_4645D0@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  void (__stdcall *v3)(int, int, int *); // eax
  int result; // eax
  int v6; // [esp+0h] [ebp-8h] BYREF
  int v7; // [esp+4h] [ebp-4h] BYREF

  v3 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)a1 + 196);
  v7 = 0;
  v6 = 0;
  v3(a1, a3, &v7);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 84))(a2, v7, &v6);
  if ( v7 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  result = v6;
  v7 = 0;
  if ( v6 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
  return result;
}

//----- (00464660) --------------------------------------------------------
int __usercall sub_464660@<eax>(int a1@<eax>, int a2, OLECHAR *psz, OLECHAR *a4, OLECHAR *a5)
{
  OLECHAR *v6; // esi
  OLECHAR *v7; // esi
  BSTR v8; // eax
  OLECHAR *v9; // esi
  void (__stdcall *v10)(int, int, BSTR *); // edx
  VARIANTARG pvarg; // [esp+10h] [ebp-30h] BYREF
  VARIANTARG v13; // [esp+20h] [ebp-20h] BYREF
  BSTR bstrString; // [esp+30h] [ebp-10h] BYREF
  int v15; // [esp+34h] [ebp-Ch] BYREF
  int v16; // [esp+38h] [ebp-8h] BYREF
  int v17; // [esp+3Ch] [ebp-4h] BYREF

  v17 = 0;
  v16 = 0;
  v15 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  v6 = SysAllocString(psz);
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 188))(a1, v6, &v17);
  SysFreeString(v6);
  sub_4645D0(a1, v17, (int)bstrString);
  v7 = SysAllocString(L"name");
  VariantInit(&pvarg);
  v8 = SysAllocString(a4);
  pvarg.vt = 8;
  *(_QWORD *)&v13.vt = *(_QWORD *)&pvarg.vt;
  v13.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v8);
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 212))(a1, v7, &v16);
  (*(void (__stdcall **)(int, _DWORD, ULONG, LONG, LONG))(*(_DWORD *)v16 + 180))(
    v16,
    *(_DWORD *)&v13.vt,
    v13.decVal.Hi32,
    v13.lVal,
    v13.cyVal.Hi);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v17 + 192))(v17, v16, &v15);
  SysFreeString(v7);
  if ( v15 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
    v15 = 0;
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  v16 = 0;
  VariantClear(&v13);
  v9 = SysAllocString(a5);
  (*(void (__stdcall **)(int, OLECHAR *))(*(_DWORD *)v17 + 108))(v17, v9);
  SysFreeString(v9);
  SysFreeString(bstrString);
  v10 = *(void (__stdcall **)(int, int, BSTR *))(*(_DWORD *)a2 + 84);
  bstrString = 0;
  v10(a2, v17, &bstrString);
  if ( bstrString )
    (*(void (__stdcall **)(BSTR))(*(_DWORD *)bstrString + 8))(bstrString);
  return (*(int (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
}

//----- (004647D0) --------------------------------------------------------
LPVOID sub_4647D0()
{
  bool v0; // sf
  LPVOID result; // eax
  LPVOID ppv; // [esp+0h] [ebp-4h] BYREF

  ppv = 0;
  v0 = CoCreateInstance(&stru_4CC3F4, 0, 1u, &stru_4CC3E4, &ppv) < 0;
  result = ppv;
  if ( !v0 )
  {
    (*(void (__stdcall **)(LPVOID, _DWORD))(*(_DWORD *)ppv + 252))(ppv, 0);
    (*(void (__stdcall **)(LPVOID, _DWORD))(*(_DWORD *)ppv + 272))(ppv, 0);
    (*(void (__stdcall **)(LPVOID, _DWORD))(*(_DWORD *)ppv + 280))(ppv, 0);
    (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 288))(ppv, -1);
    return ppv;
  }
  return result;
}

//----- (00464840) --------------------------------------------------------
int __usercall sub_464840@<eax>(int a1@<eax>)
{
  unsigned __int8 v1; // bl
  int i; // esi
  int v4; // [esp+8h] [ebp-18h] BYREF
  wchar_t *String; // [esp+Ch] [ebp-14h] BYREF
  LPCWSTR lpString1; // [esp+10h] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-Ch] BYREF
  int v8; // [esp+18h] [ebp-8h] BYREF
  unsigned __int8 v9; // [esp+1Eh] [ebp-2h]
  unsigned __int8 v10; // [esp+1Fh] [ebp-1h]

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v1 = 0;
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)a1 + 68))(a1, &v8);
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)v8 + 44))(v8, &v4);
  for ( i = 1; i < v4; ++i )
  {
    (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v8 + 40))(v8, i, &v7);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v7 + 28))(v7, &lpString1);
    (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v7 + 104))(v7, &String);
    if ( lstrcmpW(lpString1, L"r") )
    {
      if ( lstrcmpW(lpString1, L"g") )
      {
        if ( !lstrcmpW(lpString1, L"b") )
          v1 = _wtoi(String);
      }
      else
      {
        v10 = _wtoi(String);
      }
    }
    else
    {
      v9 = _wtoi(String);
    }
  }
  return v9 | ((v10 | (v1 << 8)) << 8);
}
// 464840: using guessed type int var_8;

//----- (00464940) --------------------------------------------------------
int __usercall sub_464940@<eax>(int a1@<eax>, int a2, int a3, OLECHAR *psz, OLECHAR *a5)
{
  OLECHAR *v6; // ebx
  OLECHAR *v7; // ebx
  BSTR v8; // eax
  int *v9; // esi
  void (__stdcall *v10)(int, int, int *); // eax
  int result; // eax
  int v12; // [esp-8h] [ebp-40h]
  VARIANTARG pvarg; // [esp+10h] [ebp-28h] BYREF
  VARIANTARG v14; // [esp+20h] [ebp-18h] BYREF
  int v15; // [esp+30h] [ebp-8h] BYREF
  int v16; // [esp+34h] [ebp-4h] BYREF

  v16 = 0;
  v15 = 0;
  v6 = SysAllocString(psz);
  (*(void (__stdcall **)(int, OLECHAR *, int))(*(_DWORD *)a1 + 188))(a1, v6, a2);
  SysFreeString(v6);
  v7 = SysAllocString(L"name");
  VariantInit(&pvarg);
  v8 = SysAllocString(a5);
  pvarg.vt = 8;
  *(_QWORD *)&v14.vt = *(_QWORD *)&pvarg.vt;
  v14.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v8);
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 212))(a1, v7, &v16);
  (*(void (__stdcall **)(int, _DWORD, ULONG, LONG, LONG))(*(_DWORD *)v16 + 180))(
    v16,
    *(_DWORD *)&v14.vt,
    v14.decVal.Hi32,
    v14.lVal,
    v14.cyVal.Hi);
  v9 = (int *)a2;
  (*(void (__stdcall **)(_DWORD, int, int *))(**(_DWORD **)a2 + 192))(*(_DWORD *)a2, v16, &v15);
  SysFreeString(v7);
  if ( v15 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
    v15 = 0;
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  v16 = 0;
  VariantClear(&v14);
  v12 = *v9;
  v10 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)a3 + 84);
  a2 = 0;
  v10(a3, v12, &a2);
  result = a2;
  if ( a2 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
  return result;
}

//----- (00464A60) --------------------------------------------------------
HRESULT __usercall sub_464A60@<eax>(int a1@<eax>, int a2@<edi>, OLECHAR *psz, OLECHAR *a4)
{
  OLECHAR *v5; // esi
  BSTR v6; // eax
  VARIANTARG pvarg; // [esp+8h] [ebp-28h] BYREF
  VARIANTARG v9; // [esp+18h] [ebp-18h] BYREF
  int v10; // [esp+28h] [ebp-8h] BYREF
  int v11; // [esp+2Ch] [ebp-4h] BYREF

  v11 = 0;
  v10 = 0;
  v5 = SysAllocString(psz);
  VariantInit(&pvarg);
  v6 = SysAllocString(a4);
  pvarg.vt = 8;
  *(_QWORD *)&v9.vt = *(_QWORD *)&pvarg.vt;
  v9.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v6);
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 212))(a1, v5, &v11);
  (*(void (__stdcall **)(int, _DWORD, ULONG, LONG, LONG))(*(_DWORD *)v11 + 180))(
    v11,
    *(_DWORD *)&v9.vt,
    v9.decVal.Hi32,
    v9.lVal,
    v9.cyVal.Hi);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 192))(a2, v11, &v10);
  SysFreeString(v5);
  if ( v10 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
    v10 = 0;
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
  v11 = 0;
  return VariantClear(&v9);
}

//----- (00464B40) --------------------------------------------------------
HFONT __cdecl sub_464B40(int a1)
{
  void (__stdcall *v1)(int, int *); // eax
  int i; // ebx
  int v3; // edx
  WCHAR *lfFaceName; // eax
  int v5; // edi
  WCHAR v6; // cx
  int v8; // [esp+8h] [ebp-74h] BYREF
  int v9; // [esp+Ch] [ebp-70h] BYREF
  int v10; // [esp+10h] [ebp-6Ch] BYREF
  LPCWSTR lpString1; // [esp+14h] [ebp-68h] BYREF
  LPCWSTR v12; // [esp+18h] [ebp-64h] BYREF
  LOGFONTW lf; // [esp+1Ch] [ebp-60h] BYREF

  v1 = *(void (__stdcall **)(int, int *))(*(_DWORD *)a1 + 68);
  v9 = 0;
  v10 = 0;
  v1(a1, &v10);
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)v10 + 44))(v10, &v8);
  for ( i = 1; i < v8; ++i )
  {
    (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v10 + 40))(v10, i, &v9);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v9 + 28))(v9, &lpString1);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v9 + 104))(v9, &v12);
    if ( lstrcmpW(lpString1, L"Height") )
    {
      if ( lstrcmpW(lpString1, L"Width") )
      {
        if ( lstrcmpW(lpString1, L"Weight") )
        {
          if ( lstrcmpW(lpString1, L"Italic") )
          {
            if ( lstrcmpW(lpString1, L"Underline") )
            {
              if ( lstrcmpW(lpString1, L"Strikeout") )
              {
                if ( !lstrcmpW(lpString1, L"Font") )
                {
                  v3 = 32;
                  lfFaceName = lf.lfFaceName;
                  v5 = (char *)v12 - (char *)lf.lfFaceName;
                  while ( v3 != -2147483614 )
                  {
                    v6 = *(WCHAR *)((char *)lfFaceName + v5);
                    if ( !v6 )
                      break;
                    *lfFaceName++ = v6;
                    if ( !--v3 )
                    {
                      --lfFaceName;
                      break;
                    }
                  }
                  *lfFaceName = 0;
                }
              }
              else
              {
                lf.lfStrikeOut = lstrcmpW(v12, L"yes") == 0;
              }
            }
            else
            {
              lf.lfUnderline = lstrcmpW(v12, L"yes") == 0;
            }
          }
          else
          {
            lf.lfItalic = lstrcmpW(v12, L"yes") == 0;
          }
        }
        else
        {
          lf.lfWeight = _wtoi(v12);
        }
      }
      else
      {
        lf.lfWidth = _wtoi(v12);
      }
    }
    else
    {
      lf.lfHeight = _wtoi(v12);
    }
  }
  lf.lfWeight = 500;
  lf.lfCharSet = 1;
  lf.lfEscapement = 0;
  lf.lfOrientation = 0;
  *(_DWORD *)&lf.lfOutPrecision = 822214656;
  return CreateFontIndirectW(&lf);
}
// 464CD2: conditional instruction was optimized away because edx.4!=0

//----- (00464D20) --------------------------------------------------------
unsigned int *__usercall sub_464D20@<eax>(int a1@<eax>, unsigned int *a2@<ebx>)
{
  void (__stdcall *v2)(int, int *); // eax
  int i; // esi
  int v6; // [esp+4h] [ebp-18h] BYREF
  wchar_t *String; // [esp+8h] [ebp-14h] BYREF
  LPCWSTR v8; // [esp+Ch] [ebp-10h] BYREF
  int v9; // [esp+10h] [ebp-Ch] BYREF
  int v10; // [esp+14h] [ebp-8h] BYREF
  unsigned __int8 v11; // [esp+19h] [ebp-3h]
  unsigned __int8 v12; // [esp+1Ah] [ebp-2h]
  unsigned __int8 v13; // [esp+1Bh] [ebp-1h]

  v9 = 0;
  v10 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v2 = *(void (__stdcall **)(int, int *))(*(_DWORD *)a1 + 68);
  *a2 = -16777216;
  v2(a1, &v10);
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)v10 + 44))(v10, &v6);
  for ( i = 1; i < v6; ++i )
  {
    (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v10 + 40))(v10, i, &v9);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v9 + 28))(v9, &v8);
    (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v9 + 104))(v9, &String);
    if ( lstrcmpW(v8, L"r") )
    {
      if ( lstrcmpW(v8, L"g") )
      {
        if ( !lstrcmpW(v8, L"b") )
          v11 = _wtoi(String);
      }
      else
      {
        v12 = _wtoi(String);
      }
    }
    else
    {
      v13 = _wtoi(String);
    }
  }
  *a2 = v11 | ((v12 | ((v13 | 0xFFFFFF00) << 8)) << 8);
  return a2;
}
// 4C2EF0: using guessed type wchar_t aR_8[2];
// 4C2EF4: using guessed type wchar_t aG_7[2];
// 4C2EF8: using guessed type wchar_t aB_11[2];
// 464D20: using guessed type int var_8;

//----- (00464E30) --------------------------------------------------------
void __usercall sub_464E30(int a1@<edx>, int a2@<ecx>, int a3, _DWORD **a4)
{
  _DWORD *v4; // esi
  int v5; // edi
  OLECHAR *v6; // eax
  _DWORD *v8; // [esp+1Ch] [ebp-C0h]
  OLECHAR *v10[5]; // [esp+28h] [ebp-B4h] BYREF
  unsigned int v11; // [esp+3Ch] [ebp-A0h]
  OLECHAR psz[66]; // [esp+44h] [ebp-98h] BYREF
  int v13; // [esp+D8h] [ebp-4h]

  v4 = (_DWORD *)**a4;
  v5 = 0;
  v8 = *a4;
  if ( v4 != *a4 )
  {
    while ( 1 )
    {
      LOWORD(v10[0]) = 0;
      v11 = 7;
      v10[4] = 0;
      sub_4090E0((int)v10, v4 + 2, 0, 0xFFFFFFFF);
      v13 = 0;
      sub_401000(0x40u, psz, L"%s%d", a1, v5);
      v6 = v10[0];
      if ( v11 < 8 )
        v6 = (OLECHAR *)v10;
      sub_464A60(a3, a2, psz, v6);
      v13 = -1;
      if ( v11 >= 8 )
        operator delete(v10[0]);
      v4 = (_DWORD *)*v4;
      if ( v4 == v8 )
        break;
      ++v5;
    }
  }
}
// 4C2EC4: using guessed type wchar_t aSD_3[5];

//----- (00464FA0) --------------------------------------------------------
void __userpurge sub_464FA0(int a1@<ebx>, int a2@<edi>, int a3)
{
  int v3; // esi
  int v4; // [esp+4h] [ebp-Ch] BYREF
  LPCWSTR lpString1; // [esp+8h] [ebp-8h] BYREF
  wchar_t *String; // [esp+Ch] [ebp-4h] BYREF

  v3 = 1;
  v4 = 0;
  if ( a3 > 1 )
  {
    while ( 1 )
    {
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a1 + 40))(a1, v3, &v4);
      (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v4 + 28))(v4, &lpString1);
      (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v4 + 104))(v4, &String);
      if ( !*(_BYTE *)(a2 + 536) )
        break;
      if ( lstrcmpiW(lpString1, L"PosX") )
      {
        if ( lstrcmpiW(lpString1, L"PosY") )
        {
          if ( lstrcmpiW(lpString1, L"Width") )
          {
            if ( lstrcmpiW(lpString1, L"Height") )
              break;
            *(_DWORD *)(a2 + 20) = _wtoi(String);
          }
          else
          {
            *(_DWORD *)(a2 + 16) = _wtoi(String);
          }
        }
        else
        {
          *(_DWORD *)(a2 + 12) = _wtoi(String);
        }
      }
      else
      {
        *(_DWORD *)(a2 + 8) = _wtoi(String);
      }
LABEL_12:
      if ( ++v3 >= a3 )
      {
        *(_DWORD *)(a2 + 4) = 1;
        return;
      }
    }
    (*(void (__thiscall **)(int, LPCWSTR, wchar_t *))(*(_DWORD *)a2 + 16))(a2, lpString1, String);
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 4) = 1;
}

//----- (004650C0) --------------------------------------------------------
LSTATUS __usercall sub_4650C0@<eax>(HKEY a1@<edx>, int a2@<esi>)
{
  LSTATUS result; // eax
  HKEY v3; // [esp-4h] [ebp-10h]
  DWORD v4; // [esp+0h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF

  result = RegOpenKeyExW(a1, (LPCWSTR)(a2 + 24), 0, 0x20019u, &phkResult);
  if ( !result )
  {
    if ( *(_BYTE *)(a2 + 536) )
    {
      cbData = 8;
      RegQueryValueExW(phkResult, L"Position", 0, 0, (LPBYTE)(a2 + 8), &cbData);
      v4 = 4;
      RegQueryValueExW(phkResult, L"Width", 0, 0, (LPBYTE)(a2 + 16), &v4);
      v4 = 4;
      RegQueryValueExW(phkResult, L"Height", 0, 0, (LPBYTE)(a2 + 20), &v4);
    }
    (*(void (__thiscall **)(int, HKEY))(*(_DWORD *)a2 + 8))(a2, phkResult);
    v3 = phkResult;
    *(_DWORD *)(a2 + 4) = 1;
    return RegCloseKey(v3);
  }
  return result;
}

//----- (00465170) --------------------------------------------------------
void __userpurge sub_465170(int a1@<esi>, HKEY hKey)
{
  DWORD dwDisposition; // [esp+0h] [ebp-8h] BYREF
  BYTE Data[4]; // [esp+4h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 4) && !RegCreateKeyExW(hKey, (LPCWSTR)(a1 + 24), 0, 0, 0, 0x20006u, 0, &hKey, &dwDisposition) )
  {
    if ( *(_BYTE *)(a1 + 536) )
    {
      RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)(a1 + 8), 8u);
      *(_DWORD *)Data = *(_DWORD *)(a1 + 16);
      RegSetValueExW(hKey, L"Width", 0, 4u, Data, 4u);
      *(_DWORD *)Data = *(_DWORD *)(a1 + 20);
      RegSetValueExW(hKey, L"Height", 0, 4u, Data, 4u);
    }
    (*(void (__thiscall **)(int, HKEY))(*(_DWORD *)a1 + 4))(a1, hKey);
    RegCloseKey(hKey);
  }
}

//----- (00465280) --------------------------------------------------------
int __userpurge sub_465280@<eax>(int result@<eax>, int a2@<ebx>, int a3)
{
  int v3; // esi
  BSTR v4; // eax
  int v5; // edi
  int v6; // [esp+8h] [ebp-4h] BYREF

  v3 = result;
  if ( *(_DWORD *)(a2 + 4) )
  {
    v6 = 0;
    v4 = SysAllocString(L"\n\t\t");
    v5 = a3;
    sub_4645D0(a3, v3, (int)v4);
    sub_464940(a3, (int)&v6, v3, (OLECHAR *)L"DialogState", (OLECHAR *)(a2 + 24));
    if ( *(_BYTE *)(a2 + 536) )
    {
      _itow_s(*(_DWORD *)(a2 + 8), Buffer, 0x40u, 10);
      sub_464A60(a3, v6, (OLECHAR *)L"PosX", Buffer);
      _itow_s(*(_DWORD *)(a2 + 12), Buffer, 0x40u, 10);
      sub_464A60(a3, v6, (OLECHAR *)L"PosY", Buffer);
      _itow_s(*(_DWORD *)(a2 + 16), Buffer, 0x40u, 10);
      sub_464A60(a3, v6, (OLECHAR *)L"Width", Buffer);
      _itow_s(*(_DWORD *)(a2 + 20), Buffer, 0x40u, 10);
      sub_464A60(a3, v6, (OLECHAR *)L"Height", Buffer);
      v5 = a3;
    }
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 12))(a2, v5, v6);
  }
  return result;
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (004653E0) --------------------------------------------------------
int __usercall sub_4653E0@<eax>(int result@<eax>, int a2@<edx>)
{
  _WORD *v2; // ecx
  int v3; // esi
  int v4; // edi
  __int16 v5; // dx

  v2 = (_WORD *)(result + 24);
  *(_DWORD *)result = &CDialogSettings::`vftable';
  v3 = 256;
  v4 = a2 - (result + 24);
  while ( v3 != -2147483390 )
  {
    v5 = *(_WORD *)((char *)v2 + v4);
    if ( !v5 )
      break;
    *v2++ = v5;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  *(_BYTE *)(result + 536) = 1;
  *(_DWORD *)(result + 4) = 0;
  return result;
}
// 465414: conditional instruction was optimized away because esi.4!=0
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (004654C0) --------------------------------------------------------
HWND __cdecl sub_4654C0(HWND hWndParent)
{
  DWORD v1; // esi
  HMODULE ModuleHandleW; // eax
  HWND Window; // esi
  HFONT FontW; // eax

  v1 = dwStyle;
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"SysTabControl32", &WindowName, v1, 0, 0, 0, 0, hWndParent, 0, ModuleHandleW, 0);
  FontW = CreateFontW(15, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 2u, 0, 0);
  SendMessageW(Window, 0x30u, (WPARAM)FontW, 1);
  return Window;
}

//----- (00465600) --------------------------------------------------------
HWND __cdecl sub_465600(HWND hWndParent)
{
  HMODULE ModuleHandleW; // eax
  HWND Window; // esi
  HIMAGELIST phimlSmall; // [esp+4h] [ebp-4h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"SysTreeView32", &word_4C3074, 0x5000022Bu, 0, 0, 0, 0, hWndParent, 0, ModuleHandleW, 0);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(Window, 0x1109u, 0, (LPARAM)phimlSmall);
  return Window;
}

//----- (004656B0) --------------------------------------------------------
HANDLE __usercall sub_4656B0@<eax>(HWND a1@<edi>, WCHAR *a2@<esi>)
{
  WCHAR *v2; // eax
  int v3; // ebx
  WCHAR v4; // cx
  HANDLE result; // eax
  HANDLE v6; // ebx
  LPARAM lParam[9]; // [esp+4h] [ebp-744h] BYREF
  HIMAGELIST phimlSmall; // [esp+28h] [ebp-720h] BYREF
  HANDLE hFindFile; // [esp+2Ch] [ebp-71Ch]
  SHFILEINFOW psfi; // [esp+30h] [ebp-718h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+2E8h] [ebp-460h] BYREF
  WCHAR pszPath[262]; // [esp+538h] [ebp-210h] BYREF

  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(a1, 0x402u, 0, (LPARAM)phimlSmall);
  SendMessageW(a1, 0x14Bu, 0, 0);
  v2 = pszPath;
  v3 = 260;
  while ( v3 != -2147483386 )
  {
    v4 = *(WCHAR *)((char *)v2 + (char *)a2 - (char *)pszPath);
    if ( !v4 )
      break;
    *v2++ = v4;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  PathAppendW(pszPath, L"*");
  result = FindFirstFileW(pszPath, &FindFileData);
  v6 = result;
  hFindFile = result;
  if ( result != (HANDLE)-1 )
  {
    if ( FindNextFileW(result, &FindFileData) )
    {
      do
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          if ( StrCmpW(FindFileData.cFileName, L"..") )
          {
            PathAppendW(a2, FindFileData.cFileName);
            SHGetFileInfoW(a2, 0, &psfi, 0, 0x4000u);
            PathRemoveFileSpecW(a2);
            lParam[4] = psfi.iIcon;
            lParam[5] = psfi.iIcon;
            lParam[0] = 23;
            lParam[1] = -1;
            lParam[7] = 1;
            lParam[6] = 1;
            lParam[2] = (LPARAM)FindFileData.cFileName;
            lParam[3] = lstrlenW(FindFileData.cFileName);
            SendMessageW(a1, 0x40Bu, 0, (LPARAM)lParam);
          }
        }
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      v6 = hFindFile;
    }
    return (HANDLE)FindClose(v6);
  }
  return result;
}
// 465730: conditional instruction was optimized away because ebx.4!=0

//----- (00465880) --------------------------------------------------------
void __stdcall sub_465880(void *Block)
{
  _DWORD *i; // esi
  int v2; // eax
  int v3; // eax
  int v4; // eax

  if ( !*((_DWORD *)Block + 385) )
  {
    for ( i = (_DWORD *)*((_DWORD *)Block + 519); i[518]; i = (_DWORD *)i[518] )
      sub_465880(i);
  }
  v2 = *((_DWORD *)Block + 517);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 2072) = *((_DWORD *)Block + 518);
    v4 = *((_DWORD *)Block + 518);
    if ( v4 )
      *(_DWORD *)(v4 + 2068) = *((_DWORD *)Block + 517);
  }
  else
  {
    *(_DWORD *)(*((_DWORD *)Block + 516) + 2076) = *((_DWORD *)Block + 518);
    v3 = *((_DWORD *)Block + 518);
    if ( v3 )
    {
      *(_DWORD *)(v3 + 2068) = 0;
      free(Block);
      return;
    }
  }
  free(Block);
}

//----- (00465940) --------------------------------------------------------
int __fastcall sub_465940(int a1, int a2, int a3)
{
  char *v3; // ecx
  char *v4; // eax
  int v5; // edi
  __int16 v6; // dx
  char *v7; // eax
  int v8; // esi
  __int16 v9; // dx
  char *v10; // eax
  int v11; // esi
  __int16 v12; // dx
  int v13; // esi
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // edi
  _WORD *v18; // eax
  int v19; // esi
  __int16 v20; // dx
  char *v21; // edi
  int v22; // esi
  _WORD *v23; // eax
  int v24; // edi
  __int16 v25; // dx
  char *v26; // ebx
  _WORD *v27; // eax
  int v28; // esi
  __int16 v29; // dx
  _DWORD *v30; // edi
  int v31; // edx
  _WORD *v32; // eax
  __int16 v33; // cx
  _WORD *v34; // eax
  int v35; // edx
  __int16 v36; // cx
  int v37; // edx
  _WORD *v38; // eax
  __int16 v39; // cx
  int v40; // ecx
  int v41; // edx
  int result; // eax
  _DWORD *v43; // [esp+Ch] [ebp-82Ch]
  char v44[512]; // [esp+10h] [ebp-828h] BYREF
  char v45[1024]; // [esp+210h] [ebp-628h] BYREF
  int v46; // [esp+610h] [ebp-228h]
  int v47; // [esp+614h] [ebp-224h]
  char v48[520]; // [esp+618h] [ebp-220h] BYREF
  int v49; // [esp+820h] [ebp-18h]
  int v50; // [esp+82Ch] [ebp-Ch]

  v3 = *(char **)(a3 + 2064);
  v43 = *(_DWORD **)(a2 + 2064);
  v4 = v44;
  v5 = 256;
  while ( v5 != -2147483390 )
  {
    v6 = *(_WORD *)&v4[v3 - v44];
    if ( !v6 )
      break;
    *(_WORD *)v4 = v6;
    v4 += 2;
    if ( !--v5 )
    {
      v4 -= 2;
      break;
    }
  }
  *(_WORD *)v4 = 0;
  v7 = v45;
  v8 = 512;
  while ( v8 != -2147483134 )
  {
    v9 = *(_WORD *)&v7[v3 + 512 - v45];
    if ( !v9 )
      break;
    *(_WORD *)v7 = v9;
    v7 += 2;
    if ( !--v8 )
    {
      v7 -= 2;
      break;
    }
  }
  *(_WORD *)v7 = 0;
  v10 = v48;
  v11 = 260;
  while ( v11 != -2147483386 )
  {
    v12 = *(_WORD *)&v10[v3 + 1544 - v48];
    if ( !v12 )
      break;
    *(_WORD *)v10 = v12;
    v10 += 2;
    if ( !--v11 )
    {
      v10 -= 2;
      break;
    }
  }
  v13 = (int)v43;
  *(_WORD *)v10 = 0;
  v14 = *((_DWORD *)v3 + 385);
  v46 = *((_DWORD *)v3 + 384);
  v15 = *((_DWORD *)v3 + 516);
  v47 = v14;
  v16 = *((_DWORD *)v3 + 519);
  v49 = v15;
  v50 = v16;
  v17 = 256;
  v18 = v3;
  v19 = v13 - (_DWORD)v3;
  while ( v17 != -2147483390 )
  {
    v20 = *(_WORD *)((char *)v18 + v19);
    if ( !v20 )
      break;
    *v18++ = v20;
    if ( !--v17 )
    {
      --v18;
      break;
    }
  }
  v21 = (char *)(v43 + 128);
  *v18 = 0;
  v22 = 512;
  v23 = v3 + 512;
  v24 = v21 - (v3 + 512);
  while ( v22 != -2147483134 )
  {
    v25 = *(_WORD *)((char *)v23 + v24);
    if ( !v25 )
      break;
    *v23++ = v25;
    if ( !--v22 )
    {
      --v23;
      break;
    }
  }
  v26 = (char *)(v43 + 386);
  *v23 = 0;
  v27 = v3 + 1544;
  v28 = 260;
  while ( v28 != -2147483386 )
  {
    v29 = *(_WORD *)((char *)v27 + v26 - (v3 + 1544));
    if ( !v29 )
      break;
    *v27++ = v29;
    if ( !--v28 )
    {
      --v27;
      break;
    }
  }
  v30 = v43;
  *v27 = 0;
  *((_DWORD *)v3 + 384) = v30[384];
  *((_DWORD *)v3 + 385) = v30[385];
  *((_DWORD *)v3 + 516) = v30[516];
  *((_DWORD *)v3 + 519) = v30[519];
  v31 = 256;
  v32 = v30;
  while ( v31 != -2147483390 )
  {
    v33 = *(_WORD *)((char *)v32 + v44 - (char *)v30);
    if ( !v33 )
      break;
    *v32++ = v33;
    if ( !--v31 )
    {
      --v32;
      break;
    }
  }
  *v32 = 0;
  v34 = v30 + 128;
  v35 = 512;
  while ( v35 != -2147483134 )
  {
    v36 = *(_WORD *)((char *)v34 + v45 - (char *)(v30 + 128));
    if ( !v36 )
      break;
    *v34++ = v36;
    if ( !--v35 )
    {
      --v34;
      break;
    }
  }
  *v34 = 0;
  v37 = 260;
  v38 = v26;
  while ( v37 != -2147483386 )
  {
    v39 = *(_WORD *)((char *)v38 + v48 - v26);
    if ( !v39 )
      break;
    *v38++ = v39;
    if ( !--v37 )
    {
      --v38;
      break;
    }
  }
  v40 = v47;
  *v38 = 0;
  v41 = v49;
  v30[384] = v46;
  result = v50;
  v30[385] = v40;
  v30[516] = v41;
  v30[519] = result;
  return result;
}
// 4659A0: conditional instruction was optimized away because edi.4!=0
// 4659E2: conditional instruction was optimized away because esi.4!=0
// 465A22: conditional instruction was optimized away because esi.4!=0
// 465A90: conditional instruction was optimized away because edi.4!=0
// 465ACD: conditional instruction was optimized away because esi.4!=0
// 465B10: conditional instruction was optimized away because esi.4!=0
// 465B80: conditional instruction was optimized away because edx.4!=0
// 465BC0: conditional instruction was optimized away because edx.4!=0
// 465BFA: conditional instruction was optimized away because edx.4!=0

//----- (00465C50) --------------------------------------------------------
int __usercall sub_465C50@<eax>(_DWORD *a1@<ebx>, int a2@<edi>)
{
  int v2; // edx
  _WORD *v3; // eax
  __int16 v4; // cx
  _WORD *v5; // eax
  int v6; // edx
  __int16 v7; // cx
  bool v8; // zf
  _WORD *v9; // eax
  int v10; // edx
  __int16 v11; // cx
  int result; // eax

  v2 = 256;
  v3 = (_WORD *)a2;
  while ( v2 != -2147483390 )
  {
    v4 = *(_WORD *)((char *)v3 + (_DWORD)a1 - a2);
    if ( !v4 )
      break;
    *v3++ = v4;
    if ( !--v2 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  v5 = (_WORD *)(a2 + 512);
  v6 = 512;
  while ( v6 != -2147483134 )
  {
    v7 = *(_WORD *)((char *)v5 + (_DWORD)a1 - a2);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  v8 = *(_DWORD *)(a2 + 1540) == 1;
  *(_DWORD *)(a2 + 1536) = a1[384];
  if ( v8 )
  {
    v9 = (_WORD *)(a2 + 1544);
    v10 = 260;
    while ( v10 != -2147483386 )
    {
      v11 = *(_WORD *)((char *)v9 + (_DWORD)a1 - a2);
      if ( !v11 )
        break;
      *v9++ = v11;
      if ( !--v10 )
      {
        --v9;
        break;
      }
    }
    *v9 = 0;
  }
  result = *(_DWORD *)(a2 + 1540);
  a1[385] = result;
  a1[516] = a2;
  return result;
}
// 465C80: conditional instruction was optimized away because edx.4!=0
// 465CC0: conditional instruction was optimized away because edx.4!=0
// 465D12: conditional instruction was optimized away because edx.4!=0

//----- (00465D30) --------------------------------------------------------
_WORD *__usercall sub_465D30@<eax>(int a1@<ebx>, _DWORD *a2@<edi>)
{
  int v2; // edx
  _DWORD *v3; // eax
  __int16 v4; // cx
  _WORD *v5; // eax
  int v6; // edx
  __int16 v7; // cx
  _WORD *result; // eax
  int v9; // edx
  __int16 v10; // cx

  v2 = 256;
  v3 = a2;
  while ( v2 != -2147483390 )
  {
    v4 = *(_WORD *)((char *)v3 + a1 - (_DWORD)a2);
    if ( !v4 )
      break;
    *(_WORD *)v3 = v4;
    v3 = (_DWORD *)((char *)v3 + 2);
    if ( !--v2 )
    {
      v3 = (_DWORD *)((char *)v3 - 2);
      break;
    }
  }
  *(_WORD *)v3 = 0;
  v5 = a2 + 128;
  v6 = 512;
  while ( v6 != -2147483134 )
  {
    v7 = *(_WORD *)((char *)v5 + a1 - (_DWORD)a2);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  result = *(_WORD **)(a1 + 1540);
  a2[385] = result;
  a2[384] = *(_DWORD *)(a1 + 1536);
  if ( *(_DWORD *)(a1 + 1540) == 1 )
  {
    result = a2 + 386;
    v9 = 260;
    while ( v9 != -2147483386 )
    {
      v10 = *(_WORD *)((char *)result + a1 - (_DWORD)a2);
      if ( !v10 )
        break;
      *result++ = v10;
      if ( !--v9 )
      {
        *--result = 0;
        a2[516] = a1;
        return result;
      }
    }
    *result = 0;
  }
  a2[516] = a1;
  return result;
}
// 465D60: conditional instruction was optimized away because edx.4!=0
// 465DA0: conditional instruction was optimized away because edx.4!=0
// 465E0C: conditional instruction was optimized away because edx.4!=0

//----- (00465E20) --------------------------------------------------------
_WORD *__usercall sub_465E20@<eax>(char *a1@<ebx>, _DWORD *a2@<edi>)
{
  int v2; // edx
  _DWORD *v3; // eax
  __int16 v4; // cx
  _WORD *v5; // eax
  int v6; // edx
  __int16 v7; // cx
  _WORD *result; // eax
  int v9; // edx
  __int16 v10; // cx

  v2 = 256;
  v3 = a2;
  while ( v2 != -2147483390 )
  {
    v4 = *(_WORD *)((char *)v3 + a1 - (char *)a2);
    if ( !v4 )
      break;
    *(_WORD *)v3 = v4;
    v3 = (_DWORD *)((char *)v3 + 2);
    if ( !--v2 )
    {
      v3 = (_DWORD *)((char *)v3 - 2);
      break;
    }
  }
  *(_WORD *)v3 = 0;
  v5 = a2 + 128;
  v6 = 512;
  while ( v6 != -2147483134 )
  {
    v7 = *(_WORD *)((char *)v5 + a1 - (char *)a2);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  a2[385] = *((_DWORD *)a1 + 385);
  result = 0;
  a2[384] = *((_DWORD *)a1 + 384);
  a2[519] = 0;
  a2[518] = 0;
  if ( *((_DWORD *)a1 + 385) == 1 )
  {
    result = a2 + 386;
    v9 = 260;
    while ( v9 != -2147483386 )
    {
      v10 = *(_WORD *)((char *)result + a1 - (char *)a2);
      if ( !v10 )
        break;
      *result++ = v10;
      if ( !--v9 )
      {
        *--result = 0;
        *((_DWORD *)a1 + 516) = a2;
        return result;
      }
    }
    *result = 0;
  }
  *((_DWORD *)a1 + 516) = a2;
  return result;
}
// 465E50: conditional instruction was optimized away because edx.4!=0
// 465E90: conditional instruction was optimized away because edx.4!=0
// 465F0C: conditional instruction was optimized away because edx.4!=0

//----- (00465F90) --------------------------------------------------------
int __thiscall sub_465F90(_DWORD *this, _DWORD *a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // ebx

  v2 = this[516];
  result = -2147467259;
  if ( !*(_DWORD *)(v2 + 1540) )
  {
    v4 = *(_DWORD *)(v2 + 2076);
    if ( v4 )
    {
      while ( *(_DWORD *)(v4 + 1540) )
      {
        v4 = *(_DWORD *)(v4 + 2072);
        if ( !v4 )
          return result;
      }
      sub_465D30(v4, a2);
      return 0;
    }
  }
  return result;
}

//----- (00466000) --------------------------------------------------------
int __usercall sub_466000@<eax>(int a1@<ebx>, _DWORD *a2@<edi>)
{
  int v2; // edx
  _DWORD *v3; // eax
  __int16 v4; // cx
  _WORD *v5; // eax
  int v6; // edx
  __int16 v7; // cx
  int result; // eax

  v2 = 256;
  v3 = a2;
  while ( v2 != -2147483390 )
  {
    v4 = *(_WORD *)((char *)v3 + a1 - (_DWORD)a2);
    if ( !v4 )
      break;
    *(_WORD *)v3 = v4;
    v3 = (_DWORD *)((char *)v3 + 2);
    if ( !--v2 )
    {
      v3 = (_DWORD *)((char *)v3 - 2);
      break;
    }
  }
  *(_WORD *)v3 = 0;
  v5 = a2 + 128;
  v6 = 512;
  while ( v6 != -2147483134 )
  {
    v7 = *(_WORD *)((char *)v5 + a1 - (_DWORD)a2);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  result = *(_DWORD *)(a1 + 1540);
  a2[385] = result;
  a2[384] = *(_DWORD *)(a1 + 1536);
  a2[516] = a1;
  return result;
}
// 466030: conditional instruction was optimized away because edx.4!=0
// 466070: conditional instruction was optimized away because edx.4!=0

//----- (004660A0) --------------------------------------------------------
_DWORD *__usercall sub_4660A0@<eax>(_DWORD *result@<eax>)
{
  int v1; // esi
  _DWORD *v2; // ecx
  __int16 v3; // dx

  v1 = 256;
  v2 = result;
  while ( v1 != -2147483390 )
  {
    v3 = *(_WORD *)((char *)v2 + (char *)L"Bookmarks" - (char *)result);
    if ( !v3 )
      break;
    *(_WORD *)v2 = v3;
    v2 = (_DWORD *)((char *)v2 + 2);
    if ( !--v1 )
    {
      v2 = (_DWORD *)((char *)v2 - 2);
      break;
    }
  }
  *(_WORD *)v2 = 0;
  result[385] = 0;
  result[518] = 0;
  result[519] = 0;
  return result;
}
// 4660D0: conditional instruction was optimized away because esi.4!=0
// 4C3134: using guessed type wchar_t aBookmarks_1[10];

//----- (004660F0) --------------------------------------------------------
int __usercall sub_4660F0@<eax>(char *a1@<ebx>, int a2@<esi>)
{
  _DWORD *v2; // edi
  int result; // eax

  v2 = malloc(0x820u);
  sub_465E20(a1, v2);
  v2[516] = a2;
  result = *(_DWORD *)(a2 + 2076);
  if ( result )
  {
    for ( ; *(_DWORD *)(result + 2072); result = *(_DWORD *)(result + 2072) )
      ;
    *(_DWORD *)(result + 2072) = v2;
    v2[517] = result;
  }
  else
  {
    *(_DWORD *)(a2 + 2076) = v2;
    v2[517] = 0;
  }
  return result;
}

//----- (00466190) --------------------------------------------------------
int __usercall sub_466190@<eax>(const ITEMIDLIST *a1@<edi>, const ITEMIDLIST *a2@<esi>)
{
  int v2; // ebx
  IShellFolder *ppshf; // [esp+4h] [ebp-4h] BYREF

  v2 = 0;
  if ( !a1 || !a2 )
    return 0;
  ppshf = 0;
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    if ( !(unsigned __int16)ppshf->lpVtbl->CompareIDs(ppshf, 0, a1, a2) )
      v2 = 1;
    ppshf->lpVtbl->Release(ppshf);
  }
  return v2;
}

//----- (00466220) --------------------------------------------------------
int __usercall sub_466220@<eax>(char a1@<al>, char a2, int a3)
{
  if ( ((a1 & 8) != 0 && (a1 & 4) != 0 || (a1 & 0x20) != 0) && (a2 & 4) != 0 )
    return 4;
  if ( (a1 & 4) != 0 && (a2 & 2) != 0 )
    return 2;
  if ( (a1 & 8) == 8 && (a2 & 1) != 0 )
    return 1;
  if ( a3 && (a2 & 2) != 0 )
    return 2;
  if ( (a2 & 1) != 0 )
    return 1;
  if ( (a2 & 2) != 0 )
    return 2;
  else
    return a2 & 4;
}

//----- (00466280) --------------------------------------------------------
BOOL __cdecl sub_466280(LPCWSTR lpSrc, LPWSTR lpDest)
{
  BOOL v2; // esi
  DWORD CurrentProcessId; // eax
  HANDLE v4; // edi
  HANDLE TokenHandle; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  CurrentProcessId = GetCurrentProcessId();
  v4 = OpenProcess(0x400u, 0, CurrentProcessId);
  if ( v4 )
  {
    v2 = OpenProcessToken(v4, 0xCu, &TokenHandle);
    if ( v2 )
    {
      v2 = ExpandEnvironmentStringsForUserW(TokenHandle, lpSrc, lpDest, 0x104u);
      CloseHandle(TokenHandle);
    }
    CloseHandle(v4);
  }
  return v2;
}

//----- (004663F0) --------------------------------------------------------
int __usercall sub_4663F0@<eax>(const ITEMIDLIST *a1@<edi>)
{
  int v1; // esi
  LPITEMIDLIST ppidl; // [esp+4h] [ebp-4h] BYREF

  v1 = 0;
  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
  {
    v1 = sub_466190(a1, ppidl);
    CoTaskMemFree(ppidl);
  }
  return v1;
}

//----- (00466430) --------------------------------------------------------
int __usercall sub_466430@<eax>(ITEMIDLIST *a1@<eax>, LPITEMIDLIST *a2@<ebx>)
{
  int v3; // esi
  LPITEMIDLIST ppidl; // [esp+4h] [ebp-4h] BYREF

  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 && (v3 = sub_466190(a1, ppidl), CoTaskMemFree(ppidl), v3) )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    ILRemoveLastID(a1);
    *a2 = ILClone(a1);
    return 0;
  }
}

//----- (004664A0) --------------------------------------------------------
HRESULT __cdecl sub_4664A0(int csidl, LPWSTR pszBuf)
{
  HRESULT result; // eax
  LPITEMIDLIST ppidl; // [esp+14h] [ebp-118h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+18h] [ebp-114h] BYREF
  void *ppv; // [esp+1Ch] [ebp-110h] BYREF
  IShellFolder *ppshf; // [esp+20h] [ebp-10Ch] BYREF
  STRRET pstr; // [esp+24h] [ebp-108h] BYREF

  ppv = 0;
  ppshf = 0;
  ppidl = 0;
  ppidlLast = 0;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    if ( SHGetFolderLocation(0, csidl, 0, 0, &ppidl) >= 0 )
    {
      if ( SHBindToParent(ppidl, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(
               ppv,
               ppidlLast,
               0x8000,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
        (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
      }
      CoTaskMemFree(ppidl);
    }
    return ppshf->lpVtbl->Release(ppshf);
  }
  return result;
}

//----- (00466570) --------------------------------------------------------
BOOL __usercall sub_466570@<eax>(
        const WCHAR *a1@<eax>,
        HWND a2@<edx>,
        void *a3@<ecx>,
        const WCHAR *a4,
        const WCHAR *a5)
{
  SHELLEXECUTEINFOW pExecInfo; // [esp+0h] [ebp-3Ch] BYREF

  pExecInfo.lpVerb = a1;
  pExecInfo.hwnd = a2;
  pExecInfo.lpIDList = a3;
  pExecInfo.lpParameters = a4;
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 12;
  pExecInfo.nShow = 5;
  pExecInfo.lpDirectory = a5;
  pExecInfo.lpFile = 0;
  pExecInfo.hInstApp = 0;
  return ShellExecuteExW(&pExecInfo);
}

//----- (004665C0) --------------------------------------------------------
HRESULT __usercall sub_4665C0@<eax>(const ITEMIDLIST *a1@<eax>, int a2@<edi>)
{
  HRESULT v2; // esi
  LPCITEMIDLIST ppidlLast; // [esp+0h] [ebp-8h] BYREF
  void *ppv; // [esp+4h] [ebp-4h] BYREF

  if ( !a1 || !a2 )
    return -2147467259;
  ppv = 0;
  ppidlLast = 0;
  v2 = SHBindToParent(a1, &stru_4BD7FC, &ppv, &ppidlLast);
  if ( v2 >= 0 )
  {
    v2 = (*(int (__stdcall **)(void *, int, LPCITEMIDLIST *, int))(*(_DWORD *)ppv + 36))(ppv, 1, &ppidlLast, a2);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  }
  return v2;
}

//----- (00466630) --------------------------------------------------------
HRESULT __usercall sub_466630@<eax>(const ITEMIDLIST *a1@<edi>, WCHAR *pszBuf, int a3)
{
  HRESULT v3; // esi
  void *ppv; // [esp+10h] [ebp-110h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+14h] [ebp-10Ch] BYREF
  STRRET pstr; // [esp+18h] [ebp-108h] BYREF

  if ( !a1 || !pszBuf )
    return -2147467259;
  ppv = 0;
  ppidlLast = 0;
  v3 = SHBindToParent(a1, &stru_4BD7FC, &ppv, &ppidlLast);
  if ( v3 >= 0 )
  {
    v3 = (*(int (__stdcall **)(void *, LPCITEMIDLIST, int, STRRET *))(*(_DWORD *)ppv + 44))(ppv, ppidlLast, a3, &pstr);
    if ( v3 >= 0 )
      StrRetToBufW(&pstr, a1, pszBuf, 0x104u);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
  }
  return v3;
}

//----- (004666D0) --------------------------------------------------------
HRESULT __usercall sub_4666D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4@<edi>, const WCHAR *a5, int a6)
{
  HRESULT v6; // esi
  int v8[2]; // [esp+8h] [ebp-40h] BYREF
  LPWSTR ppwsz[3]; // [esp+10h] [ebp-38h] BYREF
  LPCWSTR psz; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h] BYREF
  LPVOID ppv; // [esp+2Ch] [ebp-1Ch] BYREF
  CLSID pclsid; // [esp+30h] [ebp-18h] BYREF
  int v16; // [esp+40h] [ebp-8h]

  psz = a5;
  v11 = a2;
  v12 = a1;
  if ( !a4 || !a5 || !a3 || !a2 || !a1 )
    return -2147467259;
  ppv = 0;
  v6 = CoCreateInstance(&stru_4BD8EC, 0, 1u, &stru_4BD82C, &ppv);
  if ( v6 >= 0 )
  {
    (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 80))(ppv, a3);
    (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 44))(ppv, v11);
    (*(void (__stdcall **)(LPVOID, int, int))(*(_DWORD *)ppv + 68))(ppv, v12, a6);
    v13 = 0;
    v6 = (**(int (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_4BD99C, &v13);
    if ( v6 >= 0 )
    {
      LOWORD(v8[0]) = 31;
      if ( SHStrDupW(psz, ppwsz) < 0 )
      {
        v8[0] = 0;
        v8[1] = 0;
        ppwsz[0] = 0;
        ppwsz[1] = 0;
      }
      CLSIDFromString(L"{F29F85E0-4FF9-1068-AB91-08002B27B3D9}", &pclsid);
      v16 = 2;
      (*(void (__stdcall **)(int, CLSID *, int *))(*(_DWORD *)v13 + 24))(v13, &pclsid, v8);
      (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 28))(v13);
      (*(void (__stdcall **)(int, LPVOID))(*(_DWORD *)a4 + 20))(a4, ppv);
      (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
    }
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  }
  return v6;
}

//----- (00466830) --------------------------------------------------------
HRESULT __usercall sub_466830@<eax>(const ITEMIDLIST *a1@<eax>, IShellFolder **a2@<esi>)
{
  HRESULT result; // eax
  IShellFolder *ppshf; // [esp+4h] [ebp-4h] BYREF

  if ( !a1 || !a2 )
    return -2147467259;
  ppshf = 0;
  *a2 = 0;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    if ( sub_4663F0(a1) )
      return SHGetDesktopFolder(a2);
    else
      return ppshf->lpVtbl->BindToObject(ppshf, a1, 0, &stru_4BD7FC, (void **)a2);
  }
  return result;
}

//----- (00466900) --------------------------------------------------------
int __usercall sub_466900@<eax>(const WCHAR *a1@<esi>, WCHAR *a2)
{
  LPITEMIDLIST ppidl; // [esp+Ch] [ebp-218h] BYREF
  WCHAR String1[262]; // [esp+10h] [ebp-214h] BYREF

  ppidl = 0;
  SHGetFolderLocation(0, 3, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(3, a2);
    return 0;
  }
  SHGetFolderLocation(0, 10, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(10, a2);
    return 0;
  }
  SHGetFolderLocation(0, 17, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(17, a2);
    return 0;
  }
  SHGetFolderLocation(0, 18, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(18, a2);
    return 0;
  }
  SHGetFolderLocation(0, 49, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(49, a2);
    return 0;
  }
  SHGetFolderLocation(0, 4, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(4, a2);
    return 0;
  }
  SHGetFolderLocation(0, 6, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
    sub_4664A0(6, a2);
    return 0;
  }
  SHGetFolderLocation(0, 39, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
    goto LABEL_16;
  SHGetFolderLocation(0, 13, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
  {
LABEL_18:
    sub_4664A0(13, a2);
    return 0;
  }
  SHGetFolderLocation(0, 14, 0, 0, &ppidl);
  sub_466630(ppidl, String1, 1);
  CoTaskMemFree(ppidl);
  if ( !lstrcmpiW(String1, a1) )
    goto LABEL_20;
  if ( CompareStringW(0x7Fu, 1u, L"Desktop", -1, a1, -1) == 2 )
  {
    sub_4664A0(0, a2);
    return 0;
  }
  else
  {
    if ( CompareStringW(0x7Fu, 1u, L"Pictures", -1, a1, -1) == 2 )
    {
LABEL_16:
      sub_4664A0(39, a2);
      return 0;
    }
    if ( CompareStringW(0x7Fu, 1u, L"Music", -1, a1, -1) == 2 )
      goto LABEL_18;
    if ( CompareStringW(0x7Fu, 1u, L"Videos", -1, a1, -1) == 2 )
    {
LABEL_20:
      sub_4664A0(14, a2);
      return 0;
    }
    if ( CompareStringW(0x7Fu, 1u, L"Documents", -1, a1, -1) == 2 )
    {
      sub_4664A0(5, a2);
      return 0;
    }
    else
    {
      return -2147467259;
    }
  }
}

//----- (00466EA0) --------------------------------------------------------
int __usercall sub_466EA0@<eax>(const OLECHAR *a1@<edi>, HMODULE *a2)
{
  LSTATUS v2; // eax
  DWORD v3; // ecx
  HMODULE LibraryW; // esi
  HMODULE v5; // edx
  int result; // eax
  DWORD Type; // [esp+Ch] [ebp-638h] BYREF
  HKEY hKey; // [esp+10h] [ebp-634h] BYREF
  HKEY phkResult; // [esp+14h] [ebp-630h] BYREF
  HMODULE v10; // [esp+18h] [ebp-62Ch]
  DWORD cbData; // [esp+1Ch] [ebp-628h] BYREF
  CLSID pclsid; // [esp+20h] [ebp-624h] BYREF
  WCHAR SubKey[512]; // [esp+30h] [ebp-614h] BYREF
  __int16 Data[262]; // [esp+430h] [ebp-214h] BYREF

  v10 = 0;
  sub_401000(0x200u, SubKey, L"%s\\%s", L"Software\\Classes\\CLSID", a1);
  if ( RegOpenKeyExW(HKEY_LOCAL_MACHINE, SubKey, 0, 0x20019u, &phkResult) )
  {
    LibraryW = v10;
  }
  else if ( RegOpenKeyExW(phkResult, L"InProcServer32", 0, 0x20019u, &hKey) )
  {
    LibraryW = v10;
    RegCloseKey(phkResult);
  }
  else
  {
    cbData = 260;
    v2 = RegQueryValueExW(hKey, 0, 0, &Type, (LPBYTE)Data, &cbData);
    v3 = cbData;
    if ( cbData && Type == 1 )
    {
      if ( SubKey[cbData + 511] )
      {
        if ( cbData >= 0x104 )
          v3 = 260;
        Data[v3] = 0;
      }
    }
    else
    {
      Data[0] = 0;
    }
    if ( v2 )
      LibraryW = v10;
    else
      LibraryW = LoadLibraryW((LPCWSTR)Data);
    RegCloseKey(hKey);
    RegCloseKey(phkResult);
  }
  if ( CLSIDFromString(a1, &pclsid) || (cbData = 0, CoCreateInstance(&pclsid, 0, 1u, &stru_4BD95C, (LPVOID *)&cbData)) )
  {
    if ( LibraryW )
      FreeLibrary(LibraryW);
    return 0;
  }
  else
  {
    v5 = (HMODULE)cbData;
    result = 1;
    *a2 = LibraryW;
    a2[1] = v5;
  }
  return result;
}
// 4C3230: using guessed type wchar_t aSoftwareClasse[23];
// 4C3260: using guessed type wchar_t aSS[6];
// 466EA0: using guessed type WCHAR Data[262];

//----- (00467080) --------------------------------------------------------
int __cdecl sub_467080(int a1)
{
  const WCHAR *v1; // ecx
  int v2; // esi
  int v3; // edi
  LSTATUS v4; // eax
  DWORD v5; // ecx
  char *v6; // edi
  char **v7; // eax
  int v8; // edx
  void *v10[2]; // [esp+10h] [ebp-A34h] BYREF
  const WCHAR *v11; // [esp+18h] [ebp-A2Ch]
  DWORD Type; // [esp+1Ch] [ebp-A28h] BYREF
  int v13; // [esp+20h] [ebp-A24h]
  HKEY hKey; // [esp+24h] [ebp-A20h] BYREF
  DWORD cbData; // [esp+28h] [ebp-A1Ch] BYREF
  DWORD v16; // [esp+2Ch] [ebp-A18h]
  DWORD cchName; // [esp+30h] [ebp-A14h] BYREF
  HKEY phkResult; // [esp+34h] [ebp-A10h] BYREF
  WCHAR SubKey[512]; // [esp+38h] [ebp-A0Ch] BYREF
  WCHAR Name[512]; // [esp+438h] [ebp-60Ch] BYREF
  __int16 Data[258]; // [esp+838h] [ebp-20Ch] BYREF

  v2 = (int)v1;
  v3 = 0;
  v11 = v1;
  v13 = a1;
  phkResult = 0;
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, v1, 0, 0x20019u, &phkResult) )
  {
    v16 = 0;
    cchName = 512;
    if ( !RegEnumKeyExW(phkResult, 0, Name, &cchName, 0, 0, 0, 0) )
    {
      do
      {
        sub_401000(0x200u, SubKey, L"%s\\%s", v2, Name);
        if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, SubKey, 0, 0x20019u, &hKey) )
        {
          cbData = 256;
          v4 = RegQueryValueExW(hKey, 0, 0, &Type, (LPBYTE)Data, &cbData);
          v5 = cbData;
          if ( cbData && Type == 1 )
          {
            if ( Name[cbData + 511] )
            {
              if ( cbData >= 0x100 )
                v5 = 256;
              Data[v5] = 0;
            }
          }
          else
          {
            Data[0] = 0;
          }
          if ( !v4 && sub_466EA0((const OLECHAR *)Data, (HMODULE *)v10) )
          {
            v6 = *(char **)v13;
            v7 = sub_419770((char **)v10, *(char **)v13, *(_DWORD *)(*(_DWORD *)v13 + 4));
            v8 = *(_DWORD *)(v13 + 4);
            if ( v8 == 536870910 )
              std::_Xlength_error("list<T> too long");
            v2 = (int)v11;
            *(_DWORD *)(v13 + 4) = v8 + 1;
            *((_DWORD *)v6 + 1) = v7;
            *(_DWORD *)v7[1] = v7;
          }
          RegCloseKey(hKey);
        }
        ++v16;
        cchName = 512;
      }
      while ( !RegEnumKeyExW(phkResult, v16, Name, &cchName, 0, 0, 0, 0) );
    }
    RegCloseKey(phkResult);
    return 1;
  }
  return v3;
}
// 467099: variable 'v1' is possibly undefined
// 4C31D4: using guessed type wchar_t aSS_0[6];
// 467080: using guessed type OLECHAR Data[258];
// 467080: using guessed type HMODULE var_A34[2];

//----- (004672A0) --------------------------------------------------------
int __cdecl sub_4672A0(int a1, void *a2)
{
  void ***v2; // eax
  void *v3; // esi
  void **v4; // ecx
  void *v5; // eax
  void **v6; // esi

  v2 = (void ***)a2;
  v3 = *(void **)a2;
  if ( *(void **)a2 != a2 )
  {
    do
    {
      sub_4666D0(
        *((_DWORD *)v3 + 5),
        *((_DWORD *)v3 + 4),
        *((_DWORD *)v3 + 3),
        a1,
        *((const WCHAR **)v3 + 2),
        *((_DWORD *)v3 + 6));
      v3 = *(void **)v3;
    }
    while ( v3 != a2 );
    v2 = (void ***)a2;
  }
  v4 = *v2;
  *v2 = (void **)v2;
  *((_DWORD *)a2 + 1) = a2;
  v5 = a2;
  if ( v4 != a2 )
  {
    do
    {
      v6 = (void **)*v4;
      operator delete(v4);
      v5 = a2;
      v4 = v6;
    }
    while ( v6 != a2 );
  }
  operator delete(v5);
  return 0;
}

//----- (00467360) --------------------------------------------------------
int __usercall sub_467360@<eax>(LPCWSTR lpSrc@<ecx>, int a2@<ebx>, WCHAR *a3@<edi>)
{
  void *v4; // edx
  WCHAR *v5; // eax
  int v6; // edx
  int v7; // esi
  WCHAR v8; // cx
  __int16 v10[260]; // [esp+8h] [ebp-620h] BYREF
  WCHAR pszPath[260]; // [esp+210h] [ebp-418h] BYREF
  WCHAR pszBuf[262]; // [esp+418h] [ebp-210h] BYREF

  if ( lstrlenW(lpSrc) >= 2 && *lpSrc == 58 && lpSrc[1] == 58 )
  {
    v4 = (void *)lpSrc;
  }
  else if ( sub_466900(lpSrc, (WCHAR *)v10) < 0 )
  {
    if ( !sub_466280(lpSrc, pszPath) )
    {
      v5 = pszPath;
      v6 = 260;
      v7 = (char *)lpSrc - (char *)pszPath;
      while ( v6 != -2147483386 )
      {
        v8 = *(WCHAR *)((char *)v5 + v7);
        if ( !v8 )
          break;
        *v5++ = v8;
        if ( !--v6 )
        {
          --v5;
          break;
        }
      }
      *v5 = 0;
    }
    PathCanonicalizeW(pszBuf, pszPath);
    if ( !PathIsURLW(pszBuf) && PathIsRelativeW(pszBuf) )
    {
      sub_4A96F0(260, a2, a3);
      return PathAppendW(a3, pszBuf);
    }
    v4 = pszBuf;
  }
  else
  {
    v4 = v10;
  }
  return sub_4A96F0(260, (int)v4, a3);
}
// 467400: conditional instruction was optimized away because edx.4!=0
// 467360: using guessed type WCHAR var_620[260];

//----- (00467490) --------------------------------------------------------
int __usercall sub_467490@<eax>(int a1@<eax>, int a2, LPCITEMIDLIST pidl, void *a4, int a5)
{
  int v6; // eax
  SIZE_T v7; // edi
  void **v8; // esi
  UINT v9; // eax
  HGLOBAL v10; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // edi
  char *v14; // esi
  UINT v15; // eax
  UINT v16; // eax
  void **v17; // esi
  const ITEMIDLIST *v18; // ecx
  UINT v19; // eax
  void ***v20; // ecx
  void **v21; // eax
  void *v22; // ecx
  void **v23; // esi
  void **v24; // eax
  void *v25; // ecx
  void **v26; // esi
  HGLOBAL hMem; // [esp+Ch] [ebp-18h]
  void **v28; // [esp+10h] [ebp-14h]
  char *v29; // [esp+14h] [ebp-10h]
  char *v30; // [esp+14h] [ebp-10h]
  LPCITEMIDLIST v31; // [esp+18h] [ebp-Ch]
  LPCITEMIDLIST v32; // [esp+18h] [ebp-Ch]
  _DWORD *v33; // [esp+1Ch] [ebp-8h]
  int v34; // [esp+20h] [ebp-4h]
  _DWORD *v35; // [esp+20h] [ebp-4h]

  if ( a1 && a2 && pidl && a5 )
  {
    *(_WORD *)a1 = RegisterClipboardFormatW(L"Shell IDList Array");
    *(_DWORD *)(a1 + 16) = 1;
    *(_DWORD *)(a1 + 8) = 1;
    v6 = a5;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 12) = -1;
    v34 = v6;
    v29 = (char *)(4 * v6 + 8);
    v7 = (SIZE_T)&v29[ILGetSize(pidl)];
    v8 = *(void ***)a4;
    v31 = (LPCITEMIDLIST)a4;
    if ( *(void **)a4 != a4 )
    {
      do
      {
        v9 = ILGetSize((LPCITEMIDLIST)v8[2]);
        v8 = (void **)*v8;
        v7 += v9;
      }
      while ( v8 != (void **)v31 );
    }
    v10 = GlobalAlloc(2u, v7);
    hMem = v10;
    if ( v10 )
    {
      v12 = GlobalLock(v10);
      *v12 = v34;
      v13 = v12 + 1;
      v33 = v12;
      v14 = &v29[(_DWORD)v12];
      v12[1] = v29;
      v15 = ILGetSize(pidl);
      memcpy_0(v14, pidl, v15);
      v16 = ILGetSize(pidl);
      v17 = *(void ***)a4;
      v28 = (void **)a4;
      if ( *(void **)a4 != a4 )
      {
        v35 = v33 + 2;
        do
        {
          v18 = (const ITEMIDLIST *)v17[2];
          v13[1] = v16 + *v13;
          v32 = v18;
          v30 = (char *)v33 + *v35;
          v19 = ILGetSize(v18);
          memcpy_0(v30, v32, v19);
          v16 = ILGetSize(v32);
          v17 = (void **)*v17;
          ++v35;
          ++v13;
        }
        while ( v17 != v28 );
      }
      GlobalUnlock(hMem);
      v20 = (void ***)a4;
      *(_DWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 4) = hMem;
      *(_DWORD *)a2 = 1;
      v21 = *v20;
      *v20 = (void **)v20;
      *((_DWORD *)a4 + 1) = a4;
      v22 = a4;
      a5 = 0;
      if ( v21 != a4 )
      {
        do
        {
          v23 = (void **)*v21;
          operator delete(v21);
          v22 = a4;
          v21 = v23;
        }
        while ( v23 != a4 );
      }
      operator delete(v22);
      return 0;
    }
    else
    {
      sub_41ECB0(&a4);
      return -2147467259;
    }
  }
  else
  {
    v24 = *(void ***)a4;
    *(_DWORD *)a4 = a4;
    *((_DWORD *)a4 + 1) = a4;
    v25 = a4;
    a5 = 0;
    if ( v24 != a4 )
    {
      do
      {
        v26 = (void **)*v24;
        operator delete(v24);
        v25 = a4;
        v24 = v26;
      }
      while ( v26 != a4 );
    }
    operator delete(v25);
    return -2147467259;
  }
}

//----- (00467670) --------------------------------------------------------
BOOL __usercall sub_467670@<eax>(_DWORD *a1@<eax>)
{
  BOOL result; // eax
  HGLOBAL v3; // eax
  void *v4; // esi
  int v5; // ebx
  void *v6; // eax
  int v7; // ecx

  result = OpenClipboard(0);
  if ( result )
  {
    EmptyClipboard();
    v3 = GlobalAlloc(2u, 2 * a1[4] + 2);
    v4 = v3;
    v5 = 0;
    if ( v3 )
    {
      v6 = GlobalLock(v3);
      v7 = a1[4];
      if ( a1[5] >= 8u )
        a1 = (_DWORD *)*a1;
      memcpy_0(v6, a1, 2 * v7 + 2);
      GlobalUnlock(v4);
      if ( SetClipboardData(0xDu, v4) )
        v5 = 1;
    }
    CloseClipboard();
    return v5;
  }
  return result;
}

//----- (004676F0) --------------------------------------------------------
HRESULT __usercall sub_4676F0@<eax>(const ITEMIDLIST *a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4, int a5, _WORD *a6)
{
  HRESULT v7; // esi
  HRESULT v8; // eax
  IShellFolder *ppshf; // [esp+4h] [ebp-10h] BYREF
  int v12; // [esp+8h] [ebp-Ch] BYREF
  LPVOID pv; // [esp+Ch] [ebp-8h] BYREF
  IShellFolder *v14; // [esp+10h] [ebp-4h] BYREF

  if ( !a1 || !a5 || !a6 )
    return -2147467259;
  ppshf = 0;
  v14 = 0;
  v12 = 0;
  pv = 0;
  v7 = SHGetDesktopFolder(&ppshf);
  if ( v7 >= 0 )
  {
    if ( sub_4663F0(a1) )
      v8 = SHGetDesktopFolder(&v14);
    else
      v8 = ppshf->lpVtbl->BindToObject(ppshf, a1, 0, &stru_4BD7FC, (void **)&v14);
    v7 = v8;
    if ( v8 >= 0 )
    {
      v7 = ((int (__stdcall *)(IShellFolder *, int, int, int, void *, _DWORD, int *, int))v14->lpVtbl->GetUIObjectOf)(
             v14,
             a4,
             1,
             a5,
             &unk_4BD83C,
             0,
             &v12,
             a3);
      if ( v7 >= 0 )
      {
        v7 = (*(int (__stdcall **)(int, int, LPVOID *, int))(*(_DWORD *)v12 + 12))(v12, 8, &pv, a2);
        if ( v7 >= 0 && pv )
        {
          sub_4011B0(0x200u, (int)pv, a6);
          CoTaskMemFree(pv);
        }
        else
        {
          sub_4011B0(0x200u, (int)&unk_4C31A8, a6);
        }
        (*(void (__cdecl **)(int))(*(_DWORD *)v12 + 8))(v12);
      }
      ((void (__cdecl *)(IShellFolder *))v14->lpVtbl->Release)(v14);
    }
    ppshf->lpVtbl->Release(ppshf);
  }
  return v7;
}
// 4676F0: could not find valid save-restore pair for ebx
// 4676F0: could not find valid save-restore pair for esi

//----- (00467810) --------------------------------------------------------
HRESULT __usercall sub_467810@<eax>(LPITEMIDLIST *a1@<ebx>, int a2@<edi>)
{
  HRESULT v2; // esi
  char *v3; // eax
  int v4; // edx
  __int16 v5; // cx
  IShellFolder *ppshf; // [esp+0h] [ebp-210h] BYREF
  char v8[520]; // [esp+4h] [ebp-20Ch] BYREF

  if ( !a2 || !a1 )
    return -2147467259;
  ppshf = 0;
  v2 = SHGetDesktopFolder(&ppshf);
  if ( v2 >= 0 )
  {
    v3 = v8;
    v4 = 260;
    while ( v4 != -2147483386 )
    {
      v5 = *(_WORD *)&v3[a2 - (_DWORD)v8];
      if ( !v5 )
        break;
      *(_WORD *)v3 = v5;
      v3 += 2;
      if ( !--v4 )
      {
        v3 -= 2;
        break;
      }
    }
    *(_WORD *)v3 = 0;
    v2 = ppshf->lpVtbl->ParseDisplayName(ppshf, 0, 0, (LPWSTR)v8, 0, a1, 0);
    ppshf->lpVtbl->Release(ppshf);
  }
  return v2;
}
// 467882: conditional instruction was optimized away because edx.4!=0

//----- (004678E0) --------------------------------------------------------
HRESULT __cdecl sub_4678E0(void *a1, int a2)
{
  void **v2; // eax
  void *v3; // ecx
  void **v4; // esi
  HRESULT v6; // esi
  void **v7; // eax
  void *v8; // ecx
  void **v9; // edi
  char **v10[9]; // [esp-Ch] [ebp-40h] BYREF
  char v11[4]; // [esp+18h] [ebp-1Ch] BYREF
  LPVOID v12; // [esp+1Ch] [ebp-18h] BYREF
  LPVOID ppv; // [esp+20h] [ebp-14h] BYREF
  int v14[4]; // [esp+24h] [ebp-10h] BYREF

  v14[3] = 0;
  if ( a2 )
  {
    ppv = 0;
    v6 = CoCreateInstance(&stru_4BD90C, 0, 1u, &stru_4BD8DC, &ppv);
    if ( v6 >= 0 )
    {
      v14[0] = 0;
      v6 = (*(int (__stdcall **)(LPVOID, char *, void *, int *))(*(_DWORD *)ppv + 16))(ppv, v11, &unk_4BD97C, v14);
      if ( v6 >= 0 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v14[0] + 8))(v14[0]);
        v12 = 0;
        v6 = CoCreateInstance(&stru_4BD91C, 0, 1u, &stru_4BD98C, &v12);
        if ( v6 >= 0 )
        {
          v10[8] = (char **)v10;
          sub_415E50(v10, (int **)&a1);
          sub_4672A0((int)v12, v10[0]);
          v6 = (**(int (__stdcall ***)(LPVOID, void *, int *))v12)(v12, &unk_4BD97C, v14);
          if ( v6 >= 0 )
          {
            (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 28))(ppv, v14[0]);
            (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 32))(ppv);
            (*(void (__stdcall **)(int))(*(_DWORD *)v14[0] + 8))(v14[0]);
          }
          (*(void (__stdcall **)(LPVOID))(*(_DWORD *)v12 + 8))(v12);
        }
      }
      (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    }
    v7 = *(void ***)a1;
    *(_DWORD *)a1 = a1;
    *((_DWORD *)a1 + 1) = a1;
    v8 = a1;
    a2 = 0;
    if ( v7 != a1 )
    {
      do
      {
        v9 = (void **)*v7;
        operator delete(v7);
        v8 = a1;
        v7 = v9;
      }
      while ( v9 != a1 );
    }
    operator delete(v8);
    return v6;
  }
  else
  {
    v2 = *(void ***)a1;
    *(_DWORD *)a1 = a1;
    *((_DWORD *)a1 + 1) = a1;
    v3 = a1;
    a2 = 0;
    if ( v2 != a1 )
    {
      do
      {
        v4 = (void **)*v2;
        operator delete(v2);
        v3 = a1;
        v2 = v4;
      }
      while ( v4 != a1 );
    }
    operator delete(v3);
    return -2147467259;
  }
}
// 4678E0: using guessed type char var_1C[4];

//----- (00467A90) --------------------------------------------------------
int __thiscall sub_467A90(const ITEMIDLIST *this)
{
  LPVOID pv; // [esp+Ch] [ebp-214h] BYREF
  __int16 v3[262]; // [esp+10h] [ebp-210h] BYREF

  pv = 0;
  if ( sub_466630(this, (WCHAR *)v3, 0x8000) < 0 || sub_467810((LPITEMIDLIST *)&pv, (int)v3) < 0 )
    return 0;
  CoTaskMemFree(pv);
  return 1;
}
// 467A90: using guessed type WCHAR var_210[262];

//----- (00467B20) --------------------------------------------------------
HRESULT __usercall sub_467B20@<eax>(int a1@<eax>, int a2@<esi>)
{
  HRESULT v2; // edi
  LPVOID pv; // [esp+4h] [ebp-4h] BYREF

  if ( !a1 || !a2 )
    return -2147467259;
  pv = 0;
  v2 = sub_467810((LPITEMIDLIST *)&pv, a1);
  if ( v2 >= 0 )
  {
    v2 = sub_4665C0((const ITEMIDLIST *)pv, a2);
    CoTaskMemFree(pv);
  }
  return v2;
}

//----- (00467B70) --------------------------------------------------------
HRESULT __usercall sub_467B70@<eax>(int a1@<eax>, WCHAR *a2@<esi>, int a3)
{
  HRESULT v3; // edi
  LPVOID pv; // [esp+8h] [ebp-4h] BYREF

  if ( !a1 || !a2 )
    return -2147467259;
  pv = 0;
  v3 = sub_467810((LPITEMIDLIST *)&pv, a1);
  if ( v3 >= 0 )
    v3 = sub_466630((const ITEMIDLIST *)pv, a2, a3);
  CoTaskMemFree(pv);
  return v3;
}

//----- (00467BD0) --------------------------------------------------------
int __cdecl sub_467BD0(int a1, void *a2, int a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  int v5; // edi
  HGLOBAL v6; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // ebx
  int v9; // edi
  void **v10; // ecx
  _DWORD *v12; // [esp+10h] [ebp-38h]
  HGLOBAL hMem; // [esp+14h] [ebp-34h]
  _DWORD *v14; // [esp+18h] [ebp-30h]
  _DWORD *v15; // [esp+18h] [ebp-30h]
  void *Src[4]; // [esp+1Ch] [ebp-2Ch] BYREF
  int v17; // [esp+2Ch] [ebp-1Ch]
  unsigned int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+44h] [ebp-4h]

  v12 = v3;
  v19 = 0;
  if ( !a1 || !v3 || !a3 )
  {
    sub_40A140((int)&a2);
    operator delete(a2);
    return -2147467259;
  }
  *(_WORD *)a1 = 15;
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 12) = -1;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 4) = 0;
  v4 = *(_DWORD **)a2;
  v5 = 20;
  v14 = a2;
  if ( *(void **)a2 != a2 )
  {
    do
    {
      v18 = 7;
      v17 = 0;
      LOWORD(Src[0]) = 0;
      sub_4090E0((int)Src, v4 + 2, 0, 0xFFFFFFFF);
      v5 += 2 * v17 + 2;
      if ( v18 >= 8 )
        operator delete(Src[0]);
      v4 = (_DWORD *)*v4;
    }
    while ( v4 != v14 );
  }
  v6 = GlobalAlloc(2u, v5 + 2);
  hMem = v6;
  if ( !v6 )
  {
    sub_40A140((int)&a2);
    operator delete(a2);
    return -2147467259;
  }
  v7 = GlobalLock(v6);
  *v7 = 20;
  v7[3] = 0;
  v7[1] = 0;
  v7[2] = 0;
  v7[4] = 1;
  v8 = *(_DWORD **)a2;
  v9 = 0;
  v15 = a2;
  if ( *(void **)a2 != a2 )
  {
    do
    {
      LOWORD(Src[0]) = 0;
      v18 = 7;
      v17 = 0;
      sub_4090E0((int)Src, v8 + 2, 0, 0xFFFFFFFF);
      v10 = (void **)Src[0];
      if ( v18 < 8 )
        v10 = Src;
      memcpy_0((char *)v7 + v9 + 20, v10, 2 * v17 + 2);
      v9 += 2 * v17 + 2;
      if ( v18 >= 8 )
        operator delete(Src[0]);
      v8 = (_DWORD *)*v8;
    }
    while ( v8 != v15 );
  }
  *(_WORD *)((char *)v7 + v9 + 20) = 0;
  GlobalUnlock(hMem);
  v12[2] = 0;
  v12[1] = hMem;
  *v12 = 1;
  sub_40A140((int)&a2);
  operator delete(a2);
  return 0;
}
// 467BFE: variable 'v3' is possibly undefined

//----- (00467DC0) --------------------------------------------------------
int __userpurge sub_467DC0@<eax>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4)
{
  int result; // eax
  int v7; // ebx
  __int16 v8; // dx

  result = 0;
  if ( a1 )
  {
    v7 = a4 - (_DWORD)a3;
    while ( a2 )
    {
      v8 = *(_WORD *)((char *)a3 + v7);
      if ( !v8 )
        break;
      *a3++ = v8;
      --a2;
      if ( !--a1 )
      {
        result = -2147024774;
        *(a3 - 1) = 0;
        return result;
      }
    }
  }
  else
  {
    --a3;
    result = -2147024774;
  }
  *a3 = 0;
  return result;
}
// 467E02: conditional instruction was optimized away because esi.4!=0

//----- (00467E40) --------------------------------------------------------
int __fastcall sub_467E40(_BYTE *a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // esi
  char v5; // dl

  result = 0;
  v3 = 64;
  v4 = a2 - (_DWORD)a1;
  while ( v3 != -2147483582 )
  {
    v5 = a1[v4];
    if ( !v5 )
      break;
    *a1++ = v5;
    if ( !--v3 )
    {
      result = -2147024774;
      *(a1 - 1) = 0;
      return result;
    }
  }
  *a1 = 0;
  return result;
}
// 467E75: conditional instruction was optimized away because edi.4!=0

//----- (00467F60) --------------------------------------------------------
HWND __usercall sub_467F60@<eax>(HWND a1@<ebx>, HWND hWnd)
{
  HWND result; // eax
  WPARAM v3; // esi
  HWND v4; // [esp+Ch] [ebp-5Ch]
  int v5[2]; // [esp+10h] [ebp-58h] BYREF
  LPARAM lParam; // [esp+18h] [ebp-50h] BYREF
  int v7; // [esp+1Ch] [ebp-4Ch]
  HWND v8; // [esp+38h] [ebp-30h]
  int v9; // [esp+5Ch] [ebp-Ch]

  result = (HWND)SendMessageW(a1, 0x40Cu, 0, 0);
  v3 = 0;
  v4 = result;
  if ( (int)result > 0 )
  {
    while ( 1 )
    {
      lParam = 80;
      v7 = 16;
      SendMessageW(a1, 0x41Cu, v3, (LPARAM)&lParam);
      result = hWnd;
      if ( v8 == hWnd )
        break;
      if ( (int)++v3 >= (int)v4 )
        return result;
    }
    if ( v3 != -1 )
    {
      SendMessageW(hWnd, 0x453u, 0, (LPARAM)v5);
      lParam = 80;
      v7 = 512;
      v9 = v5[0];
      return (HWND)SendMessageW(a1, 0x40Bu, v3, (LPARAM)&lParam);
    }
  }
  return result;
}
// 467F60: using guessed type LPARAM var_58[2];

//----- (00468000) --------------------------------------------------------
LRESULT __usercall sub_468000@<eax>(HWND a1@<edi>, int a2, LPARAM lParam)
{
  int v3; // esi
  LRESULT v4; // eax

  v3 = 0;
  v4 = SendMessageW(a1, 0x1037u, 0, 0);
  if ( a2 )
  {
    if ( (v4 & 8) == 0 )
      v3 = 8;
    if ( (v4 & 0x40) == 0 )
      v3 |= 0x40u;
    if ( (v4 & 0x800) == 0 )
      v3 |= 0x800u;
    SendMessageW(a1, 0x1036u, 0, v3 | v4);
    return SendMessageW(a1, 0x1047u, 0, lParam);
  }
  else
  {
    if ( (v4 & 8) != 0 )
      v3 = 8;
    if ( (v4 & 0x40) != 0 )
      v3 |= 0x40u;
    if ( (v4 & 0x800) != 0 )
      v3 |= 0x800u;
    return SendMessageW(a1, 0x1036u, 0, v4 & ~v3);
  }
}

//----- (00468090) --------------------------------------------------------
int __cdecl sub_468090(int a1, int a2, _DWORD *a3)
{
  int v3; // esi
  HMODULE LibraryW; // eax
  HMODULE v5; // ebx
  HRESULT (__stdcall *WMCreateEditor)(IWMMetadataEditor **); // eax
  void *v7; // eax
  char v9[4]; // [esp+8h] [ebp-14h] BYREF
  int v10; // [esp+Ch] [ebp-10h] BYREF
  int v11; // [esp+10h] [ebp-Ch] BYREF
  int v12; // [esp+14h] [ebp-8h] BYREF
  unsigned __int16 v13; // [esp+18h] [ebp-4h] BYREF

  v11 = 0;
  v12 = 0;
  v3 = -2147467259;
  LibraryW = LoadLibraryW(L"wmvcore.dll");
  v5 = LibraryW;
  if ( LibraryW )
  {
    WMCreateEditor = (HRESULT (__stdcall *)(IWMMetadataEditor **))GetProcAddress(LibraryW, "WMCreateEditor");
    if ( WMCreateEditor )
    {
      v3 = WMCreateEditor((IWMMetadataEditor **)&v11);
      if ( v3 >= 0 )
      {
        v3 = (*(int (__stdcall **)(int, int))(*(_DWORD *)v11 + 12))(v11, a1);
        if ( v3 >= 0 )
        {
          v3 = (**(int (__stdcall ***)(int, void *, int *))v11)(v11, &unk_4CC2B8, &v12);
          if ( v3 >= 0 )
          {
            v10 = 0;
            v3 = (*(int (__stdcall **)(int, int *, int, char *, _DWORD, unsigned __int16 *))(*(_DWORD *)v12 + 20))(
                   v12,
                   &v10,
                   a2,
                   v9,
                   0,
                   &v13);
            if ( v3 >= 0 )
            {
              v7 = malloc(2 * v13);
              *a3 = v7;
              if ( v7 )
                v3 = (*(int (__stdcall **)(int, int *, int, char *, void *, unsigned __int16 *))(*(_DWORD *)v12 + 20))(
                       v12,
                       &v10,
                       a2,
                       v9,
                       v7,
                       &v13);
            }
            (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
          }
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
      }
    }
    FreeLibrary(v5);
  }
  return v3;
}
// 468090: using guessed type char var_14[4];

//----- (004681A0) --------------------------------------------------------
int __cdecl sub_4681A0(LPCWSTR lptstrFilename, int a2, int a3)
{
  int v3; // ebx
  DWORD FileVersionInfoSizeW; // eax
  DWORD v5; // esi
  void *v6; // eax
  void *v7; // edi
  int v8; // eax
  DWORD dwHandle; // [esp+8h] [ebp-Ch] BYREF
  unsigned int puLen; // [esp+Ch] [ebp-8h] BYREF
  LPVOID lpBuffer; // [esp+10h] [ebp-4h] BYREF

  v3 = 0;
  *(_DWORD *)a2 = 0;
  lpBuffer = 0;
  *(_DWORD *)a3 = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(lptstrFilename, &dwHandle);
  v5 = FileVersionInfoSizeW;
  if ( !FileVersionInfoSizeW )
    return 0;
  v6 = malloc(FileVersionInfoSizeW);
  v7 = v6;
  if ( v6 )
  {
    GetFileVersionInfoW(lptstrFilename, 0, v5, v6);
    VerQueryValueW(v7, L"\\", &lpBuffer, &puLen);
    if ( puLen )
    {
      v8 = *((_DWORD *)lpBuffer + 4);
      *(_DWORD *)a2 = *((_DWORD *)lpBuffer + 5);
      *(_DWORD *)a3 = v8;
      v3 = 1;
    }
    free(v7);
  }
  return v3;
}

//----- (00468240) --------------------------------------------------------
__int16 __usercall sub_468240@<ax>(const WCHAR *a1@<ebx>)
{
  DWORD FileVersionInfoSizeW; // eax
  DWORD v2; // edi
  void *v3; // eax
  void *v4; // esi
  __int16 v5; // di
  DWORD dwHandle; // [esp+8h] [ebp-10h] BYREF
  unsigned int puLen; // [esp+Ch] [ebp-Ch] BYREF
  int v9; // [esp+10h] [ebp-8h]
  LPVOID lpBuffer; // [esp+14h] [ebp-4h] BYREF

  lpBuffer = 0;
  v9 = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(a1, &dwHandle);
  v2 = FileVersionInfoSizeW;
  if ( !FileVersionInfoSizeW )
    return 0;
  v3 = malloc(FileVersionInfoSizeW);
  v4 = v3;
  if ( !v3 )
    return v9;
  GetFileVersionInfoW(a1, 0, v2, v3);
  VerQueryValueW(v4, L"\\VarFileInfo\\Translation", &lpBuffer, &puLen);
  if ( puLen < 4 )
    v5 = v9;
  else
    v5 = *(_WORD *)lpBuffer & 0x3FF;
  free(v4);
  return v5;
}

//----- (004682E0) --------------------------------------------------------
int __cdecl sub_4682E0(int a1)
{
  int ModuleFileName; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v3; // esi

  ModuleFileName = 0;
  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  if ( v3 )
  {
    ModuleFileName = GetModuleFileNameExW(v3, 0, a1, 260);
    CloseHandle(v3);
  }
  return ModuleFileName;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00468320) --------------------------------------------------------
LONG __usercall sub_468320@<eax>(int a1@<eax>, HWND a2@<edi>, int a3)
{
  LONG WindowLongW; // eax

  WindowLongW = GetWindowLongW(a2, -16);
  if ( a3 )
  {
    if ( (a1 & WindowLongW) != a1 )
      return SetWindowLongW(a2, -16, a1 | WindowLongW);
  }
  else if ( (a1 & WindowLongW) == a1 )
  {
    WindowLongW &= ~a1;
  }
  return SetWindowLongW(a2, -16, WindowLongW);
}

//----- (00468480) --------------------------------------------------------
int __usercall sub_468480@<eax>(const WCHAR *a1@<eax>)
{
  LPWSTR ExtensionW; // eax
  const WCHAR *v2; // edi
  LPCWSTR *v3; // esi

  if ( !a1 )
    return 0;
  ExtensionW = PathFindExtensionW(a1);
  if ( !ExtensionW )
    return 0;
  v2 = ExtensionW + 1;
  if ( ExtensionW == (LPWSTR)-2 )
    return 0;
  v3 = (LPCWSTR *)off_4EDBDC;
  while ( lstrcmpiW(v2, *v3) )
  {
    if ( (int)++v3 >= (int)aYes_0 )
      return 0;
  }
  return 1;
}
// 4EDBDC: using guessed type wchar_t *off_4EDBDC[10];

//----- (004684D0) --------------------------------------------------------
wchar_t *__usercall sub_4684D0@<eax>(int a1@<eax>)
{
  if ( !a1 )
    return L"Ready";
  if ( (a1 & 0x200) != 0 )
    return L"Busy";
  if ( (a1 & 2) != 0 )
    return L"Error";
  if ( (a1 & 0x8000) != 0 )
    return L"Initializing";
  if ( (a1 & 0x100) != 0 )
    return L"Active";
  if ( (a1 & 0x1000) != 0 )
    return L"Unavailable";
  if ( (a1 & 0x80u) != 0 )
    return L"Offline";
  if ( (a1 & 0x200000) != 0 )
    return L"Out of memory";
  return (a1 & 0x40000) != 0 ? L"Out of toner" : 0;
}
// 4C35C0: using guessed type wchar_t aReady[6];
// 4C35CC: using guessed type wchar_t aBusy[5];
// 4C35D8: using guessed type wchar_t aError[6];
// 4C35E4: using guessed type wchar_t aInitializing[13];
// 4C3600: using guessed type wchar_t aActive[7];
// 4C3610: using guessed type wchar_t aUnavailable[12];
// 4C3628: using guessed type wchar_t aOffline[8];
// 4C3638: using guessed type wchar_t aOutOfMemory[14];
// 4C3654: using guessed type wchar_t aOutOfToner[13];

//----- (00468540) --------------------------------------------------------
BOOL __usercall sub_468540@<eax>(LPCWSTR lpSrcStr@<ecx>, const WCHAR *a2@<eax>, int a3)
{
  LPCWSTR v3; // esi
  WCHAR v5; // ax
  BOOL v6; // edx
  BOOL v7; // eax
  WCHAR v9; // [esp+8h] [ebp-8h] BYREF
  WCHAR DestStr; // [esp+Ch] [ebp-4h] BYREF

  v3 = lpSrcStr;
  v5 = *lpSrcStr;
  v6 = 1;
  if ( *lpSrcStr )
  {
    while ( 1 )
    {
      if ( !*a2 || !v6 )
        goto LABEL_23;
      if ( v5 == 42 )
      {
        v7 = 0;
        if ( v3[1] )
          v7 = sub_469A50(++v3, (int)a2, a3);
        for ( ; *v3; v7 = sub_469A50(v3, (int)a2, a3) )
        {
          if ( !*a2 )
            break;
          if ( v7 )
            goto LABEL_17;
          ++a2;
        }
        if ( v7 )
        {
LABEL_17:
          while ( *v3 )
            ++v3;
          for ( --v3; *a2; ++a2 )
            ;
        }
        v6 = v7;
        goto LABEL_22;
      }
      if ( v5 == 63 )
        goto LABEL_9;
      if ( !a3 )
        break;
      v6 = v5 == *a2++;
LABEL_22:
      v5 = v3[1];
      ++v3;
      if ( !v5 )
        goto LABEL_23;
    }
    LCMapStringW(0x400u, 0x100u, v3, 1, &DestStr, 1);
    LCMapStringW(0x400u, 0x100u, a2, 1, &v9, 1);
    v6 = DestStr == v9;
LABEL_9:
    ++a2;
    goto LABEL_22;
  }
LABEL_23:
  while ( *v3 == 42 )
    ++v3;
  return !*v3 && !*a2 && v6;
}

//----- (004686B0) --------------------------------------------------------
LRESULT __usercall sub_4686B0@<eax>(HWND a1@<esi>, WPARAM wParam, WPARAM a3)
{
  LRESULT result; // eax
  int v4; // ebx
  int v5; // [esp+8h] [ebp-82Ch]
  int v6; // [esp+Ch] [ebp-828h]
  int v7; // [esp+10h] [ebp-824h]
  LPARAM lParam[3]; // [esp+14h] [ebp-820h] BYREF
  char *v9; // [esp+20h] [ebp-814h]
  int v10; // [esp+24h] [ebp-810h]
  int v11; // [esp+28h] [ebp-80Ch]
  int v12; // [esp+2Ch] [ebp-808h]
  char v13[1024]; // [esp+30h] [ebp-804h] BYREF
  char v14[1024]; // [esp+430h] [ebp-404h] BYREF

  lParam[0] = 11;
  v9 = v14;
  v10 = 512;
  result = SendMessageW(a1, 0x133Cu, wParam, (LPARAM)lParam);
  if ( result )
  {
    v6 = v12;
    v5 = v11;
    lParam[0] = 11;
    v9 = v13;
    v10 = 512;
    result = SendMessageW(a1, 0x133Cu, a3, (LPARAM)lParam);
    if ( result )
    {
      v4 = v12;
      v9 = v14;
      v12 = v6;
      v7 = v11;
      lParam[0] = 11;
      v11 = v5;
      SendMessageW(a1, 0x133Du, a3, (LPARAM)lParam);
      v9 = v13;
      lParam[0] = 11;
      v12 = v4;
      v11 = v7;
      return SendMessageW(a1, 0x133Du, wParam, (LPARAM)lParam);
    }
  }
  return result;
}

//----- (00468800) --------------------------------------------------------
LRESULT __usercall sub_468800@<eax>(HWND a1@<edi>, int wParam, int a3)
{
  LRESULT result; // eax
  int v4; // ebx
  HWND v5; // eax
  LRESULT v6; // eax
  unsigned int v7; // ebx
  LPARAM v8[3]; // [esp+8h] [ebp-1070h] BYREF
  LRESULT v9; // [esp+14h] [ebp-1064h]
  int v10; // [esp+18h] [ebp-1060h]
  LPARAM lParam; // [esp+3Ch] [ebp-103Ch] BYREF
  int v12; // [esp+40h] [ebp-1038h]
  int v13; // [esp+44h] [ebp-1034h]
  char *v14; // [esp+50h] [ebp-1028h]
  int v15; // [esp+54h] [ebp-1024h]
  LRESULT v16; // [esp+70h] [ebp-1008h]
  char v17[1024]; // [esp+74h] [ebp-1004h] BYREF
  char v18[1024]; // [esp+474h] [ebp-C04h] BYREF
  char v19[1024]; // [esp+874h] [ebp-804h] BYREF
  char v20[1024]; // [esp+C74h] [ebp-404h] BYREF

  lParam = 1;
  v12 = wParam;
  v13 = 0;
  v14 = v19;
  v15 = 512;
  result = SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
  if ( result )
  {
    lParam = 1;
    v12 = a3;
    v13 = 0;
    v14 = v20;
    v15 = 512;
    result = SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
    if ( result )
    {
      lParam = 1;
      v12 = wParam;
      v13 = 0;
      v14 = v20;
      SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
      lParam = 1;
      v12 = a3;
      v13 = 0;
      v14 = v19;
      SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
      v4 = 1;
      v5 = (HWND)SendMessageW(a1, 0x101Fu, 0, 0);
      v6 = SendMessageW(v5, 0x1200u, 0, 0);
      if ( v6 > 0 )
      {
        v16 = v6;
        do
        {
          lParam = 1;
          v12 = wParam;
          v13 = v4;
          v14 = v18;
          v15 = 512;
          SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
          lParam = 1;
          v12 = a3;
          v13 = v4;
          v14 = v17;
          v15 = 512;
          SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
          lParam = 1;
          v12 = wParam;
          v13 = v4;
          v14 = v17;
          SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
          lParam = 1;
          v12 = a3;
          v13 = v4;
          v14 = v18;
          SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
          ++v4;
          --v16;
        }
        while ( v16 );
      }
      v16 = SendMessageW(a1, 0x102Cu, wParam, 7);
      v10 = 7;
      v9 = SendMessageW(a1, 0x102Cu, a3, 7);
      SendMessageW(a1, 0x102Bu, wParam, (LPARAM)v8);
      v10 = 7;
      v9 = v16;
      SendMessageW(a1, 0x102Bu, a3, (LPARAM)v8);
      v7 = (unsigned int)SendMessageW(a1, 0x102Cu, wParam, 61440) >> 12;
      v10 = 61440;
      v9 = (((unsigned int)SendMessageW(a1, 0x102Cu, a3, 61440) >> 12 != 1) + 1) << 12;
      SendMessageW(a1, 0x102Bu, wParam, (LPARAM)v8);
      v10 = 61440;
      v9 = ((v7 != 1) + 1) << 12;
      return SendMessageW(a1, 0x102Bu, a3, (LPARAM)v8);
    }
  }
  return result;
}

//----- (00468B50) --------------------------------------------------------
LRESULT __usercall sub_468B50@<eax>(HWND a1@<edi>, int wParam, int a3)
{
  LRESULT result; // eax
  LRESULT v4; // ebx
  HWND v5; // eax
  unsigned int v6; // ebx
  LPARAM v7[3]; // [esp+8h] [ebp-1070h] BYREF
  LRESULT v8; // [esp+14h] [ebp-1064h]
  int v9; // [esp+18h] [ebp-1060h]
  LPARAM lParam; // [esp+3Ch] [ebp-103Ch] BYREF
  int v11; // [esp+40h] [ebp-1038h]
  LRESULT v12; // [esp+44h] [ebp-1034h]
  char *v13; // [esp+50h] [ebp-1028h]
  int v14; // [esp+54h] [ebp-1024h]
  LRESULT v15; // [esp+5Ch] [ebp-101Ch]
  LRESULT v16; // [esp+70h] [ebp-1008h]
  char v17[1024]; // [esp+74h] [ebp-1004h] BYREF
  char v18[1024]; // [esp+474h] [ebp-C04h] BYREF
  char v19[1024]; // [esp+874h] [ebp-804h] BYREF
  char v20[1024]; // [esp+C74h] [ebp-404h] BYREF

  lParam = 5;
  v11 = wParam;
  v12 = 0;
  v13 = v19;
  v14 = 512;
  result = SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
  if ( result )
  {
    lParam = 5;
    v16 = v15;
    v11 = a3;
    v12 = 0;
    v13 = v20;
    v14 = 512;
    result = SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
    if ( result )
    {
      lParam = 5;
      v11 = wParam;
      v12 = 0;
      v13 = v20;
      SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
      lParam = 5;
      v11 = a3;
      v12 = 0;
      v13 = v19;
      v15 = v16;
      SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
      v4 = 1;
      v5 = (HWND)SendMessageW(a1, 0x101Fu, 0, 0);
      v16 = SendMessageW(v5, 0x1200u, 0, 0);
      if ( v16 > 1 )
      {
        do
        {
          lParam = 1;
          v11 = wParam;
          v12 = v4;
          v13 = v18;
          v14 = 512;
          SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
          lParam = 1;
          v11 = a3;
          v12 = v4;
          v13 = v17;
          v14 = 512;
          SendMessageW(a1, 0x104Bu, 0, (LPARAM)&lParam);
          lParam = 1;
          v11 = wParam;
          v12 = v4;
          v13 = v17;
          SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
          lParam = 1;
          v11 = a3;
          v12 = v4;
          v13 = v18;
          SendMessageW(a1, 0x104Cu, 0, (LPARAM)&lParam);
          ++v4;
        }
        while ( v4 < v16 );
      }
      v16 = SendMessageW(a1, 0x102Cu, wParam, 7);
      v9 = 7;
      v8 = SendMessageW(a1, 0x102Cu, a3, 7);
      SendMessageW(a1, 0x102Bu, wParam, (LPARAM)v7);
      v9 = 7;
      v8 = v16;
      SendMessageW(a1, 0x102Bu, a3, (LPARAM)v7);
      v6 = (unsigned int)SendMessageW(a1, 0x102Cu, wParam, 61440) >> 12;
      v9 = 61440;
      v8 = (((unsigned int)SendMessageW(a1, 0x102Cu, a3, 61440) >> 12 != 1) + 1) << 12;
      SendMessageW(a1, 0x102Bu, wParam, (LPARAM)v7);
      v9 = 61440;
      v8 = ((v6 != 1) + 1) << 12;
      return SendMessageW(a1, 0x102Bu, a3, (LPARAM)v7);
    }
  }
  return result;
}

//----- (00468F10) --------------------------------------------------------
BOOL __usercall sub_468F10@<eax>(HWND a1@<eax>, const WCHAR *a2@<edx>, WCHAR *a3@<ecx>)
{
  struct tagOFNW v4; // [esp+0h] [ebp-58h] BYREF

  v4.hwndOwner = a1;
  memset(&v4.lpstrCustomFilter, 0, 12);
  v4.lpstrFileTitle = 0;
  v4.nMaxFileTitle = 0;
  v4.lpstrTitle = 0;
  v4.lCustData = 0;
  v4.lpfnHook = 0;
  memset(&v4.pvReserved, 0, 12);
  v4.lStructSize = 88;
  v4.lpstrFilter = L"Text Document (*.txt)";
  v4.lpstrFile = a3;
  v4.nMaxFile = 260;
  v4.lpstrInitialDir = a2;
  v4.Flags = 8912898;
  v4.lpstrDefExt = L"txt";
  return GetSaveFileNameW(&v4);
}
// 4C3538: using guessed type wchar_t aTextDocumentTx[22];
// 4C3590: using guessed type wchar_t aTxt[4];

//----- (00468F80) --------------------------------------------------------
DWORD __cdecl sub_468F80(LPCWSTR lpFileName)
{
  HANDLE FileW; // esi
  BOOL FileInformationByHandle; // edi
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [esp+4h] [ebp-38h] BYREF

  FileW = CreateFileW(lpFileName, 0x80u, 1u, 0, 3u, 0, 0);
  if ( FileW == (HANDLE)-1 )
    return 0;
  FileInformationByHandle = GetFileInformationByHandle(FileW, &FileInformation);
  CloseHandle(FileW);
  return FileInformationByHandle ? FileInformation.nNumberOfLinks : 0;
}

//----- (004691C0) --------------------------------------------------------
HANDLE __usercall sub_4691C0@<eax>(int a1@<ecx>, const WCHAR *a2@<ebx>, DWORD dwProcessId)
{
  HANDLE result; // eax
  HANDLE v5; // edi
  struct _LUID Luid; // [esp+8h] [ebp-24h] BYREF
  HANDLE TokenHandle; // [esp+10h] [ebp-1Ch] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+14h] [ebp-18h] BYREF

  result = OpenProcess(0x1F0FFFu, 0, dwProcessId);
  v5 = result;
  if ( result )
  {
    OpenProcessToken(result, 0xF01FFu, &TokenHandle);
    LookupPrivilegeValueW(0, a2, &Luid);
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = Luid;
    NewState.Privileges[0].Attributes = a1 != 0 ? 2 : 0;
    CloseHandle(v5);
    return (HANDLE)AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
  }
  return result;
}

//----- (00469350) --------------------------------------------------------
HINSTANCE __usercall sub_469350@<eax>(const WCHAR *a1@<esi>)
{
  WCHAR pszDest[260]; // [esp+4h] [ebp-424h] BYREF
  WCHAR pszPath[260]; // [esp+20Ch] [ebp-21Ch] BYREF
  WCHAR pszFile[2]; // [esp+414h] [ebp-14h] BYREF
  int v5; // [esp+418h] [ebp-10h]
  int v6; // [esp+41Ch] [ebp-Ch]
  int v7; // [esp+420h] [ebp-8h]

  v5 = 3014756;
  *(_DWORD *)pszFile = 7143523;
  v6 = 7864421;
  v7 = 101;
  if ( !SHGetSpecialFolderPathW(0, pszPath, 37, 0) )
    return 0;
  PathCombineW(pszDest, pszPath, pszFile);
  return ShellExecuteW(0, L"open", pszDest, a1, a1, 5);
}

//----- (004693F0) --------------------------------------------------------
LRESULT __usercall sub_4693F0@<eax>(HWND a1@<edi>, LPARAM *a2@<esi>)
{
  LPARAM v3; // edx
  LPARAM v4; // edx
  LPARAM v5; // eax
  WPARAM v6; // eax
  LPARAM v7; // edx
  LPARAM v8; // eax
  LRESULT v9; // eax
  int v10; // eax
  LRESULT v11; // [esp+4h] [ebp-5Ch]
  int v12; // [esp+4h] [ebp-5Ch]
  int v13; // [esp+8h] [ebp-58h]
  LRESULT v14; // [esp+Ch] [ebp-54h]
  LPARAM v15[3]; // [esp+10h] [ebp-50h] BYREF
  LPARAM v16; // [esp+1Ch] [ebp-44h]
  LPARAM v17; // [esp+20h] [ebp-40h]
  int v18; // [esp+24h] [ebp-3Ch]
  LPARAM v19[2]; // [esp+28h] [ebp-38h] BYREF
  int v20; // [esp+30h] [ebp-30h]
  LPARAM v21; // [esp+34h] [ebp-2Ch]
  LPARAM lParam; // [esp+38h] [ebp-28h] BYREF
  int v23; // [esp+3Ch] [ebp-24h]
  int v24; // [esp+40h] [ebp-20h]
  LPARAM v25[2]; // [esp+48h] [ebp-18h] BYREF
  char v26; // [esp+50h] [ebp-10h]
  WPARAM wParam; // [esp+54h] [ebp-Ch]

  if ( !a2 )
  {
    lParam = 16;
    v23 = 0;
    v24 = -1;
    return SendMessageW(a1, 0x10A6u, 0, (LPARAM)&lParam);
  }
  v3 = a2[1];
  v25[0] = *a2;
  v25[1] = v3;
  v11 = SendMessageW(a1, 0x1012u, 0, (LPARAM)v25);
  if ( v11 == -1 || (v26 & 0xE) == 0 )
  {
    v4 = *a2;
    v5 = a2[1];
    v12 = 0;
    v15[0] = 64;
    v16 = v4;
    v17 = v5;
    v18 = 38;
    v6 = SendMessageW(a1, 0x1053u, 0xFFFFFFFF, (LPARAM)v15);
    v13 = v6;
    if ( v6 == -1 )
    {
      v7 = *a2;
      v8 = a2[1];
      v15[0] = 64;
      v16 = v7;
      v17 = v8;
      v18 = 37;
      v6 = SendMessageW(a1, 0x1053u, 0xFFFFFFFF, (LPARAM)v15);
      v13 = v6;
    }
    v19[0] = 0;
    SendMessageW(a1, 0x100Eu, v6, (LPARAM)v19);
    if ( *a2 > v19[0] + (v20 - v19[0]) / 2 )
    {
      if ( a2[1] > v21 )
      {
        v9 = SendMessageW(a1, 0x100Cu, v13, 512);
        if ( v9 != -1 )
          v13 = v9;
      }
      v12 = 1;
    }
    v14 = SendMessageW(a1, 0x1004u, 0, 0);
    v19[0] = 0;
    SendMessageW(a1, 0x100Eu, v14 - 1, (LPARAM)v19);
    v10 = (v20 - v19[0]) / 2;
    if ( *a2 <= v10 + v19[0] || *a2 >= v10 + v20 + 2 || a2[1] <= v19[1] )
      goto LABEL_20;
    v13 = v14 - 1;
    goto LABEL_19;
  }
  v19[0] = 0;
  SendMessageW(a1, 0x100Eu, wParam, (LPARAM)v19);
  if ( *a2 - v19[0] > (v20 - v19[0]) / 2 )
  {
    v13 = v11;
LABEL_19:
    v12 = 1;
    goto LABEL_20;
  }
  v13 = v11;
  v12 = 0;
LABEL_20:
  lParam = 16;
  v23 = v12;
  v24 = v13;
  return SendMessageW(a1, 0x10A6u, 0, (LPARAM)&lParam);
}

//----- (00469690) --------------------------------------------------------
int __usercall sub_469690@<eax>(HWND a1@<edi>)
{
  signed int v1; // esi
  LRESULT v3; // eax
  LPARAM lParam[3]; // [esp+4h] [ebp-3Ch] BYREF
  int v5; // [esp+10h] [ebp-30h]
  int v6; // [esp+14h] [ebp-2Ch]
  LRESULT v7; // [esp+38h] [ebp-8h]
  int v8; // [esp+3Ch] [ebp-4h]

  v1 = 0;
  v8 = 0;
  if ( !a1 )
    return -1;
  v7 = SendMessageW(a1, 0x1004u, 0, 0);
  if ( v7 > 0 )
  {
    do
    {
      v3 = SendMessageW(a1, 0x102Cu, v1, 2);
      v6 = 2;
      if ( v3 == 2 )
      {
        v5 = 0;
        SendMessageW(a1, 0x102Bu, v1, (LPARAM)lParam);
      }
      else
      {
        v5 = 2;
        SendMessageW(a1, 0x102Bu, v1, (LPARAM)lParam);
        ++v8;
      }
      ++v1;
    }
    while ( v1 < v7 );
  }
  return v8;
}

//----- (00469710) --------------------------------------------------------
int __usercall sub_469710@<eax>(HWND a1@<esi>)
{
  LPARAM lParam[13]; // [esp+0h] [ebp-34h] BYREF

  if ( !a1 )
    return -1;
  SendMessageW(a1, 0xBu, 0, 0);
  lParam[4] = 2;
  lParam[3] = 0;
  SendMessageW(a1, 0x102Bu, 0xFFFFFFFF, (LPARAM)lParam);
  SendMessageW(a1, 0xBu, 1u, 0);
  return 0;
}

//----- (00469760) --------------------------------------------------------
int __usercall sub_469760@<eax>(HWND a1@<esi>)
{
  LPARAM lParam[13]; // [esp+0h] [ebp-34h] BYREF

  if ( !a1 )
    return -1;
  SendMessageW(a1, 0xBu, 0, 0);
  lParam[4] = 2;
  lParam[3] = 2;
  SendMessageW(a1, 0x102Bu, 0xFFFFFFFF, (LPARAM)lParam);
  SendMessageW(a1, 0xBu, 1u, 0);
  return 0;
}

//----- (004697F0) --------------------------------------------------------
BOOL __usercall sub_4697F0@<eax>(HWND a1@<edi>, HWND a2@<esi>)
{
  struct tagPOINT Points; // [esp+8h] [ebp-30h] BYREF
  int v4; // [esp+10h] [ebp-28h]
  struct tagRECT v5; // [esp+14h] [ebp-24h] BYREF
  struct tagRECT Rect; // [esp+24h] [ebp-14h] BYREF

  GetClientRect(a2, &Rect);
  GetClientRect(a1, &v5);
  Points.x = (v5.left + Rect.right - v5.right - Rect.left) / 2;
  v4 = Rect.bottom + v5.top - v5.bottom - Rect.top;
  Points.y = (int)((double)v4 * 0.45);
  MapWindowPoints(a2, 0, &Points, 1u);
  return SetWindowPos(a1, 0, Points.x, Points.y, 0, 0, 0x45u);
}

//----- (004698A0) --------------------------------------------------------
int __cdecl sub_4698A0(_BYTE *a1)
{
  int v17[16]; // [esp+18h] [ebp-44h] BYREF

  _EAX = -2147483646;
  __asm { cpuid }
  v17[0] = _EAX;
  v17[2] = _ECX;
  v17[3] = _EDX;
  v17[1] = _EBX;
  _EAX = -2147483645;
  __asm { cpuid }
  v17[4] = _EAX;
  v17[5] = _EBX;
  v17[6] = _ECX;
  v17[7] = _EDX;
  _EAX = -2147483644;
  __asm { cpuid }
  v17[8] = _EAX;
  v17[9] = _EBX;
  v17[10] = _ECX;
  v17[11] = _EDX;
  return sub_467E40(a1, (int)v17);
}

//----- (00469970) --------------------------------------------------------
HRESULT __usercall sub_469970@<eax>(const ITEMIDLIST *a1@<edx>, int a2@<esi>, _WORD *a3)
{
  HRESULT result; // eax
  int v4; // esi
  int v5; // [esp+4h] [ebp-10h] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+8h] [ebp-Ch] BYREF
  void *ppv; // [esp+Ch] [ebp-8h] BYREF
  int v8; // [esp+10h] [ebp-4h] BYREF

  ppv = 0;
  v8 = 0;
  ppidlLast = 0;
  v5 = 0;
  result = SHBindToParent(a1, &stru_4BD7FC, &ppv, &ppidlLast);
  if ( result >= 0 )
  {
    v4 = (*(int (__stdcall **)(void *, _DWORD, int, LPCITEMIDLIST *, void *, _DWORD, int *, int))(*(_DWORD *)ppv + 40))(
           ppv,
           0,
           1,
           &ppidlLast,
           &unk_4BD83C,
           0,
           &v8,
           a2);
    if ( v4 >= 0 )
    {
      v4 = (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v8 + 12))(v8, 1, &v5);
      if ( v4 >= 0 )
        sub_4A96F0(1024, v5, a3);
      (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
    }
    (*(void (__cdecl **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    return v4;
  }
  return result;
}

//----- (00469A10) --------------------------------------------------------
HRESULT __usercall sub_469A10@<eax>(int a1@<edi>, int a2@<esi>, _WORD *a3)
{
  HRESULT result; // eax
  HRESULT v4; // esi
  LPVOID pv; // [esp+4h] [ebp-4h] BYREF

  pv = 0;
  result = sub_467810((LPITEMIDLIST *)&pv, a1);
  if ( result >= 0 )
  {
    v4 = sub_469970((const ITEMIDLIST *)pv, a2, a3);
    CoTaskMemFree(pv);
    return v4;
  }
  return result;
}
// 469A10: could not find valid save-restore pair for esi

//----- (00469A50) --------------------------------------------------------
BOOL __cdecl sub_469A50(LPCWSTR lpString, int a2, int a3)
{
  int v3; // edi
  wchar_t *v5; // eax
  int v6; // edx
  wchar_t v7; // cx
  WCHAR *v8; // esi
  wchar_t *Context; // [esp+10h] [ebp-408h] BYREF
  wchar_t String[512]; // [esp+14h] [ebp-404h] BYREF

  v3 = 0;
  if ( lstrlenW(lpString) <= 0 )
    return sub_468540(lpString, (const WCHAR *)a2, a3);
  while ( lpString[v3] != 58 )
  {
    if ( ++v3 >= lstrlenW(lpString) )
      return sub_468540(lpString, (const WCHAR *)a2, a3);
  }
  v5 = String;
  Context = 0;
  v6 = 512;
  while ( v6 != -2147483134 )
  {
    v7 = *(wchar_t *)((char *)v5 + (char *)lpString - (char *)String);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  v8 = wcstok_s(String, L":", &Context);
  PathRemoveBlanksW(v8);
  if ( !v8 )
    return 0;
  while ( !sub_468540(v8, (const WCHAR *)a2, a3) )
  {
    v8 = wcstok_s(Context, L":", &Context);
    PathRemoveBlanksW(v8);
    if ( !v8 )
      return 0;
  }
  return 1;
}
// 469AF0: conditional instruction was optimized away because edx.4!=0

//----- (00469B90) --------------------------------------------------------
int __usercall sub_469B90@<eax>(int a1@<ecx>, HWND a2@<edi>)
{
  LPARAM lParam[6]; // [esp+8h] [ebp-430h] BYREF
  __int16 v5[260]; // [esp+20h] [ebp-418h] BYREF
  WCHAR Filename[262]; // [esp+228h] [ebp-210h] BYREF

  if ( !a2 )
    return -2147024809;
  GetModuleFileNameW(0, Filename, 0x104u);
  lParam[0] = 2;
  sub_401000(0x104u, (wchar_t *)v5, L"res://%s/#2/#%d", Filename, a1);
  lParam[2] = a1 != 0 ? (unsigned int)v5 : 0;
  lParam[4] = 45;
  lParam[5] = 50;
  return SendMessageW(a2, 0x108Au, 0, (LPARAM)lParam) != 0 ? 0 : -2147467259;
}
// 4C3598: using guessed type wchar_t aResS2D[16];
// 469B90: using guessed type wchar_t var_418[260];

//----- (00469C60) --------------------------------------------------------
int __cdecl sub_469C60(int a1, int a2)
{
  int v2; // ecx
  wchar_t *v3; // ebx
  char *v4; // eax
  int v5; // esi
  __int16 v6; // cx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  int ImageWidth; // eax
  int ImageHeight; // eax
  int PropertySize; // eax
  size_t v14; // ebx
  _DWORD *v15; // eax
  _DWORD *v16; // edi
  unsigned int v17; // ecx
  int AllPropertyItems; // eax
  unsigned int v19; // eax
  _DWORD *v20; // edx
  _DWORD *v21; // edx
  WCHAR *v22; // eax
  int v23; // eax
  int v24; // [esp-8h] [ebp-448h]
  int v25; // [esp-8h] [ebp-448h]
  const void *v26; // [esp-8h] [ebp-448h]
  size_t v27; // [esp-4h] [ebp-444h]
  int v28[4]; // [esp+Ch] [ebp-434h] BYREF
  int v29; // [esp+1Ch] [ebp-424h] BYREF
  size_t Size; // [esp+20h] [ebp-420h] BYREF
  unsigned int v31; // [esp+24h] [ebp-41Ch] BYREF
  int v32; // [esp+28h] [ebp-418h]
  WCHAR *v33; // [esp+2Ch] [ebp-414h] BYREF
  CHAR MultiByteStr[512]; // [esp+30h] [ebp-410h] BYREF
  char v35[524]; // [esp+230h] [ebp-210h] BYREF

  v3 = (wchar_t *)v2;
  v33 = (WCHAR *)v2;
  v28[0] = 1;
  memset(&v28[1], 0, 12);
  v32 = 0;
  GdiplusStartup(&v29, v28, 0);
  v4 = v35;
  v5 = 260;
  while ( v5 != -2147483386 )
  {
    v6 = *(_WORD *)&v4[a1 - (_DWORD)v35];
    if ( !v6 )
      break;
    *(_WORD *)v4 = v6;
    v4 += 2;
    if ( !--v5 )
    {
      v4 -= 2;
      break;
    }
  }
  *(_WORD *)v4 = 0;
  v7 = (_DWORD *)GdipAlloc(16);
  v8 = v7;
  if ( v7 )
  {
    v7[1] = 0;
    *v7 = &Gdiplus::Image::`vftable';
    v7[2] = GdipLoadImageFromFile(v35, v7 + 1);
  }
  else
  {
    v8 = 0;
  }
  v9 = v8[2];
  v8[2] = 0;
  if ( v9 )
  {
    (*(void (__thiscall **)(_DWORD *, int))*v8)(v8, 1);
    return 0;
  }
  if ( a2 == 256 )
  {
    v24 = v8[1];
    v33 = 0;
    ImageWidth = GdipGetImageWidth(v24, &v33);
    if ( ImageWidth )
      v8[2] = ImageWidth;
    v32 = 1;
    sub_401000(0x200u, v3, L"%u pixels", v33);
    goto LABEL_36;
  }
  if ( a2 == 257 )
  {
    v25 = v8[1];
    v33 = 0;
    ImageHeight = GdipGetImageHeight(v25, &v33);
    if ( ImageHeight )
      v8[2] = ImageHeight;
    v32 = 1;
    sub_401000(0x200u, v3, L"%u pixels", v33);
    goto LABEL_36;
  }
  PropertySize = GdipGetPropertySize(v8[1], &Size, &v31);
  if ( PropertySize )
    v8[2] = PropertySize;
  v14 = Size;
  v15 = malloc(Size);
  v16 = v15;
  if ( v15 )
  {
    AllPropertyItems = GdipGetAllPropertyItems(v8[1], v14, v31, v15);
    if ( AllPropertyItems )
    {
      v8[2] = AllPropertyItems;
      v17 = v31;
    }
    else
    {
      v17 = v31;
      v19 = 0;
      if ( v31 )
      {
        v20 = v16;
        while ( *v20 != a2 )
        {
          ++v19;
          v20 += 4;
          if ( v19 >= v31 )
            goto LABEL_29;
        }
        goto LABEL_37;
      }
    }
  }
  else
  {
    v8[2] = 2;
    v17 = v31;
  }
LABEL_29:
  if ( a2 == 36867 )
  {
    v19 = 0;
    if ( v17 )
    {
      v21 = v16;
      while ( *v21 != 306 )
      {
        ++v19;
        v21 += 4;
        if ( v19 >= v17 )
          goto LABEL_34;
      }
LABEL_37:
      v23 = 2 * v19;
      v27 = v16[2 * v23 + 1];
      v26 = (const void *)v16[2 * v23 + 3];
      v32 = 1;
      memcpy_0(MultiByteStr, v26, v27);
      v22 = v33;
      goto LABEL_35;
    }
  }
LABEL_34:
  v22 = 0;
LABEL_35:
  MultiByteToWideChar(0, 0, MultiByteStr, -1, v22, 512);
  free(v16);
LABEL_36:
  (*(void (__thiscall **)(_DWORD *, int))*v8)(v8, 1);
  GdiplusShutdown(v29);
  return v32;
}
// 469CF0: conditional instruction was optimized away because esi.4!=0
// 469C79: variable 'v2' is possibly undefined
// 4BD688: using guessed type int __stdcall GdiplusShutdown(_DWORD);
// 4BD68C: using guessed type int __stdcall GdipGetAllPropertyItems(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BD690: using guessed type int __stdcall GdipGetPropertySize(_DWORD, _DWORD, _DWORD);
// 4BD694: using guessed type int __stdcall GdipGetImageHeight(_DWORD, _DWORD);
// 4BD69C: using guessed type int __stdcall GdipGetImageWidth(_DWORD, _DWORD);
// 4BD6B4: using guessed type int __stdcall GdipLoadImageFromFile(_DWORD, _DWORD);
// 4BD6BC: using guessed type int __stdcall GdipAlloc(_DWORD);
// 4BD6C4: using guessed type int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD);
// 4C3470: using guessed type wchar_t aUPixels[10];
// 4C3484: using guessed type wchar_t aUPixels_0[10];
// 4CC06C: using guessed type void *Gdiplus::Image::`vftable';

//----- (00469F20) --------------------------------------------------------
DWORD __cdecl sub_469F20(int a1, int a2)
{
  WCHAR *v2; // ecx
  HANDLE FileW; // eax
  void *v4; // esi
  void *v6; // edi
  const WCHAR *v7; // ebx
  char v8[4]; // [esp+Ch] [ebp-438h] BYREF
  char v9[4]; // [esp+10h] [ebp-434h] BYREF
  LPWSTR lpWideCharStr; // [esp+14h] [ebp-430h]
  int v11; // [esp+18h] [ebp-42Ch] BYREF
  int v12; // [esp+1Ch] [ebp-428h]
  unsigned int v13; // [esp+20h] [ebp-424h]
  UINT CodePage; // [esp+24h] [ebp-420h] BYREF
  unsigned int v15; // [esp+28h] [ebp-41Ch] BYREF
  int v16; // [esp+2Ch] [ebp-418h] BYREF
  int v17; // [esp+30h] [ebp-414h] BYREF
  LONG Buffer; // [esp+34h] [ebp-410h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+38h] [ebp-40Ch] BYREF
  DWORD NumberOfBytesRead; // [esp+3Ch] [ebp-408h] BYREF
  WCHAR FileName[512]; // [esp+40h] [ebp-404h] BYREF

  lpWideCharStr = v2;
  v16 = 0;
  v17 = 0;
  CodePage = 0;
  v12 = 0;
  sub_401000(0x200u, FileName, L"%s:%cSummaryInformation", a1, 5);
  FileW = CreateFileW(FileName, 0x80000000, 1u, 0, 3u, 0, 0);
  v4 = FileW;
  if ( FileW == (HANDLE)-1 )
    return -1;
  SetFilePointer(FileW, 44, 0, 1u);
  ReadFile(v4, &Buffer, 4u, &NumberOfBytesRead, 0);
  SetFilePointer(v4, Buffer, 0, 0);
  ReadFile(v4, v8, 4u, &NumberOfBytesRead, 0);
  ReadFile(v4, &v15, 4u, &NumberOfBytesRead, 0);
  v13 = 0;
  if ( !v15 )
    goto LABEL_10;
  do
  {
    ReadFile(v4, &v11, 4u, &NumberOfBytesRead, 0);
    if ( v11 == 1 )
    {
      ReadFile(v4, &v17, 4u, &NumberOfBytesRead, 0);
    }
    else if ( v11 == a2 )
    {
      v12 = 1;
      ReadFile(v4, &v16, 4u, &NumberOfBytesRead, 0);
    }
    else
    {
      SetFilePointer(v4, 4, 0, 1u);
    }
    ++v13;
  }
  while ( v13 < v15 );
  if ( !v12 )
    goto LABEL_10;
  if ( v17 )
  {
    SetFilePointer(v4, Buffer + v17 + 4, 0, 0);
    ReadFile(v4, &CodePage, 4u, &NumberOfBytesRead, 0);
  }
  SetFilePointer(v4, v16 + Buffer, 0, 0);
  ReadFile(v4, v9, 4u, &NumberOfBytesRead, 0);
  ReadFile(v4, &nNumberOfBytesToRead, 4u, &NumberOfBytesRead, 0);
  v6 = malloc(nNumberOfBytesToRead);
  ReadFile(v4, v6, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
  {
LABEL_10:
    CloseHandle(v4);
    return -1;
  }
  v7 = lpWideCharStr;
  MultiByteToWideChar(CodePage, 1u, (LPCCH)v6, nNumberOfBytesToRead, lpWideCharStr, 512);
  nNumberOfBytesToRead = lstrlenW(v7) + 1;
  free(v6);
  CloseHandle(v4);
  return nNumberOfBytesToRead;
}
// 469F3E: variable 'v2' is possibly undefined
// 4C3410: using guessed type wchar_t aSCsummaryinfor[24];
// 469F20: using guessed type char var_438[4];
// 469F20: using guessed type char var_434[4];

//----- (0046A1B0) --------------------------------------------------------
int __usercall sub_46A1B0@<eax>(const WCHAR *a1@<edx>, _WORD *a2@<ecx>, int a3)
{
  DWORD FileVersionInfoSizeW; // eax
  DWORD v5; // esi
  void *v6; // eax
  void *v7; // edi
  __int16 v8; // bx
  int v9; // esi
  unsigned __int16 *v10; // ecx
  int v11; // eax
  unsigned int v13; // [esp+Ch] [ebp-A4h] BYREF
  int v14; // [esp+10h] [ebp-A0h]
  DWORD dwHandle; // [esp+14h] [ebp-9Ch] BYREF
  _WORD *v16; // [esp+18h] [ebp-98h]
  int v17; // [esp+1Ch] [ebp-94h]
  unsigned int puLen; // [esp+20h] [ebp-90h] BYREF
  LPVOID lpBuffer; // [esp+24h] [ebp-8Ch] BYREF
  int v20; // [esp+28h] [ebp-88h]
  WCHAR SubBlock[64]; // [esp+2Ch] [ebp-84h] BYREF

  v17 = a3;
  v16 = a2;
  lpBuffer = 0;
  dwHandle = 0;
  v20 = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(a1, &dwHandle);
  v5 = FileVersionInfoSizeW;
  if ( !FileVersionInfoSizeW )
    return 0;
  v6 = malloc(FileVersionInfoSizeW);
  v7 = v6;
  if ( v6 )
  {
    if ( GetFileVersionInfoW(a1, 0, v5, v6) )
    {
      LOBYTE(v8) = GetUserDefaultLangID();
      VerQueryValueW(v7, L"\\VarFileInfo\\Translation", &::lpBuffer, &puLen);
      v9 = 0;
      if ( (puLen & 0xFFFFFFFC) != 0 )
      {
        v10 = (unsigned __int16 *)::lpBuffer;
        v8 = (unsigned __int8)v8;
        v14 = (unsigned __int8)v8;
        while ( 1 )
        {
          v11 = v10[2 * v9];
          if ( (unsigned __int8)v11 == v8 || !(_WORD)v11 )
          {
            sub_401000(0x40u, SubBlock, L"\\StringFileInfo\\%04X%04X\\%s", v11, v10[2 * v9 + 1], v17);
            if ( VerQueryValueW(v7, SubBlock, &lpBuffer, &v13) && lpBuffer )
            {
              sub_4A96F0(512, (int)lpBuffer, v16);
              v20 = 1;
              break;
            }
            v10 = (unsigned __int16 *)::lpBuffer;
            v8 = v14;
          }
          if ( ++v9 >= puLen >> 2 )
          {
            free(v7);
            return v20;
          }
        }
      }
    }
    free(v7);
  }
  return v20;
}
// 4C33D8: using guessed type wchar_t aStringfileinfo[28];

//----- (0046A360) --------------------------------------------------------
int __thiscall sub_46A360(wchar_t *this)
{
  int v1; // esi
  DWORD CurrentProcessId; // eax
  HANDLE v4; // edi
  PSID *v5; // edi
  DWORD v7; // [esp+Ch] [ebp-824h] BYREF
  enum _SID_NAME_USE peUse; // [esp+10h] [ebp-820h] BYREF
  DWORD cchName; // [esp+14h] [ebp-81Ch] BYREF
  DWORD cchReferencedDomainName; // [esp+18h] [ebp-818h] BYREF
  HANDLE v11; // [esp+1Ch] [ebp-814h]
  HANDLE TokenHandle; // [esp+20h] [ebp-810h] BYREF
  LPWSTR StringSid; // [esp+24h] [ebp-80Ch] BYREF
  DWORD ReturnLength; // [esp+28h] [ebp-808h] BYREF
  WCHAR Name[512]; // [esp+2Ch] [ebp-804h] BYREF
  WCHAR ReferencedDomainName[512]; // [esp+42Ch] [ebp-404h] BYREF

  v1 = 0;
  cchName = 512;
  cchReferencedDomainName = 512;
  ReturnLength = 0;
  CurrentProcessId = GetCurrentProcessId();
  v4 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v11 = v4;
  if ( !v4 )
    goto LABEL_12;
  if ( !OpenProcessToken(v4, 0xF01FFu, &TokenHandle) )
    goto LABEL_11;
  GetTokenInformation(TokenHandle, TokenUser, 0, 0, &ReturnLength);
  v5 = (PSID *)GlobalAlloc(0, ReturnLength);
  if ( v5 )
  {
    GetTokenInformation(TokenHandle, TokenUser, v5, ReturnLength, &v7);
    if ( LookupAccountSidW(0, *v5, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      sub_401000(0x200u, this, L"%s\\%s", ReferencedDomainName, Name);
    }
    else
    {
      if ( !ConvertSidToStringSidW(*v5, &StringSid) )
      {
LABEL_9:
        GlobalFree(v5);
        goto LABEL_10;
      }
      sub_4011B0(0x200u, (int)StringSid, this);
      LocalFree(StringSid);
    }
    v1 = 1;
    goto LABEL_9;
  }
LABEL_10:
  v4 = v11;
LABEL_11:
  CloseHandle(v4);
  if ( !v1 )
LABEL_12:
    sub_4A96F0(512, (int)&unk_4C33A0, this);
  return v1;
}
// 4C3394: using guessed type wchar_t aSS_1[6];

//----- (0046A4F0) --------------------------------------------------------
int __cdecl sub_46A4F0(int a1)
{
  const WCHAR *v1; // ecx
  const WCHAR *v2; // ebx
  int v3; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // eax
  void *v6; // esi
  HANDLE FileW; // esi
  WCHAR *v9; // ecx
  DWORD v10; // eax
  LPWSTR StringSid; // [esp+10h] [ebp-840h] BYREF
  PSID ppsidOwner; // [esp+14h] [ebp-83Ch] BYREF
  wchar_t *v13; // [esp+18h] [ebp-838h]
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [esp+1Ch] [ebp-834h] BYREF
  DWORD cchReferencedDomainName; // [esp+20h] [ebp-830h] BYREF
  HANDLE TokenHandle; // [esp+24h] [ebp-82Ch] BYREF
  DWORD cchName; // [esp+28h] [ebp-828h] BYREF
  struct _LUID Luid; // [esp+2Ch] [ebp-824h] BYREF
  enum _SID_NAME_USE peUse; // [esp+34h] [ebp-81Ch] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+38h] [ebp-818h] BYREF
  WCHAR Name[512]; // [esp+48h] [ebp-808h] BYREF
  WCHAR ReferencedDomainName[514]; // [esp+448h] [ebp-408h] BYREF

  v13 = (wchar_t *)a1;
  v2 = v1;
  cchName = 512;
  cchReferencedDomainName = 512;
  v3 = 0;
  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v6 = v5;
  if ( !v5 )
    return 0;
  OpenProcessToken(v5, 0xF01FFu, &TokenHandle);
  LookupPrivilegeValueW(0, L"SeSecurityPrivilege", &Luid);
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Luid = Luid;
  NewState.Privileges[0].Attributes = 2;
  CloseHandle(v6);
  if ( !AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0) )
    return 0;
  FileW = CreateFileW(v2, 0x1020000u, 1u, 0, 3u, 0x2000000u, 0);
  if ( FileW != (HANDLE)-1 )
  {
    ppsidOwner = GlobalAlloc(0, 4u);
    ppSecurityDescriptor = GlobalAlloc(0, 4u);
    if ( GetSecurityInfo(FileW, SE_FILE_OBJECT, 1u, &ppsidOwner, 0, 0, 0, &ppSecurityDescriptor) )
    {
      CloseHandle(FileW);
      return 0;
    }
    if ( LookupAccountSidW(0, ppsidOwner, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      sub_401000(0x200u, v13, L"%s\\%s", ReferencedDomainName, Name);
      v9 = Name;
    }
    else
    {
      if ( !ConvertSidToStringSidW(ppsidOwner, &StringSid) )
      {
LABEL_12:
        LocalFree(&ppSecurityDescriptor);
        CloseHandle(FileW);
        goto LABEL_13;
      }
      sub_4011B0(0x200u, (int)StringSid, v13);
      LocalFree(StringSid);
      v9 = StringSid;
    }
    v3 = lstrlenW(v9);
    goto LABEL_12;
  }
LABEL_13:
  v10 = GetCurrentProcessId();
  sub_4691C0(0, L"SeSecurityPrivilege", v10);
  return v3;
}
// 46A519: variable 'v1' is possibly undefined
// 4C3360: using guessed type wchar_t aSS_2[6];
// 4C336C: using guessed type wchar_t aSesecuritypriv_0[20];

//----- (0046A6F0) --------------------------------------------------------
int __usercall sub_46A6F0@<eax>(__int16 a1@<dx>, _WORD *a2@<ecx>, unsigned int a3)
{
  int result; // eax
  __int16 v4; // si
  __int16 v5; // si
  __int16 v6; // si
  __int16 v7; // si
  __int16 v8; // si
  __int16 v9; // si
  bool v10; // zf
  __int16 v11; // dx
  __int16 v12[8]; // [esp+4h] [ebp-14h] BYREF

  result = a3;
  v4 = 65;
  if ( (a1 & 0x20) == 0 )
    v4 = 45;
  v12[0] = v4;
  v5 = 72;
  if ( (a1 & 2) == 0 )
    v5 = 45;
  v12[1] = v5;
  v6 = 82;
  if ( (a1 & 1) == 0 )
    v6 = 45;
  v12[2] = v6;
  v7 = 83;
  if ( (a1 & 4) == 0 )
    v7 = 45;
  v12[3] = v7;
  v8 = 68;
  if ( (a1 & 0x10) == 0 )
    v8 = 45;
  v12[4] = v8;
  v9 = 67;
  if ( (a1 & 0x800) == 0 )
    v9 = 45;
  v12[5] = v9;
  v10 = (a1 & 0x4000) == 0;
  v11 = 69;
  if ( v10 )
    v11 = 45;
  v12[6] = v11;
  v12[7] = 0;
  if ( a3 )
  {
    if ( a3 <= 0x7FFFFFFF )
      return sub_4A96F0(a3, (int)v12, a2);
  }
  return result;
}

//----- (0046A7C0) --------------------------------------------------------
DWORD __usercall sub_46A7C0@<eax>(_WORD *a1@<edi>, LPCWSTR lpFileName)
{
  HANDLE FirstFileW; // esi
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-25Ch] BYREF

  FirstFileW = FindFirstFileW(lpFileName, &FindFileData);
  if ( FirstFileW == (HANDLE)-1 )
  {
    sub_4A96F0(32, (int)&unk_4C3334, a1);
    return 0;
  }
  else
  {
    sub_46A6F0(FindFileData.dwFileAttributes, a1, 0x20u);
    FindClose(FirstFileW);
    return FindFileData.dwFileAttributes;
  }
}

//----- (0046A840) --------------------------------------------------------
wchar_t *__cdecl sub_46A840(unsigned int a1, int a2)
{
  __int16 *v2; // edi
  unsigned int v3; // ecx
  unsigned int v4; // esi
  unsigned __int64 v5; // kr00_8
  int v6; // ebx
  unsigned __int64 v8; // rax

  v2 = &word_4F0332;
  v5 = (unsigned __int64)(pow(2.0, 32.0) * (double)a2 + (double)a1);
  v3 = HIDWORD(v5);
  v4 = v5;
  v6 = 0;
  if ( v5 )
  {
    word_4F0332 = 0;
    do
    {
      if ( !(v6 % 3) )
      {
        if ( v6 )
          *--v2 = 44;
      }
      --v2;
      v8 = __PAIR64__(v3, v4) / 0xA;
      v3 = (__PAIR64__(v3, v4) / 0xA) >> 32;
      *v2 = v4 - 10 * v8 + 48;
      v4 = v8;
      ++v6;
    }
    while ( __PAIR64__(v3, v8) );
    return (wchar_t *)v2;
  }
  else
  {
    sub_401000(0xEu, word_4F0318, L"%d", 0);
    return word_4F0318;
  }
}
// 4C332C: using guessed type wchar_t aD_0[3];
// 4F0318: using guessed type wchar_t word_4F0318[13];
// 4F0332: using guessed type __int16 word_4F0332;

//----- (0046A930) --------------------------------------------------------
int __thiscall sub_46A930(LPCWSTR lpFileName)
{
  int result; // eax
  void *v3; // ebx
  signed int FileSize; // edi
  WCHAR *v5; // eax
  int v6; // edx
  int v7; // esi
  WCHAR v8; // cx
  signed int i; // eax
  DWORD BytesPerSector; // [esp+4h] [ebp-214h] BYREF
  int v11; // [esp+8h] [ebp-210h]
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  v11 = 0;
  if ( !lpFileName )
    return -1;
  result = (int)CreateFileW(lpFileName, 0x80000000, 3u, 0, 3u, 0, 0);
  v3 = (void *)result;
  if ( result != -1 )
  {
    FileSize = GetFileSize((HANDLE)result, 0);
    v5 = pszPath;
    v6 = 260;
    v7 = (char *)lpFileName - (char *)pszPath;
    while ( v6 != -2147483386 )
    {
      v8 = *(WCHAR *)((char *)v5 + v7);
      if ( !v8 )
        break;
      *v5++ = v8;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    *v5 = 0;
    PathStripToRootW(pszPath);
    GetDiskFreeSpaceW(pszPath, 0, &BytesPerSector, 0, 0);
    for ( i = 0; i < FileSize; i += BytesPerSector )
      ++v11;
    CloseHandle(v3);
    return v11;
  }
  return result;
}
// 46A9D1: conditional instruction was optimized away because edx.4!=0

//----- (0046AA40) --------------------------------------------------------
int __usercall sub_46AA40@<eax>(char *a1@<ecx>, LARGE_INTEGER *a2@<ebx>)
{
  char *v2; // esi
  char *v3; // eax
  HANDLE FileW; // edi
  LARGE_INTEGER v6; // kr00_8
  WCHAR *v7; // eax
  int v8; // edx
  int v9; // esi
  WCHAR v10; // cx
  LONGLONG v11; // rax
  LARGE_INTEGER FileSize; // [esp+8h] [ebp-228h] BYREF
  DWORD SectorsPerCluster; // [esp+14h] [ebp-21Ch] BYREF
  DWORD BytesPerSector; // [esp+18h] [ebp-218h] BYREF
  HANDLE v15; // [esp+1Ch] [ebp-214h]
  WCHAR pszPath[262]; // [esp+20h] [ebp-210h] BYREF

  v2 = a1;
  if ( *((_DWORD *)a1 + 5) < 8u )
    v3 = a1;
  else
    v3 = *(char **)a1;
  FileW = CreateFileW((LPCWSTR)v3, 0x80000000, 3u, 0, 3u, 0, 0);
  v15 = FileW;
  if ( FileW == (HANDLE)-1 )
    return 0;
  GetFileSizeEx(FileW, &FileSize);
  v6 = FileSize;
  *a2 = FileSize;
  if ( v6.QuadPart )
  {
    if ( *((_DWORD *)v2 + 5) >= 8u )
      v2 = *(char **)v2;
    v7 = pszPath;
    v8 = 260;
    v9 = v2 - (char *)pszPath;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v7 + v9);
      if ( !v10 )
        break;
      *v7++ = v10;
      if ( !--v8 )
      {
        --v7;
        break;
      }
    }
    *v7 = 0;
    PathStripToRootW(pszPath);
    GetDiskFreeSpaceW(pszPath, &SectorsPerCluster, &BytesPerSector, 0, 0);
    v11 = a2->QuadPart % (int)(BytesPerSector * SectorsPerCluster);
    if ( v11 )
      a2->QuadPart += (int)(BytesPerSector * SectorsPerCluster) - v11;
    FileW = v15;
  }
  CloseHandle(FileW);
  return 1;
}
// 46AAF6: conditional instruction was optimized away because edx.4!=0

//----- (0046AB90) --------------------------------------------------------
int __usercall sub_46AB90@<eax>(_WORD *a1@<ecx>, int a2@<edi>, FILETIME *lpFileTime, int a4)
{
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  int DateFormatW; // esi
  WCHAR *v8; // eax
  int v9; // edx
  WCHAR v10; // cx
  int TimeFormatW; // eax
  struct _FILETIME LocalFileTime; // [esp+Ch] [ebp-C34h] BYREF
  _WORD *v14; // [esp+14h] [ebp-C2Ch]
  struct _SYSTEMTIME v15; // [esp+18h] [ebp-C28h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+28h] [ebp-C18h] BYREF
  WCHAR TimeStr[512]; // [esp+38h] [ebp-C08h] BYREF
  WCHAR String[512]; // [esp+438h] [ebp-808h] BYREF
  WCHAR DateStr[514]; // [esp+838h] [ebp-408h] BYREF

  v14 = a1;
  if ( !lpFileTime )
    return -1;
  FileTimeToLocalFileTime(lpFileTime, &LocalFileTime);
  FileTimeToSystemTime(&LocalFileTime, &SystemTime);
  GetLocalTime(&v15);
  if ( !a4 || v15.wYear != SystemTime.wYear || v15.wMonth != SystemTime.wMonth )
    goto LABEL_19;
  if ( v15.wDay == SystemTime.wDay )
  {
    v4 = DateStr;
    v5 = 512;
    while ( v5 != -2147483134 )
    {
      v6 = *(WCHAR *)((char *)v4 + (char *)L"Today" - (char *)DateStr);
      if ( !v6 )
        break;
      *v4++ = v6;
      if ( !--v5 )
      {
        *(v4 - 1) = 0;
        DateFormatW = 1;
        goto LABEL_20;
      }
    }
    *v4 = 0;
    DateFormatW = 1;
    goto LABEL_20;
  }
  v8 = DateStr;
  if ( v15.wDay != SystemTime.wDay + 1 )
  {
LABEL_19:
    DateFormatW = GetDateFormatW(0x400u, 0x40000000u, &SystemTime, 0, DateStr, 512);
    goto LABEL_20;
  }
  v9 = 512;
  while ( v9 != -2147483134 )
  {
    v10 = *(WCHAR *)((char *)v8 + (char *)L"Yesterday" - (char *)DateStr);
    if ( !v10 )
      break;
    *v8++ = v10;
    if ( !--v9 )
    {
      *(v8 - 1) = 0;
      DateFormatW = 1;
      goto LABEL_20;
    }
  }
  *v8 = 0;
  DateFormatW = 1;
LABEL_20:
  TimeFormatW = GetTimeFormatW(0x400u, 0x40000000u, &SystemTime, 0, TimeStr, 512);
  if ( !DateFormatW || !TimeFormatW )
    return -1;
  sub_401000(0x200u, String, L"%s, %s", DateStr, TimeStr);
  if ( a2 >= lstrlenW(String) + 1 && a2 && (unsigned int)a2 <= 0x7FFFFFFF )
    sub_4A96F0(a2, (int)String, v14);
  return lstrlenW(String) + 1;
}
// 46AC6C: conditional instruction was optimized away because edx.4!=0
// 46ACC9: conditional instruction was optimized away because edx.4!=0
// 4C32C8: using guessed type wchar_t aToday_0[6];
// 4C32D4: using guessed type wchar_t aYesterday_0[10];
// 4C32E8: using guessed type wchar_t aSS_3[7];

//----- (0046AE30) --------------------------------------------------------
int __usercall sub_46AE30@<eax>(int a1@<ecx>, const WCHAR *a2@<ebx>, _WORD *a3)
{
  int v3; // esi
  int v4; // edi
  unsigned int v5; // edx
  int v6; // eax
  __int16 *v7; // ecx
  int v8; // edx
  __int16 *v9; // eax
  unsigned int v10; // edx
  int v11; // eax
  __int16 *i; // ecx
  int v15; // [esp+10h] [ebp-808h]
  __int16 v16[1024]; // [esp+14h] [ebp-804h] BYREF

  v3 = 0;
  v16[0] = 0;
  v4 = 0;
  if ( lstrlenW(a2) > 0 )
  {
    v15 = 1;
    do
    {
      if ( a2[v15 - 1] == 38 )
      {
        v5 = v4 - v3;
        v6 = 1024;
        v7 = v16;
        while ( *v7 )
        {
          ++v7;
          if ( !--v6 )
            goto LABEL_10;
        }
        if ( v5 <= 0x7FFFFFFE )
          sub_467DC0(v6, v5, &v16[1024 - v6], (int)&a2[v3]);
LABEL_10:
        v8 = 1024;
        v9 = v16;
        while ( *v9 )
        {
          ++v9;
          if ( !--v8 )
            goto LABEL_15;
        }
        sub_4AA520(v8, a1, &v16[1024 - v8]);
LABEL_15:
        v3 = v4 + 1;
      }
      ++v15;
      ++v4;
    }
    while ( v4 < lstrlenW(a2) );
  }
  v10 = v4 - v3;
  v11 = 1024;
  for ( i = v16; *i; ++i )
  {
    if ( !--v11 )
      return sub_4A96F0(260, (int)v16, a3);
  }
  if ( v10 <= 0x7FFFFFFE )
    sub_467DC0(v11, v10, &v16[1024 - v11], (int)&a2[v3]);
  return sub_4A96F0(260, (int)v16, a3);
}
// 46AEB1: conditional instruction was optimized away because eax.4!=0
// 46AEF4: conditional instruction was optimized away because edx.4!=0
// 46AF50: conditional instruction was optimized away because eax.4!=0
// 46AE30: using guessed type __int16 var_804[1024];

//----- (0046AFA0) --------------------------------------------------------
void __usercall sub_46AFA0(HWND a1@<ebx>, _DWORD *a2)
{
  int v2; // edi
  WCHAR *v3; // esi
  WCHAR *v4; // eax
  HWND v6; // [esp+0h] [ebp-Ch]

  v2 = GetWindowTextLengthW(v6) + 1;
  v3 = (WCHAR *)operator new[](2 * v2);
  GetWindowTextW(a1, v3, v2);
  v4 = v3;
  while ( *v4++ )
    ;
  sub_4094F0(a2, (int)(v3 + 1), v3, v4 - (v3 + 1));
  operator delete[](v3);
}
// 46AFA6: variable 'v6' is possibly undefined

//----- (0046B010) --------------------------------------------------------
DWORD __cdecl sub_46B010(int a1)
{
  WCHAR *v1; // ecx
  WCHAR *v2; // ebx
  DWORD CurrentProcessId; // eax
  HANDLE v4; // eax
  void *v5; // esi
  HANDLE FileW; // esi
  WCHAR *v8; // eax
  int v9; // edx
  WCHAR v10; // cx
  LONG HighPart; // ebx
  DWORD LowPart; // edi
  int v13; // ebx
  size_t v14; // ebx
  void *v15; // eax
  const void *v16; // edi
  LONG v17; // edi
  const WCHAR *lpFileName; // [esp+14h] [ebp-250h]
  DWORD NumberOfBytesRead; // [esp+18h] [ebp-24Ch] BYREF
  LONG lDistanceToMove; // [esp+1Ch] [ebp-248h]
  struct _LUID Luid; // [esp+20h] [ebp-244h] BYREF
  DWORD BytesPerSector; // [esp+2Ch] [ebp-238h] BYREF
  HANDLE TokenHandle; // [esp+30h] [ebp-234h] BYREF
  void *v24[3]; // [esp+34h] [ebp-230h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+40h] [ebp-224h] BYREF
  WCHAR pszPath[262]; // [esp+50h] [ebp-214h] BYREF

  v2 = v1;
  lpFileName = v1;
  NumberOfBytesRead = 0;
  CurrentProcessId = GetCurrentProcessId();
  v4 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v5 = v4;
  if ( v4 )
  {
    OpenProcessToken(v4, 0xF01FFu, &TokenHandle);
    LookupPrivilegeValueW(0, L"SeManageVolumePrivilege", &Luid);
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = Luid;
    NewState.Privileges[0].Attributes = 2;
    CloseHandle(v5);
    AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
  }
  if ( GetLastError() )
    return -1;
  FileW = CreateFileW(v2, 0xC0000000, 7u, 0, 3u, 0, 0);
  if ( FileW == (HANDLE)-1 )
    return -1;
  v8 = pszPath;
  v9 = 260;
  while ( v9 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)v8 + (char *)v2 - (char *)pszPath);
    if ( !v10 )
      break;
    *v8++ = v10;
    if ( !--v9 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathStripToRootW(pszPath);
  if ( GetDiskFreeSpaceW(pszPath, 0, &BytesPerSector, 0, 0) )
  {
    lDistanceToMove = GetFileSize(FileW, 0);
    sub_4095E0(v24, v2);
    sub_46AA40((char *)v24, (LARGE_INTEGER *)&Luid);
    if ( NewState.Privileges[0].Luid.HighPart >= 8u )
      operator delete(v24[0]);
    HighPart = Luid.HighPart;
    if ( Luid.HighPart >= 0 )
    {
      LowPart = Luid.LowPart;
      if ( *(__int64 *)&Luid > (unsigned int)lDistanceToMove )
      {
        TokenHandle = (HANDLE)sub_46A930(lpFileName);
        v13 = __SPAIR64__(HighPart, LowPart) / BytesPerSector - (_DWORD)TokenHandle;
        SetFilePointerEx(FileW, (LARGE_INTEGER)__PAIR64__(Luid.HighPart, LowPart), 0, 0);
        SetEndOfFile(FileW);
        SetFileValidData(FileW, __SPAIR64__(Luid.HighPart, LowPart));
        if ( BytesPerSector * (unsigned int)TokenHandle > lDistanceToMove )
        {
          SetFilePointer(FileW, BytesPerSector * (_DWORD)TokenHandle, 0, 0);
          v14 = BytesPerSector * v13;
          v15 = malloc(v14);
          v16 = v15;
          if ( v15 )
          {
            ReadFile(FileW, v15, v14, &NumberOfBytesRead, 0);
            memcpy_s((void *const)a1, 0x1000u, v16, NumberOfBytesRead);
          }
        }
        v17 = lDistanceToMove;
        SetFilePointer(FileW, lDistanceToMove, 0, 0);
        SetEndOfFile(FileW);
        SetFileValidData(FileW, (unsigned int)v17);
      }
    }
  }
  CloseHandle(FileW);
  return NumberOfBytesRead;
}
// 46B140: conditional instruction was optimized away because edx.4!=0
// 46B028: variable 'v1' is possibly undefined

//----- (0046B2E0) --------------------------------------------------------
void __cdecl sub_46B2E0(unsigned int a1, int a2, int a3, unsigned __int64 a4)
{
  _WORD *v4; // ecx
  int v5; // ebx
  double v6; // st7
  double v7; // st6
  double v8; // st5
  double v9; // st4
  int v10; // eax
  double v11; // st3
  double v12; // st4
  double i; // st7
  double v14; // rtt
  double v15; // st4
  double v16; // st7
  double v17; // st3
  double v18; // st4
  unsigned int v19; // eax
  double v20; // st3
  double v21; // st4
  unsigned int v22; // eax
  double v23; // st4
  double v24; // st6
  int *v25; // eax
  int v26; // edi
  int v27; // eax
  int v28; // esi
  void (__thiscall ***v29)(_DWORD, int); // esi
  unsigned int v30; // edi
  int v31; // eax
  int v32; // esi
  void (__thiscall ***v33)(_DWORD, int); // esi
  double v34; // st7
  int v35; // ecx
  __int64 v36; // rax
  int *v37; // eax
  int *v38; // eax
  void **v39; // edx
  int v40; // eax
  void *v41; // ebx
  int v42; // edi
  int v43; // eax
  int v44; // esi
  void (__thiscall ***v45)(_DWORD, int); // esi
  const unsigned __int16 *v46; // [esp+1Ch] [ebp-128h]
  int v47[4]; // [esp+30h] [ebp-114h] BYREF
  int v48[2]; // [esp+40h] [ebp-104h] BYREF
  void **v49; // [esp+48h] [ebp-FCh] BYREF
  int v50[3]; // [esp+4Ch] [ebp-F8h] BYREF
  void **v51; // [esp+58h] [ebp-ECh]
  _DWORD *v52; // [esp+5Ch] [ebp-E8h]
  _DWORD *v53; // [esp+68h] [ebp-DCh]
  _DWORD *v54; // [esp+6Ch] [ebp-D8h]
  _DWORD *v55; // [esp+78h] [ebp-CCh]
  _DWORD *v56; // [esp+7Ch] [ebp-C8h]
  void *v57; // [esp+80h] [ebp-C4h]
  int v58; // [esp+84h] [ebp-C0h]
  int v59; // [esp+88h] [ebp-BCh]
  int v60[19]; // [esp+90h] [ebp-B4h] BYREF
  int v61[6]; // [esp+DCh] [ebp-68h]
  struct std::locale::_Locimp *v62; // [esp+F4h] [ebp-50h] BYREF
  int v63; // [esp+F8h] [ebp-4Ch] BYREF
  _WORD *v64; // [esp+FCh] [ebp-48h] BYREF
  void ***v65; // [esp+100h] [ebp-44h] BYREF
  int v66; // [esp+104h] [ebp-40h]
  double v67; // [esp+108h] [ebp-3Ch]
  void *v68[5]; // [esp+114h] [ebp-30h] BYREF
  unsigned int v69; // [esp+128h] [ebp-1Ch]
  int v70; // [esp+140h] [ebp-4h]

  v5 = 0;
  v64 = v4;
  v61[0] = (int)L"bytes";
  v61[1] = (int)L"KB";
  v6 = (double)a4;
  v61[2] = (int)L"MB";
  v61[3] = (int)L"GB";
  v61[4] = (int)L"TB";
  v67 = (double)a4;
  v61[5] = (int)L"PB";
  v7 = 10.0;
  v8 = 1.0;
  if ( a2 )
  {
    switch ( a3 )
    {
      case 1:
        v5 = 0;
        break;
      case 2:
        v5 = 1;
        break;
      case 3:
        v5 = 2;
        break;
      case 4:
        v5 = 3;
        break;
      case 5:
        v5 = 4;
        break;
      case 6:
        v5 = 5;
        break;
      default:
        break;
    }
    v9 = v6;
    if ( v5 > 0 )
    {
      v10 = v5;
      do
      {
        --v10;
        v9 = v9 * 0.0009765625;
      }
      while ( v10 );
      v67 = v9;
      v6 = v9;
    }
    goto LABEL_13;
  }
  v11 = v6 * 0.0009765625;
  v12 = 0.0009765625;
  if ( v11 < 1.0 )
    goto LABEL_25;
  for ( i = v11; ; i = v17 )
  {
    v14 = v12;
    v15 = i;
    v16 = v14;
    ++v5;
    v67 = v15;
    v17 = v15 * v14;
    if ( v15 * v14 < 1.0 )
      break;
    v12 = v16;
  }
  v6 = v15;
  if ( (unsigned int)v5 <= 5 )
  {
LABEL_13:
    if ( v5 )
    {
      if ( v6 >= 10.0 )
        v66 = v6 < 100.0;
      else
        v66 = 2;
      v8 = 1.0;
      goto LABEL_28;
    }
LABEL_25:
    v66 = 0;
LABEL_28:
    v18 = 10.0;
    v19 = v66 + 1;
    if ( v66 + 1 < 0 )
      v19 = -v19;
    v20 = v8;
    while ( 1 )
    {
      if ( (v19 & 1) != 0 )
        v20 = v20 * v18;
      v19 >>= 1;
      if ( !v19 )
        break;
      v18 = v18 * v18;
    }
    v21 = v20;
    if ( v66 + 1 < 0 )
      v21 = v8 / v20;
    v63 = (int)v6;
    if ( (int)(v21 * (v6 - (double)(int)v6)) >= 5 )
    {
      v22 = -1 - v66;
      if ( -1 - v66 < 0 )
        v22 = v66 + 1;
      v23 = v8;
      while ( 1 )
      {
        if ( (v22 & 1) != 0 )
          v23 = v23 * v7;
        v22 >>= 1;
        if ( !v22 )
          break;
        v7 = v7 * v7;
      }
      if ( -1 - v66 >= 0 )
        v24 = v23 * 5.0;
      else
        v24 = v8 / v23 * 5.0;
      v67 = v6 - v24;
    }
    sub_40BE70(v47);
    v70 = 0;
    v25 = (int *)sub_419640(&v62, (const char *)&unk_4C11EF);
    LOBYTE(v70) = 1;
    sub_418E70(v25, (int)v47 + *(_DWORD *)(v47[0] + 4), &v63);
    v26 = v63;
    if ( v63 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v65, 0);
      v27 = *(_DWORD *)(v26 + 4);
      if ( v27 && v27 != -1 )
        *(_DWORD *)(v26 + 4) = v27 - 1;
      v28 = -(*(_DWORD *)(v26 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)&v65);
      v29 = (void (__thiscall ***)(_DWORD, int))(v26 & v28);
      if ( v29 )
        (**v29)(v29, 1);
    }
    LOBYTE(v70) = 0;
    v30 = (unsigned int)v62;
    if ( v62 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v65, 0);
      v31 = *(_DWORD *)(v30 + 4);
      if ( v31 && v31 != -1 )
        *(_DWORD *)(v30 + 4) = v31 - 1;
      v32 = -(*(_DWORD *)(v30 + 4) == 0);
      std::_Lockit::~_Lockit((std::_Lockit *)&v65);
      v33 = (void (__thiscall ***)(_DWORD, int))(v30 & v32);
      if ( v33 )
        (**v33)(v33, 1);
    }
    v34 = v67;
    v35 = *(_DWORD *)(v47[0] + 4);
    v36 = v66;
    *(int *)((char *)&v50[-1] + v35) = v66;
    *(int *)((char *)v50 + v35) = HIDWORD(v36);
    *(int *)((char *)&v50[2] + *(_DWORD *)(v48[0] + 4)) = *(int *)((char *)&v50[2] + *(_DWORD *)(v48[0] + 4)) & 0xFFFFCFFF | 0x2000;
    v46 = (const unsigned __int16 *)v61[v5];
    v37 = (int *)sub_418C80((int)v48, v34);
    v38 = sub_419050(v37, L" ");
    sub_419050(v38, v46);
    sub_40BFB0((int)v47, v68);
    v39 = (void **)v68[0];
    if ( v69 < 8 )
      v39 = v68;
    if ( a1 && a1 <= 0x7FFFFFFF )
      sub_4A96F0(a1, (int)v39, v64);
    if ( v69 >= 8 )
      operator delete(v68[0]);
    v69 = 7;
    v68[4] = 0;
    LOWORD(v68[0]) = 0;
    v40 = *(_DWORD *)(v47[0] + 4);
    v62 = (struct std::locale::_Locimp *)v60;
    *(int *)((char *)v47 + v40) = (int)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
    v70 = 2;
    v65 = &v49;
    v49 = &std::wstringbuf::`vftable';
    if ( (v59 & 1) != 0 )
      operator delete(*v51);
    *v51 = 0;
    *v53 = 0;
    *v55 = 0;
    *v52 = 0;
    *v54 = 0;
    *v56 = 0;
    v59 &= ~1u;
    v58 = 0;
    v49 = &std::wstreambuf::`vftable';
    LOBYTE(v70) = 3;
    v41 = v57;
    if ( v57 )
    {
      v42 = *(_DWORD *)v57;
      if ( *(_DWORD *)v57 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v64, 0);
        v43 = *(_DWORD *)(v42 + 4);
        if ( v43 && v43 != -1 )
          *(_DWORD *)(v42 + 4) = v43 - 1;
        v44 = -(*(_DWORD *)(v42 + 4) == 0);
        std::_Lockit::~_Lockit((std::_Lockit *)&v64);
        v45 = (void (__thiscall ***)(_DWORD, int))(v42 & v44);
        if ( v45 )
          (**v45)(v45, 1);
      }
      operator delete(v41);
    }
    LOBYTE(v70) = 2;
    std::_Mutex::~_Mutex((std::_Mutex *)v50);
    v70 = -1;
    *(int *)((char *)v47 + *(_DWORD *)(v47[0] + 4)) = (int)&std::wiostream::`vftable';
    *(int *)((char *)v48 + *(_DWORD *)(v48[0] + 4)) = (int)&std::wostream::`vftable';
    *(int *)((char *)v47 + *(_DWORD *)(v47[0] + 4)) = (int)&std::wistream::`vftable';
    v60[0] = (int)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor((struct std::ios_base *)v60);
    return;
  }
  if ( a1 && a1 <= 0x7FFFFFFF )
    sub_4A96F0(a1, (int)&unk_4C32C0, v4);
}
// 46B3BE: conditional instruction was optimized away because ebx.4<6u
// 46B339: variable 'v4' is possibly undefined
// 4C328C: using guessed type wchar_t aBytes[6];
// 4C3298: using guessed type wchar_t aKb[3];
// 4C32A0: using guessed type wchar_t aMb[3];
// 4C32A8: using guessed type wchar_t aGb[3];
// 4C32B0: using guessed type wchar_t aTb[3];
// 4C32B8: using guessed type wchar_t aPb[3];
// 4C32C4: using guessed type wchar_t asc_4C32C4[2];
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBADC: using guessed type void *std::wstreambuf::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CBF4C: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (0046B8C0) --------------------------------------------------------
int sub_46B8C0()
{
  return 0;
}

//----- (0046B8D0) --------------------------------------------------------
int sub_46B8D0()
{
  return 0;
}

//----- (0046B8E0) --------------------------------------------------------
int sub_46B8E0()
{
  return 0;
}

//----- (0046B8F0) --------------------------------------------------------
int __stdcall sub_46B8F0(int a1, int a2, int a3)
{
  return 0;
}

//----- (0046B900) --------------------------------------------------------
int __stdcall sub_46B900(int a1)
{
  return 0;
}

//----- (0046B910) --------------------------------------------------------
int __stdcall sub_46B910(int a1)
{
  return 0;
}

//----- (0046B920) --------------------------------------------------------
int __stdcall sub_46B920(int a1, int a2)
{
  return 1;
}

//----- (0046B930) --------------------------------------------------------
int __stdcall sub_46B930(int a1, int a2)
{
  return 0;
}

//----- (0046B940) --------------------------------------------------------
int __stdcall sub_46B940(int a1)
{
  return 0;
}

//----- (0046B950) --------------------------------------------------------
int sub_46B950()
{
  return 1;
}

//----- (0046B9C0) --------------------------------------------------------
int __fastcall sub_46B9C0(unsigned int a1, int a2, int a3, HWND hWnd, int a5)
{
  int (__thiscall ***v5)(_DWORD); // esi
  int result; // eax
  void (__thiscall ***v7)(_DWORD, _DWORD); // ecx
  int v8; // edi
  int v9; // ecx
  _DWORD *v10; // eax
  void (__thiscall *v11)(int, int, void **); // edx
  void *v12; // eax
  int v13; // eax
  int v14; // [esp-4h] [ebp-60h]
  int pExceptionObject[4]; // [esp+14h] [ebp-48h] BYREF
  void *v16[3]; // [esp+24h] [ebp-38h] BYREF
  char *v17; // [esp+30h] [ebp-2Ch] BYREF
  void *v18; // [esp+34h] [ebp-28h] BYREF
  struct tagRECT Rect; // [esp+38h] [ebp-24h] BYREF
  int v20; // [esp+58h] [ebp-4h]

  v5 = (int (__thiscall ***)(_DWORD))a3;
  v18 = (void *)a3;
  v17 = (char *)hWnd;
  if ( a1 - 32769 <= 0x3FFD )
  {
    (*(void (__thiscall **)(int, unsigned int, int, int))(*(_DWORD *)a3 + 44))(a3, a1, a2, a5);
    return 0;
  }
  if ( a1 > 0x82 )
  {
    switch ( a1 )
    {
      case 0x110u:
        *(_DWORD *)(a3 + 4) = hWnd;
        if ( *(_BYTE *)(a3 + 28) )
        {
          GetWindowRect(hWnd, &Rect);
          v9 = Rect.bottom - Rect.top;
          *(_DWORD *)(a3 + 36) = Rect.right - Rect.left;
          *(_DWORD *)(a3 + 40) = v9;
          v16[1] = 0;
          v10 = operator new(0x14u);
          if ( !v10 )
          {
            v17 = 0;
            std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
            pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          v16[0] = v10;
          *v10 = v10;
          *((void **)v16[0] + 1) = v16[0];
          v20 = 0;
          v11 = *(void (__thiscall **)(int, int, void **))(*(_DWORD *)a3 + 48);
          *(_DWORD *)(a3 + 32) = 0;
          v11(a3, a3 + 32, v16);
          v12 = operator new(0x10u);
          pExceptionObject[3] = (int)v12;
          LOBYTE(v20) = 1;
          if ( v12 )
            v13 = sub_4AAB10(*(HWND *)(a3 + 4), (int ***)v16, (int)v12);
          else
            v13 = 0;
          *(_DWORD *)(a3 + 44) = v13;
          v20 = -1;
          sub_41ECB0(v16);
          v5 = (int (__thiscall ***)(_DWORD))v18;
        }
        result = (**v5)(v5);
        break;
      case 0x111u:
        result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a3 + 12))(a3, a2, a5);
        break;
      case 0x113u:
        result = (*(int (__thiscall **)(int, int))(*(_DWORD *)a3 + 4))(a3, a2);
        break;
      case 0x138u:
        result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a3 + 8))(a3, a5, a2);
        break;
      default:
        return 0;
    }
  }
  else
  {
    if ( a1 != 130 )
    {
      switch ( a1 )
      {
        case 2u:
          if ( *(_DWORD *)(a3 + 24) )
          {
            v7 = *(void (__thiscall ****)(_DWORD, _DWORD))(a3 + 20);
            if ( v7 )
              (**v7)(v7, *(_DWORD *)(a3 + 12));
          }
          v8 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 32))(a3);
          (*(void (__thiscall **)(int))(*(_DWORD *)a3 + 40))(a3);
          return v8;
        case 5u:
          v14 = HIWORD(a5);
          if ( *(_BYTE *)(a3 + 28) )
          {
            sub_4AA960(*(HWND **)(a3 + 44), (unsigned __int16)a5, v14);
            return 0;
          }
          return (*(int (__thiscall **)(int, int, _DWORD, int))(*(_DWORD *)a3 + 24))(a3, a2, (unsigned __int16)a5, v14);
        case 0x10u:
          return (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 28))(a3);
        case 0x24u:
          if ( !*(_BYTE *)(a3 + 28) )
            return (*(int (__thiscall **)(int, int))(*(_DWORD *)a3 + 20))(a3, a5);
          *(_DWORD *)(a5 + 24) = *(_DWORD *)(a3 + 36);
          *(_DWORD *)(a5 + 28) = *(_DWORD *)(a3 + 40);
          if ( *(_DWORD *)(a3 + 32) == 1 )
            *(_DWORD *)(a5 + 36) = *(_DWORD *)(a3 + 40);
          if ( *(_DWORD *)(a3 + 32) == 2 )
            *(_DWORD *)(a5 + 32) = *(_DWORD *)(a3 + 36);
          break;
        case 0x4Eu:
          return (*(int (__thiscall **)(int, int))(*(_DWORD *)a3 + 16))(a3, a5);
        default:
          return 0;
      }
      return 0;
    }
    sub_4188E0((int *)&v17, &v18);
    sub_418730(&v18, v18);
    return (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 36))(a3);
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0046BD00) --------------------------------------------------------
INT_PTR __stdcall DialogFunc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // esi
  void *v5; // eax
  char *v6; // esi
  INT_PTR result; // eax
  void (__thiscall ***v8)(_DWORD, _DWORD); // ecx
  int v9; // edi
  bool v10; // zf
  HWND v11; // eax
  int v12; // eax
  _DWORD *v13; // eax
  void (__thiscall *v14)(char *, char *, void **); // edx
  void *v15; // eax
  int v16; // eax
  int v17; // [esp-4h] [ebp-68h]
  HWND hWnd; // [esp+10h] [ebp-54h] BYREF
  void *v19[2]; // [esp+14h] [ebp-50h] BYREF
  char *v20[2]; // [esp+1Ch] [ebp-48h] BYREF
  char *v21; // [esp+24h] [ebp-40h] BYREF
  void *v22[3]; // [esp+28h] [ebp-3Ch] BYREF
  int pExceptionObject[3]; // [esp+34h] [ebp-30h] BYREF
  struct tagRECT Rect; // [esp+40h] [ebp-24h] BYREF
  int v25; // [esp+60h] [ebp-4h]

  v4 = a1;
  hWnd = a1;
  if ( a2 == 272 )
  {
    v20[0] = (char *)a1;
    v20[1] = (char *)a4;
    sub_4189A0((int)v19, v20);
    v4 = hWnd;
  }
  sub_4188E0((int *)&hWnd, v19);
  v5 = v19[0];
  if ( v19[0] == dword_4EF714 )
    return 0;
  v19[0] = v4;
  v6 = (char *)*((_DWORD *)v5 + 3);
  v20[0] = v6;
  if ( a2 - 32769 <= 0x3FFD )
  {
    (*(void (__thiscall **)(char *, UINT, WPARAM, LPARAM))(*(_DWORD *)v6 + 44))(v6, a2, a3, a4);
    return 0;
  }
  if ( a2 > 0x82 )
  {
    switch ( a2 )
    {
      case 0x110u:
        v10 = v6[28] == 0;
        v11 = hWnd;
        *((_DWORD *)v6 + 1) = hWnd;
        if ( !v10 )
        {
          GetWindowRect(v11, &Rect);
          v12 = Rect.bottom - Rect.top;
          *((_DWORD *)v6 + 9) = Rect.right - Rect.left;
          *((_DWORD *)v6 + 10) = v12;
          v22[1] = 0;
          v13 = operator new(0x14u);
          if ( !v13 )
          {
            v21 = 0;
            std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
            pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          v22[0] = v13;
          *v13 = v13;
          *((void **)v22[0] + 1) = v22[0];
          v25 = 0;
          v14 = *(void (__thiscall **)(char *, char *, void **))(*(_DWORD *)v6 + 48);
          *((_DWORD *)v6 + 8) = 0;
          v14(v6, v6 + 32, v22);
          v15 = operator new(0x10u);
          v19[0] = v15;
          LOBYTE(v25) = 1;
          if ( v15 )
            v16 = sub_4AAB10(*((HWND *)v6 + 1), (int ***)v22, (int)v15);
          else
            v16 = 0;
          *((_DWORD *)v6 + 11) = v16;
          v25 = -1;
          sub_41ECB0(v22);
          v6 = v20[0];
        }
        result = (**(int (__thiscall ***)(char *))v6)(v6);
        break;
      case 0x111u:
        result = (*(int (__thiscall **)(char *, WPARAM, LPARAM))(*(_DWORD *)v6 + 12))(v6, a3, a4);
        break;
      case 0x113u:
        result = (*(int (__thiscall **)(char *, WPARAM))(*(_DWORD *)v6 + 4))(v6, a3);
        break;
      case 0x138u:
        result = (*(int (__thiscall **)(char *, LPARAM, WPARAM))(*(_DWORD *)v6 + 8))(v6, a4, a3);
        break;
      default:
        return 0;
    }
  }
  else
  {
    if ( a2 != 130 )
    {
      switch ( a2 )
      {
        case 2u:
          if ( *((_DWORD *)v6 + 6) )
          {
            v8 = (void (__thiscall ***)(_DWORD, _DWORD))*((_DWORD *)v6 + 5);
            if ( v8 )
              (**v8)(v8, *((_DWORD *)v6 + 3));
          }
          v9 = (*(int (__thiscall **)(char *))(*(_DWORD *)v6 + 32))(v6);
          (*(void (__thiscall **)(char *))(*(_DWORD *)v6 + 40))(v6);
          return v9;
        case 5u:
          v17 = HIWORD(a4);
          if ( v6[28] )
          {
            sub_4AA960(*((HWND **)v6 + 11), (unsigned __int16)a4, v17);
            return 0;
          }
          return (*(int (__thiscall **)(char *, WPARAM, _DWORD, int))(*(_DWORD *)v6 + 24))(
                   v6,
                   a3,
                   (unsigned __int16)a4,
                   v17);
        case 0x10u:
          return (*(int (__thiscall **)(char *))(*(_DWORD *)v6 + 28))(v6);
        case 0x24u:
          if ( !v6[28] )
            return (*(int (__thiscall **)(char *, LPARAM))(*(_DWORD *)v6 + 20))(v6, a4);
          *(_DWORD *)(a4 + 24) = *((_DWORD *)v6 + 9);
          *(_DWORD *)(a4 + 28) = *((_DWORD *)v6 + 10);
          if ( *((_DWORD *)v6 + 8) == 1 )
            *(_DWORD *)(a4 + 36) = *((_DWORD *)v6 + 10);
          if ( *((_DWORD *)v6 + 8) == 2 )
            *(_DWORD *)(a4 + 32) = *((_DWORD *)v6 + 9);
          break;
        case 0x4Eu:
          return (*(int (__thiscall **)(char *, LPARAM))(*(_DWORD *)v6 + 16))(v6, a4);
        default:
          return 0;
      }
      return 0;
    }
    sub_4188E0((int *)v19, &hWnd);
    sub_418730(v20, hWnd);
    return (*(int (__thiscall **)(char *))(*(_DWORD *)v6 + 36))(v6);
  }
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0046C0D0) --------------------------------------------------------
HWND __userpurge sub_46C0D0@<eax>(LPARAM a1@<esi>, int a2)
{
  HWND result; // eax

  if ( *(_DWORD *)(a1 + 24) )
    return 0;
  result = CreateDialogParamW(
             *(HINSTANCE *)(a1 + 8),
             (LPCWSTR)*(unsigned __int16 *)(a1 + 12),
             *(HWND *)(a1 + 16),
             DialogFunc,
             a1);
  if ( result )
    *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

//----- (0046C110) --------------------------------------------------------
INT_PTR __usercall sub_46C110@<eax>(LPARAM a1@<eax>)
{
  if ( *(_DWORD *)(a1 + 24) )
    return -1;
  else
    return DialogBoxParamW(
             *(HINSTANCE *)(a1 + 8),
             (LPCWSTR)*(unsigned __int16 *)(a1 + 12),
             *(HWND *)(a1 + 16),
             DialogFunc,
             a1);
}

//----- (0046C150) --------------------------------------------------------
BOOL sub_46C150()
{
  BOOL v0; // esi
  LPVOID v1; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v3; // ebx
  BSTR v4; // eax
  BSTR v5; // eax
  int i; // edi
  VARIANTARG v8; // [esp+10h] [ebp-258h] BYREF
  VARIANTARG pvarg; // [esp+20h] [ebp-248h] BYREF
  LPCWSTR lpString1; // [esp+34h] [ebp-234h] BYREF
  LPCWSTR v11; // [esp+38h] [ebp-230h] BYREF
  int v12; // [esp+3Ch] [ebp-22Ch] BYREF
  int v13; // [esp+40h] [ebp-228h] BYREF
  int v14; // [esp+44h] [ebp-224h]
  __int16 v15; // [esp+48h] [ebp-220h] BYREF
  int v16; // [esp+4Ch] [ebp-21Ch] BYREF
  int v17; // [esp+50h] [ebp-218h] BYREF
  int v18; // [esp+54h] [ebp-214h] BYREF
  WCHAR pszPath[262]; // [esp+58h] [ebp-210h] BYREF

  v0 = 1;
  v1 = sub_4647D0();
  if ( v1 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v3 = OpenProcess(0x410u, 0, CurrentProcessId);
    if ( v3 )
    {
      GetModuleFileNameExW(v3, 0, pszPath, 260);
      CloseHandle(v3);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit(&pvarg);
    v4 = SysAllocString(pszPath);
    pvarg.vt = 8;
    *(_QWORD *)&v8.vt = *(_QWORD *)&pvarg.vt;
    v8.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v4);
    (*(void (__stdcall **)(LPVOID, _DWORD, ULONG, BSTR, LONG, __int16 *))(*(_DWORD *)v1 + 232))(
      v1,
      *(_DWORD *)&pvarg.vt,
      pvarg.decVal.Hi32,
      v4,
      pvarg.cyVal.Hi,
      &v15);
    if ( v15 == -1 )
    {
      v16 = 0;
      v18 = 0;
      v13 = 0;
      v17 = 0;
      v14 = 0;
      v5 = SysAllocString(L"//Settings/*");
      (*(void (__stdcall **)(LPVOID, BSTR, int *))(*(_DWORD *)v1 + 144))(v1, v5, &v16);
      if ( v16 )
      {
        (*(void (__stdcall **)(int, int *))(*(_DWORD *)v16 + 32))(v16, &v12);
        for ( i = 0; i < v12; v18 = 0 )
        {
          if ( v14 )
            break;
          (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v16 + 28))(v16, i, &v18);
          if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)v18 + 68))(v18, &v13) >= 0
            && (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v13 + 40))(v13, 0, &v17) >= 0 )
          {
            (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v17 + 104))(v17, &lpString1);
            (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v18 + 104))(v18, &v11);
            if ( !lstrcmpW(lpString1, L"AllowMultipleInstances") )
            {
              v0 = lstrcmpW(v11, L"yes") == 0;
              v14 = 1;
            }
            (*(void (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
            v17 = 0;
          }
          (*(void (__stdcall **)(int))(*(_DWORD *)v18 + 8))(v18);
          ++i;
        }
      }
    }
  }
  VariantClear(&v8);
  return v0;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046C3F0) --------------------------------------------------------
int __cdecl sub_46C3F0(_DWORD *a1)
{
  int *v1; // esi
  DWORD CurrentProcessId; // eax
  HANDLE v3; // eax
  void *v4; // edi
  BSTR v5; // eax
  OLECHAR *v6; // eax
  int v7; // ecx
  int v8; // eax
  _DWORD *v9; // edi
  int v10; // ebx
  VARIANTARG v12; // [esp+10h] [ebp-264h] BYREF
  VARIANTARG pvarg; // [esp+20h] [ebp-254h] BYREF
  int v14; // [esp+34h] [ebp-240h] BYREF
  _DWORD *v15; // [esp+38h] [ebp-23Ch]
  BSTR bstrString; // [esp+3Ch] [ebp-238h]
  int v17; // [esp+40h] [ebp-234h] BYREF
  int v18; // [esp+44h] [ebp-230h] BYREF
  __int16 v19; // [esp+48h] [ebp-22Ch] BYREF
  int v20; // [esp+4Ch] [ebp-228h] BYREF
  int v21; // [esp+50h] [ebp-224h] BYREF
  int v22; // [esp+54h] [ebp-220h] BYREF
  LPCWSTR lpString1; // [esp+58h] [ebp-21Ch] BYREF
  wchar_t *String; // [esp+5Ch] [ebp-218h] BYREF
  WCHAR pszPath[262]; // [esp+60h] [ebp-214h] BYREF

  v15 = a1;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v20 = 0;
  bstrString = 0;
  v1 = (int *)sub_4647D0();
  if ( v1 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v3 = OpenProcess(0x410u, 0, CurrentProcessId);
    v4 = v3;
    if ( v3 )
    {
      GetModuleFileNameExW(v3, 0, pszPath, 260);
      CloseHandle(v4);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit(&pvarg);
    v5 = SysAllocString(pszPath);
    pvarg.vt = 8;
    *(_QWORD *)&v12.vt = *(_QWORD *)&pvarg.vt;
    v12.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v5);
    (*(void (__stdcall **)(int *, _DWORD, ULONG, BSTR, LONG, __int16 *))(*v1 + 232))(
      v1,
      *(_DWORD *)&pvarg.vt,
      pvarg.decVal.Hi32,
      v5,
      pvarg.cyVal.Hi,
      &v19);
    if ( v19 == -1 )
    {
      v6 = SysAllocString(L"//WindowPosition/*");
      v7 = *v1;
      bstrString = v6;
      (*(void (__stdcall **)(int *, OLECHAR *, int *))(v7 + 144))(v1, v6, &v21);
      v8 = v21;
      v9 = v15;
      *v15 = 44;
      if ( v8 )
      {
        (*(void (__stdcall **)(int, int *))(*(_DWORD *)v8 + 32))(v8, &v14);
        v10 = 1;
        if ( v14 == 1 )
        {
          (*(void (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v21 + 28))(v21, 0, &v22);
          if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)v22 + 68))(v22, &v18) >= 0 )
          {
            (*(void (__stdcall **)(int, int *))(*(_DWORD *)v18 + 44))(v18, &v17);
            if ( v17 > 1 )
            {
              do
              {
                (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v18 + 40))(v18, v10, &v20);
                (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v20 + 28))(v20, &lpString1);
                (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v20 + 104))(v20, &String);
                if ( lstrcmpW(lpString1, L"Flags") )
                {
                  if ( lstrcmpW(lpString1, L"ShowCmd") )
                  {
                    if ( lstrcmpW(lpString1, L"MinPositionX") )
                    {
                      if ( lstrcmpW(lpString1, L"MinPositionY") )
                      {
                        if ( lstrcmpW(lpString1, L"MaxPositionX") )
                        {
                          if ( lstrcmpW(lpString1, L"MaxPositionY") )
                          {
                            if ( lstrcmpW(lpString1, L"NormalPositionLeft") )
                            {
                              if ( lstrcmpW(lpString1, L"NormalPositionTop") )
                              {
                                if ( lstrcmpW(lpString1, L"NormalPositionRight") )
                                {
                                  if ( !lstrcmpW(lpString1, L"NormalPositionBottom") )
                                    v9[10] = _wtoi(String);
                                }
                                else
                                {
                                  v9[9] = _wtoi(String);
                                }
                              }
                              else
                              {
                                v9[8] = _wtoi(String);
                              }
                            }
                            else
                            {
                              v9[7] = _wtoi(String);
                            }
                          }
                          else
                          {
                            v9[6] = _wtoi(String);
                          }
                        }
                        else
                        {
                          v9[5] = _wtoi(String);
                        }
                      }
                      else
                      {
                        v9[4] = _wtoi(String);
                      }
                    }
                    else
                    {
                      v9[3] = _wtoi(String);
                    }
                  }
                  else
                  {
                    v9[2] = _wtoi(String);
                  }
                }
                else
                {
                  v9[1] = _wtoi(String);
                }
                ++v10;
              }
              while ( v10 < v17 );
            }
          }
          (*(void (__stdcall **)(int))(*(_DWORD *)v22 + 8))(v22);
          v22 = 0;
        }
      }
    }
  }
  VariantClear(&v12);
  if ( bstrString )
    SysFreeString(bstrString);
  if ( v21 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v21 + 8))(v21);
  if ( v22 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v22 + 8))(v22);
  return 1;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046C800) --------------------------------------------------------
int __usercall sub_46C800@<eax>(int a1@<edi>)
{
  BSTR v1; // eax
  int v2; // esi
  int v3; // eax
  DWORD CurrentProcessId; // eax
  HANDLE v5; // esi
  BSTR v6; // eax
  int *v7; // edx
  int v8; // esi
  int v9; // eax
  int result; // eax
  int v11; // [esp-4h] [ebp-22Ch]
  VARIANTARG pvarg; // [esp+8h] [ebp-220h] BYREF
  int v13; // [esp+18h] [ebp-210h] BYREF
  WCHAR pszPath[260]; // [esp+1Ch] [ebp-20Ch] BYREF

  v1 = SysAllocString(L"\n");
  v2 = *(_DWORD *)(a1 + 24);
  v11 = (int)v1;
  v3 = *(_DWORD *)(a1 + 16);
  v13 = 0;
  sub_4645D0(v3, v2, v11);
  (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 16) + 136))(*(_DWORD *)(a1 + 16), &v13);
  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x410u, 0, CurrentProcessId);
  GetModuleFileNameExW(v5, 0, pszPath, 260);
  CloseHandle(v5);
  PathRemoveFileSpecW(pszPath);
  PathAppendW(pszPath, L"config.xml");
  VariantInit(&pvarg);
  v6 = SysAllocString(pszPath);
  v7 = *(int **)(a1 + 16);
  v8 = *v7;
  pvarg.vt = 8;
  (*(void (__stdcall **)(int *, _DWORD, ULONG, BSTR, LONG))(v8 + 264))(
    v7,
    *(_DWORD *)&pvarg.vt,
    pvarg.decVal.Hi32,
    v6,
    pvarg.cyVal.Hi);
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 24) + 8))(*(_DWORD *)(a1 + 24));
  v9 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 24) = 0;
  result = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046C930) --------------------------------------------------------
int __usercall sub_46C930@<eax>(int a1@<edi>)
{
  LPVOID v1; // eax
  OLECHAR *v2; // esi
  OLECHAR *v3; // eax
  int v4; // ecx
  void (__stdcall *v5)(int, int, BSTR *); // eax
  OLECHAR *v6; // eax
  int *v7; // ecx
  int v8; // edx
  void (__stdcall *v9)(int, int, BSTR *); // edx
  OLECHAR *v10; // eax
  int *v11; // ecx
  int v12; // edx
  void (__stdcall *v13)(int, int, BSTR *); // edx
  int result; // eax
  int v15; // [esp-Ch] [ebp-28h]
  int v16; // [esp-Ch] [ebp-28h]
  int v17; // [esp-Ch] [ebp-28h]
  int v18; // [esp-8h] [ebp-24h]
  BSTR v19; // [esp+8h] [ebp-14h]
  BSTR bstrString; // [esp+Ch] [ebp-10h] BYREF
  BSTR v21; // [esp+10h] [ebp-Ch] BYREF
  int v22; // [esp+14h] [ebp-8h] BYREF
  int v23; // [esp+18h] [ebp-4h] BYREF

  v23 = 0;
  v22 = 0;
  v19 = SysAllocString(L"\n\t");
  v1 = sub_4647D0();
  *(_DWORD *)(a1 + 16) = v1;
  if ( v1 )
  {
    v2 = SysAllocString(L"xml");
    v3 = SysAllocString(L"version='1.0'");
    v4 = *(_DWORD *)(a1 + 16);
    bstrString = v3;
    (*(void (__stdcall **)(int, OLECHAR *, OLECHAR *, int *))(*(_DWORD *)v4 + 208))(v4, v2, v3, &v23);
    v15 = *(_DWORD *)(a1 + 16);
    v5 = *(void (__stdcall **)(int, int, BSTR *))(*(_DWORD *)v15 + 84);
    v21 = 0;
    v5(v15, v23, &v21);
    if ( v21 )
      (*(void (__stdcall **)(BSTR))(*(_DWORD *)v21 + 8))(v21);
    (*(void (__stdcall **)(int))(*(_DWORD *)v23 + 8))(v23);
    v23 = 0;
    SysFreeString(v2);
    SysFreeString(bstrString);
    v6 = SysAllocString(L" Preference file for Explorer++ ");
    v7 = *(int **)(a1 + 16);
    v8 = *v7;
    v21 = v6;
    (*(void (__stdcall **)(int *, OLECHAR *, int *))(v8 + 200))(v7, v6, &v22);
    v9 = *(void (__stdcall **)(int, int, BSTR *))(**(_DWORD **)(a1 + 16) + 84);
    v16 = *(_DWORD *)(a1 + 16);
    bstrString = 0;
    v9(v16, v22, &bstrString);
    if ( bstrString )
      (*(void (__stdcall **)(BSTR))(*(_DWORD *)bstrString + 8))(bstrString);
    SysFreeString(v21);
    (*(void (__stdcall **)(int))(*(_DWORD *)v22 + 8))(v22);
    v22 = 0;
    v10 = SysAllocString(L"ExplorerPlusPlus");
    v11 = *(int **)(a1 + 16);
    v12 = *v11;
    v21 = v10;
    (*(void (__stdcall **)(int *, OLECHAR *, int))(v12 + 188))(v11, v10, a1 + 24);
    SysFreeString(v21);
    v13 = *(void (__stdcall **)(int, int, BSTR *))(**(_DWORD **)(a1 + 16) + 84);
    v18 = *(_DWORD *)(a1 + 24);
    v17 = *(_DWORD *)(a1 + 16);
    bstrString = 0;
    v13(v17, v18, &bstrString);
    if ( bstrString )
      (*(void (__stdcall **)(BSTR))(*(_DWORD *)bstrString + 8))(bstrString);
    sub_4645D0(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), (int)v19);
  }
  if ( v23 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v23 + 8))(v23);
  result = v22;
  if ( v22 )
    return (*(int (__stdcall **)(int))(*(_DWORD *)v22 + 8))(v22);
  return result;
}

//----- (0046CAE0) --------------------------------------------------------
HRESULT __usercall sub_46CAE0@<eax>(int a1@<esi>)
{
  LPVOID v1; // eax
  DWORD CurrentProcessId; // eax
  HANDLE v3; // edi
  BSTR v4; // eax
  int v5; // edx
  VARIANTARG v7; // [esp+8h] [ebp-238h] BYREF
  VARIANTARG pvarg; // [esp+18h] [ebp-228h] BYREF
  __int16 v9; // [esp+2Ch] [ebp-214h] BYREF
  WCHAR pszPath[262]; // [esp+30h] [ebp-210h] BYREF

  *(_DWORD *)(a1 + 20) = 0;
  v1 = sub_4647D0();
  *(_DWORD *)(a1 + 16) = v1;
  if ( v1 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v3 = OpenProcess(0x410u, 0, CurrentProcessId);
    if ( v3 )
    {
      GetModuleFileNameExW(v3, 0, pszPath, 260);
      CloseHandle(v3);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit(&pvarg);
    v4 = SysAllocString(L"config.xml");
    pvarg.vt = 8;
    *(_QWORD *)&v7.vt = *(_QWORD *)&pvarg.vt;
    v5 = *(_DWORD *)(a1 + 16);
    v7.llVal = __PAIR64__(pvarg.decVal.Mid32, (unsigned int)v4);
    (*(void (__stdcall **)(int, _DWORD, ULONG, BSTR, LONG, __int16 *))(*(_DWORD *)v5 + 232))(
      v5,
      *(_DWORD *)&pvarg.vt,
      pvarg.decVal.Hi32,
      v4,
      pvarg.cyVal.Hi,
      &v9);
    if ( v9 == -1 )
      *(_DWORD *)(a1 + 20) = 1;
  }
  return VariantClear(&v7);
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046CC10) --------------------------------------------------------
int __stdcall sub_46CC10(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (0046CC30) --------------------------------------------------------
int __stdcall sub_46CC30(int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  return -2147467262;
}

//----- (0046CCF0) --------------------------------------------------------
int __userpurge sub_46CCF0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // esi
  OLECHAR *v4; // edi
  int v5; // eax
  int v6; // ecx
  int *v7; // ebx
  int i; // esi
  int v10; // [esp+Ch] [ebp-24h] BYREF
  int v11; // [esp+10h] [ebp-20h]
  int v12; // [esp+14h] [ebp-1Ch] BYREF
  wchar_t *String; // [esp+18h] [ebp-18h] BYREF
  LPCWSTR lpString1; // [esp+1Ch] [ebp-14h] BYREF
  int v15; // [esp+20h] [ebp-10h] BYREF
  int v16; // [esp+24h] [ebp-Ch] BYREF
  int v17; // [esp+28h] [ebp-8h] BYREF
  int v18; // [esp+2Ch] [ebp-4h] BYREF
  BOOL v19; // [esp+38h] [ebp+8h]

  v3 = result;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  if ( result )
  {
    v4 = SysAllocString(L"//Toolbars/*");
    (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)v3 + 144))(v3, v4, &v18);
    v5 = v18;
    if ( v18 )
    {
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)v18 + 32))(v18, &v10);
      v6 = 0;
      v11 = 0;
      if ( v10 > 0 )
      {
        v7 = (int *)(a3 + 59584);
        do
        {
          if ( (*(int (__stdcall **)(int, int, int *, int))(*(_DWORD *)v18 + 28))(v18, v6, &v17, a2) >= 0
            && (*(int (__stdcall **)(int, int *))(*(_DWORD *)v17 + 68))(v17, &v16) >= 0 )
          {
            v19 = (*v7 & 0x200) != 0;
            (*(void (__stdcall **)(int, int *))(*(_DWORD *)v16 + 44))(v16, &v12);
            for ( i = 1; i < v12; ++i )
            {
              (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v16 + 40))(v16, i, &v15);
              (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v15 + 28))(v15, &lpString1);
              (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v15 + 104))(v15, &String);
              if ( lstrcmpW(lpString1, L"id") )
              {
                if ( lstrcmpW(lpString1, L"Style") )
                {
                  if ( !lstrcmpW(lpString1, L"Length") )
                    v7[9] = _wtoi(String);
                }
                else
                {
                  *v7 = _wtoi(String);
                }
              }
              else
              {
                v7[11] = _wtoi(String);
              }
            }
            if ( v19 )
              *v7 |= 0x200u;
          }
          a2 = v17;
          (*(void (**)(void))(*(_DWORD *)v17 + 8))();
          v6 = v11 + 1;
          v7 += 20;
          v17 = 0;
          v11 = v6;
        }
        while ( v6 < v10 );
      }
      v5 = v18;
    }
    if ( v4 )
    {
      SysFreeString(v4);
      v5 = v18;
    }
    if ( v5 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
    result = v17;
    if ( v17 )
      return (*(int (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
  }
  return result;
}
// 46CCF0: could not find valid save-restore pair for edi

//----- (0046CED0) --------------------------------------------------------
int __usercall sub_46CED0@<eax>(int a1@<ecx>, int a2@<edi>)
{
  return sub_46CCF0(*(_DWORD *)(a1 + 16), a2, *(_DWORD *)(a1 + 8));
}

//----- (0046CEE0) --------------------------------------------------------
int __stdcall sub_46CEE0(_DWORD *a1)
{
  if ( a1[1]-- != 1 )
    return a1[1];
  sub_418660(a1);
  return 0;
}

//----- (0046CF00) --------------------------------------------------------
void __fastcall sub_46CF00(int a1, int a2, int a3)
{
  int v3; // edi
  OLECHAR *v5; // eax
  signed int v6; // ebx
  void (__stdcall *v7)(int, BSTR, int *); // eax
  HWND v8; // [esp+4h] [ebp-D8h]
  HWND v9; // [esp+4h] [ebp-D8h]
  int v10; // [esp+24h] [ebp-B8h] BYREF
  int v11; // [esp+28h] [ebp-B4h] BYREF
  BSTR bstrString; // [esp+2Ch] [ebp-B0h]
  int v13; // [esp+30h] [ebp-ACh]
  int v14; // [esp+34h] [ebp-A8h] BYREF
  LRESULT v15; // [esp+38h] [ebp-A4h]
  BSTR v16; // [esp+3Ch] [ebp-A0h]
  int v17; // [esp+40h] [ebp-9Ch]
  LPARAM lParam[20]; // [esp+44h] [ebp-98h] BYREF
  WCHAR v19[34]; // [esp+94h] [ebp-48h] BYREF

  v3 = a2;
  v13 = a3;
  v17 = a2;
  v10 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  v5 = SysAllocString(L"\n\t\t\t");
  v8 = *(HWND *)(a3 + 60);
  v16 = v5;
  v6 = 0;
  v15 = SendMessageW(v8, 0x40Cu, 0, 0);
  if ( v15 > 0 )
  {
    while ( 1 )
    {
      v7 = *(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a1 + 196);
      v11 = 0;
      v14 = 0;
      v7(a1, bstrString, &v11);
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v3 + 84))(v3, v11, &v14);
      if ( v11 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
      v11 = 0;
      if ( v14 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
      v9 = *(HWND *)(v13 + 60);
      lParam[0] = 80;
      lParam[1] = 337;
      SendMessageW(v9, 0x41Cu, v6, (LPARAM)lParam);
      wsprintfW(v19, L"%d", v6);
      sub_464940(a1, (int)&v10, v3, (OLECHAR *)L"Toolbar", v19);
      _itow_s(lParam[13], Buffer, 0x40u, 10);
      sub_464A60(a1, v10, (OLECHAR *)L"id", Buffer);
      _itow_s(lParam[2], Buffer, 0x40u, 10);
      sub_464A60(a1, v10, (OLECHAR *)L"Style", Buffer);
      _itow_s(lParam[11], Buffer, 0x40u, 10);
      sub_464A60(a1, v10, (OLECHAR *)L"Length", Buffer);
      (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
      ++v6;
      v10 = 0;
      if ( v6 >= v15 )
        break;
      v3 = v17;
    }
  }
  SysFreeString(bstrString);
  SysFreeString(v16);
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (0046D110) --------------------------------------------------------
int __userpurge sub_46D110@<eax>(int a1@<ebx>, int a2@<edi>, int a3)
{
  OLECHAR *v3; // esi
  void (__stdcall *v4)(int, _DWORD, int *); // edx
  int v6; // [esp+0h] [ebp-Ch]
  BSTR v7; // [esp+4h] [ebp-8h]

  v7 = SysAllocString(L"\n\t");
  sub_4645D0(a2, a1, (int)v7);
  v3 = SysAllocString(L"Toolbars");
  (*(void (__stdcall **)(int, OLECHAR *))(*(_DWORD *)a2 + 188))(a2, v3);
  SysFreeString(v3);
  sub_46CF00(a2, 0, a3);
  sub_4645D0(a2, 0, (int)v7);
  v4 = *(void (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)a1 + 84);
  a3 = 0;
  v4(a1, 0, &a3);
  if ( a3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a3 + 8))(a3);
  return (*(int (__stdcall **)(_DWORD, int))(MEMORY[0] + 8))(0, v6);
}
// 46D1AC: variable 'v6' is possibly undefined

//----- (0046D1C0) --------------------------------------------------------
int __usercall sub_46D1C0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  BSTR v5; // eax
  HWND v6; // ecx
  int v8; // [esp+8h] [ebp-38h]
  int v9; // [esp+Ch] [ebp-34h] BYREF
  WINDOWPLACEMENT wndpl; // [esp+10h] [ebp-30h] BYREF

  v9 = 0;
  v5 = SysAllocString(L"\n\t\t");
  v6 = *(HWND *)(a2 + 52);
  v8 = (int)v5;
  wndpl.length = 44;
  GetWindowPlacement(v6, &wndpl);
  sub_4645D0(a3, a1, v8);
  sub_464940(a3, (int)&v9, a1, (OLECHAR *)L"Setting", (OLECHAR *)L"Position");
  _itow_s(wndpl.flags, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"Flags", Buffer);
  _itow_s(wndpl.showCmd, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"ShowCmd", Buffer);
  _itow_s(wndpl.ptMinPosition.x, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"MinPositionX", Buffer);
  _itow_s(wndpl.ptMinPosition.y, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"MinPositionY", Buffer);
  _itow_s(wndpl.ptMaxPosition.x, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"MaxPositionX", Buffer);
  _itow_s(wndpl.ptMaxPosition.y, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"MaxPositionY", Buffer);
  _itow_s(wndpl.rcNormalPosition.left, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"NormalPositionLeft", Buffer);
  _itow_s(wndpl.rcNormalPosition.top, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"NormalPositionTop", Buffer);
  _itow_s(wndpl.rcNormalPosition.right, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"NormalPositionRight", Buffer);
  _itow_s(wndpl.rcNormalPosition.bottom, Buffer, 0x40u, 10);
  sub_464A60(a3, v9, (OLECHAR *)L"NormalPositionBottom", Buffer);
  return (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (0046D3D0) --------------------------------------------------------
int __userpurge sub_46D3D0@<eax>(int a1@<eax>, int a2@<edi>, int a3)
{
  OLECHAR *v4; // esi
  void (__stdcall *v5)(int, int, int *); // edx
  BSTR v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h] BYREF

  v8 = 0;
  v7 = SysAllocString(L"\n\t");
  v4 = SysAllocString(L"WindowPosition");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 188))(a1, v4, &v8);
  SysFreeString(v4);
  sub_46D1C0(v8, a3, a1);
  sub_4645D0(a1, v8, (int)v7);
  sub_4645D0(a1, a2, (int)v7);
  v5 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 84);
  a3 = 0;
  v5(a2, v8, &a3);
  if ( a3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a3 + 8))(a3);
  return (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
}

//----- (0046D480) --------------------------------------------------------
int __thiscall sub_46D480(int *this)
{
  return sub_46D110(this[6], this[4], this[2]);
}

//----- (0046D4A0) --------------------------------------------------------
_DWORD *__userpurge sub_46D4A0@<eax>(const WCHAR *a1@<eax>, const WCHAR *a2@<edi>, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result; // eax
  int v6; // edx
  int v7; // ebx
  __int16 v8; // cx
  int v9; // edx
  int v10; // ebx
  __int16 v11; // cx

  if ( !lstrcmpW(a2, L"ApplyFilter") )
  {
    result = (_DWORD *)(lstrcmpW(a1, L"yes") == 0);
    a3[7] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"AutoArrange") )
  {
    result = (_DWORD *)(lstrcmpW(a1, L"yes") == 0);
    a3[5] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"Filter") )
  {
    result = a3 + 15;
    v6 = 512;
    v7 = (char *)a1 - (char *)(a3 + 15);
    while ( v6 != -2147483134 )
    {
      v8 = *(_WORD *)((char *)result + v7);
      if ( !v8 )
        break;
      *(_WORD *)result = v8;
      result = (_DWORD *)((char *)result + 2);
      if ( !--v6 )
      {
        result = (_DWORD *)((char *)result - 2);
        *(_WORD *)result = 0;
        return result;
      }
    }
LABEL_37:
    *(_WORD *)result = 0;
    return result;
  }
  if ( !lstrcmpW(a2, L"FilterCaseSensitive") )
  {
    result = (_DWORD *)(lstrcmpW(a1, L"yes") == 0);
    a3[8] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"ShowGridlines") )
  {
    result = (_DWORD *)(lstrcmpW(a1, L"yes") == 0);
    a3[6] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"ShowHidden") )
  {
    result = (_DWORD *)sub_464560(a1);
    a3[4] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"ShowInGroups") )
  {
    result = (_DWORD *)sub_464560(a1);
    a3[3] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"SortAscending") )
  {
    result = (_DWORD *)sub_464560(a1);
    a3[2] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"SortMode") )
  {
    result = (_DWORD *)_wtoi(a1);
    *a3 = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"ViewMode") )
  {
    result = (_DWORD *)_wtoi(a1);
    a3[1] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"Locked") )
  {
    result = (_DWORD *)sub_464560(a1);
    *a4 = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"AddressLocked") )
  {
    result = (_DWORD *)sub_464560(a1);
    a4[1] = result;
    return result;
  }
  if ( !lstrcmpW(a2, L"UseCustomName") )
  {
    result = (_DWORD *)sub_464560(a1);
    a4[2] = result;
    return result;
  }
  result = (_DWORD *)lstrcmpW(a2, L"CustomName");
  if ( !result )
  {
    result = a4 + 3;
    v9 = 260;
    v10 = (char *)a1 - (char *)(a4 + 3);
    while ( v9 != -2147483386 )
    {
      v11 = *(_WORD *)((char *)result + v10);
      if ( !v11 )
        break;
      *(_WORD *)result = v11;
      result = (_DWORD *)((char *)result + 2);
      if ( !--v9 )
      {
        result = (_DWORD *)((char *)result - 2);
        *(_WORD *)result = 0;
        return result;
      }
    }
    goto LABEL_37;
  }
  return result;
}
// 46D6CA: conditional instruction was optimized away because edx.4!=0

//----- (0046D6E0) --------------------------------------------------------
int __fastcall sub_46D6E0(int a1, int a2, int a3)
{
  int v4; // ebx
  OLECHAR *v5; // esi
  OLECHAR *v6; // eax
  OLECHAR *v7; // eax
  OLECHAR *v8; // eax
  OLECHAR *v9; // eax
  OLECHAR *v10; // eax
  OLECHAR *v11; // eax
  OLECHAR *v12; // eax
  OLECHAR *v13; // eax
  OLECHAR *v14; // eax
  OLECHAR *v15; // eax
  OLECHAR *v16; // eax
  int v17; // edi
  OLECHAR *v18; // eax
  OLECHAR *v19; // eax
  OLECHAR *v20; // eax
  OLECHAR *v21; // eax
  OLECHAR *v22; // eax
  OLECHAR *v23; // eax
  OLECHAR *v24; // eax
  OLECHAR *v25; // eax
  OLECHAR *v26; // eax
  OLECHAR *v27; // eax
  OLECHAR *v28; // eax
  OLECHAR *v29; // eax
  OLECHAR *v30; // eax
  OLECHAR *v31; // eax
  OLECHAR *v32; // eax
  OLECHAR *v33; // eax
  OLECHAR *v34; // eax
  OLECHAR *v35; // eax
  OLECHAR *v36; // eax
  OLECHAR *v37; // eax
  OLECHAR *v38; // eax
  OLECHAR *v39; // eax
  OLECHAR *v40; // eax
  OLECHAR *v41; // eax
  OLECHAR *v42; // eax
  OLECHAR *v43; // eax
  OLECHAR *v44; // eax
  OLECHAR *v45; // eax
  OLECHAR *v46; // eax
  OLECHAR *v47; // eax
  OLECHAR *v48; // eax
  OLECHAR *v49; // eax
  OLECHAR *v50; // eax
  OLECHAR *v51; // eax
  OLECHAR *v52; // eax
  OLECHAR *v53; // eax
  OLECHAR *v54; // eax
  OLECHAR *v55; // eax
  OLECHAR *v56; // eax
  signed int v57; // esi
  int v58; // eax
  unsigned int v59; // eax
  int v60; // eax
  HMODULE ModuleHandleW; // eax
  void (__stdcall *v62)(int, BSTR, LRESULT *); // ecx
  int v63; // edi
  OLECHAR *v64; // eax
  void (__stdcall *v65)(int, BSTR, LRESULT *); // edx
  int v66; // edi
  void (__stdcall *v67)(int, BSTR, LRESULT *); // edx
  int v68; // edi
  void (__stdcall *v69)(int, BSTR, LRESULT *); // edx
  int v70; // edi
  int v71; // edi
  void (__stdcall *v72)(int, int, int *); // eax
  UINT v74; // [esp+98h] [ebp-33Ch]
  int v75; // [esp+B0h] [ebp-324h] BYREF
  BSTR v76; // [esp+B4h] [ebp-320h]
  int v77; // [esp+B8h] [ebp-31Ch] BYREF
  LRESULT v78; // [esp+BCh] [ebp-318h] BYREF
  int v79; // [esp+C0h] [ebp-314h] BYREF
  int v80; // [esp+C4h] [ebp-310h]
  WPARAM wParam; // [esp+C8h] [ebp-30Ch] BYREF
  int v82; // [esp+CCh] [ebp-308h]
  BSTR v83; // [esp+D0h] [ebp-304h]
  int pv[5]; // [esp+D4h] [ebp-300h] BYREF
  char v85; // [esp+E8h] [ebp-2ECh]
  char v86; // [esp+E9h] [ebp-2EBh]
  char v87; // [esp+EAh] [ebp-2EAh]
  __int16 v88[36]; // [esp+F0h] [ebp-2E4h] BYREF
  LPARAM lParam; // [esp+138h] [ebp-29Ch] BYREF
  int v90; // [esp+13Ch] [ebp-298h]
  wchar_t Buffer[32]; // [esp+14Ch] [ebp-288h] BYREF
  OLECHAR psz[32]; // [esp+18Ch] [ebp-248h] BYREF
  WCHAR v93[258]; // [esp+1CCh] [ebp-208h] BYREF

  v82 = a3;
  v4 = a2;
  v80 = a1;
  v79 = a2;
  v75 = 0;
  v77 = 0;
  v83 = SysAllocString(L"\n\t");
  v76 = SysAllocString(L"\n\t\t");
  v5 = SysAllocString(L"Settings");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)v4 + 188))(v4, v5, &v75);
  SysFreeString(v5);
  sub_4645D0(v4, v75, (int)v76);
  v6 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59392) )
    v6 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"AllowMultipleInstances", v6);
  sub_4645D0(v4, v75, (int)v76);
  v7 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59328) )
    v7 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"AlwaysOpenInNewTab", v7);
  sub_4645D0(v4, v75, (int)v76);
  v8 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59316) )
    v8 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"AlwaysShowTabBar", v8);
  sub_4645D0(v4, v75, (int)v76);
  v9 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59492) )
    v9 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"AutoArrangeGlobal", v9);
  sub_4645D0(v4, v75, (int)v76);
  v10 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59416) )
    v10 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"CheckBoxSelection", v10);
  sub_4645D0(v4, v75, (int)v76);
  v11 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59424) )
    v11 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"CloseMainWindowOnTabClose", v11);
  sub_4645D0(v4, v75, (int)v76);
  v12 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59348) )
    v12 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ConfirmCloseTabs", v12);
  sub_4645D0(v4, v75, (int)v76);
  v13 = aYes_0;
  if ( !*(_DWORD *)(a1 + 59336) )
    v13 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisableFolderSizesNetworkRemovable", v13);
  sub_4645D0(v4, v75, (int)v76);
  sub_464940(v4, (int)&v77, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisplayCentreColor");
  v78 = SendMessageW(*(HWND *)(a1 + 64), 0x806Bu, 0, 0);
  _itow_s((unsigned __int8)v78, ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"r", ::Buffer);
  _itow_s(BYTE1(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"g", ::Buffer);
  _itow_s(BYTE2(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"b", ::Buffer);
  (*(void (__stdcall **)(int))(*(_DWORD *)v77 + 8))(v77);
  v77 = 0;
  sub_4645D0(v4, v75, (int)v76);
  sub_464940(v4, (int)&v77, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisplayFont");
  SendMessageW(*(HWND *)(v80 + 64), 0x806Fu, (WPARAM)&wParam, 0);
  GetObjectW((HANDLE)wParam, 92, pv);
  _itow_s(pv[0], ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"Height", ::Buffer);
  _itow_s(pv[1], ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"Width", ::Buffer);
  _itow_s(pv[4], ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"Weight", ::Buffer);
  v14 = aYes_0;
  if ( !v85 )
    v14 = aNo_0;
  sub_464A60(v4, v77, (OLECHAR *)L"Italic", v14);
  v15 = aYes_0;
  if ( !v86 )
    v15 = aNo_0;
  sub_464A60(v4, v77, (OLECHAR *)L"Underline", v15);
  v16 = aYes_0;
  if ( !v87 )
    v16 = aNo_0;
  sub_464A60(v4, v77, (OLECHAR *)L"Strikeout", v16);
  sub_464A60(v4, v77, (OLECHAR *)L"Font", (OLECHAR *)v88);
  sub_4645D0(v4, v75, (int)v76);
  sub_464940(v4, (int)&v77, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisplaySurroundColor");
  v78 = SendMessageW(*(HWND *)(v80 + 64), 0x8067u, 0, 0);
  _itow_s((unsigned __int8)v78, ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"r", ::Buffer);
  _itow_s(BYTE1(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"g", ::Buffer);
  _itow_s(BYTE2(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"b", ::Buffer);
  (*(void (__stdcall **)(int))(*(_DWORD *)v77 + 8))(v77);
  v77 = 0;
  sub_4645D0(v4, v75, (int)v76);
  sub_464940(v4, (int)&v77, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisplayTextColor");
  v78 = SendMessageW(*(HWND *)(v80 + 64), 0x8071u, 0, 0);
  _itow_s((unsigned __int8)v78, ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"r", ::Buffer);
  _itow_s(BYTE1(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"g", ::Buffer);
  _itow_s(BYTE2(v78), ::Buffer, 0x40u, 10);
  sub_464A60(v4, v77, (OLECHAR *)L"b", ::Buffer);
  (*(void (__stdcall **)(int))(*(_DWORD *)v77 + 8))(v77);
  v77 = 0;
  sub_4645D0(v4, v75, (int)v76);
  v17 = v80;
  _itow_s(*(_DWORD *)(v80 + 5584), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DisplayWindowHeight", Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v18 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59400) )
    v18 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"DoubleClickTabClose", v18);
  sub_4645D0(v4, v75, (int)v76);
  v19 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59364) )
    v19 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ExtendTabControl", v19);
  sub_4645D0(v4, v75, (int)v76);
  v20 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59396) )
    v20 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ForceSameTabWidth", v20);
  sub_4645D0(v4, v75, (int)v76);
  v21 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59420) )
    v21 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ForceSize", v21);
  sub_4645D0(v4, v75, (int)v76);
  v22 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59404) )
    v22 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"HandleZipFiles", v22);
  sub_4645D0(v4, v75, (int)v76);
  v23 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59512) )
    v23 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"HideLinkExtensionGlobal", v23);
  sub_4645D0(v4, v75, (int)v76);
  v24 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59508) )
    v24 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"HideSystemFilesGlobal", v24);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 59472), ::Buffer, 0x40u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"InfoTipType", ::Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v25 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59408) )
    v25 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"InsertSorted", v25);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 5572), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"Language", Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v26 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59448) )
    v26 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"LargeToolbarIcons", v26);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 5628), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"LastSelectedTab", Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v27 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59360) )
    v27 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"LockToolbars", v27);
  sub_4645D0(v4, v75, (int)v76);
  v28 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59344) )
    v28 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"NextToCurrent", v28);
  sub_4645D0(v4, v75, (int)v76);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"NewTabDirectory", (OLECHAR *)(v17 + 4532));
  sub_4645D0(v4, v75, (int)v76);
  v29 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59384) )
    v29 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"OneClickActivate", v29);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 59388), ::Buffer, 0x40u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"OneClickActivateHoverTime", ::Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v30 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59412) )
    v30 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"OverwriteExistingFilesConfirmation", v30);
  sub_4645D0(v4, v75, (int)v76);
  v31 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59452) )
    v31 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"PlayNavigationSound", v31);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 59464), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ReplaceExplorerMode", Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v32 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59292) )
    v32 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowAddressBar", v32);
  sub_4645D0(v4, v75, (int)v76);
  v33 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59312) )
    v33 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowApplicationToolbar", v33);
  sub_4645D0(v4, v75, (int)v76);
  v34 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59304) )
    v34 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowBookmarksToolbar", v34);
  sub_4645D0(v4, v75, (int)v76);
  v35 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59308) )
    v35 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowDrivesToolbar", v35);
  sub_4645D0(v4, v75, (int)v76);
  v36 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59296) )
    v36 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowDisplayWindow", v36);
  sub_4645D0(v4, v75, (int)v76);
  v37 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59484) )
    v37 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowExtensions", v37);
  sub_4645D0(v4, v75, (int)v76);
  v38 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59380) )
    v38 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowFilePreviews", v38);
  sub_4645D0(v4, v75, (int)v76);
  v39 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59288) )
    v39 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowFolders", v39);
  sub_4645D0(v4, v75, (int)v76);
  v40 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59332) )
    v40 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowFolderSizes", v40);
  sub_4645D0(v4, v75, (int)v76);
  v41 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59500) )
    v41 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowFriendlyDates", v41);
  sub_4645D0(v4, v75, (int)v76);
  v42 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59324) )
    v42 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowFullTitlePath", v42);
  sub_4645D0(v4, v75, (int)v76);
  v43 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59504) )
    v43 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowGridlinesGlobal", v43);
  sub_4645D0(v4, v75, (int)v76);
  v44 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59480) )
    v44 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowHiddenGlobal", v44);
  sub_4645D0(v4, v75, (int)v76);
  v45 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59468) )
    v45 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowInfoTips", v45);
  sub_4645D0(v4, v75, (int)v76);
  v46 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59488) )
    v46 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowInGroupsGlobal", v46);
  sub_4645D0(v4, v75, (int)v76);
  v47 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59376) )
    v47 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowPrivilegeLevelInTitleBar", v47);
  sub_4645D0(v4, v75, (int)v76);
  v48 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59284) )
    v48 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowStatusBar", v48);
  sub_4645D0(v4, v75, (int)v76);
  v49 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59428) )
    v49 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowTabBarAtBottom", v49);
  sub_4645D0(v4, v75, (int)v76);
  v50 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59432) )
    v50 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowTaskbarThumbnails", v50);
  sub_4645D0(v4, v75, (int)v76);
  v51 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59300) )
    v51 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowToolbar", v51);
  sub_4645D0(v4, v75, (int)v76);
  v52 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59372) )
    v52 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ShowUserNameTitleBar", v52);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 59456), ::Buffer, 0x40u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"SizeDisplayFormat", ::Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v53 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59496) )
    v53 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"SortAscendingGlobal", v53);
  sub_4645D0(v4, v75, (int)v76);
  _itow_s(*(_DWORD *)(v17 + 59460), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"StartupMode", Buffer);
  sub_4645D0(v4, v75, (int)v76);
  v54 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59440) )
    v54 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"SynchronizeTreeview", v54);
  sub_4645D0(v4, v75, (int)v76);
  v55 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59444) )
    v55 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"TVAutoExpandSelected", v55);
  sub_4645D0(v4, v75, (int)v76);
  v56 = aYes_0;
  if ( !*(_DWORD *)(v17 + 59368) )
    v56 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"UseFullRowSelect", v56);
  sub_4645D0(v4, v75, (int)v76);
  sub_464940(v4, (int)&v77, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ToolbarState");
  v57 = 0;
  v78 = SendMessageW(*(HWND *)(v17 + 88), 0x418u, 0, 0);
  if ( v78 > 0 )
  {
    do
    {
      SendMessageW(*(HWND *)(v80 + 88), 0x417u, v57, (LPARAM)&lParam);
      sub_401000(0x20u, psz, L"Button%d", v57);
      v58 = v90;
      if ( !v90 )
        v58 = 45001;
      v59 = v58 - 45001;
      if ( v59 > 0x15 )
        v60 = 0;
      else
        v60 = sub_49A6A0(v59);
      v74 = v60;
      ModuleHandleW = GetModuleHandleW(0);
      LoadStringW(ModuleHandleW, v74, v93, 256);
      sub_464A60(v79, v77, psz, v93);
      ++v57;
    }
    while ( v57 < v78 );
    v4 = v79;
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v77 + 8))(v77);
  v62 = *(void (__stdcall **)(int, BSTR, LRESULT *))(*(_DWORD *)v4 + 196);
  v63 = v75;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v62(v4, v76, &v78);
  (*(void (__stdcall **)(int, LRESULT, int *))(*(_DWORD *)v63 + 84))(v63, v78, &v79);
  if ( v78 )
    (*(void (__stdcall **)(LRESULT))(*(_DWORD *)v78 + 8))(v78);
  v78 = 0;
  if ( v79 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v79 + 8))(v79);
  v64 = aYes_0;
  if ( !*(_DWORD *)(v80 + 59352) )
    v64 = aNo_0;
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"TreeViewDelayEnabled", v64);
  v65 = *(void (__stdcall **)(int, BSTR, LRESULT *))(*(_DWORD *)v4 + 196);
  v66 = v75;
  v78 = 0;
  v79 = 0;
  v65(v4, v76, &v78);
  (*(void (__stdcall **)(int, LRESULT, int *))(*(_DWORD *)v66 + 84))(v66, v78, &v79);
  if ( v78 )
    (*(void (__stdcall **)(LRESULT))(*(_DWORD *)v78 + 8))(v78);
  v78 = 0;
  if ( v79 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v79 + 8))(v79);
  _itow_s(*(_DWORD *)(v80 + 5616), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"TreeViewWidth", Buffer);
  v67 = *(void (__stdcall **)(int, BSTR, LRESULT *))(*(_DWORD *)v4 + 196);
  v68 = v75;
  v78 = 0;
  v79 = 0;
  v67(v4, v76, &v78);
  (*(void (__stdcall **)(int, LRESULT, int *))(*(_DWORD *)v68 + 84))(v68, v78, &v79);
  if ( v78 )
    (*(void (__stdcall **)(LRESULT))(*(_DWORD *)v78 + 8))(v78);
  v78 = 0;
  if ( v79 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v79 + 8))(v79);
  _itow_s(*(_DWORD *)(v80 + 59476), Buffer, 0x20u, 10);
  sub_464660(v4, v75, (OLECHAR *)L"Setting", (OLECHAR *)L"ViewModeGlobal", Buffer);
  v69 = *(void (__stdcall **)(int, BSTR, LRESULT *))(*(_DWORD *)v4 + 196);
  v70 = v75;
  v78 = 0;
  v79 = 0;
  v69(v4, v83, &v78);
  (*(void (__stdcall **)(int, LRESULT, int *))(*(_DWORD *)v70 + 84))(v70, v78, &v79);
  if ( v78 )
    (*(void (__stdcall **)(LRESULT))(*(_DWORD *)v78 + 8))(v78);
  v78 = 0;
  if ( v79 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v79 + 8))(v79);
  v71 = v82;
  v72 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)v82 + 84);
  v79 = 0;
  v72(v82, v75, &v79);
  if ( v79 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v79 + 8))(v79);
  (*(void (__stdcall **)(int))(*(_DWORD *)v75 + 8))(v75);
  v75 = 0;
  return sub_46D3D0(v4, v71, v80);
}
// 4C45E0: using guessed type wchar_t aButtonD[9];
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 4EFC90: using guessed type OLECHAR Buffer[64];
// 46D6E0: using guessed type OLECHAR var_2E4[36];

//----- (0046EC80) --------------------------------------------------------
int __thiscall sub_46EC80(int *this)
{
  return sub_46D6E0(this[2], this[4], this[6]);
}

//----- (0046EC90) --------------------------------------------------------
unsigned int __fastcall sub_46EC90(int a1, const WCHAR *a2, const WCHAR *a3, const WCHAR *lpWideCharStr)
{
  int v6; // ecx
  CHAR *v7; // edx
  unsigned int result; // eax
  int v9; // edi
  int j; // edi
  int v11; // edi
  int i; // esi
  LPCWSTR v13; // edi
  int v14; // edx
  char *v15; // ebx
  __int16 v16; // cx
  unsigned int v17; // [esp+8h] [ebp-254h] BYREF
  unsigned int v18; // [esp+Ch] [ebp-250h] BYREF
  unsigned int v19; // [esp+10h] [ebp-24Ch] BYREF
  int v20; // [esp+14h] [ebp-248h] BYREF
  int v21; // [esp+18h] [ebp-244h] BYREF
  int v22; // [esp+1Ch] [ebp-240h] BYREF
  int v23; // [esp+20h] [ebp-23Ch] BYREF
  LPCWSTR v24; // [esp+24h] [ebp-238h] BYREF
  LPCWSTR lpString1; // [esp+28h] [ebp-234h] BYREF
  WINDOWPLACEMENT wndpl; // [esp+2Ch] [ebp-230h] BYREF
  CHAR MultiByteStr[512]; // [esp+58h] [ebp-204h] BYREF

  lpString1 = a3;
  WideCharToMultiByte(0, 0, lpWideCharStr, -1, MultiByteStr, 512, 0, 0);
  v6 = (unsigned __int8)MultiByteStr[0];
  v7 = MultiByteStr;
  result = 5381;
  if ( MultiByteStr[0] )
  {
    do
    {
      ++v7;
      v9 = v6 + 32 * result;
      v6 = (unsigned __int8)*v7;
      result += v9;
    }
    while ( *v7 );
    if ( result > 0x7674C254 )
    {
      if ( result > 0xCE783598 )
      {
        if ( result > 0xE15C9D5D )
        {
          if ( result > 0xF452395C )
          {
            switch ( result )
            {
              case 0xFB1A605F:
                result = sub_464840((int)lpString1);
                *(_DWORD *)(a1 + 5664) = result;
                break;
              case 0xFCAFEEAE:
                result = sub_464560(a2);
                *(_DWORD *)(a1 + 59488) = result;
                break;
              case 0xFDC88F50:
                result = _wtoi(a2);
                *(_DWORD *)(a1 + 5616) = result;
                break;
            }
          }
          else
          {
            switch ( result )
            {
              case 0xF452395C:
                result = lstrcmpW(a2, L"yes") == 0;
                *(_DWORD *)(a1 + 59428) = result;
                break;
              case 0xE50EFE54:
                result = sub_464560(a2);
                *(_DWORD *)(a1 + 59360) = result;
                break;
              case 0xF2AF1973:
                result = sub_464560(a2);
                *(_DWORD *)(a1 + 59376) = result;
                break;
              case 0xF4407AC5:
                result = sub_464560(a2);
                *(_DWORD *)(a1 + 59364) = result;
                break;
            }
          }
        }
        else if ( result == -514024099 )
        {
          result = lstrcmpW(a2, L"yes") == 0;
          *(_DWORD *)(a1 + 59368) = result;
        }
        else if ( result > 0xD4CB11FB )
        {
          switch ( result )
          {
            case 0xDB9FB3B0:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59332) = result;
              break;
            case 0xDF22B9D6:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59484) = result;
              break;
            case 0xDF234196:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 59476) = result;
              break;
          }
        }
        else
        {
          switch ( result )
          {
            case 0xD4CB11FB:
              result = a1 + 4532;
              v14 = 260;
              v15 = (char *)a2 - a1 - 4532;
              while ( v14 != -2147483386 )
              {
                v16 = *(_WORD *)&v15[result];
                if ( !v16 )
                  break;
                *(_WORD *)result = v16;
                result += 2;
                if ( !--v14 )
                {
                  result -= 2;
                  *(_WORD *)result = 0;
                  return result;
                }
              }
              *(_WORD *)result = 0;
              break;
            case 0xD230A5A9:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 5572) = result;
              *(_DWORD *)(a1 + 5608) = 1;
              break;
            case 0xD37C201F:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 59456) = result;
              break;
            case 0xD3DF567F:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59284) = result;
              break;
          }
        }
      }
      else if ( result == -830982760 )
      {
        result = lstrcmpW(a2, L"yes") == 0;
        *(_DWORD *)(a1 + 59392) = result;
      }
      else if ( result > 0x9D29B993 )
      {
        if ( result > 0xC4DDB601 )
        {
          switch ( result )
          {
            case 0xC8A89AC0:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 59472) = result;
              break;
            case 0xCAE71A7B:
              v13 = lpString1;
              *(_DWORD *)(a1 + 5656) = *sub_464D20((int)lpString1, &v18);
              result = (unsigned int)sub_464D20((int)v13, &v19);
              *(_DWORD *)(a1 + 5656) = *(_DWORD *)result;
              break;
            case 0xCCD46DF9:
              v11 = a1 + 60388;
              v23 = 0;
              v22 = 0;
              sub_415F10(a1 + 60388);
              (*(void (__stdcall **)(LPCWSTR, int *))(*(_DWORD *)lpString1 + 68))(lpString1, &v22);
              result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v22 + 44))(v22, &v21);
              for ( i = 1; i < v21; ++i )
              {
                (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v22 + 40))(v22, i, &v23);
                (*(void (__stdcall **)(int, int *))(*(_DWORD *)v23 + 28))(v23, &v20);
                (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v23 + 104))(v23, &v24);
                if ( lstrcmpiW(v24, L"Separator") )
                {
                  if ( lstrcmpiW(v24, L"Back") )
                  {
                    if ( lstrcmpiW(v24, L"Forward") )
                    {
                      if ( lstrcmpiW(v24, L"Up") )
                      {
                        if ( lstrcmpiW(v24, L"Folders") )
                        {
                          if ( lstrcmpiW(v24, L"Copy To") )
                          {
                            if ( lstrcmpiW(v24, L"Move To") )
                            {
                              if ( lstrcmpiW(v24, L"New Folder") )
                              {
                                if ( lstrcmpiW(v24, L"Copy") )
                                {
                                  if ( lstrcmpiW(v24, L"Cut") )
                                  {
                                    if ( lstrcmpiW(v24, L"Paste") )
                                    {
                                      if ( lstrcmpiW(v24, L"Delete") )
                                      {
                                        if ( lstrcmpiW(v24, L"Delete Permanently") )
                                        {
                                          if ( lstrcmpiW(v24, L"Views") )
                                          {
                                            if ( lstrcmpiW(v24, L"Search") )
                                            {
                                              if ( lstrcmpiW(v24, L"Properties") )
                                              {
                                                if ( lstrcmpiW(v24, L"Refresh") )
                                                {
                                                  if ( lstrcmpiW(v24, L"Bookmark the current tab") )
                                                  {
                                                    if ( lstrcmpiW(v24, L"Organize Bookmarks") )
                                                    {
                                                      if ( lstrcmpiW(v24, L"Create a new tab") )
                                                      {
                                                        if ( !lstrcmpiW(v24, L"Show Command Prompt") )
                                                          lpString1 = (LPCWSTR)45020;
                                                      }
                                                      else
                                                      {
                                                        lpString1 = (LPCWSTR)45019;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      lpString1 = (LPCWSTR)45021;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    lpString1 = (LPCWSTR)45018;
                                                  }
                                                }
                                                else
                                                {
                                                  lpString1 = (LPCWSTR)45017;
                                                }
                                              }
                                              else
                                              {
                                                lpString1 = (LPCWSTR)45015;
                                              }
                                            }
                                            else
                                            {
                                              lpString1 = (LPCWSTR)45014;
                                            }
                                          }
                                          else
                                          {
                                            lpString1 = (LPCWSTR)45013;
                                          }
                                        }
                                        else
                                        {
                                          lpString1 = (LPCWSTR)45022;
                                        }
                                      }
                                      else
                                      {
                                        lpString1 = (LPCWSTR)45012;
                                      }
                                    }
                                    else
                                    {
                                      lpString1 = (LPCWSTR)45011;
                                    }
                                  }
                                  else
                                  {
                                    lpString1 = (LPCWSTR)45010;
                                  }
                                }
                                else
                                {
                                  lpString1 = (LPCWSTR)45009;
                                }
                              }
                              else
                              {
                                lpString1 = (LPCWSTR)45008;
                              }
                            }
                            else
                            {
                              lpString1 = (LPCWSTR)45007;
                            }
                          }
                          else
                          {
                            lpString1 = (LPCWSTR)45006;
                          }
                        }
                        else
                        {
                          lpString1 = (LPCWSTR)45005;
                        }
                      }
                      else
                      {
                        lpString1 = (LPCWSTR)45004;
                      }
                    }
                    else
                    {
                      lpString1 = (LPCWSTR)45003;
                    }
                  }
                  else
                  {
                    lpString1 = (LPCWSTR)45002;
                  }
                }
                else
                {
                  lpString1 = (LPCWSTR)45001;
                }
                result = (unsigned int)sub_40B7B0((int)&lpString1, v11);
              }
              break;
          }
        }
        else
        {
          switch ( result )
          {
            case 0xC4DDB601:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59292) = result;
              break;
            case 0xB3E39EB2:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59468) = result;
              break;
            case 0xB4350631:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 59388) = result;
              break;
            case 0xC4B4DE9A:
              v22 = 0;
              v23 = 0;
              v21 = 0;
              (*(void (__stdcall **)(LPCWSTR, int *))(*(_DWORD *)lpString1 + 68))(lpString1, &v23);
              (*(void (__stdcall **)(int, int *))(*(_DWORD *)v23 + 44))(v23, &v20);
              for ( j = 1; j < v20; ++j )
              {
                (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v23 + 40))(v23, j, &v22);
                (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v22 + 28))(v22, &lpString1);
                (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v22 + 104))(v22, &v24);
                if ( lstrcmpW(lpString1, L"Left") )
                {
                  if ( lstrcmpW(lpString1, L"Top") )
                  {
                    if ( lstrcmpW(lpString1, L"Right") )
                    {
                      if ( lstrcmpW(lpString1, L"Bottom") )
                      {
                        if ( !lstrcmpW(lpString1, L"Maximized") )
                          v21 = sub_464560(v24);
                      }
                      else
                      {
                        wndpl.rcNormalPosition.bottom = _wtoi(v24);
                      }
                    }
                    else
                    {
                      wndpl.rcNormalPosition.right = _wtoi(v24);
                    }
                  }
                  else
                  {
                    wndpl.rcNormalPosition.top = _wtoi(v24);
                  }
                }
                else
                {
                  wndpl.rcNormalPosition.left = _wtoi(v24);
                }
              }
              wndpl.length = 44;
              wndpl.showCmd = 0;
              if ( v21 )
                wndpl.showCmd = 3;
              return SetWindowPlacement(*(HWND *)(a1 + 52), &wndpl);
          }
        }
      }
      else if ( result == -1658209901 )
      {
        result = lstrcmpW(a2, L"yes") == 0;
        *(_DWORD *)(a1 + 59348) = result;
      }
      else if ( result > 0x906146F7 )
      {
        switch ( result )
        {
          case 0x9B4EE1AA:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59496) = result;
            break;
          case 0x9B9BCF2A:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59336) = result;
            break;
          case 0x9C0E4F7D:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59372) = result;
            break;
        }
      }
      else if ( result == -1872673033 )
      {
        result = _wtoi(a2);
        *(_DWORD *)(a1 + 59464) = result;
      }
      else if ( result > 0x834852A5 )
      {
        if ( result == -1979391215 )
        {
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59396) = result;
        }
      }
      else
      {
        switch ( result )
        {
          case 0x834852A5:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59432) = result;
            break;
          case 0x783F4F6Cu:
            result = _wtoi(a2);
            *(_DWORD *)(a1 + 5584) = result;
            break;
          case 0x82556F0A:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59352) = result;
            break;
        }
      }
    }
    else if ( result == 1987363412 )
    {
      result = lstrcmpW(a2, L"yes") == 0;
      *(_DWORD *)(a1 + 59452) = result;
    }
    else if ( result > 0x42F48700 )
    {
      if ( result > 0x65CCF038 )
      {
        if ( result > 0x6E708939 )
        {
          switch ( result )
          {
            case 0x6F3C3233u:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59400) = result;
              break;
            case 0x6F89A708u:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59324) = result;
              break;
            case 0x725F7FCFu:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59420) = result;
              break;
          }
        }
        else
        {
          switch ( result )
          {
            case 0x6E708939u:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59300) = result;
              break;
            case 0x6611BC79u:
              result = _wtoi(a2);
              *(_DWORD *)(a1 + 5628) = result;
              break;
            case 0x6BBD3F3Cu:
              result = *sub_464D20((int)lpString1, &v17);
              *(_DWORD *)(a1 + 5660) = result;
              break;
            case 0x6D5EAD1Bu:
              result = sub_464560(a2);
              *(_DWORD *)(a1 + 59380) = result;
              break;
          }
        }
      }
      else if ( result == 1707929656 )
      {
        result = lstrcmpW(a2, L"yes") == 0;
        *(_DWORD *)(a1 + 59504) = result;
      }
      else if ( result > 0x501FDC9D )
      {
        switch ( result )
        {
          case 0x60E0C373u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59412) = result;
            break;
          case 0x6361D848u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59508) = result;
            break;
          case 0x6499988Cu:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59440) = result;
            break;
        }
      }
      else
      {
        switch ( result )
        {
          case 0x501FDC9Du:
            result = _wtoi(a2);
            *(_DWORD *)(a1 + 59460) = result;
            break;
          case 0x44A77D42u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59424) = result;
            break;
          case 0x48823982u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59304) = result;
            break;
          case 0x493ED671u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59444) = result;
            break;
        }
      }
    }
    else if ( result == 1123321600 )
    {
      result = lstrcmpW(a2, L"yes") == 0;
      *(_DWORD *)(a1 + 59328) = result;
    }
    else if ( result > 0x21457403 )
    {
      if ( result > 0x3FF6377B )
      {
        switch ( result )
        {
          case 0x40072DF7u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59404) = result;
            break;
          case 0x421FAC2Bu:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59408) = result;
            break;
          case 0x42A60BBEu:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59384) = result;
            break;
        }
      }
      else
      {
        switch ( result )
        {
          case 0x3FF6377Bu:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59512) = result;
            break;
          case 0x2C4BCE0Au:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59344) = result;
            break;
          case 0x35970C86u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59308) = result;
            break;
          case 0x38869915u:
            result = sub_464560(a2);
            *(_DWORD *)(a1 + 59288) = result;
            break;
        }
      }
    }
    else if ( result == 558199811 )
    {
      result = sub_464560(a2);
      *(_DWORD *)(a1 + 59480) = result;
    }
    else if ( result > 0x14F219F4 )
    {
      switch ( result )
      {
        case 0x159F3E52u:
          result = (unsigned int)sub_464B40((int)lpString1);
          *(_DWORD *)(a1 + 5668) = result;
          break;
        case 0x1B385692u:
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59416) = result;
          break;
        case 0x1BDF6BD4u:
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59500) = result;
          break;
      }
    }
    else if ( result == 351410676 )
    {
      result = sub_464560(a2);
      *(_DWORD *)(a1 + 59296) = result;
    }
    else if ( result > 0x8D25F43 )
    {
      if ( result == 151507311 )
      {
        result = sub_464560(a2);
        *(_DWORD *)(a1 + 59492) = result;
      }
    }
    else
    {
      switch ( result )
      {
        case 0x8D25F43u:
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59316) = result;
          break;
        case 0xA63E9Fu:
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59448) = result;
          break;
        case 0x60DD9EDu:
          result = sub_464560(a2);
          *(_DWORD *)(a1 + 59312) = result;
          break;
      }
    }
  }
  return result;
}
// 46FBBB: conditional instruction was optimized away because edx.4!=0

//----- (0046FDB0) --------------------------------------------------------
void __userpurge sub_46FDB0(int a1@<ecx>, int a2@<esi>, int a3)
{
  int v4; // ebx
  int v5; // edx
  __int16 *v6; // eax
  BSTR v7; // eax
  void (__stdcall *v8)(int, BSTR, int *); // ecx
  OLECHAR *v9; // ebx
  OLECHAR *v10; // eax
  OLECHAR *v11; // eax
  unsigned __int8 *v12; // ebx
  OLECHAR *bstrString; // [esp+Ch] [ebp-120h]
  int v14; // [esp+10h] [ebp-11Ch] BYREF
  OLECHAR *v15; // [esp+14h] [ebp-118h]
  int v16; // [esp+18h] [ebp-114h] BYREF
  int v17; // [esp+1Ch] [ebp-110h] BYREF
  __int16 psz[130]; // [esp+20h] [ebp-10Ch] BYREF

  v15 = (OLECHAR *)a3;
  v17 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  sub_401000(0x80u, (wchar_t *)psz, L"\n");
  v4 = 2;
  do
  {
    v5 = 128;
    v6 = psz;
    while ( *v6 )
    {
      ++v6;
      if ( !--v5 )
        goto LABEL_7;
    }
    sub_4AA520(v5, (int)L"\t", &psz[128 - v5]);
LABEL_7:
    --v4;
  }
  while ( v4 );
  v7 = SysAllocString((const OLECHAR *)psz);
  v8 = *(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a2 + 196);
  v9 = v7;
  v16 = 0;
  v14 = 0;
  v8(a2, v7, &v16);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a1 + 84))(a1, v16, &v14);
  if ( v16 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  v16 = 0;
  if ( v14 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
  SysFreeString(v9);
  v10 = v15;
  if ( *((_DWORD *)v15 + 5) >= 8u )
    v10 = *(OLECHAR **)v15;
  sub_464940(a2, (int)&v17, a1, (OLECHAR *)L"ColorRule", v10);
  v11 = v15 + 14;
  if ( *((_DWORD *)v15 + 12) >= 8u )
    v11 = *(OLECHAR **)v11;
  sub_464A60(a2, v17, (OLECHAR *)L"FilenamePattern", v11);
  v12 = (unsigned __int8 *)v15;
  _itow_s(*((_DWORD *)v15 + 14), Buffer, 0x40u, 10);
  sub_464A60(a2, v17, (OLECHAR *)L"Attributes", Buffer);
  _itow_s(v12[60], Buffer, 0x40u, 10);
  sub_464A60(a2, v17, (OLECHAR *)L"r", Buffer);
  _itow_s(v12[61], Buffer, 0x40u, 10);
  sub_464A60(a2, v17, (OLECHAR *)L"g", Buffer);
  _itow_s(v12[62], Buffer, 0x40u, 10);
  sub_464A60(a2, v17, (OLECHAR *)L"b", Buffer);
  (*(void (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
  v17 = 0;
  SysFreeString(bstrString);
}
// 46FE23: conditional instruction was optimized away because edx.4!=0
// 4C4F6C: using guessed type wchar_t asc_4C4F6C[2];
// 4C4F70: using guessed type wchar_t asc_4C4F70[2];
// 4EFC90: using guessed type OLECHAR Buffer[64];
// 46FDB0: using guessed type OLECHAR psz[130];

//----- (00470000) --------------------------------------------------------
void __thiscall sub_470000(void *this, int a2, int a3, OLECHAR *a4)
{
  int v4; // ebx
  int v5; // edx
  __int16 *v6; // eax
  BSTR v7; // eax
  void (__stdcall *v8)(int, BSTR, int *); // ecx
  OLECHAR *v9; // ebx
  OLECHAR *v10; // ebx
  OLECHAR *v11; // ebx
  OLECHAR *v12; // eax
  int v13; // [esp+24h] [ebp-124h] BYREF
  int v14; // [esp+28h] [ebp-120h] BYREF
  OLECHAR *v15; // [esp+2Ch] [ebp-11Ch]
  int v16; // [esp+30h] [ebp-118h] BYREF
  void *v17; // [esp+34h] [ebp-114h]
  BSTR bstrString; // [esp+38h] [ebp-110h]
  int v19; // [esp+3Ch] [ebp-10Ch]
  __int16 psz[130]; // [esp+40h] [ebp-108h] BYREF

  v17 = this;
  v19 = a3;
  v15 = a4;
  v13 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  sub_401000(0x80u, (wchar_t *)psz, L"\n");
  v4 = 2;
  do
  {
    v5 = 128;
    v6 = psz;
    while ( *v6 )
    {
      ++v6;
      if ( !--v5 )
        goto LABEL_7;
    }
    sub_4AA520(v5, (int)L"\t", &psz[128 - v5]);
LABEL_7:
    --v4;
  }
  while ( v4 );
  v7 = SysAllocString((const OLECHAR *)psz);
  v8 = *(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a2 + 196);
  v9 = v7;
  v14 = 0;
  v16 = 0;
  v8(a2, v7, &v14);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a3 + 84))(a3, v14, &v16);
  if ( v14 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
  v14 = 0;
  if ( v16 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  SysFreeString(v9);
  v10 = v15;
  sub_464940(a2, (int)&v13, a3, (OLECHAR *)L"ApplicationButton", v15);
  sub_464A60(a2, v13, (OLECHAR *)L"Command", v10 + 512);
  v11 = v15;
  v12 = aYes_0;
  if ( !*((_DWORD *)v15 + 512) )
    v12 = aNo_0;
  sub_464A60(a2, v13, (OLECHAR *)L"ShowNameOnToolbar", v12);
  if ( *((_DWORD *)v11 + 513) )
    sub_470000(v17, a2, v19, *((OLECHAR **)v11 + 513));
  (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
  v13 = 0;
  SysFreeString(bstrString);
}
// 470080: conditional instruction was optimized away because edx.4!=0
// 4C4E7C: using guessed type wchar_t asc_4C4E7C[2];
// 4C4E80: using guessed type wchar_t asc_4C4E80[2];
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 470000: using guessed type OLECHAR psz[130];

//----- (004701C0) --------------------------------------------------------
void __userpurge sub_4701C0(int a1@<edi>, OLECHAR **a2, int a3)
{
  OLECHAR *v3; // ebx
  OLECHAR *v4; // esi
  void (__stdcall *v5)(int, int, OLECHAR ***); // eax
  int v6; // [esp+8h] [ebp-4h] BYREF

  v6 = 0;
  v3 = SysAllocString(L"\n\t");
  sub_4645D0(a1, a3, (int)v3);
  v4 = SysAllocString(L"ApplicationToolbar");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 188))(a1, v4, &v6);
  SysFreeString(v4);
  if ( a2[15101] )
    sub_470000(a2, a1, v6, a2[15101]);
  sub_4645D0(a1, v6, (int)v3);
  v5 = *(void (__stdcall **)(int, int, OLECHAR ***))(*(_DWORD *)a3 + 84);
  a2 = 0;
  v5(a3, v6, &a2);
  if ( a2 )
    (*((void (__stdcall **)(OLECHAR **))*a2 + 2))(a2);
  (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
  v6 = 0;
  SysFreeString(v3);
}

//----- (00470280) --------------------------------------------------------
int __thiscall sub_470280(void *this, int a2)
{
  int v2; // esi
  int (__stdcall *v3)(int, int *); // edx
  int v4; // ebx
  int v5; // edi
  int result; // eax
  char *v7; // eax
  int v8; // edx
  int v9; // esi
  __int16 v10; // cx
  char *v11; // eax
  int v12; // edx
  int v13; // esi
  __int16 v14; // cx
  int v16; // [esp+14h] [ebp-824h] BYREF
  int v17; // [esp+18h] [ebp-820h]
  int v18; // [esp+1Ch] [ebp-81Ch] BYREF
  LPCWSTR lpString1; // [esp+20h] [ebp-818h] BYREF
  LPCWSTR v20; // [esp+24h] [ebp-814h] BYREF
  int v21; // [esp+28h] [ebp-810h] BYREF
  int v22; // [esp+2Ch] [ebp-80Ch]
  int v23; // [esp+30h] [ebp-808h] BYREF
  char v24[1024]; // [esp+34h] [ebp-804h] BYREF
  char v25[1024]; // [esp+434h] [ebp-404h] BYREF

  v2 = a2;
  v3 = *(int (__stdcall **)(int, int *))(*(_DWORD *)a2 + 68);
  v4 = 0;
  v21 = 0;
  v18 = 0;
  v23 = 0;
  v17 = 0;
  v5 = 1;
  result = v3(a2, &v21);
  if ( result >= 0 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v21 + 44))(v21, &v16);
    v22 = 0;
    if ( v16 > 0 )
    {
      do
      {
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v21 + 40))(v21, v22, &v18);
        (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v18 + 28))(v18, &lpString1);
        (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v18 + 104))(v18, &v20);
        if ( lstrcmpiW(lpString1, L"Name") )
        {
          if ( lstrcmpiW(lpString1, L"Command") )
          {
            if ( !lstrcmpiW(lpString1, L"ShowNameOnToolbar") )
              v5 = lstrcmpW(v20, L"yes") == 0;
          }
          else
          {
            v11 = v25;
            v12 = 512;
            v13 = (char *)v20 - v25;
            while ( v12 != -2147483134 )
            {
              v14 = *(_WORD *)&v11[v13];
              if ( !v14 )
                break;
              *(_WORD *)v11 = v14;
              v11 += 2;
              if ( !--v12 )
              {
                *((_WORD *)v11 - 1) = 0;
                v17 = 1;
                goto LABEL_19;
              }
            }
            *(_WORD *)v11 = 0;
            v17 = 1;
          }
        }
        else
        {
          v7 = v24;
          v8 = 512;
          v9 = (char *)v20 - v24;
          while ( v8 != -2147483134 )
          {
            v10 = *(_WORD *)&v7[v9];
            if ( !v10 )
              break;
            *(_WORD *)v7 = v10;
            v7 += 2;
            if ( !--v8 )
            {
              *((_WORD *)v7 - 1) = 0;
              v4 = 1;
              goto LABEL_19;
            }
          }
          *(_WORD *)v7 = 0;
          v4 = 1;
        }
LABEL_19:
        ++v22;
      }
      while ( v22 < v16 );
      if ( v4 && v17 )
        sub_4A8DD0((int)this, (int)v24, (int)v25, v5);
      v2 = a2;
    }
    result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v2 + 64))(v2, &v23);
    if ( !result )
    {
      result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v23 + 64))(v23, &v23);
      if ( !result )
        return sub_470280(this, v23);
    }
  }
  return result;
}
// 47039F: conditional instruction was optimized away because edx.4!=0
// 470410: conditional instruction was optimized away because edx.4!=0

//----- (004704F0) --------------------------------------------------------
void __userpurge sub_4704F0(int a1@<esi>, void *a2)
{
  OLECHAR *v2; // edi
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = 0;
  if ( a1 )
  {
    v2 = SysAllocString(L"//ApplicationButton");
    if ( !(*(int (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 148))(a1, v2, &v3) )
      sub_470280(a2, v3);
    if ( v2 )
      SysFreeString(v2);
    if ( v3 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  }
}

//----- (00470550) --------------------------------------------------------
void __fastcall sub_470550(_DWORD **a1, OLECHAR *a2, int *a3, int a4, int a5)
{
  int v5; // esi
  int v6; // edx
  __int16 *v7; // eax
  BSTR v8; // eax
  int v9; // ecx
  OLECHAR *v10; // ebx
  _DWORD *v11; // esi
  int v12; // ecx
  unsigned int v13; // eax
  OLECHAR *v14; // eax
  OLECHAR *v16; // [esp+14h] [ebp-168h]
  int v17; // [esp+1Ch] [ebp-160h] BYREF
  _DWORD **v18; // [esp+20h] [ebp-15Ch]
  OLECHAR *v19; // [esp+24h] [ebp-158h]
  int v20; // [esp+28h] [ebp-154h] BYREF
  int v21; // [esp+2Ch] [ebp-150h] BYREF
  __int16 psz[128]; // [esp+30h] [ebp-14Ch] BYREF
  OLECHAR v23[34]; // [esp+130h] [ebp-4Ch] BYREF

  v5 = a5;
  v18 = a1;
  v20 = 0;
  v19 = 0;
  SysAllocString(L"\n\t\t\t\t");
  sub_401000(0x80u, (wchar_t *)psz, L"\n");
  if ( a5 > 0 )
  {
    do
    {
      v6 = 128;
      v7 = psz;
      while ( *v7 )
      {
        ++v7;
        if ( !--v6 )
          goto LABEL_7;
      }
      sub_4AA520(v6, (int)L"\t", &psz[128 - v6]);
LABEL_7:
      --v5;
    }
    while ( v5 );
  }
  v8 = SysAllocString((const OLECHAR *)psz);
  v9 = *a3;
  v10 = v8;
  v21 = 0;
  v17 = 0;
  v16 = v8;
  (*(void (__stdcall **)(int *, BSTR, int *))(v9 + 196))(a3, v8, &v21);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a4 + 84))(a4, v21, &v17);
  if ( v21 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v21 + 8))(v21);
  v21 = 0;
  if ( v17 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v17 + 8))(v17);
  sub_464940((int)a3, (int)&v20, a4, (OLECHAR *)L"Column", a2);
  v11 = (_DWORD *)**v18;
  if ( v11 != *v18 )
  {
    do
    {
      v12 = 0;
      v13 = 0;
      while ( dword_4E0358[v13] != v11[2] )
      {
        v13 += 33;
        ++v12;
        if ( v13 >= 1122 )
          goto LABEL_18;
      }
      v19 = &aName_2[66 * v12];
LABEL_18:
      v14 = aYes_0;
      if ( !v11[3] )
        v14 = aNo_0;
      sub_464A60((int)a3, v20, v19, v14);
      sub_401000(0x20u, v23, L"%s_Width", v19);
      _itow_s(v11[4], Buffer, 0x40u, 10);
      sub_464A60((int)a3, v20, v23, Buffer);
      v11 = (_DWORD *)*v11;
    }
    while ( v11 != *v18 );
    v10 = v16;
  }
  SysFreeString(v10);
}
// 4705E0: conditional instruction was optimized away because edx.4!=0
// 4C4C30: using guessed type wchar_t asc_4C4C30[2];
// 4C4C34: using guessed type wchar_t asc_4C4C34[2];
// 4C4C48: using guessed type wchar_t aSWidth[9];
// 4E0358: using guessed type int dword_4E0358[];
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 4EFC90: using guessed type OLECHAR Buffer[64];
// 470550: using guessed type OLECHAR psz[128];

//----- (00470790) --------------------------------------------------------
void __usercall sub_470790(_DWORD **a1@<ebx>, int *a2@<edi>, int a3@<esi>)
{
  sub_470550(a1 + 15118, L"Generic", a2, a3, 2);
  sub_470550(a1 + 15121, L"MyComputer", a2, a3, 2);
  sub_470550(a1 + 15124, L"ControlPanel", a2, a3, 2);
  sub_470550(a1 + 15127, L"RecycleBin", a2, a3, 2);
  sub_470550(a1 + 15130, L"Printers", a2, a3, 2);
  sub_470550(a1 + 15133, L"Network", a2, a3, 2);
  sub_470550(a1 + 15136, L"NetworkPlaces", a2, a3, 2);
}
// 4C4B88: using guessed type wchar_t aGeneric[8];
// 4C4B98: using guessed type wchar_t aMycomputer[11];
// 4C4BB0: using guessed type wchar_t aControlpanel[13];
// 4C4BCC: using guessed type wchar_t aRecyclebin[11];
// 4C4BE4: using guessed type wchar_t aPrinters[9];
// 4C4BF8: using guessed type wchar_t aNetwork[8];
// 4C4C08: using guessed type wchar_t aNetworkplaces[14];

//----- (00470830) --------------------------------------------------------
int __userpurge sub_470830@<eax>(int *a1@<eax>, _DWORD **a2, int a3)
{
  int v4; // esi
  void (__stdcall *v5)(int, _DWORD, _DWORD ***); // eax
  OLECHAR *v7; // [esp-8h] [ebp-1Ch]
  int v8; // [esp+0h] [ebp-14h]
  int v9; // [esp+4h] [ebp-10h]
  int v10; // [esp+8h] [ebp-Ch]
  BSTR v11; // [esp+Ch] [ebp-8h]

  v11 = SysAllocString(L"\n\t");
  v7 = SysAllocString(L"DefaultColumns");
  (*(void (**)(void))(*a1 + 188))();
  SysFreeString(v7);
  sub_470790(a2, a1, 0);
  sub_4645D0((int)a1, 0, (int)v11);
  v4 = a3;
  sub_4645D0((int)a1, a3, (int)v11);
  v5 = *(void (__stdcall **)(int, _DWORD, _DWORD ***))(*(_DWORD *)v4 + 84);
  a2 = 0;
  v5(v4, 0, &a2);
  if ( a2 )
    ((void (__stdcall *)(_DWORD **))(*a2)[2])(a2);
  return (*(int (__stdcall **)(_DWORD, int, int, int))(MEMORY[0] + 8))(0, v8, v9, v10);
}
// 4708CB: variable 'v8' is possibly undefined
// 4708CB: variable 'v9' is possibly undefined
// 4708CB: variable 'v10' is possibly undefined

//----- (004708E0) --------------------------------------------------------
void __thiscall sub_4708E0(void *this, int a2, int a3, OLECHAR *a4)
{
  int v4; // ebx
  int v5; // edx
  __int16 *v6; // eax
  OLECHAR *v7; // edi
  void (__stdcall *v8)(int, OLECHAR *, int *); // edx
  OLECHAR *v9; // ebx
  OLECHAR *v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // edi
  int v14; // edx
  __int16 *v15; // eax
  BSTR v16; // eax
  int v17; // edi
  OLECHAR *v18; // ebx
  OLECHAR *v19; // edi
  int v20; // edx
  void (__stdcall *v21)(int, OLECHAR *, int *); // ecx
  int v22; // edi
  void (__stdcall *v23)(int, int, int *); // eax
  int v24; // eax
  __int16 *v25; // ecx
  int v26; // edx
  bool v27; // zf
  int v28; // ecx
  __int16 *v29; // eax
  int v30; // edi
  char *v31; // ebx
  __int16 v32; // dx
  BSTR v33; // eax
  int v34; // edi
  OLECHAR *v35; // ebx
  int v36; // ebx
  int v37; // [esp+9Ch] [ebp-1158h] BYREF
  int v38; // [esp+A0h] [ebp-1154h] BYREF
  int v39; // [esp+A4h] [ebp-1150h] BYREF
  int v40; // [esp+A8h] [ebp-114Ch] BYREF
  OLECHAR *v41; // [esp+ACh] [ebp-1148h]
  int v42; // [esp+B0h] [ebp-1144h]
  void *v43; // [esp+B4h] [ebp-1140h]
  BSTR bstrString; // [esp+B8h] [ebp-113Ch]
  int v45[518]; // [esp+BCh] [ebp-1138h] BYREF
  int v46[518]; // [esp+8D4h] [ebp-920h] BYREF
  __int16 psz[130]; // [esp+10ECh] [ebp-108h] BYREF

  v43 = this;
  v42 = a3;
  v41 = a4;
  v40 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  sub_401000(0x80u, (wchar_t *)psz, L"\n");
  if ( dword_4EDBB4 > 0 )
  {
    v4 = dword_4EDBB4;
    do
    {
      v5 = 128;
      v6 = psz;
      while ( *v6 )
      {
        ++v6;
        if ( !--v5 )
          goto LABEL_8;
      }
      sub_4AA520(v5, (int)L"\t", &psz[128 - v5]);
LABEL_8:
      --v4;
    }
    while ( v4 );
  }
  v7 = SysAllocString((const OLECHAR *)psz);
  v8 = *(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a2 + 196);
  v39 = 0;
  v37 = 0;
  v8(a2, v7, &v39);
  (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v42 + 84))(v42, v39, &v37);
  if ( v39 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v39 + 8))(v39);
  v39 = 0;
  if ( v37 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v37 + 8))(v37);
  SysFreeString(v7);
  v9 = v41;
  sub_464940(a2, (int)&v40, v42, (OLECHAR *)L"Bookmark", v41);
  sub_464A60(a2, v40, (OLECHAR *)L"Description", v9 + 256);
  _itow_s(*((_DWORD *)v9 + 385), Buffer, 0x40u, 10);
  sub_464A60(a2, v40, (OLECHAR *)L"Type", Buffer);
  v10 = aYes_0;
  if ( !*((_DWORD *)v9 + 384) )
    v10 = aNo_0;
  sub_464A60(a2, v40, (OLECHAR *)L"ShowOnBookmarksToolbar", v10);
  if ( *((_DWORD *)v9 + 385) == 1 )
    sub_464A60(a2, v40, (OLECHAR *)L"Location", v9 + 772);
  if ( !*((_DWORD *)v9 + 385) )
  {
    v11 = *((_DWORD *)v9 + 516);
    if ( !*(_DWORD *)(v11 + 1540) )
    {
      v12 = *(_DWORD *)(v11 + 2076);
      if ( v12 )
      {
        sub_465D30(v12, v46);
        ++dword_4EDBB4;
        v39 = 0;
        sub_401000(0x80u, (wchar_t *)psz, L"\n");
        if ( dword_4EDBB4 > 0 )
        {
          v13 = dword_4EDBB4;
          do
          {
            v14 = 128;
            v15 = psz;
            while ( *v15 )
            {
              ++v15;
              if ( !--v14 )
                goto LABEL_27;
            }
            sub_4AA520(v14, (int)L"\t", &psz[128 - v14]);
LABEL_27:
            --v13;
          }
          while ( v13 );
        }
        v16 = SysAllocString((const OLECHAR *)psz);
        v17 = v40;
        v18 = v16;
        v37 = 0;
        v38 = 0;
        (*(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a2 + 196))(a2, v16, &v37);
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v17 + 84))(v17, v37, &v38);
        if ( v37 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v37 + 8))(v37);
        v37 = 0;
        if ( v38 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v38 + 8))(v38);
        v19 = SysAllocString(L"Bookmarks");
        (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a2 + 188))(a2, v19, &v39);
        SysFreeString(v19);
        ++dword_4EDBB4;
        sub_4708E0(v43, a2, v39, (OLECHAR *)v46);
        v20 = *(_DWORD *)a2;
        --dword_4EDBB4;
        v21 = *(void (__stdcall **)(int, OLECHAR *, int *))(v20 + 196);
        v22 = v39;
        v37 = 0;
        v38 = 0;
        v21(a2, v18, &v37);
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v22 + 84))(v22, v37, &v38);
        if ( v37 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v37 + 8))(v37);
        v37 = 0;
        if ( v38 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v38 + 8))(v38);
        SysFreeString(v18);
        v23 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)v40 + 84);
        v38 = 0;
        v23(v40, v39, &v38);
        if ( v38 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v38 + 8))(v38);
        (*(void (__stdcall **)(int))(*(_DWORD *)v39 + 8))(v39);
        --dword_4EDBB4;
        v39 = 0;
        sub_401000(0x80u, (wchar_t *)psz, L"\n");
        if ( dword_4EDBB4 > 0 )
        {
          v38 = dword_4EDBB4;
          do
          {
            v24 = 128;
            v25 = psz;
            while ( *v25 )
            {
              ++v25;
              if ( !--v24 )
                goto LABEL_53;
            }
            v26 = 128 - v24;
            v28 = v24;
            v27 = v24 == 0;
            v29 = &psz[128 - v24];
            if ( v27 )
            {
LABEL_51:
              --v29;
            }
            else
            {
              v30 = v28 + v26 + 2147483519;
              v31 = (char *)((char *)L"\t" - (char *)v29);
              while ( v30 )
              {
                v32 = *(__int16 *)((char *)v29 + (_DWORD)v31);
                if ( !v32 )
                  break;
                *v29++ = v32;
                --v30;
                if ( !--v28 )
                  goto LABEL_51;
              }
            }
            *v29 = 0;
LABEL_53:
            --v38;
          }
          while ( v38 );
        }
        v33 = SysAllocString((const OLECHAR *)psz);
        v34 = v40;
        v35 = v33;
        v37 = 0;
        v38 = 0;
        (*(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a2 + 196))(a2, v33, &v37);
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v34 + 84))(v34, v37, &v38);
        if ( v37 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v37 + 8))(v37);
        v37 = 0;
        if ( v38 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v38 + 8))(v38);
        SysFreeString(v35);
      }
      v9 = v41;
    }
  }
  v36 = *(_DWORD *)(*((_DWORD *)v9 + 516) + 2072);
  if ( v36 )
  {
    sub_465D30(v36, v45);
    sub_4708E0(v43, a2, v42, (OLECHAR *)v45);
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v40 + 8))(v40);
  v40 = 0;
  SysFreeString(bstrString);
}
// 470970: conditional instruction was optimized away because edx.4!=0
// 470B40: conditional instruction was optimized away because edx.4!=0
// 470D00: conditional instruction was optimized away because eax.4!=0
// 470D42: conditional instruction was optimized away because ecx.4!=0
// 4C4A90: using guessed type wchar_t asc_4C4A90[2];
// 4C4A94: using guessed type wchar_t asc_4C4A94[2];
// 4C4B14: using guessed type wchar_t asc_4C4B14[2];
// 4C4B18: using guessed type wchar_t asc_4C4B18[2];
// 4C4B30: using guessed type wchar_t asc_4C4B30[2];
// 4C4B34: using guessed type wchar_t asc_4C4B34[2];
// 4EDBB4: using guessed type int dword_4EDBB4;
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 4EFC90: using guessed type OLECHAR Buffer[64];
// 4708E0: using guessed type OLECHAR psz[130];
// 4708E0: using guessed type _DWORD var_920[518];
// 4708E0: using guessed type _DWORD var_1138[518];

//----- (00470E30) --------------------------------------------------------
void __fastcall sub_470E30(int a1, int a2, void *a3)
{
  OLECHAR *v5; // esi
  int v6; // eax
  void (__stdcall *v7)(int, int, int *); // eax
  OLECHAR *bstrString; // [esp+10h] [ebp-103Ch]
  int v10; // [esp+18h] [ebp-1034h] BYREF
  int v11; // [esp+1Ch] [ebp-1030h] BYREF
  int v12[516]; // [esp+20h] [ebp-102Ch] BYREF
  int v13; // [esp+830h] [ebp-81Ch]
  __int16 v14[1034]; // [esp+834h] [ebp-818h] BYREF

  v10 = a1;
  v11 = 0;
  bstrString = SysAllocString(L"\n\t");
  sub_4645D0(a1, a2, (int)bstrString);
  v5 = SysAllocString(L"Bookmarks");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 188))(a1, v5, &v11);
  SysFreeString(v5);
  sub_466000((int)a3 + 1332, v12);
  if ( !*(_DWORD *)(v13 + 1540) )
  {
    v6 = *(_DWORD *)(v13 + 2076);
    if ( v6 )
    {
      sub_465D30(v6, v14);
      sub_4708E0(a3, v10, v11, (OLECHAR *)v14);
    }
  }
  sub_4645D0(v10, v11, (int)bstrString);
  v7 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 84);
  v10 = 0;
  v7(a2, v11, &v10);
  if ( v10 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
  (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
  v11 = 0;
  SysFreeString(bstrString);
}
// 470E30: using guessed type int var_102C[516];
// 470E30: using guessed type OLECHAR var_818[1034];

//----- (00470F90) --------------------------------------------------------
int __userpurge sub_470F90@<eax>(int a1@<ebx>, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  __int16 *v5; // eax
  int v6; // edx
  int v7; // ebx
  __int16 v8; // cx
  int *v9; // eax
  int v10; // edx
  int v11; // ebx
  __int16 v12; // cx
  int *v13; // eax
  int v14; // edx
  int v15; // ebx
  __int16 v16; // cx
  int v17; // esi
  int i; // [esp+8h] [ebp-844h]
  int v19; // [esp+14h] [ebp-838h] BYREF
  int v20; // [esp+18h] [ebp-834h]
  int v21; // [esp+1Ch] [ebp-830h] BYREF
  int v22; // [esp+20h] [ebp-82Ch] BYREF
  int v23; // [esp+24h] [ebp-828h] BYREF
  LPCWSTR lpString1; // [esp+28h] [ebp-824h] BYREF
  LPCWSTR v25; // [esp+2Ch] [ebp-820h] BYREF
  int v26; // [esp+30h] [ebp-81Ch] BYREF
  __int16 v27[256]; // [esp+34h] [ebp-818h] BYREF
  int v28[389]; // [esp+234h] [ebp-618h] BYREF

  v20 = a3;
  v21 = 0;
  v22 = 0;
  v26 = 0;
  v23 = 0;
  memset(v27, 0, sizeof(v27));
  memset(v28, 0, sizeof(v28));
  result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)a2 + 68))(a2, &v21);
  if ( result >= 0 )
  {
    (*(void (__stdcall **)(int, int *, int))(*(_DWORD *)v21 + 44))(v21, &v19, a1);
    v4 = 0;
    for ( i = 0; v4 < v19; i = v4 )
    {
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v21 + 40))(v21, v4, &v22);
      (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v22 + 28))(v22, &lpString1);
      (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v22 + 104))(v22, &v25);
      if ( lstrcmpiW(lpString1, L"Name") )
      {
        if ( lstrcmpiW(lpString1, L"Description") )
        {
          if ( lstrcmpiW(lpString1, L"Location") )
          {
            if ( lstrcmpiW(lpString1, L"Type") )
            {
              if ( !lstrcmpiW(lpString1, L"ShowOnBookmarksToolbar") )
                v28[256] = lstrcmpW(v25, L"yes") == 0;
            }
            else
            {
              v28[257] = _wtoi(v25);
            }
          }
          else
          {
            v13 = &v28[258];
            v14 = 260;
            v15 = (char *)v25 - (char *)&v28[258];
            while ( v14 != -2147483386 )
            {
              v16 = *(_WORD *)((char *)v13 + v15);
              if ( !v16 )
                break;
              *(_WORD *)v13 = v16;
              v13 = (int *)((char *)v13 + 2);
              if ( !--v14 )
              {
                *((_WORD *)v13 - 1) = 0;
                goto LABEL_28;
              }
            }
            *(_WORD *)v13 = 0;
          }
        }
        else
        {
          v9 = v28;
          v10 = 512;
          v11 = (char *)v25 - (char *)v28;
          while ( v10 != -2147483134 )
          {
            v12 = *(_WORD *)((char *)v9 + v11);
            if ( !v12 )
              break;
            *(_WORD *)v9 = v12;
            v9 = (int *)((char *)v9 + 2);
            if ( !--v10 )
            {
              *((_WORD *)v9 - 1) = 0;
              goto LABEL_28;
            }
          }
          *(_WORD *)v9 = 0;
        }
      }
      else
      {
        v5 = v27;
        v6 = 256;
        v7 = (char *)v25 - (char *)v27;
        while ( v6 != -2147483390 )
        {
          v8 = *(__int16 *)((char *)v5 + v7);
          if ( !v8 )
            break;
          *v5++ = v8;
          if ( !--v6 )
          {
            *(v5 - 1) = 0;
            goto LABEL_28;
          }
        }
        *v5 = 0;
      }
LABEL_28:
      v4 = i + 1;
    }
    if ( v28[257] )
    {
      sub_4660F0((char *)v27, v20);
      v17 = a2;
    }
    else
    {
      sub_4660F0((char *)v27, v20);
      v17 = a2;
      if ( !(*(int (__stdcall **)(int, int *))(*(_DWORD *)a2 + 52))(a2, &v26)
        && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v26 + 64))(v26, &v26)
        && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v26 + 52))(v26, &v26)
        && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v26 + 64))(v26, &v26) )
      {
        sub_470F90((int)v27, v26, v28[388]);
      }
    }
    result = (*(int (__stdcall **)(int))(*(_DWORD *)v17 + 64))(v17);
    if ( !result )
    {
      result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v23 + 64))(v23, &v23);
      if ( !result )
        return sub_470F90((int)&v23, v23, v20);
    }
  }
  return result;
}
// 4710E9: conditional instruction was optimized away because edx.4!=0
// 471149: conditional instruction was optimized away because edx.4!=0
// 4711A6: conditional instruction was optimized away because edx.4!=0

//----- (00471330) --------------------------------------------------------
int __fastcall sub_471330(int a1, int a2)
{
  OLECHAR *v4; // esi
  int v5; // ebx
  int v7; // [esp+Ch] [ebp-81Ch] BYREF
  _DWORD v8[517]; // [esp+10h] [ebp-818h] BYREF

  v7 = 0;
  if ( a2 )
  {
    v4 = SysAllocString(L"//Bookmark");
    if ( !(*(int (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a2 + 148))(a2, v4, &v7) )
    {
      v5 = a1 + 1332;
      sub_466000(v5, v8);
      sub_470F90(v5, v7, v8[516]);
    }
    if ( v4 )
      SysFreeString(v4);
    if ( v7 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  return 0;
}

//----- (004713E0) --------------------------------------------------------
void __usercall sub_4713E0(int a1@<edx>, int a2@<ecx>, int *a3@<ebx>)
{
  int v3; // esi
  int v4; // edi
  bool v5; // zf
  OLECHAR *v6; // eax
  OLECHAR *v7; // eax
  OLECHAR *v8; // eax
  OLECHAR *v9; // eax
  OLECHAR *v10; // eax
  OLECHAR *v11; // eax
  OLECHAR *v12; // eax
  OLECHAR *v13; // edi
  void (__stdcall *v14)(int *, BSTR, int *); // edx
  int v15; // edi
  OLECHAR *v16; // eax
  OLECHAR *v17; // eax
  OLECHAR *v18; // eax
  int v19; // eax
  void (__stdcall *v20)(int *, BSTR, int *); // ecx
  int v21; // edi
  void (__stdcall *v22)(int, int, int *); // eax
  void (__stdcall *v23)(int *, BSTR, int *); // eax
  int v24; // edi
  void (__stdcall *v25)(int); // edx
  HWND v26; // [esp+A0h] [ebp-72Ch]
  int v27; // [esp+C0h] [ebp-70Ch] BYREF
  int v28; // [esp+C4h] [ebp-708h] BYREF
  int v29; // [esp+C8h] [ebp-704h] BYREF
  int v30; // [esp+CCh] [ebp-700h] BYREF
  WPARAM wParam; // [esp+D0h] [ebp-6FCh]
  int v32; // [esp+D4h] [ebp-6F8h] BYREF
  BSTR v33; // [esp+D8h] [ebp-6F4h]
  BSTR bstrString; // [esp+DCh] [ebp-6F0h]
  int v35; // [esp+E0h] [ebp-6ECh] BYREF
  int lParam[6]; // [esp+E4h] [ebp-6E8h] BYREF
  int v37; // [esp+FCh] [ebp-6D0h]
  int v38; // [esp+100h] [ebp-6CCh]
  int v39; // [esp+104h] [ebp-6C8h]
  LRESULT v40; // [esp+108h] [ebp-6C4h]
  int Value; // [esp+10Ch] [ebp-6C0h] BYREF
  int v42; // [esp+110h] [ebp-6BCh] BYREF
  void *v43[3]; // [esp+114h] [ebp-6B8h] BYREF
  _DWORD *v44; // [esp+120h] [ebp-6ACh] BYREF
  _DWORD *v45; // [esp+12Ch] [ebp-6A0h] BYREF
  _DWORD *v46; // [esp+138h] [ebp-694h] BYREF
  _DWORD *v47; // [esp+144h] [ebp-688h] BYREF
  _DWORD *v48; // [esp+150h] [ebp-67Ch] BYREF
  _DWORD *v49; // [esp+15Ch] [ebp-670h] BYREF
  WCHAR v50[32]; // [esp+16Ch] [ebp-660h] BYREF
  OLECHAR v51[260]; // [esp+1ACh] [ebp-620h] BYREF
  OLECHAR v52[514]; // [esp+3B4h] [ebp-418h] BYREF
  int v53; // [esp+7C8h] [ebp-4h]

  v3 = a2;
  v4 = a1;
  v39 = a2;
  v38 = a1;
  v27 = 0;
  v29 = 0;
  bstrString = SysAllocString(L"\n\t\t");
  v33 = SysAllocString(L"\n\t\t\t");
  v40 = SendMessageW(*(HWND *)(v3 + 68), 0x1304u, 0, 0);
  wParam = 0;
  if ( v40 > 0 )
  {
    while ( 1 )
    {
      v28 = 0;
      v30 = 0;
      (*(void (__stdcall **)(int *, BSTR, int *))(*a3 + 196))(a3, bstrString, &v28);
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v4 + 84))(v4, v28, &v30);
      if ( v28 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
      v28 = 0;
      if ( v30 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
      v26 = *(HWND *)(v3 + 68);
      lParam[0] = 8;
      SendMessageW(v26, 0x133Cu, wParam, (LPARAM)lParam);
      wsprintfW(v50, L"%d", wParam);
      sub_464940((int)a3, (int)&v27, v4, (OLECHAR *)L"Tab", v50);
      (*(void (__thiscall **)(_DWORD, int, OLECHAR *))(**(_DWORD **)(v3 + 4 * v37 + 916) + 52))(
        *(_DWORD *)(v3 + 4 * v37 + 916),
        260,
        v51);
      sub_464A60((int)a3, v27, (OLECHAR *)L"Directory", v51);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 916) + 216))(*(_DWORD *)(v3 + 4 * v37 + 916)) == 0;
      v6 = aYes_0;
      if ( v5 )
        v6 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"ApplyFilter", v6);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 516) + 12))(*(_DWORD *)(v3 + 4 * v37 + 516)) == 0;
      v7 = aYes_0;
      if ( v5 )
        v7 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"AutoArrange", v7);
      (*(void (__thiscall **)(_DWORD, OLECHAR *, int))(**(_DWORD **)(v3 + 4 * v37 + 916) + 208))(
        *(_DWORD *)(v3 + 4 * v37 + 916),
        v52,
        512);
      sub_464A60((int)a3, v27, (OLECHAR *)L"Filter", v52);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 916) + 224))(*(_DWORD *)(v3 + 4 * v37 + 916)) == 0;
      v8 = aYes_0;
      if ( v5 )
        v8 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"FilterCaseSensitive", v8);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 916) + 304))(*(_DWORD *)(v3 + 4 * v37 + 916)) == 0;
      v9 = aYes_0;
      if ( v5 )
        v9 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"ShowGridlines", v9);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 916) + 248))(*(_DWORD *)(v3 + 4 * v37 + 916)) == 0;
      v10 = aYes_0;
      if ( v5 )
        v10 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"ShowHidden", v10);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 516) + 36))(*(_DWORD *)(v3 + 4 * v37 + 516)) == 0;
      v11 = aYes_0;
      if ( v5 )
        v11 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"ShowInGroups", v11);
      v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v3 + 4 * v37 + 916) + 240))(*(_DWORD *)(v3 + 4 * v37 + 916)) == 0;
      v12 = aYes_0;
      if ( v5 )
        v12 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"SortAscending", v12);
      (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(v3 + 4 * v37 + 516) + 28))(
        *(_DWORD *)(v3 + 4 * v37 + 516),
        &Value);
      _itow_s(Value, Buffer, 0x40u, 10);
      sub_464A60((int)a3, v27, (OLECHAR *)L"SortMode", Buffer);
      (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(v3 + 4 * v37 + 516) + 24))(
        *(_DWORD *)(v3 + 4 * v37 + 516),
        &v42);
      _itow_s(v42, Buffer, 0x40u, 10);
      sub_464A60((int)a3, v27, (OLECHAR *)L"ViewMode", Buffer);
      v13 = SysAllocString(L"Columns");
      (*(void (__stdcall **)(int *, OLECHAR *, int *))(*a3 + 188))(a3, v13, &v29);
      SysFreeString(v13);
      sub_415920(v43);
      v53 = 0;
      (*(void (__thiscall **)(_DWORD, void **))(**(_DWORD **)(v3 + 4 * v37 + 916) + 324))(
        *(_DWORD *)(v3 + 4 * v37 + 916),
        v43);
      sub_470550((_DWORD **)v43, L"Generic", a3, v29, 4);
      sub_470550(&v44, L"MyComputer", a3, v29, 4);
      sub_470550(&v45, L"ControlPanel", a3, v29, 4);
      sub_470550(&v46, L"RecycleBin", a3, v29, 4);
      sub_470550(&v47, L"Printers", a3, v29, 4);
      sub_470550(&v48, L"Network", a3, v29, 4);
      sub_470550(&v49, L"NetworkPlaces", a3, v29, 4);
      v14 = *(void (__stdcall **)(int *, BSTR, int *))(*a3 + 196);
      v15 = v29;
      v28 = 0;
      v30 = 0;
      v14(a3, v33, &v28);
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v15 + 84))(v15, v28, &v30);
      if ( v28 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
      v28 = 0;
      if ( v30 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
      v16 = aYes_0;
      if ( !*(_DWORD *)(532 * v37 + v3 + 5672) )
        v16 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"Locked", v16);
      v17 = aYes_0;
      if ( !*(_DWORD *)(532 * v37 + v3 + 5676) )
        v17 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"AddressLocked", v17);
      v18 = aYes_0;
      if ( !*(_DWORD *)(532 * v37 + v3 + 5680) )
        v18 = aNo_0;
      sub_464A60((int)a3, v27, (OLECHAR *)L"UseCustomName", v18);
      v19 = v3 + 532 * v37;
      if ( *(_DWORD *)(v19 + 5680) )
        sub_464A60((int)a3, v27, L"CustomName", (OLECHAR *)(v19 + 5684));
      else
        sub_464A60((int)a3, v27, (OLECHAR *)L"CustomName", (OLECHAR *)&word_4C4908);
      v20 = *(void (__stdcall **)(int *, BSTR, int *))(*a3 + 196);
      v21 = v27;
      v28 = 0;
      v30 = 0;
      v20(a3, v33, &v28);
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v21 + 84))(v21, v28, &v30);
      if ( v28 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
      v28 = 0;
      if ( v30 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
      v22 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)v27 + 84);
      v30 = 0;
      v22(v27, v29, &v30);
      if ( v30 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
      (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
      v23 = *(void (__stdcall **)(int *, BSTR, int *))(*a3 + 196);
      v24 = v27;
      v29 = 0;
      v32 = 0;
      v35 = 0;
      v23(a3, bstrString, &v32);
      (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v24 + 84))(v24, v32, &v35);
      if ( v32 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v32 + 8))(v32);
      v32 = 0;
      if ( v35 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v35 + 8))(v35);
      v25 = *(void (__stdcall **)(int))(*(_DWORD *)v27 + 8);
      v35 = 0;
      v25(v27);
      v27 = 0;
      v53 = -1;
      sub_415B50(v43);
      if ( (int)++wParam >= v40 )
        break;
      v4 = v38;
      v3 = v39;
    }
  }
  SysFreeString(bstrString);
  SysFreeString(v33);
}
// 4C480C: using guessed type wchar_t aGeneric_0[8];
// 4C481C: using guessed type wchar_t aMycomputer_0[11];
// 4C4834: using guessed type wchar_t aControlpanel_0[13];
// 4C4850: using guessed type wchar_t aRecyclebin_0[11];
// 4C4868: using guessed type wchar_t aPrinters_0[9];
// 4C487C: using guessed type wchar_t aNetwork_0[8];
// 4C488C: using guessed type wchar_t aNetworkplaces_0[14];
// 4C48F0: using guessed type wchar_t aCustomname_0[11];
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 4EFC90: using guessed type OLECHAR Buffer[64];
// 4713E0: using guessed type LPARAM lParam[6];

//----- (00471B40) --------------------------------------------------------
int __userpurge sub_471B40@<eax>(int *a1@<eax>, int a2@<edi>, int a3)
{
  void (__stdcall *v4)(int, _DWORD, int *); // ecx
  OLECHAR *v6; // [esp-8h] [ebp-18h]
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+4h] [ebp-Ch]
  BSTR v9; // [esp+8h] [ebp-8h]

  v9 = SysAllocString(L"\n\t");
  sub_4645D0((int)a1, a2, (int)v9);
  v6 = SysAllocString(L"Tabs");
  (*(void (__stdcall **)(int *))(*a1 + 188))(a1);
  SysFreeString(v6);
  sub_4713E0(0, a3, a1);
  sub_4645D0((int)a1, 0, (int)v9);
  v4 = *(void (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)a2 + 84);
  a3 = 0;
  v4(a2, 0, &a3);
  if ( a3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a3 + 8))(a3);
  return (*(int (__stdcall **)(_DWORD, int, int))(MEMORY[0] + 8))(0, v7, v8);
}
// 471BDD: variable 'v7' is possibly undefined
// 471BDD: variable 'v8' is possibly undefined

//----- (00471BF0) --------------------------------------------------------
int __usercall sub_471BF0@<eax>(int result@<eax>, int a2@<ebx>)
{
  int v2; // esi
  BSTR v3; // eax
  int i; // esi
  const WCHAR *v5; // [esp+8h] [ebp-1Ch] BYREF
  const WCHAR *v6; // [esp+Ch] [ebp-18h] BYREF
  int v7; // [esp+10h] [ebp-14h] BYREF
  int v8; // [esp+14h] [ebp-10h] BYREF
  int v9; // [esp+18h] [ebp-Ch] BYREF
  int v10; // [esp+1Ch] [ebp-8h] BYREF
  const WCHAR *v11; // [esp+20h] [ebp-4h] BYREF

  v2 = result;
  v9 = 0;
  v11 = 0;
  v8 = 0;
  v10 = 0;
  if ( result )
  {
    v3 = SysAllocString(L"//Settings/*");
    (*(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)v2 + 144))(v2, v3, &v9);
    result = v9;
    if ( v9 )
    {
      result = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v9 + 32))(v9, &v7);
      for ( i = 0; i < v7; v11 = 0 )
      {
        (*(void (__stdcall **)(int, int, const WCHAR **))(*(_DWORD *)v9 + 28))(v9, i, &v11);
        if ( (*(int (__stdcall **)(const WCHAR *, int *))(*(_DWORD *)v11 + 68))(v11, &v8) >= 0
          && (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v8 + 40))(v8, 0, &v10) >= 0 )
        {
          (*(void (__stdcall **)(int, const WCHAR **))(*(_DWORD *)v10 + 104))(v10, &v6);
          (*(void (__stdcall **)(const WCHAR *, const WCHAR **))(*(_DWORD *)v11 + 104))(v11, &v5);
          sub_46EC90(a2, v5, v11, v6);
          (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
          v10 = 0;
        }
        result = (*(int (__stdcall **)(const WCHAR *))(*(_DWORD *)v11 + 8))(v11);
        ++i;
      }
    }
  }
  return result;
}

//----- (00471CF0) --------------------------------------------------------
void __thiscall sub_471CF0(int this)
{
  sub_4701C0(*(_DWORD *)(this + 16), *(OLECHAR ***)(this + 8), *(_DWORD *)(this + 24));
}

//----- (00471D10) --------------------------------------------------------
int __thiscall sub_471D10(int this)
{
  return sub_470830(*(int **)(this + 16), *(_DWORD ***)(this + 8), *(_DWORD *)(this + 24));
}

//----- (00471D30) --------------------------------------------------------
int __thiscall sub_471D30(int this)
{
  return sub_471B40(*(int **)(this + 16), *(_DWORD *)(this + 24), *(_DWORD *)(this + 8));
}

//----- (00471D50) --------------------------------------------------------
void __thiscall sub_471D50(int this)
{
  sub_470E30(*(_DWORD *)(this + 16), *(_DWORD *)(this + 24), *(void **)(this + 8));
}

//----- (00471D60) --------------------------------------------------------
void __thiscall sub_471D60(int this)
{
  sub_4704F0(*(_DWORD *)(this + 16), *(void **)(this + 8));
}

//----- (00471D70) --------------------------------------------------------
int __thiscall sub_471D70(int *this)
{
  return sub_471330(this[2], this[4]);
}

//----- (00471D80) --------------------------------------------------------
int __thiscall sub_471D80(int *this)
{
  return sub_471BF0(this[4], this[2]);
}

//----- (00471D90) --------------------------------------------------------
int __fastcall sub_471D90(int a1, _DWORD *a2)
{
  _DWORD **v3; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // edi
  int v8; // ecx
  int v9; // esi
  const WCHAR *v10; // edi
  int v11; // eax
  _DWORD *v12; // edi
  int v13; // ebx
  char **v14; // eax
  int v15; // ecx
  int v16; // eax
  char *v17; // [esp-8h] [ebp-88h]
  int v18; // [esp-4h] [ebp-84h]
  char *v19[3]; // [esp+Ch] [ebp-74h] BYREF
  int v20; // [esp+18h] [ebp-68h] BYREF
  unsigned int v21; // [esp+1Ch] [ebp-64h]
  int i; // [esp+20h] [ebp-60h]
  LPCWSTR lpString1; // [esp+24h] [ebp-5Ch] BYREF
  int v24; // [esp+28h] [ebp-58h] BYREF
  int v25; // [esp+2Ch] [ebp-54h] BYREF
  _DWORD *v26; // [esp+30h] [ebp-50h]
  int v27; // [esp+34h] [ebp-4Ch]
  LPCWSTR v28; // [esp+38h] [ebp-48h] BYREF
  WCHAR String2[32]; // [esp+3Ch] [ebp-44h] BYREF

  v3 = (_DWORD **)*a2;
  v25 = 0;
  v24 = 0;
  v5 = *v3;
  *v3 = v3;
  *(_DWORD *)(*a2 + 4) = *a2;
  v26 = a2;
  v27 = -1;
  a2[1] = 0;
  if ( v5 != (_DWORD *)*a2 )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != (_DWORD *)*a2 );
  }
  if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)a1 + 68))(a1, &v25) < 0 )
    return -1;
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)v25 + 44))(v25, &v20);
  v8 = 0;
  for ( i = 0; v8 < v20; i = v8 )
  {
    (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v25 + 40))(v25, v8, &v24);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v24 + 28))(v24, &lpString1);
    (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v24 + 104))(v24, &v28);
    if ( lstrcmpW(lpString1, L"name") )
    {
      v9 = 0;
      v10 = aName_2;
      v21 = 0;
      while ( 1 )
      {
        sub_401000(0x20u, String2, L"%s_Width", v10);
        if ( !lstrcmpW(lpString1, v10) )
          break;
        if ( !lstrcmpW(lpString1, String2) )
        {
          if ( v26[1] )
          {
            v16 = _wtoi(v28);
            *(_DWORD *)(*(_DWORD *)(*v26 + 4) + 16) = v16;
          }
          goto LABEL_30;
        }
        ++v9;
        v10 += 66;
        v21 += 132;
        if ( v21 >= 0x1188 )
          goto LABEL_30;
      }
      v19[0] = (char *)dword_4E0358[33 * v9];
      v11 = lstrcmpW(v28, L"yes");
      v12 = v26;
      v13 = *v26;
      v18 = *(_DWORD *)(*v26 + 4);
      v17 = (char *)*v26;
      v19[1] = (char *)(v11 == 0);
      v14 = sub_41EEB0(v19, v17, v18);
      v15 = v12[1];
      if ( v15 == 357913940 )
        std::_Xlength_error("list<T> too long");
      v12[1] = v15 + 1;
      *(_DWORD *)(v13 + 4) = v14;
      *(_DWORD *)v14[1] = v14;
    }
    else if ( lstrcmpW(v28, L"Generic") )
    {
      if ( lstrcmpW(v28, L"MyComputer") )
      {
        if ( lstrcmpW(v28, L"ControlPanel") )
        {
          if ( lstrcmpW(v28, L"RecycleBin") )
          {
            if ( lstrcmpW(v28, L"Printers") )
            {
              if ( lstrcmpW(v28, L"Network") )
              {
                if ( !lstrcmpW(v28, L"NetworkPlaces") )
                  v27 = 6;
              }
              else
              {
                v27 = 5;
              }
            }
            else
            {
              v27 = 4;
            }
          }
          else
          {
            v27 = 3;
          }
        }
        else
        {
          v27 = 2;
        }
      }
      else
      {
        v27 = 1;
      }
    }
    else
    {
      v27 = 0;
    }
LABEL_30:
    v8 = i + 1;
  }
  return v27;
}
// 4C49CC: using guessed type wchar_t aSWidth_0[9];
// 4E0358: using guessed type int dword_4E0358[];

//----- (00472020) --------------------------------------------------------
int __thiscall sub_472020(void *this, int a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  OLECHAR *v5; // ebx
  void (__stdcall *v6)(void *, OLECHAR *, int *); // edx
  int v7; // eax
  int i; // ebx
  int v9; // eax
  char ***v10; // esi
  bool v11; // zf
  _DWORD *v12; // eax
  _DWORD *v13; // esi
  int pExceptionObject[3]; // [esp+10h] [ebp-38h] BYREF
  int v16[3]; // [esp+1Ch] [ebp-2Ch] BYREF
  char *v17; // [esp+28h] [ebp-20h] BYREF
  OLECHAR *v18; // [esp+2Ch] [ebp-1Ch]
  int v19; // [esp+30h] [ebp-18h] BYREF
  int v20; // [esp+34h] [ebp-14h] BYREF
  int v21[4]; // [esp+38h] [ebp-10h] BYREF

  v21[0] = 0;
  v20 = 0;
  v16[1] = 0;
  v3 = operator new(0x14u);
  if ( !v3 )
  {
    v17 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v4 = v3;
  *v3 = v3;
  v16[0] = (int)v3;
  v3[1] = v3;
  v21[3] = 0;
  if ( this )
  {
    v5 = SysAllocString(L"//DefaultColumns/*");
    v6 = *(void (__stdcall **)(void *, OLECHAR *, int *))(*(_DWORD *)this + 144);
    v18 = v5;
    v6(this, v5, v21);
    v7 = v21[0];
    if ( v21[0] )
    {
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)v21[0] + 32))(v21[0], &v19);
      for ( i = 0; i < v19; v20 = 0 )
      {
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v21[0] + 28))(v21[0], i, &v20);
        v9 = sub_471D90(v20, v16);
        v4 = (_DWORD *)v16[0];
        switch ( v9 )
        {
          case 0:
            v10 = (char ***)(a2 + 60472);
            if ( (int *)(a2 + 60472) != v16 )
              goto LABEL_16;
            break;
          case 1:
            v10 = (char ***)(a2 + 60484);
            v11 = a2 + 60484 == (_DWORD)v16;
            goto LABEL_15;
          case 2:
            v10 = (char ***)(a2 + 60496);
            goto LABEL_14;
          case 3:
            v10 = (char ***)(a2 + 60508);
            goto LABEL_14;
          case 4:
            v10 = (char ***)(a2 + 60520);
            goto LABEL_14;
          case 5:
            v10 = (char ***)(a2 + 60532);
            goto LABEL_14;
          case 6:
            v10 = (char ***)(a2 + 60544);
LABEL_14:
            v11 = v10 == (char ***)v16;
LABEL_15:
            if ( !v11 )
LABEL_16:
              sub_40B820(v10, *(_DWORD *)v16[0], v16[0], a2);
            break;
          default:
            break;
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)v20 + 8))(v20);
        ++i;
      }
      v5 = v18;
      v7 = v21[0];
    }
    if ( v5 )
    {
      SysFreeString(v5);
      v7 = v21[0];
    }
  }
  else
  {
    v7 = v21[0];
  }
  if ( v7 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  if ( v20 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v20 + 8))(v20);
  v12 = (_DWORD *)*v4;
  *v4 = v4;
  v4[1] = v4;
  if ( v12 != v4 )
  {
    do
    {
      v13 = (_DWORD *)*v12;
      operator delete(v12);
      v12 = v13;
    }
    while ( v13 != v4 );
  }
  operator delete(v4);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00472230) --------------------------------------------------------
int __thiscall sub_472230(int this)
{
  return sub_472020(*(void **)(this + 16), *(_DWORD *)(this + 8));
}

//----- (00472240) --------------------------------------------------------
void __usercall sub_472240(int a1@<edx>, int a2@<ecx>, int a3@<ebx>)
{
  OLECHAR *v5; // esi
  int v6; // eax
  _DWORD *v7; // edi
  int v8; // ecx
  void (__stdcall *v9)(int, BSTR, int *); // eax
  int v10; // esi
  void (__stdcall *v11)(int, int, int *); // eax
  void (__stdcall *v12)(int); // edx
  int v13; // [esp+40h] [ebp-70h] BYREF
  _DWORD *i; // [esp+44h] [ebp-6Ch] BYREF
  int v15; // [esp+48h] [ebp-68h] BYREF
  int v16; // [esp+4Ch] [ebp-64h] BYREF
  BSTR bstrString; // [esp+50h] [ebp-60h]
  int v18; // [esp+54h] [ebp-5Ch]
  void *v19[5]; // [esp+58h] [ebp-58h] BYREF
  unsigned int v20; // [esp+6Ch] [ebp-44h]
  void *v21; // [esp+74h] [ebp-3Ch] BYREF
  int v22; // [esp+84h] [ebp-2Ch]
  unsigned int v23; // [esp+88h] [ebp-28h]
  int v24; // [esp+90h] [ebp-20h]
  int v25; // [esp+94h] [ebp-1Ch]
  int v26; // [esp+ACh] [ebp-4h]

  v18 = a1;
  v13 = 0;
  bstrString = SysAllocString(L"\n\t");
  sub_4645D0(a3, a1, (int)bstrString);
  v5 = SysAllocString(L"ColorRules");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a3 + 188))(a3, v5, &v13);
  SysFreeString(v5);
  v6 = *(_DWORD *)(a2 + 40);
  v7 = *(_DWORD **)(a2 + 36);
  for ( i = (_DWORD *)v6; v7 != i; v7 += 16 )
  {
    v20 = 7;
    v19[4] = 0;
    LOWORD(v19[0]) = 0;
    sub_4090E0((int)v19, v7, 0, 0xFFFFFFFF);
    v26 = 0;
    LOWORD(v21) = 0;
    v23 = 7;
    v22 = 0;
    sub_4090E0((int)&v21, v7 + 7, 0, 0xFFFFFFFF);
    v8 = v7[15];
    v24 = v7[14];
    v25 = v8;
    v26 = 1;
    sub_46FDB0(v13, a3, (int)v19);
    v26 = -1;
    if ( v23 >= 8 )
      operator delete(v21);
    v23 = 7;
    v22 = 0;
    LOWORD(v21) = 0;
    if ( v20 >= 8 )
      operator delete(v19[0]);
  }
  v9 = *(void (__stdcall **)(int, BSTR, int *))(*(_DWORD *)a3 + 196);
  v10 = v13;
  v15 = 0;
  i = 0;
  v9(a3, bstrString, &v15);
  (*(void (__stdcall **)(int, int, _DWORD **))(*(_DWORD *)v10 + 84))(v10, v15, &i);
  if ( v15 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
  v15 = 0;
  if ( i )
    (*(void (__stdcall **)(_DWORD *))(*i + 8))(i);
  v11 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)v18 + 84);
  v16 = 0;
  v11(v18, v13, &v16);
  if ( v16 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  v12 = *(void (__stdcall **)(int))(*(_DWORD *)v13 + 8);
  v16 = 0;
  v12(v13);
  v13 = 0;
  SysFreeString(bstrString);
}

//----- (00472460) --------------------------------------------------------
void __thiscall sub_472460(int *this)
{
  sub_472240(this[6], this[2], this[4]);
}

//----- (00472480) --------------------------------------------------------
void __thiscall sub_472480(_DWORD *this, int a2)
{
  int v2; // edi
  int (__stdcall *v3)(int, int *); // edx
  int v4; // esi
  BSTR **v5; // eax
  void **v6; // eax
  void *v7; // edx
  void *v8; // edi
  BSTR **v9; // eax
  void **v10; // eax
  void *v11; // edx
  void *v12; // edi
  int v13; // [esp+30h] [ebp-8Ch] BYREF
  LPCWSTR lpString1; // [esp+34h] [ebp-88h] BYREF
  wchar_t *String; // [esp+38h] [ebp-84h] BYREF
  int v16; // [esp+3Ch] [ebp-80h] BYREF
  int v17; // [esp+40h] [ebp-7Ch] BYREF
  int v18; // [esp+44h] [ebp-78h] BYREF
  int v19; // [esp+48h] [ebp-74h]
  int v20; // [esp+4Ch] [ebp-70h] BYREF
  int v21; // [esp+50h] [ebp-6Ch]
  int v22; // [esp+54h] [ebp-68h]
  void *v23; // [esp+58h] [ebp-64h] BYREF
  _DWORD *v24; // [esp+5Ch] [ebp-60h]
  void *v25; // [esp+60h] [ebp-5Ch] BYREF
  void *v26[5]; // [esp+64h] [ebp-58h] BYREF
  unsigned int v27; // [esp+78h] [ebp-44h]
  void *v28; // [esp+80h] [ebp-3Ch] BYREF
  int v29; // [esp+90h] [ebp-2Ch]
  unsigned int v30; // [esp+94h] [ebp-28h]
  int v31; // [esp+9Ch] [ebp-20h]
  int v32; // [esp+A0h] [ebp-1Ch]
  int v33; // [esp+B8h] [ebp-4h]

  v2 = a2;
  v24 = this;
  v22 = a2;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v27 = 7;
  v26[4] = 0;
  LOWORD(v26[0]) = 0;
  v30 = 7;
  v29 = 0;
  LOWORD(v28) = 0;
  v33 = 0;
  v3 = *(int (__stdcall **)(int, int *))(*(_DWORD *)a2 + 68);
  v4 = 0;
  v21 = 0;
  memset((char *)&v13 + 1, 0, 3);
  if ( v3(a2, &v18) >= 0 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v18 + 44))(v18, &v20);
    v19 = 0;
    if ( v20 > 0 )
    {
      do
      {
        (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v18 + 40))(v18, v19, &v17);
        (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v17 + 28))(v17, &lpString1);
        (*(void (__stdcall **)(int, wchar_t **))(*(_DWORD *)v17 + 104))(v17, &String);
        if ( lstrcmpiW(lpString1, L"Name") )
        {
          if ( lstrcmpiW(lpString1, L"FilenamePattern") )
          {
            if ( lstrcmpiW(lpString1, L"Attributes") )
            {
              if ( lstrcmpiW(lpString1, L"r") )
              {
                if ( lstrcmpiW(lpString1, L"g") )
                {
                  if ( !lstrcmpiW(lpString1, L"b") )
                    HIBYTE(v13) = _wtoi(String);
                }
                else
                {
                  BYTE2(v13) = _wtoi(String);
                }
              }
              else
              {
                BYTE1(v13) = _wtoi(String);
              }
            }
            else
            {
              v31 = _wtoi(String);
            }
          }
          else
          {
            v9 = sub_417E40(String, (BSTR **)&v25);
            LOBYTE(v33) = 2;
            v10 = (void **)*v9;
            if ( v10 )
              v11 = *v10;
            else
              v11 = 0;
            sub_4094F0(&v28, (int)v11, v11, wcslen((const unsigned __int16 *)v11));
            LOBYTE(v33) = 0;
            if ( v25 )
            {
              v12 = v25;
              if ( !InterlockedDecrement((volatile LONG *)v25 + 2) )
              {
                if ( *(_DWORD *)v12 )
                  SysFreeString(*(BSTR *)v12);
                if ( *((_DWORD *)v12 + 1) )
                  operator delete[](*((void **)v12 + 1));
                operator delete(v12);
              }
              v25 = 0;
            }
            v21 = 1;
          }
        }
        else
        {
          v5 = sub_417E40(String, (BSTR **)&v23);
          LOBYTE(v33) = 1;
          v6 = (void **)*v5;
          if ( v6 )
            v7 = *v6;
          else
            v7 = 0;
          sub_4094F0(v26, (int)v7, v7, wcslen((const unsigned __int16 *)v7));
          LOBYTE(v33) = 0;
          if ( v23 )
          {
            v8 = v23;
            if ( !InterlockedDecrement((volatile LONG *)v23 + 2) )
            {
              if ( *(_DWORD *)v8 )
                SysFreeString(*(BSTR *)v8);
              if ( *((_DWORD *)v8 + 1) )
                operator delete[](*((void **)v8 + 1));
              operator delete(v8);
            }
            v23 = 0;
          }
          v4 = 1;
        }
        ++v19;
      }
      while ( v19 < v20 );
      if ( v4 && v21 )
      {
        v32 = BYTE1(v13) | (HIWORD(v13) << 8);
        sub_409970(v26, v24 + 9);
      }
      v2 = v22;
    }
    if ( !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v2 + 64))(v2, &v16)
      && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v16 + 64))(v16, &v16) )
    {
      sub_472480(v24, v16);
    }
    if ( v30 >= 8 )
      operator delete(v28);
    v30 = 7;
    v29 = 0;
    LOWORD(v28) = 0;
    if ( v27 >= 8 )
      operator delete(v26[0]);
  }
  else
  {
    sub_409920((int)v26);
  }
}
// 47260B: conditional instruction was optimized away because edi.4!=0
// 4726BB: conditional instruction was optimized away because edi.4!=0

//----- (00472860) --------------------------------------------------------
int __usercall sub_472860@<eax>(int result@<eax>, _DWORD *a2@<esi>)
{
  int v2; // edi
  OLECHAR *v3; // ebx
  _DWORD *v4; // eax
  int v5; // ecx
  _DWORD *v6; // edi
  int v7; // [esp+8h] [ebp-4h] BYREF

  v2 = result;
  v7 = 0;
  if ( result )
  {
    v3 = SysAllocString(L"//ColorRule");
    if ( !(*(int (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)v2 + 148))(v2, v3, &v7) )
    {
      v4 = (_DWORD *)a2[10];
      v5 = a2[9];
      if ( (_DWORD *)v5 != v4 )
      {
        v6 = (_DWORD *)sub_409CA0(v4, v5, v4);
        sub_409CF0(v6, (_DWORD *)a2[10]);
        a2[10] = v6;
      }
      sub_472480(a2, v7);
    }
    if ( v3 )
      SysFreeString(v3);
    result = v7;
    if ( v7 )
      return (*(int (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  return result;
}

//----- (00472900) --------------------------------------------------------
int __thiscall sub_472900(int this)
{
  return sub_472860(*(_DWORD *)(this + 16), *(_DWORD **)(this + 8));
}

//----- (00472910) --------------------------------------------------------
int __userpurge sub_472910@<eax>(int a1@<edi>, int a2)
{
  OLECHAR *v2; // esi
  void (__stdcall *v3)(int, int, int *); // eax
  int (__stdcall *v4)(int); // edx
  int v6; // [esp+1Ch] [ebp-1Ch] BYREF
  int v7; // [esp+20h] [ebp-18h] BYREF
  BSTR v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+34h] [ebp-4h]

  v6 = 0;
  v8 = SysAllocString(L"\n\t");
  sub_4645D0(a1, a2, (int)v8);
  v2 = SysAllocString(L"State");
  (*(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)a1 + 188))(a1, v2, &v6);
  SysFreeString(v2);
  if ( (dword_4F2220 & 1) == 0 )
  {
    dword_4F2220 |= 1u;
    v9 = 0;
    sub_482160();
    atexit(sub_4BCD00);
    v9 = -1;
  }
  sub_465280(v6, (int)&dword_4F1B60, a1);
  if ( (dword_4F221C & 1) == 0 )
  {
    dword_4F221C |= 1u;
    v9 = 1;
    sub_476A70();
    atexit(sub_4BCD50);
    v9 = -1;
  }
  sub_465280(v6, (int)&dword_4F1728, a1);
  if ( (dword_4F1B50 & 1) == 0 )
  {
    dword_4F1B50 |= 1u;
    sub_4653E0((int)&dword_4F03B8, (int)L"SetFileAttributes");
    dword_4F03B8 = (int)&CSetFileAttributesDialogPersistentSettings::`vftable';
    atexit(sub_4BCD30);
  }
  sub_465280(v6, (int)&dword_4F03B8, a1);
  if ( (dword_4F1FD0 & 1) == 0 )
  {
    dword_4F1FD0 |= 1u;
    sub_4653E0((int)&dword_4F0A18, (int)L"RenameTab");
    dword_4F0A18 = (int)&CRenameTabDialogPersistentSettings::`vftable';
    atexit(sub_4BCCF0);
  }
  sub_465280(v6, (int)&dword_4F0A18, a1);
  if ( (dword_4F1FD8 & 1) == 0 )
  {
    dword_4F1FD8 |= 1u;
    sub_4653E0((int)&dword_4F0E60, (int)L"MassRename");
    dword_4F0E60 = (int)&CMassRenameDialogPersistentSettings::`vftable';
    dword_4F107C = 250;
    dword_4F1080 = 250;
    atexit(sub_4BCCD0);
  }
  sub_465280(v6, (int)&dword_4F0E60, a1);
  if ( (dword_4F222C & 1) == 0 )
  {
    dword_4F222C |= 1u;
    v9 = 2;
    sub_49FC40();
    atexit(sub_4BCCA0);
    v9 = -1;
  }
  sub_465280(v6, (int)&dword_4F1FE0, a1);
  if ( (dword_4F2210 & 1) == 0 )
  {
    dword_4F2210 |= 1u;
    sub_4A5390();
    atexit(sub_4BCBD0);
  }
  sub_465280(v6, (int)&dword_4F14C8, a1);
  if ( (dword_4F220C & 1) == 0 )
  {
    dword_4F220C |= 1u;
    sub_4653E0((int)&dword_4F12A8, (int)L"CustomizeColors");
    dword_4F12A8 = (int)&CCustomizeColorsDialogPersistentSettings::`vftable';
    atexit(sub_4BCBE0);
  }
  sub_465280(v6, (int)&dword_4F12A8, a1);
  if ( (dword_4F2484 & 1) == 0 )
  {
    dword_4F2484 |= 1u;
    v9 = 3;
    sub_47C990();
    atexit(sub_4BCD40);
    v9 = -1;
  }
  sub_465280(v6, (int)&dword_4F2230, a1);
  if ( (dword_4F2208 & 1) == 0 )
  {
    dword_4F2208 |= 1u;
    sub_4653E0((int)&dword_4F1088, (int)L"DestroyFiles");
    dword_4F1088 = (int)&CDestroyFilesDialogPersistentSettings::`vftable';
    dword_4F12A4 = 1;
    atexit(sub_4BCBF0);
  }
  sub_465280(v6, (int)&dword_4F1088, a1);
  if ( (dword_4F1FD4 & 1) == 0 )
  {
    dword_4F1FD4 |= 1u;
    sub_4653E0((int)&dword_4F0C40, (int)L"MergeFiles");
    dword_4F0C40 = (int)&CMergeFilesDialogPersistentSettings::`vftable';
    atexit(sub_4BCCE0);
  }
  sub_465280(v6, (int)&dword_4F0C40, a1);
  if ( (dword_4F1B58 & 1) == 0 )
  {
    dword_4F1B58 |= 1u;
    sub_4653E0((int)&dword_4F07F8, (int)L"SelectColumns");
    dword_4F07F8 = (int)&CSelectColumnsDialogPersistentSettings::`vftable';
    atexit(sub_4BCD10);
  }
  sub_465280(v6, (int)&dword_4F07F8, a1);
  if ( (dword_4F1B54 & 1) == 0 )
  {
    dword_4F1B54 |= 1u;
    sub_4653E0((int)&dword_4F05D8, (int)L"SetDefaultColumns");
    dword_4F05D8 = (int)&CSetDefaultColumnsDialogPersistentSettings::`vftable';
    dword_4F07F4 = 0;
    atexit(sub_4BCD20);
  }
  sub_465280(v6, (int)&dword_4F05D8, a1);
  sub_4645D0(a1, v6, (int)v8);
  v3 = *(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 84);
  v7 = 0;
  v3(a2, v6, &v7);
  if ( v7 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  v4 = *(int (__stdcall **)(int))(*(_DWORD *)v6 + 8);
  v7 = 0;
  return v4(v6);
}
// 4C6D48: using guessed type wchar_t aSetfileattribu[18];
// 4C6D6C: using guessed type wchar_t aSetdefaultcolu[18];
// 4C6DD0: using guessed type wchar_t aSelectcolumns[14];
// 4C7530: using guessed type wchar_t aRenametab[10];
// 4CABF8: using guessed type wchar_t aMergefiles[11];
// 4CADA0: using guessed type wchar_t aMassrename[11];
// 4CB2B4: using guessed type wchar_t aDestroyfiles[13];
// 4CB37C: using guessed type wchar_t aCustomizecolor[16];
// 4CBB88: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 4CBC00: using guessed type void *CDestroyFilesDialogPersistentSettings::`vftable';
// 4CBFE4: using guessed type void *CMassRenameDialogPersistentSettings::`vftable';
// 4CC04C: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 4CC0F4: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 4CC1AC: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 4CC1FC: using guessed type void *CSetDefaultColumnsDialogPersistentSettings::`vftable';
// 4CC24C: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;
// 4F05D8: using guessed type int dword_4F05D8;
// 4F07F4: using guessed type int dword_4F07F4;
// 4F07F8: using guessed type int dword_4F07F8;
// 4F0A18: using guessed type int dword_4F0A18;
// 4F0C40: using guessed type int dword_4F0C40;
// 4F0E60: using guessed type int dword_4F0E60;
// 4F107C: using guessed type int dword_4F107C;
// 4F1080: using guessed type int dword_4F1080;
// 4F1088: using guessed type int dword_4F1088;
// 4F12A4: using guessed type int dword_4F12A4;
// 4F12A8: using guessed type int dword_4F12A8;
// 4F14C8: using guessed type int dword_4F14C8;
// 4F1728: using guessed type int dword_4F1728;
// 4F1B50: using guessed type int dword_4F1B50;
// 4F1B54: using guessed type int dword_4F1B54;
// 4F1B58: using guessed type int dword_4F1B58;
// 4F1B60: using guessed type int dword_4F1B60;
// 4F1FD0: using guessed type int dword_4F1FD0;
// 4F1FD4: using guessed type int dword_4F1FD4;
// 4F1FD8: using guessed type int dword_4F1FD8;
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F2208: using guessed type int dword_4F2208;
// 4F220C: using guessed type int dword_4F220C;
// 4F2210: using guessed type int dword_4F2210;
// 4F221C: using guessed type int dword_4F221C;
// 4F2220: using guessed type int dword_4F2220;
// 4F222C: using guessed type int dword_4F222C;
// 4F2230: using guessed type int dword_4F2230;
// 4F2484: using guessed type int dword_4F2484;

//----- (00472D80) --------------------------------------------------------
int __usercall sub_472D80@<eax>(int result@<eax>, int a2@<edi>)
{
  int v2; // esi
  OLECHAR *v3; // edi
  void (__stdcall *v4)(int, OLECHAR *, int *); // edx
  int v5; // eax
  int v6; // ecx
  int *v7; // eax
  int *v8; // eax
  int *v9; // eax
  int *v10; // eax
  int *v11; // eax
  int *v12; // eax
  int *v13; // eax
  int *v14; // eax
  int *v15; // eax
  int *v16; // eax
  int *v17; // eax
  int *v18; // eax
  int *v19; // eax
  int v21; // [esp-4h] [ebp-34h]
  int v22; // [esp-4h] [ebp-34h]
  int v23; // [esp-4h] [ebp-34h]
  int v24; // [esp-4h] [ebp-34h]
  int v25; // [esp-4h] [ebp-34h]
  int v26; // [esp-4h] [ebp-34h]
  int v27; // [esp-4h] [ebp-34h]
  int v28; // [esp-4h] [ebp-34h]
  int v29; // [esp-4h] [ebp-34h]
  int v30; // [esp-4h] [ebp-34h]
  int v31; // [esp-4h] [ebp-34h]
  int v32; // [esp-4h] [ebp-34h]
  int v33; // [esp-4h] [ebp-34h]
  char v34[4]; // [esp+8h] [ebp-28h] BYREF
  OLECHAR *v35; // [esp+Ch] [ebp-24h]
  int v36; // [esp+10h] [ebp-20h] BYREF
  int v37; // [esp+14h] [ebp-1Ch]
  int v38; // [esp+18h] [ebp-18h] BYREF
  int v39; // [esp+1Ch] [ebp-14h] BYREF
  int v40; // [esp+20h] [ebp-10h] BYREF
  LPCWSTR lpString1; // [esp+24h] [ebp-Ch] BYREF
  int v42; // [esp+28h] [ebp-8h] BYREF
  int v43; // [esp+2Ch] [ebp-4h] BYREF

  v2 = result;
  v40 = 0;
  v39 = 0;
  v43 = 0;
  v38 = 0;
  if ( result )
  {
    v3 = SysAllocString(L"//State/*");
    v4 = *(void (__stdcall **)(int, OLECHAR *, int *))(*(_DWORD *)v2 + 144);
    v35 = v3;
    v4(v2, v3, &v40);
    v5 = v40;
    if ( v40 )
    {
      (*(void (__stdcall **)(int, int *))(*(_DWORD *)v40 + 32))(v40, &v36);
      v6 = 0;
      v37 = 0;
      if ( v36 > 0 )
      {
        do
        {
          if ( (*(int (__stdcall **)(int, int, int *, int))(*(_DWORD *)v40 + 28))(v40, v6, &v39, a2) >= 0
            && (*(int (__stdcall **)(int, int *))(*(_DWORD *)v39 + 68))(v39, &v43) >= 0 )
          {
            (*(void (__stdcall **)(int, int *))(*(_DWORD *)v43 + 44))(v43, &v42);
            if ( v42 >= 1 )
            {
              (*(void (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v43 + 40))(v43, 0, &v38);
              (*(void (__stdcall **)(int, char *))(*(_DWORD *)v38 + 28))(v38, v34);
              (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v38 + 104))(v38, &lpString1);
              if ( lstrcmpiW(lpString1, L"ColorRules") )
              {
                if ( lstrcmpiW(lpString1, L"CustomizeColors") )
                {
                  if ( lstrcmpiW(lpString1, L"Search") )
                  {
                    if ( lstrcmpiW(lpString1, L"WildcardSelect") )
                    {
                      if ( lstrcmpiW(lpString1, L"RenameTab") )
                      {
                        if ( lstrcmpiW(lpString1, L"MassRename") )
                        {
                          if ( lstrcmpiW(lpString1, L"Filter") )
                          {
                            if ( lstrcmpiW(lpString1, L"SplitFile") )
                            {
                              if ( lstrcmpiW(lpString1, L"DestroyFiles") )
                              {
                                if ( lstrcmpiW(lpString1, L"MergeFiles") )
                                {
                                  if ( lstrcmpiW(lpString1, L"SetFileAttributes") )
                                  {
                                    if ( lstrcmpiW(lpString1, L"SelectColumns") )
                                    {
                                      if ( !lstrcmpiW(lpString1, L"SetDefaultColumns") )
                                      {
                                        v33 = v42;
                                        v19 = sub_47FEE0();
                                        sub_464FA0(v43, (int)v19, v33);
                                      }
                                    }
                                    else
                                    {
                                      v32 = v42;
                                      v18 = sub_481280();
                                      sub_464FA0(v43, (int)v18, v32);
                                    }
                                  }
                                  else
                                  {
                                    v31 = v42;
                                    v17 = sub_47F480();
                                    sub_464FA0(v43, (int)v17, v31);
                                  }
                                }
                                else
                                {
                                  v30 = v42;
                                  v16 = sub_4978A0();
                                  sub_464FA0(v43, (int)v16, v30);
                                }
                              }
                              else
                              {
                                v29 = v42;
                                v15 = sub_4A3890();
                                sub_464FA0(v43, (int)v15, v29);
                              }
                            }
                            else
                            {
                              v28 = v42;
                              v14 = sub_47CC30();
                              sub_464FA0(v43, (int)v14, v28);
                            }
                          }
                          else
                          {
                            v27 = v42;
                            v13 = sub_49FCF0();
                            sub_464FA0(v43, (int)v13, v27);
                          }
                        }
                        else
                        {
                          v26 = v42;
                          v12 = sub_499070();
                          sub_464FA0(v43, (int)v12, v26);
                        }
                      }
                      else
                      {
                        v25 = v42;
                        v11 = sub_485830();
                        sub_464FA0(v43, (int)v11, v25);
                      }
                    }
                    else
                    {
                      v24 = v42;
                      v10 = sub_476B60();
                      sub_464FA0(v43, (int)v10, v24);
                    }
                  }
                  else
                  {
                    v23 = v42;
                    v9 = sub_482970();
                    sub_464FA0(v43, (int)v9, v23);
                  }
                }
                else
                {
                  v22 = v42;
                  v8 = sub_4A4570();
                  sub_464FA0(v43, (int)v8, v22);
                }
              }
              else
              {
                v21 = v42;
                v7 = sub_4A5410();
                sub_464FA0(v43, (int)v7, v21);
              }
            }
          }
          a2 = v39;
          (*(void (**)(void))(*(_DWORD *)v39 + 8))();
          v6 = v37 + 1;
          v39 = 0;
          v37 = v6;
        }
        while ( v6 < v36 );
        v3 = v35;
      }
      v5 = v40;
    }
    if ( v3 )
    {
      SysFreeString(v3);
      v5 = v40;
    }
    if ( v5 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
    result = v39;
    if ( v39 )
      return (*(int (__stdcall **)(int))(*(_DWORD *)v39 + 8))(v39);
  }
  return result;
}
// 472D80: could not find valid save-restore pair for edi
// 472D80: using guessed type char var_28[4];

//----- (00473030) --------------------------------------------------------
int __thiscall sub_473030(int *this)
{
  return sub_472910(this[4], this[6]);
}

//----- (00473040) --------------------------------------------------------
int __usercall sub_473040@<eax>(int a1@<ecx>, int a2@<edi>)
{
  return sub_472D80(*(_DWORD *)(a1 + 16), a2);
}

//----- (00473050) --------------------------------------------------------
int __thiscall sub_473050(void *this, int a2)
{
  char *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  char *v10; // edi
  void (__stdcall *v11)(void *, char *, int *); // edx
  int v12; // eax
  int v13; // edi
  int v14; // esi
  int v15; // ebx
  char *v16; // eax
  char *v17; // esi
  void **v18; // eax
  void **v19; // esi
  void **v20; // eax
  void **v21; // esi
  void **v22; // eax
  void **v23; // esi
  void **v24; // eax
  void **v25; // esi
  void **v26; // eax
  void **v27; // esi
  void **v28; // eax
  void **v29; // esi
  int v30; // edi
  _WORD *v31; // eax
  const WCHAR *v32; // ecx
  int v33; // esi
  _DWORD *v34; // ebx
  int (__stdcall *v35)(int, int *); // eax
  int *v36; // eax
  int *v37; // edi
  int j; // ecx
  int v39; // eax
  char ***v40; // esi
  int *v41; // eax
  int *v42; // esi
  char *v43; // eax
  unsigned int k; // ebx
  char *v45; // ecx
  char *v46; // ecx
  char ***v47; // edi
  char **v48; // eax
  char **v49; // esi
  _DWORD *v50; // ecx
  unsigned int m; // ebx
  char *v52; // edi
  char *v53; // eax
  char *v54; // eax
  char **v55; // eax
  int v56; // ecx
  char **v57; // edx
  char **v58; // esi
  _DWORD *v59; // ecx
  unsigned int n; // ebx
  char *v61; // edi
  char *v62; // eax
  char *v63; // ecx
  char **v64; // eax
  int v65; // ecx
  char **v66; // edx
  char **v67; // esi
  _DWORD *v68; // ecx
  unsigned int ii; // ebx
  char *v70; // edi
  char *v71; // eax
  char *v72; // ecx
  char **v73; // eax
  int v74; // ecx
  char **v75; // edx
  char **v76; // esi
  _DWORD *v77; // ecx
  unsigned int jj; // ebx
  char *v79; // edi
  char *v80; // eax
  char *v81; // ecx
  char **v82; // eax
  int v83; // ecx
  char **v84; // edx
  char **v85; // esi
  _DWORD *v86; // ecx
  unsigned int kk; // ebx
  char *v88; // edi
  char *v89; // eax
  char *v90; // ecx
  char **v91; // eax
  int v92; // ecx
  char **v93; // edx
  char **v94; // esi
  _DWORD *v95; // ecx
  unsigned int mm; // ebx
  char *v97; // edi
  char *v98; // eax
  char *v99; // ecx
  char **v100; // eax
  int v101; // ecx
  char **v102; // edx
  void **v103; // eax
  void *v104; // ecx
  void **v105; // esi
  void **v106; // eax
  void *v107; // ecx
  void **v108; // esi
  void **v109; // eax
  void *v110; // ecx
  void **v111; // esi
  void **v112; // eax
  void *v113; // ecx
  void **v114; // esi
  void **v115; // eax
  void *v116; // ecx
  void **v117; // esi
  void **v118; // eax
  void *v119; // ecx
  void **v120; // esi
  char *v121; // eax
  char *v122; // ecx
  char *v123; // esi
  char **v125; // ecx
  int v126; // [esp-4h] [ebp-140h]
  int v127; // [esp-4h] [ebp-140h]
  int v128; // [esp-4h] [ebp-140h]
  int v129; // [esp-4h] [ebp-140h]
  int v130; // [esp-4h] [ebp-140h]
  int v131; // [esp-4h] [ebp-140h]
  int v132; // [esp-4h] [ebp-140h]
  char *v133[3]; // [esp+10h] [ebp-12Ch] BYREF
  char *v134[3]; // [esp+1Ch] [ebp-120h] BYREF
  char *v135[3]; // [esp+28h] [ebp-114h] BYREF
  char *v136[3]; // [esp+34h] [ebp-108h] BYREF
  char *v137[3]; // [esp+40h] [ebp-FCh] BYREF
  char *v138[3]; // [esp+4Ch] [ebp-F0h] BYREF
  char *v139[3]; // [esp+58h] [ebp-E4h] BYREF
  int *v140; // [esp+64h] [ebp-D8h] BYREF
  int v141; // [esp+68h] [ebp-D4h]
  char *v142; // [esp+70h] [ebp-CCh] BYREF
  int v143; // [esp+74h] [ebp-C8h] BYREF
  LPCWSTR lpString1; // [esp+78h] [ebp-C4h] BYREF
  int v145; // [esp+7Ch] [ebp-C0h]
  const WCHAR *v146; // [esp+80h] [ebp-BCh] BYREF
  int v147; // [esp+84h] [ebp-B8h] BYREF
  int pExceptionObject[3]; // [esp+88h] [ebp-B4h] BYREF
  int v149[3]; // [esp+94h] [ebp-A8h] BYREF
  void *v150; // [esp+A0h] [ebp-9Ch]
  int v151; // [esp+A4h] [ebp-98h] BYREF
  _DWORD *i; // [esp+A8h] [ebp-94h]
  int v153; // [esp+ACh] [ebp-90h] BYREF
  int v154; // [esp+B0h] [ebp-8Ch]
  void *v155; // [esp+B4h] [ebp-88h] BYREF
  int v156; // [esp+B8h] [ebp-84h]
  int v157; // [esp+C0h] [ebp-7Ch] BYREF
  void *v158; // [esp+C4h] [ebp-78h] BYREF
  int v159; // [esp+C8h] [ebp-74h]
  void *v160; // [esp+D0h] [ebp-6Ch] BYREF
  int v161; // [esp+D4h] [ebp-68h]
  void *v162; // [esp+DCh] [ebp-60h] BYREF
  int v163; // [esp+E0h] [ebp-5Ch]
  void *v164; // [esp+E8h] [ebp-54h]
  void *v165; // [esp+ECh] [ebp-50h] BYREF
  int v166; // [esp+F0h] [ebp-4Ch]
  void *v167; // [esp+F8h] [ebp-44h] BYREF
  int v168; // [esp+FCh] [ebp-40h]
  char *v169; // [esp+104h] [ebp-38h] BYREF
  int v170; // [esp+108h] [ebp-34h]
  int v171; // [esp+110h] [ebp-2Ch] BYREF
  int v172; // [esp+114h] [ebp-28h] BYREF
  char *v173; // [esp+118h] [ebp-24h] BYREF
  char *v174; // [esp+11Ch] [ebp-20h] BYREF
  _DWORD *v175; // [esp+120h] [ebp-1Ch]
  int v176; // [esp+124h] [ebp-18h] BYREF
  _DWORD *v177; // [esp+128h] [ebp-14h]
  void *Block; // [esp+12Ch] [ebp-10h]
  int v179; // [esp+138h] [ebp-4h]

  v171 = 0;
  v172 = 0;
  v157 = 0;
  v176 = 0;
  v153 = 0;
  v151 = 0;
  v170 = 0;
  v3 = (char *)operator new(0x14u);
  if ( !v3 )
  {
    v173 = 0;
    std::exception::exception((std::exception *)v149, (const char *const *)&v173);
    v149[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v149, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v169 = v3;
  *(_DWORD *)v3 = v3;
  *((_DWORD *)v169 + 1) = v169;
  v179 = 0;
  v161 = 0;
  v4 = operator new(0x14u);
  if ( !v4 )
  {
    v174 = 0;
    v125 = &v174;
LABEL_134:
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v125);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v160 = v4;
  *v4 = v4;
  *((_DWORD *)v160 + 1) = v160;
  LOBYTE(v179) = 1;
  v156 = 0;
  v5 = operator new(0x14u);
  if ( !v5 )
  {
    v173 = 0;
    std::exception::exception((std::exception *)v149, (const char *const *)&v173);
    v149[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v149, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v155 = v5;
  *v5 = v5;
  *((_DWORD *)v155 + 1) = v155;
  LOBYTE(v179) = 2;
  v159 = 0;
  v6 = operator new(0x14u);
  if ( !v6 )
  {
    v174 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v174);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v158 = v6;
  *v6 = v6;
  *((_DWORD *)v158 + 1) = v158;
  LOBYTE(v179) = 3;
  v163 = 0;
  v7 = operator new(0x14u);
  if ( !v7 )
  {
    v173 = 0;
    std::exception::exception((std::exception *)v149, (const char *const *)&v173);
    v149[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v149, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v162 = v7;
  *v7 = v7;
  *((_DWORD *)v162 + 1) = v162;
  LOBYTE(v179) = 4;
  v166 = 0;
  v8 = operator new(0x14u);
  if ( !v8 )
  {
    v174 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v174);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v165 = v8;
  *v8 = v8;
  *((_DWORD *)v165 + 1) = v165;
  LOBYTE(v179) = 5;
  v168 = 0;
  v9 = operator new(0x14u);
  if ( !v9 )
  {
    v173 = 0;
    std::exception::exception((std::exception *)v149, (const char *const *)&v173);
    v149[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v149, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v167 = v9;
  *v9 = v9;
  *((_DWORD *)v167 + 1) = v167;
  LOBYTE(v179) = 6;
  v154 = 0;
  if ( !this )
    goto LABEL_113;
  v10 = (char *)SysAllocString(L"//Tabs/*");
  v11 = *(void (__stdcall **)(void *, char *, int *))(*(_DWORD *)this + 144);
  v174 = v10;
  v11(this, v10, &v171);
  v12 = v171;
  if ( v171 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v171 + 32))(v171, &v143);
    v13 = v143;
    v14 = 0;
    for ( i = malloc(4 * v143); v14 < v13; ++v14 )
      i[v14] = malloc(0x208u);
    v164 = malloc(1112 * v13);
    v15 = 0;
    v150 = malloc(532 * v13);
    v145 = 0;
    if ( v13 > 0 )
    {
      do
      {
        Block = (void *)(*(int (__stdcall **)(int, int, int *))(*(_DWORD *)v171 + 28))(v171, v15, &v172);
        v16 = *(char **)v169;
        *(_DWORD *)v169 = v169;
        *((_DWORD *)v169 + 1) = v169;
        v170 = 0;
        if ( v16 != v169 )
        {
          do
          {
            v17 = *(char **)v16;
            operator delete(v16);
            v16 = v17;
          }
          while ( v17 != v169 );
        }
        v18 = *(void ***)v160;
        *(_DWORD *)v160 = v160;
        *((_DWORD *)v160 + 1) = v160;
        v161 = 0;
        if ( v18 != v160 )
        {
          do
          {
            v19 = (void **)*v18;
            operator delete(v18);
            v18 = v19;
          }
          while ( v19 != v160 );
        }
        v20 = *(void ***)v155;
        *(_DWORD *)v155 = v155;
        *((_DWORD *)v155 + 1) = v155;
        v156 = 0;
        if ( v20 != v155 )
        {
          do
          {
            v21 = (void **)*v20;
            operator delete(v20);
            v20 = v21;
          }
          while ( v21 != v155 );
        }
        v22 = *(void ***)v158;
        *(_DWORD *)v158 = v158;
        *((_DWORD *)v158 + 1) = v158;
        v159 = 0;
        if ( v22 != v158 )
        {
          do
          {
            v23 = (void **)*v22;
            operator delete(v22);
            v22 = v23;
          }
          while ( v23 != v158 );
        }
        v24 = *(void ***)v162;
        *(_DWORD *)v162 = v162;
        *((_DWORD *)v162 + 1) = v162;
        v163 = 0;
        if ( v24 != v162 )
        {
          do
          {
            v25 = (void **)*v24;
            operator delete(v24);
            v24 = v25;
          }
          while ( v25 != v162 );
        }
        v26 = *(void ***)v165;
        *(_DWORD *)v165 = v165;
        *((_DWORD *)v165 + 1) = v165;
        v166 = 0;
        if ( v26 != v165 )
        {
          do
          {
            v27 = (void **)*v26;
            operator delete(v26);
            v26 = v27;
          }
          while ( v27 != v165 );
        }
        v28 = *(void ***)v167;
        *(_DWORD *)v167 = v167;
        *((_DWORD *)v167 + 1) = v167;
        v168 = 0;
        if ( v28 != v167 )
        {
          do
          {
            v29 = (void **)*v28;
            operator delete(v28);
            v28 = v29;
          }
          while ( v29 != v167 );
        }
        if ( (int)Block >= 0 && (*(int (__stdcall **)(int, int *))(*(_DWORD *)v172 + 68))(v172, &v153) >= 0 )
        {
          (*(void (__stdcall **)(int, int *))(*(_DWORD *)v153 + 44))(v153, &v147);
          v175 = (char *)v150 + 532 * v15;
          sub_4AFAF0(v175);
          v30 = 1;
          for ( Block = (void *)1; v30 < v147; Block = (void *)v30 )
          {
            (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)v153 + 40))(v153, v30, &v151);
            (*(void (__stdcall **)(int, LPCWSTR *))(*(_DWORD *)v151 + 28))(v151, &lpString1);
            (*(void (__stdcall **)(int, const WCHAR **))(*(_DWORD *)v151 + 104))(v151, &v146);
            if ( lstrcmpW(lpString1, L"Directory") )
            {
              sub_46D4A0(v146, lpString1, (_DWORD *)v164 + 278 * v15, v175);
              v30 = (int)Block;
            }
            else
            {
              v31 = (_WORD *)i[v15];
              v32 = v146;
              v33 = 260;
              while ( v33 != -2147483386 && *v32 )
              {
                *v31++ = *v32++;
                if ( !--v33 )
                {
                  *(v31 - 1) = 0;
                  goto LABEL_38;
                }
              }
              *v31 = 0;
            }
LABEL_38:
            ++v30;
          }
          v34 = (char *)v164 + 1112 * v15;
          v34[9] = *(_DWORD *)(a2 + 59332);
          v34[10] = *(_DWORD *)(a2 + 59336);
          v35 = *(int (__stdcall **)(int, int *))(*(_DWORD *)v172 + 52);
          v175 = v34;
          if ( !v35(v172, &v157)
            && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v157 + 64))(v157, &v157)
            && !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v157 + 52))(v157, &v176) )
          {
            (*(void (__stdcall **)(int, int *))(*(_DWORD *)v176 + 64))(v176, &v176);
            v141 = 0;
            v36 = (int *)operator new(0x14u);
            if ( !v36 )
            {
              v142 = 0;
              v125 = &v142;
              goto LABEL_134;
            }
            v37 = v36;
            *v36 = (int)v36;
            v140 = v36;
            v36[1] = (int)v36;
            LOBYTE(v179) = 7;
            for ( j = v176; v176; j = v176 )
            {
              v39 = sub_471D90(j, &v140);
              v37 = v140;
              switch ( v39 )
              {
                case 0:
                  v40 = (char ***)&v169;
                  goto LABEL_52;
                case 1:
                  sub_40B820((char ***)&v160, *v140, (int)v140, a2);
                  break;
                case 2:
                  v40 = (char ***)&v155;
                  goto LABEL_52;
                case 3:
                  sub_40B820((char ***)&v158, *v140, (int)v140, a2);
                  break;
                case 4:
                  v40 = (char ***)&v162;
                  goto LABEL_52;
                case 5:
                  sub_40B820((char ***)&v165, *v140, (int)v140, a2);
                  break;
                case 6:
                  v40 = (char ***)&v167;
LABEL_52:
                  sub_40B820(v40, *v140, (int)v140, a2);
                  break;
                default:
                  break;
              }
              (*(void (__stdcall **)(int, int *))(*(_DWORD *)v176 + 64))(v176, &v176);
              (*(void (__stdcall **)(int, int *))(*(_DWORD *)v176 + 64))(v176, &v176);
            }
            LOBYTE(v179) = 6;
            v41 = (int *)*v37;
            *v37 = (int)v37;
            v37[1] = (int)v37;
            v141 = 0;
            if ( v41 != v37 )
            {
              do
              {
                v42 = (int *)*v41;
                operator delete(v41);
                v41 = v42;
              }
              while ( v42 != v37 );
            }
            operator delete(v37);
          }
          v34[271] = &v169;
          v34[272] = &v160;
          v34[273] = &v155;
          v34[274] = &v158;
          v34[275] = &v162;
          v34[276] = &v165;
          v34[277] = &v167;
          Block = malloc(0xCCu);
          memset(Block, 0, 0xCCu);
          v43 = v169;
          for ( k = 0; k < 153; k += 3 )
          {
            v45 = *(char **)v43;
            if ( *(char **)v43 == v43 )
            {
LABEL_61:
              v46 = (char *)dword_4E5E84[k];
              v47 = (char ***)(v43 + 4);
              v133[0] = (char *)dword_4E5E80[k];
              v126 = *((_DWORD *)v43 + 1);
              v133[1] = v46;
              v133[2] = (char *)150;
              v48 = sub_41EEB0(v133, v43, v126);
              if ( v170 == 357913940 )
LABEL_135:
                std::_Xlength_error("list<T> too long");
              ++v170;
              *v47 = v48;
              *(_DWORD *)v48[1] = v48;
              v43 = v169;
            }
            else
            {
              while ( *((_DWORD *)v45 + 2) != dword_4E5E80[k] )
              {
                v45 = *(char **)v45;
                if ( v45 == v43 )
                  goto LABEL_61;
              }
            }
          }
          free(Block);
          v49 = (char **)v175[273];
          Block = v49;
          v50 = malloc(8u);
          *v50 = 0;
          v177 = v50;
          v50[1] = 0;
          for ( m = 0; m < 6; m += 3 )
          {
            v52 = *v49;
            v53 = *(char **)*v49;
            if ( v53 == *v49 )
            {
LABEL_68:
              v54 = (char *)dword_4E60E8[m];
              v127 = *((_DWORD *)v52 + 1);
              v136[0] = (char *)dword_4E60E4[m];
              v136[1] = v54;
              v136[2] = (char *)150;
              v55 = sub_41EEB0(v136, v52, v127);
              v56 = *((_DWORD *)Block + 1);
              if ( v56 == 357913940 )
                goto LABEL_135;
              v57 = (char **)Block;
              *((_DWORD *)Block + 1) = v56 + 1;
              *((_DWORD *)v52 + 1) = v55;
              *(_DWORD *)v55[1] = v55;
              v50 = v177;
              v49 = v57;
            }
            else
            {
              while ( *((_DWORD *)v53 + 2) != dword_4E60E4[m] )
              {
                v53 = *(char **)v53;
                if ( v53 == v52 )
                  goto LABEL_68;
              }
            }
          }
          free(v50);
          v58 = (char **)v175[272];
          Block = v58;
          v59 = malloc(0x18u);
          *v59 = 0;
          v59[1] = 0;
          v59[2] = 0;
          v59[3] = 0;
          v59[4] = 0;
          v177 = v59;
          v59[5] = 0;
          for ( n = 0; n < 18; n += 3 )
          {
            v61 = *v58;
            v62 = *(char **)*v58;
            if ( v62 == *v58 )
            {
LABEL_75:
              v63 = (char *)dword_4E6114[n];
              v128 = *((_DWORD *)v61 + 1);
              v135[0] = (char *)dword_4E6110[n];
              v135[1] = v63;
              v135[2] = (char *)150;
              v64 = sub_41EEB0(v135, v61, v128);
              v65 = *((_DWORD *)Block + 1);
              if ( v65 == 357913940 )
                goto LABEL_135;
              v66 = (char **)Block;
              *((_DWORD *)Block + 1) = v65 + 1;
              *((_DWORD *)v61 + 1) = v64;
              *(_DWORD *)v64[1] = v64;
              v59 = v177;
              v58 = v66;
            }
            else
            {
              while ( *((_DWORD *)v62 + 2) != dword_4E6110[n] )
              {
                v62 = *(char **)v62;
                if ( v62 == v61 )
                  goto LABEL_75;
              }
            }
          }
          free(v59);
          v67 = (char **)v175[274];
          Block = v67;
          v68 = malloc(0x18u);
          *v68 = 0;
          v68[1] = 0;
          v68[2] = 0;
          v68[3] = 0;
          v68[4] = 0;
          v177 = v68;
          v68[5] = 0;
          for ( ii = 0; ii < 18; ii += 3 )
          {
            v70 = *v67;
            v71 = *(char **)*v67;
            if ( v71 == *v67 )
            {
LABEL_82:
              v72 = (char *)dword_4E615C[ii];
              v129 = *((_DWORD *)v70 + 1);
              v134[0] = (char *)dword_4E6158[ii];
              v134[1] = v72;
              v134[2] = (char *)150;
              v73 = sub_41EEB0(v134, v70, v129);
              v74 = *((_DWORD *)Block + 1);
              if ( v74 == 357913940 )
                goto LABEL_135;
              v75 = (char **)Block;
              *((_DWORD *)Block + 1) = v74 + 1;
              *((_DWORD *)v70 + 1) = v73;
              *(_DWORD *)v73[1] = v73;
              v68 = v177;
              v67 = v75;
            }
            else
            {
              while ( *((_DWORD *)v71 + 2) != dword_4E6158[ii] )
              {
                v71 = *(char **)v71;
                if ( v71 == v70 )
                  goto LABEL_82;
              }
            }
          }
          free(v68);
          v76 = (char **)v175[275];
          Block = v76;
          v77 = malloc(0x18u);
          *v77 = 0;
          v77[1] = 0;
          v77[2] = 0;
          v77[3] = 0;
          v77[4] = 0;
          v177 = v77;
          v77[5] = 0;
          for ( jj = 0; jj < 18; jj += 3 )
          {
            v79 = *v76;
            v80 = *(char **)*v76;
            if ( v80 == *v76 )
            {
LABEL_89:
              v81 = (char *)dword_4E61A4[jj];
              v130 = *((_DWORD *)v79 + 1);
              v139[0] = (char *)dword_4E61A0[jj];
              v139[1] = v81;
              v139[2] = (char *)150;
              v82 = sub_41EEB0(v139, v79, v130);
              v83 = *((_DWORD *)Block + 1);
              if ( v83 == 357913940 )
                goto LABEL_135;
              v84 = (char **)Block;
              *((_DWORD *)Block + 1) = v83 + 1;
              *((_DWORD *)v79 + 1) = v82;
              *(_DWORD *)v82[1] = v82;
              v77 = v177;
              v76 = v84;
            }
            else
            {
              while ( *((_DWORD *)v80 + 2) != dword_4E61A0[jj] )
              {
                v80 = *(char **)v80;
                if ( v80 == v79 )
                  goto LABEL_89;
              }
            }
          }
          free(v77);
          v85 = (char **)v175[276];
          Block = v85;
          v86 = malloc(0x10u);
          *v86 = 0;
          v86[1] = 0;
          v86[2] = 0;
          v177 = v86;
          v86[3] = 0;
          for ( kk = 0; kk < 12; kk += 3 )
          {
            v88 = *v85;
            v89 = *(char **)*v85;
            if ( v89 == *v85 )
            {
LABEL_96:
              v90 = (char *)dword_4E61EC[kk];
              v131 = *((_DWORD *)v88 + 1);
              v138[0] = (char *)dword_4E61E8[kk];
              v138[1] = v90;
              v138[2] = (char *)150;
              v91 = sub_41EEB0(v138, v88, v131);
              v92 = *((_DWORD *)Block + 1);
              if ( v92 == 357913940 )
                goto LABEL_135;
              v93 = (char **)Block;
              *((_DWORD *)Block + 1) = v92 + 1;
              *((_DWORD *)v88 + 1) = v91;
              *(_DWORD *)v91[1] = v91;
              v86 = v177;
              v85 = v93;
            }
            else
            {
              while ( *((_DWORD *)v89 + 2) != dword_4E61E8[kk] )
              {
                v89 = *(char **)v89;
                if ( v89 == v88 )
                  goto LABEL_96;
              }
            }
          }
          free(v86);
          v94 = (char **)v175[277];
          Block = v94;
          v95 = malloc(8u);
          *v95 = 0;
          v177 = v95;
          v95[1] = 0;
          for ( mm = 0; mm < 6; mm += 3 )
          {
            v97 = *v94;
            v98 = *(char **)*v94;
            if ( v98 == *v94 )
            {
LABEL_103:
              v99 = (char *)dword_4E621C[mm];
              v132 = *((_DWORD *)v97 + 1);
              v137[0] = (char *)dword_4E6218[mm];
              v137[1] = v99;
              v137[2] = (char *)150;
              v100 = sub_41EEB0(v137, v97, v132);
              v101 = *((_DWORD *)Block + 1);
              if ( v101 == 357913940 )
                goto LABEL_135;
              v102 = (char **)Block;
              *((_DWORD *)Block + 1) = v101 + 1;
              *((_DWORD *)v97 + 1) = v100;
              *(_DWORD *)v100[1] = v100;
              v95 = v177;
              v94 = v102;
            }
            else
            {
              while ( *((_DWORD *)v98 + 2) != dword_4E6218[mm] )
              {
                v98 = *(char **)v98;
                if ( v98 == v97 )
                  goto LABEL_103;
              }
            }
          }
          free(v95);
          v15 = v145;
        }
        if ( !sub_47B6C0(a2, (const WCHAR *)i[v15], (int *)v164 + 278 * v15, (char *)v150 + 532 * v15) )
          ++v154;
        (*(void (__stdcall **)(int))(*(_DWORD *)v172 + 8))(v172);
        ++v15;
        v172 = 0;
        v145 = v15;
      }
      while ( v15 < v143 );
    }
    free(v150);
    free(v164);
    v12 = v171;
    v10 = v174;
  }
  if ( v10 )
  {
    SysFreeString((BSTR)v10);
LABEL_113:
    v12 = v171;
  }
  if ( v12 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
  if ( v172 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v172 + 8))(v172);
  v103 = *(void ***)v167;
  *(_DWORD *)v167 = v167;
  *((_DWORD *)v167 + 1) = v167;
  v104 = v167;
  v168 = 0;
  if ( v103 != v167 )
  {
    do
    {
      v105 = (void **)*v103;
      operator delete(v103);
      v104 = v167;
      v103 = v105;
    }
    while ( v105 != v167 );
  }
  operator delete(v104);
  v106 = *(void ***)v165;
  *(_DWORD *)v165 = v165;
  *((_DWORD *)v165 + 1) = v165;
  v107 = v165;
  v166 = 0;
  if ( v106 != v165 )
  {
    do
    {
      v108 = (void **)*v106;
      operator delete(v106);
      v107 = v165;
      v106 = v108;
    }
    while ( v108 != v165 );
  }
  operator delete(v107);
  v109 = *(void ***)v162;
  *(_DWORD *)v162 = v162;
  *((_DWORD *)v162 + 1) = v162;
  v110 = v162;
  v163 = 0;
  if ( v109 != v162 )
  {
    do
    {
      v111 = (void **)*v109;
      operator delete(v109);
      v110 = v162;
      v109 = v111;
    }
    while ( v111 != v162 );
  }
  operator delete(v110);
  v112 = *(void ***)v158;
  *(_DWORD *)v158 = v158;
  *((_DWORD *)v158 + 1) = v158;
  v113 = v158;
  v159 = 0;
  if ( v112 != v158 )
  {
    do
    {
      v114 = (void **)*v112;
      operator delete(v112);
      v113 = v158;
      v112 = v114;
    }
    while ( v114 != v158 );
  }
  operator delete(v113);
  v115 = *(void ***)v155;
  *(_DWORD *)v155 = v155;
  *((_DWORD *)v155 + 1) = v155;
  v116 = v155;
  v156 = 0;
  if ( v115 != v155 )
  {
    do
    {
      v117 = (void **)*v115;
      operator delete(v115);
      v116 = v155;
      v115 = v117;
    }
    while ( v117 != v155 );
  }
  operator delete(v116);
  v118 = *(void ***)v160;
  *(_DWORD *)v160 = v160;
  *((_DWORD *)v160 + 1) = v160;
  v119 = v160;
  v161 = 0;
  if ( v118 != v160 )
  {
    do
    {
      v120 = (void **)*v118;
      operator delete(v118);
      v119 = v160;
      v118 = v120;
    }
    while ( v120 != v160 );
  }
  operator delete(v119);
  v121 = *(char **)v169;
  *(_DWORD *)v169 = v169;
  *((_DWORD *)v169 + 1) = v169;
  v122 = v169;
  v170 = 0;
  if ( v121 != v169 )
  {
    do
    {
      v123 = *(char **)v121;
      operator delete(v121);
      v122 = v169;
      v121 = v123;
    }
    while ( v123 != v169 );
  }
  operator delete(v122);
  return v154;
}
// 47349A: conditional instruction was optimized away because esi.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4E5E80: using guessed type int dword_4E5E80[];
// 4E5E84: using guessed type int dword_4E5E84[];
// 4E60E4: using guessed type int dword_4E60E4[];
// 4E60E8: using guessed type int dword_4E60E8[];
// 4E6110: using guessed type int dword_4E6110[];
// 4E6114: using guessed type int dword_4E6114[];
// 4E6158: using guessed type int dword_4E6158[];
// 4E615C: using guessed type int dword_4E615C[];
// 4E61A0: using guessed type int dword_4E61A0[];
// 4E61A4: using guessed type int dword_4E61A4[];
// 4E61E8: using guessed type int dword_4E61E8[];
// 4E61EC: using guessed type int dword_4E61EC[];
// 4E6218: using guessed type int dword_4E6218[];
// 4E621C: using guessed type int dword_4E621C[];

//----- (00473F10) --------------------------------------------------------
int __thiscall sub_473F10(int this)
{
  return sub_473050(*(void **)(this + 16), *(_DWORD *)(this + 8));
}

//----- (00473FB0) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HMODULE v1; // eax
  BOOL (__stdcall *MiniDumpWriteDump)(HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, PMINIDUMP_EXCEPTION_INFORMATION, PMINIDUMP_USER_STREAM_INFORMATION, PMINIDUMP_CALLBACK_INFORMATION); // esi
  HANDLE FileW; // ebx
  HANDLE CurrentProcess; // eax
  DWORD CurrentProcessId; // [esp-18h] [ebp-470h]
  int v7[3]; // [esp+Ch] [ebp-44Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+18h] [ebp-440h] BYREF
  int v9[5]; // [esp+28h] [ebp-430h] BYREF
  __int16 v10; // [esp+3Ch] [ebp-41Ch]
  WCHAR Dest[260]; // [esp+40h] [ebp-418h] BYREF
  WCHAR FileName[262]; // [esp+248h] [ebp-210h] BYREF

  v9[0] = 7864389;
  v9[1] = 7078000;
  v9[2] = 7471215;
  v9[3] = 7471205;
  v9[4] = 2818091;
  v10 = 0;
  v1 = sub_40A920(L"Dbghelp.dll");
  if ( v1 )
  {
    MiniDumpWriteDump = (BOOL (__stdcall *)(HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, PMINIDUMP_EXCEPTION_INFORMATION, PMINIDUMP_USER_STREAM_INFORMATION, PMINIDUMP_CALLBACK_INFORMATION))GetProcAddress(v1, "MiniDumpWriteDump");
    if ( MiniDumpWriteDump )
    {
      GetLocalTime(&SystemTime);
      sub_466280(L"%TEMP%", Dest);
      sub_401000(
        0x104u,
        FileName,
        L"%s\\%s%s-%02d%02d%04d-%02d%02d%02d.dmp",
        Dest,
        v9,
        L"1.3.4.485",
        SystemTime.wDay,
        SystemTime.wMonth,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);
      FileW = CreateFileW(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);
      if ( FileW != (HANDLE)-1 )
      {
        v7[0] = GetCurrentThreadId();
        v7[1] = (int)ExceptionInfo;
        v7[2] = 0;
        CurrentProcessId = GetCurrentProcessId();
        CurrentProcess = GetCurrentProcess();
        MiniDumpWriteDump(
          CurrentProcess,
          CurrentProcessId,
          FileW,
          MiniDumpNormal,
          (PMINIDUMP_EXCEPTION_INFORMATION)v7,
          0,
          0);
      }
    }
  }
  return 0;
}
// 4C5A54: using guessed type wchar_t a134485[10];
// 4C5F00: using guessed type wchar_t aSSS02d02d04d02[38];

//----- (00474110) --------------------------------------------------------
int __thiscall sub_474110(unsigned __int16 *this)
{
  int v2; // edx
  unsigned __int16 *i; // eax
  int v4; // ecx
  int v5; // ecx
  __int16 v6; // cx
  _WORD *v7; // eax
  int v8; // ecx
  unsigned __int16 *v9; // ebx
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  __int16 v13; // ax
  _WORD *v14; // ebx
  int v15; // eax
  void (__stdcall *v16)(HWND, LPCWSTR, LPCWSTR, UINT); // edi
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  __int16 v20; // ax
  _WORD *v21; // ebx
  int v22; // eax
  _WORD *v23; // eax
  int v24; // edx
  __int16 v25; // cx
  HANDLE MutexW; // ebx
  HWND WindowW; // eax
  HWND v28; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v30; // eax
  void *v31; // edi
  char *v32; // edi
  char *v33; // eax
  LPARAM lParam[3]; // [esp+10h] [ebp-8C8h] BYREF
  int v36; // [esp+1Ch] [ebp-8BCh]
  unsigned __int16 *v37; // [esp+20h] [ebp-8B8h]
  void *v38[4]; // [esp+24h] [ebp-8B4h] BYREF
  int v39; // [esp+34h] [ebp-8A4h]
  unsigned int v40; // [esp+38h] [ebp-8A0h]
  WCHAR Text[312]; // [esp+40h] [ebp-898h] BYREF
  __int16 Src[260]; // [esp+2B0h] [ebp-628h] BYREF
  WCHAR pszPath[260]; // [esp+4B8h] [ebp-420h] BYREF
  __int16 psz1[260]; // [esp+6C0h] [ebp-218h] BYREF
  int v45; // [esp+8D4h] [ebp-4h]

  v36 = 0;
  sub_40A140((int)&dword_4EF704);
  v2 = 0;
  if ( this && *this )
  {
    for ( i = this; ; ++i )
    {
      v4 = *i;
      if ( v4 != 32 && v4 != 9 )
        break;
    }
    v5 = *i;
    if ( v5 == 34 )
    {
      v6 = i[1];
      v7 = i + 1;
      if ( v6 )
      {
        do
        {
          if ( v6 == 34 )
            break;
          ++v7;
          psz1[v2] = v6;
          v6 = *v7;
          ++v2;
        }
        while ( *v7 );
      }
      i = v7 + 1;
    }
    else if ( (_WORD)v5 )
    {
      do
      {
        if ( (_WORD)v5 == 32 )
          break;
        if ( (_WORD)v5 == 9 )
          break;
        ++i;
        psz1[v2] = v5;
        LOWORD(v5) = *i;
        ++v2;
      }
      while ( *i );
    }
    psz1[v2] = 0;
    while ( 1 )
    {
      v8 = *i;
      if ( v8 != 32 && v8 != 9 )
        break;
      ++i;
    }
    goto LABEL_66;
  }
  psz1[0] = 0;
  v37 = 0;
LABEL_21:
  while ( 1 )
  {
    v9 = v37;
    v10 = 0;
    if ( !v37 || !*v37 )
      return v36;
    while ( 1 )
    {
      v11 = *v9;
      if ( v11 != 32 && v11 != 9 )
        break;
      ++v9;
    }
    v12 = *v9;
    if ( v12 == 34 )
    {
      v13 = v9[1];
      v14 = v9 + 1;
      if ( v13 )
      {
        do
        {
          if ( v13 == 34 )
            break;
          ++v14;
          psz1[v10] = v13;
          v13 = *v14;
          ++v10;
        }
        while ( *v14 );
      }
      v9 = v14 + 1;
    }
    else if ( (_WORD)v12 )
    {
      do
      {
        if ( (_WORD)v12 == 32 )
          break;
        if ( (_WORD)v12 == 9 )
          break;
        ++v9;
        psz1[v10] = v12;
        LOWORD(v12) = *v9;
        ++v10;
      }
      while ( *v9 );
    }
    psz1[v10] = 0;
    while ( 1 )
    {
      v15 = *v9;
      if ( v15 != 32 && v15 != 9 )
        break;
      ++v9;
    }
    v37 = v9;
    if ( StrCmpW((PCWSTR)psz1, L"/?") )
    {
      v16 = (void (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))MessageBoxW;
    }
    else
    {
      qmemcpy(
        Text,
        L"Usage:\n"
         "explorer++.exe dir1 dir2 ... dirN\n"
         " where dir1 to dirN are the directories to open.\n"
         "\n"
         "e.g. explorer++.exe C:\\ D:\\\n"
         "will open the directories C:\\ and D:\\, each in their own tabs\n"
         "\n"
         "Virtual folders can be opened simply by supplying their name:\n"
         "e.g. explorer++.exe \"control panel\"\n"
         "will open the Control Panel\n",
        0x26Au);
      v16 = (void (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))MessageBoxW;
      MessageBoxW(0, Text, L"Explorer++", 0);
      v36 = 1;
    }
    if ( lstrcmpW((LPCWSTR)psz1, L"-l") )
    {
      if ( lstrcmpW((LPCWSTR)psz1, L"-clear_settings") )
      {
        if ( lstrcmpW((LPCWSTR)psz1, L"-remove_as_default") )
        {
          if ( lstrcmpW((LPCWSTR)psz1, L"-set_as_default") )
          {
            if ( lstrcmpW((LPCWSTR)psz1, L"-open_new_tab") )
            {
              CurrentProcessId = GetCurrentProcessId();
              v30 = OpenProcess(0x410u, 0, CurrentProcessId);
              v31 = v30;
              if ( v30 )
              {
                GetModuleFileNameExW(v30, 0, pszPath, 260);
                CloseHandle(v31);
              }
              PathRemoveFileSpecW(pszPath);
              sub_467360((LPCWSTR)psz1, (int)pszPath, (WCHAR *)Src);
              v40 = 7;
              v39 = 0;
              LOWORD(v38[0]) = 0;
              sub_4094F0(v38, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
              v45 = 0;
              v32 = dword_4EF704;
              v33 = sub_40A200(dword_4EF704, *((_DWORD *)dword_4EF704 + 1), (int)v38);
              if ( dword_4EF708 == 153391688 )
                std::_Xlength_error("list<T> too long");
              ++dword_4EF708;
              *((_DWORD *)v32 + 1) = v33;
              **((_DWORD **)v33 + 1) = v33;
              v45 = -1;
              if ( v40 >= 8 )
                operator delete(v38[0]);
              v40 = 7;
              v39 = 0;
              LOWORD(v38[0]) = 0;
            }
            else
            {
              MutexW = CreateMutexW(0, 1, L"Explorer++");
              if ( GetLastError() == 183 )
              {
                WindowW = FindWindowW(L"Explorer++", 0);
                v28 = WindowW;
                if ( WindowW )
                {
                  lParam[1] = 0;
                  lParam[2] = 0;
                  SendMessageW(WindowW, 0x4Au, 0, (LPARAM)lParam);
                  SetForegroundWindow(v28);
                  ShowWindow(v28, 5);
                }
              }
              if ( MutexW )
                CloseHandle(MutexW);
              v36 = 1;
            }
          }
          else if ( sub_4ACB60(L"openinexplorer++", 2, L"Open In Explorer++") )
          {
            v16(0, L"Explorer++ successfully set as default file manager.", L"Explorer++", 0);
          }
          else
          {
            v16(
              0,
              L"Could not set Explorer++ as default file manager. Please ensure you have administrator privileges.",
              L"Explorer++",
              0x30u);
          }
        }
        else if ( sub_4AC910((int)L"openinexplorer++") )
        {
          v16(0, L"Explorer++ successfully removed as default file manager.", L"Explorer++", 0);
        }
        else
        {
          v16(
            0,
            L"Could not remove Explorer++ as default file manager. Please ensure you have administrator privileges.",
            L"Explorer++",
            0x30u);
        }
      }
      else if ( SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++") )
      {
        v16(0, L"Settings could not be cleared.", L"Explorer++", 0x30u);
      }
      else
      {
        v16(0, L"Settings cleared successfully.", L"Explorer++", 0);
      }
    }
    else
    {
      v17 = 0;
      if ( !*v9 )
      {
        i = 0;
        psz1[0] = 0;
LABEL_66:
        v37 = i;
        continue;
      }
      while ( 1 )
      {
        v18 = *v9;
        if ( v18 != 32 && v18 != 9 )
          break;
        ++v9;
      }
      v19 = *v9;
      if ( v19 == 34 )
      {
        v20 = v9[1];
        v21 = v9 + 1;
        if ( v20 )
        {
          do
          {
            if ( v20 == 34 )
              break;
            ++v21;
            psz1[v17] = v20;
            v20 = *v21;
            ++v17;
          }
          while ( *v21 );
        }
        v9 = v21 + 1;
      }
      else if ( (_WORD)v19 )
      {
        do
        {
          if ( (_WORD)v19 == 32 )
            break;
          if ( (_WORD)v19 == 9 )
            break;
          ++v9;
          psz1[v17] = v19;
          LOWORD(v19) = *v9;
          ++v17;
        }
        while ( *v9 );
      }
      psz1[v17] = 0;
      while ( 1 )
      {
        v22 = *v9;
        if ( v22 != 32 && v22 != 9 )
          break;
        ++v9;
      }
      v23 = &unk_4EF3E0;
      v37 = v9;
      dword_4EF4DC = 1;
      v24 = 32;
      while ( v24 != -2147483614 )
      {
        v25 = *(_WORD *)((char *)v23 + (char *)psz1 - (char *)&unk_4EF3E0);
        if ( !v25 )
          break;
        *v23++ = v25;
        if ( !--v24 )
        {
          *(v23 - 1) = 0;
          goto LABEL_21;
        }
      }
      *v23 = 0;
    }
  }
}
// 474421: conditional instruction was optimized away because edx.4!=0
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4C5830: using guessed type wchar_t aOpeninexplorer[17];
// 4C5874: using guessed type wchar_t aOpeninexplorer_0[17];
// 4C5A14: using guessed type wchar_t aOpenInExplorer[19];
// 4C5BE0: using guessed type wchar_t aUsageExplorerE[309];
// 4EF4DC: using guessed type int dword_4EF4DC;
// 4EF708: using guessed type int dword_4EF708;
// 474110: using guessed type WCHAR psz1[260];
// 474110: using guessed type WCHAR Src[260];

//----- (004746F0) --------------------------------------------------------
__int16 __usercall sub_4746F0@<ax>(HINSTANCE a1@<esi>)
{
  DWORD dwErrCode[12]; // [esp+8h] [ebp-30h] BYREF

  dwErrCode[0] = 48;
  dwErrCode[1] = 0;
  dwErrCode[2] = (DWORD)sub_4B4E00;
  dwErrCode[3] = 0;
  dwErrCode[4] = 4;
  dwErrCode[5] = (DWORD)a1;
  dwErrCode[6] = (DWORD)LoadImageW(a1, (LPCWSTR)0x69, 1u, 48, 48, 0x80u);
  dwErrCode[11] = (DWORD)LoadImageW(a1, (LPCWSTR)0xCE, 1u, 16, 16, 0x80u);
  dwErrCode[7] = (DWORD)LoadCursorW(0, (LPCWSTR)0x7F00);
  dwErrCode[8] = 0;
  dwErrCode[9] = 0;
  dwErrCode[10] = (DWORD)L"Explorer++";
  return sub_418400((DWORD)dwErrCode);
}

//----- (00474780) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HINSTANCE v4; // edi
  unsigned __int16 *CommandLineW; // eax
  char *v7; // esi
  HMODULE v8; // esi
  bool v9; // cf
  int v10; // edi
  int v11; // eax
  int v12; // eax
  const WCHAR *v13; // eax
  int v14; // eax
  int v15; // esi
  HWND WindowW; // ebx
  HINSTANCE v17; // edi
  void **v18; // esi
  WCHAR *v19; // eax
  int v20; // edx
  int v21; // esi
  WCHAR v22; // cx
  HMODULE v23; // ebx
  ITEMIDLIST *v24; // edi
  int v25; // eax
  int SystemMetrics; // eax
  double v27; // st7
  double v28; // st6
  HACCEL AcceleratorsW; // ebx
  LPITEMIDLIST ppidl; // [esp+Ch] [ebp-3C4h] BYREF
  LPCITEMIDLIST pidl1; // [esp+10h] [ebp-3C0h] BYREF
  int v32; // [esp+14h] [ebp-3BCh]
  HMODULE hLibModule; // [esp+18h] [ebp-3B8h]
  void *v34; // [esp+1Ch] [ebp-3B4h]
  LPCITEMIDLIST pidl2; // [esp+20h] [ebp-3B0h] BYREF
  HANDLE hObject; // [esp+24h] [ebp-3ACh]
  HINSTANCE v37; // [esp+28h] [ebp-3A8h]
  LPARAM lParam; // [esp+2Ch] [ebp-3A4h] BYREF
  int v39; // [esp+30h] [ebp-3A0h]
  WCHAR *v40; // [esp+34h] [ebp-39Ch]
  DWORD dwErrCode[2]; // [esp+38h] [ebp-398h] BYREF
  struct tagMSG Msg; // [esp+40h] [ebp-390h] BYREF
  int v43; // [esp+5Ch] [ebp-374h] BYREF
  void *v44[4]; // [esp+60h] [ebp-370h] BYREF
  int v45; // [esp+70h] [ebp-360h]
  unsigned int v46; // [esp+74h] [ebp-35Ch]
  WINDOWPLACEMENT wndpl; // [esp+7Ch] [ebp-354h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+A8h] [ebp-328h] BYREF
  WCHAR File[262]; // [esp+1C0h] [ebp-210h] BYREF

  v4 = hInstance;
  v37 = hInstance;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) && VersionInformation.dwMajorVersion < 5 )
  {
    MessageBoxW(0, L"This application needs at least Windows XP or above to run properly.", L"Explorer++", 0x10u);
    return 0;
  }
  dwErrCode[0] = 8;
  dwErrCode[1] = 50693;
  sub_418540((DWORD)dwErrCode);
  OleInitialize(0);
  CommandLineW = GetCommandLineW();
  hObject = (HANDLE)sub_474110(CommandLineW);
  if ( !dword_4EF708 )
    goto LABEL_35;
  ppidl = 0;
  pidl2 = 0;
  if ( SHGetFolderLocation(0, 3, 0, 0, &ppidl) < 0 )
    goto LABEL_35;
  v7 = *(char **)dword_4EF704;
  v34 = v7;
  if ( v7 == dword_4EF704 )
    goto LABEL_32;
  while ( 1 )
  {
    v8 = (HMODULE)(v7 + 8);
    v9 = *((_DWORD *)v8 + 5) < 8u;
    hLibModule = v8;
    if ( v9 )
      v10 = (int)v8;
    else
      v10 = *(_DWORD *)v8;
    v32 = 0;
    if ( sub_467810((LPITEMIDLIST *)&pidl2, v10) >= 0 )
    {
      if ( !ILIsParent(ppidl, pidl2, 0) || (v11 = sub_466190(ppidl, pidl2), v8 = hLibModule, v11) )
      {
        VersionInformation.dwOSVersionInfoSize = 276;
        if ( !GetVersionExW(&VersionInformation) )
          goto LABEL_28;
        if ( VersionInformation.dwMajorVersion < 6 )
          goto LABEL_28;
        pidl1 = 0;
        if ( sub_467810((LPITEMIDLIST *)&pidl1, (int)L"::{26EE0668-A00A-44D7-9371-BEB064C98683}") < 0 )
          goto LABEL_28;
        if ( ILIsParent(pidl1, pidl2, 0) )
        {
          v12 = sub_466190(pidl1, pidl2);
          v8 = hLibModule;
          if ( !v12 )
            v32 = 1;
        }
        CoTaskMemFree((LPVOID)pidl1);
        if ( !v32 )
        {
LABEL_28:
          CoTaskMemFree((LPVOID)pidl2);
          if ( v32 )
            goto LABEL_30;
          goto LABEL_29;
        }
      }
      else
      {
        v32 = 1;
      }
      sub_466280(L"%windir%\\explorer.exe", File);
      if ( *((_DWORD *)v8 + 5) < 8u )
        v13 = (const WCHAR *)v8;
      else
        v13 = *(const WCHAR **)v8;
      ShellExecuteW(0, L"open", File, v13, 0, 1);
      v34 = (void *)*sub_40A1A0(&v43, (int)&dword_4EF704, v34);
      goto LABEL_28;
    }
LABEL_29:
    v34 = *(void **)v34;
LABEL_30:
    if ( v34 == dword_4EF704 )
      break;
    v7 = (char *)v34;
  }
  v4 = v37;
LABEL_32:
  if ( !dword_4EF708 )
    hObject = HANDLE_FLAG_INHERIT;
  CoTaskMemFree(ppidl);
LABEL_35:
  if ( hObject )
    return 0;
  ppidl = (LPITEMIDLIST)sub_48F8E0();
  if ( ppidl )
    v14 = sub_46C150();
  else
    v14 = sub_486920();
  v15 = v14;
  hObject = CreateMutexW(0, 1, L"Explorer++");
  if ( v15 || GetLastError() != 183 || (WindowW = FindWindowW(L"Explorer++", 0)) == 0 )
  {
    v23 = sub_40A920(L"Riched20.dll");
    hLibModule = v23;
    if ( sub_4746F0(v4) )
    {
      SetUnhandledExceptionFilter(TopLevelExceptionFilter);
      v24 = (ITEMIDLIST *)sub_418180(
                            L"Explorer++",
                            L"Explorer++",
                            0xCF0000u,
                            0x80000000,
                            0x80000000,
                            0x80000000,
                            0x80000000,
                            0,
                            v4,
                            0);
      pidl1 = v24;
      if ( v24 )
      {
        if ( ppidl )
          v25 = sub_46C3F0(&wndpl);
        else
          v25 = sub_486980((BYTE *)&wndpl);
        if ( !v25 )
        {
          wndpl.length = 44;
          wndpl.showCmd = nShowCmd;
          wndpl.flags = 0;
          wndpl.ptMinPosition.x = 0;
          wndpl.ptMinPosition.y = 0;
          wndpl.ptMaxPosition.x = -1;
          wndpl.ptMaxPosition.y = -1;
          ppidl = (LPITEMIDLIST)GetSystemMetrics(0);
          SystemMetrics = GetSystemMetrics(1);
          v27 = (double)(int)ppidl;
          v32 = SystemMetrics;
          v28 = (double)SystemMetrics;
          wndpl.rcNormalPosition.left = (int)(0.02 * v27);
          wndpl.rcNormalPosition.top = (int)(0.05 * v28);
          wndpl.rcNormalPosition.right = wndpl.rcNormalPosition.left - (int)(v27 * -0.96);
          wndpl.rcNormalPosition.bottom = wndpl.rcNormalPosition.top - (int)(v28 * -0.82);
          v24 = (ITEMIDLIST *)pidl1;
        }
        if ( nShowCmd == 6 || nShowCmd == 2 || nShowCmd == 3 )
          wndpl.showCmd = nShowCmd;
        SetWindowPlacement((HWND)v24, &wndpl);
        UpdateWindow((HWND)v24);
        AcceleratorsW = LoadAcceleratorsW(v37, (LPCWSTR)0x98);
        while ( GetMessageW(&Msg, 0, 0, 0) > 0 )
        {
          if ( !IsDialogMessageW(hDlg, &Msg)
            && !SendMessageW(hWnd, 0x475u, 0, (LPARAM)&Msg)
            && !TranslateAcceleratorW((HWND)v24, AcceleratorsW, &Msg) )
          {
            TranslateMessage(&Msg);
            DispatchMessageW(&Msg);
          }
          if ( !SendMessageW(hWnd, 0x476u, 0, 0) )
          {
            DestroyWindow(hWnd);
            hWnd = 0;
          }
        }
        FreeLibrary(hLibModule);
        OleUninitialize();
        if ( hObject )
          CloseHandle(hObject);
        return Msg.wParam;
      }
      MessageBoxW(0, L"Could not create main window.", L"Explorer++", 0x10u);
    }
    else
    {
      MessageBoxW(0, L"Could not register class", L"Explorer++", 0x10u);
    }
    FreeLibrary(v23);
    OleUninitialize();
    return 0;
  }
  if ( dword_4EF708 )
  {
    v17 = *(HINSTANCE *)dword_4EF704;
    v37 = (HINSTANCE)dword_4EF704;
    if ( v17 != (HINSTANCE)dword_4EF704 )
    {
      do
      {
        LOWORD(v44[0]) = 0;
        v46 = 7;
        v45 = 0;
        sub_4090E0((int)v44, (_DWORD *)v17 + 2, 0, 0xFFFFFFFF);
        v18 = (void **)v44[0];
        if ( v46 < 8 )
          v18 = v44;
        v19 = File;
        v20 = 260;
        v21 = (char *)v18 - (char *)File;
        while ( v20 != -2147483386 )
        {
          v22 = *(WCHAR *)((char *)v19 + v21);
          if ( !v22 )
            break;
          *v19++ = v22;
          if ( !--v20 )
          {
            --v19;
            break;
          }
        }
        *v19 = 0;
        v39 = 2 * v45 + 2;
        v40 = File;
        SendMessageW(WindowW, 0x4Au, 0, (LPARAM)&lParam);
        if ( v46 >= 8 )
          operator delete(v44[0]);
        v17 = *(HINSTANCE *)v17;
      }
      while ( v17 != v37 );
    }
  }
  else
  {
    v39 = 0;
    v40 = 0;
    SendMessageW(WindowW, 0x4Au, 0, (LPARAM)&lParam);
  }
  SetForegroundWindow(WindowW);
  ShowWindow(WindowW, 9);
  CloseHandle(hObject);
  return 0;
}
// 474B10: conditional instruction was optimized away because edx.4!=0
// 4C6040: using guessed type wchar_t a26ee0668A00a44[41];
// 4C60AC: using guessed type wchar_t aCouldNotCreate[30];
// 4EF708: using guessed type int dword_4EF708;

//----- (00474E70) --------------------------------------------------------
LRESULT __usercall sub_474E70@<eax>(int a1@<esi>)
{
  LPARAM v1; // ebx
  LPARAM *v2; // eax
  unsigned int v3; // eax
  HWND v5; // [esp-10h] [ebp-70h]
  HWND v6; // [esp-10h] [ebp-70h]
  LPARAM v7; // [esp-4h] [ebp-64h]
  LPARAM lParam[22]; // [esp+8h] [ebp-58h] BYREF

  if ( *(_DWORD *)(a1 + 59448) )
  {
    v1 = 24;
    v2 = (LPARAM *)(a1 + 59980);
  }
  else
  {
    v1 = 16;
    v2 = (LPARAM *)(a1 + 59976);
  }
  v7 = *v2;
  v5 = *(HWND *)(a1 + 88);
  lParam[21] = v1;
  SendMessageW(v5, 0x430u, 0, v7);
  SendMessageW(*(HWND *)(a1 + 88), 0x41Fu, 0, (unsigned __int16)v1 | ((unsigned __int16)v1 << 16));
  SendMessageW(*(HWND *)(a1 + 88), 0x421u, 0, 0);
  v3 = SendMessageW(*(HWND *)(a1 + 88), 0x43Au, 0, 0);
  v6 = *(HWND *)(a1 + 60);
  lParam[0] = 80;
  lParam[1] = 32;
  lParam[9] = 0;
  lParam[10] = HIWORD(v3);
  lParam[14] = HIWORD(v3);
  lParam[15] = HIWORD(v3);
  return SendMessageW(v6, 0x40Bu, 0, (LPARAM)lParam);
}

//----- (00474F60) --------------------------------------------------------
BOOL __userpurge sub_474F60@<eax>(int a1@<ebx>, HWND a2)
{
  HWND v2; // eax
  int v3; // edi
  int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  int Y; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+1Ch] [ebp-18h] BYREF

  v10 = 0;
  Y = 0;
  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  v2 = *(HWND *)(a1 + 60);
  v3 = Rect.right - Rect.left;
  v4 = Rect.bottom - Rect.top;
  if ( v2 )
  {
    GetWindowRect(v2, &Rect);
    Y = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 59284) )
  {
    GetWindowRect(*(HWND *)(a1 + 56), &Rect);
    v5 = Rect.bottom - Rect.top;
    v10 = Rect.bottom - Rect.top;
  }
  else
  {
    v5 = 0;
  }
  if ( *(_DWORD *)(a1 + 59296) )
  {
    v5 += *(_DWORD *)(a1 + 5584);
    v10 = v5;
  }
  if ( *(_DWORD *)(a1 + 59288) )
  {
    GetClientRect(*(HWND *)(a1 + 80), &Rect);
    v6 = Rect.right - Rect.left;
    v5 = v10;
  }
  else
  {
    v6 = 0;
  }
  v7 = Y;
  if ( *(_DWORD *)(a1 + 59320) )
  {
    if ( *(_DWORD *)(a1 + 59428) )
      return SetWindowPos(a2, 0, v6, v7, v3 - v6, v4 - v7 - v5 - 24, 0x84u);
    v7 = Y + 24;
  }
  if ( !*(_DWORD *)(a1 + 59428) )
    return SetWindowPos(a2, 0, v6, v7, v3 - v6, v4 - v7 - v5, 0x84u);
  return SetWindowPos(a2, 0, v6, v7, v3 - v6, v4 - v7 - v5 - 24, 0x84u);
}

//----- (00475080) --------------------------------------------------------
LRESULT __usercall sub_475080@<eax>(int a1@<esi>)
{
  struct tagRECT Rect; // [esp+4h] [ebp-14h] BYREF

  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  return SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
}

//----- (00475130) --------------------------------------------------------
LRESULT __usercall sub_475130@<eax>(int a1@<esi>)
{
  HWND v1; // ecx
  BOOL v2; // eax
  struct tagRECT Rect; // [esp+4h] [ebp-14h] BYREF

  v1 = *(HWND *)(a1 + 80);
  v2 = *(_DWORD *)(a1 + 59288) == 0;
  *(_DWORD *)(a1 + 59288) = v2;
  ShowWindow(v1, v2 ? 5 : 0);
  ShowWindow(*(HWND *)(a1 + 76), *(_DWORD *)(a1 + 59288) != 0 ? 5 : 0);
  SendMessageW(*(HWND *)(a1 + 88), 0x402u, 0xAFCDu, *(_DWORD *)(a1 + 59288));
  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  return SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
}

//----- (004751D0) --------------------------------------------------------
int __fastcall sub_4751D0(int a1, int a2)
{
  int v2; // eax
  int v3; // esi
  unsigned int v4; // eax
  char v5; // cl
  int v6; // eax
  _WORD *v7; // ecx
  unsigned int v8; // eax

  v2 = *(_DWORD *)(a2 + 12);
  if ( v2 < 0 || (unsigned int)v2 >= 0x14 )
    return 0;
  v3 = dword_4C60E8[v2];
  v4 = v3 - 45001;
  *(_BYTE *)(a2 + 24) = 4;
  switch ( v3 )
  {
    case 45002:
    case 45003:
    case 45013:
      v5 = 8;
      break;
    case 45005:
      v5 = 66;
      break;
    default:
      v5 = 0;
      break;
  }
  *(_BYTE *)(a2 + 25) = v5 | 0x10;
  *(_DWORD *)(a2 + 20) = v3;
  if ( v4 > 0x15 )
    v6 = -1;
  else
    v6 = sub_49A5C0(v4);
  v7 = *(_WORD **)(a2 + 40);
  *(_DWORD *)(a2 + 16) = v6;
  v8 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 32) = v3 - 45002;
  *(_DWORD *)(a2 + 28) = 0;
  if ( v8 )
  {
    if ( v8 <= 0x7FFFFFFF )
      sub_4A96F0(v8, (int)&unk_4F0338, v7);
  }
  return 1;
}
// 47521C: variable 'a2' is possibly undefined
// 4C60E8: using guessed type int dword_4C60E8[20];

//----- (004752B0) --------------------------------------------------------
HRESULT __thiscall sub_4752B0(_DWORD **this)
{
  IDataObject *v1; // ebx
  HRESULT result; // eax
  IDropSource *v4; // eax
  ITEMIDLIST *v5; // edi
  _DWORD *v6; // esi
  int v7; // ecx
  __int16 *v8; // eax
  _WORD *v9; // eax
  int v10; // edx
  char *v11; // esi
  __int16 v12; // cx
  HGLOBAL v13; // esi
  HGLOBAL v14; // esi
  _DWORD *v15; // eax
  LPDROPSOURCE v16; // esi
  HGLOBAL v17; // [esp-4h] [ebp-4A4h]
  DWORD pdwEffect; // [esp+14h] [ebp-48Ch] BYREF
  int v19[5]; // [esp+18h] [ebp-488h] BYREF
  __int16 v20; // [esp+2Ch] [ebp-474h]
  int v21; // [esp+30h] [ebp-470h]
  int v22; // [esp+34h] [ebp-46Ch]
  int v23; // [esp+38h] [ebp-468h]
  int v24; // [esp+3Ch] [ebp-464h]
  int v25[6]; // [esp+40h] [ebp-460h] BYREF
  int v26[2]; // [esp+58h] [ebp-448h] BYREF
  _DWORD **v27; // [esp+60h] [ebp-440h]
  LPVOID pv; // [esp+64h] [ebp-43Ch]
  LPSTREAM ppstm; // [esp+68h] [ebp-438h] BYREF
  LPDROPSOURCE pDropSource; // [esp+6Ch] [ebp-434h]
  int v31; // [esp+70h] [ebp-430h] BYREF
  HGLOBAL hMem; // [esp+74h] [ebp-42Ch]
  LPVOID v33; // [esp+78h] [ebp-428h] BYREF
  LPVOID ppv; // [esp+7Ch] [ebp-424h] BYREF
  __int16 v35[260]; // [esp+80h] [ebp-420h] BYREF
  __int16 v36[260]; // [esp+288h] [ebp-218h] BYREF
  int v37; // [esp+49Ch] [ebp-4h]

  v1 = 0;
  v27 = this;
  ppv = 0;
  result = CoCreateInstance(&rclsid, 0, 0x17u, &riid, &ppv);
  if ( result >= 0 )
  {
    v4 = (IDropSource *)operator new(0xCu);
    if ( v4 )
    {
      v4->lpVtbl = (struct IDropSourceVtbl *)&CDropSource::`vftable';
      v4[1].lpVtbl = (struct IDropSourceVtbl *)1;
      v4[2].lpVtbl = 0;
      pDropSource = v4;
    }
    else
    {
      pDropSource = 0;
    }
    v5 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD *))(*this[330] + 56))(this[330]);
    pv = v5;
    LOWORD(v19[0]) = RegisterClipboardFormatW(L"FileGroupDescriptorW");
    v19[4] = 1;
    v19[3] = -1;
    v19[2] = 1;
    v19[1] = 0;
    hMem = GlobalAlloc(2u, 0x3E8u);
    v6 = GlobalLock(hMem);
    *v6 = 1;
    v6[1] = 68;
    v6[10] = 128;
    v6[18] = 0x4000;
    v6[17] = 0;
    sub_466630(v5, (WCHAR *)v36, 1);
    v7 = 260;
    v8 = v36;
    while ( *v8 )
    {
      ++v8;
      if ( !--v7 )
        goto LABEL_10;
    }
    sub_4AA520(v7, (int)L".lnk", &v36[260 - v7]);
LABEL_10:
    v9 = v6 + 19;
    v10 = 260;
    v11 = (char *)((char *)v36 - (char *)(v6 + 19));
    while ( v10 != -2147483386 )
    {
      v12 = *(_WORD *)((char *)v9 + (_DWORD)v11);
      if ( !v12 )
        break;
      *v9++ = v12;
      if ( !--v10 )
      {
        --v9;
        break;
      }
    }
    v13 = hMem;
    v17 = hMem;
    *v9 = 0;
    GlobalUnlock(v17);
    v25[2] = 0;
    v25[1] = (int)v13;
    v25[0] = 1;
    v20 = RegisterClipboardFormatW(L"FileContents");
    v24 = 1;
    v23 = -1;
    v22 = 1;
    v21 = 0;
    v14 = GlobalAlloc(2u, 0x4000u);
    v33 = 0;
    v31 = 0;
    if ( CoCreateInstance(&stru_4BD8EC, 0, 1u, &stru_4BD82C, &v33) >= 0 )
    {
      sub_466630((const ITEMIDLIST *)pv, (WCHAR *)v35, 0x8000);
      (*(void (__stdcall **)(LPVOID, __int16 *))(*(_DWORD *)v33 + 80))(v33, v35);
      if ( (**(int (__stdcall ***)(LPVOID, void *, int *))v33)(v33, &unk_4BD9BC, &v31) >= 0 )
      {
        ppstm = 0;
        CreateStreamOnHGlobal(v14, 0, &ppstm);
        (*(void (__stdcall **)(int, LPSTREAM, int))(*(_DWORD *)v31 + 24))(v31, ppstm, 1);
      }
    }
    GlobalUnlock(v14);
    v25[5] = 0;
    v25[4] = (int)v14;
    v25[3] = 1;
    v26[0] = 0;
    v26[1] = 0;
    v15 = operator new(0x20u);
    hMem = v15;
    v37 = 0;
    if ( v15 )
      v1 = (IDataObject *)sub_462030(v15, v19, v25);
    v37 = -1;
    (*(void (__stdcall **)(LPVOID, _DWORD *, int *, IDataObject *))(*(_DWORD *)ppv + 16))(ppv, v27[21], v26, v1);
    v16 = pDropSource;
    DoDragDrop(v1, pDropSource, 4u, &pdwEffect);
    CoTaskMemFree(pv);
    v1->lpVtbl->Release(v1);
    v16->lpVtbl->Release(v16);
    return (*(int (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  }
  return result;
}
// 4753E3: conditional instruction was optimized away because ecx.4!=0
// 475434: conditional instruction was optimized away because edx.4!=0
// 4C6250: using guessed type wchar_t aLnk_1[5];
// 4CBDF4: using guessed type void *CDropSource::`vftable';
// 4752B0: using guessed type WCHAR var_218[260];
// 4752B0: using guessed type WCHAR var_420[260];

//----- (00475620) --------------------------------------------------------
int __usercall sub_475620@<eax>(int a1@<ecx>, int a2@<esi>)
{
  unsigned int v2; // eax
  int result; // eax
  const ITEMIDLIST *v5; // edi
  const ITEMIDLIST *v6; // edi
  LPARAM lParam[3]; // [esp+Ch] [ebp-123Ch] BYREF
  int v8; // [esp+18h] [ebp-1230h]
  _DWORD v9[386]; // [esp+20h] [ebp-1228h] BYREF
  char v10[528]; // [esp+628h] [ebp-C20h] BYREF
  __int16 v11[1024]; // [esp+838h] [ebp-A10h] BYREF
  __int16 v12[262]; // [esp+1038h] [ebp-210h] BYREF

  v2 = *(_DWORD *)(a2 + 16);
  if ( v2 && v2 <= 0x7FFFFFFF )
    sub_4A96F0(v2, (int)&unk_4C61D4, *(_WORD **)(a2 + 12));
  result = *(_DWORD *)(a2 + 20);
  if ( result == 45002 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 68))(*(_DWORD *)(a1 + 1320));
    if ( !result )
      return result;
    v5 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 1320) + 84))(
                               *(_DWORD *)(a1 + 1320),
                               -1);
    sub_466630(v5, (WCHAR *)v12, 1);
    sub_401000(0x400u, (wchar_t *)v11, L"Back to %s", v12);
LABEL_10:
    result = *(_DWORD *)(a2 + 16);
    if ( result )
    {
      if ( (unsigned int)result <= 0x7FFFFFFF )
        return sub_4A96F0(result, (int)v11, *(_WORD **)(a2 + 12));
    }
    return result;
  }
  if ( result == 45003 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 72))(*(_DWORD *)(a1 + 1320));
    if ( !result )
      return result;
    v6 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 1320) + 84))(
                               *(_DWORD *)(a1 + 1320),
                               1);
    sub_466630(v6, (WCHAR *)v12, 1);
    sub_401000(0x400u, (wchar_t *)v11, L"Forward to %s", v12);
    goto LABEL_10;
  }
  if ( result < 49000 )
  {
    if ( result < 47000 )
    {
      if ( result >= 46000 )
      {
        result = SendMessageW(*(HWND *)(a1 + 504), 0x419u, result, 0);
        if ( result != -1 )
        {
          SendMessageW(*(HWND *)(a1 + 504), 0x417u, result, (LPARAM)lParam);
          result = (int)sub_465D30(v8, v9);
          if ( v9[385] == 1 )
          {
            sub_401000(0x400u, (wchar_t *)v11, L"%s\n%s", v9, v10);
            return sub_4011B0(*(_DWORD *)(a2 + 16), (int)v11, *(_WORD **)(a2 + 12));
          }
        }
      }
    }
    else
    {
      result = SendMessageW(*(HWND *)(a1 + 508), 0x419u, result, 0);
      if ( result != -1 )
      {
        result = SendMessageW(*(HWND *)(a1 + 508), 0x417u, result, (LPARAM)lParam);
        if ( result )
        {
          result = sub_469A10(v8, a2, v11);
          if ( result >= 0 )
            return sub_4011B0(*(_DWORD *)(a2 + 16), (int)v11, *(_WORD **)(a2 + 12));
        }
      }
    }
  }
  else
  {
    result = SendMessageW(*(HWND *)(a1 + 512), 0x419u, result, 0);
    if ( result != -1 )
    {
      result = SendMessageW(*(HWND *)(a1 + 512), 0x417u, result, (LPARAM)lParam);
      if ( result )
        return sub_401000(*(_DWORD *)(a2 + 16), *(wchar_t **)(a2 + 12), L"%s\n%s", v8, v8 + 1024);
    }
  }
  return result;
}
// 4C61D8: using guessed type wchar_t aBackToS[11];
// 4C61F0: using guessed type wchar_t aForwardToS[14];
// 4C620C: using guessed type wchar_t aSS_4[6];
// 4C6218: using guessed type wchar_t aSS_5[6];
// 475620: using guessed type WCHAR var_210[262];
// 475620: using guessed type wchar_t var_A10[1024];
// 475620: using guessed type char var_C20[528];

//----- (004758B0) --------------------------------------------------------
void __usercall sub_4758B0(int a1@<esi>)
{
  WPARAM v1; // edi
  char *v2; // ecx
  _DWORD *v3; // eax
  _DWORD *v4; // edx
  char *v5; // ecx
  int v6; // eax
  unsigned int v7; // eax
  int v8; // eax
  char v9; // al
  char *Block; // [esp+8h] [ebp-4h]

  v1 = 0;
  v2 = (char *)malloc(20 * *(_DWORD *)(a1 + 60392));
  v3 = *(_DWORD **)(a1 + 60388);
  v4 = (_DWORD *)*v3;
  Block = v2;
  if ( (_DWORD *)*v3 != v3 )
  {
    v5 = v2 + 8;
    do
    {
      if ( v1 < *(_DWORD *)(a1 + 60392) )
      {
        v6 = v4[2];
        if ( v6 == 45001 )
        {
          *((_DWORD *)v5 - 2) = 0;
          *((_DWORD *)v5 - 1) = 0;
          *(_WORD *)v5 = 260;
          *((_DWORD *)v5 + 1) = 0;
          *((_DWORD *)v5 + 2) = 0;
        }
        else
        {
          v7 = v6 - 45001;
          if ( v7 > 0x15 )
            v8 = -1;
          else
            v8 = sub_49A5C0(v7);
          *((_DWORD *)v5 - 2) = v8;
          *((_DWORD *)v5 - 1) = v4[2];
          *v5 = 4;
          switch ( v4[2] )
          {
            case 0xAFCA:
            case 0xAFCB:
            case 0xAFD5:
              v9 = 8;
              break;
            case 0xAFCD:
              v9 = 66;
              break;
            default:
              v9 = 0;
              break;
          }
          v5[1] = v9 | 0x10;
          *((_DWORD *)v5 + 1) = 0;
          *((_DWORD *)v5 + 2) = v4[2] - 45002;
        }
        ++v1;
        v5 += 20;
      }
      v4 = (_DWORD *)*v4;
    }
    while ( v4 != *(_DWORD **)(a1 + 60388) );
    v2 = Block;
  }
  SendMessageW(*(HWND *)(a1 + 88), 0x444u, v1, (LPARAM)v2);
  free(Block);
}
// 475921: variable 'v5' is possibly undefined
// 475924: variable 'v4' is possibly undefined

//----- (004759F0) --------------------------------------------------------
void __usercall sub_4759F0(int a1@<eax>)
{
  HWND v2; // edi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  HWND v5; // ebx
  bool v6; // zf
  unsigned __int16 v7; // ax
  LPARAM *v8; // edx
  HWND v9; // [esp-10h] [ebp-2Ch]
  LPARAM lParam[3]; // [esp+Ch] [ebp-10h] BYREF
  LPARAM *v11; // [esp+18h] [ebp-4h]

  v2 = *(HWND *)(a1 + 60);
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"ToolbarWindow32", &word_4C30C0, 0x54009964u, 0, 0, 0, 0, v2, 0, ModuleHandleW, 0);
  v5 = Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 153);
  v6 = *(_DWORD *)(a1 + 59448) == 0;
  *(_DWORD *)(a1 + 88) = v5;
  if ( v6 )
  {
    v7 = 16;
    v8 = (LPARAM *)(a1 + 59976);
  }
  else
  {
    v7 = 24;
    v8 = (LPARAM *)(a1 + 59980);
  }
  v11 = v8;
  SendMessageW(v5, 0x420u, 0, v7 | (v7 << 16));
  SendMessageW(*(HWND *)(a1 + 88), 0x41Eu, 0x14u, 0);
  SendMessageW(*(HWND *)(a1 + 88), 0x430u, 0, *v11);
  sub_49A780(a1);
  sub_4758B0(a1);
  if ( !*(_DWORD *)(a1 + 5652) )
  {
    if ( *(_DWORD *)(a1 + 5604) )
    {
      v9 = *(HWND *)(a1 + 88);
      lParam[0] = -2147483647;
      lParam[1] = (LPARAM)L"Software\\Explorer++\\Settings";
      lParam[2] = (LPARAM)L"ToolbarState";
      SendMessageW(v9, 0x44Cu, 0, (LPARAM)lParam);
    }
  }
}
// 4C617C: using guessed type wchar_t aSoftwareExplor_0[29];
// 4C61B8: using guessed type wchar_t aToolbarstate_0[13];

//----- (00475AF0) --------------------------------------------------------
LRESULT __usercall sub_475AF0@<eax>(int a1@<eax>)
{
  signed int i; // edi

  for ( i = SendMessageW(*(HWND *)(a1 + 88), 0x418u, 0, 0) - 1; i >= 0; --i )
    SendMessageW(*(HWND *)(a1 + 88), 0x416u, i, 0);
  sub_4758B0(a1);
  return sub_49B450(a1);
}

//----- (00475B30) --------------------------------------------------------
int __userpurge sub_475B30@<eax>(int a1@<edx>, WPARAM a2@<ebx>, int a3@<edi>, int a4, DWORD dwErrCode)
{
  if ( a3 == 7 )
  {
    sub_49B450(a1);
  }
  else if ( a3 == 256 )
  {
    if ( a2 == 13 )
    {
      SendMessageW(*(HWND *)(a1 + 52), 0x8002u, 0xDu, 0);
      return 0;
    }
  }
  else if ( a3 == 522 && sub_479400(dwErrCode, a1, a2, 2) )
  {
    return 0;
  }
  return sub_401C60(a4, a3, a2, dwErrCode);
}

//----- (00475BA0) --------------------------------------------------------
int __stdcall sub_475BA0(int a1, int a2, WPARAM a3, DWORD a4, int a5, int a6)
{
  return sub_475B30(a6, a3, a2, a1, a4);
}

//----- (00475BD0) --------------------------------------------------------
HWND __thiscall sub_475BD0(HWND hWndParent, int a2, int a3)
{
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  HWND v6; // esi
  int v7; // ebx
  HMODULE v8; // eax
  HBITMAP ho; // [esp+Ch] [ebp-24h]
  int v11; // [esp+14h] [ebp-1Ch]
  LPARAM lParam[2]; // [esp+18h] [ebp-18h] BYREF
  __int16 v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+24h] [ebp-Ch]
  int v15; // [esp+28h] [ebp-8h]

  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(
             0,
             L"ToolbarWindow32",
             &word_4C30C0,
             0x5400994Cu,
             0,
             0,
             0,
             0,
             hWndParent,
             0,
             ModuleHandleW,
             0);
  v6 = Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 136);
  SendMessageW(v6, 0x420u, 0, 458759);
  SendMessageW(v6, 0x41Eu, 0x14u, 0);
  v7 = sub_4018B0(7, 7, 33, 0, 2u);
  v8 = GetModuleHandleW(0);
  ho = LoadBitmapW(v8, (LPCWSTR)0x66);
  v11 = sub_4011E0(v7, (int)ho, 0);
  DeleteObject(ho);
  SendMessageW(v6, 0x430u, 0, v7);
  lParam[0] = v11;
  lParam[1] = a2;
  v13 = 4100;
  v14 = 0;
  v15 = a3;
  SendMessageW(v6, 0x444u, 1u, (LPARAM)lParam);
  SendMessageW(v6, 0x41Fu, 0, 1048592);
  SendMessageW(v6, 0x421u, 0, 0);
  return v6;
}

//----- (00475D00) --------------------------------------------------------
HRESULT __usercall sub_475D00@<eax>(DWORD a1@<edi>)
{
  HWND v1; // esi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  int v4; // esi
  IDropTarget *v5; // eax
  IDropTarget *v6; // esi
  IDropTarget *v7; // ebx

  v1 = *(HWND *)(a1 + 60);
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"ToolbarWindow32", &word_4C30C0, 0x56009944u, 0, 0, 0, 0, v1, 0, ModuleHandleW, 0);
  v4 = (int)Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 153);
  *(_DWORD *)(a1 + 504) = v4;
  sub_409750(v4, (int)sub_4A73F0, 0, a1);
  SendMessageW(*(HWND *)(a1 + 504), 0x420u, 0, 1048592);
  SendMessageW(*(HWND *)(a1 + 504), 0x41Eu, 0x14u, 0);
  v5 = (IDropTarget *)operator new(0x18u);
  v6 = v5;
  if ( v5 )
  {
    v7 = v5 + 3;
    v5->lpVtbl = (struct IDropTargetVtbl *)&Explorerplusplus::CBookmarkToolbarDrop::`vftable';
    v5[2].lpVtbl = (struct IDropTargetVtbl *)a1;
    if ( CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)&v5[3].lpVtbl) >= 0 )
      (*(void (__stdcall **)(struct IDropTargetVtbl *, void *, IDropTarget *))v7->lpVtbl->QueryInterface)(
        v7->lpVtbl,
        &unk_4BD88C,
        v6 + 4);
  }
  else
  {
    v6 = 0;
  }
  return RegisterDragDrop(*(HWND *)(a1 + 504), v6);
}
// 4CB920: using guessed type void *Explorerplusplus::CBookmarkToolbarDrop::`vftable';

//----- (00475E30) --------------------------------------------------------
HRESULT __usercall sub_475E30@<eax>(DWORD a1@<esi>)
{
  HWND v1; // edi
  HMODULE ModuleHandleW; // eax
  HWND v3; // edi
  HIMAGELIST phimlSmall; // [esp+4h] [ebp-4h] BYREF

  v1 = *(HWND *)(a1 + 500);
  ModuleHandleW = GetModuleHandleW(0);
  *(_DWORD *)(a1 + 84) = CreateWindowExW(
                           0x80u,
                           L"ComboBoxEx32",
                           &word_4C30E4,
                           0x56010042u,
                           0,
                           0,
                           0,
                           200,
                           v1,
                           0,
                           ModuleHandleW,
                           0);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(*(HWND *)(a1 + 84), 0x402u, 0, (LPARAM)phimlSmall);
  v3 = (HWND)SendMessageW(*(HWND *)(a1 + 84), 0x407u, 0, 0);
  sub_409750((int)v3, (int)sub_475BA0, 0, a1);
  return SHAutoComplete(v3, 0x10000001u);
}

//----- (00475ED0) --------------------------------------------------------
LRESULT __usercall sub_475ED0@<eax>(int a1@<esi>)
{
  HWND v1; // edi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  HWND v4; // ebx
  int v5; // ebx
  HMODULE v6; // eax
  HWND v8; // [esp-10h] [ebp-90h]
  HBITMAP ho; // [esp+Ch] [ebp-74h]
  LPARAM lParam[2]; // [esp+10h] [ebp-70h] BYREF
  __int16 v11; // [esp+18h] [ebp-68h]
  int v12; // [esp+1Ch] [ebp-64h]
  int v13; // [esp+20h] [ebp-60h]
  int v14; // [esp+24h] [ebp-5Ch]
  int v15; // [esp+28h] [ebp-58h]
  __int16 v16; // [esp+2Ch] [ebp-54h]
  int v17; // [esp+30h] [ebp-50h]
  WCHAR *v18; // [esp+34h] [ebp-4Ch]
  WCHAR Buffer[34]; // [esp+38h] [ebp-48h] BYREF

  v1 = *(HWND *)(a1 + 60);
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"ToolbarWindow32", &word_4C30C0, 0x56009944u, 0, 0, 0, 0, v1, 0, ModuleHandleW, 0);
  v4 = Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 136);
  *(_DWORD *)(a1 + 500) = v4;
  SendMessageW(v4, 0x420u, 0, 1048592);
  SendMessageW(*(HWND *)(a1 + 500), 0x41Eu, 0x14u, 0);
  v5 = sub_4018B0(16, 16, 33, 0, 1u);
  v6 = GetModuleHandleW(0);
  ho = LoadBitmapW(v6, (LPCWSTR)0xC2);
  sub_4011E0(v5, (int)ho, 0);
  DeleteObject(ho);
  SendMessageW(*(HWND *)(a1 + 500), 0x430u, 0, v5);
  lParam[0] = 0;
  lParam[1] = 0;
  v11 = 260;
  v12 = 0;
  v13 = 0;
  LoadStringW(hInstance, 0x1F6Fu, Buffer, 32);
  v8 = *(HWND *)(a1 + 500);
  v14 = 0;
  v15 = 48000;
  v16 = 4100;
  v17 = 0;
  v18 = Buffer;
  return SendMessageW(v8, 0x444u, 2u, (LPARAM)lParam);
}

//----- (00476010) --------------------------------------------------------
void __usercall sub_476010(DWORD a1@<esi>)
{
  HWND v1; // edi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  int v4; // edi

  v1 = *(HWND *)(a1 + 60);
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"ToolbarWindow32", &word_4C30C0, 0x56009944u, 0, 0, 0, 0, v1, 0, ModuleHandleW, 0);
  v4 = (int)Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 144);
  *(_DWORD *)(a1 + 508) = v4;
  sub_409750(v4, (int)sub_4A2550, 0, a1);
  SendMessageW(*(HWND *)(a1 + 508), 0x420u, 0, 1048592);
  SendMessageW(*(HWND *)(a1 + 508), 0x41Eu, 0x14u, 0);
  sub_4A2230((HWND *)a1);
}

//----- (004760B0) --------------------------------------------------------
int __fastcall sub_4760B0(WPARAM a1, int a2, int a3, int a4, LPARAM lParam)
{
  HWND v8; // eax
  HWND v9; // ecx
  WPARAM v10; // esi
  int v11; // eax
  HWND v12; // ecx
  WPARAM v13; // eax
  WPARAM v14; // eax
  int v15; // edi
  char KeyState; // al
  HWND v17; // ecx
  WPARAM v18; // esi
  DWORD MessagePos; // eax
  char **v20[2]; // [esp-Ch] [ebp-A8h] BYREF
  int v21; // [esp-4h] [ebp-A0h]
  LPVOID pv; // [esp+10h] [ebp-8Ch] BYREF
  int v23; // [esp+14h] [ebp-88h] BYREF
  void *v24[4]; // [esp+18h] [ebp-84h] BYREF
  int v25[7]; // [esp+28h] [ebp-74h] BYREF
  DWORD_PTR dwRefData[12]; // [esp+44h] [ebp-58h] BYREF
  LPARAM v27[5]; // [esp+74h] [ebp-28h] BYREF
  int v28; // [esp+98h] [ebp-4h]

  pv = (LPVOID)a3;
  v23 = a2;
  if ( a4 != 78 )
  {
    if ( a4 == 278 )
    {
      SendMessageW(*(HWND *)(a2 + 52), 0x116u, a1, lParam);
      return sub_401C60((int)pv, 278, a1, lParam);
    }
    if ( a4 == 287 )
    {
      SendMessageW(*(HWND *)(a2 + 52), 0x11Fu, a1, lParam);
      return sub_401C60((int)pv, 287, a1, lParam);
    }
    return sub_401C60((int)pv, a4, a1, lParam);
  }
  if ( *(_DWORD *)(lParam + 8) != -5 )
    return sub_401C60((int)pv, a4, a1, lParam);
  v8 = *(HWND *)lParam;
  v9 = *(HWND *)(a2 + 504);
  if ( *(HWND *)lParam != v9 )
  {
    v12 = *(HWND *)(a2 + 508);
    if ( v8 == v12 )
    {
      v13 = *(_DWORD *)(lParam + 12);
      if ( v13 != -1 )
      {
        v14 = SendMessageW(v12, 0x419u, v13, 0);
        if ( v14 != -1 && SendMessageW(*(HWND *)(a2 + 508), 0x417u, v14, (LPARAM)v27) )
        {
          pv = 0;
          if ( sub_467810((LPITEMIDLIST *)&pv, v27[3]) >= 0 )
          {
            v15 = v23;
            ClientToScreen(*(HWND *)(v23 + 508), (LPPOINT)(lParam + 20));
            sub_40A470(v24);
            v24[3] = v20;
            v28 = 0;
            sub_40ACF0(v20, (int **)v24);
            sub_4AD000((int)dwRefData, *(_DWORD *)(v15 + 508), (LPCITEMIDLIST)pv, v20[0], (int)v20[1], v21);
            LOBYTE(v28) = 1;
            v21 = *(_DWORD *)(v15 + 56);
            v23 = 3;
            sub_4623B0((int)v25, v21);
            LOBYTE(v28) = 2;
            KeyState = GetKeyState(16);
            sub_4AD640(
              (DWORD_PTR)dwRefData,
              lParam + 20,
              v15 + 20,
              lParam + 20,
              (int)v25,
              (int)&v23,
              0,
              KeyState & 0x80);
            CoTaskMemFree(pv);
            sub_462390((int)v25);
            LOBYTE(v28) = 0;
            sub_4ACF20(dwRefData);
            sub_41ECB0(v24);
          }
        }
        return 1;
      }
    }
    else
    {
      v17 = *(HWND *)(a2 + 512);
      if ( v8 == v17 )
      {
        v18 = *(_DWORD *)(lParam + 12);
        if ( v18 == -1 )
        {
          sub_4A84E0(a2);
        }
        else
        {
          *(_DWORD *)(a2 + 60384) = SendMessageW(v17, 0x419u, v18, 0);
          SetFocus(*(HWND *)(a2 + 512));
          MessagePos = GetMessagePos();
          TrackPopupMenu(*(HMENU *)(a2 + 3480), 0, (__int16)MessagePos, SHIWORD(MessagePos), 0, *(HWND *)(a2 + 60), 0);
        }
        return 1;
      }
    }
    goto LABEL_21;
  }
  v10 = *(_DWORD *)(lParam + 12);
  if ( v10 == -1 )
  {
LABEL_21:
    sub_48F5E0(a2);
    return 1;
  }
  v11 = SendMessageW(v9, 0x419u, v10, 0);
  sub_48F5A0(a2, v11);
  return 1;
}

//----- (00476380) --------------------------------------------------------
int __stdcall sub_476380(int a1, int a2, int a3, LPARAM lParam, int a5, int a6)
{
  return sub_4760B0(a3, a6, a1, a2, lParam);
}

//----- (004763A0) --------------------------------------------------------
LRESULT __thiscall sub_4763A0(DWORD dwErrCode)
{
  HMODULE ModuleHandleW; // eax
  HWND v3; // eax
  unsigned int *v4; // ebx
  unsigned int v5; // eax
  LPARAM v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  LPARAM v9; // eax
  unsigned int v10; // eax
  LPARAM v11; // eax
  unsigned int v12; // eax
  LPARAM v13; // eax
  LRESULT result; // eax
  int v15; // [esp+Ch] [ebp-54h]
  LPARAM lParam[2]; // [esp+10h] [ebp-50h] BYREF
  WCHAR Buffer[34]; // [esp+18h] [ebp-48h] BYREF

  if ( *(_DWORD *)(dwErrCode + 59360) )
    dword_4E1C98 |= 0x800u;
  ModuleHandleW = GetModuleHandleW(0);
  v3 = sub_418180(L"ReBarWindow32", &word_4C615C, dword_4E1C98, 0, 0, 0, 0, *(HWND *)(dwErrCode + 52), ModuleHandleW, 0);
  *(_DWORD *)(dwErrCode + 60) = v3;
  sub_409750((int)v3, (int)sub_476380, 0, dwErrCode);
  v4 = (unsigned int *)(dwErrCode + 59616);
  v15 = 5;
  do
  {
    switch ( v4[3] )
    {
      case 0u:
        sub_4759F0(dwErrCode);
        v5 = (unsigned int)SendMessageW(*(HWND *)(dwErrCode + 88), 0x43Au, 0, 0) >> 16;
        *v4 = v5;
        v4[5] = v5;
        v4[4] = v5;
        SendMessageW(*(HWND *)(dwErrCode + 88), 0x453u, 0, (LPARAM)lParam);
        v6 = lParam[0];
        if ( !v4[1] )
          v4[1] = lParam[0];
        v4[7] = v6;
        *(v4 - 2) = *(_DWORD *)(dwErrCode + 88);
        break;
      case 1u:
        sub_475ED0(dwErrCode);
        sub_475E30(dwErrCode);
        LoadStringW(hInstance, 0x1F6Eu, Buffer, 32);
        *v4 = (unsigned int)SendMessageW(*(HWND *)(dwErrCode + 500), 0x43Au, 0, 0) >> 16;
        *(v4 - 5) = (unsigned int)Buffer;
        v7 = *(_DWORD *)(dwErrCode + 500);
        goto LABEL_18;
      case 2u:
        sub_475D00(dwErrCode);
        v8 = (unsigned int)SendMessageW(*(HWND *)(dwErrCode + 504), 0x43Au, 0, 0) >> 16;
        *v4 = v8;
        v4[5] = v8;
        v4[4] = v8;
        SendMessageW(*(HWND *)(dwErrCode + 504), 0x453u, 0, (LPARAM)lParam);
        v9 = lParam[0];
        if ( !v4[1] )
          v4[1] = lParam[0];
        v4[7] = v9;
        *(v4 - 2) = *(_DWORD *)(dwErrCode + 504);
        break;
      case 3u:
        sub_476010(dwErrCode);
        v10 = (unsigned int)SendMessageW(*(HWND *)(dwErrCode + 508), 0x43Au, 0, 0) >> 16;
        *v4 = v10;
        v4[5] = v10;
        v4[4] = v10;
        SendMessageW(*(HWND *)(dwErrCode + 508), 0x453u, 0, (LPARAM)lParam);
        v11 = lParam[0];
        if ( !v4[1] )
          v4[1] = lParam[0];
        v4[7] = v11;
        *(v4 - 2) = *(_DWORD *)(dwErrCode + 508);
        break;
      case 4u:
        sub_4A8BD0(dwErrCode);
        v12 = (unsigned int)SendMessageW(*(HWND *)(dwErrCode + 512), 0x43Au, 0, 0) >> 16;
        *v4 = v12;
        v4[5] = v12;
        v4[4] = v12;
        SendMessageW(*(HWND *)(dwErrCode + 512), 0x453u, 0, (LPARAM)lParam);
        v13 = lParam[0];
        if ( !v4[1] )
          v4[1] = lParam[0];
        v4[7] = v13;
        v7 = *(_DWORD *)(dwErrCode + 512);
LABEL_18:
        *(v4 - 2) = v7;
        break;
      default:
        break;
    }
    *(v4 - 10) = 80;
    result = SendMessageW(*(HWND *)(dwErrCode + 60), 0x40Au, 0xFFFFFFFF, (LPARAM)(v4 - 10));
    v4 += 20;
    --v15;
  }
  while ( v15 );
  return result;
}

//----- (00476620) --------------------------------------------------------
HWND __usercall sub_476620@<eax>(DWORD a1@<edi>)
{
  DWORD v1; // ebx
  HWND v2; // esi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  HWND v5; // eax
  void *v6; // eax
  DWORD_PTR v7; // eax
  HWND result; // eax
  WCHAR Buffer[32]; // [esp+10h] [ebp-50h] BYREF
  int v10; // [esp+5Ch] [ebp-4h]

  v1 = 1174405120;
  if ( *(_DWORD *)(a1 + 59288) )
    v1 = 1442840576;
  v2 = *(HWND *)(a1 + 52);
  sub_41BD90();
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"Holder", L"Folders", v1, 0, 0, 0, 0, v2, 0, ModuleHandleW, 0);
  *(_DWORD *)(a1 + 80) = Window;
  sub_409750((int)Window, (int)sub_478900, 0, a1);
  v5 = sub_465600(*(HWND *)(a1 + 80));
  *(_DWORD *)(a1 + 76) = v5;
  SetWindowTheme(v5, L"Explorer", 0);
  SetWindowLongW(*(HWND *)(a1 + 76), -20, 512);
  v6 = operator new(0x6C8u);
  v10 = 0;
  if ( v6 )
    v7 = sub_41C0F0(
           *(HWND *)(a1 + 76),
           (DWORD_PTR)v6,
           *(_DWORD *)(a1 + 52),
           *(_DWORD *)(a1 + 1324),
           *(_DWORD *)(a1 + 3424));
  else
    v7 = 0;
  *(_DWORD *)(a1 + 1328) = v7;
  sub_409750(*(_DWORD *)(a1 + 76), (int)sub_4777C0, 1, a1);
  LoadStringW(hInstance, 0x1F70u, Buffer, 32);
  result = sub_475BD0(*(HWND *)(a1 + 80), 6000, (int)Buffer);
  *(_DWORD *)(a1 + 492) = result;
  return result;
}

//----- (00476770) --------------------------------------------------------
int __thiscall sub_476770(HICON *this)
{
  DestroyIcon(this[14]);
  return 0;
}

//----- (00476780) --------------------------------------------------------
int __thiscall sub_476780(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (004767A0) --------------------------------------------------------
int __thiscall sub_4767A0(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  HWND DlgItem; // eax
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 60);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1098);
  GetWindowTextW(DlgItem, (LPWSTR)(*(_DWORD *)(this + 60) + 540), 256);
  result = *(_DWORD *)(this + 60);
  *(_DWORD *)(result + 4) = 1;
  return result;
}

//----- (00476840) --------------------------------------------------------
LRESULT __userpurge sub_476840@<eax>(int a1@<edi>, const WCHAR *a2)
{
  int (__thiscall ***v2)(_DWORD); // ecx
  int (__thiscall **v3)(_DWORD); // edx
  HWND v4; // ebx
  LRESULT result; // eax
  signed int v6; // esi
  int v7; // eax
  int v8; // edx
  LPARAM lParam[13]; // [esp+8h] [ebp-248h] BYREF
  LPCWSTR lpString; // [esp+3Ch] [ebp-214h]
  LRESULT i; // [esp+40h] [ebp-210h]
  int v12[130]; // [esp+44h] [ebp-20Ch] BYREF

  v2 = *(int (__thiscall ****)(_DWORD))(a1 + 48);
  v3 = *v2;
  lpString = a2;
  v4 = (HWND)(*v3)(v2);
  result = SendMessageW(v4, 0x1004u, 0, 0);
  v6 = 0;
  for ( i = result; v6 < i; ++v6 )
  {
    v7 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
    (*(void (__thiscall **)(int, signed int, int *))(*(_DWORD *)v7 + 44))(v7, v6, v12);
    result = sub_469A50(lpString, (int)v12, 0);
    if ( result == 1 )
    {
      v8 = *(_DWORD *)(a1 + 52) != 0 ? 2 : 0;
      lParam[4] = 2;
      lParam[3] = v8;
      result = SendMessageW(v4, 0x102Bu, v6, (LPARAM)lParam);
    }
  }
  return result;
}

//----- (00476910) --------------------------------------------------------
char **__stdcall sub_476910(_DWORD *a1, char **a2)
{
  char *v2; // ebx
  char **v3; // eax
  char *v4; // ecx
  char *v5; // ebx
  char **v6; // eax
  char *v7; // ecx
  char *v8; // ebx
  char **v9; // eax
  char *v10; // ecx
  char *v11; // ebx
  char **result; // eax
  char *v13; // ecx
  char *v14; // [esp-8h] [ebp-20h]
  char *v15; // [esp-8h] [ebp-20h]
  char *v16; // [esp-8h] [ebp-20h]
  char *v17; // [esp-8h] [ebp-20h]
  int v18; // [esp-4h] [ebp-1Ch]
  int v19; // [esp-4h] [ebp-1Ch]
  int v20; // [esp-4h] [ebp-1Ch]
  int v21; // [esp-4h] [ebp-1Ch]
  int v22; // [esp+Ch] [ebp-Ch] BYREF
  int v23; // [esp+10h] [ebp-8h]
  int v24; // [esp+14h] [ebp-4h]

  *a1 = 1;
  v2 = *a2;
  v18 = *((_DWORD *)*a2 + 1);
  v14 = *a2;
  v22 = 1098;
  v23 = 1;
  v24 = 1;
  v3 = sub_41EEB0((char **)&v22, v14, v18);
  v4 = a2[1];
  if ( v4 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v4 + 1;
  *((_DWORD *)v2 + 1) = v3;
  *(_DWORD *)v3[1] = v3;
  v5 = *a2;
  v19 = *((_DWORD *)*a2 + 1);
  v15 = *a2;
  v22 = 1;
  v23 = 0;
  v24 = 0;
  v6 = sub_41EEB0((char **)&v22, v15, v19);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v5 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v8 = *a2;
  v20 = *((_DWORD *)*a2 + 1);
  v16 = *a2;
  v22 = 2;
  v23 = 0;
  v24 = 0;
  v9 = sub_41EEB0((char **)&v22, v16, v20);
  v10 = a2[1];
  if ( v10 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v10 + 1;
  *((_DWORD *)v8 + 1) = v9;
  *(_DWORD *)v9[1] = v9;
  v11 = *a2;
  v21 = *((_DWORD *)*a2 + 1);
  v17 = *a2;
  v22 = 1304;
  v23 = 0;
  v24 = 0;
  result = sub_41EEB0((char **)&v22, v17, v21);
  v13 = a2[1];
  if ( v13 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v13 + 1;
  *((_DWORD *)v11 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (00476A70) --------------------------------------------------------
int *sub_476A70()
{
  _DWORD *v0; // eax
  _WORD *v1; // eax
  int v2; // edx
  __int16 v3; // cx
  int pExceptionObject[4]; // [esp+8h] [ebp-20h] BYREF
  char *v6[4]; // [esp+18h] [ebp-10h] BYREF

  pExceptionObject[3] = (int)&dword_4F1728;
  sub_4653E0((int)&dword_4F1728, (int)L"WildcardSelect");
  v6[3] = 0;
  dword_4F1728 = (int)&CWildcardSelectDialogPersistentSettings::`vftable';
  dword_4F1B48 = 0;
  v0 = operator new(0x24u);
  if ( !v0 )
  {
    v6[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v6);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4F1B44 = v0;
  *v0 = v0;
  *((_DWORD *)dword_4F1B44 + 1) = dword_4F1B44;
  v1 = &unk_4F1944;
  v2 = 256;
  while ( v2 != -2147483390 )
  {
    v3 = *(_WORD *)((char *)v1 + &unk_4C629C - &unk_4F1944);
    if ( !v3 )
      break;
    *v1++ = v3;
    if ( !--v2 )
    {
      --v1;
      break;
    }
  }
  *v1 = 0;
  return &dword_4F1728;
}
// 476B15: conditional instruction was optimized away because edx.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C6278: using guessed type wchar_t aWildcardselect_0[15];
// 4CC310: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 4F1728: using guessed type int dword_4F1728;
// 4F1B48: using guessed type int dword_4F1B48;

//----- (00476B60) --------------------------------------------------------
int *sub_476B60()
{
  if ( (dword_4F221C & 1) == 0 )
  {
    dword_4F221C |= 1u;
    sub_476A70();
    atexit(sub_4BCD50);
  }
  return &dword_4F1728;
}
// 4F1728: using guessed type int dword_4F1728;
// 4F221C: using guessed type int dword_4F221C;

//----- (00476BD0) --------------------------------------------------------
int __fastcall sub_476BD0(int a1, int a2, int a3, int a4)
{
  int result; // eax

  *(_DWORD *)(a3 + 8) = hInstance;
  *(_DWORD *)(a3 + 16) = a1;
  *(_DWORD *)(a3 + 12) = 176;
  *(_BYTE *)(a3 + 28) = 1;
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)a3 = &CWildcardSelectDialog::`vftable';
  *(_DWORD *)(a3 + 52) = a2;
  *(_DWORD *)(a3 + 48) = a4;
  if ( (dword_4F221C & 1) == 0 )
  {
    dword_4F221C |= 1u;
    sub_476A70();
    atexit(sub_4BCD50);
  }
  result = a3;
  *(_DWORD *)(a3 + 60) = &dword_4F1728;
  return result;
}
// 4CC2D8: using guessed type void *CWildcardSelectDialog::`vftable';
// 4F1728: using guessed type int dword_4F1728;
// 4F221C: using guessed type int dword_4F221C;

//----- (00476C70) --------------------------------------------------------
HRESULT __thiscall sub_476C70(int this, int a2, int a3)
{
  sub_464E30((int)L"Pattern", a3, a2, (_DWORD **)(this + 1052));
  return sub_464A60(a2, a3, (OLECHAR *)L"CurrentText", (OLECHAR *)(this + 540));
}
// 4C62F0: using guessed type wchar_t aPattern[8];

//----- (00476CB0) --------------------------------------------------------
LSTATUS __thiscall sub_476CB0(const WCHAR *this, HKEY hKey)
{
  const WCHAR *v2; // esi
  int v3; // eax

  v2 = this;
  sub_464130(hKey, (_DWORD **)this + 263);
  v2 += 270;
  v3 = lstrlenW(v2);
  return RegSetValueExW(hKey, L"CurrentText", 0, 1u, (const BYTE *)v2, 2 * v3);
}

//----- (00476D00) --------------------------------------------------------
int __thiscall sub_476D00(int this)
{
  HMODULE ModuleHandleW; // eax
  HICON IconW; // eax
  HWND DlgItem; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  LPARAM *v7; // eax
  HWND v8; // edi
  _DWORD *v9; // esi
  HWND Parent; // eax
  _DWORD *i; // [esp+Ch] [ebp-A4h]
  LPARAM lParam[5]; // [esp+10h] [ebp-A0h] BYREF
  unsigned int v14; // [esp+24h] [ebp-8Ch]
  WCHAR Buffer[64]; // [esp+2Ch] [ebp-84h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *(_DWORD *)(this + 56) = IconW;
  SetClassLongW(*(HWND *)(this + 4), -34, (LONG)IconW);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1098);
  v5 = *(_DWORD **)(*(_DWORD *)(this + 60) + 1052);
  v6 = (_DWORD *)*v5;
  for ( i = v5; v6 != i; v6 = (_DWORD *)*v6 )
  {
    v14 = 7;
    lParam[4] = 0;
    LOWORD(lParam[0]) = 0;
    sub_4090E0((int)lParam, v6 + 2, 0, 0xFFFFFFFF);
    v7 = (LPARAM *)lParam[0];
    if ( v14 < 8 )
      v7 = lParam;
    SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFF, (LPARAM)v7);
    if ( v14 >= 8 )
      operator delete((void *)lParam[0]);
  }
  SetWindowTextW(DlgItem, (LPCWSTR)(*(_DWORD *)(this + 60) + 540));
  if ( !*(_DWORD *)(this + 52) )
  {
    LoadStringW(*(HINSTANCE *)(this + 8), 0x847u, Buffer, 64);
    SetWindowTextW(*(HWND *)(this + 4), Buffer);
  }
  SetFocus(DlgItem);
  v8 = *(HWND *)(this + 4);
  v9 = *(_DWORD **)(this + 60);
  if ( v9[1] )
  {
    SetWindowPos(v8, 0, v9[2], v9[3], v9[4], v9[5], 4u);
  }
  else
  {
    Parent = GetParent(v8);
    sub_4697F0(v8, Parent);
  }
  return 0;
}

//----- (00476E80) --------------------------------------------------------
void __thiscall sub_476E80(_DWORD *this, LPCWSTR lpString1, void *Src)
{
  _WORD *v4; // eax
  int v5; // edx
  __int16 v6; // cx
  int v7; // esi
  char *v8; // eax
  int v9; // ecx
  void *v10[5]; // [esp+10h] [ebp-2Ch] BYREF
  unsigned int v11; // [esp+24h] [ebp-18h]
  int v12; // [esp+38h] [ebp-4h]

  if ( lstrcmpiW(lpString1, L"CurrentText") )
  {
    if ( sub_469A50(L"Pattern*", (int)lpString1, 1) )
    {
      LOWORD(v10[0]) = 0;
      v11 = 7;
      v10[4] = 0;
      sub_4094F0(v10, (int)Src + 2, Src, wcslen((const unsigned __int16 *)Src));
      v12 = 0;
      v7 = this[263];
      v8 = sub_40A200((char *)v7, *(_DWORD *)(v7 + 4), (int)v10);
      v9 = this[264];
      if ( v9 == 153391688 )
        std::_Xlength_error("list<T> too long");
      this[264] = v9 + 1;
      *(_DWORD *)(v7 + 4) = v8;
      **((_DWORD **)v8 + 1) = v8;
      if ( v11 >= 8 )
        operator delete(v10[0]);
    }
  }
  else
  {
    v4 = this + 135;
    v5 = 256;
    while ( v5 != -2147483390 )
    {
      v6 = *(_WORD *)((char *)v4 + (_BYTE *)Src - (_BYTE *)(this + 135));
      if ( !v6 )
        break;
      *v4++ = v6;
      if ( !--v5 )
      {
        *(v4 - 1) = 0;
        return;
      }
    }
    *v4 = 0;
  }
}
// 476EF9: conditional instruction was optimized away because edx.4!=0

//----- (00476FD0) --------------------------------------------------------
int __thiscall sub_476FD0(BYTE *this, HKEY hKey)
{
  HKEY v2; // ebx
  BYTE *v4; // esi
  int result; // eax
  DWORD Type; // [esp+Ch] [ebp-4h] BYREF

  v2 = hKey;
  sub_464270((int)L"Pattern", (int)(this + 1052), hKey);
  v4 = this + 540;
  hKey = (HKEY)256;
  RegQueryValueExW(v2, L"CurrentText", 0, &Type, v4, (LPDWORD)&hKey);
  result = (int)hKey;
  if ( hKey && Type == 1 )
  {
    if ( *(_WORD *)&v4[2 * (_DWORD)hKey - 2] )
    {
      if ( (unsigned int)hKey >= 0x100 )
        result = 256;
      *(_WORD *)&v4[2 * result] = 0;
    }
  }
  else
  {
    result = 0;
    *(_WORD *)v4 = 0;
  }
  return result;
}
// 4C62C8: using guessed type wchar_t aPattern_2[8];

//----- (00477060) --------------------------------------------------------
BOOL __thiscall sub_477060(int this)
{
  int v2; // eax
  int v3; // ecx
  const WCHAR *v4; // eax
  int v5; // esi
  char **v6; // ecx
  char *v7; // ebx
  char *v8; // eax
  int v9; // ecx
  void *v11[5]; // [esp+10h] [ebp-42Ch] BYREF
  unsigned int v12; // [esp+24h] [ebp-418h]
  WCHAR String; // [esp+2Ch] [ebp-410h] BYREF
  _BYTE v14[1038]; // [esp+2Eh] [ebp-40Eh] BYREF

  GetDlgItemTextW(*(HWND *)(this + 4), 1098, &String, 512);
  if ( lstrcmpW(&String, &word_4C6298) )
  {
    sub_476840(this, &String);
    v2 = *(_DWORD *)(this + 60);
    v3 = **(_DWORD **)(v2 + 1052);
    if ( v3 == *(_DWORD *)(v2 + 1052) )
      goto LABEL_6;
    v4 = (const WCHAR *)(v3 + 8);
    if ( *(_DWORD *)(v3 + 28) >= 8u )
      v4 = *(const WCHAR **)v4;
    if ( lstrcmpW(v4, &String) )
    {
LABEL_6:
      LOWORD(v11[0]) = 0;
      v12 = 7;
      v11[4] = 0;
      sub_4094F0(v11, (int)v14, &String, wcslen(&String));
      *(_DWORD *)&v14[1034] = 0;
      v5 = *(_DWORD *)(this + 60);
      v6 = *(char ***)(v5 + 1052);
      v7 = *v6;
      v8 = sub_40A200(*v6, *((_DWORD *)*v6 + 1), (int)v11);
      v9 = *(_DWORD *)(v5 + 1056);
      if ( v9 == 153391688 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(v5 + 1056) = v9 + 1;
      *((_DWORD *)v7 + 1) = v8;
      **((_DWORD **)v8 + 1) = v8;
      if ( v12 >= 8 )
        operator delete(v11[0]);
    }
  }
  return EndDialog(*(HWND *)(this + 4), 1);
}

//----- (004771E0) --------------------------------------------------------
int __thiscall sub_4771E0(HWND *this, __int16 a2, int a3)
{
  if ( a2 == 1 )
  {
    sub_477060((int)this);
  }
  else if ( a2 == 2 )
  {
    EndDialog(this[1], 0);
    return 0;
  }
  return 0;
}

//----- (00477230) --------------------------------------------------------
int __usercall sub_477230@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v3; // esi
  LPARAM v4; // ecx
  const ITEMIDLIST *v5; // eax
  HWND v7; // [esp-10h] [ebp-58h]
  LPARAM lParam[14]; // [esp+10h] [ebp-38h] BYREF

  v3 = *(_DWORD *)(a2 + 1328);
  v4 = *(_DWORD *)(a1 + 16);
  v7 = *(HWND *)(v3 + 12);
  lParam[0] = 20;
  lParam[1] = v4;
  SendMessageW(v7, 0x113Eu, 0, (LPARAM)lParam);
  v5 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v3 + 588) + 8 * lParam[9]));
  sub_466630(v5, (WCHAR *)(a2 + 5052), 0x8000);
  return 0;
}

//----- (004772A0) --------------------------------------------------------
UINT_PTR __usercall sub_4772A0@<eax>(UINT_PTR result@<eax>, int a2@<edx>)
{
  bool v2; // zf

  if ( *(_DWORD *)(result + 5592) || *(_DWORD *)(result + 5588) || *(_DWORD *)(*(_DWORD *)(result + 1328) + 612) )
  {
    *(_DWORD *)(result + 5592) = 0;
  }
  else
  {
    v2 = *(_DWORD *)(result + 59352) == 0;
    dword_4EF3D8 = *(_DWORD *)(a2 + 60);
    if ( v2 )
      return SetTimer(*(HWND *)(result + 80), 0, 0, 0);
    else
      return SetTimer(*(HWND *)(result + 80), 0, 0x1F4u, 0);
  }
  return result;
}

//----- (00477310) --------------------------------------------------------
LRESULT __usercall sub_477310@<eax>(int a1@<esi>)
{
  LPARAM v1; // eax

  SetFocus(*(HWND *)(a1 + 76));
  v1 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0);
  return SendMessageW(*(HWND *)(a1 + 76), 0x1141u, 0, v1);
}

//----- (00477350) --------------------------------------------------------
void __usercall sub_477350(int a1@<esi>)
{
  LRESULT v1; // eax
  int v2; // edi
  ITEMIDLIST *v3; // edi
  HWND v4; // [esp-10h] [ebp-50h]
  LPARAM lParam[14]; // [esp+8h] [ebp-38h] BYREF

  v1 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0);
  v2 = *(_DWORD *)(a1 + 1328);
  v4 = *(HWND *)(v2 + 12);
  lParam[0] = 20;
  lParam[1] = v1;
  SendMessageW(v4, 0x113Eu, 0, (LPARAM)lParam);
  v3 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v2 + 588) + 8 * lParam[9]));
  sub_47DC80(0, L"properties", a1, v3, 0, 0);
  CoTaskMemFree(v3);
}
// 4C6D30: using guessed type wchar_t aProperties_0[11];

//----- (004773D0) --------------------------------------------------------
void __userpurge sub_4773D0(int a1@<esi>, int a2)
{
  LPARAM v2; // ebx
  LPARAM v3; // eax
  ITEMIDLIST *v4; // edi
  int v5; // eax
  HWND v6; // [esp-10h] [ebp-58h]
  int v7; // [esp+8h] [ebp-40h]
  LPARAM lParam[14]; // [esp+10h] [ebp-38h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0);
  v3 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 3u, v2);
  SendMessageW(*(HWND *)(a1 + 76), 0x110Bu, 9u, v3);
  if ( v2 )
  {
    v6 = *(HWND *)(*(_DWORD *)(a1 + 1328) + 12);
    v7 = *(_DWORD *)(a1 + 1328);
    lParam[0] = 20;
    lParam[1] = v2;
    SendMessageW(v6, 0x113Eu, 0, (LPARAM)lParam);
    v4 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v7 + 588) + 8 * lParam[9]));
    v5 = 0x10000000;
    if ( !a2 )
      v5 = 0;
    sub_47DC80(0, L"delete", a1, v4, 0, v5);
    CoTaskMemFree(v4);
  }
}
// 4C6344: using guessed type wchar_t aDelete_0[7];

//----- (00477490) --------------------------------------------------------
void __thiscall sub_477490(_DWORD *this)
{
  HWND v2; // eax
  LRESULT v3; // edi
  int *v4; // eax
  int *v5; // ebx
  int v6; // esi
  HWND v7; // edx
  ITEMIDLIST *v8; // edi
  HRESULT v9; // esi
  HANDLE FirstFileW; // eax
  int *v11; // eax
  int *v12; // esi
  char **v13[2]; // [esp-Ch] [ebp-570h] BYREF
  int v14; // [esp-4h] [ebp-568h]
  _DWORD *v15; // [esp+10h] [ebp-554h]
  char *v16; // [esp+14h] [ebp-550h] BYREF
  int *v17[4]; // [esp+18h] [ebp-54Ch] BYREF
  int pExceptionObject[3]; // [esp+28h] [ebp-53Ch] BYREF
  LPARAM lParam[14]; // [esp+34h] [ebp-530h] BYREF
  LPARAM dwInitParam[3]; // [esp+6Ch] [ebp-4F8h] BYREF
  unsigned __int16 v21; // [esp+78h] [ebp-4ECh]
  HWND hWndParent; // [esp+7Ch] [ebp-4E8h]
  int v23; // [esp+84h] [ebp-4E0h]
  WCHAR FileName[260]; // [esp+F4h] [ebp-470h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+2FCh] [ebp-268h] BYREF
  int v26; // [esp+560h] [ebp-4h]

  v14 = 0;
  v2 = (HWND)this[19];
  v15 = this;
  v3 = SendMessageW(v2, 0x110Au, 9u, 0);
  if ( v3 )
  {
    v17[1] = 0;
    v4 = (int *)operator new(0x460u);
    if ( !v4 )
    {
      v16 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v16);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v5 = v4;
    *v4 = (int)v4;
    v17[0] = v4;
    v4[1] = (int)v4;
    v26 = 0;
    v6 = this[332];
    v7 = *(HWND *)(v6 + 12);
    lParam[0] = 20;
    lParam[1] = v3;
    SendMessageW(v7, 0x113Eu, 0, (LPARAM)lParam);
    v8 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v6 + 588) + 8 * lParam[9]));
    v9 = sub_466630(v8, FileName, 0x8000);
    CoTaskMemFree(v8);
    if ( !v9 )
    {
      FirstFileW = FindFirstFileW(FileName, &FindFileData);
      if ( FirstFileW != (HANDLE)-1 )
      {
        FindClose(FirstFileW);
        sub_40AE70((int)FileName, (int)v17);
        v17[3] = (int *)v13;
        sub_40ADB0(v13, v17);
        sub_47F4C0((void *)v15[13], (int)dwInitParam, v13[0], (int)v13[1], v14);
        if ( !v23 )
          DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v21, hWndParent, DialogFunc, (LPARAM)dwInitParam);
        sub_47E860((int)dwInitParam);
        v5 = v17[0];
      }
    }
    v11 = (int *)*v5;
    *v5 = (int)v5;
    v5[1] = (int)v5;
    if ( v11 != v5 )
    {
      do
      {
        v12 = (int *)*v11;
        operator delete(v11);
        v11 = v12;
      }
      while ( v12 != v5 );
    }
    operator delete(v5);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00477690) --------------------------------------------------------
int __userpurge sub_477690@<eax>(DWORD a1@<ebx>, _DWORD *a2@<edi>, int a3, unsigned int a4, int a5)
{
  int v5; // esi
  LPITEMIDLIST v7; // esi
  HWND v8; // [esp-10h] [ebp-28h]
  HWND v9; // [esp-10h] [ebp-28h]
  LPARAM lParam; // [esp+8h] [ebp-10h] BYREF
  DWORD v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  LPARAM v13; // [esp+14h] [ebp-4h]

  v5 = a4;
  if ( a4 <= 0x208 )
  {
    if ( a4 == 520 )
    {
      lParam = (unsigned __int16)a1;
      v9 = (HWND)a2[19];
      v11 = HIWORD(a1);
      SendMessageW(v9, 0x1111u, 0, (LPARAM)&lParam);
      if ( v12 == 1 || !v13 || v13 != a2[15328] )
        return sub_401C60(a3, v5, a5, a1);
      v7 = sub_41D9D0(v13, a2[332]);
      (*(void (__thiscall **)(_DWORD *, LPITEMIDLIST, _DWORD, int, _DWORD, _DWORD))(a2[7] + 40))(a2 + 7, v7, 0, 1, 0, 0);
      CoTaskMemFree(v7);
    }
    else
    {
      if ( a4 != 7 )
      {
        if ( a4 == 519 )
        {
          lParam = (unsigned __int16)a1;
          v8 = (HWND)a2[19];
          v11 = HIWORD(a1);
          SendMessageW(v8, 0x1111u, 0, (LPARAM)&lParam);
          if ( v12 == 1 || !v13 )
            a2[15328] = 0;
          else
            a2[15328] = v13;
        }
        return sub_401C60(a3, v5, a5, a1);
      }
      sub_49B450((int)a2);
    }
    v5 = a4;
    return sub_401C60(a3, v5, a5, a1);
  }
  if ( a4 != 522 || !sub_479400(a1, (int)a2, a5, 1) )
    return sub_401C60(a3, v5, a5, a1);
  return 0;
}

//----- (004777C0) --------------------------------------------------------
int __stdcall sub_4777C0(int a1, unsigned int a2, int a3, DWORD a4, int a5, _DWORD *a6)
{
  return sub_477690(a4, a6, a1, a2, a3);
}

//----- (004777F0) --------------------------------------------------------
LRESULT __thiscall sub_4777F0(int this)
{
  DWORD v1; // esi
  LRESULT result; // eax
  _DWORD *v4; // eax
  int v5; // edi
  ITEMIDLIST *v6; // edi
  int v7; // eax
  LPDATAOBJECT v8; // edx
  bool v9; // zf
  int v10; // ebx
  int *v11; // ecx
  HWND v12; // [esp-10h] [ebp-278h]
  LPDATAOBJECT ppDataObj; // [esp+Ch] [ebp-25Ch] BYREF
  int v14[2]; // [esp+10h] [ebp-258h] BYREF
  LPARAM lParam[14]; // [esp+18h] [ebp-250h] BYREF
  WCHAR String[266]; // [esp+50h] [ebp-218h] BYREF

  v1 = 0;
  result = SendMessageW(*(HWND *)(this + 76), 0x110Au, 9u, 0);
  v14[0] = result;
  if ( result )
  {
    ppDataObj = 0;
    result = OleGetClipboard(&ppDataObj);
    if ( !result )
    {
      v4 = operator new(0x30u);
      if ( v4 )
      {
        v4[1] = 1;
        *v4 = &CDropHandler::`vftable';
        v1 = (DWORD)v4;
      }
      v5 = *(_DWORD *)(this + 1328);
      v12 = *(HWND *)(v5 + 12);
      lParam[0] = 20;
      lParam[1] = v14[0];
      SendMessageW(v12, 0x113Eu, 0, (LPARAM)lParam);
      v6 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v5 + 588) + 8 * lParam[9]));
      sub_466630(v6, String, 0x8000);
      v7 = lstrlenW(String);
      v8 = ppDataObj;
      String[v7 + 1] = 0;
      v9 = *(_DWORD *)(this + 59412) == 0;
      v10 = *(_DWORD *)(this + 76);
      *(_DWORD *)(v1 + 8) = v8;
      *(_DWORD *)(v1 + 12) = 0;
      v14[0] = 0;
      v14[1] = 0;
      v11 = *(int **)(v1 + 8);
      *(_DWORD *)(v1 + 44) = v9;
      *(_DWORD *)(v1 + 28) = 1;
      *(_DWORD *)(v1 + 32) = v10;
      *(_DWORD *)(v1 + 40) = String;
      sub_461780(v11, v1, v14);
      CoTaskMemFree(v6);
      if ( !InterlockedDecrement((volatile LONG *)(v1 + 4)) )
        (**(void (__thiscall ***)(DWORD, int))v1)(v1, 1);
      return ppDataObj->lpVtbl->Release(ppDataObj);
    }
  }
  return result;
}
// 4CC480: using guessed type void *CDropHandler::`vftable';

//----- (00477950) --------------------------------------------------------
int __thiscall sub_477950(int this, int a2)
{
  WCHAR *p_pszPath; // eax
  int v4; // edx
  WCHAR v5; // cx
  _WORD *v6; // eax
  int v8; // edx
  void **v9; // eax
  int v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // edi
  char *v13; // eax
  int pExceptionObject[3]; // [esp+14h] [ebp-290h] BYREF
  int v15; // [esp+20h] [ebp-284h]
  void *v16; // [esp+24h] [ebp-280h] BYREF
  int v17; // [esp+28h] [ebp-27Ch]
  char *v18; // [esp+30h] [ebp-274h] BYREF
  int v19[7]; // [esp+34h] [ebp-270h] BYREF
  void *v20[7]; // [esp+50h] [ebp-254h] BYREF
  void *v21[4]; // [esp+6Ch] [ebp-238h] BYREF
  int v22; // [esp+7Ch] [ebp-228h]
  unsigned int v23; // [esp+80h] [ebp-224h]
  WCHAR pszPath; // [esp+88h] [ebp-21Ch] BYREF
  __int16 v25; // [esp+8Ah] [ebp-21Ah] BYREF
  int v26; // [esp+2A0h] [ebp-4h]

  v15 = a2;
  v18 = (char *)this;
  if ( !*(_DWORD *)(this + 28) )
    return 0;
  p_pszPath = &pszPath;
  v4 = 260;
  while ( v4 != -2147483386 )
  {
    v5 = *(WCHAR *)((char *)p_pszPath + a2 + 5052 - (_DWORD)&pszPath);
    if ( !v5 )
      break;
    *p_pszPath++ = v5;
    if ( !--v4 )
    {
      --p_pszPath;
      break;
    }
  }
  *p_pszPath = 0;
  PathRemoveFileSpecW(&pszPath);
  if ( !PathAppendW(&pszPath, *((LPCWSTR *)v18 + 7)) )
    return 0;
  v19[5] = 7;
  v19[4] = 0;
  LOWORD(v19[0]) = 0;
  v20[5] = (void *)7;
  v20[4] = 0;
  LOWORD(v20[0]) = 0;
  v6 = (_WORD *)(a2 + 5052);
  v26 = 0;
  while ( *v6++ )
    ;
  sub_4094F0(v19, a2 + 5054, (void *)(a2 + 5052), ((int)v6 - a2 - 5054) >> 1);
  sub_4094F0(v20, (int)&v25, &pszPath, wcslen(&pszPath));
  LOWORD(v21[0]) = 0;
  v23 = 7;
  v22 = 0;
  sub_4094F0(v21, v8, L" ", 1);
  LOBYTE(v26) = 1;
  v9 = (void **)v21[0];
  if ( v23 < 8 )
    v9 = v21;
  v10 = sub_418FD0(v22, (char *)v20, v9);
  sub_409050(v20, v10 + 1, 0xFFFFFFFF);
  LOBYTE(v26) = 0;
  if ( v23 >= 8 )
    operator delete(v21[0]);
  v17 = 0;
  v11 = operator new(0x40u);
  v12 = v11;
  if ( !v11 )
  {
    v18 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v18);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v11 = v11;
  v16 = v11;
  v11[1] = v11;
  LOBYTE(v26) = 2;
  v13 = sub_40B0E0((char *)v11, (int)v11, (int)v19);
  v12[1] = v13;
  **((_DWORD **)v13 + 1) = v13;
  v17 = 1;
  sub_463A50((char ***)&v16, v15 + 59552);
  sub_40B060((int)&v16);
  operator delete(v16);
  sub_409920((int)v19);
  return 1;
}
// 4779F0: conditional instruction was optimized away because edx.4!=0
// 477AC9: variable 'v8' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C6354: using guessed type wchar_t asc_4C6354[2];

//----- (00477BF0) --------------------------------------------------------
void __thiscall sub_477BF0(_DWORD *this, int a2)
{
  HWND v3; // eax
  LRESULT v4; // eax
  int v5; // esi
  HWND v6; // edx
  LPITEMIDLIST v7; // edi
  int *v8; // esi
  char *v9; // eax
  char **v10; // ecx
  HRESULT v11; // esi
  LPARAM v12; // eax
  int v13; // ecx
  HWND v14; // eax
  UINT v15; // [esp-Ch] [ebp-2E0h] BYREF
  WPARAM v16; // [esp-8h] [ebp-2DCh]
  LPARAM *v17; // [esp-4h] [ebp-2D8h]
  LPDATAOBJECT v18; // [esp+10h] [ebp-2C4h] BYREF
  char *v19; // [esp+14h] [ebp-2C0h] BYREF
  void *v20; // [esp+18h] [ebp-2BCh] BYREF
  int v21; // [esp+1Ch] [ebp-2B8h]
  LPARAM v22; // [esp+24h] [ebp-2B0h]
  LPVOID pv; // [esp+28h] [ebp-2ACh]
  int pExceptionObject[3]; // [esp+2Ch] [ebp-2A8h] BYREF
  LPARAM v25[10]; // [esp+38h] [ebp-29Ch] BYREF
  LPARAM lParam[14]; // [esp+60h] [ebp-274h] BYREF
  void *v27[4]; // [esp+98h] [ebp-23Ch] BYREF
  int v28; // [esp+A8h] [ebp-22Ch]
  unsigned int v29; // [esp+ACh] [ebp-228h]
  __int16 Src[262]; // [esp+B4h] [ebp-220h] BYREF
  int v31; // [esp+2D0h] [ebp-4h]

  v17 = 0;
  v16 = 9;
  v3 = (HWND)this[19];
  v18 = 0;
  v4 = SendMessageW(v3, 0x110Au, 9u, 0);
  v22 = v4;
  if ( !v4 )
    return;
  v5 = this[332];
  v6 = *(HWND *)(v5 + 12);
  lParam[0] = 20;
  lParam[1] = v4;
  SendMessageW(v6, 0x113Eu, 0, (LPARAM)lParam);
  v7 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v5 + 588) + 8 * lParam[9]));
  pv = v7;
  v21 = 0;
  v8 = (int *)operator new(0x24u);
  if ( !v8 )
  {
    v19 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v19);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v8 = (int)v8;
  v20 = v8;
  v8[1] = (int)v8;
  v31 = 0;
  sub_466630(v7, (WCHAR *)Src, 0x8000);
  v29 = 7;
  v28 = 0;
  LOWORD(v27[0]) = 0;
  sub_4094F0(v27, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
  LOBYTE(v31) = 1;
  v9 = sub_40A200((char *)v8, v8[1], (int)v27);
  v8[1] = (int)v9;
  v10 = (char **)*((_DWORD *)v9 + 1);
  v21 = 1;
  *v10 = v9;
  v19 = (char *)&v15;
  if ( a2 )
  {
    sub_40AC30((char ***)&v15, (int **)&v20);
    v11 = sub_4AE6E0(&v18, (void *)v15);
    goto LABEL_7;
  }
  sub_40AC30((char ***)&v15, (int **)&v20);
  v11 = sub_4AE660(&v18, (void *)v15);
  if ( v11 >= 0 )
  {
    v12 = v22;
    v13 = this[1405];
    v17 = v25;
    this[15147] = v22;
    v25[1] = v12;
    v16 = 0;
    v25[2] = 4;
    v25[3] = 4;
    v14 = (HWND)this[19];
    v15 = 4415;
    this[15310] = v13;
    v25[0] = 24;
    SendMessageW(v14, v15, v16, (LPARAM)v17);
LABEL_7:
    if ( v11 >= 0 )
      this[15146] = v18;
  }
  CoTaskMemFree(pv);
  if ( v29 >= 8 )
    operator delete(v27[0]);
  v29 = 7;
  v28 = 0;
  LOWORD(v27[0]) = 0;
  sub_40A140((int)&v20);
  operator delete(v20);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 477BF0: using guessed type WCHAR Src[262];

//----- (00477EB0) --------------------------------------------------------
void __thiscall sub_477EB0(int this)
{
  LRESULT v2; // eax
  int v3; // esi
  ITEMIDLIST *v4; // edi
  DWORD UniversalNameW; // eax
  HWND v6; // [esp-10h] [ebp-288h]
  void *Buffer; // [esp+Ch] [ebp-26Ch] BYREF
  DWORD BufferSize; // [esp+10h] [ebp-268h] BYREF
  LPARAM lParam[14]; // [esp+14h] [ebp-264h] BYREF
  void *v10[5]; // [esp+4Ch] [ebp-22Ch] BYREF
  unsigned int v11; // [esp+60h] [ebp-218h]
  WCHAR LocalPath; // [esp+68h] [ebp-210h] BYREF
  __int16 v13; // [esp+6Ah] [ebp-20Eh] BYREF

  v2 = SendMessageW(*(HWND *)(this + 76), 0x110Au, 9u, 0);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 1328);
    v6 = *(HWND *)(v3 + 12);
    lParam[0] = 20;
    lParam[1] = v2;
    SendMessageW(v6, 0x113Eu, 0, (LPARAM)lParam);
    v4 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v3 + 588) + 8 * lParam[9]));
    sub_466630(v4, &LocalPath, 0x8000);
    BufferSize = 4;
    UniversalNameW = WNetGetUniversalNameW(&LocalPath, 1u, &Buffer, &BufferSize);
    v11 = 7;
    v10[4] = 0;
    LOWORD(v10[0]) = 0;
    if ( UniversalNameW )
      sub_4094F0(v10, (int)&v13, &LocalPath, wcslen(&LocalPath));
    else
      sub_4094F0(v10, (int)Buffer, Buffer, wcslen((const unsigned __int16 *)Buffer));
    sub_467670(v10);
    if ( v11 >= 8 )
      operator delete(v10[0]);
    CoTaskMemFree(v4);
  }
}

//----- (00478000) --------------------------------------------------------
void __thiscall sub_478000(int this)
{
  LRESULT v2; // eax
  int v3; // esi
  ITEMIDLIST *v4; // edi
  HWND v5; // [esp-10h] [ebp-280h]
  LPARAM lParam[14]; // [esp+Ch] [ebp-264h] BYREF
  void *v7[5]; // [esp+44h] [ebp-22Ch] BYREF
  unsigned int v8; // [esp+58h] [ebp-218h]
  __int16 Src[262]; // [esp+60h] [ebp-210h] BYREF

  v2 = SendMessageW(*(HWND *)(this + 76), 0x110Au, 9u, 0);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 1328);
    v5 = *(HWND *)(v3 + 12);
    lParam[0] = 20;
    lParam[1] = v2;
    SendMessageW(v5, 0x113Eu, 0, (LPARAM)lParam);
    v4 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v3 + 588) + 8 * lParam[9]));
    sub_466630(v4, (WCHAR *)Src, 0x8000);
    v8 = 7;
    v7[4] = 0;
    LOWORD(v7[0]) = 0;
    sub_4094F0(v7, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
    sub_467670(v7);
    if ( v8 >= 8 )
      operator delete(v7[0]);
    CoTaskMemFree(v4);
  }
}
// 478000: using guessed type WCHAR Src[262];

//----- (00478110) --------------------------------------------------------
void __stdcall sub_478110(int a1, LPARAM lParam, int a3)
{
  int v3; // esi
  void (__stdcall *v4)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v5; // eax
  LPARAM v6; // eax
  HWND v7; // edx
  int v8; // ebx
  HWND v9; // edx
  const ITEMIDLIST *v10; // ebx
  LRESULT v11; // eax
  int v12; // ebx
  HWND v13; // ecx
  ITEMIDLIST *v14; // ebx
  _DWORD *v15; // edi
  char **v16; // eax
  int v17; // edi
  _DWORD *v18; // eax
  char KeyState; // al
  UINT v20; // [esp-Ch] [ebp-128h] BYREF
  WPARAM v21; // [esp-8h] [ebp-124h]
  int v22; // [esp-4h] [ebp-120h]
  void *ppv; // [esp+10h] [ebp-10Ch] BYREF
  LPCITEMIDLIST ppidlLast; // [esp+14h] [ebp-108h] BYREF
  char *v25; // [esp+18h] [ebp-104h] BYREF
  LPARAM v26; // [esp+1Ch] [ebp-100h]
  int v27; // [esp+20h] [ebp-FCh] BYREF
  const ITEMIDLIST *v28; // [esp+24h] [ebp-F8h]
  char *v29; // [esp+28h] [ebp-F4h] BYREF
  void *v30; // [esp+2Ch] [ebp-F0h] BYREF
  int v31; // [esp+30h] [ebp-ECh]
  int v32[3]; // [esp+38h] [ebp-E4h] BYREF
  void *v33[3]; // [esp+44h] [ebp-D8h] BYREF
  char v34; // [esp+50h] [ebp-CCh]
  int pExceptionObject[3]; // [esp+54h] [ebp-C8h] BYREF
  int v36[3]; // [esp+60h] [ebp-BCh] BYREF
  LPARAM v37[14]; // [esp+6Ch] [ebp-B0h] BYREF
  LPARAM v38[14]; // [esp+A4h] [ebp-78h] BYREF
  DWORD_PTR dwRefData[13]; // [esp+DCh] [ebp-40h] BYREF
  int v40; // [esp+118h] [ebp-4h]

  v3 = a1;
  v4 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
  v22 = 0;
  v21 = 9;
  ppv = 0;
  ppidlLast = 0;
  v5 = *(HWND *)(a1 + 76);
  v20 = 4362;
  *(_DWORD *)(a1 + 5588) = 1;
  v6 = SendMessageW(v5, v20, v21, v22);
  v7 = *(HWND *)(a1 + 76);
  v26 = v6;
  SendMessageW(v7, 0x110Bu, 9u, lParam);
  v8 = *(_DWORD *)(a1 + 1328);
  v9 = *(HWND *)(v8 + 12);
  v38[0] = 20;
  v38[1] = lParam;
  SendMessageW(v9, 0x113Eu, 0, (LPARAM)v38);
  v10 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v8 + 588) + 8 * v38[9]));
  v28 = v10;
  if ( SHBindToParent(v10, &stru_4BD7FC, &ppv, &ppidlLast) >= 0 )
  {
    v11 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 3u, lParam);
    if ( v11 || (v11 = lParam) != 0 )
    {
      v12 = *(_DWORD *)(a1 + 1328);
      v13 = *(HWND *)(v12 + 12);
      v37[1] = v11;
      v37[0] = 20;
      SendMessageW(v13, 0x113Eu, 0, (LPARAM)v37);
      v14 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v12 + 588) + 8 * v37[9]));
      if ( v14 )
      {
        v22 = 12;
        *(_DWORD *)(a1 + 5612) = 0;
        v31 = 0;
        v15 = operator new(v22);
        if ( !v15 )
        {
          v29 = 0;
          std::exception::exception((std::exception *)v36, (const char *const *)&v29);
          v36[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v36, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        *v15 = v15;
        v30 = v15;
        v15[1] = v15;
        v40 = 0;
        v16 = sub_40A550((char *)v15, (int)v15, (int)&ppidlLast);
        v15[1] = v16;
        *(_DWORD *)v16[1] = v16;
        v25 = (char *)&v20;
        v31 = 1;
        sub_40ACF0((char ***)&v20, (int **)&v30);
        sub_4AD000((int)dwRefData, *(_DWORD *)(a1 + 52), v14, (void *)v20, v21, v22);
        LOBYTE(v40) = 1;
        v17 = *(_DWORD *)(a1 + 56);
        v27 = 1;
        v33[1] = 0;
        v18 = operator new(0x24u);
        if ( !v18 )
        {
          v25 = 0;
          std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
          pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v33[0] = v18;
        *v18 = v18;
        *((void **)v33[0] + 1) = v33[0];
        v32[0] = v17;
        v34 = 0;
        v32[1] = 0;
        LOBYTE(v40) = 2;
        KeyState = GetKeyState(16);
        sub_4AD640((DWORD_PTR)dwRefData, (int)v14, a1 + 20, a3, (int)v32, (int)&v27, 1, KeyState & 0x80);
        CoTaskMemFree(v14);
        sub_40A140((int)v33);
        operator delete(v33[0]);
        LOBYTE(v40) = 0;
        sub_4ACF20(dwRefData);
        v40 = -1;
        sub_41ECB0(&v30);
        v4 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
        v3 = a1;
      }
    }
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    v10 = v28;
  }
  if ( !*(_DWORD *)(v3 + 5612) )
    v4(*(HWND *)(v3 + 76), 0x110Bu, 9u, v26);
  v22 = (int)v10;
  *(_DWORD *)(v3 + 5588) = 0;
  CoTaskMemFree((LPVOID)v22);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00478440) --------------------------------------------------------
BOOL __usercall sub_478440@<eax>(int a1@<eax>, _DWORD *a2@<ecx>)
{
  BOOL result; // eax

  switch ( *(_WORD *)(a1 + 12) )
  {
    case '.':
      if ( (GetKeyState(16) & 0x80u) == 0 )
        sub_4773D0((int)a2, 0);
      else
        sub_4773D0((int)a2, 1);
      goto LABEL_17;
    case 'C':
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_477BF0(a2, 1);
      goto LABEL_17;
    case 'V':
      if ( (GetKeyState(17) & 0x80u) == 0 || (GetKeyState(16) & 0x80u) != 0 || (GetKeyState(18) & 0x80u) != 0 )
        goto LABEL_17;
      sub_4777F0((int)a2);
      result = (GetKeyState(17) & 0x80u) != 0;
      break;
    case 'X':
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_477BF0(a2, 0);
      goto LABEL_17;
    default:
LABEL_17:
      result = (GetKeyState(17) & 0x80u) != 0;
      break;
  }
  return result;
}

//----- (00478570) --------------------------------------------------------
BOOL __usercall sub_478570@<eax>(int a1@<ebx>)
{
  int v1; // esi
  ITEMIDLIST *v2; // edi
  const ITEMIDLIST *v3; // eax
  HWND v5; // [esp-10h] [ebp-50h]
  LPARAM lParam[14]; // [esp+8h] [ebp-38h] BYREF

  v1 = *(_DWORD *)(a1 + 1328);
  v5 = *(HWND *)(v1 + 12);
  lParam[0] = 20;
  lParam[1] = dword_4EF3D8;
  SendMessageW(v5, 0x113Eu, 0, (LPARAM)lParam);
  v2 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v1 + 588) + 8 * lParam[9]));
  v3 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
  if ( !*(_DWORD *)(a1 + 5592) && !*(_DWORD *)(a1 + 5588) && !sub_466190(v2, v3) )
  {
    sub_492F40(a1, v2, 1);
    if ( *(_DWORD *)(a1 + 59444) )
      SendMessageW(*(HWND *)(a1 + 76), 0x1102u, 2u, dword_4EF3D8);
  }
  CoTaskMemFree(v2);
  return KillTimer(*(HWND *)(a1 + 80), 0);
}

//----- (00478630) --------------------------------------------------------
int __usercall sub_478630@<eax>(int a1@<ebx>, int a2@<edi>)
{
  void (__stdcall *v2)(HWND, UINT, WPARAM, LPARAM); // esi
  int v3; // eax
  ITEMIDLIST *v4; // esi
  LPARAM v6; // eax
  ITEMIDLIST *v7; // esi
  HWND v8; // [esp-10h] [ebp-50h]
  int v9; // [esp+4h] [ebp-3Ch]
  LPARAM lParam[14]; // [esp+8h] [ebp-38h] BYREF

  v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
  if ( SendMessageW(*(HWND *)a2, 0x110Au, 3u, *(_DWORD *)(a2 + 60)) )
  {
    if ( *(_DWORD *)(a2 + 12) == 2 )
    {
      v3 = *(_DWORD *)(a1 + 1328);
      lParam[1] = *(_DWORD *)(a2 + 60);
      v8 = *(HWND *)(v3 + 12);
      v9 = v3;
      lParam[0] = 20;
      SendMessageW(v8, 0x113Eu, 0, (LPARAM)lParam);
      v4 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v9 + 588) + 8 * lParam[9]));
      sub_41C970(v4, *(_DWORD *)(a1 + 1328), *(_DWORD *)(a2 + 60));
      CoTaskMemFree(v4);
      return 0;
    }
    v6 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0);
    if ( v6 )
    {
      do
        v6 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 3u, v6);
      while ( v6 != *(_DWORD *)(a2 + 60) && v6 );
      if ( v6 == *(_DWORD *)(a2 + 60) )
      {
        v7 = sub_41D9D0(*(_DWORD *)(a2 + 60), *(_DWORD *)(a1 + 1328));
        sub_492F40(a1, v7, 1);
        CoTaskMemFree(v7);
        v2 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
      }
    }
    sub_41E2B0(*(_DWORD *)(a1 + 1328), *(_DWORD *)(a2 + 60));
    v2(*(HWND *)a2, 0x1102u, 0x8001u, *(_DWORD *)(a2 + 60));
  }
  return 0;
}

//----- (00478750) --------------------------------------------------------
int __usercall sub_478750@<eax>(UINT_PTR a1@<ecx>, _DWORD *a2@<eax>)
{
  unsigned int v3; // ecx
  int result; // eax
  DWORD MessagePos; // eax
  LONG v6; // ecx
  int v7[2]; // [esp+8h] [ebp-18h] BYREF
  struct tagPOINT Point; // [esp+10h] [ebp-10h] BYREF
  char v9; // [esp+18h] [ebp-8h]
  LPARAM lParam; // [esp+1Ch] [ebp-4h]

  v3 = a2[2];
  if ( v3 > 0xFFFFFE64 )
  {
    if ( v3 == -5 && *a2 == *(_DWORD *)(a1 + 76) )
    {
      MessagePos = GetMessagePos();
      v6 = (__int16)MessagePos;
      MessagePos >>= 16;
      v7[1] = (__int16)MessagePos;
      Point.y = (__int16)MessagePos;
      v7[0] = v6;
      Point.x = v6;
      ScreenToClient(*(HWND *)(a1 + 76), &Point);
      SendMessageW(*(HWND *)(a1 + 76), 0x1111u, 0, (LPARAM)&Point);
      if ( (v9 & 1) == 0 )
        sub_478110(a1, lParam, (int)v7);
    }
    return 0;
  }
  else if ( v3 == -412 )
  {
    return sub_478440((int)a2, (_DWORD *)a1);
  }
  else
  {
    switch ( v3 )
    {
      case 0xFFFFFE34:
        sub_477950((int)a2, a1);
        result = 0;
        break;
      case 0xFFFFFE35:
        sub_477230((int)a2, a1);
        result = 0;
        break;
      case 0xFFFFFE38:
      case 0xFFFFFE3C:
        SendMessageW(*(HWND *)(a1 + 76), 0x4Eu, 0, (LPARAM)a2);
        result = 0;
        break;
      case 0xFFFFFE3A:
        result = sub_478630(a1, (int)a2);
        break;
      case 0xFFFFFE3D:
        sub_4772A0(a1, (int)a2);
        result = 0;
        break;
      default:
        return 0;
    }
  }
  return result;
}

//----- (00478900) --------------------------------------------------------
int __stdcall sub_478900(int a1, int a2, int a3, DWORD dwErrCode, int a5, int a6)
{
  if ( a2 == 78 )
    return sub_478750(a6, (_DWORD *)dwErrCode);
  if ( a2 == 273 )
  {
    if ( (_WORD)a3 == 6000 )
      sub_475130(a6);
    return 1;
  }
  else
  {
    if ( a2 == 275 )
      sub_478570(a6);
    return sub_401C60(a1, a2, a3, dwErrCode);
  }
}

//----- (00478970) --------------------------------------------------------
int __thiscall sub_478970(_DWORD *this)
{
  return this[1398];
}

//----- (00478980) --------------------------------------------------------
LRESULT __usercall sub_478980@<eax>(int a1@<esi>)
{
  int v1; // eax

  if ( SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0) <= 1 )
    return SendMessageW(*(HWND *)(a1 + 72), 0x411u, 0x13A9u, 16);
  v1 = 532 * *(_DWORD *)(a1 + 5620);
  if ( *(_DWORD *)(v1 + a1 + 5672) || *(_DWORD *)(v1 + a1 + 5676) )
    return SendMessageW(*(HWND *)(a1 + 72), 0x411u, 0x13A9u, 16);
  else
    return SendMessageW(*(HWND *)(a1 + 72), 0x411u, 0x13A9u, 4);
}

//----- (004789F0) --------------------------------------------------------
WPARAM __usercall sub_4789F0@<eax>(unsigned int a1@<ecx>, int a2@<edi>)
{
  LRESULT v3; // eax
  HWND v4; // edx
  WPARAM result; // eax
  WPARAM v6; // ebx
  int v7; // esi
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  HWND v11; // [esp-10h] [ebp-40h]
  WPARAM v12; // [esp+Ch] [ebp-24h]
  int v13[2]; // [esp+10h] [ebp-20h] BYREF
  int v14; // [esp+18h] [ebp-18h]
  LPARAM lParam[3]; // [esp+20h] [ebp-10h] BYREF

  v3 = SendMessageW(*(HWND *)(a2 + 68), 0x132Fu, 0, 0);
  v4 = *(HWND *)(a2 + 68);
  v12 = v3;
  v14 = (unsigned __int16)a1;
  lParam[0] = (unsigned __int16)a1;
  lParam[1] = HIWORD(a1);
  result = SendMessageW(v4, 0x130Du, 0, (LPARAM)lParam);
  v6 = result;
  if ( lParam[2] != 1 && result != v12 )
  {
    v7 = v14;
    if ( v14 < *(_DWORD *)(a2 + 60620) || v14 > *(_DWORD *)(a2 + 60628) )
    {
      SendMessageW(*(HWND *)(a2 + 68), 0x130Au, result, (LPARAM)v13);
      v8 = *(_DWORD *)(a2 + 60628);
      if ( v7 <= v8 )
      {
        v10 = v13[0];
        *(_DWORD *)(a2 + 60628) = *(_DWORD *)(a2 + 60620);
        *(_DWORD *)(a2 + 60620) = v10;
      }
      else
      {
        v9 = v14;
        *(_DWORD *)(a2 + 60620) = v8;
        *(_DWORD *)(a2 + 60628) = v9;
      }
      sub_4686B0(*(HWND *)(a2 + 68), v12, v6);
      v11 = *(HWND *)(a2 + 68);
      *(_DWORD *)(a2 + 5632) = v6;
      return SendMessageW(v11, 0x1330u, v6, 0);
    }
  }
  return result;
}
// 4789F0: using guessed type LPARAM var_20[2];

//----- (00478AE0) --------------------------------------------------------
HWND __usercall sub_478AE0@<eax>(int a1@<esi>)
{
  HWND result; // eax

  result = GetCapture();
  if ( result == *(HWND *)(a1 + 68) )
    result = (HWND)ReleaseCapture();
  *(_DWORD *)(a1 + 60616) = 0;
  return result;
}

//----- (00478B00) --------------------------------------------------------
HWND __userpurge sub_478B00@<eax>(int a1@<esi>, unsigned int a2)
{
  HWND result; // eax
  HWND v3; // [esp-10h] [ebp-24h]
  LPARAM lParam[3]; // [esp+4h] [ebp-10h] BYREF

  lParam[1] = HIWORD(a2);
  v3 = *(HWND *)(a1 + 68);
  lParam[0] = (unsigned __int16)a2;
  result = (HWND)SendMessageW(v3, 0x130Du, 0, (LPARAM)lParam);
  if ( lParam[2] != 1 )
  {
    SendMessageW(*(HWND *)(a1 + 68), 0x130Au, (WPARAM)result, a1 + 60620);
    result = SetCapture(*(HWND *)(a1 + 68));
    *(_DWORD *)(a1 + 60616) = 1;
  }
  return result;
}

//----- (00478B80) --------------------------------------------------------
BOOL __usercall sub_478B80@<eax>(int a1@<eax>, HMENU a2@<esi>)
{
  HWND v4; // [esp-10h] [ebp-34h]
  WPARAM v5; // [esp-8h] [ebp-2Ch]
  int lParam[6]; // [esp+8h] [ebp-1Ch] BYREF
  int v7; // [esp+20h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 60636);
  v4 = *(HWND *)(a1 + 68);
  lParam[0] = 8;
  SendMessageW(v4, 0x133Cu, v5, (LPARAM)lParam);
  if ( *(_DWORD *)(532 * v7 + a1 + 5672) )
    CheckMenuItem(a2, 0x9D39u, 8u);
  else
    CheckMenuItem(a2, 0x9D39u, 0);
  if ( *(_DWORD *)(532 * v7 + a1 + 5676) )
    CheckMenuItem(a2, 0x9D3Du, 8u);
  else
    CheckMenuItem(a2, 0x9D3Du, 0);
  if ( *(_DWORD *)(a1 + 532 * v7 + 5672) || *(_DWORD *)(a1 + 532 * v7 + 5676) )
    return EnableMenuItem(a2, 0x9D3Bu, 1u);
  else
    return EnableMenuItem(a2, 0x9D3Bu, 0);
}
// 478B80: using guessed type LPARAM lParam[6];

//----- (00478C40) --------------------------------------------------------
LRESULT __stdcall sub_478C40(int a1)
{
  LRESULT result; // eax
  LRESULT v2; // ebx
  signed int i; // esi
  HWND v4; // [esp-10h] [ebp-38h]
  LPARAM lParam[7]; // [esp+Ch] [ebp-1Ch] BYREF

  result = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  v2 = result;
  for ( i = 0; i < v2; ++i )
  {
    v4 = *(HWND *)(a1 + 68);
    lParam[0] = 8;
    SendMessageW(v4, 0x133Cu, i, (LPARAM)lParam);
    result = (*(int (__thiscall **)(int, LPARAM))(*(_DWORD *)(a1 + 28) + 16))(a1 + 28, lParam[6]);
  }
  return result;
}

//----- (00478CB0) --------------------------------------------------------
int __userpurge sub_478CB0@<eax>(int a1@<edi>, int a2@<esi>, int a3, int a4)
{
  int result; // eax

  (*(void (__stdcall **)(_DWORD, int, _DWORD))(**(_DWORD **)(a2 + 59524) + 44))(
    *(_DWORD *)(a2 + 59524),
    a1,
    *(_DWORD *)(a2 + 52));
  (*(void (__stdcall **)(_DWORD, int, _DWORD))(**(_DWORD **)(a2 + 59524) + 52))(*(_DWORD *)(a2 + 59524), a1, 0);
  result = (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(a2 + 59524) + 76))(*(_DWORD *)(a2 + 59524), a1, a3);
  if ( a4 )
    return (*(int (__stdcall **)(_DWORD, int, _DWORD, _DWORD))(**(_DWORD **)(a2 + 59524) + 56))(
             *(_DWORD *)(a2 + 59524),
             a1,
             *(_DWORD *)(a2 + 52),
             0);
  return result;
}

//----- (00478D80) --------------------------------------------------------
_DWORD *__userpurge sub_478D80@<eax>(int a1@<eax>, int a2@<ecx>, HICON hIcon)
{
  _DWORD *result; // eax
  _DWORD *v4; // esi
  HICON ClassLongW; // eax
  HICON v6; // eax

  result = *(_DWORD **)(a1 + 59528);
  v4 = (_DWORD *)*result;
  if ( (_DWORD *)*result != result )
  {
    while ( v4[4] != a2 )
    {
      v4 = (_DWORD *)*v4;
      if ( v4 == result )
        return result;
    }
    ClassLongW = (HICON)GetClassLongW((HWND)v4[3], -34);
    DestroyIcon(ClassLongW);
    v6 = CopyIcon(hIcon);
    return (_DWORD *)SetClassLongW((HWND)v4[3], -34, (LONG)v6);
  }
  return result;
}

//----- (00478DD0) --------------------------------------------------------
int __userpurge sub_478DD0@<eax>(int a1@<ecx>, int *a2@<ebx>, int a3)
{
  HWND v3; // edi
  HDC CompatibleDC; // esi
  LONG left; // ecx
  HGDIOBJ v6; // eax
  HGDIOBJ v7; // edx
  int v8; // ecx
  HWND v10; // [esp-10h] [ebp-84h]
  struct tagPOINT pt; // [esp+8h] [ebp-6Ch] BYREF
  int v12; // [esp+14h] [ebp-60h]
  BOOL v13; // [esp+20h] [ebp-54h]
  HDC hDC; // [esp+24h] [ebp-50h]
  int v15; // [esp+28h] [ebp-4Ch]
  HGDIOBJ v16; // [esp+2Ch] [ebp-48h]
  int v17; // [esp+30h] [ebp-44h]
  int v18; // [esp+34h] [ebp-40h] BYREF
  HGDIOBJ h; // [esp+38h] [ebp-3Ch] BYREF
  struct tagMENUBARINFO pmbi; // [esp+3Ch] [ebp-38h] BYREF
  struct tagRECT Rect; // [esp+5Ch] [ebp-18h] BYREF

  v3 = *(HWND *)(a3 + 4 * a1 + 92);
  v17 = a3;
  v15 = a1;
  hDC = GetDC(v3);
  CompatibleDC = CreateCompatibleDC(hDC);
  GetClientRect(v3, &Rect);
  v18 = 0;
  GdipCreateBitmapFromScan0(Rect.right - Rect.left, Rect.bottom - Rect.top, 0, 2498570, 0, &v18);
  v12 = v18;
  GdipCreateHBITMAPFromBitmap(v18, &h, -16777216);
  v16 = SelectObject(CompatibleDC, h);
  v13 = IsWindowVisible(v3);
  if ( !v13 )
    ShowWindow(v3, 5);
  PrintWindow(v3, CompatibleDC, 1u);
  if ( !v13 )
    ShowWindow(v3, 0);
  SetStretchBltMode(CompatibleDC, 4);
  SetBrushOrgEx(CompatibleDC, 0, 0, &pt);
  StretchBlt(
    CompatibleDC,
    0,
    0,
    Rect.right - Rect.left,
    Rect.bottom - Rect.top,
    CompatibleDC,
    0,
    0,
    Rect.right - Rect.left,
    Rect.bottom - Rect.top,
    0xCC0020u);
  MapWindowPoints(v3, *(HWND *)(v17 + 52), (LPPOINT)&Rect, 2u);
  v10 = *(HWND *)(v17 + 52);
  pmbi.cbSize = 32;
  GetMenuBarInfo(v10, -3, 0, &pmbi);
  left = Rect.left;
  v6 = h;
  a2[3] = Rect.top + pmbi.rcBar.bottom - pmbi.rcBar.top;
  v7 = v16;
  a2[2] = left;
  v8 = v15;
  a2[1] = (int)v6;
  *a2 = v8;
  SelectObject(CompatibleDC, v7);
  DeleteDC(CompatibleDC);
  ReleaseDC(v3, hDC);
  return GdipDisposeImage(v12);
}
// 4BD668: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 4BD674: using guessed type int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD698: using guessed type int __stdcall GdipCreateHBITMAPFromBitmap(_DWORD, _DWORD, _DWORD);

//----- (00478F50) --------------------------------------------------------
HGDIOBJ __thiscall sub_478F50(HWND *this, int a2)
{
  HWND v3; // esi
  HDC CompatibleDC; // edi
  HDC v5; // esi
  HGDIOBJ v6; // esi
  HWND v8; // [esp-8h] [ebp-8Ch]
  int v9; // [esp+10h] [ebp-74h]
  HDC v10; // [esp+20h] [ebp-64h]
  struct tagPOINT pt; // [esp+2Ch] [ebp-58h] BYREF
  HGDIOBJ v12; // [esp+34h] [ebp-50h]
  HGDIOBJ ho; // [esp+38h] [ebp-4Ch]
  BOOL v14; // [esp+3Ch] [ebp-48h]
  int v15; // [esp+40h] [ebp-44h] BYREF
  HGDIOBJ h; // [esp+44h] [ebp-40h] BYREF
  HWND *v17; // [esp+48h] [ebp-3Ch]
  HDC hdcSrc; // [esp+4Ch] [ebp-38h]
  HGDIOBJ v19; // [esp+50h] [ebp-34h] BYREF
  HDC hdc; // [esp+54h] [ebp-30h] BYREF
  HDC hdcBlt; // [esp+58h] [ebp-2Ch]
  struct tagRECT v22; // [esp+5Ch] [ebp-28h] BYREF
  struct tagRECT Rect; // [esp+6Ch] [ebp-18h] BYREF

  v3 = this[a2 + 23];
  v8 = this[13];
  v17 = this;
  GetClientRect(v8, &Rect);
  GetClientRect(v3, &v22);
  hdcSrc = GetDC(this[13]);
  CompatibleDC = CreateCompatibleDC(hdcSrc);
  v15 = 0;
  GdipCreateBitmapFromScan0(Rect.right - Rect.left, Rect.bottom - Rect.top, 0, 2498570, 0, &v15);
  v9 = v15;
  GdipCreateHBITMAPFromBitmap(v15, &h, -16777216);
  SelectObject(CompatibleDC, h);
  BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, hdcSrc, 0, 0, 0xCC0020u);
  hdc = GetDC(v3);
  hdcBlt = CreateCompatibleDC(hdc);
  ho = CreateCompatibleBitmap(hdc, v22.right - v22.left, v22.bottom - v22.top);
  v12 = SelectObject(hdcBlt, ho);
  v14 = IsWindowVisible(v3);
  if ( !v14 )
    ShowWindow(v3, 5);
  PrintWindow(v3, hdcBlt, 1u);
  if ( !v14 )
    ShowWindow(v3, 0);
  MapWindowPoints(v3, v17[13], (LPPOINT)&v22, 2u);
  BitBlt(CompatibleDC, v22.left, v22.top, v22.right - v22.left, v22.bottom - v22.top, hdcBlt, 0, 0, 0xCC0020u);
  SelectObject(hdcBlt, v12);
  DeleteObject(ho);
  DeleteDC(hdcBlt);
  ReleaseDC(v3, hdc);
  v5 = CreateCompatibleDC(hdcSrc);
  hdc = 0;
  GdipCreateBitmapFromScan0(Rect.right - Rect.left, Rect.bottom - Rect.top, 0, 2498570, 0, &hdc);
  v10 = hdc;
  GdipCreateHBITMAPFromBitmap(hdc, &v19, -16777216);
  hdcBlt = (HDC)SelectObject(v5, v19);
  SetStretchBltMode(v5, 4);
  SetBrushOrgEx(v5, 0, 0, &pt);
  BitBlt(v5, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, CompatibleDC, 0, 0, 0xCC0020u);
  SetBitmapDimensionEx((HBITMAP)v19, Rect.right - Rect.left, Rect.bottom - Rect.top, 0);
  SelectObject(v5, hdcBlt);
  DeleteDC(v5);
  DeleteObject(h);
  SelectObject(CompatibleDC, hdcBlt);
  DeleteDC(CompatibleDC);
  ReleaseDC(v17[13], hdcSrc);
  v6 = v19;
  GdipDisposeImage(v10);
  GdipDisposeImage(v9);
  return v6;
}
// 4BD668: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 4BD674: using guessed type int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD698: using guessed type int __stdcall GdipCreateHBITMAPFromBitmap(_DWORD, _DWORD, _DWORD);

//----- (004791F0) --------------------------------------------------------
void __thiscall sub_4791F0(
        _DWORD *this,
        WPARAM wParam,
        void *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10)
{
  _WORD *v11; // edx
  int v12; // esi
  _WORD *v13; // eax
  int v14; // ecx
  _BYTE *v15; // esi
  char *v16; // eax
  int v17; // edx
  int v18; // esi
  __int16 v19; // cx
  HWND v20; // [esp-10h] [ebp-23Ch]
  HWND v21; // [esp-10h] [ebp-23Ch]
  LPARAM lParam[6]; // [esp+Ch] [ebp-220h] BYREF
  int v23; // [esp+24h] [ebp-208h]
  char v24[512]; // [esp+28h] [ebp-204h] BYREF

  v20 = (HWND)this[10];
  lParam[0] = 8;
  SendMessageW(v20, 0x133Cu, wParam, (LPARAM)lParam);
  v11 = a3;
  if ( (unsigned int)a8 < 8 )
    v11 = &a3;
  v12 = 260;
  v13 = &this[133 * v23 + 1414];
  while ( v12 != -2147483386 && *v11 )
  {
    *v13++ = *v11++;
    if ( !--v12 )
    {
      --v13;
      break;
    }
  }
  v14 = a10;
  *v13 = 0;
  this[133 * v23 + 1413] = v14;
  v15 = a3;
  if ( (unsigned int)a8 < 8 )
    v15 = &a3;
  v16 = v24;
  v17 = 256;
  v18 = v15 - v24;
  while ( v17 != -2147483390 )
  {
    v19 = *(_WORD *)&v16[v18];
    if ( !v19 )
      break;
    *(_WORD *)v16 = v19;
    v16 += 2;
    if ( !--v17 )
    {
      v16 -= 2;
      break;
    }
  }
  *(_WORD *)v16 = 0;
  v21 = (HWND)this[10];
  lParam[0] = 1;
  lParam[3] = (LPARAM)v24;
  SendMessageW(v21, 0x133Du, wParam, (LPARAM)lParam);
  if ( (unsigned int)a8 >= 8 )
    operator delete(a3);
}
// 479272: conditional instruction was optimized away because esi.4!=0
// 4792D0: conditional instruction was optimized away because edx.4!=0

//----- (00479330) --------------------------------------------------------
void __userpurge sub_479330(int a1@<esi>, int a2)
{
  HRESULT v2; // edi
  LPVOID pv; // [esp+8h] [ebp-210h] BYREF
  char v4[520]; // [esp+Ch] [ebp-20Ch] BYREF

  (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a1 + 4 * a2 + 916) + 52))(
    *(_DWORD *)(a1 + 4 * a2 + 916),
    260,
    v4);
  pv = 0;
  v2 = sub_467810((LPITEMIDLIST *)&pv, (int)v4);
  (*(void (__thiscall **)(int, LPVOID, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
    a1 + 28,
    pv,
    0,
    1,
    0,
    0);
  if ( v2 >= 0 )
    CoTaskMemFree(pv);
}

//----- (004793C0) --------------------------------------------------------
void __usercall sub_4793C0(WPARAM wParam@<ecx>, int a2@<eax>)
{
  HWND v3; // [esp-10h] [ebp-30h]
  LPARAM lParam[7]; // [esp+4h] [ebp-1Ch] BYREF

  v3 = *(HWND *)(a2 + 68);
  lParam[0] = 8;
  SendMessageW(v3, 0x133Cu, wParam, (LPARAM)lParam);
  sub_479330(a2, lParam[6]);
}

//----- (00479400) --------------------------------------------------------
int __userpurge sub_479400@<eax>(LPARAM a1@<eax>, int a2@<edx>, WPARAM a3@<ecx>, int a4)
{
  DWORD MessagePos; // eax
  HWND v8; // eax
  HWND v9; // ecx
  int v10; // ecx
  int i; // edi
  int v12; // ecx
  signed int v13; // edi
  int v14; // eax
  HWND v15; // ecx
  HWND Window; // edi
  LPARAM v17; // ebx
  POINT v19; // [esp-8h] [ebp-28h]
  int v20; // [esp+10h] [ebp-10h]
  LPARAM lParam; // [esp+14h] [ebp-Ch] BYREF
  LPARAM v22; // [esp+18h] [ebp-8h] BYREF
  WPARAM wParam; // [esp+1Ch] [ebp-4h] BYREF

  *(_DWORD *)(a2 + 61308) += SHIWORD(a3);
  MessagePos = GetMessagePos();
  v19.y = SHIWORD(MessagePos);
  v19.x = (__int16)MessagePos;
  v8 = WindowFromPoint(v19);
  v9 = *(HWND *)(a2 + 3432);
  v20 = 0;
  if ( v8 == v9 )
  {
    if ( (a3 & 8) != 0 )
    {
      v10 = *(_DWORD *)(a2 + 61308);
      for ( i = 0; i < (int)abs32(v10 / 120); ++i )
      {
        sub_490840(v10, i, a2, *(_DWORD *)(a2 + 61308) > 0);
        v10 = *(_DWORD *)(a2 + 61308);
      }
      goto LABEL_28;
    }
    if ( (a3 & 4) != 0 )
    {
      v12 = *(_DWORD *)(a2 + 61308);
      v13 = 0;
      v14 = abs32(v12 / 120);
      if ( v12 >= 0 )
      {
        if ( v14 > 0 )
        {
          do
          {
            sub_490690(a2);
            ++v13;
          }
          while ( v13 < (int)abs32(*(_DWORD *)(a2 + 61308) / 120) );
        }
      }
      else if ( v14 > 0 )
      {
        do
        {
          sub_4906F0(a2);
          ++v13;
        }
        while ( v13 < (int)abs32(*(_DWORD *)(a2 + 61308) / 120) );
      }
      goto LABEL_28;
    }
    if ( !a4 )
      goto LABEL_28;
LABEL_15:
    v20 = 1;
    SendMessageW(v9, 0x20Au, a3, a1);
    goto LABEL_28;
  }
  v9 = *(HWND *)(a2 + 76);
  if ( v8 == v9 )
  {
    if ( a4 == 1 )
      goto LABEL_28;
    goto LABEL_15;
  }
  v15 = *(HWND *)(a2 + 68);
  if ( v8 == v15 )
  {
    v20 = 1;
    Window = FindWindowExW(v15, 0, L"msctls_updown32", 0);
    if ( Window )
    {
      v17 = SendMessageW(Window, 0x472u, 0, (LPARAM)&lParam);
      if ( lParam )
      {
        SendMessageW(Window, 0x470u, (WPARAM)&wParam, (LPARAM)&v22);
        if ( *(int *)(a2 + 61308) >= 0 )
        {
          if ( v17 > (int)wParam )
            LOWORD(v17) = v17 - 1;
        }
        else if ( v17 < v22 )
        {
          LOWORD(v17) = v17 + 1;
        }
        SendMessageW(*(HWND *)(a2 + 68), 0x114u, ((unsigned __int16)v17 << 16) | 4, 0);
      }
    }
  }
LABEL_28:
  if ( (int)abs32(*(_DWORD *)(a2 + 61308)) >= 120 )
    *(int *)(a2 + 61308) %= 120;
  return v20;
}

//----- (00479660) --------------------------------------------------------
void __userpurge sub_479660(int a1@<eax>, WPARAM wParam)
{
  int v3; // eax
  int v4; // ebx
  WCHAR *v5; // edi
  HWND v6; // [esp-10h] [ebp-3Ch]
  int lParam[6]; // [esp+10h] [ebp-1Ch] BYREF
  int v8; // [esp+28h] [ebp-4h]

  v6 = *(HWND *)(a1 + 68);
  lParam[0] = 8;
  SendMessageW(v6, 0x133Cu, wParam, (LPARAM)lParam);
  *(_DWORD *)(532 * v8 + a1 + 5676) = *(_DWORD *)(532 * v8 + a1 + 5676) == 0;
  v3 = v8;
  if ( *(_DWORD *)(532 * v8 + a1 + 5676) )
  {
    *(_DWORD *)(532 * v8 + a1 + 5672) = 0;
    v3 = v8;
  }
  v4 = v3;
  v5 = (WCHAR *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v3 + 916) + 56))(*(_DWORD *)(a1 + 4 * v3 + 916));
  sub_4ABFC0(v5, v4, a1, wParam);
  CoTaskMemFree(v5);
  if ( v8 == *(_DWORD *)(a1 + 5620) )
    sub_478980(a1);
}
// 479660: using guessed type LPARAM lParam[6];

//----- (00479710) --------------------------------------------------------
void __userpurge sub_479710(int a1@<eax>, int a2@<edi>, WPARAM wParam)
{
  BOOL v4; // ecx
  WCHAR *v5; // ebx

  v4 = *(_DWORD *)(532 * a2 + a1 + 5672) == 0;
  *(_DWORD *)(532 * a2 + a1 + 5672) = v4;
  if ( v4 )
    *(_DWORD *)(532 * a2 + a1 + 5676) = 0;
  v5 = (WCHAR *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * a2 + 916) + 56))(*(_DWORD *)(a1 + 4 * a2 + 916));
  sub_4ABFC0(v5, a2, a1, wParam);
  CoTaskMemFree(v5);
  if ( a2 == *(_DWORD *)(a1 + 5620) )
    sub_478980(a1);
}

//----- (00479780) --------------------------------------------------------
void __usercall sub_479780(int a1@<ebx>, WPARAM a2@<esi>)
{
  HWND v2; // [esp-10h] [ebp-30h]
  LPARAM lParam[7]; // [esp+4h] [ebp-1Ch] BYREF

  v2 = *(HWND *)(a1 + 68);
  lParam[0] = 8;
  SendMessageW(v2, 0x133Cu, a2, (LPARAM)lParam);
  sub_479710(a1, lParam[6], a2);
}

//----- (004797C0) --------------------------------------------------------
int __fastcall sub_4797C0(int a1, const ITEMIDLIST *a2, WPARAM wParam, int a4)
{
  bool v5; // zf
  int v6; // ebx
  _WORD *v7; // eax
  int v8; // edx
  __int16 v9; // cx
  HWND v10; // ecx
  int result; // eax
  HWND v12; // [esp-8h] [ebp-460h]
  LPARAM lParam[7]; // [esp+Ch] [ebp-44Ch] BYREF
  LPCWSTR pszPath; // [esp+28h] [ebp-430h]
  LPARAM v15; // [esp+2Ch] [ebp-42Ch]
  struct tagRECT Rect; // [esp+30h] [ebp-428h] BYREF
  __int16 v17[260]; // [esp+40h] [ebp-418h] BYREF
  __int16 v18[262]; // [esp+248h] [ebp-210h] BYREF

  v15 = a4;
  v5 = *(_DWORD *)(532 * a4 + a1 + 5680) == 0;
  v6 = 532 * a4 + a1;
  pszPath = &a2->mkid.cb;
  if ( v5 )
  {
    sub_466630(a2, (WCHAR *)v17, 1);
    v7 = (_WORD *)(v6 + 5684);
    v8 = 260;
    while ( v8 != -2147483386 )
    {
      v9 = *(_WORD *)((char *)v7 + (_DWORD)&v17[-2842] - v6);
      if ( !v9 )
        break;
      *v7++ = v9;
      if ( !--v8 )
      {
        --v7;
        break;
      }
    }
    *v7 = 0;
  }
  sub_46AE30((int)L"&&", (const WCHAR *)(v6 + 5684), v18);
  lParam[3] = (LPARAM)v18;
  v10 = *(HWND *)(a1 + 68);
  lParam[0] = 9;
  lParam[6] = v15;
  SendMessageW(v10, 0x133Eu, wParam, (LPARAM)lParam);
  result = sub_4ABFC0(pszPath, v15, a1, wParam);
  if ( !*(_DWORD *)(a1 + 59316) )
  {
    result = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
    if ( result > 1 )
    {
      v12 = *(HWND *)(a1 + 52);
      *(_DWORD *)(a1 + 59320) = 1;
      GetClientRect(v12, &Rect);
      return SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
    }
  }
  return result;
}
// 479840: conditional instruction was optimized away because edx.4!=0
// 4C6428: using guessed type wchar_t asc_4C6428[3];
// 4797C0: using guessed type WCHAR var_418[260];
// 4797C0: using guessed type _WORD var_210[262];

//----- (00479920) --------------------------------------------------------
int __stdcall sub_479920(int a1)
{
  int v1; // esi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // eax
  HICON v4; // eax
  ICONINFO piconinfo; // [esp+8h] [ebp-14h] BYREF

  v1 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v1, (int)BitmapW, 0);
  v4 = (HICON)sub_409F80(v1, 29, 1u);
  GetIconInfo(v4, &piconinfo);
  sub_4011E0(a1, (int)piconinfo.hbmColor, (DWORD)piconinfo.hbmMask);
  DeleteObject(piconinfo.hbmColor);
  DeleteObject(piconinfo.hbmMask);
  return sub_409E60(v1);
}

//----- (004799A0) --------------------------------------------------------
int __thiscall sub_4799A0(_DWORD *this, int a2, WPARAM wParam)
{
  _DWORD *v4; // edx
  HWND v6; // [esp-10h] [ebp-38h]
  LPARAM lParam[8]; // [esp+8h] [ebp-20h] BYREF

  v6 = (HWND)this[10];
  lParam[7] = 0;
  lParam[0] = 8;
  SendMessageW(v6, 0x133Cu, wParam, (LPARAM)lParam);
  v4 = &this[133 * lParam[6] + 1414];
  *(_DWORD *)(a2 + 20) = 7;
  *(_DWORD *)(a2 + 16) = 0;
  *(_WORD *)a2 = 0;
  sub_4094F0((_DWORD *)a2, (int)v4, v4, wcslen((const unsigned __int16 *)v4));
  return a2;
}

//----- (00479A30) --------------------------------------------------------
HWND __userpurge sub_479A30@<eax>(int a1@<eax>, int a2)
{
  int v3; // eax
  int v4; // ecx
  HWND result; // eax
  HWND v6; // ebx
  LRESULT v7; // eax
  int v8; // ecx
  _DWORD *v9; // eax
  _DWORD *v10; // edi
  HWND v11; // [esp-10h] [ebp-54h]
  HWND v12; // [esp-10h] [ebp-54h]
  WPARAM v13; // [esp-8h] [ebp-4Ch]
  LPARAM v14[7]; // [esp+Ch] [ebp-38h] BYREF
  int lParam[6]; // [esp+28h] [ebp-1Ch] BYREF
  int v16; // [esp+40h] [ebp-4h]

  v13 = *(_DWORD *)(a1 + 5632);
  v11 = *(HWND *)(a1 + 68);
  lParam[0] = 8;
  SendMessageW(v11, 0x133Cu, v13, (LPARAM)lParam);
  ShowWindow(*(HWND *)(a1 + 3432), 0);
  v3 = v16;
  *(_DWORD *)(a1 + 5620) = v16;
  *(_DWORD *)(a1 + 3432) = *(_DWORD *)(a1 + 4 * v3 + 92);
  v4 = *(_DWORD *)(a1 + 4 * v3 + 916);
  *(_DWORD *)(a1 + 1320) = v4;
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 52))(v4, 260, a1 + 3492);
  SetCurrentDirectoryW((LPCWSTR)(a1 + 3492));
  *(_DWORD *)(a1 + 60572) = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 292))(*(_DWORD *)(a1 + 1320));
  sub_4A7980(a1);
  sub_4A8290(a1);
  sub_4AC380(a1);
  result = (HWND)ShowWindow(*(HWND *)(a1 + 3432), 5);
  if ( *(_DWORD *)(a1 + 59544) )
  {
    result = *(HWND *)(a1 + 59528);
    v6 = *(HWND *)result;
    if ( *(HWND *)result != result )
    {
      result = *(HWND *)(a1 + 5620);
      while ( *((HWND *)v6 + 4) != result )
      {
        v6 = *(HWND *)v6;
        if ( v6 == *(HWND *)(a1 + 59528) )
          goto LABEL_14;
      }
      v7 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
      v8 = *(_DWORD *)(a1 + 5632);
      if ( v8 == v7 - 1 )
      {
        (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 59524) + 52))(
          *(_DWORD *)(a1 + 59524),
          *((_DWORD *)v6 + 3),
          0);
      }
      else
      {
        v12 = *(HWND *)(a1 + 68);
        v14[0] = 8;
        SendMessageW(v12, 0x133Cu, v8 + 1, (LPARAM)v14);
        v9 = *(_DWORD **)(a1 + 59528);
        v10 = (_DWORD *)*v9;
        if ( (_DWORD *)*v9 != v9 )
        {
          do
          {
            if ( v10[4] == v14[6] )
              (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 59524) + 52))(
                *(_DWORD *)(a1 + 59524),
                *((_DWORD *)v6 + 3),
                v10[3]);
            v10 = (_DWORD *)*v10;
          }
          while ( v10 != *(_DWORD **)(a1 + 59528) );
        }
      }
      result = (HWND)(*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD **)(a1 + 59524) + 56))(
                       *(_DWORD *)(a1 + 59524),
                       *((_DWORD *)v6 + 3),
                       *(_DWORD *)(a1 + 52),
                       0);
    }
  }
LABEL_14:
  if ( a2 )
    return SetFocus(*(HWND *)(a1 + 3432));
  return result;
}
// 479A30: using guessed type LPARAM lParam[6];

//----- (00479BD0) --------------------------------------------------------
HWND __usercall sub_479BD0@<eax>(int a1@<esi>)
{
  *(_DWORD *)(a1 + 5632) = SendMessageW(*(HWND *)(a1 + 68), 0x130Bu, 0, 0);
  return sub_479A30(a1, 1);
}

//----- (00479C00) --------------------------------------------------------
void __thiscall sub_479C00(_DWORD **this, int a2)
{
  void *v3; // ebx

  v3 = (void *)(*(int (__thiscall **)(_DWORD *))(*this[a2 + 222] + 56))(this[a2 + 222]);
  if ( (*(int (__thiscall **)(_DWORD *, void *, int))(*this[a2 + 222] + 12))(this[a2 + 222], v3, 134217729) >= 0 )
    sub_492670(a2, (int)(this - 7));
  CoTaskMemFree(v3);
}

//----- (00479C50) --------------------------------------------------------
int __userpurge sub_479C50@<eax>(int a1@<ebx>, WPARAM wParam)
{
  int v3; // edi
  bool v4; // zf
  int v5; // eax
  signed int v6; // eax
  void **v7; // eax
  void **v8; // esi
  void *WindowLongW; // edi
  HICON ClassLongW; // edi
  HMODULE ModuleHandleW; // eax
  int v12; // esi
  int v13; // eax
  int v14; // eax
  HWND v15; // [esp-10h] [ebp-58h]
  HWND v16; // [esp-8h] [ebp-50h]
  WPARAM v17; // [esp+Ch] [ebp-3Ch] BYREF
  int v18; // [esp+10h] [ebp-38h]
  LRESULT v19; // [esp+14h] [ebp-34h]
  LPARAM lParam[6]; // [esp+18h] [ebp-30h] BYREF
  int v21; // [esp+30h] [ebp-18h]
  struct tagRECT Rect; // [esp+34h] [ebp-14h] BYREF

  v19 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  if ( v19 == 1 )
  {
    if ( *(_DWORD *)(a1 + 59424) )
      SendMessageW(*(HWND *)(a1 + 52), 0x10u, 0, 0);
    return 0;
  }
  else
  {
    v15 = *(HWND *)(a1 + 68);
    lParam[0] = 10;
    SendMessageW(v15, 0x133Cu, wParam, (LPARAM)lParam);
    v3 = v21;
    v4 = *(_DWORD *)(532 * v21 + a1 + 5672) == 0;
    v17 = lParam[5];
    if ( !v4 || *(_DWORD *)(532 * v21 + a1 + 5676) )
    {
      return 1;
    }
    else
    {
      v18 = v21;
      EnterCriticalSection(&stru_4EF1A0);
      *(_DWORD *)(a1 + 4 * v3 + 58872) = 0;
      LeaveCriticalSection(&stru_4EF1A0);
      v5 = *(_DWORD *)(a1 + 5632);
      if ( wParam == v5 )
      {
        if ( wParam == v19 - 1 )
        {
          *(_DWORD *)(a1 + 5632) = v5 - 1;
          SendMessageW(*(HWND *)(a1 + 68), 0x130Cu, v5 - 1, 0);
          SendMessageW(*(HWND *)(a1 + 68), 0x1308u, wParam, 0);
        }
        else
        {
          SendMessageW(*(HWND *)(a1 + 68), 0x1308u, wParam, 0);
          SendMessageW(*(HWND *)(a1 + 68), 0x130Cu, *(_DWORD *)(a1 + 5632), 0);
        }
        sub_479A30(a1, 1);
      }
      else
      {
        SendMessageW(*(HWND *)(a1 + 68), 0x1308u, wParam, 0);
        v6 = *(_DWORD *)(a1 + 5632);
        if ( (int)wParam < v6 )
          *(_DWORD *)(a1 + 5632) = v6 - 1;
      }
      SendMessageW(*(HWND *)(a1 + 68), 0x132Au, v17, 0);
      if ( *(_DWORD *)(a1 + 59544) )
      {
        v7 = *(void ***)(a1 + 59528);
        v8 = (void **)*v7;
        if ( *v7 != v7 )
        {
          while ( v8[4] != (void *)v3 )
          {
            v8 = (void **)*v8;
            if ( v8 == v7 )
              goto LABEL_20;
          }
          (*(void (__stdcall **)(_DWORD, void *))(**(_DWORD **)(a1 + 59524) + 48))(*(_DWORD *)(a1 + 59524), v8[3]);
          WindowLongW = (void *)GetWindowLongW((HWND)v8[3], -21);
          DestroyWindow((HWND)v8[3]);
          free(WindowLongW);
          ClassLongW = (HICON)GetClassLongW((HWND)v8[3], -34);
          ModuleHandleW = GetModuleHandleW(0);
          sub_4182B0((LPCWSTR)*((unsigned __int8 *)v8 + 8), ModuleHandleW);
          DestroyIcon(ClassLongW);
          sub_40ABF0(&v17, a1 + 59528, v8);
          v3 = v18;
        }
      }
LABEL_20:
      v12 = **(_DWORD **)(a1 + 1324);
      v13 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v3 + 916) + 164))(*(_DWORD *)(a1 + 4 * v3 + 916));
      (*(void (__thiscall **)(_DWORD, int))(v12 + 20))(*(_DWORD *)(a1 + 1324), v13);
      (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v3 + 516) + 52))(*(_DWORD *)(a1 + 4 * v3 + 516));
      DestroyWindow(*(HWND *)(a1 + 4 * v3 + 92));
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v3 + 916) + 8))(*(_DWORD *)(a1 + 4 * v3 + 916));
      v14 = *(_DWORD *)(a1 + 4 * v3 + 516);
      *(_DWORD *)(a1 + 4 * v3 + 916) = 0;
      (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
      *(_DWORD *)(a1 + 4 * v3 + 516) = 0;
      sub_478980(a1);
      if ( !*(_DWORD *)(a1 + 59316) && SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0) == 1 )
      {
        v16 = *(HWND *)(a1 + 52);
        *(_DWORD *)(a1 + 59320) = 0;
        GetClientRect(v16, &Rect);
        SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
      }
      return 0;
    }
  }
}

//----- (00479F80) --------------------------------------------------------
HWND __userpurge sub_479F80@<eax>(LRESULT a1@<edi>, int a2@<esi>, int a3)
{
  LRESULT v3; // eax

  v3 = SendMessageW(*(HWND *)(a2 + 68), 0x1304u, 0, 0);
  if ( a1 == -1 || a1 >= v3 )
    *(_DWORD *)(a2 + 5632) = v3 - 1;
  else
    *(_DWORD *)(a2 + 5632) = a1;
  SendMessageW(*(HWND *)(a2 + 68), 0x130Cu, *(_DWORD *)(a2 + 5632), 0);
  return sub_479A30(a2, a3);
}

//----- (00479FD0) --------------------------------------------------------
HWND __usercall sub_479FD0@<eax>(LRESULT a1@<edi>, int a2@<esi>)
{
  LRESULT v2; // eax

  v2 = SendMessageW(*(HWND *)(a2 + 68), 0x1304u, 0, 0);
  if ( a1 == -1 || a1 >= v2 )
    *(_DWORD *)(a2 + 5632) = v2 - 1;
  else
    *(_DWORD *)(a2 + 5632) = a1;
  SendMessageW(*(HWND *)(a2 + 68), 0x130Cu, *(_DWORD *)(a2 + 5632), 0);
  return sub_479A30(a2, 1);
}

//----- (0047A020) --------------------------------------------------------
HWND __userpurge sub_47A020@<eax>(int a1@<esi>, int a2)
{
  LRESULT v2; // eax
  int v3; // ecx
  int v4; // ecx

  v2 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  v3 = *(_DWORD *)(a1 + 5632);
  if ( !a2 )
  {
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 5632) = v2 - 1;
      goto LABEL_9;
    }
    v4 = v3 - 1;
LABEL_8:
    *(_DWORD *)(a1 + 5632) = v4;
    goto LABEL_9;
  }
  if ( v3 != v2 - 1 )
  {
    v4 = v3 + 1;
    goto LABEL_8;
  }
  *(_DWORD *)(a1 + 5632) = 0;
LABEL_9:
  SendMessageW(*(HWND *)(a1 + 68), 0x130Cu, *(_DWORD *)(a1 + 5632), 0);
  return sub_479A30(a1, 1);
}

//----- (0047A090) --------------------------------------------------------
LRESULT __thiscall sub_47A090(int this, int a2)
{
  LRESULT (__stdcall *v2)(HWND, UINT, WPARAM, LPARAM); // edi
  LRESULT result; // eax
  int v5; // ebx
  int v6; // ebx
  int v7; // eax
  signed int v8; // eax
  void **v9; // eax
  void **v10; // edi
  HMODULE ModuleHandleW; // eax
  int v12; // eax
  int v13; // eax
  HWND v14; // [esp-Ch] [ebp-58h]
  HWND v15; // [esp-4h] [ebp-50h]
  WPARAM v16; // [esp+10h] [ebp-3Ch]
  void *WindowLongW; // [esp+10h] [ebp-3Ch]
  HICON ClassLongW; // [esp+10h] [ebp-3Ch]
  void (__thiscall **v19)(_DWORD, int); // [esp+10h] [ebp-3Ch]
  signed int wParam; // [esp+14h] [ebp-38h]
  LRESULT v21; // [esp+18h] [ebp-34h]
  LPARAM lParam[6]; // [esp+1Ch] [ebp-30h] BYREF
  int v23; // [esp+34h] [ebp-18h]
  struct tagRECT Rect; // [esp+38h] [ebp-14h] BYREF

  v2 = SendMessageW;
  result = SendMessageW(*(HWND *)(this + 68), 0x1304u, 0, 0);
  v5 = result - 1;
  for ( wParam = result - 1; v5 >= 0; wParam = v5 )
  {
    if ( v5 != a2 )
    {
      result = v2(*(HWND *)(this + 68), 0x1304u, 0, 0);
      v21 = result;
      if ( result == 1 )
      {
        if ( *(_DWORD *)(this + 59424) )
          result = v2(*(HWND *)(this + 52), 0x10u, 0, 0);
      }
      else
      {
        v14 = *(HWND *)(this + 68);
        lParam[0] = 10;
        v2(v14, 0x133Cu, v5, (LPARAM)lParam);
        result = 532 * v23;
        v16 = lParam[5];
        if ( !*(_DWORD *)(532 * v23 + this + 5672) && !*(_DWORD *)(result + this + 5676) )
        {
          v6 = v23;
          EnterCriticalSection(&stru_4EF1A0);
          *(_DWORD *)(this + 4 * v6 + 58872) = 0;
          LeaveCriticalSection(&stru_4EF1A0);
          v7 = *(_DWORD *)(this + 5632);
          if ( wParam == v7 )
          {
            if ( wParam == v21 - 1 )
            {
              *(_DWORD *)(this + 5632) = v7 - 1;
              v2(*(HWND *)(this + 68), 0x130Cu, v7 - 1, 0);
              v2(*(HWND *)(this + 68), 0x1308u, wParam, 0);
            }
            else
            {
              v2(*(HWND *)(this + 68), 0x1308u, wParam, 0);
              v2(*(HWND *)(this + 68), 0x130Cu, *(_DWORD *)(this + 5632), 0);
            }
            sub_479A30(this, 1);
          }
          else
          {
            v2(*(HWND *)(this + 68), 0x1308u, wParam, 0);
            v8 = *(_DWORD *)(this + 5632);
            if ( wParam < v8 )
              *(_DWORD *)(this + 5632) = v8 - 1;
          }
          v2(*(HWND *)(this + 68), 0x132Au, v16, 0);
          if ( *(_DWORD *)(this + 59544) )
          {
            v9 = *(void ***)(this + 59528);
            v10 = (void **)*v9;
            if ( *v9 != v9 )
            {
              while ( v10[4] != (void *)v6 )
              {
                v10 = (void **)*v10;
                if ( v10 == v9 )
                  goto LABEL_22;
              }
              (*(void (__stdcall **)(_DWORD, void *))(**(_DWORD **)(this + 59524) + 48))(
                *(_DWORD *)(this + 59524),
                v10[3]);
              WindowLongW = (void *)GetWindowLongW((HWND)v10[3], -21);
              DestroyWindow((HWND)v10[3]);
              free(WindowLongW);
              ClassLongW = (HICON)GetClassLongW((HWND)v10[3], -34);
              ModuleHandleW = GetModuleHandleW(0);
              sub_4182B0((LPCWSTR)*((unsigned __int8 *)v10 + 8), ModuleHandleW);
              DestroyIcon(ClassLongW);
              if ( v10 != *(void ***)(this + 59528) )
              {
                *(_DWORD *)v10[1] = *v10;
                *((_DWORD *)*v10 + 1) = v10[1];
                operator delete(v10);
                --*(_DWORD *)(this + 59532);
              }
            }
LABEL_22:
            v2 = SendMessageW;
          }
          v19 = (void (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 1324) + 20);
          v12 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 4 * v6 + 916) + 164))(*(_DWORD *)(this + 4 * v6 + 916));
          (*v19)(*(_DWORD *)(this + 1324), v12);
          (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 4 * v6 + 516) + 52))(*(_DWORD *)(this + 4 * v6 + 516));
          DestroyWindow(*(HWND *)(this + 4 * v6 + 92));
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4 * v6 + 916) + 8))(*(_DWORD *)(this + 4 * v6 + 916));
          v13 = *(_DWORD *)(this + 4 * v6 + 516);
          *(_DWORD *)(this + 4 * v6 + 916) = 0;
          (*(void (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13);
          *(_DWORD *)(this + 4 * v6 + 516) = 0;
          result = sub_478980(this);
          if ( !*(_DWORD *)(this + 59316) )
          {
            result = v2(*(HWND *)(this + 68), 0x1304u, 0, 0);
            if ( result == 1 )
            {
              v15 = *(HWND *)(this + 52);
              *(_DWORD *)(this + 59320) = 0;
              GetClientRect(v15, &Rect);
              result = v2(*(HWND *)(this + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
            }
          }
          v5 = wParam;
        }
      }
    }
    --v5;
  }
  return result;
}

//----- (0047A3E0) --------------------------------------------------------
LRESULT __stdcall sub_47A3E0(int a1, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM a5, int a6)
{
  UINT v6; // esi
  HDC v7; // eax
  WPARAM v8; // esi
  HMODULE v10; // eax
  HMODULE v11; // esi
  HRESULT (__stdcall *DwmSetIconicLivePreviewBitmap)(HWND, HBITMAP, POINT *, DWORD); // eax
  HMODULE ModuleHandleW; // eax
  HBITMAP ImageW; // esi
  int cx; // esi
  HDC CompatibleDC; // ebx
  HDC v17; // edi
  int v18; // eax
  HMODULE v19; // eax
  HMODULE v20; // edi
  HRESULT (__stdcall *DwmSetIconicThumbnail)(HWND, HBITMAP, DWORD); // eax
  HWND v22; // [esp-10h] [ebp-84h]
  HWND v23; // [esp-4h] [ebp-78h]
  LONG hSrc; // [esp+10h] [ebp-64h]
  HBITMAP h; // [esp+14h] [ebp-60h]
  int hDest; // [esp+18h] [ebp-5Ch]
  int wDest; // [esp+1Ch] [ebp-58h]
  HGDIOBJ ho; // [esp+20h] [ebp-54h] BYREF
  int v29; // [esp+24h] [ebp-50h] BYREF
  HGDIOBJ v30; // [esp+28h] [ebp-4Ch]
  HDC hdc; // [esp+2Ch] [ebp-48h]
  struct tagSIZE size; // [esp+30h] [ebp-44h] BYREF
  struct tagPOINT pt; // [esp+38h] [ebp-3Ch] BYREF
  POINT v34; // [esp+40h] [ebp-34h] BYREF
  LPARAM lParam[2]; // [esp+48h] [ebp-2Ch] BYREF
  int v36; // [esp+50h] [ebp-24h]
  int v37; // [esp+60h] [ebp-14h]
  int v38; // [esp+70h] [ebp-4h]

  v6 = Msg;
  if ( Msg > 0x112 )
  {
    if ( Msg == 803 )
    {
      v29 = HIWORD(a5);
      if ( IsIconic(*(HWND *)(a1 + 52)) )
      {
        ModuleHandleW = GetModuleHandleW(0);
        ImageW = (HBITMAP)LoadImageW(ModuleHandleW, (LPCWSTR)0xEC, 0, 0, 0, 0);
        h = ImageW;
        SetBitmapDimensionEx(ImageW, 223, 130, 0);
      }
      else
      {
        h = (HBITMAP)sub_478F50((HWND *)a1, a6);
        ImageW = h;
      }
      GetBitmapDimensionEx(ImageW, &size);
      cx = size.cx;
      hSrc = size.cy;
      hdc = GetDC(*(HWND *)(a1 + 52));
      CompatibleDC = CreateCompatibleDC(hdc);
      SelectObject(CompatibleDC, h);
      v17 = CreateCompatibleDC(hdc);
      if ( cx / v29 <= hSrc / (unsigned __int16)a5 )
      {
        hDest = (unsigned __int16)a5;
        wDest = (unsigned __int16)a5 * cx / hSrc;
      }
      else
      {
        wDest = v29;
        hDest = v29 * hSrc / cx;
      }
      lParam[0] = (LPARAM)&Gdiplus::Bitmap::`vftable';
      v29 = 0;
      v36 = GdipCreateBitmapFromScan0(wDest, hDest, 0, 2498570, 0, &v29);
      lParam[1] = v29;
      v38 = 0;
      v18 = GdipCreateHBITMAPFromBitmap(v29, &ho, -16777216);
      if ( v18 )
        v36 = v18;
      v30 = SelectObject(v17, ho);
      SetStretchBltMode(v17, 4);
      SetBrushOrgEx(v17, 0, 0, &pt);
      StretchBlt(v17, 0, 0, wDest, hDest, CompatibleDC, 0, 0, cx, hSrc, 0xCC0020u);
      SelectObject(v17, v30);
      DeleteDC(v17);
      v19 = sub_40A920(L"dwmapi.dll");
      v20 = v19;
      if ( v19 )
      {
        DwmSetIconicThumbnail = (HRESULT (__stdcall *)(HWND, HBITMAP, DWORD))GetProcAddress(
                                                                               v19,
                                                                               "DwmSetIconicThumbnail");
        if ( DwmSetIconicThumbnail )
          DwmSetIconicThumbnail(hWnd, (HBITMAP)ho, 0);
      }
      FreeLibrary(v20);
      DeleteObject(h);
      SelectObject(CompatibleDC, v30);
      DeleteObject(ho);
      DeleteDC(CompatibleDC);
      ReleaseDC(*(HWND *)(a1 + 52), hdc);
      GdipDisposeImage(v29);
      return 0;
    }
    if ( Msg == 806 )
    {
      v23 = *(HWND *)(a1 + 52);
      pt.y = 0;
      if ( !IsIconic(v23) )
        sub_478DD0(a6, &pt.x, a1);
      v10 = sub_40A920(L"dwmapi.dll");
      v11 = v10;
      if ( v10 )
      {
        DwmSetIconicLivePreviewBitmap = (HRESULT (__stdcall *)(HWND, HBITMAP, POINT *, DWORD))GetProcAddress(
                                                                                                v10,
                                                                                                "DwmSetIconicLivePreviewBitmap");
        if ( DwmSetIconicLivePreviewBitmap )
          DwmSetIconicLivePreviewBitmap(hWnd, (HBITMAP)pt.y, &v34, 0);
      }
      FreeLibrary(v11);
      if ( pt.y )
        DeleteObject((HGDIOBJ)pt.y);
      return 0;
    }
    return DefWindowProcW(hWnd, v6, wParam, a5);
  }
  if ( Msg == 274 )
  {
    if ( wParam != 61536 )
      SendMessageW(*(HWND *)(a1 + 4 * a6 + 92), 0x112u, wParam, a5);
    return DefWindowProcW(hWnd, v6, wParam, a5);
  }
  if ( Msg != 6 )
  {
    if ( Msg == 7 )
    {
      SetFocus(*(HWND *)(a1 + 4 * a6 + 92));
    }
    else if ( Msg == 16 )
    {
      v7 = (HDC)SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
      hdc = v7;
      if ( v7 == (HDC)1 )
      {
        SendMessageW(*(HWND *)(a1 + 52), 0x10u, 0, 0);
      }
      else
      {
        v8 = 0;
        if ( (int)v7 > 0 )
        {
          while ( 1 )
          {
            v22 = *(HWND *)(a1 + 68);
            lParam[0] = 8;
            SendMessageW(v22, 0x133Cu, v8, (LPARAM)lParam);
            if ( v37 == a6 )
              break;
            if ( (int)++v8 >= (int)hdc )
              goto LABEL_11;
          }
          sub_479C50(a1, v8);
        }
LABEL_11:
        v6 = Msg;
      }
    }
    return DefWindowProcW(hWnd, v6, wParam, a5);
  }
  if ( IsIconic(*(HWND *)(a1 + 52)) )
    ShowWindow(*(HWND *)(a1 + 52), 9);
  sub_479F80(a6, a1, 0);
  return 0;
}
// 4BD668: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 4BD674: using guessed type int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4BD698: using guessed type int __stdcall GdipCreateHBITMAPFromBitmap(_DWORD, _DWORD, _DWORD);
// 4CC2CC: using guessed type void *Gdiplus::Bitmap::`vftable';
// 47A3E0: using guessed type POINT var_34;

//----- (0047A800) --------------------------------------------------------
LRESULT __stdcall sub_47A800(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int *WindowLongW; // esi

  WindowLongW = (int *)GetWindowLongW(hWnd, -21);
  if ( Msg == 1 )
  {
    WindowLongW = *(int **)lParam;
    SetWindowLongW(hWnd, -21, *(_DWORD *)lParam);
  }
  if ( WindowLongW )
    return sub_47A3E0(*WindowLongW, hWnd, Msg, wParam, lParam, WindowLongW[1]);
  else
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (0047A860) --------------------------------------------------------
__int16 __stdcall sub_47A860(DWORD a1)
{
  DWORD dwErrCode[13]; // [esp+8h] [ebp-34h] BYREF

  dwErrCode[0] = 48;
  dwErrCode[1] = 0;
  dwErrCode[2] = (DWORD)sub_47A800;
  dwErrCode[3] = 0;
  dwErrCode[4] = 4;
  dwErrCode[5] = (DWORD)GetModuleHandleW(0);
  dwErrCode[6] = 0;
  dwErrCode[11] = 0;
  dwErrCode[7] = (DWORD)LoadCursorW(0, (LPCWSTR)0x7F00);
  dwErrCode[8] = 0;
  dwErrCode[9] = 0;
  dwErrCode[10] = a1;
  return sub_418400((DWORD)dwErrCode);
}

//----- (0047A8C0) --------------------------------------------------------
void __fastcall sub_47A8C0(int a1, void *a2, unsigned int a3)
{
  ITEMIDLIST *v5; // esi
  void (__thiscall *v6)(int, LPVOID, _DWORD, int, int, _DWORD); // eax
  int v7; // ecx
  void *v8; // edi
  int v9; // eax
  signed int v10; // esi
  HWND v11; // [esp-10h] [ebp-284h]
  HWND v12; // [esp-10h] [ebp-284h]
  LPARAM lParam[6]; // [esp+Ch] [ebp-268h] BYREF
  int v14; // [esp+24h] [ebp-250h]
  LPVOID pv; // [esp+28h] [ebp-24Ch] BYREF
  int v16[145]; // [esp+2Ch] [ebp-248h] BYREF

  pv = a2;
  if ( a3 > 0x9D37 )
  {
    switch ( a3 )
    {
      case 0x9D39u:
        sub_479780(a1, (WPARAM)a2);
        break;
      case 0x9D3Au:
        (*(void (__thiscall **)(int, void *))(*(_DWORD *)(a1 + 28) + 16))(a1 + 28, a2);
        break;
      case 0x9D3Bu:
        sub_479C50(a1, (WPARAM)a2);
        break;
      case 0x9D3Du:
        sub_479660(a1, (WPARAM)a2);
        break;
      case 0x9D7Fu:
        v12 = *(HWND *)(a1 + 68);
        lParam[0] = 8;
        SendMessageW(v12, 0x133Cu, (WPARAM)a2, (LPARAM)lParam);
        v5 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v14 + 916) + 56))(*(_DWORD *)(a1 + 4 * v14 + 916));
        pv = 0;
        if ( sub_466430(v5, (LPITEMIDLIST *)&pv) >= 0 )
        {
          v6 = *(void (__thiscall **)(int, LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)(a1 + 28) + 40);
          v7 = a1 + 28;
          v8 = pv;
          v6(v7, pv, 0, 1, 1, 0);
          CoTaskMemFree(v8);
        }
        CoTaskMemFree(v5);
        break;
      case 0x9D81u:
        if ( a1 )
          v9 = a1 + 28;
        else
          v9 = 0;
        sub_485870((int)a2, *(_DWORD *)(a1 + 52), (int)v16, v9);
        sub_46C110((LPARAM)v16);
        sub_485710(v16);
        break;
      case 0x9DEDu:
        v10 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0) - 1;
        if ( v10 > (int)a2 )
        {
          do
            sub_479C50(a1, v10--);
          while ( v10 > (int)pv );
        }
        break;
      default:
        goto LABEL_23;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 0x9D37u:
        v11 = *(HWND *)(a1 + 68);
        lParam[0] = 8;
        SendMessageW(v11, 0x133Cu, (WPARAM)a2, (LPARAM)lParam);
        sub_479330(a1, v14);
        break;
      case 0x9CDAu:
        sub_47A090(a1, (int)a2);
        break;
      case 0x9CDFu:
        sub_478C40(a1);
        break;
      default:
LABEL_23:
        SendMessageW(*(HWND *)(a1 + 52), 0x111u, (unsigned __int16)a3 | ((unsigned __int16)a2 << 16), 0);
        break;
    }
  }
}
// 47A8C0: using guessed type _DWORD var_248[145];

//----- (0047AC20) --------------------------------------------------------
void __userpurge sub_47AC20(int a1@<esi>, unsigned int a2)
{
  void *v2; // edi
  unsigned int v3; // eax
  HMENU v4; // [esp-1Ch] [ebp-40h]
  struct tagPOINT v5; // [esp-14h] [ebp-38h]
  HWND v6; // [esp-8h] [ebp-2Ch]
  struct tagPOINT Point; // [esp+8h] [ebp-1Ch] BYREF
  LPARAM lParam[3]; // [esp+10h] [ebp-14h] BYREF

  Point.y = HIWORD(a2);
  lParam[1] = HIWORD(a2);
  Point.x = (unsigned __int16)a2;
  lParam[0] = (unsigned __int16)a2;
  v2 = (void *)SendMessageW(*(HWND *)(a1 + 68), 0x130Du, 0, (LPARAM)lParam);
  if ( lParam[2] != 1 )
  {
    ClientToScreen(*(HWND *)(a1 + 68), &Point);
    v6 = *(HWND *)(a1 + 68);
    v5 = Point;
    v4 = *(HMENU *)(a1 + 3468);
    *(_DWORD *)(a1 + 60636) = v2;
    v3 = TrackPopupMenu(v4, 0x142u, v5.x, v5.y, 0, v6, 0);
    sub_47A8C0(a1, v2, v3);
  }
}

//----- (0047ACC0) --------------------------------------------------------
int __fastcall sub_47ACC0(int a1, HWND a2, unsigned int a3, HMENU wParam, unsigned int lParam)
{
  HWND v5; // ebx
  DWORD MessagePos; // eax
  WPARAM v8; // eax
  HWND v10; // [esp-10h] [ebp-38h]
  struct tagPOINT Point; // [esp+10h] [ebp-18h] BYREF
  LPARAM v13[3]; // [esp+18h] [ebp-10h] BYREF

  v5 = a2;
  if ( a3 > 0x200 )
  {
    switch ( a3 )
    {
      case 0x201u:
        sub_478B00(a1, lParam);
        break;
      case 0x202u:
        sub_478AE0(a1);
        break;
      case 0x203u:
        MessagePos = GetMessagePos();
        Point.x = (__int16)MessagePos;
        Point.y = SHIWORD(MessagePos);
        ScreenToClient(v5, &Point);
        v13[1] = HIWORD(lParam);
        v10 = *(HWND *)(a1 + 68);
        v13[0] = (unsigned __int16)lParam;
        v8 = SendMessageW(v10, 0x130Du, 0, (LPARAM)v13);
        if ( v13[2] != 1 && *(_DWORD *)(a1 + 59400) )
        {
          sub_479C50(a1, v8);
          v5 = a2;
        }
        break;
      case 0x205u:
        sub_47AC20(a1, lParam);
        break;
      case 0x208u:
        SendMessageW(*(HWND *)(a1 + 52), 0x8035u, (WPARAM)wParam, lParam);
        break;
      case 0x215u:
        if ( (HWND)lParam != a2 )
          ReleaseCapture();
        *(_DWORD *)(a1 + 60616) = 0;
        break;
      default:
        return sub_401C60((int)v5, a3, (int)wParam, lParam);
    }
  }
  else if ( a3 == 512 )
  {
    if ( *(_DWORD *)(a1 + 60616) )
      sub_4789F0(lParam, a1);
  }
  else
  {
    switch ( a3 )
    {
      case 0x2Bu:
        SendMessageW(*(HWND *)(a1 + 52), 0x2Bu, (WPARAM)wParam, lParam);
        break;
      case 0x2Cu:
        SendMessageW(*(HWND *)(a1 + 52), 0x2Cu, (WPARAM)wParam, lParam);
        break;
      case 0x116u:
        sub_478B80(a1, wParam);
        SendMessageW(*(HWND *)(a1 + 52), 0x116u, (WPARAM)wParam, lParam);
        break;
      case 0x11Fu:
        SendMessageW(*(HWND *)(a1 + 52), 0x11Fu, (WPARAM)wParam, lParam);
        break;
      default:
        return sub_401C60((int)v5, a3, (int)wParam, lParam);
    }
  }
  return sub_401C60((int)v5, a3, (int)wParam, lParam);
}

//----- (0047AFE0) --------------------------------------------------------
int __stdcall sub_47AFE0(HWND a1, unsigned int a2, HMENU a3, unsigned int a4, int a5, int a6)
{
  return sub_47ACC0(a6, a1, a2, a3, a4);
}

//----- (0047B000) --------------------------------------------------------
HMODULE __thiscall sub_47B000(_DWORD *this, char *a2, int a3)
{
  HMODULE result; // eax
  bool v5; // cf
  HMODULE ModuleHandleW; // eax
  char *v7; // edi
  HRESULT (__stdcall *DwmSetWindowAttribute)(HWND, DWORD, LPCVOID, DWORD); // ebx
  int v9; // [esp-4h] [ebp-434h]
  _DWORD *v10; // [esp-4h] [ebp-434h]
  char *v11[3]; // [esp+10h] [ebp-420h] BYREF
  HMODULE v12; // [esp+1Ch] [ebp-414h]
  HMODULE hLibModule; // [esp+20h] [ebp-410h]
  int v14; // [esp+24h] [ebp-40Ch] BYREF
  WCHAR ClassName[514]; // [esp+28h] [ebp-408h] BYREF

  result = (HMODULE)this[1394];
  v14 = 1;
  v5 = (unsigned int)result < 6;
  if ( result == (HMODULE)6 )
  {
    if ( !this[1395] )
      return result;
    v5 = 0;
  }
  if ( !v5 )
  {
    if ( this[14858] )
    {
      v9 = dword_4EF818++;
      sub_401000(0x200u, ClassName, L"Explorer++TabProxy%d", v9);
      result = (HMODULE)(unsigned __int16)sub_47A860((DWORD)ClassName);
      v12 = result;
      if ( (_WORD)result )
      {
        v10 = malloc(8u);
        *v10 = this;
        v10[1] = a2;
        ModuleHandleW = GetModuleHandleW(0);
        result = (HMODULE)sub_418180(ClassName, &word_4C6388, 0xCF0000u, 0, 0, 0, 0, 0, ModuleHandleW, v10);
        v7 = (char *)result;
        if ( result )
        {
          result = sub_40A920(L"dwmapi.dll");
          hLibModule = result;
          if ( result )
          {
            DwmSetWindowAttribute = (HRESULT (__stdcall *)(HWND, DWORD, LPCVOID, DWORD))GetProcAddress(
                                                                                          result,
                                                                                          "DwmSetWindowAttribute");
            if ( DwmSetWindowAttribute )
            {
              DwmSetWindowAttribute((HWND)v7, 7, &v14, 4);
              DwmSetWindowAttribute((HWND)v7, 10, &v14, 4);
              if ( this[14886] )
                sub_478CB0((int)v7, (int)this, (int)&unk_4C63BC, a3);
              v11[1] = v7;
              v11[2] = a2;
              LOWORD(v11[0]) = (_WORD)v12;
              sub_415830((int)(this + 14882), v11);
            }
            return (HMODULE)FreeLibrary(hLibModule);
          }
        }
      }
    }
  }
  return result;
}
// 4C635C: using guessed type wchar_t aExplorerTabpro[21];
// 4EF818: using guessed type int dword_4EF818;

//----- (0047B180) --------------------------------------------------------
int __fastcall sub_47B180(int *a1, int a2, const ITEMIDLIST *a3, int *a4, const void *a5, int a6)
{
  WPARAM v7; // eax
  int v8; // eax
  _DWORD *i; // ecx
  int v11; // eax
  HWND v12; // eax
  int v13; // esi
  int *v14; // eax
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  _DWORD *v22; // ecx
  _DWORD *v23; // eax
  int v24; // ecx
  char *v25; // eax
  int v26; // edx
  __int16 v27; // cx
  _DWORD *v28; // eax
  _DWORD *v29; // edi
  int v30; // edx
  WPARAM v31; // eax
  int *v32; // [esp+2Ch] [ebp-4E8h]
  _DWORD *v33; // [esp+2Ch] [ebp-4E8h]
  WPARAM wParam; // [esp+30h] [ebp-4E4h] BYREF
  int v35; // [esp+34h] [ebp-4E0h]
  const ITEMIDLIST *v36; // [esp+38h] [ebp-4DCh]
  _DWORD *v37; // [esp+3Ch] [ebp-4D8h]
  int *v38; // [esp+40h] [ebp-4D4h]
  const ITEMIDLIST *v39; // [esp+44h] [ebp-4D0h]
  char v40[92]; // [esp+48h] [ebp-4CCh] BYREF
  int v41[15]; // [esp+A4h] [ebp-470h] BYREF
  char v42[1024]; // [esp+E0h] [ebp-434h] BYREF
  int v43; // [esp+4E0h] [ebp-34h]
  int v44; // [esp+4E4h] [ebp-30h]
  int v45; // [esp+4E8h] [ebp-2Ch]
  int v46; // [esp+4ECh] [ebp-28h]
  int v47; // [esp+4F0h] [ebp-24h]
  int v48; // [esp+4F4h] [ebp-20h]
  int v49; // [esp+4F8h] [ebp-1Ch]
  int v50; // [esp+510h] [ebp-4h]

  v38 = a1;
  v36 = a3;
  v32 = a4;
  if ( !sub_467A90(a3) )
    return -2147467259;
  wParam = 0x20000000;
  sub_4665C0(a3, (int)&wParam);
  if ( (wParam & 0x20000000) == 0 )
    return -2147467259;
  v7 = *(_DWORD *)(a2 + 59344) ? *(_DWORD *)(a2 + 5632) + 1 : SendMessageW(*(HWND *)(a2 + 68), 0x1304u, 0, 0);
  wParam = v7;
  v8 = 0;
  for ( i = (_DWORD *)(a2 + 58872); *i; ++i )
  {
    if ( ++v8 >= 100 )
      return -2147467259;
  }
  v35 = v8;
  *(_DWORD *)(a2 + 4 * v8 + 58872) = 1;
  if ( v8 == -1 )
    return -2147467259;
  v11 = 532 * v8;
  if ( a5 )
  {
    qmemcpy((void *)(v11 + a2 + 5672), a5, 0x214u);
  }
  else
  {
    *(_DWORD *)(v11 + a2 + 5672) = 0;
    *(_DWORD *)(v11 + a2 + 5676) = 0;
    *(_DWORD *)(v11 + a2 + 5680) = 0;
  }
  v12 = sub_49BC80(a2, *(HWND *)(a2 + 52));
  v13 = v35;
  *(_DWORD *)(a2 + 4 * v35 + 92) = v12;
  if ( !v12 )
    return -2147467259;
  sub_468000(v12, *(_DWORD *)(a2 + 59384), *(_DWORD *)(a2 + 59388));
  sub_474F60(a2, *(HWND *)(a2 + 4 * v13 + 92));
  v14 = a4;
  if ( !a4 )
  {
    v15 = *(_DWORD *)(a2 + 59488);
    v16 = *(_DWORD *)(a2 + 59480);
    v41[6] = *(_DWORD *)(a2 + 59504);
    v17 = *(_DWORD *)(a2 + 59496);
    v41[3] = v15;
    v18 = *(_DWORD *)(a2 + 59332);
    v41[2] = v17;
    v19 = *(_DWORD *)(a2 + 59336);
    v41[9] = v18;
    v20 = *(_DWORD *)(a2 + 59512);
    v41[4] = v16;
    v21 = *(_DWORD *)(a2 + 59492);
    v41[10] = v19;
    v22 = *(_DWORD **)(a2 + 59272);
    v41[12] = v20;
    v23 = (_DWORD *)*v22;
    v41[5] = v21;
    v41[11] = *(_DWORD *)(a2 + 59508);
    v37 = v22;
    v33 = v23;
    if ( v23 != v22 )
    {
      while ( 1 )
      {
        v39 = (const ITEMIDLIST *)v23[2];
        sub_415CD0(v23 + 3, (int)v40);
        v50 = 0;
        sub_466190(v36, v39);
        v50 = -1;
        sub_40A700((int)v40);
        v33 = (_DWORD *)*v33;
        if ( v33 == v37 )
          break;
        v23 = v33;
      }
      v13 = v35;
    }
    v24 = *(_DWORD *)(a2 + 59476);
    v41[7] = 0;
    v41[8] = 0;
    v25 = v42;
    v41[1] = v24;
    v41[0] = 1;
    v26 = 512;
    while ( v26 != -2147483134 )
    {
      v27 = *(_WORD *)&v25[&unk_4C6358 - (_UNKNOWN *)v42];
      if ( !v27 )
        break;
      *(_WORD *)v25 = v27;
      v25 += 2;
      if ( !--v26 )
      {
        v25 -= 2;
        break;
      }
    }
    *(_WORD *)v25 = 0;
    v45 = a2 + 60496;
    v44 = a2 + 60484;
    v48 = a2 + 60532;
    v49 = a2 + 60544;
    v47 = a2 + 60520;
    v46 = a2 + 60508;
    v43 = a2 + 60472;
    v32 = v41;
    v14 = v41;
  }
  v14[13] = *(_DWORD *)(a2 + 59420);
  v14[14] = *(_DWORD *)(a2 + 59456);
  sub_45DFE0(
    (int *)(a2 + 4 * v13 + 516),
    *(_DWORD *)(a2 + 52),
    *(_DWORD *)(a2 + 4 * v13 + 92),
    (int)v14,
    *(_DWORD *)(a2 + 3420),
    *(_DWORD *)(a2 + 3428));
  if ( v32[7] )
    sub_469B90(104, *(HWND *)(a2 + 4 * v13 + 92));
  v28 = malloc(8u);
  *v28 = a2;
  v28[1] = v13;
  SetWindowLongW(*(HWND *)(a2 + 4 * v13 + 92), -21, (LONG)v28);
  lpPrevWndFunc = (WNDPROC)SetWindowLongW(*(HWND *)(a2 + 4 * v13 + 92), -4, (LONG)sub_49F510);
  v29 = (_DWORD *)(a2 + 4 * v13 + 916);
  (***(void (__stdcall ****)(_DWORD, _DWORD *, _DWORD *))(a2 + 4 * v13 + 516))(
    *(_DWORD *)(a2 + 4 * v13 + 516),
    dword_4BD7CC,
    v29);
  (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a2 + 4 * v13 + 516) + 48))(*(_DWORD *)(a2 + 4 * v13 + 516), v13);
  (*(void (__thiscall **)(_DWORD, HINSTANCE))(**(_DWORD **)(a2 + 4 * v13 + 516) + 56))(
    *(_DWORD *)(a2 + 4 * v13 + 516),
    hInstance);
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 340))(*v29, *(_DWORD *)(a2 + 59508));
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 348))(*v29, *(_DWORD *)(a2 + 59484));
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 356))(*v29, *(_DWORD *)(a2 + 59512));
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 364))(*v29, *(_DWORD *)(a2 + 59332));
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 376))(*v29, *(_DWORD *)(a2 + 59500));
  (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v29 + 384))(*v29, *(_DWORD *)(a2 + 59408));
  sub_4797C0(a2, v36, wParam, v13);
  if ( a6 )
  {
    SendMessageW(*(HWND *)(a2 + 68), 0x130Cu, wParam, 0);
    ShowWindow(*(HWND *)(a2 + 3432), 0);
    ShowWindow(*(HWND *)(a2 + 4 * v13 + 92), 5);
    v31 = wParam;
    *(_DWORD *)(a2 + 5620) = v13;
    *(_DWORD *)(a2 + 5632) = v31;
    *(_DWORD *)(a2 + 3432) = *(_DWORD *)(a2 + 4 * v13 + 92);
    *(_DWORD *)(a2 + 1320) = *v29;
    SetFocus(*(HWND *)(a2 + 4 * v13 + 92));
  }
  sub_494470(v13, v30, (_DWORD *)a2);
  v37 = (_DWORD *)(*(int (__thiscall **)(_DWORD, const ITEMIDLIST *, _DWORD))(*(_DWORD *)*v29 + 12))(*v29, v36, 0);
  if ( a6 )
    (*(void (__thiscall **)(_DWORD, int, int))(*(_DWORD *)*v29 + 52))(*v29, 260, a2 + 3492);
  if ( v37 )
    return -2147467259;
  if ( v38 )
    *v38 = v13;
  sub_47B000((_DWORD *)a2, (char *)v13, a6);
  return 0;
}
// 47B435: conditional instruction was optimized away because edx.4!=0
// 47B654: variable 'v30' is possibly undefined
// 4BD7CC: using guessed type _DWORD dword_4BD7CC[4];

//----- (0047B6C0) --------------------------------------------------------
int __fastcall sub_47B6C0(int a1, const WCHAR *a2, int *a3, const void *a4)
{
  WCHAR *v6; // eax
  int v7; // edx
  int v8; // edi
  WCHAR v9; // cx
  int v11; // esi
  LPVOID pv; // [esp+14h] [ebp-214h] BYREF
  WCHAR Dest[262]; // [esp+18h] [ebp-210h] BYREF

  pv = 0;
  if ( !sub_466280(a2, Dest) )
  {
    v6 = Dest;
    v7 = 260;
    v8 = (char *)a2 - (char *)Dest;
    while ( v7 != -2147483386 )
    {
      v9 = *(WCHAR *)((char *)v6 + v8);
      if ( !v9 )
        break;
      *v6++ = v9;
      if ( !--v7 )
      {
        --v6;
        break;
      }
    }
    *v6 = 0;
  }
  if ( sub_467810((LPITEMIDLIST *)&pv, (int)Dest) < 0 )
    return -2147467259;
  v11 = sub_47B180(0, a1, (const ITEMIDLIST *)pv, a3, a4, 1);
  CoTaskMemFree(pv);
  return v11;
}
// 47B730: conditional instruction was optimized away because edx.4!=0

//----- (0047B7B0) --------------------------------------------------------
HWND __usercall sub_47B7B0@<eax>(DWORD a1@<esi>)
{
  HMODULE ModuleHandleW; // eax
  HWND v2; // eax
  int v3; // edi
  HWND result; // eax
  WCHAR Buffer[66]; // [esp+8h] [ebp-88h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  v2 = sub_418180(L"Static", &word_4C6450, 0x54000100u, 0, 0, 0, 0, *(HWND *)(a1 + 52), ModuleHandleW, 0);
  *(_DWORD *)(a1 + 496) = v2;
  sub_409750((int)v2, (int)sub_4B5000, 0, a1);
  if ( *(_DWORD *)(a1 + 59396) )
    dwStyle |= 0x400u;
  *(_DWORD *)(a1 + 68) = sub_4654C0(*(HWND *)(a1 + 496));
  v3 = sub_4018B0(16, 16, 33, 0, 0x64u);
  sub_479920(v3);
  SendMessageW(*(HWND *)(a1 + 68), 0x1303u, 0, v3);
  if ( CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)(a1 + 60652)) >= 0
    && (***(int (__stdcall ****)(_DWORD, void *, DWORD))(a1 + 60652))(*(_DWORD *)(a1 + 60652), &unk_4BD88C, a1 + 60656) >= 0 )
  {
    RegisterDragDrop(*(HWND *)(a1 + 68), (LPDROPTARGET)a1);
  }
  sub_409750(*(_DWORD *)(a1 + 68), (int)sub_47AFE0, 0, a1);
  LoadStringW(hInstance, 0x2019u, Buffer, 64);
  result = sub_475BD0(*(HWND *)(a1 + 496), 5033, (int)Buffer);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (0047B8F0) --------------------------------------------------------
int __stdcall sub_47B8F0(int a1)
{
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 60656) + 16))(*(_DWORD *)(a1 + 60656));
  return 0;
}

//----- (0047B910) --------------------------------------------------------
void __stdcall TimerFunc(HWND a1, UINT a2, UINT_PTR a3, DWORD a4)
{
  dword_4EF3D4 = 1;
}
// 4EF3D4: using guessed type int dword_4EF3D4;

//----- (0047B980) --------------------------------------------------------
void __userpurge sub_47B980(int a1@<eax>, int a2)
{
  int (__stdcall *v2)(int, __int16 *, STGMEDIUM *); // edx
  HDROP v3; // eax
  HDROP v4; // esi
  __int16 v5; // [esp+0h] [ebp-20h] BYREF
  int v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]
  STGMEDIUM v10; // [esp+14h] [ebp-Ch] BYREF

  v2 = *(int (__stdcall **)(int, __int16 *, STGMEDIUM *))(*(_DWORD *)a1 + 12);
  v5 = 15;
  v6 = 0;
  v7 = 1;
  v8 = -1;
  v9 = 1;
  if ( !v2(a1, &v5, &v10) )
  {
    v3 = (HDROP)GlobalLock(v10.hBitmap);
    v4 = v3;
    if ( v3 )
    {
      if ( (int)DragQueryFileW(v3, 0xFFFFFFFF, 0, 0) >= 1 )
        DragQueryFileW(v4, 0, (LPWSTR)(a2 + 60660), 0x104u);
      GlobalUnlock(v10.hBitmap);
    }
    ReleaseStgMedium(&v10);
  }
}

//----- (0047BA20) --------------------------------------------------------
int __stdcall sub_47BA20(int a1, int a2, char a3, LONG a4, LONG a5, _DWORD *a6)
{
  int v6; // edx
  _DWORD *v7; // eax
  _DWORD *v8; // ebx
  _DWORD *v9; // edi
  int v10; // ecx
  LONG v11; // edx
  LONG v12; // eax
  int v13; // ecx
  _DWORD *v14; // eax
  int v15; // eax
  WPARAM v16; // eax
  BOOL IsSameRootW; // eax
  int v18; // ecx
  char v19; // dl
  _DWORD *v20; // eax
  _DWORD *v21; // esi
  HWND v23; // [esp-10h] [ebp-28Ch]
  HWND v24; // [esp-8h] [ebp-284h]
  int lParam[6]; // [esp+10h] [ebp-26Ch] BYREF
  int v26; // [esp+28h] [ebp-254h]
  int pExceptionObject[3]; // [esp+2Ch] [ebp-250h] BYREF
  void *v28[3]; // [esp+38h] [ebp-244h] BYREF
  char *v29; // [esp+44h] [ebp-238h] BYREF
  int v30; // [esp+48h] [ebp-234h]
  _DWORD *v31; // [esp+4Ch] [ebp-230h]
  int v32[2]; // [esp+50h] [ebp-22Ch] BYREF
  struct tagPOINT Point; // [esp+58h] [ebp-224h] BYREF
  int v34; // [esp+60h] [ebp-21Ch]
  WCHAR pszPath1[260]; // [esp+64h] [ebp-218h] BYREF
  int v36; // [esp+278h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 5632);
  v30 = a2;
  v31 = a6;
  *(_DWORD *)(a1 + 61188) = v6;
  dword_4EF3D4 = 0;
  v28[1] = 0;
  v7 = operator new(0x1Cu);
  if ( !v7 )
  {
    v29 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v29);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v7 = v7;
  v28[0] = v7;
  v7[1] = v7;
  v36 = 0;
  sub_45F8F0((int)v28);
  v8 = v28[0];
  v9 = *(_DWORD **)v28[0];
  if ( *(void **)v28[0] == v28[0] )
  {
LABEL_5:
    v14 = v31;
    *(_DWORD *)(a1 + 61184) = 0;
    *v14 = 0;
  }
  else
  {
    while ( 1 )
    {
      v10 = v9[3];
      v11 = v9[4];
      v32[0] = v9[2];
      v12 = v9[5];
      v32[1] = v10;
      v13 = v9[6];
      Point.y = v12;
      v34 = v13;
      Point.x = v11;
      if ( !(*(int (__stdcall **)(int, int *))(*(_DWORD *)v30 + 20))(v30, v32) )
        break;
      v9 = (_DWORD *)*v9;
      if ( v9 == v8 )
        goto LABEL_5;
    }
    v15 = v30;
    *(_DWORD *)(a1 + 61184) = 1;
    sub_47B980(v15, a1);
    Point.x = a4;
    v24 = *(HWND *)(a1 + 68);
    Point.y = a5;
    ScreenToClient(v24, &Point);
    v16 = SendMessageW(*(HWND *)(a1 + 68), 0x130Du, 0, (LPARAM)&Point);
    if ( v16 == -1 )
    {
      *v31 = 0;
    }
    else
    {
      v23 = *(HWND *)(a1 + 68);
      lParam[0] = 8;
      SendMessageW(v23, 0x133Cu, v16, (LPARAM)lParam);
      (*(void (__thiscall **)(_DWORD, int, WCHAR *))(**(_DWORD **)(a1 + 4 * v26 + 916) + 52))(
        *(_DWORD *)(a1 + 4 * v26 + 916),
        260,
        pszPath1);
      IsSameRootW = PathIsSameRootW(pszPath1, (LPCWSTR)(a1 + 60660));
      v18 = *v31;
      if ( *(_DWORD *)(a1 + 61184) )
      {
        if ( ((a3 & 8) != 0 && (v19 = a3, (a3 & 4) != 0) || (v19 = a3, (a3 & 0x20) != 0)) && (v18 & 4) != 0 )
        {
          *v31 = 4;
        }
        else if ( (v19 & 4) != 0 && (v18 & 2) != 0 )
        {
          *v31 = 2;
        }
        else if ( (a3 & 8) == 8 && (v18 & 1) != 0 )
        {
          *v31 = 1;
        }
        else if ( IsSameRootW && (v18 & 2) != 0 )
        {
          *v31 = 2;
        }
        else if ( (v18 & 1) != 0 )
        {
          *v31 = 1;
        }
        else if ( (v18 & 2) != 0 )
        {
          *v31 = 2;
        }
        else
        {
          *v31 &= 4u;
        }
      }
      else
      {
        *v31 = 0;
      }
    }
  }
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)(a1 + 61180) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *(_DWORD *)(a1 + 61180) = 1;
  }
  (*(void (__stdcall **)(_DWORD, _DWORD, int, LONG *, _DWORD))(**(_DWORD **)(a1 + 60656) + 12))(
    *(_DWORD *)(a1 + 60656),
    *(_DWORD *)(a1 + 68),
    v30,
    &a4,
    *v31);
  v20 = (_DWORD *)*v8;
  *v8 = v8;
  v8[1] = v8;
  if ( v20 != v8 )
  {
    do
    {
      v21 = (_DWORD *)*v20;
      operator delete(v20);
      v20 = v21;
    }
    while ( v21 != v8 );
  }
  operator delete(v8);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4EF3D4: using guessed type int dword_4EF3D4;
// 47BA20: using guessed type LPARAM lParam[6];

//----- (0047BD80) --------------------------------------------------------
int __stdcall sub_47BD80(int a1, int *a2, int a3, LONG a4, LONG a5, _DWORD *a6)
{
  WPARAM v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  HWND v10; // [esp-4h] [ebp-258h]
  HWND v11; // [esp+4h] [ebp-250h]
  _DWORD *v12; // [esp+18h] [ebp-23Ch]
  int lParam[6]; // [esp+1Ch] [ebp-238h] BYREF
  int v14; // [esp+34h] [ebp-220h]
  struct tagPOINT Point; // [esp+38h] [ebp-21Ch] BYREF
  char v16[524]; // [esp+44h] [ebp-210h] BYREF

  v12 = a6;
  (*(void (__stdcall **)(_DWORD, int *, LONG *, _DWORD))(**(_DWORD **)(a1 + 60656) + 24))(
    *(_DWORD *)(a1 + 60656),
    a2,
    &a4,
    *a6);
  Point.x = a4;
  v11 = *(HWND *)(a1 + 68);
  Point.y = a5;
  ScreenToClient(v11, &Point);
  v6 = SendMessageW(*(HWND *)(a1 + 68), 0x130Du, 0, (LPARAM)&Point);
  if ( v6 != -1 )
  {
    v10 = *(HWND *)(a1 + 68);
    lParam[0] = 8;
    SendMessageW(v10, 0x133Cu, v6, (LPARAM)lParam);
    (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a1 + 4 * v14 + 916) + 52))(
      *(_DWORD *)(a1 + 4 * v14 + 916),
      260,
      v16);
    if ( *(_DWORD *)(a1 + 61184) )
    {
      v7 = operator new(0x30u);
      if ( v7 )
      {
        v7[1] = 1;
        *v7 = &CDropHandler::`vftable';
        v8 = v7;
      }
      else
      {
        v8 = 0;
      }
      sub_461A40(a3, *(_DWORD *)(a1 + 61180), a2, v8, v12, *(_DWORD *)(a1 + 68), (int)v16, 0, a4, a5);
      if ( !InterlockedDecrement(v8 + 1) && v8 )
        (*(void (__thiscall **)(_DWORD *, int))*v8)(v8, 1);
    }
  }
  return 0;
}
// 4CC480: using guessed type void *CDropHandler::`vftable';
// 47BD80: using guessed type LPARAM lParam[6];

//----- (0047BEC0) --------------------------------------------------------
int __stdcall sub_47BEC0(int a1, char a2, LONG a3, LONG a4, int *a5)
{
  WPARAM v5; // edi
  int IsSameRootW; // eax
  int v7; // eax
  HWND v9; // [esp-10h] [ebp-254h]
  HWND v10; // [esp-10h] [ebp-254h]
  HWND v11; // [esp-8h] [ebp-24Ch]
  int lParam[6]; // [esp+Ch] [ebp-238h] BYREF
  int v13; // [esp+24h] [ebp-220h]
  int *v14; // [esp+28h] [ebp-21Ch]
  struct tagPOINT Point; // [esp+2Ch] [ebp-218h] BYREF
  WCHAR pszPath1[260]; // [esp+38h] [ebp-20Ch] BYREF

  v14 = a5;
  Point.x = a3;
  v11 = *(HWND *)(a1 + 68);
  Point.y = a4;
  ScreenToClient(v11, &Point);
  v5 = SendMessageW(*(HWND *)(a1 + 68), 0x130Du, 0, (LPARAM)&Point);
  if ( v5 == -1 )
    goto LABEL_10;
  v9 = *(HWND *)(a1 + 68);
  lParam[0] = 8;
  SendMessageW(v9, 0x133Cu, v5, (LPARAM)lParam);
  if ( v5 == *(_DWORD *)(a1 + 5632) )
  {
    KillTimer(*(HWND *)(a1 + 68), 0);
    goto LABEL_8;
  }
  if ( v5 != *(_DWORD *)(a1 + 61188) )
  {
    SetTimer(*(HWND *)(a1 + 68), 0, 0x1F4u, TimerFunc);
LABEL_8:
    *(_DWORD *)(a1 + 61188) = v5;
    goto LABEL_9;
  }
  if ( dword_4EF3D4 )
  {
    v10 = *(HWND *)(a1 + 68);
    *(_DWORD *)(a1 + 5632) = v5;
    SendMessageW(v10, 0x130Cu, v5, 0);
    sub_479A30(a1, 1);
    dword_4EF3D4 = 0;
  }
LABEL_9:
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v13 + 916) + 144))(*(_DWORD *)(a1 + 4 * v13 + 916)) )
  {
LABEL_10:
    *v14 = 0;
    goto LABEL_15;
  }
  (*(void (__thiscall **)(_DWORD, int, WCHAR *))(**(_DWORD **)(a1 + 4 * v13 + 916) + 52))(
    *(_DWORD *)(a1 + 4 * v13 + 916),
    260,
    pszPath1);
  IsSameRootW = PathIsSameRootW(pszPath1, (LPCWSTR)(a1 + 60660));
  if ( *(_DWORD *)(a1 + 61184) )
    v7 = sub_466220(a2, *v14, IsSameRootW);
  else
    v7 = 0;
  *v14 = v7;
LABEL_15:
  (*(void (__stdcall **)(_DWORD, LONG *, int))(**(_DWORD **)(a1 + 60656) + 20))(*(_DWORD *)(a1 + 60656), &a3, *v14);
  return 0;
}
// 4EF3D4: using guessed type int dword_4EF3D4;
// 47BEC0: using guessed type LPARAM lParam[6];

//----- (0047C090) --------------------------------------------------------
BOOL __usercall sub_47C090@<eax>(int a1@<esi>)
{
  int v1; // edi
  WPARAM v2; // eax
  HWND v4; // [esp-10h] [ebp-94h]
  WCHAR Buffer[64]; // [esp+0h] [ebp-84h] BYREF

  if ( *(_BYTE *)(a1 + 77) )
    LoadStringW(*(HINSTANCE *)(a1 + 8), 0xF8u, Buffer, 64);
  else
    LoadStringW(*(HINSTANCE *)(a1 + 8), 0xF7u, Buffer, 64);
  SetDlgItemTextW(*(HWND *)(a1 + 4), 1309, Buffer);
  v1 = *(_DWORD *)(a1 + 124);
  if ( !InterlockedDecrement((volatile LONG *)(v1 + 4)) && v1 )
    (**(void (__thiscall ***)(int, int))v1)(v1, 1);
  v4 = *(HWND *)(a1 + 4);
  *(_DWORD *)(a1 + 124) = 0;
  *(_WORD *)(a1 + 76) = 0;
  KillTimer(v4, 1u);
  v2 = SendDlgItemMessageW(*(HWND *)(a1 + 4), 1143, 0x407u, 0, 0);
  SendDlgItemMessageW(*(HWND *)(a1 + 4), 1143, 0x402u, v2, 0);
  return SetDlgItemTextW(*(HWND *)(a1 + 4), 1, (LPCWSTR)(a1 + 132));
}

//----- (0047C1A0) --------------------------------------------------------
LRESULT __thiscall sub_47C1A0(int this, int a2, LPARAM lParam, int a4)
{
  LRESULT result; // eax
  int v6; // edi
  HWND v7; // [esp-10h] [ebp-118h]
  WCHAR Buffer[128]; // [esp+4h] [ebp-104h] BYREF

  result = a2 - 32769;
  switch ( a2 )
  {
    case 32769:
      result = SendDlgItemMessageW(*(HWND *)(this + 4), 1143, 0x406u, 0, lParam);
      break;
    case 32770:
      result = SendDlgItemMessageW(*(HWND *)(this + 4), 1143, 0x402u, lParam, 0);
      break;
    case 32771:
      result = sub_47C090(this);
      break;
    case 32772:
      LoadStringW(*(HINSTANCE *)(this + 8), 0xF9u, Buffer, 128);
      SetDlgItemTextW(*(HWND *)(this + 4), 1309, Buffer);
      v6 = *(_DWORD *)(this + 124);
      if ( !InterlockedDecrement((volatile LONG *)(v6 + 4)) )
      {
        if ( v6 )
          (**(void (__thiscall ***)(int, int))v6)(v6, 1);
      }
      v7 = *(HWND *)(this + 4);
      *(_DWORD *)(this + 124) = 0;
      *(_WORD *)(this + 76) = 0;
      KillTimer(v7, 1u);
      result = SetDlgItemTextW(*(HWND *)(this + 4), 1, (LPCWSTR)(this + 132));
      break;
    default:
      return result;
  }
  return result;
}

//----- (0047C2E0) --------------------------------------------------------
int __thiscall sub_47C2E0(HGDIOBJ *this)
{
  DeleteObject(this[32]);
  return 0;
}

//----- (0047C2F0) --------------------------------------------------------
int __thiscall sub_47C2F0(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (0047C300) --------------------------------------------------------
HGDIOBJ __thiscall sub_47C300(HWND *this, int a2, HDC hdc)
{
  if ( (HWND)a2 != GetDlgItem(this[1], 1298) )
    return 0;
  SetTextColor(hdc, 0x787878u);
  SetBkMode(hdc, 1);
  return GetStockObject(5);
}

//----- (0047C350) --------------------------------------------------------
HRESULT __thiscall sub_47C350(OLECHAR *this, int a2, int a3)
{
  OLECHAR *v4; // eax
  OLECHAR *v5; // eax

  v4 = this + 270;
  if ( *((_DWORD *)this + 140) >= 8u )
    v4 = *(OLECHAR **)v4;
  sub_464A60(a2, a3, (OLECHAR *)L"Size", v4);
  v5 = this + 284;
  if ( *((_DWORD *)this + 147) >= 8u )
    v5 = *(OLECHAR **)v5;
  return sub_464A60(a2, a3, (OLECHAR *)L"SizeGroup", v5);
}

//----- (0047C3B0) --------------------------------------------------------
LSTATUS __thiscall sub_47C3B0(const WCHAR *this, HKEY hKey)
{
  const WCHAR *v2; // esi
  int v3; // eax
  const WCHAR *v4; // esi
  int v5; // eax

  v2 = this + 270;
  if ( *((_DWORD *)this + 140) >= 8u )
    v2 = *(const WCHAR **)v2;
  v3 = lstrlenW(v2);
  RegSetValueExW(hKey, L"Size", 0, 1u, (const BYTE *)v2, 2 * v3);
  if ( *((_DWORD *)this + 147) < 8u )
    v4 = this + 284;
  else
    v4 = (const WCHAR *)*((_DWORD *)this + 142);
  v5 = lstrlenW(v4);
  return RegSetValueExW(hKey, L"SizeGroup", 0, 1u, (const BYTE *)v4, 2 * v5);
}

//----- (0047C430) --------------------------------------------------------
int __usercall sub_47C430@<eax>(int a1@<esi>)
{
  int result; // eax

  *(_DWORD *)a1 = &CSplitFileDialogPersistentSettings::`vftable';
  if ( *(_DWORD *)(a1 + 588) >= 8u )
    operator delete(*(void **)(a1 + 568));
  *(_DWORD *)(a1 + 588) = 7;
  *(_DWORD *)(a1 + 584) = 0;
  *(_WORD *)(a1 + 568) = 0;
  if ( *(_DWORD *)(a1 + 560) >= 8u )
    operator delete(*(void **)(a1 + 540));
  *(_DWORD *)(a1 + 560) = 7;
  *(_DWORD *)(a1 + 556) = 0;
  result = 0;
  *(_WORD *)(a1 + 540) = 0;
  *(_DWORD *)a1 = &CDialogSettings::`vftable';
  return result;
}
// 4CC29C: using guessed type void *CSplitFileDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (0047C4B0) --------------------------------------------------------
int __usercall sub_47C4B0@<eax>(int a1@<esi>)
{
  int result; // eax

  *(_DWORD *)a1 = &CSplitFile::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 100));
  if ( *(_DWORD *)(a1 + 88) >= 8u )
    operator delete(*(void **)(a1 + 68));
  *(_DWORD *)(a1 + 88) = 7;
  *(_DWORD *)(a1 + 84) = 0;
  *(_WORD *)(a1 + 68) = 0;
  if ( *(_DWORD *)(a1 + 60) >= 8u )
    operator delete(*(void **)(a1 + 40));
  *(_DWORD *)(a1 + 60) = 7;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 32) >= 8u )
    operator delete(*(void **)(a1 + 12));
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 28) = 0;
  result = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_DWORD *)a1 = &CReferenceCount::`vftable';
  return result;
}
// 4CC2B4: using guessed type void *CSplitFile::`vftable';
// 4CC488: using guessed type void *CReferenceCount::`vftable';

//----- (0047C540) --------------------------------------------------------
int __thiscall sub_47C540(int this, int a2)
{
  WCHAR String[10]; // [esp+4h] [ebp-18h] BYREF

  if ( a2 == 1 )
  {
    ++*(_DWORD *)(this + 196);
    sub_401000(
      9u,
      String,
      L"%02d:%02d:%02d",
      *(_DWORD *)(this + 196) / 0xE10u,
      *(_DWORD *)(this + 196) / 0x3Cu % 0x3C,
      *(_DWORD *)(this + 196) % 0x3Cu);
    SetDlgItemTextW(*(HWND *)(this + 4), 1301, String);
  }
  return 0;
}
// 4C6C48: using guessed type wchar_t a02d02d02d[15];

//----- (0047C5D0) --------------------------------------------------------
void __stdcall sub_47C5D0(int a1)
{
  int v1; // esi
  int v2; // esi
  void *v3; // edi

  *(_DWORD *)a1 = &CSplitFileDialog::`vftable';
  v1 = *(_DWORD *)(a1 + 124);
  if ( v1 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 100));
    *(_BYTE *)(v1 + 124) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 100));
    v2 = *(_DWORD *)(a1 + 124);
    if ( !InterlockedDecrement((volatile LONG *)(v2 + 4)) )
    {
      if ( v2 )
        (**(void (__thiscall ***)(int, int))v2)(v2, 1);
    }
  }
  sub_4179C0(a1 + 80);
  if ( *(_DWORD *)(a1 + 68) >= 8u )
    operator delete(*(void **)(a1 + 48));
  *(_DWORD *)(a1 + 68) = 7;
  *(_DWORD *)(a1 + 64) = 0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)a1 = &CBaseDialog::`vftable';
  v3 = *(void **)(a1 + 44);
  if ( v3 )
  {
    sub_4AAAD0((int)v3);
    operator delete(v3);
  }
}
// 4CC264: using guessed type void *CSplitFileDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0047C6A0) --------------------------------------------------------
int __userpurge sub_47C6A0@<eax>(
        int a1@<esi>,
        int a2,
        void *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        void *a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        void *a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24)
{
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)a1 = &CSplitFile::`vftable';
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 28) = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 60) = 7;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 88) = 7;
  *(_DWORD *)(a1 + 84) = 0;
  *(_WORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  sub_4090E0(a1 + 12, &a3, 0, 0xFFFFFFFF);
  sub_4090E0(a1 + 40, &a10, 0, 0xFFFFFFFF);
  sub_4090E0(a1 + 68, &a17, 0, 0xFFFFFFFF);
  *(_DWORD *)(a1 + 96) = a24;
  *(_BYTE *)(a1 + 124) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 100));
  if ( (unsigned int)a8 >= 8 )
    operator delete(a3);
  a8 = 7;
  a7 = 0;
  LOWORD(a3) = 0;
  if ( (unsigned int)a15 >= 8 )
    operator delete(a10);
  a15 = 7;
  a14 = 0;
  LOWORD(a10) = 0;
  if ( (unsigned int)a22 >= 8 )
    operator delete(a17);
  return a1;
}
// 4CC2B4: using guessed type void *CSplitFile::`vftable';

//----- (0047C7C0) --------------------------------------------------------
void __thiscall sub_47C7C0(_DWORD *this, LPCWSTR lpString1, void *a3)
{
  const WCHAR *v4; // esi
  BSTR *v5; // eax
  BSTR v6; // edx
  void *v7; // esi
  BSTR *v8; // eax
  BSTR v9; // edx

  v4 = lpString1;
  if ( lstrcmpiW(lpString1, L"Size") )
  {
    if ( !lstrcmpiW(v4, L"SizeGroup") )
    {
      v8 = *sub_417E40((const OLECHAR *)a3, (BSTR **)&lpString1);
      if ( v8 )
        v9 = *v8;
      else
        v9 = 0;
      sub_4094F0(this + 142, (int)v9, v9, wcslen(v9));
      sub_417EE0((int *)&lpString1);
    }
  }
  else
  {
    v5 = *sub_417E40((const OLECHAR *)a3, (BSTR **)&a3);
    if ( v5 )
      v6 = *v5;
    else
      v6 = 0;
    sub_4094F0(this + 135, (int)v6, v6, wcslen(v6));
    if ( a3 )
    {
      v7 = a3;
      if ( !InterlockedDecrement((volatile LONG *)a3 + 2) )
      {
        if ( *(_DWORD *)v7 )
          SysFreeString(*(BSTR *)v7);
        if ( *((_DWORD *)v7 + 1) )
          operator delete[](*((void **)v7 + 1));
        operator delete(v7);
      }
    }
  }
}
// 47C861: conditional instruction was optimized away because esi.4!=0

//----- (0047C910) --------------------------------------------------------
LSTATUS __fastcall sub_47C910(int a1, int a2, HKEY hKey)
{
  _DWORD *v4; // edi
  LPCWSTR v6; // [esp+0h] [ebp-2Ch] BYREF
  int v7; // [esp+4h] [ebp-28h]
  int v8; // [esp+8h] [ebp-24h]
  int v9; // [esp+Ch] [ebp-20h]
  int v10; // [esp+10h] [ebp-1Ch]
  int v11; // [esp+14h] [ebp-18h]
  LPCWSTR *v12; // [esp+28h] [ebp-4h]

  v12 = &v6;
  v11 = 7;
  v10 = 0;
  v4 = (_DWORD *)(a1 + 540);
  LOWORD(v6) = 0;
  sub_4094F0(&v6, a2, L"Size", 4);
  sub_464420(v4, hKey, v6, v7, v8, v9, v10, v11);
  v11 = 7;
  v10 = 0;
  LOWORD(v6) = 0;
  sub_4094F0(&v6, 0, L"SizeGroup", 9);
  return sub_464420((_DWORD *)(a1 + 568), hKey, v6, v7, v8, v9, v10, v11);
}
// 4C6CA0: using guessed type wchar_t aSize_2[5];
// 4C6CAC: using guessed type wchar_t aSizegroup_2[10];

//----- (0047C990) --------------------------------------------------------
int *sub_47C990()
{
  int v0; // edx

  sub_4653E0((int)&dword_4F2230, (int)L"SplitFile");
  dword_4F2230 = (int)&CSplitFileDialogPersistentSettings::`vftable';
  dword_4F2460 = 7;
  dword_4F245C = 0;
  word_4F244C[0] = 0;
  dword_4F247C = 7;
  dword_4F2478 = 0;
  word_4F2468[0] = 0;
  sub_4094F0(word_4F244C, 0, L"10", 2);
  sub_4094F0(word_4F2468, v0, L"KB", 2);
  return &dword_4F2230;
}
// 47CA23: variable 'v0' is possibly undefined
// 4C6BC4: using guessed type wchar_t aSplitfile_0[10];
// 4C6C70: using guessed type wchar_t a10[3];
// 4C6C78: using guessed type wchar_t aKb_0[3];
// 4CC29C: using guessed type void *CSplitFileDialogPersistentSettings::`vftable';
// 4F2230: using guessed type int dword_4F2230;
// 4F244C: using guessed type __int16 word_4F244C[8];
// 4F245C: using guessed type int dword_4F245C;
// 4F2460: using guessed type int dword_4F2460;
// 4F2468: using guessed type __int16 word_4F2468[8];
// 4F2478: using guessed type int dword_4F2478;
// 4F247C: using guessed type int dword_4F247C;

//----- (0047CA40) --------------------------------------------------------
void __usercall sub_47CA40(int a1@<esi>)
{
  BOOL v1; // edi
  const WCHAR *v2; // eax
  void *v3[5]; // [esp+8h] [ebp-148h] BYREF
  unsigned int v4; // [esp+1Ch] [ebp-134h]
  LPCWSTR lpString[5]; // [esp+24h] [ebp-12Ch] BYREF
  unsigned int v6; // [esp+38h] [ebp-118h]
  WCHAR Buffer; // [esp+40h] [ebp-110h] BYREF
  __int16 v8; // [esp+42h] [ebp-10Eh] BYREF
  int v9; // [esp+14Ch] [ebp-4h]

  LoadStringW(*(HINSTANCE *)(a1 + 8), 0x851u, &Buffer, 128);
  v6 = 7;
  lpString[4] = 0;
  LOWORD(lpString[0]) = 0;
  v9 = 0;
  v4 = 7;
  LOWORD(v3[0]) = 0;
  v3[4] = 0;
  sub_4094F0(v3, (int)&v8, &Buffer, wcslen(&Buffer));
  LOBYTE(v9) = 1;
  v1 = sub_4AE0D0((int)v3, *(HWND *)(a1 + 4), lpString);
  if ( v4 >= 8 )
    operator delete(v3[0]);
  if ( v1 )
  {
    v2 = lpString[0];
    if ( v6 < 8 )
      v2 = (const WCHAR *)lpString;
    SetDlgItemTextW(*(HWND *)(a1 + 4), 1141, v2);
  }
  if ( v6 >= 8 )
    operator delete((void *)lpString[0]);
}

//----- (0047CB80) --------------------------------------------------------
int __thiscall sub_47CB80(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  HWND DlgItem; // eax
  HWND v9; // eax
  int result; // eax
  _DWORD *v11; // [esp-4h] [ebp-24h]
  _DWORD *v12; // [esp-4h] [ebp-24h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 204);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  v11 = (_DWORD *)(*(_DWORD *)(this + 204) + 540);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1139);
  sub_46AFA0(DlgItem, v11);
  v12 = (_DWORD *)(*(_DWORD *)(this + 204) + 568);
  v9 = GetDlgItem(*(HWND *)(this + 4), 1140);
  sub_46AFA0(v9, v12);
  *(_DWORD *)(*(_DWORD *)(this + 204) + 4) = 1;
  return result;
}

//----- (0047CC30) --------------------------------------------------------
int *sub_47CC30()
{
  if ( (dword_4F2484 & 1) == 0 )
  {
    dword_4F2484 |= 1u;
    sub_47C990();
    atexit(sub_4BCD40);
  }
  return &dword_4F2230;
}
// 4F2230: using guessed type int dword_4F2230;
// 4F2484: using guessed type int dword_4F2484;

//----- (0047CCA0) --------------------------------------------------------
void __userpurge sub_47CCA0(int a1@<ecx>, void *a2@<ebx>, int a3)
{
  _DWORD *v4; // esi
  int v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8[4]; // [esp+10h] [ebp-114h] BYREF
  int v9[20]; // [esp+20h] [ebp-104h] BYREF
  int v10[19]; // [esp+70h] [ebp-B4h] BYREF
  void *v11[7]; // [esp+BCh] [ebp-68h] BYREF
  void *v12[5]; // [esp+D8h] [ebp-4Ch] BYREF
  unsigned int v13; // [esp+ECh] [ebp-38h]
  void *v14[5]; // [esp+F4h] [ebp-30h] BYREF
  unsigned int v15; // [esp+108h] [ebp-1Ch]
  int v16; // [esp+120h] [ebp-4h]

  v13 = 7;
  v12[4] = 0;
  LOWORD(v12[0]) = 0;
  sub_4090E0((int)v12, (_DWORD *)(a1 + 40), 0, 0xFFFFFFFF);
  v16 = 0;
  sub_40BE70(v8);
  LOBYTE(v16) = 1;
  sub_40BB80(v9, a3);
  v4 = sub_40BFB0((int)v8, v14);
  LOBYTE(v16) = 2;
  v5 = sub_40C610((int *)v12, L"/N", 2u);
  sub_40C0F0(v5, v12, 2u, v4, 0, 0xFFFFFFFF);
  LOBYTE(v16) = 1;
  if ( v15 >= 8 )
    operator delete(v14[0]);
  v6 = sub_418090(v11, a1 + 68, (int)L"\\");
  LOBYTE(v16) = 3;
  v7 = sub_40DFD0(v12, v6, v14);
  LOBYTE(v16) = 4;
  sub_40AF70(a2, v7);
  if ( v15 >= 8 )
    operator delete(v14[0]);
  v15 = 7;
  v14[4] = 0;
  LOWORD(v14[0]) = 0;
  if ( v11[5] >= (void *)8 )
    operator delete(v11[0]);
  LOBYTE(v16) = 0;
  sub_40BF20(v10);
  v10[0] = (int)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v10);
  if ( v13 >= 8 )
    operator delete(v12[0]);
}
// 4C6C18: using guessed type wchar_t aN[3];
// 4C6C6C: using guessed type wchar_t asc_4C6C6C[2];
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 47CCA0: using guessed type _DWORD var_114[4];
// 47CCA0: using guessed type int var_104[20];

//----- (0047CE20) --------------------------------------------------------
void __userpurge sub_47CE20(int a1@<esi>, void *a2, _QWORD *a3)
{
  WPARAM v3; // edi
  const WCHAR *v4; // eax
  HANDLE FileW; // ebx
  unsigned int v6; // [esp-4h] [ebp-5Ch]
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-48h] BYREF
  HANDLE hFile; // [esp+14h] [ebp-44h]
  DWORD NumberOfBytesRead; // [esp+18h] [ebp-40h] BYREF
  LPVOID lpBuffer; // [esp+1Ch] [ebp-3Ch]
  __int64 v11; // [esp+20h] [ebp-38h]
  char v12; // [esp+2Bh] [ebp-2Dh]
  LPCWSTR lpFileName[5]; // [esp+2Ch] [ebp-2Ch] BYREF
  unsigned int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+54h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 96);
  hFile = a2;
  v11 = 0i64;
  lpBuffer = operator new[](v6);
  v12 = 0;
  v3 = 1;
  while ( v11 < *a3 )
  {
    if ( v12 )
      break;
    ReadFile(hFile, lpBuffer, *(_DWORD *)(a1 + 96), &NumberOfBytesRead, 0);
    v14 = 7;
    lpFileName[4] = 0;
    LOWORD(lpFileName[0]) = 0;
    v15 = 0;
    sub_47CCA0(a1, lpFileName, v3);
    v4 = lpFileName[0];
    if ( v14 < 8 )
      v4 = (const WCHAR *)lpFileName;
    FileW = CreateFileW(v4, 0x40000000u, 0, 0, 1u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      WriteFile(FileW, lpBuffer, NumberOfBytesRead, &NumberOfBytesWritten, 0);
      CloseHandle(FileW);
    }
    PostMessageW(*(HWND *)(a1 + 8), 0x8002u, v3, 0);
    v11 += NumberOfBytesRead;
    ++v3;
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 100));
    if ( *(_BYTE *)(a1 + 124) )
      v12 = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 100));
    v15 = -1;
    if ( v14 >= 8 )
      operator delete((void *)lpFileName[0]);
  }
  operator delete[](lpBuffer);
}

//----- (0047CFB0) --------------------------------------------------------
LRESULT __usercall sub_47CFB0@<eax>(int a1@<eax>)
{
  bool v2; // cf
  const WCHAR *v3; // eax
  HANDLE FileW; // eax
  void *v5; // edi
  LONGLONG v7; // rax
  __int64 v8; // [esp-8h] [ebp-20h]
  LARGE_INTEGER FileSize; // [esp+10h] [ebp-8h] BYREF

  v2 = *(_DWORD *)(a1 + 32) < 8u;
  v3 = (const WCHAR *)(a1 + 12);
  if ( !v2 )
    v3 = *(const WCHAR **)v3;
  FileW = CreateFileW(v3, 0x80000000, 1u, 0, 3u, 0, 0);
  v5 = FileW;
  if ( FileW == (HANDLE)-1 )
    return PostMessageW(*(HWND *)(a1 + 8), 0x8004u, 0, 0);
  GetFileSizeEx(FileW, &FileSize);
  v8 = *(unsigned int *)(a1 + 96);
  v7 = FileSize.QuadPart / v8;
  if ( FileSize.QuadPart % v8 )
    LODWORD(v7) = v7 + 1;
  PostMessageW(*(HWND *)(a1 + 8), 0x8001u, v7, 0);
  sub_47CE20(a1, v5, &FileSize);
  CloseHandle(v5);
  return SendMessageW(*(HWND *)(a1 + 8), 0x8003u, 0, 0);
}

//----- (0047D070) --------------------------------------------------------
DWORD __stdcall sub_47D070(LPVOID lpThreadParameter)
{
  sub_47CFB0((int)lpThreadParameter);
  return 0;
}

//----- (0047D090) --------------------------------------------------------
void __thiscall sub_47D090(int this)
{
  HWND DlgItem; // ebx
  HWND v3; // ebx
  int v4; // edx
  HWND v5; // eax
  HWND v6; // eax
  void *v7; // esi
  int v8; // eax
  HWND v9; // edx
  HANDLE Thread; // esi
  int v11; // edi
  int v12; // [esp-5Ch] [ebp-248h]
  void *v13[7]; // [esp-58h] [ebp-244h] BYREF
  void *v14[7]; // [esp-3Ch] [ebp-228h] BYREF
  void *v15[4]; // [esp-20h] [ebp-20Ch] BYREF
  HWND v16; // [esp-10h] [ebp-1FCh]
  UINT_PTR v17; // [esp-Ch] [ebp-1F8h]
  int v18; // [esp-8h] [ebp-1F4h]
  int v19; // [esp-4h] [ebp-1F0h]
  void **v20; // [esp+10h] [ebp-1DCh]
  BOOL Translated; // [esp+14h] [ebp-1D8h] BYREF
  void **v22; // [esp+18h] [ebp-1D4h] BYREF
  void *v23; // [esp+1Ch] [ebp-1D0h] BYREF
  int DlgItemInt; // [esp+20h] [ebp-1CCh]
  int v25[7]; // [esp+24h] [ebp-1C8h] BYREF
  void *v26[5]; // [esp+40h] [ebp-1ACh] BYREF
  unsigned int v27; // [esp+54h] [ebp-198h]
  WCHAR String[64]; // [esp+5Ch] [ebp-190h] BYREF
  WCHAR Buffer[128]; // [esp+DCh] [ebp-110h] BYREF
  int v30; // [esp+1E8h] [ebp-4h]

  if ( *(_BYTE *)(this + 76) )
  {
    *(_BYTE *)(this + 77) = 1;
    v11 = *(_DWORD *)(this + 124);
    if ( v11 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(v11 + 100));
      v19 = v11 + 100;
      *(_BYTE *)(v11 + 124) = 1;
      LeaveCriticalSection((LPCRITICAL_SECTION)v19);
    }
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(this + 4), 1293);
    if ( GetWindowTextLengthW(DlgItem) )
    {
      v27 = 7;
      v26[4] = 0;
      LOWORD(v26[0]) = 0;
      v30 = 0;
      sub_46AFA0(DlgItem, v26);
      if ( sub_40C610((int *)v26, L"/N", 2u) == -1 )
      {
        LoadStringW(*(HINSTANCE *)(this + 8), 0x852u, Buffer, 128);
        SetDlgItemTextW(*(HWND *)(this + 4), 1309, Buffer);
        v19 = (int)DlgItem;
        *(_DWORD *)(this + 200) = 2;
        SetFocus((HWND)v19);
        if ( v27 >= 8 )
          operator delete(v26[0]);
      }
      else
      {
        v3 = GetDlgItem(*(HWND *)(this + 4), 1141);
        if ( GetWindowTextLengthW(v3) )
        {
          v25[5] = 7;
          v25[4] = 0;
          LOWORD(v25[0]) = 0;
          LOBYTE(v30) = 1;
          sub_46AFA0(v3, v25);
          DlgItemInt = GetDlgItemInt(*(HWND *)(this + 4), 1139, &Translated, 0);
          if ( Translated )
          {
            v6 = GetDlgItem(*(HWND *)(this + 4), 1140);
            v22 = (void **)SendMessageW(v6, 0x147u, 0, 0);
            sub_417A20((_DWORD *)(this + 80), (int *)&v22, &v23);
            if ( v23 != *(void **)(this + 84) )
            {
              switch ( *((_DWORD *)v23 + 3) )
              {
                case 1:
                  DlgItemInt <<= 10;
                  break;
                case 2:
                  DlgItemInt <<= 20;
                  break;
                case 3:
                  DlgItemInt <<= 30;
                  break;
              }
            }
            v7 = operator new(0x80u);
            v23 = v7;
            LOBYTE(v30) = 2;
            if ( v7 )
            {
              v19 = DlgItemInt;
              v22 = v15;
              sub_409E30(v15, v25);
              LOBYTE(v30) = 3;
              DlgItemInt = (int)v14;
              sub_409E30(v14, v26);
              v20 = v13;
              LOBYTE(v30) = 4;
              sub_409E30(v13, (_DWORD *)(this + 48));
              v12 = *(_DWORD *)(this + 4);
              LOBYTE(v30) = 2;
              v8 = sub_47C6A0(
                     (int)v7,
                     v12,
                     v13[0],
                     (int)v13[1],
                     (int)v13[2],
                     (int)v13[3],
                     (int)v13[4],
                     (int)v13[5],
                     (int)v13[6],
                     v14[0],
                     (int)v14[1],
                     (int)v14[2],
                     (int)v14[3],
                     (int)v14[4],
                     (int)v14[5],
                     (int)v14[6],
                     v15[0],
                     (int)v15[1],
                     (int)v15[2],
                     (int)v15[3],
                     (int)v16,
                     v17,
                     v18,
                     v19);
            }
            else
            {
              v8 = 0;
            }
            v19 = 32;
            v18 = this + 132;
            *(_DWORD *)(this + 124) = v8;
            GetDlgItemTextW(*(HWND *)(this + 4), 1, (LPWSTR)v18, v19);
            LoadStringW(*(HINSTANCE *)(this + 8), 0x849u, String, 64);
            SetDlgItemTextW(*(HWND *)(this + 4), 1, String);
            v9 = *(HWND *)(this + 4);
            v19 = 0;
            v18 = 1000;
            v17 = 1;
            v16 = v9;
            *(_BYTE *)(this + 76) = 1;
            *(_DWORD *)(this + 196) = 0;
            SetTimer(v16, v17, v18, (TIMERPROC)v19);
            LoadStringW(*(HINSTANCE *)(this + 8), 0xF6u, String, 64);
            SetDlgItemTextW(*(HWND *)(this + 4), 1309, String);
            Thread = CreateThread(0, 0, sub_47D070, *(LPVOID *)(this + 124), 0, 0);
            SetThreadPriority(Thread, -2);
            CloseHandle(Thread);
          }
          else
          {
            LoadStringW(*(HINSTANCE *)(this + 8), 0x84Fu, Buffer, 128);
            SetDlgItemTextW(*(HWND *)(this + 4), 1309, Buffer);
            v4 = *(_DWORD *)(this + 4);
            v19 = 1139;
            v18 = v4;
            *(_DWORD *)(this + 200) = 4;
            v5 = GetDlgItem((HWND)v18, v19);
            SetFocus(v5);
          }
          sub_409000((int)v25);
          sub_409000((int)v26);
        }
        else
        {
          LoadStringW(*(HINSTANCE *)(this + 8), 0x84Eu, Buffer, 128);
          SetDlgItemTextW(*(HWND *)(this + 4), 1309, Buffer);
          v19 = (int)v3;
          *(_DWORD *)(this + 200) = 3;
          SetFocus((HWND)v19);
          sub_409000((int)v26);
        }
      }
    }
    else
    {
      LoadStringW(*(HINSTANCE *)(this + 8), 0x850u, Buffer, 128);
      SetDlgItemTextW(*(HWND *)(this + 4), 1309, Buffer);
      v19 = (int)DlgItem;
      *(_DWORD *)(this + 200) = 1;
      SetFocus((HWND)v19);
    }
  }
}
// 4C6C18: using guessed type wchar_t aN[3];

//----- (0047D500) --------------------------------------------------------
int __thiscall sub_47D500(int this, unsigned int a2, int a3)
{
  __int16 v4; // cx
  bool v5; // zf

  if ( HIWORD(a2) == 768 )
  {
    switch ( *(_DWORD *)(this + 200) )
    {
      case 1:
        v4 = 1293;
        goto LABEL_7;
      case 2:
        v5 = (_WORD)a2 == 1293;
        goto LABEL_8;
      case 3:
        v5 = (_WORD)a2 == 1141;
        goto LABEL_8;
      case 4:
        v4 = 1139;
LABEL_7:
        v5 = (_WORD)a2 == (unsigned __int16)v4;
LABEL_8:
        if ( v5 )
        {
          SetDlgItemTextW(*(HWND *)(this + 4), 1309, &word_4C6C68);
          *(_DWORD *)(this + 200) = 0;
        }
        break;
      default:
        break;
    }
  }
  if ( (unsigned __int16)a2 == 1 )
  {
    sub_47D090(this);
    return 0;
  }
  if ( (unsigned __int16)a2 != 2 )
  {
    if ( (unsigned __int16)a2 == 1142 )
    {
      sub_47CA40(this);
      return 0;
    }
    return 0;
  }
  if ( *(_BYTE *)(this + 76) )
    *(_BYTE *)(this + 77) = 1;
  else
    EndDialog(*(HWND *)(this + 4), 0);
  return 0;
}

//----- (0047D5E0) --------------------------------------------------------
int __thiscall sub_47D5E0(int this)
{
  int v2; // esi
  const WCHAR *v3; // eax
  const WCHAR *v4; // eax
  const WCHAR *v5; // eax
  HANDLE FileW; // eax
  void *v7; // ebx
  WCHAR *v8; // eax
  int v9; // edx
  int v10; // esi
  WCHAR v11; // cx
  HWND DlgItem; // esi
  int v13; // eax
  char **v14; // ecx
  char **v15; // eax
  int v16; // ecx
  DWORD v17; // eax
  char **v18; // eax
  int v19; // ecx
  DWORD v20; // eax
  char **v21; // eax
  int v22; // ecx
  DWORD v23; // eax
  char **v24; // eax
  int v25; // ecx
  _DWORD *v26; // eax
  HWND v27; // esi
  const WCHAR *v28; // eax
  WCHAR *v29; // eax
  WCHAR *v30; // edx
  int v31; // esi
  WCHAR *v32; // eax
  void *v33; // eax
  HFONT v34; // eax
  HWND v35; // esi
  _DWORD *v36; // edi
  HWND Parent; // eax
  HWND v39; // [esp-14h] [ebp-83Ch]
  HINSTANCE v40; // [esp-10h] [ebp-838h]
  char *v41; // [esp-8h] [ebp-830h]
  int v42; // [esp-4h] [ebp-82Ch]
  int v43; // [esp-4h] [ebp-82Ch]
  int v44; // [esp-4h] [ebp-82Ch]
  int v45; // [esp-4h] [ebp-82Ch]
  int v46; // [esp+10h] [ebp-818h] BYREF
  int v47; // [esp+14h] [ebp-814h]
  LARGE_INTEGER FileSize; // [esp+18h] [ebp-810h] BYREF
  HWND hWnd; // [esp+20h] [ebp-808h]
  ICONINFO piconinfo; // [esp+24h] [ebp-804h] BYREF
  SHFILEINFOW psfi; // [esp+38h] [ebp-7F0h] BYREF
  LOGFONTW pv; // [esp+2F0h] [ebp-538h] BYREF
  WCHAR Buffer[64]; // [esp+350h] [ebp-4D8h] BYREF
  __int16 String[32]; // [esp+3D0h] [ebp-458h] BYREF
  WCHAR v55[260]; // [esp+410h] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+618h] [ebp-210h] BYREF

  v2 = this + 48;
  if ( *(_DWORD *)(this + 68) < 8u )
    v3 = (const WCHAR *)(this + 48);
  else
    v3 = *(const WCHAR **)v2;
  if ( SHGetFileInfoW(v3, 0, &psfi, 0x2B4u, 0x100u) )
  {
    GetIconInfo(psfi.hIcon, &piconinfo);
    SendDlgItemMessageW(*(HWND *)(this + 4), 1297, 0x172u, 0, (LPARAM)piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmMask);
    DestroyIcon(psfi.hIcon);
  }
  if ( *(_DWORD *)(v2 + 20) < 8u )
    v4 = (const WCHAR *)v2;
  else
    v4 = *(const WCHAR **)v2;
  SetDlgItemTextW(*(HWND *)(this + 4), 1295, v4);
  if ( *(_DWORD *)(v2 + 20) < 8u )
    v5 = (const WCHAR *)v2;
  else
    v5 = *(const WCHAR **)v2;
  FileW = CreateFileW(v5, 0x80000000, 1u, 0, 3u, 0, 0);
  v7 = FileW;
  if ( FileW != (HANDLE)-1 )
  {
    GetFileSizeEx(FileW, &FileSize);
    sub_46B2E0(0x20u, 0, 0, FileSize.QuadPart);
    SetDlgItemTextW(*(HWND *)(this + 4), 1296, (LPCWSTR)String);
    CloseHandle(v7);
  }
  if ( *(_DWORD *)(v2 + 20) >= 8u )
    v2 = *(_DWORD *)v2;
  v8 = pszPath;
  v9 = 260;
  v10 = v2 - (_DWORD)pszPath;
  while ( v9 != -2147483386 )
  {
    v11 = *(WCHAR *)((char *)v8 + v10);
    if ( !v11 )
      break;
    *v8++ = v11;
    if ( !--v9 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathRemoveFileSpecW(pszPath);
  SetDlgItemTextW(*(HWND *)(this + 4), 1141, pszPath);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1140);
  v40 = *(HINSTANCE *)(this + 8);
  hWnd = DlgItem;
  LoadStringW(v40, 0x86Eu, Buffer, 64);
  v13 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFF, (LPARAM)Buffer);
  v14 = *(char ***)(this + 84);
  v46 = v13;
  v42 = *((_DWORD *)*v14 + 1);
  v41 = *v14;
  v47 = 0;
  FileSize.LowPart = (DWORD)v41;
  v15 = sub_419770((char **)&v46, v41, v42);
  v16 = *(_DWORD *)(this + 88);
  if ( v16 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 88) = v16 + 1;
  *(_DWORD *)(FileSize.LowPart + 4) = v15;
  *(_DWORD *)v15[1] = v15;
  sub_418A00(this + 80, (int)&v46, **(_DWORD **)(this + 84) + 8, **(void ***)(this + 84));
  LoadStringW(*(HINSTANCE *)(this + 8), 0x86Fu, Buffer, 64);
  v46 = SendMessageW(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)Buffer);
  v17 = **(_DWORD **)(this + 84);
  v43 = *(_DWORD *)(v17 + 4);
  v47 = 1;
  FileSize.LowPart = v17;
  v18 = sub_419770((char **)&v46, (char *)v17, v43);
  v19 = *(_DWORD *)(this + 88);
  if ( v19 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 88) = v19 + 1;
  *(_DWORD *)(FileSize.LowPart + 4) = v18;
  *(_DWORD *)v18[1] = v18;
  sub_418A00(this + 80, (int)&v46, **(_DWORD **)(this + 84) + 8, **(void ***)(this + 84));
  LoadStringW(*(HINSTANCE *)(this + 8), 0x870u, Buffer, 64);
  v46 = SendMessageW(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)Buffer);
  v20 = **(_DWORD **)(this + 84);
  v44 = *(_DWORD *)(v20 + 4);
  v47 = 2;
  FileSize.LowPart = v20;
  v21 = sub_419770((char **)&v46, (char *)v20, v44);
  v22 = *(_DWORD *)(this + 88);
  if ( v22 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 88) = v22 + 1;
  *(_DWORD *)(FileSize.LowPart + 4) = v21;
  *(_DWORD *)v21[1] = v21;
  sub_418A00(this + 80, (int)&v46, **(_DWORD **)(this + 84) + 8, **(void ***)(this + 84));
  LoadStringW(*(HINSTANCE *)(this + 8), 0x871u, Buffer, 64);
  v46 = SendMessageW(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)Buffer);
  v23 = **(_DWORD **)(this + 84);
  v45 = *(_DWORD *)(v23 + 4);
  v47 = 3;
  FileSize.LowPart = v23;
  v24 = sub_419770((char **)&v46, (char *)v23, v45);
  v25 = *(_DWORD *)(this + 88);
  if ( v25 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(this + 88) = v25 + 1;
  *(_DWORD *)(FileSize.LowPart + 4) = v24;
  *(_DWORD *)v24[1] = v24;
  sub_418A00(this + 80, (int)&v46, **(_DWORD **)(this + 84) + 8, **(void ***)(this + 84));
  v26 = (_DWORD *)(*(_DWORD *)(this + 204) + 568);
  if ( *(_DWORD *)(*(_DWORD *)(this + 204) + 588) >= 8u )
    v26 = (_DWORD *)*v26;
  SendMessageW(hWnd, 0x14Du, 0xFFFFFFFF, (LPARAM)v26);
  v27 = GetDlgItem(*(HWND *)(this + 4), 1139);
  v28 = (const WCHAR *)(*(_DWORD *)(this + 204) + 540);
  if ( *(_DWORD *)(*(_DWORD *)(this + 204) + 560) >= 8u )
    v28 = *(const WCHAR **)v28;
  SetWindowTextW(v27, v28);
  SendMessageW(v27, 0xB1u, 0, -1);
  SetFocus(v27);
  v29 = (WCHAR *)(this + 48);
  if ( *(_DWORD *)(this + 68) >= 8u )
    v29 = *(WCHAR **)v29;
  v30 = v29;
  v31 = 260;
  v32 = v55;
  while ( v31 != -2147483386 && *v30 )
  {
    *v32++ = *v30++;
    if ( !--v31 )
    {
      --v32;
      break;
    }
  }
  *v32 = 0;
  PathStripPathW(v55);
  sub_401000(0x104u, v55, L"%s.part%s", v55, L"/N");
  SetDlgItemTextW(*(HWND *)(this + 4), 1293, v55);
  v33 = (void *)SendDlgItemMessageW(*(HWND *)(this + 4), 1298, 0x31u, 0, 0);
  GetObjectW(v33, 92, &pv);
  pv.lfItalic = 1;
  v34 = CreateFontIndirectW(&pv);
  v39 = *(HWND *)(this + 4);
  *(_DWORD *)(this + 128) = v34;
  SendDlgItemMessageW(v39, 1298, 0x30u, (WPARAM)v34, 1);
  SetDlgItemTextW(*(HWND *)(this + 4), 1301, L"00:00:00");
  v35 = *(HWND *)(this + 4);
  v36 = *(_DWORD **)(this + 204);
  if ( v36[1] )
  {
    SetWindowPos(v35, 0, v36[2], v36[3], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v35);
    sub_4697F0(v35, Parent);
  }
  return 0;
}
// 47D741: conditional instruction was optimized away because edx.4!=0
// 47DA76: conditional instruction was optimized away because esi.4!=0
// 4C6C18: using guessed type wchar_t aN[3];
// 4C6C20: using guessed type wchar_t aSPartS[10];
// 47D5E0: using guessed type WCHAR String[32];

//----- (0047DB90) --------------------------------------------------------
int __userpurge sub_47DB90@<eax>(int a1@<ecx>, int a2@<esi>, void *a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  bool v9; // cf
  char v11[2]; // [esp+12h] [ebp-Eh] BYREF
  int v12; // [esp+1Ch] [ebp-4h]

  v12 = 0;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(a2 + 12) = 183;
  *(_DWORD *)(a2 + 16) = a1;
  *(_BYTE *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)a2 = &CSplitFileDialog::`vftable';
  *(_DWORD *)(a2 + 68) = 7;
  *(_DWORD *)(a2 + 64) = 0;
  *(_WORD *)(a2 + 48) = 0;
  LOBYTE(v12) = 2;
  sub_417FA0(a2 + 80, v11);
  LOBYTE(v12) = 3;
  sub_4090E0(a2 + 48, &a3, 0, 0xFFFFFFFF);
  *(_WORD *)(a2 + 76) = 0;
  *(_DWORD *)(a2 + 200) = 0;
  *(_DWORD *)(a2 + 124) = 0;
  if ( (dword_4F2484 & 1) == 0 )
  {
    dword_4F2484 |= 1u;
    LOBYTE(v12) = 4;
    sub_47C990();
    atexit(sub_4BCD40);
  }
  v9 = (unsigned int)a8 < 8;
  *(_DWORD *)(a2 + 204) = &dword_4F2230;
  if ( !v9 )
    operator delete(a3);
  return a2;
}
// 4CC264: using guessed type void *CSplitFileDialog::`vftable';
// 4F2230: using guessed type int dword_4F2230;
// 4F2484: using guessed type int dword_4F2484;
// 47DB90: using guessed type char var_E[2];

//----- (0047DC80) --------------------------------------------------------
HRESULT __fastcall sub_47DC80(LPCITEMIDLIST *a1, const WCHAR *a2, int a3, LPCITEMIDLIST pidl, int a5, int a6)
{
  HRESULT v6; // esi
  int v7; // esi
  int v8; // ecx
  int v10[9]; // [esp+Ch] [ebp-6Ch] BYREF
  LPCWCH lpWideCharStr; // [esp+30h] [ebp-48h]
  LPCITEMIDLIST *v12; // [esp+34h] [ebp-44h]
  LPCITEMIDLIST ppidlLast; // [esp+38h] [ebp-40h] BYREF
  LPITEMIDLIST ppidl; // [esp+3Ch] [ebp-3Ch] BYREF
  int v15; // [esp+40h] [ebp-38h] BYREF
  int v16; // [esp+44h] [ebp-34h]
  void *ppv; // [esp+48h] [ebp-30h] BYREF
  IShellFolder *ppshf; // [esp+4Ch] [ebp-2Ch] BYREF
  int v19; // [esp+50h] [ebp-28h] BYREF
  CHAR MultiByteStr[32]; // [esp+54h] [ebp-24h] BYREF

  v16 = a3;
  v12 = a1;
  lpWideCharStr = a2;
  ppshf = 0;
  ppv = 0;
  v15 = 0;
  v19 = 0;
  ppidlLast = 0;
  if ( a5 )
  {
    v6 = SHGetDesktopFolder(&ppshf);
    if ( v6 >= 0 )
    {
      ppidl = 0;
      if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 && (v7 = sub_466190(pidl, ppidl), CoTaskMemFree(ppidl), v7) )
      {
        v6 = ppshf->lpVtbl->GetUIObjectOf(
               ppshf,
               *(HWND *)(v16 + 52),
               a5,
               v12,
               (const IID *const)&unk_4BD7EC,
               0,
               (void **)&v19);
      }
      else
      {
        v6 = ppshf->lpVtbl->BindToObject(ppshf, pidl, 0, &stru_4BD7FC, (void **)&v15);
        if ( v6 >= 0 )
        {
          v6 = (*(int (__stdcall **)(int, _DWORD, int, LPCITEMIDLIST *, void *, _DWORD, int *))(*(_DWORD *)v15 + 40))(
                 v15,
                 *(_DWORD *)(v16 + 52),
                 a5,
                 v12,
                 &unk_4BD7EC,
                 0,
                 &v19);
          (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
          v15 = 0;
        }
      }
      ppshf->lpVtbl->Release(ppshf);
      ppshf = 0;
    }
  }
  else
  {
    v6 = SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast);
    if ( v6 >= 0 )
    {
      v6 = (*(int (__stdcall **)(void *, _DWORD, int, LPCITEMIDLIST *, void *, _DWORD, int *))(*(_DWORD *)ppv + 40))(
             ppv,
             *(_DWORD *)(v16 + 52),
             1,
             &ppidlLast,
             &unk_4BD7EC,
             0,
             &v19);
      (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
      ppv = 0;
    }
  }
  if ( v19 )
  {
    WideCharToMultiByte(0, 0, lpWideCharStr, -1, MultiByteStr, 32, 0, 0);
    v8 = *(_DWORD *)(v16 + 52);
    v10[1] = a6;
    v10[3] = (int)MultiByteStr;
    v10[0] = 36;
    v10[2] = v8;
    v10[4] = 0;
    v10[5] = 0;
    v10[6] = 5;
    v6 = (*(int (__stdcall **)(int, int *))(*(_DWORD *)v19 + 16))(v19, v10);
    (*(void (__stdcall **)(int))(*(_DWORD *)v19 + 8))(v19);
  }
  return v6;
}

//----- (0047DE70) --------------------------------------------------------
void __thiscall sub_47DE70(_DWORD *this, LPCITEMIDLIST pidl1, int a3, int a4)
{
  void *v4; // edi
  ITEMIDLIST *v5; // esi
  HRESULT v6; // eax
  _DWORD *v7; // ebx
  int v8; // edi
  int v9; // [esp-8h] [ebp-244h]
  int *v10; // [esp-4h] [ebp-240h]
  LPVOID pv; // [esp+14h] [ebp-228h] BYREF
  _DWORD *v12; // [esp+18h] [ebp-224h]
  void *v13[4]; // [esp+1Ch] [ebp-220h] BYREF
  __int16 v14[262]; // [esp+2Ch] [ebp-210h] BYREF

  v12 = this;
  if ( a4 == 1001 )
  {
    if ( *(_DWORD *)(a3 + 4) )
    {
      v10 = *(int **)a3;
      v9 = **(_DWORD **)a3;
      memset(v13, 0, 12);
      sub_417B50(v13, v9, (int)v10, (int)v12);
      v4 = v13[0];
      v5 = ILCombine(pidl1, *(LPCITEMIDLIST *)v13[0]);
      operator delete(v4);
    }
    else
    {
      v5 = ILClone(pidl1);
    }
    sub_466630(v5, (WCHAR *)v14, 0x8000);
    pv = 0;
    v6 = sub_467810((LPITEMIDLIST *)&pv, (int)v14);
    v7 = v12;
    v8 = v6;
    (*(void (__thiscall **)(_DWORD *, LPVOID, _DWORD, int, int, _DWORD))(v12[2] + 40))(v12 + 2, pv, 0, 1, 1, 0);
    if ( v8 >= 0 )
      CoTaskMemFree(pv);
    v7[1398] = 1;
    CoTaskMemFree(v5);
  }
}
// 47DE70: using guessed type WCHAR var_210[262];

//----- (0047DF70) --------------------------------------------------------
void __stdcall sub_47DF70(int a1, int a2, int *a3, HMENU a4)
{
  int v4; // eax
  void *v5; // esi
  int v6; // [esp-Ch] [ebp-F8h]
  int *v7; // [esp-8h] [ebp-F4h]
  int v8; // [esp+Ch] [ebp-E0h] BYREF
  HMENU hmenu; // [esp+10h] [ebp-DCh]
  void *v10[4]; // [esp+14h] [ebp-D8h] BYREF
  MENUITEMINFOW mi; // [esp+24h] [ebp-C8h] BYREF
  WCHAR Buffer[66]; // [esp+54h] [ebp-98h] BYREF
  int v13; // [esp+E8h] [ebp-4h]

  hmenu = a4;
  v4 = *a3;
  if ( (!*a3 || v4 == 1 || v4 == 3) && *(_DWORD *)(a2 + 4) == 1 )
  {
    v7 = *(int **)a2;
    v8 = 0x20000000;
    v6 = *v7;
    memset(v10, 0, 12);
    sub_417B50(v10, v6, (int)v7, (int)hmenu);
    v13 = 0;
    v5 = v10[0];
    sub_4665C0(*(const ITEMIDLIST **)v10[0], (int)&v8);
    if ( (v8 & 0x20000000) != 0 )
    {
      LoadStringW(hInstance, 0x86Du, Buffer, 64);
      mi.cbSize = 48;
      mi.fMask = 66;
      mi.wID = 1001;
      mi.dwTypeData = Buffer;
      InsertMenuItemW(hmenu, 1u, 1, &mi);
    }
    operator delete(v5);
  }
}

//----- (0047E0A0) --------------------------------------------------------
int __thiscall sub_47E0A0(_DWORD *this, LPCITEMIDLIST pidl1, int a3, int a4, PCWSTR psz1)
{
  const ITEMIDLIST *v5; // edi
  int result; // eax
  HRESULT (__stdcall *v8)(IDataObject *, const IID *const, void **); // esi
  LPITEMIDLIST v9; // edi
  _DWORD *v10; // ebx
  HCURSOR CursorW; // eax
  _DWORD *v12; // eax
  HCURSOR v13; // eax
  _DWORD *v14; // esi
  HCURSOR v15; // eax
  _DWORD *v16; // eax
  HWND v17; // ecx
  int v18; // eax
  WPARAM i; // ebx
  int v20; // edi
  char *v21; // eax
  int v22; // ecx
  UINT v23; // [esp-Ch] [ebp-280h] BYREF
  WPARAM v24; // [esp-8h] [ebp-27Ch]
  LPARAM v25; // [esp-4h] [ebp-278h]
  struct IDataObjectVtbl *v26; // [esp+14h] [ebp-260h] BYREF
  char *v27; // [esp+18h] [ebp-25Ch] BYREF
  void *v28; // [esp+1Ch] [ebp-258h] BYREF
  int v29; // [esp+20h] [ebp-254h]
  LPCITEMIDLIST v30; // [esp+28h] [ebp-24Ch]
  int pExceptionObject[3]; // [esp+2Ch] [ebp-248h] BYREF
  void *v32[5]; // [esp+38h] [ebp-23Ch] BYREF
  unsigned int v33; // [esp+4Ch] [ebp-228h]
  unsigned __int16 Src; // [esp+54h] [ebp-220h] BYREF
  __int16 v35; // [esp+56h] [ebp-21Eh] BYREF
  int v36; // [esp+270h] [ebp-4h]

  v5 = pidl1;
  v30 = pidl1;
  v26 = (struct IDataObjectVtbl *)a3;
  if ( !StrCmpIW(psz1, L"open") )
  {
    if ( v26->AddRef )
    {
      v8 = *(HRESULT (__stdcall **)(IDataObject *, const IID *const, void **))v26->QueryInterface;
      v26 = (struct IDataObjectVtbl *)v26->QueryInterface;
      if ( (char *)v8 != (char *)v26 )
      {
        while ( 1 )
        {
          v9 = ILCombine(v5, *((LPCITEMIDLIST *)v8 + 2));
          (*(void (__thiscall **)(_DWORD *, LPITEMIDLIST, _DWORD, _DWORD))(this[2] + 32))(this + 2, v9, 0, 0);
          CoTaskMemFree(v9);
          v8 = *(HRESULT (__stdcall **)(IDataObject *, const IID *const, void **))v8;
          if ( (char *)v8 == (char *)v26 )
            break;
          v5 = v30;
        }
      }
      result = 1;
      this[1398] = 1;
    }
    else
    {
      (*(void (__thiscall **)(_DWORD *, LPCITEMIDLIST, _DWORD, _DWORD))(this[2] + 32))(this + 2, pidl1, 0, 0);
      result = 1;
      this[1398] = 1;
    }
    return result;
  }
  if ( StrCmpIW(psz1, L"rename") )
  {
    if ( !StrCmpIW(psz1, L"copy") )
    {
      if ( *(_DWORD *)a4 )
      {
        if ( *(_DWORD *)a4 == 1 )
          sub_477BF0(this - 5, 1);
      }
      else
      {
        v10 = this - 5;
        v26 = 0;
        if ( sub_494670(v10) )
        {
          CursorW = LoadCursorW(0, (LPCWSTR)0x7F02);
          SetCursor(CursorW);
          v29 = 0;
          v12 = operator new(0x24u);
          if ( !v12 )
          {
            v27 = 0;
            std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
            pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v12 = v12;
          v28 = v12;
          v12[1] = v12;
          v36 = 0;
          sub_49CB90((HWND)v10[858], (int)v10, (int)&v28);
          v30 = (LPCITEMIDLIST)&v23;
          sub_40AC30((char ***)&v23, (int **)&v28);
          if ( sub_4AE6E0((LPDATAOBJECT *)&v26, (void *)v23) >= 0 )
            v10[15146] = v26;
LABEL_21:
          v13 = LoadCursorW(0, (LPCWSTR)0x7F00);
          SetCursor(v13);
          sub_40A140((int)&v28);
          operator delete(v28);
          return 1;
        }
      }
      return 1;
    }
    if ( StrCmpIW(psz1, L"cut") )
      return 0;
    if ( *(_DWORD *)a4 )
    {
      if ( *(_DWORD *)a4 == 1 )
        sub_477BF0(this - 5, 0);
    }
    else
    {
      v14 = this - 5;
      v26 = 0;
      if ( sub_494670(this - 5) )
      {
        v15 = LoadCursorW(0, (LPCWSTR)0x7F02);
        SetCursor(v15);
        v29 = 0;
        v16 = operator new(0x24u);
        if ( !v16 )
        {
          v27 = 0;
          std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
          pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        *v16 = v16;
        v28 = v16;
        v16[1] = v16;
        v36 = 2;
        sub_49CB90((HWND)v14[858], (int)(this - 5), (int)&v28);
        v30 = (LPCITEMIDLIST)&v23;
        sub_40AC30((char ***)&v23, (int **)&v28);
        if ( sub_4AE660((LPDATAOBJECT *)&v26, (void *)v23) >= 0 )
        {
          v17 = (HWND)v14[858];
          v18 = v14[1405];
          v25 = 2;
          v24 = -1;
          v23 = 4108;
          v14[15146] = v26;
          v14[15310] = v18;
          for ( i = SendMessageW(v17, v23, v24, v25); i != -1; i = SendMessageW((HWND)v14[858], 0x100Cu, i, 2) )
          {
            (*(void (__thiscall **)(_DWORD, WPARAM, int, unsigned __int16 *))(*(_DWORD *)v14[330] + 64))(
              v14[330],
              i,
              260,
              &Src);
            LOWORD(v32[0]) = 0;
            v33 = 7;
            v32[4] = 0;
            sub_4094F0(v32, (int)&v35, &Src, wcslen(&Src));
            LOBYTE(v36) = 3;
            v20 = v14[15307];
            v21 = sub_40A200((char *)v20, *(_DWORD *)(v20 + 4), (int)v32);
            v22 = v14[15308];
            if ( v22 == 153391688 )
              std::_Xlength_error("list<T> too long");
            v14[15308] = v22 + 1;
            *(_DWORD *)(v20 + 4) = v21;
            **((_DWORD **)v21 + 1) = v21;
            LOBYTE(v36) = 2;
            if ( v33 >= 8 )
              operator delete(v32[0]);
            (*(void (__thiscall **)(_DWORD, WPARAM))(*(_DWORD *)v14[330] + 188))(v14[330], i);
          }
        }
        goto LABEL_21;
      }
    }
    return 1;
  }
  if ( *(_DWORD *)a4 )
  {
    if ( *(_DWORD *)a4 == 1 )
      sub_477310((int)(this - 5));
    return 1;
  }
  else
  {
    sub_4AC590((int)(this - 5));
    return 1;
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0047E6C0) --------------------------------------------------------
int __thiscall sub_47E6C0(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (0047E6D0) --------------------------------------------------------
int __thiscall sub_47E6D0(int this, _DWORD *a2)
{
  HWND v3; // edx
  HWND v4; // eax
  HWND v5; // eax
  HWND v7; // ecx
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND DlgItem; // eax
  HWND v12; // eax
  BOOL v13; // [esp-8h] [ebp-10h]
  BOOL v14; // [esp-8h] [ebp-10h]
  BOOL v15; // [esp-8h] [ebp-10h]
  BOOL v16; // [esp-8h] [ebp-10h]
  BOOL v17; // [esp-8h] [ebp-10h]
  BOOL v18; // [esp-8h] [ebp-10h]

  if ( a2[2] == -759 )
  {
    switch ( a2[1] )
    {
      case 0x413:
        v10 = *(HWND *)(this + 4);
        *(_DWORD *)(this + 124) = a2[3] == 0;
        v17 = a2[3] == 0;
        DlgItem = GetDlgItem(v10, 1048);
        EnableWindow(DlgItem, v17);
        v18 = a2[3] == 0;
        v12 = GetDlgItem(*(HWND *)(this + 4), 1111);
        EnableWindow(v12, v18);
        break;
      case 0x419:
        v7 = *(HWND *)(this + 4);
        *(_DWORD *)(this + 128) = a2[3] == 0;
        v15 = a2[3] == 0;
        v8 = GetDlgItem(v7, 1050);
        EnableWindow(v8, v15);
        v16 = a2[3] == 0;
        v9 = GetDlgItem(*(HWND *)(this + 4), 1054);
        EnableWindow(v9, v16);
        return 0;
      case 0x41B:
        v3 = *(HWND *)(this + 4);
        *(_DWORD *)(this + 132) = a2[3] == 0;
        v13 = a2[3] == 0;
        v4 = GetDlgItem(v3, 1052);
        EnableWindow(v4, v13);
        v14 = a2[3] == 0;
        v5 = GetDlgItem(*(HWND *)(this + 4), 1055);
        EnableWindow(v5, v14);
        return 0;
    }
  }
  return 0;
}

//----- (0047E800) --------------------------------------------------------
int __thiscall sub_47E800(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 72);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 72) + 4) = 1;
  return result;
}

//----- (0047E860) --------------------------------------------------------
void __usercall sub_47E860(int a1@<eax>)
{
  _DWORD **v2; // ecx
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  _DWORD **v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  void *v8; // esi

  *(_DWORD *)a1 = &CSetFileAttributesDialog::`vftable';
  v2 = *(_DWORD ***)(a1 + 60);
  v3 = *v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 60) + 4) = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 64) = 0;
  if ( v3 != *(_DWORD **)(a1 + 60) )
  {
    do
    {
      v4 = (_DWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_DWORD **)(a1 + 60) );
  }
  operator delete(*(void **)(a1 + 60));
  v5 = *(_DWORD ***)(a1 + 48);
  v6 = *v5;
  *v5 = v5;
  *(_DWORD *)(*(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 52) = 0;
  if ( v6 != *(_DWORD **)(a1 + 48) )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      operator delete(v6);
      v6 = v7;
    }
    while ( v7 != *(_DWORD **)(a1 + 48) );
  }
  operator delete(*(void **)(a1 + 48));
  *(_DWORD *)a1 = &CBaseDialog::`vftable';
  v8 = *(void **)(a1 + 44);
  if ( v8 )
  {
    sub_4AAAD0((int)v8);
    operator delete(v8);
  }
}
// 4CC214: using guessed type void *CSetFileAttributesDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0047E920) --------------------------------------------------------
BOOL __usercall sub_47E920@<eax>(int a1@<ebx>)
{
  HWND DlgItem; // eax
  HWND v2; // eax
  HWND v3; // eax
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  LPARAM v9; // ecx
  int v10; // eax
  HWND v11; // edx
  HWND v12; // eax
  LRESULT v13; // eax
  _DWORD *v14; // ecx
  _DWORD *v15; // eax
  _DWORD *v16; // edi
  _DWORD *v17; // eax
  bool v18; // zf
  int v19; // edx
  int v20; // esi
  HANDLE FileW; // esi
  _DWORD *v23; // [esp+Ch] [ebp-4D4h]
  _DWORD *v24; // [esp+Ch] [ebp-4D4h]
  DWORD dwFileAttributes; // [esp+10h] [ebp-4D0h]
  int v26; // [esp+14h] [ebp-4CCh]
  struct _FILETIME *lpLastWriteTime; // [esp+18h] [ebp-4C8h]
  struct _FILETIME *lpCreationTime; // [esp+1Ch] [ebp-4C4h]
  struct _FILETIME *lpLastAccessTime; // [esp+20h] [ebp-4C0h]
  _DWORD *v30; // [esp+24h] [ebp-4BCh]
  struct _FILETIME FileTime; // [esp+28h] [ebp-4B8h] BYREF
  struct _FILETIME v32; // [esp+30h] [ebp-4B0h] BYREF
  struct _FILETIME v33; // [esp+38h] [ebp-4A8h] BYREF
  SYSTEMTIME LocalTime; // [esp+40h] [ebp-4A0h] BYREF
  LPARAM v35; // [esp+50h] [ebp-490h] BYREF
  WORD v36; // [esp+54h] [ebp-48Ch]
  WORD v37; // [esp+56h] [ebp-48Ah]
  int v38; // [esp+58h] [ebp-488h]
  int v39; // [esp+5Ch] [ebp-484h]
  LPARAM lParam; // [esp+60h] [ebp-480h] BYREF
  WORD v41; // [esp+64h] [ebp-47Ch]
  WORD v42; // [esp+66h] [ebp-47Ah]
  WORD v43; // [esp+68h] [ebp-478h]
  WORD v44; // [esp+6Ah] [ebp-476h]
  WORD v45; // [esp+6Ch] [ebp-474h]
  WORD v46; // [esp+6Eh] [ebp-472h]
  struct _SYSTEMTIME UniversalTime; // [esp+70h] [ebp-470h] BYREF
  WCHAR FileName[558]; // [esp+80h] [ebp-460h] BYREF

  lpLastWriteTime = 0;
  lpCreationTime = 0;
  lpLastAccessTime = 0;
  v26 = 128;
  if ( *(_DWORD *)(a1 + 124) )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1043);
    SendMessageW(DlgItem, 0x1001u, 0, (LPARAM)&lParam);
    v2 = GetDlgItem(*(HWND *)(a1 + 4), 1048);
    SendMessageW(v2, 0x1001u, 0, (LPARAM)&v35);
    *(_DWORD *)&LocalTime.wYear = lParam;
    LocalTime.wDayOfWeek = v41;
    LocalTime.wDay = v42;
    *(_DWORD *)&LocalTime.wSecond = v39;
    *(_DWORD *)&LocalTime.wHour = v38;
    TzSpecificLocalTimeToSystemTime(0, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &FileTime);
    lpLastWriteTime = &FileTime;
  }
  if ( *(_DWORD *)(a1 + 128) )
  {
    v3 = GetDlgItem(*(HWND *)(a1 + 4), 1049);
    SendMessageW(v3, 0x1001u, 0, (LPARAM)&v35);
    v4 = GetDlgItem(*(HWND *)(a1 + 4), 1050);
    SendMessageW(v4, 0x1001u, 0, (LPARAM)&lParam);
    *(_DWORD *)&LocalTime.wYear = v35;
    LocalTime.wDayOfWeek = v36;
    LocalTime.wDay = v37;
    LocalTime.wMinute = v44;
    LocalTime.wSecond = v45;
    LocalTime.wHour = v43;
    LocalTime.wMilliseconds = v46;
    TzSpecificLocalTimeToSystemTime(0, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &v33);
    lpCreationTime = &v33;
  }
  if ( *(_DWORD *)(a1 + 132) )
  {
    v5 = GetDlgItem(*(HWND *)(a1 + 4), 1051);
    SendMessageW(v5, 0x1001u, 0, (LPARAM)&v35);
    v6 = GetDlgItem(*(HWND *)(a1 + 4), 1052);
    SendMessageW(v6, 0x1001u, 0, (LPARAM)&lParam);
    *(_DWORD *)&LocalTime.wYear = v35;
    LocalTime.wDayOfWeek = v36;
    LocalTime.wDay = v37;
    LocalTime.wMinute = v44;
    LocalTime.wSecond = v45;
    LocalTime.wHour = v43;
    LocalTime.wMilliseconds = v46;
    TzSpecificLocalTimeToSystemTime(0, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &v32);
    lpLastAccessTime = &v32;
  }
  v7 = *(_DWORD **)(a1 + 60);
  v8 = (_DWORD *)*v7;
  v23 = v7;
  if ( (_DWORD *)*v7 != v7 )
  {
    while ( 1 )
    {
      v9 = v8[2];
      v10 = v8[3];
      v38 = v8[4];
      v11 = *(HWND *)(a1 + 4);
      v35 = v9;
      v39 = v8[5];
      v12 = GetDlgItem(v11, v10);
      v13 = SendMessageW(v12, 0xF0u, 0, 0);
      if ( !v39 )
        break;
      if ( v13 != 1 )
        goto LABEL_12;
LABEL_13:
      v8 = (_DWORD *)*v8;
      if ( v8 == v23 )
        goto LABEL_14;
    }
    if ( v13 != 1 )
      goto LABEL_13;
LABEL_12:
    v26 |= v35;
    goto LABEL_13;
  }
LABEL_14:
  v14 = *(_DWORD **)(a1 + 48);
  v15 = (_DWORD *)*v14;
  v30 = v14;
  v24 = (_DWORD *)*v14;
  if ( (_DWORD *)*v14 != v14 )
  {
    while ( 1 )
    {
      qmemcpy(FileName, v15 + 2, 0x458u);
      v16 = *(_DWORD **)(a1 + 60);
      v17 = (_DWORD *)*v16;
      for ( dwFileAttributes = v26; v17 != v16; v17 = (_DWORD *)*v17 )
      {
        v18 = v17[4] == 2;
        v19 = v17[2];
        v20 = v17[5];
        *(_DWORD *)&UniversalTime.wDayOfWeek = v17[3];
        if ( v18 && !v20 && (v19 & *(_DWORD *)&FileName[260]) != 0 )
          dwFileAttributes |= v19;
      }
      SetFileAttributesW(FileName, dwFileAttributes);
      FileW = CreateFileW(FileName, 0x100u, 0, 0, 3u, 0, 0);
      if ( FileW != (HANDLE)-1 )
      {
        SetFileTime(FileW, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        CloseHandle(FileW);
      }
      v24 = (_DWORD *)*v24;
      if ( v24 == v30 )
        break;
      v15 = v24;
    }
  }
  return EndDialog(*(HWND *)(a1 + 4), 1);
}

//----- (0047ECE0) --------------------------------------------------------
int __thiscall sub_47ECE0(HWND *this, unsigned __int16 a2, int a3)
{
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND DlgItem; // eax
  HWND v10; // eax
  HWND *v11; // [esp-4h] [ebp-10h]
  HWND *v12; // [esp-4h] [ebp-10h]

  if ( a2 > 0x41Eu )
  {
    if ( a2 == 1055 )
    {
      v12 = this + 23;
      DlgItem = GetDlgItem(this[1], 1051);
      SendMessageW(DlgItem, 0x1002u, 0, (LPARAM)v12);
      v10 = GetDlgItem(this[1], 1052);
      SendMessageW(v10, 0x1002u, 0, (LPARAM)(this + 23));
    }
    else if ( a2 == 1111 )
    {
      v11 = this + 19;
      v7 = GetDlgItem(this[1], 1043);
      SendMessageW(v7, 0x1002u, 0, (LPARAM)v11);
      v8 = GetDlgItem(this[1], 1048);
      SendMessageW(v8, 0x1002u, 0, (LPARAM)(this + 19));
      return 0;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 0x41Eu:
        v5 = GetDlgItem(this[1], 1049);
        SendMessageW(v5, 0x1002u, 0, (LPARAM)(this + 23));
        v6 = GetDlgItem(this[1], 1050);
        SendMessageW(v6, 0x1002u, 0, (LPARAM)(this + 23));
        return 0;
      case 1u:
        sub_47E920((int)this);
        return 0;
      case 2u:
        EndDialog(this[1], 0);
        return 0;
    }
  }
  return 0;
}

//----- (0047EE10) --------------------------------------------------------
char **__usercall sub_47EE10@<eax>(int a1@<edi>)
{
  int v1; // ebx
  char **v2; // eax
  int v3; // ecx
  int v4; // ebx
  char **v5; // eax
  int v6; // ecx
  int v7; // ebx
  char **v8; // eax
  int v9; // ecx
  int v10; // ebx
  char **v11; // eax
  int v12; // ecx
  int v13; // ebx
  char **result; // eax
  int v15; // ecx
  int v16; // [esp-4h] [ebp-1Ch]
  int v17; // [esp-4h] [ebp-1Ch]
  int v18; // [esp-4h] [ebp-1Ch]
  int v19; // [esp-4h] [ebp-1Ch]
  int v20; // [esp-4h] [ebp-1Ch]
  int v21; // [esp+8h] [ebp-10h] BYREF
  int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 60);
  v16 = *(_DWORD *)(v1 + 4);
  v21 = 32;
  v22 = 1060;
  v23 = 0;
  v2 = sub_420A20((char **)&v21, (char *)v1, v16);
  v3 = *(_DWORD *)(a1 + 64);
  if ( v3 == 268435454 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 64) = v3 + 1;
  *(_DWORD *)(v1 + 4) = v2;
  *(_DWORD *)v2[1] = v2;
  v4 = *(_DWORD *)(a1 + 60);
  v17 = *(_DWORD *)(v4 + 4);
  v21 = 2;
  v22 = 1061;
  v23 = 0;
  v5 = sub_420A20((char **)&v21, (char *)v4, v17);
  v6 = *(_DWORD *)(a1 + 64);
  if ( v6 == 268435454 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 64) = v6 + 1;
  *(_DWORD *)(v4 + 4) = v5;
  *(_DWORD *)v5[1] = v5;
  v7 = *(_DWORD *)(a1 + 60);
  v18 = *(_DWORD *)(v7 + 4);
  v21 = 4;
  v22 = 1059;
  v23 = 0;
  v8 = sub_420A20((char **)&v21, (char *)v7, v18);
  v9 = *(_DWORD *)(a1 + 64);
  if ( v9 == 268435454 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 64) = v9 + 1;
  *(_DWORD *)(v7 + 4) = v8;
  *(_DWORD *)v8[1] = v8;
  v10 = *(_DWORD *)(a1 + 60);
  v19 = *(_DWORD *)(v10 + 4);
  v21 = 1;
  v22 = 1062;
  v23 = 0;
  v11 = sub_420A20((char **)&v21, (char *)v10, v19);
  v12 = *(_DWORD *)(a1 + 64);
  if ( v12 == 268435454 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 64) = v12 + 1;
  *(_DWORD *)(v10 + 4) = v11;
  *(_DWORD *)v11[1] = v11;
  v13 = *(_DWORD *)(a1 + 60);
  v20 = *(_DWORD *)(v13 + 4);
  v21 = 0x2000;
  v22 = 1063;
  v23 = 1;
  result = sub_420A20((char **)&v21, (char *)v13, v20);
  v15 = *(_DWORD *)(a1 + 64);
  if ( v15 == 268435454 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 64) = v15 + 1;
  *(_DWORD *)(v13 + 4) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0047EFB0) --------------------------------------------------------
BOOL __usercall sub_47EFB0@<eax>(int a1@<esi>)
{
  int v1; // edi
  HWND DlgItem; // eax
  HWND v3; // eax
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-14h] BYREF

  v1 = **(_DWORD **)(a1 + 48);
  FileTimeToSystemTime((const FILETIME *)(v1 + 548), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0, &SystemTime, (LPSYSTEMTIME)(a1 + 76));
  FileTimeToSystemTime((const FILETIME *)(v1 + 532), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0, &SystemTime, (LPSYSTEMTIME)(a1 + 92));
  FileTimeToSystemTime((const FILETIME *)(v1 + 540), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0, &SystemTime, (LPSYSTEMTIME)(a1 + 92));
  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1043);
  SendMessageW(DlgItem, 0x1002u, 0, a1 + 76);
  v3 = GetDlgItem(*(HWND *)(a1 + 4), 1048);
  SendMessageW(v3, 0x1002u, 0, a1 + 76);
  v4 = GetDlgItem(*(HWND *)(a1 + 4), 1049);
  SendMessageW(v4, 0x1002u, 0, a1 + 92);
  v5 = GetDlgItem(*(HWND *)(a1 + 4), 1050);
  SendMessageW(v5, 0x1002u, 0, a1 + 92);
  v6 = GetDlgItem(*(HWND *)(a1 + 4), 1051);
  SendMessageW(v6, 0x1002u, 0, a1 + 92);
  v7 = GetDlgItem(*(HWND *)(a1 + 4), 1052);
  SendMessageW(v7, 0x1002u, 0, a1 + 92);
  v8 = GetDlgItem(*(HWND *)(a1 + 4), 1043);
  SendMessageW(v8, 0x1002u, 1u, 0);
  v9 = GetDlgItem(*(HWND *)(a1 + 4), 1048);
  EnableWindow(v9, 0);
  v10 = GetDlgItem(*(HWND *)(a1 + 4), 1111);
  EnableWindow(v10, 0);
  v11 = GetDlgItem(*(HWND *)(a1 + 4), 1049);
  SendMessageW(v11, 0x1002u, 1u, 0);
  v12 = GetDlgItem(*(HWND *)(a1 + 4), 1050);
  EnableWindow(v12, 0);
  v13 = GetDlgItem(*(HWND *)(a1 + 4), 1054);
  EnableWindow(v13, 0);
  v14 = GetDlgItem(*(HWND *)(a1 + 4), 1051);
  SendMessageW(v14, 0x1002u, 1u, 0);
  v15 = GetDlgItem(*(HWND *)(a1 + 4), 1052);
  EnableWindow(v15, 0);
  v16 = GetDlgItem(*(HWND *)(a1 + 4), 1055);
  return EnableWindow(v16, 0);
}

//----- (0047F1A0) --------------------------------------------------------
int __thiscall sub_47F1A0(int this)
{
  _DWORD *v2; // edx
  _DWORD *v3; // eax
  int v4; // edi
  HWND DlgItem; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  HWND v14; // eax
  WPARAM v15; // ecx
  HWND v16; // edi
  _DWORD *v17; // ebx
  HWND Parent; // eax
  int v20[278]; // [esp+Ch] [ebp-474h] BYREF
  WPARAM v21; // [esp+464h] [ebp-1Ch]
  WPARAM v22; // [esp+468h] [ebp-18h]
  WPARAM wParam; // [esp+46Ch] [ebp-14h]
  int v24; // [esp+470h] [ebp-10h]
  WPARAM v25; // [esp+474h] [ebp-Ch]
  int v26; // [esp+478h] [ebp-8h]
  HWND hWnd; // [esp+47Ch] [ebp-4h]

  sub_47EE10(this);
  sub_47EFB0(this);
  v2 = *(_DWORD **)(this + 48);
  v26 = *(_DWORD *)(this + 52);
  wParam = 0;
  v22 = 0;
  v25 = 0;
  v21 = 0;
  v24 = 0;
  v3 = (_DWORD *)*v2;
  if ( (_DWORD *)*v2 == v2 )
    goto LABEL_16;
  do
  {
    qmemcpy(v20, v3 + 2, sizeof(v20));
    if ( (v20[130] & 0x20) != 0 )
      ++wParam;
    if ( (v20[130] & 2) != 0 )
      ++v22;
    if ( (v20[130] & 4) != 0 )
      ++v25;
    if ( (v20[130] & 1) != 0 )
      ++v21;
    if ( (v20[130] & 0x2000) == 0 )
      ++v24;
    v3 = (_DWORD *)*v3;
  }
  while ( v3 != v2 );
  if ( !wParam || wParam == v26 )
LABEL_16:
    v4 = 1;
  else
    v4 = 0;
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1060);
  if ( v4 )
    SendMessageW(DlgItem, 0xF4u, 3u, 0);
  if ( !v22 || (hWnd = 0, v22 == v26) )
    hWnd = (HWND)1;
  v6 = GetDlgItem(*(HWND *)(this + 4), 1061);
  if ( hWnd )
    SendMessageW(v6, 0xF4u, 3u, 0);
  if ( !v25 || (hWnd = 0, v25 == v26) )
    hWnd = (HWND)1;
  v7 = GetDlgItem(*(HWND *)(this + 4), 1059);
  if ( hWnd )
    SendMessageW(v7, 0xF4u, 3u, 0);
  if ( !v21 || (hWnd = 0, v21 == v26) )
    hWnd = (HWND)1;
  v8 = GetDlgItem(*(HWND *)(this + 4), 1062);
  if ( hWnd )
    SendMessageW(v8, 0xF4u, 3u, 0);
  if ( !v24 || (hWnd = 0, v24 == v26) )
    hWnd = (HWND)1;
  v9 = GetDlgItem(*(HWND *)(this + 4), 1063);
  if ( hWnd )
    SendMessageW(v9, 0xF4u, 3u, 0);
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1060);
  v10 = wParam;
  if ( wParam )
    v10 = (wParam != v26) + 1;
  SendMessageW(hWnd, 0xF1u, v10, 0);
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1061);
  v11 = v22;
  if ( v22 )
    v11 = (v22 != v26) + 1;
  SendMessageW(hWnd, 0xF1u, v11, 0);
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1059);
  v12 = v25;
  if ( v25 )
    v12 = (v25 != v26) + 1;
  SendMessageW(hWnd, 0xF1u, v12, 0);
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1062);
  v13 = v21;
  if ( v21 )
    v13 = (v21 != v26) + 1;
  SendMessageW(hWnd, 0xF1u, v13, 0);
  v14 = GetDlgItem(*(HWND *)(this + 4), 1063);
  v15 = 0;
  if ( v24 )
  {
    LOBYTE(v15) = v24 != v26;
    ++v15;
  }
  SendMessageW(v14, 0xF1u, v15, 0);
  v16 = *(HWND *)(this + 4);
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 132) = 0;
  v17 = *(_DWORD **)(this + 72);
  if ( v17[1] )
  {
    SetWindowPos(v16, 0, v17[2], v17[3], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v16);
    sub_4697F0(v16, Parent);
  }
  return 0;
}

//----- (0047F480) --------------------------------------------------------
int *sub_47F480()
{
  if ( (dword_4F1B50 & 1) == 0 )
  {
    dword_4F1B50 |= 1u;
    sub_4653E0((int)&dword_4F03B8, (int)L"SetFileAttributes");
    dword_4F03B8 = (int)&CSetFileAttributesDialogPersistentSettings::`vftable';
    atexit(sub_4BCD30);
  }
  return &dword_4F03B8;
}
// 4C6D48: using guessed type wchar_t aSetfileattribu[18];
// 4CC24C: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;
// 4F1B50: using guessed type int dword_4F1B50;

//----- (0047F4C0) --------------------------------------------------------
int __thiscall sub_47F4C0(void *this, int a2, void *a3, int a4, int a5)
{
  char ***v5; // esi
  char **v6; // eax
  _DWORD *v7; // eax
  void ***v8; // ecx
  void **v9; // eax
  void *v10; // ecx
  void **v11; // esi
  int v13[3]; // [esp+10h] [ebp-2Ch] BYREF
  int pExceptionObject[3]; // [esp+1Ch] [ebp-20h] BYREF
  char *v15; // [esp+28h] [ebp-14h] BYREF
  char *v16; // [esp+2Ch] [ebp-10h] BYREF
  int v17; // [esp+38h] [ebp-4h]

  v17 = 0;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(a2 + 12) = 167;
  *(_DWORD *)(a2 + 16) = this;
  *(_BYTE *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  LOBYTE(v17) = 1;
  *(_DWORD *)a2 = &CSetFileAttributesDialog::`vftable';
  v5 = (char ***)(a2 + 48);
  *(_DWORD *)(a2 + 52) = 0;
  v6 = (char **)operator new(0x460u);
  if ( !v6 )
  {
    v15 = 0;
    std::exception::exception((std::exception *)v13, (const char *const *)&v15);
    v13[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v13, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v5 = v6;
  *v6 = (char *)v6;
  (*v5)[1] = (char *)*v5;
  LOBYTE(v17) = 2;
  *(_DWORD *)(a2 + 64) = 0;
  v7 = operator new(0x18u);
  if ( !v7 )
  {
    v16 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v16);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a2 + 60) = v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a2 + 60) + 4) = *(_DWORD *)(a2 + 60);
  LOBYTE(v17) = 3;
  if ( v5 != (char ***)&a3 )
    sub_417AD0(v5, *(_DWORD *)a3, (int)a3, a2);
  if ( (dword_4F1B50 & 1) == 0 )
  {
    dword_4F1B50 |= 1u;
    sub_4653E0((int)&dword_4F03B8, (int)L"SetFileAttributes");
    dword_4F03B8 = (int)&CSetFileAttributesDialogPersistentSettings::`vftable';
    atexit(sub_4BCD30);
  }
  v8 = (void ***)a3;
  *(_DWORD *)(a2 + 72) = &dword_4F03B8;
  v9 = *v8;
  *v8 = (void **)v8;
  *((_DWORD *)a3 + 1) = a3;
  v10 = a3;
  a4 = 0;
  if ( v9 != a3 )
  {
    do
    {
      v11 = (void **)*v9;
      operator delete(v9);
      v10 = a3;
      v9 = v11;
    }
    while ( v11 != a3 );
  }
  operator delete(v10);
  return a2;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C6D48: using guessed type wchar_t aSetfileattribu[18];
// 4CC214: using guessed type void *CSetFileAttributesDialog::`vftable';
// 4CC24C: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;
// 4F1B50: using guessed type int dword_4F1B50;

//----- (0047F650) --------------------------------------------------------
int __thiscall sub_47F650(_DWORD *this, LPCWSTR lpString1, wchar_t *String)
{
  int result; // eax

  result = lstrcmpiW(lpString1, L"Folder");
  if ( !result )
  {
    result = _wtoi(String);
    this[135] = result;
  }
  return result;
}

//----- (0047F680) --------------------------------------------------------
LSTATUS __thiscall sub_47F680(BYTE *this, HKEY hKey)
{
  DWORD cbData; // [esp+0h] [ebp-4h] BYREF

  cbData = 4;
  return RegQueryValueExW(hKey, L"Folder", 0, 0, this + 540, &cbData);
}

//----- (0047F6B0) --------------------------------------------------------
LSTATUS __thiscall sub_47F6B0(_DWORD *this, HKEY hKey)
{
  BYTE Data[4]; // [esp+0h] [ebp-4h] BYREF

  *(_DWORD *)Data = this;
  *(_DWORD *)Data = this[135];
  return RegSetValueExW(hKey, L"Folder", 0, 4u, Data, 4u);
}

//----- (0047F740) --------------------------------------------------------
void __usercall sub_47F740(int a1@<edi>, int a2@<esi>)
{
  HWND DlgItem; // eax
  LPARAM v3; // ecx
  UINT v4; // eax
  LPARAM lParam[13]; // [esp+0h] [ebp-138h] BYREF
  WCHAR Buffer[128]; // [esp+34h] [ebp-104h] BYREF

  if ( (*(_BYTE *)(a1 + 20) & 2) != 0 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a2 + 4), 1085);
    v3 = *(_DWORD *)(a1 + 12);
    lParam[0] = 4;
    lParam[1] = v3;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
    v4 = (*(int (__thiscall **)(_DWORD, LPARAM))(**(_DWORD **)(a2 + 48) + 28))(*(_DWORD *)(a2 + 48), lParam[8]);
    LoadStringW(*(HINSTANCE *)(a2 + 8), v4, Buffer, 128);
    SetDlgItemTextW(*(HWND *)(a2 + 4), 1001, Buffer);
  }
}

//----- (0047F850) --------------------------------------------------------
int __thiscall sub_47F850(HICON *this)
{
  DestroyIcon(this[32]);
  return 0;
}

//----- (0047F860) --------------------------------------------------------
int __thiscall sub_47F860(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (0047F870) --------------------------------------------------------
int __thiscall sub_47F870(void *this, int a2)
{
  if ( *(_DWORD *)(a2 + 8) == -100 )
    sub_47F740(a2, (int)this);
  return 0;
}

//----- (0047F890) --------------------------------------------------------
HRESULT __thiscall sub_47F890(int *this, int a2, int a3)
{
  _itow_s(this[135], Buffer, 0x40u, 10);
  return sub_464A60(a2, a3, (OLECHAR *)L"Folder", Buffer);
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (0047F900) --------------------------------------------------------
LRESULT __thiscall sub_47F900(void *this, int a2)
{
  _DWORD **v2; // esi
  HWND DlgItem; // ebx
  _DWORD **v4; // eax
  _DWORD *v5; // esi
  WPARAM v6; // edi
  int v7; // edx
  LPARAM v8; // ebx
  HINSTANCE v9; // ecx
  UINT v10; // eax
  LPARAM v12[3]; // [esp+Ch] [ebp-108h] BYREF
  int v13; // [esp+18h] [ebp-FCh]
  int v14; // [esp+1Ch] [ebp-F8h]
  LPARAM lParam[14]; // [esp+40h] [ebp-D4h] BYREF
  int v16; // [esp+78h] [ebp-9Ch]
  int v17; // [esp+7Ch] [ebp-98h]
  HINSTANCE hInstance; // [esp+80h] [ebp-94h]
  int v19; // [esp+84h] [ebp-90h]
  _DWORD *i; // [esp+88h] [ebp-8Ch]
  HWND hWnd; // [esp+8Ch] [ebp-88h]
  WCHAR Buffer[64]; // [esp+90h] [ebp-84h] BYREF

  v19 = a2;
  switch ( (unsigned int)this )
  {
    case 0u:
      v2 = *(_DWORD ***)(a2 + 52);
      break;
    case 1u:
      v2 = *(_DWORD ***)(a2 + 56);
      break;
    case 2u:
      v2 = *(_DWORD ***)(a2 + 60);
      break;
    case 3u:
      v2 = *(_DWORD ***)(a2 + 72);
      break;
    case 4u:
      v2 = *(_DWORD ***)(a2 + 76);
      break;
    case 5u:
      v2 = *(_DWORD ***)(a2 + 68);
      break;
    case 6u:
      v2 = *(_DWORD ***)(a2 + 64);
      break;
    default:
      v2 = 0;
      break;
  }
  DlgItem = GetDlgItem(*(HWND *)(a2 + 4), 1085);
  hWnd = DlgItem;
  SendMessageW(DlgItem, 0x1009u, 0, 0);
  v4 = (_DWORD **)*v2;
  v5 = (_DWORD *)**v2;
  v6 = 0;
  for ( i = v4; v5 != i; ++v6 )
  {
    v7 = v5[4];
    v8 = v5[2];
    v16 = v5[3];
    v9 = *(HINSTANCE *)(v19 + 8);
    v17 = v7;
    hInstance = v9;
    v10 = (*(int (__thiscall **)(_DWORD, LPARAM))(**(_DWORD **)(v19 + 48) + 24))(*(_DWORD *)(v19 + 48), v8);
    LoadStringW(hInstance, v10, Buffer, 64);
    lParam[8] = v8;
    DlgItem = hWnd;
    lParam[0] = 5;
    lParam[1] = v6;
    lParam[2] = 0;
    lParam[5] = (LPARAM)Buffer;
    SendMessageW(hWnd, 0x104Du, 0, (LPARAM)lParam);
    v14 = 61440;
    v13 = ((v16 != 0) + 1) << 12;
    SendMessageW(DlgItem, 0x102Bu, v6, (LPARAM)v12);
    v5 = (_DWORD *)*v5;
  }
  v14 = 2;
  v13 = 2;
  return SendMessageW(DlgItem, 0x102Bu, 0, (LPARAM)v12);
}

//----- (0047FAC0) --------------------------------------------------------
int __thiscall sub_47FAC0(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  int result; // eax
  LRESULT v9; // [esp+Ch] [ebp-1Ch] BYREF
  int v10; // [esp+10h] [ebp-18h] BYREF
  struct tagRECT Rect; // [esp+14h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 132);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  v9 = SendDlgItemMessageW(*(HWND *)(this + 4), 1186, 0x147u, 0, 0);
  sub_417A20((_DWORD *)(this + 80), &v9, &v10);
  *(_DWORD *)(*(_DWORD *)(this + 132) + 540) = *(_DWORD *)(v10 + 12);
  result = *(_DWORD *)(this + 132);
  *(_DWORD *)(result + 4) = 1;
  return result;
}

//----- (0047FB60) --------------------------------------------------------
char **__stdcall sub_47FB60(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char **v4; // eax
  char *v5; // ecx
  char **v6; // eax
  char *v7; // ecx
  char **v8; // eax
  char *v9; // ecx
  char **v10; // eax
  char *v11; // ecx
  char *v12; // eax
  char **v13; // eax
  char *v14; // ecx
  char **v15; // eax
  char *v16; // ecx
  char *v17; // eax
  char **v18; // eax
  char *v19; // ecx
  char **v20; // eax
  char *v21; // ecx
  char **v22; // eax
  char *v23; // ecx
  char *v24; // ebx
  char **result; // eax
  char *v26; // ecx
  char *v27; // [esp-8h] [ebp-20h]
  char *v28; // [esp-8h] [ebp-20h]
  char *v29; // [esp-8h] [ebp-20h]
  char *v30; // [esp-8h] [ebp-20h]
  char *v31; // [esp-8h] [ebp-20h]
  char *v32; // [esp-8h] [ebp-20h]
  char *v33; // [esp-8h] [ebp-20h]
  char *v34; // [esp-8h] [ebp-20h]
  char *v35; // [esp-8h] [ebp-20h]
  int v36; // [esp-4h] [ebp-1Ch]
  int v37; // [esp-4h] [ebp-1Ch]
  int v38; // [esp-4h] [ebp-1Ch]
  int v39; // [esp-4h] [ebp-1Ch]
  int v40; // [esp-4h] [ebp-1Ch]
  int v41; // [esp-4h] [ebp-1Ch]
  int v42; // [esp-4h] [ebp-1Ch]
  int v43; // [esp-4h] [ebp-1Ch]
  int v44; // [esp-4h] [ebp-1Ch]
  int v45; // [esp-4h] [ebp-1Ch]
  int v46; // [esp-4h] [ebp-1Ch]
  int v47; // [esp+Ch] [ebp-Ch] BYREF
  int v48; // [esp+10h] [ebp-8h]
  int v49; // [esp+14h] [ebp-4h]
  char *v50; // [esp+20h] [ebp+8h]
  char *v51; // [esp+20h] [ebp+8h]
  char *v52; // [esp+20h] [ebp+8h]
  char *v53; // [esp+20h] [ebp+8h]
  char *v54; // [esp+20h] [ebp+8h]
  char *v55; // [esp+20h] [ebp+8h]
  char *v56; // [esp+20h] [ebp+8h]
  char *v57; // [esp+20h] [ebp+8h]
  char *v58; // [esp+20h] [ebp+8h]
  char *v59; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v36 = *((_DWORD *)*a2 + 1);
  v27 = *a2;
  v47 = 1085;
  v48 = 1;
  v49 = 0;
  v50 = v27;
  v2 = sub_41EEB0((char **)&v47, v27, v36);
  v3 = a2[1];
  if ( v3 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v50 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v37 = *((_DWORD *)*a2 + 1);
  v28 = *a2;
  v47 = 1053;
  v48 = 0;
  v49 = 1;
  v51 = v28;
  v4 = sub_41EEB0((char **)&v47, v28, v37);
  v5 = a2[1];
  if ( v5 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v5 + 1;
  *((_DWORD *)v51 + 1) = v4;
  *(_DWORD *)v4[1] = v4;
  v38 = *((_DWORD *)*a2 + 1);
  v29 = *a2;
  v47 = 1054;
  v48 = 0;
  v49 = 1;
  v52 = v29;
  v6 = sub_41EEB0((char **)&v47, v29, v38);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v52 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v39 = *((_DWORD *)*a2 + 1);
  v30 = *a2;
  v47 = 1174;
  v48 = 0;
  v49 = 2;
  v53 = v30;
  v8 = sub_41EEB0((char **)&v47, v30, v39);
  v9 = a2[1];
  if ( v9 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v9 + 1;
  *((_DWORD *)v53 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v40 = *((_DWORD *)*a2 + 1);
  v31 = *a2;
  v47 = 1001;
  v48 = 0;
  v49 = 2;
  v54 = v31;
  v10 = sub_41EEB0((char **)&v47, v31, v40);
  v11 = a2[1];
  if ( v11 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v11 + 1;
  *((_DWORD *)v54 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  v12 = *a2;
  v48 = 1;
  v49 = 1;
  v41 = *((_DWORD *)v12 + 1);
  v47 = 1001;
  v55 = v12;
  v13 = sub_41EEB0((char **)&v47, v12, v41);
  v14 = a2[1];
  if ( v14 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v14 + 1;
  *((_DWORD *)v55 + 1) = v13;
  *(_DWORD *)v13[1] = v13;
  v42 = *((_DWORD *)*a2 + 1);
  v32 = *a2;
  v47 = 1254;
  v48 = 0;
  v49 = 2;
  v56 = v32;
  v15 = sub_41EEB0((char **)&v47, v32, v42);
  v16 = a2[1];
  if ( v16 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v16 + 1;
  *((_DWORD *)v56 + 1) = v15;
  *(_DWORD *)v15[1] = v15;
  v17 = *a2;
  v48 = 1;
  v49 = 1;
  v43 = *((_DWORD *)v17 + 1);
  v47 = 1254;
  v57 = v17;
  v18 = sub_41EEB0((char **)&v47, v17, v43);
  v19 = a2[1];
  if ( v19 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v19 + 1;
  *((_DWORD *)v57 + 1) = v18;
  *(_DWORD *)v18[1] = v18;
  v44 = *((_DWORD *)*a2 + 1);
  v33 = *a2;
  v47 = 1;
  v48 = 0;
  v49 = 0;
  v58 = v33;
  v20 = sub_41EEB0((char **)&v47, v33, v44);
  v21 = a2[1];
  if ( v21 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v21 + 1;
  *((_DWORD *)v58 + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  v45 = *((_DWORD *)*a2 + 1);
  v34 = *a2;
  v47 = 2;
  v48 = 0;
  v49 = 0;
  v59 = v34;
  v22 = sub_41EEB0((char **)&v47, v34, v45);
  v23 = a2[1];
  if ( v23 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v23 + 1;
  *((_DWORD *)v59 + 1) = v22;
  *(_DWORD *)v22[1] = v22;
  v48 = 0;
  v49 = 0;
  v24 = *a2;
  v46 = *((_DWORD *)*a2 + 1);
  v35 = *a2;
  v47 = 1304;
  result = sub_41EEB0((char **)&v47, v35, v46);
  v26 = a2[1];
  if ( v26 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v26 + 1;
  *((_DWORD *)v24 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0047FEB0) --------------------------------------------------------
void __usercall sub_47FEB0(_DWORD *a1@<edi>)
{
  void *v1; // esi

  *a1 = &CSetDefaultColumnsDialog::`vftable';
  sub_4179C0((int)(a1 + 20));
  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC1C4: using guessed type void *CSetDefaultColumnsDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0047FEE0) --------------------------------------------------------
int *sub_47FEE0()
{
  if ( (dword_4F1B54 & 1) == 0 )
  {
    dword_4F1B54 |= 1u;
    sub_4653E0((int)&dword_4F05D8, (int)L"SetDefaultColumns");
    dword_4F05D8 = (int)&CSetDefaultColumnsDialogPersistentSettings::`vftable';
    dword_4F07F4 = 0;
    atexit(sub_4BCD20);
  }
  return &dword_4F05D8;
}
// 4C6D6C: using guessed type wchar_t aSetdefaultcolu[18];
// 4CC1FC: using guessed type void *CSetDefaultColumnsDialogPersistentSettings::`vftable';
// 4F05D8: using guessed type int dword_4F05D8;
// 4F07F4: using guessed type int dword_4F07F4;
// 4F1B54: using guessed type int dword_4F1B54;

//----- (0047FF30) --------------------------------------------------------
int __thiscall sub_47FF30(int this)
{
  HMODULE ModuleHandleW; // eax
  HICON IconW; // eax
  HWND DlgItem; // esi
  LRESULT (__stdcall *v5)(HWND, UINT, WPARAM, LPARAM); // edi
  int v6; // eax
  int v7; // ebx
  char **v8; // eax
  int v9; // ecx
  int v10; // eax
  ITEMIDLIST **v11; // ecx
  char **v12; // eax
  int v13; // ecx
  int v14; // eax
  ITEMIDLIST **v15; // ecx
  char **v16; // eax
  int v17; // ecx
  int v18; // eax
  ITEMIDLIST **v19; // ecx
  char **v20; // eax
  int v21; // ecx
  int v22; // eax
  ITEMIDLIST **v23; // ecx
  char **v24; // eax
  int v25; // ecx
  int v26; // eax
  ITEMIDLIST **v27; // ecx
  char **v28; // eax
  int v29; // ecx
  int v30; // eax
  ITEMIDLIST **v31; // ecx
  char **v32; // eax
  int v33; // ecx
  _DWORD *v34; // esi
  _DWORD *v35; // ecx
  _DWORD *i; // eax
  HWND v37; // ebx
  HWND v38; // edi
  _DWORD *v39; // esi
  HWND Parent; // eax
  ITEMIDLIST *v42; // [esp-8h] [ebp-258h]
  ITEMIDLIST *v43; // [esp-8h] [ebp-258h]
  ITEMIDLIST *v44; // [esp-8h] [ebp-258h]
  ITEMIDLIST *v45; // [esp-8h] [ebp-258h]
  ITEMIDLIST *v46; // [esp-8h] [ebp-258h]
  ITEMIDLIST *v47; // [esp-8h] [ebp-258h]
  HWND v48; // [esp-8h] [ebp-258h]
  int v49; // [esp-4h] [ebp-254h]
  int v50; // [esp-4h] [ebp-254h]
  int v51; // [esp-4h] [ebp-254h]
  int v52; // [esp-4h] [ebp-254h]
  int v53; // [esp-4h] [ebp-254h]
  int v54; // [esp-4h] [ebp-254h]
  int v55; // [esp-4h] [ebp-254h]
  LPITEMIDLIST ppidl; // [esp+Ch] [ebp-244h] BYREF
  int v57; // [esp+10h] [ebp-240h] BYREF
  int v58; // [esp+14h] [ebp-23Ch]
  HWND hWnd; // [esp+18h] [ebp-238h]
  int v60; // [esp+1Ch] [ebp-234h]
  LPARAM v61[8]; // [esp+20h] [ebp-230h] BYREF
  __int16 lParam[262]; // [esp+40h] [ebp-210h] BYREF

  v60 = this;
  ModuleHandleW = GetModuleHandleW(0);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *(_DWORD *)(this + 128) = IconW;
  SetClassLongW(*(HWND *)(this + 4), -34, (LONG)IconW);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1186);
  hWnd = DlgItem;
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 3, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
  }
  v5 = SendMessageW;
  v57 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v6 = **(_DWORD **)(this + 84);
  v7 = this + 80;
  v49 = *(_DWORD *)(v6 + 4);
  v58 = 2;
  ppidl = (LPITEMIDLIST)v6;
  v8 = sub_419770((char **)&v57, (char *)v6, v49);
  v9 = *(_DWORD *)(v7 + 8);
  if ( v9 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v9 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  LoadStringW(*(HINSTANCE *)(v60 + 8), 0x2014u, (LPWSTR)lParam, 260);
  v10 = SendMessageW(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v11 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v10;
  v50 = *(_DWORD *)((char *)&(*v11)[1].mkid.cb + 1);
  v42 = *v11;
  v58 = 0;
  ppidl = v42;
  v12 = sub_419770((char **)&v57, (char *)v42, v50);
  v13 = *(_DWORD *)(v7 + 8);
  if ( v13 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v13 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v12;
  *(_DWORD *)v12[1] = v12;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 17, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
    v5 = SendMessageW;
  }
  v14 = v5(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v15 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v14;
  v51 = *(_DWORD *)((char *)&(*v15)[1].mkid.cb + 1);
  v43 = *v15;
  v58 = 1;
  ppidl = v43;
  v16 = sub_419770((char **)&v57, (char *)v43, v51);
  v17 = *(_DWORD *)(v7 + 8);
  if ( v17 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v17 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v16;
  *(_DWORD *)v16[1] = v16;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 49, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
    v5 = SendMessageW;
  }
  v18 = v5(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v19 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v18;
  v52 = *(_DWORD *)((char *)&(*v19)[1].mkid.cb + 1);
  v44 = *v19;
  v58 = 3;
  ppidl = v44;
  v20 = sub_419770((char **)&v57, (char *)v44, v52);
  v21 = *(_DWORD *)(v7 + 8);
  if ( v21 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v21 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 18, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
    v5 = SendMessageW;
  }
  v22 = v5(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v23 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v22;
  v53 = *(_DWORD *)((char *)&(*v23)[1].mkid.cb + 1);
  v45 = *v23;
  v58 = 4;
  ppidl = v45;
  v24 = sub_419770((char **)&v57, (char *)v45, v53);
  v25 = *(_DWORD *)(v7 + 8);
  if ( v25 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v25 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v24;
  *(_DWORD *)v24[1] = v24;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 4, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
    v5 = SendMessageW;
  }
  v26 = v5(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v27 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v26;
  v54 = *(_DWORD *)((char *)&(*v27)[1].mkid.cb + 1);
  v46 = *v27;
  v58 = 5;
  ppidl = v46;
  v28 = sub_419770((char **)&v57, (char *)v46, v54);
  v29 = *(_DWORD *)(v7 + 8);
  if ( v29 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v29 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v28;
  *(_DWORD *)v28[1] = v28;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  ppidl = 0;
  if ( !SHGetFolderLocation(0, 10, 0, 0, &ppidl) )
  {
    sub_466630(ppidl, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppidl);
    v5 = SendMessageW;
  }
  v30 = v5(hWnd, 0x14Au, 0xFFFFFFFF, (LPARAM)lParam);
  v31 = *(ITEMIDLIST ***)(v7 + 4);
  v57 = v30;
  v55 = *(_DWORD *)((char *)&(*v31)[1].mkid.cb + 1);
  v47 = *v31;
  v58 = 6;
  ppidl = v47;
  v32 = sub_419770((char **)&v57, (char *)v47, v55);
  v33 = *(_DWORD *)(v7 + 8);
  if ( v33 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(v7 + 8) = v33 + 1;
  *(_DWORD *)((char *)&ppidl[1].mkid.cb + 1) = v32;
  *(_DWORD *)v32[1] = v32;
  sub_418A00(v7, (int)&v57, **(_DWORD **)(v7 + 4) + 8, **(void ***)(v7 + 4));
  v34 = (_DWORD *)v60;
  v35 = *(_DWORD **)(v60 + 84);
  for ( i = (_DWORD *)*v35; i != v35; i = (_DWORD *)*i )
  {
    if ( i[3] == *(_DWORD *)(*(_DWORD *)(v60 + 132) + 540) )
      break;
  }
  v5(hWnd, 0x14Eu, i[2], 0);
  v48 = (HWND)v34[1];
  v34[31] = *(_DWORD *)(v34[33] + 540);
  v37 = GetDlgItem(v48, 1085);
  v5(v37, 0x1036u, 4u, 4);
  v61[0] = 2;
  v61[2] = 180;
  v5(v37, 0x1061u, 0, (LPARAM)v61);
  sub_47F900(*(void **)(v34[33] + 540), (int)v34);
  SetFocus(v37);
  v38 = (HWND)v34[1];
  v39 = (_DWORD *)v34[33];
  if ( v39[1] )
  {
    SetWindowPos(v38, 0, v39[2], v39[3], v39[4], v39[5], 4u);
  }
  else
  {
    Parent = GetParent(v38);
    sub_4697F0(v38, Parent);
  }
  return 0;
}
// 47FF30: using guessed type WCHAR lParam[262];

//----- (00480570) --------------------------------------------------------
int __thiscall sub_480570(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // esi
  bool v11; // zf
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // edx
  int result; // eax

  v10 = a2;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(v10 + 12) = 187;
  *(_DWORD *)(v10 + 16) = this;
  *(_BYTE *)(v10 + 28) = 1;
  *(_DWORD *)(v10 + 44) = 0;
  *(_DWORD *)(v10 + 24) = 0;
  *(_DWORD *)v10 = &CSetDefaultColumnsDialog::`vftable';
  sub_417FA0(v10 + 80, (char *)&a2 + 2);
  v11 = (dword_4F1B54 & 1) == 0;
  v12 = a4;
  v13 = a5;
  *(_DWORD *)(v10 + 48) = a3;
  v14 = a6;
  *(_DWORD *)(v10 + 52) = v12;
  v15 = a7;
  *(_DWORD *)(v10 + 56) = v13;
  v16 = a8;
  *(_DWORD *)(v10 + 60) = v14;
  v17 = a9;
  *(_DWORD *)(v10 + 64) = v15;
  v18 = a10;
  *(_DWORD *)(v10 + 68) = v16;
  *(_DWORD *)(v10 + 72) = v17;
  *(_DWORD *)(v10 + 76) = v18;
  if ( v11 )
  {
    dword_4F1B54 |= 1u;
    sub_4653E0((int)&dword_4F05D8, (int)L"SetDefaultColumns");
    dword_4F05D8 = (int)&CSetDefaultColumnsDialogPersistentSettings::`vftable';
    dword_4F07F4 = 0;
    atexit(sub_4BCD20);
  }
  result = v10;
  *(_DWORD *)(v10 + 132) = &dword_4F05D8;
  return result;
}
// 4C6D6C: using guessed type wchar_t aSetdefaultcolu[18];
// 4CC1C4: using guessed type void *CSetDefaultColumnsDialog::`vftable';
// 4CC1FC: using guessed type void *CSetDefaultColumnsDialogPersistentSettings::`vftable';
// 4F05D8: using guessed type int dword_4F05D8;
// 4F07F4: using guessed type int dword_4F07F4;
// 4F1B54: using guessed type int dword_4F1B54;

//----- (00480660) --------------------------------------------------------
void __fastcall sub_480660(int a1, int a2)
{
  char ***v4; // esi
  signed int v5; // ebx
  _DWORD *v6; // eax
  int v7; // edi
  char *i; // eax
  char *v9; // ecx
  char **v10; // eax
  LRESULT v11; // eax
  char *v12; // eax
  HWND v13; // edx
  char *v14; // ebx
  _DWORD *v15; // eax
  _DWORD *v16; // esi
  LPARAM lParam[8]; // [esp+10h] [ebp-70h] BYREF
  char *v18; // [esp+30h] [ebp-50h]
  int pExceptionObject[3]; // [esp+44h] [ebp-3Ch] BYREF
  char *v20[3]; // [esp+50h] [ebp-30h] BYREF
  _DWORD *v21; // [esp+5Ch] [ebp-24h] BYREF
  int v22; // [esp+60h] [ebp-20h]
  char *v23; // [esp+68h] [ebp-18h] BYREF
  HWND hWnd; // [esp+6Ch] [ebp-14h]
  char ***v25; // [esp+70h] [ebp-10h]
  int v26; // [esp+7Ch] [ebp-4h]

  hWnd = GetDlgItem(*(HWND *)(a2 + 4), 1085);
  switch ( a1 )
  {
    case 0:
      v4 = *(char ****)(a2 + 52);
      v25 = v4;
      break;
    case 1:
      v25 = *(char ****)(a2 + 56);
      v4 = v25;
      break;
    case 2:
      v25 = *(char ****)(a2 + 60);
      v4 = v25;
      break;
    case 3:
      v25 = *(char ****)(a2 + 72);
      v4 = v25;
      break;
    case 4:
      v25 = *(char ****)(a2 + 76);
      v4 = v25;
      break;
    case 5:
      v25 = *(char ****)(a2 + 68);
      v4 = v25;
      break;
    case 6:
      v25 = *(char ****)(a2 + 64);
      v4 = v25;
      break;
    default:
      v25 = 0;
      v4 = 0;
      break;
  }
  v5 = 0;
  v22 = 0;
  v6 = operator new(0x14u);
  v7 = (int)v6;
  if ( !v6 )
  {
    v23 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v23);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v6 = v6;
  v21 = v6;
  v6[1] = v6;
  v26 = 0;
  if ( SendMessageW(hWnd, 0x1004u, 0, 0) > 0 )
  {
    do
    {
      lParam[0] = 4;
      lParam[1] = v5;
      lParam[2] = 0;
      SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam);
      for ( i = **v4; i != (char *)*v4; i = *(char **)i )
      {
        if ( *((char **)i + 2) == v18 )
          break;
      }
      v9 = (char *)*((_DWORD *)i + 4);
      v20[0] = v18;
      v20[2] = v9;
      v20[1] = (char *)(((unsigned int)SendMessageW(hWnd, 0x102Cu, v5, 61440) >> 12) - 1);
      v10 = sub_41EEB0(v20, (char *)v7, *(_DWORD *)(v7 + 4));
      if ( v22 == 357913940 )
        std::_Xlength_error("list<T> too long");
      ++v22;
      *(_DWORD *)(v7 + 4) = v10;
      *(_DWORD *)v10[1] = v10;
      ++v5;
      v11 = SendMessageW(hWnd, 0x1004u, 0, 0);
      v4 = v25;
    }
    while ( v5 < v11 );
  }
  if ( v4 != &v21 )
  {
    v12 = **v4;
    v13 = *(HWND *)v7;
    **v4 = (char *)*v4;
    (*v4)[1] = (char *)*v4;
    hWnd = v13;
    v4[1] = 0;
    if ( v12 != (char *)*v4 )
    {
      do
      {
        v14 = *(char **)v12;
        operator delete(v12);
        v12 = v14;
      }
      while ( v14 != (char *)*v4 );
    }
    sub_40B870((int)v4, **v4, (int)hWnd, v7, (int)v23);
  }
  v15 = *(_DWORD **)v7;
  *(_DWORD *)v7 = v7;
  *(_DWORD *)(v7 + 4) = v7;
  if ( v15 != (_DWORD *)v7 )
  {
    do
    {
      v16 = (_DWORD *)*v15;
      operator delete(v15);
      v15 = v16;
    }
    while ( v16 != (_DWORD *)v7 );
  }
  operator delete((void *)v7);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004808B0) --------------------------------------------------------
LRESULT __usercall sub_4808B0@<eax>(int a1@<esi>)
{
  HWND DlgItem; // eax
  int v2; // edi
  LRESULT result; // eax
  int v4; // [esp+8h] [ebp-8h] BYREF
  LRESULT v5; // [esp+Ch] [ebp-4h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1186);
  v5 = SendMessageW(DlgItem, 0x147u, 0, 0);
  sub_417A20((_DWORD *)(a1 + 80), &v5, &v4);
  sub_480660(*(_DWORD *)(a1 + 124), a1);
  v2 = v4;
  result = sub_47F900(*(void **)(v4 + 12), a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(v2 + 12);
  return result;
}

//----- (00480910) --------------------------------------------------------
BOOL __usercall sub_480910@<eax>(int a1@<esi>)
{
  HWND DlgItem; // eax
  int v3; // [esp+4h] [ebp-8h] BYREF
  LRESULT v4; // [esp+8h] [ebp-4h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1186);
  v4 = SendMessageW(DlgItem, 0x147u, 0, 0);
  sub_417A20((_DWORD *)(a1 + 80), &v4, &v3);
  sub_480660(*(_DWORD *)(v3 + 12), a1);
  return EndDialog(*(HWND *)(a1 + 4), 1);
}

//----- (00480970) --------------------------------------------------------
int __thiscall sub_480970(HWND *this, unsigned int a2, int a3)
{
  HWND DlgItem; // edi
  int v6; // eax
  int v7; // eax

  if ( HIWORD(a2) == 1 )
    sub_4808B0((int)this);
  if ( (unsigned __int16)a2 > 0x41Du )
  {
    if ( (unsigned __int16)a2 != 1054 )
      return 0;
    DlgItem = GetDlgItem(this[1], 1085);
    v7 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
    if ( v7 == -1 )
      return 0;
    sub_468B50(DlgItem, v7, v7 + 1);
    goto LABEL_14;
  }
  switch ( (unsigned __int16)a2 )
  {
    case 0x41Du:
      DlgItem = GetDlgItem(this[1], 1085);
      v6 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
      if ( v6 == -1 )
        return 0;
      sub_468B50(DlgItem, v6, v6 - 1);
LABEL_14:
      SetFocus(DlgItem);
      return 0;
    case 1u:
      sub_480910((int)this);
      return 0;
    case 2u:
      EndDialog(this[1], 0);
      return 0;
  }
  return 0;
}

//----- (00480AB0) --------------------------------------------------------
void __usercall sub_480AB0(int a1@<edi>, int a2@<esi>)
{
  HWND DlgItem; // eax
  LPARAM v3; // ecx
  UINT v4; // eax
  LPARAM lParam[13]; // [esp+0h] [ebp-138h] BYREF
  WCHAR Buffer[128]; // [esp+34h] [ebp-104h] BYREF

  if ( (*(_BYTE *)(a1 + 20) & 2) != 0 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a2 + 4), 1085);
    v3 = *(_DWORD *)(a1 + 12);
    lParam[0] = 4;
    lParam[1] = v3;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
    v4 = (*(int (__thiscall **)(_DWORD, LPARAM))(**(_DWORD **)(a2 + 48) + 28))(*(_DWORD *)(a2 + 48), lParam[8]);
    LoadStringW(*(HINSTANCE *)(a2 + 8), v4, Buffer, 128);
    SetDlgItemTextW(*(HWND *)(a2 + 4), 1001, Buffer);
  }
}

//----- (00480B70) --------------------------------------------------------
int __thiscall sub_480B70(HICON *this)
{
  DestroyIcon(this[14]);
  return 0;
}

//----- (00480B80) --------------------------------------------------------
int __thiscall sub_480B80(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (00480B90) --------------------------------------------------------
int __thiscall sub_480B90(void *this, int a2)
{
  if ( *(_DWORD *)(a2 + 8) == -100 )
    sub_480AB0(a2, (int)this);
  return 0;
}

//----- (00480BB0) --------------------------------------------------------
int __thiscall sub_480BB0(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 60);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 60) + 4) = 1;
  return result;
}

//----- (00480C50) --------------------------------------------------------
char **__stdcall sub_480C50(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char **v4; // eax
  char *v5; // ecx
  char **v6; // eax
  char *v7; // ecx
  char **v8; // eax
  char *v9; // ecx
  char **v10; // eax
  char *v11; // ecx
  char *v12; // eax
  char **v13; // eax
  char *v14; // ecx
  char **v15; // eax
  char *v16; // ecx
  char *v17; // eax
  char **v18; // eax
  char *v19; // ecx
  char **v20; // eax
  char *v21; // ecx
  char **v22; // eax
  char *v23; // ecx
  char *v24; // ebx
  char **result; // eax
  char *v26; // ecx
  char *v27; // [esp-8h] [ebp-20h]
  char *v28; // [esp-8h] [ebp-20h]
  char *v29; // [esp-8h] [ebp-20h]
  char *v30; // [esp-8h] [ebp-20h]
  char *v31; // [esp-8h] [ebp-20h]
  char *v32; // [esp-8h] [ebp-20h]
  char *v33; // [esp-8h] [ebp-20h]
  char *v34; // [esp-8h] [ebp-20h]
  char *v35; // [esp-8h] [ebp-20h]
  int v36; // [esp-4h] [ebp-1Ch]
  int v37; // [esp-4h] [ebp-1Ch]
  int v38; // [esp-4h] [ebp-1Ch]
  int v39; // [esp-4h] [ebp-1Ch]
  int v40; // [esp-4h] [ebp-1Ch]
  int v41; // [esp-4h] [ebp-1Ch]
  int v42; // [esp-4h] [ebp-1Ch]
  int v43; // [esp-4h] [ebp-1Ch]
  int v44; // [esp-4h] [ebp-1Ch]
  int v45; // [esp-4h] [ebp-1Ch]
  int v46; // [esp-4h] [ebp-1Ch]
  int v47; // [esp+Ch] [ebp-Ch] BYREF
  int v48; // [esp+10h] [ebp-8h]
  int v49; // [esp+14h] [ebp-4h]
  char *v50; // [esp+20h] [ebp+8h]
  char *v51; // [esp+20h] [ebp+8h]
  char *v52; // [esp+20h] [ebp+8h]
  char *v53; // [esp+20h] [ebp+8h]
  char *v54; // [esp+20h] [ebp+8h]
  char *v55; // [esp+20h] [ebp+8h]
  char *v56; // [esp+20h] [ebp+8h]
  char *v57; // [esp+20h] [ebp+8h]
  char *v58; // [esp+20h] [ebp+8h]
  char *v59; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v36 = *((_DWORD *)*a2 + 1);
  v27 = *a2;
  v47 = 1085;
  v48 = 1;
  v49 = 0;
  v50 = v27;
  v2 = sub_41EEB0((char **)&v47, v27, v36);
  v3 = a2[1];
  if ( v3 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v50 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v37 = *((_DWORD *)*a2 + 1);
  v28 = *a2;
  v47 = 1053;
  v48 = 0;
  v49 = 1;
  v51 = v28;
  v4 = sub_41EEB0((char **)&v47, v28, v37);
  v5 = a2[1];
  if ( v5 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v5 + 1;
  *((_DWORD *)v51 + 1) = v4;
  *(_DWORD *)v4[1] = v4;
  v38 = *((_DWORD *)*a2 + 1);
  v29 = *a2;
  v47 = 1054;
  v48 = 0;
  v49 = 1;
  v52 = v29;
  v6 = sub_41EEB0((char **)&v47, v29, v38);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v52 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v39 = *((_DWORD *)*a2 + 1);
  v30 = *a2;
  v47 = 1174;
  v48 = 0;
  v49 = 2;
  v53 = v30;
  v8 = sub_41EEB0((char **)&v47, v30, v39);
  v9 = a2[1];
  if ( v9 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v9 + 1;
  *((_DWORD *)v53 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v40 = *((_DWORD *)*a2 + 1);
  v31 = *a2;
  v47 = 1001;
  v48 = 0;
  v49 = 2;
  v54 = v31;
  v10 = sub_41EEB0((char **)&v47, v31, v40);
  v11 = a2[1];
  if ( v11 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v11 + 1;
  *((_DWORD *)v54 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  v12 = *a2;
  v48 = 1;
  v49 = 1;
  v41 = *((_DWORD *)v12 + 1);
  v47 = 1001;
  v55 = v12;
  v13 = sub_41EEB0((char **)&v47, v12, v41);
  v14 = a2[1];
  if ( v14 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v14 + 1;
  *((_DWORD *)v55 + 1) = v13;
  *(_DWORD *)v13[1] = v13;
  v42 = *((_DWORD *)*a2 + 1);
  v32 = *a2;
  v47 = 1254;
  v48 = 0;
  v49 = 2;
  v56 = v32;
  v15 = sub_41EEB0((char **)&v47, v32, v42);
  v16 = a2[1];
  if ( v16 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v16 + 1;
  *((_DWORD *)v56 + 1) = v15;
  *(_DWORD *)v15[1] = v15;
  v17 = *a2;
  v48 = 1;
  v49 = 1;
  v43 = *((_DWORD *)v17 + 1);
  v47 = 1254;
  v57 = v17;
  v18 = sub_41EEB0((char **)&v47, v17, v43);
  v19 = a2[1];
  if ( v19 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v19 + 1;
  *((_DWORD *)v57 + 1) = v18;
  *(_DWORD *)v18[1] = v18;
  v44 = *((_DWORD *)*a2 + 1);
  v33 = *a2;
  v47 = 1;
  v48 = 0;
  v49 = 0;
  v58 = v33;
  v20 = sub_41EEB0((char **)&v47, v33, v44);
  v21 = a2[1];
  if ( v21 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v21 + 1;
  *((_DWORD *)v58 + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  v45 = *((_DWORD *)*a2 + 1);
  v34 = *a2;
  v47 = 2;
  v48 = 0;
  v49 = 0;
  v59 = v34;
  v22 = sub_41EEB0((char **)&v47, v34, v45);
  v23 = a2[1];
  if ( v23 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v23 + 1;
  *((_DWORD *)v59 + 1) = v22;
  *(_DWORD *)v22[1] = v22;
  v48 = 0;
  v49 = 0;
  v24 = *a2;
  v46 = *((_DWORD *)*a2 + 1);
  v35 = *a2;
  v47 = 1304;
  result = sub_41EEB0((char **)&v47, v35, v46);
  v26 = a2[1];
  if ( v26 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v26 + 1;
  *((_DWORD *)v24 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (00480FA0) --------------------------------------------------------
int __thiscall sub_480FA0(int this)
{
  HMODULE ModuleHandleW; // eax
  HICON IconW; // eax
  HWND DlgItem; // ebx
  _DWORD *v5; // eax
  int v6; // eax
  void **v7; // esi
  int v8; // edx
  LPARAM v9; // eax
  HINSTANCE v10; // ecx
  int *v11; // ecx
  int v12; // edx
  UINT v13; // eax
  HWND v14; // esi
  _DWORD *v15; // edi
  HWND Parent; // eax
  void **v17; // eax
  void *v18; // ecx
  void **v19; // esi
  LPARAM wParam; // [esp+10h] [ebp-154h]
  void *v22; // [esp+14h] [ebp-150h] BYREF
  int v23; // [esp+18h] [ebp-14Ch]
  void **v24; // [esp+20h] [ebp-144h]
  char *v25; // [esp+24h] [ebp-140h] BYREF
  HINSTANCE hInstance; // [esp+28h] [ebp-13Ch]
  LPARAM v27; // [esp+2Ch] [ebp-138h]
  void *v28; // [esp+30h] [ebp-134h]
  int v29; // [esp+34h] [ebp-130h]
  int pExceptionObject[3]; // [esp+38h] [ebp-12Ch] BYREF
  LPARAM v31[13]; // [esp+44h] [ebp-120h] BYREF
  LPARAM v32[3]; // [esp+78h] [ebp-ECh] BYREF
  int v33; // [esp+84h] [ebp-E0h]
  int v34; // [esp+88h] [ebp-DCh]
  int lParam[8]; // [esp+ACh] [ebp-B8h] BYREF
  WCHAR Buffer[66]; // [esp+CCh] [ebp-98h] BYREF
  int v37; // [esp+160h] [ebp-4h]

  ModuleHandleW = GetModuleHandleW(0);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *(_DWORD *)(this + 56) = IconW;
  SetClassLongW(*(HWND *)(this + 4), -34, (LONG)IconW);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1085);
  SetWindowTheme(DlgItem, L"Explorer", 0);
  SendMessageW(DlgItem, 0x1036u, 4u, 4);
  lParam[0] = 0;
  SendMessageW(DlgItem, 0x1061u, 0, (LPARAM)lParam);
  v23 = 0;
  v5 = operator new(0x14u);
  if ( !v5 )
  {
    v25 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v22 = v5;
  *v5 = v5;
  *((_DWORD *)v22 + 1) = v22;
  v37 = 0;
  v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 48) + 4))(*(_DWORD *)(this + 48));
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v6 + 312))(v6, &v22);
  wParam = 0;
  v7 = *(void ***)v22;
  v24 = (void **)v22;
  if ( v7 != v22 )
  {
    do
    {
      v8 = (int)v7[4];
      v9 = (LPARAM)v7[2];
      v28 = v7[3];
      v10 = *(HINSTANCE *)(this + 8);
      v29 = v8;
      hInstance = v10;
      v11 = *(int **)(this + 48);
      v12 = *v11;
      v27 = v9;
      v13 = (*(int (__thiscall **)(int *, LPARAM))(v12 + 24))(v11, v9);
      LoadStringW(hInstance, v13, Buffer, 64);
      v31[1] = wParam;
      v31[0] = 5;
      v31[2] = 0;
      v31[5] = (LPARAM)Buffer;
      v31[8] = v27;
      SendMessageW(DlgItem, 0x104Du, 0, (LPARAM)v31);
      v34 = 61440;
      v33 = ((v28 != 0) + 1) << 12;
      SendMessageW(DlgItem, 0x102Bu, wParam, (LPARAM)v32);
      v7 = (void **)*v7;
      ++wParam;
    }
    while ( v7 != v24 );
  }
  SendMessageW(DlgItem, 0x101Eu, 0, 0xFFFF);
  v34 = 2;
  v33 = 2;
  SendMessageW(DlgItem, 0x102Bu, 0, (LPARAM)v32);
  SetFocus(DlgItem);
  v14 = *(HWND *)(this + 4);
  v15 = *(_DWORD **)(this + 60);
  if ( v15[1] )
  {
    SetWindowPos(v14, 0, v15[2], v15[3], v15[4], v15[5], 4u);
  }
  else
  {
    Parent = GetParent(v14);
    sub_4697F0(v14, Parent);
  }
  v17 = *(void ***)v22;
  *(_DWORD *)v22 = v22;
  *((_DWORD *)v22 + 1) = v22;
  v18 = v22;
  v23 = 0;
  if ( v17 != v22 )
  {
    do
    {
      v19 = (void **)*v17;
      operator delete(v17);
      v18 = v22;
      v17 = v19;
    }
    while ( v19 != v22 );
  }
  operator delete(v18);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 480FA0: using guessed type LPARAM lParam[8];

//----- (00481280) --------------------------------------------------------
int *sub_481280()
{
  if ( (dword_4F1B58 & 1) == 0 )
  {
    dword_4F1B58 |= 1u;
    sub_4653E0((int)&dword_4F07F8, (int)L"SelectColumns");
    dword_4F07F8 = (int)&CSelectColumnsDialogPersistentSettings::`vftable';
    atexit(sub_4BCD10);
  }
  return &dword_4F07F8;
}
// 4C6DD0: using guessed type wchar_t aSelectcolumns[14];
// 4CC1AC: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 4F07F8: using guessed type int dword_4F07F8;
// 4F1B58: using guessed type int dword_4F1B58;

//----- (004812C0) --------------------------------------------------------
int __usercall sub_4812C0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  HINSTANCE v3; // eax
  int result; // eax

  v3 = hInstance;
  *(_DWORD *)(a3 + 16) = a2;
  *(_DWORD *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 12) = 174;
  *(_BYTE *)(a3 + 28) = 1;
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)a3 = &CSelectColumnsDialog::`vftable';
  *(_DWORD *)(a3 + 48) = a1;
  *(_DWORD *)(a3 + 52) = 0;
  if ( (dword_4F1B58 & 1) == 0 )
  {
    dword_4F1B58 |= 1u;
    sub_4653E0((int)&dword_4F07F8, (int)L"SelectColumns");
    dword_4F07F8 = (int)&CSelectColumnsDialogPersistentSettings::`vftable';
    atexit(sub_4BCD10);
  }
  result = a3;
  *(_DWORD *)(a3 + 60) = &dword_4F07F8;
  return result;
}
// 4C6DD0: using guessed type wchar_t aSelectcolumns[14];
// 4CC174: using guessed type void *CSelectColumnsDialog::`vftable';
// 4CC1AC: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 4F07F8: using guessed type int dword_4F07F8;
// 4F1B58: using guessed type int dword_4F1B58;

//----- (00481330) --------------------------------------------------------
void __stdcall sub_481330(int a1)
{
  int v1; // esi
  HWND DlgItem; // ebx
  WPARAM v3; // edi
  char *v4; // eax
  _DWORD *v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edi
  int v9; // eax
  void **v10; // eax
  void *v11; // ecx
  void **v12; // esi
  char *v13; // eax
  char *v14; // ecx
  char *v15; // esi
  void **i; // eax
  char *v17; // ecx
  char *v18; // ebx
  char **v19; // eax
  LPARAM lParam[8]; // [esp+10h] [ebp-7Ch] BYREF
  char *v21; // [esp+30h] [ebp-5Ch]
  int pExceptionObject[3]; // [esp+44h] [ebp-48h] BYREF
  char *v23[3]; // [esp+50h] [ebp-3Ch] BYREF
  void *v24; // [esp+5Ch] [ebp-30h] BYREF
  int v25; // [esp+60h] [ebp-2Ch]
  char *v26; // [esp+68h] [ebp-24h] BYREF
  int v27; // [esp+6Ch] [ebp-20h]
  char *v28; // [esp+74h] [ebp-18h] BYREF
  char *v29; // [esp+78h] [ebp-14h] BYREF
  HWND hWnd; // [esp+7Ch] [ebp-10h]
  int v31; // [esp+88h] [ebp-4h]

  v1 = a1;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1085);
  v3 = 0;
  hWnd = DlgItem;
  v27 = 0;
  v4 = (char *)operator new(0x14u);
  if ( !v4 )
  {
    v28 = 0;
    std::exception::exception((std::exception *)v23, (const char *const *)&v28);
    v23[0] = (char *)&std::bad_alloc::`vftable';
    _CxxThrowException(v23, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v26 = v4;
  *(_DWORD *)v4 = v4;
  *((_DWORD *)v26 + 1) = v26;
  v31 = 0;
  v25 = 0;
  v5 = operator new(0x14u);
  if ( !v5 )
  {
    v29 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v29);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v24 = v5;
  *v5 = v5;
  *((_DWORD *)v24 + 1) = v24;
  LOBYTE(v31) = 1;
  v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v6 + 312))(v6, &v24);
  if ( SendMessageW(DlgItem, 0x1004u, 0, 0) > 0 )
  {
    while ( 1 )
    {
      lParam[0] = 4;
      lParam[1] = v3;
      lParam[2] = 0;
      SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
      for ( i = *(void ***)v24; i != v24; i = (void **)*i )
      {
        if ( i[2] == v21 )
          break;
      }
      v17 = (char *)i[4];
      v23[0] = v21;
      v23[2] = v17;
      v23[1] = (char *)(((unsigned int)SendMessageW(DlgItem, 0x102Cu, v3, 61440) >> 12) - 1);
      v18 = v26 + 4;
      v19 = sub_41EEB0(v23, v26, *((_DWORD *)v26 + 1));
      if ( v27 == 357913940 )
        std::_Xlength_error("list<T> too long");
      ++v27;
      *(_DWORD *)v18 = v19;
      *(_DWORD *)v19[1] = v19;
      if ( (int)++v3 >= SendMessageW(hWnd, 0x1004u, 0, 0) )
        break;
      DlgItem = hWnd;
    }
    v1 = a1;
  }
  v7 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 48) + 4))(*(_DWORD *)(v1 + 48));
  (*(void (__thiscall **)(int, char **, _DWORD))(*(_DWORD *)v7 + 316))(v7, &v26, *(_DWORD *)(v1 + 52));
  if ( *(_DWORD *)(v1 + 52) )
  {
    v8 = **(_DWORD **)(v1 + 48);
    v9 = (*(int (__thiscall **)(_DWORD))(v8 + 20))(*(_DWORD *)(v1 + 48));
    (*(void (__thiscall **)(_DWORD, int))(v8 + 16))(*(_DWORD *)(v1 + 48), v9);
  }
  EndDialog(*(HWND *)(v1 + 4), 1);
  v10 = *(void ***)v24;
  *(_DWORD *)v24 = v24;
  *((_DWORD *)v24 + 1) = v24;
  v11 = v24;
  v25 = 0;
  if ( v10 != v24 )
  {
    do
    {
      v12 = (void **)*v10;
      operator delete(v10);
      v11 = v24;
      v10 = v12;
    }
    while ( v12 != v24 );
  }
  operator delete(v11);
  v13 = *(char **)v26;
  *(_DWORD *)v26 = v26;
  *((_DWORD *)v26 + 1) = v26;
  v14 = v26;
  v27 = 0;
  if ( v13 != v26 )
  {
    do
    {
      v15 = *(char **)v13;
      operator delete(v13);
      v14 = v26;
      v13 = v15;
    }
    while ( v15 != v26 );
  }
  operator delete(v14);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004815B0) --------------------------------------------------------
int __thiscall sub_4815B0(int this, unsigned __int16 a2, int a3)
{
  HWND DlgItem; // edi
  int v6; // eax
  int v7; // eax

  if ( a2 > 0x41Du )
  {
    if ( a2 != 1054 )
      return 0;
    DlgItem = GetDlgItem(*(HWND *)(this + 4), 1085);
    v7 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
    if ( v7 == -1 )
      return 0;
    sub_468B50(DlgItem, v7, v7 + 1);
    goto LABEL_12;
  }
  switch ( a2 )
  {
    case 0x41Du:
      DlgItem = GetDlgItem(*(HWND *)(this + 4), 1085);
      v6 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
      if ( v6 == -1 )
        return 0;
      sub_468B50(DlgItem, v6, v6 - 1);
LABEL_12:
      *(_DWORD *)(this + 52) = 1;
      SetFocus(DlgItem);
      return 0;
    case 1u:
      sub_481330(this);
      return 0;
    case 2u:
      EndDialog(*(HWND *)(this + 4), 0);
      return 0;
  }
  return 0;
}

//----- (004816A0) --------------------------------------------------------
int __thiscall sub_4816A0(HWND *this)
{
  DestroyWindow(this[1]);
  return 0;
}

//----- (004816B0) --------------------------------------------------------
int __stdcall sub_4816B0(HWND hWnd, int a2, int a3, LPARAM lParam)
{
  if ( a2 == 1 )
    SendMessageW(hWnd, 0x467u, 1u, lParam);
  return 0;
}

//----- (004816E0) --------------------------------------------------------
UINT __thiscall sub_4816E0(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  HWND DlgItem; // edi
  UINT result; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 728);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1084) = IsDlgButtonChecked(*(HWND *)(this + 4), 1282) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1080) = IsDlgButtonChecked(*(HWND *)(this + 4), 1281) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1076) = IsDlgButtonChecked(*(HWND *)(this + 4), 1249) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1088) = IsDlgButtonChecked(*(HWND *)(this + 4), 1060) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1092) = IsDlgButtonChecked(*(HWND *)(this + 4), 1061) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1096) = IsDlgButtonChecked(*(HWND *)(this + 4), 1062) == 1;
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1100) = IsDlgButtonChecked(*(HWND *)(this + 4), 1059) == 1;
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1226);
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1128) = SendMessageW(DlgItem, 0x101Du, 0, 0);
  *(_DWORD *)(*(_DWORD *)(this + 728) + 1132) = SendMessageW(DlgItem, 0x101Du, 1u, 0);
  result = GetDlgItemTextW(*(HWND *)(this + 4), 1225, (LPWSTR)(*(_DWORD *)(this + 728) + 540), 260);
  *(_DWORD *)(*(_DWORD *)(this + 728) + 4) = 1;
  return result;
}

//----- (00481880) --------------------------------------------------------
LRESULT __usercall sub_481880@<eax>(int a1@<edi>)
{
  HWND DlgItem; // eax
  HWND v2; // esi
  WPARAM v3; // eax
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  int *v6; // edx
  int *v7; // eax
  WPARAM v8; // esi
  LRESULT result; // eax
  LPARAM lParam[5]; // [esp+8h] [ebp-40h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+3Ch] [ebp-Ch]
  int v15; // [esp+40h] [ebp-8h]
  HWND hWnd; // [esp+44h] [ebp-4h]

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1226);
  v2 = (HWND)SendMessageW(DlgItem, 0x101Fu, 0, 0);
  v3 = *(_DWORD *)(a1 + 716);
  hWnd = v2;
  if ( v3 != -1 )
  {
    lParam[0] = 4;
    SendMessageW(v2, 0x120Bu, v3, (LPARAM)lParam);
    if ( (v11 & 0x400) != 0 )
    {
      v4 = v11 & 0xFFFFFBFF;
    }
    else
    {
      if ( (v11 & 0x200) == 0 )
      {
LABEL_7:
        SendMessageW(v2, 0x120Cu, *(_DWORD *)(a1 + 716), (LPARAM)lParam);
        goto LABEL_8;
      }
      v4 = v11 & 0xFFFFFDFF;
    }
    v11 = v4;
    goto LABEL_7;
  }
LABEL_8:
  v5 = *(_DWORD **)(a1 + 728);
  v6 = (int *)v5[277];
  v7 = (int *)v5[276];
  v8 = 0;
  if ( v7 != v6 )
  {
    v15 = v5[280];
    do
    {
      v12 = *v7;
      v13 = v7[1];
      v14 = v7[2];
      if ( v12 == v15 )
        break;
      v7 += 3;
      ++v8;
    }
    while ( v7 != v6 );
  }
  lParam[0] = 4;
  SendMessageW(hWnd, 0x120Bu, v8, (LPARAM)lParam);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 728) + 1124) )
    v11 |= 0x400u;
  else
    v11 |= 0x200u;
  result = SendMessageW(hWnd, 0x120Cu, v8, (LPARAM)lParam);
  *(_DWORD *)(a1 + 716) = v8;
  return result;
}

//----- (004819A0) --------------------------------------------------------
int __thiscall sub_4819A0(void *this, int a2, int a3)
{
  int v3; // esi
  WCHAR *v4; // eax
  int v5; // edx
  int v6; // esi
  WCHAR v7; // cx
  int v8; // esi
  WCHAR *v9; // eax
  int v10; // edx
  int v11; // esi
  WCHAR v12; // cx
  int v14; // [esp+8h] [ebp-420h] BYREF
  int v15; // [esp+Ch] [ebp-41Ch] BYREF
  void *v16; // [esp+10h] [ebp-418h] BYREF
  WCHAR pszPath[260]; // [esp+14h] [ebp-414h] BYREF
  WCHAR psz2[260]; // [esp+21Ch] [ebp-20Ch] BYREF

  v16 = this;
  sub_417A20((_DWORD *)(a2 + 668), (int *)&v16, &v14);
  v16 = (void *)a3;
  sub_417A20((_DWORD *)(a2 + 668), (int *)&v16, &v15);
  if ( *(_DWORD *)(v14 + 32) < 8u )
    v3 = v14 + 12;
  else
    v3 = *(_DWORD *)(v14 + 12);
  v4 = pszPath;
  v5 = 260;
  v6 = v3 - (_DWORD)pszPath;
  while ( v5 != -2147483386 )
  {
    v7 = *(WCHAR *)((char *)v4 + v6);
    if ( !v7 )
      break;
    *v4++ = v7;
    if ( !--v5 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  if ( *(_DWORD *)(v15 + 32) < 8u )
    v8 = v15 + 12;
  else
    v8 = *(_DWORD *)(v15 + 12);
  v9 = psz2;
  v10 = 260;
  v11 = v8 - (_DWORD)psz2;
  while ( v10 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v9 + v11);
    if ( !v12 )
      break;
    *v9++ = v12;
    if ( !--v10 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  PathRemoveFileSpecW(pszPath);
  PathRemoveFileSpecW(psz2);
  return StrCmpLogicalW(pszPath, psz2);
}
// 481A40: conditional instruction was optimized away because edx.4!=0
// 481A90: conditional instruction was optimized away because edx.4!=0

//----- (00481AE0) --------------------------------------------------------
int __thiscall sub_481AE0(void *this, int a2, int a3)
{
  int v3; // esi
  WCHAR *v4; // eax
  int v5; // edx
  int v6; // esi
  WCHAR v7; // cx
  int v8; // esi
  WCHAR *v9; // eax
  int v10; // edx
  int v11; // esi
  WCHAR v12; // cx
  int v14; // [esp+8h] [ebp-420h] BYREF
  int v15; // [esp+Ch] [ebp-41Ch] BYREF
  void *v16; // [esp+10h] [ebp-418h] BYREF
  WCHAR pszPath[260]; // [esp+14h] [ebp-414h] BYREF
  WCHAR psz2[260]; // [esp+21Ch] [ebp-20Ch] BYREF

  v16 = this;
  sub_417A20((_DWORD *)(a2 + 668), (int *)&v16, &v14);
  v16 = (void *)a3;
  sub_417A20((_DWORD *)(a2 + 668), (int *)&v16, &v15);
  if ( *(_DWORD *)(v14 + 32) < 8u )
    v3 = v14 + 12;
  else
    v3 = *(_DWORD *)(v14 + 12);
  v4 = pszPath;
  v5 = 260;
  v6 = v3 - (_DWORD)pszPath;
  while ( v5 != -2147483386 )
  {
    v7 = *(WCHAR *)((char *)v4 + v6);
    if ( !v7 )
      break;
    *v4++ = v7;
    if ( !--v5 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  if ( *(_DWORD *)(v15 + 32) < 8u )
    v8 = v15 + 12;
  else
    v8 = *(_DWORD *)(v15 + 12);
  v9 = psz2;
  v10 = 260;
  v11 = v8 - (_DWORD)psz2;
  while ( v10 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v9 + v11);
    if ( !v12 )
      break;
    *v9++ = v12;
    if ( !--v10 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  PathStripPathW(pszPath);
  PathStripPathW(psz2);
  return StrCmpLogicalW(pszPath, psz2);
}
// 481B80: conditional instruction was optimized away because edx.4!=0
// 481BD0: conditional instruction was optimized away because edx.4!=0

//----- (00481C60) --------------------------------------------------------
int __stdcall sub_481C60(void *a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 728) + 1120) == 1 )
  {
    result = sub_481AE0(a1, a3, a2);
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a3 + 728) + 1120) == 2 )
  {
    result = sub_4819A0(a1, a3, a2);
  }
  if ( !*(_DWORD *)(*(_DWORD *)(a3 + 728) + 1124) )
    return -result;
  return result;
}

//----- (00481CB0) --------------------------------------------------------
char **__stdcall sub_481CB0(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char **v4; // eax
  char *v5; // ecx
  char **v6; // eax
  char *v7; // ecx
  char **v8; // eax
  char *v9; // ecx
  char **v10; // eax
  char *v11; // ecx
  char **v12; // eax
  char *v13; // ecx
  char **v14; // eax
  char *v15; // ecx
  char **v16; // eax
  char *v17; // ecx
  char **v18; // eax
  char *v19; // ecx
  char **v20; // eax
  char *v21; // ecx
  char **v22; // eax
  char *v23; // ecx
  char **v24; // eax
  char *v25; // ecx
  char **v26; // eax
  char *v27; // ecx
  char **result; // eax
  char *v29; // ecx
  char *v30; // [esp-8h] [ebp-20h]
  char *v31; // [esp-8h] [ebp-20h]
  char *v32; // [esp-8h] [ebp-20h]
  char *v33; // [esp-8h] [ebp-20h]
  char *v34; // [esp-8h] [ebp-20h]
  char *v35; // [esp-8h] [ebp-20h]
  char *v36; // [esp-8h] [ebp-20h]
  char *v37; // [esp-8h] [ebp-20h]
  char *v38; // [esp-8h] [ebp-20h]
  char *v39; // [esp-8h] [ebp-20h]
  char *v40; // [esp-8h] [ebp-20h]
  char *v41; // [esp-8h] [ebp-20h]
  char *v42; // [esp-8h] [ebp-20h]
  char *v43; // [esp-8h] [ebp-20h]
  int v44; // [esp-4h] [ebp-1Ch]
  int v45; // [esp-4h] [ebp-1Ch]
  int v46; // [esp-4h] [ebp-1Ch]
  int v47; // [esp-4h] [ebp-1Ch]
  int v48; // [esp-4h] [ebp-1Ch]
  int v49; // [esp-4h] [ebp-1Ch]
  int v50; // [esp-4h] [ebp-1Ch]
  int v51; // [esp-4h] [ebp-1Ch]
  int v52; // [esp-4h] [ebp-1Ch]
  int v53; // [esp-4h] [ebp-1Ch]
  int v54; // [esp-4h] [ebp-1Ch]
  int v55; // [esp-4h] [ebp-1Ch]
  int v56; // [esp-4h] [ebp-1Ch]
  int v57; // [esp-4h] [ebp-1Ch]
  int v58; // [esp+Ch] [ebp-Ch] BYREF
  int v59; // [esp+10h] [ebp-8h]
  int v60; // [esp+14h] [ebp-4h]
  char *v61; // [esp+20h] [ebp+8h]
  char *v62; // [esp+20h] [ebp+8h]
  char *v63; // [esp+20h] [ebp+8h]
  char *v64; // [esp+20h] [ebp+8h]
  char *v65; // [esp+20h] [ebp+8h]
  char *v66; // [esp+20h] [ebp+8h]
  char *v67; // [esp+20h] [ebp+8h]
  char *v68; // [esp+20h] [ebp+8h]
  char *v69; // [esp+20h] [ebp+8h]
  char *v70; // [esp+20h] [ebp+8h]
  char *v71; // [esp+20h] [ebp+8h]
  char *v72; // [esp+20h] [ebp+8h]
  char *v73; // [esp+20h] [ebp+8h]
  char *v74; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v44 = *((_DWORD *)*a2 + 1);
  v30 = *a2;
  v58 = 1225;
  v59 = 1;
  v60 = 1;
  v61 = v30;
  v2 = sub_41EEB0((char **)&v58, v30, v44);
  v3 = a2[1];
  if ( 357913940 == (_DWORD)v3 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v61 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v45 = *((_DWORD *)*a2 + 1);
  v31 = *a2;
  v58 = 1224;
  v59 = 1;
  v60 = 1;
  v62 = v31;
  v4 = sub_41EEB0((char **)&v58, v31, v45);
  v5 = a2[1];
  if ( 357913940 == (_DWORD)v5 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v5 + 1;
  *((_DWORD *)v62 + 1) = v4;
  *(_DWORD *)v4[1] = v4;
  v46 = *((_DWORD *)*a2 + 1);
  v32 = *a2;
  v58 = 1229;
  v59 = 0;
  v60 = 1;
  v63 = v32;
  v6 = sub_41EEB0((char **)&v58, v32, v46);
  v7 = a2[1];
  if ( 357913940 == (_DWORD)v7 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v63 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v47 = *((_DWORD *)*a2 + 1);
  v33 = *a2;
  v58 = 1226;
  v59 = 1;
  v60 = 0;
  v64 = v33;
  v8 = sub_41EEB0((char **)&v58, v33, v47);
  v9 = a2[1];
  if ( 357913940 == (_DWORD)v9 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v9 + 1;
  *((_DWORD *)v64 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v48 = *((_DWORD *)*a2 + 1);
  v34 = *a2;
  v58 = 1255;
  v59 = 0;
  v60 = 2;
  v65 = v34;
  v10 = sub_41EEB0((char **)&v58, v34, v48);
  v11 = a2[1];
  if ( 357913940 == (_DWORD)v11 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v11 + 1;
  *((_DWORD *)v65 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  v49 = *((_DWORD *)*a2 + 1);
  v35 = *a2;
  v58 = 1250;
  v59 = 0;
  v60 = 2;
  v66 = v35;
  v12 = sub_41EEB0((char **)&v58, v35, v49);
  v13 = a2[1];
  if ( 357913940 == (_DWORD)v13 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v13 + 1;
  *((_DWORD *)v66 + 1) = v12;
  *(_DWORD *)v12[1] = v12;
  v50 = *((_DWORD *)*a2 + 1);
  v36 = *a2;
  v58 = 1250;
  v59 = 1;
  v60 = 1;
  v67 = v36;
  v14 = sub_41EEB0((char **)&v58, v36, v50);
  v15 = a2[1];
  if ( 357913940 == (_DWORD)v15 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v15 + 1;
  *((_DWORD *)v67 + 1) = v14;
  *(_DWORD *)v14[1] = v14;
  v51 = *((_DWORD *)*a2 + 1);
  v37 = *a2;
  v58 = 1285;
  v59 = 0;
  v60 = 2;
  v68 = v37;
  v16 = sub_41EEB0((char **)&v58, v37, v51);
  v17 = a2[1];
  if ( 357913940 == (_DWORD)v17 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v17 + 1;
  *((_DWORD *)v68 + 1) = v16;
  *(_DWORD *)v16[1] = v16;
  v52 = *((_DWORD *)*a2 + 1);
  v38 = *a2;
  v58 = 1285;
  v59 = 1;
  v60 = 1;
  v69 = v38;
  v18 = sub_41EEB0((char **)&v58, v38, v52);
  v19 = a2[1];
  if ( 357913940 == (_DWORD)v19 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v19 + 1;
  *((_DWORD *)v69 + 1) = v18;
  *(_DWORD *)v18[1] = v18;
  v53 = *((_DWORD *)*a2 + 1);
  v39 = *a2;
  v58 = 1254;
  v59 = 0;
  v60 = 2;
  v70 = v39;
  v20 = sub_41EEB0((char **)&v58, v39, v53);
  v21 = a2[1];
  if ( 357913940 == (_DWORD)v21 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v21 + 1;
  *((_DWORD *)v70 + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  v54 = *((_DWORD *)*a2 + 1);
  v40 = *a2;
  v58 = 1254;
  v59 = 1;
  v60 = 1;
  v71 = v40;
  v22 = sub_41EEB0((char **)&v58, v40, v54);
  v23 = a2[1];
  if ( 357913940 == (_DWORD)v23 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v23 + 1;
  *((_DWORD *)v71 + 1) = v22;
  *(_DWORD *)v22[1] = v22;
  v59 = 0;
  v60 = 0;
  v55 = *((_DWORD *)*a2 + 1);
  v41 = *a2;
  v58 = 1227;
  v72 = v41;
  v24 = sub_41EEB0((char **)&v58, v41, v55);
  v25 = a2[1];
  if ( 357913940 == (_DWORD)v25 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v25 + 1;
  *((_DWORD *)v72 + 1) = v24;
  *(_DWORD *)v24[1] = v24;
  v59 = 0;
  v60 = 0;
  v56 = *((_DWORD *)*a2 + 1);
  v42 = *a2;
  v58 = 1228;
  v73 = v42;
  v26 = sub_41EEB0((char **)&v58, v42, v56);
  v27 = a2[1];
  if ( 357913940 == (_DWORD)v27 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v27 + 1;
  *((_DWORD *)v73 + 1) = v26;
  *(_DWORD *)v26[1] = v26;
  v59 = 0;
  v60 = 0;
  v57 = *((_DWORD *)*a2 + 1);
  v43 = *a2;
  v58 = 1304;
  v74 = v43;
  result = sub_41EEB0((char **)&v58, v43, v57);
  v29 = a2[1];
  if ( 357913940 == (_DWORD)v29 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v29 + 1;
  *((_DWORD *)v74 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (004820E0) --------------------------------------------------------
void __usercall sub_4820E0(int a1@<edi>)
{
  void **v1; // esi

  v1 = *(void ***)(a1 + 1072);
  *(_DWORD *)a1 = &CSearchDialogPersistentSettings::`vftable';
  if ( v1 )
  {
    sub_416E70(v1);
    if ( *v1 )
      operator delete(*v1);
    operator delete(v1);
  }
  if ( *(_DWORD *)(a1 + 1104) )
    operator delete(*(void **)(a1 + 1104));
  *(_DWORD *)(a1 + 1104) = 0;
  *(_DWORD *)(a1 + 1108) = 0;
  *(_DWORD *)(a1 + 1112) = 0;
  sub_40A140(a1 + 1060);
  operator delete(*(void **)(a1 + 1060));
  *(_DWORD *)a1 = &CDialogSettings::`vftable';
}
// 4CC154: using guessed type void *CSearchDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';

//----- (00482160) --------------------------------------------------------
int *sub_482160()
{
  int v0; // esi
  _DWORD *v1; // eax
  _WORD *v2; // eax
  int v3; // edi
  __int16 v4; // cx
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  char *v7; // eax
  char *v9; // [esp+18h] [ebp-20h] BYREF
  int pExceptionObject; // [esp+1Ch] [ebp-1Ch] BYREF
  int v11; // [esp+20h] [ebp-18h]
  char v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+34h] [ebp-4h]

  sub_4653E0((int)&dword_4F1B60, (int)L"Search");
  v0 = 0;
  v13 = 0;
  dword_4F1B60 = (int)&CSearchDialogPersistentSettings::`vftable';
  dword_4F1F88 = 0;
  v1 = operator new(0x24u);
  if ( !v1 )
  {
    v9 = 0;
    std::exception::exception((std::exception *)&pExceptionObject, (const char *const *)&v9);
    pExceptionObject = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4F1F84 = (int)v1;
  *v1 = v1;
  *(_DWORD *)(dword_4F1F84 + 4) = dword_4F1F84;
  dword_4F1FB0 = 0;
  dword_4F1FB4 = 0;
  dword_4F1FB8 = 0;
  LOBYTE(v13) = 2;
  dword_4F1FC8 = -1;
  dword_4F1FCC = -1;
  v2 = &unk_4F1D7C;
  dword_4F1F94 = 1;
  dword_4F1F98 = 0;
  dword_4F1F9C = 0;
  dword_4F1FA0 = 0;
  dword_4F1FA4 = 0;
  dword_4F1FA8 = 0;
  dword_4F1FAC = 0;
  v3 = 260;
  while ( v3 != -2147483386 )
  {
    v4 = *(_WORD *)((char *)v2 + &unk_4C6F84 - &unk_4F1D7C);
    if ( !v4 )
      break;
    *v2++ = v4;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  v5 = operator new(0x18u);
  v6 = v5;
  LOBYTE(v13) = 3;
  if ( v5 )
  {
    v5[4] = 0;
    v7 = (char *)operator new(0x230u);
    if ( !v7 )
    {
      v9 = 0;
      std::exception::exception((std::exception *)&pExceptionObject, (const char *const *)&v9);
      pExceptionObject = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v6 = v7;
    v6[1] = v7 + 560;
    v6[3] = v7;
    v6[2] = v7;
    v0 = (int)v6;
  }
  LOBYTE(v13) = 2;
  dword_4F1F90 = v0;
  pExceptionObject = 1;
  v11 = 2141;
  v12 = 1;
  sub_416820(&pExceptionObject, &dword_4F1FB0);
  pExceptionObject = 2;
  v11 = 2142;
  v12 = 1;
  sub_416820(&pExceptionObject, &dword_4F1FB0);
  dword_4F1FC0 = *(_DWORD *)dword_4F1FB0;
  dword_4F1FC4 = *(unsigned __int8 *)(dword_4F1FB0 + 8);
  return &dword_4F1B60;
}
// 482257: conditional instruction was optimized away because edi.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C6F24: using guessed type wchar_t aSearch_1[7];
// 4CC154: using guessed type void *CSearchDialogPersistentSettings::`vftable';
// 4F1B60: using guessed type int dword_4F1B60;
// 4F1F84: using guessed type int dword_4F1F84;
// 4F1F88: using guessed type int dword_4F1F88;
// 4F1F90: using guessed type int dword_4F1F90;
// 4F1F94: using guessed type int dword_4F1F94;
// 4F1F98: using guessed type int dword_4F1F98;
// 4F1F9C: using guessed type int dword_4F1F9C;
// 4F1FA0: using guessed type int dword_4F1FA0;
// 4F1FA4: using guessed type int dword_4F1FA4;
// 4F1FA8: using guessed type int dword_4F1FA8;
// 4F1FAC: using guessed type int dword_4F1FAC;
// 4F1FB0: using guessed type int dword_4F1FB0;
// 4F1FB4: using guessed type int dword_4F1FB4;
// 4F1FB8: using guessed type int dword_4F1FB8;
// 4F1FC0: using guessed type int dword_4F1FC0;
// 4F1FC4: using guessed type int dword_4F1FC4;
// 4F1FC8: using guessed type int dword_4F1FC8;
// 4F1FCC: using guessed type int dword_4F1FCC;

//----- (00482370) --------------------------------------------------------
void __stdcall sub_482370(int a1)
{
  *(_DWORD *)a1 = &CSearch::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 1088));
  sub_40BD70((int *)(a1 + 1072));
  *(_DWORD *)a1 = &CReferenceCount::`vftable';
}
// 4CC16C: using guessed type void *CSearch::`vftable';
// 4CC488: using guessed type void *CReferenceCount::`vftable';

//----- (004823E0) --------------------------------------------------------
int __userpurge sub_4823E0@<eax>(int a1@<esi>, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi
  int v9; // eax
  _WORD *v10; // eax
  int v11; // edi
  __int16 v12; // cx
  _WORD *v13; // eax
  int v14; // edx
  __int16 v15; // cx
  char v17[4]; // [esp+8h] [ebp-4h] BYREF

  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)a1 = &CSearch::`vftable';
  *(_DWORD *)(a1 + 1072) = 0;
  *(_DWORD *)(a1 + 1076) = 0;
  *(_DWORD *)(a1 + 1080) = 0;
  *(_DWORD *)(a1 + 1084) = std::locale::_Init();
  v8 = sub_426E4C();
  std::_Lockit::_Lockit((std::_Lockit *)v17, 0);
  v9 = *(_DWORD *)(v8 + 4);
  if ( v9 != -1 )
    *(_DWORD *)(v8 + 4) = v9 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v17);
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 1060) = a6;
  *(_DWORD *)(a1 + 1056) = a5;
  *(_DWORD *)(a1 + 1064) = a7;
  v10 = (_WORD *)(a1 + 12);
  *(_DWORD *)(a1 + 1068) = a8;
  v11 = 260;
  while ( v11 != -2147483386 )
  {
    v12 = *(_WORD *)((char *)v10 + a3 - (a1 + 12));
    if ( !v12 )
      break;
    *v10++ = v12;
    if ( !--v11 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  v13 = (_WORD *)(a1 + 532);
  v14 = 262;
  while ( v14 != -2147483384 )
  {
    v15 = *(_WORD *)((char *)v13 + a4 - (a1 + 532));
    if ( !v15 )
      break;
    *v13++ = v15;
    if ( !--v14 )
    {
      --v13;
      break;
    }
  }
  *v13 = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 1088));
  *(_DWORD *)(a1 + 1112) = 0;
  return a1;
}
// 482490: conditional instruction was optimized away because edi.4!=0
// 4824D0: conditional instruction was optimized away because edx.4!=0
// 4CC16C: using guessed type void *CSearch::`vftable';
// 4823E0: using guessed type char var_4[4];

//----- (00482500) --------------------------------------------------------
char **__thiscall sub_482500(int this, int a2, int a3, unsigned int a4)
{
  char **result; // eax
  int v6; // ebx
  HWND v7; // edx
  HWND DlgItem; // eax
  HWND v9; // eax
  int v10; // ebx
  HWND v11; // ecx
  WCHAR *v12; // [esp-8h] [ebp-518h]
  int v13; // [esp+8h] [ebp-508h] BYREF
  WCHAR String[512]; // [esp+Ch] [ebp-504h] BYREF
  WCHAR Buffer[64]; // [esp+40Ch] [ebp-104h] BYREF
  WCHAR v16[64]; // [esp+48Ch] [ebp-84h] BYREF

  result = (char **)(a2 - 32769);
  switch ( a2 )
  {
    case 32769:
      v13 = a3;
      result = sub_40B7B0((int)&v13, this + 656);
      if ( *(_DWORD *)(this + 720) )
      {
        result = (char **)SetTimer(*(HWND *)(this + 4), 0, 0x32u, 0);
        *(_DWORD *)(this + 720) = 0;
      }
      break;
    case 32770:
      if ( *(_DWORD *)(this + 584) )
      {
        LoadStringW(*(HINSTANCE *)(this + 8), 0x860u, Buffer, 128);
        v12 = Buffer;
      }
      else
      {
        LoadStringW(*(HINSTANCE *)(this + 8), 0x85Fu, Buffer, 128);
        sub_401000(0x200u, String, Buffer, (unsigned __int16)a4, HIWORD(a4));
        v12 = String;
      }
      SetDlgItemTextW(*(HWND *)(this + 4), 1250, v12);
      v6 = *(_DWORD *)(this + 652);
      if ( !InterlockedDecrement((volatile LONG *)(v6 + 4)) && v6 )
        (**(void (__thiscall ***)(int, int))v6)(v6, 1);
      v7 = *(HWND *)(this + 4);
      *(_DWORD *)(this + 652) = 0;
      *(_DWORD *)(this + 580) = 0;
      *(_DWORD *)(this + 584) = 0;
      result = (char **)SetDlgItemTextW(v7, 1227, (LPCWSTR)(this + 588));
      break;
    case 32771:
      LoadStringW(*(HINSTANCE *)(this + 8), 0x84Au, v16, 64);
      sub_401000(0x200u, String, v16, a3);
      result = (char **)SetDlgItemTextW(*(HWND *)(this + 4), 1250, String);
      break;
    case 32772:
      DlgItem = GetDlgItem(*(HWND *)(this + 4), 1285);
      ShowWindow(DlgItem, 5);
      v9 = GetDlgItem(*(HWND *)(this + 4), 1250);
      ShowWindow(v9, 0);
      LoadStringW(*(HINSTANCE *)(this + 8), 0x861u, Buffer, 128);
      SetDlgItemTextW(*(HWND *)(this + 4), 1285, Buffer);
      v10 = *(_DWORD *)(this + 652);
      if ( !InterlockedDecrement((volatile LONG *)(v10 + 4)) && v10 )
        (**(void (__thiscall ***)(int, int))v10)(v10, 1);
      v11 = *(HWND *)(this + 4);
      *(_DWORD *)(this + 652) = 0;
      *(_DWORD *)(this + 580) = 0;
      *(_DWORD *)(this + 584) = 0;
      result = (char **)SetDlgItemTextW(v11, 1227, (LPCWSTR)(this + 588));
      break;
    default:
      return result;
  }
  return result;
}

//----- (00482780) --------------------------------------------------------
void __thiscall sub_482780(_DWORD **this, LPCITEMIDLIST pidl1, int a3, int a4)
{
  ITEMIDLIST *v5; // edi
  int v6; // eax
  __int16 v7[260]; // [esp+Ch] [ebp-20Ch] BYREF

  if ( a4 == 1001 )
  {
    (*(void (__thiscall **)(_DWORD *, LPCITEMIDLIST, _DWORD, int, int, _DWORD))(*this[169] + 40))(
      this[169],
      pidl1,
      0,
      1,
      1,
      0);
    v5 = ILCombine(pidl1, *(LPCITEMIDLIST *)(**(_DWORD **)a3 + 8));
    sub_466630(v5, (WCHAR *)v7, 32769);
    CoTaskMemFree(v5);
    v6 = (*(int (__thiscall **)(_DWORD *))(*this[169] + 4))(this[169]);
    (*(void (__thiscall **)(int, __int16 *))(*(_DWORD *)v6 + 116))(v6, v7);
  }
}
// 482780: using guessed type WCHAR var_20C[260];

//----- (00482820) --------------------------------------------------------
int __thiscall sub_482820(_DWORD **this, LPCITEMIDLIST pidl1, int a3, int a4, PCWSTR psz1)
{
  int **v5; // ebx
  int **v6; // esi
  LPITEMIDLIST v7; // edi

  if ( StrCmpIW(psz1, L"open") )
    return 0;
  v5 = *(int ***)a3;
  v6 = **(int ****)a3;
  if ( *v5 != (int *)v5 )
  {
    do
    {
      v7 = ILCombine(pidl1, (LPCITEMIDLIST)v6[2]);
      (*(void (__thiscall **)(_DWORD *, LPITEMIDLIST, _DWORD, _DWORD))(*this[169] + 32))(this[169], v7, 0, 0);
      CoTaskMemFree(v7);
      v6 = (int **)*v6;
    }
    while ( v6 != v5 );
  }
  return 1;
}

//----- (00482890) --------------------------------------------------------
BOOL __thiscall sub_482890(HINSTANCE *this, LPCITEMIDLIST pidl1, int a3, int a4, int a5)
{
  int v6; // ecx
  ITEMIDLIST *v7; // esi
  MENUITEMINFOW mi; // [esp+Ch] [ebp-BCh] BYREF
  HMENU hmenu; // [esp+3Ch] [ebp-8Ch]
  int v11; // [esp+40h] [ebp-88h] BYREF
  WCHAR Buffer[64]; // [esp+44h] [ebp-84h] BYREF

  v6 = **(_DWORD **)a3;
  hmenu = (HMENU)a5;
  v7 = ILCombine(pidl1, *(LPCITEMIDLIST *)(v6 + 8));
  v11 = 0x20000000;
  sub_4665C0(v7, (int)&v11);
  CoTaskMemFree(v7);
  if ( (v11 & 0x20000000) != 0 )
    LoadStringW(*(this - 10), 0x869u, Buffer, 64);
  else
    LoadStringW(*(this - 10), 0x868u, Buffer, 64);
  mi.cbSize = 48;
  mi.fMask = 66;
  mi.wID = 1001;
  mi.dwTypeData = Buffer;
  return InsertMenuItemW(hmenu, 1u, 1, &mi);
}

//----- (00482970) --------------------------------------------------------
int *sub_482970()
{
  if ( (dword_4F2220 & 1) == 0 )
  {
    dword_4F2220 |= 1u;
    sub_482160();
    atexit(sub_4BCD00);
  }
  return &dword_4F1B60;
}
// 4F1B60: using guessed type int dword_4F1B60;
// 4F2220: using guessed type int dword_4F2220;

//----- (004829E0) --------------------------------------------------------
int __thiscall sub_4829E0(void *this, int a2, int a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // eax
  _WORD *v6; // eax
  int v7; // edi
  int v8; // edx
  __int16 v9; // cx
  bool v10; // zf
  int pExceptionObject[3]; // [esp+10h] [ebp-1Ch] BYREF
  char *v13; // [esp+1Ch] [ebp-10h] BYREF
  int v14; // [esp+28h] [ebp-4h]

  v4 = a2;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(v4 + 12) = 224;
  *(_DWORD *)(v4 + 16) = this;
  *(_BYTE *)(v4 + 28) = 1;
  *(_DWORD *)(v4 + 44) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  v14 = 0;
  *(_DWORD *)v4 = &CSearchDialog::`vftable';
  *(_DWORD *)(v4 + 48) = &CSearchDialog::`vftable';
  *(_DWORD *)(v4 + 660) = 0;
  v5 = operator new(0xCu);
  if ( !v5 )
  {
    v13 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v13);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(v4 + 656) = v5;
  *v5 = v5;
  *(_DWORD *)(*(_DWORD *)(v4 + 656) + 4) = *(_DWORD *)(v4 + 656);
  sub_416C10(v4 + 668, (char *)&a2 + 2);
  v6 = (_WORD *)(v4 + 52);
  LOBYTE(v14) = 2;
  v7 = 260;
  v8 = a3 - (v4 + 52);
  while ( v7 != -2147483386 )
  {
    v9 = *(_WORD *)((char *)v6 + v8);
    if ( !v9 )
      break;
    *v6++ = v9;
    if ( !--v7 )
    {
      --v6;
      break;
    }
  }
  v10 = (dword_4F2220 & 1) == 0;
  *v6 = 0;
  *(_DWORD *)(v4 + 724) = a4;
  *(_DWORD *)(v4 + 580) = 0;
  *(_DWORD *)(v4 + 584) = 0;
  *(_DWORD *)(v4 + 720) = 1;
  *(_DWORD *)(v4 + 712) = 0;
  *(_DWORD *)(v4 + 716) = -1;
  *(_DWORD *)(v4 + 652) = 0;
  if ( v10 )
  {
    dword_4F2220 |= 1u;
    LOBYTE(v14) = 3;
    sub_482160();
    atexit(sub_4BCD00);
  }
  *(_DWORD *)(v4 + 728) = &dword_4F1B60;
  return v4;
}
// 482AB0: conditional instruction was optimized away because edi.4!=0
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC10C: using guessed type void *CSearchDialog::`vftable';
// 4CC144: using guessed type void *CSearchDialog::`vftable';
// 4F1B60: using guessed type int dword_4F1B60;
// 4F2220: using guessed type int dword_4F2220;

//----- (00482B60) --------------------------------------------------------
void __stdcall sub_482B60(int a1)
{
  int v1; // ebx
  int v2; // ebx
  _DWORD **v3; // ecx
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  void *v6; // esi

  *(_DWORD *)a1 = &CSearchDialog::`vftable';
  *(_DWORD *)(a1 + 48) = &CSearchDialog::`vftable';
  DestroyIcon(*(HICON *)(a1 + 572));
  DestroyIcon(*(HICON *)(a1 + 576));
  v1 = *(_DWORD *)(a1 + 652);
  if ( v1 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 1088));
    *(_DWORD *)(v1 + 1112) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 1088));
    v2 = *(_DWORD *)(a1 + 652);
    if ( !InterlockedDecrement((volatile LONG *)(v2 + 4)) )
    {
      if ( v2 )
        (**(void (__thiscall ***)(int, int))v2)(v2, 1);
    }
  }
  if ( *(_DWORD *)(a1 + 684) )
    operator delete(*(void **)(a1 + 684));
  *(_DWORD *)(a1 + 684) = 0;
  *(_DWORD *)(a1 + 688) = 0;
  *(_DWORD *)(a1 + 692) = 0;
  sub_416D20(a1 + 672);
  operator delete(*(void **)(a1 + 672));
  v3 = *(_DWORD ***)(a1 + 656);
  v4 = *v3;
  *v3 = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 656) + 4) = *(_DWORD *)(a1 + 656);
  *(_DWORD *)(a1 + 660) = 0;
  if ( v4 != *(_DWORD **)(a1 + 656) )
  {
    do
    {
      v5 = (_DWORD *)*v4;
      operator delete(v4);
      v4 = v5;
    }
    while ( v5 != *(_DWORD **)(a1 + 656) );
  }
  operator delete(*(void **)(a1 + 656));
  *(_DWORD *)a1 = &CBaseDialog::`vftable';
  v6 = *(void **)(a1 + 44);
  if ( v6 )
  {
    sub_4AAAD0((int)v6);
    operator delete(v6);
  }
}
// 4CC10C: using guessed type void *CSearchDialog::`vftable';
// 4CC144: using guessed type void *CSearchDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (00482CC0) --------------------------------------------------------
int __thiscall sub_482CC0(void *this)
{
  if ( this )
  {
    sub_482B60((int)this);
    operator delete(this);
  }
  return 0;
}

//----- (00482CE0) --------------------------------------------------------
int __thiscall sub_482CE0(int this)
{
  int v2; // edi
  HMODULE ModuleHandleW; // eax
  int v4; // eax
  HWND DlgItem; // eax
  HWND v6; // edi
  int v7; // eax
  int *v8; // ecx
  int *v9; // eax
  int v10; // edx
  _DWORD *v11; // edi
  _DWORD *v12; // eax
  LPARAM *v13; // edx
  char *v14; // eax
  int v15; // edx
  __int16 v16; // cx
  int v17; // eax
  _DWORD *v18; // eax
  LPARAM *v19; // edi
  char *v20; // eax
  int v21; // edx
  int v22; // edi
  __int16 v23; // cx
  int v24; // eax
  _DWORD *v25; // eax
  HWND v26; // edi
  HWND Parent; // eax
  HWND v28; // eax
  HWND v30; // [esp-14h] [ebp-3B4h]
  HINSTANCE v31; // [esp-10h] [ebp-3B0h]
  UINT v32; // [esp-Ch] [ebp-3ACh]
  LPARAM v33; // [esp-4h] [ebp-3A4h]
  HBITMAP hoc; // [esp+10h] [ebp-390h]
  int *ho; // [esp+10h] [ebp-390h]
  HWND hoa; // [esp+10h] [ebp-390h]
  HWND hob; // [esp+10h] [ebp-390h]
  int *v38; // [esp+14h] [ebp-38Ch]
  int v39; // [esp+14h] [ebp-38Ch]
  int v40; // [esp+14h] [ebp-38Ch]
  WPARAM wParam; // [esp+18h] [ebp-388h]
  WPARAM wParama; // [esp+18h] [ebp-388h]
  _DWORD *v43; // [esp+1Ch] [ebp-384h]
  _DWORD *v44; // [esp+20h] [ebp-380h]
  _DWORD **v45; // [esp+20h] [ebp-380h]
  HWND hWnd; // [esp+24h] [ebp-37Ch]
  HWND hWnda; // [esp+24h] [ebp-37Ch]
  HWND v48; // [esp+28h] [ebp-378h]
  HIMAGELIST phimlSmall; // [esp+2Ch] [ebp-374h] BYREF
  LPARAM v50; // [esp+30h] [ebp-370h] BYREF
  int v51; // [esp+34h] [ebp-36Ch]
  char *v52; // [esp+38h] [ebp-368h]
  int v53; // [esp+54h] [ebp-34Ch]
  int v54; // [esp+5Ch] [ebp-344h]
  LPARAM lParam[4]; // [esp+60h] [ebp-340h] BYREF
  int v56; // [esp+70h] [ebp-330h]
  unsigned int v57; // [esp+74h] [ebp-32Ch]
  struct tagRECT Rect; // [esp+80h] [ebp-320h] BYREF
  char v59[520]; // [esp+90h] [ebp-310h] BYREF
  WCHAR Buffer[130]; // [esp+298h] [ebp-108h] BYREF

  SetDlgItemTextW(*(HWND *)(this + 4), 1225, (LPCWSTR)(*(_DWORD *)(this + 728) + 540));
  SetDlgItemTextW(*(HWND *)(this + 4), 1224, (LPCWSTR)(this + 52));
  v2 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  hoc = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v2, (int)hoc, 0);
  *(_DWORD *)(this + 576) = sub_409F80(v2, 15, 0);
  v4 = sub_409F80(v2, 17, 0);
  v33 = *(_DWORD *)(this + 576);
  v30 = *(HWND *)(this + 4);
  *(_DWORD *)(this + 572) = v4;
  DlgItem = GetDlgItem(v30, 1229);
  SendMessageW(DlgItem, 0xF7u, 1u, v33);
  SetClassLongW(*(HWND *)(this + 4), -34, *(_DWORD *)(this + 572));
  DeleteObject(hoc);
  sub_409E60(v2);
  v6 = GetDlgItem(*(HWND *)(this + 4), 1226);
  v48 = v6;
  SendMessageW(v6, 0x1036u, 0x10001u, 65537);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(v6, 0x1003u, 1u, (LPARAM)phimlSmall);
  SetWindowTheme(v6, L"Explorer", 0);
  v7 = *(_DWORD *)(this + 728);
  v8 = *(int **)(v7 + 1108);
  v9 = *(int **)(v7 + 1104);
  wParam = 0;
  ho = v8;
  v38 = v9;
  if ( v9 != v8 )
  {
    while ( 1 )
    {
      v10 = v9[2];
      v53 = *v9;
      v32 = v9[1];
      v31 = *(HINSTANCE *)(this + 8);
      v54 = v10;
      LoadStringW(v31, v32, Buffer, 128);
      lParam[0] = 4;
      lParam[3] = (LPARAM)Buffer;
      SendMessageW(v6, 0x1061u, wParam++, (LPARAM)lParam);
      v38 += 3;
      if ( v38 == ho )
        break;
      v9 = v38;
    }
  }
  GetClientRect(v6, &Rect);
  SendMessageW(v6, 0x101Eu, 0, (unsigned __int16)(int)((double)(Rect.right - Rect.left) * 0.3333333333333333));
  SendMessageW(v6, 0x101Eu, 1u, (unsigned __int16)(int)((double)(Rect.right - Rect.left) * 0.6));
  sub_481880(this);
  CheckDlgButton(*(HWND *)(this + 4), 1060, *(_DWORD *)(*(_DWORD *)(this + 728) + 1088) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1061, *(_DWORD *)(*(_DWORD *)(this + 728) + 1092) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1062, *(_DWORD *)(*(_DWORD *)(this + 728) + 1096) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1059, *(_DWORD *)(*(_DWORD *)(this + 728) + 1100) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1249, *(_DWORD *)(*(_DWORD *)(this + 728) + 1076) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1282, *(_DWORD *)(*(_DWORD *)(this + 728) + 1084) != 0);
  CheckDlgButton(*(HWND *)(this + 4), 1281, *(_DWORD *)(*(_DWORD *)(this + 728) + 1080) != 0);
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1224);
  hoa = (HWND)SendMessageW(hWnd, 0x406u, 0, 0);
  v11 = *(_DWORD **)(*(_DWORD *)(this + 728) + 1060);
  v12 = (_DWORD *)*v11;
  v39 = 0;
  v44 = (_DWORD *)*v11;
  if ( (_DWORD *)*v11 != v11 )
  {
    while ( 2 )
    {
      LOWORD(lParam[0]) = 0;
      v57 = 7;
      v56 = 0;
      sub_4090E0((int)lParam, v12 + 2, 0, 0xFFFFFFFF);
      v13 = (LPARAM *)lParam[0];
      if ( v57 < 8 )
        v13 = lParam;
      v14 = v59;
      wParama = 260;
      v15 = (char *)v13 - v59;
      while ( wParama != -2147483386 )
      {
        v16 = *(_WORD *)&v14[v15];
        if ( !v16 )
          break;
        *(_WORD *)v14 = v16;
        v14 += 2;
        if ( !--wParama )
        {
          v14 -= 2;
          break;
        }
      }
      *(_WORD *)v14 = 0;
      v51 = v39++;
      v50 = 1;
      v52 = v59;
      SendMessageW(hWnd, 0x40Bu, 0, (LPARAM)&v50);
      if ( v57 >= 8 )
        operator delete((void *)lParam[0]);
      v44 = (_DWORD *)*v44;
      if ( v44 != v11 )
      {
        v12 = v44;
        continue;
      }
      break;
    }
  }
  SendMessageW(hoa, 0x14Eu, 0, 0);
  hWnda = GetDlgItem(*(HWND *)(this + 4), 1225);
  hob = (HWND)SendMessageW(hWnda, 0x406u, 0, 0);
  v17 = *(_DWORD *)(*(_DWORD *)(this + 728) + 1072);
  v40 = 0;
  v45 = (_DWORD **)v17;
  if ( *(_DWORD *)(v17 + 16) )
    v18 = *(_DWORD **)(v17 + 8);
  else
    v18 = 0;
  v43 = v18;
  if ( v18 )
  {
    do
    {
      v57 = 7;
      v56 = 0;
      LOWORD(lParam[0]) = 0;
      sub_4090E0((int)lParam, v18, 0, 0xFFFFFFFF);
      v19 = (LPARAM *)lParam[0];
      if ( v57 < 8 )
        v19 = lParam;
      v20 = v59;
      v21 = 260;
      v22 = (char *)v19 - v59;
      while ( v21 != -2147483386 )
      {
        v23 = *(_WORD *)&v20[v22];
        if ( !v23 )
          break;
        *(_WORD *)v20 = v23;
        v20 += 2;
        if ( !--v21 )
        {
          v20 -= 2;
          break;
        }
      }
      *(_WORD *)v20 = 0;
      v51 = v40++;
      v50 = 1;
      v52 = v59;
      SendMessageW(hWnda, 0x40Bu, 0, (LPARAM)&v50);
      if ( v57 >= 8 )
        operator delete((void *)lParam[0]);
      v18 = v43 + 7;
      v43 = v18;
      if ( v18 == v45[1] )
      {
        v18 = *v45;
        v43 = *v45;
      }
    }
    while ( v18 != v45[3] && v18 );
  }
  SendMessageW(hob, 0x14Eu, 0, 0);
  v24 = *(_DWORD *)(this + 728);
  if ( *(_DWORD *)(v24 + 4) && *(_DWORD *)(v24 + 1128) != -1 && *(_DWORD *)(v24 + 1132) != -1 )
  {
    SendMessageW(v48, 0x101Eu, 0, *(unsigned __int16 *)(v24 + 1128));
    SendMessageW(v48, 0x101Eu, 1u, *(unsigned __int16 *)(*(_DWORD *)(this + 728) + 1132));
  }
  v25 = *(_DWORD **)(this + 728);
  v26 = *(HWND *)(this + 4);
  if ( v25[1] )
  {
    SetWindowPos(v26, 0, v25[2], v25[3], v25[4], v25[5], 4u);
  }
  else
  {
    Parent = GetParent(*(HWND *)(this + 4));
    sub_4697F0(v26, Parent);
  }
  v28 = GetDlgItem(*(HWND *)(this + 4), 1225);
  SetFocus(v28);
  return 0;
}
// 4830E8: conditional instruction was optimized away because %wParam.4!=0
// 483214: conditional instruction was optimized away because edx.4!=0

//----- (00483350) --------------------------------------------------------
void __thiscall sub_483350(int this, LPCWSTR lpString1, wchar_t *String)
{
  _WORD *v3; // eax
  int v4; // edx
  __int16 v5; // cx
  int v6; // eax
  int v8[7]; // [esp+14h] [ebp-48h] BYREF
  void *v9[7]; // [esp+30h] [ebp-2Ch] BYREF
  int v10; // [esp+58h] [ebp-4h]

  if ( lstrcmpiW(lpString1, L"ColumnWidth1") )
  {
    if ( lstrcmpiW(lpString1, L"ColumnWidth2") )
    {
      if ( sub_469A50(L"Directory*", (int)lpString1, 1) )
      {
        sub_4095E0(v9, String);
        v10 = 0;
        sub_40AAD0((int)v9, this + 1060);
        if ( v9[5] >= (void *)8 )
          operator delete(v9[0]);
      }
      else if ( sub_469A50(L"Pattern*", (int)lpString1, 1) )
      {
        sub_4095E0(v8, String);
        v10 = 1;
        sub_416900(v8, *(_DWORD **)(this + 1072));
        sub_409000((int)v8);
      }
      else if ( lstrcmpiW(lpString1, L"SearchDirectoryText") )
      {
        if ( lstrcmpiW(lpString1, L"SearchSubFolders") )
        {
          if ( lstrcmpiW(lpString1, L"UseRegularExpressions") )
          {
            if ( lstrcmpiW(lpString1, L"CaseInsensitive") )
            {
              if ( lstrcmpiW(lpString1, L"Archive") )
              {
                if ( lstrcmpiW(lpString1, L"Hidden") )
                {
                  if ( lstrcmpiW(lpString1, L"ReadOnly") )
                  {
                    if ( lstrcmpiW(lpString1, L"System") )
                    {
                      if ( lstrcmpiW(lpString1, L"SortMode") )
                      {
                        if ( !lstrcmpiW(lpString1, L"SortAscending") )
                          *(_DWORD *)(this + 1124) = sub_464560(String);
                      }
                      else
                      {
                        v6 = _wtoi(String) - 1;
                        if ( v6 )
                        {
                          if ( v6 == 1 )
                            *(_DWORD *)(this + 1120) = 2;
                        }
                        else
                        {
                          *(_DWORD *)(this + 1120) = 1;
                        }
                      }
                    }
                    else
                    {
                      *(_DWORD *)(this + 1100) = sub_464560(String);
                    }
                  }
                  else
                  {
                    *(_DWORD *)(this + 1096) = sub_464560(String);
                  }
                }
                else
                {
                  *(_DWORD *)(this + 1092) = sub_464560(String);
                }
              }
              else
              {
                *(_DWORD *)(this + 1088) = sub_464560(String);
              }
            }
            else
            {
              *(_DWORD *)(this + 1084) = sub_464560(String);
            }
          }
          else
          {
            *(_DWORD *)(this + 1080) = sub_464560(String);
          }
        }
        else
        {
          *(_DWORD *)(this + 1076) = sub_464560(String);
        }
      }
      else
      {
        v3 = (_WORD *)(this + 540);
        v4 = 260;
        while ( v4 != -2147483386 )
        {
          v5 = *(_WORD *)((char *)v3 + (_DWORD)((char *)String - this - 540));
          if ( !v5 )
            break;
          *v3++ = v5;
          if ( !--v4 )
          {
            *(v3 - 1) = 0;
            return;
          }
        }
        *v3 = 0;
      }
    }
    else
    {
      *(_DWORD *)(this + 1132) = _wtoi(String);
    }
  }
  else
  {
    *(_DWORD *)(this + 1128) = _wtoi(String);
  }
}
// 4834A9: conditional instruction was optimized away because edx.4!=0
// 483350: using guessed type _DWORD var_48[7];

//----- (00483610) --------------------------------------------------------
void __thiscall sub_483610(int this, int a2, int a3)
{
  char *v4; // eax
  char *v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // esi
  OLECHAR *v9; // eax
  OLECHAR *v10; // eax
  OLECHAR *v11; // eax
  OLECHAR *v12; // eax
  OLECHAR *v13; // eax
  OLECHAR *v14; // eax
  OLECHAR *v15; // eax
  OLECHAR *v16; // eax
  char *v17; // eax
  _DWORD *v18; // eax
  int v19; // [esp-10h] [ebp-7Ch]
  _DWORD *v20; // [esp+14h] [ebp-58h]
  void *v21; // [esp+18h] [ebp-54h] BYREF
  int v22; // [esp+1Ch] [ebp-50h]
  _DWORD *v23; // [esp+24h] [ebp-48h]
  char *v24; // [esp+28h] [ebp-44h] BYREF
  int v25; // [esp+2Ch] [ebp-40h]
  int pExceptionObject[3]; // [esp+30h] [ebp-3Ch] BYREF
  void *v27[5]; // [esp+3Ch] [ebp-30h] BYREF
  unsigned int v28; // [esp+50h] [ebp-1Ch]
  int v29; // [esp+68h] [ebp-4h]

  v19 = *(_DWORD *)(this + 1128);
  v25 = a2;
  _itow_s(v19, Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"ColumnWidth1", Buffer);
  _itow_s(*(_DWORD *)(this + 1132), Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"ColumnWidth2", Buffer);
  sub_464E30((int)L"Directory", a3, a2, (_DWORD **)(this + 1060));
  v22 = 0;
  v4 = (char *)operator new(0x24u);
  v5 = v4;
  if ( !v4 )
  {
    v24 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v24);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)v4 = v4;
  v21 = v4;
  *((_DWORD *)v4 + 1) = v4;
  v29 = 0;
  v6 = *(_DWORD **)(this + 1072);
  v23 = v6;
  if ( v6[4] )
    v7 = (_DWORD *)v6[2];
  else
    v7 = 0;
  v20 = v7;
  if ( v7 )
  {
    do
    {
      v27[4] = 0;
      v28 = 7;
      LOWORD(v27[0]) = 0;
      sub_4090E0((int)v27, v20, 0, 0xFFFFFFFF);
      LOBYTE(v29) = 1;
      v17 = sub_40A200(v5, *((_DWORD *)v5 + 1), (int)v27);
      if ( v22 == 153391688 )
        std::_Xlength_error("list<T> too long");
      ++v22;
      *((_DWORD *)v5 + 1) = v17;
      **((_DWORD **)v17 + 1) = v17;
      LOBYTE(v29) = 0;
      if ( v28 >= 8 )
        operator delete(v27[0]);
      v18 = v20 + 7;
      v20 = v18;
      if ( v18 == (_DWORD *)v23[1] )
      {
        v18 = (_DWORD *)*v23;
        v20 = (_DWORD *)*v23;
      }
    }
    while ( v18 != (_DWORD *)v23[3] && v18 );
  }
  v8 = v25;
  sub_464E30((int)L"Pattern", a3, v25, (_DWORD **)&v21);
  sub_464A60(v8, a3, (OLECHAR *)L"SearchDirectoryText", (OLECHAR *)(this + 540));
  v9 = aYes_0;
  if ( !*(_DWORD *)(this + 1076) )
    v9 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"SearchSubFolders", v9);
  v10 = aYes_0;
  if ( !*(_DWORD *)(this + 1080) )
    v10 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"UseRegularExpressions", v10);
  v11 = aYes_0;
  if ( !*(_DWORD *)(this + 1084) )
    v11 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"CaseInsensitive", v11);
  v12 = aYes_0;
  if ( !*(_DWORD *)(this + 1088) )
    v12 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"Archive", v12);
  v13 = aYes_0;
  if ( !*(_DWORD *)(this + 1092) )
    v13 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"Hidden", v13);
  v14 = aYes_0;
  if ( !*(_DWORD *)(this + 1096) )
    v14 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"ReadOnly", v14);
  v15 = aYes_0;
  if ( !*(_DWORD *)(this + 1100) )
    v15 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"System", v15);
  _itow_s(*(_DWORD *)(this + 1120), Buffer, 0x40u, 10);
  sub_464A60(v8, a3, (OLECHAR *)L"SortMode", Buffer);
  v16 = aYes_0;
  if ( !*(_DWORD *)(this + 1124) )
    v16 = aNo_0;
  sub_464A60(v8, a3, (OLECHAR *)L"SortAscending", v16);
  sub_40A140((int)&v21);
  operator delete(v21);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C7290: using guessed type wchar_t aDirectory_3[10];
// 4C72A4: using guessed type wchar_t aPattern_4[8];
// 4EDC0C: using guessed type wchar_t aNo_0[3];
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (00483980) --------------------------------------------------------
void __thiscall sub_483980(int this, HKEY hKey)
{
  HKEY v3; // ebx
  int v4; // eax
  _DWORD *v5; // eax
  int pExceptionObject[3]; // [esp+10h] [ebp-28h] BYREF
  void *v7[3]; // [esp+1Ch] [ebp-1Ch] BYREF
  DWORD cbData[4]; // [esp+28h] [ebp-10h] BYREF

  v3 = hKey;
  cbData[0] = 4;
  RegQueryValueExW(hKey, L"ColumnWidth1", 0, 0, (LPBYTE)(this + 1128), cbData);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"ColumnWidth2", 0, 0, (LPBYTE)(this + 1132), (LPDWORD)&hKey);
  hKey = (HKEY)260;
  RegQueryValueExW(v3, L"SearchDirectoryText", 0, cbData, (LPBYTE)(this + 540), (LPDWORD)&hKey);
  v4 = (int)hKey;
  if ( hKey && cbData[0] == 1 )
  {
    if ( *(_WORD *)(this + 2 * (_DWORD)hKey + 538) )
    {
      if ( (unsigned int)hKey >= 0x104 )
        v4 = 260;
      *(_WORD *)(this + 2 * v4 + 540) = 0;
    }
  }
  else
  {
    *(_WORD *)(this + 540) = 0;
  }
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"SearchSubFolders", 0, 0, (LPBYTE)(this + 1076), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"UseRegularExpressions", 0, 0, (LPBYTE)(this + 1080), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"CaseInsensitive", 0, 0, (LPBYTE)(this + 1084), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"Archive", 0, 0, (LPBYTE)(this + 1088), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"Hidden", 0, 0, (LPBYTE)(this + 1092), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"ReadOnly", 0, 0, (LPBYTE)(this + 1096), (LPDWORD)&hKey);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"System", 0, 0, (LPBYTE)(this + 1100), (LPDWORD)&hKey);
  sub_464270((int)L"Directory", this + 1060, v3);
  v7[1] = 0;
  v5 = operator new(0x24u);
  if ( !v5 )
  {
    hKey = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&hKey);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v5 = v5;
  v7[0] = v5;
  v5[1] = v5;
  cbData[3] = 0;
  sub_464270((int)L"Pattern", (int)v7, v3);
  sub_417240(*(_DWORD **)(this + 1072), (_DWORD **)v7);
  hKey = (HKEY)4;
  RegQueryValueExW(v3, L"SortMode", 0, 0, (LPBYTE)(this + 1120), (LPDWORD)&hKey);
  cbData[0] = 4;
  RegQueryValueExW(v3, L"SortAscending", 0, 0, (LPBYTE)(this + 1124), cbData);
  sub_40A140((int)v7);
  operator delete(v7[0]);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C7204: using guessed type wchar_t aDirectory_4[10];
// 4C7218: using guessed type wchar_t aPattern_5[8];

//----- (00483C00) --------------------------------------------------------
void __thiscall sub_483C00(int this, HKEY hKey)
{
  int v3; // eax
  char *v4; // eax
  char *v5; // ebx
  int v6; // eax
  _DWORD *v7; // eax
  char *v8; // eax
  _DWORD *v9; // eax
  BYTE Data[4]; // [esp+14h] [ebp-58h] BYREF
  BYTE v11[4]; // [esp+18h] [ebp-54h] BYREF
  _DWORD *v12; // [esp+1Ch] [ebp-50h]
  void *v13; // [esp+20h] [ebp-4Ch] BYREF
  int v14; // [esp+24h] [ebp-48h]
  char *v15; // [esp+2Ch] [ebp-40h] BYREF
  int pExceptionObject[3]; // [esp+30h] [ebp-3Ch] BYREF
  void *v17[5]; // [esp+3Ch] [ebp-30h] BYREF
  unsigned int v18; // [esp+50h] [ebp-1Ch]
  int v19; // [esp+68h] [ebp-4h]

  *(_DWORD *)Data = *(_DWORD *)(this + 1128);
  RegSetValueExW(hKey, L"ColumnWidth1", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1132);
  RegSetValueExW(hKey, L"ColumnWidth2", 0, 4u, Data, 4u);
  v3 = lstrlenW((LPCWSTR)(this + 540));
  RegSetValueExW(hKey, L"SearchDirectoryText", 0, 1u, (const BYTE *)(this + 540), 2 * v3);
  *(_DWORD *)Data = *(_DWORD *)(this + 1076);
  RegSetValueExW(hKey, L"SearchSubFolders", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1080);
  RegSetValueExW(hKey, L"UseRegularExpressions", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1084);
  RegSetValueExW(hKey, L"CaseInsensitive", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1088);
  RegSetValueExW(hKey, L"Archive", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1092);
  RegSetValueExW(hKey, L"Hidden", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1096);
  RegSetValueExW(hKey, L"ReadOnly", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(this + 1100);
  RegSetValueExW(hKey, L"System", 0, 4u, Data, 4u);
  sub_464130(hKey, (_DWORD **)(this + 1060));
  v14 = 0;
  v4 = (char *)operator new(0x24u);
  v5 = v4;
  if ( !v4 )
  {
    v15 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v15);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)v4 = v4;
  v13 = v4;
  *((_DWORD *)v4 + 1) = v4;
  v19 = 0;
  v6 = *(_DWORD *)(this + 1072);
  *(_DWORD *)Data = v6;
  if ( *(_DWORD *)(v6 + 16) )
    v7 = *(_DWORD **)(v6 + 8);
  else
    v7 = 0;
  v12 = v7;
  if ( v7 )
  {
    do
    {
      v17[4] = 0;
      v18 = 7;
      LOWORD(v17[0]) = 0;
      sub_4090E0((int)v17, v12, 0, 0xFFFFFFFF);
      LOBYTE(v19) = 1;
      v8 = sub_40A200(v5, *((_DWORD *)v5 + 1), (int)v17);
      if ( v14 == 153391688 )
        std::_Xlength_error("list<T> too long");
      ++v14;
      *((_DWORD *)v5 + 1) = v8;
      **((_DWORD **)v8 + 1) = v8;
      LOBYTE(v19) = 0;
      if ( v18 >= 8 )
        operator delete(v17[0]);
      v9 = v12 + 7;
      v12 = v9;
      if ( v9 == *(_DWORD **)(*(_DWORD *)Data + 4) )
      {
        v9 = **(_DWORD ***)Data;
        v12 = **(_DWORD ***)Data;
      }
    }
    while ( v9 != *(_DWORD **)(*(_DWORD *)Data + 12) && v9 );
  }
  sub_464130(hKey, (_DWORD **)&v13);
  *(_DWORD *)Data = *(_DWORD *)(this + 1120);
  RegSetValueExW(hKey, L"SortMode", 0, 4u, Data, 4u);
  *(_DWORD *)v11 = *(_DWORD *)(this + 1124);
  RegSetValueExW(hKey, L"SortAscending", 0, 4u, v11, 4u);
  sub_40A140((int)&v13);
  operator delete(v13);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00483F30) --------------------------------------------------------
int __thiscall sub_483F30(int this, int a2)
{
  void *v4; // ebx
  ITEMIDLIST *v5; // edi
  char **v6; // eax
  int v7; // ecx
  WPARAM v8; // eax
  void *v9; // edi
  int v10; // [esp+10h] [ebp-98Ch]
  int i; // [esp+14h] [ebp-988h]
  HWND hWnd; // [esp+18h] [ebp-984h]
  int v13; // [esp+1Ch] [ebp-980h]
  LRESULT v14; // [esp+20h] [ebp-97Ch]
  LPARAM lParam[8]; // [esp+24h] [ebp-978h] BYREF
  int v16; // [esp+44h] [ebp-958h]
  int v17; // [esp+58h] [ebp-944h] BYREF
  LPARAM v18[13]; // [esp+60h] [ebp-93Ch] BYREF
  int v19; // [esp+94h] [ebp-908h] BYREF
  void *v20[5]; // [esp+98h] [ebp-904h] BYREF
  unsigned int v21; // [esp+ACh] [ebp-8F0h]
  SHFILEINFOW psfi; // [esp+B4h] [ebp-8E8h] BYREF
  WCHAR pszPath[260]; // [esp+36Ch] [ebp-630h] BYREF
  __int16 Src[260]; // [esp+574h] [ebp-428h] BYREF
  __int16 v25[262]; // [esp+77Ch] [ebp-220h] BYREF
  int v26; // [esp+998h] [ebp-4h]

  if ( a2 )
    return 1;
  hWnd = GetDlgItem(*(HWND *)(this + 4), 1226);
  v14 = SendMessageW(hWnd, 0x1004u, 0, 0);
  v10 = *(_DWORD *)(this + 660);
  if ( v10 >= 100 )
    v10 = 100;
  v4 = **(void ***)(this + 656);
  for ( i = 0; i < v10; ++i )
  {
    v5 = (ITEMIDLIST *)*((_DWORD *)v4 + 2);
    sub_466630(v5, pszPath, 0x8000);
    PathRemoveFileSpecW(pszPath);
    sub_466630(v5, (WCHAR *)Src, 0x8000);
    sub_466630(v5, (WCHAR *)v25, 32769);
    SHGetFileInfoW(&v5->mkid.cb, 0, &psfi, 0x2B4u, 0x4008u);
    v19 = *(_DWORD *)(this + 712);
    LOWORD(v20[0]) = 0;
    v21 = 7;
    v20[4] = 0;
    sub_4094F0(v20, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
    v26 = 0;
    v13 = **(_DWORD **)(this + 672);
    v6 = sub_4178F0(&v19, (char *)v13, *(_DWORD *)(v13 + 4));
    v7 = *(_DWORD *)(this + 676);
    if ( v7 == 134217726 )
      std::vector<void *>::_Xlen(0);
    *(_DWORD *)(this + 676) = v7 + 1;
    *(_DWORD *)(v13 + 4) = v6;
    *(_DWORD *)v6[1] = v6;
    sub_417310(this + 668, (int)&v17, **(_DWORD **)(this + 672) + 8, **(void ***)(this + 672));
    v26 = -1;
    if ( v21 >= 8 )
      operator delete(v20[0]);
    lParam[1] = v14 + i;
    v16 = *(_DWORD *)(this + 712);
    *(_DWORD *)(this + 712) = v16 + 1;
    lParam[5] = (LPARAM)v25;
    lParam[0] = 7;
    lParam[2] = 0;
    lParam[7] = psfi.iIcon;
    v8 = SendMessageW(hWnd, 0x104Du, 0, (LPARAM)lParam);
    v18[5] = (LPARAM)pszPath;
    v18[2] = 1;
    SendMessageW(hWnd, 0x1074u, v8, (LPARAM)v18);
    CoTaskMemFree(v5);
    v9 = *(void **)v4;
    if ( v4 != *(void **)(this + 656) )
    {
      **((_DWORD **)v4 + 1) = v9;
      *(_DWORD *)(*(_DWORD *)v4 + 4) = *((_DWORD *)v4 + 1);
      operator delete(v4);
      --*(_DWORD *)(this + 660);
    }
    v4 = v9;
  }
  *(_DWORD *)(this + 720) = 1;
  return 0;
}
// 48422E: using guessed type void __stdcall __noreturn std::vector<void *>::_Xlen(_DWORD);
// 483F30: using guessed type WCHAR Src[260];
// 483F30: using guessed type WCHAR var_220[262];

//----- (00484240) --------------------------------------------------------
int __thiscall sub_484240(WPARAM wParam, int a2)
{
  HWND v3; // edi
  LRESULT v4; // eax
  ITEMIDLIST *v5; // eax
  HWND v6; // edi
  LRESULT v7; // eax
  _DWORD *v8; // eax
  LPITEMIDLIST v9; // esi
  int v10; // edi
  DWORD MessagePos; // eax
  int v12; // ebx
  int *v13; // edi
  char KeyState; // al
  int v15; // edx
  int (__thiscall *v16)(int *); // eax
  int v17; // eax
  _DWORD *v18; // eax
  int v19; // edx
  HWND DlgItem; // eax
  int v22; // [esp-Ch] [ebp-E8h] BYREF
  WPARAM v23; // [esp-8h] [ebp-E4h]
  int (__stdcall *v24)(void *, int, int); // [esp-4h] [ebp-E0h]
  LPITEMIDLIST ID; // [esp+14h] [ebp-C8h] BYREF
  LPCITEMIDLIST pidl; // [esp+18h] [ebp-C4h] BYREF
  LPVOID pv; // [esp+1Ch] [ebp-C0h] BYREF
  int v28[2]; // [esp+20h] [ebp-BCh] BYREF
  void *v29[3]; // [esp+28h] [ebp-B4h] BYREF
  LPARAM v30[13]; // [esp+34h] [ebp-A8h] BYREF
  LPARAM lParam[13]; // [esp+68h] [ebp-74h] BYREF
  DWORD_PTR dwRefData[13]; // [esp+9Ch] [ebp-40h] BYREF
  int v33; // [esp+D8h] [ebp-4h]

  v28[0] = wParam;
  switch ( *(_DWORD *)(a2 + 8) )
  {
    case 0xFFFFFF94:
      v18 = *(_DWORD **)(wParam + 728);
      if ( *(_DWORD *)(v18[276] + 12 * *(_DWORD *)(a2 + 16)) == v18[280] )
      {
        v19 = v18[281] == 0;
      }
      else
      {
        v18[280] = *(_DWORD *)(v18[276] + 12 * *(_DWORD *)(a2 + 16));
        v18 = *(_DWORD **)(wParam + 728);
        v19 = *(unsigned __int8 *)(v18[276] + 12 * *(_DWORD *)(a2 + 16) + 8);
      }
      v24 = sub_481C60;
      v23 = wParam;
      v22 = 4144;
      v18[281] = v19;
      DlgItem = GetDlgItem(*(HWND *)(wParam + 4), 1226);
      SendMessageW(DlgItem, v22, v23, (LPARAM)v24);
      sub_481880(wParam);
      break;
    case 0xFFFFFFFB:
      if ( *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 4), 1226) )
      {
        v6 = GetDlgItem(*(HWND *)(wParam + 4), 1226);
        v7 = SendMessageW(v6, 0x100Cu, 0xFFFFFFFF, 2);
        if ( v7 != -1 )
        {
          v30[0] = 4;
          v30[1] = v7;
          v30[2] = 0;
          if ( SendMessageW(v6, 0x104Bu, 0, (LPARAM)v30) )
          {
            ID = (LPITEMIDLIST)v30[8];
            sub_417A20((_DWORD *)(wParam + 668), (int *)&ID, &pv);
            v8 = (char *)pv + 12;
            pidl = 0;
            if ( *((_DWORD *)pv + 8) >= 8u )
              v8 = (_DWORD *)*v8;
            if ( !sub_467810((LPITEMIDLIST *)&pidl, (int)v8) )
            {
              sub_40A470(v29);
              v33 = 0;
              ID = ILFindLastID(pidl);
              sub_40B7B0((int)&ID, (int)v29);
              v9 = ILClone(pidl);
              ILRemoveLastID(v9);
              ID = (LPITEMIDLIST)&v22;
              sub_40ACF0((char ***)&v22, (int **)v29);
              v10 = v28[0];
              sub_4AD000((int)dwRefData, *(_DWORD *)(v28[0] + 4), v9, (void *)v22, v23, (int)v24);
              LOBYTE(v33) = 1;
              MessagePos = GetMessagePos();
              v12 = v10 + 48;
              v13 = *(int **)(v10 + 724);
              v28[0] = (__int16)MessagePos;
              v28[1] = SHIWORD(MessagePos);
              KeyState = GetKeyState(16);
              v15 = *v13;
              v24 = (int (__stdcall *)(void *, int, int))(KeyState & 0x80);
              v16 = *(int (__thiscall **)(int *))(v15 + 36);
              v23 = 0;
              v22 = 0;
              v17 = v16(v13);
              sub_4AD640((DWORD_PTR)dwRefData, v12, v12, (int)v28, v17, v22, v23, (int)v24);
              CoTaskMemFree(v9);
              CoTaskMemFree((LPVOID)pidl);
              LOBYTE(v33) = 0;
              sub_4ACF20(dwRefData);
              sub_41ECB0(v29);
            }
          }
        }
      }
      break;
    case 0xFFFFFFFD:
      if ( *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 4), 1226) )
      {
        v3 = GetDlgItem(*(HWND *)(wParam + 4), 1226);
        v4 = SendMessageW(v3, 0x100Cu, 0xFFFFFFFF, 2);
        if ( v4 != -1 )
        {
          lParam[1] = v4;
          lParam[0] = 4;
          lParam[2] = 0;
          if ( SendMessageW(v3, 0x104Bu, 0, (LPARAM)lParam) )
          {
            pidl = (LPCITEMIDLIST)lParam[8];
            sub_417A20((_DWORD *)(wParam + 668), (int *)&pidl, &ID);
            v5 = ID + 4;
            pv = 0;
            if ( *(_DWORD *)ID[10].mkid.abID >= 8u )
              v5 = *(ITEMIDLIST **)&v5->mkid.cb;
            if ( !sub_467810((LPITEMIDLIST *)&pv, (int)v5) )
            {
              (*(void (__thiscall **)(_DWORD, LPVOID, _DWORD, _DWORD))(**(_DWORD **)(wParam + 724) + 32))(
                *(_DWORD *)(wParam + 724),
                pv,
                0,
                0);
              CoTaskMemFree(pv);
            }
          }
        }
      }
      break;
    case 0xFFFFFFFE:
      if ( *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 4), 1285) )
        ShellExecuteW(0, L"open", (LPCWSTR)(a2 + 124), 0, 0, 5);
      break;
    default:
      return 0;
  }
  return 0;
}

//----- (00484670) --------------------------------------------------------
HANDLE __userpurge sub_484670@<eax>(int a1@<ecx>, int a2@<esi>, LPCWSTR pszDir)
{
  HANDLE result; // eax
  HANDLE v4; // ebx
  int v5; // ebx
  bool v6; // zf
  int v7; // eax
  char dwFileAttributes; // cl
  LPITEMIDLIST v9; // eax
  char *v10; // edi
  char *v11; // eax
  int v12; // ecx
  HANDLE v14; // [esp+14h] [ebp-8A8h]
  LPCITEMIDLIST pidl; // [esp+18h] [ebp-8A4h] BYREF
  char v16; // [esp+1Fh] [ebp-89Dh]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+20h] [ebp-89Ch] BYREF
  void *v18[4]; // [esp+274h] [ebp-648h] BYREF
  int v19; // [esp+284h] [ebp-638h]
  unsigned int v20; // [esp+288h] [ebp-634h]
  WCHAR pszDest[260]; // [esp+290h] [ebp-62Ch] BYREF
  WCHAR v22[260]; // [esp+498h] [ebp-424h] BYREF
  WCHAR Src; // [esp+6A0h] [ebp-21Ch] BYREF
  __int16 v24; // [esp+6A2h] [ebp-21Ah] BYREF
  int v25; // [esp+8B8h] [ebp-4h]

  PathCombineW(pszDest, pszDir, L"*");
  result = FindFirstFileW(pszDest, &FindFileData);
  v4 = result;
  v14 = result;
  if ( result != (HANDLE)-1 )
  {
    v16 = 0;
    if ( FindNextFileW(result, &FindFileData) )
    {
      do
      {
        if ( v16 )
          break;
        if ( lstrcmpiW(FindFileData.cFileName, L".") && lstrcmpiW(FindFileData.cFileName, L"..") )
        {
          v5 = 0;
          pidl = 0;
          if ( !lstrcmpW((LPCWSTR)(a2 + 532), &word_4C6F80)
            || (!*(_DWORD *)(a2 + 1060) ? (v6 = !sub_469A50(
                                                   (LPCWSTR)(a2 + 532),
                                                   (int)FindFileData.cFileName,
                                                   *(_DWORD *)(a2 + 1064) == 0)) : (v6 = !sub_417730(
                                                                                            (int)FindFileData.cFileName,
                                                                                            (int)&FindFileData.cFileName[wcslen(FindFileData.cFileName)],
                                                                                            (int *)(a2 + 1072),
                                                                                            16)),
                !v6) )
          {
            v5 = 1;
          }
          v7 = *(_DWORD *)(a2 + 1056);
          dwFileAttributes = FindFileData.dwFileAttributes;
          if ( !v7 || (FindFileData.dwFileAttributes & v7) == v7 )
            pidl = (LPCITEMIDLIST)1;
          if ( v5 && pidl )
          {
            if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
              ++*(_DWORD *)(a2 + 1116);
            else
              ++*(_DWORD *)(a2 + 1120);
            pidl = 0;
            PathCombineW(v22, pszDir, FindFileData.cFileName);
            sub_467810((LPITEMIDLIST *)&pidl, (int)v22);
            v9 = ILClone(pidl);
            PostMessageW(*(HWND *)(a2 + 8), 0x8001u, (WPARAM)v9, 0);
            CoTaskMemFree((LPVOID)pidl);
            dwFileAttributes = FindFileData.dwFileAttributes;
          }
          if ( (dwFileAttributes & 0x10) != 0 )
          {
            PathCombineW(&Src, pszDir, FindFileData.cFileName);
            LOWORD(v18[0]) = 0;
            v20 = 7;
            v19 = 0;
            sub_4094F0(v18, (int)&v24, &Src, wcslen(&Src));
            v25 = 0;
            v10 = *(char **)a1;
            v11 = sub_40A200(*(char **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4), (int)v18);
            v12 = *(_DWORD *)(a1 + 4);
            if ( v12 == 153391688 )
              std::_Xlength_error("list<T> too long");
            *(_DWORD *)(a1 + 4) = v12 + 1;
            *((_DWORD *)v10 + 1) = v11;
            **((_DWORD **)v11 + 1) = v11;
            v25 = -1;
            if ( v20 >= 8 )
              operator delete(v18[0]);
            v20 = 7;
            v19 = 0;
            LOWORD(v18[0]) = 0;
          }
          v4 = v14;
        }
        EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 1088));
        if ( *(_DWORD *)(a2 + 1112) )
          v16 = 1;
        LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 1088));
      }
      while ( FindNextFileW(v4, &FindFileData) );
    }
    return (HANDLE)FindClose(v4);
  }
  return result;
}

//----- (004849D0) --------------------------------------------------------
void __thiscall sub_4849D0(int this, WPARAM wParam)
{
  _DWORD *v3; // eax
  char v4; // bl
  _DWORD *i; // edi
  WPARAM *v6; // eax
  void *v7[3]; // [esp+10h] [ebp-4Ch] BYREF
  char *v8; // [esp+1Ch] [ebp-40h] BYREF
  int pExceptionObject[3]; // [esp+20h] [ebp-3Ch] BYREF
  WPARAM v10[5]; // [esp+2Ch] [ebp-30h] BYREF
  unsigned int v11; // [esp+40h] [ebp-1Ch]
  int v12; // [esp+58h] [ebp-4h]

  SendMessageW(*(HWND *)(this + 8), 0x8003u, wParam, 0);
  v7[1] = 0;
  v3 = operator new(0x24u);
  if ( !v3 )
  {
    v8 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v3 = v3;
  v7[0] = v3;
  v3[1] = v3;
  v12 = 0;
  sub_484670((int)v7, this, (LPCWSTR)wParam);
  v4 = 0;
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 1088));
  if ( *(_DWORD *)(this + 1112) )
    v4 = 1;
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 1088));
  if ( !v4 )
  {
    if ( *(_DWORD *)(this + 1068) )
    {
      for ( i = *(_DWORD **)v7[0]; i != v7[0]; i = (_DWORD *)*i )
      {
        v11 = 7;
        v10[4] = 0;
        LOWORD(v10[0]) = 0;
        sub_4090E0((int)v10, i + 2, 0, 0xFFFFFFFF);
        LOBYTE(v12) = 1;
        v6 = (WPARAM *)v10[0];
        if ( v11 < 8 )
          v6 = v10;
        sub_4849D0(this, (WPARAM)v6);
        LOBYTE(v12) = 0;
        if ( v11 >= 8 )
          operator delete((void *)v10[0]);
      }
    }
  }
  sub_40A140((int)v7);
  operator delete(v7[0]);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00484B50) --------------------------------------------------------
LONG __stdcall sub_484B50(int a1)
{
  const unsigned __int16 *v1; // edi
  int *v2; // eax
  LONG result; // eax
  _DWORD v4[6]; // [esp+0h] [ebp-24h] BYREF
  int v5; // [esp+20h] [ebp-4h]

  v4[5] = v4;
  v1 = (const unsigned __int16 *)(a1 + 532);
  *(_DWORD *)(a1 + 1116) = 0;
  *(_DWORD *)(a1 + 1120) = 0;
  if ( lstrcmpW((LPCWSTR)(a1 + 532), &word_4C6F6C) && *(_DWORD *)(a1 + 1060) )
  {
    v5 = 0;
    v2 = (int *)(a1 + 1072);
    if ( *(_DWORD *)(a1 + 1064) )
      sub_40BE20(v2, v1, 0x100u);
    else
      sub_40BE20(v2, v1, 1u);
  }
  v5 = -1;
  sub_4849D0(a1, a1 + 12);
  SendMessageW(
    *(HWND *)(a1 + 8),
    0x8002u,
    0,
    *(unsigned __int16 *)(a1 + 1116) | (*(unsigned __int16 *)(a1 + 1120) << 16));
  result = InterlockedDecrement((volatile LONG *)(a1 + 4));
  if ( !result )
    return (**(int (__thiscall ***)(int, int))a1)(a1, 1);
  return result;
}

//----- (00484C60) --------------------------------------------------------
DWORD __stdcall sub_484C60(LPVOID lpThreadParameter)
{
  sub_484B50((int)lpThreadParameter);
  return 0;
}

//----- (00484C80) --------------------------------------------------------
void __thiscall sub_484C80(int this)
{
  int v1; // esi
  bool v2; // zf
  HWND DlgItem; // eax
  HWND v4; // eax
  _DWORD **v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  HWND v8; // eax
  UINT v9; // eax
  HWND v10; // ecx
  HWND v11; // ebx
  int v12; // edi
  WCHAR *v13; // eax
  int v14; // edx
  WCHAR v15; // cx
  HWND v16; // eax
  void *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // edi
  int v22; // ebx
  char *v23; // eax
  int v24; // ecx
  LRESULT (__stdcall *v25)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v26; // ebx
  int v27; // eax
  const WCHAR *v28; // eax
  int v29; // ecx
  void *v30; // edx
  int v31; // esi
  HWND v32; // ebx
  int v33; // ecx
  int v34; // edx
  int v35; // esi
  int v36; // eax
  _DWORD *v37; // edi
  unsigned int v38; // esi
  LRESULT v39; // eax
  void *v40; // ecx
  HANDLE Thread; // eax
  int v42; // esi
  void *v43[4]; // [esp-2Ch] [ebp-7A4h] BYREF
  int v44; // [esp-1Ch] [ebp-794h]
  int v45; // [esp-18h] [ebp-790h]
  SIZE_T v46; // [esp-14h] [ebp-78Ch]
  LPTHREAD_START_ROUTINE v47; // [esp-10h] [ebp-788h] BYREF
  LPVOID v48; // [esp-Ch] [ebp-784h]
  int v49; // [esp-8h] [ebp-780h] BYREF
  DWORD *v50; // [esp-4h] [ebp-77Ch]
  LPARAM lParam[9]; // [esp+10h] [ebp-768h] BYREF
  LPARAM v52[9]; // [esp+34h] [ebp-744h] BYREF
  int v53[3]; // [esp+58h] [ebp-720h] BYREF
  int v54; // [esp+64h] [ebp-714h] BYREF
  HWND v55; // [esp+68h] [ebp-710h]
  int v56; // [esp+6Ch] [ebp-70Ch]
  int v57; // [esp+70h] [ebp-708h] BYREF
  HWND hWnd; // [esp+74h] [ebp-704h]
  HWND v59; // [esp+78h] [ebp-700h]
  void *v60[5]; // [esp+7Ch] [ebp-6FCh] BYREF
  unsigned int v61; // [esp+90h] [ebp-6E8h]
  void *v62[5]; // [esp+98h] [ebp-6E0h] BYREF
  unsigned int v63; // [esp+ACh] [ebp-6CCh]
  void *v64[5]; // [esp+B4h] [ebp-6C4h] BYREF
  unsigned int v65; // [esp+C8h] [ebp-6B0h]
  WCHAR String; // [esp+D0h] [ebp-6A8h] BYREF
  __int16 v67; // [esp+D2h] [ebp-6A6h] BYREF
  WCHAR Src; // [esp+2D8h] [ebp-4A0h] BYREF
  __int16 v69; // [esp+2DAh] [ebp-49Eh] BYREF
  WCHAR Buffer[64]; // [esp+4E0h] [ebp-298h] BYREF
  WCHAR pszPath[260]; // [esp+560h] [ebp-218h] BYREF
  int v72; // [esp+774h] [ebp-4h]

  v1 = this;
  v2 = *(_DWORD *)(this + 580) == 0;
  v56 = this;
  if ( v2 )
  {
    DlgItem = GetDlgItem(*(HWND *)(this + 4), 1285);
    ShowWindow(DlgItem, 0);
    v4 = GetDlgItem(*(HWND *)(v1 + 4), 1250);
    ShowWindow(v4, 5);
    v5 = *(_DWORD ***)(v1 + 656);
    v6 = *v5;
    *v5 = v5;
    *(_DWORD *)(*(_DWORD *)(v1 + 656) + 4) = *(_DWORD *)(v1 + 656);
    *(_DWORD *)(v1 + 660) = 0;
    if ( v6 != *(_DWORD **)(v1 + 656) )
    {
      do
      {
        v7 = (_DWORD *)*v6;
        operator delete(v6);
        v6 = v7;
      }
      while ( v7 != *(_DWORD **)(v1 + 656) );
    }
    sub_4168A0((_DWORD *)(v1 + 668));
    v8 = GetDlgItem(*(HWND *)(v1 + 4), 1226);
    SendMessageW(v8, 0x1009u, 0, 0);
    GetDlgItemTextW(*(HWND *)(v1 + 4), 1224, &String, 260);
    PathRemoveBlanksW(&String);
    GetDlgItemTextW(*(HWND *)(v1 + 4), 1225, pszPath, 260);
    PathRemoveBlanksW(pszPath);
    v9 = IsDlgButtonChecked(*(HWND *)(v1 + 4), 1249);
    v10 = *(HWND *)(v1 + 4);
    v11 = (HWND)(v9 == 1);
    v59 = v11;
    v12 = IsDlgButtonChecked(v10, 1281) == 1;
    hWnd = (HWND)(IsDlgButtonChecked(*(HWND *)(v1 + 4), 1282) == 1);
    if ( !v12 && lstrlenW(pszPath) > 0 && pszPath[0] != 42 && Buffer[lstrlenW(pszPath) + 63] != 42 )
    {
      sub_401000(0x104u, &Src, L"*%s*", pszPath);
      v13 = pszPath;
      v14 = 260;
      while ( v14 != -2147483386 )
      {
        v15 = *(WCHAR *)((char *)v13 + (char *)&Src - (char *)pszPath);
        if ( !v15 )
          break;
        *v13++ = v15;
        if ( !--v14 )
        {
          --v13;
          break;
        }
      }
      v11 = v59;
      *v13 = 0;
    }
    v16 = *(HWND *)(v1 + 4);
    v59 = 0;
    if ( IsDlgButtonChecked(v16, 1060) == 1 )
      v59 = (HWND)32;
    if ( IsDlgButtonChecked(*(HWND *)(v1 + 4), 1061) == 1 )
      v59 = (HWND)((unsigned int)v59 | 2);
    if ( IsDlgButtonChecked(*(HWND *)(v1 + 4), 1062) == 1 )
      v59 = (HWND)((unsigned int)v59 | 1);
    if ( IsDlgButtonChecked(*(HWND *)(v1 + 4), 1059) == 1 )
      v59 = (HWND)((unsigned int)v59 | 4);
    v17 = operator new(0x464u);
    if ( v17 )
    {
      v18 = sub_4823E0((int)v17, *(_DWORD *)(v1 + 4), (int)&String, (int)pszPath, (int)v59, v12, (int)hWnd, (int)v11);
      v1 = v56;
    }
    else
    {
      v18 = 0;
    }
    *(_DWORD *)(v1 + 652) = v18;
    InterlockedIncrement((volatile LONG *)(v18 + 4));
    v19 = *(_DWORD *)(v1 + 728);
    if ( !*(_DWORD *)(v19 + 1064) )
      goto LABEL_29;
    v20 = **(_DWORD **)(v19 + 1060) + 8;
    if ( *(_DWORD *)(v20 + 20) >= 8u )
      v20 = *(_DWORD *)v20;
    if ( !lstrcmpW(&String, (LPCWSTR)v20) )
    {
      v25 = SendMessageW;
    }
    else
    {
LABEL_29:
      LOWORD(v62[0]) = 0;
      v63 = 7;
      v62[4] = 0;
      sub_4094F0(v62, (int)&v67, &String, wcslen(&String));
      v72 = 0;
      v21 = *(_DWORD *)(v1 + 728);
      v22 = **(_DWORD **)(v21 + 1060);
      v23 = sub_40A200((char *)v22, *(_DWORD *)(v22 + 4), (int)v62);
      v24 = *(_DWORD *)(v21 + 1064);
      if ( v24 == 153391688 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(v21 + 1064) = v24 + 1;
      *(_DWORD *)(v22 + 4) = v23;
      **((_DWORD **)v23 + 1) = v23;
      v72 = -1;
      if ( v63 >= 8 )
        operator delete(v62[0]);
      v25 = SendMessageW;
      v26 = GetDlgItem(*(HWND *)(v1 + 4), 1224);
      hWnd = (HWND)SendMessageW(v26, 0x406u, 0, 0);
      lParam[0] = 1;
      lParam[1] = 0;
      lParam[2] = (LPARAM)&String;
      SendMessageW(v26, 0x40Bu, 0, (LPARAM)lParam);
      SendMessageW(hWnd, 0x14Eu, 0, 0);
    }
    v27 = *(_DWORD *)(*(_DWORD *)(v1 + 728) + 1072);
    if ( !*(_DWORD *)(v27 + 16) )
      goto LABEL_39;
    v28 = *(const WCHAR **)(v27 + 8);
    if ( *((_DWORD *)v28 + 5) >= 8u )
      v28 = *(const WCHAR **)v28;
    if ( lstrcmpW(pszPath, v28) )
    {
LABEL_39:
      GetDlgItemTextW(*(HWND *)(v1 + 4), 1225, &Src, 260);
      LOWORD(v60[0]) = 0;
      v61 = 7;
      v60[4] = 0;
      sub_4094F0(v60, (int)&v69, &Src, wcslen(&Src));
      v72 = 1;
      v49 = *(_DWORD *)(*(_DWORD *)(v1 + 728) + 1072);
      v50 = 0;
      v29 = *(_DWORD *)(*(_DWORD *)(v1 + 728) + 1072);
      hWnd = (HWND)&v47;
      if ( *(_DWORD *)(v29 + 16) )
        v30 = *(void **)(v29 + 8);
      else
        v30 = 0;
      v47 = (LPTHREAD_START_ROUTINE)v29;
      v48 = v30;
      hWnd = (HWND)v43;
      v45 = 7;
      v44 = 0;
      LOWORD(v43[0]) = 0;
      sub_4090E0((int)v43, v60, 0, 0xFFFFFFFF);
      sub_417180(&v54, v43[0], (int)v43[1], (int)v43[2], (int)v43[3], v44, v45, v46, (int)v47, (int)v48, v49, (int)v50);
      v31 = v56;
      v32 = GetDlgItem(*(HWND *)(v56 + 4), 1225);
      v59 = (HWND)v25(v32, 0x406u, 0, 0);
      v25(v59, 0x14Eu, 0xFFFFFFFF, 0);
      if ( v55 )
      {
        v33 = *(_DWORD *)(*(_DWORD *)(v31 + 728) + 1072);
        if ( *(_DWORD *)(v33 + 16) )
          v34 = *(_DWORD *)(v33 + 8);
        else
          v34 = 0;
        hWnd = v55;
        v53[0] = v33;
        v57 = v54;
        v53[1] = v34;
        v35 = sub_417880((int)&v57, (int)v53);
        v36 = sub_417880((int)&v57, (int)&v57);
        v25(v32, 0x144u, (v36 - v35) / 28, 0);
        v31 = v56;
        v49 = v54;
        v50 = (DWORD *)v55;
        v37 = *(_DWORD **)(*(_DWORD *)(v56 + 728) + 1072);
        hWnd = (HWND)&v49;
        sub_416AF0(v37, v53, v54, (int)v55);
        v25 = SendMessageW;
      }
      v65 = 7;
      v64[4] = 0;
      LOWORD(v64[0]) = 0;
      sub_4094F0(v64, (int)&Src, &Src, wcslen(&Src));
      LOBYTE(v72) = 2;
      sub_4169E0(*(int **)(*(_DWORD *)(v31 + 728) + 1072), v64);
      if ( v65 >= 8 )
        operator delete(v64[0]);
      v52[0] = 1;
      v52[1] = 0;
      v52[2] = (LPARAM)&Src;
      v25(v32, 0x40Bu, 0, (LPARAM)v52);
      v38 = (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v31 + 728) + 1072) + 4) - **(_DWORD **)(*(_DWORD *)(v31 + 728) + 1072))
          / 28;
      if ( v25(v59, 0x146u, 0, 0) > v38 )
      {
        v50 = 0;
        v39 = v25(v59, 0x146u, 0, 0);
        v25(v32, 0x144u, v39 - 1, (LPARAM)v50);
      }
      if ( v61 >= 8 )
        operator delete(v60[0]);
      v1 = v56;
    }
    GetDlgItemTextW(*(HWND *)(v1 + 4), 1227, (LPWSTR)(v1 + 588), 32);
    LoadStringW(*(HINSTANCE *)(v1 + 8), 0x849u, Buffer, 64);
    SetDlgItemTextW(*(HWND *)(v1 + 4), 1227, Buffer);
    v40 = *(void **)(v1 + 652);
    v50 = 0;
    v49 = 0;
    v48 = v40;
    v47 = sub_484C60;
    v46 = 0;
    v45 = 0;
    *(_DWORD *)(v1 + 580) = 1;
    Thread = CreateThread((LPSECURITY_ATTRIBUTES)v45, v46, v47, v48, v49, v50);
    CloseHandle(Thread);
  }
  else
  {
    *(_DWORD *)(this + 584) = 1;
    v42 = *(_DWORD *)(this + 652);
    if ( v42 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(v42 + 1088));
      v50 = (DWORD *)(v42 + 1088);
      *(_DWORD *)(v42 + 1112) = 1;
      LeaveCriticalSection((LPCRITICAL_SECTION)v50);
    }
  }
}
// 484E73: conditional instruction was optimized away because edx.4!=0
// 4C6F48: using guessed type wchar_t aS_1[5];

//----- (004854B0) --------------------------------------------------------
int __thiscall sub_4854B0(int this, unsigned __int16 a2, int a3)
{
  HWND v5; // eax
  ITEMIDLIST *v6; // edi
  struct _browseinfoW bi; // [esp+8h] [ebp-840h] BYREF
  WCHAR String[260]; // [esp+28h] [ebp-820h] BYREF
  WCHAR v9[260]; // [esp+230h] [ebp-618h] BYREF
  WCHAR Buffer[256]; // [esp+438h] [ebp-410h] BYREF
  char v11; // [esp+638h] [ebp-210h] BYREF

  if ( a2 > 0x4CCu )
  {
    if ( a2 == 1229 )
    {
      LoadStringW(*(HINSTANCE *)(this + 8), 0x84Du, Buffer, 256);
      GetDlgItemTextW(*(HWND *)(this + 4), 1224, String, 260);
      v5 = *(HWND *)(this + 4);
      bi.pszDisplayName = (LPWSTR)&v11;
      bi.hwndOwner = v5;
      bi.pidlRoot = 0;
      bi.lpszTitle = Buffer;
      bi.ulFlags = 65;
      bi.lpfn = (BFFCALLBACK)sub_4816B0;
      bi.lParam = (LPARAM)String;
      v6 = SHBrowseForFolderW(&bi);
      if ( v6 )
      {
        sub_466630(v6, v9, 0x8000);
        SetDlgItemTextW(*(HWND *)(this + 4), 1224, v9);
        CoTaskMemFree(v6);
      }
    }
  }
  else
  {
    if ( a2 == 1228 || a2 == 2 )
    {
      DestroyWindow(*(HWND *)(this + 4));
      return 0;
    }
    if ( a2 == 1227 )
    {
      sub_484C80(this);
      return 0;
    }
  }
  return 0;
}

//----- (004856A0) --------------------------------------------------------
int __thiscall sub_4856A0(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (004856B0) --------------------------------------------------------
int __thiscall sub_4856B0(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 48);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 48) + 4) = 1;
  return result;
}

//----- (00485710) --------------------------------------------------------
void __usercall sub_485710(_DWORD *a1@<eax>)
{
  void *v1; // esi

  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (00485750) --------------------------------------------------------
int __thiscall sub_485750(int this)
{
  HWND DlgItem; // edi
  int v3; // eax
  HWND v4; // edi
  _DWORD *v5; // esi
  HWND Parent; // eax
  void *v8[7]; // [esp+8h] [ebp-20h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1184);
  v3 = (*(int (__thiscall **)(_DWORD, void **, _DWORD))(**(_DWORD **)(this + 52) + 8))(
         *(_DWORD *)(this + 52),
         v8,
         *(_DWORD *)(this + 56));
  if ( *(_DWORD *)(v3 + 20) >= 8u )
    v3 = *(_DWORD *)v3;
  SetWindowTextW(DlgItem, (LPCWSTR)v3);
  if ( v8[5] >= (void *)8 )
    operator delete(v8[0]);
  CheckDlgButton(*(HWND *)(this + 4), 1074, 1u);
  EnableWindow(DlgItem, 1);
  SendMessageW(DlgItem, 0xB1u, 0, -1);
  SetFocus(DlgItem);
  v4 = *(HWND *)(this + 4);
  v5 = *(_DWORD **)(this + 48);
  if ( v5[1] )
  {
    SetWindowPos(v4, 0, v5[2], v5[3], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v4);
    sub_4697F0(v4, Parent);
  }
  return 0;
}

//----- (00485830) --------------------------------------------------------
int *sub_485830()
{
  if ( (dword_4F1FD0 & 1) == 0 )
  {
    dword_4F1FD0 |= 1u;
    sub_4653E0((int)&dword_4F0A18, (int)L"RenameTab");
    dword_4F0A18 = (int)&CRenameTabDialogPersistentSettings::`vftable';
    atexit(sub_4BCCF0);
  }
  return &dword_4F0A18;
}
// 4C7530: using guessed type wchar_t aRenametab[10];
// 4CC0F4: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 4F0A18: using guessed type int dword_4F0A18;
// 4F1FD0: using guessed type int dword_4F1FD0;

//----- (00485870) --------------------------------------------------------
int __userpurge sub_485870@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>, int a4)
{
  int result; // eax

  *(_DWORD *)(a3 + 8) = hInstance;
  *(_BYTE *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 52) = a4;
  *(_DWORD *)(a3 + 12) = 213;
  *(_DWORD *)(a3 + 16) = a2;
  *(_DWORD *)a3 = &CRenameTabDialog::`vftable';
  *(_DWORD *)(a3 + 56) = a1;
  if ( (dword_4F1FD0 & 1) == 0 )
  {
    dword_4F1FD0 |= 1u;
    sub_4653E0((int)&dword_4F0A18, (int)L"RenameTab");
    dword_4F0A18 = (int)&CRenameTabDialogPersistentSettings::`vftable';
    atexit(sub_4BCCF0);
  }
  result = a3;
  *(_DWORD *)(a3 + 48) = &dword_4F0A18;
  return result;
}
// 4C7530: using guessed type wchar_t aRenametab[10];
// 4CC0BC: using guessed type void *CRenameTabDialog::`vftable';
// 4CC0F4: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 4F0A18: using guessed type int dword_4F0A18;
// 4F1FD0: using guessed type int dword_4F1FD0;

//----- (004858F0) --------------------------------------------------------
BOOL __usercall sub_4858F0@<eax>(int a1@<esi>)
{
  UINT v1; // ebx
  int v2; // eax
  ITEMIDLIST *v3; // edi
  HWND DlgItem; // eax
  int v5; // edx
  int v6; // kr00_4
  _DWORD v8[4]; // [esp-20h] [ebp-238h] BYREF
  int v9; // [esp-10h] [ebp-228h]
  int v10; // [esp-Ch] [ebp-224h]
  int v11; // [esp-8h] [ebp-220h]
  BOOL v12; // [esp-4h] [ebp-21Ch]
  _DWORD *v13; // [esp+8h] [ebp-210h]
  WCHAR String[260]; // [esp+Ch] [ebp-20Ch] BYREF

  v1 = IsDlgButtonChecked(*(HWND *)(a1 + 4), 1183);
  if ( v1 == 1 )
  {
    v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 52) + 4))(*(_DWORD *)(a1 + 52));
    v3 = (ITEMIDLIST *)(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 56))(v2);
    sub_466630(v3, String, 1);
    CoTaskMemFree(v3);
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1184);
    GetWindowTextW(DlgItem, String, 260);
  }
  if ( lstrlenW(String) > 0 )
  {
    v12 = v1 != 1;
    HIWORD(v5) = 0;
    v10 = 7;
    v9 = 0;
    v13 = v8;
    LOWORD(v8[0]) = 0;
    v6 = wcslen(String);
    sub_4094F0(v8, v5, String, v6);
    (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, int, int, BOOL))(**(_DWORD **)(a1 + 52)
                                                                                                + 12))(
      *(_DWORD *)(a1 + 52),
      *(_DWORD *)(a1 + 56),
      v8[0],
      v8[1],
      v8[2],
      v8[3],
      v9,
      v10,
      v11,
      v12);
  }
  return EndDialog(*(HWND *)(a1 + 4), 1);
}
// 4859C7: variable 'v5' is possibly undefined

//----- (00485A00) --------------------------------------------------------
int __thiscall sub_485A00(HWND *this, unsigned __int16 a2, int a3)
{
  HWND v4; // esi
  HWND DlgItem; // eax

  if ( a2 > 0x432u )
  {
    if ( a2 != 1183 )
      return 0;
    DlgItem = GetDlgItem(this[1], 1184);
    EnableWindow(DlgItem, 0);
    return 0;
  }
  else if ( a2 == 1074 )
  {
    v4 = GetDlgItem(this[1], 1184);
    EnableWindow(v4, 1);
    SetFocus(v4);
    return 0;
  }
  else
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 )
        EndDialog(this[1], 0);
      return 0;
    }
    sub_4858F0((int)this);
    return 0;
  }
}

//----- (00485A90) --------------------------------------------------------
int __usercall sub_485A90@<eax>(HKEY hKey@<ecx>, int a2@<esi>)
{
  int result; // eax
  DWORD cbData; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  result = RegOpenKeyExW(hKey, L"OrganizeBookmarks", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(phkResult, L"Position", 0, 0, (LPBYTE)(a2 + 61208), &cbData) )
      *(_DWORD *)(a2 + 61204) = 1;
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485B00) --------------------------------------------------------
int __usercall sub_485B00@<eax>(HKEY hKey@<ecx>, int a2@<esi>)
{
  int result; // eax
  DWORD cbData; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  result = RegOpenKeyExW(hKey, L"DisplayColors", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(phkResult, L"Position", 0, 0, (LPBYTE)(a2 + 61220), &cbData) )
      *(_DWORD *)(a2 + 61216) = 1;
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485B70) --------------------------------------------------------
int __usercall sub_485B70@<eax>(HKEY hKey@<ecx>, int a2@<esi>)
{
  int result; // eax
  DWORD cbData; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  result = RegOpenKeyExW(hKey, L"AddBookmark", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(phkResult, L"Position", 0, 0, (LPBYTE)(a2 + 61196), &cbData) )
      *(_DWORD *)(a2 + 61192) = 1;
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485BE0) --------------------------------------------------------
LSTATUS __usercall sub_485BE0@<eax>(int a1@<eax>, HKEY a2@<edx>)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF

  result = RegCreateKeyExW(a2, L"OrganizeBookmarks", 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 61204) )
      RegSetValueExW(phkResult, L"Position", 0, 3u, (const BYTE *)(a1 + 61208), 8u);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485C40) --------------------------------------------------------
LSTATUS __usercall sub_485C40@<eax>(int a1@<eax>, HKEY a2@<edx>)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF

  result = RegCreateKeyExW(a2, L"DisplayColors", 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 61216) )
      RegSetValueExW(phkResult, L"Position", 0, 3u, (const BYTE *)(a1 + 61220), 8u);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485CA0) --------------------------------------------------------
LSTATUS __usercall sub_485CA0@<eax>(int a1@<eax>, HKEY a2@<edx>)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [esp+4h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+8h] [ebp-4h] BYREF

  result = RegCreateKeyExW(a2, L"AddBookmark", 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 61192) )
      RegSetValueExW(phkResult, L"Position", 0, 3u, (const BYTE *)(a1 + 61196), 8u);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485D00) --------------------------------------------------------
LSTATUS __thiscall sub_485D00(void *this, HKEY hKey, LPCWSTR lpString, int Value)
{
  HKEY v4; // edi
  int v5; // eax
  int v6; // eax
  LSTATUS result; // eax
  const WCHAR *v8; // esi
  DWORD dwDisposition; // [esp+Ch] [ebp-58h] BYREF
  void *v10; // [esp+10h] [ebp-54h]
  HKEY v11; // [esp+14h] [ebp-50h]
  HKEY v12; // [esp+18h] [ebp-4Ch] BYREF
  HKEY phkResult; // [esp+1Ch] [ebp-48h] BYREF
  WCHAR SubKey[32]; // [esp+20h] [ebp-44h] BYREF

  v10 = this;
  v11 = hKey;
  _itow_s(Value, SubKey, 0x20u, 10);
  RegCreateKeyExW(hKey, SubKey, 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  v4 = phkResult;
  v5 = lstrlenW(lpString);
  RegSetValueExW(v4, L"Name", 0, 1u, (const BYTE *)lpString, 2 * v5);
  v12 = phkResult;
  v6 = lstrlenW(lpString + 512);
  RegSetValueExW(v12, L"Command", 0, 1u, (const BYTE *)lpString + 1024, 2 * v6);
  v12 = (HKEY)*((_DWORD *)lpString + 512);
  RegSetValueExW(phkResult, L"ShowNameOnToolbar", 0, 4u, (const BYTE *)&v12, 4u);
  result = RegCloseKey(phkResult);
  v8 = (const WCHAR *)*((_DWORD *)lpString + 513);
  if ( v8 )
    return sub_485D00(v10, v11, v8, Value + 1);
  return result;
}

//----- (00485DF0) --------------------------------------------------------
LSTATUS __usercall sub_485DF0@<eax>(_DWORD *a1@<esi>)
{
  LSTATUS result; // eax
  const WCHAR *v2; // eax
  DWORD dwDisposition; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ApplicationToolbar");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\ApplicationToolbar",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    v2 = (const WCHAR *)a1[15101];
    if ( v2 )
      sub_485D00(a1, phkResult, v2, 0);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00485E60) --------------------------------------------------------
LSTATUS __usercall sub_485E60@<eax>(int a1@<esi>)
{
  LSTATUS result; // eax
  int v2; // eax
  LRESULT v3; // eax
  HWND v4; // [esp-18h] [ebp-D0h]
  HWND v5; // [esp-18h] [ebp-D0h]
  HWND v6; // [esp-10h] [ebp-C8h]
  DWORD dwDisposition; // [esp+0h] [ebp-B8h] BYREF
  LPARAM lParam[3]; // [esp+4h] [ebp-B4h] BYREF
  LSTATUS v9; // [esp+10h] [ebp-A8h]
  BYTE v10[4]; // [esp+14h] [ebp-A4h] BYREF
  BYTE v11[4]; // [esp+18h] [ebp-A0h] BYREF
  BYTE v12[4]; // [esp+1Ch] [ebp-9Ch] BYREF
  WPARAM wParam; // [esp+20h] [ebp-98h] BYREF
  HKEY phkResult; // [esp+24h] [ebp-94h] BYREF
  BYTE Data[4]; // [esp+28h] [ebp-90h] BYREF
  BYTE pv[92]; // [esp+2Ch] [ebp-8Ch] BYREF
  WINDOWPLACEMENT wndpl; // [esp+88h] [ebp-30h] BYREF

  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Settings",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  v9 = result;
  if ( !result )
  {
    v6 = *(HWND *)(a1 + 52);
    wndpl.length = 44;
    GetWindowPlacement(v6, &wndpl);
    RegSetValueExW(phkResult, L"Position", 0, 3u, (const BYTE *)&wndpl, 0x2Cu);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 5628);
    RegSetValueExW(phkResult, L"LastSelectedTab", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59484);
    RegSetValueExW(phkResult, L"ShowExtensions", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59284);
    RegSetValueExW(phkResult, L"ShowStatusBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59288);
    RegSetValueExW(phkResult, L"ShowFolders", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59292);
    RegSetValueExW(phkResult, L"ShowAddressBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59300);
    RegSetValueExW(phkResult, L"ShowToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59304);
    RegSetValueExW(phkResult, L"ShowBookmarksToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59308);
    RegSetValueExW(phkResult, L"ShowDrivesToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59312);
    RegSetValueExW(phkResult, L"ShowApplicationToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59324);
    RegSetValueExW(phkResult, L"ShowFullTitlePath", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59328);
    RegSetValueExW(phkResult, L"AlwaysOpenNewTab", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 5616);
    RegSetValueExW(phkResult, L"TreeViewWidth", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59500);
    RegSetValueExW(phkResult, L"ShowFriendlyDates", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59296);
    RegSetValueExW(phkResult, L"ShowDisplayWindow", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59332);
    RegSetValueExW(phkResult, L"ShowFolderSizes", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59336);
    RegSetValueExW(phkResult, L"DisableFolderSizesNetworkRemovable", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59460);
    RegSetValueExW(phkResult, L"StartupMode", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59344);
    RegSetValueExW(phkResult, L"NextToCurrent", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59348);
    RegSetValueExW(phkResult, L"ConfirmCloseTabs", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59468);
    RegSetValueExW(phkResult, L"ShowInfoTips", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59472);
    RegSetValueExW(phkResult, L"InfoTipType", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59352);
    RegSetValueExW(phkResult, L"TreeViewDelayEnabled", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59360);
    RegSetValueExW(phkResult, L"LockToolbars", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59364);
    RegSetValueExW(phkResult, L"ExtendTabControl", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59368);
    RegSetValueExW(phkResult, L"UseFullRowSelect", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59380);
    RegSetValueExW(phkResult, L"ShowFilePreviews", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59464);
    RegSetValueExW(phkResult, L"ReplaceExplorerMode", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59372);
    RegSetValueExW(phkResult, L"ShowUserNameTitleBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59392);
    RegSetValueExW(phkResult, L"AllowMultipleInstances", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59384);
    RegSetValueExW(phkResult, L"OneClickActivate", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59388);
    RegSetValueExW(phkResult, L"OneClickActivateHoverTime", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59396);
    RegSetValueExW(phkResult, L"ForceSameTabWidth", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59400);
    RegSetValueExW(phkResult, L"DoubleClickTabClose", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59404);
    RegSetValueExW(phkResult, L"HandleZipFiles", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59408);
    RegSetValueExW(phkResult, L"InsertSorted", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59376);
    RegSetValueExW(phkResult, L"ShowPrivilegeLevelInTitleBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59316);
    RegSetValueExW(phkResult, L"AlwaysShowTabBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59416);
    RegSetValueExW(phkResult, L"CheckBoxSelection", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59420);
    RegSetValueExW(phkResult, L"ForceSize", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59456);
    RegSetValueExW(phkResult, L"SizeDisplayFormat", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59424);
    RegSetValueExW(phkResult, L"CloseMainWindowOnTabClose", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59428);
    RegSetValueExW(phkResult, L"ShowTabBarAtBottom", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59412);
    RegSetValueExW(phkResult, L"OverwriteExistingFilesConfirmation", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59448);
    RegSetValueExW(phkResult, L"LargeToolbarIcons", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59452);
    RegSetValueExW(phkResult, L"PlayNavigationSound", 0, 4u, Data, 4u);
    *(_DWORD *)Data = phkResult;
    v2 = lstrlenW((LPCWSTR)(a1 + 4532));
    RegSetValueExW(*(HKEY *)Data, L"NewTabDirectory", 0, 1u, (const BYTE *)(a1 + 4532), 2 * v2);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 5572);
    RegSetValueExW(phkResult, L"Language", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59480);
    RegSetValueExW(phkResult, L"ShowHiddenGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59476);
    RegSetValueExW(phkResult, L"ViewModeGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59504);
    RegSetValueExW(phkResult, L"ShowGridlinesGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59488);
    RegSetValueExW(phkResult, L"ShowInGroupsGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59492);
    RegSetValueExW(phkResult, L"AutoArrangeGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59496);
    RegSetValueExW(phkResult, L"SortAscendingGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59508);
    RegSetValueExW(phkResult, L"HideSystemFilesGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59512);
    RegSetValueExW(phkResult, L"HideLinkExtensionGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59432);
    RegSetValueExW(phkResult, L"ShowTaskbarThumbnails", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59440);
    RegSetValueExW(phkResult, L"SynchronizeTreeview", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 59444);
    RegSetValueExW(phkResult, L"TVAutoExpandSelected", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 5584);
    RegSetValueExW(phkResult, L"DisplayWindowHeight", 0, 4u, Data, 4u);
    *(_DWORD *)v12 = SendMessageW(*(HWND *)(a1 + 64), 0x806Bu, 0, 0);
    v3 = SendMessageW(*(HWND *)(a1 + 64), 0x8067u, 0, 0);
    v4 = *(HWND *)(a1 + 64);
    *(_DWORD *)v10 = v3;
    *(_DWORD *)v11 = SendMessageW(v4, 0x8071u, 0, 0);
    SendMessageW(*(HWND *)(a1 + 64), 0x806Fu, (WPARAM)&wParam, 0);
    RegSetValueExW(phkResult, L"DisplayCentreColor", 0, 3u, v12, 4u);
    RegSetValueExW(phkResult, L"DisplaySurroundColor", 0, 3u, v10, 4u);
    RegSetValueExW(phkResult, L"DisplayTextColor", 0, 3u, v11, 4u);
    GetObjectW((HANDLE)wParam, 92, pv);
    RegSetValueExW(phkResult, L"DisplayFont", 0, 3u, pv, 0x5Cu);
    v5 = *(HWND *)(a1 + 88);
    lParam[0] = -2147483647;
    lParam[1] = (LPARAM)L"Software\\Explorer++\\Settings";
    lParam[2] = (LPARAM)L"ToolbarState";
    SendMessageW(v5, 0x44Cu, 1u, (LPARAM)lParam);
    RegCloseKey(phkResult);
    return v9;
  }
  return result;
}
// 4C8094: using guessed type wchar_t aSoftwareExplor_4[29];
// 4C80D0: using guessed type wchar_t aToolbarstate_1[13];

//----- (00486920) --------------------------------------------------------
int sub_486920()
{
  DWORD cbData; // [esp+0h] [ebp-Ch] BYREF
  HKEY phkResult; // [esp+4h] [ebp-8h] BYREF
  BYTE Data[4]; // [esp+8h] [ebp-4h] BYREF

  *(_DWORD *)Data = 1;
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &phkResult) )
  {
    cbData = 4;
    RegQueryValueExW(phkResult, L"AllowMultipleInstances", 0, 0, Data, &cbData);
    RegCloseKey(phkResult);
  }
  return *(_DWORD *)Data;
}

//----- (00486980) --------------------------------------------------------
int __usercall sub_486980@<eax>(BYTE *a1@<esi>)
{
  int result; // eax
  HKEY phkResult; // [esp+4h] [ebp-8h] BYREF
  DWORD cbData; // [esp+8h] [ebp-4h] BYREF

  if ( RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &phkResult) )
    return 0;
  cbData = 44;
  RegQueryValueExW(phkResult, L"Position", 0, 0, a1, &cbData);
  if ( cbData != 44 )
    return 0;
  result = 1;
  if ( *(_DWORD *)a1 != 44 )
    return 0;
  return result;
}

//----- (004869E0) --------------------------------------------------------
LSTATUS __thiscall sub_4869E0(_DWORD **this)
{
  return sub_485DF0(this[2]);
}

//----- (004869F0) --------------------------------------------------------
LSTATUS __thiscall sub_4869F0(int *this)
{
  return sub_485E60(this[2]);
}

//----- (00486A00) --------------------------------------------------------
LSTATUS __thiscall sub_486A00(BYTE *this)
{
  LSTATUS result; // eax
  BYTE *v3; // esi
  int v4; // [esp+8h] [ebp-118h]
  BOOL v5; // [esp+Ch] [ebp-114h]
  HKEY phkResult; // [esp+10h] [ebp-110h] BYREF
  HKEY hKey; // [esp+14h] [ebp-10Ch] BYREF
  DWORD cbData; // [esp+18h] [ebp-108h] BYREF
  WCHAR SubKey[128]; // [esp+1Ch] [ebp-104h] BYREF

  v4 = 0;
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Toolbars", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    sub_401000(0x80u, SubKey, L"%d", 0);
    if ( !RegOpenKeyExW(phkResult, SubKey, 0, 0x20019u, &hKey) )
    {
      v3 = this + 59584;
      do
      {
        v5 = (*(_DWORD *)v3 & 0x200) != 0;
        cbData = 4;
        RegQueryValueExW(hKey, L"id", 0, 0, v3 + 44, &cbData);
        cbData = 4;
        RegQueryValueExW(hKey, L"Style", 0, 0, v3, &cbData);
        cbData = 4;
        RegQueryValueExW(hKey, L"Length", 0, 0, v3 + 36, &cbData);
        if ( v5 )
          *(_DWORD *)v3 |= 0x200u;
        RegCloseKey(hKey);
        ++v4;
        v3 += 80;
        sub_401000(0x80u, SubKey, L"%d", v4);
      }
      while ( !RegOpenKeyExW(phkResult, SubKey, 0, 0x20019u, &hKey) );
    }
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4C9D7C: using guessed type wchar_t aD_3[3];
// 4C9DA8: using guessed type wchar_t aD_4[3];

//----- (00486BC0) --------------------------------------------------------
LSTATUS __thiscall sub_486BC0(HWND *this)
{
  LSTATUS result; // eax
  signed int v3; // edi
  HWND v4; // [esp-10h] [ebp-190h]
  BYTE Data[4]; // [esp+10h] [ebp-170h] BYREF
  HKEY hKey; // [esp+14h] [ebp-16Ch] BYREF
  HKEY phkResult; // [esp+18h] [ebp-168h] BYREF
  HWND *v8; // [esp+1Ch] [ebp-164h]
  LRESULT v9; // [esp+20h] [ebp-160h]
  DWORD dwDisposition; // [esp+24h] [ebp-15Ch] BYREF
  LPARAM lParam[20]; // [esp+28h] [ebp-158h] BYREF
  WCHAR SubKey[130]; // [esp+78h] [ebp-108h] BYREF

  v8 = this;
  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Toolbars");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Toolbars",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    v3 = 0;
    v9 = SendMessageW(this[15], 0x40Cu, 0, 0);
    if ( v9 > 0 )
    {
      do
      {
        sub_401000(0x80u, SubKey, L"%d", v3);
        if ( !RegCreateKeyExW(phkResult, SubKey, 0, 0, 0, 0x20006u, 0, &hKey, &dwDisposition) )
        {
          v4 = v8[15];
          lParam[0] = 80;
          lParam[1] = 337;
          SendMessageW(v4, 0x41Cu, v3, (LPARAM)lParam);
          *(_DWORD *)Data = lParam[13];
          RegSetValueExW(hKey, L"id", 0, 4u, Data, 4u);
          *(_DWORD *)Data = lParam[2];
          RegSetValueExW(hKey, L"Style", 0, 4u, Data, 4u);
          *(_DWORD *)Data = lParam[11];
          RegSetValueExW(hKey, L"Length", 0, 4u, Data, 4u);
          RegCloseKey(hKey);
        }
        ++v3;
      }
      while ( v3 < v9 );
    }
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4C9D14: using guessed type wchar_t aD_5[3];

//----- (00486D60) --------------------------------------------------------
LSTATUS __fastcall sub_486D60(int Value, HKEY hKey, int a3)
{
  const WCHAR *v4; // edi
  HKEY v5; // ebx
  int v6; // eax
  const WCHAR *v7; // ebx
  int v8; // eax
  DWORD dwDisposition; // [esp+Ch] [ebp-50h] BYREF
  HKEY hKeya; // [esp+10h] [ebp-4Ch] BYREF
  HKEY phkResult; // [esp+14h] [ebp-48h] BYREF
  WCHAR SubKey[32]; // [esp+18h] [ebp-44h] BYREF

  _itow_s(Value, SubKey, 0x20u, 10);
  RegCreateKeyExW(hKey, SubKey, 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  if ( *(_DWORD *)(a3 + 20) < 8u )
    v4 = (const WCHAR *)a3;
  else
    v4 = *(const WCHAR **)a3;
  v5 = phkResult;
  v6 = lstrlenW(v4);
  RegSetValueExW(v5, L"Description", 0, 1u, (const BYTE *)v4, 2 * v6);
  if ( *(_DWORD *)(a3 + 48) < 8u )
    v7 = (const WCHAR *)(a3 + 28);
  else
    v7 = *(const WCHAR **)(a3 + 28);
  hKeya = phkResult;
  v8 = lstrlenW(v7);
  RegSetValueExW(hKeya, L"FilenamePattern", 0, 1u, (const BYTE *)v7, 2 * v8);
  hKeya = *(HKEY *)(a3 + 56);
  RegSetValueExW(phkResult, L"Attributes", 0, 4u, (const BYTE *)&hKeya, 4u);
  RegSetValueExW(phkResult, L"Color", 0, 3u, (const BYTE *)(a3 + 60), 4u);
  return RegCloseKey(phkResult);
}

//----- (00486E50) --------------------------------------------------------
void __userpurge sub_486E50(int a1@<esi>, HKEY hKey, LPCWSTR lpValueName)
{
  BYTE *v3; // edi
  _DWORD *v4; // eax
  BYTE *v5; // ecx

  v3 = (BYTE *)malloc(8 * *(_DWORD *)(a1 + 4));
  v4 = **(_DWORD ***)a1;
  if ( v4 != *(_DWORD **)a1 )
  {
    v5 = v3;
    do
    {
      *(_DWORD *)v5 = v4[2];
      *((_DWORD *)v5 + 1) = v4[3];
      v4 = (_DWORD *)*v4;
      v5 += 8;
    }
    while ( v4 != *(_DWORD **)a1 );
  }
  RegSetValueExW(hKey, lpValueName, 0, 3u, v3, 8 * *(_DWORD *)(a1 + 4));
  free(v3);
}

//----- (00486EC0) --------------------------------------------------------
void __userpurge sub_486EC0(int a1@<esi>, HKEY hKey, LPCWSTR lpValueName)
{
  BYTE *v3; // edi
  _DWORD *v4; // eax
  BYTE *v5; // ecx

  v3 = (BYTE *)malloc(8 * *(_DWORD *)(a1 + 4));
  v4 = **(_DWORD ***)a1;
  if ( v4 != *(_DWORD **)a1 )
  {
    v5 = v3;
    do
    {
      *(_DWORD *)v5 = v4[2];
      *((_DWORD *)v5 + 1) = v4[4];
      v4 = (_DWORD *)*v4;
      v5 += 8;
    }
    while ( v4 != *(_DWORD **)a1 );
  }
  RegSetValueExW(hKey, lpValueName, 0, 3u, v3, 8 * *(_DWORD *)(a1 + 4));
  free(v3);
}

//----- (00486F30) --------------------------------------------------------
_DWORD **__usercall sub_486F30@<eax>(_DWORD **a1@<ebx>, _DWORD **a2@<edi>)
{
  _DWORD **result; // eax
  int **i; // edx

  result = (_DWORD **)*a2;
  for ( i = (int **)**a2; i != *a2; i = (int **)*i )
  {
    result = (_DWORD **)**a1;
    if ( result != *a1 )
    {
      while ( result[2] != i[2] )
      {
        result = (_DWORD **)*result;
        if ( result == *a1 )
          goto LABEL_7;
      }
      result[4] = i[4];
    }
LABEL_7:
    ;
  }
  return result;
}

//----- (00486F70) --------------------------------------------------------
LSTATUS __thiscall sub_486F70(void *this, HKEY hKey, LPCWSTR lpString, int Value)
{
  HKEY v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  LSTATUS result; // eax
  int v11; // ebx
  DWORD dwDisposition; // [esp+Ch] [ebp-1080h] BYREF
  HKEY v13; // [esp+10h] [ebp-107Ch]
  void *v14; // [esp+14h] [ebp-1078h]
  HKEY phkResult; // [esp+18h] [ebp-1074h] BYREF
  HKEY v16; // [esp+1Ch] [ebp-1070h] BYREF
  WCHAR String[1034]; // [esp+20h] [ebp-106Ch] BYREF
  WCHAR v18[1034]; // [esp+834h] [ebp-858h] BYREF
  WCHAR SubKey[32]; // [esp+1048h] [ebp-44h] BYREF
  int Valuea; // [esp+109Ch] [ebp+10h]

  v14 = this;
  v13 = hKey;
  _itow_s(Value, SubKey, 0x20u, 10);
  RegCreateKeyExW(hKey, SubKey, 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition);
  v4 = phkResult;
  v5 = lstrlenW(lpString);
  RegSetValueExW(v4, L"Name", 0, 1u, (const BYTE *)lpString, 2 * v5);
  v16 = phkResult;
  v6 = lstrlenW(lpString + 256);
  RegSetValueExW(v16, L"Description", 0, 1u, (const BYTE *)lpString + 512, 2 * v6);
  v16 = (HKEY)*((_DWORD *)lpString + 385);
  RegSetValueExW(phkResult, L"Type", 0, 4u, (const BYTE *)&v16, 4u);
  v16 = (HKEY)*((_DWORD *)lpString + 384);
  RegSetValueExW(phkResult, L"ShowOnBookmarksToolbar", 0, 4u, (const BYTE *)&v16, 4u);
  Valuea = Value + 1;
  if ( *((_DWORD *)lpString + 385) == 1 )
  {
    v16 = phkResult;
    v7 = lstrlenW(lpString + 772);
    RegSetValueExW(v16, L"Location", 0, 1u, (const BYTE *)lpString + 1544, 2 * v7);
  }
  if ( !*((_DWORD *)lpString + 385) )
  {
    v8 = *((_DWORD *)lpString + 516);
    if ( !*(_DWORD *)(v8 + 1540) )
    {
      v9 = *(_DWORD *)(v8 + 2076);
      if ( v9 )
      {
        sub_465D30(v9, String);
        sub_486F70(v14, phkResult, String, 0);
      }
    }
  }
  result = RegCloseKey(phkResult);
  v11 = *(_DWORD *)(*((_DWORD *)lpString + 516) + 2072);
  if ( v11 )
  {
    sub_465D30(v11, v18);
    return sub_486F70(v14, v13, v18, Valuea);
  }
  return result;
}

//----- (00487150) --------------------------------------------------------
LSTATUS __usercall sub_487150@<eax>(void *a1@<esi>)
{
  LSTATUS result; // eax
  int v2; // ebx
  DWORD dwDisposition; // [esp+0h] [ebp-1034h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-1030h] BYREF
  WCHAR String[1034]; // [esp+8h] [ebp-102Ch] BYREF
  int v6[516]; // [esp+81Ch] [ebp-818h] BYREF
  int v7; // [esp+102Ch] [ebp-8h]

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Bookmarks");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Bookmarks",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    sub_466000((int)a1 + 1332, v6);
    if ( !*(_DWORD *)(v7 + 1540) )
    {
      v2 = *(_DWORD *)(v7 + 2076);
      if ( v2 )
      {
        sub_465D30(v2, String);
        sub_486F70(a1, phkResult, String, 0);
      }
    }
    return RegCloseKey(phkResult);
  }
  return result;
}
// 487150: using guessed type int var_818[516];

//----- (00487210) --------------------------------------------------------
LSTATUS __thiscall sub_487210(HWND **this)
{
  return sub_486BC0(this[2]);
}

//----- (00487220) --------------------------------------------------------
LSTATUS __thiscall sub_487220(void **this)
{
  return sub_487150(this[2]);
}

//----- (00487230) --------------------------------------------------------
LSTATUS __thiscall sub_487230(BYTE **this)
{
  return sub_486A00(this[2]);
}

//----- (00487240) --------------------------------------------------------
LSTATUS __thiscall sub_487240(HKEY hKey, int a2)
{
  int v2; // esi
  LSTATUS result; // eax
  DWORD v5; // eax
  LSTATUS v6; // ebx
  DWORD v7; // eax
  DWORD Type; // [esp+14h] [ebp-A1Ch] BYREF
  DWORD v10; // [esp+18h] [ebp-A18h] BYREF
  LSTATUS v11; // [esp+1Ch] [ebp-A14h]
  BYTE v12[4]; // [esp+20h] [ebp-A10h] BYREF
  HKEY phkResult; // [esp+24h] [ebp-A0Ch] BYREF
  DWORD cbData; // [esp+28h] [ebp-A08h] BYREF
  BYTE v15[2]; // [esp+2Ch] [ebp-A04h] BYREF
  BYTE Data[2]; // [esp+42Ch] [ebp-604h] BYREF
  WCHAR SubKey[256]; // [esp+82Ch] [ebp-204h] BYREF

  v2 = 0;
  *(_DWORD *)v12 = 1;
  sub_401000(0x100u, SubKey, L"%d", 0);
  for ( result = RegOpenKeyExW(hKey, SubKey, 0, 0x20019u, &phkResult);
        !result;
        result = RegOpenKeyExW(hKey, SubKey, 0, 0x20019u, &phkResult) )
  {
    cbData = 512;
    v11 = RegQueryValueExW(phkResult, L"Name", 0, &Type, Data, &cbData);
    v5 = cbData;
    if ( cbData && Type == 1 )
    {
      if ( *(_WORD *)&Data[2 * cbData - 2] )
      {
        if ( cbData >= 0x200 )
          v5 = 512;
        *(_WORD *)&Data[2 * v5] = 0;
      }
    }
    else
    {
      *(_WORD *)Data = 0;
    }
    cbData = 512;
    v6 = RegQueryValueExW(phkResult, L"Command", 0, &v10, v15, &cbData);
    v7 = cbData;
    if ( cbData && v10 == 1 )
    {
      if ( *(_WORD *)&v15[2 * cbData - 2] )
      {
        if ( cbData >= 0x200 )
          v7 = 512;
        *(_WORD *)&v15[2 * v7] = 0;
      }
    }
    else
    {
      *(_WORD *)v15 = 0;
    }
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowNameOnToolbar", 0, 0, v12, &cbData);
    if ( !v11 && !v6 )
      sub_4A8DD0(a2, (int)Data, (int)v15, *(int *)v12);
    RegCloseKey(phkResult);
    sub_401000(0x100u, SubKey, L"%d", ++v2);
  }
  return result;
}
// 4C9AE0: using guessed type wchar_t aD_6[3];
// 4C9B1C: using guessed type wchar_t aD_7[3];

//----- (00487490) --------------------------------------------------------
LSTATUS __usercall sub_487490@<eax>(int a1@<edi>)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\DefaultColumns",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    sub_486E50(a1 + 60496, phkResult, L"ControlPanelColumns");
    sub_486EC0(a1 + 60496, phkResult, L"ControlPanelColumnWidths");
    sub_486E50(a1 + 60484, phkResult, L"MyComputerColumns");
    sub_486EC0(a1 + 60484, phkResult, L"MyComputerColumnWidths");
    sub_486E50(a1 + 60472, phkResult, L"RealFolderColumns");
    sub_486EC0(a1 + 60472, phkResult, L"RealFolderColumnWidths");
    sub_486E50(a1 + 60508, phkResult, L"RecycleBinColumns");
    sub_486EC0(a1 + 60508, phkResult, L"RecycleBinColumnWidths");
    sub_486E50(a1 + 60520, phkResult, L"PrinterColumns");
    sub_486EC0(a1 + 60520, phkResult, L"PrinterColumnWidths");
    sub_486E50(a1 + 60532, phkResult, L"NetworkColumns");
    sub_486EC0(a1 + 60532, phkResult, L"NetworkColumnWidths");
    sub_486E50(a1 + 60544, phkResult, L"NetworkPlacesColumns");
    sub_486EC0(a1 + 60544, phkResult, L"NetworkPlacesColumnWidths");
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (004875D0) --------------------------------------------------------
LSTATUS __usercall sub_4875D0@<eax>(int a1@<edi>)
{
  LSTATUS result; // eax
  signed int v2; // esi
  ITEMIDLIST *v3; // esi
  DWORD v4; // eax
  HKEY v5; // esi
  int v6; // eax
  const WCHAR *v7; // esi
  HKEY v8; // esi
  DWORD v9; // [esp-4h] [ebp-5DCh]
  DWORD v10; // [esp-4h] [ebp-5DCh]
  void *v11[3]; // [esp+Ch] [ebp-5CCh] BYREF
  char v12[12]; // [esp+18h] [ebp-5C0h] BYREF
  char v13[12]; // [esp+24h] [ebp-5B4h] BYREF
  char v14[12]; // [esp+30h] [ebp-5A8h] BYREF
  char v15[12]; // [esp+3Ch] [ebp-59Ch] BYREF
  char v16[12]; // [esp+48h] [ebp-590h] BYREF
  char v17[12]; // [esp+54h] [ebp-584h] BYREF
  BYTE v18[4]; // [esp+60h] [ebp-578h] BYREF
  BYTE v19[4]; // [esp+64h] [ebp-574h] BYREF
  BYTE v20[4]; // [esp+68h] [ebp-570h] BYREF
  BYTE v21[4]; // [esp+6Ch] [ebp-56Ch] BYREF
  int v22; // [esp+70h] [ebp-568h] BYREF
  int v23; // [esp+74h] [ebp-564h] BYREF
  BYTE v24[4]; // [esp+78h] [ebp-560h] BYREF
  LRESULT v25; // [esp+7Ch] [ebp-55Ch]
  BYTE v26[4]; // [esp+80h] [ebp-558h] BYREF
  BYTE v27[4]; // [esp+84h] [ebp-554h] BYREF
  BYTE v28[4]; // [esp+88h] [ebp-550h] BYREF
  BYTE v29[4]; // [esp+8Ch] [ebp-54Ch] BYREF
  BYTE v30[4]; // [esp+90h] [ebp-548h] BYREF
  int lParam[6]; // [esp+94h] [ebp-544h] BYREF
  int v32; // [esp+ACh] [ebp-52Ch]
  DWORD dwDisposition; // [esp+B0h] [ebp-528h] BYREF
  int v34; // [esp+B4h] [ebp-524h]
  HKEY phkResult; // [esp+B8h] [ebp-520h] BYREF
  BYTE Data[4]; // [esp+BCh] [ebp-51Ch] BYREF
  HKEY v37; // [esp+C0h] [ebp-518h] BYREF
  HKEY hKey; // [esp+C4h] [ebp-514h] BYREF
  WCHAR String[512]; // [esp+C8h] [ebp-510h] BYREF
  WCHAR SubKey[128]; // [esp+4C8h] [ebp-110h] BYREF
  int v41; // [esp+5D4h] [ebp-4h]

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Tabs");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Tabs",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    v2 = 0;
    v25 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
    lParam[0] = 8;
    v34 = 0;
    if ( v25 > 0 )
    {
      do
      {
        SendMessageW(*(HWND *)(a1 + 68), 0x133Cu, v2, (LPARAM)lParam);
        sub_401000(0x80u, SubKey, L"%d", v2);
        if ( !RegCreateKeyExW(phkResult, SubKey, 0, 0, 0, 0x20006u, 0, &hKey, &dwDisposition) )
        {
          v3 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 916) + 56))(*(_DWORD *)(a1 + 4 * v32 + 916));
          v4 = ILGetSize(v3);
          RegSetValueExW(hKey, L"Directory", 0, 3u, (const BYTE *)v3, v4);
          CoTaskMemFree(v3);
          (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(a1 + 4 * v32 + 516) + 24))(
            *(_DWORD *)(a1 + 4 * v32 + 516),
            &v22);
          *(_DWORD *)Data = v22;
          RegSetValueExW(hKey, L"ViewMode", 0, 4u, Data, 4u);
          (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(a1 + 4 * v32 + 516) + 28))(
            *(_DWORD *)(a1 + 4 * v32 + 516),
            &v23);
          *(_DWORD *)Data = v23;
          RegSetValueExW(hKey, L"SortMode", 0, 4u, Data, 4u);
          *(_DWORD *)v18 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 516) + 40))(*(_DWORD *)(a1 + 4 * v32 + 516));
          RegSetValueExW(hKey, L"SortAscending", 0, 4u, v18, 4u);
          *(_DWORD *)v19 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 516) + 36))(*(_DWORD *)(a1 + 4 * v32 + 516));
          RegSetValueExW(hKey, L"ShowInGroups", 0, 4u, v19, 4u);
          *(_DWORD *)v28 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 916) + 216))(*(_DWORD *)(a1 + 4 * v32 + 916));
          RegSetValueExW(hKey, L"ApplyFilter", 0, 4u, v28, 4u);
          *(_DWORD *)v30 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 916) + 224))(*(_DWORD *)(a1 + 4 * v32 + 916));
          RegSetValueExW(hKey, L"FilterCaseSensitive", 0, 4u, v30, 4u);
          *(_DWORD *)v26 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 916) + 248))(*(_DWORD *)(a1 + 4 * v32 + 916));
          RegSetValueExW(hKey, L"ShowHidden", 0, 4u, v26, 4u);
          *(_DWORD *)v21 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 516) + 12))(*(_DWORD *)(a1 + 4 * v32 + 516));
          RegSetValueExW(hKey, L"AutoArrange", 0, 4u, v21, 4u);
          *(_DWORD *)v24 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v32 + 916) + 304))(*(_DWORD *)(a1 + 4 * v32 + 916));
          RegSetValueExW(hKey, L"ShowGridlines", 0, 4u, v24, 4u);
          (*(void (__thiscall **)(_DWORD, WCHAR *, int))(**(_DWORD **)(a1 + 4 * v32 + 916) + 208))(
            *(_DWORD *)(a1 + 4 * v32 + 916),
            String,
            512);
          v5 = hKey;
          v6 = lstrlenW(String);
          RegSetValueExW(v5, L"Filter", 0, 1u, (const BYTE *)String, 2 * v6);
          if ( !RegCreateKeyExW(hKey, L"Columns", 0, 0, 0, 0x20006u, 0, &v37, &dwDisposition) )
          {
            sub_415920(v11);
            v41 = 0;
            (*(void (__thiscall **)(_DWORD, void **))(**(_DWORD **)(a1 + 4 * v32 + 916) + 324))(
              *(_DWORD *)(a1 + 4 * v32 + 916),
              v11);
            sub_486E50((int)v13, v37, L"ControlPanelColumns");
            sub_486E50((int)v12, v37, L"MyComputerColumns");
            sub_486E50((int)v11, v37, L"RealFolderColumns");
            sub_486E50((int)v14, v37, L"RecycleBinColumns");
            sub_486E50((int)v15, v37, L"PrinterColumns");
            sub_486E50((int)v16, v37, L"NetworkColumns");
            sub_486E50((int)v17, v37, L"NetworkPlacesColumns");
            sub_486EC0((int)v13, v37, L"ControlPanelColumnWidths");
            sub_486EC0((int)v12, v37, L"MyComputerColumnWidths");
            sub_486EC0((int)v11, v37, L"RealFolderColumnWidths");
            sub_486EC0((int)v14, v37, L"RecycleBinColumnWidths");
            sub_486EC0((int)v15, v37, L"PrinterColumnWidths");
            sub_486EC0((int)v16, v37, L"NetworkColumnWidths");
            sub_486EC0((int)v17, v37, L"NetworkPlacesColumnWidths");
            v41 = -1;
            sub_415B50(v11);
          }
          *(_DWORD *)v20 = *(_DWORD *)(532 * v32 + a1 + 5672);
          RegSetValueExW(hKey, L"Locked", 0, 4u, v20, 4u);
          *(_DWORD *)v29 = *(_DWORD *)(532 * v32 + a1 + 5676);
          RegSetValueExW(hKey, L"AddressLocked", 0, 4u, v29, 4u);
          *(_DWORD *)v27 = *(_DWORD *)(532 * v32 + a1 + 5680);
          RegSetValueExW(hKey, L"UseCustomName", 0, 4u, v27, 4u);
          if ( *(_DWORD *)(532 * v32 + a1 + 5680) )
          {
            v7 = (const WCHAR *)(532 * v32 + a1 + 5684);
            *(_DWORD *)Data = hKey;
            v9 = 2 * lstrlenW(v7);
            RegSetValueExW(*(HKEY *)Data, L"CustomName", 0, 1u, (const BYTE *)v7, v9);
          }
          else
          {
            v8 = hKey;
            v10 = 2 * lstrlenW(&word_4C9048);
            RegSetValueExW(v8, L"CustomName", 0, 1u, (const BYTE *)&word_4C9048, v10);
          }
          RegCloseKey(hKey);
          v2 = v34;
        }
        v34 = ++v2;
      }
      while ( v2 < v25 );
    }
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4C8C78: using guessed type wchar_t aD_8[3];
// 4C9030: using guessed type wchar_t aCustomname_2[11];
// 4875D0: using guessed type LPARAM lParam[6];

//----- (00487C70) --------------------------------------------------------
LSTATUS __stdcall sub_487C70(HKEY hKey, int a2)
{
  HKEY v2; // ebx
  LSTATUS result; // eax
  DWORD v4; // eax
  LSTATUS v5; // esi
  DWORD v6; // eax
  DWORD v7; // eax
  LSTATUS v8; // [esp+4h] [ebp-A48h]
  DWORD v9; // [esp+Ch] [ebp-A40h] BYREF
  LSTATUS v10; // [esp+10h] [ebp-A3Ch]
  DWORD v11; // [esp+14h] [ebp-A38h] BYREF
  DWORD Type; // [esp+18h] [ebp-A34h] BYREF
  int v13; // [esp+1Ch] [ebp-A30h]
  HKEY v14; // [esp+20h] [ebp-A2Ch]
  DWORD dwIndex; // [esp+24h] [ebp-A28h]
  DWORD cchName; // [esp+28h] [ebp-A24h] BYREF
  HKEY phkResult; // [esp+2Ch] [ebp-A20h] BYREF
  DWORD cbData; // [esp+30h] [ebp-A1Ch] BYREF
  BYTE v19[2]; // [esp+34h] [ebp-A18h] BYREF
  BYTE v21[2]; // [esp+234h] [ebp-818h] BYREF
  char v22[4]; // [esp+634h] [ebp-418h] BYREF
  BYTE Data[4]; // [esp+638h] [ebp-414h] BYREF
  BYTE v24[2]; // [esp+63Ch] [ebp-410h] BYREF
  int v25; // [esp+844h] [ebp-208h]
  WCHAR Name[256]; // [esp+848h] [ebp-204h] BYREF

  v2 = hKey;
  v14 = hKey;
  v13 = a2;
  dwIndex = 0;
  cchName = 256;
  for ( result = RegEnumKeyExW(hKey, 0, Name, &cchName, 0, 0, 0, 0);
        !result;
        result = RegEnumKeyExW(v2, dwIndex, Name, &cchName, 0, 0, 0, 0) )
  {
    ++dwIndex;
    RegOpenKeyExW(v2, Name, 0, 0x20019u, &phkResult);
    cbData = 4;
    v8 = RegQueryValueExW(phkResult, L"Type", 0, 0, Data, &cbData);
    cbData = 256;
    v10 = RegQueryValueExW(phkResult, L"Name", 0, &Type, v19, &cbData);
    v4 = cbData;
    if ( cbData && Type == 1 )
    {
      if ( *(_WORD *)&v19[2 * cbData - 2] )
      {
        if ( cbData >= 0x100 )
          v4 = 256;
        *(_WORD *)&v19[2 * v4] = 0;
      }
    }
    else
    {
      *(_WORD *)v19 = 0;
    }
    cbData = 4;
    v5 = RegQueryValueExW(phkResult, L"ShowOnBookmarksToolbar", 0, 0, (LPBYTE)v22, &cbData);
    cbData = 512;
    RegQueryValueExW(phkResult, L"Description", 0, &v9, v21, &cbData);
    v6 = cbData;
    if ( cbData && v9 == 1 )
    {
      if ( *(_WORD *)&v21[2 * cbData - 2] )
      {
        if ( cbData >= 0x200 )
          v6 = 512;
        *(_WORD *)&v21[2 * v6] = 0;
      }
    }
    else
    {
      *(_WORD *)v21 = 0;
    }
    if ( !v8 && !v10 && !v5 )
    {
      if ( *(_DWORD *)Data )
      {
        cbData = 260;
        RegQueryValueExW(phkResult, L"Location", 0, &v11, v24, &cbData);
        v7 = cbData;
        if ( cbData && v11 == 1 )
        {
          if ( *(_WORD *)&Data[2 * cbData + 2] )
          {
            if ( cbData >= 0x104 )
              v7 = 260;
            *(_WORD *)&v24[2 * v7] = 0;
          }
        }
        else
        {
          *(_WORD *)v24 = 0;
        }
        sub_4660F0((char *)v19, v13);
      }
      else
      {
        sub_4660F0((char *)v19, v13);
        sub_487C70(phkResult, v25);
      }
      v2 = v14;
    }
    RegCloseKey(phkResult);
    cchName = 256;
  }
  return result;
}
// 487C70: using guessed type BYTE var_418[4];

//----- (00487F80) --------------------------------------------------------
LSTATUS __usercall sub_487F80@<eax>(int a1@<esi>)
{
  LSTATUS result; // eax
  HKEY phkResult; // [esp+0h] [ebp-81Ch] BYREF
  int v3[517]; // [esp+4h] [ebp-818h] BYREF

  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Bookmarks", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    sub_466000(a1 + 1332, v3);
    sub_487C70(phkResult, v3[516]);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00488000) --------------------------------------------------------
LSTATUS __thiscall sub_488000(int this)
{
  LSTATUS v1; // ebx
  LSTATUS v3; // edi
  DWORD v4; // eax
  HFONT v5; // eax
  int v6; // ecx
  HKEY v7; // eax
  BYTE Data[4]; // [esp+Ch] [ebp-8Ch] BYREF
  BYTE v10[4]; // [esp+10h] [ebp-88h] BYREF
  LSTATUS v11; // [esp+14h] [ebp-84h]
  LSTATUS v12; // [esp+18h] [ebp-80h]
  BYTE v13[4]; // [esp+1Ch] [ebp-7Ch] BYREF
  LSTATUS v14; // [esp+20h] [ebp-78h]
  DWORD v15; // [esp+24h] [ebp-74h] BYREF
  DWORD v16; // [esp+28h] [ebp-70h] BYREF
  DWORD Type; // [esp+2Ch] [ebp-6Ch] BYREF
  HKEY phkResult; // [esp+30h] [ebp-68h] BYREF
  DWORD cbData; // [esp+34h] [ebp-64h] BYREF
  LOGFONTW v20; // [esp+38h] [ebp-60h] BYREF

  v1 = 1;
  v14 = 1;
  v15 = 1;
  cbData = 1;
  v3 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &phkResult);
  v12 = v3;
  if ( !v3 )
  {
    cbData = 4;
    RegQueryValueExW(phkResult, L"LastSelectedTab", 0, 0, (LPBYTE)(this + 5628), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowExtensions", 0, 0, (LPBYTE)(this + 59484), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowStatusBar", 0, 0, (LPBYTE)(this + 59284), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowFolders", 0, 0, (LPBYTE)(this + 59288), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowAddressBar", 0, 0, (LPBYTE)(this + 59292), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowToolbar", 0, 0, (LPBYTE)(this + 59300), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowBookmarksToolbar", 0, 0, (LPBYTE)(this + 59304), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowDrivesToolbar", 0, 0, (LPBYTE)(this + 59308), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowApplicationToolbar", 0, 0, (LPBYTE)(this + 59312), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowFullTitlePath", 0, 0, (LPBYTE)(this + 59324), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"AlwaysOpenNewTab", 0, 0, (LPBYTE)(this + 59328), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"TreeViewWidth", 0, 0, (LPBYTE)(this + 5616), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowFriendlyDates", 0, 0, (LPBYTE)(this + 59500), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowDisplayWindow", 0, 0, (LPBYTE)(this + 59296), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowFolderSizes", 0, 0, (LPBYTE)(this + 59332), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"DisableFolderSizesNetworkRemovable", 0, 0, (LPBYTE)(this + 59336), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"StartupMode", 0, 0, (LPBYTE)(this + 59460), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"NextToCurrent", 0, 0, (LPBYTE)(this + 59344), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ConfirmCloseTabs", 0, 0, (LPBYTE)(this + 59348), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowInfoTips", 0, 0, (LPBYTE)(this + 59468), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"InfoTipType", 0, 0, (LPBYTE)(this + 59472), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"TreeViewDelayEnabled", 0, 0, (LPBYTE)(this + 59352), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"LockToolbars", 0, 0, (LPBYTE)(this + 59360), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ExtendTabControl", 0, 0, (LPBYTE)(this + 59364), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"UseFullRowSelect", 0, 0, (LPBYTE)(this + 59368), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowFilePreviews", 0, 0, (LPBYTE)(this + 59380), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ReplaceExplorerMode", 0, 0, (LPBYTE)(this + 59464), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowUserNameTitleBar", 0, 0, (LPBYTE)(this + 59372), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"AllowMultipleInstances", 0, 0, (LPBYTE)(this + 59392), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"OneClickActivate", 0, 0, (LPBYTE)(this + 59384), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"OneClickActivateHoverTime", 0, 0, (LPBYTE)(this + 59388), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ForceSameTabWidth", 0, 0, (LPBYTE)(this + 59396), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"DoubleClickTabClose", 0, 0, (LPBYTE)(this + 59400), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"HandleZipFiles", 0, 0, (LPBYTE)(this + 59404), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"InsertSorted", 0, 0, (LPBYTE)(this + 59408), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowPrivilegeLevelInTitleBar", 0, 0, (LPBYTE)(this + 59376), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"AlwaysShowTabBar", 0, 0, (LPBYTE)(this + 59316), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"CheckBoxSelection", 0, 0, (LPBYTE)(this + 59416), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ForceSize", 0, 0, (LPBYTE)(this + 59420), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"SizeDisplayFormat", 0, 0, (LPBYTE)(this + 59456), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"CloseMainWindowOnTabClose", 0, 0, (LPBYTE)(this + 59424), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowTabBarAtBottom", 0, 0, (LPBYTE)(this + 59428), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowTaskbarThumbnails", 0, 0, (LPBYTE)(this + 59432), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"SynchronizeTreeview", 0, 0, (LPBYTE)(this + 59440), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"TVAutoExpandSelected", 0, 0, (LPBYTE)(this + 59444), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"OverwriteExistingFilesConfirmation", 0, 0, (LPBYTE)(this + 59412), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"LargeToolbarIcons", 0, 0, (LPBYTE)(this + 59448), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"PlayNavigationSound", 0, 0, (LPBYTE)(this + 59452), &cbData);
    v15 = 260;
    RegQueryValueExW(phkResult, L"NewTabDirectory", 0, &cbData, (LPBYTE)(this + 4532), &v15);
    v4 = v15;
    if ( v15 && cbData == 1 )
    {
      if ( *(_WORD *)(this + 2 * v15 + 4530) )
      {
        if ( v15 >= 0x104 )
          v4 = 260;
        *(_WORD *)(this + 2 * v4 + 4532) = 0;
      }
    }
    else
    {
      *(_WORD *)(this + 4532) = 0;
    }
    cbData = 4;
    if ( !RegQueryValueExW(phkResult, L"Language", 0, 0, (LPBYTE)(this + 5572), &cbData) )
      *(_DWORD *)(this + 5608) = 1;
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowHiddenGlobal", 0, 0, (LPBYTE)(this + 59480), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ViewModeGlobal", 0, 0, (LPBYTE)(this + 59476), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowGridlinesGlobal", 0, 0, (LPBYTE)(this + 59504), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"ShowInGroupsGlobal", 0, 0, (LPBYTE)(this + 59488), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"AutoArrangeGlobal", 0, 0, (LPBYTE)(this + 59492), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"SortAscendingGlobal", 0, 0, (LPBYTE)(this + 59496), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"HideSystemFilesGlobal", 0, 0, (LPBYTE)(this + 59508), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"HideLinkExtensionGlobal", 0, 0, (LPBYTE)(this + 59512), &cbData);
    cbData = 4;
    RegQueryValueExW(phkResult, L"DisplayWindowHeight", 0, 0, (LPBYTE)(this + 5584), &cbData);
    Type = 3;
    v16 = 4;
    v15 = RegQueryValueExW(phkResult, L"DisplaySurroundColor", 0, &Type, Data, &v16);
    Type = 3;
    v16 = 4;
    v14 = RegQueryValueExW(phkResult, L"DisplayCentreColor", 0, &Type, v13, &v16);
    Type = 3;
    v16 = 4;
    v11 = RegQueryValueExW(phkResult, L"DisplayTextColor", 0, &Type, v10, &v16);
    Type = 3;
    v16 = 92;
    cbData = RegQueryValueExW(phkResult, L"DisplayFont", 0, &Type, (LPBYTE)&v20, &v16);
    v5 = CreateFontIndirectW(&v20);
    v6 = *(_DWORD *)Data;
    *(_DWORD *)(this + 5656) = v13[2] | ((v13[1] | ((v13[0] | 0xFFFFFF00) << 8)) << 8);
    *(_DWORD *)(this + 5668) = v5;
    v7 = phkResult;
    *(_DWORD *)(this + 5660) = BYTE2(v6) | ((BYTE1(v6) | ((v6 | 0xFFFFFF00) << 8)) << 8);
    *(_DWORD *)(this + 5664) = *(_DWORD *)v10;
    *(_DWORD *)(this + 5604) = 1;
    RegCloseKey(v7);
    v3 = v12;
    v1 = v11;
  }
  sub_49AD80(this);
  if ( v15 )
    *(_DWORD *)(this + 5660) = -16753014;
  if ( v14 )
    *(_DWORD *)(this + 5656) = -1;
  if ( v1 )
    *(_DWORD *)(this + 5664) = 0;
  if ( cbData )
    *(_DWORD *)(this + 5668) = CreateFontW(-13, 0, 0, 0, 500, 0, 0, 0, 1u, 0, 0, 2u, 0x31u, L"Segoe UI");
  return v3;
}

//----- (00488910) --------------------------------------------------------
LSTATUS __thiscall sub_488910(int *this)
{
  return sub_487490(this[2]);
}

//----- (00488920) --------------------------------------------------------
LSTATUS __thiscall sub_488920(int *this)
{
  return sub_4875D0(this[2]);
}

//----- (00488930) --------------------------------------------------------
LSTATUS __thiscall sub_488930(_DWORD *this)
{
  int v1; // esi
  LSTATUS result; // eax
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  v1 = this[2];
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ApplicationToolbar", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    sub_487240(phkResult, v1);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00488970) --------------------------------------------------------
LSTATUS __thiscall sub_488970(int *this)
{
  return sub_487F80(this[2]);
}

//----- (00488980) --------------------------------------------------------
LSTATUS __thiscall sub_488980(int *this)
{
  return sub_488000(this[2]);
}

//----- (00488990) --------------------------------------------------------
char **__fastcall sub_488990(LPCWSTR lpValueName, int *a2, HKEY hKey)
{
  char **result; // eax
  DWORD v4; // edi
  int v5; // ebx
  char *v6; // ecx
  int v7; // ecx
  int v8; // [esp-4h] [ebp-238h]
  char *v9[3]; // [esp+10h] [ebp-224h] BYREF
  DWORD Type; // [esp+1Ch] [ebp-218h] BYREF
  int *v11; // [esp+20h] [ebp-214h]
  DWORD cbData; // [esp+24h] [ebp-210h] BYREF
  BYTE Data[4]; // [esp+28h] [ebp-20Ch] BYREF
  int v14[128]; // [esp+2Ch] [ebp-208h]

  v11 = a2;
  Type = 3;
  cbData = 512;
  result = (char **)RegQueryValueExW(hKey, lpValueName, 0, &Type, Data, &cbData);
  v4 = 0;
  if ( (cbData & 0xFFFFFFF8) != 0 )
  {
    v9[2] = (char *)150;
    do
    {
      v5 = *v11;
      v6 = (char *)v14[2 * v4];
      v9[0] = *(char **)&Data[8 * v4];
      v8 = *(_DWORD *)(v5 + 4);
      v9[1] = v6;
      result = sub_41EEB0(v9, (char *)v5, v8);
      v7 = v11[1];
      if ( v7 == 357913940 )
        std::_Xlength_error("list<T> too long");
      v11[1] = v7 + 1;
      *(_DWORD *)(v5 + 4) = result;
      *(_DWORD *)result[1] = result;
      ++v4;
    }
    while ( v4 < cbData >> 3 );
  }
  return result;
}
// 488990: using guessed type _DWORD var_208[128];

//----- (00488A80) --------------------------------------------------------
char **__fastcall sub_488A80(LPCWSTR lpValueName, int *a2, HKEY hKey)
{
  char **result; // eax
  DWORD v4; // ebx
  int v5; // edi
  char *v6; // ecx
  int v7; // ecx
  int v8; // [esp-4h] [ebp-238h]
  char *v9[3]; // [esp+10h] [ebp-224h] BYREF
  DWORD Type; // [esp+1Ch] [ebp-218h] BYREF
  int *v11; // [esp+20h] [ebp-214h]
  DWORD cbData; // [esp+24h] [ebp-210h] BYREF
  BYTE Data[4]; // [esp+28h] [ebp-20Ch] BYREF
  int v14[128]; // [esp+2Ch] [ebp-208h]

  v11 = a2;
  Type = 3;
  cbData = 512;
  result = (char **)RegQueryValueExW(hKey, lpValueName, 0, &Type, Data, &cbData);
  if ( !result )
  {
    v4 = 0;
    if ( (cbData & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v5 = *v11;
        v6 = (char *)v14[2 * v4];
        v9[0] = *(char **)&Data[8 * v4];
        v8 = *(_DWORD *)(v5 + 4);
        v9[2] = v6;
        result = sub_41EEB0(v9, (char *)v5, v8);
        v7 = v11[1];
        if ( v7 == 357913940 )
          std::_Xlength_error("list<T> too long");
        v11[1] = v7 + 1;
        *(_DWORD *)(v5 + 4) = result;
        *(_DWORD *)result[1] = result;
        ++v4;
      }
      while ( v4 < cbData >> 3 );
    }
  }
  return result;
}
// 488A80: using guessed type _DWORD var_208[128];

//----- (00488B70) --------------------------------------------------------
void __stdcall sub_488B70(_DWORD *a1)
{
  char **v1; // ecx
  char *v2; // eax
  _DWORD **v3; // ecx
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  _DWORD **v6; // ecx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  _DWORD **v9; // ecx
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD **v12; // ecx
  _DWORD *v13; // eax
  _DWORD *v14; // esi
  _DWORD **v15; // ecx
  _DWORD *v16; // eax
  _DWORD *v17; // esi
  char **v18; // ecx
  char *v19; // eax
  _DWORD *v20; // esi
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  _DWORD *v27; // eax
  _DWORD *v28; // esi
  _DWORD *v29; // eax
  _DWORD *v30; // edi
  _DWORD *v31; // esi
  _DWORD *v32; // eax
  _DWORD *v33; // edi
  _DWORD *v34; // esi
  _DWORD *v35; // eax
  _DWORD *v36; // edi
  _DWORD *v37; // esi
  _DWORD *v38; // eax
  _DWORD *v39; // edi
  _DWORD *v40; // esi
  _DWORD *v41; // eax
  _DWORD *v42; // edi
  _DWORD *v43; // esi
  _DWORD *v44; // eax
  _DWORD *v45; // edi
  _DWORD *v46; // esi
  _DWORD *v47; // eax
  _DWORD *v48; // edi
  HKEY phkResult; // [esp+14h] [ebp-90h] BYREF
  int *v50; // [esp+18h] [ebp-8Ch]
  char *v51; // [esp+1Ch] [ebp-88h] BYREF
  char *v52; // [esp+20h] [ebp-84h] BYREF
  char *v53; // [esp+24h] [ebp-80h] BYREF
  void *v54[3]; // [esp+28h] [ebp-7Ch] BYREF
  void *v55[3]; // [esp+34h] [ebp-70h] BYREF
  void *v56[3]; // [esp+40h] [ebp-64h] BYREF
  void *v57[3]; // [esp+4Ch] [ebp-58h] BYREF
  void *v58[3]; // [esp+58h] [ebp-4Ch] BYREF
  void *v59[3]; // [esp+64h] [ebp-40h] BYREF
  void *v60[3]; // [esp+70h] [ebp-34h] BYREF
  int pExceptionObject[3]; // [esp+7Ch] [ebp-28h] BYREF
  int v62[4]; // [esp+88h] [ebp-1Ch] BYREF
  int v63; // [esp+A0h] [ebp-4h]

  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\DefaultColumns", 0, 0x20019u, &phkResult) )
  {
    v1 = (char **)a1[15124];
    v2 = *v1;
    *v1 = (char *)v1;
    *(_DWORD *)(a1[15124] + 4) = a1[15124];
    v50 = a1 + 15124;
    a1[15125] = 0;
    if ( v2 != (char *)a1[15124] )
    {
      do
      {
        v51 = *(char **)v2;
        operator delete(v2);
        v2 = v51;
      }
      while ( v51 != (char *)a1[15124] );
    }
    v3 = (_DWORD **)a1[15121];
    v4 = *v3;
    *v3 = v3;
    *(_DWORD *)(a1[15121] + 4) = a1[15121];
    a1[15122] = 0;
    if ( v4 != (_DWORD *)a1[15121] )
    {
      do
      {
        v5 = (_DWORD *)*v4;
        operator delete(v4);
        v4 = v5;
      }
      while ( v5 != (_DWORD *)a1[15121] );
    }
    v6 = (_DWORD **)a1[15118];
    v7 = *v6;
    *v6 = v6;
    *(_DWORD *)(a1[15118] + 4) = a1[15118];
    a1[15119] = 0;
    if ( v7 != (_DWORD *)a1[15118] )
    {
      do
      {
        v8 = (_DWORD *)*v7;
        operator delete(v7);
        v7 = v8;
      }
      while ( v8 != (_DWORD *)a1[15118] );
    }
    v9 = (_DWORD **)a1[15127];
    v10 = *v9;
    *v9 = v9;
    *(_DWORD *)(a1[15127] + 4) = a1[15127];
    a1[15128] = 0;
    if ( v10 != (_DWORD *)a1[15127] )
    {
      do
      {
        v11 = (_DWORD *)*v10;
        operator delete(v10);
        v10 = v11;
      }
      while ( v11 != (_DWORD *)a1[15127] );
    }
    v12 = (_DWORD **)a1[15130];
    v13 = *v12;
    *v12 = v12;
    *(_DWORD *)(a1[15130] + 4) = a1[15130];
    a1[15131] = 0;
    if ( v13 != (_DWORD *)a1[15130] )
    {
      do
      {
        v14 = (_DWORD *)*v13;
        operator delete(v13);
        v13 = v14;
      }
      while ( v14 != (_DWORD *)a1[15130] );
    }
    v15 = (_DWORD **)a1[15133];
    v16 = *v15;
    *v15 = v15;
    *(_DWORD *)(a1[15133] + 4) = a1[15133];
    a1[15134] = 0;
    if ( v16 != (_DWORD *)a1[15133] )
    {
      do
      {
        v17 = (_DWORD *)*v16;
        operator delete(v16);
        v16 = v17;
      }
      while ( v17 != (_DWORD *)a1[15133] );
    }
    v18 = (char **)a1[15136];
    v19 = *v18;
    v20 = a1 + 15136;
    *v18 = (char *)v18;
    *(_DWORD *)(a1[15136] + 4) = a1[15136];
    a1[15137] = 0;
    if ( v19 != (char *)a1[15136] )
    {
      do
      {
        v51 = *(char **)v19;
        operator delete(v19);
        v19 = v51;
      }
      while ( v51 != (char *)*v20 );
    }
    sub_488990(L"ControlPanelColumns", v50, phkResult);
    sub_488990(L"MyComputerColumns", a1 + 15121, phkResult);
    sub_488990(L"RealFolderColumns", a1 + 15118, phkResult);
    sub_488990(L"RecycleBinColumns", a1 + 15127, phkResult);
    sub_488990(L"PrinterColumns", a1 + 15130, phkResult);
    sub_488990(L"NetworkColumns", a1 + 15133, phkResult);
    sub_488990(L"NetworkPlacesColumns", a1 + 15136, phkResult);
    v60[1] = 0;
    v21 = operator new(0x14u);
    if ( !v21 )
    {
      v53 = 0;
      std::exception::exception((std::exception *)v58, (const char *const *)&v53);
      v58[0] = &std::bad_alloc::`vftable';
      _CxxThrowException(v58, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v21 = v21;
    v60[0] = v21;
    v21[1] = v21;
    v63 = 0;
    v59[1] = 0;
    v22 = operator new(0x14u);
    if ( !v22 )
    {
      v52 = 0;
      std::exception::exception((std::exception *)v62, (const char *const *)&v52);
      v62[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(v62, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v22 = v22;
    v59[0] = v22;
    v22[1] = v22;
    LOBYTE(v63) = 1;
    v58[1] = 0;
    v23 = operator new(0x14u);
    if ( !v23 )
    {
      v51 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v51);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v23 = v23;
    v58[0] = v23;
    v23[1] = v23;
    LOBYTE(v63) = 2;
    v57[1] = 0;
    v24 = operator new(0x14u);
    if ( !v24 )
    {
      v52 = 0;
      std::exception::exception((std::exception *)v62, (const char *const *)&v52);
      v62[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(v62, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v24 = v24;
    v57[0] = v24;
    v24[1] = v24;
    LOBYTE(v63) = 3;
    v56[1] = 0;
    v25 = operator new(0x14u);
    if ( !v25 )
    {
      v51 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v51);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v25 = v25;
    v56[0] = v25;
    v25[1] = v25;
    LOBYTE(v63) = 4;
    v55[1] = 0;
    v26 = operator new(0x14u);
    if ( !v26 )
    {
      v52 = 0;
      std::exception::exception((std::exception *)v62, (const char *const *)&v52);
      v62[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(v62, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v26 = v26;
    v55[0] = v26;
    v26[1] = v26;
    LOBYTE(v63) = 5;
    v54[1] = 0;
    v27 = operator new(0x14u);
    if ( !v27 )
    {
      v51 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v51);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v27 = v27;
    v54[0] = v27;
    v27[1] = v27;
    LOBYTE(v63) = 6;
    sub_488A80(L"ControlPanelColumnWidths", (int *)v58, phkResult);
    sub_488A80(L"MyComputerColumnWidths", (int *)v59, phkResult);
    sub_488A80(L"RealFolderColumnWidths", (int *)v60, phkResult);
    sub_488A80(L"RecycleBinColumnWidths", (int *)v57, phkResult);
    sub_488A80(L"PrinterColumnWidths", (int *)v56, phkResult);
    sub_488A80(L"NetworkColumnWidths", (int *)v55, phkResult);
    sub_488A80(L"NetworkPlacesColumnWidths", (int *)v54, phkResult);
    sub_486F30((_DWORD **)v50, (_DWORD **)v58);
    sub_486F30((_DWORD **)a1 + 15121, (_DWORD **)v59);
    sub_486F30((_DWORD **)a1 + 15118, (_DWORD **)v60);
    sub_486F30((_DWORD **)a1 + 15127, (_DWORD **)v57);
    sub_486F30((_DWORD **)a1 + 15130, (_DWORD **)v56);
    sub_486F30((_DWORD **)a1 + 15133, (_DWORD **)v55);
    sub_486F30((_DWORD **)v20, (_DWORD **)v54);
    sub_495530(a1);
    RegCloseKey(phkResult);
    v28 = v54[0];
    v29 = *(_DWORD **)v54[0];
    *(_DWORD *)v54[0] = v54[0];
    v28[1] = v28;
    if ( v29 != v28 )
    {
      do
      {
        v30 = (_DWORD *)*v29;
        operator delete(v29);
        v29 = v30;
      }
      while ( v30 != v28 );
    }
    operator delete(v28);
    v31 = v55[0];
    v32 = *(_DWORD **)v55[0];
    *(_DWORD *)v55[0] = v55[0];
    v31[1] = v31;
    if ( v32 != v31 )
    {
      do
      {
        v33 = (_DWORD *)*v32;
        operator delete(v32);
        v32 = v33;
      }
      while ( v33 != v31 );
    }
    operator delete(v31);
    v34 = v56[0];
    v35 = *(_DWORD **)v56[0];
    *(_DWORD *)v56[0] = v56[0];
    v34[1] = v34;
    if ( v35 != v34 )
    {
      do
      {
        v36 = (_DWORD *)*v35;
        operator delete(v35);
        v35 = v36;
      }
      while ( v36 != v34 );
    }
    operator delete(v34);
    v37 = v57[0];
    v38 = *(_DWORD **)v57[0];
    *(_DWORD *)v57[0] = v57[0];
    v37[1] = v37;
    if ( v38 != v37 )
    {
      do
      {
        v39 = (_DWORD *)*v38;
        operator delete(v38);
        v38 = v39;
      }
      while ( v39 != v37 );
    }
    operator delete(v37);
    v40 = v58[0];
    v41 = *(_DWORD **)v58[0];
    *(_DWORD *)v58[0] = v58[0];
    v40[1] = v40;
    if ( v41 != v40 )
    {
      do
      {
        v42 = (_DWORD *)*v41;
        operator delete(v41);
        v41 = v42;
      }
      while ( v42 != v40 );
    }
    operator delete(v40);
    v43 = v59[0];
    v44 = *(_DWORD **)v59[0];
    *(_DWORD *)v59[0] = v59[0];
    v43[1] = v43;
    if ( v44 != v43 )
    {
      do
      {
        v45 = (_DWORD *)*v44;
        operator delete(v44);
        v44 = v45;
      }
      while ( v45 != v43 );
    }
    operator delete(v43);
    v46 = v60[0];
    v47 = *(_DWORD **)v60[0];
    *(_DWORD *)v60[0] = v60[0];
    v46[1] = v46;
    if ( v47 != v46 )
    {
      do
      {
        v48 = (_DWORD *)*v47;
        operator delete(v47);
        v47 = v48;
      }
      while ( v48 != v46 );
    }
    operator delete(v46);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004892B0) --------------------------------------------------------
void __thiscall sub_4892B0(_DWORD **this)
{
  sub_488B70(this[2]);
}

//----- (004892C0) --------------------------------------------------------
LSTATUS __thiscall sub_4892C0(_DWORD *this)
{
  LSTATUS result; // eax
  int v3; // edi
  int v4; // eax
  _DWORD *v5; // esi
  int v6; // eax
  HKEY phkResult; // [esp+10h] [ebp-64h] BYREF
  _DWORD *i; // [esp+14h] [ebp-60h]
  DWORD dwDisposition; // [esp+18h] [ebp-5Ch] BYREF
  void *v10[5]; // [esp+1Ch] [ebp-58h] BYREF
  unsigned int v11; // [esp+30h] [ebp-44h]
  void *v12; // [esp+38h] [ebp-3Ch] BYREF
  int v13; // [esp+48h] [ebp-2Ch]
  unsigned int v14; // [esp+4Ch] [ebp-28h]
  int v15; // [esp+54h] [ebp-20h]
  int v16; // [esp+58h] [ebp-1Ch]
  int v17; // [esp+70h] [ebp-4h]

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ColorRules");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\ColorRules",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  v3 = 0;
  if ( !result )
  {
    v4 = this[10];
    v5 = (_DWORD *)this[9];
    for ( i = (_DWORD *)v4; v5 != i; v5 += 16 )
    {
      v11 = 7;
      v10[4] = 0;
      LOWORD(v10[0]) = 0;
      sub_4090E0((int)v10, v5, 0, 0xFFFFFFFF);
      v17 = 0;
      v14 = 7;
      v13 = 0;
      LOWORD(v12) = 0;
      sub_4090E0((int)&v12, v5 + 7, 0, 0xFFFFFFFF);
      v6 = v5[15];
      v15 = v5[14];
      v17 = -1;
      v16 = v6;
      sub_486D60(v3++, phkResult, (int)v10);
      if ( v14 >= 8 )
        operator delete(v12);
      v14 = 7;
      v13 = 0;
      LOWORD(v12) = 0;
      if ( v11 >= 8 )
        operator delete(v10[0]);
    }
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00489430) --------------------------------------------------------
LSTATUS __thiscall sub_489430(_DWORD **this)
{
  return sub_4892C0(this[2]);
}

//----- (00489440) --------------------------------------------------------
LSTATUS __thiscall sub_489440(HKEY this, int a2)
{
  HKEY v2; // edi
  LSTATUS result; // eax
  LSTATUS v4; // eax
  LSTATUS v5; // esi
  LSTATUS v6; // edi
  _DWORD *v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // esi
  DWORD v12; // edi
  void **v13; // edi
  DWORD v14; // edi
  LPCWSTR v15; // [esp-1Ch] [ebp-2A8h] BYREF
  int v16; // [esp-18h] [ebp-2A4h]
  int v17; // [esp-14h] [ebp-2A0h]
  int v18; // [esp-10h] [ebp-29Ch]
  int v19; // [esp-Ch] [ebp-298h]
  int v20; // [esp-8h] [ebp-294h]
  int v21; // [esp-4h] [ebp-290h]
  DWORD cbData; // [esp+10h] [ebp-27Ch] BYREF
  HKEY phkResult; // [esp+14h] [ebp-278h] BYREF
  DWORD dwIndex; // [esp+18h] [ebp-274h]
  _DWORD *v25; // [esp+1Ch] [ebp-270h]
  DWORD cchName; // [esp+20h] [ebp-26Ch] BYREF
  HKEY hKey; // [esp+24h] [ebp-268h]
  DWORD v28; // [esp+28h] [ebp-264h] BYREF
  DWORD v29; // [esp+2Ch] [ebp-260h]
  DWORD Type; // [esp+30h] [ebp-25Ch] BYREF
  void *v31[5]; // [esp+34h] [ebp-258h] BYREF
  unsigned int v32; // [esp+48h] [ebp-244h]
  void *v33; // [esp+50h] [ebp-23Ch] BYREF
  int v34; // [esp+60h] [ebp-22Ch]
  unsigned int v35; // [esp+64h] [ebp-228h]
  char Data[4]; // [esp+6Ch] [ebp-220h] BYREF
  char v37[4]; // [esp+70h] [ebp-21Ch] BYREF
  WCHAR Name[258]; // [esp+74h] [ebp-218h] BYREF
  int v39; // [esp+288h] [ebp-4h]

  v2 = this;
  v25 = (_DWORD *)a2;
  hKey = this;
  dwIndex = 0;
  cchName = 256;
  result = RegEnumKeyExW(this, 0, Name, &cchName, 0, 0, 0, 0);
  if ( !result )
  {
    while ( 1 )
    {
      ++dwIndex;
      v32 = 7;
      v31[4] = 0;
      LOWORD(v31[0]) = 0;
      v35 = 7;
      v34 = 0;
      LOWORD(v33) = 0;
      v39 = 0;
      RegOpenKeyExW(v2, Name, 0, 0x20019u, &phkResult);
      cbData = (DWORD)&v15;
      v20 = 7;
      v19 = 0;
      LOWORD(v15) = 0;
      sub_4094F0(&v15, 0, L"Description", 11);
      v4 = sub_464420(v31, phkResult, v15, v16, v17, v18, v19, v20);
      cbData = (DWORD)&v15;
      v20 = 7;
      v19 = 0;
      v5 = v4;
      LOWORD(v15) = 0;
      sub_4094F0(&v15, 0, L"FilenamePattern", 15);
      v6 = sub_464420(&v33, phkResult, v15, v16, v17, v18, v19, v20);
      cbData = 4;
      RegQueryValueExW(phkResult, L"Attributes", 0, 0, (LPBYTE)Data, &cbData);
      Type = 3;
      v28 = 4;
      RegQueryValueExW(phkResult, L"Color", 0, &Type, (LPBYTE)v37, &v28);
      if ( !v5 && !v6 )
        break;
LABEL_18:
      RegCloseKey(phkResult);
      v39 = -1;
      cchName = 256;
      if ( v35 >= 8 )
        operator delete(v33);
      v35 = 7;
      v34 = 0;
      LOWORD(v33) = 0;
      if ( v32 >= 8 )
        operator delete(v31[0]);
      result = RegEnumKeyExW(hKey, dwIndex, Name, &cchName, 0, 0, 0, 0);
      if ( result )
        return result;
      v2 = hKey;
    }
    v7 = v25;
    v8 = v25[10];
    if ( (unsigned int)v31 >= v8 || (v9 = v25[9], v9 > (unsigned int)v31) )
    {
      if ( v8 == v25[11] )
        sub_409A10(v25 + 9);
      v14 = v7[10];
      v29 = v14;
      cbData = v14;
      LOBYTE(v39) = 2;
      if ( !v14 )
        goto LABEL_17;
      v21 = v14;
      v13 = v31;
    }
    else
    {
      v10 = (unsigned int)v31 - v9;
      if ( v8 == v25[11] )
        sub_409A10(v25 + 9);
      v11 = v7[9] + (v10 & 0xFFFFFFC0);
      v12 = v7[10];
      cbData = v12;
      v29 = v12;
      LOBYTE(v39) = 1;
      if ( !v12 )
        goto LABEL_17;
      v21 = v12;
      v13 = (void **)v11;
    }
    sub_409890(v13, v21);
LABEL_17:
    v25[10] += 64;
    goto LABEL_18;
  }
  return result;
}
// 4C9C40: using guessed type wchar_t aDescription_4[12];
// 4C9C58: using guessed type wchar_t aFilenamepatter_2[16];
// 489440: using guessed type BYTE Data[4];
// 489440: using guessed type BYTE var_21C[4];

//----- (00489710) --------------------------------------------------------
LSTATUS __usercall sub_489710@<eax>(HKEY a1@<ecx>, int a2@<esi>)
{
  LSTATUS result; // eax
  _DWORD *v3; // eax
  int v4; // ecx
  _DWORD *v5; // edi
  HKEY phkResult; // [esp+0h] [ebp-4h] BYREF

  phkResult = a1;
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ColorRules", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    v3 = *(_DWORD **)(a2 + 40);
    v4 = *(_DWORD *)(a2 + 36);
    if ( (_DWORD *)v4 != v3 )
    {
      v5 = (_DWORD *)sub_409CA0(v3, v4, v3);
      sub_409CF0(v5, *(_DWORD **)(a2 + 40));
      *(_DWORD *)(a2 + 40) = v5;
    }
    sub_489440(phkResult, a2);
    return RegCloseKey(phkResult);
  }
  return result;
}

//----- (00489780) --------------------------------------------------------
LSTATUS __thiscall sub_489780(HKEY this)
{
  return sub_489710(this, *((_DWORD *)this + 2));
}

//----- (00489790) --------------------------------------------------------
LSTATUS __thiscall sub_489790(void *this)
{
  LSTATUS result; // eax
  int *v3; // eax
  int *v4; // eax
  int *v5; // eax
  HKEY phkResult; // [esp+10h] [ebp-10h] BYREF
  int v7; // [esp+1Ch] [ebp-4h]

  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Dialogs", 0, 0x20019u, &phkResult);
  if ( !result )
  {
    sub_485B70(phkResult, (int)this);
    sub_485B00(phkResult, (int)this);
    sub_485A90(phkResult, (int)this);
    if ( (dword_4F2220 & 1) == 0 )
    {
      dword_4F2220 |= 1u;
      v7 = 0;
      sub_482160();
      atexit(sub_4BCD00);
      v7 = -1;
    }
    sub_4650C0(phkResult, (int)&dword_4F1B60);
    if ( (dword_4F221C & 1) == 0 )
    {
      dword_4F221C |= 1u;
      v7 = 1;
      sub_476A70();
      atexit(sub_4BCD50);
      v7 = -1;
    }
    sub_4650C0(phkResult, (int)&dword_4F1728);
    if ( (dword_4F1B50 & 1) == 0 )
    {
      dword_4F1B50 |= 1u;
      sub_4653E0((int)&dword_4F03B8, (int)L"SetFileAttributes");
      dword_4F03B8 = (int)&CSetFileAttributesDialogPersistentSettings::`vftable';
      atexit(sub_4BCD30);
    }
    sub_4650C0(phkResult, (int)&dword_4F03B8);
    if ( (dword_4F1FD0 & 1) == 0 )
    {
      dword_4F1FD0 |= 1u;
      sub_4653E0((int)&dword_4F0A18, (int)L"RenameTab");
      dword_4F0A18 = (int)&CRenameTabDialogPersistentSettings::`vftable';
      atexit(sub_4BCCF0);
    }
    sub_4650C0(phkResult, (int)&dword_4F0A18);
    v3 = sub_499070();
    sub_4650C0(phkResult, (int)v3);
    if ( (dword_4F222C & 1) == 0 )
    {
      dword_4F222C |= 1u;
      v7 = 2;
      sub_49FC40();
      atexit(sub_4BCCA0);
      v7 = -1;
    }
    sub_4650C0(phkResult, (int)&dword_4F1FE0);
    if ( (dword_4F2210 & 1) == 0 )
    {
      dword_4F2210 |= 1u;
      sub_4A5390();
      atexit(sub_4BCBD0);
    }
    sub_4650C0(phkResult, (int)&dword_4F14C8);
    if ( (dword_4F220C & 1) == 0 )
    {
      dword_4F220C |= 1u;
      sub_4653E0((int)&dword_4F12A8, (int)L"CustomizeColors");
      dword_4F12A8 = (int)&CCustomizeColorsDialogPersistentSettings::`vftable';
      atexit(sub_4BCBE0);
    }
    sub_4650C0(phkResult, (int)&dword_4F12A8);
    if ( (dword_4F2484 & 1) == 0 )
    {
      dword_4F2484 |= 1u;
      v7 = 3;
      sub_47C990();
      atexit(sub_4BCD40);
      v7 = -1;
    }
    sub_4650C0(phkResult, (int)&dword_4F2230);
    v4 = sub_4A3890();
    sub_4650C0(phkResult, (int)v4);
    if ( (dword_4F1FD4 & 1) == 0 )
    {
      dword_4F1FD4 |= 1u;
      sub_4653E0((int)&dword_4F0C40, (int)L"MergeFiles");
      dword_4F0C40 = (int)&CMergeFilesDialogPersistentSettings::`vftable';
      atexit(sub_4BCCE0);
    }
    sub_4650C0(phkResult, (int)&dword_4F0C40);
    if ( (dword_4F1B58 & 1) == 0 )
    {
      dword_4F1B58 |= 1u;
      sub_4653E0((int)&dword_4F07F8, (int)L"SelectColumns");
      dword_4F07F8 = (int)&CSelectColumnsDialogPersistentSettings::`vftable';
      atexit(sub_4BCD10);
    }
    sub_4650C0(phkResult, (int)&dword_4F07F8);
    v5 = sub_47FEE0();
    sub_4650C0(phkResult, (int)v5);
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4C6D48: using guessed type wchar_t aSetfileattribu[18];
// 4C6DD0: using guessed type wchar_t aSelectcolumns[14];
// 4C7530: using guessed type wchar_t aRenametab[10];
// 4CABF8: using guessed type wchar_t aMergefiles[11];
// 4CB37C: using guessed type wchar_t aCustomizecolor[16];
// 4CBB88: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 4CC04C: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 4CC0F4: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 4CC1AC: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 4CC24C: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;
// 4F07F8: using guessed type int dword_4F07F8;
// 4F0A18: using guessed type int dword_4F0A18;
// 4F0C40: using guessed type int dword_4F0C40;
// 4F12A8: using guessed type int dword_4F12A8;
// 4F14C8: using guessed type int dword_4F14C8;
// 4F1728: using guessed type int dword_4F1728;
// 4F1B50: using guessed type int dword_4F1B50;
// 4F1B58: using guessed type int dword_4F1B58;
// 4F1B60: using guessed type int dword_4F1B60;
// 4F1FD0: using guessed type int dword_4F1FD0;
// 4F1FD4: using guessed type int dword_4F1FD4;
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F220C: using guessed type int dword_4F220C;
// 4F2210: using guessed type int dword_4F2210;
// 4F221C: using guessed type int dword_4F221C;
// 4F2220: using guessed type int dword_4F2220;
// 4F222C: using guessed type int dword_4F222C;
// 4F2230: using guessed type int dword_4F2230;
// 4F2484: using guessed type int dword_4F2484;

//----- (00489A90) --------------------------------------------------------
LSTATUS __thiscall sub_489A90(void *this)
{
  LSTATUS result; // eax
  int *v3; // eax
  int *v4; // eax
  int *v5; // eax
  HKEY v6; // [esp-4h] [ebp-28h]
  HKEY v7; // [esp-4h] [ebp-28h]
  HKEY v8; // [esp-4h] [ebp-28h]
  DWORD dwDisposition; // [esp+10h] [ebp-14h] BYREF
  HKEY phkResult; // [esp+14h] [ebp-10h] BYREF
  int v11; // [esp+20h] [ebp-4h]

  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Dialogs",
             0,
             0,
             0,
             0x20006u,
             0,
             &phkResult,
             &dwDisposition);
  if ( !result )
  {
    sub_485CA0((int)this, phkResult);
    sub_485C40((int)this, phkResult);
    sub_485BE0((int)this, phkResult);
    if ( (dword_4F2220 & 1) == 0 )
    {
      dword_4F2220 |= 1u;
      v11 = 0;
      sub_482160();
      atexit(sub_4BCD00);
      v11 = -1;
    }
    sub_465170((int)&dword_4F1B60, phkResult);
    if ( (dword_4F221C & 1) == 0 )
    {
      dword_4F221C |= 1u;
      v11 = 1;
      sub_476A70();
      atexit(sub_4BCD50);
      v11 = -1;
    }
    sub_465170((int)&dword_4F1728, phkResult);
    if ( (dword_4F1B50 & 1) == 0 )
    {
      dword_4F1B50 |= 1u;
      sub_4653E0((int)&dword_4F03B8, (int)L"SetFileAttributes");
      dword_4F03B8 = (int)&CSetFileAttributesDialogPersistentSettings::`vftable';
      atexit(sub_4BCD30);
    }
    sub_465170((int)&dword_4F03B8, phkResult);
    if ( (dword_4F1FD0 & 1) == 0 )
    {
      dword_4F1FD0 |= 1u;
      sub_4653E0((int)&dword_4F0A18, (int)L"RenameTab");
      dword_4F0A18 = (int)&CRenameTabDialogPersistentSettings::`vftable';
      atexit(sub_4BCCF0);
    }
    sub_465170((int)&dword_4F0A18, phkResult);
    v6 = phkResult;
    v3 = sub_499070();
    sub_465170((int)v3, v6);
    if ( (dword_4F222C & 1) == 0 )
    {
      dword_4F222C |= 1u;
      v11 = 2;
      sub_49FC40();
      atexit(sub_4BCCA0);
      v11 = -1;
    }
    sub_465170((int)&dword_4F1FE0, phkResult);
    if ( (dword_4F2210 & 1) == 0 )
    {
      dword_4F2210 |= 1u;
      sub_4A5390();
      atexit(sub_4BCBD0);
    }
    sub_465170((int)&dword_4F14C8, phkResult);
    if ( (dword_4F220C & 1) == 0 )
    {
      dword_4F220C |= 1u;
      sub_4653E0((int)&dword_4F12A8, (int)L"CustomizeColors");
      dword_4F12A8 = (int)&CCustomizeColorsDialogPersistentSettings::`vftable';
      atexit(sub_4BCBE0);
    }
    sub_465170((int)&dword_4F12A8, phkResult);
    if ( (dword_4F2484 & 1) == 0 )
    {
      dword_4F2484 |= 1u;
      v11 = 3;
      sub_47C990();
      atexit(sub_4BCD40);
      v11 = -1;
    }
    sub_465170((int)&dword_4F2230, phkResult);
    v7 = phkResult;
    v4 = sub_4A3890();
    sub_465170((int)v4, v7);
    if ( (dword_4F1FD4 & 1) == 0 )
    {
      dword_4F1FD4 |= 1u;
      sub_4653E0((int)&dword_4F0C40, (int)L"MergeFiles");
      dword_4F0C40 = (int)&CMergeFilesDialogPersistentSettings::`vftable';
      atexit(sub_4BCCE0);
    }
    sub_465170((int)&dword_4F0C40, phkResult);
    if ( (dword_4F1B58 & 1) == 0 )
    {
      dword_4F1B58 |= 1u;
      sub_4653E0((int)&dword_4F07F8, (int)L"SelectColumns");
      dword_4F07F8 = (int)&CSelectColumnsDialogPersistentSettings::`vftable';
      atexit(sub_4BCD10);
    }
    sub_465170((int)&dword_4F07F8, phkResult);
    v8 = phkResult;
    v5 = sub_47FEE0();
    sub_465170((int)v5, v8);
    return RegCloseKey(phkResult);
  }
  return result;
}
// 4C6D48: using guessed type wchar_t aSetfileattribu[18];
// 4C6DD0: using guessed type wchar_t aSelectcolumns[14];
// 4C7530: using guessed type wchar_t aRenametab[10];
// 4CABF8: using guessed type wchar_t aMergefiles[11];
// 4CB37C: using guessed type wchar_t aCustomizecolor[16];
// 4CBB88: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 4CC04C: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 4CC0F4: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 4CC1AC: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 4CC24C: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;
// 4F07F8: using guessed type int dword_4F07F8;
// 4F0A18: using guessed type int dword_4F0A18;
// 4F0C40: using guessed type int dword_4F0C40;
// 4F12A8: using guessed type int dword_4F12A8;
// 4F14C8: using guessed type int dword_4F14C8;
// 4F1728: using guessed type int dword_4F1728;
// 4F1B50: using guessed type int dword_4F1B50;
// 4F1B58: using guessed type int dword_4F1B58;
// 4F1B60: using guessed type int dword_4F1B60;
// 4F1FD0: using guessed type int dword_4F1FD0;
// 4F1FD4: using guessed type int dword_4F1FD4;
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F220C: using guessed type int dword_4F220C;
// 4F2210: using guessed type int dword_4F2210;
// 4F221C: using guessed type int dword_4F221C;
// 4F2220: using guessed type int dword_4F2220;
// 4F222C: using guessed type int dword_4F222C;
// 4F2230: using guessed type int dword_4F2230;
// 4F2484: using guessed type int dword_4F2484;

//----- (00489DB0) --------------------------------------------------------
LSTATUS __thiscall sub_489DB0(void **this)
{
  return sub_489A90(this[2]);
}

//----- (00489DC0) --------------------------------------------------------
LSTATUS __thiscall sub_489DC0(void **this)
{
  return sub_489790(this[2]);
}

//----- (00489DD0) --------------------------------------------------------
int __stdcall sub_489DD0(int a1)
{
  DWORD v1; // eax
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // esi
  _DWORD *v18; // ecx
  char *v19; // edx
  char *v20; // eax
  _DWORD *v21; // esi
  _DWORD *v22; // ecx
  char *v23; // edx
  char *v24; // eax
  _DWORD *v25; // esi
  _DWORD *v26; // ecx
  char *v27; // edx
  char *v28; // eax
  _DWORD *v29; // esi
  _DWORD *v30; // ecx
  char *v31; // edx
  char *v32; // eax
  _DWORD *v33; // esi
  _DWORD *v34; // ecx
  char *v35; // edx
  char *v36; // eax
  _DWORD *v37; // esi
  _DWORD *v38; // ecx
  char *v39; // edx
  char *v40; // eax
  _DWORD *v41; // edi
  _DWORD *v42; // ecx
  char *v43; // edx
  char *v44; // eax
  _DWORD *v45; // eax
  _DWORD *v46; // ebx
  _DWORD *v47; // eax
  _DWORD *v48; // edi
  _DWORD *v49; // esi
  _DWORD *v50; // eax
  _DWORD *v51; // edi
  _DWORD *v52; // esi
  _DWORD *v53; // eax
  _DWORD *v54; // edi
  _DWORD *v55; // esi
  _DWORD *v56; // eax
  _DWORD *v57; // edi
  _DWORD *v58; // esi
  _DWORD *v59; // eax
  _DWORD *v60; // edi
  _DWORD *v61; // esi
  _DWORD *v62; // eax
  _DWORD *v63; // edi
  char *v64; // eax
  unsigned int i; // ebx
  char *v66; // ecx
  char *v67; // edx
  char ***v68; // edi
  char **v69; // eax
  _DWORD *v70; // edi
  char *v71; // eax
  unsigned int j; // ebx
  char *v73; // ecx
  char *v74; // edx
  char ***v75; // edi
  char **v76; // eax
  _DWORD *v77; // edx
  char *v78; // eax
  unsigned int k; // ebx
  char *v80; // ecx
  char *v81; // edx
  char ***v82; // edi
  char **v83; // eax
  _DWORD *v84; // edx
  char *v85; // eax
  unsigned int m; // ebx
  char *v87; // ecx
  char *v88; // edx
  char ***v89; // edi
  char **v90; // eax
  _DWORD *v91; // edx
  char *v92; // eax
  unsigned int n; // ebx
  char *v94; // ecx
  char *v95; // edx
  char ***v96; // edi
  char **v97; // eax
  _DWORD *v98; // edx
  char *v99; // eax
  unsigned int ii; // ebx
  char *v101; // ecx
  char *v102; // edx
  char ***v103; // edi
  char **v104; // eax
  _DWORD *v105; // edi
  char *v106; // eax
  unsigned int jj; // ebx
  char *v108; // ecx
  char *v109; // edx
  char ***v110; // edi
  char **v111; // eax
  DWORD v112; // eax
  void *v113; // edi
  LSTATUS v114; // ebx
  char *v115; // eax
  char *v116; // ecx
  char *v117; // edi
  char *v118; // eax
  char *v119; // ecx
  char *v120; // edi
  char *v121; // eax
  char *v122; // ecx
  char *v123; // edi
  char *v124; // eax
  char *v125; // ecx
  char *v126; // edi
  char *v127; // eax
  char *v128; // ecx
  char *v129; // edi
  char *v130; // eax
  char *v131; // ecx
  char *v132; // edi
  char *v133; // eax
  char *v134; // ecx
  char *v135; // edi
  int v137; // [esp-4h] [ebp-9B0h]
  int v138; // [esp-4h] [ebp-9B0h]
  int v139; // [esp-4h] [ebp-9B0h]
  int v140; // [esp-4h] [ebp-9B0h]
  int v141; // [esp-4h] [ebp-9B0h]
  int v142; // [esp-4h] [ebp-9B0h]
  int v143; // [esp-4h] [ebp-9B0h]
  DWORD v144; // [esp+14h] [ebp-998h] BYREF
  HKEY hKey; // [esp+18h] [ebp-994h] BYREF
  HKEY v146; // [esp+1Ch] [ebp-990h] BYREF
  char *v147; // [esp+20h] [ebp-98Ch] BYREF
  int v148; // [esp+24h] [ebp-988h]
  char *v149; // [esp+2Ch] [ebp-980h] BYREF
  int v150; // [esp+30h] [ebp-97Ch]
  char *v151; // [esp+38h] [ebp-974h] BYREF
  int v152; // [esp+3Ch] [ebp-970h]
  char *v153; // [esp+44h] [ebp-968h] BYREF
  int v154; // [esp+48h] [ebp-964h]
  char *v155; // [esp+50h] [ebp-95Ch] BYREF
  int v156; // [esp+54h] [ebp-958h]
  char *v157; // [esp+5Ch] [ebp-950h] BYREF
  int v158; // [esp+60h] [ebp-94Ch]
  char *v159; // [esp+68h] [ebp-944h] BYREF
  int v160; // [esp+6Ch] [ebp-940h]
  int v161; // [esp+74h] [ebp-938h]
  HKEY phkResult; // [esp+78h] [ebp-934h] BYREF
  DWORD v163; // [esp+7Ch] [ebp-930h] BYREF
  int v164; // [esp+80h] [ebp-92Ch]
  LPVOID pv; // [esp+84h] [ebp-928h]
  int v166; // [esp+88h] [ebp-924h]
  DWORD cbData; // [esp+8Ch] [ebp-920h] BYREF
  void *v168; // [esp+90h] [ebp-91Ch] BYREF
  int v169; // [esp+94h] [ebp-918h]
  char *v170; // [esp+9Ch] [ebp-910h] BYREF
  char *v171; // [esp+A0h] [ebp-90Ch] BYREF
  char *v172; // [esp+A4h] [ebp-908h] BYREF
  char *v173; // [esp+A8h] [ebp-904h] BYREF
  char *v174; // [esp+ACh] [ebp-900h] BYREF
  char *v175; // [esp+B0h] [ebp-8FCh] BYREF
  char *v176; // [esp+B4h] [ebp-8F8h] BYREF
  char *v177; // [esp+B8h] [ebp-8F4h] BYREF
  char *v178; // [esp+BCh] [ebp-8F0h] BYREF
  char *v179; // [esp+C0h] [ebp-8ECh] BYREF
  DWORD v180; // [esp+C4h] [ebp-8E8h] BYREF
  void *v181; // [esp+C8h] [ebp-8E4h] BYREF
  int v182; // [esp+CCh] [ebp-8E0h]
  char *v183; // [esp+D4h] [ebp-8D8h] BYREF
  void *v184; // [esp+D8h] [ebp-8D4h] BYREF
  int v185; // [esp+DCh] [ebp-8D0h]
  char *v186; // [esp+E4h] [ebp-8C8h] BYREF
  void *v187; // [esp+E8h] [ebp-8C4h] BYREF
  int v188; // [esp+ECh] [ebp-8C0h]
  char *v189; // [esp+F4h] [ebp-8B8h] BYREF
  void *v190; // [esp+F8h] [ebp-8B4h] BYREF
  int v191; // [esp+FCh] [ebp-8B0h]
  DWORD v192; // [esp+104h] [ebp-8A8h] BYREF
  char *v193; // [esp+108h] [ebp-8A4h] BYREF
  void *v194; // [esp+10Ch] [ebp-8A0h] BYREF
  int v195; // [esp+110h] [ebp-89Ch]
  void *v196; // [esp+118h] [ebp-894h] BYREF
  int v197; // [esp+11Ch] [ebp-890h]
  char *v198[3]; // [esp+124h] [ebp-888h] BYREF
  char *v199[3]; // [esp+130h] [ebp-87Ch] BYREF
  char *v200[3]; // [esp+13Ch] [ebp-870h] BYREF
  char *v201[3]; // [esp+148h] [ebp-864h] BYREF
  char *v202[3]; // [esp+154h] [ebp-858h] BYREF
  char *v203[3]; // [esp+160h] [ebp-84Ch] BYREF
  char *v204[3]; // [esp+16Ch] [ebp-840h] BYREF
  int v205[3]; // [esp+178h] [ebp-834h] BYREF
  int v206[3]; // [esp+184h] [ebp-828h] BYREF
  int pExceptionObject[3]; // [esp+190h] [ebp-81Ch] BYREF
  int v208[3]; // [esp+19Ch] [ebp-810h] BYREF
  int v209[3]; // [esp+1A8h] [ebp-804h] BYREF
  int v210[3]; // [esp+1B4h] [ebp-7F8h] BYREF
  DWORD Type; // [esp+1C0h] [ebp-7ECh] BYREF
  int v212[3]; // [esp+1C4h] [ebp-7E8h] BYREF
  int v213[3]; // [esp+1D0h] [ebp-7DCh] BYREF
  int v214[3]; // [esp+1DCh] [ebp-7D0h] BYREF
  int v215[3]; // [esp+1E8h] [ebp-7C4h] BYREF
  int v216[3]; // [esp+1F4h] [ebp-7B8h] BYREF
  int v217[3]; // [esp+200h] [ebp-7ACh] BYREF
  int v218[3]; // [esp+20Ch] [ebp-7A0h] BYREF
  int v219[3]; // [esp+218h] [ebp-794h] BYREF
  int v220; // [esp+224h] [ebp-788h] BYREF
  char Data[4]; // [esp+228h] [ebp-784h] BYREF
  char v222[4]; // [esp+22Ch] [ebp-780h] BYREF
  char v223[4]; // [esp+230h] [ebp-77Ch] BYREF
  char v224[4]; // [esp+234h] [ebp-778h] BYREF
  char v225[4]; // [esp+238h] [ebp-774h] BYREF
  char v226[4]; // [esp+23Ch] [ebp-770h] BYREF
  char v227[4]; // [esp+240h] [ebp-76Ch] BYREF
  char v228[4]; // [esp+244h] [ebp-768h] BYREF
  int v229; // [esp+248h] [ebp-764h]
  int v230; // [esp+24Ch] [ebp-760h]
  BYTE v232[2]; // [esp+260h] [ebp-74Ch] BYREF
  char **v233; // [esp+660h] [ebp-34Ch]
  char **v234; // [esp+664h] [ebp-348h]
  char **v235; // [esp+668h] [ebp-344h]
  char **v236; // [esp+66Ch] [ebp-340h]
  char **v237; // [esp+670h] [ebp-33Ch]
  char **v238; // [esp+674h] [ebp-338h]
  char **v239; // [esp+678h] [ebp-334h]
  int v240; // [esp+67Ch] [ebp-330h] BYREF
  char v241[4]; // [esp+680h] [ebp-32Ch] BYREF
  BYTE v242[4]; // [esp+684h] [ebp-328h] BYREF
  BYTE v243[2]; // [esp+688h] [ebp-324h] BYREF
  WCHAR SubKey[130]; // [esp+894h] [ebp-118h] BYREF
  int v245; // [esp+9A8h] [ebp-4h]

  v164 = a1;
  pv = 0;
  v161 = 0;
  v166 = 0;
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Tabs", 0, 0x20019u, &phkResult) )
  {
    sub_401000(0x80u, SubKey, L"%d", 0);
    if ( !RegOpenKeyExW(phkResult, SubKey, 0, 0x20019u, &hKey) )
    {
      do
      {
        if ( !RegQueryValueExW(hKey, L"Directory", 0, 0, 0, &cbData) )
        {
          pv = CoTaskMemAlloc(cbData);
          RegQueryValueExW(hKey, L"Directory", 0, &Type, (LPBYTE)pv, &cbData);
        }
        v144 = 4;
        RegQueryValueExW(hKey, L"ViewMode", 0, 0, (LPBYTE)Data, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"SortMode", 0, 0, (LPBYTE)&v220, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"SortAscending", 0, 0, (LPBYTE)v222, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"ShowInGroups", 0, 0, (LPBYTE)v223, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"ApplyFilter", 0, 0, (LPBYTE)v227, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"FilterCaseSensitive", 0, 0, (LPBYTE)v228, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"ShowHidden", 0, 0, (LPBYTE)v224, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"AutoArrange", 0, 0, (LPBYTE)v225, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"ShowGridlines", 0, 0, (LPBYTE)v226, &v144);
        v144 = 512;
        RegQueryValueExW(hKey, L"Filter", 0, &v192, v232, &v144);
        v1 = v144;
        if ( v144 && v192 == 1 )
        {
          if ( *(_WORD *)&v232[2 * v144 - 2] )
          {
            if ( v144 >= 0x200 )
              v1 = 512;
            *(_WORD *)&v232[2 * v1] = 0;
          }
        }
        else
        {
          *(_WORD *)v232 = 0;
        }
        v2 = *(_DWORD *)(v164 + 59336);
        v229 = *(_DWORD *)(v164 + 59332);
        v230 = v2;
        v154 = 0;
        v3 = (char *)operator new(0x14u);
        if ( !v3 )
        {
          v178 = 0;
          std::exception::exception((std::exception *)v216, (const char *const *)&v178);
          v216[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v216, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v153 = v3;
        *(_DWORD *)v3 = v3;
        *((_DWORD *)v153 + 1) = v153;
        v245 = 0;
        v148 = 0;
        v4 = (char *)operator new(0x14u);
        if ( !v4 )
        {
          v186 = 0;
          std::exception::exception((std::exception *)v214, (const char *const *)&v186);
          v214[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v214, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v147 = v4;
        *(_DWORD *)v4 = v4;
        *((_DWORD *)v147 + 1) = v147;
        LOBYTE(v245) = 1;
        v160 = 0;
        v5 = (char *)operator new(0x14u);
        if ( !v5 )
        {
          v176 = 0;
          std::exception::exception((std::exception *)v212, (const char *const *)&v176);
          v212[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v212, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v159 = v5;
        *(_DWORD *)v5 = v5;
        *((_DWORD *)v159 + 1) = v159;
        LOBYTE(v245) = 2;
        v156 = 0;
        v6 = (char *)operator new(0x14u);
        if ( !v6 )
        {
          v193 = 0;
          std::exception::exception((std::exception *)v210, (const char *const *)&v193);
          v210[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v210, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v155 = v6;
        *(_DWORD *)v6 = v6;
        *((_DWORD *)v155 + 1) = v155;
        LOBYTE(v245) = 3;
        v152 = 0;
        v7 = (char *)operator new(0x14u);
        if ( !v7 )
        {
          v174 = 0;
          std::exception::exception((std::exception *)v208, (const char *const *)&v174);
          v208[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v208, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v151 = v7;
        *(_DWORD *)v7 = v7;
        *((_DWORD *)v151 + 1) = v151;
        LOBYTE(v245) = 4;
        v158 = 0;
        v8 = (char *)operator new(0x14u);
        if ( !v8 )
        {
          v183 = 0;
          std::exception::exception((std::exception *)v206, (const char *const *)&v183);
          v206[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v206, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v157 = v8;
        *(_DWORD *)v8 = v8;
        *((_DWORD *)v157 + 1) = v157;
        LOBYTE(v245) = 5;
        v150 = 0;
        v9 = (char *)operator new(0x14u);
        if ( !v9 )
        {
          v172 = 0;
          std::exception::exception((std::exception *)v218, (const char *const *)&v172);
          v218[0] = (int)&std::bad_alloc::`vftable';
          _CxxThrowException(v218, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v149 = v9;
        *(_DWORD *)v9 = v9;
        *((_DWORD *)v149 + 1) = v149;
        LOBYTE(v245) = 6;
        if ( !RegOpenKeyExW(hKey, L"Columns", 0, 0x20019u, &v146) )
        {
          sub_488990(L"ControlPanelColumns", (int *)&v159, v146);
          sub_488990(L"MyComputerColumns", (int *)&v147, v146);
          sub_488990(L"RealFolderColumns", (int *)&v153, v146);
          sub_488990(L"RecycleBinColumns", (int *)&v155, v146);
          sub_488990(L"PrinterColumns", (int *)&v151, v146);
          sub_488990(L"NetworkColumns", (int *)&v157, v146);
          sub_488990(L"NetworkPlacesColumns", (int *)&v149, v146);
          v191 = 0;
          v10 = operator new(0x14u);
          if ( !v10 )
          {
            v189 = 0;
            std::exception::exception((std::exception *)v213, (const char *const *)&v189);
            v213[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v213, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v10 = v10;
          v190 = v10;
          v10[1] = v10;
          LOBYTE(v245) = 7;
          v188 = 0;
          v11 = operator new(0x14u);
          if ( !v11 )
          {
            v179 = 0;
            std::exception::exception((std::exception *)v217, (const char *const *)&v179);
            v217[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v217, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v11 = v11;
          v187 = v11;
          v11[1] = v11;
          LOBYTE(v245) = 8;
          v185 = 0;
          v12 = operator new(0x14u);
          if ( !v12 )
          {
            v177 = 0;
            std::exception::exception((std::exception *)v205, (const char *const *)&v177);
            v205[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v205, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v12 = v12;
          v184 = v12;
          v12[1] = v12;
          LOBYTE(v245) = 9;
          v182 = 0;
          v13 = operator new(0x14u);
          if ( !v13 )
          {
            v175 = 0;
            std::exception::exception((std::exception *)v219, (const char *const *)&v175);
            v219[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v219, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v13 = v13;
          v181 = v13;
          v13[1] = v13;
          LOBYTE(v245) = 10;
          v169 = 0;
          v14 = operator new(0x14u);
          if ( !v14 )
          {
            v173 = 0;
            std::exception::exception((std::exception *)v209, (const char *const *)&v173);
            v209[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v209, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v14 = v14;
          v168 = v14;
          v14[1] = v14;
          LOBYTE(v245) = 11;
          v197 = 0;
          v15 = operator new(0x14u);
          if ( !v15 )
          {
            v171 = 0;
            std::exception::exception((std::exception *)v215, (const char *const *)&v171);
            v215[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(v215, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v15 = v15;
          v196 = v15;
          v15[1] = v15;
          LOBYTE(v245) = 12;
          v195 = 0;
          v16 = operator new(0x14u);
          if ( !v16 )
          {
            v170 = 0;
            std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v170);
            pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          *v16 = v16;
          v194 = v16;
          v16[1] = v16;
          LOBYTE(v245) = 13;
          sub_488A80(L"ControlPanelColumnWidths", (int *)&v184, v146);
          sub_488A80(L"MyComputerColumnWidths", (int *)&v187, v146);
          sub_488A80(L"RealFolderColumnWidths", (int *)&v190, v146);
          sub_488A80(L"RecycleBinColumnWidths", (int *)&v181, v146);
          sub_488A80(L"PrinterColumnWidths", (int *)&v168, v146);
          sub_488A80(L"NetworkColumnWidths", (int *)&v196, v146);
          sub_488A80(L"NetworkPlacesColumnWidths", (int *)&v194, v146);
          v17 = v184;
          v18 = *(_DWORD **)v184;
          if ( *(void **)v184 != v184 )
          {
            v19 = v159;
            do
            {
              v20 = *(char **)v19;
              if ( *(char **)v19 != v19 )
              {
                while ( *((_DWORD *)v20 + 2) != v18[2] )
                {
                  v20 = *(char **)v20;
                  if ( v20 == v19 )
                    goto LABEL_34;
                }
                *((_DWORD *)v20 + 4) = v18[4];
                v19 = v159;
              }
LABEL_34:
              v18 = (_DWORD *)*v18;
            }
            while ( v18 != v17 );
          }
          v21 = v187;
          v22 = *(_DWORD **)v187;
          if ( *(void **)v187 != v187 )
          {
            v23 = v147;
            do
            {
              v24 = *(char **)v23;
              if ( *(char **)v23 != v23 )
              {
                while ( *((_DWORD *)v24 + 2) != v22[2] )
                {
                  v24 = *(char **)v24;
                  if ( v24 == v23 )
                    goto LABEL_42;
                }
                *((_DWORD *)v24 + 4) = v22[4];
                v23 = v147;
              }
LABEL_42:
              v22 = (_DWORD *)*v22;
            }
            while ( v22 != v21 );
          }
          v25 = v190;
          v26 = *(_DWORD **)v190;
          if ( *(void **)v190 != v190 )
          {
            v27 = v153;
            do
            {
              v28 = *(char **)v27;
              if ( *(char **)v27 != v27 )
              {
                while ( *((_DWORD *)v28 + 2) != v26[2] )
                {
                  v28 = *(char **)v28;
                  if ( v28 == v27 )
                    goto LABEL_50;
                }
                *((_DWORD *)v28 + 4) = v26[4];
                v27 = v153;
              }
LABEL_50:
              v26 = (_DWORD *)*v26;
            }
            while ( v26 != v25 );
          }
          v29 = v181;
          v30 = *(_DWORD **)v181;
          if ( *(void **)v181 != v181 )
          {
            v31 = v155;
            do
            {
              v32 = *(char **)v31;
              if ( *(char **)v31 != v31 )
              {
                while ( *((_DWORD *)v32 + 2) != v30[2] )
                {
                  v32 = *(char **)v32;
                  if ( v32 == v31 )
                    goto LABEL_58;
                }
                *((_DWORD *)v32 + 4) = v30[4];
                v31 = v155;
              }
LABEL_58:
              v30 = (_DWORD *)*v30;
            }
            while ( v30 != v29 );
          }
          v33 = v168;
          v34 = *(_DWORD **)v168;
          if ( *(void **)v168 != v168 )
          {
            v35 = v151;
            do
            {
              v36 = *(char **)v35;
              if ( *(char **)v35 != v35 )
              {
                while ( *((_DWORD *)v36 + 2) != v34[2] )
                {
                  v36 = *(char **)v36;
                  if ( v36 == v35 )
                    goto LABEL_66;
                }
                *((_DWORD *)v36 + 4) = v34[4];
                v35 = v151;
              }
LABEL_66:
              v34 = (_DWORD *)*v34;
            }
            while ( v34 != v33 );
          }
          v37 = v196;
          v38 = *(_DWORD **)v196;
          if ( *(void **)v196 != v196 )
          {
            v39 = v157;
            do
            {
              v40 = *(char **)v39;
              if ( *(char **)v39 != v39 )
              {
                while ( *((_DWORD *)v40 + 2) != v38[2] )
                {
                  v40 = *(char **)v40;
                  if ( v40 == v39 )
                    goto LABEL_74;
                }
                *((_DWORD *)v40 + 4) = v38[4];
                v39 = v157;
              }
LABEL_74:
              v38 = (_DWORD *)*v38;
            }
            while ( v38 != v37 );
          }
          v41 = v194;
          v42 = *(_DWORD **)v194;
          if ( *(void **)v194 != v194 )
          {
            v43 = v149;
            do
            {
              v44 = *(char **)v43;
              if ( *(char **)v43 != v43 )
              {
                while ( *((_DWORD *)v44 + 2) != v42[2] )
                {
                  v44 = *(char **)v44;
                  if ( v44 == v43 )
                    goto LABEL_82;
                }
                *((_DWORD *)v44 + 4) = v42[4];
                v43 = v149;
              }
LABEL_82:
              v42 = (_DWORD *)*v42;
            }
            while ( v42 != v41 );
          }
          RegCloseKey(v146);
          v45 = (_DWORD *)*v41;
          *v41 = v41;
          v41[1] = v41;
          v195 = 0;
          if ( v45 != v41 )
          {
            do
            {
              v46 = (_DWORD *)*v45;
              operator delete(v45);
              v45 = v46;
            }
            while ( v46 != v41 );
          }
          operator delete(v41);
          v47 = (_DWORD *)*v37;
          *v37 = v37;
          v37[1] = v37;
          v197 = 0;
          if ( v47 != v37 )
          {
            do
            {
              v48 = (_DWORD *)*v47;
              operator delete(v47);
              v47 = v48;
            }
            while ( v48 != v37 );
          }
          operator delete(v37);
          v49 = v168;
          v50 = *(_DWORD **)v168;
          *(_DWORD *)v168 = v168;
          v49[1] = v49;
          v169 = 0;
          if ( v50 != v49 )
          {
            do
            {
              v51 = (_DWORD *)*v50;
              operator delete(v50);
              v50 = v51;
            }
            while ( v51 != v49 );
          }
          operator delete(v49);
          v52 = v181;
          v53 = *(_DWORD **)v181;
          *(_DWORD *)v181 = v181;
          v52[1] = v52;
          v182 = 0;
          if ( v53 != v52 )
          {
            do
            {
              v54 = (_DWORD *)*v53;
              operator delete(v53);
              v53 = v54;
            }
            while ( v54 != v52 );
          }
          operator delete(v52);
          v55 = v184;
          v56 = *(_DWORD **)v184;
          *(_DWORD *)v184 = v184;
          v55[1] = v55;
          v185 = 0;
          if ( v56 != v55 )
          {
            do
            {
              v57 = (_DWORD *)*v56;
              operator delete(v56);
              v56 = v57;
            }
            while ( v57 != v55 );
          }
          operator delete(v55);
          v58 = v187;
          v59 = *(_DWORD **)v187;
          *(_DWORD *)v187 = v187;
          v58[1] = v58;
          v188 = 0;
          if ( v59 != v58 )
          {
            do
            {
              v60 = (_DWORD *)*v59;
              operator delete(v59);
              v59 = v60;
            }
            while ( v60 != v58 );
          }
          operator delete(v58);
          LOBYTE(v245) = 6;
          v61 = v190;
          v62 = *(_DWORD **)v190;
          *(_DWORD *)v190 = v190;
          v61[1] = v61;
          v191 = 0;
          if ( v62 != v61 )
          {
            do
            {
              v63 = (_DWORD *)*v62;
              operator delete(v62);
              v62 = v63;
            }
            while ( v63 != v61 );
          }
          operator delete(v61);
        }
        v144 = (DWORD)malloc(0xCCu);
        memset((void *)v144, 0, 0xCCu);
        v64 = v153;
        for ( i = 0; i < 153; i += 3 )
        {
          v66 = *(char **)v64;
          if ( *(char **)v64 == v64 )
          {
LABEL_102:
            v67 = (char *)dword_4E5E84[i];
            v68 = (char ***)(v64 + 4);
            v198[0] = (char *)dword_4E5E80[i];
            v137 = *((_DWORD *)v64 + 1);
            v198[1] = v67;
            v198[2] = (char *)150;
            v69 = sub_41EEB0(v198, v64, v137);
            if ( v154 == 357913940 )
LABEL_180:
              std::_Xlength_error("list<T> too long");
            ++v154;
            *v68 = v69;
            *(_DWORD *)v69[1] = v69;
            v64 = v153;
          }
          else
          {
            while ( *((_DWORD *)v66 + 2) != dword_4E5E80[i] )
            {
              v66 = *(char **)v66;
              if ( v66 == v64 )
                goto LABEL_102;
            }
          }
        }
        free((void *)v144);
        v70 = malloc(8u);
        *v70 = 0;
        v70[1] = 0;
        v71 = v159;
        v144 = (DWORD)v70;
        for ( j = 0; j < 6; j += 3 )
        {
          v73 = *(char **)v71;
          if ( *(char **)v71 == v71 )
          {
LABEL_109:
            v74 = (char *)dword_4E60E8[j];
            v75 = (char ***)(v71 + 4);
            v201[0] = (char *)dword_4E60E4[j];
            v138 = *((_DWORD *)v71 + 1);
            v201[1] = v74;
            v201[2] = (char *)150;
            v76 = sub_41EEB0(v201, v71, v138);
            if ( v160 == 357913940 )
              goto LABEL_180;
            ++v160;
            *v75 = v76;
            v70 = (_DWORD *)v144;
            *(_DWORD *)v76[1] = v76;
            v71 = v159;
          }
          else
          {
            while ( *((_DWORD *)v73 + 2) != dword_4E60E4[j] )
            {
              v73 = *(char **)v73;
              if ( v73 == v71 )
                goto LABEL_109;
            }
          }
        }
        free(v70);
        v77 = malloc(0x18u);
        *v77 = 0;
        v77[1] = 0;
        v77[2] = 0;
        v77[3] = 0;
        v77[4] = 0;
        v77[5] = 0;
        v78 = v147;
        v144 = (DWORD)v77;
        for ( k = 0; k < 18; k += 3 )
        {
          v80 = *(char **)v78;
          if ( *(char **)v78 == v78 )
          {
LABEL_116:
            v81 = (char *)dword_4E6114[k];
            v82 = (char ***)(v78 + 4);
            v199[0] = (char *)dword_4E6110[k];
            v139 = *((_DWORD *)v78 + 1);
            v199[1] = v81;
            v199[2] = (char *)150;
            v83 = sub_41EEB0(v199, v78, v139);
            if ( v148 == 357913940 )
              goto LABEL_180;
            ++v148;
            v77 = (_DWORD *)v144;
            *v82 = v83;
            *(_DWORD *)v83[1] = v83;
            v78 = v147;
          }
          else
          {
            while ( *((_DWORD *)v80 + 2) != dword_4E6110[k] )
            {
              v80 = *(char **)v80;
              if ( v80 == v78 )
                goto LABEL_116;
            }
          }
        }
        free(v77);
        v84 = malloc(0x18u);
        *v84 = 0;
        v84[1] = 0;
        v84[2] = 0;
        v84[3] = 0;
        v84[4] = 0;
        v84[5] = 0;
        v85 = v155;
        v144 = (DWORD)v84;
        for ( m = 0; m < 18; m += 3 )
        {
          v87 = *(char **)v85;
          if ( *(char **)v85 == v85 )
          {
LABEL_123:
            v88 = (char *)dword_4E615C[m];
            v89 = (char ***)(v85 + 4);
            v200[0] = (char *)dword_4E6158[m];
            v140 = *((_DWORD *)v85 + 1);
            v200[1] = v88;
            v200[2] = (char *)150;
            v90 = sub_41EEB0(v200, v85, v140);
            if ( v156 == 357913940 )
              goto LABEL_180;
            ++v156;
            v84 = (_DWORD *)v144;
            *v89 = v90;
            *(_DWORD *)v90[1] = v90;
            v85 = v155;
          }
          else
          {
            while ( *((_DWORD *)v87 + 2) != dword_4E6158[m] )
            {
              v87 = *(char **)v87;
              if ( v87 == v85 )
                goto LABEL_123;
            }
          }
        }
        free(v84);
        v91 = malloc(0x18u);
        *v91 = 0;
        v91[1] = 0;
        v91[2] = 0;
        v91[3] = 0;
        v91[4] = 0;
        v91[5] = 0;
        v92 = v151;
        v144 = (DWORD)v91;
        for ( n = 0; n < 18; n += 3 )
        {
          v94 = *(char **)v92;
          if ( *(char **)v92 == v92 )
          {
LABEL_130:
            v95 = (char *)dword_4E61A4[n];
            v96 = (char ***)(v92 + 4);
            v202[0] = (char *)dword_4E61A0[n];
            v141 = *((_DWORD *)v92 + 1);
            v202[1] = v95;
            v202[2] = (char *)150;
            v97 = sub_41EEB0(v202, v92, v141);
            if ( v152 == 357913940 )
              goto LABEL_180;
            ++v152;
            v91 = (_DWORD *)v144;
            *v96 = v97;
            *(_DWORD *)v97[1] = v97;
            v92 = v151;
          }
          else
          {
            while ( *((_DWORD *)v94 + 2) != dword_4E61A0[n] )
            {
              v94 = *(char **)v94;
              if ( v94 == v92 )
                goto LABEL_130;
            }
          }
        }
        free(v91);
        v98 = malloc(0x10u);
        *v98 = 0;
        v98[1] = 0;
        v98[2] = 0;
        v98[3] = 0;
        v99 = v157;
        v144 = (DWORD)v98;
        for ( ii = 0; ii < 12; ii += 3 )
        {
          v101 = *(char **)v99;
          if ( *(char **)v99 == v99 )
          {
LABEL_137:
            v102 = (char *)dword_4E61EC[ii];
            v103 = (char ***)(v99 + 4);
            v204[0] = (char *)dword_4E61E8[ii];
            v142 = *((_DWORD *)v99 + 1);
            v204[1] = v102;
            v204[2] = (char *)150;
            v104 = sub_41EEB0(v204, v99, v142);
            if ( v158 == 357913940 )
              goto LABEL_180;
            ++v158;
            v98 = (_DWORD *)v144;
            *v103 = v104;
            *(_DWORD *)v104[1] = v104;
            v99 = v157;
          }
          else
          {
            while ( *((_DWORD *)v101 + 2) != dword_4E61E8[ii] )
            {
              v101 = *(char **)v101;
              if ( v101 == v99 )
                goto LABEL_137;
            }
          }
        }
        free(v98);
        v105 = malloc(8u);
        *v105 = 0;
        v105[1] = 0;
        v106 = v149;
        v144 = (DWORD)v105;
        for ( jj = 0; jj < 6; jj += 3 )
        {
          v108 = *(char **)v106;
          if ( *(char **)v106 == v106 )
          {
LABEL_144:
            v109 = (char *)dword_4E621C[jj];
            v110 = (char ***)(v106 + 4);
            v203[0] = (char *)dword_4E6218[jj];
            v143 = *((_DWORD *)v106 + 1);
            v203[1] = v109;
            v203[2] = (char *)150;
            v111 = sub_41EEB0(v203, v106, v143);
            if ( v150 == 357913940 )
              goto LABEL_180;
            ++v150;
            *v110 = v111;
            v105 = (_DWORD *)v144;
            *(_DWORD *)v111[1] = v111;
            v106 = v149;
          }
          else
          {
            while ( *((_DWORD *)v108 + 2) != dword_4E6218[jj] )
            {
              v108 = *(char **)v108;
              if ( v108 == v106 )
                goto LABEL_144;
            }
          }
        }
        free(v105);
        v235 = &v159;
        v238 = &v157;
        v234 = &v147;
        v239 = &v149;
        v236 = &v155;
        v237 = &v151;
        v233 = &v153;
        sub_4AFAF0(&v240);
        v144 = 4;
        RegQueryValueExW(hKey, L"Locked", 0, 0, (LPBYTE)&v240, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"AddressLocked", 0, 0, (LPBYTE)v241, &v144);
        v144 = 4;
        RegQueryValueExW(hKey, L"UseCustomName", 0, 0, v242, &v144);
        v163 = 260;
        RegQueryValueExW(hKey, L"CustomName", 0, &v180, v243, &v163);
        v112 = v163;
        if ( v163 && v180 == 1 )
        {
          if ( *(_WORD *)&v242[2 * v163 + 2] )
          {
            if ( v163 >= 0x104 )
            {
              v112 = 260;
              v163 = 260;
            }
            *(_WORD *)&v243[2 * v112] = 0;
          }
        }
        else
        {
          *(_WORD *)v243 = 0;
        }
        v113 = pv;
        if ( !sub_47B180(0, v164, (const ITEMIDLIST *)pv, &v220, &v240, 1) )
          ++v161;
        CoTaskMemFree(v113);
        RegCloseKey(hKey);
        sub_401000(0x80u, SubKey, L"%d", ++v166);
        v114 = RegOpenKeyExW(phkResult, SubKey, 0, 0x20019u, &hKey);
        v115 = *(char **)v149;
        *(_DWORD *)v149 = v149;
        *((_DWORD *)v149 + 1) = v149;
        v116 = v149;
        v150 = 0;
        if ( v115 != v149 )
        {
          do
          {
            v117 = *(char **)v115;
            operator delete(v115);
            v116 = v149;
            v115 = v117;
          }
          while ( v117 != v149 );
        }
        operator delete(v116);
        v118 = *(char **)v157;
        *(_DWORD *)v157 = v157;
        *((_DWORD *)v157 + 1) = v157;
        v119 = v157;
        v158 = 0;
        if ( v118 != v157 )
        {
          do
          {
            v120 = *(char **)v118;
            operator delete(v118);
            v119 = v157;
            v118 = v120;
          }
          while ( v120 != v157 );
        }
        operator delete(v119);
        v121 = *(char **)v151;
        *(_DWORD *)v151 = v151;
        *((_DWORD *)v151 + 1) = v151;
        v122 = v151;
        v152 = 0;
        if ( v121 != v151 )
        {
          do
          {
            v123 = *(char **)v121;
            operator delete(v121);
            v122 = v151;
            v121 = v123;
          }
          while ( v123 != v151 );
        }
        operator delete(v122);
        v124 = *(char **)v155;
        *(_DWORD *)v155 = v155;
        *((_DWORD *)v155 + 1) = v155;
        v125 = v155;
        v156 = 0;
        if ( v124 != v155 )
        {
          do
          {
            v126 = *(char **)v124;
            operator delete(v124);
            v125 = v155;
            v124 = v126;
          }
          while ( v126 != v155 );
        }
        operator delete(v125);
        v127 = *(char **)v159;
        *(_DWORD *)v159 = v159;
        *((_DWORD *)v159 + 1) = v159;
        v128 = v159;
        v160 = 0;
        if ( v127 != v159 )
        {
          do
          {
            v129 = *(char **)v127;
            operator delete(v127);
            v128 = v159;
            v127 = v129;
          }
          while ( v129 != v159 );
        }
        operator delete(v128);
        v130 = *(char **)v147;
        *(_DWORD *)v147 = v147;
        *((_DWORD *)v147 + 1) = v147;
        v131 = v147;
        v148 = 0;
        if ( v130 != v147 )
        {
          do
          {
            v132 = *(char **)v130;
            operator delete(v130);
            v131 = v147;
            v130 = v132;
          }
          while ( v132 != v147 );
        }
        operator delete(v131);
        v245 = -1;
        v133 = *(char **)v153;
        *(_DWORD *)v153 = v153;
        *((_DWORD *)v153 + 1) = v153;
        v134 = v153;
        v154 = 0;
        if ( v133 != v153 )
        {
          do
          {
            v135 = *(char **)v133;
            operator delete(v133);
            v134 = v153;
            v133 = v135;
          }
          while ( v135 != v153 );
        }
        operator delete(v134);
      }
      while ( !v114 );
    }
    RegCloseKey(phkResult);
  }
  return v161;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C9098: using guessed type wchar_t aD_9[3];
// 4C947C: using guessed type wchar_t aD_10[3];
// 4E5E80: using guessed type int dword_4E5E80[];
// 4E5E84: using guessed type int dword_4E5E84[];
// 4E60E4: using guessed type int dword_4E60E4[];
// 4E60E8: using guessed type int dword_4E60E8[];
// 4E6110: using guessed type int dword_4E6110[];
// 4E6114: using guessed type int dword_4E6114[];
// 4E6158: using guessed type int dword_4E6158[];
// 4E615C: using guessed type int dword_4E615C[];
// 4E61A0: using guessed type int dword_4E61A0[];
// 4E61A4: using guessed type int dword_4E61A4[];
// 4E61E8: using guessed type int dword_4E61E8[];
// 4E61EC: using guessed type int dword_4E61EC[];
// 4E6218: using guessed type int dword_4E6218[];
// 4E621C: using guessed type int dword_4E621C[];
// 489DD0: using guessed type BYTE Data[4];
// 489DD0: using guessed type BYTE var_780[4];
// 489DD0: using guessed type BYTE var_77C[4];
// 489DD0: using guessed type BYTE var_76C[4];
// 489DD0: using guessed type BYTE var_768[4];
// 489DD0: using guessed type BYTE var_778[4];
// 489DD0: using guessed type BYTE var_774[4];
// 489DD0: using guessed type BYTE var_770[4];
// 489DD0: using guessed type BYTE var_32C[4];

//----- (0048B300) --------------------------------------------------------
int __thiscall sub_48B300(int *this)
{
  return sub_489DD0(this[2]);
}

//----- (0048B360) --------------------------------------------------------
LRESULT __usercall sub_48B360@<eax>(HWND a1@<edi>)
{
  HWND DlgItem; // esi
  DWORD MessagePos; // eax
  LONG v3; // ebx
  LRESULT result; // eax
  HMODULE ModuleHandleW; // eax
  HMENU MenuW; // esi
  int y; // [esp+Ch] [ebp-1Ch]
  struct tagPOINT Point; // [esp+10h] [ebp-18h] BYREF
  char v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  DlgItem = GetDlgItem(a1, 1114);
  MessagePos = GetMessagePos();
  v3 = (__int16)MessagePos;
  MessagePos >>= 16;
  y = (__int16)MessagePos;
  Point.y = (__int16)MessagePos;
  Point.x = v3;
  ScreenToClient(DlgItem, &Point);
  result = SendMessageW(DlgItem, 0x1012u, 0, (LPARAM)&Point);
  if ( (v9 & 1) == 0 && v10 != -1 )
  {
    ModuleHandleW = GetModuleHandleW(0);
    MenuW = LoadMenuW(ModuleHandleW, (LPCWSTR)0xD4);
    hMenu = GetSubMenu(MenuW, 0);
    dword_4EF3C8 = v10;
    TrackPopupMenu(hMenu, 0, v3, y, 0, a1, 0);
    return DestroyMenu(MenuW);
  }
  return result;
}
// 4EF3C8: using guessed type int dword_4EF3C8;

//----- (0048B420) --------------------------------------------------------
LRESULT __userpurge sub_48B420@<eax>(HWND a1@<eax>, int a2)
{
  HWND DlgItem; // edi
  LPARAM v3; // eax
  LRESULT result; // eax
  LPARAM v5; // esi
  LPARAM lParam[10]; // [esp+10h] [ebp-28h] BYREF

  DlgItem = GetDlgItem(a1, 1175);
  v3 = SendMessageW(DlgItem, 0x110Au, 9u, 0);
  result = SendMessageW(DlgItem, 0x110Au, 4u, v3);
  v5 = result;
  if ( result )
  {
    while ( 1 )
    {
      lParam[0] = 4;
      lParam[1] = v5;
      SendMessageW(DlgItem, 0x113Eu, 0, (LPARAM)lParam);
      if ( lParam[9] == a2 )
        break;
      result = SendMessageW(DlgItem, 0x110Au, 1u, v5);
      v5 = result;
      if ( !result )
        return result;
    }
    return SendMessageW(DlgItem, 0x110Bu, 9u, v5);
  }
  return result;
}

//----- (0048B4B0) --------------------------------------------------------
int __stdcall sub_48B4B0(int a1, HWND hDlg, int a3)
{
  HWND DlgItem; // esi
  int result; // eax
  int v5; // ebx
  LPARAM lParam[13]; // [esp+4h] [ebp-1068h] BYREF
  HWND v7; // [esp+38h] [ebp-1034h]
  int v8; // [esp+3Ch] [ebp-1030h]
  int v9[517]; // [esp+40h] [ebp-102Ch] BYREF
  int v10[385]; // [esp+854h] [ebp-818h] BYREF
  WPARAM wParam; // [esp+E58h] [ebp-214h]
  char v12[520]; // [esp+E5Ch] [ebp-210h] BYREF
  int v13; // [esp+1064h] [ebp-8h]

  v8 = a1;
  v7 = hDlg;
  DlgItem = GetDlgItem(hDlg, 1114);
  result = dword_4EF3C8;
  if ( dword_4EF3C8 != -1 )
  {
    lParam[0] = 4;
    lParam[1] = dword_4EF3C8;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
    sub_465D30(lParam[8], v10);
    result = wParam;
    if ( wParam )
    {
      if ( wParam == 1 )
      {
        if ( a3 )
          sub_48FFD0((int)v12, v8, wParam, wParam, 1);
        else
          sub_490020((int)v12, v8, 1);
        return EndDialog(v7, 1);
      }
    }
    else
    {
      SendMessageW(DlgItem, 0x1009u, 0, 0);
      result = v13;
      if ( !*(_DWORD *)(v13 + 1540) )
      {
        v5 = *(_DWORD *)(v13 + 2076);
        if ( v5 )
        {
          sub_465D30(v5, v9);
          return sub_4A6960(v9, DlgItem);
        }
      }
    }
  }
  return result;
}
// 4EF3C8: using guessed type int dword_4EF3C8;
// 48B4B0: using guessed type int var_818[385];
// 48B4B0: using guessed type _DWORD var_102C[517];

//----- (0048B5E0) --------------------------------------------------------
HWND __thiscall sub_48B5E0(HWND *this, HWND hDlg)
{
  HWND result; // eax
  int v4; // ecx
  int v5; // eax
  LPARAM lParam[13]; // [esp+10h] [ebp-854h] BYREF
  int v7[384]; // [esp+44h] [ebp-820h] BYREF
  BOOL v8; // [esp+644h] [ebp-220h]
  int v9; // [esp+854h] [ebp-10h]

  result = GetDlgItem(hDlg, 1114);
  if ( dword_4EF3C8 != -1 )
  {
    lParam[1] = dword_4EF3C8;
    lParam[0] = 4;
    lParam[2] = 0;
    result = (HWND)SendMessageW(result, 0x104Bu, 0, (LPARAM)lParam);
    if ( result )
    {
      sub_465D30(lParam[8], v7);
      v8 = !v8;
      if ( v8 )
      {
        v5 = sub_4A6570(v4, (int)this);
        sub_4A6700((int)v7, (int)this, v5);
      }
      else
      {
        sub_4A6420(this, v9);
      }
      return (HWND)sub_465C50(v7, v9);
    }
  }
  return result;
}
// 48B671: variable 'v4' is possibly undefined
// 4EF3C8: using guessed type int dword_4EF3C8;
// 48B5E0: using guessed type _DWORD var_820[384];

//----- (0048B6B0) --------------------------------------------------------
HWND __stdcall sub_48B6B0(int a1, HWND hWnd)
{
  HWND result; // eax
  LPARAM lParam[13]; // [esp+0h] [ebp-84Ch] BYREF
  _DWORD v4[517]; // [esp+34h] [ebp-818h] BYREF

  result = hWnd;
  if ( dword_4EF3C8 != -1 )
  {
    lParam[1] = dword_4EF3C8;
    lParam[0] = 4;
    lParam[2] = 0;
    result = (HWND)SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam);
    if ( result )
    {
      sub_465D30(lParam[8], v4);
      if ( v4[384] )
        return (HWND)CheckMenuItem(hMenu, 0x9D88u, 8u);
      else
        return (HWND)CheckMenuItem(hMenu, 0x9D88u, 0);
    }
  }
  return result;
}
// 4EF3C8: using guessed type int dword_4EF3C8;

//----- (0048B760) --------------------------------------------------------
HWND __thiscall sub_48B760(HWND hDlg, int a2)
{
  HWND DlgItem; // edi
  HWND result; // eax
  HWND *v5; // edi
  WPARAM v6; // edi
  HWND v7; // ebx
  LPARAM v8[13]; // [esp+Ch] [ebp-898h] BYREF
  LPARAM lParam[8]; // [esp+40h] [ebp-864h] BYREF
  void *v10; // [esp+60h] [ebp-844h]
  WPARAM wParam; // [esp+74h] [ebp-830h]
  HWND hWnd; // [esp+78h] [ebp-82Ch]
  LRESULT v13; // [esp+7Ch] [ebp-828h]
  HWND *v14; // [esp+80h] [ebp-824h]
  _DWORD v15[519]; // [esp+84h] [ebp-820h] BYREF

  v14 = (HWND *)a2;
  DlgItem = GetDlgItem(hDlg, 1114);
  hWnd = DlgItem;
  v13 = SendMessageW(DlgItem, 0x1004u, 0, 0);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  wParam = (WPARAM)result;
  if ( result != HWND_MESSAGE|0x2 )
  {
    lParam[0] = 4;
    lParam[1] = (LPARAM)result;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
    sub_465D30((int)v10, v15);
    v5 = v14;
    result = (HWND)sub_4A63A0(v10, hDlg);
    if ( result )
    {
      if ( v15[384] )
        sub_4A6420(v5, v15[516]);
      v6 = wParam;
      v7 = hWnd;
      dword_4EF4B0 = 1;
      SendMessageW(hWnd, 0x1008u, wParam, 0);
      sub_4A6FC0((HMENU *)v14);
      if ( v6 == v13 - 1 )
        --v6;
      v8[4] = 2;
      v8[3] = 2;
      SendMessageW(v7, 0x102Bu, v6, (LPARAM)v8);
      return SetFocus(v7);
    }
  }
  return result;
}
// 4EF4B0: using guessed type int dword_4EF4B0;

//----- (0048B8B0) --------------------------------------------------------
int __fastcall sub_48B8B0(HWND a1, int a2)
{
  HWND DlgItem; // esi
  int result; // eax
  int v6[517]; // [esp+Ch] [ebp-102Ch] BYREF
  int v7[516]; // [esp+820h] [ebp-818h] BYREF
  int v8; // [esp+1030h] [ebp-8h]

  GetDlgItem(a1, 1175);
  DlgItem = GetDlgItem(a1, 1114);
  SendMessageW(DlgItem, 0x1009u, 0, 0);
  sub_465D30(*(_DWORD *)(a2 + 92), v7);
  result = v8;
  if ( !*(_DWORD *)(v8 + 1540) )
  {
    result = *(_DWORD *)(v8 + 2076);
    if ( result )
    {
      sub_465D30(result, v6);
      return sub_4A6960(v6, DlgItem);
    }
  }
  return result;
}
// 48B8B0: using guessed type int var_818[516];
// 48B8B0: using guessed type _DWORD var_102C[517];

//----- (0048B940) --------------------------------------------------------
WPARAM __thiscall sub_48B940(_DWORD *this, int a2, HWND hDlg)
{
  HWND DlgItem; // esi
  WPARAM result; // eax
  int v6; // eax
  int v7; // ebx
  LPARAM lParam[13]; // [esp+Ch] [ebp-1074h] BYREF
  int v9; // [esp+40h] [ebp-1040h]
  HWND v10; // [esp+44h] [ebp-103Ch]
  int v11[385]; // [esp+48h] [ebp-1038h] BYREF
  WPARAM wParam; // [esp+64Ch] [ebp-A34h]
  char v13[520]; // [esp+650h] [ebp-A30h] BYREF
  int v14; // [esp+858h] [ebp-828h]
  int v15[519]; // [esp+860h] [ebp-820h] BYREF

  v9 = a2;
  v10 = hDlg;
  DlgItem = GetDlgItem(hDlg, 1114);
  result = this[3];
  if ( result != -1 )
  {
    lParam[0] = 4;
    lParam[1] = result;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
    sub_465D30(lParam[8], v11);
    result = wParam;
    if ( wParam )
    {
      if ( wParam == 1 )
      {
        sub_490020((int)v13, v9, 1);
        return EndDialog(v10, 1);
      }
    }
    else
    {
      SendMessageW(DlgItem, 0x1009u, 0, 0);
      v6 = v14;
      if ( !*(_DWORD *)(v14 + 1540) )
      {
        v7 = *(_DWORD *)(v14 + 2076);
        if ( v7 )
        {
          sub_465D30(v7, v15);
          sub_4A6960(v15, DlgItem);
          v6 = v14;
        }
      }
      return sub_48B420(v10, v6);
    }
  }
  return result;
}
// 48B940: using guessed type int var_1038[385];
// 48B940: using guessed type _DWORD var_820[519];
// 48B940: using guessed type char var_A30[520];

//----- (0048BA70) --------------------------------------------------------
BOOL __usercall sub_48BA70@<eax>(int a1@<ecx>, HWND a2@<edi>)
{
  LONG top; // edx
  struct tagRECT Rect; // [esp+4h] [ebp-14h] BYREF

  sub_4A6FC0((HMENU *)a1);
  GetWindowRect(a2, &Rect);
  top = Rect.top;
  *(_DWORD *)(a1 + 61208) = Rect.left;
  *(_DWORD *)(a1 + 61212) = top;
  *(_DWORD *)(a1 + 61204) = 1;
  return EndDialog(a2, 1);
}

//----- (0048BAD0) --------------------------------------------------------
_WORD *__stdcall sub_48BAD0(HWND hDlg, int a2)
{
  HWND DlgItem; // edi
  _WORD *result; // eax
  _WORD *v4; // esi
  LPARAM lParam; // [esp+Ch] [ebp-1074h] BYREF
  _WORD *v6; // [esp+10h] [ebp-1070h]
  int v7; // [esp+14h] [ebp-106Ch]
  int v8; // [esp+2Ch] [ebp-1054h]
  _WORD *v9; // [esp+40h] [ebp-1040h]
  HWND hWnd; // [esp+44h] [ebp-103Ch]
  int v11[518]; // [esp+48h] [ebp-1038h] BYREF
  int v12[519]; // [esp+860h] [ebp-820h] BYREF

  DlgItem = GetDlgItem(hDlg, 1114);
  hWnd = DlgItem;
  result = (_WORD *)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  v4 = result;
  if ( result != (_WORD *)-1 )
  {
    lParam = 4;
    v6 = result;
    v7 = 0;
    SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)&lParam);
    result = sub_465D30(v8, v12);
    if ( a2 )
    {
      if ( !v4 )
        return result;
      v9 = (_WORD *)((char *)v4 - 1);
    }
    else
    {
      result = (_WORD *)(SendMessageW(hWnd, 0x1004u, 0, 0) - 1);
      if ( v4 == result )
        return result;
      v9 = (_WORD *)((char *)v4 + 1);
    }
    lParam = 4;
    v6 = v9;
    v7 = 0;
    SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)&lParam);
    sub_465D30(v8, v11);
    sub_465940((int)v12, (int)v11, (int)v12);
    return (_WORD *)sub_468800(hWnd, (int)v4, (int)v9);
  }
  return result;
}
// 48BAD0: using guessed type _DWORD var_820[519];
// 48BAD0: using guessed type _DWORD var_1038[518];

//----- (0048BC20) --------------------------------------------------------
LRESULT __stdcall sub_48BC20(HWND hDlg, WPARAM wParam)
{
  HWND DlgItem; // esi
  LPARAM lParam[13]; // [esp+Ch] [ebp-880h] BYREF
  LPARAM v5[2]; // [esp+40h] [ebp-84Ch] BYREF
  int v6; // [esp+48h] [ebp-844h]
  char *v7; // [esp+54h] [ebp-838h]
  int v8[128]; // [esp+74h] [ebp-818h] BYREF
  char v9; // [esp+274h] [ebp-618h] BYREF
  int v10; // [esp+678h] [ebp-214h]
  char v11; // [esp+67Ch] [ebp-210h] BYREF

  DlgItem = GetDlgItem(hDlg, 1114);
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  SendMessageW(DlgItem, 0x104Bu, 0, (LPARAM)lParam);
  sub_465D30(lParam[8], v8);
  v6 = 0;
  v7 = (char *)v8;
  SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v5);
  if ( v10 == 1 )
  {
    v6 = 1;
    v7 = &v11;
    SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v5);
  }
  v6 = 2;
  v7 = &v9;
  return SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v5);
}
// 48BC20: using guessed type _DWORD var_818[128];

//----- (0048BD20) --------------------------------------------------------
HWND __userpurge sub_48BD20@<eax>(LPARAM a1@<esi>, int a2, HWND hWnd, WPARAM wParam)
{
  INT_PTR v4; // eax
  LPARAM dwInitParam[2]; // [esp+10h] [ebp-860h] BYREF
  HWND v7; // [esp+18h] [ebp-858h]
  LPARAM lParam[8]; // [esp+1Ch] [ebp-854h] BYREF
  int v9; // [esp+3Ch] [ebp-834h]
  _DWORD v10[519]; // [esp+50h] [ebp-820h] BYREF

  v7 = hWnd;
  lParam[0] = 4;
  lParam[1] = wParam;
  lParam[2] = 0;
  SendMessageW(hWnd, 0x104Bu, 0, (LPARAM)lParam);
  sub_465D30(v9, v10);
  dwInitParam[0] = a1;
  dwInitParam[1] = v9;
  if ( v10[385] )
    v4 = sub_401090((LPCWSTR)0xB6, (HWND)a2, (DLGPROC)sub_4B0E20, (LPARAM)dwInitParam);
  else
    v4 = sub_401090((LPCWSTR)0xD4, (HWND)a2, (DLGPROC)sub_4B0C50, (LPARAM)dwInitParam);
  if ( v4 == 1 )
  {
    sub_48BC20((HWND)a2, wParam);
    dword_4EF4B0 = 1;
  }
  return SetFocus(v7);
}
// 4EF4B0: using guessed type int dword_4EF4B0;

//----- (0048BE10) --------------------------------------------------------
HWND __userpurge sub_48BE10@<eax>(HWND a1@<edi>, LPARAM a2)
{
  HWND DlgItem; // esi
  HWND result; // eax

  DlgItem = GetDlgItem(a1, 1114);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  if ( result != HWND_MESSAGE|0x2 )
    return sub_48BD20(a2, (int)a1, DlgItem, (WPARAM)result);
  return result;
}

//----- (0048BE50) --------------------------------------------------------
BOOL __thiscall sub_48BE50(HWND hDlg, int a2)
{
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  LPARAM v5; // eax
  LPARAM v6; // eax
  HWND hWnd; // [esp+14h] [ebp-8C4h]
  int v10; // [esp+1Ch] [ebp-8BCh]
  HWND DlgItem; // [esp+20h] [ebp-8B8h]
  LPARAM lParam[3]; // [esp+24h] [ebp-8B4h] BYREF
  WCHAR *v13; // [esp+30h] [ebp-8A8h]
  LPARAM v14[3]; // [esp+44h] [ebp-894h] BYREF
  int v15; // [esp+50h] [ebp-888h]
  int v16; // [esp+54h] [ebp-884h]
  int v17[518]; // [esp+78h] [ebp-860h] BYREF
  WCHAR Buffer[34]; // [esp+890h] [ebp-48h] BYREF

  DlgItem = GetDlgItem(hDlg, 1114);
  SendMessageW(DlgItem, 0x1036u, 0x20u, 32);
  SendMessageW(DlgItem, 0x1036u, 0x4000u, 0x4000);
  LoadStringW(hInstance, 0x200Cu, Buffer, 32);
  lParam[0] = 4;
  v13 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0, (LPARAM)lParam);
  LoadStringW(hInstance, 0x200Du, Buffer, 32);
  lParam[0] = 4;
  v13 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1u, (LPARAM)lParam);
  LoadStringW(hInstance, 0x200Eu, Buffer, 32);
  lParam[0] = 4;
  v13 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2u, (LPARAM)lParam);
  hWnd = GetDlgItem(hDlg, 1175);
  v10 = sub_4018B0(16, 16, 33, 0, 1u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v10, (int)BitmapW, 0);
  DeleteObject(BitmapW);
  SendMessageW(hWnd, 0x1109u, 0, v10);
  sub_466000(a2 + 1332, v17);
  sub_4A6A90((void *)a2, hWnd, 0, v17);
  v5 = SendMessageW(hWnd, 0x110Au, 0, 0);
  SendMessageW(hWnd, 0x1102u, 2u, v5);
  SendMessageW(DlgItem, 0x101Eu, 0, 100);
  SendMessageW(DlgItem, 0x101Eu, 1u, 220);
  SendMessageW(DlgItem, 0x101Eu, 2u, 180);
  v6 = SendMessageW(hWnd, 0x110Au, 0, 0);
  SendMessageW(hWnd, 0x110Bu, 9u, v6);
  v16 = 2;
  v15 = 2;
  SendMessageW(DlgItem, 0x102Bu, 0, (LPARAM)v14);
  SetFocus(DlgItem);
  v16 = 1;
  v15 = 1;
  SendMessageW(DlgItem, 0x102Bu, 0, (LPARAM)v14);
  SendMessageW(DlgItem, 0x1003u, 1u, v10);
  if ( *(_DWORD *)(a2 + 61204) )
    return SetWindowPos(hDlg, 0, *(_DWORD *)(a2 + 61208), *(_DWORD *)(a2 + 61212), 0, 0, 5u);
  else
    return sub_4697F0(hDlg, *(HWND *)(a2 + 52));
}
// 48BE50: using guessed type _DWORD var_860[518];

//----- (0048C100) --------------------------------------------------------
int __userpurge sub_48C100@<eax>(HWND hDlg@<ecx>, _DWORD *a2@<edx>, HMENU a3@<ebx>, int a4)
{
  _DWORD *v5; // esi
  int v6; // eax
  int result; // eax
  LONG top; // edx
  HWND DlgItem; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-18h] BYREF

  v5 = (_DWORD *)dword_4EF814;
  if ( (unsigned int)a4 <= 0x110 )
  {
    if ( a4 == 272 )
    {
      sub_48BE50(hDlg, dword_4EF814);
      return 0;
    }
    if ( a4 != 16 )
    {
      if ( a4 == 78 )
      {
        v6 = a2[2];
        switch ( v6 )
        {
          case -451:
            sub_48B8B0(hDlg, (int)a2);
            return 0;
          case -5:
            sub_48B360(hDlg);
            return 0;
          case -3:
            sub_48B940(a2, dword_4EF814, hDlg);
            return 0;
        }
      }
      return 0;
    }
    GetWindowRect(hDlg, &Rect);
    top = Rect.top;
    v5[15302] = Rect.left;
    v5[15303] = top;
    v5[15301] = 1;
LABEL_12:
    EndDialog(hDlg, 0);
    return 0;
  }
  if ( a4 != 273 )
  {
    if ( a4 == 278 )
    {
      DlgItem = GetDlgItem(hDlg, 1114);
      if ( a3 == hMenu )
      {
        sub_48B6B0((int)v5, DlgItem);
        return 0;
      }
    }
    return 0;
  }
  if ( (unsigned __int16)a3 <= 0x45Bu )
  {
    if ( (unsigned __int16)a3 == 1115 )
    {
LABEL_33:
      sub_48B760(hDlg, dword_4EF814);
      return 0;
    }
    if ( (unsigned __int16)a3 == 1 )
    {
      sub_48BA70(dword_4EF814, hDlg);
      return 0;
    }
    if ( (unsigned __int16)a3 != 2 )
    {
      if ( (unsigned __int16)a3 == 1054 )
      {
        sub_48BAD0(hDlg, 0);
        return 0;
      }
      return 0;
    }
    goto LABEL_12;
  }
  if ( (unsigned __int16)a3 <= 0x9D77u )
  {
    switch ( (unsigned __int16)a3 )
    {
      case 0x9D77u:
        sub_48B4B0(dword_4EF814, hDlg, 0);
        return 0;
      case 0x45Cu:
LABEL_34:
        sub_48BE10(hDlg, dword_4EF814);
        return 0;
      case 0x45Du:
        sub_48BAD0(hDlg, 1);
        return 0;
    }
    return 0;
  }
  switch ( (unsigned __int16)a3 )
  {
    case 0x9D78u:
      sub_48B4B0(dword_4EF814, hDlg, 1);
      result = 0;
      break;
    case 0x9D7Au:
      goto LABEL_33;
    case 0x9D7Du:
      goto LABEL_34;
    case 0x9D88u:
      sub_48B5E0((HWND *)dword_4EF814, hDlg);
      return 0;
    default:
      return 0;
  }
  return result;
}

//----- (0048C3B0) --------------------------------------------------------
int __stdcall sub_48C3B0(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 272 )
    dword_4EF814 = a4;
  return sub_48C100(hDlg, (_DWORD *)a4, (HMENU)a3, a2);
}

//----- (0048C3E0) --------------------------------------------------------
BOOL __usercall sub_48C3E0@<eax>(HWND a1@<esi>)
{
  HWND DlgItem; // edi
  UINT v2; // eax

  DlgItem = GetDlgItem(a1, 1268);
  v2 = IsDlgButtonChecked(a1, 1003);
  return EnableWindow(DlgItem, v2 == 1);
}

//----- (0048C410) --------------------------------------------------------
BOOL __usercall sub_48C410@<eax>(HWND a1@<eax>)
{
  HWND DlgItem; // ebx
  HWND v3; // edi
  BOOL v4; // esi

  DlgItem = GetDlgItem(a1, 1193);
  v3 = GetDlgItem(a1, 1194);
  v4 = IsDlgButtonChecked(a1, 1195) == 1;
  EnableWindow(DlgItem, v4);
  return EnableWindow(v3, v4);
}

//----- (0048C490) --------------------------------------------------------
LRESULT __usercall sub_48C490@<eax>(HWND a1@<ebx>, const ITEMIDLIST *a2@<esi>)
{
  int v3; // [esp+4h] [ebp-214h] BYREF
  __int16 lParam[262]; // [esp+8h] [ebp-210h] BYREF

  v3 = 0x40000000;
  sub_4665C0(a2, (int)&v3);
  sub_466630(a2, (WCHAR *)lParam, (v3 & 0x40000000) != 0 ? 0x8000 : 1);
  return SendMessageW(a1, 0xCu, 0, (LPARAM)lParam);
}
// 48C490: using guessed type WCHAR lParam[262];

//----- (0048C510) --------------------------------------------------------
int __stdcall sub_48C510(HWND hWnd, int a2, int a3, int a4)
{
  if ( a2 == 1 )
    SendMessageW(hWnd, 0x467u, 1u, (LPARAM)&unk_4EF1C0);
  return 0;
}

//----- (0048C540) --------------------------------------------------------
int __stdcall sub_48C540(HWND a1, int a2, int a3)
{
  if ( a2 == 1 )
    dword_4EF4AC = a1;
  return 0;
}

//----- (0048C560) --------------------------------------------------------
__int16 __fastcall sub_48C560(LPCWSTR pszMore, int a2, int a3)
{
  WCHAR *v3; // eax
  __int16 v5; // bx
  int v6; // esi
  int v7; // edx
  WCHAR v8; // cx
  DWORD FileVersionInfoSizeW; // eax
  DWORD v10; // esi
  void *v11; // eax
  void *v12; // edi
  LCID v13; // eax
  int v14; // edx
  WCHAR *v15; // eax
  WCHAR v16; // cx
  HWND v17; // ebx
  WPARAM v18; // eax
  DWORD dwHandle; // [esp+Ch] [ebp-25Ch] BYREF
  unsigned int puLen; // [esp+10h] [ebp-258h] BYREF
  HWND hWnd; // [esp+14h] [ebp-254h]
  LPVOID lpBuffer; // [esp+18h] [ebp-250h] BYREF
  WCHAR pszPath[260]; // [esp+1Ch] [ebp-24Ch] BYREF
  WCHAR LCData[32]; // [esp+224h] [ebp-44h] BYREF

  hWnd = (HWND)a3;
  v3 = pszPath;
  v5 = 0;
  lpBuffer = 0;
  v6 = 260;
  v7 = a2 - (_DWORD)pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v3 + v7);
    if ( !v8 )
      break;
    *v3++ = v8;
    if ( !--v6 )
    {
      --v3;
      break;
    }
  }
  *v3 = 0;
  PathAppendW(pszPath, pszMore);
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszPath, &dwHandle);
  v10 = FileVersionInfoSizeW;
  if ( FileVersionInfoSizeW )
  {
    v11 = malloc(FileVersionInfoSizeW);
    v12 = v11;
    if ( v11 )
    {
      GetFileVersionInfoW(pszPath, 0, v10, v11);
      VerQueryValueW(v12, L"\\VarFileInfo\\Translation", &lpBuffer, &puLen);
      if ( puLen >= 4 )
      {
        v13 = *(unsigned __int16 *)lpBuffer;
        if ( (_WORD)v13 == 1115 )
        {
          v14 = 32;
          v15 = LCData;
          while ( v14 != -2147483614 )
          {
            v16 = *(WCHAR *)((char *)v15 + (char *)L"Sinhala" - (char *)LCData);
            if ( !v16 )
              break;
            *v15++ = v16;
            if ( !--v14 )
            {
              *(v15 - 1) = 0;
              goto LABEL_17;
            }
          }
          *v15 = 0;
        }
        else
        {
          GetLocaleInfoW(v13, 4u, LCData, 32);
        }
LABEL_17:
        v17 = hWnd;
        v18 = SendMessageW(hWnd, 0x143u, 0, (LPARAM)LCData);
        if ( v18 != -1 )
          SendMessageW(v17, 0x151u, v18, *(_WORD *)lpBuffer & 0x3FF);
        v5 = *(_WORD *)lpBuffer & 0x3FF;
      }
      free(v12);
    }
  }
  return v5;
}
// 48C5C0: conditional instruction was optimized away because esi.4!=0
// 48C68B: conditional instruction was optimized away because edx.4!=0
// 4CA478: using guessed type wchar_t aSinhala[8];

//----- (0048C710) --------------------------------------------------------
LRESULT __stdcall sub_48C710(int a1, HWND hDlg)
{
  HWND DlgItem; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v4; // eax
  void *v5; // esi
  WCHAR *v6; // eax
  int v7; // edx
  WCHAR v8; // cx
  HANDLE FirstFileW; // ebx
  int i; // esi
  WPARAM wParam; // [esp+14h] [ebp-66Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-668h] BYREF
  WCHAR FileName[260]; // [esp+268h] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+470h] [ebp-210h] BYREF

  wParam = 0;
  DlgItem = GetDlgItem(hDlg, 1162);
  SendMessageW(DlgItem, 0x143u, 0, (LPARAM)L"English");
  SendMessageW(DlgItem, 0x151u, 0, 9);
  CurrentProcessId = GetCurrentProcessId();
  v4 = OpenProcess(0x410u, 0, CurrentProcessId);
  v5 = v4;
  if ( v4 )
  {
    GetModuleFileNameExW(v4, 0, pszPath, 260);
    CloseHandle(v5);
  }
  PathRemoveFileSpecW(pszPath);
  v6 = FileName;
  v7 = 260;
  while ( v7 != -2147483386 )
  {
    v8 = v6[260];
    if ( !v8 )
      break;
    *v6++ = v8;
    if ( !--v7 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  PathAppendW(FileName, L"Explorer++??.dll");
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW != (HANDLE)-1 )
  {
    if ( (unsigned __int16)sub_48C560(FindFileData.cFileName, (int)pszPath, (int)DlgItem) == *(_DWORD *)(a1 + 5572) )
      wParam = 1;
    for ( i = 2; FindNextFileW(FirstFileW, &FindFileData); ++i )
    {
      if ( (unsigned __int16)sub_48C560(FindFileData.cFileName, (int)pszPath, (int)DlgItem) == *(_DWORD *)(a1 + 5572) )
        wParam = i;
    }
    FindClose(FirstFileW);
  }
  return SendMessageW(DlgItem, 0x14Eu, wParam, 0);
}
// 48C7E3: conditional instruction was optimized away because edx.4!=0
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4CA410: using guessed type wchar_t aEnglish[8];

//----- (0048C910) --------------------------------------------------------
void __usercall sub_48C910(HWND a1@<edi>)
{
  bool v1; // sf
  int v2; // edx
  _WORD *v3; // eax
  __int16 v4; // cx
  __int16 v5; // cx
  ITEMIDLIST *v6; // esi
  HWND DlgItem; // eax
  struct _browseinfoW bi; // [esp+8h] [ebp-840h] BYREF
  char v9; // [esp+28h] [ebp-820h] BYREF
  __int16 v10[260]; // [esp+230h] [ebp-618h] BYREF
  WCHAR Buffer[256]; // [esp+438h] [ebp-410h] BYREF
  WCHAR String[262]; // [esp+638h] [ebp-210h] BYREF

  LoadStringW(hInstance, 0x2012u, Buffer, 256);
  GetDlgItemTextW(a1, 1188, String, 260);
  v1 = sub_466900(String, (WCHAR *)v10) < 0;
  v2 = 260;
  v3 = &unk_4EF1C0;
  if ( v1 )
  {
    while ( v2 != -2147483386 )
    {
      v5 = *(_WORD *)((char *)v3 + (char *)String - (char *)&unk_4EF1C0);
      if ( !v5 )
        break;
      *v3++ = v5;
      if ( !--v2 )
      {
LABEL_11:
        --v3;
        break;
      }
    }
  }
  else
  {
    while ( v2 != -2147483386 )
    {
      v4 = *(_WORD *)((char *)v3 + (char *)v10 - (char *)&unk_4EF1C0);
      if ( !v4 )
        break;
      *v3++ = v4;
      if ( !--v2 )
        goto LABEL_11;
    }
  }
  *v3 = 0;
  CoInitializeEx(0, 2u);
  bi.hwndOwner = a1;
  bi.pidlRoot = 0;
  bi.pszDisplayName = (LPWSTR)&v9;
  bi.lpszTitle = Buffer;
  bi.ulFlags = 64;
  bi.lpfn = (BFFCALLBACK)sub_48C510;
  v6 = SHBrowseForFolderW(&bi);
  CoUninitialize();
  if ( v6 )
  {
    DlgItem = GetDlgItem(a1, 1188);
    sub_48C490(DlgItem, v6);
    CoTaskMemFree(v6);
  }
}
// 48C9D0: conditional instruction was optimized away because edx.4!=0
// 48C910: using guessed type WCHAR var_618[260];

//----- (0048CA70) --------------------------------------------------------
int __userpurge sub_48CA70@<eax>(unsigned int a1@<eax>, HWND a2@<esi>, unsigned __int16 a3, int a4)
{
  _DWORD *v4; // ebx
  UINT v5; // eax
  int v6; // ecx
  HWND v7; // edi
  HWND DlgItem; // eax
  bool v10; // zf

  v4 = (_DWORD *)dword_4F0C34;
  if ( a1 <= 0x110 )
  {
    if ( a1 != 272 )
    {
      if ( a1 == 16 )
      {
        EndDialog(a2, 0);
        return 0;
      }
      if ( a1 == 78 && *(_DWORD *)(a4 + 8) == -202 )
      {
        v4[14859] = IsDlgButtonChecked(a2, 1278) == 1;
        v4[14849] = IsDlgButtonChecked(a2, 1138) == 1;
        v4[14837] = IsDlgButtonChecked(a2, 1042) == 1;
        v4[14836] = IsDlgButtonChecked(a2, 1137) == 1;
        v4[14832] = IsDlgButtonChecked(a2, 1006) == 1;
        v4[14850] = IsDlgButtonChecked(a2, 1218) == 1;
        v5 = IsDlgButtonChecked(a2, 1268);
        v6 = v4[14849];
        v7 = (HWND)v4[17];
        v4[14856] = v5 == 1;
        sub_468320(1024, v7, v6);
        sub_48F9F0((int)v4);
        return 0;
      }
      return 0;
    }
    if ( *(_DWORD *)(dword_4F0C34 + 5576) != 6 || !*(_DWORD *)(dword_4F0C34 + 5580) )
    {
      DlgItem = GetDlgItem(a2, 1278);
      EnableWindow(DlgItem, 0);
      v10 = v4[14859] == 0;
      if ( !v4[14859] )
        goto LABEL_13;
      v4[14859] = 0;
    }
    v10 = v4[14859] == 0;
LABEL_13:
    if ( !v10 )
      CheckDlgButton(a2, 1278, 1u);
    if ( v4[14849] )
      CheckDlgButton(a2, 1138, 1u);
    if ( v4[14837] )
      CheckDlgButton(a2, 1042, 1u);
    if ( v4[14836] )
      CheckDlgButton(a2, 1137, 1u);
    if ( v4[14832] )
      CheckDlgButton(a2, 1006, 1u);
    if ( v4[14850] )
      CheckDlgButton(a2, 1218, 1u);
    if ( v4[14856] )
    {
      CheckDlgButton(a2, 1268, 1u);
      return 0;
    }
    return 0;
  }
  if ( a1 == 273 )
  {
    if ( a3 > 0x4C2u )
    {
      if ( a3 != 1268 && a3 != 1278 )
        return 0;
    }
    else if ( a3 != 1218 )
    {
      switch ( a3 )
      {
        case 0x3EEu:
        case 0x412u:
        case 0x471u:
        case 0x472u:
          goto LABEL_33;
        default:
          return 0;
      }
      return 0;
    }
LABEL_33:
    SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
  }
  return 0;
}
// 4F0C34: using guessed type int dword_4F0C34;

//----- (0048CD30) --------------------------------------------------------
int __stdcall sub_48CD30(HWND a1, unsigned int a2, unsigned __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4F0C34 = *(_DWORD *)(a4 + 28);
  return sub_48CA70(a2, a1, a3, a4);
}
// 4F0C34: using guessed type int dword_4F0C34;

//----- (0048CD60) --------------------------------------------------------
int __userpurge sub_48CD60@<eax>(unsigned int a1@<eax>, HWND a2@<edx>, unsigned int a3@<ecx>, WPARAM wParam)
{
  _DWORD *v4; // ebx
  void (__stdcall *v6)(HWND, UINT, WPARAM, LPARAM); // edi
  HWND v7; // esi
  WPARAM v8; // eax
  LRESULT v9; // eax
  WPARAM v10; // esi
  int result; // eax
  HWND v12; // eax
  HWND v13; // eax
  unsigned int v14; // edi
  BOOL v15; // ebx
  HWND v16; // ebx
  UINT v17; // eax
  int v18; // edi
  HWND DlgItem; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // [esp-10h] [ebp-3Ch]
  HWND v23; // [esp-10h] [ebp-3Ch]
  int v24; // [esp-4h] [ebp-30h]
  int v25; // [esp-4h] [ebp-30h]
  BOOL v26; // [esp-4h] [ebp-30h]
  BOOL v27; // [esp-4h] [ebp-30h]
  BOOL v28; // [esp-4h] [ebp-30h]
  int lParam[6]; // [esp+Ch] [ebp-20h] BYREF
  int v30; // [esp+24h] [ebp-8h]
  HWND hWnd; // [esp+28h] [ebp-4h]
  signed int wParama; // [esp+34h] [ebp+8h]
  WPARAM wParamb; // [esp+34h] [ebp+8h]
  HWND wParamc; // [esp+34h] [ebp+8h]

  v4 = (_DWORD *)dword_4F0C38;
  if ( a1 > 0x110 )
  {
    if ( a1 != 273 )
      return 0;
    if ( HIWORD(a3) )
    {
      if ( HIWORD(a3) == 1 )
      {
        SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
        return 0;
      }
      return 0;
    }
    v18 = (unsigned __int16)a3;
    if ( (unsigned __int16)a3 > 0x4F4u )
    {
      if ( (unsigned __int16)a3 != 1275 && (unsigned __int16)a3 != 1280 && (unsigned __int16)a3 != 1302 )
        return 0;
    }
    else if ( (unsigned __int16)a3 != 1268 )
    {
      switch ( (__int16)a3 )
      {
        case 1002:
        case 1081:
        case 1218:
        case 1221:
        case 1240:
        case 1241:
          goto LABEL_62;
        case 1003:
          sub_48C3E0(a2);
          SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
          result = 0;
          break;
        case 1108:
          v26 = IsDlgButtonChecked(a2, (unsigned __int16)a3) == 1;
          DlgItem = GetDlgItem(a2, 1276);
          EnableWindow(DlgItem, v26);
          SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
          result = 0;
          break;
        case 1193:
        case 1194:
          if ( IsDlgButtonChecked(a2, (unsigned __int16)a3) != 1 )
            return 0;
          SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
          result = 0;
          break;
        case 1195:
          sub_48C410(a2);
          goto LABEL_62;
        case 1242:
          v27 = IsDlgButtonChecked(a2, (unsigned __int16)a3) == 1;
          v20 = GetDlgItem(a2, 1302);
          EnableWindow(v20, v27);
          v28 = IsDlgButtonChecked(a2, v18) == 1;
          v21 = GetDlgItem(a2, 1303);
          EnableWindow(v21, v28);
          SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
LABEL_62:
    SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
    return 0;
  }
  if ( a1 != 272 )
  {
    if ( a1 == 16 )
    {
      EndDialog(a2, 0);
      return 0;
    }
    if ( a1 == 78 && *(_DWORD *)(wParam + 8) == -202 )
    {
      v4[14877] = IsDlgButtonChecked(a2, 1241) == 1;
      v4[14871] = IsDlgButtonChecked(a2, 1002) != 1;
      v4[14878] = IsDlgButtonChecked(a2, 1240) == 1;
      v4[14852] = IsDlgButtonChecked(a2, 1221) == 1;
      v4[14846] = IsDlgButtonChecked(a2, 1242) == 1;
      v4[14847] = GetDlgItemInt(a2, 1302, 0, 0);
      v4[14853] = IsDlgButtonChecked(a2, 1275) == 1;
      v4[14863] = IsDlgButtonChecked(a2, 1280) == 1;
      v4[14833] = IsDlgButtonChecked(a2, 1003) == 1;
      v4[14834] = IsDlgButtonChecked(a2, 1268) == 1;
      v4[14855] = IsDlgButtonChecked(a2, 1108) == 1;
      v4[14851] = IsDlgButtonChecked(a2, 1218) == 1;
      v4[14875] = IsDlgButtonChecked(a2, 1081) == 1;
      v4[14867] = IsDlgButtonChecked(a2, 1195) == 1;
      v4[14868] = IsDlgButtonChecked(a2, 1193) != 1;
      v6 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
      v7 = GetDlgItem(a2, 1276);
      v8 = SendMessageW(v7, 0x147u, 0, 0);
      v9 = SendMessageW(v7, 0x150u, v8, 0);
      v22 = (HWND)v4[17];
      v4[14864] = v9;
      v10 = 0;
      wParama = SendMessageW(v22, 0x1304u, 0, 0);
      if ( wParama > 0 )
      {
        while ( 1 )
        {
          v23 = (HWND)v4[17];
          lParam[0] = 8;
          v6(v23, 0x133Cu, v10, (LPARAM)lParam);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 340))(v4[v30 + 229], v4[14877]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 348))(v4[v30 + 229], v4[14871]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 356))(v4[v30 + 229], v4[14878]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 364))(v4[v30 + 229], v4[14833]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 372))(v4[v30 + 229], v4[14834]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 376))(v4[v30 + 229], v4[14875]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 384))(v4[v30 + 229], v4[14852]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 392))(v4[v30 + 229], v4[14855]);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)v4[v30 + 229] + 396))(v4[v30 + 229], v4[14864]);
          (*(void (__thiscall **)(_DWORD *, int))(v4[7] + 16))(v4 + 7, v30);
          sub_468000((HWND)v4[v30 + 23], v4[14846], v4[14847]);
          if ( (int)++v10 >= wParama )
            break;
          v6 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
        }
      }
      sub_48F9F0((int)v4);
      return 0;
    }
    return 0;
  }
  if ( *(_DWORD *)(dword_4F0C38 + 59508) )
    CheckDlgButton(a2, 1241, 1u);
  if ( !v4[14871] )
    CheckDlgButton(a2, 1002, 1u);
  if ( v4[14878] )
    CheckDlgButton(a2, 1240, 1u);
  if ( v4[14852] )
    CheckDlgButton(a2, 1221, 1u);
  if ( v4[14846] )
    CheckDlgButton(a2, 1242, 1u);
  SetDlgItemInt(a2, 1302, v4[14847], 0);
  v24 = v4[14846];
  v12 = GetDlgItem(a2, 1302);
  EnableWindow(v12, v24);
  v25 = v4[14846];
  v13 = GetDlgItem(a2, 1303);
  EnableWindow(v13, v25);
  if ( v4[14853] )
    CheckDlgButton(a2, 1275, 1u);
  if ( v4[14863] )
    CheckDlgButton(a2, 1280, 1u);
  if ( v4[14833] )
    CheckDlgButton(a2, 1003, 1u);
  if ( v4[14834] )
    CheckDlgButton(a2, 1268, 1u);
  if ( v4[14855] )
    CheckDlgButton(a2, 1108, 1u);
  if ( v4[14851] )
    CheckDlgButton(a2, 1218, 1u);
  if ( v4[14875] )
    CheckDlgButton(a2, 1081, 1u);
  if ( v4[14867] )
    CheckDlgButton(a2, 1195, 1u);
  if ( v4[14868] )
    CheckDlgButton(a2, 1194, 1u);
  else
    CheckDlgButton(a2, 1193, 1u);
  v14 = 0;
  hWnd = GetDlgItem(a2, 1276);
  wParamb = 0;
  do
  {
    SendMessageW(hWnd, 0x143u, 0, (LPARAM)&aBytes_0[v14 / 2]);
    SendMessageW(hWnd, 0x151u, wParamb, dword_4C9F88[v14 / 4]);
    if ( dword_4C9F88[v14 / 4] == v4[14864] )
      SendMessageW(hWnd, 0x14Eu, wParamb, 0);
    ++wParamb;
    v14 += 132;
  }
  while ( v14 < 0x318 );
  EnableWindow(hWnd, v4[14855]);
  wParamc = GetDlgItem(a2, 1193);
  hWnd = GetDlgItem(a2, 1194);
  v15 = IsDlgButtonChecked(a2, 1195) == 1;
  EnableWindow(wParamc, v15);
  EnableWindow(hWnd, v15);
  v16 = GetDlgItem(a2, 1268);
  v17 = IsDlgButtonChecked(a2, 1003);
  EnableWindow(v16, v17 == 1);
  return 0;
}
// 4C9F88: using guessed type int dword_4C9F88[];
// 4C9F8C: using guessed type wchar_t aBytes_0[6];
// 4F0C38: using guessed type int dword_4F0C38;
// 48CD60: using guessed type LPARAM lParam[6];

//----- (0048D5B0) --------------------------------------------------------
int __stdcall sub_48D5B0(HWND a1, unsigned int a2, unsigned int a3, WPARAM a4)
{
  if ( a2 == 272 )
    dword_4F0C38 = *(_DWORD *)(a4 + 28);
  return sub_48CD60(a2, a1, a3, a4);
}
// 4F0C38: using guessed type int dword_4F0C38;

//----- (0048D5E0) --------------------------------------------------------
int __fastcall sub_48D5E0(HWND hDlg, unsigned int a2, int a3, int a4)
{
  HWND v4; // esi
  int v5; // ebx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  HWND v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // ebx
  _WORD *v15; // eax
  __int16 v16; // cx
  __int16 v17; // cx
  HWND v18; // edi
  HWND v19; // eax
  WPARAM v20; // esi
  HWND v21; // eax
  int v22; // eax
  HWND DlgItem; // eax
  int v24; // eax
  HWND v25; // eax
  HWND v27; // [esp-14h] [ebp-64Ch]
  int v28; // [esp+10h] [ebp-628h]
  LPVOID pv; // [esp+14h] [ebp-624h] BYREF
  HWND hDlga; // [esp+18h] [ebp-620h]
  HWND v31; // [esp+1Ch] [ebp-61Ch]
  __int16 lParam[260]; // [esp+20h] [ebp-618h] BYREF
  WCHAR Buffer[256]; // [esp+228h] [ebp-410h] BYREF
  __int16 v34[262]; // [esp+428h] [ebp-210h] BYREF

  v4 = hDlg;
  hDlga = hDlg;
  v28 = dword_4F0C3C;
  if ( (unsigned int)a3 > 0x4E )
  {
    if ( a3 != 272 )
    {
      if ( a3 == 273 )
      {
        if ( HIWORD(a2) )
        {
          if ( HIWORD(a2) == 1 || HIWORD(a2) == 768 )
LABEL_63:
            SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)v4, 0);
        }
        else
        {
          switch ( (__int16)a2 )
          {
            case 1073:
            case 1074:
              if ( IsDlgButtonChecked(hDlg, (unsigned __int16)a2) == 1 )
                goto LABEL_63;
              break;
            case 1176:
            case 1202:
            case 1266:
            case 1267:
              goto LABEL_63;
            case 1187:
              sub_48C910(hDlg);
              SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)v4, 0);
              break;
            default:
              return 0;
          }
        }
      }
      return 0;
    }
    if ( *(_DWORD *)(dword_4F0C3C + 59460) != 1 )
    {
      if ( *(_DWORD *)(dword_4F0C3C + 59460) == 2 )
      {
        v22 = 1073;
        goto LABEL_69;
      }
      *(_DWORD *)(dword_4F0C3C + 59460) = 1;
    }
    v22 = 1074;
LABEL_69:
    CheckDlgButton(hDlg, v22, 1u);
    if ( *(_DWORD *)(v28 + 5576) == 5 )
    {
      DlgItem = GetDlgItem(v4, 1267);
      EnableWindow(DlgItem, 0);
      if ( *(_DWORD *)(v28 + 59464) == 3 )
        *(_DWORD *)(v28 + 59464) = 1;
    }
    if ( *(_DWORD *)(v28 + 59464) != 1 )
    {
      if ( *(_DWORD *)(v28 + 59464) == 2 )
      {
        v24 = 1202;
        goto LABEL_79;
      }
      if ( *(_DWORD *)(v28 + 59464) == 3 )
      {
        v24 = 1267;
LABEL_79:
        CheckDlgButton(v4, v24, 1u);
        if ( *(_DWORD *)(v28 + 59356) )
          CheckDlgButton(v4, 1176, 1u);
        v25 = GetDlgItem(v4, 1187);
        SendMessageW(v25, 0xF7u, 1u, (LPARAM)hIcon);
        v31 = GetDlgItem(v4, 1188);
        pv = 0;
        if ( sub_467810((LPITEMIDLIST *)&pv, v28 + 4532) >= 0 )
        {
          sub_48C490(v31, (const ITEMIDLIST *)pv);
          CoTaskMemFree(pv);
          v4 = hDlga;
        }
        sub_48C710(v28, v4);
        sub_4697F0(dword_4EF4AC, *(HWND *)(v28 + 52));
        return 0;
      }
    }
    v24 = 1266;
    goto LABEL_79;
  }
  if ( a3 != 78 )
  {
    if ( a3 == 2 )
    {
      DestroyIcon(hIcon);
    }
    else if ( a3 == 16 )
    {
      EndDialog(hDlg, 0);
    }
    return 0;
  }
  if ( *(_DWORD *)(a4 + 8) != -202 )
    return 0;
  v5 = 1;
  if ( IsDlgButtonChecked(hDlg, 1074) == 1 )
  {
    *(_DWORD *)(v28 + 59460) = 1;
  }
  else if ( IsDlgButtonChecked(v4, 1073) == 1 )
  {
    *(_DWORD *)(v28 + 59460) = 2;
  }
  if ( IsDlgButtonChecked(v4, 1266) != 1 )
  {
    if ( IsDlgButtonChecked(v4, 1202) == 1 )
    {
      v5 = 2;
    }
    else if ( IsDlgButtonChecked(v4, 1267) == 1 )
    {
      v5 = 3;
    }
  }
  v6 = *(_DWORD *)(v28 + 59464);
  if ( v6 == v5 )
    goto LABEL_41;
  v7 = 1;
  if ( v5 == 1 )
  {
    if ( v6 == 2 )
    {
      v8 = sub_4AC910((int)L"openinexplorer++");
    }
    else
    {
      if ( v6 != 3 )
        goto LABEL_27;
      v8 = sub_4ACA40(L"openinexplorer++");
    }
  }
  else if ( v5 == 2 )
  {
    sub_4AC910((int)L"openinexplorer++");
    sub_4ACA40(L"openinexplorer++");
    v8 = sub_4ACB60(L"openinexplorer++", 2, L"Open In Explorer++");
  }
  else
  {
    sub_4AC910((int)L"openinexplorer++");
    sub_4ACA40(L"openinexplorer++");
    v8 = sub_4ACD40();
  }
  v7 = v8;
LABEL_27:
  LoadStringW(hInstance, 0x7F9u, Buffer, 256);
  if ( !v7 )
  {
    MessageBoxW(v4, Buffer, L"Explorer++", 0x30u);
    if ( v5 == 1 )
    {
      v9 = 1266;
    }
    else if ( v5 == 2 )
    {
      v9 = 1202;
    }
    else
    {
      v9 = 1267;
    }
    CheckDlgButton(v4, v9, 0);
    if ( *(_DWORD *)(v28 + 59464) != 1 )
    {
      if ( *(_DWORD *)(v28 + 59464) == 2 )
      {
        v10 = 1202;
        goto LABEL_40;
      }
      if ( *(_DWORD *)(v28 + 59464) == 3 )
      {
        v10 = 1267;
LABEL_40:
        CheckDlgButton(v4, v10, 1u);
        goto LABEL_41;
      }
    }
    v10 = 1266;
    goto LABEL_40;
  }
  *(_DWORD *)(v28 + 59464) = v5;
LABEL_41:
  *(_DWORD *)(v28 + 59356) = IsDlgButtonChecked(v4, 1176) == 1;
  v11 = GetDlgItem(v4, 1188);
  SendMessageW(v11, 0xDu, 0x104u, (LPARAM)lParam);
  v12 = sub_466900((const WCHAR *)lParam, (WCHAR *)v34);
  v13 = 260;
  if ( v12 < 0 )
  {
    v15 = (_WORD *)(v28 + 4532);
    while ( v13 != -2147483386 )
    {
      v17 = *(_WORD *)((char *)v15 + (_DWORD)&lParam[-2266] - v28);
      if ( !v17 )
        break;
      *v15++ = v17;
      if ( !--v13 )
      {
        --v15;
        break;
      }
    }
    v14 = v28;
  }
  else
  {
    v14 = v28;
    v15 = (_WORD *)(v28 + 4532);
    while ( v13 != -2147483386 )
    {
      v16 = *(_WORD *)((char *)v15 + (_DWORD)&v34[-2266] - v28);
      if ( !v16 )
        break;
      *v15++ = v16;
      if ( !--v13 )
      {
        --v15;
        break;
      }
    }
  }
  v18 = hDlga;
  v27 = hDlga;
  *v15 = 0;
  v19 = GetDlgItem(v27, 1162);
  v20 = SendMessageW(v19, 0x147u, 0, 0);
  v21 = GetDlgItem(v18, 1162);
  *(_DWORD *)(v14 + 5572) = SendMessageW(v21, 0x150u, v20, 0);
  sub_48F9F0(v14);
  return 0;
}
// 48D893: conditional instruction was optimized away because edx.4!=0
// 48D8D0: conditional instruction was optimized away because edx.4!=0
// 48D6E6: conditional instruction was optimized away because ebx.4==3
// 48D7B2: conditional instruction was optimized away because ebx.4==3
// 4CA2A0: using guessed type wchar_t aOpeninexplorer_7[17];
// 4CA2C4: using guessed type wchar_t aOpeninexplorer_6[17];
// 4CA2E8: using guessed type wchar_t aOpeninexplorer_3[17];
// 4CA30C: using guessed type wchar_t aOpeninexplorer_4[17];
// 4CA330: using guessed type wchar_t aOpenInExplorer_0[19];
// 4CA358: using guessed type wchar_t aOpeninexplorer_5[17];
// 4CA37C: using guessed type wchar_t aOpeninexplorer_1[17];
// 4CA3A0: using guessed type wchar_t aOpeninexplorer_2[17];
// 4F0C3C: using guessed type int dword_4F0C3C;
// 48D5E0: using guessed type WCHAR lParam[260];
// 48D5E0: using guessed type WCHAR var_210[262];

//----- (0048DC00) --------------------------------------------------------
int __stdcall sub_48DC00(HWND hDlg, int a2, int a3, int a4)
{
  if ( a2 == 272 )
    dword_4F0C3C = *(_DWORD *)(a4 + 28);
  return sub_48D5E0(hDlg, a3, a2, a4);
}
// 4F0C3C: using guessed type int dword_4F0C3C;

//----- (0048DC30) --------------------------------------------------------
int __userpurge sub_48DC30@<eax>(unsigned int a1@<ecx>, HWND a2@<esi>, unsigned __int16 a3, int a4)
{
  _DWORD *v4; // ebx
  int result; // eax
  int v6; // ecx
  int v7[34]; // [esp+8h] [ebp-88h] BYREF

  v4 = (_DWORD *)dword_4F2224;
  if ( a1 > 0x110 )
  {
    if ( a1 != 273 )
      return 0;
    switch ( a3 )
    {
      case 0x431u:
      case 0x432u:
      case 0x464u:
      case 0x465u:
      case 0x466u:
      case 0x46Fu:
        if ( IsDlgButtonChecked(a2, a3) != 1 )
          return 0;
        break;
      case 0x463u:
      case 0x468u:
      case 0x469u:
      case 0x46Au:
        break;
      case 0x4E5u:
        if ( dword_4F2224 )
          v6 = dword_4F2224 + 28;
        else
          v6 = 0;
        sub_480570(
          a2,
          (int)v7,
          v6,
          dword_4F2224 + 60472,
          dword_4F2224 + 60484,
          dword_4F2224 + 60496,
          dword_4F2224 + 60508,
          dword_4F2224 + 60520,
          dword_4F2224 + 60532,
          dword_4F2224 + 60544);
        sub_46C110((LPARAM)v7);
        sub_47FEB0(v7);
        return 0;
      default:
        return 0;
    }
    SendMessageW(dword_4EF4AC, 0x468u, (WPARAM)a2, 0);
    return 0;
  }
  else
  {
    if ( a1 != 272 )
    {
      if ( a1 == 16 )
      {
        EndDialog(a2, 0);
        return 0;
      }
      if ( a1 == 78 && *(_DWORD *)(a4 + 8) == -202 )
      {
        v4[14870] = IsDlgButtonChecked(a2, 1123) == 1;
        v4[14872] = IsDlgButtonChecked(a2, 1130) == 1;
        v4[14873] = IsDlgButtonChecked(a2, 1129) == 1;
        v4[14874] = IsDlgButtonChecked(a2, 1128) == 1;
        if ( IsDlgButtonChecked(a2, 1135) == 1 )
        {
          v4[14869] = 6;
          sub_48F9F0((int)v4);
          return 0;
        }
        else if ( IsDlgButtonChecked(a2, 1074) == 1 )
        {
          v4[14869] = 5;
          sub_48F9F0((int)v4);
          return 0;
        }
        else if ( IsDlgButtonChecked(a2, 1073) == 1 )
        {
          v4[14869] = 1;
          sub_48F9F0((int)v4);
          return 0;
        }
        else if ( IsDlgButtonChecked(a2, 1124) == 1 )
        {
          v4[14869] = 2;
          sub_48F9F0((int)v4);
          return 0;
        }
        else if ( IsDlgButtonChecked(a2, 1125) == 1 )
        {
          v4[14869] = 3;
          sub_48F9F0((int)v4);
          return 0;
        }
        else
        {
          if ( IsDlgButtonChecked(a2, 1126) == 1 )
            v4[14869] = 4;
          sub_48F9F0((int)v4);
          return 0;
        }
      }
      return 0;
    }
    if ( *(_DWORD *)(dword_4F2224 + 59480) )
      CheckDlgButton(a2, 1123, 1u);
    if ( v4[14872] )
      CheckDlgButton(a2, 1130, 1u);
    if ( v4[14873] )
      CheckDlgButton(a2, 1129, 1u);
    if ( v4[14874] )
      CheckDlgButton(a2, 1128, 1u);
    switch ( v4[14869] )
    {
      case 1:
        goto LABEL_35;
      case 2:
        CheckDlgButton(a2, 1124, 1u);
        result = 0;
        break;
      case 3:
        CheckDlgButton(a2, 1125, 1u);
        result = 0;
        break;
      case 4:
        CheckDlgButton(a2, 1126, 1u);
        result = 0;
        break;
      case 5:
        CheckDlgButton(a2, 1074, 1u);
        result = 0;
        break;
      case 6:
        CheckDlgButton(a2, 1135, 1u);
        result = 0;
        break;
      default:
        v4[14869] = 1;
LABEL_35:
        CheckDlgButton(a2, 1073, 1u);
        result = 0;
        break;
    }
  }
  return result;
}
// 4F2224: using guessed type int dword_4F2224;
// 48DC30: using guessed type _DWORD var_88[34];

//----- (0048E080) --------------------------------------------------------
int __stdcall sub_48E080(HWND a1, unsigned int a2, unsigned __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4F2224 = *(_DWORD *)(a4 + 28);
  return sub_48DC30(a2, a1, a3, a4);
}
// 4F2224: using guessed type int dword_4F2224;

//----- (0048E0B0) --------------------------------------------------------
int __thiscall sub_48E0B0(WPARAM wParam, int a2, __int16 a3, int a4)
{
  int v4; // esi
  LRESULT v6; // eax
  LPARAM v7; // eax
  HWND v8; // ebx
  LRESULT v9; // eax
  LPARAM v10; // eax
  HWND v12; // [esp-10h] [ebp-78h]
  HWND v13; // [esp-10h] [ebp-78h]
  signed int wParama; // [esp+10h] [ebp-58h]
  signed int wParamb; // [esp+10h] [ebp-58h]
  LRESULT v16; // [esp+14h] [ebp-54h]
  int v17; // [esp+14h] [ebp-54h]
  int v18; // [esp+18h] [ebp-50h]
  LRESULT v19; // [esp+18h] [ebp-50h]
  int v20[6]; // [esp+1Ch] [ebp-4Ch] BYREF
  int v21; // [esp+34h] [ebp-34h]
  int lParam[6]; // [esp+38h] [ebp-30h] BYREF
  int v23; // [esp+50h] [ebp-18h]
  struct tagRECT Rect; // [esp+54h] [ebp-14h] BYREF

  v4 = dword_4F2228;
  if ( (unsigned int)a2 > 0x110 )
  {
    if ( a2 == 273 )
    {
      if ( (unsigned __int16)a3 > 0x488u )
      {
        switch ( a3 )
        {
          case 1163:
          case 1196:
          case 1197:
          case 1203:
          case 1204:
          case 1221:
          case 1264:
          case 1268:
          case 1272:
          case 1273:
          case 1274:
          case 1277:
          case 1279:
            goto LABEL_61;
          default:
            return 0;
        }
      }
      else if ( a3 == 1160 || a3 == 1004 )
      {
LABEL_61:
        SendMessageW(dword_4EF4AC, 0x468u, wParam, 0);
      }
    }
  }
  else if ( a2 == 272 )
  {
    if ( *(_DWORD *)(dword_4F2228 + 59392) )
      CheckDlgButton((HWND)wParam, 1221, 1u);
    if ( *(_DWORD *)(v4 + 59448) )
      CheckDlgButton((HWND)wParam, 1279, 1u);
    if ( *(_DWORD *)(v4 + 59316) )
      CheckDlgButton((HWND)wParam, 1268, 1u);
    if ( *(_DWORD *)(v4 + 59428) )
      CheckDlgButton((HWND)wParam, 1274, 1u);
    if ( *(_DWORD *)(v4 + 59380) )
      CheckDlgButton((HWND)wParam, 1203, 1u);
    if ( *(_DWORD *)(v4 + 59324) )
      CheckDlgButton((HWND)wParam, 1004, 1u);
    if ( *(_DWORD *)(v4 + 59372) )
      CheckDlgButton((HWND)wParam, 1204, 1u);
    if ( *(_DWORD *)(v4 + 59376) )
      CheckDlgButton((HWND)wParam, 1264, 1u);
    if ( *(_DWORD *)(v4 + 59440) )
      CheckDlgButton((HWND)wParam, 1272, 1u);
    if ( *(_DWORD *)(v4 + 59444) )
      CheckDlgButton((HWND)wParam, 1277, 1u);
    if ( !*(_DWORD *)(v4 + 59352) )
      CheckDlgButton((HWND)wParam, 1163, 1u);
    if ( *(_DWORD *)(v4 + 59364) )
      CheckDlgButton((HWND)wParam, 1196, 1u);
    if ( *(_DWORD *)(v4 + 59504) )
      CheckDlgButton((HWND)wParam, 1160, 1u);
    if ( *(_DWORD *)(v4 + 59416) )
      CheckDlgButton((HWND)wParam, 1273, 1u);
    if ( *(_DWORD *)(v4 + 59368) )
      CheckDlgButton((HWND)wParam, 1197, 1u);
  }
  else if ( a2 == 16 )
  {
    EndDialog((HWND)wParam, 0);
  }
  else if ( a2 == 78 && *(_DWORD *)(a4 + 8) == -202 )
  {
    *(_DWORD *)(v4 + 59392) = IsDlgButtonChecked((HWND)wParam, 1221) == 1;
    *(_DWORD *)(v4 + 59316) = IsDlgButtonChecked((HWND)wParam, 1268) == 1;
    *(_DWORD *)(v4 + 59428) = IsDlgButtonChecked((HWND)wParam, 1274) == 1;
    *(_DWORD *)(v4 + 59380) = IsDlgButtonChecked((HWND)wParam, 1203) == 1;
    *(_DWORD *)(v4 + 59324) = IsDlgButtonChecked((HWND)wParam, 1004) == 1;
    *(_DWORD *)(v4 + 59372) = IsDlgButtonChecked((HWND)wParam, 1204) == 1;
    *(_DWORD *)(v4 + 59376) = IsDlgButtonChecked((HWND)wParam, 1264) == 1;
    *(_DWORD *)(v4 + 59440) = IsDlgButtonChecked((HWND)wParam, 1272) == 1;
    *(_DWORD *)(v4 + 59444) = IsDlgButtonChecked((HWND)wParam, 1277) == 1;
    *(_DWORD *)(v4 + 59352) = IsDlgButtonChecked((HWND)wParam, 1163) != 1;
    *(_DWORD *)(v4 + 59364) = IsDlgButtonChecked((HWND)wParam, 1196) == 1;
    *(_DWORD *)(v4 + 59504) = IsDlgButtonChecked((HWND)wParam, 1160) == 1;
    v18 = IsDlgButtonChecked((HWND)wParam, 1273) == 1;
    if ( *(_DWORD *)(v4 + 59416) != v18 )
    {
      v16 = SendMessageW(*(HWND *)(v4 + 68), 0x1304u, 0, 0);
      for ( wParama = 0; wParama < v16; ++wParama )
      {
        v12 = *(HWND *)(v4 + 68);
        lParam[0] = 8;
        SendMessageW(v12, 0x133Cu, wParama, (LPARAM)lParam);
        v6 = SendMessageW(*(HWND *)(v4 + 4 * v23 + 92), 0x1037u, 0, 0);
        if ( v18 )
          v7 = v6 | 4;
        else
          v7 = v6 & 0xFFFFFFFB;
        SendMessageW(*(HWND *)(v4 + 4 * v23 + 92), 0x1036u, 0, v7);
      }
      *(_DWORD *)(v4 + 59416) = IsDlgButtonChecked((HWND)wParam, 1273) == 1;
    }
    *(_DWORD *)(v4 + 59368) = IsDlgButtonChecked((HWND)wParam, 1197) == 1;
    if ( *(_DWORD *)(v4 + 59448) != (IsDlgButtonChecked((HWND)wParam, 1279) == 1) )
    {
      *(_DWORD *)(v4 + 59448) = IsDlgButtonChecked((HWND)wParam, 1279) == 1;
      sub_474E70(v4);
    }
    sub_4AB3E0(v4);
    if ( *(_DWORD *)(v4 + 59316) )
      *(_DWORD *)(v4 + 59320) = 1;
    else
      *(_DWORD *)(v4 + 59320) = SendMessageW(*(HWND *)(v4 + 68), 0x1304u, 0, 0) > 1;
    GetClientRect(*(HWND *)(v4 + 52), &Rect);
    SendMessageW(*(HWND *)(v4 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
    v19 = SendMessageW(*(HWND *)(v4 + 68), 0x1304u, 0, 0);
    for ( wParamb = 0; wParamb < v19; ++wParamb )
    {
      v13 = *(HWND *)(v4 + 68);
      v20[0] = 8;
      SendMessageW(v13, 0x133Cu, wParamb, (LPARAM)v20);
      if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v4 + 4 * v21 + 916) + 304))(*(_DWORD *)(v4 + 4 * v21 + 916)) != *(_DWORD *)(v4 + 59504) )
        (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(v4 + 4 * v21 + 916) + 300))(*(_DWORD *)(v4 + 4 * v21 + 916));
      v8 = *(HWND *)(v4 + 4 * v21 + 92);
      v17 = *(_DWORD *)(v4 + 59368);
      v9 = SendMessageW(v8, 0x1037u, 0, 0);
      if ( v17 )
        v10 = v9 | 0x20;
      else
        v10 = v9 & 0xFFFFFFDF;
      SendMessageW(v8, 0x1036u, 0, v10);
    }
    sub_48F9F0(v4);
  }
  return 0;
}
// 4F2228: using guessed type int dword_4F2228;
// 48E0B0: using guessed type LPARAM lParam[6];
// 48E0B0: using guessed type LPARAM var_4C[6];

//----- (0048E650) --------------------------------------------------------
int __stdcall sub_48E650(WPARAM wParam, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4F2228 = *(_DWORD *)(a4 + 28);
  return sub_48E0B0(wParam, a2, a3, a4);
}
// 4F2228: using guessed type int dword_4F2228;

//----- (0048E680) --------------------------------------------------------
HWND __usercall sub_48E680@<eax>(int a1@<esi>)
{
  int v1; // edi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  int v4; // eax
  int v5; // eax
  DWORD v6; // ecx
  HWND result; // eax
  DWORD dwErrCode[13]; // [esp+8h] [ebp-1D8h] BYREF
  int v9[5]; // [esp+3Ch] [ebp-1A4h] BYREF
  int v10[13]; // [esp+50h] [ebp-190h] BYREF
  int v11[13]; // [esp+84h] [ebp-15Ch] BYREF
  int v12[13]; // [esp+B8h] [ebp-128h] BYREF
  int v13[13]; // [esp+ECh] [ebp-F4h] BYREF
  int v14[14]; // [esp+120h] [ebp-C0h] BYREF
  WCHAR Buffer[66]; // [esp+158h] [ebp-88h] BYREF

  v1 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v1, (int)BitmapW, 0);
  hIcon = (HICON)sub_409F80(v1, 15, 0);
  v10[0] = 52;
  v10[1] = 0;
  v10[2] = (int)hInstance;
  v10[3] = 135;
  v10[7] = a1;
  v10[6] = (int)sub_48DC00;
  v4 = sub_416550(v10);
  v11[2] = (int)hInstance;
  v9[0] = v4;
  v11[0] = 52;
  v11[1] = 0;
  v11[3] = 9;
  v11[7] = a1;
  v11[6] = (int)sub_48D5B0;
  v9[1] = sub_416550(v11);
  v12[0] = 52;
  v12[1] = 0;
  v12[2] = (int)hInstance;
  v12[3] = 227;
  v12[7] = a1;
  v12[6] = (int)sub_48E650;
  v9[2] = sub_416550(v12);
  v13[0] = 52;
  v13[1] = 0;
  v13[2] = (int)hInstance;
  v13[3] = 166;
  v13[7] = a1;
  v13[6] = (int)sub_48CD30;
  v5 = sub_416550(v13);
  v14[2] = (int)hInstance;
  v9[3] = v5;
  v14[0] = 52;
  v14[1] = 0;
  v14[3] = 181;
  v14[7] = a1;
  v14[6] = (int)sub_48E080;
  v9[4] = sub_416550(v14);
  LoadStringW(hInstance, 0x2011u, Buffer, 64);
  v6 = *(_DWORD *)(a1 + 52);
  dwErrCode[0] = 52;
  dwErrCode[1] = 33555714;
  dwErrCode[2] = v6;
  dwErrCode[5] = (DWORD)Buffer;
  dwErrCode[6] = 5;
  dwErrCode[7] = 0;
  dwErrCode[4] = sub_409F80(v1, 25, 1u);
  dwErrCode[8] = (DWORD)v9;
  dwErrCode[9] = (DWORD)sub_48C540;
  DeleteObject(BitmapW);
  sub_409E60(v1);
  result = (HWND)sub_416330((DWORD)dwErrCode);
  hWnd = result;
  return result;
}

//----- (0048E920) --------------------------------------------------------
int __thiscall sub_48E920(_DWORD *this)
{
  return this[323];
}

//----- (0048E930) --------------------------------------------------------
int __thiscall sub_48E930(_DWORD *this)
{
  return this[851];
}

//----- (0048E940) --------------------------------------------------------
void __stdcall sub_48E940(int a1)
{
  if ( a1 == 224 )
    hDlg = 0;
}

//----- (0048E980) --------------------------------------------------------
int __usercall sub_48E980@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-4h] BYREF

  v8 = a1;
  v3 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v3 + 28))(v3, &v8);
  v4 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  if ( (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 36))(v4) && a2 == v8 )
  {
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a3 + 1320) + 232))(*(_DWORD *)(a3 + 1320));
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
    if ( !(*(int (__thiscall **)(int))(*(_DWORD *)v5 + 36))(v5) )
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a3 + 1320) + 108))(*(_DWORD *)(a3 + 1320), 1);
  }
  v6 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)v6 + 16))(v6, a2);
}

//----- (0048EA10) --------------------------------------------------------
int __usercall sub_48EA10@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v8; // [esp+0h] [ebp-4h] BYREF

  v8 = a1;
  v3 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v3 + 28))(v3, &v8);
  v4 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  if ( (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 36))(v4) || a2 != v8 )
  {
    v5 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
    if ( (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 36))(v5) )
      (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a3 + 1320) + 104))(*(_DWORD *)(a3 + 1320), 0);
  }
  else
  {
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a3 + 1320) + 232))(*(_DWORD *)(a3 + 1320));
  }
  v6 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)v6 + 16))(v6, a2);
}

//----- (0048EAA0) --------------------------------------------------------
int __userpurge sub_48EAA0@<eax>(int a1@<eax>, int a2)
{
  int result; // eax
  unsigned int v3; // eax

  switch ( a1 )
  {
    case 1:
      v3 = *(_DWORD *)(a2 + 5576);
      if ( v3 < 6 )
      {
        if ( v3 < 5 )
          goto LABEL_13;
        result = 2047;
      }
      else
      {
        result = 2046;
      }
      break;
    case 2:
      result = 2048;
      break;
    case 3:
      result = 2088;
      break;
    case 4:
      result = 2089;
      break;
    case 5:
      result = 2091;
      break;
    case 6:
      result = 2090;
      break;
    case 7:
      result = 2044;
      break;
    case 8:
      result = 2045;
      break;
    default:
LABEL_13:
      result = -1;
      break;
  }
  return result;
}

//----- (0048EBA0) --------------------------------------------------------
BOOL __usercall sub_48EBA0@<eax>(int a1@<eax>, int a2@<esi>)
{
  HWND v3; // [esp-8h] [ebp-10h]
  struct tagPOINT Point; // [esp+0h] [ebp-8h] BYREF

  Point.x = (__int16)a1;
  v3 = *(HWND *)(a2 + 64);
  Point.y = SHIWORD(a1);
  ClientToScreen(v3, &Point);
  return TrackPopupMenu(*(HMENU *)(a2 + 3484), 0x42u, Point.x, Point.y, 0, *(HWND *)(a2 + 52), 0);
}

//----- (0048EBF0) --------------------------------------------------------
unsigned int __userpurge sub_48EBF0@<eax>(int a1@<edi>, int a2, LPARAM a3)
{
  unsigned int result; // eax
  WPARAM v4; // esi
  HWND v5; // [esp-10h] [ebp-70h]
  LPARAM lParam[21]; // [esp+8h] [ebp-58h] BYREF
  unsigned int v7; // [esp+5Ch] [ebp-4h]

  result = SendMessageW(*(HWND *)(a1 + 60), 0x40Cu, 0, 0);
  v4 = 0;
  v7 = result;
  if ( result )
  {
    while ( 1 )
    {
      v5 = *(HWND *)(a1 + 60);
      lParam[0] = 80;
      lParam[1] = 16;
      result = SendMessageW(v5, 0x41Cu, v4, (LPARAM)lParam);
      if ( result )
      {
        result = a2;
        if ( a2 == lParam[8] )
          break;
      }
      if ( ++v4 >= v7 )
        return result;
    }
    return SendMessageW(*(HWND *)(a1 + 60), 0x423u, v4, a3);
  }
  return result;
}

//----- (0048EC70) --------------------------------------------------------
int __usercall sub_48EC70@<eax>(int a1@<esi>)
{
  int *v1; // ecx
  int v2; // edi
  int v3; // eax

  v1 = *(int **)(a1 + 1320);
  v2 = *v1;
  v3 = (*(int (__thiscall **)(int *))(*v1 + 216))(v1);
  return (*(int (__thiscall **)(_DWORD, bool))(v2 + 220))(*(_DWORD *)(a1 + 1320), v3 == 0);
}

//----- (0048ECA0) --------------------------------------------------------
int __usercall sub_48ECA0@<eax>(int a1@<eax>)
{
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(a1 + 28) + 16))(a1 + 28, *(_DWORD *)(a1 + 5620));
}

//----- (0048ECC0) --------------------------------------------------------
WPARAM __userpurge sub_48ECC0@<eax>(WPARAM result@<eax>, int a2)
{
  if ( result != -1 )
    return SendMessageW(*(HWND *)(a2 + 3432), 0x1076u, result, 0);
  return result;
}

//----- (0048ECF0) --------------------------------------------------------
LONG __usercall sub_48ECF0@<eax>(int a1@<eax>)
{
  unsigned int v2; // edi
  unsigned int v3; // eax
  int v4; // eax
  int v5; // edi
  HWND v6; // esi
  LONG WindowLongW; // eax
  HWND v9; // [esp-10h] [ebp-78h]
  HWND v10; // [esp-10h] [ebp-78h]
  LPARAM lParam[2]; // [esp+10h] [ebp-58h] BYREF
  int v12; // [esp+18h] [ebp-50h]
  unsigned int v13; // [esp+64h] [ebp-4h]

  v9 = *(HWND *)(a1 + 60);
  *(_DWORD *)(a1 + 59360) = *(_DWORD *)(a1 + 59360) == 0;
  v2 = 0;
  v13 = SendMessageW(v9, 0x40Cu, 0, 0);
  if ( v13 )
  {
    do
    {
      v10 = *(HWND *)(a1 + 60);
      lParam[0] = 80;
      lParam[1] = 1;
      SendMessageW(v10, 0x41Cu, v2, (LPARAM)lParam);
      v3 = v12;
      if ( *(_DWORD *)(a1 + 59360) )
      {
        if ( (v12 & 0x80u) != 0 )
        {
          v3 = v12 & 0xFFFFFF7F;
          v12 &= ~0x80u;
        }
        if ( (v3 & 0x100) != 0 )
          goto LABEL_12;
        v4 = v3 | 0x100;
      }
      else
      {
        if ( (v12 & 0x100) != 0 )
        {
          v3 = v12 & 0xFFFFFEFF;
          v12 &= ~0x100u;
        }
        if ( (v3 & 0x80u) != 0 )
          goto LABEL_12;
        v4 = v3 | 0x80;
      }
      v12 = v4;
LABEL_12:
      SendMessageW(*(HWND *)(a1 + 60), 0x40Bu, v2++, (LPARAM)lParam);
    }
    while ( v2 < v13 );
  }
  v5 = *(_DWORD *)(a1 + 59360);
  v6 = *(HWND *)(a1 + 60);
  WindowLongW = GetWindowLongW(v6, -16);
  if ( v5 )
  {
    if ( (WindowLongW & 0x800) == 0 )
      return SetWindowLongW(v6, -16, WindowLongW | 0x800);
  }
  else if ( (WindowLongW & 0x800) != 0 )
  {
    WindowLongW &= ~0x800u;
  }
  return SetWindowLongW(v6, -16, WindowLongW);
}

//----- (0048EE00) --------------------------------------------------------
void __usercall sub_48EE00(int csidl@<ecx>, UINT a2@<ebx>, HMENU a3@<esi>)
{
  MENUITEMINFOW mii; // [esp+4h] [ebp-244h] BYREF
  LPITEMIDLIST ppidl; // [esp+34h] [ebp-214h] BYREF
  __int16 v5[262]; // [esp+38h] [ebp-210h] BYREF

  ppidl = 0;
  if ( SHGetFolderLocation(0, csidl, 0, 0, &ppidl) )
  {
    mii.cbSize = 48;
    mii.fMask = 32;
    GetMenuItemInfoW(a3, a2, 0, &mii);
    free((void *)mii.dwItemData);
    DeleteMenu(a3, a2, 0);
  }
  else
  {
    sub_466630(ppidl, (WCHAR *)v5, 1);
    mii.cbSize = 48;
    mii.fMask = 64;
    mii.dwTypeData = (LPWSTR)v5;
    SetMenuItemInfoW(a3, a2, 0, &mii);
    CoTaskMemFree(ppidl);
  }
}
// 48EE00: using guessed type WCHAR var_210[262];

//----- (0048EEF0) --------------------------------------------------------
HWND __usercall sub_48EEF0@<eax>(int a1@<eax>)
{
  HWND v2; // eax
  HWND result; // eax
  HWND Focus; // edi

  if ( *(_DWORD *)(a1 + 60608) )
  {
    v2 = (HWND)SendMessageW(*(HWND *)(a1 + 3432), 0x1018u, 0, 0);
    return (HWND)SendMessageW(v2, 0x8037u, 9u, 0);
  }
  Focus = GetFocus();
  result = *(HWND *)(a1 + 3432);
  if ( Focus == result )
  {
    if ( *(_DWORD *)(a1 + 59292) )
      return SetFocus(*(HWND *)(a1 + 84));
    if ( *(_DWORD *)(a1 + 59288) )
      return SetFocus(*(HWND *)(a1 + 76));
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 76) )
    {
      result = (HWND)SendMessageW(*(HWND *)(a1 + 84), 0x407u, 0, 0);
      if ( Focus != result )
        return result;
      if ( *(_DWORD *)(a1 + 59288) )
        return SetFocus(*(HWND *)(a1 + 76));
    }
    return SetFocus(*(HWND *)(a1 + 3432));
  }
  return result;
}

//----- (0048EFB0) --------------------------------------------------------
HWND __usercall sub_48EFB0@<eax>(int a1@<esi>)
{
  HWND Focus; // edi
  HWND result; // eax

  Focus = GetFocus();
  result = *(HWND *)(a1 + 3432);
  if ( Focus == result )
  {
    if ( *(_DWORD *)(a1 + 59288) )
    {
      result = *(HWND *)(a1 + 76);
      return SetFocus(result);
    }
    if ( *(_DWORD *)(a1 + 59292) )
      return SetFocus(*(HWND *)(a1 + 84));
  }
  else
  {
    if ( Focus == *(HWND *)(a1 + 76) )
    {
      if ( !*(_DWORD *)(a1 + 59292) )
        return SetFocus(result);
      return SetFocus(*(HWND *)(a1 + 84));
    }
    result = (HWND)SendMessageW(*(HWND *)(a1 + 84), 0x407u, 0, 0);
    if ( Focus == result )
      return SetFocus(*(HWND *)(a1 + 3432));
  }
  return result;
}

//----- (0048F030) --------------------------------------------------------
int __usercall sub_48F030@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax
  int v4; // ecx
  void (__thiscall *v5)(int); // edx
  int v6; // ecx
  int *v7; // [esp+0h] [ebp-4h] BYREF

  result = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a3 + 1320) + 256))(*(_DWORD *)(a3 + 1320), a1);
  if ( a2 != result )
  {
    (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a3 + 1320) + 260))(*(_DWORD *)(a3 + 1320), a2);
    v4 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
    v5 = *(void (__thiscall **)(int))(*(_DWORD *)v4 + 28);
    v7 = (int *)&v7;
    v5(v4);
    v6 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
    return (*(int (__thiscall **)(int, int *))(*(_DWORD *)v6 + 16))(v6, v7);
  }
  return result;
}

//----- (0048F090) --------------------------------------------------------
int __thiscall sub_48F090(UINT *this, int a2)
{
  if ( *this == 1 )
    return sub_463340(*(_DWORD *)(a2 + 3412), this);
  else
    return 1;
}

//----- (0048F0C0) --------------------------------------------------------
unsigned int __usercall sub_48F0C0@<eax>(int a1@<ebx>)
{
  unsigned int result; // eax
  unsigned int v2; // edi
  WPARAM i; // esi

  result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 296))(*(_DWORD *)(a1 + 1320));
  v2 = result;
  for ( i = 0; i < v2; ++i )
    result = SendMessageW(*(HWND *)(a1 + 3432), 0x101Eu, i, 0xFFFF);
  return result;
}

//----- (0048F100) --------------------------------------------------------
LRESULT __userpurge sub_48F100@<eax>(int a1@<esi>, int a2)
{
  struct tagRECT Rect; // [esp+4h] [ebp-18h] BYREF

  if ( a2 >= 70 )
    *(_DWORD *)(a1 + 5584) = a2;
  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  return SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
}

//----- (0048F160) --------------------------------------------------------
HWND __usercall sub_48F160@<eax>(WPARAM wParam@<ecx>, int a2@<edx>, LPARAM a3@<esi>)
{
  HWND result; // eax

  result = *(HWND *)(a2 + 3440);
  if ( (HWND)wParam == result )
  {
    *(_DWORD *)(a2 + 3440) = a3;
  }
  else if ( result )
  {
    return (HWND)SendMessageW(result, 0x30Du, wParam, a3);
  }
  return result;
}

//----- (0048F1A0) --------------------------------------------------------
LRESULT __usercall sub_48F1A0@<eax>(int a1@<edi>, _DWORD *a2@<esi>)
{
  LRESULT result; // eax
  HWND v3; // [esp-10h] [ebp-30h]
  WPARAM v4; // [esp-8h] [ebp-28h]
  int lParam[6]; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  result = SendMessageW(*(HWND *)(a1 + 68), 0x132Du, 0, 0);
  if ( *a2 == result )
  {
    v4 = a2[1];
    v3 = *(HWND *)(a1 + 68);
    lParam[0] = 8;
    SendMessageW(v3, 0x133Cu, v4, (LPARAM)lParam);
    result = (*(int (__thiscall **)(_DWORD, int, void *))(**(_DWORD **)(a1 + 4 * v6 + 916) + 52))(
               *(_DWORD *)(a1 + 4 * v6 + 916),
               512,
               &unk_4EFD10);
    a2[3] = &unk_4EFD10;
  }
  return result;
}
// 48F1A0: using guessed type LPARAM lParam[6];

//----- (0048F210) --------------------------------------------------------
int __userpurge sub_48F210@<eax>(int a1@<esi>, int nWidth, int a3)
{
  HWND v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // edx
  UINT v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  UINT v15; // eax
  double v16; // st7
  int v17; // ebx
  HWND v19; // [esp-1Ch] [ebp-BCh]
  HWND v20; // [esp-10h] [ebp-B0h]
  HWND v21; // [esp-10h] [ebp-B0h]
  HWND v22; // [esp-10h] [ebp-B0h]
  int v23; // [esp-8h] [ebp-A8h]
  int lParam[6]; // [esp+8h] [ebp-98h] BYREF
  int v25; // [esp+20h] [ebp-80h]
  LPARAM v26[4]; // [esp+24h] [ebp-7Ch] BYREF
  __int16 v27; // [esp+36h] [ebp-6Ah]
  HWND hWnd; // [esp+44h] [ebp-5Ch]
  WPARAM wParam; // [esp+48h] [ebp-58h]
  int Y; // [esp+4Ch] [ebp-54h]
  int X; // [esp+50h] [ebp-50h]
  int v32; // [esp+54h] [ebp-4Ch]
  int v33; // [esp+58h] [ebp-48h]
  struct tagRECT v34; // [esp+5Ch] [ebp-44h] BYREF
  struct tagRECT v35; // [esp+6Ch] [ebp-34h] BYREF
  struct tagRECT v36; // [esp+7Ch] [ebp-24h] BYREF
  struct tagRECT Rect; // [esp+8Ch] [ebp-14h] BYREF

  v3 = *(HWND *)(a1 + 60);
  v4 = 0;
  v33 = 0;
  X = 0;
  v32 = 0;
  if ( v3 )
  {
    GetWindowRect(v3, &Rect);
    v32 = Rect.bottom - Rect.top;
    v4 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 59284) )
  {
    GetWindowRect(*(HWND *)(a1 + 56), &Rect);
    v33 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 59296) )
    v33 += *(_DWORD *)(a1 + 5584);
  if ( *(_DWORD *)(a1 + 59288) )
  {
    GetClientRect(*(HWND *)(a1 + 80), &Rect);
    X = Rect.right - Rect.left;
  }
  v5 = *(_DWORD *)(a1 + 59320);
  Y = v4;
  if ( v5 && !*(_DWORD *)(a1 + 59428) )
    Y = v4 + 24;
  v6 = nWidth;
  if ( *(_DWORD *)(a1 + 59364) )
  {
    v7 = 0;
  }
  else
  {
    v7 = X;
    v6 = nWidth - X;
  }
  v8 = v5 != 0 ? 64 : 128;
  if ( *(_DWORD *)(a1 + 59428) )
    v9 = a3 - v33 - 24;
  else
    v9 = v4;
  SetWindowPos(*(HWND *)(a1 + 496), *(HWND *)(a1 + 64), v7, v9, v6, 24, v8);
  SetWindowPos(*(HWND *)(a1 + 68), 0, 0, 0, v6 - 25, 24, 0x44u);
  SetWindowPos(*(HWND *)(a1 + 72), 0, v6 - 20, 5, 20, 20, 0x44u);
  v10 = *(_DWORD *)(a1 + 59364);
  if ( !v10 || (v11 = Y, *(_DWORD *)(a1 + 59428)) )
    v11 = v32;
  if ( v10 && *(_DWORD *)(a1 + 59428) && *(_DWORD *)(a1 + 59320) )
    v12 = a3 - v11 - v33 - 24;
  else
    v12 = a3 - v11 - v33;
  v19 = *(HWND *)(a1 + 80);
  wParam = *(_DWORD *)(a1 + 5616);
  SetWindowPos(v19, 0, 0, v11, wParam, v12, 4u);
  SetWindowPos(*(HWND *)(a1 + 76), 0, 1, 20, wParam - 5, v12 - 20, 4u);
  SetWindowPos(*(HWND *)(a1 + 492), 0, wParam - 20, 3, 16, 16, 0x44u);
  v13 = nWidth;
  SetWindowPos(*(HWND *)(a1 + 64), 0, 0, a3 - v33, nWidth, *(_DWORD *)(a1 + 5584), 0x44u);
  hWnd = (HWND)SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  wParam = 0;
  if ( (int)hWnd > 0 )
  {
    v14 = a3 - Y - v33;
    v32 = nWidth - X;
    while ( 1 )
    {
      v20 = *(HWND *)(a1 + 68);
      lParam[0] = 8;
      SendMessageW(v20, 0x133Cu, wParam, (LPARAM)lParam);
      v15 = 4;
      if ( v25 == *(_DWORD *)(a1 + 5620) )
        v15 = 68;
      if ( *(_DWORD *)(a1 + 59428) )
      {
        if ( !*(_DWORD *)(a1 + 59320) )
        {
          SetWindowPos(*(HWND *)(a1 + 4 * v25 + 92), 0, X, Y, v32, v14, v15);
          goto LABEL_36;
        }
        v23 = v14 - 24;
      }
      else
      {
        v23 = v14;
      }
      SetWindowPos(*(HWND *)(a1 + 4 * v25 + 92), 0, X, Y, v32, v23, v15);
LABEL_36:
      if ( (int)++wParam >= (int)hWnd )
      {
        v13 = nWidth;
        break;
      }
    }
  }
  hWnd = *(HWND *)(a1 + 56);
  GetWindowRect(hWnd, &v36);
  SetWindowPos(hWnd, 0, 0, a3 + v36.top - v36.bottom, v13, 24, 4u);
  v16 = (double)nWidth;
  v36.top = (int)(0.5 * v16);
  v21 = *(HWND *)(a1 + 56);
  v36.right = (int)(v16 * 0.75);
  v36.bottom = v13;
  SendMessageW(v21, 0x404u, 3u, (LPARAM)&v36.top);
  MoveWindow(*(HWND *)(a1 + 60), 0, 0, v13, 0, 0);
  GetWindowRect(*(HWND *)(a1 + 52), &v35);
  GetWindowRect(*(HWND *)(a1 + 84), &v34);
  v17 = (unsigned __int16)(v13 - LOWORD(v34.left) + LOWORD(v35.left) - 22);
  MoveWindow(*(HWND *)(a1 + 84), 0, 0, v17, 0, 0);
  v22 = *(HWND *)(a1 + 500);
  v26[0] = 32;
  v26[1] = -2147483584;
  v27 = v17;
  SendMessageW(v22, 0x440u, 0, (LPARAM)v26);
  SetFocus(*(HWND *)(a1 + 3436));
  return 1;
}
// 48F210: using guessed type LPARAM lParam[6];

//----- (0048F5A0) --------------------------------------------------------
BOOL __userpurge sub_48F5A0@<eax>(int a1@<esi>, int a2)
{
  DWORD MessagePos; // eax

  SetFocus(*(HWND *)(a1 + 88));
  MessagePos = GetMessagePos();
  *(_DWORD *)(a1 + 60384) = a2;
  return TrackPopupMenu(*(HMENU *)(a1 + 3476), 0, (__int16)MessagePos, SHIWORD(MessagePos), 0, *(HWND *)(a1 + 60), 0);
}

//----- (0048F5E0) --------------------------------------------------------
BOOL __usercall sub_48F5E0@<eax>(int a1@<esi>)
{
  HMENU v1; // eax
  HMENU v2; // eax
  HMENU v3; // eax
  HMENU v4; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  DWORD MessagePos; // eax

  v1 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59292) )
    CheckMenuItem(v1, 0x9D5Au, 8u);
  else
    CheckMenuItem(v1, 0x9D5Au, 0);
  v2 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59300) )
    CheckMenuItem(v2, 0x9D63u, 8u);
  else
    CheckMenuItem(v2, 0x9D63u, 0);
  v3 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59304) )
    CheckMenuItem(v3, 0x9D64u, 8u);
  else
    CheckMenuItem(v3, 0x9D64u, 0);
  v4 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59308) )
    CheckMenuItem(v4, 0x9D8Bu, 8u);
  else
    CheckMenuItem(v4, 0x9D8Bu, 0);
  v5 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59312) )
    CheckMenuItem(v5, 0x9D9Du, 8u);
  else
    CheckMenuItem(v5, 0x9D9Du, 0);
  v6 = *(HMENU *)(a1 + 3472);
  if ( *(_DWORD *)(a1 + 59360) )
    CheckMenuItem(v6, 0x9D98u, 8u);
  else
    CheckMenuItem(v6, 0x9D98u, 0);
  SetFocus(*(HWND *)(a1 + 88));
  MessagePos = GetMessagePos();
  return TrackPopupMenu(*(HMENU *)(a1 + 3472), 0, (__int16)MessagePos, SHIWORD(MessagePos), 0, *(HWND *)(a1 + 60), 0);
}

//----- (0048F6D0) --------------------------------------------------------
void __userpurge sub_48F6D0(int a1@<ebx>, ITEMIDLIST *a2@<esi>, const WCHAR *a3)
{
  LPITEMIDLIST v3; // edi
  SHELLEXECUTEINFOW pExecInfo; // [esp+8h] [ebp-254h] BYREF
  const WCHAR *v5; // [esp+44h] [ebp-218h]
  __int16 v6[262]; // [esp+48h] [ebp-214h] BYREF

  v5 = a3;
  v3 = ILClone(a2);
  ILRemoveLastID(v3);
  sub_466630(v3, (WCHAR *)v6, 0x8000);
  pExecInfo.hwnd = *(HWND *)(a1 + 52);
  pExecInfo.lpParameters = a3;
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 12;
  pExecInfo.lpVerb = (LPCWSTR)&unk_4CA5FC;
  pExecInfo.lpIDList = a2;
  pExecInfo.nShow = 5;
  pExecInfo.lpDirectory = (LPCWSTR)v6;
  pExecInfo.lpFile = 0;
  pExecInfo.hInstApp = 0;
  ShellExecuteExW(&pExecInfo);
  CoTaskMemFree(v3);
}
// 48F6D0: using guessed type WCHAR var_214[262];

//----- (0048F7A0) --------------------------------------------------------
void __userpurge sub_48F7A0(int a1@<eax>, int a2, int a3, int a4)
{
  ITEMIDLIST *v5; // ebx
  const ITEMIDLIST *v6; // eax
  ITEMIDLIST *v7; // esi
  LPITEMIDLIST v8; // ebx
  ITEMIDLIST *pv; // [esp+Ch] [ebp-4h]

  v5 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
  pv = v5;
  v6 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 1320) + 140))(
                             *(_DWORD *)(a1 + 1320),
                             a2);
  v7 = (ITEMIDLIST *)v6;
  if ( v6 )
  {
    v8 = ILCombine(v5, v6);
    (*(void (__thiscall **)(int, LPITEMIDLIST, int, int))(*(_DWORD *)(a1 + 28) + 32))(a1 + 28, v8, a3, a4);
    CoTaskMemFree(v8);
    CoTaskMemFree(v7);
    CoTaskMemFree(pv);
  }
  else
  {
    CoTaskMemFree(v5);
  }
}

//----- (0048F820) --------------------------------------------------------
_DWORD *__fastcall sub_48F820(UINT item, HMENU hmenu, int a3)
{
  _DWORD *result; // eax
  struct tagMENUITEMINFOW mii; // [esp+0h] [ebp-34h] BYREF

  mii.cbSize = 48;
  mii.fMask = 32;
  result = (_DWORD *)GetMenuItemInfoW(hmenu, item, 0, &mii);
  if ( result )
  {
    result = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *result = a3;
  }
  return result;
}

//----- (0048F860) --------------------------------------------------------
BOOL __usercall sub_48F860@<eax>(HMENU a1@<edi>, UINT a2@<esi>)
{
  _DWORD *v2; // eax
  struct tagMENUITEMINFOW mii; // [esp+0h] [ebp-30h] BYREF

  mii.cbSize = 48;
  mii.fMask = 258;
  GetMenuItemInfoW(a1, a2, 1, &mii);
  if ( (mii.fType & 0x100) == 0 )
    mii.fType |= 0x100u;
  v2 = malloc(0xCu);
  v2[1] = 0;
  v2[2] = 0;
  mii.fMask |= 0x20u;
  mii.dwItemData = (ULONG_PTR)v2;
  return SetMenuItemInfoW(a1, a2, 1, &mii);
}

//----- (0048F8E0) --------------------------------------------------------
int sub_48F8E0()
{
  DWORD CurrentProcessId; // eax
  HANDLE v1; // esi
  HANDLE FileW; // eax
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v1 = OpenProcess(0x410u, 0, CurrentProcessId);
  if ( v1 )
  {
    GetModuleFileNameExW(v1, 0, pszPath, 260);
    CloseHandle(v1);
  }
  PathRemoveFileSpecW(pszPath);
  PathAppendW(pszPath, L"config.xml");
  FileW = CreateFileW(pszPath, 0x80000000, 1u, 0, 3u, 0, 0);
  if ( FileW == (HANDLE)-1 )
    return 0;
  CloseHandle(FileW);
  return 1;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048F9C0) --------------------------------------------------------
// attributes: thunk
void __stdcall sub_48F9C0(ULONG_PTR Parameter)
{
  CoUninitialize();
}

//----- (0048F9D0) --------------------------------------------------------
void __stdcall sub_48F9D0(ULONG_PTR Parameter)
{
  CoInitializeEx(0, 2u);
}

//----- (0048F9E0) --------------------------------------------------------
void __stdcall __noreturn sub_48F9E0(LPVOID lpThreadParameter)
{
  while ( 1 )
    SleepEx(0xFFFFFFFF, 1);
}

//----- (0048F9F0) --------------------------------------------------------
int __usercall sub_48F9F0@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  _DWORD *v4; // eax

  v1 = 0;
  if ( *(_DWORD *)(a1 + 59356) )
  {
    v2 = operator new(0x1Cu);
    v3 = v2;
    if ( v2 )
    {
      *v2 = &Explorerplusplus::CLoadSaveXML::`vftable';
      v2[1] = 1;
      v2[2] = a1;
      v2[3] = 0;
      sub_46C930((int)v2);
      v1 = v3;
    }
  }
  else
  {
    v4 = operator new(0xCu);
    if ( v4 )
    {
      *v4 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
      v4[1] = 1;
      v4[2] = a1;
    }
    else
    {
      v4 = 0;
    }
    v1 = v4;
  }
  (*(void (__thiscall **)(_DWORD *))(*v1 + 44))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 52))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 56))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 48))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 60))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 64))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 68))(v1);
  (*(void (__thiscall **)(_DWORD *))(*v1 + 72))(v1);
  return (*(int (__stdcall **)(_DWORD *))(*v1 + 8))(v1);
}
// 4CBD1C: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';
// 4CC344: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (0048FAE0) --------------------------------------------------------
BOOL __thiscall sub_48FAE0(HWND *this)
{
  int v2; // ecx
  HWND v4; // [esp-8h] [ebp-30h]
  struct tagPOINT Point; // [esp+Ch] [ebp-1Ch] BYREF
  LPARAM lParam[4]; // [esp+14h] [ebp-14h] BYREF

  SendMessageW(this[22], 0x433u, 0xAFD5u, (LPARAM)lParam);
  Point.x = lParam[0];
  v4 = this[22];
  Point.y = lParam[3];
  ClientToScreen(v4, &Point);
  return sub_4943A0(v2, &Point.x, (int)this);
}
// 48FB29: variable 'v2' is possibly undefined

//----- (0048FB40) --------------------------------------------------------
int __thiscall sub_48FB40(_DWORD *this)
{
  if ( *this == 1 )
    return sub_463500((int)this);
  else
    return 1;
}

//----- (0048FB60) --------------------------------------------------------
int __usercall sub_48FB60@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax
  int v3; // eax
  _DWORD *v4; // ebx
  __int16 pszBuf[260]; // [esp+8h] [ebp-418h] BYREF
  char v7[524]; // [esp+210h] [ebp-210h] BYREF

  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 4 * a1 + 916) + 164))(*(_DWORD *)(a2 + 4 * a1 + 916));
  (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a2 + 1324) + 20))(*(_DWORD *)(a2 + 1324), v2);
  (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a2 + 4 * a1 + 916) + 52))(
    *(_DWORD *)(a2 + 4 * a1 + 916),
    260,
    v7);
  sub_4664A0(10, (LPWSTR)pszBuf);
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 4 * a1 + 916) + 144))(*(_DWORD *)(a2 + 4 * a1 + 916)) )
  {
    v3 = -1;
  }
  else
  {
    v4 = malloc(0xCu);
    *v4 = a1;
    v4[1] = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 4 * a1 + 916) + 24))(*(_DWORD *)(a2 + 4 * a1 + 916));
    v4[2] = a2;
    v3 = (*(int (__thiscall **)(_DWORD, char *, int, void (__cdecl *)(int, int, _DWORD *), _DWORD, _DWORD *))(**(_DWORD **)(a2 + 1324) + 16))(
           *(_DWORD *)(a2 + 1324),
           v7,
           383,
           sub_494560,
           0,
           v4);
  }
  return (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a2 + 4 * a1 + 916) + 156))(
           *(_DWORD *)(a2 + 4 * a1 + 916),
           v3);
}
// 48FB60: using guessed type WCHAR pszBuf[260];

//----- (0048FC40) --------------------------------------------------------
int __usercall sub_48FC40@<eax>(int a1@<eax>)
{
  int v3; // eax

  if ( *(_DWORD *)(a1 + 59348)
    && SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0) > 1
    && MessageBoxW(*(HWND *)(a1 + 52), L"Are you sure you want to close all the current tabs?", L"Explorer++", 0x44u) == 7 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a1 + 59436);
  *(_DWORD *)(a1 + 5628) = *(_DWORD *)(a1 + 5632);
  *(_DWORD *)(a1 + 59432) = v3;
  sub_48F9F0(a1);
  RevokeDragDrop(*(HWND *)(a1 + 68));
  DestroyWindow(*(HWND *)(a1 + 52));
  return 0;
}

//----- (0048FCC0) --------------------------------------------------------
void __stdcall sub_48FCC0(HMENU hmenu, int a2)
{
  int i; // esi
  _DWORD *v3; // eax
  int MenuItemCount; // eax
  HMENU hSubMenu; // [esp+10h] [ebp-68h]
  struct tagMENUITEMINFOW mii; // [esp+18h] [ebp-60h] BYREF
  struct tagMENUITEMINFOW v7; // [esp+48h] [ebp-30h] BYREF

  for ( i = 0; i < a2; ++i )
  {
    mii.cbSize = 48;
    mii.fMask = 258;
    GetMenuItemInfoW(hmenu, i, 1, &mii);
    if ( (mii.fType & 0x100) == 0 )
      mii.fType |= 0x100u;
    v3 = malloc(0xCu);
    v3[1] = 0;
    v3[2] = 0;
    mii.fMask |= 0x20u;
    mii.dwItemData = (ULONG_PTR)v3;
    SetMenuItemInfoW(hmenu, i, 1, &mii);
    v7.cbSize = 48;
    v7.fMask = 4;
    GetMenuItemInfoW(hmenu, i, 1, &v7);
    if ( v7.hSubMenu )
    {
      hSubMenu = v7.hSubMenu;
      MenuItemCount = GetMenuItemCount(v7.hSubMenu);
      sub_48FCC0(hSubMenu, MenuItemCount);
    }
  }
}

//----- (0048FD90) --------------------------------------------------------
BOOL __thiscall sub_48FD90(_DWORD **this)
{
  DWORD CurrentProcessId; // eax
  HANDLE v3; // esi
  SHELLEXECUTEINFOW pExecInfo; // [esp+8h] [ebp-658h] BYREF
  __int16 v6[260]; // [esp+44h] [ebp-61Ch] BYREF
  char v7[520]; // [esp+24Ch] [ebp-414h] BYREF
  char v8[520]; // [esp+454h] [ebp-20Ch] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  if ( v3 )
  {
    GetModuleFileNameExW(v3, 0, v7, 260);
    CloseHandle(v3);
  }
  (*(void (__thiscall **)(_DWORD *, int, char *))(*this[330] + 52))(this[330], 260, v8);
  sub_401000(0x104u, (wchar_t *)v6, L"\"%s\"", v8);
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 0;
  pExecInfo.lpVerb = L"open";
  pExecInfo.lpFile = (LPCWSTR)v7;
  pExecInfo.lpParameters = (LPCWSTR)v6;
  pExecInfo.lpDirectory = 0;
  pExecInfo.hwnd = 0;
  pExecInfo.nShow = 5;
  return ShellExecuteExW(&pExecInfo);
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4CA7C0: using guessed type wchar_t aS_2[5];
// 4CA7CC: using guessed type wchar_t aOpen_5[5];
// 48FD90: using guessed type wchar_t var_61C[260];

//----- (0048FE90) --------------------------------------------------------
void __thiscall sub_48FE90(int this)
{
  HWND v2; // esi
  LPARAM lParam[13]; // [esp+Ch] [ebp-10444h] BYREF
  int v4; // [esp+40h] [ebp-10410h]
  LPVOID pv; // [esp+44h] [ebp-1040Ch] BYREF
  __int16 v6[32768]; // [esp+48h] [ebp-10408h] BYREF
  WCHAR Buffer[514]; // [esp+10048h] [ebp-408h] BYREF

  v4 = this;
  pv = 0;
  if ( sub_4ADAF0((const WCHAR *)(this + 3492), v6) < 0 )
  {
    LoadStringW(hInstance, 0x200Bu, Buffer, 512);
    MessageBoxW(*(HWND *)(this + 52), Buffer, L"Explorer++", 0x10u);
  }
  else
  {
    v2 = *(HWND *)(this + 3432);
    *(_DWORD *)(this + 60560) = 1;
    if ( v2 )
    {
      SendMessageW(v2, 0xBu, 0, 0);
      lParam[4] = 2;
      lParam[3] = 0;
      SendMessageW(v2, 0x102Bu, 0xFFFFFFFF, (LPARAM)lParam);
      SendMessageW(v2, 0xBu, 1u, 0);
    }
    SetFocus(*(HWND *)(this + 3432));
    sub_467810((LPITEMIDLIST *)&pv, (int)v6);
    (*(void (__thiscall **)(_DWORD, LPVOID))(**(_DWORD **)(v4 + 1320) + 328))(*(_DWORD *)(v4 + 1320), pv);
    CoTaskMemFree(pv);
  }
}
// 48FE90: using guessed type _WORD var_10408[32768];

//----- (0048FFD0) --------------------------------------------------------
HRESULT __userpurge sub_48FFD0@<eax>(int a1@<edi>, int a2, int a3, int a4, int a5)
{
  HRESULT v5; // esi
  LPVOID pv; // [esp+8h] [ebp-4h] BYREF

  pv = 0;
  v5 = sub_467810((LPITEMIDLIST *)&pv, a1);
  (*(void (__thiscall **)(int, LPVOID, int, int, int, _DWORD))(*(_DWORD *)(a2 + 28) + 40))(a2 + 28, pv, a3, a4, a5, 0);
  if ( v5 >= 0 )
    CoTaskMemFree(pv);
  return v5;
}

//----- (00490020) --------------------------------------------------------
HRESULT __userpurge sub_490020@<eax>(int a1@<edi>, int a2, int a3)
{
  HRESULT v3; // esi
  LPVOID pv; // [esp+8h] [ebp-4h] BYREF

  pv = 0;
  v3 = sub_467810((LPITEMIDLIST *)&pv, a1);
  (*(void (__thiscall **)(int, LPVOID, int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a2 + 28) + 40))(
    a2 + 28,
    pv,
    a3,
    0,
    0,
    0);
  if ( v3 >= 0 )
    CoTaskMemFree(pv);
  return v3;
}

//----- (00490070) --------------------------------------------------------
LRESULT __userpurge sub_490070@<eax>(int a1@<esi>, int a2)
{
  __int16 lParam[512]; // [esp+8h] [ebp-404h] BYREF

  sub_401000(0x200u, (wchar_t *)lParam, L"Loading %s...", a2);
  SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 0, (LPARAM)lParam);
  SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 1u, (LPARAM)&unk_4CA6B8);
  return SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 2u, (LPARAM)&unk_4CA6BC);
}
// 4CA69C: using guessed type wchar_t aLoadingS[14];
// 490070: using guessed type wchar_t lParam[512];

//----- (004900F0) --------------------------------------------------------
HWND __thiscall sub_4900F0(int this)
{
  HWND result; // eax
  WCHAR *v3; // eax
  int v4; // edx
  WCHAR v5; // cx
  HRESULT v6; // esi
  LPVOID pv; // [esp+8h] [ebp-620h] BYREF
  __int16 v9[260]; // [esp+Ch] [ebp-61Ch] BYREF
  WCHAR v10[260]; // [esp+214h] [ebp-414h] BYREF
  WCHAR pszPath[260]; // [esp+41Ch] [ebp-20Ch] BYREF

  result = (HWND)SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 1);
  if ( result != HWND_MESSAGE|0x2 )
  {
    (*(void (__thiscall **)(_DWORD, HWND, __int16 *))(**(_DWORD **)(this + 1320) + 48))(
      *(_DWORD *)(this + 1320),
      result,
      v9);
    result = (HWND)sub_4AD8F0(*(_DWORD *)(this + 52), this, (const WCHAR *)v9, 0, v10);
    if ( !result )
    {
      v3 = pszPath;
      v4 = 260;
      while ( v4 != -2147483386 )
      {
        v5 = *(v3 - 260);
        if ( !v5 )
          break;
        *v3++ = v5;
        if ( !--v4 )
        {
          --v3;
          break;
        }
      }
      *v3 = 0;
      PathRemoveFileSpecW(pszPath);
      pv = 0;
      v6 = sub_467810((LPITEMIDLIST *)&pv, (int)pszPath);
      result = (HWND)(*(int (__thiscall **)(int, LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)(this + 28) + 40))(
                       this + 28,
                       pv,
                       0,
                       1,
                       1,
                       0);
      if ( v6 >= 0 )
      {
        CoTaskMemFree(pv);
        PathStripPathW(v10);
        (*(void (__thiscall **)(_DWORD, WCHAR *))(**(_DWORD **)(this + 1320) + 116))(*(_DWORD *)(this + 1320), v10);
        return SetFocus(*(HWND *)(this + 3432));
      }
    }
  }
  return result;
}
// 490193: conditional instruction was optimized away because edx.4!=0
// 4900F0: using guessed type WCHAR var_61C[260];

//----- (00490280) --------------------------------------------------------
void __thiscall sub_490280(int this)
{
  LRESULT v2; // eax
  HRESULT v3; // edi
  bool v4; // sf
  HRESULT v5; // edi
  HRESULT v6; // esi
  int v7; // [esp+Ch] [ebp-214h]
  LPVOID pv; // [esp+10h] [ebp-210h] BYREF
  WCHAR pszPath[260]; // [esp+14h] [ebp-20Ch] BYREF

  v2 = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 3);
  if ( v2 != -1 )
  {
    (*(void (__thiscall **)(_DWORD, LRESULT, WCHAR *))(**(_DWORD **)(this + 1320) + 48))(
      *(_DWORD *)(this + 1320),
      v2,
      pszPath);
    if ( PathIsDirectoryW(pszPath) )
    {
      pv = 0;
      v3 = sub_467810((LPITEMIDLIST *)&pv, (int)pszPath);
      (*(void (__thiscall **)(int, LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)(this + 28) + 40))(
        this + 28,
        pv,
        0,
        1,
        1,
        0);
      v4 = v3 < 0;
      goto LABEL_6;
    }
  }
  pv = 0;
  v5 = sub_467810((LPITEMIDLIST *)&pv, this + 4532);
  v7 = this + 28;
  (*(void (__stdcall **)(LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)(this + 28) + 40))(pv, 0, 1, 1, 0);
  if ( v5 < 0 )
  {
    pv = 0;
    v6 = sub_467810((LPITEMIDLIST *)&pv, this + 4012);
    (*(void (__thiscall **)(int, LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)v7 + 40))(v7, pv, 0, 1, 1, 0);
    v4 = v6 < 0;
LABEL_6:
    if ( v4 )
      return;
  }
  CoTaskMemFree(pv);
}

//----- (004903B0) --------------------------------------------------------
void sub_4903B0()
{
  int *v0; // eax
  int *v1; // edi
  DWORD CurrentProcessId; // eax
  HANDLE v3; // esi
  char **v4; // eax
  int *v5; // eax
  int *v6; // esi
  char **v7[2]; // [esp-Ch] [ebp-46Ch] BYREF
  int v8; // [esp-4h] [ebp-464h]
  char ***v9; // [esp+14h] [ebp-44Ch]
  int pExceptionObject[3]; // [esp+18h] [ebp-448h] BYREF
  char *v11[5]; // [esp+24h] [ebp-43Ch] BYREF
  int *v12; // [esp+38h] [ebp-428h] BYREF
  int v13; // [esp+3Ch] [ebp-424h]
  char *v14; // [esp+44h] [ebp-41Ch] BYREF
  WCHAR Buffer[256]; // [esp+48h] [ebp-418h] BYREF
  char v16[520]; // [esp+248h] [ebp-218h] BYREF
  int v17; // [esp+45Ch] [ebp-4h]

  v13 = 0;
  v0 = (int *)operator new(0x1Cu);
  v1 = v0;
  if ( !v0 )
  {
    v14 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v0 = (int)v0;
  v12 = v0;
  v0[1] = (int)v0;
  v17 = 0;
  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  if ( v3 )
  {
    GetModuleFileNameExW(v3, 0, v16, 260);
    CloseHandle(v3);
  }
  LoadStringW(hInstance, 0x84Cu, Buffer, 256);
  v11[0] = (char *)Buffer;
  v8 = v1[1];
  v11[1] = v16;
  v11[2] = (char *)L"-open_new_tab";
  v11[3] = v16;
  v11[4] = (char *)1;
  v4 = sub_416060(v11, (char *)v1, v8);
  v1[1] = (int)v4;
  *(_DWORD *)v4[1] = v4;
  v9 = v7;
  v13 = 1;
  sub_415E50(v7, &v12);
  sub_4678E0(v7[0], (int)v7[1]);
  v5 = (int *)*v1;
  *v1 = (int)v1;
  v1[1] = (int)v1;
  if ( v5 != v1 )
  {
    do
    {
      v6 = (int *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != v1 );
  }
  operator delete(v1);
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CA4D4: using guessed type wchar_t aOpenNewTab_0[14];

//----- (00490550) --------------------------------------------------------
int __usercall sub_490550@<eax>(int a1@<esi>)
{
  HRESULT v1; // edi
  LPVOID pv; // [esp+8h] [ebp-210h] BYREF
  WCHAR pszPath[260]; // [esp+Ch] [ebp-20Ch] BYREF

  (*(void (__thiscall **)(_DWORD, int, WCHAR *))(**(_DWORD **)(a1 + 1320) + 52))(*(_DWORD *)(a1 + 1320), 260, pszPath);
  PathStripPathW(pszPath);
  pv = 0;
  v1 = sub_467810((LPITEMIDLIST *)&pv, (int)&unk_4CA7D8);
  (*(void (__thiscall **)(int, LPVOID, int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
    a1 + 28,
    pv,
    8193,
    0,
    0,
    0);
  if ( v1 >= 0 )
    CoTaskMemFree(pv);
  return (*(int (__thiscall **)(_DWORD, WCHAR *))(**(_DWORD **)(a1 + 1320) + 116))(*(_DWORD *)(a1 + 1320), pszPath);
}

//----- (00490600) --------------------------------------------------------
void __stdcall sub_490600(int a1)
{
  HRESULT v1; // edi
  HRESULT v2; // edi
  LPVOID pv; // [esp+Ch] [ebp-4h] BYREF

  pv = 0;
  v1 = sub_467810((LPITEMIDLIST *)&pv, a1 + 4532);
  (*(void (__thiscall **)(int, LPVOID, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
    a1 + 28,
    pv,
    0,
    0,
    0,
    0);
  if ( v1 >= 0
    || (pv = 0,
        v2 = sub_467810((LPITEMIDLIST *)&pv, a1 + 4012),
        (*(void (__thiscall **)(int, LPVOID, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
          a1 + 28,
          pv,
          0,
          0,
          0,
          0),
        v2 >= 0) )
  {
    CoTaskMemFree(pv);
  }
}

//----- (00490690) --------------------------------------------------------
void __stdcall sub_490690(int a1)
{
  HRESULT v1; // esi
  LPVOID pv; // [esp+Ch] [ebp-4h] BYREF

  pv = 0;
  v1 = sub_467810((LPITEMIDLIST *)&pv, (int)&unk_4CA6DC);
  (*(void (__thiscall **)(int, LPVOID, int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
    a1 + 28,
    pv,
    32769,
    0,
    0,
    0);
  if ( v1 >= 0 )
    CoTaskMemFree(pv);
}

//----- (004906F0) --------------------------------------------------------
void __stdcall sub_4906F0(int a1)
{
  HRESULT v1; // esi
  LPVOID pv; // [esp+Ch] [ebp-4h] BYREF

  pv = 0;
  v1 = sub_467810((LPITEMIDLIST *)&pv, (int)&unk_4CA6D8);
  (*(void (__thiscall **)(int, LPVOID, int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
    a1 + 28,
    pv,
    16385,
    0,
    0,
    0);
  if ( v1 >= 0 )
    CoTaskMemFree(pv);
}

//----- (00490750) --------------------------------------------------------
int __usercall sub_490750@<eax>(_DWORD *a1@<edi>)
{
  DWORD v1; // esi
  HWND v2; // ebx
  HMODULE ModuleHandleW; // eax
  _DWORD *v4; // esi
  int result; // eax
  int v6; // ebx
  _DWORD *v7; // eax
  int pExceptionObject[4]; // [esp+Ch] [ebp-20h] BYREF
  char *v9[4]; // [esp+1Ch] [ebp-10h] BYREF

  if ( a1[14821] )
    dword_4E5CDC |= 0x10000000u;
  v1 = dword_4E5CDC;
  v2 = (HWND)a1[13];
  ModuleHandleW = GetModuleHandleW(0);
  a1[14] = CreateWindowExW(0, L"msctls_statusbar32", &word_4C3094, v1, 0, 0, 0, 0, v2, 0, ModuleHandleW, 0);
  v4 = operator new(0x1Cu);
  pExceptionObject[3] = (int)v4;
  result = 0;
  v9[3] = 0;
  if ( v4 )
  {
    v6 = a1[14];
    v4[4] = 0;
    v7 = operator new(0x24u);
    if ( !v7 )
    {
      v9[0] = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v9);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v4[3] = v7;
    *v7 = v7;
    result = v4[3];
    *(_DWORD *)(result + 4) = result;
    *v4 = v6;
    *((_BYTE *)v4 + 24) = 0;
    v4[1] = 0;
  }
  else
  {
    v4 = 0;
  }
  a1[854] = v4;
  return result;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00490840) --------------------------------------------------------
int __userpurge sub_490840@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // ecx
  _DWORD *v5; // ecx
  _DWORD *v6; // edx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // ecx
  int v11; // [esp+0h] [ebp-4h] BYREF

  v11 = a1;
  v4 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v4 + 24))(v4, &v11);
  v5 = *(_DWORD **)(a3 + 5640);
  v6 = (_DWORD *)*v5;
  v7 = (_DWORD *)*v5;
  if ( (_DWORD *)*v5 != v5 )
  {
    v11 = a2;
    do
    {
      if ( v7[2] == a2 )
        break;
      v7 = (_DWORD *)*v7;
    }
    while ( v7 != v5 );
  }
  if ( a4 )
  {
    if ( v7 == (_DWORD *)v5[1] )
      v8 = v6;
    else
      v8 = (_DWORD *)*v7;
  }
  else if ( v7 == v6 )
  {
    v8 = (_DWORD *)v5[1];
  }
  else
  {
    v8 = (_DWORD *)v7[1];
  }
  v9 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 20))(v9, v8[2]);
}

//----- (004908C0) --------------------------------------------------------
int __usercall sub_4908C0@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ecx
  _DWORD *v4; // ecx
  _DWORD *v5; // edx
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // ecx
  int v10; // [esp+0h] [ebp-4h] BYREF

  v10 = a1;
  v3 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v3 + 24))(v3, &v10);
  v4 = *(_DWORD **)(a3 + 5640);
  v5 = (_DWORD *)*v4;
  v6 = (_DWORD *)*v4;
  if ( (_DWORD *)*v4 != v4 )
  {
    v10 = a2;
    do
    {
      if ( v6[2] == a2 )
        break;
      v6 = (_DWORD *)*v6;
    }
    while ( v6 != v4 );
  }
  if ( v6 == (_DWORD *)v4[1] )
    v7 = v5;
  else
    v7 = (_DWORD *)*v6;
  v8 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 20))(v8, v7[2]);
}

//----- (00490940) --------------------------------------------------------
char **__usercall sub_490940@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5DEC[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5DE8[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 6 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5DE8: using guessed type int dword_4E5DE8[];
// 4E5DEC: using guessed type int dword_4E5DEC[];

//----- (004909E0) --------------------------------------------------------
char **__usercall sub_4909E0@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5DBC[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5DB8[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 12 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5DB8: using guessed type int dword_4E5DB8[];
// 4E5DBC: using guessed type int dword_4E5DBC[];

//----- (00490A80) --------------------------------------------------------
char **__usercall sub_490A80@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5D74[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5D70[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 18 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5D70: using guessed type int dword_4E5D70[];
// 4E5D74: using guessed type int dword_4E5D74[];

//----- (00490B20) --------------------------------------------------------
char **__usercall sub_490B20@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5D2C[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5D28[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 18 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5D28: using guessed type int dword_4E5D28[];
// 4E5D2C: using guessed type int dword_4E5D2C[];

//----- (00490BC0) --------------------------------------------------------
char **__usercall sub_490BC0@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5CE4[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5CE0[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 18 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5CE0: using guessed type int dword_4E5CE0[];
// 4E5CE4: using guessed type int dword_4E5CE4[];

//----- (00490C60) --------------------------------------------------------
char **__usercall sub_490C60@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5CC8[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5CC4[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 6 );
  return result;
}
// 4E5A68: using guessed type int dword_4E5A68[];
// 4E5CC4: using guessed type int dword_4E5CC4[];
// 4E5CC8: using guessed type int dword_4E5CC8[];

//----- (00490D00) --------------------------------------------------------
char **__usercall sub_490D00@<eax>(int a1@<ebx>)
{
  _DWORD *v1; // eax
  unsigned int v2; // edi
  _DWORD *v3; // esi
  char *v4; // ecx
  char *v5; // edx
  char *v6; // eax
  char **result; // eax
  int v8; // ecx
  int v9; // [esp-4h] [ebp-1Ch]
  char *v10[3]; // [esp+8h] [ebp-10h] BYREF
  char *v11; // [esp+14h] [ebp-4h]

  v1 = **(_DWORD ***)a1;
  **(_DWORD **)a1 = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = *(_DWORD *)a1;
  v2 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  if ( v1 != *(_DWORD **)a1 )
  {
    do
    {
      v3 = (_DWORD *)*v1;
      operator delete(v1);
      v1 = v3;
    }
    while ( v3 != *(_DWORD **)a1 );
  }
  do
  {
    v4 = (char *)dword_4E5A64[v2];
    v5 = (char *)dword_4E5A68[v2];
    v10[0] = (char *)dword_4E5A60[v2];
    v6 = *(char **)a1;
    v10[1] = v4;
    v9 = *((_DWORD *)v6 + 1);
    v10[2] = v5;
    v11 = v6;
    result = sub_41EEB0(v10, v6, v9);
    v8 = *(_DWORD *)(a1 + 4);
    if ( v8 == 357913940 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(a1 + 4) = v8 + 1;
    *((_DWORD *)v11 + 1) = result;
    v2 += 3;
    *(_DWORD *)result[1] = result;
  }
  while ( v2 < 153 );
  return result;
}
// 4E5A60: using guessed type int dword_4E5A60[];
// 4E5A64: using guessed type int dword_4E5A64[];
// 4E5A68: using guessed type int dword_4E5A68[];

//----- (00490DF0) --------------------------------------------------------
void __fastcall sub_490DF0(int a1, int a2)
{
  int v2; // eax
  void *v3; // edi
  LPARAM dwInitParam[3]; // [esp+8h] [ebp-40h] BYREF
  unsigned __int16 v5; // [esp+14h] [ebp-34h]
  HWND hWndParent; // [esp+18h] [ebp-30h]
  int v7; // [esp+20h] [ebp-28h]
  void *v8; // [esp+34h] [ebp-14h]

  if ( a1 )
    v2 = a1 + 28;
  else
    v2 = 0;
  sub_476BD0(*(_DWORD *)(a1 + 52), a2, (int)dwInitParam, v2);
  if ( !v7 )
    DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v5, hWndParent, DialogFunc, (LPARAM)dwInitParam);
  dwInitParam[0] = (LPARAM)&CBaseDialog::`vftable';
  v3 = v8;
  if ( v8 )
  {
    sub_4AAAD0((int)v8);
    operator delete(v3);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (00490E60) --------------------------------------------------------
void __usercall sub_490E60(_DWORD *a1@<ecx>, _DWORD *a2@<edi>)
{
  int v3; // eax
  _DWORD *v4; // esi
  _DWORD *v5; // eax

  a1[1413] = 0;
  v3 = sub_48F8E0();
  a1[1413] = v3;
  if ( v3 )
  {
    v4 = operator new(0x1Cu);
    if ( v4 )
    {
      *v4 = &Explorerplusplus::CLoadSaveXML::`vftable';
      v4[1] = 1;
      v4[2] = a1;
      v4[3] = 1;
      sub_46CAE0((int)v4);
    }
    else
    {
      v4 = 0;
    }
    *a2 = v4;
    a1[14839] = 1;
  }
  else
  {
    v5 = operator new(0xCu);
    if ( v5 )
    {
      *v5 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
      v5[1] = 1;
      v5[2] = a1;
    }
    else
    {
      v5 = 0;
    }
    *a2 = v5;
  }
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 16))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 12))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 24))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 28))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 32))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 36))(*a2);
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 40))(*a2);
  if ( !a1[1404] )
    a1[1404] = 208;
  if ( (int)a1[1396] < 70 )
    a1[1396] = 90;
  sub_495530(a1);
  sub_4959C0((int)a1);
}
// 4CBD1C: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';
// 4CC344: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (00490FA0) --------------------------------------------------------
void __usercall sub_490FA0(int a1@<edi>)
{
  HMODULE v1; // eax
  FARPROC ProcAddress; // esi
  DWORD v3; // eax
  int v4; // eax
  HKEY v5; // ebx
  int v6; // eax
  int v7; // eax
  LRESULT v8; // ebx
  signed int i; // esi
  HWND v10; // [esp-10h] [ebp-C8h]
  int lParam[6]; // [esp+8h] [ebp-B0h] BYREF
  int v12; // [esp+20h] [ebp-98h]
  DWORD cbData; // [esp+24h] [ebp-94h] BYREF
  DWORD Type; // [esp+28h] [ebp-90h] BYREF
  HKEY phkResult; // [esp+2Ch] [ebp-8Ch] BYREF
  WCHAR String[32]; // [esp+30h] [ebp-88h] BYREF
  __int16 Data[34]; // [esp+70h] [ebp-48h] BYREF

  v1 = sub_40A920(L"shell32.dll");
  ProcAddress = GetProcAddress(v1, (LPCSTR)0x294);
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Control Panel\\Desktop\\WindowMetrics", 0, 0x2001Fu, &phkResult) )
  {
    cbData = 32;
    RegQueryValueExW(phkResult, L"Shell Icon Size", 0, &Type, (LPBYTE)Data, &cbData);
    v3 = cbData;
    if ( cbData && Type == 1 )
    {
      if ( String[cbData + 31] )
      {
        if ( cbData >= 0x20 )
          v3 = 32;
        Data[v3] = 0;
      }
    }
    else
    {
      Data[0] = 0;
    }
    v4 = _wtoi((const wchar_t *)Data);
    sub_401000(0x20u, String, L"%d", v4 + 1);
    v5 = phkResult;
    v6 = lstrlenW(String);
    RegSetValueExW(v5, L"Shell Icon Size", 0, 1u, (const BYTE *)String, 2 * v6);
    if ( ProcAddress )
      ((void (__stdcall *)(int))ProcAddress)(1);
    Type = (DWORD)phkResult;
    v7 = lstrlenW((LPCWSTR)Data);
    RegSetValueExW((HKEY)Type, L"Shell Icon Size", 0, 1u, (const BYTE *)Data, 2 * v7);
    if ( ProcAddress )
      ((void (__stdcall *)(_DWORD))ProcAddress)(0);
    RegCloseKey(phkResult);
  }
  v8 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  for ( i = 0; i < v8; ++i )
  {
    v10 = *(HWND *)(a1 + 68);
    lParam[0] = 8;
    SendMessageW(v10, 0x133Cu, i, (LPARAM)lParam);
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v12 + 916) + 332))(*(_DWORD *)(a1 + 4 * v12 + 916));
  }
  sub_41E920(*(_DWORD *)(a1 + 1328));
  sub_4A1E40(a1);
  sub_4AAFA0((_DWORD **)a1);
}
// 4CA778: using guessed type wchar_t aD_11[3];
// 490FA0: using guessed type wchar_t Data[34];
// 490FA0: using guessed type LPARAM lParam[6];

//----- (00491180) --------------------------------------------------------
HINSTANCE __thiscall sub_491180(_DWORD *this)
{
  _DWORD *v1; // ebx
  DWORD CurrentProcessId; // eax
  HANDLE v3; // edi
  HINSTANCE result; // eax
  DWORD v5; // eax
  HANDLE v6; // edi
  WCHAR *v7; // eax
  int v8; // edx
  WCHAR v9; // cx
  WCHAR *v10; // eax
  int v11; // edx
  WCHAR v12; // cx
  unsigned __int16 v13; // bx
  int v14; // edx
  WCHAR *v15; // eax
  WCHAR v16; // cx
  HMODULE ModuleHandleW; // eax
  UINT v18; // [esp-Ch] [ebp-C9Ch]
  HINSTANCE hFindFile; // [esp+Ch] [ebp-C84h]
  int v20; // [esp+10h] [ebp-C80h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-C78h] BYREF
  WCHAR pszMore[260]; // [esp+268h] [ebp-A28h] BYREF
  WCHAR FileName[260]; // [esp+470h] [ebp-820h] BYREF
  WCHAR pszPath[260]; // [esp+678h] [ebp-618h] BYREF
  WCHAR LibFileName[260]; // [esp+880h] [ebp-410h] BYREF
  WCHAR Buffer[258]; // [esp+A88h] [ebp-208h] BYREF

  v1 = this;
  if ( dword_4EF4DC )
  {
    CurrentProcessId = GetCurrentProcessId();
    v3 = OpenProcess(0x410u, 0, CurrentProcessId);
    if ( v3 )
    {
      GetModuleFileNameExW(v3, 0, pszPath, 260);
      CloseHandle(v3);
    }
    PathRemoveFileSpecW(pszPath);
    sub_401000(0x104u, pszMore, L"Explorer++%2s.dll", &unk_4EF3E0);
    PathAppendW(pszPath, pszMore);
    this[1393] = (unsigned __int16)sub_468240(pszPath);
    v1 = this;
  }
  else if ( !this[1402] )
  {
    this[1393] = GetUserDefaultUILanguage() & 0x3FF;
  }
  if ( v1[1393] == 9 )
  {
    result = GetModuleHandleW(0);
    hInstance = result;
    goto LABEL_55;
  }
  v5 = GetCurrentProcessId();
  v6 = OpenProcess(0x410u, 0, v5);
  if ( v6 )
  {
    GetModuleFileNameExW(v6, 0, pszPath, 260);
    CloseHandle(v6);
  }
  PathRemoveFileSpecW(pszPath);
  v7 = FileName;
  v8 = 260;
  while ( v8 != -2147483386 )
  {
    v9 = v7[260];
    if ( !v9 )
      break;
    *v7++ = v9;
    if ( !--v8 )
    {
      --v7;
      break;
    }
  }
  *v7 = 0;
  PathAppendW(FileName, L"Explorer++??.dll");
  result = (HINSTANCE)FindFirstFileW(FileName, &FindFileData);
  hFindFile = result;
  if ( result != (HINSTANCE)-1 )
  {
    v10 = LibFileName;
    v11 = 260;
    while ( v11 != -2147483386 )
    {
      v12 = *(v10 - 260);
      if ( !v12 )
        break;
      *v10++ = v12;
      if ( !--v11 )
      {
        --v10;
        break;
      }
    }
    *v10 = 0;
    PathAppendW(LibFileName, FindFileData.cFileName);
    v13 = sub_468240(LibFileName);
    v20 = 0;
    if ( v13 == this[1393] )
    {
      if ( sub_494260(LibFileName) )
        goto LABEL_24;
    }
    else
    {
      if ( !FindNextFileW(hFindFile, &FindFileData) )
        goto LABEL_36;
      while ( 1 )
      {
        v14 = 260;
        v15 = LibFileName;
        while ( v14 != -2147483386 )
        {
          v16 = *(v15 - 260);
          if ( !v16 )
            break;
          *v15++ = v16;
          if ( !--v14 )
          {
            --v15;
            break;
          }
        }
        *v15 = 0;
        PathAppendW(LibFileName, FindFileData.cFileName);
        v13 = sub_468240(LibFileName);
        if ( v13 == this[1393] )
          break;
        if ( !FindNextFileW(hFindFile, &FindFileData) )
          goto LABEL_36;
      }
      if ( sub_494260(LibFileName) )
      {
LABEL_24:
        hInstance = sub_40A920(LibFileName);
LABEL_36:
        result = (HINSTANCE)FindClose(hFindFile);
        if ( v20 )
        {
          switch ( v13 )
          {
            case 4u:
              v18 = 232;
              break;
            case 5u:
              v18 = 233;
              break;
            case 6u:
              v18 = 234;
              break;
            case 7u:
              v18 = 237;
              break;
            case 0xAu:
              v18 = 245;
              break;
            case 0xCu:
              v18 = 236;
              break;
            case 0x10u:
              v18 = 238;
              break;
            case 0x11u:
              v18 = 239;
              break;
            case 0x12u:
              v18 = 240;
              break;
            case 0x13u:
              v18 = 235;
              break;
            case 0x14u:
              v18 = 241;
              break;
            case 0x16u:
              v18 = 242;
              break;
            case 0x18u:
              v18 = 243;
              break;
            case 0x19u:
              v18 = 244;
              break;
            default:
              v18 = 2162;
              break;
          }
          ModuleHandleW = GetModuleHandleW(0);
          LoadStringW(ModuleHandleW, v18, Buffer, 256);
          result = (HINSTANCE)MessageBoxW(0, Buffer, L"Explorer++", 0x30u);
        }
        v1 = this;
        goto LABEL_55;
      }
    }
    v20 = 1;
    goto LABEL_36;
  }
LABEL_55:
  if ( !hInstance )
  {
    result = GetModuleHandleW(0);
    hInstance = result;
    v1[1393] = 9;
  }
  return result;
}
// 4912E4: conditional instruction was optimized away because edx.4!=0
// 491360: conditional instruction was optimized away because edx.4!=0
// 491410: conditional instruction was optimized away because edx.4!=0
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4CA51C: using guessed type wchar_t aExplorer2sDll[18];
// 4EF4DC: using guessed type int dword_4EF4DC;

//----- (004916A0) --------------------------------------------------------
int __fastcall sub_4916A0(int a1, _DWORD *a2)
{
  _DWORD *v4; // edi
  int v5; // ebx
  int v6; // esi
  const WCHAR *p_lpString; // eax
  int v9; // [esp+14h] [ebp-264h]
  _DWORD *v10; // [esp+18h] [ebp-260h]
  void *v12[7]; // [esp+20h] [ebp-258h] BYREF
  LPCWSTR lpString; // [esp+3Ch] [ebp-23Ch] BYREF
  int v14; // [esp+4Ch] [ebp-22Ch]
  unsigned int v15; // [esp+50h] [ebp-228h]
  int v16; // [esp+58h] [ebp-220h]
  int v17; // [esp+5Ch] [ebp-21Ch]
  WCHAR pszPath[260]; // [esp+60h] [ebp-218h] BYREF
  int v19; // [esp+274h] [ebp-4h]

  if ( *a2 != *(_DWORD *)(a1 + 3432) )
    return 0;
  if ( a2[3] == 1 )
    return 32;
  if ( a2[3] != 65537 )
    return 32;
  v9 = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 1320) + 124))(*(_DWORD *)(a1 + 1320), a2[9]);
  (*(void (__thiscall **)(_DWORD, _DWORD, WCHAR *))(**(_DWORD **)(a1 + 1320) + 48))(
    *(_DWORD *)(a1 + 1320),
    a2[9],
    pszPath);
  PathStripPathW(pszPath);
  v4 = *(_DWORD **)(a1 + 36);
  v10 = *(_DWORD **)(a1 + 40);
  if ( v4 == v10 )
    return 32;
  while ( 1 )
  {
    sub_409890(v4, (int)v12);
    v5 = 0;
    v19 = 0;
    v6 = 0;
    if ( !v14 )
      goto LABEL_9;
    p_lpString = lpString;
    if ( v15 < 8 )
      p_lpString = (const WCHAR *)&lpString;
    if ( sub_469A50(p_lpString, (int)pszPath, 1) )
LABEL_9:
      v6 = 1;
    if ( !v16 || (v16 & v9) != 0 )
      v5 = 1;
    if ( v6 && v5 )
      break;
    v19 = -1;
    if ( v15 >= 8 )
      operator delete((void *)lpString);
    v15 = 7;
    v14 = 0;
    LOWORD(lpString) = 0;
    if ( v12[5] >= (void *)8 )
      operator delete(v12[0]);
    v4 += 16;
    if ( v4 == v10 )
      return 32;
  }
  a2[12] = v17;
  sub_409920((int)v12);
  return 2;
}

//----- (00491870) --------------------------------------------------------
LRESULT __usercall sub_491870@<eax>(int a1@<esi>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ebx
  int v3; // eax
  void **v4; // ecx
  int v5; // eax
  int v6; // ecx
  BOOL v7; // eax
  HWND v9; // [esp-10h] [ebp-78h]
  LPARAM lParam[10]; // [esp+10h] [ebp-58h] BYREF
  _DWORD *i; // [esp+38h] [ebp-30h]
  void *v12[5]; // [esp+3Ch] [ebp-2Ch] BYREF
  unsigned int v13; // [esp+50h] [ebp-18h]
  int v14; // [esp+64h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 60584) && OleIsCurrentClipboard(*(LPDATAOBJECT *)(a1 + 60584)) == 1 )
  {
    v1 = *(_DWORD **)(a1 + 61228);
    v2 = (_DWORD *)*v1;
    for ( i = v1; v2 != i; v2 = (_DWORD *)*v2 )
    {
      LOWORD(v12[0]) = 0;
      v13 = 7;
      v12[4] = 0;
      sub_4090E0((int)v12, v2 + 2, 0, 0xFFFFFFFF);
      v14 = 0;
      v3 = *(_DWORD *)(a1 + 61240);
      if ( *(_DWORD *)(a1 + 4 * v3 + 58872) )
      {
        v4 = (void **)v12[0];
        if ( v13 < 8 )
          v4 = v12;
        v5 = (*(int (__thiscall **)(_DWORD, void **))(**(_DWORD **)(a1 + 4 * v3 + 916) + 180))(
               *(_DWORD *)(a1 + 4 * v3 + 916),
               v4);
        if ( v5 != -1 )
        {
          v6 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 61240) + 916);
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 184))(v6, v5);
        }
      }
      v14 = -1;
      if ( v13 >= 8 )
        operator delete(v12[0]);
    }
    sub_40A140(a1 + 61228);
    if ( *(_DWORD *)(a1 + 60588) )
    {
      lParam[1] = *(_DWORD *)(a1 + 60588);
      v9 = *(HWND *)(a1 + 76);
      lParam[0] = 24;
      lParam[2] = 0;
      lParam[3] = 4;
      SendMessageW(v9, 0x113Fu, 0, (LPARAM)lParam);
      *(_DWORD *)(a1 + 60588) = 0;
    }
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 60584) + 8))(*(_DWORD *)(a1 + 60584));
    *(_DWORD *)(a1 + 60584) = 0;
  }
  v7 = !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 144))(*(_DWORD *)(a1 + 1320))
    && IsClipboardFormatAvailable(0xFu);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD3u, v7);
  return SendMessageW(*(HWND *)(a1 + 3440), 0x308u, 0, 0);
}

//----- (00491A30) --------------------------------------------------------
int __usercall sub_491A30@<eax>(int a1@<esi>)
{
  void **v1; // edi

  if ( *(_DWORD *)(a1 + 60584) && !OleIsCurrentClipboard(*(LPDATAOBJECT *)(a1 + 60584)) )
    OleFlushClipboard();
  QueueUserAPC(sub_48F9C0, *(HANDLE *)(a1 + 3420), 0);
  sub_409E60(*(_DWORD *)(a1 + 59976));
  sub_409E60(*(_DWORD *)(a1 + 59980));
  v1 = *(void ***)(a1 + 3416);
  if ( v1 )
  {
    sub_40A140((int)(v1 + 3));
    operator delete(v1[3]);
    operator delete(v1);
  }
  ChangeClipboardChain(*(HWND *)(a1 + 52), *(HWND *)(a1 + 3440));
  PostQuitMessage(0);
  return 0;
}

//----- (00491AC0) --------------------------------------------------------
void __thiscall sub_491AC0(void *this)
{
  void *v1; // edi
  _DWORD *v2; // eax
  void **v3; // esi
  void *v4; // eax
  UINT v5; // eax
  _DWORD *v6; // eax
  void **v7; // esi
  LPARAM i; // esi
  _DWORD *v9; // eax
  void **v10; // esi
  void **v11; // esi
  HGLOBAL v12; // eax
  void *v13; // esi
  void *v14; // eax
  void **v15; // ecx
  void **v16; // eax
  void *v17; // ecx
  void **v18; // esi
  HWND v19; // [esp-10h] [ebp-140h]
  int pExceptionObject[3]; // [esp+10h] [ebp-120h] BYREF
  void *v21; // [esp+1Ch] [ebp-114h] BYREF
  int v22; // [esp+20h] [ebp-110h]
  void *v23; // [esp+28h] [ebp-108h]
  LPARAM v24; // [esp+2Ch] [ebp-104h]
  WPARAM wParam; // [esp+30h] [ebp-100h] BYREF
  LPARAM lParam[6]; // [esp+34h] [ebp-FCh] BYREF
  void *v27[4]; // [esp+4Ch] [ebp-E4h] BYREF
  int v28; // [esp+5Ch] [ebp-D4h]
  unsigned int v29; // [esp+60h] [ebp-D0h]
  void *v30[4]; // [esp+68h] [ebp-C8h] BYREF
  int v31; // [esp+78h] [ebp-B8h]
  unsigned int v32; // [esp+7Ch] [ebp-B4h]
  void *Src[4]; // [esp+84h] [ebp-ACh] BYREF
  void *v34; // [esp+94h] [ebp-9Ch]
  unsigned int v35; // [esp+98h] [ebp-98h]
  WCHAR Buffer; // [esp+A0h] [ebp-90h] BYREF
  _BYTE v37[126]; // [esp+A2h] [ebp-8Eh] BYREF
  int v38; // [esp+12Ch] [ebp-4h]

  v1 = this;
  v23 = this;
  v22 = 0;
  v2 = operator new(0x14u);
  if ( !v2 )
  {
    wParam = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&wParam);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v21 = v2;
  *v2 = v2;
  *((_DWORD *)v21 + 1) = v21;
  v38 = 0;
  (*(void (__thiscall **)(_DWORD, void **))(**((_DWORD **)v1 + 330) + 312))(*((_DWORD *)v1 + 330), &v21);
  v35 = 7;
  v34 = 0;
  LOWORD(Src[0]) = 0;
  LOBYTE(v38) = 1;
  v3 = *(void ***)v21;
  v24 = 0;
  wParam = (WPARAM)v21;
  if ( v3 != v21 )
  {
    do
    {
      v4 = v3[2];
      pExceptionObject[2] = (int)v3[4];
      if ( v3[3] )
      {
        v5 = (*(int (__thiscall **)(int, void *))(*((_DWORD *)v1 + 7) + 24))((int)v1 + 28, v4);
        LoadStringW(hInstance, v5, &Buffer, 64);
        LOWORD(v30[0]) = 0;
        v32 = 7;
        v31 = 0;
        sub_4094F0(v30, (int)v37, &Buffer, wcslen(&Buffer));
        LOBYTE(v38) = 2;
        v6 = sub_4160E0((char *)L"\t", v27, v30);
        LOBYTE(v38) = 3;
        sub_406A00(Src, v6, 0, 0xFFFFFFFF);
        if ( v29 >= 8 )
          operator delete(v27[0]);
        LOBYTE(v38) = 1;
        v29 = 7;
        v28 = 0;
        LOWORD(v27[0]) = 0;
        if ( v32 >= 8 )
          operator delete(v30[0]);
        ++v24;
        v1 = v23;
      }
      v3 = (void **)*v3;
    }
    while ( v3 != (void **)wParam );
  }
  v7 = (void **)sub_402000(0, (unsigned int)v34 - 1, (int)v27, Src);
  if ( Src != v7 )
  {
    if ( v35 >= 8 )
      operator delete(Src[0]);
    v35 = 7;
    v34 = 0;
    LOWORD(Src[0]) = 0;
    if ( (unsigned int)v7[5] >= 8 )
    {
      Src[0] = *v7;
      *v7 = 0;
    }
    else
    {
      memcpy(Src, v7, 2 * ((_DWORD)v7[4] + 1));
    }
    v34 = v7[4];
    v35 = (unsigned int)v7[5];
    v7[5] = (void *)7;
    v7[4] = 0;
    *(_WORD *)v7 = 0;
  }
  LOBYTE(v38) = 1;
  if ( v29 >= 8 )
    operator delete(v27[0]);
  sub_415F40((char *)L"\r\n", Src, 2u);
  for ( wParam = SendMessageW(*((HWND *)v1 + 858), 0x100Cu, 0xFFFFFFFF, 2);
        wParam != -1;
        wParam = SendMessageW(*((HWND *)v1 + 858), 0x100Cu, wParam, 2) )
  {
    for ( i = 0; i < v24; ++i )
    {
      lParam[5] = (LPARAM)&Buffer;
      v19 = (HWND)*((_DWORD *)v1 + 858);
      lParam[2] = i;
      v27[0] = (void *)64;
      SendMessageW(v19, 0x1073u, wParam, (LPARAM)lParam);
      LOWORD(v30[0]) = 0;
      v32 = 7;
      v31 = 0;
      sub_4094F0(v30, (int)v37, &Buffer, wcslen(&Buffer));
      LOBYTE(v38) = 5;
      v9 = sub_4160E0((char *)L"\t", v27, v30);
      LOBYTE(v38) = 6;
      sub_406A00(Src, v9, 0, 0xFFFFFFFF);
      if ( v29 >= 8 )
        operator delete(v27[0]);
      LOBYTE(v38) = 1;
      v29 = 7;
      v28 = 0;
      LOWORD(v27[0]) = 0;
      if ( v32 >= 8 )
        operator delete(v30[0]);
      v1 = v23;
    }
    v10 = (void **)sub_402000(0, (unsigned int)v34 - 1, (int)v27, Src);
    if ( Src != v10 )
    {
      if ( v35 >= 8 )
        operator delete(Src[0]);
      v35 = 7;
      v34 = 0;
      LOWORD(Src[0]) = 0;
      if ( (unsigned int)v10[5] >= 8 )
      {
        Src[0] = *v10;
        *v10 = 0;
      }
      else
      {
        memcpy(Src, v10, 2 * (_DWORD)v10[4] + 2);
      }
      v34 = v10[4];
      v35 = (unsigned int)v10[5];
      v10[5] = (void *)7;
      v10[4] = 0;
      *(_WORD *)v10 = 0;
    }
    LOBYTE(v38) = 1;
    if ( v29 >= 8 )
      operator delete(v27[0]);
    sub_415F40((char *)L"\r\n", Src, 2u);
  }
  v11 = (void **)sub_402000(0, (unsigned int)v34 - 2, (int)v27, Src);
  if ( Src != v11 )
  {
    if ( v35 >= 8 )
      operator delete(Src[0]);
    v35 = 7;
    v34 = 0;
    LOWORD(Src[0]) = 0;
    if ( (unsigned int)v11[5] >= 8 )
    {
      Src[0] = *v11;
      *v11 = 0;
    }
    else
    {
      memcpy(Src, v11, 2 * (_DWORD)v11[4] + 2);
    }
    v34 = v11[4];
    v35 = (unsigned int)v11[5];
    v11[5] = (void *)7;
    v11[4] = 0;
    *(_WORD *)v11 = 0;
  }
  if ( v29 >= 8 )
    operator delete(v27[0]);
  if ( OpenClipboard(0) )
  {
    EmptyClipboard();
    v12 = GlobalAlloc(2u, 2 * (_DWORD)v34 + 2);
    v13 = v12;
    if ( v12 )
    {
      v14 = GlobalLock(v12);
      v15 = (void **)Src[0];
      if ( v35 < 8 )
        v15 = Src;
      memcpy_0(v14, v15, 2 * (_DWORD)v34 + 2);
      GlobalUnlock(v13);
      SetClipboardData(0xDu, v13);
    }
    CloseClipboard();
  }
  if ( v35 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v35 = 7;
  v34 = 0;
  v16 = *(void ***)v21;
  *(_DWORD *)v21 = v21;
  *((_DWORD *)v21 + 1) = v21;
  v17 = v21;
  v22 = 0;
  if ( v16 != v21 )
  {
    do
    {
      v18 = (void **)*v16;
      operator delete(v16);
      v17 = v21;
      v16 = v18;
    }
    while ( v18 != v21 );
  }
  operator delete(v17);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CA6E0: using guessed type wchar_t asc_4CA6E0[2];
// 4CA6E4: using guessed type wchar_t asc_4CA6E4[3];
// 4CA6EC: using guessed type wchar_t asc_4CA6EC[2];
// 4CA6F0: using guessed type wchar_t asc_4CA6F0[3];

//----- (004921A0) --------------------------------------------------------
void *__thiscall sub_4921A0(int this)
{
  void *result; // eax
  DWORD v3; // edi
  void *v4; // esi
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-241Ch] BYREF
  char Buffer[8192]; // [esp+10h] [ebp-2418h] BYREF
  char Src[520]; // [esp+2010h] [ebp-418h] BYREF
  WCHAR FileName[262]; // [esp+2218h] [ebp-210h] BYREF

  memset(FileName, 0, 520);
  result = (void *)sub_468F10(*(HWND *)(this + 52), (const WCHAR *)(this + 3492), FileName);
  if ( result )
  {
    result = (void *)SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 1);
    if ( result != (void *)-1 )
    {
      (*(void (__thiscall **)(_DWORD, void *, char *))(**(_DWORD **)(this + 1320) + 48))(
        *(_DWORD *)(this + 1320),
        result,
        Src);
      result = (void *)sub_46B010((int)Buffer);
      v3 = (DWORD)result;
      if ( result != (void *)-1 )
      {
        result = CreateFileW(FileName, 0x40000000u, 0, 0, 4u, 0, 0);
        v4 = result;
        if ( result != (void *)-1 )
        {
          WriteFile(result, Buffer, v3, &NumberOfBytesWritten, 0);
          return (void *)CloseHandle(v4);
        }
      }
    }
  }
  return result;
}
// 4921A0: using guessed type char Src[520];

//----- (00492290) --------------------------------------------------------
void __usercall sub_492290(int a1@<eax>, int a2@<ecx>)
{
  HWND v4; // [esp-8h] [ebp-20h]
  struct tagPOINT Point; // [esp+10h] [ebp-8h] BYREF

  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 56))(*(_DWORD *)(a2 + 1320));
  Point.x = (__int16)a1;
  v4 = *(HWND *)(a2 + 64);
  Point.y = SHIWORD(a1);
  ClientToScreen(v4, &Point);
  sub_49E480(&Point.x, a2);
}

//----- (004922E0) --------------------------------------------------------
void __thiscall sub_4922E0(int this)
{
  HWND Focus; // eax
  HWND v3; // ecx
  WPARAM v4; // eax
  int v5; // ecx
  int v6; // eax
  HWND v7; // ecx
  LPARAM v8; // esi
  HWND v9; // [esp-10h] [ebp-48h]
  HWND v10; // [esp-8h] [ebp-40h]
  int v11; // [esp+10h] [ebp-28h] BYREF
  int v12; // [esp+14h] [ebp-24h] BYREF
  DWORD dwErrCode; // [esp+18h] [ebp-20h] BYREF
  struct tagPOINT Point; // [esp+1Ch] [ebp-1Ch] BYREF
  LPARAM v15; // [esp+24h] [ebp-14h] BYREF
  LONG v16; // [esp+28h] [ebp-10h]
  struct tagPOINT lParam; // [esp+2Ch] [ebp-Ch] BYREF

  Focus = GetFocus();
  v3 = *(HWND *)(this + 3432);
  if ( Focus == v3 )
  {
    Point.x = 0;
    Point.y = 0;
    if ( SendMessageW(v3, 0x1032u, 0, 0) )
    {
      v4 = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 1);
      if ( v4 != -1 )
      {
        SendMessageW(*(HWND *)(this + 3432), 0x1010u, v4, (LPARAM)&lParam);
        ClientToScreen(*(HWND *)(this + 3432), &lParam);
        v5 = *(_DWORD *)(this + 4 * *(_DWORD *)(this + 5620) + 516);
        (*(void (__thiscall **)(int, int *))(*(_DWORD *)v5 + 24))(v5, &v11);
        if ( v11 == 2 || v11 == 3 || v11 == 4 )
          v6 = SendMessageW(*(HWND *)(this + 3432), 0x1002u, 1u, 0);
        else
          v6 = SendMessageW(*(HWND *)(this + 3432), 0x1002u, 0, 0);
        sub_416200(v6, (int)&v12, (DWORD)&dwErrCode);
        Point.x = lParam.x + v12 / 2;
        Point.y = lParam.y + (int)dwErrCode / 2;
      }
      sub_49E480(&Point.x, this);
    }
    else
    {
      GetCursorPos(&Point);
      sub_49E480(&Point.x, this);
    }
  }
  else
  {
    v7 = *(HWND *)(this + 76);
    if ( Focus == v7 )
    {
      v8 = SendMessageW(v7, 0x110Au, 9u, 0);
      v9 = *(HWND *)(this + 76);
      v15 = v8;
      SendMessageW(v9, 0x1104u, 1u, (LPARAM)&v15);
      Point.x = v15;
      v10 = *(HWND *)(this + 76);
      Point.y = v16;
      ClientToScreen(v10, &Point);
      Point.y += (lParam.y - v16) / 2;
      if ( v8 )
        sub_478110(this, v8, (int)&Point);
    }
  }
}

//----- (00492490) --------------------------------------------------------
void __usercall sub_492490(int a1@<eax>)
{
  int v2; // eax

  sub_496BE0(a1);
  SendMessageW(*(HWND *)(a1 + 64), 0x8074u, 0, 0);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 292))(*(_DWORD *)(a1 + 1320));
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      sub_496160((_DWORD *)a1);
    }
    else if ( v2 > 1 )
    {
      sub_495FD0(a1);
    }
  }
  else
  {
    sub_4968D0(a1);
  }
}

//----- (004924F0) --------------------------------------------------------
void __thiscall sub_4924F0(HWND *this)
{
  HWND *v2; // eax
  __int16 v3; // cx
  void *v4[5]; // [esp+10h] [ebp-250h] BYREF
  unsigned int v5; // [esp+24h] [ebp-23Ch]
  void *v6[4]; // [esp+2Ch] [ebp-234h] BYREF
  int v7; // [esp+3Ch] [ebp-224h]
  unsigned int v8; // [esp+40h] [ebp-220h]
  unsigned __int16 Src[260]; // [esp+48h] [ebp-218h] BYREF
  int v10; // [esp+25Ch] [ebp-4h]

  qmemcpy(Src, L"Directory Listing.txt", 0x2Cu);
  memset(&Src[22], 0, 0x1DCu);
  if ( sub_468F10(this[13], (const WCHAR *)this + 1746, Src) )
  {
    v5 = 7;
    v4[4] = 0;
    LOWORD(v4[0]) = 0;
    sub_4094F0(v4, (int)Src, Src, wcslen(Src));
    v10 = 0;
    LOWORD(v6[0]) = 0;
    v2 = this + 873;
    v8 = 7;
    v7 = 0;
    do
    {
      v3 = *(_WORD *)v2;
      v2 = (HWND *)((char *)v2 + 2);
    }
    while ( v3 );
    sub_4094F0(v6, (int)this + 3494, this + 873, ((char *)v2 - ((char *)this + 3494)) >> 1);
    LOBYTE(v10) = 1;
    sub_4AE8C0(v6);
    if ( v8 >= 8 )
      operator delete(v6[0]);
    v8 = 7;
    v7 = 0;
    LOWORD(v6[0]) = 0;
    if ( v5 >= 8 )
      operator delete(v4[0]);
  }
}
// 4CA604: using guessed type wchar_t aDirectoryListi[22];

//----- (00492670) --------------------------------------------------------
void __usercall sub_492670(int a1@<eax>, int a2@<ecx>)
{
  HWND v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  WCHAR *v7; // edi
  LPARAM lParam[13]; // [esp+Ch] [ebp-34h] BYREF

  (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(a2 + 1320) + 52))(*(_DWORD *)(a2 + 1320), 260, a2 + 3492);
  SetCurrentDirectoryW((LPCWSTR)(a2 + 3492));
  sub_48FB60(a1, a2);
  sub_4A8290(a2);
  v4 = *(HWND *)(a2 + 3432);
  lParam[4] = 1;
  lParam[3] = 1;
  *(_DWORD *)(a2 + 60572) = 0;
  SendMessageW(v4, 0x102Bu, 0, (LPARAM)lParam);
  sub_4AC380(a2);
  if ( *(_DWORD *)(a2 + 59516) )
  {
    v5 = *(_DWORD **)(a2 + 59528);
    v6 = (_DWORD *)*v5;
    if ( (_DWORD *)*v5 != v5 )
    {
      do
      {
        if ( v6[4] == a1 )
          (*(void (__stdcall **)(_DWORD))(a2 + 59516))(v6[3]);
        v6 = (_DWORD *)*v6;
      }
      while ( v6 != *(_DWORD **)(a2 + 59528) );
    }
  }
  v7 = (WCHAR *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 56))(*(_DWORD *)(a2 + 1320));
  sub_4ABFC0(v7, *(_DWORD *)(a2 + 5620), a2, *(_DWORD *)(a2 + 5632));
  CoTaskMemFree(v7);
}

//----- (00492740) --------------------------------------------------------
void __usercall sub_492740(unsigned int a1@<eax>, int a2@<ecx>)
{
  WPARAM v3; // eax

  switch ( HIWORD(a1) & 0xFFF )
  {
    case 1:
      SendMessageW(*(HWND *)(a2 + 52), 0x1Fu, 0, 0);
      sub_4906F0(a2);
      break;
    case 2:
      SendMessageW(*(HWND *)(a2 + 52), 0x1Fu, 0, 0);
      sub_490690(a2);
      break;
    case 3:
      SendMessageW(*(HWND *)(a2 + 52), 0x1Fu, 0, 0);
      (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)(a2 + 28) + 16))(a2 + 28, *(_DWORD *)(a2 + 5620));
      break;
    case 0x1F:
      SendMessageW(*(HWND *)(a2 + 52), 0x1Fu, 0, 0);
      v3 = SendMessageW(*(HWND *)(a2 + 68), 0x130Bu, 0, 0);
      sub_479C50(a2, v3);
      break;
    case 0x22:
      sub_463F50((int *)(a2 + 59552));
      break;
    case 0x24:
      sub_4AC5F0(1, a2);
      break;
    case 0x25:
      sub_4AC5F0(0, a2);
      break;
    case 0x26:
      sub_4AC4A0(a2);
      break;
    default:
      return;
  }
}

//----- (00492870) --------------------------------------------------------
int __thiscall sub_492870(_DWORD *this, unsigned int a2)
{
  int result; // eax
  HWND v4; // [esp-10h] [ebp-24h]
  LPARAM lParam[3]; // [esp+4h] [ebp-10h] BYREF

  lParam[1] = HIWORD(a2);
  v4 = (HWND)this[17];
  lParam[0] = (unsigned __int16)a2;
  result = SendMessageW(v4, 0x130Du, 0, (LPARAM)lParam);
  if ( result != -1 )
    return sub_479C50((int)this, result);
  return result;
}

//----- (004928D0) --------------------------------------------------------
int __thiscall sub_4928D0(int this, const ITEMIDLIST *a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx
  DWORD CurrentProcessId; // eax
  HANDLE v8; // edi
  int v10; // edi
  int v11; // esi
  int v12; // ebx
  WPARAM v13; // eax
  _DWORD *i; // eax
  int v15; // eax
  HWND v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int *v24; // ecx
  int *v25; // eax
  int v26; // ecx
  char *v27; // eax
  int v28; // edx
  __int16 v29; // cx
  int v30; // ecx
  int v31; // eax
  int v32; // edx
  int v33; // ecx
  _DWORD *v34; // eax
  _DWORD *v35; // edi
  WPARAM v36; // eax
  int v37; // edx
  int v38; // eax
  int v39; // edi
  int v40; // eax
  int v41; // [esp+14h] [ebp-94Ch]
  int v42; // [esp+18h] [ebp-948h]
  int v43; // [esp+2Ch] [ebp-934h] BYREF
  WPARAM wParam; // [esp+30h] [ebp-930h]
  const ITEMIDLIST *v45; // [esp+34h] [ebp-92Ch]
  int *v46; // [esp+38h] [ebp-928h]
  int *v47; // [esp+3Ch] [ebp-924h]
  int v48; // [esp+40h] [ebp-920h]
  SHELLEXECUTEINFOW pExecInfo; // [esp+44h] [ebp-91Ch] BYREF
  const ITEMIDLIST *v50; // [esp+80h] [ebp-8E0h]
  char v51[92]; // [esp+84h] [ebp-8DCh] BYREF
  int v52[7]; // [esp+E0h] [ebp-880h] BYREF
  int v53; // [esp+FCh] [ebp-864h]
  int v54; // [esp+100h] [ebp-860h]
  int v55; // [esp+104h] [ebp-85Ch]
  int v56; // [esp+108h] [ebp-858h]
  int v57; // [esp+10Ch] [ebp-854h]
  int v58; // [esp+110h] [ebp-850h]
  int v59; // [esp+114h] [ebp-84Ch]
  int v60; // [esp+118h] [ebp-848h]
  char v61[1024]; // [esp+11Ch] [ebp-844h] BYREF
  int v62; // [esp+51Ch] [ebp-444h]
  int v63; // [esp+520h] [ebp-440h]
  int v64; // [esp+524h] [ebp-43Ch]
  int v65; // [esp+528h] [ebp-438h]
  int v66; // [esp+52Ch] [ebp-434h]
  int v67; // [esp+530h] [ebp-430h]
  int v68; // [esp+534h] [ebp-42Ch]
  __int16 v69[260]; // [esp+538h] [ebp-428h] BYREF
  char v70[524]; // [esp+740h] [ebp-220h] BYREF
  int v71; // [esp+95Ch] [ebp-4h]

  v6 = this;
  v48 = this;
  v45 = a2;
  v43 = -1;
  if ( a6 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v8 = OpenProcess(0x410u, 0, CurrentProcessId);
    if ( v8 )
    {
      GetModuleFileNameExW(v8, 0, v70, 260);
      CloseHandle(v8);
    }
    sub_466630(a2, (WCHAR *)v69, 0x8000);
    sub_401000(0x200u, (wchar_t *)v52, L"\"%s\"", v69);
    pExecInfo.fMask = 0;
    pExecInfo.lpDirectory = 0;
    pExecInfo.cbSize = 60;
    pExecInfo.lpVerb = L"open";
    pExecInfo.lpFile = (LPCWSTR)v70;
    pExecInfo.lpParameters = (LPCWSTR)v52;
    pExecInfo.nShow = 5;
    ShellExecuteExW(&pExecInfo);
    return -2147467259;
  }
  if ( a4 || *(_DWORD *)(532 * *(_DWORD *)(this + 5592) + this + 5648) )
  {
    if ( *(_DWORD *)(532 * *(_DWORD *)(this + 5592) + this + 5648) )
    {
      v12 = this - 28;
      if ( !sub_467A90(a2) )
        return -2147467259;
      v43 = 0x20000000;
      sub_4665C0(a2, (int)&v43);
      if ( (v43 & 0x20000000) == 0 )
        return -2147467259;
      v13 = *(_DWORD *)(v12 + 59344) ? *(_DWORD *)(v12 + 5632) + 1 : SendMessageW(*(HWND *)(v12 + 68), 0x1304u, 0, 0);
      wParam = v13;
      v11 = 0;
      for ( i = (_DWORD *)(v12 + 58872); *i; ++i )
      {
        if ( ++v11 >= 100 )
          return -2147467259;
      }
      v43 = v11;
      *(_DWORD *)(v12 + 4 * v11 + 58872) = 1;
      if ( v11 == -1 )
        return -2147467259;
      v15 = 532 * v11;
      *(_DWORD *)(v15 + v12 + 5672) = 0;
      *(_DWORD *)(v15 + v12 + 5676) = 0;
      *(_DWORD *)(v15 + v12 + 5680) = 0;
      v16 = sub_49BC80(v12, *(HWND *)(v12 + 52));
      *(_DWORD *)(v12 + 4 * v11 + 92) = v16;
      if ( !v16 )
        return -2147467259;
      sub_468000(v16, *(_DWORD *)(v12 + 59384), *(_DWORD *)(v12 + 59388));
      sub_474F60(v12, *(HWND *)(v12 + 4 * v11 + 92));
      v17 = *(_DWORD *)(v12 + 59488);
      v18 = *(_DWORD *)(v12 + 59480);
      v52[6] = *(_DWORD *)(v12 + 59504);
      v19 = *(_DWORD *)(v12 + 59496);
      v52[3] = v17;
      v20 = *(_DWORD *)(v12 + 59332);
      v52[2] = v19;
      v21 = *(_DWORD *)(v12 + 59336);
      v55 = v20;
      v22 = *(_DWORD *)(v12 + 59512);
      v52[4] = v18;
      v23 = *(_DWORD *)(v12 + 59492);
      v56 = v21;
      v24 = *(int **)(v12 + 59272);
      v58 = v22;
      v25 = (int *)*v24;
      v52[5] = v23;
      v57 = *(_DWORD *)(v12 + 59508);
      v47 = v24;
      v46 = v25;
      if ( v25 != v24 )
      {
        while ( 1 )
        {
          v50 = (const ITEMIDLIST *)v25[2];
          sub_415CD0(v25 + 3, (int)v51);
          v71 = 0;
          sub_466190(v45, v50);
          v71 = -1;
          sub_40A700((int)v51);
          v46 = (int *)*v46;
          if ( v46 == v47 )
            break;
          v25 = v46;
        }
        v11 = v43;
      }
      v26 = *(_DWORD *)(v12 + 59476);
      v53 = 0;
      v54 = 0;
      v27 = v61;
      v52[1] = v26;
      v52[0] = 1;
      v28 = 512;
      while ( v28 != -2147483134 )
      {
        v29 = *(_WORD *)&v27[&unk_4C6358 - (_UNKNOWN *)v61];
        if ( !v29 )
          break;
        *(_WORD *)v27 = v29;
        v27 += 2;
        if ( !--v28 )
        {
          v27 -= 2;
          break;
        }
      }
      *(_WORD *)v27 = 0;
      v64 = v12 + 60496;
      v63 = v12 + 60484;
      v67 = v12 + 60532;
      v68 = v12 + 60544;
      v66 = v12 + 60520;
      v30 = *(_DWORD *)(v12 + 59420);
      v65 = v12 + 60508;
      v42 = *(_DWORD *)(v12 + 3428);
      v31 = *(_DWORD *)(v12 + 4 * v11 + 92);
      v62 = v12 + 60472;
      v32 = *(_DWORD *)(v12 + 59456);
      v59 = v30;
      v41 = *(_DWORD *)(v12 + 3420);
      v33 = *(_DWORD *)(v12 + 52);
      v60 = v32;
      sub_45DFE0((int *)(v12 + 4 * v11 + 516), v33, v31, (int)v52, v41, v42);
      if ( v53 )
        sub_469B90(104, *(HWND *)(v12 + 4 * v11 + 92));
      v34 = malloc(8u);
      *v34 = v12;
      v34[1] = v11;
      SetWindowLongW(*(HWND *)(v12 + 4 * v11 + 92), -21, (LONG)v34);
      lpPrevWndFunc = (WNDPROC)SetWindowLongW(*(HWND *)(v12 + 4 * v11 + 92), -4, (LONG)sub_49F510);
      v35 = (_DWORD *)(v12 + 4 * v11 + 916);
      (***(void (__stdcall ****)(_DWORD, _DWORD *, _DWORD *))(v12 + 4 * v11 + 516))(
        *(_DWORD *)(v12 + 4 * v11 + 516),
        dword_4BD7CC,
        v35);
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(v12 + 4 * v11 + 516) + 48))(
        *(_DWORD *)(v12 + 4 * v11 + 516),
        v11);
      (*(void (__thiscall **)(_DWORD, HINSTANCE))(**(_DWORD **)(v12 + 4 * v11 + 516) + 56))(
        *(_DWORD *)(v12 + 4 * v11 + 516),
        hInstance);
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 340))(*v35, *(_DWORD *)(v12 + 59508));
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 348))(*v35, *(_DWORD *)(v12 + 59484));
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 356))(*v35, *(_DWORD *)(v12 + 59512));
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 364))(*v35, *(_DWORD *)(v12 + 59332));
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 376))(*v35, *(_DWORD *)(v12 + 59500));
      (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v35 + 384))(*v35, *(_DWORD *)(v12 + 59408));
      sub_4797C0(v12, v45, wParam, v11);
      SendMessageW(*(HWND *)(v12 + 68), 0x130Cu, wParam, 0);
      ShowWindow(*(HWND *)(v12 + 3432), 0);
      ShowWindow(*(HWND *)(v12 + 4 * v11 + 92), 5);
      v36 = wParam;
      *(_DWORD *)(v12 + 5620) = v11;
      *(_DWORD *)(v12 + 5632) = v36;
      *(_DWORD *)(v12 + 3432) = *(_DWORD *)(v12 + 4 * v11 + 92);
      *(_DWORD *)(v12 + 1320) = *v35;
      SetFocus(*(HWND *)(v12 + 4 * v11 + 92));
      sub_494470(v11, v37, (_DWORD *)v12);
      v38 = (*(int (__thiscall **)(_DWORD, const ITEMIDLIST *, _DWORD))(*(_DWORD *)*v35 + 12))(*v35, v45, 0);
      v39 = *v35;
      v47 = (int *)v38;
      (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v39 + 52))(v39, 260, v12 + 3492);
      if ( v47 )
        return -2147467259;
      sub_47B000((_DWORD *)v12, (char *)v11, 1);
      v6 = v48;
      v10 = 0;
      goto LABEL_40;
    }
    v40 = sub_47B180(&v43, this - 28, a2, 0, 0, a5);
    v11 = v43;
    v10 = v40;
  }
  else
  {
    v10 = (*(int (__thiscall **)(_DWORD, const ITEMIDLIST *, int))(**(_DWORD **)(this + 1292) + 12))(
            *(_DWORD *)(this + 1292),
            a2,
            a3);
    if ( v10 >= 0 && *(_DWORD *)(v6 + 59424) )
      PlaySoundW((LPCWSTR)0xEB, 0, 0x40005u);
    v11 = *(_DWORD *)(v6 + 5592);
  }
  if ( v10 >= 0 )
LABEL_40:
    sub_492670(v11, v6 - 28);
  return v10;
}
// 492C85: conditional instruction was optimized away because edx.4!=0
// 492EA0: variable 'v37' is possibly undefined
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);
// 4BD7CC: using guessed type _DWORD dword_4BD7CC[4];
// 4CA6C0: using guessed type wchar_t aS_3[5];
// 4CA6CC: using guessed type wchar_t aOpen_6[5];
// 4928D0: using guessed type WCHAR var_428[260];

//----- (00492F40) --------------------------------------------------------
int __fastcall sub_492F40(int a1, const ITEMIDLIST *a2, int a3)
{
  bool v4; // zf
  int v6; // edi
  int v7; // esi
  WPARAM v9; // eax
  _DWORD *i; // eax
  int v11; // eax
  HWND v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int *v20; // ecx
  int *v21; // eax
  int v22; // ecx
  char *v23; // eax
  int v24; // edx
  __int16 v25; // cx
  int v26; // ecx
  int v27; // eax
  int v28; // edx
  int v29; // ecx
  _DWORD *v30; // eax
  _DWORD *v31; // edi
  WPARAM v32; // eax
  int v33; // edx
  int v34; // eax
  int v35; // edi
  int v36; // [esp+18h] [ebp-4FCh]
  int v37; // [esp+1Ch] [ebp-4F8h]
  int v38; // [esp+30h] [ebp-4E4h] BYREF
  WPARAM wParam; // [esp+34h] [ebp-4E0h]
  const ITEMIDLIST *v40; // [esp+38h] [ebp-4DCh]
  int *v41; // [esp+3Ch] [ebp-4D8h]
  int *v42; // [esp+40h] [ebp-4D4h]
  const ITEMIDLIST *v43; // [esp+44h] [ebp-4D0h]
  char v44[92]; // [esp+48h] [ebp-4CCh] BYREF
  int v45[7]; // [esp+A4h] [ebp-470h] BYREF
  int v46; // [esp+C0h] [ebp-454h]
  int v47; // [esp+C4h] [ebp-450h]
  int v48; // [esp+C8h] [ebp-44Ch]
  int v49; // [esp+CCh] [ebp-448h]
  int v50; // [esp+D0h] [ebp-444h]
  int v51; // [esp+D4h] [ebp-440h]
  int v52; // [esp+D8h] [ebp-43Ch]
  int v53; // [esp+DCh] [ebp-438h]
  char v54[1024]; // [esp+E0h] [ebp-434h] BYREF
  int v55; // [esp+4E0h] [ebp-34h]
  int v56; // [esp+4E4h] [ebp-30h]
  int v57; // [esp+4E8h] [ebp-2Ch]
  int v58; // [esp+4ECh] [ebp-28h]
  int v59; // [esp+4F0h] [ebp-24h]
  int v60; // [esp+4F4h] [ebp-20h]
  int v61; // [esp+4F8h] [ebp-1Ch]
  int v62; // [esp+510h] [ebp-4h]

  v4 = *(_DWORD *)(532 * *(_DWORD *)(a1 + 5620) + a1 + 5676) == 0;
  v40 = a2;
  if ( v4 )
  {
    v6 = (*(int (__thiscall **)(_DWORD, const ITEMIDLIST *, int))(**(_DWORD **)(a1 + 1320) + 12))(
           *(_DWORD *)(a1 + 1320),
           a2,
           a3);
    if ( v6 >= 0 )
    {
      if ( *(_DWORD *)(a1 + 59452) )
        PlaySoundW((LPCWSTR)0xEB, 0, 0x40005u);
    }
    v7 = *(_DWORD *)(a1 + 5620);
    if ( v6 < 0 )
      return v6;
    goto LABEL_6;
  }
  if ( sub_467A90(a2) )
  {
    v38 = 0x20000000;
    sub_4665C0(a2, (int)&v38);
    if ( (v38 & 0x20000000) != 0 )
    {
      v9 = *(_DWORD *)(a1 + 59344) ? *(_DWORD *)(a1 + 5632) + 1 : SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
      wParam = v9;
      v7 = 0;
      for ( i = (_DWORD *)(a1 + 58872); *i; ++i )
      {
        if ( ++v7 >= 100 )
          return -2147467259;
      }
      v38 = v7;
      *(_DWORD *)(a1 + 4 * v7 + 58872) = 1;
      if ( v7 != -1 )
      {
        v11 = 532 * v7;
        *(_DWORD *)(v11 + a1 + 5672) = 0;
        *(_DWORD *)(v11 + a1 + 5676) = 0;
        *(_DWORD *)(v11 + a1 + 5680) = 0;
        v12 = sub_49BC80(a1, *(HWND *)(a1 + 52));
        *(_DWORD *)(a1 + 4 * v7 + 92) = v12;
        if ( v12 )
        {
          sub_468000(v12, *(_DWORD *)(a1 + 59384), *(_DWORD *)(a1 + 59388));
          sub_474F60(a1, *(HWND *)(a1 + 4 * v7 + 92));
          v13 = *(_DWORD *)(a1 + 59488);
          v14 = *(_DWORD *)(a1 + 59480);
          v45[6] = *(_DWORD *)(a1 + 59504);
          v15 = *(_DWORD *)(a1 + 59496);
          v45[3] = v13;
          v16 = *(_DWORD *)(a1 + 59332);
          v45[2] = v15;
          v17 = *(_DWORD *)(a1 + 59336);
          v48 = v16;
          v18 = *(_DWORD *)(a1 + 59512);
          v45[4] = v14;
          v19 = *(_DWORD *)(a1 + 59492);
          v49 = v17;
          v20 = *(int **)(a1 + 59272);
          v51 = v18;
          v21 = (int *)*v20;
          v45[5] = v19;
          v50 = *(_DWORD *)(a1 + 59508);
          v41 = v20;
          v42 = v21;
          if ( v21 != v20 )
          {
            while ( 1 )
            {
              v43 = (const ITEMIDLIST *)v21[2];
              sub_415CD0(v21 + 3, (int)v44);
              v62 = 0;
              sub_466190(v40, v43);
              v62 = -1;
              sub_40A700((int)v44);
              v42 = (int *)*v42;
              if ( v42 == v41 )
                break;
              v21 = v42;
            }
            v7 = v38;
          }
          v22 = *(_DWORD *)(a1 + 59476);
          v46 = 0;
          v47 = 0;
          v23 = v54;
          v45[1] = v22;
          v45[0] = 1;
          v24 = 512;
          while ( v24 != -2147483134 )
          {
            v25 = *(_WORD *)&v23[&unk_4C6358 - (_UNKNOWN *)v54];
            if ( !v25 )
              break;
            *(_WORD *)v23 = v25;
            v23 += 2;
            if ( !--v24 )
            {
              v23 -= 2;
              break;
            }
          }
          *(_WORD *)v23 = 0;
          v57 = a1 + 60496;
          v56 = a1 + 60484;
          v60 = a1 + 60532;
          v61 = a1 + 60544;
          v59 = a1 + 60520;
          v26 = *(_DWORD *)(a1 + 59420);
          v58 = a1 + 60508;
          v37 = *(_DWORD *)(a1 + 3428);
          v27 = *(_DWORD *)(a1 + 4 * v7 + 92);
          v55 = a1 + 60472;
          v28 = *(_DWORD *)(a1 + 59456);
          v52 = v26;
          v36 = *(_DWORD *)(a1 + 3420);
          v29 = *(_DWORD *)(a1 + 52);
          v53 = v28;
          sub_45DFE0((int *)(a1 + 4 * v7 + 516), v29, v27, (int)v45, v36, v37);
          if ( v46 )
            sub_469B90(104, *(HWND *)(a1 + 4 * v7 + 92));
          v30 = malloc(8u);
          *v30 = a1;
          v30[1] = v7;
          SetWindowLongW(*(HWND *)(a1 + 4 * v7 + 92), -21, (LONG)v30);
          lpPrevWndFunc = (WNDPROC)SetWindowLongW(*(HWND *)(a1 + 4 * v7 + 92), -4, (LONG)sub_49F510);
          v31 = (_DWORD *)(a1 + 4 * v7 + 916);
          (***(void (__stdcall ****)(_DWORD, _DWORD *, _DWORD *))(a1 + 4 * v7 + 516))(
            *(_DWORD *)(a1 + 4 * v7 + 516),
            dword_4BD7CC,
            v31);
          (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 4 * v7 + 516) + 48))(
            *(_DWORD *)(a1 + 4 * v7 + 516),
            v7);
          (*(void (__thiscall **)(_DWORD, HINSTANCE))(**(_DWORD **)(a1 + 4 * v7 + 516) + 56))(
            *(_DWORD *)(a1 + 4 * v7 + 516),
            hInstance);
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 340))(*v31, *(_DWORD *)(a1 + 59508));
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 348))(*v31, *(_DWORD *)(a1 + 59484));
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 356))(*v31, *(_DWORD *)(a1 + 59512));
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 364))(*v31, *(_DWORD *)(a1 + 59332));
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 376))(*v31, *(_DWORD *)(a1 + 59500));
          (*(void (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)*v31 + 384))(*v31, *(_DWORD *)(a1 + 59408));
          sub_4797C0(a1, v40, wParam, v7);
          SendMessageW(*(HWND *)(a1 + 68), 0x130Cu, wParam, 0);
          ShowWindow(*(HWND *)(a1 + 3432), 0);
          ShowWindow(*(HWND *)(a1 + 4 * v7 + 92), 5);
          v32 = wParam;
          *(_DWORD *)(a1 + 5620) = v7;
          *(_DWORD *)(a1 + 5632) = v32;
          *(_DWORD *)(a1 + 3432) = *(_DWORD *)(a1 + 4 * v7 + 92);
          *(_DWORD *)(a1 + 1320) = *v31;
          SetFocus(*(HWND *)(a1 + 4 * v7 + 92));
          sub_494470(v7, v33, (_DWORD *)a1);
          v34 = (*(int (__thiscall **)(_DWORD, const ITEMIDLIST *, _DWORD))(*(_DWORD *)*v31 + 12))(*v31, v40, 0);
          v35 = *v31;
          v41 = (int *)v34;
          (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v35 + 52))(v35, 260, a1 + 3492);
          if ( !v41 )
          {
            sub_47B000((_DWORD *)a1, (char *)v7, 1);
            v6 = 0;
LABEL_6:
            sub_492670(v7, a1);
            return v6;
          }
        }
      }
    }
  }
  return -2147467259;
}
// 493235: conditional instruction was optimized away because edx.4!=0
// 493450: variable 'v33' is possibly undefined
// 4BD7CC: using guessed type _DWORD dword_4BD7CC[4];

//----- (004934A0) --------------------------------------------------------
void __userpurge sub_4934A0(int a1@<esi>, int a2)
{
  int v2; // eax
  int v3; // eax
  HWND v4; // [esp-8h] [ebp-2Ch]
  int v5[2]; // [esp+0h] [ebp-24h] BYREF
  LPVOID pv; // [esp+8h] [ebp-1Ch] BYREF
  struct tagRECT Rect; // [esp+Ch] [ebp-18h] BYREF

  v4 = *(HWND *)(a1 + 88);
  pv = 0;
  GetWindowRect(v4, &Rect);
  v5[1] = Rect.bottom - 4;
  v2 = *(_DWORD *)(a2 + 12);
  v5[0] = Rect.left;
  switch ( v2 )
  {
    case 45002:
      v3 = (*(int (__thiscall **)(_DWORD, _DWORD, LPVOID *, int *, int))(**(_DWORD **)(a1 + 1320) + 60))(
             *(_DWORD *)(a1 + 1320),
             *(_DWORD *)(a1 + 52),
             &pv,
             v5,
             1);
      goto LABEL_5;
    case 45003:
      SendMessageW(*(HWND *)(a1 + 88), 0x433u, 0xAFCAu, (LPARAM)&Rect);
      v5[0] += Rect.right;
      v3 = (*(int (__thiscall **)(_DWORD, _DWORD, LPVOID *, int *, _DWORD))(**(_DWORD **)(a1 + 1320) + 60))(
             *(_DWORD *)(a1 + 1320),
             *(_DWORD *)(a1 + 52),
             &pv,
             v5,
             0);
LABEL_5:
      if ( v3 >= 0 )
      {
        sub_492F40(a1, (const ITEMIDLIST *)pv, 0x8000000);
        CoTaskMemFree(pv);
      }
      return;
    case 45013:
      sub_48FAE0((HWND *)a1);
      break;
  }
}

//----- (00493570) --------------------------------------------------------
int __fastcall sub_493570(int a1, const ITEMIDLIST *a2, int a3, int a4)
{
  if ( a4 )
    return (*(int (__thiscall **)(int, const ITEMIDLIST *, int, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 28) + 40))(
             a1 + 28,
             a2,
             1,
             0,
             0,
             1);
  if ( *(_DWORD *)(a1 + 59328) || a3 )
    return (*(int (__thiscall **)(int, const ITEMIDLIST *, int, int, int, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(
             a1 + 28,
             a2,
             1,
             1,
             1,
             0);
  return sub_492F40(a1, a2, 1);
}

//----- (004935D0) --------------------------------------------------------
void __thiscall sub_4935D0(int *this, LPCITEMIDLIST pidl2, int a3, int a4)
{
  int *v4; // ebx
  int v5; // eax
  HRESULT v6; // eax
  bool v7; // sf
  HRESULT v8; // esi
  LPVOID pv; // [esp+Ch] [ebp-42Ch] BYREF
  LPITEMIDLIST ppidl; // [esp+10h] [ebp-428h] BYREF
  ITEMIDLIST *v11; // [esp+14h] [ebp-424h]
  int v12; // [esp+18h] [ebp-420h] BYREF
  int *v13; // [esp+1Ch] [ebp-41Ch]
  WCHAR File[260]; // [esp+20h] [ebp-418h] BYREF
  WCHAR Parameters[262]; // [esp+228h] [ebp-210h] BYREF

  v4 = this;
  v13 = this;
  v11 = (ITEMIDLIST *)pidl2;
  v12 = 541130752;
  ppidl = 0;
  pv = 0;
  if ( SHGetFolderLocation(0, 3, 0, 0, &ppidl) >= 0 )
  {
    if ( ILIsParent(ppidl, pidl2, 0) && !sub_466190(ppidl, pidl2) )
      pv = (LPVOID)1;
    CoTaskMemFree(ppidl);
  }
  if ( (unsigned int)v4[1387] >= 6 && !pv )
  {
    if ( sub_467810(&ppidl, (int)L"::{26EE0668-A00A-44D7-9371-BEB064C98683}") >= 0 )
    {
      if ( ILIsParent(ppidl, pidl2, 0) && !sub_466190(ppidl, pidl2) )
        pv = (LPVOID)1;
      CoTaskMemFree(ppidl);
    }
    v4 = v13;
  }
  if ( sub_4665C0(pidl2, (int)&v12) < 0 )
    return;
  v5 = v12 & 0x20000000;
  if ( (v12 & 0x20000000) == 0 || (v12 & 0x400000) == 0 )
  {
    if ( v5 && !pv )
      goto LABEL_18;
    if ( (v12 & 0x10000) != 0 )
    {
      if ( !pv )
      {
        sub_466630(pidl2, Parameters, 0x8000);
        v6 = sub_4AD8F0(v4[6], (int)pidl2, Parameters, 0, File);
        v7 = v6 < 0;
        if ( !v6 )
        {
          v12 = 541065216;
          if ( sub_467B20((int)File, (int)&v12) < 0
            || ((v12 & 0x20000000) == 0 || (v12 & 0x400000) != 0)
            && ((v12 & 0x20000000) == 0 || (v12 & 0x400000) == 0 || !v13[14844])
            || (pv = 0, v8 = sub_467810((LPITEMIDLIST *)&pv, (int)File), v8 < 0) )
          {
LABEL_34:
            sub_48F6D0((int)(v13 - 7), v11, word_4CA5BC);
            return;
          }
          sub_493570((int)(v13 - 7), (const ITEMIDLIST *)pv, a3, a4);
          CoTaskMemFree(pv);
          v7 = v8 < 0;
        }
        if ( !v7 )
          return;
        goto LABEL_34;
      }
    }
    else if ( !pv )
    {
LABEL_38:
      sub_48F6D0((int)(v4 - 7), v11, word_4CA5F8);
      return;
    }
    if ( v5 )
    {
      sub_466630(pidl2, Parameters, 0x8000);
      sub_466280(L"%windir%\\explorer.exe", File);
      ShellExecuteW((HWND)v4[6], L"open", File, Parameters, 0, 1);
      return;
    }
    goto LABEL_38;
  }
  if ( v4[14844] )
  {
LABEL_18:
    sub_493570((int)(v4 - 7), pidl2, a3, a4);
    return;
  }
  sub_48F6D0((int)(v4 - 7), v11, word_4CA564);
}
// 4CA564: using guessed type WCHAR word_4CA564[2];
// 4CA568: using guessed type wchar_t a26ee0668A00a44_0[41];
// 4CA5BC: using guessed type WCHAR word_4CA5BC[2];
// 4CA5F8: using guessed type WCHAR word_4CA5F8[2];

//----- (004938E0) --------------------------------------------------------
HWND __usercall sub_4938E0@<eax>(DWORD a1@<ebx>)
{
  HANDLE Thread; // eax
  HANDLE v2; // eax
  HANDLE v3; // eax
  HMENU MenuW; // eax
  HMENU v5; // eax
  HMENU v6; // eax
  HMENU SubMenu; // eax
  HMENU v8; // eax
  HMENU v9; // eax
  HMENU v10; // eax
  HMENU Menu; // eax
  HMENU v12; // eax
  HMENU v13; // eax
  HMENU v14; // eax
  HMENU v15; // eax
  HMENU v16; // eax
  HMENU v17; // eax
  HMENU v18; // eax
  HMENU v19; // eax
  HMENU v20; // eax
  HMENU v21; // eax
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // esi
  HMODULE v24; // eax
  HBITMAP v25; // esi
  void *v26; // eax
  int v27; // eax
  int v28; // esi
  HMENU v29; // eax
  HWND v30; // eax
  HWND v32; // [esp-18h] [ebp-58h]
  HINSTANCE v33; // [esp-Ch] [ebp-4Ch]
  HINSTANCE v34; // [esp-Ch] [ebp-4Ch]
  HINSTANCE v35; // [esp-Ch] [ebp-4Ch]
  HINSTANCE v36; // [esp-Ch] [ebp-4Ch]
  HINSTANCE v37; // [esp-Ch] [ebp-4Ch]
  HINSTANCE v38; // [esp-Ch] [ebp-4Ch]
  HWND v39; // [esp-4h] [ebp-44h]
  SHChangeNotifyEntry pshcne; // [esp+14h] [ebp-2Ch] BYREF
  int v41; // [esp+1Ch] [ebp-24h] BYREF
  struct tagRECT Rect; // [esp+20h] [ebp-20h] BYREF
  int v43; // [esp+3Ch] [ebp-4h]

  v41 = 0;
  *(_DWORD *)(a1 + 59544) = 0;
  *(_DWORD *)(a1 + 59540) = RegisterWindowMessageW(L"TaskbarButtonCreated");
  sub_490E60((_DWORD *)a1, &v41);
  sub_494C50((_DWORD *)a1);
  sub_491180((_DWORD *)a1);
  Thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_48F9E0, 0, 0, 0);
  *(_DWORD *)(a1 + 3420) = Thread;
  SetThreadPriority(Thread, -1);
  QueueUserAPC(sub_48F9D0, *(HANDLE *)(a1 + 3420), 0);
  v2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_48F9E0, 0, 0, 0);
  *(_DWORD *)(a1 + 3424) = v2;
  SetThreadPriority(v2, -1);
  QueueUserAPC(sub_48F9D0, *(HANDLE *)(a1 + 3424), 0);
  v3 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_48F9E0, 0, 0, 0);
  *(_DWORD *)(a1 + 3428) = v3;
  SetThreadPriority(v3, -1);
  QueueUserAPC(sub_48F9D0, *(HANDLE *)(a1 + 3428), 0);
  MenuW = LoadMenuW(hInstance, (LPCWSTR)0x97);
  SetMenu(*(HWND *)(a1 + 52), MenuW);
  v5 = LoadMenuW(hInstance, (LPCWSTR)0x9C);
  *(_DWORD *)(a1 + 3448) = GetSubMenu(v5, 0);
  v6 = LoadMenuW(hInstance, (LPCWSTR)0x9C);
  SubMenu = GetSubMenu(v6, 0);
  v33 = hInstance;
  *(_DWORD *)(a1 + 3456) = SubMenu;
  v8 = LoadMenuW(v33, (LPCWSTR)0xE1);
  v9 = GetSubMenu(v8, 0);
  v34 = hInstance;
  *(_DWORD *)(a1 + 3452) = v9;
  v10 = LoadMenuW(v34, (LPCWSTR)0xE1);
  *(_DWORD *)(a1 + 3460) = GetSubMenu(v10, 0);
  Menu = GetMenu(*(HWND *)(a1 + 52));
  v12 = GetSubMenu(Menu, 6);
  v35 = hInstance;
  *(_DWORD *)(a1 + 3464) = v12;
  v13 = LoadMenuW(v35, (LPCWSTR)0xA4);
  v14 = GetSubMenu(v13, 0);
  v36 = hInstance;
  *(_DWORD *)(a1 + 3468) = v14;
  v15 = LoadMenuW(v36, (LPCWSTR)0xC4);
  *(_DWORD *)(a1 + 3472) = GetSubMenu(v15, 0);
  v16 = LoadMenuW(hInstance, (LPCWSTR)0xD2);
  v17 = GetSubMenu(v16, 0);
  v37 = hInstance;
  *(_DWORD *)(a1 + 3476) = v17;
  v18 = LoadMenuW(v37, (LPCWSTR)0xD9);
  v19 = GetSubMenu(v18, 0);
  v38 = hInstance;
  *(_DWORD *)(a1 + 3480) = v19;
  v20 = LoadMenuW(v38, (LPCWSTR)0xDB);
  *(_DWORD *)(a1 + 3484) = GetSubMenu(v20, 0);
  v21 = LoadMenuW(hInstance, (LPCWSTR)0xC3);
  *(_DWORD *)(a1 + 3488) = GetSubMenu(v21, 0);
  *(_DWORD *)(a1 + 59976) = sub_4018B0(16, 16, 33, 0, 0x2Fu);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(*(_DWORD *)(a1 + 59976), (int)BitmapW, 0);
  DeleteObject(BitmapW);
  *(_DWORD *)(a1 + 59980) = sub_4018B0(24, 24, 33, 0, 0x2Fu);
  v24 = GetModuleHandleW(0);
  v25 = LoadBitmapW(v24, (LPCWSTR)0xED);
  sub_4011E0(*(_DWORD *)(a1 + 59980), (int)v25, 0);
  DeleteObject(v25);
  v26 = operator new(0x3Cu);
  v43 = 0;
  if ( v26 )
    v27 = sub_45EE40((int)v26);
  else
    v27 = 0;
  v43 = -1;
  *(_DWORD *)(a1 + 1324) = v27;
  sub_490750((_DWORD *)a1);
  sub_4763A0(a1);
  sub_4AFB50((_DWORD *)a1);
  sub_47B7B0(a1);
  sub_476620(a1);
  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  SendMessageW(*(HWND *)(a1 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
  *(_DWORD *)(*(_DWORD *)(a1 + 1328) + 552) = *(_DWORD *)(a1 + 59480);
  if ( *(_DWORD *)(a1 + 5576) != 6 || !*(_DWORD *)(a1 + 5580) )
    *(_DWORD *)(a1 + 59432) = 0;
  v28 = v41;
  *(_DWORD *)(a1 + 59436) = *(_DWORD *)(a1 + 59432);
  sub_496E90(v28, a1);
  (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
  v32 = *(HWND *)(a1 + 52);
  pshcne.fRecursive = 1;
  pshcne.pidl = 0;
  SHChangeNotifyRegister(v32, 2, 0x8000000, 0x8036u, 1, &pshcne);
  sub_4AFBE0(a1);
  v29 = GetMenu(*(HWND *)(a1 + 52));
  GetSubMenu(v29, 6);
  memset((void *)(a1 + 59984), 0, 0x190u);
  sub_4A6FC0((HMENU *)a1);
  sub_4A7440((HWND *)a1);
  sub_4A7D10(a1);
  v30 = SetClipboardViewer(*(HWND *)(a1 + 52));
  v39 = *(HWND *)(a1 + 3432);
  *(_DWORD *)(a1 + 3440) = v30;
  return SetFocus(v39);
}

//----- (00493CF0) --------------------------------------------------------
int __thiscall sub_493CF0(_DWORD *this)
{
  return this[847];
}

//----- (00493D00) --------------------------------------------------------
int __stdcall sub_493D00(int a1)
{
  int result; // eax

  switch ( a1 )
  {
    case 1:
      result = 2000;
      break;
    case 2:
    case 32:
      result = 2001;
      break;
    case 3:
      result = 2002;
      break;
    case 4:
      result = 2003;
      break;
    case 5:
      result = 2004;
      break;
    case 6:
      result = 2005;
      break;
    case 7:
      result = 2006;
      break;
    case 8:
      result = 2007;
      break;
    case 9:
      result = 2008;
      break;
    case 10:
      result = 2009;
      break;
    case 11:
      result = 2010;
      break;
    case 12:
      result = 2011;
      break;
    case 13:
      result = 2012;
      break;
    case 14:
      result = 2013;
      break;
    case 15:
      result = 2014;
      break;
    case 16:
      result = 2015;
      break;
    case 17:
      result = 2016;
      break;
    case 18:
      result = 2017;
      break;
    case 19:
      result = 2018;
      break;
    case 20:
      result = 2019;
      break;
    case 21:
      result = 2020;
      break;
    case 22:
      result = 2021;
      break;
    case 23:
    case 28:
      result = 2022;
      break;
    case 24:
      result = 2023;
      break;
    case 25:
      result = 2024;
      break;
    case 26:
      result = 2025;
      break;
    case 27:
      result = 2026;
      break;
    case 29:
      result = 2027;
      break;
    case 30:
      result = 2028;
      break;
    case 31:
      result = 2029;
      break;
    case 35:
      result = 2030;
      break;
    case 37:
      result = 2031;
      break;
    case 38:
      result = 2032;
      break;
    case 39:
      result = 2033;
      break;
    case 40:
      result = 2092;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00493F00) --------------------------------------------------------
int __stdcall sub_493F00(int a1)
{
  int result; // eax

  switch ( a1 )
  {
    case 1:
      result = 2049;
      break;
    case 2:
      result = 2050;
      break;
    case 3:
      result = 2051;
      break;
    case 4:
      result = 2052;
      break;
    case 5:
      result = 2053;
      break;
    case 6:
      result = 2054;
      break;
    case 7:
      result = 2055;
      break;
    case 8:
      result = 2056;
      break;
    case 9:
      result = 2057;
      break;
    case 10:
      result = 2058;
      break;
    case 11:
      result = 2059;
      break;
    case 12:
      result = 2060;
      break;
    case 13:
      result = 2061;
      break;
    case 14:
      result = 2062;
      break;
    case 15:
      result = 2063;
      break;
    case 16:
      result = 2064;
      break;
    case 17:
      result = 2065;
      break;
    case 18:
      result = 2066;
      break;
    case 19:
      result = 2067;
      break;
    case 20:
      result = 2068;
      break;
    case 21:
      result = 2069;
      break;
    case 22:
      result = 2070;
      break;
    case 23:
      result = 2071;
      break;
    case 24:
      result = 2072;
      break;
    case 25:
      result = 2073;
      break;
    case 26:
      result = 2074;
      break;
    case 27:
      result = 2075;
      break;
    case 28:
      result = 2076;
      break;
    case 29:
      result = 2077;
      break;
    case 30:
      result = 2078;
      break;
    case 31:
      result = 2079;
      break;
    case 32:
      result = 2080;
      break;
    case 33:
      result = 2081;
      break;
    case 34:
      result = 2082;
      break;
    case 35:
      result = 2083;
      break;
    case 36:
      result = 2084;
      break;
    case 37:
      result = 2085;
      break;
    case 38:
      result = 2086;
      break;
    case 39:
      result = 2087;
      break;
    case 40:
      result = 2093;
      break;
    case 41:
      result = 2094;
      break;
    case 42:
      result = 2095;
      break;
    case 43:
      result = 2096;
      break;
    case 44:
      result = 2097;
      break;
    case 45:
      result = 2098;
      break;
    case 46:
      result = 2099;
      break;
    case 47:
      result = 2100;
      break;
    case 48:
      result = 2101;
      break;
    case 49:
      result = 2102;
      break;
    case 50:
      result = 2103;
      break;
    case 51:
      result = 2104;
      break;
    case 52:
      result = 2105;
      break;
    case 53:
      result = 2106;
      break;
    case 54:
      result = 2107;
      break;
    case 55:
      result = 2108;
      break;
    case 56:
      result = 2109;
      break;
    case 57:
      result = 2110;
      break;
    case 58:
      result = 2111;
      break;
    case 59:
      result = 2112;
      break;
    case 60:
      result = 2113;
      break;
    case 61:
      result = 2114;
      break;
    case 62:
      result = 2115;
      break;
    case 63:
      result = 2116;
      break;
    case 64:
      result = 2117;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00494260) --------------------------------------------------------
BOOL __usercall sub_494260@<eax>(const WCHAR *a1@<edi>)
{
  DWORD CurrentProcessId; // eax
  HANDLE v2; // esi
  int ModuleFileName; // ebx
  int v4; // esi
  int v5; // eax
  BOOL result; // eax
  int v7; // [esp+4h] [ebp-21Ch] BYREF
  int v8; // [esp+8h] [ebp-218h] BYREF
  int v9; // [esp+Ch] [ebp-214h] BYREF
  int v10; // [esp+10h] [ebp-210h] BYREF
  WCHAR tstrFilename[260]; // [esp+14h] [ebp-20Ch] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v2 = OpenProcess(0x410u, 0, CurrentProcessId);
  result = 0;
  if ( v2 )
  {
    ModuleFileName = GetModuleFileNameExW(v2, 0, tstrFilename, 260);
    CloseHandle(v2);
    if ( ModuleFileName )
    {
      v4 = sub_4681A0(tstrFilename, (int)&v9, (int)&v7);
      v5 = sub_4681A0(a1, (int)&v10, (int)&v8);
      if ( v4 )
      {
        if ( v5 && HIWORD(v8) == HIWORD(v7) && (_WORD)v8 == (_WORD)v7 && HIWORD(v10) == HIWORD(v9) )
          return 1;
      }
    }
  }
  return result;
}
// 4BD32C: using guessed type int __stdcall GetModuleFileNameExW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004943A0) --------------------------------------------------------
BOOL __usercall sub_4943A0@<eax>(int a1@<ecx>, int *a2@<edi>, int a3@<esi>)
{
  int v3; // ecx
  UINT v4; // eax
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = a1;
  v3 = *(_DWORD *)(a3 + 4 * *(_DWORD *)(a3 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v3 + 24))(v3, &v6);
  switch ( v6 )
  {
    case 1:
      v4 = 60002;
      break;
    case 2:
      v4 = 60003;
      break;
    case 3:
      v4 = 60004;
      break;
    case 4:
      v4 = 60005;
      break;
    case 5:
      v4 = 60001;
      break;
    case 6:
      v4 = 60000;
      break;
    case 7:
      v4 = 60008;
      break;
    case 8:
      v4 = 60007;
      break;
    default:
      v4 = -1;
      break;
  }
  CheckMenuRadioItem(*(HMENU *)(a3 + 3488), 0xEA60u, 0xEA68u, v4, 0);
  return TrackPopupMenu(*(HMENU *)(a3 + 3488), 0, *a2, a2[1], 0, *(HWND *)(a3 + 52), 0);
}

//----- (00494470) --------------------------------------------------------
int __fastcall sub_494470(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int v5[4]; // [esp+4h] [ebp-18h] BYREF

  v5[0] = a3[14871];
  v5[2] = a3[14875];
  v3 = a3[a1 + 229];
  v5[3] = a3[14833];
  return (*(int (__thiscall **)(int, int *))(*(_DWORD *)v3 + 288))(v3, v5);
}

//----- (00494510) --------------------------------------------------------
void __cdecl sub_494510(int a1, int a2, int a3, void *Block)
{
  int v4; // edi
  _DWORD *v5; // eax

  v4 = *(_DWORD *)Block;
  v5 = malloc(0x10u);
  *v5 = *(_DWORD *)a3;
  v5[1] = *(_DWORD *)(a3 + 4);
  v5[2] = *((_DWORD *)Block + 1);
  PostMessageW(*(HWND *)(v4 + 52), 0x8003u, (WPARAM)v5, 0);
  free(Block);
}

//----- (00494560) --------------------------------------------------------
void __cdecl sub_494560(int a1, int a2, _DWORD *a3)
{
  int v3; // ecx

  EnterCriticalSection(&stru_4EF1A0);
  v3 = a3[2];
  if ( *(_DWORD *)(v3 + 4 * *a3 + 58872) == 1 )
    (*(void (__thiscall **)(_DWORD, int, int, _DWORD, _DWORD))(**(_DWORD **)(v3 + 4 * *a3 + 916) + 28))(
      *(_DWORD *)(v3 + 4 * *a3 + 916),
      a2,
      a1,
      *a3,
      a3[1]);
  LeaveCriticalSection(&stru_4EF1A0);
}

//----- (004945B0) --------------------------------------------------------
BOOL __fastcall sub_4945B0(int csidl, int a2)
{
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(csidl, psz2);
  return StrCmpW((PCWSTR)(a2 + 3492), psz2) == 0;
}

//----- (00494600) --------------------------------------------------------
int __usercall sub_494600@<eax>(int a1@<edi>)
{
  WPARAM v2; // esi

  if ( !*(_DWORD *)(a1 + 60572) )
    return 0;
  v2 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 == -1 )
    return 1;
  while ( (*(int (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a1 + 1320) + 176))(*(_DWORD *)(a1 + 1320), v2) )
  {
    v2 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, v2, 2);
    if ( v2 == -1 )
      return 1;
  }
  return 0;
}

//----- (00494670) --------------------------------------------------------
int __usercall sub_494670@<eax>(_DWORD *a1@<eax>)
{
  HWND Focus; // eax
  HWND v4; // ecx
  LPARAM v5; // eax
  ITEMIDLIST *v6; // esi
  HRESULT v7; // edi
  int v8; // [esp+8h] [ebp-4h] BYREF

  Focus = GetFocus();
  if ( Focus == (HWND)a1[858] )
  {
    if ( a1[15143] && sub_494600((int)a1) )
      return 1;
  }
  else
  {
    v4 = (HWND)a1[19];
    if ( Focus == v4 )
    {
      v5 = SendMessageW(v4, 0x110Au, 9u, 0);
      if ( v5 )
      {
        v6 = sub_41D9D0(v5, a1[332]);
        v8 = 1;
        v7 = sub_4665C0(v6, (int)&v8);
        CoTaskMemFree(v6);
        if ( !v7 )
          return 1;
      }
    }
  }
  return 0;
}

//----- (004946F0) --------------------------------------------------------
HRESULT __userpurge sub_4946F0@<eax>(int a1@<eax>, int a2)
{
  LRESULT v3; // eax
  int v4; // esi
  ITEMIDLIST *v5; // esi
  HRESULT v6; // edi
  HWND v8; // [esp-10h] [ebp-58h]
  LPARAM lParam[14]; // [esp+10h] [ebp-38h] BYREF

  v3 = SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0);
  if ( !v3 )
    return -2147467259;
  v4 = *(_DWORD *)(a1 + 1328);
  v8 = *(HWND *)(v4 + 12);
  lParam[0] = 20;
  lParam[1] = v3;
  SendMessageW(v8, 0x113Eu, 0, (LPARAM)lParam);
  v5 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v4 + 588) + 8 * lParam[9]));
  v6 = sub_4665C0(v5, a2);
  CoTaskMemFree(v5);
  return v6;
}

//----- (00494780) --------------------------------------------------------
HRESULT __userpurge sub_494780@<eax>(int a1@<eax>, int a2)
{
  LRESULT v3; // ebx
  ITEMIDLIST *v4; // esi
  ITEMIDLIST *v5; // ebx
  ITEMIDLIST *pv; // [esp+Ch] [ebp-4h]
  HRESULT v8; // [esp+18h] [ebp+8h]

  v3 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, 0xFFFFFFFF, 2);
  if ( v3 == -1 )
    return -2147467259;
  v4 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
  v5 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, LRESULT))(**(_DWORD **)(a1 + 1320) + 140))(
                       *(_DWORD *)(a1 + 1320),
                       v3);
  pv = ILCombine(v4, v5);
  v8 = sub_4665C0(pv, a2);
  CoTaskMemFree(pv);
  CoTaskMemFree(v5);
  CoTaskMemFree(v4);
  return v8;
}

//----- (00494810) --------------------------------------------------------
LRESULT __userpurge sub_494810@<eax>(LPARAM a1@<edi>, HWND a2@<esi>, const WCHAR *pszPath)
{
  LPARAM lParam[9]; // [esp+4h] [ebp-2DCh] BYREF
  SHFILEINFOW psfi; // [esp+28h] [ebp-2B8h] BYREF

  SHGetFileInfoW(pszPath, 0, &psfi, 0, 0x4008u);
  SendMessageW(a2, 0x14Bu, 0, 0);
  lParam[4] = psfi.iIcon;
  lParam[5] = psfi.iIcon;
  lParam[0] = 23;
  lParam[1] = -1;
  lParam[7] = 1;
  lParam[6] = 1;
  lParam[2] = a1;
  return SendMessageW(a2, 0x40Cu, 0, (LPARAM)lParam);
}

//----- (004948B0) --------------------------------------------------------
void __userpurge sub_4948B0(int a1@<edi>, int a2)
{
  WPARAM v2; // esi
  const ITEMIDLIST *v3; // eax
  ITEMIDLIST *v4; // ebx
  LPITEMIDLIST pv; // [esp+4h] [ebp-10h]
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  ITEMIDLIST *pidl1; // [esp+10h] [ebp-4h]

  v7 = 0;
  v6 = -1;
  v2 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
  {
    do
    {
      if ( ((*(int (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a1 + 1320) + 124))(*(_DWORD *)(a1 + 1320), v2) & 0x10) != 0 )
      {
        v7 = 1;
        v6 = v2;
      }
      else
      {
        pidl1 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
        v3 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a1 + 1320) + 140))(
                                   *(_DWORD *)(a1 + 1320),
                                   v2);
        v4 = (ITEMIDLIST *)v3;
        if ( v3 )
        {
          pv = ILCombine(pidl1, v3);
          (*(void (__thiscall **)(int, LPITEMIDLIST, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 32))(a1 + 28, pv, 0, 0);
          CoTaskMemFree(pv);
          CoTaskMemFree(v4);
        }
        CoTaskMemFree(pidl1);
      }
      v2 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, v2, 2);
    }
    while ( v2 != -1 );
    if ( v7 )
      sub_48F7A0(a1, v6, a2, 0);
  }
}

//----- (004949B0) --------------------------------------------------------
int __usercall sub_4949B0@<eax>(int a1@<esi>)
{
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 252))(*(_DWORD *)(a1 + 1320));
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(a1 + 28) + 16))(a1 + 28, *(_DWORD *)(a1 + 5620));
}

//----- (004949E0) --------------------------------------------------------
HWND __usercall sub_4949E0@<eax>(int a1@<esi>)
{
  int v1; // ebx
  HWND result; // eax
  int v3; // edi
  int v4; // [esp+8h] [ebp-28h]
  struct tagRECT Rect; // [esp+Ch] [ebp-24h] BYREF
  struct tagRECT v6; // [esp+1Ch] [ebp-14h] BYREF

  v1 = 0;
  v4 = 0;
  GetClientRect(*(HWND *)(a1 + 52), &Rect);
  result = *(HWND *)(a1 + 60);
  v3 = Rect.bottom - Rect.top;
  if ( result )
  {
    result = (HWND)GetWindowRect(result, &v6);
    v1 = v6.bottom - v6.top;
  }
  if ( *(_DWORD *)(a1 + 59284) )
  {
    GetWindowRect(*(HWND *)(a1 + 56), &v6);
    result = (HWND)(v6.bottom - v6.top);
    v4 = v6.bottom - v6.top;
  }
  if ( *(_DWORD *)(a1 + 59296) )
  {
    result = (HWND)GetWindowRect(*(HWND *)(a1 + 64), &v6);
    v4 += v6.bottom - v6.top;
  }
  if ( *(_DWORD *)(a1 + 59288) )
  {
    GetClientRect(*(HWND *)(a1 + 80), &v6);
    return (HWND)SetWindowPos(*(HWND *)(a1 + 80), 0, 0, v1, v6.right, v3 - v4 - v1, 0x44u);
  }
  return result;
}

//----- (00494AB0) --------------------------------------------------------
LRESULT __usercall sub_494AB0@<eax>(int a1@<ecx>, HWND a2@<edi>)
{
  LRESULT result; // eax
  signed int v4; // esi
  LPARAM lParam[3]; // [esp+8h] [ebp-9BCh] BYREF
  int v6; // [esp+14h] [ebp-9B0h]
  int v7; // [esp+18h] [ebp-9ACh]
  LRESULT v8; // [esp+3Ch] [ebp-988h]
  int v9; // [esp+40h] [ebp-984h]
  int v10; // [esp+44h] [ebp-980h]
  SHFILEINFOW v11; // [esp+48h] [ebp-97Ch] BYREF
  SHFILEINFOW psfi; // [esp+2FCh] [ebp-6C8h] BYREF
  WCHAR pszPath[260]; // [esp+5B0h] [ebp-414h] BYREF
  WCHAR v14[260]; // [esp+7B8h] [ebp-20Ch] BYREF

  v9 = a1;
  v10 = 0;
  result = SendMessageW(a2, 0x100Cu, 0xFFFFFFFF, 2);
  if ( result != -1 )
  {
    if ( (*(int (__thiscall **)(_DWORD, LRESULT, WCHAR *))(**(_DWORD **)(a1 + 1320) + 48))(
           *(_DWORD *)(a1 + 1320),
           result,
           v14) >= 0 )
    {
      v4 = 0;
      v8 = SendMessageW(a2, 0x1004u, 0, 0);
      if ( v8 > 0 )
      {
        do
        {
          (*(void (__thiscall **)(_DWORD, signed int, WCHAR *))(**(_DWORD **)(v9 + 1320) + 48))(
            *(_DWORD *)(v9 + 1320),
            v4,
            pszPath);
          SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x400u);
          SHGetFileInfoW(v14, 0, &v11, 0x2B4u, 0x400u);
          if ( StrCmpW(psfi.szTypeName, v11.szTypeName) )
          {
            v7 = 2;
            v6 = 0;
            SendMessageW(a2, 0x102Bu, v4, (LPARAM)lParam);
          }
          else
          {
            v7 = 2;
            v6 = 2;
            SendMessageW(a2, 0x102Bu, v4, (LPARAM)lParam);
            ++v10;
          }
          ++v4;
        }
        while ( v4 < v8 );
      }
    }
    return v10;
  }
  return result;
}

//----- (00494C50) --------------------------------------------------------
_DWORD *__usercall sub_494C50@<eax>(_DWORD *result@<eax>)
{
  int v1; // esi
  _DWORD *v2; // edx
  int v3; // edi
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx

  v1 = 0;
  v2 = result + 14896;
  v3 = 5;
  do
  {
    switch ( v2[11] )
    {
      case 0:
        v1 = result[14825];
        break;
      case 1:
        v1 = result[14823];
        break;
      case 2:
        v1 = result[14826];
        break;
      case 3:
        v1 = result[14827];
        break;
      case 4:
        v1 = result[14828];
        break;
      default:
        break;
    }
    if ( !v1 && (*v2 & 8) == 0 )
      *v2 |= 8u;
    v2 += 20;
    --v3;
  }
  while ( v3 );
  if ( result[14840] )
  {
    v4 = result[14896];
    if ( (v4 & 0x100) == 0 )
      result[14896] = v4 | 0x100;
    v5 = result[14916];
    if ( (v5 & 0x100) == 0 )
      result[14916] = v5 | 0x100;
    v6 = result[14936];
    if ( (v6 & 0x100) == 0 )
      result[14936] = v6 | 0x100;
    v7 = result[14956];
    if ( (v7 & 0x100) == 0 )
      result[14956] = v7 | 0x100;
    v8 = result[14976];
    if ( (v8 & 0x100) == 0 )
      result[14976] = v8 | 0x100;
  }
  return result;
}

//----- (00494E80) --------------------------------------------------------
void __usercall sub_494E80(int a1@<esi>)
{
  ITEMIDLIST *v1; // ebx
  UINT DriveTypeW; // eax
  LPARAM v3; // edi
  WCHAR RootPathName[260]; // [esp+10h] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+218h] [ebp-210h] BYREF

  if ( *(_DWORD *)(a1 + 59440) )
  {
    v1 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
    sub_466630(v1, pszPath, 0x8000);
    if ( !PathIsUNCW(pszPath) )
    {
      PathStripToRootW(RootPathName);
      DriveTypeW = GetDriveTypeW(RootPathName);
      if ( DriveTypeW != 4 )
      {
        v3 = sub_41DBD0(*(_DWORD *)(a1 + 1328), v1, DriveTypeW == 4);
        if ( v3 )
        {
          if ( SendMessageW(*(HWND *)(a1 + 76), 0x110Au, 9u, 0) != v3 )
            *(_DWORD *)(a1 + 5592) = 1;
          SendMessageW(*(HWND *)(a1 + 76), 0x110Bu, 9u, v3);
        }
      }
    }
    CoTaskMemFree(v1);
  }
}

//----- (00494FD0) --------------------------------------------------------
int __stdcall sub_494FD0(int a1)
{
  int v1; // ebx
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  int v5; // edx
  UINT v6; // eax
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // edi
  HWND v12; // eax
  LRESULT v13; // eax
  int v14; // edi
  ITEMIDLIST *v15; // ebx
  HRESULT v16; // edi
  _DWORD *v17; // eax
  _DWORD *v18; // edi
  _DWORD *v19; // eax
  _DWORD *v20; // edi
  HWND v21; // [esp-10h] [ebp-A4h]
  int v22; // [esp+10h] [ebp-84h]
  HWND Focus; // [esp+14h] [ebp-80h]
  int v24; // [esp+18h] [ebp-7Ch] BYREF
  char *v25; // [esp+1Ch] [ebp-78h] BYREF
  void *v26[3]; // [esp+20h] [ebp-74h] BYREF
  int pExceptionObject[8]; // [esp+2Ch] [ebp-68h] BYREF
  LPARAM lParam[18]; // [esp+4Ch] [ebp-48h] BYREF

  v1 = 0;
  Focus = GetFocus();
  v26[1] = 0;
  v2 = operator new(0x1Cu);
  if ( !v2 )
  {
    v25 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v2 = v2;
  v26[0] = v2;
  v2[1] = v2;
  lParam[17] = 0;
  sub_45F8F0((int)v26);
  v3 = v26[0];
  v4 = *(_DWORD **)v26[0];
  v22 = 0;
  if ( *(void **)v26[0] != v26[0] )
  {
    while ( 1 )
    {
      v5 = v4[4];
      v6 = (unsigned __int16)v4[2];
      pExceptionObject[4] = v4[3];
      v7 = v4[5];
      pExceptionObject[5] = v5;
      v8 = v4[6];
      pExceptionObject[6] = v7;
      pExceptionObject[7] = v8;
      if ( IsClipboardFormatAvailable(v6) )
        break;
      v4 = (_DWORD *)*v4;
      if ( v4 == v3 )
        goto LABEL_7;
    }
    v22 = 1;
LABEL_7:
    v1 = 0;
  }
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    if ( v22 && (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 152))(*(_DWORD *)(a1 + 1320)) )
      v1 = 1;
    v9 = (_DWORD *)*v3;
    *v3 = v3;
    v3[1] = v3;
    if ( v9 != v3 )
    {
      do
      {
        v10 = (_DWORD *)*v9;
        operator delete(v9);
        v9 = v10;
      }
      while ( v10 != v3 );
    }
    operator delete(v3);
    return v1;
  }
  else
  {
    v12 = *(HWND *)(a1 + 76);
    if ( Focus != v12 )
      goto LABEL_21;
    v13 = SendMessageW(v12, 0x110Au, 9u, 0);
    if ( !v13 )
      goto LABEL_21;
    v14 = *(_DWORD *)(a1 + 1328);
    v21 = *(HWND *)(v14 + 12);
    lParam[0] = 20;
    lParam[1] = v13;
    SendMessageW(v21, 0x113Eu, 0, (LPARAM)lParam);
    v15 = ILClone(*(LPCITEMIDLIST *)(*(_DWORD *)(v14 + 588) + 8 * lParam[9]));
    v24 = 0x40000000;
    v16 = sub_4665C0(v15, (int)&v24);
    CoTaskMemFree(v15);
    if ( !v16 )
    {
      v17 = (_DWORD *)*v3;
      *v3 = v3;
      v3[1] = v3;
      if ( v17 != v3 )
      {
        do
        {
          v18 = (_DWORD *)*v17;
          operator delete(v17);
          v17 = v18;
        }
        while ( v18 != v3 );
      }
      operator delete(v3);
      return v22;
    }
    else
    {
LABEL_21:
      v19 = (_DWORD *)*v3;
      *v3 = v3;
      v3[1] = v3;
      if ( v19 != v3 )
      {
        do
        {
          v20 = (_DWORD *)*v19;
          operator delete(v19);
          v19 = v20;
        }
        while ( v20 != v3 );
      }
      operator delete(v3);
      return 0;
    }
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00495230) --------------------------------------------------------
int __userpurge sub_495230@<eax>(LPARAM lParam@<ecx>, HWND *a2@<esi>, WPARAM wParam)
{
  signed int v4; // edi
  int v5; // eax
  unsigned int j; // ebx
  unsigned int v8; // ebx
  __int16 i; // ax
  HWND v10; // [esp-10h] [ebp-4Ch]
  HWND v11; // [esp-10h] [ebp-4Ch]
  int lParama[6]; // [esp+Ch] [ebp-30h] BYREF
  int v13; // [esp+24h] [ebp-18h]
  LPARAM v14; // [esp+28h] [ebp-14h]
  wchar_t v15; // [esp+2Ch] [ebp-10h] BYREF
  LRESULT v16; // [esp+30h] [ebp-Ch]

  v10 = a2[17];
  v14 = lParam;
  v4 = 0;
  v16 = SendMessageW(v10, 0x1304u, 0, 0);
  if ( v16 > 0 )
  {
    do
    {
      v11 = a2[17];
      lParama[0] = 8;
      SendMessageW(v11, 0x133Cu, v4, (LPARAM)lParama);
      (*(void (__thiscall **)(HWND, WPARAM, LPARAM))(*(_DWORD *)a2[v13 + 229] + 336))(a2[v13 + 229], wParam, lParam);
      ++v4;
    }
    while ( v4 < v16 );
  }
  SendMessageW(a2[19], 0x219u, wParam, lParam);
  if ( wParam == 0x8000 )
  {
    if ( *(_DWORD *)(lParam + 4) == 2 )
    {
      v8 = *(_DWORD *)(lParam + 12);
      for ( i = 0; (v8 & 1) == 0; ++i )
        v8 >>= 1;
      sub_401000(4u, &v15, L"%c:\\", (unsigned __int16)(i + 65));
      if ( (*(_BYTE *)(v14 + 16) & 1) != 0 )
      {
        sub_4A1EF0((int)a2, &v15);
      }
      else
      {
        sub_4A2080((int)a2, &v15);
        sub_467F60(a2[15], a2[127]);
      }
    }
    return -2147467263;
  }
  if ( wParam != 32772 )
    return -2147467263;
  v5 = *(_DWORD *)(lParam + 4) - 2;
  if ( *(_DWORD *)(lParam + 4) == 2 )
  {
    for ( j = *(_DWORD *)(lParam + 12); (j & 1) == 0; LOWORD(v5) = v5 + 1 )
      j >>= 1;
    sub_401000(4u, &v15, L"%c:\\", (unsigned __int16)(v5 + 65));
    if ( (*(_BYTE *)(v14 + 16) & 1) != 0 )
    {
      sub_4A1EF0((int)a2, &v15);
      return 1;
    }
    sub_4A1FD0((int)a2, &v15);
    sub_467F60(a2[15], a2[127]);
  }
  return 1;
}
// 4CA7E8: using guessed type wchar_t aC_4[5];
// 4CA7F4: using guessed type wchar_t aC_3[5];
// 495230: using guessed type LPARAM lParam[6];

//----- (00495530) --------------------------------------------------------
void __usercall sub_495530(_DWORD *a1@<ebx>)
{
  unsigned int v1; // ecx
  int v2; // edi
  _DWORD *v3; // eax
  char *v4; // eax
  int v5; // ecx
  char **v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  unsigned int v9; // edx
  int v10; // edi
  _DWORD *v11; // ecx
  int v12; // ecx
  char **v13; // eax
  int v14; // ecx
  _DWORD *v15; // eax
  unsigned int v16; // edx
  int v17; // edi
  _DWORD *v18; // ecx
  int v19; // ecx
  char **v20; // eax
  int v21; // ecx
  _DWORD *v22; // eax
  unsigned int v23; // edx
  int v24; // edi
  _DWORD *v25; // ecx
  int v26; // ecx
  char **v27; // eax
  int v28; // ecx
  _DWORD *v29; // eax
  unsigned int v30; // edx
  int v31; // edi
  _DWORD *v32; // ecx
  int v33; // ecx
  char **v34; // eax
  int v35; // ecx
  _DWORD *v36; // eax
  unsigned int v37; // edx
  int v38; // edi
  _DWORD *v39; // ecx
  int v40; // ecx
  char **v41; // eax
  int v42; // ecx
  _DWORD *v43; // eax
  unsigned int v44; // edx
  int v45; // edi
  _DWORD *v46; // ecx
  int v47; // ecx
  char **v48; // eax
  int v49; // ecx
  int v50; // [esp-4h] [ebp-20h]
  int v51; // [esp-4h] [ebp-20h]
  int v52; // [esp-4h] [ebp-20h]
  int v53; // [esp-4h] [ebp-20h]
  int v54; // [esp-4h] [ebp-20h]
  int v55; // [esp-4h] [ebp-20h]
  int v56; // [esp-4h] [ebp-20h]
  char *v57; // [esp+8h] [ebp-14h] BYREF
  int v58; // [esp+Ch] [ebp-10h]
  int v59; // [esp+10h] [ebp-Ch]
  void *Block; // [esp+14h] [ebp-8h]
  unsigned int v61; // [esp+18h] [ebp-4h]

  Block = malloc(0xCCu);
  memset(Block, 0, 0xCCu);
  v1 = 0;
  v61 = 0;
  do
  {
    v2 = a1[15118];
    v3 = *(_DWORD **)v2;
    if ( *(_DWORD *)v2 == v2 )
    {
LABEL_5:
      v4 = *(char **)((char *)dword_4E5E80 + v1);
      v5 = *(int *)((char *)dword_4E5E84 + v1);
      v50 = *(_DWORD *)(v2 + 4);
      v57 = v4;
      v58 = v5;
      v59 = 150;
      v6 = sub_41EEB0(&v57, (char *)v2, v50);
      v7 = a1[15119];
      if ( v7 == 357913940 )
LABEL_51:
        std::_Xlength_error("list<T> too long");
      a1[15119] = v7 + 1;
      *(_DWORD *)(v2 + 4) = v6;
      *(_DWORD *)v6[1] = v6;
      v1 = v61;
    }
    else
    {
      while ( v3[2] != *(int *)((char *)dword_4E5E80 + v1) )
      {
        v3 = (_DWORD *)*v3;
        if ( v3 == (_DWORD *)v2 )
          goto LABEL_5;
      }
    }
    v1 += 12;
    v61 = v1;
  }
  while ( v1 < 0x264 );
  free(Block);
  v8 = malloc(8u);
  v9 = 0;
  *v8 = 0;
  Block = v8;
  v8[1] = 0;
  v61 = 0;
  do
  {
    v10 = a1[15124];
    v11 = *(_DWORD **)v10;
    if ( *(_DWORD *)v10 == v10 )
    {
LABEL_12:
      v12 = *(int *)((char *)dword_4E60E8 + v9);
      v51 = *(_DWORD *)(v10 + 4);
      v57 = *(char **)((char *)dword_4E60E4 + v9);
      v58 = v12;
      v59 = 150;
      v13 = sub_41EEB0(&v57, (char *)v10, v51);
      v14 = a1[15125];
      if ( v14 == 357913940 )
        goto LABEL_51;
      v9 = v61;
      a1[15125] = v14 + 1;
      *(_DWORD *)(v10 + 4) = v13;
      *(_DWORD *)v13[1] = v13;
      v8 = Block;
    }
    else
    {
      while ( v11[2] != *(int *)((char *)dword_4E60E4 + v9) )
      {
        v11 = (_DWORD *)*v11;
        if ( v11 == (_DWORD *)v10 )
          goto LABEL_12;
      }
    }
    v9 += 12;
    v61 = v9;
  }
  while ( v9 < 0x18 );
  free(v8);
  v15 = malloc(0x18u);
  *v15 = 0;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  v16 = 0;
  v15[4] = 0;
  Block = v15;
  v15[5] = 0;
  v61 = 0;
  do
  {
    v17 = a1[15121];
    v18 = *(_DWORD **)v17;
    if ( *(_DWORD *)v17 == v17 )
    {
LABEL_19:
      v19 = *(int *)((char *)dword_4E6114 + v16);
      v52 = *(_DWORD *)(v17 + 4);
      v57 = *(char **)((char *)dword_4E6110 + v16);
      v58 = v19;
      v59 = 150;
      v20 = sub_41EEB0(&v57, (char *)v17, v52);
      v21 = a1[15122];
      if ( v21 == 357913940 )
        goto LABEL_51;
      v16 = v61;
      a1[15122] = v21 + 1;
      *(_DWORD *)(v17 + 4) = v20;
      *(_DWORD *)v20[1] = v20;
      v15 = Block;
    }
    else
    {
      while ( v18[2] != *(int *)((char *)dword_4E6110 + v16) )
      {
        v18 = (_DWORD *)*v18;
        if ( v18 == (_DWORD *)v17 )
          goto LABEL_19;
      }
    }
    v16 += 12;
    v61 = v16;
  }
  while ( v16 < 0x48 );
  free(v15);
  v22 = malloc(0x18u);
  *v22 = 0;
  v22[1] = 0;
  v22[2] = 0;
  v22[3] = 0;
  v23 = 0;
  v22[4] = 0;
  Block = v22;
  v22[5] = 0;
  v61 = 0;
  do
  {
    v24 = a1[15127];
    v25 = *(_DWORD **)v24;
    if ( *(_DWORD *)v24 == v24 )
    {
LABEL_26:
      v26 = *(int *)((char *)dword_4E615C + v23);
      v53 = *(_DWORD *)(v24 + 4);
      v57 = *(char **)((char *)dword_4E6158 + v23);
      v58 = v26;
      v59 = 150;
      v27 = sub_41EEB0(&v57, (char *)v24, v53);
      v28 = a1[15128];
      if ( v28 == 357913940 )
        goto LABEL_51;
      v23 = v61;
      a1[15128] = v28 + 1;
      *(_DWORD *)(v24 + 4) = v27;
      *(_DWORD *)v27[1] = v27;
      v22 = Block;
    }
    else
    {
      while ( v25[2] != *(int *)((char *)dword_4E6158 + v23) )
      {
        v25 = (_DWORD *)*v25;
        if ( v25 == (_DWORD *)v24 )
          goto LABEL_26;
      }
    }
    v23 += 12;
    v61 = v23;
  }
  while ( v23 < 0x48 );
  free(v22);
  v29 = malloc(0x18u);
  *v29 = 0;
  v29[1] = 0;
  v29[2] = 0;
  v29[3] = 0;
  v30 = 0;
  v29[4] = 0;
  Block = v29;
  v29[5] = 0;
  v61 = 0;
  do
  {
    v31 = a1[15130];
    v32 = *(_DWORD **)v31;
    if ( *(_DWORD *)v31 == v31 )
    {
LABEL_33:
      v33 = *(int *)((char *)dword_4E61A4 + v30);
      v54 = *(_DWORD *)(v31 + 4);
      v57 = *(char **)((char *)dword_4E61A0 + v30);
      v58 = v33;
      v59 = 150;
      v34 = sub_41EEB0(&v57, (char *)v31, v54);
      v35 = a1[15131];
      if ( v35 == 357913940 )
        goto LABEL_51;
      v30 = v61;
      a1[15131] = v35 + 1;
      *(_DWORD *)(v31 + 4) = v34;
      *(_DWORD *)v34[1] = v34;
      v29 = Block;
    }
    else
    {
      while ( v32[2] != *(int *)((char *)dword_4E61A0 + v30) )
      {
        v32 = (_DWORD *)*v32;
        if ( v32 == (_DWORD *)v31 )
          goto LABEL_33;
      }
    }
    v30 += 12;
    v61 = v30;
  }
  while ( v30 < 0x48 );
  free(v29);
  v36 = malloc(0x10u);
  *v36 = 0;
  v36[1] = 0;
  v37 = 0;
  v36[2] = 0;
  Block = v36;
  v36[3] = 0;
  v61 = 0;
  do
  {
    v38 = a1[15133];
    v39 = *(_DWORD **)v38;
    if ( *(_DWORD *)v38 == v38 )
    {
LABEL_40:
      v40 = *(int *)((char *)dword_4E61EC + v37);
      v55 = *(_DWORD *)(v38 + 4);
      v57 = *(char **)((char *)dword_4E61E8 + v37);
      v58 = v40;
      v59 = 150;
      v41 = sub_41EEB0(&v57, (char *)v38, v55);
      v42 = a1[15134];
      if ( v42 == 357913940 )
        goto LABEL_51;
      v37 = v61;
      a1[15134] = v42 + 1;
      *(_DWORD *)(v38 + 4) = v41;
      *(_DWORD *)v41[1] = v41;
      v36 = Block;
    }
    else
    {
      while ( v39[2] != *(int *)((char *)dword_4E61E8 + v37) )
      {
        v39 = (_DWORD *)*v39;
        if ( v39 == (_DWORD *)v38 )
          goto LABEL_40;
      }
    }
    v37 += 12;
    v61 = v37;
  }
  while ( v37 < 0x30 );
  free(v36);
  v43 = malloc(8u);
  v44 = 0;
  *v43 = 0;
  Block = v43;
  v43[1] = 0;
  v61 = 0;
  do
  {
    v45 = a1[15136];
    v46 = *(_DWORD **)v45;
    if ( *(_DWORD *)v45 == v45 )
    {
LABEL_47:
      v47 = *(int *)((char *)dword_4E621C + v44);
      v56 = *(_DWORD *)(v45 + 4);
      v57 = *(char **)((char *)dword_4E6218 + v44);
      v58 = v47;
      v59 = 150;
      v48 = sub_41EEB0(&v57, (char *)v45, v56);
      v49 = a1[15137];
      if ( v49 == 357913940 )
        goto LABEL_51;
      v44 = v61;
      a1[15137] = v49 + 1;
      *(_DWORD *)(v45 + 4) = v48;
      *(_DWORD *)v48[1] = v48;
      v43 = Block;
    }
    else
    {
      while ( v46[2] != *(int *)((char *)dword_4E6218 + v44) )
      {
        v46 = (_DWORD *)*v46;
        if ( v46 == (_DWORD *)v45 )
          goto LABEL_47;
      }
    }
    v44 += 12;
    v61 = v44;
  }
  while ( v44 < 0x18 );
  free(v43);
}
// 4E5E80: using guessed type int dword_4E5E80[];
// 4E5E84: using guessed type int dword_4E5E84[];
// 4E60E4: using guessed type int dword_4E60E4[];
// 4E60E8: using guessed type int dword_4E60E8[];
// 4E6110: using guessed type int dword_4E6110[];
// 4E6114: using guessed type int dword_4E6114[];
// 4E6158: using guessed type int dword_4E6158[];
// 4E615C: using guessed type int dword_4E615C[];
// 4E61A0: using guessed type int dword_4E61A0[];
// 4E61A4: using guessed type int dword_4E61A4[];
// 4E61E8: using guessed type int dword_4E61E8[];
// 4E61EC: using guessed type int dword_4E61EC[];
// 4E6218: using guessed type int dword_4E6218[];
// 4E621C: using guessed type int dword_4E621C[];

//----- (004959C0) --------------------------------------------------------
void __usercall sub_4959C0(int a1@<eax>)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ecx
  _DWORD *v4; // eax
  int v5; // eax

  v2 = malloc(0x50u);
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  v3 = *(_DWORD **)(a1 + 60388);
  v2[3] = 0;
  v2[4] = 0;
  v2[5] = 0;
  v2[6] = 0;
  v2[7] = 0;
  v2[8] = 0;
  v2[9] = 0;
  v2[10] = 0;
  v2[11] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 0;
  v2[19] = 0;
  v4 = (_DWORD *)*v3;
  if ( (_DWORD *)*v3 == v3 )
  {
LABEL_4:
    v5 = 0;
    while ( (int)v2[v5] <= 1 )
    {
      if ( ++v5 >= 20 )
      {
        free(v2);
        return;
      }
    }
  }
  else
  {
    while ( (int)v4[2] >= 45000 )
    {
      v4 = (_DWORD *)*v4;
      if ( v4 == v3 )
        goto LABEL_4;
    }
  }
  sub_49AD80(a1);
  free(v2);
}

//----- (00495AA0) --------------------------------------------------------
void __thiscall sub_495AA0(int *this)
{
  int *v2; // edx
  void *v3; // edi
  LPARAM dwInitParam[3]; // [esp+10h] [ebp-50h] BYREF
  unsigned __int16 v5; // [esp+1Ch] [ebp-44h]
  HWND hWndParent; // [esp+20h] [ebp-40h]
  int v7; // [esp+28h] [ebp-38h]
  void *v8; // [esp+3Ch] [ebp-24h]
  int v9; // [esp+5Ch] [ebp-4h]

  if ( this )
    v2 = this + 7;
  else
    v2 = 0;
  sub_4812C0((int)v2, this[13], (int)dwInitParam);
  v9 = 0;
  if ( !v7 )
    DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v5, hWndParent, DialogFunc, (LPARAM)dwInitParam);
  sub_4A8290((int)this);
  dwInitParam[0] = (LPARAM)&CBaseDialog::`vftable';
  v3 = v8;
  if ( v8 )
  {
    sub_4AAAD0((int)v8);
    operator delete(v3);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (00495B40) --------------------------------------------------------
void __thiscall sub_495B40(int this, int a2)
{
  int *v3; // esi
  WPARAM i; // edi
  char *v5; // eax
  int pExceptionObject[3]; // [esp+10h] [ebp-354h] BYREF
  char *v7; // [esp+1Ch] [ebp-348h] BYREF
  void *v8; // [esp+20h] [ebp-344h] BYREF
  int v9; // [esp+24h] [ebp-340h]
  void *v10[4]; // [esp+2Ch] [ebp-338h] BYREF
  int v11; // [esp+3Ch] [ebp-328h]
  unsigned int v12; // [esp+40h] [ebp-324h]
  unsigned __int16 Src; // [esp+48h] [ebp-31Ch] BYREF
  __int16 v14; // [esp+4Ah] [ebp-31Ah] BYREF
  WCHAR Buffer; // [esp+250h] [ebp-114h] BYREF
  __int16 v16; // [esp+252h] [ebp-112h] BYREF
  int v17; // [esp+360h] [ebp-4h]

  if ( SendMessageW(*(HWND *)(this + 3432), 0x1032u, 0, 0) )
  {
    v9 = 0;
    v3 = (int *)operator new(0x24u);
    if ( !v3 )
    {
      v7 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v3 = (int)v3;
    v8 = v3;
    v3[1] = (int)v3;
    v17 = 0;
    for ( i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 2);
          i != -1;
          i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, i, 2) )
    {
      (*(void (__thiscall **)(_DWORD, WPARAM, unsigned __int16 *))(**(_DWORD **)(this + 1320) + 48))(
        *(_DWORD *)(this + 1320),
        i,
        &Src);
      LOWORD(v10[0]) = 0;
      v12 = 7;
      v11 = 0;
      sub_4094F0(v10, (int)&v14, &Src, wcslen(&Src));
      LOBYTE(v17) = 1;
      v5 = sub_40A200((char *)v3, v3[1], (int)v10);
      if ( v9 == 153391688 )
        std::_Xlength_error("list<T> too long");
      ++v9;
      v3[1] = (int)v5;
      **((_DWORD **)v5 + 1) = v5;
      LOBYTE(v17) = 0;
      if ( v12 >= 8 )
        operator delete(v10[0]);
    }
    LoadStringW(hInstance, 0x86Au, &Buffer, 128);
    LOWORD(v10[0]) = 0;
    v12 = 7;
    v11 = 0;
    sub_4094F0(v10, (int)&v16, &Buffer, wcslen(&Buffer));
    LOBYTE(v17) = 2;
    sub_4AE760(a2, (_DWORD **)&v8, *(HWND *)(this + 52), v10);
    if ( v12 >= 8 )
      operator delete(v10[0]);
    sub_40A140((int)&v8);
    operator delete(v8);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (00495DD0) --------------------------------------------------------
int __userpurge sub_495DD0@<eax>(unsigned int a1@<ebx>, int a2@<edi>, int a3)
{
  WCHAR Buffer[512]; // [esp+4h] [ebp-404h] BYREF

  if ( HIWORD(a1) != 0xFFFF || a3 )
  {
    sub_4624E0(*(_DWORD *)(a2 + 3416));
    LoadStringW(hInstance, (unsigned __int16)a1, Buffer, 512);
    SetWindowTextW(*(HWND *)(a2 + 56), Buffer);
    return 0;
  }
  else
  {
    sub_462410(*(_DWORD *)(a2 + 3416));
    return 0;
  }
}

//----- (00495E60) --------------------------------------------------------
int __userpurge sub_495E60@<eax>(_WORD *a1@<edi>, LPCWSTR lpDirectoryName)
{
  ULARGE_INTEGER FreeBytesAvailableToCaller; // [esp+10h] [ebp-48Ch] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+18h] [ebp-484h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+20h] [ebp-47Ch] BYREF
  ULONGLONG v6; // [esp+28h] [ebp-474h]
  WCHAR String[512]; // [esp+30h] [ebp-46Ch] BYREF
  char v8[68]; // [esp+430h] [ebp-6Ch] BYREF
  WCHAR Buffer[16]; // [esp+474h] [ebp-28h] BYREF

  if ( !GetDiskFreeSpaceExW(lpDirectoryName, &FreeBytesAvailableToCaller, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) )
    return -1;
  sub_46B2E0(0x20u, 0, 0, TotalNumberOfFreeBytes.QuadPart);
  LoadStringW(hInstance, 0x1FF4u, Buffer, 16);
  v6 = TotalNumberOfBytes.QuadPart & 0x8000000000000000ui64;
  sub_401000(
    0x20u,
    String,
    L"%s %s (%.0f%%)",
    v8,
    Buffer,
    (double)TotalNumberOfFreeBytes.QuadPart * 100.0 / (double)TotalNumberOfBytes.QuadPart);
  if ( lstrlenW(String) < 64 )
    sub_4A96F0(64, (int)String, a1);
  return lstrlenW(String);
}
// 4CAA9C: using guessed type wchar_t aSS0f[15];
// 495E60: using guessed type char var_6C[68];

//----- (00495FD0) --------------------------------------------------------
LRESULT __usercall sub_495FD0@<eax>(int a1@<esi>)
{
  int v1; // ebx
  char v3[8]; // [esp+8h] [ebp-258h] BYREF
  unsigned __int64 v4; // [esp+10h] [ebp-250h]
  WCHAR v5[64]; // [esp+18h] [ebp-248h] BYREF
  WCHAR Buffer[64]; // [esp+98h] [ebp-1C8h] BYREF
  wchar_t v7[64]; // [esp+118h] [ebp-148h] BYREF
  wchar_t lParam[64]; // [esp+198h] [ebp-C8h] BYREF
  __int16 v9[34]; // [esp+218h] [ebp-48h] BYREF

  memset(lParam, 0, sizeof(lParam));
  memset(v7, 0, sizeof(v7));
  memset(v9, 0, 64);
  SendMessageW(*(HWND *)(a1 + 64), 0x8066u, (WPARAM)&unk_4CAA7C, 0);
  v1 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 292))(*(_DWORD *)(a1 + 1320));
  LoadStringW(hInstance, 0x1FF0u, Buffer, 64);
  sub_401000(0x40u, lParam, L"%d %s", v1, Buffer);
  SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)lParam);
  if ( !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 144))(*(_DWORD *)(a1 + 1320)) )
  {
    (*(void (__thiscall **)(_DWORD, char *))(**(_DWORD **)(a1 + 1320) + 204))(*(_DWORD *)(a1 + 1320), v3);
    sub_46B2E0(0x20u, *(_DWORD *)(a1 + 59420), *(_DWORD *)(a1 + 59456), v4);
    LoadStringW(hInstance, 0x2017u, v5, 64);
    sub_401000(0x40u, v7, L"%s: %s", v5, v9);
  }
  return SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)v7);
}
// 4CAA80: using guessed type wchar_t aDS[6];
// 4CAA8C: using guessed type wchar_t aSS_6[7];
// 495FD0: using guessed type char var_258[8];

//----- (00496160) --------------------------------------------------------
LRESULT __thiscall sub_496160(_DWORD *this)
{
  char **v1; // esi
  LRESULT result; // eax
  LRESULT v3; // ebx
  int v4; // eax
  char *v5; // ecx
  int v6; // ebx
  _DWORD *v7; // edi
  _DWORD *v8; // eax
  int v9; // edx
  _WORD *v10; // eax
  __int16 v11; // cx
  HINSTANCE v12; // ecx
  char *v13; // eax
  HANDLE Thread; // eax
  char **v15; // eax
  LRESULT (__stdcall *v16)(HWND, UINT, WPARAM, LPARAM); // ebx
  int v17; // ecx
  _DWORD *v18; // edi
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int ImagePixelFormat; // eax
  int v24; // eax
  int v25; // ecx
  int ImageHorizontalResolution; // eax
  int v27; // edx
  int ImageVerticalResolution; // eax
  HWND v29; // [esp+18h] [ebp-1220h]
  char *v30[3]; // [esp+34h] [ebp-1204h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+40h] [ebp-11F8h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [esp+48h] [ebp-11F0h] BYREF
  char **v33; // [esp+50h] [ebp-11E8h]
  int v34; // [esp+54h] [ebp-11E4h] BYREF
  SHFILEINFOW psfi; // [esp+58h] [ebp-11E0h] BYREF
  __int16 v36[512]; // [esp+310h] [ebp-F28h] BYREF
  LPARAM lParam[130]; // [esp+710h] [ebp-B28h] BYREF
  WCHAR v38[256]; // [esp+918h] [ebp-920h] BYREF
  __int16 v39[256]; // [esp+B18h] [ebp-720h] BYREF
  WCHAR FileName[260]; // [esp+D18h] [ebp-520h] BYREF
  WCHAR FileSystemNameBuffer[4]; // [esp+F20h] [ebp-318h] BYREF
  __int16 v42[260]; // [esp+F28h] [ebp-310h] BYREF
  WCHAR Buffer[32]; // [esp+1130h] [ebp-108h] BYREF
  char v44[64]; // [esp+1170h] [ebp-C8h] BYREF
  WCHAR v45[66]; // [esp+11B0h] [ebp-88h] BYREF

  v1 = (char **)this;
  v29 = (HWND)this[858];
  v33 = (char **)this;
  result = SendMessageW(v29, 0x100Cu, 0xFFFFFFFF, 2);
  v3 = result;
  if ( result == -1 )
    return result;
  (*(void (__thiscall **)(char *, LRESULT, int, LPARAM *))(*(_DWORD *)v1[330] + 64))(v1[330], result, 260, lParam);
  SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)lParam);
  (*(void (__thiscall **)(char *, LRESULT, WCHAR *))(*(_DWORD *)v1[330] + 48))(v1[330], v3, FileName);
  v4 = (*(int (__thiscall **)(char *))(*(_DWORD *)v1[330] + 144))(v1[330]);
  v5 = v1[330];
  if ( !v4 )
  {
    (*(void (__thiscall **)(char *, LRESULT, WCHAR *))(*(_DWORD *)v5 + 48))(v5, v3, FileName);
    v6 = (*(int (__thiscall **)(char *, LRESULT))(*(_DWORD *)v1[330] + 132))(v1[330], v3);
    v34 = v6;
    TotalNumberOfBytes.HighPart = GetFileAttributesW(FileName) & 0x10;
    if ( TotalNumberOfBytes.HighPart && v1[14833] )
    {
      v7 = malloc(0x210u);
      if ( v7 )
      {
        v8 = malloc(8u);
        if ( v8 )
        {
          *v8 = v1;
          v8[1] = v1[15117];
          v7[130] = v8;
          v7[131] = sub_494510;
          v9 = 260;
          v10 = v7;
          while ( v9 != -2147483386 )
          {
            v11 = *(_WORD *)((char *)v10 + (char *)FileName - (char *)v7);
            if ( !v11 )
              break;
            *v10++ = v11;
            if ( !--v9 )
            {
              --v10;
              break;
            }
          }
          v12 = hInstance;
          *v10 = 0;
          LoadStringW(v12, 0x1FF6u, Buffer, 64);
          LoadStringW(hInstance, 0x2018u, v45, 64);
          sub_401000(0x100u, (wchar_t *)v42, L"%s: %s", Buffer, v45);
          SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v42);
          v13 = v1[1405];
          v30[0] = v1[15117];
          v30[1] = v13;
          v30[2] = (char *)1;
          sub_415830((int)(v1 + 15114), v30);
          Thread = CreateThread(0, 0, sub_4B1210, v7, 0, &TotalNumberOfFreeBytes.HighPart);
          CloseHandle(Thread);
          v15 = v33;
          ++v33[15117];
          v6 = v34;
          v1 = v15;
        }
        else
        {
          free(v7);
        }
      }
    }
    else
    {
      SHGetFileInfoW(FileName, *(_DWORD *)v6, &psfi, 0x2B4u, 0x410u);
      SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)psfi.szTypeName);
    }
    sub_46AB90(v39, 256, (FILETIME *)(v6 + 20), (int)v1[14875]);
    LoadStringW(hInstance, 0x2015u, v38, 256);
    sub_401000(0x200u, (wchar_t *)v36, L"%s: %s", v38, v39);
    v16 = SendMessageW;
    SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v36);
    if ( !sub_468480(FileName) )
      goto LABEL_40;
    v18 = (_DWORD *)GdipAlloc(16);
    if ( v18 )
    {
      *v18 = &Gdiplus::Image::`vftable';
      v18[1] = 0;
      v18[2] = GdipLoadImageFromFile(FileName, v18 + 1);
    }
    else
    {
      v18 = 0;
    }
    v19 = v18[2];
    v18[2] = 0;
    if ( v19 )
    {
LABEL_39:
      (*(void (__thiscall **)(_DWORD *, int))*v18)(v18, 1);
LABEL_40:
      if ( TotalNumberOfBytes.HighPart != 16 && v1[14845] && v1[14824] )
        return v16((HWND)v1[16], 0x8066u, (WPARAM)FileName, 1);
      else
        return v16((HWND)v1[16], 0x8066u, (WPARAM)&unk_4CA998, 0);
    }
    v20 = sub_4158A0(v17, (int)v18);
    sub_401000(0x100u, (wchar_t *)v42, L"Width: %u pixels", v20);
    SendMessageW((HWND)v33[16], 0x8073u, 0, (LPARAM)v42);
    v22 = sub_415870(v21, (int)v18);
    sub_401000(0x100u, (wchar_t *)v42, L"Height: %u pixels", v22);
    v1 = v33;
    SendMessageW((HWND)v33[16], 0x8073u, 0, (LPARAM)v42);
    ImagePixelFormat = GdipGetImagePixelFormat(v18[1], &v34);
    if ( ImagePixelFormat )
      v18[2] = ImagePixelFormat;
    if ( v34 <= 397319 )
    {
      if ( v34 == 397319 )
        goto LABEL_30;
      if ( v34 > 196865 )
      {
        if ( v34 == 197634 )
        {
          v24 = 4;
          goto LABEL_34;
        }
        if ( v34 == 198659 )
        {
          v24 = 8;
          goto LABEL_34;
        }
        goto LABEL_57;
      }
      if ( v34 == 196865 )
      {
        v24 = 1;
        goto LABEL_34;
      }
      if ( v34 <= 137224 )
      {
        if ( v34 == 137224 )
        {
          v24 = 24;
          goto LABEL_34;
        }
        if ( v34 >= 135173 && v34 <= 135174 )
        {
LABEL_30:
          v24 = 16;
LABEL_34:
          sub_401000(0x100u, (wchar_t *)v42, L"Bit depth: %u", v24);
          SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v42);
          v25 = v18[1];
          *(float *)&v34 = 0.0;
          ImageHorizontalResolution = GdipGetImageHorizontalResolution(v25, &v34);
          if ( ImageHorizontalResolution )
            v18[2] = ImageHorizontalResolution;
          sub_401000(0x100u, (wchar_t *)v42, L"Horizontal resolution: %.0f dpi", *(float *)&v34);
          SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v42);
          v27 = v18[1];
          *(float *)&v34 = 0.0;
          ImageVerticalResolution = GdipGetImageVerticalResolution(v27, &v34);
          if ( ImageVerticalResolution )
            v18[2] = ImageVerticalResolution;
          sub_401000(0x100u, (wchar_t *)v42, L"Vertical resolution: %.0f dpi", *(float *)&v34);
          SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v42);
          v16 = SendMessageW;
          goto LABEL_39;
        }
LABEL_57:
        v24 = 0;
        goto LABEL_34;
      }
      if ( v34 != 139273 )
        goto LABEL_57;
      goto LABEL_33;
    }
    if ( v34 > 1851406 )
    {
      if ( v34 == 2498570 )
        goto LABEL_33;
      if ( v34 != 3424269 )
        goto LABEL_57;
    }
    else if ( v34 != 1851406 )
    {
      if ( v34 != 925707 )
      {
        if ( v34 == 1052676 )
          goto LABEL_30;
        if ( v34 == 1060876 )
        {
          v24 = 48;
          goto LABEL_34;
        }
        goto LABEL_57;
      }
LABEL_33:
      v24 = 32;
      goto LABEL_34;
    }
    v24 = 64;
    goto LABEL_34;
  }
  (*(void (__thiscall **)(char *, LRESULT, WCHAR *))(*(_DWORD *)v5 + 48))(v5, v3, FileName);
  result = PathIsRootW(FileName);
  if ( result )
  {
    if ( GetDiskFreeSpaceExW(FileName, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) )
    {
      sub_46B2E0(0x20u, 0, 0, TotalNumberOfFreeBytes.QuadPart);
      sub_401000(0x40u, v45, L"Free Space: %s", v44);
      SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v45);
      sub_46B2E0(0x20u, 0, 0, TotalNumberOfBytes.QuadPart);
      sub_401000(0x40u, v45, L"Total Size: %s", v44);
      SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v45);
    }
    result = GetVolumeInformationW(FileName, 0, 0, 0, 0, 0, FileSystemNameBuffer, 0x105u);
    if ( result )
    {
      sub_401000(0x40u, v45, L"File System: %s", FileSystemNameBuffer);
      return SendMessageW((HWND)v1[16], 0x8073u, 0, (LPARAM)v45);
    }
  }
  return result;
}
// 4962D0: conditional instruction was optimized away because edx.4!=0
// 4964BC: variable 'v17' is possibly undefined
// 4964F4: variable 'v21' is possibly undefined
// 4BD6A0: using guessed type int __stdcall GdipGetImagePixelFormat(_DWORD, _DWORD);
// 4BD6A4: using guessed type int __stdcall GdipGetImageHorizontalResolution(_DWORD, _DWORD);
// 4BD6AC: using guessed type int __stdcall GdipGetImageVerticalResolution(_DWORD, _DWORD);
// 4BD6B4: using guessed type int __stdcall GdipLoadImageFromFile(_DWORD, _DWORD);
// 4BD6BC: using guessed type int __stdcall GdipAlloc(_DWORD);
// 4CA870: using guessed type wchar_t aSS_7[7];
// 4CA880: using guessed type wchar_t aSS_8[7];
// 4CA890: using guessed type wchar_t aWidthUPixels[17];
// 4CA8B4: using guessed type wchar_t aHeightUPixels[18];
// 4CA900: using guessed type wchar_t aBitDepthU[14];
// 4CA91C: using guessed type wchar_t aVerticalResolu[30];
// 4CA958: using guessed type wchar_t aHorizontalReso[32];
// 4CA99C: using guessed type wchar_t aFreeSpaceS[15];
// 4CA9BC: using guessed type wchar_t aTotalSizeS[15];
// 4CA9DC: using guessed type wchar_t aFileSystemS[16];
// 4CC06C: using guessed type void *Gdiplus::Image::`vftable';
// 496160: using guessed type wchar_t var_310[260];
// 496160: using guessed type _WORD var_720[256];
// 496160: using guessed type wchar_t var_F28[512];

//----- (004968D0) --------------------------------------------------------
void __usercall sub_4968D0(int a1@<esi>)
{
  const ITEMIDLIST *v1; // ebx
  __int16 v2; // ax
  DWORD v3; // ebx
  HWND v4; // [esp-10h] [ebp-1000h]
  const ITEMIDLIST *v5; // [esp+Ch] [ebp-FE4h]
  WCHAR *pszPath; // [esp+10h] [ebp-FE0h]
  LPITEMIDLIST ppidl; // [esp+14h] [ebp-FDCh] BYREF
  DWORD nSize; // [esp+18h] [ebp-FD8h] BYREF
  IShellFolder *ppshf; // [esp+1Ch] [ebp-FD4h] BYREF
  SHFILEINFOW psfi; // [esp+20h] [ebp-FD0h] BYREF
  struct _MEMORYSTATUSEX v11; // [esp+2D8h] [ebp-D18h] BYREF
  char v12[1024]; // [esp+318h] [ebp-CD8h] BYREF
  __int16 lParam[260]; // [esp+718h] [ebp-8D8h] BYREF
  char v14[520]; // [esp+920h] [ebp-6D0h] BYREF
  WCHAR Buffer[512]; // [esp+B28h] [ebp-4C8h] BYREF
  WCHAR WideCharStr[64]; // [esp+F28h] [ebp-C8h] BYREF
  CHAR MultiByteStr[68]; // [esp+FA8h] [ebp-48h] BYREF

  v4 = *(HWND *)(a1 + 64);
  ppidl = 0;
  SendMessageW(v4, 0x8074u, 0, 0);
  SendMessageW(*(HWND *)(a1 + 64), 0x8066u, (WPARAM)&unk_4CA838, 0);
  (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a1 + 1320) + 52))(*(_DWORD *)(a1 + 1320), 260, v14);
  v1 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
  pszPath = &v1->mkid.cb;
  SHGetFolderLocation(0, 17, 0, 0, &ppidl);
  v5 = ppidl;
  if ( !v1 )
    goto LABEL_8;
  if ( !ppidl )
    goto LABEL_8;
  ppshf = 0;
  nSize = 0;
  if ( SHGetDesktopFolder(&ppshf) < 0 )
    goto LABEL_8;
  v2 = ppshf->lpVtbl->CompareIDs(ppshf, 0, v1, v5);
  v3 = 1;
  if ( v2 )
    v3 = nSize;
  ppshf->lpVtbl->Release(ppshf);
  if ( v3 )
  {
    nSize = 512;
    GetComputerNameW(Buffer, &nSize);
    SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)Buffer);
    sub_4698A0(MultiByteStr);
    MultiByteToWideChar(0, 0, MultiByteStr, -1, WideCharStr, 64);
    sub_401000(0x200u, Buffer, L"Processor: %s", WideCharStr);
    SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)Buffer);
    v11.dwLength = 64;
    GlobalMemoryStatusEx(&v11);
    sub_46B2E0(0x200u, 0, 0, v11.ullTotalPhys);
    sub_401000(0x200u, Buffer, L"Memory: %s", v12);
    SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)Buffer);
  }
  else
  {
LABEL_8:
    ppshf = 0;
    if ( sub_467810((LPITEMIDLIST *)&ppshf, (int)v14) >= 0 )
      sub_466630((const ITEMIDLIST *)ppshf, (WCHAR *)lParam, 1);
    CoTaskMemFree(ppshf);
    SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)lParam);
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x408u);
    SendMessageW(*(HWND *)(a1 + 64), 0x8073u, 0, (LPARAM)psfi.szTypeName);
  }
  CoTaskMemFree(pszPath);
}
// 4CA83C: using guessed type wchar_t aProcessorS[14];
// 4CA858: using guessed type wchar_t aMemoryS[11];
// 4968D0: using guessed type char var_CD8[1024];
// 4968D0: using guessed type WCHAR lParam[260];

//----- (00496B80) --------------------------------------------------------
void __usercall sub_496B80(int a1@<eax>)
{
  int v2; // eax

  SendMessageW(*(HWND *)(a1 + 64), 0x8074u, 0, 0);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 292))(*(_DWORD *)(a1 + 1320));
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      sub_496160((_DWORD *)a1);
    }
    else if ( v2 > 1 )
    {
      sub_495FD0(a1);
    }
  }
  else
  {
    sub_4968D0(a1);
  }
}

//----- (00496BE0) --------------------------------------------------------
int __usercall sub_496BE0@<eax>(int a1@<esi>)
{
  unsigned int v1; // ebx
  unsigned int v2; // edi
  wchar_t *v3; // ebx
  WCHAR *v4; // eax
  int v5; // edx
  WCHAR v6; // cx
  int v7; // edx
  __int16 *v8; // eax
  __int16 v9; // cx
  wchar_t *v11; // [esp+8h] [ebp-1E0h]
  int v12; // [esp+Ch] [ebp-1DCh]
  unsigned __int64 v13[2]; // [esp+10h] [ebp-1D8h] BYREF
  WCHAR v14[32]; // [esp+20h] [ebp-1C8h] BYREF
  WCHAR Buffer[64]; // [esp+60h] [ebp-188h] BYREF
  __int16 lParam[64]; // [esp+E0h] [ebp-108h] BYREF
  __int16 v17[66]; // [esp+160h] [ebp-88h] BYREF

  v1 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 192))(*(_DWORD *)(a1 + 1320));
  v12 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 196))(*(_DWORD *)(a1 + 1320));
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 200))(*(_DWORD *)(a1 + 1320)) + v12;
  if ( v2 )
  {
    v3 = sub_46A840(v2, 0);
    if ( v2 == 1 )
    {
      LoadStringW(hInstance, 0x1FEFu, Buffer, 64);
      sub_401000(0x40u, (wchar_t *)lParam, L"%s %s", v3, Buffer);
    }
    else
    {
      LoadStringW(hInstance, 0x1FF0u, Buffer, 64);
      sub_401000(0x40u, (wchar_t *)lParam, L"%s %s", v3, Buffer);
    }
  }
  else
  {
    v11 = sub_46A840(v1, 0);
    if ( v1 == 1 )
    {
      LoadStringW(hInstance, 0x1FF1u, Buffer, 64);
      sub_401000(0x40u, (wchar_t *)lParam, L"%s %s", v11, Buffer);
    }
    else
    {
      LoadStringW(hInstance, 0x1FF2u, Buffer, 64);
      sub_401000(0x40u, (wchar_t *)lParam, L"%s %s", v11, Buffer);
    }
  }
  SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 0, (LPARAM)lParam);
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 144))(*(_DWORD *)(a1 + 1320)) )
  {
    LoadStringW(hInstance, 0x1FF3u, v14, 32);
  }
  else
  {
    (*(void (__thiscall **)(_DWORD, unsigned __int64 *))(**(_DWORD **)(a1 + 1320) + 204))(*(_DWORD *)(a1 + 1320), v13);
    if ( v2 )
    {
      if ( v12 )
      {
        sub_46B2E0(0x20u, *(_DWORD *)(a1 + 59420), *(_DWORD *)(a1 + 59456), v13[1]);
      }
      else
      {
        v4 = v14;
        v5 = 32;
        while ( v5 != -2147483614 )
        {
          v6 = *(WCHAR *)((char *)v4 + &unk_4CA830 - (_UNKNOWN *)v14);
          if ( !v6 )
            break;
          *v4++ = v6;
          if ( !--v5 )
          {
            *(v4 - 1) = 0;
            goto LABEL_20;
          }
        }
        *v4 = 0;
      }
    }
    else
    {
      sub_46B2E0(0x20u, *(_DWORD *)(a1 + 59420), *(_DWORD *)(a1 + 59456), v13[0]);
    }
  }
LABEL_20:
  SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 1u, (LPARAM)v14);
  if ( sub_495E60(v17, (LPCWSTR)(a1 + 3492)) == -1 )
  {
    v7 = 64;
    v8 = v17;
    while ( v7 != -2147483582 )
    {
      v9 = *(__int16 *)((char *)v8 + &unk_4CA834 - (_UNKNOWN *)v17);
      if ( !v9 )
        break;
      *v8++ = v9;
      if ( !--v7 )
      {
        --v8;
        break;
      }
    }
    *v8 = 0;
  }
  SendMessageW(*(HWND *)(a1 + 56), 0x40Bu, 2u, (LPARAM)v17);
  return 0;
}
// 496DC6: conditional instruction was optimized away because edx.4!=0
// 496E50: conditional instruction was optimized away because edx.4!=0
// 4CA800: using guessed type wchar_t aSS_9[6];
// 4CA80C: using guessed type wchar_t aSS_10[6];
// 4CA818: using guessed type wchar_t aSS_11[6];
// 4CA824: using guessed type wchar_t aSS_12[6];
// 496BE0: using guessed type wchar_t lParam[64];
// 496BE0: using guessed type _WORD var_88[66];

//----- (00496E90) --------------------------------------------------------
int __fastcall sub_496E90(int a1, int a2)
{
  signed int v2; // ebx
  int v4; // eax
  unsigned int v5; // ebx
  LPCWSTR *v6; // edi
  WCHAR *v7; // eax
  int v8; // edx
  int v9; // edi
  WCHAR v10; // cx
  const WCHAR *v11; // eax
  const WCHAR *v12; // eax
  bool v13; // cc
  int v14; // eax
  bool v15; // zf
  LRESULT v16; // edi
  HWND v18; // [esp-10h] [ebp-280h]
  LPARAM lParam[7]; // [esp+14h] [ebp-25Ch] BYREF
  char *v20; // [esp+30h] [ebp-240h]
  int *v21; // [esp+34h] [ebp-23Ch]
  int v22; // [esp+38h] [ebp-238h]
  LPCWSTR lpString1[5]; // [esp+3Ch] [ebp-234h] BYREF
  unsigned int v24; // [esp+50h] [ebp-220h]
  WCHAR Buffer[260]; // [esp+58h] [ebp-218h] BYREF
  int v26; // [esp+26Ch] [ebp-4h]

  v2 = 0;
  v22 = 0;
  if ( dword_4EF708 )
  {
    v4 = *(_DWORD *)dword_4EF704;
    v20 = dword_4EF704;
    v21 = (int *)v4;
    if ( (char *)v4 != dword_4EF704 )
    {
      while ( 2 )
      {
        LOWORD(lpString1[0]) = 0;
        v24 = 7;
        lpString1[4] = 0;
        sub_4090E0((int)lpString1, (_DWORD *)(v4 + 8), 0, 0xFFFFFFFF);
        v26 = 0;
        v5 = v24;
        v6 = (LPCWSTR *)lpString1[0];
        if ( v24 < 8 )
          v6 = lpString1;
        v7 = Buffer;
        v8 = 260;
        v9 = (char *)v6 - (char *)Buffer;
        while ( v8 != -2147483386 )
        {
          v10 = *(WCHAR *)((char *)v7 + v9);
          if ( !v10 )
            break;
          *v7++ = v10;
          if ( !--v8 )
          {
            --v7;
            break;
          }
        }
        *v7 = 0;
        v11 = lpString1[0];
        if ( v5 < 8 )
          v11 = (const WCHAR *)lpString1;
        if ( lstrcmpW(v11, L"..") )
        {
          v12 = lpString1[0];
          if ( v24 < 8 )
            v12 = (const WCHAR *)lpString1;
          if ( !lstrcmpW(v12, L".") )
            GetCurrentDirectoryW(0x104u, Buffer);
        }
        else
        {
          GetCurrentDirectoryW(0x104u, Buffer);
          PathRemoveFileSpecW(Buffer);
        }
        if ( !sub_47B6C0(a2, Buffer, 0, 0) )
          ++v22;
        v26 = -1;
        if ( v24 >= 8 )
          operator delete((void *)lpString1[0]);
        v2 = 0;
        v21 = (int *)*v21;
        if ( v21 != (int *)v20 )
        {
          v4 = (int)v21;
          continue;
        }
        break;
      }
LABEL_28:
      v13 = v22 <= 0;
      if ( v22 )
        goto LABEL_33;
    }
  }
  else if ( *(_DWORD *)(a2 + 59460) == 1 )
  {
    v22 = (*(int (__thiscall **)(int))(*(_DWORD *)a1 + 20))(a1);
    goto LABEL_28;
  }
  v14 = sub_47B6C0(a2, (const WCHAR *)(a2 + 4532), 0, 0);
  v15 = v14 == 0;
  if ( v14 < 0 )
    v15 = sub_47B6C0(a2, (const WCHAR *)(a2 + 4012), 0, 0) == 0;
  if ( !v15 )
    return -2147467259;
  v22 = 1;
  v13 = 0;
LABEL_33:
  if ( !v13 )
  {
    do
    {
      v18 = *(HWND *)(a2 + 68);
      lParam[0] = 8;
      SendMessageW(v18, 0x133Cu, v2, (LPARAM)lParam);
      sub_48FB60(lParam[6], a2);
      ++v2;
    }
    while ( v2 < v22 );
  }
  if ( !*(_DWORD *)(a2 + 59316) && v22 == 1 )
    *(_DWORD *)(a2 + 59320) = 0;
  v16 = *(_DWORD *)(a2 + 5628);
  if ( v16 >= SendMessageW(*(HWND *)(a2 + 68), 0x1304u, 0, 0) || v16 < 0 )
    *(_DWORD *)(a2 + 5628) = 0;
  SendMessageW(*(HWND *)(a2 + 68), 0x130Cu, *(_DWORD *)(a2 + 5628), 0);
  *(_DWORD *)(a2 + 5632) = *(_DWORD *)(a2 + 5628);
  sub_479A30(a2, 1);
  return 0;
}
// 496F70: conditional instruction was optimized away because edx.4!=0
// 4EF708: using guessed type int dword_4EF708;

//----- (004971A0) --------------------------------------------------------
BOOL __usercall sub_4971A0@<eax>(int a1@<esi>)
{
  int v1; // edi
  WPARAM v2; // eax
  HWND v4; // [esp-14h] [ebp-18h]

  v1 = *(_DWORD *)(a1 + 92);
  if ( !InterlockedDecrement((volatile LONG *)(v1 + 4)) && v1 )
    (**(void (__thiscall ***)(int, int))v1)(v1, 1);
  v4 = *(HWND *)(a1 + 4);
  *(_DWORD *)(a1 + 92) = 0;
  *(_WORD *)(a1 + 96) = 0;
  v2 = SendDlgItemMessageW(v4, 1152, 0x407u, 0, 0);
  SendDlgItemMessageW(*(HWND *)(a1 + 4), 1152, 0x402u, v2, 0);
  return SetDlgItemTextW(*(HWND *)(a1 + 4), 1, (LPCWSTR)(a1 + 98));
}

//----- (00497230) --------------------------------------------------------
LRESULT __thiscall sub_497230(int this, int a2, LPARAM lParam, int a4)
{
  LRESULT result; // eax
  int v6; // edi
  HWND v7; // [esp-10h] [ebp-98h]
  WCHAR Buffer[64]; // [esp+4h] [ebp-84h] BYREF

  result = a2 - 32769;
  switch ( a2 )
  {
    case 32769:
      result = SendDlgItemMessageW(*(HWND *)(this + 4), 1152, 0x406u, 0, lParam);
      break;
    case 32770:
      result = SendDlgItemMessageW(*(HWND *)(this + 4), 1152, 0x402u, lParam, 0);
      break;
    case 32771:
      result = sub_4971A0(this);
      break;
    case 32772:
      LoadStringW(*(HINSTANCE *)(this + 8), 0xFAu, Buffer, 64);
      MessageBoxW(*(HWND *)(this + 4), Buffer, L"Explorer++", 0x30u);
      v6 = *(_DWORD *)(this + 92);
      if ( !InterlockedDecrement((volatile LONG *)(v6 + 4)) )
      {
        if ( v6 )
          (**(void (__thiscall ***)(int, int))v6)(v6, 1);
      }
      v7 = *(HWND *)(this + 4);
      *(_DWORD *)(this + 92) = 0;
      *(_WORD *)(this + 96) = 0;
      result = SetDlgItemTextW(v7, 1, (LPCWSTR)(this + 98));
      break;
    default:
      return result;
  }
  return result;
}

//----- (00497360) --------------------------------------------------------
int __thiscall sub_497360(HICON *this)
{
  DestroyIcon(this[41]);
  return 0;
}

//----- (00497370) --------------------------------------------------------
int __thiscall sub_497370(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (00497380) --------------------------------------------------------
int __thiscall sub_497380(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 168);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 168) + 4) = 1;
  return result;
}

//----- (00497410) --------------------------------------------------------
char **__stdcall sub_497410(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char **v4; // eax
  char *v5; // ecx
  char **v6; // eax
  char *v7; // ecx
  char **v8; // eax
  char *v9; // ecx
  char **v10; // eax
  char *v11; // ecx
  char *v12; // eax
  char **v13; // eax
  char *v14; // ecx
  char **v15; // eax
  char *v16; // ecx
  char **v17; // eax
  char *v18; // ecx
  char *v19; // eax
  char **v20; // eax
  char *v21; // ecx
  char **v22; // eax
  char *v23; // ecx
  char *v24; // eax
  char **v25; // eax
  char *v26; // ecx
  char **v27; // eax
  char *v28; // ecx
  char **v29; // eax
  char *v30; // ecx
  char *v31; // ebx
  char **result; // eax
  char *v33; // ecx
  char *v34; // [esp-8h] [ebp-20h]
  char *v35; // [esp-8h] [ebp-20h]
  char *v36; // [esp-8h] [ebp-20h]
  char *v37; // [esp-8h] [ebp-20h]
  char *v38; // [esp-8h] [ebp-20h]
  char *v39; // [esp-8h] [ebp-20h]
  char *v40; // [esp-8h] [ebp-20h]
  char *v41; // [esp-8h] [ebp-20h]
  char *v42; // [esp-8h] [ebp-20h]
  char *v43; // [esp-8h] [ebp-20h]
  char *v44; // [esp-8h] [ebp-20h]
  int v45; // [esp-4h] [ebp-1Ch]
  int v46; // [esp-4h] [ebp-1Ch]
  int v47; // [esp-4h] [ebp-1Ch]
  int v48; // [esp-4h] [ebp-1Ch]
  int v49; // [esp-4h] [ebp-1Ch]
  int v50; // [esp-4h] [ebp-1Ch]
  int v51; // [esp-4h] [ebp-1Ch]
  int v52; // [esp-4h] [ebp-1Ch]
  int v53; // [esp-4h] [ebp-1Ch]
  int v54; // [esp-4h] [ebp-1Ch]
  int v55; // [esp-4h] [ebp-1Ch]
  int v56; // [esp-4h] [ebp-1Ch]
  int v57; // [esp-4h] [ebp-1Ch]
  int v58; // [esp-4h] [ebp-1Ch]
  int v59; // [esp+Ch] [ebp-Ch] BYREF
  int v60; // [esp+10h] [ebp-8h]
  int v61; // [esp+14h] [ebp-4h]
  char *v62; // [esp+20h] [ebp+8h]
  char *v63; // [esp+20h] [ebp+8h]
  char *v64; // [esp+20h] [ebp+8h]
  char *v65; // [esp+20h] [ebp+8h]
  char *v66; // [esp+20h] [ebp+8h]
  char *v67; // [esp+20h] [ebp+8h]
  char *v68; // [esp+20h] [ebp+8h]
  char *v69; // [esp+20h] [ebp+8h]
  char *v70; // [esp+20h] [ebp+8h]
  char *v71; // [esp+20h] [ebp+8h]
  char *v72; // [esp+20h] [ebp+8h]
  char *v73; // [esp+20h] [ebp+8h]
  char *v74; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v45 = *((_DWORD *)*a2 + 1);
  v34 = *a2;
  v59 = 1150;
  v60 = 1;
  v61 = 0;
  v62 = v34;
  v2 = sub_41EEB0((char **)&v59, v34, v45);
  v3 = a2[1];
  if ( v3 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v62 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v46 = *((_DWORD *)*a2 + 1);
  v35 = *a2;
  v59 = 1153;
  v60 = 0;
  v61 = 1;
  v63 = v35;
  v4 = sub_41EEB0((char **)&v59, v35, v46);
  v5 = a2[1];
  if ( v5 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v5 + 1;
  *((_DWORD *)v63 + 1) = v4;
  *(_DWORD *)v4[1] = v4;
  v47 = *((_DWORD *)*a2 + 1);
  v36 = *a2;
  v59 = 1054;
  v60 = 0;
  v61 = 1;
  v64 = v36;
  v6 = sub_41EEB0((char **)&v59, v36, v47);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v64 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v48 = *((_DWORD *)*a2 + 1);
  v37 = *a2;
  v59 = 1307;
  v60 = 0;
  v61 = 2;
  v65 = v37;
  v8 = sub_41EEB0((char **)&v59, v37, v48);
  v9 = a2[1];
  if ( v9 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v9 + 1;
  *((_DWORD *)v65 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v49 = *((_DWORD *)*a2 + 1);
  v38 = *a2;
  v59 = 1151;
  v60 = 0;
  v61 = 2;
  v66 = v38;
  v10 = sub_41EEB0((char **)&v59, v38, v49);
  v11 = a2[1];
  if ( v11 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v11 + 1;
  *((_DWORD *)v66 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  v12 = *a2;
  v60 = 1;
  v61 = 1;
  v50 = *((_DWORD *)v12 + 1);
  v59 = 1151;
  v67 = v12;
  v13 = sub_41EEB0((char **)&v59, v12, v50);
  v14 = a2[1];
  if ( v14 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v14 + 1;
  *((_DWORD *)v67 + 1) = v13;
  *(_DWORD *)v13[1] = v13;
  v51 = *((_DWORD *)*a2 + 1);
  v39 = *a2;
  v59 = 1154;
  v60 = 0;
  v61 = 0;
  v68 = v39;
  v15 = sub_41EEB0((char **)&v59, v39, v51);
  v16 = a2[1];
  if ( v16 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v16 + 1;
  *((_DWORD *)v68 + 1) = v15;
  *(_DWORD *)v15[1] = v15;
  v52 = *((_DWORD *)*a2 + 1);
  v40 = *a2;
  v59 = 1152;
  v60 = 0;
  v61 = 2;
  v69 = v40;
  v17 = sub_41EEB0((char **)&v59, v40, v52);
  v18 = a2[1];
  if ( v18 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v18 + 1;
  *((_DWORD *)v69 + 1) = v17;
  *(_DWORD *)v17[1] = v17;
  v19 = *a2;
  v60 = 1;
  v61 = 1;
  v53 = *((_DWORD *)v19 + 1);
  v59 = 1152;
  v70 = v19;
  v20 = sub_41EEB0((char **)&v59, v19, v53);
  v21 = a2[1];
  if ( v21 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v21 + 1;
  *((_DWORD *)v70 + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  v54 = *((_DWORD *)*a2 + 1);
  v41 = *a2;
  v59 = 1308;
  v60 = 0;
  v61 = 2;
  v71 = v41;
  v22 = sub_41EEB0((char **)&v59, v41, v54);
  v23 = a2[1];
  if ( v23 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v23 + 1;
  *((_DWORD *)v71 + 1) = v22;
  *(_DWORD *)v22[1] = v22;
  v24 = *a2;
  v60 = 1;
  v61 = 1;
  v55 = *((_DWORD *)v24 + 1);
  v59 = 1308;
  v72 = v24;
  v25 = sub_41EEB0((char **)&v59, v24, v55);
  v26 = a2[1];
  if ( v26 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v26 + 1;
  *((_DWORD *)v72 + 1) = v25;
  *(_DWORD *)v25[1] = v25;
  v56 = *((_DWORD *)*a2 + 1);
  v42 = *a2;
  v59 = 1;
  v60 = 0;
  v61 = 0;
  v73 = v42;
  v27 = sub_41EEB0((char **)&v59, v42, v56);
  v28 = a2[1];
  if ( v28 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v28 + 1;
  *((_DWORD *)v73 + 1) = v27;
  *(_DWORD *)v27[1] = v27;
  v57 = *((_DWORD *)*a2 + 1);
  v43 = *a2;
  v59 = 2;
  v60 = 0;
  v61 = 0;
  v74 = v43;
  v29 = sub_41EEB0((char **)&v59, v43, v57);
  v30 = a2[1];
  if ( v30 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v30 + 1;
  *((_DWORD *)v74 + 1) = v29;
  *(_DWORD *)v29[1] = v29;
  v60 = 0;
  v61 = 0;
  v31 = *a2;
  v58 = *((_DWORD *)*a2 + 1);
  v44 = *a2;
  v59 = 1304;
  result = sub_41EEB0((char **)&v59, v44, v58);
  v33 = a2[1];
  if ( v33 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v33 + 1;
  *((_DWORD *)v31 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (004978A0) --------------------------------------------------------
int *sub_4978A0()
{
  if ( (dword_4F1FD4 & 1) == 0 )
  {
    dword_4F1FD4 |= 1u;
    sub_4653E0((int)&dword_4F0C40, (int)L"MergeFiles");
    dword_4F0C40 = (int)&CMergeFilesDialogPersistentSettings::`vftable';
    atexit(sub_4BCCE0);
  }
  return &dword_4F0C40;
}
// 4CABF8: using guessed type wchar_t aMergefiles[11];
// 4CC04C: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 4F0C40: using guessed type int dword_4F0C40;
// 4F1FD4: using guessed type int dword_4F1FD4;

//----- (004978E0) --------------------------------------------------------
int __usercall sub_4978E0@<eax>(int a1@<esi>)
{
  int result; // eax

  *(_DWORD *)a1 = &CMergeFiles::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 52));
  sub_40A140(a1 + 40);
  operator delete(*(void **)(a1 + 40));
  if ( *(_DWORD *)(a1 + 32) >= 8u )
    operator delete(*(void **)(a1 + 12));
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 28) = 0;
  result = 0;
  *(_WORD *)(a1 + 12) = 0;
  *(_DWORD *)a1 = &CReferenceCount::`vftable';
  return result;
}
// 4CC064: using guessed type void *CMergeFiles::`vftable';
// 4CC488: using guessed type void *CReferenceCount::`vftable';

//----- (00497940) --------------------------------------------------------
void __stdcall sub_497940(int a1)
{
  int v1; // edi
  int v2; // edi
  void *v3; // esi

  *(_DWORD *)a1 = &CMergeFilesDialog::`vftable';
  v1 = *(_DWORD *)(a1 + 92);
  if ( v1 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 52));
    *(_BYTE *)(v1 + 76) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 52));
    v2 = *(_DWORD *)(a1 + 92);
    if ( !InterlockedDecrement((volatile LONG *)(v2 + 4)) )
    {
      if ( v2 )
        (**(void (__thiscall ***)(int, int))v2)(v2, 1);
    }
  }
  sub_40A140(a1 + 76);
  operator delete(*(void **)(a1 + 76));
  if ( *(_DWORD *)(a1 + 68) >= 8u )
    operator delete(*(void **)(a1 + 48));
  *(_DWORD *)(a1 + 68) = 7;
  *(_DWORD *)(a1 + 64) = 0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)a1 = &CBaseDialog::`vftable';
  v3 = *(void **)(a1 + 44);
  if ( v3 )
  {
    sub_4AAAD0((int)v3);
    operator delete(v3);
  }
}
// 4CC014: using guessed type void *CMergeFilesDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (00497A20) --------------------------------------------------------
LRESULT __usercall sub_497A20@<eax>(int a1@<edi>)
{
  const WCHAR *v1; // eax
  _DWORD **v3; // eax
  _DWORD *v4; // ebx
  const WCHAR *v5; // eax
  HANDLE FileW; // esi
  void *v7; // ebx
  char v8; // [esp+13h] [ebp-51h]
  _DWORD *v9; // [esp+14h] [ebp-50h]
  WPARAM wParam; // [esp+18h] [ebp-4Ch]
  HANDLE hFile; // [esp+1Ch] [ebp-48h]
  DWORD NumberOfBytesRead; // [esp+20h] [ebp-44h] BYREF
  LARGE_INTEGER FileSize; // [esp+24h] [ebp-40h] BYREF
  _DWORD **v14; // [esp+2Ch] [ebp-38h]
  DWORD NumberOfBytesWritten; // [esp+30h] [ebp-34h] BYREF
  LPCWSTR lpFileName[5]; // [esp+34h] [ebp-30h] BYREF
  unsigned int v17; // [esp+48h] [ebp-1Ch]
  int v18; // [esp+60h] [ebp-4h]

  v1 = (const WCHAR *)(a1 + 12);
  wParam = 1;
  v8 = 0;
  if ( *(_DWORD *)(a1 + 32) >= 8u )
    v1 = *(const WCHAR **)v1;
  hFile = CreateFileW(v1, 0x40000000u, 0, 0, 1u, 0x80u, 0);
  if ( hFile == (HANDLE)-1 )
    return PostMessageW(*(HWND *)(a1 + 8), 0x8004u, 0, 0);
  PostMessageW(*(HWND *)(a1 + 8), 0x8001u, *(_DWORD *)(a1 + 44), 0);
  v3 = *(_DWORD ***)(a1 + 40);
  v4 = *v3;
  v14 = v3;
  v9 = v4;
  if ( v4 != v3 )
  {
    while ( 1 )
    {
      v17 = 7;
      lpFileName[4] = 0;
      LOWORD(lpFileName[0]) = 0;
      sub_4090E0((int)lpFileName, v4 + 2, 0, 0xFFFFFFFF);
      v18 = 0;
      if ( v8 )
        break;
      v5 = lpFileName[0];
      if ( v17 < 8 )
        v5 = (const WCHAR *)lpFileName;
      FileW = CreateFileW(v5, 0x80000000, 1u, 0, 3u, 0, 0);
      if ( FileW != (HANDLE)-1 )
      {
        GetFileSizeEx(FileW, &FileSize);
        if ( FileSize.QuadPart )
        {
          v7 = operator new[](FileSize.LowPart);
          ReadFile(FileW, v7, FileSize.LowPart, &NumberOfBytesRead, 0);
          WriteFile(hFile, v7, NumberOfBytesRead, &NumberOfBytesWritten, 0);
          operator delete[](v7);
          v4 = v9;
        }
        CloseHandle(FileW);
        PostMessageW(*(HWND *)(a1 + 8), 0x8002u, wParam++, 0);
        EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 52));
        if ( *(_BYTE *)(a1 + 76) )
          v8 = 1;
        LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 52));
      }
      v18 = -1;
      if ( v17 >= 8 )
        operator delete((void *)lpFileName[0]);
      v9 = (_DWORD *)*v4;
      if ( (_DWORD **)*v4 == v14 )
        goto LABEL_23;
      v4 = (_DWORD *)*v4;
    }
    if ( v17 >= 8 )
      operator delete((void *)lpFileName[0]);
  }
LABEL_23:
  CloseHandle(hFile);
  return SendMessageW(*(HWND *)(a1 + 8), 0x8003u, 0, 0);
}

//----- (00497C70) --------------------------------------------------------
DWORD __stdcall sub_497C70(LPVOID lpThreadParameter)
{
  sub_497A20((int)lpThreadParameter);
  return 0;
}

//----- (00497C90) --------------------------------------------------------
int __userpurge sub_497C90@<eax>(
        int a1@<edi>,
        int a2,
        void *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        void *a10,
        int a11,
        int a12)
{
  char ***v12; // esi
  char **v13; // eax
  int v14; // edx
  int pExceptionObject[3]; // [esp+Ch] [ebp-28h] BYREF
  int v17; // [esp+18h] [ebp-1Ch]
  int v18; // [esp+1Ch] [ebp-18h]
  int v19; // [esp+20h] [ebp-14h]
  char *v20; // [esp+24h] [ebp-10h] BYREF
  int v21; // [esp+30h] [ebp-4h]

  v18 = a1;
  v21 = 0;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)a1 = &CMergeFiles::`vftable';
  *(_DWORD *)(a1 + 32) = 7;
  *(_DWORD *)(a1 + 28) = 0;
  *(_WORD *)(a1 + 12) = 0;
  LOBYTE(v21) = 3;
  v12 = (char ***)(a1 + 40);
  *(_DWORD *)(a1 + 44) = 0;
  v13 = (char **)operator new(0x24u);
  if ( !v13 )
  {
    v20 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v20);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v12 = v13;
  *v13 = (char *)v13;
  (*v12)[1] = (char *)*v12;
  LOBYTE(v21) = 4;
  *(_DWORD *)(a1 + 8) = a2;
  sub_4090E0(a1 + 12, &a3, 0, 0xFFFFFFFF);
  if ( v12 != (char ***)&a10 )
  {
    v14 = *(_DWORD *)a10;
    v19 = (int)a10;
    v17 = v14;
    sub_40A140(a1 + 40);
    sub_40B6E0(a1 + 40, **v12, v17, v19, v18);
  }
  *(_BYTE *)(a1 + 76) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 52));
  if ( (unsigned int)a8 >= 8 )
    operator delete(a3);
  a8 = 7;
  a7 = 0;
  LOWORD(a3) = 0;
  sub_40A140((int)&a10);
  operator delete(a10);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CC064: using guessed type void *CMergeFiles::`vftable';

//----- (00497DE0) --------------------------------------------------------
LRESULT __userpurge sub_497DE0@<eax>(int a1@<ebx>, char a2)
{
  LRESULT result; // eax
  int v3; // esi
  int v4; // edi
  _DWORD *v5; // eax
  int i; // ecx
  int v7; // ecx
  int j; // ecx
  int v9; // ecx
  HWND DlgItem; // [esp+4h] [ebp-4h]

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1150);
  result = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  v3 = result;
  if ( result != -1 )
  {
    if ( a2 )
    {
      if ( !result )
        return result;
      v4 = result - 1;
    }
    else
    {
      if ( result == *(_DWORD *)(a1 + 80) - 1 )
        return result;
      v4 = result + 1;
    }
    v5 = **(_DWORD ***)(a1 + 76);
    for ( i = v3; i > 0; --i )
      v5 = (_DWORD *)*v5;
    if ( i < 0 )
    {
      v7 = -i;
      do
      {
        --v7;
        v5 = (_DWORD *)v5[1];
      }
      while ( v7 );
    }
    for ( j = v4; j > 0; --j )
      v5 = (_DWORD *)*v5;
    if ( j < 0 )
    {
      v9 = -j;
      do
      {
        --v9;
        v5 = (_DWORD *)v5[1];
      }
      while ( v9 );
    }
    sub_40AB10(v5, **(_DWORD ***)(a1 + 76));
    return sub_468800(DlgItem, v3, v4);
  }
  return result;
}

//----- (00497E90) --------------------------------------------------------
int __userpurge sub_497E90@<eax>(
        int a1@<edx>,
        int a2@<esi>,
        void *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        void *a10,
        int a11,
        int a12,
        int a13)
{
  char ***v13; // ebx
  char **v14; // eax
  void *v15; // edi
  bool v16; // zf
  bool v17; // cf
  int pExceptionObject[3]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+18h] [ebp-18h]
  int v21; // [esp+1Ch] [ebp-14h]
  char *v22; // [esp+20h] [ebp-10h] BYREF
  int v23; // [esp+2Ch] [ebp-4h]

  v21 = a2;
  v23 = 0;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(a2 + 12) = 185;
  *(_DWORD *)(a2 + 16) = a1;
  *(_BYTE *)(a2 + 28) = 1;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)a2 = &CMergeFilesDialog::`vftable';
  *(_DWORD *)(a2 + 68) = 7;
  *(_DWORD *)(a2 + 64) = 0;
  *(_WORD *)(a2 + 48) = 0;
  LOBYTE(v23) = 3;
  v13 = (char ***)(a2 + 76);
  *(_DWORD *)(a2 + 80) = 0;
  v14 = (char **)operator new(0x24u);
  if ( !v14 )
  {
    v22 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v22);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v13 = v14;
  *v14 = (char *)v14;
  (*v13)[1] = (char *)*v13;
  LOBYTE(v23) = 4;
  sub_4090E0(a2 + 48, &a3, 0, 0xFFFFFFFF);
  if ( v13 != (char ***)&a10 )
  {
    v15 = a10;
    v20 = *(_DWORD *)a10;
    sub_40A140((int)v13);
    sub_40B6E0(a2 + 76, **v13, v20, (int)v15, v21);
  }
  v16 = (dword_4F1FD4 & 1) == 0;
  *(_DWORD *)(a2 + 88) = a13;
  *(_WORD *)(a2 + 96) = 0;
  *(_DWORD *)(a2 + 92) = 0;
  if ( v16 )
  {
    dword_4F1FD4 |= 1u;
    sub_4653E0((int)&dword_4F0C40, (int)L"MergeFiles");
    dword_4F0C40 = (int)&CMergeFilesDialogPersistentSettings::`vftable';
    atexit(sub_4BCCE0);
  }
  v17 = (unsigned int)a8 < 8;
  *(_DWORD *)(a2 + 168) = &dword_4F0C40;
  if ( !v17 )
    operator delete(a3);
  a8 = 7;
  a7 = 0;
  LOWORD(a3) = 0;
  sub_40A140((int)&a10);
  operator delete(a10);
  return a2;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CABF8: using guessed type wchar_t aMergefiles[11];
// 4CC014: using guessed type void *CMergeFilesDialog::`vftable';
// 4CC04C: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 4F0C40: using guessed type int dword_4F0C40;
// 4F1FD4: using guessed type int dword_4F1FD4;

//----- (00498020) --------------------------------------------------------
void __usercall sub_498020(int a1@<esi>)
{
  BOOL v1; // edi
  const WCHAR *v2; // eax
  void *v3[5]; // [esp+8h] [ebp-148h] BYREF
  unsigned int v4; // [esp+1Ch] [ebp-134h]
  LPCWSTR lpString[5]; // [esp+24h] [ebp-12Ch] BYREF
  unsigned int v6; // [esp+38h] [ebp-118h]
  WCHAR Buffer; // [esp+40h] [ebp-110h] BYREF
  __int16 v8; // [esp+42h] [ebp-10Eh] BYREF
  int v9; // [esp+14Ch] [ebp-4h]

  LoadStringW(*(HINSTANCE *)(a1 + 8), 0x1F48u, &Buffer, 128);
  v6 = 7;
  lpString[4] = 0;
  LOWORD(lpString[0]) = 0;
  v9 = 0;
  v4 = 7;
  LOWORD(v3[0]) = 0;
  v3[4] = 0;
  sub_4094F0(v3, (int)&v8, &Buffer, wcslen(&Buffer));
  LOBYTE(v9) = 1;
  v1 = sub_4AE0D0((int)v3, *(HWND *)(a1 + 4), lpString);
  if ( v4 >= 8 )
    operator delete(v3[0]);
  if ( v1 )
  {
    v2 = lpString[0];
    if ( v6 < 8 )
      v2 = (const WCHAR *)lpString;
    SetDlgItemTextW(*(HWND *)(a1 + 4), 1151, v2);
  }
  if ( v6 >= 8 )
    operator delete((void *)lpString[0]);
}

//----- (00498160) --------------------------------------------------------
void __thiscall sub_498160(int this)
{
  HWND DlgItem; // edi
  void *v3; // edi
  int v4; // eax
  HWND v5; // ecx
  char **v6; // edx
  HANDLE Thread; // esi
  int v8; // esi
  int v9; // [esp-2Ch] [ebp-35Ch]
  void *v10[4]; // [esp-28h] [ebp-358h] BYREF
  LPSECURITY_ATTRIBUTES v11; // [esp-18h] [ebp-348h]
  HWND v12; // [esp-14h] [ebp-344h]
  int v13; // [esp-10h] [ebp-340h]
  UINT v14; // [esp-Ch] [ebp-33Ch] BYREF
  WPARAM v15; // [esp-8h] [ebp-338h]
  LPCRITICAL_SECTION v16; // [esp-4h] [ebp-334h]
  void *v17; // [esp+Ch] [ebp-324h]
  void *v18; // [esp+10h] [ebp-320h]
  void **v19; // [esp+14h] [ebp-31Ch]
  WCHAR String[260]; // [esp+18h] [ebp-318h] BYREF
  WCHAR v21[64]; // [esp+220h] [ebp-110h] BYREF
  WCHAR Buffer[64]; // [esp+2A0h] [ebp-90h] BYREF
  int v23; // [esp+32Ch] [ebp-4h]

  if ( *(_BYTE *)(this + 96) )
  {
    *(_BYTE *)(this + 97) = 1;
    v8 = *(_DWORD *)(this + 92);
    if ( v8 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(v8 + 52));
      v16 = (LPCRITICAL_SECTION)(v8 + 52);
      *(_BYTE *)(v8 + 76) = 1;
      LeaveCriticalSection(v16);
    }
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(this + 4), 1151);
    if ( GetWindowTextLengthW(DlgItem) )
    {
      GetWindowTextW(DlgItem, String, 260);
      v3 = operator new(0x50u);
      v18 = v3;
      v4 = 0;
      v23 = 0;
      if ( v3 )
      {
        v17 = &v14;
        sub_40AC30((char ***)&v14, (int **)(this + 76));
        v19 = v10;
        LOBYTE(v23) = 1;
        sub_4095E0(v10, String);
        v9 = *(_DWORD *)(this + 4);
        LOBYTE(v23) = 0;
        v4 = sub_497C90(
               (int)v3,
               v9,
               v10[0],
               (int)v10[1],
               (int)v10[2],
               (int)v10[3],
               (int)v11,
               (int)v12,
               v13,
               (void *)v14,
               v15,
               (int)v16);
      }
      v5 = *(HWND *)(this + 4);
      v16 = 0;
      v15 = 0;
      v14 = 1026;
      v13 = 1152;
      v12 = v5;
      *(_DWORD *)(this + 92) = v4;
      SendDlgItemMessageW(v12, v13, v14, v15, (LPARAM)v16);
      GetDlgItemTextW(*(HWND *)(this + 4), 1, (LPWSTR)(this + 98), 32);
      LoadStringW(*(HINSTANCE *)(this + 8), 0x1F47u, v21, 64);
      SetDlgItemTextW(*(HWND *)(this + 4), 1, v21);
      v6 = *(char ***)(this + 92);
      v16 = 0;
      v15 = 0;
      v14 = (UINT)v6;
      v13 = (int)sub_497C70;
      v12 = 0;
      v11 = 0;
      *(_BYTE *)(this + 96) = 1;
      Thread = CreateThread(v11, (SIZE_T)v12, (LPTHREAD_START_ROUTINE)v13, (LPVOID)v14, v15, (LPDWORD)v16);
      SetThreadPriority(Thread, -2);
      CloseHandle(Thread);
    }
    else
    {
      LoadStringW(*(HINSTANCE *)(this + 8), 0x1F46u, Buffer, 64);
      MessageBoxW(*(HWND *)(this + 4), Buffer, L"Explorer++", 0x30u);
    }
  }
}

//----- (00498320) --------------------------------------------------------
int __thiscall sub_498320(int this, unsigned __int16 a2, int a3)
{
  int result; // eax

  if ( a2 > 0x41Eu )
  {
    if ( a2 == 1153 )
    {
      sub_497DE0(this, 1);
    }
    else if ( a2 == 1154 )
    {
      sub_498020(this);
      return 0;
    }
    return 0;
  }
  if ( a2 == 1054 )
  {
    sub_497DE0(this, 0);
    return 0;
  }
  if ( a2 == 1 )
  {
    sub_498160(this);
    return 0;
  }
  result = a2 - 2;
  if ( a2 != 2 )
    return 0;
  if ( *(_BYTE *)(this + 96) )
  {
    *(_BYTE *)(this + 97) = 1;
  }
  else
  {
    EndDialog(*(HWND *)(this + 4), 0);
    return 0;
  }
  return result;
}

//----- (004983A0) --------------------------------------------------------
int __thiscall sub_4983A0(void *this)
{
  char *v1; // edi
  HMODULE ModuleHandleW; // eax
  HICON IconW; // eax
  int v4; // esi
  int v5; // eax
  _DWORD *v6; // ebx
  _DWORD *v7; // esi
  void **v8; // ecx
  void **v9; // eax
  int v10; // ecx
  int v11; // edx
  int *v12; // eax
  const WCHAR *v13; // ecx
  const WCHAR *v14; // eax
  HWND DlgItem; // esi
  int *v16; // eax
  int *v17; // ecx
  void **v18; // edx
  WCHAR *v19; // eax
  int v20; // edx
  WCHAR v21; // cx
  WPARAM v22; // edi
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // esi
  _DWORD *v26; // edi
  HWND Parent; // eax
  int v29; // esi
  _DWORD *v30; // eax
  void (__thiscall ***v31)(_DWORD, int); // ecx
  int v32; // edi
  int v33; // eax
  int v34; // esi
  void (__thiscall ***v35)(_DWORD, int); // esi
  char v37; // [esp+17h] [ebp-8ADh]
  int *v38; // [esp+18h] [ebp-8ACh] BYREF
  WPARAM wParam; // [esp+1Ch] [ebp-8A8h]
  int *v40; // [esp+20h] [ebp-8A4h] BYREF
  int v41; // [esp+24h] [ebp-8A0h]
  char *v42; // [esp+28h] [ebp-89Ch]
  int v43[3]; // [esp+2Ch] [ebp-898h] BYREF
  struct std::locale::_Locimp *v44; // [esp+38h] [ebp-88Ch]
  HIMAGELIST phimlSmall; // [esp+3Ch] [ebp-888h] BYREF
  LPARAM lParam[3]; // [esp+40h] [ebp-884h] BYREF
  WCHAR *v47; // [esp+4Ch] [ebp-878h]
  LPARAM v48[2]; // [esp+60h] [ebp-864h] BYREF
  int v49; // [esp+68h] [ebp-85Ch]
  char *szTypeName; // [esp+74h] [ebp-850h]
  LPARAM v51[13]; // [esp+94h] [ebp-830h] BYREF
  void *v52[4]; // [esp+C8h] [ebp-7FCh] BYREF
  int v53; // [esp+D8h] [ebp-7ECh]
  unsigned int v54; // [esp+DCh] [ebp-7E8h]
  LPCWSTR pszFile[4]; // [esp+E4h] [ebp-7E0h] BYREF
  int v56; // [esp+F4h] [ebp-7D0h]
  unsigned int v57; // [esp+F8h] [ebp-7CCh]
  void *FileInformation[5]; // [esp+100h] [ebp-7C4h] BYREF
  FILETIME FileTime; // [esp+114h] [ebp-7B0h] BYREF
  unsigned int v60; // [esp+11Ch] [ebp-7A8h]
  unsigned int v61; // [esp+120h] [ebp-7A4h]
  SHFILEINFOW psfi; // [esp+124h] [ebp-7A0h] BYREF
  WCHAR Buffer[32]; // [esp+3DCh] [ebp-4E8h] BYREF
  __int16 v64[32]; // [esp+41Ch] [ebp-4A8h] BYREF
  char v65; // [esp+45Ch] [ebp-468h] BYREF
  WCHAR pszPath[260]; // [esp+49Ch] [ebp-428h] BYREF
  WCHAR pszDest[262]; // [esp+6A4h] [ebp-220h] BYREF
  int v68; // [esp+8C0h] [ebp-4h]

  v1 = (char *)this;
  v42 = (char *)this;
  ModuleHandleW = GetModuleHandleW(0);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *((_DWORD *)v1 + 41) = IconW;
  SetClassLongW(*((HWND *)v1 + 1), -34, (LONG)IconW);
  memset(v43, 0, sizeof(v43));
  v44 = std::locale::_Init();
  v4 = sub_426E4C();
  std::_Lockit::_Lockit((std::_Lockit *)&v38, 0);
  v5 = *(_DWORD *)(v4 + 4);
  if ( v5 != -1 )
    *(_DWORD *)(v4 + 4) = v5 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v38);
  v68 = 0;
  v37 = 1;
  sub_40E150((int)L"", 0x100u, v43, (int)L".*[\\.]?part[0-9]+", (int)v40);
  v6 = (_DWORD *)*((_DWORD *)v1 + 19);
  v7 = (_DWORD *)*v6;
  if ( (_DWORD *)*v6 != v6 )
  {
    while ( 1 )
    {
      v54 = 7;
      v53 = 0;
      LOWORD(v52[0]) = 0;
      sub_4090E0((int)v52, v7 + 2, 0, 0xFFFFFFFF);
      LOBYTE(v68) = 1;
      v8 = (void **)v52[0];
      if ( v54 < 8 )
        v8 = v52;
      v9 = (void **)v52[0];
      v10 = (int)v8 + 2 * v53;
      if ( v54 < 8 )
        v9 = v52;
      if ( !sub_4139C0((int)v9, v10, v43, 16) )
        break;
      LOBYTE(v68) = 0;
      if ( v54 >= 8 )
        operator delete(v52[0]);
      v7 = (_DWORD *)*v7;
      if ( v7 == v6 )
        goto LABEL_15;
    }
    v37 = 0;
    if ( v54 >= 8 )
      operator delete(v52[0]);
  }
LABEL_15:
  v57 = 7;
  v56 = 0;
  LOWORD(pszFile[0]) = 0;
  LOBYTE(v68) = 2;
  if ( v37 )
  {
    sub_413640((void **)v1 + 19);
    sub_40E150((int)L"", 0x100u, v43, (int)L"[\\.]?part[0-9]+", (int)v40);
    LOWORD(v52[0]) = 0;
    v54 = 7;
    v53 = 0;
    sub_4094F0(v52, v11, &unk_4CAC54, 0);
    LOBYTE(v68) = 3;
    v12 = sub_4138C0((unsigned __int16 *)v52, (int *)FileInformation, (int *)(**((_DWORD **)v1 + 19) + 8), v43);
    LOBYTE(v68) = 4;
    sub_40AF70(pszFile, v12);
    if ( FileTime.dwLowDateTime >= 8 )
      operator delete(FileInformation[0]);
    LOBYTE(v68) = 2;
    FileTime.dwLowDateTime = 7;
    FileInformation[4] = 0;
    LOWORD(FileInformation[0]) = 0;
    if ( v54 >= 8 )
      operator delete(v52[0]);
  }
  else
  {
    sub_4094F0(pszFile, 0, L"output", 6);
  }
  v13 = pszFile[0];
  if ( v57 < 8 )
    v13 = (const WCHAR *)pszFile;
  v14 = (const WCHAR *)(v1 + 48);
  if ( *((_DWORD *)v1 + 17) >= 8u )
    v14 = *(const WCHAR **)v14;
  PathCombineW(pszDest, v14, v13);
  SetDlgItemTextW(*((HWND *)v1 + 1), 1151, pszDest);
  DlgItem = GetDlgItem(*((HWND *)v1 + 1), 1150);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1u, (LPARAM)phimlSmall);
  SetWindowTheme(DlgItem, L"Explorer", 0);
  SendMessageW(DlgItem, 0x1036u, 0x10021u, 65569);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x1F43u, Buffer, 32);
  lParam[0] = 4;
  v47 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x862u, Buffer, 32);
  lParam[0] = 4;
  v47 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1u, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x863u, Buffer, 32);
  lParam[0] = 4;
  v47 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2u, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x864u, Buffer, 32);
  lParam[0] = 4;
  v47 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 3u, (LPARAM)lParam);
  v16 = (int *)*((_DWORD *)v1 + 19);
  v17 = (int *)*v16;
  wParam = 0;
  v40 = v16;
  v38 = v17;
  if ( v17 != v16 )
  {
    while ( 2 )
    {
      LOWORD(v52[0]) = 0;
      v54 = 7;
      v53 = 0;
      sub_4090E0((int)v52, v17 + 2, 0, 0xFFFFFFFF);
      LOBYTE(v68) = 5;
      v18 = (void **)v52[0];
      if ( v54 < 8 )
        v18 = v52;
      v19 = pszPath;
      v41 = 260;
      v20 = (char *)v18 - (char *)pszPath;
      while ( v41 != -2147483386 )
      {
        v21 = *(WCHAR *)((char *)v19 + v20);
        if ( !v21 )
          break;
        *v19++ = v21;
        if ( !--v41 )
        {
          --v19;
          break;
        }
      }
      *v19 = 0;
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4400u);
      v51[1] = wParam;
      v51[0] = 3;
      v51[2] = 0;
      v51[5] = (LPARAM)pszPath;
      v51[7] = psfi.iIcon;
      SendMessageW(DlgItem, 0x104Du, 0, (LPARAM)v51);
      v49 = 1;
      szTypeName = (char *)psfi.szTypeName;
      SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v48);
      GetFileAttributesExW(pszPath, GetFileExInfoStandard, FileInformation);
      sub_46B2E0(0x20u, 0, 0, __PAIR64__(v60, v61));
      v49 = 2;
      szTypeName = &v65;
      SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v48);
      sub_46AB90(v64, 32, &FileTime, *((_DWORD *)v1 + 22));
      v22 = wParam;
      v49 = 3;
      szTypeName = (char *)v64;
      SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v48);
      wParam = v22 + 1;
      LOBYTE(v68) = 2;
      if ( v54 >= 8 )
        operator delete(v52[0]);
      v1 = v42;
      v38 = (int *)*v38;
      if ( v38 != v40 )
      {
        v17 = v38;
        continue;
      }
      break;
    }
  }
  SendMessageW(DlgItem, 0x101Eu, 0, 65534);
  SendMessageW(DlgItem, 0x101Eu, 1u, 65534);
  SendMessageW(DlgItem, 0x101Eu, 2u, 65534);
  SendMessageW(DlgItem, 0x101Eu, 3u, 65534);
  v23 = GetDlgItem(*((HWND *)v1 + 1), 1151);
  SendMessageW(v23, 0xB1u, 0, -1);
  v24 = GetDlgItem(*((HWND *)v1 + 1), 1151);
  SetFocus(v24);
  v25 = (HWND)*((_DWORD *)v1 + 1);
  v26 = (_DWORD *)*((_DWORD *)v1 + 42);
  if ( v26[1] )
  {
    SetWindowPos(v25, 0, v26[2], v26[3], v26[4], v26[5], 4u);
  }
  else
  {
    Parent = GetParent(v25);
    sub_4697F0(v25, Parent);
  }
  if ( v57 >= 8 )
    operator delete((void *)pszFile[0]);
  v57 = 7;
  v56 = 0;
  LOWORD(pszFile[0]) = 0;
  v68 = 6;
  if ( v43[0] )
  {
    if ( (*(_DWORD *)(v43[0] + 28))-- == 1 )
    {
      v29 = v43[0];
      while ( v29 )
      {
        v30 = (_DWORD *)(v29 + 12);
        v31 = (void (__thiscall ***)(_DWORD, int))v29;
        v29 = *(_DWORD *)(v29 + 12);
        *v30 = 0;
        (**v31)(v31, 1);
      }
    }
  }
  v68 = -1;
  v32 = (int)v44;
  v43[0] = 0;
  if ( v44 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v40, 0);
    v33 = *(_DWORD *)(v32 + 4);
    if ( v33 && v33 != -1 )
      *(_DWORD *)(v32 + 4) = v33 - 1;
    v34 = -(*(_DWORD *)(v32 + 4) == 0);
    std::_Lockit::~_Lockit((std::_Lockit *)&v40);
    v35 = (void (__thiscall ***)(_DWORD, int))(v32 & v34);
    if ( v35 )
      (**v35)(v35, 1);
  }
  return 0;
}
// 4988D8: conditional instruction was optimized away because %var_8A0.4!=0
// 4985D8: variable 'v11' is possibly undefined
// 4CAC10: using guessed type wchar_t aPart09[18];
// 4CAC34: using guessed type wchar_t aPart09_0[16];
// 4CAC58: using guessed type wchar_t aOutput[7];
// 4983A0: using guessed type _WORD var_4A8[32];

//----- (00498C00) --------------------------------------------------------
int __thiscall sub_498C00(_DWORD *this, LPCWSTR lpString1, wchar_t *String)
{
  int result; // eax

  if ( lstrcmpiW(lpString1, L"ColumnWidth1") )
  {
    result = lstrcmpiW(lpString1, L"ColumnWidth2");
    if ( !result )
    {
      result = _wtoi(String);
      this[136] = result;
    }
  }
  else
  {
    result = _wtoi(String);
    this[135] = result;
  }
  return result;
}

//----- (00498C60) --------------------------------------------------------
LSTATUS __thiscall sub_498C60(BYTE *this, HKEY hKey)
{
  HKEY v2; // edi
  DWORD cbData; // [esp+Ch] [ebp-4h] BYREF

  v2 = hKey;
  cbData = 4;
  RegQueryValueExW(hKey, L"ColumnWidth1", 0, 0, this + 540, &cbData);
  hKey = (HKEY)4;
  return RegQueryValueExW(v2, L"ColumnWidth2", 0, 0, this + 544, (LPDWORD)&hKey);
}

//----- (00498CC0) --------------------------------------------------------
LSTATUS __thiscall sub_498CC0(int this, HKEY hKey)
{
  HKEY v2; // edi
  BYTE Data[4]; // [esp+Ch] [ebp-4h] BYREF

  v2 = hKey;
  *(_DWORD *)Data = *(_DWORD *)(this + 540);
  RegSetValueExW(hKey, L"ColumnWidth1", 0, 4u, Data, 4u);
  hKey = *(HKEY *)(this + 544);
  return RegSetValueExW(v2, L"ColumnWidth2", 0, 4u, (const BYTE *)&hKey, 4u);
}

//----- (00498D40) --------------------------------------------------------
int __thiscall sub_498D40(HICON *this)
{
  DestroyIcon(this[16]);
  DestroyIcon(this[15]);
  return 0;
}

//----- (00498D60) --------------------------------------------------------
int __thiscall sub_498D60(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (00498D70) --------------------------------------------------------
HRESULT __thiscall sub_498D70(int *this, int a2, int a3)
{
  _itow_s(this[135], Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"ColumnWidth1", Buffer);
  _itow_s(this[136], Buffer, 0x40u, 10);
  return sub_464A60(a2, a3, (OLECHAR *)L"ColumnWidth2", Buffer);
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (00498DE0) --------------------------------------------------------
LRESULT __thiscall sub_498DE0(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  HWND DlgItem; // edi
  LRESULT result; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 72);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1094);
  *(_DWORD *)(*(_DWORD *)(this + 72) + 540) = SendMessageW(DlgItem, 0x101Du, 0, 0);
  result = SendMessageW(DlgItem, 0x101Du, 1u, 0);
  *(_DWORD *)(*(_DWORD *)(this + 72) + 544) = result;
  *(_DWORD *)(*(_DWORD *)(this + 72) + 4) = 1;
  return result;
}

//----- (00498EB0) --------------------------------------------------------
char **__stdcall sub_498EB0(_DWORD *a1, char **a2)
{
  char *v2; // ebx
  char **v3; // eax
  char *v4; // ecx
  char *v5; // ebx
  char **v6; // eax
  char *v7; // ecx
  char *v8; // ebx
  char **v9; // eax
  char *v10; // ecx
  char *v11; // ebx
  char **v12; // eax
  char *v13; // ecx
  char *v14; // ebx
  char **v15; // eax
  char *v16; // ecx
  char *v17; // ebx
  char **result; // eax
  char *v19; // ecx
  char *v20; // [esp-8h] [ebp-20h]
  char *v21; // [esp-8h] [ebp-20h]
  char *v22; // [esp-8h] [ebp-20h]
  char *v23; // [esp-8h] [ebp-20h]
  char *v24; // [esp-8h] [ebp-20h]
  char *v25; // [esp-8h] [ebp-20h]
  int v26; // [esp-4h] [ebp-1Ch]
  int v27; // [esp-4h] [ebp-1Ch]
  int v28; // [esp-4h] [ebp-1Ch]
  int v29; // [esp-4h] [ebp-1Ch]
  int v30; // [esp-4h] [ebp-1Ch]
  int v31; // [esp-4h] [ebp-1Ch]
  int v32; // [esp+Ch] [ebp-Ch] BYREF
  int v33; // [esp+10h] [ebp-8h]
  int v34; // [esp+14h] [ebp-4h]

  *a1 = 0;
  v2 = *a2;
  v26 = *((_DWORD *)*a2 + 1);
  v20 = *a2;
  v32 = 1095;
  v33 = 1;
  v34 = 1;
  v3 = sub_41EEB0((char **)&v32, v20, v26);
  v4 = a2[1];
  if ( v4 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v4 + 1;
  *((_DWORD *)v2 + 1) = v3;
  *(_DWORD *)v3[1] = v3;
  v5 = *a2;
  v27 = *((_DWORD *)*a2 + 1);
  v21 = *a2;
  v32 = 1219;
  v33 = 0;
  v34 = 1;
  v6 = sub_41EEB0((char **)&v32, v21, v27);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v5 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v8 = *a2;
  v28 = *((_DWORD *)*a2 + 1);
  v22 = *a2;
  v32 = 1094;
  v33 = 1;
  v34 = 0;
  v9 = sub_41EEB0((char **)&v32, v22, v28);
  v10 = a2[1];
  if ( v10 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v10 + 1;
  *((_DWORD *)v8 + 1) = v9;
  *(_DWORD *)v9[1] = v9;
  v11 = *a2;
  v29 = *((_DWORD *)*a2 + 1);
  v23 = *a2;
  v32 = 1;
  v33 = 0;
  v34 = 0;
  v12 = sub_41EEB0((char **)&v32, v23, v29);
  v13 = a2[1];
  if ( v13 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v13 + 1;
  *((_DWORD *)v11 + 1) = v12;
  *(_DWORD *)v12[1] = v12;
  v14 = *a2;
  v30 = *((_DWORD *)*a2 + 1);
  v24 = *a2;
  v32 = 2;
  v33 = 0;
  v34 = 0;
  v15 = sub_41EEB0((char **)&v32, v24, v30);
  v16 = a2[1];
  if ( v16 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v16 + 1;
  *((_DWORD *)v14 + 1) = v15;
  *(_DWORD *)v15[1] = v15;
  v17 = *a2;
  v31 = *((_DWORD *)*a2 + 1);
  v25 = *a2;
  v32 = 1304;
  v33 = 0;
  v34 = 0;
  result = sub_41EEB0((char **)&v32, v25, v31);
  v19 = a2[1];
  if ( v19 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v19 + 1;
  *((_DWORD *)v17 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (00499070) --------------------------------------------------------
int *sub_499070()
{
  if ( (dword_4F1FD8 & 1) == 0 )
  {
    dword_4F1FD8 |= 1u;
    sub_4653E0((int)&dword_4F0E60, (int)L"MassRename");
    dword_4F0E60 = (int)&CMassRenameDialogPersistentSettings::`vftable';
    dword_4F107C = 250;
    dword_4F1080 = 250;
    atexit(sub_4BCCD0);
  }
  return &dword_4F0E60;
}
// 4CADA0: using guessed type wchar_t aMassrename[11];
// 4CBFE4: using guessed type void *CMassRenameDialogPersistentSettings::`vftable';
// 4F0E60: using guessed type int dword_4F0E60;
// 4F107C: using guessed type int dword_4F107C;
// 4F1080: using guessed type int dword_4F1080;
// 4F1FD8: using guessed type int dword_4F1FD8;

//----- (00499100) --------------------------------------------------------
int __thiscall sub_499100(int this)
{
  int v2; // esi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // edi
  LONG v5; // eax
  LPARAM v6; // eax
  HWND DlgItem; // esi
  LONG WindowLongW; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  const WCHAR *v11; // eax
  LPCWSTR *v12; // edx
  WCHAR *v13; // eax
  int v14; // edx
  WCHAR v15; // cx
  HWND v16; // eax
  HWND v17; // eax
  HWND v18; // edi
  _DWORD *v19; // ebx
  HWND Parent; // eax
  HWND v22; // [esp-14h] [ebp-5FCh]
  int v23; // [esp+Ch] [ebp-5DCh]
  int v24; // [esp+10h] [ebp-5D8h]
  _DWORD *v25; // [esp+14h] [ebp-5D4h]
  HIMAGELIST phimlSmall; // [esp+18h] [ebp-5D0h] BYREF
  _DWORD *v27; // [esp+1Ch] [ebp-5CCh]
  LPARAM v28; // [esp+20h] [ebp-5C8h] BYREF
  int v29; // [esp+24h] [ebp-5C4h]
  int v30; // [esp+28h] [ebp-5C0h]
  WCHAR *v31; // [esp+34h] [ebp-5B4h]
  int iIcon; // [esp+3Ch] [ebp-5ACh]
  LPARAM lParam[3]; // [esp+54h] [ebp-594h] BYREF
  WCHAR *v34; // [esp+60h] [ebp-588h]
  LPCWSTR pszPath[5]; // [esp+74h] [ebp-574h] BYREF
  unsigned int v36; // [esp+88h] [ebp-560h]
  struct tagRECT Rect; // [esp+90h] [ebp-558h] BYREF
  SHFILEINFOW psfi; // [esp+A0h] [ebp-548h] BYREF
  WCHAR Buffer[64]; // [esp+358h] [ebp-290h] BYREF
  WCHAR v40[262]; // [esp+3D8h] [ebp-210h] BYREF

  v2 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v2, (int)BitmapW, 0);
  v5 = sub_409F80(v2, 24, 0);
  *(_DWORD *)(this + 60) = v5;
  SetClassLongW(*(HWND *)(this + 4), -34, v5);
  v6 = sub_409F80(v2, 22, 0);
  v22 = *(HWND *)(this + 4);
  *(_DWORD *)(this + 64) = v6;
  SendDlgItemMessageW(v22, 1219, 0xF7u, 1u, v6);
  DeleteObject(BitmapW);
  sub_409E60(v2);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1094);
  WindowLongW = GetWindowLongW(DlgItem, -16);
  SetWindowLongW(DlgItem, -16, WindowLongW | 0x40);
  SetWindowTheme(DlgItem, L"Explorer", 0);
  SendMessageW(DlgItem, 0x1036u, 0x10023u, 65571);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1u, (LPARAM)phimlSmall);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x853u, Buffer, 64);
  lParam[0] = 4;
  v34 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1u, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x854u, Buffer, 64);
  lParam[0] = 4;
  v34 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2u, (LPARAM)lParam);
  GetClientRect(DlgItem, &Rect);
  SendMessageW(DlgItem, 0x101Eu, 0, *(_DWORD *)(*(_DWORD *)(this + 72) + 540));
  SendMessageW(DlgItem, 0x101Eu, 1u, *(_DWORD *)(*(_DWORD *)(this + 72) + 544));
  v9 = *(_DWORD **)(this + 48);
  v10 = (_DWORD *)*v9;
  v23 = 0;
  v27 = v9;
  v25 = v10;
  if ( v10 != v9 )
  {
    while ( 2 )
    {
      LOWORD(pszPath[0]) = 0;
      v36 = 7;
      pszPath[4] = 0;
      sub_4090E0((int)pszPath, v10 + 2, 0, 0xFFFFFFFF);
      v11 = pszPath[0];
      if ( v36 < 8 )
        v11 = (const WCHAR *)pszPath;
      SHGetFileInfoW(v11, 0, &psfi, 0x2B4u, 0x4000u);
      v12 = (LPCWSTR *)pszPath[0];
      if ( v36 < 8 )
        v12 = pszPath;
      v13 = v40;
      v24 = 260;
      v14 = (char *)v12 - (char *)v40;
      while ( v24 != -2147483386 )
      {
        v15 = *(WCHAR *)((char *)v13 + v14);
        if ( !v15 )
          break;
        *v13++ = v15;
        if ( !--v24 )
        {
          --v13;
          break;
        }
      }
      *v13 = 0;
      PathStripPathW(v40);
      v29 = v23;
      v28 = 3;
      v30 = 0;
      iIcon = psfi.iIcon;
      v31 = v40;
      SendMessageW(DlgItem, 0x104Du, 0, (LPARAM)&v28);
      v28 = 1;
      v30 = 1;
      v29 = v23;
      v31 = v40;
      SendMessageW(DlgItem, 0x104Cu, 0, (LPARAM)&v28);
      ++v23;
      if ( v36 >= 8 )
        operator delete((void *)pszPath[0]);
      v25 = (_DWORD *)*v25;
      if ( v25 != v27 )
      {
        v10 = v25;
        continue;
      }
      break;
    }
  }
  SetDlgItemTextW(*(HWND *)(this + 4), 1095, L"/F");
  v16 = GetDlgItem(*(HWND *)(this + 4), 1095);
  SendMessageW(v16, 0xB1u, 0, -1);
  v17 = GetDlgItem(*(HWND *)(this + 4), 1095);
  SetFocus(v17);
  v18 = *(HWND *)(this + 4);
  v19 = *(_DWORD **)(this + 72);
  if ( v19[1] )
  {
    SetWindowPos(v18, 0, v19[2], v19[3], v19[4], v19[5], 4u);
  }
  else
  {
    Parent = GetParent(v18);
    sub_4697F0(v18, Parent);
  }
  return 0;
}
// 499388: conditional instruction was optimized away because %var_5D8.4!=0

//----- (004994F0) --------------------------------------------------------
int __thiscall sub_4994F0(void *this, int a2, void *a3, int a4, int a5, int a6)
{
  char ***v6; // ebx
  char **v7; // eax
  void *v8; // edi
  bool v9; // zf
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v12; // [esp+1Ch] [ebp-14h] BYREF
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v14 = 0;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(a2 + 12) = 175;
  *(_DWORD *)(a2 + 16) = this;
  *(_BYTE *)(a2 + 28) = 1;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  LOBYTE(v14) = 1;
  *(_DWORD *)a2 = &CMassRenameDialog::`vftable';
  v6 = (char ***)(a2 + 48);
  *(_DWORD *)(a2 + 52) = 0;
  v7 = (char **)operator new(0x24u);
  if ( !v7 )
  {
    v12 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v6 = v7;
  *v7 = (char *)v7;
  (*v6)[1] = (char *)*v6;
  LOBYTE(v14) = 2;
  if ( v6 != (char ***)&a3 )
  {
    v8 = a3;
    v13 = *(_DWORD *)a3;
    sub_40A140((int)v6);
    sub_40B6E0(a2 + 48, **v6, v13, (int)v8, a2);
  }
  v9 = (dword_4F1FD8 & 1) == 0;
  *(_DWORD *)(a2 + 68) = a6;
  if ( v9 )
  {
    dword_4F1FD8 |= 1u;
    sub_4653E0((int)&dword_4F0E60, (int)L"MassRename");
    dword_4F0E60 = (int)&CMassRenameDialogPersistentSettings::`vftable';
    dword_4F107C = 250;
    dword_4F1080 = 250;
    atexit(sub_4BCCD0);
  }
  *(_DWORD *)(a2 + 72) = &dword_4F0E60;
  sub_40A140((int)&a3);
  operator delete(a3);
  return a2;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CADA0: using guessed type wchar_t aMassrename[11];
// 4CBFAC: using guessed type void *CMassRenameDialog::`vftable';
// 4CBFE4: using guessed type void *CMassRenameDialogPersistentSettings::`vftable';
// 4F0E60: using guessed type int dword_4F0E60;
// 4F107C: using guessed type int dword_4F107C;
// 4F1080: using guessed type int dword_4F1080;
// 4F1FD8: using guessed type int dword_4F1FD8;

//----- (00499640) --------------------------------------------------------
void __userpurge sub_499640(
        int *a1@<edi>,
        void *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        LPCWSTR a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16)
{
  _BYTE *v16; // esi
  WCHAR *v17; // eax
  int v18; // edx
  int v19; // esi
  WCHAR v20; // cx
  const WCHAR *v21; // eax
  int v22; // esi
  int v23; // eax
  unsigned int v24; // ecx
  int *v25; // eax
  int *v26; // ecx
  int *v27; // ebx
  int v28; // esi
  int *v29; // ecx
  int v30; // ecx
  int v31; // eax
  _DWORD *v32; // eax
  int *v33; // edx
  int v34; // edx
  int *v35; // ecx
  int v36; // eax
  int v37; // ebx
  int v38; // eax
  int v39; // esi
  void (__thiscall ***v40)(_DWORD, int); // esi
  int i; // eax
  int j; // eax
  int k; // eax
  char v44[16]; // [esp+10h] [ebp-354h] BYREF
  int v45[4]; // [esp+20h] [ebp-344h] BYREF
  int v46[2]; // [esp+30h] [ebp-334h] BYREF
  void **v47; // [esp+38h] [ebp-32Ch] BYREF
  char v48[12]; // [esp+3Ch] [ebp-328h] BYREF
  void **v49; // [esp+48h] [ebp-31Ch]
  _DWORD *v50; // [esp+4Ch] [ebp-318h]
  _DWORD *v51; // [esp+58h] [ebp-30Ch]
  _DWORD *v52; // [esp+5Ch] [ebp-308h]
  _DWORD *v53; // [esp+68h] [ebp-2FCh]
  _DWORD *v54; // [esp+6Ch] [ebp-2F8h]
  int v55[2]; // [esp+70h] [ebp-2F4h]
  int v56; // [esp+78h] [ebp-2ECh]
  int v57[20]; // [esp+80h] [ebp-2E4h] BYREF
  int v58; // [esp+D0h] [ebp-294h]
  void *v59; // [esp+D4h] [ebp-290h]
  int v60; // [esp+D8h] [ebp-28Ch]
  int v61; // [esp+DCh] [ebp-288h]
  int v62; // [esp+E4h] [ebp-280h]
  int v63; // [esp+E8h] [ebp-27Ch]
  char v64; // [esp+ECh] [ebp-278h]
  int v65; // [esp+F0h] [ebp-274h]
  int v66; // [esp+F4h] [ebp-270h]
  char v67; // [esp+F8h] [ebp-26Ch]
  int v68[2]; // [esp+FCh] [ebp-268h] BYREF
  char v69; // [esp+104h] [ebp-260h]
  int v70[4]; // [esp+108h] [ebp-25Ch] BYREF
  char v71[4]; // [esp+118h] [ebp-24Ch] BYREF
  void *v72; // [esp+11Ch] [ebp-248h]
  char v73[4]; // [esp+120h] [ebp-244h] BYREF
  void *Src; // [esp+124h] [ebp-240h]
  char v75; // [esp+12Bh] [ebp-239h]
  void *v76[7]; // [esp+12Ch] [ebp-238h] BYREF
  WCHAR pszPath[260]; // [esp+148h] [ebp-21Ch] BYREF
  int v78; // [esp+360h] [ebp-4h]

  v78 = 1;
  v16 = a9;
  if ( (unsigned int)a14 < 8 )
    v16 = &a9;
  v17 = pszPath;
  v18 = 260;
  v19 = v16 - (_BYTE *)pszPath;
  while ( v18 != -2147483386 )
  {
    v20 = *(WCHAR *)((char *)v17 + v19);
    if ( !v20 )
      break;
    *v17++ = v20;
    if ( !--v18 )
    {
      --v17;
      break;
    }
  }
  *v17 = 0;
  PathRemoveExtensionW(pszPath);
  v21 = a9;
  if ( (unsigned int)a14 < 8 )
    v21 = (const WCHAR *)&a9;
  Src = PathFindExtensionW(v21);
  sub_4090E0((int)a1, &a2, 0, 0xFFFFFFFF);
  memset(v70, 0, 12);
  v70[3] = (int)std::locale::_Init();
  v22 = sub_426E4C();
  std::_Lockit::_Lockit((std::_Lockit *)v71, 0);
  v23 = *(_DWORD *)(v22 + 4);
  if ( v23 != -1 )
    *(_DWORD *)(v22 + 4) = v23 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v71);
  LOBYTE(v78) = 2;
  sub_40E150((int)L"", 1u, v70, (int)L"/[0]*N", (int)Src);
  v75 = 0;
  do
  {
    v58 = 0;
    v59 = 0;
    v60 = 0;
    v61 = 0;
    v62 = 0;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v68[0] = 0;
    v68[1] = 0;
    v69 = 0;
    LOBYTE(v78) = 3;
    v24 = a1[5];
    if ( v24 < 8 )
      v25 = a1;
    else
      v25 = (int *)*a1;
    if ( v24 < 8 )
      v26 = a1;
    else
      v26 = (int *)*a1;
    if ( sub_40E260((int)v25, (unsigned __int16 *)v26 + a1[4], v70, (int)v25) )
    {
      sub_40BE70(v45);
      LOBYTE(v78) = 4;
      v27 = (int *)v59;
      v28 = (v60 - (int)v59) / 12;
      v29 = v68;
      if ( v28 )
        v29 = (int *)v59;
      if ( *((_BYTE *)v29 + 8) )
        v30 = (v29[1] - *v29) >> 1;
      else
        v30 = 0;
      *(_WORD *)((char *)v55 + *(_DWORD *)(v46[0] + 4)) = 48;
      v31 = std::setw(v44, v30 - 1, (v30 - 1) >> 31);
      (*(void (__cdecl **)(char *, _DWORD, _DWORD))v31)(
        (char *)v46 + *(_DWORD *)(v46[0] + 4),
        *(_DWORD *)(v31 + 8),
        *(_DWORD *)(v31 + 12));
      sub_40BB80(v46, a16);
      v32 = sub_40BFB0((int)v45, v76);
      LOBYTE(v78) = 5;
      v33 = v68;
      if ( v28 )
        v33 = v27;
      if ( *((_BYTE *)v33 + 8) )
        v34 = (v33[1] - *v33) >> 1;
      else
        v34 = 0;
      v35 = v68;
      if ( v28 )
        v35 = v27;
      sub_40C0F0((*v35 - v58) >> 1, a1, v34, v32, 0, 0xFFFFFFFF);
      if ( v76[5] >= (void *)8 )
        operator delete(v76[0]);
      v36 = *(_DWORD *)(v45[0] + 4);
      v57[18] = (int)v57;
      *(int *)((char *)v45 + v36) = (int)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
      v57[19] = (int)&v47;
      v47 = &std::wstringbuf::`vftable';
      if ( (v56 & 1) != 0 )
        operator delete(*v49);
      *v49 = 0;
      *v51 = 0;
      *v53 = 0;
      *v50 = 0;
      *v52 = 0;
      *v54 = 0;
      v56 &= ~1u;
      v55[1] = 0;
      v47 = &std::wstreambuf::`vftable';
      LOBYTE(v78) = 7;
      v72 = (void *)v55[0];
      if ( v55[0] )
      {
        v37 = *(_DWORD *)v55[0];
        if ( *(_DWORD *)v55[0] )
        {
          std::_Lockit::_Lockit((std::_Lockit *)v73, 0);
          v38 = *(_DWORD *)(v37 + 4);
          if ( v38 && v38 != -1 )
            *(_DWORD *)(v37 + 4) = v38 - 1;
          v39 = -(*(_DWORD *)(v37 + 4) == 0);
          std::_Lockit::~_Lockit((std::_Lockit *)v73);
          v40 = (void (__thiscall ***)(_DWORD, int))(v37 & v39);
          if ( v40 )
            (**v40)(v40, 1);
        }
        operator delete(v72);
        v27 = (int *)v59;
      }
      LOBYTE(v78) = 6;
      std::_Mutex::~_Mutex((std::_Mutex *)v48);
      LOBYTE(v78) = 3;
      *(int *)((char *)v45 + *(_DWORD *)(v45[0] + 4)) = (int)&std::wiostream::`vftable';
      *(int *)((char *)v46 + *(_DWORD *)(v46[0] + 4)) = (int)&std::wostream::`vftable';
      *(int *)((char *)v45 + *(_DWORD *)(v45[0] + 4)) = (int)&std::wistream::`vftable';
      v57[0] = (int)&std::ios_base::`vftable';
      std::ios_base::_Ios_base_dtor((struct std::ios_base *)v57);
    }
    else
    {
      v27 = (int *)v59;
      v75 = 1;
    }
    LOBYTE(v78) = 2;
    if ( v27 )
      operator delete(v27);
  }
  while ( !v75 );
  for ( i = sub_40C610(a1, L"/F", 2u); i != -1; i = sub_40C610(a1, L"/F", 2u) )
    sub_40C0F0(i, a1, 2u, &a9, 0, 0xFFFFFFFF);
  for ( j = sub_40C610(a1, L"/B", 2u); j != -1; j = sub_40C610(a1, L"/B", 2u) )
    sub_40C420((unsigned int)a1, j, pszPath, wcslen(pszPath));
  for ( k = sub_40C610(a1, L"/E", 2u); k != -1; k = sub_40C610(a1, L"/E", 2u) )
    sub_40C420((unsigned int)a1, k, Src, wcslen((const unsigned __int16 *)Src));
  LOBYTE(v78) = 1;
  sub_40BD70(v70);
  if ( (unsigned int)a7 >= 8 )
    operator delete(a2);
  a7 = 7;
  a6 = 0;
  LOWORD(a2) = 0;
  if ( (unsigned int)a14 >= 8 )
    operator delete((void *)a9);
}
// 4996B2: conditional instruction was optimized away because edx.4!=0
// 427BA9: using guessed type _DWORD __cdecl std::setw(_DWORD, _DWORD, _DWORD);
// 4CADF8: using guessed type wchar_t a0N[7];
// 4CAE08: using guessed type wchar_t asc_4CAE08[3];
// 4CAE10: using guessed type wchar_t aB_6[3];
// 4CAE18: using guessed type wchar_t aE[3];
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBADC: using guessed type void *std::wstreambuf::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CBF4C: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';
// 499640: using guessed type char var_24C[4];
// 499640: using guessed type char var_354[16];
// 499640: using guessed type char var_244[4];
// 499640: using guessed type char var_328[12];

//----- (00499C20) --------------------------------------------------------
void __thiscall sub_499C20(_DWORD *this)
{
  _DWORD *v1; // esi
  HWND v2; // ecx
  char *v3; // eax
  int *v4; // ecx
  int *v5; // eax
  void **v6; // esi
  WCHAR *v7; // eax
  int v8; // edx
  int v9; // esi
  WCHAR v10; // cx
  void **v11; // esi
  WCHAR *v12; // eax
  int v13; // edx
  int v14; // esi
  WCHAR v15; // cx
  int v16; // edx
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  char *v19; // esi
  char *v20; // eax
  void *v21[4]; // [esp-3Ch] [ebp-56Ch] BYREF
  int v22; // [esp-2Ch] [ebp-55Ch]
  int v23; // [esp-28h] [ebp-558h]
  int v24; // [esp-24h] [ebp-554h]
  LPCWSTR v25[4]; // [esp-20h] [ebp-550h] BYREF
  int v26; // [esp-10h] [ebp-540h]
  int v27; // [esp-Ch] [ebp-53Ch]
  int v28; // [esp-8h] [ebp-538h]
  int v29; // [esp-4h] [ebp-534h]
  LPCWSTR *v30; // [esp+14h] [ebp-51Ch]
  int pExceptionObject[4]; // [esp+18h] [ebp-518h] BYREF
  char *v32; // [esp+28h] [ebp-508h]
  int *v33; // [esp+2Ch] [ebp-504h]
  _DWORD *v34; // [esp+30h] [ebp-500h]
  char *v35; // [esp+34h] [ebp-4FCh] BYREF
  void *v36; // [esp+38h] [ebp-4F8h] BYREF
  int v37; // [esp+3Ch] [ebp-4F4h]
  int v38; // [esp+44h] [ebp-4ECh]
  int *v39; // [esp+48h] [ebp-4E8h]
  void *v40[5]; // [esp+4Ch] [ebp-4E4h] BYREF
  unsigned int v41; // [esp+60h] [ebp-4D0h]
  void *v42[5]; // [esp+68h] [ebp-4C8h] BYREF
  unsigned int v43; // [esp+7Ch] [ebp-4B4h]
  void *v44[5]; // [esp+84h] [ebp-4ACh] BYREF
  unsigned int v45; // [esp+98h] [ebp-498h]
  void *v46[5]; // [esp+A0h] [ebp-490h] BYREF
  unsigned int v47; // [esp+B4h] [ebp-47Ch]
  void *v48[4]; // [esp+BCh] [ebp-474h] BYREF
  int v49; // [esp+CCh] [ebp-464h]
  unsigned int v50; // [esp+D0h] [ebp-460h]
  void *v51; // [esp+D8h] [ebp-458h] BYREF
  int v52; // [esp+E8h] [ebp-448h]
  unsigned int v53; // [esp+ECh] [ebp-444h]
  void *v54[5]; // [esp+F4h] [ebp-43Ch] BYREF
  unsigned int v55; // [esp+108h] [ebp-428h]
  WCHAR String[260]; // [esp+110h] [ebp-420h] BYREF
  WCHAR pszPath[260]; // [esp+318h] [ebp-218h] BYREF
  int v58; // [esp+52Ch] [ebp-4h]

  v29 = 260;
  v1 = this;
  v2 = (HWND)this[1];
  v34 = v1;
  GetDlgItemTextW(v2, 1095, String, 260);
  if ( lstrlenW(String) )
  {
    v37 = 0;
    v3 = (char *)operator new(0x40u);
    v32 = v3;
    if ( !v3 )
    {
      v35 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v35);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_DWORD *)v3 = v3;
    v36 = v3;
    *((_DWORD *)v3 + 1) = v3;
    v58 = 0;
    v4 = (int *)v1[12];
    v5 = (int *)*v4;
    v38 = 0;
    v33 = v4;
    v39 = v5;
    if ( v5 != v4 )
    {
      while ( 2 )
      {
        LOWORD(v54[0]) = 0;
        v55 = 7;
        v54[4] = 0;
        sub_4090E0((int)v54, v5 + 2, 0, 0xFFFFFFFF);
        v6 = (void **)v54[0];
        if ( v55 < 8 )
          v6 = v54;
        v7 = pszPath;
        v8 = 260;
        v9 = (char *)v6 - (char *)pszPath;
        while ( v8 != -2147483386 )
        {
          v10 = *(WCHAR *)((char *)v7 + v9);
          if ( !v10 )
            break;
          *v7++ = v10;
          if ( !--v8 )
          {
            --v7;
            break;
          }
        }
        *v7 = 0;
        PathStripPathW(pszPath);
        v47 = 7;
        v46[4] = 0;
        LOWORD(v46[0]) = 0;
        v29 = v38;
        LOBYTE(v58) = 2;
        v27 = 7;
        v26 = 0;
        LOWORD(v25[0]) = 0;
        v30 = v25;
        sub_4094F0(v25, (int)pszPath, pszPath, wcslen(pszPath));
        LOBYTE(v58) = 3;
        v23 = 7;
        v22 = 0;
        LOWORD(v21[0]) = 0;
        pExceptionObject[3] = (int)v21;
        sub_4094F0(v21, (int)String, String, wcslen(String));
        LOBYTE(v58) = 2;
        sub_499640(
          (int *)v46,
          v21[0],
          (int)v21[1],
          (int)v21[2],
          (int)v21[3],
          v22,
          v23,
          v24,
          v25[0],
          (int)v25[1],
          (int)v25[2],
          (int)v25[3],
          v26,
          v27,
          v28,
          v29);
        v11 = (void **)v54[0];
        if ( v55 < 8 )
          v11 = v54;
        v12 = pszPath;
        v13 = 260;
        v14 = (char *)v11 - (char *)pszPath;
        while ( v13 != -2147483386 )
        {
          v15 = *(WCHAR *)((char *)v12 + v14);
          if ( !v15 )
            break;
          *v12++ = v15;
          if ( !--v13 )
          {
            --v12;
            break;
          }
        }
        *v12 = 0;
        PathRemoveFileSpecW(pszPath);
        LOWORD(v44[0]) = 0;
        v45 = 7;
        v44[4] = 0;
        sub_4094F0(v44, v16, L"\\", 1);
        LOBYTE(v58) = 4;
        v17 = sub_40B1A0(pszPath, v42, v44);
        LOBYTE(v58) = 5;
        v18 = sub_40DFD0(v46, v17, v40);
        LOBYTE(v58) = 6;
        sub_40AF70(v46, v18);
        if ( v41 >= 8 )
          operator delete(v40[0]);
        v41 = 7;
        v40[4] = 0;
        LOWORD(v40[0]) = 0;
        if ( v43 >= 8 )
          operator delete(v42[0]);
        v43 = 7;
        v42[4] = 0;
        LOWORD(v42[0]) = 0;
        if ( v45 >= 8 )
          operator delete(v44[0]);
        v50 = 7;
        v49 = 0;
        LOWORD(v48[0]) = 0;
        v53 = 7;
        v52 = 0;
        LOWORD(v51) = 0;
        LOBYTE(v58) = 7;
        sub_4090E0((int)v48, v54, 0, 0xFFFFFFFF);
        sub_4090E0((int)&v51, v46, 0, 0xFFFFFFFF);
        v19 = v32;
        v20 = sub_40B0E0(v32, *((_DWORD *)v32 + 1), (int)v48);
        if ( v37 == 76695843 )
          std::_Xlength_error("list<T> too long");
        ++v37;
        ++v38;
        *((_DWORD *)v19 + 1) = v20;
        **((_DWORD **)v20 + 1) = v20;
        if ( v53 >= 8 )
          operator delete(v51);
        v53 = 7;
        v52 = 0;
        LOWORD(v51) = 0;
        if ( v50 >= 8 )
          operator delete(v48[0]);
        v50 = 7;
        v49 = 0;
        LOWORD(v48[0]) = 0;
        if ( v47 >= 8 )
          operator delete(v46[0]);
        LOBYTE(v58) = 0;
        if ( v55 >= 8 )
          operator delete(v54[0]);
        v39 = (int *)*v39;
        if ( v39 != v33 )
        {
          v5 = v39;
          continue;
        }
        break;
      }
      v1 = v34;
    }
    sub_463A50((char ***)&v36, v1[17]);
    EndDialog((HWND)v1[1], 1);
    sub_40B060((int)&v36);
    operator delete(v36);
  }
  else
  {
    EndDialog((HWND)v1[1], 1);
  }
}
// 499DA6: conditional instruction was optimized away because edx.4!=0
// 499EC0: conditional instruction was optimized away because edx.4!=0
// 499EFE: variable 'v16' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CADF4: using guessed type wchar_t asc_4CADF4[2];

//----- (0049A150) --------------------------------------------------------
int __thiscall sub_49A150(int this, int a2, int a3)
{
  int *v4; // esi
  int *v5; // eax
  struct tagRECT *left; // esi
  WCHAR *v7; // eax
  int v8; // edx
  int v9; // esi
  WCHAR v10; // cx
  int v11; // edx
  int v12; // kr00_4
  int v13; // edx
  int v14; // kr04_4
  void **v15; // esi
  char *v16; // eax
  int v17; // edx
  int v18; // esi
  __int16 v19; // cx
  int v20; // esi
  HMENU MenuW; // eax
  HMENU SubMenu; // edi
  HWND DlgItem; // eax
  void *v25[4]; // [esp-3Ch] [ebp-700h] BYREF
  int v26; // [esp-2Ch] [ebp-6F0h]
  int v27; // [esp-28h] [ebp-6ECh]
  int v28; // [esp-24h] [ebp-6E8h]
  LPCWSTR v29[4]; // [esp-20h] [ebp-6E4h] BYREF
  int v30; // [esp-10h] [ebp-6D4h]
  int v31; // [esp-Ch] [ebp-6D0h]
  WPARAM v32; // [esp-8h] [ebp-6CCh]
  const wchar_t *v33; // [esp-4h] [ebp-6C8h]
  int *v34; // [esp+10h] [ebp-6B4h]
  int v35; // [esp+14h] [ebp-6B0h]
  HWND hWnd; // [esp+18h] [ebp-6ACh]
  int *v37; // [esp+1Ch] [ebp-6A8h]
  void **v38; // [esp+20h] [ebp-6A4h]
  LPCWSTR *v39; // [esp+24h] [ebp-6A0h]
  LPARAM lParam[13]; // [esp+28h] [ebp-69Ch] BYREF
  struct tagRECT Rect; // [esp+5Ch] [ebp-668h] BYREF
  int v42; // [esp+6Ch] [ebp-658h]
  unsigned int v43; // [esp+70h] [ebp-654h]
  void *v44[5]; // [esp+78h] [ebp-64Ch] BYREF
  unsigned int v45; // [esp+8Ch] [ebp-638h]
  WCHAR pszPath[260]; // [esp+94h] [ebp-630h] BYREF
  WCHAR String[260]; // [esp+29Ch] [ebp-428h] BYREF
  char v48[524]; // [esp+4A4h] [ebp-220h] BYREF
  int v49; // [esp+6C0h] [ebp-4h]

  if ( HIWORD(a2) )
  {
    if ( HIWORD(a2) == 768 )
    {
      GetDlgItemTextW(*(HWND *)(this + 4), 1095, String, 260);
      hWnd = GetDlgItem(*(HWND *)(this + 4), 1094);
      v45 = 7;
      v44[4] = 0;
      LOWORD(v44[0]) = 0;
      v49 = 0;
      v4 = *(int **)(this + 48);
      v5 = (int *)*v4;
      v35 = 0;
      v37 = v4;
      v34 = v5;
      if ( v5 != v4 )
      {
        while ( 2 )
        {
          LOWORD(Rect.left) = 0;
          v43 = 7;
          v42 = 0;
          sub_4090E0((int)&Rect, v5 + 2, 0, 0xFFFFFFFF);
          LOBYTE(v49) = 1;
          left = (struct tagRECT *)Rect.left;
          if ( v43 < 8 )
            left = &Rect;
          v7 = pszPath;
          v8 = 260;
          v9 = (char *)left - (char *)pszPath;
          while ( v8 != -2147483386 )
          {
            v10 = *(WCHAR *)((char *)v7 + v9);
            if ( !v10 )
              break;
            *v7++ = v10;
            if ( !--v8 )
            {
              --v7;
              break;
            }
          }
          *v7 = 0;
          PathStripPathW(pszPath);
          v33 = (const wchar_t *)v35;
          HIWORD(v11) = 0;
          v31 = 7;
          v30 = 0;
          v39 = v29;
          LOWORD(v29[0]) = 0;
          v12 = wcslen(pszPath);
          sub_4094F0(v29, v11, pszPath, v12);
          LOBYTE(v49) = 2;
          HIWORD(v13) = 0;
          v27 = 7;
          v26 = 0;
          v38 = v25;
          LOWORD(v25[0]) = 0;
          v14 = wcslen(String);
          sub_4094F0(v25, v13, String, v14);
          LOBYTE(v49) = 1;
          sub_499640(
            (int *)v44,
            v25[0],
            (int)v25[1],
            (int)v25[2],
            (int)v25[3],
            v26,
            v27,
            v28,
            v29[0],
            (int)v29[1],
            (int)v29[2],
            (int)v29[3],
            v30,
            v31,
            v32,
            (int)v33);
          v15 = (void **)v44[0];
          if ( v45 < 8 )
            v15 = v44;
          v16 = v48;
          v17 = 260;
          v18 = (char *)v15 - v48;
          while ( v17 != -2147483386 )
          {
            v19 = *(_WORD *)&v16[v18];
            if ( !v19 )
              break;
            *(_WORD *)v16 = v19;
            v16 += 2;
            if ( !--v17 )
            {
              v16 -= 2;
              break;
            }
          }
          v20 = v35;
          v33 = (const wchar_t *)lParam;
          v32 = 0;
          *(_WORD *)v16 = 0;
          lParam[0] = 1;
          lParam[1] = v20;
          lParam[2] = 1;
          lParam[5] = (LPARAM)v48;
          SendMessageW(hWnd, 0x104Cu, v32, (LPARAM)v33);
          LOBYTE(v49) = 0;
          v35 = v20 + 1;
          if ( v43 >= 8 )
            operator delete((void *)Rect.left);
          v34 = (int *)*v34;
          if ( v34 != v37 )
          {
            v5 = v34;
            continue;
          }
          break;
        }
        if ( v45 >= 8 )
          operator delete(v44[0]);
      }
    }
  }
  else
  {
    switch ( (unsigned __int16)a2 )
    {
      case 1u:
        sub_499C20((_DWORD *)this);
        break;
      case 2u:
        EndDialog(*(HWND *)(this + 4), 0);
        break;
      case 0x4C3u:
        MenuW = LoadMenuW(*(HINSTANCE *)(this + 8), (LPCWSTR)0xDF);
        SubMenu = GetSubMenu(MenuW, 0);
        DlgItem = GetDlgItem(*(HWND *)(this + 4), 1219);
        GetWindowRect(DlgItem, &Rect);
        switch ( TrackPopupMenu(SubMenu, 0x140u, Rect.right, Rect.top, 0, *(HWND *)(this + 4), 0) )
        {
          case 40413:
            v33 = L"/F";
            goto LABEL_33;
          case 40414:
            SendDlgItemMessageW(*(HWND *)(this + 4), 1095, 0xC2u, 1u, (LPARAM)L"/B");
            break;
          case 40415:
            SendDlgItemMessageW(*(HWND *)(this + 4), 1095, 0xC2u, 1u, (LPARAM)L"/E");
            break;
          case 40416:
            v33 = L"/N";
LABEL_33:
            SendDlgItemMessageW(*(HWND *)(this + 4), 1095, 0xC2u, 1u, (LPARAM)v33);
            break;
          default:
            return 0;
        }
        break;
    }
  }
  return 0;
}
// 49A290: conditional instruction was optimized away because edx.4!=0
// 49A390: conditional instruction was optimized away because edx.4!=0
// 49A2EE: variable 'v11' is possibly undefined
// 49A338: variable 'v13' is possibly undefined
// 4CADD4: using guessed type wchar_t asc_4CADD4[3];
// 4CADDC: using guessed type wchar_t aB_7[3];
// 4CADE4: using guessed type wchar_t aE_0[3];
// 4CADEC: using guessed type wchar_t aN_0[3];

//----- (0049A5C0) --------------------------------------------------------
int __usercall sub_49A5C0@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
    case 15:
      result = -1;
      break;
    case 1:
      result = 0;
      break;
    case 2:
      result = 1;
      break;
    case 3:
      result = 8;
      break;
    case 4:
      result = 14;
      break;
    case 5:
      result = 11;
      break;
    case 6:
      result = 10;
      break;
    case 7:
      result = 9;
      break;
    case 8:
      result = 3;
      break;
    case 9:
      result = 2;
      break;
    case 10:
      result = 4;
      break;
    case 11:
      result = 5;
      break;
    case 12:
      result = 7;
      break;
    case 13:
      result = 17;
      break;
    case 14:
      result = 6;
      break;
    case 16:
      result = 12;
      break;
    case 17:
      result = 19;
      break;
    case 18:
      result = 15;
      break;
    case 19:
      result = 18;
      break;
    case 20:
      result = 20;
      break;
    case 21:
      result = 31;
      break;
  }
  return result;
}

//----- (0049A6A0) --------------------------------------------------------
int __usercall sub_49A6A0@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
      result = 8187;
      break;
    case 1:
      result = 8050;
      break;
    case 2:
      result = 8051;
      break;
    case 3:
      result = 8052;
      break;
    case 4:
      result = 8096;
      break;
    case 5:
      result = 8097;
      break;
    case 6:
      result = 8098;
      break;
    case 7:
      result = 8166;
      break;
    case 8:
      result = 8167;
      break;
    case 9:
      result = 8168;
      break;
    case 10:
      result = 8169;
      break;
    case 11:
      result = 8170;
      break;
    case 12:
      result = 8171;
      break;
    case 13:
      result = 8172;
      break;
    case 14:
      result = 8173;
      break;
    case 15:
      result = 0;
      break;
    case 16:
      result = 8174;
      break;
    case 17:
      result = 8183;
      break;
    case 18:
      result = 8184;
      break;
    case 19:
      result = 8185;
      break;
    case 20:
      result = 8186;
      break;
    case 21:
      result = 8188;
      break;
  }
  return result;
}

//----- (0049A780) --------------------------------------------------------
LRESULT __usercall sub_49A780@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  WCHAR Buffer[64]; // [esp+8h] [ebp-84h] BYREF

  v1 = sub_49A6A0(1);
  LoadStringW(hInstance, v1, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v2 = sub_49A6A0(2);
  LoadStringW(hInstance, v2, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v3 = sub_49A6A0(3);
  LoadStringW(hInstance, v3, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v4 = sub_49A6A0(4);
  LoadStringW(hInstance, v4, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v5 = sub_49A6A0(5);
  LoadStringW(hInstance, v5, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v6 = sub_49A6A0(6);
  LoadStringW(hInstance, v6, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v7 = sub_49A6A0(7);
  LoadStringW(hInstance, v7, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v8 = sub_49A6A0(8);
  LoadStringW(hInstance, v8, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v9 = sub_49A6A0(9);
  LoadStringW(hInstance, v9, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v10 = sub_49A6A0(10);
  LoadStringW(hInstance, v10, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v11 = sub_49A6A0(11);
  LoadStringW(hInstance, v11, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v12 = sub_49A6A0(12);
  LoadStringW(hInstance, v12, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v13 = sub_49A6A0(13);
  LoadStringW(hInstance, v13, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v14 = sub_49A6A0(14);
  LoadStringW(hInstance, v14, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  LoadStringW(hInstance, 0, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v15 = sub_49A6A0(16);
  LoadStringW(hInstance, v15, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v16 = sub_49A6A0(17);
  LoadStringW(hInstance, v16, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v17 = sub_49A6A0(18);
  LoadStringW(hInstance, v17, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v18 = sub_49A6A0(19);
  LoadStringW(hInstance, v18, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v19 = sub_49A6A0(20);
  LoadStringW(hInstance, v19, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
  v20 = sub_49A6A0(21);
  LoadStringW(hInstance, v20, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  return SendMessageW(*(HWND *)(a1 + 88), 0x44Du, 0, (LPARAM)Buffer);
}

//----- (0049AD80) --------------------------------------------------------
char **__usercall sub_49AD80@<eax>(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  int v4; // edi
  char **v5; // eax
  int v6; // ecx
  int v7; // edi
  char **v8; // eax
  int v9; // ecx
  int v10; // edi
  char **v11; // eax
  int v12; // ecx
  int v13; // edi
  char **v14; // eax
  int v15; // ecx
  int v16; // edi
  char **v17; // eax
  int v18; // ecx
  int v19; // edi
  char **v20; // eax
  int v21; // ecx
  int v22; // edi
  char **v23; // eax
  int v24; // ecx
  int v25; // edi
  char **v26; // eax
  int v27; // ecx
  int v28; // edi
  char **v29; // eax
  int v30; // ecx
  int v31; // edi
  char **v32; // eax
  int v33; // ecx
  int v34; // edi
  char **v35; // eax
  int v36; // ecx
  int v37; // edi
  char **v38; // eax
  int v39; // ecx
  int v40; // edi
  char **v41; // eax
  int v42; // ecx
  int v43; // edi
  char **v44; // eax
  int v45; // ecx
  int v46; // edi
  char **v47; // eax
  int v48; // ecx
  int v49; // edi
  char **v50; // eax
  int v51; // ecx
  int v52; // edi
  char **v53; // eax
  int v54; // ecx
  int v55; // edi
  char **v56; // eax
  int v57; // ecx
  int v58; // edi
  char **v59; // eax
  int v60; // ecx
  int v61; // edi
  char **v62; // eax
  int v63; // ecx
  int v64; // edi
  char **v65; // eax
  int v66; // ecx
  int v67; // edi
  char **v68; // eax
  int v69; // ecx
  int v70; // edi
  char **v71; // eax
  int v72; // ecx
  int v73; // edi
  char **result; // eax
  int v75; // ecx
  int v76; // [esp-Ch] [ebp-14h]
  int v77; // [esp-Ch] [ebp-14h]
  int v78; // [esp-Ch] [ebp-14h]
  int v79; // [esp-Ch] [ebp-14h]
  int v80; // [esp-Ch] [ebp-14h]
  int v81; // [esp-Ch] [ebp-14h]
  int v82; // [esp-Ch] [ebp-14h]
  int v83; // [esp-Ch] [ebp-14h]
  int v84; // [esp-Ch] [ebp-14h]
  int v85; // [esp-Ch] [ebp-14h]
  int v86; // [esp-Ch] [ebp-14h]
  int v87; // [esp-Ch] [ebp-14h]
  int v88; // [esp-Ch] [ebp-14h]
  int v89; // [esp-Ch] [ebp-14h]
  int v90; // [esp-Ch] [ebp-14h]
  int v91; // [esp-Ch] [ebp-14h]
  int v92; // [esp-Ch] [ebp-14h]
  int v93; // [esp-Ch] [ebp-14h]
  int v94; // [esp-Ch] [ebp-14h]
  int v95; // [esp-8h] [ebp-10h]
  int v96; // [esp-8h] [ebp-10h]
  int v97; // [esp-8h] [ebp-10h]
  int v98; // [esp-8h] [ebp-10h]
  int v99; // [esp-8h] [ebp-10h]
  int v100; // [esp+4h] [ebp-4h] BYREF

  v1 = *(_DWORD ***)(a1 + 60388);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 60388) + 4) = *(_DWORD *)(a1 + 60388);
  *(_DWORD *)(a1 + 60392) = 0;
  if ( v2 != *(_DWORD **)(a1 + 60388) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 60388) );
  }
  v4 = *(_DWORD *)(a1 + 60388);
  v95 = *(_DWORD *)(v4 + 4);
  v100 = 45002;
  v5 = sub_40A550((char *)v4, v95, (int)&v100);
  v6 = *(_DWORD *)(a1 + 60392);
  if ( v6 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v6 + 1;
  *(_DWORD *)(v4 + 4) = v5;
  *(_DWORD *)v5[1] = v5;
  v7 = *(_DWORD *)(a1 + 60388);
  v96 = *(_DWORD *)(v7 + 4);
  v100 = 45003;
  v8 = sub_40A550((char *)v7, v96, (int)&v100);
  v9 = *(_DWORD *)(a1 + 60392);
  if ( v9 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v9 + 1;
  *(_DWORD *)(v7 + 4) = v8;
  *(_DWORD *)v8[1] = v8;
  v10 = *(_DWORD *)(a1 + 60388);
  v97 = *(_DWORD *)(v10 + 4);
  v100 = 45004;
  v11 = sub_40A550((char *)v10, v97, (int)&v100);
  v12 = *(_DWORD *)(a1 + 60392);
  if ( v12 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v12 + 1;
  *(_DWORD *)(v10 + 4) = v11;
  *(_DWORD *)v11[1] = v11;
  v13 = *(_DWORD *)(a1 + 60388);
  v76 = *(_DWORD *)(v13 + 4);
  v100 = 45001;
  v14 = sub_40A550((char *)v13, v76, (int)&v100);
  v15 = *(_DWORD *)(a1 + 60392);
  if ( v15 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v15 + 1;
  *(_DWORD *)(v13 + 4) = v14;
  *(_DWORD *)v14[1] = v14;
  v16 = *(_DWORD *)(a1 + 60388);
  v77 = *(_DWORD *)(v16 + 4);
  v100 = 45005;
  v17 = sub_40A550((char *)v16, v77, (int)&v100);
  v18 = *(_DWORD *)(a1 + 60392);
  if ( v18 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v18 + 1;
  *(_DWORD *)(v16 + 4) = v17;
  *(_DWORD *)v17[1] = v17;
  v19 = *(_DWORD *)(a1 + 60388);
  v78 = *(_DWORD *)(v19 + 4);
  v100 = 45001;
  v20 = sub_40A550((char *)v19, v78, (int)&v100);
  v21 = *(_DWORD *)(a1 + 60392);
  if ( v21 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v21 + 1;
  *(_DWORD *)(v19 + 4) = v20;
  *(_DWORD *)v20[1] = v20;
  v22 = *(_DWORD *)(a1 + 60388);
  v79 = *(_DWORD *)(v22 + 4);
  v100 = 45010;
  v23 = sub_40A550((char *)v22, v79, (int)&v100);
  v24 = *(_DWORD *)(a1 + 60392);
  if ( v24 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v24 + 1;
  *(_DWORD *)(v22 + 4) = v23;
  *(_DWORD *)v23[1] = v23;
  v25 = *(_DWORD *)(a1 + 60388);
  v80 = *(_DWORD *)(v25 + 4);
  v100 = 45009;
  v26 = sub_40A550((char *)v25, v80, (int)&v100);
  v27 = *(_DWORD *)(a1 + 60392);
  if ( v27 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v27 + 1;
  *(_DWORD *)(v25 + 4) = v26;
  *(_DWORD *)v26[1] = v26;
  v28 = *(_DWORD *)(a1 + 60388);
  v81 = *(_DWORD *)(v28 + 4);
  v100 = 45011;
  v29 = sub_40A550((char *)v28, v81, (int)&v100);
  v30 = *(_DWORD *)(a1 + 60392);
  if ( v30 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v30 + 1;
  *(_DWORD *)(v28 + 4) = v29;
  *(_DWORD *)v29[1] = v29;
  v31 = *(_DWORD *)(a1 + 60388);
  v82 = *(_DWORD *)(v31 + 4);
  v100 = 45012;
  v32 = sub_40A550((char *)v31, v82, (int)&v100);
  v33 = *(_DWORD *)(a1 + 60392);
  if ( v33 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v33 + 1;
  *(_DWORD *)(v31 + 4) = v32;
  *(_DWORD *)v32[1] = v32;
  v34 = *(_DWORD *)(a1 + 60388);
  v83 = *(_DWORD *)(v34 + 4);
  v100 = 45022;
  v35 = sub_40A550((char *)v34, v83, (int)&v100);
  v36 = *(_DWORD *)(a1 + 60392);
  if ( v36 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v36 + 1;
  *(_DWORD *)(v34 + 4) = v35;
  *(_DWORD *)v35[1] = v35;
  v37 = *(_DWORD *)(a1 + 60388);
  v84 = *(_DWORD *)(v37 + 4);
  v100 = 45015;
  v38 = sub_40A550((char *)v37, v84, (int)&v100);
  v39 = *(_DWORD *)(a1 + 60392);
  if ( v39 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v39 + 1;
  *(_DWORD *)(v37 + 4) = v38;
  *(_DWORD *)v38[1] = v38;
  v40 = *(_DWORD *)(a1 + 60388);
  v85 = *(_DWORD *)(v40 + 4);
  v100 = 45014;
  v41 = sub_40A550((char *)v40, v85, (int)&v100);
  v42 = *(_DWORD *)(a1 + 60392);
  if ( v42 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v42 + 1;
  *(_DWORD *)(v40 + 4) = v41;
  *(_DWORD *)v41[1] = v41;
  v43 = *(_DWORD *)(a1 + 60388);
  v86 = *(_DWORD *)(v43 + 4);
  v100 = 45001;
  v44 = sub_40A550((char *)v43, v86, (int)&v100);
  v45 = *(_DWORD *)(a1 + 60392);
  if ( v45 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v45 + 1;
  *(_DWORD *)(v43 + 4) = v44;
  *(_DWORD *)v44[1] = v44;
  v46 = *(_DWORD *)(a1 + 60388);
  v87 = *(_DWORD *)(v46 + 4);
  v100 = 45008;
  v47 = sub_40A550((char *)v46, v87, (int)&v100);
  v48 = *(_DWORD *)(a1 + 60392);
  if ( v48 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v48 + 1;
  *(_DWORD *)(v46 + 4) = v47;
  *(_DWORD *)v47[1] = v47;
  v49 = *(_DWORD *)(a1 + 60388);
  v88 = *(_DWORD *)(v49 + 4);
  v100 = 45006;
  v50 = sub_40A550((char *)v49, v88, (int)&v100);
  v51 = *(_DWORD *)(a1 + 60392);
  if ( v51 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v51 + 1;
  *(_DWORD *)(v49 + 4) = v50;
  *(_DWORD *)v50[1] = v50;
  v52 = *(_DWORD *)(a1 + 60388);
  v89 = *(_DWORD *)(v52 + 4);
  v100 = 45007;
  v53 = sub_40A550((char *)v52, v89, (int)&v100);
  v54 = *(_DWORD *)(a1 + 60392);
  if ( v54 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v54 + 1;
  *(_DWORD *)(v52 + 4) = v53;
  *(_DWORD *)v53[1] = v53;
  v55 = *(_DWORD *)(a1 + 60388);
  v90 = *(_DWORD *)(v55 + 4);
  v100 = 45001;
  v56 = sub_40A550((char *)v55, v90, (int)&v100);
  v57 = *(_DWORD *)(a1 + 60392);
  if ( v57 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v57 + 1;
  *(_DWORD *)(v55 + 4) = v56;
  *(_DWORD *)v56[1] = v56;
  v58 = *(_DWORD *)(a1 + 60388);
  v91 = *(_DWORD *)(v58 + 4);
  v100 = 45013;
  v59 = sub_40A550((char *)v58, v91, (int)&v100);
  v60 = *(_DWORD *)(a1 + 60392);
  if ( v60 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v60 + 1;
  *(_DWORD *)(v58 + 4) = v59;
  *(_DWORD *)v59[1] = v59;
  v61 = *(_DWORD *)(a1 + 60388);
  v92 = *(_DWORD *)(v61 + 4);
  v100 = 45020;
  v62 = sub_40A550((char *)v61, v92, (int)&v100);
  v63 = *(_DWORD *)(a1 + 60392);
  if ( v63 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v63 + 1;
  *(_DWORD *)(v61 + 4) = v62;
  *(_DWORD *)v62[1] = v62;
  v64 = *(_DWORD *)(a1 + 60388);
  v93 = *(_DWORD *)(v64 + 4);
  v100 = 45017;
  v65 = sub_40A550((char *)v64, v93, (int)&v100);
  v66 = *(_DWORD *)(a1 + 60392);
  if ( v66 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v66 + 1;
  *(_DWORD *)(v64 + 4) = v65;
  *(_DWORD *)v65[1] = v65;
  v67 = *(_DWORD *)(a1 + 60388);
  v94 = *(_DWORD *)(v67 + 4);
  v100 = 45001;
  v68 = sub_40A550((char *)v67, v94, (int)&v100);
  v69 = *(_DWORD *)(a1 + 60392);
  if ( v69 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v69 + 1;
  *(_DWORD *)(v67 + 4) = v68;
  *(_DWORD *)v68[1] = v68;
  v70 = *(_DWORD *)(a1 + 60388);
  v98 = *(_DWORD *)(v70 + 4);
  v100 = 45018;
  v71 = sub_40A550((char *)v70, v98, (int)&v100);
  v72 = *(_DWORD *)(a1 + 60392);
  if ( v72 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v72 + 1;
  *(_DWORD *)(v70 + 4) = v71;
  *(_DWORD *)v71[1] = v71;
  v73 = *(_DWORD *)(a1 + 60388);
  v99 = *(_DWORD *)(v73 + 4);
  v100 = 45021;
  result = sub_40A550((char *)v73, v99, (int)&v100);
  v75 = *(_DWORD *)(a1 + 60392);
  if ( v75 == 1073741822 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 60392) = v75 + 1;
  *(_DWORD *)(v73 + 4) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0049B450) --------------------------------------------------------
LRESULT __usercall sub_49B450@<eax>(int a1@<esi>)
{
  LPARAM v1; // eax
  LPARAM v2; // eax
  LPARAM v3; // eax
  BOOL v4; // eax
  BOOL v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  HWND Focus; // eax
  HRESULT v10; // eax
  BOOL v11; // eax
  HWND v12; // eax
  HRESULT v13; // eax
  BOOL v14; // eax
  HWND v15; // eax
  HRESULT v16; // eax
  BOOL v17; // eax
  int v19; // [esp+8h] [ebp-8h]
  int v20; // [esp+Ch] [ebp-4h] BYREF

  v19 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 144))(*(_DWORD *)(a1 + 1320));
  v1 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 92))(*(_DWORD *)(a1 + 1320));
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFCCu, v1);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 68))(*(_DWORD *)(a1 + 1320));
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFCAu, v2);
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 72))(*(_DWORD *)(a1 + 1320));
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFCBu, v3);
  v4 = sub_494670((_DWORD *)a1) && GetFocus() != *(HWND *)(a1 + 76);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFCEu, v4);
  v5 = sub_494670((_DWORD *)a1) && GetFocus() != *(HWND *)(a1 + 76);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFCFu, v5);
  v6 = sub_494670((_DWORD *)a1);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD1u, v6);
  v7 = sub_494670((_DWORD *)a1);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD2u, v7);
  v8 = sub_494FD0(a1);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD3u, v8);
  v20 = 64;
  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    v10 = sub_494780(a1, (int)&v20);
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 76) )
      goto LABEL_15;
    v10 = sub_4946F0(a1, (int)&v20);
  }
  if ( v10 >= 0 )
  {
    v11 = (v20 & 0x40) == 64;
    goto LABEL_16;
  }
LABEL_15:
  v11 = 0;
LABEL_16:
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD7u, v11);
  v20 = 32;
  v12 = GetFocus();
  if ( v12 == *(HWND *)(a1 + 3432) )
  {
    v13 = sub_494780(a1, (int)&v20);
  }
  else
  {
    if ( v12 != *(HWND *)(a1 + 76) )
      goto LABEL_22;
    v13 = sub_4946F0(a1, (int)&v20);
  }
  if ( v13 >= 0 )
  {
    v14 = (v20 & 0x20) == 32;
    goto LABEL_23;
  }
LABEL_22:
  v14 = 0;
LABEL_23:
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD4u, v14);
  v20 = 32;
  v15 = GetFocus();
  if ( v15 == *(HWND *)(a1 + 3432) )
  {
    v16 = sub_494780(a1, (int)&v20);
  }
  else
  {
    if ( v15 != *(HWND *)(a1 + 76) )
    {
LABEL_29:
      v17 = 0;
      goto LABEL_30;
    }
    v16 = sub_4946F0(a1, (int)&v20);
  }
  if ( v16 < 0 )
    goto LABEL_29;
  v17 = (v20 & 0x20) == 32;
LABEL_30:
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFDEu, v17);
  SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFDCu, v19 == 0);
  return SendMessageW(*(HWND *)(a1 + 88), 0x401u, 0xAFD0u, v19 == 0);
}

//----- (0049B6A0) --------------------------------------------------------
int __thiscall sub_49B6A0(_DWORD **this, int a2, int a3)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD *))(*this[326] + 292))(this[326]);
  if ( !result )
    return (*(int (__thiscall **)(_DWORD *, int))(*this[326] + 120))(this[326], a2);
  return result;
}

//----- (0049B6D0) --------------------------------------------------------
void __usercall sub_49B6D0(int a1@<eax>)
{
  LRESULT v2; // eax
  int v3; // ebx
  WPARAM v4; // esi
  LPCITEMIDLIST *v5; // ebx
  ITEMIDLIST *v6; // esi
  int i; // esi
  int v8; // [esp+Ch] [ebp-8h]
  LPCITEMIDLIST *Block; // [esp+10h] [ebp-4h]

  v2 = SendMessageW(*(HWND *)(a1 + 3432), 0x1032u, 0, 0);
  v3 = v2;
  v8 = v2;
  if ( v2 )
  {
    Block = (LPCITEMIDLIST *)malloc(4 * v2);
    v4 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, 0xFFFFFFFF, 2);
    if ( v4 != -1 )
    {
      v5 = Block;
      do
      {
        *v5++ = (LPCITEMIDLIST)(*(int (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a1 + 1320) + 140))(
                                 *(_DWORD *)(a1 + 1320),
                                 v4);
        v4 = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, v4, 2);
      }
      while ( v4 != -1 );
      v3 = v8;
    }
  }
  else
  {
    Block = 0;
  }
  v6 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
  sub_47DC80(Block, L"properties", a1, v6, v3, 0);
  CoTaskMemFree(v6);
  for ( i = 0; i < v3; ++i )
    CoTaskMemFree((LPVOID)Block[i]);
  free(Block);
}
// 4C6D30: using guessed type wchar_t aProperties_0[11];

//----- (0049B7C0) --------------------------------------------------------
void __thiscall sub_49B7C0(_DWORD *this)
{
  DWORD MessagePos; // eax
  SHORT KeyState; // bx
  SHORT v4; // ax
  int v5; // ecx
  ITEMIDLIST *v6; // edi
  HWND v7; // [esp-10h] [ebp-40h]
  HWND v8; // [esp-8h] [ebp-38h]
  struct tagPOINT Point; // [esp+Ch] [ebp-24h] BYREF
  LPVOID pv; // [esp+14h] [ebp-1Ch] BYREF
  LPARAM lParam[3]; // [esp+18h] [ebp-18h] BYREF
  int v12; // [esp+24h] [ebp-Ch]

  MessagePos = GetMessagePos();
  Point.x = (__int16)MessagePos;
  v8 = (HWND)this[858];
  Point.y = SHIWORD(MessagePos);
  ScreenToClient(v8, &Point);
  lParam[0] = Point.x;
  v7 = (HWND)this[858];
  lParam[1] = Point.y;
  SendMessageW(v7, 0x1012u, 0, (LPARAM)lParam);
  if ( lParam[2] != 1 && v12 != -1 )
  {
    KeyState = GetKeyState(18);
    pv = (LPVOID)(unsigned __int16)GetKeyState(17);
    v4 = GetKeyState(16);
    if ( (KeyState & 0x8000) != 0 )
    {
      v5 = this[330];
      pv = 0;
      v6 = (ITEMIDLIST *)(*(int (__thiscall **)(int))(*(_DWORD *)v5 + 56))(v5);
      pv = (LPVOID)(*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)this[330] + 140))(this[330], v12);
      sub_47DC80((LPCITEMIDLIST *)&pv, L"properties", (int)this, v6, 1, 0);
      CoTaskMemFree(pv);
      CoTaskMemFree(v6);
    }
    else if ( ((unsigned __int16)pv & 0x8000) != 0 )
    {
      sub_48F7A0((int)this, v12, 1, 0);
    }
    else
    {
      sub_48F7A0((int)this, v12, 0, (v4 & 0x8000) != 0);
    }
  }
}
// 4C6D30: using guessed type wchar_t aProperties_0[11];

//----- (0049B900) --------------------------------------------------------
int __usercall sub_49B900@<eax>(int a1@<ebx>, _DWORD *a2@<esi>)
{
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(17, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 3492), psz2) )
  {
    sub_4664A0(3, psz2);
    if ( StrCmpW((PCWSTR)(a1 + 3492), psz2) )
    {
      sub_4664A0(10, psz2);
      if ( StrCmpW((PCWSTR)(a1 + 3492), psz2) )
      {
        if ( sub_4945B0(49, a1) )
        {
          *a2 = &unk_4E76E0;
          return 4;
        }
        else if ( sub_4945B0(18, a1) )
        {
          *a2 = &unk_4E76F0;
          return 2;
        }
        else if ( sub_4945B0(4, a1) )
        {
          *a2 = &unk_4E715C;
          return 5;
        }
        else
        {
          *a2 = &unk_4E76A8;
          return 6;
        }
      }
      else
      {
        *a2 = &unk_4E76F8;
        return 6;
      }
    }
    else
    {
      *a2 = &unk_4E76C0;
      return 2;
    }
  }
  else
  {
    *a2 = &unk_4E76C8;
    return 6;
  }
}

//----- (0049BA70) --------------------------------------------------------
int __userpurge sub_49BA70@<eax>(int a1@<eax>, int a2)
{
  return (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 1320) + 280))(
           *(_DWORD *)(a1 + 1320),
           *(_DWORD *)(a2 + 16));
}

//----- (0049BA90) --------------------------------------------------------
int __userpurge sub_49BA90@<eax>(int a1@<eax>, int *a2)
{
  signed int v2; // edi
  int v4; // ebx
  LRESULT v5; // eax
  int v6; // edx
  HWND v8; // [esp-10h] [ebp-3Ch]
  int lParam[6]; // [esp+Ch] [ebp-20h] BYREF
  int v10; // [esp+24h] [ebp-8h]
  int v11; // [esp+28h] [ebp-4h]

  v2 = 0;
  v4 = 0;
  v5 = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  v6 = *a2;
  v11 = v5;
  if ( v6 != *(_DWORD *)(a1 + 92) )
  {
    do
    {
      if ( v2 >= v11 )
        break;
      v8 = *(HWND *)(a1 + 68);
      lParam[0] = 8;
      SendMessageW(v8, 0x133Cu, v2++, (LPARAM)lParam);
      v4 = v10;
    }
    while ( *a2 != *(_DWORD *)(a1 + 4 * v10 + 92) );
  }
  return (*(int (__thiscall **)(_DWORD, int *))(**(_DWORD **)(a1 + 4 * v4 + 916) + 136))(
           *(_DWORD *)(a1 + 4 * v4 + 916),
           a2);
}
// 49BA90: using guessed type LPARAM lParam[6];

//----- (0049BB50) --------------------------------------------------------
LRESULT __userpurge sub_49BB50@<eax>(int a1@<esi>, unsigned int a2)
{
  LRESULT result; // eax
  HWND v3; // edx
  HWND v4; // [esp-10h] [ebp-60h]
  WPARAM v5; // [esp-8h] [ebp-58h]
  LPARAM v6[13]; // [esp+4h] [ebp-4Ch] BYREF
  LPARAM lParam[3]; // [esp+38h] [ebp-18h] BYREF
  WPARAM wParam; // [esp+44h] [ebp-Ch]

  lParam[1] = HIWORD(a2);
  v4 = *(HWND *)(a1 + 3432);
  lParam[0] = (unsigned __int16)a2;
  result = SendMessageW(v4, 0x1012u, 0, (LPARAM)lParam);
  if ( lParam[2] == 1 || (result = wParam, wParam == -1) )
  {
    *(_DWORD *)(a1 + 60580) = -1;
  }
  else
  {
    v3 = *(HWND *)(a1 + 3432);
    v6[4] = 1;
    v6[3] = 1;
    v5 = wParam;
    *(_DWORD *)(a1 + 60580) = wParam;
    return SendMessageW(v3, 0x102Bu, v5, (LPARAM)v6);
  }
  return result;
}

//----- (0049BBF0) --------------------------------------------------------
LRESULT __usercall sub_49BBF0@<eax>(char a1@<bl>, unsigned int a2@<edi>, int a3@<esi>)
{
  HWND v4; // [esp-10h] [ebp-28h]
  LPARAM lParam[5]; // [esp+0h] [ebp-18h] BYREF

  lParam[0] = (unsigned __int16)a2;
  v4 = *(HWND *)(a3 + 3432);
  lParam[1] = HIWORD(a2);
  SendMessageW(v4, 0x1012u, 0, (LPARAM)lParam);
  if ( lParam[2] == 1 )
  {
    *(_DWORD *)(a3 + 60568) = 1;
    if ( (a1 & 8) == 0 && *(int *)(a3 + 60572) > 1 )
      *(_DWORD *)(a3 + 60560) = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 60568) = 0;
  }
  return CallWindowProcW(lpPrevWndFunc, *(HWND *)(a3 + 3432), 0x201u, a1, a2);
}

//----- (0049BC80) --------------------------------------------------------
HWND __userpurge sub_49BC80@<eax>(int a1@<ebx>, HWND hWndParent)
{
  HMODULE ModuleHandleW; // eax
  HWND Window; // esi
  LPARAM v4; // eax
  void *ppvObj; // [esp+8h] [ebp-4h] BYREF

  ppvObj = 0;
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"SysListView32", &word_4C3054, 0x56010348u, 0, 0, 0, 0, hWndParent, 0, ModuleHandleW, 0);
  SendMessageW(Window, 0x1036u, 0, 66560);
  SHGetImageList(1, &stru_4BD96C, &ppvObj);
  SendMessageW(Window, 0x1003u, 1u, (LPARAM)ppvObj);
  (*(void (__stdcall **)(void *))(*(_DWORD *)ppvObj + 8))(ppvObj);
  v4 = SendMessageW(Window, 0x1037u, 0, 0);
  if ( *(_DWORD *)(a1 + 59368) )
    v4 |= 0x20u;
  if ( *(_DWORD *)(a1 + 59416) )
    v4 |= 4u;
  SendMessageW(Window, 0x1036u, 0, v4);
  SetWindowTheme(Window, L"Explorer", 0);
  return Window;
}

//----- (0049BD50) --------------------------------------------------------
void __thiscall sub_49BD50(int this, int *a2)
{
  UINT v2; // edi
  _DWORD *v4; // eax
  HMENU SubMenu; // eax
  int v6; // ecx
  void (__thiscall *v7)(int, void **); // edx
  int v8; // eax
  int v9; // ecx
  _DWORD **v10; // edx
  _DWORD *v11; // esi
  UINT v12; // eax
  HMENU v13; // esi
  int MenuItemCount; // eax
  HMENU v15; // esi
  void **v16; // eax
  void *v17; // ecx
  void **v18; // esi
  MENUITEMINFOW mi; // [esp+10h] [ebp-27Ch] BYREF
  int pExceptionObject[3]; // [esp+40h] [ebp-24Ch] BYREF
  char *v21; // [esp+4Ch] [ebp-240h] BYREF
  int v22; // [esp+50h] [ebp-23Ch]
  HMENU hMenu; // [esp+54h] [ebp-238h]
  int v24; // [esp+58h] [ebp-234h]
  int *v25; // [esp+5Ch] [ebp-230h]
  int v26; // [esp+60h] [ebp-22Ch]
  int v27; // [esp+64h] [ebp-228h] BYREF
  HMENU hmenu; // [esp+68h] [ebp-224h]
  void *v29; // [esp+6Ch] [ebp-220h] BYREF
  int v30; // [esp+70h] [ebp-21Ch]
  WCHAR Buffer[256]; // [esp+78h] [ebp-214h] BYREF
  int v32; // [esp+288h] [ebp-4h]

  v2 = 0;
  v25 = a2;
  v30 = 0;
  v4 = operator new(0x14u);
  if ( !v4 )
  {
    v21 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v29 = v4;
  *v4 = v4;
  *((_DWORD *)v29 + 1) = v29;
  v32 = 0;
  v27 = 0;
  hMenu = LoadMenuW(hInstance, (LPCWSTR)0xDA);
  SubMenu = GetSubMenu(hMenu, 0);
  v6 = *(_DWORD *)(this + 1320);
  v7 = *(void (__thiscall **)(int, void **))(*(_DWORD *)v6 + 312);
  hmenu = SubMenu;
  v7(v6, &v29);
  v8 = sub_49B900(this, &v27);
  v9 = 0;
  v24 = v8;
  v26 = 0;
  if ( v8 > 0 )
  {
    v10 = (_DWORD **)v29;
    do
    {
      v11 = *v10;
      if ( *v10 != v10 )
      {
        v22 = *(_DWORD *)(v27 + 4 * v9);
        while ( v11[2] != v22 )
        {
          v11 = (_DWORD *)*v11;
          v10 = (_DWORD **)v29;
          if ( v11 == v29 )
            goto LABEL_10;
        }
        v12 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this + 28) + 24))(this + 28, v11[2]);
        LoadStringW(hInstance, v12, Buffer, 256);
        mi.fState = v11[3] != 0 ? 8 : 0;
        mi.dwTypeData = Buffer;
        mi.cbSize = 48;
        mi.fMask = 67;
        mi.wID = v2 + 12000;
        InsertMenuItemW(hmenu, v2, 1, &mi);
        v10 = (_DWORD **)v29;
        v9 = v26;
        v8 = v24;
        ++v2;
      }
LABEL_10:
      v26 = ++v9;
    }
    while ( v9 < v8 );
  }
  v13 = hmenu;
  MenuItemCount = GetMenuItemCount(hmenu);
  sub_48FCC0(v13, MenuItemCount);
  TrackPopupMenu(v13, 0x42u, *v25, v25[1], 0, *(HWND *)(this + 52), 0);
  v15 = hMenu;
  mi.cbSize = 48;
  mi.fMask = 32;
  GetMenuItemInfoW(hMenu, 0, 1, &mi);
  free((void *)mi.dwItemData);
  DestroyMenu(v15);
  v16 = *(void ***)v29;
  *(_DWORD *)v29 = v29;
  *((_DWORD *)v29 + 1) = v29;
  v17 = v29;
  v30 = 0;
  if ( v16 != v29 )
  {
    do
    {
      v18 = (void **)*v16;
      operator delete(v16);
      v17 = v29;
      v16 = v18;
    }
    while ( v18 != v29 );
  }
  operator delete(v17);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0049C010) --------------------------------------------------------
void __fastcall sub_49C010(_DWORD *a1, int a2, wchar_t *a3)
{
  int v5; // eax
  int v6; // ecx
  void *v7; // eax
  int v8; // ecx
  ITEMIDLIST *pv; // [esp+10h] [ebp-414h]
  LPVOID v10; // [esp+14h] [ebp-410h] BYREF
  WCHAR Buffer[256]; // [esp+18h] [ebp-40Ch] BYREF
  __int16 v12[258]; // [esp+218h] [ebp-20Ch] BYREF

  if ( !a1[14868] || (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a1[330] + 144))(a1[330]) )
  {
    v6 = a1[330];
    v10 = 0;
    pv = (ITEMIDLIST *)(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 56))(v6);
    v7 = (void *)(*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)a1[330] + 140))(a1[330], a2);
    v8 = a1[13];
    v10 = v7;
    if ( sub_4676F0(pv, (int)a3, (int)pv, v8, (int)&v10, a3) < 0 )
      sub_4A96F0(512, (int)&unk_4CB0CC, a3);
    CoTaskMemFree(pv);
    CoTaskMemFree(v10);
  }
  else
  {
    v5 = (*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)a1[330] + 132))(a1[330], a2);
    sub_46AB90(v12, 256, (FILETIME *)(v5 + 20), a1[14875]);
    LoadStringW(hInstance, 0x2015u, Buffer, 256);
    sub_401000(0x200u, a3, L"%s: %s", Buffer, v12);
  }
}
// 4CB0D0: using guessed type wchar_t aSS_13[7];
// 49C010: using guessed type _WORD var_20C[258];

//----- (0049C160) --------------------------------------------------------
LRESULT __userpurge sub_49C160@<eax>(int a1@<esi>, unsigned int a2)
{
  LRESULT result; // eax
  ITEMIDLIST *v3; // ebx
  HWND v4; // [esp-10h] [ebp-35Ch]
  STRRET pstr; // [esp+8h] [ebp-344h] BYREF
  int v6; // [esp+114h] [ebp-238h] BYREF
  IShellFolder *ppshf; // [esp+118h] [ebp-234h] BYREF
  LPCITEMIDLIST pidl; // [esp+11Ch] [ebp-230h] BYREF
  IShellFolder *v9; // [esp+120h] [ebp-22Ch] BYREF
  LPARAM lParam[3]; // [esp+124h] [ebp-228h] BYREF
  int v11; // [esp+130h] [ebp-21Ch]
  WCHAR pszBuf[262]; // [esp+138h] [ebp-214h] BYREF

  lParam[1] = HIWORD(a2);
  v4 = *(HWND *)(a1 + 3432);
  lParam[0] = (unsigned __int16)a2;
  result = SendMessageW(v4, 0x1012u, 0, (LPARAM)lParam);
  if ( lParam[2] != 1 && v11 == *(_DWORD *)(a1 + 60580) )
  {
    ppshf = 0;
    v9 = 0;
    pidl = 0;
    v6 = 541065216;
    result = SHGetDesktopFolder(&ppshf);
    if ( result >= 0 )
    {
      v3 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 56))(*(_DWORD *)(a1 + 1320));
      if ( ppshf->lpVtbl->BindToObject(ppshf, v3, 0, &stru_4BD7FC, (void **)&v9) >= 0 || SHGetDesktopFolder(&v9) >= 0 )
      {
        pidl = (LPCITEMIDLIST)(*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 1320) + 140))(
                                *(_DWORD *)(a1 + 1320),
                                v11);
        if ( v9->lpVtbl->GetAttributesOf(v9, 1, &pidl, (SFGAOF *)&v6) >= 0
          && (v6 & 0x20000000) != 0
          && (v6 & 0x400000) == 0 )
        {
          v9->lpVtbl->GetDisplayNameOf(v9, pidl, 0x8000, &pstr);
          StrRetToBufW(&pstr, pidl, pszBuf, 0x104u);
          sub_48FFD0((int)pszBuf, a1, 0, 1, 0);
        }
        CoTaskMemFree((LPVOID)pidl);
        v9->lpVtbl->Release(v9);
      }
      CoTaskMemFree(v3);
      return ppshf->lpVtbl->Release(ppshf);
    }
  }
  return result;
}

//----- (0049C330) --------------------------------------------------------
HMENU __thiscall sub_49C330(_DWORD *this)
{
  HMENU MenuW; // eax
  HMENU SubMenu; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  int v6; // esi
  int v7; // eax
  UINT v8; // eax
  HMENU v9; // eax
  HMENU v10; // edx
  int v11; // ebx
  MENUITEMINFOW mi; // [esp+Ch] [ebp-C4h] BYREF
  _DWORD *v14; // [esp+3Ch] [ebp-94h]
  int v15; // [esp+40h] [ebp-90h] BYREF
  HMENU hmenu; // [esp+44h] [ebp-8Ch]
  WCHAR Buffer[66]; // [esp+48h] [ebp-88h] BYREF

  MenuW = LoadMenuW(hInstance, (LPCWSTR)0x9B);
  SubMenu = GetSubMenu(MenuW, 0);
  v4 = (_DWORD *)this[1410];
  v5 = (_DWORD *)*v4;
  hmenu = SubMenu;
  v14 = v4;
  if ( v5 != v4 )
  {
    do
    {
      v6 = v5[2];
      v7 = sub_48EAA0(v6, (int)this);
      LoadStringW(hInstance, v7, Buffer, 64);
      mi.cbSize = 48;
      mi.fMask = 66;
      switch ( v6 )
      {
        case 1:
          v8 = 60002;
          break;
        case 2:
          v8 = 60003;
          break;
        case 3:
          v8 = 60004;
          break;
        case 4:
          v8 = 60005;
          break;
        case 5:
          v8 = 60001;
          break;
        case 6:
          v8 = 60000;
          break;
        case 7:
          v8 = 60008;
          break;
        case 8:
          v8 = 60007;
          break;
        default:
          v8 = -1;
          break;
      }
      mi.wID = v8;
      mi.dwTypeData = Buffer;
      InsertMenuItemW(hmenu, 0x9DEEu, 0, &mi);
      v5 = (_DWORD *)*v5;
    }
    while ( v5 != v14 );
    SubMenu = hmenu;
  }
  DeleteMenu(SubMenu, 0x9DEEu, 0);
  v9 = (HMENU)this[864];
  mi.cbSize = 48;
  mi.fMask = 4;
  mi.hSubMenu = v9;
  SetMenuItemInfoW(SubMenu, 0x9DBBu, 0, &mi);
  v10 = (HMENU)this[865];
  mi.cbSize = 48;
  mi.fMask = 4;
  mi.hSubMenu = v10;
  SetMenuItemInfoW(SubMenu, 0x9DBAu, 0, &mi);
  v11 = this[this[1405] + 129];
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v11 + 24))(v11, &v15);
  EnableMenuItem(SubMenu, 0x9DBAu, v15 == 3);
  return SubMenu;
}

//----- (0049C530) --------------------------------------------------------
unsigned int __fastcall sub_49C530(_DWORD *a1, int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // ebx
  _WORD *v5; // esi
  unsigned int result; // eax
  int v7; // [esp+Ch] [ebp-40Ch] BYREF
  __int16 v8[514]; // [esp+10h] [ebp-408h] BYREF

  if ( a1[14867] )
  {
    sub_49C010(a1, *(_DWORD *)(a2 + 24), (wchar_t *)v8);
    if ( lstrlenW(*(LPCWSTR *)(a2 + 16)) > 0 )
    {
      v3 = *(_DWORD *)(a2 + 20);
      if ( sub_4AA6C0(v3, *(_WORD **)(a2 + 16), &v7) >= 0 )
        sub_4AA520(v3 - v7, (int)L"\n", (_WORD *)(*(_DWORD *)(a2 + 16) + 2 * v7));
    }
    v4 = *(_DWORD *)(a2 + 20);
    v5 = *(_WORD **)(a2 + 16);
    result = sub_4AA6C0(v4, v5, &v7);
    if ( (result & 0x80000000) == 0 )
      return sub_4AA520(v4 - v7, (int)v8, &v5[v7]);
  }
  else
  {
    result = *(_DWORD *)(a2 + 20);
    if ( result && result <= 0x7FFFFFFF )
      return sub_4A96F0(result, (int)&unk_4CB0C8, *(_WORD **)(a2 + 16));
  }
  return result;
}
// 4CB0C4: using guessed type wchar_t asc_4CB0C4[2];
// 49C530: using guessed type wchar_t var_408[514];

//----- (0049C620) --------------------------------------------------------
void __thiscall sub_49C620(char ***this)
{
  char ***v1; // esi
  HWND v2; // eax
  int *v3; // ebx
  WPARAM v4; // edi
  int *v5; // eax
  int *v6; // esi
  char **v7; // eax
  WPARAM v8; // edx
  char ***v9; // ecx
  char **v10[2]; // [esp-Ch] [ebp-534h] BYREF
  LPARAM v11; // [esp-4h] [ebp-52Ch]
  int pExceptionObject[3]; // [esp+14h] [ebp-514h] BYREF
  char *v13; // [esp+20h] [ebp-508h] BYREF
  int *v14; // [esp+24h] [ebp-504h] BYREF
  int v15; // [esp+28h] [ebp-500h]
  WPARAM wParam; // [esp+30h] [ebp-4F8h]
  char ***v17; // [esp+34h] [ebp-4F4h]
  int v18[130]; // [esp+38h] [ebp-4F0h] BYREF
  char v19[592]; // [esp+240h] [ebp-2E8h] BYREF
  LPARAM dwInitParam[3]; // [esp+490h] [ebp-98h] BYREF
  unsigned __int16 v21; // [esp+49Ch] [ebp-8Ch]
  HWND hWndParent; // [esp+4A0h] [ebp-88h]
  int v23; // [esp+4A8h] [ebp-80h]
  int v24; // [esp+524h] [ebp-4h]

  v11 = 0;
  v1 = this;
  v2 = (HWND)this[858];
  v17 = this;
  if ( SendMessageW(v2, 0x1032u, 0, 0) )
  {
    v15 = 0;
    v3 = (int *)operator new(0x460u);
    if ( !v3 )
    {
      v13 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v13);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v3 = (int)v3;
    v14 = v3;
    v3[1] = (int)v3;
    v24 = 0;
    v4 = SendMessageW((HWND)v1[858], 0x100Cu, 0xFFFFFFFF, 2);
    wParam = v4;
    if ( v4 != -1 )
    {
      while ( 1 )
      {
        (*((void (__thiscall **)(char **, WPARAM, int *))*v1[330] + 12))(v1[330], v4, v18);
        qmemcpy(v19, (const void *)(*((int (__thiscall **)(char **, WPARAM))*v1[330] + 33))(v1[330], v4), sizeof(v19));
        v7 = sub_40AFF0((char *)v3, v3[1], (int)v18);
        if ( v15 == 3862379 )
          std::_Xlength_error("list<T> too long");
        v8 = wParam;
        ++v15;
        v3[1] = (int)v7;
        v9 = (char ***)v7[1];
        v11 = 2;
        *v9 = v7;
        v1 = v17;
        wParam = SendMessageW((HWND)v17[858], 0x100Cu, v8, v11);
        if ( wParam == -1 )
          break;
        v4 = wParam;
      }
    }
    v17 = v10;
    sub_40ADB0(v10, &v14);
    sub_47F4C0(v1[13], (int)dwInitParam, v10[0], (int)v10[1], v11);
    if ( !v23 )
      DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v21, hWndParent, DialogFunc, (LPARAM)dwInitParam);
    sub_47E860((int)dwInitParam);
    v5 = (int *)*v3;
    *v3 = (int)v3;
    v3[1] = (int)v3;
    if ( v5 != v3 )
    {
      do
      {
        v6 = (int *)*v5;
        operator delete(v5);
        v5 = v6;
      }
      while ( v6 != v3 );
    }
    operator delete(v3);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0049C860) --------------------------------------------------------
int __userpurge sub_49C860@<eax>(int a1@<ecx>, HWND a2@<esi>, int a3, int a4, DWORD dwErrCode)
{
  LPARAM v6; // ebx
  int v7; // eax
  int v8; // eax
  HWND Parent; // eax
  HWND v10; // eax
  HWND v11; // eax
  LRESULT v12; // eax
  WPARAM v13; // eax
  HWND v14; // eax
  signed int v16; // eax
  WPARAM v17; // [esp-8h] [ebp-25Ch]
  LPARAM v18[13]; // [esp+8h] [ebp-24Ch] BYREF
  WPARAM wParam; // [esp+3Ch] [ebp-218h]
  __int16 lParam[262]; // [esp+40h] [ebp-214h] BYREF

  if ( a3 == 177 )
  {
    if ( *(_DWORD *)(a1 + 60604) && !a4 && dwErrCode == -1 )
    {
      SendMessageW(a2, 0xDu, 0x104u, (LPARAM)lParam);
      if ( ((*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 1320) + 124))(
              *(_DWORD *)(a1 + 1320),
              *(_DWORD *)(a1 + 60612)) & 0x10) == 0 )
      {
        v16 = lstrlenW((LPCWSTR)lParam) - 1;
        if ( v16 >= 0 )
        {
          while ( lParam[v16] != 46 )
          {
            if ( --v16 < 0 )
              goto LABEL_29;
          }
          a4 = 0;
          dwErrCode = v16;
        }
      }
LABEL_29:
      *(_DWORD *)(a1 + 60604) = 0;
    }
    return sub_401C60((int)a2, a3, a4, dwErrCode);
  }
  if ( a3 != 32823 )
    return sub_401C60((int)a2, a3, a4, dwErrCode);
  if ( a4 != 9 )
  {
    if ( a4 == 113 )
    {
      SendMessageW(a2, 0xDu, 0x104u, (LPARAM)lParam);
      if ( ((*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 1320) + 124))(
              *(_DWORD *)(a1 + 1320),
              *(_DWORD *)(a1 + 60612)) & 0x10) == 0 )
      {
        v6 = lstrlenW((LPCWSTR)lParam) - 1;
        if ( v6 >= 0 )
        {
          while ( lParam[v6] != 46 )
          {
            if ( --v6 < 0 )
              return sub_401C60((int)a2, a3, a4, dwErrCode);
          }
          v7 = *(_DWORD *)(a1 + 5636);
          if ( v7 )
          {
            if ( v7 == 1 )
            {
              *(_DWORD *)(a1 + 5636) = 2;
              SendMessageW(a2, 0xB1u, 0, -1);
            }
            else if ( v7 == 2 )
            {
              *(_DWORD *)(a1 + 5636) = 0;
              SendMessageW(a2, 0xB1u, 0, v6);
            }
          }
          else
          {
            v8 = lstrlenW((LPCWSTR)lParam);
            SendMessageW(a2, 0xB1u, v6 + 1, v8);
            *(_DWORD *)(a1 + 5636) = 1;
          }
        }
      }
    }
    return sub_401C60((int)a2, a3, a4, dwErrCode);
  }
  Parent = GetParent(a2);
  wParam = SendMessageW(Parent, 0x100Cu, 0xFFFFFFFF, 2);
  v10 = GetParent(a2);
  v18[4] = 2;
  v18[3] = 0;
  SendMessageW(v10, 0x102Bu, wParam, (LPARAM)v18);
  v11 = GetParent(a2);
  v12 = SendMessageW(v11, 0x1004u, 0, 0);
  if ( wParam == v12 - 1 )
    v13 = 0;
  else
    v13 = wParam + 1;
  v17 = v13;
  v14 = GetParent(a2);
  SendMessageW(v14, 0x1076u, v17, 0);
  return 0;
}
// 49C860: using guessed type WCHAR lParam[262];

//----- (0049CAB0) --------------------------------------------------------
int __stdcall sub_49CAB0(HWND a1, int a2, int a3, DWORD a4, int a5, int a6)
{
  return sub_49C860(a6, a1, a2, a3, a4);
}

//----- (0049CAE0) --------------------------------------------------------
int __userpurge sub_49CAE0@<eax>(DWORD a1@<esi>, int a2)
{
  HWND Focus; // eax
  HRESULT v3; // eax
  int v5; // eax
  int v6; // edx
  int v7; // [esp+0h] [ebp-4h] BYREF

  v7 = 16;
  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    v3 = sub_494780(a1, (int)&v7);
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 76) )
      return 1;
    v3 = sub_4946F0(a1, (int)&v7);
  }
  if ( v3 < 0 || (v7 & 0x10) != 16 )
    return 1;
  v5 = SendMessageW(*(HWND *)(a1 + 3432), 0x1018u, 0, 0);
  sub_409750(v5, (int)sub_49CAB0, 0, a1);
  *(_DWORD *)(a1 + 5636) = 0;
  v6 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 60608) = 1;
  *(_DWORD *)(a1 + 60604) = 1;
  *(_DWORD *)(a1 + 60612) = v6;
  return 0;
}

//----- (0049CB90) --------------------------------------------------------
void __thiscall sub_49CB90(HWND hWnd, int a2, int a3)
{
  int v3; // ebx
  _DWORD *v5; // eax
  int v6; // esi
  WPARAM i; // edi
  char *v8; // eax
  int v9; // edi
  int pExceptionObject[3]; // [esp+10h] [ebp-25Ch] BYREF
  void *v11; // [esp+1Ch] [ebp-250h] BYREF
  int v12; // [esp+20h] [ebp-24Ch]
  int v13; // [esp+28h] [ebp-244h]
  HWND hWnda; // [esp+2Ch] [ebp-240h]
  int v15; // [esp+30h] [ebp-23Ch]
  char *v16; // [esp+34h] [ebp-238h] BYREF
  void *v17[5]; // [esp+38h] [ebp-234h] BYREF
  unsigned int v18; // [esp+4Ch] [ebp-220h]
  unsigned __int16 Src; // [esp+54h] [ebp-218h] BYREF
  __int16 v20; // [esp+56h] [ebp-216h] BYREF
  int v21; // [esp+268h] [ebp-4h]

  v13 = a2;
  v3 = 0;
  hWnda = hWnd;
  v15 = a3;
  if ( a3 )
  {
    v12 = 0;
    v5 = operator new(0x24u);
    v6 = (int)v5;
    if ( !v5 )
    {
      v16 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v16);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v5 = v5;
    v11 = v5;
    v5[1] = v5;
    v21 = 0;
    for ( i = SendMessageW(hWnd, 0x100Cu, 0xFFFFFFFF, 2); i != -1; i = SendMessageW(hWnda, 0x100Cu, i, 2) )
    {
      (*(void (__thiscall **)(_DWORD, WPARAM, unsigned __int16 *))(**(_DWORD **)(v13 + 1320) + 48))(
        *(_DWORD *)(v13 + 1320),
        i,
        &Src);
      LOWORD(v17[0]) = 0;
      v18 = 7;
      v17[4] = 0;
      sub_4094F0(v17, (int)&v20, &Src, wcslen(&Src));
      LOBYTE(v21) = 1;
      v8 = sub_40A200((char *)v6, *(_DWORD *)(v6 + 4), (int)v17);
      if ( v3 == 153391688 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(v6 + 4) = v8;
      ++v3;
      **((_DWORD **)v8 + 1) = v8;
      LOBYTE(v21) = 0;
      v12 = v3;
      if ( v18 >= 8 )
        operator delete(v17[0]);
    }
    v9 = *(_DWORD *)v6;
    sub_40A140(v15);
    sub_40B6E0(v15, **(char ***)v15, v9, v6, (int)v16);
    sub_40A140((int)&v11);
    operator delete(v11);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0049CDA0) --------------------------------------------------------
HRESULT __thiscall sub_49CDA0(char *this)
{
  DWORD v1; // esi
  HRESULT result; // eax
  _DWORD *v4; // eax
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  char *v8; // edx
  int v9; // ecx
  bool v10; // zf
  int *v11; // ebx
  int v12[2]; // [esp+Ch] [ebp-224h] BYREF
  LPDATAOBJECT ppDataObj; // [esp+14h] [ebp-21Ch] BYREF
  WCHAR String[266]; // [esp+18h] [ebp-218h] BYREF

  v1 = 0;
  ppDataObj = 0;
  result = OleGetClipboard(&ppDataObj);
  if ( !result )
  {
    v4 = operator new(0x30u);
    if ( v4 )
    {
      v4[1] = 1;
      *v4 = &CDropHandler::`vftable';
      v1 = (DWORD)v4;
    }
    v5 = String;
    v6 = 261;
    while ( v6 != -2147483385 )
    {
      v7 = *(WCHAR *)((char *)v5 + this + 3492 - (char *)String);
      if ( !v7 )
        break;
      *v5++ = v7;
      if ( !--v6 )
      {
        --v5;
        break;
      }
    }
    *v5 = 0;
    String[lstrlenW(String) + 1] = 0;
    if ( this )
      v8 = this + 16;
    else
      v8 = 0;
    v9 = *((_DWORD *)this + 13);
    v10 = *((_DWORD *)this + 14853) == 0;
    v11 = (int *)ppDataObj;
    *(_DWORD *)(v1 + 32) = v9;
    *(_DWORD *)(v1 + 12) = v8;
    *(_DWORD *)(v1 + 40) = String;
    *(_DWORD *)(v1 + 8) = v11;
    *(_DWORD *)(v1 + 28) = 1;
    *(_DWORD *)(v1 + 44) = v10;
    v12[0] = 0;
    v12[1] = 0;
    sub_461780(v11, v1, v12);
    if ( !InterlockedDecrement((volatile LONG *)(v1 + 4)) )
      (**(void (__thiscall ***)(DWORD, int))v1)(v1, 1);
    return ppDataObj->lpVtbl->Release(ppDataObj);
  }
  return result;
}
// 49CE30: conditional instruction was optimized away because edx.4!=0
// 4CC480: using guessed type void *CDropHandler::`vftable';

//----- (0049CEE0) --------------------------------------------------------
HRESULT __userpurge sub_49CEE0@<eax>(int a1@<esi>, int a2)
{
  HCURSOR CursorW; // eax
  _DWORD *v4; // eax
  HRESULT v5; // edi
  HWND v6; // edx
  int v7; // ecx
  WPARAM i; // ebx
  int v9; // edi
  char *v10; // eax
  int v11; // ecx
  HCURSOR v12; // eax
  UINT v13; // [esp-Ch] [ebp-278h] BYREF
  WPARAM v14; // [esp-8h] [ebp-274h]
  LPARAM v15; // [esp-4h] [ebp-270h]
  int pExceptionObject[3]; // [esp+10h] [ebp-25Ch] BYREF
  char *v17; // [esp+1Ch] [ebp-250h] BYREF
  void *v18[3]; // [esp+20h] [ebp-24Ch] BYREF
  LPDATAOBJECT v19; // [esp+2Ch] [ebp-240h] BYREF
  UINT *v20; // [esp+30h] [ebp-23Ch]
  void *v21[5]; // [esp+34h] [ebp-238h] BYREF
  unsigned int v22; // [esp+48h] [ebp-224h]
  __int16 Src[260]; // [esp+50h] [ebp-21Ch] BYREF
  int v24; // [esp+268h] [ebp-4h]

  v19 = 0;
  if ( !sub_494670((_DWORD *)a1) )
    return -2147467259;
  CursorW = LoadCursorW(0, (LPCWSTR)0x7F02);
  SetCursor(CursorW);
  v18[1] = 0;
  v4 = operator new(0x24u);
  if ( !v4 )
  {
    v17 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v4 = v4;
  v18[0] = v4;
  v4[1] = v4;
  v24 = 0;
  sub_49CB90(*(HWND *)(a1 + 3432), a1, (int)v18);
  v20 = &v13;
  sub_40AC30((char ***)&v13, (int **)v18);
  if ( a2 )
  {
    v5 = sub_4AE6E0(&v19, (void *)v13);
    if ( v5 >= 0 )
      *(_DWORD *)(a1 + 60584) = v19;
  }
  else
  {
    v20 = (UINT *)sub_4AE660(&v19, (void *)v13);
    if ( (int)v20 >= 0 )
    {
      v6 = *(HWND *)(a1 + 3432);
      v7 = *(_DWORD *)(a1 + 5620);
      v15 = 2;
      v14 = -1;
      v13 = 4108;
      *(_DWORD *)(a1 + 60584) = v19;
      *(_DWORD *)(a1 + 61240) = v7;
      for ( i = SendMessageW(v6, v13, v14, v15); i != -1; i = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, i, 2) )
      {
        (*(void (__thiscall **)(_DWORD, WPARAM, int, __int16 *))(**(_DWORD **)(a1 + 1320) + 64))(
          *(_DWORD *)(a1 + 1320),
          i,
          260,
          Src);
        v22 = 7;
        v21[4] = 0;
        LOWORD(v21[0]) = 0;
        sub_4094F0(v21, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
        LOBYTE(v24) = 1;
        v9 = *(_DWORD *)(a1 + 61228);
        v10 = sub_40A200((char *)v9, *(_DWORD *)(v9 + 4), (int)v21);
        v11 = *(_DWORD *)(a1 + 61232);
        if ( v11 == 153391688 )
          std::_Xlength_error("list<T> too long");
        *(_DWORD *)(a1 + 61232) = v11 + 1;
        *(_DWORD *)(v9 + 4) = v10;
        **((_DWORD **)v10 + 1) = v10;
        LOBYTE(v24) = 0;
        if ( v22 >= 8 )
          operator delete(v21[0]);
        (*(void (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a1 + 1320) + 188))(*(_DWORD *)(a1 + 1320), i);
      }
    }
    v5 = (HRESULT)v20;
  }
  v12 = LoadCursorW(0, (LPCWSTR)0x7F00);
  SetCursor(v12);
  sub_40A140((int)v18);
  operator delete(v18[0]);
  return v5;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 49CEE0: using guessed type unsigned __int16 Src[260];

//----- (0049D190) --------------------------------------------------------
void __thiscall sub_49D190(_DWORD *this)
{
  _DWORD *v1; // esi
  WPARAM v2; // edi
  DWORD UniversalNameW; // eax
  int v4; // edx
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  void *v7; // eax
  HWND v8; // [esp-10h] [ebp-A94h]
  DWORD BufferSize; // [esp+10h] [ebp-A74h] BYREF
  _DWORD *v10; // [esp+14h] [ebp-A70h]
  void *v11[4]; // [esp+18h] [ebp-A6Ch] BYREF
  int v12; // [esp+28h] [ebp-A5Ch]
  unsigned int v13; // [esp+2Ch] [ebp-A58h]
  void *v14[5]; // [esp+34h] [ebp-A50h] BYREF
  unsigned int v15; // [esp+48h] [ebp-A3Ch]
  void *v16[4]; // [esp+50h] [ebp-A34h] BYREF
  int v17; // [esp+60h] [ebp-A24h]
  unsigned int v18; // [esp+64h] [ebp-A20h]
  unsigned __int16 *Buffer; // [esp+6Ch] [ebp-A18h] BYREF
  WCHAR LocalPath[260]; // [esp+86Ch] [ebp-218h] BYREF
  int v21; // [esp+A80h] [ebp-4h]

  v1 = this;
  v8 = (HWND)this[858];
  v10 = this;
  if ( SendMessageW(v8, 0x1032u, 0, 0) )
  {
    v13 = 7;
    v12 = 0;
    LOWORD(v11[0]) = 0;
    v21 = 0;
    v2 = SendMessageW((HWND)v1[858], 0x100Cu, 0xFFFFFFFF, 2);
    if ( v2 != -1 )
    {
      while ( 1 )
      {
        (*(void (__thiscall **)(_DWORD, WPARAM, WCHAR *))(*(_DWORD *)v1[330] + 48))(v1[330], v2, LocalPath);
        BufferSize = 1024;
        UniversalNameW = WNetGetUniversalNameW(LocalPath, 1u, &Buffer, &BufferSize);
        v15 = 7;
        v14[4] = 0;
        if ( UniversalNameW )
        {
          LOWORD(v14[0]) = 0;
          sub_4094F0(v14, v4, L"\r\n", 2);
          LOBYTE(v21) = 3;
          v6 = sub_40B1A0(LocalPath, v16, v14);
          LOBYTE(v21) = 4;
          sub_406A00(v11, v6, 0, 0xFFFFFFFF);
          if ( v18 >= 8 )
            operator delete(v16[0]);
          LOBYTE(v21) = 0;
          v18 = 7;
          v17 = 0;
          LOWORD(v16[0]) = 0;
          if ( v15 >= 8 )
LABEL_13:
            operator delete(v14[0]);
        }
        else
        {
          LOWORD(v14[0]) = 0;
          sub_4094F0(v14, v4, L"\r\n", 2);
          LOBYTE(v21) = 1;
          v5 = sub_40B1A0(Buffer, v16, v14);
          LOBYTE(v21) = 2;
          sub_406A00(v11, v5, 0, 0xFFFFFFFF);
          if ( v18 >= 8 )
            operator delete(v16[0]);
          LOBYTE(v21) = 0;
          v18 = 7;
          v17 = 0;
          LOWORD(v16[0]) = 0;
          if ( v15 >= 8 )
            goto LABEL_13;
        }
        v2 = SendMessageW((HWND)v10[858], 0x100Cu, v2, 2);
        if ( v2 == -1 )
          break;
        v1 = v10;
      }
    }
    v7 = (void *)sub_402000(0, v12 - 2, (int)v16, v11);
    LOBYTE(v21) = 5;
    sub_40AF70(v11, v7);
    if ( v18 >= 8 )
      operator delete(v16[0]);
    sub_467670(v11);
    if ( v13 >= 8 )
      operator delete(v11[0]);
  }
}
// 49D291: variable 'v4' is possibly undefined
// 4CB0E8: using guessed type wchar_t asc_4CB0E8[3];
// 4CB0F0: using guessed type wchar_t asc_4CB0F0[3];

//----- (0049D460) --------------------------------------------------------
void __usercall sub_49D460(int a1@<ebx>)
{
  WPARAM i; // edi
  int v2; // edx
  _DWORD *v3; // eax
  void *v4; // eax
  void *v5[5]; // [esp+Ch] [ebp-26Ch] BYREF
  unsigned int v6; // [esp+20h] [ebp-258h]
  void *v7[5]; // [esp+28h] [ebp-250h] BYREF
  unsigned int v8; // [esp+3Ch] [ebp-23Ch]
  void *v9[4]; // [esp+44h] [ebp-234h] BYREF
  int v10; // [esp+54h] [ebp-224h]
  unsigned int v11; // [esp+58h] [ebp-220h]
  __int16 v12[260]; // [esp+60h] [ebp-218h] BYREF
  int v13; // [esp+274h] [ebp-4h]

  if ( SendMessageW(*(HWND *)(a1 + 3432), 0x1032u, 0, 0) )
  {
    v11 = 7;
    v10 = 0;
    LOWORD(v9[0]) = 0;
    v13 = 0;
    for ( i = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, 0xFFFFFFFF, 2);
          i != -1;
          i = SendMessageW(*(HWND *)(a1 + 3432), 0x100Cu, i, 2) )
    {
      (*(void (__thiscall **)(_DWORD, WPARAM, __int16 *))(**(_DWORD **)(a1 + 1320) + 48))(
        *(_DWORD *)(a1 + 1320),
        i,
        v12);
      LOWORD(v5[0]) = 0;
      v6 = 7;
      v5[4] = 0;
      sub_4094F0(v5, v2, L"\r\n", 2);
      LOBYTE(v13) = 1;
      v3 = sub_40B1A0((unsigned __int16 *)v12, v7, v5);
      LOBYTE(v13) = 2;
      sub_406A00(v9, v3, 0, 0xFFFFFFFF);
      if ( v8 >= 8 )
        operator delete(v7[0]);
      LOBYTE(v13) = 0;
      v8 = 7;
      v7[4] = 0;
      LOWORD(v7[0]) = 0;
      if ( v6 >= 8 )
        operator delete(v5[0]);
    }
    v4 = (void *)sub_402000(0, v10 - 2, (int)v7, v9);
    LOBYTE(v13) = 3;
    sub_40AF70(v9, v4);
    if ( v8 >= 8 )
      operator delete(v7[0]);
    sub_467670(v9);
    if ( v11 >= 8 )
      operator delete(v9[0]);
  }
}
// 49D52D: variable 'v2' is possibly undefined
// 4CB0E0: using guessed type wchar_t asc_4CB0E0[3];
// 49D460: using guessed type unsigned __int16 var_218[260];

//----- (0049D660) --------------------------------------------------------
void __thiscall sub_49D660(int this)
{
  LRESULT v2; // eax
  WPARAM v3; // eax
  char *v4; // eax
  char *v5; // esi
  WPARAM v6; // edi
  char *v7; // eax
  void *v8; // edi
  char **v9[3]; // [esp-10h] [ebp-2C4h] BYREF
  int v10; // [esp-4h] [ebp-2B8h]
  LPARAM dwInitParam[3]; // [esp+10h] [ebp-2A4h] BYREF
  unsigned __int16 v12; // [esp+1Ch] [ebp-298h]
  HWND hWndParent; // [esp+20h] [ebp-294h]
  int v14; // [esp+28h] [ebp-28Ch]
  void *v15; // [esp+3Ch] [ebp-278h]
  void *v16; // [esp+40h] [ebp-274h] BYREF
  int pExceptionObject[3]; // [esp+5Ch] [ebp-258h] BYREF
  char *v18; // [esp+68h] [ebp-24Ch] BYREF
  void *v19; // [esp+6Ch] [ebp-248h] BYREF
  int v20; // [esp+70h] [ebp-244h]
  int i; // [esp+78h] [ebp-23Ch]
  char ***v22; // [esp+7Ch] [ebp-238h]
  void *v23[5]; // [esp+80h] [ebp-234h] BYREF
  unsigned int v24; // [esp+94h] [ebp-220h]
  unsigned __int16 Src; // [esp+9Ch] [ebp-218h] BYREF
  __int16 v26; // [esp+9Eh] [ebp-216h] BYREF
  int v27; // [esp+2B0h] [ebp-4h]

  if ( !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 1320) + 144))(*(_DWORD *)(this + 1320)) )
  {
    v2 = SendMessageW(*(HWND *)(this + 3432), 0x1032u, 0, 0);
    v22 = (char ***)v2;
    if ( v2 == 1 )
    {
      v3 = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 3);
      if ( v3 != -1 )
        SendMessageW(*(HWND *)(this + 3432), 0x1076u, v3, 0);
    }
    else if ( v2 > 1 )
    {
      v20 = 0;
      v4 = (char *)operator new(0x24u);
      v5 = v4;
      if ( !v4 )
      {
        v18 = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v18);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      *(_DWORD *)v4 = v4;
      v19 = v4;
      *((_DWORD *)v4 + 1) = v4;
      v27 = 0;
      v6 = -1;
      for ( i = 0; i < (int)v22; ++i )
      {
        v6 = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, v6, 2);
        if ( v6 != -1 )
        {
          (*(void (__thiscall **)(_DWORD, WPARAM, unsigned __int16 *))(**(_DWORD **)(this + 1320) + 48))(
            *(_DWORD *)(this + 1320),
            v6,
            &Src);
          LOWORD(v23[0]) = 0;
          v24 = 7;
          v23[4] = 0;
          sub_4094F0(v23, (int)&v26, &Src, wcslen(&Src));
          LOBYTE(v27) = 1;
          v7 = sub_40A200(v5, *((_DWORD *)v5 + 1), (int)v23);
          if ( v20 == 153391688 )
            std::_Xlength_error("list<T> too long");
          ++v20;
          *((_DWORD *)v5 + 1) = v7;
          **((_DWORD **)v7 + 1) = v7;
          LOBYTE(v27) = 0;
          if ( v24 >= 8 )
            operator delete(v23[0]);
        }
      }
      v10 = this + 59552;
      v22 = v9;
      sub_40AC30(v9, (int **)&v19);
      sub_4994F0(*(void **)(this + 52), (int)dwInitParam, v9[0], (int)v9[1], (int)v9[2], v10);
      if ( !v14 )
        DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v12, hWndParent, DialogFunc, (LPARAM)dwInitParam);
      dwInitParam[0] = (LPARAM)&CMassRenameDialog::`vftable';
      sub_40A140((int)&v16);
      operator delete(v16);
      dwInitParam[0] = (LPARAM)&CBaseDialog::`vftable';
      v8 = v15;
      if ( v15 )
      {
        sub_4AAAD0((int)v15);
        operator delete(v8);
      }
      sub_40A140((int)&v19);
      operator delete(v19);
    }
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CBFAC: using guessed type void *CMassRenameDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0049D950) --------------------------------------------------------
void __thiscall sub_49D950(int this, void *a2)
{
  int *v3; // esi
  WPARAM i; // edi
  char *v5; // eax
  int pExceptionObject[3]; // [esp+10h] [ebp-250h] BYREF
  char *v7; // [esp+1Ch] [ebp-244h] BYREF
  void *v8; // [esp+20h] [ebp-240h] BYREF
  int v9; // [esp+24h] [ebp-23Ch]
  void *v10[5]; // [esp+2Ch] [ebp-234h] BYREF
  unsigned int v11; // [esp+40h] [ebp-220h]
  unsigned __int16 Src; // [esp+48h] [ebp-218h] BYREF
  __int16 v13; // [esp+4Ah] [ebp-216h] BYREF
  int v14; // [esp+25Ch] [ebp-4h]

  if ( SendMessageW(*(HWND *)(this + 3432), 0x1032u, 0, 0) )
  {
    v9 = 0;
    v3 = (int *)operator new(0x24u);
    if ( !v3 )
    {
      v7 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v3 = (int)v3;
    v8 = v3;
    v3[1] = (int)v3;
    v14 = 0;
    for ( i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 2);
          i != -1;
          i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, i, 2) )
    {
      (*(void (__thiscall **)(_DWORD, WPARAM, unsigned __int16 *))(**(_DWORD **)(this + 1320) + 48))(
        *(_DWORD *)(this + 1320),
        i,
        &Src);
      LOWORD(v10[0]) = 0;
      v11 = 7;
      v10[4] = 0;
      sub_4094F0(v10, (int)&v13, &Src, wcslen(&Src));
      LOBYTE(v14) = 1;
      v5 = sub_40A200((char *)v3, v3[1], (int)v10);
      if ( v9 == 153391688 )
        std::_Xlength_error("list<T> too long");
      ++v9;
      v3[1] = (int)v5;
      **((_DWORD **)v5 + 1) = v5;
      LOBYTE(v14) = 0;
      if ( v11 >= 8 )
        operator delete(v10[0]);
    }
    sub_463FD0(*(HWND *)(this + 52), (int **)&v8, this + 59552, a2);
    sub_40A140((int)&v8);
    operator delete(v8);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0049DB50) --------------------------------------------------------
LPDATAOBJECT __thiscall sub_49DB50(int this, int a2, struct IDropSourceVtbl *a3)
{
  HWND v4; // ecx
  int *v6; // eax
  int *v7; // edi
  char *v8; // eax
  char *v9; // esi
  void *v10; // eax
  HWND v11; // ecx
  WPARAM v12; // eax
  IDropSource *v13; // eax
  IDataObject *v14; // eax
  int v15; // edx
  char **v16; // eax
  int v17; // kr00_4
  int v18; // edx
  char *v19; // eax
  IDataObject *v20; // esi
  int v21; // eax
  int v22; // eax
  int i; // ebx
  int *v24; // eax
  int *v25; // ebx
  char **v26; // [esp-Ch] [ebp-2CCh] BYREF
  DWORD v27; // [esp-8h] [ebp-2C8h]
  LPDWORD p_pdwEffect; // [esp-4h] [ebp-2C4h]
  int v29[5]; // [esp+14h] [ebp-2ACh] BYREF
  char v30[20]; // [esp+28h] [ebp-298h] BYREF
  char v31[4]; // [esp+3Ch] [ebp-284h] BYREF
  int pExceptionObject[3]; // [esp+40h] [ebp-280h] BYREF
  DWORD pdwEffect; // [esp+4Ch] [ebp-274h] BYREF
  int v34[2]; // [esp+50h] [ebp-270h] BYREF
  int *v35; // [esp+58h] [ebp-268h] BYREF
  int v36; // [esp+5Ch] [ebp-264h]
  char *v37; // [esp+64h] [ebp-25Ch] BYREF
  void *v38; // [esp+68h] [ebp-258h] BYREF
  int v39; // [esp+6Ch] [ebp-254h]
  LPVOID ppv; // [esp+74h] [ebp-24Ch] BYREF
  LPDROPSOURCE pDropSource; // [esp+78h] [ebp-248h]
  int v42; // [esp+7Ch] [ebp-244h]
  LPVOID pv; // [esp+80h] [ebp-240h] BYREF
  WPARAM wParam; // [esp+84h] [ebp-23Ch] BYREF
  LPDATAOBJECT pDataObj; // [esp+88h] [ebp-238h] BYREF
  void *v46; // [esp+8Ch] [ebp-234h] BYREF
  int v47[3]; // [esp+90h] [ebp-230h] BYREF
  int v48; // [esp+9Ch] [ebp-224h] BYREF
  unsigned int v49; // [esp+A0h] [ebp-220h]
  __int16 Src[260]; // [esp+A8h] [ebp-218h] BYREF
  int v51; // [esp+2BCh] [ebp-4h]

  p_pdwEffect = 0;
  v27 = 0;
  v4 = *(HWND *)(this + 3432);
  v42 = a2;
  ppv = 0;
  v34[0] = 0;
  v34[1] = 0;
  if ( !SendMessageW(v4, 0x1032u, 0, 0) )
    return (LPDATAOBJECT)-2147467259;
  v36 = 0;
  v6 = (int *)operator new(0xCu);
  v7 = v6;
  if ( !v6 )
  {
    pv = 0;
    std::exception::exception((std::exception *)&v48, (const char *const *)&pv);
    v48 = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(&v48, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v6 = (int)v6;
  v35 = v6;
  v6[1] = (int)v6;
  v51 = 0;
  v39 = 0;
  v8 = (char *)operator new(0x24u);
  v9 = v8;
  if ( !v8 )
  {
    v37 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v37);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)v8 = v8;
  v38 = v8;
  *((_DWORD *)v8 + 1) = v8;
  LOBYTE(v51) = 1;
  v10 = (void *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 1320) + 56))(*(_DWORD *)(this + 1320));
  v11 = *(HWND *)(this + 3432);
  pv = v10;
  v12 = SendMessageW(v11, 0x100Cu, 0xFFFFFFFF, 2);
  wParam = v12;
  if ( v12 != -1 )
  {
    while ( 1 )
    {
      v14 = (IDataObject *)(*(int (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(this + 1320) + 140))(
                             *(_DWORD *)(this + 1320),
                             v12);
      v15 = v7[1];
      pDataObj = v14;
      v16 = sub_40A550((char *)v7, v15, (int)&pDataObj);
      if ( v36 == 1073741822 )
        goto LABEL_16;
      ++v36;
      v7[1] = (int)v16;
      *(_DWORD *)v16[1] = v16;
      (*(void (__thiscall **)(_DWORD, WPARAM, __int16 *))(**(_DWORD **)(this + 1320) + 48))(
        *(_DWORD *)(this + 1320),
        wParam,
        Src);
      LOWORD(v46) = 0;
      v49 = 7;
      v48 = 0;
      v17 = wcslen((const unsigned __int16 *)Src);
      sub_4094F0(&v46, v18, Src, v17);
      LOBYTE(v51) = 2;
      v19 = sub_40A200(v9, *((_DWORD *)v9 + 1), (int)&v46);
      if ( v39 == 153391688 )
LABEL_16:
        std::_Xlength_error("list<T> too long");
      ++v39;
      *((_DWORD *)v9 + 1) = v19;
      **((_DWORD **)v19 + 1) = v19;
      LOBYTE(v51) = 1;
      if ( v49 >= 8 )
        operator delete(v46);
      wParam = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, wParam, 2);
      if ( wParam == -1 )
        break;
      v12 = wParam;
    }
  }
  pDataObj = (LPDATAOBJECT)CoCreateInstance(&rclsid, 0, 0x17u, &riid, &ppv);
  if ( (int)pDataObj >= 0 )
  {
    v13 = (IDropSource *)operator new(0xCu);
    if ( v13 )
    {
      v13->lpVtbl = (struct IDropSourceVtbl *)&CDropSource::`vftable';
      v13[1].lpVtbl = (struct IDropSourceVtbl *)1;
      v13[2].lpVtbl = a3;
      pDropSource = v13;
    }
    else
    {
      pDropSource = 0;
    }
    pDataObj = (LPDATAOBJECT)&v26;
    sub_40AC30(&v26, (int **)&v38);
    sub_467BD0((int)v29, v26, v27);
    pDataObj = (LPDATAOBJECT)&v26;
    sub_40ACF0(&v26, &v35);
    sub_467490((int)v30, (int)&v48, (LPCITEMIDLIST)pv, v26, v27);
    pDataObj = 0;
    wParam = 0;
    sub_462160(&pDataObj, v29, v47);
    v20 = pDataObj;
    pDataObj->lpVtbl->QueryInterface(pDataObj, (const IID *const)dword_4BD9AC, (void **)&wParam);
    (*(void (__stdcall **)(WPARAM, int))(*(_DWORD *)wParam + 12))(wParam, 1);
    (*(void (__stdcall **)(LPVOID, _DWORD, int *, IDataObject *))(*(_DWORD *)ppv + 16))(
      ppv,
      *(_DWORD *)(this + 3432),
      v34,
      v20);
    (*(void (__thiscall **)(_DWORD, _DWORD, int))(**(_DWORD **)(this + 1320) + 128))(
      *(_DWORD *)(this + 1320),
      *(_DWORD *)(v42 + 12),
      v42 + 32);
    v21 = *(_DWORD *)(this + 5620);
    p_pdwEffect = &pdwEffect;
    v27 = 7;
    v26 = (char **)pDropSource;
    *(_DWORD *)(this + 60592) = 1;
    v42 = v21;
    DoDragDrop(v20, (LPDROPSOURCE)v26, v27, p_pdwEffect);
    v22 = v42;
    *(_DWORD *)(this + 60592) = 0;
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 4 * v22 + 916) + 172))(*(_DWORD *)(this + 4 * v22 + 916));
    pDataObj = (LPDATAOBJECT)(*(int (__stdcall **)(WPARAM, char *))(*(_DWORD *)wParam + 24))(wParam, v31);
    (*(void (__stdcall **)(WPARAM))(*(_DWORD *)wParam + 8))(wParam);
    v20->lpVtbl->Release(v20);
    pDropSource->lpVtbl->Release(pDropSource);
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  }
  for ( i = *v7; (int *)i != v7; i = *(_DWORD *)i )
    CoTaskMemFree(*(LPVOID *)(i + 8));
  CoTaskMemFree(pv);
  sub_40A140((int)&v38);
  operator delete(v38);
  v24 = (int *)*v7;
  *v7 = (int)v7;
  v7[1] = (int)v7;
  if ( v24 != v7 )
  {
    do
    {
      v25 = (int *)*v24;
      operator delete(v24);
      v24 = v25;
    }
    while ( v25 != v7 );
  }
  operator delete(v7);
  return pDataObj;
}
// 49DD6E: variable 'v18' is possibly undefined
// 4BD9AC: using guessed type _DWORD dword_4BD9AC[4];
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CBDF4: using guessed type void *CDropSource::`vftable';
// 49DB50: using guessed type unsigned __int16 Src[260];
// 49DB50: using guessed type int var_230[3];
// 49DB50: using guessed type char var_298[20];
// 49DB50: using guessed type char var_284[4];

//----- (0049E070) --------------------------------------------------------
void __thiscall sub_49E070(int this, int a2)
{
  int *v3; // esi
  LRESULT i; // edi
  void *v5; // eax
  int v6; // edx
  char **v7; // eax
  char ***v8; // ecx
  const ITEMIDLIST *v9; // edi
  int v10; // edi
  _DWORD *v11; // eax
  char KeyState; // al
  int j; // edi
  int *v14; // eax
  int *v15; // edi
  char **v16; // [esp-Ch] [ebp-B0h] BYREF
  WPARAM v17; // [esp-8h] [ebp-ACh]
  LPARAM v18; // [esp-4h] [ebp-A8h]
  DWORD_PTR dwRefData[12]; // [esp+14h] [ebp-90h] BYREF
  int v20[3]; // [esp+44h] [ebp-60h] BYREF
  void *v21[3]; // [esp+50h] [ebp-54h] BYREF
  char v22; // [esp+5Ch] [ebp-48h]
  int v23[3]; // [esp+60h] [ebp-44h] BYREF
  int pExceptionObject[3]; // [esp+6Ch] [ebp-38h] BYREF
  int *v25; // [esp+78h] [ebp-2Ch] BYREF
  int v26; // [esp+7Ch] [ebp-28h]
  char *v27; // [esp+84h] [ebp-20h] BYREF
  char *v28; // [esp+88h] [ebp-1Ch] BYREF
  int v29; // [esp+8Ch] [ebp-18h] BYREF
  void *pv[2]; // [esp+90h] [ebp-14h] BYREF
  int v31; // [esp+A0h] [ebp-4h]

  if ( SendMessageW(*(HWND *)(this + 3432), 0x1032u, 0, 0) > 0 )
  {
    v26 = 0;
    v3 = (int *)operator new(0xCu);
    if ( !v3 )
    {
      v27 = 0;
      std::exception::exception((std::exception *)v23, (const char *const *)&v27);
      v23[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(v23, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v3 = (int)v3;
    v25 = v3;
    v3[1] = (int)v3;
    v31 = 0;
    for ( i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, 0xFFFFFFFF, 2);
          i != -1;
          i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, v17, v18) )
    {
      v5 = (void *)(*(int (__thiscall **)(_DWORD, LRESULT))(**(_DWORD **)(this + 1320) + 140))(
                     *(_DWORD *)(this + 1320),
                     i);
      v6 = v3[1];
      pv[0] = v5;
      v7 = sub_40A550((char *)v3, v6, (int)pv);
      if ( v26 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      ++v26;
      v3[1] = (int)v7;
      v8 = (char ***)v7[1];
      v18 = 2;
      v17 = i;
      *v8 = v7;
    }
    v9 = (const ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 1320) + 56))(*(_DWORD *)(this + 1320));
    v28 = (char *)&v16;
    pv[0] = (void *)v9;
    sub_40ACF0(&v16, &v25);
    sub_4AD000((int)dwRefData, *(_DWORD *)(this + 3432), v9, v16, v17, v18);
    LOBYTE(v31) = 1;
    v10 = *(_DWORD *)(this + 56);
    v29 = 0;
    v21[1] = 0;
    v11 = operator new(0x24u);
    if ( !v11 )
    {
      v28 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v28);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v21[0] = v11;
    *v11 = v11;
    *((void **)v21[0] + 1) = v21[0];
    v20[0] = v10;
    v22 = 0;
    v20[1] = 0;
    LOBYTE(v31) = 2;
    KeyState = GetKeyState(16);
    sub_4AD640((DWORD_PTR)dwRefData, this, this + 20, a2, (int)v20, (int)&v29, 1, KeyState & 0x80);
    CoTaskMemFree(pv[0]);
    for ( j = *v3; (int *)j != v3; j = *(_DWORD *)j )
      CoTaskMemFree(*(LPVOID *)(j + 8));
    sub_40A140((int)v21);
    operator delete(v21[0]);
    LOBYTE(v31) = 0;
    sub_4ACF20(dwRefData);
    v14 = (int *)*v3;
    *v3 = (int)v3;
    v3[1] = (int)v3;
    if ( v14 != v3 )
    {
      do
      {
        v15 = (int *)*v14;
        operator delete(v14);
        v14 = v15;
      }
      while ( v15 != v3 );
    }
    operator delete(v3);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 49E070: using guessed type LPVOID pv[2];

//----- (0049E2E0) --------------------------------------------------------
BOOL __thiscall sub_49E2E0(int this, int a2)
{
  HMENU v3; // eax
  int v4; // ecx
  ITEMIDLIST *v5; // esi
  LPITEMIDLIST v6; // edi
  int v7; // esi
  HRESULT v8; // eax
  void *v10[9]; // [esp+14h] [ebp-50h] BYREF
  ITEMIDLIST *v11; // [esp+38h] [ebp-2Ch]
  LPITEMIDLIST ID; // [esp+3Ch] [ebp-28h] BYREF
  HRESULT v13; // [esp+40h] [ebp-24h]
  HMENU hMenu; // [esp+44h] [ebp-20h]
  LPVOID pv; // [esp+48h] [ebp-1Ch]
  int v16; // [esp+4Ch] [ebp-18h] BYREF
  LPITEMIDLIST ppidl; // [esp+50h] [ebp-14h] BYREF
  IShellFolder *ppshf; // [esp+54h] [ebp-10h] BYREF
  int v19; // [esp+60h] [ebp-4h]

  v3 = sub_49C330((_DWORD *)this);
  v4 = *(_DWORD *)(this + 1320);
  hMenu = v3;
  v5 = (ITEMIDLIST *)(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 56))(v4);
  pv = v5;
  v6 = ILClone(v5);
  v11 = v6;
  ILRemoveLastID(v6);
  ID = ILFindLastID(v5);
  ppshf = 0;
  ppidl = 0;
  if ( SHGetFolderLocation(0, 0, 0, 0, &ppidl) >= 0 )
  {
    v7 = sub_466190(v6, ppidl);
    CoTaskMemFree(ppidl);
    if ( v7 )
    {
      v8 = SHGetDesktopFolder(&ppshf);
      v5 = (ITEMIDLIST *)pv;
      goto LABEL_6;
    }
    v5 = (ITEMIDLIST *)pv;
  }
  ppidl = 0;
  SHGetDesktopFolder((IShellFolder **)&ppidl);
  v13 = (*(int (__stdcall **)(LPITEMIDLIST, LPITEMIDLIST, _DWORD, const IID *, IShellFolder **))(*(_DWORD *)&ppidl->mkid.cb
                                                                                               + 20))(
          ppidl,
          v6,
          0,
          &stru_4BD7FC,
          &ppshf);
  (*(void (__stdcall **)(LPITEMIDLIST))(*(_DWORD *)&ppidl->mkid.cb + 8))(ppidl);
  v8 = v13;
LABEL_6:
  if ( v8 >= 0 )
  {
    v16 = 0;
    if ( ppshf->lpVtbl->GetUIObjectOf(
           ppshf,
           0,
           1,
           (LPCITEMIDLIST *)&ID,
           (const IID *const)dword_4BD9FC,
           0,
           (void **)&v16) >= 0 )
    {
      sub_462DB0((int **)v10, v5, v16, this);
      v19 = 0;
      sub_463280(hMenu, *(_DWORD *)(this + 3416), *(HWND *)(this + 52), v10, a2);
      (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
      v19 = -1;
      sub_462C80(v10);
      v5 = (ITEMIDLIST *)pv;
      v6 = v11;
    }
    ppshf->lpVtbl->Release(ppshf);
  }
  CoTaskMemFree(v6);
  CoTaskMemFree(v5);
  return DestroyMenu(hMenu);
}
// 4BD9FC: using guessed type _DWORD dword_4BD9FC[4];

//----- (0049E480) --------------------------------------------------------
void __usercall sub_49E480(LONG *a1@<ebx>, int a2@<edi>)
{
  LONG v2; // edx
  HWND v3; // ecx
  HWND v4; // [esp-8h] [ebp-58h]
  LPARAM lParam[13]; // [esp+4h] [ebp-4Ch] BYREF
  struct tagPOINT Point; // [esp+38h] [ebp-18h] BYREF
  char v7; // [esp+40h] [ebp-10h]
  WPARAM wParam; // [esp+44h] [ebp-Ch]

  SetForegroundWindow(*(HWND *)(a2 + 52));
  if ( (GetKeyState(16) & 0x80u) != 0 && (GetKeyState(17) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
  {
    v2 = a1[1];
    Point.x = *a1;
    v4 = *(HWND *)(a2 + 3432);
    Point.y = v2;
    ScreenToClient(v4, &Point);
    SendMessageW(*(HWND *)(a2 + 3432), 0x1012u, 0, (LPARAM)&Point);
    if ( (v7 & 1) == 0 && wParam != -1 && SendMessageW(*(HWND *)(a2 + 3432), 0x102Cu, wParam, 2) != 2 )
    {
      sub_469710(*(HWND *)(a2 + 3432));
      v3 = *(HWND *)(a2 + 3432);
      lParam[4] = 2;
      lParam[3] = 2;
      SendMessageW(v3, 0x102Bu, wParam, (LPARAM)lParam);
    }
  }
  if ( SendMessageW(*(HWND *)(a2 + 3432), 0x1032u, 0, 0) )
    sub_49E070(a2, (int)a1);
  else
    sub_49E2E0(a2, (int)a1);
}

//----- (0049E5A0) --------------------------------------------------------
int __fastcall sub_49E5A0(int a1, int a2)
{
  const WCHAR *v4; // eax
  const WCHAR *v5; // edi
  WCHAR *v6; // eax
  int v7; // edx
  WCHAR v8; // cx
  WCHAR *v9; // eax
  int v10; // edx
  WCHAR v11; // cx
  int v12; // ecx
  const WCHAR *v13; // eax
  LPWSTR ExtensionW; // eax
  int v15; // ecx
  int *v16; // eax
  int v17; // eax
  int v18; // esi
  int v19; // edi
  void *v21[3]; // [esp+14h] [ebp-DA4h] BYREF
  int v22; // [esp+20h] [ebp-D98h]
  int v23[7]; // [esp+24h] [ebp-D94h] BYREF
  _DWORD v24[7]; // [esp+40h] [ebp-D78h] BYREF
  _DWORD v25[7]; // [esp+5Ch] [ebp-D5Ch] BYREF
  WCHAR Text[256]; // [esp+78h] [ebp-D40h] BYREF
  WCHAR Caption[256]; // [esp+278h] [ebp-B40h] BYREF
  char v28[520]; // [esp+478h] [ebp-940h] BYREF
  WCHAR pszPath[264]; // [esp+680h] [ebp-738h] BYREF
  WCHAR Buffer[128]; // [esp+890h] [ebp-528h] BYREF
  WCHAR pszMore[260]; // [esp+990h] [ebp-428h] BYREF
  WCHAR v32[264]; // [esp+B98h] [ebp-220h] BYREF
  int v33; // [esp+DB4h] [ebp-4h]

  *(_DWORD *)(a1 + 60608) = 0;
  v4 = *(const WCHAR **)(a2 + 32);
  v22 = a1;
  if ( !v4 )
    return 0;
  if ( !lstrcmpW(v4, &word_4CB0B0) )
    return 0;
  v5 = *(const WCHAR **)(a2 + 32);
  if ( v5[lstrlenW(v5) - 1] == 46 )
    return 0;
  if ( StrChrW(v5, 0x5Cu)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x2Fu)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x3Au)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x2Au)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x3Fu)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x22u)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x3Cu)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x3Eu)
    || StrChrW(*(PCWSTR *)(a2 + 32), 0x7Cu) )
  {
    LoadStringW(hInstance, 0x200Fu, Text, 256);
    LoadStringW(hInstance, 0x2010u, Caption, 256);
    MessageBoxW(*(HWND *)(a1 + 52), Text, Caption, 0x10u);
    return 0;
  }
  (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a1 + 1320) + 52))(*(_DWORD *)(a1 + 1320), 260, v28);
  v6 = v32;
  v7 = 261;
  while ( v7 != -2147483385 )
  {
    v8 = *(v6 - 912);
    if ( !v8 )
      break;
    *v6++ = v8;
    if ( !--v7 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  v9 = pszPath;
  v10 = 261;
  while ( v10 != -2147483385 )
  {
    v11 = *(v9 - 260);
    if ( !v11 )
      break;
    *v9++ = v11;
    if ( !--v10 )
    {
      --v9;
      break;
    }
  }
  v12 = *(_DWORD *)(a1 + 1320);
  *v9 = 0;
  (*(void (__thiscall **)(int, _DWORD, WCHAR *))(*(_DWORD *)v12 + 44))(v12, *(_DWORD *)(a2 + 16), pszMore);
  PathAppendW(pszPath, pszMore);
  if ( !PathAppendW(v32, *(LPCWSTR *)(a2 + 32)) )
    return 0;
  if ( ((*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(a1 + 1320) + 124))(
          *(_DWORD *)(a1 + 1320),
          *(_DWORD *)(a2 + 16)) & 0x10) == 0 )
  {
    if ( !*(_DWORD *)(a1 + 59484)
      || *(_DWORD *)(a1 + 59512) && (v13 = PathFindExtensionW(pszMore), !lstrcmpiW(v13, L".lnk")) )
    {
      ExtensionW = PathFindExtensionW(pszMore);
      if ( *ExtensionW == 46 )
        sub_401060(v32, 0x105u, (int)ExtensionW);
    }
  }
  v24[5] = 7;
  v25[5] = 7;
  v24[4] = 0;
  LOWORD(v24[0]) = 0;
  v25[4] = 0;
  LOWORD(v25[0]) = 0;
  v33 = 0;
  sub_40ABC0((int)v24, pszPath, v24);
  sub_40ABC0(v15, v32, v25);
  sub_4095E0(v23, L" ");
  LOBYTE(v33) = 1;
  v16 = (int *)v23[0];
  if ( v23[5] < 8u )
    v16 = v23;
  v17 = sub_418FD0(v23[4], (char *)v25, v16);
  sub_409050(v25, v17 + 1, 0xFFFFFFFF);
  LOBYTE(v33) = 0;
  sub_409000((int)v23);
  sub_40AEB0(v21);
  LOBYTE(v33) = 2;
  sub_40AF30((int)v24, (int)v21);
  v18 = v22;
  v19 = sub_463A50((char ***)v21, v22 + 59552);
  if ( !v19 )
  {
    LoadStringW(hInstance, 0x1F71u, Buffer, 128);
    MessageBoxW(*(HWND *)(v18 + 52), Buffer, L"Explorer++", 0x30u);
  }
  sub_40B060((int)v21);
  operator delete(v21[0]);
  sub_409920((int)v24);
  return v19;
}
// 49E700: conditional instruction was optimized away because edx.4!=0
// 49E740: conditional instruction was optimized away because edx.4!=0
// 49E846: variable 'v15' is possibly undefined
// 4CB0C0: using guessed type wchar_t asc_4CB0C0[2];
// 49E5A0: using guessed type char var_940[520];

//----- (0049E9B0) --------------------------------------------------------
int __thiscall sub_49E9B0(int this, int a2)
{
  ITEMIDLIST *v4; // esi
  HWND v5; // esi
  HCURSOR CursorW; // eax
  _DWORD *v7; // eax
  int v8; // edx
  HWND v9; // edi
  HCURSOR v10; // eax
  _DWORD *v11; // eax
  HWND v12; // eax
  int v13; // edx
  WPARAM i; // esi
  int v15; // edi
  char *v16; // eax
  int v17; // ecx
  HCURSOR v18; // eax
  UINT v19; // [esp-Ch] [ebp-480h] BYREF
  WPARAM v20; // [esp-8h] [ebp-47Ch]
  int v21; // [esp-4h] [ebp-478h]
  int pExceptionObject[3]; // [esp+10h] [ebp-464h] BYREF
  UINT *v23; // [esp+1Ch] [ebp-458h]
  char *v24; // [esp+20h] [ebp-454h] BYREF
  void *v25; // [esp+24h] [ebp-450h] BYREF
  int v26; // [esp+28h] [ebp-44Ch]
  LPDATAOBJECT v27; // [esp+30h] [ebp-444h] BYREF
  void *v28[5]; // [esp+34h] [ebp-440h] BYREF
  unsigned int v29; // [esp+48h] [ebp-42Ch]
  WCHAR pszPath[260]; // [esp+50h] [ebp-424h] BYREF
  unsigned __int16 Src; // [esp+258h] [ebp-21Ch] BYREF
  __int16 v32; // [esp+25Ah] [ebp-21Ah] BYREF
  int v33; // [esp+470h] [ebp-4h]

  switch ( *(_WORD *)(a2 + 12) )
  {
    case 8:
      if ( (GetKeyState(17) & 0x80u) == 0 || (GetKeyState(16) & 0x80u) != 0 || (GetKeyState(18) & 0x80u) != 0 )
      {
        sub_490550(this);
      }
      else
      {
        v4 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 1320) + 56))(*(_DWORD *)(this + 1320));
        sub_466630(v4, pszPath, 0x8000);
        PathStripToRootW(pszPath);
        sub_490020((int)pszPath, this, 1);
        CoTaskMemFree(v4);
      }
      return 0;
    case 0xD:
      v21 = (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0;
      sub_4948B0(this, v21);
      return 0;
    case 0x2E:
      if ( (GetKeyState(16) & 0x80u) == 0 )
        sub_49D950(this, 0);
      else
        sub_49D950(this, (void *)1);
      return 0;
    case 0x41:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v5 = *(HWND *)(this + 3432);
        *(_DWORD *)(this + 60556) = 1;
        sub_469760(v5);
        SetFocus(*(HWND *)(this + 3432));
      }
      return 0;
    case 0x43:
      if ( (GetKeyState(17) & 0x80u) == 0 )
        return 0;
      if ( (GetKeyState(16) & 0x80u) != 0 )
        return 0;
      if ( (GetKeyState(18) & 0x80u) != 0 )
        return 0;
      v27 = 0;
      if ( !sub_494670((_DWORD *)this) )
        return 0;
      CursorW = LoadCursorW(0, (LPCWSTR)0x7F02);
      SetCursor(CursorW);
      v26 = 0;
      v7 = operator new(0x24u);
      if ( !v7 )
        goto LABEL_29;
      *v7 = v7;
      v25 = v7;
      v7[1] = v7;
      v33 = 0;
      sub_49CB90(*(HWND *)(this + 3432), this, (int)&v25);
      v23 = &v19;
      sub_40AC30((char ***)&v19, (int **)&v25);
      if ( sub_4AE6E0(&v27, (void *)v19) >= 0 )
        *(_DWORD *)(this + 60584) = v27;
      v21 = 32512;
      v20 = 0;
      break;
    case 0x49:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v8 = *(_DWORD *)(this + 60572);
        v9 = *(HWND *)(this + 3432);
        *(_DWORD *)(this + 60564) = 1;
        *(_DWORD *)(this + 60576) = v8;
        sub_469690(v9);
        SetFocus(*(HWND *)(this + 3432));
      }
      return 0;
    case 0x56:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_49CDA0((char *)this);
      return 0;
    case 0x58:
      if ( (GetKeyState(17) & 0x80u) == 0 )
        return 0;
      if ( (GetKeyState(16) & 0x80u) != 0 )
        return 0;
      if ( (GetKeyState(18) & 0x80u) != 0 )
        return 0;
      v27 = 0;
      if ( !sub_494670((_DWORD *)this) )
        return 0;
      v10 = LoadCursorW(0, (LPCWSTR)0x7F02);
      SetCursor(v10);
      v26 = 0;
      v11 = operator new(0x24u);
      if ( !v11 )
      {
LABEL_29:
        v24 = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v24);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      *v11 = v11;
      v25 = v11;
      v11[1] = v11;
      v33 = 2;
      sub_49CB90(*(HWND *)(this + 3432), this, (int)&v25);
      v23 = &v19;
      sub_40AC30((char ***)&v19, (int **)&v25);
      if ( sub_4AE660(&v27, (void *)v19) >= 0 )
      {
        v12 = *(HWND *)(this + 3432);
        v13 = *(_DWORD *)(this + 5620);
        v21 = 2;
        v20 = -1;
        v19 = 4108;
        *(_DWORD *)(this + 60584) = v27;
        *(_DWORD *)(this + 61240) = v13;
        for ( i = SendMessageW(v12, v19, v20, v21); i != -1; i = SendMessageW(*(HWND *)(this + 3432), 0x100Cu, i, 2) )
        {
          (*(void (__thiscall **)(_DWORD, WPARAM, int, unsigned __int16 *))(**(_DWORD **)(this + 1320) + 64))(
            *(_DWORD *)(this + 1320),
            i,
            260,
            &Src);
          LOWORD(v28[0]) = 0;
          v29 = 7;
          v28[4] = 0;
          sub_4094F0(v28, (int)&v32, &Src, wcslen(&Src));
          LOBYTE(v33) = 3;
          v15 = *(_DWORD *)(this + 61228);
          v16 = sub_40A200((char *)v15, *(_DWORD *)(v15 + 4), (int)v28);
          v17 = *(_DWORD *)(this + 61232);
          if ( v17 == 153391688 )
            std::_Xlength_error("list<T> too long");
          *(_DWORD *)(this + 61232) = v17 + 1;
          *(_DWORD *)(v15 + 4) = v16;
          **((_DWORD **)v16 + 1) = v16;
          LOBYTE(v33) = 2;
          if ( v29 >= 8 )
            operator delete(v28[0]);
          (*(void (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(this + 1320) + 188))(*(_DWORD *)(this + 1320), i);
        }
      }
      v21 = 32512;
      v20 = 0;
      break;
    default:
      return 0;
  }
  v18 = LoadCursorW((HINSTANCE)v20, (LPCWSTR)v21);
  SetCursor(v18);
  sub_40A140((int)&v25);
  operator delete(v25);
  return 0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (0049EF70) --------------------------------------------------------
LRESULT __fastcall sub_49EF70(int a1, HWND a2, UINT Msg, WPARAM wParam, unsigned int lParam)
{
  int v7; // eax
  int v9; // ecx
  int v10; // edx
  int *i; // eax
  LONG v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int *j; // edi
  char **v17; // eax
  bool v18; // zf
  DWORD v19; // eax
  DWORD MessagePos; // eax
  int v21; // ecx
  HDC DC; // esi
  int v23; // eax
  HWND v24; // [esp-10h] [ebp-2F4h]
  HWND v25; // [esp-10h] [ebp-2F4h]
  HWND v26; // [esp-10h] [ebp-2F4h]
  HWND v27; // [esp-10h] [ebp-2F4h]
  HWND v28; // [esp-Ch] [ebp-2F0h]
  HWND v29; // [esp-8h] [ebp-2ECh]
  struct tagPOINT Points; // [esp+14h] [ebp-2D0h] BYREF
  int v31; // [esp+1Ch] [ebp-2C8h] BYREF
  int **v32; // [esp+20h] [ebp-2C4h] BYREF
  int v33; // [esp+24h] [ebp-2C0h]
  HWND hWnd; // [esp+2Ch] [ebp-2B8h] BYREF
  struct tagPOINT Point; // [esp+30h] [ebp-2B4h] BYREF
  struct tagSIZE psizl; // [esp+38h] [ebp-2ACh] BYREF
  int v37; // [esp+40h] [ebp-2A4h]
  LPARAM v38[8]; // [esp+44h] [ebp-2A0h] BYREF
  struct tagPOINT v39; // [esp+64h] [ebp-280h]
  POINT v40; // [esp+78h] [ebp-26Ch] BYREF
  int v41; // [esp+80h] [ebp-264h]
  WPARAM v42; // [esp+84h] [ebp-260h]
  RECT v43; // [esp+8Ch] [ebp-258h] BYREF
  struct tagPOINT v44; // [esp+9Ch] [ebp-248h] BYREF
  int v45; // [esp+A4h] [ebp-240h]
  LPARAM v46[2]; // [esp+B0h] [ebp-234h] BYREF
  char v47; // [esp+B8h] [ebp-22Ch]
  WCHAR String[262]; // [esp+C4h] [ebp-220h] BYREF
  int v49; // [esp+2E0h] [ebp-4h]

  hWnd = a2;
  Points.x = lParam;
  if ( Msg > 0x200 )
  {
    switch ( Msg )
    {
      case 0x201u:
        return sub_49BBF0(wParam, lParam, a1);
      case 0x203u:
        MessagePos = GetMessagePos();
        Point.x = (__int16)MessagePos;
        v29 = *(HWND *)(a1 + 3432);
        Point.y = SHIWORD(MessagePos);
        ScreenToClient(v29, &Point);
        v44 = Point;
        SendMessageW(a2, 0x1012u, 0, (LPARAM)&v44);
        if ( v45 != 1 )
          return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        sub_490550(a1);
        return 0;
      case 0x204u:
        if ( (wParam & 2) == 0 || (wParam & 0x11) != 0 )
          return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        v40.x = (unsigned __int16)lParam;
        v25 = *(HWND *)(a1 + 3432);
        v40.y = HIWORD(lParam);
        SendMessageW(v25, 0x1012u, 0, (LPARAM)&v40);
        v21 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516);
        (*(void (__thiscall **)(int, int *))(*(_DWORD *)v21 + 24))(v21, &v31);
        if ( v31 != 3 )
          goto LABEL_49;
        if ( (v41 & 1) == 0 )
        {
          if ( v42 != -1 )
          {
            v26 = *(HWND *)(a1 + 3432);
            v43.left = 2;
            SendMessageW(v26, 0x100Eu, v42, (LPARAM)&v43);
            v38[5] = (LPARAM)String;
            v27 = *(HWND *)(a1 + 3432);
            v38[2] = 0;
            v38[6] = 260;
            SendMessageW(v27, 0x1073u, v42, (LPARAM)v38);
            DC = GetDC(*(HWND *)(a1 + 3432));
            v23 = lstrlenW(String);
            GetTextExtentPoint32W(DC, String, v23, &psizl);
            ReleaseDC(*(HWND *)(a1 + 3432), DC);
            v43.right = v43.left + psizl.cx;
            if ( !PtInRect(&v43, v40) )
              *(_DWORD *)(a1 + 61316) = 1;
          }
LABEL_49:
          if ( (v41 & 1) == 0 )
            *(_DWORD *)(a1 + 60600) = 1;
        }
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
      case 0x205u:
        *(_DWORD *)(a1 + 60596) = 0;
        *(_DWORD *)(a1 + 60600) = 0;
        *(_DWORD *)(a1 + 61316) = 0;
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
      case 0x207u:
        sub_49BB50(a1, lParam);
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
      case 0x208u:
        sub_49C160(a1, lParam);
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
      case 0x20Au:
        if ( !sub_479400(lParam, a1, wParam, 0) )
          return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        return 0;
      default:
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
    }
  }
  if ( Msg == 512 )
  {
    v18 = *(_DWORD *)(a1 + 60592) == 0;
    *(_DWORD *)(a1 + 61316) = 0;
    if ( v18 && !*(_DWORD *)(a1 + 60596) )
    {
      if ( *(_DWORD *)(a1 + 60600) )
      {
        if ( (wParam & 2) != 0 && (wParam & 0x11) == 0 )
        {
          v19 = GetMessagePos();
          Points.x = (__int16)v19;
          v28 = *(HWND *)(a1 + 3432);
          Points.y = SHIWORD(v19);
          MapWindowPoints(0, v28, &Points, 1u);
          v46[0] = Points.x;
          v24 = *(HWND *)(a1 + 3432);
          v46[1] = Points.y;
          SendMessageW(v24, 0x1012u, 0, (LPARAM)v46);
          if ( (v47 & 1) == 0 )
          {
            if ( SendMessageW(*(HWND *)(a1 + 3432), 0x1032u, 0, 0) )
            {
              v39 = Points;
              v38[3] = 0;
              if ( sub_49DB50(a1, (int)v38, (struct IDropSourceVtbl *)1) == (LPDATAOBJECT)262401 )
                *(_DWORD *)(a1 + 60596) = 1;
            }
          }
        }
      }
    }
    return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  if ( Msg == 7 )
  {
    *(_DWORD *)(a1 + 3436) = a2;
    sub_49B450(a1);
    return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 78 )
  {
    if ( Msg == 287 )
      SendMessageW(*(HWND *)(a1 + 52), 0x11Fu, wParam, lParam);
    return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  v7 = *(_DWORD *)(lParam + 8);
  if ( v7 != -311 )
  {
    if ( v7 == -310 )
      return 0;
    return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  sub_40A410(&v32);
  v49 = 0;
  (*(void (__thiscall **)(_DWORD, int ***))(**(_DWORD **)(a1 + 1320) + 312))(*(_DWORD *)(a1 + 1320), &v32);
  v9 = *(_DWORD *)(lParam + 12) + 1;
  v10 = 0;
  for ( i = *v32; v10 < v9; i = (int *)*i )
  {
    if ( i == (int *)v32 )
      break;
    if ( i[3] )
      ++v10;
  }
  if ( i != *v32 )
    i = (int *)i[1];
  v12 = i[3];
  psizl.cx = i[2];
  v13 = i[4];
  psizl.cy = v12;
  v37 = v13;
  sub_40ABF0(&hWnd, (int)&v32, i);
  v14 = *(_DWORD *)(*(_DWORD *)(Points.x + 20) + 32) + 1;
  v15 = 0;
  for ( j = *v32; v15 < v14; j = (int *)*j )
  {
    if ( j == (int *)v32 )
      break;
    if ( j[3] )
      ++v15;
  }
  if ( j != *v32 )
    j = (int *)j[1];
  v17 = sub_41EEB0((char **)&psizl, (char *)j, j[1]);
  if ( v33 == 357913940 )
    std::_Xlength_error("list<T> too long");
  ++v33;
  j[1] = (int)v17;
  *(_DWORD *)v17[1] = v17;
  (*(void (__thiscall **)(_DWORD, int ***, int))(**(_DWORD **)(a1 + 1320) + 316))(*(_DWORD *)(a1 + 1320), &v32, 1);
  (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)(a1 + 28) + 16))(a1 + 28, *(_DWORD *)(a1 + 5620));
  sub_41ECB0((void **)&v32);
  return 1;
}

//----- (0049F510) --------------------------------------------------------
LRESULT __stdcall sub_49F510(HWND hWnd, int a2, int a3, int a4)
{
  int *WindowLongW; // eax

  WindowLongW = (int *)GetWindowLongW(hWnd, -21);
  return sub_49EF70(*WindowLongW, hWnd, a2, a3, a4);
}

//----- (0049F540) --------------------------------------------------------
LONG __usercall sub_49F540@<eax>(int a1@<eax>, int a2@<ebx>)
{
  LONG result; // eax
  int v4; // edi
  unsigned int v5; // eax
  HWND v6; // eax
  HWND v7; // edx
  _DWORD *v8; // ecx
  _DWORD *v9; // eax
  HWND v10; // eax
  HWND v11; // [esp-10h] [ebp-50h]
  HWND v12; // [esp-10h] [ebp-50h]
  HWND v13; // [esp-10h] [ebp-50h]
  HWND v14; // [esp-10h] [ebp-50h]
  WPARAM v15; // [esp-8h] [ebp-48h]
  WPARAM v16; // [esp-8h] [ebp-48h]
  WPARAM v17; // [esp-8h] [ebp-48h]
  WPARAM v18; // [esp-8h] [ebp-48h]
  LPARAM lParam[3]; // [esp+8h] [ebp-38h] BYREF
  int v20; // [esp+14h] [ebp-2Ch]
  int v21; // [esp+18h] [ebp-28h]
  int v22; // [esp+3Ch] [ebp-4h]

  result = GetWindowLongW(*(HWND *)a2, -21);
  v4 = *(_DWORD *)(result + 4);
  if ( v4 < 100 && *(_DWORD *)(a1 + 4 * v4 + 58872) == 1 && v4 != -1 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4 * v4 + 916) + 276))(*(_DWORD *)(a1 + 4 * v4 + 916));
    if ( !result )
    {
      if ( *(_DWORD *)(a2 + 28) == 8 && (*(_DWORD *)(a2 + 20) & 0xF000) != 0 && (*(_DWORD *)(a2 + 24) & 0xF000) != 0 )
      {
        v5 = SendMessageW(*(HWND *)(a1 + 4 * v4 + 92), 0x102Cu, *(_DWORD *)(a2 + 12), 61440);
        v15 = *(_DWORD *)(a2 + 12);
        if ( v5 >> 12 == 1 )
        {
          v11 = *(HWND *)(a1 + 4 * v4 + 92);
          v21 = 2;
          v20 = 0;
          return SendMessageW(v11, 0x102Bu, v15, (LPARAM)lParam);
        }
        else
        {
          v21 = 2;
          v20 = 2;
          return SendMessageW(*(HWND *)(a1 + 4 * v4 + 92), 0x102Bu, v15, (LPARAM)lParam);
        }
      }
      result = *(_DWORD *)(a2 + 20) & 2;
      if ( !result || (*(_BYTE *)(a2 + 24) & 2) == 0 )
      {
        if ( result )
        {
          v16 = *(_DWORD *)(a2 + 12);
          v12 = *(HWND *)(a1 + 4 * v4 + 92);
          v22 = 1;
          if ( (unsigned int)SendMessageW(v12, 0x102Cu, v16, 61440) >> 12 != 1 )
          {
LABEL_20:
            v8 = *(_DWORD **)(a1 + 60456);
            v9 = (_DWORD *)*v8;
            if ( (_DWORD *)*v8 != v8 )
            {
              do
              {
                if ( v9[3] == v4 )
                  v9[4] = 0;
                v9 = (_DWORD *)*v9;
              }
              while ( v9 != *(_DWORD **)(a1 + 60456) );
            }
            if ( v4 == *(_DWORD *)(a1 + 5620) )
            {
              if ( v22 )
              {
                v10 = *(HWND *)(a1 + 3432);
                ++*(_DWORD *)(a1 + 60572);
                if ( *(_DWORD *)(a1 + 60572) == SendMessageW(v10, 0x1004u, 0, 0) )
                  *(_DWORD *)(a1 + 60556) = 0;
              }
              else if ( (int)--*(_DWORD *)(a1 + 60572) <= 1 )
              {
                *(_DWORD *)(a1 + 60560) = 0;
              }
            }
            (*(void (__thiscall **)(_DWORD, _DWORD, int))(**(_DWORD **)(a1 + 4 * v4 + 916) + 20))(
              *(_DWORD *)(a1 + 4 * v4 + 916),
              *(_DWORD *)(a2 + 40),
              v22);
            result = SendMessageW(*(HWND *)(a1 + 3432), 0x1004u, 0, 0) - *(_DWORD *)(a1 + 60572);
            if ( result == *(_DWORD *)(a1 + 60576) )
              *(_DWORD *)(a1 + 60564) = 0;
            if ( !*(_DWORD *)(a1 + 60556) && !*(_DWORD *)(a1 + 60560) && !*(_DWORD *)(a1 + 60564) )
            {
              sub_496B80(a1);
              sub_496BE0(a1);
              return sub_49B450(a1);
            }
            return result;
          }
          v6 = *(HWND *)(a1 + 4 * v4 + 92);
          v17 = *(_DWORD *)(a2 + 12);
          v20 = 0x2000;
          v13 = v6;
        }
        else
        {
          if ( (*(_BYTE *)(a2 + 24) & 2) == 0 )
            return result;
          v18 = *(_DWORD *)(a2 + 12);
          v14 = *(HWND *)(a1 + 4 * v4 + 92);
          v22 = 0;
          if ( (unsigned int)SendMessageW(v14, 0x102Cu, v18, 61440) >> 12 == 1 )
            goto LABEL_20;
          v7 = *(HWND *)(a1 + 4 * v4 + 92);
          v17 = *(_DWORD *)(a2 + 12);
          v20 = 4096;
          v13 = v7;
        }
        v21 = 61440;
        SendMessageW(v13, 0x102Bu, v17, (LPARAM)lParam);
        goto LABEL_20;
      }
    }
  }
  return result;
}

//----- (0049F7B0) --------------------------------------------------------
int __stdcall sub_49F7B0(int a1, int a2)
{
  return 262402;
}

//----- (0049F7C0) --------------------------------------------------------
int __stdcall sub_49F7C0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx

  v3 = *(_DWORD *)(a1 + 8);
  v4 = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( (a3 & 2) == 0 )
        return 262400;
      v4 = *(_DWORD *)(a1 + 8);
    }
  }
  else
  {
    if ( (a3 & 1) == 0 )
      return 262400;
    v4 = 2;
  }
  if ( a2 == 1 || (v4 & a3) != 0 )
    return 262401;
  else
    return 0;
}

//----- (0049F810) --------------------------------------------------------
LONG __stdcall sub_49F810(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 + 4));
}

//----- (0049F840) --------------------------------------------------------
LONG __stdcall sub_49F840(void *a1)
{
  LONG result; // eax

  result = InterlockedDecrement((volatile LONG *)a1 + 1);
  if ( !result )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = &CDropSource::`vftable';
      operator delete(a1);
    }
    return 0;
  }
  return result;
}
// 4CBDF4: using guessed type void *CDropSource::`vftable';

//----- (0049F8D0) --------------------------------------------------------
int __stdcall sub_49F8D0(int a1, _DWORD *a2, _DWORD *a3)
{
  *a3 = 0;
  if ( !sub_40AA20(dword_4BD93C, a2) && !sub_40AA20(&stru_4BD95C, a2) )
    return -2147467262;
  *a3 = a1;
  if ( !a1 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}
// 4BD93C: using guessed type _DWORD dword_4BD93C[4];

//----- (0049F930) --------------------------------------------------------
int __thiscall sub_49F930(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (0049F940) --------------------------------------------------------
int __thiscall sub_49F940(HWND *this, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 8);
  if ( (v2 == -4 || v2 == -2) && *(HWND *)a2 == GetDlgItem(this[1], 1315) )
    ShellExecuteW(0, L"open", (LPCWSTR)(a2 + 124), 0, 0, 5);
  return 0;
}

//----- (0049F990) --------------------------------------------------------
int __thiscall sub_49F990(HWND *this, __int16 a2, int a3)
{
  if ( a2 == 1 )
  {
    EndDialog(this[1], 1);
  }
  else if ( a2 == 2 )
  {
    EndDialog(this[1], 0);
    return 0;
  }
  return 0;
}

//----- (0049F9C0) --------------------------------------------------------
int __thiscall sub_49F9C0(_DWORD *this)
{
  HWND v1; // edi
  HWND Parent; // eax

  v1 = (HWND)this[1];
  Parent = GetParent(v1);
  sub_4697F0(v1, Parent);
  return 1;
}

//----- (0049F9E0) --------------------------------------------------------
void __usercall sub_49F9E0(_DWORD *a1@<eax>)
{
  void *v1; // esi

  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0049FA00) --------------------------------------------------------
int __usercall sub_49FA00@<eax>(int result@<eax>, int a2@<edx>)
{
  *(_DWORD *)(result + 8) = hInstance;
  *(_DWORD *)(result + 12) = 239;
  *(_DWORD *)(result + 16) = a2;
  *(_BYTE *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)result = &CHelpFileMissingDialog::`vftable';
  return result;
}
// 4CBDBC: using guessed type void *CHelpFileMissingDialog::`vftable';

//----- (0049FA40) --------------------------------------------------------
int __thiscall sub_49FA40(HICON *this)
{
  DestroyIcon(this[13]);
  return 0;
}

//----- (0049FA50) --------------------------------------------------------
int __thiscall sub_49FA50(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (0049FA60) --------------------------------------------------------
int __thiscall sub_49FA60(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 56);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 56) + 4) = 1;
  return result;
}

//----- (0049FAC0) --------------------------------------------------------
void __usercall sub_49FAC0(_DWORD *a1@<eax>)
{
  void *v1; // esi

  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (0049FAE0) --------------------------------------------------------
char **__stdcall sub_49FAE0(_DWORD *a1, char **a2)
{
  char *v2; // ebx
  char **v3; // eax
  char *v4; // ecx
  char *v5; // ebx
  char **v6; // eax
  char *v7; // ecx
  char *v8; // ebx
  char **v9; // eax
  char *v10; // ecx
  char *v11; // ebx
  char **result; // eax
  char *v13; // ecx
  char *v14; // [esp-8h] [ebp-20h]
  char *v15; // [esp-8h] [ebp-20h]
  char *v16; // [esp-8h] [ebp-20h]
  char *v17; // [esp-8h] [ebp-20h]
  int v18; // [esp-4h] [ebp-1Ch]
  int v19; // [esp-4h] [ebp-1Ch]
  int v20; // [esp-4h] [ebp-1Ch]
  int v21; // [esp-4h] [ebp-1Ch]
  int v22; // [esp+Ch] [ebp-Ch] BYREF
  int v23; // [esp+10h] [ebp-8h]
  int v24; // [esp+14h] [ebp-4h]

  *a1 = 1;
  v2 = *a2;
  v18 = *((_DWORD *)*a2 + 1);
  v14 = *a2;
  v22 = 1112;
  v23 = 1;
  v24 = 1;
  v3 = sub_41EEB0((char **)&v22, v14, v18);
  v4 = a2[1];
  if ( v4 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v4 + 1;
  *((_DWORD *)v2 + 1) = v3;
  *(_DWORD *)v3[1] = v3;
  v5 = *a2;
  v19 = *((_DWORD *)*a2 + 1);
  v15 = *a2;
  v22 = 1;
  v23 = 0;
  v24 = 0;
  v6 = sub_41EEB0((char **)&v22, v15, v19);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v5 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v8 = *a2;
  v20 = *((_DWORD *)*a2 + 1);
  v16 = *a2;
  v22 = 2;
  v23 = 0;
  v24 = 0;
  v9 = sub_41EEB0((char **)&v22, v16, v20);
  v10 = a2[1];
  if ( v10 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v10 + 1;
  *((_DWORD *)v8 + 1) = v9;
  *(_DWORD *)v9[1] = v9;
  v11 = *a2;
  v21 = *((_DWORD *)*a2 + 1);
  v17 = *a2;
  v22 = 1304;
  v23 = 0;
  v24 = 0;
  result = sub_41EEB0((char **)&v22, v17, v21);
  v13 = a2[1];
  if ( v13 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v13 + 1;
  *((_DWORD *)v11 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (0049FC40) --------------------------------------------------------
int *sub_49FC40()
{
  _DWORD *v0; // eax
  int pExceptionObject[4]; // [esp+4h] [ebp-20h] BYREF
  char *v3[4]; // [esp+14h] [ebp-10h] BYREF

  pExceptionObject[3] = (int)&dword_4F1FE0;
  sub_4653E0((int)&dword_4F1FE0, (int)L"Filter");
  v3[3] = 0;
  dword_4F1FE0 = (int)&CFilterDialogPersistentSettings::`vftable';
  dword_4F2200 = 0;
  v0 = operator new(0x24u);
  if ( !v0 )
  {
    v3[0] = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4F21FC = v0;
  *v0 = v0;
  *((_DWORD *)dword_4F21FC + 1) = dword_4F21FC;
  return &dword_4F1FE0;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CB1B8: using guessed type wchar_t aFilter_4[7];
// 4CBDA4: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F2200: using guessed type int dword_4F2200;

//----- (0049FCF0) --------------------------------------------------------
int *sub_49FCF0()
{
  if ( (dword_4F222C & 1) == 0 )
  {
    dword_4F222C |= 1u;
    sub_49FC40();
    atexit(sub_4BCCA0);
  }
  return &dword_4F1FE0;
}
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F222C: using guessed type int dword_4F222C;

//----- (0049FD60) --------------------------------------------------------
int __fastcall sub_49FD60(int a1, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)(a3 + 8) = hInstance;
  *(_DWORD *)(a3 + 16) = a1;
  *(_DWORD *)(a3 + 12) = 139;
  *(_BYTE *)(a3 + 28) = 1;
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)a3 = &CFilterDialog::`vftable';
  *(_DWORD *)(a3 + 48) = a2;
  if ( (dword_4F222C & 1) == 0 )
  {
    dword_4F222C |= 1u;
    sub_49FC40();
    atexit(sub_4BCCA0);
  }
  result = a3;
  *(_DWORD *)(a3 + 56) = &dword_4F1FE0;
  return result;
}
// 4CBD6C: using guessed type void *CFilterDialog::`vftable';
// 4F1FE0: using guessed type int dword_4F1FE0;
// 4F222C: using guessed type int dword_4F222C;

//----- (0049FE00) --------------------------------------------------------
void __thiscall sub_49FE00(_DWORD **this, int a2, int a3)
{
  sub_464E30((int)L"Filter", a3, a2, this + 135);
}
// 4CB1E8: using guessed type wchar_t aFilter_5[7];

//----- (0049FE30) --------------------------------------------------------
LSTATUS __thiscall sub_49FE30(_DWORD **this, HKEY a2)
{
  return sub_464130(a2, this + 135);
}

//----- (0049FE50) --------------------------------------------------------
int __thiscall sub_49FE50(int this)
{
  int v2; // edi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  LONG v5; // eax
  HWND DlgItem; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // ebx
  LPARAM *v9; // eax
  int v10; // eax
  int v11; // eax
  HWND v12; // edi
  _DWORD *v13; // esi
  HWND Parent; // eax
  _DWORD *i; // [esp+Ch] [ebp-424h]
  LPARAM lParam[5]; // [esp+10h] [ebp-420h] BYREF
  unsigned int v18; // [esp+24h] [ebp-40Ch]
  LPARAM v19[256]; // [esp+2Ch] [ebp-404h] BYREF

  v2 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v2, (int)BitmapW, 0);
  v5 = sub_409F80(v2, 26, 0);
  *(_DWORD *)(this + 52) = v5;
  SetClassLongW(*(HWND *)(this + 4), -34, v5);
  DeleteObject(BitmapW);
  sub_409E60(v2);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1112);
  SetFocus(DlgItem);
  v7 = *(_DWORD **)(*(_DWORD *)(this + 56) + 540);
  v8 = (_DWORD *)*v7;
  for ( i = v7; v8 != i; v8 = (_DWORD *)*v8 )
  {
    v18 = 7;
    lParam[4] = 0;
    LOWORD(lParam[0]) = 0;
    sub_4090E0((int)lParam, v8 + 2, 0, 0xFFFFFFFF);
    v9 = (LPARAM *)lParam[0];
    if ( v18 < 8 )
      v9 = lParam;
    SendMessageW(DlgItem, 0x143u, 0xFFFFFFFF, (LPARAM)v9);
    if ( v18 >= 8 )
      operator delete((void *)lParam[0]);
  }
  v10 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 48) + 4))(*(_DWORD *)(this + 48));
  (*(void (__thiscall **)(int, LPARAM *, int))(*(_DWORD *)v10 + 208))(v10, v19, 512);
  SendMessageW(DlgItem, 0x14Du, 0xFFFFFFFF, (LPARAM)v19);
  SendMessageW(DlgItem, 0x142u, 0, -65536);
  v11 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 48) + 4))(*(_DWORD *)(this + 48));
  if ( (*(int (__thiscall **)(int))(*(_DWORD *)v11 + 224))(v11) )
    CheckDlgButton(*(HWND *)(this + 4), 1290, 1u);
  v12 = *(HWND *)(this + 4);
  v13 = *(_DWORD **)(this + 56);
  if ( v13[1] )
  {
    SetWindowPos(v12, 0, v13[2], v13[3], v13[4], v13[5], 4u);
  }
  else
  {
    Parent = GetParent(v12);
    sub_4697F0(v12, Parent);
  }
  return 0;
}

//----- (004A0040) --------------------------------------------------------
void __thiscall sub_4A0040(_DWORD *this, int a2, void *Src)
{
  int v4; // esi
  char *v5; // eax
  int v6; // ecx
  void *v7[5]; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+34h] [ebp-4h]

  if ( sub_469A50(L"Filter*", a2, 1) )
  {
    LOWORD(v7[0]) = 0;
    v8 = 7;
    v7[4] = 0;
    sub_4094F0(v7, (int)Src + 2, Src, wcslen((const unsigned __int16 *)Src));
    v9 = 0;
    v4 = this[135];
    v5 = sub_40A200((char *)v4, *(_DWORD *)(v4 + 4), (int)v7);
    v6 = this[136];
    if ( v6 == 153391688 )
      std::_Xlength_error("list<T> too long");
    this[136] = v6 + 1;
    *(_DWORD *)(v4 + 4) = v5;
    **((_DWORD **)v5 + 1) = v5;
    if ( v8 >= 8 )
      operator delete(v7[0]);
  }
}

//----- (004A0140) --------------------------------------------------------
LSTATUS __thiscall sub_4A0140(void *this, HKEY a2)
{
  return sub_464270((int)L"Filter", (int)this + 540, a2);
}
// 4CB1D8: using guessed type wchar_t aFilter_8[7];

//----- (004A0160) --------------------------------------------------------
BOOL __usercall sub_4A0160@<eax>(int a1@<esi>)
{
  HWND DlgItem; // edi
  WPARAM v2; // ebx
  _DWORD *v3; // ecx
  _DWORD *v4; // edi
  const WCHAR *v5; // eax
  bool v6; // zf
  int v7; // eax
  int v8; // edi
  char **v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v12; // ecx
  int *v13; // eax
  int *v14; // ecx
  int v15; // edx
  int v16; // edi
  unsigned int v17; // edx
  int v18; // edx
  int v19; // edx
  int *v20; // ebx
  int v21; // edi
  UINT v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  WCHAR *lpString1; // [esp+Ch] [ebp-30h]
  void *v28[4]; // [esp+10h] [ebp-2Ch] BYREF
  int v29; // [esp+20h] [ebp-1Ch]
  unsigned int v30; // [esp+24h] [ebp-18h]
  int v31; // [esp+28h] [ebp-14h]
  int v32; // [esp+38h] [ebp-4h]

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1112);
  v2 = GetWindowTextLengthW(DlgItem) + 1;
  lpString1 = (WCHAR *)operator new[](2 * v2);
  SendMessageW(DlgItem, 0xDu, v2, (LPARAM)lpString1);
  v3 = *(_DWORD **)(*(_DWORD *)(a1 + 56) + 540);
  v4 = (_DWORD *)*v3;
  if ( (_DWORD *)*v3 == v3 )
  {
LABEL_6:
    LOWORD(v28[0]) = 0;
    v30 = 7;
    v29 = 0;
    sub_4094F0(v28, (int)(lpString1 + 1), lpString1, wcslen(lpString1));
    v32 = 1;
    v8 = *(_DWORD *)(a1 + 56);
    v9 = *(char ***)(v8 + 540);
    v10 = *v9;
    v11 = sub_40A200(*v9, *((_DWORD *)*v9 + 1), (int)v28);
    v12 = *(_DWORD *)(v8 + 544);
    if ( v12 == 153391688 )
      std::_Xlength_error("list<T> too long");
    *(_DWORD *)(v8 + 544) = v12 + 1;
    *((_DWORD *)v10 + 1) = v11;
    **((_DWORD **)v11 + 1) = v11;
    v32 = -1;
    if ( v30 >= 8 )
      operator delete(v28[0]);
    v30 = 7;
    v29 = 0;
    LOWORD(v28[0]) = 0;
  }
  else
  {
    while ( 1 )
    {
      v5 = (const WCHAR *)(v4 + 2);
      if ( v4[7] >= 8u )
        v5 = *(const WCHAR **)v5;
      v6 = lstrcmpW(lpString1, v5) == 0;
      v7 = *(_DWORD *)(a1 + 56);
      if ( v6 )
        break;
      v4 = (_DWORD *)*v4;
      if ( v4 == *(_DWORD **)(v7 + 540) )
        goto LABEL_6;
    }
    v13 = (int *)(**(_DWORD **)(v7 + 540) + 8);
    v14 = v4 + 2;
    if ( v4 + 2 != v13 )
    {
      v15 = *v14;
      v16 = v4[3];
      v30 = v14[2];
      v31 = v14[3];
      *v14 = *v13;
      v14[1] = v13[1];
      v14[2] = v13[2];
      v14[3] = v13[3];
      *v13 = v15;
      v17 = v30;
      v13[1] = v16;
      v13[2] = v17;
      v13[3] = v31;
      v18 = v14[4];
      v14[4] = v13[4];
      v13[4] = v18;
      v19 = v14[5];
      v14[5] = v13[5];
      v13[5] = v19;
    }
  }
  v20 = (int *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
  v21 = *v20;
  v22 = IsDlgButtonChecked(*(HWND *)(a1 + 4), 1290);
  (*(void (__thiscall **)(int *, bool))(v21 + 228))(v20, v22 == 1);
  v23 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
  (*(void (__thiscall **)(int, WCHAR *))(*(_DWORD *)v23 + 212))(v23, lpString1);
  v24 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
  if ( !(*(int (__thiscall **)(int))(*(_DWORD *)v24 + 216))(v24) )
  {
    v25 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 48) + 4))(*(_DWORD *)(a1 + 48));
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v25 + 220))(v25, 1);
  }
  operator delete[](lpString1);
  return EndDialog(*(HWND *)(a1 + 4), 1);
}

//----- (004A03D0) --------------------------------------------------------
int __thiscall sub_4A03D0(HWND *this, __int16 a2, int a3)
{
  if ( a2 == 1 )
  {
    sub_4A0160((int)this);
  }
  else if ( a2 == 2 )
  {
    EndDialog(this[1], 0);
    return 0;
  }
  return 0;
}

//----- (004A0400) --------------------------------------------------------
int __stdcall sub_4A0400(int a1, int a2, int a3)
{
  if ( a3 == 1 )
    (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 1308) + 328))(*(_DWORD *)(a1 + 1308), a2);
  return 0;
}

//----- (004A0430) --------------------------------------------------------
int __stdcall sub_4A0430(int a1, _DWORD *a2)
{
  *a2 = 3;
  return 0;
}

//----- (004A0450) --------------------------------------------------------
int __stdcall sub_4A0450(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (004A0460) --------------------------------------------------------
int __stdcall sub_4A0460(int a1, int a2, int a3)
{
  return 0;
}

//----- (004A0470) --------------------------------------------------------
int __stdcall sub_4A0470(int a1)
{
  return 0;
}

//----- (004A0480) --------------------------------------------------------
int __stdcall sub_4A0480(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (004A0490) --------------------------------------------------------
int __stdcall sub_4A0490(int a1, int a2)
{
  return 0;
}

//----- (004A04A0) --------------------------------------------------------
int __stdcall sub_4A04A0(int a1)
{
  return 0;
}

//----- (004A04B0) --------------------------------------------------------
int __stdcall sub_4A04B0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return 0;
}

//----- (004A04C0) --------------------------------------------------------
int __stdcall sub_4A04C0(int a1)
{
  return 0;
}

//----- (004A04D0) --------------------------------------------------------
int __stdcall sub_4A04D0(int a1, int a2)
{
  return 0;
}

//----- (004A04E0) --------------------------------------------------------
int __stdcall sub_4A04E0(int a1, int a2)
{
  return 0;
}

//----- (004A04F0) --------------------------------------------------------
int __stdcall sub_4A04F0(int a1, int a2)
{
  return 0;
}

//----- (004A0500) --------------------------------------------------------
int __stdcall sub_4A0500(int a1, int a2)
{
  return 0;
}

//----- (004A0510) --------------------------------------------------------
int __stdcall sub_4A0510(int a1, int a2)
{
  return 0;
}

//----- (004A0520) --------------------------------------------------------
int __stdcall sub_4A0520(int a1, LPCITEMIDLIST pidl2, int a3, int a4)
{
  ITEMIDLIST *v4; // esi
  LPITEMIDLIST v5; // edi

  v4 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1312) + 56))(*(_DWORD *)(a1 + 1312));
  v5 = ILCombine(v4, pidl2);
  (*(void (__thiscall **)(_DWORD, LPITEMIDLIST))(**(_DWORD **)(a1 + 1312) + 328))(*(_DWORD *)(a1 + 1312), v5);
  CoTaskMemFree(v4);
  CoTaskMemFree(v5);
  return 0;
}

//----- (004A0570) --------------------------------------------------------
int __stdcall sub_4A0570(int a1, int a2)
{
  return 0;
}

//----- (004A0580) --------------------------------------------------------
int __stdcall sub_4A0580(int a1, int a2, int a3)
{
  return 0;
}

//----- (004A0590) --------------------------------------------------------
int __stdcall sub_4A0590(int a1, int a2)
{
  return 0;
}

//----- (004A05A0) --------------------------------------------------------
int __stdcall sub_4A05A0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (004A05C0) --------------------------------------------------------
int __stdcall sub_4A05C0(int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  return -2147467262;
}

//----- (004A0610) --------------------------------------------------------
_DWORD *__usercall sub_4A0610@<eax>(_DWORD *result@<eax>)
{
  result[14836] = 0;
  result[14837] = 0;
  result[1400] = 1;
  result[14831] = 0;
  result[14832] = 0;
  result[14833] = 0;
  result[14834] = 0;
  result[14835] = 1;
  result[14865] = 1;
  result[14841] = 0;
  result[14843] = 0;
  result[14844] = 0;
  result[14845] = 1;
  result[14866] = 1;
  result[14846] = 0;
  result[14847] = 500;
  result[14848] = 1;
  result[14849] = 0;
  result[14850] = 1;
  result[14851] = 0;
  result[14852] = 1;
  result[14853] = 1;
  result[14854] = 0;
  result[14855] = 0;
  result[14864] = 1;
  result[14860] = 1;
  result[14861] = 0;
  result[14856] = 1;
  result[14862] = 0;
  result[14858] = 1;
  result[14863] = 1;
  result[14867] = 1;
  result[14868] = 0;
  result[14821] = 1;
  result[14822] = 1;
  result[14823] = 1;
  result[14825] = 1;
  result[14826] = 0;
  result[14824] = 1;
  result[14827] = 1;
  result[14828] = 0;
  result[14829] = 1;
  result[14830] = 1;
  result[14840] = 1;
  result[1396] = 90;
  result[1404] = 208;
  result[14842] = 0;
  result[14857] = 0;
  result[14869] = 1;
  result[14870] = 1;
  result[14871] = 1;
  result[14872] = 0;
  result[14873] = 1;
  result[14874] = 1;
  result[14876] = 1;
  result[14875] = 1;
  result[14877] = 0;
  result[14878] = 0;
  return result;
}

//----- (004A0780) --------------------------------------------------------
_DWORD *__usercall sub_4A0780@<eax>(_DWORD *result@<eax>)
{
  result[14895] = 881;
  result[14935] = 881;
  result[14955] = 881;
  result[14975] = 881;
  result[14907] = 0;
  result[14896] = 513;
  result[14905] = 0;
  result[14911] = 0;
  result[14903] = 0;
  result[14910] = 0;
  result[14913] = 0;
  result[14899] = 0;
  result[14927] = 1;
  result[14915] = 373;
  result[14916] = 1;
  result[14925] = 0;
  result[14931] = 0;
  result[14923] = 0;
  result[14930] = 0;
  result[14933] = 0;
  result[14919] = 0;
  result[14947] = 2;
  result[14936] = 513;
  result[14945] = 0;
  result[14951] = 0;
  result[14943] = 0;
  result[14950] = 0;
  result[14953] = 0;
  result[14939] = 0;
  result[14967] = 3;
  result[14956] = 513;
  result[14965] = 0;
  result[14971] = 0;
  result[14963] = 0;
  result[14970] = 0;
  result[14973] = 0;
  result[14959] = 0;
  result[14987] = 4;
  result[14976] = 513;
  result[14985] = 0;
  result[14991] = 0;
  result[14983] = 0;
  result[14990] = 0;
  result[14993] = 0;
  result[14979] = 0;
  return result;
}

//----- (004A08C0) --------------------------------------------------------
int __stdcall sub_4A08C0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 32) + 1;
  *(_DWORD *)(a1 + 32) = result;
  return result;
}

//----- (004A08E0) --------------------------------------------------------
int __stdcall sub_4A08E0(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ecx
  int v5; // eax

  *a4 = 0;
  if ( sub_40AA20(dword_4BD84C, a3) )
  {
    v4 = a1;
    if ( a1 != 4 )
    {
      v5 = a1 + 4;
      goto LABEL_8;
    }
  }
  else
  {
    if ( !sub_40AA20(dword_4BD8CC, a3) )
      return -2147467262;
    v4 = a1;
    if ( a1 != 4 )
    {
      v5 = a1 + 8;
      goto LABEL_8;
    }
  }
  v5 = 0;
LABEL_8:
  *a4 = v5;
  if ( v5 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)(v4 - 4) + 4))(v4 - 4);
    return 0;
  }
  return -2147467262;
}
// 4BD84C: using guessed type _DWORD dword_4BD84C[4];
// 4BD8CC: using guessed type _DWORD dword_4BD8CC[4];

//----- (004A0960) --------------------------------------------------------
int __stdcall sub_4A0960(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    *(_DWORD *)a1 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
    operator delete(a1);
    return 0;
  }
  return result;
}
// 4CBD1C: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';

//----- (004A0990) --------------------------------------------------------
HMENU __thiscall sub_4A0990(_DWORD *this, int a2)
{
  UINT v3; // ebx
  HMENU v4; // edi
  _DWORD *v5; // eax
  int v6; // ecx
  HMENU Menu; // edi
  void ***v8; // eax
  void **v9; // esi
  void **v10; // ecx
  void **v11; // esi
  int MenuItemCount; // eax
  void **v13; // eax
  void *v14; // ecx
  void **v15; // esi
  MENUITEMINFOW mi; // [esp+10h] [ebp-274h] BYREF
  int pExceptionObject[4]; // [esp+40h] [ebp-244h] BYREF
  char *v19; // [esp+50h] [ebp-234h] BYREF
  int v20; // [esp+54h] [ebp-230h]
  HMENU hmenu; // [esp+58h] [ebp-22Ch]
  void *v22; // [esp+5Ch] [ebp-228h] BYREF
  int v23; // [esp+60h] [ebp-224h]
  __int16 v24[260]; // [esp+68h] [ebp-21Ch] BYREF
  int v25; // [esp+280h] [ebp-4h]

  v3 = 0;
  pExceptionObject[3] = (int)this;
  v4 = 0;
  v23 = 0;
  v5 = operator new(0xCu);
  if ( !v5 )
  {
    v19 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v19);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v22 = v5;
  *v5 = v5;
  *((_DWORD *)v22 + 1) = v22;
  v25 = 0;
  v6 = this[330];
  if ( a2 )
  {
    (*(void (__thiscall **)(int, void **))(*(_DWORD *)v6 + 76))(v6, &v22);
    v20 = 2000;
  }
  else
  {
    (*(void (__thiscall **)(int, void **))(*(_DWORD *)v6 + 80))(v6, &v22);
    v20 = 3000;
  }
  if ( v23 )
  {
    Menu = CreateMenu();
    v8 = (void ***)v22;
    v9 = *(void ***)v22;
    hmenu = Menu;
    if ( v9 != v22 )
    {
      do
      {
        sub_466630((const ITEMIDLIST *)v9[2], (WCHAR *)v24, 1);
        mi.wID = v20 + v3 + 1;
        mi.cbSize = 48;
        mi.fMask = 66;
        mi.dwTypeData = (LPWSTR)v24;
        InsertMenuItemW(hmenu, v3++, 1, &mi);
        CoTaskMemFree(v9[2]);
        v9 = (void **)*v9;
        v8 = (void ***)v22;
      }
      while ( v9 != v22 );
      Menu = hmenu;
    }
    v10 = *v8;
    *v8 = (void **)v8;
    *((_DWORD *)v22 + 1) = v22;
    v23 = 0;
    if ( v10 != v22 )
    {
      do
      {
        v11 = (void **)*v10;
        operator delete(v10);
        v10 = v11;
      }
      while ( v11 != v22 );
    }
    MenuItemCount = GetMenuItemCount(Menu);
    sub_48FCC0(Menu, MenuItemCount);
    v4 = hmenu;
  }
  v13 = *(void ***)v22;
  *(_DWORD *)v22 = v22;
  *((_DWORD *)v22 + 1) = v22;
  v14 = v22;
  v23 = 0;
  if ( v13 != v22 )
  {
    do
    {
      v15 = (void **)*v13;
      operator delete(v13);
      v14 = v22;
      v13 = v15;
    }
    while ( v15 != v22 );
  }
  operator delete(v14);
  return v4;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4A0990: using guessed type WCHAR var_21C[260];

//----- (004A0BC0) --------------------------------------------------------
int __stdcall sub_4A0BC0(int a1, _DWORD *a2, int *a3)
{
  int v3; // eax

  *a3 = 0;
  if ( !sub_40AA20(dword_4BD92C, a2) )
    return -2147467262;
  v3 = a1 ? a1 + 4 : 0;
  *a3 = v3;
  if ( !v3 )
    return -2147467262;
  (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  return 0;
}
// 4BD92C: using guessed type _DWORD dword_4BD92C[4];

//----- (004A0C10) --------------------------------------------------------
void __stdcall sub_4A0C10(int a1)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  _DWORD **v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // ebx
  _DWORD **v10; // ecx
  _DWORD *v11; // eax
  _DWORD *v12; // ebx
  _DWORD **v13; // ecx
  _DWORD *v14; // eax
  _DWORD *v15; // ebx
  _DWORD **v16; // ecx
  _DWORD *v17; // eax
  _DWORD *v18; // ebx
  _DWORD **v19; // ecx
  _DWORD *v20; // eax
  _DWORD *v21; // ebx
  _DWORD **v22; // ecx
  _DWORD *v23; // eax
  _DWORD *v24; // ebx
  _DWORD **v25; // ecx
  _DWORD *v26; // eax
  _DWORD *v27; // ebx
  _DWORD **v28; // ecx
  _DWORD *v29; // eax
  _DWORD *v30; // ebx
  _DWORD **v31; // ecx
  _DWORD *v32; // eax
  _DWORD *v33; // ebx
  _DWORD **v34; // ecx
  _DWORD *v35; // eax
  _DWORD *v36; // ebx
  _DWORD **v37; // ecx
  _DWORD *v38; // eax
  _DWORD *v39; // ebx
  _DWORD **v40; // ecx
  _DWORD *v41; // eax
  _DWORD *v42; // ebx
  _DWORD **v43; // ecx
  _DWORD *v44; // eax
  _DWORD *v45; // ebx
  _DWORD **v46; // ecx
  _DWORD *v47; // eax
  _DWORD *v48; // ebx
  _DWORD **v49; // ecx
  _DWORD *v50; // eax
  _DWORD *v51; // ebx
  _DWORD **v52; // ecx
  _DWORD *v53; // eax
  _DWORD *v54; // ebx
  _DWORD *v55; // eax

  *(_DWORD *)a1 = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 4) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 8) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 12) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 16) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 20) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 24) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 28) = &Explorerplusplus::`vftable';
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 1324) + 8))(*(_DWORD *)(a1 + 1324));
  if ( *(_DWORD *)(a1 + 59520) )
    FreeLibrary(*(HMODULE *)(a1 + 59520));
  v1 = *(_DWORD ***)(a1 + 61296);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 61296) + 4) = *(_DWORD *)(a1 + 61296);
  *(_DWORD *)(a1 + 61300) = 0;
  if ( v2 != *(_DWORD **)(a1 + 61296) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 61296) );
  }
  operator delete(*(void **)(a1 + 61296));
  v4 = *(_DWORD ***)(a1 + 61284);
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 61284) + 4) = *(_DWORD *)(a1 + 61284);
  *(_DWORD *)(a1 + 61288) = 0;
  if ( v5 != *(_DWORD **)(a1 + 61284) )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != *(_DWORD **)(a1 + 61284) );
  }
  operator delete(*(void **)(a1 + 61284));
  v7 = *(_DWORD ***)(a1 + 61272);
  v8 = *v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a1 + 61272) + 4) = *(_DWORD *)(a1 + 61272);
  *(_DWORD *)(a1 + 61276) = 0;
  if ( v8 != *(_DWORD **)(a1 + 61272) )
  {
    do
    {
      v9 = (_DWORD *)*v8;
      operator delete(v8);
      v8 = v9;
    }
    while ( v9 != *(_DWORD **)(a1 + 61272) );
  }
  operator delete(*(void **)(a1 + 61272));
  v10 = *(_DWORD ***)(a1 + 61260);
  v11 = *v10;
  *v10 = v10;
  *(_DWORD *)(*(_DWORD *)(a1 + 61260) + 4) = *(_DWORD *)(a1 + 61260);
  *(_DWORD *)(a1 + 61264) = 0;
  if ( v11 != *(_DWORD **)(a1 + 61260) )
  {
    do
    {
      v12 = (_DWORD *)*v11;
      operator delete(v11);
      v11 = v12;
    }
    while ( v12 != *(_DWORD **)(a1 + 61260) );
  }
  operator delete(*(void **)(a1 + 61260));
  v13 = *(_DWORD ***)(a1 + 61244);
  v14 = *v13;
  *v13 = v13;
  *(_DWORD *)(*(_DWORD *)(a1 + 61244) + 4) = *(_DWORD *)(a1 + 61244);
  *(_DWORD *)(a1 + 61248) = 0;
  if ( v14 != *(_DWORD **)(a1 + 61244) )
  {
    do
    {
      v15 = (_DWORD *)*v14;
      operator delete(v14);
      v14 = v15;
    }
    while ( v15 != *(_DWORD **)(a1 + 61244) );
  }
  operator delete(*(void **)(a1 + 61244));
  sub_40A140(a1 + 61228);
  operator delete(*(void **)(a1 + 61228));
  v16 = *(_DWORD ***)(a1 + 60544);
  v17 = *v16;
  *v16 = v16;
  *(_DWORD *)(*(_DWORD *)(a1 + 60544) + 4) = *(_DWORD *)(a1 + 60544);
  *(_DWORD *)(a1 + 60548) = 0;
  if ( v17 != *(_DWORD **)(a1 + 60544) )
  {
    do
    {
      v18 = (_DWORD *)*v17;
      operator delete(v17);
      v17 = v18;
    }
    while ( v18 != *(_DWORD **)(a1 + 60544) );
  }
  operator delete(*(void **)(a1 + 60544));
  v19 = *(_DWORD ***)(a1 + 60532);
  v20 = *v19;
  *v19 = v19;
  *(_DWORD *)(*(_DWORD *)(a1 + 60532) + 4) = *(_DWORD *)(a1 + 60532);
  *(_DWORD *)(a1 + 60536) = 0;
  if ( v20 != *(_DWORD **)(a1 + 60532) )
  {
    do
    {
      v21 = (_DWORD *)*v20;
      operator delete(v20);
      v20 = v21;
    }
    while ( v21 != *(_DWORD **)(a1 + 60532) );
  }
  operator delete(*(void **)(a1 + 60532));
  v22 = *(_DWORD ***)(a1 + 60520);
  v23 = *v22;
  *v22 = v22;
  *(_DWORD *)(*(_DWORD *)(a1 + 60520) + 4) = *(_DWORD *)(a1 + 60520);
  *(_DWORD *)(a1 + 60524) = 0;
  if ( v23 != *(_DWORD **)(a1 + 60520) )
  {
    do
    {
      v24 = (_DWORD *)*v23;
      operator delete(v23);
      v23 = v24;
    }
    while ( v24 != *(_DWORD **)(a1 + 60520) );
  }
  operator delete(*(void **)(a1 + 60520));
  v25 = *(_DWORD ***)(a1 + 60508);
  v26 = *v25;
  *v25 = v25;
  *(_DWORD *)(*(_DWORD *)(a1 + 60508) + 4) = *(_DWORD *)(a1 + 60508);
  *(_DWORD *)(a1 + 60512) = 0;
  if ( v26 != *(_DWORD **)(a1 + 60508) )
  {
    do
    {
      v27 = (_DWORD *)*v26;
      operator delete(v26);
      v26 = v27;
    }
    while ( v27 != *(_DWORD **)(a1 + 60508) );
  }
  operator delete(*(void **)(a1 + 60508));
  v28 = *(_DWORD ***)(a1 + 60496);
  v29 = *v28;
  *v28 = v28;
  *(_DWORD *)(*(_DWORD *)(a1 + 60496) + 4) = *(_DWORD *)(a1 + 60496);
  *(_DWORD *)(a1 + 60500) = 0;
  if ( v29 != *(_DWORD **)(a1 + 60496) )
  {
    do
    {
      v30 = (_DWORD *)*v29;
      operator delete(v29);
      v29 = v30;
    }
    while ( v30 != *(_DWORD **)(a1 + 60496) );
  }
  operator delete(*(void **)(a1 + 60496));
  v31 = *(_DWORD ***)(a1 + 60484);
  v32 = *v31;
  *v31 = v31;
  *(_DWORD *)(*(_DWORD *)(a1 + 60484) + 4) = *(_DWORD *)(a1 + 60484);
  *(_DWORD *)(a1 + 60488) = 0;
  if ( v32 != *(_DWORD **)(a1 + 60484) )
  {
    do
    {
      v33 = (_DWORD *)*v32;
      operator delete(v32);
      v32 = v33;
    }
    while ( v33 != *(_DWORD **)(a1 + 60484) );
  }
  operator delete(*(void **)(a1 + 60484));
  v34 = *(_DWORD ***)(a1 + 60472);
  v35 = *v34;
  *v34 = v34;
  *(_DWORD *)(*(_DWORD *)(a1 + 60472) + 4) = *(_DWORD *)(a1 + 60472);
  *(_DWORD *)(a1 + 60476) = 0;
  if ( v35 != *(_DWORD **)(a1 + 60472) )
  {
    do
    {
      v36 = (_DWORD *)*v35;
      operator delete(v35);
      v35 = v36;
    }
    while ( v36 != *(_DWORD **)(a1 + 60472) );
  }
  operator delete(*(void **)(a1 + 60472));
  v37 = *(_DWORD ***)(a1 + 60456);
  v38 = *v37;
  *v37 = v37;
  *(_DWORD *)(*(_DWORD *)(a1 + 60456) + 4) = *(_DWORD *)(a1 + 60456);
  *(_DWORD *)(a1 + 60460) = 0;
  if ( v38 != *(_DWORD **)(a1 + 60456) )
  {
    do
    {
      v39 = (_DWORD *)*v38;
      operator delete(v38);
      v38 = v39;
    }
    while ( v39 != *(_DWORD **)(a1 + 60456) );
  }
  operator delete(*(void **)(a1 + 60456));
  v40 = *(_DWORD ***)(a1 + 60444);
  v41 = *v40;
  *v40 = v40;
  *(_DWORD *)(*(_DWORD *)(a1 + 60444) + 4) = *(_DWORD *)(a1 + 60444);
  *(_DWORD *)(a1 + 60448) = 0;
  if ( v41 != *(_DWORD **)(a1 + 60444) )
  {
    do
    {
      v42 = (_DWORD *)*v41;
      operator delete(v41);
      v41 = v42;
    }
    while ( v42 != *(_DWORD **)(a1 + 60444) );
  }
  operator delete(*(void **)(a1 + 60444));
  v43 = *(_DWORD ***)(a1 + 60432);
  v44 = *v43;
  *v43 = v43;
  *(_DWORD *)(*(_DWORD *)(a1 + 60432) + 4) = *(_DWORD *)(a1 + 60432);
  *(_DWORD *)(a1 + 60436) = 0;
  if ( v44 != *(_DWORD **)(a1 + 60432) )
  {
    do
    {
      v45 = (_DWORD *)*v44;
      operator delete(v44);
      v44 = v45;
    }
    while ( v45 != *(_DWORD **)(a1 + 60432) );
  }
  operator delete(*(void **)(a1 + 60432));
  sub_40A600(a1 + 60420);
  operator delete(*(void **)(a1 + 60420));
  v46 = *(_DWORD ***)(a1 + 60388);
  v47 = *v46;
  *v46 = v46;
  *(_DWORD *)(*(_DWORD *)(a1 + 60388) + 4) = *(_DWORD *)(a1 + 60388);
  *(_DWORD *)(a1 + 60392) = 0;
  if ( v47 != *(_DWORD **)(a1 + 60388) )
  {
    do
    {
      v48 = (_DWORD *)*v47;
      operator delete(v47);
      v47 = v48;
    }
    while ( v48 != *(_DWORD **)(a1 + 60388) );
  }
  operator delete(*(void **)(a1 + 60388));
  sub_463980((int *)(a1 + 59552));
  v49 = *(_DWORD ***)(a1 + 59528);
  v50 = *v49;
  *v49 = v49;
  *(_DWORD *)(*(_DWORD *)(a1 + 59528) + 4) = *(_DWORD *)(a1 + 59528);
  *(_DWORD *)(a1 + 59532) = 0;
  if ( v50 != *(_DWORD **)(a1 + 59528) )
  {
    do
    {
      v51 = (_DWORD *)*v50;
      operator delete(v50);
      v50 = v51;
    }
    while ( v51 != *(_DWORD **)(a1 + 59528) );
  }
  operator delete(*(void **)(a1 + 59528));
  sub_40A5B0(a1 + 59272);
  operator delete(*(void **)(a1 + 59272));
  v52 = *(_DWORD ***)(a1 + 5640);
  v53 = *v52;
  *v52 = v52;
  *(_DWORD *)(*(_DWORD *)(a1 + 5640) + 4) = *(_DWORD *)(a1 + 5640);
  *(_DWORD *)(a1 + 5644) = 0;
  if ( v53 != *(_DWORD **)(a1 + 5640) )
  {
    do
    {
      v54 = (_DWORD *)*v53;
      operator delete(v53);
      v53 = v54;
    }
    while ( v54 != *(_DWORD **)(a1 + 5640) );
  }
  operator delete(*(void **)(a1 + 5640));
  v55 = *(_DWORD **)(a1 + 36);
  if ( v55 )
  {
    sub_409CF0(v55, *(_DWORD **)(a1 + 40));
    operator delete(*(void **)(a1 + 36));
  }
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
}
// 4CBC24: using guessed type void *Explorerplusplus::`vftable';
// 4CBC44: using guessed type void *Explorerplusplus::`vftable';
// 4CBC5C: using guessed type void *Explorerplusplus::`vftable';
// 4CBCB0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCC8: using guessed type void *Explorerplusplus::`vftable';
// 4CBCD0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCE0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCE8: using guessed type void *Explorerplusplus::`vftable';

//----- (004A1220) --------------------------------------------------------
int __stdcall sub_4A1220(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 8))-- == 1;
  result = *((_DWORD *)a1 + 8);
  if ( v1 )
  {
    sub_4A0C10((int)a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (004A1250) --------------------------------------------------------
int __userpurge sub_4A1250@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  DWORD dwMajorVersion; // eax
  DWORD dwMinorVersion; // edx
  int v27; // edi
  char **v28; // eax
  int v29; // ecx
  int v30; // edi
  char **v31; // eax
  int v32; // ecx
  int v33; // edi
  char **v34; // eax
  int v35; // ecx
  int v36; // edi
  char **v37; // eax
  int v38; // ecx
  int v39; // edi
  char **v40; // eax
  int v41; // ecx
  int v42; // edi
  char **v43; // eax
  int v44; // ecx
  int v45; // edi
  char **v46; // eax
  int v47; // ecx
  int v48; // edi
  char **v49; // eax
  int v50; // ecx
  char **v51; // eax
  int v52; // ecx
  int v53; // edi
  char **v54; // eax
  int v55; // ecx
  int v56; // edi
  char **v57; // eax
  int v58; // ecx
  int v59; // edi
  char **v60; // eax
  int v61; // ecx
  int v62; // edi
  char **v63; // eax
  int v64; // ecx
  HMODULE v65; // eax
  int v67; // [esp-8h] [ebp-164h]
  int v68; // [esp-8h] [ebp-164h]
  int v69; // [esp-8h] [ebp-164h]
  int v70; // [esp-8h] [ebp-164h]
  int v71; // [esp-8h] [ebp-164h]
  int v72; // [esp-8h] [ebp-164h]
  int v73; // [esp-8h] [ebp-164h]
  int v74; // [esp-8h] [ebp-164h]
  int v75; // [esp-8h] [ebp-164h]
  int v76; // [esp-8h] [ebp-164h]
  int v77; // [esp-8h] [ebp-164h]
  int v78; // [esp-8h] [ebp-164h]
  int v79; // [esp-8h] [ebp-164h]
  int v80; // [esp-8h] [ebp-164h]
  int v81[3]; // [esp+14h] [ebp-148h] BYREF
  int pExceptionObject[3]; // [esp+20h] [ebp-13Ch] BYREF
  char *v83; // [esp+2Ch] [ebp-130h] BYREF
  char *v84; // [esp+30h] [ebp-12Ch] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+34h] [ebp-128h] BYREF
  int v86; // [esp+158h] [ebp-4h]

  *(_DWORD *)a1 = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 4) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 8) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 12) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 16) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 20) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 24) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 28) = &Explorerplusplus::`vftable';
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  v86 = 0;
  sub_4660A0((_DWORD *)(a1 + 1332));
  *(_DWORD *)(a1 + 5644) = 0;
  v2 = operator new(0xCu);
  if ( !v2 )
  {
LABEL_61:
    v84 = 0;
    std::exception::exception((std::exception *)v81, (const char *const *)&v84);
    v81[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v81, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 5640) = v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 5640) + 4) = *(_DWORD *)(a1 + 5640);
  LOBYTE(v86) = 1;
  *(_DWORD *)(a1 + 5656) = -16777216;
  *(_DWORD *)(a1 + 5660) = -16777216;
  *(_DWORD *)(a1 + 59276) = 0;
  v3 = operator new(0x68u);
  if ( !v3 )
    goto LABEL_60;
  *(_DWORD *)(a1 + 59272) = v3;
  *v3 = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 59272) + 4) = *(_DWORD *)(a1 + 59272);
  LOBYTE(v86) = 2;
  *(_DWORD *)(a1 + 59532) = 0;
  v4 = operator new(0x14u);
  if ( !v4 )
    goto LABEL_59;
  *(_DWORD *)(a1 + 59528) = v4;
  *v4 = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 59528) + 4) = *(_DWORD *)(a1 + 59528);
  LOBYTE(v86) = 3;
  v5 = (_DWORD *)(a1 + 59552);
  *(_DWORD *)(a1 + 59552) = 0;
  v6 = operator new(8u);
  if ( !v6 )
    goto LABEL_58;
  *v5 = v6;
  v6[1] = 0;
  *v6 = 0;
  *(_DWORD *)*v5 = v5;
  *(_DWORD *)(a1 + 59556) = 0;
  *(_DWORD *)(a1 + 59560) = 0;
  *(_DWORD *)(a1 + 59564) = 0;
  *(_DWORD *)(a1 + 59568) = 0;
  LOBYTE(v86) = 4;
  *(_DWORD *)(a1 + 60392) = 0;
  v7 = operator new(0xCu);
  if ( !v7 )
    goto LABEL_63;
  *(_DWORD *)(a1 + 60388) = v7;
  *v7 = v7;
  *(_DWORD *)(*(_DWORD *)(a1 + 60388) + 4) = *(_DWORD *)(a1 + 60388);
  LOBYTE(v86) = 5;
  *(_DWORD *)(a1 + 60424) = 0;
  v8 = operator new(0x220u);
  if ( !v8 )
    goto LABEL_62;
  *(_DWORD *)(a1 + 60420) = v8;
  *v8 = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 60420) + 4) = *(_DWORD *)(a1 + 60420);
  LOBYTE(v86) = 6;
  *(_DWORD *)(a1 + 60436) = 0;
  v9 = operator new(0x408u);
  if ( !v9 )
    goto LABEL_61;
  *(_DWORD *)(a1 + 60432) = v9;
  *v9 = v9;
  *(_DWORD *)(*(_DWORD *)(a1 + 60432) + 4) = *(_DWORD *)(a1 + 60432);
  LOBYTE(v86) = 7;
  *(_DWORD *)(a1 + 60448) = 0;
  v10 = operator new(0x408u);
  if ( !v10 )
    goto LABEL_60;
  *(_DWORD *)(a1 + 60444) = v10;
  *v10 = v10;
  *(_DWORD *)(*(_DWORD *)(a1 + 60444) + 4) = *(_DWORD *)(a1 + 60444);
  LOBYTE(v86) = 8;
  *(_DWORD *)(a1 + 60460) = 0;
  v11 = operator new(0x14u);
  if ( !v11 )
    goto LABEL_59;
  *(_DWORD *)(a1 + 60456) = v11;
  *v11 = v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 60456) + 4) = *(_DWORD *)(a1 + 60456);
  LOBYTE(v86) = 9;
  *(_DWORD *)(a1 + 60476) = 0;
  v12 = operator new(0x14u);
  if ( !v12 )
    goto LABEL_58;
  *(_DWORD *)(a1 + 60472) = v12;
  *v12 = v12;
  *(_DWORD *)(*(_DWORD *)(a1 + 60472) + 4) = *(_DWORD *)(a1 + 60472);
  LOBYTE(v86) = 10;
  *(_DWORD *)(a1 + 60488) = 0;
  v13 = operator new(0x14u);
  if ( !v13 )
    goto LABEL_63;
  *(_DWORD *)(a1 + 60484) = v13;
  *v13 = v13;
  *(_DWORD *)(*(_DWORD *)(a1 + 60484) + 4) = *(_DWORD *)(a1 + 60484);
  LOBYTE(v86) = 11;
  *(_DWORD *)(a1 + 60500) = 0;
  v14 = operator new(0x14u);
  if ( !v14 )
    goto LABEL_62;
  *(_DWORD *)(a1 + 60496) = v14;
  *v14 = v14;
  *(_DWORD *)(*(_DWORD *)(a1 + 60496) + 4) = *(_DWORD *)(a1 + 60496);
  LOBYTE(v86) = 12;
  *(_DWORD *)(a1 + 60512) = 0;
  v15 = operator new(0x14u);
  if ( !v15 )
    goto LABEL_61;
  *(_DWORD *)(a1 + 60508) = v15;
  *v15 = v15;
  *(_DWORD *)(*(_DWORD *)(a1 + 60508) + 4) = *(_DWORD *)(a1 + 60508);
  LOBYTE(v86) = 13;
  *(_DWORD *)(a1 + 60524) = 0;
  v16 = operator new(0x14u);
  if ( !v16 )
    goto LABEL_60;
  *(_DWORD *)(a1 + 60520) = v16;
  *v16 = v16;
  *(_DWORD *)(*(_DWORD *)(a1 + 60520) + 4) = *(_DWORD *)(a1 + 60520);
  LOBYTE(v86) = 14;
  *(_DWORD *)(a1 + 60536) = 0;
  v17 = operator new(0x14u);
  if ( !v17 )
    goto LABEL_59;
  *(_DWORD *)(a1 + 60532) = v17;
  *v17 = v17;
  *(_DWORD *)(*(_DWORD *)(a1 + 60532) + 4) = *(_DWORD *)(a1 + 60532);
  LOBYTE(v86) = 15;
  *(_DWORD *)(a1 + 60548) = 0;
  v18 = operator new(0x14u);
  if ( !v18 )
    goto LABEL_58;
  *(_DWORD *)(a1 + 60544) = v18;
  *v18 = v18;
  *(_DWORD *)(*(_DWORD *)(a1 + 60544) + 4) = *(_DWORD *)(a1 + 60544);
  LOBYTE(v86) = 16;
  *(_DWORD *)(a1 + 61232) = 0;
  v19 = operator new(0x24u);
  if ( !v19 )
  {
LABEL_63:
    v84 = 0;
    std::exception::exception((std::exception *)v81, (const char *const *)&v84);
    v81[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v81, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 61228) = v19;
  *v19 = v19;
  *(_DWORD *)(*(_DWORD *)(a1 + 61228) + 4) = *(_DWORD *)(a1 + 61228);
  LOBYTE(v86) = 17;
  *(_DWORD *)(a1 + 61248) = 0;
  v20 = operator new(0x10u);
  if ( !v20 )
  {
LABEL_62:
    v83 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v83);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 61244) = v20;
  *v20 = v20;
  *(_DWORD *)(*(_DWORD *)(a1 + 61244) + 4) = *(_DWORD *)(a1 + 61244);
  LOBYTE(v86) = 18;
  *(_DWORD *)(a1 + 61264) = 0;
  v21 = operator new(0x10u);
  if ( !v21 )
    goto LABEL_61;
  *(_DWORD *)(a1 + 61260) = v21;
  *v21 = v21;
  *(_DWORD *)(*(_DWORD *)(a1 + 61260) + 4) = *(_DWORD *)(a1 + 61260);
  LOBYTE(v86) = 19;
  *(_DWORD *)(a1 + 61276) = 0;
  v22 = operator new(0x10u);
  if ( !v22 )
  {
LABEL_60:
    v83 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v83);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 61272) = v22;
  *v22 = v22;
  *(_DWORD *)(*(_DWORD *)(a1 + 61272) + 4) = *(_DWORD *)(a1 + 61272);
  LOBYTE(v86) = 20;
  *(_DWORD *)(a1 + 61288) = 0;
  v23 = operator new(0x10u);
  if ( !v23 )
  {
LABEL_59:
    v84 = 0;
    std::exception::exception((std::exception *)v81, (const char *const *)&v84);
    v81[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(v81, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 61284) = v23;
  *v23 = v23;
  *(_DWORD *)(*(_DWORD *)(a1 + 61284) + 4) = *(_DWORD *)(a1 + 61284);
  LOBYTE(v86) = 21;
  *(_DWORD *)(a1 + 61300) = 0;
  v24 = operator new(0x10u);
  if ( !v24 )
  {
LABEL_58:
    v83 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v83);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 61296) = v24;
  *v24 = v24;
  *(_DWORD *)(*(_DWORD *)(a1 + 61296) + 4) = *(_DWORD *)(a1 + 61296);
  LOBYTE(v86) = 22;
  *(_DWORD *)(a1 + 52) = a2;
  *(_DWORD *)(a1 + 32) = 1;
  *(_DWORD *)(a1 + 5632) = 0;
  *(_DWORD *)(a1 + 60572) = 0;
  *(_DWORD *)(a1 + 5620) = 0;
  *(_DWORD *)(a1 + 5624) = 0;
  *(_DWORD *)(a1 + 60556) = 0;
  *(_DWORD *)(a1 + 60560) = 0;
  *(_DWORD *)(a1 + 60564) = 0;
  *(_DWORD *)(a1 + 60568) = 0;
  *(_DWORD *)(a1 + 5592) = 0;
  *(_DWORD *)(a1 + 5588) = 0;
  *(_DWORD *)(a1 + 60616) = 0;
  *(_DWORD *)(a1 + 59352) = 0;
  *(_DWORD *)(a1 + 59356) = 0;
  *(_DWORD *)(a1 + 5604) = 0;
  *(_DWORD *)(a1 + 5608) = 0;
  *(_DWORD *)(a1 + 60608) = 0;
  *(_DWORD *)(a1 + 60592) = 0;
  *(_DWORD *)(a1 + 60596) = 0;
  *(_DWORD *)(a1 + 60600) = 0;
  *(_DWORD *)(a1 + 1320) = 0;
  hDlg = 0;
  hWnd = 0;
  *(_DWORD *)(a1 + 60580) = -1;
  *(_DWORD *)(a1 + 60400) = 0;
  *(_DWORD *)(a1 + 61308) = 0;
  *(_DWORD *)(a1 + 61192) = 0;
  *(_DWORD *)(a1 + 61216) = 0;
  *(_DWORD *)(a1 + 61204) = 0;
  *(_DWORD *)(a1 + 59524) = 0;
  *(_DWORD *)(a1 + 61316) = 0;
  sub_4B06D0((_DWORD *)a1);
  sub_4A0610((_DWORD *)a1);
  sub_490D00(a1 + 60472);
  sub_490C60(a1 + 60496);
  sub_490BC0(a1 + 60484);
  sub_490B20(a1 + 60508);
  sub_490A80(a1 + 60520);
  sub_4909E0(a1 + 60532);
  sub_490940(a1 + 60544);
  memset((void *)(a1 + 58872), 0, 0x190u);
  sub_4664A0(17, (LPWSTR)(a1 + 4012));
  sub_4664A0(17, (LPWSTR)(a1 + 4532));
  sub_4A0780((_DWORD *)a1);
  *(_DWORD *)(a1 + 60404) = 0;
  *(_DWORD *)(a1 + 60412) = 0;
  *(_DWORD *)(a1 + 60416) = 0;
  InitializeCriticalSection(&stru_4EF1A0);
  *(_DWORD *)(a1 + 60468) = 0;
  *(_DWORD *)(a1 + 60584) = 0;
  *(_DWORD *)(a1 + 61240) = 0;
  *(_DWORD *)(a1 + 60588) = 0;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) )
  {
    dwMajorVersion = VersionInformation.dwMajorVersion;
    dwMinorVersion = VersionInformation.dwMinorVersion;
    *(_DWORD *)(a1 + 5576) = VersionInformation.dwMajorVersion;
    *(_DWORD *)(a1 + 5580) = dwMinorVersion;
    v27 = *(_DWORD *)(a1 + 5640);
    if ( dwMajorVersion < 6 )
    {
      v75 = *(_DWORD *)(v27 + 4);
      v84 = (char *)6;
      v51 = sub_40A550((char *)v27, v75, (int)&v84);
      v52 = *(_DWORD *)(a1 + 5644);
      if ( v52 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v52 + 1;
      *(_DWORD *)(v27 + 4) = v51;
      *(_DWORD *)v51[1] = v51;
      v53 = *(_DWORD *)(a1 + 5640);
      v76 = *(_DWORD *)(v53 + 4);
      v84 = (char *)5;
      v54 = sub_40A550((char *)v53, v76, (int)&v84);
      v55 = *(_DWORD *)(a1 + 5644);
      if ( v55 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v55 + 1;
      *(_DWORD *)(v53 + 4) = v54;
      *(_DWORD *)v54[1] = v54;
      v56 = *(_DWORD *)(a1 + 5640);
      v77 = *(_DWORD *)(v56 + 4);
      v84 = (char *)1;
      v57 = sub_40A550((char *)v56, v77, (int)&v84);
      v58 = *(_DWORD *)(a1 + 5644);
      if ( v58 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v58 + 1;
      *(_DWORD *)(v56 + 4) = v57;
      *(_DWORD *)v57[1] = v57;
      v59 = *(_DWORD *)(a1 + 5640);
      v78 = *(_DWORD *)(v59 + 4);
      v84 = (char *)2;
      v60 = sub_40A550((char *)v59, v78, (int)&v84);
      v61 = *(_DWORD *)(a1 + 5644);
      if ( v61 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v61 + 1;
      *(_DWORD *)(v59 + 4) = v60;
      *(_DWORD *)v60[1] = v60;
      v62 = *(_DWORD *)(a1 + 5640);
      v79 = *(_DWORD *)(v62 + 4);
      v84 = (char *)3;
      v63 = sub_40A550((char *)v62, v79, (int)&v84);
      v64 = *(_DWORD *)(a1 + 5644);
      if ( v64 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v64 + 1;
      *(_DWORD *)(v62 + 4) = v63;
      *(_DWORD *)v63[1] = v63;
      v48 = *(_DWORD *)(a1 + 5640);
      v80 = *(_DWORD *)(v48 + 4);
      v84 = (char *)4;
      v49 = sub_40A550((char *)v48, v80, (int)&v84);
      v50 = *(_DWORD *)(a1 + 5644);
      if ( v50 == 1073741822 )
        std::_Xlength_error("list<T> too long");
    }
    else
    {
      v67 = *(_DWORD *)(v27 + 4);
      v84 = (char *)7;
      v28 = sub_40A550((char *)v27, v67, (int)&v84);
      v29 = *(_DWORD *)(a1 + 5644);
      if ( v29 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v29 + 1;
      *(_DWORD *)(v27 + 4) = v28;
      *(_DWORD *)v28[1] = v28;
      v30 = *(_DWORD *)(a1 + 5640);
      v68 = *(_DWORD *)(v30 + 4);
      v84 = (char *)8;
      v31 = sub_40A550((char *)v30, v68, (int)&v84);
      v32 = *(_DWORD *)(a1 + 5644);
      if ( v32 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v32 + 1;
      *(_DWORD *)(v30 + 4) = v31;
      *(_DWORD *)v31[1] = v31;
      v33 = *(_DWORD *)(a1 + 5640);
      v69 = *(_DWORD *)(v33 + 4);
      v84 = (char *)1;
      v34 = sub_40A550((char *)v33, v69, (int)&v84);
      v35 = *(_DWORD *)(a1 + 5644);
      if ( v35 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v35 + 1;
      *(_DWORD *)(v33 + 4) = v34;
      *(_DWORD *)v34[1] = v34;
      v36 = *(_DWORD *)(a1 + 5640);
      v70 = *(_DWORD *)(v36 + 4);
      v84 = (char *)2;
      v37 = sub_40A550((char *)v36, v70, (int)&v84);
      v38 = *(_DWORD *)(a1 + 5644);
      if ( v38 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v38 + 1;
      *(_DWORD *)(v36 + 4) = v37;
      *(_DWORD *)v37[1] = v37;
      v39 = *(_DWORD *)(a1 + 5640);
      v71 = *(_DWORD *)(v39 + 4);
      v84 = (char *)3;
      v40 = sub_40A550((char *)v39, v71, (int)&v84);
      v41 = *(_DWORD *)(a1 + 5644);
      if ( v41 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v41 + 1;
      *(_DWORD *)(v39 + 4) = v40;
      *(_DWORD *)v40[1] = v40;
      v42 = *(_DWORD *)(a1 + 5640);
      v72 = *(_DWORD *)(v42 + 4);
      v84 = (char *)4;
      v43 = sub_40A550((char *)v42, v72, (int)&v84);
      v44 = *(_DWORD *)(a1 + 5644);
      if ( v44 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v44 + 1;
      *(_DWORD *)(v42 + 4) = v43;
      *(_DWORD *)v43[1] = v43;
      v45 = *(_DWORD *)(a1 + 5640);
      v73 = *(_DWORD *)(v45 + 4);
      v84 = (char *)6;
      v46 = sub_40A550((char *)v45, v73, (int)&v84);
      v47 = *(_DWORD *)(a1 + 5644);
      if ( v47 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 5644) = v47 + 1;
      *(_DWORD *)(v45 + 4) = v46;
      *(_DWORD *)v46[1] = v46;
      v48 = *(_DWORD *)(a1 + 5640);
      v74 = *(_DWORD *)(v48 + 4);
      v84 = (char *)5;
      v49 = sub_40A550((char *)v48, v74, (int)&v84);
      v50 = *(_DWORD *)(a1 + 5644);
      if ( v50 == 1073741822 )
        std::_Xlength_error("list<T> too long");
    }
    *(_DWORD *)(a1 + 5644) = v50 + 1;
    *(_DWORD *)(v48 + 4) = v49;
    *(_DWORD *)v49[1] = v49;
  }
  v65 = sub_40A920(L"dwmapi.dll");
  *(_DWORD *)(a1 + 59520) = v65;
  if ( v65 )
    *(_DWORD *)(a1 + 59516) = GetProcAddress(v65, "DwmInvalidateIconicBitmaps");
  else
    *(_DWORD *)(a1 + 59516) = 0;
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CBC24: using guessed type void *Explorerplusplus::`vftable';
// 4CBC44: using guessed type void *Explorerplusplus::`vftable';
// 4CBC5C: using guessed type void *Explorerplusplus::`vftable';
// 4CBCB0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCC8: using guessed type void *Explorerplusplus::`vftable';
// 4CBCD0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCE0: using guessed type void *Explorerplusplus::`vftable';
// 4CBCE8: using guessed type void *Explorerplusplus::`vftable';

//----- (004A1E40) --------------------------------------------------------
LRESULT __usercall sub_4A1E40@<eax>(int a1@<esi>)
{
  LRESULT result; // eax
  signed int v2; // ebx
  LRESULT i; // [esp+8h] [ebp-2D0h]
  LPARAM lParam[5]; // [esp+Ch] [ebp-2CCh] BYREF
  SHFILEINFOW psfi; // [esp+20h] [ebp-2B8h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 508), 0x418u, 0, 0);
  v2 = 0;
  for ( i = result; v2 < i; ++v2 )
  {
    result = SendMessageW(*(HWND *)(a1 + 508), 0x417u, v2, (LPARAM)lParam);
    if ( result )
    {
      SHGetFileInfoW((LPCWSTR)lParam[3], 0, &psfi, 0x2B4u, 0x4000u);
      result = SendMessageW(*(HWND *)(a1 + 508), 0x42Bu, lParam[1], psfi.iIcon);
    }
  }
  return result;
}

//----- (004A1EF0) --------------------------------------------------------
int __userpurge sub_4A1EF0@<eax>(int a1@<edi>, const WCHAR *a2)
{
  int result; // eax
  int v3; // ebx
  WPARAM v4; // esi
  LPARAM lParam[5]; // [esp+Ch] [ebp-2CCh] BYREF
  SHFILEINFOW psfi; // [esp+20h] [ebp-2B8h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 508), 0x418u, 0, 0);
  v3 = result;
  v4 = 0;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result = SendMessageW(*(HWND *)(a1 + 508), 0x417u, v4, (LPARAM)lParam);
      if ( result )
      {
        result = lstrcmpiW(a2, (LPCWSTR)lParam[3]);
        if ( !result )
          break;
      }
      if ( (int)++v4 >= v3 )
        return result;
    }
    SHGetFileInfoW(a2, 0, &psfi, 0x2B4u, 0x4000u);
    return SendMessageW(*(HWND *)(a1 + 508), 0x42Bu, lParam[1], psfi.iIcon);
  }
  return result;
}

//----- (004A1FD0) --------------------------------------------------------
LRESULT __userpurge sub_4A1FD0@<eax>(int a1@<edi>, const WCHAR *a2)
{
  LRESULT v2; // ebx
  WPARAM v3; // esi
  LRESULT v5; // [esp+Ch] [ebp-1Ch]
  LPARAM lParam[5]; // [esp+10h] [ebp-18h] BYREF

  v2 = 0;
  v3 = 0;
  v5 = SendMessageW(*(HWND *)(a1 + 508), 0x418u, 0, 0);
  if ( v5 <= 0 )
    return v2;
  while ( 1 )
  {
    v2 = SendMessageW(*(HWND *)(a1 + 508), 0x417u, v3, (LPARAM)lParam);
    if ( v2 )
    {
      if ( !lstrcmpW(a2, (LPCWSTR)lParam[3]) )
        break;
    }
    if ( (int)++v3 >= v5 )
      return v2;
  }
  return SendMessageW(*(HWND *)(a1 + 508), 0x416u, v3, 0);
}

//----- (004A2080) --------------------------------------------------------
LRESULT __usercall sub_4A2080@<eax>(int a1@<ebx>, const WCHAR *a2@<edi>)
{
  WCHAR *v2; // eax
  int v3; // esi
  WCHAR v4; // cx
  int v5; // eax
  unsigned int v6; // eax
  signed int v7; // esi
  LRESULT result; // eax
  HWND v9; // [esp-10h] [ebp-32Ch]
  LRESULT v10; // [esp+4h] [ebp-318h]
  WCHAR *v11; // [esp+8h] [ebp-314h]
  WPARAM wParam; // [esp+Ch] [ebp-310h]
  LPARAM lParam[2]; // [esp+10h] [ebp-30Ch] BYREF
  __int16 v14; // [esp+18h] [ebp-304h]
  LPCWSTR lpString2; // [esp+1Ch] [ebp-300h]
  WCHAR *v16; // [esp+20h] [ebp-2FCh]
  SHFILEINFOW psfi; // [esp+24h] [ebp-2F8h] BYREF
  WCHAR String[32]; // [esp+2D8h] [ebp-44h] BYREF

  v2 = String;
  wParam = 0;
  v3 = 32;
  while ( v3 != -2147483614 )
  {
    v4 = *(WCHAR *)((char *)v2 + (char *)a2 - (char *)String);
    if ( !v4 )
      break;
    *v2++ = v4;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  if ( psfi.szTypeName[lstrlenW(String) + 79] == 92 )
    psfi.szTypeName[lstrlenW(String) + 79] = 0;
  SHGetFileInfoW(a2, 0, &psfi, 0x2B4u, 0x4010u);
  v5 = lstrlenW(a2);
  v11 = (WCHAR *)malloc(2 * v5 + 2);
  v6 = lstrlenW(a2) + 1;
  if ( v6 && v6 <= 0x7FFFFFFF )
    sub_4A96F0(v6, (int)a2, v11);
  v7 = 0;
  v10 = SendMessageW(*(HWND *)(a1 + 508), 0x418u, 0, 0);
  if ( v10 > 0 )
  {
    do
    {
      if ( SendMessageW(*(HWND *)(a1 + 508), 0x417u, v7, (LPARAM)lParam) )
      {
        if ( lstrcmpW(a2, lpString2) < 0 )
          break;
        ++wParam;
      }
      ++v7;
    }
    while ( v7 < v10 );
  }
  lParam[1] = *(_DWORD *)(a1 + 60400) + 47000;
  lParam[0] = psfi.iIcon;
  lpString2 = v11;
  v16 = String;
  v9 = *(HWND *)(a1 + 508);
  v14 = 20484;
  result = SendMessageW(v9, 0x443u, wParam, (LPARAM)lParam);
  if ( result )
    ++*(_DWORD *)(a1 + 60400);
  return result;
}
// 4A20D0: conditional instruction was optimized away because esi.4!=0

//----- (004A2230) --------------------------------------------------------
void __thiscall sub_4A2230(HWND *this)
{
  DWORD LogicalDriveStringsW; // esi
  WCHAR *v3; // eax
  WCHAR *v4; // edi
  WCHAR *v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  int v8; // eax
  WCHAR *v9; // ebx
  unsigned int v10; // eax
  LRESULT v11; // ebx
  signed int i; // esi
  HWND *v13; // esi
  int v14; // eax
  bool v15; // zf
  HWND v16; // [esp-10h] [ebp-33Ch]
  HIMAGELIST phimlSmall; // [esp+Ch] [ebp-320h] BYREF
  WCHAR *v18; // [esp+10h] [ebp-31Ch]
  const WCHAR *v19; // [esp+14h] [ebp-318h]
  WPARAM wParam; // [esp+18h] [ebp-314h]
  HWND *v21; // [esp+1Ch] [ebp-310h]
  LPARAM lParam[2]; // [esp+20h] [ebp-30Ch] BYREF
  __int16 v23; // [esp+28h] [ebp-304h]
  LPCWSTR lpString2; // [esp+2Ch] [ebp-300h]
  WCHAR *v25; // [esp+30h] [ebp-2FCh]
  SHFILEINFOW psfi; // [esp+34h] [ebp-2F8h] BYREF
  WCHAR String[32]; // [esp+2E8h] [ebp-44h] BYREF

  v21 = this;
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(this[127], 0x430u, 0, (LPARAM)phimlSmall);
  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0);
  v3 = (WCHAR *)malloc(2 * LogicalDriveStringsW + 2);
  v4 = v3;
  v18 = v3;
  if ( v3 )
  {
    if ( GetLogicalDriveStringsW(LogicalDriveStringsW, v3) && *v4 )
    {
      do
      {
        v5 = String;
        wParam = 0;
        v6 = 32;
        while ( v6 != -2147483614 )
        {
          v7 = *(WCHAR *)((char *)v5 + (char *)v4 - (char *)String);
          if ( !v7 )
            break;
          *v5++ = v7;
          if ( !--v6 )
          {
            --v5;
            break;
          }
        }
        *v5 = 0;
        if ( psfi.szTypeName[lstrlenW(String) + 79] == 92 )
          psfi.szTypeName[lstrlenW(String) + 79] = 0;
        SHGetFileInfoW(v4, 0, &psfi, 0x2B4u, 0x4010u);
        v8 = lstrlenW(v4);
        v9 = (WCHAR *)malloc(2 * v8 + 2);
        v19 = v9;
        v10 = lstrlenW(v4) + 1;
        if ( v10 && v10 <= 0x7FFFFFFF )
          sub_4A96F0(v10, (int)v4, v9);
        v11 = SendMessageW(v21[127], 0x418u, 0, 0);
        for ( i = 0; i < v11; ++i )
        {
          if ( SendMessageW(v21[127], 0x417u, i, (LPARAM)lParam) )
          {
            if ( lstrcmpW(v4, lpString2) < 0 )
              break;
            ++wParam;
          }
        }
        v13 = v21;
        lParam[1] = (LPARAM)(v21[15100] + 11750);
        lParam[0] = psfi.iIcon;
        lpString2 = v19;
        v25 = String;
        v16 = v21[127];
        v23 = 20484;
        if ( SendMessageW(v16, 0x443u, wParam, (LPARAM)lParam) )
          v13[15100] = (HWND)((char *)v13[15100] + 1);
        v14 = lstrlenW(v4);
        v15 = v4[v14 + 1] == 0;
        v4 += v14 + 1;
      }
      while ( !v15 );
      v4 = v18;
    }
    free(v4);
  }
}
// 4A2300: conditional instruction was optimized away because edx.4!=0

//----- (004A2490) --------------------------------------------------------
int __userpurge sub_4A2490@<eax>(int a1@<ebx>, int a2@<esi>, int a3, int a4, DWORD dwErrCode)
{
  DWORD MessagePos; // eax
  signed int v6; // eax
  HWND v8; // [esp-Ch] [ebp-34h]
  struct tagPOINT Points; // [esp+4h] [ebp-24h] BYREF
  int v10; // [esp+Ch] [ebp-1Ch]
  LPARAM lParam[5]; // [esp+10h] [ebp-18h] BYREF

  v10 = a3;
  if ( a1 == 520 )
  {
    MessagePos = GetMessagePos();
    Points.x = (__int16)MessagePos;
    v8 = *(HWND *)(a2 + 508);
    Points.y = SHIWORD(MessagePos);
    MapWindowPoints(0, v8, &Points, 1u);
    v6 = SendMessageW(*(HWND *)(a2 + 508), 0x445u, 0, (LPARAM)&Points);
    if ( v6 >= 0 )
    {
      if ( SendMessageW(*(HWND *)(a2 + 508), 0x417u, v6, (LPARAM)lParam) )
        sub_48FFD0(lParam[3], a2, 0, 1, 1);
    }
  }
  return sub_401C60(v10, a1, a4, dwErrCode);
}

//----- (004A2550) --------------------------------------------------------
int __stdcall sub_4A2550(int a1, int a2, int a3, DWORD a4, int a5, int a6)
{
  return sub_4A2490(a2, a6, a1, a3, a4);
}

//----- (004A25D0) --------------------------------------------------------
LRESULT __usercall sub_4A25D0@<eax>(HWND hWnd@<ecx>, HWND a2@<esi>)
{
  HWND DlgItem; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int lParam; // [esp+8h] [ebp-4Ch]
  unsigned __int8 lParama; // [esp+8h] [ebp-4Ch]
  unsigned __int8 lParamb; // [esp+8h] [ebp-4Ch]
  HWND hWnda; // [esp+Ch] [ebp-48h]
  unsigned __int8 hWndb; // [esp+Ch] [ebp-48h]
  unsigned __int8 hWndc; // [esp+Ch] [ebp-48h]
  WCHAR String[32]; // [esp+10h] [ebp-44h] BYREF

  hWnda = 0;
  GetWindowTextW(hWnd, String, 32);
  lParam = _wtoi(String);
  if ( hWnd == GetDlgItem(a2, 1105) )
  {
    DlgItem = GetDlgItem(a2, 1104);
LABEL_13:
    hWnda = DlgItem;
    goto LABEL_14;
  }
  if ( hWnd == GetDlgItem(a2, 1106) )
  {
    DlgItem = GetDlgItem(a2, 1102);
    goto LABEL_13;
  }
  if ( hWnd == GetDlgItem(a2, 1107) )
  {
    DlgItem = GetDlgItem(a2, 1103);
    goto LABEL_13;
  }
  if ( hWnd == GetDlgItem(a2, 1111) )
  {
    DlgItem = GetDlgItem(a2, 1108);
    goto LABEL_13;
  }
  if ( hWnd == GetDlgItem(a2, 1112) )
  {
    DlgItem = GetDlgItem(a2, 1109);
    goto LABEL_13;
  }
  if ( hWnd == GetDlgItem(a2, 1113) )
  {
    DlgItem = GetDlgItem(a2, 1110);
    goto LABEL_13;
  }
LABEL_14:
  SendMessageW(hWnda, 0x405u, 1u, lParam);
  lParama = SendDlgItemMessageW(a2, 1104, 0x400u, 0, 0);
  hWndb = SendDlgItemMessageW(a2, 1102, 0x400u, 0, 0);
  v4 = SendDlgItemMessageW(a2, 1103, 0x400u, 0, 0);
  SendMessageW(dword_4EF19C, 0x8068u, lParama | ((hWndb | (v4 << 8)) << 8), 0);
  lParamb = SendDlgItemMessageW(a2, 1108, 0x400u, 0, 0);
  hWndc = SendDlgItemMessageW(a2, 1109, 0x400u, 0, 0);
  v5 = SendDlgItemMessageW(a2, 1110, 0x400u, 0, 0);
  return SendMessageW(dword_4EF19C, 0x806Cu, lParamb | ((hWndc | (v5 << 8)) << 8), 0);
}

//----- (004A2770) --------------------------------------------------------
UINT __usercall sub_4A2770@<eax>(HWND a1@<esi>)
{
  UINT v1; // edi
  UINT result; // eax
  LRESULT v3; // [esp+8h] [ebp-Ch]
  LRESULT v4; // [esp+Ch] [ebp-8h]
  LRESULT v5; // [esp+Ch] [ebp-8h]
  LRESULT uValue; // [esp+10h] [ebp-4h]
  LRESULT uValuea; // [esp+10h] [ebp-4h]

  uValue = SendDlgItemMessageW(a1, 1104, 0x400u, 0, 0);
  v4 = SendDlgItemMessageW(a1, 1102, 0x400u, 0, 0);
  v3 = SendDlgItemMessageW(a1, 1103, 0x400u, 0, 0);
  if ( GetDlgItemInt(a1, 1105, 0, 0) != uValue )
    SetDlgItemInt(a1, 1105, uValue, 0);
  if ( GetDlgItemInt(a1, 1106, 0, 0) != v4 )
    SetDlgItemInt(a1, 1106, v4, 0);
  if ( GetDlgItemInt(a1, 1107, 0, 0) != v3 )
    SetDlgItemInt(a1, 1107, v3, 0);
  uValuea = SendDlgItemMessageW(a1, 1108, 0x400u, 0, 0);
  v5 = SendDlgItemMessageW(a1, 1109, 0x400u, 0, 0);
  v1 = SendDlgItemMessageW(a1, 1110, 0x400u, 0, 0);
  if ( GetDlgItemInt(a1, 1111, 0, 0) != uValuea )
    SetDlgItemInt(a1, 1111, uValuea, 0);
  if ( GetDlgItemInt(a1, 1112, 0, 0) != v5 )
    SetDlgItemInt(a1, 1112, v5, 0);
  result = GetDlgItemInt(a1, 1113, 0, 0);
  if ( result != v1 )
    return SetDlgItemInt(a1, 1113, v1, 0);
  return result;
}

//----- (004A28D0) --------------------------------------------------------
BOOL __usercall sub_4A28D0@<eax>(int a1@<edi>, HWND a2@<esi>)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  LONG top; // ecx
  unsigned __int8 v6; // [esp+4h] [ebp-1Ch]
  unsigned __int8 v7; // [esp+4h] [ebp-1Ch]
  unsigned __int8 v8; // [esp+8h] [ebp-18h]
  unsigned __int8 v9; // [esp+8h] [ebp-18h]
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  v8 = SendDlgItemMessageW(a2, 1104, 0x400u, 0, 0);
  v6 = SendDlgItemMessageW(a2, 1102, 0x400u, 0, 0);
  v2 = SendDlgItemMessageW(a2, 1103, 0x400u, 0, 0);
  SendMessageW(*(HWND *)(a1 + 64), 0x8068u, v8 | ((v6 | (v2 << 8)) << 8), 0);
  v9 = SendDlgItemMessageW(a2, 1108, 0x400u, 0, 0);
  v7 = SendDlgItemMessageW(a2, 1109, 0x400u, 0, 0);
  v3 = SendDlgItemMessageW(a2, 1110, 0x400u, 0, 0);
  SendMessageW(*(HWND *)(a1 + 64), 0x806Cu, v9 | ((v7 | (v3 << 8)) << 8), 0);
  SendMessageW(*(HWND *)(a1 + 64), 0x8070u, wParam, 0);
  SendMessageW(*(HWND *)(a1 + 64), 0x8072u, dword_4EF14C, 0);
  GetWindowRect(a2, &Rect);
  top = Rect.top;
  *(_DWORD *)(a1 + 61220) = Rect.left;
  *(_DWORD *)(a1 + 61224) = top;
  *(_DWORD *)(a1 + 61216) = 1;
  return EndDialog(a2, 1);
}

//----- (004A2A10) --------------------------------------------------------
LRESULT __usercall sub_4A2A10@<eax>(DWORD a1@<edi>)
{
  DWORD dwErrCode[3]; // [esp+8h] [ebp-4A8h] BYREF
  LOGFONTW *lplf; // [esp+14h] [ebp-49Ch]
  int v4; // [esp+1Ch] [ebp-494h]
  LRESULT v5; // [esp+20h] [ebp-490h]
  int v6; // [esp+24h] [ebp-48Ch]
  char *v7; // [esp+34h] [ebp-47Ch]
  WPARAM wParam; // [esp+44h] [ebp-46Ch] BYREF
  char pv[96]; // [esp+48h] [ebp-468h] BYREF
  char v10; // [esp+A8h] [ebp-408h] BYREF

  SendMessageW(dword_4EF19C, 0x806Fu, (WPARAM)&wParam, 0);
  GetObjectW((HANDLE)wParam, 92, pv);
  dwErrCode[0] = 60;
  dwErrCode[1] = a1;
  v4 = 65857;
  lplf = (LOGFONTW *)pv;
  v5 = SendMessageW(dword_4EF19C, 0x8071u, 0, 0);
  v6 = 0;
  v7 = &v10;
  sub_40A2D0((DWORD)dwErrCode);
  ::wParam = (WPARAM)CreateFontIndirectW(lplf);
  dword_4EF14C = v5;
  SendMessageW(dword_4EF19C, 0x8070u, ::wParam, 0);
  return SendMessageW(dword_4EF19C, 0x8072u, dword_4EF14C, 0);
}

//----- (004A2B10) --------------------------------------------------------
BOOL __thiscall sub_4A2B10(HWND hWnd, int a2)
{
  int *v3; // esi
  int *v4; // esi
  HMODULE ModuleHandleW; // eax
  HICON ImageW; // eax
  int v7; // edx
  int v8; // ecx
  HMODULE v9; // eax
  UINT v10; // eax
  int Param; // [esp+Ch] [ebp-48h] BYREF
  int v13; // [esp+10h] [ebp-44h]
  int v14; // [esp+14h] [ebp-40h]
  int v15; // [esp+18h] [ebp-3Ch]
  HICON v16; // [esp+1Ch] [ebp-38h]
  HWND hWnda; // [esp+20h] [ebp-34h]
  LPARAM v18; // [esp+24h] [ebp-30h]
  LPARAM v19; // [esp+28h] [ebp-2Ch]
  LPARAM lParam; // [esp+2Ch] [ebp-28h]
  WPARAM v21; // [esp+30h] [ebp-24h]
  WPARAM wParam; // [esp+34h] [ebp-20h]
  int v23; // [esp+38h] [ebp-1Ch]
  struct tagRECT Rect; // [esp+3Ch] [ebp-18h] BYREF

  v23 = a2;
  dword_4EF178 = 1108;
  dword_4EF17C = 1111;
  dword_4EF184 = 1109;
  dword_4EF188 = 1112;
  dword_4EF190 = 1110;
  dword_4EF194 = 1113;
  dword_4EF154 = 1104;
  dword_4EF158 = 1105;
  dword_4EF160 = 1102;
  dword_4EF164 = 1106;
  dword_4EF16C = 1103;
  dword_4EF170 = 1107;
  v3 = &dword_4EF154;
  do
  {
    SendDlgItemMessageW(hWnd, *v3, 0x414u, 0xAu, 0);
    SendDlgItemMessageW(hWnd, *v3, 0x406u, 1u, 16711680);
    SendDlgItemMessageW(hWnd, v3[1], 0xC5u, 3u, 0);
    v3 += 3;
  }
  while ( (int)v3 < (int)&dword_4EF178 );
  v4 = &dword_4EF178;
  do
  {
    SendDlgItemMessageW(hWnd, *v4, 0x414u, 0xAu, 0);
    SendDlgItemMessageW(hWnd, *v4, 0x406u, 1u, 16711680);
    SendDlgItemMessageW(hWnd, v4[1], 0xC5u, 3u, 0);
    v4 += 3;
  }
  while ( (int)v4 < (int)&dword_4EF19C );
  wParam = SendMessageW(*(HWND *)(v23 + 64), 0x8067u, 0, 0);
  v21 = SendMessageW(*(HWND *)(v23 + 64), 0x806Bu, 0, 0);
  SendMessageW(*(HWND *)(v23 + 64), 0x806Fu, (WPARAM)&::wParam, 0);
  dword_4EF14C = SendMessageW(*(HWND *)(v23 + 64), 0x8071u, 0, 0);
  hWnda = GetDlgItem(hWnd, 1118);
  Param = -16777216;
  v13 = -16777216;
  ModuleHandleW = GetModuleHandleW(0);
  ImageW = (HICON)LoadImageW(ModuleHandleW, (LPCWSTR)0x6A, 1u, 0, 0, 0x2000u);
  Param = *(_DWORD *)(v23 + 5656);
  v13 = *(_DWORD *)(v23 + 5660);
  v7 = *(_DWORD *)(v23 + 5664);
  v8 = *(_DWORD *)(v23 + 5668);
  dword_4EF148 = ImageW;
  v14 = v7;
  v15 = v8;
  v16 = ImageW;
  sub_41A510();
  v9 = GetModuleHandleW(0);
  dword_4EF19C = sub_418180(L"DisplayWindow", &word_4CC4F8, 0x54000000u, 0, 0, 0, 0, hWnda, v9, &Param);
  v10 = (unsigned __int8)wParam;
  *(_DWORD *)(v23 + 1316) = 0;
  lParam = v10;
  SetDlgItemInt(hWnd, 1105, v10, 0);
  v18 = BYTE1(wParam);
  SetDlgItemInt(hWnd, 1106, BYTE1(wParam), 0);
  v19 = BYTE2(wParam);
  SetDlgItemInt(hWnd, 1107, BYTE2(wParam), 0);
  SendDlgItemMessageW(hWnd, 1104, 0x405u, 1u, lParam);
  SendDlgItemMessageW(hWnd, 1102, 0x405u, 1u, v18);
  SendDlgItemMessageW(hWnd, 1103, 0x405u, 1u, v19);
  v19 = (unsigned __int8)v21;
  SetDlgItemInt(hWnd, 1111, (unsigned __int8)v21, 0);
  v18 = BYTE1(v21);
  SetDlgItemInt(hWnd, 1112, BYTE1(v21), 0);
  lParam = BYTE2(v21);
  SetDlgItemInt(hWnd, 1113, BYTE2(v21), 0);
  SendDlgItemMessageW(hWnd, 1108, 0x405u, 1u, v19);
  SendDlgItemMessageW(hWnd, 1109, 0x405u, 1u, v18);
  SendDlgItemMessageW(hWnd, 1110, 0x405u, 1u, lParam);
  SendMessageW(dword_4EF19C, 0x8068u, wParam, 0);
  SendMessageW(dword_4EF19C, 0x806Cu, v21, 0);
  SendMessageW(dword_4EF19C, 0x8070u, ::wParam, 0);
  SendMessageW(dword_4EF19C, 0x8072u, dword_4EF14C, 0);
  SendMessageW(dword_4EF19C, 0x8074u, 0, 0);
  SendMessageW(dword_4EF19C, 0x8073u, 0, (LPARAM)L"Filename");
  SendMessageW(dword_4EF19C, 0x8073u, 0, (LPARAM)L"File Type");
  SendMessageW(dword_4EF19C, 0x8073u, 0, (LPARAM)L"Modification Date");
  GetWindowRect(hWnda, &Rect);
  SetWindowPos(dword_4EF19C, 0, 0, 0, Rect.right, Rect.bottom, 0x44u);
  if ( *(_DWORD *)(v23 + 61216) )
    return SetWindowPos(hWnd, 0, *(_DWORD *)(v23 + 61220), *(_DWORD *)(v23 + 61224), 0, 0, 5u);
  else
    return sub_4697F0(hWnd, *(HWND *)(v23 + 52));
}
// 4CB250: using guessed type wchar_t aFilename[9];
// 4CB264: using guessed type wchar_t aFileType[10];
// 4CB278: using guessed type wchar_t aModificationDa[18];
// 4EF154: using guessed type int dword_4EF154;
// 4EF158: using guessed type int dword_4EF158;
// 4EF160: using guessed type int dword_4EF160;
// 4EF164: using guessed type int dword_4EF164;
// 4EF16C: using guessed type int dword_4EF16C;
// 4EF170: using guessed type int dword_4EF170;
// 4EF178: using guessed type int dword_4EF178;
// 4EF17C: using guessed type int dword_4EF17C;
// 4EF184: using guessed type int dword_4EF184;
// 4EF188: using guessed type int dword_4EF188;
// 4EF190: using guessed type int dword_4EF190;
// 4EF194: using guessed type int dword_4EF194;

//----- (004A2F60) --------------------------------------------------------
int __fastcall sub_4A2F60(unsigned int a1, HWND a2, unsigned int a3, HWND hWnd)
{
  _DWORD *v4; // edi
  unsigned __int16 v5; // bx
  LONG v7; // edx
  LONG top; // ecx
  int v9; // ebx
  HFONT FontW; // eax
  HWND v11; // edx
  int wParam; // [esp+Ch] [ebp-24h]
  struct tagRECT Rect; // [esp+1Ch] [ebp-14h] BYREF

  v4 = (_DWORD *)dword_4EF7E0;
  v5 = a1;
  if ( a3 > 0x110 )
  {
    if ( a3 == 273 )
    {
      if ( HIWORD(a1) == 768 )
        sub_4A25D0(hWnd, a2);
      if ( v5 > 0x41Fu )
      {
        if ( v5 == 1217 )
        {
          v4[1415] = -16753014;
          v4[1414] = -1;
          v9 = (unsigned __int8)BYTE2(v4[1415]) | ((((unsigned __int8)v4[1415] << 8) | (unsigned __int8)BYTE1(v4[1415])) << 8);
          wParam = (unsigned __int8)BYTE2(v4[1414]) | ((((unsigned __int8)v4[1414] << 8) | (unsigned __int8)BYTE1(v4[1414])) << 8);
          FontW = CreateFontW(-13, 0, 0, 0, 500, 0, 0, 0, 1u, 0, 0, 2u, 0x31u, L"Segoe UI");
          v11 = dword_4EF19C;
          v4[1417] = FontW;
          ::wParam = (WPARAM)FontW;
          SendMessageW(v11, 0x8068u, v9, 0);
          SendMessageW(dword_4EF19C, 0x806Cu, wParam, 0);
          SendMessageW(dword_4EF19C, 0x8070u, ::wParam, 0);
          SendMessageW(dword_4EF19C, 0x8072u, dword_4EF14C, 0);
          SetDlgItemInt(a2, 1105, (unsigned __int8)v9, 0);
          SetDlgItemInt(a2, 1106, BYTE1(v9), 0);
          SetDlgItemInt(a2, 1107, BYTE2(v9), 0);
          SendDlgItemMessageW(a2, 1104, 0x405u, 1u, (unsigned __int8)v9);
          SendDlgItemMessageW(a2, 1102, 0x405u, 1u, BYTE1(v9));
          SendDlgItemMessageW(a2, 1103, 0x405u, 1u, BYTE2(v9));
          SetDlgItemInt(a2, 1111, (unsigned __int8)wParam, 0);
          SetDlgItemInt(a2, 1112, BYTE1(wParam), 0);
          SetDlgItemInt(a2, 1113, BYTE2(wParam), 0);
          SendDlgItemMessageW(a2, 1108, 0x405u, 1u, (unsigned __int8)wParam);
          SendDlgItemMessageW(a2, 1109, 0x405u, 1u, BYTE1(wParam));
          SendDlgItemMessageW(a2, 1110, 0x405u, 1u, BYTE2(wParam));
          SendMessageW(dword_4EF19C, 0x8068u, v9, 0);
          SendMessageW(dword_4EF19C, 0x806Cu, wParam, 0);
          SendMessageW(dword_4EF19C, 0x8070u, ::wParam, 0);
          SendMessageW(dword_4EF19C, 0x8072u, dword_4EF14C, 0);
        }
      }
      else
      {
        switch ( v5 )
        {
          case 0x41Fu:
            sub_4A2A10((DWORD)a2);
            return 0;
          case 1u:
            sub_4A28D0((int)v4, a2);
            return 0;
          case 2u:
            GetWindowRect(a2, &Rect);
            top = Rect.top;
            v4[15305] = Rect.left;
            v4[15306] = top;
            goto LABEL_18;
        }
      }
    }
    else if ( a3 == 276 )
    {
      sub_4A2770(a2);
    }
  }
  else
  {
    switch ( a3 )
    {
      case 0x110u:
        sub_4A2B10(a2, dword_4EF7E0);
        break;
      case 2u:
        DestroyIcon(dword_4EF148);
        break;
      case 0x10u:
        GetWindowRect(a2, &Rect);
        v7 = Rect.top;
        v4[15305] = Rect.left;
        v4[15306] = v7;
LABEL_18:
        v4[15304] = 1;
        EndDialog(a2, 0);
        break;
    }
  }
  return 0;
}

//----- (004A3300) --------------------------------------------------------
int __stdcall sub_4A3300(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 272 )
    dword_4EF7E0 = a4;
  return sub_4A2F60(a3, a1, a2, (HWND)a4);
}

//----- (004A3330) --------------------------------------------------------
int __thiscall sub_4A3330(_DWORD *this, LPCWSTR lpString1, wchar_t *String)
{
  int result; // eax

  result = lstrcmpiW(lpString1, L"OverwriteMethod");
  if ( !result )
  {
    result = _wtoi(String);
    this[135] = result;
  }
  return result;
}

//----- (004A3360) --------------------------------------------------------
LSTATUS __thiscall sub_4A3360(BYTE *this, HKEY hKey)
{
  DWORD cbData; // [esp+0h] [ebp-4h] BYREF

  cbData = 4;
  return RegQueryValueExW(hKey, L"OverwriteMethod", 0, 0, this + 540, &cbData);
}

//----- (004A3390) --------------------------------------------------------
LSTATUS __thiscall sub_4A3390(_DWORD *this, HKEY hKey)
{
  BYTE Data[4]; // [esp+0h] [ebp-4h] BYREF

  *(_DWORD *)Data = this;
  *(_DWORD *)Data = this[135];
  return RegSetValueExW(hKey, L"OverwriteMethod", 0, 4u, Data, 4u);
}

//----- (004A33E0) --------------------------------------------------------
int __thiscall sub_4A33E0(HICON *this)
{
  DestroyIcon(this[15]);
  return 0;
}

//----- (004A33F0) --------------------------------------------------------
int __thiscall sub_4A33F0(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (004A3400) --------------------------------------------------------
HGDIOBJ __thiscall sub_4A3400(HWND *this, int a2, HDC hdc)
{
  if ( (HWND)a2 != GetDlgItem(this[1], 1305) )
    return 0;
  SetTextColor(hdc, 0xFFu);
  SetBkMode(hdc, 1);
  return GetStockObject(5);
}

//----- (004A3450) --------------------------------------------------------
HRESULT __thiscall sub_4A3450(int *this, int a2, int a3)
{
  _itow_s(this[135], Buffer, 0x40u, 10);
  return sub_464A60(a2, a3, (OLECHAR *)L"OverwriteMethod", Buffer);
}
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (004A3490) --------------------------------------------------------
int __thiscall sub_4A3490(int this)
{
  _DWORD *v2; // edi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int v7; // eax
  UINT v8; // eax
  int v9; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 64);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  v7 = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = v7;
  v8 = IsDlgButtonChecked(*(HWND *)(this + 4), 1073);
  v9 = *(_DWORD *)(this + 64);
  if ( v8 == 1 )
    *(_DWORD *)(v9 + 540) = 1;
  else
    *(_DWORD *)(v9 + 540) = 2;
  result = *(_DWORD *)(this + 64);
  *(_DWORD *)(result + 4) = 1;
  return result;
}

//----- (004A3550) --------------------------------------------------------
char **__stdcall sub_4A3550(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char *v4; // eax
  char **v5; // eax
  char *v6; // ecx
  char **v7; // eax
  char *v8; // ecx
  char **v9; // eax
  char *v10; // ecx
  char **v11; // eax
  char *v12; // ecx
  char **v13; // eax
  char *v14; // ecx
  char *v15; // eax
  char **v16; // eax
  char *v17; // ecx
  char **v18; // eax
  char *v19; // ecx
  char **v20; // eax
  char *v21; // ecx
  char *v22; // ebx
  char **result; // eax
  char *v24; // ecx
  char *v25; // [esp-8h] [ebp-20h]
  char *v26; // [esp-8h] [ebp-20h]
  char *v27; // [esp-8h] [ebp-20h]
  char *v28; // [esp-8h] [ebp-20h]
  char *v29; // [esp-8h] [ebp-20h]
  char *v30; // [esp-8h] [ebp-20h]
  char *v31; // [esp-8h] [ebp-20h]
  char *v32; // [esp-8h] [ebp-20h]
  int v33; // [esp-4h] [ebp-1Ch]
  int v34; // [esp-4h] [ebp-1Ch]
  int v35; // [esp-4h] [ebp-1Ch]
  int v36; // [esp-4h] [ebp-1Ch]
  int v37; // [esp-4h] [ebp-1Ch]
  int v38; // [esp-4h] [ebp-1Ch]
  int v39; // [esp-4h] [ebp-1Ch]
  int v40; // [esp-4h] [ebp-1Ch]
  int v41; // [esp-4h] [ebp-1Ch]
  int v42; // [esp-4h] [ebp-1Ch]
  int v43; // [esp+Ch] [ebp-Ch] BYREF
  int v44; // [esp+10h] [ebp-8h]
  int v45; // [esp+14h] [ebp-4h]
  char *v46; // [esp+20h] [ebp+8h]
  char *v47; // [esp+20h] [ebp+8h]
  char *v48; // [esp+20h] [ebp+8h]
  char *v49; // [esp+20h] [ebp+8h]
  char *v50; // [esp+20h] [ebp+8h]
  char *v51; // [esp+20h] [ebp+8h]
  char *v52; // [esp+20h] [ebp+8h]
  char *v53; // [esp+20h] [ebp+8h]
  char *v54; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v33 = *((_DWORD *)*a2 + 1);
  v25 = *a2;
  v43 = 1145;
  v44 = 1;
  v45 = 0;
  v46 = v25;
  v2 = sub_41EEB0((char **)&v43, v25, v33);
  v3 = a2[1];
  if ( v3 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v46 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v4 = *a2;
  v44 = 1;
  v45 = 1;
  v34 = *((_DWORD *)v4 + 1);
  v43 = 1306;
  v47 = v4;
  v5 = sub_41EEB0((char **)&v43, v4, v34);
  v6 = a2[1];
  if ( v6 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v6 + 1;
  *((_DWORD *)v47 + 1) = v5;
  *(_DWORD *)v5[1] = v5;
  v35 = *((_DWORD *)*a2 + 1);
  v26 = *a2;
  v43 = 1306;
  v44 = 0;
  v45 = 2;
  v48 = v26;
  v7 = sub_41EEB0((char **)&v43, v26, v35);
  v8 = a2[1];
  if ( v8 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v8 + 1;
  *((_DWORD *)v48 + 1) = v7;
  *(_DWORD *)v7[1] = v7;
  v36 = *((_DWORD *)*a2 + 1);
  v27 = *a2;
  v43 = 1073;
  v44 = 0;
  v45 = 2;
  v49 = v27;
  v9 = sub_41EEB0((char **)&v43, v27, v36);
  v10 = a2[1];
  if ( v10 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v10 + 1;
  *((_DWORD *)v49 + 1) = v9;
  *(_DWORD *)v9[1] = v9;
  v37 = *((_DWORD *)*a2 + 1);
  v28 = *a2;
  v43 = 1074;
  v44 = 0;
  v45 = 2;
  v50 = v28;
  v11 = sub_41EEB0((char **)&v43, v28, v37);
  v12 = a2[1];
  if ( v12 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v12 + 1;
  *((_DWORD *)v50 + 1) = v11;
  *(_DWORD *)v11[1] = v11;
  v38 = *((_DWORD *)*a2 + 1);
  v29 = *a2;
  v43 = 1305;
  v44 = 0;
  v45 = 2;
  v51 = v29;
  v13 = sub_41EEB0((char **)&v43, v29, v38);
  v14 = a2[1];
  if ( v14 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v14 + 1;
  *((_DWORD *)v51 + 1) = v13;
  *(_DWORD *)v13[1] = v13;
  v15 = *a2;
  v44 = 1;
  v45 = 1;
  v39 = *((_DWORD *)v15 + 1);
  v43 = 1305;
  v52 = v15;
  v16 = sub_41EEB0((char **)&v43, v15, v39);
  v17 = a2[1];
  if ( v17 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v17 + 1;
  *((_DWORD *)v52 + 1) = v16;
  *(_DWORD *)v16[1] = v16;
  v40 = *((_DWORD *)*a2 + 1);
  v30 = *a2;
  v43 = 1;
  v44 = 0;
  v45 = 0;
  v53 = v30;
  v18 = sub_41EEB0((char **)&v43, v30, v40);
  v19 = a2[1];
  if ( v19 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v19 + 1;
  *((_DWORD *)v53 + 1) = v18;
  *(_DWORD *)v18[1] = v18;
  v41 = *((_DWORD *)*a2 + 1);
  v31 = *a2;
  v43 = 2;
  v44 = 0;
  v45 = 0;
  v54 = v31;
  v20 = sub_41EEB0((char **)&v43, v31, v41);
  v21 = a2[1];
  if ( v21 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v21 + 1;
  *((_DWORD *)v54 + 1) = v20;
  *(_DWORD *)v20[1] = v20;
  v44 = 0;
  v45 = 0;
  v22 = *a2;
  v42 = *((_DWORD *)*a2 + 1);
  v32 = *a2;
  v43 = 1304;
  result = sub_41EEB0((char **)&v43, v32, v42);
  v24 = a2[1];
  if ( v24 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v24 + 1;
  *((_DWORD *)v22 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (004A3850) --------------------------------------------------------
void __usercall sub_4A3850(_DWORD *a1@<eax>)
{
  void **v2; // ebx
  void *v3; // esi

  v2 = (void **)(a1 + 12);
  *a1 = &CDestroyFilesDialog::`vftable';
  sub_40A140((int)(a1 + 12));
  operator delete(*v2);
  *a1 = &CBaseDialog::`vftable';
  v3 = (void *)a1[11];
  if ( v3 )
  {
    sub_4AAAD0((int)v3);
    operator delete(v3);
  }
}
// 4CBBC8: using guessed type void *CDestroyFilesDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (004A3890) --------------------------------------------------------
int *sub_4A3890()
{
  int *result; // eax

  result = &dword_4F1088;
  if ( (dword_4F2208 & 1) == 0 )
  {
    dword_4F2208 |= 1u;
    sub_4653E0((int)&dword_4F1088, (int)L"DestroyFiles");
    dword_4F1088 = (int)&CDestroyFilesDialogPersistentSettings::`vftable';
    dword_4F12A4 = 1;
    atexit(sub_4BCBF0);
    return &dword_4F1088;
  }
  return result;
}
// 4CB2B4: using guessed type wchar_t aDestroyfiles[13];
// 4CBC00: using guessed type void *CDestroyFilesDialogPersistentSettings::`vftable';
// 4F1088: using guessed type int dword_4F1088;
// 4F12A4: using guessed type int dword_4F12A4;
// 4F2208: using guessed type int dword_4F2208;

//----- (004A38E0) --------------------------------------------------------
BOOL __thiscall sub_4A38E0(int this)
{
  UINT v2; // eax
  _DWORD *v3; // ebx
  _DWORD *v4; // edi
  int i; // esi
  WCHAR FileName[2]; // [esp+10h] [ebp-20h] BYREF
  int v9; // [esp+20h] [ebp-10h]
  unsigned int v10; // [esp+24h] [ebp-Ch]

  v2 = IsDlgButtonChecked(*(HWND *)(this + 4), 1073);
  v3 = *(_DWORD **)(this + 48);
  v4 = (_DWORD *)*v3;
  for ( i = (v2 != 1) + 1; v4 != v3; v4 = (_DWORD *)*v4 )
  {
    FileName[0] = 0;
    v10 = 7;
    v9 = 0;
    sub_4090E0((int)FileName, v4 + 2, 0, 0xFFFFFFFF);
    sub_4ADD50(i);
    if ( v10 >= 8 )
      operator delete(*(void **)FileName);
  }
  return EndDialog(*(HWND *)(this + 4), 1);
}

//----- (004A3990) --------------------------------------------------------
BOOL __usercall sub_4A3990@<eax>(int a1@<esi>)
{
  WCHAR Buffer[128]; // [esp+0h] [ebp-104h] BYREF

  LoadStringW(*(HINSTANCE *)(a1 + 8), 0x855u, Buffer, 128);
  if ( MessageBoxW(*(HWND *)(a1 + 4), Buffer, L"Explorer++", 0x10134u) == 6 )
    return sub_4A38E0(a1);
  else
    return EndDialog(*(HWND *)(a1 + 4), 0);
}

//----- (004A3A10) --------------------------------------------------------
int __thiscall sub_4A3A10(HWND *this, __int16 a2, int a3)
{
  if ( a2 == 1 )
  {
    sub_4A3990((int)this);
  }
  else if ( a2 == 2 )
  {
    EndDialog(this[1], 0);
    return 0;
  }
  return 0;
}

//----- (004A3A40) --------------------------------------------------------
int __thiscall sub_4A3A40(void *this, int a2, void *a3, int a4, int a5, int a6)
{
  char ***v6; // ebx
  char **v7; // eax
  void *v8; // edi
  bool v9; // zf
  int pExceptionObject[3]; // [esp+10h] [ebp-20h] BYREF
  char *v12; // [esp+1Ch] [ebp-14h] BYREF
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v14 = 0;
  *(_DWORD *)(a2 + 8) = hInstance;
  *(_DWORD *)(a2 + 12) = 170;
  *(_DWORD *)(a2 + 16) = this;
  *(_BYTE *)(a2 + 28) = 1;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  LOBYTE(v14) = 1;
  *(_DWORD *)a2 = &CDestroyFilesDialog::`vftable';
  v6 = (char ***)(a2 + 48);
  *(_DWORD *)(a2 + 52) = 0;
  v7 = (char **)operator new(0x24u);
  if ( !v7 )
  {
    v12 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v6 = v7;
  *v7 = (char *)v7;
  (*v6)[1] = (char *)*v6;
  LOBYTE(v14) = 2;
  if ( v6 != (char ***)&a3 )
  {
    v8 = a3;
    v13 = *(_DWORD *)a3;
    sub_40A140((int)v6);
    sub_40B6E0(a2 + 48, **v6, v13, (int)v8, a2);
  }
  v9 = (dword_4F2208 & 1) == 0;
  *(_DWORD *)(a2 + 68) = a6;
  if ( v9 )
  {
    dword_4F2208 |= 1u;
    sub_4653E0((int)&dword_4F1088, (int)L"DestroyFiles");
    dword_4F1088 = (int)&CDestroyFilesDialogPersistentSettings::`vftable';
    dword_4F12A4 = 1;
    atexit(sub_4BCBF0);
  }
  *(_DWORD *)(a2 + 64) = &dword_4F1088;
  sub_40A140((int)&a3);
  operator delete(a3);
  return a2;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CB2B4: using guessed type wchar_t aDestroyfiles[13];
// 4CBBC8: using guessed type void *CDestroyFilesDialog::`vftable';
// 4CBC00: using guessed type void *CDestroyFilesDialogPersistentSettings::`vftable';
// 4F1088: using guessed type int dword_4F1088;
// 4F12A4: using guessed type int dword_4F12A4;
// 4F2208: using guessed type int dword_4F2208;

//----- (004A3B90) --------------------------------------------------------
int __thiscall sub_4A3B90(void *this)
{
  void *v1; // edi
  HMODULE ModuleHandleW; // eax
  HICON IconW; // eax
  HWND DlgItem; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  void **v7; // edx
  WCHAR *v8; // eax
  int v9; // edx
  WCHAR v10; // cx
  HWND v11; // esi
  _DWORD *v12; // edi
  HWND Parent; // eax
  LPARAM wParam; // [esp+14h] [ebp-738h]
  int v16; // [esp+18h] [ebp-734h]
  _DWORD *v17; // [esp+1Ch] [ebp-730h]
  HIMAGELIST phimlSmall; // [esp+24h] [ebp-728h] BYREF
  _DWORD *v20; // [esp+28h] [ebp-724h]
  LPARAM lParam[3]; // [esp+2Ch] [ebp-720h] BYREF
  WCHAR *v22; // [esp+38h] [ebp-714h]
  LPARAM v23[2]; // [esp+4Ch] [ebp-700h] BYREF
  int v24; // [esp+54h] [ebp-6F8h]
  char *szTypeName; // [esp+60h] [ebp-6ECh]
  LPARAM v26[13]; // [esp+80h] [ebp-6CCh] BYREF
  void *v27[5]; // [esp+B4h] [ebp-698h] BYREF
  unsigned int v28; // [esp+C8h] [ebp-684h]
  char FileInformation[20]; // [esp+D0h] [ebp-67Ch] BYREF
  FILETIME FileTime; // [esp+E4h] [ebp-668h] BYREF
  unsigned int v31; // [esp+ECh] [ebp-660h]
  unsigned int v32; // [esp+F0h] [ebp-65Ch]
  SHFILEINFOW psfi; // [esp+F4h] [ebp-658h] BYREF
  char v34; // [esp+3ACh] [ebp-3A0h] BYREF
  __int16 v35[32]; // [esp+3ECh] [ebp-360h] BYREF
  WCHAR Buffer[128]; // [esp+42Ch] [ebp-320h] BYREF
  WCHAR pszPath[262]; // [esp+52Ch] [ebp-220h] BYREF
  int v38; // [esp+748h] [ebp-4h]

  v1 = this;
  ModuleHandleW = GetModuleHandleW(0);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *((_DWORD *)v1 + 15) = IconW;
  SetClassLongW(*((HWND *)v1 + 1), -34, (LONG)IconW);
  DlgItem = GetDlgItem(*((HWND *)v1 + 1), 1145);
  Shell_GetImageLists(0, &phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1u, (LPARAM)phimlSmall);
  SetWindowTheme(DlgItem, L"Explorer", 0);
  SendMessageW(DlgItem, 0x1036u, 0x10021u, 65569);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x856u, Buffer, 128);
  lParam[0] = 4;
  v22 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x857u, Buffer, 128);
  lParam[0] = 4;
  v22 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1u, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x858u, Buffer, 128);
  lParam[0] = 4;
  v22 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2u, (LPARAM)lParam);
  LoadStringW(*((HINSTANCE *)v1 + 2), 0x859u, Buffer, 128);
  lParam[0] = 4;
  v22 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 3u, (LPARAM)lParam);
  v5 = (_DWORD *)*((_DWORD *)v1 + 12);
  v6 = (_DWORD *)*v5;
  wParam = 0;
  v20 = v5;
  v17 = v6;
  if ( v6 != v5 )
  {
    while ( 2 )
    {
      LOWORD(v27[0]) = 0;
      v28 = 7;
      v27[4] = 0;
      sub_4090E0((int)v27, v6 + 2, 0, 0xFFFFFFFF);
      v38 = 0;
      v7 = (void **)v27[0];
      if ( v28 < 8 )
        v7 = v27;
      v8 = pszPath;
      v16 = 260;
      v9 = (char *)v7 - (char *)pszPath;
      while ( v16 != -2147483386 )
      {
        v10 = *(WCHAR *)((char *)v8 + v9);
        if ( !v10 )
          break;
        *v8++ = v10;
        if ( !--v16 )
        {
          --v8;
          break;
        }
      }
      *v8 = 0;
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4400u);
      v26[1] = wParam;
      v26[0] = 3;
      v26[2] = 0;
      v26[5] = (LPARAM)pszPath;
      v26[7] = psfi.iIcon;
      SendMessageW(DlgItem, 0x104Du, 0, (LPARAM)v26);
      v24 = 1;
      szTypeName = (char *)psfi.szTypeName;
      SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v23);
      GetFileAttributesExW(pszPath, GetFileExInfoStandard, FileInformation);
      sub_46B2E0(0x20u, 0, 0, __PAIR64__(v31, v32));
      v24 = 2;
      szTypeName = &v34;
      SendMessageW(DlgItem, 0x1074u, wParam, (LPARAM)v23);
      sub_46AB90(v35, 32, &FileTime, *((_DWORD *)v1 + 17));
      v24 = 3;
      szTypeName = (char *)v35;
      SendMessageW(DlgItem, 0x1074u, wParam++, (LPARAM)v23);
      v38 = -1;
      if ( v28 >= 8 )
        operator delete(v27[0]);
      v1 = this;
      v17 = (_DWORD *)*v17;
      if ( v17 != v20 )
      {
        v6 = v17;
        continue;
      }
      break;
    }
  }
  SendMessageW(DlgItem, 0x101Eu, 0, 65534);
  SendMessageW(DlgItem, 0x101Eu, 1u, 65534);
  SendMessageW(DlgItem, 0x101Eu, 2u, 65534);
  SendMessageW(DlgItem, 0x101Eu, 3u, 65534);
  if ( *(_DWORD *)(*((_DWORD *)v1 + 16) + 540) == 1 )
  {
    CheckDlgButton(*((HWND *)v1 + 1), 1073, 1u);
  }
  else if ( *(_DWORD *)(*((_DWORD *)v1 + 16) + 540) == 2 )
  {
    CheckDlgButton(*((HWND *)v1 + 1), 1074, 1u);
  }
  v11 = (HWND)*((_DWORD *)v1 + 1);
  v12 = (_DWORD *)*((_DWORD *)v1 + 16);
  if ( v12[1] )
  {
    SetWindowPos(v11, 0, v12[2], v12[3], v12[4], v12[5], 4u);
  }
  else
  {
    Parent = GetParent(v11);
    sub_4697F0(v11, Parent);
  }
  return 0;
}
// 4A3DF9: conditional instruction was optimized away because %var_734.4!=0
// 4A3B90: using guessed type char FileInformation[20];
// 4A3B90: using guessed type _WORD var_360[32];

//----- (004A4080) --------------------------------------------------------
int __thiscall sub_4A4080(HICON *this)
{
  DestroyIcon(this[12]);
  return 0;
}

//----- (004A4090) --------------------------------------------------------
int __thiscall sub_4A4090(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (004A40A0) --------------------------------------------------------
int __thiscall sub_4A40A0(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 56);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 56) + 4) = 1;
  return result;
}

//----- (004A4100) --------------------------------------------------------
char **__stdcall sub_4A4100(_DWORD *a1, char **a2)
{
  char **v2; // eax
  char *v3; // ecx
  char **v4; // eax
  char *v5; // ecx
  char **v6; // eax
  char *v7; // ecx
  char **v8; // eax
  char *v9; // ecx
  char **v10; // eax
  char *v11; // ecx
  char **v12; // eax
  char *v13; // ecx
  char **v14; // eax
  char *v15; // ecx
  char **v16; // eax
  char *v17; // ecx
  char *v18; // ebx
  char **result; // eax
  char *v20; // ecx
  char *v21; // [esp-8h] [ebp-20h]
  char *v22; // [esp-8h] [ebp-20h]
  char *v23; // [esp-8h] [ebp-20h]
  char *v24; // [esp-8h] [ebp-20h]
  char *v25; // [esp-8h] [ebp-20h]
  char *v26; // [esp-8h] [ebp-20h]
  char *v27; // [esp-8h] [ebp-20h]
  char *v28; // [esp-8h] [ebp-20h]
  char *v29; // [esp-8h] [ebp-20h]
  int v30; // [esp-4h] [ebp-1Ch]
  int v31; // [esp-4h] [ebp-1Ch]
  int v32; // [esp-4h] [ebp-1Ch]
  int v33; // [esp-4h] [ebp-1Ch]
  int v34; // [esp-4h] [ebp-1Ch]
  int v35; // [esp-4h] [ebp-1Ch]
  int v36; // [esp-4h] [ebp-1Ch]
  int v37; // [esp-4h] [ebp-1Ch]
  int v38; // [esp-4h] [ebp-1Ch]
  int v39; // [esp+Ch] [ebp-Ch] BYREF
  int v40; // [esp+10h] [ebp-8h]
  int v41; // [esp+14h] [ebp-4h]
  char *v42; // [esp+20h] [ebp+8h]
  char *v43; // [esp+20h] [ebp+8h]
  char *v44; // [esp+20h] [ebp+8h]
  char *v45; // [esp+20h] [ebp+8h]
  char *v46; // [esp+20h] [ebp+8h]
  char *v47; // [esp+20h] [ebp+8h]
  char *v48; // [esp+20h] [ebp+8h]
  char *v49; // [esp+20h] [ebp+8h]

  *a1 = 0;
  v30 = *((_DWORD *)*a2 + 1);
  v21 = *a2;
  v39 = 1245;
  v40 = 1;
  v41 = 0;
  v42 = v21;
  v2 = sub_41EEB0((char **)&v39, v21, v30);
  v3 = a2[1];
  if ( v3 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v3 + 1;
  *((_DWORD *)v42 + 1) = v2;
  *(_DWORD *)v2[1] = v2;
  v31 = *((_DWORD *)*a2 + 1);
  v22 = *a2;
  v39 = 1232;
  v40 = 0;
  v41 = 1;
  v43 = v22;
  v4 = sub_41EEB0((char **)&v39, v22, v31);
  v5 = a2[1];
  if ( v5 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v5 + 1;
  *((_DWORD *)v43 + 1) = v4;
  *(_DWORD *)v4[1] = v4;
  v32 = *((_DWORD *)*a2 + 1);
  v23 = *a2;
  v39 = 1234;
  v40 = 0;
  v41 = 1;
  v44 = v23;
  v6 = sub_41EEB0((char **)&v39, v23, v32);
  v7 = a2[1];
  if ( v7 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v7 + 1;
  *((_DWORD *)v44 + 1) = v6;
  *(_DWORD *)v6[1] = v6;
  v33 = *((_DWORD *)*a2 + 1);
  v24 = *a2;
  v39 = 1233;
  v40 = 0;
  v41 = 1;
  v45 = v24;
  v8 = sub_41EEB0((char **)&v39, v24, v33);
  v9 = a2[1];
  if ( v9 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v9 + 1;
  *((_DWORD *)v45 + 1) = v8;
  *(_DWORD *)v8[1] = v8;
  v34 = *((_DWORD *)*a2 + 1);
  v25 = *a2;
  v39 = 1237;
  v40 = 0;
  v41 = 1;
  v46 = v25;
  v10 = sub_41EEB0((char **)&v39, v25, v34);
  v11 = a2[1];
  if ( v11 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v11 + 1;
  *((_DWORD *)v46 + 1) = v10;
  *(_DWORD *)v10[1] = v10;
  v35 = *((_DWORD *)*a2 + 1);
  v26 = *a2;
  v39 = 1243;
  v40 = 0;
  v41 = 1;
  v47 = v26;
  v12 = sub_41EEB0((char **)&v39, v26, v35);
  v13 = a2[1];
  if ( v13 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v13 + 1;
  *((_DWORD *)v47 + 1) = v12;
  *(_DWORD *)v12[1] = v12;
  v36 = *((_DWORD *)*a2 + 1);
  v27 = *a2;
  v39 = 1;
  v40 = 0;
  v41 = 0;
  v48 = v27;
  v14 = sub_41EEB0((char **)&v39, v27, v36);
  v15 = a2[1];
  if ( v15 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v15 + 1;
  *((_DWORD *)v48 + 1) = v14;
  *(_DWORD *)v14[1] = v14;
  v37 = *((_DWORD *)*a2 + 1);
  v28 = *a2;
  v39 = 2;
  v40 = 0;
  v41 = 0;
  v49 = v28;
  v16 = sub_41EEB0((char **)&v39, v28, v37);
  v17 = a2[1];
  if ( v17 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v17 + 1;
  *((_DWORD *)v49 + 1) = v16;
  *(_DWORD *)v16[1] = v16;
  v40 = 0;
  v41 = 0;
  v18 = *a2;
  v38 = *((_DWORD *)*a2 + 1);
  v29 = *a2;
  v39 = 1304;
  result = sub_41EEB0((char **)&v39, v29, v38);
  v20 = a2[1];
  if ( v20 == (char *)357913940 )
    std::_Xlength_error("list<T> too long");
  a2[1] = v20 + 1;
  *((_DWORD *)v18 + 1) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (004A43B0) --------------------------------------------------------
void __usercall sub_4A43B0(_DWORD *a1@<eax>)
{
  void *v1; // esi

  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (004A43F0) --------------------------------------------------------
WPARAM __thiscall sub_4A43F0(HWND hWnd, int a2, int a3)
{
  bool v3; // cf
  int v5; // esi
  __int16 *v6; // eax
  int v7; // edx
  int v8; // esi
  __int16 v9; // cx
  WPARAM result; // eax
  WPARAM v11; // esi
  int v12; // edi
  __int16 *v13; // eax
  int v14; // edx
  int v15; // edi
  __int16 v16; // cx
  HWND v17; // edi
  LPARAM lParam[13]; // [esp+Ch] [ebp-470h] BYREF
  LPARAM v19[2]; // [esp+40h] [ebp-43Ch] BYREF
  int v20; // [esp+48h] [ebp-434h]
  __int16 *v21; // [esp+54h] [ebp-428h]
  HWND hWnda; // [esp+74h] [ebp-408h]
  __int16 v23[512]; // [esp+78h] [ebp-404h] BYREF

  v3 = *(_DWORD *)(a2 + 20) < 8u;
  hWnda = hWnd;
  if ( v3 )
    v5 = a2;
  else
    v5 = *(_DWORD *)a2;
  v6 = v23;
  v7 = 512;
  v8 = v5 - (_DWORD)v23;
  while ( v7 != -2147483134 )
  {
    v9 = *(__int16 *)((char *)v6 + v8);
    if ( !v9 )
      break;
    *v6++ = v9;
    if ( !--v7 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  lParam[2] = 0;
  lParam[0] = 1;
  lParam[5] = (LPARAM)v23;
  lParam[1] = a3;
  result = SendMessageW(hWnd, 0x104Du, 0, (LPARAM)lParam);
  v11 = result;
  if ( result != -1 )
  {
    if ( *(_DWORD *)(a2 + 48) < 8u )
      v12 = a2 + 28;
    else
      v12 = *(_DWORD *)(a2 + 28);
    v13 = v23;
    v14 = 512;
    v15 = v12 - (_DWORD)v23;
    while ( v14 != -2147483134 )
    {
      v16 = *(__int16 *)((char *)v13 + v15);
      if ( !v16 )
        break;
      *v13++ = v16;
      if ( !--v14 )
      {
        --v13;
        break;
      }
    }
    v17 = hWnda;
    *v13 = 0;
    v20 = 1;
    v21 = v23;
    SendMessageW(v17, 0x1074u, v11, (LPARAM)v19);
    sub_46A6F0(*(_DWORD *)(a2 + 56), v23, 0x200u);
    v20 = 2;
    v21 = v23;
    return SendMessageW(v17, 0x1074u, v11, (LPARAM)v19);
  }
  return result;
}
// 4A4450: conditional instruction was optimized away because edx.4!=0
// 4A44E0: conditional instruction was optimized away because edx.4!=0
// 4A43F0: using guessed type _WORD var_404[512];

//----- (004A4570) --------------------------------------------------------
int *sub_4A4570()
{
  if ( (dword_4F220C & 1) == 0 )
  {
    dword_4F220C |= 1u;
    sub_4653E0((int)&dword_4F12A8, (int)L"CustomizeColors");
    dword_4F12A8 = (int)&CCustomizeColorsDialogPersistentSettings::`vftable';
    atexit(sub_4BCBE0);
  }
  return &dword_4F12A8;
}
// 4CB37C: using guessed type wchar_t aCustomizecolor[16];
// 4CBB88: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 4F12A8: using guessed type int dword_4F12A8;
// 4F220C: using guessed type int dword_4F220C;

//----- (004A45B0) --------------------------------------------------------
int __usercall sub_4A45B0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  HINSTANCE v3; // eax
  int result; // eax

  v3 = hInstance;
  *(_DWORD *)(a3 + 16) = a2;
  *(_DWORD *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 12) = 228;
  *(_BYTE *)(a3 + 28) = 1;
  *(_DWORD *)(a3 + 44) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)a3 = &CCustomizeColorsDialog::`vftable';
  *(_DWORD *)(a3 + 52) = a1;
  if ( (dword_4F220C & 1) == 0 )
  {
    dword_4F220C |= 1u;
    sub_4653E0((int)&dword_4F12A8, (int)L"CustomizeColors");
    dword_4F12A8 = (int)&CCustomizeColorsDialogPersistentSettings::`vftable';
    atexit(sub_4BCBE0);
  }
  result = a3;
  *(_DWORD *)(a3 + 56) = &dword_4F12A8;
  return result;
}
// 4CB37C: using guessed type wchar_t aCustomizecolor[16];
// 4CBB50: using guessed type void *CCustomizeColorsDialog::`vftable';
// 4CBB88: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 4F12A8: using guessed type int dword_4F12A8;
// 4F220C: using guessed type int dword_4F220C;

//----- (004A4620) --------------------------------------------------------
void __usercall sub_4A4620(int a1@<ecx>, WPARAM a2@<ebx>)
{
  int v3; // eax
  HINSTANCE v4; // ecx
  HWND v5; // edx
  WPARAM v6; // edi
  HWND DlgItem; // eax
  _DWORD *v8; // edx
  WPARAM *v9; // eax
  WPARAM v10; // edx
  __int16 *v11; // eax
  WPARAM v12; // edx
  __int16 v13; // cx
  int v14; // ecx
  int v15; // edx
  __int16 *v16; // eax
  int v17; // edx
  __int16 v18; // cx
  void *v19; // edi
  int v20; // [esp+8h] [ebp-488h]
  int v21; // [esp+8h] [ebp-488h]
  HWND hWnd; // [esp+Ch] [ebp-484h]
  int dwInitParam[2]; // [esp+10h] [ebp-480h] BYREF
  HINSTANCE hInstance; // [esp+18h] [ebp-478h]
  int v25; // [esp+1Ch] [ebp-474h]
  HWND hWndParent; // [esp+20h] [ebp-470h]
  int v27; // [esp+28h] [ebp-468h]
  char v28; // [esp+2Ch] [ebp-464h]
  void *v29; // [esp+3Ch] [ebp-454h]
  int v30; // [esp+40h] [ebp-450h]
  int v31; // [esp+44h] [ebp-44Ch]
  int *v32; // [esp+4Ch] [ebp-444h]
  LPARAM lParam[2]; // [esp+54h] [ebp-43Ch] BYREF
  int v34; // [esp+5Ch] [ebp-434h]
  __int16 *v35; // [esp+68h] [ebp-428h]
  __int16 v36[514]; // [esp+88h] [ebp-408h] BYREF

  v3 = **(_DWORD **)(a1 + 52);
  v4 = *(HINSTANCE *)(a1 + 8);
  v5 = *(HWND *)(a1 + 4);
  v6 = a2 << 6;
  v31 = (a2 << 6) + v3;
  hInstance = v4;
  v25 = 220;
  hWndParent = v5;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  dwInitParam[0] = (int)&CColorRuleDialog::`vftable';
  v30 = 1;
  if ( (dword_4F2210 & 1) == 0 )
  {
    dword_4F2210 |= 1u;
    sub_4A5390();
    atexit(sub_4BCBD0);
  }
  v32 = &dword_4F14C8;
  if ( DialogBoxParamW(hInstance, (LPCWSTR)(unsigned __int16)v25, hWndParent, DialogFunc, (LPARAM)dwInitParam) == 1 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1245);
    v8 = *(_DWORD **)(a1 + 52);
    hWnd = DlgItem;
    v9 = (WPARAM *)(v6 + *v8);
    if ( v9[5] < 8 )
      v10 = v6 + *v8;
    else
      v10 = *v9;
    v11 = v36;
    v20 = 512;
    v12 = v10 - (_DWORD)v36;
    while ( v20 != -2147483134 )
    {
      v13 = *(__int16 *)((char *)v11 + v12);
      if ( !v13 )
        break;
      *v11++ = v13;
      if ( !--v20 )
      {
        --v11;
        break;
      }
    }
    *v11 = 0;
    v34 = 0;
    v35 = v36;
    SendMessageW(hWnd, 0x1074u, a2, (LPARAM)lParam);
    v14 = **(_DWORD **)(a1 + 52);
    if ( *(_DWORD *)(v14 + v6 + 48) < 8u )
      v15 = v14 + v6 + 28;
    else
      v15 = *(_DWORD *)(v14 + v6 + 28);
    v16 = v36;
    v21 = 512;
    v17 = v15 - (_DWORD)v36;
    while ( v21 != -2147483134 )
    {
      v18 = *(__int16 *)((char *)v16 + v17);
      if ( !v18 )
        break;
      *v16++ = v18;
      if ( !--v21 )
      {
        --v16;
        break;
      }
    }
    *v16 = 0;
    v34 = 1;
    v35 = v36;
    SendMessageW(hWnd, 0x1074u, a2, (LPARAM)lParam);
    sub_46A6F0(*(_DWORD *)(**(_DWORD **)(a1 + 52) + v6 + 56), v36, 0x200u);
    v34 = 2;
    v35 = v36;
    SendMessageW(hWnd, 0x1074u, a2, (LPARAM)lParam);
  }
  dwInitParam[0] = (int)&CBaseDialog::`vftable';
  v19 = v29;
  if ( v29 )
  {
    sub_4AAAD0((int)v29);
    operator delete(v19);
  }
}
// 4A46B1: conditional instruction was optimized away because %var_468.4==0
// 4A4748: conditional instruction was optimized away because %var_488.4!=0
// 4A47C8: conditional instruction was optimized away because %var_488.4!=0
// 4CB9BC: using guessed type void *CColorRuleDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';
// 4F14C8: using guessed type int dword_4F14C8;
// 4F2210: using guessed type int dword_4F2210;
// 4A4620: using guessed type LPARAM dwInitParam[2];
// 4A4620: using guessed type _WORD var_408[514];

//----- (004A4880) --------------------------------------------------------
HWND __usercall sub_4A4880@<eax>(int a1@<esi>)
{
  HWND DlgItem; // eax
  WPARAM v2; // eax

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1245);
  v2 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  if ( v2 != -1 )
    sub_4A4620(a1, v2);
  return SetFocus(*(HWND *)(a1 + 4));
}

//----- (004A48C0) --------------------------------------------------------
int __thiscall sub_4A48C0(void *this, int a2)
{
  WPARAM v2; // ebx

  if ( *(_DWORD *)(a2 + 8) != -3 )
    return 0;
  v2 = *(_DWORD *)(a2 + 12);
  if ( v2 != -1 )
    sub_4A4620((int)this, v2);
  return 0;
}

//----- (004A48F0) --------------------------------------------------------
HWND __thiscall sub_4A48F0(int this)
{
  HWND DlgItem; // esi
  HWND result; // eax
  WPARAM v4; // edi
  _DWORD *v5; // eax
  int v6; // esi
  int v7; // ecx
  HWND v8; // ebx
  LPARAM lParam[13]; // [esp+Ch] [ebp-140h] BYREF
  _DWORD *v10; // [esp+40h] [ebp-10Ch]
  HWND hWnd; // [esp+44h] [ebp-108h]
  WCHAR Buffer[128]; // [esp+48h] [ebp-104h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1245);
  hWnd = DlgItem;
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  v4 = (WPARAM)result;
  if ( result != HWND_MESSAGE|0x2 )
  {
    LoadStringW(*(HINSTANCE *)(this + 8), 0x846u, Buffer, 128);
    if ( MessageBoxW(*(HWND *)(this + 4), Buffer, L"Explorer++", 0x144u) == 6 )
    {
      v5 = *(_DWORD **)(this + 52);
      v6 = v5[1] - *v5;
      v7 = *v5 + (v4 << 6);
      v10 = v5;
      sub_409CA0((_DWORD *)(v7 + 64), v7, (_DWORD *)v5[1]);
      sub_409CF0((_DWORD *)(v10[1] - 64), (_DWORD *)v10[1]);
      v8 = hWnd;
      v10[1] -= 64;
      SendMessageW(v8, 0x1008u, v4, 0);
      if ( v4 == (v6 >> 6) - 1 )
        --v4;
      lParam[4] = 2;
      lParam[3] = 2;
      SendMessageW(v8, 0x102Bu, v4, (LPARAM)lParam);
      DlgItem = v8;
    }
    return SetFocus(DlgItem);
  }
  return result;
}

//----- (004A4A30) --------------------------------------------------------
_DWORD *__stdcall sub_4A4A30(int a1, int a2)
{
  HWND DlgItem; // edi
  _DWORD *result; // eax
  int v4; // esi
  int v5; // ebx

  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1245);
  result = (_DWORD *)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFF, 2);
  v4 = (int)result;
  if ( result != (_DWORD *)-1 )
  {
    if ( a2 )
    {
      if ( !result )
        return result;
      v5 = (int)result - 1;
    }
    else
    {
      result = *(_DWORD **)(a1 + 52);
      if ( v4 == ((result[1] - *result) >> 6) - 1 )
        return result;
      v5 = v4 + 1;
    }
    sub_409B90((_DWORD *)(**(_DWORD **)(a1 + 52) + (v4 << 6)), (_DWORD *)(**(_DWORD **)(a1 + 52) + (v5 << 6)));
    return (_DWORD *)sub_468800(DlgItem, v4, v5);
  }
  return result;
}

//----- (004A4AB0) --------------------------------------------------------
void __thiscall sub_4A4AB0(int this)
{
  HWND DlgItem; // edi
  HWND v3; // ecx
  int v4; // eax
  void *v5; // edi
  int dwInitParam[2]; // [esp+14h] [ebp-98h] BYREF
  HINSTANCE hInstance; // [esp+1Ch] [ebp-90h]
  int v8; // [esp+20h] [ebp-8Ch]
  HWND hWndParent; // [esp+24h] [ebp-88h]
  int v10; // [esp+2Ch] [ebp-80h]
  char v11; // [esp+30h] [ebp-7Ch]
  void *v12; // [esp+40h] [ebp-6Ch]
  int v13; // [esp+44h] [ebp-68h]
  void **v14; // [esp+48h] [ebp-64h]
  int *v15; // [esp+50h] [ebp-5Ch]
  void *v16[5]; // [esp+54h] [ebp-58h] BYREF
  unsigned int v17; // [esp+68h] [ebp-44h]
  void *v18; // [esp+70h] [ebp-3Ch]
  int v19; // [esp+80h] [ebp-2Ch]
  unsigned int v20; // [esp+84h] [ebp-28h]
  int v21; // [esp+A8h] [ebp-4h]

  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1245);
  v17 = 7;
  v16[4] = 0;
  LOWORD(v16[0]) = 0;
  v20 = 7;
  v19 = 0;
  LOWORD(v18) = 0;
  v21 = 0;
  v3 = *(HWND *)(this + 4);
  hInstance = *(HINSTANCE *)(this + 8);
  v8 = 220;
  hWndParent = v3;
  v11 = 0;
  v12 = 0;
  v10 = 0;
  dwInitParam[0] = (int)&CColorRuleDialog::`vftable';
  v14 = v16;
  v13 = 0;
  if ( (dword_4F2210 & 1) == 0 )
  {
    dword_4F2210 |= 1u;
    sub_4A5390();
    atexit(sub_4BCBD0);
  }
  v15 = &dword_4F14C8;
  LOBYTE(v21) = 1;
  if ( DialogBoxParamW(hInstance, (LPCWSTR)(unsigned __int16)v8, hWndParent, DialogFunc, (LPARAM)dwInitParam) == 1 )
  {
    sub_409970(v16, *(_DWORD **)(this + 52));
    v4 = SendMessageW(DlgItem, 0x1004u, 0, 0);
    sub_4A43F0(DlgItem, (int)v16, v4);
  }
  SetFocus(*(HWND *)(this + 4));
  dwInitParam[0] = (int)&CBaseDialog::`vftable';
  v5 = v12;
  if ( v12 )
  {
    sub_4AAAD0((int)v12);
    operator delete(v5);
  }
  if ( v20 >= 8 )
    operator delete(v18);
  v20 = 7;
  v19 = 0;
  LOWORD(v18) = 0;
  if ( v17 >= 8 )
    operator delete(v16[0]);
}
// 4A4BA1: conditional instruction was optimized away because %var_80.4==0
// 4CB9BC: using guessed type void *CColorRuleDialog::`vftable';
// 4CC394: using guessed type void *CBaseDialog::`vftable';
// 4F14C8: using guessed type int dword_4F14C8;
// 4F2210: using guessed type int dword_4F2210;
// 4A4AB0: using guessed type LPARAM dwInitParam[2];

//----- (004A4C90) --------------------------------------------------------
int __thiscall sub_4A4C90(HWND *this, unsigned __int16 a2, int a3)
{
  int result; // eax

  if ( a2 > 0x4D0u )
  {
    switch ( a2 )
    {
      case 0x4D1u:
        sub_4A4A30((int)this, 1);
        result = 0;
        break;
      case 0x4D2u:
        sub_4A4A30((int)this, 0);
        return 0;
      case 0x4D5u:
        sub_4A4880((int)this);
        result = 0;
        break;
      case 0x4DBu:
        sub_4A4AB0((int)this);
        result = 0;
        break;
      default:
        return 0;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 0x4D0u:
        sub_4A48F0((int)this);
        return 0;
      case 1u:
        EndDialog(this[1], 1);
        return 0;
      case 2u:
        EndDialog(this[1], 0);
        return 0;
      default:
        return 0;
    }
  }
  return result;
}

//----- (004A4D50) --------------------------------------------------------
int __thiscall sub_4A4D50(int this)
{
  int v2; // esi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // edi
  LONG v5; // eax
  HWND DlgItem; // esi
  int v7; // eax
  _DWORD *v8; // edi
  int v9; // edx
  HWND v10; // edi
  _DWORD *v11; // ebx
  HWND Parent; // eax
  int v14; // [esp+14h] [ebp-190h]
  _DWORD *v15; // [esp+18h] [ebp-18Ch]
  LPARAM lParam[3]; // [esp+1Ch] [ebp-188h] BYREF
  WCHAR *v17; // [esp+28h] [ebp-17Ch]
  struct tagRECT Rect; // [esp+3Ch] [ebp-168h] BYREF
  void *v19[5]; // [esp+4Ch] [ebp-158h] BYREF
  unsigned int v20; // [esp+60h] [ebp-144h]
  void *v21; // [esp+68h] [ebp-13Ch] BYREF
  int v22; // [esp+78h] [ebp-12Ch]
  unsigned int v23; // [esp+7Ch] [ebp-128h]
  int v24; // [esp+84h] [ebp-120h]
  int v25; // [esp+88h] [ebp-11Ch]
  WCHAR Buffer[130]; // [esp+8Ch] [ebp-118h] BYREF
  int v27; // [esp+1A0h] [ebp-4h]

  v2 = sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v2, (int)BitmapW, 0);
  v5 = sub_409F80(v2, 23, 0);
  *(_DWORD *)(this + 48) = v5;
  SetClassLongW(*(HWND *)(this + 4), -34, v5);
  DeleteObject(BitmapW);
  sub_409E60(v2);
  DlgItem = GetDlgItem(*(HWND *)(this + 4), 1245);
  SetWindowTheme(DlgItem, L"Explorer", 0);
  SendMessageW(DlgItem, 0x1036u, 0x10021u, 65569);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x85Au, Buffer, 128);
  lParam[0] = 4;
  v17 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x85Bu, Buffer, 128);
  lParam[0] = 4;
  v17 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1u, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x85Cu, Buffer, 128);
  lParam[0] = 4;
  v17 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2u, (LPARAM)lParam);
  GetClientRect(DlgItem, &Rect);
  SendMessageW(DlgItem, 0x101Eu, 0, (Rect.right - Rect.left) / 3);
  SendMessageW(DlgItem, 0x101Eu, 1u, (Rect.right - Rect.left) / 3);
  SendMessageW(DlgItem, 0x101Eu, 2u, (Rect.right - Rect.left) / 3);
  v7 = *(_DWORD *)(this + 52);
  v8 = *(_DWORD **)v7;
  v14 = 0;
  v15 = *(_DWORD **)(v7 + 4);
  if ( *(_DWORD **)v7 != v15 )
  {
    do
    {
      LOWORD(v19[0]) = 0;
      v20 = 7;
      v19[4] = 0;
      sub_4090E0((int)v19, v8, 0, 0xFFFFFFFF);
      v27 = 0;
      v22 = 0;
      v23 = 7;
      LOWORD(v21) = 0;
      sub_4090E0((int)&v21, v8 + 7, 0, 0xFFFFFFFF);
      v9 = v8[15];
      v24 = v8[14];
      v25 = v9;
      v27 = -1;
      sub_4A43F0(DlgItem, (int)v19, v14++);
      if ( v23 >= 8 )
        operator delete(v21);
      v23 = 7;
      v22 = 0;
      LOWORD(v21) = 0;
      if ( v20 >= 8 )
        operator delete(v19[0]);
      v8 += 16;
    }
    while ( v8 != v15 );
  }
  SetFocus(DlgItem);
  v10 = *(HWND *)(this + 4);
  v11 = *(_DWORD **)(this + 56);
  if ( v11[1] )
  {
    SetWindowPos(v10, 0, v11[2], v11[3], v11[4], v11[5], 4u);
  }
  else
  {
    Parent = GetParent(v10);
    sub_4697F0(v10, Parent);
  }
  return 0;
}

//----- (004A50A0) --------------------------------------------------------
LSTATUS __thiscall sub_4A50A0(BYTE *this, HKEY hKey)
{
  DWORD cbData; // [esp+Ch] [ebp-4h] BYREF

  cbData = 4;
  RegQueryValueExW(hKey, L"InitialColor", 0, 0, this + 540, &cbData);
  cbData = 64;
  return RegQueryValueExW(hKey, L"CustomColors", 0, 0, this + 544, &cbData);
}

//----- (004A5100) --------------------------------------------------------
LSTATUS __thiscall sub_4A5100(const BYTE *this, HKEY hKey)
{
  RegSetValueExW(hKey, L"InitialColor", 0, 3u, this + 540, 4u);
  return RegSetValueExW(hKey, L"CustomColors", 0, 3u, this + 544, 0x40u);
}

//----- (004A5160) --------------------------------------------------------
int __thiscall sub_4A5160(HWND *this)
{
  EndDialog(this[1], 0);
  return 0;
}

//----- (004A5180) --------------------------------------------------------
int __thiscall sub_4A5180(int this)
{
  _DWORD *v2; // esi
  LONG left; // eax
  LONG right; // edx
  LONG top; // ecx
  int v6; // edx
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-14h] BYREF

  v2 = *(_DWORD **)(this + 60);
  GetWindowRect(*(HWND *)(this + 4), &Rect);
  left = Rect.left;
  right = Rect.right;
  top = Rect.top;
  v2[2] = Rect.left;
  v6 = right - left;
  result = Rect.bottom - top;
  v2[3] = top;
  v2[4] = v6;
  v2[5] = result;
  *(_DWORD *)(*(_DWORD *)(this + 60) + 4) = 1;
  return result;
}

//----- (004A5200) --------------------------------------------------------
HRESULT __thiscall sub_4A5200(unsigned __int8 *this, int a2, int a3)
{
  unsigned int v4; // esi
  HRESULT result; // eax
  unsigned __int8 *v6; // [esp+10h] [ebp-50h]
  OLECHAR psz[34]; // [esp+18h] [ebp-48h] BYREF

  _itow_s(this[540], Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"InitialColor_r", Buffer);
  _itow_s(this[541], Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"InitialColor_g", Buffer);
  _itow_s(this[542], Buffer, 0x40u, 10);
  sub_464A60(a2, a3, (OLECHAR *)L"InitialColor_b", Buffer);
  v4 = 0;
  v6 = this + 544;
  do
  {
    sub_401000(0x20u, psz, L"r%d", v4);
    _itow_s(*v6, Buffer, 0x40u, 10);
    sub_464A60(a2, a3, psz, Buffer);
    sub_401000(0x20u, psz, L"g%d", v4);
    _itow_s(v6[1], Buffer, 0x40u, 10);
    sub_464A60(a2, a3, psz, Buffer);
    sub_401000(0x20u, psz, L"b%d", v4);
    _itow_s(v6[2], Buffer, 0x40u, 10);
    result = sub_464A60(a2, a3, psz, Buffer);
    ++v4;
    v6 += 4;
  }
  while ( v4 < 0x10 );
  return result;
}
// 4CB498: using guessed type wchar_t aRD[4];
// 4CB4A0: using guessed type wchar_t aGD[4];
// 4CB4A8: using guessed type wchar_t aBD[4];
// 4EFC90: using guessed type OLECHAR Buffer[64];

//----- (004A5390) --------------------------------------------------------
int *sub_4A5390()
{
  sub_4653E0((int)&dword_4F14C8, (int)L"ColorRules");
  dword_4F16E8 = 0xFFFFFF;
  dword_4F16EC = 0xFFFFFF;
  dword_4F16F0 = 0xFFFFFF;
  dword_4F16F4 = 0xFFFFFF;
  dword_4F16F8 = 0xFFFFFF;
  dword_4F16FC = 0xFFFFFF;
  dword_4F1700 = 0xFFFFFF;
  dword_4F1704 = 0xFFFFFF;
  dword_4F1708 = 0xFFFFFF;
  dword_4F170C = 0xFFFFFF;
  dword_4F1710 = 0xFFFFFF;
  dword_4F1714 = 0xFFFFFF;
  dword_4F1718 = 0xFFFFFF;
  dword_4F171C = 0xFFFFFF;
  dword_4F1720 = 0xFFFFFF;
  dword_4F1724 = 0xFFFFFF;
  dword_4F14C8 = (int)&CColorRuleDialogPersistentSettings::`vftable';
  dword_4F16E4 = 9068032;
  return &dword_4F14C8;
}
// 4CB3B0: using guessed type wchar_t aColorrules_1[11];
// 4CB9F4: using guessed type void *CColorRuleDialogPersistentSettings::`vftable';
// 4F14C8: using guessed type int dword_4F14C8;
// 4F16E4: using guessed type int dword_4F16E4;
// 4F16E8: using guessed type int dword_4F16E8;
// 4F16EC: using guessed type int dword_4F16EC;
// 4F16F0: using guessed type int dword_4F16F0;
// 4F16F4: using guessed type int dword_4F16F4;
// 4F16F8: using guessed type int dword_4F16F8;
// 4F16FC: using guessed type int dword_4F16FC;
// 4F1700: using guessed type int dword_4F1700;
// 4F1704: using guessed type int dword_4F1704;
// 4F1708: using guessed type int dword_4F1708;
// 4F170C: using guessed type int dword_4F170C;
// 4F1710: using guessed type int dword_4F1710;
// 4F1714: using guessed type int dword_4F1714;
// 4F1718: using guessed type int dword_4F1718;
// 4F171C: using guessed type int dword_4F171C;
// 4F1720: using guessed type int dword_4F1720;
// 4F1724: using guessed type int dword_4F1724;

//----- (004A5410) --------------------------------------------------------
int *sub_4A5410()
{
  if ( (dword_4F2210 & 1) == 0 )
  {
    dword_4F2210 |= 1u;
    sub_4A5390();
    atexit(sub_4BCBD0);
  }
  return &dword_4F14C8;
}
// 4F14C8: using guessed type int dword_4F14C8;
// 4F2210: using guessed type int dword_4F2210;

//----- (004A54A0) --------------------------------------------------------
int __usercall sub_4A54A0@<eax>(int a1@<esi>)
{
  int v1; // edx
  int v2; // ecx
  int result; // eax
  bool v4; // zf
  int v5; // eax
  HWND DlgItem; // eax
  DWORD dwErrCode[3]; // [esp+0h] [ebp-24h] BYREF
  int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+10h] [ebp-14h]
  int v10; // [esp+14h] [ebp-10h]

  v1 = *(_DWORD *)(a1 + 60);
  v2 = *(_DWORD *)(a1 + 56);
  dwErrCode[1] = *(_DWORD *)(a1 + 4);
  dwErrCode[0] = 36;
  v8 = v2;
  v9 = v1 + 544;
  v10 = 1;
  result = sub_409630((DWORD)dwErrCode);
  if ( result )
  {
    v4 = *(_DWORD *)(a1 + 48) == 0;
    v5 = v8;
    *(_DWORD *)(a1 + 56) = v8;
    if ( v4 )
      *(_DWORD *)(*(_DWORD *)(a1 + 60) + 540) = v5;
    DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1247);
    return InvalidateRect(DlgItem, 0, 1);
  }
  return result;
}

//----- (004A5590) --------------------------------------------------------
int __stdcall sub_4A5590(HWND hWnd, int a2, HDC hDC, DWORD dwErrCode, int a5, int a6)
{
  HBRUSH SolidBrush; // esi
  struct tagRECT Rect; // [esp+4h] [ebp-14h] BYREF

  if ( a2 != 20 )
    return sub_401C60((int)hWnd, a2, (int)hDC, dwErrCode);
  GetClientRect(hWnd, &Rect);
  SolidBrush = CreateSolidBrush(*(_DWORD *)(a6 + 56));
  FillRect(hDC, &Rect, SolidBrush);
  DeleteObject(SolidBrush);
  return 1;
}

//----- (004A5620) --------------------------------------------------------
int __thiscall sub_4A5620(DWORD dwErrCode)
{
  const WCHAR *v2; // eax
  const WCHAR *v3; // eax
  int v4; // eax
  HWND DlgItem; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // edi
  _DWORD *v9; // esi
  HWND Parent; // eax
  WCHAR Buffer[64]; // [esp+8h] [ebp-84h] BYREF

  if ( *(_DWORD *)(dwErrCode + 48) )
  {
    v2 = *(const WCHAR **)(dwErrCode + 52);
    if ( *((_DWORD *)v2 + 5) >= 8u )
      v2 = *(const WCHAR **)v2;
    SetDlgItemTextW(*(HWND *)(dwErrCode + 4), 1215, v2);
    v3 = (const WCHAR *)(*(_DWORD *)(dwErrCode + 52) + 28);
    if ( *(_DWORD *)(*(_DWORD *)(dwErrCode + 52) + 48) >= 8u )
      v3 = *(const WCHAR **)v3;
    SetDlgItemTextW(*(HWND *)(dwErrCode + 4), 1207, v3);
    v4 = *(_DWORD *)(dwErrCode + 52);
    *(_DWORD *)(dwErrCode + 56) = *(_DWORD *)(v4 + 60);
    if ( (*(_DWORD *)(v4 + 56) & 0x800) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1204, 1u);
    if ( (*(_DWORD *)(*(_DWORD *)(dwErrCode + 52) + 56) & 0x4000) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1205, 1u);
    if ( (*(_BYTE *)(*(_DWORD *)(dwErrCode + 52) + 56) & 0x20) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1060, 1u);
    if ( (*(_BYTE *)(*(_DWORD *)(dwErrCode + 52) + 56) & 2) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1061, 1u);
    if ( (*(_DWORD *)(*(_DWORD *)(dwErrCode + 52) + 56) & 0x2000) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1063, 1u);
    if ( (*(_BYTE *)(*(_DWORD *)(dwErrCode + 52) + 56) & 1) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1062, 1u);
    if ( (*(_BYTE *)(*(_DWORD *)(dwErrCode + 52) + 56) & 4) != 0 )
      CheckDlgButton(*(HWND *)(dwErrCode + 4), 1059, 1u);
    LoadStringW(*(HINSTANCE *)(dwErrCode + 8), 0x848u, Buffer, 64);
    SetWindowTextW(*(HWND *)(dwErrCode + 4), Buffer);
  }
  else
  {
    *(_DWORD *)(dwErrCode + 56) = *(_DWORD *)(*(_DWORD *)(dwErrCode + 60) + 540);
  }
  DlgItem = GetDlgItem(*(HWND *)(dwErrCode + 4), 1247);
  sub_409750((int)DlgItem, (int)sub_4A5590, 0, dwErrCode);
  v6 = GetDlgItem(*(HWND *)(dwErrCode + 4), 1215);
  SendMessageW(v6, 0xB1u, 0, -1);
  v7 = GetDlgItem(*(HWND *)(dwErrCode + 4), 1215);
  SetFocus(v7);
  v8 = *(HWND *)(dwErrCode + 4);
  v9 = *(_DWORD **)(dwErrCode + 60);
  if ( v9[1] )
  {
    SetWindowPos(v8, 0, v9[2], v9[3], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v8);
    sub_4697F0(v8, Parent);
  }
  return 0;
}

//----- (004A5800) --------------------------------------------------------
void __thiscall sub_4A5800(int this, LPCWSTR lpString2, wchar_t *String)
{
  unsigned __int8 v4; // bl
  void *v5; // eax
  unsigned int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // ecx
  int v10; // edx
  unsigned __int8 v11; // [esp+17h] [ebp-FDh]
  unsigned int v13; // [esp+1Ch] [ebp-F8h] BYREF
  wchar_t *v14; // [esp+20h] [ebp-F4h]
  int v15[41]; // [esp+24h] [ebp-F0h] BYREF
  void *v16[5]; // [esp+C8h] [ebp-4Ch] BYREF
  unsigned int v17; // [esp+DCh] [ebp-38h]
  void *v18[5]; // [esp+E4h] [ebp-30h] BYREF
  unsigned int v19; // [esp+F8h] [ebp-1Ch]
  int v20; // [esp+110h] [ebp-4h]

  v14 = String;
  if ( sub_469A50(L"r*", (int)lpString2, 1)
    || sub_469A50(L"g*", (int)lpString2, 1)
    || sub_469A50(L"b*", (int)lpString2, 1) )
  {
    if ( lstrlenW(lpString2) < 2 )
      return;
    LOWORD(v16[0]) = 0;
    v13 = 0;
    v17 = 7;
    v16[4] = 0;
    sub_4094F0(v16, (int)(lpString2 + 1), (void *)lpString2, wcslen(lpString2));
    v20 = 0;
    v5 = (void *)sub_402000(1u, 0xFFFFFFFF, (int)v18, v16);
    LOBYTE(v20) = 1;
    sub_402030(v5, (int)v15);
    LOBYTE(v20) = 3;
    if ( v19 >= 8 )
      operator delete(v18[0]);
    v19 = 7;
    v18[4] = 0;
    LOWORD(v18[0]) = 0;
    sub_401E20((int)v15, &v13);
    v6 = v13;
    if ( (v13 & 0x80000000) != 0 || v13 > 0x3F )
    {
      LOBYTE(v20) = 0;
      sub_401D90(v15);
      if ( v17 < 8 )
        return;
      goto LABEL_24;
    }
    v7 = *(_DWORD *)(this + 4 * v13 + 544);
    v11 = _wtoi(v14);
    if ( sub_469A50(L"r*", (int)lpString2, 1) )
    {
      v8 = v11;
      v9 = BYTE2(v7) << 8;
      v10 = BYTE1(v7);
    }
    else
    {
      if ( sub_469A50(L"g*", (int)lpString2, 1) )
      {
        v10 = v11;
        v9 = BYTE2(v7) << 8;
      }
      else
      {
        if ( !sub_469A50(L"b*", (int)lpString2, 1) )
          goto LABEL_21;
        v9 = BYTE1(v7);
        v10 = v11 << 8;
      }
      v8 = (unsigned __int8)v7;
    }
    *(_DWORD *)(this + 4 * v6 + 544) = v8 | ((v10 | v9) << 8);
LABEL_21:
    LOBYTE(v20) = 0;
    sub_401D90(v15);
    if ( v17 < 8 )
      return;
LABEL_24:
    operator delete(v16[0]);
    return;
  }
  v4 = _wtoi(String);
  if ( !lstrcmpiW(L"InitialColor_r", lpString2)
    || !lstrcmpiW(L"InitialColor_g", lpString2)
    || !lstrcmpiW(L"InitialColor_b", lpString2) )
  {
    *(_DWORD *)(this + 540) = v4 | (*(unsigned __int16 *)(this + 541) << 8);
  }
}

//----- (004A5B10) --------------------------------------------------------
BOOL __usercall sub_4A5B10@<eax>(int a1@<esi>)
{
  HWND DlgItem; // eax
  HWND v2; // eax
  _DWORD *v4; // [esp-Ch] [ebp-Ch]
  _DWORD *v5; // [esp-Ch] [ebp-Ch]

  v4 = *(_DWORD **)(a1 + 52);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 4), 1215);
  sub_46AFA0(DlgItem, v4);
  v5 = (_DWORD *)(*(_DWORD *)(a1 + 52) + 28);
  v2 = GetDlgItem(*(HWND *)(a1 + 4), 1207);
  sub_46AFA0(v2, v5);
  *(_DWORD *)(*(_DWORD *)(a1 + 52) + 60) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) = 0;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1204) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 0x800u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1205) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 0x4000u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1060) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 0x20u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1061) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 2u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1062) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 1u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 4), 1059) == 1 )
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 56) |= 4u;
  return EndDialog(*(HWND *)(a1 + 4), 1);
}

//----- (004A5C10) --------------------------------------------------------
int __thiscall sub_4A5C10(HWND *this, unsigned int a2, int a3)
{
  if ( HIWORD(a2) )
  {
    if ( HIWORD(a2) == 1 )
    {
LABEL_3:
      sub_4A54A0((int)this);
      return 0;
    }
  }
  else
  {
    switch ( (unsigned __int16)a2 )
    {
      case 1u:
        sub_4A5B10((int)this);
        break;
      case 2u:
        EndDialog(this[1], 0);
        return 0;
      case 0x4E0u:
        goto LABEL_3;
    }
  }
  return 0;
}

//----- (004A5CB0) --------------------------------------------------------
int __stdcall sub_4A5CB0(int a1)
{
  int v1; // ecx
  int lParam[2]; // [esp+4h] [ebp-8h] BYREF

  v1 = *(_DWORD *)(a1 + 8);
  lParam[0] = -1;
  SendMessageW(*(HWND *)(v1 + 504), 0x450u, 0, (LPARAM)lParam);
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 16) + 16))(*(_DWORD *)(a1 + 16));
  return 0;
}
// 4A5CB0: using guessed type LPARAM lParam[2];

//----- (004A5CF0) --------------------------------------------------------
int __stdcall sub_4A5CF0(int a1, int a2, LONG a3, LONG a4, _DWORD *a5)
{
  bool v5; // zf
  int v6; // edx
  signed int v7; // eax
  HWND v8; // edx
  LPARAM v9; // ebx
  LRESULT v10; // eax
  int v11; // ecx
  int v12; // eax
  bool v13; // sf
  bool v14; // of
  int v15; // eax
  _DWORD *v17; // [esp+Ch] [ebp-28h]
  struct tagPOINT Point; // [esp+10h] [ebp-24h] BYREF
  LPARAM v19; // [esp+18h] [ebp-1Ch] BYREF
  BOOL v20; // [esp+1Ch] [ebp-18h]
  LPARAM lParam[4]; // [esp+20h] [ebp-14h] BYREF

  v5 = *(_DWORD *)(a1 + 20) == 0;
  v17 = a5;
  Point.x = a3;
  *a5 = !v5;
  v6 = *(_DWORD *)(a1 + 8);
  Point.y = a4;
  ScreenToClient(*(HWND *)(v6 + 504), &Point);
  v7 = SendMessageW(*(HWND *)(*(_DWORD *)(a1 + 8) + 504), 0x445u, 0, (LPARAM)&Point);
  v8 = *(HWND *)(*(_DWORD *)(a1 + 8) + 504);
  v9 = v7;
  if ( v7 >= 0 )
  {
    SendMessageW(v8, 0x41Du, v7, (LPARAM)lParam);
    v12 = lParam[0] + (lParam[2] - lParam[0]) / 2;
    v14 = __OFSUB__(Point.x, v12);
    v5 = Point.x == v12;
    v13 = Point.x - v12 < 0;
    v15 = *(_DWORD *)(a1 + 8);
    v19 = v9;
    v20 = !(v13 ^ v14 | v5);
    SendMessageW(*(HWND *)(v15 + 504), 0x450u, 0, (LPARAM)&v19);
  }
  else
  {
    v10 = SendMessageW(v8, 0x418u, 0, 0);
    v11 = *(_DWORD *)(a1 + 8);
    v19 = v10 - 1;
    v20 = 1;
    SendMessageW(*(HWND *)(v11 + 504), 0x450u, 0, (LPARAM)&v19);
  }
  (*(void (__stdcall **)(_DWORD, LONG *, _DWORD))(**(_DWORD **)(a1 + 16) + 20))(*(_DWORD *)(a1 + 16), &a3, *v17);
  return 0;
}

//----- (004A5E00) --------------------------------------------------------
int __stdcall sub_4A5E00(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // ebx
  int (__stdcall *v7)(int, __int16 *, STGMEDIUM *); // edx
  int v8; // esi
  HDROP v9; // eax
  HDROP v10; // edi
  UINT v11; // esi
  _DWORD *v12; // edx
  _DWORD *v13; // eax
  __int16 v15; // [esp+Ch] [ebp-244h] BYREF
  int v16; // [esp+10h] [ebp-240h]
  int v17; // [esp+14h] [ebp-23Ch]
  int v18; // [esp+18h] [ebp-238h]
  int v19; // [esp+1Ch] [ebp-234h]
  STGMEDIUM v20; // [esp+20h] [ebp-230h] BYREF
  int FileW; // [esp+2Ch] [ebp-224h]
  int v22; // [esp+30h] [ebp-220h]
  int v23; // [esp+34h] [ebp-21Ch]
  int v24; // [esp+38h] [ebp-218h]
  int v25; // [esp+3Ch] [ebp-214h]
  _DWORD *v26; // [esp+40h] [ebp-210h]
  WCHAR szFile[260]; // [esp+44h] [ebp-20Ch] BYREF

  v6 = a2;
  v7 = *(int (__stdcall **)(int, __int16 *, STGMEDIUM *))(*(_DWORD *)a2 + 12);
  v8 = a1;
  v26 = a6;
  v15 = 15;
  v22 = a1;
  v24 = a2;
  v16 = 0;
  v17 = 1;
  v18 = -1;
  v19 = 1;
  v23 = v7(a2, &v15, &v20);
  if ( v23 )
    goto LABEL_11;
  v25 = 1;
  v9 = (HDROP)GlobalLock(v20.hBitmap);
  v10 = v9;
  if ( v9 )
  {
    v11 = 0;
    FileW = DragQueryFileW(v9, 0xFFFFFFFF, 0, 0);
    if ( FileW > 0 )
    {
      while ( 1 )
      {
        DragQueryFileW(v10, v11, szFile, 0x104u);
        if ( !PathIsDirectoryW(szFile) )
          break;
        if ( (int)++v11 >= FileW )
          goto LABEL_8;
      }
      v25 = 0;
    }
LABEL_8:
    GlobalUnlock(v20.hBitmap);
    v8 = v22;
    v6 = v24;
  }
  ReleaseStgMedium(&v20);
  if ( !v25 )
  {
LABEL_11:
    v13 = v26;
    *(_DWORD *)(v8 + 20) = 0;
    *v13 = 0;
  }
  else
  {
    v12 = v26;
    *(_DWORD *)(v8 + 20) = 1;
    *v12 = 1;
  }
  (*(void (__stdcall **)(_DWORD, _DWORD, int, int *, _DWORD))(**(_DWORD **)(v8 + 16) + 12))(
    *(_DWORD *)(v8 + 16),
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 504),
    v6,
    &a4,
    *v26);
  return v23;
}

//----- (004A5F90) --------------------------------------------------------
int __stdcall sub_4A5F90(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (004A5FB0) --------------------------------------------------------
int __stdcall sub_4A5FB0(int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  return -2147467262;
}

//----- (004A5FE0) --------------------------------------------------------
int __stdcall sub_4A5FE0(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    *(_DWORD *)a1 = &Explorerplusplus::CBookmarkToolbarDrop::`vftable';
    operator delete(a1);
    return 0;
  }
  return result;
}
// 4CB920: using guessed type void *Explorerplusplus::CBookmarkToolbarDrop::`vftable';

//----- (004A6050) --------------------------------------------------------
int __stdcall sub_4A6050(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // esi
  int (__stdcall *v9)(int, __int16 *, STGMEDIUM *); // ecx
  HDROP v10; // eax
  HDROP v11; // esi
  signed int i; // edi
  WCHAR *v13; // eax
  int v14; // edx
  WCHAR v15; // cx
  char *v16; // eax
  int v17; // edx
  __int16 v18; // cx
  char *v19; // eax
  int v20; // edx
  __int16 v21; // cx
  char *v22; // eax
  int v23; // edx
  __int16 v24; // cx
  int v25; // esi
  int v26; // edx
  int v27; // eax
  _DWORD *v28; // ecx
  LPARAM v29; // ecx
  int v30; // ebx
  HWND v31; // eax
  signed int FileW; // [esp+1Ch] [ebp-1494h]
  HDROP v34; // [esp+24h] [ebp-148Ch]
  STGMEDIUM v35; // [esp+28h] [ebp-1488h] BYREF
  __int16 v36; // [esp+34h] [ebp-147Ch] BYREF
  int v37; // [esp+38h] [ebp-1478h]
  int v38; // [esp+3Ch] [ebp-1474h]
  int v39; // [esp+40h] [ebp-1470h]
  int v40; // [esp+44h] [ebp-146Ch]
  int lParam[2]; // [esp+48h] [ebp-1468h] BYREF
  LPARAM v42[519]; // [esp+50h] [ebp-1460h] BYREF
  LPARAM v43[2]; // [esp+86Ch] [ebp-C44h] BYREF
  __int16 v44; // [esp+874h] [ebp-C3Ch]
  int v45; // [esp+878h] [ebp-C38h]
  char *v46; // [esp+87Ch] [ebp-C34h]
  char v47[512]; // [esp+880h] [ebp-C30h] BYREF
  char v48[1024]; // [esp+A80h] [ebp-A30h] BYREF
  int v49; // [esp+E80h] [ebp-630h]
  int v50; // [esp+E84h] [ebp-62Ch]
  char v51[520]; // [esp+E88h] [ebp-628h] BYREF
  int v52; // [esp+1090h] [ebp-420h]
  WCHAR szFile[260]; // [esp+1098h] [ebp-418h] BYREF
  WCHAR pszPath[262]; // [esp+12A0h] [ebp-210h] BYREF

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = a6;
  lParam[0] = -1;
  SendMessageW(*(HWND *)(v7 + 504), 0x450u, 0, (LPARAM)lParam);
  v9 = *(int (__stdcall **)(int, __int16 *, STGMEDIUM *))(*(_DWORD *)a2 + 12);
  v36 = 15;
  v38 = 1;
  v40 = 1;
  v37 = 0;
  v39 = -1;
  if ( !v9(a2, &v36, &v35) )
  {
    (*(void (__stdcall **)(_DWORD, int, int *, _DWORD))(**(_DWORD **)(a1 + 16) + 24))(
      *(_DWORD *)(a1 + 16),
      a2,
      &a4,
      *v8);
    v10 = (HDROP)GlobalLock(v35.hBitmap);
    v11 = v10;
    v34 = v10;
    if ( v10 )
    {
      FileW = DragQueryFileW(v10, 0xFFFFFFFF, 0, 0);
      sub_466000(*(_DWORD *)(a1 + 8) + 1332, v42);
      for ( i = 0; i < FileW; ++i )
      {
        DragQueryFileW(v11, i, szFile, 0x104u);
        if ( PathIsDirectoryW(szFile) )
        {
          v13 = pszPath;
          v14 = 260;
          while ( v14 != -2147483386 )
          {
            v15 = *(WCHAR *)((char *)v13 + (char *)szFile - (char *)pszPath);
            if ( !v15 )
              break;
            *v13++ = v15;
            if ( !--v14 )
            {
              --v13;
              break;
            }
          }
          *v13 = 0;
          PathStripPathW(pszPath);
          v16 = v47;
          v17 = 256;
          while ( v17 != -2147483390 )
          {
            v18 = *(_WORD *)&v16[(char *)pszPath - v47];
            if ( !v18 )
              break;
            *(_WORD *)v16 = v18;
            v16 += 2;
            if ( !--v17 )
            {
              v16 -= 2;
              break;
            }
          }
          *(_WORD *)v16 = 0;
          v19 = v48;
          v20 = 512;
          while ( v20 != -2147483134 )
          {
            v21 = *(_WORD *)&v19[&unk_4CB540 - (_UNKNOWN *)v48];
            if ( !v21 )
              break;
            *(_WORD *)v19 = v21;
            v19 += 2;
            if ( !--v20 )
            {
              v19 -= 2;
              break;
            }
          }
          *(_WORD *)v19 = 0;
          v22 = v51;
          v23 = 260;
          while ( v23 != -2147483386 )
          {
            v24 = *(_WORD *)&v22[(char *)szFile - v51];
            if ( !v24 )
              break;
            *(_WORD *)v22 = v24;
            v22 += 2;
            if ( !--v23 )
            {
              v22 -= 2;
              break;
            }
          }
          v25 = v42[516];
          *(_WORD *)v22 = 0;
          v50 = 1;
          v49 = 1;
          sub_4660F0(v47, v25);
          v26 = *(_DWORD *)(a1 + 8);
          v27 = 0;
          v28 = (_DWORD *)(v26 + 59984);
          while ( *v28 )
          {
            ++v27;
            ++v28;
            if ( v27 >= 100 )
            {
              v29 = -1;
              goto LABEL_29;
            }
          }
          *(_DWORD *)(v26 + 4 * v27 + 59984) = 1;
          v29 = v27 + 46000;
LABEL_29:
          v30 = *(_DWORD *)(a1 + 8);
          v43[0] = v50 != 0 ? 20 : 15;
          v45 = v52;
          v31 = *(HWND *)(v30 + 504);
          v43[1] = v29;
          v44 = 28676;
          v46 = v47;
          SendMessageW(v31, 0x444u, 1u, (LPARAM)v43);
          sub_467F60(*(HWND *)(v30 + 60), *(HWND *)(v30 + 504));
          v11 = v34;
        }
      }
      GlobalUnlock(v35.hBitmap);
      v6 = a1;
    }
    ReleaseStgMedium(&v35);
  }
  sub_4A6FC0(*(HMENU **)(v6 + 8));
  return 0;
}
// 4A61A0: conditional instruction was optimized away because edx.4!=0
// 4A61F0: conditional instruction was optimized away because edx.4!=0
// 4A6230: conditional instruction was optimized away because edx.4!=0
// 4A6271: conditional instruction was optimized away because edx.4!=0
// 4A6050: using guessed type LPARAM lParam[2];

//----- (004A63A0) --------------------------------------------------------
int __usercall sub_4A63A0@<eax>(void *a1@<ebx>, HWND a2@<esi>)
{
  WCHAR Buffer[128]; // [esp+0h] [ebp-104h] BYREF

  LoadStringW(hInstance, 0x7FAu, Buffer, 128);
  if ( MessageBoxW(a2, Buffer, L"Explorer++", 0x144u) != 6 )
    return 0;
  sub_465880(a1);
  return 1;
}

//----- (004A6420) --------------------------------------------------------
HWND __thiscall sub_4A6420(HWND *this, int a2)
{
  HWND result; // eax
  WPARAM v4; // ebx
  HWND v5; // ebx
  WPARAM v6; // edi
  HWND hWnd; // [esp+10h] [ebp-78h]
  HWND hWnda; // [esp+10h] [ebp-78h]
  int v9; // [esp+14h] [ebp-74h]
  int v10[2]; // [esp+18h] [ebp-70h] BYREF
  LPARAM v11; // [esp+20h] [ebp-68h] BYREF
  int v12; // [esp+24h] [ebp-64h]
  HWND v13; // [esp+40h] [ebp-48h]
  int v14; // [esp+64h] [ebp-24h]
  LPARAM lParam[5]; // [esp+70h] [ebp-18h] BYREF

  result = (HWND)SendMessageW(this[126], 0x418u, 0, 0);
  v4 = 0;
  hWnd = result;
  if ( (int)result > 0 )
  {
    while ( 1 )
    {
      result = (HWND)SendMessageW(this[126], 0x417u, v4, (LPARAM)lParam);
      if ( result )
      {
        result = (HWND)a2;
        if ( lParam[3] == a2 )
          break;
      }
      if ( (int)++v4 >= (int)hWnd )
        return result;
    }
    SendMessageW(this[126], 0x416u, v4, 0);
    v5 = this[15];
    hWnda = this[126];
    result = (HWND)SendMessageW(v5, 0x40Cu, 0, 0);
    v6 = 0;
    v9 = (int)result;
    if ( (int)result > 0 )
    {
      while ( 1 )
      {
        v11 = 80;
        v12 = 16;
        SendMessageW(v5, 0x41Cu, v6, (LPARAM)&v11);
        result = hWnda;
        if ( v13 == hWnda )
          break;
        if ( (int)++v6 >= v9 )
          return result;
      }
      if ( v6 != -1 )
      {
        SendMessageW(hWnda, 0x453u, 0, (LPARAM)v10);
        v11 = 80;
        v12 = 512;
        v14 = v10[0];
        return (HWND)SendMessageW(v5, 0x40Bu, v6, (LPARAM)&v11);
      }
    }
  }
  return result;
}
// 4A6420: using guessed type LPARAM var_70[2];

//----- (004A6570) --------------------------------------------------------
int __fastcall sub_4A6570(int a1, int a2)
{
  int v2; // eax
  _DWORD *i; // ecx

  v2 = 0;
  for ( i = (_DWORD *)(a2 + 59984); *i; ++i )
  {
    if ( ++v2 >= 100 )
      return -1;
  }
  *(_DWORD *)(a2 + 4 * v2 + 59984) = 1;
  return v2 + 46000;
}

//----- (004A65C0) --------------------------------------------------------
WPARAM __userpurge sub_4A65C0@<eax>(HWND a1@<edi>, int a2)
{
  WPARAM v2; // esi
  LRESULT v3; // eax
  LRESULT v5; // [esp+8h] [ebp-4h]

  v2 = 0;
  v5 = SendMessageW(a1, 0x146u, 0, 0);
  if ( v5 <= 0 )
    return -1;
  while ( 1 )
  {
    v3 = SendMessageW(a1, 0x150u, v2, 0);
    if ( v3 != -1 && v3 == a2 )
      break;
    if ( (int)++v2 >= v5 )
      return -1;
  }
  return v2;
}

//----- (004A6620) --------------------------------------------------------
int __userpurge sub_4A6620@<eax>(int a1@<edi>, LPARAM a2)
{
  int result; // eax
  int v3; // ebx
  WPARAM v4; // esi
  LPARAM v5; // eax
  HWND v6; // [esp-10h] [ebp-5Ch]
  HWND v7; // [esp-10h] [ebp-5Ch]
  LPARAM v8[8]; // [esp+Ch] [ebp-40h] BYREF
  LPARAM v9; // [esp+2Ch] [ebp-20h]
  LPARAM lParam[5]; // [esp+30h] [ebp-1Ch] BYREF

  v6 = *(HWND *)(a1 + 504);
  v9 = a2;
  result = SendMessageW(v6, 0x418u, 0, 0);
  v3 = result;
  v4 = 0;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result = SendMessageW(*(HWND *)(a1 + 504), 0x417u, v4, (LPARAM)lParam);
      if ( result )
      {
        if ( lParam[3] == *(_DWORD *)(v9 + 2064) )
          break;
      }
      if ( (int)++v4 >= v3 )
        return result;
    }
    v8[3] = *(_DWORD *)(v9 + 1540) != 0 ? 20 : 15;
    v5 = *(_DWORD *)(v9 + 2064);
    v8[6] = v9;
    v8[5] = v5;
    v7 = *(HWND *)(a1 + 504);
    v8[0] = 32;
    v8[1] = 2;
    return SendMessageW(v7, 0x440u, lParam[1], (LPARAM)v8);
  }
  return result;
}

//----- (004A6700) --------------------------------------------------------
HWND __userpurge sub_4A6700@<eax>(int a1@<ecx>, int a2@<esi>, LPARAM a3)
{
  int v3; // edx
  HWND v5; // [esp-10h] [ebp-2Ch]
  LPARAM lParam[2]; // [esp+4h] [ebp-18h] BYREF
  __int16 v7; // [esp+Ch] [ebp-10h]
  int v8; // [esp+10h] [ebp-Ch]
  int v9; // [esp+14h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 2064);
  lParam[0] = *(_DWORD *)(a1 + 1540) != 0 ? 20 : 15;
  lParam[1] = a3;
  v9 = a1;
  v5 = *(HWND *)(a2 + 504);
  v7 = 28676;
  v8 = v3;
  SendMessageW(v5, 0x444u, 1u, (LPARAM)lParam);
  return sub_467F60(*(HWND *)(a2 + 60), *(HWND *)(a2 + 504));
}

//----- (004A6780) --------------------------------------------------------
HRESULT __userpurge sub_4A6780@<eax>(int a1@<esi>, LPCWSTR lpSrc, int a3, int a4)
{
  HRESULT v4; // edi
  LPVOID pv; // [esp+8h] [ebp-210h] BYREF
  WCHAR Dest[260]; // [esp+Ch] [ebp-20Ch] BYREF

  sub_466280(lpSrc, Dest);
  pv = 0;
  v4 = sub_467810((LPITEMIDLIST *)&pv, (int)Dest);
  (*(void (__thiscall **)(int, LPVOID, _DWORD, int, int, _DWORD))(*(_DWORD *)(a1 + 28) + 40))(a1 + 28, pv, 0, a3, a4, 0);
  if ( v4 >= 0 )
    CoTaskMemFree(pv);
  return v4;
}

//----- (004A6820) --------------------------------------------------------
int __thiscall sub_4A6820(void *this, HWND hWnd, int a3, int a4, int a5)
{
  int v5; // esi
  LPARAM v6; // eax
  int result; // eax
  int v8; // ebx
  LPARAM lParam[9]; // [esp+Ch] [ebp-1058h] BYREF
  HWND v10; // [esp+30h] [ebp-1034h]
  void *v11; // [esp+34h] [ebp-1030h]
  int v12[517]; // [esp+38h] [ebp-102Ch] BYREF
  int v13[517]; // [esp+84Ch] [ebp-818h] BYREF
  int v14; // [esp+1078h] [ebp+14h]

  v5 = a4;
  lParam[1] = a5;
  v11 = this;
  v14 = a5 + 1;
  lParam[4] = 15;
  lParam[5] = 15;
  v6 = *(_DWORD *)(a3 + 2064);
  v10 = hWnd;
  lParam[0] = 55;
  lParam[2] = a3;
  lParam[7] = a4;
  lParam[8] = v6;
  SendMessageW(hWnd, 0x40Bu, 0, (LPARAM)lParam);
  result = sub_465F90((_DWORD *)a3, v12);
  if ( result >= 0 )
  {
    result = sub_4A6820(v11, hWnd, (int)v12, a4 + 1, v14);
    v5 = a4;
  }
  v8 = *(_DWORD *)(*(_DWORD *)(a3 + 2064) + 2072);
  if ( v8 )
  {
    while ( *(_DWORD *)(v8 + 1540) )
    {
      v8 = *(_DWORD *)(v8 + 2072);
      if ( !v8 )
        return result;
    }
    sub_465D30(v8, v13);
    return sub_4A6820(v11, v10, (int)v13, v5, v14);
  }
  return result;
}

//----- (004A6960) --------------------------------------------------------
int __thiscall sub_4A6960(_DWORD *this, HWND a2)
{
  WPARAM v3; // esi
  LPARAM v4; // ecx
  int v5; // ebx
  int result; // eax
  LPARAM v7[2]; // [esp+Ch] [ebp-884h] BYREF
  int v8; // [esp+14h] [ebp-87Ch]
  _DWORD *v9; // [esp+20h] [ebp-870h]
  LPARAM lParam[13]; // [esp+40h] [ebp-850h] BYREF
  HWND hWnd; // [esp+74h] [ebp-81Ch]
  int v12[517]; // [esp+78h] [ebp-818h] BYREF

  hWnd = a2;
  v3 = 0;
  do
  {
    v4 = this[516];
    lParam[7] = this[385] != 1 ? 15 : 20;
    lParam[0] = 7;
    lParam[1] = v3;
    lParam[2] = 0;
    lParam[5] = (LPARAM)this;
    lParam[8] = v4;
    SendMessageW(hWnd, 0x104Du, 0, (LPARAM)lParam);
    if ( this[385] == 1 )
    {
      v8 = 1;
      v9 = this + 386;
      SendMessageW(hWnd, 0x1074u, v3, (LPARAM)v7);
      v8 = 2;
      v9 = this + 128;
      SendMessageW(hWnd, 0x1074u, v3, (LPARAM)v7);
    }
    v5 = *(_DWORD *)(this[516] + 2072);
    result = -2147467259;
    if ( v5 )
    {
      sub_465D30(v5, v12);
      result = 0;
    }
    ++v3;
    this = v12;
  }
  while ( result >= 0 );
  return result;
}
// 4A6960: using guessed type _DWORD var_818[517];

//----- (004A6A90) --------------------------------------------------------
int __thiscall sub_4A6A90(void *this, HWND a2, LPARAM a3, _DWORD *a4)
{
  int v4; // eax
  BOOL v5; // edx
  int v6; // eax
  LPARAM v7; // eax
  int result; // eax
  int v9; // ebx
  LPARAM lParam[2]; // [esp+10h] [ebp-10C4h] BYREF
  char v11[56]; // [esp+18h] [ebp-10BCh] BYREF
  int v12[14]; // [esp+50h] [ebp-1084h] BYREF
  int v13; // [esp+88h] [ebp-104Ch]
  LPARAM v14; // [esp+8Ch] [ebp-1048h]
  HWND hWnd; // [esp+90h] [ebp-1044h]
  void *v16; // [esp+94h] [ebp-1040h]
  int v17[518]; // [esp+98h] [ebp-103Ch] BYREF
  int v18[519]; // [esp+8B0h] [ebp-824h] BYREF

  v16 = this;
  hWnd = a2;
  v14 = a3;
  v4 = sub_465F90(a4, v18);
  v5 = v4 == 0;
  v13 = v4;
  v12[6] = 15;
  v12[7] = 15;
  v6 = a4[516];
  lParam[0] = a3;
  v12[8] = v5;
  v12[9] = v6;
  lParam[1] = -65533;
  v12[0] = 103;
  v12[4] = (int)a4;
  qmemcpy(v11, v12, sizeof(v11));
  v7 = SendMessageW(a2, 0x1132u, 0, (LPARAM)lParam);
  if ( v13 >= 0 )
    sub_4A6A90(v16, a2, v7, v18);
  result = a4[516];
  v9 = *(_DWORD *)(result + 2072);
  if ( v9 )
  {
    while ( *(_DWORD *)(v9 + 1540) )
    {
      v9 = *(_DWORD *)(v9 + 2072);
      if ( !v9 )
        return result;
    }
    sub_465D30(v9, v17);
    return sub_4A6A90(v16, a2, v14, v17);
  }
  return result;
}
// 4A6A90: using guessed type _DWORD var_824[519];
// 4A6A90: using guessed type _DWORD var_103C[518];

//----- (004A6BE0) --------------------------------------------------------
_DWORD *__thiscall sub_4A6BE0(HWND *this, int a2)
{
  _DWORD *result; // eax
  _DWORD *v4; // ebx
  int v5; // eax
  HWND *v6; // ecx
  LPARAM v7; // ecx
  HWND v8; // eax
  int v9; // ebx
  int v10[518]; // [esp+Ch] [ebp-1048h] BYREF
  _DWORD v11[385]; // [esp+824h] [ebp-830h] BYREF
  int v12; // [esp+E28h] [ebp-22Ch]
  _DWORD *v13; // [esp+1034h] [ebp-20h]
  LPARAM lParam[2]; // [esp+103Ch] [ebp-18h] BYREF
  __int16 v15; // [esp+1044h] [ebp-10h]
  _DWORD *v16; // [esp+1048h] [ebp-Ch]
  _DWORD *v17; // [esp+104Ch] [ebp-8h]

  result = *(_DWORD **)(a2 + 2064);
  if ( !result[385] )
  {
    result = (_DWORD *)result[519];
    if ( result )
    {
      v4 = result;
      do
      {
        sub_465D30((int)v4, v11);
        if ( v11[384] )
        {
          v5 = 0;
          v6 = this + 14996;
          while ( *v6 )
          {
            ++v5;
            ++v6;
            if ( v5 >= 100 )
            {
              v7 = -1;
              goto LABEL_9;
            }
          }
          this[v5 + 14996] = (HWND)1;
          v7 = v5 + 46000;
LABEL_9:
          lParam[0] = v12 != 0 ? 20 : 15;
          v16 = v13;
          v8 = this[126];
          lParam[1] = v7;
          v15 = 28676;
          v17 = v11;
          SendMessageW(v8, 0x444u, 1u, (LPARAM)lParam);
          sub_467F60(this[15], this[126]);
        }
        if ( !v12 && !v13[385] )
        {
          v9 = v13[519];
          if ( v9 )
          {
            sub_465D30(v9, v10);
            sub_4A6BE0(this, (int)v10);
          }
        }
        result = v13;
        v4 = (_DWORD *)v13[518];
      }
      while ( v4 );
    }
  }
  return result;
}
// 4A6BE0: using guessed type _DWORD var_1048[518];

//----- (004A6D20) --------------------------------------------------------
int __thiscall sub_4A6D20(void *this, HMENU hmenu, UINT item, UINT uPosition)
{
  UINT v4; // ebx
  int result; // eax
  HMENU v6; // edi
  HMENU v7; // edi
  int v8; // ebx
  MENUITEMINFOW mi; // [esp+18h] [ebp-1074h] BYREF
  void *v10; // [esp+48h] [ebp-1044h]
  HMENU Menu; // [esp+4Ch] [ebp-1040h]
  UINT v12[518]; // [esp+50h] [ebp-103Ch] BYREF
  UINT v13[519]; // [esp+868h] [ebp-824h] BYREF

  v4 = item;
  v10 = this;
  if ( item )
  {
    if ( *(_DWORD *)(item + 1540) == 1 )
    {
      mi.wID = dword_4EB2DC;
      mi.cbSize = 48;
      mi.fMask = 66;
      ++dword_4EB2DC;
      mi.dwTypeData = (LPWSTR)item;
      InsertMenuItemW(hmenu, uPosition, 1, &mi);
      sub_48F860(hmenu, uPosition);
      mi.cbSize = 48;
      mi.fMask = 32;
      GetMenuItemInfoW(hmenu, uPosition, 1, &mi);
      result = *(_DWORD *)(item + 2064);
      *(_DWORD *)(mi.dwItemData + 8) = result;
    }
    else
    {
      Menu = CreateMenu();
      InsertMenuW(hmenu, uPosition, 0x410u, 0x3F2u, (LPCWSTR)item);
      mi.cbSize = 48;
      mi.fMask = 4;
      mi.hSubMenu = Menu;
      SetMenuItemInfoW(hmenu, uPosition, 1, &mi);
      sub_48F860(hmenu, uPosition);
      v6 = Menu;
      mi.cbSize = 48;
      mi.fMask = 66;
      mi.wID = 40174;
      mi.dwTypeData = L"Bookmark This Tab...";
      InsertMenuItemW(Menu, 0, 1, &mi);
      sub_48F860(v6, 0);
      result = *(_DWORD *)(item + 2064);
      if ( !*(_DWORD *)(result + 1540) )
      {
        result = *(_DWORD *)(result + 2076);
        if ( result )
        {
          sub_465D30(result, v13);
          v7 = Menu;
          mi.cbSize = 48;
          mi.fMask = 256;
          mi.fType = 2048;
          InsertMenuItemW(Menu, 1u, 1, &mi);
          sub_48F860(v7, 1u);
          result = sub_4A6D20(v10, v7, (UINT)v13, 2u);
          v4 = item;
        }
      }
    }
    v8 = *(_DWORD *)(*(_DWORD *)(v4 + 2064) + 2072);
    if ( v8 )
    {
      sub_465D30(v8, v12);
      return sub_4A6D20(v10, hmenu, (UINT)v12, uPosition + 1);
    }
  }
  else
  {
    mi.cbSize = 48;
    mi.fMask = 66;
    mi.wID = 40174;
    mi.dwTypeData = L"Bookmark This Tab...";
    InsertMenuItemW(hmenu, 0, 1, &mi);
    return sub_48F860(hmenu, 0);
  }
  return result;
}
// 4CB55C: using guessed type wchar_t aBookmarkThisTa[21];
// 4CB588: using guessed type wchar_t aBookmarkThisTa_0[21];
// 4EB2DC: using guessed type int dword_4EB2DC;

//----- (004A6FC0) --------------------------------------------------------
int __usercall sub_4A6FC0@<eax>(HMENU *a1@<esi>)
{
  int v1; // eax
  int v2; // ebx
  UINT v3; // edi
  int result; // eax
  int v5; // ebx
  HMENU v6; // [esp-10h] [ebp-1080h]
  struct tagMENUITEMINFOW mii; // [esp+8h] [ebp-1068h] BYREF
  int v8[516]; // [esp+38h] [ebp-1038h] BYREF
  int v9; // [esp+848h] [ebp-828h]
  UINT item[519]; // [esp+850h] [ebp-820h] BYREF

  v1 = GetMenuItemCount(a1[866]) - 3;
  if ( v1 > 0 )
  {
    v2 = v1 - 1;
    if ( v1 - 1 >= 0 )
    {
      v3 = v2 + 3;
      do
      {
        v6 = a1[866];
        mii.cbSize = 48;
        mii.fMask = 32;
        GetMenuItemInfoW(v6, v3, 1, &mii);
        free((void *)mii.dwItemData);
        DeleteMenu(a1[866], v3--, 0x400u);
        --v2;
      }
      while ( v2 >= 0 );
    }
    dword_4EB2DC = 10000;
  }
  sub_466000((int)(a1 + 333), v8);
  result = v9;
  if ( !*(_DWORD *)(v9 + 1540) )
  {
    v5 = *(_DWORD *)(v9 + 2076);
    if ( v5 )
    {
      sub_465D30(v5, item);
      return sub_4A6D20(a1, a1[866], (UINT)item, 3u);
    }
  }
  return result;
}
// 4EB2DC: using guessed type int dword_4EB2DC;
// 4A6FC0: using guessed type int var_1038[516];

//----- (004A70B0) --------------------------------------------------------
int __thiscall sub_4A70B0(int this, WPARAM wParam)
{
  int result; // eax
  LPARAM lParam[5]; // [esp+Ch] [ebp-18h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    SendMessageW(*(HWND *)(this + 504), 0x417u, wParam, (LPARAM)lParam);
    result = sub_4A63A0((void *)lParam[3], *(HWND *)(this + 52));
    if ( result )
    {
      SendMessageW(*(HWND *)(this + 504), 0x416u, wParam, 0);
      return sub_4A6FC0((HMENU *)this);
    }
  }
  return result;
}

//----- (004A7130) --------------------------------------------------------
int __userpurge sub_4A7130@<eax>(int a1@<esi>, WPARAM wParam, int a3)
{
  int result; // eax
  LPARAM lParam[5]; // [esp+0h] [ebp-82Ch] BYREF
  _DWORD v5[386]; // [esp+14h] [ebp-818h] BYREF
  char v6[524]; // [esp+61Ch] [ebp-210h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 504), 0x417u, wParam, (LPARAM)lParam);
    result = (int)sub_465D30(lParam[3], v5);
    if ( v5[385] == 1 )
    {
      if ( a3 )
        return sub_48FFD0((int)v6, a1, 0, 1, 1);
      else
        return sub_490020((int)v6, a1, 0);
    }
  }
  return result;
}

//----- (004A71D0) --------------------------------------------------------
int __userpurge sub_4A71D0@<eax>(UINT a1@<edx>, _WORD *a2@<esi>, HMENU hmenu)
{
  struct tagMENUITEMINFOW mii; // [esp+8h] [ebp-854h] BYREF
  int v5[386]; // [esp+38h] [ebp-824h] BYREF
  char v6[532]; // [esp+640h] [ebp-21Ch] BYREF

  mii.cbSize = 48;
  mii.fMask = 32;
  GetMenuItemInfoW(hmenu, a1, 0, &mii);
  sub_465D30(*(_DWORD *)(mii.dwItemData + 8), v5);
  return sub_4A96F0(260, (int)v6, a2);
}
// 4A71D0: using guessed type int var_824[386];
// 4A71D0: using guessed type char var_21C[532];

//----- (004A7250) --------------------------------------------------------
WPARAM __userpurge sub_4A7250@<eax>(LPARAM a1@<esi>, WPARAM wParam)
{
  WPARAM result; // eax
  LPARAM dwInitParam[2]; // [esp+Ch] [ebp-840h] BYREF
  int lParam[3]; // [esp+14h] [ebp-838h] BYREF
  int v5; // [esp+20h] [ebp-82Ch]
  _DWORD v6[519]; // [esp+28h] [ebp-824h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 504), 0x417u, wParam, (LPARAM)lParam);
    sub_465D30(v5, v6);
    dwInitParam[0] = a1;
    dwInitParam[1] = v5;
    if ( v6[385] )
      return sub_401090((LPCWSTR)0xB6, *(HWND *)(a1 + 52), (DLGPROC)sub_4B0E20, (LPARAM)dwInitParam);
    else
      return sub_401090((LPCWSTR)0xD4, *(HWND *)(a1 + 52), (DLGPROC)sub_4B0C50, (LPARAM)dwInitParam);
  }
  return result;
}
// 4A7250: using guessed type LPARAM lParam[3];

//----- (004A7300) --------------------------------------------------------
int __thiscall sub_4A7300(HWND *this, int a2, int a3, int a4, DWORD dwErrCode)
{
  DWORD MessagePos; // eax
  signed int v7; // eax
  HWND v9; // [esp-Ch] [ebp-85Ch]
  struct tagPOINT Points; // [esp+10h] [ebp-840h] BYREF
  int v11; // [esp+18h] [ebp-838h]
  LPARAM lParam[5]; // [esp+1Ch] [ebp-834h] BYREF
  _DWORD v13[386]; // [esp+30h] [ebp-820h] BYREF
  __int16 Src[266]; // [esp+638h] [ebp-218h] BYREF

  v11 = a2;
  if ( a3 == 520 )
  {
    MessagePos = GetMessagePos();
    Points.x = (__int16)MessagePos;
    v9 = this[126];
    Points.y = SHIWORD(MessagePos);
    MapWindowPoints(0, v9, &Points, 1u);
    v7 = SendMessageW(this[126], 0x445u, 0, (LPARAM)&Points);
    if ( v7 >= 0 )
    {
      SendMessageW(this[126], 0x417u, v7, (LPARAM)lParam);
      sub_465D30(lParam[3], v13);
      if ( v13[385] == 1 )
        sub_4A6780((int)this, (LPCWSTR)Src, 1, 1);
    }
  }
  return sub_401C60(v11, a3, a4, dwErrCode);
}
// 4A7300: using guessed type WCHAR Src[266];

//----- (004A73F0) --------------------------------------------------------
int __stdcall sub_4A73F0(int a1, int a2, int a3, DWORD dwErrCode, int a5, int a6)
{
  return sub_4A7300((HWND *)a6, a1, a2, a3, dwErrCode);
}

//----- (004A7410) --------------------------------------------------------
INT_PTR __usercall sub_4A7410@<eax>(LPARAM a1@<eax>)
{
  HWND v2; // [esp-10h] [ebp-10h]

  v2 = *(HWND *)(a1 + 52);
  dword_4EF138 = 0;
  return sub_401090((LPCWSTR)0xD3, v2, sub_4B1510, a1);
}

//----- (004A7440) --------------------------------------------------------
_DWORD *__usercall sub_4A7440@<eax>(HWND *a1@<esi>)
{
  int v1; // edi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  int v5[519]; // [esp+8h] [ebp-820h] BYREF

  v1 = sub_4018B0(16, 16, 33, 0, 1u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v1, (int)BitmapW, 0);
  DeleteObject(BitmapW);
  SendMessageW(a1[126], 0x430u, 0, v1);
  sub_466000((int)(a1 + 333), v5);
  return sub_4A6BE0(a1, (int)v5);
}
// 4A7440: using guessed type _DWORD var_820[519];

//----- (004A74D0) --------------------------------------------------------
WPARAM __userpurge sub_4A74D0@<eax>(LPARAM a1@<esi>, WPARAM wParam)
{
  WPARAM result; // eax
  HWND v3; // ecx
  LPARAM dwInitParam[4]; // [esp+Ch] [ebp-848h] BYREF
  int lParam[3]; // [esp+1Ch] [ebp-838h] BYREF
  int v6; // [esp+28h] [ebp-82Ch]
  _DWORD v7[519]; // [esp+30h] [ebp-824h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 504), 0x417u, wParam, (LPARAM)lParam);
    sub_465D30(v6, v7);
    v3 = *(HWND *)(a1 + 52);
    dwInitParam[0] = a1;
    dwInitParam[1] = v7[385] == 0 ? v6 : 0;
    dwInitParam[2] = 0;
    dwInitParam[3] = 1;
    return sub_401090((LPCWSTR)0xB3, v3, sub_4AA4F0, (LPARAM)dwInitParam);
  }
  return result;
}
// 4A74D0: using guessed type LPARAM lParam[3];

//----- (004A7580) --------------------------------------------------------
BOOL __usercall sub_4A7580@<eax>(int a1@<edi>)
{
  signed int i; // esi
  BOOL result; // eax
  HMENU v3; // [esp-10h] [ebp-48h]
  HMENU v4; // [esp-10h] [ebp-48h]
  struct tagMENUITEMINFOW mii; // [esp+8h] [ebp-30h] BYREF

  for ( i = *(_DWORD *)(a1 + 5624) - 1; i >= 0; --i )
  {
    v3 = *(HMENU *)(a1 + 3448);
    mii.cbSize = 48;
    mii.fMask = 32;
    GetMenuItemInfoW(v3, i, 1, &mii);
    free((void *)mii.dwItemData);
    v4 = *(HMENU *)(a1 + 3452);
    mii.cbSize = 48;
    mii.fMask = 32;
    GetMenuItemInfoW(v4, i, 1, &mii);
    free((void *)mii.dwItemData);
    DeleteMenu(*(HMENU *)(a1 + 3448), i, 0x400u);
    DeleteMenu(*(HMENU *)(a1 + 3456), i, 0x400u);
    DeleteMenu(*(HMENU *)(a1 + 3452), i, 0x400u);
    result = DeleteMenu(*(HMENU *)(a1 + 3460), i, 0x400u);
  }
  return result;
}

//----- (004A7640) --------------------------------------------------------
int __usercall sub_4A7640@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
      result = 50100;
      break;
    case 1:
      result = 50103;
      break;
    case 2:
      result = 50101;
      break;
    case 3:
      result = 50102;
      break;
    case 4:
      result = 50104;
      break;
    case 5:
      result = 50105;
      break;
    case 6:
      result = 50127;
      break;
    case 7:
      result = 50107;
      break;
    case 8:
      result = 50108;
      break;
    case 9:
      result = 50109;
      break;
    case 10:
      result = 50110;
      break;
    case 11:
      result = 50111;
      break;
    case 12:
      result = 50112;
      break;
    case 13:
      result = 50113;
      break;
    case 14:
      result = 50114;
      break;
    case 15:
      result = 50115;
      break;
    case 16:
      result = 50116;
      break;
    case 17:
      result = 50117;
      break;
    case 18:
      result = 50118;
      break;
    case 19:
      result = 50119;
      break;
    case 20:
      result = 50120;
      break;
    case 21:
      result = 50121;
      break;
    case 22:
      result = 50122;
      break;
    case 23:
      result = 50123;
      break;
    case 24:
      result = 50124;
      break;
    case 25:
      result = 50125;
      break;
    case 26:
      result = 50126;
      break;
    case 27:
      result = -1;
      break;
    case 28:
      result = 50128;
      break;
    case 29:
      result = 50129;
      break;
    case 30:
      result = 50130;
      break;
    case 31:
      result = 50131;
      break;
    case 32:
      result = 50132;
      break;
    case 33:
      result = 50133;
      break;
    case 34:
      result = 50134;
      break;
    case 35:
      result = 50135;
      break;
    case 36:
      result = 50136;
      break;
    case 37:
      result = 50137;
      break;
    case 38:
      result = 50138;
      break;
    case 39:
      result = 50139;
      break;
  }
  return result;
}

//----- (004A77E0) --------------------------------------------------------
int __usercall sub_4A77E0@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
      result = 50000;
      break;
    case 1:
      result = 50003;
      break;
    case 2:
      result = 50001;
      break;
    case 3:
      result = 50002;
      break;
    case 4:
      result = 50004;
      break;
    case 5:
      result = 50005;
      break;
    case 6:
      result = 50027;
      break;
    case 7:
      result = 50007;
      break;
    case 8:
      result = 50008;
      break;
    case 9:
      result = 50009;
      break;
    case 10:
      result = 50010;
      break;
    case 11:
      result = 50011;
      break;
    case 12:
      result = 50012;
      break;
    case 13:
      result = 50013;
      break;
    case 14:
      result = 50014;
      break;
    case 15:
      result = 50015;
      break;
    case 16:
      result = 50016;
      break;
    case 17:
      result = 50017;
      break;
    case 18:
      result = 50018;
      break;
    case 19:
      result = 50019;
      break;
    case 20:
      result = 50020;
      break;
    case 21:
      result = 50021;
      break;
    case 22:
      result = 50022;
      break;
    case 23:
      result = 50023;
      break;
    case 24:
      result = 50024;
      break;
    case 25:
      result = 50025;
      break;
    case 26:
      result = 50026;
      break;
    case 27:
      result = -1;
      break;
    case 28:
      result = 50028;
      break;
    case 29:
      result = 50029;
      break;
    case 30:
      result = 50030;
      break;
    case 31:
      result = 50031;
      break;
    case 32:
      result = 50032;
      break;
    case 33:
      result = 50033;
      break;
    case 34:
      result = 50034;
      break;
    case 35:
      result = 50035;
      break;
    case 36:
      result = 50036;
      break;
    case 37:
      result = 50037;
      break;
    case 38:
      result = 50038;
      break;
    case 39:
      result = 50039;
      break;
  }
  return result;
}

//----- (004A7980) --------------------------------------------------------
int __usercall sub_4A7980@<eax>(int a1@<esi>)
{
  int result; // eax
  WCHAR psz2[262]; // [esp+8h] [ebp-210h] BYREF

  sub_4664A0(17, psz2);
  result = StrCmpW((PCWSTR)(a1 + 3492), psz2);
  if ( result )
  {
    sub_4664A0(3, psz2);
    result = StrCmpW((PCWSTR)(a1 + 3492), psz2);
    if ( result )
    {
      sub_4664A0(10, psz2);
      result = StrCmpW((PCWSTR)(a1 + 3492), psz2);
      if ( result )
      {
        result = a1 + 61260;
        *(_DWORD *)(a1 + 61256) = a1 + 61260;
      }
      else
      {
        *(_DWORD *)(a1 + 61256) = a1 + 61296;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 61256) = a1 + 61284;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 61256) = a1 + 61272;
  }
  return result;
}

//----- (004A7A70) --------------------------------------------------------
int __usercall sub_4A7A70@<eax>(int a1@<eax>)
{
  int result; // eax

  switch ( a1 )
  {
    case 0:
      result = 8009;
      break;
    case 1:
      result = 8010;
      break;
    case 2:
    case 34:
      result = 8011;
      break;
    case 3:
      result = 8012;
      break;
    case 4:
      result = 8013;
      break;
    case 5:
      result = 8014;
      break;
    case 6:
      result = 0;
      break;
    case 7:
      result = 8015;
      break;
    case 8:
      result = 8016;
      break;
    case 9:
      result = 8017;
      break;
    case 10:
      result = 8018;
      break;
    case 11:
      result = 8019;
      break;
    case 12:
      result = 8020;
      break;
    case 13:
      result = 8021;
      break;
    case 14:
      result = 8022;
      break;
    case 15:
      result = 8023;
      break;
    case 16:
      result = 8024;
      break;
    case 17:
      result = 8025;
      break;
    case 18:
      result = 8026;
      break;
    case 19:
      result = 8027;
      break;
    case 20:
      result = 8028;
      break;
    case 21:
      result = 8029;
      break;
    case 22:
      result = 8030;
      break;
    case 23:
      result = 8031;
      break;
    case 24:
      result = 8032;
      break;
    case 25:
      result = 8033;
      break;
    case 26:
      result = 8034;
      break;
    case 27:
    case 32:
    case 37:
      result = 8035;
      break;
    case 28:
      result = 8036;
      break;
    case 29:
      result = 8037;
      break;
    case 30:
      result = 8038;
      break;
    case 31:
      result = 8039;
      break;
    case 33:
      result = 8040;
      break;
    case 35:
      result = 8041;
      break;
    case 36:
      result = 8042;
      break;
    case 38:
      result = 8043;
      break;
    case 39:
      result = 8044;
      break;
  }
  return result;
}

//----- (004A7C00) --------------------------------------------------------
UINT __userpurge sub_4A7C00@<eax>(int a1@<ebx>, HMENU a2)
{
  _DWORD **v2; // ecx
  _DWORD *v3; // esi
  UINT v4; // edi
  unsigned int v5; // eax
  int v6; // eax
  HMENU v7; // edx
  MENUITEMINFOW mi; // [esp+Ch] [ebp-80h] BYREF
  HMENU hmenu; // [esp+3Ch] [ebp-50h]
  WCHAR Buffer[34]; // [esp+40h] [ebp-4Ch] BYREF

  v2 = *(_DWORD ***)(a1 + 61256);
  hmenu = a2;
  v3 = (_DWORD *)**v2;
  v4 = 0;
  if ( v3 != *v2 )
  {
    do
    {
      v5 = v3[2] - 50000;
      if ( v5 > 0x27 )
        v6 = 0;
      else
        v6 = sub_4A7A70(v5);
      LoadStringW(hInstance, v6, Buffer, 32);
      mi.dwTypeData = Buffer;
      mi.cbSize = 48;
      mi.fMask = 66;
      mi.wID = v3[2];
      InsertMenuItemW(hmenu, v4, 1, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 3456), v4, 1, &mi);
      memset(&mi, 0, sizeof(mi));
      mi.dwTypeData = Buffer;
      v7 = *(HMENU *)(a1 + 3452);
      mi.cbSize = 48;
      mi.fMask = 66;
      mi.wID = v3[3];
      InsertMenuItemW(v7, v4, 1, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 3460), v4, 1, &mi);
      v3 = (_DWORD *)*v3;
      ++v4;
    }
    while ( v3 != **(_DWORD ***)(a1 + 61256) );
  }
  return v4;
}

//----- (004A7D10) --------------------------------------------------------
char **__usercall sub_4A7D10@<eax>(int a1@<edi>)
{
  HMENU Menu; // eax
  HMENU SubMenu; // eax
  HMENU v3; // ecx
  HMENU v4; // esi
  HMENU v5; // eax
  int v6; // ebx
  char **v7; // eax
  int v8; // ecx
  int v9; // ebx
  char **v10; // eax
  int v11; // ecx
  int v12; // ebx
  char **v13; // eax
  int v14; // ecx
  int v15; // ebx
  char **v16; // eax
  int v17; // ecx
  int v18; // ebx
  char **v19; // eax
  int v20; // ecx
  int v21; // ebx
  char **v22; // eax
  int v23; // ecx
  int v24; // ebx
  char **v25; // eax
  int v26; // ecx
  int v27; // ebx
  char **v28; // eax
  int v29; // ecx
  int v30; // ebx
  char **v31; // eax
  int v32; // ecx
  int v33; // ebx
  char **v34; // eax
  int v35; // ecx
  int v36; // ebx
  char **v37; // eax
  int v38; // ecx
  int v39; // ebx
  char **v40; // eax
  int v41; // ecx
  int v42; // ebx
  char **v43; // eax
  int v44; // ecx
  int v45; // ebx
  char **v46; // eax
  int v47; // ecx
  int v48; // ebx
  char **v49; // eax
  int v50; // ecx
  int v51; // ebx
  char **v52; // eax
  int v53; // ecx
  int v54; // ebx
  char **result; // eax
  int v56; // ecx
  int v57; // [esp-4h] [ebp-44h]
  int v58; // [esp-4h] [ebp-44h]
  int v59; // [esp-4h] [ebp-44h]
  int v60; // [esp-4h] [ebp-44h]
  int v61; // [esp-4h] [ebp-44h]
  int v62; // [esp-4h] [ebp-44h]
  int v63; // [esp-4h] [ebp-44h]
  int v64; // [esp-4h] [ebp-44h]
  int v65; // [esp-4h] [ebp-44h]
  int v66; // [esp-4h] [ebp-44h]
  int v67; // [esp-4h] [ebp-44h]
  int v68; // [esp-4h] [ebp-44h]
  int v69; // [esp-4h] [ebp-44h]
  int v70; // [esp-4h] [ebp-44h]
  int v71; // [esp-4h] [ebp-44h]
  int v72; // [esp-4h] [ebp-44h]
  int v73; // [esp-4h] [ebp-44h]
  MENUITEMINFOW mii; // [esp+8h] [ebp-38h] BYREF
  int v75; // [esp+38h] [ebp-8h] BYREF
  int v76; // [esp+3Ch] [ebp-4h]

  Menu = GetMenu(*(HWND *)(a1 + 52));
  SubMenu = GetSubMenu(Menu, 3);
  v3 = *(HMENU *)(a1 + 3448);
  v4 = SubMenu;
  mii.cbSize = 48;
  mii.fMask = 4;
  mii.hSubMenu = v3;
  SetMenuItemInfoW(SubMenu, 0x9D5Du, 0, &mii);
  v5 = *(HMENU *)(a1 + 3452);
  mii.cbSize = 48;
  mii.fMask = 4;
  mii.hSubMenu = v5;
  SetMenuItemInfoW(v4, 0x9DB9u, 0, &mii);
  v6 = *(_DWORD *)(a1 + 61260);
  v57 = *(_DWORD *)(v6 + 4);
  v75 = 50000;
  v76 = 50100;
  v7 = sub_419770((char **)&v75, (char *)v6, v57);
  v8 = *(_DWORD *)(a1 + 61264);
  if ( v8 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61264) = v8 + 1;
  *(_DWORD *)(v6 + 4) = v7;
  *(_DWORD *)v7[1] = v7;
  v9 = *(_DWORD *)(a1 + 61260);
  v58 = *(_DWORD *)(v9 + 4);
  v75 = 50001;
  v76 = 50101;
  v10 = sub_419770((char **)&v75, (char *)v9, v58);
  v11 = *(_DWORD *)(a1 + 61264);
  if ( v11 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61264) = v11 + 1;
  *(_DWORD *)(v9 + 4) = v10;
  *(_DWORD *)v10[1] = v10;
  v12 = *(_DWORD *)(a1 + 61260);
  v59 = *(_DWORD *)(v12 + 4);
  v75 = 50002;
  v76 = 50102;
  v13 = sub_419770((char **)&v75, (char *)v12, v59);
  v14 = *(_DWORD *)(a1 + 61264);
  if ( v14 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61264) = v14 + 1;
  *(_DWORD *)(v12 + 4) = v13;
  *(_DWORD *)v13[1] = v13;
  v15 = *(_DWORD *)(a1 + 61260);
  v60 = *(_DWORD *)(v15 + 4);
  v75 = 50003;
  v76 = 50103;
  v16 = sub_419770((char **)&v75, (char *)v15, v60);
  v17 = *(_DWORD *)(a1 + 61264);
  if ( v17 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61264) = v17 + 1;
  *(_DWORD *)(v15 + 4) = v16;
  *(_DWORD *)v16[1] = v16;
  v18 = *(_DWORD *)(a1 + 61272);
  v61 = *(_DWORD *)(v18 + 4);
  v75 = 50000;
  v76 = 50100;
  v19 = sub_419770((char **)&v75, (char *)v18, v61);
  v20 = *(_DWORD *)(a1 + 61276);
  if ( v20 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61276) = v20 + 1;
  *(_DWORD *)(v18 + 4) = v19;
  *(_DWORD *)v19[1] = v19;
  v21 = *(_DWORD *)(a1 + 61272);
  v62 = *(_DWORD *)(v21 + 4);
  v75 = 50002;
  v76 = 50102;
  v22 = sub_419770((char **)&v75, (char *)v21, v62);
  v23 = *(_DWORD *)(a1 + 61276);
  if ( v23 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61276) = v23 + 1;
  *(_DWORD *)(v21 + 4) = v22;
  *(_DWORD *)v22[1] = v22;
  v24 = *(_DWORD *)(a1 + 61272);
  v63 = *(_DWORD *)(v24 + 4);
  v75 = 50004;
  v76 = 50104;
  v25 = sub_419770((char **)&v75, (char *)v24, v63);
  v26 = *(_DWORD *)(a1 + 61276);
  if ( v26 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61276) = v26 + 1;
  *(_DWORD *)(v24 + 4) = v25;
  *(_DWORD *)v25[1] = v25;
  v27 = *(_DWORD *)(a1 + 61272);
  v64 = *(_DWORD *)(v27 + 4);
  v75 = 50005;
  v76 = 50105;
  v28 = sub_419770((char **)&v75, (char *)v27, v64);
  v29 = *(_DWORD *)(a1 + 61276);
  if ( v29 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61276) = v29 + 1;
  *(_DWORD *)(v27 + 4) = v28;
  *(_DWORD *)v28[1] = v28;
  v30 = *(_DWORD *)(a1 + 61272);
  v65 = *(_DWORD *)(v30 + 4);
  v75 = 50027;
  v76 = 50127;
  v31 = sub_419770((char **)&v75, (char *)v30, v65);
  v32 = *(_DWORD *)(a1 + 61276);
  if ( v32 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61276) = v32 + 1;
  *(_DWORD *)(v30 + 4) = v31;
  *(_DWORD *)v31[1] = v31;
  v33 = *(_DWORD *)(a1 + 61284);
  v66 = *(_DWORD *)(v33 + 4);
  v75 = 50000;
  v76 = 50100;
  v34 = sub_419770((char **)&v75, (char *)v33, v66);
  v35 = *(_DWORD *)(a1 + 61288);
  if ( v35 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61288) = v35 + 1;
  *(_DWORD *)(v33 + 4) = v34;
  *(_DWORD *)v34[1] = v34;
  v36 = *(_DWORD *)(a1 + 61284);
  v67 = *(_DWORD *)(v36 + 4);
  v75 = 50027;
  v76 = 50127;
  v37 = sub_419770((char **)&v75, (char *)v36, v67);
  v38 = *(_DWORD *)(a1 + 61288);
  if ( v38 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61288) = v38 + 1;
  *(_DWORD *)(v36 + 4) = v37;
  *(_DWORD *)v37[1] = v37;
  v39 = *(_DWORD *)(a1 + 61296);
  v68 = *(_DWORD *)(v39 + 4);
  v75 = 50000;
  v76 = 50100;
  v40 = sub_419770((char **)&v75, (char *)v39, v68);
  v41 = *(_DWORD *)(a1 + 61300);
  if ( v41 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v41 + 1;
  *(_DWORD *)(v39 + 4) = v40;
  *(_DWORD *)v40[1] = v40;
  v42 = *(_DWORD *)(a1 + 61296);
  v69 = *(_DWORD *)(v42 + 4);
  v75 = 50008;
  v76 = 50108;
  v43 = sub_419770((char **)&v75, (char *)v42, v69);
  v44 = *(_DWORD *)(a1 + 61300);
  if ( v44 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v44 + 1;
  *(_DWORD *)(v42 + 4) = v43;
  *(_DWORD *)v43[1] = v43;
  v45 = *(_DWORD *)(a1 + 61296);
  v70 = *(_DWORD *)(v45 + 4);
  v75 = 50007;
  v76 = 50107;
  v46 = sub_419770((char **)&v75, (char *)v45, v70);
  v47 = *(_DWORD *)(a1 + 61300);
  if ( v47 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v47 + 1;
  *(_DWORD *)(v45 + 4) = v46;
  *(_DWORD *)v46[1] = v46;
  v48 = *(_DWORD *)(a1 + 61296);
  v71 = *(_DWORD *)(v48 + 4);
  v76 = 50101;
  v49 = sub_419770((char **)&v75, (char *)v48, v71);
  v50 = *(_DWORD *)(a1 + 61300);
  if ( v50 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v50 + 1;
  *(_DWORD *)(v48 + 4) = v49;
  *(_DWORD *)v49[1] = v49;
  v51 = *(_DWORD *)(a1 + 61296);
  v72 = *(_DWORD *)(v51 + 4);
  v75 = 50002;
  v76 = 50102;
  v52 = sub_419770((char **)&v75, (char *)v51, v72);
  v53 = *(_DWORD *)(a1 + 61300);
  if ( v53 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v53 + 1;
  *(_DWORD *)(v51 + 4) = v52;
  *(_DWORD *)v52[1] = v52;
  v54 = *(_DWORD *)(a1 + 61296);
  v73 = *(_DWORD *)(v54 + 4);
  v75 = 50003;
  v76 = 50103;
  result = sub_419770((char **)&v75, (char *)v54, v73);
  v56 = *(_DWORD *)(a1 + 61300);
  if ( v56 == 536870910 )
    std::_Xlength_error("list<T> too long");
  *(_DWORD *)(a1 + 61300) = v56 + 1;
  *(_DWORD *)(v54 + 4) = result;
  *(_DWORD *)result[1] = result;
  return result;
}

//----- (004A8290) --------------------------------------------------------
void __stdcall sub_4A8290(int a1)
{
  _DWORD *v1; // eax
  int v2; // ebx
  _DWORD **v3; // ecx
  _DWORD *v4; // eax
  int v5; // edi
  _DWORD *v6; // esi
  void ***v7; // ecx
  void **v8; // esi
  unsigned int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ebx
  char **v13; // eax
  int v14; // ecx
  void **v15; // eax
  void **v16; // esi
  int v17; // eax
  void **v18; // eax
  void *v19; // ecx
  void **v20; // esi
  char *v21; // [esp-8h] [ebp-54h]
  int v22; // [esp-4h] [ebp-50h]
  void **v23; // [esp+14h] [ebp-38h]
  char *v24; // [esp+18h] [ebp-34h] BYREF
  char *v25[2]; // [esp+1Ch] [ebp-30h] BYREF
  void *v26; // [esp+24h] [ebp-28h] BYREF
  int v27; // [esp+28h] [ebp-24h]
  int pExceptionObject[7]; // [esp+30h] [ebp-1Ch] BYREF

  v27 = 0;
  v1 = operator new(0xCu);
  if ( !v1 )
  {
    v24 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v24);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v26 = v1;
  *v1 = v1;
  *((_DWORD *)v26 + 1) = v26;
  v2 = a1;
  pExceptionObject[6] = 0;
  sub_4A7580(a1);
  (*(void (__thiscall **)(_DWORD, void **))(**(_DWORD **)(v2 + 1320) + 284))(*(_DWORD *)(v2 + 1320), &v26);
  v3 = *(_DWORD ***)(a1 + 61244);
  v4 = *v3;
  v5 = a1 + 61244;
  *v3 = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 61244) + 4) = *(_DWORD *)(a1 + 61244);
  *(_DWORD *)(a1 + 61248) = 0;
  if ( v4 != *(_DWORD **)(a1 + 61244) )
  {
    do
    {
      v6 = (_DWORD *)*v4;
      operator delete(v4);
      v4 = v6;
    }
    while ( v6 != *(_DWORD **)v5 );
  }
  if ( v27 )
  {
    v7 = (void ***)v26;
    v8 = *(void ***)v26;
    v23 = *(void ***)v26;
    if ( *(void **)v26 == v26 )
    {
      *(_DWORD *)(a1 + 61256) = v5;
    }
    else
    {
      while ( 1 )
      {
        v9 = (unsigned int)v8[2] - 1;
        if ( v9 > 0x27 )
          v10 = -1;
        else
          v10 = sub_4A77E0((int)v8[2] - 1);
        if ( v9 > 0x27 )
          v11 = -1;
        else
          v11 = sub_4A7640(v9);
        if ( v10 != -1 && v11 != -1 )
        {
          v12 = *(_DWORD *)v5;
          v22 = *(_DWORD *)(*(_DWORD *)v5 + 4);
          v21 = *(char **)v5;
          v25[0] = (char *)v10;
          v25[1] = (char *)v11;
          v13 = sub_419770(v25, v21, v22);
          v14 = *(_DWORD *)(a1 + 61248);
          if ( v14 == 536870910 )
            std::_Xlength_error("list<T> too long");
          v8 = v23;
          *(_DWORD *)(a1 + 61248) = v14 + 1;
          *(_DWORD *)(v12 + 4) = v13;
          v2 = a1;
          *(_DWORD *)v13[1] = v13;
        }
        v23 = (void **)*v8;
        if ( *v8 == v26 )
          break;
        v8 = (void **)*v8;
      }
      v7 = (void ***)v26;
      *(_DWORD *)(v2 + 61256) = v5;
    }
  }
  else
  {
    sub_4A7980(a1);
    v7 = (void ***)v26;
  }
  v15 = *v7;
  *v7 = (void **)v7;
  *((_DWORD *)v26 + 1) = v26;
  v27 = 0;
  if ( v15 != v26 )
  {
    do
    {
      v16 = (void **)*v15;
      operator delete(v15);
      v15 = v16;
    }
    while ( v16 != v26 );
  }
  v17 = sub_4A7C00(v2, *(HMENU *)(v2 + 3448));
  *(_DWORD *)(a1 + 5624) = v17;
  sub_48FCC0(*(HMENU *)(a1 + 3448), v17);
  sub_48FCC0(*(HMENU *)(a1 + 3452), *(_DWORD *)(a1 + 5624));
  v18 = *(void ***)v26;
  *(_DWORD *)v26 = v26;
  *((_DWORD *)v26 + 1) = v26;
  v19 = v26;
  v27 = 0;
  if ( v18 != v26 )
  {
    do
    {
      v20 = (void **)*v18;
      operator delete(v18);
      v19 = v26;
      v18 = v20;
    }
    while ( v20 != v26 );
  }
  operator delete(v19);
}
// 4A8374: variable 'v9' is possibly undefined
// 4A8385: variable 'v10' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004A84E0) --------------------------------------------------------
BOOL __usercall sub_4A84E0@<eax>(int a1@<eax>)
{
  HMENU v2; // edi
  _DWORD *v3; // eax
  HMENU v5; // [esp-10h] [ebp-80h]
  HMENU v6; // [esp-10h] [ebp-80h]
  MENUITEMINFOW mi; // [esp+10h] [ebp-60h] BYREF
  struct tagMENUITEMINFOW mii; // [esp+40h] [ebp-30h] BYREF

  v5 = *(HMENU *)(a1 + 3472);
  mi.cbSize = 48;
  mi.fMask = 66;
  mi.dwTypeData = L"New Application Button...";
  mi.wID = 40360;
  InsertMenuItemW(v5, 7u, 1, &mi);
  v2 = *(HMENU *)(a1 + 3472);
  mii.cbSize = 48;
  mii.fMask = 258;
  GetMenuItemInfoW(v2, 7u, 1, &mii);
  if ( (mii.fType & 0x100) == 0 )
    mii.fType |= 0x100u;
  v3 = malloc(0xCu);
  v3[1] = 0;
  v3[2] = 0;
  mii.fMask |= 0x20u;
  mii.dwItemData = (ULONG_PTR)v3;
  SetMenuItemInfoW(v2, 7u, 1, &mii);
  sub_48F5E0(a1);
  v6 = *(HMENU *)(a1 + 3472);
  mi.cbSize = 48;
  mi.fMask = 32;
  GetMenuItemInfoW(v6, 7u, 1, &mi);
  free((void *)mi.dwItemData);
  return DeleteMenu(*(HMENU *)(a1 + 3472), 7u, 0x400u);
}
// 4CB62C: using guessed type wchar_t aNewApplication[26];

//----- (004A85C0) --------------------------------------------------------
HWND __usercall sub_4A85C0@<eax>(HWND a1@<esi>)
{
  HWND DlgItem; // edi
  WCHAR Buffer[64]; // [esp+4h] [ebp-84h] BYREF

  DlgItem = GetDlgItem(a1, 1200);
  CheckDlgButton(a1, 1222, 1u);
  LoadStringW(hInstance, 0x84Bu, Buffer, 64);
  SetWindowTextW(a1, Buffer);
  return SetFocus(DlgItem);
}

//----- (004A8630) --------------------------------------------------------
HWND __usercall sub_4A8630@<eax>(int a1@<ebx>, HWND a2@<edi>)
{
  HWND DlgItem; // esi
  HWND hWnd; // [esp+4h] [ebp-4h]

  DlgItem = GetDlgItem(a2, 1200);
  hWnd = GetDlgItem(a2, 1199);
  SetWindowTextW(DlgItem, *(LPCWSTR *)(a1 + 60408));
  SetWindowTextW(hWnd, (LPCWSTR)(*(_DWORD *)(a1 + 60408) + 1024));
  CheckDlgButton(a2, 1222, *(_DWORD *)(*(_DWORD *)(a1 + 60408) + 2048) != 0);
  SendMessageW(DlgItem, 0xB1u, 0, -1);
  return SetFocus(DlgItem);
}

//----- (004A86C0) --------------------------------------------------------
LRESULT __userpurge sub_4A86C0@<eax>(int a1@<edi>, WPARAM wParam)
{
  LRESULT result; // eax
  const WCHAR *v3; // esi
  bool v4; // zf
  LPARAM v5[6]; // [esp+Ch] [ebp-500h] BYREF
  const WCHAR *v6; // [esp+24h] [ebp-4E8h]
  LPARAM lParam[3]; // [esp+2Ch] [ebp-4E0h] BYREF
  const WCHAR *v8; // [esp+38h] [ebp-4D4h]
  SHFILEINFOW psfi; // [esp+40h] [ebp-4CCh] BYREF
  WCHAR pszPath[262]; // [esp+2F8h] [ebp-214h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    result = SendMessageW(*(HWND *)(a1 + 512), 0x417u, wParam, (LPARAM)lParam);
    if ( result )
    {
      v3 = v8;
      sub_466280(v8 + 512, pszPath);
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u);
      v5[0] = 32;
      v5[1] = 3;
      v5[3] = psfi.iIcon;
      v4 = *((_DWORD *)v3 + 512) == 0;
      v6 = v3;
      if ( v4 )
        v6 = (const WCHAR *)&unk_4CB5CC;
      return SendMessageW(*(HWND *)(a1 + 512), 0x440u, lParam[1], (LPARAM)v5);
    }
  }
  return result;
}

//----- (004A87B0) --------------------------------------------------------
HWND __usercall sub_4A87B0@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax
  HWND v3; // ecx
  SHFILEINFOW psfi; // [esp+8h] [ebp-4E0h] BYREF
  LPARAM lParam[2]; // [esp+2C4h] [ebp-224h] BYREF
  __int16 v7; // [esp+2CCh] [ebp-21Ch]
  int v8; // [esp+2D0h] [ebp-218h]
  int v9; // [esp+2D4h] [ebp-214h]
  WCHAR pszPath[262]; // [esp+2D8h] [ebp-210h] BYREF

  sub_466280((LPCWSTR)(a2 + 1024), pszPath);
  if ( !SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x4000u) )
    psfi.iIcon = 0;
  v2 = *(_DWORD *)(a1 + 60416);
  lParam[0] = psfi.iIcon;
  lParam[1] = v2 + 49000;
  v7 = 4100;
  v8 = a2;
  v9 = 0;
  if ( *(_DWORD *)(a2 + 2048) )
  {
    HIBYTE(v7) = 80;
    v9 = a2;
  }
  v3 = *(HWND *)(a1 + 512);
  *(_DWORD *)(a1 + 60416) = v2 + 1;
  SendMessageW(v3, 0x444u, 1u, (LPARAM)lParam);
  return sub_467F60(*(HWND *)(a1 + 60), *(HWND *)(a1 + 512));
}

//----- (004A8890) --------------------------------------------------------
void __usercall sub_4A8890(int a1@<edi>)
{
  int v1; // ebx
  char *v2; // eax
  char *v3; // esi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // eax
  HANDLE hObject; // [esp+Ch] [ebp-4D4h]
  char *lParam; // [esp+10h] [ebp-4D0h]
  HANDLE TokenHandle; // [esp+14h] [ebp-4CCh] BYREF
  SHFILEINFOW psfi; // [esp+18h] [ebp-4C8h] BYREF
  WCHAR Dest[262]; // [esp+2D0h] [ebp-210h] BYREF

  v1 = *(_DWORD *)(a1 + 60404);
  if ( v1 )
  {
    v2 = (char *)malloc(20 * *(_DWORD *)(a1 + 60412));
    lParam = v2;
    if ( v2 )
    {
      v3 = v2 + 8;
      do
      {
        CurrentProcessId = GetCurrentProcessId();
        v5 = OpenProcess(0x400u, 0, CurrentProcessId);
        hObject = v5;
        if ( v5 )
        {
          if ( OpenProcessToken(v5, 0xCu, &TokenHandle) )
          {
            ExpandEnvironmentStringsForUserW(TokenHandle, (LPCWSTR)(v1 + 1024), Dest, 0x104u);
            CloseHandle(TokenHandle);
          }
          CloseHandle(hObject);
        }
        if ( !SHGetFileInfoW(Dest, 0, &psfi, 0x2B4u, 0x4000u) )
          psfi.iIcon = 0;
        *((_DWORD *)v3 - 2) = psfi.iIcon;
        *((_DWORD *)v3 - 1) = *(_DWORD *)(a1 + 60416) + 49000;
        *(_WORD *)v3 = 4100;
        *((_DWORD *)v3 + 1) = v1;
        *((_DWORD *)v3 + 2) = 0;
        if ( *(_DWORD *)(v1 + 2048) )
        {
          v3[1] = 80;
          *((_DWORD *)v3 + 2) = v1;
        }
        ++*(_DWORD *)(a1 + 60416);
        v1 = *(_DWORD *)(v1 + 2052);
        v3 += 20;
      }
      while ( v1 );
      SendMessageW(*(HWND *)(a1 + 512), 0x444u, *(_DWORD *)(a1 + 60412), (LPARAM)lParam);
      sub_467F60(*(HWND *)(a1 + 60), *(HWND *)(a1 + 512));
      free(lParam);
    }
  }
}

//----- (004A8A10) --------------------------------------------------------
void __usercall sub_4A8A10(WPARAM wParam@<ecx>, int a2@<esi>)
{
  _DWORD *v3; // eax
  _DWORD *v4; // edi
  int v5; // ecx
  _DWORD *v6; // edx
  int v7; // eax
  int lParam[3]; // [esp+Ch] [ebp-11Ch] BYREF
  void *Block; // [esp+18h] [ebp-110h]
  WCHAR Buffer[130]; // [esp+20h] [ebp-108h] BYREF

  if ( wParam != -1 )
  {
    if ( SendMessageW(*(HWND *)(a2 + 512), 0x417u, wParam, (LPARAM)lParam) )
    {
      LoadStringW(hInstance, 0x7FBu, Buffer, 128);
      if ( MessageBoxW(*(HWND *)(a2 + 52), Buffer, L"Explorer++", 0x144u) == 6 )
      {
        v3 = Block;
        v4 = Block;
        if ( *(void **)(a2 + 60404) == Block )
          *(_DWORD *)(a2 + 60404) = *((_DWORD *)Block + 513);
        v5 = v3[513];
        v6 = v3 + 513;
        if ( v5 )
          *(_DWORD *)(v5 + 2056) = v3[514];
        v7 = v4[514];
        if ( v7 )
          *(_DWORD *)(v7 + 2052) = *v6;
        free(v4);
        SendMessageW(*(HWND *)(a2 + 512), 0x416u, wParam, 0);
        sub_467F60(*(HWND *)(a2 + 60), *(HWND *)(a2 + 512));
      }
    }
  }
}
// 4A8A10: using guessed type LPARAM lParam[3];

//----- (004A8B40) --------------------------------------------------------
BOOL __usercall sub_4A8B40@<eax>(int a1@<eax>, HWND a2@<esi>)
{
  HWND DlgItem; // ebx
  HWND hWnd; // [esp+Ch] [ebp-4h]

  hWnd = GetDlgItem(a2, 1200);
  DlgItem = GetDlgItem(a2, 1199);
  GetWindowTextW(hWnd, *(LPWSTR *)(a1 + 60408), 512);
  GetWindowTextW(DlgItem, (LPWSTR)(*(_DWORD *)(a1 + 60408) + 1024), 512);
  *(_DWORD *)(*(_DWORD *)(a1 + 60408) + 2048) = IsDlgButtonChecked(a2, 1222) == 1;
  sub_4A86C0(a1, *(_DWORD *)(a1 + 60384));
  return EndDialog(a2, 1);
}

//----- (004A8BD0) --------------------------------------------------------
HRESULT __thiscall sub_4A8BD0(int this)
{
  HWND v2; // esi
  HMODULE ModuleHandleW; // eax
  HWND Window; // eax
  HWND v5; // esi
  IDropTarget *v6; // eax
  IDropTarget *v7; // esi
  IDropTarget *v8; // ebx
  HIMAGELIST phimlSmall[4]; // [esp+18h] [ebp-10h] BYREF

  v2 = *(HWND *)(this + 60);
  ModuleHandleW = GetModuleHandleW(0);
  Window = CreateWindowExW(0, L"ToolbarWindow32", &word_4C30C0, 0x56009944u, 0, 0, 0, 0, v2, 0, ModuleHandleW, 0);
  v5 = Window;
  if ( Window )
    SendMessageW(Window, 0x454u, 0, 153);
  *(_DWORD *)(this + 512) = v5;
  SendMessageW(v5, 0x420u, 0, 1048592);
  SendMessageW(*(HWND *)(this + 512), 0x41Eu, 0x14u, 0);
  Shell_GetImageLists(0, phimlSmall);
  SendMessageW(*(HWND *)(this + 512), 0x430u, 0, (LPARAM)phimlSmall[0]);
  sub_4A8890(this);
  v6 = (IDropTarget *)operator new(0x18u);
  v7 = v6;
  phimlSmall[3] = 0;
  if ( v6 )
  {
    v8 = v6 + 3;
    v6->lpVtbl = (struct IDropTargetVtbl *)&Explorerplusplus::CApplicationToolbarDrop::`vftable';
    v6[2].lpVtbl = (struct IDropTargetVtbl *)this;
    if ( CoCreateInstance(&rclsid, 0, 1u, &riid, (LPVOID *)&v6[3].lpVtbl) >= 0 )
      (*(void (__stdcall **)(struct IDropTargetVtbl *, void *, IDropTarget *))v8->lpVtbl->QueryInterface)(
        v8->lpVtbl,
        &unk_4BD88C,
        v7 + 4);
  }
  else
  {
    v7 = 0;
  }
  return RegisterDragDrop(*(HWND *)(this + 512), v7);
}
// 4CB88C: using guessed type void *Explorerplusplus::CApplicationToolbarDrop::`vftable';

//----- (004A8D10) --------------------------------------------------------
void __fastcall sub_4A8D10(int a1, const WCHAR *a2, WPARAM wParam)
{
  LPVOID pv; // [esp+10h] [ebp-22Ch] BYREF
  LPARAM lParam[5]; // [esp+14h] [ebp-228h] BYREF
  WCHAR Dest[262]; // [esp+28h] [ebp-214h] BYREF

  pv = 0;
  if ( wParam != -1 && SendMessageW(*(HWND *)(a1 + 512), 0x417u, wParam, (LPARAM)lParam) )
  {
    sub_466280((LPCWSTR)(lParam[3] + 1024), Dest);
    if ( sub_467810((LPITEMIDLIST *)&pv, (int)Dest) >= 0 )
    {
      sub_48F6D0(a1, (ITEMIDLIST *)pv, a2);
      CoTaskMemFree(pv);
    }
  }
}

//----- (004A8DD0) --------------------------------------------------------
_DWORD *__stdcall sub_4A8DD0(int a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax
  int v5; // esi
  _WORD *v6; // ecx
  __int16 v7; // dx
  _WORD *v8; // ecx
  int v9; // esi
  __int16 v10; // dx
  int v11; // ecx

  result = malloc(0x810u);
  if ( result )
  {
    v5 = 512;
    v6 = result;
    while ( v5 != -2147483134 )
    {
      v7 = *(_WORD *)((char *)v6 + a2 - (_DWORD)result);
      if ( !v7 )
        break;
      *v6++ = v7;
      if ( !--v5 )
      {
        --v6;
        break;
      }
    }
    *v6 = 0;
    v8 = result + 256;
    v9 = 512;
    while ( v9 != -2147483134 )
    {
      v10 = *(_WORD *)((char *)v8 + a3 - (_DWORD)(result + 256));
      if ( !v10 )
        break;
      *v8++ = v10;
      if ( !--v9 )
      {
        --v8;
        break;
      }
    }
    *v8 = 0;
    result[513] = 0;
    result[512] = a4;
    v11 = *(_DWORD *)(a1 + 60404);
    if ( v11 )
    {
      for ( ; *(_DWORD *)(v11 + 2052); v11 = *(_DWORD *)(v11 + 2052) )
        ;
      result[514] = v11;
      *(_DWORD *)(v11 + 2052) = result;
      ++*(_DWORD *)(a1 + 60412);
    }
    else
    {
      result[514] = 0;
      ++*(_DWORD *)(a1 + 60412);
      *(_DWORD *)(a1 + 60404) = result;
    }
  }
  return result;
}
// 4A8E16: conditional instruction was optimized away because esi.4!=0
// 4A8E50: conditional instruction was optimized away because esi.4!=0

//----- (004A8ED0) --------------------------------------------------------
BOOL __usercall sub_4A8ED0@<eax>(int a1@<ecx>, HWND a2@<ebx>)
{
  HWND DlgItem; // esi
  UINT v4; // eax
  _DWORD *v5; // eax
  HWND hWnd; // [esp+Ch] [ebp-80Ch]
  WCHAR String[512]; // [esp+10h] [ebp-808h] BYREF
  WCHAR v9[514]; // [esp+410h] [ebp-408h] BYREF

  hWnd = GetDlgItem(a2, 1200);
  DlgItem = GetDlgItem(a2, 1199);
  GetWindowTextW(hWnd, String, 512);
  GetWindowTextW(DlgItem, v9, 512);
  v4 = IsDlgButtonChecked(a2, 1222);
  v5 = sub_4A8DD0(a1, (int)String, (int)v9, v4 == 1);
  sub_4A87B0(a1, (int)v5);
  return EndDialog(a2, 1);
}

//----- (004A8F80) --------------------------------------------------------
int __usercall sub_4A8F80@<eax>(HWND a1@<edi>)
{
  HWND DlgItem; // ebx
  int result; // eax
  DWORD dwErrCode[22]; // [esp+8h] [ebp-268h] BYREF
  WCHAR String[262]; // [esp+60h] [ebp-210h] BYREF

  memset(String, 0, 520);
  DlgItem = GetDlgItem(a1, 1199);
  dwErrCode[0] = 88;
  dwErrCode[1] = (DWORD)a1;
  dwErrCode[3] = (DWORD)L"Programs (*.exe)";
  memset(&dwErrCode[4], 0, 12);
  dwErrCode[7] = (DWORD)String;
  dwErrCode[8] = 260;
  memset(&dwErrCode[9], 0, 16);
  dwErrCode[13] = 8394752;
  dwErrCode[15] = (DWORD)L"exe";
  dwErrCode[16] = 0;
  dwErrCode[17] = 0;
  memset(&dwErrCode[19], 0, 12);
  result = sub_401AE0((DWORD)dwErrCode);
  if ( result )
    return SetWindowTextW(DlgItem, String);
  return result;
}
// 4CB5D0: using guessed type wchar_t aProgramsExe[17];
// 4CB624: using guessed type wchar_t aExe[4];

//----- (004A9060) --------------------------------------------------------
int __userpurge sub_4A9060@<eax>(HWND hDlg@<ecx>, int a2@<eax>, __int16 a3)
{
  int v3; // eax
  int v4; // eax

  v3 = a2 - 16;
  if ( !v3 )
  {
LABEL_10:
    EndDialog(hDlg, 0);
    return 0;
  }
  v4 = v3 - 256;
  if ( !v4 )
  {
    sub_4A85C0(hDlg);
    return 0;
  }
  if ( v4 == 1 )
  {
    if ( a3 == 1 )
    {
      sub_4A8ED0(dword_4EF7B0, hDlg);
      return 0;
    }
    if ( a3 != 2 )
    {
      if ( a3 == 1198 )
      {
        sub_4A8F80(hDlg);
        return 0;
      }
      return 0;
    }
    goto LABEL_10;
  }
  return 0;
}
// 4EF7B0: using guessed type int dword_4EF7B0;

//----- (004A90D0) --------------------------------------------------------
int __stdcall sub_4A90D0(HWND hDlg, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4EF7B0 = a4;
  return sub_4A9060(hDlg, a2, a3);
}
// 4EF7B0: using guessed type int dword_4EF7B0;

//----- (004A9100) --------------------------------------------------------
int __userpurge sub_4A9100@<eax>(HWND hDlg@<ecx>, int a2@<eax>, __int16 a3)
{
  int v3; // eax
  int v4; // eax

  v3 = a2 - 16;
  if ( !v3 )
  {
LABEL_10:
    EndDialog(hDlg, 0);
    return 0;
  }
  v4 = v3 - 256;
  if ( !v4 )
  {
    sub_4A8630(dword_4EF7AC, hDlg);
    return 0;
  }
  if ( v4 == 1 )
  {
    if ( a3 == 1 )
    {
      sub_4A8B40(dword_4EF7AC, hDlg);
      return 0;
    }
    if ( a3 != 2 )
    {
      if ( a3 == 1198 )
      {
        sub_4A8F80(hDlg);
        return 0;
      }
      return 0;
    }
    goto LABEL_10;
  }
  return 0;
}
// 4EF7AC: using guessed type int dword_4EF7AC;

//----- (004A9180) --------------------------------------------------------
int __stdcall sub_4A9180(HWND hDlg, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4EF7AC = a4;
  return sub_4A9100(hDlg, a2, a3);
}
// 4EF7AC: using guessed type int dword_4EF7AC;

//----- (004A91B0) --------------------------------------------------------
INT_PTR __userpurge sub_4A91B0@<eax>(LPARAM a1@<esi>, WPARAM wParam)
{
  INT_PTR result; // eax
  HWND v3; // [esp-Ch] [ebp-28h]
  LPARAM lParam[5]; // [esp+4h] [ebp-18h] BYREF

  result = wParam;
  if ( wParam != -1 )
  {
    result = SendMessageW(*(HWND *)(a1 + 512), 0x417u, wParam, (LPARAM)lParam);
    if ( result )
    {
      v3 = *(HWND *)(a1 + 52);
      *(_DWORD *)(a1 + 60408) = lParam[3];
      return sub_401090((LPCWSTR)0xD8, v3, (DLGPROC)sub_4A9180, a1);
    }
  }
  return result;
}

//----- (004A9210) --------------------------------------------------------
INT_PTR __usercall sub_4A9210@<eax>(LPARAM a1@<eax>)
{
  return sub_401090((LPCWSTR)0xD8, *(HWND *)(a1 + 52), (DLGPROC)sub_4A90D0, a1);
}

//----- (004A9270) --------------------------------------------------------
int __stdcall sub_4A9270(int a1)
{
  (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 16) + 16))(*(_DWORD *)(a1 + 16));
  return 0;
}

//----- (004A9290) --------------------------------------------------------
int __stdcall sub_4A9290(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = 1;
  (*(void (__stdcall **)(_DWORD, int *, int))(**(_DWORD **)(a1 + 16) + 20))(*(_DWORD *)(a1 + 16), &a3, 1);
  return 0;
}

//----- (004A92C0) --------------------------------------------------------
int __stdcall sub_4A92C0(int a1, int *a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // ecx
  int (__stdcall *v7)(int *, __int16 *); // eax
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // edi
  __int16 v12; // [esp+Ch] [ebp-14h] BYREF
  int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]

  v6 = *a2;
  v12 = 15;
  v14 = 1;
  v16 = 1;
  v7 = *(int (__stdcall **)(int *, __int16 *))(v6 + 20);
  v13 = 0;
  v15 = -1;
  v8 = v7(a2, &v12);
  v9 = a6;
  v10 = v8;
  *a6 = v8 == 0;
  (*(void (__stdcall **)(_DWORD, _DWORD, int *, int *, _DWORD))(**(_DWORD **)(a1 + 16) + 12))(
    *(_DWORD *)(a1 + 16),
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 512),
    a2,
    &a4,
    *v9);
  return v10;
}

//----- (004A9340) --------------------------------------------------------
int __stdcall sub_4A9340(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (004A9360) --------------------------------------------------------
int __stdcall sub_4A9360(int a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  return -2147467262;
}

//----- (004A93D0) --------------------------------------------------------
int __stdcall sub_4A93D0(void *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = (*((_DWORD *)a1 + 1))-- == 1;
  result = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    *(_DWORD *)a1 = &Explorerplusplus::CApplicationToolbarDrop::`vftable';
    operator delete(a1);
    return 0;
  }
  return result;
}
// 4CB88C: using guessed type void *Explorerplusplus::CApplicationToolbarDrop::`vftable';

//----- (004A9400) --------------------------------------------------------
int __stdcall sub_4A9400(int a1, int a2, int a3, LONG a4, LONG a5, _DWORD *a6)
{
  _DWORD *v6; // ebx
  int (__stdcall *v7)(int, __int16 *, STGMEDIUM *); // ecx
  int v8; // edi
  HDROP v9; // eax
  HDROP v10; // ebx
  signed int FileW; // esi
  int v12; // ecx
  void *v13; // esi
  UINT v14; // edi
  int v15; // eax
  int v16; // esi
  int v17; // edx
  WCHAR *v18; // eax
  WCHAR v19; // cx
  _DWORD *v20; // eax
  size_t v22; // [esp+8h] [ebp-A64h]
  signed int iFile; // [esp+1Ch] [ebp-A50h]
  UINT iFilea; // [esp+1Ch] [ebp-A50h]
  LRESULT wParam; // [esp+20h] [ebp-A4Ch]
  int v26; // [esp+24h] [ebp-A48h]
  HDROP v27; // [esp+2Ch] [ebp-A40h]
  struct tagPOINT Point; // [esp+30h] [ebp-A3Ch] BYREF
  int v29; // [esp+38h] [ebp-A34h]
  STGMEDIUM v30; // [esp+3Ch] [ebp-A30h] BYREF
  __int16 v31; // [esp+48h] [ebp-A24h] BYREF
  int v32; // [esp+4Ch] [ebp-A20h]
  int v33; // [esp+50h] [ebp-A1Ch]
  int v34; // [esp+54h] [ebp-A18h]
  int v35; // [esp+58h] [ebp-A14h]
  WCHAR szFile[260]; // [esp+5Ch] [ebp-A10h] BYREF
  WCHAR pszPath[512]; // [esp+264h] [ebp-808h] BYREF
  WCHAR psz2[514]; // [esp+664h] [ebp-408h] BYREF

  v6 = a6;
  v7 = *(int (__stdcall **)(int, __int16 *, STGMEDIUM *))(*(_DWORD *)a2 + 12);
  v8 = a1;
  v31 = 15;
  v33 = 1;
  v35 = 1;
  v32 = 0;
  v34 = -1;
  if ( !v7(a2, &v31, &v30) )
  {
    (*(void (__stdcall **)(_DWORD, int, LONG *, _DWORD))(**(_DWORD **)(a1 + 16) + 24))(
      *(_DWORD *)(a1 + 16),
      a2,
      &a4,
      *v6);
    v9 = (HDROP)GlobalLock(v30.hBitmap);
    v10 = v9;
    v27 = v9;
    if ( v9 )
    {
      FileW = DragQueryFileW(v9, 0xFFFFFFFF, 0, 0);
      Point.x = a4;
      v12 = *(_DWORD *)(a1 + 8);
      Point.y = a5;
      v26 = FileW;
      ScreenToClient(*(HWND *)(v12 + 512), &Point);
      wParam = SendMessageW(*(HWND *)(*(_DWORD *)(a1 + 8) + 512), 0x445u, 0, (LPARAM)&Point);
      if ( wParam < 0 )
      {
        iFilea = 0;
        if ( FileW > 0 )
        {
          v16 = (char *)szFile - (char *)pszPath;
          while ( 2 )
          {
            DragQueryFileW(v10, iFilea, szFile, 0x104u);
            v17 = 512;
            v18 = pszPath;
            while ( v17 != -2147483134 )
            {
              v19 = *(WCHAR *)((char *)v18 + v16);
              if ( !v19 )
                break;
              *v18++ = v19;
              if ( !--v17 )
              {
                --v18;
                break;
              }
            }
            *v18 = 0;
            PathStripPathW(pszPath);
            if ( pszPath[0] != 46 )
              PathRemoveExtensionW(pszPath);
            v20 = sub_4A8DD0(*(_DWORD *)(v8 + 8), (int)pszPath, (int)szFile, 1);
            sub_4A87B0(*(_DWORD *)(v8 + 8), (int)v20);
            if ( (int)++iFilea < v26 )
            {
              v10 = v27;
              v16 = (char *)szFile - (char *)pszPath;
              v8 = a1;
              continue;
            }
            break;
          }
        }
      }
      else
      {
        iFile = 1024;
        v13 = malloc(0x800u);
        memset(v13, 0, 0x800u);
        if ( v13 )
        {
          v14 = 0;
          if ( v26 > 0 )
          {
            while ( 1 )
            {
              DragQueryFileW(v10, v14, szFile, 0x104u);
              v29 = lstrlenW((LPCWSTR)v13);
              v15 = lstrlenW(szFile);
              if ( v15 + v29 > iFile )
              {
                v22 = 2 * (iFile + 1024);
                iFile += 1024;
                v13 = realloc(v13, v22);
              }
              sub_401000(0x200u, psz2, L" \"%s\"", szFile);
              StrCatW((PWSTR)v13, psz2);
              if ( (int)++v14 >= v26 )
                break;
              v10 = v27;
            }
          }
          sub_4A8D10(*(_DWORD *)(a1 + 8), (const WCHAR *)v13, wParam);
          free(v13);
        }
      }
      GlobalUnlock(v30.hBitmap);
    }
    ReleaseStgMedium(&v30);
  }
  return 0;
}
// 4A9650: conditional instruction was optimized away because edx.4!=0
// 4CB660: using guessed type wchar_t aS_4[6];

//----- (004A96F0) --------------------------------------------------------
int __usercall sub_4A96F0@<eax>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>)
{
  int result; // eax
  int v5; // edi
  int v6; // ebx
  __int16 v7; // dx

  result = 0;
  if ( a1 )
  {
    v5 = 2147483646;
    v6 = a2 - (_DWORD)a3;
    while ( v5 )
    {
      v7 = *(_WORD *)((char *)a3 + v6);
      if ( !v7 )
        break;
      *a3++ = v7;
      --v5;
      if ( !--a1 )
      {
        result = -2147024774;
        *(a3 - 1) = 0;
        return result;
      }
    }
  }
  else
  {
    --a3;
    result = -2147024774;
  }
  *a3 = 0;
  return result;
}
// 4A972E: conditional instruction was optimized away because esi.4!=0

//----- (004A97C0) --------------------------------------------------------
BOOL __usercall sub_4A97C0@<eax>(HWND a1@<esi>)
{
  HWND v1; // ebx
  BOOL result; // eax
  HWND v3; // [esp+Ch] [ebp-94h]
  HWND v4; // [esp+10h] [ebp-90h]
  HWND v5; // [esp+14h] [ebp-8Ch]
  HWND v6; // [esp+18h] [ebp-88h]
  HWND v7; // [esp+1Ch] [ebp-84h]
  HWND v8; // [esp+20h] [ebp-80h]
  HWND DlgItem; // [esp+24h] [ebp-7Ch]
  HWND hWnd; // [esp+28h] [ebp-78h]
  struct tagRECT v11; // [esp+2Ch] [ebp-74h] BYREF
  struct tagRECT v12; // [esp+3Ch] [ebp-64h] BYREF
  struct tagRECT v13; // [esp+4Ch] [ebp-54h] BYREF
  struct tagRECT v14; // [esp+5Ch] [ebp-44h] BYREF
  struct tagRECT Rect; // [esp+6Ch] [ebp-34h] BYREF
  struct tagRECT rc; // [esp+7Ch] [ebp-24h] BYREF
  struct tagRECT v17; // [esp+8Ch] [ebp-14h] BYREF

  hWnd = GetDlgItem(a1, 1172);
  DlgItem = GetDlgItem(a1, 1);
  v5 = GetDlgItem(a1, 2);
  v8 = GetDlgItem(a1, 1165);
  v6 = GetDlgItem(a1, 1134);
  v3 = GetDlgItem(a1, 1173);
  v4 = GetDlgItem(a1, 1174);
  v1 = GetDlgItem(a1, 1054);
  v7 = GetDlgItem(a1, 1180);
  if ( dword_4EF13C )
  {
    GetWindowRect(v1, &Rect);
    GetWindowRect(hWnd, &v17);
    OffsetRect(&Rect, 0, 6);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&Rect, 2u);
    SetWindowPos(hWnd, 0, v17.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(DlgItem, &v17);
    GetWindowRect(hWnd, &rc);
    OffsetRect(&rc, 0, 6);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&rc, 2u);
    SetWindowPos(DlgItem, 0, v17.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(v5, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v5, 0, v17.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(a1, &v17);
    GetWindowRect(DlgItem, &v14);
    InflateRect(&v14, 0, 10);
    SetWindowPos(a1, 0, 0, 0, v17.right - v17.left, v14.bottom - v17.top, 6u);
    GetWindowRect(v3, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v3, 0, v17.left, v17.top + 45, 0, 0, 5u);
    GetWindowRect(v8, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v8, 0, v17.left, v17.top + 45, 0, 0, 5u);
    GetWindowRect(v4, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v4, 0, v17.left, v17.top + 45, 0, 0, 5u);
    GetWindowRect(v6, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v6, 0, v17.left, v17.top + 45, 0, 0, 5u);
    GetWindowRect(v7, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v7, 0, v17.left, v17.top + 45, 0, 0, 5u);
    result = SetWindowTextW(v1, L"Details >>");
  }
  else
  {
    GetWindowRect(v1, &rc);
    GetWindowRect(v3, &v17);
    OffsetRect(&rc, 0, 5);
    MapWindowPoints(0, a1, (LPPOINT)&rc, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v3, 0, v17.left, rc.bottom + 2, 0, 0, 5u);
    GetWindowRect(v8, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v8, 0, v17.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(v8, &v13);
    GetWindowRect(v6, &v17);
    OffsetRect(&v13, 0, 5);
    MapWindowPoints(0, a1, (LPPOINT)&v13, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v6, 0, v17.left, v13.bottom, 0, 0, 5u);
    GetWindowRect(v4, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v4, 0, v17.left, v13.bottom + 2, 0, 0, 5u);
    GetWindowRect(v6, &v12);
    GetWindowRect(v7, &v17);
    OffsetRect(&v12, 0, 7);
    MapWindowPoints(0, a1, (LPPOINT)&v12, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v7, 0, v17.left, v12.bottom, 0, 0, 5u);
    GetWindowRect(hWnd, &v17);
    GetWindowRect(v7, &v14);
    OffsetRect(&v14, 0, 6);
    MapWindowPoints(0, a1, (LPPOINT)&v14, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(hWnd, 0, v17.left, v14.bottom, 0, 0, 5u);
    GetWindowRect(DlgItem, &v17);
    GetWindowRect(hWnd, &Rect);
    OffsetRect(&Rect, 0, 6);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    MapWindowPoints(0, a1, (LPPOINT)&Rect, 2u);
    SetWindowPos(DlgItem, 0, v17.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(v5, &v17);
    MapWindowPoints(0, a1, (LPPOINT)&v17, 2u);
    SetWindowPos(v5, 0, v17.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(a1, &v17);
    GetWindowRect(DlgItem, &v11);
    InflateRect(&v11, 0, 10);
    SetWindowPos(a1, 0, 0, 0, v17.right - v17.left, v11.bottom - v17.top, 6u);
    result = SetWindowTextW(v1, L"Details <<");
  }
  dword_4EF13C = dword_4EF13C == 0;
  return result;
}
// 4CB66C: using guessed type wchar_t aDetails[11];
// 4EF13C: using guessed type int dword_4EF13C;

//----- (004A9D60) --------------------------------------------------------
BOOL __thiscall sub_4A9D60(HWND hDlg, int a2)
{
  HWND DlgItem; // ebx
  HWND v4; // edi
  int WindowTextLengthW; // esi
  void *v6; // eax
  void (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // esi
  int v8; // ebx
  void *v9; // eax
  HWND v10; // edi
  int v11; // ebx
  HWND v12; // eax
  HWND v13; // ebx
  char *v14; // eax
  int v15; // esi
  int v16; // edx
  __int16 v17; // cx
  _BYTE *v18; // esi
  char *v19; // eax
  int v20; // edx
  int v21; // esi
  __int16 v22; // cx
  WCHAR *v23; // edi
  bool v24; // sf
  int v25; // edx
  char *v26; // eax
  __int16 v27; // cx
  __int16 v28; // cx
  int v29; // esi
  int v30; // esi
  int v31; // eax
  _DWORD *v32; // ecx
  LONG v33; // ecx
  HWND v34; // eax
  HWND v35; // ebx
  LONG top; // ecx
  WPARAM v38; // [esp-8h] [ebp-A94h]
  LPARAM lParam[9]; // [esp+Ch] [ebp-A80h] BYREF
  int v40; // [esp+30h] [ebp-A5Ch]
  void *Block; // [esp+34h] [ebp-A58h]
  void *v42; // [esp+38h] [ebp-A54h]
  HWND v43; // [esp+3Ch] [ebp-A50h]
  HWND hWnd; // [esp+40h] [ebp-A4Ch]
  HWND hDlga; // [esp+44h] [ebp-A48h]
  char v46[512]; // [esp+48h] [ebp-A44h] BYREF
  char v47[1024]; // [esp+248h] [ebp-844h] BYREF
  BOOL v48; // [esp+648h] [ebp-444h]
  int v49; // [esp+64Ch] [ebp-440h]
  char v50[520]; // [esp+650h] [ebp-43Ch] BYREF
  LONG v51; // [esp+858h] [ebp-234h]
  LPARAM v52; // [esp+864h] [ebp-228h] BYREF
  struct tagRECT Rect; // [esp+868h] [ebp-224h] BYREF
  __int16 v54[262]; // [esp+878h] [ebp-214h] BYREF

  v40 = a2;
  hDlga = hDlg;
  DlgItem = GetDlgItem(hDlg, 1113);
  v4 = GetDlgItem(hDlg, 1134);
  hWnd = GetDlgItem(hDlga, 1165);
  v43 = GetDlgItem(hDlga, 1164);
  WindowTextLengthW = GetWindowTextLengthW(DlgItem);
  v6 = malloc(2 * WindowTextLengthW + 2);
  v42 = v6;
  if ( v6 )
  {
    v38 = WindowTextLengthW + 1;
    v7 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
    SendMessageW(DlgItem, 0xDu, v38, (LPARAM)v6);
  }
  else
  {
    v7 = (void (__stdcall *)(HWND, UINT, WPARAM, LPARAM))SendMessageW;
  }
  v8 = GetWindowTextLengthW(v4);
  v9 = malloc(2 * v8 + 2);
  Block = v9;
  if ( v9 )
    v7(v4, 0xDu, v8 + 1, (LPARAM)v9);
  v10 = hWnd;
  v11 = GetWindowTextLengthW(hWnd);
  v12 = (HWND)malloc(2 * v11 + 2);
  hWnd = v12;
  if ( v12 )
    v7(v10, 0xDu, v11 + 1, (LPARAM)v12);
  lParam[1] = ((LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))v7)(v43, 0x147u, 0, 0);
  lParam[0] = 32;
  v7(v43, 0x40Du, 0, (LPARAM)lParam);
  v13 = (HWND)IsDlgButtonChecked(hDlga, 1180);
  v14 = v46;
  v43 = v13;
  v15 = 256;
  v16 = (_BYTE *)v42 - v46;
  while ( v15 != -2147483390 )
  {
    v17 = *(_WORD *)&v14[v16];
    if ( !v17 )
      break;
    *(_WORD *)v14 = v17;
    v14 += 2;
    if ( !--v15 )
    {
      v14 -= 2;
      break;
    }
  }
  v18 = Block;
  *(_WORD *)v14 = 0;
  v19 = v47;
  v20 = 512;
  v21 = v18 - v47;
  while ( v20 != -2147483134 )
  {
    v22 = *(_WORD *)&v19[v21];
    if ( !v22 )
      break;
    *(_WORD *)v19 = v22;
    v19 += 2;
    if ( !--v20 )
    {
      v19 -= 2;
      break;
    }
  }
  v23 = (WCHAR *)hWnd;
  *(_WORD *)v19 = 0;
  v24 = sub_466900(v23, (WCHAR *)v54) < 0;
  v25 = 260;
  v26 = v50;
  if ( v24 )
  {
    while ( v25 != -2147483386 )
    {
      v28 = *(_WORD *)&v26[(char *)v23 - v50];
      if ( !v28 )
        break;
      *(_WORD *)v26 = v28;
      v26 += 2;
      if ( !--v25 )
      {
LABEL_28:
        v26 -= 2;
        break;
      }
    }
  }
  else
  {
    while ( v25 != -2147483386 )
    {
      v27 = *(_WORD *)&v26[(char *)v54 - v50];
      if ( !v27 )
        break;
      *(_WORD *)v26 = v27;
      v26 += 2;
      if ( !--v25 )
        goto LABEL_28;
    }
  }
  v29 = lParam[8];
  *(_WORD *)v26 = 0;
  v49 = 1;
  v48 = v13 == (HWND)1;
  sub_4660F0(v46, v29);
  free(Block);
  free(v42);
  free(v23);
  v30 = v40;
  if ( v43 == (HWND)1 )
  {
    v31 = 0;
    v32 = (_DWORD *)(v40 + 59984);
    while ( *v32 )
    {
      ++v31;
      ++v32;
      if ( v31 >= 100 )
      {
        v33 = -1;
        goto LABEL_34;
      }
    }
    *(_DWORD *)(v40 + 4 * v31 + 59984) = 1;
    v33 = v31 + 46000;
LABEL_34:
    v52 = v49 != 0 ? 20 : 15;
    Rect.right = v51;
    v34 = *(HWND *)(v30 + 504);
    Rect.left = v33;
    LOWORD(Rect.top) = 28676;
    Rect.bottom = (LONG)v46;
    SendMessageW(v34, 0x444u, 1u, (LPARAM)&v52);
    sub_467F60(*(HWND *)(v30 + 60), *(HWND *)(v30 + 504));
  }
  v35 = hDlga;
  GetWindowRect(hDlga, &Rect);
  top = Rect.top;
  *(_DWORD *)(v30 + 61196) = Rect.left;
  *(_DWORD *)(v30 + 61200) = top;
  *(_DWORD *)(v30 + 61192) = 1;
  return EndDialog(v35, 1);
}
// 4A9EE0: conditional instruction was optimized away because esi.4!=0
// 4A9F20: conditional instruction was optimized away because edx.4!=0
// 4A9FA2: conditional instruction was optimized away because edx.4!=0
// 4A9D60: using guessed type WCHAR var_214[262];

//----- (004AA100) --------------------------------------------------------
BOOL __fastcall sub_4AA100(int a1, HWND a2, int a3)
{
  HWND DlgItem; // ebx
  HWND v5; // eax
  const ITEMIDLIST *v6; // edi
  int v7; // eax
  int v8; // edi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  WPARAM v11; // eax
  HWND v13; // [esp+Ch] [ebp-C48h]
  HWND hWnd; // [esp+10h] [ebp-C44h]
  HWND v15; // [esp+14h] [ebp-C40h]
  int v17[518]; // [esp+20h] [ebp-C34h] BYREF
  WCHAR v18[260]; // [esp+838h] [ebp-41Ch] BYREF
  WCHAR String[262]; // [esp+A40h] [ebp-214h] BYREF

  DlgItem = GetDlgItem(a2, 1113);
  v13 = DlgItem;
  hWnd = GetDlgItem(a2, 1165);
  v5 = GetDlgItem(a2, 1164);
  v6 = *(const ITEMIDLIST **)(a1 + 8);
  v15 = v5;
  if ( v6 )
  {
    sub_466630(v6, String, 1);
    SetWindowTextW(DlgItem, String);
    SendMessageW(DlgItem, 0xB1u, 0, -1);
    v7 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a3 + 1320) + 144))(*(_DWORD *)(a3 + 1320));
    sub_466630(*(const ITEMIDLIST **)(a1 + 8), v18, v7 != 0 ? 0 : 0x8000);
    SetWindowTextW(hWnd, v18);
  }
  v8 = sub_4018B0(16, 16, 33, 0, 1u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v8, (int)BitmapW, 0);
  DeleteObject(BitmapW);
  SendMessageW(v15, 0x402u, 0, v8);
  sub_466000(a3 + 1332, v17);
  sub_4A6820((void *)a3, v15, (int)v17, 0, 0);
  if ( *(_DWORD *)(a1 + 4) )
    v11 = sub_4A65C0(v15, *(_DWORD *)(a1 + 4));
  else
    v11 = 0;
  SendMessageW(v15, 0x14Eu, v11, 0);
  dword_4EF13C = *(_DWORD *)(a1 + 12) == 0;
  sub_4A97C0(a2);
  dword_4EF13C = *(_DWORD *)(a1 + 12);
  SetFocus(v13);
  if ( *(_DWORD *)(a3 + 61192) )
    return SetWindowPos(a2, 0, *(_DWORD *)(a3 + 61196), *(_DWORD *)(a3 + 61200), 0, 0, 5u);
  else
    return sub_4697F0(a2, *(HWND *)(a3 + 52));
}
// 4EF13C: using guessed type int dword_4EF13C;

//----- (004AA320) --------------------------------------------------------
INT_PTR __fastcall sub_4AA320(LPARAM dwInitParam, HWND hWndParent)
{
  HWND DlgItem; // esi
  INT_PTR result; // eax
  int v7[519]; // [esp+10h] [ebp-820h] BYREF

  DlgItem = GetDlgItem(hWndParent, 1164);
  dword_4EF138 = SendMessageW(DlgItem, 0x147u, 0, 0);
  result = sub_401090((LPCWSTR)0xD3, hWndParent, sub_4B1510, dwInitParam);
  if ( result == 1 )
  {
    SendMessageW(DlgItem, 0x14Bu, 0, 0);
    sub_466000(dwInitParam + 1332, v7);
    sub_4A6820((void *)dwInitParam, DlgItem, (int)v7, 0, 0);
    return SendMessageW(DlgItem, 0x14Eu, dword_4EF138 + 1, 0);
  }
  return result;
}

//----- (004AA3E0) --------------------------------------------------------
int __thiscall sub_4AA3E0(HWND hWndParent, int a2, __int16 a3, int a4)
{
  _DWORD *v5; // edi
  LONG top; // edx
  struct tagRECT Rect; // [esp+Ch] [ebp-14h] BYREF

  v5 = (_DWORD *)dwInitParam;
  switch ( a2 )
  {
    case 16:
      goto LABEL_8;
    case 272:
      sub_4AA100(a4, hWndParent, dwInitParam);
      return 0;
    case 273:
      if ( (unsigned __int16)a3 > 0x41Eu )
      {
        if ( a3 != 1166 )
          return 0;
        sub_4AA320(dwInitParam, hWndParent);
        return 0;
      }
      else if ( a3 == 1054 )
      {
        sub_4A97C0(hWndParent);
        return 0;
      }
      else
      {
        if ( a3 != 1 )
        {
          if ( a3 == 2 )
          {
LABEL_8:
            GetWindowRect(hWndParent, &Rect);
            top = Rect.top;
            v5[15299] = Rect.left;
            v5[15300] = top;
            v5[15298] = 1;
            EndDialog(hWndParent, 0);
          }
          return 0;
        }
        sub_4A9D60(hWndParent, dwInitParam);
        return 0;
      }
    default:
      return 0;
  }
}

//----- (004AA4F0) --------------------------------------------------------
int __stdcall sub_4AA4F0(HWND hWndParent, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 272 )
    dwInitParam = *(_DWORD *)a4;
  return sub_4AA3E0(hWndParent, a2, a3, a4);
}

//----- (004AA520) --------------------------------------------------------
int __usercall sub_4AA520@<eax>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>)
{
  int result; // eax
  int v5; // edi
  int v6; // ebx
  __int16 v7; // dx

  result = 0;
  if ( a1 )
  {
    v5 = 0x7FFFFFFF;
    v6 = a2 - (_DWORD)a3;
    while ( v5 )
    {
      v7 = *(_WORD *)((char *)a3 + v6);
      if ( !v7 )
        break;
      *a3++ = v7;
      --v5;
      if ( !--a1 )
      {
        result = -2147024774;
        *(a3 - 1) = 0;
        return result;
      }
    }
  }
  else
  {
    --a3;
    result = -2147024774;
  }
  *a3 = 0;
  return result;
}
// 4AA55E: conditional instruction was optimized away because esi.4!=0

//----- (004AA620) --------------------------------------------------------
int __thiscall sub_4AA620(int this)
{
  DestroyIcon(*(HICON *)(this + 48));
  EndDialog(*(HWND *)(this + 4), 0);
  return 0;
}

//----- (004AA640) --------------------------------------------------------
int __thiscall sub_4AA640(HWND *this, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 8);
  if ( (v2 == -4 || v2 == -2) && *(HWND *)a2 == GetDlgItem(this[1], 1269) )
    ShellExecuteW(0, L"open", (LPCWSTR)(a2 + 124), 0, 0, 5);
  return 0;
}

//----- (004AA690) --------------------------------------------------------
int __thiscall sub_4AA690(HWND *this, __int16 a2, int a3)
{
  if ( a2 == 1 )
  {
    EndDialog(this[1], 1);
  }
  else if ( a2 == 2 )
  {
    EndDialog(this[1], 0);
    return 0;
  }
  return 0;
}

//----- (004AA6C0) --------------------------------------------------------
int __usercall sub_4AA6C0@<eax>(unsigned int a1@<edx>, _WORD *a2@<ecx>, _DWORD *a3@<edi>)
{
  int result; // eax
  unsigned int v4; // esi

  result = 0;
  if ( !a1 || a1 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result < 0 )
  {
    *a3 = 0;
  }
  else
  {
    result = 0;
    v4 = a1;
    if ( !a1 )
      goto LABEL_10;
    while ( *a2 )
    {
      ++a2;
      if ( !--v4 )
        goto LABEL_10;
    }
    if ( !v4 )
LABEL_10:
      result = -2147024809;
    if ( a3 )
    {
      if ( result < 0 )
        *a3 = 0;
      else
        *a3 = a1 - v4;
    }
  }
  return result;
}

//----- (004AA720) --------------------------------------------------------
void __usercall sub_4AA720(_DWORD *a1@<eax>)
{
  void *v1; // esi

  v1 = (void *)a1[11];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    sub_4AAAD0((int)v1);
    operator delete(v1);
  }
}
// 4CC394: using guessed type void *CBaseDialog::`vftable';

//----- (004AA740) --------------------------------------------------------
int __usercall sub_4AA740@<eax>(int result@<eax>, int a2@<edx>)
{
  *(_DWORD *)(result + 8) = hInstance;
  *(_DWORD *)(result + 12) = 120;
  *(_DWORD *)(result + 16) = a2;
  *(_BYTE *)(result + 28) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)result = &CAboutDialog::`vftable';
  return result;
}
// 4CB6EC: using guessed type void *CAboutDialog::`vftable';

//----- (004AA770) --------------------------------------------------------
int __thiscall sub_4AA770(int this)
{
  HMODULE ModuleHandleW; // eax
  HANDLE ImageW; // eax
  HMODULE v4; // ebx
  HMODULE v5; // eax
  HBITMAP BitmapW; // eax
  int v7; // ecx
  __int16 *v8; // eax
  int v9; // edx
  __int16 *v10; // eax
  HWND v11; // esi
  HWND Parent; // eax
  WCHAR v14[64]; // [esp+Ch] [ebp-204h] BYREF
  WCHAR v15[64]; // [esp+8Ch] [ebp-184h] BYREF
  __int16 Buffer[64]; // [esp+10Ch] [ebp-104h] BYREF
  WCHAR String[64]; // [esp+18Ch] [ebp-84h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  ImageW = LoadImageW(ModuleHandleW, (LPCWSTR)0x69, 1u, 32, 32, 0x80u);
  *(_DWORD *)(this + 48) = ImageW;
  SendMessageW(*(HWND *)(this + 4), 0x80u, 0, (LPARAM)ImageW);
  v4 = *(HMODULE *)(this + 8);
  if ( v4 != GetModuleHandleW(0) )
  {
    v5 = GetModuleHandleW(0);
    BitmapW = LoadBitmapW(v5, (LPCWSTR)0xE7);
    SendDlgItemMessageW(*(HWND *)(this + 4), 1149, 0x172u, 0, (LPARAM)BitmapW);
  }
  LoadStringW(*(HINSTANCE *)(this + 8), 0x866u, (LPWSTR)Buffer, 64);
  LoadStringW(*(HINSTANCE *)(this + 8), 0x867u, String, 64);
  v7 = 64;
  v8 = Buffer;
  while ( *v8 )
  {
    ++v8;
    if ( !--v7 )
      goto LABEL_8;
  }
  sub_4AA520(v7, (int)L" ", &Buffer[64 - v7]);
LABEL_8:
  v9 = 64;
  v10 = Buffer;
  while ( *v10 )
  {
    ++v10;
    if ( !--v9 )
      goto LABEL_13;
  }
  sub_4AA520(v9, (int)String, &Buffer[64 - v9]);
LABEL_13:
  GetDlgItemTextW(*(HWND *)(this + 4), 1270, String, 64);
  sub_401000(0x40u, v15, String, L"1.3.4.485", Buffer);
  SetDlgItemTextW(*(HWND *)(this + 4), 1270, v15);
  GetDlgItemTextW(*(HWND *)(this + 4), 1271, String, 64);
  sub_401000(0x40u, v14, String, L"12/11/2011 14:55:49");
  SetDlgItemTextW(*(HWND *)(this + 4), 1271, v14);
  v11 = *(HWND *)(this + 4);
  Parent = GetParent(v11);
  sub_4697F0(v11, Parent);
  return 1;
}
// 4AA836: conditional instruction was optimized away because ecx.4!=0
// 4AA872: conditional instruction was optimized away because edx.4!=0
// 4CB69C: using guessed type wchar_t asc_4CB69C[2];
// 4CB6A0: using guessed type wchar_t a134485_0[10];
// 4CB6B4: using guessed type wchar_t a12112011145549[20];
// 4AA770: using guessed type WCHAR Buffer[64];

//----- (004AA960) --------------------------------------------------------
LONG __thiscall sub_4AA960(HWND *this, int a2, int a3)
{
  LONG result; // eax
  _DWORD *v4; // edi
  int v5; // ebx
  HWND DlgItem; // esi
  int v7; // [esp+14h] [ebp-2Ch]
  int v8; // [esp+18h] [ebp-28h]
  int v9; // [esp+20h] [ebp-20h]
  LONG v10; // [esp+24h] [ebp-1Ch]
  HWND *v11; // [esp+28h] [ebp-18h]
  struct tagRECT Rect; // [esp+2Ch] [ebp-14h] BYREF

  result = (LONG)this[1];
  v4 = *(_DWORD **)result;
  v11 = this;
  v10 = result;
  if ( *(_DWORD *)result != result )
  {
    while ( 1 )
    {
      v5 = v4[5];
      v7 = v4[3];
      v8 = v4[4];
      v9 = v4[6];
      DlgItem = GetDlgItem(*this, v4[2]);
      GetWindowRect(DlgItem, &Rect);
      MapWindowPoints(0, *v11, (LPPOINT)&Rect, 2u);
      if ( v7 )
      {
        if ( v7 == 1 )
        {
          if ( v8 )
          {
            if ( v8 == 1 )
            {
              SetWindowPos(DlgItem, 0, 0, 0, a2 - Rect.left - v5, Rect.bottom - Rect.top, 6u);
            }
            else if ( v8 == 2 )
            {
              SetWindowPos(DlgItem, 0, 0, 0, Rect.right - Rect.left, a3 - Rect.top - v9, 6u);
            }
          }
          else
          {
            SetWindowPos(DlgItem, 0, 0, 0, a2 - Rect.left - v5, a3 - Rect.top - v9, 6u);
          }
        }
      }
      else if ( v8 )
      {
        if ( v8 == 1 )
        {
          SetWindowPos(DlgItem, 0, a2 - v5, Rect.top, 0, 0, 5u);
        }
        else if ( v8 == 2 )
        {
          SetWindowPos(DlgItem, 0, Rect.left, a3 - v9, 0, 0, 5u);
        }
      }
      else
      {
        SetWindowPos(DlgItem, 0, a2 - v5, a3 - v9, 0, 0, 5u);
      }
      result = GetWindowLongW(DlgItem, -16);
      if ( (result & 7) != 0 )
        result = InvalidateRect(DlgItem, 0, 1);
      v4 = (_DWORD *)*v4;
      if ( v4 == (_DWORD *)v10 )
        break;
      this = v11;
    }
  }
  return result;
}

//----- (004AAAD0) --------------------------------------------------------
void __usercall sub_4AAAD0(int a1@<esi>)
{
  _DWORD **v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // edi

  v1 = *(_DWORD ***)(a1 + 4);
  v2 = *v1;
  *v1 = v1;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 8) = 0;
  if ( v2 != *(_DWORD **)(a1 + 4) )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 4) );
  }
  operator delete(*(void **)(a1 + 4));
}

//----- (004AAB10) --------------------------------------------------------
int __usercall sub_4AAB10@<eax>(HWND hWnd@<ecx>, int ***a2@<edx>, int a3@<edi>)
{
  _DWORD *v5; // eax
  int **v6; // eax
  int *v7; // ebx
  char *v8; // eax
  char *v9; // esi
  HWND DlgItem; // eax
  char **v11; // eax
  int v12; // ecx
  HWND v14; // [esp-8h] [ebp-78h]
  int v15; // [esp-4h] [ebp-74h]
  int pExceptionObject[4]; // [esp+10h] [ebp-60h] BYREF
  char *v17[3]; // [esp+20h] [ebp-50h] BYREF
  int v18; // [esp+2Ch] [ebp-44h]
  int v19; // [esp+30h] [ebp-40h]
  char *v20; // [esp+34h] [ebp-3Ch]
  int *v21; // [esp+38h] [ebp-38h]
  char *v22; // [esp+3Ch] [ebp-34h] BYREF
  struct tagRECT Rect; // [esp+40h] [ebp-30h] BYREF
  struct tagRECT v24; // [esp+50h] [ebp-20h] BYREF
  int v25; // [esp+6Ch] [ebp-4h]

  pExceptionObject[3] = a3;
  *(_DWORD *)(a3 + 8) = 0;
  v5 = operator new(0x1Cu);
  if ( !v5 )
  {
    v22 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v22);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a3 + 4) = v5;
  *v5 = v5;
  *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4) = *(_DWORD *)(a3 + 4);
  v25 = 0;
  *(_DWORD *)a3 = hWnd;
  GetClientRect(hWnd, &Rect);
  v6 = *a2;
  v7 = **a2;
  v21 = (int *)v6;
  if ( v7 != (int *)v6 )
  {
    do
    {
      v8 = (char *)v7[2];
      v9 = (char *)v7[3];
      v17[2] = (char *)v7[4];
      v14 = *(HWND *)a3;
      v17[0] = v8;
      v17[1] = v9;
      DlgItem = GetDlgItem(v14, (int)v8);
      GetWindowRect(DlgItem, &v24);
      MapWindowPoints(0, *(HWND *)a3, (LPPOINT)&v24, 2u);
      if ( v9 )
      {
        if ( v9 == (char *)1 )
        {
          v18 = Rect.right - v24.right;
          v19 = Rect.bottom - v24.bottom;
        }
      }
      else
      {
        v18 = Rect.right - v24.left;
        v19 = Rect.bottom - v24.top;
      }
      v15 = *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4);
      v20 = *(char **)(a3 + 4);
      v11 = sub_416060(v17, v20, v15);
      v12 = *(_DWORD *)(a3 + 8);
      if ( v12 == 214748363 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a3 + 8) = v12 + 1;
      *((_DWORD *)v20 + 1) = v11;
      *(_DWORD *)v11[1] = v11;
      v7 = (int *)*v7;
    }
    while ( v7 != v21 );
  }
  return a3;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004AAC80) --------------------------------------------------------
BOOL __usercall sub_4AAC80@<eax>(int a1@<eax>)
{
  int v2; // ecx
  int v3; // ecx
  signed int v4; // edi
  signed int v5; // edi
  HMENU v6; // edx
  int v7; // eax
  HMENU v8; // edx
  int v9; // eax
  int v10; // esi
  UINT v11; // esi
  HMENU v13; // [esp-Ch] [ebp-30h]
  HMENU v14; // [esp-Ch] [ebp-30h]
  HMENU v15; // [esp+Ch] [ebp-18h]
  HMENU v16; // [esp+Ch] [ebp-18h]
  UINT first; // [esp+10h] [ebp-14h]
  int v18; // [esp+14h] [ebp-10h] BYREF
  HMENU hmenu; // [esp+18h] [ebp-Ch]
  UINT last; // [esp+1Ch] [ebp-8h]
  UINT check; // [esp+20h] [ebp-4h]

  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 144))(*(_DWORD *)(a1 + 1320));
  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v2 + 28))(v2, &v18);
  v3 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516);
  v15 = (HMENU)(*(int (__thiscall **)(int))(*(_DWORD *)v3 + 36))(v3);
  v4 = 0;
  check = GetMenuItemCount(*(HMENU *)(a1 + 3448));
  if ( (int)check > 0 )
  {
    do
    {
      CheckMenuItem(*(HMENU *)(a1 + 3448), v4, 0x400u);
      CheckMenuItem(*(HMENU *)(a1 + 3456), v4++, 0x400u);
    }
    while ( v4 < (int)check );
  }
  v5 = 0;
  check = GetMenuItemCount(*(HMENU *)(a1 + 3452));
  if ( (int)check > 0 )
  {
    do
    {
      CheckMenuItem(*(HMENU *)(a1 + 3452), v5, 0x400u);
      CheckMenuItem(*(HMENU *)(a1 + 3460), v5++, 0x400u);
    }
    while ( v5 < (int)check );
  }
  if ( v15 )
  {
    v6 = *(HMENU *)(a1 + 3460);
    hmenu = *(HMENU *)(a1 + 3452);
    v16 = v6;
    if ( (unsigned int)(v18 - 1) > 0x27 )
      v7 = -1;
    else
      v7 = sub_4A7640(v18 - 1);
    check = v7;
    if ( v7 == -1 )
      check = 50100;
    v13 = *(HMENU *)(a1 + 3448);
    first = 50100;
    last = 50199;
    EnableMenuItem(v13, 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3448), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3456), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3456), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3452), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3452), 0x9C9Au, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3460), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3460), 0x9C9Au, 0);
    CheckMenuRadioItem(*(HMENU *)(a1 + 3448), 0xC350u, 0xC3B3u, 0, 0);
    CheckMenuRadioItem(*(HMENU *)(a1 + 3456), 0xC350u, 0xC3B3u, 0, 0);
  }
  else
  {
    v8 = *(HMENU *)(a1 + 3456);
    hmenu = *(HMENU *)(a1 + 3448);
    v16 = v8;
    if ( (unsigned int)(v18 - 1) > 0x27 )
      v9 = -1;
    else
      v9 = sub_4A77E0(v18 - 1);
    check = v9;
    if ( v9 == -1 )
      check = 50000;
    v14 = *(HMENU *)(a1 + 3452);
    first = 50000;
    last = 50099;
    EnableMenuItem(v14, 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3452), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3460), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3460), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 3448), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3448), 0x9C9Au, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3456), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 3456), 0x9C9Au, 0);
  }
  CheckMenuRadioItem(hmenu, first, last, check, 0);
  CheckMenuRadioItem(v16, first, last, check, 0);
  v10 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516);
  v11 = 40090 - ((*(int (__thiscall **)(int))(*(_DWORD *)v10 + 40))(v10) != 0);
  CheckMenuRadioItem(hmenu, 0x9C99u, 0x9C9Au, v11, 0);
  return CheckMenuRadioItem(v16, 0x9C99u, 0x9C9Au, v11, 0);
}

//----- (004AAFA0) --------------------------------------------------------
void __thiscall sub_4AAFA0(_DWORD **this)
{
  _DWORD **v1; // esi
  ITEMIDLIST *v2; // ebx
  __int16 *v3; // eax
  int v4; // edx
  __int16 v5; // cx
  WCHAR String[260]; // [esp+10h] [ebp-418h] BYREF
  __int16 v8[262]; // [esp+218h] [ebp-210h] BYREF

  v1 = this;
  v2 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD *))(*this[330] + 56))(this[330]);
  sub_466630(v2, String, 0x8000);
  if ( lstrlenW(String) > 2 && String[0] == 58 && String[1] == 58 )
  {
    sub_466630(v2, (WCHAR *)v8, 1);
  }
  else
  {
    v3 = v8;
    v4 = 260;
    while ( v4 != -2147483386 )
    {
      v5 = *(__int16 *)((char *)v3 + (char *)String - (char *)v8);
      if ( !v5 )
        break;
      *v3++ = v5;
      if ( !--v4 )
      {
        --v3;
        break;
      }
    }
    v1 = this;
    *v3 = 0;
  }
  sub_494810((LPARAM)v8, (HWND)v1[21], &v2->mkid.cb);
  CoTaskMemFree(v2);
}
// 4AB051: conditional instruction was optimized away because edx.4!=0
// 4AAFA0: using guessed type WCHAR var_210[262];

//----- (004AB090) --------------------------------------------------------
void __thiscall sub_4AB090(int this, WPARAM wParam, int a3)
{
  bool v4; // zf
  char *v5; // eax
  int v6; // edi
  int v7; // edx
  __int16 v8; // cx
  _DWORD *v9; // eax
  _DWORD *v10; // ebx
  HWND v11; // [esp-10h] [ebp-458h]
  LPARAM lParam[7]; // [esp+Ch] [ebp-43Ch] BYREF
  int v13; // [esp+28h] [ebp-420h]
  LPVOID pv; // [esp+2Ch] [ebp-41Ch]
  __int16 v15[260]; // [esp+30h] [ebp-418h] BYREF
  WCHAR String[262]; // [esp+238h] [ebp-210h] BYREF

  v4 = *(_DWORD *)(532 * a3 + this + 5680) == 0;
  v13 = a3;
  if ( v4 )
  {
    pv = (LPVOID)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 4 * a3 + 916) + 56))(*(_DWORD *)(this + 4 * a3 + 916));
    sub_466630((const ITEMIDLIST *)pv, (WCHAR *)v15, 1);
    v5 = (char *)(532 * a3 + this + 5684);
    v6 = 260;
    v7 = (char *)v15 - v5;
    while ( v6 != -2147483386 )
    {
      v8 = *(_WORD *)&v5[v7];
      if ( !v8 )
        break;
      *(_WORD *)v5 = v8;
      v5 += 2;
      if ( !--v6 )
      {
        v5 -= 2;
        break;
      }
    }
    *(_WORD *)v5 = 0;
    sub_46AE30((int)L"&&", (const WCHAR *)v15, String);
    lParam[3] = (LPARAM)String;
    v11 = *(HWND *)(this + 68);
    lParam[0] = 1;
    SendMessageW(v11, 0x133Du, wParam, (LPARAM)lParam);
    if ( *(_DWORD *)(this + 59544) )
    {
      v9 = *(_DWORD **)(this + 59528);
      v10 = (_DWORD *)*v9;
      if ( (_DWORD *)*v9 != v9 )
      {
        while ( v10[4] != v13 )
        {
          v10 = (_DWORD *)*v10;
          if ( v10 == v9 )
            goto LABEL_13;
        }
        SetWindowTextW((HWND)v10[3], String);
        (*(void (__stdcall **)(_DWORD, _DWORD, WCHAR *))(**(_DWORD **)(this + 59524) + 76))(
          *(_DWORD *)(this + 59524),
          v10[3],
          String);
      }
    }
LABEL_13:
    CoTaskMemFree(pv);
  }
}
// 4AB122: conditional instruction was optimized away because edi.4!=0
// 4CB1B0: using guessed type wchar_t asc_4CB1B0[3];
// 4AB090: using guessed type WCHAR var_418[260];

//----- (004AB1F0) --------------------------------------------------------
void __thiscall sub_4AB1F0(int this, int a2)
{
  WPARAM v3; // edi
  HWND v4; // edx
  bool v5; // zf
  ITEMIDLIST *v6; // edi
  _WORD *v7; // eax
  int v8; // ebx
  char *v9; // edx
  __int16 v10; // cx
  HWND v11; // ecx
  _DWORD *v12; // eax
  _DWORD *v13; // ebx
  LPARAM v14[7]; // [esp+10h] [ebp-45Ch] BYREF
  LPARAM lParam[7]; // [esp+2Ch] [ebp-440h] BYREF
  WPARAM wParam; // [esp+48h] [ebp-424h]
  LRESULT v17; // [esp+4Ch] [ebp-420h]
  __int16 v18[260]; // [esp+50h] [ebp-41Ch] BYREF
  WCHAR String[262]; // [esp+258h] [ebp-214h] BYREF

  v3 = 0;
  v17 = SendMessageW(*(HWND *)(this + 68), 0x1304u, 0, 0);
  if ( v17 > 0 )
  {
    while ( 1 )
    {
      v4 = *(HWND *)(this + 68);
      lParam[0] = 8;
      SendMessageW(v4, 0x133Cu, v3, (LPARAM)lParam);
      if ( lParam[6] == a2 )
        break;
      if ( (int)++v3 >= v17 )
        return;
    }
    v5 = *(_DWORD *)(this + 532 * a2 + 5680) == 0;
    wParam = v3;
    v17 = this + 532 * a2;
    if ( v5 )
    {
      v6 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 4 * a2 + 916) + 56))(*(_DWORD *)(this + 4 * a2 + 916));
      sub_466630(v6, (WCHAR *)v18, 1);
      v7 = (_WORD *)(v17 + 5684);
      v8 = 260;
      v9 = (char *)&v18[-2842] - v17;
      while ( v8 != -2147483386 )
      {
        v10 = *(_WORD *)((char *)v7 + (_DWORD)v9);
        if ( !v10 )
          break;
        *v7++ = v10;
        if ( !--v8 )
        {
          --v7;
          break;
        }
      }
      *v7 = 0;
      sub_46AE30((int)L"&&", (const WCHAR *)v18, String);
      v14[3] = (LPARAM)String;
      v11 = *(HWND *)(this + 68);
      v14[0] = 1;
      SendMessageW(v11, 0x133Du, wParam, (LPARAM)v14);
      if ( *(_DWORD *)(this + 59544) )
      {
        v12 = *(_DWORD **)(this + 59528);
        v13 = (_DWORD *)*v12;
        if ( (_DWORD *)*v12 != v12 )
        {
          while ( v13[4] != a2 )
          {
            v13 = (_DWORD *)*v13;
            if ( v13 == v12 )
              goto LABEL_17;
          }
          SetWindowTextW((HWND)v13[3], String);
          (*(void (__stdcall **)(_DWORD, _DWORD, WCHAR *))(**(_DWORD **)(this + 59524) + 76))(
            *(_DWORD *)(this + 59524),
            v13[3],
            String);
        }
      }
LABEL_17:
      CoTaskMemFree(v6);
    }
  }
}
// 4AB2F0: conditional instruction was optimized away because ebx.4!=0
// 4CB1B0: using guessed type wchar_t asc_4CB1B0[3];
// 4AB1F0: using guessed type WCHAR var_41C[260];

//----- (004AB3E0) --------------------------------------------------------
BOOL __thiscall sub_4AB3E0(int this)
{
  int v1; // esi
  int v2; // edx
  __int16 *v3; // eax
  int v4; // edx
  __int16 *v5; // eax
  int v6; // edx
  __int16 *v7; // eax
  int v8; // edx
  __int16 *i; // eax
  BOOL IsMember; // [esp+10h] [ebp-AA0h] BYREF
  LPVOID pv; // [esp+14h] [ebp-A9Ch] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+18h] [ebp-A98h] BYREF
  __int16 v15[512]; // [esp+20h] [ebp-A90h] BYREF
  __int16 v16[260]; // [esp+420h] [ebp-690h] BYREF
  __int16 String[512]; // [esp+628h] [ebp-488h] BYREF
  __int16 v18[32]; // [esp+A28h] [ebp-88h] BYREF
  __int16 v19[34]; // [esp+A68h] [ebp-48h] BYREF

  v1 = this;
  if ( !*(_DWORD *)(this + 59324)
    || (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 1320) + 144))(*(_DWORD *)(this + 1320)) )
  {
    if ( v1 != -3492 )
    {
      pv = 0;
      if ( sub_467810((LPITEMIDLIST *)&pv, v1 + 3492) >= 0 )
        sub_466630((const ITEMIDLIST *)pv, (WCHAR *)v16, 0);
      goto LABEL_10;
    }
  }
  else if ( v1 != -3492 )
  {
    pv = 0;
    if ( sub_467810((LPITEMIDLIST *)&pv, v1 + 3492) >= 0 )
      sub_466630((const ITEMIDLIST *)pv, (WCHAR *)v16, 0x8000);
LABEL_10:
    CoTaskMemFree(pv);
  }
  sub_401000(0x200u, (wchar_t *)String, L"%s - Explorer++", v16);
  if ( *(_DWORD *)(v1 + 59372) || *(_DWORD *)(v1 + 59376) )
  {
    v2 = 512;
    v3 = String;
    while ( *v3 )
    {
      ++v3;
      if ( !--v2 )
        goto LABEL_18;
    }
    sub_4AA520(v2, (int)L" [", &String[512 - v2]);
  }
LABEL_18:
  if ( *(_DWORD *)(v1 + 59372) )
  {
    sub_46A360((wchar_t *)v15);
    v4 = 512;
    v5 = String;
    while ( *v5 )
    {
      ++v5;
      if ( !--v4 )
        goto LABEL_24;
    }
    sub_4AA520(v4, (int)v15, &String[512 - v4]);
  }
LABEL_24:
  if ( *(_DWORD *)(v1 + 59376) )
  {
    *(_DWORD *)pIdentifierAuthority.Value = 0;
    *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
    IsMember = 0;
    if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &pv) )
    {
      CheckTokenMembership(0, pv, &IsMember);
      FreeSid(pv);
    }
    if ( IsMember )
    {
      sub_401000(0x20u, (wchar_t *)v19, L"Administrators");
    }
    else
    {
      *(_DWORD *)pIdentifierAuthority.Value = 0;
      *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
      pv = 0;
      if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x223u, 0, 0, 0, 0, 0, 0, (PSID *)&IsMember) )
      {
        CheckTokenMembership(0, (PSID)IsMember, (PBOOL)&pv);
        FreeSid((PSID)IsMember);
      }
      if ( pv )
      {
        sub_401000(0x20u, (wchar_t *)v19, L"Power Users");
      }
      else
      {
        *(_DWORD *)pIdentifierAuthority.Value = 0;
        *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
        pv = 0;
        if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x221u, 0, 0, 0, 0, 0, 0, (PSID *)&IsMember) )
        {
          CheckTokenMembership(0, (PSID)IsMember, (PBOOL)&pv);
          FreeSid((PSID)IsMember);
        }
        if ( pv )
        {
          sub_401000(0x20u, (wchar_t *)v19, L"Users");
        }
        else
        {
          *(_DWORD *)pIdentifierAuthority.Value = 0;
          *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
          pv = 0;
          if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x222u, 0, 0, 0, 0, 0, 0, (PSID *)&IsMember) )
          {
            CheckTokenMembership(0, (PSID)IsMember, (PBOOL)&pv);
            FreeSid((PSID)IsMember);
          }
          if ( pv )
            sub_401000(0x20u, (wchar_t *)v19, L"Users/Restricted");
        }
      }
    }
    if ( *(_DWORD *)(this + 59372) )
      sub_401000(0x20u, (wchar_t *)v18, L" - %s", v19);
    else
      sub_401000(0x20u, (wchar_t *)v18, L"%s", v19);
    v6 = 512;
    v7 = String;
    while ( *v7 )
    {
      ++v7;
      if ( !--v6 )
        goto LABEL_49;
    }
    sub_4AA520(v6, (int)v18, &String[512 - v6]);
LABEL_49:
    v1 = this;
  }
  if ( *(_DWORD *)(v1 + 59372) || *(_DWORD *)(v1 + 59376) )
  {
    v8 = 512;
    for ( i = String; *i; ++i )
    {
      if ( !--v8 )
        return SetWindowTextW(*(HWND *)(v1 + 52), (LPCWSTR)String);
    }
    sub_4AA520(v8, (int)L"]", &String[512 - v8]);
  }
  return SetWindowTextW(*(HWND *)(v1 + 52), (LPCWSTR)String);
}
// 4AB4EF: conditional instruction was optimized away because edx.4!=0
// 4AB53F: conditional instruction was optimized away because edx.4!=0
// 4AB773: conditional instruction was optimized away because edx.4!=0
// 4AB7C7: conditional instruction was optimized away because edx.4!=0
// 4CB108: using guessed type wchar_t aSExplorer[16];
// 4CB128: using guessed type wchar_t asc_4CB128[3];
// 4CB130: using guessed type wchar_t aAdministrators[15];
// 4CB150: using guessed type wchar_t aPowerUsers[12];
// 4CB168: using guessed type wchar_t aUsers[6];
// 4CB174: using guessed type wchar_t aUsersRestricte[17];
// 4CB198: using guessed type wchar_t aS_5[6];
// 4CB1A4: using guessed type wchar_t aS_6[3];
// 4CB1AC: using guessed type wchar_t asc_4CB1AC[2];
// 4AB3E0: using guessed type WCHAR var_690[260];
// 4AB3E0: using guessed type wchar_t String[512];
// 4AB3E0: using guessed type wchar_t var_A90[512];
// 4AB3E0: using guessed type wchar_t var_48[34];
// 4AB3E0: using guessed type wchar_t var_88[32];

//----- (004AB810) --------------------------------------------------------
BOOL __userpurge sub_4AB810@<eax>(HMENU a1@<esi>, int a2)
{
  int v2; // ecx
  HWND Focus; // eax
  HWND v4; // ecx
  HWND v5; // eax
  HWND v6; // ecx
  HWND v7; // eax
  HWND v8; // ecx
  HWND v9; // ecx
  HWND v10; // ecx
  HWND v11; // ecx
  HWND v12; // eax
  HRESULT v13; // eax
  HWND v14; // eax
  HRESULT v15; // eax
  HWND v16; // eax
  HRESULT v17; // eax
  HWND v18; // eax
  HRESULT v19; // eax
  UINT v20; // eax
  UINT v22; // [esp-4h] [ebp-18h]
  BOOL v23; // [esp-4h] [ebp-18h]
  BOOL v24; // [esp-4h] [ebp-18h]
  BOOL v25; // [esp-4h] [ebp-18h]
  BOOL v26; // [esp-4h] [ebp-18h]
  BOOL v27; // [esp-4h] [ebp-18h]
  BOOL v28; // [esp-4h] [ebp-18h]
  BOOL v29; // [esp-4h] [ebp-18h]
  BOOL v30; // [esp-4h] [ebp-18h]
  BOOL v31; // [esp-4h] [ebp-18h]
  int v32; // [esp+8h] [ebp-Ch]
  int v33; // [esp+Ch] [ebp-8h] BYREF
  int v34; // [esp+10h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 4 * *(_DWORD *)(a2 + 5620) + 516);
  (*(void (__thiscall **)(int, int *))(*(_DWORD *)v2 + 24))(v2, &v34);
  v32 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 144))(*(_DWORD *)(a2 + 1320));
  Focus = GetFocus();
  v4 = *(HWND *)(a2 + 3432);
  if ( Focus == v4 )
  {
    if ( !SendMessageW(v4, 0x1032u, 0, 0) )
    {
LABEL_3:
      v22 = 1;
      goto LABEL_4;
    }
  }
  else
  {
    v9 = *(HWND *)(a2 + 76);
    if ( Focus != v9 || !SendMessageW(v9, 0x110Au, 9u, 0) )
      goto LABEL_3;
  }
  v22 = 0;
LABEL_4:
  EnableMenuItem(a1, 0x9C7Du, v22);
  v5 = GetFocus();
  v6 = *(HWND *)(a2 + 3432);
  if ( v5 == v6 )
  {
    if ( !SendMessageW(v6, 0x1032u, 0, 0) )
    {
LABEL_6:
      EnableMenuItem(a1, 0x9DD3u, 1u);
      goto LABEL_7;
    }
  }
  else
  {
    v10 = *(HWND *)(a2 + 76);
    if ( v5 != v10 || !SendMessageW(v10, 0x110Au, 9u, 0) )
      goto LABEL_6;
  }
  EnableMenuItem(a1, 0x9DD3u, 0);
LABEL_7:
  v7 = GetFocus();
  v8 = *(HWND *)(a2 + 3432);
  if ( v7 == v8 )
  {
    if ( !SendMessageW(v8, 0x1032u, 0, 0) )
    {
LABEL_9:
      EnableMenuItem(a1, 0x9CE8u, 1u);
      goto LABEL_10;
    }
  }
  else
  {
    v11 = *(HWND *)(a2 + 76);
    if ( v7 != v11 || !SendMessageW(v11, 0x110Au, 9u, 0) )
      goto LABEL_9;
  }
  EnableMenuItem(a1, 0x9CE8u, 0);
LABEL_10:
  if ( v32 )
  {
    EnableMenuItem(a1, 0x9C7Bu, 1u);
    EnableMenuItem(a1, 0x1F42u, 1u);
  }
  else
  {
    EnableMenuItem(a1, 0x9C7Bu, 0);
    EnableMenuItem(a1, 0x1F42u, 0);
  }
  if ( *(_DWORD *)(a2 + 60572) && v34 == 4 )
    EnableMenuItem(a1, 0x9D2Du, 0);
  else
    EnableMenuItem(a1, 0x9D2Du, 1u);
  v33 = 16;
  v12 = GetFocus();
  if ( v12 == *(HWND *)(a2 + 3432) )
  {
    v13 = sub_494780(a2, (int)&v33);
  }
  else
  {
    if ( v12 != *(HWND *)(a2 + 76) )
      goto LABEL_33;
    v13 = sub_4946F0(a2, (int)&v33);
  }
  if ( v13 >= 0 && (v33 & 0x10) == 16 )
  {
    EnableMenuItem(a1, 0x9C80u, 0);
    goto LABEL_34;
  }
LABEL_33:
  EnableMenuItem(a1, 0x9C80u, 1u);
LABEL_34:
  v33 = 32;
  v14 = GetFocus();
  if ( v14 == *(HWND *)(a2 + 3432) )
  {
    v15 = sub_494780(a2, (int)&v33);
  }
  else
  {
    if ( v14 != *(HWND *)(a2 + 76) )
      goto LABEL_41;
    v15 = sub_4946F0(a2, (int)&v33);
  }
  if ( v15 >= 0 && (v33 & 0x20) == 32 )
  {
    EnableMenuItem(a1, 0x9C7Fu, 0);
    goto LABEL_42;
  }
LABEL_41:
  EnableMenuItem(a1, 0x9C7Fu, 1u);
LABEL_42:
  v33 = 32;
  v16 = GetFocus();
  if ( v16 == *(HWND *)(a2 + 3432) )
  {
    v17 = sub_494780(a2, (int)&v33);
  }
  else
  {
    if ( v16 != *(HWND *)(a2 + 76) )
      goto LABEL_49;
    v17 = sub_4946F0(a2, (int)&v33);
  }
  if ( v17 >= 0 && (v33 & 0x20) == 32 )
  {
    EnableMenuItem(a1, 0x9CD1u, 0);
    goto LABEL_50;
  }
LABEL_49:
  EnableMenuItem(a1, 0x9CD1u, 1u);
LABEL_50:
  v33 = 64;
  v18 = GetFocus();
  if ( v18 == *(HWND *)(a2 + 3432) )
  {
    v19 = sub_494780(a2, (int)&v33);
  }
  else
  {
    if ( v18 != *(HWND *)(a2 + 76) )
    {
LABEL_57:
      EnableMenuItem(a1, 0x9C81u, 1u);
      goto LABEL_58;
    }
    v19 = sub_4946F0(a2, (int)&v33);
  }
  if ( v19 < 0 || (v33 & 0x40) != 64 )
    goto LABEL_57;
  EnableMenuItem(a1, 0x9C81u, 0);
LABEL_58:
  EnableMenuItem(a1, 0x9D85u, *(_DWORD *)(a2 + 59568) == 0);
  v23 = sub_494FD0(a2) == 0;
  EnableMenuItem(a1, 0x9C86u, v23);
  v24 = sub_494FD0(a2) == 0;
  EnableMenuItem(a1, 0x9C87u, v24);
  v25 = sub_494FD0(a2) == 0;
  EnableMenuItem(a1, 0x9CFDu, v25);
  v26 = sub_494670((_DWORD *)a2) == 0;
  EnableMenuItem(a1, 0x9C85u, v26);
  v27 = sub_494670((_DWORD *)a2) == 0;
  EnableMenuItem(a1, 0x9C83u, v27);
  if ( !sub_494670((_DWORD *)a2) || GetFocus() == *(HWND *)(a2 + 76) )
    EnableMenuItem(a1, 0x9C88u, 1u);
  else
    EnableMenuItem(a1, 0x9C88u, 0);
  if ( !sub_494670((_DWORD *)a2) || GetFocus() == *(HWND *)(a2 + 76) )
    EnableMenuItem(a1, 0x9C89u, 1u);
  else
    EnableMenuItem(a1, 0x9C89u, 0);
  EnableMenuItem(a1, 0x9D0Cu, *(_DWORD *)(a2 + 60572) == 0);
  EnableMenuItem(a1, 0x9C8Cu, *(_DWORD *)(a2 + 60572) == 0);
  EnableMenuItem(a1, 0x9CEAu, *(_DWORD *)(a2 + 60572) == 0);
  EnableMenuItem(a1, 0x9CECu, *(_DWORD *)(a2 + 60572) == 0);
  if ( *(_DWORD *)(a2 + 59284) )
    CheckMenuItem(a1, 0x9C8Du, 8u);
  else
    CheckMenuItem(a1, 0x9C8Du, 0);
  if ( *(_DWORD *)(a2 + 59288) )
    CheckMenuItem(a1, 0x9C8Eu, 8u);
  else
    CheckMenuItem(a1, 0x9C8Eu, 0);
  if ( *(_DWORD *)(a2 + 59296) )
    CheckMenuItem(a1, 0x9D07u, 8u);
  else
    CheckMenuItem(a1, 0x9D07u, 0);
  if ( *(_DWORD *)(a2 + 59292) )
    CheckMenuItem(a1, 0x9D5Au, 8u);
  else
    CheckMenuItem(a1, 0x9D5Au, 0);
  if ( *(_DWORD *)(a2 + 59300) )
    CheckMenuItem(a1, 0x9D63u, 8u);
  else
    CheckMenuItem(a1, 0x9D63u, 0);
  if ( *(_DWORD *)(a2 + 59304) )
    CheckMenuItem(a1, 0x9D64u, 8u);
  else
    CheckMenuItem(a1, 0x9D64u, 0);
  if ( *(_DWORD *)(a2 + 59308) )
    CheckMenuItem(a1, 0x9D8Bu, 8u);
  else
    CheckMenuItem(a1, 0x9D8Bu, 0);
  if ( *(_DWORD *)(a2 + 59312) )
    CheckMenuItem(a1, 0x9D9Du, 8u);
  else
    CheckMenuItem(a1, 0x9D9Du, 0);
  if ( *(_DWORD *)(a2 + 59360) )
    CheckMenuItem(a1, 0x9D98u, 8u);
  else
    CheckMenuItem(a1, 0x9D98u, 0);
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 248))(*(_DWORD *)(a2 + 1320)) )
    CheckMenuItem(a1, 0x9CA8u, 8u);
  else
    CheckMenuItem(a1, 0x9CA8u, 0);
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 216))(*(_DWORD *)(a2 + 1320)) )
    CheckMenuItem(a1, 0x9D25u, 8u);
  else
    CheckMenuItem(a1, 0x9D25u, 0);
  EnableMenuItem(a1, 0x9D47u, v32 != 0);
  if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 196))(*(_DWORD *)(a2 + 1320)) != 1 || v32 )
    EnableMenuItem(a1, 0x9D41u, 1u);
  else
    EnableMenuItem(a1, 0x9D41u, 0);
  EnableMenuItem(a1, 0x9D44u, *(_DWORD *)(a2 + 60572) <= 1);
  EnableMenuItem(a1, 0x9D45u, *(_DWORD *)(a2 + 60572) == 0);
  GetWindowLongW(*(HWND *)(a2 + 3432), -16);
  switch ( v34 )
  {
    case 1:
      v20 = 60002;
      break;
    case 2:
      v20 = 60003;
      break;
    case 3:
      v20 = 60004;
      break;
    case 4:
      v20 = 60005;
      break;
    case 5:
      v20 = 60001;
      break;
    case 6:
      v20 = 60000;
      break;
    case 7:
      v20 = 60008;
      break;
    case 8:
      v20 = 60007;
      break;
    default:
      v20 = -1;
      break;
  }
  CheckMenuRadioItem(a1, 0xEA60u, 0xEA68u, v20, 0);
  v28 = SendMessageW(*(HWND *)(a2 + 68), 0x1304u, 0, 0) == 0;
  EnableMenuItem(a1, 0x9C79u, v28);
  v29 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 68))(*(_DWORD *)(a2 + 1320)) == 0;
  EnableMenuItem(a1, 0x9C9Du, v29);
  v30 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 72))(*(_DWORD *)(a2 + 1320)) == 0;
  EnableMenuItem(a1, 0x9C9Eu, v30);
  v31 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 92))(*(_DWORD *)(a2 + 1320)) == 0;
  EnableMenuItem(a1, 0x9C9Fu, v31);
  EnableMenuItem(a1, 0x9D49u, v34 != 4);
  if ( v34 == 4 )
  {
    EnableMenuItem(a1, 0x9C9Cu, 1u);
    CheckMenuItem(a1, 0x9C9Cu, 0);
    EnableMenuItem(a1, 0x9DB9u, 0);
    return sub_4AAC80(a2);
  }
  if ( v34 == 3 )
  {
    EnableMenuItem(a1, 0x9DB9u, 1u);
    EnableMenuItem(a1, 0x9C9Cu, 1u);
  }
  else
  {
    EnableMenuItem(a1, 0x9DB9u, 0);
    EnableMenuItem(a1, 0x9C9Cu, 0);
    if ( (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a2 + 1320) + 244))(*(_DWORD *)(a2 + 1320)) )
    {
      CheckMenuItem(a1, 0x9C9Cu, 8u);
      return sub_4AAC80(a2);
    }
  }
  CheckMenuItem(a1, 0x9C9Cu, 0);
  return sub_4AAC80(a2);
}

//----- (004ABFC0) --------------------------------------------------------
int __userpurge sub_4ABFC0@<eax>(LPCWSTR pszPath@<ecx>, int a2@<edx>, int a3@<esi>, WPARAM wParam)
{
  int v5; // eax
  WPARAM v6; // ebx
  int result; // eax
  HWND v8; // [esp-10h] [ebp-30Ch]
  HWND v9; // [esp-10h] [ebp-30Ch]
  HBITMAP hbmColor; // [esp-8h] [ebp-304h]
  HBITMAP hbmMask; // [esp-4h] [ebp-300h]
  LPARAM lParam[5]; // [esp+8h] [ebp-2F4h] BYREF
  WPARAM v13; // [esp+1Ch] [ebp-2E0h]
  ICONINFO piconinfo; // [esp+24h] [ebp-2D8h] BYREF
  WPARAM v15; // [esp+38h] [ebp-2C4h]
  SHFILEINFOW psfi; // [esp+3Ch] [ebp-2C0h] BYREF

  if ( *(_DWORD *)(532 * a2 + a3 + 5676) || *(_DWORD *)(532 * a2 + a3 + 5672) )
  {
    v15 = 0;
  }
  else
  {
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x109u);
    sub_478D80(a3, a2, psfi.hIcon);
    GetIconInfo(psfi.hIcon, &piconinfo);
    hbmMask = piconinfo.hbmMask;
    hbmColor = piconinfo.hbmColor;
    v5 = SendMessageW(*(HWND *)(a3 + 68), 0x1302u, 0, 0);
    v15 = sub_4011E0(v5, (int)hbmColor, (DWORD)hbmMask);
    DeleteObject(piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmMask);
    DestroyIcon(psfi.hIcon);
  }
  v8 = *(HWND *)(a3 + 68);
  lParam[0] = 2;
  SendMessageW(v8, 0x133Cu, wParam, (LPARAM)lParam);
  v6 = v13;
  v13 = v15;
  v9 = *(HWND *)(a3 + 68);
  lParam[0] = 2;
  result = SendMessageW(v9, 0x133Du, wParam, (LPARAM)lParam);
  if ( v6 )
    return SendMessageW(*(HWND *)(a3 + 68), 0x132Au, v6, 0);
  return result;
}

//----- (004AC150) --------------------------------------------------------
void __userpurge sub_4AC150(int a1@<esi>, int a2)
{
  int v2; // ecx
  WPARAM v3; // edi
  int v4; // eax
  HWND v5; // [esp-10h] [ebp-334h]
  HWND v6; // [esp-10h] [ebp-334h]
  HWND v7; // [esp-10h] [ebp-334h]
  HBITMAP hbmColor; // [esp-8h] [ebp-32Ch]
  HBITMAP hbmMask; // [esp-4h] [ebp-328h]
  LPARAM lParam[7]; // [esp+Ch] [ebp-318h] BYREF
  LPARAM v11[5]; // [esp+28h] [ebp-2FCh] BYREF
  WPARAM v12; // [esp+3Ch] [ebp-2E8h]
  ICONINFO piconinfo; // [esp+44h] [ebp-2E0h] BYREF
  LPCWSTR pszPath; // [esp+58h] [ebp-2CCh]
  WPARAM wParam; // [esp+5Ch] [ebp-2C8h]
  int v16; // [esp+60h] [ebp-2C4h]
  SHFILEINFOW psfi; // [esp+64h] [ebp-2C0h] BYREF

  v2 = *(_DWORD *)(a1 + 4 * a2 + 916);
  v16 = a2;
  pszPath = (LPCWSTR)(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 56))(v2);
  v3 = 0;
  wParam = SendMessageW(*(HWND *)(a1 + 68), 0x1304u, 0, 0);
  if ( (int)wParam > 0 )
  {
    while ( 1 )
    {
      v5 = *(HWND *)(a1 + 68);
      lParam[0] = 8;
      SendMessageW(v5, 0x133Cu, v3, (LPARAM)lParam);
      if ( lParam[6] == v16 )
        break;
      if ( (int)++v3 >= (int)wParam )
        goto LABEL_11;
    }
    if ( *(_DWORD *)(532 * v16 + a1 + 5676) || *(_DWORD *)(532 * v16 + a1 + 5672) )
    {
      v16 = 0;
    }
    else
    {
      SHGetFileInfoW(pszPath, 0, &psfi, 0x2B4u, 0x109u);
      sub_478D80(a1, v16, psfi.hIcon);
      GetIconInfo(psfi.hIcon, &piconinfo);
      hbmMask = piconinfo.hbmMask;
      hbmColor = piconinfo.hbmColor;
      v4 = SendMessageW(*(HWND *)(a1 + 68), 0x1302u, 0, 0);
      v16 = sub_4011E0(v4, (int)hbmColor, (DWORD)hbmMask);
      DeleteObject(piconinfo.hbmColor);
      DeleteObject(piconinfo.hbmMask);
      DestroyIcon(psfi.hIcon);
    }
    v6 = *(HWND *)(a1 + 68);
    v11[0] = 2;
    SendMessageW(v6, 0x133Cu, v3, (LPARAM)v11);
    wParam = v12;
    v7 = *(HWND *)(a1 + 68);
    v11[0] = 2;
    v12 = v16;
    SendMessageW(v7, 0x133Du, v3, (LPARAM)v11);
    if ( wParam )
      SendMessageW(*(HWND *)(a1 + 68), 0x132Au, wParam, 0);
  }
LABEL_11:
  CoTaskMemFree((LPVOID)pszPath);
}

//----- (004AC380) --------------------------------------------------------
void __usercall sub_4AC380(int a1@<eax>)
{
  int v2; // eax

  (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(a1 + 1320) + 52))(*(_DWORD *)(a1 + 1320), 260, a1 + 3492);
  sub_4AB3E0(a1);
  sub_4AAFA0((_DWORD **)a1);
  sub_49B450(a1);
  sub_4AB090(a1, *(_DWORD *)(a1 + 5632), *(_DWORD *)(a1 + 5620));
  sub_494E80(a1);
  sub_496BE0(a1);
  sub_478980(a1);
  SendMessageW(*(HWND *)(a1 + 64), 0x8074u, 0, 0);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 1320) + 292))(*(_DWORD *)(a1 + 1320));
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      sub_496160((_DWORD *)a1);
    }
    else if ( v2 > 1 )
    {
      sub_495FD0(a1);
    }
  }
  else
  {
    sub_4968D0(a1);
  }
  if ( *(_DWORD *)(a1 + 59288) )
    SendMessageW(*(HWND *)(a1 + 88), 0x402u, 0xAFCDu, 1);
}

//----- (004AC440) --------------------------------------------------------
void __usercall sub_4AC440(int a1@<eax>)
{
  HWND Focus; // eax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    sub_49B6D0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 76) )
  {
    sub_477350(a1);
  }
}

//----- (004AC470) --------------------------------------------------------
void __usercall sub_4AC470(int a1@<esi>)
{
  HWND Focus; // eax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    sub_49C620((char ***)a1);
  }
  else if ( Focus == *(HWND *)(a1 + 76) )
  {
    sub_477490((_DWORD *)a1);
  }
}

//----- (004AC4A0) --------------------------------------------------------
HWND __usercall sub_4AC4A0@<eax>(int a1@<esi>)
{
  HWND result; // eax

  result = GetFocus();
  if ( result == *(HWND *)(a1 + 3432) )
    return (HWND)sub_49CDA0((char *)a1);
  if ( result == *(HWND *)(a1 + 76) )
    return (HWND)sub_4777F0(a1);
  return result;
}

//----- (004AC4D0) --------------------------------------------------------
void __usercall sub_4AC4D0(int a1@<eax>, HWND *a2@<ecx>)
{
  HWND v3; // eax
  DWORD MessagePos; // eax
  HWND v5; // ebx
  DWORD v6; // eax
  int v7; // [esp+10h] [ebp-8h] BYREF
  int v8; // [esp+14h] [ebp-4h]

  v3 = *(HWND *)(a1 + 3432);
  if ( *a2 == v3 )
  {
    MessagePos = GetMessagePos();
    v7 = (__int16)MessagePos;
    v8 = SHIWORD(MessagePos);
    sub_49E480(&v7, a1);
  }
  else
  {
    v5 = *a2;
    if ( v5 == (HWND)SendMessageW(v3, 0x101Fu, 0, 0) )
    {
      v6 = GetMessagePos();
      v7 = (__int16)v6;
      v8 = SHIWORD(v6);
      sub_49BD50(a1, &v7);
    }
    else if ( v5 == *(HWND *)(a1 + 88) )
    {
      sub_48F5E0(a1);
    }
  }
}

//----- (004AC560) --------------------------------------------------------
void __usercall sub_4AC560(int a1@<eax>, void *a2@<edi>)
{
  HWND Focus; // eax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    sub_49D950(a1, a2);
  }
  else if ( Focus == *(HWND *)(a1 + 76) )
  {
    sub_4773D0(a1, (int)a2);
  }
}

//----- (004AC590) --------------------------------------------------------
void __usercall sub_4AC590(int a1@<eax>)
{
  HWND v2; // eax
  HWND Focus; // eax

  if ( *(_DWORD *)(a1 + 60608) )
  {
    v2 = (HWND)SendMessageW(*(HWND *)(a1 + 3432), 0x1018u, 0, 0);
    SendMessageW(v2, 0x8037u, 0x71u, 0);
  }
  else
  {
    Focus = GetFocus();
    if ( Focus == *(HWND *)(a1 + 3432) )
    {
      sub_49D660(a1);
    }
    else if ( Focus == *(HWND *)(a1 + 76) )
    {
      sub_477310(a1);
    }
  }
}

//----- (004AC5F0) --------------------------------------------------------
void __usercall sub_4AC5F0(int a1@<ecx>, int a2@<esi>)
{
  HWND Focus; // eax
  HCURSOR CursorW; // eax
  _DWORD *v5; // eax
  HWND v6; // edx
  int v7; // ecx
  WPARAM i; // ebx
  int v9; // edi
  char *v10; // eax
  int v11; // ecx
  HCURSOR v12; // eax
  UINT v13; // [esp-Ch] [ebp-274h] BYREF
  WPARAM v14; // [esp-8h] [ebp-270h]
  LPARAM v15; // [esp-4h] [ebp-26Ch]
  int pExceptionObject[3]; // [esp+10h] [ebp-258h] BYREF
  char *v17[2]; // [esp+1Ch] [ebp-24Ch] BYREF
  void *v18[3]; // [esp+24h] [ebp-244h] BYREF
  LPDATAOBJECT v19; // [esp+30h] [ebp-238h] BYREF
  void *v20[5]; // [esp+34h] [ebp-234h] BYREF
  unsigned int v21; // [esp+48h] [ebp-220h]
  __int16 Src[260]; // [esp+50h] [ebp-218h] BYREF
  int v23; // [esp+264h] [ebp-4h]

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a2 + 3432) )
  {
    v19 = 0;
    if ( sub_494670((_DWORD *)a2) )
    {
      CursorW = LoadCursorW(0, (LPCWSTR)0x7F02);
      SetCursor(CursorW);
      v18[1] = 0;
      v5 = operator new(0x24u);
      if ( !v5 )
      {
        v17[0] = 0;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v17);
        pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      *v5 = v5;
      v18[0] = v5;
      v5[1] = v5;
      v23 = 0;
      sub_49CB90(*(HWND *)(a2 + 3432), a2, (int)v18);
      v17[1] = (char *)&v13;
      if ( a1 )
      {
        sub_40AC30((char ***)&v13, (int **)v18);
        if ( sub_4AE6E0(&v19, (void *)v13) >= 0 )
          *(_DWORD *)(a2 + 60584) = v19;
      }
      else
      {
        sub_40AC30((char ***)&v13, (int **)v18);
        if ( sub_4AE660(&v19, (void *)v13) >= 0 )
        {
          v6 = *(HWND *)(a2 + 3432);
          v7 = *(_DWORD *)(a2 + 5620);
          v15 = 2;
          v14 = -1;
          v13 = 4108;
          *(_DWORD *)(a2 + 60584) = v19;
          *(_DWORD *)(a2 + 61240) = v7;
          for ( i = SendMessageW(v6, v13, v14, v15); i != -1; i = SendMessageW(*(HWND *)(a2 + 3432), 0x100Cu, i, 2) )
          {
            (*(void (__thiscall **)(_DWORD, WPARAM, int, __int16 *))(**(_DWORD **)(a2 + 1320) + 64))(
              *(_DWORD *)(a2 + 1320),
              i,
              260,
              Src);
            v21 = 7;
            v20[4] = 0;
            LOWORD(v20[0]) = 0;
            sub_4094F0(v20, (int)Src, Src, wcslen((const unsigned __int16 *)Src));
            LOBYTE(v23) = 1;
            v9 = *(_DWORD *)(a2 + 61228);
            v10 = sub_40A200((char *)v9, *(_DWORD *)(v9 + 4), (int)v20);
            v11 = *(_DWORD *)(a2 + 61232);
            if ( v11 == 153391688 )
              std::_Xlength_error("list<T> too long");
            *(_DWORD *)(a2 + 61232) = v11 + 1;
            *(_DWORD *)(v9 + 4) = v10;
            **((_DWORD **)v10 + 1) = v10;
            LOBYTE(v23) = 0;
            if ( v21 >= 8 )
              operator delete(v20[0]);
            (*(void (__thiscall **)(_DWORD, WPARAM))(**(_DWORD **)(a2 + 1320) + 188))(*(_DWORD *)(a2 + 1320), i);
          }
        }
      }
      v12 = LoadCursorW(0, (LPCWSTR)0x7F00);
      SetCursor(v12);
      sub_40A140((int)v18);
      operator delete(v18[0]);
    }
  }
  else if ( Focus == *(HWND *)(a2 + 76) )
  {
    sub_477BF0((_DWORD *)a2, a1);
  }
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4AC5F0: using guessed type unsigned __int16 Src[260];

//----- (004AC8B0) --------------------------------------------------------
void __usercall sub_4AC8B0(_DWORD *a1@<esi>)
{
  HWND Focus; // eax

  Focus = GetFocus();
  if ( Focus == (HWND)a1[858] )
  {
    sub_49D190(a1);
  }
  else if ( Focus == (HWND)a1[19] )
  {
    sub_477EB0((int)a1);
  }
}

//----- (004AC8E0) --------------------------------------------------------
void __usercall sub_4AC8E0(int a1@<eax>)
{
  HWND Focus; // eax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 3432) )
  {
    sub_49D460(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 76) )
  {
    sub_478000(a1);
  }
}

//----- (004AC910) --------------------------------------------------------
BOOL __cdecl sub_4AC910(int a1)
{
  int v1; // ecx
  int v2; // esi
  const WCHAR *v4; // esi
  const WCHAR *v5; // edi
  LSTATUS v6; // ebx
  int v7; // eax
  LSTATUS v8; // edi
  HKEY phkResult; // [esp+8h] [ebp-51Ch] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+Ch] [ebp-518h] BYREF
  WCHAR pszSubKey[512]; // [esp+120h] [ebp-404h] BYREF

  v2 = v1;
  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && v2 == 3 )
    return 0;
  if ( v2 == 2 || v2 != 3 )
  {
    v5 = L"none";
    v4 = L"Directory\\shell";
  }
  else
  {
    v4 = L"Folder\\shell";
    v5 = &Data;
  }
  v6 = 1;
  if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, v4, 0, 0x20006u, &phkResult) )
    return 0;
  v7 = lstrlenW(v5);
  v8 = RegSetValueExW(phkResult, 0, 0, 1u, (const BYTE *)v5, 2 * v7 + 2);
  if ( !v8 )
  {
    sub_401000(0x200u, pszSubKey, L"%s\\%s", v4, a1);
    v6 = SHDeleteKeyW(HKEY_CLASSES_ROOT, pszSubKey);
  }
  RegCloseKey(phkResult);
  return !v8 && !v6;
}
// 4AC927: variable 'v1' is possibly undefined
// 4C2880: using guessed type wchar_t aDirectoryShell[16];
// 4C28BC: using guessed type wchar_t aNone_0[5];
// 4C28F4: using guessed type wchar_t aSS_14[6];

//----- (004ACA40) --------------------------------------------------------
BOOL __thiscall sub_4ACA40(void *this)
{
  LSTATUS v3; // esi
  int v4; // eax
  LSTATUS v5; // edi
  HKEY phkResult; // [esp+4h] [ebp-51Ch] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+8h] [ebp-518h] BYREF
  WCHAR pszSubKey[512]; // [esp+11Ch] [ebp-404h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 )
    return 0;
  v3 = 1;
  if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Folder\\shell", 0, 0x20006u, &phkResult) )
    return 0;
  v4 = lstrlenW(&Data);
  v5 = RegSetValueExW(phkResult, 0, 0, 1u, (const BYTE *)&Data, 2 * v4 + 2);
  if ( !v5 )
  {
    sub_401000(0x200u, pszSubKey, L"%s\\%s", L"Folder\\shell", this);
    v3 = SHDeleteKeyW(HKEY_CLASSES_ROOT, pszSubKey);
  }
  RegCloseKey(phkResult);
  return !v5 && !v3;
}
// 4C28F4: using guessed type wchar_t aSS_14[6];

//----- (004ACB60) --------------------------------------------------------
int __usercall sub_4ACB60@<eax>(const WCHAR *a1@<edx>, int a2@<ecx>, const WCHAR *lpString)
{
  const WCHAR *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  DWORD dwDisposition; // [esp+10h] [ebp-734h] BYREF
  HKEY v12; // [esp+14h] [ebp-730h] BYREF
  int v13; // [esp+18h] [ebp-72Ch]
  HKEY phkResult; // [esp+1Ch] [ebp-728h] BYREF
  HKEY hKey; // [esp+20h] [ebp-724h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+24h] [ebp-720h] BYREF
  WCHAR String[512]; // [esp+138h] [ebp-60Ch] BYREF
  char v18[520]; // [esp+538h] [ebp-20Ch] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && a2 == 3 )
    return 0;
  if ( a2 == 2 || (v6 = L"Folder\\shell", a2 != 3) )
    v6 = L"Directory\\shell";
  v13 = 0;
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, v6, 0, 0x20006u, &phkResult) )
  {
    if ( !RegCreateKeyExW(phkResult, a1, 0, 0, 0, 0x20006u, 0, &hKey, &dwDisposition) )
    {
      v7 = lstrlenW(lpString);
      RegSetValueExW(hKey, 0, 0, 1u, (const BYTE *)lpString, 2 * v7 + 2);
      if ( !RegCreateKeyExW(hKey, L"command", 0, 0, 0, 0x20006u, 0, &v12, &dwDisposition) )
      {
        sub_4682E0((int)v18);
        sub_401000(0x200u, String, L"\"%s\" \"%%1\"", v18);
        v8 = lstrlenW(String);
        if ( !RegSetValueExW(v12, 0, 0, 1u, (const BYTE *)String, 2 * v8 + 2) )
        {
          v9 = lstrlenW(a1);
          if ( !RegSetValueExW(phkResult, 0, 0, 1u, (const BYTE *)a1, 2 * v9 + 2) )
            v13 = 1;
        }
        RegCloseKey(v12);
      }
      RegCloseKey(hKey);
    }
    RegCloseKey(phkResult);
  }
  return v13;
}
// 4C2880: using guessed type wchar_t aDirectoryShell[16];
// 4C28D8: using guessed type wchar_t aS1[11];

//----- (004ACD40) --------------------------------------------------------
int sub_4ACD40()
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  DWORD dwDisposition; // [esp+0h] [ebp-734h] BYREF
  HKEY v5; // [esp+4h] [ebp-730h] BYREF
  int v6; // [esp+8h] [ebp-72Ch]
  HKEY phkResult; // [esp+Ch] [ebp-728h] BYREF
  HKEY hKey; // [esp+10h] [ebp-724h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+14h] [ebp-720h] BYREF
  WCHAR String[512]; // [esp+128h] [ebp-60Ch] BYREF
  char v11[520]; // [esp+528h] [ebp-20Ch] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 )
    return 0;
  v6 = 0;
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Folder\\shell", 0, 0x20006u, &phkResult) )
  {
    if ( !RegCreateKeyExW(phkResult, L"openinexplorer++", 0, 0, 0, 0x20006u, 0, &hKey, &dwDisposition) )
    {
      v1 = lstrlenW(L"Open In Explorer++");
      RegSetValueExW(hKey, 0, 0, 1u, (const BYTE *)L"Open In Explorer++", 2 * v1 + 2);
      if ( !RegCreateKeyExW(hKey, L"command", 0, 0, 0, 0x20006u, 0, &v5, &dwDisposition) )
      {
        sub_4682E0((int)v11);
        sub_401000(0x200u, String, L"\"%s\" \"%%1\"", v11);
        v2 = lstrlenW(String);
        if ( !RegSetValueExW(v5, 0, 0, 1u, (const BYTE *)String, 2 * v2 + 2) )
        {
          v3 = lstrlenW(L"openinexplorer++");
          if ( !RegSetValueExW(phkResult, 0, 0, 1u, (const BYTE *)L"openinexplorer++", 2 * v3 + 2) )
            v6 = 1;
        }
        RegCloseKey(v5);
      }
      RegCloseKey(hKey);
    }
    RegCloseKey(phkResult);
  }
  return v6;
}
// 4C28D8: using guessed type wchar_t aS1[11];

//----- (004ACF20) --------------------------------------------------------
void __stdcall sub_4ACF20(_DWORD *a1)
{
  int ***v1; // ebx
  int **i; // edi
  int v3; // eax
  _DWORD **v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // edi

  v1 = (int ***)a1[9];
  for ( i = *v1; i != (int **)v1; i = (int **)*i )
    CoTaskMemFree(i[2]);
  CoTaskMemFree((LPVOID)a1[8]);
  if ( *a1 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*a1 + 8))(*a1);
    goto LABEL_10;
  }
  if ( a1[1] )
  {
    v3 = a1[1];
  }
  else
  {
    if ( !a1[2] )
      goto LABEL_10;
    v3 = a1[2];
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
LABEL_10:
  v4 = (_DWORD **)a1[9];
  v5 = *v4;
  *v4 = v4;
  *(_DWORD *)(a1[9] + 4) = a1[9];
  a1[10] = 0;
  if ( v5 != (_DWORD *)a1[9] )
  {
    do
    {
      v6 = (_DWORD *)*v5;
      operator delete(v5);
      v5 = v6;
    }
    while ( v6 != (_DWORD *)a1[9] );
  }
  operator delete((void *)a1[9]);
}

//----- (004AD000) --------------------------------------------------------
int __stdcall sub_4AD000(int a1, int a2, LPCITEMIDLIST pidl, void *a4, int a5, int a6)
{
  _DWORD *v6; // eax
  IShellFolder v7; // edi
  const ITEMIDLIST *v8; // eax
  int v9; // ebx
  char **v10; // eax
  int v11; // ecx
  ITEMIDLIST *v12; // eax
  int v13; // edi
  HRESULT v14; // edi
  void *v15; // edi
  int v16; // eax
  int v17; // eax
  void **v18; // eax
  void *v19; // ecx
  void **v20; // edi
  int v22; // [esp-Ch] [ebp-5Ch]
  void *v23[4]; // [esp+10h] [ebp-40h] BYREF
  int pExceptionObject[3]; // [esp+20h] [ebp-30h] BYREF
  char *v25; // [esp+2Ch] [ebp-24h] BYREF
  const ITEMIDLIST *v26; // [esp+30h] [ebp-20h]
  LPCITEMIDLIST ppidlLast; // [esp+34h] [ebp-1Ch] BYREF
  IShellFolder *ppshf; // [esp+38h] [ebp-18h] BYREF
  void *ppv; // [esp+3Ch] [ebp-14h] BYREF
  int v30; // [esp+40h] [ebp-10h] BYREF
  int v31; // [esp+4Ch] [ebp-4h]
  LPCITEMIDLIST pidla; // [esp+60h] [ebp+10h]

  v31 = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 32) = ILClone(pidl);
  *(_DWORD *)(a1 + 40) = 0;
  v6 = operator new(0xCu);
  if ( !v6 )
  {
    v25 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_DWORD *)(a1 + 36) = v6;
  *v6 = v6;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) = *(_DWORD *)(a1 + 36);
  LOBYTE(v31) = 1;
  v30 = 0;
  v7.lpVtbl = *(struct IShellFolderVtbl **)a4;
  ppshf = (IShellFolder *)a4;
  if ( v7.lpVtbl != a4 )
  {
    do
    {
      v8 = ILClone((LPCITEMIDLIST)v7.lpVtbl->Release);
      v9 = *(_DWORD *)(a1 + 36);
      ppidlLast = v8;
      v10 = sub_40A550((char *)v9, *(_DWORD *)(v9 + 4), (int)&ppidlLast);
      v11 = *(_DWORD *)(a1 + 40);
      if ( v11 == 1073741822 )
        std::_Xlength_error("list<T> too long");
      *(_DWORD *)(a1 + 40) = v11 + 1;
      *(_DWORD *)(v9 + 4) = v10;
      *(_DWORD *)v10[1] = v10;
      v7.lpVtbl = (struct IShellFolderVtbl *)v7.lpVtbl->QueryInterface;
    }
    while ( (IShellFolder *)v7.lpVtbl != ppshf );
  }
  *(_DWORD *)(a1 + 12) = 0;
  ppv = 0;
  ppidlLast = 0;
  if ( !a5 )
  {
    if ( SHBindToParent(pidl, &stru_4BD7FC, &ppv, &ppidlLast) < 0 )
      goto LABEL_28;
    pidla = (LPCITEMIDLIST)(*(int (__stdcall **)(void *, int, int, LPCITEMIDLIST *, void *, _DWORD, int *))(*(_DWORD *)ppv + 40))(
                             ppv,
                             a2,
                             1,
                             &ppidlLast,
                             &unk_4BD7EC,
                             0,
                             &v30);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    goto LABEL_24;
  }
  if ( SHGetFolderLocation(0, 0, 0, 0, (LPITEMIDLIST *)&ppidlLast) < 0 )
    goto LABEL_20;
  v12 = (ITEMIDLIST *)ppidlLast;
  v26 = ppidlLast;
  if ( pidl && ppidlLast )
  {
    ppshf = 0;
    v13 = 0;
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      if ( !(unsigned __int16)ppshf->lpVtbl->CompareIDs(ppshf, 0, pidl, v26) )
        v13 = 1;
      ppshf->lpVtbl->Release(ppshf);
    }
    v12 = (ITEMIDLIST *)ppidlLast;
  }
  else
  {
    v13 = 0;
  }
  CoTaskMemFree(v12);
  if ( v13 )
  {
    v14 = SHGetDesktopFolder((IShellFolder **)&ppv);
  }
  else
  {
LABEL_20:
    ppidlLast = 0;
    SHGetDesktopFolder((IShellFolder **)&ppidlLast);
    v14 = (*(int (__stdcall **)(LPCITEMIDLIST, LPCITEMIDLIST, _DWORD, const IID *, void **))(*(_DWORD *)&ppidlLast->mkid.cb
                                                                                           + 20))(
            ppidlLast,
            pidl,
            0,
            &stru_4BD7FC,
            &ppv);
    (*(void (__stdcall **)(LPCITEMIDLIST))(*(_DWORD *)&ppidlLast->mkid.cb + 8))(ppidlLast);
  }
  if ( v14 >= 0 )
  {
    v22 = *(_DWORD *)a4;
    memset(v23, 0, 12);
    sub_419FD0(v23, v22, (int)a4, (int)pidl);
    LOBYTE(v31) = 2;
    v15 = v23[0];
    pidla = (LPCITEMIDLIST)(*(int (__stdcall **)(void *, int, int, void *, void *, _DWORD, int *))(*(_DWORD *)ppv + 40))(
                             ppv,
                             a2,
                             a5,
                             v23[0],
                             &unk_4BD7EC,
                             0,
                             &v30);
    (*(void (__stdcall **)(void *))(*(_DWORD *)ppv + 8))(ppv);
    LOBYTE(v31) = 1;
    if ( v15 )
      operator delete(v15);
LABEL_24:
    if ( (int)pidla >= 0 )
    {
      v16 = (**(int (__stdcall ***)(int, void *, int))v30)(v30, &unk_4BD85C, a1);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a1;
      if ( v16 < 0 )
      {
        v17 = (**(int (__stdcall ***)(int, void *, int))v30)(v30, &unk_4BD81C, a1 + 4);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 4);
        if ( v17 < 0 )
        {
          (**(void (__stdcall ***)(int, void *, int))v30)(v30, &unk_4BD7EC, a1 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
        }
      }
    }
  }
LABEL_28:
  if ( v30 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
  v18 = *(void ***)a4;
  *(_DWORD *)a4 = a4;
  *((_DWORD *)a4 + 1) = a4;
  v19 = a4;
  if ( v18 != a4 )
  {
    do
    {
      v20 = (void **)*v18;
      operator delete(v18);
      v19 = a4;
      v18 = v20;
    }
    while ( v20 != a4 );
  }
  operator delete(v19);
  return a1;
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004AD310) --------------------------------------------------------
LRESULT __fastcall sub_4AD310(LPARAM lParam, UINT uMsg, int a3, int a4, WPARAM wParam)
{
  int v7; // eax
  LRESULT result; // eax
  int v9; // eax
  int v10; // edx
  LPARAM lParama[256]; // [esp+10h] [ebp-404h] BYREF

  switch ( uMsg )
  {
    case 0x2Bu:
      if ( !wParam )
      {
        v7 = *(_DWORD *)a3;
        if ( *(_DWORD *)a3 )
          goto LABEL_4;
        if ( *(_DWORD *)(a3 + 4) )
          (*(void (__stdcall **)(_DWORD, UINT, _DWORD, LPARAM))(**(_DWORD **)(a3 + 4) + 24))(
            *(_DWORD *)(a3 + 4),
            uMsg,
            0,
            lParam);
      }
      return 1;
    case 0x2Cu:
      if ( wParam )
        goto LABEL_15;
      v7 = *(_DWORD *)a3;
      if ( *(_DWORD *)a3 )
      {
LABEL_4:
        (*(void (__stdcall **)(int, UINT, _DWORD, LPARAM, _DWORD))(*(_DWORD *)v7 + 28))(v7, uMsg, 0, lParam, 0);
        return 1;
      }
      else
      {
        if ( *(_DWORD *)(a3 + 4) )
          (*(void (__stdcall **)(_DWORD, UINT, _DWORD, LPARAM))(**(_DWORD **)(a3 + 4) + 24))(
            *(_DWORD *)(a3 + 4),
            uMsg,
            0,
            lParam);
        return 1;
      }
    case 0x117u:
      if ( *(_DWORD *)a3 )
      {
        (*(void (__stdcall **)(_DWORD, UINT, WPARAM, LPARAM, _DWORD))(**(_DWORD **)a3 + 28))(
          *(_DWORD *)a3,
          uMsg,
          wParam,
          lParam,
          0);
      }
      else if ( *(_DWORD *)(a3 + 4) )
      {
        (*(void (__stdcall **)(_DWORD, UINT, WPARAM, LPARAM))(**(_DWORD **)(a3 + 4) + 24))(
          *(_DWORD *)(a3 + 4),
          uMsg,
          wParam,
          lParam);
      }
      goto LABEL_15;
    case 0x11Fu:
      v9 = *(_DWORD *)(a3 + 28);
      if ( !v9 )
        goto LABEL_15;
      if ( HIWORD(wParam) != 0xFFFF || lParam )
      {
        sub_4624E0(v9);
        if ( (wParam & 0x100000) == 0 )
        {
          v10 = *(_DWORD *)(a3 + 20);
          if ( (unsigned __int16)wParam >= v10
            && (unsigned __int16)wParam <= *(int *)(a3 + 24)
            && !(*(int (__stdcall **)(_DWORD, int, int, _DWORD, LPARAM *, int))(**(_DWORD **)(a3 + 12) + 20))(
                  *(_DWORD *)(a3 + 12),
                  (unsigned __int16)wParam - v10,
                  5,
                  0,
                  lParama,
                  512) )
          {
            SendMessageW(**(HWND **)(a3 + 28), 0x40Bu, 0, (LPARAM)lParama);
          }
        }
        result = 0;
      }
      else
      {
        sub_462410(v9);
        result = 0;
      }
      break;
    default:
LABEL_15:
      result = DefSubclassProc((HWND)a4, uMsg, wParam, lParam);
      break;
  }
  return result;
}

//----- (004AD620) --------------------------------------------------------
LRESULT __stdcall sub_4AD620(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  return sub_4AD310(lParam, uMsg, dwRefData, (int)hWnd, wParam);
}

//----- (004AD640) --------------------------------------------------------
int __userpurge sub_4AD640@<eax>(
        DWORD_PTR dwRefData@<ecx>,
        int a2@<ebx>,
        int a3@<edi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  bool v9; // zf
  HMENU PopupMenu; // eax
  int v11; // ecx
  HMENU v12; // ebx
  BOOL v13; // ebx
  int v14; // eax
  int v15; // esi
  int v18[9]; // [esp+4h] [ebp-B0h] BYREF
  int *v19; // [esp+28h] [ebp-8Ch]
  HMENU hMenu; // [esp+2Ch] [ebp-88h]
  char v21[128]; // [esp+30h] [ebp-84h] BYREF

  v9 = *(_DWORD *)(dwRefData + 12) == 0;
  v19 = (int *)a4;
  if ( v9 || !a3 || !a4 )
    return -2147467259;
  *(_DWORD *)(dwRefData + 28) = a5;
  *(_DWORD *)(dwRefData + 20) = 1;
  *(_DWORD *)(dwRefData + 24) = 1000;
  PopupMenu = CreatePopupMenu();
  v11 = 0;
  v12 = PopupMenu;
  hMenu = PopupMenu;
  if ( a8 )
    v11 = 256;
  if ( a7 )
    v11 |= 0x10u;
  (*(void (__stdcall **)(_DWORD, HMENU, _DWORD, int, int, int, int))(**(_DWORD **)(dwRefData + 12) + 12))(
    *(_DWORD *)(dwRefData + 12),
    PopupMenu,
    0,
    1,
    1000,
    v11,
    a2);
  (**(void (__thiscall ***)(int, _DWORD, DWORD_PTR, int, HMENU))a3)(
    a3,
    *(_DWORD *)(dwRefData + 32),
    dwRefData + 36,
    a6,
    v12);
  if ( *(_DWORD *)dwRefData || *(_DWORD *)(dwRefData + 4) )
    SetWindowSubclass(*(HWND *)(dwRefData + 16), sub_4AD620, 1u, dwRefData);
  v13 = TrackPopupMenu(v12, 0x100u, *v19, v19[1], 0, *(HWND *)(dwRefData + 16), 0);
  if ( *(_DWORD *)dwRefData || *(_DWORD *)(dwRefData + 4) )
    RemoveWindowSubclass(*(HWND *)(dwRefData + 16), sub_4AD620, 1u);
  if ( v13 < 1 || v13 > 1000 )
  {
    (*(void (__thiscall **)(int, _DWORD, DWORD_PTR))(*(_DWORD *)a3 + 8))(
      a3,
      *(_DWORD *)(dwRefData + 32),
      dwRefData + 36);
  }
  else if ( (*(int (__stdcall **)(_DWORD, int, int, _DWORD, char *))(**(_DWORD **)(dwRefData + 12) + 20))(
              *(_DWORD *)(dwRefData + 12),
              v13 - 1,
              4,
              0,
              v21) < 0
         || !(*(int (__thiscall **)(int, _DWORD, DWORD_PTR, int, char *))(*(_DWORD *)a3 + 4))(
               a3,
               *(_DWORD *)(dwRefData + 32),
               dwRefData + 36,
               a6,
               v21) )
  {
    v14 = *(_DWORD *)(dwRefData + 16);
    v15 = *(_DWORD *)(dwRefData + 12);
    v18[1] = 0;
    v18[4] = 0;
    v18[5] = 0;
    v18[3] = (unsigned __int8)(v13 - 1);
    v18[0] = 36;
    v18[2] = v14;
    v18[6] = 5;
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)v15 + 16))(v15, v18);
    DestroyMenu(hMenu);
    return 0;
  }
  DestroyMenu(hMenu);
  return 0;
}
// 4AD640: could not find valid save-restore pair for ebx

//----- (004AD850) --------------------------------------------------------
BOOL __usercall sub_4AD850@<eax>(int a1@<edx>, HWND a2@<ecx>, LPITEMIDLIST *a3@<ebx>)
{
  bool v5; // cf
  ITEMIDLIST *v6; // eax
  BOOL v7; // esi
  struct _browseinfoW bi; // [esp+8h] [ebp-230h] BYREF
  char v10; // [esp+28h] [ebp-210h] BYREF

  CoInitializeEx(0, 2u);
  bi.hwndOwner = a2;
  v5 = *(_DWORD *)(a1 + 20) < 8u;
  bi.pidlRoot = 0;
  bi.pszDisplayName = (LPWSTR)&v10;
  if ( v5 )
    bi.lpszTitle = (LPCWSTR)a1;
  else
    bi.lpszTitle = *(LPCWSTR *)a1;
  bi.ulFlags = 64;
  bi.lpfn = 0;
  v6 = SHBrowseForFolderW(&bi);
  *a3 = v6;
  v7 = v6 != 0;
  CoUninitialize();
  return v7;
}

//----- (004AD8F0) --------------------------------------------------------
HRESULT __usercall sub_4AD8F0@<eax>(int a1@<ebx>, int a2@<edi>, const WCHAR *a3@<esi>, int a4, _WORD *a5)
{
  HRESULT v5; // edi
  int v8; // [esp+4h] [ebp-4C8h] BYREF
  LPVOID ppv; // [esp+8h] [ebp-4C4h] BYREF
  SHFILEINFOW psfi; // [esp+Ch] [ebp-4C0h] BYREF
  char v11[520]; // [esp+2C0h] [ebp-20Ch] BYREF

  if ( !SHGetFileInfoW(a3, 0, &psfi, 0x2B4u, 0x800u) || (psfi.dwAttributes & 0x10000) == 0 )
    return -2147467259;
  ppv = 0;
  v5 = CoCreateInstance(&stru_4BD8EC, 0, 1u, &stru_4BD82C, &ppv);
  if ( !v5 )
  {
    v8 = 0;
    v5 = (**(int (__stdcall ***)(LPVOID, void *, int *, int))ppv)(ppv, &unk_4BD9DC, &v8, a2);
    if ( !v5 )
    {
      v5 = (*(int (__stdcall **)(int, const WCHAR *, _DWORD))(*(_DWORD *)v8 + 20))(v8, a3, 0);
      if ( !v5 )
      {
        (*(void (__stdcall **)(LPVOID, int, int))(*(_DWORD *)ppv + 76))(ppv, a1, a4);
        (*(void (__stdcall **)(LPVOID, char *, int, _DWORD, int))(*(_DWORD *)ppv + 12))(ppv, v11, 260, 0, 2);
        sub_4011B0(0x104u, (int)v11, a5);
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
    }
    (*(void (__cdecl **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  }
  return v5;
}
// 4AD8F0: could not find valid save-restore pair for edi

//----- (004ADA30) --------------------------------------------------------
HRESULT __usercall sub_4ADA30@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edi>, _DWORD *a3)
{
  HRESULT result; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx
  int v7; // esi
  _DWORD *v8; // ecx
  int v9; // [esp+4h] [ebp-8h] BYREF
  LPVOID ppv; // [esp+8h] [ebp-4h] BYREF

  ppv = 0;
  result = CoCreateInstance(&stru_4BD8EC, 0, 1u, &stru_4BD82C, &ppv);
  if ( result >= 0 )
  {
    if ( a1[5] < 8u )
      v5 = a1;
    else
      v5 = (_DWORD *)*a1;
    (*(void (__stdcall **)(LPVOID, _DWORD *))(*(_DWORD *)ppv + 80))(ppv, v5);
    if ( a2[5] < 8u )
      v6 = a2;
    else
      v6 = (_DWORD *)*a2;
    (*(void (__stdcall **)(LPVOID, _DWORD *))(*(_DWORD *)ppv + 28))(ppv, v6);
    v9 = 0;
    v7 = (**(int (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_4BD9DC, &v9);
    if ( v7 >= 0 )
    {
      v8 = a3;
      if ( a3[5] >= 8u )
        v8 = (_DWORD *)*a3;
      (*(void (__stdcall **)(int, _DWORD *, int))(*(_DWORD *)v9 + 24))(v9, v8, 1);
      (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
    }
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    return v7;
  }
  return result;
}

//----- (004ADAF0) --------------------------------------------------------
int __usercall sub_4ADAF0@<eax>(const WCHAR *a1@<esi>, _WORD *a2)
{
  int v2; // edi
  HANDLE i; // eax
  struct _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-2025Ch] BYREF
  __int16 v6[32768]; // [esp+260h] [ebp-2000Ch] BYREF
  WCHAR FileName[32770]; // [esp+10260h] [ebp-1000Ch] BYREF

  v2 = 2;
  if ( !a1 )
    return -2147024809;
  if ( a1[lstrlenW(a1) - 1] == 92 )
    sub_401000(0x8000u, (wchar_t *)v6, L"%sNew Folder", a1);
  else
    sub_401000(0x8000u, (wchar_t *)v6, L"%s\\New Folder", a1);
  sub_401000(0x8000u, FileName, L"\\\\?\\%s", v6);
  for ( i = FindFirstFileW(FileName, &FindFileData); i != (HANDLE)-1; i = FindFirstFileW(FileName, &FindFileData) )
  {
    FindClose(i);
    if ( a1[lstrlenW(a1) - 1] == 92 )
      sub_401000(0x8000u, (wchar_t *)v6, L"%sNew Folder (%d)", a1, v2);
    else
      sub_401000(0x8000u, (wchar_t *)v6, L"%s\\New Folder (%d)", a1, v2);
    sub_401000(0x8000u, FileName, L"\\\\?\\%s", v6);
    ++v2;
  }
  if ( !CreateDirectoryW(FileName, 0) )
    return -2147467259;
  sub_4A96F0(0x8000, (int)v6, a2);
  return 0;
}
// 4C2BC4: using guessed type wchar_t aSnewFolder[13];
// 4C2BE0: using guessed type wchar_t aSNewFolder[14];
// 4C2BFC: using guessed type wchar_t aS_7[7];
// 4C2C0C: using guessed type wchar_t aSnewFolderD[18];
// 4C2C30: using guessed type wchar_t aSNewFolderD[19];
// 4C2C58: using guessed type wchar_t aS_8[7];
// 4ADAF0: using guessed type wchar_t var_2000C[32768];

//----- (004ADC50) --------------------------------------------------------
int __usercall sub_4ADC50@<eax>(int *a1@<eax>, int *a2@<ecx>)
{
  WCHAR *v4; // edi
  const WCHAR *v5; // eax
  bool v6; // cf
  int *v7; // edx
  unsigned int v8; // eax
  int *v9; // edx
  unsigned int v10; // eax
  WCHAR *v11; // ebx
  int v12; // esi
  struct _SHFILEOPSTRUCTW FileOp; // [esp+Ch] [ebp-24h] BYREF
  LPCWSTR lpString; // [esp+2Ch] [ebp-4h]

  v4 = (WCHAR *)operator new[](2 * (a2[4] + 2));
  v5 = (const WCHAR *)operator new[](2 * (a1[4] + 2));
  v6 = (unsigned int)a2[5] < 8;
  lpString = v5;
  if ( v6 )
    v7 = a2;
  else
    v7 = (int *)*a2;
  v8 = a2[4] + 2;
  if ( a2[4] != -2 && v8 <= 0x7FFFFFFF )
    sub_4A96F0(v8, (int)v7, v4);
  v4[lstrlenW(v4) + 1] = 0;
  if ( (unsigned int)a1[5] < 8 )
    v9 = a1;
  else
    v9 = (int *)*a1;
  v10 = a1[4] + 2;
  if ( a1[4] == -2 || v10 > 0x7FFFFFFF )
  {
    v11 = (WCHAR *)lpString;
  }
  else
  {
    v11 = (WCHAR *)lpString;
    sub_4A96F0(v10, (int)v9, lpString);
  }
  v11[lstrlenW(v11) + 1] = 0;
  v12 = 0;
  FileOp.hwnd = 0;
  FileOp.wFunc = 4;
  FileOp.pFrom = v4;
  FileOp.pTo = v11;
  FileOp.fFlags = 64;
  if ( !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted )
    v12 = 1;
  operator delete[](v4);
  operator delete[](v11);
  return v12;
}

//----- (004ADD50) --------------------------------------------------------
HANDLE __cdecl sub_4ADD50(int a1)
{
  const WCHAR *v1; // ecx
  char *v2; // esi
  const WCHAR *v3; // eax
  HANDLE result; // eax
  BOOL v5; // ebx
  HANDLE v6; // esi
  LONG HighPart; // ebx
  int v8; // edi
  int v9; // edi
  int v10; // edi
  const WCHAR *v11; // eax
  LPCWSTR lpFileName; // [esp+Ch] [ebp-278h]
  HCRYPTPROV phProv; // [esp+10h] [ebp-274h] BYREF
  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-270h] BYREF
  LARGE_INTEGER liDistanceToMove; // [esp+18h] [ebp-26Ch] BYREF
  char v16; // [esp+25h] [ebp-25Fh] BYREF
  char Buffer; // [esp+26h] [ebp-25Eh] BYREF
  BYTE pbBuffer; // [esp+27h] [ebp-25Dh] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-25Ch] BYREF

  v2 = (char *)v1;
  lpFileName = v1;
  if ( *((_DWORD *)v1 + 5) < 8u )
    v3 = v1;
  else
    v3 = *(const WCHAR **)v1;
  result = FindFirstFileW(v3, &FindFileData);
  if ( result != (HANDLE)-1 )
  {
    v5 = (FindFileData.dwFileAttributes & 0x10) == 16;
    result = (HANDLE)FindClose(result);
    if ( !v5 )
    {
      sub_46AA40(v2, &liDistanceToMove);
      if ( *((_DWORD *)v2 + 5) >= 8u )
        v2 = *(char **)v2;
      result = CreateFileW((LPCWSTR)v2, 2u, 0, 0, 3u, 0, 0);
      v6 = result;
      if ( result != (HANDLE)-1 )
      {
        HighPart = liDistanceToMove.HighPart;
        SetFilePointerEx(result, liDistanceToMove, 0, 0);
        SetEndOfFile(v6);
        SetFilePointer(v6, 0, 0, 0);
        v8 = 0;
        for ( Buffer = 0; v8 < __SPAIR64__(HighPart, liDistanceToMove.LowPart); ++v8 )
          WriteFile(v6, &Buffer, 1u, &NumberOfBytesWritten, 0);
        if ( a1 == 2 )
        {
          SetFilePointer(v6, 0, 0, 0);
          v9 = 0;
          v16 = -1;
          if ( HighPart >= 0 && (HighPart > 0 || liDistanceToMove.LowPart) )
          {
            do
            {
              WriteFile(v6, &v16, 1u, &NumberOfBytesWritten, 0);
              ++v9;
            }
            while ( v9 < __SPAIR64__(HighPart, liDistanceToMove.LowPart) );
          }
          SetFilePointer(v6, 0, 0, 0);
          CryptAcquireContextW(&phProv, L"SecureDelete", 0, 0x18u, 8u);
          v10 = 0;
          if ( HighPart >= 0 && (HighPart > 0 || liDistanceToMove.LowPart) )
          {
            do
            {
              CryptGenRandom(phProv, 1u, &pbBuffer);
              WriteFile(v6, &pbBuffer, 1u, &NumberOfBytesWritten, 0);
              ++v10;
            }
            while ( v10 < __SPAIR64__(HighPart, liDistanceToMove.LowPart) );
          }
          CryptAcquireContextW(&phProv, L"SecureDelete", 0, 0x18u, 0x10u);
        }
        FlushFileBuffers(v6);
        CloseHandle(v6);
        v11 = lpFileName;
        if ( *((_DWORD *)lpFileName + 5) >= 8u )
          v11 = *(const WCHAR **)lpFileName;
        return (HANDLE)DeleteFileW(v11);
      }
    }
  }
  return result;
}
// 4ADD66: variable 'v1' is possibly undefined

//----- (004ADF80) --------------------------------------------------------
_WORD *__cdecl sub_4ADF80(_DWORD **a1)
{
  _DWORD *v1; // eax
  char *v2; // esi
  int v3; // ebx
  int v4; // edi
  void **v5; // eax
  _WORD *result; // eax
  _DWORD *v7; // [esp+8h] [ebp-28h]
  _DWORD *v8; // [esp+Ch] [ebp-24h]
  void *Src[4]; // [esp+10h] [ebp-20h] BYREF
  int v10; // [esp+20h] [ebp-10h]
  unsigned int v11; // [esp+24h] [ebp-Ch]

  v1 = (_DWORD *)**a1;
  v2 = 0;
  v3 = 0;
  v7 = *a1;
  v8 = v1;
  if ( v1 != *a1 )
  {
    while ( 1 )
    {
      LOWORD(Src[0]) = 0;
      v11 = 7;
      v10 = 0;
      sub_4090E0((int)Src, v1 + 2, 0, 0xFFFFFFFF);
      v4 = v3 + v10;
      v2 = (char *)realloc(v2, 2 * (v3 + v10) + 2);
      v5 = (void **)Src[0];
      if ( v11 < 8 )
        v5 = Src;
      memcpy_0(&v2[2 * v3], v5, 2 * v10 + 2);
      v3 = v4 + 1;
      if ( v11 >= 8 )
        operator delete(Src[0]);
      v8 = (_DWORD *)*v8;
      if ( v8 == v7 )
        break;
      v1 = v8;
    }
  }
  result = realloc(v2, 2 * v3 + 2);
  result[v3] = 0;
  return result;
}

//----- (004AE060) --------------------------------------------------------
int __usercall sub_4AE060@<eax>(_DWORD **a1@<eax>, HWND a2, int a3)
{
  WCHAR *v3; // esi
  int v4; // edi
  FILEOP_FLAGS v5; // ax
  struct _SHFILEOPSTRUCTW FileOp; // [esp+8h] [ebp-20h] BYREF

  v3 = sub_4ADF80(a1);
  v4 = 0;
  v5 = 0;
  if ( !a3 )
    v5 = 64;
  FileOp.hwnd = a2;
  FileOp.wFunc = 3;
  FileOp.pFrom = v3;
  FileOp.pTo = 0;
  FileOp.fFlags = v5;
  memset(&FileOp.fAnyOperationsAborted, 0, 12);
  if ( !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted )
    v4 = 1;
  free(v3);
  return v4;
}

//----- (004AE0D0) --------------------------------------------------------
BOOL __usercall sub_4AE0D0@<eax>(int a1@<edx>, HWND a2@<ecx>, _DWORD *a3@<edi>)
{
  BOOL result; // eax
  BOOL v4; // esi
  ITEMIDLIST *v5; // ebx
  LPCITEMIDLIST pidl; // [esp+Ch] [ebp-214h] BYREF
  WCHAR pszPath; // [esp+10h] [ebp-210h] BYREF
  __int16 v8; // [esp+12h] [ebp-20Eh] BYREF

  pidl = 0;
  result = sub_4AD850(a1, a2, (LPITEMIDLIST *)&pidl);
  v4 = result;
  if ( result )
  {
    v5 = (ITEMIDLIST *)pidl;
    SHGetPathFromIDListW(pidl, &pszPath);
    sub_4094F0(a3, (int)&v8, &pszPath, wcslen(&pszPath));
    CoTaskMemFree(v5);
    return v4;
  }
  return result;
}

//----- (004AE160) --------------------------------------------------------
int __cdecl sub_4AE160(int a1, int a2)
{
  int v2; // ebx
  HDROP v3; // eax
  signed int v4; // edi
  int v5; // edx
  WCHAR *v6; // eax
  WCHAR v7; // cx
  int v8; // edx
  WCHAR *v9; // eax
  WCHAR v10; // cx
  int v11; // edx
  __int16 v13; // [esp+10h] [ebp-6B4h] BYREF
  int v14; // [esp+14h] [ebp-6B0h]
  int v15; // [esp+18h] [ebp-6ACh]
  int v16; // [esp+1Ch] [ebp-6A8h]
  int v17; // [esp+20h] [ebp-6A4h]
  STGMEDIUM v18; // [esp+24h] [ebp-6A0h] BYREF
  HDROP hDrop; // [esp+30h] [ebp-694h]
  int v20; // [esp+34h] [ebp-690h]
  unsigned int v21; // [esp+38h] [ebp-68Ch]
  int FileW; // [esp+3Ch] [ebp-688h]
  int v23; // [esp+40h] [ebp-684h]
  LPDATAOBJECT ppDataObj; // [esp+44h] [ebp-680h] BYREF
  void *v25[4]; // [esp+48h] [ebp-67Ch] BYREF
  int v26; // [esp+58h] [ebp-66Ch]
  unsigned int v27; // [esp+5Ch] [ebp-668h]
  void *v28[4]; // [esp+64h] [ebp-660h] BYREF
  int v29; // [esp+74h] [ebp-650h]
  unsigned int v30; // [esp+78h] [ebp-64Ch]
  void *v31[4]; // [esp+80h] [ebp-644h] BYREF
  int v32; // [esp+90h] [ebp-634h]
  unsigned int v33; // [esp+94h] [ebp-630h]
  WCHAR pszPath[260]; // [esp+9Ch] [ebp-628h] BYREF
  WCHAR szFile; // [esp+2A4h] [ebp-420h] BYREF
  __int16 v36; // [esp+2A6h] [ebp-41Eh] BYREF
  WCHAR FileName[260]; // [esp+4ACh] [ebp-218h] BYREF
  int v38; // [esp+6C0h] [ebp-4h]

  ppDataObj = 0;
  v2 = -1;
  if ( OleGetClipboard(&ppDataObj) >= 0 )
  {
    v13 = 15;
    v15 = 1;
    v17 = 1;
    v14 = 0;
    v16 = -1;
    if ( ppDataObj->lpVtbl->GetData(ppDataObj, (FORMATETC *)&v13, &v18) >= 0 )
    {
      v3 = (HDROP)GlobalLock(v18.hBitmap);
      hDrop = v3;
      if ( v3 )
      {
        v4 = 0;
        FileW = DragQueryFileW(v3, 0xFFFFFFFF, 0, 0);
        v23 = 0;
        if ( FileW > 0 )
        {
          v20 = a1 - (_DWORD)FileName;
          v21 = 520;
          do
          {
            DragQueryFileW(hDrop, v4, &szFile, 0x104u);
            v5 = 260;
            v6 = FileName;
            while ( v5 != -2147483386 )
            {
              v7 = *(WCHAR *)((char *)v6 + v20);
              if ( !v7 )
                break;
              *v6++ = v7;
              if ( !--v5 )
              {
                --v6;
                break;
              }
            }
            *v6 = 0;
            v8 = 260;
            v9 = pszPath;
            while ( v8 != -2147483386 )
            {
              v10 = v9[v21 / 2];
              if ( !v10 )
                break;
              *v9++ = v10;
              if ( !--v8 )
              {
                --v9;
                break;
              }
            }
            *v9 = 0;
            PathStripPathW(pszPath);
            PathAppendW(FileName, pszPath);
            if ( a2 )
            {
              if ( a2 == 1 )
                CreateHardLinkW(FileName, &szFile, 0);
            }
            else
            {
              PathRenameExtensionW(FileName, L".lnk");
              v27 = 7;
              v26 = 0;
              LOWORD(v25[0]) = 0;
              sub_4094F0(v25, v11, &unk_4C2E74, 0);
              v38 = 0;
              v30 = 7;
              v29 = 0;
              LOWORD(v28[0]) = 0;
              sub_4094F0(v28, (int)FileName, FileName, wcslen(FileName));
              LOBYTE(v38) = 1;
              LOWORD(v31[0]) = 0;
              v33 = 7;
              v32 = 0;
              sub_4094F0(v31, (int)&v36, &szFile, wcslen(&szFile));
              LOBYTE(v38) = 2;
              sub_4ADA30(v31, v25, v28);
              if ( v33 >= 8 )
                operator delete(v31[0]);
              v33 = 7;
              v32 = 0;
              LOWORD(v31[0]) = 0;
              if ( v30 >= 8 )
                operator delete(v28[0]);
              v38 = -1;
              v30 = 7;
              v29 = 0;
              LOWORD(v28[0]) = 0;
              if ( v27 >= 8 )
                operator delete(v25[0]);
              v4 = v23;
              v27 = 7;
              v26 = 0;
              LOWORD(v25[0]) = 0;
            }
            v23 = ++v4;
          }
          while ( v4 < FileW );
        }
        GlobalUnlock(v18.hBitmap);
        v2 = FileW;
      }
      ReleaseStgMedium(&v18);
    }
    ppDataObj->lpVtbl->Release(ppDataObj);
  }
  return v2;
}
// 4AE2AB: conditional instruction was optimized away because edx.4!=0
// 4AE2E6: conditional instruction was optimized away because edx.4!=0
// 4AE36C: variable 'v11' is possibly undefined

//----- (004AE530) --------------------------------------------------------
HRESULT __usercall sub_4AE530@<eax>(LPDATAOBJECT *a1@<edi>, void *a2, int a3, int a4, void *a5)
{
  HGLOBAL v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  IDataObject *v8; // eax
  HRESULT v9; // esi
  char **v11[2]; // [esp+0h] [ebp-6Ch] BYREF
  int *v12; // [esp+8h] [ebp-64h]
  int v13[5]; // [esp+1Ch] [ebp-50h] BYREF
  __int16 v14; // [esp+30h] [ebp-3Ch]
  int v15; // [esp+34h] [ebp-38h]
  int v16; // [esp+38h] [ebp-34h]
  int v17; // [esp+3Ch] [ebp-30h]
  int v18; // [esp+40h] [ebp-2Ch]
  int v19[6]; // [esp+44h] [ebp-28h] BYREF
  char ***v20; // [esp+5Ch] [ebp-10h] BYREF
  int v21; // [esp+68h] [ebp-4h]

  v21 = 0;
  v20 = v11;
  sub_40AC30(v11, (int **)&a2);
  sub_467BD0((int)v13, v11[0], (int)v11[1]);
  v14 = RegisterClipboardFormatW(L"Preferred DropEffect");
  v15 = 0;
  v16 = 1;
  v17 = -1;
  v18 = 1;
  v5 = GlobalAlloc(2u, 4u);
  v6 = GlobalLock(v5);
  v12 = (int *)v5;
  *v6 = (a5 != 0) + 1;
  GlobalUnlock(v12);
  v19[5] = 0;
  v19[4] = (int)v5;
  v19[3] = 1;
  v7 = operator new(0x20u);
  a5 = v7;
  LOBYTE(v21) = 1;
  if ( v7 )
    v8 = (IDataObject *)sub_462030(v7, v13, v19);
  else
    v8 = 0;
  LOBYTE(v21) = 0;
  v12 = (int *)&v20;
  *a1 = v8;
  v20 = 0;
  ((void (__cdecl *)(IDataObject *, _DWORD *, int *))v8->lpVtbl->QueryInterface)(v8, dword_4BD9AC, v12);
  ((void (__cdecl *)(char ***, int))(*v20)[3])(v20, 1);
  ((void (__cdecl *)(char ***))(*v20)[2])(v20);
  v9 = OleSetClipboard(*a1);
  sub_40A140((int)&a2);
  operator delete(a2);
  return v9;
}
// 4BD9AC: using guessed type _DWORD dword_4BD9AC[4];

//----- (004AE660) --------------------------------------------------------
HRESULT __usercall sub_4AE660@<eax>(LPDATAOBJECT *a1@<edi>, void *a2)
{
  HRESULT v2; // esi
  char **v4[3]; // [esp-10h] [ebp-2Ch] BYREF
  int v5; // [esp-4h] [ebp-20h]
  char ***v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v5 = 1;
  v6 = v4;
  v7 = 0;
  sub_40AC30(v4, (int **)&a2);
  v2 = sub_4AE530(a1, v4[0], (int)v4[1], (int)v4[2], (void *)v5);
  sub_40A140((int)&a2);
  operator delete(a2);
  return v2;
}

//----- (004AE6E0) --------------------------------------------------------
HRESULT __usercall sub_4AE6E0@<eax>(LPDATAOBJECT *a1@<edi>, void *a2)
{
  HRESULT v2; // esi
  char **v4[3]; // [esp-10h] [ebp-2Ch] BYREF
  void *v5; // [esp-4h] [ebp-20h]
  char ***v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v5 = 0;
  v6 = v4;
  v7 = 0;
  sub_40AC30(v4, (int **)&a2);
  v2 = sub_4AE530(a1, v4[0], (int)v4[1], (int)v4[2], v5);
  sub_40A140((int)&a2);
  operator delete(a2);
  return v2;
}

//----- (004AE760) --------------------------------------------------------
BOOL __usercall sub_4AE760@<eax>(int a1@<edx>, _DWORD **a2@<ecx>, HWND a3, void **a4)
{
  void *v5; // edx
  BOOL v6; // eax
  BOOL v7; // edi
  WCHAR *v9; // edi
  BOOL v10; // esi
  struct _SHFILEOPSTRUCTW FileOp; // [esp+14h] [ebp-6Ch] BYREF
  _DWORD **v12; // [esp+34h] [ebp-4Ch]
  void *v13[5]; // [esp+38h] [ebp-48h] BYREF
  unsigned int v14; // [esp+4Ch] [ebp-34h]
  void *v15[5]; // [esp+54h] [ebp-2Ch] BYREF
  unsigned int v16; // [esp+68h] [ebp-18h]
  int v17; // [esp+7Ch] [ebp-4h]

  v12 = a2;
  v16 = 7;
  v15[4] = 0;
  LOWORD(v15[0]) = 0;
  v17 = 0;
  if ( (unsigned int)a4[5] < 8 )
    v5 = a4;
  else
    v5 = *a4;
  LOWORD(v13[0]) = 0;
  v14 = 7;
  v13[4] = 0;
  sub_4094F0(v13, (int)v5, v5, wcslen((const unsigned __int16 *)v5));
  LOBYTE(v17) = 1;
  v6 = sub_4AE0D0((int)v13, a3, v15);
  LOBYTE(v17) = 0;
  v7 = v6;
  if ( v14 >= 8 )
    operator delete(v13[0]);
  if ( v7 )
  {
    FileOp.hwnd = a3;
    v9 = sub_4ADF80(v12);
    FileOp.wFunc = 2 - (a1 != 0);
    FileOp.pFrom = v9;
    if ( v16 < 8 )
      FileOp.pTo = (PCZZWSTR)v15;
    else
      FileOp.pTo = (PCZZWSTR)v15[0];
    FileOp.fFlags = 64;
    v10 = !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted;
    free(v9);
    if ( v16 >= 8 )
      operator delete(v15[0]);
    return v10;
  }
  else
  {
    if ( v16 >= 8 )
      operator delete(v15[0]);
    return 0;
  }
}

//----- (004AE8C0) --------------------------------------------------------
int __cdecl sub_4AE8C0(void *a1)
{
  const WCHAR *v1; // ecx
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  const WCHAR *v5; // eax
  _DWORD *v6; // eax
  void *v7; // edi
  _DWORD *v8; // eax
  void *v9; // esi
  WCHAR *cFileName; // eax
  char *v12; // eax
  char *v14; // eax
  int *v15; // eax
  _DWORD *v16; // edi
  int v17; // eax
  void (__thiscall ***v18)(_DWORD, int); // esi
  char *v19; // edi
  int v20; // eax
  void (__thiscall ***v21)(_DWORD, int); // esi
  char *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  int v26; // edx
  void **v27; // ecx
  int v28; // edx
  int v29; // edx
  _DWORD *v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  _DWORD *v33; // eax
  _DWORD *v34; // eax
  _DWORD *i; // esi
  _DWORD *v36; // eax
  _DWORD *j; // esi
  _DWORD *v38; // eax
  LPCVOID *v39; // esi
  const WCHAR *v40; // eax
  HANDLE FileW; // eax
  void *v42; // esi
  LPCVOID *v43; // eax
  int v44; // edx
  int v45; // edi
  int v46; // eax
  void (__thiscall ***v47)(_DWORD, int); // esi
  int v49; // ecx
  int v50; // edi
  int v51; // eax
  void (__thiscall ***v52)(_DWORD, int); // esi
  FILETIME v53; // [esp+14h] [ebp-560h] BYREF
  struct _FILETIME FileTime; // [esp+1Ch] [ebp-558h] BYREF
  int pExceptionObject[3]; // [esp+24h] [ebp-550h] BYREF
  int v56[4]; // [esp+30h] [ebp-544h] BYREF
  int v57[2]; // [esp+40h] [ebp-534h] BYREF
  void **v58; // [esp+48h] [ebp-52Ch] BYREF
  char v59[12]; // [esp+4Ch] [ebp-528h] BYREF
  void **v60; // [esp+58h] [ebp-51Ch]
  _DWORD *v61; // [esp+5Ch] [ebp-518h]
  _DWORD *v62; // [esp+68h] [ebp-50Ch]
  _DWORD *v63; // [esp+6Ch] [ebp-508h]
  _DWORD *v64; // [esp+78h] [ebp-4FCh]
  _DWORD *v65; // [esp+7Ch] [ebp-4F8h]
  char *v66; // [esp+80h] [ebp-4F4h]
  int v67; // [esp+84h] [ebp-4F0h]
  int v68; // [esp+88h] [ebp-4ECh]
  int v69[19]; // [esp+90h] [ebp-4E4h] BYREF
  char *v70; // [esp+DCh] [ebp-498h] BYREF
  void *v71; // [esp+E0h] [ebp-494h] BYREF
  int v72; // [esp+E4h] [ebp-490h]
  void *v73; // [esp+ECh] [ebp-488h] BYREF
  int v74; // [esp+F0h] [ebp-484h]
  unsigned __int64 v75; // [esp+F8h] [ebp-47Ch] BYREF
  void ***v76; // [esp+100h] [ebp-474h]
  void ***v77; // [esp+108h] [ebp-46Ch] BYREF
  LPCWSTR v78; // [esp+10Ch] [ebp-468h] BYREF
  char *v79; // [esp+110h] [ebp-464h] BYREF
  HANDLE hFindFile; // [esp+114h] [ebp-460h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+118h] [ebp-45Ch] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+368h] [ebp-20Ch] BYREF
  LPCWSTR lpFileName[4]; // [esp+378h] [ebp-1FCh] BYREF
  int v84; // [esp+388h] [ebp-1ECh]
  unsigned int v85; // [esp+38Ch] [ebp-1E8h]
  void *v86[4]; // [esp+394h] [ebp-1E0h] BYREF
  int v87; // [esp+3A4h] [ebp-1D0h]
  unsigned int v88; // [esp+3A8h] [ebp-1CCh]
  LPCVOID lpBuffer[4]; // [esp+3B0h] [ebp-1C4h] BYREF
  HANDLE v90; // [esp+3C0h] [ebp-1B4h]
  unsigned int v91; // [esp+3C4h] [ebp-1B0h]
  void *v92[4]; // [esp+3CCh] [ebp-1A8h] BYREF
  int v93; // [esp+3DCh] [ebp-198h]
  unsigned int v94; // [esp+3E0h] [ebp-194h]
  void *v95[4]; // [esp+3E8h] [ebp-18Ch] BYREF
  int v96; // [esp+3F8h] [ebp-17Ch]
  unsigned int v97; // [esp+3FCh] [ebp-178h]
  void *Src[4]; // [esp+404h] [ebp-170h] BYREF
  unsigned int v99; // [esp+414h] [ebp-160h]
  unsigned int v100; // [esp+418h] [ebp-15Ch]
  unsigned __int16 v101; // [esp+420h] [ebp-154h] BYREF
  __int16 v102; // [esp+422h] [ebp-152h] BYREF
  unsigned __int16 v103; // [esp+520h] [ebp-54h] BYREF
  __int16 v104; // [esp+522h] [ebp-52h] BYREF
  int v105; // [esp+570h] [ebp-4h]

  hFindFile = a1;
  v78 = v1;
  v2 = sub_4199C0(v95, (int)a1);
  v105 = 0;
  sub_4160E0((char *)L"\r\n\r\n", lpBuffer, v2);
  LOBYTE(v105) = 2;
  if ( v97 >= 8 )
    operator delete(v95[0]);
  v97 = 7;
  v96 = 0;
  LOWORD(v95[0]) = 0;
  GetLocalTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  LocalFileTimeToFileTime(&FileTime, &v53);
  sub_46AB90(&v101, 128, &v53, 0);
  LOWORD(Src[0]) = 0;
  v100 = 7;
  v99 = 0;
  sub_4094F0(Src, (int)&v102, &v101, wcslen(&v101));
  LOBYTE(v105) = 3;
  v3 = sub_40B1A0(L"Date\r\n----\r\n", v92, Src);
  LOBYTE(v105) = 4;
  v4 = sub_4160E0((char *)L"\r\n\r\n", v86, v3);
  LOBYTE(v105) = 5;
  sub_406A00(lpBuffer, v4, 0, 0xFFFFFFFF);
  if ( v88 >= 8 )
    operator delete(v86[0]);
  v88 = 7;
  v87 = 0;
  LOWORD(v86[0]) = 0;
  if ( v94 >= 8 )
    operator delete(v92[0]);
  LOBYTE(v105) = 2;
  v94 = 7;
  v93 = 0;
  LOWORD(v92[0]) = 0;
  if ( v100 >= 8 )
    operator delete(Src[0]);
  sub_418090(lpFileName, (int)hFindFile, (int)L"\\*");
  LOBYTE(v105) = 6;
  v5 = lpFileName[0];
  if ( v85 < 8 )
    v5 = (const WCHAR *)lpFileName;
  hFindFile = FindFirstFileW(v5, &FindFileData);
  v74 = 0;
  v6 = operator new(0x24u);
  if ( !v6 )
  {
    v79 = 0;
    std::exception::exception((std::exception *)&v75, (const char *const *)&v79);
    LODWORD(v75) = &std::bad_alloc::`vftable';
    _CxxThrowException(&v75, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v7 = v6;
  *v6 = v6;
  v73 = v6;
  v6[1] = v6;
  LOBYTE(v105) = 7;
  v72 = 0;
  v8 = operator new(0x24u);
  if ( !v8 )
  {
    v70 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v70);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v9 = v8;
  *v8 = v8;
  v71 = v8;
  v8[1] = v8;
  LOBYTE(v105) = 8;
  v75 = 0i64;
  if ( hFindFile != (HANDLE)-1 )
  {
    if ( lstrcmpiW(FindFileData.cFileName, L".") && lstrcmpiW(FindFileData.cFileName, L"..") )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        sub_4095E0(v92, FindFileData.cFileName);
        LOBYTE(v105) = 9;
        sub_40AAD0((int)v92, (int)&v73);
        LOBYTE(v105) = 8;
        sub_409000((int)v92);
      }
      else
      {
        sub_4095E0(v92, FindFileData.cFileName);
        LOBYTE(v105) = 10;
        sub_40AAD0((int)v92, (int)&v71);
        LOBYTE(v105) = 8;
        sub_409000((int)v92);
        v9 = v71;
        v75 = __PAIR64__(FindFileData.nFileSizeHigh, FindFileData.nFileSizeLow);
      }
      v7 = v73;
    }
    while ( FindNextFileW(hFindFile, &FindFileData) )
    {
      if ( lstrcmpiW(FindFileData.cFileName, L".") && lstrcmpiW(FindFileData.cFileName, L"..") )
      {
        cFileName = FindFileData.cFileName;
        v100 = 7;
        v99 = 0;
        LOWORD(Src[0]) = 0;
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          while ( *cFileName++ )
            ;
          sub_4094F0(Src, (int)FindFileData.cFileName, FindFileData.cFileName, cFileName - &FindFileData.cFileName[1]);
          LOBYTE(v105) = 11;
          v12 = sub_40A200((char *)v7, *((_DWORD *)v7 + 1), (int)Src);
          if ( v74 == 153391688 )
            goto LABEL_94;
          ++v74;
          *((_DWORD *)v7 + 1) = v12;
          **((_DWORD **)v12 + 1) = v12;
          LOBYTE(v105) = 8;
          if ( v100 >= 8 )
            operator delete(Src[0]);
        }
        else
        {
          while ( *cFileName++ )
            ;
          sub_4094F0(Src, (int)FindFileData.cFileName, FindFileData.cFileName, cFileName - &FindFileData.cFileName[1]);
          LOBYTE(v105) = 12;
          v14 = sub_40A200((char *)v9, *((_DWORD *)v9 + 1), (int)Src);
          if ( v72 == 153391688 )
LABEL_94:
            std::_Xlength_error("list<T> too long");
          ++v72;
          *((_DWORD *)v9 + 1) = v14;
          **((_DWORD **)v14 + 1) = v14;
          LOBYTE(v105) = 8;
          if ( v100 >= 8 )
            operator delete(Src[0]);
          v75 += __PAIR64__(FindFileData.nFileSizeHigh, FindFileData.nFileSizeLow);
        }
      }
    }
    FindClose(hFindFile);
  }
  sub_40BE70(v56);
  LOBYTE(v105) = 13;
  v15 = (int *)sub_419640((struct std::locale::_Locimp **)&v79, (const char *)&unk_4C11EE);
  LOBYTE(v105) = 14;
  sub_418E70(v15, (int)v56 + *(_DWORD *)(v56[0] + 4), &hFindFile);
  v16 = hFindFile;
  if ( hFindFile )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v77, 0);
    v17 = v16[1];
    if ( v17 && v17 != -1 )
      v16[1] = v17 - 1;
    v18 = v16[1] == 0 ? (void (__thiscall ***)(_DWORD, int))v16 : 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v77);
    if ( v18 )
      (**v18)(v18, 1);
  }
  LOBYTE(v105) = 13;
  v19 = v79;
  if ( v79 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v77, 0);
    v20 = *((_DWORD *)v19 + 1);
    if ( v20 && v20 != -1 )
      *((_DWORD *)v19 + 1) = v20 - 1;
    v21 = *((_DWORD *)v19 + 1) == 0 ? (void (__thiscall ***)(_DWORD, int))v19 : 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v77);
    if ( v21 )
      (**v21)(v21, 1);
  }
  v22 = (char *)v56 + *(_DWORD *)(v56[0] + 4);
  *((_DWORD *)v22 + 6) = 0;
  *((_DWORD *)v22 + 7) = 0;
  sub_415F40((char *)L"Statistics\r\n----------\r\n", lpBuffer, 0x18u);
  *(_DWORD *)&v59[*(_DWORD *)(v57[0] + 4) + 8] = *(_DWORD *)&v59[*(_DWORD *)(v57[0] + 4) + 8] & 0xFFFFCFFF | 0x2000;
  sub_4197D0(v57, v74);
  v100 = 7;
  v99 = 0;
  LOWORD(Src[0]) = 0;
  sub_4094F0(Src, 0, L"\r\n", 2);
  LOBYTE(v105) = 15;
  v23 = sub_40BFB0((int)v56, v95);
  LOBYTE(v105) = 16;
  v24 = sub_40B1A0(L"Number of folders: ", v86, v23);
  LOBYTE(v105) = 17;
  v25 = sub_419A80(Src, v24, v92);
  LOBYTE(v105) = 18;
  sub_406A00(lpBuffer, v25, 0, 0xFFFFFFFF);
  if ( v94 >= 8 )
    operator delete(v92[0]);
  v94 = 7;
  v93 = 0;
  LOWORD(v92[0]) = 0;
  if ( v88 >= 8 )
    operator delete(v86[0]);
  v88 = 7;
  v87 = 0;
  LOWORD(v86[0]) = 0;
  if ( v97 >= 8 )
    operator delete(v95[0]);
  v26 = 0;
  LOBYTE(v105) = 13;
  v97 = 7;
  v96 = 0;
  LOWORD(v95[0]) = 0;
  if ( v100 >= 8 )
    operator delete(Src[0]);
  LOWORD(Src[0]) = 0;
  v100 = 7;
  v99 = 0;
  sub_4094F0(Src, v26, &unk_4C2D50, 0);
  LOBYTE(v105) = 19;
  sub_4027E0((int)&v58);
  v27 = (void **)Src[0];
  if ( v100 < 8 )
    v27 = Src;
  v67 = 0;
  if ( v99 )
    sub_403930(v99, (int)&v58, v27);
  LOBYTE(v105) = 13;
  if ( v100 >= 8 )
    operator delete(Src[0]);
  v28 = v72;
  *(_DWORD *)&v59[*(_DWORD *)(v57[0] + 4) + 8] = *(_DWORD *)&v59[*(_DWORD *)(v57[0] + 4) + 8] & 0xFFFFCFFF | 0x2000;
  sub_4197D0(v57, v28);
  LOWORD(Src[0]) = 0;
  v100 = 7;
  v99 = 0;
  sub_4094F0(Src, v29, L"\r\n", 2);
  LOBYTE(v105) = 20;
  v30 = sub_40BFB0((int)v56, v95);
  LOBYTE(v105) = 21;
  v31 = sub_40B1A0(L"Number of files: ", v86, v30);
  LOBYTE(v105) = 22;
  v32 = sub_419A80(Src, v31, v92);
  LOBYTE(v105) = 23;
  sub_406A00(lpBuffer, v32, 0, 0xFFFFFFFF);
  if ( v94 >= 8 )
    operator delete(v92[0]);
  v94 = 7;
  v93 = 0;
  LOWORD(v92[0]) = 0;
  if ( v88 >= 8 )
    operator delete(v86[0]);
  v88 = 7;
  v87 = 0;
  LOWORD(v86[0]) = 0;
  if ( v97 >= 8 )
    operator delete(v95[0]);
  LOBYTE(v105) = 13;
  v97 = 7;
  v96 = 0;
  LOWORD(v95[0]) = 0;
  if ( v100 >= 8 )
    operator delete(Src[0]);
  sub_46B2E0(0x20u, 0, 0, v75);
  v97 = 7;
  v96 = 0;
  LOWORD(v95[0]) = 0;
  sub_4094F0(v95, 0, L"\r\n", 2);
  LOBYTE(v105) = 24;
  LOWORD(Src[0]) = 0;
  v100 = 7;
  v99 = 0;
  sub_4094F0(Src, (int)&v104, &v103, wcslen(&v103));
  LOBYTE(v105) = 25;
  v33 = sub_40B1A0(L"Total size (not including subfolders): ", v86, Src);
  LOBYTE(v105) = 26;
  v34 = sub_419A80(v95, v33, v92);
  LOBYTE(v105) = 27;
  sub_406A00(lpBuffer, v34, 0, 0xFFFFFFFF);
  if ( v94 >= 8 )
    operator delete(v92[0]);
  v94 = 7;
  v93 = 0;
  LOWORD(v92[0]) = 0;
  if ( v88 >= 8 )
    operator delete(v86[0]);
  v88 = 7;
  v87 = 0;
  LOWORD(v86[0]) = 0;
  if ( v100 >= 8 )
    operator delete(Src[0]);
  LOBYTE(v105) = 13;
  v100 = 7;
  v99 = 0;
  LOWORD(Src[0]) = 0;
  if ( v97 >= 8 )
    operator delete(v95[0]);
  sub_415F40((char *)L"\r\nFolders\r\n-------\r\n", lpBuffer, 0x14u);
  for ( i = *(_DWORD **)v73; i != v73; i = (_DWORD *)*i )
  {
    LOWORD(v95[0]) = 0;
    v97 = 7;
    v96 = 0;
    sub_4090E0((int)v95, i + 2, 0, 0xFFFFFFFF);
    LOBYTE(v105) = 28;
    v36 = sub_418090(v92, (int)v95, (int)L"\r\n");
    LOBYTE(v105) = 29;
    sub_406A00(lpBuffer, v36, 0, 0xFFFFFFFF);
    if ( v94 >= 8 )
      operator delete(v92[0]);
    LOBYTE(v105) = 13;
    if ( v97 >= 8 )
      operator delete(v95[0]);
  }
  sub_415F40((char *)L"\r\nFiles\r\n-----\r\n", lpBuffer, 0x10u);
  for ( j = *(_DWORD **)v71; j != v71; j = (_DWORD *)*j )
  {
    LOWORD(v95[0]) = 0;
    v97 = 7;
    v96 = 0;
    sub_4090E0((int)v95, j + 2, 0, 0xFFFFFFFF);
    LOBYTE(v105) = 30;
    v38 = sub_418090(v92, (int)v95, (int)L"\r\n");
    LOBYTE(v105) = 31;
    sub_406A00(lpBuffer, v38, 0, 0xFFFFFFFF);
    if ( v94 >= 8 )
      operator delete(v92[0]);
    LOBYTE(v105) = 13;
    if ( v97 >= 8 )
      operator delete(v95[0]);
  }
  v39 = (LPCVOID *)sub_402000(0, (unsigned int)v90 - 2, (int)v92, lpBuffer);
  if ( lpBuffer != v39 )
  {
    if ( v91 >= 8 )
      operator delete((void *)lpBuffer[0]);
    v91 = 7;
    v90 = 0;
    LOWORD(lpBuffer[0]) = 0;
    if ( (unsigned int)v39[5] >= 8 )
    {
      lpBuffer[0] = *v39;
      *v39 = 0;
    }
    else
    {
      memcpy(lpBuffer, v39, 2 * (_DWORD)v39[4] + 2);
    }
    v90 = (HANDLE)v39[4];
    v91 = (unsigned int)v39[5];
    v39[5] = (LPCVOID)7;
    v39[4] = 0;
    *(_WORD *)v39 = 0;
  }
  if ( v94 >= 8 )
    operator delete(v92[0]);
  v40 = v78;
  if ( *((_DWORD *)v78 + 5) >= 8u )
    v40 = *(const WCHAR **)v78;
  FileW = CreateFileW(v40, 2u, 0, 0, 2u, 0x80u, 0);
  v42 = FileW;
  if ( FileW != (HANDLE)-1 )
  {
    WriteFile(FileW, &unk_4C2E38, 2u, (LPDWORD)&hFindFile, 0);
    v43 = (LPCVOID *)lpBuffer[0];
    if ( v91 < 8 )
      v43 = lpBuffer;
    WriteFile(v42, v43, 2 * (_DWORD)v90, (LPDWORD)&hFindFile, 0);
    if ( hFindFile == v90 )
    {
      v44 = *(_DWORD *)(v56[0] + 4);
      v77 = (void ***)v69;
      *(int *)((char *)v56 + v44) = (int)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
      v76 = &v58;
      v58 = &std::wstringbuf::`vftable';
      if ( (v68 & 1) != 0 )
        operator delete(*v60);
      *v60 = 0;
      *v62 = 0;
      *v64 = 0;
      *v61 = 0;
      *v63 = 0;
      *v65 = 0;
      v68 &= ~1u;
      v67 = 0;
      v58 = &std::wstreambuf::`vftable';
      LOBYTE(v105) = 34;
      v79 = v66;
      if ( v66 )
      {
        v45 = *(_DWORD *)v66;
        if ( *(_DWORD *)v66 )
        {
          std::_Lockit::_Lockit((std::_Lockit *)&v78, 0);
          v46 = *(_DWORD *)(v45 + 4);
          if ( v46 && v46 != -1 )
            *(_DWORD *)(v45 + 4) = v46 - 1;
          v47 = *(_DWORD *)(v45 + 4) == 0 ? (void (__thiscall ***)(_DWORD, int))v45 : 0;
          std::_Lockit::~_Lockit((std::_Lockit *)&v78);
          if ( v47 )
            (**v47)(v47, 1);
        }
        operator delete(v79);
      }
      LOBYTE(v105) = 33;
      std::_Mutex::~_Mutex((std::_Mutex *)v59);
      LOBYTE(v105) = 8;
      *(int *)((char *)v56 + *(_DWORD *)(v56[0] + 4)) = (int)&std::wiostream::`vftable';
      *(int *)((char *)v57 + *(_DWORD *)(v57[0] + 4)) = (int)&std::wostream::`vftable';
      *(int *)((char *)v56 + *(_DWORD *)(v56[0] + 4)) = (int)&std::wistream::`vftable';
      v69[0] = (int)&std::ios_base::`vftable';
      std::ios_base::_Ios_base_dtor((struct std::ios_base *)v69);
      sub_40A140((int)&v71);
      operator delete(v71);
      sub_40A140((int)&v73);
      operator delete(v73);
      if ( v85 >= 8 )
        operator delete((void *)lpFileName[0]);
      v85 = 7;
      v84 = 0;
      LOWORD(lpFileName[0]) = 0;
      if ( v91 >= 8 )
        operator delete((void *)lpBuffer[0]);
      return 1;
    }
    CloseHandle(v42);
  }
  v49 = *(_DWORD *)(v56[0] + 4);
  v76 = (void ***)v69;
  *(int *)((char *)v56 + v49) = (int)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
  v77 = &v58;
  v58 = &std::wstringbuf::`vftable';
  if ( (v68 & 1) != 0 )
    operator delete(*v60);
  *v60 = 0;
  *v62 = 0;
  *v64 = 0;
  *v61 = 0;
  *v63 = 0;
  *v65 = 0;
  v68 &= ~1u;
  v67 = 0;
  v58 = &std::wstreambuf::`vftable';
  LOBYTE(v105) = 36;
  v78 = (LPCWSTR)v66;
  if ( v66 )
  {
    v50 = *(_DWORD *)v66;
    if ( *(_DWORD *)v66 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v79, 0);
      v51 = *(_DWORD *)(v50 + 4);
      if ( v51 && v51 != -1 )
        *(_DWORD *)(v50 + 4) = v51 - 1;
      v52 = *(_DWORD *)(v50 + 4) == 0 ? (void (__thiscall ***)(_DWORD, int))v50 : 0;
      std::_Lockit::~_Lockit((std::_Lockit *)&v79);
      if ( v52 )
        (**v52)(v52, 1);
    }
    operator delete((void *)v78);
  }
  LOBYTE(v105) = 35;
  std::_Mutex::~_Mutex((std::_Mutex *)v59);
  LOBYTE(v105) = 8;
  *(int *)((char *)v56 + *(_DWORD *)(v56[0] + 4)) = (int)&std::wiostream::`vftable';
  *(int *)((char *)v57 + *(_DWORD *)(v57[0] + 4)) = (int)&std::wostream::`vftable';
  *(int *)((char *)v56 + *(_DWORD *)(v56[0] + 4)) = (int)&std::wistream::`vftable';
  v69[0] = (int)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v69);
  sub_40A140((int)&v71);
  operator delete(v71);
  sub_40A140((int)&v73);
  operator delete(v73);
  if ( v85 >= 8 )
    operator delete((void *)lpFileName[0]);
  v85 = 7;
  v84 = 0;
  LOWORD(lpFileName[0]) = 0;
  if ( v91 >= 8 )
    operator delete((void *)lpBuffer[0]);
  return 0;
}
// 4AE8FF: variable 'v1' is possibly undefined
// 4AF070: variable 'v26' is possibly undefined
// 4AF12E: variable 'v29' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4C2C68: using guessed type wchar_t asc_4C2C68[5];
// 4C2CA4: using guessed type wchar_t asc_4C2CA4[5];
// 4C2CB0: using guessed type wchar_t aDate[13];
// 4C2CCC: using guessed type wchar_t asc_4C2CCC[3];
// 4C2CEC: using guessed type wchar_t aStatistics[25];
// 4C2D20: using guessed type wchar_t asc_4C2D20[3];
// 4C2D28: using guessed type wchar_t aNumberOfFolder[20];
// 4C2D54: using guessed type wchar_t asc_4C2D54[3];
// 4C2D5C: using guessed type wchar_t aNumberOfFiles[18];
// 4C2D80: using guessed type wchar_t asc_4C2D80[3];
// 4C2D88: using guessed type wchar_t aTotalSizeNotIn[40];
// 4C2DD8: using guessed type wchar_t aFolders_2[21];
// 4C2E04: using guessed type wchar_t asc_4C2E04[3];
// 4C2E0C: using guessed type wchar_t aFiles[17];
// 4C2E30: using guessed type wchar_t asc_4C2E30[3];
// 4CB96C: using guessed type void *std::wstringbuf::`vftable';
// 4CBACC: using guessed type void *std::ios_base::`vftable';
// 4CBADC: using guessed type void *std::wstreambuf::`vftable';
// 4CBB1C: using guessed type void *std::wistream::`vftable';
// 4CBF44: using guessed type void *std::wiostream::`vftable';
// 4CBF4C: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 4CC00C: using guessed type void *std::wostream::`vftable';

//----- (004AFAF0) --------------------------------------------------------
_WORD *__usercall sub_4AFAF0@<eax>(_DWORD *a1@<eax>)
{
  _WORD *result; // eax
  int v2; // edx
  int v3; // esi
  __int16 v4; // cx

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = a1 + 3;
  v2 = 260;
  v3 = &unk_4CB0F8 - (_UNKNOWN *)result;
  while ( v2 != -2147483386 )
  {
    v4 = *(_WORD *)((char *)result + v3);
    if ( !v4 )
      break;
    *result++ = v4;
    if ( !--v2 )
    {
      *(result - 1) = 0;
      return result;
    }
  }
  *result = 0;
  return result;
}
// 4AFB38: conditional instruction was optimized away because edx.4!=0

//----- (004AFB50) --------------------------------------------------------
HWND __usercall sub_4AFB50@<eax>(_DWORD *a1@<esi>)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  HMODULE ModuleHandleW; // eax
  HANDLE ImageW; // eax
  HWND v6; // ebx
  HMODULE v7; // eax
  HWND result; // eax
  int Param[5]; // [esp+Ch] [ebp-14h] BYREF

  v1 = a1[1415];
  v2 = a1[1416];
  Param[0] = a1[1414];
  v3 = a1[1417];
  Param[1] = v1;
  Param[2] = v2;
  Param[3] = v3;
  ModuleHandleW = GetModuleHandleW(0);
  ImageW = LoadImageW(ModuleHandleW, (LPCWSTR)0x6A, 1u, 0, 0, 0x2000u);
  v6 = (HWND)a1[13];
  Param[4] = (int)ImageW;
  sub_41A510();
  v7 = GetModuleHandleW(0);
  result = sub_418180(L"DisplayWindow", &word_4CC4F8, 0x54000000u, 0, 0, 0, 0, v6, v7, Param);
  a1[329] = 0;
  a1[16] = result;
  return result;
}

//----- (004AFBE0) --------------------------------------------------------
void __usercall sub_4AFBE0(int a1@<edi>)
{
  HMENU Menu; // esi
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  int v4; // eax
  UINT v5; // eax
  int v6; // ebx
  int MenuItemCount; // eax
  HMODULE ModuleHandleW; // eax
  _DWORD *dwItemData; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  _DWORD *v25; // eax
  _DWORD *v26; // eax
  _DWORD *v27; // eax
  _DWORD *v28; // eax
  _DWORD *v29; // eax
  _DWORD *v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  _DWORD *v33; // eax
  int v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  int v37; // eax
  int v38; // eax
  _DWORD *v39; // eax
  _DWORD *v40; // eax
  int v41; // eax
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  HMENU v44; // ebx
  int v45; // eax
  HMENU v46; // ebx
  int v47; // eax
  _DWORD *v48; // eax
  HIMAGELIST v49; // edx
  HMENU v50; // esi
  int v51; // eax
  HMENU v52; // esi
  int v53; // eax
  HMENU v54; // [esp-10h] [ebp-108h]
  HMENU v55; // [esp-10h] [ebp-108h]
  HMENU v56; // [esp-10h] [ebp-108h]
  HMENU v57; // [esp-10h] [ebp-108h]
  HMENU v58; // [esp-10h] [ebp-108h]
  HMENU v59; // [esp-10h] [ebp-108h]
  MENUITEMINFOW mi; // [esp+8h] [ebp-F0h] BYREF
  HGDIOBJ ho; // [esp+38h] [ebp-C0h]
  HMENU hmenu; // [esp+3Ch] [ebp-BCh]
  struct tagMENUITEMINFOW mii; // [esp+40h] [ebp-B8h] BYREF
  WCHAR Buffer[66]; // [esp+70h] [ebp-88h] BYREF

  Menu = GetMenu(*(HWND *)(a1 + 52));
  v2 = *(_DWORD **)(a1 + 5640);
  v3 = (_DWORD *)*v2;
  if ( (_DWORD *)*v2 != v2 )
  {
    do
    {
      v4 = sub_48EAA0(v3[2], a1);
      LoadStringW(hInstance, v4, Buffer, 64);
      mi.cbSize = 48;
      mi.fMask = 66;
      switch ( v3[2] )
      {
        case 1:
          v5 = 60002;
          break;
        case 2:
          v5 = 60003;
          break;
        case 3:
          v5 = 60004;
          break;
        case 4:
          v5 = 60005;
          break;
        case 5:
          v5 = 60001;
          break;
        case 6:
          v5 = 60000;
          break;
        case 7:
          v5 = 60008;
          break;
        case 8:
          v5 = 60007;
          break;
        default:
          v5 = -1;
          break;
      }
      mi.wID = v5;
      mi.dwTypeData = Buffer;
      InsertMenuItemW(Menu, 0x9DD8u, 0, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 3488), 0x9DD8u, 0, &mi);
      v3 = (_DWORD *)*v3;
    }
    while ( v3 != *(_DWORD **)(a1 + 5640) );
  }
  DeleteMenu(Menu, 0x9DD8u, 0);
  DeleteMenu(*(HMENU *)(a1 + 3488), 0x9DD8u, 0);
  v6 = 0;
  hmenu = (HMENU)GetMenuItemCount(Menu);
  if ( (int)hmenu > 0 )
  {
    do
    {
      ho = GetSubMenu(Menu, v6);
      MenuItemCount = GetMenuItemCount((HMENU)ho);
      sub_48FCC0((HMENU)ho, MenuItemCount);
      ++v6;
    }
    while ( v6 < (int)hmenu );
  }
  himl = (HIMAGELIST)sub_4018B0(16, 16, 33, 0, 0x30u);
  ModuleHandleW = GetModuleHandleW(0);
  ho = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0((int)himl, (int)ho, 0);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C78u, 0, &mii) )
  {
    dwItemData = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *dwItemData = 15;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C7Bu, 0, &mii) )
  {
    v10 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v10 = 18;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C7Fu, 0, &mii) )
  {
    v11 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v11 = 5;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9CD1u, 0, &mii) )
  {
    v12 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v12 = 31;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C80u, 0, &mii) )
  {
    v13 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v13 = 24;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C81u, 0, &mii) )
  {
    v14 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v14 = 6;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9D85u, 0, &mii) )
  {
    v15 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v15 = 27;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C85u, 0, &mii) )
  {
    v16 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v16 = 3;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C83u, 0, &mii) )
  {
    v17 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v17 = 2;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C86u, 0, &mii) )
  {
    v18 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v18 = 4;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C87u, 0, &mii) )
  {
    v19 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v19 = 30;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C88u, 0, &mii) )
  {
    v20 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v20 = 11;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C89u, 0, &mii) )
  {
    v21 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v21 = 10;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9D47u, 0, &mii) )
  {
    v22 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v22 = 9;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9CA9u, 0, &mii) )
  {
    v23 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v23 = 12;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9D26u, 0, &mii) )
  {
    v24 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v24 = 26;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C9Du, 0, &mii) )
  {
    v25 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v25 = 0;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C9Eu, 0, &mii) )
  {
    v26 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v26 = 1;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9C9Fu, 0, &mii) )
  {
    v27 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v27 = 8;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9CEEu, 0, &mii) )
  {
    v28 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v28 = 19;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9D05u, 0, &mii) )
  {
    v29 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v29 = 20;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9DE1u, 0, &mii) )
  {
    v30 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v30 = 17;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9DDBu, 0, &mii) )
  {
    v31 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v31 = 23;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9CA5u, 0, &mii) )
  {
    v32 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v32 = 25;
  }
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(Menu, 0x9CA6u, 0, &mii) )
  {
    v33 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v33 = 16;
  }
  hmenu = *(HMENU *)(a1 + 3468);
  v34 = GetMenuItemCount(hmenu);
  sub_48FCC0(hmenu, v34);
  v54 = *(HMENU *)(a1 + 3468);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v54, 0x9C78u, 0, &mii) )
  {
    v35 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v35 = 15;
  }
  v55 = *(HMENU *)(a1 + 3468);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v55, 0x9D3Au, 0, &mii) )
  {
    v36 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v36 = 12;
  }
  hmenu = *(HMENU *)(a1 + 3472);
  v37 = GetMenuItemCount(hmenu);
  sub_48FCC0(hmenu, v37);
  hmenu = *(HMENU *)(a1 + 3476);
  v38 = GetMenuItemCount(hmenu);
  sub_48FCC0(hmenu, v38);
  v56 = *(HMENU *)(a1 + 3476);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v56, 0x9D94u, 0, &mii) )
  {
    v39 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v39 = 5;
  }
  v57 = *(HMENU *)(a1 + 3476);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v57, 0x9D95u, 0, &mii) )
  {
    v40 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v40 = 6;
  }
  hmenu = *(HMENU *)(a1 + 3480);
  v41 = GetMenuItemCount(hmenu);
  sub_48FCC0(hmenu, v41);
  v58 = *(HMENU *)(a1 + 3480);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v58, 0x9DA9u, 0, &mii) )
  {
    v42 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v42 = 5;
  }
  v59 = *(HMENU *)(a1 + 3480);
  mii.cbSize = 48;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v59, 0x9DAAu, 0, &mii) )
  {
    v43 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v43 = 6;
  }
  v44 = *(HMENU *)(a1 + 3484);
  v45 = GetMenuItemCount(v44);
  sub_48FCC0(v44, v45);
  v46 = *(HMENU *)(a1 + 3488);
  v47 = GetMenuItemCount(v46);
  sub_48FCC0(v46, v47);
  v48 = operator new(0xCu);
  if ( v48 )
  {
    v49 = himl;
    *v48 = *(_DWORD *)(a1 + 52);
    v48[1] = Menu;
    v48[2] = v49;
  }
  else
  {
    v48 = 0;
  }
  *(_DWORD *)(a1 + 3412) = v48;
  sub_48EE00(17, 0x9CA0u, Menu);
  sub_48EE00(5, 0x9CA1u, Menu);
  sub_48EE00(13, 0x9CA2u, Menu);
  sub_48EE00(39, 0x9CA3u, Menu);
  sub_48EE00(0, 0x9CD3u, Menu);
  sub_48EE00(10, 0x9D0Eu, Menu);
  sub_48EE00(3, 0x9D11u, Menu);
  sub_48EE00(4, 0x9D12u, Menu);
  sub_48EE00(59, 0x9D14u, Menu);
  sub_48EE00(18, 0x9D17u, Menu);
  sub_48EE00(49, 0x9D28u, Menu);
  DeleteObject(ho);
  v50 = *(HMENU *)(a1 + 3448);
  v51 = GetMenuItemCount(v50);
  sub_48FCC0(v50, v51);
  v52 = *(HMENU *)(a1 + 3452);
  v53 = GetMenuItemCount(v52);
  sub_48FCC0(v52, v53);
}

//----- (004B06D0) --------------------------------------------------------
void __thiscall sub_4B06D0(_DWORD *this)
{
  void *v2[5]; // [esp+14h] [ebp-D8h] BYREF
  unsigned int v3; // [esp+28h] [ebp-C4h]
  void *v4; // [esp+30h] [ebp-BCh]
  int v5; // [esp+40h] [ebp-ACh]
  unsigned int v6; // [esp+44h] [ebp-A8h]
  int v7; // [esp+4Ch] [ebp-A0h]
  int v8; // [esp+50h] [ebp-9Ch]
  WCHAR Buffer[66]; // [esp+54h] [ebp-98h] BYREF
  int v10; // [esp+E8h] [ebp-4h]

  v3 = 7;
  v2[4] = 0;
  LOWORD(v2[0]) = 0;
  v6 = 7;
  v5 = 0;
  LOWORD(v4) = 0;
  v10 = 0;
  LoadStringW(hInstance, 0x86Bu, Buffer, 64);
  sub_4094F0(v2, (int)Buffer, Buffer, wcslen(Buffer));
  v8 = 16711680;
  v7 = 2048;
  sub_409970(v2, this + 9);
  LoadStringW(hInstance, 0x86Cu, Buffer, 64);
  sub_4094F0(v2, (int)Buffer, Buffer, wcslen(Buffer));
  v8 = 0x8000;
  v7 = 0x4000;
  sub_409970(v2, this + 9);
  if ( v6 >= 8 )
    operator delete(v4);
  v6 = 7;
  v5 = 0;
  LOWORD(v4) = 0;
  if ( v3 >= 8 )
    operator delete(v2[0]);
}

//----- (004B08A0) --------------------------------------------------------
BOOL __userpurge sub_4B08A0@<eax>(HWND a1@<esi>, HWND *a2)
{
  HWND DlgItem; // ebx
  HWND v3; // edi
  int v4; // ecx
  HWND v5; // eax
  LPARAM lParam[128]; // [esp+Ch] [ebp-830h] BYREF
  int v8[256]; // [esp+20Ch] [ebp-630h] BYREF
  int v9; // [esp+60Ch] [ebp-230h]
  int v10; // [esp+610h] [ebp-22Ch]
  int v11; // [esp+81Ch] [ebp-20h]
  LPARAM v12[2]; // [esp+824h] [ebp-18h] BYREF
  __int16 v13; // [esp+82Ch] [ebp-10h]
  int v14; // [esp+830h] [ebp-Ch]
  LPARAM *v15; // [esp+834h] [ebp-8h]

  DlgItem = GetDlgItem(a1, 1177);
  v3 = GetDlgItem(a1, 1178);
  SendMessageW(DlgItem, 0xDu, 0x100u, (LPARAM)lParam);
  SendMessageW(v3, 0xDu, 0x200u, (LPARAM)v8);
  v9 = IsDlgButtonChecked(a1, 1182) == 1;
  sub_465C50(lParam, dword_4EF144);
  if ( v9 != dword_4EF140 )
  {
    if ( v9 )
    {
      v12[1] = sub_4A6570(v4, (int)a2);
      v14 = v11;
      v5 = a2[126];
      v12[0] = v10 != 0 ? 20 : 15;
      v13 = 28676;
      v15 = lParam;
      SendMessageW(v5, 0x444u, 1u, (LPARAM)v12);
      sub_467F60(a2[15], a2[126]);
    }
    else
    {
      sub_4A6420(a2, v11);
    }
  }
  return EndDialog(a1, 1);
}
// 4B0943: variable 'v4' is possibly undefined
// 4EF140: using guessed type int dword_4EF140;
// 4EF144: using guessed type int dword_4EF144;
// 4B08A0: using guessed type LPARAM var_630[256];

//----- (004B09D0) --------------------------------------------------------
BOOL __userpurge sub_4B09D0@<eax>(HWND a1@<esi>, HWND *a2)
{
  HWND DlgItem; // ebx
  HWND v3; // edi
  int v4; // ecx
  int v5; // eax
  HWND v6; // edx
  HWND hWnd; // [esp+Ch] [ebp-838h]
  LPARAM lParam[128]; // [esp+14h] [ebp-830h] BYREF
  int v10[256]; // [esp+214h] [ebp-630h] BYREF
  int v11; // [esp+614h] [ebp-230h]
  int v12; // [esp+618h] [ebp-22Ch]
  int v13[130]; // [esp+61Ch] [ebp-228h] BYREF
  int v14; // [esp+824h] [ebp-20h]
  LPARAM v15[2]; // [esp+82Ch] [ebp-18h] BYREF
  __int16 v16; // [esp+834h] [ebp-10h]
  int v17; // [esp+838h] [ebp-Ch]
  LPARAM *v18; // [esp+83Ch] [ebp-8h]

  DlgItem = GetDlgItem(a1, 1131);
  hWnd = GetDlgItem(a1, 1132);
  v3 = GetDlgItem(a1, 1133);
  SendMessageW(DlgItem, 0xDu, 0x100u, (LPARAM)lParam);
  SendMessageW(hWnd, 0xDu, 0x104u, (LPARAM)v13);
  SendMessageW(v3, 0xDu, 0x200u, (LPARAM)v10);
  v11 = IsDlgButtonChecked(a1, 1181) == 1;
  sub_465C50(lParam, dword_4EF144);
  if ( v11 == dword_4EF140 )
  {
    if ( v11 )
      sub_4A6620((int)a2, (LPARAM)lParam);
  }
  else if ( v11 )
  {
    v5 = sub_4A6570(v4, (int)a2);
    v15[0] = v12 != 0 ? 20 : 15;
    v17 = v14;
    v6 = a2[126];
    v15[1] = v5;
    v16 = 28676;
    v18 = lParam;
    SendMessageW(v6, 0x444u, 1u, (LPARAM)v15);
    sub_467F60(a2[15], a2[126]);
  }
  else
  {
    sub_4A6420(a2, v14);
  }
  return EndDialog(a1, 1);
}
// 4B0A98: variable 'v4' is possibly undefined
// 4EF140: using guessed type int dword_4EF140;
// 4EF144: using guessed type int dword_4EF144;
// 4B09D0: using guessed type LPARAM var_228[130];
// 4B09D0: using guessed type LPARAM var_630[256];

//----- (004B0B40) --------------------------------------------------------
LRESULT __userpurge sub_4B0B40@<eax>(HWND a1@<esi>, int a2)
{
  HWND DlgItem; // edi
  HWND v3; // ebx
  WCHAR String[256]; // [esp+8h] [ebp-818h] BYREF
  __int16 v6[512]; // [esp+208h] [ebp-618h] BYREF
  int v7; // [esp+608h] [ebp-218h]
  int v8; // [esp+818h] [ebp-8h]

  sub_465D30(*(_DWORD *)(a2 + 4), String);
  dword_4EF144 = v8;
  dword_4EF140 = v7;
  DlgItem = GetDlgItem(a1, 1177);
  v3 = GetDlgItem(a1, 1178);
  SetWindowTextW(DlgItem, String);
  SetWindowTextW(v3, (LPCWSTR)v6);
  if ( v7 )
    CheckDlgButton(a1, 1182, 1u);
  SetFocus(DlgItem);
  return SendMessageW(DlgItem, 0xB1u, 0, -1);
}
// 4EF140: using guessed type int dword_4EF140;
// 4EF144: using guessed type int dword_4EF144;
// 4B0B40: using guessed type WCHAR var_618[512];

//----- (004B0C50) --------------------------------------------------------
int __stdcall sub_4B0C50(HWND hDlg, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4EF7BC = *(_DWORD *)a4;
  switch ( a2 )
  {
    case 16:
      EndDialog(hDlg, 0);
      break;
    case 272:
      sub_4B0B40(hDlg, a4);
      return 0;
    case 273:
      if ( a3 == 1 )
      {
        sub_4B08A0(hDlg, (HWND *)dword_4EF7BC);
        return 0;
      }
      if ( a3 == 2 )
      {
        EndDialog(hDlg, 0);
        return 0;
      }
      break;
  }
  return 0;
}
// 4EF7BC: using guessed type int dword_4EF7BC;

//----- (004B0CE0) --------------------------------------------------------
LRESULT __userpurge sub_4B0CE0@<eax>(HWND a1@<esi>, int a2)
{
  HWND DlgItem; // ebx
  HWND hWnd; // [esp+8h] [ebp-820h]
  HWND v5; // [esp+Ch] [ebp-81Ch]
  WCHAR String[256]; // [esp+10h] [ebp-818h] BYREF
  __int16 v7[512]; // [esp+210h] [ebp-618h] BYREF
  int v8; // [esp+610h] [ebp-218h]
  __int16 v9[260]; // [esp+618h] [ebp-210h] BYREF
  int v10; // [esp+820h] [ebp-8h]

  sub_465D30(*(_DWORD *)(a2 + 4), String);
  dword_4EF144 = v10;
  dword_4EF140 = v8;
  DlgItem = GetDlgItem(a1, 1131);
  hWnd = GetDlgItem(a1, 1132);
  v5 = GetDlgItem(a1, 1133);
  SetWindowTextW(DlgItem, String);
  SetWindowTextW(hWnd, (LPCWSTR)v9);
  SetWindowTextW(v5, (LPCWSTR)v7);
  if ( v8 )
    CheckDlgButton(a1, 1181, 1u);
  SetFocus(DlgItem);
  return SendMessageW(DlgItem, 0xB1u, 0, -1);
}
// 4EF140: using guessed type int dword_4EF140;
// 4EF144: using guessed type int dword_4EF144;
// 4B0CE0: using guessed type WCHAR var_210[260];
// 4B0CE0: using guessed type WCHAR var_618[512];

//----- (004B0E20) --------------------------------------------------------
int __stdcall sub_4B0E20(HWND hDlg, int a2, __int16 a3, int a4)
{
  if ( a2 == 272 )
    dword_4EF7B8 = *(_DWORD *)a4;
  switch ( a2 )
  {
    case 16:
      EndDialog(hDlg, 0);
      break;
    case 272:
      sub_4B0CE0(hDlg, a4);
      return 0;
    case 273:
      if ( a3 == 1 )
      {
        sub_4B09D0(hDlg, (HWND *)dword_4EF7B8);
        return 0;
      }
      if ( a3 == 2 )
      {
        EndDialog(hDlg, 0);
        return 0;
      }
      break;
  }
  return 0;
}
// 4EF7B8: using guessed type int dword_4EF7B8;

//----- (004B0EB0) --------------------------------------------------------
void __usercall sub_4B0EB0(int a1@<esi>)
{
  LPVOID pv; // [esp+Ch] [ebp-624h] BYREF
  __int16 v2[260]; // [esp+10h] [ebp-620h] BYREF
  __int16 lParam[260]; // [esp+218h] [ebp-418h] BYREF
  char v4[524]; // [esp+420h] [ebp-210h] BYREF

  SendMessageW(*(HWND *)(a1 + 84), 0xDu, 0x104u, (LPARAM)lParam);
  (*(void (__thiscall **)(_DWORD, int, char *))(**(_DWORD **)(a1 + 1320) + 52))(*(_DWORD *)(a1 + 1320), 260, v4);
  sub_467360((LPCWSTR)lParam, (int)v4, (WCHAR *)v2);
  pv = 0;
  if ( sub_467810((LPITEMIDLIST *)&pv, (int)v2) >= 0 )
  {
    (*(void (__thiscall **)(int, LPVOID, _DWORD, _DWORD))(*(_DWORD *)(a1 + 28) + 32))(a1 + 28, pv, 0, 0);
    CoTaskMemFree(pv);
  }
}
// 4B0EB0: using guessed type WCHAR lParam[260];
// 4B0EB0: using guessed type WCHAR var_620[260];

//----- (004B0F60) --------------------------------------------------------
int __cdecl sub_4B0F60(int a1, int *a2, int *a3, _DWORD *a4)
{
  int v4; // edi
  int v5; // ebx
  __int16 *v6; // eax
  int v7; // edx
  __int16 v8; // cx
  int v9; // edx
  __int16 *v10; // eax
  HANDLE FirstFileW; // esi
  WCHAR *v12; // eax
  int v13; // edi
  int v14; // edx
  WCHAR v15; // cx
  DWORD nFileSizeLow; // eax
  DWORD nFileSizeHigh; // ecx
  int v18; // edx
  int v19; // ecx
  HANDLE v21; // [esp+14h] [ebp-69Ch]
  DWORD v22; // [esp+20h] [ebp-690h] BYREF
  DWORD v23; // [esp+24h] [ebp-68Ch]
  int v24; // [esp+28h] [ebp-688h] BYREF
  int v25; // [esp+2Ch] [ebp-684h] BYREF
  __int64 v26; // [esp+30h] [ebp-680h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+38h] [ebp-678h] BYREF
  WCHAR pszPath[264]; // [esp+288h] [ebp-428h] BYREF
  __int16 FileName[266]; // [esp+498h] [ebp-218h] BYREF

  v4 = 0;
  v5 = 0;
  v24 = 0;
  v25 = 0;
  if ( !a1 || !a2 || !a3 || !a4 )
    return -2147024809;
  v6 = FileName;
  v26 = 0i64;
  v22 = 0;
  v23 = 0;
  v7 = 262;
  while ( v7 != -2147483384 )
  {
    v8 = *(__int16 *)((char *)v6 + a1 - (_DWORD)FileName);
    if ( !v8 )
      break;
    *v6++ = v8;
    if ( !--v7 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  v9 = 262;
  v10 = FileName;
  while ( *v10 )
  {
    ++v10;
    if ( !--v9 )
      goto LABEL_15;
  }
  sub_4AA520(v9, (int)L"\\*", &FileName[262 - v9]);
LABEL_15:
  FirstFileW = FindFirstFileW((LPCWSTR)FileName, &FindFileData);
  v21 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1 )
  {
    if ( StrCmpW(FindFileData.cFileName, L".") )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        v4 = 1;
      else
        v5 = 1;
    }
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( StrCmpW(FindFileData.cFileName, L"..") )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          v12 = pszPath;
          v13 = v4 + 1;
          v14 = 262;
          while ( v14 != -2147483384 )
          {
            v15 = *(WCHAR *)((char *)v12 + a1 - (_DWORD)pszPath);
            if ( !v15 )
              break;
            *v12++ = v15;
            if ( !--v14 )
            {
              --v12;
              break;
            }
          }
          *v12 = 0;
          PathAppendW(pszPath, FindFileData.cFileName);
          sub_4B0F60((int)pszPath, &v25, &v24, &v22);
          v4 = v25 + v13;
          nFileSizeLow = v22;
          nFileSizeHigh = v23;
          FirstFileW = v21;
          v5 += v24;
        }
        else
        {
          nFileSizeLow = FindFileData.nFileSizeLow;
          nFileSizeHigh = FindFileData.nFileSizeHigh;
          ++v5;
        }
        v26 += __PAIR64__(nFileSizeHigh, nFileSizeLow);
      }
    }
    v18 = v26;
    *a2 = v4;
    *a3 = v5;
    v19 = HIDWORD(v26);
    *a4 = v18;
    a4[1] = v19;
    FindClose(FirstFileW);
  }
  return 0;
}
// 4B1010: conditional instruction was optimized away because edx.4!=0
// 4B1034: conditional instruction was optimized away because edx.4!=0
// 4B1120: conditional instruction was optimized away because edx.4!=0
// 4C2900: using guessed type wchar_t asc_4C2900[3];
// 4B0F60: using guessed type WCHAR FileName[266];

//----- (004B1210) --------------------------------------------------------
DWORD __stdcall sub_4B1210(LPVOID lpThreadParameter)
{
  int v2[2]; // [esp+8h] [ebp-8h] BYREF

  if ( !lpThreadParameter )
    return 0;
  sub_4B0F60((int)lpThreadParameter, &dword_4F2214, &dword_4F2218, v2);
  (*((void (__cdecl **)(int, int, int *, _DWORD))lpThreadParameter + 131))(
    dword_4F2214,
    dword_4F2218,
    v2,
    *((_DWORD *)lpThreadParameter + 130));
  free(lpThreadParameter);
  return 1;
}
// 4F2214: using guessed type int dword_4F2214;
// 4F2218: using guessed type int dword_4F2218;
// 4B1210: using guessed type _DWORD var_8[2];

//----- (004B1280) --------------------------------------------------------
BOOL __usercall sub_4B1280@<eax>(HWND a1@<edi>)
{
  HWND DlgItem; // ebx
  HWND v2; // esi
  char *v3; // eax
  int v4; // esi
  __int16 v5; // cx
  char *v6; // eax
  int v7; // edx
  __int16 v8; // cx
  int v9; // esi
  LPARAM v11[9]; // [esp+8h] [ebp-A3Ch] BYREF
  char v12[512]; // [esp+2Ch] [ebp-A18h] BYREF
  char v13[1024]; // [esp+22Ch] [ebp-818h] BYREF
  int v14; // [esp+62Ch] [ebp-418h]
  int v15; // [esp+630h] [ebp-414h]
  int lParam[128]; // [esp+840h] [ebp-204h] BYREF

  DlgItem = GetDlgItem(a1, 1170);
  v2 = GetDlgItem(a1, 1058);
  SendMessageW(DlgItem, 0xDu, 0x100u, (LPARAM)lParam);
  v11[1] = SendMessageW(v2, 0x147u, 0, 0);
  v11[0] = 32;
  SendMessageW(v2, 0x40Du, 0, (LPARAM)v11);
  v3 = v12;
  v4 = 256;
  while ( v4 != -2147483390 )
  {
    v5 = *((_WORD *)v3 + 1034);
    if ( !v5 )
      break;
    *(_WORD *)v3 = v5;
    v3 += 2;
    if ( !--v4 )
    {
      v3 -= 2;
      break;
    }
  }
  *(_WORD *)v3 = 0;
  v6 = v13;
  v7 = 512;
  while ( v7 != -2147483134 )
  {
    v8 = *(_WORD *)&v6[&unk_4CA4A0 - (_UNKNOWN *)v13];
    if ( !v8 )
      break;
    *(_WORD *)v6 = v8;
    v6 += 2;
    if ( !--v7 )
    {
      v6 -= 2;
      break;
    }
  }
  v9 = v11[8];
  *(_WORD *)v6 = 0;
  v15 = 0;
  v14 = 0;
  sub_4660F0(v12, v9);
  return EndDialog(a1, 1);
}
// 4B1330: conditional instruction was optimized away because esi.4!=0
// 4B1370: conditional instruction was optimized away because edx.4!=0
// 4B1280: using guessed type LPARAM lParam[128];

//----- (004B13B0) --------------------------------------------------------
HWND __thiscall sub_4B13B0(HWND hDlg, int a2)
{
  HWND DlgItem; // esi
  int v4; // edi
  HMODULE ModuleHandleW; // eax
  HBITMAP BitmapW; // ebx
  HWND hWnd; // [esp+Ch] [ebp-828h]
  int v9[519]; // [esp+14h] [ebp-820h] BYREF

  DlgItem = GetDlgItem(hDlg, 1170);
  hWnd = GetDlgItem(hDlg, 1058);
  SetWindowTextW(DlgItem, L"New Folder");
  v4 = sub_4018B0(16, 16, 33, 0, 1u);
  ModuleHandleW = GetModuleHandleW(0);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_4011E0(v4, (int)BitmapW, 0);
  DeleteObject(BitmapW);
  SendMessageW(hWnd, 0x402u, 0, v4);
  sub_466000(a2 + 1332, v9);
  sub_4A6820((void *)a2, hWnd, (int)v9, 0, 0);
  SendMessageW(hWnd, 0x14Eu, dword_4EF138, 0);
  SendMessageW(DlgItem, 0xB1u, 0, -1);
  return SetFocus(DlgItem);
}

//----- (004B1510) --------------------------------------------------------
int __stdcall sub_4B1510(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 == 272 )
    dword_4EF804 = a4;
  switch ( a2 )
  {
    case 0x10u:
      EndDialog(hDlg, 0);
      break;
    case 0x110u:
      sub_4B13B0(hDlg, dword_4EF804);
      return 0;
    case 0x111u:
      if ( (unsigned __int16)a3 == 1 )
      {
        sub_4B1280(hDlg);
        return 0;
      }
      if ( (unsigned __int16)a3 == 2 )
      {
        EndDialog(hDlg, 0);
        return 0;
      }
      break;
  }
  return 0;
}

//----- (004B1590) --------------------------------------------------------
void __fastcall sub_4B1590(int nPos, HMENU hMenu, int a3)
{
  UINT MenuItemID; // eax
  HRESULT v5; // esi
  LPVOID pv; // [esp+14h] [ebp-218h] BYREF
  __int16 v7[262]; // [esp+18h] [ebp-214h] BYREF

  MenuItemID = GetMenuItemID(hMenu, nPos);
  if ( MenuItemID - 10000 <= 0x3E8 )
  {
    sub_4A71D0(MenuItemID, v7, hMenu);
    pv = 0;
    v5 = sub_467810((LPITEMIDLIST *)&pv, (int)v7);
    (*(void (__thiscall **)(int, LPVOID, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(a3 + 28) + 40))(
      a3 + 28,
      pv,
      0,
      0,
      0,
      0);
    if ( v5 >= 0 )
      CoTaskMemFree(pv);
  }
}
// 4B1590: using guessed type _WORD var_214[262];

//----- (004B1640) --------------------------------------------------------
int __fastcall sub_4B1640(DWORD a1, int *a2)
{
  unsigned int v2; // eax
  _DWORD *v3; // edi
  int result; // eax
  HWND v6; // ebx
  int v7; // edx
  signed int v8; // esi
  int v9; // edx
  LPARAM *v10; // eax
  int v11; // esi
  __int16 v12; // cx
  int v13; // ecx
  HMENU Menu; // esi
  UINT v15; // eax
  WPARAM v16; // eax
  HMENU v17; // eax
  _DWORD *v18; // edi
  int v19; // eax
  int MenuItemCount; // eax
  UINT v21; // esi
  HMENU v22; // edi
  LONG v23; // edx
  HMENU v24; // ebx
  BOOL v25; // eax
  int v26; // eax
  signed int v27; // ebx
  int v28; // eax
  ITEMIDLIST *v29; // esi
  int v30; // ecx
  char v31; // al
  int v32; // ecx
  HMENU v33; // [esp-10h] [ebp-1918h]
  HMENU v34; // [esp-Ch] [ebp-1914h]
  UINT *v35; // [esp-8h] [ebp-1910h]
  HWND v36; // [esp-8h] [ebp-1910h]
  MENUINFO v37; // [esp+10h] [ebp-18F8h] BYREF
  MENUITEMINFOW mi; // [esp+2Ch] [ebp-18DCh] BYREF
  struct tagPOINT Point; // [esp+5Ch] [ebp-18ACh] BYREF
  int v40; // [esp+64h] [ebp-18A4h]
  HIMAGELIST phimlSmall; // [esp+68h] [ebp-18A0h] BYREF
  LRESULT v42; // [esp+6Ch] [ebp-189Ch]
  UINT item; // [esp+70h] [ebp-1898h]
  HMENU hmenu; // [esp+74h] [ebp-1894h]
  _DWORD *v45; // [esp+78h] [ebp-1890h]
  int *v46; // [esp+7Ch] [ebp-188Ch]
  int v47; // [esp+80h] [ebp-1888h]
  struct _IMAGELIST *v48; // [esp+84h] [ebp-1884h] BYREF
  HWND v49; // [esp+88h] [ebp-1880h]
  LPARAM v50; // [esp+8Ch] [ebp-187Ch] BYREF
  WPARAM wParam; // [esp+90h] [ebp-1878h]
  char v52; // [esp+95h] [ebp-1873h]
  int v53; // [esp+98h] [ebp-1870h]
  int v54; // [esp+9Ch] [ebp-186Ch]
  _DWORD v55[516]; // [esp+A0h] [ebp-1868h] BYREF
  int v56; // [esp+8B0h] [ebp-1058h]
  UINT v57[518]; // [esp+8B8h] [ebp-1050h] BYREF
  struct tagRECT rcDst; // [esp+10D0h] [ebp-838h] BYREF
  struct tagRECT Rect; // [esp+10E0h] [ebp-828h] BYREF
  RECT lParam; // [esp+10F0h] [ebp-818h] BYREF
  char v61[1024]; // [esp+1100h] [ebp-808h] BYREF
  LPARAM v62[257]; // [esp+1500h] [ebp-408h] BYREF

  v2 = a2[2];
  v3 = (_DWORD *)a1;
  v45 = (_DWORD *)a1;
  v46 = a2;
  if ( v2 > 0xFFFFFF4B )
  {
    switch ( v2 )
    {
      case 0xFFFFFF4F:
        sub_49BA90(a1, a2);
        return 0;
      case 0xFFFFFF50:
        return sub_49E5A0(a1, (int)a2);
      case 0xFFFFFF51:
        return sub_49CAE0(a1, (int)a2);
      case 0xFFFFFF62:
        sub_49C530((_DWORD *)a1, (int)a2);
        return 0;
      case 0xFFFFFF65:
        return sub_49E9B0(a1, (int)a2);
      case 0xFFFFFF93:
        sub_49DB50(a1, (int)a2, 0);
        return 0;
      case 0xFFFFFF94:
        sub_49BA70(a1, (int)a2);
        return 0;
      case 0xFFFFFF9B:
        sub_49F540(a1, (int)a2);
        return 0;
      case 0xFFFFFF9C:
        v32 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516);
        (*(void (__thiscall **)(int, struct _IMAGELIST **))(*(_DWORD *)v32 + 24))(v32, &v48);
        if ( v48 != (struct _IMAGELIST *)3 || !v3[15329] )
          return 0;
        v3[15329] = 0;
        return 1;
      case 0xFFFFFFF4:
        return sub_4916A0(a1, a2);
      case 0xFFFFFFFB:
        sub_4AC4D0(a1, (HWND *)a2);
        return 0;
      case 0xFFFFFFFD:
        if ( *a2 != *(_DWORD *)(a1 + 3432) )
          return 0;
        goto LABEL_73;
      case 0xFFFFFFFE:
        if ( !*(_DWORD *)(a1 + 59384) || *(_DWORD *)(a1 + 60568) || *a2 != *(_DWORD *)(a1 + 3432) )
          return 0;
LABEL_73:
        sub_49B7C0((_DWORD *)a1);
        result = 0;
        break;
      default:
        return 0;
    }
  }
  else
  {
    if ( v2 != -181 )
    {
      switch ( v2 )
      {
        case 0xFFFFFCB7:
          v6 = 0;
          v49 = 0;
          item = 0;
          hmenu = CreatePopupMenu();
          v48 = himl;
          Shell_GetImageLists(0, &phimlSmall);
          switch ( v46[4] )
          {
            case 0:
              v49 = (HWND)v3[22];
              v6 = v49;
              break;
            case 2:
              v7 = v3[126];
              goto LABEL_17;
            case 3:
              v49 = (HWND)v3[127];
              himl = phimlSmall;
              v6 = v49;
              break;
            case 4:
              v7 = v3[128];
              himl = phimlSmall;
LABEL_17:
              v6 = (HWND)v7;
              v49 = (HWND)v7;
              break;
            default:
              break;
          }
          v42 = SendMessageW(v6, 0x418u, 0, 0);
          GetClientRect(v6, &Rect);
          v8 = 0;
          v40 = 0;
          if ( v42 <= 0 )
            goto LABEL_45;
          break;
        case 0xFFFFFCBD:
          SendMessageW(*(HWND *)(a1 + 60), 0x41Au, 0, -1);
          return 0;
        case 0xFFFFFCC1:
          sub_4949E0(a1);
          sub_475080(a1);
          return 0;
        case 0xFFFFFCD7:
          sub_4752B0((_DWORD **)a1);
          return 0;
        case 0xFFFFFD2D:
        case 0xFFFFFD3D:
        case 0xFFFFFD3E:
          return 1;
        case 0xFFFFFD30:
          return sub_4751D0(a1, (int)a2);
        case 0xFFFFFD31:
          sub_475620(a1, (int)a2);
          return 0;
        case 0xFFFFFD3A:
          sub_4934A0(a1, (int)a2);
          return 0;
        case 0xFFFFFD3F:
          sub_475AF0(a1);
          return 0;
        case 0xFFFFFD40:
          sub_467F60(*(HWND *)(a1 + 60), (HWND)*a2);
          return 0;
        default:
          return 0;
      }
      do
      {
        if ( SendMessageW(v6, 0x41Du, v8, (LPARAM)&lParam)
          && (!IntersectRect(&rcDst, &Rect, &lParam) || lParam.right > Rect.right) )
        {
          SendMessageW(v6, 0x417u, v8, (LPARAM)&v50);
          if ( (v52 & 1) != 0 )
          {
            mi.cbSize = 48;
            mi.fMask = 256;
            mi.fType = 2048;
            InsertMenuItemW(hmenu, v8, 1, &mi);
          }
          else
          {
            if ( (v54 & 0xFFFF0000) != 0 )
            {
              v9 = 512;
              v10 = v62;
              v11 = v54 - (_DWORD)v62;
              while ( v9 != -2147483134 )
              {
                v12 = *(_WORD *)((char *)v10 + v11);
                if ( !v12 )
                  break;
                *(_WORD *)v10 = v12;
                v10 = (LPARAM *)((char *)v10 + 2);
                if ( !--v9 )
                {
                  v10 = (LPARAM *)((char *)v10 - 2);
                  break;
                }
              }
              *(_WORD *)v10 = 0;
            }
            else
            {
              SendMessageW(v6, 0x45Bu, ((unsigned __int16)v54 << 16) | 0x200, (LPARAM)v62);
            }
            v13 = v46[4];
            Menu = 0;
            v15 = 66;
            v47 = 66;
            if ( v13 )
            {
              if ( v13 == 2 )
              {
                v16 = SendMessageW((HWND)v3[126], 0x419u, wParam, 0);
                if ( v16 != -1 )
                {
                  SendMessageW((HWND)v3[126], 0x417u, v16, (LPARAM)&v50);
                  sub_465D30(v53, v55);
                  if ( !v55[385] )
                  {
                    Menu = CreateMenu();
                    v17 = CreateMenu();
                    v18 = v45;
                    v45[866] = v17;
                    v37.cbSize = 28;
                    v37.fMask = 16;
                    v37.dwStyle = 0x8000000;
                    SetMenuInfo(Menu, &v37);
                    if ( *(_DWORD *)(v56 + 1540) || (v19 = *(_DWORD *)(v56 + 2076)) == 0 )
                    {
                      dword_4EB2DC = 10000;
                      sub_4A6D20(v18, Menu, 0, 0);
                      v35 = 0;
                      v34 = (HMENU)v18[866];
                    }
                    else
                    {
                      sub_465D30(v19, v57);
                      v18 = v45;
                      dword_4EB2DC = 10000;
                      sub_4A6D20(v45, Menu, (UINT)v57, 0);
                      v35 = v57;
                      v34 = (HMENU)v18[866];
                    }
                    dword_4EB2DC = 10000;
                    sub_4A6D20(v18, v34, (UINT)v35, 0);
                    MenuItemCount = GetMenuItemCount(Menu);
                    sub_48FCC0(Menu, MenuItemCount);
                    v47 = 70;
                  }
                }
              }
              v15 = v47;
            }
            else
            {
              switch ( wParam )
              {
                case 0xAFCAu:
                  Menu = sub_4A0990(v3, 1);
                  v15 = 70;
                  break;
                case 0xAFCBu:
                  Menu = sub_4A0990(v3, 0);
                  v15 = 70;
                  break;
                case 0xAFD5u:
                  Menu = CreateMenu();
                  v27 = 0;
                  v47 = GetMenuItemCount((HMENU)v3[872]);
                  if ( v47 > 0 )
                  {
                    do
                    {
                      v33 = (HMENU)v3[872];
                      mi.cbSize = 48;
                      mi.fMask = 66;
                      mi.dwTypeData = (LPWSTR)v61;
                      mi.cch = 512;
                      if ( GetMenuItemInfoW(v33, v27, 1, &mi) )
                      {
                        mi.cbSize = 48;
                        mi.fMask = 66;
                        mi.dwTypeData = (LPWSTR)v61;
                        InsertMenuItemW(Menu, v27, 1, &mi);
                      }
                      ++v27;
                    }
                    while ( v27 < v47 );
                  }
                  v28 = GetMenuItemCount(Menu);
                  sub_48FCC0(Menu, v28);
                  v15 = 70;
                  break;
              }
            }
            mi.hSubMenu = Menu;
            v21 = item;
            mi.wID = wParam;
            mi.fMask = v15;
            mi.cbSize = 48;
            mi.dwTypeData = (LPWSTR)v62;
            InsertMenuItemW(hmenu, item, 1, &mi);
            v22 = hmenu;
            sub_48F860(hmenu, v21);
            sub_48F820(wParam, v22, v50);
            v8 = v40;
            v6 = v49;
            v3 = v45;
          }
          ++item;
        }
        v40 = ++v8;
      }
      while ( v8 < v42 );
LABEL_45:
      v23 = v46[9];
      Point.x = v46[6];
      v36 = (HWND)v3[15];
      Point.y = v23;
      ClientToScreen(v36, &Point);
      v24 = hmenu;
      v25 = TrackPopupMenu(hmenu, 0x100u, Point.x, Point.y, 0, (HWND)v3[15], 0);
      if ( v25 )
      {
        if ( v25 >= 2000 && v25 <= 2999 || (unsigned int)(v25 - 3000) <= 0x3E7 )
        {
          if ( (unsigned int)(v25 - 2000) > 0x3E7 )
            v26 = v25 - 3000;
          else
            v26 = 2000 - v25;
          v29 = (ITEMIDLIST *)(*(int (__thiscall **)(_DWORD, int))(*(_DWORD *)v3[330] + 88))(v3[330], v26);
          sub_492F40((int)v3, v29, 0x8000000);
          CoTaskMemFree(v29);
          DestroyMenu(v24);
          himl = v48;
          return 0;
        }
        SendMessageW((HWND)v3[13], 0x111u, v25, 0);
      }
      DestroyMenu(v24);
      himl = v48;
      return 0;
    }
    if ( *(_DWORD *)(a1 + 5576) == 5
      && (v30 = *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 5620) + 516),
          (*(void (__thiscall **)(int, struct _IMAGELIST **))(*(_DWORD *)v30 + 24))(v30, &v48),
          v31 = SendMessageW((HWND)v3[858], 0x1037u, 0, 0),
          v48 == (struct _IMAGELIST *)4)
      && (v31 & 1) != 0 )
    {
      InvalidateRect((HWND)v3[858], 0, 1);
      UpdateWindow((HWND)v3[858]);
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 4B1951: conditional instruction was optimized away because edx.4!=0
// 4EB2DC: using guessed type int dword_4EB2DC;

//----- (004B21A0) --------------------------------------------------------
int __thiscall sub_4B21A0(int this, HWND a2, unsigned int a3)
{
  LPITEMIDLIST v3; // edi
  HRESULT v4; // esi
  WPARAM v5; // eax
  HRESULT v6; // edi
  _DWORD *v7; // eax
  int v8; // ecx
  void (__thiscall *v9)(int, void **); // edx
  void **v10; // eax
  void (__stdcall *v11)(void **, int); // edx
  void **v12; // eax
  void *v13; // ecx
  void **v14; // esi
  HMENU PopupMenu; // ebx
  int v16; // eax
  LPITEMIDLIST v17; // edi
  WPARAM v18; // eax
  int v19; // ecx
  WPARAM v20; // eax
  WPARAM v21; // eax
  HWND v22; // esi
  HWND v23; // eax
  int v24; // ecx
  LPITEMIDLIST v25; // esi
  HWND v26; // esi
  HWND v27; // ecx
  BOOL v28; // eax
  LPITEMIDLIST v29; // esi
  HWND v30; // ecx
  BOOL v31; // eax
  LPITEMIDLIST v32; // esi
  HWND v33; // edx
  LPITEMIDLIST v34; // esi
  int v35; // edx
  LPITEMIDLIST v36; // esi
  LPITEMIDLIST v37; // esi
  WPARAM v38; // ebx
  LRESULT v39; // eax
  LRESULT v40; // eax
  WPARAM v41; // ebx
  LRESULT v42; // eax
  int v43; // eax
  int v44; // eax
  HWND v45; // edx
  int v46; // ecx
  void *v47; // ebx
  char ***v48; // ecx
  int v49; // eax
  LPITEMIDLIST v50; // esi
  LPITEMIDLIST v51; // esi
  LPITEMIDLIST v52; // esi
  LPITEMIDLIST v53; // esi
  LPITEMIDLIST v54; // esi
  LPITEMIDLIST v55; // esi
  LPITEMIDLIST v56; // esi
  LPITEMIDLIST v57; // esi
  LRESULT v58; // eax
  char **v59; // edx
  HWND v60; // eax
  int v61; // edi
  int v63; // ecx
  ITEMIDLIST *v64; // eax
  int v65; // eax
  LPITEMIDLIST v66; // esi
  LPITEMIDLIST v67; // esi
  LPITEMIDLIST v68; // esi
  LPITEMIDLIST v69; // esi
  LPITEMIDLIST v70; // esi
  LPITEMIDLIST v71; // esi
  LPITEMIDLIST v72; // esi
  LPITEMIDLIST v73; // esi
  LPITEMIDLIST v74; // esi
  LPITEMIDLIST v75; // esi
  LPITEMIDLIST v76; // esi
  LPITEMIDLIST v77; // esi
  LPITEMIDLIST v78; // esi
  LPITEMIDLIST v79; // esi
  LPITEMIDLIST v80; // esi
  LPITEMIDLIST v81; // esi
  LPITEMIDLIST v82; // esi
  LPITEMIDLIST v83; // esi
  LPITEMIDLIST v84; // esi
  LPITEMIDLIST v85; // esi
  LPITEMIDLIST v86; // esi
  LPITEMIDLIST v87; // esi
  LPITEMIDLIST v88; // esi
  LPITEMIDLIST v89; // esi
  LPITEMIDLIST v90; // esi
  LPITEMIDLIST v91; // esi
  LPITEMIDLIST v92; // esi
  LPITEMIDLIST v93; // esi
  LPITEMIDLIST v94; // esi
  LPITEMIDLIST v95; // esi
  LPITEMIDLIST v96; // esi
  LPITEMIDLIST v97; // esi
  LPITEMIDLIST v98; // esi
  LPITEMIDLIST v99; // esi
  LPITEMIDLIST v100; // esi
  LPITEMIDLIST v101; // esi
  LPITEMIDLIST v102; // esi
  LPITEMIDLIST v103; // esi
  LPITEMIDLIST v104; // esi
  LPITEMIDLIST v105; // esi
  LPITEMIDLIST v106; // esi
  LPITEMIDLIST v107; // esi
  LPITEMIDLIST v108; // esi
  LPITEMIDLIST v109; // esi
  LPITEMIDLIST v110; // esi
  LPITEMIDLIST v111; // esi
  LPITEMIDLIST v112; // esi
  LPITEMIDLIST v113; // esi
  LPITEMIDLIST v114; // esi
  LPITEMIDLIST v115; // esi
  LPITEMIDLIST v116; // esi
  LPITEMIDLIST v117; // esi
  LPITEMIDLIST v118; // esi
  LPITEMIDLIST v119; // esi
  LPITEMIDLIST v120; // esi
  LPITEMIDLIST v121; // esi
  LPITEMIDLIST v122; // esi
  LPITEMIDLIST v123; // esi
  LPITEMIDLIST v124; // esi
  LPITEMIDLIST v125; // esi
  LPITEMIDLIST v126; // esi
  LPITEMIDLIST v127; // esi
  LPITEMIDLIST v128; // esi
  LPITEMIDLIST v129; // esi
  LPITEMIDLIST v130; // esi
  LPITEMIDLIST v131; // esi
  LPITEMIDLIST v132; // esi
  LPITEMIDLIST v133; // esi
  LPITEMIDLIST v134; // esi
  LPITEMIDLIST v135; // esi
  LPITEMIDLIST v136; // esi
  LPITEMIDLIST v137; // esi
  LPITEMIDLIST v138; // esi
  LPITEMIDLIST v139; // esi
  LPITEMIDLIST v140; // esi
  LPITEMIDLIST v141; // esi
  LPITEMIDLIST v142; // esi
  LPITEMIDLIST v143; // esi
  int v144; // ecx
  int v145; // ecx
  int v146; // ecx
  int v147; // ecx
  int v148; // ecx
  int v149; // ecx
  int v150; // ecx
  int v151; // ecx
  void *v152[4]; // [esp-2Ch] [ebp-18ACh] BYREF
  void *v153; // [esp-1Ch] [ebp-189Ch] BYREF
  int v154; // [esp-18h] [ebp-1898h]
  int v155; // [esp-14h] [ebp-1894h]
  char **v156; // [esp-10h] [ebp-1890h] BYREF
  UINT v157; // [esp-Ch] [ebp-188Ch]
  HWND v158; // [esp-8h] [ebp-1888h]
  LPARAM v159; // [esp-4h] [ebp-1884h]
  int v160[2]; // [esp+14h] [ebp-186Ch] BYREF
  int v161[13]; // [esp+1Ch] [ebp-1864h] BYREF
  int v162[3]; // [esp+50h] [ebp-1830h] BYREF
  int v163[3]; // [esp+5Ch] [ebp-1824h] BYREF
  int v164[5]; // [esp+68h] [ebp-1818h] BYREF
  MENUINFO v165; // [esp+7Ch] [ebp-1804h] BYREF
  unsigned int v166; // [esp+9Ch] [ebp-17E4h]
  LPITEMIDLIST v167; // [esp+A0h] [ebp-17E0h] BYREF
  LPITEMIDLIST v168; // [esp+A4h] [ebp-17DCh] BYREF
  WPARAM wParam; // [esp+A8h] [ebp-17D8h] BYREF
  LPVOID pv; // [esp+ACh] [ebp-17D4h] BYREF
  void *v171; // [esp+B0h] [ebp-17D0h] BYREF
  int v172; // [esp+B4h] [ebp-17CCh]
  HWND hWnd; // [esp+BCh] [ebp-17C4h] BYREF
  HMENU hMenu; // [esp+C0h] [ebp-17C0h] BYREF
  LPITEMIDLIST ppidl; // [esp+C4h] [ebp-17BCh] BYREF
  LPARAM lParam[5]; // [esp+C8h] [ebp-17B8h] BYREF
  LPARAM v177[5]; // [esp+DCh] [ebp-17A4h] BYREF
  UINT item[518]; // [esp+F0h] [ebp-1790h] BYREF
  _DWORD v179[386]; // [esp+908h] [ebp-F78h] BYREF
  __int16 Src[260]; // [esp+F10h] [ebp-970h] BYREF
  int v181; // [esp+1118h] [ebp-768h]
  char v182[32]; // [esp+1120h] [ebp-760h] BYREF
  char v183[180]; // [esp+1140h] [ebp-740h] BYREF
  int v184[7]; // [esp+11F4h] [ebp-68Ch] BYREF
  int v185[7]; // [esp+1210h] [ebp-670h] BYREF
  int v186[7]; // [esp+122Ch] [ebp-654h] BYREF
  struct tagPOINT x; // [esp+1248h] [ebp-638h] BYREF
  LPVOID v188; // [esp+1250h] [ebp-630h]
  int y; // [esp+1254h] [ebp-62Ch]
  WCHAR Dest[260]; // [esp+1258h] [ebp-628h] BYREF
  WCHAR pszPath[260]; // [esp+1460h] [ebp-420h] BYREF
  WCHAR v192[260]; // [esp+1668h] [ebp-218h] BYREF
  int v193; // [esp+187Ch] [ebp-4h]

  v3 = (LPITEMIDLIST)this;
  hWnd = a2;
  ppidl = (LPITEMIDLIST)this;
  v166 = HIWORD(a3);
  if ( !HIWORD(a3) )
  {
    if ( (unsigned __int16)(a3 - 10000) > 0x3E8u )
    {
      if ( (unsigned __int16)(a3 - 12000) <= 0x3E8u )
      {
        pv = (LPVOID)((unsigned __int16)a3 - 12000);
        v172 = 0;
        v7 = operator new(0x14u);
        if ( !v7 )
        {
          v168 = 0;
          std::exception::exception((std::exception *)&x.y, (const char *const *)&v168);
          x.y = (LONG)&std::bad_alloc::`vftable';
          _CxxThrowException(&x.y, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
        v171 = v7;
        *v7 = v7;
        *((_DWORD *)v171 + 1) = v171;
        v193 = 0;
        v8 = *(_DWORD *)&v3[440].mkid.cb;
        v9 = *(void (__thiscall **)(int, void **))(*(_DWORD *)v8 + 312);
        hMenu = 0;
        v9(v8, &v171);
        sub_49B900((int)v3, &hMenu);
        v10 = *(void ***)v171;
        if ( *(void **)v171 != v171 )
        {
          while ( v10[2] != *((void **)hMenu + (_DWORD)pv) )
          {
            v10 = (void **)*v10;
            if ( v10 == v171 )
              goto LABEL_18;
          }
          v10[3] = (void *)(v10[3] == 0);
        }
LABEL_18:
        v11 = *(void (__stdcall **)(void **, int))(**(_DWORD **)&v3[440].mkid.cb + 316);
        if ( pv )
        {
          v11(&v171, 0);
        }
        else
        {
          v11(&v171, 1);
          (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)((char *)&v3[9].mkid.cb + 1) + 16))(
            (int)&v3[9].mkid.cb + 1,
            *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
        }
        v193 = -1;
        v12 = *(void ***)v171;
        *(_DWORD *)v171 = v171;
        *((_DWORD *)v171 + 1) = v171;
        v13 = v171;
        v172 = 0;
        if ( v12 != v171 )
        {
          do
          {
            v14 = (void **)*v12;
            operator delete(v12);
            v13 = v171;
            v12 = v14;
          }
          while ( v14 != v171 );
        }
        operator delete(v13);
      }
    }
    else
    {
      sub_4A71D0((unsigned __int16)a3, pszPath, *(HMENU *)(this + 3464));
      sub_466280(pszPath, Dest);
      pv = 0;
      v4 = sub_467810((LPITEMIDLIST *)&pv, (int)Dest);
      (*(void (__thiscall **)(char *, LPVOID, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)((char *)&ppidl[9].mkid.cb + 1)
                                                                             + 40))(
        (char *)&ppidl[9].mkid.cb + 1,
        pv,
        0,
        0,
        0,
        0);
      if ( v4 >= 0 )
        CoTaskMemFree(pv);
      v3 = ppidl;
    }
  }
  if ( (unsigned __int16)(a3 + 19536) <= 0x3E7u )
  {
    v5 = SendMessageW(*(HWND *)&v3[168].mkid.cb, 0x419u, (unsigned __int16)a3, 0);
    wParam = v5;
    if ( v5 != -1 )
    {
      SendMessageW(*(HWND *)&v3[168].mkid.cb, 0x417u, v5, (LPARAM)lParam);
      sub_465D30(lParam[3], v179);
      if ( v179[385] == 1 )
      {
        sub_466280((LPCWSTR)Src, v192);
        hMenu = 0;
        v6 = sub_467810((LPITEMIDLIST *)&hMenu, (int)v192);
        (*(void (__thiscall **)(char *, HMENU, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)((char *)&ppidl[9].mkid.cb + 1)
                                                                              + 40))(
          (char *)&ppidl[9].mkid.cb + 1,
          hMenu,
          0,
          0,
          0,
          0);
        if ( v6 >= 0 )
          CoTaskMemFree(hMenu);
      }
      else
      {
        PopupMenu = CreatePopupMenu();
        hMenu = PopupMenu;
        v165.cbSize = 28;
        v165.fMask = 16;
        v165.dwStyle = 0x8000000;
        SetMenuInfo(PopupMenu, &v165);
        if ( *(_DWORD *)(v181 + 1540) || (v16 = *(_DWORD *)(v181 + 2076)) == 0 )
        {
          dword_4EB2DC = 10000;
          sub_4A6D20(ppidl, PopupMenu, 0, 0);
          v17 = ppidl;
        }
        else
        {
          sub_465D30(v16, item);
          v17 = ppidl;
          dword_4EB2DC = 10000;
          sub_4A6D20(ppidl, hMenu, (UINT)item, 0);
          PopupMenu = hMenu;
        }
        SendMessageW(*(HWND *)&v17[168].mkid.cb, 0x41Du, wParam, (LPARAM)&x);
        MapWindowPoints(*(HWND *)&v17[168].mkid.cb, 0, &x, 2u);
        TrackPopupMenu(PopupMenu, 0, x.x, y, 0, hWnd, 0);
      }
      v3 = ppidl;
    }
  }
  if ( (unsigned __int16)a3 < 0xBF68u )
  {
    v19 = 47000;
    if ( (unsigned __int16)a3 >= 0xB798u )
    {
      v20 = SendMessageW(*(HWND *)((char *)&v3[169].mkid.cb + 1), 0x419u, (unsigned __int16)a3, 0);
      if ( v20 != -1 )
      {
        if ( SendMessageW(*(HWND *)((char *)&v3[169].mkid.cb + 1), 0x417u, v20, (LPARAM)v177) )
        {
          sub_490020(v177[3], (int)v3, 0);
          v3 = ppidl;
        }
      }
    }
  }
  else
  {
    v18 = SendMessageW(*(HWND *)v3[170].mkid.abID, 0x419u, (unsigned __int16)a3, 0);
    sub_4A8D10((int)v3, word_4CB07C, v18);
  }
  if ( (unsigned __int16)a3 > 0x9D85u )
  {
    if ( (unsigned __int16)a3 > 0xAFCAu )
    {
      if ( (unsigned __int16)a3 > 0xBB80u )
      {
        if ( (unsigned __int16)a3 > 0xEA60u )
        {
          switch ( (unsigned __int16)a3 )
          {
            case 0xEA61u:
              v151 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v151 + 20))(v151, 5);
              break;
            case 0xEA62u:
              v147 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v147 + 20))(v147, 1);
              break;
            case 0xEA63u:
              v148 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v148 + 20))(v148, 2);
              break;
            case 0xEA64u:
              v149 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v149 + 20))(v149, 3);
              break;
            case 0xEA65u:
              v150 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v150 + 20))(v150, 4);
              break;
            case 0xEA67u:
              v146 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v146 + 20))(v146, 8);
              break;
            case 0xEA68u:
              v145 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
              (*(void (__thiscall **)(int, int))(*(_DWORD *)v145 + 20))(v145, 7);
              break;
            default:
              break;
          }
        }
        else if ( (unsigned __int16)a3 == 60000 )
        {
          v144 = *((_DWORD *)&v3[172].mkid.cb + *(_DWORD *)((char *)&v3[1873].mkid.cb + 1));
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v144 + 20))(v144, 6);
        }
        else
        {
          switch ( (unsigned __int16)a3 )
          {
            case 0xC350u:
              v66 = ppidl;
              sub_48EA10(v19, 1, (int)ppidl);
              v3 = v66;
              break;
            case 0xC351u:
              v67 = ppidl;
              sub_48EA10(v19, 3, (int)ppidl);
              v3 = v67;
              break;
            case 0xC352u:
              v68 = ppidl;
              sub_48EA10(v19, 4, (int)ppidl);
              v3 = v68;
              break;
            case 0xC353u:
              v69 = ppidl;
              sub_48EA10(v19, 2, (int)ppidl);
              v3 = v69;
              break;
            case 0xC354u:
              v70 = ppidl;
              sub_48EA10(v19, 5, (int)ppidl);
              v3 = v70;
              break;
            case 0xC355u:
              v71 = ppidl;
              sub_48EA10(v19, 6, (int)ppidl);
              v3 = v71;
              break;
            case 0xC357u:
              v72 = ppidl;
              sub_48EA10(v19, 8, (int)ppidl);
              v3 = v72;
              break;
            case 0xC358u:
              v73 = ppidl;
              sub_48EA10(v19, 9, (int)ppidl);
              v3 = v73;
              break;
            case 0xC359u:
              v74 = ppidl;
              sub_48EA10(v19, 10, (int)ppidl);
              v3 = v74;
              break;
            case 0xC35Au:
              v75 = ppidl;
              sub_48EA10(v19, 11, (int)ppidl);
              v3 = v75;
              break;
            case 0xC35Bu:
              v76 = ppidl;
              sub_48EA10(v19, 12, (int)ppidl);
              v3 = v76;
              break;
            case 0xC35Cu:
              v77 = ppidl;
              sub_48EA10(v19, 13, (int)ppidl);
              v3 = v77;
              break;
            case 0xC35Du:
              v78 = ppidl;
              sub_48EA10(v19, 14, (int)ppidl);
              v3 = v78;
              break;
            case 0xC35Eu:
              v79 = ppidl;
              sub_48EA10(v19, 15, (int)ppidl);
              v3 = v79;
              break;
            case 0xC35Fu:
              v80 = ppidl;
              sub_48EA10(v19, 16, (int)ppidl);
              v3 = v80;
              break;
            case 0xC360u:
              v81 = ppidl;
              sub_48EA10(v19, 17, (int)ppidl);
              v3 = v81;
              break;
            case 0xC361u:
              v82 = ppidl;
              sub_48EA10(v19, 18, (int)ppidl);
              v3 = v82;
              break;
            case 0xC362u:
              v83 = ppidl;
              sub_48EA10(v19, 19, (int)ppidl);
              v3 = v83;
              break;
            case 0xC363u:
              v84 = ppidl;
              sub_48EA10(v19, 20, (int)ppidl);
              v3 = v84;
              break;
            case 0xC364u:
              v85 = ppidl;
              sub_48EA10(v19, 21, (int)ppidl);
              v3 = v85;
              break;
            case 0xC365u:
              v86 = ppidl;
              sub_48EA10(v19, 22, (int)ppidl);
              v3 = v86;
              break;
            case 0xC366u:
              v87 = ppidl;
              sub_48EA10(v19, 23, (int)ppidl);
              v3 = v87;
              break;
            case 0xC367u:
              v88 = ppidl;
              sub_48EA10(v19, 24, (int)ppidl);
              v3 = v88;
              break;
            case 0xC368u:
              v89 = ppidl;
              sub_48EA10(v19, 25, (int)ppidl);
              v3 = v89;
              break;
            case 0xC369u:
              v90 = ppidl;
              sub_48EA10(v19, 26, (int)ppidl);
              v3 = v90;
              break;
            case 0xC36Au:
              v91 = ppidl;
              sub_48EA10(v19, 27, (int)ppidl);
              v3 = v91;
              break;
            case 0xC36Bu:
              v92 = ppidl;
              sub_48EA10(v19, 7, (int)ppidl);
              v3 = v92;
              break;
            case 0xC36Cu:
              v93 = ppidl;
              sub_48EA10(v19, 29, (int)ppidl);
              v3 = v93;
              break;
            case 0xC36Du:
              v94 = ppidl;
              sub_48EA10(v19, 30, (int)ppidl);
              v3 = v94;
              break;
            case 0xC36Eu:
              v95 = ppidl;
              sub_48EA10(v19, 31, (int)ppidl);
              v3 = v95;
              break;
            case 0xC36Fu:
              v96 = ppidl;
              sub_48EA10(v19, 32, (int)ppidl);
              v3 = v96;
              break;
            case 0xC370u:
              v97 = ppidl;
              sub_48EA10(v19, 33, (int)ppidl);
              v3 = v97;
              break;
            case 0xC371u:
              v98 = ppidl;
              sub_48EA10(v19, 34, (int)ppidl);
              v3 = v98;
              break;
            case 0xC372u:
              v99 = ppidl;
              sub_48EA10(v19, 35, (int)ppidl);
              v3 = v99;
              break;
            case 0xC373u:
              v100 = ppidl;
              sub_48EA10(v19, 36, (int)ppidl);
              v3 = v100;
              break;
            case 0xC374u:
              v101 = ppidl;
              sub_48EA10(v19, 37, (int)ppidl);
              v3 = v101;
              break;
            case 0xC375u:
              v102 = ppidl;
              sub_48EA10(v19, 38, (int)ppidl);
              v3 = v102;
              break;
            case 0xC376u:
              v103 = ppidl;
              sub_48EA10(v19, 39, (int)ppidl);
              v3 = v103;
              break;
            case 0xC377u:
              v104 = ppidl;
              sub_48EA10(v19, 40, (int)ppidl);
              v3 = v104;
              break;
            case 0xC3B4u:
              v105 = ppidl;
              sub_48E980(v19, 1, (int)ppidl);
              v3 = v105;
              break;
            case 0xC3B5u:
              v106 = ppidl;
              sub_48E980(v19, 3, (int)ppidl);
              v3 = v106;
              break;
            case 0xC3B6u:
              v107 = ppidl;
              sub_48E980(v19, 4, (int)ppidl);
              v3 = v107;
              break;
            case 0xC3B7u:
              v108 = ppidl;
              sub_48E980(v19, 2, (int)ppidl);
              v3 = v108;
              break;
            case 0xC3B8u:
              v109 = ppidl;
              sub_48E980(v19, 5, (int)ppidl);
              v3 = v109;
              break;
            case 0xC3B9u:
              v110 = ppidl;
              sub_48E980(v19, 6, (int)ppidl);
              v3 = v110;
              break;
            case 0xC3BBu:
              v111 = ppidl;
              sub_48E980(v19, 8, (int)ppidl);
              v3 = v111;
              break;
            case 0xC3BCu:
              v112 = ppidl;
              sub_48E980(v19, 9, (int)ppidl);
              v3 = v112;
              break;
            case 0xC3BDu:
              v113 = ppidl;
              sub_48E980(v19, 10, (int)ppidl);
              v3 = v113;
              break;
            case 0xC3BEu:
              v114 = ppidl;
              sub_48E980(v19, 11, (int)ppidl);
              v3 = v114;
              break;
            case 0xC3BFu:
              v115 = ppidl;
              sub_48E980(v19, 12, (int)ppidl);
              v3 = v115;
              break;
            case 0xC3C0u:
              v116 = ppidl;
              sub_48E980(v19, 13, (int)ppidl);
              v3 = v116;
              break;
            case 0xC3C1u:
              v117 = ppidl;
              sub_48E980(v19, 14, (int)ppidl);
              v3 = v117;
              break;
            case 0xC3C2u:
              v118 = ppidl;
              sub_48E980(v19, 15, (int)ppidl);
              v3 = v118;
              break;
            case 0xC3C3u:
              v119 = ppidl;
              sub_48E980(v19, 16, (int)ppidl);
              v3 = v119;
              break;
            case 0xC3C4u:
              v120 = ppidl;
              sub_48E980(v19, 17, (int)ppidl);
              v3 = v120;
              break;
            case 0xC3C5u:
              v121 = ppidl;
              sub_48E980(v19, 18, (int)ppidl);
              v3 = v121;
              break;
            case 0xC3C6u:
              v122 = ppidl;
              sub_48E980(v19, 19, (int)ppidl);
              v3 = v122;
              break;
            case 0xC3C7u:
              v123 = ppidl;
              sub_48E980(v19, 20, (int)ppidl);
              v3 = v123;
              break;
            case 0xC3C8u:
              v124 = ppidl;
              sub_48E980(v19, 21, (int)ppidl);
              v3 = v124;
              break;
            case 0xC3C9u:
              v125 = ppidl;
              sub_48E980(v19, 22, (int)ppidl);
              v3 = v125;
              break;
            case 0xC3CAu:
              v126 = ppidl;
              sub_48E980(v19, 23, (int)ppidl);
              v3 = v126;
              break;
            case 0xC3CBu:
              v127 = ppidl;
              sub_48E980(v19, 24, (int)ppidl);
              v3 = v127;
              break;
            case 0xC3CCu:
              v128 = ppidl;
              sub_48E980(v19, 25, (int)ppidl);
              v3 = v128;
              break;
            case 0xC3CDu:
              v129 = ppidl;
              sub_48E980(v19, 26, (int)ppidl);
              v3 = v129;
              break;
            case 0xC3CEu:
              v130 = ppidl;
              sub_48E980(v19, 27, (int)ppidl);
              v3 = v130;
              break;
            case 0xC3CFu:
              v131 = ppidl;
              sub_48E980(v19, 7, (int)ppidl);
              v3 = v131;
              break;
            case 0xC3D0u:
              v132 = ppidl;
              sub_48E980(v19, 29, (int)ppidl);
              v3 = v132;
              break;
            case 0xC3D1u:
              v133 = ppidl;
              sub_48E980(v19, 30, (int)ppidl);
              v3 = v133;
              break;
            case 0xC3D2u:
              v134 = ppidl;
              sub_48E980(v19, 31, (int)ppidl);
              v3 = v134;
              break;
            case 0xC3D3u:
              v135 = ppidl;
              sub_48E980(v19, 32, (int)ppidl);
              v3 = v135;
              break;
            case 0xC3D4u:
              v136 = ppidl;
              sub_48E980(v19, 33, (int)ppidl);
              v3 = v136;
              break;
            case 0xC3D5u:
              v137 = ppidl;
              sub_48E980(v19, 34, (int)ppidl);
              v3 = v137;
              break;
            case 0xC3D6u:
              v138 = ppidl;
              sub_48E980(v19, 35, (int)ppidl);
              v3 = v138;
              break;
            case 0xC3D7u:
              v139 = ppidl;
              sub_48E980(v19, 36, (int)ppidl);
              v3 = v139;
              break;
            case 0xC3D8u:
              v140 = ppidl;
              sub_48E980(v19, 37, (int)ppidl);
              v3 = v140;
              break;
            case 0xC3D9u:
              v141 = ppidl;
              sub_48E980(v19, 38, (int)ppidl);
              v3 = v141;
              break;
            case 0xC3DAu:
              v142 = ppidl;
              sub_48E980(v19, 39, (int)ppidl);
              v3 = v142;
              break;
            case 0xC3DBu:
              v143 = ppidl;
              sub_48E980(v19, 40, (int)ppidl);
              v3 = v143;
              break;
            default:
              break;
          }
        }
      }
      else
      {
        if ( (unsigned __int16)a3 != 48000 )
        {
          switch ( (unsigned __int16)a3 )
          {
            case 0xAFCBu:
LABEL_195:
              sub_490690((int)v3);
              goto LABEL_182;
            case 0xAFCCu:
LABEL_196:
              sub_490550((int)v3);
              goto LABEL_182;
            case 0xAFCDu:
LABEL_192:
              sub_475130((int)v3);
              goto LABEL_182;
            case 0xAFCEu:
LABEL_190:
              sub_495B40((int)v3, 0);
              goto LABEL_182;
            case 0xAFCFu:
LABEL_191:
              sub_495B40((int)v3, 1);
              goto LABEL_182;
            case 0xAFD0u:
LABEL_194:
              sub_48FE90((int)v3);
              goto LABEL_182;
            case 0xAFD1u:
LABEL_187:
              sub_4AC5F0(1, (int)v3);
              goto LABEL_182;
            case 0xAFD2u:
LABEL_188:
              sub_4AC5F0(0, (int)v3);
              goto LABEL_182;
            case 0xAFD3u:
LABEL_189:
              sub_4AC4A0((int)v3);
              goto LABEL_182;
            case 0xAFD4u:
LABEL_179:
              v61 = 0;
              goto LABEL_180;
            case 0xAFD5u:
              sub_4908C0(v19, (int)v3, (int)v3);
              goto LABEL_182;
            case 0xAFD6u:
LABEL_199:
              v23 = hDlg;
              if ( hDlg )
              {
LABEL_54:
                SetFocus(v23);
              }
              else
              {
                (*(void (__thiscall **)(_DWORD, int, WCHAR *))(**(_DWORD **)&v3[440].mkid.cb + 52))(
                  *(_DWORD *)&v3[440].mkid.cb,
                  260,
                  v192);
                v64 = (ITEMIDLIST *)operator new(0x2DCu);
                v168 = v64;
                v193 = 7;
                if ( v64 )
                  v65 = sub_4829E0(hWnd, (int)v64, (int)v192, (int)&v3[9].mkid.cb + 1);
                else
                  v65 = 0;
                hDlg = sub_46C0D0(v65, (int)&v3[8]);
              }
              goto LABEL_182;
            case 0xAFD7u:
LABEL_186:
              sub_4AC440((int)v3);
              goto LABEL_182;
            case 0xAFD9u:
LABEL_193:
              sub_48ECA0((int)v3);
              goto LABEL_182;
            case 0xAFDAu:
LABEL_197:
              v63 = *(_DWORD *)&v3[440].mkid.cb;
              x.x = (LONG)v3;
              x.y = 0;
              v188 = (LPVOID)(*(int (__thiscall **)(int))(*(_DWORD *)v63 + 56))(v63);
              y = 0;
              sub_401090((LPCWSTR)0xB3, hWnd, sub_4AA4F0, (LPARAM)&x);
              CoTaskMemFree(v188);
              sub_4A6FC0((HMENU *)v3);
              goto LABEL_182;
            case 0xAFDBu:
              goto LABEL_177;
            case 0xAFDCu:
LABEL_178:
              sub_469350(&v3[1164].mkid.cb);
              goto LABEL_182;
            case 0xAFDDu:
LABEL_198:
              sub_401090((LPCWSTR)0xB4, *(HWND *)((char *)&v3[17].mkid.cb + 1), sub_48C3B0, (LPARAM)v3);
              goto LABEL_182;
            case 0xAFDEu:
LABEL_185:
              v61 = 1;
LABEL_180:
              sub_4AC560((int)ppidl, (void *)v61);
              goto LABEL_181;
            default:
              goto LABEL_182;
          }
        }
        sub_4B0EB0((int)v3);
      }
    }
    else if ( (unsigned __int16)a3 == 45002 )
    {
LABEL_173:
      sub_4906F0((int)v3);
    }
    else
    {
      switch ( (unsigned __int16)a3 )
      {
        case 0x9D8Bu:
          v30 = *(HWND *)((char *)&v3[169].mkid.cb + 1);
          v31 = *(_DWORD *)((char *)&v3[19769].mkid.cb + 1) == 0;
          *(_DWORD *)((char *)&v3[19769].mkid.cb + 1) = v31;
LABEL_67:
          v159 = v31;
          v158 = v30;
          goto LABEL_68;
        case 0x9D90u:
          sub_4A7130((int)v3, *(_DWORD *)&v3[20128].mkid.cb, 0);
          break;
        case 0x9D92u:
          sub_4A74D0((LPARAM)v3, *(_DWORD *)&v3[20128].mkid.cb);
          break;
        case 0x9D93u:
          sub_4A7410((LPARAM)v3);
          break;
        case 0x9D94u:
          sub_4A70B0((int)v3, *(_DWORD *)&v3[20128].mkid.cb);
          break;
        case 0x9D95u:
          sub_4A7250((LPARAM)v3, *(_DWORD *)&v3[20128].mkid.cb);
          break;
        case 0x9D96u:
          sub_4A7130((int)v3, *(_DWORD *)&v3[20128].mkid.cb, 1);
          break;
        case 0x9D98u:
          sub_48ECF0((int)v3);
          break;
        case 0x9D9Du:
          v45 = *(HWND *)v3[170].mkid.abID;
          v159 = *(_DWORD *)v3[19770].mkid.abID == 0;
          *(_DWORD *)v3[19770].mkid.abID = v159;
          v158 = v45;
LABEL_68:
          sub_48EBF0((int)v3, (int)v158, v159);
          v32 = ppidl;
          sub_4949E0((int)ppidl);
          sub_475080((int)v32);
          v3 = v32;
          break;
        case 0x9D9Eu:
          sub_48EFB0((int)v3);
          break;
        case 0x9DA0u:
          sub_4922E0((int)v3);
          break;
        case 0x9DA7u:
          sub_4A8D10((int)v3, word_4CB080, *(_DWORD *)&v3[20128].mkid.cb);
          break;
        case 0x9DA8u:
          sub_4A9210((LPARAM)v3);
          break;
        case 0x9DA9u:
          sub_4A8A10(*(_DWORD *)&v3[20128].mkid.cb, (int)v3);
          break;
        case 0x9DAAu:
          sub_4A91B0((LPARAM)v3, *(_DWORD *)&v3[20128].mkid.cb);
          break;
        case 0x9DB1u:
        case 0x9DD0u:
LABEL_135:
          sub_495AA0((int *)v3);
          break;
        case 0x9DB3u:
          sub_48FD90(v3);
          break;
        case 0x9DB7u:
          v60 = *(HWND *)((char *)&v3[21].mkid.cb + 1);
          v159 = 0;
          v158 = v60;
          *(_DWORD *)((char *)&v3[19765].mkid.cb + 1) = 0;
          ShowWindow(v158, v159);
          sub_475080((int)v3);
          break;
        case 0x9DB9u:
LABEL_131:
          sub_4AC590((int)v3);
          break;
        case 0x9DD3u:
          sub_4AC8B0(v3);
          break;
        case 0x9DDBu:
          sub_4A45B0((int)&v3[12], (int)hWnd, (int)v160);
          sub_46C110((LPARAM)v160);
          InvalidateRect(*(HWND *)&v3[1144].mkid.cb, 0, 0);
          sub_4A43B0(v160);
          break;
        case 0x9DE1u:
          goto LABEL_199;
        case 0x9DE3u:
          hWnd = 0;
          sub_40A410(&v171);
          v193 = 1;
          v46 = *(_DWORD *)&v3[440].mkid.cb;
          wParam = 0;
          hMenu = 0;
          pv = 0;
          ppidl = 0;
          v167 = 0;
          v168 = 0;
          (*(void (__thiscall **)(int, void **))(*(_DWORD *)v46 + 312))(v46, &v171);
          v47 = (void *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)&v3[440].mkid.cb + 56))(*(_DWORD *)&v3[440].mkid.cb);
          SHGetFolderLocation(0, 17, 0, 0, (LPITEMIDLIST *)&wParam);
          SHGetFolderLocation(0, 3, 0, 0, (LPITEMIDLIST *)&hMenu);
          SHGetFolderLocation(0, 10, 0, 0, (LPITEMIDLIST *)&pv);
          SHGetFolderLocation(0, 4, 0, 0, &ppidl);
          SHGetFolderLocation(0, 49, 0, 0, &v167);
          SHGetFolderLocation(0, 18, 0, 0, &v168);
          SHGetDesktopFolder((IShellFolder **)&hWnd);
          if ( (*(int (__stdcall **)(HWND, int, void *, WPARAM))(*(_DWORD *)hWnd + 28))(hWnd, 0x10000000, v47, wParam) )
          {
            if ( (*(int (__stdcall **)(HWND, int, void *, HMENU))(*(_DWORD *)hWnd + 28))(hWnd, 0x10000000, v47, hMenu) )
            {
              if ( (*(int (__stdcall **)(HWND, int, void *, LPVOID))(*(_DWORD *)hWnd + 28))(hWnd, 0x10000000, v47, pv) )
              {
                if ( (*(int (__stdcall **)(HWND, int, void *, LPITEMIDLIST))(*(_DWORD *)hWnd + 28))(
                       hWnd,
                       0x10000000,
                       v47,
                       ppidl) )
                {
                  if ( (*(int (__stdcall **)(HWND, int, void *, LPITEMIDLIST))(*(_DWORD *)hWnd + 28))(
                         hWnd,
                         0x10000000,
                         v47,
                         v167) )
                  {
                    v49 = (*(int (__stdcall **)(HWND, int, void *, LPITEMIDLIST))(*(_DWORD *)hWnd + 28))(
                            hWnd,
                            0x10000000,
                            v47,
                            v168);
                    v48 = (char ***)((char *)&v3[20181].mkid.cb + 1);
                    if ( v49 )
                      v48 = (char ***)((char *)&v3[20157].mkid.cb + 1);
                  }
                  else
                  {
                    v48 = (char ***)((char *)&v3[20177].mkid.cb + 1);
                  }
                }
                else
                {
                  v48 = (char ***)((char *)&v3[20173].mkid.cb + 1);
                }
              }
              else
              {
                v48 = (char ***)((char *)&v3[20169].mkid.cb + 1);
              }
            }
            else
            {
              v48 = (char ***)((char *)&v3[20165].mkid.cb + 1);
            }
          }
          else
          {
            v48 = (char ***)((char *)&v3[20161].mkid.cb + 1);
          }
          sub_40B7F0((int **)&v171, v48);
          sub_415F10((int)&v171);
          (*(void (__stdcall **)(HWND))(*(_DWORD *)hWnd + 8))(hWnd);
          CoTaskMemFree(v47);
          sub_41ECB0(&v171);
          break;
        case 0x9DE4u:
          sub_490600((int)v3);
          break;
        case 0x9DE7u:
          v50 = ppidl;
          sub_479FD0(0, (int)ppidl);
          v3 = v50;
          break;
        case 0x9DE8u:
          v51 = ppidl;
          sub_479FD0(1, (int)ppidl);
          v3 = v51;
          break;
        case 0x9DE9u:
          v52 = ppidl;
          sub_479FD0(2, (int)ppidl);
          v3 = v52;
          break;
        case 0x9DEAu:
          v53 = ppidl;
          sub_479FD0(3, (int)ppidl);
          v3 = v53;
          break;
        case 0x9DEBu:
          v54 = ppidl;
          sub_479FD0(4, (int)ppidl);
          v3 = v54;
          break;
        case 0x9DECu:
          v55 = ppidl;
          sub_479FD0(5, (int)ppidl);
          v3 = v55;
          break;
        case 0x9DEDu:
          v56 = ppidl;
          sub_479FD0(6, (int)ppidl);
          v3 = v56;
          break;
        case 0x9DEEu:
          v57 = ppidl;
          sub_479FD0(7, (int)ppidl);
          v3 = v57;
          break;
        case 0x9DEFu:
          v58 = SendMessageW(*(HWND *)v3[22].mkid.abID, 0x1304u, 0, 0);
          v59 = *(char ***)v3[22].mkid.abID;
          v159 = 0;
          v158 = (HWND)(v58 - 1);
          v157 = 4876;
          v156 = v59;
          *(_DWORD *)((char *)&v3[1877].mkid.cb + 1) = v58 - 1;
          SendMessageW((HWND)v156, v157, (WPARAM)v158, v159);
          sub_479A30((int)v3, 1);
          break;
        default:
          break;
      }
    }
  }
  else if ( (unsigned __int16)a3 == 40325 )
  {
    sub_463F50((int *)v3[19850].mkid.abID);
LABEL_181:
    v3 = ppidl;
  }
  else if ( (unsigned __int16)a3 > 0x9C78u )
  {
    switch ( (unsigned __int16)a3 )
    {
      case 0x9C79u:
        goto LABEL_45;
      case 0x9C7Bu:
        goto LABEL_178;
      case 0x9C7Cu:
        sub_4095E0(v184, &v3[1164]);
        sub_467670(v184);
        sub_409000((int)v184);
        break;
      case 0x9C7Du:
        sub_4AC8E0((int)v3);
        break;
      case 0x9C7Fu:
        goto LABEL_179;
      case 0x9C80u:
        goto LABEL_131;
      case 0x9C81u:
      case 0x9CEDu:
        goto LABEL_186;
      case 0x9C83u:
        goto LABEL_188;
      case 0x9C85u:
        goto LABEL_187;
      case 0x9C86u:
        goto LABEL_189;
      case 0x9C87u:
        sub_4AE160((int)&v3[1164], 0);
        break;
      case 0x9C88u:
        goto LABEL_190;
      case 0x9C89u:
        goto LABEL_191;
      case 0x9C8Au:
        v22 = *(HWND *)&v3[1144].mkid.cb;
        *(_DWORD *)((char *)&v3[20185].mkid.cb + 1) = 1;
        sub_469760(v22);
        v23 = *(HWND *)&v3[1144].mkid.cb;
        goto LABEL_54;
      case 0x9C8Bu:
        v24 = *(_DWORD *)v3[20190].mkid.abID;
        *(_DWORD *)&v3[20188].mkid.cb = 1;
        *(_DWORD *)&v3[20192].mkid.cb = v24;
        sub_469690(*(HWND *)&v3[1144].mkid.cb);
        SetFocus(*(HWND *)&ppidl[1144].mkid.cb);
        goto LABEL_181;
      case 0x9C8Cu:
        v26 = *(HWND *)&v3[1144].mkid.cb;
        *(_DWORD *)v3[20186].mkid.abID = 1;
        sub_469710(v26);
        SetFocus(*(HWND *)&v3[1144].mkid.cb);
        break;
      case 0x9C8Du:
        v27 = *(HWND *)v3[18].mkid.abID;
        v28 = *(_DWORD *)((char *)&v3[19761].mkid.cb + 1) == 0;
        *(_DWORD *)((char *)&v3[19761].mkid.cb + 1) = v28;
        goto LABEL_63;
      case 0x9C8Eu:
        goto LABEL_192;
      case 0x9C99u:
        v36 = ppidl;
        sub_48F030(v19, 1, (int)ppidl);
        v3 = v36;
        break;
      case 0x9C9Au:
        v37 = ppidl;
        sub_48F030(v19, 0, (int)ppidl);
        v3 = v37;
        break;
      case 0x9C9Bu:
        (*(void (__thiscall **)(_DWORD))(**(_DWORD **)&v3[440].mkid.cb + 100))(*(_DWORD *)&v3[440].mkid.cb);
        break;
      case 0x9C9Cu:
        (*(void (__thiscall **)(_DWORD))(**(_DWORD **)&v3[440].mkid.cb + 236))(*(_DWORD *)&v3[440].mkid.cb);
        break;
      case 0x9C9Du:
        goto LABEL_173;
      case 0x9C9Eu:
        goto LABEL_195;
      case 0x9C9Fu:
        goto LABEL_196;
      case 0x9CA0u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 17, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9CA1u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 5, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9CA2u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 13, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9CA3u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 39, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9CA5u:
        v23 = ::hWnd;
        if ( ::hWnd )
          goto LABEL_54;
        sub_48E680((int)v3);
        break;
      case 0x9CA6u:
        sub_4682E0((int)pszPath);
        PathRemoveFileSpecW(pszPath);
        PathAppendW(pszPath, L"Explorer++ Help.chm");
        wParam = 0;
        if ( sub_467810((LPITEMIDLIST *)&wParam, (int)pszPath) < 0
          || !sub_466570(0, *(HWND *)((char *)&ppidl[17].mkid.cb + 1), (void *)wParam, 0, 0) )
        {
          v43 = sub_49FA00((int)v164, (int)hWnd);
          sub_46C110(v43);
          sub_49F9E0(v164);
        }
        goto LABEL_181;
      case 0x9CA7u:
        v44 = sub_4AA740((int)v161, (int)hWnd);
        sub_46C110(v44);
        sub_4AA720(v161);
        break;
      case 0x9CA8u:
        sub_4949B0((int)v3);
        break;
      case 0x9CA9u:
        goto LABEL_193;
      case 0x9CBBu:
        sub_47A020((int)v3, 1);
        break;
      case 0x9CBDu:
        sub_47A020((int)v3, 0);
        break;
      case 0x9CD1u:
        goto LABEL_185;
      case 0x9CD3u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 0, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9CE0u:
        SendMessageW(hWnd, 0x10u, 0, 0);
        break;
      case 0x9CE6u:
        v25 = ppidl;
        sub_494AB0((int)ppidl, *(HWND *)&v3[1144].mkid.cb);
        SetFocus(*(HWND *)&v25[1144].mkid.cb);
        v3 = v25;
        break;
      case 0x9CE8u:
        sub_4AC470((int)v3);
        break;
      case 0x9CEAu:
        sub_4921A0((int)v3);
        break;
      case 0x9CECu:
        sub_4900F0((int)v3);
        break;
      case 0x9CEEu:
        goto LABEL_197;
      case 0x9CFDu:
        sub_4AE160((int)&v3[1164], 1);
        break;
      case 0x9CFFu:
        goto LABEL_135;
      case 0x9D03u:
        sub_490DF0((int)v3, 1);
        break;
      case 0x9D05u:
        goto LABEL_198;
      case 0x9D07u:
        v27 = *(HWND *)((char *)&v3[21].mkid.cb + 1);
        v28 = *(_DWORD *)((char *)&v3[19765].mkid.cb + 1) == 0;
        *(_DWORD *)((char *)&v3[19765].mkid.cb + 1) = v28;
LABEL_63:
        ShowWindow(v27, v28 ? 5 : 0);
        sub_475080((int)v3);
        break;
      case 0x9D0Au:
        sub_401090((LPCWSTR)0xB2, hWnd, sub_4A3300, (LPARAM)v3);
        break;
      case 0x9D0Cu:
        sub_490DF0((int)v3, 0);
        break;
      case 0x9D0Eu:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 10, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9D11u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 3, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9D12u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 4, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9D14u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 59, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9D17u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 18, 0, 0, (LPITEMIDLIST *)&hMenu) )
          goto LABEL_112;
        break;
      case 0x9D25u:
        sub_48EC70((int)v3);
        break;
      case 0x9D26u:
        if ( v3 )
          v35 = (int)&v3[9].mkid.cb + 1;
        else
          v35 = 0;
        sub_49FD60((int)hWnd, v35, (int)v163);
        sub_46C110((LPARAM)v163);
        sub_49FAC0(v163);
        break;
      case 0x9D28u:
        hMenu = 0;
        if ( !SHGetFolderLocation(0, 49, 0, 0, (LPITEMIDLIST *)&hMenu) )
        {
LABEL_112:
          sub_492F40((int)v3, (const ITEMIDLIST *)hMenu, 1);
          CoTaskMemFree(hMenu);
        }
        break;
      case 0x9D2Du:
        sub_491AC0(v3);
        break;
      case 0x9D37u:
        sub_4793C0(*(_DWORD *)((char *)&v3[1877].mkid.cb + 1), (int)v3);
        break;
      case 0x9D41u:
        v40 = SendMessageW(*(HWND *)&v3[1144].mkid.cb, 0x100Cu, 0xFFFFFFFF, 2);
        if ( v40 != -1 )
        {
          (*(void (__thiscall **)(_DWORD, LRESULT, WCHAR *))(**(_DWORD **)&v3[440].mkid.cb + 48))(
            *(_DWORD *)&v3[440].mkid.cb,
            v40,
            v192);
          v168 = (LPITEMIDLIST)&v153;
          sub_4095E0(&v153, v192);
          sub_47DB90((int)hWnd, (int)v182, v153, v154, v155, (int)v156, v157, (int)v158, v159);
          sub_46C110((LPARAM)v182);
          sub_47C5D0((int)v182);
        }
        break;
      case 0x9D44u:
        (*(void (__thiscall **)(_DWORD, int, WCHAR *))(**(_DWORD **)&v3[440].mkid.cb + 52))(
          *(_DWORD *)&v3[440].mkid.cb,
          260,
          Dest);
        sub_40A0B0(&v171);
        v193 = 2;
        v38 = SendMessageW(*(HWND *)&v3[1144].mkid.cb, 0x100Cu, 0xFFFFFFFF, 2);
        if ( v38 != -1 )
        {
          do
          {
            (*(void (__thiscall **)(_DWORD, WPARAM, WCHAR *))(**(_DWORD **)&v3[440].mkid.cb + 48))(
              *(_DWORD *)&v3[440].mkid.cb,
              v38,
              v192);
            sub_4095E0(v185, v192);
            LOBYTE(v193) = 3;
            sub_40AAD0((int)v185, (int)&v171);
            LOBYTE(v193) = 2;
            sub_409000((int)v185);
            v39 = SendMessageW(*(HWND *)&ppidl[1144].mkid.cb, 0x100Cu, v38, 2);
            v3 = ppidl;
            v38 = v39;
          }
          while ( v39 != -1 );
        }
        v159 = *(_DWORD *)((char *)&v3[19833].mkid.cb + 1);
        v168 = (LPITEMIDLIST)&v156;
        sub_40AC30(&v156, (int **)&v171);
        LOBYTE(v193) = 4;
        v167 = (LPITEMIDLIST)v152;
        sub_4095E0(v152, Dest);
        LOBYTE(v193) = 2;
        sub_497E90(
          *(_DWORD *)((char *)&v3[17].mkid.cb + 1),
          (int)v183,
          v152[0],
          (int)v152[1],
          (int)v152[2],
          (int)v152[3],
          (int)v153,
          v154,
          v155,
          v156,
          v157,
          (int)v158,
          v159);
        sub_46C110((LPARAM)v183);
        sub_497940((int)v183);
        sub_40A140((int)&v171);
        operator delete(v171);
        break;
      case 0x9D45u:
        sub_40A0B0(&v171);
        v193 = 5;
        v41 = SendMessageW(*(HWND *)&v3[1144].mkid.cb, 0x100Cu, 0xFFFFFFFF, 2);
        if ( v41 != -1 )
        {
          do
          {
            (*(void (__thiscall **)(_DWORD, WPARAM, WCHAR *))(**(_DWORD **)&v3[440].mkid.cb + 48))(
              *(_DWORD *)&v3[440].mkid.cb,
              v41,
              v192);
            sub_4095E0(v186, v192);
            LOBYTE(v193) = 6;
            sub_40AAD0((int)v186, (int)&v171);
            LOBYTE(v193) = 5;
            sub_409000((int)v186);
            v42 = SendMessageW(*(HWND *)&ppidl[1144].mkid.cb, 0x100Cu, v41, 2);
            v3 = ppidl;
            v41 = v42;
          }
          while ( v42 != -1 );
        }
        v159 = *(_DWORD *)((char *)&v3[19833].mkid.cb + 1);
        v168 = (LPITEMIDLIST)&v156;
        sub_40AC30(&v156, (int **)&v171);
        sub_4A3A40(*(void **)((char *)&v3[17].mkid.cb + 1), (int)v162, v156, v157, (int)v158, v159);
        sub_46C110((LPARAM)v162);
        sub_4A3850(v162);
        sub_40A140((int)&v171);
        operator delete(v171);
        break;
      case 0x9D47u:
        goto LABEL_194;
      case 0x9D49u:
        sub_48F0C0((int)v3);
        break;
      case 0x9D5Au:
        v159 = *(_DWORD *)&v3[19764].mkid.cb == 0;
        *(_DWORD *)&v3[19764].mkid.cb = v159;
        sub_48EBF0((int)v3, *(_DWORD *)v3[166].mkid.abID, v159);
        v29 = ppidl;
        sub_4949E0((int)ppidl);
        sub_475080((int)v29);
        v3 = v29;
        break;
      case 0x9D5Cu:
        SendMessageW(*(HWND *)((char *)&v3[29].mkid.cb + 1), 0x41Bu, 0, 0);
        break;
      case 0x9D5Eu:
        SetFocus(*(HWND *)&v3[28].mkid.cb);
        break;
      case 0x9D5Fu:
        SetFocus(*(HWND *)&v3[28].mkid.cb);
        SendMessageW(*(HWND *)&v3[28].mkid.cb, 0x14Fu, 1u, 0);
        break;
      case 0x9D61u:
        sub_48EEF0((int)v3);
        break;
      case 0x9D63u:
        v30 = *(HWND *)((char *)&v3[29].mkid.cb + 1);
        v31 = *(_DWORD *)v3[19766].mkid.abID == 0;
        *(_DWORD *)v3[19766].mkid.abID = v31;
        goto LABEL_67;
      case 0x9D64u:
        v33 = *(HWND *)&v3[168].mkid.cb;
        v159 = *(_DWORD *)&v3[19768].mkid.cb == 0;
        v158 = v33;
        *(_DWORD *)&v3[19768].mkid.cb = v159;
        sub_48EBF0((int)v3, (int)v158, v159);
        v34 = ppidl;
        sub_4949E0((int)ppidl);
        sub_475080((int)v34);
        v3 = v34;
        break;
      default:
        break;
    }
  }
  else
  {
    switch ( (unsigned __int16)a3 )
    {
      case 0x9C78u:
LABEL_177:
        sub_490280((int)v3);
        break;
      case 0x13A9u:
LABEL_45:
        v21 = SendMessageW(*(HWND *)v3[22].mkid.abID, 0x130Bu, 0, 0);
        sub_479C50((int)v3, v21);
        break;
      case 0x1F42u:
        sub_4924F0((HWND *)v3);
        break;
    }
  }
LABEL_182:
  if ( (_WORD)v166 == 7 )
    sub_4656B0(*(HWND *)&v3[28].mkid.cb, &v3[1164].mkid.cb);
  return 1;
}
// 4B2371: conditional instruction was optimized away because %arg_4@2.2==0
// 4B29BC: variable 'v19' is possibly undefined
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4CB07C: using guessed type WCHAR word_4CB07C[2];
// 4CB080: using guessed type WCHAR word_4CB080[2];
// 4EB2DC: using guessed type int dword_4EB2DC;
// 4B21A0: using guessed type WCHAR Src[260];
// 4B21A0: using guessed type _DWORD var_68C[7];
// 4B21A0: using guessed type _DWORD var_1824[3];
// 4B21A0: using guessed type _DWORD var_670[7];
// 4B21A0: using guessed type _DWORD var_654[7];
// 4B21A0: using guessed type _DWORD var_1818[5];
// 4B21A0: using guessed type _DWORD var_1864[13];
// 4B21A0: using guessed type _DWORD var_186C[2];

//----- (004B44F0) --------------------------------------------------------
int __fastcall sub_4B44F0(WPARAM wParam, unsigned int a2, int a3, int a4, UINT Msg)
{
  int v5; // edi
  unsigned int v6; // eax
  bool v7; // cf
  HMODULE v8; // eax
  HMODULE v9; // ebx
  FARPROC ChangeWindowsMessageFilter; // eax
  void (__stdcall *v11)(int, int); // esi
  int v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // ebx
  int result; // eax
  int v16; // eax
  int v18; // eax
  _DWORD **v19; // ecx
  _DWORD *v20; // eax
  _DWORD *v21; // esi
  int v22; // ebx
  HWND v23; // [esp-4h] [ebp-180h]
  int v26; // [esp+20h] [ebp-15Ch] BYREF
  struct tagRECT Rect; // [esp+24h] [ebp-158h] BYREF
  char v28[64]; // [esp+34h] [ebp-148h] BYREF
  WCHAR Buffer[64]; // [esp+74h] [ebp-108h] BYREF
  __int16 lParam[66]; // [esp+F4h] [ebp-88h] BYREF

  v5 = a3;
  if ( Msg == *(_DWORD *)(a3 + 59540) )
  {
    v6 = *(_DWORD *)(a3 + 5576);
    v7 = v6 < 6;
    if ( v6 == 6 )
    {
      if ( !*(_DWORD *)(a3 + 5580) )
        return 0;
      v7 = 0;
    }
    if ( !v7 && *(_DWORD *)(a3 + 59432) )
    {
      v8 = sub_40A920(L"user32.dll");
      v9 = v8;
      if ( v8 )
      {
        ChangeWindowsMessageFilter = GetProcAddress(v8, "ChangeWindowsMessageFilter");
        v11 = (void (__stdcall *)(int, int))ChangeWindowsMessageFilter;
        if ( ChangeWindowsMessageFilter )
        {
          ((void (__stdcall *)(int, int))ChangeWindowsMessageFilter)(803, 1);
          v11(806, 1);
        }
        FreeLibrary(v9);
      }
      v12 = *(_DWORD *)(a3 + 59524);
      if ( v12 )
        (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v12 + 8))(*(_DWORD *)(a3 + 59524));
      CoCreateInstance(&stru_4BD8FC, 0, 1u, &stru_4BD8BC, (LPVOID *)(a3 + 59524));
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a3 + 59524) + 12))(*(_DWORD *)(a3 + 59524));
      *(_DWORD *)(a3 + 59544) = 1;
      sub_4903B0();
      v13 = *(_DWORD **)(a3 + 59528);
      v14 = (_DWORD *)*v13;
      if ( (_DWORD *)*v13 != v13 )
      {
        while ( 1 )
        {
          sub_478CB0(v14[3], a3, (int)&unk_4CB068, v14[4] == *(_DWORD *)(v5 + 5620));
          sub_4AB1F0(a3, v14[4]);
          sub_4AC150(a3, v14[4]);
          CoTaskMemFree(0);
          v14 = (_DWORD *)*v14;
          if ( v14 == *(_DWORD **)(a3 + 59528) )
            break;
          v5 = a3;
        }
      }
    }
    return 0;
  }
  if ( Msg <= 0x10 )
  {
    if ( Msg == 16 )
      return sub_48FC40(a3);
    switch ( Msg )
    {
      case 1u:
        sub_4938E0(a3);
        return DefWindowProcW((HWND)a4, Msg, wParam, a2);
      case 2u:
        result = sub_491A30(a3);
        break;
      case 5u:
        result = sub_48F210(a3, (unsigned __int16)a2, HIWORD(a2));
        break;
      case 7u:
        SetFocus(*(HWND *)(a3 + 3436));
        result = 0;
        break;
      default:
        return DefWindowProcW((HWND)a4, Msg, wParam, a2);
    }
    return result;
  }
  if ( Msg > 0x8002 )
  {
    if ( Msg <= 0x812C )
    {
      if ( Msg == 33068 )
      {
        v23 = *(HWND *)(a3 + 52);
        *(_DWORD *)(a3 + 5616) = a2 + 8;
        GetClientRect(v23, &Rect);
        SendMessageW(*(HWND *)(a3 + 52), 5u, 0, LOWORD(Rect.right) | (LOWORD(Rect.bottom) << 16));
      }
      else
      {
        switch ( Msg )
        {
          case 0x8003u:
            v19 = *(_DWORD ***)(a3 + 60456);
            v20 = *v19;
            v21 = (_DWORD *)(a3 + 60456);
            v22 = 0;
            if ( *v19 == v19 )
              goto LABEL_85;
            break;
          case 0x8011u:
            sub_4AC380(a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8033u:
            if ( *(_DWORD *)(a3 + 4 * wParam + 58872) )
              (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(a3 + 4 * wParam + 916) + 36))(*(_DWORD *)(a3 + 4 * wParam + 916));
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8034u:
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(a3 + 4 * wParam + 916) + 8))(*(_DWORD *)(a3 + 4 * wParam + 916));
            v18 = *(_DWORD *)(a3 + 4 * wParam + 516);
            *(_DWORD *)(a3 + 4 * wParam + 916) = 0;
            (*(void (__stdcall **)(int))(*(_DWORD *)v18 + 8))(v18);
            *(_DWORD *)(a3 + 4 * wParam + 516) = 0;
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8035u:
            if ( GetFocus() == *(HWND *)(a3 + 68) )
              sub_492870((_DWORD *)a3, a2);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8036u:
            sub_490FA0(a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8037u:
            if ( wParam == *(_DWORD *)(a3 + 5620) )
              sub_490070(a3, a2);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8048u:
            *(_DWORD *)(a3 + 3436) = *(_DWORD *)(a3 + 76);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8064u:
            sub_48F100(a3, wParam);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8065u:
            sub_492290(a2, a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x8066u:
            sub_48EBA0(a2, a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x80C8u:
            sub_48ECC0(a2, a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x80C9u:
            if ( a2 != 1 )
              goto LABEL_70;
            sub_469B90(149, *(HWND *)(a3 + 4 * wParam + 92));
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x80CAu:
            if ( a2 == 1 )
              sub_469B90(104, *(HWND *)(a3 + 4 * wParam + 92));
            else
LABEL_70:
              sub_469B90(0, *(HWND *)(a3 + 4 * wParam + 92));
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          case 0x80CBu:
            return (*(int (__thiscall **)(int, WPARAM))(*(_DWORD *)(a3 + 28) + 24))(a3 + 28, wParam);
          case 0x80CCu:
            if ( wParam == *(_DWORD *)(a3 + 5620) )
              sub_492490(a3);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          default:
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
        }
        while ( v20[2] != *(_DWORD *)(wParam + 8) )
        {
          v20 = (_DWORD *)*v20;
          if ( v20 == (_DWORD *)*v21 )
          {
            free((void *)wParam);
            return DefWindowProcW((HWND)a4, Msg, wParam, a2);
          }
        }
        if ( v20[3] == *(_DWORD *)(a3 + 5620) )
          v22 = v20[4];
        sub_40ABF0(&v26, (int)v21, v20);
        if ( v22 )
        {
          sub_46B2E0(0x20u, *(_DWORD *)(a3 + 59420), *(_DWORD *)(a3 + 59456), *(_QWORD *)wParam);
          LoadStringW(hInstance, 0x1FF6u, Buffer, 64);
          sub_401000(0x40u, (wchar_t *)lParam, L"%s: %s", Buffer, v28);
          SendMessageW(*(HWND *)(a3 + 64), 0x8075u, 1u, (LPARAM)lParam);
        }
LABEL_85:
        free((void *)wParam);
      }
    }
    return DefWindowProcW((HWND)a4, Msg, wParam, a2);
  }
  if ( Msg == 32770 )
  {
    if ( wParam == 13 )
      sub_4B0EB0(a3);
    return DefWindowProcW((HWND)a4, Msg, wParam, a2);
  }
  if ( Msg > 0x11F )
  {
    if ( Msg > 0x308 )
    {
      if ( Msg == 781 )
      {
        sub_48F160(wParam, a3, a2);
      }
      else if ( Msg == 793 )
      {
        sub_492740(a2, a3);
      }
    }
    else
    {
      switch ( Msg )
      {
        case 0x308u:
          sub_491870(a3);
          break;
        case 0x126u:
          sub_4B1590(wParam, (HMENU)a2, a3);
          break;
        case 0x219u:
          sub_495230(a2, (HWND *)a3, wParam);
          break;
      }
    }
    return DefWindowProcW((HWND)a4, Msg, wParam, a2);
  }
  if ( Msg == 287 )
  {
    sub_495DD0(wParam, a3, a2);
    return DefWindowProcW((HWND)a4, Msg, wParam, a2);
  }
  switch ( Msg )
  {
    case 0x2Bu:
      result = sub_48FB40((_DWORD *)a2);
      break;
    case 0x2Cu:
      result = sub_48F090((UINT *)a2, a3);
      break;
    case 0x4Au:
      v16 = *(_DWORD *)(a2 + 8);
      if ( v16 )
      {
        sub_48FFD0(v16, a3, 0, 1, 1);
      }
      else if ( sub_48FFD0(a3 + 4532, a3, 0, 1, 1) < 0 )
      {
        sub_48FFD0(a3 + 4012, a3, 0, 1, 1);
      }
      return DefWindowProcW((HWND)a4, Msg, wParam, a2);
    case 0x4Eu:
      result = sub_4B1640(a3, (int *)a2);
      break;
    case 0x111u:
      result = sub_4B21A0(a3, (HWND)a4, wParam);
      break;
    case 0x116u:
      *(_DWORD *)(*(_DWORD *)(a3 + 3412) + 4) = wParam;
      sub_4AB810((HMENU)wParam, a3);
      return DefWindowProcW((HWND)a4, Msg, wParam, a2);
    default:
      return DefWindowProcW((HWND)a4, Msg, wParam, a2);
  }
  return result;
}
// 4CB06C: using guessed type wchar_t aSS_15[7];
// 4B44F0: using guessed type char var_148[64];
// 4B44F0: using guessed type wchar_t lParam[66];

//----- (004B4E00) --------------------------------------------------------
int __stdcall sub_4B4E00(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int WindowLongW; // esi
  void *v5; // eax
  int v6; // eax

  WindowLongW = GetWindowLongW(hWnd, -21);
  if ( Msg == 129 )
  {
    v5 = operator new(0xEF88u);
    if ( v5 )
      v6 = sub_4A1250((int)v5, (int)hWnd);
    else
      v6 = 0;
    WindowLongW = v6;
    if ( !v6 )
    {
      PostQuitMessage(0);
      return 0;
    }
    SetWindowLongW(hWnd, -21, v6);
  }
  if ( WindowLongW )
    return sub_4B44F0(wParam, lParam, WindowLongW, (int)hWnd, Msg);
  else
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (004B4EF0) --------------------------------------------------------
int __userpurge sub_4B4EF0@<eax>(int a1@<eax>, int a2, int a3, WPARAM wParam, LPARAM lParam)
{
  int v5; // esi
  int v7; // eax
  WPARAM v8; // eax

  v5 = a3;
  if ( (unsigned int)a3 > 0x111 )
  {
    if ( a3 == 278 )
    {
      SendMessageW(*(HWND *)(a1 + 52), 0x116u, wParam, lParam);
    }
    else if ( a3 == 515 && sub_48FFD0(a1 + 4532, a1, 0, 1, 1) < 0 )
    {
      sub_48FFD0(a1 + 4012, a1, 0, 1, 1);
    }
  }
  else
  {
    switch ( a3 )
    {
      case 273:
        if ( (_WORD)wParam == 5033 )
        {
          v8 = SendMessageW(*(HWND *)(a1 + 68), 0x130Bu, 0, 0);
          sub_479C50(a1, v8);
        }
        break;
      case 44:
        *(_DWORD *)(lParam + 12) = 20;
        *(_DWORD *)(lParam + 16) = 10;
        break;
      case 78:
        v7 = *(_DWORD *)(lParam + 8);
        if ( v7 == -551 )
        {
          sub_479BD0(a1);
          v5 = 78;
        }
        else if ( v7 == -530 )
        {
          sub_48F1A0(a1, (_DWORD *)lParam);
          v5 = 78;
        }
        break;
    }
  }
  return sub_401C60(a2, v5, wParam, lParam);
}

//----- (004B5000) --------------------------------------------------------
int __stdcall sub_4B5000(int a1, int a2, WPARAM wParam, LPARAM lParam, int a5, int a6)
{
  return sub_4B4EF0(a6, a1, a2, wParam, lParam);
}

//----- (004B551A) --------------------------------------------------------
int sub_4B551A()
{
  dword_4F24B4 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 4F24B4: using guessed type int dword_4F24B4;

//----- (004BC810) --------------------------------------------------------
int sub_4BC810()
{
  _DWORD *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = operator new(0x408u);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF6EC = v0;
  *v0 = v0;
  *((_DWORD *)dword_4EF6EC + 1) = dword_4EF6EC;
  return atexit(sub_4BCC00);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BC870) --------------------------------------------------------
int sub_4BC870()
{
  _DWORD *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = operator new(0x408u);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF6F8 = v0;
  *v0 = v0;
  *((_DWORD *)dword_4EF6F8 + 1) = dword_4EF6F8;
  return atexit(sub_4BCC50);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BC8D0) --------------------------------------------------------
int sub_4BC8D0()
{
  char *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = (char *)operator new(0x24u);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF704 = v0;
  *(_DWORD *)v0 = v0;
  *((_DWORD *)dword_4EF704 + 1) = dword_4EF704;
  return atexit(sub_4BCD80);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BC930) --------------------------------------------------------
int __fastcall sub_4BC930(int a1)
{
  __int16 v2; // [esp+0h] [ebp-2h] BYREF

  v2 = HIWORD(a1);
  sub_4187F0((char *)&v2);
  return atexit(sub_4BCDA0);
}

//----- (004BC950) --------------------------------------------------------
int sub_4BC950()
{
  int result; // eax

  word_4EF73C = RegisterClipboardFormatW(L"FileGroupDescriptorW");
  result = 1;
  dword_4EF740 = 0;
  dword_4EF744 = 1;
  dword_4EF748 = -1;
  dword_4EF74C = 1;
  return result;
}
// 4EF73C: using guessed type __int16 word_4EF73C;
// 4EF740: using guessed type int dword_4EF740;
// 4EF744: using guessed type int dword_4EF744;
// 4EF748: using guessed type int dword_4EF748;
// 4EF74C: using guessed type int dword_4EF74C;

//----- (004BC990) --------------------------------------------------------
int sub_4BC990()
{
  int result; // eax

  word_4EF750 = RegisterClipboardFormatW(L"Shell IDList Array");
  result = 1;
  dword_4EF754 = 0;
  dword_4EF758 = 1;
  dword_4EF75C = -1;
  dword_4EF760 = 1;
  return result;
}
// 4EF750: using guessed type __int16 word_4EF750;
// 4EF754: using guessed type int dword_4EF754;
// 4EF758: using guessed type int dword_4EF758;
// 4EF75C: using guessed type int dword_4EF75C;
// 4EF760: using guessed type int dword_4EF760;

//----- (004BC9D0) --------------------------------------------------------
int sub_4BC9D0()
{
  char *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = (char *)operator new(0x10u);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF764 = v0;
  *(_DWORD *)v0 = v0;
  *((_DWORD *)dword_4EF764 + 1) = dword_4EF764;
  return atexit(sub_4BCDB0);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BCA30) --------------------------------------------------------
int sub_4BCA30()
{
  char *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = (char *)operator new(0x14u);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF770 = v0;
  *(_DWORD *)v0 = v0;
  *((_DWORD *)dword_4EF770 + 1) = dword_4EF770;
  return atexit(sub_4BCDD0);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BCA90) --------------------------------------------------------
int sub_4BCA90()
{
  char *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = (char *)operator new(0x1Cu);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF77C = v0;
  *(_DWORD *)v0 = v0;
  *((_DWORD *)dword_4EF77C + 1) = dword_4EF77C;
  return atexit(sub_4BCDF0);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BCAF0) --------------------------------------------------------
int sub_4BCAF0()
{
  char *v0; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  v0 = (char *)operator new(0x1Cu);
  if ( !v0 )
  {
    v3 = 0;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  dword_4EF788 = v0;
  *(_DWORD *)v0 = v0;
  *((_DWORD *)dword_4EF788 + 1) = dword_4EF788;
  return atexit(sub_4BCE40);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';

//----- (004BCB4D) --------------------------------------------------------
int sub_4BCB4D()
{
  return atexit(sub_4BCE88);
}

//----- (004BCB59) --------------------------------------------------------
int sub_4BCB59()
{
  return atexit(sub_4BCE93);
}

//----- (004BCB65) --------------------------------------------------------
int sub_4BCB65()
{
  return atexit(sub_4BCE9E);
}

//----- (004BCB71) --------------------------------------------------------
int sub_4BCB71()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4EE0F8);
  return atexit(sub_4BCEA9);
}

//----- (004BCB87) --------------------------------------------------------
int sub_4BCB87()
{
  return atexit(sub_4BCEBD);
}

//----- (004BCB93) --------------------------------------------------------
int sub_4BCB93()
{
  return atexit(sub_4BCEB3);
}

//----- (004BCB9F) --------------------------------------------------------
int sub_4BCB9F()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4EE2A0);
  return atexit(sub_4BCEEF);
}

//----- (004BCBB5) --------------------------------------------------------
int sub_4BCBB5()
{
  return atexit(sub_4BCEF9);
}

//----- (004BCBD0) --------------------------------------------------------
void __cdecl sub_4BCBD0()
{
  dword_4F14C8 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F14C8: using guessed type int dword_4F14C8;

//----- (004BCBE0) --------------------------------------------------------
void __cdecl sub_4BCBE0()
{
  dword_4F12A8 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F12A8: using guessed type int dword_4F12A8;

//----- (004BCBF0) --------------------------------------------------------
void __cdecl sub_4BCBF0()
{
  dword_4F1088 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F1088: using guessed type int dword_4F1088;

//----- (004BCC00) --------------------------------------------------------
void __cdecl sub_4BCC00()
{
  void **v0; // eax
  void *v1; // ecx
  void **v2; // esi

  v0 = *(void ***)dword_4EF6EC;
  *(_DWORD *)dword_4EF6EC = dword_4EF6EC;
  *((_DWORD *)dword_4EF6EC + 1) = dword_4EF6EC;
  v1 = dword_4EF6EC;
  dword_4EF6F0 = 0;
  if ( v0 != dword_4EF6EC )
  {
    do
    {
      v2 = (void **)*v0;
      operator delete(v0);
      v1 = dword_4EF6EC;
      v0 = v2;
    }
    while ( v2 != dword_4EF6EC );
  }
  operator delete(v1);
}
// 4EF6F0: using guessed type int dword_4EF6F0;

//----- (004BCC50) --------------------------------------------------------
void __cdecl sub_4BCC50()
{
  void **v0; // eax
  void *v1; // ecx
  void **v2; // esi

  v0 = *(void ***)dword_4EF6F8;
  *(_DWORD *)dword_4EF6F8 = dword_4EF6F8;
  *((_DWORD *)dword_4EF6F8 + 1) = dword_4EF6F8;
  v1 = dword_4EF6F8;
  dword_4EF6FC = 0;
  if ( v0 != dword_4EF6F8 )
  {
    do
    {
      v2 = (void **)*v0;
      operator delete(v0);
      v1 = dword_4EF6F8;
      v0 = v2;
    }
    while ( v2 != dword_4EF6F8 );
  }
  operator delete(v1);
}
// 4EF6FC: using guessed type int dword_4EF6FC;

//----- (004BCCA0) --------------------------------------------------------
void __cdecl sub_4BCCA0()
{
  dword_4F1FE0 = (int)&CFilterDialogPersistentSettings::`vftable';
  sub_40A140((int)&dword_4F21FC);
  operator delete(dword_4F21FC);
  dword_4F1FE0 = (int)&CDialogSettings::`vftable';
}
// 4CBDA4: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F1FE0: using guessed type int dword_4F1FE0;

//----- (004BCCD0) --------------------------------------------------------
void __cdecl sub_4BCCD0()
{
  dword_4F0E60 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F0E60: using guessed type int dword_4F0E60;

//----- (004BCCE0) --------------------------------------------------------
void __cdecl sub_4BCCE0()
{
  dword_4F0C40 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F0C40: using guessed type int dword_4F0C40;

//----- (004BCCF0) --------------------------------------------------------
void __cdecl sub_4BCCF0()
{
  dword_4F0A18 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F0A18: using guessed type int dword_4F0A18;

//----- (004BCD00) --------------------------------------------------------
void __cdecl sub_4BCD00()
{
  sub_4820E0((int)&dword_4F1B60);
}
// 4F1B60: using guessed type int dword_4F1B60;

//----- (004BCD10) --------------------------------------------------------
void __cdecl sub_4BCD10()
{
  dword_4F07F8 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F07F8: using guessed type int dword_4F07F8;

//----- (004BCD20) --------------------------------------------------------
void __cdecl sub_4BCD20()
{
  dword_4F05D8 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F05D8: using guessed type int dword_4F05D8;

//----- (004BCD30) --------------------------------------------------------
void __cdecl sub_4BCD30()
{
  dword_4F03B8 = (int)&CDialogSettings::`vftable';
}
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F03B8: using guessed type int dword_4F03B8;

//----- (004BCD40) --------------------------------------------------------
void __cdecl sub_4BCD40()
{
  sub_47C430((int)&dword_4F2230);
}
// 4F2230: using guessed type int dword_4F2230;

//----- (004BCD50) --------------------------------------------------------
void __cdecl sub_4BCD50()
{
  dword_4F1728 = (int)&CWildcardSelectDialogPersistentSettings::`vftable';
  sub_40A140((int)&dword_4F1B44);
  operator delete(dword_4F1B44);
  dword_4F1728 = (int)&CDialogSettings::`vftable';
}
// 4CC310: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 4CC3D0: using guessed type void *CDialogSettings::`vftable';
// 4F1728: using guessed type int dword_4F1728;

//----- (004BCD80) --------------------------------------------------------
void __cdecl sub_4BCD80()
{
  sub_40A140((int)&dword_4EF704);
  operator delete(dword_4EF704);
}

//----- (004BCDB0) --------------------------------------------------------
void __cdecl sub_4BCDB0()
{
  sub_41BBB0();
  operator delete(dword_4EF764);
}

//----- (004BCDD0) --------------------------------------------------------
void __cdecl sub_4BCDD0()
{
  sub_41EE70();
  operator delete(dword_4EF770);
}

//----- (004BCDF0) --------------------------------------------------------
void __cdecl sub_4BCDF0()
{
  char *v0; // eax
  char *v1; // ecx
  char *v2; // esi

  v0 = *(char **)dword_4EF77C;
  *(_DWORD *)dword_4EF77C = dword_4EF77C;
  *((_DWORD *)dword_4EF77C + 1) = dword_4EF77C;
  v1 = dword_4EF77C;
  dword_4EF780 = 0;
  if ( v0 != dword_4EF77C )
  {
    do
    {
      v2 = *(char **)v0;
      operator delete(v0);
      v1 = dword_4EF77C;
      v0 = v2;
    }
    while ( v2 != dword_4EF77C );
  }
  operator delete(v1);
}
// 4EF780: using guessed type int dword_4EF780;

//----- (004BCE40) --------------------------------------------------------
void __cdecl sub_4BCE40()
{
  char *v0; // eax
  char *v1; // ecx
  char *v2; // esi

  v0 = *(char **)dword_4EF788;
  *(_DWORD *)dword_4EF788 = dword_4EF788;
  *((_DWORD *)dword_4EF788 + 1) = dword_4EF788;
  v1 = dword_4EF788;
  dword_4EF78C = 0;
  if ( v0 != dword_4EF788 )
  {
    do
    {
      v2 = *(char **)v0;
      operator delete(v0);
      v1 = dword_4EF788;
      v0 = v2;
    }
    while ( v2 != dword_4EF788 );
  }
  operator delete(v1);
}
// 4EF78C: using guessed type int dword_4EF78C;

//----- (004BCE88) --------------------------------------------------------
void __cdecl sub_4BCE88()
{
  off_4DE0C8 = (int (__thiscall *)(void *, char))&std::error_category::`vftable';
}
// 4BDA4C: using guessed type void *std::error_category::`vftable';
// 4DE0C8: using guessed type int (__thiscall *off_4DE0C8)(void *, char);

//----- (004BCE93) --------------------------------------------------------
void __cdecl sub_4BCE93()
{
  off_4DE0D0 = (int (__thiscall *)(void *, char))&std::error_category::`vftable';
}
// 4BDA4C: using guessed type void *std::error_category::`vftable';
// 4DE0D0: using guessed type int (__thiscall *off_4DE0D0)(void *, char);

//----- (004BCE9E) --------------------------------------------------------
void __cdecl sub_4BCE9E()
{
  off_4DE0D8 = (int (__thiscall *)(void *, char))&std::error_category::`vftable';
}
// 4BDA4C: using guessed type void *std::error_category::`vftable';
// 4DE0D8: using guessed type int (__thiscall *off_4DE0D8)(void *, char);

//----- (004BCEA9) --------------------------------------------------------
void __cdecl sub_4BCEA9()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( InterlockedDecrement(&Addend) < 0 )
  {
    v0 = &stru_4EE098;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4EE0F8 );
  }
}

//----- (004BCEB3) --------------------------------------------------------
void __cdecl sub_4BCEB3()
{
  sub_408B00(&dword_4EE11C);
}
// 4EE11C: using guessed type int dword_4EE11C;

//----- (004BCEBD) --------------------------------------------------------
void __cdecl sub_4BCEBD()
{
  unknown_libname_3(&unk_4EE124);
}
// 426EDC: using guessed type int __thiscall unknown_libname_3(_DWORD);

//----- (004BCEC7) --------------------------------------------------------
void __cdecl sub_4BCEC7()
{
  dword_4EE248[0] = &std::bad_alloc::`vftable';
  sub_4398D8((std::exception *)dword_4EE248);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4EE248: using guessed type _DWORD dword_4EE248[3];

//----- (004BCEDB) --------------------------------------------------------
void __cdecl sub_4BCEDB()
{
  dword_4EE220[0] = &std::bad_alloc::`vftable';
  sub_4398D8((std::exception *)dword_4EE220);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4EE220: using guessed type _DWORD dword_4EE220[3];

//----- (004BCEEF) --------------------------------------------------------
void __cdecl sub_4BCEEF()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( InterlockedDecrement(&Addend) < 0 )
  {
    v0 = &stru_4EE098;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4EE0F8 );
  }
}

//----- (004BCEF9) --------------------------------------------------------
void __cdecl sub_4BCEF9()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_4EE2A1);
}

//----- (004BCF03) --------------------------------------------------------
void __cdecl sub_4BCF03()
{
  dword_4EE378[0] = &std::bad_alloc::`vftable';
  sub_4398D8((std::exception *)dword_4EE378);
}
// 4BDA8C: using guessed type void *std::bad_alloc::`vftable';
// 4EE378: using guessed type _DWORD dword_4EE378[3];

// nfuncs=2985 queued=2228 decompiled=2228 lumina nreq=0 worse=0 better=0
// ALL OK, 2228 function(s) have been successfully decompiled
