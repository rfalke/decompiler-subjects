/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 sub_140001000(wchar_t *, unsigned __int64, const wchar_t *, ...);
__int64 __fastcall sub_140001080(_WORD *, unsigned __int64, __int64);
INT_PTR __fastcall sub_140001150(LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
__int64 __fastcall sub_140001240(_WORD *, unsigned __int64, __int64);
__int64 __fastcall sub_1400012C0(__int64, __int64, __int64);
__int64 sub_1400013C0();
__int64 __fastcall sub_1400015A0(ULONG_PTR *lpCookie); // idb
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
FARPROC __fastcall sub_140001610(LPCSTR lpProcName);
__int64 __fastcall sub_1400016D0(unsigned int, unsigned int, unsigned int, unsigned int, int);
FARPROC __fastcall sub_1400017F0(LPCSTR lpProcName);
__int64 __fastcall sub_1400018B0(__int64);
void __fastcall sub_1400019A0(std::exception *);
std::exception *__fastcall sub_1400019B0(std::exception *, const struct std::exception *);
void *__fastcall sub_1400019E0(void *Block, char);
__int64 __fastcall sub_140001A20(__int64, unsigned int, __int64, __int64);
_QWORD *__fastcall sub_140001B30(_QWORD *, char);
void __fastcall sub_140001B60(__int64);
// __int64 __fastcall sub_140001BE0(_QWORD, _QWORD); weak
_QWORD *__fastcall sub_140001DE0(_QWORD *, _QWORD *, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_140001E20(__int64);
__int64 __fastcall sub_140001EC0(__int64, unsigned __int16);
__int64 __fastcall sub_140002180(__int64, unsigned __int16);
__int64 __fastcall sub_1400021E0(__int64);
__int64 __fastcall sub_140002280(__int64, __int64, __int64, int, char);
__int64 __fastcall sub_140002440(__int64, __int64, __int64, char);
void *__fastcall sub_140002570(__int64, char);
void *__fastcall sub_1400025B0(void *Block, char);
_QWORD *__fastcall sub_1400025E0(_QWORD *, __int64);
_QWORD *__fastcall sub_140002680(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, bool *);
_QWORD *__fastcall sub_1400029E0(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, _WORD *);
_QWORD *__fastcall sub_140002B90(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, int *);
_QWORD *__fastcall sub_140002D30(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, _DWORD *);
_QWORD *__fastcall sub_140002EB0(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, _DWORD *);
_QWORD *__fastcall sub_140003030(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, __int64 *);
_QWORD *__fastcall sub_1400031B0(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, __int64 *);
_QWORD *__fastcall sub_140003330(int, _QWORD *, __int64, __int64, __int64, _DWORD *, float *);
_QWORD *__fastcall sub_140003460(int, _QWORD *, __int64, __int64, __int64, _DWORD *, double *);
_QWORD *__fastcall sub_140003590(int, _QWORD *, __int64, __int64, __int64, _DWORD *, double *);
_QWORD *__fastcall sub_1400036C0(__int64, _QWORD *, __int64, __int64, __int64, _DWORD *, __int64 *);
// __int64 __fastcall sub_140003840(_QWORD); weak
_DWORD *__fastcall sub_140003930(__int64, const void *, unsigned __int64);
__int64 __fastcall sub_140003A10(__int64, __int64, __int64, __int64, __int16, __int64 *);
// __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
// __int64 __fastcall unknown_libname_1(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_2(_QWORD, _QWORD); weak
__int64 __fastcall sub_140005450(__int64);
__int64 __fastcall sub_140005460(__int64);
_QWORD *__fastcall sub_140005470(__int64, _QWORD *);
_QWORD *__fastcall sub_1400054C0(__int64, _QWORD *);
_QWORD *__fastcall sub_140005510(__int64, _QWORD *);
void *__fastcall sub_140005560(void *Block, char);
_QWORD *__fastcall sub_1400055C0(_QWORD *, size_t, char);
__int64 __fastcall sub_1400056C0(__int64);
void *__fastcall sub_140005760(void *Src, unsigned __int64, __int16);
__int64 __fastcall sub_140006CE0(__int64);
// __int64 __fastcall unknown_libname_3(_QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_4(_QWORD); weak
void *__fastcall sub_140006D60(void *, size_t Size, char);
void *__fastcall sub_140006E60(void *Src, _QWORD *, unsigned __int64, unsigned __int64);
void __fastcall sub_140006F90(_QWORD *, __int64, __int64, __int16);
void __fastcall sub_140006FE0(__int64 *);
__int64 __fastcall sub_140007050(__int64 *);
__int64 __fastcall sub_1400070B0(__int64);
__int64 __fastcall sub_140007200(__int64 *);
__int64 __fastcall sub_140007350(__int64 *, __int64 *, size_t, __int16 *);
char __fastcall sub_140007740(__int64, __int64);
__int64 __fastcall sub_1400077B0(_QWORD *, __int64);
char __fastcall sub_140007870(__int64, __int64);
// __int64 __fastcall sub_1400078D0(_QWORD, _QWORD); weak
int __fastcall sub_140007990(__int64, __int64, char);
wchar_t *__fastcall sub_140007BE0(char *, __int64, const _Cvtvec *);
_QWORD *__fastcall sub_140007CE0(_QWORD *, unsigned __int64, unsigned __int64);
// __int64 __fastcall std::string::assign(void *); idb
void *__fastcall sub_140007E90(__int64, size_t);
void __fastcall sub_140007EF0(void *Src, unsigned __int64, size_t);
bool __fastcall sub_140008030(size_t *, unsigned __int64, char);
size_t *__fastcall sub_140008100(void *, void *Src, size_t Size);
void __fastcall sub_140008230(__int64);
void __fastcall sub_140008270(__int64);
void *__fastcall sub_140008330(void *Block, char);
__int64 sub_1400083A0();
__int64 __fastcall sub_1400083B0(__int64, _WORD *, __int64);
// __int64 __fastcall unknown_libname_5(_QWORD); weak
__int64 sub_1400084B0();
__int64 __fastcall sub_1400084C0(__int64, unsigned __int16 *, __int64);
__int64 __fastcall sub_1400085C0(__int64);
__int64 __fastcall sub_1400085D0(_QWORD *);
char *__fastcall sub_140008620(struct std::ios_base *, char);
void __fastcall sub_1400086A0(__int64);
void __fastcall sub_1400086B0(__int64);
__int64 __fastcall sub_1400086F0(__int64);
unsigned __int16 *__fastcall sub_1400087D0(__int64, unsigned __int16, unsigned __int16 *, unsigned __int16 *);
unsigned __int16 *__fastcall sub_140008840(__int64, unsigned __int16, unsigned __int16 *, unsigned __int16 *);
wchar_t *__fastcall sub_1400088B0(__int64, wchar_t *, wchar_t *);
wchar_t *__fastcall sub_140008910(__int64, wchar_t *, wchar_t *);
char *__fastcall sub_140008970(__int64, char *, char *, __int64);
wchar_t *__fastcall sub_140008A60(__int64, wchar_t *, wchar_t *, char, _BYTE *);
// __int64 __fastcall std::_Locinfo::_Locinfo(std::_Locinfo *__hidden this, const char *); idb
void __fastcall sub_140008C10(void **);
// __int64 __fastcall sub_140008C40(std::_Lockit *this); idb
// __int64 __fastcall sub_140008CC0(_QWORD, _QWORD); weak
__int64 __fastcall sub_140008DB0(__int64 *);
__int64 *__fastcall sub_140008F00(__int64, __int64 *);
__int64 __fastcall sub_140008F50(__int64);
void __fastcall sub_140008FC0(__int64 *);
__int64 __fastcall sub_140009030(__int64);
// __int64 __fastcall unknown_libname_13(_QWORD); weak
__int64 __fastcall sub_140009090(int **);
std::exception *__fastcall sub_140009170(std::exception *, const struct std::exception *);
std::exception *__fastcall sub_1400091C0(std::exception *, const struct std::exception *);
void *__fastcall sub_140009200(void *Block, char);
std::exception *__fastcall sub_140009230(std::exception *, const struct std::exception *);
__int64 __fastcall sub_140009260(__int64, char, char);
char __fastcall sub_140009380(__int64);
void *__fastcall sub_140009520(void *Block, char);
void __fastcall sub_140009560(struct std::ios_base *);
_QWORD *__fastcall sub_140009570(_QWORD *, unsigned __int64, unsigned __int64);
void *__fastcall sub_140009610(void *Src, _QWORD *, unsigned __int64, unsigned __int64);
void *__fastcall sub_140009740(__int64, unsigned __int64);
void __fastcall sub_1400097B0(void *Src, unsigned __int64, const void *);
bool __fastcall sub_140009900(const void **, unsigned __int64, char);
_QWORD *__fastcall sub_1400099E0(void *Src, void *, unsigned __int64);
__int64 __fastcall sub_140009B40(__int64);
__int64 __fastcall sub_140009C20(__int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_140009D30(_QWORD *);
__int64 __fastcall sub_140009D40(__int64, __int64);
void __fastcall sub_140009DD0(unsigned __int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_140009E90(_QWORD *);
// __int64 __fastcall sub_140009F50(_QWORD, _QWORD); weak
void __fastcall sub_14000A090(void *Src, void *);
_DWORD *__fastcall sub_14000A200(_DWORD *, _DWORD *, _DWORD *);
_QWORD *__fastcall sub_14000A280(_QWORD *, _QWORD *);
__int64 __fastcall sub_14000A300(__int64, __int64, __int64);
__int64 __fastcall sub_14000A390(__int64);
__int64 __fastcall sub_14000A470(__int64, unsigned int, unsigned int);
void __fastcall sub_14000A570(void *);
void __fastcall sub_14000A590(void *);
_QWORD *__fastcall sub_14000A5B0(_QWORD *);
void __fastcall sub_14000A630(__int64);
void __fastcall sub_14000A6B0(__int64, __int64, _QWORD *, _QWORD *);
char *__fastcall sub_14000A760(__int64, __int64, _QWORD *);
__int64 __fastcall sub_14000A830(__int64);
_QWORD *__fastcall sub_14000A910(_QWORD *);
__int64 __fastcall sub_14000A980(__int64);
void __fastcall sub_14000A9C0(void **);
void __fastcall sub_14000AA30(void **);
void __fastcall sub_14000AA90(void **);
_QWORD *__fastcall sub_14000AB00(_QWORD *);
_QWORD *__fastcall sub_14000AB70(_QWORD *);
void __fastcall sub_14000ABE0(__int64);
void __fastcall sub_14000AC40(__int64);
void __fastcall sub_14000AD00(__int64);
__int64 __fastcall sub_14000AEE0(__int64);
__int64 __fastcall sub_14000AEF0(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_14000AF00(__int64);
__int64 __fastcall sub_14000AF10(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_14000AF20(__int64);
__int64 __fastcall sub_14000AF30(__int64);
__int64 __fastcall sub_14000AF40(__int64);
__int64 __fastcall sub_14000AF50(__int64);
__int64 __fastcall sub_14000AF60(__int64, _QWORD *, _QWORD *);
HMODULE __fastcall sub_14000AF70(LPCWSTR lpLibFileName);
void *__fastcall sub_14000B030(void *Block, char);
__int64 __fastcall sub_14000B0A0(__int64, __int64);
void __fastcall sub_14000B120(__int64);
__int64 **__fastcall sub_14000B180(__int64 **, _QWORD ***);
__int64 **__fastcall sub_14000B220(__int64 **, _QWORD ***);
__int64 **__fastcall sub_14000B2C0(__int64 **, _QWORD ***);
_QWORD *__fastcall sub_14000B360(_QWORD *);
void __fastcall sub_14000B3D0(void **);
void *__fastcall sub_14000B3F0(void *, void *Src);
_QWORD *__fastcall sub_14000B490(_QWORD *);
char *__fastcall sub_14000B500(__int64, __int64, const void *);
void __fastcall sub_14000B5B0(__int64);
char *__fastcall sub_14000B650(__int64, __int64, _QWORD *);
void *__fastcall sub_14000B710(void *, _WORD *, void *);
_QWORD *__fastcall sub_14000B780(void *Src, void *, unsigned __int64);
void *__fastcall sub_14000B910(void *Src, _QWORD *, unsigned __int64, unsigned __int64);
void __fastcall sub_14000BAC0(__int64, __int64, _QWORD *, _QWORD *);
char *__fastcall sub_14000BB70(__int64, __int64, _QWORD *);
void __fastcall sub_14000BC10(__int64, __int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_14000BCC0(__int64, _QWORD *);
__int64 **__fastcall sub_14000BD40(__int64 **, __int64 **);
void __fastcall sub_14000BDC0(__int64, __int64, _QWORD *, _QWORD *);
_QWORD *__fastcall sub_14000BE80(_QWORD *, char);
void *__fastcall sub_14000BEB0(_QWORD *);
void *__fastcall sub_14000BF20(void *Block, char);
void *__fastcall sub_14000BF50(_QWORD *);
void *__fastcall sub_14000BFF0(void *Block, char);
__int64 __fastcall sub_14000C020(_QWORD *);
void __fastcall sub_14000C050(__int64);
__int64 __fastcall sub_14000C080(__int64);
void __fastcall sub_14000C260(__int64 *);
__int64 *__fastcall sub_14000C290(__int64 *, __int64, unsigned int);
_QWORD *__fastcall sub_14000C330(_QWORD *);
void **__fastcall sub_14000C3E0(__int64);
__int64 __fastcall sub_14000C460(__int64, __int64);
__int64 __fastcall sub_14000C4E0(__int64, char);
char *__fastcall sub_14000C540(struct std::ios_base *, char);
void *__fastcall sub_14000C5C0(void *Src, unsigned __int64, char *, _QWORD *, __int64, __int64);
_QWORD *__fastcall sub_14000C940(void *Src, unsigned __int64, char *, unsigned __int64);
__int64 __fastcall sub_14000CB60(char *, _WORD *, unsigned __int64);
__int64 __fastcall sub_14000CC60(__int64 *);
__int64 __fastcall sub_14000CCE0(__int64, char);
__int64 __fastcall sub_14000CD50(__int64, __int64);
__int128 *__fastcall sub_14000D380(__int64, __int128 *, __int128 *, __int64, unsigned __int16, unsigned int);
__int128 *__fastcall sub_14000D480(__int64, __int128 *, __int128 *, __int64, unsigned __int16, unsigned int);
__int128 *__fastcall sub_14000D580(__int64, __int128 *, __int128 *, __int64, unsigned __int16, __int64);
__int128 *__fastcall sub_14000D680(__int64, __int128 *, __int128 *, __int64, unsigned __int16, __int64);
__int128 *__fastcall sub_14000D780(__int64, __int128 *, __int128 *, __int64, __int16, __int64);
__int128 *__fastcall sub_14000D990(__int64, __int128 *, __int128 *, __int64, __int16, __int64);
_QWORD *__fastcall sub_14000DC30(_QWORD *, char);
__int128 *__fastcall sub_14000DC60(__int64, __int128 *, __int128 *, __int64, __int16, void *Buf, __int64, __int64, __int64, size_t MaxCount);
__int128 *__fastcall sub_14000E7A0(__int64, __int128 *, __int64, __int64, unsigned __int16, char *, size_t);
_QWORD *__fastcall sub_14000EB70(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int16 a4, __int64 a5);
_QWORD *__fastcall sub_14000EC20(void *Src, void *, size_t Size);
_QWORD *__fastcall sub_14000ED60(__int64 a1, _QWORD *a2, _QWORD *a3, char *a4, __int64 a5);
__int128 *__fastcall sub_14000EE60(__int64, __int128 *, __int128 *, char *, size_t MaxCount, unsigned __int16);
__int64 __fastcall sub_14000F050(__int64, unsigned __int16);
_QWORD *__fastcall sub_14000F0C0(_QWORD *, _QWORD *, unsigned __int64, size_t);
void *__fastcall sub_14000F1E0(void *, void *Src, _QWORD *);
__int64 __fastcall sub_14000F240(__int64);
__int64 __fastcall sub_14000F390(_QWORD *, __int64);
char __fastcall sub_14000F450(unsigned __int16 *a1, unsigned __int16 *a2, _QWORD *a3, __int64 *a4, __int64 a5);
__int64 __fastcall sub_14000F600(__int64, __int64, __int64, __int64, unsigned int);
__int64 __fastcall sub_14000F6D0(__int64);
__int64 __fastcall sub_14000F760(__int64, __int64, __int64, __int64, char, int, int);
unsigned __int16 **__fastcall sub_14000F870(__int64, unsigned __int16 **, unsigned __int16 *, unsigned __int16 *, __int64);
bool __fastcall sub_14000FC70(__int64, __int64, char);
char __fastcall sub_14000FDE0(__int64);
__int64 __fastcall sub_14000FFE0(__int64);
__int64 __fastcall sub_140010150(__int64, __int64, unsigned int);
__int64 __fastcall sub_1400101E0(__int64, __int64);
_DWORD *__fastcall sub_1400102A0(__int64, int);
__int64 __fastcall sub_140010330(__int64, unsigned __int16);
__int64 __fastcall sub_1400103B0(__int64, unsigned __int16, unsigned __int16);
void *__fastcall sub_140010430(__int64);
void *__fastcall sub_140010510(void *Block, char);
__int64 __fastcall sub_140010540(__int64);
// __int64 __fastcall sub_1400105F0(_QWORD); weak
unsigned __int64 __fastcall sub_1400106A0(__int64 *, unsigned __int64);
__int64 __fastcall sub_140010820(__int64, __int64);
_QWORD *__fastcall sub_140010880(const _Collvec *, _QWORD *, const wchar_t *, const wchar_t *);
__int64 __fastcall sub_140010980(__int64, unsigned __int16 *, unsigned __int16 *);
_QWORD *__fastcall sub_1400109B0(__int64, _QWORD *);
// __int64 __fastcall sub_140010A00(_QWORD, _QWORD); weak
bool __fastcall sub_140010B40(__int64 *, char *, __int64);
__int64 *__fastcall sub_140011080(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int16 *a5, __int64 a6, __int64 a7, char a8);
_QWORD *__fastcall sub_1400111B0(_QWORD *, _WORD *, _WORD *, unsigned int *);
// __int64 __fastcall sub_140011260(_QWORD, _QWORD, _QWORD); weak
bool __fastcall sub_140011590(__int64);
char __fastcall sub_1400115D0(__int64);
__int64 __fastcall sub_140011630(__int64);
bool __fastcall sub_140011A80(__int64);
_QWORD *__fastcall sub_140011AC0(__int64, __int64);
__int64 __fastcall sub_140011BB0(__int64, __int64, __int64);
_DWORD *__fastcall sub_140011C60(__int64, int);
__int64 __fastcall sub_140011CF0(__int64 *);
std::exception *__fastcall sub_140011E40(std::exception *, const struct std::exception *);
// __int64 __fastcall sub_140011E70(_QWORD, _QWORD); weak
char __fastcall sub_140011F90(__int64, __int64, unsigned int);
char __fastcall sub_140012080(void *Src, __int64, char, unsigned int);
char __fastcall sub_140012240(__int64 *, __int64);
bool __fastcall sub_140012420(__int64);
__int64 *__fastcall sub_1400124F0(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int16 *a5, __int64 a6, __int64 a7, char a8);
__int64 *__fastcall sub_140012610(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int64 a5, __int64 a6, char a7);
__int64 *__fastcall sub_1400127A0(__int64 *a1, _WORD *a2, _WORD *a3, unsigned __int16 *a4, __int64 a5, __int64 a6, char a7);
_QWORD *__fastcall sub_140012890(__int64, _QWORD *, __int16 *, __int16 *);
char __fastcall sub_1400129B0(__int64, int, unsigned int);
char __fastcall sub_140012A20(__int64);
char __fastcall sub_140012AE0(__int64);
char __fastcall sub_140012BB0(int *);
__int64 __fastcall sub_140012D10(__int64);
__int64 __fastcall sub_140012EB0(__int64, unsigned __int16);
__int64 __fastcall sub_140012F70(__int64, __int64);
__int64 *__fastcall sub_140012FB0(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int16 *a5, __int64 a6, char a7);
__int64 *__fastcall sub_140013130(__int64 *a1, _WORD *a2, _WORD *a3, unsigned __int16 *a4, unsigned __int16 *a5, __int64 a6, char a7);
bool __fastcall sub_140013220(__int64);
char __fastcall sub_1400132F0(__int64, char);
char __fastcall sub_1400133F0(__int64);
char __fastcall sub_1400135B0(__int64);
__int64 __fastcall sub_140013950(__int64);
__int64 __fastcall sub_1400139A0(__int64, char);
__int64 __fastcall sub_1400139F0(__int64);
__int64 __fastcall sub_140013A80(__int64, int);
__int64 __fastcall sub_140013B10(__int64, int, int, char);
__int64 __fastcall sub_140013C80(__int64);
void *__fastcall sub_140013D00(void *Block, char);
__int16 *__fastcall sub_140013D40(__int16 **, __int16 *, _WORD *);
bool __fastcall sub_140013D70(__int64);
__int64 __fastcall sub_140013E30(__int64);
char __fastcall sub_140013FB0(__int64);
char __fastcall sub_1400140E0(__int64, __int16);
__int64 __fastcall sub_140014140(__int64, unsigned __int16 *, unsigned __int16 *, char);
__int64 __fastcall sub_1400142C0(__int64, unsigned __int16, unsigned __int16);
_DWORD *__fastcall sub_140014490(__int64, char);
char __fastcall sub_140014580(__int64, unsigned __int16);
__int64 __fastcall sub_140014610(__int64, unsigned __int16);
char __fastcall sub_1400146D0(unsigned __int16 **, int);
__int64 __fastcall sub_1400148A0(__int64);
void __fastcall sub_140014930(__int64, unsigned __int16, __int64);
__int16 *__fastcall sub_140014A00(__int64, __int16 *, __int16 *, _WORD *);
// __int64 __fastcall sub_140014B70(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int16 *__fastcall sub_140014D30(__int16 *a1, __int16 *a2, __int16 *a3);
void __fastcall sub_140014D90(__int16 *, __int16 *, unsigned int, _DWORD **);
void __fastcall sub_140014F50(__int64, __int16 *, __int16 *);
_WORD *__fastcall sub_140014FE0(_WORD *, _WORD *, _WORD *);
__int64 __fastcall sub_140015020(__int16 *, __int64, __int16 *);
void __fastcall sub_1400150E0(__int16 **, const void *, __int64);
void __fastcall sub_140015110(__int64, __int16 *, const void *, __int64);
_QWORD *__fastcall sub_140015280(__int64, _QWORD *);
_QWORD *__fastcall sub_1400152E0(_QWORD *, size_t, size_t, char);
char *__fastcall sub_140015440(struct std::ios_base *, char);
// __int64 __fastcall sub_1400154C0(_QWORD); weak
__int64 __fastcall sub_1400154F0(__int64 **);
void *__fastcall sub_140015540(void *Block, char);
void __fastcall sub_140015570(__int64 *);
_QWORD *__fastcall sub_140015890(_QWORD *, _QWORD *, __int64 *, __int16 *);
__int64 __fastcall sub_140015910(__int64, __int64, __int64, __int64, __int64, unsigned __int64);
// __int64 __fastcall sub_1400159C0(_QWORD); weak
_QWORD *__fastcall sub_140015B60(_QWORD *a1, _QWORD *a2, __int16 *a3, __int16 *a4, __int64 *a5, __int16 *a6);
char __fastcall sub_140015E00(__int16 *a1, __int16 *a2, _QWORD *a3, __int64 *a4, unsigned int a5, __int64 a6);
_QWORD *__fastcall sub_140015FF0(_QWORD *, __int64, _QWORD *, __int16 *, __int16 *);
_QWORD *__fastcall sub_140016200(_QWORD *, _QWORD *, _QWORD *, __int16 *, __int16 *);
void *__fastcall sub_140016600(void *Src, unsigned __int64, unsigned __int64, __int16);
__int16 *__fastcall sub_140016750(__int64, __int16 *, __int16 *, __int64);
bool __fastcall sub_140016AB0(__int64, __int64, char);
bool __fastcall sub_140016C20(__int64, char *, __int64);
__int16 *__fastcall sub_140017140(__int16 *, __int16 *, __int16 *, __int16 *, __int64, __int16, char);
__int16 *__fastcall sub_1400171F0(__int16 *, __int16 *, unsigned int *);
char __fastcall sub_1400172A0(__int64, __int64, unsigned int);
char __fastcall sub_140017390(void *Src, __int64, char, unsigned int);
char __fastcall sub_140017550(__int64, __int64);
bool __fastcall sub_140017720(__int64);
__int16 *__fastcall sub_1400177F0(__int16 *, __int16 *, __int16 *, __int16 *, __int64, char);
unsigned __int16 *__fastcall sub_140017950(unsigned __int16 *, unsigned __int16 *, unsigned __int16 *, unsigned __int16 *, __int64, char);
__int64 __fastcall sub_140017A10(__int64, __int64, __int64);
_QWORD *__fastcall sub_140017A60(_QWORD *);
char *__fastcall sub_140017AD0(__int64, __int64, _DWORD *);
_QWORD *__fastcall sub_140017B80(_QWORD *, char);
__int64 __fastcall sub_140017BC0(__int64);
__int64 __fastcall sub_140017C00(__int64);
__int64 __fastcall sub_140017C40(__int64);
void __fastcall sub_140017CA0(void **);
__int64 __fastcall sub_140017E60(__int64, __int64);
__int64 **__fastcall sub_140017F10(__int64 **, _QWORD ***);
__int64 **__fastcall sub_140017FB0(__int64 **, _QWORD ***);
_QWORD *__fastcall sub_140018050(void *Src, void *, unsigned __int64);
void *__fastcall sub_1400181B0(void *, void *Src, void *);
void __fastcall sub_140018220(__int64, __int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400182D0(__int64, __int64, __int64);
__int64 __fastcall sub_1400183D0(__int64);
FARPROC __fastcall sub_1400184C0(LPCSTR lpProcName);
__int64 __fastcall sub_140018580(__int64);
void __fastcall sub_1400186A0(__int64);
void *__fastcall sub_140018720(void *Block, char);
void *__fastcall sub_140018750(void *Block, char);
void __fastcall sub_140018780(__int64 *, _DWORD *);
unsigned __int64 __fastcall sub_1400188F0(__int64, _QWORD *);
__int64 __fastcall sub_1400189C0(__int64 *a1, _QWORD *a2);
_QWORD *__fastcall sub_140018A90(__int64, _QWORD *, __int64 *);
unsigned __int64 __fastcall sub_140018B90(_QWORD *);
__int64 __fastcall sub_140018C50(_QWORD *, __int64);
void __fastcall sub_140018CD0(void **);
void __fastcall sub_140018CF0(__int64);
// __int64 __fastcall sub_140018D70(_QWORD, _QWORD); weak
__int64 __fastcall sub_140018EA0(__int64 *);
void *__fastcall sub_140018F20(unsigned __int64);
// __int64 __fastcall sub_140018F90(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_140019210(_QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall sub_140019320(__int64, __int64 *);
std::exception *__fastcall sub_140019440(std::exception *, const struct std::exception *);
__int64 __fastcall sub_140019470(_QWORD *, __int64, int *, __int64);
_QWORD *__fastcall sub_140019610(__int64);
__int64 __fastcall sub_1400196F0(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_1400197A0(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_140019810(_QWORD *, _QWORD **, __int64, __int64);
bool __fastcall sub_1400199D0(__int64, __int64, __int64 *, int);
_DWORD *__fastcall sub_140019AF0(_DWORD *, _DWORD *, _DWORD *);
_QWORD *__fastcall sub_140019B30(_QWORD *, _QWORD *, _QWORD *);
__int64 __fastcall sub_140019B70(__int64, __int64);
char *__fastcall sub_140019BF0(__int64, __int64, _DWORD *);
__int64 **__fastcall sub_140019CD0(_QWORD *, __int64 **, int *);
__int64 __fastcall sub_140019DD0(_QWORD *, __int64, int *, __int64);
_QWORD *__fastcall sub_140019F40(__int64);
__int64 __fastcall sub_14001A020(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_14001A0D0(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_14001A140(__int64 *, __int64, __int64 *);
__int64 **__fastcall sub_14001A170(__int64 **, __int64 **);
void *__fastcall sub_14001A1F0(unsigned __int64);
__int64 *__fastcall sub_14001A260(__int64 *a1, __int64 *a2, __int64 *a3);
_QWORD *__fastcall sub_14001A2C0(_QWORD *, _QWORD *, _QWORD *);
__int64 __fastcall sub_14001A300(__int64 *, __int64, __int64 *);
void __fastcall sub_14001A3C0(__int64 *);
void *__fastcall sub_14001A430(void *Block, char);
void *__fastcall sub_14001A460(void *Block, char);
// __int64 __fastcall sub_14001A490(_QWORD); weak
void __fastcall sub_14001A540(__int64);
void *__fastcall sub_14001A5B0(void *Src, _QWORD *, _WORD *);
char *__fastcall sub_14001A690(__int64, __int64, _DWORD *);
HWND __fastcall sub_14001A730(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPVOID lpParam);
char *__fastcall sub_14001A860(__int64, __int64, _QWORD *);
__int64 __fastcall sub_14001A910(LPCWSTR lpClassName, HINSTANCE hInstance); // idb
__int64 __fastcall sub_14001A9F0(WNDCLASSEXW *); // idb
void *__fastcall sub_14001AAB0(void *Block, char);
__int64 __fastcall sub_14001AB20(__int64);
void sub_14001AC00();
__int16 *__fastcall sub_14001AC90(__int16 *);
unsigned __int64 __fastcall sub_14001AD60(unsigned __int64);
__int64 __fastcall sub_14001ADF0(_QWORD *, __int64, unsigned __int64 *, __int64);
_QWORD *__fastcall sub_14001AF50(__int64);
__int64 __fastcall sub_14001B030(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_14001B0E0(_QWORD *a1, __int64 a2);
char *__fastcall sub_14001B150(__int64, __int64, _QWORD *);
__int64 __fastcall sub_14001B200(__int64);
__int64 *__fastcall sub_14001B3E0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_14001B490(char *, _QWORD *);
__int64 *__fastcall sub_14001B540(__int64 **, __int64 *, __int64 *);
__int64 __fastcall sub_14001B5D0(__int64, _WORD *);
__int64 *__fastcall sub_14001B830(__int64 *, __int64 *);
__int64 *__fastcall sub_14001B8F0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_14001BA20(_WORD *, __int64, unsigned __int64);
void **__fastcall sub_14001BB80(void **, _BYTE *);
struct std::locale::_Locimp **__fastcall sub_14001BC10(struct std::locale::_Locimp **, const char *);
char *__fastcall sub_14001BDE0(__int64, __int64, _QWORD *);
__int64 __fastcall sub_14001BE90(__int64);
void *__fastcall sub_14001C070(void *Src, _QWORD *);
void *__fastcall sub_14001C120(void *, void *Src, void *);
__int64 __fastcall sub_14001C1B0(_QWORD *, _QWORD *);
void __fastcall sub_14001C280(_QWORD *);
_QWORD *__fastcall sub_14001C460(_QWORD *);
_QWORD *__fastcall sub_14001C4E0(__int64, _QWORD *);
__int64 __fastcall sub_14001C590(__int64);
char *__fastcall sub_14001C600(__int64, __int64, _QWORD *);
// __int64 __fastcall sub_14001C6C0(_QWORD, _QWORD); weak
void __fastcall sub_14001C7D0(__int64 **, _QWORD *, _QWORD *);
void __fastcall sub_14001C800(__int64, __int64 *, _QWORD *, _QWORD *);
__int64 **__fastcall sub_14001C990(__int64 **, _QWORD ***);
char *__fastcall sub_14001CA30(__int64, __int64, _QWORD *);
char *__fastcall sub_14001CB00(__int64, __int64, _QWORD *);
void __fastcall sub_14001CBC0(__int64, __int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_14001CC70(__int64);
__int64 __fastcall sub_14001CC80(__int64);
__int64 __fastcall sub_14001CC90(__int64, _QWORD *, _QWORD *);
_QWORD *__fastcall sub_14001CCA0(_QWORD *, char);
void *__fastcall sub_14001CCD0(void *Block);
char *__fastcall sub_14001CD30(__int64, __int64, const void *);
char *__fastcall sub_14001CDE0(__int64, __int64, _DWORD *);
__int64 sub_14001CE90();
__int64 __fastcall sub_14001CF50(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_14001CFA0(__int64);
__int64 __fastcall sub_14001CFB0(void *Block); // idb
__int64 __fastcall sub_14001CFE0(__int64, __int64, __int64);
__int64 __fastcall sub_14001D0A0(__int64);
unsigned __int64 __fastcall sub_14001D120(HWND hWnd, UINT, HDC, int *);
unsigned __int64 __fastcall sub_14001D1D0(__int64, HWND, UINT, HDC, int *lParam);
__int64 __fastcall sub_14001D740(__int64 *);
// __int64 __fastcall sub_14001D7D0(_QWORD, _QWORD); weak
char *__fastcall sub_14001D8E0(void *Src, void *, char *);
__int64 __fastcall sub_14001D940(WNDCLASSW *lpWndClass); // idb
__int64 __fastcall sub_14001DA00(__int64, HDC, _DWORD *);
BOOL __fastcall sub_14001DBF0(__int64, HDC, _DWORD *, int *);
void __fastcall sub_14001DD50(__int64, HDC);
__int64 __fastcall StartAddress(LPVOID lpThreadParameter);
BOOL __fastcall sub_14001DEA0(__int64);
void __fastcall sub_14001DF50(__int64, __int64);
__int64 __fastcall sub_14001E270(__int64, HDC, LONG);
__int64 __fastcall sub_14001E460(__int64, int);
unsigned int __fastcall sub_14001E5C0(__int64, int);
LRESULT __fastcall sub_14001E6F0(__int64, WPARAM, LPARAM);
void __fastcall sub_14001E7A0(__int64, __int64, int);
BOOL __fastcall sub_14001E890(__int64, int);
void **sub_14001E940();
__int64 __fastcall sub_14001E9C0(__int64, __int64, int *);
_QWORD *__fastcall sub_14001EB10(_QWORD *, char);
ATOM sub_14001EB60();
LRESULT __fastcall sub_14001EBE0(HWND hWnd, UINT, WPARAM, LPARAM);
LRESULT __fastcall sub_14001ECC0(__int64, HWND, UINT, WPARAM, LPARAM);
BOOL __fastcall sub_14001ED50(HWND hWnd);
HWND __fastcall sub_14001EE70(__int64, __int16);
__int64 __fastcall sub_14001EF00(__int64, int);
LPVOID __fastcall sub_14001EFD0(LPVOID lpParameter, HWND hWnd, __int64, __int64, __int64);
void __fastcall sub_14001F240(__int64);
LRESULT __fastcall pfnSubclass(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
__int64 __fastcall sub_14001F390(ULONG_PTR dwData, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM); // idb
__int64 __fastcall sub_14001F680(__int64);
HRESULT __fastcall sub_14001F8B0(__int64, __int64, const ITEMIDLIST *);
void __fastcall sub_14001F970(ULONG_PTR dwData, __int64);
void __fastcall pfnAPC(ULONG_PTR Parameter);
int __fastcall sub_14001FC90(int, int, __int64);
int __fastcall sub_14001FCB0(__int64, int, int);
void __fastcall sub_14001FE90(__int64, __int64, const ITEMIDLIST *, __int64);
__int64 __fastcall sub_1400204F0(__int64);
__int64 __fastcall sub_140020600(LPVOID lpThreadParameter);
__int64 __fastcall sub_140020640(__int64, __int64);
LRESULT __fastcall sub_140020830(__int64, LPARAM, const WCHAR *);
LRESULT __fastcall sub_140020A40(__int64, LPARAM, const WCHAR *);
LPITEMIDLIST __fastcall sub_140020BE0(__int64, LPARAM);
LRESULT __fastcall sub_140020C30(__int64, __int64);
LPARAM __fastcall sub_140020E30(__int64, const ITEMIDLIST *, int);
LRESULT __fastcall sub_140020FE0(__int64, __int64);
LPARAM __fastcall sub_140021470(__int64, wchar_t *);
LRESULT __fastcall sub_1400216B0(__int64, LPARAM);
__int64 __fastcall sub_1400217C0(__int64, __int64, __int64);
__int64 __fastcall sub_140021B50(LPVOID lpThreadParameter);
int __fastcall sub_140021BF0(__int64, const WCHAR *);
__int64 __fastcall sub_140021E30(__int64, __int64, _QWORD *);
__int64 __fastcall sub_140021E40(__int64);
__int64 __fastcall sub_140021E50(void *Block); // idb
LRESULT __fastcall sub_140021E80(__int64);
LRESULT __fastcall sub_140021F90(__int64, LPARAM);
HRESULT __fastcall sub_140022190(__int64, int, int);
_BOOL8 __fastcall sub_1400222D0(wchar_t *String1);
_QWORD *__fastcall sub_140022350(_QWORD *);
__int64 __fastcall sub_1400223C0(__int64);
void **sub_1400223F0();
unsigned __int64 __fastcall sub_140022470(_QWORD *);
char *__fastcall sub_140022530(__int64, __int64, const void *);
// __int64 __fastcall sub_1400225E0(_QWORD, _QWORD); weak
char *__fastcall sub_140022720(void *Src, void *, char *);
__int64 __fastcall sub_140022780(void *, __int64, char *);
__int64 __fastcall sub_140022940(__int64, __int64, _QWORD *);
__int64 __fastcall sub_140022950(__int64);
__int64 __fastcall sub_140022960(__int64);
void __fastcall sub_140022970(__int64);
void __fastcall sub_140022B00(__int64, const WCHAR *);
void __fastcall sub_140022C30(__int64, wchar_t *);
void __fastcall sub_140022E50(__int64, const WCHAR *);
void __fastcall sub_140023150(LPCWSTR pszMore, int, __int64);
void __fastcall sub_140023200(__int64, int, __int64);
void __fastcall sub_140023320(__int64, const WCHAR *);
void __fastcall sub_1400234B0(__int64, LPARAM, const WCHAR *);
void __fastcall sub_140023760(__int64, LPARAM, const WCHAR *);
LRESULT __fastcall sub_1400238F0(__int64, LPARAM, const ITEMIDLIST *);
__int64 __fastcall sub_140023A60(__int64, const ITEMIDLIST *, int);
void __fastcall sub_140023AD0(__int64, LPARAM);
char *__fastcall sub_140023C20(__int64, __int64, const void *);
__int64 sub_140023CD0(__int64, __int64, char, ...);
void __fastcall TimerFunc(HWND);
__int64 __fastcall sub_140023ED0(__int64, char, char, struct tagPOINT *);
void __fastcall sub_140023FF0(HWND);
__int64 __fastcall sub_140024030(__int64, char, struct tagPOINT, unsigned int *);
__int64 __fastcall sub_1400241A0(__int64, __int64 *, LPARAM);
__int64 __fastcall sub_1400242D0(__int64);
__int64 __fastcall sub_140024330(__int64, __int64, int, struct tagPOINT, unsigned int *);
__int64 __fastcall sub_140024520(__int64, int, int);
__int64 sub_140024570();
__int64 __fastcall sub_140024580(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_140024590(__int64);
__int64 __fastcall sub_1400245A0(__int64);
__int64 __fastcall sub_1400245B0(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400245C0(__int64);
__int64 __fastcall sub_1400245D0(__int64);
__int64 __fastcall sub_1400245E0(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400245F0(__int64);
__int64 __fastcall sub_140024600(__int64);
__int64 __fastcall sub_140024610(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_140024620(__int64);
__int64 __fastcall sub_140024630(__int64);
char *__fastcall sub_140024640(__int64, __int64, _DWORD *);
char *__fastcall sub_1400246F0(__int64, __int64, _DWORD *);
char *__fastcall sub_140024790(__int64, __int64, const void *);
__int64 __fastcall sub_140024850(__int64, __int64 *);
// __int64 __fastcall sub_140024940(_QWORD); weak
_QWORD *__fastcall sub_140024AA0(__int64);
_QWORD *__fastcall sub_140024AE0(__int64);
_QWORD *__fastcall sub_140024B20(__int64);
_QWORD *__fastcall sub_140024B60(__int64);
_QWORD *__fastcall sub_140024BA0(__int64, _QWORD *, __int128 *, __int64, int, unsigned int);
void __fastcall sub_140024F20(__int64);
void *__fastcall sub_140024FE0(void *Block, char);
void **__fastcall sub_140025050(__int64);
__int64 __fastcall sub_140025660(__int64);
_QWORD *__fastcall sub_140025790(__int64 *a1, _QWORD *a2, _QWORD *a3, __int64 a4, __int16 a5, __int64 a6, wchar_t *a7, mbstate_t a8);
_QWORD *__fastcall sub_140025A10(__int64, _QWORD *, _QWORD *, __int64, int, struct tm *Timeptr, char, char);
void *__fastcall sub_140025C30(void *Block, char);
__int64 __fastcall sub_140025C60(__int64, __int64);
void *__fastcall sub_140025D40(void *Block, char);
_QWORD *__fastcall sub_140025D90(_QWORD *, __int64);
void __fastcall sub_140025E50(_QWORD *, void *);
unsigned __int64 __fastcall sub_140025F30(__int64, unsigned __int64);
void __fastcall sub_140026030(__int64);
void __fastcall sub_1400260B0(__int64, __int64);
unsigned __int64 __fastcall sub_140026110(_QWORD *);
struct std::locale::_Locimp **__fastcall sub_1400261D0(struct std::locale::_Locimp **, struct std::locale::_Locimp **, struct std::locale::facet *);
__int64 *__fastcall sub_140026290(__int64 *, __int64);
void __fastcall sub_140026570(void *Src, _WORD *, _QWORD *);
// __int64 __fastcall sub_140026610(_QWORD); weak
void __fastcall sub_140026760(__int64);
__int64 __fastcall sub_1400267E0(__int64);
bool __fastcall sub_1400269C0(__int64 *);
// __int64 __fastcall sub_140026A40(_DWORD, _DWORD, _DWORD, _DWORD, __int16, __int64); weak
__int64 __fastcall sub_1400277C0(__int64, __int64);
void *__fastcall sub_1400277F0(__int64, char);
__int64 __fastcall sub_140027830(__int64, _QWORD *, char);
__int64 __fastcall sub_1400278C0(__int64);
__int64 __fastcall sub_140027910(__int64, __int64, __int64);
__int64 __fastcall sub_140027980(__int64 *);
__int64 __fastcall sub_140027A40(__int64 *);
void __fastcall sub_140027B40(void *Src, __int64, __int128 *);
void __fastcall sub_140027C50(void *Src, _QWORD *, _QWORD *);
__int64 __fastcall sub_140027CE0(__int64, __int64, int);
__int64 __fastcall sub_140027EE0(__int64);
_QWORD *__fastcall sub_1400280C0(_QWORD *, _QWORD *);
_QWORD *__fastcall sub_140028150(_QWORD *, _WORD *, _WORD *, __int64);
_QWORD *__fastcall sub_140028220(_QWORD *, _QWORD *, _QWORD *);
_QWORD *__fastcall sub_1400282B0(void *Src, void *, _QWORD *);
// __int64 __fastcall unknown_libname_16(_QWORD); weak
void __fastcall sub_140028360(void *Src, __int64, __int64);
// __int64 __fastcall sub_140028460(_QWORD, _QWORD); weak
void __fastcall sub_140028550(void *Src, __int64, unsigned __int16 *, unsigned __int16 **, unsigned __int16 **);
void __fastcall sub_1400288D0(void **);
_QWORD *__fastcall sub_140028900(__int64 *, _QWORD *);
_QWORD *__fastcall sub_140028920(__int64 *, _QWORD *);
void __fastcall sub_140028940(_QWORD *);
__int64 __fastcall sub_1400289D0(void *Src, __int64, __int64, __int64);
void __fastcall sub_140028AC0(void *Src, __int64, unsigned __int16 *, unsigned __int16 **, __int64);
void __fastcall sub_140028E40(void *Src, __int64, __int64, unsigned __int16 **);
_QWORD *__fastcall sub_1400291A0(_QWORD *, __int64);
unsigned __int16 **__fastcall sub_140029200(unsigned __int16 **, __int64 *, __int64, void *, unsigned __int16 *);
__int64 __fastcall sub_140029340(void *Src, __int64, __int64, __int64);
void __fastcall sub_140029430(_QWORD *);
__int64 __fastcall sub_140029470(__int64, unsigned __int16 *);
void __fastcall sub_140029560(_QWORD *);
__int64 __fastcall sub_140029750(__int64);
_QWORD *__fastcall sub_140029790(_QWORD *, __int64 *, __int64, __int64);
unsigned __int16 *__fastcall sub_140029890(__int64 *, __int64, unsigned __int16 *, unsigned __int16 *);
__int64 __fastcall sub_140029AE0(void *Src, __int64, __int64, __int64);
__int64 __fastcall sub_140029BE0(_QWORD *, unsigned __int16 *);
_QWORD *__fastcall sub_140029CD0(__int64, _QWORD *, __int64);
__int64 __fastcall sub_140029D80(__int64, __int64);
// __int64 __fastcall sub_140029EE0(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14002A050(void *Src, __int64, __int64, __int64, __int64);
// __int64 __fastcall sub_14002A150(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_14002A370(_QWORD *, __int64);
// __int64 __usercall sub_14002A420@<rax>(void *Src@<rcx>, __int64); idb
__int64 __fastcall sub_14002A580(__int64, __int64, __int64);
void *__fastcall sub_14002A760(void *Src, __int64, __int64);
__int64 __fastcall sub_14002A850(void *Src, __int64, __int64);
void **__fastcall sub_14002AAB0(__int64, void **);
// __int64 __fastcall sub_14002AAD0(struct std::locale::_Locimp *, struct std::locale::_Locimp *); weak
void __fastcall sub_14002AB60(ULONG_PTR dwData, int);
__int64 __fastcall sub_14002B060(__int64, int, int, int);
__int64 __fastcall sub_14002B130(__int64, const ITEMIDLIST *, const ITEMIDLIST *, _WORD *);
char *__fastcall sub_14002B490(__int64, __int64, const void *);
char *__fastcall sub_14002B540(__int64, __int64, const void *);
void __fastcall __noreturn sub_14002B5F8(char *);
void __fastcall __noreturn sub_14002B630(char *);
std::exception *__fastcall sub_14002B668(std::exception *, const struct std::exception *);
void __fastcall __noreturn sub_14002B68C(char *);
void *__fastcall sub_14002B6C4(void *Block, char);
// void __fastcall std::ios_base::_Ios_base_dtor(struct std::ios_base *this); idb
__int64 __fastcall sub_14002B7FC(__int64);
__int64 __fastcall sub_14002B804(__int64);
__int64 (__fastcall **sub_14002B818())();
_QWORD *__fastcall sub_14002B820(_QWORD *, char);
// __int64 __fastcall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); idb
// __int64 __fastcall unknown_libname_18(_QWORD); weak
// __int64 __fastcall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int); idb
// void __fastcall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); idb
// __int64 __fastcall unknown_libname_19(_QWORD); weak
__int64 sub_14002BB90();
// void __fastcall std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); idb
// struct std::locale::_Locimp *std::locale::_Init(void); idb
// const struct std::locale *std::locale::classic(void); idb
// int __cdecl Wcrtomb(char *, wchar_t, mbstate_t *, const _Cvtvec *);
// _Cvtvec *__cdecl Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// int __cdecl Tolower(int, const _Ctypevec *);
// _Ctypevec *__cdecl Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl Mbrtowc(wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
// wchar_t __cdecl Towupper(wchar_t, const _Ctypevec *);
// wchar_t __cdecl Towlower(wchar_t, const _Ctypevec *);
// __int64 __fastcall unknown_libname_21(_QWORD); weak
// __int64 __fastcall Stoulx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall Stolx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall Stollx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall Stoullx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// double __fastcall Stofx(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall Stodx(char *String, char **EndPtr); idb
__int64 __fastcall j__Stodx(char *String, char **EndPtr); // idb
void *__fastcall operator new(size_t Size); // idb
// __int64 __fastcall std::setw(_QWORD, _QWORD); weak
bool __uncaught_exception(void); // idb
// void __fastcall __noreturn std::tr1::_Xmem(std::tr1 *__hidden this); idb
// void __fastcall __noreturn std::tr1::_Xbad(_QWORD); weak
std::exception *__fastcall sub_14002CC7C(std::exception *, const struct std::exception *);
// size_t __cdecl Wcsxfrm(wchar_t *String1, wchar_t *End1, const wchar_t *, const wchar_t *, const _Collvec *);
// _Collvec *__cdecl Getcoll(_Collvec *__return_ptr __struct_ptr retstr);
char sub_14002CF88();
__int64 sub_14002CF8C();
int __fastcall sub_14002CF94(__int64, unsigned __int8);
int __fastcall sub_14002CFEC(__int64, unsigned __int8);
char __fastcall sub_14002D044(__int64, char);
// void __fastcall std::locale::_Locimp::_Locimp_Addfac(struct std::locale::_Locimp *, struct std::locale::facet *, unsigned __int64); idb
// __int64 __fastcall std::numpunct<char>::_Init(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::istreambuf_iterator<char>::equal(_QWORD, _QWORD); weak
// __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD); weak
__int64 __fastcall sub_14002D7FC(_QWORD *, __int64);
__int64 __fastcall sub_14002D8B4(_QWORD *, __int64);
char __fastcall sub_14002D96C(__int64);
char __fastcall sub_14002D970(__int64);
void *__fastcall sub_14002D974(void *Block, char);
__int64 __fastcall sub_14002D9D0(_QWORD *, __int64);
// __int64 __fastcall std::codecvt<char,char,int>::_Getcat(_QWORD, _QWORD); weak
__int64 __fastcall sub_14002DD80(__int64 *);
__int64 __fastcall sub_14002DED4(__int64);
__int64 __fastcall sub_14002E028(__int64);
__int64 __fastcall sub_14002E17C(__int64);
__int64 __fastcall sub_14002E2D0(__int64 *);
// struct std::locale::_Locimp *__stdcall static std::locale::_Locimp::_Makeloc(const struct std::_Locinfo *, int, struct std::locale::_Locimp *, const struct std::locale *); idb
// void __fastcall std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, int, const char *); idb
// __int64 __fastcall std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
_OWORD *__fastcall sub_1400309F8(int, _OWORD *, _OWORD *, __int64, __int64, _DWORD *, __int64 *);
_OWORD *__fastcall sub_140030AFC(int, _OWORD *, _OWORD *, __int64, __int64, _DWORD *, __int64 *);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __cdecl Toupper(int, const _Ctypevec *);
char sub_1400330C4();
__int64 sub_1400330C8();
__int64 __fastcall sub_140033478(__int64);
__int64 sub_1400334DC();
_QWORD *__fastcall sub_1400334E0(_QWORD *, char);
__int64 __fastcall sub_140033508(__int64);
__int64 __fastcall sub_140033510(__int64);
void *__fastcall sub_140033520(void *Block, char);
// __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unknown_libname_61(_QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD); weak
// __int64 __fastcall std::ctype<wchar_t>::_Getcat(_QWORD, _QWORD); weak
__int64 __fastcall sub_140034250(_QWORD *, __int64);
__int64 __fastcall sub_140034300(_QWORD *, __int64);
__int64 __fastcall sub_1400343B8(_QWORD *, __int64);
__int64 __fastcall sub_140034470(_QWORD *, __int64);
__int64 __fastcall sub_140034528(_QWORD *, __int64);
void *__fastcall sub_1400345E0(void *Block, char);
// __int64 __fastcall sub_14003463C(_QWORD, _QWORD); weak
__int64 __fastcall sub_1400346F4(_QWORD *, __int64);
__int64 __fastcall sub_1400347A4(_QWORD *, __int64);
__int64 __fastcall sub_14003485C(_QWORD *, __int64);
__int64 __fastcall sub_140034914(_QWORD *, __int64);
// __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(_QWORD, _QWORD); weak
// __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(_QWORD, _QWORD); weak
__int64 __fastcall sub_140034F28(__int64 *);
__int64 __fastcall sub_14003507C(__int64);
__int64 __fastcall sub_1400351D0(__int64);
__int64 __fastcall sub_140035324(__int64);
__int64 __fastcall sub_140035478(__int64 *);
__int64 __fastcall sub_1400355CC(__int64);
__int64 __fastcall sub_140035720(__int64);
__int64 __fastcall sub_140035874(__int64 *);
__int64 __fastcall sub_1400359C8(__int64);
__int64 __fastcall sub_140035B1C(__int64);
__int64 __fastcall sub_140035C70(__int64);
__int64 __fastcall sub_140035DC4(__int64);
__int64 __fastcall sub_140035F18(__int64 *);
__int64 __fastcall sub_14003606C(_QWORD *, __int64);
__int64 __fastcall sub_140036138(_QWORD *, __int64);
void *__fastcall sub_140036204(void *Block, char);
__int64 __fastcall sub_140036254(_QWORD *, __int64);
__int64 __fastcall sub_140036308(_QWORD *, __int64);
__int64 __fastcall sub_1400363D4(_QWORD *, __int64);
void *__fastcall sub_1400364A0(void *Block, char);
__int64 __fastcall sub_1400364F0(_QWORD *, __int64);
// __int64 std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, ...); weak
// __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
__int64 __fastcall sub_1400373C0(__int64);
__int64 __fastcall sub_140037514(__int64);
__int64 __fastcall sub_140037668(__int64);
__int64 __fastcall sub_1400377BC(__int64);
__int64 __fastcall sub_140037910(__int64);
__int64 __fastcall sub_140037A64(__int64);
_OWORD *__fastcall sub_14003956C(int, _OWORD *, _OWORD *, int, int, _DWORD *, __int64);
// __int64 __fastcall std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>(_QWORD, _QWORD, _QWORD, _QWORD); weak
_OWORD *__fastcall sub_14003B444(__int64, _OWORD *, __int64 *, __int64 *, int, _DWORD *, __int64);
_OWORD *__fastcall sub_14003B49C(__int64, _OWORD *, __int64 *, __int64 *, int, _DWORD *, __int64);
__int128 *__fastcall sub_14003BDC0(__int64 *, __int128 *, __int128 *, __int128 *, __int64, _DWORD *, _DWORD *, char);
// __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
// __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64); weak
_OWORD *__fastcall sub_14003E8A8(int, _OWORD *, _OWORD *, __int64, __int64, _DWORD *, __int64 *);
_OWORD *__fastcall sub_14003E9AC(int, _OWORD *, _OWORD *, __int64, __int64, _DWORD *, __int64 *);
_OWORD *__fastcall sub_14003EAB0(int, _OWORD *, _OWORD *, __int64, __int64, _DWORD *, float *);
__int64 __fastcall sub_14003F320(_QWORD *, __int64);
__int64 __fastcall sub_140040E6C(__int64);
void __fastcall sub_140040FC0(__int64, int, struct std::locale::_Locimp *, __int64 *);
void *__fastcall sub_140045320(void *Block, char);
// __int64 __fastcall std::_Mpunct<char>::_Init(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140045770(_QWORD *, __int64);
__int64 __fastcall sub_140045820(_QWORD *, __int64);
__int64 __fastcall sub_1400458D8(_QWORD *, __int64);
// __int64 __fastcall sub_140045990(_QWORD, _QWORD); weak
__int64 __fastcall sub_140045BA4(__int64);
__int64 __fastcall sub_140045CF8(__int64);
__int64 __fastcall sub_140045E4C(__int64);
__int64 __fastcall sub_140045FA0(__int64 *);
__int64 __fastcall sub_1400460F4(_QWORD *, __int64);
__int64 __fastcall sub_1400461C0(_QWORD *, __int64);
__int64 __fastcall sub_14004628C(__int64);
void *__fastcall sub_140046290(void *Block, char);
// __int64 __fastcall sub_1400462E0(_QWORD, _QWORD); weak
__int64 __fastcall sub_1400468DC(__int64);
__int64 __fastcall sub_140046A30(__int64);
__int64 __fastcall sub_140046B84(__int64 *);
// void __cdecl _security_check_cookie(uintptr_t StackCookie);
// int __cdecl vsnwprintf(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
void *__fastcall sub_14004AAC4(void *Block, char);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
void __cdecl j_free(void *Block);
// void *__cdecl realloc(void *Block, size_t Size);
// void *__fastcall operator new(size_t Size); idb
// void __fastcall std::exception::_Tidy(std::exception *__hidden this); idb
// __int64 __fastcall std::exception::exception(std::exception *__hidden this, const char *const *); idb
void __fastcall sub_14004AEC0(std::exception *);
std::exception *__fastcall sub_14004AED0(std::exception *, char *);
void *__fastcall sub_14004AEFC(void *Block, char);
// __int64 __fastcall std::exception::exception(std::exception *__hidden this, const struct std::exception *); idb
std::exception *__fastcall sub_14004AF64(std::exception *, const struct std::exception *);
void __cdecl j_j_free(void *Block);
// int __cdecl atexit(void (__cdecl *)());
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// double __cdecl ldexp(double X, int Y);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// struct lconv *__cdecl localeconv();
// __int64 __fastcall sub_14004B61C(_QWORD); weak
// int sprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// errno_t __cdecl static memmove_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// char *__cdecl strchr(const char *Str, int Val);
// void __fastcall `eh vector constructor iterator'(void *, unsigned __int64, int, void (__stdcall *)(void *), void (__stdcall *)(void *)); idb
// void __fastcall `eh vector destructor iterator'(void *, unsigned __int64, int, void (__stdcall *)(void *)); idb
// errno_t __cdecl itow_s(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// div_t __cdecl div(int Numerator, int Denominator);
// errno_t __cdecl static memcpy_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// wchar_t *__cdecl wcstok_s(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// _LocaleUpdate *__fastcall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// void *__cdecl Gettnames();
// size_t __cdecl Strftime(char *Buffer, size_t Max_size, const char *Format, const struct tm *Timeptr, void *Lc_time_arg);
// int __cdecl iswalpha(wint_t C);
// wint_t __cdecl towupper(wint_t C);
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
__int64 sub_14004DD20();
// int *__cdecl errno();
void __fastcall sub_140050030(std::exception *);
void *__fastcall sub_140050040(void *Block, char);
std::exception *__fastcall sub_14005116C(std::exception *, const struct std::exception *);
// void *__cdecl memset(void *, int Val, size_t Size);
void __fastcall sub_140052AD0(void *);
// void __cdecl invalid_parameter_noinfo();
// __int64 unknown_libname_86(void); weak
void __fastcall sub_14005343C(void *);
PVOID sub_1400545E0();
void __fastcall sub_140054EBC(void *);
void sub_14005592C();
void __fastcall sub_140055964();
__int64 __fastcall sub_140056298(_DWORD *);
__int64 __fastcall sub_1400562C8(_DWORD *);
__int64 __fastcall sub_1400562F8(_DWORD *);
int *sub_140056328();
int *sub_140056330();
int *sub_140056338();
void **sub_140056340();
void *sub_140056B58();
char **sub_140056B60();
PVOID sub_14005A644();
void sub_14005A888();
void **sub_14005B300();
void __fastcall sub_14005B8D4(__int64);
__int64 __fastcall sub_14005B9A4(__int64, __int64, unsigned int);
__int64 __fastcall sub_14005D248(_DWORD *, int, struct localeinfo_struct *);
__int64 __fastcall sub_14005D348(_DWORD *, int, struct localeinfo_struct *);
__int64 __fastcall sub_14005D6A0(unsigned __int16 *, _DWORD *);
__int64 __fastcall sub_14005DC6C(unsigned __int16 *, _DWORD *);
// __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
BOOL sub_140060290();
__int64 __fastcall sub_140060C30(__int64);
__int64 (__fastcall **__fastcall sub_140060C40(_QWORD *))(void *Block);
void __fastcall __noreturn sub_140060C80(int, __int64);
__int64 __fastcall sub_140060CC0(__int64, __int64);
void *__fastcall sub_140060D00(void *Block, char);
int __fastcall sub_140060E00(HWND hWnd, int *);
__int64 __fastcall sub_140060F10(__int64, __int64, __int64);
__int64 __fastcall sub_140060F40(__int64, __int64 *);
__int64 __fastcall sub_140061070(__int64);
_QWORD *__fastcall sub_1400610E0(WPARAM wParam, struct tagPOINT *);
LRESULT __fastcall sub_140061630(__int64, __int64 *);
__int64 __fastcall sub_140061850(__int64, char, struct tagPOINT, unsigned int *);
__int64 __fastcall sub_140061990(__int64, __int64 *, char, __int64, int *);
void __fastcall sub_140061C50(__int64, _QWORD **, struct tagPOINT *);
__int64 __fastcall sub_140061E30(__int64, __int64, int, __int64, _DWORD *);
LRESULT __fastcall sub_140062110(__int64, int, int);
void __fastcall sub_140062150(__int64, int);
__int64 __fastcall sub_140062190(int, int);
__int64 __fastcall sub_1400622B0(int, int);
__int64 __fastcall sub_1400623D0(__int64, char *);
void __fastcall sub_1400624F0(__int64, int, char *);
__int64 __fastcall sub_140062700(__int64, int, char *);
__int64 __fastcall sub_140062820(__int64, int, int, _WORD *);
__int64 __fastcall sub_1400629F0(__int64, int, _WORD *);
__int64 __fastcall sub_140062B50(__int64, int, wchar_t *, __int64, __int64);
__int64 __fastcall sub_140062C10(__int64, const WCHAR *, WPARAM);
__int64 __fastcall sub_140062EA0(__int64, int, int, char *);
__int64 __fastcall sub_140063010(__int64, int, __int64, char *);
__int64 __fastcall sub_1400631A0(__int64, int, char *);
__int64 __fastcall sub_1400632C0(__int64, int, char *);
__int64 __fastcall sub_140063470(__int64, int, char *);
__int64 __fastcall sub_140063680(__int64, int, int, char *);
void __fastcall sub_1400637F0(__int64, int, char *);
__int64 __fastcall sub_140063900(__int64, int, _WORD *);
__int64 __fastcall sub_140063B50(__int64, int, __int64, __int64);
LRESULT __fastcall sub_140064380(__int64);
LRESULT __fastcall sub_140064500(__int64);
LRESULT __fastcall sub_140064560(__int64, int);
void __fastcall sub_1400645B0(HWND, __int64, UINT_PTR);
void __fastcall sub_1400645F0(__int64, const WCHAR *);
void __fastcall sub_1400646B0(__int64, const WCHAR *);
void __fastcall sub_140064770(__int64, int, const WCHAR *);
void __fastcall sub_140064890(__int64, int, __int64, int, int);
void __fastcall sub_1400649D0(_QWORD *, const WCHAR *);
int __fastcall sub_140064DB0(__int64, const WCHAR *);
void __fastcall sub_1400650A0(ULONG_PTR dwData, LPCWSTR pszMore);
void __fastcall sub_1400653A0(_QWORD *, const WCHAR *);
void __fastcall sub_1400653D0(__int64);
__int64 __fastcall sub_140065730(__int64, int, int);
__int64 __fastcall sub_1400657A0(int, int, __int64);
__int64 __fastcall sub_140065810(__int64, int, int);
__int64 __fastcall sub_1400659B0(__int64, int, int);
__int64 __fastcall sub_140065B50(_QWORD *, int, int);
__int64 __fastcall sub_140065C20(_QWORD *, int, int);
__int64 __fastcall sub_140065DB0(__int64, __int64, __int64);
__int64 __fastcall sub_140066060(_QWORD *, __int64, __int64);
__int64 __fastcall sub_1400662D0(__int64, int, int);
__int64 __fastcall sub_140066410(_QWORD *, __int64, __int64);
__int64 __fastcall sub_140066500(__int64);
__int64 __fastcall sub_140066520(__int64);
__int64 __fastcall sub_140066540(__int64, __int64, __int64, int);
__int64 __fastcall sub_140066780(_QWORD *, __int64, __int64, int);
__int64 __fastcall sub_140066860(__int64);
__int64 __fastcall sub_140066880(__int64);
__int64 __fastcall sub_1400668A0(_QWORD *, __int64, __int64);
int __fastcall sub_140066980(__int64, __int64, __int64);
__int64 __fastcall sub_140066DB0(_QWORD *, int, int);
__int64 __fastcall sub_140066FD0(_QWORD *, __int64, __int64);
__int64 __fastcall sub_1400670B0(_QWORD *, __int64, __int64);
__int64 __fastcall sub_140067190(__int64, int, int);
__int64 __fastcall sub_1400672D0(char *, int, int);
int __fastcall sub_1400674E0(__int64, __int64, __int64);
__int64 __fastcall sub_1400677A0(__int64 *, int, int);
__int64 __fastcall sub_140067900(__int64, int, int, int);
__int64 __fastcall sub_140067B40(__int64, int, int, int);
__int64 __fastcall sub_140067DC0(__int64, int, int);
__int64 __fastcall sub_140067F80(__int64, int, int);
__int64 __fastcall sub_1400681F0(__int64, int, int);
__int64 __fastcall sub_140068340(__int64, int, int);
int __fastcall sub_1400685A0(__int64, __int64, __int64);
int __fastcall sub_140068600(__int64, __int64, __int64);
__int64 __fastcall sub_140068670(WPARAM wParam, int);
void __fastcall sub_140068710(__int64, int);
WCHAR *__fastcall sub_140068810(__int64, int);
__int64 __fastcall sub_140068950(__int64, __int64, unsigned int);
__int64 __fastcall sub_1400689D0(__int64, const ITEMIDLIST *);
__int64 __fastcall sub_140068C20(__int64, LPITEMIDLIST *, int, _DWORD *);
_BOOL8 __fastcall sub_140068D50(__int64, int);
__int64 __fastcall sub_140068E10(__int64, const ITEMIDLIST *, int);
__int64 __fastcall sub_140069120(_WORD *, _QWORD *, __int64);
__int64 __fastcall sub_1400691C0(__int64, unsigned __int64);
__int64 __fastcall sub_140069230(int);
LRESULT __fastcall sub_1400693F0(__int64, unsigned int, int, int);
LRESULT __fastcall sub_140069500(__int64, int, int);
__int64 __fastcall sub_140069620(__int64, HWND, int, int);
__int64 __fastcall sub_1400696E0(__int64, HWND, int, int);
void __fastcall sub_1400697C0(__int64, int, int);
__int64 __fastcall sub_1400698D0(__int64, unsigned int, int);
__int64 __fastcall sub_140069980(__int64);
LRESULT __fastcall sub_1400699A0(__int64, int, int);
LRESULT __fastcall sub_140069B60(__int64, int, int);
LRESULT __fastcall sub_140069D20(__int64, int, int);
LRESULT __fastcall sub_140069EE0(__int64, int, int);
void __fastcall sub_14006A0B0(__int64);
void __fastcall sub_14006A140(__int64);
int __fastcall sub_14006A1D0(__int64);
LRESULT __fastcall sub_14006A340(__int64);
__int64 __fastcall sub_14006A4D0(__int64, int);
__int64 __fastcall sub_14006A550(__int64);
_QWORD **__fastcall sub_14006A680(__int64);
LRESULT __fastcall sub_14006A750(__int64, int, int);
__int64 __fastcall sub_14006A8D0(__int64, HWND, int, int);
void __fastcall sub_14006AA30(__int64, int, int);
__int64 __fastcall sub_14006AC40(__int64, HWND, int, int);
__int64 __fastcall sub_14006ACF0(__int64, _DWORD *);
__int64 __fastcall sub_14006ADB0(__int64, _DWORD *);
__int64 **__fastcall sub_14006AE70(__int64 **, __int64 **);
__int64 __fastcall sub_14006AF10(__int64, HWND, int, int, int);
__int64 __fastcall sub_14006B060(__int64, HWND, int, int, int);
__int64 __fastcall sub_14006B1B0(__int64, HWND, int, int);
__int64 __fastcall sub_14006B350(__int64, HWND, int, int, __int64);
__int64 __fastcall sub_14006B4D0(__int64, unsigned int, int);
__int64 __fastcall sub_14006B590(__int64, unsigned int, int);
__int64 __fastcall sub_14006B6C0(__int64, HWND, int, int, int);
char **__fastcall sub_14006B7F0(__int64, int);
char **__fastcall sub_14006B870(__int64, int);
LRESULT __fastcall sub_14006B8F0(_QWORD *, int, int);
char *__fastcall sub_14006BA40(__int64, char **);
void __fastcall sub_14006BAE0(__int64, int, int, int);
__int64 __fastcall sub_14006BD20(__int64, HWND, int, int);
__int64 __fastcall sub_14006BF20(__int64, HWND, int, int);
__int64 __fastcall sub_14006C030(__int64);
void __stdcall sub_14006C2F0(ULONG_PTR Parameter); // idb
// __int64 __fastcall sub_14006C300(_QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall sub_14006D410(__int64, int, unsigned int, unsigned int);
__int64 __fastcall sub_14006DA70(__int64);
void __stdcall sub_14006DCB0(ULONG_PTR Parameter); // idb
__int64 __fastcall sub_14006DCC0(__int64);
void __fastcall sub_14006DCD0(__int64, const WCHAR *);
__int64 __fastcall sub_14006DE80(__int64);
_BOOL8 __fastcall sub_14006DE90(__int64);
__int64 __fastcall sub_14006DEB0(__int64, unsigned int);
__int64 __fastcall sub_14006DEC0(__int64);
__int64 __fastcall sub_14006DED0(__int64);
__int64 __fastcall sub_14006DEE0(__int64);
__int64 __fastcall sub_14006DEF0(__int64);
__int64 __fastcall sub_14006DF00(__int64, unsigned int);
_BOOL8 __fastcall sub_14006DF10(__int64);
__int64 __fastcall sub_14006DF30(__int64);
void __fastcall sub_14006DF40(__int64, int);
__int64 __fastcall sub_14006DF50(__int64);
__int64 __fastcall sub_14006DF60(__int64, _QWORD *);
__int64 __fastcall sub_14006DF80(__int64);
__int64 __fastcall sub_14006DFA0(__int64);
__int64 __fastcall sub_14006DFB0(__int64);
__int64 __fastcall sub_14006DFC0(__int64);
__int64 __fastcall sub_14006DFD0(__int64, int, int);
__int64 __fastcall sub_14006E090(__int64, int);
__int64 __fastcall sub_14006E150(__int64, int);
__int64 __fastcall sub_14006E210(__int64, int);
__int64 __fastcall sub_14006E280(__int64);
__int64 __fastcall sub_14006E320(__int64);
__int64 __fastcall sub_14006E330(__int64);
void __fastcall sub_14006E340(__int64, int);
void __fastcall sub_14006E350(__int64, int);
__int64 __fastcall sub_14006E360(__int64, int);
__int64 __fastcall sub_14006E440(__int64);
LPITEMIDLIST __fastcall sub_14006E450(__int64, int);
void sub_14006E4C0();
__int64 __fastcall sub_14006E500(__int64, int);
__int64 __fastcall sub_14006E550(__int64, int);
__int64 __fastcall sub_14006E5B0(__int64, const WCHAR *);
LRESULT __fastcall sub_14006E680(__int64, const WCHAR *);
__int64 __fastcall sub_14006E6E0(__int64);
__int64 sub_14006E6F0();
__int64 __fastcall sub_14006E700(__int64);
__int64 __fastcall sub_14006E720(__int64);
__int64 __fastcall sub_14006E740(__int64);
__int64 __fastcall sub_14006E760(__int64);
_BOOL8 __fastcall sub_14006E780(__int64);
_BOOL8 __fastcall sub_14006E7B0(__int64);
__int64 __fastcall sub_14006E7E0(__int64, __int64, _QWORD *, __int64, unsigned int);
LPITEMIDLIST __fastcall sub_14006E850(__int64);
__int64 __fastcall sub_14006E870(__int64, int, int);
__int64 __fastcall sub_14006E900(__int64, int);
__int64 __fastcall sub_14006E910(__int64, const WCHAR *, _DWORD *);
__int64 __fastcall sub_14006E9B0(__int64, int);
LPITEMIDLIST __fastcall sub_14006EA20(__int64, const ITEMIDLIST *);
__int64 __fastcall sub_14006EBA0(__int64);
_BOOL8 __fastcall sub_14006EC20(__int64, int);
__int64 __fastcall sub_14006EC90(__int64 *);
void __fastcall sub_14006ED10(__int64);
__int64 __fastcall sub_14006ED80(HWND *);
__int64 __fastcall sub_14006EE30(__int64);
void __fastcall sub_14006EEB0(__int64, int, WCHAR *);
__int64 __fastcall sub_14006EF10(__int64, int, WCHAR *);
__int64 ***__fastcall sub_14006F000(__int64, __int64 *);
unsigned int __fastcall sub_14006F0C0(__int64);
__int64 __fastcall sub_14006F260(__int64, _WORD *, int);
int __fastcall sub_14006F280(__int64, const ITEMIDLIST *);
char **__fastcall sub_14006F330(__int64, int, int);
void __fastcall sub_14006F450(__int64);
__int64 __fastcall sub_14006F960(_QWORD *, void *);
void __fastcall sub_14006FA40(__int64);
LRESULT __fastcall sub_14006FAF0(__int64, int, _DWORD *);
int __fastcall sub_14006FC80(__int64, int, _WORD *);
__int64 __fastcall sub_14006FCE0(__int64, int, _WORD *);
int __fastcall sub_14006FDB0(__int64, int, unsigned int, WCHAR *);
__int64 __fastcall sub_14006FE40(__int64, int, _WORD *, unsigned int);
void __fastcall sub_14006FF00(__int64);
int __fastcall sub_14006FF50(__int64, __int64, __int64);
int __fastcall sub_140070210(__int64, __int64, __int64);
__int64 __fastcall sub_140070270(__int64, __int64);
__int64 __fastcall sub_140070390(_QWORD *, int, _WORD *);
void __fastcall sub_140070430(ULONG_PTR Parameter);
void __fastcall sub_1400706B0(ULONG_PTR dwData, __int64);
_BOOL8 __fastcall sub_1400707B0(__int64, const WCHAR *);
void __fastcall sub_1400707E0(__int64, const WCHAR *);
void __fastcall sub_140070A60(__int64);
__int64 ***__fastcall sub_140070BE0(__int64, __int64 *);
void __fastcall sub_140070CE0(__int64);
__int64 __fastcall sub_140070DE0(__int64, int);
__int64 __fastcall sub_140070EE0(_QWORD *, int);
void __fastcall sub_140070F60(__int64);
void __fastcall sub_1400711E0(__int64, __int64);
void __fastcall sub_140071490(__int64, __int64 **);
LRESULT __fastcall sub_1400716D0(ULONG_PTR dwData);
LRESULT __fastcall sub_140071810(ULONG_PTR);
LRESULT __fastcall sub_140071870(__int64, int);
LRESULT __fastcall sub_1400718E0(__int64, __int64);
void __fastcall sub_1400719A0(__int64, __int64, __int64);
BOOL __fastcall sub_140071AE0(HDC hdc, HANDLE h);
void sub_140071BB0();
__int64 __fastcall sub_140071BE0(_QWORD *);
BOOL __fastcall sub_140071C90(__int64, HDC, int);
__int64 __fastcall sub_140071D90(__int64, int, int, void *);
void __fastcall sub_140071F30(ULONG_PTR Parameter);
void __fastcall sub_140072270(ULONG_PTR dwData, int);
__int64 __fastcall sub_140072380(__int64);
LRESULT __fastcall sub_140072480(__int64);
__int64 __fastcall sub_1400725E0(__int64);
__int64 __fastcall sub_1400725F0(__int64);
LPITEMIDLIST __fastcall sub_140072600(__int64, int);
LPITEMIDLIST __fastcall sub_140072630(__int64, int);
__int64 __fastcall sub_140072670(__int64, int);
__int64 __fastcall sub_1400726C0(__int64, const ITEMIDLIST *);
__int64 __fastcall sub_140072730(__int64);
__int64 __fastcall sub_140072760(__int64);
BOOL __fastcall sub_1400727B0(__int64, HWND, int *, int);
__int64 __fastcall sub_140072A10(_DWORD *);
__int64 __fastcall sub_140072A40(__int64, _QWORD *, _QWORD *);
char *__fastcall sub_140072AA0(__int64, __int64 *);
char *__fastcall sub_140072B70(__int64, __int64 *);
LPITEMIDLIST __fastcall sub_140072C40(__int64, int);
LRESULT __fastcall sub_140072CF0(__int64);
LRESULT __fastcall sub_140072D50(__int64);
void __fastcall sub_140072E50(__int64, int);
void __fastcall sub_140072E60(__int64, int);
__int64 __fastcall sub_140072E70(__int64);
void __fastcall sub_140072E80(__int64, int);
__int64 __fastcall sub_140072E90(__int64);
void __fastcall sub_140072EA0(__int64, int);
void __fastcall sub_140072EB0(__int64, int);
__int64 __fastcall sub_140072EC0(__int64);
void __fastcall sub_140072ED0(__int64, int);
__int64 __fastcall sub_140072EE0(__int64);
void __fastcall sub_140072EF0(__int64, int);
__int64 __fastcall sub_140072F00(__int64);
void __fastcall sub_140072F10(__int64, int);
__int64 __fastcall sub_140072F20(__int64);
void __fastcall sub_140072F30(__int64, int);
__int64 __fastcall sub_140072F40(__int64);
void __fastcall sub_140072F70(__int64, __int64);
__int64 __fastcall sub_140072F80(__int64);
void *__fastcall sub_140072F90(__int64);
void __fastcall sub_140072FD0(__int64, int);
__int64 __fastcall sub_140072FE0(__int64);
__int64 __fastcall sub_140072FF0(_DWORD *, _DWORD *);
int *__fastcall sub_140073020(_DWORD *);
HRESULT __fastcall sub_140073090(__int64);
__int64 __fastcall sub_140073150(__int64);
__int64 __fastcall sub_140073160(__int64, int);
__int64 __fastcall sub_140073170(__int64, _DWORD *);
__int64 __fastcall sub_140073190(__int64, _DWORD *);
_BOOL8 __fastcall sub_1400731B0(__int64);
__int64 __fastcall sub_1400731D0(__int64);
LRESULT __fastcall sub_1400731E0(__int64);
__int64 __fastcall sub_140073250(__int64, _QWORD *, _QWORD *);
void __fastcall sub_140073350(__int64);
__int64 __fastcall sub_140073A70(void *Block); // idb
char *__fastcall sub_140073AB0(__int64, char **);
LRESULT __fastcall sub_140073BB0(__int64, __int64);
__int64 __fastcall sub_140073D70(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall sub_1400744C0(__int64, __int64, _QWORD *, __int64, __int64, __int64);
LRESULT __fastcall sub_140074550(__int64, unsigned int);
LRESULT __fastcall sub_140074700(__int64, int, int);
LRESULT __fastcall sub_140074880(__int64);
__int64 __fastcall sub_140074A80(ULONG_PTR dwData, unsigned int);
__int64 sub_140074B50();
__int64 __fastcall sub_140074B60(__int64);
__int64 __fastcall sub_140074B70(__int64, int);
__int64 __fastcall sub_140074BA0(__int64, __int64, _QWORD *, _DWORD *);
__int64 __fastcall sub_140074CB0(__int64, _QWORD *, _QWORD *);
void __fastcall sub_140074D40(__int64);
__int64 __fastcall sub_140074DB0(void *Block); // idb
__int64 __fastcall sub_140074E40(__int64, void **);
__int64 __fastcall sub_140074FE0(void **, _QWORD *);
void __fastcall sub_140075080(ULONG_PTR Parameter);
void __fastcall sub_1400750B0(ULONG_PTR Parameter);
void __fastcall __noreturn sub_140075160(ULONG_PTR Parameter);
void __fastcall __noreturn sub_140075180(LPVOID lpThreadParameter);
__int64 __fastcall sub_1400751B0(__int64);
__int64 __fastcall sub_1400751E0(__int64, int);
void __fastcall sub_140075280(__int64);
void __fastcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
void __fastcall sub_1400754E0(ULONG_PTR dwData);
__int64 __fastcall sub_1400755C0(__int64);
__int64 __fastcall sub_140075690(_QWORD *);
__int64 __fastcall sub_1400756D0(__int64, __int64, __int64, int, __int64, int, __int64);
__int64 __fastcall sub_140075880(__int64, __int64, int, __int64, int, void *Block);
__int64 __fastcall sub_140075A50(void *Block); // idb
__int64 __fastcall sub_140075A90(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_140075B00(const WCHAR *);
__int64 __fastcall sub_140075B30(const WCHAR *);
__int64 __fastcall sub_140075B60(__int64);
__int64 __fastcall sub_140075BF0(__int64, signed int);
LRESULT __fastcall sub_140075CF0(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
__int64 __fastcall sub_140075D60(__int64, __int64);
_DWORD *sub_140075E20();
__int64 __fastcall sub_140075E60(LPSTGMEDIUM); // idb
__int64 __fastcall sub_140075F90(LPCWSTR pszDir, LPCVOID lpBuffer, char *);
void __fastcall sub_1400761A0(__int64);
__int64 __fastcall sub_1400762E0(__int64 *);
// __int64 __fastcall sub_1400764D0(_QWORD, _QWORD); weak
// __int64 __fastcall sub_1400767B0(_QWORD); weak
__int64 __fastcall sub_140076C40(LPVOID lpThreadParameter);
// __int64 __fastcall sub_140076D20(_QWORD, _QWORD, _QWORD, _QWORD); weak
void __fastcall sub_140076F00(__int64, HDROP *, int, int);
__int64 __fastcall sub_140077420(__int64, __int64 *, STGMEDIUM *);
__int64 __fastcall sub_140077760(__int64, __int64 *, STGMEDIUM *);
__int64 __fastcall sub_140077970(__int64, __int64 *, STGMEDIUM *);
__int64 __fastcall sub_140077B00(__int64, __int64, __int64 *);
__int64 __fastcall sub_140078370(__int64, int, int, STGMEDIUM *);
void __fastcall sub_1400783F0(__int64, __int64, int *);
void __fastcall sub_1400787D0(__int64, __int64, __int64, __int64, __int64, int);
void __fastcall sub_140078820(__int64, __int64, int, __int64, int *, __int64, int, __int64, __int64);
__int64 __fastcall sub_140078890(__int64);
__int64 __fastcall sub_1400788A0(__int64, int);
__int64 __fastcall sub_1400788B0(__int64, _DWORD *);
__int64 __fastcall sub_1400788C0(__int64, _DWORD *);
__int64 __fastcall sub_1400788D0(__int64);
__int64 sub_1400788E0();
__int64 sub_1400788F0();
__int64 sub_140078900();
__int64 __fastcall sub_140078910(__int64, __int64, __int64);
__int64 sub_140078930();
__int64 __fastcall sub_140078940(__int64, int *, __int64);
__int64 __fastcall sub_140078A40(__int64);
__int64 __fastcall sub_140078A60(__int64, __int64);
__int64 __fastcall sub_140078AF0(_QWORD *, __int16 *, __int64);
__int64 __fastcall sub_140078BF0(__int64, _QWORD *, _QWORD *);
void __fastcall sub_140078CD0(__int64);
__int64 __fastcall sub_140078DC0(__int64, _QWORD *, __int64, int);
__int64 __fastcall sub_140078EA0(void *Block); // idb
__int64 __fastcall sub_140078EE0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_140079060(__int64 *, __int64 *, _QWORD *);
__int64 __fastcall sub_1400790C0(__int64, int, _QWORD *);
void __fastcall sub_1400792A0(__int64);
__int64 __fastcall sub_1400792D0(__int64, __int64);
void __fastcall sub_140079310(__int64);
void **__fastcall sub_140079430(__int64);
__int64 __fastcall sub_1400795F0(HMENU hMenu); // idb
__int64 __fastcall sub_140079660(const ITEMIDLIST *);
_QWORD *__fastcall sub_140079700(__int64, __int64, unsigned int);
__int64 __fastcall sub_1400797A0(__int64, unsigned int);
__int64 __fastcall sub_140079830(__int64, unsigned int, HMENU, HMENU, __int64);
void __fastcall sub_140079960(HMENU hMenu);
void __fastcall sub_140079BD0(__int64, HMENU);
// __int64 __fastcall sub_140079D10(_QWORD); weak
// __int64 __fastcall sub_140079E40(_QWORD, _QWORD, _QWORD, _QWORD); weak
LRESULT __fastcall sub_14007A0F0(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
char __fastcall sub_14007A230(DWORD_PTR dwRefData, HWND hWnd, HMENU hMenu, int *, __int64);
__int64 __fastcall sub_14007A340(__int64, _DWORD *);
__int64 __fastcall sub_14007A580(__int64);
_QWORD *__fastcall sub_14007A9F0(_QWORD *);
// __int64 __fastcall sub_14007AA10(_QWORD); weak
// __int64 __fastcall sub_14007AAE0(_QWORD, _QWORD); weak
// __int64 __fastcall sub_14007ADD0(_QWORD, _QWORD); weak
void __fastcall sub_14007B1C0(__int64 *);
__int64 __fastcall sub_14007B260(_QWORD *, HWND, _QWORD **, int);
__int64 __fastcall sub_14007B2F0(HKEY, const WCHAR *, BYTE *lpData, DWORD);
LSTATUS __fastcall sub_14007B370(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData);
LSTATUS __fastcall sub_14007B3D0(HKEY, const WCHAR *, BYTE *lpData);
LSTATUS __fastcall sub_14007B410(HKEY, const WCHAR *, int);
__int64 __fastcall sub_14007B450(HKEY hKey, __int64, _QWORD **);
__int64 __fastcall sub_14007B580(HKEY hKey, __int64, __int64 *);
__int64 __fastcall sub_14007B740(HKEY, __int64, void *);
OLECHAR *__fastcall sub_14007B860(int);
_BOOL8 __fastcall sub_14007B890(const WCHAR *);
__int64 __fastcall sub_14007B8E0(__int64, __int64 *);
__int64 __fastcall sub_14007B920(__int64 *, __int64, __int64);
VARIANTARG *__fastcall sub_14007B9A0(VARIANTARG *, const OLECHAR *);
__int64 __fastcall sub_14007B9E0(__int64 *, __int64 *, const OLECHAR *, const OLECHAR *, OLECHAR *psz);
LPVOID sub_14007BBA0();
__int64 __fastcall sub_14007BC30(__int64);
__int64 __fastcall sub_14007BD50(__int64 *, _QWORD *, __int64 *, const OLECHAR *, OLECHAR *psz);
HRESULT __fastcall sub_14007BEA0(__int64 *, __int64, const OLECHAR *, const OLECHAR *);
HFONT __fastcall sub_14007BFA0(__int64 *);
unsigned int *__fastcall sub_14007C1F0(unsigned int *, __int64 *);
void __fastcall sub_14007C330(__int64 *, __int64, __int64, _QWORD **);
void __fastcall sub_14007C470(__int64, __int64, int);
LSTATUS __fastcall sub_14007C5C0(__int64, HKEY);
LSTATUS __fastcall sub_14007C6D0(__int64, HKEY);
__int64 __fastcall sub_14007C820(_DWORD *, HWND);
void __fastcall sub_14007C890(__int64, __int64 *, __int64 *);
BOOL __fastcall sub_14007CA00(_DWORD *, HWND, char);
LRESULT __fastcall sub_14007CB00(HWND, int);
__int64 __fastcall sub_14007CB60(HWND hWnd, int cx, int);
HWND __fastcall sub_14007CBE0(HWND hWndParent);
HWND __fastcall sub_14007CCC0(HWND hWndParent);
HWND __fastcall sub_14007CD30(HWND hWndParent, DWORD dwStyle, LPARAM lParam);
HWND __fastcall sub_14007CDD0(HWND hWndParent);
HWND __fastcall sub_14007CE40(HWND hWndParent);
HWND __fastcall sub_14007CED0(HWND hWndParent);
int __fastcall sub_14007CF50(HWND hWnd, LPWSTR pszPath);
void __fastcall sub_14007D150(__int64, __int64);
__int64 __fastcall sub_14007D240(__int64, __int64);
__int64 __fastcall sub_14007D5F0(__int64, __int64);
__int64 __fastcall sub_14007D720(__int64, __int64);
__int64 __fastcall sub_14007D850(__int64, __int64);
__int64 __fastcall sub_14007D990(__int64, __int64);
__int64 __fastcall sub_14007D9E0(__int64, __int64, __int64);
__int64 __fastcall sub_14007DA00(__int64, __int64, __int64);
__int64 __fastcall sub_14007DA50(__int64, __int64, __int64);
__int64 __fastcall sub_14007DA80(__int64, __int64);
_QWORD *__fastcall sub_14007DBC0(__int64, __int64);
__int64 __fastcall sub_14007DCB0(__int64, __int64);
_BOOL8 __fastcall sub_14007DD40(__int64);
__int64 __fastcall sub_14007DD80(char, char, int);
__int64 __fastcall sub_14007DDE0(LPCWSTR lpSrc, LPWSTR lpDest, HANDLE hObject); // idb
__int64 __fastcall sub_14007DE60(int);
__int64 sub_14007DED0();
__int64 sub_14007DF30();
__int64 __fastcall sub_14007DF90(__int64);
__int64 __fastcall sub_14007DFF0(LPCITEMIDLIST pidl, LPITEMIDLIST *);
HRESULT __fastcall sub_14007E090(int csidl, LPWSTR pszBuf);
BOOL __fastcall sub_14007E190(HWND, const WCHAR *, const WCHAR *, const WCHAR *, void *);
__int64 __fastcall sub_14007E1F0(const ITEMIDLIST *, __int64);
__int64 __fastcall sub_14007E270(LPCITEMIDLIST pidl, LPWSTR pszBuf, unsigned int);
__int64 __fastcall sub_14007E340(__int64, const WCHAR *, __int64, __int64, __int64, unsigned int);
int __fastcall sub_14007E500(__int64, IShellFolder **);
HRESULT __fastcall sub_14007E590(int csidl, LPWSTR pszBuf);
__int64 __fastcall sub_14007E5F0(PCNZWCH lpString2, LPWSTR pszBuf); // idb
__int64 __fastcall sub_14007EB20(const ITEMIDLIST *);
__int64 __fastcall sub_14007EBA0(LPCOLESTR lpsz, HMODULE *);
__int64 __fastcall sub_14007ED80(LPCWSTR lpSubKey, __int64 *);
__int64 __fastcall sub_14007EFF0(__int64, void **);
int __fastcall sub_14007F0B0(PCNZWCH lpString2, __int64, char *);
__int64 __fastcall sub_14007F330(__int64, __int64, const ITEMIDLIST *, __int64 ***);
__int64 __fastcall sub_14007F5B0(void *Src); // idb
__int64 __fastcall sub_14007F650(__int64, __int64, __int64, _WORD *, unsigned int);
__int64 __fastcall sub_14007F810(__int64, __int64);
// __int64 __fastcall sub_14007F920(_QWORD); weak
__int64 __fastcall sub_14007FB00(const ITEMIDLIST *);
__int64 __fastcall sub_14007FBA0(__int64, __int64);
__int64 __fastcall sub_14007FC30(__int64, WCHAR *, unsigned int);
// __int64 __fastcall sub_14007FCB0(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140080090(HWND hWnd, HWND); // idb
LRESULT __fastcall sub_140080180(HWND hWnd, int, unsigned int);
__int64 __fastcall sub_140080240(__int64, __int64, _QWORD *, HMODULE);
__int64 __fastcall sub_140080390(LPCWSTR lptstrFilename, _DWORD *, _DWORD *);
__int64 __fastcall sub_140080450(LPCWSTR lptstrFilename, size_t Size); // idb
__int64 __fastcall sub_1400804E0(__int64, void *);
LONG_PTR __fastcall sub_140080520(HWND, unsigned int, int);
__int16 *__fastcall sub_1400805D0(__int16 *, _WORD *);
int __fastcall sub_140080690(LPCWSTR lpString);
__int64 __fastcall sub_140080700(const WCHAR *);
const wchar_t *__fastcall sub_140080780(int);
_BOOL8 __fastcall sub_140080810(LPCWSTR lpSrcStr, LPCWSTR, int);
LRESULT __fastcall sub_1400809C0(HWND, int, LPARAM);
__int64 __fastcall sub_1400809F0(HWND hWnd, int, int);
LRESULT __fastcall sub_140080B70(HWND, int, int);
LRESULT __fastcall sub_140080F00(HWND, int, int);
LONG_PTR __fastcall sub_140081290(HWND, int);
BOOL __fastcall sub_1400812F0(HWND, WCHAR *, const WCHAR *);
__int64 __fastcall sub_140081380(const WCHAR *);
_BOOL8 __fastcall sub_140081430(int);
LRESULT __fastcall sub_140081530(HWND, int);
_BOOL8 __fastcall sub_1400815D0(const WCHAR *, const WCHAR *);
BOOL __fastcall sub_140081670(LPCWSTR lpName, int, void *);
BOOL __fastcall sub_140081730(SYSTEMTIME *lpLocalTime, LPFILETIME lpFileTime);
BOOL __fastcall sub_140081780(const FILETIME *, struct _SYSTEMTIME *);
__int64 __fastcall sub_1400817D0(HMENU, UINT, int);
__int64 __fastcall sub_140081810(HMENU, UINT, int);
HINSTANCE __fastcall sub_140081850(LPCWSTR lpParameters);
LRESULT __fastcall sub_140081900(HWND hWnd, __int64);
LRESULT __fastcall sub_140081B50(HWND, int);
LRESULT __fastcall sub_140081B90(HWND, int, int);
__int64 __fastcall sub_140081BD0(HWND hWnd); // idb
__int64 __fastcall sub_140081CC0(HWND hWnd); // idb
__int64 __fastcall sub_140081D30(HWND hWnd); // idb
BOOL __fastcall sub_140081E00(HWND hWndFrom, HWND hWnd);
__int64 __fastcall sub_140081EE0(_BYTE *);
HRESULT __fastcall sub_140081FD0(const ITEMIDLIST *, _WORD *);
__int64 __fastcall sub_1400820A0(__int64, _WORD *);
__int64 __fastcall sub_140082100(LPCWSTR lpSrcStr, LPCWSTR a2, int a3);
__int64 __fastcall sub_140082260(HWND hWnd, int);
__int64 __fastcall sub_140082350(__int64, int, WCHAR *);
__int64 __fastcall sub_140082600(__int64, int, WCHAR *);
__int64 __fastcall sub_140082920(LPCWSTR lptstrFilename, __int64, _WORD *, DWORD);
__int64 __fastcall sub_140082AC0(wchar_t *);
__int64 __fastcall sub_140082CD0(LPCWSTR lpFileName, wchar_t *);
void __fastcall sub_140082FB0(__int16, char *, unsigned int);
__int64 __fastcall sub_1400830E0(const WCHAR *, char *);
wchar_t *__fastcall sub_1400831A0(__int64 a1);
__int64 __fastcall sub_140083300(const WCHAR *);
__int64 __fastcall sub_140083440(char *, LARGE_INTEGER *);
__int64 __fastcall sub_1400835A0(const FILETIME *, char *, int, int);
_QWORD *__fastcall sub_140083840(char *, _QWORD *);
__int64 __fastcall sub_140083870(LPCWSTR lpString, char *, __int64);
void __fastcall sub_140083A30(HWND hWnd, void *Src);
__int64 __fastcall sub_140083AD0(void *, void *Destination); // idb
void __fastcall sub_140083DE0(__int64, char *, unsigned __int64, int, int);
__int64 sub_140084450();
__int64 sub_140084460();
__int64 sub_140084470();
__int64 sub_140084480();
__int64 sub_140084490();
__int64 sub_1400844A0();
__int64 sub_1400844B0();
__int64 sub_1400844C0();
__int64 sub_1400844D0();
__int64 sub_1400844E0();
void __fastcall sub_140084540(_QWORD *);
// __int64 __fastcall sub_1400845C0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
INT_PTR __fastcall DialogFunc(HWND, unsigned int, __int64, __int64);
HWND __fastcall sub_140084B40(LPARAM dwInitParam, __int64);
INT_PTR __fastcall sub_140084BB0(LPARAM dwInitParam);
_BOOL8 sub_140084BE0();
__int64 __fastcall sub_140084E80(_DWORD *);
__int64 __fastcall sub_1400852B0(__int64);
__int64 __fastcall sub_140085400(__int64);
__int64 __fastcall sub_1400855F0(__int64);
HRESULT __fastcall sub_140085620(__int64);
__int64 __fastcall sub_140085770(__int64);
__int64 __fastcall sub_140085780(__int64, __int64, _QWORD *);
void **__fastcall sub_1400857A0(__int64);
__int64 __fastcall sub_1400857F0(__int64, __int64, int);
void __fastcall sub_140085870(__int64, __int64);
void __fastcall sub_140085A90(__int64);
__int64 __fastcall sub_140085AB0(void *Block); // idb
void __fastcall sub_140085B20(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_140086100(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_1400861F0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_1400864A0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_140086590(__int64);
int __fastcall sub_1400865B0(LPCWSTR lpString1, LPCWSTR, int *, _DWORD *);
__int64 __fastcall sub_1400868E0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_140088040(__int64);
int __fastcall sub_140088060(__int64, __int64 *, const WCHAR *, const WCHAR *);
void __fastcall sub_140089050(__int64 *, __int64 *, __int64);
void __fastcall sub_140089650(__int64, __int64 *, __int64 *, OLECHAR *);
void __fastcall sub_140089880(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_140089990(__int64, _QWORD *);
void __fastcall sub_140089C30(__int64, __int64);
void __fastcall sub_140089CD0(__int64 *, __int64 *, __int64 ***, OLECHAR *, int);
void __fastcall sub_14008A040(__int64 ***, __int64 *, __int64 *);
__int64 __fastcall sub_14008A160(__int64 ***, __int64 *, __int64 *);
void __fastcall sub_14008A250(__int64, __int64 *, __int64 *, __int64);
void __fastcall sub_14008A9A0(__int64, __int64 *, __int64 *);
__int64 __fastcall sub_14008AB00(__int64, __int64, __int64);
__int64 __fastcall sub_14008AF60(__int64, __int64);
void __fastcall sub_14008B040(__int64, __int64 *, __int64);
__int64 __fastcall sub_14008C010(__int64, __int64 *, __int64 *);
void __fastcall sub_14008C100(__int64, __int64);
void __fastcall sub_14008C230(__int64);
__int64 __fastcall sub_14008C250(__int64);
__int64 __fastcall sub_14008C270(__int64);
void __fastcall sub_14008C290(__int64);
void __fastcall sub_14008C2B0(__int64);
__int64 __fastcall sub_14008C2D0(__int64);
void __fastcall sub_14008C2F0(__int64);
__int64 __fastcall sub_14008C310(__int64, __int64 *);
__int64 __fastcall sub_14008C640(__int64 **, __int64);
__int64 __fastcall sub_14008C850(__int64);
void __fastcall sub_14008C870(__int64, __int64 *, __int64);
void __fastcall sub_14008CA80(__int64);
// __int64 __fastcall sub_14008CAA0(_QWORD, _QWORD); weak
void __fastcall sub_14008CF10(__int64, __int64);
void __fastcall sub_14008CFD0(__int64);
// __int64 __fastcall sub_14008CFF0(_QWORD, _QWORD); weak
void __fastcall sub_14008D3E0(__int64);
__int64 __fastcall sub_14008D6D0(__int64);
void __fastcall sub_14008D6F0(__int64);
// __int64 __fastcall sub_14008D700(_QWORD, _QWORD); weak
__int64 __fastcall sub_14008E970(__int64);
int sub_14008E980();
int sub_14008E9E0();
HMODULE __fastcall sub_14008EA50(struct _EXCEPTION_POINTERS *ExceptionInfo);
__int64 __fastcall sub_14008EC90(__int16 *);
__int64 __fastcall sub_14008F2A0(HINSTANCE hInst); // idb
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
LRESULT __fastcall sub_14008FB90(__int64);
BOOL __fastcall sub_14008FCC0(__int64, HWND);
LRESULT __fastcall sub_14008FE00(__int64);
LRESULT __fastcall sub_14008FE70(__int64, int);
LRESULT __fastcall sub_14008FEF0(__int64);
__int64 __fastcall sub_14008FFC0(__int64);
HRESULT __fastcall sub_1400900A0(__int64);
void __fastcall sub_140090450(__int64, char *);
void __fastcall sub_140090870(__int64);
void __fastcall sub_140090960(__int64);
LRESULT __fastcall sub_140090A70(__int64);
__int64 __fastcall sub_140090B00(__int64, __int64, unsigned int, __int64, LPARAM);
__int64 __fastcall sub_140090BB0(__int64, unsigned int, __int64, LPARAM, int, __int64);
HWND __fastcall sub_140090BE0(HWND, int, __int64);
HRESULT __fastcall sub_140090D40(__int64);
HRESULT __fastcall sub_140090E00(__int64);
LRESULT __fastcall sub_140090EF0(__int64);
void __fastcall sub_140091070(__int64);
__int64 __fastcall sub_1400910F0(__int64, __int64, unsigned int, WPARAM, LPARAM lParam);
__int64 __fastcall sub_140091440(__int64, unsigned int, WPARAM, LPARAM, int, __int64);
LRESULT __fastcall sub_140091470(__int64);
HWND __fastcall sub_140091790(__int64);
__int64 __fastcall sub_140091950(__int64);
__int64 __fastcall sub_140091970(__int64);
int __fastcall sub_1400919B0(__int64);
LRESULT __fastcall sub_140091A80(__int64, const WCHAR *);
char **__fastcall sub_140091B80(__int64, _DWORD *, __int64 *);
void __fastcall sub_140091D20(__int64);
__int64 *sub_140091D70();
// __int64 sub_140091E70(void); weak
HRESULT __fastcall sub_140091F50(__int64, __int64 *, __int64);
LSTATUS __fastcall sub_140091FB0(__int64, HKEY);
__int64 __fastcall sub_140092020(__int64);
void __fastcall sub_1400921F0(__int64, const WCHAR *, _WORD *);
int __fastcall sub_140092350(__int64, HKEY);
BOOL __fastcall sub_140092410(__int64);
__int64 __fastcall sub_1400925A0(__int64, __int16);
__int64 __fastcall sub_1400925E0(__int64, __int64);
UINT_PTR __fastcall sub_140092660(__int64, __int64);
LRESULT __fastcall sub_1400926D0(__int64);
__int64 __fastcall sub_140092730(__int64, __int16);
void __fastcall sub_140092760(__int64);
void __fastcall sub_140092820(__int64, int);
void __fastcall sub_140092950(__int64);
__int64 __fastcall sub_140092B70(_QWORD *, __int64, unsigned int, __int64, LPARAM);
__int64 __fastcall sub_140092CF0(__int64, unsigned int, __int64, LPARAM, int, _QWORD *);
int __fastcall sub_140092D20(__int64);
// __int64 __fastcall sub_140092EF0(_QWORD); weak
// __int64 __fastcall sub_1400932D0(_QWORD, _QWORD); weak
void __fastcall sub_1400935F0(__int64);
void __fastcall sub_140093760(__int64);
// __int64 __fastcall sub_140093910(_QWORD, _QWORD, _QWORD); weak
_BOOL8 __fastcall sub_140093C40(__int64, __int64);
BOOL __fastcall sub_140093D70(__int64);
__int64 __fastcall sub_140093E60(__int64, __int64);
__int64 __fastcall sub_140093FD0(__int64, __int64);
__int64 __fastcall sub_140094130(__int64, __int64, unsigned int, __int64, __int64);
__int64 __fastcall sub_1400941D0(__int64, unsigned int, __int64, __int64, int, __int64);
__int64 __fastcall sub_140094200(__int64);
LRESULT __fastcall sub_140094210(__int64);
void __fastcall sub_140094290(__int64, int);
int __fastcall sub_140094400(__int64);
LRESULT __fastcall sub_140094440(__int64, int);
BOOL __fastcall sub_1400944E0(__int64, HMENU);
LRESULT __fastcall sub_1400945C0(__int64);
__int64 __fastcall sub_140094660(__int64, __int64, __int64, int);
_QWORD *__fastcall sub_1400947A0(__int64, int, HICON);
__int64 __fastcall sub_140094820(__int64, int, __int64);
HGDIOBJ __fastcall sub_140094A70(__int64, int);
void __fastcall sub_140094DD0(__int64, int, __int64 *, int);
void __fastcall sub_140094F50(__int64, int);
void __fastcall sub_140095010(__int64, int);
__int64 __fastcall sub_140095060(__int64, int, __int64, LPARAM);
void __fastcall sub_140095300(__int64, int);
void __fastcall sub_1400953F0(__int64, int, int);
void __fastcall sub_140095490(__int64, int);
LRESULT __fastcall sub_1400954F0(__int64, const ITEMIDLIST *, int, int);
__int64 __fastcall sub_140095680(__int64);
_QWORD *__fastcall sub_140095730(__int64, _QWORD *, int);
int __fastcall sub_1400957D0(__int64, int);
int __fastcall sub_1400959D0(__int64);
void __fastcall sub_140095A10(__int64, int);
__int64 __fastcall sub_140095A90(__int64, int);
__int64 __fastcall sub_140095E30(__int64);
int __fastcall sub_140095E70(__int64, int, int);
int __fastcall sub_140095F20(__int64, int);
LRESULT __fastcall sub_140095FC0(__int64, int);
LRESULT __fastcall sub_140096020(__int64, HWND, UINT, WPARAM, LPARAM, int);
LRESULT __fastcall sub_140096530(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
__int64 __fastcall sub_1400965E0(const WCHAR *);
void __fastcall sub_140096670(__int64, unsigned int, int);
void __fastcall sub_140096960(__int64, int);
__int64 __fastcall sub_140096A40(__int64, HWND, unsigned int, HMENU, LPARAM lParam);
__int64 __fastcall sub_140096C90(HWND, unsigned int, HMENU, LPARAM, int, __int64);
int __fastcall sub_140096CC0(__int64, int, int);
__int64 __fastcall sub_140096F90(__int64, const ITEMIDLIST *, int *, const void *, int, int *);
__int64 __fastcall sub_1400974D0(__int64, const WCHAR *, int *, const void *);
struct IDropTargetVtbl *__fastcall sub_140097650(LPDROPTARGET pDropTarget);
__int64 __fastcall sub_1400977B0(__int64);
void __fastcall sub_1400977D0(HWND);
BOOL __fastcall sub_1400977F0(__int64, int);
void __fastcall sub_140097860(__int64, __int64 *);
__int64 __fastcall sub_140097920(__int64, __int64 *, char, struct tagPOINT, int *);
__int64 __fastcall sub_140097C20(__int64, __int64, int, struct tagPOINT, unsigned int *);
__int64 __fastcall sub_140097DE0(__int64, char, struct tagPOINT, unsigned int *);
void __fastcall sub_140097FD0(__int64);
BOOL __fastcall sub_140098010(__int64);
int __fastcall sub_140098140(__int64, int, WPARAM lParam);
__int64 __fastcall sub_140098260(__int64);
__int64 __fastcall sub_140098280(__int64);
HGDIOBJ __fastcall sub_1400982A0(__int64, HWND, HDC);
HRESULT __fastcall sub_140098310(__int64, __int64 *, __int64);
LSTATUS __fastcall sub_140098390(__int64, HKEY);
void **__fastcall sub_140098440(__int64);
void **__fastcall sub_1400984E0(__int64);
__int64 __fastcall sub_140098590(__int64, int);
void __fastcall sub_140098650(__int64);
__int64 __fastcall sub_140098720(__int64, __int64, void **, void **, void **, int);
void __fastcall sub_1400988A0(__int64, const WCHAR *, const OLECHAR *);
__int64 __fastcall sub_140098A50(__int64, HKEY);
__int64 *sub_140098B00();
void __fastcall sub_140098BF0(__int64);
void __fastcall sub_140098D20(__int64);
// __int64 sub_140098DF0(void); weak
void __fastcall sub_140098E40(__int64, __int64, void *);
void __fastcall sub_140098FE0(__int64, void *, _QWORD *);
int __fastcall sub_1400991A0(__int64);
__int64 __fastcall sub_140099290(LPVOID lpThreadParameter);
// __int64 __fastcall sub_1400992B0(_QWORD); weak
__int64 __fastcall sub_140099790(__int64, int);
__int64 __fastcall sub_140099880(__int64);
__int64 __fastcall sub_14009A080(__int64, const ITEMIDLIST *, __int64, unsigned int, const WCHAR *lpWideCharStr, int);
__int64 __fastcall sub_14009A2D0(__int64, const ITEMIDLIST *, __int64, unsigned int);
void __fastcall sub_14009A300(__int64, const ITEMIDLIST *, __int64, int);
void __fastcall sub_14009A430(__int64, __int64, __int64, int *, HMENU hmenu);
__int64 __fastcall sub_14009A5B0(__int64, const ITEMIDLIST *, __int64 ***, _DWORD *, const WCHAR *psz1);
void **__fastcall sub_14009A760(_QWORD *);
LRESULT __fastcall sub_14009A780(HWND, int);
void __fastcall sub_14009A7E0(__int64, int);
__int64 __fastcall sub_14009A8F0(__int64);
__int64 __fastcall sub_14009A910(__int64, __int64);
__int64 __fastcall sub_14009AA50(__int64);
void __fastcall sub_14009AAE0(__int64);
__int64 *sub_14009AB90();
BOOL __fastcall sub_14009AC10(__int64);
__int64 __fastcall sub_14009B060(__int64, __int16);
char **__fastcall sub_14009B190(__int64);
BOOL __fastcall sub_14009B3A0(__int64);
__int64 __fastcall sub_14009B660(__int64);
__int64 *sub_14009B9D0();
__int64 __fastcall sub_14009BA10(__int64, __int64, __int64 **);
int __fastcall sub_14009BB50(__int64, const WCHAR *, __int64);
LSTATUS __fastcall sub_14009BBA0(__int64, HKEY);
LSTATUS __fastcall sub_14009BBF0(__int64, HKEY);
HWND __fastcall sub_14009BC60(__int64, char);
void __fastcall sub_14009BCD0(__int64, __int64);
__int64 __fastcall sub_14009BE30(__int64);
__int64 __fastcall sub_14009BE50(__int64);
__int64 __fastcall sub_14009BE70(__int64, __int64);
HRESULT __fastcall sub_14009BE90(__int64, __int64 *, __int64);
__int64 *sub_14009BEF0();
LRESULT __fastcall sub_14009BF80(__int64, int);
__int64 __fastcall sub_14009C180(__int64);
char **__fastcall sub_14009C260(__int64, _DWORD *, __int64 *);
void __fastcall sub_14009C650(_QWORD *);
__int64 *sub_14009C690();
__int64 __fastcall sub_14009C6D0(__int64);
__int64 __fastcall sub_14009CE50(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall sub_14009CF50(__int64, int);
LRESULT __fastcall sub_14009D200(__int64);
BOOL __fastcall sub_14009D290(__int64);
__int64 __fastcall sub_14009D310(__int64, int);
HWND __fastcall sub_14009D430(__int64, char);
void __fastcall sub_14009D4C0(__int64, __int64);
__int64 __fastcall sub_14009D5B0(__int64);
__int64 __fastcall sub_14009D5D0(__int64);
__int64 __fastcall sub_14009D5F0(__int64, __int64);
__int64 __fastcall sub_14009D610(__int64);
__int64 *sub_14009D6B0();
char **__fastcall sub_14009D730(__int64, _DWORD *, __int64 *);
__int64 *sub_14009DE30();
__int64 __fastcall sub_14009DE70(__int64, __int64, __int64);
void __fastcall sub_14009DEF0(__int64);
__int64 __fastcall sub_14009E1E0(__int64, __int16);
void __fastcall sub_14009E2D0(__int64);
__int64 __fastcall sub_14009E320(__int64);
__int64 __fastcall sub_14009E340(HWND, int, __int64, LPARAM);
UINT __fastcall sub_14009E370(__int64);
LRESULT __fastcall sub_14009E570(__int64);
int __fastcall sub_14009E6E0(__int64, int, int);
int __fastcall sub_14009E850(__int64, int, int);
__int64 __fastcall sub_14009E9C0(__int64, int, int);
__int64 __fastcall sub_14009EA20(int, int, __int64);
char **__fastcall sub_14009EA90(__int64, _DWORD *, __int64 *);
void __fastcall sub_14009EF90(__int64);
__int64 *sub_14009F030();
void **__fastcall sub_14009F270(__int64);
__int64 __fastcall sub_14009F2E0(__int64, __int64, __int64, __int64, int, int, int, int);
void __fastcall sub_14009F450(__int64, int, __int64, int);
void __fastcall sub_14009F720(__int64, const ITEMIDLIST *, __int64, int);
__int64 __fastcall sub_14009F7F0(__int64, const ITEMIDLIST *, __int64 ****, __int64, const WCHAR *psz1);
BOOL __fastcall sub_14009F8C0(__int64, const ITEMIDLIST *, __int64, __int64, HMENU hmenu);
// __int64 sub_14009F9F0(void); weak
void __fastcall sub_14009FB80(__int64);
__int64 __fastcall sub_14009FCD0(void *Block); // idb
__int64 __fastcall sub_14009FD00(__int64);
void __fastcall sub_1400A0460(__int64, const WCHAR *, _WORD *);
void __fastcall sub_1400A0860(__int64, __int64 *, __int64);
void __fastcall sub_1400A0F90(__int64, HKEY);
__int64 __fastcall sub_1400A1330(__int64, int);
__int64 __fastcall sub_1400A1780(WPARAM wParam, __int64);
int __fastcall sub_1400A1C10(__int64, const WCHAR *, __int64 *);
void __fastcall sub_1400A1F50(__int64, const WCHAR *);
__int64 __fastcall sub_1400A2180(__int64);
__int64 __fastcall sub_1400A2260(LPVOID lpThreadParameter);
void __fastcall sub_1400A2280(__int64);
__int64 __fastcall sub_1400A2B00(__int64, __int16);
HWND __fastcall sub_1400A2CA0(__int64);
BOOL __fastcall sub_1400A2CE0(__int64);
__int64 __fastcall sub_1400A2D10(__int64);
__int64 __fastcall sub_1400A2D30(__int64);
__int64 *sub_1400A2DD0();
__int64 __fastcall sub_1400A2E50(__int64);
__int64 *sub_1400A2F70();
__int64 __fastcall sub_1400A2FB0(__int64, __int64, int, __int64);
BOOL __fastcall sub_1400A3030(__int64);
__int64 __fastcall sub_1400A3170(__int64, __int16);
LSTATUS __fastcall sub_1400A3210(__int64, HKEY);
LSTATUS __fastcall sub_1400A32A0(__int64, HKEY);
LSTATUS __fastcall sub_1400A3330(__int64, HKEY);
LSTATUS __fastcall sub_1400A33C0(__int64, HKEY);
LSTATUS __fastcall sub_1400A3460(__int64, HKEY);
LSTATUS __fastcall sub_1400A3500(__int64, HKEY);
LSTATUS __fastcall sub_1400A35A0(__int64, HKEY, __int64, int);
LSTATUS __fastcall sub_1400A3720(__int64);
LSTATUS __fastcall sub_1400A37C0(__int64);
__int64 sub_1400A4710();
__int64 __fastcall sub_1400A47A0(LPBYTE lpData, HKEY *);
LSTATUS __fastcall sub_1400A4810(__int64);
LSTATUS __fastcall sub_1400A4820(__int64);
LSTATUS __fastcall sub_1400A4830(__int64);
LSTATUS __fastcall sub_1400A4A70(__int64);
LSTATUS __fastcall sub_1400A4CD0(HKEY hKey, __int64, int);
void __fastcall sub_1400A4E60(HKEY hKey, LPCWSTR lpValueName, __int64 ***);
void __fastcall sub_1400A4F10(HKEY hKey, LPCWSTR lpValueName, __int64 ***);
LSTATUS __fastcall sub_1400A5010(__int64, HKEY, __int64, int);
LSTATUS __fastcall sub_1400A5280(__int64);
LSTATUS __fastcall sub_1400A5380(__int64);
LSTATUS __fastcall sub_1400A5390(__int64);
LSTATUS __fastcall sub_1400A53A0(__int64);
LSTATUS __fastcall sub_1400A53B0(__int64, HKEY);
LSTATUS __fastcall sub_1400A5630(__int64);
LSTATUS __fastcall sub_1400A5690(_QWORD *);
LSTATUS __fastcall sub_1400A5E20(__int64);
LSTATUS __fastcall sub_1400A6C50(__int64, HKEY, __int64);
LSTATUS __fastcall sub_1400A7070(__int64);
__int64 __fastcall sub_1400A7110(__int64);
LSTATUS __fastcall sub_1400A8080(__int64);
LSTATUS __fastcall sub_1400A8090(__int64);
LSTATUS __fastcall sub_1400A80A0(__int64);
LSTATUS __fastcall sub_1400A8100(__int64);
__int64 __fastcall sub_1400A8110(__int64);
DWORD __fastcall sub_1400A8120(HKEY, const WCHAR *, __int64 *);
DWORD __fastcall sub_1400A8250(HKEY, const WCHAR *, __int64 *);
// __int64 __fastcall sub_1400A83A0(_QWORD); weak
__int64 __fastcall sub_1400A8C10(__int64);
LSTATUS __fastcall sub_1400A8C20(__int64);
LSTATUS __fastcall sub_1400A8DF0(__int64);
// __int64 __fastcall sub_1400A8E00(_QWORD, _QWORD); weak
LSTATUS __fastcall sub_1400A9170(__int64);
LSTATUS __fastcall sub_1400A9200(__int64);
// __int64 __fastcall sub_1400A9210(_QWORD); weak
// __int64 __fastcall sub_1400A9590(_QWORD); weak
__int64 __fastcall sub_1400A9950(__int64);
__int64 __fastcall sub_1400A9960(__int64);
// __int64 __fastcall sub_1400A9970(_QWORD); weak
__int64 __fastcall sub_1400AB0A0(__int64);
__int64 __fastcall sub_1400AB0B0(_DWORD *, HWND);
int __fastcall sub_1400AB120(HWND hWnd);
LRESULT __fastcall sub_1400AB230(HWND, __int64);
int __fastcall sub_1400AB310(__int64, HWND);
HWND __fastcall sub_1400AB4B0(__int64, HWND);
int __fastcall sub_1400AB5B0(HWND, HMENU);
HWND __fastcall sub_1400AB670(__int64, HWND);
__int64 __fastcall sub_1400AB7F0(HWND, __int64);
int __fastcall sub_1400AB8C0(__int64, HWND, __int64);
BOOL __fastcall sub_1400ABA40(_DWORD *, HWND);
LRESULT __fastcall sub_1400ABAC0(HWND, int);
LRESULT __fastcall sub_1400ABC10(HWND, int);
HWND __fastcall sub_1400ABD40(LPARAM, HWND, HWND, int);
HWND __fastcall sub_1400ABE30(LPARAM, HWND);
BOOL __fastcall sub_1400ABEA0(__int64, HWND);
__int64 __fastcall sub_1400AC220(HWND hDlg, int, HMENU, __int64);
INT_PTR __fastcall sub_1400AC400(HWND hDlg, int, HMENU, __int64);
BOOL __fastcall sub_1400AC420(HWND hDlg);
BOOL __fastcall sub_1400AC470(HWND hDlg);
LRESULT __fastcall sub_1400AC4F0(HWND, int);
LRESULT __fastcall sub_1400AC530(HWND hWnd, LPCITEMIDLIST pidl);
__int64 __fastcall sub_1400AC620(HWND, int);
__int64 __fastcall sub_1400AC650(HWND, int);
__int64 __fastcall sub_1400AC670(HWND hWnd, __int64, const WCHAR *);
LRESULT __fastcall sub_1400AC870(__int64, HWND);
void __fastcall sub_1400ACA90(HWND hWnd, __int64);
void __fastcall sub_1400ACAE0(HWND hDlg);
__int64 __fastcall sub_1400ACC80(HWND hDlg, int, unsigned __int16, __int64);
__int64 __fastcall sub_1400ACF80(HWND hDlg, int, unsigned __int16, __int64);
__int64 __fastcall sub_1400ACFA0(HWND hDlg, int, int, __int64);
__int64 __fastcall sub_1400AD8E0(HWND hDlg, int, int, __int64);
__int64 __fastcall sub_1400AD900(HWND hDlg, int, int, __int64);
__int64 __fastcall sub_1400ADF70(HWND hDlg, int, int, __int64);
__int64 __fastcall sub_1400ADF90(HWND hDlg, int, unsigned __int16, __int64);
__int64 __fastcall sub_1400AE500(HWND hDlg, int, unsigned __int16, __int64);
__int64 __fastcall sub_1400AE520(HWND hDlg, int, unsigned __int16, __int64);
__int64 __fastcall sub_1400AEC60(HWND hDlg, int, unsigned __int16, __int64);
HWND __fastcall sub_1400AEC80(__int64);
__int64 __fastcall sub_1400AEF20(__int64);
__int64 __fastcall sub_1400AEF30(__int64);
HWND __fastcall sub_1400AEF40(__int64, int);
BOOL __fastcall sub_1400AEF70(__int64);
__int64 __fastcall sub_1400AEFA0(__int64, unsigned int);
__int64 __fastcall sub_1400AF050(__int64, unsigned int);
__int64 __fastcall sub_1400AF190(int);
BOOL __fastcall sub_1400AF210(__int64, int);
LRESULT __fastcall sub_1400AF280(__int64, __int64, int);
__int64 __fastcall sub_1400AF340(__int64);
LRESULT __fastcall sub_1400AF3B0(__int64, int);
LONG_PTR __fastcall sub_1400AF3E0(__int64);
void __fastcall sub_1400AF530(HMENU hMenu, UINT uPosition, int csidl);
HWND __fastcall sub_1400AF640(__int64);
HWND __fastcall sub_1400AF730(__int64);
__int64 __fastcall sub_1400AF800(__int64, unsigned int);
unsigned __int64 __fastcall sub_1400AF8A0(__int64 a1);
LRESULT __fastcall sub_1400AF910(__int64, int);
LRESULT __fastcall sub_1400AF980(LRESULT, WPARAM, LPARAM);
LRESULT __fastcall sub_1400AF9E0(__int64, __int64);
__int64 __fastcall sub_1400AFA70(__int64, int, int);
BOOL __fastcall sub_1400AFF20(__int64, int);
BOOL __fastcall sub_1400AFF90(__int64);
void __fastcall sub_1400B00D0(__int64, ITEMIDLIST *, const WCHAR *);
void __fastcall sub_1400B01C0(__int64, unsigned int, unsigned int, unsigned int);
int __fastcall sub_1400B0270(HMENU, UINT, int);
BOOL __fastcall sub_1400B02C0(HMENU hmenu, UINT item);
void __fastcall sub_1400B0350(__int64, HMENU);
__int64 sub_1400B0390();
__int64 __fastcall sub_1400B0470(__int64);
// void __stdcall CoUninitialize();
void __fastcall sub_1400B04B0(ULONG_PTR Parameter);
void __fastcall __noreturn sub_1400B04D0(LPVOID lpThreadParameter);
__int64 __fastcall sub_1400B0500(__int64);
BOOL __fastcall sub_1400B0600(__int64);
__int64 __fastcall sub_1400B0710(__int64, int);
__int64 __fastcall sub_1400B0830(__int64);
void __fastcall sub_1400B08E0(__int64, HMENU, int);
BOOL __fastcall sub_1400B0A00(__int64);
void __fastcall sub_1400B0B20(__int64);
__int64 __fastcall sub_1400B0C20(__int64, __int64, unsigned int, unsigned int, int);
LRESULT __fastcall sub_1400B0CD0(__int64, int, __int64);
HWND __fastcall sub_1400B0D80(__int64);
void __fastcall sub_1400B0F60(__int64, __int64);
void __fastcall sub_1400B0FC0(__int64);
void sub_1400B10F0();
__int64 __fastcall sub_1400B12B0(__int64);
void __fastcall sub_1400B1390(__int64);
void __fastcall sub_1400B1460(__int64);
void __fastcall sub_1400B14E0(__int64);
_QWORD *__fastcall sub_1400B1560(__int64);
__int64 __fastcall sub_1400B1600(__int64, int);
__int64 __fastcall sub_1400B16A0(__int64);
void __fastcall sub_1400B1720(__int64, __int64);
void __fastcall sub_1400B1740(__int64);
char *__fastcall sub_1400B19A0(__int64);
char *__fastcall sub_1400B1AA0(__int64);
char *__fastcall sub_1400B1BA0(__int64);
char *__fastcall sub_1400B1CA0(__int64);
char *__fastcall sub_1400B1DA0(__int64);
char *__fastcall sub_1400B1EA0(__int64);
char *__fastcall sub_1400B1FA0(__int64);
char *__fastcall sub_1400B2090(__int64);
int __fastcall sub_1400B2260(__int64);
void __fastcall sub_1400B2930(__int64, _QWORD *);
__int64 __fastcall sub_1400B2A70(__int64);
__int64 __fastcall sub_1400B2B30(__int64, __int64);
LRESULT __fastcall sub_1400B2D70(__int64);
int __fastcall sub_1400B35A0(__int64);
void __fastcall sub_1400B3750(__int64, int);
void __fastcall sub_1400B37C0(__int64);
void __fastcall sub_1400B39C0(__int64, int);
void __fastcall sub_1400B39F0(__int64);
void __fastcall sub_1400B3BC0(__int64, int);
void __fastcall sub_1400B3CD0(__int64, unsigned __int64);
HWND __fastcall sub_1400B3E30(__int64 a1, int a2);
__int64 __fastcall sub_1400B3EC0(__int64, const ITEMIDLIST *, __int64, int, int, int);
__int64 __fastcall sub_1400B40A0(__int64, const ITEMIDLIST *);
void __fastcall sub_1400B4150(__int64, __int64);
__int64 __fastcall sub_1400B4260(__int64, const ITEMIDLIST *, int, int);
void __fastcall sub_1400B42E0(__int64, const ITEMIDLIST *, int, int);
void __fastcall sub_1400B46F0(__int64, int);
HWND __fastcall sub_1400B4750(LPDROPTARGET pDropTarget);
__int64 __fastcall sub_1400B4C70(__int64);
__int64 __fastcall sub_1400B4C80(__int64, int);
__int64 __fastcall sub_1400B4E20(__int64, int);
_BOOL8 __fastcall sub_1400B50D0(LPCWSTR lptstrFilename);
__int64 __fastcall sub_1400B52C0(__int64);
BOOL __fastcall sub_1400B5340(__int64, int *);
__int64 __fastcall sub_1400B53E0(_DWORD *, int);
BOOL __fastcall sub_1400B5450(__int64, __int64, _QWORD *);
void __fastcall sub_1400B54B0(__int64, __int64, _QWORD *, _DWORD *);
void __fastcall sub_1400B5510(__int64, unsigned int, int *);
_BOOL8 __fastcall sub_1400B5590(__int64, int);
__int64 __fastcall sub_1400B5600(__int64);
__int64 __fastcall sub_1400B56A0(__int64);
__int64 __fastcall sub_1400B57C0(__int64, __int64);
__int64 __fastcall sub_1400B5880(__int64, __int64);
LRESULT __fastcall sub_1400B5950(HWND hWnd, LPCWSTR pszPath, LPARAM);
void __fastcall sub_1400B5A20(__int64, unsigned int);
__int64 __fastcall sub_1400B5B60(__int64);
BOOL __fastcall sub_1400B5BA0(__int64);
__int64 __fastcall sub_1400B5CC0(__int64, HWND);
void __fastcall sub_1400B5E90(_DWORD *);
__int64 __fastcall sub_1400B5F60(__int64, __int64);
_BOOL8 __fastcall sub_1400B5FD0(__int64);
_BOOL8 __fastcall sub_1400B6040(__int64);
void __fastcall sub_1400B60B0(__int64);
_BOOL8 __fastcall sub_1400B61E0(__int64);
__int64 __fastcall sub_1400B6250(__int64);
__int64 __fastcall sub_1400B64E0(HWND *, WPARAM, LPARAM);
void __fastcall sub_1400B66C0(int, __int64 ****);
void __fastcall sub_1400B6860(_QWORD *);
void __fastcall sub_1400B6DB0(__int64);
void __fastcall sub_1400B6E60(__int64);
void __fastcall sub_1400B6EC0(__int64);
void __fastcall sub_1400B7020(__int64, int);
__int64 __fastcall sub_1400B72E0(__int64, int, __int64);
int __fastcall sub_1400B7390(char *, __int64 *, __int64 *);
LRESULT __fastcall sub_1400B74F0(__int64);
unsigned int __fastcall sub_1400B76E0(__int64);
void __fastcall sub_1400B7FB0(__int64);
void __fastcall sub_1400B8250(__int64);
__int64 __fastcall sub_1400B82C0(__int64);
__int64 __fastcall sub_1400B85E0(__int64, __int64);
void __fastcall sub_1400B88E0(__int64);
BOOL __fastcall sub_1400B8920(__int64);
int __fastcall sub_1400B89F0(__int64, int, WPARAM lParam);
__int64 __fastcall sub_1400B8B10(__int64);
__int64 __fastcall sub_1400B8B30(__int64);
__int64 __fastcall sub_1400B8B50(__int64);
__int64 *sub_1400B8BE0();
char **__fastcall sub_1400B8C60(__int64, _DWORD *, __int64 *);
_BOOL8 __fastcall sub_1400B9150(const WCHAR *, const WCHAR *);
__int64 *sub_1400B91E0();
void **__fastcall sub_1400B9220(__int64);
void __fastcall sub_1400B92A0(__int64);
int __fastcall sub_1400B9370(__int64);
__int64 __fastcall sub_1400B95F0(LPVOID lpThreadParameter);
// __int64 __fastcall sub_1400B9610(_QWORD, _QWORD, _QWORD, _QWORD); weak
LRESULT __fastcall sub_1400B9730(__int64, char);
void __fastcall sub_1400B9990(__int64);
void __fastcall sub_1400B9AC0(__int64);
__int64 __fastcall sub_1400B9D20(__int64, __int16);
__int64 __fastcall sub_1400B9DB0(__int64);
int __fastcall sub_1400BA8B0(__int64, const WCHAR *, __int64);
LSTATUS __fastcall sub_1400BA940(__int64, HKEY);
LSTATUS __fastcall sub_1400BA9D0(__int64, HKEY);
__int64 __fastcall sub_1400BAAA0(__int64);
__int64 __fastcall sub_1400BAAD0(__int64);
HRESULT __fastcall sub_1400BAAF0(__int64, __int64 *, __int64);
__int64 __fastcall sub_1400BAB90(__int64);
__int64 *sub_1400BAC70();
char **__fastcall sub_1400BAD00(__int64, _DWORD *, __int64 *);
__int64 *sub_1400BAF50();
void __fastcall sub_1400BAF90(__int64);
__int64 __fastcall sub_1400BAFE0(__int64);
__int64 __fastcall sub_1400BB450(__int64, __int64, void **, __int64);
void __fastcall sub_1400BB540(_QWORD *, const WCHAR *, __int64, __int64 *);
char __fastcall sub_1400BC5B0(int);
__int64 __fastcall sub_1400BC640(int);
__int64 __fastcall sub_1400BC740(int);
LRESULT __fastcall sub_1400BC840(__int64);
char **__fastcall sub_1400BCEA0(__int64);
LRESULT __fastcall sub_1400BD730(__int64);
__int64 __fastcall sub_1400BD980(__int64, __int64);
void __fastcall sub_1400BD9D0(__int64);
void __fastcall sub_1400BDB10(__int64, _QWORD *);
__int64 __fastcall sub_1400BDC90(__int64, _QWORD *);
__int64 __fastcall sub_1400BDDF0(__int64, _QWORD *);
__int64 __fastcall sub_1400BDEC0(__int64, HWND);
LRESULT __fastcall sub_1400BDF00(__int64, int);
LRESULT __fastcall sub_1400BDFC0(__int64, WPARAM, LPARAM);
HWND __fastcall sub_1400BE090(__int64, HWND);
void __fastcall sub_1400BE160(__int64, __int64);
void __fastcall sub_1400BE430(__int64, unsigned int, _WORD *);
int __fastcall sub_1400BE5E0(__int64, int);
HMENU __fastcall sub_1400BE810(__int64);
void __fastcall sub_1400BEAF0(__int64, __int64);
void __fastcall sub_1400BEBE0(__int64);
__int64 __fastcall sub_1400BEE30(__int64, HWND, unsigned int, __int64, __int64);
__int64 __fastcall sub_1400BF0D0(HWND, unsigned int, __int64, __int64, int, __int64);
__int64 __fastcall sub_1400BF100(__int64, __int64);
void __fastcall sub_1400BF190(__int64, HWND, __int64 **);
HRESULT __fastcall sub_1400BF3D0(__int64);
// __int64 __fastcall sub_1400BF540(_QWORD, _QWORD); weak
// __int64 __fastcall sub_1400BF8A0(_QWORD); weak
// __int64 __fastcall sub_1400BFBF0(_QWORD); weak
void __fastcall sub_1400BFEC0(__int64);
void __fastcall sub_1400C0210(__int64, int);
// __int64 __fastcall sub_1400C0510(_QWORD, _QWORD, _QWORD); weak
void __fastcall sub_1400C0A40(__int64, int *);
BOOL __fastcall sub_1400C0CD0(__int64, int *);
void __fastcall sub_1400C0ED0(__int64, struct tagPOINT *);
__int64 __fastcall sub_1400C1030(__int64, __int64);
__int64 __fastcall sub_1400C1700(__int64, __int64);
// __int64 __fastcall sub_1400C1AD0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_1400C20F0(HWND, unsigned int, __int64, __int64);
__int64 __fastcall sub_1400C2150(__int64, __int64);
__int64 sub_1400C23F0();
__int64 __fastcall sub_1400C2400(__int64, int, int);
__int64 __fastcall sub_1400C2490(volatile signed __int32 *);
__int64 __fastcall sub_1400C24F0(_QWORD *, int);
__int64 __fastcall sub_1400C2550(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400C25E0(__int64);
__int64 __fastcall sub_1400C2600(__int64, __int64);
__int64 __fastcall sub_1400C2670(__int64, __int16);
__int64 __fastcall sub_1400C26C0(__int64);
__int64 __fastcall sub_1400C2770(__int64);
__int64 __fastcall sub_1400C2790(__int64);
__int64 __fastcall sub_1400C27B0(__int64);
char **__fastcall sub_1400C2850(__int64, _DWORD *, __int64 *);
void __fastcall sub_1400C29F0(__int64);
__int64 *sub_1400C2A40();
// __int64 sub_1400C2AE0(void); weak
void __fastcall sub_1400C2BC0(__int64, __int64 *, __int64);
__int64 __fastcall sub_1400C2BF0(__int64, HKEY);
__int64 __fastcall sub_1400C2C10(__int64);
void __fastcall sub_1400C2E60(__int64, const WCHAR *, _WORD *);
__int64 __fastcall sub_1400C2F60(__int64, HKEY);
BOOL __fastcall sub_1400C2F80(__int64);
__int64 __fastcall sub_1400C3220(__int64, __int16);
__int64 __fastcall sub_1400C3260(__int64, __int64, int);
__int64 __fastcall sub_1400C3290(__int64, _DWORD *);
__int64 sub_1400C32A0();
__int64 sub_1400C32B0();
__int64 sub_1400C32C0();
__int64 sub_1400C32D0();
__int64 sub_1400C32E0();
__int64 sub_1400C32F0();
__int64 sub_1400C3300();
__int64 sub_1400C3310();
__int64 sub_1400C3320();
__int64 sub_1400C3330();
__int64 sub_1400C3340();
__int64 sub_1400C3350();
__int64 sub_1400C3360();
__int64 __fastcall sub_1400C3370(__int64, const ITEMIDLIST *);
__int64 sub_1400C33F0();
__int64 sub_1400C3400();
__int64 sub_1400C3410();
__int64 __fastcall sub_1400C3420(__int64);
__int64 __fastcall sub_1400C3430(__int64, __int64, _QWORD *);
__int64 __fastcall sub_1400C3490(__int64);
__int64 __fastcall sub_1400C3640(__int64);
__int64 __fastcall sub_1400C3780(__int64);
__int64 __fastcall sub_1400C3790(__int64, __int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400C3840(_DWORD *);
HMENU __fastcall sub_1400C3870(__int64, int);
__int64 __fastcall sub_1400C3B00(__int64, _QWORD *, _QWORD *);
void __fastcall sub_1400C3B60(__int64);
__int64 __fastcall sub_1400C4200(void *Block); // idb
__int64 __fastcall sub_1400C4240(__int64, __int64);
LRESULT __fastcall sub_1400C4D10(__int64);
int __fastcall sub_1400C4E10(__int64, const WCHAR *);
LRESULT __fastcall sub_1400C4F00(__int64, const WCHAR *);
LRESULT __fastcall sub_1400C4FE0(__int64, const WCHAR *);
void __fastcall sub_1400C51C0(__int64);
__int64 __fastcall sub_1400C54E0(__int64, __int64, unsigned int, __int64, __int64);
__int64 __fastcall sub_1400C55D0(__int64, unsigned int, __int64, __int64, int, __int64);
__int64 __fastcall sub_1400C5600(_DWORD *, HWND);
LRESULT __fastcall sub_1400C5670(HWND hDlg, HWND hWnd);
UINT __fastcall sub_1400C58B0(HWND hDlg);
BOOL __fastcall sub_1400C5AB0(__int64, HWND);
LRESULT __fastcall sub_1400C5C80(__int64);
BOOL __fastcall sub_1400C5DA0(__int64, HWND);
__int64 __fastcall sub_1400C6360(HWND hDlg, int, int, HWND);
INT_PTR __fastcall sub_1400C67E0(HWND hDlg, int, int, HWND);
int __fastcall sub_1400C6800(__int64, const WCHAR *, __int64);
LSTATUS __fastcall sub_1400C6850(__int64, HKEY);
LSTATUS __fastcall sub_1400C68A0(__int64, HKEY);
__int64 __fastcall sub_1400C6930(__int64);
__int64 __fastcall sub_1400C6950(__int64);
HGDIOBJ __fastcall sub_1400C6970(__int64, HWND, HDC);
HRESULT __fastcall sub_1400C69E0(__int64, __int64 *, __int64);
__int64 __fastcall sub_1400C6A40(__int64);
__int64 *sub_1400C6AF0();
char **__fastcall sub_1400C6B80(__int64, _DWORD *, __int64 *);
void __fastcall sub_1400C6F20(__int64);
__int64 *sub_1400C6F70();
BOOL __fastcall sub_1400C6FB0(__int64);
BOOL __fastcall sub_1400C7090(__int64);
__int64 __fastcall sub_1400C7120(__int64, __int16);
__int64 __fastcall sub_1400C7160(__int64, __int64, void **, int);
__int64 __fastcall sub_1400C7250(__int64);
__int64 __fastcall sub_1400C77A0(__int64);
__int64 __fastcall sub_1400C77C0(__int64);
__int64 __fastcall sub_1400C77E0(__int64);
char **__fastcall sub_1400C7860(__int64, _DWORD *, __int64 *);
__int64 *sub_1400C7BC0();
__int64 __fastcall sub_1400C7C40(HWND hWnd, char *, int);
__int64 *sub_1400C7E00();
__int64 __fastcall sub_1400C7E40(__int64, __int64, __int64);
void __fastcall sub_1400C7EC0(__int64, int);
HWND __fastcall sub_1400C81A0(__int64);
__int64 __fastcall sub_1400C8200(__int64, __int64);
HWND __fastcall sub_1400C8230(__int64);
LRESULT __fastcall sub_1400C8750(__int64, int);
// __int64 sub_1400C8820(void); weak
__int64 __fastcall sub_1400C8A20(__int64, unsigned __int16);
LSTATUS __fastcall sub_1400C8AD0(__int64, HKEY);
LSTATUS __fastcall sub_1400C8B60(__int64, HKEY);
__int64 __fastcall sub_1400C8C00(__int64);
__int64 __fastcall sub_1400C8C40(__int64);
HRESULT __fastcall sub_1400C8CE0(unsigned __int8 *, __int64 *, __int64);
__int64 *sub_1400C9140();
__int64 *sub_1400C91E0();
__int64 __fastcall sub_1400C9220(__int64, __int64, __int64, __int64, int);
int __fastcall sub_1400C92A0(__int64);
__int64 __fastcall sub_1400C9330(__int64, HWND, unsigned int, HDC, __int64);
__int64 __fastcall sub_1400C93C0(HWND, unsigned int, HDC, __int64, int, __int64);
__int64 __fastcall sub_1400C93F0(__int64);
void __fastcall sub_1400C9650(__int64, WCHAR *, __int64);
BOOL __fastcall sub_1400C9A40(__int64);
__int64 __fastcall sub_1400C9B70(__int64, int);
HRESULT __fastcall sub_1400C9BE0(__int64);
__int64 __fastcall sub_1400C9C40(__int64);
__int64 __fastcall sub_1400C9C90(__int64, __int64, __int64, _DWORD *);
__int64 __fastcall sub_1400C9DC0(__int64, __int64 *, __int64, __int64, _DWORD *);
__int64 __fastcall sub_1400C9F70(__int64);
__int64 __fastcall sub_1400C9F80(__int64, __int64, _QWORD *);
__int64 __fastcall sub_1400C9FC0(_DWORD *);
_QWORD *__fastcall sub_1400C9FF0(_QWORD *, __int64);
__int64 __fastcall sub_1400CA060(__int64, __int64 *, __int64, __int64, unsigned int *);
__int64 __fastcall sub_1400CA4B0(__int64, HWND, __int64);
LRESULT __fastcall sub_1400CA550(__int64, __int64);
__int64 __fastcall sub_1400CA6E0(__int64);
__int64 __fastcall sub_1400CA750(HWND hWnd, __int64);
LRESULT __fastcall sub_1400CA7E0(__int64, __int64);
__int64 __fastcall sub_1400CA8E0(__int64, __int64, int);
__int64 __fastcall sub_1400CA970(__int64, const WCHAR *, unsigned int, int);
__int64 __fastcall sub_1400CAA90(int, HWND, LPARAM, int, int);
__int64 __fastcall sub_1400CAC10(HWND hWnd, char *);
__int64 __fastcall sub_1400CAD70(__int64, HWND, LPARAM, __int64);
void __fastcall sub_1400CAF10(__int64, __int64);
int __fastcall sub_1400CB0B0(__int64, HMENU, __int64, UINT);
int __fastcall sub_1400CB360(__int64);
INT_PTR __fastcall sub_1400CB4B0(LPARAM, int);
void __fastcall sub_1400CB560(__int64, int);
void __fastcall sub_1400CB600(__int64, int, int);
__int64 __fastcall sub_1400CB700(HMENU, UINT, char *);
__int64 __fastcall sub_1400CB7C0(__int64, __int64, unsigned int, __int64, __int64);
__int64 __fastcall sub_1400CB8D0(__int64, unsigned int, __int64, __int64, int, __int64);
void __fastcall sub_1400CB930(__int64);
void __fastcall sub_1400CBA10(LPARAM, int);
BOOL __fastcall sub_1400CBAC0(__int64);
__int64 __fastcall sub_1400CBBC0(int);
__int64 __fastcall sub_1400CBD80(int);
__int64 __fastcall sub_1400CBF40(__int64);
__int64 __fastcall sub_1400CC010(int);
__int64 __fastcall sub_1400CC1C0(__int64, HMENU);
char **__fastcall sub_1400CC320(__int64);
void __fastcall sub_1400CCA00(__int64);
BOOL __fastcall sub_1400CCC60(__int64);
HWND __fastcall sub_1400CCD20(HWND hWnd);
HWND __fastcall sub_1400CCDC0(__int64, HWND);
void __fastcall sub_1400CCE80(__int64, int);
__int64 __fastcall sub_1400CCFF0(__int64, __int64);
void __fastcall sub_1400CD150(__int64);
void __fastcall sub_1400CD320(__int64, int);
BOOL __fastcall sub_1400CD480(__int64, HWND);
HRESULT __fastcall sub_1400CD550(__int64);
void __fastcall sub_1400CD620(__int64, int, const WCHAR *);
__int64 __fastcall sub_1400CD750(__int64, __int64, __int64, int, __int64);
BOOL __fastcall sub_1400CD870(__int64, HWND);
int __fastcall sub_1400CD970(HWND hDlg);
__int64 __fastcall sub_1400CDA80(HWND, int, __int16);
__int64 __fastcall sub_1400CDAF0(HWND hDlg, int, __int16, __int64);
__int64 __fastcall sub_1400CDB80(HWND, int, __int16);
INT_PTR __fastcall sub_1400CDC00(HWND, int, __int16, __int64);
void __fastcall sub_1400CDC30(LPARAM dwInitParam, int);
HRESULT __fastcall sub_1400CDCD0(__int64);
__int64 __fastcall sub_1400CDD30(__int64);
__int64 __fastcall sub_1400CDD50(__int64, __int64, __int64, _DWORD *);
__int64 sub_1400CDD90(__int64, __int64 *, __int64, ...);
__int64 __fastcall sub_1400CDE40(__int64);
__int64 __fastcall sub_1400CDE50(__int64, __int64, _QWORD *);
_QWORD *__fastcall sub_1400CDE90(_QWORD *, __int64);
__int64 __fastcall sub_1400CDF00(_DWORD *);
__int64 __fastcall sub_1400CDF30(__int64, __int64 *, __int64, struct tagPOINT, unsigned int *);
__int64 __fastcall sub_1400CE300(_DWORD *, HWND);
BOOL __fastcall sub_1400CE370(HWND hWnd);
BOOL __fastcall sub_1400CEB20(__int64, HWND);
BOOL __fastcall sub_1400CEF80(__int64, HWND, __int64);
INT_PTR __fastcall sub_1400CF1C0(LPARAM dwInitParam, HWND hWndParent);
__int64 __fastcall sub_1400CF2C0(HWND hWndParent, int, __int16, __int64);
INT_PTR __fastcall sub_1400CF380(HWND hWndParent, int a2, __int16 a3, LPARAM *a4);
__int64 __fastcall sub_1400CF480(wchar_t *, __int64, const wchar_t *, va_list);
__int64 __fastcall sub_1400CF4E0(__int64);
__int64 __fastcall sub_1400CF510(__int64, __int64);
__int64 __fastcall sub_1400CF580(__int64, __int16);
__int64 __fastcall sub_1400CF6A0(__int64);
HWND *__fastcall sub_1400CF970(__int64, int, int);
void __fastcall sub_1400CFB70(__int64);
BOOL __fastcall sub_1400CFD80(__int64);
void __fastcall sub_1400D0130(__int64);
void __fastcall sub_1400D0250(__int64, int, int);
void __fastcall sub_1400D03E0(__int64, int);
BOOL __fastcall sub_1400D05E0(__int64);
BOOL __fastcall sub_1400D0B20(__int64, HMENU);
LRESULT __fastcall sub_1400D12A0(__int64, int, int, const WCHAR *);
void __fastcall sub_1400D1430(__int64, int, int);
void __fastcall sub_1400D14A0(__int64, int);
void __fastcall sub_1400D16B0(__int64);
void __fastcall sub_1400D1700(__int64);
void __fastcall sub_1400D17A0(__int64);
void __fastcall sub_1400D17F0(__int64);
int __fastcall sub_1400D1840(__int64);
void __fastcall sub_1400D1890(__int64, HWND *);
void __fastcall sub_1400D1940(__int64, int);
void __fastcall sub_1400D19A0(__int64);
HWND __fastcall sub_1400D1A20(__int64, unsigned int);
void __fastcall sub_1400D1A80(__int64);
void __fastcall sub_1400D1AD0(__int64);
__int64 __fastcall sub_1400D1B10(int, __int64);
_BOOL8 __fastcall sub_1400D1C80(__int64);
__int64 __fastcall sub_1400D1DE0(int, const WCHAR *, const WCHAR *);
__int64 sub_1400D2040();
// __int64 __fastcall sub_1400D22C0(_QWORD); weak
_QWORD *__fastcall sub_1400D2390(_QWORD *, void *, const ITEMIDLIST *, void **);
LRESULT __fastcall sub_1400D26B0(__int64 *, HWND, UINT, WPARAM, LPARAM);
LRESULT __fastcall sub_1400D28E0(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
__int64 __fastcall sub_1400D2910(DWORD_PTR dwRefData, __int64, int *, __int64, __int64, int, int);
__int64 __fastcall sub_1400D2B60(HWND, __int64, LPITEMIDLIST *);
__int64 __fastcall sub_1400D2C10(__int64, unsigned int, __int64, _WORD *, __int64);
__int64 __fastcall sub_1400D2D60(_QWORD *, _QWORD *, _QWORD *, _QWORD *);
__int64 __fastcall sub_1400D2E20(const WCHAR *, char *);
__int64 __fastcall sub_1400D2FE0(_QWORD *, _QWORD *);
int __fastcall sub_1400D3120(LPCWSTR lpFileName, int);
_WORD *__fastcall sub_1400D33C0(_QWORD **);
__int64 __fastcall sub_1400D3500(HWND, _QWORD **, int);
__int64 __fastcall sub_1400D35A0(HWND, __int64, void *);
__int64 __fastcall sub_1400D3AB0(void **, int, LPDATAOBJECT *);
__int64 __fastcall sub_1400D3C20(void **, LPDATAOBJECT *);
__int64 __fastcall sub_1400D3C80(void **, LPDATAOBJECT *);
__int64 __fastcall sub_1400D3CE0(HWND, _QWORD *, _QWORD **, int);
// __int64 __fastcall sub_1400D3E30(_QWORD, _QWORD); weak
void __fastcall sub_1400D5030(__int64);
HWND __fastcall sub_1400D5C30(__int64);
void __fastcall sub_1400D5D10(__int64);
void __fastcall sub_1400D5D60(__int64);
BOOL __fastcall sub_1400D5ED0(__int64, HWND);
BOOL __fastcall sub_1400D60A0(__int64, HWND);
LRESULT __fastcall sub_1400D62B0(HWND hDlg, __int64);
__int64 __fastcall sub_1400D63B0(HWND, int, __int16, __int64);
__int64 __fastcall sub_1400D6410(HWND hDlg, int, __int16, __int64 *);
LRESULT __fastcall sub_1400D6490(HWND hDlg, __int64);
__int64 __fastcall sub_1400D65B0(HWND, int, __int16, __int64);
__int64 __fastcall sub_1400D6610(HWND hDlg, int, __int16, __int64 *);
void __fastcall sub_1400D6690(__int64);
__int64 __fastcall sub_1400D6760(__int64, int *, int *, _QWORD *);
__int64 __fastcall sub_1400D6A50(LPVOID lpThreadParameter);
BOOL __fastcall sub_1400D6AB0(HWND hDlg);
HWND __fastcall sub_1400D6CB0(__int64, HWND);
__int64 __fastcall sub_1400D6E10(HWND, int, __int16);
__int64 __fastcall sub_1400D6E70(HWND hDlg, int, __int16, __int64);
void __fastcall sub_1400D6EE0(__int64, int, HMENU);
__int64 __fastcall sub_1400D6FB0(__int64, __int64);
// __int64 __fastcall sub_1400D79A0(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_1400DA110(__int64, HWND, UINT, WPARAM, HMENU);
__int64 __fastcall sub_1400DA990(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
__int64 __fastcall sub_1400DAA70(__int64, __int64, unsigned int, WPARAM, __int64 lParam);
__int64 __fastcall sub_1400DABA0(__int64, unsigned int, WPARAM, __int64, int, __int64);
__int64 __fastcall sub_1400DABD0(__int64);
int sub_1400E1A90();
int sub_1400E1B00();
int sub_1400E1B70();
int sub_1400E1BE0();
UINT sub_1400E1C00();
UINT sub_1400E1C50();
int sub_1400E1CA0();
int sub_1400E1CC0();
int sub_1400E1CE0();
int sub_1400E1D50();
int sub_1400E1DC0();
int sub_1400E1DCC();
int sub_1400E1DD8();
int sub_1400E1DE4();
int sub_1400E1E04();
int sub_1400E1E10();
int sub_1400E1E1C();
int sub_1400E1E3C();
void __fastcall sub_1400E1E50();
void __fastcall sub_1400E1E60();
void __fastcall sub_1400E1E70();
void __fastcall sub_1400E1E80();
void __fastcall sub_1400E1EF0();
void __fastcall sub_1400E1F60();
void __fastcall sub_1400E1FA0();
void __fastcall sub_1400E1FB0();
void __fastcall sub_1400E1FC0();
void __fastcall sub_1400E1FD0();
void __fastcall sub_1400E2070();
void __fastcall sub_1400E2080();
void __fastcall sub_1400E2090();
void __fastcall sub_1400E20A0();
void __fastcall sub_1400E2130();
void __fastcall sub_1400E2170();
void __cdecl sub_1400E2200(); // idb
void __fastcall sub_1400E2210();
void __fastcall sub_1400E2280();
void __fastcall sub_1400E22F0();
void __fastcall sub_1400E2360();
void **sub_1400E23C8();
void **sub_1400E23D8();
void **sub_1400E23E8();
void __fastcall sub_1400E23F8();
void sub_1400E2404();
// void __cdecl unknown_libname_234(); idb
void __fastcall sub_1400E2464();
void __fastcall sub_1400E2480();
void __fastcall sub_1400E249C();
// void __cdecl unknown_libname_235(); idb
void __fastcall sub_1400E24E4();
// __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipGetPathGradientPointCount(_QWORD, _QWORD); weak
// __int64 __fastcall GdipSetPathGradientSurroundColorsWithCount(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipSetPathGradientCenterColor(_QWORD, _QWORD); weak
// __int64 __fastcall GdipSetPathGradientCenterPointI(_QWORD, _QWORD); weak
// __int64 __fastcall GdipCreatePathGradientFromPath(_QWORD, _QWORD); weak
// __int64 __fastcall GdipAddPathRectangleI(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall GdipDeletePath(_QWORD); weak
// __int64 __fastcall GdipCreatePath(_QWORD, _QWORD); weak
// double __fastcall GdipFillRectangleI(_QWORD, _QWORD); weak
// __int64 __fastcall GdipDeleteGraphics(_QWORD); weak
// __int64 __fastcall GdipCreateFromHDC(_QWORD, _QWORD); weak
// __int64 __fastcall GdipCloneBrush(_QWORD, _QWORD); weak
// __int64 __fastcall GdipDeleteBrush(_QWORD); weak
// __int64 __fastcall GdipCreateSolidFill(_QWORD, _QWORD); weak
// __int64 __fastcall GdiplusShutdown(_QWORD); weak
// __int64 __fastcall GdipGetAllPropertyItems(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipGetPropertySize(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdiplusStartup(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipCreatePen1(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD); weak
// __int64 __fastcall GdipDisposeImage(_QWORD); weak
// __int64 __fastcall GdipCreateBitmapFromScan0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipCreateHBITMAPFromBitmap(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GdipGetImageWidth(_QWORD, _QWORD); weak
// __int64 __fastcall GdipDeletePen(_QWORD); weak
// __int64 __fastcall GdipGetImageHeight(_QWORD, _QWORD); weak
// __int64 __fastcall GdipGetImagePixelFormat(_QWORD, _QWORD); weak
// __int64 __fastcall GdipGetImageHorizontalResolution(_QWORD, _QWORD); weak
// __int64 __fastcall GdipCloneImage(_QWORD, _QWORD); weak
// __int64 __fastcall GdipLoadImageFromFile(_QWORD); weak
// __int64 __fastcall GdipFree(_QWORD); weak
// __int64 __fastcall GdipAlloc(_QWORD); weak
// __int64 __fastcall GdipDrawLineI(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD); weak
// __int64 __fastcall GdipGetImageVerticalResolution(_QWORD, _QWORD); weak
// double __cdecl pow(double X, double Y);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *ConvertSidToStringSidW)(PSID Sid, LPWSTR *StringSid);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern BOOL (__stdcall *CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern BOOL (__stdcall *LookupAccountSidW)(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern DWORD (__stdcall *GetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *LookupPrivilegeValueW)(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern BOOL (__stdcall *ImageList_Draw)(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);
// extern BOOL (__stdcall *SetWindowSubclass)(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
// extern BOOL (__stdcall *RemoveWindowSubclass)(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass);
// extern LRESULT (__stdcall *DefSubclassProc)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *GetSaveFileNameW)(LPOPENFILENAMEW);
// extern BOOL (__stdcall *SetBrushOrgEx)(HDC hdc, int x, int y, LPPOINT lppt);
// extern BOOL (__stdcall *StretchBlt)(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *BitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern int (__stdcall *SetStretchBltMode)(HDC hdc, int mode);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern BOOL (__stdcall *GetBitmapDimensionEx)(HBITMAP hbit, LPSIZE lpsize);
// extern BOOL (__stdcall *GetTextExtentPoint32W)(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// extern HFONT (__stdcall *CreateFontIndirectW)(const LOGFONTW *lplf);
// extern HFONT (__stdcall *CreateFontW)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
// extern BOOL (__stdcall *TextOutW)(HDC hdc, int x, int y, LPCWSTR lpString, int c);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern HBRUSH (__stdcall *CreateSolidBrush)(COLORREF color);
// extern int (__stdcall *GetObjectW)(HANDLE h, int c, LPVOID pv);
// extern BOOL (__stdcall *SetBitmapDimensionEx)(HBITMAP hbm, int w, int h, LPSIZE lpsz);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern ULONG (__stdcall *GetAdaptersAddresses)(ULONG Family, ULONG Flags, PVOID Reserved, PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *DeactivateActCtx)(DWORD dwFlags, ULONG_PTR ulCookie);
// extern DWORD (__stdcall *GetLastError)();
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *ActivateActCtx)(HANDLE hActCtx, ULONG_PTR *lpCookie);
// extern BOOL (__stdcall *FindActCtxSectionStringW)(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
// extern HANDLE (__stdcall *CreateActCtxW)(PCACTCTXW pActCtx);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *GetModuleHandleExW)(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// extern BOOL (__stdcall *QueryActCtxW)(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired);
// extern void (__stdcall *OutputDebugStringA)(LPCSTR lpOutputString);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// extern DWORD (__stdcall *GetLogicalDriveStringsW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern DWORD (__stdcall *GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern BOOL (__stdcall *GetComputerNameW)(LPWSTR lpBuffer, LPDWORD nSize);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *GlobalMemoryStatusEx)(LPMEMORYSTATUSEX lpBuffer);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *GetDiskFreeSpaceExW)(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// extern BOOL (__stdcall *GetVolumeInformationW)(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// extern DWORD (__stdcall *SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
// extern DWORD (__stdcall *QueueUserAPC)(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
// extern LANGID (__stdcall *GetUserDefaultUILanguage)();
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *SetCurrentDirectoryW)(LPCWSTR lpPathName);
// extern int (__stdcall *GetLocaleInfoW)(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern LONG (__stdcall *CompareFileTime)(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern BOOL (__stdcall *CancelIo)(HANDLE hFile);
// extern BOOL (__stdcall *ReadDirectoryChangesW)(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern SIZE_T (__stdcall *GlobalSize)(HGLOBAL hMem);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *LocalFileTimeToFileTime)(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *CreateDirectoryW)(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern int (__stdcall *CompareStringW)(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *SetFileValidData)(HANDLE hFile, LONGLONG ValidDataLength);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *GetDiskFreeSpaceW)(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// extern LANGID (__stdcall *GetUserDefaultLangID)();
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *TzSpecificLocalTimeToSystemTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
// extern BOOL (__stdcall *SystemTimeToTzSpecificLocalTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern DWORD (__stdcall *WNetGetUniversalNameW)(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern HRESULT (__stdcall *SHBindToParent)(LPCITEMIDLIST pidl, const IID *const riid, void **ppv, LPCITEMIDLIST *ppidlLast);
// extern UINT (__stdcall *ILGetSize)(LPCITEMIDLIST pidl);
// extern LPITEMIDLIST (__stdcall *SHBrowseForFolderW)(LPBROWSEINFOW lpbi);
// extern BOOL (__stdcall *ShellExecuteExW)(SHELLEXECUTEINFOW *pExecInfo);
// extern BOOL (__stdcall *ILIsParent)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
// extern ULONG (__stdcall *SHChangeNotifyRegister)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, const SHChangeNotifyEntry *pshcne);
// extern BOOL (__stdcall *SHGetSpecialFolderPathW)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
// extern LPITEMIDLIST (__stdcall *ILFindLastID)(LPCITEMIDLIST pidl);
// extern BOOL (__stdcall *ILRemoveLastID)(LPITEMIDLIST pidl);
// extern LPITEMIDLIST (__stdcall *ILClone)(LPCITEMIDLIST pidl);
// extern HRESULT (__stdcall *SHGetDesktopFolder)(IShellFolder **ppshf);
// extern HRESULT (__stdcall *SHGetImageList)(int iImageList, const IID *const riid, void **ppvObj);
// extern LPITEMIDLIST (__stdcall *ILCombine)(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
// extern DWORD_PTR (__stdcall *SHGetFileInfoW)(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
// extern HRESULT (__stdcall *SHGetFolderLocation)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPITEMIDLIST *ppidl);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern BOOL (__stdcall *Shell_GetImageLists)(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);
// extern UINT (__stdcall *DragQueryFileW)(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
// extern int (__stdcall *SHFileOperationW)(LPSHFILEOPSTRUCTW lpFileOp);
// extern BOOL (__stdcall *SHGetPathFromIDListW)(LPCITEMIDLIST pidl, LPWSTR pszPath);
// extern HRESULT (__stdcall *SHGetFolderPathW)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
// extern BOOL (__stdcall *PathIsRelativeW)(LPCWSTR pszPath);
// extern HRESULT (__stdcall *SHStrDupW)(LPCWSTR psz, LPWSTR *ppwsz);
// extern BOOL (__stdcall *PathCanonicalizeW)(LPWSTR pszBuf, LPCWSTR pszPath);
// extern PWSTR (__stdcall *StrCatW)(PWSTR psz1, PCWSTR psz2);
// extern LPWSTR (__stdcall *PathRemoveBackslashW)(LPWSTR pszPath);
// extern void (__stdcall *PathStripPathW)(LPWSTR pszPath);
// extern void (__stdcall *PathRemoveExtensionW)(LPWSTR pszPath);
// extern BOOL (__stdcall *PathIsDirectoryW)(LPCWSTR pszPath);
// extern HRESULT (__stdcall *StrRetToBufW)(STRRET *pstr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf);
// extern HRESULT (__stdcall *SHAutoComplete)(HWND hwndEdit, DWORD dwFlags);
// extern BOOL (__stdcall *PathIsSameRootW)(LPCWSTR pszPath1, LPCWSTR pszPath2);
// extern int (__stdcall *StrCmpIW)(PCWSTR psz1, PCWSTR psz2);
// extern void (__stdcall *PathRemoveBlanksW)(LPWSTR pszPath);
// extern LSTATUS (__stdcall *SHDeleteKeyW)(HKEY hkey, LPCWSTR pszSubKey);
// extern BOOL (__stdcall *PathIsRootW)(LPCWSTR pszPath);
// extern int (__stdcall *StrCmpW)(PCWSTR psz1, PCWSTR psz2);
// extern BOOL (__stdcall *PathIsUNCW)(LPCWSTR pszPath);
// extern LPWSTR (__stdcall *PathCombineW)(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
// extern int (__stdcall *StrCmpLogicalW)(PCWSTR psz1, PCWSTR psz2);
// extern BOOL (__stdcall *PathRemoveFileSpecW)(LPWSTR pszPath);
// extern LPWSTR (__stdcall *PathFindExtensionW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathAppendW)(LPWSTR pszPath, LPCWSTR pszMore);
// extern PWSTR (__stdcall *StrChrW)(PCWSTR pszStart, WCHAR wMatch);
// extern BOOL (__stdcall *PathIsURLW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathStripToRootW)(LPWSTR pszPath);
// extern UINT (__stdcall *RegisterWindowMessageW)(LPCWSTR lpString);
// extern HWND (__stdcall *SetClipboardViewer)(HWND hWndNewViewer);
// extern BOOL (__stdcall *AppendMenuW)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// extern HDEVNOTIFY (__stdcall *RegisterDeviceNotificationW)(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);
// extern BOOL (__stdcall *IsClipboardFormatAvailable)(UINT format);
// extern BOOL (__stdcall *UnregisterDeviceNotification)(HDEVNOTIFY Handle);
// extern HBRUSH (__stdcall *GetSysColorBrush)(int nIndex);
// extern BOOL (__stdcall *PostMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *SetRect)(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);
// extern BOOL (__stdcall *ClientToScreen)(HWND hWnd, LPPOINT lpPoint);
// extern BOOL (__stdcall *IntersectRect)(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern BOOL (__stdcall *SetMenuInfo)(HMENU, LPCMENUINFO);
// extern HMENU (__stdcall *CreatePopupMenu)();
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern BOOL (__stdcall *ChangeClipboardChain)(HWND hWndRemove, HWND hWndNewNext);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *GetCursorPos)(LPPOINT lpPoint);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *DrawIconEx)(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
// extern BOOL (__stdcall *RedrawWindow)(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// extern BOOL (__stdcall *EndPaint)(HWND hWnd, const PAINTSTRUCT *lpPaint);
// extern HDC (__stdcall *BeginPaint)(HWND hWnd, LPPAINTSTRUCT lpPaint);
// extern BOOL (__stdcall *GetUpdateRect)(HWND hWnd, LPRECT lpRect, BOOL bErase);
// extern ATOM (__stdcall *RegisterClassW)(const WNDCLASSW *lpWndClass);
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *DrawEdge)(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);
// extern UINT (__stdcall *GetMenuState)(HMENU hMenu, UINT uId, UINT uFlags);
// extern int (__stdcall *FrameRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern DWORD (__stdcall *GetSysColor)(int nIndex);
// extern DWORD (__stdcall *GetTabbedTextExtentW)(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions);
// extern int (__stdcall *GetMenuStringW)(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern BOOL (__stdcall *CloseClipboard)();
// extern HANDLE (__stdcall *SetClipboardData)(UINT uFormat, HANDLE hMem);
// extern BOOL (__stdcall *EmptyClipboard)();
// extern BOOL (__stdcall *OpenClipboard)(HWND hWndNewOwner);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern HWND (__stdcall *CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern BOOL (__stdcall *GetWindowPlacement)(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern UINT_PTR (__stdcall *SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// extern BOOL (__stdcall *KillTimer)(HWND hWnd, UINT_PTR uIDEvent);
// extern HWND (__stdcall *CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassExW)(const WNDCLASSEXW *);
// extern BOOL (__stdcall *IsIconic)(HWND hWnd);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern UINT (__stdcall *GetMenuItemID)(HMENU hMenu, int nPos);
// extern LRESULT (__stdcall *DefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LONG_PTR (__stdcall *SetWindowLongPtrW)(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern HCURSOR (__stdcall *LoadCursorW)(HINSTANCE hInstance, LPCWSTR lpCursorName);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *TrackPopupMenu)(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// extern HMENU (__stdcall *LoadMenuW)(HINSTANCE hInstance, LPCWSTR lpMenuName);
// extern BOOL (__stdcall *DestroyMenu)(HMENU hMenu);
// extern BOOL (__stdcall *SetForegroundWindow)(HWND hWnd);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern LRESULT (__stdcall *CallWindowProcW)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *PtInRect)(const RECT *lprc, POINT pt);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern LONG_PTR (__stdcall *GetWindowLongPtrW)(HWND hWnd, int nIndex);
// extern BOOL (__stdcall *GetIconInfo)(HICON hIcon, PICONINFO piconinfo);
// extern DWORD (__stdcall *CheckMenuItem)(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
// extern BOOL (__stdcall *CheckMenuRadioItem)(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags);
// extern LONG (__stdcall *GetWindowLongW)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *GetFocus)();
// extern UINT (__stdcall *GetDlgItemInt)(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned);
// extern BOOL (__stdcall *SetDlgItemInt)(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);
// extern HICON (__stdcall *LoadIconW)(HINSTANCE hInstance, LPCWSTR lpIconName);
// extern ULONG_PTR (__stdcall *SetClassLongPtrW)(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
// extern int (__stdcall *FillRect)(HDC hDC, const RECT *lprc, HBRUSH hbr);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *InvalidateRect)(HWND hWnd, const RECT *lpRect, BOOL bErase);
// extern BOOL (__stdcall *InsertMenuW)(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// extern HMENU (__stdcall *CreateMenu)();
// extern int (__stdcall *GetMenuItemCount)(HMENU hMenu);
// extern DWORD (__stdcall *GetMessagePos)();
// extern BOOL (__stdcall *SetMenuItemInfoW)(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii);
// extern HMENU (__stdcall *GetSubMenu)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern BOOL (__stdcall *DeleteMenu)(HMENU hMenu, UINT uPosition, UINT uFlags);
// extern BOOL (__stdcall *GetMenuItemInfoW)(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii);
// extern BOOL (__stdcall *InsertMenuItemW)(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi);
// extern int (__stdcall *GetWindowTextW)(HWND hWnd, LPWSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *CheckDlgButton)(HWND hDlg, int nIDButton, UINT uCheck);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *ScreenToClient)(HWND hWnd, LPPOINT lpPoint);
// extern BOOL (__stdcall *InflateRect)(LPRECT lprc, int dx, int dy);
// extern int (__stdcall *MapWindowPoints)(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
// extern BOOL (__stdcall *OffsetRect)(LPRECT lprc, int dx, int dy);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern INT_PTR (__stdcall *DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern UINT (__stdcall *IsDlgButtonChecked)(HWND hDlg, int nIDButton);
// extern int (__stdcall *GetWindowTextLengthW)(HWND hWnd);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern BOOL (__stdcall *SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
// extern BOOL (__stdcall *DestroyIcon)(HICON hIcon);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern BOOL (__stdcall *SetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// extern UINT (__stdcall *GetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
// extern int (__stdcall *LoadStringW)(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// extern LRESULT (__stdcall *SendDlgItemMessageW)(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HBITMAP (__stdcall *LoadBitmapW)(HINSTANCE hInstance, LPCWSTR lpBitmapName);
// extern LRESULT (__stdcall *SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *LoadImageW)(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
// extern BOOL (__stdcall *PrintWindow)(HWND hwnd, HDC hdcBlt, UINT nFlags);
// extern BOOL (__stdcall *GetMenuBarInfo)(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi);
// extern ULONG_PTR (__stdcall *GetClassLongPtrW)(HWND hWnd, int nIndex);
// extern BOOL (__stdcall *UnregisterClassW)(LPCWSTR lpClassName, HINSTANCE hInstance);
// extern BOOL (__stdcall *ReleaseCapture)();
// extern HWND (__stdcall *SetCapture)(HWND hWnd);
// extern HWND (__stdcall *GetCapture)();
// extern HWND (__stdcall *WindowFromPoint)(POINT Point);
// extern HWND (__stdcall *FindWindowExW)(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);
// extern HICON (__stdcall *CopyIcon)(HICON hIcon);
// extern UINT (__stdcall *RegisterClipboardFormatW)(LPCWSTR lpszFormat);
// extern HWND (__stdcall *FindWindowW)(LPCWSTR lpClassName, LPCWSTR lpWindowName);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *SetWindowPlacement)(HWND hWnd, const WINDOWPLACEMENT *lpwndpl);
// extern HACCEL (__stdcall *LoadAcceleratorsW)(HINSTANCE hInstance, LPCWSTR lpTableName);
// extern BOOL (__stdcall *GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *IsDialogMessageW)(HWND hDlg, LPMSG lpMsg);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern LRESULT (__stdcall *DispatchMessageW)(const MSG *lpMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern BOOL (__stdcall *SetMenu)(HWND hWnd, HMENU hMenu);
// extern int (__stdcall *TranslateAcceleratorW)(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// extern BOOL (__stdcall *ExpandEnvironmentStringsForUserW)(HANDLE hToken, LPCWSTR lpSrc, LPWSTR lpDest, DWORD dwSize);
// extern HRESULT (__stdcall *SetWindowTheme)(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList);
// extern BOOL (__stdcall *VerQueryValueW)(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
// extern BOOL (__stdcall *GetFileVersionInfoW)(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
// extern DWORD (__stdcall *GetFileVersionInfoSizeW)(LPCWSTR lptstrFilename, LPDWORD lpdwHandle);
// extern BOOL (__stdcall *PlaySoundW)(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
// extern BOOL (__stdcall *GetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);
// extern BOOL (__stdcall *OpenPrinterW)(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);
// extern BOOL (__stdcall *ClosePrinter)(HANDLE hPrinter);
// extern void (__stdcall *OleUninitialize)();
// extern HRESULT (__stdcall *OleInitialize)(LPVOID pvReserved);
// extern HRESULT (__stdcall *CreateStreamOnHGlobal)(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
// extern LPVOID (__stdcall *CoTaskMemAlloc)(SIZE_T cb);
// extern HRESULT (__stdcall *RevokeDragDrop)(HWND hwnd);
// extern HRESULT (__stdcall *OleFlushClipboard)();
// extern HRESULT (__stdcall *OleIsCurrentClipboard)(LPDATAOBJECT pDataObj);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
// extern HRESULT (__stdcall *OleGetClipboard)(LPDATAOBJECT *ppDataObj);
// extern HRESULT (__stdcall *DoDragDrop)(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect);
// extern HRESULT (__stdcall *CLSIDFromString)(LPCOLESTR lpsz, LPCLSID pclsid);
// extern HRESULT (__stdcall *OleSetClipboard)(LPDATAOBJECT pDataObj);
// extern HANDLE (__stdcall *OleDuplicateData)(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags);
// extern HRESULT (__stdcall *StgCreateStorageEx)(const WCHAR *pwcsName, DWORD grfMode, DWORD stgfmt, DWORD grfAttrs, STGOPTIONS *pStgOptions, PSECURITY_DESCRIPTOR pSecurityDescriptor, const IID *const riid, void **ppObjectOpen);
// extern void (__stdcall *CoTaskMemFree)(LPVOID pv);
// extern HRESULT (__stdcall *RegisterDragDrop)(HWND hwnd, LPDROPTARGET pDropTarget);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern void (__stdcall *ReleaseStgMedium)(LPSTGMEDIUM);
__int64 qword_1400E3F80 = 136418i64; // weak
_UNKNOWN unk_1400E3FA0; // weak
const IID stru_1400E3FB0 = { 136422u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_1400E3FD0; // weak
const IID stru_1400E3FE0 = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_1400E3FF0; // weak
_UNKNOWN unk_1400E4010; // weak
const IID rclsid = { 1180116874u, 16667u, 4562u, { 131u, 154u, 0u, 192u, 79u, 217u, 24u, 208u } }; // idb
_UNKNOWN unk_1400E4040; // weak
const IID riid = { 3730569094u, 18298u, 4562u, { 131u, 157u, 0u, 192u, 79u, 217u, 24u, 208u } }; // idb
_UNKNOWN unk_1400E4060; // weak
const IID stru_1400E4070 = { 3292383128u, 38353u, 19434u, { 144u, 48u, 187u, 153u, 226u, 152u, 58u, 26u } }; // idb
const IID stru_1400E40A0 = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID stru_1400E40B0 = { 1459483460u, 64877u, 4560u, { 149u, 138u, 0u, 96u, 151u, 201u, 160u, 144u } }; // idb
_QWORD qword_1400E40E0[2] = { 1283090720958267585i64, -429706733468765056i64 }; // weak
_UNKNOWN unk_1400E4100; // weak
const IID stru_1400E4110 = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID stru_1400E4120 = { 1189828902u, 22574u, 16407u, { 159u, 223u, 232u, 153u, 141u, 170u, 9u, 80u } }; // idb
_UNKNOWN unk_1400E4150; // weak
__int64 qword_1400E4160 = 1284359947417224592i64; // weak
_UNKNOWN unk_1400E4170; // weak
const IID stru_1400E4180 = { 11u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_1400E4190; // weak
__int64 qword_1400E41B0 = 270i64; // weak
void *std::logic_error::`vftable' = &sub_140009200; // weak
void *std::length_error::`vftable' = &sub_140009200; // weak
void *std::out_of_range::`vftable' = &sub_14002B6C4; // weak
void *std::runtime_error::`vftable' = &sub_140009200; // weak
void *std::error_category::`vftable' = &sub_14002B820; // weak
void *std::bad_alloc::`vftable' = &sub_1400019E0; // weak
void *std::locale::facet::`vftable' = &sub_14000DC30; // weak
void *std::locale::_Locimp::`vftable' = &std::locale::_Locimp::`scalar deleting destructor'; // weak
void *std::tr1::regex_error::`vftable' = &sub_14002B6C4; // weak
void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_1400334E0; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_1400334E0; // weak
void *std::numpunct<char>::`vftable' = &sub_14002D974; // weak
void *std::codecvt<wchar_t,char,int>::`vftable' = &sub_1400334E0; // weak
void *std::ctype<wchar_t>::`vftable' = &std::ctype<wchar_t>::`scalar deleting destructor'; // weak
void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_140025D40; // weak
void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_14000DC30; // weak
void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_14000DC30; // weak
void *std::collate<wchar_t>::`vftable' = &sub_14000DC30; // weak
void *std::messages<wchar_t>::`vftable' = &sub_1400334E0; // weak
void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_1400334E0; // weak
void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_1400334E0; // weak
void *std::_Mpunct<wchar_t>::`vftable' = &unknown_libname_57; // weak
void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_1400334E0; // weak
void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_1400334E0; // weak
void *std::collate<unsigned short>::`vftable' = &sub_1400334E0; // weak
void *std::messages<unsigned short>::`vftable' = &sub_1400334E0; // weak
void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_1400334E0; // weak
void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_1400334E0; // weak
void *std::_Mpunct<unsigned short>::`vftable' = &unknown_libname_58; // weak
void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable' = &sub_140033520; // weak
void *std::numpunct<wchar_t>::`vftable' = &sub_140005560; // weak
void *std::numpunct<unsigned short>::`vftable' = &sub_1400345E0; // weak
void *std::moneypunct<wchar_t,0>::`vftable' = &unknown_libname_57; // weak
void *std::moneypunct<wchar_t,1>::`vftable' = &unknown_libname_57; // weak
void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable' = &sub_140036204; // weak
void *std::moneypunct<unsigned short,0>::`vftable' = &unknown_libname_58; // weak
void *std::moneypunct<unsigned short,1>::`vftable' = &unknown_libname_58; // weak
void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable' = &sub_1400364A0; // weak
void *std::messages<char>::`vftable' = &sub_1400334E0; // weak
void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_1400334E0; // weak
void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_1400334E0; // weak
void *std::_Mpunct<char>::`vftable' = &unknown_libname_81; // weak
void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_140045320; // weak
void *std::moneypunct<char,0>::`vftable' = &unknown_libname_81; // weak
void *std::moneypunct<char,1>::`vftable' = &unknown_libname_81; // weak
void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_140046290; // weak
void *type_info::`vftable' = &sub_14004AAC4; // weak
void *std::exception::`vftable' = &sub_14004AEFC; // weak
void *std::bad_cast::`vftable' = &sub_14004AEFC; // weak
void *std::bad_exception::`vftable' = &sub_140050040; // weak
__int64 (__fastcall *off_1400E9D80)(void *Block) = &sub_140060D00; // weak
_UNKNOWN unk_1400E9DBC; // weak
_UNKNOWN unk_1400E9DBF; // weak
_UNKNOWN unk_1400E9DCC; // weak
_UNKNOWN unk_1400E9DDC; // weak
_UNKNOWN unk_1400E9DEC; // weak
_UNKNOWN unk_1400E9DFC; // weak
_UNKNOWN unk_1400E9F54; // weak
_UNKNOWN unk_1400E9F84; // weak
_UNKNOWN unk_1400E9FA4; // weak
_UNKNOWN unk_1400E9FB4; // weak
_UNKNOWN unk_1400E9FDC; // weak
_UNKNOWN unk_1400E9FFC; // weak
_UNKNOWN unk_1400EA014; // weak
_UNKNOWN unk_1400EA024; // weak
_UNKNOWN unk_1400EA214; // weak
_UNKNOWN unk_1400EA2FC; // weak
_UNKNOWN unk_1400EA32C; // weak
_UNKNOWN unk_1400EA354; // weak
const WCHAR word_1400EA38C = 0u; // idb
_UNKNOWN unk_1400EA578; // weak
_UNKNOWN unk_1400EA5D0; // weak
_UNKNOWN unk_1400EA640; // weak
_UNKNOWN unk_1400EA658; // weak
_UNKNOWN unk_1400EA670; // weak
const WCHAR word_1400EA684 = 114u; // idb
_UNKNOWN unk_1400EA688; // weak
const WCHAR word_1400EA6EC = 114u; // idb
const WCHAR word_1400EA6FC = 103u; // idb
const WCHAR word_1400EA71C = 98u; // idb
const WCHAR word_1400EA74C = 0u; // idb
const WCHAR word_1400EA76C = 0u; // idb
const WCHAR word_1400EA78C = 0u; // idb
const WCHAR word_1400EA7B4 = 0u; // idb
const WCHAR word_1400EA7EC = 0u; // idb
const WCHAR WindowName = 0u; // idb
const WCHAR pszMore = 42u; // idb
_UNKNOWN unk_1400EAA84; // weak
_UNKNOWN unk_1400EAB1C; // weak
_WORD word_1400EABE4[92] =
{
  32,
  0,
  76,
  105,
  99,
  101,
  110,
  115,
  101,
  83,
  116,
  97,
  116,
  101,
  68,
  97,
  116,
  97,
  46,
  66,
  97,
  99,
  107,
  117,
  112,
  0,
  87,
  77,
  68,
  82,
  77,
  78,
  69,
  84,
  95,
  82,
  69,
  86,
  79,
  67,
  65,
  84,
  73,
  79,
  78,
  0,
  76,
  105,
  99,
  101,
  110,
  115,
  101,
  83,
  116,
  97,
  116,
  101,
  68,
  97,
  116,
  97,
  46,
  67,
  111,
  108,
  108,
  97,
  98,
  111,
  114,
  97,
  116,
  105,
  118,
  101,
  80,
  108,
  97,
  121,
  0,
  0,
  83,
  65,
  80,
  76,
  69,
  86,
  69,
  76,
  0,
  0
}; // weak
_UNKNOWN unk_1400EAC9C; // weak
_UNKNOWN unk_1400EACCC; // weak
const wchar_t asc_1400EACE4[] = L":"; // idb
const wchar_t asc_1400EACFC[] = L":"; // idb
const WCHAR SubBlock = 92u; // idb
const OLECHAR word_1400EB32C = 0u; // idb
const WCHAR word_1400EB87C = 0u; // idb
_UNKNOWN unk_1400EB8AC; // weak
const WCHAR word_1400EB8E4 = 0u; // idb
_UNKNOWN unk_1400EB8F4; // weak
_UNKNOWN unk_1400EBA84; // weak
const WCHAR word_1400EBAA4 = 0u; // idb
_UNKNOWN unk_1400EBAFC; // weak
const WCHAR word_1400EBB3C = 0u; // idb
const WCHAR String = 0u; // idb
const WCHAR word_1400EBD74 = 0u; // idb
const WCHAR word_1400EBDE4 = 0u; // idb
_UNKNOWN unk_1400EBDFC; // weak
const WCHAR Data = 0u; // idb
_UNKNOWN unk_1400EBED4; // weak
_UNKNOWN unk_1400EBEF4; // weak
_UNKNOWN unk_1400EBF04; // weak
_UNKNOWN unk_1400EBF14; // weak
_UNKNOWN unk_1400EBF44; // weak
const LPARAM unk_1400EBFCC = 34058828664274944i64; // idb
const LPARAM unk_1400EC00C = 28429264705552384i64; // idb
_UNKNOWN unk_1400EC034; // weak
_UNKNOWN unk_1400EC044; // weak
_UNKNOWN unk_1400EC10C; // weak
_UNKNOWN unk_1400EC19C; // weak
_UNKNOWN unk_1400EC1AC; // weak
const WPARAM unk_1400EC1C4 = 32369781235515392ui64; // idb
const WPARAM unk_1400EC214 = 28429329130061824ui64; // idb
const WPARAM unk_1400EC36C = 32932731188936704ui64; // idb
_UNKNOWN unk_1400EC5D4; // weak
_UNKNOWN unk_1400EC7B4; // weak
const WCHAR word_1400EC8C4 = 0u; // idb
_UNKNOWN unk_1400ECA2C; // weak
_UNKNOWN unk_1400ECA64; // weak
_UNKNOWN unk_1400ECABC; // weak
_UNKNOWN unk_1400ECAF4; // weak
_DWORD dword_1400EF1F0[20] =
{
  45002,
  45003,
  45004,
  45005,
  45006,
  45007,
  45008,
  45009,
  45010,
  45011,
  45012,
  45013,
  45014,
  45015,
  45017,
  45018,
  45019,
  45020,
  45021,
  45022
}; // weak
_UNKNOWN unk_1400F3460; // weak
wchar_t aBytes_0[6] = L"Bytes"; // weak
__int128 xmmword_1400F3AE8 = 0x72006F007400630065007200690044i64; // weak
__int128 xmmword_1400F3AF8 = 0x6E0069007400730069004C00200079i64; // weak
void *Explorerplusplus::CApplicationToolbarDrop::`vftable' = &sub_1400CDE50; // weak
void *Explorerplusplus::CBookmarkToolbarDrop::`vftable' = &sub_1400C9F80; // weak
const char byte_1400F6829[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
void *std::wstringbuf::`vftable' = &sub_1400025B0; // weak
void *std::wistringstream::`vftable' = &sub_140002570; // weak
_UNKNOWN unk_1400F68C0; // weak
void *CColorRuleDialog::`vftable' = &sub_1400C93F0; // weak
void *CColorRuleDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *std::ios_base::`vftable' = &sub_140009520; // weak
void *std::wios::`vftable' = &sub_140009520; // weak
void *std::wstreambuf::`vftable' = &sub_140008330; // weak
void *std::wistream::`vftable' = &sub_140008620; // weak
void *std::system_error::`vftable' = &sub_140009200; // weak
void *std::ios_base::failure::`vftable' = &sub_140009200; // weak
void *CCustomizeColorsDialog::`vftable' = &sub_1400C83B0; // weak
void *CCustomizeColorsDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CDestroyFilesDialog::`vftable' = &sub_1400C7250; // weak
void *CDestroyFilesDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *Explorerplusplus::`vftable' = &sub_1400C3B00; // weak
void *Explorerplusplus::`vftable' = &sub_14000AF60; // weak
void *Explorerplusplus::`vftable' = &sub_14000AEF0; // weak
void *Explorerplusplus::`vftable' = &sub_14000AF10; // weak
void *Explorerplusplus::`vftable' = &sub_1400BD980; // weak
void *Explorerplusplus::`vftable' = &sub_14009A430; // weak
void *Explorerplusplus::`vftable' = &sub_1400AEF40; // weak
void *Explorerplusplus::`vftable' = &sub_1400AEF30; // weak
void *Explorerplusplus::CLoadSaveRegistry::`vftable' = &sub_1400C3430; // weak
void *CFilterDialogPersistentSettings::`vftable' = &sub_14000B030; // weak
void *CDropSource::`vftable' = &sub_1400C2550; // weak
wchar_t *off_1400F7090 = L"alnum"; // weak
void *std::wiostream::`vftable' = &sub_14000C540; // weak
void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable' = &sub_14000C4E0; // weak
_UNKNOWN unk_1400F7230; // weak
_UNKNOWN unk_1400F7238; // weak
// extern _UNKNOWN loc_1400F7248; weak
__int64 (__fastcall *off_1400F7258)() = &sub_14000BE80; // weak
__int64 (__fastcall *off_1400F7268)() = &sub_14000BE80; // weak
void *std::tr1::_Node_assert::`vftable' = &sub_14000BF20; // weak
void *std::tr1::_Node_capture::`vftable' = &sub_14000BE80; // weak
void *std::tr1::_Node_back::`vftable' = &sub_14000BE80; // weak
void *std::tr1::_Node_endif::`vftable' = &sub_14000BE80; // weak
void *std::tr1::_Node_if::`vftable' = &sub_14000BFF0; // weak
void *std::tr1::_Node_end_rep::`vftable' = &sub_14000BE80; // weak
void *std::tr1::_Node_rep::`vftable' = &sub_14000BE80; // weak
void *CMassRenameDialog::`vftable' = &sub_1400BAFE0; // weak
void *CMassRenameDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable' = &sub_140010510; // weak
void *std::tr1::_Node_str<wchar_t>::`vftable' = &sub_140013D00; // weak
void *std::wostream::`vftable' = &sub_140015440; // weak
void *CMergeFilesDialog::`vftable' = &sub_1400B9DB0; // weak
void *CMergeFilesDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CMergeFiles::`vftable' = &sub_140015540; // weak
void *Gdiplus::Image::`vftable' = &sub_140017B80; // weak
void *CRenameTabDialog::`vftable' = &sub_1400A2E50; // weak
void *CRenameTabDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CSearchDialog::`vftable' = &sub_14009FD00; // weak
void *CSearchDialog::`vftable' = &sub_14009F8C0; // weak
void *CSearchDialogPersistentSettings::`vftable' = &sub_140018750; // weak
void *CSearch::`vftable' = &sub_140018720; // weak
void *CSelectColumnsDialog::`vftable' = &sub_14009DB20; // weak
void *CSelectColumnsDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CSetDefaultColumnsDialog::`vftable' = &sub_14009C6D0; // weak
void *CSetDefaultColumnsDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CSetFileAttributesDialog::`vftable' = &sub_14009B660; // weak
void *CSetFileAttributesDialogPersistentSettings::`vftable' = &sub_140001B30; // weak
void *CSplitFileDialog::`vftable' = &sub_140099880; // weak
void *CSplitFileDialogPersistentSettings::`vftable' = &sub_14001A460; // weak
void *CSplitFile::`vftable' = &sub_14001A430; // weak
_UNKNOWN unk_1400F78D0; // weak
void *Gdiplus::Bitmap::`vftable' = &sub_140017B80; // weak
void *CWildcardSelectDialogPersistentSettings::`vftable' = &sub_14001AAB0; // weak
void *Explorerplusplus::CLoadSaveXML::`vftable' = &sub_140085780; // weak
void *CBaseDialog::`vftable' = &sub_1400844E0; // weak
void *CDialogSettings::`vftable' = &sub_140001B30; // weak
const IID stru_1400F7B08 = { 691257217u, 31542u, 4562u, { 178u, 14u, 0u, 192u, 79u, 152u, 62u, 96u } }; // idb
const IID stru_1400F7B18 = { 4110913330u, 50513u, 4563u, { 137u, 185u, 0u, 0u, 248u, 31u, 226u, 33u } }; // idb
void *Gdiplus::Brush::`vftable' = &sub_14001EB10; // weak
void *CDataObject::`vftable' = &sub_140078BF0; // weak
void *CDataObject::`vftable' = &sub_14001CC90; // weak
void *CDropHandler::`vftable' = &sub_14001CCA0; // weak
void *CReferenceCount::`vftable' = &sub_14001CCA0; // weak
void *CDirectoryMonitor::`vftable' = &sub_140075A90; // weak
void *CEnumFormatEtc::`vftable' = &sub_140074CB0; // weak
void *CDisplayWindow::`vftable' = &sub_14001CF50; // weak
const WCHAR word_1400F7CF8 = 0u; // idb
void *Gdiplus::PathGradientBrush::`vftable' = &sub_14001EB10; // weak
void *CMyTreeView::`vftable' = &sub_140021E30; // weak
void *CMyTreeView::`vftable' = &sub_140022940; // weak
void *CFolderView::`vftable' = &sub_140073250; // weak
void *CFolderView::`vftable' = &sub_140024580; // weak
void *CFolderView::`vftable' = &sub_1400245B0; // weak
void *CFolderView::`vftable' = &sub_1400245E0; // weak
void *CFolderView::`vftable' = &sub_140024610; // weak
void *CFolderView::`vftable' = &sub_140061C50; // weak
void *CPathManager::`vftable' = &sub_140072A40; // weak
void *std::wostringstream::`vftable' = &sub_1400277F0; // weak
void (*qword_140100138[2])(void) = { NULL, NULL }; // weak
void (*qword_140100148)(void) = NULL; // weak
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, 105664, 0, 1144480 }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, 177648, 0, 1144544 }; // idb
const _ThrowInfo _TI1_AV_com_error__ = { 0u, 396352, 0, 1144848 }; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, 6560, 0, 1144984 }; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, 105664, 0, 1145080 }; // idb
const _ThrowInfo _TI4_AVfailure_ios_base_std__ = { 0u, 105664, 0, 1145216 }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, 306880, 0, 1145328 }; // idb
const _ThrowInfo _TI2_AVlogic_error_std__ = { 0u, 105664, 0, 1145424 }; // idb
__int64 (__fastcall *off_14011B100)() = &off_1400E4270; // weak
__int64 (__fastcall *off_14011B110)() = &off_1400E42D0; // weak
__int64 (__fastcall *off_14011B120)() = &off_1400E4310; // weak
int dword_14011CA60 = 28800; // weak
int dword_14011CA64 = 1; // weak
int dword_14011CA68 = -3600; // weak
void *off_14011CAF0 = &unk_14011CA70; // weak
char *off_14011CB20[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_14011CC80; // weak
void *off_14011CF40 = &unk_140130FA0; // weak
int dword_14011D380 = 1024; // weak
int dword_14011D384 = -1023; // weak
int dword_14011D388 = 53; // weak
int dword_14011D38C = 11; // weak
int dword_14011D390 = 64; // weak
int dword_14011D394 = 1023; // weak
int dword_14011D398 = 128; // weak
int dword_14011D39C = -127; // weak
int dword_14011D3A0 = 24; // weak
int dword_14011D3A4 = 8; // weak
int dword_14011D3A8 = 32; // weak
int dword_14011D3AC = 127; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
__int64 (__fastcall *off_14011D678)(_QWORD, _QWORD) = &sub_140060C80; // weak
int dword_14011D704 = 1; // weak
_QWORD qword_14011D720[2] = { 15i64, 0i64 }; // weak
int dword_14011D734 = -1; // weak
_QWORD qword_14011D740[4] = { 1i64, 0i64, -4294967295i64, 1i64 }; // weak
_QWORD qword_14011D760[4] = { 13i64, 0i64, -4294967295i64, 1i64 }; // weak
_QWORD qword_14011D780[136] =
{
  17i64,
  0i64,
  -4294967295i64,
  1i64,
  4294967297i64,
  8589934742i64,
  644245094401i64,
  4294967299i64,
  17179869334i64,
  644245094401i64,
  5i64,
  25769803926i64,
  644245094400i64,
  7i64,
  34359738518i64,
  644245094400i64,
  9i64,
  42949673110i64,
  644245094400i64,
  11i64,
  51539607702i64,
  644245094400i64,
  13i64,
  60129542294i64,
  644245094400i64,
  15i64,
  68719476886i64,
  644245094400i64,
  17i64,
  77309411478i64,
  644245094400i64,
  19i64,
  85899346070i64,
  644245094400i64,
  21i64,
  94489280662i64,
  644245094400i64,
  23i64,
  103079215254i64,
  644245094400i64,
  25i64,
  111669149846i64,
  644245094400i64,
  27i64,
  171798691990i64,
  644245094400i64,
  41i64,
  180388626582i64,
  644245094400i64,
  43i64,
  188978561174i64,
  644245094400i64,
  45i64,
  197568495766i64,
  644245094400i64,
  47i64,
  206158430358i64,
  644245094400i64,
  49i64,
  214748364950i64,
  644245094400i64,
  51i64,
  223338299542i64,
  644245094400i64,
  53i64,
  231928234134i64,
  644245094400i64,
  55i64,
  240518168726i64,
  644245094400i64,
  57i64,
  249108103318i64,
  644245094400i64,
  59i64,
  257698037910i64,
  644245094400i64,
  61i64,
  266287972502i64,
  644245094400i64,
  63i64,
  217724777136278i64,
  4294967297i64,
  120259084438i64,
  644245094401i64,
  4294967297i64,
  137438953622i64,
  644245094401i64,
  4294967325i64,
  128849019030i64,
  644245094401i64,
  28i64,
  133143986326i64,
  644245094400i64,
  4294967297i64,
  120259084438i64,
  644245094401i64,
  4294967297i64,
  141733920918i64,
  644245094401i64,
  4294967330i64,
  12884902038i64,
  644245094401i64,
  4294967298i64,
  17179869334i64,
  644245094401i64,
  8589934593i64,
  17179869187i64,
  81604378645i64,
  4294967297i64,
  150323855510i64,
  644245094401i64,
  4294967332i64,
  158913790102i64,
  644245094401i64,
  4294967334i64,
  274877907094i64,
  644245094401i64,
  4294967297i64,
  137438953622i64,
  644245094401i64,
  4294967335i64,
  34359738518i64,
  644245094401i64,
  120259084289i64,
  137438953473i64,
  128849018909i64,
  133143986204i64,
  137438953473i64,
  34359738407i64,
  120259084289i64,
  150323855361i64,
  158913789988i64,
  6053006553961725990i64,
  141733920769i64,
  12884901922i64,
  17179869186i64
}; // weak
wchar_t aName_2[5] = L"Name"; // weak
_UNKNOWN unk_14011DC40; // weak
DWORD dword_14011F58C = 1451230793u; // idb
DWORD dwStyle = 1442889728u; // idb
DWORD dword_14011FC14 = 1174405376u; // idb
int dword_140120034 = 10000; // weak
_UNKNOWN unk_1401233B4; // weak
_UNKNOWN unk_1401233B8; // weak
_UNKNOWN unk_140123618; // weak
_UNKNOWN unk_14012361C; // weak
_UNKNOWN unk_140123630; // weak
_UNKNOWN unk_140123634; // weak
_UNKNOWN unk_140123678; // weak
_UNKNOWN unk_14012367C; // weak
_UNKNOWN unk_140123690; // weak
_UNKNOWN unk_140123694; // weak
_UNKNOWN unk_1401236F0; // weak
_UNKNOWN unk_1401236F4; // weak
_UNKNOWN unk_140123738; // weak
_UNKNOWN unk_14012373C; // weak
_UNKNOWN unk_1401237D0; // weak
_UNKNOWN unk_140123A38; // weak
_UNKNOWN unk_140123A50; // weak
_UNKNOWN unk_140123A98; // weak
_UNKNOWN unk_140123AB0; // weak
_UNKNOWN unk_140123B10; // weak
_UNKNOWN unk_140123B58; // weak
_UNKNOWN unk_140124F98; // weak
_UNKNOWN unk_140125028; // weak
_UNKNOWN unk_140125030; // weak
_UNKNOWN unk_140125048; // weak
_UNKNOWN unk_140125058; // weak
_UNKNOWN unk_140125060; // weak
_UNKNOWN unk_140125078; // weak
HANDLE hActCtx = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
int dword_14012B984 = 2; // weak
wchar_t *off_14012B9C0[10] =
{
  L"bmp",
  L"ico",
  L"gif",
  L"jpg",
  L"exf",
  L"png",
  L"tif",
  L"wmf",
  L"emf",
  L"tiff"
}; // weak
wchar_t aYes_0[4] = L"yes"; // weak
wchar_t aNo[3] = L"no"; // weak
_UNKNOWN unk_14012C090; // weak
__int64 qword_14012C0A0; // weak
int dword_14012C0B0; // weak
unsigned __int64 qword_14012C0B8; // idb
unsigned __int64 qword_14012C0C0; // idb
unsigned __int64 qword_14012C0C8; // idb
__int64 qword_14012C0D0; // weak
unsigned __int64 qword_14012C0D8; // idb
unsigned __int64 qword_14012C0E0; // idb
_QWORD qword_14012C2E0[3]; // weak
__int64 qword_14012C300; // weak
__int64 qword_14012C308; // weak
__int64 qword_14012C310; // weak
__int64 qword_14012C318; // weak
__int64 qword_14012C320; // weak
_UNKNOWN qword_14012C328; // weak
unsigned __int64 qword_14012C348; // idb
_UNKNOWN unk_14012C3E0; // weak
__int64 qword_14012C3E8; // weak
__int64 qword_14012C3F0; // weak
__int64 qword_14012C3F8; // weak
__int64 qword_14012C400; // weak
__int64 qword_14012C408; // weak
__int64 qword_14012C410; // weak
__int64 qword_14012C418; // weak
__int64 qword_14012C420; // weak
__int64 qword_14012C428; // weak
__int64 qword_14012C430; // weak
__int64 qword_14012C438; // weak
__int64 qword_14012C440; // weak
__int64 qword_14012C448; // weak
__int64 qword_14012C450; // weak
__int64 qword_14012C458; // weak
__int64 qword_14012C460; // weak
__int64 qword_14012C468; // weak
__int64 qword_14012C470; // weak
__int64 qword_14012C478; // weak
__int64 qword_14012C480; // weak
unsigned __int64 qword_14012C488; // idb
unsigned __int64 qword_14012C490; // idb
unsigned __int64 qword_14012C498; // idb
unsigned __int64 qword_14012C4A0; // idb
unsigned __int64 qword_14012C4A8; // idb
unsigned __int64 qword_14012C4B0; // idb
unsigned __int64 qword_14012C4B8; // idb
unsigned __int64 qword_14012C4C0; // idb
unsigned __int64 qword_14012C4C8; // idb
unsigned __int64 qword_14012C4D0; // idb
unsigned __int64 qword_14012C4D8; // idb
unsigned __int64 qword_14012C4E0; // idb
unsigned __int64 qword_14012C4E8; // idb
unsigned __int64 qword_14012C4F0; // idb
unsigned __int64 qword_14012C4F8; // idb
unsigned __int64 qword_14012C500; // idb
unsigned __int64 qword_14012C508; // idb
__int64 qword_14012C510; // weak
__int64 qword_14012C518; // weak
__int64 qword_14012C520; // weak
__int64 qword_14012C528; // weak
__int64 qword_14012C530; // weak
__int64 qword_14012C538; // weak
__int64 qword_14012C540; // weak
unsigned __int64 qword_14012C550; // idb
unsigned __int64 qword_14012C558; // idb
unsigned __int64 qword_14012C560; // idb
unsigned __int64 qword_14012C568; // idb
unsigned __int64 qword_14012C578; // idb
unsigned __int64 qword_14012C580; // idb
unsigned __int64 qword_14012C588; // idb
_QWORD qword_14012C590[3]; // weak
PVOID qword_14012CB50; // idb
PVOID qword_14012D1F0; // idb
PVOID qword_14012D208; // idb
__int64 qword_14012D640; // weak
__int64 qword_14012D6D0; // weak
PVOID qword_14012D6D8; // idb
PVOID qword_14012D6E0; // idb
PVOID qword_14012D6E8; // idb
PVOID qword_14012D6F0; // idb
PVOID qword_14012D6F8; // idb
HMODULE hModule; // idb
__int64 qword_14012D720; // weak
__int64 qword_14012D728; // weak
int dword_14012D730; // weak
int dword_14012D734; // weak
int dword_14012D738; // weak
WPARAM dword_14012D73C; // idb
__int64 qword_14012D740; // weak
HICON qword_14012D748; // idb
WPARAM wParam; // idb
int dword_14012D758; // weak
int dword_14012D75C; // weak
int dword_14012D768; // weak
int dword_14012D76C; // weak
int dword_14012D778; // weak
int dword_14012D77C; // weak
int dword_14012D788; // weak
int dword_14012D78C; // weak
int dword_14012D798; // weak
int dword_14012D79C; // weak
int dword_14012D7A8; // weak
int dword_14012D7AC; // weak
HWND qword_14012D7B8; // idb
struct _RTL_CRITICAL_SECTION stru_14012D7C0; // idb
WNDPROC lpPrevWndFunc; // idb
LPARAM qword_14012D7F0; // idb
LPARAM hIcon; // idb
int dword_14012DA00; // weak
HMENU hMenu; // idb
int dword_14012DA10; // weak
LPARAM qword_14012DA18; // idb
_UNKNOWN unk_14012DA20; // weak
HINSTANCE hInstance; // idb
HWND hWnd; // idb
HWND hDlg; // idb
LPVOID lpBuffer; // idb
HIMAGELIST himl; // idb
__int64 qword_14012DA88; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
DWORD ThreadId; // idb
int dword_14012DACC; // weak
struct _RTL_CRITICAL_SECTION stru_14012DAD0; // idb
int dword_14012DAF8; // weak
int dword_14012DAFC; // weak
struct _RTL_CRITICAL_SECTION stru_14012DB00; // idb
int dword_14012DB28; // weak
int dword_14012DB2C; // weak
int dword_14012DB30; // weak
int dword_14012DB34; // weak
HWND qword_14012DB38; // idb
int dword_14012DB90; // weak
int dword_14012DB94; // weak
int dword_14012DC38; // weak
int dword_14012DC3C; // weak
LPARAM lParam; // idb
int dword_14012DC98; // weak
int dword_14012DC9C; // weak
int dword_14012DD40; // weak
int dword_14012DD44; // weak
int dword_14012DD48; // weak
int dword_14012DD4C; // weak
__int64 qword_14012DF30; // weak
void *qword_14012DF88; // idb
__int64 qword_14012DF90; // weak
void *qword_14012DFA0; // idb
__int64 qword_14012DFA8; // weak
void *qword_14012DFB8; // idb
__int64 qword_14012DFC0; // weak
__int16 word_14012DFD0; // weak
void *qword_14012DFD8; // idb
__int64 qword_14012DFE0; // weak
void *Block; // idb
__int64 qword_14012DFF8; // weak
__int64 qword_14012E000; // weak
__int64 qword_14012E010; // weak
__int64 qword_14012E018; // weak
int dword_14012E020; // weak
__int16 word_14012E028; // weak
__int64 qword_14012E030; // weak
int dword_14012E038; // weak
int dword_14012E03C; // weak
int dword_14012E040; // weak
__int16 word_14012E048; // weak
__int64 qword_14012E050; // weak
int dword_14012E058; // weak
int dword_14012E05C; // weak
int dword_14012E060; // weak
void *qword_14012E068; // idb
__int64 qword_14012E070; // weak
void *qword_14012E080; // idb
__int64 qword_14012E088; // weak
void *qword_14012E098; // idb
__int64 qword_14012E0A0; // weak
void *qword_14012E0B0; // idb
__int64 qword_14012E0B8; // weak
LPARAM dwInitParam; // idb
int dword_14012E0D0; // weak
int dword_14012E0D4; // weak
__int64 qword_14012E0D8; // weak
HMODULE qword_14012E0E0; // idb
__int64 qword_14012E0E8; // weak
__int64 qword_14012E0F0; // weak
__int64 qword_14012E0F8; // weak
__int64 qword_14012E100; // weak
__int64 qword_14012E108; // weak
__int64 qword_14012E110; // weak
__int64 qword_14012E118; // weak
__int64 qword_14012E120; // weak
__int64 qword_14012E128; // weak
__int64 qword_14012E130; // weak
__int64 qword_14012E138; // weak
__int64 qword_14012E140; // weak
__int64 qword_14012E148; // weak
__int64 qword_14012E150; // weak
__int64 qword_14012E158; // weak
int dword_14012E160; // weak
int dword_14012E164; // weak
__int64 qword_14012E168; // weak
int dword_14012E170; // weak
int dword_14012E174; // weak
int dword_14012E178; // weak
__int64 qword_14012E180; // weak
__int64 qword_14012E188; // weak
__int64 qword_14012E190; // weak
HMODULE qword_14012E198; // idb
__int64 qword_14012E1A0; // weak
__int64 qword_14012E1A8; // weak
int dword_14012E1B0; // weak
__int64 qword_14012E1B8; // weak
__int64 qword_14012E1C8; // weak
int dword_14012E1D0; // weak
int dword_14012E1D4; // weak
int dword_14012E1D8; // weak
int dword_14012E1DC; // weak
int dword_14012E1E0; // weak
int dword_14012E1E4; // weak
int dword_14012E1E8; // weak
int dword_14012E648; // weak
int dword_14012E650; // weak
int dword_14012E654; // weak
OLECHAR Buffer[64]; // weak
_UNKNOWN unk_14012E6E0; // weak
WCHAR word_14012EAE0; // idb
wchar_t word_14012ECE8[13]; // weak
__int16 word_14012ED02; // weak
_UNKNOWN unk_14012ED10; // weak
__int64 qword_14012ED90; // weak
int dword_14012ED98; // weak
_UNKNOWN unk_14012EDAC; // weak
char byte_14012EFAC; // weak
__int64 qword_14012EFB0; // weak
int dword_14012EFB8; // weak
_UNKNOWN unk_14012EFCC; // weak
char byte_14012F1CC; // weak
int dword_14012F1D0; // weak
__int64 qword_14012F1E0; // weak
int dword_14012F1E8; // weak
_UNKNOWN unk_14012F1FC; // weak
char byte_14012F3FC; // weak
__int64 qword_14012F400; // weak
int dword_14012F408; // weak
_UNKNOWN unk_14012F41C; // weak
char byte_14012F61C; // weak
__int64 qword_14012F620; // weak
__int64 qword_14012F628; // weak
__int64 qword_14012F630; // weak
__int64 qword_14012F640; // weak
int dword_14012F648; // weak
_UNKNOWN unk_14012F65C; // weak
char byte_14012F85C; // weak
__int64 qword_14012F860; // weak
int dword_14012F868; // weak
_UNKNOWN unk_14012F87C; // weak
char byte_14012FA7C; // weak
int dword_14012FA80; // weak
int dword_14012FA84; // weak
__int64 qword_14012FA90; // weak
int dword_14012FA98; // weak
_UNKNOWN unk_14012FAAC; // weak
char byte_14012FCAC; // weak
int dword_14012FCB0; // weak
__int64 qword_14012FCC0; // weak
int dword_14012FCC8; // weak
_UNKNOWN unk_14012FCDC; // weak
char byte_14012FEDC; // weak
__int64 qword_14012FEE0; // weak
int dword_14012FEE8; // weak
_UNKNOWN unk_14012FEFC; // weak
char byte_1401300FC; // weak
int dword_140130100; // weak
_UNKNOWN unk_140130104; // weak
__int64 qword_140130150; // weak
int dword_140130158; // weak
_UNKNOWN unk_14013016C; // weak
char byte_14013036C; // weak
_UNKNOWN unk_140130370; // weak
void *qword_140130570; // idb
int dword_140130588; // weak
int dword_14013058C; // weak
int dword_140130590; // weak
__int64 qword_1401305A0; // weak
int dword_1401305A8; // weak
_UNKNOWN unk_1401305BC; // weak
char byte_1401307BC; // weak
_UNKNOWN unk_1401307C0; // weak
void *qword_1401309C8; // idb
void *qword_1401309E0; // idb
__int64 qword_1401309E8; // weak
__int64 qword_1401309F0; // weak
__int64 qword_1401309F8; // weak
int dword_140130A00; // weak
void *qword_140130A08; // idb
__int64 qword_140130A10; // weak
__int64 qword_140130A18; // weak
int dword_140130A28; // weak
int dword_140130A2C; // weak
__int64 qword_140130A30; // weak
int dword_140130A38; // weak
int dword_140130A3C; // weak
int dword_140130A40; // weak
__int64 qword_140130A50; // weak
int dword_140130A58; // weak
_UNKNOWN unk_140130A6C; // weak
char byte_140130C6C; // weak
void *qword_140130C70; // idb
int dword_140130C88; // weak
int dword_140130C8C; // weak
int dword_140130C90; // weak
int dword_140130C94; // weak
int dword_140130C98; // weak
__int64 qword_140130CA8; // weak
__int64 qword_140130CB0; // weak
__int64 qword_140130CC0; // weak
int dword_140130CC8; // weak
_UNKNOWN unk_140130CDC; // weak
char byte_140130EDC; // weak
void *qword_140130EE0; // idb
__int64 qword_140130EF0; // weak
__int64 qword_140130EF8; // weak
void *qword_140130F08; // idb
__int64 qword_140130F18; // weak
__int64 qword_140130F20; // weak
unsigned __int64 qword_140130F38; // idb
unsigned __int64 qword_140130F40; // idb
unsigned __int64 qword_140130F48; // idb
unsigned __int64 qword_140130F50; // idb
unsigned __int64 qword_140130F58; // idb
unsigned __int64 qword_140130F60; // idb
unsigned __int64 qword_140130F68; // idb
unsigned __int64 qword_140130F70; // idb
unsigned __int64 qword_140130F78; // idb
int dword_140131FA4; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 sub_140001000(wchar_t *a1, unsigned __int64 a2, const wchar_t *a3, ...)
{
  unsigned int v3; // ebx
  __int64 result; // rax
  unsigned __int64 v6; // rdi
  int v7; // eax
  va_list Args; // [rsp+58h] [rbp+20h] BYREF

  va_start(Args, a3);
  v3 = 0;
  result = 0i64;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = 2147942487i64;
  if ( (int)result >= 0 )
  {
    v6 = a2 - 1;
    v7 = vsnwprintf(a1, a2 - 1, a3, Args);
    if ( v7 < 0 || v7 > v6 )
    {
      a1[v6] = 0;
      return (unsigned int)-2147024774;
    }
    else if ( v7 == v6 )
    {
      a1[v6] = 0;
      return 0i64;
    }
    return v3;
  }
  return result;
}

//----- (0000000140001080) ----------------------------------------------------
__int64 __fastcall sub_140001080(_WORD *a1, unsigned __int64 a2, __int64 a3)
{
  int v6; // er9
  unsigned __int64 v7; // rcx
  _WORD *v8; // rax
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdx
  _WORD *v11; // rcx
  __int64 v12; // r11
  __int64 v13; // r8
  __int16 v14; // ax

  v6 = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    v6 = -2147024809;
  if ( v6 < 0 )
    goto LABEL_9;
  v7 = a2;
  v8 = a1;
  v6 = 0;
  if ( !a2 )
    goto LABEL_8;
  while ( *v8 )
  {
    ++v8;
    if ( !--v7 )
      goto LABEL_8;
  }
  if ( !v7 )
  {
LABEL_8:
    v6 = -2147024809;
LABEL_9:
    v9 = 0i64;
    goto LABEL_10;
  }
  v9 = a2 - v7;
LABEL_10:
  if ( v6 >= 0 )
  {
    v10 = a2 - v9;
    v11 = &a1[v9];
    v6 = 0;
    if ( v10 )
    {
      v12 = a3 - (_QWORD)v11;
      v13 = v10 - a2 + v9 + 0x7FFFFFFF;
      while ( v13 )
      {
        v14 = *(_WORD *)((char *)v11 + v12);
        if ( !v14 )
          break;
        *v11++ = v14;
        --v13;
        if ( !--v10 )
          goto LABEL_20;
      }
    }
    else
    {
LABEL_20:
      --v11;
      v6 = -2147024774;
    }
    *v11 = 0;
  }
  return (unsigned int)v6;
}
// 140001130: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140001150) ----------------------------------------------------
INT_PTR __fastcall sub_140001150(LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
  HINSTANCE v8; // r14
  DWORD LastError; // edi
  INT_PTR v11; // rsi
  ULONG_PTR Cookie; // [rsp+30h] [rbp-28h] BYREF
  INT_PTR v13; // [rsp+38h] [rbp-20h]

  v8 = hInstance;
  v13 = -1i64;
  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return -1i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return -1i64;
  v11 = DialogBoxParamW(v8, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
  v13 = v11;
  if ( v11 == -1 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( v11 == -1 )
    SetLastError(LastError);
  return v11;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (0000000140001240) ----------------------------------------------------
__int64 __fastcall sub_140001240(_WORD *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned int v4; // er10
  unsigned __int64 v5; // r9
  __int64 v6; // r8
  __int16 v7; // ax

  result = 0i64;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = 2147942487i64;
  if ( (int)result >= 0 )
  {
    v4 = 0;
    if ( a2 )
    {
      v5 = 2147483646 - a2;
      v6 = a3 - (_QWORD)a1;
      while ( v5 + a2 )
      {
        v7 = *(_WORD *)((char *)a1 + v6);
        if ( !v7 )
          break;
        *a1++ = v7;
        if ( !--a2 )
        {
          *(a1 - 1) = 0;
          return 2147942522i64;
        }
      }
    }
    else
    {
      --a1;
      v4 = -2147024774;
    }
    *a1 = 0;
    return v4;
  }
  return result;
}
// 1400012A5: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400012C0) ----------------------------------------------------
__int64 __fastcall sub_1400012C0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int v6; // edi
  __int64 (__fastcall *v7)(__int64, __int64, __int64); // rbx
  DWORD LastError; // esi
  FARPROC v9; // rax
  ULONG_PTR Cookie; // [rsp+68h] [rbp+20h] BYREF

  v6 = -1;
  v7 = (__int64 (__fastcall *)(__int64, __int64, __int64))qword_14012D728;
  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return v6;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return v6;
  if ( v7 )
    goto LABEL_8;
  v9 = sub_140001610("ImageList_Add");
  v7 = (__int64 (__fastcall *)(__int64, __int64, __int64))v9;
  if ( v9 )
  {
    qword_14012D728 = (__int64)v9;
LABEL_8:
    v6 = v7(a1, a2, a3);
  }
  if ( v6 == -1 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( v6 == -1 )
    SetLastError(LastError);
  return v6;
}
// 14012D728: using guessed type __int64 qword_14012D728;
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (00000001400013C0) ----------------------------------------------------
__int64 sub_1400013C0()
{
  unsigned int v0; // ebx
  HANDLE ActCtxW; // rax
  DWORD LastError; // eax
  ULONG_PTR Cookie; // [rsp+40h] [rbp-2B8h] BYREF
  HMODULE phModule; // [rsp+48h] [rbp-2B0h] BYREF
  void *hActCtx[2]; // [rsp+50h] [rbp-2A8h] BYREF
  struct tagACTCTX_SECTION_KEYED_DATA pActCtx; // [rsp+60h] [rbp-298h] BYREF
  WCHAR Filename[260]; // [rsp+D0h] [rbp-228h] BYREF
  int v9; // [rsp+2D8h] [rbp-20h]

  v0 = 0;
  Cookie = 0i64;
  if ( ::hActCtx != (HANDLE)-1i64 )
    return 1;
  if ( QueryActCtxW(0x80000010, &::hActCtx, 0i64, 1u, hActCtx, 0x10ui64, 0i64) )
  {
    ActCtxW = hActCtx[0];
    if ( hActCtx[0] )
      goto LABEL_15;
    if ( GetModuleHandleExW(6u, (LPCWSTR)&::hActCtx, &phModule) )
    {
      v9 = 0;
      if ( GetModuleFileNameW(phModule, Filename, 0x105u) )
      {
        if ( (_WORD)v9 )
        {
          SetLastError(0x6Fu);
          return v0;
        }
        pActCtx.cbSize = 56;
        pActCtx.ulDataFormatVersion = 136;
        pActCtx.lpData = Filename;
        *(_QWORD *)&pActCtx.ulSectionGlobalDataLength = 3i64;
        *(_QWORD *)&pActCtx.ulSectionTotalLength = phModule;
        ActCtxW = CreateActCtxW((PCACTCTXW)&pActCtx);
        hActCtx[0] = ActCtxW;
        if ( ActCtxW != (HANDLE)-1i64 )
          goto LABEL_14;
        LastError = GetLastError();
        if ( LastError == 1812 || LastError == 1813 || LastError == 1815 || LastError == 1814 )
        {
          ActCtxW = 0i64;
          hActCtx[0] = 0i64;
LABEL_14:
          dword_14012E0D0 = 1;
LABEL_15:
          ::hActCtx = ActCtxW;
          if ( ActivateActCtx(ActCtxW, &Cookie) )
          {
            pActCtx.cbSize = 112;
            if ( FindActCtxSectionStringW(0, 0i64, 2u, L"Comctl32.dll", &pActCtx) )
              LoadLibraryW(L"Comctl32.dll");
            DeactivateActCtx(0, Cookie);
          }
          return 1;
        }
      }
    }
  }
  return v0;
}
// 14012E0D0: using guessed type int dword_14012E0D0;
// 1400013C0: using guessed type HANDLE hActCtx[2];

//----- (00000001400015A0) ----------------------------------------------------
__int64 __fastcall sub_1400015A0(ULONG_PTR *lpCookie)
{
  unsigned int v1; // ebx

  v1 = 0;
  if ( dword_14012E0D4
    && (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), dword_14012E0D4)
    || (unsigned int)sub_1400013C0() )
  {
    if ( ActivateActCtx(hActCtx, lpCookie) )
      return 1;
  }
  return v1;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (0000000140001610) ----------------------------------------------------
FARPROC __fastcall sub_140001610(LPCSTR lpProcName)
{
  DWORD LastError; // edi
  FARPROC ProcAddress; // rbx
  int v4; // esi
  HMODULE LibraryW; // rax
  ULONG_PTR ulCookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  ProcAddress = 0i64;
  ulCookie = 0i64;
  v4 = sub_1400015A0(&ulCookie);
  if ( v4 )
  {
    LibraryW = hModule;
    if ( !hModule )
    {
      LibraryW = LoadLibraryW(L"Comctl32.dll");
      if ( !LibraryW )
        goto LABEL_6;
      hModule = LibraryW;
    }
    ProcAddress = GetProcAddress(LibraryW, lpProcName);
  }
LABEL_6:
  if ( v4 )
  {
    if ( !ProcAddress )
      LastError = GetLastError();
    DeactivateActCtx(0, ulCookie);
    if ( !ProcAddress )
      SetLastError(LastError);
  }
  return ProcAddress;
}

//----- (00000001400016D0) ----------------------------------------------------
__int64 __fastcall sub_1400016D0(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  DWORD LastError; // edi
  __int64 v10; // rsi
  __int64 (__fastcall *v11)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); // rbx
  FARPROC v13; // rax
  ULONG_PTR Cookie; // [rsp+30h] [rbp-28h] BYREF
  __int64 v15; // [rsp+38h] [rbp-20h]

  LastError = 0;
  v10 = 0i64;
  v15 = 0i64;
  v11 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD))qword_14012D720;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v11 )
    goto LABEL_9;
  v13 = sub_140001610("ImageList_Create");
  v11 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD))v13;
  if ( v13 )
  {
    qword_14012D720 = (__int64)v13;
LABEL_9:
    v10 = v11(a1, a2, a3, a4, a5);
    v15 = v10;
  }
  if ( !v10 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v10 )
    SetLastError(LastError);
  return v10;
}
// 14012D720: using guessed type __int64 qword_14012D720;
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (00000001400017F0) ----------------------------------------------------
FARPROC __fastcall sub_1400017F0(LPCSTR lpProcName)
{
  DWORD LastError; // edi
  FARPROC ProcAddress; // rbx
  int v4; // esi
  HMODULE LibraryW; // rax
  ULONG_PTR ulCookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  ProcAddress = 0i64;
  ulCookie = 0i64;
  v4 = sub_1400015A0(&ulCookie);
  if ( v4 )
  {
    LibraryW = qword_14012E0E0;
    if ( !qword_14012E0E0 )
    {
      LibraryW = LoadLibraryW(L"Comdlg32.dll");
      if ( !LibraryW )
        goto LABEL_6;
      qword_14012E0E0 = LibraryW;
    }
    ProcAddress = GetProcAddress(LibraryW, lpProcName);
  }
LABEL_6:
  if ( v4 )
  {
    if ( !ProcAddress )
      LastError = GetLastError();
    DeactivateActCtx(0, ulCookie);
    if ( !ProcAddress )
      SetLastError(LastError);
  }
  return ProcAddress;
}
// 1400F6750: using guessed type wchar_t aComdlg32Dll_0[13];

//----- (00000001400018B0) ----------------------------------------------------
__int64 __fastcall sub_1400018B0(__int64 a1)
{
  DWORD LastError; // esi
  unsigned int v3; // edi
  __int64 (__fastcall *v4)(__int64); // rbx
  FARPROC v6; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v3 = 0;
  v4 = (__int64 (__fastcall *)(__int64))qword_14012E0D8;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
    goto LABEL_9;
  v6 = sub_1400017F0("GetOpenFileNameW");
  v4 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E0D8 = (__int64)v6;
LABEL_9:
    v3 = v4(a1);
  }
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E0D8: using guessed type __int64 qword_14012E0D8;

//----- (00000001400019A0) ----------------------------------------------------
void __fastcall sub_1400019A0(std::exception *a1)
{
  *(_QWORD *)a1 = &std::bad_alloc::`vftable';
  sub_14004AEC0(a1);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400019B0) ----------------------------------------------------
std::exception *__fastcall sub_1400019B0(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400019E0) ----------------------------------------------------
void *__fastcall sub_1400019E0(void *Block, char a2)
{
  *(_QWORD *)Block = &std::bad_alloc::`vftable';
  sub_14004AEC0((std::exception *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140001A20) ----------------------------------------------------
__int64 __fastcall sub_140001A20(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  DWORD LastError; // edi
  __int64 v9; // rsi
  __int64 (__fastcall *v10)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // rbx
  FARPROC v12; // rax
  ULONG_PTR Cookie; // [rsp+20h] [rbp-28h] BYREF
  __int64 v14; // [rsp+28h] [rbp-20h]

  LastError = 0;
  v9 = 0i64;
  v14 = 0i64;
  v10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))qword_14012E0F8;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v10 )
    goto LABEL_9;
  v12 = sub_140001610("DefSubclassProc");
  v10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v12;
  if ( v12 )
  {
    qword_14012E0F8 = (__int64)v12;
LABEL_9:
    v9 = v10(a1, a2, a3, a4, Cookie, v14);
    v14 = v9;
  }
  if ( !v9 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v9 )
    SetLastError(LastError);
  return v9;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E0F8: using guessed type __int64 qword_14012E0F8;

//----- (0000000140001B30) ----------------------------------------------------
_QWORD *__fastcall sub_140001B30(_QWORD *a1, char a2)
{
  *a1 = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (0000000140001B60) ----------------------------------------------------
void __fastcall sub_140001B60(__int64 a1)
{
  struct std::ios_base *v1; // rdi

  v1 = (struct std::ios_base *)(a1 + 144);
  *(_QWORD *)((char *)v1 + *(int *)(*(_QWORD *)a1 + 4i64) - 144) = &std::wistringstream::`vftable';
  sub_140001E20(a1 + 16);
  *(_QWORD *)((char *)v1 + *(int *)(*((_QWORD *)v1 - 18) + 4i64) - 144) = &std::wistream::`vftable';
  *(_QWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 140001B7B: ignored the value written to the shadow area of the succeeding call
// 1400F68B8: using guessed type void *std::wistringstream::`vftable';
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';

//----- (0000000140001DE0) ----------------------------------------------------
_QWORD *__fastcall sub_140001DE0(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  a2[3] = 7i64;
  a2[2] = 0i64;
  *(_WORD *)a2 = 0;
  sub_140009610(a2, a1, a3, a4);
  return a2;
}

//----- (0000000140001E20) ----------------------------------------------------
__int64 __fastcall sub_140001E20(__int64 a1)
{
  bool v1; // zf
  __int64 *v3; // rdi

  v1 = (*(_BYTE *)(a1 + 120) & 1) == 0;
  *(_QWORD *)a1 = &std::wstringbuf::`vftable';
  if ( !v1 )
    j_free(**(void ***)(a1 + 32));
  **(_QWORD **)(a1 + 32) = 0i64;
  **(_QWORD **)(a1 + 64) = 0i64;
  **(_DWORD **)(a1 + 88) = 0;
  **(_QWORD **)(a1 + 40) = 0i64;
  **(_QWORD **)(a1 + 72) = 0i64;
  **(_DWORD **)(a1 + 96) = 0;
  v3 = *(__int64 **)(a1 + 104);
  *(_DWORD *)(a1 + 120) &= ~1u;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)a1 = &std::wstreambuf::`vftable';
  if ( v3 )
  {
    sub_140008FC0(v3);
    j_free(v3);
  }
  return unknown_libname_21(a1 + 8);
}
// 14002C534: using guessed type __int64 __fastcall unknown_libname_21(_QWORD);
// 1400F6838: using guessed type void *std::wstringbuf::`vftable';
// 1400F6A68: using guessed type void *std::wstreambuf::`vftable';

//----- (0000000140001EC0) ----------------------------------------------------
__int64 __fastcall sub_140001EC0(__int64 a1, unsigned __int16 a2)
{
  unsigned __int64 *v4; // r10
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // r9
  __int64 v7; // rcx
  unsigned __int64 v9; // r9
  int *v10; // r8
  _WORD **v11; // rcx
  unsigned __int16 *v12; // rdx
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // r14
  void *v16; // rax
  const void **v17; // rcx
  void *v18; // r13
  __int64 v19; // rsi
  __int64 *v20; // rax
  bool v21; // zf
  __int64 *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // r8
  __int64 v25; // rcx
  __int64 v26; // rdx
  _DWORD *v27; // rax
  _WORD **v28; // rcx
  unsigned __int16 *v29; // rdx

  if ( (*(_BYTE *)(a1 + 120) & 8) != 0 )
  {
    v4 = *(unsigned __int64 **)(a1 + 72);
    v5 = *v4;
    if ( *v4 )
    {
      v6 = *(_QWORD *)(a1 + 112);
      if ( v5 < v6 )
      {
        v7 = **(int **)(a1 + 96);
        *v4 = v6;
        **(_DWORD **)(a1 + 96) = (__int64)(v5 + 2 * v7 - v6) >> 1;
      }
    }
  }
  if ( a2 == 0xFFFF )
    return 0i64;
  v9 = **(_QWORD **)(a1 + 72);
  if ( v9 )
  {
    v10 = *(int **)(a1 + 96);
    if ( v9 < v9 + 2i64 * *v10 )
    {
      --*v10;
      v11 = *(_WORD ***)(a1 + 72);
      v12 = (*v11)++;
      *v12 = a2;
      return a2;
    }
  }
  if ( (*(_BYTE *)(a1 + 120) & 2) != 0 )
    return 0xFFFFi64;
  if ( v9 )
    v13 = (__int64)(v9 + 2i64 * **(int **)(a1 + 96) - **(_QWORD **)(a1 + 32)) >> 1;
  else
    v13 = 0i64;
  v14 = v13 >> 1;
  if ( v13 >> 1 >= 0x20 )
  {
    if ( !v14 )
      return 0xFFFFi64;
  }
  else
  {
    v14 = 32i64;
  }
  do
  {
    if ( 0x7FFFFFFF - v14 >= v13 )
      break;
    v14 >>= 1;
  }
  while ( v14 );
  if ( !v14 )
    return 0xFFFFi64;
  v15 = v14 + v13;
  v16 = sub_140009740(a1 + 124, v14 + v13);
  v17 = *(const void ***)(a1 + 32);
  v18 = (void *)*v17;
  v19 = (__int64)v16;
  if ( v13 )
  {
    memmove(v16, *v17, 2 * v13);
    *(_QWORD *)(a1 + 112) = v19 + 2 * ((__int64)(*(_QWORD *)(a1 + 112) - (_QWORD)v18) >> 1);
    v23 = v19 + 2 * ((__int64)(**(_QWORD **)(a1 + 72) - (_QWORD)v18) >> 1);
    **(_QWORD **)(a1 + 40) = v19 + 2 * ((__int64)(**(_QWORD **)(a1 + 40) - (_QWORD)v18) >> 1);
    **(_QWORD **)(a1 + 72) = v23;
    **(_DWORD **)(a1 + 96) = (__int64)(v19 + 2 * v15 - v23) >> 1;
    if ( (*(_BYTE *)(a1 + 120) & 4) != 0 )
    {
      **(_QWORD **)(a1 + 32) = v19;
      **(_QWORD **)(a1 + 64) = 0i64;
      **(_DWORD **)(a1 + 88) = v19 >> 1;
    }
    else
    {
      v24 = **(_QWORD **)(a1 + 72);
      v25 = **(_QWORD **)(a1 + 64);
      **(_QWORD **)(a1 + 32) = v19;
      v26 = v19 + 2 * ((v25 - (__int64)v18) >> 1);
      **(_QWORD **)(a1 + 64) = v26;
      **(_DWORD **)(a1 + 88) = (v24 - v26 + 2) >> 1;
    }
  }
  else
  {
    v20 = *(__int64 **)(a1 + 40);
    *(_QWORD *)(a1 + 112) = v19;
    *v20 = v19;
    **(_QWORD **)(a1 + 72) = v19;
    **(_DWORD **)(a1 + 96) = (__int64)(2 * v15) >> 1;
    v21 = (*(_BYTE *)(a1 + 120) & 4) == 0;
    **(_QWORD **)(a1 + 32) = v19;
    v22 = *(__int64 **)(a1 + 64);
    if ( v21 )
    {
      *v22 = v19;
      **(_DWORD **)(a1 + 88) = 1;
    }
    else
    {
      *v22 = 0i64;
      **(_DWORD **)(a1 + 88) = v19 >> 1;
    }
  }
  if ( (*(_BYTE *)(a1 + 120) & 1) != 0 )
    j_free(v18);
  v27 = *(_DWORD **)(a1 + 96);
  *(_DWORD *)(a1 + 120) |= 1u;
  --*v27;
  v28 = *(_WORD ***)(a1 + 72);
  v29 = (*v28)++;
  *v29 = a2;
  return a2;
}
// 14000202D: conditional instruction was optimized away because rdi.8!=0

//----- (0000000140002180) ----------------------------------------------------
__int64 __fastcall sub_140002180(__int64 a1, unsigned __int16 a2)
{
  unsigned __int64 v2; // r8
  __int64 result; // rax

  v2 = **(_QWORD **)(a1 + 64);
  if ( !v2
    || v2 <= **(_QWORD **)(a1 + 32)
    || a2 != 0xFFFF && a2 != *(_WORD *)(v2 - 2) && (*(_BYTE *)(a1 + 120) & 2) != 0 )
  {
    return 0xFFFFi64;
  }
  ++**(_DWORD **)(a1 + 88);
  **(_QWORD **)(a1 + 64) -= 2i64;
  if ( a2 == 0xFFFF )
    return 0i64;
  result = a2;
  ***(_WORD ***)(a1 + 64) = a2;
  return result;
}

//----- (00000001400021E0) ----------------------------------------------------
__int64 __fastcall sub_1400021E0(__int64 a1)
{
  unsigned __int16 **v1; // r11
  unsigned __int16 *v3; // r10
  int *v5; // rbx
  unsigned __int64 v6; // rcx

  v1 = *(unsigned __int16 ***)(a1 + 64);
  v3 = *v1;
  if ( !*v1 )
    return 0xFFFFi64;
  v5 = *(int **)(a1 + 88);
  if ( v3 < &v3[*v5] )
    return *v3;
  if ( (*(_BYTE *)(a1 + 120) & 4) != 0 )
    return 0xFFFFi64;
  v6 = **(_QWORD **)(a1 + 72);
  if ( !v6 || v6 <= (unsigned __int64)v3 && *(_QWORD *)(a1 + 112) <= (unsigned __int64)v3 )
    return 0xFFFFi64;
  if ( *(_QWORD *)(a1 + 112) < v6 )
    *(_QWORD *)(a1 + 112) = v6;
  *v5 = (__int64)(*(_QWORD *)(a1 + 112) - (_QWORD)*v1) >> 1;
  return ***(unsigned __int16 ***)(a1 + 64);
}

//----- (0000000140002280) ----------------------------------------------------
__int64 __fastcall sub_140002280(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  unsigned __int64 *v6; // r8
  unsigned __int64 v8; // rax
  __int64 v10; // rdi
  __int64 v11; // r9
  int v12; // er9
  __int64 *v13; // r9
  __int64 v14; // r8
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned __int64 v17; // r8
  __int64 v18; // rdx
  int v19; // edx

  v6 = *(unsigned __int64 **)(a1 + 72);
  v8 = *v6;
  if ( *v6 && *(_QWORD *)(a1 + 112) < v8 )
    *(_QWORD *)(a1 + 112) = v8;
  if ( (a5 & 1) != 0 )
  {
    v10 = **(_QWORD **)(a1 + 64);
    if ( v10 )
    {
      switch ( a4 )
      {
        case 2:
          a3 += (__int64)(*(_QWORD *)(a1 + 112) - **(_QWORD **)(a1 + 32)) >> 1;
LABEL_13:
          if ( a3 < 0 || (v11 = **(_QWORD **)(a1 + 32), a3 > (*(_QWORD *)(a1 + 112) - v11) >> 1) )
          {
            a3 = -1i64;
          }
          else
          {
            v12 = a3 + ((v11 - v10) >> 1);
            **(_DWORD **)(a1 + 88) -= v12;
            **(_QWORD **)(a1 + 64) += 2i64 * v12;
            if ( (a5 & 2) != 0 )
            {
              v13 = *(__int64 **)(a1 + 72);
              v14 = *v13;
              if ( *v13 )
              {
                v15 = **(_QWORD **)(a1 + 64);
                v16 = **(int **)(a1 + 96);
                *v13 = v15;
                **(_DWORD **)(a1 + 96) = (v14 + 2 * v16 - v15) >> 1;
              }
            }
          }
          goto LABEL_33;
        case 1:
          if ( (a5 & 2) == 0 )
          {
            a3 += (v10 - **(_QWORD **)(a1 + 32)) >> 1;
            goto LABEL_13;
          }
          break;
        case 0:
          goto LABEL_13;
      }
      a3 = -1i64;
      goto LABEL_13;
    }
  }
  if ( (a5 & 2) != 0 && (v17 = *v6) != 0 )
  {
    if ( a4 == 2 )
    {
      a3 += (__int64)(*(_QWORD *)(a1 + 112) - **(_QWORD **)(a1 + 32)) >> 1;
    }
    else if ( a4 == 1 )
    {
      a3 += (__int64)(v17 - **(_QWORD **)(a1 + 32)) >> 1;
    }
    else if ( a4 )
    {
      a3 = -1i64;
    }
    if ( a3 < 0 || (v18 = **(_QWORD **)(a1 + 32), a3 > (*(_QWORD *)(a1 + 112) - v18) >> 1) )
    {
      a3 = -1i64;
    }
    else
    {
      v19 = a3 + ((__int64)(v18 - v17) >> 1);
      **(_DWORD **)(a1 + 96) -= v19;
      **(_QWORD **)(a1 + 72) += 2i64 * v19;
    }
  }
  else if ( a3 )
  {
    a3 = -1i64;
  }
LABEL_33:
  *(_QWORD *)a2 = a3;
  *(_QWORD *)(a2 + 8) = 0i64;
  *(_DWORD *)(a2 + 16) = 0;
  return a2;
}

//----- (0000000140002440) ----------------------------------------------------
__int64 __fastcall sub_140002440(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  unsigned __int64 *v6; // rdx
  __int64 v7; // r10
  unsigned __int64 v9; // rax
  __int64 v10; // r8
  __int64 v11; // rdx
  int v12; // edx
  __int64 *v13; // rbx
  __int64 v14; // r8
  __int64 v15; // rdx
  __int64 v16; // rcx
  unsigned __int64 v17; // r8
  __int64 v18; // rdx
  int v19; // edx

  v6 = *(unsigned __int64 **)(a1 + 72);
  v7 = *(_QWORD *)a3 + *(int *)(a3 + 8);
  v9 = *v6;
  if ( *v6 && *(_QWORD *)(a1 + 112) < v9 )
    *(_QWORD *)(a1 + 112) = v9;
  if ( v7 != -1 )
  {
    if ( (a4 & 1) != 0 && (v10 = **(_QWORD **)(a1 + 64)) != 0 )
    {
      if ( v7 >= 0 )
      {
        v11 = **(_QWORD **)(a1 + 32);
        if ( v7 <= (*(_QWORD *)(a1 + 112) - v11) >> 1 )
        {
          v12 = v7 + ((v11 - v10) >> 1);
          **(_DWORD **)(a1 + 88) -= v12;
          **(_QWORD **)(a1 + 64) += 2i64 * v12;
          if ( (a4 & 2) != 0 )
          {
            v13 = *(__int64 **)(a1 + 72);
            v14 = *v13;
            if ( *v13 )
            {
              v15 = **(_QWORD **)(a1 + 64);
              v16 = **(int **)(a1 + 96);
              *v13 = v15;
              **(_DWORD **)(a1 + 96) = (v14 + 2 * v16 - v15) >> 1;
            }
          }
          goto LABEL_18;
        }
      }
    }
    else if ( (a4 & 2) != 0 )
    {
      v17 = *v6;
      if ( *v6 )
      {
        if ( v7 >= 0 )
        {
          v18 = **(_QWORD **)(a1 + 32);
          if ( v7 <= (*(_QWORD *)(a1 + 112) - v18) >> 1 )
          {
            v19 = v7 + ((__int64)(v18 - v17) >> 1);
            **(_DWORD **)(a1 + 96) -= v19;
            **(_QWORD **)(a1 + 72) += 2i64 * v19;
            goto LABEL_18;
          }
        }
      }
    }
    v7 = -1i64;
  }
LABEL_18:
  *(_QWORD *)a2 = v7;
  *(_QWORD *)(a2 + 8) = 0i64;
  *(_DWORD *)(a2 + 16) = 0;
  return a2;
}

//----- (0000000140002570) ----------------------------------------------------
void *__fastcall sub_140002570(__int64 a1, char a2)
{
  void *v2; // rdi

  v2 = (void *)(a1 - 144);
  sub_140001B60(a1 - 144);
  if ( (a2 & 1) != 0 )
    j_free(v2);
  return v2;
}

//----- (00000001400025B0) ----------------------------------------------------
void *__fastcall sub_1400025B0(void *Block, char a2)
{
  sub_140001E20((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (00000001400025E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400025E0(_QWORD *a1, __int64 a2)
{
  char *v4; // rsi

  *(_QWORD *)((char *)a1 + *(int *)(*a1 + 4i64)) = &std::wistream::`vftable';
  a1[1] = 0i64;
  v4 = (char *)a1 + *(int *)(*a1 + 4i64);
  sub_140008270((__int64)v4);
  *((_QWORD *)v4 + 9) = a2;
  *((_QWORD *)v4 + 10) = 0i64;
  *((_WORD *)v4 + 44) = sub_1400056C0((__int64)v4);
  if ( !*((_QWORD *)v4 + 9) )
    sub_140009260((__int64)v4, v4[16] | 4, 0);
  return a1;
}
// 1400F6AE8: using guessed type void *std::wistream::`vftable';

//----- (0000000140002680) ----------------------------------------------------
_QWORD *__fastcall sub_140002680(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, bool *a7)
{
  int v10; // edi
  __int64 *v11; // rax
  __int64 v12; // r13
  __int64 v13; // rax
  void (__fastcall ***v14)(_QWORD, __int64); // rsi
  __int64 v15; // r13
  _QWORD *v16; // rax
  __int64 v17; // rcx
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // rdx
  bool v20; // zf
  void **v21; // rax
  void **v22; // rax
  void **v23; // rax
  _QWORD *v24; // rax
  __int16 *v25; // r9
  void *v26; // rsi
  unsigned __int64 v27; // rbx
  void (__fastcall ***v28)(_QWORD, __int64); // rbx
  __int64 *v29; // r11
  unsigned int v30; // eax
  unsigned int v31; // er13
  __int64 v32; // rsi
  __int64 v33; // rax
  _QWORD *result; // rax
  int v35; // [rsp+30h] [rbp-91h] BYREF
  __int64 v36; // [rsp+38h] [rbp-89h] BYREF
  __int64 v37; // [rsp+40h] [rbp-81h] BYREF
  bool *v38; // [rsp+48h] [rbp-79h]
  void **v39; // [rsp+50h] [rbp-71h] BYREF
  _QWORD *v40; // [rsp+58h] [rbp-69h]
  __int64 v41; // [rsp+60h] [rbp-61h]
  void *Src[2]; // [rsp+68h] [rbp-59h] BYREF
  __int64 v43; // [rsp+78h] [rbp-49h]
  unsigned __int64 v44; // [rsp+80h] [rbp-41h]
  void *Block[3]; // [rsp+90h] [rbp-31h] BYREF
  unsigned __int64 v46; // [rsp+A8h] [rbp-19h]

  v41 = -2i64;
  v40 = a2;
  v38 = a7;
  v10 = -1;
  if ( (*(_DWORD *)(a5 + 24) & 0x4000) != 0 )
  {
    v11 = sub_140008F00(a5, &v36);
    v37 = sub_140007200(v11);
    v12 = v36;
    if ( v36 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v35, 0);
      v13 = *(_QWORD *)(v12 + 8);
      if ( v13 && v13 != -1 )
        *(_QWORD *)(v12 + 8) = v13 - 1;
      v14 = 0i64;
      if ( !*(_QWORD *)(v12 + 8) )
        v14 = (void (__fastcall ***)(_QWORD, __int64))v12;
      std::_Lockit::~_Lockit((std::_Lockit *)&v35);
      if ( v14 )
        (**v14)(v14, 1i64);
    }
    v44 = 7i64;
    v43 = 1i64;
    LODWORD(Src[0]) = 0;
    v15 = v37;
    v16 = (_QWORD *)unknown_libname_1(v37, Block);
    sub_140006E60(Src, v16, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    if ( v46 >= 8 )
      j_free(Block[0]);
    v17 = v43;
    if ( (unsigned __int64)(-1 - v43) <= 1 )
      sub_14002B5F8("string too long");
    v18 = v43 + 1;
    if ( (unsigned __int64)(v43 + 1) > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v19 = v44;
    if ( v44 >= v18 )
    {
      v20 = v18 == 0;
      if ( v43 != -1 )
      {
LABEL_23:
        if ( !v20 )
        {
          v22 = Src;
          if ( v19 >= 8 )
            v22 = (void **)Src[0];
          *((_WORD *)v22 + v17) = 0;
          v43 = v18;
          v23 = Src;
          if ( v44 >= 8 )
            v23 = (void **)Src[0];
          *((_WORD *)v23 + v18) = 0;
        }
        v24 = (_QWORD *)unknown_libname_2(v15, Block);
        sub_140006E60(Src, v24, 0i64, 0xFFFFFFFFFFFFFFFFui64);
        if ( v46 >= 8 )
          j_free(Block[0]);
        v25 = (__int16 *)Src;
        v26 = Src[0];
        v27 = v44;
        if ( v44 >= 8 )
          v25 = (__int16 *)Src[0];
        v10 = sub_140007350((__int64 *)a3, (__int64 *)a4, 2ui64, v25);
        if ( v27 >= 8 )
          j_free(v26);
        goto LABEL_47;
      }
      v43 = 0i64;
      v21 = Src;
      if ( v44 >= 8 )
        v21 = (void **)Src[0];
      *(_WORD *)v21 = 0;
    }
    else
    {
      sub_1400097B0(Src, v43 + 1, (const void *)v43);
    }
    v17 = v43;
    v19 = v44;
    v20 = v18 == 0;
    goto LABEL_23;
  }
  v28 = 0i64;
  v35 = 0;
  v29 = sub_140008F00(a5, &v37);
  v30 = sub_140003A10(a1, (__int64)Src, a3, a4, *(_DWORD *)(a5 + 24), v29);
  v31 = Stoulx(Src, &v39, v30, &v35);
  v32 = v37;
  if ( v37 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v36, 0);
    v33 = *(_QWORD *)(v32 + 8);
    if ( v33 && v33 != -1 )
      *(_QWORD *)(v32 + 8) = v33 - 1;
    if ( !*(_QWORD *)(v32 + 8) )
      v28 = (void (__fastcall ***)(_QWORD, __int64))v32;
    std::_Lockit::~_Lockit((std::_Lockit *)&v36);
    if ( v28 )
      (**v28)(v28, 1i64);
  }
  if ( v39 != Src && !v35 && v31 <= 1 )
    v10 = v31;
LABEL_47:
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( *(_QWORD *)a3 )
  {
    if ( !*(_QWORD *)a4 )
      goto LABEL_56;
    goto LABEL_55;
  }
  if ( !*(_QWORD *)a4 )
LABEL_55:
    *a6 |= 1u;
LABEL_56:
  if ( v10 >= 0 )
    *v38 = v10 != 0;
  else
    *a6 |= 2u;
  result = v40;
  *v40 = *(_QWORD *)a3;
  result[1] = *(_QWORD *)(a3 + 8);
  return result;
}
// 140005410: using guessed type __int64 __fastcall unknown_libname_1(_QWORD, _QWORD);
// 140005430: using guessed type __int64 __fastcall unknown_libname_2(_QWORD, _QWORD);
// 14002C564: using guessed type __int64 __fastcall Stoulx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400029E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400029E0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, _WORD *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // er15
  __int64 v14; // rbx
  __int64 v15; // rax
  char *v16; // rdi
  unsigned int v17; // ebx
  int v19; // [rsp+30h] [rbp-98h] BYREF
  char v20[4]; // [rsp+34h] [rbp-94h] BYREF
  char *v21; // [rsp+38h] [rbp-90h] BYREF
  _WORD *v22; // [rsp+40h] [rbp-88h]
  __int64 v23[2]; // [rsp+48h] [rbp-80h] BYREF
  char v24; // [rsp+58h] [rbp-70h] BYREF
  char v25; // [rsp+59h] [rbp-6Fh] BYREF

  v23[1] = -2i64;
  v22 = a7;
  v11 = 0i64;
  v19 = 0;
  v12 = sub_140008F00(a5, v23);
  v13 = sub_140003A10(a1, (__int64)&v24, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = v23[0];
  if ( v23[0] )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v20, 0);
    v15 = *(_QWORD *)(v14 + 8);
    if ( v15 && v15 != -1 )
      *(_QWORD *)(v14 + 8) = v15 - 1;
    if ( !*(_QWORD *)(v14 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v14;
    std::_Lockit::~_Lockit((std::_Lockit *)v20);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v17 = Stoulx(v16, &v21, v13, &v19);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_20;
    goto LABEL_19;
  }
  if ( *(_QWORD *)a4 )
LABEL_19:
    *a6 |= 1u;
LABEL_20:
  if ( v21 == v16 || v19 || v17 > 0xFFFF )
  {
    *a6 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v22 = v17;
  }
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C564: using guessed type __int64 __fastcall Stoulx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002B90) ----------------------------------------------------
_QWORD *__fastcall sub_140002B90(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, int *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // er15
  __int64 v14; // rbx
  __int64 v15; // rax
  char *v16; // rdi
  int v17; // ebx
  int v19; // [rsp+30h] [rbp-98h] BYREF
  char v20[4]; // [rsp+34h] [rbp-94h] BYREF
  char *v21; // [rsp+38h] [rbp-90h] BYREF
  int *v22; // [rsp+40h] [rbp-88h]
  __int64 v23[2]; // [rsp+48h] [rbp-80h] BYREF
  char v24; // [rsp+58h] [rbp-70h] BYREF
  char v25; // [rsp+59h] [rbp-6Fh] BYREF

  v23[1] = -2i64;
  v22 = a7;
  v11 = 0i64;
  v19 = 0;
  v12 = sub_140008F00(a5, v23);
  v13 = sub_140003A10(a1, (__int64)&v24, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = v23[0];
  if ( v23[0] )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v20, 0);
    v15 = *(_QWORD *)(v14 + 8);
    if ( v15 && v15 != -1 )
      *(_QWORD *)(v14 + 8) = v15 - 1;
    if ( !*(_QWORD *)(v14 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v14;
    std::_Lockit::~_Lockit((std::_Lockit *)v20);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  v16 = &v25;
  if ( v24 != 45 )
    v16 = &v24;
  v17 = Stoulx(v16, &v21, v13, &v19);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_20;
    goto LABEL_19;
  }
  if ( *(_QWORD *)a4 )
LABEL_19:
    *a6 |= 1u;
LABEL_20:
  if ( v21 == v16 || v19 )
  {
    *a6 |= 2u;
  }
  else
  {
    if ( v24 == 45 )
      v17 = -v17;
    *v22 = v17;
  }
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C564: using guessed type __int64 __fastcall Stoulx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002D30) ----------------------------------------------------
_QWORD *__fastcall sub_140002D30(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, _DWORD *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // eax
  int v14; // edi
  __int64 v15; // rbx
  __int64 v16; // rax
  int v18; // [rsp+30h] [rbp-98h] BYREF
  char v19[4]; // [rsp+34h] [rbp-94h] BYREF
  __int64 v20; // [rsp+38h] [rbp-90h] BYREF
  __int64 v21[2]; // [rsp+40h] [rbp-88h] BYREF
  char v22[32]; // [rsp+50h] [rbp-78h] BYREF

  v21[1] = -2i64;
  v11 = 0i64;
  v18 = 0;
  v12 = sub_140008F00(a5, &v20);
  v13 = sub_140003A10(a1, (__int64)v22, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = Stolx(v22, v21, v13, &v18);
  v15 = v20;
  if ( v20 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 0);
    v16 = *(_QWORD *)(v15 + 8);
    if ( v16 && v16 != -1 )
      *(_QWORD *)(v15 + 8) = v16 - 1;
    if ( !*(_QWORD *)(v15 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v15;
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( *(_QWORD *)a4 )
LABEL_17:
    *a6 |= 1u;
LABEL_18:
  if ( (char *)v21[0] == v22 || v18 )
    *a6 |= 2u;
  else
    *a7 = v14;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C744: using guessed type __int64 __fastcall Stolx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140002EB0) ----------------------------------------------------
_QWORD *__fastcall sub_140002EB0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, _DWORD *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // eax
  int v14; // edi
  __int64 v15; // rbx
  __int64 v16; // rax
  int v18; // [rsp+30h] [rbp-98h] BYREF
  char v19[4]; // [rsp+34h] [rbp-94h] BYREF
  __int64 v20; // [rsp+38h] [rbp-90h] BYREF
  __int64 v21[2]; // [rsp+40h] [rbp-88h] BYREF
  char v22[32]; // [rsp+50h] [rbp-78h] BYREF

  v21[1] = -2i64;
  v11 = 0i64;
  v18 = 0;
  v12 = sub_140008F00(a5, &v20);
  v13 = sub_140003A10(a1, (__int64)v22, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = Stoulx(v22, v21, v13, &v18);
  v15 = v20;
  if ( v20 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 0);
    v16 = *(_QWORD *)(v15 + 8);
    if ( v16 && v16 != -1 )
      *(_QWORD *)(v15 + 8) = v16 - 1;
    if ( !*(_QWORD *)(v15 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v15;
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( *(_QWORD *)a4 )
LABEL_17:
    *a6 |= 1u;
LABEL_18:
  if ( (char *)v21[0] == v22 || v18 )
    *a6 |= 2u;
  else
    *a7 = v14;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C564: using guessed type __int64 __fastcall Stoulx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003030) ----------------------------------------------------
_QWORD *__fastcall sub_140003030(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // eax
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rax
  int v18; // [rsp+30h] [rbp-98h] BYREF
  char v19[4]; // [rsp+34h] [rbp-94h] BYREF
  __int64 v20; // [rsp+38h] [rbp-90h] BYREF
  __int64 v21[2]; // [rsp+40h] [rbp-88h] BYREF
  char v22[32]; // [rsp+50h] [rbp-78h] BYREF

  v21[1] = -2i64;
  v11 = 0i64;
  v18 = 0;
  v12 = sub_140008F00(a5, &v20);
  v13 = sub_140003A10(a1, (__int64)v22, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = Stollx(v22, v21, v13, &v18);
  v15 = v20;
  if ( v20 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 0);
    v16 = *(_QWORD *)(v15 + 8);
    if ( v16 && v16 != -1 )
      *(_QWORD *)(v15 + 8) = v16 - 1;
    if ( !*(_QWORD *)(v15 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v15;
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( *(_QWORD *)a4 )
LABEL_17:
    *a6 |= 1u;
LABEL_18:
  if ( (char *)v21[0] == v22 || v18 )
    *a6 |= 2u;
  else
    *a7 = v14;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C824: using guessed type __int64 __fastcall Stollx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400031B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400031B0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // rbp
  __int64 *v12; // r11
  unsigned int v13; // eax
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rax
  int v18; // [rsp+30h] [rbp-98h] BYREF
  char v19[4]; // [rsp+34h] [rbp-94h] BYREF
  __int64 v20; // [rsp+38h] [rbp-90h] BYREF
  __int64 v21[2]; // [rsp+40h] [rbp-88h] BYREF
  char v22[32]; // [rsp+50h] [rbp-78h] BYREF

  v21[1] = -2i64;
  v11 = 0i64;
  v18 = 0;
  v12 = sub_140008F00(a5, &v20);
  v13 = sub_140003A10(a1, (__int64)v22, a3, a4, *(_DWORD *)(a5 + 24), v12);
  v14 = Stoullx(v22, v21, v13, &v18);
  v15 = v20;
  if ( v20 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 0);
    v16 = *(_QWORD *)(v15 + 8);
    if ( v16 && v16 != -1 )
      *(_QWORD *)(v15 + 8) = v16 - 1;
    if ( !*(_QWORD *)(v15 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v15;
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( *(_QWORD *)a4 )
LABEL_17:
    *a6 |= 1u;
LABEL_18:
  if ( (char *)v21[0] == v22 || v18 )
    *a6 |= 2u;
  else
    *a7 = v14;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C918: using guessed type __int64 __fastcall Stoullx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003330) ----------------------------------------------------
_QWORD *__fastcall sub_140003330(int a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, float *a7)
{
  unsigned int v10; // eax
  double v11; // xmm0_8
  float v12; // xmm6_4
  _QWORD *result; // rax
  int v14; // [rsp+30h] [rbp-98h] BYREF
  int v15; // [rsp+34h] [rbp-94h] BYREF
  char *v16; // [rsp+38h] [rbp-90h] BYREF
  char v17[64]; // [rsp+40h] [rbp-88h] BYREF

  v14 = 0;
  v15 = 0;
  v10 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(
          a1,
          (unsigned int)v17,
          a3,
          a4,
          a5,
          (__int64)&v15);
  v11 = Stofx(v17, &v16, v10, &v14);
  v12 = *(float *)&v11;
  if ( v15 )
    v12 = ldexp(*(float *)&v11, 4 * v15);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( *(_QWORD *)a4 )
LABEL_11:
    *a6 |= 1u;
LABEL_12:
  if ( v16 == v17 || v14 )
    *a6 |= 2u;
  else
    *a7 = v12;
  result = a2;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return result;
}
// 140004150: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);
// 14002CB04: using guessed type double __fastcall Stofx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003460) ----------------------------------------------------
_QWORD *__fastcall sub_140003460(int a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, double *a7)
{
  double v7; // xmm0_8
  double v11; // xmm6_8
  _QWORD *result; // rax
  int v13; // [rsp+34h] [rbp-94h] BYREF
  char *EndPtr; // [rsp+38h] [rbp-90h] BYREF
  char String[64]; // [rsp+40h] [rbp-88h] BYREF

  v13 = 0;
  std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(a1, (unsigned int)String, a3, a4, a5, (__int64)&v13);
  Stodx(String, &EndPtr);
  v11 = v7;
  if ( v13 )
    v11 = ldexp(v7, 4 * v13);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( *(_QWORD *)a3 )
  {
    if ( !*(_QWORD *)a4 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( !*(_QWORD *)a4 )
LABEL_11:
    *a6 |= 1u;
LABEL_12:
  if ( EndPtr == String )
    *a6 |= 2u;
  else
    *a7 = v11;
  result = a2;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return result;
}
// 14000353F: conditional instruction was optimized away because %var_98.4==0
// 1400034E7: variable 'v7' is possibly undefined
// 140004150: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);

//----- (0000000140003590) ----------------------------------------------------
_QWORD *__fastcall sub_140003590(int a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, double *a7)
{
  double v7; // xmm0_8
  double v11; // xmm6_8
  _QWORD *result; // rax
  int v13; // [rsp+34h] [rbp-94h] BYREF
  char *EndPtr; // [rsp+38h] [rbp-90h] BYREF
  char String[64]; // [rsp+40h] [rbp-88h] BYREF

  v13 = 0;
  std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(a1, (unsigned int)String, a3, a4, a5, (__int64)&v13);
  j__Stodx(String, &EndPtr);
  v11 = v7;
  if ( v13 )
    v11 = ldexp(v7, 4 * v13);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( *(_QWORD *)a3 )
  {
    if ( !*(_QWORD *)a4 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( !*(_QWORD *)a4 )
LABEL_11:
    *a6 |= 1u;
LABEL_12:
  if ( EndPtr == String )
    *a6 |= 2u;
  else
    *a7 = v11;
  result = a2;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return result;
}
// 14000366F: conditional instruction was optimized away because %var_98.4==0
// 140003617: variable 'v7' is possibly undefined
// 140004150: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);

//----- (00000001400036C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400036C0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  void (__fastcall ***v11)(_QWORD, __int64); // r12
  __int64 *v12; // rax
  unsigned int v13; // er14
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rbx
  int v18; // [rsp+30h] [rbp-98h] BYREF
  char v19[4]; // [rsp+34h] [rbp-94h] BYREF
  __int64 v20; // [rsp+38h] [rbp-90h] BYREF
  __int64 v21[2]; // [rsp+40h] [rbp-88h] BYREF
  char v22[32]; // [rsp+50h] [rbp-78h] BYREF

  v21[1] = -2i64;
  v11 = 0i64;
  v18 = 0;
  v12 = sub_140008F00(a5, &v20);
  v13 = sub_140003A10(a1, (__int64)v22, a3, a4, 2048, v12);
  v14 = v20;
  if ( v20 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v19, 0);
    v15 = *(_QWORD *)(v14 + 8);
    if ( v15 && v15 != -1 )
      *(_QWORD *)(v14 + 8) = v15 - 1;
    if ( !*(_QWORD *)(v14 + 8) )
      v11 = (void (__fastcall ***)(_QWORD, __int64))v14;
    std::_Lockit::~_Lockit((std::_Lockit *)v19);
    if ( v11 )
      (**v11)(v11, 1i64);
  }
  v16 = Stoullx(v22, v21, v13, &v18);
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( !*(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( *(_QWORD *)a4 )
LABEL_17:
    *a6 |= 1u;
LABEL_18:
  if ( (char *)v21[0] == v22 || v18 )
    *a6 |= 2u;
  else
    *a7 = v16;
  *a2 = *(_QWORD *)a3;
  a2[1] = *(_QWORD *)(a3 + 8);
  return a2;
}
// 14002C918: using guessed type __int64 __fastcall Stoullx(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140003930) ----------------------------------------------------
_DWORD *__fastcall sub_140003930(__int64 a1, const void *a2, unsigned __int64 a3)
{
  _DWORD *result; // rax
  signed __int64 v6; // rsi
  __int64 v7; // rdi
  bool v8; // zf
  __int64 v9; // rcx

  result = (_DWORD *)(*(_DWORD *)(a1 + 120) & 6);
  if ( (*(_BYTE *)(a1 + 120) & 6) != 6 )
  {
    v6 = 2 * a3;
    v7 = (__int64)sub_140009740(a1 + 124, a3);
    memmove((void *)v7, a2, v6);
    v8 = (*(_BYTE *)(a1 + 120) & 4) == 0;
    *(_QWORD *)(a1 + 112) = v6 + v7;
    if ( v8 )
    {
      **(_QWORD **)(a1 + 32) = v7;
      **(_QWORD **)(a1 + 64) = v7;
      **(_DWORD **)(a1 + 88) = v6 >> 1;
    }
    result = (_DWORD *)*(unsigned int *)(a1 + 120);
    if ( ((unsigned __int8)result & 2) == 0 )
    {
      v9 = v7;
      **(_QWORD **)(a1 + 40) = v7;
      if ( ((unsigned __int8)result & 0x10) != 0 )
        v9 = v6 + v7;
      **(_QWORD **)(a1 + 72) = v9;
      **(_DWORD **)(a1 + 96) = (v7 + v6 - v9) >> 1;
      result = *(_DWORD **)(a1 + 64);
      if ( !*(_QWORD *)result )
      {
        **(_QWORD **)(a1 + 32) = v7;
        **(_QWORD **)(a1 + 64) = 0i64;
        result = *(_DWORD **)(a1 + 88);
        *result = v7 >> 1;
      }
    }
    *(_DWORD *)(a1 + 120) |= 1u;
  }
  return result;
}

//----- (0000000140003A10) ----------------------------------------------------
__int64 __fastcall sub_140003A10(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int16 a5, __int64 *a6)
{
  __int64 v9; // rbx
  const _Cvtvec *v10; // r14
  _BYTE *v11; // rsi
  _BYTE *v12; // r15
  __int16 v13; // bx
  __int16 v14; // bx
  int v15; // eax
  unsigned int v16; // esi
  unsigned __int8 v17; // bl
  __int16 v18; // bx
  unsigned __int16 Byte; // bx
  int v20; // eax
  unsigned __int64 v21; // r13
  __int64 v22; // rbx
  __int64 v23; // rsi
  void **v24; // r14
  __int64 v25; // rcx
  __int16 **v26; // rdx
  __int16 v27; // ax
  __int64 v28; // rcx
  __int16 **v29; // rdx
  __int16 v30; // ax
  __int64 v31; // rcx
  __int16 **v32; // rdx
  __int16 v33; // ax
  int v34; // er11
  void **v35; // rax
  void **v36; // rax
  void **v37; // rax
  __int16 v38; // ax
  unsigned __int64 v39; // rbx
  __int64 v40; // rcx
  void **v41; // rax
  void **v42; // rax
  void **v43; // rax
  __int64 v44; // rcx
  int *v45; // rax
  __int16 **v46; // rcx
  __int16 *v47; // rdx
  __int16 v48; // ax
  void **v49; // rax
  char v50; // al
  void **v51; // rdx
  void *v52; // r9
  unsigned __int64 v53; // r8
  char v54; // cl
  void **v55; // rax
  void **v56; // rax
  char v58[8]; // [rsp+30h] [rbp-99h] BYREF
  char v59; // [rsp+38h] [rbp-91h]
  wchar_t v60[2]; // [rsp+3Ch] [rbp-8Dh] BYREF
  mbstate_t v61; // [rsp+40h] [rbp-89h] BYREF
  __int16 v62; // [rsp+48h] [rbp-81h]
  char v63[12]; // [rsp+4Ch] [rbp-7Dh] BYREF
  _BYTE *v64; // [rsp+58h] [rbp-71h]
  _Cvtvec *v65; // [rsp+60h] [rbp-69h]
  __int64 v66; // [rsp+68h] [rbp-61h]
  void *Block[2]; // [rsp+70h] [rbp-59h] BYREF
  __int64 v68; // [rsp+80h] [rbp-49h]
  unsigned __int64 v69; // [rsp+88h] [rbp-41h]
  void *v70[3]; // [rsp+98h] [rbp-31h] BYREF
  unsigned __int64 v71; // [rsp+B0h] [rbp-19h]

  v66 = -2i64;
  v64 = (_BYTE *)a2;
  v9 = sub_140007200(a6);
  unknown_libname_3(v9, v70);
  if ( v70[2] )
    v62 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 16i64))(v9);
  else
    v62 = 0;
  v58[0] = 48;
  v61._Byte = 0;
  v61._Wchar = 0;
  v10 = (const _Cvtvec *)(a1 + 16);
  v65 = (_Cvtvec *)(a1 + 16);
  *(_QWORD *)&v63[4] = 1i64;
  Mbrtowc(&v61._Byte, v58, 1ui64, &v61, (const _Cvtvec *)(a1 + 16));
  v11 = v64;
  v12 = v64;
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( *(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_21;
  }
  else if ( !*(_QWORD *)a4 )
  {
    goto LABEL_21;
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  v13 = *(_WORD *)(a3 + 10);
  v58[0] = 43;
  v60[0] = 0;
  v61._Wchar = 0;
  Mbrtowc(v60, v58, 1ui64, &v61, v10);
  if ( v13 == v60[0] )
  {
    *v11 = 43;
LABEL_20:
    v12 = v11 + 1;
    sub_140006FE0((__int64 *)a3);
    goto LABEL_21;
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  v14 = *(_WORD *)(a3 + 10);
  v58[0] = 45;
  v60[0] = 0;
  v61._Wchar = 0;
  Mbrtowc(v60, v58, 1ui64, &v61, v10);
  if ( v14 == v60[0] )
  {
    *v11 = 45;
    goto LABEL_20;
  }
LABEL_21:
  v15 = a5 & 0xE00;
  if ( v15 == 1024 )
  {
    v16 = 8;
  }
  else if ( v15 == 2048 )
  {
    v16 = 16;
  }
  else
  {
    v16 = v15 != 0 ? 0xA : 0;
  }
  v61._Wchar = v16;
  v17 = 0;
  v59 = 0;
  LOBYTE(v60[0]) = 0;
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( !*(_BYTE *)(a4 + 8) )
    sub_140007050((__int64 *)a4);
  if ( *(_QWORD *)a3 )
  {
    if ( *(_QWORD *)a4 )
      goto LABEL_48;
  }
  else if ( !*(_QWORD *)a4 )
  {
    goto LABEL_48;
  }
  if ( !*(_BYTE *)(a3 + 8) )
    sub_140007050((__int64 *)a3);
  if ( *(_WORD *)(a3 + 10) != v61._Byte )
  {
LABEL_48:
    if ( !v16 )
      goto LABEL_53;
    goto LABEL_49;
  }
  v17 = 1;
  v59 = 1;
  sub_140006FE0((__int64 *)a3);
  if ( sub_140007740(a3, a4) )
  {
    if ( !*(_BYTE *)(a3 + 8) )
      sub_140007050((__int64 *)a3);
    v18 = *(_WORD *)(a3 + 10);
    v58[0] = 120;
    v61._Byte = 0;
    *(_DWORD *)v63 = 0;
    Mbrtowc(&v61._Byte, v58, 1ui64, (mbstate_t *)v63, v10);
    if ( v18 == v61._Byte
      || (v58[0] = 88,
          v61._Byte = 0,
          *(_DWORD *)v63 = 0,
          Mbrtowc(&v61._Byte, v58, 1ui64, (mbstate_t *)v63, v10),
          Byte = v61._Byte,
          (unsigned __int16)sub_140006CE0(a3) == Byte) )
    {
      if ( !v16 || v16 == 16 )
      {
        v16 = 16;
        v61._Wchar = 16;
        v17 = 0;
        v59 = 0;
        sub_140006FE0((__int64 *)a3);
LABEL_50:
        v20 = 22;
        if ( v16 == 8 )
          v20 = 8;
        *(_DWORD *)&v61._Byte = v20;
        goto LABEL_54;
      }
    }
    v17 = 1;
  }
  if ( !v16 )
  {
    v16 = 8;
    v61._Wchar = 8;
    goto LABEL_50;
  }
LABEL_49:
  if ( v16 != 10 )
    goto LABEL_50;
LABEL_53:
  *(_DWORD *)&v61._Byte = 10;
LABEL_54:
  v21 = 15i64;
  v69 = 15i64;
  LOWORD(Block[0]) = v17;
  v22 = 1i64;
  v68 = 1i64;
  v23 = 0i64;
  v24 = (void **)Block[0];
  while ( 1 )
  {
    if ( !*(_BYTE *)(a3 + 8) )
    {
      v25 = *(_QWORD *)a3;
      if ( !*(_QWORD *)a3
        || ((v26 = *(__int16 ***)(v25 + 64), !*v26) || **(int **)(v25 + 88) <= 0 ? (v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 48i64))(v25)) : (v27 = **v26),
            v27 == -1) )
      {
        *(_QWORD *)a3 = 0i64;
      }
      else
      {
        *(_WORD *)(a3 + 10) = v27;
      }
      *(_BYTE *)(a3 + 8) = 1;
    }
    if ( !*(_BYTE *)(a4 + 8) )
    {
      v28 = *(_QWORD *)a4;
      if ( !*(_QWORD *)a4
        || ((v29 = *(__int16 ***)(v28 + 64), !*v29) || **(int **)(v28 + 88) <= 0 ? (v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 48i64))(v28)) : (v30 = **v29),
            v30 == -1) )
      {
        *(_QWORD *)a4 = 0i64;
      }
      else
      {
        *(_WORD *)(a4 + 10) = v30;
      }
      *(_BYTE *)(a4 + 8) = 1;
    }
    v31 = *(_QWORD *)a3;
    if ( *(_QWORD *)a3 )
    {
      if ( *(_QWORD *)a4 )
        goto LABEL_135;
    }
    else if ( !*(_QWORD *)a4 )
    {
      goto LABEL_135;
    }
    if ( !*(_BYTE *)(a3 + 8) )
    {
      if ( !v31
        || ((v32 = *(__int16 ***)(v31 + 64), !*v32) || **(int **)(v31 + 88) <= 0 ? (v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 48i64))(v31)) : (v33 = **v32),
            v33 == -1) )
      {
        *(_QWORD *)a3 = 0i64;
      }
      else
      {
        *(_WORD *)(a3 + 10) = v33;
      }
      *(_BYTE *)(a3 + 8) = 1;
    }
    v58[0] = 0;
    *(_DWORD *)v63 = 0;
    Wcrtomb(v58, *(_WORD *)(a3 + 10), (mbstate_t *)v63, v65);
    v34 = v58[0];
    *v12 = v58[0];
    if ( !memchr("0123456789abcdefABCDEF", v34, *(int *)&v61._Byte) )
      break;
    if ( (LOBYTE(v60[0]) || *v12 != 48) && v12 < v64 + 31 )
    {
      ++v12;
      LOBYTE(v60[0]) = 1;
    }
    v59 = 1;
    v35 = Block;
    if ( v21 >= 0x10 )
      v35 = v24;
    if ( *((_BYTE *)v35 + v23) != 127 )
    {
      v36 = Block;
      if ( v21 >= 0x10 )
        v36 = v24;
      ++*((_BYTE *)v36 + v23);
      v21 = v69;
      v22 = v68;
      *(_QWORD *)&v63[4] = v68;
      v24 = (void **)Block[0];
    }
LABEL_125:
    v44 = *(_QWORD *)a3;
    if ( !*(_QWORD *)a3
      || (!**(_QWORD **)(v44 + 64) || (v45 = *(int **)(v44 + 88), *v45 <= 0) ? (v48 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v44 + 56i64))(v44)) : (--*v45, v46 = *(__int16 ***)(v44 + 64), v47 = *v46, ++*v46, v48 = *v47),
          v48 == -1) )
    {
      *(_QWORD *)a3 = 0i64;
      *(_BYTE *)(a3 + 8) = 1;
    }
    else
    {
      *(_BYTE *)(a3 + 8) = 0;
    }
  }
  v37 = Block;
  if ( v21 >= 0x10 )
    v37 = v24;
  if ( *((_BYTE *)v37 + v23) )
  {
    v38 = v62;
    if ( v62 )
    {
      if ( !*(_BYTE *)(a3 + 8) )
      {
        sub_140007050((__int64 *)a3);
        v38 = v62;
      }
      if ( *(_WORD *)(a3 + 10) == v38 )
      {
        if ( v22 == -1 || v22 == -2 )
          sub_14002B5F8("string too long");
        v39 = v22 + 1;
        if ( v39 == -1i64 )
          sub_14002B5F8("string too long");
        if ( v21 >= v39 )
        {
          if ( !v39 )
          {
            v68 = 0i64;
            v41 = Block;
            if ( v21 >= 0x10 )
              v41 = v24;
            *(_BYTE *)v41 = 0;
            goto LABEL_115;
          }
          v40 = *(_QWORD *)&v63[4];
        }
        else
        {
          sub_140007EF0(Block, v39, *(size_t *)&v63[4]);
          v21 = v69;
          v40 = v68;
          *(_QWORD *)&v63[4] = v68;
          v24 = (void **)Block[0];
        }
        if ( !v39 )
        {
          v22 = *(_QWORD *)&v63[4];
          goto LABEL_124;
        }
        v42 = Block;
        if ( v21 >= 0x10 )
          v42 = v24;
        *((_BYTE *)v42 + v40) = 0;
        v68 = v39;
        v43 = Block;
        if ( v69 >= 0x10 )
          v43 = (void **)Block[0];
        *((_BYTE *)v43 + v39) = 0;
LABEL_115:
        v21 = v69;
        v22 = v68;
        *(_QWORD *)&v63[4] = v68;
        v24 = (void **)Block[0];
LABEL_124:
        ++v23;
        goto LABEL_125;
      }
    }
  }
LABEL_135:
  if ( !v23 )
    goto LABEL_141;
  v49 = Block;
  if ( v21 >= 0x10 )
    v49 = v24;
  if ( *((char *)v49 + v23) <= 0 )
  {
    v50 = 0;
  }
  else
  {
    ++v23;
LABEL_141:
    v50 = v59;
  }
  v51 = v70;
  v52 = v70[0];
  v53 = v71;
  if ( v71 >= 0x10 )
    v51 = (void **)v70[0];
  if ( v50 )
  {
    while ( v23 )
    {
      v54 = *(_BYTE *)v51;
      if ( *(_BYTE *)v51 == 127 )
        break;
      if ( --v23 )
      {
        v55 = Block;
        if ( v21 >= 0x10 )
          v55 = v24;
        if ( v54 != *((_BYTE *)v55 + v23) )
          goto LABEL_159;
      }
      if ( !v23 )
      {
        v56 = Block;
        if ( v21 >= 0x10 )
          v56 = v24;
        if ( v54 < *(char *)v56 )
          goto LABEL_159;
      }
      if ( *((char *)v51 + 1) > 0 )
        v51 = (void **)((char *)v51 + 1);
    }
    if ( !LOBYTE(v60[0]) )
      *v12++ = 48;
  }
  else
  {
LABEL_159:
    v12 = v64;
  }
  *v12 = 0;
  if ( v21 >= 0x10 )
  {
    j_free(v24);
    v53 = v71;
    v52 = v70[0];
  }
  if ( v53 >= 0x10 )
    j_free(v52);
  return v61._Wchar;
}
// 140006D10: using guessed type __int64 __fastcall unknown_libname_3(_QWORD, _QWORD);
// 140003A10: using guessed type char var_E0[8];

//----- (0000000140005450) ----------------------------------------------------
__int64 __fastcall sub_140005450(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

//----- (0000000140005460) ----------------------------------------------------
__int64 __fastcall sub_140005460(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

//----- (0000000140005470) ----------------------------------------------------
_QWORD *__fastcall sub_140005470(__int64 a1, _QWORD *a2)
{
  void *v3; // rdx

  v3 = *(void **)(a1 + 16);
  a2[3] = 15i64;
  a2[2] = 0i64;
  *(_BYTE *)a2 = 0;
  sub_140008100(a2, v3, strlen((const char *)v3));
  return a2;
}

//----- (00000001400054C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400054C0(__int64 a1, _QWORD *a2)
{
  _WORD *v3; // rdx
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf

  v3 = *(_WORD **)(a1 + 32);
  v4 = -1i64;
  a2[3] = 7i64;
  a2[2] = 0i64;
  v5 = v3;
  *(_WORD *)a2 = 0;
  do
  {
    if ( !v4 )
      break;
    v6 = *v5++ == 0;
    --v4;
  }
  while ( !v6 );
  sub_1400099E0(a2, v3, -v4 - 2);
  return a2;
}

//----- (0000000140005510) ----------------------------------------------------
_QWORD *__fastcall sub_140005510(__int64 a1, _QWORD *a2)
{
  _WORD *v3; // rdx
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf

  v3 = *(_WORD **)(a1 + 40);
  v4 = -1i64;
  a2[3] = 7i64;
  a2[2] = 0i64;
  v5 = v3;
  *(_WORD *)a2 = 0;
  do
  {
    if ( !v4 )
      break;
    v6 = *v5++ == 0;
    --v4;
  }
  while ( !v6 );
  sub_1400099E0(a2, v3, -v4 - 2);
  return a2;
}

//----- (0000000140005560) ----------------------------------------------------
void *__fastcall sub_140005560(void *Block, char a2)
{
  *(_QWORD *)Block = &std::numpunct<wchar_t>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 4));
  j_j_free(*((void **)Block + 5));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E5288: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (00000001400055C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400055C0(_QWORD *a1, size_t a2, char a3)
{
  size_t v4; // r8
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rax
  __int64 v9; // rcx
  _QWORD *v10; // rax
  bool v11; // cf
  _QWORD *v12; // rax

  v4 = a1[2];
  if ( -1i64 - v4 <= a2 )
    sub_14002B5F8("string too long");
  if ( a2 )
  {
    v7 = v4 + a2;
    if ( v4 + a2 == -1i64 )
      sub_14002B5F8("string too long");
    v8 = a1[3];
    if ( v8 >= v7 )
    {
      if ( !v7 )
      {
        a1[2] = 0i64;
        if ( v8 < 0x10 )
          *(_BYTE *)a1 = 0;
        else
          *(_BYTE *)*a1 = 0;
        return a1;
      }
    }
    else
    {
      sub_140007EF0(a1, v4 + a2, v4);
      if ( !v7 )
        return a1;
    }
    v9 = a1[2];
    if ( a2 == 1 )
    {
      if ( a1[3] < 0x10ui64 )
        *((_BYTE *)a1 + v9) = a3;
      else
        *(_BYTE *)(*a1 + v9) = a3;
    }
    else
    {
      if ( a1[3] < 0x10ui64 )
        v10 = a1;
      else
        v10 = (_QWORD *)*a1;
      memset((char *)v10 + v9, a3, a2);
    }
    v11 = a1[3] < 0x10ui64;
    a1[2] = v7;
    if ( v11 )
      v12 = a1;
    else
      v12 = (_QWORD *)*a1;
    *((_BYTE *)v12 + v7) = 0;
  }
  return a1;
}

//----- (00000001400056C0) ----------------------------------------------------
__int64 __fastcall sub_1400056C0(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rax
  void (__fastcall ***v6)(_QWORD, __int64); // rbx
  char v8; // [rsp+48h] [rbp+10h] BYREF
  __int64 v9; // [rsp+50h] [rbp+18h] BYREF

  v1 = sub_140008F00(a1, &v9);
  v3 = sub_140008DB0(v1);
  v4 = v9;
  if ( v9 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v8, 0);
    v5 = *(_QWORD *)(v4 + 8);
    if ( v5 && v5 != -1 )
      *(_QWORD *)(v4 + 8) = v5 - 1;
    v6 = 0i64;
    if ( !*(_QWORD *)(v4 + 8) )
      v6 = (void (__fastcall ***)(_QWORD, __int64))v4;
    std::_Lockit::~_Lockit((std::_Lockit *)&v8);
    if ( v6 )
      (**v6)(v6, 1i64);
  }
  LOBYTE(v2) = 32;
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 80i64))(v3, v2);
}
// 140005749: variable 'v2' is possibly undefined

//----- (0000000140005760) ----------------------------------------------------
void *__fastcall sub_140005760(void *Src, unsigned __int64 a2, __int16 a3)
{
  char *v4; // r8
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rcx
  __int64 v9; // rcx
  _WORD *v10; // rax
  _WORD *v11; // rdi
  unsigned __int64 i; // rcx
  bool v13; // cf
  _WORD *v14; // rcx

  v4 = (char *)*((_QWORD *)Src + 2);
  if ( -1 - (__int64)v4 <= a2 )
    sub_14002B5F8("string too long");
  if ( a2 )
  {
    v7 = (unsigned __int64)&v4[a2];
    if ( (unsigned __int64)&v4[a2] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v8 = *((_QWORD *)Src + 3);
    if ( v8 >= v7 )
    {
      if ( !v7 )
      {
        *((_QWORD *)Src + 2) = 0i64;
        if ( v8 < 8 )
          *(_WORD *)Src = 0;
        else
          **(_WORD **)Src = 0;
        return Src;
      }
    }
    else
    {
      sub_1400097B0(Src, (unsigned __int64)&v4[a2], v4);
      if ( !v7 )
        return Src;
    }
    v9 = *((_QWORD *)Src + 2);
    if ( a2 == 1 )
    {
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        *((_WORD *)Src + v9) = a3;
      else
        *(_WORD *)(*(_QWORD *)Src + 2 * v9) = a3;
    }
    else
    {
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v10 = Src;
      else
        v10 = *(_WORD **)Src;
      v11 = &v10[v9];
      for ( i = a2; i; --i )
        *v11++ = a3;
    }
    v13 = *((_QWORD *)Src + 3) < 8ui64;
    *((_QWORD *)Src + 2) = v7;
    if ( v13 )
      v14 = Src;
    else
      v14 = *(_WORD **)Src;
    v14[v7] = 0;
  }
  return Src;
}

//----- (0000000140006CE0) ----------------------------------------------------
__int64 __fastcall sub_140006CE0(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 8) )
    return *(unsigned __int16 *)(a1 + 10);
  sub_140007050((__int64 *)a1);
  return *(unsigned __int16 *)(a1 + 10);
}

//----- (0000000140006D60) ----------------------------------------------------
void *__fastcall sub_140006D60(void *a1, size_t Size, char a3)
{
  size_t v6; // rax
  _BYTE *v8; // rcx
  bool v9; // cf
  _BYTE *v10; // rax

  if ( Size == -1i64 )
    sub_14002B5F8("string too long");
  v6 = *((_QWORD *)a1 + 3);
  if ( v6 >= Size )
  {
    if ( !Size )
    {
      *((_QWORD *)a1 + 2) = 0i64;
      if ( v6 < 0x10 )
        *(_BYTE *)a1 = 0;
      else
        **(_BYTE **)a1 = 0;
      return a1;
    }
  }
  else
  {
    sub_140007EF0(a1, Size, *((_QWORD *)a1 + 2));
  }
  if ( Size )
  {
    if ( Size == 1 )
    {
      if ( *((_QWORD *)a1 + 3) < 0x10ui64 )
        *(_BYTE *)a1 = a3;
      else
        **(_BYTE **)a1 = a3;
    }
    else
    {
      if ( *((_QWORD *)a1 + 3) < 0x10ui64 )
        v8 = a1;
      else
        v8 = *(_BYTE **)a1;
      memset(v8, a3, Size);
    }
    v9 = *((_QWORD *)a1 + 3) < 0x10ui64;
    *((_QWORD *)a1 + 2) = Size;
    if ( v9 )
      v10 = a1;
    else
      v10 = *(_BYTE **)a1;
    v10[Size] = 0;
  }
  return a1;
}
// 140006D90: conditional instruction was optimized away because rdx.8!=FFFFFFFFFFFFFFFF

//----- (0000000140006E60) ----------------------------------------------------
void *__fastcall sub_140006E60(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rbp
  _QWORD *v7; // rsi
  unsigned __int64 v9; // rax
  char *v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rcx
  _WORD *v13; // rcx
  bool v14; // cf
  _WORD *v15; // rcx

  v4 = a2[2];
  v5 = a4;
  v7 = a2;
  if ( v4 < a3 )
    sub_14002B630("invalid string position");
  v9 = v4 - a3;
  v10 = (char *)*((_QWORD *)Src + 2);
  if ( v9 < a4 )
    v5 = v9;
  if ( -1 - (__int64)v10 <= v5 )
    sub_14002B5F8("string too long");
  if ( v5 )
  {
    v11 = (unsigned __int64)&v10[v5];
    if ( (unsigned __int64)&v10[v5] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v12 = *((_QWORD *)Src + 3);
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        *((_QWORD *)Src + 2) = 0i64;
        if ( v12 < 8 )
          *(_WORD *)Src = 0;
        else
          **(_WORD **)Src = 0;
        return Src;
      }
    }
    else
    {
      sub_1400097B0(Src, (unsigned __int64)&v10[v5], v10);
      if ( !v11 )
        return Src;
    }
    if ( v7[3] >= 8ui64 )
      v7 = (_QWORD *)*v7;
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v13 = Src;
    else
      v13 = *(_WORD **)Src;
    memmove(&v13[*((_QWORD *)Src + 2)], (char *)v7 + 2 * a3, 2 * v5);
    v14 = *((_QWORD *)Src + 3) < 8ui64;
    *((_QWORD *)Src + 2) = v11;
    if ( v14 )
      v15 = Src;
    else
      v15 = *(_WORD **)Src;
    v15[v11] = 0;
  }
  return Src;
}

//----- (0000000140006F90) ----------------------------------------------------
void __fastcall sub_140006F90(_QWORD *a1, __int64 a2, __int64 a3, __int16 a4)
{
  _WORD *v4; // rdi
  __int64 i; // rcx

  if ( a3 == 1 )
  {
    if ( a1[3] >= 8ui64 )
      a1 = (_QWORD *)*a1;
    *((_WORD *)a1 + a2) = a4;
  }
  else
  {
    if ( a1[3] >= 8ui64 )
      a1 = (_QWORD *)*a1;
    v4 = (_WORD *)a1 + a2;
    if ( a3 )
    {
      for ( i = a3; i; --i )
        *v4++ = a4;
    }
  }
}

//----- (0000000140006FE0) ----------------------------------------------------
void __fastcall sub_140006FE0(__int64 *a1)
{
  __int64 v2; // rcx
  int *v3; // rax
  __int16 **v4; // rcx
  __int16 *v5; // rdx
  __int16 v6; // ax

  v2 = *a1;
  if ( !v2
    || (!**(_QWORD **)(v2 + 64) || (v3 = *(int **)(v2 + 88), *v3 <= 0) ? (v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 56i64))(v2)) : (--*v3, v4 = *(__int16 ***)(v2 + 64), v5 = *v4, ++*v4, v6 = *v5),
        v6 == -1) )
  {
    *a1 = 0i64;
    *((_BYTE *)a1 + 8) = 1;
  }
  else
  {
    *((_BYTE *)a1 + 8) = 0;
  }
}

//----- (0000000140007050) ----------------------------------------------------
__int64 __fastcall sub_140007050(__int64 *a1)
{
  __int64 v2; // rcx
  _QWORD *v3; // rdx
  __int64 result; // rax

  v2 = *a1;
  if ( !v2
    || ((v3 = *(_QWORD **)(v2 + 64), !*v3) || **(int **)(v2 + 88) <= 0 ? (result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2)) : (result = *(unsigned __int16 *)*v3),
        (_WORD)result == 0xFFFF) )
  {
    result = *((unsigned __int16 *)a1 + 5);
    *a1 = 0i64;
    *((_BYTE *)a1 + 8) = 1;
  }
  else
  {
    *((_WORD *)a1 + 5) = result;
    *((_BYTE *)a1 + 8) = 1;
  }
  return result;
}

//----- (00000001400070B0) ----------------------------------------------------
__int64 __fastcall sub_1400070B0(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012E120;
  v12 = qword_14012E120;
  v3 = qword_140130F40;
  if ( !qword_140130F40 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F40 == v3 )
      qword_140130F40 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F40;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v5 = v2;
  }
  else
  {
    if ( sub_1400077B0(&v12, a1) == -1 )
    {
      sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v5 = v12;
    qword_14012E120 = v12;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v7 = *(_QWORD *)(v5 + 8);
    if ( v7 != -1 )
      *(_QWORD *)(v5 + 8) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    unknown_libname_19(v5);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E120: using guessed type __int64 qword_14012E120;

//----- (0000000140007200) ----------------------------------------------------
__int64 __fastcall sub_140007200(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012E128;
  v12 = qword_14012E128;
  v3 = qword_140130F38;
  if ( !qword_140130F38 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F38 == v3 )
      qword_140130F38 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F38;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v5 = v2;
  }
  else
  {
    if ( sub_1400078D0(&v12, a1) == -1 )
    {
      sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v5 = v12;
    qword_14012E128 = v12;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v7 = *(_QWORD *)(v5 + 8);
    if ( v7 != -1 )
      *(_QWORD *)(v5 + 8) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    unknown_libname_19(v5);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 1400078D0: using guessed type __int64 __fastcall sub_1400078D0(_QWORD, _QWORD);
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E128: using guessed type __int64 qword_14012E128;

//----- (0000000140007350) ----------------------------------------------------
__int64 __fastcall sub_140007350(__int64 *a1, __int64 *a2, size_t a3, __int16 *a4)
{
  size_t v5; // r9
  __int64 v8; // r10
  __int16 v9; // ax
  __int64 result; // rax
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // r15
  char v13; // r13
  __int64 v14; // rbx
  size_t v15; // r12
  __int16 i; // ax
  void **v17; // rax
  void **v18; // rax
  __int16 v19; // ax
  __int64 v20; // rcx
  __int16 **v21; // rdx
  __int16 v22; // ax
  __int64 v23; // rcx
  __int16 **v24; // rdx
  __int16 v25; // ax
  __int64 v26; // rcx
  __int16 **v27; // rdx
  __int16 v28; // ax
  void **v29; // rdx
  char v30; // cl
  __int64 v31; // rcx
  __int16 **v32; // rdx
  __int16 v33; // ax
  __int64 v34; // rcx
  __int16 **v35; // rdx
  __int16 v36; // ax
  __int64 v37; // rcx
  int *v38; // rax
  __int16 **v39; // rcx
  __int16 *v40; // rdx
  __int16 v41; // ax
  unsigned int v42; // [rsp+20h] [rbp-88h]
  size_t v43; // [rsp+28h] [rbp-80h]
  void *Block[3]; // [rsp+38h] [rbp-70h] BYREF
  unsigned __int64 v45; // [rsp+50h] [rbp-58h]

  v5 = a3;
  v43 = a3;
  v8 = 0i64;
  if ( *a4 )
  {
    v9 = *a4;
    do
    {
      if ( v9 == *a4 )
        ++v5;
      v9 = a4[++v8];
    }
    while ( v9 );
    v43 = v5;
  }
  v45 = 15i64;
  Block[2] = 0i64;
  LOBYTE(Block[0]) = 0;
  sub_140006D60(Block, v5, 0);
  result = 4294967294i64;
  v11 = 1i64;
  v12 = v45;
  while ( 2 )
  {
    v42 = result;
    v13 = 0;
    v14 = 0i64;
    v15 = 0i64;
    if ( !v43 )
      break;
    do
    {
      for ( i = a4[v14]; i; i = a4[v14] )
      {
        if ( i == *a4 )
          break;
        ++v14;
      }
      v17 = Block;
      if ( v12 >= 0x10 )
        v17 = (void **)Block[0];
      if ( !*((_BYTE *)v17 + v15) )
      {
        v14 += v11;
        v19 = a4[v14];
        if ( v19 == *a4 || !v19 )
        {
          v29 = Block;
          if ( v12 >= 0x10 )
            v29 = (void **)Block[0];
          v30 = 127;
          if ( v11 < 0x7F )
            v30 = v11;
          result = (unsigned int)v15;
          v42 = v15;
          goto LABEL_66;
        }
        if ( !*((_BYTE *)a1 + 8) )
        {
          v20 = *a1;
          if ( !*a1
            || ((v21 = *(__int16 ***)(v20 + 64), !*v21) || **(int **)(v20 + 88) <= 0 ? (v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 48i64))(v20)) : (v22 = **v21),
                v22 == -1) )
          {
            *a1 = 0i64;
          }
          else
          {
            *((_WORD *)a1 + 5) = v22;
          }
          *((_BYTE *)a1 + 8) = 1;
        }
        if ( !*((_BYTE *)a2 + 8) )
        {
          v23 = *a2;
          if ( !*a2
            || ((v24 = *(__int16 ***)(v23 + 64), !*v24) || **(int **)(v23 + 88) <= 0 ? (v25 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v23 + 48i64))(v23)) : (v25 = **v24),
                v25 == -1) )
          {
            *a2 = 0i64;
          }
          else
          {
            *((_WORD *)a2 + 5) = v25;
          }
          *((_BYTE *)a2 + 8) = 1;
        }
        v26 = *a1;
        if ( *a1 )
        {
          if ( !*a2 )
            goto LABEL_44;
        }
        else if ( *a2 )
        {
LABEL_44:
          if ( !*((_BYTE *)a1 + 8) )
          {
            if ( !v26
              || ((v27 = *(__int16 ***)(v26 + 64), !*v27) || **(int **)(v26 + 88) <= 0 ? (v28 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v26 + 48i64))(v26)) : (v28 = **v27),
                  v28 == -1) )
            {
              *a1 = 0i64;
            }
            else
            {
              *((_WORD *)a1 + 5) = v28;
            }
            *((_BYTE *)a1 + 8) = 1;
          }
          if ( a4[v14] == *((_WORD *)a1 + 5) )
          {
            v13 = 1;
            result = v42;
            goto LABEL_67;
          }
        }
        v29 = Block;
        if ( v12 >= 0x10 )
          v29 = (void **)Block[0];
        v30 = 127;
        if ( v11 < 0x7F )
          v30 = v11;
        result = v42;
LABEL_66:
        *((_BYTE *)v29 + v15) = v30;
        v12 = v45;
        goto LABEL_67;
      }
      v18 = Block;
      if ( v12 >= 0x10 )
        v18 = (void **)Block[0];
      v14 += *((char *)v18 + v15);
      result = v42;
LABEL_67:
      ++v15;
    }
    while ( v15 < v43 );
    if ( v13 )
    {
      if ( !*((_BYTE *)a1 + 8) )
      {
        v31 = *a1;
        if ( !*a1
          || ((v32 = *(__int16 ***)(v31 + 64), !*v32) || **(int **)(v31 + 88) <= 0 ? (v33 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 48i64))(v31)) : (v33 = **v32),
              v33 == -1) )
        {
          *a1 = 0i64;
        }
        else
        {
          *((_WORD *)a1 + 5) = v33;
        }
        *((_BYTE *)a1 + 8) = 1;
      }
      if ( !*((_BYTE *)a2 + 8) )
      {
        v34 = *a2;
        if ( !*a2
          || ((v35 = *(__int16 ***)(v34 + 64), !*v35) || **(int **)(v34 + 88) <= 0 ? (v36 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 48i64))(v34)) : (v36 = **v35),
              v36 == -1) )
        {
          *a2 = 0i64;
        }
        else
        {
          *((_WORD *)a2 + 5) = v36;
        }
        *((_BYTE *)a2 + 8) = 1;
      }
      v37 = *a1;
      if ( *a1 )
      {
        if ( *a2 )
          goto LABEL_102;
LABEL_93:
        ++v11;
        if ( !v37
          || (!**(_QWORD **)(v37 + 64) || (v38 = *(int **)(v37 + 88), *v38 <= 0) ? (v41 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 56i64))(v37)) : (--*v38, v39 = *(__int16 ***)(v37 + 64), v40 = *v39, ++*v39, v41 = *v40),
              v41 == -1) )
        {
          *a1 = 0i64;
          *((_BYTE *)a1 + 8) = 1;
        }
        else
        {
          *((_BYTE *)a1 + 8) = 0;
        }
        result = 0xFFFFFFFFi64;
        continue;
      }
      if ( *a2 )
        goto LABEL_93;
LABEL_102:
      result = v42;
    }
    break;
  }
  if ( v12 >= 0x10 )
  {
    j_free(Block[0]);
    return v42;
  }
  return result;
}

//----- (0000000140007740) ----------------------------------------------------
char __fastcall sub_140007740(__int64 a1, __int64 a2)
{
  if ( !*(_BYTE *)(a1 + 8) )
    sub_140007050((__int64 *)a1);
  if ( !*(_BYTE *)(a2 + 8) )
    sub_140007050((__int64 *)a2);
  if ( *(_QWORD *)a1 )
  {
    if ( !*(_QWORD *)a2 )
      return 1;
  }
  else if ( *(_QWORD *)a2 )
  {
    return 1;
  }
  return 0;
}

//----- (00000001400077B0) ----------------------------------------------------
__int64 __fastcall sub_1400077B0(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 140007830: variable 'v7' is possibly undefined
// 1400E4D38: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140007870) ----------------------------------------------------
char __fastcall sub_140007870(__int64 a1, __int64 a2)
{
  if ( !*(_BYTE *)(a1 + 8) )
    sub_140007050((__int64 *)a1);
  if ( !*(_BYTE *)(a2 + 8) )
    sub_140007050((__int64 *)a2);
  if ( *(_QWORD *)a1 )
  {
    if ( !*(_QWORD *)a2 )
      return 0;
  }
  else if ( *(_QWORD *)a2 )
  {
    return 0;
  }
  return 1;
}

//----- (0000000140007990) ----------------------------------------------------
int __fastcall sub_140007990(__int64 a1, __int64 a2, char a3)
{
  struct lconv *v5; // rax
  _Cvtvec *v6; // rcx
  char **p_decimal_point; // r12
  const char *grouping; // rbx
  size_t v9; // rdi
  _BYTE *v10; // rax
  _Cvtvec *v11; // rcx
  _BYTE *v12; // rdx
  _Cvtvec *v13; // rcx
  _Cvtvec *v14; // rcx
  _Cvtvec *v15; // rcx
  _Cvtvec *v16; // rcx
  int result; // eax
  _Cvtvec *v18; // rcx
  _Cvtvec v19; // [rsp+30h] [rbp-38h] BYREF
  __int64 v20; // [rsp+70h] [rbp+8h] BYREF
  char v21; // [rsp+80h] [rbp+18h] BYREF
  mbstate_t v22; // [rsp+88h] [rbp+20h] BYREF

  v20 = a1;
  *(_QWORD *)&v19._Isclocale = -2i64;
  v5 = localeconv();
  p_decimal_point = &v5->decimal_point;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  grouping = byte_1400F6829;
  if ( !a3 )
    grouping = v5->grouping;
  Getcvt(v6);
  v9 = strlen(grouping) + 1;
  v10 = operator new(v9);
  v12 = v10;
  while ( v9 )
  {
    v11 = (_Cvtvec *)*(unsigned __int8 *)grouping;
    *v12 = (_BYTE)v11;
    --v9;
    ++v12;
    ++grouping;
  }
  *(_QWORD *)(a1 + 16) = v10;
  v22 = (mbstate_t)Getcvt(v11);
  *(_QWORD *)(a1 + 32) = sub_140007BE0("false", 0i64, (const _Cvtvec *)&v22);
  v22 = (mbstate_t)Getcvt(v13);
  *(_QWORD *)(a1 + 40) = sub_140007BE0("true", 0i64, (const _Cvtvec *)&v22);
  *(_QWORD *)&v19._Page = Getcvt(v14);
  v21 = **p_decimal_point;
  LOWORD(v20) = 0;
  v22._Wchar = 0;
  Mbrtowc((wchar_t *)&v20, &v21, 1ui64, &v22, &v19);
  *(_WORD *)(a1 + 24) = v20;
  *(_QWORD *)&v19._Page = Getcvt(v15);
  v21 = *p_decimal_point[1];
  LOWORD(v20) = 0;
  v22._Wchar = 0;
  Mbrtowc((wchar_t *)&v20, &v21, 1ui64, &v22, &v19);
  result = (unsigned __int16)v20;
  *(_WORD *)(a1 + 26) = v20;
  if ( a3 )
  {
    *(_QWORD *)&v19._Page = Getcvt(v16);
    v21 = 46;
    LOWORD(v20) = 0;
    v22._Wchar = 0;
    Mbrtowc((wchar_t *)&v20, &v21, 1ui64, &v22, &v19);
    *(_WORD *)(a1 + 24) = v20;
    *(_QWORD *)&v19._Page = Getcvt(v18);
    v21 = 44;
    LOWORD(v20) = 0;
    v22._Wchar = 0;
    result = Mbrtowc((wchar_t *)&v20, &v21, 1ui64, &v22, &v19);
    *(_WORD *)(a1 + 26) = v20;
  }
  return result;
}
// 1400079DD: variable 'v6' is possibly undefined
// 140007A19: variable 'v11' is possibly undefined
// 140007A40: variable 'v13' is possibly undefined
// 140007A67: variable 'v14' is possibly undefined
// 140007AC0: variable 'v15' is possibly undefined
// 140007B23: variable 'v16' is possibly undefined
// 140007B76: variable 'v18' is possibly undefined
// 140006D30: using guessed type __int64 __fastcall unknown_libname_4(_QWORD);

//----- (0000000140007BE0) ----------------------------------------------------
wchar_t *__fastcall sub_140007BE0(char *a1, __int64 a2, const _Cvtvec *a3)
{
  char *v3; // rbp
  size_t v4; // r13
  __int64 v6; // rdi
  const char *v7; // rsi
  size_t v8; // rbx
  int v9; // eax
  unsigned __int64 v10; // rdi
  size_t v11; // rax
  wchar_t *v12; // rsi
  wchar_t *i; // rbx
  int v14; // eax
  mbstate_t v16; // [rsp+30h] [rbp-48h] BYREF
  wchar_t v17; // [rsp+80h] [rbp+8h] BYREF
  mbstate_t v18; // [rsp+98h] [rbp+20h] BYREF

  v3 = a1;
  v4 = strlen(a1) + 1;
  v18._Wchar = 0;
  v6 = 0i64;
  v7 = v3;
  v8 = v4;
  if ( ~v4 != -1i64 )
  {
    do
    {
      v9 = Mbrtowc(&v17, v7, v8, &v18, a3);
      if ( v9 <= 0 )
        break;
      ++v6;
      v7 += v9;
      v8 -= v9;
    }
    while ( v8 );
  }
  v10 = v6 + 1;
  v11 = 2 * v10;
  if ( !is_mul_ok(v10, 2ui64) )
    v11 = -1i64;
  v16._Wchar = 0;
  v12 = (wchar_t *)operator new(v11);
  for ( i = v12; v10; --v10 )
  {
    v14 = Mbrtowc(i, v3, v4, &v16, a3);
    if ( v14 <= 0 )
      break;
    ++i;
    v3 += v14;
  }
  *i = 0;
  return v12;
}

//----- (0000000140007CE0) ----------------------------------------------------
_QWORD *__fastcall sub_140007CE0(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r8
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r8
  _QWORD *v7; // rax
  unsigned __int64 v8; // r11
  bool v9; // cf

  v4 = a1[2];
  v5 = a1;
  if ( v4 < a2 )
    sub_14002B630("invalid string position");
  v6 = v4 - a2;
  if ( v6 < a3 )
    a3 = v6;
  if ( a3 )
  {
    if ( a1[3] < 0x10ui64 )
    {
      v7 = a1;
    }
    else
    {
      a1 = (_QWORD *)*a1;
      v7 = (_QWORD *)*v5;
    }
    memmove((char *)v7 + a2, (char *)a1 + a2 + a3, v6 - a3);
    v8 = v5[2] - a3;
    v9 = v5[3] < 0x10ui64;
    v5[2] = v8;
    if ( !v9 )
    {
      *(_BYTE *)(*v5 + v8) = 0;
      return v5;
    }
    *((_BYTE *)v5 + v8) = 0;
  }
  return v5;
}

//----- (0000000140007E90) ----------------------------------------------------
void *__fastcall sub_140007E90(__int64 a1, size_t a2)
{
  void *result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v4; // [rsp+58h] [rbp+10h] BYREF

  result = 0i64;
  if ( a2 )
  {
    result = operator new(a2);
    if ( !result )
    {
      v4 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140007EF0) ----------------------------------------------------
void __fastcall sub_140007EF0(void *Src, unsigned __int64 a2, size_t a3)
{
  const void **v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  void *v8; // rsi
  const void *v9; // rdx
  __int64 pExceptionObject[8]; // [rsp+40h] [rbp-40h] BYREF
  char *v11; // [rsp+A0h] [rbp+20h] BYREF

  v4 = (const void **)Src;
  v5 = a2 | 0xF;
  if ( (a2 | 0xF) == -1i64 )
  {
    v5 = a2;
  }
  else
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = v6 >> 1;
    if ( v6 >> 1 > v5 / 3 )
    {
      v5 = -2i64;
      if ( v6 <= -2i64 - v7 )
        v5 = v7 + v6;
    }
  }
  v8 = 0i64;
  if ( v5 != -1i64 )
  {
    v8 = operator new(v5 + 1);
    if ( !v8 )
    {
      v11 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v11);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  if ( a3 )
  {
    if ( (unsigned __int64)v4[3] < 0x10 )
      v9 = v4;
    else
      v9 = *v4;
    memmove(v8, v9, a3);
  }
  if ( (unsigned __int64)v4[3] >= 0x10 )
    j_free((void *)*v4);
  *(_BYTE *)v4 = 0;
  *v4 = v8;
  v4[3] = (const void *)v5;
  v4[2] = (const void *)a3;
  if ( v5 >= 0x10 )
    v4 = (const void **)v8;
  *((_BYTE *)v4 + a3) = 0;
}
// 140007EF0: could not find valid save-restore pair for rbp
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140008030) ----------------------------------------------------
bool __fastcall sub_140008030(size_t *a1, unsigned __int64 a2, char a3)
{
  size_t v4; // rbx
  size_t v5; // rax
  size_t v6; // rbp
  void *v7; // r12

  v4 = (size_t)a1;
  if ( a2 == -1i64 )
    sub_14002B5F8("string too long");
  v5 = a1[3];
  if ( v5 >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      v6 = a1[2];
      if ( a2 < v6 )
        v6 = a2;
      if ( v5 >= 0x10 )
      {
        v7 = (void *)*a1;
        if ( v6 )
          memmove(a1, (const void *)*a1, v6);
        j_free(v7);
      }
      *(_QWORD *)(v4 + 16) = v6;
      *(_QWORD *)(v4 + 24) = 15i64;
      *(_BYTE *)(v4 + v6) = 0;
    }
    else if ( !a2 )
    {
      a1[2] = 0i64;
      if ( v5 >= 0x10 )
        v4 = *a1;
      *(_BYTE *)v4 = 0;
    }
  }
  else
  {
    sub_140007EF0(a1, a2, a1[2]);
  }
  return a2 != 0;
}

//----- (0000000140008100) ----------------------------------------------------
size_t *__fastcall sub_140008100(void *a1, void *Src, size_t Size)
{
  size_t *v5; // rbx
  unsigned __int64 v6; // r8
  void *v7; // rax
  size_t *result; // rax
  size_t v9; // rax
  _BYTE *v10; // rcx
  bool v11; // cf
  size_t v12; // rax

  v5 = (size_t *)a1;
  if ( Src )
  {
    v6 = *((_QWORD *)a1 + 3);
    v7 = v6 < 0x10 ? a1 : *(void **)a1;
    if ( Src >= v7 )
    {
      if ( v6 >= 0x10 )
        a1 = *(void **)a1;
      if ( (char *)a1 + v5[2] > Src )
        return (size_t *)std::string::assign(v5);
    }
  }
  if ( Size == -1i64 )
    sub_14002B5F8("string too long");
  v9 = v5[3];
  if ( v9 < Size )
  {
    sub_140007EF0(v5, Size, v5[2]);
    if ( !Size )
      return v5;
LABEL_14:
    if ( v5[3] < 0x10 )
      v10 = v5;
    else
      v10 = (_BYTE *)*v5;
    memmove(v10, Src, Size);
    v11 = v5[3] < 0x10;
    v5[2] = Size;
    if ( v11 )
      v12 = (size_t)v5;
    else
      v12 = *v5;
    *(_BYTE *)(v12 + Size) = 0;
    return v5;
  }
  if ( Size )
    goto LABEL_14;
  v5[2] = 0i64;
  if ( v9 < 0x10 )
  {
    result = v5;
    *(_BYTE *)v5 = 0;
  }
  else
  {
    *(_BYTE *)*v5 = 0;
    return v5;
  }
  return result;
}

//----- (0000000140008230) ----------------------------------------------------
void __fastcall sub_140008230(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 24) >= 0x10ui64 )
    j_free(*(void **)a1);
  *(_QWORD *)(a1 + 24) = 15i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_BYTE *)a1 = 0;
}

//----- (0000000140008270) ----------------------------------------------------
void __fastcall sub_140008270(__int64 a1)
{
  _QWORD *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rcx
  char v5; // [rsp+30h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 24) = 513;
  *(_QWORD *)(a1 + 32) = 6i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  sub_140009260(a1, 0, 0);
  v2 = operator new(8ui64);
  if ( v2 )
  {
    *v2 = std::locale::_Init();
    v3 = sub_14002BB90();
    std::_Lockit::_Lockit((std::_Lockit *)&v5, 0);
    v4 = *(_QWORD *)(v3 + 8);
    if ( v4 != -1 )
      *(_QWORD *)(v3 + 8) = v4 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v5);
    *(_QWORD *)(a1 + 64) = v2;
  }
  else
  {
    *(_QWORD *)(a1 + 64) = 0i64;
  }
}

//----- (0000000140008330) ----------------------------------------------------
void *__fastcall sub_140008330(void *Block, char a2)
{
  __int64 *v2; // rdi

  v2 = (__int64 *)*((_QWORD *)Block + 13);
  *(_QWORD *)Block = &std::wstreambuf::`vftable';
  if ( v2 )
  {
    sub_140008FC0(v2);
    j_free(v2);
  }
  unknown_libname_21((char *)Block + 8);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 14002C534: using guessed type __int64 __fastcall unknown_libname_21(_QWORD);
// 1400F6A68: using guessed type void *std::wstreambuf::`vftable';

//----- (00000001400083A0) ----------------------------------------------------
__int64 sub_1400083A0()
{
  return 0i64;
}

//----- (00000001400083B0) ----------------------------------------------------
__int64 __fastcall sub_1400083B0(__int64 a1, _WORD *a2, __int64 a3)
{
  __int64 v3; // rbp
  __int64 v4; // rdi
  __int64 v7; // rax
  __int64 v8; // r13
  __int16 v9; // ax

  v3 = 0i64;
  v4 = a3;
  if ( a3 <= 0 )
    return 0i64;
  do
  {
    v7 = unknown_libname_13(a1);
    v8 = v7;
    if ( v7 <= 0 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
      if ( v9 == -1 )
        return v3;
      *a2++ = v9;
      ++v3;
      --v4;
    }
    else
    {
      if ( v4 < v7 )
        v8 = v4;
      memmove(a2, **(const void ***)(a1 + 64), 2 * v8);
      a2 += v8;
      **(_DWORD **)(a1 + 88) -= v8;
      v3 += v8;
      v4 -= v8;
      **(_QWORD **)(a1 + 64) += 2i64 * (int)v8;
    }
  }
  while ( v4 > 0 );
  return v3;
}
// 140009070: using guessed type __int64 __fastcall unknown_libname_13(_QWORD);

//----- (00000001400084B0) ----------------------------------------------------
__int64 sub_1400084B0()
{
  return 0xFFFFi64;
}

//----- (00000001400084C0) ----------------------------------------------------
__int64 __fastcall sub_1400084C0(__int64 a1, unsigned __int16 *a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v7; // rax
  __int64 v8; // r12

  v3 = 0i64;
  v4 = a3;
  if ( a3 <= 0 )
    return 0i64;
  do
  {
    v7 = unknown_libname_5(a1);
    v8 = v7;
    if ( v7 <= 0 )
    {
      if ( (*(unsigned __int16 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, *a2) == 0xFFFF )
        return v3;
      ++a2;
      ++v3;
      --v4;
    }
    else
    {
      if ( v4 < v7 )
        v8 = v4;
      memmove(**(void ***)(a1 + 72), a2, 2 * v8);
      a2 += v8;
      **(_DWORD **)(a1 + 96) -= v8;
      v3 += v8;
      v4 -= v8;
      **(_QWORD **)(a1 + 72) += 2i64 * (int)v8;
    }
  }
  while ( v4 > 0 );
  return v3;
}
// 140008490: using guessed type __int64 __fastcall unknown_libname_5(_QWORD);

//----- (00000001400085C0) ----------------------------------------------------
__int64 __fastcall sub_1400085C0(__int64 a1)
{
  return a1;
}

//----- (00000001400085D0) ----------------------------------------------------
__int64 __fastcall sub_1400085D0(_QWORD *a1)
{
  __int64 *v1; // rdi

  v1 = (__int64 *)a1[13];
  *a1 = &std::wstreambuf::`vftable';
  if ( v1 )
  {
    sub_140008FC0(v1);
    j_free(v1);
  }
  return unknown_libname_21(a1 + 1);
}
// 14002C534: using guessed type __int64 __fastcall unknown_libname_21(_QWORD);
// 1400F6A68: using guessed type void *std::wstreambuf::`vftable';

//----- (0000000140008620) ----------------------------------------------------
char *__fastcall sub_140008620(struct std::ios_base *a1, char a2)
{
  char *v2; // rdi

  v2 = (char *)a1 - 16;
  *(_QWORD *)((char *)a1 + *(int *)(*((_QWORD *)a1 - 2) + 4i64) - 16) = &std::wistream::`vftable';
  *(_QWORD *)a1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(a1);
  if ( (a2 & 1) != 0 )
    j_free(v2);
  return v2;
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';

//----- (00000001400086A0) ----------------------------------------------------
void __fastcall sub_1400086A0(__int64 a1)
{
  EnterCriticalSection(*(LPCRITICAL_SECTION *)(a1 + 8));
}

//----- (00000001400086B0) ----------------------------------------------------
void __fastcall sub_1400086B0(__int64 a1)
{
  LeaveCriticalSection(*(LPCRITICAL_SECTION *)(a1 + 8));
}

//----- (00000001400086F0) ----------------------------------------------------
__int64 __fastcall sub_1400086F0(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rcx
  __int64 v4; // rcx
  int v5; // edx

  v2 = 0;
  v3 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( (*(_BYTE *)(v3 + a1 + 16) & 6) == 0
    && (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(v3 + a1 + 72) + 104i64))(*(_QWORD *)(v3 + a1 + 72)) == -1 )
  {
    v2 = 4;
  }
  v4 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v2 )
  {
    v5 = v2 | *(_DWORD *)(v4 + 16);
    if ( !*(_QWORD *)(v4 + 72) )
      LOBYTE(v5) = v5 | 4;
    sub_140009260(v4, v5, 0);
  }
  return a1;
}

//----- (00000001400087D0) ----------------------------------------------------
unsigned __int16 *__fastcall sub_1400087D0(__int64 a1, unsigned __int16 a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // rbx

  for ( i = a3; i != a4; ++i )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 16i64))(a1, a2, *i) )
      break;
  }
  return i;
}

//----- (0000000140008840) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140008840(__int64 a1, unsigned __int16 a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // rbx

  for ( i = a3; i != a4; ++i )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 16i64))(a1, a2, *i) )
      break;
  }
  return i;
}

//----- (00000001400088B0) ----------------------------------------------------
wchar_t *__fastcall sub_1400088B0(__int64 a1, wchar_t *a2, wchar_t *a3)
{
  wchar_t *v4; // rbx
  const _Ctypevec *v5; // rdi
  wchar_t v6; // ax

  v4 = a2;
  if ( a2 != a3 )
  {
    v5 = (const _Ctypevec *)(a1 + 16);
    do
    {
      v6 = Towlower(*v4++, v5);
      *(v4 - 1) = v6;
    }
    while ( v4 != a3 );
  }
  return v4;
}

//----- (0000000140008910) ----------------------------------------------------
wchar_t *__fastcall sub_140008910(__int64 a1, wchar_t *a2, wchar_t *a3)
{
  wchar_t *v4; // rbx
  const _Ctypevec *v5; // rdi
  wchar_t v6; // ax

  v4 = a2;
  if ( a2 != a3 )
  {
    v5 = (const _Ctypevec *)(a1 + 16);
    do
    {
      v6 = Towupper(*v4++, v5);
      *(v4 - 1) = v6;
    }
    while ( v4 != a3 );
  }
  return v4;
}

//----- (0000000140008970) ----------------------------------------------------
char *__fastcall sub_140008970(__int64 a1, char *a2, char *a3, __int64 a4)
{
  char *v6; // rbx
  const _Cvtvec *v7; // rbp
  char v8; // al
  int v9; // eax
  wchar_t v10; // cx
  mbstate_t v12; // [rsp+30h] [rbp-38h] BYREF
  char v13; // [rsp+78h] [rbp+10h] BYREF
  wchar_t v14; // [rsp+80h] [rbp+18h] BYREF

  v6 = a2;
  if ( a2 != a3 )
  {
    v7 = (const _Cvtvec *)(a1 + 40);
    do
    {
      v8 = *v6;
      v12._Wchar = 0;
      v13 = v8;
      v9 = Mbrtowc(&v14, &v13, 1ui64, &v12, v7);
      v10 = v14;
      if ( v9 < 0 )
        v10 = -1;
      ++v6;
      a4 += 2i64;
      *(_WORD *)(a4 - 2) = v10;
    }
    while ( v6 != a3 );
  }
  return v6;
}

//----- (0000000140008A60) ----------------------------------------------------
wchar_t *__fastcall sub_140008A60(__int64 a1, wchar_t *a2, wchar_t *a3, char a4, _BYTE *a5)
{
  wchar_t *v8; // rbx
  const _Cvtvec *v9; // rbp
  wchar_t v10; // dx
  int v11; // eax
  char Byte; // dl
  mbstate_t v14; // [rsp+20h] [rbp-48h] BYREF

  v8 = a2;
  if ( a2 != a3 )
  {
    v9 = (const _Cvtvec *)(a1 + 40);
    do
    {
      v10 = *v8;
      v14._Wchar = 0;
      v11 = Wcrtomb((char *)&v14._Byte, v10, &v14, v9);
      Byte = v14._Byte;
      if ( v11 != 1 )
        Byte = a4;
      ++v8;
      *a5++ = Byte;
    }
    while ( v8 != a3 );
  }
  return v8;
}

//----- (0000000140008C10) ----------------------------------------------------
void __fastcall sub_140008C10(void **a1)
{
  void *v2; // rcx

  v2 = *a1;
  if ( v2 )
    free(v2);
  *a1 = 0i64;
}

//----- (0000000140008DB0) ----------------------------------------------------
__int64 __fastcall sub_140008DB0(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012E130;
  v12 = qword_14012E130;
  v3 = qword_14012C0E0;
  if ( !qword_14012C0E0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C0E0 == v3 )
      qword_14012C0E0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C0E0;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v5 = v2;
  }
  else
  {
    if ( sub_140008CC0(&v12, a1) == -1 )
    {
      sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v5 = v12;
    qword_14012E130 = v12;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v7 = *(_QWORD *)(v5 + 8);
    if ( v7 != -1 )
      *(_QWORD *)(v5 + 8) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    unknown_libname_19(v5);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 140008CC0: using guessed type __int64 __fastcall sub_140008CC0(_QWORD, _QWORD);
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E130: using guessed type __int64 qword_14012E130;

//----- (0000000140008F00) ----------------------------------------------------
__int64 *__fastcall sub_140008F00(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rax
  __int64 v4; // rdi
  __int64 v5; // rax
  char v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(__int64 **)(a1 + 64);
  v4 = *v2;
  *a2 = *v2;
  std::_Lockit::_Lockit((std::_Lockit *)&v7, 0);
  v5 = *(_QWORD *)(v4 + 8);
  if ( v5 != -1 )
    *(_QWORD *)(v4 + 8) = v5 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v7);
  return a2;
}

//----- (0000000140008F50) ----------------------------------------------------
__int64 __fastcall sub_140008F50(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  char v5; // [rsp+30h] [rbp+8h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v5, 0);
  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 && v2 != -1 )
    *(_QWORD *)(a1 + 8) = v2 - 1;
  v3 = 0i64;
  if ( !*(_QWORD *)(a1 + 8) )
    v3 = a1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v5);
  return v3;
}

//----- (0000000140008FC0) ----------------------------------------------------
void __fastcall sub_140008FC0(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax
  void (__fastcall ***v3)(_QWORD, __int64); // rdi
  char v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = *a1;
  if ( *a1 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v4, 0);
    v2 = *(_QWORD *)(v1 + 8);
    if ( v2 && v2 != -1 )
      *(_QWORD *)(v1 + 8) = v2 - 1;
    v3 = 0i64;
    if ( !*(_QWORD *)(v1 + 8) )
      v3 = (void (__fastcall ***)(_QWORD, __int64))v1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v4);
    if ( v3 )
      (**v3)(v3, 1i64);
  }
}

//----- (0000000140009030) ----------------------------------------------------
__int64 __fastcall sub_140009030(__int64 a1)
{
  unsigned __int16 **v3; // rcx
  unsigned __int16 *v4; // rdx

  if ( (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1) == 0xFFFF )
    return 0xFFFFi64;
  --**(_DWORD **)(a1 + 88);
  v3 = *(unsigned __int16 ***)(a1 + 64);
  v4 = (*v3)++;
  return *v4;
}

//----- (0000000140009090) ----------------------------------------------------
__int64 __fastcall sub_140009090(int **a1)
{
  int *v2; // rax
  int *v3; // rax
  unsigned __int16 *v4; // rcx
  int *v6; // rax
  int *v7; // rcx
  __int16 *v8; // rdx
  __int16 v9; // ax
  int *v10; // rcx

  if ( !*(_QWORD *)a1[8] )
    goto LABEL_6;
  v2 = a1[11];
  if ( *v2 > 1 )
  {
    --*v2;
    v3 = a1[8];
    v4 = (unsigned __int16 *)(*(_QWORD *)v3 + 2i64);
    *(_QWORD *)v3 = v4;
    return *v4;
  }
  v6 = a1[11];
  if ( *v6 > 0 )
  {
    --*v6;
    v7 = a1[8];
    v8 = *(__int16 **)v7;
    *(_QWORD *)v7 += 2i64;
    v9 = *v8;
  }
  else
  {
LABEL_6:
    v9 = (*((__int64 (__fastcall **)(int **))*a1 + 7))(a1);
  }
  if ( v9 == -1 )
    return 0xFFFFi64;
  v10 = a1[8];
  if ( *(_QWORD *)v10 && *a1[11] > 0 )
    return **(unsigned __int16 **)v10;
  else
    return (*((__int64 (__fastcall **)(int **))*a1 + 6))(a1);
}
// 1400090CA: conditional instruction was optimized away because rcx.8!=0

//----- (0000000140009170) ----------------------------------------------------
std::exception *__fastcall sub_140009170(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::system_error::`vftable';
  *((_QWORD *)a1 + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)a1 + 4) = *((_QWORD *)a2 + 4);
  *(_QWORD *)a1 = &std::ios_base::failure::`vftable';
  return a1;
}
// 1400F6AF8: using guessed type void *std::system_error::`vftable';
// 1400F6B10: using guessed type void *std::ios_base::failure::`vftable';

//----- (00000001400091C0) ----------------------------------------------------
std::exception *__fastcall sub_1400091C0(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::system_error::`vftable';
  *((_QWORD *)a1 + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)a1 + 4) = *((_QWORD *)a2 + 4);
  return a1;
}
// 1400F6AF8: using guessed type void *std::system_error::`vftable';

//----- (0000000140009200) ----------------------------------------------------
void *__fastcall sub_140009200(void *Block, char a2)
{
  sub_14004AEC0((std::exception *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140009230) ----------------------------------------------------
std::exception *__fastcall sub_140009230(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::runtime_error::`vftable';
  return a1;
}
// 1400E4210: using guessed type void *std::runtime_error::`vftable';

//----- (0000000140009260) ----------------------------------------------------
__int64 __fastcall sub_140009260(__int64 a1, char a2, char a3)
{
  __int64 v3; // rbx
  int v4; // edx
  bool v5; // zf
  __int64 result; // rax
  __int64 (__fastcall **v7)(); // rbx
  __int64 (__fastcall **v8)(); // rbx
  __int64 (__fastcall **v9)(); // rbx
  __int64 v10; // [rsp+20h] [rbp-40h]
  __int64 pExceptionObject[3]; // [rsp+30h] [rbp-30h] BYREF
  __int64 v12; // [rsp+48h] [rbp-18h]
  __int64 (__fastcall **v13)(); // [rsp+50h] [rbp-10h]
  char *v14; // [rsp+70h] [rbp+10h] BYREF
  __int64 v15; // [rsp+78h] [rbp+18h]

  v4 = a2 & 0x17;
  v5 = (v4 & *(_DWORD *)(a1 + 20)) == 0;
  result = (unsigned int)v4 & *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  if ( !v5 )
  {
    if ( a3 )
      CxxThrowException(0i64, 0i64);
    v15 = v3;
    LODWORD(v10) = 1;
    if ( (result & 4) != 0 )
    {
      v7 = sub_14002B818();
      v14 = "ios_base::badbit set";
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
      v12 = v10;
      v13 = v7;
      pExceptionObject[0] = (__int64)&std::ios_base::failure::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
    }
    if ( (result & 2) != 0 )
    {
      v8 = sub_14002B818();
      v14 = "ios_base::failbit set";
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
      v12 = v10;
      v13 = v8;
      pExceptionObject[0] = (__int64)&std::ios_base::failure::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
    }
    v9 = sub_14002B818();
    v14 = "ios_base::eofbit set";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    v12 = v10;
    v13 = v9;
    pExceptionObject[0] = (__int64)&std::ios_base::failure::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVfailure_ios_base_std__);
  }
  return result;
}
// 140009289: variable 'v3' is possibly undefined
// 1400092BD: variable 'v10' is possibly undefined
// 1400F6B10: using guessed type void *std::ios_base::failure::`vftable';

//----- (0000000140009380) ----------------------------------------------------
char __fastcall sub_140009380(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 *v4; // rax
  __int64 v5; // r12
  __int64 v6; // rsi
  __int64 v7; // rax
  void (__fastcall ***v8)(_QWORD, __int64); // rdi
  __int64 v9; // rcx
  __int16 **v10; // rdx
  __int16 v11; // r8
  __int64 v12; // rcx
  int v13; // edx
  int v15; // edx
  __int64 v16; // [rsp+58h] [rbp+10h] BYREF
  __int64 v17; // [rsp+60h] [rbp+18h] BYREF

  v2 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v2 + 16) )
  {
    v3 = *(_QWORD *)(v2 + 80);
    if ( v3 )
      sub_1400086F0(v3);
    if ( (*(_BYTE *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 24) & 1) != 0 )
    {
      v4 = sub_140008F00(a1 + *(int *)(*(_QWORD *)a1 + 4i64), &v17);
      v5 = sub_140008DB0(v4);
      v6 = v17;
      if ( v17 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v16, 0);
        v7 = *(_QWORD *)(v6 + 8);
        if ( v7 && v7 != -1 )
          *(_QWORD *)(v6 + 8) = v7 - 1;
        v8 = 0i64;
        if ( !*(_QWORD *)(v6 + 8) )
          v8 = (void (__fastcall ***)(_QWORD, __int64))v6;
        std::_Lockit::~_Lockit((std::_Lockit *)&v16);
        if ( v8 )
          (**v8)(v8, 1i64);
      }
      v9 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
      v10 = *(__int16 ***)(v9 + 64);
      if ( *v10 && **(int **)(v9 + 88) > 0 )
        v11 = **v10;
      else
        v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 48i64))(v9);
      while ( v11 != -1 )
      {
        if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 16i64))(v5, 72i64) )
          goto LABEL_23;
        v11 = sub_140009090(*(int ***)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72));
      }
      v12 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
      v13 = *(_DWORD *)(v12 + 16) | 1;
      if ( !*(_QWORD *)(v12 + 72) )
        LOBYTE(v13) = *(_BYTE *)(v12 + 16) | 5;
      sub_140009260(v12, v13, 0);
    }
LABEL_23:
    v2 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
    if ( !*(_DWORD *)(v2 + 16) )
      return 1;
  }
  v15 = *(_DWORD *)(v2 + 16) | 2;
  if ( !*(_QWORD *)(v2 + 72) )
    LOBYTE(v15) = *(_BYTE *)(v2 + 16) | 6;
  sub_140009260(v2, v15, 0);
  return 0;
}
// 140009380: could not find valid save-restore pair for rbp

//----- (0000000140009520) ----------------------------------------------------
void *__fastcall sub_140009520(void *Block, char a2)
{
  *(_QWORD *)Block = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';

//----- (0000000140009560) ----------------------------------------------------
void __fastcall sub_140009560(struct std::ios_base *a1)
{
  *(_QWORD *)a1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(a1);
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';

//----- (0000000140009570) ----------------------------------------------------
_QWORD *__fastcall sub_140009570(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r8
  _QWORD *v6; // rbx
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rax
  _QWORD *v9; // rdx
  unsigned __int64 v10; // r11
  bool v11; // cf
  _QWORD *v12; // rax

  v4 = a1[2];
  v6 = a1;
  if ( v4 < a2 )
    sub_14002B630("invalid string position");
  v7 = v4 - a2;
  if ( v7 < a3 )
    a3 = v7;
  if ( a3 )
  {
    v8 = a1[3];
    if ( v8 < 8 )
      v9 = a1;
    else
      v9 = (_QWORD *)*a1;
    if ( v8 >= 8 )
      a1 = (_QWORD *)*a1;
    memmove((char *)a1 + 2 * a2, (char *)v9 + 2 * a2 + 2 * a3, 2 * (v7 - a3));
    v10 = v6[2] - a3;
    v11 = v6[3] < 8ui64;
    v6[2] = v10;
    if ( v11 )
      v12 = v6;
    else
      v12 = (_QWORD *)*v6;
    *((_WORD *)v12 + v10) = 0;
  }
  return v6;
}

//----- (0000000140009610) ----------------------------------------------------
void *__fastcall sub_140009610(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rdi
  _QWORD *v6; // rsi
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rcx
  _WORD *v10; // rcx
  bool v11; // cf
  _WORD *v12; // rcx

  v4 = a2[2];
  v6 = a2;
  if ( v4 < a3 )
    sub_14002B630("invalid string position");
  v8 = v4 - a3;
  if ( a4 < v8 )
    v8 = a4;
  if ( Src == a2 )
  {
    sub_140009570(Src, v8 + a3, 0xFFFFFFFFFFFFFFFFui64);
    sub_140009570(Src, 0i64, a3);
    return Src;
  }
  if ( v8 > 0x7FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("string too long");
  v9 = *((_QWORD *)Src + 3);
  if ( v9 >= v8 )
  {
    if ( !v8 )
    {
      *((_QWORD *)Src + 2) = 0i64;
      if ( v9 < 8 )
        *(_WORD *)Src = 0;
      else
        **(_WORD **)Src = 0;
      return Src;
    }
  }
  else
  {
    sub_1400097B0(Src, v8, *((const void **)Src + 2));
    if ( !v8 )
      return Src;
  }
  if ( v6[3] >= 8ui64 )
    v6 = (_QWORD *)*v6;
  if ( *((_QWORD *)Src + 3) < 8ui64 )
    v10 = Src;
  else
    v10 = *(_WORD **)Src;
  memmove(v10, (char *)v6 + 2 * a3, 2 * v8);
  v11 = *((_QWORD *)Src + 3) < 8ui64;
  *((_QWORD *)Src + 2) = v8;
  if ( v11 )
    v12 = Src;
  else
    v12 = *(_WORD **)Src;
  v12[v8] = 0;
  return Src;
}

//----- (0000000140009740) ----------------------------------------------------
void *__fastcall sub_140009740(__int64 a1, unsigned __int64 a2)
{
  void *result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v4; // [rsp+58h] [rbp+10h] BYREF

  result = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFi64 || (result = operator new(2 * a2)) == 0i64 )
    {
      v4 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400097B0) ----------------------------------------------------
void __fastcall sub_1400097B0(void *Src, unsigned __int64 a2, const void *a3)
{
  const void **v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  void *v9; // rsi
  const void *v10; // rdx
  __int64 pExceptionObject[8]; // [rsp+40h] [rbp-40h] BYREF
  char *v12; // [rsp+A0h] [rbp+20h] BYREF

  v4 = (const void **)Src;
  v5 = a2 | 7;
  if ( (a2 | 7) <= 0x7FFFFFFFFFFFFFFEi64 )
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = v6 >> 1;
    if ( v6 >> 1 > v5 / 3 )
    {
      v5 = v7 + v6;
      if ( v6 > 0x7FFFFFFFFFFFFFFEi64 - v7 )
        v5 = 0x7FFFFFFFFFFFFFFEi64;
    }
  }
  else
  {
    v5 = a2;
  }
  v8 = v5 + 1;
  v9 = 0i64;
  if ( v5 != -1i64 && (v8 > 0x7FFFFFFFFFFFFFFFi64 || (v9 = operator new(2 * v8)) == 0i64) )
  {
    v12 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( a3 )
  {
    if ( (unsigned __int64)v4[3] < 8 )
      v10 = v4;
    else
      v10 = *v4;
    memmove(v9, v10, 2i64 * (_QWORD)a3);
  }
  if ( (unsigned __int64)v4[3] >= 8 )
    j_free((void *)*v4);
  *v4 = v9;
  v4[3] = (const void *)v5;
  v4[2] = a3;
  if ( v5 >= 8 )
    v4 = (const void **)v9;
  *((_WORD *)v4 + (_QWORD)a3) = 0;
}
// 1400097B0: could not find valid save-restore pair for rbp
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140009900) ----------------------------------------------------
bool __fastcall sub_140009900(const void **a1, unsigned __int64 a2, char a3)
{
  _QWORD *v4; // rbx
  const void *v5; // rax
  unsigned __int64 v6; // rbp
  void *v7; // r12

  v4 = a1;
  if ( a2 > 0x7FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("string too long");
  v5 = a1[3];
  if ( (unsigned __int64)v5 >= a2 )
  {
    if ( a3 && a2 < 8 )
    {
      v6 = (unsigned __int64)a1[2];
      if ( a2 < v6 )
        v6 = a2;
      if ( (unsigned __int64)v5 >= 8 )
      {
        v7 = (void *)*a1;
        if ( v6 )
          memmove(a1, *a1, 2 * v6);
        j_free(v7);
      }
      v4[2] = v6;
      v4[3] = 7i64;
      *((_WORD *)v4 + v6) = 0;
    }
    else if ( !a2 )
    {
      a1[2] = 0i64;
      if ( (unsigned __int64)v5 >= 8 )
        v4 = *a1;
      *(_WORD *)v4 = 0;
    }
  }
  else
  {
    sub_1400097B0(a1, a2, a1[2]);
  }
  return a2 != 0;
}

//----- (00000001400099E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400099E0(void *Src, void *a2, unsigned __int64 a3)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r8
  void *v7; // rax
  _WORD *v8; // rax
  unsigned __int64 v10; // rcx
  void *v11; // rcx
  bool v12; // cf
  _QWORD *v13; // rcx

  v5 = Src;
  if ( a2 )
  {
    v6 = *((_QWORD *)Src + 3);
    v7 = v6 < 8 ? Src : *(void **)Src;
    if ( a2 >= v7 )
    {
      if ( v6 >= 8 )
        Src = *(void **)Src;
      if ( (char *)Src + 2 * v5[2] > a2 )
      {
        if ( v6 < 8 )
          v8 = v5;
        else
          v8 = (_WORD *)*v5;
        return sub_140009610(v5, v5, ((_BYTE *)a2 - (_BYTE *)v8) >> 1, a3);
      }
    }
  }
  if ( a3 > 0x7FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("string too long");
  v10 = v5[3];
  if ( v10 < a3 )
  {
    sub_1400097B0(v5, a3, (const void *)v5[2]);
    if ( !a3 )
      return v5;
LABEL_17:
    if ( v5[3] < 8ui64 )
      v11 = v5;
    else
      v11 = (void *)*v5;
    memmove(v11, a2, 2 * a3);
    v12 = v5[3] < 8ui64;
    v5[2] = a3;
    if ( v12 )
      v13 = v5;
    else
      v13 = (_QWORD *)*v5;
    *((_WORD *)v13 + a3) = 0;
    return v5;
  }
  if ( a3 )
    goto LABEL_17;
  v5[2] = 0i64;
  if ( v10 < 8 )
    *(_WORD *)v5 = 0;
  else
    *(_WORD *)*v5 = 0;
  return v5;
}

//----- (0000000140009B40) ----------------------------------------------------
__int64 __fastcall sub_140009B40(__int64 a1)
{
  DWORD LastError; // esi
  unsigned int v3; // edi
  __int64 (__fastcall *v4)(__int64); // rbx
  FARPROC v6; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v3 = 0;
  v4 = (__int64 (__fastcall *)(__int64))qword_14012E110;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
    goto LABEL_9;
  v6 = sub_1400017F0("ChooseColorW");
  v4 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E110 = (__int64)v6;
LABEL_9:
    v3 = v4(a1);
  }
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E110: using guessed type __int64 qword_14012E110;

//----- (0000000140009C20) ----------------------------------------------------
__int64 __fastcall sub_140009C20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  DWORD LastError; // edi
  unsigned int v9; // esi
  __int64 (__fastcall *v10)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // rbx
  FARPROC v12; // rax
  __int64 Cookie[4]; // [rsp+28h] [rbp-20h] BYREF

  LastError = 0;
  v9 = 0;
  v10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD))qword_14012E118;
  Cookie[0] = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, (ULONG_PTR *)Cookie) )
    return 0i64;
  if ( v10 )
    goto LABEL_9;
  v12 = sub_140001610("SetWindowSubclass");
  v10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD))v12;
  if ( v12 )
  {
    qword_14012E118 = (__int64)v12;
LABEL_9:
    v9 = v10(a1, a2, a3, a4, 0, Cookie[0]);
  }
  if ( !v9 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie[0]);
  if ( !v9 )
    SetLastError(LastError);
  return v9;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E118: using guessed type __int64 qword_14012E118;
// 140009C20: using guessed type ULONG_PTR Cookie[4];

//----- (0000000140009D30) ----------------------------------------------------
_QWORD *__fastcall sub_140009D30(_QWORD *a1)
{
  if ( a1[3] < 8ui64 )
    return a1;
  else
    return (_QWORD *)*a1;
}

//----- (0000000140009D40) ----------------------------------------------------
__int64 __fastcall sub_140009D40(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_WORD *)a1 = 0;
  sub_140009610((void *)a1, (_QWORD *)a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(a1 + 64) = 7i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_WORD *)(a1 + 40) = 0;
  sub_140009610((void *)(a1 + 40), (_QWORD *)(a2 + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  return a1;
}

//----- (0000000140009DD0) ----------------------------------------------------
void __fastcall sub_140009DD0(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rcx
  __int64 v5; // rdi
  __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rcx

  v4 = a1[1];
  if ( a2 >= v4 || *a1 > a2 )
  {
    if ( v4 == a1[2] )
      sub_140009E90(a1);
    v8 = a1[1];
    if ( v8 )
      sub_140009D40(v8, a2);
  }
  else
  {
    v5 = (__int64)(a2 - *a1) / 88;
    if ( v4 == a1[2] )
      sub_140009E90(a1);
    v6 = *a1 + 88 * v5;
    v7 = a1[1];
    if ( v7 )
      sub_140009D40(v7, v6);
  }
  a1[1] += 88i64;
}

//----- (0000000140009E90) ----------------------------------------------------
unsigned __int64 __fastcall sub_140009E90(_QWORD *a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdx

  v2 = (a1[1] - *a1) / 88i64;
  if ( v2 > 0x2E8BA2E8BA2E8B9i64 )
    sub_14002B5F8("vector<T> too long");
  v3 = v2 + 1;
  v4 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x2E8BA2E8BA2E8BA3i64) >> 64) >> 63;
  v6 = v4 / 88;
  if ( v3 > v4 / 88 )
  {
    if ( 0x2E8BA2E8BA2E8BAi64 - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v3 )
        v8 = v3;
      return sub_140009F50(a1, v8);
    }
    else
    {
      v7 = 0i64;
      if ( v3 )
        v7 = v3;
      return sub_140009F50(a1, v7);
    }
  }
  return result;
}
// 140009F50: using guessed type __int64 __fastcall sub_140009F50(_QWORD, _QWORD);

//----- (000000014000A090) ----------------------------------------------------
void __fastcall sub_14000A090(void *Src, void *a2)
{
  void *Srca[3]; // [rsp+30h] [rbp-88h] BYREF
  unsigned __int64 v5; // [rsp+48h] [rbp-70h]
  void *Block[2]; // [rsp+58h] [rbp-60h] BYREF
  __int64 v7; // [rsp+68h] [rbp-50h]
  unsigned __int64 v8; // [rsp+70h] [rbp-48h]
  int v9; // [rsp+80h] [rbp-38h]
  int v10; // [rsp+84h] [rbp-34h]

  v5 = 7i64;
  Srca[2] = 0i64;
  LOWORD(Srca[0]) = 0;
  sub_140009610(Srca, Src, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v8 = 7i64;
  v7 = 0i64;
  LOWORD(Block[0]) = 0;
  sub_140009610(Block, (_QWORD *)Src + 5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v9 = *((_DWORD *)Src + 20);
  v10 = *((_DWORD *)Src + 21);
  sub_140009610(Src, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140009610((char *)Src + 40, (_QWORD *)a2 + 5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *((_DWORD *)Src + 20) = *((_DWORD *)a2 + 20);
  *((_DWORD *)Src + 21) = *((_DWORD *)a2 + 21);
  sub_140009610(a2, Srca, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140009610((char *)a2 + 40, Block, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *((_DWORD *)a2 + 20) = v9;
  *((_DWORD *)a2 + 21) = v10;
  if ( v8 >= 8 )
    j_free(Block[0]);
  v8 = 7i64;
  v7 = 0i64;
  LOWORD(Block[0]) = 0;
  if ( v5 >= 8 )
    j_free(Srca[0]);
}

//----- (000000014000A200) ----------------------------------------------------
_DWORD *__fastcall sub_14000A200(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v5; // rdi
  int v6; // er11

  if ( a1 != a2 )
  {
    v5 = a1 + 20;
    do
    {
      sub_140009610(a3, (_QWORD *)v5 - 10, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      sub_140009610(a3 + 10, (_QWORD *)v5 - 5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v6 = *v5;
      v5 += 22;
      a3[20] = v6;
      a3 += 22;
      *(a3 - 1) = *(v5 - 21);
    }
    while ( v5 - 20 != a2 );
  }
  return a3;
}

//----- (000000014000A280) ----------------------------------------------------
_QWORD *__fastcall sub_14000A280(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3; // rbx
  _QWORD *result; // rax

  if ( a1 != a2 )
  {
    v3 = a1 + 8;
    do
    {
      if ( *v3 >= 8ui64 )
        j_free((void *)*(v3 - 3));
      *v3 = 7i64;
      *(v3 - 1) = 0i64;
      *((_WORD *)v3 - 12) = 0;
      if ( *(v3 - 5) >= 8ui64 )
        j_free((void *)*(v3 - 8));
      *(v3 - 5) = 7i64;
      *(v3 - 6) = 0i64;
      *((_WORD *)v3 - 32) = 0;
      v3 += 11;
      result = v3 - 8;
    }
    while ( v3 - 8 != a2 );
  }
  return result;
}

//----- (000000014000A300) ----------------------------------------------------
__int64 __fastcall sub_14000A300(__int64 a1, __int64 a2, __int64 a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
      sub_140009D40(a3, a1);
    a3 += 88i64;
    a1 += 88i64;
  }
  return a3;
}

//----- (000000014000A390) ----------------------------------------------------
__int64 __fastcall sub_14000A390(__int64 a1)
{
  DWORD LastError; // esi
  unsigned int v3; // edi
  __int64 (__fastcall *v4)(__int64); // rbx
  FARPROC v6; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v3 = 0;
  v4 = (__int64 (__fastcall *)(__int64))qword_14012E140;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
    goto LABEL_9;
  v6 = sub_140001610("ImageList_Destroy");
  v4 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E140 = (__int64)v6;
LABEL_9:
    v3 = v4(a1);
  }
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E140: using guessed type __int64 qword_14012E140;

//----- (000000014000A470) ----------------------------------------------------
__int64 __fastcall sub_14000A470(__int64 a1, unsigned int a2, unsigned int a3)
{
  DWORD LastError; // edi
  __int64 v7; // rsi
  __int64 (__fastcall *v8)(_QWORD, _QWORD, _QWORD); // rbx
  FARPROC v10; // rax
  ULONG_PTR Cookie; // [rsp+68h] [rbp+20h] BYREF

  LastError = 0;
  v7 = 0i64;
  v8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))qword_14012E138;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v8 )
    goto LABEL_9;
  v10 = sub_140001610("ImageList_GetIcon");
  v8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))v10;
  if ( v10 )
  {
    qword_14012E138 = (__int64)v10;
LABEL_9:
    v7 = v8(a1, a2, a3);
  }
  if ( !v7 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v7 )
    SetLastError(LastError);
  return v7;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E138: using guessed type __int64 qword_14012E138;

//----- (000000014000A570) ----------------------------------------------------
void __fastcall sub_14000A570(void *a1)
{
  sub_14000A5B0(a1);
}

//----- (000000014000A590) ----------------------------------------------------
void __fastcall sub_14000A590(void *a1)
{
  sub_14000A630((__int64)a1);
  j_free(*(void **)a1);
}

//----- (000000014000A5B0) ----------------------------------------------------
_QWORD *__fastcall sub_14000A5B0(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x38ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000A630) ----------------------------------------------------
void __fastcall sub_14000A630(__int64 a1)
{
  void **v2; // rbx
  void **v3; // rsi

  v2 = **(void ****)a1;
  **(_QWORD **)a1 = *(_QWORD *)a1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v2 != *(void ***)a1 )
  {
    do
    {
      v3 = (void **)*v2;
      if ( (unsigned __int64)v2[5] >= 8 )
        j_free(v2[2]);
      v2[5] = (void *)7;
      v2[4] = 0i64;
      *((_WORD *)v2 + 8) = 0;
      j_free(v2);
      v2 = v3;
    }
    while ( v3 != *(void ***)a1 );
  }
}

//----- (000000014000A6B0) ----------------------------------------------------
void __fastcall sub_14000A6B0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_14000A760(v4, *(_QWORD *)(v4 + 8), a3 + 2);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (000000014000A760) ----------------------------------------------------
char *__fastcall sub_14000A760(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *v6; // rax
  char *v7; // rbx
  _WORD *v8; // rcx
  __int64 pExceptionObject[4]; // [rsp+38h] [rbp-20h] BYREF
  char *v11; // [rsp+78h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x38ui64);
  v7 = v6;
  v11 = v6;
  if ( !v6 )
  {
    v11 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v11);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  v8 = v6 + 16;
  if ( v6 != (char *)-16i64 )
  {
    *((_QWORD *)v6 + 5) = 7i64;
    *((_QWORD *)v6 + 4) = 0i64;
    *v8 = 0;
    sub_140009610(v8, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  }
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000A830) ----------------------------------------------------
__int64 __fastcall sub_14000A830(__int64 a1)
{
  DWORD LastError; // esi
  unsigned int v3; // edi
  __int64 (__fastcall *v4)(__int64); // rbx
  FARPROC v6; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v3 = 0;
  v4 = (__int64 (__fastcall *)(__int64))qword_14012E148;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
    goto LABEL_9;
  v6 = sub_1400017F0("ChooseFontW");
  v4 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E148 = (__int64)v6;
LABEL_9:
    v3 = v4(a1);
  }
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E148: using guessed type __int64 qword_14012E148;

//----- (000000014000A910) ----------------------------------------------------
_QWORD *__fastcall sub_14000A910(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x410ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000A980) ----------------------------------------------------
__int64 __fastcall sub_14000A980(__int64 a1)
{
  _QWORD *v2; // rcx
  __int64 result; // rax

  v2 = *(_QWORD **)a1;
  if ( v2 )
  {
    sub_14000A280(v2, *(_QWORD **)(a1 + 8));
    j_free(*(void **)a1);
  }
  result = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (000000014000A9C0) ----------------------------------------------------
void __fastcall sub_14000A9C0(void **a1)
{
  void **v2; // rsi
  void **v3; // rbx

  v2 = *(void ***)*a1;
  *(_QWORD *)*a1 = *a1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v2 != *a1 )
  {
    do
    {
      v3 = (void **)*v2;
      sub_14000AD00((__int64)(v2 + 3));
      j_free(v2);
      v2 = v3;
    }
    while ( v3 != *a1 );
  }
  j_free(*a1);
}

//----- (000000014000AA30) ----------------------------------------------------
void __fastcall sub_14000AA30(void **a1)
{
  _QWORD *v1; // rax
  void **v3; // rcx
  void **v4; // rbx

  v1 = *a1;
  v3 = *(void ***)*a1;
  *v1 = v1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v3 != *a1 )
  {
    do
    {
      v4 = (void **)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *a1 );
  }
  j_free(*a1);
}

//----- (000000014000AA90) ----------------------------------------------------
void __fastcall sub_14000AA90(void **a1)
{
  void **v2; // rsi
  void **v3; // rbx

  v2 = *(void ***)*a1;
  *(_QWORD *)*a1 = *a1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v2 != *a1 )
  {
    do
    {
      v3 = (void **)*v2;
      sub_14000AC40((__int64)(v2 + 2));
      j_free(v2);
      v2 = v3;
    }
    while ( v3 != *a1 );
  }
  j_free(*a1);
}

//----- (000000014000AB00) ----------------------------------------------------
_QWORD *__fastcall sub_14000AB00(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x18ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000AB70) ----------------------------------------------------
_QWORD *__fastcall sub_14000AB70(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x20ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000ABE0) ----------------------------------------------------
void __fastcall sub_14000ABE0(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD **)a1;
  v3 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v3 != *(_QWORD **)a1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
}

//----- (000000014000AC40) ----------------------------------------------------
void __fastcall sub_14000AC40(__int64 a1)
{
  _QWORD **v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  _QWORD **v5; // rax
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx

  v1 = *(_QWORD ***)(a1 + 536);
  v3 = *v1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)(a1 + 536) + 8i64) = *(_QWORD *)(a1 + 536);
  *(_QWORD *)(a1 + 544) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 536) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 536) );
  }
  j_free(*(void **)(a1 + 536));
  v5 = *(_QWORD ***)(a1 + 512);
  v6 = *v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 512) + 8i64) = *(_QWORD *)(a1 + 512);
  *(_QWORD *)(a1 + 520) = 0i64;
  if ( v6 != *(_QWORD **)(a1 + 512) )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *(_QWORD **)(a1 + 512) );
  }
  j_free(*(void **)(a1 + 512));
}

//----- (000000014000AD00) ----------------------------------------------------
void __fastcall sub_14000AD00(__int64 a1)
{
  _QWORD **v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  _QWORD **v5; // rax
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD **v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rbx
  _QWORD **v11; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rbx
  _QWORD **v14; // rax
  _QWORD *v15; // rcx
  _QWORD *v16; // rbx
  _QWORD **v17; // rax
  _QWORD *v18; // rcx
  _QWORD *v19; // rbx
  _QWORD **v20; // rax
  _QWORD *v21; // rcx
  _QWORD *v22; // rbx

  v1 = *(_QWORD ***)(a1 + 152);
  v3 = *v1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)(a1 + 152) + 8i64) = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(a1 + 160) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 152) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 152) );
  }
  j_free(*(void **)(a1 + 152));
  v5 = *(_QWORD ***)(a1 + 128);
  v6 = *v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8i64) = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 136) = 0i64;
  if ( v6 != *(_QWORD **)(a1 + 128) )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *(_QWORD **)(a1 + 128) );
  }
  j_free(*(void **)(a1 + 128));
  v8 = *(_QWORD ***)(a1 + 104);
  v9 = *v8;
  *v8 = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8i64) = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 112) = 0i64;
  if ( v9 != *(_QWORD **)(a1 + 104) )
  {
    do
    {
      v10 = (_QWORD *)*v9;
      j_free(v9);
      v9 = v10;
    }
    while ( v10 != *(_QWORD **)(a1 + 104) );
  }
  j_free(*(void **)(a1 + 104));
  v11 = *(_QWORD ***)(a1 + 80);
  v12 = *v11;
  *v11 = v11;
  *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8i64) = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 88) = 0i64;
  if ( v12 != *(_QWORD **)(a1 + 80) )
  {
    do
    {
      v13 = (_QWORD *)*v12;
      j_free(v12);
      v12 = v13;
    }
    while ( v13 != *(_QWORD **)(a1 + 80) );
  }
  j_free(*(void **)(a1 + 80));
  v14 = *(_QWORD ***)(a1 + 56);
  v15 = *v14;
  *v14 = v14;
  *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 64) = 0i64;
  if ( v15 != *(_QWORD **)(a1 + 56) )
  {
    do
    {
      v16 = (_QWORD *)*v15;
      j_free(v15);
      v15 = v16;
    }
    while ( v16 != *(_QWORD **)(a1 + 56) );
  }
  j_free(*(void **)(a1 + 56));
  v17 = *(_QWORD ***)(a1 + 32);
  v18 = *v17;
  *v17 = v17;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 40) = 0i64;
  if ( v18 != *(_QWORD **)(a1 + 32) )
  {
    do
    {
      v19 = (_QWORD *)*v18;
      j_free(v18);
      v18 = v19;
    }
    while ( v19 != *(_QWORD **)(a1 + 32) );
  }
  j_free(*(void **)(a1 + 32));
  v20 = *(_QWORD ***)(a1 + 8);
  v21 = *v20;
  *v20 = v20;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0i64;
  if ( v21 != *(_QWORD **)(a1 + 8) )
  {
    do
    {
      v22 = (_QWORD *)*v21;
      j_free(v21);
      v21 = v22;
    }
    while ( v22 != *(_QWORD **)(a1 + 8) );
  }
  j_free(*(void **)(a1 + 8));
}

//----- (000000014000AEE0) ----------------------------------------------------
__int64 __fastcall sub_14000AEE0(__int64 a1)
{
  return sub_1400C3780(a1 - 24);
}

//----- (000000014000AEF0) ----------------------------------------------------
__int64 __fastcall sub_14000AEF0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_1400C3B00(a1 - 16, a2, a3);
}

//----- (000000014000AF00) ----------------------------------------------------
__int64 __fastcall sub_14000AF00(__int64 a1)
{
  return sub_1400C4200((void *)(a1 - 8));
}

//----- (000000014000AF10) ----------------------------------------------------
__int64 __fastcall sub_14000AF10(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_1400C3B00(a1 - 24, a2, a3);
}

//----- (000000014000AF20) ----------------------------------------------------
__int64 __fastcall sub_14000AF20(__int64 a1)
{
  return sub_1400C4200((void *)(a1 - 16));
}

//----- (000000014000AF30) ----------------------------------------------------
__int64 __fastcall sub_14000AF30(__int64 a1)
{
  return sub_1400C3780(a1 - 8);
}

//----- (000000014000AF40) ----------------------------------------------------
__int64 __fastcall sub_14000AF40(__int64 a1)
{
  return sub_1400C4200((void *)(a1 - 24));
}

//----- (000000014000AF50) ----------------------------------------------------
__int64 __fastcall sub_14000AF50(__int64 a1)
{
  return sub_1400C3780(a1 - 16);
}

//----- (000000014000AF60) ----------------------------------------------------
__int64 __fastcall sub_14000AF60(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_1400C3B00(a1 - 8, a2, a3);
}

//----- (000000014000AF70) ----------------------------------------------------
HMODULE __fastcall sub_14000AF70(LPCWSTR lpLibFileName)
{
  DWORD LastError; // ebx
  HMODULE LibraryW; // rdi
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  LibraryW = LoadLibraryW(lpLibFileName);
  if ( !LibraryW )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !LibraryW )
    SetLastError(LastError);
  return LibraryW;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (000000014000B030) ----------------------------------------------------
void *__fastcall sub_14000B030(void *Block, char a2)
{
  char *v3; // rcx

  v3 = (char *)Block + 544;
  *((_QWORD *)v3 - 68) = &CFilterDialogPersistentSettings::`vftable';
  sub_14000A630((__int64)v3);
  j_free(*((void **)Block + 68));
  *(_QWORD *)Block = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400F6FC8: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (000000014000B0A0) ----------------------------------------------------
__int64 __fastcall sub_14000B0A0(__int64 a1, __int64 a2)
{
  __int64 *v2; // r8
  __int64 *v3; // r9
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 result; // rax

  v2 = (__int64 *)(a2 + 16);
  v3 = (__int64 *)(a1 + 16);
  if ( a1 + 16 != a2 + 16 )
  {
    v4 = *v3;
    v5 = v3[1];
    *v3 = *v2;
    v3[1] = v2[1];
    *v2 = v4;
    v2[1] = v5;
    v6 = v3[2];
    v3[2] = v2[2];
    v2[2] = v6;
    v7 = v3[3];
    result = v2[3];
    v3[3] = result;
    v2[3] = v7;
  }
  return result;
}

//----- (000000014000B120) ----------------------------------------------------
void __fastcall sub_14000B120(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 64) >= 8ui64 )
    j_free(*(void **)(a1 + 40));
  *(_QWORD *)(a1 + 64) = 7i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_WORD *)(a1 + 40) = 0;
  if ( *(_QWORD *)(a1 + 24) >= 8ui64 )
    j_free(*(void **)a1);
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_WORD *)a1 = 0;
}

//----- (000000014000B180) ----------------------------------------------------
__int64 **__fastcall sub_14000B180(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x38ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_14000A6B0((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B220) ----------------------------------------------------
__int64 **__fastcall sub_14000B220(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x18ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_14000BAC0((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B2C0) ----------------------------------------------------
__int64 **__fastcall sub_14000B2C0(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x468ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_14000BC10((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B360) ----------------------------------------------------
_QWORD *__fastcall sub_14000B360(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x60ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B3D0) ----------------------------------------------------
void __fastcall sub_14000B3D0(void **a1)
{
  sub_14000B5B0((__int64)a1);
  j_free(*a1);
}

//----- (000000014000B3F0) ----------------------------------------------------
void *__fastcall sub_14000B3F0(void *a1, void *Src)
{
  if ( a1 != Src )
  {
    if ( *((_QWORD *)a1 + 3) >= 8ui64 )
      j_free(*(void **)a1);
    *((_QWORD *)a1 + 3) = 7i64;
    *((_QWORD *)a1 + 2) = 0i64;
    *(_WORD *)a1 = 0;
    if ( *((_QWORD *)Src + 3) >= 8ui64 )
    {
      *(_QWORD *)a1 = *(_QWORD *)Src;
      *(_QWORD *)Src = 0i64;
    }
    else
    {
      memmove(a1, Src, 2i64 * *((_QWORD *)Src + 2) + 2);
    }
    *((_QWORD *)a1 + 2) = *((_QWORD *)Src + 2);
    *((_QWORD *)a1 + 3) = *((_QWORD *)Src + 3);
    *((_QWORD *)Src + 2) = 0i64;
    *((_QWORD *)Src + 3) = 7i64;
    *(_WORD *)Src = 0;
  }
  return a1;
}

//----- (000000014000B490) ----------------------------------------------------
_QWORD *__fastcall sub_14000B490(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x468ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B500) ----------------------------------------------------
char *__fastcall sub_14000B500(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x468ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x458ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B5B0) ----------------------------------------------------
void __fastcall sub_14000B5B0(__int64 a1)
{
  void **v2; // rbx
  void **v3; // rsi

  v2 = **(void ****)a1;
  **(_QWORD **)a1 = *(_QWORD *)a1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v2 != *(void ***)a1 )
  {
    do
    {
      v3 = (void **)*v2;
      if ( (unsigned __int64)v2[10] >= 8 )
        j_free(v2[7]);
      v2[10] = (void *)7;
      v2[9] = 0i64;
      *((_WORD *)v2 + 28) = 0;
      if ( (unsigned __int64)v2[5] >= 8 )
        j_free(v2[2]);
      v2[5] = (void *)7;
      v2[4] = 0i64;
      *((_WORD *)v2 + 8) = 0;
      j_free(v2);
      v2 = v3;
    }
    while ( v3 != *(void ***)a1 );
  }
}

//----- (000000014000B650) ----------------------------------------------------
char *__fastcall sub_14000B650(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+38h] [rbp-20h] BYREF
  char *v10; // [rsp+78h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x60ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    sub_14000BCC0((__int64)(v6 + 16), a3);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000B710) ----------------------------------------------------
void *__fastcall sub_14000B710(void *a1, _WORD *a2, void *a3)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  _QWORD *v7; // rax

  v4 = -1i64;
  v5 = a2;
  do
  {
    if ( !v4 )
      break;
    v6 = *v5++ == 0;
    --v4;
  }
  while ( !v6 );
  v7 = sub_14000B780(a3, a2, -v4 - 2);
  *((_QWORD *)a1 + 3) = 7i64;
  *((_QWORD *)a1 + 2) = 0i64;
  *(_WORD *)a1 = 0;
  sub_14000B3F0(a1, v7);
  return a1;
}

//----- (000000014000B780) ----------------------------------------------------
_QWORD *__fastcall sub_14000B780(void *Src, void *a2, unsigned __int64 a3)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r9
  void *v7; // rax
  _QWORD *v8; // rax
  char *v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  const void *v14; // rdx
  _QWORD *v15; // rax
  size_t v16; // rbp
  void *v17; // rcx
  bool v18; // cf
  _QWORD *v19; // rcx

  v5 = Src;
  if ( !a2 )
    goto LABEL_13;
  v6 = *((_QWORD *)Src + 3);
  v7 = v6 < 8 ? Src : *(void **)Src;
  if ( a2 < v7 )
    goto LABEL_13;
  if ( v6 >= 8 )
    Src = *(void **)Src;
  if ( (char *)Src + 2 * v5[2] <= a2 )
  {
LABEL_13:
    v10 = (char *)v5[2];
    if ( -1 - (__int64)v10 <= a3 )
      sub_14002B5F8("string too long");
    if ( !a3 )
      return v5;
    v11 = (unsigned __int64)&v10[a3];
    if ( (unsigned __int64)&v10[a3] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v12 = v5[3];
    if ( v12 >= v11 )
    {
      if ( v11 )
        goto LABEL_20;
      v5[2] = 0i64;
      if ( v12 < 8 )
        *(_WORD *)v5 = 0;
      else
        *(_WORD *)*v5 = 0;
    }
    else
    {
      sub_1400097B0(v5, (unsigned __int64)&v10[a3], v10);
      if ( v11 )
      {
LABEL_20:
        v13 = v5[3];
        if ( v13 < 8 )
          v14 = v5;
        else
          v14 = (const void *)*v5;
        if ( v13 < 8 )
          v15 = v5;
        else
          v15 = (_QWORD *)*v5;
        v16 = 2 * a3;
        memmove((char *)v15 + v16, v14, 2i64 * v5[2]);
        if ( v5[3] < 8ui64 )
          v17 = v5;
        else
          v17 = (void *)*v5;
        memmove(v17, a2, v16);
        v18 = v5[3] < 8ui64;
        v5[2] = v11;
        if ( v18 )
          v19 = v5;
        else
          v19 = (_QWORD *)*v5;
        *((_WORD *)v19 + v11) = 0;
      }
    }
    return v5;
  }
  if ( v6 < 8 )
    v8 = v5;
  else
    v8 = (_QWORD *)*v5;
  return sub_14000B910(v5, v5, ((_BYTE *)a2 - (_BYTE *)v8) >> 1, a3);
}

//----- (000000014000B910) ----------------------------------------------------
void *__fastcall sub_14000B910(void *Src, _QWORD *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r12
  _QWORD *v7; // rbp
  unsigned __int64 v9; // rax
  char *v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rax
  char *v14; // rdx
  char *v15; // rax
  unsigned __int64 v16; // rax
  char *v17; // rdx
  void *v18; // rcx
  bool v19; // cf
  _WORD *v20; // rcx

  v4 = a2[2];
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( v4 < a3 )
    sub_14002B630("invalid string position");
  v9 = v4 - a3;
  v10 = (char *)*((_QWORD *)Src + 2);
  if ( v9 < a4 )
    v5 = v9;
  if ( -1 - (__int64)v10 <= v5 )
    sub_14002B5F8("string too long");
  if ( v5 )
  {
    v11 = (unsigned __int64)&v10[v5];
    if ( (unsigned __int64)&v10[v5] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v12 = *((_QWORD *)Src + 3);
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        *((_QWORD *)Src + 2) = 0i64;
        if ( v12 < 8 )
          *(_WORD *)Src = 0;
        else
          **(_WORD **)Src = 0;
        return Src;
      }
    }
    else
    {
      sub_1400097B0(Src, (unsigned __int64)&v10[v5], v10);
      if ( !v11 )
        return Src;
    }
    v13 = *((_QWORD *)Src + 3);
    if ( v13 < 8 )
      v14 = (char *)Src;
    else
      v14 = *(char **)Src;
    if ( v13 < 8 )
      v15 = (char *)Src;
    else
      v15 = *(char **)Src;
    memmove(&v15[2 * v5], v14, 2i64 * *((_QWORD *)Src + 2));
    if ( Src == v7 )
    {
      if ( v6 )
        v6 += v5;
      v16 = *((_QWORD *)Src + 3);
      if ( v16 < 8 )
        v17 = (char *)Src;
      else
        v17 = *(char **)Src;
      if ( v16 < 8 )
        memmove(Src, &v17[2 * v6], 2 * v5);
      else
        memmove(*(void **)Src, &v17[2 * v6], 2 * v5);
    }
    else
    {
      if ( v7[3] >= 8ui64 )
        v7 = (_QWORD *)*v7;
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v18 = Src;
      else
        v18 = *(void **)Src;
      memmove(v18, (char *)v7 + 2 * v6, 2 * v5);
    }
    v19 = *((_QWORD *)Src + 3) < 8ui64;
    *((_QWORD *)Src + 2) = v11;
    if ( v19 )
      v20 = Src;
    else
      v20 = *(_WORD **)Src;
    v20[v11] = 0;
  }
  return Src;
}

//----- (000000014000BAC0) ----------------------------------------------------
void __fastcall sub_14000BAC0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_14000BB70(v4, *(_QWORD *)(v4 + 8), a3 + 2);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x1FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (000000014000BB70) ----------------------------------------------------
char *__fastcall sub_14000BB70(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x18ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
    *((_QWORD *)result + 2) = *a3;
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000BC10) ----------------------------------------------------
void __fastcall sub_14000BC10(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_14000B500(v4, *(_QWORD *)(v4 + 8), a3 + 2);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x3AEF6CA9705866i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (000000014000BCC0) ----------------------------------------------------
__int64 __fastcall sub_14000BCC0(__int64 a1, _QWORD *a2)
{
  *(_QWORD *)(a1 + 24) = 7i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_WORD *)a1 = 0;
  sub_140009610((void *)a1, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(a1 + 64) = 7i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_WORD *)(a1 + 40) = 0;
  sub_140009610((void *)(a1 + 40), a2 + 5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return a1;
}

//----- (000000014000BD40) ----------------------------------------------------
__int64 **__fastcall sub_14000BD40(__int64 **a1, __int64 **a2)
{
  __int64 *v3; // rax
  __int64 *v4; // rbx
  __int64 *v5; // rcx
  _QWORD *v6; // rdi
  __int64 *v7; // rsi

  if ( a1 != a2 )
  {
    v3 = *a1;
    v4 = *a2;
    v5 = (__int64 *)**a1;
    v6 = (_QWORD *)**a2;
    *v3 = (__int64)v3;
    (*a1)[1] = (__int64)*a1;
    a1[1] = 0i64;
    if ( v5 != *a1 )
    {
      do
      {
        v7 = (__int64 *)*v5;
        j_free(v5);
        v5 = v7;
      }
      while ( v7 != *a1 );
    }
    sub_14000BDC0((__int64)a1, **a1, v6, v4);
  }
  return a1;
}

//----- (000000014000BDC0) ----------------------------------------------------
void __fastcall sub_14000BDC0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_140017AD0(v4, *(_QWORD *)(v4 + 8), (_DWORD *)a3 + 4);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (000000014000BE80) ----------------------------------------------------
_QWORD *__fastcall sub_14000BE80(_QWORD *a1, char a2)
{
  *a1 = &loc_1400F7248;
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}

//----- (000000014000BEB0) ----------------------------------------------------
void *__fastcall sub_14000BEB0(_QWORD *a1)
{
  __int64 v2; // rbx
  void (__fastcall ***v3)(_QWORD, __int64); // rcx
  _QWORD *v4; // rax
  void *result; // rax

  *a1 = &std::tr1::_Node_assert::`vftable';
  v2 = a1[4];
  while ( v2 )
  {
    v3 = (void (__fastcall ***)(_QWORD, __int64))v2;
    v4 = (_QWORD *)(v2 + 16);
    v2 = *(_QWORD *)(v2 + 16);
    *v4 = 0i64;
    (**v3)(v3, 1i64);
  }
  result = &loc_1400F7248;
  *a1 = &loc_1400F7248;
  return result;
}
// 14000BEE8: conditional instruction was optimized away because rbx.8!=0
// 1400F7278: using guessed type void *std::tr1::_Node_assert::`vftable';

//----- (000000014000BF20) ----------------------------------------------------
void *__fastcall sub_14000BF20(void *Block, char a2)
{
  sub_14000BEB0(Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (000000014000BF50) ----------------------------------------------------
void *__fastcall sub_14000BF50(_QWORD *a1)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  _QWORD *v4; // rax
  __int64 v5; // rsi
  void (__fastcall ***v6)(_QWORD, __int64); // rcx
  _QWORD *v7; // rax
  void *result; // rax

  *a1 = &std::tr1::_Node_if::`vftable';
  v2 = a1[5];
  while ( v2 )
  {
    v3 = v2;
    v4 = (_QWORD *)(v2 + 40);
    v2 = *(_QWORD *)(v2 + 40);
    *v4 = 0i64;
    v5 = a1[4];
    while ( v3 != v5 )
    {
      if ( !v3 )
        break;
      v6 = (void (__fastcall ***)(_QWORD, __int64))v3;
      v7 = (_QWORD *)(v3 + 16);
      v3 = *(_QWORD *)(v3 + 16);
      *v7 = 0i64;
      (**v6)(v6, 1i64);
    }
  }
  result = &loc_1400F7248;
  *a1 = &loc_1400F7248;
  return result;
}
// 1400F72B8: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (000000014000BFF0) ----------------------------------------------------
void *__fastcall sub_14000BFF0(void *Block, char a2)
{
  sub_14000BF50(Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (000000014000C020) ----------------------------------------------------
__int64 __fastcall sub_14000C020(_QWORD *a1)
{
  void *v2; // rcx
  __int64 result; // rax

  v2 = (void *)a1[1];
  if ( v2 )
    j_free(v2);
  result = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  return result;
}

//----- (000000014000C050) ----------------------------------------------------
void __fastcall sub_14000C050(__int64 a1)
{
  struct std::ios_base *v1; // rbx

  v1 = (struct std::ios_base *)(a1 + 152);
  sub_14000C3E0(a1 + 152);
  *(_QWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';

//----- (000000014000C080) ----------------------------------------------------
__int64 __fastcall sub_14000C080(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rax
  void (__fastcall ***v11)(_QWORD, __int64); // rsi
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // rcx
  __int64 v17[2]; // [rsp+30h] [rbp-68h] BYREF
  char v18; // [rsp+40h] [rbp-58h] BYREF
  __int64 v19; // [rsp+48h] [rbp-50h]
  __int64 v20; // [rsp+50h] [rbp-48h]
  char v22[56]; // [rsp+60h] [rbp-38h] BYREF
  char v23; // [rsp+B8h] [rbp+20h] BYREF

  v17[1] = -2i64;
  v2 = 0;
  v20 = a1;
  v3 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  v4 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v4 + a1 + 16) )
  {
    v5 = *(_QWORD *)(v4 + a1 + 80);
    if ( v5 )
      sub_1400086F0(v5);
  }
  v6 = *(_QWORD *)a1;
  if ( *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 16) == 0 )
  {
    v7 = sub_140008F00(a1 + *(int *)(v6 + 4), v17);
    v8 = sub_14000F240((__int64)v7);
    v9 = v17[0];
    if ( v17[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v23, 0);
      v10 = *(_QWORD *)(v9 + 8);
      if ( v10 && v10 != -1 )
        *(_QWORD *)(v9 + 8) = v10 - 1;
      v11 = 0i64;
      if ( !*(_QWORD *)(v9 + 8) )
        v11 = (void (__fastcall ***)(_QWORD, __int64))v9;
      std::_Lockit::~_Lockit((std::_Lockit *)&v23);
      if ( v11 )
        (**v11)(v11, 1i64);
    }
    v12 = *(_QWORD *)(a1 + *(int *)(*(_QWORD *)a1 + 4i64) + 72);
    v18 = 0;
    v19 = v12;
    (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v8 + 56i64))(v8, v22, &v18);
    if ( v22[0] )
      v2 = 4;
  }
  v13 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v2 )
  {
    v14 = v2 | *(_DWORD *)(v13 + 16);
    if ( !*(_QWORD *)(v13 + 72) )
      LOBYTE(v14) = v14 | 4;
    sub_140009260(v13, v14, 0);
  }
  if ( !__uncaught_exception() )
    sub_1400154C0(a1);
  v15 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  return a1;
}
// 14000C080: could not find valid save-restore pair for rbp
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);
// 14000C080: using guessed type char var_38[56];

//----- (000000014000C260) ----------------------------------------------------
void __fastcall sub_14000C260(__int64 *a1)
{
  sub_14000CC60(a1);
  sub_140008FC0(a1 + 3);
}
// 14000C260: ignored the value written to the shadow area of the succeeding call

//----- (000000014000C290) ----------------------------------------------------
__int64 *__fastcall sub_14000C290(__int64 *a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  __int64 v7; // rax
  __int64 v8; // rdi
  char v10[112]; // [rsp+30h] [rbp-78h] BYREF

  if ( !a2 )
    std::tr1::_Xbad(13i64);
  v4 = -1i64;
  v5 = (_WORD *)a2;
  do
  {
    if ( !v4 )
      break;
    v6 = *v5++ == 0;
    --v4;
  }
  while ( !v6 );
  sub_14000F600((__int64)v10, (__int64)(a1 + 1), a2, a2 + 2 * (-v4 - 2), a3);
  v7 = sub_14000F6D0((__int64)v10);
  v8 = v7;
  if ( v7 )
    ++*(_DWORD *)(v7 + 40);
  sub_14000CC60(a1);
  *a1 = v8;
  return a1;
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (000000014000C330) ----------------------------------------------------
_QWORD *__fastcall sub_14000C330(_QWORD *a1)
{
  *a1 = &unk_1400F7230;
  a1[2] = &unk_1400F7238;
  a1[19] = &std::wios::`vftable';
  sub_1400025E0(a1, (__int64)(a1 + 3));
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = &std::wostream::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(*a1 + 4i64)) = &std::wiostream::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(*a1 + 4i64)) = &std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
  sub_14000CCE0((__int64)(a1 + 3), 3);
  return a1;
}
// 1400F6A50: using guessed type void *std::wios::`vftable';
// 1400F7218: using guessed type void *std::wiostream::`vftable';
// 1400F7228: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';

//----- (000000014000C3E0) ----------------------------------------------------
void **__fastcall sub_14000C3E0(__int64 a1)
{
  __int64 v1; // rbx
  void **result; // rax

  *(_QWORD *)(*(int *)(*(_QWORD *)(a1 - 152) + 4i64) + a1 - 152) = &std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
  v1 = a1 - 128;
  sub_140001E20(a1 - 128);
  *(_QWORD *)(*(int *)(*(_QWORD *)(v1 - 24) + 4i64) + v1 - 24) = &std::wiostream::`vftable';
  *(_QWORD *)(*(int *)(*(_QWORD *)(v1 - 8) + 4i64) + v1 - 8) = &std::wostream::`vftable';
  result = &std::wistream::`vftable';
  *(_QWORD *)(*(int *)(*(_QWORD *)(v1 - 24) + 4i64) + v1 - 24) = &std::wistream::`vftable';
  return result;
}
// 1400F6AE8: using guessed type void *std::wistream::`vftable';
// 1400F7218: using guessed type void *std::wiostream::`vftable';
// 1400F7228: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';

//----- (000000014000C460) ----------------------------------------------------
__int64 __fastcall sub_14000C460(__int64 a1, __int64 a2)
{
  sub_14000CD50(a1 + 24, a2);
  return a2;
}

//----- (000000014000C4E0) ----------------------------------------------------
__int64 __fastcall sub_14000C4E0(__int64 a1, char a2)
{
  __int64 v2; // rsi

  v2 = a1 - 152;
  sub_14000C3E0(a1);
  *(_QWORD *)(v2 + 152) = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)(v2 + 152));
  if ( (a2 & 1) != 0 )
    j_free((void *)v2);
  return v2;
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';

//----- (000000014000C540) ----------------------------------------------------
char *__fastcall sub_14000C540(struct std::ios_base *a1, char a2)
{
  char *v2; // rdi

  v2 = (char *)a1 - 24;
  *(_QWORD *)((char *)a1 + *(int *)(*((_QWORD *)a1 - 3) + 4i64) - 24) = &std::wiostream::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(*((_QWORD *)a1 - 1) + 4i64) - 8) = &std::wostream::`vftable';
  *(_QWORD *)((char *)a1 + *(int *)(*((_QWORD *)a1 - 3) + 4i64) - 24) = &std::wistream::`vftable';
  *(_QWORD *)a1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(a1);
  if ( (a2 & 1) != 0 )
    j_free(v2);
  return v2;
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';
// 1400F7218: using guessed type void *std::wiostream::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';

//----- (000000014000C5C0) ----------------------------------------------------
void *__fastcall sub_14000C5C0(void *Src, unsigned __int64 a2, char *a3, _QWORD *a4, __int64 a5, __int64 a6)
{
  _BYTE *v7; // r8
  _QWORD *v8; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r12
  unsigned __int64 v13; // rax
  signed __int64 v14; // rcx
  unsigned __int64 v15; // r14
  signed __int64 v16; // r15
  unsigned __int64 v17; // rax
  _WORD *v18; // rax
  unsigned __int64 v19; // rax
  _WORD *v20; // rdx
  _WORD *v21; // rcx
  _WORD *v22; // rax
  _WORD *v23; // rcx
  _WORD *v24; // rax
  unsigned __int64 v25; // r11
  _WORD *v26; // rdx
  _WORD *v27; // rcx
  size_t v28; // r8
  char *v29; // rdx
  char *v30; // rcx
  _WORD *v31; // rdx
  _WORD *v32; // rcx
  unsigned __int64 v33; // r11
  _WORD *v34; // rcx
  char *v35; // rdi
  _WORD *v36; // rdx
  _WORD *v37; // rcx
  unsigned __int64 v38; // r11
  _WORD *v39; // rcx
  _WORD *v40; // rax
  _WORD *v41; // rcx
  _WORD *v42; // rax
  unsigned __int64 v43; // r11
  _WORD *v44; // rax
  _WORD *v45; // rcx
  unsigned __int64 v46; // r11
  _WORD *v47; // rdx
  _WORD *v48; // rcx
  bool v49; // cf
  _WORD *v50; // rax

  v7 = (_BYTE *)*((_QWORD *)Src + 2);
  v8 = a4;
  if ( (unsigned __int64)v7 < a2 || (v11 = a4[2], v11 < a5) )
    sub_14002B630("invalid string position");
  v12 = a6;
  if ( &v7[-a2] < a3 )
    a3 = &v7[-a2];
  v13 = v11 - a5;
  if ( v13 < a6 )
    v12 = v13;
  v14 = v7 - a3;
  if ( -1i64 - v12 <= v7 - a3 )
    sub_14002B5F8("string too long");
  v15 = v14 + v12;
  v16 = &v7[-a2] - a3;
  if ( (unsigned __int64)v7 < v14 + v12 )
  {
    if ( v15 > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v17 = *((_QWORD *)Src + 3);
    if ( v17 >= v15 )
    {
      if ( !v15 )
      {
        *((_QWORD *)Src + 2) = 0i64;
        if ( v17 < 8 )
          v18 = Src;
        else
          v18 = *(_WORD **)Src;
        *v18 = 0;
      }
    }
    else
    {
      sub_1400097B0(Src, v15, v7);
    }
  }
  v19 = *((_QWORD *)Src + 3);
  if ( Src == v8 )
  {
    if ( v12 > (unsigned __int64)a3 )
    {
      if ( a5 > a2 )
      {
        v35 = &a3[a2];
        if ( (unsigned __int64)&a3[a2] > a5 )
        {
          if ( v19 < 8 )
            v41 = Src;
          else
            v41 = *(_WORD **)Src;
          if ( v19 < 8 )
            v42 = Src;
          else
            v42 = *(_WORD **)Src;
          memmove(&v42[a2], &v41[a5], 2i64 * (_QWORD)a3);
          v43 = *((_QWORD *)Src + 3);
          if ( v43 < 8 )
            v44 = Src;
          else
            v44 = *(_WORD **)Src;
          if ( v43 < 8 )
            v45 = Src;
          else
            v45 = *(_WORD **)Src;
          memmove(&v45[a2 + v12], &v44[(_QWORD)v35], 2 * v16);
          v46 = *((_QWORD *)Src + 3);
          if ( v46 < 8 )
            v47 = Src;
          else
            v47 = *(_WORD **)Src;
          if ( v46 < 8 )
            v48 = Src;
          else
            v48 = *(_WORD **)Src;
          v30 = (char *)&v48[(_QWORD)v35];
          v29 = (char *)&v47[v12 + a5];
          v28 = 2 * (v12 - (_QWORD)a3);
        }
        else
        {
          if ( v19 < 8 )
            v36 = Src;
          else
            v36 = *(_WORD **)Src;
          if ( v19 < 8 )
            v37 = Src;
          else
            v37 = *(_WORD **)Src;
          memmove(&v37[a2 + v12], &v36[(_QWORD)v35], 2 * v16);
          v38 = *((_QWORD *)Src + 3);
          if ( v38 < 8 )
            v39 = Src;
          else
            v39 = *(_WORD **)Src;
          if ( v38 < 8 )
            v40 = Src;
          else
            v40 = *(_WORD **)Src;
          v28 = 2 * v12;
          v29 = (char *)&v39[v12 + a5 - (_QWORD)a3];
          v30 = (char *)&v40[a2];
        }
      }
      else
      {
        if ( v19 < 8 )
          v31 = Src;
        else
          v31 = *(_WORD **)Src;
        if ( v19 < 8 )
          v32 = Src;
        else
          v32 = *(_WORD **)Src;
        memmove(&v32[a2 + v12], &v31[(_QWORD)&a3[a2]], 2 * v16);
        v33 = *((_QWORD *)Src + 3);
        if ( v33 < 8 )
          v34 = Src;
        else
          v34 = *(_WORD **)Src;
        v29 = (char *)&v34[a5];
        v28 = 2 * v12;
        if ( v33 < 8 )
          v30 = (char *)Src + 2 * a2;
        else
          v30 = (char *)(*(_QWORD *)Src + 2 * a2);
      }
    }
    else
    {
      if ( v19 < 8 )
        v23 = Src;
      else
        v23 = *(_WORD **)Src;
      if ( v19 < 8 )
        v24 = Src;
      else
        v24 = *(_WORD **)Src;
      memmove(&v24[a2], &v23[a5], 2 * v12);
      v25 = *((_QWORD *)Src + 3);
      if ( v25 < 8 )
        v26 = Src;
      else
        v26 = *(_WORD **)Src;
      if ( v25 < 8 )
        v27 = Src;
      else
        v27 = *(_WORD **)Src;
      v28 = 2 * v16;
      v29 = (char *)&v26[(_QWORD)&a3[a2]];
      v30 = (char *)&v27[a2 + v12];
    }
    memmove(v30, v29, v28);
  }
  else
  {
    if ( v19 < 8 )
      v20 = Src;
    else
      v20 = *(_WORD **)Src;
    if ( v19 < 8 )
      v21 = Src;
    else
      v21 = *(_WORD **)Src;
    memmove(&v21[a2 + v12], &v20[(_QWORD)&a3[a2]], 2 * v16);
    if ( v8[3] >= 8ui64 )
      v8 = (_QWORD *)*v8;
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v22 = Src;
    else
      v22 = *(_WORD **)Src;
    memmove(&v22[a2], (char *)v8 + 2 * a5, 2 * v12);
  }
  v49 = *((_QWORD *)Src + 3) < 8ui64;
  *((_QWORD *)Src + 2) = v15;
  if ( v49 )
    v50 = Src;
  else
    v50 = *(_WORD **)Src;
  v50[v15] = 0;
  return Src;
}

//----- (000000014000C940) ----------------------------------------------------
_QWORD *__fastcall sub_14000C940(void *Src, unsigned __int64 a2, char *a3, unsigned __int64 a4)
{
  _QWORD *v7; // rbx
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // r10
  char *v10; // rax
  char *v11; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r12
  unsigned __int64 v15; // rax
  _WORD *v16; // rdx
  _QWORD *v17; // rcx
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rax
  _QWORD *v21; // rdx
  _QWORD *v22; // rcx
  _QWORD *v23; // rax
  bool v24; // cf
  _QWORD *v25; // rcx

  v7 = Src;
  v8 = 2i64;
  if ( !a3 )
    goto LABEL_13;
  v9 = *((_QWORD *)Src + 3);
  v10 = v9 < 8 ? (char *)Src : *(char **)Src;
  if ( a3 < v10 )
    goto LABEL_13;
  if ( v9 >= 8 )
    Src = *(void **)Src;
  if ( (char *)Src + 2 * v7[2] <= a3 )
  {
LABEL_13:
    v13 = v7[2];
    if ( v13 < a2 )
      sub_14002B630("invalid string position");
    if ( v13 - a2 < 2 )
      v8 = v13 - a2;
    if ( -1i64 - a4 <= v13 - v8 )
      sub_14002B5F8("string too long");
    v14 = v13 - a2 - v8;
    if ( a4 < v8 )
    {
      v15 = v7[3];
      if ( v15 < 8 )
        v16 = v7;
      else
        v16 = (_WORD *)*v7;
      if ( v15 < 8 )
        v17 = v7;
      else
        v17 = (_QWORD *)*v7;
      memmove((char *)v17 + 2 * a2 + 2 * a4, &v16[a2 + v8], 2 * v14);
    }
    if ( !a4 && !v8 )
      return v7;
    v18 = a4 + v7[2] - v8;
    if ( v18 > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v19 = v7[3];
    if ( v19 >= v18 )
    {
      if ( v18 )
        goto LABEL_33;
      v7[2] = 0i64;
      if ( v19 < 8 )
        *(_WORD *)v7 = 0;
      else
        *(_WORD *)*v7 = 0;
    }
    else
    {
      sub_1400097B0(v7, a4 + v7[2] - v8, (const void *)v7[2]);
      if ( v18 )
      {
LABEL_33:
        if ( v8 < a4 )
        {
          v20 = v7[3];
          if ( v20 < 8 )
            v21 = v7;
          else
            v21 = (_QWORD *)*v7;
          if ( v20 < 8 )
            v22 = v7;
          else
            v22 = (_QWORD *)*v7;
          memmove((char *)v22 + 2 * a2 + 2 * a4, (char *)v21 + 2 * a2 + 2 * v8, 2 * v14);
        }
        if ( v7[3] < 8ui64 )
          v23 = v7;
        else
          v23 = (_QWORD *)*v7;
        memmove((char *)v23 + 2 * a2, a3, 2 * a4);
        v24 = v7[3] < 8ui64;
        v7[2] = v18;
        if ( v24 )
          v25 = v7;
        else
          v25 = (_QWORD *)*v7;
        *((_WORD *)v25 + v18) = 0;
      }
    }
    return v7;
  }
  if ( v9 < 8 )
    v11 = (char *)v7;
  else
    v11 = (char *)*v7;
  return sub_14000C5C0(v7, a2, (char *)2, v7, (a3 - v11) >> 1, a4);
}

//----- (000000014000CB60) ----------------------------------------------------
__int64 __fastcall sub_14000CB60(char *a1, _WORD *a2, unsigned __int64 a3)
{
  char *v5; // r11
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r10
  char *v9; // rdi
  unsigned __int64 v10; // rax
  char *v11; // rdx
  unsigned __int64 v12; // rcx
  _WORD *v13; // r8
  char *v14; // r9
  __int64 v15; // rcx

  v5 = a1;
  if ( !a3 )
    return 0i64;
  v7 = *((_QWORD *)a1 + 2);
  if ( v7 && a3 <= v7 )
  {
    v8 = 1 - a3 + v7;
    if ( *((_QWORD *)a1 + 3) < 8ui64 )
      v9 = a1;
    else
      v9 = *(char **)a1;
    while ( 1 )
    {
      v10 = v8;
      v11 = v9;
      if ( !v8 )
        break;
      while ( *(_WORD *)v11 != *a2 )
      {
        v11 += 2;
        if ( !--v10 )
          return -1i64;
      }
      if ( !v11 )
        break;
      v12 = a3;
      v13 = a2;
      v14 = v11;
      if ( !a3 )
      {
LABEL_16:
        if ( *((_QWORD *)v5 + 3) >= 8ui64 )
          v5 = *(char **)v5;
        return (v11 - v5) >> 1;
      }
      while ( *(_WORD *)v14 == *v13 )
      {
        v14 += 2;
        ++v13;
        if ( !--v12 )
          goto LABEL_16;
      }
      v15 = v11 - v9;
      v9 = v11 + 2;
      v8 += -1 - (v15 >> 1);
    }
  }
  return -1i64;
}
// 14000CC40: conditional instruction was optimized away because ecx.4 is in (==1|==FFFFFFFF)

//----- (000000014000CC60) ----------------------------------------------------
__int64 __fastcall sub_14000CC60(__int64 *a1)
{
  __int64 result; // rax
  bool v3; // zf
  __int64 v4; // rsi
  _QWORD *v5; // rax
  __int64 (__fastcall ***v6)(_QWORD, __int64); // rcx

  result = *a1;
  if ( *a1 && (v3 = *(_DWORD *)(result + 40) == 1, --*(_DWORD *)(result + 40), v3) )
  {
    v4 = *a1;
    if ( *a1 )
    {
      do
      {
        v5 = (_QWORD *)(v4 + 16);
        v6 = (__int64 (__fastcall ***)(_QWORD, __int64))v4;
        v4 = *(_QWORD *)(v4 + 16);
        *v5 = 0i64;
        result = (**v6)(v6, 1i64);
      }
      while ( v4 );
      *a1 = 0i64;
    }
    else
    {
      *a1 = 0i64;
    }
  }
  else
  {
    *a1 = 0i64;
  }
  return result;
}

//----- (000000014000CCE0) ----------------------------------------------------
__int64 __fastcall sub_14000CCE0(__int64 a1, char a2)
{
  int v4; // eax

  sub_140003840(a1);
  *(_QWORD *)a1 = &std::wstringbuf::`vftable';
  v4 = 0;
  if ( (a2 & 1) == 0 )
    v4 = 4;
  if ( (a2 & 2) == 0 )
    v4 |= 2u;
  if ( (a2 & 8) != 0 )
    v4 |= 8u;
  if ( (a2 & 4) != 0 )
    v4 |= 0x10u;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_DWORD *)(a1 + 120) = v4;
  return a1;
}
// 140003840: using guessed type __int64 __fastcall sub_140003840(_QWORD);
// 1400F6838: using guessed type void *std::wstringbuf::`vftable';

//----- (000000014000CD50) ----------------------------------------------------
__int64 __fastcall sub_14000CD50(__int64 a1, __int64 a2)
{
  int v4; // eax
  unsigned __int64 *v5; // rcx
  unsigned __int64 v6; // r8
  void *v7; // rdx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rcx
  _QWORD *v10; // r8
  __int64 v11; // r8
  void *v12; // rdx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rcx
  void *Block[2]; // [rsp+30h] [rbp-30h] BYREF
  __int64 v17; // [rsp+40h] [rbp-20h]
  unsigned __int64 v18; // [rsp+48h] [rbp-18h]

  v4 = *(_DWORD *)(a1 + 120);
  if ( (v4 & 2) != 0 || (v5 = *(unsigned __int64 **)(a1 + 72), !*v5) )
  {
    if ( (v4 & 4) != 0 || (v10 = *(_QWORD **)(a1 + 64), !*v10) )
    {
      v8 = 7i64;
      v18 = 7i64;
      v17 = 0i64;
      LOWORD(Block[0]) = 0;
      *(_QWORD *)(a2 + 24) = 7i64;
      *(_QWORD *)(a2 + 16) = 0i64;
      *(_WORD *)a2 = 0;
      if ( (void **)a2 == Block )
      {
        v8 = v18;
      }
      else
      {
        if ( *(_QWORD *)(a2 + 24) >= 8ui64 )
          j_free(*(void **)a2);
        *(_QWORD *)(a2 + 24) = 7i64;
        *(_QWORD *)(a2 + 16) = 0i64;
        *(_WORD *)a2 = 0;
        v14 = v18;
        if ( v18 >= 8 )
        {
          *(void **)a2 = Block[0];
          Block[0] = 0i64;
        }
        else
        {
          memmove((void *)a2, Block, 2 * v17 + 2);
          v14 = v18;
        }
        *(_QWORD *)(a2 + 16) = v17;
        *(_QWORD *)(a2 + 24) = v14;
        v18 = 7i64;
        v17 = 0i64;
        LOWORD(Block[0]) = 0;
      }
    }
    else
    {
      v11 = *v10 + 2i64 * **(int **)(a1 + 88);
      v12 = **(void ***)(a1 + 32);
      v8 = 7i64;
      v18 = 7i64;
      v17 = 0i64;
      LOWORD(Block[0]) = 0;
      sub_1400099E0(Block, v12, (v11 - (__int64)v12) >> 1);
      *(_QWORD *)(a2 + 24) = 7i64;
      *(_QWORD *)(a2 + 16) = 0i64;
      *(_WORD *)a2 = 0;
      if ( (void **)a2 == Block )
      {
        v8 = v18;
      }
      else
      {
        if ( *(_QWORD *)(a2 + 24) >= 8ui64 )
          j_free(*(void **)a2);
        *(_QWORD *)(a2 + 24) = 7i64;
        *(_QWORD *)(a2 + 16) = 0i64;
        *(_WORD *)a2 = 0;
        v13 = v18;
        if ( v18 >= 8 )
        {
          *(void **)a2 = Block[0];
          Block[0] = 0i64;
        }
        else
        {
          memmove((void *)a2, Block, 2 * v17 + 2);
          v13 = v18;
        }
        *(_QWORD *)(a2 + 16) = v17;
        *(_QWORD *)(a2 + 24) = v13;
        v18 = 7i64;
        v17 = 0i64;
        LOWORD(Block[0]) = 0;
      }
    }
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 112);
    if ( v6 < *v5 )
      v6 = *v5;
    v7 = **(void ***)(a1 + 40);
    v8 = 7i64;
    v18 = 7i64;
    v17 = 0i64;
    LOWORD(Block[0]) = 0;
    sub_1400099E0(Block, v7, (__int64)(v6 - (_QWORD)v7) >> 1);
    *(_QWORD *)(a2 + 24) = 7i64;
    *(_QWORD *)(a2 + 16) = 0i64;
    *(_WORD *)a2 = 0;
    if ( (void **)a2 == Block )
    {
      v8 = v18;
    }
    else
    {
      if ( *(_QWORD *)(a2 + 24) >= 8ui64 )
        j_free(*(void **)a2);
      *(_QWORD *)(a2 + 24) = 7i64;
      *(_QWORD *)(a2 + 16) = 0i64;
      *(_WORD *)a2 = 0;
      v9 = v18;
      if ( v18 >= 8 )
      {
        *(void **)a2 = Block[0];
        Block[0] = 0i64;
      }
      else
      {
        memmove((void *)a2, Block, 2 * v17 + 2);
        v9 = v18;
      }
      *(_QWORD *)(a2 + 16) = v17;
      *(_QWORD *)(a2 + 24) = v9;
      v18 = 7i64;
      v17 = 0i64;
      LOWORD(Block[0]) = 0;
    }
  }
  if ( v8 >= 8 )
    j_free(Block[0]);
  return a2;
}

//----- (000000014000D380) ----------------------------------------------------
__int128 *__fastcall sub_14000D380(
        __int64 a1,
        __int128 *a2,
        __int128 *a3,
        __int64 a4,
        unsigned __int16 a5,
        unsigned int a6)
{
  __int128 v6; // xmm0
  int v7; // eax
  char *v11; // rcx
  int v12; // edx
  char v13; // al
  int v14; // eax
  __int128 v16; // [rsp+40h] [rbp-88h] BYREF
  char Format; // [rsp+50h] [rbp-78h] BYREF
  char v18; // [rsp+51h] [rbp-77h] BYREF
  char v19; // [rsp+52h] [rbp-76h] BYREF
  char Buffer[64]; // [rsp+60h] [rbp-68h] BYREF

  v6 = *a3;
  v7 = *(_DWORD *)(a4 + 24);
  Format = 37;
  v11 = &v18;
  v16 = v6;
  if ( (v7 & 0x20) != 0 )
  {
    v18 = 43;
    v11 = &v19;
  }
  if ( (v7 & 8) != 0 )
    *v11++ = 35;
  *v11 = 108;
  v12 = v7 & 0xE00;
  if ( v12 == 1024 )
  {
    v13 = 111;
  }
  else if ( v12 == 2048 )
  {
    v13 = ~(8 * v7) & 0x20 | 0x58;
  }
  else
  {
    v13 = 100;
  }
  v11[1] = v13;
  v11[2] = 0;
  v14 = sprintf_s(Buffer, 0x40ui64, &Format, a6);
  sub_14000E7A0(a1, a2, (__int64)&v16, a4, a5, Buffer, v14);
  return a2;
}

//----- (000000014000D480) ----------------------------------------------------
__int128 *__fastcall sub_14000D480(
        __int64 a1,
        __int128 *a2,
        __int128 *a3,
        __int64 a4,
        unsigned __int16 a5,
        unsigned int a6)
{
  __int128 v6; // xmm0
  int v7; // eax
  char *v11; // rcx
  int v12; // edx
  char v13; // al
  int v14; // eax
  __int128 v16; // [rsp+40h] [rbp-88h] BYREF
  char Format; // [rsp+50h] [rbp-78h] BYREF
  char v18; // [rsp+51h] [rbp-77h] BYREF
  char v19; // [rsp+52h] [rbp-76h] BYREF
  char Buffer[64]; // [rsp+60h] [rbp-68h] BYREF

  v6 = *a3;
  v7 = *(_DWORD *)(a4 + 24);
  Format = 37;
  v11 = &v18;
  v16 = v6;
  if ( (v7 & 0x20) != 0 )
  {
    v18 = 43;
    v11 = &v19;
  }
  if ( (v7 & 8) != 0 )
    *v11++ = 35;
  *v11 = 108;
  v12 = v7 & 0xE00;
  if ( v12 == 1024 )
  {
    v13 = 111;
  }
  else if ( v12 == 2048 )
  {
    v13 = ~(8 * v7) & 0x20 | 0x58;
  }
  else
  {
    v13 = 117;
  }
  v11[1] = v13;
  v11[2] = 0;
  v14 = sprintf_s(Buffer, 0x40ui64, &Format, a6);
  sub_14000E7A0(a1, a2, (__int64)&v16, a4, a5, Buffer, v14);
  return a2;
}

//----- (000000014000D580) ----------------------------------------------------
__int128 *__fastcall sub_14000D580(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, unsigned __int16 a5, __int64 a6)
{
  __int128 v6; // xmm0
  int v8; // ecx
  char *v11; // rax
  int v12; // edx
  char v13; // cl
  int v14; // eax
  __int128 v16; // [rsp+40h] [rbp-88h] BYREF
  char Format; // [rsp+50h] [rbp-78h] BYREF
  char v18; // [rsp+51h] [rbp-77h] BYREF
  char v19; // [rsp+52h] [rbp-76h] BYREF
  char Buffer[64]; // [rsp+60h] [rbp-68h] BYREF

  v6 = *a3;
  v8 = *(_DWORD *)(a4 + 24);
  Format = 37;
  v11 = &v18;
  v16 = v6;
  if ( (v8 & 0x20) != 0 )
  {
    v18 = 43;
    v11 = &v19;
  }
  if ( (v8 & 8) != 0 )
    *v11++ = 35;
  *(_WORD *)v11 = 13897;
  v11[2] = 52;
  v12 = v8 & 0xE00;
  if ( v12 == 1024 )
  {
    v13 = 111;
  }
  else if ( v12 == 2048 )
  {
    v13 = ~(8 * v8) & 0x20 | 0x58;
  }
  else
  {
    v13 = 100;
  }
  v11[3] = v13;
  v11[4] = 0;
  v14 = sprintf_s(Buffer, 0x40ui64, &Format, a6);
  sub_14000E7A0(a1, a2, (__int64)&v16, a4, a5, Buffer, v14);
  return a2;
}

//----- (000000014000D680) ----------------------------------------------------
__int128 *__fastcall sub_14000D680(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, unsigned __int16 a5, __int64 a6)
{
  __int128 v6; // xmm0
  int v8; // ecx
  char *v11; // rax
  int v12; // edx
  char v13; // cl
  int v14; // eax
  __int128 v16; // [rsp+40h] [rbp-88h] BYREF
  char Format; // [rsp+50h] [rbp-78h] BYREF
  char v18; // [rsp+51h] [rbp-77h] BYREF
  char v19; // [rsp+52h] [rbp-76h] BYREF
  char Buffer[64]; // [rsp+60h] [rbp-68h] BYREF

  v6 = *a3;
  v8 = *(_DWORD *)(a4 + 24);
  Format = 37;
  v11 = &v18;
  v16 = v6;
  if ( (v8 & 0x20) != 0 )
  {
    v18 = 43;
    v11 = &v19;
  }
  if ( (v8 & 8) != 0 )
    *v11++ = 35;
  *(_WORD *)v11 = 13897;
  v11[2] = 52;
  v12 = v8 & 0xE00;
  if ( v12 == 1024 )
  {
    v13 = 111;
  }
  else if ( v12 == 2048 )
  {
    v13 = ~(8 * v8) & 0x20 | 0x58;
  }
  else
  {
    v13 = 117;
  }
  v11[3] = v13;
  v11[4] = 0;
  v14 = sprintf_s(Buffer, 0x40ui64, &Format, a6);
  sub_14000E7A0(a1, a2, (__int64)&v16, a4, a5, Buffer, v14);
  return a2;
}

//----- (000000014000D780) ----------------------------------------------------
__int128 *__fastcall sub_14000D780(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, __int16 a5, __int64 a6)
{
  __int64 v6; // rbx
  int v10; // edx
  double v11; // xmm1_8
  int v12; // er9
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rdi
  __int64 v15; // rbx
  __int128 v16; // xmm0
  char *v17; // rax
  int v18; // edx
  char v19; // cl
  int v20; // eax
  int v22[4]; // [rsp+50h] [rbp-D8h] BYREF
  char Format; // [rsp+60h] [rbp-C8h] BYREF
  char v24; // [rsp+61h] [rbp-C7h] BYREF
  char v25; // [rsp+62h] [rbp-C6h] BYREF
  char Buffer[112]; // [rsp+70h] [rbp-B8h] BYREF

  v6 = *(_QWORD *)(a4 + 32);
  if ( v6 <= 0 && (*(_DWORD *)(a4 + 24) & 0x2000) == 0 )
    v6 = 6i64;
  v10 = *(_DWORD *)(a4 + 24);
  v11 = *(double *)&a6;
  v12 = v6;
  if ( v6 > 36 )
    v12 = 36;
  v13 = 0i64;
  v14 = 0i64;
  v15 = v6 - v12;
  if ( (v10 & 0x3000) == 0x2000 && *(double *)&a6 * 0.5 != *(double *)&a6 )
  {
    if ( *(double *)&a6 < 0.0 )
      v11 = -*(double *)&a6;
    for ( ; v11 >= 1.0e35; v13 += 10i64 )
    {
      if ( v13 >= 0x1388 )
        break;
      v11 = v11 / 1.0e10;
    }
    if ( v11 > 0.0 && v15 >= 10 )
    {
      do
      {
        if ( v11 > 1.0e-35 )
          break;
        if ( v14 >= 0x1388 )
          break;
        v15 -= 10i64;
        v14 += 10i64;
        v11 = v11 * 1.0e10;
      }
      while ( v15 >= 10 );
    }
  }
  v16 = *a3;
  Format = 37;
  v17 = &v24;
  *(_OWORD *)v22 = v16;
  if ( (v10 & 0x20) != 0 )
  {
    v24 = 43;
    v17 = &v25;
  }
  if ( (v10 & 0x10) != 0 )
    *v17++ = 35;
  v18 = v10 & 0x3000;
  *(_WORD *)v17 = 10798;
  if ( v18 == 0x2000 )
  {
    v19 = 102;
  }
  else if ( v18 == 12288 )
  {
    v19 = 97;
  }
  else
  {
    v19 = 103;
    if ( v18 == 4096 )
      v19 = 101;
  }
  v17[2] = v19;
  v17[3] = 0;
  v20 = sprintf_s(Buffer, 0x6Cui64, &Format);
  sub_14000DC60(a1, a2, (__int128 *)v22, a4, a5, Buffer, v13, v14, v15, v20);
  return a2;
}

//----- (000000014000D990) ----------------------------------------------------
__int128 *__fastcall sub_14000D990(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, __int16 a5, __int64 a6)
{
  __int64 v6; // rbx
  int v10; // edx
  double v11; // xmm1_8
  int v12; // er9
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rdi
  __int64 v15; // rbx
  __int128 v16; // xmm0
  char *v17; // rax
  int v18; // edx
  char v19; // cl
  int v20; // eax
  int v22[4]; // [rsp+50h] [rbp-D8h] BYREF
  char Format; // [rsp+60h] [rbp-C8h] BYREF
  char v24; // [rsp+61h] [rbp-C7h] BYREF
  char v25; // [rsp+62h] [rbp-C6h] BYREF
  char Buffer[112]; // [rsp+70h] [rbp-B8h] BYREF

  v6 = *(_QWORD *)(a4 + 32);
  if ( v6 <= 0 && (*(_DWORD *)(a4 + 24) & 0x2000) == 0 )
    v6 = 6i64;
  v10 = *(_DWORD *)(a4 + 24);
  v11 = *(double *)&a6;
  v12 = v6;
  if ( v6 > 36 )
    v12 = 36;
  v13 = 0i64;
  v14 = 0i64;
  v15 = v6 - v12;
  if ( (v10 & 0x3000) == 0x2000 )
  {
    if ( *(double *)&a6 < 0.0 )
      v11 = -*(double *)&a6;
    for ( ; v11 >= 1.0e35; v13 += 10i64 )
    {
      if ( v13 >= 0x1388 )
        break;
      v11 = v11 / 1.0e10;
    }
    if ( v11 > 0.0 && v15 >= 10 )
    {
      do
      {
        if ( v11 > 1.0e-35 )
          break;
        if ( v14 >= 0x1388 )
          break;
        v15 -= 10i64;
        v14 += 10i64;
        v11 = v11 * 1.0e10;
      }
      while ( v15 >= 10 );
    }
  }
  v16 = *a3;
  Format = 37;
  v17 = &v24;
  *(_OWORD *)v22 = v16;
  if ( (v10 & 0x20) != 0 )
  {
    v24 = 43;
    v17 = &v25;
  }
  if ( (v10 & 0x10) != 0 )
    *v17++ = 35;
  v18 = v10 & 0x3000;
  *(_WORD *)v17 = 10798;
  v17[2] = 76;
  if ( v18 == 0x2000 )
  {
    v19 = 102;
  }
  else if ( v18 == 12288 )
  {
    v19 = 97;
  }
  else
  {
    v19 = 103;
    if ( v18 == 4096 )
      v19 = 101;
  }
  v17[3] = v19;
  v17[4] = 0;
  v20 = sprintf_s(Buffer, 0x6Cui64, &Format);
  sub_14000DC60(a1, a2, (__int128 *)v22, a4, a5, Buffer, v13, v14, v15, v20);
  return a2;
}

//----- (000000014000DC30) ----------------------------------------------------
_QWORD *__fastcall sub_14000DC30(_QWORD *a1, char a2)
{
  *a1 = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';

//----- (000000014000DC60) ----------------------------------------------------
__int128 *__fastcall sub_14000DC60(
        __int64 a1,
        __int128 *a2,
        __int128 *a3,
        __int64 a4,
        __int16 a5,
        void *Buf,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        size_t MaxCount)
{
  unsigned __int16 v10; // r15
  _BYTE *v11; // rbx
  __int64 v12; // rsi
  size_t v14; // r12
  __int64 *v15; // rax
  __int64 v16; // r13
  __int64 v17; // rdi
  __int64 v18; // rax
  void (__fastcall ***v19)(_QWORD, __int64); // rbx
  int v20; // eax
  __int64 v21; // r13
  _BYTE *v22; // rdi
  _BYTE *v23; // rbx
  __int64 v24; // r9
  void **v25; // rcx
  unsigned __int64 Wchar_low; // r8
  void **v27; // rax
  _BYTE *v28; // r12
  size_t v29; // rbx
  void **v30; // rdi
  void **v31; // rcx
  size_t v32; // rsi
  char v33; // cl
  size_t v34; // rbx
  bool v35; // zf
  void **v36; // rax
  void **v37; // rdx
  void **v38; // rcx
  void **v39; // r11
  void **v40; // rax
  char *v41; // rdi
  size_t v42; // rax
  __int64 v43; // rsi
  size_t v44; // rsi
  int v45; // eax
  __int64 v46; // rbx
  __int128 v47; // xmm0
  __int64 v48; // rbx
  int *v49; // rax
  __int16 **v50; // rcx
  __int16 *v51; // rdx
  __int16 v52; // ax
  __int128 v53; // xmm6
  __int64 v54; // rcx
  int *v55; // rax
  _WORD **v56; // rcx
  _WORD *v57; // rdx
  __int64 v58; // rbx
  int *v59; // rax
  __int16 **v60; // rcx
  __int16 *v61; // rdx
  __int16 v62; // ax
  _BYTE *v63; // rax
  wchar_t v64; // di
  __int64 v65; // r13
  __int128 *v66; // r11
  __int128 v67; // xmm6
  _QWORD *v68; // rbx
  __int64 v69; // r8
  int *v70; // rax
  _WORD **v71; // rcx
  wchar_t *v72; // rdx
  wchar_t v73; // ax
  unsigned __int16 v74; // r11
  int *v75; // rax
  unsigned __int16 **v76; // rcx
  unsigned __int16 *v77; // rdx
  __int128 *v78; // rax
  __int64 v79; // r8
  _QWORD *v80; // rbx
  int *v81; // rax
  _WORD **v82; // rcx
  wchar_t *v83; // rdx
  wchar_t v84; // ax
  char *v85; // rbx
  _BYTE *v86; // rax
  __int64 v87; // r13
  __int128 *v88; // r11
  __int64 v89; // rcx
  __int128 v90; // xmm6
  __int64 v91; // rbx
  int *v92; // rax
  wchar_t **v93; // rcx
  wchar_t *v94; // rdx
  wchar_t v95; // ax
  char *v96; // rax
  wchar_t v97; // r8
  int *v98; // rax
  wchar_t **v99; // rcx
  wchar_t *v100; // rdx
  __int128 *v101; // r13
  __int128 *v102; // r11
  __int128 v103; // xmm0
  __int64 v104; // rbx
  int *v105; // rax
  wchar_t **v106; // rcx
  wchar_t *v107; // rdx
  wchar_t v108; // ax
  __int128 v109; // xmm0
  __int64 v110; // rbx
  int *v111; // rax
  unsigned __int16 **v112; // rcx
  unsigned __int16 *v113; // rdx
  unsigned __int16 v114; // ax
  __int128 *v115; // rbx
  char v117[16]; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v118; // [rsp+40h] [rbp-C0h] BYREF
  wchar_t v119[2]; // [rsp+50h] [rbp-B0h] BYREF
  char Control; // [rsp+54h] [rbp-ACh] BYREF
  __int16 v121; // [rsp+55h] [rbp-ABh]
  unsigned __int16 v122; // [rsp+58h] [rbp-A8h]
  __int16 v123; // [rsp+5Ah] [rbp-A6h]
  __int128 *v124; // [rsp+60h] [rbp-A0h]
  void *v125; // [rsp+68h] [rbp-98h]
  mbstate_t v126; // [rsp+70h] [rbp-90h] BYREF
  __int64 v127; // [rsp+78h] [rbp-88h]
  __int64 v128; // [rsp+80h] [rbp-80h]
  __int64 v129; // [rsp+88h] [rbp-78h]
  __int64 v130; // [rsp+90h] [rbp-70h]
  __int128 *v131; // [rsp+98h] [rbp-68h]
  __int64 v132; // [rsp+A0h] [rbp-60h]
  __int64 v133; // [rsp+A8h] [rbp-58h] BYREF
  __int128 v134; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v135; // [rsp+C0h] [rbp-40h]
  void *Block[2]; // [rsp+C8h] [rbp-38h] BYREF
  size_t v137; // [rsp+D8h] [rbp-28h]
  unsigned __int64 v138; // [rsp+E0h] [rbp-20h]
  void *v139[3]; // [rsp+F0h] [rbp-10h] BYREF
  unsigned __int64 v140; // [rsp+108h] [rbp+8h]

  v135 = -2i64;
  v130 = a4;
  v124 = a3;
  v131 = a2;
  v127 = a1;
  v10 = a5;
  v123 = a5;
  v11 = Buf;
  v125 = Buf;
  v12 = a7;
  v129 = a7;
  v128 = a8;
  v14 = MaxCount;
  v15 = sub_140008F00(a4, &v133);
  v16 = sub_140007200(v15);
  v132 = v16;
  v17 = v133;
  if ( v133 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v119, 0);
    v18 = *(_QWORD *)(v17 + 8);
    if ( v18 && v18 != -1 )
      *(_QWORD *)(v17 + 8) = v18 - 1;
    v19 = 0i64;
    if ( !*(_QWORD *)(v17 + 8) )
      v19 = (void (__fastcall ***)(_QWORD, __int64))v17;
    std::_Lockit::~_Lockit((std::_Lockit *)v119);
    if ( v19 )
      (**v19)(v19, 1i64);
    v11 = v125;
  }
  unknown_libname_3(v16, v139);
  v122 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
  v138 = 15i64;
  v137 = 0i64;
  LOBYTE(Block[0]) = 0;
  v117[0] = 48;
  v119[0] = 0;
  v126._Wchar = 0;
  Mbrtowc(v119, v117, 1ui64, &v126, (const _Cvtvec *)(v127 + 16));
  if ( *v11 == 43 || (v20 = 0, *v11 == 45) )
    v20 = 1;
  v21 = v20;
  Control = *localeconv()->decimal_point;
  v121 = 101;
  v22 = memchr(v11, 101, MaxCount);
  v23 = memchr(v11, Control, MaxCount);
  v24 = 0i64;
  if ( !v23 )
    a9 = 0i64;
  v25 = v139;
  Wchar_low = v140;
  if ( v140 >= 0x10 )
    v25 = (void **)v139[0];
  if ( *(_BYTE *)v25 == 127 )
    goto LABEL_66;
  v27 = v139;
  if ( v140 >= 0x10 )
    v27 = (void **)v139[0];
  if ( *(char *)v27 <= 0 )
  {
LABEL_66:
    v41 = (char *)v125;
  }
  else
  {
    v28 = v125;
    sub_14000EC20(Block, v125, MaxCount);
    if ( v22 )
    {
      if ( !v23 )
      {
        sub_1400055C0(Block, a7, 48);
        v12 = 0i64;
      }
      sub_1400152E0(Block, v22 - v28, a9, 48);
    }
    else
    {
      sub_1400055C0(Block, a9, 48);
    }
    if ( v23 )
    {
      v29 = v23 - v28;
      sub_1400152E0(Block, v29 + 1, v128, 48);
      sub_1400152E0(Block, v29, v12, 48);
      a9 = 0i64;
      v128 = 0i64;
    }
    else
    {
      sub_1400055C0(Block, v12, 48);
      a9 = 0i64;
    }
    v129 = 0i64;
    v30 = v139;
    if ( v140 >= 0x10 )
      v30 = (void **)v139[0];
    v31 = Block;
    if ( v138 >= 0x10 )
      v31 = (void **)Block[0];
    v32 = strcspn((const char *)v31, &Control);
    v33 = *(_BYTE *)v30;
    Wchar_low = v138;
    v14 = v137;
    if ( *(_BYTE *)v30 != 127 )
    {
      while ( 1 )
      {
        if ( v33 <= 0 || v33 >= v32 - v21 )
          goto LABEL_63;
        v32 -= v33;
        if ( v14 < v32 )
          sub_14002B630("invalid string position");
        if ( v14 == -1i64 || v14 == -2i64 )
          sub_14002B5F8("string too long");
        v34 = v14 + 1;
        if ( v14 == -2i64 )
          sub_14002B5F8("string too long");
        if ( Wchar_low < v34 )
          break;
        v35 = v34 == 0;
        if ( v14 == -1i64 )
        {
          v137 = 0i64;
          v36 = Block;
          if ( Wchar_low >= 0x10 )
            v36 = (void **)Block[0];
          *(_BYTE *)v36 = 0;
          goto LABEL_45;
        }
LABEL_46:
        if ( !v35 )
        {
          v37 = Block;
          if ( Wchar_low >= 0x10 )
            v37 = (void **)Block[0];
          v38 = Block;
          if ( Wchar_low >= 0x10 )
            v38 = (void **)Block[0];
          memmove((char *)v38 + v32 + 1, (char *)v37 + v32, v14 - v32);
          v39 = Block;
          if ( v138 >= 0x10 )
            v39 = (void **)Block[0];
          *((_BYTE *)v39 + v32) = 0;
          v137 = v34;
          v40 = Block;
          if ( v138 >= 0x10 )
            v40 = (void **)Block[0];
          *((_BYTE *)v40 + v34) = 0;
          Wchar_low = v138;
          v14 = v137;
        }
        if ( *((char *)v30 + 1) > 0 )
          v30 = (void **)((char *)v30 + 1);
        v33 = *(_BYTE *)v30;
        if ( *(_BYTE *)v30 == 127 )
          goto LABEL_63;
      }
      sub_140007EF0(Block, v14 + 1, v14);
LABEL_45:
      v14 = v137;
      Wchar_low = v138;
      v35 = v34 == 0;
      goto LABEL_46;
    }
LABEL_63:
    v41 = (char *)Block;
    if ( Wchar_low >= 0x10 )
      v41 = (char *)Block[0];
    v125 = v41;
    v12 = 0i64;
    v24 = 0i64;
  }
  v42 = v12 + v128 + v14 + a9;
  v43 = *(_QWORD *)(v130 + 40);
  if ( v43 <= 0 || v43 <= v42 )
    v44 = 0i64;
  else
    v44 = v43 - v42;
  v45 = *(_DWORD *)(v130 + 24) & 0x1C0;
  v46 = (__int64)v124;
  if ( v45 != 64 )
  {
    if ( v45 == 256 )
    {
      if ( v21 )
      {
        v53 = *v124;
        v118 = *v124;
        v117[0] = *v41;
        LOWORD(v126._Wchar) = 0;
        *(_DWORD *)&v126._Byte = 0;
        Mbrtowc((wchar_t *)&v126, v117, 1ui64, (mbstate_t *)&v126._Byte, (const _Cvtvec *)(v127 + 16));
        v54 = *((_QWORD *)&v118 + 1);
        if ( !*((_QWORD *)&v118 + 1)
          || ((Wchar_low = LOWORD(v126._Wchar), !**(_QWORD **)(*((_QWORD *)&v118 + 1) + 72i64))
           || (v55 = *(int **)(*((_QWORD *)&v118 + 1) + 96i64), *v55 <= 0) ? (Wchar_low = (*(unsigned __int16 (__fastcall **)(_QWORD, _QWORD))(**((_QWORD **)&v118 + 1) + 24i64))(
                                                                                            *((_QWORD *)&v118 + 1),
                                                                                            LOWORD(v126._Wchar))) : (--*v55, v56 = *(_WORD ***)(v54 + 72), v57 = *v56, ++*v56, *v57 = Wchar_low),
              (_WORD)Wchar_low == 0xFFFF) )
        {
          LOBYTE(v118) = 1;
          v53 = v118;
        }
        *(_OWORD *)v46 = v53;
        v125 = ++v41;
        --v14;
      }
      v47 = *(_OWORD *)v46;
      v118 = *(_OWORD *)v46;
      if ( !v44 )
        goto LABEL_84;
      v58 = *((_QWORD *)&v118 + 1);
      do
      {
        if ( !v58
          || (!**(_QWORD **)(v58 + 72) || (v59 = *(int **)(v58 + 96), *v59 <= 0) ? (v62 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int64, __int64))(*(_QWORD *)v58 + 24i64))(
                                                                                            v58,
                                                                                            (unsigned __int16)a5,
                                                                                            Wchar_low,
                                                                                            v24)) : (--*v59, v60 = *(__int16 ***)(v58 + 72), v61 = *v60, ++*v60, *v61 = a5, v62 = a5),
              v62 == -1) )
        {
          LOBYTE(v118) = 1;
        }
        --v44;
      }
      while ( v44 );
    }
    else
    {
      v47 = *v124;
      v118 = *v124;
      if ( !v44 )
      {
LABEL_84:
        *(_OWORD *)v46 = v47;
        v44 = 0i64;
        goto LABEL_105;
      }
      v48 = *((_QWORD *)&v118 + 1);
      do
      {
        if ( !v48
          || (!**(_QWORD **)(v48 + 72) || (v49 = *(int **)(v48 + 96), *v49 <= 0) ? (v52 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int64, __int64))(*(_QWORD *)v48 + 24i64))(
                                                                                            v48,
                                                                                            (unsigned __int16)a5,
                                                                                            Wchar_low,
                                                                                            v24)) : (--*v49, v50 = *(__int16 ***)(v48 + 72), v51 = *v50, ++*v50, *v51 = a5, v52 = a5),
              v52 == -1) )
        {
          LOBYTE(v118) = 1;
        }
        --v44;
      }
      while ( v44 );
    }
    v47 = v118;
    v46 = (__int64)v124;
    goto LABEL_84;
  }
LABEL_105:
  v63 = memchr(v41, Control, v14);
  v64 = v119[0];
  if ( v63 )
  {
    v65 = v63 - (_BYTE *)v125 + 1;
    v118 = *(_OWORD *)v46;
    v66 = sub_14000EE60(v127, &v134, &v118, (char *)v125, v63 - (_BYTE *)v125, v122);
    *(_QWORD *)v46 = *(_QWORD *)v66;
    *(_QWORD *)(v46 + 8) = *((_QWORD *)v66 + 1);
    v67 = *v66;
    v118 = *v66;
    v68 = (_QWORD *)*((_QWORD *)&v118 + 1);
    v69 = v129;
    if ( v129 )
    {
      do
      {
        if ( !v68 )
          goto LABEL_113;
        if ( *(_QWORD *)v68[9] && (v70 = (int *)v68[12], *v70 > 0) )
        {
          --*v70;
          v71 = (_WORD **)v68[9];
          v72 = (*v71)++;
          *v72 = v64;
          v73 = v64;
        }
        else
        {
          v73 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v68 + 24i64))(v68, v64);
          v69 = v129;
        }
        if ( v73 == 0xFFFF )
LABEL_113:
          LOBYTE(v118) = 1;
        v129 = --v69;
      }
      while ( v69 );
      v67 = v118;
      v10 = v123;
    }
    *v124 = v67;
    v118 = v67;
    v74 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v132 + 8i64))(v132);
    if ( !v68
      || (!*(_QWORD *)v68[9] || (v75 = (int *)v68[12], *v75 <= 0) ? (v74 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v68 + 24i64))(
                                                                             v68,
                                                                             v74)) : (--*v75,
                                                                                      v76 = (unsigned __int16 **)v68[9],
                                                                                      v77 = *v76,
                                                                                      ++*v76,
                                                                                      *v77 = v74),
          v74 == 0xFFFF) )
    {
      LOBYTE(v118) = 1;
      v67 = v118;
    }
    v78 = v124;
    *v124 = v67;
    v118 = v67;
    v79 = v128;
    if ( v128 )
    {
      v80 = (_QWORD *)*((_QWORD *)&v118 + 1);
      do
      {
        if ( !v80 )
          goto LABEL_131;
        if ( *(_QWORD *)v80[9] && (v81 = (int *)v80[12], *v81 > 0) )
        {
          --*v81;
          v82 = (_WORD **)v80[9];
          v83 = (*v82)++;
          *v83 = v64;
          v84 = v64;
        }
        else
        {
          v84 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v80 + 24i64))(v80, v64);
          v79 = v128;
        }
        if ( v84 == 0xFFFF )
LABEL_131:
          LOBYTE(v118) = 1;
        v128 = --v79;
      }
      while ( v79 );
      v67 = v118;
      v10 = v123;
      v78 = v124;
    }
    *v78 = v67;
    v85 = (char *)v125 + v65;
    v125 = (char *)v125 + v65;
    v14 -= v65;
  }
  else
  {
    v85 = (char *)v125;
  }
  v86 = memchr(v85, 101, v14);
  if ( v86 )
  {
    v87 = v86 - v85 + 1;
    v118 = *v124;
    v88 = sub_14000EE60(v127, &v134, &v118, v85, v86 - v85, v122);
    v89 = (__int64)v124;
    *(_QWORD *)v124 = *(_QWORD *)v88;
    *(_QWORD *)(v89 + 8) = *((_QWORD *)v88 + 1);
    v90 = *v88;
    v118 = *v88;
    v91 = *((_QWORD *)&v118 + 1);
    if ( a9 )
    {
      do
      {
        if ( !v91
          || (!**(_QWORD **)(v91 + 72) || (v92 = *(int **)(v91 + 96), *v92 <= 0) ? (v95 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v91 + 24i64))(
                                                                                            v91,
                                                                                            v64)) : (--*v92, v93 = *(wchar_t ***)(v91 + 72), v94 = *v93, ++*v93, *v94 = v64, v95 = v64),
              v95 == 0xFFFF) )
        {
          LOBYTE(v118) = 1;
        }
        --a9;
      }
      while ( a9 );
      v90 = v118;
      v10 = v123;
      v89 = (__int64)v124;
    }
    *(_OWORD *)v89 = v90;
    a9 = 0i64;
    v118 = v90;
    v96 = "e";
    if ( (*(_BYTE *)(v130 + 24) & 4) != 0 )
      v96 = "E";
    v117[0] = *v96;
    v119[0] = 0;
    *(_DWORD *)&v126._Byte = 0;
    Mbrtowc(v119, v117, 1ui64, (mbstate_t *)&v126._Byte, (const _Cvtvec *)(v127 + 16));
    if ( !v91
      || ((v97 = v119[0], !**(_QWORD **)(v91 + 72)) || (v98 = *(int **)(v91 + 96), *v98 <= 0) ? (v97 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v91 + 24i64))(v91, v119[0])) : (--*v98, v99 = *(wchar_t ***)(v91 + 72), v100 = *v99, ++*v99, *v100 = v97),
          v97 == 0xFFFF) )
    {
      LOBYTE(v118) = 1;
      v90 = v118;
    }
    *v124 = v90;
    v85 = (char *)v125 + v87;
    v14 -= v87;
  }
  v101 = v124;
  v118 = *v124;
  v102 = sub_14000EE60(v127, &v134, &v118, v85, v14, v122);
  *(_QWORD *)v101 = *(_QWORD *)v102;
  *((_QWORD *)v101 + 1) = *((_QWORD *)v102 + 1);
  v103 = *v102;
  v118 = *v102;
  if ( a9 )
  {
    v104 = *((_QWORD *)&v118 + 1);
    do
    {
      if ( !v104
        || (!**(_QWORD **)(v104 + 72) || (v105 = *(int **)(v104 + 96), *v105 <= 0) ? (v108 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v104 + 24i64))(
                                                                                               v104,
                                                                                               v64)) : (--*v105, v106 = *(wchar_t ***)(v104 + 72), v107 = *v106, ++*v106, *v107 = v64, v108 = v64),
            v108 == 0xFFFF) )
      {
        LOBYTE(v118) = 1;
      }
      --a9;
    }
    while ( a9 );
    v103 = v118;
    v101 = v124;
  }
  *v101 = v103;
  *(_QWORD *)(v130 + 40) = 0i64;
  v109 = *v101;
  v118 = *v101;
  if ( v44 )
  {
    v110 = *((_QWORD *)&v118 + 1);
    do
    {
      if ( !v110
        || (!**(_QWORD **)(v110 + 72) || (v111 = *(int **)(v110 + 96), *v111 <= 0) ? (v114 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v110 + 24i64))(
                                                                                               v110,
                                                                                               v10)) : (--*v111, v112 = *(unsigned __int16 ***)(v110 + 72), v113 = *v112, ++*v112, *v113 = v10, v114 = v10),
            v114 == 0xFFFF) )
      {
        LOBYTE(v118) = 1;
      }
      --v44;
    }
    while ( v44 );
    v109 = v118;
  }
  v115 = v131;
  *v131 = v109;
  if ( v138 >= 0x10 )
    j_free(Block[0]);
  v138 = 15i64;
  v137 = 0i64;
  LOBYTE(Block[0]) = 0;
  if ( v140 >= 0x10 )
    j_free(v139[0]);
  return v115;
}
// 14000E102: variable 'Wchar_low' is possibly undefined
// 14000E102: variable 'v24' is possibly undefined
// 140006D10: using guessed type __int64 __fastcall unknown_libname_3(_QWORD, _QWORD);

//----- (000000014000E7A0) ----------------------------------------------------
__int128 *__fastcall sub_14000E7A0(
        __int64 a1,
        __int128 *a2,
        __int64 a3,
        __int64 a4,
        unsigned __int16 a5,
        char *a6,
        size_t a7)
{
  char *v7; // r15
  size_t v8; // r14
  __int64 *v9; // rax
  __int64 v10; // r13
  int v11; // er12
  __int64 v12; // rdi
  __int64 v13; // rax
  void (__fastcall ***v14)(_QWORD, __int64); // rbx
  char v15; // al
  char v16; // al
  __int64 v17; // r13
  void **v18; // rax
  void **v19; // rax
  void **v20; // r12
  size_t v21; // rdi
  char i; // al
  __int64 v23; // rbx
  __int64 v24; // rdi
  size_t v25; // rdi
  int v26; // eax
  _QWORD *v27; // r12
  __int128 v28; // xmm0
  __int64 v29; // rbx
  int *v30; // rax
  unsigned __int16 **v31; // rcx
  unsigned __int16 *v32; // rdx
  unsigned __int16 v33; // ax
  _QWORD *v34; // r11
  __int128 v35; // xmm0
  __int64 v36; // rbx
  int *v37; // rax
  unsigned __int16 **v38; // rcx
  unsigned __int16 *v39; // rdx
  unsigned __int16 v40; // ax
  unsigned __int16 v41; // ax
  __int128 *v42; // r11
  __int128 v43; // xmm0
  __int64 v44; // rbx
  int *v45; // rax
  unsigned __int16 **v46; // rcx
  unsigned __int16 *v47; // rdx
  unsigned __int16 v48; // ax
  __int128 *v49; // rbx
  __int128 v51; // [rsp+30h] [rbp-91h] BYREF
  char v52[8]; // [rsp+40h] [rbp-81h] BYREF
  __int64 v53; // [rsp+48h] [rbp-79h]
  __int128 v54; // [rsp+50h] [rbp-71h]
  __int64 v55; // [rsp+60h] [rbp-61h]
  __int64 v56; // [rsp+68h] [rbp-59h] BYREF
  __int128 *v57; // [rsp+70h] [rbp-51h]
  __int64 v58; // [rsp+78h] [rbp-49h]
  __int128 v59; // [rsp+80h] [rbp-41h] BYREF
  void *Block[3]; // [rsp+90h] [rbp-31h] BYREF
  unsigned __int64 v61; // [rsp+A8h] [rbp-19h]

  v58 = -2i64;
  v53 = a4;
  *(_QWORD *)&v51 = a3;
  v57 = a2;
  v55 = a1;
  v7 = a6;
  v8 = a7;
  v9 = sub_140008F00(a4, &v56);
  v10 = sub_140007200(v9);
  *(_QWORD *)&v54 = v10;
  v11 = 1;
  v12 = v56;
  if ( v56 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v52, 0);
    v13 = *(_QWORD *)(v12 + 8);
    if ( v13 && v13 != -1 )
      *(_QWORD *)(v12 + 8) = v13 - 1;
    v14 = 0i64;
    if ( !*(_QWORD *)(v12 + 8) )
      v14 = (void (__fastcall ***)(_QWORD, __int64))v12;
    std::_Lockit::~_Lockit((std::_Lockit *)v52);
    if ( v14 )
      (**v14)(v14, 1i64);
  }
  unknown_libname_3(v10, Block);
  v15 = *a6;
  if ( *a6 != 43 && v15 != 45 )
  {
    if ( v15 == 48 && ((v16 = a6[1], v16 == 120) || v16 == 88) )
      v11 = 2;
    else
      v11 = 0;
  }
  v17 = v11;
  v18 = Block;
  if ( v61 >= 0x10 )
    v18 = (void **)Block[0];
  if ( *(_BYTE *)v18 != 127 )
  {
    v19 = Block;
    if ( v61 >= 0x10 )
      v19 = (void **)Block[0];
    if ( *(char *)v19 > 0 )
    {
      v20 = Block;
      if ( v61 >= 0x10 )
        v20 = (void **)Block[0];
      v21 = a7;
      for ( i = *(_BYTE *)v20; *(_BYTE *)v20 != 127; i = *(_BYTE *)v20 )
      {
        if ( i <= 0 || i >= v21 - v17 )
          break;
        v21 -= i;
        memmove_s(&a6[v21 + 1], v8 - v21 + 1, &a6[v21], v8 - v21 + 1);
        a6[v21] = 0;
        ++v8;
        if ( *((char *)v20 + 1) > 0 )
          v20 = (void **)((char *)v20 + 1);
      }
    }
  }
  v23 = v53;
  v24 = *(_QWORD *)(v53 + 40);
  if ( v24 <= 0 || v24 <= v8 )
    v25 = 0i64;
  else
    v25 = v24 - v8;
  v26 = *(_DWORD *)(v53 + 24) & 0x1C0;
  v27 = (_QWORD *)v51;
  if ( v26 != 64 )
  {
    v28 = *(_OWORD *)v51;
    v51 = *(_OWORD *)v51;
    if ( v26 == 256 )
    {
      v34 = sub_14000ED60(v55, &v59, &v51, a6, v17);
      *v27 = *v34;
      v27[1] = v34[1];
      v7 = &a6[v17];
      v8 -= v17;
      v35 = *(_OWORD *)v34;
      v51 = *(_OWORD *)v34;
      if ( v25 )
      {
        v36 = *((_QWORD *)&v51 + 1);
        do
        {
          if ( !v36
            || (!**(_QWORD **)(v36 + 72) || (v37 = *(int **)(v36 + 96), *v37 <= 0) ? (v40 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v36 + 24i64))(
                                                                                              v36,
                                                                                              a5)) : (--*v37, v38 = *(unsigned __int16 ***)(v36 + 72), v39 = *v38, ++*v38, *v39 = a5, v40 = a5),
                v40 == 0xFFFF) )
          {
            LOBYTE(v51) = 1;
          }
          --v25;
        }
        while ( v25 );
        v35 = v51;
        v23 = v53;
      }
      *(_OWORD *)v27 = v35;
      v25 = 0i64;
    }
    else
    {
      if ( v25 )
      {
        v29 = *((_QWORD *)&v51 + 1);
        do
        {
          if ( !v29
            || (!**(_QWORD **)(v29 + 72) || (v30 = *(int **)(v29 + 96), *v30 <= 0) ? (v33 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v29 + 24i64))(
                                                                                              v29,
                                                                                              a5)) : (--*v30, v31 = *(unsigned __int16 ***)(v29 + 72), v32 = *v31, ++*v31, *v32 = a5, v33 = a5),
                v33 == 0xFFFF) )
          {
            LOBYTE(v51) = 1;
          }
          --v25;
        }
        while ( v25 );
        v28 = v51;
        v23 = v53;
      }
      *(_OWORD *)v27 = v28;
      v25 = 0i64;
    }
  }
  v51 = *(_OWORD *)v27;
  v41 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v54 + 16i64))(v54);
  v42 = sub_14000EE60(v55, &v59, &v51, v7, v8, v41);
  *v27 = *(_QWORD *)v42;
  v27[1] = *((_QWORD *)v42 + 1);
  *(_QWORD *)(v23 + 40) = 0i64;
  v43 = *(_OWORD *)v27;
  v54 = *(_OWORD *)v27;
  if ( v25 )
  {
    v44 = *((_QWORD *)&v54 + 1);
    do
    {
      if ( !v44
        || (!**(_QWORD **)(v44 + 72) || (v45 = *(int **)(v44 + 96), *v45 <= 0) ? (v48 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v44 + 24i64))(
                                                                                          v44,
                                                                                          a5)) : (--*v45,
                                                                                                  v46 = *(unsigned __int16 ***)(v44 + 72),
                                                                                                  v47 = *v46,
                                                                                                  ++*v46,
                                                                                                  *v47 = a5,
                                                                                                  v48 = a5),
            v48 == 0xFFFF) )
      {
        LOBYTE(v54) = 1;
      }
      --v25;
    }
    while ( v25 );
    v43 = v54;
  }
  v49 = v57;
  *v57 = v43;
  if ( v61 >= 0x10 )
    j_free(Block[0]);
  return v49;
}
// 140006D10: using guessed type __int64 __fastcall unknown_libname_3(_QWORD, _QWORD);
// 14000E7A0: using guessed type char var_C0[8];

//----- (000000014000EB70) ----------------------------------------------------
_QWORD *__fastcall sub_14000EB70(__int64 a1, _QWORD *a2, _QWORD *a3, unsigned __int16 a4, __int64 a5)
{
  __int64 i; // rdi
  _QWORD *v9; // rcx
  int *v10; // rax
  _WORD **v11; // rcx
  unsigned __int16 *v12; // rdx
  unsigned __int16 v13; // ax

  for ( i = a5; i; --i )
  {
    v9 = (_QWORD *)a3[1];
    if ( v9 )
    {
      if ( *(_QWORD *)v9[9] && (v10 = (int *)v9[12], *v10 > 0) )
      {
        --*v10;
        v11 = (_WORD **)v9[9];
        v12 = (*v11)++;
        *v12 = a4;
        v13 = a4;
      }
      else
      {
        v13 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v9 + 24i64))(v9, a4);
      }
      if ( v13 != 0xFFFF )
        continue;
    }
    *(_BYTE *)a3 = 1;
  }
  *a2 = *a3;
  a2[1] = a3[1];
  return a2;
}

//----- (000000014000EC20) ----------------------------------------------------
_QWORD *__fastcall sub_14000EC20(void *Src, void *a2, size_t Size)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r9
  void *v7; // rax
  _QWORD *v8; // rax
  size_t v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rax

  v5 = Src;
  if ( !a2 )
    goto LABEL_13;
  v6 = *((_QWORD *)Src + 3);
  v7 = v6 < 0x10 ? Src : *(void **)Src;
  if ( a2 < v7 )
    goto LABEL_13;
  if ( v6 >= 0x10 )
    Src = *(void **)Src;
  if ( (char *)Src + v5[2] <= a2 )
  {
LABEL_13:
    v10 = v5[2];
    if ( -1i64 - v10 <= Size )
      sub_14002B5F8("string too long");
    if ( !Size )
      return v5;
    v11 = v10 + Size;
    if ( v10 + Size == -1i64 )
      sub_14002B5F8("string too long");
    v12 = v5[3];
    if ( v12 >= v11 )
    {
      if ( v11 )
        goto LABEL_20;
      v5[2] = 0i64;
      if ( v12 < 0x10 )
        *(_BYTE *)v5 = 0;
      else
        *(_BYTE *)*v5 = 0;
    }
    else
    {
      sub_140007EF0(v5, v10 + Size, v10);
      if ( v11 )
      {
LABEL_20:
        if ( v5[3] < 0x10ui64 )
          v13 = v5;
        else
          v13 = (_QWORD *)*v5;
        memmove((char *)v13 + v5[2], a2, Size);
        v14 = v5[3] < 0x10ui64;
        v5[2] = v11;
        if ( v14 )
          v15 = v5;
        else
          v15 = (_QWORD *)*v5;
        *((_BYTE *)v15 + v11) = 0;
      }
    }
    return v5;
  }
  if ( v6 < 0x10 )
    v8 = v5;
  else
    v8 = (_QWORD *)*v5;
  return sub_14000F0C0(v5, v5, (_BYTE *)a2 - (_BYTE *)v8, Size);
}

//----- (000000014000ED60) ----------------------------------------------------
_QWORD *__fastcall sub_14000ED60(__int64 a1, _QWORD *a2, _QWORD *a3, char *a4, __int64 a5)
{
  __int64 v5; // rbx
  const _Cvtvec *v9; // r12
  char v10; // al
  __int64 v11; // rcx
  wchar_t v12; // r8
  int *v13; // rax
  wchar_t **v14; // rcx
  wchar_t *v15; // rdx
  wchar_t v17; // [rsp+68h] [rbp+10h] BYREF
  mbstate_t v18; // [rsp+70h] [rbp+18h] BYREF

  v5 = a5;
  if ( a5 )
  {
    v9 = (const _Cvtvec *)(a1 + 16);
    do
    {
      v10 = *a4;
      v17 = 0;
      LOBYTE(a5) = v10;
      v18._Wchar = 0;
      Mbrtowc(&v17, (const char *)&a5, 1ui64, &v18, v9);
      v11 = a3[1];
      if ( !v11
        || ((v12 = v17, !**(_QWORD **)(v11 + 72)) || (v13 = *(int **)(v11 + 96), *v13 <= 0) ? (v12 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v11 + 24i64))(v11, v17)) : (--*v13, v14 = *(wchar_t ***)(v11 + 72), v15 = *v14, ++*v14, *v15 = v12),
            v12 == 0xFFFF) )
      {
        *(_BYTE *)a3 = 1;
      }
      ++a4;
      --v5;
    }
    while ( v5 );
  }
  *a2 = *a3;
  a2[1] = a3[1];
  return a2;
}

//----- (000000014000EE60) ----------------------------------------------------
__int128 *__fastcall sub_14000EE60(
        __int64 a1,
        __int128 *a2,
        __int128 *a3,
        char *a4,
        size_t MaxCount,
        unsigned __int16 a6)
{
  unsigned __int16 v6; // r15
  size_t v7; // r13
  __int128 *v9; // rdi
  __int64 v10; // r14
  _BYTE *v11; // rax
  size_t v12; // rbp
  __int128 v13; // xmm6
  char *v14; // rsi
  size_t v15; // rdi
  __int64 v16; // rbx
  const _Cvtvec *v17; // r14
  char v18; // al
  __int16 v19; // r8
  int *v20; // rax
  __int16 **v21; // rcx
  __int16 *v22; // rdx
  char *v23; // r12
  size_t v24; // r13
  int *v25; // rax
  unsigned __int16 **v26; // rcx
  unsigned __int16 *v27; // rdx
  unsigned __int16 v28; // ax
  __int128 *result; // rax
  __int16 v30[2]; // [rsp+30h] [rbp-88h] BYREF
  mbstate_t v31; // [rsp+34h] [rbp-84h] BYREF
  __int128 v32; // [rsp+40h] [rbp-78h]
  __int128 v33; // [rsp+50h] [rbp-68h]
  char v37; // [rsp+D8h] [rbp+20h] BYREF

  v6 = a6;
  v7 = MaxCount;
  v9 = a3;
  v10 = a1;
  while ( 1 )
  {
    v11 = memchr(a4, 0, v7);
    if ( v11 )
      v12 = v11 - a4;
    else
      v12 = v7;
    v13 = *v9;
    v14 = a4;
    v15 = v12;
    v32 = v13;
    v16 = *((_QWORD *)&v13 + 1);
    if ( v12 )
    {
      v17 = (const _Cvtvec *)(v10 + 16);
      do
      {
        v18 = *v14;
        v30[0] = 0;
        v37 = v18;
        v31._Wchar = 0;
        Mbrtowc((wchar_t *)v30, &v37, 1ui64, &v31, v17);
        if ( !*((_QWORD *)&v13 + 1)
          || ((v19 = v30[0], !**(_QWORD **)(*((_QWORD *)&v13 + 1) + 72i64))
           || (v20 = *(int **)(*((_QWORD *)&v13 + 1) + 96i64), *v20 <= 0) ? (v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**((_QWORD **)&v13 + 1) + 24i64))(
                                                                                     *((_QWORD *)&v13 + 1),
                                                                                     (unsigned __int16)v30[0])) : (--*v20, v21 = *(__int16 ***)(*((_QWORD *)&v13 + 1) + 72i64), v22 = *v21, ++*v21, *v22 = v19),
              v19 == -1) )
        {
          LOBYTE(v32) = 1;
        }
        ++v14;
        --v15;
      }
      while ( v15 );
      v7 = MaxCount;
      v6 = a6;
      v13 = v32;
      v10 = a1;
    }
    v9 = a3;
    v23 = &a4[v12];
    v24 = v7 - v12;
    *a3 = v13;
    if ( !v24 )
      break;
    if ( v6 )
    {
      v33 = v13;
      if ( !v16
        || (!**(_QWORD **)(v16 + 72) || (v25 = *(int **)(v16 + 96), *v25 <= 0) ? (v28 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 24i64))(
                                                                                          v16,
                                                                                          v6)) : (--*v25,
                                                                                                  v26 = *(unsigned __int16 ***)(v16 + 72),
                                                                                                  v27 = *v26,
                                                                                                  ++*v26,
                                                                                                  *v27 = v6,
                                                                                                  v28 = v6),
            v28 == 0xFFFF) )
      {
        LOBYTE(v33) = 1;
        v13 = v33;
      }
      *a3 = v13;
    }
    a4 = v23 + 1;
    v7 = v24 - 1;
    MaxCount = v7;
  }
  result = a2;
  *a2 = v13;
  return result;
}
// 14000EE60: using guessed type wchar_t var_88[2];

//----- (000000014000F050) ----------------------------------------------------
__int64 __fastcall sub_14000F050(__int64 a1, unsigned __int16 a2)
{
  __int64 v3; // rcx
  unsigned __int16 v4; // r8
  int *v5; // rax
  unsigned __int16 **v6; // rcx
  unsigned __int16 *v7; // rdx

  v3 = *(_QWORD *)(a1 + 8);
  v4 = a2;
  if ( !v3
    || (!**(_QWORD **)(v3 + 72) || (v5 = *(int **)(v3 + 96), *v5 <= 0) ? (v4 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v3 + 24i64))(
                                                                                 v3,
                                                                                 a2)) : (--*v5,
                                                                                         v6 = *(unsigned __int16 ***)(v3 + 72),
                                                                                         v7 = *v6,
                                                                                         ++*v6,
                                                                                         *v7 = v4),
        v4 == 0xFFFF) )
  {
    *(_BYTE *)a1 = 1;
  }
  return a1;
}

//----- (000000014000F0C0) ----------------------------------------------------
_QWORD *__fastcall sub_14000F0C0(_QWORD *a1, _QWORD *a2, unsigned __int64 a3, size_t a4)
{
  unsigned __int64 v4; // rax
  size_t v5; // rbp
  _QWORD *v7; // rsi
  size_t v9; // rax
  size_t v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rax
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rax

  v4 = a2[2];
  v5 = a4;
  v7 = a2;
  if ( v4 < a3 )
    sub_14002B630("invalid string position");
  v9 = v4 - a3;
  v10 = a1[2];
  if ( v9 < a4 )
    v5 = v9;
  if ( -1i64 - v10 <= v5 )
    sub_14002B5F8("string too long");
  if ( v5 )
  {
    v11 = v10 + v5;
    if ( v10 + v5 == -1i64 )
      sub_14002B5F8("string too long");
    v12 = a1[3];
    if ( v12 >= v11 )
    {
      if ( !v11 )
      {
        a1[2] = 0i64;
        if ( v12 < 0x10 )
          *(_BYTE *)a1 = 0;
        else
          *(_BYTE *)*a1 = 0;
        return a1;
      }
    }
    else
    {
      sub_140007EF0(a1, v10 + v5, v10);
      if ( !v11 )
        return a1;
    }
    if ( v7[3] >= 0x10ui64 )
      v7 = (_QWORD *)*v7;
    if ( a1[3] < 0x10ui64 )
      v13 = a1;
    else
      v13 = (_QWORD *)*a1;
    memmove((char *)v13 + a1[2], (char *)v7 + a3, v5);
    v14 = a1[3] < 0x10ui64;
    a1[2] = v11;
    if ( v14 )
      v15 = a1;
    else
      v15 = (_QWORD *)*a1;
    *((_BYTE *)v15 + v11) = 0;
  }
  return a1;
}

//----- (000000014000F1E0) ----------------------------------------------------
void *__fastcall sub_14000F1E0(void *a1, void *Src, _QWORD *a3)
{
  void *v4; // rax

  v4 = sub_140006E60(Src, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *((_QWORD *)a1 + 3) = 7i64;
  *((_QWORD *)a1 + 2) = 0i64;
  *(_WORD *)a1 = 0;
  sub_14000B3F0(a1, v4);
  return a1;
}

//----- (000000014000F240) ----------------------------------------------------
__int64 __fastcall sub_14000F240(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012E158;
  v12 = qword_14012E158;
  v3 = qword_140130F50;
  if ( !qword_140130F50 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F50 == v3 )
      qword_140130F50 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F50;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v5 = v2;
  }
  else
  {
    if ( sub_14000F390(&v12, a1) == -1 )
    {
      sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v5 = v12;
    qword_14012E158 = v12;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v7 = *(_QWORD *)(v5 + 8);
    if ( v7 != -1 )
      *(_QWORD *)(v5 + 8) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    unknown_libname_19(v5);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E158: using guessed type __int64 qword_14012E158;

//----- (000000014000F390) ----------------------------------------------------
__int64 __fastcall sub_14000F390(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 14000F410: variable 'v7' is possibly undefined
// 1400E4DA8: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (000000014000F450) ----------------------------------------------------
char __fastcall sub_14000F450(unsigned __int16 *a1, unsigned __int16 *a2, _QWORD *a3, __int64 *a4, __int64 a5)
{
  __int64 v7; // r9
  char v9; // si
  unsigned __int16 *v10; // rax
  unsigned __int16 *i; // rcx
  unsigned __int16 *v12[2]; // [rsp+40h] [rbp-C0h] BYREF
  char v13[1072]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int16 *v14; // [rsp+480h] [rbp+380h]
  unsigned int v15; // [rsp+494h] [rbp+394h]
  __int64 v16; // [rsp+4B0h] [rbp+3B0h] BYREF
  unsigned __int16 *v18; // [rsp+500h] [rbp+400h]

  v12[1] = (unsigned __int16 *)-2i64;
  v7 = *a4;
  if ( !v7 )
    return 0;
  v9 = 0;
  sub_14000F760((__int64)v13, (__int64)a1, (__int64)a2, v7, *(_DWORD *)(v7 + 36), *(_DWORD *)(v7 + 32), 0);
  if ( sub_14000FC70((__int64)v13, (__int64)a3, 0) )
    goto LABEL_9;
  if ( a1 != a2 )
  {
    v15 = v15 & 0xFFFFDEFF | 0x100;
    v10 = *sub_14000F870((__int64)v13, v12, a1 + 1, a2, 0i64);
    v18 = v10;
    for ( i = a2; v10 != a2; i = a2 )
    {
      v14 = v10;
      if ( sub_14000FC70((__int64)v13, (__int64)a3, 0) )
        goto LABEL_9;
      v10 = *sub_14000F870((__int64)v13, v12, v18 + 1, a2, 0i64);
      v18 = v10;
    }
    v14 = i;
    if ( sub_14000FC70((__int64)v13, (__int64)a3, 0) )
    {
LABEL_9:
      v9 = 1;
      if ( a3 )
      {
        *a3 = a5;
        a3[5] = a1;
      }
    }
  }
  sub_140008FC0(&v16);
  return v9;
}

//----- (000000014000F600) ----------------------------------------------------
__int64 __fastcall sub_14000F600(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  int v5; // edi
  unsigned int v8; // esi

  *(_QWORD *)a1 = a3;
  *(_QWORD *)(a1 + 8) = a3;
  v5 = 0;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  sub_140010150(a1 + 40, a2, a5);
  *(_DWORD *)(a1 + 88) = a5;
  v8 = a5 & 0x3F;
  *(_QWORD *)(a1 + 80) = a2;
  if ( v8 == 1 || (a5 & 0x3F) == 0 )
  {
    v5 = 142040571;
  }
  else
  {
    switch ( v8 )
    {
      case 2u:
        v5 = 1845494528;
        break;
      case 4u:
        v5 = 1887436827;
        break;
      case 8u:
        v5 = 1904320539;
        break;
      case 0x10u:
        v5 = 1846018820;
        break;
      case 0x20u:
        v5 = 1887961119;
        break;
    }
  }
  *(_DWORD *)(a1 + 100) = v5;
  if ( (v5 & 0x40000000) != 0 )
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 12i64) |= 8u;
  sub_14000FDE0(a1);
  return a1;
}

//----- (000000014000F6D0) ----------------------------------------------------
__int64 __fastcall sub_14000F6D0(__int64 a1)
{
  _DWORD *v2; // rsi
  __int64 result; // rax

  v2 = sub_1400102A0(a1 + 40, 0);
  sub_14000FFE0(a1);
  if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 16) )
    std::tr1::_Xbad(14i64);
  sub_1400101E0(a1 + 40, (__int64)v2);
  sub_140011C60(a1 + 40, 21);
  result = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(result + 32) = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a1 + 24) + 1;
  return result;
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (000000014000F760) ----------------------------------------------------
__int64 __fastcall sub_14000F760(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, int a6, int a7)
{
  _QWORD *v8; // rax
  int v9; // ecx
  int i; // er10
  _QWORD *v11; // rax
  int v12; // eax
  int v13; // ecx
  char v14; // al
  __int64 v15; // rdi
  __int64 v16; // rcx

  v8 = (_QWORD *)(a1 + 16);
  *(_QWORD *)a1 = 0i64;
  v9 = 31;
  for ( i = 31; i >= 0; --i )
  {
    *v8 = 0i64;
    v8[1] = 0i64;
    v8 += 2;
  }
  *(_QWORD *)(a1 + 528) = 0i64;
  v11 = (_QWORD *)(a1 + 544);
  do
  {
    *v11 = 0i64;
    v11[1] = 0i64;
    v11 += 2;
    --v9;
  }
  while ( v9 >= 0 );
  v12 = a6;
  v13 = a7;
  *(_QWORD *)(a1 + 1056) = 0i64;
  *(_DWORD *)(a1 + 1088) = v12;
  *(_QWORD *)(a1 + 1064) = a3;
  *(_QWORD *)(a1 + 1072) = a2;
  *(_QWORD *)(a1 + 1080) = a4;
  *(_DWORD *)(a1 + 1092) = v13;
  *(_BYTE *)(a1 + 1098) = a5;
  *(_BYTE *)(a1 + 1096) = 0;
  if ( (*(_BYTE *)(a4 + 12) & 8) == 0 || (v14 = 1, (v13 & 0x10) != 0) )
    v14 = 0;
  *(_BYTE *)(a1 + 1099) = v14;
  *(_QWORD *)(a1 + 1104) = 0i64;
  *(_QWORD *)(a1 + 1112) = 0i64;
  *(_QWORD *)(a1 + 1120) = std::locale::_Init();
  v15 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)&a6, 0);
  v16 = *(_QWORD *)(v15 + 8);
  if ( v16 != -1 )
    *(_QWORD *)(v15 + 8) = v16 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&a6);
  return a1;
}

//----- (000000014000F870) ----------------------------------------------------
unsigned __int16 **__fastcall sub_14000F870(
        __int64 a1,
        unsigned __int16 **a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        __int64 a5)
{
  __int64 v5; // rsi
  unsigned __int16 *v6; // rdi
  unsigned __int16 *v7; // rbx
  __int64 v9; // r10
  unsigned __int16 **result; // rax
  __int64 v11; // rdi
  __int64 *v12; // rax
  unsigned int *v13; // r9
  unsigned __int16 v14; // bp
  char v15; // al
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // r11
  __int64 v18; // rax
  int v19; // ecx
  int v20; // edx
  unsigned __int16 *v21; // rax
  __int64 v22; // r9
  __int64 v23; // rax
  _WORD *v24; // rdx
  _WORD *i; // rcx
  unsigned __int16 v26; // r8
  __int64 v27; // rdx
  unsigned __int16 **v28; // rax
  __int64 v29; // [rsp+30h] [rbp-58h]
  __int64 v30; // [rsp+40h] [rbp-48h] BYREF
  __int64 v31; // [rsp+48h] [rbp-40h] BYREF
  unsigned __int16 *v32; // [rsp+50h] [rbp-38h] BYREF
  unsigned __int16 *v35; // [rsp+A0h] [rbp+18h]

  v35 = a3;
  v5 = a5;
  v6 = a4;
  v7 = a3;
  v9 = a1;
  if ( !a5 )
    v5 = *(_QWORD *)(a1 + 1080);
  if ( a3 == a4 )
    goto LABEL_12;
  while ( 2 )
  {
    if ( !v5 )
    {
LABEL_12:
      *a2 = v7;
      return a2;
    }
    switch ( *(_DWORD *)(v5 + 8) )
    {
      case 1:
      case 8:
      case 9:
      case 0xD:
      case 0xE:
      case 0x14:
        v5 = *(_QWORD *)(v5 + 16);
        continue;
      case 2:
        if ( (*(_BYTE *)(a1 + 1092) & 1) != 0 )
          goto LABEL_9;
        do
        {
          if ( *(v7 - 1) == 10 )
            break;
          ++v7;
        }
        while ( v7 != a4 );
        goto LABEL_12;
      case 3:
        if ( (*(_BYTE *)(a1 + 1092) & 2) != 0 )
        {
LABEL_9:
          *a2 = a4;
          return a2;
        }
        while ( *v7 != 10 )
        {
          if ( ++v7 == a4 )
          {
            *a2 = v7;
            return a2;
          }
        }
        goto LABEL_12;
      case 6:
        v11 = a1 + 1104;
        do
        {
          LODWORD(v29) = *(_DWORD *)(a1 + 1088);
          v12 = sub_140011080(
                  &v30,
                  v7,
                  v7 + 1,
                  *(__int16 **)(v5 + 40),
                  (__int16 *)(*(_QWORD *)(v5 + 40) + 2i64),
                  v11,
                  v29,
                  (*(_DWORD *)(a1 + 1092) & 0x80) != 0);
          v7 = v35;
          if ( (unsigned __int16 *)*v12 != v35 )
            break;
          v7 = v35 + 1;
          v35 = v7;
        }
        while ( v7 != a4 );
        result = a2;
        *a2 = v7;
        return result;
      case 7:
        goto LABEL_21;
      case 0xC:
      case 0x15:
        v5 = 0i64;
        continue;
      case 0x10:
        do
        {
          if ( !v5 )
            break;
          v28 = sub_14000F870(v9, &v32, v7, v6, *(_QWORD *)(v5 + 16));
          v7 = v35;
          v9 = a1;
          v6 = *v28;
          v5 = *(_QWORD *)(v5 + 40);
        }
        while ( v35 != *v28 );
        *a2 = v6;
        return a2;
      default:
        goto LABEL_12;
    }
  }
  do
  {
LABEL_21:
    v13 = *(unsigned int **)(v5 + 32);
    v14 = *v7;
    if ( v13 )
    {
      if ( (unsigned __int16 *)*sub_1400111B0(&v31, v7, v7 + 1, v13) != v7 )
      {
        v15 = 1;
        goto LABEL_52;
      }
      v9 = a1;
    }
    if ( *(_QWORD *)(v5 + 56) )
    {
      if ( (*(_DWORD *)(v9 + 1088) & 0x800) != 0 )
      {
        v16 = sub_140010330(v9 + 1104, v14);
        v6 = a4;
        v7 = v35;
        v9 = a1;
        v17 = v16;
      }
      else
      {
        v17 = v14;
      }
      v18 = *(_QWORD *)(v5 + 56);
      v19 = 0;
      v20 = *(_DWORD *)(v18 + 4);
      if ( v20 > 0 )
      {
        v21 = *(unsigned __int16 **)(v18 + 8);
        while ( *v21 > v17 || v17 > v21[1] )
        {
          v19 += 2;
          v21 += 2;
          if ( v19 >= v20 )
            goto LABEL_34;
        }
LABEL_50:
        v15 = 1;
        goto LABEL_52;
      }
    }
LABEL_34:
    if ( dword_14012E160 > v14 || v14 >= 0x100u )
    {
      if ( !*(_QWORD *)(v5 + 48) )
        goto LABEL_45;
      v23 = *(_QWORD *)(v5 + 48);
      v24 = *(_WORD **)(v23 + 8);
      for ( i = &v24[*(int *)(v23 + 4)]; v24 != i; ++v24 )
      {
        if ( *v24 == v14 )
          break;
      }
      if ( v24 == (_WORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 8i64) + 2i64 * *(int *)(*(_QWORD *)(v5 + 48) + 4i64)) )
      {
LABEL_45:
        v26 = *(_WORD *)(v5 + 64);
        if ( !v26 || (v6 = a4, v7 = v35, !(unsigned __int8)sub_1400103B0(v9 + 1104, v14, v26)) )
        {
          v27 = *(_QWORD *)(v5 + 72);
          if ( !v27 || (v6 = a4, v7 = v35, !(unsigned __int8)sub_140011260(v14, v27, a1 + 1104)) )
          {
LABEL_51:
            v15 = 0;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
        v15 = 1;
      }
      else
      {
        v15 = 1;
      }
    }
    else
    {
      v22 = *(_QWORD *)(v5 + 40);
      if ( !v22 || ((unsigned __int8)(1 << (v14 & 7)) & *(_BYTE *)(((unsigned __int64)v14 >> 3) + v22)) == 0 )
        goto LABEL_51;
      v15 = 1;
    }
LABEL_52:
    if ( v15 != (*(_BYTE *)(v5 + 12) & 1) )
      break;
    v9 = a1;
    v35 = ++v7;
  }
  while ( v7 != v6 );
  result = a2;
  *a2 = v7;
  return result;
}
// 14000F9AA: variable 'v29' is possibly undefined
// 140011260: using guessed type __int64 __fastcall sub_140011260(_QWORD, _QWORD, _QWORD);
// 14012E160: using guessed type int dword_14012E160;

//----- (000000014000FC70) ----------------------------------------------------
bool __fastcall sub_14000FC70(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rax
  unsigned int v4; // esi
  bool v5; // zf
  char *v7; // rdx
  bool result; // al
  int v10; // edx
  __int64 v11; // r8
  __int64 *v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rax

  v3 = *(_QWORD *)(a1 + 1072);
  v4 = 0;
  v5 = a2 == 0;
  v7 = *(char **)(a1 + 1080);
  *(_QWORD *)(a1 + 1056) = v3;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 1128) = a3;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 1097) = !v5;
  *(_BYTE *)(a1 + 1096) = 0;
  result = sub_140010B40((__int64 *)a1, v7, 0i64);
  if ( result )
  {
    if ( a2 )
    {
      sub_1400106A0((__int64 *)(a2 + 8), *(unsigned __int8 *)(a1 + 1098));
      v10 = 1;
      if ( *(_BYTE *)(a1 + 1098) )
      {
        v11 = 0i64;
        v12 = (__int64 *)(a1 + 552);
        do
        {
          v13 = *(_QWORD *)(a2 + 8);
          if ( (v10 & *(_DWORD *)(a1 + 536)) != 0 )
          {
            *(_BYTE *)(v11 + v13 + 16) = 1;
            *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8)) = *(v12 - 1);
            v14 = *v12;
          }
          else
          {
            *(_BYTE *)(v11 + v13 + 16) = 0;
            *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8)) = *(_QWORD *)(a1 + 1064);
            v14 = *(_QWORD *)(a1 + 1064);
          }
          ++v4;
          v12 += 2;
          *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8) + 8) = v14;
          v10 = __ROL4__(v10, 1);
          v11 += 24i64;
        }
        while ( v4 < *(unsigned __int8 *)(a1 + 1098) );
      }
      v15 = *(__int64 **)(a2 + 8);
      *(_QWORD *)a2 = *(_QWORD *)(a1 + 1056);
      *(_BYTE *)(a2 + 56) = 1;
      *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 1056);
      v16 = *v15;
      *(_BYTE *)(a2 + 80) = 1;
      *(_QWORD *)(a2 + 48) = v16;
      *(_QWORD *)(a2 + 64) = v15[1];
      *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 1064);
      *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 1064);
      *(_QWORD *)(a2 + 96) = *(_QWORD *)(a1 + 1064);
    }
    return 1;
  }
  return result;
}

//----- (000000014000FDE0) ----------------------------------------------------
char __fastcall sub_14000FDE0(__int64 a1)
{
  unsigned __int16 v2; // cx
  int v3; // eax
  unsigned __int16 *v4; // rax
  int v5; // ecx
  bool v6; // zf

  if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 16) )
  {
    *(_WORD *)(a1 + 94) = -1;
    *(_DWORD *)(a1 + 96) = 0xFFFF;
  }
  else
  {
    v2 = **(_WORD **)a1;
    *(_WORD *)(a1 + 94) = v2;
    if ( v2 == 0xFFFF )
    {
      v3 = -1;
    }
    else if ( strchr("()$^.*+?[]|\\-{},:=!\n\r\b", v2) )
    {
      v3 = *(unsigned __int16 *)(a1 + 94);
    }
    else
    {
      v3 = 0;
    }
    *(_DWORD *)(a1 + 96) = v3;
  }
  LOWORD(v4) = *(_WORD *)(a1 + 94) - 10;
  switch ( *(_WORD *)(a1 + 94) )
  {
    case 0xA:
      if ( (*(_BYTE *)(a1 + 100) & 4) != 0 && !*(_DWORD *)(a1 + 28) )
        *(_DWORD *)(a1 + 96) = 124;
      return (char)v4;
    case 0x24:
      if ( (*(_DWORD *)(a1 + 100) & 0x2000000) != 0 )
      {
        v4 = (unsigned __int16 *)(*(_QWORD *)a1 + 2i64);
        if ( v4 != *(unsigned __int16 **)(a1 + 16) && *v4 != 10 )
          *(_DWORD *)(a1 + 96) = 0;
      }
      return (char)v4;
    case 0x28:
    case 0x29:
      v6 = (*(_BYTE *)(a1 + 100) & 8) == 0;
      goto LABEL_28;
    case 0x2A:
      if ( (*(_DWORD *)(a1 + 100) & 0x4000000) != 0 )
      {
        LOBYTE(v4) = sub_140011A80(a1 + 40);
        if ( (_BYTE)v4 )
          *(_DWORD *)(a1 + 96) = 0;
      }
      return (char)v4;
    case 0x2B:
    case 0x3F:
      v6 = (*(_BYTE *)(a1 + 100) & 1) == 0;
      goto LABEL_28;
    case 0x5C:
      LOBYTE(v4) = sub_140011590(a1);
      if ( (_BYTE)v4 )
      {
        v4 = *(unsigned __int16 **)a1;
        v5 = *(unsigned __int16 *)(*(_QWORD *)a1 + 2i64);
        *(_WORD *)(a1 + 94) = v5;
        *(_DWORD *)(a1 + 96) = v5;
      }
      return (char)v4;
    case 0x5E:
      if ( (*(_DWORD *)(a1 + 100) & 0x2000000) == 0 )
        return (char)v4;
      LOBYTE(v4) = sub_140011A80(a1 + 40);
      v6 = (_BYTE)v4 == 0;
LABEL_28:
      if ( v6 )
        *(_DWORD *)(a1 + 96) = 0;
      return (char)v4;
    case 0x7B:
    case 0x7D:
      v6 = (*(_BYTE *)(a1 + 100) & 0x10) == 0;
      goto LABEL_28;
    case 0x7C:
      v6 = (*(_BYTE *)(a1 + 100) & 2) == 0;
      goto LABEL_28;
    default:
      return (char)v4;
  }
}

//----- (000000014000FFE0) ----------------------------------------------------
__int64 __fastcall sub_14000FFE0(__int64 a1)
{
  __int64 v1; // rsi
  __int64 result; // rax
  _DWORD *v4; // rax
  __int64 i; // rbp
  _WORD *v6; // rcx
  _WORD *v7; // rdx
  _WORD *v8; // rcx
  _QWORD *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx

  v1 = *(_QWORD *)(a1 + 48);
  result = sub_140011630(a1);
  if ( !(_BYTE)result )
  {
    if ( *(_DWORD *)(a1 + 96) != 124 )
      return result;
    v4 = sub_140011C60(a1 + 40, 8);
    sub_1400101E0(a1 + 40, (__int64)v4);
  }
  result = (__int64)sub_140011AC0(a1 + 40, v1);
  for ( i = result; *(_DWORD *)(a1 + 96) == 124; result = sub_140011BB0(a1 + 40, v1, i) )
  {
    v6 = *(_WORD **)a1;
    v7 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v7 )
    {
      if ( *v6 == 92 )
      {
        if ( (v8 = v6 + 1, v8 != v7) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v8 == 40 || *v8 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v8 == 123 || *v8 == 125) )
        {
          *(_QWORD *)a1 = v8;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
    if ( !(unsigned __int8)sub_140011630(a1) )
    {
      v9 = operator new(0x20ui64);
      v10 = (__int64)v9;
      if ( v9 )
      {
        *v9 = &loc_1400F7248;
        v9[1] = 8i64;
        v9[2] = 0i64;
        v9[3] = 0i64;
      }
      else
      {
        v10 = 0i64;
      }
      *(_QWORD *)(v10 + 24) = *(_QWORD *)(a1 + 48);
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64);
      if ( v11 )
      {
        *(_QWORD *)(v10 + 16) = v11;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64) + 24i64) = v10;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64) = v10;
      *(_QWORD *)(a1 + 48) = v10;
      sub_1400101E0(a1 + 40, v10);
    }
  }
  return result;
}

//----- (0000000140010150) ----------------------------------------------------
__int64 __fastcall sub_140010150(__int64 a1, __int64 a2, unsigned int a3)
{
  _QWORD *v6; // rax

  v6 = operator new(0x30ui64);
  if ( v6 )
  {
    v6[1] = 20i64;
    v6[2] = 0i64;
    v6[3] = 0i64;
    *((_DWORD *)v6 + 10) = 0;
    *v6 = &off_1400F7258;
  }
  else
  {
    v6 = 0i64;
  }
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 20) = a3;
  *(_QWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 36) = ~(unsigned __int8)(a3 >> 9) & 4;
  *(_DWORD *)(a1 + 32) = ~(unsigned __int16)(a3 >> 3) & 0x100;
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}
// 1400F7258: using guessed type __int64 (__fastcall *off_1400F7258)();

//----- (00000001400101E0) ----------------------------------------------------
__int64 __fastcall sub_1400101E0(__int64 a1, __int64 a2)
{
  int v3; // ecx
  int v5; // edi
  int v6; // eax
  _DWORD *v7; // rax
  _DWORD *v8; // r11
  __int64 v9; // rcx
  __int64 result; // rax

  v3 = *(_DWORD *)(a2 + 8);
  if ( v3 == 8 )
  {
    v5 = 9;
  }
  else
  {
    v5 = 12;
    if ( v3 != 10 )
    {
      v6 = 14;
      if ( v3 == 11 )
        v6 = 12;
      v5 = v6;
    }
  }
  v7 = operator new(0x28ui64);
  v8 = v7;
  if ( v7 )
  {
    v7[2] = v5;
    *((_QWORD *)v7 + 4) = a2;
    v7[3] = 0;
    *((_QWORD *)v7 + 2) = 0i64;
    *((_QWORD *)v7 + 3) = 0i64;
    *(_QWORD *)v7 = &off_1400F7268;
  }
  else
  {
    v8 = 0i64;
  }
  *((_QWORD *)v8 + 3) = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v9 )
  {
    *((_QWORD *)v8 + 2) = v9;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v8;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 16) = v8;
  *(_QWORD *)(a1 + 8) = v8;
  return result;
}
// 1400F7268: using guessed type __int64 (__fastcall *off_1400F7268)();

//----- (00000001400102A0) ----------------------------------------------------
_DWORD *__fastcall sub_1400102A0(__int64 a1, int a2)
{
  _DWORD *v4; // rax
  _DWORD *v5; // r11
  __int64 v6; // rax
  _DWORD *result; // rax

  v4 = operator new(0x28ui64);
  v5 = v4;
  if ( v4 )
  {
    v4[2] = 13;
    v4[8] = a2;
    v4[3] = 0;
    *((_QWORD *)v4 + 2) = 0i64;
    *((_QWORD *)v4 + 3) = 0i64;
    *(_QWORD *)v4 = &std::tr1::_Node_capture::`vftable';
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)v5 + 3) = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v6 )
  {
    *((_QWORD *)v5 + 2) = v6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v5;
  }
  result = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = v5;
  *(_QWORD *)(a1 + 8) = v5;
  return result;
}
// 1400F7288: using guessed type void *std::tr1::_Node_capture::`vftable';

//----- (0000000140010330) ----------------------------------------------------
__int64 __fastcall sub_140010330(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rax
  void **v3; // rax
  unsigned __int16 v4; // bx
  void *Block[3]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v8; // [rsp+40h] [rbp-28h]

  v2 = sub_140010540(a1);
  sub_140010820(v2, (__int64)Block);
  if ( Block[2] == (void *)1 )
  {
    v3 = Block;
    if ( v8 >= 8 )
      v3 = (void **)Block[0];
    v4 = *(_WORD *)v3;
  }
  else
  {
    v4 = a2;
  }
  if ( v8 >= 8 )
    j_free(Block[0]);
  return v4;
}

//----- (00000001400103B0) ----------------------------------------------------
__int64 __fastcall sub_1400103B0(__int64 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  __int64 v5; // rax
  __int64 v7; // rax

  if ( a3 == 0xFFFF )
    return a2 == 95
        || (v7 = sub_1400105F0(a1),
            (*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 16i64))(v7, 263i64, a2));
  v5 = sub_1400105F0(a1);
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v5 + 16i64))(v5, a3, a2);
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140010430) ----------------------------------------------------
void *__fastcall sub_140010430(__int64 a1)
{
  __int64 v1; // rdi
  void **v3; // rbx
  void **v4; // rbx
  void **v5; // rbx
  __int64 v6; // rdi
  void **v7; // rbx
  void *result; // rax

  v1 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)a1 = &std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';
  while ( v1 )
  {
    v3 = (void **)v1;
    v1 = *(_QWORD *)(v1 + 24);
    free(v3[2]);
    j_free(v3);
  }
  j_free(*(void **)(a1 + 40));
  v4 = *(void ***)(a1 + 48);
  if ( v4 )
  {
    free(v4[1]);
    j_free(v4);
  }
  v5 = *(void ***)(a1 + 56);
  if ( v5 )
  {
    free(v5[1]);
    j_free(v5);
  }
  v6 = *(_QWORD *)(a1 + 72);
  while ( v6 )
  {
    v7 = (void **)v6;
    v6 = *(_QWORD *)(v6 + 24);
    free(v7[2]);
    j_free(v7);
  }
  result = &loc_1400F7248;
  *(_QWORD *)a1 = &loc_1400F7248;
  return result;
}
// 1400F7388: using guessed type void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';

//----- (0000000140010510) ----------------------------------------------------
void *__fastcall sub_140010510(void *Block, char a2)
{
  sub_140010430((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140010540) ----------------------------------------------------
__int64 __fastcall sub_140010540(__int64 a1)
{
  __int64 *v2; // rax
  __int64 result; // rax
  __int64 v4; // rsi
  __int64 v5; // rax
  void (__fastcall ***v6)(_QWORD, __int64); // rdi
  char v7; // [rsp+40h] [rbp+8h] BYREF
  __int64 v8; // [rsp+48h] [rbp+10h] BYREF

  if ( *(_QWORD *)a1 )
    return *(_QWORD *)a1;
  v2 = sub_1400109B0(a1, &v8);
  result = sub_140011CF0(v2);
  *(_QWORD *)a1 = result;
  v4 = v8;
  if ( v8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v7, 0);
    v5 = *(_QWORD *)(v4 + 8);
    if ( v5 && v5 != -1 )
      *(_QWORD *)(v4 + 8) = v5 - 1;
    v6 = 0i64;
    if ( !*(_QWORD *)(v4 + 8) )
      v6 = (void (__fastcall ***)(_QWORD, __int64))v4;
    std::_Lockit::~_Lockit((std::_Lockit *)&v7);
    if ( v6 )
      (**v6)(v6, 1i64);
    return *(_QWORD *)a1;
  }
  return result;
}

//----- (00000001400106A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400106A0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v2; // r9
  __int64 v3; // r10
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rbx

  v2 = a1[1];
  v3 = *a1;
  result = (unsigned __int64)((unsigned __int128)((v2 - *a1) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 63;
  v7 = (v2 - *a1) / 24;
  if ( v7 <= a2 )
  {
    if ( v7 >= a2 )
      return result;
    if ( 0xAAAAAAAAAAAAAAAi64 - (a2 - v7) < v7 )
      sub_14002B5F8("vector<T> too long");
    v9 = (a1[2] - v3) / 24;
    if ( a2 > v9 )
    {
      if ( 0xAAAAAAAAAAAAAAAi64 - (v9 >> 1) >= v9 )
        v10 = (v9 >> 1) + v9;
      else
        v10 = 0i64;
      if ( v10 < a2 )
        v10 = a2;
      sub_140010A00(a1, v10);
    }
    sub_140012F70(a1[1], a2 - (a1[1] - *a1) / 24);
    v11 = a2 - (a1[1] - *a1) / 24;
    result = 3 * v11;
    v8 = a1[1] + 24 * v11;
  }
  else
  {
    result = 3 * a2;
    v8 = v3 + 24 * a2;
    if ( v8 == v2 )
      return result;
  }
  a1[1] = v8;
  return result;
}
// 140010A00: using guessed type __int64 __fastcall sub_140010A00(_QWORD, _QWORD);

//----- (0000000140010820) ----------------------------------------------------
__int64 __fastcall sub_140010820(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16i64))(a1);
  return a2;
}

//----- (0000000140010880) ----------------------------------------------------
_QWORD *__fastcall sub_140010880(const _Collvec *a1, _QWORD *a2, const wchar_t *a3, const wchar_t *a4)
{
  unsigned __int64 v7; // rax
  const _Collvec *v8; // rdi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  wchar_t *v11; // rdx
  wchar_t *v12; // rcx
  unsigned __int64 v13; // rcx

  a2[3] = 7i64;
  a2[2] = 0i64;
  *(_WORD *)a2 = 0;
  v7 = a4 - a3;
  if ( v7 )
  {
    v8 = a1 + 1;
    do
    {
      v9 = a2[2];
      if ( v7 > v9 )
        sub_140005760(a2, v7 - v9, 0);
      else
        sub_140009570(a2, v7, 0xFFFFFFFFFFFFFFFFui64);
      v10 = a2[3];
      if ( v10 < 8 )
        v11 = (wchar_t *)a2;
      else
        v11 = (wchar_t *)*a2;
      if ( v10 < 8 )
        v12 = (wchar_t *)a2;
      else
        v12 = (wchar_t *)*a2;
      v7 = Wcsxfrm(v12, &v11[a2[2]], a3, a4, v8);
    }
    while ( v7 > a2[2] && v7 );
  }
  v13 = a2[2];
  if ( v7 > v13 )
    sub_140005760(a2, v7 - v13, 0);
  else
    sub_140009570(a2, v7, 0xFFFFFFFFFFFFFFFFui64);
  return a2;
}

//----- (0000000140010980) ----------------------------------------------------
__int64 __fastcall sub_140010980(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  __int64 result; // rax
  int v4; // ecx

  for ( result = 0i64; a2 != a3; result = (unsigned int)(v4 + __ROL4__(result, 8)) )
    v4 = *a2++;
  return result;
}

//----- (00000001400109B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400109B0(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rdi
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 16);
  *a2 = v2;
  std::_Lockit::_Lockit((std::_Lockit *)&v6, 0);
  v4 = *(_QWORD *)(v2 + 8);
  if ( v4 != -1 )
    *(_QWORD *)(v2 + 8) = v4 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v6);
  return a2;
}

//----- (0000000140010B40) ----------------------------------------------------
bool __fastcall sub_140010B40(__int64 *a1, char *a2, __int64 a3)
{
  bool v3; // bp
  char *v4; // rbx
  int v6; // edx
  int v7; // ecx
  int v8; // ecx
  bool v9; // cl
  __int64 v10; // rax
  int v11; // edx
  char v12; // di
  _WORD *v13; // rax
  int v14; // edx
  char v15; // al
  _WORD *v16; // rax
  __int64 v17; // rax
  __int64 v18; // rbx
  bool v19; // zf
  char *v20; // rdx
  __int64 v21; // rdx
  __int64 v22; // rcx
  int v23; // eax
  __int64 v24; // rax
  __int64 v25; // rcx
  __int16 *v26; // r9
  __int16 *v27; // rcx
  __int64 v28; // rbx
  __int64 v29; // rdi
  bool v30; // al
  __int64 v32; // [rsp+30h] [rbp-58h]
  __int64 v33; // [rsp+40h] [rbp-48h]
  __int64 v34; // [rsp+48h] [rbp-40h] BYREF
  __int64 v35; // [rsp+50h] [rbp-38h] BYREF
  __int64 pExceptionObject[6]; // [rsp+58h] [rbp-30h] BYREF
  char *v37; // [rsp+98h] [rbp+10h] BYREF
  unsigned int v38; // [rsp+A0h] [rbp+18h]
  __int64 v39; // [rsp+A8h] [rbp+20h]

  v38 = a3;
  v37 = a2;
  v3 = 0;
  v4 = a2;
  if ( !a2 )
    return !v3;
  while ( 2 )
  {
    v6 = *((_DWORD *)v4 + 2);
    switch ( v6 )
    {
      case 1:
      case 8:
      case 9:
      case 17:
      case 20:
        goto LABEL_66;
      case 2:
        v7 = *((_DWORD *)a1 + 273);
        if ( (v7 & 0x101) == 1 )
          goto LABEL_71;
        if ( (v7 & 0x100) != 0 || *a1 != a1[132] )
          v3 = *(_WORD *)(*a1 - 2) != 10;
        goto LABEL_66;
      case 3:
        if ( (*((_BYTE *)a1 + 1092) & 2) == 0 && (*a1 == a1[133] || *(_WORD *)*a1 == 10) )
          goto LABEL_66;
        goto LABEL_71;
      case 4:
        v8 = *((_DWORD *)a1 + 273);
        if ( (v8 & 4) != 0 && *a1 == a1[132] || (v8 & 8) != 0 && *a1 == a1[133] )
        {
          v9 = 0;
        }
        else
        {
          v10 = *a1;
          v12 = 0;
          if ( *a1 != a1[132] || (v8 & 0x100) != 0 )
          {
            v11 = *(unsigned __int16 *)(v10 - 2);
            if ( v11 == (char)*(_WORD *)(v10 - 2) )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v11) )
                v12 = 1;
            }
          }
          v13 = (_WORD *)*a1;
          v15 = 0;
          if ( *a1 != a1[133] )
          {
            v14 = (unsigned __int16)*v13;
            if ( v14 == (char)*v13 )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v14) )
                v15 = 1;
            }
          }
          v9 = v12 != v15;
        }
        if ( v9 != (v4[12] & 1) )
          goto LABEL_66;
        goto LABEL_71;
      case 5:
        v16 = (_WORD *)*a1;
        if ( *a1 == a1[133] || *v16 == 10 || *v16 == 13 )
          goto LABEL_71;
        *a1 = (__int64)(v16 + 1);
        goto LABEL_66;
      case 6:
        LODWORD(v32) = *((_DWORD *)a1 + 272);
        v17 = *sub_140011080(
                 &v34,
                 (_WORD *)*a1,
                 (_WORD *)a1[133],
                 *((__int16 **)v4 + 5),
                 (__int16 *)(*((_QWORD *)v4 + 5) + 2i64 * *((int *)v4 + 9)),
                 (__int64)(a1 + 138),
                 v32,
                 (*((_DWORD *)a1 + 273) & 0x80) != 0);
        if ( v17 == *a1 )
          goto LABEL_71;
        *a1 = v17;
        goto LABEL_66;
      case 7:
        if ( *a1 == a1[133] || !sub_140012240(a1, (__int64)v4) )
          goto LABEL_71;
        v3 = 0;
        goto LABEL_67;
      case 10:
      case 11:
        v18 = *a1;
        v19 = v6 == 11;
        v20 = (char *)*((_QWORD *)v37 + 4);
        v33 = a1[1];
        v39 = *a1;
        if ( sub_140010B40(a1, v20, 0i64) != v19 )
        {
          *a1 = v18;
          v4 = v37;
LABEL_66:
          if ( v3 )
            goto LABEL_72;
LABEL_67:
          if ( !v4 )
            return !v3;
          v4 = (char *)*((_QWORD *)v4 + 2);
          v37 = v4;
          if ( !v4 )
            return !v3;
          a3 = v38;
          continue;
        }
        *a1 = v39;
        a1[1] = v33;
LABEL_71:
        v3 = 1;
LABEL_72:
        if ( *((char *)a1 + 1092) < 0 && *a1 == a1[133] )
        {
          v3 = 0;
          memmove(a1 + 66, a1, 0x210ui64);
        }
        return !v3;
      case 12:
        goto LABEL_65;
      case 13:
        a1[2 * *((unsigned int *)v4 + 8) + 2] = *a1;
        goto LABEL_66;
      case 14:
        v21 = *((_QWORD *)v4 + 4);
        if ( *((_BYTE *)a1 + 1097) || *(_DWORD *)(v21 + 32) )
        {
          *((_DWORD *)a1 + 2) |= 1 << *(_DWORD *)(v21 + 32);
          a1[2 * *(unsigned int *)(v21 + 32) + 3] = *a1;
        }
        goto LABEL_66;
      case 15:
        v22 = *((unsigned int *)v4 + 8);
        v23 = *((_DWORD *)a1 + 2);
        if ( !_bittest(&v23, v22) )
          goto LABEL_66;
        v24 = *a1;
        v25 = 2 * v22;
        v26 = (__int16 *)a1[v25 + 2];
        v27 = (__int16 *)a1[v25 + 3];
        if ( v26 != v27 )
        {
          LODWORD(v32) = *((_DWORD *)a1 + 272);
          v24 = *sub_1400124F0(
                   &v35,
                   (_WORD *)*a1,
                   (_WORD *)a1[133],
                   v26,
                   v27,
                   (__int64)(a1 + 138),
                   v32,
                   (*((_DWORD *)a1 + 273) & 0x80) != 0);
          if ( v24 == *a1 )
            goto LABEL_71;
        }
        *a1 = v24;
        goto LABEL_66;
      case 16:
        if ( !sub_140011F90((__int64)a1, (__int64)v4, a3) )
          v3 = 1;
        goto LABEL_65;
      case 18:
        if ( !sub_140012080(a1, (__int64)v4, (*((_DWORD *)v4 + 3) & 2) != 0, a3) )
          v3 = 1;
        goto LABEL_65;
      case 19:
        if ( (int)a3 > 0 )
        {
          v28 = *a1;
          v29 = a1[1];
          v30 = sub_140010B40(a1, *((char **)v37 + 2), a3);
          *a1 = v28;
          a1[1] = v29;
          v3 = !v30;
        }
        goto LABEL_65;
      case 21:
        if ( (*((_DWORD *)a1 + 273) & 0x2020) != 0 && a1[132] == *a1 || *((_BYTE *)a1 + 1128) && *a1 != a1[133] )
        {
          v3 = 1;
        }
        else if ( !*((_BYTE *)a1 + 1096) || sub_140012420((__int64)a1) )
        {
          memmove(a1 + 66, a1, 0x210ui64);
          *((_BYTE *)a1 + 1096) = 1;
        }
LABEL_65:
        v4 = 0i64;
        goto LABEL_66;
      default:
        v37 = "corrupted regex pattern";
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v37);
        pExceptionObject[0] = (__int64)&std::logic_error::`vftable';
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVlogic_error_std__);
    }
  }
}
// 140010D27: variable 'v32' is possibly undefined
// 1400E41C8: using guessed type void *std::logic_error::`vftable';

//----- (0000000140011080) ----------------------------------------------------
__int64 *__fastcall sub_140011080(
        __int64 *a1,
        _WORD *a2,
        _WORD *a3,
        __int16 *a4,
        __int16 *a5,
        __int64 a6,
        __int64 a7,
        char a8)
{
  __int16 v8; // ax
  __int16 *v9; // r10
  __int64 v11; // rcx
  __int64 *result; // rax
  __int64 v13; // rcx
  _WORD *v14; // rcx
  __int16 v15; // r9
  __int16 v16; // ax
  _WORD **v17; // rdx
  _WORD *v18; // [rsp+40h] [rbp-18h] BYREF
  _WORD *v19; // [rsp+60h] [rbp+8h] BYREF

  v8 = a7;
  v9 = a4;
  *a1 = (__int64)a3;
  if ( (v8 & 0x800) != 0 )
  {
    v11 = *sub_140012610((__int64 *)&v19, a2, a3, a4, (__int64)a5, a6, a8);
    result = a1;
    *a1 = v11;
    return result;
  }
  if ( (v8 & 0x100) != 0 )
  {
    v13 = *sub_1400127A0((__int64 *)&v19, a2, a3, (unsigned __int16 *)a4, (__int64)a5, a6, a8);
    result = a1;
    *a1 = v13;
    return result;
  }
  v14 = a2;
  v19 = a2;
  v18 = a2;
  if ( a2 != a3 )
  {
    while ( v9 != a5 )
    {
      v15 = *v14;
      v16 = *v9;
      ++v14;
      ++v9;
      v19 = v14;
      if ( v15 != v16 )
        goto LABEL_15;
      if ( v14 == a3 )
        goto LABEL_9;
    }
    goto LABEL_10;
  }
LABEL_9:
  if ( v9 == a5 )
  {
LABEL_10:
    result = a1;
    *a1 = (__int64)v19;
    return result;
  }
  if ( !a8 || (v17 = &v19, v14 != a3) )
    v17 = &v18;
  a2 = *v17;
LABEL_15:
  *a1 = (__int64)a2;
  return a1;
}

//----- (00000001400111B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400111B0(_QWORD *a1, _WORD *a2, _WORD *a3, unsigned int *a4)
{
  unsigned int *v4; // rsi
  int v6; // ebp
  int v7; // edi
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r10
  _WORD *v10; // rcx
  _WORD *v11; // r11
  _WORD *v12; // rax

  v4 = a4;
  if ( a4 )
  {
    while ( 1 )
    {
      v6 = v4[3];
      v7 = 0;
      if ( v6 > 0 )
        break;
LABEL_10:
      v4 = (unsigned int *)*((_QWORD *)v4 + 3);
      if ( !v4 )
        goto LABEL_11;
    }
    v8 = *v4;
    while ( 1 )
    {
      v9 = 0i64;
      v10 = a2;
      if ( *v4 )
      {
        v11 = (_WORD *)(*((_QWORD *)v4 + 2) + 2i64 * v7);
        do
        {
          v12 = v10++;
          if ( *v12 != *v11 )
            break;
          ++v9;
          ++v11;
        }
        while ( v9 < v8 );
      }
      if ( v10 == a3 )
        break;
      v7 += v8;
      if ( v7 >= v6 )
        goto LABEL_10;
    }
    *a1 = a3;
  }
  else
  {
LABEL_11:
    *a1 = a2;
  }
  return a1;
}

//----- (0000000140011590) ----------------------------------------------------
bool __fastcall sub_140011590(__int64 a1)
{
  __int16 *v1; // rax
  __int16 v2; // ax
  bool result; // al

  v1 = (__int16 *)(*(_QWORD *)a1 + 2i64);
  result = 1;
  if ( v1 == *(__int16 **)(a1 + 16) || (*(_BYTE *)(a1 + 100) & 8) != 0 || *v1 != 40 && *v1 != 41 )
  {
    if ( (*(_BYTE *)(a1 + 100) & 0x10) != 0 )
      return 0;
    v2 = *v1;
    if ( v2 != 123 && v2 != 125 )
      return 0;
  }
  return result;
}

//----- (00000001400115D0) ----------------------------------------------------
char __fastcall sub_1400115D0(__int64 a1)
{
  _WORD *v1; // rax
  _WORD *v2; // rdx
  _WORD *v3; // rax

  v1 = *(_WORD **)a1;
  v2 = *(_WORD **)(a1 + 16);
  if ( *(_WORD **)a1 != v2 )
  {
    if ( *v1 == 92 )
    {
      if ( (v3 = v1 + 1, v3 != v2) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v3 == 40 || *v3 == 41)
        || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v3 == 123 || *v3 == 125) )
      {
        *(_QWORD *)a1 = v3;
      }
    }
    *(_QWORD *)a1 += 2i64;
  }
  return sub_14000FDE0(a1);
}

//----- (0000000140011630) ----------------------------------------------------
__int64 __fastcall sub_140011630(__int64 a1)
{
  unsigned __int8 v2; // cl
  int v3; // eax
  __int64 v4; // rcx
  _QWORD *v5; // rax
  _QWORD *v6; // r11
  __int64 v7; // rcx
  _WORD *v8; // rax
  _WORD *v9; // rcx
  _WORD *v10; // rax
  _WORD *v11; // rax
  _WORD *v12; // rcx
  _WORD *v13; // rdx
  _WORD *v14; // rcx
  _WORD *v15; // rax
  _WORD *v16; // rcx
  _WORD *v17; // rax
  _WORD *v18; // rcx
  _WORD *v19; // rdx
  _WORD *v20; // rax
  _WORD *v21; // rcx
  _WORD *v22; // rax
  _WORD *v23; // rax
  _WORD *v24; // rcx
  _WORD *v25; // rax
  char v26; // bl

  v2 = 0;
  if ( *(_DWORD *)(a1 + 96) != 0xFFFF )
  {
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 96);
      if ( v3 == 124 )
        return v2;
      if ( v3 == 41 )
      {
        if ( *(_DWORD *)(a1 + 28) )
          return v2;
        if ( (*(_DWORD *)(a1 + 100) & 0x10000000) == 0 )
        {
          v4 = 5i64;
          goto LABEL_111;
        }
      }
      if ( v3 == 46 )
        break;
      switch ( v3 )
      {
        case '\\':
          v11 = *(_WORD **)a1;
          v12 = *(_WORD **)(a1 + 16);
          if ( *(_WORD **)a1 != v12 )
          {
            if ( *v11 == 92 )
            {
              if ( (v13 = v11 + 1, v11 + 1 != v12) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v13 == 40 || *v13 == 41)
                || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v13 == 123 || *v13 == 125) )
              {
                *(_QWORD *)a1 = v13;
              }
            }
            *(_QWORD *)a1 += 2i64;
          }
          sub_14000FDE0(a1);
          if ( (*(_DWORD *)(a1 + 100) & 0x80) != 0 && *(_WORD *)(a1 + 94) == 98 )
          {
            sub_140011C60(a1 + 40, 4);
            v14 = *(_WORD **)a1;
            v15 = *(_WORD **)(a1 + 16);
            if ( *(_WORD **)a1 != v15 )
            {
              if ( *v14 == 92 )
              {
                if ( (v16 = v14 + 1, v16 != v15) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v16 == 40 || *v16 == 41)
                  || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v16 == 123 || *v16 == 125) )
                {
                  *(_QWORD *)a1 = v16;
                }
              }
              *(_QWORD *)a1 += 2i64;
            }
            sub_14000FDE0(a1);
            break;
          }
          if ( (*(_DWORD *)(a1 + 100) & 0x80) == 0 || *(_WORD *)(a1 + 94) != 66 )
          {
            sub_140012AE0(a1);
            goto LABEL_112;
          }
          sub_140011C60(a1 + 40, 4);
          *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12i64) ^= 1u;
          sub_1400115D0(a1);
          break;
        case '[':
          v17 = *(_WORD **)a1;
          v18 = *(_WORD **)(a1 + 16);
          if ( *(_WORD **)a1 != v18 )
          {
            if ( *v17 == 92 )
            {
              if ( (v19 = v17 + 1, v17 + 1 != v18) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v19 == 40 || *v19 == 41)
                || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v19 == 123 || *v19 == 125) )
              {
                *(_QWORD *)a1 = v19;
              }
            }
            *(_QWORD *)a1 += 2i64;
          }
          sub_14000FDE0(a1);
          sub_140012A20(a1);
          if ( *(_DWORD *)(a1 + 96) != 93 )
            std::tr1::_Xbad(4i64);
          v20 = *(_WORD **)a1;
          v21 = *(_WORD **)(a1 + 16);
          if ( *(_WORD **)a1 != v21 )
          {
            if ( *v20 == 92 )
            {
              if ( (v22 = v20 + 1, v22 != v21) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v22 == 40 || *v22 == 41)
                || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v22 == 123 || *v22 == 125) )
              {
                *(_QWORD *)a1 = v22;
              }
            }
            *(_QWORD *)a1 += 2i64;
          }
          goto LABEL_24;
        case '(':
          v23 = *(_WORD **)a1;
          v24 = *(_WORD **)(a1 + 16);
          if ( *(_WORD **)a1 != v24 )
          {
            if ( *v23 == 92 )
            {
              if ( (v25 = v23 + 1, v25 != v24) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v25 == 40 || *v25 == 41)
                || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v25 == 123 || *v25 == 125) )
              {
                *(_QWORD *)a1 = v25;
              }
            }
            *(_QWORD *)a1 += 2i64;
          }
          sub_14000FDE0(a1);
          v26 = sub_140012BB0((int *)a1);
          sub_1400129B0(a1, 41, 5u);
          if ( !v26 )
            break;
          goto LABEL_112;
        case '^':
          sub_140011C60(a1 + 40, 2);
          sub_1400115D0(a1);
          break;
        case '$':
          sub_140011C60(a1 + 40, 3);
          sub_1400115D0(a1);
          break;
        case '*':
        case '+':
        case '?':
        case '{':
          v4 = 10i64;
LABEL_111:
          std::tr1::_Xbad(v4);
        default:
          if ( v3 == 125 && (*(_DWORD *)(a1 + 100) & 0x10000000) == 0 )
          {
            v4 = 6i64;
            goto LABEL_111;
          }
          if ( v3 == 93 && (*(_DWORD *)(a1 + 100) & 0x10000000) == 0 )
          {
            v4 = 4i64;
            goto LABEL_111;
          }
          sub_140012EB0(a1 + 40, *(_WORD *)(a1 + 94));
          sub_1400115D0(a1);
          goto LABEL_112;
      }
LABEL_113:
      v2 = 1;
      if ( *(_DWORD *)(a1 + 96) == 0xFFFF )
        return v2;
    }
    v5 = operator new(0x20ui64);
    v6 = v5;
    if ( v5 )
    {
      *v5 = &loc_1400F7248;
      v5[1] = 5i64;
      v5[2] = 0i64;
      v5[3] = 0i64;
    }
    else
    {
      v6 = 0i64;
    }
    v6[3] = *(_QWORD *)(a1 + 48);
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64);
    if ( v7 )
    {
      v6[2] = v7;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64) + 24i64) = v6;
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64) = v6;
    *(_QWORD *)(a1 + 48) = v6;
    v8 = *(_WORD **)a1;
    v9 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v9 )
    {
      if ( *v8 == 92 )
      {
        if ( (v10 = v8 + 1, v10 != v9) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v10 == 40 || *v10 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v10 == 123 || *v10 == 125) )
        {
          *(_QWORD *)a1 = v10;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
LABEL_24:
    sub_14000FDE0(a1);
LABEL_112:
    sub_140012D10(a1);
    goto LABEL_113;
  }
  return 0i64;
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140011A80) ----------------------------------------------------
bool __fastcall sub_140011A80(__int64 a1)
{
  __int64 v1; // rdx
  int v2; // eax
  int v3; // ecx
  bool result; // al

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)(v1 + 8);
  result = 1;
  if ( v2 != 20 && v2 != 8 && v2 != 13 )
  {
    if ( v2 != 2 )
      return 0;
    v3 = *(_DWORD *)(*(_QWORD *)(v1 + 24) + 8i64);
    if ( v3 != 20 && v3 != 8 && v3 != 13 )
      return 0;
  }
  return result;
}

//----- (0000000140011AC0) ----------------------------------------------------
_QWORD *__fastcall sub_140011AC0(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rdi
  __int64 v6; // rcx
  _QWORD *v7; // rax
  __int64 v8; // rdx

  v4 = operator new(0x20ui64);
  v5 = v4;
  if ( v4 )
  {
    v4[1] = 17i64;
    v4[2] = 0i64;
    v4[3] = 0i64;
    *v4 = &std::tr1::_Node_endif::`vftable';
  }
  else
  {
    v5 = 0i64;
  }
  v5[3] = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v6 )
  {
    v5[2] = v6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v5;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = v5;
  *(_QWORD *)(a1 + 8) = v5;
  v7 = operator new(0x30ui64);
  if ( v7 )
  {
    v7[1] = 16i64;
    v7[2] = 0i64;
    v7[3] = 0i64;
    v7[4] = v5;
    v7[5] = 0i64;
    *v7 = &std::tr1::_Node_if::`vftable';
  }
  else
  {
    v7 = 0i64;
  }
  v8 = *(_QWORD *)(a2 + 16);
  v7[3] = *(_QWORD *)(v8 + 24);
  *(_QWORD *)(*(_QWORD *)(v8 + 24) + 16i64) = v7;
  v7[2] = v8;
  *(_QWORD *)(v8 + 24) = v7;
  return v5;
}
// 1400F72A8: using guessed type void *std::tr1::_Node_endif::`vftable';
// 1400F72B8: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (0000000140011BB0) ----------------------------------------------------
__int64 __fastcall sub_140011BB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rax
  bool v8; // zf
  _QWORD *v9; // rax
  __int64 result; // rax

  v3 = *(_QWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = 0i64;
  v5 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a3 + 16) = 0i64;
  *(_QWORD *)(v5 + 16) = a3;
  v6 = v3 + 40;
  if ( *(_QWORD *)(v3 + 40) )
  {
    do
    {
      v3 = *(_QWORD *)v6;
      v8 = *(_QWORD *)(*(_QWORD *)v6 + 40i64) == 0i64;
      v6 = *(_QWORD *)v6 + 40i64;
    }
    while ( !v8 );
  }
  v9 = operator new(0x30ui64);
  if ( v9 )
  {
    v9[1] = 16i64;
    v9[2] = 0i64;
    v9[3] = 0i64;
    v9[4] = a3;
    v9[5] = 0i64;
    *v9 = &std::tr1::_Node_if::`vftable';
  }
  else
  {
    v9 = 0i64;
  }
  *(_QWORD *)(v3 + 40) = v9;
  v9[2] = v4;
  result = *(_QWORD *)(v3 + 40);
  *(_QWORD *)(v4 + 24) = result;
  return result;
}
// 1400F72B8: using guessed type void *std::tr1::_Node_if::`vftable';

//----- (0000000140011C60) ----------------------------------------------------
_DWORD *__fastcall sub_140011C60(__int64 a1, int a2)
{
  _DWORD *v4; // rax
  _DWORD *v5; // r11
  __int64 v6; // rax
  _DWORD *result; // rax

  v4 = operator new(0x20ui64);
  v5 = v4;
  if ( v4 )
  {
    v4[2] = a2;
    *(_QWORD *)v4 = &loc_1400F7248;
    v4[3] = 0;
    *((_QWORD *)v4 + 2) = 0i64;
    *((_QWORD *)v4 + 3) = 0i64;
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)v5 + 3) = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v6 )
  {
    *((_QWORD *)v5 + 2) = v6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v5;
  }
  result = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = v5;
  *(_QWORD *)(a1 + 8) = v5;
  return result;
}

//----- (0000000140011CF0) ----------------------------------------------------
__int64 __fastcall sub_140011CF0(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012E168;
  v12 = qword_14012E168;
  v3 = qword_140130F48;
  if ( !qword_140130F48 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F48 == v3 )
      qword_140130F48 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F48;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v5 = v2;
  }
  else
  {
    if ( sub_140011E70(&v12, a1) == -1 )
    {
      sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v5 = v12;
    qword_14012E168 = v12;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v7 = *(_QWORD *)(v5 + 8);
    if ( v7 != -1 )
      *(_QWORD *)(v5 + 8) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    unknown_libname_19(v5);
  }
LABEL_20:
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 140011E70: using guessed type __int64 __fastcall sub_140011E70(_QWORD, _QWORD);
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E168: using guessed type __int64 qword_14012E168;

//----- (0000000140011E40) ----------------------------------------------------
std::exception *__fastcall sub_140011E40(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::logic_error::`vftable';
  return a1;
}
// 1400E41C8: using guessed type void *std::logic_error::`vftable';

//----- (0000000140011F90) ----------------------------------------------------
char __fastcall sub_140011F90(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v4; // r13
  char v5; // bp
  int v6; // er12
  __int64 v8; // rsi
  __int64 *v10; // rdx
  char result; // al
  __int64 v12; // [rsp+20h] [rbp-68h] BYREF
  __int64 i; // [rsp+28h] [rbp-60h]
  __int64 v14[2]; // [rsp+30h] [rbp-58h] BYREF

  v3 = *(_QWORD *)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  v6 = -1;
  v8 = a2;
  v14[0] = v3;
  v14[1] = v4;
  v12 = v3;
  for ( i = v4; v8; v8 = *(_QWORD *)(v8 + 40) )
  {
    *(_QWORD *)a1 = v3;
    *(_QWORD *)(a1 + 8) = v4;
    if ( sub_140010B40((__int64 *)a1, *(char **)(v8 + 16), a3) )
    {
      if ( !*(_BYTE *)(a1 + 1099) )
        return 1;
      if ( v6 < (int)((*(_QWORD *)a1 - v3) >> 1) )
      {
        v6 = (*(_QWORD *)a1 - v3) >> 1;
        v12 = *(_QWORD *)a1;
        i = *(_QWORD *)(a1 + 8);
      }
      v5 = 1;
    }
  }
  v10 = &v12;
  if ( !v5 )
    v10 = v14;
  result = v5;
  *(_QWORD *)a1 = *v10;
  *(_QWORD *)(a1 + 8) = v10[1];
  return result;
}

//----- (0000000140012080) ----------------------------------------------------
char __fastcall sub_140012080(void *Src, __int64 a2, char a3, unsigned int a4)
{
  __int64 v4; // rdi
  __int64 v5; // r14
  int v6; // ebp
  __int64 v10; // rbx
  __int64 v11; // rdi
  char v12; // r13
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  __int64 v16; // r8
  char result; // al
  __int64 v18; // rbx
  __int64 *v19; // rdx
  __int64 v21[3]; // [rsp+28h] [rbp-270h] BYREF
  char v22[528]; // [rsp+40h] [rbp-258h] BYREF

  v4 = *(_QWORD *)Src;
  v5 = *((_QWORD *)Src + 1);
  v6 = 0;
  v21[0] = *(_QWORD *)Src;
  v21[1] = v5;
  if ( *(int *)(a2 + 40) <= 0 )
  {
LABEL_5:
    memmove(v22, Src, 0x210ui64);
    v11 = *(_QWORD *)Src;
    v12 = 0;
    if ( !sub_140010B40((__int64 *)Src, *(char **)(*(_QWORD *)(a2 + 32) + 16i64), a4) )
      goto LABEL_8;
    if ( a3 )
    {
      memmove(v22, Src, 0x210ui64);
      v12 = 1;
LABEL_8:
      while ( 1 )
      {
        v13 = *(_DWORD *)(a2 + 44);
        if ( v13 != -1 )
        {
          v14 = v6++;
          if ( v14 >= v13 )
            break;
        }
        *(_QWORD *)Src = v11;
        *((_DWORD *)Src + 2) = v5;
        v15 = *(_DWORD *)(a2 + 44);
        if ( v15 < 0 || v15 > v6 )
          v16 = 0xFFFFFFFFi64;
        else
          v16 = 1i64;
        if ( !sub_140010B40((__int64 *)Src, *(char **)(a2 + 16), v16) )
          break;
        v18 = *(_QWORD *)Src;
        if ( sub_140010B40((__int64 *)Src, *(char **)(*(_QWORD *)(a2 + 32) + 16i64), a4) )
        {
          if ( !a3 )
            return 1;
          memmove(v22, Src, 0x210ui64);
          v12 = 1;
        }
        if ( v11 == v18 )
          break;
        v11 = v18;
      }
      v19 = (__int64 *)v22;
      if ( !v12 )
        v19 = v21;
      result = v12;
      *(_QWORD *)Src = *v19;
      *((_QWORD *)Src + 1) = v19[1];
    }
    else
    {
      return 1;
    }
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_QWORD *)Src;
      if ( !sub_140010B40((__int64 *)Src, *(char **)(a2 + 16), 0xFFFFFFFFi64) )
        break;
      if ( v10 != *(_QWORD *)Src && ++v6 < *(_DWORD *)(a2 + 40) )
        continue;
      goto LABEL_5;
    }
    *(_QWORD *)Src = v4;
    result = 0;
    *((_QWORD *)Src + 1) = v5;
  }
  return result;
}

//----- (0000000140012240) ----------------------------------------------------
char __fastcall sub_140012240(__int64 *a1, __int64 a2)
{
  unsigned __int16 v3; // di
  __int64 v5; // rax
  __int64 v6; // r12
  unsigned int *v7; // r9
  __int64 v8; // rbx
  __int64 v9; // rax
  char v10; // al
  unsigned __int16 v11; // r11
  __int64 v12; // rax
  int v13; // ecx
  int v14; // edx
  unsigned __int16 *v15; // rax
  __int64 v16; // r9
  bool v17; // zf
  __int64 v18; // rax
  _WORD *v19; // rdx
  _WORD *i; // rcx
  unsigned __int16 v21; // r8
  __int64 v22; // rdx
  __int64 v24; // [rsp+40h] [rbp+8h] BYREF

  v3 = *(_WORD *)*a1;
  if ( (a1[136] & 0x100) != 0 )
  {
    v5 = sub_1400105F0(a1 + 138);
    v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 48i64))(v5, v3);
  }
  v6 = *a1;
  v7 = *(unsigned int **)(a2 + 32);
  v8 = *a1 + 2;
  if ( v7 )
  {
    v9 = *sub_1400111B0(&v24, (_WORD *)*a1, (_WORD *)a1[133], v7);
    if ( v9 != v6 )
    {
      v8 = v9;
      v10 = 1;
      goto LABEL_33;
    }
  }
  if ( *(_QWORD *)(a2 + 56) )
  {
    v11 = (a1[136] & 0x800) != 0 ? sub_140010330((__int64)(a1 + 138), v3) : v3;
    v12 = *(_QWORD *)(a2 + 56);
    v13 = 0;
    v14 = *(_DWORD *)(v12 + 4);
    if ( v14 > 0 )
    {
      v15 = *(unsigned __int16 **)(v12 + 8);
      while ( *v15 > v11 || v11 > v15[1] )
      {
        v13 += 2;
        v15 += 2;
        if ( v13 >= v14 )
          goto LABEL_15;
      }
      goto LABEL_31;
    }
  }
LABEL_15:
  if ( dword_14012E164 > v3 || v3 >= 0x100u )
  {
    if ( *(_QWORD *)(a2 + 48) )
    {
      v18 = *(_QWORD *)(a2 + 48);
      v19 = *(_WORD **)(v18 + 8);
      for ( i = &v19[*(int *)(v18 + 4)]; v19 != i; ++v19 )
      {
        if ( *v19 == v3 )
          break;
      }
      if ( v19 != (_WORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 8i64) + 2i64 * *(int *)(*(_QWORD *)(a2 + 48) + 4i64)) )
      {
        v10 = 1;
        goto LABEL_33;
      }
    }
    v21 = *(_WORD *)(a2 + 64);
    if ( v21 && (unsigned __int8)sub_1400103B0((__int64)(a1 + 138), v3, v21) )
    {
      v10 = 1;
      goto LABEL_33;
    }
    v22 = *(_QWORD *)(a2 + 72);
    if ( !v22 )
      goto LABEL_32;
    v17 = (unsigned __int8)sub_140011260(v3, v22, a1 + 138) == 0;
  }
  else
  {
    v16 = *(_QWORD *)(a2 + 40);
    if ( !v16 )
      goto LABEL_32;
    v17 = ((unsigned __int8)(1 << (v3 & 7)) & *(_BYTE *)(((unsigned __int64)v3 >> 3) + v16)) == 0;
  }
  if ( !v17 )
  {
LABEL_31:
    v10 = 1;
    goto LABEL_33;
  }
LABEL_32:
  v10 = 0;
LABEL_33:
  if ( v10 == (*(_BYTE *)(a2 + 12) & 1) )
    return 0;
  *a1 = v8;
  return 1;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);
// 140011260: using guessed type __int64 __fastcall sub_140011260(_QWORD, _QWORD, _QWORD);
// 14012E164: using guessed type int dword_14012E164;

//----- (0000000140012420) ----------------------------------------------------
bool __fastcall sub_140012420(__int64 a1)
{
  int v2; // ecx
  int v3; // er9
  int v4; // er8
  _QWORD *i; // rdx
  __int64 v6; // rax

  v2 = *(unsigned __int8 *)(a1 + 1098);
  v3 = 0;
  v4 = 1;
  if ( v2 <= 0 )
    return 0;
  for ( i = (_QWORD *)(a1 + 16); ; i += 2 )
  {
    if ( (*(_DWORD *)(a1 + 536) & v4) == 0 || (v4 & *(_DWORD *)(a1 + 8)) == 0 )
      goto LABEL_7;
    v6 = i[66];
    if ( v6 != *i )
      break;
    if ( i[67] != i[1] )
      return (__int64)((*(_QWORD *)(a1 + 16i64 * v3 + 552) - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64) < (__int64)((*(_QWORD *)(a1 + 16i64 * v3 + 24) - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64);
LABEL_7:
    ++v3;
    v4 *= 2;
    if ( v3 >= v2 )
      return 0;
  }
  return (__int64)((v6 - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64) < (__int64)((*(_QWORD *)(a1 + 16 * (v3 + 1i64))
                                                                                      - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64);
}

//----- (00000001400124F0) ----------------------------------------------------
__int64 *__fastcall sub_1400124F0(
        __int64 *a1,
        _WORD *a2,
        _WORD *a3,
        __int16 *a4,
        __int16 *a5,
        __int64 a6,
        __int64 a7,
        char a8)
{
  __int16 v8; // ax
  _WORD *v9; // r10
  __int64 v11; // rcx
  __int64 *result; // rax
  __int64 v13; // rcx
  __int16 v14; // cx
  _WORD *v15; // rax
  _WORD **v16; // r10
  _WORD *v17; // [rsp+40h] [rbp-18h] BYREF
  _WORD *v18; // [rsp+60h] [rbp+8h] BYREF

  v8 = a7;
  v9 = a2;
  *a1 = (__int64)a3;
  if ( (v8 & 0x800) != 0 )
  {
    v11 = *sub_140012FB0((__int64 *)&v18, a2, a3, a4, a5, a6, a8);
    result = a1;
    *a1 = v11;
    return result;
  }
  if ( (v8 & 0x100) != 0 )
  {
    v13 = *sub_140013130((__int64 *)&v18, a2, a3, (unsigned __int16 *)a4, (unsigned __int16 *)a5, a6, a8);
    result = a1;
    *a1 = v13;
    return result;
  }
  v18 = a2;
  v17 = a2;
  if ( a2 != a3 )
  {
    while ( a4 != a5 )
    {
      v14 = *a4;
      v15 = a2++;
      ++a4;
      v18 = a2;
      if ( *v15 != v14 )
        goto LABEL_15;
      if ( a2 == a3 )
        goto LABEL_9;
    }
    goto LABEL_10;
  }
LABEL_9:
  if ( a4 == a5 )
  {
LABEL_10:
    result = a1;
    *a1 = (__int64)v18;
    return result;
  }
  if ( !a8 || (v16 = &v18, a2 != a3) )
    v16 = &v17;
  v9 = *v16;
LABEL_15:
  *a1 = (__int64)v9;
  return a1;
}

//----- (0000000140012610) ----------------------------------------------------
__int64 *__fastcall sub_140012610(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int64 a5, __int64 a6, char a7)
{
  __int16 *v7; // r13
  _WORD *v10; // rbx
  __int16 v11; // si
  __int64 v12; // rax
  void **v13; // rax
  __int16 v14; // r12
  __int64 v15; // rax
  void **v16; // rax
  __int64 *v17; // rax
  __int16 v19; // [rsp+20h] [rbp-71h]
  _WORD *v20; // [rsp+30h] [rbp-61h] BYREF
  void *Block[2]; // [rsp+38h] [rbp-59h] BYREF
  __int64 v22; // [rsp+48h] [rbp-49h]
  unsigned __int64 v23; // [rsp+50h] [rbp-41h]
  void *v24[3]; // [rsp+60h] [rbp-31h] BYREF
  unsigned __int64 v25; // [rsp+78h] [rbp-19h]
  _WORD *v26; // [rsp+E8h] [rbp+57h] BYREF
  _WORD *v27; // [rsp+F0h] [rbp+5Fh]

  v27 = a3;
  v26 = a2;
  v7 = (__int16 *)a5;
  v10 = a2;
  v20 = a2;
  if ( a2 == a3 )
  {
LABEL_18:
    if ( a4 != v7 )
    {
      if ( !a7 || (v17 = (__int64 *)&v26, a2 != a3) )
        v17 = (__int64 *)&v20;
      goto LABEL_24;
    }
  }
  else
  {
    while ( a4 != v7 )
    {
      v11 = *a4;
      v26 = a2 + 1;
      v19 = *a2;
      v12 = sub_140010540(a6);
      sub_140010820(v12, (__int64)Block);
      if ( v22 == 1 )
      {
        v13 = Block;
        if ( v23 >= 8 )
          v13 = (void **)Block[0];
        v14 = *(_WORD *)v13;
      }
      else
      {
        v14 = v19;
      }
      if ( v23 >= 8 )
        j_free(Block[0]);
      v23 = 7i64;
      v22 = 0i64;
      LOWORD(Block[0]) = 0;
      v15 = sub_140010540(a6);
      sub_140010820(v15, (__int64)v24);
      if ( v24[2] == (void *)1 )
      {
        v16 = v24;
        if ( v25 >= 8 )
          v16 = (void **)v24[0];
        v11 = *(_WORD *)v16;
      }
      if ( v25 >= 8 )
        j_free(v24[0]);
      ++a4;
      if ( v14 != v11 )
      {
        *a1 = (__int64)v10;
        return a1;
      }
      a2 = v26;
      a3 = v27;
      if ( v26 == v27 )
        goto LABEL_18;
    }
  }
  v17 = (__int64 *)&v26;
LABEL_24:
  *a1 = *v17;
  return a1;
}

//----- (00000001400127A0) ----------------------------------------------------
__int64 *__fastcall sub_1400127A0(
        __int64 *a1,
        _WORD *a2,
        _WORD *a3,
        unsigned __int16 *a4,
        __int64 a5,
        __int64 a6,
        char a7)
{
  unsigned __int16 *v7; // r12
  _WORD *v10; // rbx
  unsigned __int16 v11; // si
  unsigned __int16 v12; // di
  __int64 v13; // rax
  __int16 v14; // di
  __int64 v15; // rax
  __int64 *v16; // rax
  _WORD *v18; // [rsp+20h] [rbp-38h] BYREF
  _WORD *v19; // [rsp+68h] [rbp+10h] BYREF
  _WORD *v20; // [rsp+70h] [rbp+18h]

  v20 = a3;
  v19 = a2;
  v7 = (unsigned __int16 *)a5;
  v10 = a2;
  v18 = a2;
  if ( a2 == a3 )
  {
LABEL_5:
    if ( a4 != v7 )
    {
      if ( !a7 || (v16 = (__int64 *)&v19, a2 != a3) )
        v16 = (__int64 *)&v18;
      goto LABEL_11;
    }
  }
  else
  {
    while ( a4 != v7 )
    {
      v11 = *a4;
      v19 = a2 + 1;
      v12 = *a2;
      v13 = sub_1400105F0(a6);
      v14 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 48i64))(v13, v12);
      v15 = sub_1400105F0(a6);
      ++a4;
      if ( v14 != (*(unsigned __int16 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 48i64))(v15, v11) )
      {
        *a1 = (__int64)v10;
        return a1;
      }
      a2 = v19;
      a3 = v20;
      if ( v19 == v20 )
        goto LABEL_5;
    }
  }
  v16 = (__int64 *)&v19;
LABEL_11:
  *a1 = *v16;
  return a1;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140012890) ----------------------------------------------------
_QWORD *__fastcall sub_140012890(__int64 a1, _QWORD *a2, __int16 *a3, __int16 *a4)
{
  void *v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rax
  void *v10; // rax
  void *v12; // [rsp+28h] [rbp-90h] BYREF
  __int64 v13; // [rsp+30h] [rbp-88h]
  __int64 v14; // [rsp+38h] [rbp-80h]
  _QWORD *v15; // [rsp+48h] [rbp-70h]
  __int64 v16; // [rsp+50h] [rbp-68h]
  void *Block[5]; // [rsp+58h] [rbp-60h] BYREF

  v16 = -2i64;
  v15 = a2;
  a2[3] = 7i64;
  a2[2] = 0i64;
  *(_WORD *)a2 = 0;
  if ( a3 != a4 )
  {
    v12 = 0i64;
    v13 = 0i64;
    v14 = 0i64;
    sub_140013D40((__int16 **)&v12, a3, a4);
    v6 = v12;
    v7 = (v13 - (__int64)v12) >> 1;
    v8 = sub_1400105F0(a1);
    (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)v8 + 40i64))(v8, v6, (__int64)v6 + 2 * v7);
    v9 = sub_140010540(a1);
    v10 = (void *)sub_140010820(v9, (__int64)Block);
    sub_14000B3F0(a2, v10);
    if ( Block[3] >= (void *)8 )
      j_free(Block[0]);
    if ( v6 )
      j_free(v6);
  }
  return a2;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (00000001400129B0) ----------------------------------------------------
char __fastcall sub_1400129B0(__int64 a1, int a2, unsigned int a3)
{
  _WORD *v4; // rax
  _WORD *v5; // rcx
  _WORD *v6; // rax

  if ( *(_DWORD *)(a1 + 96) != a2 )
    std::tr1::_Xbad(a3);
  v4 = *(_WORD **)a1;
  v5 = *(_WORD **)(a1 + 16);
  if ( *(_WORD **)a1 != v5 )
  {
    if ( *v4 == 92 )
    {
      if ( (v6 = v4 + 1, v6 != v5) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v6 == 40 || *v6 == 41)
        || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v6 == 123 || *v6 == 125) )
      {
        *(_QWORD *)a1 = v6;
      }
    }
    *(_QWORD *)a1 += 2i64;
  }
  return sub_14000FDE0(a1);
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140012A20) ----------------------------------------------------
char __fastcall sub_140012A20(__int64 a1)
{
  _WORD *v2; // rax
  _WORD *v3; // rcx
  _WORD *v4; // rax
  __int64 v5; // rcx

  sub_1400139F0(a1 + 40);
  if ( *(_DWORD *)(a1 + 96) == 94 )
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12i64) ^= 1u;
    v2 = *(_WORD **)a1;
    v3 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v3 )
    {
      if ( *v2 == 92 )
      {
        if ( (v4 = v2 + 1, v4 != v3) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v4 == 40 || *v4 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v4 == 123 || *v4 == 125) )
        {
          *(_QWORD *)a1 = v4;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
  }
  if ( (*(_DWORD *)(a1 + 100) & 0x20000000) != 0 && *(_DWORD *)(a1 + 96) == 93 )
  {
    v5 = a1 + 40;
    if ( dword_14012E170 > 93 )
      sub_140014610(v5, 0x5Du);
    else
      sub_140014580(v5, 0x5Du);
    sub_1400115D0(a1);
  }
  return sub_1400133F0(a1);
}
// 14012E170: using guessed type int dword_14012E170;

//----- (0000000140012AE0) ----------------------------------------------------
char __fastcall sub_140012AE0(__int64 a1)
{
  unsigned __int16 v2; // ax
  char result; // al
  unsigned int v4; // edx
  int v5; // eax

  if ( (*(_DWORD *)(a1 + 100) & 0x100) != 0 && sub_140013220(a1) )
  {
    v2 = *(_WORD *)(a1 + 92);
    if ( !v2 )
    {
      if ( (*(_DWORD *)(a1 + 100) & 0x100000) != 0 )
        return sub_140012EB0(a1 + 40, 0);
LABEL_16:
      std::tr1::_Xbad(2i64);
    }
    if ( (*(_DWORD *)(a1 + 100) & 0x200) != 0 && v2 > 9u
      || (v4 = v2, *(_DWORD *)(a1 + 24) < (unsigned int)v2)
      || (v5 = *(_DWORD *)(a1 + 32), !_bittest(&v5, v4)) )
    {
      std::tr1::_Xbad(3i64);
    }
    return sub_140013A80(a1 + 40, v4);
  }
  else if ( sub_1400135B0(a1) )
  {
    return sub_140012EB0(a1 + 40, *(_WORD *)(a1 + 92));
  }
  else
  {
    if ( (*(_DWORD *)(a1 + 100) & 0x20000) == 0 )
      goto LABEL_16;
    result = sub_1400132F0(a1, 1);
    if ( !result )
      goto LABEL_16;
  }
  return result;
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140012BB0) ----------------------------------------------------
char __fastcall sub_140012BB0(int *a1)
{
  int v1; // eax
  int v3; // ebx
  _DWORD *v5; // rbx
  _DWORD *v6; // rbx

  v1 = a1[25];
  ++a1[7];
  if ( (v1 & 0x8000000) == 0 && a1[24] == 41 )
    std::tr1::_Xbad(5i64);
  if ( (v1 & 0x20) != 0 && a1[24] == 63 )
  {
    sub_1400115D0((__int64)a1);
    v3 = a1[24];
    sub_1400115D0((__int64)a1);
    switch ( v3 )
    {
      case ':':
        sub_140013950((__int64)a1);
        --a1[7];
        return 1;
      case '!':
        sub_1400139A0((__int64)a1, 1);
        --a1[7];
        return 0;
      case '=':
        sub_1400139A0((__int64)a1, 0);
        --a1[7];
        return 0;
      default:
        std::tr1::_Xbad(14i64);
    }
  }
  else
  {
    if ( (a1[22] & 0x200) != 0 )
    {
      v5 = sub_140011C60((__int64)(a1 + 10), 8);
      sub_14000FFE0((__int64)a1);
      sub_1400101E0((__int64)(a1 + 10), (__int64)v5);
    }
    else
    {
      if ( (unsigned int)++a1[6] >= 0x20 )
        std::tr1::_Xbad(11i64);
      v6 = sub_1400102A0((__int64)(a1 + 10), a1[6]);
      sub_14000FFE0((__int64)a1);
      sub_1400101E0((__int64)(a1 + 10), (__int64)v6);
      a1[8] |= 1 << v6[8];
    }
    --a1[7];
    return 1;
  }
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140012D10) ----------------------------------------------------
__int64 __fastcall sub_140012D10(__int64 a1)
{
  __int64 result; // rax
  int v2; // esi
  int v3; // edi
  _WORD *v5; // rcx
  _WORD *v6; // rax
  _WORD *v7; // rcx
  int v8; // er11
  _WORD *v9; // rax
  _WORD *v10; // rcx
  _WORD *v11; // rax
  char v12; // r9

  result = *(unsigned int *)(a1 + 96);
  v2 = 0;
  v3 = -1;
  if ( (_DWORD)result == 42 )
    goto LABEL_19;
  if ( (_DWORD)result != 43 )
  {
    if ( (_DWORD)result == 63 )
    {
      v3 = 1;
      goto LABEL_19;
    }
    if ( (_DWORD)result != 123 )
      return result;
    sub_1400115D0(a1);
    if ( !sub_140013220(a1) )
      std::tr1::_Xbad(7i64);
    v2 = *(unsigned __int16 *)(a1 + 92);
    if ( *(_DWORD *)(a1 + 96) == 44 )
    {
      sub_1400115D0(a1);
      if ( *(_DWORD *)(a1 + 96) == 125 )
      {
LABEL_16:
        if ( v3 == -1 || v3 >= v2 )
          goto LABEL_19;
LABEL_18:
        std::tr1::_Xbad(7i64);
      }
      if ( !sub_140013220(a1) )
        std::tr1::_Xbad(7i64);
      v3 = *(unsigned __int16 *)(a1 + 92);
    }
    else
    {
      v3 = *(unsigned __int16 *)(a1 + 92);
    }
    if ( *(_DWORD *)(a1 + 96) != 125 )
      goto LABEL_18;
    goto LABEL_16;
  }
  v2 = 1;
LABEL_19:
  *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12i64) |= 4u;
  v5 = *(_WORD **)a1;
  v6 = *(_WORD **)(a1 + 16);
  if ( *(_WORD **)a1 != v6 )
  {
    if ( *v5 == 92 )
    {
      if ( (v7 = v5 + 1, v7 != v6) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v7 == 40 || *v7 == 41)
        || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v7 == 123 || *v7 == 125) )
      {
        *(_QWORD *)a1 = v7;
      }
    }
    *(_QWORD *)a1 += 2i64;
  }
  sub_14000FDE0(a1);
  v8 = *(_DWORD *)(a1 + 100);
  if ( (v8 & 0x400) != 0 && *(_DWORD *)(a1 + 96) == 63 )
  {
    v9 = *(_WORD **)a1;
    v10 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v10 )
    {
      if ( *v9 == 92 )
      {
        if ( (v11 = v9 + 1, v11 != v10) && (v8 & 8) == 0 && (*v11 == 40 || *v11 == 41)
          || (v8 & 0x10) == 0 && (*v11 == 123 || *v11 == 125) )
        {
          *(_QWORD *)a1 = v11;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
    v12 = 0;
  }
  else
  {
    v12 = 1;
  }
  return sub_140013B10(a1 + 40, v2, v3, v12);
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140012EB0) ----------------------------------------------------
__int64 __fastcall sub_140012EB0(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rax
  int v5; // eax
  __int64 v6; // rax
  unsigned __int16 v7; // ax
  __int64 v8; // rbx
  unsigned int v9; // eax
  unsigned int v10; // esi
  void *v11; // rax
  std::tr1 *v12; // rcx
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v2 + 8) != 6 || (*(_BYTE *)(v2 + 12) & 4) != 0 )
    sub_140013C80(a1);
  v5 = *(_DWORD *)(a1 + 20);
  if ( (v5 & 0x100) != 0 )
  {
    v6 = sub_1400105F0(*(_QWORD *)(a1 + 24));
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 48i64))(v6, a2);
  }
  else
  {
    if ( (v5 & 0x800) == 0 )
      goto LABEL_9;
    v7 = sub_140010330(*(_QWORD *)(a1 + 24), a2);
  }
  a2 = v7;
LABEL_9:
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(_DWORD *)(v8 + 36);
  if ( *(_DWORD *)(v8 + 32) <= v9 )
  {
    v10 = v9 + 16;
    v11 = realloc(*(void **)(v8 + 40), 2i64 * (int)(v9 + 16));
    if ( !v11 )
      std::tr1::_Xmem(v12);
    *(_QWORD *)(v8 + 40) = v11;
    *(_DWORD *)(v8 + 32) = v10;
  }
  result = *(_QWORD *)(v8 + 40);
  *(_WORD *)(result + 2i64 * (unsigned int)(*(_DWORD *)(v8 + 36))++) = a2;
  return result;
}
// 140012F3B: variable 'v12' is possibly undefined
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140012F70) ----------------------------------------------------
__int64 __fastcall sub_140012F70(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  while ( a2 )
  {
    if ( a1 )
    {
      *(_QWORD *)a1 = 0i64;
      *(_QWORD *)(a1 + 8) = 0i64;
      *(_BYTE *)(a1 + 16) = 0;
    }
    --a2;
    a1 += 24i64;
  }
  return result;
}

//----- (0000000140012FB0) ----------------------------------------------------
__int64 *__fastcall sub_140012FB0(__int64 *a1, _WORD *a2, _WORD *a3, __int16 *a4, __int16 *a5, __int64 a6, char a7)
{
  _WORD *v8; // rbx
  __int16 v9; // di
  __int64 v10; // rax
  void **v11; // rax
  __int16 v12; // si
  __int64 v13; // rax
  void **v14; // rax
  __int64 *v15; // rax
  __int16 v17; // [rsp+20h] [rbp-61h]
  _WORD *v18; // [rsp+30h] [rbp-51h] BYREF
  void *Block[2]; // [rsp+38h] [rbp-49h] BYREF
  __int64 v20; // [rsp+48h] [rbp-39h]
  unsigned __int64 v21; // [rsp+50h] [rbp-31h]
  void *v22[3]; // [rsp+60h] [rbp-21h] BYREF
  unsigned __int64 v23; // [rsp+78h] [rbp-9h]
  _WORD *v24; // [rsp+D8h] [rbp+57h] BYREF
  _WORD *v25; // [rsp+E0h] [rbp+5Fh]
  __int16 *v26; // [rsp+E8h] [rbp+67h]

  v25 = a3;
  v24 = a2;
  v8 = a2;
  v18 = a2;
  if ( a2 == a3 )
  {
LABEL_18:
    if ( a4 != a5 )
    {
      if ( !a7 || (v15 = (__int64 *)&v24, a2 != a3) )
        v15 = (__int64 *)&v18;
      goto LABEL_24;
    }
  }
  else
  {
    while ( a4 != a5 )
    {
      v26 = a4 + 1;
      v24 = a2 + 1;
      v9 = *a4;
      v17 = *a2;
      v10 = sub_140010540(a6);
      sub_140010820(v10, (__int64)Block);
      if ( v20 == 1 )
      {
        v11 = Block;
        if ( v21 >= 8 )
          v11 = (void **)Block[0];
        v12 = *(_WORD *)v11;
      }
      else
      {
        v12 = v17;
      }
      if ( v21 >= 8 )
        j_free(Block[0]);
      v21 = 7i64;
      v20 = 0i64;
      LOWORD(Block[0]) = 0;
      v13 = sub_140010540(a6);
      sub_140010820(v13, (__int64)v22);
      if ( v22[2] == (void *)1 )
      {
        v14 = v22;
        if ( v23 >= 8 )
          v14 = (void **)v22[0];
        v9 = *(_WORD *)v14;
      }
      if ( v23 >= 8 )
        j_free(v22[0]);
      if ( v12 != v9 )
      {
        *a1 = (__int64)v8;
        return a1;
      }
      a2 = v24;
      a3 = v25;
      a4 = v26;
      if ( v24 == v25 )
        goto LABEL_18;
    }
  }
  v15 = (__int64 *)&v24;
LABEL_24:
  *a1 = *v15;
  return a1;
}

//----- (0000000140013130) ----------------------------------------------------
__int64 *__fastcall sub_140013130(
        __int64 *a1,
        _WORD *a2,
        _WORD *a3,
        unsigned __int16 *a4,
        unsigned __int16 *a5,
        __int64 a6,
        char a7)
{
  _WORD *v8; // rbx
  unsigned __int16 v9; // si
  unsigned __int16 v10; // di
  __int64 v11; // rax
  __int16 v12; // di
  __int64 v13; // rax
  __int64 *v14; // rax
  _WORD *v16; // [rsp+20h] [rbp-28h] BYREF
  _WORD *v17; // [rsp+58h] [rbp+10h] BYREF
  _WORD *v18; // [rsp+60h] [rbp+18h]
  unsigned __int16 *v19; // [rsp+68h] [rbp+20h]

  v18 = a3;
  v17 = a2;
  v8 = a2;
  v16 = a2;
  if ( a2 == a3 )
  {
LABEL_5:
    if ( a4 != a5 )
    {
      if ( !a7 || (v14 = (__int64 *)&v17, a2 != a3) )
        v14 = (__int64 *)&v16;
      goto LABEL_11;
    }
  }
  else
  {
    while ( a4 != a5 )
    {
      v19 = a4 + 1;
      v17 = a2 + 1;
      v9 = *a4;
      v10 = *a2;
      v11 = sub_1400105F0(a6);
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v11 + 48i64))(v11, v10);
      v13 = sub_1400105F0(a6);
      if ( v12 != (*(unsigned __int16 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 48i64))(v13, v9) )
      {
        *a1 = (__int64)v8;
        return a1;
      }
      a2 = v17;
      a3 = v18;
      a4 = v19;
      if ( v17 == v18 )
        goto LABEL_5;
    }
  }
  v14 = (__int64 *)&v17;
LABEL_11:
  *a1 = *v14;
  return a1;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140013220) ----------------------------------------------------
bool __fastcall sub_140013220(__int64 a1)
{
  int v2; // edi
  __int16 v3; // cx
  _WORD *v4; // rax
  _WORD *v5; // rcx
  _WORD *v6; // rax

  v2 = 0x7FFFFFFF;
  *(_WORD *)(a1 + 92) = 0;
  do
  {
    v3 = *(_WORD *)(a1 + 94);
    if ( (unsigned __int16)(v3 - 48) > 9u || v3 == 47 )
      break;
    --v2;
    v4 = *(_WORD **)a1;
    *(_WORD *)(a1 + 92) = v3 - 48 + 10 * *(_WORD *)(a1 + 92);
    v5 = *(_WORD **)(a1 + 16);
    if ( v4 != v5 )
    {
      if ( *v4 == 92 )
      {
        if ( (v6 = v4 + 1, v6 != v5) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v6 == 40 || *v6 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v6 == 123 || *v6 == 125) )
        {
          *(_QWORD *)a1 = v6;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
  }
  while ( v2 );
  return v2 != 0x7FFFFFFF;
}

//----- (00000001400132F0) ----------------------------------------------------
char __fastcall sub_1400132F0(__int64 a1, char a2)
{
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // si
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int16 *v8; // rax
  _WORD *v9; // rcx
  _WORD *v10; // rax

  v4 = sub_140014140(
         *(_QWORD *)(a1 + 80),
         *(unsigned __int16 **)a1,
         (unsigned __int16 *)(*(_QWORD *)a1 + 2i64),
         (*(_DWORD *)(a1 + 88) & 0x100) != 0);
  v5 = v4;
  if ( v4 )
  {
    if ( a2 )
      sub_1400139F0(a1 + 40);
    v6 = *(_QWORD *)(a1 + 48);
    sub_140014930(v6, v5, *(_QWORD *)(a1 + 64));
    *(_WORD *)(v6 + 64) |= v5;
    LOWORD(v6) = *(_WORD *)(a1 + 94);
    v7 = sub_1400105F0(*(_QWORD *)(a1 + 80));
    if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 16i64))(
           v7,
           1i64,
           (unsigned __int16)v6) )
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 48) + 12i64) ^= 1u;
    }
    v8 = *(unsigned __int16 **)a1;
    v9 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v9 )
    {
      if ( *v8 == 92 )
      {
        if ( (v10 = v8 + 1, v10 != v9) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v10 == 40 || *v10 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v10 == 123 || *v10 == 125) )
        {
          *(_QWORD *)a1 = v10;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
    LOBYTE(v4) = 1;
  }
  return v4;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (00000001400133F0) ----------------------------------------------------
char __fastcall sub_1400133F0(__int64 a1)
{
  int v2; // eax
  unsigned __int16 v3; // dx
  _WORD *v4; // rax
  _WORD *v5; // rcx
  _WORD *v6; // rax
  unsigned __int16 v7; // di
  int v8; // eax
  __int16 v9; // ax
  __int64 v10; // rcx
  __int64 v11; // rcx
  int v12; // edx
  __int64 v13; // rbx

  v2 = sub_140013E30(a1);
  if ( !v2 )
    return v2;
  while ( v2 == 2 )
  {
LABEL_30:
    v2 = sub_140013E30(a1);
    if ( !v2 )
      return v2;
  }
  v3 = *(_WORD *)(a1 + 92);
  if ( !v3 && (*(_DWORD *)(a1 + 100) & 0x100000) == 0 )
    std::tr1::_Xbad(2i64);
  if ( *(_DWORD *)(a1 + 96) != 45 )
  {
    v11 = a1 + 40;
    if ( dword_14012E170 > v3 || v3 >= 0x100u )
      sub_140014610(v11, v3);
    else
      sub_140014580(v11, v3);
    goto LABEL_30;
  }
  v4 = *(_WORD **)a1;
  v5 = *(_WORD **)(a1 + 16);
  if ( *(_WORD **)a1 != v5 )
  {
    if ( *v4 == 92 )
    {
      if ( (v6 = v4 + 1, v6 != v5) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v6 == 40 || *v6 == 41)
        || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v6 == 123 || *v6 == 125) )
      {
        *(_QWORD *)a1 = v6;
      }
    }
    *(_QWORD *)a1 += 2i64;
  }
  sub_14000FDE0(a1);
  v7 = *(_WORD *)(a1 + 92);
  v8 = sub_140013E30(a1);
  if ( v8 )
  {
    if ( v8 == 2 )
      std::tr1::_Xbad(8i64);
    if ( (*(_DWORD *)(a1 + 88) & 0x800) != 0 )
    {
      v9 = sub_140010330(*(_QWORD *)(a1 + 80), *(_WORD *)(a1 + 92));
      v10 = *(_QWORD *)(a1 + 80);
      *(_WORD *)(a1 + 92) = v9;
      v7 = sub_140010330(v10, v7);
    }
    if ( *(_WORD *)(a1 + 92) < v7 )
      std::tr1::_Xbad(8i64);
    sub_1400142C0(a1 + 40, v7, *(_WORD *)(a1 + 92));
    goto LABEL_30;
  }
  v12 = *(unsigned __int16 *)(a1 + 92);
  v13 = a1 + 40;
  if ( dword_14012E170 > v12 || (unsigned __int16)v12 >= 0x100u )
    sub_140014610(v13, v12);
  else
    sub_140014580(v13, v12);
  if ( dword_14012E170 > 45 )
    LOBYTE(v2) = sub_140014610(v13, 0x2Du);
  else
    LOBYTE(v2) = sub_140014580(v13, 0x2Du);
  return v2;
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);
// 14012E170: using guessed type int dword_14012E170;

//----- (00000001400135B0) ----------------------------------------------------
char __fastcall sub_1400135B0(__int64 a1)
{
  int v1; // eax
  __int16 v3; // cx
  __int16 v4; // cx
  __int16 v5; // cx
  _WORD *v6; // rdx
  _WORD *v7; // rcx
  _WORD *v8; // rcx
  __int16 v9; // cx
  _WORD *v10; // rcx
  _WORD *v11; // rdx
  _WORD *v12; // rcx
  unsigned __int16 v13; // bx
  __int64 v14; // rax
  int v15; // ebx
  unsigned __int16 v16; // cx
  int v17; // ecx
  __int16 v18; // ax
  _WORD *v19; // rcx
  _WORD *v20; // rax
  _WORD *v21; // rax
  int v22; // ebx
  unsigned __int16 v23; // cx
  int v24; // ecx
  __int16 v25; // ax
  _WORD *v26; // rcx
  _WORD *v27; // rax
  _WORD *v28; // rax

  v1 = *(_DWORD *)(a1 + 100);
  if ( (v1 & 0x10000) != 0 )
  {
    v3 = *(_WORD *)(a1 + 94);
    switch ( v3 )
    {
      case 'f':
        v4 = 12;
LABEL_17:
        v6 = *(_WORD **)(a1 + 16);
        *(_WORD *)(a1 + 92) = v4;
        v7 = *(_WORD **)a1;
        if ( *(_WORD **)a1 != v6 )
        {
          if ( *v7 == 92 )
          {
            if ( (v8 = v7 + 1, v8 != v6) && (v1 & 8) == 0 && (*v8 == 40 || *v8 == 41)
              || (v1 & 0x10) == 0 && (*v8 == 123 || *v8 == 125) )
            {
              *(_QWORD *)a1 = v8;
            }
          }
          *(_QWORD *)a1 += 2i64;
        }
        sub_14000FDE0(a1);
        return 1;
      case 'n':
        v4 = 10;
        goto LABEL_17;
      case 'r':
        v4 = 13;
        goto LABEL_17;
      case 't':
        v4 = 9;
        goto LABEL_17;
      case 'v':
        v4 = 11;
        goto LABEL_17;
    }
  }
  if ( (v1 & 0x8000) != 0 )
  {
    v5 = *(_WORD *)(a1 + 94);
    if ( v5 == 97 )
    {
      v4 = 7;
      goto LABEL_17;
    }
    if ( v5 == 98 )
    {
      v4 = 8;
      goto LABEL_17;
    }
  }
  v9 = *(_WORD *)(a1 + 94);
  if ( v9 == 99 && (v1 & 0x40000) != 0 )
  {
    v10 = *(_WORD **)a1;
    v11 = *(_WORD **)(a1 + 16);
    if ( *(_WORD **)a1 != v11 )
    {
      if ( *v10 == 92 )
      {
        if ( (v12 = v10 + 1, v12 != v11) && (v1 & 8) == 0 && (*v12 == 40 || *v12 == 41)
          || (v1 & 0x10) == 0 && (*v12 == 123 || *v12 == 125) )
        {
          *(_QWORD *)a1 = v12;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
    v13 = *(_WORD *)(a1 + 94);
    v14 = sub_1400105F0(*(_QWORD *)(a1 + 80));
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v14 + 16i64))(v14, 259i64, v13) )
      std::tr1::_Xbad(2i64);
    *(_WORD *)(a1 + 92) = *(_BYTE *)(a1 + 94) & 0x1F;
    sub_1400115D0(a1);
    return 1;
  }
  if ( v9 == 120 && (v1 & 0x1000) != 0 )
  {
    sub_1400115D0(a1);
    v15 = 2;
    *(_WORD *)(a1 + 92) = 0;
    while ( 1 )
    {
      v16 = *(_WORD *)(a1 + 94);
      if ( (unsigned __int16)(v16 - 48) > 9u )
      {
        if ( (unsigned __int16)(v16 - 97) > 5u )
        {
          if ( (unsigned __int16)(v16 - 65) > 5u )
            goto LABEL_95;
          v17 = v16 - 55;
        }
        else
        {
          v17 = v16 - 87;
        }
      }
      else
      {
        v17 = v16 - 48;
      }
      if ( v17 == -1 )
        goto LABEL_95;
      --v15;
      v18 = v17 + 16 * *(_WORD *)(a1 + 92);
      v19 = *(_WORD **)(a1 + 16);
      *(_WORD *)(a1 + 92) = v18;
      v20 = *(_WORD **)a1;
      if ( *(_WORD **)a1 != v19 )
      {
        if ( *v20 == 92 )
        {
          if ( (v21 = v20 + 1, v21 != v19) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v21 == 40 || *v21 == 41)
            || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v21 == 123 || *v21 == 125) )
          {
            *(_QWORD *)a1 = v21;
          }
        }
        *(_QWORD *)a1 += 2i64;
      }
      sub_14000FDE0(a1);
      if ( !v15 )
        return 1;
    }
  }
  if ( v9 == 117 && (v1 & 0x800) != 0 )
  {
    sub_1400115D0(a1);
    v22 = 4;
    *(_WORD *)(a1 + 92) = 0;
    while ( 1 )
    {
      v23 = *(_WORD *)(a1 + 94);
      if ( (unsigned __int16)(v23 - 48) > 9u )
      {
        if ( (unsigned __int16)(v23 - 97) > 5u )
        {
          if ( (unsigned __int16)(v23 - 65) > 5u )
            goto LABEL_95;
          v24 = v23 - 55;
        }
        else
        {
          v24 = v23 - 87;
        }
      }
      else
      {
        v24 = v23 - 48;
      }
      if ( v24 == -1 )
        goto LABEL_95;
      --v22;
      v25 = v24 + 16 * *(_WORD *)(a1 + 92);
      v26 = *(_WORD **)(a1 + 16);
      *(_WORD *)(a1 + 92) = v25;
      v27 = *(_WORD **)a1;
      if ( *(_WORD **)a1 != v26 )
      {
        if ( *v27 == 92 )
        {
          if ( (v28 = v27 + 1, v28 != v26) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v28 == 40 || *v28 == 41)
            || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v28 == 123 || *v28 == 125) )
          {
            *(_QWORD *)a1 = v28;
          }
        }
        *(_QWORD *)a1 += 2i64;
      }
      sub_14000FDE0(a1);
      if ( !v22 )
        return 1;
    }
  }
  if ( (v1 & 0x2000) != 0 && sub_140013D70(a1) )
  {
    if ( *(_WORD *)(a1 + 92) )
      return 1;
LABEL_95:
    std::tr1::_Xbad(2i64);
  }
  return sub_140013FB0(a1);
}
// 14001381E: conditional instruction was optimized away because ebx.4!=0
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140013950) ----------------------------------------------------
__int64 __fastcall sub_140013950(__int64 a1)
{
  _DWORD *v2; // rbx

  v2 = sub_140011C60(a1 + 40, 8);
  sub_14000FFE0(a1);
  return sub_1400101E0(a1 + 40, (__int64)v2);
}

//----- (00000001400139A0) ----------------------------------------------------
__int64 __fastcall sub_1400139A0(__int64 a1, char a2)
{
  _DWORD *v3; // rbx
  __int64 result; // rax

  v3 = sub_140014490(a1 + 40, a2);
  sub_14000FFE0(a1);
  result = sub_1400101E0(a1 + 40, (__int64)v3);
  *(_QWORD *)(a1 + 48) = v3;
  return result;
}

//----- (00000001400139F0) ----------------------------------------------------
__int64 __fastcall sub_1400139F0(__int64 a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // r11
  __int64 v4; // rcx
  __int64 result; // rax

  v2 = operator new(0x50ui64);
  v3 = v2;
  if ( v2 )
  {
    v2[2] = 7;
    *(_QWORD *)v2 = &std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';
    v2[3] = 0;
    *((_QWORD *)v2 + 2) = 0i64;
    *((_QWORD *)v2 + 3) = 0i64;
    *((_QWORD *)v2 + 4) = 0i64;
    *((_QWORD *)v2 + 5) = 0i64;
    *((_QWORD *)v2 + 6) = 0i64;
    *((_QWORD *)v2 + 7) = 0i64;
    *((_WORD *)v2 + 32) = 0;
    *((_QWORD *)v2 + 9) = 0i64;
  }
  else
  {
    v3 = 0i64;
  }
  *((_QWORD *)v3 + 3) = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v4 )
  {
    *((_QWORD *)v3 + 2) = v4;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v3;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(a1 + 8) = v3;
  return result;
}
// 1400F7388: using guessed type void *std::tr1::_Node_class<wchar_t,std::tr1::regex_traits<wchar_t>>::`vftable';

//----- (0000000140013A80) ----------------------------------------------------
__int64 __fastcall sub_140013A80(__int64 a1, int a2)
{
  _DWORD *v4; // rax
  _DWORD *v5; // r11
  __int64 v6; // rcx
  __int64 result; // rax

  v4 = operator new(0x28ui64);
  v5 = v4;
  if ( v4 )
  {
    v4[2] = 15;
    v4[8] = a2;
    v4[3] = 0;
    *((_QWORD *)v4 + 2) = 0i64;
    *((_QWORD *)v4 + 3) = 0i64;
    *(_QWORD *)v4 = &std::tr1::_Node_back::`vftable';
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)v5 + 3) = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v6 )
  {
    *((_QWORD *)v5 + 2) = v6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v5;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 16) = v5;
  *(_QWORD *)(a1 + 8) = v5;
  return result;
}
// 1400F7298: using guessed type void *std::tr1::_Node_back::`vftable';

//----- (0000000140013B10) ----------------------------------------------------
__int64 __fastcall sub_140013B10(__int64 a1, int a2, int a3, char a4)
{
  __int64 v5; // rcx
  __int64 v9; // rax
  unsigned int v10; // edx
  __int64 v11; // rdi
  _QWORD *v12; // rax
  _QWORD *v13; // rbx
  int v14; // ecx
  _DWORD *v15; // rax
  _DWORD *v16; // r11
  __int64 v17; // rcx
  int v18; // eax
  __int64 result; // rax

  v5 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v5 + 8) == 6 && *(_DWORD *)(v5 + 36) != 1 )
  {
    v9 = *(_QWORD *)(v5 + 40);
    v10 = *(_DWORD *)(v5 + 36) - 1;
    *(_DWORD *)(v5 + 36) = v10;
    sub_140012EB0(a1, *(_WORD *)(v9 + 2i64 * v10));
  }
  v11 = *(_QWORD *)(a1 + 8);
  v12 = operator new(0x28ui64);
  v13 = v12;
  if ( v12 )
  {
    v14 = *(_DWORD *)(a1 + 16) + 1;
    *(_DWORD *)(a1 + 16) = v14;
    v12[1] = 19i64;
    v12[2] = 0i64;
    v12[3] = 0i64;
    *((_DWORD *)v12 + 8) = v14;
    *v12 = &std::tr1::_Node_end_rep::`vftable';
  }
  else
  {
    v13 = 0i64;
  }
  v15 = operator new(0x30ui64);
  v16 = v15;
  if ( v15 )
  {
    v15[2] = 18;
    *((_QWORD *)v15 + 2) = 0i64;
    *((_QWORD *)v15 + 3) = 0i64;
    *((_QWORD *)v15 + 4) = v13;
    v15[10] = a2;
    v15[11] = a3;
    v15[3] = a4 != 0 ? 2 : 0;
    *(_QWORD *)v15 = &std::tr1::_Node_rep::`vftable';
  }
  else
  {
    v16 = 0i64;
  }
  v13[3] = *(_QWORD *)(a1 + 8);
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v17 )
  {
    v13[2] = v17;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v13;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = v13;
  *(_QWORD *)(a1 + 8) = v13;
  v18 = *(_DWORD *)(v11 + 8);
  if ( v18 == 9 || v18 == 14 )
    v11 = *(_QWORD *)(v11 + 32);
  *(_QWORD *)(*(_QWORD *)(v11 + 24) + 16i64) = v16;
  result = *(_QWORD *)(v11 + 24);
  *((_QWORD *)v16 + 3) = result;
  *(_QWORD *)(v11 + 24) = v16;
  *((_QWORD *)v16 + 2) = v11;
  return result;
}
// 1400F72C8: using guessed type void *std::tr1::_Node_end_rep::`vftable';
// 1400F72D8: using guessed type void *std::tr1::_Node_rep::`vftable';

//----- (0000000140013C80) ----------------------------------------------------
__int64 __fastcall sub_140013C80(__int64 a1)
{
  _DWORD *v2; // rax
  _DWORD *v3; // r11
  __int64 v4; // rcx
  __int64 result; // rax

  v2 = operator new(0x30ui64);
  v3 = v2;
  if ( v2 )
  {
    v2[2] = 6;
    *(_QWORD *)v2 = &std::tr1::_Node_str<wchar_t>::`vftable';
    v2[3] = 0;
    *((_QWORD *)v2 + 2) = 0i64;
    *((_QWORD *)v2 + 3) = 0i64;
    *((_QWORD *)v2 + 4) = 0i64;
    *((_QWORD *)v2 + 5) = 0i64;
  }
  else
  {
    v3 = 0i64;
  }
  *((_QWORD *)v3 + 3) = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v4 )
  {
    *((_QWORD *)v3 + 2) = v4;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v3;
  }
  result = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(a1 + 8) = v3;
  return result;
}
// 1400F7398: using guessed type void *std::tr1::_Node_str<wchar_t>::`vftable';

//----- (0000000140013D00) ----------------------------------------------------
void *__fastcall sub_140013D00(void *Block, char a2)
{
  free(*((void **)Block + 5));
  *(_QWORD *)Block = &loc_1400F7248;
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140013D40) ----------------------------------------------------
__int16 *__fastcall sub_140013D40(__int16 **a1, __int16 *a2, _WORD *a3)
{
  return sub_140014A00((__int64)a1, *a1, a2, a3);
}

//----- (0000000140013D70) ----------------------------------------------------
bool __fastcall sub_140013D70(__int64 a1)
{
  int v2; // edi
  unsigned __int16 v3; // cx
  int v4; // ecx
  __int16 v5; // ax
  _WORD *v6; // rcx
  _WORD *v7; // rax
  _WORD *v8; // rax

  v2 = 3;
  *(_WORD *)(a1 + 92) = 0;
  do
  {
    v3 = *(_WORD *)(a1 + 94);
    if ( (unsigned __int16)(v3 - 48) > 7u )
      break;
    v4 = v3 - 48;
    if ( v4 == -1 )
      break;
    --v2;
    v5 = v4 + 8 * *(_WORD *)(a1 + 92);
    v6 = *(_WORD **)(a1 + 16);
    *(_WORD *)(a1 + 92) = v5;
    v7 = *(_WORD **)a1;
    if ( *(_WORD **)a1 != v6 )
    {
      if ( *v7 == 92 )
      {
        if ( (v8 = v7 + 1, v8 != v6) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v8 == 40 || *v8 == 41)
          || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v8 == 123 || *v8 == 125) )
        {
          *(_QWORD *)a1 = v8;
        }
      }
      *(_QWORD *)a1 += 2i64;
    }
    sub_14000FDE0(a1);
  }
  while ( v2 );
  return v2 != 3;
}

//----- (0000000140013E30) ----------------------------------------------------
__int64 __fastcall sub_140013E30(__int64 a1)
{
  int v1; // eax
  unsigned __int16 *v3; // rax
  unsigned __int16 *v4; // rcx
  unsigned __int16 *v5; // rax
  int v6; // eax
  __int16 v8; // ax
  __int16 v9; // ax
  int v10; // edi

  v1 = *(_DWORD *)(a1 + 96);
  switch ( v1 )
  {
    case 0x5C:
      v3 = *(unsigned __int16 **)a1;
      v4 = *(unsigned __int16 **)(a1 + 16);
      if ( v3 != v4 )
      {
        if ( *v3 == 92 )
        {
          if ( (v5 = v3 + 1, v5 != v4) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v5 == 40 || *v5 == 41)
            || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v5 == 123 || *v5 == 125) )
          {
            *(_QWORD *)a1 = v5;
          }
        }
        *(_QWORD *)a1 += 2i64;
      }
      sub_14000FDE0(a1);
      v6 = *(_DWORD *)(a1 + 100);
      if ( (v6 & 0x200000) != 0 )
        return sub_1400148A0(a1);
      if ( (v6 & 0x10000) != 0 && sub_1400140E0(a1, *(_WORD *)(a1 + 94)) )
        goto LABEL_23;
      if ( (*(_DWORD *)(a1 + 100) & 0x8000) != 0 )
      {
        v8 = *(_WORD *)(a1 + 94);
        if ( v8 == 97 )
        {
          v9 = 7;
LABEL_22:
          *(_WORD *)(a1 + 92) = v9;
LABEL_23:
          sub_1400115D0(a1);
          return 1i64;
        }
        if ( v8 == 98 )
        {
          v9 = 8;
          goto LABEL_22;
        }
      }
      *(_WORD *)(a1 + 92) = 92;
      return 1i64;
    case 0x5B:
      sub_1400115D0(a1);
      v10 = *(_DWORD *)(a1 + 96);
      if ( v10 == 58 || v10 == 61 || v10 == 46 )
      {
        sub_1400115D0(a1);
        sub_1400146D0((unsigned __int16 **)a1, v10);
        sub_1400129B0(a1, 93, 4u);
        return 2i64;
      }
      else
      {
        *(_WORD *)(a1 + 92) = 91;
        return 1i64;
      }
    case 0x5D:
    case 0xFFFF:
      return 0i64;
    default:
      *(_WORD *)(a1 + 92) = *(_WORD *)(a1 + 94);
      sub_1400115D0(a1);
      return 1i64;
  }
}

//----- (0000000140013FB0) ----------------------------------------------------
char __fastcall sub_140013FB0(__int64 a1)
{
  unsigned __int16 v2; // bx
  __int64 v3; // rax
  __int16 v4; // ax
  int v5; // ecx
  _WORD *v6; // rcx
  _WORD *v7; // rax
  _WORD *v8; // rax

  if ( (*(_DWORD *)(a1 + 100) & 0x400000) == 0
    || (v2 = *(_WORD *)(a1 + 94),
        v3 = sub_1400105F0(*(_QWORD *)(a1 + 80)),
        (*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v3 + 16i64))(v3, 263i64, v2))
    || (v4 = *(_WORD *)(a1 + 94), v4 == 95) )
  {
    v5 = *(_DWORD *)(a1 + 100);
    if ( (v5 & 0x400000) != 0
      || (v4 = *(_WORD *)(a1 + 94), v4 != 46) && v4 != 91 && v4 != 92 && v4 != 42 && v4 != 124 && v4 != 94 && v4 != 36 )
    {
      if ( (v5 & 0x800000) == 0
        || (v4 = *(_WORD *)(a1 + 94), v4 != 40) && v4 != 41 && v4 != 43 && v4 != 63 && v4 != 123 && v4 != 125 )
      {
        if ( (v5 & 0x1000000) == 0 )
          return 0;
        v4 = *(_WORD *)(a1 + 94);
        if ( v4 != 34 && v4 != 47 )
          return 0;
      }
    }
  }
  v6 = *(_WORD **)(a1 + 16);
  *(_WORD *)(a1 + 92) = v4;
  v7 = *(_WORD **)a1;
  if ( *(_WORD **)a1 != v6 )
  {
    if ( *v7 == 92 )
    {
      if ( (v8 = v7 + 1, v8 != v6) && (*(_BYTE *)(a1 + 100) & 8) == 0 && (*v8 == 40 || *v8 == 41)
        || (*(_BYTE *)(a1 + 100) & 0x10) == 0 && (*v8 == 123 || *v8 == 125) )
      {
        *(_QWORD *)a1 = v8;
      }
    }
    *(_QWORD *)a1 += 2i64;
  }
  sub_14000FDE0(a1);
  return 1;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (00000001400140E0) ----------------------------------------------------
char __fastcall sub_1400140E0(__int64 a1, __int16 a2)
{
  char result; // al

  switch ( a2 )
  {
    case 'f':
      result = 1;
      *(_WORD *)(a1 + 92) = 12;
      break;
    case 'n':
      result = 1;
      *(_WORD *)(a1 + 92) = 10;
      break;
    case 'r':
      result = 1;
      *(_WORD *)(a1 + 92) = 13;
      break;
    case 't':
      result = 1;
      *(_WORD *)(a1 + 92) = 9;
      break;
    case 'v':
      result = 1;
      *(_WORD *)(a1 + 92) = 11;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (0000000140014140) ----------------------------------------------------
__int64 __fastcall sub_140014140(__int64 a1, unsigned __int16 *a2, unsigned __int16 *a3, char a4)
{
  unsigned __int16 v4; // r14
  __int64 v5; // rdx
  int v6; // ecx
  __int64 v8; // r15
  __int64 v9; // rax
  wchar_t **v10; // r8
  wchar_t *v11; // rsi
  unsigned __int16 *v12; // rbp
  __int64 v13; // r13
  wchar_t v14; // di
  unsigned __int16 v15; // bx
  __int64 v16; // rax
  __int16 v17; // bx
  __int64 v18; // rax
  __int64 v19; // rax
  int v21; // [rsp+20h] [rbp-48h]
  char v24; // [rsp+88h] [rbp+20h]

  v24 = a4;
  v4 = 0;
  v5 = a1;
  v6 = 0;
  v21 = 0;
  v8 = 0i64;
  if ( L"alnum" )
  {
    v9 = 0i64;
    v10 = &off_1400F7090;
    do
    {
      v11 = *v10;
      v12 = a2;
      v13 = (__int64)&(*v10)[*((unsigned int *)&off_1400F7090 + 2 * v9 + 2)];
      if ( a2 == a3 )
      {
LABEL_10:
        if ( v11 == (wchar_t *)v13 )
          break;
      }
      else
      {
        while ( v11 != (wchar_t *)v13 )
        {
          v14 = *v11;
          v15 = *v12;
          v16 = sub_1400105F0(v5);
          v17 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 48i64))(v16, v15);
          v18 = sub_1400105F0(a1);
          ++v12;
          ++v11;
          if ( v17 != (*(unsigned __int16 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v18 + 48i64))(v18, v14) )
            goto LABEL_12;
          v5 = a1;
          if ( v12 == a3 )
            goto LABEL_9;
        }
        if ( v12 == a3 )
        {
LABEL_9:
          v6 = v21;
          goto LABEL_10;
        }
LABEL_12:
        v6 = v21;
      }
      v5 = a1;
      ++v8;
      v21 = ++v6;
      v9 = 2 * v8;
      v10 = &(&off_1400F7090)[2 * v8];
    }
    while ( *v10 );
    a4 = v24;
    v4 = 0;
  }
  v19 = 2i64 * v6;
  if ( (&off_1400F7090)[v19] )
    v4 = *((_WORD *)&off_1400F7090 + 4 * v19 + 6);
  if ( a4 && (v4 & 3) != 0 )
    v4 |= 3u;
  return v4;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);
// 1400F44A8: using guessed type wchar_t aAlnum[6];
// 1400F7090: using guessed type wchar_t *off_1400F7090;

//----- (00000001400142C0) ----------------------------------------------------
__int64 __fastcall sub_1400142C0(__int64 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 i; // rsi
  _QWORD *v9; // rax
  __int64 result; // rax
  _QWORD *v11; // rax
  __int64 v12; // rbp
  unsigned int v13; // eax
  unsigned int v14; // er12
  void *v15; // rax
  std::tr1 *v16; // rcx
  __int64 v17; // rbx
  unsigned int v18; // esi
  unsigned int v19; // esi
  void *v20; // rax
  std::tr1 *v21; // rcx

  if ( (*(_DWORD *)(a1 + 20) & 0x100) != 0 )
  {
    v6 = sub_1400105F0(*(_QWORD *)(a1 + 24));
    a2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 48i64))(v6, a2);
    v7 = sub_1400105F0(*(_QWORD *)(a1 + 24));
    a3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 48i64))(v7, a3);
  }
  for ( i = *(_QWORD *)(a1 + 8); a2 <= a3; ++a2 )
  {
    if ( a3 >= *(int *)(a1 + 32) )
      break;
    if ( !*(_QWORD *)(i + 40) )
    {
      v9 = operator new(0x20ui64);
      if ( v9 )
      {
        *v9 = 0i64;
        v9[1] = 0i64;
        v9[2] = 0i64;
        v9[3] = 0i64;
      }
      else
      {
        v9 = 0i64;
      }
      *(_QWORD *)(i + 40) = v9;
    }
    *(_BYTE *)(((unsigned __int64)a2 >> 3) + *(_QWORD *)(i + 40)) |= 1 << (a2 & 7);
    if ( a2 == a3 )
      break;
  }
  result = a2;
  if ( a3 - a2 >= *(_DWORD *)(a1 + 36) )
  {
    if ( !*(_QWORD *)(i + 56) )
    {
      v11 = operator new(0x10ui64);
      if ( v11 )
      {
        *v11 = 0i64;
        v11[1] = 0i64;
      }
      else
      {
        v11 = 0i64;
      }
      *(_QWORD *)(i + 56) = v11;
    }
    v12 = *(_QWORD *)(i + 56);
    v13 = *(_DWORD *)(v12 + 4);
    if ( *(_DWORD *)v12 <= v13 )
    {
      v14 = v13 + 16;
      v15 = realloc(*(void **)(v12 + 8), 2i64 * (int)(v13 + 16));
      if ( !v15 )
        std::tr1::_Xmem(v16);
      *(_QWORD *)(v12 + 8) = v15;
      *(_DWORD *)v12 = v14;
    }
    *(_WORD *)(*(_QWORD *)(v12 + 8) + 2i64 * (unsigned int)(*(_DWORD *)(v12 + 4))++) = a2;
    v17 = *(_QWORD *)(i + 56);
    v18 = *(_DWORD *)(v17 + 4);
    if ( *(_DWORD *)v17 <= v18 )
    {
      v19 = v18 + 16;
      v20 = realloc(*(void **)(v17 + 8), 2i64 * (int)v19);
      if ( !v20 )
        std::tr1::_Xmem(v21);
      *(_QWORD *)(v17 + 8) = v20;
      *(_DWORD *)v17 = v19;
    }
    result = *(_QWORD *)(v17 + 8);
    *(_WORD *)(result + 2i64 * (unsigned int)(*(_DWORD *)(v17 + 4))++) = a3;
  }
  else
  {
    for ( ; a2 <= a3; ++a2 )
    {
      result = sub_140014610(a1, a2);
      if ( a2 == a3 )
        break;
    }
  }
  return result;
}
// 140014410: variable 'v16' is possibly undefined
// 140014450: variable 'v21' is possibly undefined
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140014490) ----------------------------------------------------
_DWORD *__fastcall sub_140014490(__int64 a1, char a2)
{
  _DWORD *v4; // rbx
  _QWORD *v5; // r11
  __int64 v6; // rcx

  v4 = operator new(0x28ui64);
  if ( v4 )
  {
    v4[2] = (a2 != 0) + 10;
    v4[3] = 0;
    *((_QWORD *)v4 + 2) = 0i64;
    *((_QWORD *)v4 + 3) = 0i64;
    *(_QWORD *)v4 = &std::tr1::_Node_assert::`vftable';
    *((_QWORD *)v4 + 4) = 0i64;
  }
  else
  {
    v4 = 0i64;
  }
  v5 = operator new(0x20ui64);
  if ( v5 )
  {
    *v5 = &loc_1400F7248;
    v5[1] = 1i64;
    v5[2] = 0i64;
    v5[3] = 0i64;
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)v4 + 3) = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64);
  if ( v6 )
  {
    *((_QWORD *)v4 + 2) = v6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) + 24i64) = v4;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16i64) = v4;
  *((_QWORD *)v4 + 4) = v5;
  v5[3] = v4;
  *(_QWORD *)(a1 + 8) = v5;
  return v4;
}
// 1400F7278: using guessed type void *std::tr1::_Node_assert::`vftable';

//----- (0000000140014580) ----------------------------------------------------
char __fastcall sub_140014580(__int64 a1, unsigned __int16 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  _QWORD *v6; // rax
  char result; // al

  if ( (*(_DWORD *)(a1 + 20) & 0x100) != 0 )
  {
    v4 = sub_1400105F0(*(_QWORD *)(a1 + 24));
    a2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 48i64))(v4, a2);
  }
  v5 = *(_QWORD *)(a1 + 8);
  if ( !*(_QWORD *)(v5 + 40) )
  {
    v6 = operator new(0x20ui64);
    if ( v6 )
    {
      *v6 = 0i64;
      v6[1] = 0i64;
      v6[2] = 0i64;
      v6[3] = 0i64;
    }
    *(_QWORD *)(v5 + 40) = v6;
  }
  result = 1 << (a2 & 7);
  *(_BYTE *)(((unsigned __int64)a2 >> 3) + *(_QWORD *)(v5 + 40)) |= result;
  return result;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140014610) ----------------------------------------------------
__int64 __fastcall sub_140014610(__int64 a1, unsigned __int16 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // rbx
  unsigned int v8; // eax
  unsigned int v9; // esi
  void *v10; // rax
  std::tr1 *v11; // rcx
  __int64 result; // rax

  if ( (*(_DWORD *)(a1 + 20) & 0x100) != 0 )
  {
    v4 = sub_1400105F0(*(_QWORD *)(a1 + 24));
    a2 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 48i64))(v4, a2);
  }
  v5 = *(_QWORD *)(a1 + 8);
  if ( !*(_QWORD *)(v5 + 48) )
  {
    v6 = operator new(0x10ui64);
    if ( v6 )
    {
      *v6 = 0i64;
      v6[1] = 0i64;
    }
    else
    {
      v6 = 0i64;
    }
    *(_QWORD *)(v5 + 48) = v6;
  }
  v7 = *(_QWORD *)(v5 + 48);
  v8 = *(_DWORD *)(v7 + 4);
  if ( *(_DWORD *)v7 <= v8 )
  {
    v9 = v8 + 16;
    v10 = realloc(*(void **)(v7 + 8), 2i64 * (int)(v8 + 16));
    if ( !v10 )
      std::tr1::_Xmem(v11);
    *(_QWORD *)(v7 + 8) = v10;
    *(_DWORD *)v7 = v9;
  }
  result = *(_QWORD *)(v7 + 8);
  *(_WORD *)(result + 2i64 * (unsigned int)(*(_DWORD *)(v7 + 4))++) = a2;
  return result;
}
// 14001469D: variable 'v11' is possibly undefined
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (00000001400146D0) ----------------------------------------------------
char __fastcall sub_1400146D0(unsigned __int16 **a1, int a2)
{
  unsigned __int16 *v2; // rbp
  unsigned int v3; // er12
  __int64 i; // rsi
  unsigned __int16 *v7; // rax
  unsigned __int16 *v8; // rcx
  unsigned __int16 *v9; // rdx
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // si
  unsigned __int16 *v12; // rbx
  unsigned __int16 *v13; // rax
  unsigned __int16 *v14; // rcx
  unsigned __int16 *v15; // rax

  v2 = *a1;
  v3 = 0;
  for ( i = 0i64; *((_DWORD *)a1 + 24) != 0xFFFF; ++i )
  {
    if ( *((_DWORD *)a1 + 24) == a2 )
      break;
    v7 = *a1;
    v8 = a1[2];
    if ( *a1 != v8 )
    {
      if ( *v7 == 92 )
      {
        if ( (v9 = v7 + 1, v7 + 1 != v8) && (*((_BYTE *)a1 + 100) & 8) == 0 && (*v9 == 40 || *v9 == 41)
          || (*((_BYTE *)a1 + 100) & 0x10) == 0 && (*v9 == 123 || *v9 == 125) )
        {
          *a1 = v9;
        }
      }
      ++*a1;
    }
    sub_14000FDE0((__int64)a1);
  }
  if ( *((_DWORD *)a1 + 24) == 0xFFFF )
  {
    if ( a2 != 46 )
    {
      v3 = 14;
      if ( a2 == 58 )
        v3 = 1;
    }
    std::tr1::_Xbad(v3);
  }
  switch ( a2 )
  {
    case ':':
      v10 = sub_140014140((__int64)a1[10], v2, *a1, ((_DWORD)a1[11] & 0x100) != 0);
      v11 = v10;
      if ( !v10 )
        std::tr1::_Xbad(1i64);
      v12 = a1[6];
      sub_140014930((__int64)v12, v10, (__int64)a1[8]);
      v12[32] |= v11;
      break;
    case '=':
      if ( v2 == *a1 )
        std::tr1::_Xbad(0i64);
      sub_140014B70(a1 + 5, v2, *a1, i);
      break;
    case '.':
      if ( v2 == *a1 )
        std::tr1::_Xbad(0i64);
      sub_140014D90((__int16 *)v2, (__int16 *)*a1, i, (_DWORD **)a1[6] + 4);
      break;
  }
  v13 = *a1;
  v14 = a1[2];
  if ( *a1 != v14 )
  {
    if ( *v13 == 92 )
    {
      if ( (v15 = v13 + 1, v15 != v14) && (*((_BYTE *)a1 + 100) & 8) == 0 && (*v15 == 40 || *v15 == 41)
        || (*((_BYTE *)a1 + 100) & 0x10) == 0 && (*v15 == 123 || *v15 == 125) )
      {
        *a1 = v15;
      }
    }
    ++*a1;
  }
  return sub_14000FDE0((__int64)a1);
}
// 140014B70: using guessed type __int64 __fastcall sub_140014B70(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (00000001400148A0) ----------------------------------------------------
__int64 __fastcall sub_1400148A0(__int64 a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 100);
  if ( (v1 & 0x4000) != 0 && *(_WORD *)(a1 + 94) == 92 )
  {
    *(_WORD *)(a1 + 92) = 92;
    sub_1400115D0(a1);
    return 1i64;
  }
  else if ( (v1 & 0x20000) != 0 && sub_1400132F0(a1, 0) )
  {
    return 2i64;
  }
  else if ( sub_140013220(a1) )
  {
    if ( *(_WORD *)(a1 + 92) )
      std::tr1::_Xbad(2i64);
    return 1i64;
  }
  else
  {
    return sub_1400135B0(a1) != 0;
  }
}
// 14002CC34: using guessed type void __fastcall __noreturn std::tr1::_Xbad(_QWORD);

//----- (0000000140014930) ----------------------------------------------------
void __fastcall sub_140014930(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  int i; // ebx
  __int64 v7; // rax
  __int64 v8; // rdx
  _QWORD *v9; // rax

  for ( i = 0; i < 256; ++i )
  {
    if ( a2 != 0xFFFF )
    {
      v7 = sub_1400105F0(a3);
      v8 = a2;
      goto LABEL_6;
    }
    if ( (_WORD)i != 95 )
    {
      v7 = sub_1400105F0(a3);
      v8 = 263i64;
LABEL_6:
      if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 16i64))(
              v7,
              v8,
              (unsigned __int16)i) )
        continue;
    }
    if ( !*(_QWORD *)(a1 + 40) )
    {
      v9 = operator new(0x20ui64);
      if ( v9 )
      {
        *v9 = 0i64;
        v9[1] = 0i64;
        v9[2] = 0i64;
        v9[3] = 0i64;
      }
      *(_QWORD *)(a1 + 40) = v9;
    }
    *(_BYTE *)(((unsigned __int64)(unsigned int)i >> 3) + *(_QWORD *)(a1 + 40)) |= 1 << (i & 7);
  }
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140014A00) ----------------------------------------------------
__int16 *__fastcall sub_140014A00(__int64 a1, __int16 *a2, __int16 *a3, _WORD *a4)
{
  __int16 *result; // rax
  unsigned __int64 v6; // r12
  __int64 v7; // rdx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rdi
  char *v10; // r13
  size_t v11; // rbx
  char *v12; // rax
  _WORD *v13; // rax
  unsigned __int64 v14; // r12

  result = a3;
  v6 = a4 - a3;
  if ( v6 )
  {
    v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
    if ( 0x7FFFFFFFFFFFFFFFi64 - v7 < v6 )
      sub_14002B5F8("vector<T> too long");
    v8 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 1;
    if ( v8 >= v7 + v6 )
    {
      sub_140014FE0(a3, a4, *(_WORD **)(a1 + 8));
      result = sub_140014D30(a2, *(__int16 **)(a1 + 8), (__int16 *)(2 * v6 + *(_QWORD *)(a1 + 8)));
      *(_QWORD *)(a1 + 8) += 2 * v6;
    }
    else
    {
      if ( 0x7FFFFFFFFFFFFFFFi64 - (v8 >> 1) >= v8 )
        v9 = (v8 >> 1) + v8;
      else
        v9 = 0i64;
      if ( v9 < v7 + v6 )
        v9 = v7 + v6;
      v10 = (char *)sub_140009740(a1 + 24, v9);
      v11 = 2 * (((__int64)a2 - *(_QWORD *)a1) >> 1);
      v12 = (char *)memmove(v10, *(const void **)a1, v11);
      v13 = sub_140014FE0(a3, a4, &v12[v11]);
      memmove(v13, a2, 2 * ((__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)a2) >> 1));
      v14 = ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1) + v6;
      if ( *(_QWORD *)a1 )
        j_free(*(void **)a1);
      *(_QWORD *)(a1 + 16) = &v10[2 * v9];
      result = (__int16 *)&v10[2 * v14];
      *(_QWORD *)(a1 + 8) = result;
      *(_QWORD *)a1 = v10;
    }
  }
  return result;
}

//----- (0000000140014D30) ----------------------------------------------------
__int16 *__fastcall sub_140014D30(__int16 *a1, __int16 *a2, __int16 *a3)
{
  if ( a1 == a2 || a2 == a3 )
    return a1;
  sub_140015020(a1, (__int64)a2, a3);
  return &a1[a3 - a2];
}

//----- (0000000140014D90) ----------------------------------------------------
void __fastcall sub_140014D90(__int16 *a1, __int16 *a2, unsigned int a3, _DWORD **a4)
{
  _DWORD *v4; // rsi
  unsigned int **v5; // rbx
  unsigned int *v9; // rax
  unsigned int *v10; // rax

  v4 = *a4;
  v5 = a4;
  if ( !*a4 )
    goto LABEL_6;
  do
  {
    v9 = *v5;
    if ( a3 >= **v5 )
      break;
    v5 = (unsigned int **)(v9 + 6);
  }
  while ( *((_QWORD *)v9 + 3) );
  v4 = *v5;
  if ( !*v5 || a3 != *v4 )
  {
LABEL_6:
    v10 = (unsigned int *)operator new(0x20ui64);
    if ( v10 )
    {
      *v10 = a3;
      *((_QWORD *)v10 + 1) = 0i64;
      *((_QWORD *)v10 + 2) = 0i64;
    }
    else
    {
      v10 = 0i64;
    }
    *v5 = v10;
    *((_QWORD *)v10 + 3) = v4;
  }
  sub_140014F50((__int64)(*v5 + 2), a1, a2);
}

//----- (0000000140014F50) ----------------------------------------------------
void __fastcall sub_140014F50(__int64 a1, __int16 *a2, __int16 *a3)
{
  __int16 *v4; // rdi
  unsigned int v6; // eax
  __int16 v7; // si
  unsigned int v8; // ebp
  void *v9; // rax
  std::tr1 *v10; // rcx

  if ( a2 != a3 )
  {
    v4 = a2;
    do
    {
      v6 = *(_DWORD *)(a1 + 4);
      v7 = *v4;
      if ( *(_DWORD *)a1 <= v6 )
      {
        v8 = v6 + 16;
        v9 = realloc(*(void **)(a1 + 8), 2i64 * (int)(v6 + 16));
        if ( !v9 )
          std::tr1::_Xmem(v10);
        *(_QWORD *)(a1 + 8) = v9;
        *(_DWORD *)a1 = v8;
      }
      ++v4;
      *(_WORD *)(*(_QWORD *)(a1 + 8) + 2i64 * (unsigned int)(*(_DWORD *)(a1 + 4))++) = v7;
    }
    while ( v4 != a3 );
  }
}
// 140014F99: variable 'v10' is possibly undefined

//----- (0000000140014FE0) ----------------------------------------------------
_WORD *__fastcall sub_140014FE0(_WORD *a1, _WORD *a2, _WORD *a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
      *a3 = *a1;
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140015020) ----------------------------------------------------
__int64 __fastcall sub_140015020(__int16 *a1, __int64 a2, __int16 *a3)
{
  __int64 v5; // r10
  signed __int64 v6; // r9
  __int64 v7; // r11
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 result; // rax
  __int64 v11; // rt2
  __int64 v12; // r9
  __int16 *v13; // r8
  __int16 *v14; // rdx
  __int16 *v15; // rdi
  __int16 v16; // cx
  __int64 v17; // rcx

  v5 = (a2 - (__int64)a1) >> 1;
  v6 = a3 - a1;
  v7 = v6;
  v8 = v5;
  if ( v5 )
  {
    do
    {
      v9 = v7;
      v7 = v8;
      v11 = v9 % v8;
      result = v9 / v8;
      v8 = v11;
    }
    while ( v11 );
  }
  if ( v7 < v6 && v7 > 0 )
  {
    v12 = v5;
    v13 = &a1[v7];
    do
    {
      v14 = &v13[v12];
      v15 = v13;
      if ( &v13[v12] == a3 )
        v14 = a1;
      do
      {
        v16 = *v15;
        result = (unsigned __int16)*v14;
        *v15 = result;
        *v14 = v16;
        v15 = v14;
        v17 = a3 - v14;
        if ( v5 >= v17 )
        {
          result = v5 - v17;
          v14 = &a1[v5 - v17];
        }
        else
        {
          v14 = (__int16 *)((char *)v14 + v12 * 2);
        }
      }
      while ( v14 != v13 );
      --v7;
      --v13;
    }
    while ( v7 > 0 );
  }
  return result;
}

//----- (00000001400150E0) ----------------------------------------------------
void __fastcall sub_1400150E0(__int16 **a1, const void *a2, __int64 a3)
{
  sub_140015110((__int64)a1, *a1, a2, a3);
}

//----- (0000000140015110) ----------------------------------------------------
void __fastcall sub_140015110(__int64 a1, __int16 *a2, const void *a3, __int64 a4)
{
  unsigned __int64 v6; // r12
  void *v7; // r10
  const void *v8; // r9
  __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rdi
  char *v12; // r13
  size_t v13; // rbx
  char *v14; // rcx
  char *v15; // rax
  unsigned __int64 v16; // r12

  v6 = (a4 - (__int64)a3) >> 1;
  if ( v6 )
  {
    v7 = *(void **)(a1 + 8);
    v8 = *(const void **)a1;
    v9 = ((__int64)v7 - *(_QWORD *)a1) >> 1;
    if ( 0x7FFFFFFFFFFFFFFFi64 - v9 < v6 )
      sub_14002B5F8("vector<T> too long");
    v10 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v8) >> 1;
    if ( v10 >= v9 + v6 )
    {
      memmove(v7, a3, 2 * v6);
      sub_140014D30(a2, *(__int16 **)(a1 + 8), (__int16 *)(2 * v6 + *(_QWORD *)(a1 + 8)));
      *(_QWORD *)(a1 + 8) += 2 * v6;
    }
    else
    {
      if ( 0x7FFFFFFFFFFFFFFFi64 - (v10 >> 1) >= v10 )
        v11 = (v10 >> 1) + v10;
      else
        v11 = 0i64;
      if ( v11 < v9 + v6 )
        v11 = v9 + v6;
      v12 = (char *)sub_140009740(a1 + 24, v11);
      v13 = 2 * (((__int64)a2 - *(_QWORD *)a1) >> 1);
      v14 = (char *)memmove(v12, *(const void **)a1, v13) + v13;
      v15 = (char *)memmove(v14, a3, 2 * v6);
      memmove(&v15[2 * v6], a2, 2 * ((__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)a2) >> 1));
      v16 = ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1) + v6;
      if ( *(_QWORD *)a1 )
        j_free(*(void **)a1);
      *(_QWORD *)(a1 + 16) = &v12[2 * v11];
      *(_QWORD *)(a1 + 8) = &v12[2 * v16];
      *(_QWORD *)a1 = v12;
    }
  }
}

//----- (0000000140015280) ----------------------------------------------------
_QWORD *__fastcall sub_140015280(__int64 a1, _QWORD *a2)
{
  void *v3; // rdx

  v3 = *(void **)(*(_QWORD *)a1 + 40i64);
  if ( !v3 )
    v3 = (void *)(*(_QWORD *)a1 + 48i64);
  a2[2] = 0i64;
  a2[3] = 15i64;
  *(_BYTE *)a2 = 0;
  sub_140008100(a2, v3, strlen((const char *)v3));
  return a2;
}

//----- (00000001400152E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400152E0(_QWORD *a1, size_t a2, size_t a3, char a4)
{
  size_t v5; // r8
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rax
  _QWORD *v14; // rax
  bool v15; // cf
  _QWORD *v16; // rax

  v5 = a1[2];
  if ( v5 < a2 )
    sub_14002B630("invalid string position");
  if ( -1i64 - v5 <= a3 )
    sub_14002B5F8("string too long");
  if ( a3 )
  {
    v9 = v5 + a3;
    if ( v5 + a3 == -1i64 )
      sub_14002B5F8("string too long");
    v10 = a1[3];
    if ( v10 >= v9 )
    {
      if ( !v9 )
      {
        a1[2] = 0i64;
        if ( v10 < 0x10 )
          *(_BYTE *)a1 = 0;
        else
          *(_BYTE *)*a1 = 0;
        return a1;
      }
    }
    else
    {
      sub_140007EF0(a1, v5 + a3, v5);
      if ( !v9 )
        return a1;
    }
    v11 = a1[3];
    if ( v11 < 0x10 )
      v12 = a1;
    else
      v12 = (_QWORD *)*a1;
    if ( v11 < 0x10 )
      v13 = a1;
    else
      v13 = (_QWORD *)*a1;
    memmove((char *)v13 + a2 + a3, (char *)v12 + a2, a1[2] - a2);
    if ( a3 == 1 )
    {
      if ( a1[3] < 0x10ui64 )
        *((_BYTE *)a1 + a2) = a4;
      else
        *(_BYTE *)(*a1 + a2) = a4;
    }
    else
    {
      if ( a1[3] < 0x10ui64 )
        v14 = a1;
      else
        v14 = (_QWORD *)*a1;
      memset((char *)v14 + a2, a4, a3);
    }
    v15 = a1[3] < 0x10ui64;
    a1[2] = v9;
    if ( v15 )
      v16 = a1;
    else
      v16 = (_QWORD *)*a1;
    *((_BYTE *)v16 + v9) = 0;
  }
  return a1;
}

//----- (0000000140015440) ----------------------------------------------------
char *__fastcall sub_140015440(struct std::ios_base *a1, char a2)
{
  char *v2; // rdi

  v2 = (char *)a1 - 8;
  *(_QWORD *)((char *)a1 + *(int *)(*((_QWORD *)a1 - 1) + 4i64) - 8) = &std::wostream::`vftable';
  *(_QWORD *)a1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(a1);
  if ( (a2 & 1) != 0 )
    j_free(v2);
  return v2;
}
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';

//----- (00000001400154F0) ----------------------------------------------------
__int64 __fastcall sub_1400154F0(__int64 **a1)
{
  __int64 result; // rax
  __int64 v3; // rcx

  if ( !__uncaught_exception() )
    sub_1400154C0(*a1);
  result = **a1;
  v3 = *(__int64 *)((char *)*a1 + *(int *)(result + 4) + 72);
  if ( v3 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
  return result;
}
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);

//----- (0000000140015540) ----------------------------------------------------
void *__fastcall sub_140015540(void *Block, char a2)
{
  sub_1400B9220((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140015570) ----------------------------------------------------
void __fastcall sub_140015570(__int64 *a1)
{
  __int64 v2; // r12
  void **v3; // rax
  void **v4; // rsi
  unsigned __int64 v5; // r13
  bool i; // zf
  __int64 v7; // rax
  __int64 v8; // rcx
  void **v9; // rdx
  void *v10; // r9
  unsigned __int64 v11; // rdi
  __int64 *v12; // rbx
  __int64 *v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  char *v16; // rbx
  unsigned __int64 v17; // rdi
  __int64 *v18; // r8
  void **v19; // rbx
  void **v20; // rdi
  void **v21; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v22; // [rsp+40h] [rbp-C8h]
  char *v23; // [rsp+50h] [rbp-B8h] BYREF
  _QWORD pExceptionObject[4]; // [rsp+58h] [rbp-B0h] BYREF
  _QWORD v25[3]; // [rsp+78h] [rbp-90h] BYREF
  char v26; // [rsp+90h] [rbp-78h] BYREF
  char v27[48]; // [rsp+2B8h] [rbp+1B0h] BYREF

  pExceptionObject[3] = -2i64;
  if ( (unsigned __int64)a1[1] >= 2 )
  {
    v2 = 0i64;
    v22 = 0i64;
    v3 = (void **)operator new(0x38ui64);
    v4 = v3;
    if ( !v3 )
    {
      v23 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v23);
      pExceptionObject[0] = &std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v21 = v3;
    *v3 = v3;
    v3[1] = v3;
    `eh vector constructor iterator'(
      v25,
      0x18ui64,
      26,
      (void (__stdcall *)(void *))sub_14000A570,
      (void (__stdcall *)(void *))sub_14000A590);
    v5 = 0i64;
    for ( i = a1[1] == 0; !i; i = a1[1] == 0 )
    {
      v7 = **(_QWORD **)*a1;
      v8 = *(_QWORD *)*a1;
      v9 = (void **)*v4;
      if ( &v21 != (void ***)a1 )
      {
        if ( v2 == 0x666666666666665i64 )
          sub_14002B5F8("list<T> too long");
        v22 = ++v2;
        --a1[1];
      }
      **(_QWORD **)(v8 + 8) = v7;
      **(_QWORD **)(v7 + 8) = v9;
      *(_QWORD *)v9[1] = v8;
      v10 = v9[1];
      v9[1] = *(void **)(v7 + 8);
      *(_QWORD *)(v7 + 8) = *(_QWORD *)(v8 + 8);
      *(_QWORD *)(v8 + 8) = v10;
      v11 = 0i64;
      if ( !v5 )
        goto LABEL_16;
      v12 = v25;
      do
      {
        if ( !v12[1] )
          break;
        if ( &v21 != (void ***)v12 )
        {
          sub_1400159C0(v12);
          v4 = (void **)*v12;
          *v12 = (__int64)v21;
          v21 = v4;
          v2 = v12[1];
          v12[1] = v22;
          v22 = v2;
        }
        ++v11;
        v12 += 3;
      }
      while ( v11 < v5 );
      if ( v11 == 25 )
      {
        sub_1400159C0(v27);
        v2 = v22;
        v4 = v21;
      }
      else
      {
LABEL_16:
        v13 = &v25[3 * v11];
        if ( v13 != (__int64 *)&v21 )
        {
          v14 = *v13;
          *v13 = (__int64)v4;
          v4 = (void **)v14;
          v21 = (void **)v14;
          v15 = v13[1];
          v13[1] = v2;
          v2 = v15;
          v22 = v15;
        }
        if ( v11 == v5 )
          ++v5;
      }
    }
    if ( v5 > 1 )
    {
      v16 = &v26;
      v17 = v5 - 1;
      do
      {
        if ( v16 - 24 != v16 )
          sub_1400159C0(v16);
        v16 += 24;
        --v17;
      }
      while ( v17 );
    }
    v18 = &pExceptionObject[3 * v5 + 1];
    if ( a1 != v18 && v18[1] )
      sub_140015910((__int64)a1, *(_QWORD *)*a1, (__int64)v18, *(_QWORD *)*v18, *v18, v18[1]);
    `eh vector destructor iterator'(v25, 0x18ui64, 26, (void (__stdcall *)(void *))sub_14000A590);
    v19 = (void **)*v4;
    *v4 = v4;
    v4[1] = v4;
    if ( v19 != v4 )
    {
      do
      {
        v20 = (void **)*v19;
        if ( (unsigned __int64)v19[5] >= 8 )
          j_free(v19[2]);
        v19[5] = (void *)7;
        v19[4] = 0i64;
        *((_WORD *)v19 + 8) = 0;
        j_free(v19);
        v19 = v20;
      }
      while ( v20 != v4 );
    }
    j_free(v4);
  }
}
// 1400159C0: using guessed type __int64 __fastcall sub_1400159C0(_QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 140015570: using guessed type char var_60[48];

//----- (0000000140015890) ----------------------------------------------------
_QWORD *__fastcall sub_140015890(_QWORD *a1, _QWORD *a2, __int64 *a3, __int16 *a4)
{
  unsigned __int64 v7; // r8
  _QWORD *v8; // rcx
  __int16 *v9; // r9
  __int64 v11; // [rsp+38h] [rbp-10h] BYREF

  a1[3] = 7i64;
  a1[2] = 0i64;
  *(_WORD *)a1 = 0;
  v7 = a2[3];
  if ( v7 < 8 )
    v8 = a2;
  else
    v8 = (_QWORD *)*a2;
  v9 = (__int16 *)v8 + a2[2];
  if ( v7 >= 8 )
    a2 = (_QWORD *)*a2;
  sub_140015B60(&v11, a1, (__int16 *)a2, v9, a3, a4);
  return a1;
}

//----- (0000000140015910) ----------------------------------------------------
__int64 __fastcall sub_140015910(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6)
{
  __int64 v6; // r10
  __int64 v7; // r8
  __int64 result; // rax

  if ( a1 != a3 )
  {
    v6 = *(_QWORD *)(a1 + 8);
    if ( 0x666666666666665i64 - v6 < a6 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v6 + a6;
    *(_QWORD *)(a3 + 8) -= a6;
  }
  **(_QWORD **)(a4 + 8) = a5;
  **(_QWORD **)(a5 + 8) = a2;
  **(_QWORD **)(a2 + 8) = a4;
  v7 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = *(_QWORD *)(a4 + 8);
  result = a4;
  *(_QWORD *)(a4 + 8) = v7;
  return result;
}

//----- (0000000140015B60) ----------------------------------------------------
_QWORD *__fastcall sub_140015B60(_QWORD *a1, _QWORD *a2, __int16 *a3, __int16 *a4, __int64 *a5, __int16 *a6)
{
  __int16 *v7; // rdi
  int v8; // er13
  __int64 *v9; // r15
  __int16 *v10; // rsi
  __int16 *v11; // rdi
  __int64 i; // r12
  unsigned __int64 v13; // r8
  _QWORD *v14; // rcx
  __int64 v15; // rdx
  _QWORD *v16; // rax
  unsigned __int64 v17; // rdx
  __int16 *v18; // rcx
  __int16 *v19; // r9
  _QWORD *v20; // rax
  __int16 *v21; // rcx
  __int16 *v22; // r9
  _QWORD *v23; // rbx
  void *j; // r12
  __int64 v25; // rdx
  __int64 *v26; // rax
  __int64 *v27; // rcx
  __int64 *v28; // rax
  int v29; // eax
  unsigned __int64 v30; // r8
  _QWORD *v31; // rcx
  __int64 v32; // rdx
  _QWORD *v33; // rax
  __int64 v35; // [rsp+38h] [rbp-69h] BYREF
  void *Block; // [rsp+40h] [rbp-61h]
  __int64 v37; // [rsp+48h] [rbp-59h]
  __int64 v38; // [rsp+50h] [rbp-51h]
  __int16 *v39; // [rsp+60h] [rbp-41h]
  __int64 v40; // [rsp+68h] [rbp-39h]
  char v41; // [rsp+70h] [rbp-31h]
  __int64 v42; // [rsp+78h] [rbp-29h]
  __int64 v43; // [rsp+80h] [rbp-21h]
  char v44; // [rsp+88h] [rbp-19h]
  __int64 v45[2]; // [rsp+90h] [rbp-11h] BYREF
  char v46; // [rsp+A0h] [rbp-1h]
  _QWORD v47[8]; // [rsp+A8h] [rbp+7h] BYREF
  __int64 v50; // [rsp+108h] [rbp+67h] BYREF

  v47[1] = -2i64;
  v7 = a3;
  Block = 0i64;
  v37 = 0i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v41 = 0;
  v42 = 0i64;
  v43 = 0i64;
  v44 = 0;
  v45[0] = 0i64;
  v45[1] = 0i64;
  v46 = 0;
  v8 = 0;
  v9 = a5;
  if ( sub_140015E00(a3, a4, &v35, a5, 0, (__int64)a3) )
  {
    v10 = a6;
    while ( 1 )
    {
      v11 = v39;
      for ( i = v40; v11 != (__int16 *)i; ++v11 )
      {
        v13 = a2[3];
        if ( v13 < 8 )
          v14 = a2;
        else
          v14 = (_QWORD *)*a2;
        v15 = (__int64)v14 + 2 * a2[2];
        if ( v13 < 8 )
          v16 = a2;
        else
          v16 = (_QWORD *)*a2;
        if ( v15 )
          v15 = (v15 - (__int64)v16) >> 1;
        sub_140016600(a2, v15, 1ui64, *v11);
      }
      v17 = *((_QWORD *)v10 + 3);
      if ( (v8 & 0x400) != 0 )
      {
        if ( v17 < 8 )
          v18 = v10;
        else
          v18 = *(__int16 **)v10;
        if ( v17 < 8 )
          v19 = v10;
        else
          v19 = *(__int16 **)v10;
        v20 = sub_140015FF0(&v50, (__int64)&v35, a2, v19, &v18[*((_QWORD *)v10 + 2)]);
      }
      else
      {
        if ( v17 < 8 )
          v21 = v10;
        else
          v21 = *(__int16 **)v10;
        if ( v17 < 8 )
          v22 = v10;
        else
          v22 = *(__int16 **)v10;
        v20 = sub_140016200(v47, &v35, a2, v22, &v21[*((_QWORD *)v10 + 2)]);
      }
      v23 = (_QWORD *)*v20;
      a2 = (_QWORD *)*v20;
      j = Block;
      v25 = (v37 - (__int64)Block) / 24;
      v26 = v45;
      if ( v25 )
        v26 = (__int64 *)Block;
      v7 = (__int16 *)v26[1];
      if ( v7 == a4 )
        break;
      v27 = v45;
      if ( v25 )
        v27 = (__int64 *)Block;
      v28 = v45;
      if ( v25 )
        v28 = (__int64 *)Block;
      if ( *v27 == v28[1] )
      {
        v29 = 0x2000;
      }
      else
      {
        v29 = 0;
        v8 |= 0x100u;
      }
      if ( !sub_140015E00(v7, a4, &v35, v9, v8 | v29, (__int64)v7) )
        goto LABEL_39;
    }
  }
  else
  {
LABEL_39:
    v23 = a2;
    for ( j = Block; v7 != a4; ++v7 )
    {
      v30 = a2[3];
      if ( v30 < 8 )
        v31 = a2;
      else
        v31 = (_QWORD *)*a2;
      v32 = (__int64)v31 + 2 * a2[2];
      if ( v30 < 8 )
        v33 = a2;
      else
        v33 = (_QWORD *)*a2;
      if ( v32 )
        v32 = (v32 - (__int64)v33) >> 1;
      sub_140016600(a2, v32, 1ui64, *v7);
    }
  }
  *a1 = v23;
  if ( j )
    j_free(j);
  return a1;
}

//----- (0000000140015E00) ----------------------------------------------------
char __fastcall sub_140015E00(__int16 *a1, __int16 *a2, _QWORD *a3, __int64 *a4, unsigned int a5, __int64 a6)
{
  __int64 v9; // rdx
  char v11; // r12
  int v12; // eax
  int v13; // ecx
  __int64 v14; // r13
  __int64 v15; // rax
  __int16 *i; // rbx
  char v17[8]; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v18; // [rsp+28h] [rbp-D8h]
  char v19[1064]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 *v20; // [rsp+458h] [rbp+358h]
  __int16 *v21; // [rsp+460h] [rbp+360h]
  __int64 v22; // [rsp+468h] [rbp+368h]
  int v23; // [rsp+470h] [rbp+370h]
  unsigned int v24; // [rsp+474h] [rbp+374h]
  char v25; // [rsp+478h] [rbp+378h]
  char v26; // [rsp+47Ah] [rbp+37Ah]
  char v27; // [rsp+47Bh] [rbp+37Bh]
  __int64 v28; // [rsp+480h] [rbp+380h]
  __int64 v29; // [rsp+488h] [rbp+388h]
  struct std::locale::_Locimp *v30; // [rsp+490h] [rbp+390h] BYREF

  v18 = -2i64;
  v9 = *a4;
  if ( !*a4 )
    return 0;
  v11 = 0;
  v12 = *(_DWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 36);
  v20 = a2;
  v21 = a1;
  v22 = v9;
  v23 = v12;
  v24 = a5;
  v25 = 0;
  v26 = v13;
  if ( (*(_BYTE *)(v9 + 12) & 8) == 0 || (v27 = 1, (a5 & 0x10) != 0) )
    v27 = 0;
  v28 = 0i64;
  v29 = 0i64;
  v30 = std::locale::_Init();
  v14 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)v17, 0);
  v15 = *(_QWORD *)(v14 + 8);
  if ( v15 != -1 )
    *(_QWORD *)(v14 + 8) = v15 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v17);
  if ( sub_140016AB0((__int64)v19, (__int64)a3, 0) )
    goto LABEL_15;
  if ( a1 == a2 || (a5 & 0x40) != 0 )
    goto LABEL_17;
  v24 = v24 & 0xFFFFDEFF | 0x100;
  for ( i = sub_140016750((__int64)v19, a1 + 1, a2, 0i64); i != a2; i = sub_140016750((__int64)v19, i + 1, a2, 0i64) )
  {
    v21 = i;
    if ( sub_140016AB0((__int64)v19, (__int64)a3, 0) )
      goto LABEL_15;
  }
  v21 = a2;
  if ( sub_140016AB0((__int64)v19, (__int64)a3, 0) )
  {
LABEL_15:
    v11 = 1;
    if ( a3 )
    {
      *a3 = a6;
      a3[5] = a1;
    }
  }
LABEL_17:
  sub_140008FC0((__int64 *)&v30);
  return v11;
}
// 140015E00: using guessed type char var_4C0[8];

//----- (0000000140015FF0) ----------------------------------------------------
_QWORD *__fastcall sub_140015FF0(_QWORD *a1, __int64 a2, _QWORD *a3, __int16 *a4, __int16 *a5)
{
  _QWORD *v5; // rbx
  __int16 **v8; // rax
  __int16 *v9; // rsi
  __int16 *v10; // rdi
  unsigned __int64 v11; // r8
  _QWORD *v12; // rcx
  __int64 v13; // rdx
  _QWORD *v14; // rax
  unsigned __int64 v15; // r8
  __int16 v16; // r9
  _QWORD *v17; // rcx
  __int16 *v18; // rax
  int v19; // ecx
  __int64 v20; // rax
  __int64 v21; // rcx
  __int16 *v22; // rsi
  __int16 *v23; // rdi
  unsigned __int64 v24; // r8
  _QWORD *v25; // rcx
  __int64 v26; // rdx
  _QWORD *v27; // rax
  __int64 v28; // rdx
  _QWORD *v29; // rax
  _QWORD *v31; // [rsp+60h] [rbp+18h]
  __int16 *v32; // [rsp+68h] [rbp+20h]

  v32 = a4;
  v31 = a3;
  v5 = a3;
  if ( a4 == a5 )
  {
    *a1 = a3;
    return a1;
  }
  else
  {
    do
    {
      if ( *a4 == 38 )
      {
        v8 = *(__int16 ***)(a2 + 8);
        v9 = v8[1];
        v10 = *v8;
        if ( *v8 != v9 )
        {
          do
          {
            v11 = v5[3];
            if ( v11 < 8 )
              v12 = v5;
            else
              v12 = (_QWORD *)*v5;
            v13 = (__int64)v12 + 2 * v5[2];
            if ( v11 < 8 )
              v14 = v5;
            else
              v14 = (_QWORD *)*v5;
            if ( v13 )
              v13 = (v13 - (__int64)v14) >> 1;
            sub_140016600(v5, v13, 1ui64, *v10++);
          }
          while ( v10 != v9 );
          a4 = v32;
        }
        ++a4;
        v31 = v5;
        v32 = a4;
      }
      else
      {
        if ( *a4 != 92 )
          goto LABEL_16;
        if ( ++a4 == a5 )
          break;
        if ( (unsigned __int16)*a4 >= 0x30u && (unsigned __int16)*a4 <= 0x39u )
        {
          v18 = a4++;
          v32 = a4;
          v19 = (unsigned __int16)*v18;
          v20 = *(_QWORD *)(a2 + 8);
          v21 = 3i64 * (unsigned int)(v19 - 48);
          v22 = *(__int16 **)(v20 + 8 * v21 + 8);
          v23 = *(__int16 **)(v20 + 8 * v21);
          if ( v23 != v22 )
          {
            do
            {
              v24 = v5[3];
              if ( v24 < 8 )
                v25 = v5;
              else
                v25 = (_QWORD *)*v5;
              v26 = (__int64)v25 + 2 * v5[2];
              if ( v24 < 8 )
                v27 = v5;
              else
                v27 = (_QWORD *)*v5;
              if ( v26 )
                v26 = (v26 - (__int64)v27) >> 1;
              sub_140016600(v5, v26, 1ui64, *v23++);
            }
            while ( v23 != v22 );
            a4 = v32;
          }
          v31 = v5;
        }
        else
        {
LABEL_16:
          v32 = a4 + 1;
          v15 = v5[3];
          v16 = *a4;
          if ( v15 < 8 )
            v17 = v5;
          else
            v17 = (_QWORD *)*v5;
          v28 = (__int64)v17 + 2 * v5[2];
          if ( v15 < 8 )
            v29 = v5;
          else
            v29 = (_QWORD *)*v5;
          if ( v28 )
            v28 = (v28 - (__int64)v29) >> 1;
          sub_140016600(v5, v28, 1ui64, v16);
          v5 = v31;
          a4 = v32;
        }
      }
    }
    while ( a4 != a5 );
    *a1 = v5;
    return a1;
  }
}

//----- (0000000140016200) ----------------------------------------------------
_QWORD *__fastcall sub_140016200(_QWORD *a1, _QWORD *a2, _QWORD *a3, __int16 *a4, __int16 *a5)
{
  _QWORD *v5; // rbx
  unsigned __int64 v8; // r8
  __int16 v9; // r9
  _QWORD *v10; // rcx
  __int64 v11; // rdx
  _QWORD *v12; // rax
  void *v13; // rcx
  __int16 *v14; // r9
  __int16 v15; // ax
  unsigned __int64 v16; // r8
  _QWORD *v17; // rcx
  __int64 v18; // rdx
  _QWORD *v19; // rax
  __int16 *v20; // rsi
  __int16 *v21; // rdi
  unsigned __int64 v22; // r8
  _QWORD *v23; // rcx
  __int64 v24; // rdx
  _QWORD *v25; // rax
  __int16 *v26; // rsi
  __int16 *v27; // rdi
  unsigned __int64 v28; // r8
  _QWORD *v29; // rcx
  __int64 v30; // rdx
  _QWORD *v31; // rax
  __int64 v32; // r8
  __int16 *v33; // rax
  __int16 *v34; // rax
  __int64 v35; // r10
  __int16 *v36; // rsi
  __int16 *v37; // rdi
  unsigned __int64 v38; // r8
  _QWORD *v39; // rcx
  __int64 v40; // rdx
  _QWORD *v41; // rax
  unsigned __int64 v42; // r8
  _QWORD *v43; // rcx
  __int64 v44; // rdx
  _QWORD *v45; // rax
  __int16 *v46; // rax
  unsigned __int64 v47; // r8
  _QWORD *v48; // rdx
  _QWORD *v49; // rax
  _QWORD *Src; // [rsp+70h] [rbp+38h]
  __int16 *v52; // [rsp+78h] [rbp+40h]
  __int16 *v53; // [rsp+78h] [rbp+40h]
  __int16 *v54; // [rsp+78h] [rbp+40h]

  Src = a3;
  v5 = a3;
  if ( a4 != a5 )
  {
    while ( 1 )
    {
      if ( *a4 != 36 )
      {
        v52 = a4 + 1;
        v8 = v5[3];
        v9 = *a4;
        if ( v8 < 8 )
          v10 = v5;
        else
          v10 = (_QWORD *)*v5;
        v11 = (__int64)v10 + 2 * v5[2];
        if ( v8 < 8 )
          v12 = v5;
        else
          v12 = (_QWORD *)*v5;
        v13 = v5;
        if ( v11 )
          v11 = (v11 - (__int64)v12) >> 1;
LABEL_85:
        sub_140016600(v13, v11, 1ui64, v9);
        a4 = v52;
LABEL_86:
        v5 = Src;
        goto LABEL_87;
      }
      v14 = a4 + 1;
      v53 = v14;
      if ( v14 == a5 )
        goto LABEL_88;
      v15 = *v14;
      if ( *v14 == 36 )
      {
        v16 = v5[3];
        if ( v16 < 8 )
          v17 = v5;
        else
          v17 = (_QWORD *)*v5;
        v18 = (__int64)v17 + 2 * v5[2];
        if ( v16 < 8 )
          v19 = v5;
        else
          v19 = (_QWORD *)*v5;
        if ( v18 )
          v18 = (v18 - (__int64)v19) >> 1;
        sub_140016600(v5, v18, 1ui64, 36);
        a4 = v53 + 1;
        goto LABEL_86;
      }
      switch ( v15 )
      {
        case '`':
          v20 = (__int16 *)a2[6];
          v21 = (__int16 *)a2[5];
          if ( v21 != v20 )
          {
            do
            {
              v22 = v5[3];
              if ( v22 < 8 )
                v23 = v5;
              else
                v23 = (_QWORD *)*v5;
              v24 = (__int64)v23 + 2 * v5[2];
              if ( v22 < 8 )
                v25 = v5;
              else
                v25 = (_QWORD *)*v5;
              if ( v24 )
                v24 = (v24 - (__int64)v25) >> 1;
              sub_140016600(v5, v24, 1ui64, *v21++);
            }
            while ( v21 != v20 );
LABEL_45:
            v14 = v53;
          }
          break;
        case '\'':
          v26 = (__int16 *)a2[9];
          v27 = (__int16 *)a2[8];
          if ( v27 != v26 )
          {
            do
            {
              v28 = v5[3];
              if ( v28 < 8 )
                v29 = v5;
              else
                v29 = (_QWORD *)*v5;
              v30 = (__int64)v29 + 2 * v5[2];
              if ( v28 < 8 )
                v31 = v5;
              else
                v31 = (_QWORD *)*v5;
              if ( v30 )
                v30 = (v30 - (__int64)v31) >> 1;
              sub_140016600(v5, v30, 1ui64, *v27++);
            }
            while ( v27 != v26 );
            goto LABEL_45;
          }
          break;
        case '&':
          v32 = 0i64;
          a4 = v14 + 1;
          v54 = a4;
LABEL_56:
          v35 = a2[1];
          if ( (int)v32 < (int)((a2[2] - v35) / 24) )
          {
            v36 = *(__int16 **)(v35 + 24 * v32 + 8);
            v37 = *(__int16 **)(v35 + 24 * v32);
            if ( v37 != v36 )
            {
              do
              {
                v38 = v5[3];
                if ( v38 < 8 )
                  v39 = v5;
                else
                  v39 = (_QWORD *)*v5;
                v40 = (__int64)v39 + 2 * v5[2];
                if ( v38 < 8 )
                  v41 = v5;
                else
                  v41 = (_QWORD *)*v5;
                if ( v40 )
                  v40 = (v40 - (__int64)v41) >> 1;
                sub_140016600(v5, v40, 1ui64, *v37++);
              }
              while ( v37 != v36 );
              a4 = v54;
            }
            Src = v5;
          }
          goto LABEL_87;
        default:
          if ( (unsigned __int16)v15 >= 0x30u && (unsigned __int16)v15 <= 0x39u )
          {
            v33 = v14;
            a4 = v14 + 1;
            v54 = a4;
            v32 = (unsigned int)(unsigned __int16)*v33 - 48;
            if ( a4 != a5 && (unsigned __int16)*a4 >= 0x30u && (unsigned __int16)*a4 <= 0x39u )
            {
              v34 = a4++;
              v54 = a4;
              v32 = (unsigned int)(unsigned __int16)*v34 + 10 * (_DWORD)v32 - 48;
            }
            if ( (int)v32 < 0 )
              goto LABEL_87;
            goto LABEL_56;
          }
          v42 = v5[3];
          if ( v42 < 8 )
            v43 = v5;
          else
            v43 = (_QWORD *)*v5;
          v44 = (__int64)v43 + 2 * v5[2];
          if ( v42 < 8 )
            v45 = v5;
          else
            v45 = (_QWORD *)*v5;
          if ( v44 )
            v44 = (v44 - (__int64)v45) >> 1;
          sub_140016600(v5, v44, 1ui64, 36);
          v13 = Src;
          v46 = v53;
          v52 = v53 + 1;
          v47 = Src[3];
          v9 = *v46;
          if ( v47 < 8 )
            v48 = Src;
          else
            v48 = (_QWORD *)*Src;
          v11 = (__int64)v48 + 2 * Src[2];
          if ( v47 < 8 )
            v49 = Src;
          else
            v49 = (_QWORD *)*Src;
          if ( v11 )
            v11 = (v11 - (__int64)v49) >> 1;
          goto LABEL_85;
      }
      a4 = v14 + 1;
      Src = v5;
LABEL_87:
      if ( a4 == a5 )
      {
LABEL_88:
        *a1 = v5;
        return a1;
      }
    }
  }
  *a1 = a3;
  return a1;
}

//----- (0000000140016600) ----------------------------------------------------
void *__fastcall sub_140016600(void *Src, unsigned __int64 a2, unsigned __int64 a3, __int16 a4)
{
  char *v5; // r8
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  char *v12; // rdx
  char *v13; // rcx
  bool v14; // cf
  char *v15; // rcx

  v5 = (char *)*((_QWORD *)Src + 2);
  if ( (unsigned __int64)v5 < a2 )
    sub_14002B630("invalid string position");
  if ( -1 - (__int64)v5 <= a3 )
    sub_14002B5F8("string too long");
  if ( a3 )
  {
    v9 = (unsigned __int64)&v5[a3];
    if ( (unsigned __int64)&v5[a3] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v10 = *((_QWORD *)Src + 3);
    if ( v10 >= v9 )
    {
      if ( !v9 )
      {
        *((_QWORD *)Src + 2) = 0i64;
        if ( v10 < 8 )
          *(_WORD *)Src = 0;
        else
          **(_WORD **)Src = 0;
        return Src;
      }
    }
    else
    {
      sub_1400097B0(Src, (unsigned __int64)&v5[a3], v5);
      if ( !v9 )
        return Src;
    }
    v11 = *((_QWORD *)Src + 3);
    if ( v11 < 8 )
      v12 = (char *)Src;
    else
      v12 = *(char **)Src;
    if ( v11 < 8 )
      v13 = (char *)Src;
    else
      v13 = *(char **)Src;
    memmove(&v13[2 * a3 + 2 * a2], &v12[2 * a2], 2 * (*((_QWORD *)Src + 2) - a2));
    sub_140006F90(Src, a2, a3, a4);
    v14 = *((_QWORD *)Src + 3) < 8ui64;
    *((_QWORD *)Src + 2) = v9;
    if ( v14 )
      v15 = (char *)Src;
    else
      v15 = *(char **)Src;
    *(_WORD *)&v15[2 * v9] = 0;
  }
  return Src;
}

//----- (0000000140016750) ----------------------------------------------------
__int16 *__fastcall sub_140016750(__int64 a1, __int16 *a2, __int16 *a3, __int64 a4)
{
  __int64 v4; // rdi
  __int16 *v5; // rbp
  __int16 *v6; // rbx
  __int64 v7; // r10
  __int64 v9; // rcx
  __int16 *v10; // rsi
  unsigned int *v11; // r8
  unsigned __int16 v12; // si
  char v13; // al
  unsigned __int16 v14; // ax
  unsigned __int16 v15; // r11
  __int64 v16; // rax
  int v17; // ecx
  int v18; // edx
  unsigned __int16 *v19; // rax
  __int64 v20; // r8
  bool v21; // zf
  __int64 v22; // rax
  _WORD *v23; // rdx
  _WORD *i; // rcx
  unsigned __int16 v25; // r8
  __int64 v26; // rdx
  __int16 *v27; // rax
  __int64 v29; // [rsp+70h] [rbp+18h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( !a4 )
    v4 = *(_QWORD *)(a1 + 1080);
  if ( a2 == a3 )
    return v6;
  while ( 2 )
  {
    if ( !v4 )
      return v6;
    switch ( *(_DWORD *)(v4 + 8) )
    {
      case 1:
      case 8:
      case 9:
      case 0xD:
      case 0xE:
      case 0x14:
        v4 = *(_QWORD *)(v4 + 16);
        continue;
      case 2:
        if ( (*(_BYTE *)(a1 + 1092) & 1) != 0 )
          return a3;
        do
        {
          if ( *(v6 - 1) == 10 )
            break;
          ++v6;
        }
        while ( v6 != a3 );
        return v6;
      case 3:
        if ( (*(_BYTE *)(a1 + 1092) & 2) != 0 )
          return a3;
        while ( *v6 != 10 )
        {
          if ( ++v6 == a3 )
            return v6;
        }
        return v6;
      case 6:
        v9 = a1 + 1104;
        v29 = v7 + 1104;
        while ( 1 )
        {
          v10 = v6 + 1;
          if ( sub_140017140(
                 v6,
                 v6 + 1,
                 *(__int16 **)(v4 + 40),
                 (__int16 *)(*(_QWORD *)(v4 + 40) + 2i64),
                 v9,
                 *(_DWORD *)(v7 + 1088),
                 (*(_DWORD *)(v7 + 1092) & 0x80) != 0) != v6 )
            break;
          v9 = v29;
          v7 = a1;
          ++v6;
          if ( v10 == v5 )
            return v10;
        }
        return v6;
      case 7:
        goto LABEL_21;
      case 0xC:
      case 0x15:
        v4 = 0i64;
        continue;
      case 0x10:
        do
        {
          if ( !v4 )
            break;
          v27 = sub_140016750(v7, v6, v5, *(_QWORD *)(v4 + 16));
          v4 = *(_QWORD *)(v4 + 40);
          v7 = a1;
          v5 = v27;
        }
        while ( v6 != v27 );
        return v5;
      default:
        return v6;
    }
  }
  do
  {
LABEL_21:
    v11 = *(unsigned int **)(v4 + 32);
    v12 = *v6;
    if ( v11 )
    {
      if ( sub_1400171F0(v6, v6 + 1, v11) != v6 )
      {
        v13 = 1;
        goto LABEL_52;
      }
      v7 = a1;
    }
    if ( *(_QWORD *)(v4 + 56) )
    {
      if ( (*(_DWORD *)(v7 + 1088) & 0x800) != 0 )
      {
        v14 = sub_140010330(v7 + 1104, v12);
        v7 = a1;
        v15 = v14;
      }
      else
      {
        v15 = v12;
      }
      v16 = *(_QWORD *)(v4 + 56);
      v17 = 0;
      v18 = *(_DWORD *)(v16 + 4);
      if ( v18 > 0 )
      {
        v19 = *(unsigned __int16 **)(v16 + 8);
        while ( *v19 > v15 || v15 > v19[1] )
        {
          v17 += 2;
          v19 += 2;
          if ( v17 >= v18 )
            goto LABEL_34;
        }
LABEL_50:
        v13 = 1;
        goto LABEL_52;
      }
    }
LABEL_34:
    if ( dword_14012E174 > v12 || v12 >= 0x100u )
    {
      if ( *(_QWORD *)(v4 + 48) )
      {
        v22 = *(_QWORD *)(v4 + 48);
        v23 = *(_WORD **)(v22 + 8);
        for ( i = &v23[*(int *)(v22 + 4)]; v23 != i; ++v23 )
        {
          if ( *v23 == v12 )
            break;
        }
        if ( v23 != (_WORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 8i64) + 2i64 * *(int *)(*(_QWORD *)(v4 + 48) + 4i64)) )
        {
          v13 = 1;
          goto LABEL_52;
        }
      }
      v25 = *(_WORD *)(v4 + 64);
      if ( v25 && (unsigned __int8)sub_1400103B0(v7 + 1104, v12, v25) )
      {
        v13 = 1;
        goto LABEL_52;
      }
      v26 = *(_QWORD *)(v4 + 72);
      if ( !v26 )
        goto LABEL_51;
      v21 = (unsigned __int8)sub_140011260(v12, v26, a1 + 1104) == 0;
    }
    else
    {
      v20 = *(_QWORD *)(v4 + 40);
      if ( !v20 )
        goto LABEL_51;
      v21 = ((unsigned __int8)(1 << (v12 & 7)) & *(_BYTE *)(((unsigned __int64)v12 >> 3) + v20)) == 0;
    }
    if ( !v21 )
      goto LABEL_50;
LABEL_51:
    v13 = 0;
LABEL_52:
    if ( v13 != (*(_BYTE *)(v4 + 12) & 1) )
      return v6;
    v7 = a1;
    ++v6;
  }
  while ( v6 != v5 );
  return v6;
}
// 140011260: using guessed type __int64 __fastcall sub_140011260(_QWORD, _QWORD, _QWORD);
// 14012E174: using guessed type int dword_14012E174;

//----- (0000000140016AB0) ----------------------------------------------------
bool __fastcall sub_140016AB0(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // rax
  unsigned int v4; // esi
  bool v5; // zf
  char *v7; // rdx
  bool result; // al
  int v10; // edx
  __int64 v11; // r8
  __int64 *v12; // r9
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rax

  v3 = *(_QWORD *)(a1 + 1072);
  v4 = 0;
  v5 = a2 == 0;
  v7 = *(char **)(a1 + 1080);
  *(_QWORD *)(a1 + 1056) = v3;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 1128) = a3;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 1097) = !v5;
  *(_BYTE *)(a1 + 1096) = 0;
  result = sub_140016C20(a1, v7, 0i64);
  if ( result )
  {
    if ( a2 )
    {
      sub_1400106A0((__int64 *)(a2 + 8), *(unsigned __int8 *)(a1 + 1098));
      v10 = 1;
      if ( *(_BYTE *)(a1 + 1098) )
      {
        v11 = 0i64;
        v12 = (__int64 *)(a1 + 552);
        do
        {
          v13 = *(_QWORD *)(a2 + 8);
          if ( (v10 & *(_DWORD *)(a1 + 536)) != 0 )
          {
            *(_BYTE *)(v11 + v13 + 16) = 1;
            *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8)) = *(v12 - 1);
            v14 = *v12;
          }
          else
          {
            *(_BYTE *)(v11 + v13 + 16) = 0;
            *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8)) = *(_QWORD *)(a1 + 1064);
            v14 = *(_QWORD *)(a1 + 1064);
          }
          ++v4;
          v12 += 2;
          *(_QWORD *)(v11 + *(_QWORD *)(a2 + 8) + 8) = v14;
          v10 = __ROL4__(v10, 1);
          v11 += 24i64;
        }
        while ( v4 < *(unsigned __int8 *)(a1 + 1098) );
      }
      v15 = *(__int64 **)(a2 + 8);
      *(_QWORD *)a2 = *(_QWORD *)(a1 + 1056);
      *(_BYTE *)(a2 + 56) = 1;
      *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 1056);
      v16 = *v15;
      *(_BYTE *)(a2 + 80) = 1;
      *(_QWORD *)(a2 + 48) = v16;
      *(_QWORD *)(a2 + 64) = v15[1];
      *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 1064);
      *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 1064);
      *(_QWORD *)(a2 + 96) = *(_QWORD *)(a1 + 1064);
    }
    return 1;
  }
  return result;
}

//----- (0000000140016C20) ----------------------------------------------------
bool __fastcall sub_140016C20(__int64 a1, char *a2, __int64 a3)
{
  bool v3; // bp
  char *v4; // rdi
  int v6; // edx
  int v7; // ecx
  int v8; // ecx
  bool v9; // cl
  unsigned __int16 v10; // ax
  char v11; // bl
  unsigned __int16 v12; // ax
  char v13; // al
  __int16 *v14; // rax
  __int16 *v15; // rax
  bool v16; // zf
  char *v17; // rdx
  __int64 v18; // rdx
  unsigned int v19; // ecx
  int v20; // eax
  __int16 *v21; // r10
  __int16 *v22; // r8
  __int16 *v23; // r9
  __int16 *v24; // rbx
  __int64 v25; // rdi
  bool v26; // al
  __int64 v28; // [rsp+40h] [rbp-38h]
  __int64 pExceptionObject[6]; // [rsp+48h] [rbp-30h] BYREF
  char *v30; // [rsp+88h] [rbp+10h] BYREF
  unsigned int v31; // [rsp+90h] [rbp+18h]
  char *v32; // [rsp+98h] [rbp+20h]

  v31 = a3;
  v30 = a2;
  v3 = 0;
  v4 = a2;
  if ( !a2 )
    return !v3;
  while ( 2 )
  {
    v6 = *((_DWORD *)v4 + 2);
    switch ( v6 )
    {
      case 1:
      case 8:
      case 9:
      case 17:
      case 20:
        goto LABEL_66;
      case 2:
        v7 = *(_DWORD *)(a1 + 1092);
        if ( (v7 & 0x101) == 1 )
          goto LABEL_71;
        if ( (v7 & 0x100) != 0 || *(_QWORD *)a1 != *(_QWORD *)(a1 + 1056) )
          v3 = *(_WORD *)(*(_QWORD *)a1 - 2i64) != 10;
        goto LABEL_66;
      case 3:
        if ( (*(_BYTE *)(a1 + 1092) & 2) == 0 && (*(_QWORD *)a1 == *(_QWORD *)(a1 + 1064) || **(_WORD **)a1 == 10) )
          goto LABEL_66;
        goto LABEL_71;
      case 4:
        v8 = *(_DWORD *)(a1 + 1092);
        if ( (v8 & 4) != 0 && *(_QWORD *)a1 == *(_QWORD *)(a1 + 1056)
          || (v8 & 8) != 0 && *(_QWORD *)a1 == *(_QWORD *)(a1 + 1064) )
        {
          v9 = 0;
        }
        else
        {
          v11 = 0;
          if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 1056) || (v8 & 0x100) != 0 )
          {
            v10 = *(_WORD *)(*(_QWORD *)a1 - 2i64);
            if ( v10 == (char)v10 )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v10) )
                v11 = 1;
            }
          }
          v13 = 0;
          if ( *(_QWORD *)a1 != *(_QWORD *)(a1 + 1064) )
          {
            v12 = **(_WORD **)a1;
            if ( v12 == (char)v12 )
            {
              if ( strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", v12) )
                v13 = 1;
            }
          }
          v9 = v11 != v13;
        }
        if ( v9 != (v4[12] & 1) )
          goto LABEL_66;
        goto LABEL_71;
      case 5:
        v14 = *(__int16 **)a1;
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 1064) || *v14 == 10 || *v14 == 13 )
          goto LABEL_71;
        *(_QWORD *)a1 = v14 + 1;
        goto LABEL_66;
      case 6:
        v15 = sub_140017140(
                *(__int16 **)a1,
                *(__int16 **)(a1 + 1064),
                *((__int16 **)v4 + 5),
                (__int16 *)(*((_QWORD *)v4 + 5) + 2i64 * *((int *)v4 + 9)),
                a1 + 1104,
                *(_DWORD *)(a1 + 1088),
                (*(_DWORD *)(a1 + 1092) & 0x80) != 0);
        if ( v15 == *(__int16 **)a1 )
          goto LABEL_71;
        *(_QWORD *)a1 = v15;
        goto LABEL_66;
      case 7:
        if ( *(_QWORD *)a1 == *(_QWORD *)(a1 + 1064) || !sub_140017550(a1, (__int64)v4) )
          goto LABEL_71;
        v3 = 0;
        goto LABEL_67;
      case 10:
      case 11:
        v16 = v6 == 11;
        v17 = (char *)*((_QWORD *)v4 + 4);
        v30 = *(char **)a1;
        v32 = v30;
        v28 = *(_QWORD *)(a1 + 8);
        if ( sub_140016C20(a1, v17, 0i64) != v16 )
        {
          *(_QWORD *)a1 = v30;
LABEL_66:
          if ( v3 )
            goto LABEL_72;
LABEL_67:
          if ( !v4 )
            return !v3;
          v4 = (char *)*((_QWORD *)v4 + 2);
          v30 = v4;
          if ( !v4 )
            return !v3;
          a3 = v31;
          continue;
        }
        *(_QWORD *)a1 = v32;
        *(_QWORD *)(a1 + 8) = v28;
LABEL_71:
        v3 = 1;
LABEL_72:
        if ( *(char *)(a1 + 1092) < 0 && *(_QWORD *)a1 == *(_QWORD *)(a1 + 1064) )
        {
          v3 = 0;
          memmove((void *)(a1 + 528), (const void *)a1, 0x210ui64);
        }
        return !v3;
      case 12:
        goto LABEL_65;
      case 13:
        *(_QWORD *)(a1 + 16 * (*((unsigned int *)v4 + 8) + 1i64)) = *(_QWORD *)a1;
        goto LABEL_66;
      case 14:
        v18 = *((_QWORD *)v4 + 4);
        if ( *(_BYTE *)(a1 + 1097) || *(_DWORD *)(v18 + 32) )
        {
          *(_DWORD *)(a1 + 8) |= 1 << *(_DWORD *)(v18 + 32);
          *(_QWORD *)(a1 + 16i64 * *(unsigned int *)(v18 + 32) + 24) = *(_QWORD *)a1;
        }
        goto LABEL_66;
      case 15:
        v19 = *((_DWORD *)v4 + 8);
        v20 = *(_DWORD *)(a1 + 8);
        if ( !_bittest(&v20, v19) )
          goto LABEL_66;
        v21 = *(__int16 **)a1;
        v22 = *(__int16 **)(a1 + 16i64 * v19 + 16);
        v23 = *(__int16 **)(a1 + 16i64 * v19 + 24);
        if ( v22 != v23 )
        {
          v21 = sub_140017140(
                  v21,
                  *(__int16 **)(a1 + 1064),
                  v22,
                  v23,
                  a1 + 1104,
                  *(_DWORD *)(a1 + 1088),
                  (*(_DWORD *)(a1 + 1092) & 0x80) != 0);
          if ( v21 == *(__int16 **)a1 )
            goto LABEL_71;
        }
        *(_QWORD *)a1 = v21;
        goto LABEL_66;
      case 16:
        if ( !sub_1400172A0(a1, (__int64)v4, a3) )
          v3 = 1;
        goto LABEL_65;
      case 18:
        if ( !sub_140017390((void *)a1, (__int64)v4, (*((_DWORD *)v4 + 3) & 2) != 0, a3) )
          v3 = 1;
        goto LABEL_65;
      case 19:
        if ( (int)a3 > 0 )
        {
          v24 = *(__int16 **)a1;
          v25 = *(_QWORD *)(a1 + 8);
          v26 = sub_140016C20(a1, *((char **)v30 + 2), a3);
          *(_QWORD *)a1 = v24;
          *(_QWORD *)(a1 + 8) = v25;
          v3 = !v26;
        }
        goto LABEL_65;
      case 21:
        if ( (*(_DWORD *)(a1 + 1092) & 0x2020) != 0 && *(_QWORD *)(a1 + 1056) == *(_QWORD *)a1
          || *(_BYTE *)(a1 + 1128) && *(_QWORD *)a1 != *(_QWORD *)(a1 + 1064) )
        {
          v3 = 1;
        }
        else if ( !*(_BYTE *)(a1 + 1096) || sub_140017720(a1) )
        {
          memmove((void *)(a1 + 528), (const void *)a1, 0x210ui64);
          *(_BYTE *)(a1 + 1096) = 1;
        }
LABEL_65:
        v4 = 0i64;
        goto LABEL_66;
      default:
        v30 = "corrupted regex pattern";
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v30);
        pExceptionObject[0] = (__int64)&std::logic_error::`vftable';
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVlogic_error_std__);
    }
  }
}
// 1400E41C8: using guessed type void *std::logic_error::`vftable';

//----- (0000000140017140) ----------------------------------------------------
__int16 *__fastcall sub_140017140(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int64 a5, __int16 a6, char a7)
{
  __int16 *result; // rax
  __int16 *v10; // rdx
  __int16 v11; // cx
  __int16 v12; // ax

  if ( (a6 & 0x800) != 0 )
    return sub_1400177F0(a1, a2, a3, a4, a5, a7);
  if ( (a6 & 0x100) != 0 )
    return (__int16 *)sub_140017950(
                        (unsigned __int16 *)a1,
                        (unsigned __int16 *)a2,
                        (unsigned __int16 *)a3,
                        (unsigned __int16 *)a4,
                        a5,
                        a7);
  v10 = a1;
  if ( a1 != a2 )
  {
    while ( a3 != a4 )
    {
      v11 = *v10;
      v12 = *a3;
      ++v10;
      ++a3;
      if ( v11 != v12 )
        return a1;
      if ( v10 == a2 )
        goto LABEL_9;
    }
    return v10;
  }
LABEL_9:
  if ( a3 == a4 )
    return v10;
  if ( !a7 )
    return a1;
  result = v10;
  if ( v10 != a2 )
    return a1;
  return result;
}

//----- (00000001400171F0) ----------------------------------------------------
__int16 *__fastcall sub_1400171F0(__int16 *a1, __int16 *a2, unsigned int *a3)
{
  unsigned int *v3; // r11
  int v6; // ebx
  int v7; // er10
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // rcx
  __int16 *v10; // r9
  _WORD *v11; // rdx
  __int16 v12; // ax

  v3 = a3;
  if ( !a3 )
    return a1;
  while ( 1 )
  {
    v6 = v3[3];
    v7 = 0;
    if ( v6 > 0 )
      break;
LABEL_10:
    v3 = (unsigned int *)*((_QWORD *)v3 + 3);
    if ( !v3 )
      return a1;
  }
  v8 = *v3;
  while ( 1 )
  {
    v9 = 0i64;
    v10 = a1;
    if ( *v3 )
    {
      v11 = (_WORD *)(*((_QWORD *)v3 + 2) + 2i64 * v7);
      do
      {
        v12 = *v10++;
        if ( v12 != *v11 )
          break;
        ++v9;
        ++v11;
      }
      while ( v9 < v8 );
    }
    if ( v10 == a2 )
      return a2;
    v7 += v8;
    if ( v7 >= v6 )
      goto LABEL_10;
  }
}

//----- (00000001400172A0) ----------------------------------------------------
char __fastcall sub_1400172A0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r12
  __int64 v4; // r13
  char v5; // si
  int v6; // ebp
  __int64 v8; // rdi
  __int64 *v10; // rdx
  char result; // al
  __int64 v12; // [rsp+20h] [rbp-38h] BYREF
  __int64 i; // [rsp+28h] [rbp-30h]
  __int64 v14[5]; // [rsp+30h] [rbp-28h] BYREF

  v4 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  v6 = -1;
  v8 = a2;
  v14[0] = *(_QWORD *)a1;
  v3 = v14[0];
  v14[1] = v4;
  v12 = v14[0];
  for ( i = v4; v8; v8 = *(_QWORD *)(v8 + 40) )
  {
    *(_QWORD *)a1 = v3;
    *(_QWORD *)(a1 + 8) = v4;
    if ( sub_140016C20(a1, *(char **)(v8 + 16), a3) )
    {
      if ( !*(_BYTE *)(a1 + 1099) )
        return 1;
      if ( v6 < (int)((*(_QWORD *)a1 - v3) >> 1) )
      {
        v6 = (*(_QWORD *)a1 - v3) >> 1;
        v12 = *(_QWORD *)a1;
        i = *(_QWORD *)(a1 + 8);
      }
      v5 = 1;
    }
  }
  v10 = &v12;
  if ( !v5 )
    v10 = v14;
  result = v5;
  *(_QWORD *)a1 = *v10;
  *(_QWORD *)(a1 + 8) = v10[1];
  return result;
}
// 1400172A0: using guessed type _QWORD var_28[5];

//----- (0000000140017390) ----------------------------------------------------
char __fastcall sub_140017390(void *Src, __int64 a2, char a3, unsigned int a4)
{
  __int64 v4; // r12
  __int64 v5; // r14
  int v6; // edi
  __int64 v10; // rbp
  __int64 v11; // r12
  char v12; // r13
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  __int64 v16; // r8
  char result; // al
  __int64 v18; // rbp
  __int64 *v19; // rdx
  __int64 v21[3]; // [rsp+28h] [rbp-270h] BYREF
  char v22[528]; // [rsp+40h] [rbp-258h] BYREF

  v4 = *(_QWORD *)Src;
  v5 = *((_QWORD *)Src + 1);
  v6 = 0;
  v21[0] = *(_QWORD *)Src;
  v21[1] = v5;
  if ( *(int *)(a2 + 40) <= 0 )
  {
LABEL_5:
    memmove(v22, Src, 0x210ui64);
    v11 = *(_QWORD *)Src;
    v12 = 0;
    if ( !sub_140016C20((__int64)Src, *(char **)(*(_QWORD *)(a2 + 32) + 16i64), a4) )
      goto LABEL_8;
    if ( a3 )
    {
      memmove(v22, Src, 0x210ui64);
      v12 = 1;
LABEL_8:
      while ( 1 )
      {
        v13 = *(_DWORD *)(a2 + 44);
        if ( v13 != -1 )
        {
          v14 = v6++;
          if ( v14 >= v13 )
            break;
        }
        *(_QWORD *)Src = v11;
        *((_DWORD *)Src + 2) = v5;
        v15 = *(_DWORD *)(a2 + 44);
        if ( v15 < 0 || v15 > v6 )
          v16 = 0xFFFFFFFFi64;
        else
          v16 = 1i64;
        if ( !sub_140016C20((__int64)Src, *(char **)(a2 + 16), v16) )
          break;
        v18 = *(_QWORD *)Src;
        if ( sub_140016C20((__int64)Src, *(char **)(*(_QWORD *)(a2 + 32) + 16i64), a4) )
        {
          if ( !a3 )
            return 1;
          memmove(v22, Src, 0x210ui64);
          v12 = 1;
        }
        if ( v11 == v18 )
          break;
        v11 = v18;
      }
      v19 = (__int64 *)v22;
      if ( !v12 )
        v19 = v21;
      result = v12;
      *(_QWORD *)Src = *v19;
      *((_QWORD *)Src + 1) = v19[1];
    }
    else
    {
      return 1;
    }
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_QWORD *)Src;
      if ( !sub_140016C20((__int64)Src, *(char **)(a2 + 16), 0xFFFFFFFFi64) )
        break;
      if ( v10 != *(_QWORD *)Src && ++v6 < *(_DWORD *)(a2 + 40) )
        continue;
      goto LABEL_5;
    }
    *(_QWORD *)Src = v4;
    result = 0;
    *((_QWORD *)Src + 1) = v5;
  }
  return result;
}

//----- (0000000140017550) ----------------------------------------------------
char __fastcall sub_140017550(__int64 a1, __int64 a2)
{
  unsigned __int16 v3; // bx
  __int64 v5; // rax
  unsigned __int16 *v6; // rsi
  unsigned int *v7; // r8
  __int64 v8; // r12
  __int16 *v9; // rax
  char v10; // al
  unsigned __int16 v11; // r11
  __int64 v12; // rax
  int v13; // ecx
  int v14; // edx
  unsigned __int16 *v15; // rax
  __int64 v16; // r8
  bool v17; // zf
  __int64 v18; // rax
  _WORD *v19; // rdx
  _WORD *i; // rcx
  unsigned __int16 v21; // r8
  __int64 v22; // rdx

  v3 = **(_WORD **)a1;
  if ( (*(_DWORD *)(a1 + 1088) & 0x100) != 0 )
  {
    v5 = sub_1400105F0(a1 + 1104);
    v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 48i64))(v5, v3);
  }
  v6 = *(unsigned __int16 **)a1;
  v7 = *(unsigned int **)(a2 + 32);
  v8 = *(_QWORD *)a1 + 2i64;
  if ( v7 )
  {
    v9 = sub_1400171F0(*(__int16 **)a1, *(__int16 **)(a1 + 1064), v7);
    if ( v9 != (__int16 *)v6 )
    {
      v8 = (__int64)v9;
      v10 = 1;
      goto LABEL_33;
    }
  }
  if ( *(_QWORD *)(a2 + 56) )
  {
    v11 = (*(_DWORD *)(a1 + 1088) & 0x800) != 0 ? sub_140010330(a1 + 1104, v3) : v3;
    v12 = *(_QWORD *)(a2 + 56);
    v13 = 0;
    v14 = *(_DWORD *)(v12 + 4);
    if ( v14 > 0 )
    {
      v15 = *(unsigned __int16 **)(v12 + 8);
      while ( *v15 > v11 || v11 > v15[1] )
      {
        v13 += 2;
        v15 += 2;
        if ( v13 >= v14 )
          goto LABEL_15;
      }
      goto LABEL_31;
    }
  }
LABEL_15:
  if ( dword_14012E178 > v3 || v3 >= 0x100u )
  {
    if ( *(_QWORD *)(a2 + 48) )
    {
      v18 = *(_QWORD *)(a2 + 48);
      v19 = *(_WORD **)(v18 + 8);
      for ( i = &v19[*(int *)(v18 + 4)]; v19 != i; ++v19 )
      {
        if ( *v19 == v3 )
          break;
      }
      if ( v19 != (_WORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 8i64) + 2i64 * *(int *)(*(_QWORD *)(a2 + 48) + 4i64)) )
      {
        v10 = 1;
        goto LABEL_33;
      }
    }
    v21 = *(_WORD *)(a2 + 64);
    if ( v21 && (unsigned __int8)sub_1400103B0(a1 + 1104, v3, v21) )
    {
      v10 = 1;
      goto LABEL_33;
    }
    v22 = *(_QWORD *)(a2 + 72);
    if ( !v22 )
      goto LABEL_32;
    v17 = (unsigned __int8)sub_140011260(v3, v22, a1 + 1104) == 0;
  }
  else
  {
    v16 = *(_QWORD *)(a2 + 40);
    if ( !v16 )
      goto LABEL_32;
    v17 = ((unsigned __int8)(1 << (v3 & 7)) & *(_BYTE *)(((unsigned __int64)v3 >> 3) + v16)) == 0;
  }
  if ( !v17 )
  {
LABEL_31:
    v10 = 1;
    goto LABEL_33;
  }
LABEL_32:
  v10 = 0;
LABEL_33:
  if ( v10 == (*(_BYTE *)(a2 + 12) & 1) )
    return 0;
  *(_QWORD *)a1 = v8;
  return 1;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);
// 140011260: using guessed type __int64 __fastcall sub_140011260(_QWORD, _QWORD, _QWORD);
// 14012E178: using guessed type int dword_14012E178;

//----- (0000000140017720) ----------------------------------------------------
bool __fastcall sub_140017720(__int64 a1)
{
  int v2; // ecx
  int v3; // er9
  int v4; // er8
  _QWORD *i; // rdx
  __int64 v6; // rax

  v2 = *(unsigned __int8 *)(a1 + 1098);
  v3 = 0;
  v4 = 1;
  if ( v2 <= 0 )
    return 0;
  for ( i = (_QWORD *)(a1 + 16); ; i += 2 )
  {
    if ( (*(_DWORD *)(a1 + 536) & v4) == 0 || (v4 & *(_DWORD *)(a1 + 8)) == 0 )
      goto LABEL_7;
    v6 = i[66];
    if ( v6 != *i )
      break;
    if ( i[67] != i[1] )
      return (__int64)((*(_QWORD *)(a1 + 16i64 * v3 + 552) - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64) < (__int64)((*(_QWORD *)(a1 + 16i64 * v3 + 24) - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64);
LABEL_7:
    ++v3;
    v4 *= 2;
    if ( v3 >= v2 )
      return 0;
  }
  return (__int64)((v6 - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64) < (__int64)((*(_QWORD *)(a1 + 16 * (v3 + 1i64))
                                                                                      - *(_QWORD *)(a1 + 1056)) & 0xFFFFFFFFFFFFFFFEui64);
}

//----- (00000001400177F0) ----------------------------------------------------
__int16 *__fastcall sub_1400177F0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int64 a5, char a6)
{
  __int16 *v9; // rbx
  __int16 v11; // si
  __int64 v12; // rax
  void **v13; // rax
  __int16 v14; // r12
  __int64 v15; // rax
  void **v16; // rax
  __int16 v18; // [rsp+28h] [rbp-51h]
  void *Block[2]; // [rsp+30h] [rbp-49h] BYREF
  __int64 v20; // [rsp+40h] [rbp-39h]
  unsigned __int64 v21; // [rsp+48h] [rbp-31h]
  void *v22[3]; // [rsp+58h] [rbp-21h] BYREF
  unsigned __int64 v23; // [rsp+70h] [rbp-9h]

  v9 = a1;
  if ( a1 == a2 )
  {
LABEL_18:
    if ( a3 != a4 && (!a6 || v9 != a2) )
      return a1;
  }
  else
  {
    while ( a3 != a4 )
    {
      v11 = *a3;
      v18 = *v9;
      v12 = sub_140010540(a5);
      sub_140010820(v12, (__int64)Block);
      if ( v20 == 1 )
      {
        v13 = Block;
        if ( v21 >= 8 )
          v13 = (void **)Block[0];
        v14 = *(_WORD *)v13;
      }
      else
      {
        v14 = v18;
      }
      if ( v21 >= 8 )
        j_free(Block[0]);
      v21 = 7i64;
      v20 = 0i64;
      LOWORD(Block[0]) = 0;
      v15 = sub_140010540(a5);
      sub_140010820(v15, (__int64)v22);
      if ( v22[2] == (void *)1 )
      {
        v16 = v22;
        if ( v23 >= 8 )
          v16 = (void **)v22[0];
        v11 = *(_WORD *)v16;
      }
      if ( v23 >= 8 )
        j_free(v22[0]);
      ++v9;
      ++a3;
      if ( v14 != v11 )
        return a1;
      if ( v9 == a2 )
        goto LABEL_18;
    }
  }
  return v9;
}

//----- (0000000140017950) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140017950(
        unsigned __int16 *a1,
        unsigned __int16 *a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4,
        __int64 a5,
        char a6)
{
  unsigned __int16 *v9; // rsi
  unsigned __int16 v11; // di
  unsigned __int16 v12; // bx
  __int64 v13; // rax
  __int16 v14; // bx
  __int64 v15; // rax

  v9 = a1;
  if ( a1 == a2 )
  {
LABEL_5:
    if ( a3 != a4 && (!a6 || v9 != a2) )
      return a1;
  }
  else
  {
    while ( a3 != a4 )
    {
      v11 = *a3;
      v12 = *v9;
      v13 = sub_1400105F0(a5);
      v14 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v13 + 48i64))(v13, v12);
      v15 = sub_1400105F0(a5);
      ++v9;
      ++a3;
      if ( v14 != (*(unsigned __int16 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 48i64))(v15, v11) )
        return a1;
      if ( v9 == a2 )
        goto LABEL_5;
    }
  }
  return v9;
}
// 1400105F0: using guessed type __int64 __fastcall sub_1400105F0(_QWORD);

//----- (0000000140017A10) ----------------------------------------------------
__int64 __fastcall sub_140017A10(__int64 a1, __int64 a2, __int64 a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
    {
      *(_QWORD *)a3 = *(_QWORD *)a1;
      *(_QWORD *)(a3 + 8) = *(_QWORD *)(a1 + 8);
      *(_BYTE *)(a3 + 16) = *(_BYTE *)(a1 + 16);
    }
    a3 += 24i64;
    a1 += 24i64;
  }
  return a3;
}

//----- (0000000140017A60) ----------------------------------------------------
_QWORD *__fastcall sub_140017A60(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x30ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140017AD0) ----------------------------------------------------
char *__fastcall sub_140017AD0(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x20ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_DWORD *)result + 4) = *a3;
    *((_DWORD *)result + 5) = a3[1];
    *((_DWORD *)result + 6) = a3[2];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140017B80) ----------------------------------------------------
_QWORD *__fastcall sub_140017B80(_QWORD *a1, char a2)
{
  *a1 = &Gdiplus::Image::`vftable';
  GdipDisposeImage(a1[1]);
  if ( (a2 & 1) != 0 )
    GdipFree(a1);
  return a1;
}
// 1400E3D40: using guessed type __int64 __fastcall GdipDisposeImage(_QWORD);
// 1400E3D90: using guessed type __int64 __fastcall GdipFree(_QWORD);
// 1400F7468: using guessed type void *Gdiplus::Image::`vftable';

//----- (0000000140017BC0) ----------------------------------------------------
__int64 __fastcall sub_140017BC0(__int64 a1)
{
  __int64 v2; // rcx
  int ImageHeight; // eax
  unsigned int v5; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  ImageHeight = GdipGetImageHeight(v2, &v5);
  if ( ImageHeight )
    *(_DWORD *)(a1 + 16) = ImageHeight;
  return v5;
}
// 1400E3D68: using guessed type __int64 __fastcall GdipGetImageHeight(_QWORD, _QWORD);

//----- (0000000140017C00) ----------------------------------------------------
__int64 __fastcall sub_140017C00(__int64 a1)
{
  __int64 v2; // rcx
  int ImageWidth; // eax
  unsigned int v5; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  ImageWidth = GdipGetImageWidth(v2, &v5);
  if ( ImageWidth )
    *(_DWORD *)(a1 + 16) = ImageWidth;
  return v5;
}
// 1400E3D58: using guessed type __int64 __fastcall GdipGetImageWidth(_QWORD, _QWORD);

//----- (0000000140017C40) ----------------------------------------------------
__int64 __fastcall sub_140017C40(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // eax
  __int64 result; // rax
  int v5; // edx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8);
  v6 = 0i64;
  v3 = GdipCloneImage(v2, &v6);
  if ( v3 )
    *(_DWORD *)(a1 + 16) = v3;
  result = GdipAlloc(24i64);
  if ( result )
  {
    v5 = *(_DWORD *)(a1 + 16);
    *(_QWORD *)(result + 8) = v6;
    *(_DWORD *)(result + 16) = v5;
    *(_QWORD *)result = &Gdiplus::Image::`vftable';
  }
  return result;
}
// 1400E3D80: using guessed type __int64 __fastcall GdipCloneImage(_QWORD, _QWORD);
// 1400E3D98: using guessed type __int64 __fastcall GdipAlloc(_QWORD);
// 1400F7468: using guessed type void *Gdiplus::Image::`vftable';

//----- (0000000140017CA0) ----------------------------------------------------
void __fastcall sub_140017CA0(void **a1)
{
  void ***v1; // rax
  void **v3; // rcx
  void **v4; // rbx
  void ***v5; // rax
  void **v6; // rcx
  void **v7; // rbx
  void ***v8; // rax
  void **v9; // rcx
  void **v10; // rbx
  void ***v11; // rax
  void **v12; // rcx
  void **v13; // rbx
  void ***v14; // rax
  void **v15; // rcx
  void **v16; // rbx
  void ***v17; // rax
  void **v18; // rcx
  void **v19; // rbx
  void **v20; // rcx
  void **v21; // rbx

  v1 = (void ***)a1[18];
  v3 = *v1;
  *v1 = (void **)v1;
  *((_QWORD *)a1[18] + 1) = a1[18];
  a1[19] = 0i64;
  if ( v3 != a1[18] )
  {
    do
    {
      v4 = (void **)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != a1[18] );
  }
  j_free(a1[18]);
  v5 = (void ***)a1[15];
  v6 = *v5;
  *v5 = (void **)v5;
  *((_QWORD *)a1[15] + 1) = a1[15];
  a1[16] = 0i64;
  if ( v6 != a1[15] )
  {
    do
    {
      v7 = (void **)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != a1[15] );
  }
  j_free(a1[15]);
  v8 = (void ***)a1[12];
  v9 = *v8;
  *v8 = (void **)v8;
  *((_QWORD *)a1[12] + 1) = a1[12];
  a1[13] = 0i64;
  if ( v9 != a1[12] )
  {
    do
    {
      v10 = (void **)*v9;
      j_free(v9);
      v9 = v10;
    }
    while ( v10 != a1[12] );
  }
  j_free(a1[12]);
  v11 = (void ***)a1[9];
  v12 = *v11;
  *v11 = (void **)v11;
  *((_QWORD *)a1[9] + 1) = a1[9];
  a1[10] = 0i64;
  if ( v12 != a1[9] )
  {
    do
    {
      v13 = (void **)*v12;
      j_free(v12);
      v12 = v13;
    }
    while ( v13 != a1[9] );
  }
  j_free(a1[9]);
  v14 = (void ***)a1[6];
  v15 = *v14;
  *v14 = (void **)v14;
  *((_QWORD *)a1[6] + 1) = a1[6];
  a1[7] = 0i64;
  if ( v15 != a1[6] )
  {
    do
    {
      v16 = (void **)*v15;
      j_free(v15);
      v15 = v16;
    }
    while ( v16 != a1[6] );
  }
  j_free(a1[6]);
  v17 = (void ***)a1[3];
  v18 = *v17;
  *v17 = (void **)v17;
  *((_QWORD *)a1[3] + 1) = a1[3];
  a1[4] = 0i64;
  if ( v18 != a1[3] )
  {
    do
    {
      v19 = (void **)*v18;
      j_free(v18);
      v18 = v19;
    }
    while ( v19 != a1[3] );
  }
  j_free(a1[3]);
  v20 = *(void ***)*a1;
  *(_QWORD *)*a1 = *a1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v20 != *a1 )
  {
    do
    {
      v21 = (void **)*v20;
      j_free(v20);
      v20 = v21;
    }
    while ( v21 != *a1 );
  }
  j_free(*a1);
}

//----- (0000000140017E60) ----------------------------------------------------
__int64 __fastcall sub_140017E60(__int64 a1, __int64 a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  sub_140017F10((__int64 **)(a1 + 8), (_QWORD ***)(a2 + 8));
  sub_140017F10((__int64 **)(a1 + 32), (_QWORD ***)(a2 + 32));
  sub_140017F10((__int64 **)(a1 + 56), (_QWORD ***)(a2 + 56));
  sub_140017F10((__int64 **)(a1 + 80), (_QWORD ***)(a2 + 80));
  sub_140017F10((__int64 **)(a1 + 104), (_QWORD ***)(a2 + 104));
  sub_140017F10((__int64 **)(a1 + 128), (_QWORD ***)(a2 + 128));
  sub_140017F10((__int64 **)(a1 + 152), (_QWORD ***)(a2 + 152));
  return a1;
}

//----- (0000000140017F10) ----------------------------------------------------
__int64 **__fastcall sub_140017F10(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x20ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_14000BDC0((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140017FB0) ----------------------------------------------------
__int64 **__fastcall sub_140017FB0(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x38ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_140018220((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140018050) ----------------------------------------------------
_QWORD *__fastcall sub_140018050(void *Src, void *a2, unsigned __int64 a3)
{
  _QWORD *v5; // rbx
  unsigned __int64 v6; // r9
  void *v7; // rax
  _QWORD *v8; // rax
  char *v10; // r8
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rcx
  _QWORD *v13; // rcx
  bool v14; // cf
  _QWORD *v15; // rcx

  v5 = Src;
  if ( !a2 )
    goto LABEL_13;
  v6 = *((_QWORD *)Src + 3);
  v7 = v6 < 8 ? Src : *(void **)Src;
  if ( a2 < v7 )
    goto LABEL_13;
  if ( v6 >= 8 )
    Src = *(void **)Src;
  if ( (char *)Src + 2 * v5[2] <= a2 )
  {
LABEL_13:
    v10 = (char *)v5[2];
    if ( -1 - (__int64)v10 <= a3 )
      sub_14002B5F8("string too long");
    if ( !a3 )
      return v5;
    v11 = (unsigned __int64)&v10[a3];
    if ( (unsigned __int64)&v10[a3] > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v12 = v5[3];
    if ( v12 >= v11 )
    {
      if ( v11 )
        goto LABEL_20;
      v5[2] = 0i64;
      if ( v12 < 8 )
        *(_WORD *)v5 = 0;
      else
        *(_WORD *)*v5 = 0;
    }
    else
    {
      sub_1400097B0(v5, (unsigned __int64)&v10[a3], v10);
      if ( v11 )
      {
LABEL_20:
        if ( v5[3] < 8ui64 )
          v13 = v5;
        else
          v13 = (_QWORD *)*v5;
        memmove((char *)v13 + 2 * v5[2], a2, 2 * a3);
        v14 = v5[3] < 8ui64;
        v5[2] = v11;
        if ( v14 )
          v15 = v5;
        else
          v15 = (_QWORD *)*v5;
        *((_WORD *)v15 + v11) = 0;
      }
    }
    return v5;
  }
  if ( v6 < 8 )
    v8 = v5;
  else
    v8 = (_QWORD *)*v5;
  return sub_140006E60(v5, v5, ((_BYTE *)a2 - (_BYTE *)v8) >> 1, a3);
}

//----- (00000001400181B0) ----------------------------------------------------
void *__fastcall sub_1400181B0(void *a1, void *Src, void *a3)
{
  __int64 v4; // rcx
  _WORD *v5; // rdi
  bool v6; // zf
  _QWORD *v7; // rax

  v4 = -1i64;
  v5 = a3;
  do
  {
    if ( !v4 )
      break;
    v6 = *v5++ == 0;
    --v4;
  }
  while ( !v6 );
  v7 = sub_140018050(Src, a3, -v4 - 2);
  *((_QWORD *)a1 + 3) = 7i64;
  *((_QWORD *)a1 + 2) = 0i64;
  *(_WORD *)a1 = 0;
  sub_14000B3F0(a1, v7);
  return a1;
}

//----- (0000000140018220) ----------------------------------------------------
void __fastcall sub_140018220(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_14001C600(v4, *(_QWORD *)(v4 + 8), a3 + 2);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (00000001400182D0) ----------------------------------------------------
__int64 __fastcall sub_1400182D0(__int64 a1, __int64 a2, __int64 a3)
{
  DWORD LastError; // edi
  unsigned int v7; // esi
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // rbx
  FARPROC v10; // rax
  ULONG_PTR Cookie; // [rsp+68h] [rbp+20h] BYREF

  LastError = 0;
  v7 = 0;
  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64))qword_14012E180;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v8 )
    goto LABEL_9;
  v10 = sub_140001610("ImageList_GetIconSize");
  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64))v10;
  if ( v10 )
  {
    qword_14012E180 = (__int64)v10;
LABEL_9:
    v7 = v8(a1, a2, a3);
  }
  if ( !v7 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v7 )
    SetLastError(LastError);
  return v7;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E180: using guessed type __int64 qword_14012E180;

//----- (00000001400183D0) ----------------------------------------------------
__int64 __fastcall sub_1400183D0(__int64 a1)
{
  __int64 v2; // rbx
  __int64 (__fastcall *v3)(__int64); // rdi
  DWORD LastError; // esi
  FARPROC v5; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  v2 = -1i64;
  v3 = (__int64 (__fastcall *)(__int64))qword_14012E190;
  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return v2;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return v2;
  if ( v3 )
    goto LABEL_8;
  v5 = sub_1400184C0("PropertySheetW");
  v3 = (__int64 (__fastcall *)(__int64))v5;
  if ( v5 )
  {
    qword_14012E190 = (__int64)v5;
LABEL_8:
    v2 = v3(a1);
  }
  if ( v2 == -1 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( v2 == -1 )
    SetLastError(LastError);
  return v2;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E190: using guessed type __int64 qword_14012E190;

//----- (00000001400184C0) ----------------------------------------------------
FARPROC __fastcall sub_1400184C0(LPCSTR lpProcName)
{
  DWORD LastError; // edi
  FARPROC ProcAddress; // rbx
  int v4; // esi
  HMODULE LibraryW; // rax
  ULONG_PTR ulCookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  ProcAddress = 0i64;
  ulCookie = 0i64;
  v4 = sub_1400015A0(&ulCookie);
  if ( v4 )
  {
    LibraryW = qword_14012E198;
    if ( !qword_14012E198 )
    {
      LibraryW = LoadLibraryW(L"Comctl32.dll");
      if ( !LibraryW )
        goto LABEL_6;
      qword_14012E198 = LibraryW;
    }
    ProcAddress = GetProcAddress(LibraryW, lpProcName);
  }
LABEL_6:
  if ( v4 )
  {
    if ( !ProcAddress )
      LastError = GetLastError();
    DeactivateActCtx(0, ulCookie);
    if ( !ProcAddress )
      SetLastError(LastError);
  }
  return ProcAddress;
}

//----- (0000000140018580) ----------------------------------------------------
__int64 __fastcall sub_140018580(__int64 a1)
{
  DWORD LastError; // esi
  __int64 v3; // rdi
  __int64 v4; // r12
  FARPROC v6; // rax
  __int64 (__fastcall *v7)(__int64); // r11
  int v8; // eax
  ULONG_PTR Cookie; // [rsp+40h] [rbp+8h] BYREF

  LastError = 0;
  v3 = 0i64;
  v4 = qword_14012E1A0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
  {
    v7 = (__int64 (__fastcall *)(__int64))qword_14012E1A0;
LABEL_10:
    v8 = *(_DWORD *)(a1 + 4);
    if ( (v8 & 0x4000) == 0 && *(_DWORD *)a1 >= 0x60u )
    {
      *(_DWORD *)(a1 + 4) = v8 | 0x4000;
      *(_QWORD *)(a1 + 88) = hActCtx;
    }
    v3 = v7(a1);
    goto LABEL_14;
  }
  v6 = sub_1400184C0("CreatePropertySheetPageW");
  v7 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E1A0 = (__int64)v6;
    goto LABEL_10;
  }
LABEL_14:
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E1A0: using guessed type __int64 qword_14012E1A0;

//----- (00000001400186A0) ----------------------------------------------------
void __fastcall sub_1400186A0(__int64 a1)
{
  void *v2; // rcx

  v2 = *(void **)(a1 + 32);
  if ( v2 )
    j_free(v2);
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  sub_140018CF0(a1 + 8);
  j_free(*(void **)(a1 + 8));
}

//----- (0000000140018720) ----------------------------------------------------
void *__fastcall sub_140018720(void *Block, char a2)
{
  sub_14009F270((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140018750) ----------------------------------------------------
void *__fastcall sub_140018750(void *Block, char a2)
{
  sub_14009EF90((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140018780) ----------------------------------------------------
void __fastcall sub_140018780(__int64 *a1, _DWORD *a2)
{
  unsigned __int64 v3; // rcx
  __int64 v5; // rdi
  _DWORD *v6; // rcx
  __int64 v7; // r8
  _DWORD *v8; // rcx

  v3 = a1[1];
  if ( (unsigned __int64)a2 >= v3 || *a1 > (unsigned __int64)a2 )
  {
    if ( v3 == a1[2] )
      sub_140018B90(a1);
    v8 = (_DWORD *)a1[1];
    if ( v8 )
    {
      *v8 = *a2;
      v8[1] = a2[1];
      v8[2] = a2[2];
    }
  }
  else
  {
    v5 = ((__int64)a2 - *a1) / 12;
    if ( v3 == a1[2] )
      sub_140018B90(a1);
    v6 = (_DWORD *)a1[1];
    v7 = *a1;
    if ( v6 )
    {
      *v6 = *(_DWORD *)(v7 + 12 * v5);
      v6[1] = *(_DWORD *)(v7 + 12 * v5 + 4);
      v6[2] = *(_DWORD *)(v7 + 12 * v5 + 8);
      a1[1] += 12i64;
      return;
    }
  }
  a1[1] += 12i64;
}

//----- (00000001400188F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400188F0(__int64 a1, _QWORD *a2)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  unsigned __int64 result; // rax
  _QWORD *v6; // rcx

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x6666666666666667i64) >> 64) >> 63;
  if ( v4 / 40 == v3 )
  {
    if ( v3 )
    {
      sub_140009610(*(void **)(a1 + 24), a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      *(_QWORD *)(a1 + 24) += 40i64;
      if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 8) )
        *(_QWORD *)(a1 + 24) = *(_QWORD *)a1;
      result = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 16) = result;
    }
  }
  else
  {
    v6 = *(_QWORD **)(a1 + 24);
    if ( v6 )
    {
      v6[3] = 7i64;
      v6[2] = 0i64;
      *(_WORD *)v6 = 0;
      sub_140009610(v6, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
    *(_QWORD *)(a1 + 24) += 40i64;
    result = *(_QWORD *)(a1 + 24);
    if ( result == *(_QWORD *)(a1 + 8) )
    {
      result = *(_QWORD *)a1;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)a1;
    }
    ++*(_QWORD *)(a1 + 32);
  }
  return result;
}

//----- (00000001400189C0) ----------------------------------------------------
__int64 __fastcall sub_1400189C0(__int64 *a1, _QWORD *a2)
{
  __int64 v3; // r11
  __int64 v4; // rcx
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 result; // rax
  bool v8; // zf
  _QWORD *v9; // rcx

  v3 = a1[4];
  v4 = a1[1];
  v5 = *a1;
  v6 = v4 - *a1;
  result = (unsigned __int64)((unsigned __int128)(v6 * (__int128)0x6666666666666667i64) >> 64) >> 63;
  if ( v6 / 40 == v3 )
  {
    if ( v3 )
    {
      if ( a1[2] == v5 )
        a1[2] = v4;
      a1[2] -= 40i64;
      sub_140009610((void *)a1[2], a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      result = a1[2];
      a1[3] = result;
    }
  }
  else
  {
    if ( a1[2] == v5 )
      a1[2] = v4;
    v8 = a1[2] == 40;
    a1[2] -= 40i64;
    v9 = (_QWORD *)a1[2];
    if ( !v8 )
    {
      v9[3] = 7i64;
      v9[2] = 0i64;
      *(_WORD *)v9 = 0;
      result = (__int64)sub_140009610(v9, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    }
    ++a1[4];
  }
  return result;
}

//----- (0000000140018A90) ----------------------------------------------------
_QWORD *__fastcall sub_140018A90(__int64 a1, _QWORD *a2, __int64 *a3)
{
  _QWORD *v4; // rcx
  _QWORD *v6; // rdi
  __int64 v8; // rdi
  __int64 v10; // [rsp+20h] [rbp-18h]
  __int64 v11; // [rsp+28h] [rbp-10h]

  v4 = (_QWORD *)a3[1];
  v6 = v4 + 5;
  if ( v4 + 5 == *(_QWORD **)(a1 + 8) )
    v6 = *(_QWORD **)a1;
  while ( v6 != *(_QWORD **)(a1 + 24) )
  {
    sub_140009610(v4, v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v4 = v6;
    v6 += 5;
    if ( v6 == *(_QWORD **)(a1 + 8) )
      v6 = *(_QWORD **)a1;
  }
  if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)a1 )
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) -= 40i64;
  v8 = *(_QWORD *)(a1 + 24);
  if ( *(_QWORD *)(v8 + 24) >= 8ui64 )
    j_free(*(void **)v8);
  *(_QWORD *)(v8 + 24) = 7i64;
  *(_QWORD *)(v8 + 16) = 0i64;
  *(_WORD *)v8 = 0;
  --*(_QWORD *)(a1 + 32);
  if ( *(_QWORD *)(a1 + 24) == a3[1] )
  {
    v10 = a1;
    v11 = 0i64;
  }
  else
  {
    v11 = a3[1];
    v10 = *a3;
  }
  *a2 = v10;
  a2[1] = v11;
  return a2;
}

//----- (0000000140018B90) ----------------------------------------------------
unsigned __int64 __fastcall sub_140018B90(_QWORD *a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdx

  v2 = (a1[1] - *a1) / 12i64;
  if ( v2 > 0x1555555555555554i64 )
    sub_14002B5F8("vector<T> too long");
  v3 = v2 + 1;
  v4 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 63;
  v6 = v4 / 12;
  if ( v3 > v4 / 12 )
  {
    if ( 0x1555555555555555i64 - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v3 )
        v8 = v3;
      return sub_140018D70(a1, v8);
    }
    else
    {
      v7 = 0i64;
      if ( v3 )
        v7 = v3;
      return sub_140018D70(a1, v7);
    }
  }
  return result;
}
// 140018D70: using guessed type __int64 __fastcall sub_140018D70(_QWORD, _QWORD);

//----- (0000000140018C50) ----------------------------------------------------
__int64 __fastcall sub_140018C50(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v5; // rax
  _QWORD *v6; // rcx
  __int64 result; // rax
  __int64 v9; // [rsp+30h] [rbp+8h] BYREF

  v2 = a1[4];
  v3 = a1[5];
  v5 = a1[1];
  v6 = a1 + 4;
  v9 = v5;
  if ( v2 != v3 )
    v6[1] = v2;
  result = sub_140018F90(v6, *v6, 2 * a2, &v9);
  a1[9] = a2;
  a1[8] = a2 - 1;
  return result;
}
// 140018F90: using guessed type __int64 __fastcall sub_140018F90(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140018CD0) ----------------------------------------------------
void __fastcall sub_140018CD0(void **a1)
{
  sub_140018CF0((__int64)a1);
  j_free(*a1);
}

//----- (0000000140018CF0) ----------------------------------------------------
void __fastcall sub_140018CF0(__int64 a1)
{
  void **v2; // rbx
  void **v3; // rsi

  v2 = **(void ****)a1;
  **(_QWORD **)a1 = *(_QWORD *)a1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v2 != *(void ***)a1 )
  {
    do
    {
      v3 = (void **)*v2;
      if ( (unsigned __int64)v2[6] >= 8 )
        j_free(v2[3]);
      v2[6] = (void *)7;
      v2[5] = 0i64;
      *((_WORD *)v2 + 12) = 0;
      j_free(v2);
      v2 = v3;
    }
    while ( v3 != *(void ***)a1 );
  }
}

//----- (0000000140018EA0) ----------------------------------------------------
__int64 __fastcall sub_140018EA0(__int64 *a1)
{
  unsigned __int64 i; // rsi
  __int64 v3; // rdi
  __int64 result; // rax

  for ( i = 0i64; i < a1[4]; ++i )
  {
    v3 = a1[2];
    if ( *(_QWORD *)(v3 + 24) >= 8ui64 )
      j_free(*(void **)v3);
    *(_QWORD *)(v3 + 24) = 7i64;
    *(_QWORD *)(v3 + 16) = 0i64;
    *(_WORD *)v3 = 0;
    a1[2] += 40i64;
    result = a1[2];
    if ( result == a1[1] )
    {
      result = *a1;
      a1[2] = *a1;
    }
  }
  return result;
}

//----- (0000000140018F20) ----------------------------------------------------
void *__fastcall sub_140018F20(unsigned __int64 a1)
{
  void *result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  result = 0i64;
  if ( a1 )
  {
    if ( a1 > 0x666666666666666i64 || (result = operator new(40 * a1)) == 0i64 )
    {
      v3 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140019320) ----------------------------------------------------
void __fastcall sub_140019320(__int64 a1, __int64 *a2)
{
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  char *v6; // rax
  __int64 v7; // rdx
  void *Block[3]; // [rsp+28h] [rbp-60h] BYREF
  unsigned __int64 v9; // [rsp+40h] [rbp-48h]

  v4 = 0i64;
  if ( *(_QWORD *)(a1 + 32) )
    v4 = *(_QWORD **)(a1 + 16);
  if ( v4 )
  {
    do
    {
      v9 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      sub_140009610(Block, v4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v5 = *a2;
      v6 = sub_14000A760(*a2, *(_QWORD *)(*a2 + 8), Block);
      v7 = a2[1];
      if ( v7 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      a2[1] = v7 + 1;
      *(_QWORD *)(v5 + 8) = v6;
      **((_QWORD **)v6 + 1) = v6;
      if ( v9 >= 8 )
        j_free(Block[0]);
      v4 += 5;
      if ( v4 == *(_QWORD **)(a1 + 8) )
        v4 = *(_QWORD **)a1;
    }
    while ( v4 != *(_QWORD **)(a1 + 24) && v4 );
  }
}

//----- (0000000140019440) ----------------------------------------------------
std::exception *__fastcall sub_140019440(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::length_error::`vftable';
  return a1;
}
// 1400E41E0: using guessed type void *std::length_error::`vftable';

//----- (0000000140019470) ----------------------------------------------------
__int64 __fastcall sub_140019470(_QWORD *a1, __int64 a2, int *a3, __int64 a4)
{
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // rcx
  __int64 *v16; // rcx
  __int64 v17; // rdx
  div_t v19; // [rsp+60h] [rbp+8h]

  v19 = div(*a3, 127773);
  v7 = a1[8];
  v8 = v7 & (16807 * v19.rem - 2836 * v19.quot + (16807 * v19.rem - 2836 * v19.quot < 0 ? 0x7FFFFFFF : 0));
  if ( a1[9] <= v8 )
    v8 += -1i64 - (v7 >> 1);
  v9 = a1[4];
  v10 = a1[1];
  v11 = 2 * v8;
  v12 = *(_QWORD *)(v9 + 8 * v11);
  if ( v10 == v12 || (v10 = **(_QWORD **)(v9 + 8 * v11 + 8), v10 == v12) )
  {
LABEL_7:
    v13 = a4;
    if ( v10 != *(_QWORD *)a4 )
    {
      sub_1400196F0((__int64)(a1 + 1), v10, (__int64)(a1 + 1), a4, *(_QWORD *)a4);
      v13 = a4;
    }
    v14 = a1[4];
    v15 = *(_QWORD *)(v14 + 8 * v11);
    if ( v15 == a1[1] )
    {
      *(_QWORD *)(v14 + 8 * v11) = v13;
      *(_QWORD *)(a1[4] + 8 * v11 + 8) = v13;
    }
    else if ( v15 == v10 )
    {
      *(_QWORD *)(v14 + 8 * v11) = v13;
    }
    else
    {
      v16 = *(__int64 **)(v14 + 8 * v11 + 8);
      v17 = *v16;
      *(_QWORD *)(v14 + 8 * v11 + 8) = *v16;
      if ( v17 != v13 )
        *(_QWORD *)(a1[4] + 8 * v11 + 8) = *(_QWORD *)(*(_QWORD *)(a1[4] + 8 * v11 + 8) + 8i64);
    }
    sub_140019610((__int64)a1);
    *(_BYTE *)(a2 + 8) = 1;
    *(_QWORD *)a2 = a4;
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_QWORD *)(v10 + 8);
      if ( *(_DWORD *)(v10 + 16) == *a3 )
        break;
      if ( v10 == v12 )
        goto LABEL_7;
    }
    if ( a4 != a1[1] )
    {
      **(_QWORD **)(a4 + 8) = *(_QWORD *)a4;
      *(_QWORD *)(*(_QWORD *)a4 + 8i64) = *(_QWORD *)(a4 + 8);
      if ( *(_QWORD *)(a4 + 48) >= 8ui64 )
        j_free(*(void **)(a4 + 24));
      *(_QWORD *)(a4 + 48) = 7i64;
      *(_QWORD *)(a4 + 40) = 0i64;
      *(_WORD *)(a4 + 24) = 0;
      j_free((void *)a4);
      --a1[2];
    }
    *(_QWORD *)a2 = v10;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}

//----- (0000000140019610) ----------------------------------------------------
_QWORD *__fastcall sub_140019610(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rbx
  float v4; // xmm0_4
  float v5; // xmm1_4
  int i; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  result = *(_QWORD **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 72);
  v4 = (float)(int)result;
  if ( (__int64)result < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)v2;
  if ( v2 < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > *(float *)(a1 + 80) )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( (unsigned __int64)v2 >= 0xFFFFFFFFFFFFFFFi64 )
        break;
      v2 *= 2i64;
    }
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 40);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v7 != v8 )
      *(_QWORD *)(a1 + 40) = v7;
    sub_140018F90(a1 + 32, *(_QWORD *)(a1 + 32), 2 * v2, &v10);
    v9 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 64) = v2 - 1;
    *(_QWORD *)(a1 + 72) = v2;
    return sub_1400197A0((_QWORD *)a1, v9);
  }
  return result;
}
// 140018F90: using guessed type __int64 __fastcall sub_140018F90(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400196F0) ----------------------------------------------------
__int64 __fastcall sub_1400196F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 result; // rax

  if ( a1 != a3 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 == 0x555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v5 + 1;
    --*(_QWORD *)(a3 + 8);
  }
  **(_QWORD **)(a4 + 8) = a5;
  **(_QWORD **)(a5 + 8) = a2;
  **(_QWORD **)(a2 + 8) = a4;
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = *(_QWORD *)(a4 + 8);
  result = a4;
  *(_QWORD *)(a4 + 8) = v6;
  return result;
}

//----- (00000001400197A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400197A0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v4; // rax
  __int64 v5; // r9
  bool v6; // bl
  char v7[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 i; // [rsp+48h] [rbp+10h]

  result = (_QWORD *)a1[1];
  if ( *result != a2 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    for ( i = v4; ; v4 = i )
    {
      v5 = *(_QWORD *)a1[1];
      v6 = v5 == v4;
      result = (_QWORD *)sub_140019470(a1, (__int64)v7, (int *)(v5 + 16), v5);
      if ( v6 )
        break;
    }
  }
  return result;
}
// 1400197A0: using guessed type char var_18[24];

//----- (0000000140019810) ----------------------------------------------------
_QWORD *__fastcall sub_140019810(_QWORD *a1, _QWORD **a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v8; // r9
  _WORD *v9; // rcx
  void **v10; // rdx
  unsigned __int64 v11; // r8
  int v12; // er8
  int v13; // eax
  bool v14; // di
  _QWORD *v15; // rcx
  _QWORD *v16; // rcx
  void *Block[2]; // [rsp+20h] [rbp-88h] BYREF
  unsigned __int64 v19; // [rsp+30h] [rbp-78h]
  unsigned __int64 v20; // [rsp+38h] [rbp-70h]
  __int64 v21; // [rsp+48h] [rbp-60h]
  __int64 v22; // [rsp+50h] [rbp-58h]

  v21 = -2i64;
  v22 = a4;
  if ( a2[1] != *(_QWORD **)(a3 + 8) )
  {
    do
    {
      v20 = 7i64;
      v19 = 0i64;
      LOWORD(Block[0]) = 0;
      sub_140009610(Block, a2[1], 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v8 = *(_QWORD *)(a4 + 16);
      if ( *(_QWORD *)(a4 + 24) < 8ui64 )
        v9 = (_WORD *)a4;
      else
        v9 = *(_WORD **)a4;
      v10 = Block;
      if ( v20 >= 8 )
        v10 = (void **)Block[0];
      v11 = *(_QWORD *)(a4 + 16);
      if ( v19 < v8 )
        v11 = v19;
      if ( v11 )
      {
        while ( *(_WORD *)v10 == *v9 )
        {
          v10 = (void **)((char *)v10 + 2);
          ++v9;
          if ( !--v11 )
            goto LABEL_16;
        }
        v12 = 1;
        if ( *(_WORD *)v10 < *v9 )
          v12 = -1;
      }
      else
      {
LABEL_16:
        v12 = 0;
      }
      v13 = v12;
      if ( !v12 )
      {
        if ( v19 >= v8 )
          v13 = v19 != *(_QWORD *)(a4 + 16);
        else
          v13 = -1;
      }
      v14 = v13 == 0;
      if ( v20 >= 8 )
        j_free(Block[0]);
      if ( v14 )
        break;
      v15 = *a2;
      a2[1] += 5;
      if ( a2[1] == (_QWORD *)v15[1] )
        a2[1] = (_QWORD *)*v15;
      v16 = a2[1];
      if ( v16 == (_QWORD *)(*a2)[3] )
        v16 = 0i64;
      a2[1] = v16;
    }
    while ( v16 != *(_QWORD **)(a3 + 8) );
  }
  *a1 = *a2;
  a1[1] = a2[1];
  if ( *(_QWORD *)(a4 + 24) >= 8ui64 )
    j_free(*(void **)a4);
  *(_QWORD *)(a4 + 24) = 7i64;
  *(_QWORD *)(a4 + 16) = 0i64;
  *(_WORD *)a4 = 0;
  return a1;
}

//----- (00000001400199D0) ----------------------------------------------------
bool __fastcall sub_1400199D0(__int64 a1, __int64 a2, __int64 *a3, int a4)
{
  __int64 v5; // r10
  int v7; // eax
  int v8; // ecx
  __int64 v9; // rbx
  __int64 v10; // rcx
  bool v11; // bl
  char v12[8]; // [rsp+20h] [rbp-498h] BYREF
  __int64 v13; // [rsp+28h] [rbp-490h]
  char v14[1064]; // [rsp+30h] [rbp-488h] BYREF
  __int64 v15; // [rsp+458h] [rbp-60h]
  __int64 v16; // [rsp+460h] [rbp-58h]
  __int64 v17; // [rsp+468h] [rbp-50h]
  int v18; // [rsp+470h] [rbp-48h]
  int v19; // [rsp+474h] [rbp-44h]
  char v20; // [rsp+478h] [rbp-40h]
  char v21; // [rsp+47Ah] [rbp-3Eh]
  char v22; // [rsp+47Bh] [rbp-3Dh]
  __int64 v23; // [rsp+480h] [rbp-38h]
  __int64 v24; // [rsp+488h] [rbp-30h]
  struct std::locale::_Locimp *v25; // [rsp+490h] [rbp-28h] BYREF

  v13 = -2i64;
  v5 = *a3;
  if ( !*a3 )
    return 0;
  v7 = *(_DWORD *)(v5 + 32);
  v8 = *(_DWORD *)(v5 + 36);
  v15 = a2;
  v16 = a1;
  v17 = v5;
  v18 = v7;
  v19 = a4;
  v20 = 0;
  v21 = v8;
  if ( (*(_BYTE *)(v5 + 12) & 8) == 0 || (v22 = 1, (a4 & 0x10) != 0) )
    v22 = 0;
  v23 = 0i64;
  v24 = 0i64;
  v25 = std::locale::_Init();
  v9 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
  v10 = *(_QWORD *)(v9 + 8);
  if ( v10 != -1 )
    *(_QWORD *)(v9 + 8) = v10 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v12);
  v11 = sub_140016AB0((__int64)v14, 0i64, 1);
  sub_140008FC0((__int64 *)&v25);
  return v11;
}
// 1400199D0: using guessed type char var_498[8];
// 1400199D0: using guessed type char var_488[1064];

//----- (0000000140019AF0) ----------------------------------------------------
_DWORD *__fastcall sub_140019AF0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
    {
      *a3 = *a1;
      a3[1] = a1[1];
      a3[2] = a1[2];
    }
    a3 += 3;
    a1 += 3;
  }
  return a3;
}

//----- (0000000140019B30) ----------------------------------------------------
_QWORD *__fastcall sub_140019B30(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
      *a3 = *a1;
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000140019B70) ----------------------------------------------------
__int64 __fastcall sub_140019B70(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // r8
  _QWORD *v4; // r9
  unsigned __int64 v5; // rax

  v2 = *(_QWORD *)(a2 + 8);
  if ( !v2 )
    return **(_QWORD **)a1 + 40i64 * *(_QWORD *)(*(_QWORD *)a1 + 32i64);
  v4 = *(_QWORD **)a1;
  v5 = *(_QWORD *)(*(_QWORD *)a1 + 16i64);
  if ( v2 >= v5 )
    return *v4 + 40 * ((__int64)(v2 - v5) / 40);
  else
    return v2 + 40 * ((__int64)(v4[1] - v5) / 40);
}

//----- (0000000140019BF0) ----------------------------------------------------
char *__fastcall sub_140019BF0(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+38h] [rbp-20h] BYREF
  char *v10; // [rsp+78h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x40ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
  {
    *((_DWORD *)v6 + 4) = *a3;
    *((_QWORD *)v6 + 6) = 7i64;
    *((_QWORD *)v6 + 5) = 0i64;
    *((_WORD *)v6 + 12) = 0;
    sub_14000B3F0(v6 + 24, a3 + 2);
  }
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140019CD0) ----------------------------------------------------
__int64 **__fastcall sub_140019CD0(_QWORD *a1, __int64 **a2, int *a3)
{
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // r8
  __int64 v8; // r10
  __int64 *v9; // rdx
  __int64 v10; // r8
  __int64 i; // rax
  __int64 v12; // rcx
  div_t v14; // [rsp+30h] [rbp+8h]

  v14 = div(*a3, 127773);
  v6 = a1[8];
  v7 = v6 & (16807 * v14.rem - 2836 * v14.quot + (16807 * v14.rem - 2836 * v14.quot < 0 ? 0x7FFFFFFF : 0));
  if ( a1[9] <= v7 )
    v7 += -1i64 - (v6 >> 1);
  v8 = a1[4];
  v9 = (__int64 *)a1[1];
  v10 = 2 * v7;
  for ( i = *(_QWORD *)(v8 + 8 * v10); ; i = *(_QWORD *)i )
  {
    if ( *(__int64 **)(v8 + 8 * v10) == v9 )
      v12 = a1[1];
    else
      v12 = **(_QWORD **)(v8 + 8 * v10 + 8);
    if ( i == v12 )
    {
      *a2 = v9;
      return a2;
    }
    if ( *(_DWORD *)(i + 16) == *a3 )
      break;
  }
  if ( *a3 == *(_DWORD *)(i + 16) )
    *a2 = (__int64 *)i;
  else
    *a2 = v9;
  return a2;
}

//----- (0000000140019DD0) ----------------------------------------------------
__int64 __fastcall sub_140019DD0(_QWORD *a1, __int64 a2, int *a3, __int64 a4)
{
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // rcx
  __int64 *v16; // rcx
  __int64 v17; // rdx
  div_t v19; // [rsp+60h] [rbp+8h]

  v19 = div(*a3, 127773);
  v7 = a1[8];
  v8 = v7 & (16807 * v19.rem - 2836 * v19.quot + (16807 * v19.rem - 2836 * v19.quot < 0 ? 0x7FFFFFFF : 0));
  if ( a1[9] <= v8 )
    v8 += -1i64 - (v7 >> 1);
  v9 = a1[4];
  v10 = a1[1];
  v11 = 2 * v8;
  v12 = *(_QWORD *)(v9 + 8 * v11);
  if ( v10 == v12 || (v10 = **(_QWORD **)(v9 + 8 * v11 + 8), v10 == v12) )
  {
LABEL_7:
    v13 = a4;
    if ( v10 != *(_QWORD *)a4 )
    {
      sub_14001A020((__int64)(a1 + 1), v10, (__int64)(a1 + 1), a4, *(_QWORD *)a4);
      v13 = a4;
    }
    v14 = a1[4];
    v15 = *(_QWORD *)(v14 + 8 * v11);
    if ( v15 == a1[1] )
    {
      *(_QWORD *)(v14 + 8 * v11) = v13;
      *(_QWORD *)(a1[4] + 8 * v11 + 8) = v13;
    }
    else if ( v15 == v10 )
    {
      *(_QWORD *)(v14 + 8 * v11) = v13;
    }
    else
    {
      v16 = *(__int64 **)(v14 + 8 * v11 + 8);
      v17 = *v16;
      *(_QWORD *)(v14 + 8 * v11 + 8) = *v16;
      if ( v17 != v13 )
        *(_QWORD *)(a1[4] + 8 * v11 + 8) = *(_QWORD *)(*(_QWORD *)(a1[4] + 8 * v11 + 8) + 8i64);
    }
    sub_140019F40((__int64)a1);
    *(_BYTE *)(a2 + 8) = 1;
    *(_QWORD *)a2 = a4;
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_QWORD *)(v10 + 8);
      if ( *(_DWORD *)(v10 + 16) == *a3 )
        break;
      if ( v10 == v12 )
        goto LABEL_7;
    }
    if ( a4 != a1[1] )
    {
      **(_QWORD **)(a4 + 8) = *(_QWORD *)a4;
      *(_QWORD *)(*(_QWORD *)a4 + 8i64) = *(_QWORD *)(a4 + 8);
      j_free((void *)a4);
      --a1[2];
    }
    *(_QWORD *)a2 = v10;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}

//----- (0000000140019F40) ----------------------------------------------------
_QWORD *__fastcall sub_140019F40(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rbx
  float v4; // xmm0_4
  float v5; // xmm1_4
  int i; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  result = *(_QWORD **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 72);
  v4 = (float)(int)result;
  if ( (__int64)result < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)v2;
  if ( v2 < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > *(float *)(a1 + 80) )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( (unsigned __int64)v2 >= 0xFFFFFFFFFFFFFFFi64 )
        break;
      v2 *= 2i64;
    }
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 40);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v7 != v8 )
      *(_QWORD *)(a1 + 40) = v7;
    sub_140018F90(a1 + 32, *(_QWORD *)(a1 + 32), 2 * v2, &v10);
    v9 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 64) = v2 - 1;
    *(_QWORD *)(a1 + 72) = v2;
    return sub_14001A0D0((_QWORD *)a1, v9);
  }
  return result;
}
// 140018F90: using guessed type __int64 __fastcall sub_140018F90(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001A020) ----------------------------------------------------
__int64 __fastcall sub_14001A020(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 result; // rax

  if ( a1 != a3 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 == 0x1FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v5 + 1;
    --*(_QWORD *)(a3 + 8);
  }
  **(_QWORD **)(a4 + 8) = a5;
  **(_QWORD **)(a5 + 8) = a2;
  **(_QWORD **)(a2 + 8) = a4;
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = *(_QWORD *)(a4 + 8);
  result = a4;
  *(_QWORD *)(a4 + 8) = v6;
  return result;
}

//----- (000000014001A0D0) ----------------------------------------------------
_QWORD *__fastcall sub_14001A0D0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v4; // rax
  __int64 v5; // r9
  bool v6; // bl
  char v7[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 i; // [rsp+48h] [rbp+10h]

  result = (_QWORD *)a1[1];
  if ( *result != a2 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    for ( i = v4; ; v4 = i )
    {
      v5 = *(_QWORD *)a1[1];
      v6 = v5 == v4;
      result = (_QWORD *)sub_140019DD0(a1, (__int64)v7, (int *)(v5 + 16), v5);
      if ( v6 )
        break;
    }
  }
  return result;
}
// 14001A0D0: using guessed type char var_18[24];

//----- (000000014001A140) ----------------------------------------------------
__int64 __fastcall sub_14001A140(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 result; // rax

  while ( a2 )
  {
    if ( a1 )
    {
      result = *a3;
      *a1 = *a3;
    }
    --a2;
    ++a1;
  }
  return result;
}

//----- (000000014001A170) ----------------------------------------------------
__int64 **__fastcall sub_14001A170(__int64 **a1, __int64 **a2)
{
  __int64 *v3; // rax
  __int64 *v4; // rbx
  __int64 *v5; // rcx
  _QWORD *v6; // rdi
  __int64 *v7; // rsi

  if ( a1 != a2 )
  {
    v3 = *a1;
    v4 = *a2;
    v5 = (__int64 *)**a1;
    v6 = (_QWORD *)**a2;
    *v3 = (__int64)v3;
    (*a1)[1] = (__int64)*a1;
    a1[1] = 0i64;
    if ( v5 != *a1 )
    {
      do
      {
        v7 = (__int64 *)*v5;
        j_free(v5);
        v5 = v7;
      }
      while ( v7 != *a1 );
    }
    sub_14000BC10((__int64)a1, **a1, v6, v4);
  }
  return a1;
}

//----- (000000014001A1F0) ----------------------------------------------------
void *__fastcall sub_14001A1F0(unsigned __int64 a1)
{
  void *result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  result = 0i64;
  if ( a1 )
  {
    if ( a1 > 0x1FFFFFFFFFFFFFFFi64 || (result = operator new(8 * a1)) == 0i64 )
    {
      v3 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001A260) ----------------------------------------------------
__int64 *__fastcall sub_14001A260(__int64 *a1, __int64 *a2, __int64 *a3)
{
  if ( a1 == a2 || a2 == a3 )
    return a1;
  sub_14001A300(a1, (__int64)a2, a3);
  return &a1[a3 - a2];
}

//----- (000000014001A2C0) ----------------------------------------------------
_QWORD *__fastcall sub_14001A2C0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  while ( a1 != a2 )
  {
    if ( a3 )
      *a3 = a1[2];
    ++a3;
    a1 = (_QWORD *)*a1;
  }
  return a3;
}

//----- (000000014001A300) ----------------------------------------------------
__int64 __fastcall sub_14001A300(__int64 *a1, __int64 a2, __int64 *a3)
{
  __int64 v5; // r10
  signed __int64 v6; // r9
  __int64 v7; // r11
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 result; // rax
  __int64 v11; // rt2
  __int64 v12; // r9
  __int64 *v13; // r8
  __int64 *v14; // rdx
  __int64 *v15; // rdi
  __int64 v16; // rcx
  __int64 v17; // rcx

  v5 = (a2 - (__int64)a1) >> 3;
  v6 = a3 - a1;
  v7 = v6;
  v8 = v5;
  if ( v5 )
  {
    do
    {
      v9 = v7;
      v7 = v8;
      v11 = v9 % v8;
      result = v9 / v8;
      v8 = v11;
    }
    while ( v11 );
  }
  if ( v7 < v6 && v7 > 0 )
  {
    v12 = v5;
    v13 = &a1[v7];
    do
    {
      v14 = &v13[v12];
      v15 = v13;
      if ( &v13[v12] == a3 )
        v14 = a1;
      do
      {
        v16 = *v15;
        result = *v14;
        *v15 = *v14;
        *v14 = v16;
        v15 = v14;
        v17 = a3 - v14;
        if ( v5 >= v17 )
        {
          result = v5 - v17;
          v14 = &a1[v5 - v17];
        }
        else
        {
          v14 = (__int64 *)((char *)v14 + v12 * 8);
        }
      }
      while ( v14 != v13 );
      --v7;
      --v13;
    }
    while ( v7 > 0 );
  }
  return result;
}

//----- (000000014001A3C0) ----------------------------------------------------
void __fastcall sub_14001A3C0(__int64 *a1)
{
  __int64 v1; // rbx
  void *v3; // rcx

  v1 = *a1;
  if ( *a1 )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v1 + 16)) && v1 )
    {
      if ( *(_QWORD *)v1 )
        SysFreeString(*(BSTR *)v1);
      v3 = *(void **)(v1 + 8);
      if ( v3 )
        j_j_free(v3);
      j_free((void *)v1);
    }
    *a1 = 0i64;
  }
}

//----- (000000014001A430) ----------------------------------------------------
void *__fastcall sub_14001A430(void *Block, char a2)
{
  sub_1400984E0((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (000000014001A460) ----------------------------------------------------
void *__fastcall sub_14001A460(void *Block, char a2)
{
  sub_140098440((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (000000014001A540) ----------------------------------------------------
void __fastcall sub_14001A540(__int64 a1)
{
  void *v2; // rcx
  _QWORD **v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  v2 = *(void **)(a1 + 32);
  if ( v2 )
    j_free(v2);
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  v3 = *(_QWORD ***)(a1 + 8);
  v4 = *v3;
  *v3 = v3;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0i64;
  if ( v4 != *(_QWORD **)(a1 + 8) )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)(a1 + 8) );
  }
  j_free(*(void **)(a1 + 8));
}

//----- (000000014001A5B0) ----------------------------------------------------
void *__fastcall sub_14001A5B0(void *Src, _QWORD *a2, _WORD *a3)
{
  __int64 v6; // rcx
  _WORD *v7; // rdi
  bool v8; // zf
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdi
  _WORD *v11; // rax
  __int64 v12; // rcx
  _WORD *v13; // rdi

  *((_QWORD *)Src + 3) = 7i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_WORD *)Src = 0;
  v6 = -1i64;
  v7 = a3;
  do
  {
    if ( !v6 )
      break;
    v8 = *v7++ == 0;
    --v6;
  }
  while ( !v8 );
  v9 = a2[2] + -v6 - 2;
  v10 = *((_QWORD *)Src + 2);
  if ( v10 <= v9 && *((_QWORD *)Src + 3) != v9 && sub_140009900((const void **)Src, v9, 1) )
  {
    *((_QWORD *)Src + 2) = v10;
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v11 = Src;
    else
      v11 = *(_WORD **)Src;
    v11[v10] = 0;
  }
  sub_140006E60(Src, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v12 = -1i64;
  v13 = a3;
  do
  {
    if ( !v12 )
      break;
    v8 = *v13++ == 0;
    --v12;
  }
  while ( !v8 );
  sub_140018050(Src, a3, -v12 - 2);
  return Src;
}

//----- (000000014001A690) ----------------------------------------------------
char *__fastcall sub_14001A690(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x18ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_DWORD *)result + 4) = *a3;
    *((_DWORD *)result + 5) = a3[1];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001A730) ----------------------------------------------------
HWND __fastcall sub_14001A730(
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent,
        HINSTANCE hInstance,
        LPVOID lpParam)
{
  DWORD LastError; // ebx
  HWND Window; // rsi
  ULONG_PTR Cookie; // [rsp+60h] [rbp-18h] BYREF
  HWND v18; // [rsp+68h] [rbp-10h]

  LastError = 0;
  v18 = 0i64;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  Window = CreateWindowExW(
             0,
             lpClassName,
             lpWindowName,
             dwStyle,
             X,
             Y,
             nWidth,
             nHeight,
             hWndParent,
             0i64,
             hInstance,
             lpParam);
  v18 = Window;
  if ( !Window )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !Window )
    SetLastError(LastError);
  return Window;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (000000014001A860) ----------------------------------------------------
char *__fastcall sub_14001A860(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x28ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
    *((_QWORD *)result + 4) = a3[2];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001A910) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_14001A910(LPCWSTR lpClassName, HINSTANCE hInstance)
{
  DWORD LastError; // edi
  unsigned int v6; // esi
  ULONG_PTR v7; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v7 = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &v7) )
    return 0i64;
  v6 = UnregisterClassW(lpClassName, hInstance);
  if ( !v6 )
    LastError = GetLastError();
  DeactivateActCtx(0, v7);
  if ( !v6 )
    SetLastError(LastError);
  return v6;
}
// 1400DFF64: positive sp value 8 has been found
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (000000014001A9F0) ----------------------------------------------------
__int64 __fastcall sub_14001A9F0(WNDCLASSEXW *a1)
{
  DWORD LastError; // ebx
  ATOM v4; // di
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  v4 = RegisterClassExW(a1);
  if ( !v4 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v4 )
    SetLastError(LastError);
  return v4;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (000000014001AAB0) ----------------------------------------------------
void *__fastcall sub_14001AAB0(void *Block, char a2)
{
  char *v3; // rcx

  v3 = (char *)Block + 1056;
  *((_QWORD *)v3 - 132) = &CWildcardSelectDialogPersistentSettings::`vftable';
  sub_14000A630((__int64)v3);
  j_free(*((void **)Block + 132));
  *(_QWORD *)Block = &CDialogSettings::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400F7978: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (000000014001AB20) ----------------------------------------------------
__int64 __fastcall sub_14001AB20(__int64 a1)
{
  DWORD LastError; // esi
  unsigned int v3; // edi
  __int64 (__fastcall *v4)(__int64); // rbx
  FARPROC v6; // rax
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  v3 = 0;
  v4 = (__int64 (__fastcall *)(__int64))qword_14012E1B8;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  if ( v4 )
    goto LABEL_9;
  v6 = sub_140001610("InitCommonControlsEx");
  v4 = (__int64 (__fastcall *)(__int64))v6;
  if ( v6 )
  {
    qword_14012E1B8 = (__int64)v6;
LABEL_9:
    v3 = v4(a1);
  }
  if ( !v3 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v3 )
    SetLastError(LastError);
  return v3;
}
// 14012E0D4: using guessed type int dword_14012E0D4;
// 14012E1B8: using guessed type __int64 qword_14012E1B8;

//----- (000000014001AC00) ----------------------------------------------------
void sub_14001AC00()
{
  void **v0; // rcx
  void *v1; // rax
  void **v2; // rbx

  if ( Block )
    j_free(Block);
  Block = 0i64;
  qword_14012DFF8 = 0i64;
  qword_14012E000 = 0i64;
  v0 = *(void ***)qword_14012DFD8;
  *(_QWORD *)qword_14012DFD8 = qword_14012DFD8;
  *((_QWORD *)qword_14012DFD8 + 1) = qword_14012DFD8;
  v1 = qword_14012DFD8;
  qword_14012DFE0 = 0i64;
  if ( v0 != qword_14012DFD8 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012DFD8;
      v0 = v2;
    }
    while ( v2 != qword_14012DFD8 );
  }
  j_free(v1);
}
// 14012DFE0: using guessed type __int64 qword_14012DFE0;
// 14012DFF8: using guessed type __int64 qword_14012DFF8;
// 14012E000: using guessed type __int64 qword_14012E000;

//----- (000000014001AC90) ----------------------------------------------------
__int16 *__fastcall sub_14001AC90(__int16 *a1)
{
  _QWORD *v1; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v4; // [rsp+50h] [rbp+8h] BYREF
  __int16 *v5; // [rsp+58h] [rbp+10h]

  v5 = &word_14012DFD0;
  word_14012DFD0 = *a1;
  qword_14012DFE0 = 0i64;
  v1 = operator new(0x20ui64);
  if ( !v1 )
  {
    v4 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v4);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012DFD8 = v1;
  *v1 = v1;
  *((_QWORD *)qword_14012DFD8 + 1) = qword_14012DFD8;
  Block = 0i64;
  qword_14012DFF8 = 0i64;
  qword_14012E000 = 0i64;
  dword_14012E020 = 1065353216;
  sub_140018C50(&word_14012DFD0, 8i64);
  return &word_14012DFD0;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012DFD0: using guessed type __int16 word_14012DFD0;
// 14012DFE0: using guessed type __int64 qword_14012DFE0;
// 14012DFF8: using guessed type __int64 qword_14012DFF8;
// 14012E000: using guessed type __int64 qword_14012E000;
// 14012E020: using guessed type int dword_14012E020;

//----- (000000014001AD60) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001AD60(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdi
  int v2; // ebx
  div_t v4; // [rsp+30h] [rbp+8h]
  div_t v5; // [rsp+30h] [rbp+8h]

  v1 = HIDWORD(a1);
  v4 = div(a1, 127773);
  v2 = 16807 * v4.rem - 2836 * v4.quot + (16807 * v4.rem - 2836 * v4.quot < 0 ? 0x7FFFFFFF : 0);
  v5 = div(v1, 127773);
  return v2 ^ (unsigned __int64)(16807 * v5.rem - 2836 * v5.quot + (16807 * v5.rem - 2836 * v5.quot < 0 ? 0x7FFFFFFF : 0));
}

//----- (000000014001ADF0) ----------------------------------------------------
__int64 __fastcall sub_14001ADF0(_QWORD *a1, __int64 a2, unsigned __int64 *a3, __int64 a4)
{
  unsigned __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r8
  __int64 v14; // rcx
  __int64 *v15; // rcx
  __int64 v16; // rdx

  v7 = sub_14001AD60(*a3) & a1[8];
  if ( a1[9] <= v7 )
    v7 += -1i64 - (a1[8] >> 1);
  v8 = a1[4];
  v9 = a1[1];
  v10 = 2 * v7;
  v11 = *(_QWORD *)(v8 + 8 * v10);
  if ( v9 == v11 || (v9 = **(_QWORD **)(v8 + 8 * v10 + 8), v9 == v11) )
  {
LABEL_7:
    v12 = a4;
    if ( v9 != *(_QWORD *)a4 )
    {
      sub_14001B030((__int64)(a1 + 1), v9, (__int64)(a1 + 1), a4, *(_QWORD *)a4);
      v12 = a4;
    }
    v13 = a1[4];
    v14 = *(_QWORD *)(v13 + 8 * v10);
    if ( v14 == a1[1] )
    {
      *(_QWORD *)(v13 + 8 * v10) = v12;
      *(_QWORD *)(a1[4] + 8 * v10 + 8) = v12;
    }
    else if ( v14 == v9 )
    {
      *(_QWORD *)(v13 + 8 * v10) = v12;
    }
    else
    {
      v15 = *(__int64 **)(v13 + 8 * v10 + 8);
      v16 = *v15;
      *(_QWORD *)(v13 + 8 * v10 + 8) = *v15;
      if ( v16 != v12 )
        *(_QWORD *)(a1[4] + 8 * v10 + 8) = *(_QWORD *)(*(_QWORD *)(a1[4] + 8 * v10 + 8) + 8i64);
    }
    sub_14001AF50((__int64)a1);
    *(_BYTE *)(a2 + 8) = 1;
    *(_QWORD *)a2 = a4;
  }
  else
  {
    while ( 1 )
    {
      v9 = *(_QWORD *)(v9 + 8);
      if ( *(_QWORD *)(v9 + 16) == *a3 )
        break;
      if ( v9 == v11 )
        goto LABEL_7;
    }
    if ( a4 != a1[1] )
    {
      **(_QWORD **)(a4 + 8) = *(_QWORD *)a4;
      *(_QWORD *)(*(_QWORD *)a4 + 8i64) = *(_QWORD *)(a4 + 8);
      j_free((void *)a4);
      --a1[2];
    }
    *(_QWORD *)a2 = v9;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}

//----- (000000014001AF50) ----------------------------------------------------
_QWORD *__fastcall sub_14001AF50(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rbx
  float v4; // xmm0_4
  float v5; // xmm1_4
  int i; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  result = *(_QWORD **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 72);
  v4 = (float)(int)result;
  if ( (__int64)result < 0 )
    v4 = v4 + 1.8446744e19;
  v5 = (float)(int)v2;
  if ( v2 < 0 )
    v5 = v5 + 1.8446744e19;
  if ( (float)(v4 / v5) > *(float *)(a1 + 80) )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( (unsigned __int64)v2 >= 0xFFFFFFFFFFFFFFFi64 )
        break;
      v2 *= 2i64;
    }
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 40);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v7 != v8 )
      *(_QWORD *)(a1 + 40) = v7;
    sub_140018F90(a1 + 32, *(_QWORD *)(a1 + 32), 2 * v2, &v10);
    v9 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 64) = v2 - 1;
    *(_QWORD *)(a1 + 72) = v2;
    return sub_14001B0E0((_QWORD *)a1, v9);
  }
  return result;
}
// 140018F90: using guessed type __int64 __fastcall sub_140018F90(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001B030) ----------------------------------------------------
__int64 __fastcall sub_14001B030(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 result; // rax

  if ( a1 != a3 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    if ( v5 == 0xFFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v5 + 1;
    --*(_QWORD *)(a3 + 8);
  }
  **(_QWORD **)(a4 + 8) = a5;
  **(_QWORD **)(a5 + 8) = a2;
  **(_QWORD **)(a2 + 8) = a4;
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = *(_QWORD *)(a4 + 8);
  result = a4;
  *(_QWORD *)(a4 + 8) = v6;
  return result;
}

//----- (000000014001B0E0) ----------------------------------------------------
_QWORD *__fastcall sub_14001B0E0(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v4; // rax
  __int64 v5; // r9
  bool v6; // bl
  char v7[24]; // [rsp+20h] [rbp-18h] BYREF
  __int64 i; // [rsp+48h] [rbp+10h]

  result = (_QWORD *)a1[1];
  if ( *result != a2 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    for ( i = v4; ; v4 = i )
    {
      v5 = *(_QWORD *)a1[1];
      v6 = v5 == v4;
      result = (_QWORD *)sub_14001ADF0(a1, (__int64)v7, (unsigned __int64 *)(v5 + 16), v5);
      if ( v6 )
        break;
    }
  }
  return result;
}
// 14001B0E0: using guessed type char var_18[24];

//----- (000000014001B150) ----------------------------------------------------
char *__fastcall sub_14001B150(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x20ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001B200) ----------------------------------------------------
__int64 __fastcall sub_14001B200(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rax
  void (__fastcall ***v11)(_QWORD, __int64); // rsi
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // rcx
  __int64 v17[2]; // [rsp+30h] [rbp-78h] BYREF
  char v18; // [rsp+40h] [rbp-68h] BYREF
  __int64 v19; // [rsp+48h] [rbp-60h]
  __int64 v20; // [rsp+50h] [rbp-58h]
  char v22[16]; // [rsp+60h] [rbp-48h] BYREF
  char v23; // [rsp+C8h] [rbp+20h] BYREF

  v17[1] = -2i64;
  v2 = 0;
  v20 = a1;
  v3 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  v4 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v4 + a1 + 16) )
  {
    v5 = *(_QWORD *)(v4 + a1 + 80);
    if ( v5 )
      sub_1400086F0(v5);
  }
  v6 = *(_QWORD *)a1;
  if ( *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 16) == 0 )
  {
    v7 = sub_140008F00(a1 + *(int *)(v6 + 4), v17);
    v8 = sub_14000F240((__int64)v7);
    v9 = v17[0];
    if ( v17[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v23, 0);
      v10 = *(_QWORD *)(v9 + 8);
      if ( v10 && v10 != -1 )
        *(_QWORD *)(v9 + 8) = v10 - 1;
      v11 = 0i64;
      if ( !*(_QWORD *)(v9 + 8) )
        v11 = (void (__fastcall ***)(_QWORD, __int64))v9;
      std::_Lockit::~_Lockit((std::_Lockit *)&v23);
      if ( v11 )
        (**v11)(v11, 1i64);
    }
    v12 = *(_QWORD *)(a1 + *(int *)(*(_QWORD *)a1 + 4i64) + 72);
    v18 = 0;
    v19 = v12;
    (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v8 + 24i64))(v8, v22, &v18);
    if ( v22[0] )
      v2 = 4;
  }
  v13 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v2 )
  {
    v14 = v2 | *(_DWORD *)(v13 + 16);
    if ( !*(_QWORD *)(v13 + 72) )
      LOBYTE(v14) = v14 | 4;
    sub_140009260(v13, v14, 0);
  }
  if ( !__uncaught_exception() )
    sub_1400154C0(a1);
  v15 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  return a1;
}
// 14001B200: could not find valid save-restore pair for rbp
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);
// 14001B200: using guessed type char var_48[16];

//----- (000000014001B3E0) ----------------------------------------------------
__int64 *__fastcall sub_14001B3E0(__int64 a1, __int64 *a2, __int64 *a3)
{
  void (__fastcall ***v6)(_QWORD, __int64); // rsi
  __int64 **v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v11[5]; // [rsp+20h] [rbp-28h] BYREF
  char v12; // [rsp+68h] [rbp+20h] BYREF

  v11[1] = -2i64;
  v6 = 0i64;
  sub_14001B8F0(a1, a2, a3);
  v7 = *(__int64 ***)(a1 + 72);
  if ( v7 )
  {
    sub_14001B540(v7, v11, a3);
    v8 = v11[0];
    if ( v11[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v12, 0);
      v9 = *(_QWORD *)(v8 + 8);
      if ( v9 && v9 != -1 )
        *(_QWORD *)(v8 + 8) = v9 - 1;
      if ( !*(_QWORD *)(v8 + 8) )
        v6 = (void (__fastcall ***)(_QWORD, __int64))v8;
      std::_Lockit::~_Lockit((std::_Lockit *)&v12);
      if ( v6 )
        (**v6)(v6, 1i64);
    }
  }
  return a2;
}

//----- (000000014001B490) ----------------------------------------------------
__int64 __fastcall sub_14001B490(char *a1, _QWORD *a2)
{
  __int64 v2; // rbp
  _QWORD *v3; // rsi
  char *v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rax
  char *i; // rbx
  __int64 v8; // rcx
  _WORD *v9; // rax

  v2 = a2[2];
  v3 = a2;
  v4 = a1;
  if ( a2[3] >= 8ui64 )
    v3 = (_QWORD *)*a2;
  v5 = *((_QWORD *)a1 + 2);
  if ( !v5 )
    return -1i64;
  v6 = v5 - 1;
  if ( *((_QWORD *)a1 + 3) >= 8ui64 )
    a1 = *(char **)a1;
  for ( i = &a1[2 * v6]; ; i -= 2 )
  {
    v8 = v2;
    v9 = v3;
    if ( !v2 )
      break;
    while ( *v9 != *(_WORD *)i )
    {
      ++v9;
      if ( !--v8 )
        goto LABEL_10;
    }
    if ( i == (char *)sub_140009D30(v4) )
      return -1i64;
  }
LABEL_10:
  if ( *((_QWORD *)v4 + 3) >= 8ui64 )
    v4 = *(char **)v4;
  return (i - v4) >> 1;
}

//----- (000000014001B540) ----------------------------------------------------
__int64 *__fastcall sub_14001B540(__int64 **a1, __int64 *a2, __int64 *a3)
{
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rax
  char v10; // [rsp+50h] [rbp+8h] BYREF
  __int64 *v11; // [rsp+58h] [rbp+10h]
  int v12; // [rsp+68h] [rbp+20h]

  v11 = a2;
  v12 = 0;
  v6 = a1[13];
  v7 = *v6;
  *a2 = *v6;
  std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
  v8 = *(_QWORD *)(v7 + 8);
  if ( v8 != -1 )
    *(_QWORD *)(v7 + 8) = v8 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  v12 = 1;
  ((void (__fastcall *)(__int64 **, __int64 *))(*a1)[14])(a1, a3);
  sub_14001B830(a1[13], a3);
  return a2;
}

//----- (000000014001B5D0) ----------------------------------------------------
__int64 __fastcall sub_14001B5D0(__int64 a1, _WORD *a2)
{
  int v4; // ebx
  __int64 v5; // rcx
  _WORD *v6; // rdi
  bool v7; // zf
  __int64 v8; // r13
  __int64 v9; // rcx
  __int64 v10; // rdi
  __int64 v11; // rdi
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  unsigned __int16 v17; // r8
  _QWORD *v18; // rcx
  int *v19; // rax
  _WORD **v20; // rcx
  unsigned __int16 *v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rcx
  unsigned __int16 v24; // r8
  _QWORD *v25; // rcx
  int *v26; // rax
  _WORD **v27; // rcx
  unsigned __int16 *v28; // rdx
  __int64 v29; // rcx
  int v30; // edx
  __int64 v31; // rcx

  v4 = 0;
  v5 = -1i64;
  v6 = a2;
  do
  {
    if ( !v5 )
      break;
    v7 = *v6++ == 0;
    --v5;
  }
  while ( !v7 );
  v8 = -v5 - 2;
  v9 = *(int *)(*(_QWORD *)a1 + 4i64);
  v10 = *(_QWORD *)(v9 + a1 + 40);
  if ( v10 <= 0 || v10 <= v8 )
    v11 = 0i64;
  else
    v11 = v10 - v8;
  v12 = *(_QWORD *)(v9 + a1 + 72);
  if ( v12 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 8i64))(v12);
  v13 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v13 + a1 + 16) )
  {
    v14 = *(_QWORD *)(v13 + a1 + 80);
    if ( v14 )
      sub_1400086F0(v14);
  }
  v15 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( *(_DWORD *)(v15 + a1 + 16) )
  {
    v4 = 4;
  }
  else
  {
    if ( (*(_DWORD *)(v15 + a1 + 24) & 0x1C0) == 64 )
      goto LABEL_25;
    while ( v11 > 0 )
    {
      v16 = *(int *)(*(_QWORD *)a1 + 4i64);
      v17 = *(_WORD *)(v16 + a1 + 88);
      v18 = *(_QWORD **)(v16 + a1 + 72);
      if ( *(_QWORD *)v18[9] && (v19 = (int *)v18[12], *v19 > 0) )
      {
        --*v19;
        v20 = (_WORD **)v18[9];
        v21 = (*v20)++;
        *v21 = v17;
      }
      else
      {
        v17 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v18 + 24i64))(v18, v17);
      }
      if ( v17 == 0xFFFF )
      {
        v4 = 4;
        break;
      }
      --v11;
    }
    if ( !v4 )
    {
LABEL_25:
      v22 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
      if ( (*(__int64 (__fastcall **)(__int64, _WORD *, __int64))(*(_QWORD *)v22 + 72i64))(v22, a2, v8) == v8 )
      {
        while ( v11 > 0 )
        {
          v23 = *(int *)(*(_QWORD *)a1 + 4i64);
          v24 = *(_WORD *)(v23 + a1 + 88);
          v25 = *(_QWORD **)(v23 + a1 + 72);
          if ( *(_QWORD *)v25[9] && (v26 = (int *)v25[12], *v26 > 0) )
          {
            --*v26;
            v27 = (_WORD **)v25[9];
            v28 = (*v27)++;
            *v28 = v24;
          }
          else
          {
            v24 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD))(*v25 + 24i64))(v25, v24);
          }
          if ( v24 == 0xFFFF )
          {
            v4 |= 4u;
            break;
          }
          --v11;
        }
      }
      else
      {
        v4 = 4;
      }
    }
    *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 40) = 0i64;
  }
  v29 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v4 )
  {
    v30 = v4 | *(_DWORD *)(v29 + 16);
    if ( !*(_QWORD *)(v29 + 72) )
      LOBYTE(v30) = v30 | 4;
    sub_140009260(v29, v30, 0);
  }
  if ( !__uncaught_exception() )
    sub_1400154C0(a1);
  v31 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v31 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
  return a1;
}
// 14001B5D0: could not find valid save-restore pair for rbp
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);

//----- (000000014001B830) ----------------------------------------------------
__int64 *__fastcall sub_14001B830(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rdi
  __int64 v5; // rax
  void (__fastcall ***v6)(_QWORD, __int64); // rsi
  __int64 v7; // rdi
  __int64 v8; // rax
  char v10; // [rsp+30h] [rbp+8h] BYREF

  v2 = *a1;
  if ( *a1 != *a2 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v5 = *(_QWORD *)(v2 + 8);
    if ( v5 && v5 != -1 )
      *(_QWORD *)(v2 + 8) = v5 - 1;
    v6 = 0i64;
    if ( !*(_QWORD *)(v2 + 8) )
      v6 = (void (__fastcall ***)(_QWORD, __int64))v2;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    if ( v6 )
      (**v6)(v6, 1i64);
    v7 = *a2;
    *a1 = *a2;
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    v8 = *(_QWORD *)(v7 + 8);
    if ( v8 != -1 )
      *(_QWORD *)(v7 + 8) = v8 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  }
  return a1;
}

//----- (000000014001B8F0) ----------------------------------------------------
__int64 *__fastcall sub_14001B8F0(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 **i; // rbx
  char v11; // [rsp+50h] [rbp+8h] BYREF
  __int64 *v12; // [rsp+58h] [rbp+10h]
  int v13; // [rsp+68h] [rbp+20h]

  v12 = a2;
  v13 = 0;
  v6 = *(__int64 **)(a1 + 64);
  v7 = *v6;
  *a2 = *v6;
  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v8 = *(_QWORD *)(v7 + 8);
  if ( v8 != -1 )
    *(_QWORD *)(v7 + 8) = v8 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  v13 = 1;
  sub_14001B830(*(__int64 **)(a1 + 64), a3);
  for ( i = *(__int64 ***)(a1 + 56); i; i = (__int64 **)*i )
    ((void (__fastcall *)(__int64, __int64, _QWORD))i[2])(1i64, a1, *((unsigned int *)i + 2));
  return a2;
}

//----- (000000014001BA20) ----------------------------------------------------
__int64 __fastcall sub_14001BA20(_WORD *a1, __int64 a2, unsigned __int64 a3)
{
  _WORD *v4; // rax
  __int64 v5; // r10
  int v6; // er11
  __int64 v7; // rax
  __int64 v9; // r9
  _WORD *v10; // rcx
  unsigned int v11; // er8
  __int64 v12; // rbx
  unsigned __int64 v13; // rdx
  __int16 v14; // ax

  v4 = a1;
  v5 = 1024i64;
  v6 = 0;
  while ( *v4 )
  {
    ++v4;
    if ( !--v5 )
    {
      v6 = -2147024809;
      v7 = 0i64;
      goto LABEL_6;
    }
  }
  v7 = 1024 - v5;
LABEL_6:
  if ( v6 < 0 )
    return (unsigned int)v6;
  if ( a3 > 0x7FFFFFFE )
    return 2147942487i64;
  v9 = 1024 - v7;
  v10 = &a1[v7];
  v11 = 0;
  if ( 1024 == v7 )
    goto LABEL_16;
  v12 = a2 - (_QWORD)v10;
  v13 = a3;
  while ( v13 )
  {
    v14 = *(_WORD *)((char *)v10 + v12);
    if ( !v14 )
      break;
    *v10++ = v14;
    --v13;
    if ( !--v9 )
      goto LABEL_16;
  }
  if ( !v9 )
  {
LABEL_16:
    --v10;
    v11 = -2147024774;
  }
  *v10 = 0;
  return v11;
}
// 14001BA62: conditional instruction was optimized away because r10.8!=0

//----- (000000014001BB80) ----------------------------------------------------
void **__fastcall sub_14001BB80(void **a1, _BYTE *a2)
{
  _BYTE *v3; // rcx
  _BYTE *i; // rbx
  __int64 v6; // rbx
  void *v7; // rax

  v3 = *a1;
  if ( v3 == a2 )
    return a1;
  if ( v3 )
    free(v3);
  *a1 = 0i64;
  if ( !a2 )
    return a1;
  for ( i = a2; *i; ++i )
    ;
  v6 = i - a2;
  v7 = malloc(v6 + 1);
  *a1 = v7;
  if ( v7 )
    memmove(v7, a2, v6 + 1);
  return a1;
}

//----- (000000014001BC10) ----------------------------------------------------
struct std::locale::_Locimp **__fastcall sub_14001BC10(struct std::locale::_Locimp **a1, const char *a2)
{
  void **v4; // rax
  struct std::locale::_Locimp *v5; // rdi
  const char *v6; // rsi
  __int64 pExceptionObject[3]; // [rsp+28h] [rbp-80h] BYREF
  char v9[8]; // [rsp+40h] [rbp-68h] BYREF
  void *v10; // [rsp+48h] [rbp-60h]
  char v11; // [rsp+50h] [rbp-58h]
  void *v12; // [rsp+58h] [rbp-50h]
  char v13; // [rsp+60h] [rbp-48h]
  void *v14; // [rsp+68h] [rbp-40h]
  char v15; // [rsp+70h] [rbp-38h]
  void *Block; // [rsp+78h] [rbp-30h]
  char v17; // [rsp+80h] [rbp-28h] BYREF
  char *v18; // [rsp+C0h] [rbp+18h] BYREF

  v4 = (void **)operator new(0x38ui64);
  v5 = (struct std::locale::_Locimp *)v4;
  if ( v4 )
  {
    v4[1] = (void *)1;
    *v4 = &std::locale::_Locimp::`vftable';
    v4[2] = 0i64;
    v4[3] = 0i64;
    *((_DWORD *)v4 + 8) = 0;
    *((_BYTE *)v4 + 36) = 0;
    v4[5] = 0i64;
    *((_BYTE *)v4 + 48) = 0;
    sub_14001BB80(v4 + 5, "*");
  }
  else
  {
    v5 = 0i64;
  }
  *a1 = v5;
  std::locale::_Init();
  std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
  v10 = 0i64;
  v11 = 0;
  v12 = 0i64;
  v13 = 0;
  v14 = 0i64;
  v15 = 0;
  Block = 0i64;
  v17 = 0;
  if ( !a2 )
  {
    v18 = "bad locale name";
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v18);
    pExceptionObject[0] = (__int64)&std::runtime_error::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)v9, 63, a2);
  v6 = &v17;
  if ( Block )
    v6 = (const char *)Block;
  if ( !strcmp(v6, "*") )
    sub_14002B68C("bad locale name");
  std::locale::_Locimp::_Makeloc((const struct std::_Locinfo *)v9, 63, *a1, 0i64);
  std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)v9);
  if ( Block )
    free(Block);
  Block = 0i64;
  if ( v14 )
    free(v14);
  v14 = 0i64;
  if ( v12 )
    free(v12);
  v12 = 0i64;
  if ( v10 )
    free(v10);
  v10 = 0i64;
  std::_Lockit::~_Lockit((std::_Lockit *)v9);
  return a1;
}
// 1400E4210: using guessed type void *std::runtime_error::`vftable';
// 1400E4398: using guessed type void *std::locale::_Locimp::`vftable';
// 14001BC10: using guessed type char var_68[8];

//----- (000000014001BDE0) ----------------------------------------------------
char *__fastcall sub_14001BDE0(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x20ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001BE90) ----------------------------------------------------
__int64 __fastcall sub_14001BE90(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rax
  void (__fastcall ***v11)(_QWORD, __int64); // rsi
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // rcx
  __int64 v17[2]; // [rsp+30h] [rbp-68h] BYREF
  char v18; // [rsp+40h] [rbp-58h] BYREF
  __int64 v19; // [rsp+48h] [rbp-50h]
  __int64 v20; // [rsp+50h] [rbp-48h]
  char v22[56]; // [rsp+60h] [rbp-38h] BYREF
  char v23; // [rsp+B8h] [rbp+20h] BYREF

  v17[1] = -2i64;
  v2 = 0;
  v20 = a1;
  v3 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  v4 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v4 + a1 + 16) )
  {
    v5 = *(_QWORD *)(v4 + a1 + 80);
    if ( v5 )
      sub_1400086F0(v5);
  }
  v6 = *(_QWORD *)a1;
  if ( *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 16) == 0 )
  {
    v7 = sub_140008F00(a1 + *(int *)(v6 + 4), v17);
    v8 = sub_14000F240((__int64)v7);
    v9 = v17[0];
    if ( v17[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v23, 0);
      v10 = *(_QWORD *)(v9 + 8);
      if ( v10 && v10 != -1 )
        *(_QWORD *)(v9 + 8) = v10 - 1;
      v11 = 0i64;
      if ( !*(_QWORD *)(v9 + 8) )
        v11 = (void (__fastcall ***)(_QWORD, __int64))v9;
      std::_Lockit::~_Lockit((std::_Lockit *)&v23);
      if ( v11 )
        (**v11)(v11, 1i64);
    }
    v12 = *(_QWORD *)(a1 + *(int *)(*(_QWORD *)a1 + 4i64) + 72);
    v18 = 0;
    v19 = v12;
    (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v8 + 32i64))(v8, v22, &v18);
    if ( v22[0] )
      v2 = 4;
  }
  v13 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v2 )
  {
    v14 = v2 | *(_DWORD *)(v13 + 16);
    if ( !*(_QWORD *)(v13 + 72) )
      LOBYTE(v14) = v14 | 4;
    sub_140009260(v13, v14, 0);
  }
  if ( !__uncaught_exception() )
    sub_1400154C0(a1);
  v15 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  return a1;
}
// 14001BE90: could not find valid save-restore pair for rbp
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);
// 14001BE90: using guessed type char var_38[56];

//----- (000000014001C070) ----------------------------------------------------
void *__fastcall sub_14001C070(void *Src, _QWORD *a2)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdi
  _WORD *v6; // rax

  *((_QWORD *)Src + 3) = 7i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_WORD *)Src = 0;
  v4 = a2[2] + 22i64;
  v5 = *((_QWORD *)Src + 2);
  if ( v5 <= v4 && *((_QWORD *)Src + 3) != v4 && sub_140009900((const void **)Src, v4, 1) )
  {
    *((_QWORD *)Src + 2) = v5;
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v6 = Src;
    else
      v6 = *(_WORD **)Src;
    v6[v5] = 0;
  }
  sub_140018050(Src, L"Directory\r\n---------\r\n", 0x16ui64);
  sub_140006E60(Src, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return Src;
}
// 1400EBB00: using guessed type wchar_t aDirectory[23];

//----- (000000014001C120) ----------------------------------------------------
void *__fastcall sub_14001C120(void *a1, void *Src, void *a3)
{
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // r9
  void *v7; // rax

  v4 = *((_QWORD *)Src + 2);
  v5 = *((_QWORD *)a3 + 2);
  if ( v5 <= *((_QWORD *)Src + 3) - v4 || *((_QWORD *)a3 + 3) - v5 < v4 )
    v7 = sub_140006E60(Src, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  else
    v7 = sub_14000B910(a3, Src, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *((_QWORD *)a1 + 3) = 7i64;
  *((_QWORD *)a1 + 2) = 0i64;
  *(_WORD *)a1 = 0;
  sub_14000B3F0(a1, v7);
  return a1;
}

//----- (000000014001C1B0) ----------------------------------------------------
__int64 __fastcall sub_14001C1B0(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdi
  void *v6; // rax
  __int64 result; // rax
  _QWORD *v8; // rcx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v10; // [rsp+50h] [rbp+8h] BYREF

  if ( a1[2] <= (unsigned __int64)(a1[4] + 1i64) )
    sub_14001C280(a1);
  v4 = a1[2];
  v5 = a1[4] + a1[3];
  if ( v4 <= v5 )
    v5 -= v4;
  if ( !*(_QWORD *)(a1[1] + 8 * v5) )
  {
    v6 = operator new(0x10ui64);
    if ( !v6 )
    {
      v10 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_QWORD *)(a1[1] + 8 * v5) = v6;
  }
  result = a1[1];
  v8 = *(_QWORD **)(result + 8 * v5);
  if ( v8 )
  {
    *v8 = *a2;
    result = a2[1];
    v8[1] = result;
  }
  ++a1[4];
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001C280) ----------------------------------------------------
void __fastcall sub_14001C280(_QWORD *a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rbp
  char *v6; // r12
  unsigned __int64 v7; // rcx
  __int64 v8; // r13
  unsigned __int64 v9; // rbx
  char *v10; // rax
  const void *v11; // rdx
  char *v12; // rcx
  char *v13; // rax
  void *v14; // rcx
  size_t v15; // r8
  char *v16; // rax
  void *v17; // rcx
  __int64 pExceptionObject[4]; // [rsp+20h] [rbp-48h] BYREF
  char *v19; // [rsp+70h] [rbp+8h] BYREF

  v2 = a1[2];
  v3 = 1i64;
  if ( v2 == 0xFFFFFFFFFFFFFFFi64 )
    sub_14002B5F8("deque<T> too long");
  v4 = v2 >> 1;
  if ( v2 >> 1 >= 8 )
  {
    if ( v4 <= 1 )
      goto LABEL_8;
  }
  else
  {
    v4 = 8i64;
  }
  if ( v2 <= 0xFFFFFFFFFFFFFFFi64 - v4 )
    v3 = v4;
LABEL_8:
  v5 = a1[3];
  v6 = 0i64;
  v7 = v3 + v2;
  if ( v7 )
  {
    if ( v7 > 0x1FFFFFFFFFFFFFFFi64 || (v6 = (char *)operator new(8 * v7)) == 0i64 )
    {
      v19 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v19);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  v8 = 8 * v5;
  v9 = (8i64 * a1[2] - 8 * v5) & 0xFFFFFFFFFFFFFFF8ui64;
  v10 = (char *)memmove(&v6[8 * v5], (const void *)(8 * v5 + a1[1]), v9);
  v11 = (const void *)a1[1];
  v12 = &v10[v9];
  if ( v5 > v3 )
  {
    memmove(v12, v11, 8 * v3);
    v16 = (char *)memmove(v6, (const void *)(8 * v3 + a1[1]), 8 * ((__int64)(v8 - 8 * v3) >> 3))
        + 8 * ((__int64)(v8 - 8 * v3) >> 3);
    v14 = v16;
    v15 = 8 * v3;
    goto LABEL_19;
  }
  v13 = (char *)memmove(v12, v11, 8 * (v8 >> 3)) + 8 * (v8 >> 3);
  if ( v3 != v5 )
    memset(v13, 0, 8 * (v3 - v5));
  if ( v5 )
  {
    v14 = v6;
    v15 = 8 * v5;
LABEL_19:
    memset(v14, 0, v15);
  }
  v17 = (void *)a1[1];
  if ( v17 )
    j_free(v17);
  a1[2] += v3;
  a1[1] = v6;
}
// 14001C419: conditional instruction was optimized away because rsi.8!=0
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001C460) ----------------------------------------------------
_QWORD *__fastcall sub_14001C460(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  *a1 = 0i64;
  v2 = operator new(0x10ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = 0i64;
  v2[1] = 0i64;
  *(_QWORD *)*a1 = a1;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  a1[4] = 0i64;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001C4E0) ----------------------------------------------------
_QWORD *__fastcall sub_14001C4E0(__int64 a1, _QWORD *a2)
{
  _QWORD **v2; // rsi
  _QWORD ***v5; // rax
  __int64 v6; // rdi
  __int64 v7; // rdi
  char v9; // [rsp+30h] [rbp+8h] BYREF

  v2 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v5 = **(_QWORD *****)a1;
    if ( v5 )
    {
      v2 = *v5;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v9, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    }
  }
  v6 = *(_QWORD *)(a1 + 16);
  *a2 = 0i64;
  a2[1] = 0i64;
  v7 = v6 - 1;
  if ( v2 )
  {
    if ( *v2 )
    {
      *a2 = **v2;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v9, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    }
  }
  a2[2] = v7;
  return a2;
}

//----- (000000014001C590) ----------------------------------------------------
__int64 __fastcall sub_14001C590(__int64 a1)
{
  __int64 v2; // rcx
  int v3; // eax
  __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8);
  v6 = 0i64;
  v3 = GdipCloneBrush(v2, &v6);
  if ( v3 )
    *(_DWORD *)(a1 + 16) = v3;
  result = GdipAlloc(24i64);
  if ( result )
  {
    v5 = v6;
    *(_DWORD *)(result + 16) = *(_DWORD *)(a1 + 16);
    *(_QWORD *)(result + 8) = v5;
    *(_QWORD *)result = &Gdiplus::Brush::`vftable';
  }
  else
  {
    GdipDeleteBrush(v6);
    return 0i64;
  }
  return result;
}
// 1400E3D00: using guessed type __int64 __fastcall GdipCloneBrush(_QWORD, _QWORD);
// 1400E3D08: using guessed type __int64 __fastcall GdipDeleteBrush(_QWORD);
// 1400E3D98: using guessed type __int64 __fastcall GdipAlloc(_QWORD);
// 1400F7B48: using guessed type void *Gdiplus::Brush::`vftable';

//----- (000000014001C600) ----------------------------------------------------
char *__fastcall sub_14001C600(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x38ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
    *((_QWORD *)result + 4) = a3[2];
    *((_QWORD *)result + 5) = a3[3];
    *((_QWORD *)result + 6) = a3[4];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001C7D0) ----------------------------------------------------
void __fastcall sub_14001C7D0(__int64 **a1, _QWORD *a2, _QWORD *a3)
{
  sub_14001C800((__int64)a1, *a1, a2, a3);
}

//----- (000000014001C800) ----------------------------------------------------
void __fastcall sub_14001C800(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  unsigned __int64 v5; // rdi
  _QWORD *v6; // rax
  _QWORD *v7; // r11
  const void *v8; // rbx
  __int64 v9; // rcx
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rsi
  char *v12; // r13
  size_t v13; // rbx
  char *v14; // rax
  _QWORD *v15; // rax
  unsigned __int64 v16; // rdi

  if ( a3 != a4 )
  {
    v5 = 0i64;
    v6 = a3;
    do
    {
      ++v5;
      v6 = (_QWORD *)*v6;
    }
    while ( v6 != a4 );
    if ( v5 )
    {
      v7 = *(_QWORD **)(a1 + 8);
      v8 = *(const void **)a1;
      v9 = ((__int64)v7 - *(_QWORD *)a1) >> 3;
      if ( 0x1FFFFFFFFFFFFFFFi64 - v9 < v5 )
        sub_14002B5F8("vector<T> too long");
      v10 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v8) >> 3;
      if ( v10 >= v9 + v5 )
      {
        sub_14001A2C0(a3, a4, v7);
        sub_14001A260(a2, *(__int64 **)(a1 + 8), (__int64 *)(8 * v5 + *(_QWORD *)(a1 + 8)));
        *(_QWORD *)(a1 + 8) += 8 * v5;
      }
      else
      {
        if ( 0x1FFFFFFFFFFFFFFFi64 - (v10 >> 1) >= v10 )
          v11 = (v10 >> 1) + v10;
        else
          v11 = 0i64;
        if ( v11 < v9 + v5 )
          v11 = v9 + v5;
        v12 = (char *)sub_14001A1F0(v11);
        v13 = 8 * (((__int64)a2 - *(_QWORD *)a1) >> 3);
        v14 = (char *)memmove(v12, *(const void **)a1, v13);
        v15 = sub_14001A2C0(a3, a4, &v14[v13]);
        memmove(v15, a2, (*(_QWORD *)(a1 + 8) - (_QWORD)a2) & 0xFFFFFFFFFFFFFFF8ui64);
        v16 = ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3) + v5;
        if ( *(_QWORD *)a1 )
          j_free(*(void **)a1);
        *(_QWORD *)(a1 + 16) = &v12[8 * v11];
        *(_QWORD *)(a1 + 8) = &v12[8 * v16];
        *(_QWORD *)a1 = v12;
      }
    }
  }
}

//----- (000000014001C990) ----------------------------------------------------
__int64 **__fastcall sub_14001C990(__int64 **a1, _QWORD ***a2)
{
  __int64 *v4; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v7; // [rsp+60h] [rbp+18h] BYREF

  a1[1] = 0i64;
  v4 = (__int64 *)operator new(0x30ui64);
  if ( !v4 )
  {
    v7 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v7);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v4;
  *v4 = (__int64)v4;
  (*a1)[1] = (__int64)*a1;
  sub_14001CBC0((__int64)a1, **a1, **a2, *a2);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001CA30) ----------------------------------------------------
char *__fastcall sub_14001CA30(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x48ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
    *((_QWORD *)result + 4) = a3[2];
    *((_QWORD *)result + 5) = a3[3];
    *((_QWORD *)result + 6) = a3[4];
    *((_QWORD *)result + 7) = a3[5];
    *((_QWORD *)result + 8) = a3[6];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001CB00) ----------------------------------------------------
char *__fastcall sub_14001CB00(__int64 a1, __int64 a2, _QWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x30ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_QWORD *)result + 2) = *a3;
    *((_QWORD *)result + 3) = a3[1];
    *((_QWORD *)result + 4) = a3[2];
    *((_QWORD *)result + 5) = a3[3];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001CBC0) ----------------------------------------------------
void __fastcall sub_14001CBC0(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rbx
  char *v6; // r11
  __int64 v7; // rax
  _QWORD **v9; // [rsp+60h] [rbp+18h]
  _QWORD *v10; // [rsp+68h] [rbp+20h]

  v10 = a4;
  v9 = (_QWORD **)a3;
  v4 = a2;
  while ( a3 != a4 )
  {
    v6 = sub_14001CB00(v4, *(_QWORD *)(v4 + 8), a3 + 2);
    v7 = *(_QWORD *)(a1 + 8);
    if ( v7 == 0x7FFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v7 + 1;
    *(_QWORD *)(v4 + 8) = v6;
    **((_QWORD **)v6 + 1) = v6;
    a3 = *v9;
    v9 = (_QWORD **)*v9;
    a4 = v10;
    v4 = a2;
  }
}

//----- (000000014001CC70) ----------------------------------------------------
__int64 __fastcall sub_14001CC70(__int64 a1)
{
  return sub_140078EA0((void *)(a1 - 8));
}

//----- (000000014001CC80) ----------------------------------------------------
__int64 __fastcall sub_14001CC80(__int64 a1)
{
  return sub_140078A40(a1 - 8);
}

//----- (000000014001CC90) ----------------------------------------------------
__int64 __fastcall sub_14001CC90(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_140078BF0(a1 - 8, a2, a3);
}

//----- (000000014001CCA0) ----------------------------------------------------
_QWORD *__fastcall sub_14001CCA0(_QWORD *a1, char a2)
{
  *a1 = &CReferenceCount::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}
// 1400F7C30: using guessed type void *CReferenceCount::`vftable';

//----- (000000014001CCD0) ----------------------------------------------------
void *__fastcall sub_14001CCD0(void *Block)
{
  if ( *((_QWORD *)Block + 8) >= 8ui64 )
    j_free(*((void **)Block + 5));
  *((_QWORD *)Block + 8) = 7i64;
  *((_QWORD *)Block + 7) = 0i64;
  *((_WORD *)Block + 20) = 0;
  sub_14000A630((__int64)Block + 16);
  j_free(*((void **)Block + 2));
  j_free(Block);
  return Block;
}

//----- (000000014001CD30) ----------------------------------------------------
char *__fastcall sub_14001CD30(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x280ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x270ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001CDE0) ----------------------------------------------------
char *__fastcall sub_14001CDE0(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x28ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_DWORD *)result + 4) = *a3;
    *((_DWORD *)result + 5) = a3[1];
    *((_DWORD *)result + 6) = a3[2];
    *((_DWORD *)result + 7) = a3[3];
    *((_DWORD *)result + 8) = a3[4];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014001CE90) ----------------------------------------------------
__int64 sub_14001CE90()
{
  int v1; // [rsp+20h] [rbp-78h] BYREF
  __int64 v2; // [rsp+28h] [rbp-70h]
  __int64 v3; // [rsp+30h] [rbp-68h]
  WNDCLASSW WndClass; // [rsp+40h] [rbp-58h] BYREF

  v1 = 1;
  WndClass.cbWndExtra = 8;
  WndClass.lpfnWndProc = (WNDPROC)sub_14001D120;
  v2 = 0i64;
  v3 = 0i64;
  WndClass.style = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hIcon = 0i64;
  WndClass.hInstance = GetModuleHandleW(0i64);
  WndClass.hbrBackground = 0i64;
  WndClass.hCursor = LoadCursorW(0i64, (LPCWSTR)0x7F00);
  WndClass.lpszMenuName = 0i64;
  WndClass.lpszClassName = L"DisplayWindow";
  if ( !(unsigned __int16)sub_14001D940(&WndClass) )
    return 0i64;
  GdiplusStartup(&qword_14012DA88, &v1, 0i64);
  return 1i64;
}
// 1400E3D30: using guessed type __int64 __fastcall GdiplusStartup(_QWORD, _QWORD, _QWORD);
// 14012DA88: using guessed type __int64 qword_14012DA88;

//----- (000000014001CF50) ----------------------------------------------------
__int64 __fastcall sub_14001CF50(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // er9
  bool v4; // cf
  unsigned __int64 v5; // r10

  v3 = 0;
  *a3 = 0i64;
  v4 = 0;
  if ( *a2 || (v5 = a2[1], v4 = v5 < *(_QWORD *)stru_1400E4110.Data4, v5 != *(_QWORD *)stru_1400E4110.Data4) )
    v3 = -v4 - (v4 - 1);
  if ( v3 )
    return 2147500034i64;
  *a3 = a1;
  if ( !a1 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}

//----- (000000014001CFA0) ----------------------------------------------------
__int64 __fastcall sub_14001CFA0(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000014001CFB0) ----------------------------------------------------
__int64 __fastcall sub_14001CFB0(void *Block)
{
  if ( (*((_DWORD *)Block + 2))-- != 1 )
    return *((unsigned int *)Block + 2);
  sub_14001D0A0((__int64)Block);
  j_free(Block);
  return 0i64;
}

//----- (000000014001CFE0) ----------------------------------------------------
__int64 __fastcall sub_14001CFE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v5; // rax

  ++dword_14012DB94;
  *(_QWORD *)a1 = &CDisplayWindow::`vftable';
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_DWORD *)(a1 + 596) = -16777216;
  *(_DWORD *)(a1 + 600) = -16777216;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = a2;
  v4 = *(_QWORD *)(a3 + 24);
  *(_DWORD *)(a1 + 592) = 0;
  *(_DWORD *)(a1 + 28) = 20;
  *(_DWORD *)(a1 + 32) = 80;
  *(_QWORD *)(a1 + 816) = v4;
  *(_DWORD *)(a1 + 596) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 600) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a3 + 8);
  v5 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a1 + 656) = 0i64;
  *(_QWORD *)(a1 + 664) = 0i64;
  *(_DWORD *)(a1 + 672) = 0;
  *(_QWORD *)(a1 + 824) = v5;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 616));
  return a1;
}
// 1400F7CD8: using guessed type void *CDisplayWindow::`vftable';
// 14012DB94: using guessed type int dword_14012DB94;

//----- (000000014001D0A0) ----------------------------------------------------
__int64 __fastcall sub_14001D0A0(__int64 a1)
{
  void *v2; // rcx
  __int64 result; // rax

  *(_QWORD *)a1 = &CDisplayWindow::`vftable';
  DeleteDC(*(HDC *)(a1 + 768));
  DeleteObject(*(HGDIOBJ *)(a1 + 808));
  DestroyIcon(*(HICON *)(a1 + 816));
  if ( !--dword_14012DB94 )
    GdiplusShutdown(qword_14012DA88);
  v2 = *(void **)(a1 + 40);
  if ( v2 )
    j_free(v2);
  result = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  return result;
}
// 1400E3D18: using guessed type __int64 __fastcall GdiplusShutdown(_QWORD);
// 1400F7CD8: using guessed type void *CDisplayWindow::`vftable';
// 14012DA88: using guessed type __int64 qword_14012DA88;
// 14012DB94: using guessed type int dword_14012DB94;

//----- (000000014001D120) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001D120(HWND hWnd, UINT a2, HDC a3, int *a4)
{
  LONG_PTR WindowLongPtrW; // rbx
  __int64 v10; // rbx
  void *v11; // rax

  WindowLongPtrW = GetWindowLongPtrW(hWnd, -21);
  if ( a2 == 1 )
  {
    v10 = *(_QWORD *)a4;
    v11 = operator new(0x598ui64);
    if ( v11 )
      WindowLongPtrW = sub_14001CFE0((__int64)v11, (__int64)hWnd, v10);
    else
      WindowLongPtrW = 0i64;
    SetWindowLongPtrW(hWnd, -21, WindowLongPtrW);
  }
  else if ( a2 == 2 )
  {
    return 0i64;
  }
  return sub_14001D1D0(WindowLongPtrW, hWnd, a2, a3, a4);
}

//----- (000000014001D1D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001D1D0(__int64 a1, HWND a2, UINT a3, HDC a4, int *lParam)
{
  HDC v9; // rbx
  HDC v11; // rax
  HDC v12; // rax
  __int64 v13; // rdx
  char *v14; // rcx
  __int16 v15; // ax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rbx
  void *v19; // rcx
  unsigned __int64 v20; // rbx
  char *v21; // rdx
  HWND v22; // rcx
  __int64 v23; // rsi
  int v24; // edx
  char *v25; // rcx
  __int64 v26; // rdx
  signed __int64 v27; // r8
  __int16 v28; // ax
  HDC DC; // rbx
  struct tagRECT v30; // [rsp+20h] [rbp-4E8h] BYREF
  struct tagRECT v31; // [rsp+30h] [rbp-4D8h] BYREF
  struct tagRECT v32; // [rsp+40h] [rbp-4C8h] BYREF
  struct tagRECT Rect; // [rsp+50h] [rbp-4B8h] BYREF
  struct tagPAINTSTRUCT Paint; // [rsp+60h] [rbp-4A8h] BYREF
  char Src[1024]; // [rsp+B0h] [rbp-458h] BYREF

  if ( a3 > 0x8066 )
  {
    switch ( a3 )
    {
      case 0x8067u:
        return (*(unsigned __int8 *)(a1 + 600) << 16) | (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 600)) | (unsigned __int64)((unsigned __int8)BYTE1(*(_DWORD *)(a1 + 600)) << 8);
      case 0x8068u:
        *(_DWORD *)(a1 + 600) = BYTE2(a4) | ((BYTE1(a4) | (((unsigned __int8)a4 | 0xFFFFFF00) << 8)) << 8);
        goto LABEL_59;
      case 0x806Bu:
        return (*(unsigned __int8 *)(a1 + 596) << 16) | (unsigned __int8)BYTE2(*(_DWORD *)(a1 + 596)) | (unsigned __int64)((unsigned __int8)BYTE1(*(_DWORD *)(a1 + 596)) << 8);
      case 0x806Cu:
        *(_DWORD *)(a1 + 596) = BYTE2(a4) | ((BYTE1(a4) | (((unsigned __int8)a4 | 0xFFFFFF00) << 8)) << 8);
LABEL_59:
        DC = GetDC(a2);
        GetClientRect(a2, &v30);
        sub_14001DA00(a1, DC, &v30);
        ReleaseDC(a2, DC);
        goto LABEL_40;
      case 0x806Eu:
        sub_14001DBF0(a1, a4, lParam, lParam);
        return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
      case 0x806Fu:
        *(_QWORD *)a4 = *(_QWORD *)(a1 + 824);
        return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
      case 0x8070u:
        v22 = *(HWND *)(a1 + 16);
        *(_QWORD *)(a1 + 824) = a4;
        goto LABEL_41;
      case 0x8071u:
        return *(unsigned int *)(a1 + 24);
      case 0x8072u:
        v22 = *(HWND *)(a1 + 16);
        *(_DWORD *)(a1 + 24) = (_DWORD)a4;
        goto LABEL_41;
      case 0x8073u:
        if ( !lParam )
          goto LABEL_40;
        v13 = 512i64;
        v14 = Src;
        while ( v13 != -2147483134 )
        {
          v15 = *(_WORD *)&v14[(char *)lParam - Src];
          if ( !v15 )
            break;
          *(_WORD *)v14 = v15;
          v14 += 2;
          if ( !--v13 )
          {
            v14 -= 2;
            break;
          }
        }
        v16 = *(_QWORD *)(a1 + 48);
        *(_WORD *)v14 = 0;
        if ( (unsigned __int64)Src >= v16 || (v17 = *(_QWORD *)(a1 + 40), v17 > (unsigned __int64)Src) )
        {
          if ( v16 == *(_QWORD *)(a1 + 56) )
            sub_14001D740((__int64 *)(a1 + 40));
          v19 = *(void **)(a1 + 48);
          if ( v19 )
          {
            v21 = Src;
            goto LABEL_38;
          }
        }
        else
        {
          v18 = (unsigned __int64)&Src[-v17];
          if ( v16 == *(_QWORD *)(a1 + 56) )
            sub_14001D740((__int64 *)(a1 + 40));
          v19 = *(void **)(a1 + 48);
          v20 = *(_QWORD *)(a1 + 40) + (v18 & 0xFFFFFFFFFFFFFC00ui64);
          if ( v19 )
          {
            v21 = (char *)v20;
LABEL_38:
            memmove(v19, v21, 0x400ui64);
          }
        }
        *(_QWORD *)(a1 + 48) += 1024i64;
LABEL_40:
        v22 = a2;
LABEL_41:
        RedrawWindow(v22, 0i64, 0i64, 1u);
        return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
      case 0x8074u:
        v23 = *(_QWORD *)(a1 + 40);
        if ( v23 != *(_QWORD *)(a1 + 48) )
          *(_QWORD *)(a1 + 48) = v23;
        return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
      case 0x8075u:
        v24 = 0;
        if ( !lParam )
          goto LABEL_40;
        if ( (unsigned int)a4 >= (unsigned __int64)((__int64)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 10) )
          goto LABEL_40;
        v25 = *(char **)(a1 + 40);
        if ( v25 == *(char **)(a1 + 48) )
          goto LABEL_40;
        while ( v24 != (_DWORD)a4 )
        {
          v25 += 1024;
          ++v24;
          if ( v25 == *(char **)(a1 + 48) )
            goto LABEL_40;
        }
        v26 = 512i64;
        v27 = (char *)lParam - v25;
        while ( v26 != -2147483134 )
        {
          v28 = *(_WORD *)&v25[v27];
          if ( !v28 )
            break;
          *(_WORD *)v25 = v28;
          v25 += 2;
          if ( !--v26 )
          {
            *((_WORD *)v25 - 1) = 0;
            goto LABEL_40;
          }
        }
        *(_WORD *)v25 = 0;
        goto LABEL_40;
      default:
        return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
    }
  }
  if ( a3 == 32870 )
  {
    sub_14001E7A0(a1, (__int64)a4, (int)lParam);
    goto LABEL_40;
  }
  if ( a3 > 0x200 )
  {
    switch ( a3 )
    {
      case 0x201u:
        sub_14001E5C0(a1, (int)lParam);
        break;
      case 0x202u:
        *(_DWORD *)(a1 + 592) = 0;
        ReleaseCapture();
        break;
      case 0x205u:
        sub_14001E6F0(a1, (WPARAM)a4, (LPARAM)lParam);
        break;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 0x200u:
        return (int)sub_14001E460(a1, (int)lParam);
      case 1u:
        v12 = GetDC(a2);
        *(_QWORD *)(a1 + 768) = CreateCompatibleDC(v12);
        break;
      case 5u:
        sub_14001E890(a1, (int)lParam);
        break;
      case 0xFu:
        GetUpdateRect(a2, &v31, 0);
        GetClientRect(a2, &v30);
        v11 = BeginPaint(a2, &Paint);
        sub_14001DBF0(a1, v11, &v30, &v31.left);
        EndPaint(a2, &Paint);
        break;
      case 0x14u:
        v9 = GetDC(a2);
        GetUpdateRect(a2, &Rect, 0);
        GetClientRect(a2, &v32);
        sub_14001DBF0(a1, v9, &v32, &Rect.left);
        ReleaseDC(a2, v9);
        return 1i64;
    }
  }
  return DefWindowProcW(a2, a3, (WPARAM)a4, (LPARAM)lParam);
}
// 14001D407: conditional instruction was optimized away because rdx.8!=0
// 14001D585: conditional instruction was optimized away because rdx.8!=0

//----- (000000014001D740) ----------------------------------------------------
__int64 __fastcall sub_14001D740(__int64 *a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rdx

  result = *a1;
  v2 = (a1[1] - *a1) >> 10;
  if ( v2 > 0x3FFFFFFFFFFFFEi64 )
    sub_14002B5F8("vector<T> too long");
  v3 = v2 + 1;
  v4 = (a1[2] - result) >> 10;
  if ( v3 > v4 )
  {
    if ( 0x3FFFFFFFFFFFFFi64 - (v4 >> 1) >= v4 )
    {
      v6 = (v4 >> 1) + v4;
      if ( v6 < v3 )
        v6 = v3;
      return sub_14001D7D0(a1, v6);
    }
    else
    {
      v5 = 0i64;
      if ( v3 )
        v5 = v3;
      return sub_14001D7D0(a1, v5);
    }
  }
  return result;
}
// 14001D7D0: using guessed type __int64 __fastcall sub_14001D7D0(_QWORD, _QWORD);

//----- (000000014001D8E0) ----------------------------------------------------
char *__fastcall sub_14001D8E0(void *Src, void *a2, char *a3)
{
  while ( Src != a2 )
  {
    if ( a3 )
      memmove(a3, Src, 0x400ui64);
    a3 += 1024;
    Src = (char *)Src + 1024;
  }
  return a3;
}

//----- (000000014001D940) ----------------------------------------------------
__int64 __fastcall sub_14001D940(WNDCLASSW *lpWndClass)
{
  DWORD LastError; // ebx
  ATOM v4; // di
  ULONG_PTR Cookie; // [rsp+48h] [rbp+10h] BYREF

  LastError = 0;
  Cookie = 0i64;
  if ( !dword_14012E0D4
    || (OutputDebugStringA("IsolationAware function called after IsolationAwareCleanup\n"), !dword_14012E0D4) )
  {
    if ( !(unsigned int)sub_1400013C0() )
      return 0i64;
  }
  if ( !ActivateActCtx(hActCtx, &Cookie) )
    return 0i64;
  v4 = RegisterClassW(lpWndClass);
  if ( !v4 )
    LastError = GetLastError();
  DeactivateActCtx(0, Cookie);
  if ( !v4 )
    SetLastError(LastError);
  return v4;
}
// 14012E0D4: using guessed type int dword_14012E0D4;

//----- (000000014001DA00) ----------------------------------------------------
__int64 __fastcall sub_14001DA00(__int64 a1, HDC a2, _DWORD *a3)
{
  void *v6; // rcx
  HBITMAP CompatibleBitmap; // rax
  __int64 v8; // r13
  int v9; // er12
  unsigned int v10; // esi
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  __int64 v14; // rbx
  int v15; // eax
  int v16; // eax
  __int64 v17; // rbx
  __int64 v18; // rdx
  __int64 v20; // [rsp+38h] [rbp-48h] BYREF
  int v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h] BYREF
  int v23; // [rsp+50h] [rbp-30h]
  __int64 v24; // [rsp+58h] [rbp-28h]
  int v25; // [rsp+60h] [rbp-20h]
  void **v26; // [rsp+68h] [rbp-18h] BYREF
  __int64 v27; // [rsp+70h] [rbp-10h]
  int v28; // [rsp+78h] [rbp-8h]
  int v29; // [rsp+C0h] [rbp+40h] BYREF
  __int64 v30; // [rsp+D0h] [rbp+50h] BYREF
  __int64 v31; // [rsp+D8h] [rbp+58h] BYREF

  v20 = 0i64;
  v21 = GdipCreatePath(0i64, &v20);
  v31 = 0i64;
  v29 = 1;
  v6 = *(void **)(a1 + 808);
  if ( v6 )
    DeleteObject(v6);
  CompatibleBitmap = CreateCompatibleBitmap(a2, a3[2] - *a3, a3[3] - a3[1]);
  *(_QWORD *)(a1 + 808) = CompatibleBitmap;
  SelectObject(*(HDC *)(a1 + 768), CompatibleBitmap);
  v30 = 0i64;
  v25 = GdipCreateFromHDC(*(_QWORD *)(a1 + 768), &v30);
  v8 = v30;
  v24 = v30;
  v9 = a3[3] - a3[1];
  v10 = a3[2] - *a3;
  v11 = GdipAddPathRectangleI(v20, 0i64, 0i64, v10, v9);
  v12 = v21;
  if ( v11 )
    v12 = v11;
  v21 = v12;
  v26 = &Gdiplus::PathGradientBrush::`vftable';
  v30 = 0i64;
  v13 = GdipCreatePathGradientFromPath(v20, &v30);
  v14 = v30;
  v27 = v30;
  v15 = GdipSetPathGradientCenterPointI(v30, &v31);
  if ( v15 )
    v13 = v15;
  v16 = GdipSetPathGradientCenterColor(v14, *(unsigned int *)(a1 + 596));
  if ( v16 )
    v13 = v16;
  v28 = v13;
  sub_14001E9C0((__int64)&v26, a1 + 600, &v29);
  v17 = v27;
  GdipFillRectangleI(v8, v27);
  v22 = 0i64;
  v23 = GdipCreatePen1(4286611584i64, v18, 0i64, &v22, v10, v9);
  GdipDrawLineI(v8, v22, 0i64, 0i64, a3[2], 0);
  GdipDeletePen(v22);
  GdipDeleteBrush(v17);
  GdipDeleteGraphics(v8);
  return GdipDeletePath(v20);
}
// 14001DB7F: variable 'v18' is possibly undefined
// 1400E3CB8: using guessed type __int64 __fastcall GdipSetPathGradientCenterColor(_QWORD, _QWORD);
// 1400E3CC0: using guessed type __int64 __fastcall GdipSetPathGradientCenterPointI(_QWORD, _QWORD);
// 1400E3CC8: using guessed type __int64 __fastcall GdipCreatePathGradientFromPath(_QWORD, _QWORD);
// 1400E3CD0: using guessed type __int64 __fastcall GdipAddPathRectangleI(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1400E3CD8: using guessed type __int64 __fastcall GdipDeletePath(_QWORD);
// 1400E3CE0: using guessed type __int64 __fastcall GdipCreatePath(_QWORD, _QWORD);
// 1400E3CE8: using guessed type double __fastcall GdipFillRectangleI(_QWORD, _QWORD);
// 1400E3CF0: using guessed type __int64 __fastcall GdipDeleteGraphics(_QWORD);
// 1400E3CF8: using guessed type __int64 __fastcall GdipCreateFromHDC(_QWORD, _QWORD);
// 1400E3D08: using guessed type __int64 __fastcall GdipDeleteBrush(_QWORD);
// 1400E3D38: using guessed type __int64 __fastcall GdipCreatePen1(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 1400E3D60: using guessed type __int64 __fastcall GdipDeletePen(_QWORD);
// 1400E3DA0: using guessed type __int64 __fastcall GdipDrawLineI(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 1400F7D38: using guessed type void *Gdiplus::PathGradientBrush::`vftable';

//----- (000000014001DBF0) ----------------------------------------------------
BOOL __fastcall sub_14001DBF0(__int64 a1, HDC a2, _DWORD *a3, int *a4)
{
  HDC hdcSrc; // rbx
  HBITMAP CompatibleBitmap; // r13

  hdcSrc = CreateCompatibleDC(a2);
  CompatibleBitmap = CreateCompatibleBitmap(a2, a3[2] - *a3, a3[3] - a3[1]);
  SelectObject(hdcSrc, CompatibleBitmap);
  BitBlt(hdcSrc, *a4, a4[1], a3[2], a3[3], *(HDC *)(a1 + 768), *a4, a4[1], 0xCC0020u);
  sub_14001E270(a1, hdcSrc, *(_DWORD *)(a1 + 32));
  DrawIconEx(hdcSrc, 20, 20, *(HICON *)(a1 + 816), 48, 48, 0, 0i64, 3u);
  if ( *(_DWORD *)(a1 + 664) )
    sub_14001DD50(a1, hdcSrc);
  BitBlt(a2, *a4, a4[1], a3[2], a3[3], hdcSrc, *a4, a4[1], 0xCC0020u);
  DeleteDC(hdcSrc);
  return DeleteObject(CompatibleBitmap);
}

//----- (000000014001DD50) ----------------------------------------------------
void __fastcall sub_14001DD50(__int64 a1, HDC a2)
{
  HDC hdcSrc; // rdi
  HGDIOBJ v5; // rbx
  struct tagRECT Rect; // [rsp+50h] [rbp-38h] BYREF

  if ( *(_DWORD *)(a1 + 668) )
  {
    if ( !*(_DWORD *)(a1 + 672) )
    {
      GetClientRect(*(HWND *)(a1 + 16), &Rect);
      hdcSrc = CreateCompatibleDC(a2);
      v5 = SelectObject(hdcSrc, *(HGDIOBJ *)(a1 + 656));
      BitBlt(
        a2,
        *(_DWORD *)(a1 + 676),
        10,
        Rect.right - *(_DWORD *)(a1 + 676) - Rect.left,
        Rect.bottom - Rect.top - 20,
        hdcSrc,
        0,
        0,
        0xCC0020u);
      SelectObject(hdcSrc, v5);
      DeleteDC(hdcSrc);
    }
  }
  else
  {
    sub_14001DEA0(a1);
  }
}

//----- (000000014001DE50) ----------------------------------------------------
__int64 __fastcall StartAddress(LPVOID lpThreadParameter)
{
  __int64 v1; // rbx
  HANDLE CurrentThread; // rax

  v1 = *(_QWORD *)lpThreadParameter;
  CoInitializeEx(0i64, 2u);
  CurrentThread = GetCurrentThread();
  SetThreadPriority(CurrentThread, -1);
  sub_14001DF50(v1, (__int64)lpThreadParameter);
  CoUninitialize();
  return 0i64;
}

//----- (000000014001DEA0) ----------------------------------------------------
BOOL __fastcall sub_14001DEA0(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  char *v3; // rax
  HANDLE Thread; // rax
  __int64 v6; // [rsp+30h] [rbp-18h] BYREF
  int v7; // [rsp+38h] [rbp-10h]

  v1 = qword_14012E068;
  v6 = a1;
  v2 = *((_QWORD *)qword_14012E068 + 1);
  v7 = 0;
  v3 = sub_14001BDE0((__int64)qword_14012E068, v2, &v6);
  if ( qword_14012E070 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  ++qword_14012E070;
  v1[1] = v3;
  **((_QWORD **)v3 + 1) = v3;
  Thread = CreateThread(
             0i64,
             0i64,
             (LPTHREAD_START_ROUTINE)StartAddress,
             (LPVOID)(*((_QWORD *)qword_14012E068 + 1) + 16i64),
             0,
             0i64);
  return CloseHandle(Thread);
}
// 14012E070: using guessed type __int64 qword_14012E070;

//----- (000000014001DF50) ----------------------------------------------------
void __fastcall sub_14001DF50(__int64 a1, __int64 a2)
{
  bool v3; // zf
  __int64 v4; // rcx
  ITEMIDLIST *v6; // rsi
  const ITEMIDLIST *ID; // rax
  double v8; // xmm2_8
  double v9; // xmm0_8
  int v10; // ecx
  double v11; // xmm1_8
  __int64 v12; // rcx
  HWND v13; // rcx
  int v14; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v15; // [rsp+48h] [rbp-B8h] BYREF
  int v16; // [rsp+50h] [rbp-B0h] BYREF
  int v17; // [rsp+54h] [rbp-ACh]
  LPCITEMIDLIST pidl; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v19; // [rsp+60h] [rbp-A0h] BYREF
  IShellFolder *ppshf; // [rsp+68h] [rbp-98h] BYREF
  char v21[8]; // [rsp+70h] [rbp-90h] BYREF
  LPVOID v22; // [rsp+78h] [rbp-88h] BYREF
  HANDLE h; // [rsp+80h] [rbp-80h] BYREF
  char pv[4]; // [rsp+88h] [rbp-78h] BYREF
  int v25; // [rsp+8Ch] [rbp-74h]
  int v26; // [rsp+90h] [rbp-70h]
  struct tagRECT Rect; // [rsp+A8h] [rbp-58h] BYREF
  char v28[528]; // [rsp+C0h] [rbp-40h] BYREF

  *(_DWORD *)(a1 + 668) = 1;
  *(_DWORD *)(a1 + 672) = 1;
  v3 = a1 == -72;
  v4 = a1 + 72;
  v15 = 0i64;
  ppshf = 0i64;
  v19 = 0i64;
  pidl = 0i64;
  v22 = 0i64;
  if ( !v3 && (int)sub_14007F810(v4, (__int64)&pidl) >= 0 )
  {
    v6 = ILClone(pidl);
    ILRemoveLastID(v6);
    ID = ILFindLastID(pidl);
    v22 = ILClone(ID);
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      if ( ((int (__fastcall *)(IShellFolder *, ITEMIDLIST *, _QWORD, const IID *, __int64 *))ppshf->lpVtbl->BindToObject)(
             ppshf,
             v6,
             0i64,
             &stru_1400E3FB0,
             &v19) >= 0 )
      {
        if ( (*(int (__fastcall **)(__int64, _QWORD, __int64, LPVOID *, void *, _QWORD, __int64 *))(*(_QWORD *)v19
                                                                                                  + 80i64))(
               v19,
               0i64,
               1i64,
               &v22,
               &unk_1400E4060,
               0i64,
               &v15) >= 0 )
        {
          GetClientRect(*(HWND *)(a1 + 16), &Rect);
          v14 = 584;
          v16 = Rect.bottom - Rect.top - 20;
          v17 = v16;
          if ( (*(int (__fastcall **)(__int64, char *, __int64, char *, int *, int, int *))(*(_QWORD *)v15 + 24i64))(
                 v15,
                 v28,
                 260i64,
                 v21,
                 &v16,
                 32,
                 &v14) >= 0
            && (*(int (__fastcall **)(__int64, HANDLE *))(*(_QWORD *)v15 + 32i64))(v15, &h) >= 0 )
          {
            GetObjectW(h, 32, pv);
            DeleteObject(h);
            v8 = (double)v25;
            v9 = (double)v26;
            v10 = Rect.bottom - Rect.top - 20;
            v14 = 588;
            v17 = v10;
            *(_DWORD *)(a1 + 608) = v10;
            v11 = (double)v10;
            v12 = v15;
            v16 = (int)(v8 / v9 * v11);
            *(_DWORD *)(a1 + 604) = v16;
            (*(void (__fastcall **)(__int64, char *, __int64, char *, int *, int, int *))(*(_QWORD *)v12 + 24i64))(
              v12,
              v28,
              260i64,
              v21,
              &v16,
              32,
              &v14);
            if ( (*(int (__fastcall **)(__int64, __int64))(*(_QWORD *)v15 + 32i64))(v15, a1 + 656) < 0 )
            {
              *(_DWORD *)(a1 + 672) = 1;
              *(_QWORD *)(a1 + 656) = 0i64;
            }
            else
            {
              EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 616));
              if ( !*(_DWORD *)(a2 + 8) )
              {
                v13 = *(HWND *)(a1 + 16);
                *(_DWORD *)(a1 + 672) = 0;
                InvalidateRect(v13, 0i64, 0);
              }
              LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 616));
            }
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
      }
      ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    }
    CoTaskMemFree((LPVOID)pidl);
    CoTaskMemFree(v6);
    CoTaskMemFree(v22);
  }
}
// 14001DF50: using guessed type char var_280[8];
// 14001DF50: using guessed type char pv[4];

//----- (000000014001E270) ----------------------------------------------------
__int64 __fastcall sub_14001E270(__int64 a1, HDC a2, LONG a3)
{
  int v6; // er13
  LONG v7; // edi
  __int64 v8; // rcx
  unsigned __int64 v9; // r12
  const WCHAR *v10; // rbx
  int v11; // eax
  int v12; // er11
  LONG cx; // ecx
  __int64 v14; // rcx
  const WCHAR *v15; // rbx
  int v16; // eax
  __int64 result; // rax
  unsigned int v18; // [rsp+30h] [rbp-78h]
  struct tagSIZE psizl; // [rsp+38h] [rbp-70h] BYREF
  struct tagRECT rc; // [rsp+40h] [rbp-68h] BYREF
  struct tagRECT Rect; // [rsp+50h] [rbp-58h] BYREF

  v6 = 0;
  v7 = 0;
  SelectObject(a2, *(HGDIOBJ *)(a1 + 824));
  SetBkMode(a2, 1);
  SetTextColor(a2, *(_DWORD *)(a1 + 24));
  GetClientRect(*(HWND *)(a1 + 16), &Rect);
  v8 = *(_QWORD *)(a1 + 40);
  v18 = 0;
  if ( (*(_QWORD *)(a1 + 48) - v8) >> 10 )
  {
    v9 = 0i64;
    do
    {
      v10 = (const WCHAR *)((v9 << 10) + v8);
      v11 = lstrlenW(v10);
      GetTextExtentPoint32W(a2, v10, v11, &psizl);
      v12 = *(_DWORD *)(a1 + 28);
      if ( (int)abs32(v12 + psizl.cy * (v6 + 1) - Rect.bottom) < 10 )
      {
        a3 += v7 + 50;
        v7 = 0;
        v6 = 0;
      }
      rc.left = a3;
      cx = psizl.cx;
      if ( v7 > psizl.cx )
        cx = v7;
      v7 = cx;
      rc.right = psizl.cx + a3;
      v14 = *(_QWORD *)(a1 + 40);
      rc.top = v12 + v6 * psizl.cy;
      rc.bottom = rc.top + psizl.cy;
      if ( (*(_QWORD *)(a1 + 48) - v14) >> 10 <= v9 )
        sub_14002B630("invalid vector<T> subscript");
      v15 = (const WCHAR *)((v9 << 10) + v14);
      SelectObject(a2, *(HGDIOBJ *)(a1 + 824));
      SetBkMode(a2, 1);
      SetTextColor(a2, *(_DWORD *)(a1 + 24));
      v16 = lstrlenW(v15);
      DrawTextW(a2, v15, v16, &rc, 0x800u);
      v8 = *(_QWORD *)(a1 + 40);
      ++v6;
      v9 = ++v18;
    }
    while ( (*(_QWORD *)(a1 + 48) - v8) >> 10 > (unsigned __int64)v18 );
  }
  result = (unsigned int)(a3 + v7 + 50);
  *(_DWORD *)(a1 + 676) = result;
  return result;
}
// 14001E2FA: conditional instruction was optimized away because rax.8!=0

//----- (000000014001E460) ----------------------------------------------------
__int64 __fastcall sub_14001E460(__int64 a1, int a2)
{
  int v2; // ebx
  int v4; // esi
  HWND Parent; // rax
  HWND v7; // rcx
  WPARAM v8; // rbx
  HWND v9; // rax
  HCURSOR CursorW; // rax
  HCURSOR v11; // rax
  POINT pt; // [rsp+30h] [rbp-48h]
  struct tagRECT Rect; // [rsp+38h] [rbp-40h] BYREF
  struct tagRECT rc; // [rsp+48h] [rbp-30h] BYREF
  struct tagRECT v15; // [rsp+58h] [rbp-20h] BYREF

  v2 = (__int16)a2;
  v4 = SHIWORD(a2);
  pt.x = (__int16)a2;
  pt.y = SHIWORD(a2);
  GetClientRect(*(HWND *)(a1 + 16), &Rect);
  Parent = GetParent(*(HWND *)(a1 + 16));
  GetClientRect(Parent, &v15);
  if ( *(_DWORD *)(a1 + 592) )
  {
    if ( dword_14012E650 == v2 && dword_14012E654 == v4 )
      return 0i64;
    v7 = *(HWND *)(a1 + 16);
    dword_14012E650 = v2;
    dword_14012E654 = v4;
    v8 = Rect.bottom - v4;
    v9 = GetParent(v7);
    SendMessageW(v9, 0x8064u, v8, 0i64);
  }
  if ( v4 <= Rect.top + 5 )
  {
    CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F85);
    SetCursor(CursorW);
  }
  if ( *(_DWORD *)(a1 + 664) )
  {
    SetRect(&rc, *(_DWORD *)(a1 + 676), 10, *(_DWORD *)(a1 + 676) + *(_DWORD *)(a1 + 604), *(_DWORD *)(a1 + 608) + 10);
    if ( PtInRect(&rc, pt) )
    {
      v11 = LoadCursorW(0i64, (LPCWSTR)0x7F89);
      SetCursor(v11);
    }
  }
  return 1i64;
}
// 14012E650: using guessed type int dword_14012E650;
// 14012E654: using guessed type int dword_14012E654;

//----- (000000014001E5C0) ----------------------------------------------------
unsigned int __fastcall sub_14001E5C0(__int64 a1, int a2)
{
  int v3; // ebx
  unsigned int result; // eax
  HCURSOR CursorW; // rax
  HWND v6; // rcx
  HCURSOR v7; // rax
  POINT pt; // [rsp+30h] [rbp-38h]
  struct tagRECT Rect; // [rsp+38h] [rbp-30h] BYREF
  struct tagRECT rc; // [rsp+48h] [rbp-20h] BYREF

  v3 = SHIWORD(a2);
  pt.x = (__int16)a2;
  pt.y = SHIWORD(a2);
  result = GetClientRect(*(HWND *)(a1 + 16), &Rect);
  if ( v3 <= Rect.top + 5 )
  {
    CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F85);
    SetCursor(CursorW);
    v6 = *(HWND *)(a1 + 16);
    *(_DWORD *)(a1 + 592) = 1;
    SetFocus(v6);
    result = (unsigned int)SetCapture(*(HWND *)(a1 + 16));
  }
  if ( *(_DWORD *)(a1 + 664) )
  {
    SetRect(&rc, *(_DWORD *)(a1 + 676), 10, *(_DWORD *)(a1 + 676) + *(_DWORD *)(a1 + 604), *(_DWORD *)(a1 + 608) + 10);
    result = PtInRect(&rc, pt);
    if ( result )
    {
      v7 = LoadCursorW(0i64, (LPCWSTR)0x7F89);
      SetCursor(v7);
      return (unsigned int)ShellExecuteW(*(HWND *)(a1 + 16), L"open", (LPCWSTR)(a1 + 72), 0i64, 0i64, 5);
    }
  }
  return result;
}

//----- (000000014001E6F0) ----------------------------------------------------
LRESULT __fastcall sub_14001E6F0(__int64 a1, WPARAM a2, LPARAM a3)
{
  BOOL v6; // eax
  HWND v7; // rcx
  HWND Parent; // rax
  UINT v9; // edx
  POINT pt; // [rsp+20h] [rbp-38h]
  RECT rc; // [rsp+28h] [rbp-30h] BYREF

  pt.x = (__int16)a3;
  rc.left = 20;
  rc.top = 20;
  rc.right = 68;
  pt.y = SWORD1(a3);
  rc.bottom = 68;
  v6 = PtInRect(&rc, pt);
  v7 = *(HWND *)(a1 + 16);
  if ( v6 )
  {
    Parent = GetParent(v7);
    v9 = 32869;
  }
  else
  {
    Parent = GetParent(v7);
    v9 = 32870;
  }
  return SendMessageW(Parent, v9, a2, a3);
}

//----- (000000014001E7A0) ----------------------------------------------------
void __fastcall sub_14001E7A0(__int64 a1, __int64 a2, int a3)
{
  _DWORD *i; // rax
  void *v6; // rcx
  _WORD *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int16 v10; // ax

  *(_DWORD *)(a1 + 664) = a3;
  if ( a3 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 616));
    for ( i = *(_DWORD **)qword_14012E068; i != qword_14012E068; i = *(_DWORD **)i )
      i[6] = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 616));
    v6 = *(void **)(a1 + 656);
    if ( v6 )
      DeleteObject(v6);
    v7 = (_WORD *)(a1 + 72);
    v8 = 260i64;
    v9 = a2 - (a1 + 72);
    *(_QWORD *)(a1 + 604) = 0i64;
    *(_QWORD *)(a1 + 668) = 0i64;
    while ( v8 != -2147483386 )
    {
      v10 = *(_WORD *)((char *)v7 + v9);
      if ( !v10 )
        break;
      *v7++ = v10;
      if ( !--v8 )
      {
        *(v7 - 1) = 0;
        return;
      }
    }
    *v7 = 0;
  }
}
// 14001E877: conditional instruction was optimized away because rdx.8!=0

//----- (000000014001E890) ----------------------------------------------------
BOOL __fastcall sub_14001E890(__int64 a1, int a2)
{
  HDC DC; // rdi
  struct tagRECT rc; // [rsp+30h] [rbp-28h] BYREF

  DC = GetDC(*(HWND *)(a1 + 16));
  SetRect(&rc, 0, 0, (unsigned __int16)a2, HIWORD(a2));
  sub_14001DA00(a1, DC, &rc);
  ReleaseDC(*(HWND *)(a1 + 16), DC);
  return RedrawWindow(*(HWND *)(a1 + 16), 0i64, 0i64, 1u);
}

//----- (000000014001E940) ----------------------------------------------------
void **sub_14001E940()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  qword_14012E070 = 0i64;
  v0 = operator new(0x20ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012E068 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012E068 + 1) = qword_14012E068;
  return &qword_14012E068;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012E070: using guessed type __int64 qword_14012E070;

//----- (000000014001E9C0) ----------------------------------------------------
__int64 __fastcall sub_14001E9C0(__int64 a1, __int64 a2, int *a3)
{
  int PathGradientPointCount; // eax
  unsigned __int64 v7; // rcx
  void *v8; // rax
  void *v9; // rbp
  __int64 result; // rax
  int v11; // edx
  _DWORD *v12; // rcx
  __int64 v13; // rdi
  int v14; // eax
  int v15; // eax
  int v16; // [rsp+48h] [rbp+10h] BYREF
  int v17; // [rsp+58h] [rbp+20h] BYREF

  if ( a2 && a3 )
  {
    PathGradientPointCount = GdipGetPathGradientPointCount(*(_QWORD *)(a1 + 8), &v17);
    if ( PathGradientPointCount )
      *(_DWORD *)(a1 + 16) = PathGradientPointCount;
    v7 = *a3;
    if ( (int)v7 > v17 || v17 <= 0 )
    {
      *(_DWORD *)(a1 + 16) = 2;
      return 2i64;
    }
    else
    {
      v16 = *a3;
      v8 = operator new(saturated_mul(v7, 4ui64));
      v9 = v8;
      if ( v8 )
      {
        v11 = 0;
        if ( v16 > 0 )
        {
          v12 = v8;
          v13 = a2 - (_QWORD)v8;
          do
          {
            v14 = *(_DWORD *)((char *)v12 + v13);
            ++v11;
            *v12++ = v14;
          }
          while ( v11 < v16 );
        }
        v15 = GdipSetPathGradientSurroundColorsWithCount(*(_QWORD *)(a1 + 8), v9, &v16);
        if ( v15 )
          *(_DWORD *)(a1 + 16) = v15;
        if ( !*(_DWORD *)(a1 + 16) )
          *a3 = v16;
        j_free(v9);
        return *(unsigned int *)(a1 + 16);
      }
      else
      {
        result = 3i64;
        *(_DWORD *)(a1 + 16) = 3;
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 2;
    return 2i64;
  }
  return result;
}
// 1400E3CA8: using guessed type __int64 __fastcall GdipGetPathGradientPointCount(_QWORD, _QWORD);
// 1400E3CB0: using guessed type __int64 __fastcall GdipSetPathGradientSurroundColorsWithCount(_QWORD, _QWORD, _QWORD);

//----- (000000014001EB10) ----------------------------------------------------
_QWORD *__fastcall sub_14001EB10(_QWORD *a1, char a2)
{
  *a1 = &Gdiplus::Brush::`vftable';
  GdipDeleteBrush(a1[1]);
  if ( (a2 & 1) != 0 )
    GdipFree(a1);
  return a1;
}
// 1400E3D08: using guessed type __int64 __fastcall GdipDeleteBrush(_QWORD);
// 1400E3D90: using guessed type __int64 __fastcall GdipFree(_QWORD);
// 1400F7B48: using guessed type void *Gdiplus::Brush::`vftable';

//----- (000000014001EB60) ----------------------------------------------------
ATOM sub_14001EB60()
{
  WNDCLASSW WndClass; // [rsp+20h] [rbp-58h] BYREF

  WndClass.lpfnWndProc = (WNDPROC)sub_14001EBE0;
  WndClass.style = 0;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 8;
  WndClass.hIcon = 0i64;
  WndClass.hInstance = GetModuleHandleW(0i64);
  WndClass.hCursor = LoadCursorW(0i64, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = GetSysColorBrush(15);
  WndClass.lpszMenuName = 0i64;
  WndClass.lpszClassName = L"Holder";
  return RegisterClassW(&WndClass);
}

//----- (000000014001EBE0) ----------------------------------------------------
LRESULT __fastcall sub_14001EBE0(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  _DWORD *WindowLongPtrW; // rbx
  _DWORD *v10; // rax
  struct _OSVERSIONINFOW VersionInformation; // [rsp+30h] [rbp-158h] BYREF

  WindowLongPtrW = (_DWORD *)GetWindowLongPtrW(hWnd, -21);
  if ( a2 == 1 )
  {
    v10 = operator new(0x10ui64);
    WindowLongPtrW = v10;
    if ( v10 )
    {
      *(_QWORD *)v10 = hWnd;
      v10[3] = 0;
      VersionInformation.dwOSVersionInfoSize = 276;
      if ( GetVersionExW(&VersionInformation) )
        WindowLongPtrW[2] = VersionInformation.dwMajorVersion;
    }
    else
    {
      WindowLongPtrW = 0i64;
    }
    SetWindowLongPtrW(hWnd, -21, (LONG_PTR)WindowLongPtrW);
    return sub_14001ECC0((__int64)WindowLongPtrW, hWnd, a2, a3, a4);
  }
  if ( a2 != 2 )
    return sub_14001ECC0((__int64)WindowLongPtrW, hWnd, a2, a3, a4);
  if ( WindowLongPtrW )
  {
    WindowLongPtrW[3] = 0;
    j_free(WindowLongPtrW);
  }
  return 0i64;
}

//----- (000000014001ECC0) ----------------------------------------------------
LRESULT __fastcall sub_14001ECC0(__int64 a1, HWND a2, UINT a3, WPARAM a4, LPARAM a5)
{
  switch ( a3 )
  {
    case 0xFu:
      sub_14001ED50(a2);
      break;
    case 0x200u:
      return (int)sub_14001EF00(a1, a5);
    case 0x201u:
      sub_14001EE70(a1, a5);
      break;
    case 0x202u:
      *(_DWORD *)(a1 + 12) = 0;
      ReleaseCapture();
      break;
  }
  return DefWindowProcW(a2, a3, a4, a5);
}

//----- (000000014001ED50) ----------------------------------------------------
BOOL __fastcall sub_14001ED50(HWND hWnd)
{
  HDC v2; // rax
  HDC v3; // rdi
  HFONT v4; // rbx
  int c; // eax
  struct tagRECT Rect; // [rsp+30h] [rbp-2F8h] BYREF
  struct tagPAINTSTRUCT Paint; // [rsp+40h] [rbp-2E8h] BYREF
  int pvParam[31]; // [rsp+90h] [rbp-298h] BYREF
  LOGFONTW lf; // [rsp+10Ch] [rbp-21Ch] BYREF
  WCHAR String[64]; // [rsp+290h] [rbp-98h] BYREF

  GetClientRect(hWnd, &Rect);
  v2 = BeginPaint(hWnd, &Paint);
  pvParam[0] = 500;
  v3 = v2;
  SystemParametersInfoW(0x29u, 0x1F4u, pvParam, 0);
  lf.lfWeight = 400;
  v4 = CreateFontIndirectW(&lf);
  SelectObject(v3, v4);
  GetWindowTextW(hWnd, String, 64);
  SetBkMode(v3, 1);
  c = lstrlenW(String);
  TextOutW(v3, 5, 2, String, c);
  DeleteObject(v4);
  return EndPaint(hWnd, &Paint);
}
// 14001ED50: using guessed type int pvParam[31];

//----- (000000014001EE70) ----------------------------------------------------
HWND __fastcall sub_14001EE70(__int64 a1, __int16 a2)
{
  HWND result; // rax
  HCURSOR CursorW; // rax
  HWND v6; // rcx
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetClientRect(*(HWND *)a1, &Rect);
  result = (HWND)(unsigned int)a2;
  if ( (int)result >= Rect.right - 10 )
  {
    CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F84);
    SetCursor(CursorW);
    v6 = *(HWND *)a1;
    *(_DWORD *)(a1 + 12) = 1;
    SetFocus(v6);
    return SetCapture(*(HWND *)a1);
  }
  return result;
}

//----- (000000014001EF00) ----------------------------------------------------
__int64 __fastcall sub_14001EF00(__int64 a1, int a2)
{
  HWND v4; // rdi
  HWND Parent; // rax
  HCURSOR CursorW; // rax
  struct tagRECT Rect; // [rsp+28h] [rbp-20h] BYREF

  GetClientRect(*(HWND *)a1, &Rect);
  if ( *(_DWORD *)(a1 + 12) )
  {
    if ( dword_14012E648 != a2 )
    {
      v4 = *(HWND *)a1;
      dword_14012E648 = a2;
      Parent = GetParent(v4);
      SendMessageW(Parent, 0x812Cu, (WPARAM)v4, (__int16)a2);
      return 1i64;
    }
  }
  else if ( (__int16)a2 >= Rect.right - 10 )
  {
    CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F84);
    SetCursor(CursorW);
  }
  return 0i64;
}
// 14012E648: using guessed type int dword_14012E648;

//----- (000000014001EFD0) ----------------------------------------------------
LPVOID __fastcall sub_14001EFD0(LPVOID lpParameter, HWND hWnd, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD *v9; // rax
  void *v10; // rbx
  HANDLE Thread; // rax
  char *v13[2]; // [rsp+30h] [rbp-318h] BYREF
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-308h] BYREF
  SHFILEINFOW psfi; // [rsp+60h] [rbp-2E8h] BYREF

  pExceptionObject[3] = -2i64;
  v13[1] = (char *)lpParameter;
  *(_QWORD *)lpParameter = &CMyTreeView::`vftable';
  *((_QWORD *)lpParameter + 1) = &CMyTreeView::`vftable';
  sub_140022350((_QWORD *)lpParameter + 88);
  sub_140022350((_QWORD *)lpParameter + 91);
  *((_QWORD *)lpParameter + 165) = 0i64;
  v9 = operator new(0x228ui64);
  if ( !v9 )
  {
    v13[0] = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v13);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *((_QWORD *)lpParameter + 164) = v9;
  *v9 = v9;
  *(_QWORD *)(*((_QWORD *)lpParameter + 164) + 8i64) = *((_QWORD *)lpParameter + 164);
  *((_QWORD *)lpParameter + 3) = hWnd;
  *((_QWORD *)lpParameter + 4) = a3;
  SetWindowSubclass(hWnd, (SUBCLASSPROC)pfnSubclass, 0i64, (DWORD_PTR)lpParameter);
  InitializeCriticalSection((LPCRITICAL_SECTION)((char *)lpParameter + 752));
  InitializeCriticalSection((LPCRITICAL_SECTION)((char *)lpParameter + 584));
  InitializeCriticalSection(&CriticalSection);
  *((_QWORD *)lpParameter + 78) = a5;
  *((_QWORD *)lpParameter + 6) = a4;
  v10 = malloc(0x190ui64);
  *((_QWORD *)lpParameter + 79) = v10;
  *((_QWORD *)lpParameter + 80) = malloc(0x640ui64);
  *((_DWORD *)lpParameter + 162) = 100;
  memset(v10, 0, 0x190ui64);
  SHGetFileInfoW(L"dummy", 0x90u, &psfi, 0x2B8u, 0x4010u);
  *((_DWORD *)lpParameter + 163) = psfi.iIcon;
  sub_14001F680((__int64)lpParameter);
  *((_QWORD *)lpParameter + 85) = 0i64;
  *((_DWORD *)lpParameter + 172) = 0;
  *((_DWORD *)lpParameter + 145) = 1;
  if ( CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)lpParameter + 82) >= 0 )
  {
    (***((void (__fastcall ****)(_QWORD, void *, char *))lpParameter + 82))(
      *((_QWORD *)lpParameter + 82),
      &unk_1400E4040,
      (char *)lpParameter + 664);
    RegisterDragDrop(*((HWND *)lpParameter + 3), (LPDROPTARGET)lpParameter);
  }
  *((_DWORD *)lpParameter + 334) = 0;
  Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_140021B50, lpParameter, 0, 0i64);
  CloseHandle(Thread);
  *((_DWORD *)lpParameter + 4) = 0;
  return lpParameter;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F7D78: using guessed type void *CMyTreeView::`vftable';
// 1400F7DB8: using guessed type void *CMyTreeView::`vftable';

//----- (000000014001F240) ----------------------------------------------------
void __fastcall sub_14001F240(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  _QWORD **v5; // rax
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD **v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rbx

  *(_QWORD *)a1 = &CMyTreeView::`vftable';
  *(_QWORD *)(a1 + 8) = &CMyTreeView::`vftable';
  v2 = *(_QWORD ***)(a1 + 1312);
  v3 = *v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 1312) + 8i64) = *(_QWORD *)(a1 + 1312);
  *(_QWORD *)(a1 + 1320) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 1312) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 1312) );
  }
  j_free(*(void **)(a1 + 1312));
  v5 = *(_QWORD ***)(a1 + 728);
  v6 = *v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 728) + 8i64) = *(_QWORD *)(a1 + 728);
  *(_QWORD *)(a1 + 736) = 0i64;
  if ( v6 != *(_QWORD **)(a1 + 728) )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *(_QWORD **)(a1 + 728) );
  }
  j_free(*(void **)(a1 + 728));
  v8 = *(_QWORD ***)(a1 + 704);
  v9 = *v8;
  *v8 = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8i64) = *(_QWORD *)(a1 + 704);
  *(_QWORD *)(a1 + 712) = 0i64;
  if ( v9 != *(_QWORD **)(a1 + 704) )
  {
    do
    {
      v10 = (_QWORD *)*v9;
      j_free(v9);
      v9 = v10;
    }
    while ( v10 != *(_QWORD **)(a1 + 704) );
  }
  j_free(*(void **)(a1 + 704));
}
// 1400F7D78: using guessed type void *CMyTreeView::`vftable';
// 1400F7DB8: using guessed type void *CMyTreeView::`vftable';

//----- (000000014001F360) ----------------------------------------------------
LRESULT __fastcall pfnSubclass(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  return sub_14001F390(dwRefData, hWnd, uMsg, wParam, lParam);
}

//----- (000000014001F390) ----------------------------------------------------
__int64 __fastcall sub_14001F390(ULONG_PTR dwData, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM a5)
{
  int v9; // ecx
  HCURSOR v11; // rax
  HCURSOR CursorW; // rax
  DWORD MessagePos; // eax
  HWND v14; // rdx
  HWND v15; // rcx
  HWND v16; // rcx
  HWND v17; // rcx
  struct tagPOINT Points; // [rsp+20h] [rbp-68h] BYREF
  LPARAM lParam; // [rsp+28h] [rbp-60h] BYREF
  char v20; // [rsp+30h] [rbp-58h]
  LPARAM v21; // [rsp+38h] [rbp-50h]
  LPARAM v22[6]; // [rsp+40h] [rbp-48h] BYREF
  int v23; // [rsp+70h] [rbp-18h]

  if ( uMsg > 0x200 )
  {
    switch ( uMsg )
    {
      case 0x204u:
        if ( (wParam & 2) != 0 && (wParam & 1) == 0 && (wParam & 0x10) == 0 )
        {
          v17 = *(HWND *)(dwData + 24);
          LODWORD(lParam) = (unsigned __int16)a5;
          HIDWORD(lParam) = WORD1(a5);
          SendMessageW(v17, 0x1111u, 0i64, (LPARAM)&lParam);
          if ( (v20 & 1) == 0 )
            *(_DWORD *)(dwData + 688) = 1;
        }
        break;
      case 0x205u:
        *(_QWORD *)(dwData + 684) = 0i64;
        break;
      case 0x219u:
        return sub_1400217C0(dwData, wParam, a5);
    }
    return DefSubclassProc(hWnd, uMsg, wParam, a5);
  }
  switch ( uMsg )
  {
    case 0x200u:
      if ( !*(_DWORD *)(dwData + 680) && !*(_DWORD *)(dwData + 684) )
      {
        if ( *(_DWORD *)(dwData + 688) )
        {
          if ( (wParam & 2) != 0 && (wParam & 1) == 0 && (wParam & 0x10) == 0 )
          {
            MessagePos = GetMessagePos();
            v14 = *(HWND *)(dwData + 24);
            Points.x = (__int16)MessagePos;
            Points.y = SHIWORD(MessagePos);
            MapWindowPoints(0i64, v14, &Points, 1u);
            v15 = *(HWND *)(dwData + 24);
            lParam = (LPARAM)Points;
            SendMessageW(v15, 0x1111u, 0i64, (LPARAM)&lParam);
            if ( (v20 & 1) == 0 )
            {
              v16 = *(HWND *)(dwData + 24);
              v22[1] = v21;
              LODWORD(v22[0]) = 20;
              if ( (unsigned int)SendMessageW(v16, 0x113Eu, 0i64, (LPARAM)v22) )
              {
                if ( sub_140022190(dwData, v23, 1) == 262401 )
                  *(_DWORD *)(dwData + 684) = 1;
              }
            }
          }
        }
      }
      return DefSubclassProc(hWnd, uMsg, wParam, a5);
    case 7u:
      SendMessageW(*(HWND *)(dwData + 32), 0x8048u, 0i64, 0i64);
      return DefSubclassProc(hWnd, uMsg, wParam, a5);
    case 0x20u:
      if ( *(int *)(dwData + 16) <= 0 )
      {
        CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F00);
        SetCursor(CursorW);
        return 0i64;
      }
      else
      {
        v11 = LoadCursorW(0i64, (LPCWSTR)0x7F8A);
        SetCursor(v11);
        return 1i64;
      }
  }
  if ( uMsg != 78 )
  {
    if ( uMsg == 275 )
      sub_140022970(dwData);
    return DefSubclassProc(hWnd, uMsg, wParam, a5);
  }
  v9 = *(_DWORD *)(a5 + 16);
  if ( v9 == -456 )
  {
    sub_140022190(dwData, *(_DWORD *)(a5 + 136), 0);
    return 0i64;
  }
  if ( v9 != -452 )
    return 0i64;
  if ( (*(_BYTE *)(a5 + 24) & 2) != 0 )
  {
    *(_DWORD *)(a5 + 60) = *(_DWORD *)(dwData + 652);
    *(_DWORD *)(a5 + 64) = *(_DWORD *)(dwData + 652);
    sub_14001F970(dwData, a5 + 24);
  }
  *(_DWORD *)(a5 + 24) |= 0x1000u;
  return 0i64;
}

//----- (000000014001F680) ----------------------------------------------------
__int64 __fastcall sub_14001F680(__int64 a1)
{
  HWND v2; // rcx
  __int64 v3; // rbx
  LPITEMIDLIST v4; // rax
  __int64 v5; // rcx
  int v6; // eax
  HWND v7; // rcx
  __int64 v8; // rbx
  LPITEMIDLIST ppidl; // [rsp+30h] [rbp-D0h] BYREF
  LPVOID pv; // [rsp+38h] [rbp-C8h] BYREF
  IShellFolder *ppshf; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v13; // [rsp+50h] [rbp-B0h]
  __int128 v14; // [rsp+60h] [rbp-A0h]
  __int128 v15; // [rsp+70h] [rbp-90h]
  __int128 v16; // [rsp+80h] [rbp-80h]
  __int128 v17; // [rsp+90h] [rbp-70h]
  LPARAM lParam[2]; // [rsp+A0h] [rbp-60h] BYREF
  __int128 v19; // [rsp+B0h] [rbp-50h]
  __int128 v20; // [rsp+C0h] [rbp-40h]
  __int128 v21; // [rsp+D0h] [rbp-30h]
  __int128 v22; // [rsp+E0h] [rbp-20h]
  __int128 v23; // [rsp+F0h] [rbp-10h]
  SHFILEINFOW psfi; // [rsp+100h] [rbp+0h] BYREF
  WCHAR String[264]; // [rsp+3C0h] [rbp+2C0h] BYREF
  WCHAR pszBuf[264]; // [rsp+5D0h] [rbp+4D0h] BYREF

  v2 = *(HWND *)(a1 + 24);
  ppshf = 0i64;
  ppidl = 0i64;
  SendMessageW(v2, 0x1101u, 0i64, -65536i64);
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) < 0 )
    return 0i64;
  sub_14007E090(0, pszBuf);
  pv = 0i64;
  if ( (int)sub_14007F810((__int64)pszBuf, (__int64)&pv) >= 0 )
    sub_14007E270((LPCITEMIDLIST)pv, String, 1u);
  CoTaskMemFree(pv);
  SHGetFileInfoW(&ppidl->mkid.cb, 0, &psfi, 0, 0x4008u);
  v3 = (int)sub_1400204F0(a1);
  v4 = ILClone(ppidl);
  v5 = *(_QWORD *)(a1 + 640);
  LODWORD(v13) = 103;
  *(_QWORD *)(v5 + 16 * v3) = v4;
  *(_DWORD *)(*(_QWORD *)(a1 + 632) + 4 * v3) = 1;
  *((_QWORD *)&v14 + 1) = String;
  v6 = lstrlenW(String);
  v7 = *(HWND *)(a1 + 24);
  *(_QWORD *)&v15 = __PAIR64__(psfi.iIcon, v6);
  v19 = v13;
  v20 = v14;
  *((_QWORD *)&v15 + 1) = (unsigned int)psfi.iIcon | 0x100000000i64;
  *(_QWORD *)&v16 = v3;
  v21 = v15;
  v22 = v16;
  lParam[0] = 0i64;
  lParam[1] = -65534i64;
  v23 = v17;
  v8 = SendMessageW(v7, 0x1132u, 0i64, (LPARAM)lParam);
  if ( v8 )
  {
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      sub_14001FE90(a1, (__int64)ppshf, ppidl, v8);
      SendMessageW(*(HWND *)(a1 + 24), 0x1102u, 2ui64, v8);
      ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    }
  }
  CoTaskMemFree(ppidl);
  return v8;
}

//----- (000000014001F8B0) ----------------------------------------------------
HRESULT __fastcall sub_14001F8B0(__int64 a1, __int64 a2, const ITEMIDLIST *a3)
{
  HRESULT result; // eax
  HRESULT v7; // eax
  HRESULT v8; // ebx
  IShellFolder *ppshf; // [rsp+30h] [rbp-18h] BYREF
  IShellFolder *v10; // [rsp+68h] [rbp+20h] BYREF

  ppshf = 0i64;
  v10 = 0i64;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    if ( (unsigned int)sub_14007DF90((__int64)a3) )
      v7 = SHGetDesktopFolder(&v10);
    else
      v7 = ((__int64 (__fastcall *)(IShellFolder *, const ITEMIDLIST *, _QWORD, const IID *, IShellFolder **))ppshf->lpVtbl->BindToObject)(
             ppshf,
             a3,
             0i64,
             &stru_1400E3FB0,
             &v10);
    v8 = v7;
    if ( v7 >= 0 )
    {
      sub_14001FE90(a1, (__int64)v10, a3, a2);
      ((void (__fastcall *)(IShellFolder *))v10->lpVtbl->Release)(v10);
    }
    ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    return v8;
  }
  return result;
}

//----- (000000014001F970) ----------------------------------------------------
void __fastcall sub_14001F970(ULONG_PTR dwData, __int64 a2)
{
  HWND v4; // rax
  LPITEMIDLIST v5; // rax
  _QWORD *v6; // rbx
  __int64 v7; // rdx
  char *v8; // rax
  void *v9; // rdx
  HWND v10[4]; // [rsp+20h] [rbp-78h] BYREF
  LPARAM lParam[6]; // [rsp+40h] [rbp-58h] BYREF
  int v12; // [rsp+70h] [rbp-28h]

  EnterCriticalSection(&CriticalSection);
  v4 = *(HWND *)(a2 + 8);
  v10[0] = *(HWND *)(dwData + 24);
  v10[2] = v4;
  lParam[1] = (LPARAM)v4;
  LODWORD(lParam[0]) = 20;
  SendMessageW(v10[0], 0x113Eu, 0i64, (LPARAM)lParam);
  v5 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(dwData + 640) + 16i64 * v12));
  v6 = qword_14012E080;
  v7 = *((_QWORD *)qword_14012E080 + 1);
  v10[1] = (HWND)v5;
  v8 = sub_14001A860((__int64)qword_14012E080, v7, v10);
  if ( qword_14012E088 == 0xAAAAAAAAAAAAAA9i64 )
    sub_14002B5F8("list<T> too long");
  ++qword_14012E088;
  v6[1] = v8;
  **((_QWORD **)v8 + 1) = v8;
  if ( dword_14012DC38 == dword_14012DC3C )
  {
    v9 = *(void **)(dwData + 624);
    ++dword_14012DC3C;
    QueueUserAPC((PAPCFUNC)pfnAPC, v9, dwData);
  }
  LeaveCriticalSection(&CriticalSection);
}
// 14012DC38: using guessed type int dword_14012DC38;
// 14012DC3C: using guessed type int dword_14012DC3C;
// 14012E088: using guessed type __int64 qword_14012E088;

//----- (000000014001FA90) ----------------------------------------------------
void __fastcall pfnAPC(ULONG_PTR Parameter)
{
  LPARAM v1; // rsi
  WCHAR *v2; // rdi
  HWND v3; // rbp
  int v4; // ebx
  void *v5; // rcx
  int v6; // ebx
  void *v7; // rcx
  LPARAM lParam[2]; // [rsp+30h] [rbp-328h] BYREF
  int v9; // [rsp+40h] [rbp-318h]
  int v10; // [rsp+44h] [rbp-314h]
  int iIcon; // [rsp+54h] [rbp-304h]
  int v12; // [rsp+58h] [rbp-300h]
  HWND hWnd; // [rsp+68h] [rbp-2F0h]
  LPCWSTR pszPath; // [rsp+70h] [rbp-2E8h]
  LPARAM v15; // [rsp+78h] [rbp-2E0h]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-2D8h] BYREF

  EnterCriticalSection(&CriticalSection);
  if ( qword_14012E088 )
  {
    v5 = (void *)*((_QWORD *)qword_14012E080 + 1);
    v3 = (HWND)*((_QWORD *)v5 + 2);
    v2 = (WCHAR *)*((_QWORD *)v5 + 3);
    v1 = *((_QWORD *)v5 + 4);
    if ( v5 != qword_14012E080 )
    {
      **((_QWORD **)v5 + 1) = *(_QWORD *)v5;
      *(_QWORD *)(*(_QWORD *)v5 + 8i64) = *((_QWORD *)v5 + 1);
      j_free(v5);
      --qword_14012E088;
    }
    v4 = 1;
  }
  else
  {
    v1 = v15;
    v2 = (WCHAR *)pszPath;
    v3 = hWnd;
    v4 = 0;
    ++dword_14012DC38;
    dword_14011D704 = 1;
  }
  LeaveCriticalSection(&CriticalSection);
  if ( v4 )
  {
    do
    {
      if ( SHGetFileInfoW(v2, 0, &psfi, 0x2B8u, 0x148u) )
      {
        LODWORD(lParam[0]) = 50;
        lParam[1] = v1;
        iIcon = psfi.iIcon;
        v12 = psfi.iIcon;
        if ( psfi.iIcon >> 24 )
        {
          LODWORD(lParam[0]) = 58;
          v10 = 3840;
          v9 = psfi.iIcon >> 24 << 8;
        }
        SendMessageW(v3, 0x113Fu, 0i64, (LPARAM)lParam);
        DestroyIcon(psfi.hIcon);
        CoTaskMemFree(v2);
      }
      EnterCriticalSection(&CriticalSection);
      if ( qword_14012E088 )
      {
        v7 = (void *)*((_QWORD *)qword_14012E080 + 1);
        v3 = (HWND)*((_QWORD *)v7 + 2);
        v2 = (WCHAR *)*((_QWORD *)v7 + 3);
        v1 = *((_QWORD *)v7 + 4);
        if ( v7 != qword_14012E080 )
        {
          **((_QWORD **)v7 + 1) = *(_QWORD *)v7;
          *(_QWORD *)(*(_QWORD *)v7 + 8i64) = *((_QWORD *)v7 + 1);
          j_free(v7);
          --qword_14012E088;
        }
        v6 = 1;
      }
      else
      {
        v6 = 0;
        ++dword_14012DC38;
        dword_14011D704 = 1;
      }
      LeaveCriticalSection(&CriticalSection);
    }
    while ( v6 );
  }
}
// 14011D704: using guessed type int dword_14011D704;
// 14012DC38: using guessed type int dword_14012DC38;
// 14012E088: using guessed type __int64 qword_14012E088;

//----- (000000014001FC90) ----------------------------------------------------
int __fastcall sub_14001FC90(int a1, int a2, __int64 a3)
{
  return sub_14001FCB0(a3, a1, a2);
}

//----- (000000014001FCB0) ----------------------------------------------------
int __fastcall sub_14001FCB0(__int64 a1, int a2, int a3)
{
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rbx
  WCHAR pszPath[264]; // [rsp+20h] [rbp-658h] BYREF
  WCHAR String2[264]; // [rsp+230h] [rbp-448h] BYREF
  WCHAR v10[264]; // [rsp+440h] [rbp-238h] BYREF

  v4 = a3;
  v5 = 2i64 * a2;
  sub_14007E270(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16i64 * a2), pszPath, 0x8000u);
  v6 = 2 * v4;
  sub_14007E270(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v6), String2, 0x8000u);
  if ( PathIsRootW(pszPath) && !PathIsRootW(String2) )
    return -1;
  if ( !PathIsRootW(pszPath) && PathIsRootW(String2) )
    return 1;
  if ( PathIsRootW(pszPath) && PathIsRootW(String2) )
    return lstrcmpiW(pszPath, String2);
  if ( !SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v5), v10)
    && SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v6), v10) )
  {
    return -1;
  }
  if ( SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v5), v10)
    && !SHGetPathFromIDListW(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v6), v10) )
  {
    return 1;
  }
  sub_14007E270(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v5), pszPath, 1u);
  sub_14007E270(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v6), String2, 1u);
  return StrCmpLogicalW(pszPath, String2);
}

//----- (000000014001FE90) ----------------------------------------------------
void __fastcall sub_14001FE90(__int64 a1, __int64 a2, const ITEMIDLIST *a3, __int64 a4)
{
  const ITEMIDLIST *v4; // rbx
  __int64 v7; // r13
  int v8; // edi
  int v9; // ebx
  __int64 v10; // r8
  int v11; // eax
  unsigned __int64 v12; // r12
  int (__fastcall *v13)(int, int, __int64); // rsi
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rdx
  char *v17; // rcx
  __int16 v18; // ax
  __int64 v19; // rbx
  char *v20; // rbx
  char *v21; // rdx
  const WCHAR *v22; // rbx
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // rbx
  __int64 v25; // rdx
  char *v26; // rbx
  unsigned __int64 v27; // rbx
  LPARAM i; // r13
  _QWORD *v29; // rax
  _QWORD *v30; // rbx
  HANDLE Thread; // rax
  LPCITEMIDLIST pidl; // [rsp+30h] [rbp-D0h] BYREF
  int v33; // [rsp+38h] [rbp-C8h] BYREF
  LPITEMIDLIST ppidl; // [rsp+40h] [rbp-C0h] BYREF
  int v35; // [rsp+48h] [rbp-B8h]
  LPARAM v36; // [rsp+50h] [rbp-B0h] BYREF
  int (__fastcall *v37)(int, int, __int64); // [rsp+58h] [rbp-A8h]
  __int64 v38; // [rsp+60h] [rbp-A0h]
  __int64 v39; // [rsp+70h] [rbp-90h] BYREF
  __int64 v40; // [rsp+78h] [rbp-88h]
  LPCITEMIDLIST v41; // [rsp+80h] [rbp-80h]
  LPITEMIDLIST v42; // [rsp+88h] [rbp-78h] BYREF
  LPCITEMIDLIST v43; // [rsp+90h] [rbp-70h]
  __int64 v44; // [rsp+98h] [rbp-68h]
  __int128 v45; // [rsp+A0h] [rbp-60h]
  __int128 v46; // [rsp+B0h] [rbp-50h]
  __int128 v47; // [rsp+C0h] [rbp-40h]
  __int128 v48; // [rsp+D0h] [rbp-30h]
  __int128 v49; // [rsp+E0h] [rbp-20h]
  __int64 v50; // [rsp+F0h] [rbp-10h]
  LPARAM lParam[2]; // [rsp+100h] [rbp+0h] BYREF
  __int128 v52; // [rsp+110h] [rbp+10h]
  __int128 v53; // [rsp+120h] [rbp+20h]
  __int128 v54; // [rsp+130h] [rbp+30h]
  __int128 v55; // [rsp+140h] [rbp+40h]
  __int128 v56; // [rsp+150h] [rbp+50h]
  STRRET pstr; // [rsp+160h] [rbp+60h] BYREF
  char Src[520]; // [rsp+270h] [rbp+170h] BYREF
  int v59; // [rsp+478h] [rbp+378h]
  WCHAR pszBuf[264]; // [rsp+480h] [rbp+380h] BYREF
  WCHAR pszPath[264]; // [rsp+690h] [rbp+590h] BYREF
  __int16 v62[264]; // [rsp+8A0h] [rbp+7A0h] BYREF

  v50 = -2i64;
  v40 = a4;
  v4 = a3;
  v41 = a3;
  v7 = 0i64;
  v39 = 0i64;
  v42 = 0i64;
  pidl = 0i64;
  v8 = !SHGetPathFromIDListW(a3, pszPath);
  v35 = v8;
  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) >= 0 )
  {
    v9 = sub_14007DCB0((__int64)v4, (__int64)ppidl);
    CoTaskMemFree(ppidl);
    if ( v9 )
      v8 = 1;
    v35 = v8;
    v4 = v41;
  }
  sub_14007E270(v4, pszPath, 0x8000u);
  sub_14007E270(v4, (LPWSTR)v62, 0x8000u);
  if ( SHGetFolderLocation(0i64, 17, 0i64, 0, &v42) >= 0 )
  {
    sub_14007DCB0((__int64)v4, (__int64)v42);
    CoTaskMemFree(v42);
  }
  SendMessageW(*(HWND *)(a1 + 24), 0xBu, 0i64, 0i64);
  v10 = 32i64;
  if ( *(_DWORD *)(a1 + 580) )
    v10 = 160i64;
  v11 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64 *))(*(_QWORD *)a2 + 32i64))(a2, 0i64, v10, &v39);
  v12 = 0i64;
  v36 = 0i64;
  v13 = 0i64;
  v37 = 0i64;
  v38 = 0i64;
  if ( v11 < 0 || !v39 )
  {
    i = v40;
    goto LABEL_56;
  }
  v33 = 1;
  v44 = v8;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)v39 + 24i64))(
         v39,
         1i64,
         &pidl,
         &v33) )
  {
    goto LABEL_51;
  }
  while ( v33 == 1 )
  {
    LODWORD(ppidl) = 1610612736;
    if ( (*(int (__fastcall **)(__int64, __int64, LPCITEMIDLIST *, LPITEMIDLIST *))(*(_QWORD *)a2 + 72i64))(
           a2,
           1i64,
           &pidl,
           &ppidl) < 0
      || ((unsigned int)ppidl & 0x20000000) == 0
      || (*(int (__fastcall **)(__int64, LPCITEMIDLIST, _QWORD, STRRET *))(*(_QWORD *)a2 + 88i64))(
           a2,
           pidl,
           0i64,
           &pstr) < 0 )
    {
      goto LABEL_49;
    }
    StrRetToBufW(&pstr, pidl, pszBuf, 0x104u);
    v43 = ILCombine(v4, pidl);
    v14 = (int)sub_1400204F0(a1);
    v15 = 2 * v14;
    *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v15) = ILClone(v43);
    *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v15 + 8) = ILClone(pidl);
    v59 = v14;
    v16 = 260i64;
    v17 = Src;
    while ( v16 != -2147483386 )
    {
      v18 = *((_WORD *)v17 + 264);
      if ( !v18 )
        break;
      *(_WORD *)v17 = v18;
      v17 += 2;
      if ( !--v16 )
      {
        v17 -= 2;
        break;
      }
    }
    *(_WORD *)v17 = 0;
    if ( !v44 )
    {
      v22 = (const WCHAR *)v13;
      if ( (__int64)((__int64)v13 - v12) / 524 )
      {
        v22 = (const WCHAR *)((char *)v13 - 524);
        if ( StrCmpLogicalW(pszBuf, (PCWSTR)v13 - 262) >= 0 )
        {
LABEL_38:
          if ( v22 == (const WCHAR *)v12 )
            goto LABEL_39;
          goto LABEL_40;
        }
        while ( v22 != (const WCHAR *)v12 )
        {
          v22 -= 262;
          if ( StrCmpLogicalW(pszBuf, v22) >= 0 )
            goto LABEL_38;
        }
LABEL_39:
        if ( StrCmpLogicalW(pszBuf, v22) > 0 )
LABEL_40:
          v22 += 262;
      }
      v23 = (__int64)((unsigned __int128)((__int64)((__int64)v22 - v12) * (__int128)0x3E88CB3C9484E2Bi64) >> 64) >> 3;
      v24 = (v23 >> 63) + v23;
      if ( v13 == (int (__fastcall *)(int, int, __int64))v7 )
      {
        sub_140022470(&v36);
        v7 = v38;
        v13 = v37;
        v12 = v36;
      }
      if ( v13 )
        memmove(v13, Src, 0x20Cui64);
      v13 = (int (__fastcall *)(int, int, __int64))((char *)v13 + 524);
      v37 = v13;
      v25 = (__int64)v13 - 524;
      v26 = (char *)(v12 + 524 * v24);
      if ( v26 != (char *)v13 - 524 && (int (__fastcall *)(int, int, __int64))v25 != v13 )
        sub_140022780(v26, v25, (char *)v13);
      goto LABEL_48;
    }
    if ( Src >= (char *)v13 || v12 > (unsigned __int64)Src )
    {
      if ( v13 == (int (__fastcall *)(int, int, __int64))v7 )
      {
        sub_140022470(&v36);
        v7 = v38;
        v13 = v37;
        v12 = v36;
      }
      if ( !v13 )
        goto LABEL_33;
      v21 = Src;
    }
    else
    {
      v19 = (__int64)&Src[-v12] / 524;
      if ( v13 == (int (__fastcall *)(int, int, __int64))v7 )
      {
        sub_140022470(&v36);
        v7 = v38;
        v13 = v37;
        v12 = v36;
      }
      v20 = (char *)(v12 + 524 * v19);
      if ( !v13 )
        goto LABEL_33;
      v21 = v20;
    }
    memmove(v13, v21, 0x20Cui64);
LABEL_33:
    v13 = (int (__fastcall *)(int, int, __int64))((char *)v13 + 524);
    v37 = v13;
LABEL_48:
    CoTaskMemFree((LPVOID)v43);
    v4 = v41;
LABEL_49:
    CoTaskMemFree((LPVOID)pidl);
    if ( (*(unsigned int (__fastcall **)(__int64, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)v39 + 24i64))(
           v39,
           1i64,
           &pidl,
           &v33) )
    {
      break;
    }
  }
  v8 = v35;
LABEL_51:
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v39 + 16i64))(v39);
  v27 = v12;
  for ( i = v40; (int (__fastcall *)(int, int, __int64))v27 != v13; v27 += 524i64 )
  {
    LODWORD(v45) = 103;
    *((_QWORD *)&v46 + 1) = v27;
    *(_QWORD *)((char *)&v47 + 4) = -1i64;
    *(_QWORD *)&v48 = *(int *)(v27 + 520);
    HIDWORD(v47) = 1;
    lParam[1] = -65534i64;
    lParam[0] = i;
    v52 = v45;
    v53 = v46;
    v54 = v47;
    v55 = v48;
    v56 = v49;
    SendMessageW(*(HWND *)(a1 + 24), 0x1132u, 0i64, (LPARAM)lParam);
  }
  if ( v8 )
  {
    v36 = i;
    v37 = sub_14001FC90;
    v38 = a1;
    SendMessageW(*(HWND *)(a1 + 24), 0x1115u, 0i64, (LPARAM)&v36);
  }
LABEL_56:
  SendMessageW(*(HWND *)(a1 + 24), 0xBu, 1ui64, 0i64);
  v29 = malloc(0x28ui64);
  v30 = v29;
  if ( v29 )
  {
    *v29 = *(_QWORD *)(a1 + 24);
    v29[2] = ILClone(v41);
    v30[1] = i;
    v30[3] = a1;
    Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_140020600, v30, 0, &ThreadId);
    CloseHandle(Thread);
  }
  if ( v12 )
    j_free((void *)v12);
}
// 140020157: conditional instruction was optimized away because rdx.8!=0
// 14001FE90: using guessed type WCHAR var_260[264];

//----- (00000001400204F0) ----------------------------------------------------
__int64 __fastcall sub_1400204F0(__int64 a1)
{
  int v1; // er8
  __int64 result; // rax
  _DWORD *v4; // rdx
  _DWORD *v5; // rcx
  void *v6; // rax
  void *v7; // rcx
  void *v8; // rax
  __int64 v9; // r9
  int v10; // er8
  __int64 v11; // rdx

  v1 = *(_DWORD *)(a1 + 648);
  result = 0i64;
  if ( v1 <= 0 )
  {
LABEL_5:
    v6 = realloc(*(void **)(a1 + 632), 4i64 * (v1 + 100));
    v7 = *(void **)(a1 + 640);
    *(_QWORD *)(a1 + 632) = v6;
    v8 = realloc(v7, 16i64 * (*(_DWORD *)(a1 + 648) + 100));
    *(_QWORD *)(a1 + 640) = v8;
    if ( *(_QWORD *)(a1 + 632) && v8 )
    {
      v9 = *(int *)(a1 + 648);
      v10 = v9;
      *(_DWORD *)(a1 + 648) = v9 + 100;
      if ( !__OFSUB__((_DWORD)v9, v9 + 100) )
      {
        v11 = 4 * v9;
        do
        {
          ++v10;
          v11 += 4i64;
          *(_DWORD *)(v11 + *(_QWORD *)(a1 + 632) - 4) = 0;
        }
        while ( v10 < *(_DWORD *)(a1 + 648) );
      }
      result = (unsigned int)v9;
      *(_DWORD *)(*(_QWORD *)(a1 + 632) + 4 * v9) = 1;
    }
    else
    {
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    v4 = *(_DWORD **)(a1 + 632);
    v5 = v4;
    while ( *v5 )
    {
      result = (unsigned int)(result + 1);
      ++v5;
      if ( (int)result >= v1 )
        goto LABEL_5;
    }
    v4[(int)result] = 1;
  }
  return result;
}

//----- (0000000140020600) ----------------------------------------------------
__int64 __fastcall sub_140020600(LPVOID lpThreadParameter)
{
  __int64 v1; // rbx

  v1 = *((_QWORD *)lpThreadParameter + 3);
  CoInitializeEx(0i64, 2u);
  sub_140020640(v1, (__int64)lpThreadParameter);
  CoUninitialize();
  return 0i64;
}

//----- (0000000140020640) ----------------------------------------------------
__int64 __fastcall sub_140020640(__int64 a1, __int64 a2)
{
  LPARAM v2; // r9
  HWND v5; // rcx
  ITEMIDLIST *v6; // r13
  LPARAM i; // r14
  HWND v8; // rcx
  __int64 v9; // rbx
  int v10; // edi
  HWND v11; // rcx
  LPARAM lParam[5]; // [rsp+20h] [rbp-78h] BYREF
  int v14; // [rsp+4Ch] [rbp-4Ch]
  int v15; // [rsp+50h] [rbp-48h]
  int v16; // [rsp+A8h] [rbp+10h] BYREF
  void *ppv; // [rsp+B0h] [rbp+18h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+B8h] [rbp+20h] BYREF

  v2 = *(_QWORD *)(a2 + 8);
  v5 = *(HWND *)a2;
  ppv = 0i64;
  v6 = 0i64;
  ppidlLast = 0i64;
  for ( i = SendMessageW(v5, 0x110Au, 4ui64, v2); i; i = SendMessageW(*(HWND *)a2, 0x110Au, 1ui64, i) )
  {
    v8 = *(HWND *)a2;
    v16 = 0x80000000;
    LODWORD(lParam[0]) = 20;
    lParam[1] = i;
    if ( (unsigned int)SendMessageW(v8, 0x113Eu, 0i64, (LPARAM)lParam) )
    {
      v9 = v15;
      v10 = 0;
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 584));
      if ( (int)v9 < *(_DWORD *)(a1 + 648) && *(_DWORD *)(*(_QWORD *)(a1 + 632) + 4 * v9) == 1 )
      {
        v10 = 1;
        v6 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16i64 * v15));
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 584));
      if ( v10 )
      {
        if ( SHBindToParent(v6, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0
          && (*(int (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
               ppv,
               1i64,
               &ppidlLast,
               &v16) >= 0 )
        {
          if ( v16 >= 0 )
          {
            v11 = *(HWND *)a2;
            LODWORD(lParam[0]) = 64;
            v14 = 0;
            SendMessageW(v11, 0x113Fu, 0i64, (LPARAM)lParam);
          }
          (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
        }
        CoTaskMemFree(v6);
      }
    }
  }
  CoTaskMemFree(*(LPVOID *)(a2 + 16));
  free((void *)a2);
  return 0i64;
}

//----- (0000000140020830) ----------------------------------------------------
LRESULT __fastcall sub_140020830(__int64 a1, LPARAM a2, const WCHAR *a3)
{
  __int64 v6; // rbx
  LPARAM v8; // rsi
  __int64 v9; // rbp
  HWND v10; // rcx
  __int64 v11; // rax
  const ITEMIDLIST *v12; // rdi
  const ITEMIDLIST *v13; // rcx
  DWORD FileAttributesW; // edi
  void *ppv; // [rsp+20h] [rbp-3C8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+28h] [rbp-3C0h] BYREF
  LPARAM lParam[6]; // [rsp+30h] [rbp-3B8h] BYREF
  int v18; // [rsp+60h] [rbp-388h]
  STRRET pstr; // [rsp+80h] [rbp-368h] BYREF
  WCHAR pszBuf[264]; // [rsp+190h] [rbp-258h] BYREF

  v6 = 0i64;
  if ( PathIsRootW(a3) )
    return sub_140020A40(a1, a2, a3);
  v8 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, a2);
  if ( !v8 )
    return -65535i64;
  v9 = -65535i64;
  while ( 1 )
  {
    v10 = *(HWND *)(a1 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v8;
    SendMessageW(v10, 0x113Eu, 0i64, (LPARAM)lParam);
    v11 = *(_QWORD *)(a1 + 640);
    v12 = *(const ITEMIDLIST **)(v11 + 16i64 * v18);
    if ( v12 )
    {
      v13 = *(const ITEMIDLIST **)(v11 + 16i64 * v18);
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v13, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               0x8000i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v12, pszBuf, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    FileAttributesW = GetFileAttributesW(pszBuf);
    if ( !PathIsRootW(pszBuf) && (FileAttributesW & 0x40000000) == 0 && lstrcmpiW(a3, pszBuf) < 0 )
      v6 = v9;
    v9 = v8;
    v8 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v8);
    if ( !v8 )
      break;
    if ( v6 )
      return v6;
  }
  if ( !v6 )
    return -65534i64;
  return v6;
}

//----- (0000000140020A40) ----------------------------------------------------
LRESULT __fastcall sub_140020A40(__int64 a1, LPARAM a2, const WCHAR *a3)
{
  LPARAM v5; // rsi
  LRESULT result; // rax
  __int64 v7; // rbx
  HWND v8; // rcx
  __int64 v9; // rax
  const ITEMIDLIST *v10; // rdi
  const ITEMIDLIST *v11; // rcx
  void *ppv; // [rsp+20h] [rbp-3B8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+28h] [rbp-3B0h] BYREF
  LPARAM lParam[6]; // [rsp+30h] [rbp-3A8h] BYREF
  int v15; // [rsp+60h] [rbp-378h]
  STRRET pstr; // [rsp+80h] [rbp-358h] BYREF
  WCHAR pszBuf[264]; // [rsp+190h] [rbp-248h] BYREF

  v5 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, a2);
  if ( !v5 )
    return -65535i64;
  v7 = -65535i64;
  while ( 1 )
  {
    v8 = *(HWND *)(a1 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v5;
    SendMessageW(v8, 0x113Eu, 0i64, (LPARAM)lParam);
    v9 = *(_QWORD *)(a1 + 640);
    v10 = *(const ITEMIDLIST **)(v9 + 16i64 * v15);
    if ( v10 )
    {
      v11 = *(const ITEMIDLIST **)(v9 + 16i64 * v15);
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v11, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               0x8000i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v10, pszBuf, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    if ( !PathIsRootW(pszBuf) || lstrcmpW(a3, pszBuf) < 0 )
      break;
    v7 = v5;
    result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v5);
    v5 = result;
    if ( !result )
      return result;
  }
  return v7;
}

//----- (0000000140020BE0) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_140020BE0(__int64 a1, LPARAM a2)
{
  HWND v3; // rcx
  LPARAM lParam[6]; // [rsp+20h] [rbp-58h] BYREF
  int v6; // [rsp+50h] [rbp-28h]

  v3 = *(HWND *)(a1 + 24);
  lParam[1] = a2;
  LODWORD(lParam[0]) = 20;
  SendMessageW(v3, 0x113Eu, 0i64, (LPARAM)lParam);
  return ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16i64 * v6));
}

//----- (0000000140020C30) ----------------------------------------------------
LRESULT __fastcall sub_140020C30(__int64 a1, __int64 a2)
{
  __int64 v4; // r8
  WCHAR *v5; // rcx
  WCHAR v6; // ax
  LPARAM v7; // rax
  LRESULT v8; // rax
  __int64 v9; // rdx
  LPARAM v10; // rbx
  WCHAR *v11; // rcx
  WCHAR v12; // ax
  HWND v13; // rcx
  const ITEMIDLIST *v15; // [rsp+20h] [rbp-688h] BYREF
  LPARAM lParam[4]; // [rsp+28h] [rbp-680h] BYREF
  int v17; // [rsp+48h] [rbp-660h]
  WCHAR pszPath[264]; // [rsp+60h] [rbp-648h] BYREF
  WCHAR String1[264]; // [rsp+270h] [rbp-438h] BYREF
  WCHAR String2[264]; // [rsp+480h] [rbp-228h] BYREF

  v4 = 260i64;
  v15 = 0i64;
  v5 = pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + a2 - (_QWORD)pszPath);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  PathRemoveFileSpecW(pszPath);
  if ( (int)sub_14007F810((__int64)pszPath, (__int64)&v15) < 0 )
    return sub_140020FE0(a1, a2);
  v7 = sub_140020E30(a1, v15, 1);
  if ( !v7 )
    return sub_140020FE0(a1, a2);
  v8 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v7);
  v9 = 260i64;
  v10 = v8;
  v11 = String1;
  while ( v9 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v11 + a2 - (_QWORD)String1);
    if ( !v12 )
      break;
    *v11++ = v12;
    if ( !--v9 )
    {
      --v11;
      break;
    }
  }
  *v11 = 0;
  PathStripPathW(String1);
  if ( !v10 )
    return sub_140020FE0(a1, a2);
  while ( 1 )
  {
    v13 = *(HWND *)(a1 + 24);
    lParam[3] = (LPARAM)String2;
    LODWORD(lParam[0]) = 17;
    lParam[1] = v10;
    v17 = 260;
    SendMessageW(v13, 0x113Eu, 0i64, (LPARAM)lParam);
    if ( !lstrcmpW(String1, String2) )
      break;
    v10 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v10);
    if ( !v10 )
      return sub_140020FE0(a1, a2);
  }
  return v10;
}
// 140020CA7: conditional instruction was optimized away because r8.8!=0
// 140020D57: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140020E30) ----------------------------------------------------
LPARAM __fastcall sub_140020E30(__int64 a1, const ITEMIDLIST *a2, int a3)
{
  LRESULT v6; // rax
  HWND v7; // rcx
  LPARAM v8; // rdi
  LPCITEMIDLIST *v9; // rsi
  LPCITEMIDLIST v10; // rbx
  BOOL v11; // ebx
  BOOL v12; // eax
  HWND v13; // rcx
  LPARAM v14; // r9
  WPARAM v15; // r8
  LRESULT v16; // rax
  HWND v17; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-78h] BYREF
  LRESULT v20; // [rsp+28h] [rbp-70h]
  int v21; // [rsp+50h] [rbp-48h]
  IShellFolder *ppshf; // [rsp+A0h] [rbp+8h] BYREF

  v6 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 0i64, 0i64);
  v7 = *(HWND *)(a1 + 24);
  v8 = v6;
  v20 = v6;
  LODWORD(lParam) = 20;
  SendMessageW(v7, 0x113Eu, 0i64, (LPARAM)&lParam);
  while ( v8 )
  {
    v9 = (LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16i64 * v21);
    v10 = *v9;
    if ( *v9 )
    {
      if ( a2 )
      {
        ppshf = 0i64;
        if ( SHGetDesktopFolder(&ppshf) >= 0 )
        {
          v11 = ((unsigned __int16 (__fastcall *)(IShellFolder *, _QWORD, LPCITEMIDLIST, const ITEMIDLIST *))ppshf->lpVtbl->CompareIDs)(
                  ppshf,
                  0i64,
                  v10,
                  a2) == 0;
          ((void (*)(void))ppshf->lpVtbl->Release)();
          if ( v11 )
            break;
        }
      }
    }
    v12 = ILIsParent(*v9, a2, 0);
    v13 = *(HWND *)(a1 + 24);
    v14 = v8;
    if ( v12 )
    {
      if ( !SendMessageW(v13, 0x110Au, 4ui64, v8) )
      {
        if ( a3 )
          return 0i64;
        SendMessageW(*(HWND *)(a1 + 24), 0x1102u, 2ui64, v8);
      }
      v13 = *(HWND *)(a1 + 24);
      v14 = v8;
      v15 = 4i64;
    }
    else
    {
      v15 = 1i64;
    }
    v16 = SendMessageW(v13, 0x110Au, v15, v14);
    v17 = *(HWND *)(a1 + 24);
    v8 = v16;
    v20 = v16;
    LODWORD(lParam) = 20;
    SendMessageW(v17, 0x113Eu, 0i64, (LPARAM)&lParam);
  }
  return v8;
}

//----- (0000000140020FE0) ----------------------------------------------------
LRESULT __fastcall sub_140020FE0(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  WCHAR *v4; // rcx
  __int64 v5; // rdx
  WCHAR v6; // ax
  LPARAM v7; // rbx
  LRESULT result; // rax
  LPARAM v9; // rbx
  wchar_t *v10; // rax
  __int64 v11; // r8
  signed __int64 v12; // rax
  __int16 *v13; // rdx
  __int16 v14; // cx
  __int64 v15; // rcx
  __int16 *v16; // rax
  __int16 *v17; // rax
  __int64 v18; // rdx
  char *v19; // r9
  __int16 v20; // r8
  HWND v21; // rcx
  LRESULT v22; // rax
  HWND v23; // rcx
  __int64 v24; // rax
  const ITEMIDLIST *v25; // rsi
  const ITEMIDLIST *v26; // rcx
  wchar_t *v27; // rsi
  LRESULT v28; // rax
  HWND v29; // rcx
  HWND v30; // rcx
  void *ppv; // [rsp+30h] [rbp-D0h] BYREF
  wchar_t *Context; // [rsp+38h] [rbp-C8h] BYREF
  LPITEMIDLIST ppidl; // [rsp+40h] [rbp-C0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+48h] [rbp-B8h] BYREF
  LPARAM lParam; // [rsp+50h] [rbp-B0h] BYREF
  LPARAM v36; // [rsp+58h] [rbp-A8h]
  __int16 *v37; // [rsp+68h] [rbp-98h]
  int v38; // [rsp+70h] [rbp-90h]
  int v39; // [rsp+80h] [rbp-80h]
  STRRET pstr; // [rsp+A0h] [rbp-60h] BYREF
  __int16 psz1[264]; // [rsp+1B0h] [rbp+B0h] BYREF
  WCHAR pszPath[264]; // [rsp+3C0h] [rbp+2C0h] BYREF
  WCHAR psz2[264]; // [rsp+5D0h] [rbp+4D0h] BYREF

  v3 = 260i64;
  v4 = pszPath;
  v5 = a2 - (_QWORD)pszPath;
  ppidl = 0i64;
  Context = 0i64;
  while ( v3 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v4 + v5);
    if ( !v6 )
      break;
    *v4++ = v6;
    if ( !--v3 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  PathRemoveBackslashW(pszPath);
  SHGetFolderLocation(0i64, 17, 0i64, 0, &ppidl);
  v7 = sub_140020E30(a1, ppidl, 0);
  CoTaskMemFree(ppidl);
  result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v7);
  v9 = result;
  if ( result )
  {
    v10 = wcstok_s(pszPath, L"\\", &Context);
    v11 = 260i64;
    v12 = (char *)v10 - (char *)psz1;
    v13 = psz1;
    while ( v11 != -2147483386 )
    {
      v14 = *(__int16 *)((char *)v13 + v12);
      if ( !v14 )
        break;
      *v13++ = v14;
      if ( !--v11 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
    v15 = 260i64;
    v16 = psz1;
    while ( *v16 )
    {
      ++v16;
      if ( !--v15 )
        goto LABEL_22;
    }
    v17 = &psz1[260 - v15];
    v18 = 0x7FFFFFFFi64;
    v19 = (char *)((char *)L"\\" - (char *)v17);
    while ( v18 )
    {
      v20 = *(__int16 *)((char *)v17 + (_QWORD)v19);
      if ( !v20 )
        break;
      *v17++ = v20;
      --v18;
      if ( !--v15 )
      {
        --v17;
        break;
      }
    }
    *v17 = 0;
LABEL_22:
    v21 = *(HWND *)(a1 + 24);
    LODWORD(lParam) = 20;
    v36 = v9;
    SendMessageW(v21, 0x113Eu, 0i64, (LPARAM)&lParam);
    sub_14007E270(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16i64 * v39), psz2, 0x8000u);
    while ( StrCmpIW((PCWSTR)psz1, psz2) )
    {
      v22 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v9);
      v9 = v22;
      if ( !v22 )
        return 0i64;
      v23 = *(HWND *)(a1 + 24);
      LODWORD(lParam) = 4;
      v36 = v22;
      SendMessageW(v23, 0x113Eu, 0i64, (LPARAM)&lParam);
      v24 = *(_QWORD *)(a1 + 640);
      v25 = *(const ITEMIDLIST **)(v24 + 16i64 * v39);
      if ( v25 )
      {
        v26 = *(const ITEMIDLIST **)(v24 + 16i64 * v39);
        ppv = 0i64;
        ppidlLast = 0i64;
        if ( SHBindToParent(v26, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
        {
          if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
                 ppv,
                 ppidlLast,
                 0x8000i64,
                 &pstr) >= 0 )
            StrRetToBufW(&pstr, v25, psz2, 0x104u);
          (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
        }
      }
    }
    LODWORD(lParam) = 1;
    v27 = wcstok_s(0i64, L"\\", &Context);
    if ( v27 )
    {
      while ( SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v9) )
      {
        v28 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v9);
        v29 = *(HWND *)(a1 + 24);
        v9 = v28;
        v38 = 260;
        v37 = psz1;
        v36 = v28;
        SendMessageW(v29, 0x113Eu, 0i64, (LPARAM)&lParam);
        while ( StrCmpIW(v27, (PCWSTR)psz1) )
        {
          v9 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v9);
          if ( !v9 )
            return 0i64;
          v30 = *(HWND *)(a1 + 24);
          v37 = psz1;
          v38 = 260;
          v36 = v9;
          SendMessageW(v30, 0x113Eu, 0i64, (LPARAM)&lParam);
        }
        v27 = wcstok_s(0i64, L"\\", &Context);
        if ( !v27 )
          return v9;
      }
      return 0i64;
    }
    return v9;
  }
  return result;
}
// 140021056: conditional instruction was optimized away because r8.8!=0
// 140021126: conditional instruction was optimized away because r8.8!=0
// 140021154: conditional instruction was optimized away because rcx.8!=0
// 14002116E: conditional instruction was optimized away because rcx.8!=0
// 1400211A7: conditional instruction was optimized away because rcx.8!=0
// 140020FE0: using guessed type WCHAR psz1[264];

//----- (0000000140021470) ----------------------------------------------------
LPARAM __fastcall sub_140021470(__int64 a1, wchar_t *a2)
{
  __int64 v5; // rdx
  wchar_t *v6; // rcx
  wchar_t v7; // ax
  wchar_t *v8; // rdi
  int v9; // ebx
  wchar_t *v10; // rbp
  LPARAM v11; // rbx
  int v12; // edi
  HWND v13; // rcx
  wchar_t *Context[2]; // [rsp+30h] [rbp-6B8h] BYREF
  LPARAM lParam[4]; // [rsp+40h] [rbp-6A8h] BYREF
  int v16; // [rsp+60h] [rbp-688h]
  wchar_t v17[264]; // [rsp+90h] [rbp-658h] BYREF
  WCHAR String[264]; // [rsp+2A0h] [rbp-448h] BYREF
  WCHAR String1[264]; // [rsp+4B0h] [rbp-238h] BYREF

  Context[0] = 0i64;
  if ( !sub_1400222D0(a2) )
    return 0i64;
  v5 = 260i64;
  v6 = v17;
  while ( v5 != -2147483386 )
  {
    v7 = *(wchar_t *)((char *)v6 + (char *)a2 - (char *)v17);
    if ( !v7 )
      break;
    *v6++ = v7;
    if ( !--v5 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  SHGetFolderPathW(0i64, 0, 0i64, 0, String);
  v8 = &v17[lstrlenW(String)];
  v9 = lstrlenW(a2);
  if ( v9 > lstrlenW(String) )
    ++v8;
  Context[0] = 0i64;
  v10 = wcstok_s(v8, L"\\", Context);
  v11 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 0i64, 0i64);
  if ( !v10 )
    return v11;
  while ( 1 )
  {
    v12 = 0;
    v11 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v11);
    if ( !v11 )
      return 0i64;
    while ( !v12 )
    {
      v13 = *(HWND *)(a1 + 24);
      lParam[3] = (LPARAM)String1;
      LODWORD(lParam[0]) = 1;
      lParam[1] = v11;
      v16 = 260;
      SendMessageW(v13, 0x113Eu, 0i64, (LPARAM)lParam);
      if ( lstrcmpW(String1, v10) )
        v11 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v11);
      else
        v12 = 1;
      if ( !v11 )
      {
        if ( !v12 )
          return 0i64;
        break;
      }
    }
    v10 = wcstok_s(Context[0], L"\\", Context);
    if ( !v10 )
      return v11;
  }
}
// 140021507: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400216B0) ----------------------------------------------------
LRESULT __fastcall sub_1400216B0(__int64 a1, LPARAM a2)
{
  LRESULT result; // rax
  LPARAM i; // rsi
  HWND v5; // rcx
  LPVOID *v6; // rbx
  LPARAM lParam[5]; // [rsp+20h] [rbp-58h] BYREF
  int v8; // [rsp+4Ch] [rbp-2Ch]
  int v9; // [rsp+50h] [rbp-28h]

  result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, a2);
  for ( i = result; result; i = result )
  {
    v5 = *(HWND *)(a1 + 24);
    LODWORD(lParam[0]) = 84;
    lParam[1] = i;
    SendMessageW(v5, 0x113Eu, 0i64, (LPARAM)lParam);
    if ( v8 )
      sub_1400216B0(a1, i);
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 584));
    v6 = (LPVOID *)(*(_QWORD *)(a1 + 640) + 16i64 * v9);
    CoTaskMemFree(*v6);
    CoTaskMemFree(v6[1]);
    *(_DWORD *)(*(_QWORD *)(a1 + 632) + 4i64 * v9) = 0;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 584));
    result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, i);
  }
  return result;
}

//----- (00000001400217C0) ----------------------------------------------------
__int64 __fastcall sub_1400217C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  __int64 v6; // rdx
  __int64 v7; // rdx
  int v8; // eax
  unsigned int v10; // eax
  __int16 j; // cx
  LRESULT v12; // rsi
  LPARAM *p_lParam; // r9
  UINT v14; // edx
  LPARAM v15; // rax
  LPARAM *v16; // rbx
  _QWORD *v17; // rax
  _QWORD *v18; // rbx
  _WORD *v19; // rbx
  __int64 v20; // rdx
  _WORD *v21; // rcx
  unsigned int v22; // eax
  __int16 i; // cx
  LRESULT v24; // rsi
  HWND v25; // rcx
  LPVOID pv; // [rsp+30h] [rbp-D0h] BYREF
  LPARAM lParam; // [rsp+38h] [rbp-C8h] BYREF
  LRESULT v28; // [rsp+40h] [rbp-C0h]
  WCHAR *v29; // [rsp+50h] [rbp-B0h]
  int iIcon; // [rsp+5Ch] [rbp-A4h]
  int v31; // [rsp+60h] [rbp-A0h]
  SHFILEINFOW psfi; // [rsp+70h] [rbp-90h] BYREF
  WCHAR pszPath[8]; // [rsp+330h] [rbp+230h] BYREF
  WCHAR pszBuf[264]; // [rsp+340h] [rbp+240h] BYREF

  v3 = a2 - 0x8000;
  if ( !v3 )
  {
    if ( *(_DWORD *)(a3 + 4) == 2 )
    {
      v22 = *(_DWORD *)(a3 + 12);
      for ( i = 0; (v22 & 1) == 0; ++i )
        v22 >>= 1;
      sub_140001000(pszPath, 4ui64, L"%c:\\", (unsigned __int16)(i + 65));
      if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
      {
        v24 = sub_140020FE0(a1, (__int64)pszPath);
        if ( v24 )
        {
          SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x4000u);
          pv = 0i64;
          if ( (int)sub_14007F810((__int64)pszPath, (__int64)&pv) >= 0 )
            sub_14007E270((LPCITEMIDLIST)pv, pszBuf, 1u);
          CoTaskMemFree(pv);
          v25 = *(HWND *)(a1 + 24);
          iIcon = psfi.iIcon;
          v31 = psfi.iIcon;
          v29 = pszBuf;
          LODWORD(lParam) = 51;
          v28 = v24;
          SendMessageW(v25, 0x113Fu, 0i64, (LPARAM)&lParam);
        }
      }
      else
      {
        sub_140023320(a1, pszPath);
        sub_140021BF0(a1, pszPath);
      }
    }
    return 0i64;
  }
  v6 = v3 - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 && v7 == 2 )
    {
      v8 = *(_DWORD *)(a3 + 4);
      if ( v8 != 2 )
      {
        if ( v8 == 6 )
        {
          UnregisterDeviceNotification(*(HDEVNOTIFY *)(a3 + 24));
          return 1i64;
        }
        return 1i64;
      }
      v10 = *(_DWORD *)(a3 + 12);
      for ( j = 0; (v10 & 1) == 0; ++j )
        v10 >>= 1;
      sub_140001000(pszPath, 4ui64, L"%c:\\", (unsigned __int16)(j + 65));
      if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
      {
        v12 = sub_140020FE0(a1, (__int64)pszPath);
        if ( v12 )
        {
          SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x4000u);
          pv = 0i64;
          if ( (int)sub_14007F810((__int64)pszPath, (__int64)&pv) >= 0 )
            sub_14007E270((LPCITEMIDLIST)pv, pszBuf, 1u);
          CoTaskMemFree(pv);
          LODWORD(lParam) = 51;
          iIcon = psfi.iIcon;
          v31 = psfi.iIcon;
          v28 = v12;
          p_lParam = &lParam;
          v14 = 4415;
          v29 = pszBuf;
          goto LABEL_17;
        }
      }
      else
      {
        v15 = sub_140020C30(a1, (__int64)pszPath);
        v16 = (LPARAM *)v15;
        if ( v15 )
        {
          sub_1400216B0(a1, v15);
          p_lParam = v16;
          v14 = 4353;
LABEL_17:
          SendMessageW(*(HWND *)(a1 + 24), v14, 0i64, (LPARAM)p_lParam);
        }
      }
      return 1i64;
    }
    return 0i64;
  }
  if ( *(_DWORD *)(a3 + 4) == 6 )
  {
    v17 = *(_QWORD **)(a1 + 1312);
    v18 = (_QWORD *)*v17;
    if ( (_QWORD *)*v17 != v17 )
    {
      while ( v18[67] != *(_QWORD *)(a3 + 16) )
      {
        v18 = (_QWORD *)*v18;
        if ( v18 == *(_QWORD **)(a1 + 1312) )
          return 1i64;
      }
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 40i64))(
        *(_QWORD *)(a1 + 48),
        *((unsigned int *)v18 + 136));
      *(_DWORD *)(a1 + 1336) = 1;
      v19 = v18 + 2;
      v20 = 260i64;
      v21 = (_WORD *)(a1 + 1340);
      while ( v20 != -2147483386 && *v19 )
      {
        *v21++ = *v19++;
        if ( !--v20 )
        {
          --v21;
          break;
        }
      }
      *v21 = 0;
    }
  }
  return 1i64;
}
// 1400219F9: conditional instruction was optimized away because rdx.8!=0
// 1400F7D60: using guessed type wchar_t aC[5];

//----- (0000000140021B50) ----------------------------------------------------
__int64 __fastcall sub_140021B50(LPVOID lpThreadParameter)
{
  DWORD LogicalDriveStringsW; // ebx
  __int64 result; // rax
  WCHAR *v4; // rdi
  const WCHAR *i; // rbx

  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0i64);
  result = (__int64)malloc(2i64 * (LogicalDriveStringsW + 1));
  v4 = (WCHAR *)result;
  if ( result )
  {
    if ( GetLogicalDriveStringsW(LogicalDriveStringsW, (LPWSTR)result) )
    {
      for ( i = v4; *i; i += lstrlenW(i) + 1 )
        sub_140021BF0((__int64)lpThreadParameter, i);
    }
    free(v4);
    return 1i64;
  }
  return result;
}

//----- (0000000140021BF0) ----------------------------------------------------
int __fastcall sub_140021BF0(__int64 a1, const WCHAR *a2)
{
  _QWORD *FileW; // rax
  __int64 v5; // rbp
  _WORD *v6; // rax
  __int64 v7; // rbx
  _WORD *v8; // rdx
  __int64 v9; // r8
  __int16 v10; // cx
  int v11; // eax
  void *v12; // rcx
  int v13; // er12
  char *v14; // rcx
  signed __int64 v15; // rdi
  __int16 v16; // ax
  __int64 v17; // rbx
  __int64 v18; // rdx
  char *v19; // r11
  __int64 v20; // rax
  int NotificationFilter[4]; // [rsp+40h] [rbp-298h] BYREF
  __int64 v23; // [rsp+50h] [rbp-288h]
  char v24[520]; // [rsp+80h] [rbp-258h] BYREF
  __int64 v25; // [rsp+288h] [rbp-50h]
  int v26; // [rsp+290h] [rbp-48h]

  LODWORD(FileW) = GetDriveTypeW(a2);
  if ( (_DWORD)FileW != 4 )
  {
    FileW = CreateFileW(a2, 1u, 7u, 0i64, 3u, 0x42000000u, 0i64);
    v5 = (__int64)FileW;
    if ( FileW != (_QWORD *)-1i64 )
    {
      v6 = malloc(0x210ui64);
      v7 = 260i64;
      v8 = v6;
      v9 = 260i64;
      while ( v9 != -2147483386 )
      {
        v10 = *(_WORD *)((char *)v8 + (char *)a2 - (char *)v6);
        if ( !v10 )
          break;
        *v8++ = v10;
        if ( !--v9 )
        {
          --v8;
          break;
        }
      }
      *v8 = 0;
      *((_QWORD *)v6 + 65) = a1;
      v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, const WCHAR *, __int64, void (__fastcall *)(LPCWSTR, int, __int64), int, _WORD *))(**(_QWORD **)(a1 + 48) + 24i64))(
              *(_QWORD *)(a1 + 48),
              v5,
              a2,
              2i64,
              sub_140023150,
              1,
              v6);
      v12 = *(void **)(a1 + 24);
      v13 = v11;
      NotificationFilter[0] = 56;
      NotificationFilter[1] = 6;
      v23 = v5;
      FileW = RegisterDeviceNotificationW(v12, NotificationFilter, 0);
      if ( FileW )
      {
        v14 = v24;
        v15 = (char *)a2 - v24;
        while ( v7 != -2147483386 )
        {
          v16 = *(_WORD *)&v14[v15];
          if ( !v16 )
            break;
          *(_WORD *)v14 = v16;
          v14 += 2;
          if ( !--v7 )
          {
            v14 -= 2;
            break;
          }
        }
        v17 = *(_QWORD *)(a1 + 1312);
        *(_WORD *)v14 = 0;
        v18 = *(_QWORD *)(v17 + 8);
        v25 = v5;
        v26 = v13;
        v19 = sub_140022530(v17, v18, v24);
        v20 = *(_QWORD *)(a1 + 1320);
        if ( v20 == 0x7A44C6AFC2DD9Bi64 )
          sub_14002B5F8("list<T> too long");
        *(_QWORD *)(a1 + 1320) = v20 + 1;
        *(_QWORD *)(v17 + 8) = v19;
        FileW = (_QWORD *)*((_QWORD *)v19 + 1);
        *FileW = v19;
      }
    }
  }
  return (int)FileW;
}
// 140021CC7: conditional instruction was optimized away because r8.8!=0
// 140021D76: conditional instruction was optimized away because rbx.8!=0

//----- (0000000140021E30) ----------------------------------------------------
__int64 __fastcall sub_140021E30(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 2147500034i64;
}

//----- (0000000140021E40) ----------------------------------------------------
__int64 __fastcall sub_140021E40(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 40) + 1);
  *(_DWORD *)(a1 + 40) = result;
  return result;
}

//----- (0000000140021E50) ----------------------------------------------------
__int64 __fastcall sub_140021E50(void *Block)
{
  if ( (*((_DWORD *)Block + 10))-- != 1 )
    return *((unsigned int *)Block + 10);
  sub_14001F240((__int64)Block);
  j_free(Block);
  return 0i64;
}

//----- (0000000140021E80) ----------------------------------------------------
LRESULT __fastcall sub_140021E80(__int64 a1)
{
  LRESULT v2; // rax
  HWND v3; // rcx
  LPARAM v4; // rbx
  HWND v5; // rcx
  LPARAM v6; // rax
  LPARAM lParam; // [rsp+30h] [rbp-328h] BYREF
  LRESULT v9; // [rsp+38h] [rbp-320h]
  int iIcon; // [rsp+54h] [rbp-304h]
  int v11; // [rsp+58h] [rbp-300h]
  int v12; // [rsp+60h] [rbp-2F8h]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-2D8h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 0i64, 0i64);
  v3 = *(HWND *)(a1 + 24);
  v4 = v2;
  v9 = v2;
  LODWORD(lParam) = 20;
  SendMessageW(v3, 0x113Eu, 0i64, (LPARAM)&lParam);
  SHGetFileInfoW(*(LPCWSTR *)(*(_QWORD *)(a1 + 640) + 16i64 * v12), 0, &psfi, 0x2B8u, 0x4008u);
  v5 = *(HWND *)(a1 + 24);
  iIcon = psfi.iIcon;
  v11 = psfi.iIcon;
  LODWORD(lParam) = 50;
  v9 = v4;
  SendMessageW(v5, 0x113Fu, 0i64, (LPARAM)&lParam);
  v6 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v4);
  return sub_140021F90(a1, v6);
}

//----- (0000000140021F90) ----------------------------------------------------
LRESULT __fastcall sub_140021F90(__int64 a1, LPARAM a2)
{
  LRESULT v4; // rax
  HWND v5; // rcx
  LPARAM v6; // rdi
  HWND v7; // rcx
  LRESULT result; // rax
  HWND v9; // rcx
  HWND v10; // rcx
  LPARAM v11; // rax
  LPARAM lParam; // [rsp+30h] [rbp-318h] BYREF
  LPARAM v13; // [rsp+38h] [rbp-310h]
  int iIcon; // [rsp+54h] [rbp-2F4h]
  int v15; // [rsp+58h] [rbp-2F0h]
  int v16; // [rsp+60h] [rbp-2E8h]
  SHFILEINFOW psfi; // [rsp+70h] [rbp-2D8h] BYREF

  v4 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, a2);
  v5 = *(HWND *)(a1 + 24);
  v6 = v4;
  LODWORD(lParam) = 20;
  v13 = a2;
  SendMessageW(v5, 0x113Eu, 0i64, (LPARAM)&lParam);
  SHGetFileInfoW(*(LPCWSTR *)(*(_QWORD *)(a1 + 640) + 16i64 * v16), 0, &psfi, 0x2B8u, 0x4008u);
  v7 = *(HWND *)(a1 + 24);
  iIcon = psfi.iIcon;
  v15 = psfi.iIcon;
  LODWORD(lParam) = 50;
  v13 = a2;
  SendMessageW(v7, 0x113Fu, 0i64, (LPARAM)&lParam);
  result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, a2);
  if ( result )
    result = sub_140021F90(a1, result);
  if ( v6 )
  {
    do
    {
      v9 = *(HWND *)(a1 + 24);
      LODWORD(lParam) = 20;
      v13 = v6;
      SendMessageW(v9, 0x113Eu, 0i64, (LPARAM)&lParam);
      SHGetFileInfoW(*(LPCWSTR *)(*(_QWORD *)(a1 + 640) + 16i64 * v16), 0, &psfi, 0x2B8u, 0x4008u);
      v10 = *(HWND *)(a1 + 24);
      iIcon = psfi.iIcon;
      v15 = psfi.iIcon;
      LODWORD(lParam) = 50;
      v13 = v6;
      SendMessageW(v10, 0x113Fu, 0i64, (LPARAM)&lParam);
      v11 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, v6);
      if ( v11 )
        sub_140021F90(a1, v11);
      result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v6);
      v6 = result;
    }
    while ( result );
  }
  return result;
}

//----- (0000000140022190) ----------------------------------------------------
HRESULT __fastcall sub_140022190(__int64 a1, int a2, int a3)
{
  __int64 v5; // rbx
  HRESULT result; // eax
  HRESULT v7; // ebx
  IDataObject *v8; // rcx
  HRESULT v9; // eax
  LPDATAOBJECT v10; // rcx
  LPDATAOBJECT pDataObj; // [rsp+40h] [rbp-38h] BYREF
  void *ppv; // [rsp+48h] [rbp-30h] BYREF
  LPVOID v13; // [rsp+50h] [rbp-28h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+58h] [rbp-20h] BYREF
  __int64 v15; // [rsp+60h] [rbp-18h] BYREF
  DWORD pdwEffect; // [rsp+98h] [rbp+20h] BYREF

  v5 = a2;
  pDataObj = 0i64;
  v13 = 0i64;
  ppv = 0i64;
  ppidlLast = 0i64;
  v15 = 0i64;
  result = CoCreateInstance(&rclsid, 0i64, 0x17u, &riid, &v13);
  if ( result >= 0 )
  {
    v7 = SHBindToParent(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 16 * v5), &stru_1400E3FB0, &ppv, &ppidlLast);
    if ( v7 >= 0 )
    {
      (*(void (__fastcall **)(void *, _QWORD, __int64, LPCITEMIDLIST *, __int64 *, _QWORD, LPDATAOBJECT *))(*(_QWORD *)ppv + 80i64))(
        ppv,
        *(_QWORD *)(a1 + 24),
        1i64,
        &ppidlLast,
        &qword_1400E41B0,
        0i64,
        &pDataObj);
      (*(void (__fastcall **)(LPVOID, _QWORD, __int64 *, LPDATAOBJECT))(*(_QWORD *)v13 + 32i64))(
        v13,
        *(_QWORD *)(a1 + 24),
        &v15,
        pDataObj);
      v8 = pDataObj;
      *(_DWORD *)(a1 + 696) = a3;
      v9 = DoDragDrop(v8, (LPDROPSOURCE)(a1 + 8), 7u, &pdwEffect);
      v10 = pDataObj;
      *(_DWORD *)(a1 + 680) = 0;
      v7 = v9;
      ((void (__fastcall *)(LPDATAOBJECT))v10->lpVtbl->Release)(v10);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    }
    (*(void (__fastcall **)(LPVOID))(*(_QWORD *)v13 + 16i64))(v13);
    return v7;
  }
  return result;
}
// 1400E41B0: using guessed type __int64 qword_1400E41B0;

//----- (00000001400222D0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400222D0(wchar_t *String1)
{
  int v2; // eax
  WCHAR String[264]; // [rsp+30h] [rbp-228h] BYREF

  SHGetFolderPathW(0i64, 0, 0i64, 0, String);
  v2 = lstrlenW(String);
  return wcsncmp(String1, String, v2) == 0;
}

//----- (0000000140022350) ----------------------------------------------------
_QWORD *__fastcall sub_140022350(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v5; // [rsp+50h] [rbp+8h] BYREF

  a1[1] = 0i64;
  v2 = operator new(0x220ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *a1 = v2;
  *v2 = v2;
  *(_QWORD *)(*a1 + 8i64) = *a1;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400223C0) ----------------------------------------------------
__int64 __fastcall sub_1400223C0(__int64 a1)
{
  void *v2; // rcx
  __int64 result; // rax

  v2 = *(void **)a1;
  if ( v2 )
    j_free(v2);
  result = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (00000001400223F0) ----------------------------------------------------
void **sub_1400223F0()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  qword_14012E088 = 0i64;
  v0 = operator new(0x28ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012E080 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012E080 + 1) = qword_14012E080;
  return &qword_14012E080;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012E088: using guessed type __int64 qword_14012E088;

//----- (0000000140022470) ----------------------------------------------------
unsigned __int64 __fastcall sub_140022470(_QWORD *a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdx

  v2 = (a1[1] - *a1) / 524i64;
  if ( v2 > 0x7D1196792909C4i64 )
    sub_14002B5F8("vector<T> too long");
  v3 = v2 + 1;
  v4 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x3E88CB3C9484E2Bi64) >> 64) >> 63;
  v6 = v4 / 524;
  if ( v3 > v4 / 524 )
  {
    if ( 0x7D1196792909C5i64 - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v3 )
        v8 = v3;
      return sub_1400225E0(a1, v8);
    }
    else
    {
      v7 = 0i64;
      if ( v3 )
        v7 = v3;
      return sub_1400225E0(a1, v7);
    }
  }
  return result;
}
// 1400225E0: using guessed type __int64 __fastcall sub_1400225E0(_QWORD, _QWORD);

//----- (0000000140022530) ----------------------------------------------------
char *__fastcall sub_140022530(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x228ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x218ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140022720) ----------------------------------------------------
char *__fastcall sub_140022720(void *Src, void *a2, char *a3)
{
  while ( Src != a2 )
  {
    if ( a3 )
      memmove(a3, Src, 0x20Cui64);
    a3 += 524;
    Src = (char *)Src + 524;
  }
  return a3;
}

//----- (0000000140022780) ----------------------------------------------------
__int64 __fastcall sub_140022780(void *a1, __int64 a2, char *a3)
{
  __int64 v5; // r12
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 result; // rax
  __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // rt2
  __int64 v12; // rsi
  char *v13; // rdi
  char *v14; // rbx
  char *v15; // r15
  __int64 v16; // rdx
  char Src[528]; // [rsp+20h] [rbp-238h] BYREF
  __int64 v18; // [rsp+260h] [rbp+8h]

  v5 = (a2 - (__int64)a1) / 524;
  v6 = (unsigned __int128)((a3 - (_BYTE *)a1) * (__int128)0x3E88CB3C9484E2Bi64) >> 64;
  v7 = v5;
  result = (unsigned __int64)v6 >> 63;
  v9 = ((unsigned __int64)v6 >> 63) + (v6 >> 3);
  v18 = v9;
  if ( v5 )
  {
    do
    {
      v10 = v9;
      v9 = v7;
      v11 = v10 % v7;
      result = v10 / v7;
      v7 = v11;
    }
    while ( v11 );
    v18 = v9;
  }
  if ( v9 < (__int64)(((unsigned __int64)v6 >> 63) + (v6 >> 3)) && v9 > 0 )
  {
    v12 = 524 * v5;
    v13 = (char *)a1 + 524 * v9;
    do
    {
      v14 = &v13[v12];
      v15 = v13;
      if ( &v13[v12] == a3 )
        v14 = (char *)a1;
      do
      {
        memmove(Src, v15, 0x20Cui64);
        memmove(v15, v14, 0x20Cui64);
        memmove(v14, Src, 0x20Cui64);
        v15 = v14;
        result = (unsigned __int64)((unsigned __int128)((a3 - v14) * (__int128)0x3E88CB3C9484E2Bi64) >> 64) >> 63;
        v16 = (a3 - v14) / 524;
        if ( v5 >= v16 )
          v14 = (char *)a1 + 524 * (v5 - v16);
        else
          v14 += v12;
      }
      while ( v14 != v13 );
      v13 -= 524;
      --v18;
    }
    while ( v18 > 0 );
  }
  return result;
}

//----- (0000000140022940) ----------------------------------------------------
__int64 __fastcall sub_140022940(__int64 a1, __int64 a2, _QWORD *a3)
{
  return sub_140021E30(a1 - 8, a2, a3);
}

//----- (0000000140022950) ----------------------------------------------------
__int64 __fastcall sub_140022950(__int64 a1)
{
  return sub_140021E50((void *)(a1 - 8));
}

//----- (0000000140022960) ----------------------------------------------------
__int64 __fastcall sub_140022960(__int64 a1)
{
  return sub_140021E40(a1 - 8);
}

//----- (0000000140022970) ----------------------------------------------------
void __fastcall sub_140022970(__int64 a1)
{
  _QWORD *v2; // rdi
  _QWORD *i; // rbx
  __int16 *v4; // r8
  __int64 v5; // rdx
  _WORD *v6; // rcx
  _QWORD **v7; // rax
  _QWORD *v8; // rcx
  _QWORD *v9; // rbx
  __int16 v10[260]; // [rsp+20h] [rbp-238h] BYREF
  int v11; // [rsp+228h] [rbp-30h]

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 752));
  KillTimer(*(HWND *)(a1 + 24), 0i64);
  v2 = *(_QWORD **)(a1 + 704);
  for ( i = (_QWORD *)*v2; i != v2; i = (_QWORD *)*i )
  {
    memmove(v10, i + 2, 0x20Cui64);
    switch ( v11 )
    {
      case 1:
        sub_140022B00(a1, (const WCHAR *)v10);
        break;
      case 2:
        sub_140022C30(a1, (wchar_t *)v10);
        break;
      case 4:
        v4 = v10;
        v5 = 260i64;
        v6 = (_WORD *)(a1 + 792);
        while ( v5 != -2147483386 && *v4 )
        {
          *v6++ = *v4++;
          if ( !--v5 )
          {
            *(v6 - 1) = 0;
            goto LABEL_15;
          }
        }
        *v6 = 0;
        break;
      case 5:
        sub_140022E50(a1, (const WCHAR *)v10);
        break;
    }
LABEL_15:
    ;
  }
  v7 = *(_QWORD ***)(a1 + 704);
  v8 = *v7;
  *v7 = v7;
  *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8i64) = *(_QWORD *)(a1 + 704);
  *(_QWORD *)(a1 + 712) = 0i64;
  if ( v8 != *(_QWORD **)(a1 + 704) )
  {
    do
    {
      v9 = (_QWORD *)*v8;
      j_free(v8);
      v8 = v9;
    }
    while ( v9 != *(_QWORD **)(a1 + 704) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 752));
}
// 140022A53: conditional instruction was optimized away because rdx.8!=0
// 140022970: using guessed type wchar_t var_238[260];

//----- (0000000140022B00) ----------------------------------------------------
void __fastcall sub_140022B00(__int64 a1, const WCHAR *a2)
{
  __int64 v4; // rdx
  char *v5; // rcx
  signed __int64 v6; // rbx
  __int16 v7; // ax
  __int64 v8; // rbx
  __int64 v9; // rdx
  char *v10; // r11
  __int64 v11; // rax
  void *pv[2]; // [rsp+20h] [rbp-238h] BYREF
  char v13[520]; // [rsp+30h] [rbp-228h] BYREF
  int v14; // [rsp+238h] [rbp-20h]

  pv[0] = 0i64;
  if ( a2 && (int)sub_14007F810((__int64)a2, (__int64)pv) >= 0 )
  {
    sub_140023320(a1, a2);
    CoTaskMemFree(pv[0]);
  }
  else
  {
    v4 = 260i64;
    v5 = v13;
    v6 = (char *)a2 - v13;
    while ( v4 != -2147483386 )
    {
      v7 = *(_WORD *)&v5[v6];
      if ( !v7 )
        break;
      *(_WORD *)v5 = v7;
      v5 += 2;
      if ( !--v4 )
      {
        v5 -= 2;
        break;
      }
    }
    v8 = *(_QWORD *)(a1 + 728);
    *(_WORD *)v5 = 0;
    v9 = *(_QWORD *)(v8 + 8);
    v14 = 1;
    v10 = sub_140023C20(v8, v9, v13);
    v11 = *(_QWORD *)(a1 + 736);
    if ( v11 == 0x7D1196792909C4i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 736) = v11 + 1;
    *(_QWORD *)(v8 + 8) = v10;
    **((_QWORD **)v10 + 1) = v10;
  }
}
// 140022B9A: conditional instruction was optimized away because rdx.8!=0
// 140022B00: using guessed type LPVOID pv[2];

//----- (0000000140022C30) ----------------------------------------------------
void __fastcall sub_140022C30(__int64 a1, wchar_t *a2)
{
  __int64 v4; // r9
  WCHAR *v5; // r8
  WCHAR v6; // ax
  LPARAM v7; // r12
  LPARAM v8; // r14
  LPARAM v9; // rax
  LPARAM v10; // r13
  LRESULT v11; // rbx
  LPARAM v12; // rax
  LPARAM v13; // rbp
  void **v14; // rax
  WCHAR *v15; // rbx
  void *pv[2]; // [rsp+20h] [rbp-258h] BYREF
  WCHAR pszPath[264]; // [rsp+30h] [rbp-248h] BYREF

  v4 = 260i64;
  v5 = pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + (char *)a2 - (char *)pszPath);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = 0i64;
  *v5 = 0;
  PathRemoveFileSpecW(pszPath);
  v8 = sub_140021470(a1, pszPath);
  v9 = sub_140021470(a1, a2);
  v10 = v9;
  if ( v9 )
  {
    sub_1400216B0(a1, v9);
    SendMessageW(*(HWND *)(a1 + 24), 0x1101u, 0i64, v10);
  }
  v11 = sub_140020C30(a1, (__int64)a2);
  if ( v11 )
  {
    v12 = sub_140020C30(a1, (__int64)a2);
    v13 = v12;
    if ( v12 )
    {
      sub_1400216B0(a1, v12);
      SendMessageW(*(HWND *)(a1 + 24), 0x1101u, 0i64, v13);
    }
  }
  sub_140023AD0(a1, v8);
  pv[0] = 0i64;
  if ( (int)sub_14007F810((__int64)pszPath, (__int64)pv) >= 0 )
  {
    v7 = sub_140020E30(a1, (const ITEMIDLIST *)pv[0], 1);
    CoTaskMemFree(pv[0]);
  }
  sub_140023AD0(a1, v7);
  if ( !v10 && !v11 )
  {
    v14 = *(void ***)(a1 + 728);
    v15 = (WCHAR *)*v14;
    if ( *v14 != v14 )
    {
      while ( lstrcmpW(a2, v15 + 8) )
      {
        v15 = *(WCHAR **)v15;
        if ( v15 == *(WCHAR **)(a1 + 728) )
          return;
      }
      if ( v15 != *(WCHAR **)(a1 + 728) )
      {
        **((_QWORD **)v15 + 1) = *(_QWORD *)v15;
        *(_QWORD *)(*(_QWORD *)v15 + 8i64) = *((_QWORD *)v15 + 1);
        j_free(v15);
        --*(_QWORD *)(a1 + 736);
      }
    }
  }
}
// 140022CA8: conditional instruction was optimized away because r9.8!=0
// 140022C30: using guessed type LPVOID pv[2];

//----- (0000000140022E50) ----------------------------------------------------
void __fastcall sub_140022E50(__int64 a1, const WCHAR *a2)
{
  LPARAM v4; // rax
  LPARAM v5; // r12
  LPARAM v6; // rax
  LPARAM v7; // rdi
  LPARAM v8; // rax
  __int64 v9; // rbx
  HWND v10; // rcx
  int v11; // ebx
  HWND Parent; // rax
  void **v13; // rax
  WCHAR *v14; // rdi
  __int64 v15; // rdx
  _WORD *v16; // rcx
  __int16 v17; // ax
  _QWORD *v18; // rax
  _QWORD *v19; // rbx
  __int64 v20; // rbx
  char *v21; // r11
  __int64 v22; // rax
  LPARAM lParam; // [rsp+20h] [rbp-F8h] BYREF
  __int64 v24; // [rsp+28h] [rbp-F0h]
  __int64 v25; // [rsp+30h] [rbp-E8h]
  __int64 v26; // [rsp+38h] [rbp-E0h]
  __int64 v27; // [rsp+40h] [rbp-D8h]
  __int64 v28; // [rsp+48h] [rbp-D0h]
  __int64 v29; // [rsp+50h] [rbp-C8h]
  __int64 v30[2]; // [rsp+60h] [rbp-B8h] BYREF
  int v31; // [rsp+70h] [rbp-A8h]
  int v32; // [rsp+78h] [rbp-A0h]
  LPARAM v33; // [rsp+B8h] [rbp-60h]
  __int64 v34; // [rsp+C0h] [rbp-58h]
  __int64 v35; // [rsp+C8h] [rbp-50h]
  __int64 v36; // [rsp+D0h] [rbp-48h]
  __int64 v37; // [rsp+D8h] [rbp-40h]
  __int64 v38; // [rsp+E0h] [rbp-38h]
  __int64 v39; // [rsp+E8h] [rbp-30h]

  v4 = sub_140021470(a1, (wchar_t *)(a1 + 792));
  v5 = v4;
  if ( v4 )
    sub_140023760(a1, v4, a2);
  v6 = sub_140020FE0(a1, a1 + 792);
  v7 = v6;
  if ( v6 )
  {
    sub_140023760(a1, v6, a2);
    v8 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 9ui64, 0i64);
    v9 = v8;
    if ( v8 == v7 )
    {
LABEL_7:
      v10 = *(HWND *)(a1 + 24);
      LODWORD(lParam) = 4;
      v24 = v9;
      v11 = SendMessageW(v10, 0x113Eu, 0i64, (LPARAM)&lParam);
      Parent = GetParent(*(HWND *)(a1 + 24));
      if ( v11 && Parent )
      {
        v35 = v25;
        v33 = lParam;
        v36 = v26;
        v37 = v27;
        v34 = v24;
        v38 = v28;
        v31 = -451;
        v39 = v29;
        v32 = 0;
        SendMessageW(Parent, 0x4Eu, 0i64, (LPARAM)v30);
      }
    }
    else
    {
      while ( v8 )
      {
        v8 = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 3ui64, v8);
        if ( v8 == v7 )
          goto LABEL_7;
      }
    }
  }
  if ( !v5 && !v7 )
  {
    v13 = *(void ***)(a1 + 728);
    v14 = (WCHAR *)*v13;
    if ( *v13 != v13 )
    {
      while ( lstrcmpW((LPCWSTR)(a1 + 792), v14 + 8) )
      {
        v14 = *(WCHAR **)v14;
        if ( v14 == *(WCHAR **)(a1 + 728) )
          return;
      }
      v15 = 260i64;
      v16 = v14 + 8;
      while ( v15 != -2147483386 )
      {
        v17 = *(_WORD *)((char *)v16 + (char *)a2 - (char *)(v14 + 8));
        if ( !v17 )
          break;
        *v16++ = v17;
        if ( !--v15 )
        {
          --v16;
          break;
        }
      }
      *v16 = 0;
      v18 = *(_QWORD **)(a1 + 704);
      v19 = (_QWORD *)*v18;
      if ( (_QWORD *)*v18 != v18 )
      {
        while ( *((_DWORD *)v19 + 134) != 5 || lstrcmpW((LPCWSTR)v19 + 8, a2) )
        {
          v19 = (_QWORD *)*v19;
          if ( v19 == *(_QWORD **)(a1 + 704) )
            goto LABEL_29;
        }
        v20 = *v19;
        v21 = sub_140023C20(v20, *(_QWORD *)(v20 + 8), v14 + 8);
        v22 = *(_QWORD *)(a1 + 712);
        if ( v22 == 0x7D1196792909C4i64 )
          sub_14002B5F8("list<T> too long");
        *(_QWORD *)(a1 + 712) = v22 + 1;
        *(_QWORD *)(v20 + 8) = v21;
        **((_QWORD **)v21 + 1) = v21;
      }
LABEL_29:
      if ( v14 != *(WCHAR **)(a1 + 728) )
      {
        **((_QWORD **)v14 + 1) = *(_QWORD *)v14;
        *(_QWORD *)(*(_QWORD *)v14 + 8i64) = *((_QWORD *)v14 + 1);
        j_free(v14);
        --*(_QWORD *)(a1 + 736);
      }
    }
  }
}
// 140023067: conditional instruction was optimized away because rdx.8!=0
// 140022E50: using guessed type LPARAM var_B8[2];

//----- (0000000140023150) ----------------------------------------------------
void __fastcall sub_140023150(LPCWSTR pszMore, int a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v6; // rdx
  __int64 v7; // r8
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-228h] BYREF

  v3 = *(_QWORD *)(a3 + 520);
  v6 = 260i64;
  v7 = a3 - (_QWORD)pszPath;
  v8 = pszPath;
  while ( v6 != -2147483386 )
  {
    v9 = *(WCHAR *)((char *)v8 + v7);
    if ( !v9 )
      break;
    *v8++ = v9;
    if ( !--v6 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathAppendW(pszPath, pszMore);
  sub_140023200(v3, a2, (__int64)pszPath);
}
// 1400231B7: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140023200) ----------------------------------------------------
void __fastcall sub_140023200(__int64 a1, int a2, __int64 a3)
{
  __int64 v6; // r11
  __int64 v7; // rbx
  char *v8; // rcx
  __int16 v9; // ax
  __int64 v10; // rbx
  __int64 v11; // rdx
  char *v12; // r11
  __int64 v13; // rax
  char v14[520]; // [rsp+20h] [rbp-238h] BYREF
  int v15; // [rsp+228h] [rbp-30h]

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 752));
  SetTimer(*(HWND *)(a1 + 24), 0i64, 0x1F4u, 0i64);
  v6 = 260i64;
  v7 = a3 - (_QWORD)v14;
  v8 = v14;
  while ( v6 != -2147483386 )
  {
    v9 = *(_WORD *)&v8[v7];
    if ( !v9 )
      break;
    *(_WORD *)v8 = v9;
    v8 += 2;
    if ( !--v6 )
    {
      v8 -= 2;
      break;
    }
  }
  v10 = *(_QWORD *)(a1 + 704);
  v11 = *(_QWORD *)(v10 + 8);
  *(_WORD *)v8 = 0;
  v15 = a2;
  v12 = sub_140023C20(v10, v11, v14);
  v13 = *(_QWORD *)(a1 + 712);
  if ( v13 == 0x7D1196792909C4i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 712) = v13 + 1;
  *(_QWORD *)(v10 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 752));
}
// 140023286: conditional instruction was optimized away because r11.8!=0

//----- (0000000140023320) ----------------------------------------------------
void __fastcall sub_140023320(__int64 a1, const WCHAR *a2)
{
  LPARAM v4; // rax
  __int64 v5; // rdx
  WCHAR *v6; // rcx
  WCHAR v7; // ax
  LPARAM v8; // rsi
  LPARAM v9; // rbp
  LPITEMIDLIST ppidl[2]; // [rsp+30h] [rbp-248h] BYREF
  WCHAR pszPath[264]; // [rsp+40h] [rbp-238h] BYREF

  if ( PathIsRootW(a2) )
  {
    ppidl[0] = 0i64;
    if ( !SHGetFolderLocation(0i64, 17, 0i64, 0, ppidl) )
    {
      v4 = sub_140020E30(a1, ppidl[0], 1);
      if ( v4 )
        sub_1400234B0(a1, v4, a2);
      CoTaskMemFree(ppidl[0]);
    }
  }
  else
  {
    v5 = 260i64;
    v6 = pszPath;
    while ( v5 != -2147483386 )
    {
      v7 = *(WCHAR *)((char *)v6 + (char *)a2 - (char *)pszPath);
      if ( !v7 )
        break;
      *v6++ = v7;
      if ( !--v5 )
      {
        --v6;
        break;
      }
    }
    v8 = 0i64;
    *v6 = 0;
    PathRemoveFileSpecW(pszPath);
    v9 = sub_140021470(a1, pszPath);
    ppidl[0] = 0i64;
    if ( (int)sub_14007F810((__int64)pszPath, (__int64)ppidl) >= 0
      && (v8 = sub_140020E30(a1, ppidl[0], 1), CoTaskMemFree(ppidl[0]), v8)
      || v9 )
    {
      sub_1400234B0(a1, v8, a2);
      if ( v9 )
        sub_1400234B0(a1, v9, a2);
    }
  }
}
// 1400233F7: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400234B0) ----------------------------------------------------
void __fastcall sub_1400234B0(__int64 a1, LPARAM a2, const WCHAR *a3)
{
  HWND v6; // rcx
  BOOL v7; // er13
  __int64 v8; // r14
  __int64 v9; // rbx
  LRESULT v10; // rax
  HWND v11; // rcx
  HWND v12; // rcx
  int v13; // [rsp+30h] [rbp-D0h] BYREF
  LPCITEMIDLIST pidl; // [rsp+38h] [rbp-C8h] BYREF
  void *ppv; // [rsp+40h] [rbp-C0h] BYREF
  LPVOID pv; // [rsp+48h] [rbp-B8h] BYREF
  LPCITEMIDLIST ppidlLast[2]; // [rsp+50h] [rbp-B0h] BYREF
  LPARAM lParam[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v19; // [rsp+70h] [rbp-90h]
  __int128 v20; // [rsp+80h] [rbp-80h]
  __int128 v21; // [rsp+90h] [rbp-70h]
  __int128 v22; // [rsp+A0h] [rbp-60h]
  LPARAM v23[2]; // [rsp+B0h] [rbp-50h] BYREF
  __int128 v24; // [rsp+C0h] [rbp-40h]
  __int128 v25; // [rsp+D0h] [rbp-30h]
  __int128 v26; // [rsp+E0h] [rbp-20h]
  __int128 v27; // [rsp+F0h] [rbp-10h]
  __int128 v28; // [rsp+100h] [rbp+0h]
  SHFILEINFOW psfi; // [rsp+110h] [rbp+10h] BYREF
  WCHAR pszBuf[264]; // [rsp+3D0h] [rbp+2D0h] BYREF

  if ( a3 )
  {
    ppv = 0i64;
    pidl = 0i64;
    ppidlLast[0] = 0i64;
    if ( (int)sub_14007F810((__int64)a3, (__int64)&pidl) >= 0 )
    {
      v6 = *(HWND *)(a1 + 24);
      LODWORD(lParam[0]) = 72;
      lParam[1] = a2;
      if ( (unsigned int)SendMessageW(v6, 0x113Eu, 0i64, (LPARAM)lParam) )
      {
        if ( HIDWORD(v20) && (v19 & 0x20) != 0 )
        {
          SHGetFileInfoW(a3, 0, &psfi, 0x2B8u, 0x4000u);
          if ( SHBindToParent(pidl, &stru_1400E3FB0, &ppv, ppidlLast) >= 0 )
          {
            v13 = 0x80000000;
            if ( (*(int (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
                   ppv,
                   1i64,
                   ppidlLast,
                   &v13) >= 0 )
            {
              v7 = (v13 & 0x80000000) == 0x80000000;
              v8 = (int)sub_1400204F0(a1);
              v9 = 2 * v8;
              *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v9) = ILClone(pidl);
              *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v9 + 8) = ILClone(ppidlLast[0]);
              pv = 0i64;
              if ( (int)sub_14007F810((__int64)a3, (__int64)&pv) >= 0 )
                sub_14007E270((LPCITEMIDLIST)pv, pszBuf, 0);
              CoTaskMemFree(pv);
              *(_QWORD *)&v21 = v8;
              *((_QWORD *)&v19 + 1) = pszBuf;
              DWORD1(v20) = psfi.iIcon;
              *((_QWORD *)&v20 + 1) = __PAIR64__(v7, psfi.iIcon);
              LODWORD(lParam[0]) = 103;
              if ( a2 )
              {
                v23[0] = a2;
                v10 = sub_140020830(a1, a2, a3);
                v11 = *(HWND *)(a1 + 24);
                v24 = *(_OWORD *)lParam;
                v25 = v19;
                v23[1] = v10;
                v26 = v20;
                v28 = v22;
                v27 = v21;
                SendMessageW(v11, 0x1132u, 0i64, (LPARAM)v23);
              }
            }
            (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
          }
        }
        else
        {
          v12 = *(HWND *)(a1 + 24);
          LODWORD(lParam[0]) = 64;
          lParam[1] = a2;
          HIDWORD(v20) = 1;
          SendMessageW(v12, 0x113Fu, 0i64, (LPARAM)lParam);
        }
      }
      CoTaskMemFree((LPVOID)pidl);
    }
  }
}

//----- (0000000140023760) ----------------------------------------------------
void __fastcall sub_140023760(__int64 a1, LPARAM a2, const WCHAR *a3)
{
  HWND v4; // rcx
  LPVOID *v7; // rbx
  __int64 v8; // r11
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  int v11; // eax
  const ITEMIDLIST *v12; // rbx
  HWND v13; // rcx
  LPARAM lParam; // [rsp+30h] [rbp-548h] BYREF
  LPARAM v15; // [rsp+38h] [rbp-540h]
  WCHAR *v16; // [rsp+48h] [rbp-530h]
  int iIcon; // [rsp+54h] [rbp-524h]
  int v18; // [rsp+58h] [rbp-520h]
  int v19; // [rsp+60h] [rbp-518h]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-4F8h] BYREF
  WCHAR pszPath[264]; // [rsp+340h] [rbp-238h] BYREF

  if ( a2 )
  {
    v4 = *(HWND *)(a1 + 24);
    v15 = a2;
    LODWORD(lParam) = 4;
    if ( (unsigned int)SendMessageW(v4, 0x113Eu, 0i64, (LPARAM)&lParam) )
    {
      v7 = (LPVOID *)(*(_QWORD *)(a1 + 640) + 16i64 * v19);
      CoTaskMemFree(*v7);
      v8 = 260i64;
      v9 = pszPath;
      while ( v8 != -2147483386 )
      {
        v10 = *(WCHAR *)((char *)v9 + (char *)a3 - (char *)pszPath);
        if ( !v10 )
          break;
        *v9++ = v10;
        if ( !--v8 )
        {
          --v9;
          break;
        }
      }
      *v9 = 0;
      PathStripPathW(pszPath);
      if ( a3 )
        v11 = sub_14007F810((__int64)a3, (__int64)v7);
      else
        v11 = -2147467259;
      v12 = (const ITEMIDLIST *)*v7;
      if ( v11 >= 0 )
      {
        SHGetFileInfoW(a3, 0, &psfi, 0x2B8u, 0x4000u);
        v13 = *(HWND *)(a1 + 24);
        v16 = pszPath;
        LODWORD(lParam) = 51;
        iIcon = psfi.iIcon;
        v18 = psfi.iIcon;
        v15 = a2;
        SendMessageW(v13, 0x113Fu, 0i64, (LPARAM)&lParam);
        sub_1400238F0(a1, a2, v12);
      }
    }
  }
}
// 140023826: conditional instruction was optimized away because r11.8!=0

//----- (00000001400238F0) ----------------------------------------------------
LRESULT __fastcall sub_1400238F0(__int64 a1, LPARAM a2, const ITEMIDLIST *a3)
{
  LRESULT result; // rax
  LPARAM v6; // rbx
  HWND v7; // rcx
  const ITEMIDLIST *v8; // rax
  LPARAM i; // rdi
  HWND v10; // rcx
  __int64 v11; // rbx
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  LRESULT v13; // [rsp+28h] [rbp-50h]
  int v14; // [rsp+50h] [rbp-28h]

  result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 4ui64, a2);
  v6 = result;
  if ( result )
  {
    v7 = *(HWND *)(a1 + 24);
    LODWORD(lParam) = 4;
    v13 = result;
    result = SendMessageW(v7, 0x113Eu, 0i64, (LPARAM)&lParam);
    if ( (_DWORD)result )
    {
      v8 = (const ITEMIDLIST *)sub_140023A60(a1, a3, v14);
      sub_1400238F0(a1, v6, v8);
      result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, v6);
      for ( i = result; result; i = result )
      {
        v10 = *(HWND *)(a1 + 24);
        LODWORD(lParam) = 4;
        v13 = i;
        if ( (unsigned int)SendMessageW(v10, 0x113Eu, 0i64, (LPARAM)&lParam) )
        {
          v11 = v14;
          CoTaskMemFree(*(LPVOID *)(*(_QWORD *)(a1 + 640) + 16i64 * v14));
          v11 *= 2i64;
          *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v11) = ILCombine(
                                                           a3,
                                                           *(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v11 + 8));
          sub_1400238F0(a1, i, *(const ITEMIDLIST **)(*(_QWORD *)(a1 + 640) + 8 * v11));
        }
        result = SendMessageW(*(HWND *)(a1 + 24), 0x110Au, 1ui64, i);
      }
    }
  }
  return result;
}

//----- (0000000140023A60) ----------------------------------------------------
__int64 __fastcall sub_140023A60(__int64 a1, const ITEMIDLIST *a2, int a3)
{
  __int64 v4; // rdi

  v4 = 2i64 * a3;
  CoTaskMemFree(*(LPVOID *)(*(_QWORD *)(a1 + 640) + 16i64 * a3));
  *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v4) = ILCombine(a2, *(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 640) + 8 * v4 + 8));
  return *(_QWORD *)(*(_QWORD *)(a1 + 640) + 8 * v4);
}

//----- (0000000140023AD0) ----------------------------------------------------
void __fastcall sub_140023AD0(__int64 a1, LPARAM a2)
{
  HWND v3; // rcx
  const ITEMIDLIST *v5; // rcx
  int v6; // ebx
  HWND v7; // rcx
  HWND v8; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  LPARAM v10; // [rsp+28h] [rbp-50h]
  int v11; // [rsp+4Ch] [rbp-2Ch]
  int v12; // [rsp+50h] [rbp-28h]
  int v13; // [rsp+88h] [rbp+10h] BYREF
  void *ppv; // [rsp+90h] [rbp+18h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+98h] [rbp+20h] BYREF

  if ( a2 )
  {
    v3 = *(HWND *)(a1 + 24);
    v10 = a2;
    v13 = 0x80000000;
    LODWORD(lParam) = 20;
    if ( (unsigned int)SendMessageW(v3, 0x113Eu, 0i64, (LPARAM)&lParam) )
    {
      v5 = *(const ITEMIDLIST **)(*(_QWORD *)(a1 + 640) + 16i64 * v12);
      if ( v5 )
      {
        ppv = 0i64;
        ppidlLast = 0i64;
        if ( SHBindToParent(v5, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
        {
          v6 = (*(__int64 (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
                 ppv,
                 1i64,
                 &ppidlLast,
                 &v13);
          (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
          if ( v6 >= 0 )
          {
            if ( v13 < 0 )
            {
              v11 = 1;
            }
            else
            {
              v7 = *(HWND *)(a1 + 24);
              v11 = 0;
              SendMessageW(v7, 0x1102u, 1ui64, a2);
            }
            v8 = *(HWND *)(a1 + 24);
            LODWORD(lParam) = 64;
            v10 = a2;
            SendMessageW(v8, 0x113Fu, 0i64, (LPARAM)&lParam);
          }
        }
      }
    }
  }
}

//----- (0000000140023C20) ----------------------------------------------------
char *__fastcall sub_140023C20(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x220ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x20Cui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140023CD0) ----------------------------------------------------
__int64 sub_140023CD0(__int64 a1, __int64 a2, char a3, ...)
{
  _QWORD *v6; // rax
  _QWORD *v7; // rdi
  _QWORD *v8; // rbx
  _DWORD *v9; // rbx
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx
  void *Block[3]; // [rsp+38h] [rbp-80h] BYREF
  __int64 pExceptionObject[3]; // [rsp+50h] [rbp-68h] BYREF
  __int64 v15[10]; // [rsp+68h] [rbp-50h] BYREF
  char *v16; // [rsp+C0h] [rbp+8h] BYREF
  struct tagPOINT v17; // [rsp+D8h] [rbp+20h] BYREF
  va_list va; // [rsp+D8h] [rbp+20h]
  _DWORD *v19; // [rsp+E0h] [rbp+28h]
  va_list va1; // [rsp+E8h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v17 = va_arg(va1, struct tagPOINT);
  v19 = va_arg(va1, _DWORD *);
  *(_QWORD *)(a1 + 672) = a2;
  *(_DWORD *)(a1 + 680) = 1;
  Block[1] = 0i64;
  v6 = operator new(0x30ui64);
  if ( !v6 )
  {
    v16 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v16);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v6;
  *v6 = v6;
  v6[1] = v6;
  sub_1400762E0((__int64 *)Block);
  v7 = Block[0];
  v8 = *(_QWORD **)Block[0];
  if ( *(void **)Block[0] == Block[0] )
  {
LABEL_7:
    *(_DWORD *)(a1 + 692) = 0;
    v9 = v19;
    *v19 = 0;
  }
  else
  {
    while ( 1 )
    {
      v15[0] = v8[2];
      v15[1] = v8[3];
      v15[2] = v8[4];
      v15[3] = v8[5];
      if ( !(*(unsigned int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a2 + 40i64))(a2, v15) )
        break;
      v8 = (_QWORD *)*v8;
      if ( v8 == v7 )
        goto LABEL_7;
    }
    *(_DWORD *)(a1 + 692) = 1;
    v9 = v19;
    sub_140023ED0(a1, a3, *v19, (struct tagPOINT *)va);
  }
  lParam = 0i64;
  SetTimer(*(HWND *)(a1 + 24), 2ui64, 0x3E8u, (TIMERPROC)TimerFunc);
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)(a1 + 696) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *(_DWORD *)(a1 + 696) = 1;
  }
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64, struct tagPOINT *, _DWORD))(**(_QWORD **)(a1 + 664) + 24i64))(
    *(_QWORD *)(a1 + 664),
    *(_QWORD *)(a1 + 24),
    a2,
    (struct tagPOINT *)va,
    *v9);
  v10 = (_QWORD *)*v7;
  *v7 = v7;
  v7[1] = v7;
  if ( v10 != v7 )
  {
    do
    {
      v11 = (_QWORD *)*v10;
      j_free(v10);
      v10 = v11;
    }
    while ( v11 != v7 );
  }
  j_free(v7);
  return 0i64;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140023EB0) ----------------------------------------------------
void __fastcall TimerFunc(HWND a1)
{
  dword_14012DC98 = 1;
  KillTimer(a1, 2ui64);
}
// 14012DC98: using guessed type int dword_14012DC98;

//----- (0000000140023ED0) ----------------------------------------------------
__int64 __fastcall sub_140023ED0(__int64 a1, char a2, char a3, struct tagPOINT *a4)
{
  HWND v5; // rcx
  LPARAM v8; // rax
  int v9; // er11
  struct tagPOINT Point; // [rsp+20h] [rbp-28h] BYREF

  v5 = *(HWND *)(a1 + 24);
  Point = *a4;
  ScreenToClient(v5, &Point);
  v8 = SendMessageW(*(HWND *)(a1 + 24), 0x1111u, 0i64, (LPARAM)&Point);
  if ( !v8 )
    return 0i64;
  v9 = sub_1400241A0(a1, *(__int64 **)(a1 + 672), v8);
  if ( !*(_DWORD *)(a1 + 692) )
    return 0i64;
  if ( ((a2 & 8) != 0 && (a2 & 4) != 0 || (a2 & 0x20) != 0) && (a3 & 4) != 0 )
    return 4i64;
  if ( (a2 & 4) != 0 && (a3 & 2) != 0 )
    return 2i64;
  if ( (a2 & 8) == 8 && (a3 & 1) != 0 )
    return 1i64;
  if ( v9 && (a3 & 2) != 0 )
    return 2i64;
  if ( (a3 & 1) != 0 )
    return 1i64;
  if ( (a3 & 2) != 0 )
    return 2i64;
  else
    return a3 & 4;
}

//----- (0000000140023FF0) ----------------------------------------------------
void __fastcall sub_140023FF0(HWND a1)
{
  SendMessageW(a1, 0x1102u, 2ui64, lParam);
  KillTimer(a1, 1ui64);
}

//----- (0000000140024030) ----------------------------------------------------
__int64 __fastcall sub_140024030(__int64 a1, char a2, struct tagPOINT a3, unsigned int *a4)
{
  unsigned int v6; // eax
  WPARAM v7; // r8
  WPARAM v8; // r8
  HWND v9; // rcx
  HWND v10; // rcx
  struct tagPOINT Point; // [rsp+20h] [rbp-48h] BYREF
  LPARAM lParam; // [rsp+28h] [rbp-40h] BYREF
  char v14; // [rsp+30h] [rbp-38h]
  LPARAM v15; // [rsp+38h] [rbp-30h]
  struct tagRECT Rect; // [rsp+40h] [rbp-28h] BYREF

  Point = a3;
  v6 = sub_140023ED0(a1, a2, *a4, &Point);
  *a4 = v6;
  (*(void (__fastcall **)(_QWORD, struct tagPOINT *, _QWORD))(**(_QWORD **)(a1 + 664) + 40i64))(
    *(_QWORD *)(a1 + 664),
    &Point,
    v6);
  ScreenToClient(*(HWND *)(a1 + 24), &Point);
  if ( !dword_14012DC98 )
    goto LABEL_12;
  GetClientRect(*(HWND *)(a1 + 24), &Rect);
  if ( Point.x < 10 )
  {
    v7 = 0i64;
LABEL_6:
    SendMessageW(*(HWND *)(a1 + 24), 0x114u, v7, 0i64);
    goto LABEL_7;
  }
  if ( Point.x > Rect.right - 10 )
  {
    v7 = 1i64;
    goto LABEL_6;
  }
LABEL_7:
  if ( Point.y < 10 )
  {
    v8 = 0i64;
LABEL_11:
    SendMessageW(*(HWND *)(a1 + 24), 0x115u, v8, 0i64);
    goto LABEL_12;
  }
  if ( Point.y > Rect.bottom - 10 )
  {
    v8 = 1i64;
    goto LABEL_11;
  }
LABEL_12:
  v9 = *(HWND *)(a1 + 24);
  lParam = (LPARAM)Point;
  SendMessageW(v9, 0x1111u, 0i64, (LPARAM)&lParam);
  if ( (v14 & 1) == 0 )
  {
    if ( v15 )
    {
      SendMessageW(*(HWND *)(a1 + 24), 0x110Bu, 8ui64, v15);
      if ( ::lParam != v15 )
      {
        v10 = *(HWND *)(a1 + 24);
        ::lParam = v15;
        SetTimer(v10, 1ui64, 0x320u, (TIMERPROC)sub_140023FF0);
      }
    }
  }
  return 0i64;
}
// 14012DC98: using guessed type int dword_14012DC98;

//----- (00000001400241A0) ----------------------------------------------------
__int64 __fastcall sub_1400241A0(__int64 a1, __int64 *a2, LPARAM a3)
{
  __int64 v4; // rax
  unsigned int IsSameRootW; // ebx
  HDROP v7; // rax
  HDROP v8; // rdi
  ITEMIDLIST *v9; // rsi
  __int16 v11; // [rsp+20h] [rbp-488h] BYREF
  __int64 v12; // [rsp+28h] [rbp-480h]
  int v13; // [rsp+30h] [rbp-478h]
  int v14; // [rsp+34h] [rbp-474h]
  int v15; // [rsp+38h] [rbp-470h]
  char v16[8]; // [rsp+40h] [rbp-468h] BYREF
  HGLOBAL hMem; // [rsp+48h] [rbp-460h]
  WCHAR szFile[264]; // [rsp+60h] [rbp-448h] BYREF
  WCHAR pszPath1[264]; // [rsp+270h] [rbp-238h] BYREF

  v11 = 15;
  v4 = *a2;
  IsSameRootW = 0;
  v13 = 1;
  v14 = -1;
  v12 = 0i64;
  v15 = 1;
  if ( (*(unsigned int (__fastcall **)(__int64 *, __int16 *, char *))(v4 + 24))(a2, &v11, v16) )
    return 0i64;
  v7 = (HDROP)GlobalLock(hMem);
  v8 = v7;
  if ( v7 )
  {
    if ( (int)DragQueryFileW(v7, 0xFFFFFFFF, 0i64, 0) > 0 )
    {
      v9 = sub_140020BE0(a1, a3);
      if ( v9 )
      {
        DragQueryFileW(v8, 0, szFile, 0x104u);
        sub_14007E270(v9, pszPath1, 0x8000u);
        IsSameRootW = PathIsSameRootW(pszPath1, szFile);
        CoTaskMemFree(v9);
      }
    }
    GlobalUnlock(hMem);
  }
  return IsSameRootW;
}
// 1400241A0: using guessed type char var_468[8];

//----- (00000001400242D0) ----------------------------------------------------
__int64 __fastcall sub_1400242D0(__int64 a1)
{
  HWND v2; // rcx

  SendMessageW(*(HWND *)(a1 + 24), 0x110Bu, 8ui64, 0i64);
  v2 = *(HWND *)(a1 + 24);
  dword_14012DC98 = 0;
  *(_DWORD *)(a1 + 680) = 0;
  KillTimer(v2, 1ui64);
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 32i64))(*(_QWORD *)(a1 + 664));
  return 0i64;
}
// 14012DC98: using guessed type int dword_14012DC98;

//----- (0000000140024330) ----------------------------------------------------
__int64 __fastcall sub_140024330(__int64 a1, __int64 a2, int a3, struct tagPOINT a4, unsigned int *a5)
{
  HWND v6; // rcx
  HWND v9; // rcx
  ITEMIDLIST *v10; // rsi
  _DWORD *v11; // rax
  __int64 v12; // rbx
  int v13; // edx
  __int64 v14; // rcx
  int *v15; // r8
  unsigned int v16; // eax
  __int64 v17; // rcx
  __int64 v18; // r9
  struct tagPOINT v20; // [rsp+20h] [rbp-288h] BYREF
  struct tagPOINT Point; // [rsp+28h] [rbp-280h] BYREF
  char v22; // [rsp+30h] [rbp-278h]
  LPARAM v23; // [rsp+38h] [rbp-270h]
  WCHAR pszBuf[264]; // [rsp+50h] [rbp-258h] BYREF

  v6 = *(HWND *)(a1 + 24);
  v20 = a4;
  KillTimer(v6, 1ui64);
  v9 = *(HWND *)(a1 + 24);
  Point = v20;
  ScreenToClient(v9, &Point);
  SendMessageW(*(HWND *)(a1 + 24), 0x1111u, 0i64, (LPARAM)&Point);
  if ( (v22 & 1) == 0 && v23 && *(_DWORD *)(a1 + 692) )
  {
    v10 = sub_140020BE0(a1, v23);
    sub_14007E270(v10, pszBuf, 0x8000u);
    v11 = operator new(0x50ui64);
    v12 = (__int64)v11;
    if ( v11 )
    {
      v11[2] = 1;
      *(_QWORD *)v11 = &CDropHandler::`vftable';
    }
    else
    {
      v12 = 0i64;
    }
    v13 = *(_DWORD *)(a1 + 696);
    v14 = *(_QWORD *)(a1 + 24);
    *(struct tagPOINT *)(v12 + 36) = v20;
    v15 = (int *)(v12 + 36);
    *(_QWORD *)(v12 + 16) = a2;
    *(_DWORD *)(v12 + 32) = a3;
    v16 = *a5;
    *(_QWORD *)(v12 + 48) = v14;
    *(_DWORD *)(v12 + 44) = v16;
    *(_DWORD *)(v12 + 56) = v13;
    *(_QWORD *)(v12 + 24) = 0i64;
    *(_DWORD *)(v12 + 72) = 0;
    *(_QWORD *)(v12 + 64) = pszBuf;
    if ( v13 )
    {
      if ( v13 == 1 )
        sub_1400761A0(v12);
    }
    else
    {
      sub_1400783F0(v12, a2, v15);
    }
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v12 + 8)) )
      (**(void (__fastcall ***)(__int64, __int64, int *))v12)(v12, 1i64, v15);
    CoTaskMemFree(v10);
  }
  SendMessageW(*(HWND *)(a1 + 24), 0x110Bu, 8ui64, 0i64);
  v17 = *(_QWORD *)(a1 + 664);
  *(_DWORD *)(a1 + 680) = 0;
  v18 = *a5;
  dword_14012DC98 = 0;
  (*(void (__fastcall **)(__int64, __int64, struct tagPOINT *, __int64))(*(_QWORD *)v17 + 48i64))(v17, a2, &v20, v18);
  return 0i64;
}
// 14002449F: variable 'v15' is possibly undefined
// 1400F7C20: using guessed type void *CDropHandler::`vftable';
// 14012DC98: using guessed type int dword_14012DC98;

//----- (0000000140024520) ----------------------------------------------------
__int64 __fastcall sub_140024520(__int64 a1, int a2, int a3)
{
  int v3; // er9
  int v4; // eax

  v3 = *(_DWORD *)(a1 + 688);
  v4 = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( (a3 & 2) == 0 )
        return 262400i64;
      v4 = 1;
    }
  }
  else
  {
    if ( (a3 & 1) == 0 )
      return 262400i64;
    v4 = 2;
  }
  if ( a2 == 1 || (v4 & a3) != 0 )
    return 262401i64;
  else
    return 0i64;
}

//----- (0000000140024570) ----------------------------------------------------
__int64 sub_140024570()
{
  return 262402i64;
}

//----- (0000000140024580) ----------------------------------------------------
__int64 __fastcall sub_140024580(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_140073250(a1 - 8, a2, a3);
}

//----- (0000000140024590) ----------------------------------------------------
__int64 __fastcall sub_140024590(__int64 a1)
{
  return sub_140073A70((void *)(a1 - 24));
}

//----- (00000001400245A0) ----------------------------------------------------
__int64 __fastcall sub_1400245A0(__int64 a1)
{
  return sub_1400731D0(a1 - 16);
}

//----- (00000001400245B0) ----------------------------------------------------
__int64 __fastcall sub_1400245B0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_140073250(a1 - 16, a2, a3);
}

//----- (00000001400245C0) ----------------------------------------------------
__int64 __fastcall sub_1400245C0(__int64 a1)
{
  return sub_140073A70((void *)(a1 - 32));
}

//----- (00000001400245D0) ----------------------------------------------------
__int64 __fastcall sub_1400245D0(__int64 a1)
{
  return sub_1400731D0(a1 - 24);
}

//----- (00000001400245E0) ----------------------------------------------------
__int64 __fastcall sub_1400245E0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_140073250(a1 - 24, a2, a3);
}

//----- (00000001400245F0) ----------------------------------------------------
__int64 __fastcall sub_1400245F0(__int64 a1)
{
  return sub_140073A70((void *)(a1 - 8));
}

//----- (0000000140024600) ----------------------------------------------------
__int64 __fastcall sub_140024600(__int64 a1)
{
  return sub_1400731D0(a1 - 32);
}

//----- (0000000140024610) ----------------------------------------------------
__int64 __fastcall sub_140024610(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  return sub_140073250(a1 - 32, a2, a3);
}

//----- (0000000140024620) ----------------------------------------------------
__int64 __fastcall sub_140024620(__int64 a1)
{
  return sub_140073A70((void *)(a1 - 16));
}

//----- (0000000140024630) ----------------------------------------------------
__int64 __fastcall sub_140024630(__int64 a1)
{
  return sub_1400731D0(a1 - 8);
}

//----- (0000000140024640) ----------------------------------------------------
char *__fastcall sub_140024640(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x20ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
  {
    *((_DWORD *)result + 4) = *a3;
    *((_DWORD *)result + 5) = a3[1];
    *((_DWORD *)result + 6) = a3[2];
    *((_DWORD *)result + 7) = a3[3];
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400246F0) ----------------------------------------------------
char *__fastcall sub_1400246F0(__int64 a1, __int64 a2, _DWORD *a3)
{
  char *result; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v8; // [rsp+68h] [rbp+20h] BYREF

  result = (char *)operator new(0x18ui64);
  v8 = result;
  if ( !result )
  {
    v8 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v8);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)result = a1;
  *((_QWORD *)result + 1) = a2;
  if ( result != (char *)-16i64 )
    *((_DWORD *)result + 4) = *a3;
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140024790) ----------------------------------------------------
char *__fastcall sub_140024790(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x218ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x208ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140024850) ----------------------------------------------------
__int64 __fastcall sub_140024850(__int64 a1, __int64 *a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // r8

  v2 = *a2;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 8) = abs32((int)v2 / -694967296);
  *(_DWORD *)(a1 + 4) = abs32(v2 / 60000000 % 60);
  v3 = (__int64)((unsigned __int128)(v2 * (__int128)0x431BDE82D7B634DBi64) >> 64) >> 18;
  *(_DWORD *)a1 = abs32((__int64)((v3 >> 63) + v3) % 60);
  return a1;
}

//----- (0000000140024AA0) ----------------------------------------------------
_QWORD *__fastcall sub_140024AA0(__int64 a1)
{
  __int64 v2; // rcx
  const wchar_t *v3; // rdi
  bool v4; // zf

  v2 = -1i64;
  v3 = L"%Y%m%dT%H%M%S%F%q";
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  return sub_1400099E0((void *)(a1 + 16), L"%Y%m%dT%H%M%S%F%q", -v2 - 2);
}
// 1400F8360: using guessed type wchar_t aYMDtHMSFQ[18];

//----- (0000000140024AE0) ----------------------------------------------------
_QWORD *__fastcall sub_140024AE0(__int64 a1)
{
  __int64 v2; // rcx
  const wchar_t *v3; // rdi
  bool v4; // zf

  v2 = -1i64;
  v3 = L"%Y-%m-%d %H:%M:%S%F%Q";
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  return sub_1400099E0((void *)(a1 + 16), L"%Y-%m-%d %H:%M:%S%F%Q", -v2 - 2);
}
// 1400F8330: using guessed type wchar_t aYMDHMSFQ[22];

//----- (0000000140024B20) ----------------------------------------------------
_QWORD *__fastcall sub_140024B20(__int64 a1)
{
  __int64 v2; // rcx
  const wchar_t *v3; // rdi
  bool v4; // zf

  v2 = -1i64;
  v3 = L"%Y%m%d";
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  return sub_1400099E0((void *)(a1 + 16), L"%Y%m%d", -v2 - 2);
}
// 1400F84B8: using guessed type wchar_t aYMD[7];

//----- (0000000140024B60) ----------------------------------------------------
_QWORD *__fastcall sub_140024B60(__int64 a1)
{
  __int64 v2; // rcx
  const wchar_t *v3; // rdi
  bool v4; // zf

  v2 = -1i64;
  v3 = L"%Y-%m-%d";
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  return sub_1400099E0((void *)(a1 + 16), L"%Y-%m-%d", -v2 - 2);
}
// 1400F84C8: using guessed type wchar_t aYMD_0[9];

//----- (0000000140024BA0) ----------------------------------------------------
_QWORD *__fastcall sub_140024BA0(__int64 a1, _QWORD *a2, __int128 *a3, __int64 a4, int a5, unsigned int a6)
{
  __int64 v6; // r10
  _QWORD *v9; // rdi
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx
  unsigned __int16 v12; // r8
  int *v13; // rax
  _WORD **v14; // rcx
  unsigned __int16 *v15; // rdx
  __int128 i; // [rsp+20h] [rbp-18h]

  v6 = *(_QWORD *)(a1 + 336);
  if ( a6 < (unsigned __int64)((*(_QWORD *)(a1 + 344) - v6) / 40) )
  {
    v9 = (_QWORD *)(v6 + 40i64 * a6);
    if ( v9[3] < 8ui64 )
      v10 = (_QWORD *)(v6 + 40i64 * a6);
    else
      v10 = (_QWORD *)*v9;
    v11 = (_QWORD *)((char *)v10 + 2 * v9[2]);
    if ( v9[3] >= 8ui64 )
      v9 = (_QWORD *)*v9;
    for ( i = *a3; v9 != v11; v9 = (_QWORD *)((char *)v9 + 2) )
    {
      if ( *((_QWORD *)&i + 1) )
      {
        v12 = *(_WORD *)v9;
        if ( **(_QWORD **)(*((_QWORD *)&i + 1) + 72i64) && (v13 = *(int **)(*((_QWORD *)&i + 1) + 96i64), *v13 > 0) )
        {
          --*v13;
          v14 = *(_WORD ***)(*((_QWORD *)&i + 1) + 72i64);
          v15 = (*v14)++;
          *v15 = v12;
        }
        else
        {
          (*(void (__fastcall **)(_QWORD, _QWORD))(**((_QWORD **)&i + 1) + 24i64))(*((_QWORD *)&i + 1), v12);
        }
      }
    }
  }
  *a2 = *(_QWORD *)a3;
  a2[1] = *((_QWORD *)a3 + 1);
  return a2;
}

//----- (0000000140024F20) ----------------------------------------------------
void __fastcall sub_140024F20(__int64 a1)
{
  if ( *(_QWORD *)(a1 + 152) >= 8ui64 )
    j_free(*(void **)(a1 + 128));
  *(_QWORD *)(a1 + 152) = 7i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_WORD *)(a1 + 128) = 0;
  if ( *(_QWORD *)(a1 + 112) >= 8ui64 )
    j_free(*(void **)(a1 + 88));
  *(_QWORD *)(a1 + 112) = 7i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_WORD *)(a1 + 88) = 0;
  if ( *(_QWORD *)(a1 + 72) >= 8ui64 )
    j_free(*(void **)(a1 + 48));
  *(_QWORD *)(a1 + 72) = 7i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_WORD *)(a1 + 48) = 0;
  if ( *(_QWORD *)(a1 + 32) >= 8ui64 )
    j_free(*(void **)(a1 + 8));
  *(_QWORD *)(a1 + 32) = 7i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_WORD *)(a1 + 8) = 0;
}

//----- (0000000140024FE0) ----------------------------------------------------
void *__fastcall sub_140024FE0(void *Block, char a2)
{
  if ( *((_QWORD *)Block + 65) >= 8ui64 )
    j_free(*((void **)Block + 62));
  *((_QWORD *)Block + 65) = 7i64;
  *((_QWORD *)Block + 64) = 0i64;
  *((_WORD *)Block + 248) = 0;
  sub_140025050((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140025050) ----------------------------------------------------
void **__fastcall sub_140025050(__int64 a1)
{
  void **result; // rax

  sub_140026030(a1 + 464);
  sub_140026030(a1 + 432);
  sub_140026030(a1 + 400);
  sub_140026030(a1 + 368);
  sub_140026030(a1 + 336);
  sub_140026030(a1 + 304);
  sub_140024F20(a1 + 136);
  if ( *(_QWORD *)(a1 + 120) >= 8ui64 )
    j_free(*(void **)(a1 + 96));
  *(_QWORD *)(a1 + 120) = 7i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_WORD *)(a1 + 96) = 0;
  if ( *(_QWORD *)(a1 + 80) >= 8ui64 )
    j_free(*(void **)(a1 + 56));
  *(_QWORD *)(a1 + 80) = 7i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_WORD *)(a1 + 56) = 0;
  if ( *(_QWORD *)(a1 + 40) >= 8ui64 )
    j_free(*(void **)(a1 + 16));
  *(_QWORD *)(a1 + 40) = 7i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_WORD *)(a1 + 16) = 0;
  result = &std::locale::facet::`vftable';
  *(_QWORD *)a1 = &std::locale::facet::`vftable';
  return result;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';

//----- (0000000140025660) ----------------------------------------------------
__int64 __fastcall sub_140025660(__int64 a1)
{
  __int64 v2; // rcx
  const wchar_t *v3; // rdi
  bool v4; // zf
  __int64 v5; // rcx
  const wchar_t *v6; // rdi
  __int64 v7; // rcx
  const wchar_t *v8; // rdi
  __int64 v9; // rcx
  const wchar_t *v10; // rdi

  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 32) = 7i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_WORD *)(a1 + 8) = 0;
  v2 = -1i64;
  v3 = L"/";
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  sub_1400099E0((void *)(a1 + 8), L"/", -v2 - 2);
  *(_QWORD *)(a1 + 72) = 7i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_WORD *)(a1 + 48) = 0;
  v5 = -1i64;
  v6 = L"[";
  do
  {
    if ( !v5 )
      break;
    v4 = *v6++ == 0;
    --v5;
  }
  while ( !v4 );
  sub_1400099E0((void *)(a1 + 48), L"[", -v5 - 2);
  *(_QWORD *)(a1 + 112) = 7i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_WORD *)(a1 + 88) = 0;
  v7 = -1i64;
  v8 = L")";
  do
  {
    if ( !v7 )
      break;
    v4 = *v8++ == 0;
    --v7;
  }
  while ( !v4 );
  sub_1400099E0((void *)(a1 + 88), L")", -v7 - 2);
  *(_QWORD *)(a1 + 152) = 7i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_WORD *)(a1 + 128) = 0;
  v9 = -1i64;
  v10 = L"]";
  do
  {
    if ( !v9 )
      break;
    v4 = *v10++ == 0;
    --v9;
  }
  while ( !v4 );
  sub_1400099E0((void *)(a1 + 128), L"]", -v9 - 2);
  return a1;
}
// 1400F841C: using guessed type wchar_t asc_1400F841C[2];
// 1400F8420: using guessed type wchar_t asc_1400F8420[2];
// 1400F8424: using guessed type wchar_t asc_1400F8424[2];
// 1400F8428: using guessed type wchar_t asc_1400F8428[2];

//----- (0000000140025790) ----------------------------------------------------
_QWORD *__fastcall sub_140025790(
        __int64 *a1,
        _QWORD *a2,
        _QWORD *a3,
        __int64 a4,
        __int16 a5,
        __int64 a6,
        wchar_t *a7,
        mbstate_t a8)
{
  const _Cvtvec *v8; // r14
  wchar_t *v11; // rbx
  mbstate_t v12; // rbp
  unsigned __int16 v13; // r13
  wchar_t v14; // r8
  __int64 v15; // rcx
  int *v16; // rax
  wchar_t **v17; // rcx
  wchar_t *v18; // rdx
  wchar_t v19; // dx
  char v20; // di
  char v21; // r12
  wchar_t v22; // dx
  __int64 v23; // rax
  _QWORD *v24; // rax
  __int64 v25; // rcx
  int *v26; // rax
  unsigned __int16 **v27; // rcx
  unsigned __int16 *v28; // rdx
  int v30; // [rsp+20h] [rbp-98h]
  int v31; // [rsp+30h] [rbp-88h]
  int v32; // [rsp+38h] [rbp-80h]
  mbstate_t v33; // [rsp+40h] [rbp-78h] BYREF
  __int128 v34; // [rsp+50h] [rbp-68h] BYREF
  char v35[24]; // [rsp+60h] [rbp-58h] BYREF
  char v37; // [rsp+C8h] [rbp+10h] BYREF
  wchar_t v38; // [rsp+D0h] [rbp+18h] BYREF
  __int64 v39; // [rsp+D8h] [rbp+20h]

  v39 = a4;
  v8 = (const _Cvtvec *)(a1 + 3);
  v37 = 37;
  v38 = 0;
  v33._Wchar = 0;
  Mbrtowc(&v38, &v37, 1ui64, &v33, (const _Cvtvec *)(a1 + 3));
  v11 = a7;
  v12 = a8;
  if ( a7 == *(wchar_t **)&a8 )
    goto LABEL_29;
  v13 = v38;
  while ( 1 )
  {
    v14 = *v11;
    if ( *v11 != v13 )
    {
      v15 = a3[1];
      if ( !v15
        || (!**(_QWORD **)(v15 + 72) || (v16 = *(int **)(v15 + 96), *v16 <= 0) ? (v14 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v15 + 24i64))(
                                                                                          v15,
                                                                                          v14)) : (--*v16,
                                                                                                   v17 = *(wchar_t ***)(v15 + 72),
                                                                                                   v18 = *v17,
                                                                                                   ++*v17,
                                                                                                   *v18 = v14),
            v14 == 0xFFFF) )
      {
        *(_BYTE *)a3 = 1;
      }
      goto LABEL_19;
    }
    if ( ++v11 == *(wchar_t **)&v12 )
      break;
    v19 = *v11;
    LOBYTE(a7) = 0;
    a8._Wchar = 0;
    Wcrtomb((char *)&a7, v19, &a8, v8);
    v20 = (char)a7;
    v21 = 0;
    if ( (_BYTE)a7 == 69 || (_BYTE)a7 == 79 || (_BYTE)a7 == 81 || (_BYTE)a7 == 35 )
    {
      if ( ++v11 == *(wchar_t **)&v12 )
      {
        sub_14000F050((__int64)a3, v13);
        sub_14000F050((__int64)a3, v20);
        goto LABEL_29;
      }
      v22 = *v11;
      v21 = (char)a7;
      LOBYTE(a7) = 0;
      a8._Wchar = 0;
      Wcrtomb((char *)&a7, v22, &a8, v8);
      v20 = (char)a7;
    }
    v23 = *a1;
    LOBYTE(v32) = v21;
    v34 = *(_OWORD *)a3;
    LOBYTE(v31) = v20;
    LOWORD(v30) = a5;
    v24 = (_QWORD *)(*(__int64 (__fastcall **)(__int64 *, char *, __int128 *, __int64, int, __int64, int, int))(v23 + 8))(
                      a1,
                      v35,
                      &v34,
                      v39,
                      v30,
                      a6,
                      v31,
                      v32);
    *a3 = *v24;
    a3[1] = v24[1];
LABEL_19:
    if ( ++v11 == *(wchar_t **)&v12 )
      goto LABEL_29;
  }
  v25 = a3[1];
  if ( !v25
    || (!**(_QWORD **)(v25 + 72) || (v26 = *(int **)(v25 + 96), *v26 <= 0) ? (v13 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v25 + 24i64))(
                                                                                      v25,
                                                                                      v13)) : (--*v26,
                                                                                               v27 = *(unsigned __int16 ***)(v25 + 72),
                                                                                               v28 = *v27,
                                                                                               ++*v27,
                                                                                               *v28 = v13),
        v13 == 0xFFFF) )
  {
    *(_BYTE *)a3 = 1;
  }
LABEL_29:
  *a2 = *a3;
  a2[1] = a3[1];
  return a2;
}
// 140025956: variable 'v30' is possibly undefined
// 140025956: variable 'v31' is possibly undefined
// 140025956: variable 'v32' is possibly undefined
// 140025790: using guessed type char var_58[24];

//----- (0000000140025A10) ----------------------------------------------------
_QWORD *__fastcall sub_140025A10(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        __int64 a4,
        int a5,
        struct tm *Timeptr,
        char a7,
        char a8)
{
  size_t i; // rdi
  char *v12; // rcx
  size_t v13; // rax
  void **v14; // rbx
  void *v15; // rcx
  unsigned __int64 v16; // rdx
  const char *v17; // rbx
  size_t v18; // rsi
  const _Cvtvec *v19; // r13
  int v20; // eax
  int v21; // ecx
  __int16 v22; // r8
  __int64 v23; // rcx
  int *v24; // rax
  __int16 **v25; // rcx
  __int16 *v26; // rdx
  __int16 v28[2]; // [rsp+30h] [rbp-50h] BYREF
  char v29[12]; // [rsp+34h] [rbp-4Ch] BYREF
  void *Block[2]; // [rsp+40h] [rbp-40h] BYREF
  size_t Max_size; // [rsp+50h] [rbp-30h]
  unsigned __int64 v32; // [rsp+58h] [rbp-28h]
  char Format[4]; // [rsp+68h] [rbp-18h] BYREF
  char v34; // [rsp+6Ch] [rbp-14h]

  *(_QWORD *)&v29[4] = -2i64;
  strcpy(Format, "!%x");
  v34 = 0;
  v32 = 15i64;
  Max_size = 0i64;
  LOBYTE(Block[0]) = 0;
  if ( a8 )
  {
    Format[2] = a8;
    Format[3] = a7;
  }
  else
  {
    Format[2] = a7;
  }
  for ( i = 16i64; ; i *= 2i64 )
  {
    sub_1400055C0(Block, i, 0);
    v12 = (char *)Block;
    if ( v32 >= 0x10 )
      v12 = (char *)Block[0];
    v13 = Strftime(v12, Max_size, Format, Timeptr, *(void **)(a1 + 16));
    if ( v13 )
      break;
  }
  *(_DWORD *)v29 = 0;
  v14 = Block;
  v15 = Block[0];
  v16 = v32;
  if ( v32 >= 0x10 )
    v14 = (void **)Block[0];
  v17 = (char *)v14 + 1;
  v18 = v13 - 1;
  if ( v13 == 1 )
  {
LABEL_32:
    *a2 = *a3;
    a2[1] = a3[1];
    if ( v16 >= 0x10 )
      goto LABEL_33;
    return a2;
  }
  v19 = (const _Cvtvec *)(a1 + 24);
  while ( 1 )
  {
    v20 = Mbrtowc((wchar_t *)v28, v17, v18, (mbstate_t *)v29, v19);
    v21 = v20;
    v22 = v28[0];
    if ( v20 != -3 )
      break;
    v21 = 0;
LABEL_20:
    v18 -= v21;
    v17 += v21;
    v23 = a3[1];
    if ( !v23
      || (!**(_QWORD **)(v23 + 72) || (v24 = *(int **)(v23 + 96), *v24 <= 0) ? (v22 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v23 + 24i64))(
                                                                                        v23,
                                                                                        (unsigned __int16)v28[0])) : (--*v24, v25 = *(__int16 ***)(v23 + 72), v26 = *v25, ++*v25, *v26 = v22),
          v22 == -1) )
    {
      *(_BYTE *)a3 = 1;
    }
    if ( !v18 )
    {
      v16 = v32;
      v15 = Block[0];
      goto LABEL_32;
    }
  }
  if ( v20 <= -3 )
    goto LABEL_20;
  if ( v20 >= 0 )
  {
    if ( !v20 && !v28[0] )
      v21 = strlen(v17) + 1;
    goto LABEL_20;
  }
  *a2 = *a3;
  a2[1] = a3[1];
  if ( v32 < 0x10 )
    return a2;
  v15 = Block[0];
LABEL_33:
  j_free(v15);
  return a2;
}
// 140025A10: using guessed type wchar_t var_50[2];

//----- (0000000140025C30) ----------------------------------------------------
void *__fastcall sub_140025C30(void *Block, char a2)
{
  sub_140025050((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (0000000140025C60) ----------------------------------------------------
__int64 __fastcall sub_140025C60(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rcx

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v4 = (_QWORD *)(a1 + 8);
  v4[3] = 7i64;
  v4[2] = 0i64;
  *(_WORD *)v4 = 0;
  sub_140009610(v4, (_QWORD *)(a2 + 8), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(a1 + 72) = 7i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_WORD *)(a1 + 48) = 0;
  sub_140009610((void *)(a1 + 48), (_QWORD *)(a2 + 48), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(a1 + 112) = 7i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_WORD *)(a1 + 88) = 0;
  sub_140009610((void *)(a1 + 88), (_QWORD *)(a2 + 88), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_QWORD *)(a1 + 152) = 7i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_WORD *)(a1 + 128) = 0;
  sub_140009610((void *)(a1 + 128), (_QWORD *)(a2 + 128), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  return a1;
}

//----- (0000000140025D40) ----------------------------------------------------
void *__fastcall sub_140025D40(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  free(*((void **)Block + 2));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E4D18: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140025D90) ----------------------------------------------------
_QWORD *__fastcall sub_140025D90(_QWORD *a1, __int64 a2)
{
  __int64 v4; // r8
  unsigned __int64 v5; // rdi
  _QWORD *v6; // r8

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v4 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v5 = v4 / 40;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( v4 / 40 )
  {
    if ( v5 > 0x666666666666666i64 )
      sub_14002B5F8("vector<T> too long");
    v6 = sub_140018F20(v4 / 40);
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[5 * v5];
    a1[1] = sub_140028220(*(_QWORD **)a2, *(_QWORD **)(a2 + 8), v6);
  }
  return a1;
}

//----- (0000000140025E50) ----------------------------------------------------
void __fastcall sub_140025E50(_QWORD *a1, void *a2)
{
  unsigned __int64 v4; // rcx
  __int64 v5; // rdi
  void *v6; // rdx
  _QWORD *v7; // rcx
  _QWORD *v8; // rcx

  v4 = a1[1];
  if ( (unsigned __int64)a2 >= v4 || *a1 > (unsigned __int64)a2 )
  {
    if ( v4 == a1[2] )
      sub_140026110(a1);
    v8 = (_QWORD *)a1[1];
    if ( v8 )
    {
      v8[3] = 7i64;
      v8[2] = 0i64;
      *(_WORD *)v8 = 0;
      sub_14000B3F0(v8, a2);
    }
  }
  else
  {
    v5 = ((__int64)a2 - *a1) / 40;
    if ( v4 == a1[2] )
      sub_140026110(a1);
    v6 = (void *)(*a1 + 40 * v5);
    v7 = (_QWORD *)a1[1];
    if ( v7 )
    {
      v7[3] = 7i64;
      v7[2] = 0i64;
      *(_WORD *)v7 = 0;
      sub_14000B3F0(v7, v6);
    }
  }
  a1[1] += 40i64;
}

//----- (0000000140025F30) ----------------------------------------------------
unsigned __int64 __fastcall sub_140025F30(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  _QWORD *v6; // rsi
  __int64 v7; // r12

  if ( a2 > 0x666666666666666i64 )
    sub_14002B5F8("vector<T> too long");
  v4 = *(_QWORD *)(a1 + 16) - *(_QWORD *)a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x6666666666666667i64) >> 64) >> 63;
  if ( v4 / 40 < a2 )
  {
    v6 = sub_140018F20(a2);
    sub_1400282B0(*(void **)a1, *(void **)(a1 + 8), v6);
    v7 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) / 40i64;
    if ( *(_QWORD *)a1 )
    {
      sub_1400260B0(*(_QWORD *)a1, *(_QWORD *)(a1 + 8));
      j_free(*(void **)a1);
    }
    *(_QWORD *)(a1 + 16) = &v6[5 * a2];
    result = 5 * v7;
    *(_QWORD *)(a1 + 8) = &v6[5 * v7];
    *(_QWORD *)a1 = v6;
  }
  return result;
}

//----- (0000000140026030) ----------------------------------------------------
void __fastcall sub_140026030(__int64 a1)
{
  void **v1; // rbx
  void **i; // rsi

  v1 = *(void ***)a1;
  if ( *(_QWORD *)a1 )
  {
    for ( i = *(void ***)(a1 + 8); v1 != i; v1 += 5 )
    {
      if ( (unsigned __int64)v1[3] >= 8 )
        j_free(*v1);
      v1[3] = (void *)7;
      v1[2] = 0i64;
      *(_WORD *)v1 = 0;
    }
    j_free(*(void **)a1);
  }
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
}

//----- (00000001400260B0) ----------------------------------------------------
void __fastcall sub_1400260B0(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      if ( *(_QWORD *)(v3 + 24) >= 8ui64 )
        j_free(*(void **)v3);
      *(_QWORD *)(v3 + 24) = 7i64;
      *(_QWORD *)(v3 + 16) = 0i64;
      *(_WORD *)v3 = 0;
      v3 += 40i64;
    }
    while ( v3 != a2 );
  }
}

//----- (0000000140026110) ----------------------------------------------------
unsigned __int64 __fastcall sub_140026110(_QWORD *a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdx

  v2 = (a1[1] - *a1) / 40i64;
  if ( v2 > 0x666666666666665i64 )
    sub_14002B5F8("vector<T> too long");
  v3 = v2 + 1;
  v4 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v4 * (__int128)0x6666666666666667i64) >> 64) >> 63;
  v6 = v4 / 40;
  if ( v3 > v4 / 40 )
  {
    if ( 0x666666666666666i64 - (v6 >> 1) >= v6 )
    {
      v8 = (v6 >> 1) + v6;
      if ( v8 < v3 )
        v8 = v3;
      return sub_140025F30((__int64)a1, v8);
    }
    else
    {
      v7 = 0i64;
      if ( v3 )
        v7 = v3;
      return sub_140025F30((__int64)a1, v7);
    }
  }
  return result;
}

//----- (00000001400261D0) ----------------------------------------------------
struct std::locale::_Locimp **__fastcall sub_1400261D0(
        struct std::locale::_Locimp **a1,
        struct std::locale::_Locimp **a2,
        struct std::locale::facet *a3)
{
  struct std::locale::_Locimp *v6; // rax
  unsigned __int64 v7; // r8
  struct std::locale::_Locimp *v9; // [rsp+40h] [rbp+8h] BYREF

  v6 = (struct std::locale::_Locimp *)operator new(0x38ui64);
  v9 = v6;
  if ( v6 )
    v6 = (struct std::locale::_Locimp *)sub_14002AAD0(v6, *a2);
  *a1 = v6;
  if ( a3 )
  {
    v7 = qword_140130F78;
    if ( !qword_140130F78 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
      if ( !qword_140130F78 )
        qword_140130F78 = ++dword_14012C0B0;
      std::_Lockit::~_Lockit((std::_Lockit *)&v9);
      v7 = qword_140130F78;
    }
    std::locale::_Locimp::_Locimp_Addfac(*a1, a3, v7);
  }
  return a1;
}
// 14002AAD0: using guessed type __int64 __fastcall sub_14002AAD0(struct std::locale::_Locimp *, struct std::locale::_Locimp *);
// 14012C0B0: using guessed type int dword_14012C0B0;

//----- (0000000140026290) ----------------------------------------------------
__int64 *__fastcall sub_140026290(__int64 *a1, __int64 a2)
{
  struct std::locale::_Locimp *v4; // rsi
  char *v5; // r13
  __int64 v6; // rdx
  __int64 *v7; // rax
  char v8; // r14
  struct std::locale::_Locimp *v9; // rdi
  __int64 v10; // rax
  struct std::locale::_Locimp *v11; // rbx
  int v12; // edi
  __int64 *v13; // rax
  __int16 v14; // bx
  int v15; // eax
  void *v16; // rax
  struct std::locale::facet *v17; // r14
  __int64 *v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rax
  void (__fastcall ***v21)(_QWORD, __int64); // rbx
  __int64 v22; // rdi
  __int64 v23; // rax
  void (__fastcall ***v24)(_QWORD, __int64); // rbx
  char *v25; // r9
  struct std::locale::_Locimp *v26; // rbx
  __int64 v27; // rax
  __int64 v29; // [rsp+30h] [rbp-40h] BYREF
  __int64 v30[3]; // [rsp+38h] [rbp-38h] BYREF
  char v31; // [rsp+50h] [rbp-20h] BYREF
  __int64 v32; // [rsp+58h] [rbp-18h]
  char *v33; // [rsp+60h] [rbp-10h]
  int v34; // [rsp+68h] [rbp-8h]
  void *v35; // [rsp+B0h] [rbp+40h] BYREF
  int v36; // [rsp+C0h] [rbp+50h]
  struct std::locale::_Locimp *v37; // [rsp+C8h] [rbp+58h] BYREF

  v30[2] = -2i64;
  v4 = 0i64;
  if ( a1 )
    v5 = (char *)a1 + *(int *)(*a1 + 4);
  else
    v5 = 0i64;
  v33 = v5;
  v36 = *((_DWORD *)v5 + 6);
  v34 = v36;
  v31 = 0;
  v6 = *a1;
  v32 = *(__int64 *)((char *)a1 + *(int *)(*a1 + 4) + 72);
  v7 = sub_140008F00((__int64)a1 + *(int *)(v6 + 4), (__int64 *)&v37);
  v8 = sub_140027980(v7);
  v9 = v37;
  if ( v37 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v35, 0);
    v10 = *((_QWORD *)v9 + 1);
    if ( v10 && v10 != -1 )
      *((_QWORD *)v9 + 1) = v10 - 1;
    v11 = 0i64;
    if ( !*((_QWORD *)v9 + 1) )
      v11 = v9;
    std::_Lockit::~_Lockit((std::_Lockit *)&v35);
    if ( v11 )
      (**(void (__fastcall ***)(struct std::locale::_Locimp *, __int64))v11)(v11, 1i64);
  }
  if ( v8 )
  {
    v12 = (_DWORD)a1 + *(_DWORD *)(*a1 + 4);
    v13 = sub_140008F00((__int64)a1 + *(int *)(*a1 + 4), (__int64 *)&v37);
    v14 = *(_WORD *)((char *)a1 + *(int *)(*a1 + 4) + 88);
    v15 = sub_140027A40(v13);
    sub_140026A40(v15, (unsigned int)v30, (unsigned int)&v31, v12, v14, a2);
  }
  else
  {
    v16 = operator new(0x218ui64);
    v35 = v16;
    if ( v16 )
      v17 = (struct std::locale::facet *)sub_140024940(v16);
    else
      v17 = 0i64;
    v18 = sub_140008F00((__int64)a1 + *(int *)(*a1 + 4), &v29);
    sub_1400261D0(&v37, (struct std::locale::_Locimp **)v18, v17);
    v19 = v29;
    if ( v29 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v35, 0);
      v20 = *(_QWORD *)(v19 + 8);
      if ( v20 && v20 != -1 )
        *(_QWORD *)(v19 + 8) = v20 - 1;
      v21 = 0i64;
      if ( !*(_QWORD *)(v19 + 8) )
        v21 = (void (__fastcall ***)(_QWORD, __int64))v19;
      std::_Lockit::~_Lockit((std::_Lockit *)&v35);
      if ( v21 )
        (**v21)(v21, 1i64);
    }
    sub_14001B3E0((__int64)a1 + *(int *)(*a1 + 4), v30, (__int64 *)&v37);
    v22 = v30[0];
    if ( v30[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v35, 0);
      v23 = *(_QWORD *)(v22 + 8);
      if ( v23 && v23 != -1 )
        *(_QWORD *)(v22 + 8) = v23 - 1;
      v24 = 0i64;
      if ( !*(_QWORD *)(v22 + 8) )
        v24 = (void (__fastcall ***)(_QWORD, __int64))v22;
      std::_Lockit::~_Lockit((std::_Lockit *)&v35);
      if ( v24 )
        (**v24)(v24, 1i64);
    }
    v25 = (char *)a1 + *(int *)(*a1 + 4);
    sub_140026A40((_DWORD)v17, (unsigned int)v30, (unsigned int)&v31, (_DWORD)v25, *((_WORD *)v25 + 44), a2);
  }
  v26 = v37;
  if ( v37 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v35, 0);
    v27 = *((_QWORD *)v26 + 1);
    if ( v27 && v27 != -1 )
      *((_QWORD *)v26 + 1) = v27 - 1;
    if ( !*((_QWORD *)v26 + 1) )
      v4 = v26;
    std::_Lockit::~_Lockit((std::_Lockit *)&v35);
    if ( v4 )
      (**(void (__fastcall ***)(struct std::locale::_Locimp *, __int64))v4)(v4, 1i64);
  }
  *((_DWORD *)v5 + 6) = (unsigned __int16)v36;
  return a1;
}
// 140024940: using guessed type __int64 __fastcall sub_140024940(_QWORD);
// 140026A40: using guessed type __int64 __fastcall sub_140026A40(_DWORD, _DWORD, _DWORD, _DWORD, __int16, __int64);

//----- (0000000140026570) ----------------------------------------------------
void __fastcall sub_140026570(void *Src, _WORD *a2, _QWORD *a3)
{
  __int64 *v5; // rax
  _WORD *v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx
  bool v10; // zf
  __int128 v11; // [rsp+20h] [rbp-58h] BYREF
  __int128 v12; // [rsp+30h] [rbp-48h]
  __int64 v13; // [rsp+40h] [rbp-38h]
  __int128 v14; // [rsp+50h] [rbp-28h] BYREF
  __int64 v15; // [rsp+60h] [rbp-18h]

  v5 = sub_1400280C0(&v11, a3);
  v6 = a2;
  *(_QWORD *)&v12 = a2;
  v15 = v13;
  v7 = *v5;
  v8 = v5[1];
  *(_QWORD *)&v11 = v7;
  *((_QWORD *)&v11 + 1) = v8;
  v9 = -1i64;
  do
  {
    if ( !v9 )
      break;
    v10 = *v6++ == 0;
    --v9;
  }
  while ( !v10 );
  *((_QWORD *)&v12 + 1) = &a2[~v9 - 1];
  v14 = v12;
  sub_140027B40(Src, (__int64)&v14, &v11);
}

//----- (0000000140026760) ----------------------------------------------------
void __fastcall sub_140026760(__int64 a1)
{
  struct std::ios_base *v1; // rdi

  v1 = (struct std::ios_base *)(a1 + 136);
  *(_QWORD *)((char *)v1 + *(int *)(*(_QWORD *)a1 + 4i64) - 136) = &std::wostringstream::`vftable';
  sub_140001E20(a1 + 8);
  *(_QWORD *)((char *)v1 + *(int *)(*((_QWORD *)v1 - 17) + 4i64) - 136) = &std::wostream::`vftable';
  *(_QWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 14002677B: ignored the value written to the shadow area of the succeeding call
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';
// 1400F8520: using guessed type void *std::wostringstream::`vftable';

//----- (00000001400267E0) ----------------------------------------------------
__int64 __fastcall sub_1400267E0(__int64 a1)
{
  int v2; // edi
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // r13
  __int64 v9; // r12
  __int64 v10; // rax
  void (__fastcall ***v11)(_QWORD, __int64); // rsi
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // edx
  __int64 v15; // rcx
  __int64 v17[2]; // [rsp+30h] [rbp-68h] BYREF
  char v18; // [rsp+40h] [rbp-58h] BYREF
  __int64 v19; // [rsp+48h] [rbp-50h]
  __int64 v20; // [rsp+50h] [rbp-48h]
  char v22[56]; // [rsp+60h] [rbp-38h] BYREF
  char v23; // [rsp+B8h] [rbp+20h] BYREF

  v17[1] = -2i64;
  v2 = 0;
  v20 = a1;
  v3 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  v4 = *(int *)(*(_QWORD *)a1 + 4i64);
  if ( !*(_DWORD *)(v4 + a1 + 16) )
  {
    v5 = *(_QWORD *)(v4 + a1 + 80);
    if ( v5 )
      sub_1400086F0(v5);
  }
  v6 = *(_QWORD *)a1;
  if ( *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 16) == 0 )
  {
    v7 = sub_140008F00(a1 + *(int *)(v6 + 4), v17);
    v8 = sub_14000F240((__int64)v7);
    v9 = v17[0];
    if ( v17[0] )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v23, 0);
      v10 = *(_QWORD *)(v9 + 8);
      if ( v10 && v10 != -1 )
        *(_QWORD *)(v9 + 8) = v10 - 1;
      v11 = 0i64;
      if ( !*(_QWORD *)(v9 + 8) )
        v11 = (void (__fastcall ***)(_QWORD, __int64))v9;
      std::_Lockit::~_Lockit((std::_Lockit *)&v23);
      if ( v11 )
        (**v11)(v11, 1i64);
    }
    v12 = *(_QWORD *)(a1 + *(int *)(*(_QWORD *)a1 + 4i64) + 72);
    v18 = 0;
    v19 = v12;
    (*(void (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v8 + 40i64))(v8, v22, &v18);
    if ( v22[0] )
      v2 = 4;
  }
  v13 = a1 + *(int *)(*(_QWORD *)a1 + 4i64);
  if ( v2 )
  {
    v14 = v2 | *(_DWORD *)(v13 + 16);
    if ( !*(_QWORD *)(v13 + 72) )
      LOBYTE(v14) = v14 | 4;
    sub_140009260(v13, v14, 0);
  }
  if ( !__uncaught_exception() )
    sub_1400154C0(a1);
  v15 = *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4i64) + a1 + 72);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  return a1;
}
// 1400267E0: could not find valid save-restore pair for rbp
// 1400154C0: using guessed type __int64 __fastcall sub_1400154C0(_QWORD);
// 1400267E0: using guessed type char var_38[56];

//----- (00000001400269C0) ----------------------------------------------------
bool __fastcall sub_1400269C0(__int64 *a1)
{
  __int64 v1; // rdx

  v1 = *a1;
  if ( *a1 != 0x8000000000000000ui64 && v1 != 0x7FFFFFFFFFFFFFFFi64 )
  {
    if ( v1 != 0x7FFFFFFFFFFFFFFEi64 )
      goto LABEL_4;
    return 0;
  }
  if ( v1 == 0x7FFFFFFFFFFFFFFEi64 )
    return 0;
  if ( v1 == 0x8000000000000000ui64 )
    return 1;
  if ( v1 != 0x7FFFFFFFFFFFFFFFi64 )
  {
LABEL_4:
    if ( v1 >= 0 )
      return v1 > 0 == -1;
    return 1;
  }
  return 0;
}

//----- (00000001400277C0) ----------------------------------------------------
__int64 __fastcall sub_1400277C0(__int64 a1, __int64 a2)
{
  sub_14000CD50(a1 + 8, a2);
  return a2;
}

//----- (00000001400277F0) ----------------------------------------------------
void *__fastcall sub_1400277F0(__int64 a1, char a2)
{
  void *v2; // rdi

  v2 = (void *)(a1 - 136);
  sub_140026760(a1 - 136);
  if ( (a2 & 1) != 0 )
    j_free(v2);
  return v2;
}

//----- (0000000140027830) ----------------------------------------------------
__int64 __fastcall sub_140027830(__int64 a1, _QWORD *a2, char a3)
{
  __int64 v4; // rcx
  __int64 result; // rax

  v4 = *a2 % 1000000i64;
  if ( !a3 || v4 )
  {
    sub_140027CE0(a1, abs64(v4), 6);
    return a1;
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 7i64;
    *(_QWORD *)(a1 + 16) = 0i64;
    result = a1;
    *(_WORD *)a1 = 0;
  }
  return result;
}

//----- (00000001400278C0) ----------------------------------------------------
__int64 __fastcall sub_1400278C0(__int64 a1)
{
  sub_140027EE0(a1);
  return a1;
}

//----- (0000000140027910) ----------------------------------------------------
__int64 __fastcall sub_140027910(__int64 a1, __int64 a2, __int64 a3)
{
  void **v5; // rax
  void *Block; // [rsp+30h] [rbp+8h] BYREF

  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)a1 = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = Getcvt((_Cvtvec *)a1);
  v5 = sub_14002AAB0(a2, &Block);
  *(_QWORD *)(a1 + 16) = *v5;
  *v5 = 0i64;
  free(Block);
  return a1;
}
// 1400E4D18: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140027980) ----------------------------------------------------
__int64 __fastcall sub_140027980(__int64 *a1)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rdx
  __int64 v4; // rcx
  unsigned __int8 v5; // bl
  __int64 v7; // rax
  char v8; // [rsp+30h] [rbp+8h] BYREF
  char v9; // [rsp+38h] [rbp+10h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
  v2 = qword_140130F78;
  if ( !qword_140130F78 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v8, 0);
    if ( qword_140130F78 == v2 )
      qword_140130F78 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v8);
    v2 = qword_140130F78;
  }
  v3 = *a1;
  if ( v2 >= *(_QWORD *)(*a1 + 24) )
  {
    v4 = 0i64;
LABEL_10:
    if ( *(_BYTE *)(v3 + 36) )
    {
      v7 = sub_14002BB90();
      if ( v2 >= *(_QWORD *)(v7 + 24) )
        goto LABEL_14;
      v4 = *(_QWORD *)(*(_QWORD *)(v7 + 16) + 8 * v2);
    }
    if ( v4 )
      goto LABEL_7;
LABEL_14:
    v5 = 0;
    goto LABEL_8;
  }
  v4 = *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8 * v2);
  if ( !v4 )
    goto LABEL_10;
LABEL_7:
  v5 = 1;
LABEL_8:
  std::_Lockit::~_Lockit((std::_Lockit *)&v9);
  return v5;
}
// 14012C0B0: using guessed type int dword_14012C0B0;

//----- (0000000140027A40) ----------------------------------------------------
__int64 __fastcall sub_140027A40(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  char pExceptionObject[32]; // [rsp+28h] [rbp-20h] BYREF
  char v9; // [rsp+50h] [rbp+8h] BYREF
  char v10; // [rsp+58h] [rbp+10h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
  v2 = qword_14012E1C8;
  v3 = qword_140130F78;
  if ( !qword_140130F78 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v9, 0);
    if ( qword_140130F78 == v3 )
      qword_140130F78 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    v3 = qword_140130F78;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
    if ( v5 )
      goto LABEL_16;
  }
  if ( !*(_BYTE *)(v4 + 36) )
    goto LABEL_12;
  v6 = sub_14002BB90();
  if ( v3 < *(_QWORD *)(v6 + 24) )
  {
    v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
LABEL_12:
    if ( v5 )
      goto LABEL_16;
  }
  if ( !v2 )
  {
    sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
  }
  v5 = v2;
LABEL_16:
  std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  return v5;
}
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012E1C8: using guessed type __int64 qword_14012E1C8;

//----- (0000000140027B40) ----------------------------------------------------
void __fastcall sub_140027B40(void *Src, __int64 a2, __int128 *a3)
{
  unsigned __int64 v3; // r10
  unsigned __int16 *v6; // r9
  unsigned __int16 *v7; // rcx
  unsigned __int16 *v8; // rdx
  _WORD *v9; // r10
  unsigned __int16 *v10; // rax
  _WORD *v11; // r9
  __int128 v12; // xmm0
  __int64 v13; // xmm1_8
  unsigned __int16 *v14[2]; // [rsp+30h] [rbp-58h] BYREF
  __int128 v15; // [rsp+40h] [rbp-48h] BYREF
  __int128 v16; // [rsp+50h] [rbp-38h] BYREF
  __int64 v17[2]; // [rsp+60h] [rbp-28h] BYREF
  __int64 v18; // [rsp+70h] [rbp-18h]

  v3 = *((_QWORD *)Src + 3);
  if ( v3 < 8 )
    v6 = (unsigned __int16 *)Src;
  else
    v6 = *(unsigned __int16 **)Src;
  v7 = &v6[*((_QWORD *)Src + 2)];
  if ( v3 < 8 )
    v8 = (unsigned __int16 *)Src;
  else
    v8 = *(unsigned __int16 **)Src;
  if ( v8 != v7 )
  {
    v9 = *(_WORD **)(a2 + 8);
    while ( *(_WORD **)a2 != v9 )
    {
      v10 = v8;
      v11 = *(_WORD **)a2;
      if ( v8 != v7 )
      {
        while ( v11 != v9 )
        {
          if ( *v10 == *v11 )
          {
            ++v10;
            ++v11;
            if ( v10 != v7 )
              continue;
          }
          goto LABEL_14;
        }
LABEL_17:
        if ( v8 != v10 )
        {
          v12 = *a3;
          v13 = *(_QWORD *)(a2 + 16);
          v14[0] = v8;
          v14[1] = v10;
          v15 = v12;
          v18 = v13;
          v16 = *a3;
          *(_OWORD *)v17 = *(_OWORD *)a2;
          sub_140028550(Src, (__int64)v17, (unsigned __int16 *)&v16, v14, (unsigned __int16 **)&v15);
        }
        return;
      }
LABEL_14:
      if ( v11 == v9 )
        goto LABEL_17;
      if ( ++v8 == v7 )
        return;
    }
  }
}

//----- (0000000140027C50) ----------------------------------------------------
void __fastcall sub_140027C50(void *Src, _QWORD *a2, _QWORD *a3)
{
  __int64 *v5; // rax
  _WORD *v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rax
  _WORD *v9; // rdi
  __int64 v10; // rcx
  bool v11; // zf
  __int128 v12; // [rsp+20h] [rbp-58h] BYREF
  __int128 v13; // [rsp+30h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-38h]
  __int128 v15; // [rsp+50h] [rbp-28h] BYREF
  __int64 v16; // [rsp+60h] [rbp-18h]

  v5 = sub_1400280C0(&v12, a3);
  v6 = (_WORD *)*a2;
  v16 = v14;
  v7 = *v5;
  v8 = v5[1];
  v9 = v6;
  *(_QWORD *)&v12 = v7;
  *((_QWORD *)&v12 + 1) = v8;
  v10 = -1i64;
  *(_QWORD *)&v13 = v6;
  do
  {
    if ( !v10 )
      break;
    v11 = *v9++ == 0;
    --v10;
  }
  while ( !v11 );
  *((_QWORD *)&v13 + 1) = &v6[~v10 - 1];
  v15 = v13;
  sub_140027B40(Src, (__int64)&v15, &v12);
}

//----- (0000000140027CE0) ----------------------------------------------------
__int64 __fastcall sub_140027CE0(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r12
  void (__fastcall ***v5)(_QWORD, __int64); // rbx
  __int64 *v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11[2]; // [rsp+20h] [rbp-E0h] BYREF
  int *v12; // [rsp+30h] [rbp-D0h] BYREF
  char v13[128]; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v14[2]; // [rsp+B8h] [rbp-48h] BYREF
  int v15; // [rsp+C8h] [rbp-38h]
  char *v16; // [rsp+100h] [rbp+0h]
  __int64 v17; // [rsp+108h] [rbp+8h]
  __int16 v18; // [rsp+110h] [rbp+10h]
  __int64 v19; // [rsp+120h] [rbp+20h]
  __int64 *v20; // [rsp+188h] [rbp+88h] BYREF

  v19 = -2i64;
  v3 = a3;
  v5 = 0i64;
  v12 = (int *)&unk_1400F7238;
  v14[0] = (__int64)&std::wostream::`vftable';
  sub_140008270((__int64)v14);
  v16 = v13;
  v17 = 0i64;
  v18 = sub_1400056C0((__int64)v14);
  if ( !v16 )
    sub_140009260((__int64)v14, v15 | 4, 0);
  *(_QWORD *)&v13[v12[1] - 8] = &std::wostringstream::`vftable';
  sub_14000CCE0((__int64)v13, 2);
  v6 = (__int64 *)std::locale::classic();
  sub_14001B3E0((__int64)&v13[v12[1] - 8], v11, v6);
  v7 = v11[0];
  if ( v11[0] )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v20, 0);
    v8 = *(_QWORD *)(v7 + 8);
    if ( v8 && v8 != -1 )
      *(_QWORD *)(v7 + 8) = v8 - 1;
    if ( !*(_QWORD *)(v7 + 8) )
      v5 = (void (__fastcall ***)(_QWORD, __int64))v7;
    std::_Lockit::~_Lockit((std::_Lockit *)&v20);
    if ( v5 )
      (**v5)(v5, 1i64);
  }
  v9 = std::setw(v11, v3);
  (*(void (__fastcall **)(char *, _QWORD))v9)(&v13[v12[1] - 8], *(_QWORD *)(v9 + 8));
  *(_WORD *)&v13[v12[1] + 80] = 48;
  sub_1400267E0((__int64)&v12);
  sub_1400277C0((__int64)&v12, a1);
  v20 = v14;
  *(_QWORD *)&v13[v12[1] - 8] = &std::wostringstream::`vftable';
  sub_140001E20((__int64)v13);
  *(_QWORD *)&v13[v12[1] - 8] = &std::wostream::`vftable';
  v14[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v14);
  return a1;
}
// 14002CBD4: using guessed type __int64 __fastcall std::setw(_QWORD, _QWORD);
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';
// 1400F8520: using guessed type void *std::wostringstream::`vftable';

//----- (0000000140027EE0) ----------------------------------------------------
__int64 __fastcall sub_140027EE0(__int64 a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rbx
  __int64 *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v8[2]; // [rsp+20h] [rbp-E0h] BYREF
  int *v9; // [rsp+30h] [rbp-D0h] BYREF
  char v10[128]; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v11[2]; // [rsp+B8h] [rbp-48h] BYREF
  int v12; // [rsp+C8h] [rbp-38h]
  char *v13; // [rsp+100h] [rbp+0h]
  __int64 v14; // [rsp+108h] [rbp+8h]
  __int16 v15; // [rsp+110h] [rbp+10h]
  __int64 v16; // [rsp+120h] [rbp+20h]
  __int64 *v17; // [rsp+188h] [rbp+88h] BYREF

  v16 = -2i64;
  v2 = 0i64;
  v9 = (int *)&unk_1400F7238;
  v11[0] = (__int64)&std::wostream::`vftable';
  sub_140008270((__int64)v11);
  v13 = v10;
  v14 = 0i64;
  v15 = sub_1400056C0((__int64)v11);
  if ( !v13 )
    sub_140009260((__int64)v11, v12 | 4, 0);
  *(_QWORD *)&v10[v9[1] - 8] = &std::wostringstream::`vftable';
  sub_14000CCE0((__int64)v10, 2);
  v3 = (__int64 *)std::locale::classic();
  sub_14001B3E0((__int64)&v10[v9[1] - 8], v8, v3);
  v4 = v8[0];
  if ( v8[0] )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v17, 0);
    v5 = *(_QWORD *)(v4 + 8);
    if ( v5 && v5 != -1 )
      *(_QWORD *)(v4 + 8) = v5 - 1;
    if ( !*(_QWORD *)(v4 + 8) )
      v2 = (void (__fastcall ***)(_QWORD, __int64))v4;
    std::_Lockit::~_Lockit((std::_Lockit *)&v17);
    if ( v2 )
      (**v2)(v2, 1i64);
  }
  v6 = std::setw(v8, 2i64);
  (*(void (__fastcall **)(char *, _QWORD))v6)(&v10[v9[1] - 8], *(_QWORD *)(v6 + 8));
  *(_WORD *)&v10[v9[1] + 80] = 48;
  sub_14000C080((__int64)&v9);
  sub_1400277C0((__int64)&v9, a1);
  v17 = v11;
  *(_QWORD *)&v10[v9[1] - 8] = &std::wostringstream::`vftable';
  sub_140001E20((__int64)v10);
  *(_QWORD *)&v10[v9[1] - 8] = &std::wostream::`vftable';
  v11[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v11);
  return a1;
}
// 14002CBD4: using guessed type __int64 __fastcall std::setw(_QWORD, _QWORD);
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';
// 1400F8520: using guessed type void *std::wostringstream::`vftable';

//----- (00000001400280C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400280C0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rcx
  _QWORD *result; // rax
  void *Block[3]; // [rsp+20h] [rbp-38h] BYREF
  unsigned __int64 v8; // [rsp+38h] [rbp-20h]

  v8 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  sub_140009610(Block, a2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  if ( v8 >= 8 )
    j_free(Block[0]);
  if ( a2[3] < 8ui64 )
    v4 = a2;
  else
    v4 = (_QWORD *)*a2;
  *a1 = v4;
  if ( a2[3] < 8ui64 )
    v5 = a2;
  else
    v5 = (_QWORD *)*a2;
  result = a1;
  a1[1] = (char *)v5 + 2 * a2[2];
  return result;
}

//----- (0000000140028150) ----------------------------------------------------
_QWORD *__fastcall sub_140028150(_QWORD *a1, _WORD *a2, _WORD *a3, __int64 a4)
{
  _WORD *v5; // rbx
  __int64 v7; // rcx
  _WORD *v8; // rdi
  bool v9; // zf
  void *Block[3]; // [rsp+28h] [rbp-60h] BYREF
  unsigned __int64 v12; // [rsp+40h] [rbp-48h]

  v5 = a2;
  if ( a2 == a3 )
  {
    *a1 = a4;
  }
  else
  {
    do
    {
      v12 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v7 = -1i64;
      v8 = v5;
      do
      {
        if ( !v7 )
          break;
        v9 = *v8++ == 0;
        --v7;
      }
      while ( !v9 );
      sub_1400099E0(Block, v5, -v7 - 2);
      sub_140028460(a4, Block);
      if ( v12 >= 8 )
        j_free(Block[0]);
      v5 += 17;
    }
    while ( v5 != a3 );
    *a1 = a4;
  }
  return a1;
}
// 140028460: using guessed type __int64 __fastcall sub_140028460(_QWORD, _QWORD);

//----- (0000000140028220) ----------------------------------------------------
_QWORD *__fastcall sub_140028220(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v5; // [rsp+60h] [rbp+8h]
  _QWORD *v6; // [rsp+68h] [rbp+10h]

  v6 = a2;
  v5 = a1;
  while ( a1 != a2 )
  {
    if ( a3 )
    {
      a3[3] = 7i64;
      a3[2] = 0i64;
      *(_WORD *)a3 = 0;
      sub_140009610(a3, a1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      a2 = v6;
      a1 = v5;
    }
    a3 += 5;
    a1 += 5;
    v5 = a1;
  }
  return a3;
}
// 140028330: using guessed type __int64 __fastcall unknown_libname_16(_QWORD);

//----- (00000001400282B0) ----------------------------------------------------
_QWORD *__fastcall sub_1400282B0(void *Src, void *a2, _QWORD *a3)
{
  while ( Src != a2 )
  {
    if ( a3 )
    {
      a3[3] = 7i64;
      a3[2] = 0i64;
      *(_WORD *)a3 = 0;
      sub_14000B3F0(a3, Src);
    }
    a3 += 5;
    Src = (char *)Src + 40;
  }
  return a3;
}
// 140028330: using guessed type __int64 __fastcall unknown_libname_16(_QWORD);

//----- (0000000140028360) ----------------------------------------------------
void __fastcall sub_140028360(void *Src, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r10
  unsigned __int16 *v6; // r9
  unsigned __int16 *v7; // rcx
  unsigned __int16 *v8; // rdx
  _WORD *v9; // r11
  unsigned __int16 *v10; // rax
  _WORD *v11; // r10
  __int64 v12; // xmm1_8
  unsigned __int16 *v13[2]; // [rsp+30h] [rbp-38h] BYREF
  __int128 v14; // [rsp+40h] [rbp-28h] BYREF
  __int64 v15; // [rsp+50h] [rbp-18h]

  v3 = *((_QWORD *)Src + 3);
  if ( v3 < 8 )
    v6 = (unsigned __int16 *)Src;
  else
    v6 = *(unsigned __int16 **)Src;
  v7 = &v6[*((_QWORD *)Src + 2)];
  if ( v3 < 8 )
    v8 = (unsigned __int16 *)Src;
  else
    v8 = *(unsigned __int16 **)Src;
  if ( v8 != v7 )
  {
    v9 = *(_WORD **)(a2 + 8);
    while ( *(_WORD **)a2 != v9 )
    {
      v10 = v8;
      v11 = *(_WORD **)a2;
      if ( v8 != v7 )
      {
        while ( v11 != v9 )
        {
          if ( *v10 == *v11 )
          {
            ++v10;
            ++v11;
            if ( v10 != v7 )
              continue;
          }
          goto LABEL_14;
        }
LABEL_17:
        if ( v8 != v10 )
        {
          v12 = *(_QWORD *)(a2 + 16);
          v13[0] = v8;
          v13[1] = v10;
          v15 = v12;
          v14 = *(_OWORD *)a2;
          sub_140028E40(Src, (__int64)&v14, a3, v13);
        }
        return;
      }
LABEL_14:
      if ( v11 == v9 )
        goto LABEL_17;
      if ( ++v8 == v7 )
        return;
    }
  }
}

//----- (0000000140028550) ----------------------------------------------------
void __fastcall sub_140028550(
        void *Src,
        __int64 a2,
        unsigned __int16 *a3,
        unsigned __int16 **a4,
        unsigned __int16 **a5)
{
  unsigned __int16 *v5; // r13
  unsigned __int16 *v6; // r12
  unsigned __int16 *v7; // rsi
  unsigned __int16 *v8; // r14
  unsigned __int16 *v9; // r15
  _QWORD *v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int16 *v12; // rdi
  unsigned __int16 *v13; // rbx
  __int64 *****v14; // r13
  __int64 **v15; // r12
  __int64 ***v16; // rcx
  __int64 v17; // r13
  char *v18; // rcx
  unsigned __int16 *v19; // rax
  _WORD *v20; // r8
  _WORD *v21; // rdx
  unsigned __int16 *v22; // rcx
  unsigned __int64 v23; // rdx
  unsigned __int16 *v24; // rcx
  unsigned __int16 *v25; // r8
  unsigned __int16 *v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // r8
  _QWORD *v29; // rbx
  _QWORD *v30; // r8
  unsigned __int16 *v31; // rcx
  __int64 v32; // rax
  __int64 v33; // rcx
  __int64 v34; // rbx
  void **v35; // rcx
  void *v36; // [rsp+30h] [rbp-81h] BYREF
  void *Block; // [rsp+38h] [rbp-79h]
  __int64 v38; // [rsp+40h] [rbp-71h]
  __int64 v39; // [rsp+48h] [rbp-69h]
  __int64 v40; // [rsp+50h] [rbp-61h]
  __int64 v41[3]; // [rsp+60h] [rbp-51h] BYREF
  char *v42; // [rsp+78h] [rbp-39h] BYREF
  unsigned __int16 *v43; // [rsp+80h] [rbp-31h] BYREF
  __int64 pExceptionObject[4]; // [rsp+88h] [rbp-29h] BYREF
  __int64 v45[11]; // [rsp+A8h] [rbp-9h] BYREF
  unsigned __int16 *v48; // [rsp+120h] [rbp+6Fh] BYREF
  char v49; // [rsp+128h] [rbp+77h] BYREF

  v48 = a3;
  pExceptionObject[3] = -2i64;
  v5 = (unsigned __int16 *)Src;
  v6 = *a4;
  v7 = a4[1];
  v8 = *a5;
  v9 = a5[1];
  v36 = 0i64;
  v10 = operator new(0x10ui64);
  if ( !v10 )
  {
    v42 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v42);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v36 = v10;
  *v10 = 0i64;
  v10[1] = 0i64;
  *(_QWORD *)v36 = &v36;
  Block = 0i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v11 = *((_QWORD *)v5 + 3);
  if ( v11 < 8 )
    v12 = v5;
  else
    v12 = *(unsigned __int16 **)v5;
  if ( v11 < 8 )
    v13 = v5;
  else
    v13 = *(unsigned __int16 **)v5;
  if ( v6 != v7 )
  {
    while ( 1 )
    {
      sub_140029200(&v43, (__int64 *)&v36, (__int64)v12, v13, v6);
      v12 = v43;
      v13 = v7;
      v14 = (__int64 *****)sub_140028920((__int64 *)&v36, v45);
      v15 = 0i64;
      if ( *v14 )
      {
        v16 = **v14;
        if ( v16 )
        {
          v15 = *v16;
        }
        else
        {
          std::_Lockit::_Lockit((std::_Lockit *)&a5, 3);
          std::_Lockit::~_Lockit((std::_Lockit *)&a5);
        }
      }
      v17 = (__int64)v14[2];
      v41[0] = 0i64;
      v41[1] = 0i64;
      if ( v15 )
      {
        if ( *v15 )
        {
          v41[0] = **v15;
        }
        else
        {
          std::_Lockit::_Lockit((std::_Lockit *)&v49, 3);
          std::_Lockit::~_Lockit((std::_Lockit *)&v49);
        }
      }
      v41[2] = v17;
      sub_140029890((__int64 *)&v36, (__int64)v41, v8, v9);
      v5 = (unsigned __int16 *)Src;
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v18 = (char *)Src;
      else
        v18 = *(char **)Src;
      v19 = (unsigned __int16 *)&v18[2 * *((_QWORD *)Src + 2)];
      v6 = v7;
      if ( v7 != v19 )
      {
        v20 = *(_WORD **)(a2 + 8);
        while ( *(_WORD **)a2 != v20 )
        {
          v7 = v6;
          v21 = *(_WORD **)a2;
          if ( v6 != v19 )
          {
            while ( v21 != v20 )
            {
              if ( *v7 == *v21 )
              {
                ++v7;
                ++v21;
                if ( v7 != v19 )
                  continue;
              }
              goto LABEL_27;
            }
            goto LABEL_30;
          }
LABEL_27:
          if ( v21 == v20 )
            goto LABEL_30;
          if ( ++v6 == v19 )
            break;
        }
      }
      v7 = (unsigned __int16 *)&v18[2 * *((_QWORD *)Src + 2)];
      v6 = v7;
LABEL_30:
      if ( v6 == v7 )
        break;
      v8 = *(unsigned __int16 **)v48;
      v9 = (unsigned __int16 *)*((_QWORD *)v48 + 1);
    }
  }
  if ( *((_QWORD *)v5 + 3) < 8ui64 )
    v22 = v5;
  else
    v22 = *(unsigned __int16 **)v5;
  sub_140029200(&v48, (__int64 *)&v36, (__int64)v12, v13, &v22[*((_QWORD *)v5 + 2)]);
  if ( v40 )
  {
    v48 = (unsigned __int16 *)v41;
    v29 = sub_140028920((__int64 *)&v36, v41);
    v30 = sub_140028900((__int64 *)&v36, v45);
    if ( *((_QWORD *)v5 + 3) < 8ui64 )
      v31 = v5;
    else
      v31 = *(unsigned __int16 **)v5;
    sub_1400289D0(v5, (__int64)&v31[*((_QWORD *)v5 + 2)], (__int64)v30, (__int64)v29);
  }
  else
  {
    v23 = *((_QWORD *)v5 + 3);
    if ( v23 < 8 )
      v24 = v5;
    else
      v24 = *(unsigned __int16 **)v5;
    v25 = &v24[*((_QWORD *)v5 + 2)];
    if ( v23 < 8 )
      v26 = v5;
    else
      v26 = *(unsigned __int16 **)v5;
    if ( v48 )
      v27 = v48 - v26;
    else
      v27 = 0i64;
    if ( v25 )
      v28 = v25 - v48;
    else
      v28 = 0i64;
    sub_140009570(v5, v27, v28);
  }
  v32 = v40;
  if ( v40 )
  {
    v33 = v39;
    do
    {
      if ( !--v32 )
        v33 = 0i64;
      v39 = v33;
    }
    while ( v32 );
    v40 = 0i64;
  }
  v34 = v38;
  v35 = (void **)Block;
  while ( v34 )
  {
    if ( v35[--v34] )
    {
      j_free(v35[v34]);
      v35 = (void **)Block;
    }
  }
  if ( v35 )
    j_free(v35);
  v38 = 0i64;
  Block = 0i64;
  j_free(v36);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 140028550: using guessed type _QWORD var_58[11];

//----- (00000001400288D0) ----------------------------------------------------
void __fastcall sub_1400288D0(void **a1)
{
  sub_140028940(a1);
  j_free(*a1);
  *a1 = 0i64;
}

//----- (0000000140028900) ----------------------------------------------------
_QWORD *__fastcall sub_140028900(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // r8

  v2 = *a1;
  v3 = a1[3];
  a2[1] = 0i64;
  *a2 = v2;
  a2[2] = v3;
  return a2;
}

//----- (0000000140028920) ----------------------------------------------------
_QWORD *__fastcall sub_140028920(__int64 *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // r8
  _QWORD *result; // rax

  v2 = *a1;
  v3 = a1[4];
  a2[1] = 0i64;
  v4 = a1[3] + v3;
  *a2 = v2;
  result = a2;
  a2[2] = v4;
  return result;
}

//----- (0000000140028940) ----------------------------------------------------
void __fastcall sub_140028940(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 v3; // rdi
  __int64 v4; // rcx
  void *v5; // rcx

  v1 = a1[4];
  if ( v1 )
  {
    do
    {
      if ( v1 )
      {
        a1[4] = --v1;
        if ( !v1 )
          a1[3] = 0i64;
      }
    }
    while ( a1[4] );
  }
  v3 = a1[2];
  while ( v3 )
  {
    v4 = a1[1];
    --v3;
    if ( *(_QWORD *)(v4 + 8 * v3) )
      j_free(*(void **)(v4 + 8 * v3));
  }
  v5 = (void *)a1[1];
  if ( v5 )
    j_free(v5);
  a1[1] = 0i64;
  a1[2] = 0i64;
}

//----- (00000001400289D0) ----------------------------------------------------
__int64 __fastcall sub_1400289D0(void *Src, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v8; // rax
  __int64 *v9; // rax
  __int64 v11[3]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v12[3]; // [rsp+48h] [rbp-30h] BYREF
  char v13; // [rsp+90h] [rbp+18h] BYREF
  char v14; // [rsp+98h] [rbp+20h] BYREF

  v11[0] = 0i64;
  v11[1] = 0i64;
  if ( *(_QWORD *)a4 )
  {
    v8 = **(__int64 ***)a4;
    if ( v8 )
    {
      v11[0] = *v8;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v13, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v13);
    }
  }
  v11[2] = *(_QWORD *)(a4 + 16);
  v12[0] = 0i64;
  v12[1] = 0i64;
  if ( *(_QWORD *)a3 )
  {
    v9 = **(__int64 ***)a3;
    if ( v9 )
    {
      v12[0] = *v9;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v14, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v14);
    }
  }
  v12[2] = *(_QWORD *)(a3 + 16);
  return sub_140029340(Src, a2, (__int64)v12, (__int64)v11);
}

//----- (0000000140028AC0) ----------------------------------------------------
void __fastcall sub_140028AC0(void *Src, __int64 a2, unsigned __int16 *a3, unsigned __int16 **a4, __int64 a5)
{
  unsigned __int16 *v5; // r13
  unsigned __int16 *v6; // r12
  unsigned __int16 *v7; // rsi
  __int64 v8; // r14
  __int64 v9; // r15
  _QWORD *v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int16 *v12; // rdi
  unsigned __int16 *v13; // rbx
  __int64 *****v14; // r13
  __int64 **v15; // r12
  __int64 ***v16; // rcx
  __int64 v17; // r13
  char *v18; // rcx
  unsigned __int16 *v19; // rax
  _WORD *v20; // r8
  _WORD *v21; // rdx
  unsigned __int16 *v22; // rcx
  unsigned __int64 v23; // rdx
  unsigned __int16 *v24; // rcx
  unsigned __int16 *v25; // r8
  unsigned __int16 *v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // r8
  _QWORD *v29; // rbx
  _QWORD *v30; // r8
  unsigned __int16 *v31; // rcx
  __int64 v32; // rax
  __int64 v33; // rcx
  __int64 v34; // rbx
  void **v35; // rcx
  void *v36; // [rsp+30h] [rbp-81h] BYREF
  void *Block; // [rsp+38h] [rbp-79h]
  __int64 v38; // [rsp+40h] [rbp-71h]
  __int64 v39; // [rsp+48h] [rbp-69h]
  __int64 v40; // [rsp+50h] [rbp-61h]
  __int64 v41[3]; // [rsp+60h] [rbp-51h] BYREF
  char *v42; // [rsp+78h] [rbp-39h] BYREF
  unsigned __int16 *v43; // [rsp+80h] [rbp-31h] BYREF
  __int64 pExceptionObject[4]; // [rsp+88h] [rbp-29h] BYREF
  __int64 v45[11]; // [rsp+A8h] [rbp-9h] BYREF
  unsigned __int16 *v48; // [rsp+120h] [rbp+6Fh] BYREF
  char v49; // [rsp+128h] [rbp+77h] BYREF

  v48 = a3;
  pExceptionObject[3] = -2i64;
  v5 = (unsigned __int16 *)Src;
  v6 = *a4;
  v7 = a4[1];
  v8 = *(_QWORD *)a5;
  v9 = *(_QWORD *)(a5 + 8);
  v36 = 0i64;
  v10 = operator new(0x10ui64);
  if ( !v10 )
  {
    v42 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v42);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v36 = v10;
  *v10 = 0i64;
  v10[1] = 0i64;
  *(_QWORD *)v36 = &v36;
  Block = 0i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v11 = *((_QWORD *)v5 + 3);
  if ( v11 < 8 )
    v12 = v5;
  else
    v12 = *(unsigned __int16 **)v5;
  if ( v11 < 8 )
    v13 = v5;
  else
    v13 = *(unsigned __int16 **)v5;
  if ( v6 != v7 )
  {
    while ( 1 )
    {
      sub_140029200(&v43, (__int64 *)&v36, (__int64)v12, v13, v6);
      v12 = v43;
      v13 = v7;
      v14 = (__int64 *****)sub_140028920((__int64 *)&v36, v45);
      v15 = 0i64;
      if ( *v14 )
      {
        v16 = **v14;
        if ( v16 )
        {
          v15 = *v16;
        }
        else
        {
          std::_Lockit::_Lockit((std::_Lockit *)&a5, 3);
          std::_Lockit::~_Lockit((std::_Lockit *)&a5);
        }
      }
      v17 = (__int64)v14[2];
      v41[0] = 0i64;
      v41[1] = 0i64;
      if ( v15 )
      {
        if ( *v15 )
        {
          v41[0] = **v15;
        }
        else
        {
          std::_Lockit::_Lockit((std::_Lockit *)&v49, 3);
          std::_Lockit::~_Lockit((std::_Lockit *)&v49);
        }
      }
      v41[2] = v17;
      sub_14002A150(&v36, v41, v8, v9);
      v5 = (unsigned __int16 *)Src;
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v18 = (char *)Src;
      else
        v18 = *(char **)Src;
      v19 = (unsigned __int16 *)&v18[2 * *((_QWORD *)Src + 2)];
      v6 = v7;
      if ( v7 != v19 )
      {
        v20 = *(_WORD **)(a2 + 8);
        while ( *(_WORD **)a2 != v20 )
        {
          v7 = v6;
          v21 = *(_WORD **)a2;
          if ( v6 != v19 )
          {
            while ( v21 != v20 )
            {
              if ( *v7 == *v21 )
              {
                ++v7;
                ++v21;
                if ( v7 != v19 )
                  continue;
              }
              goto LABEL_27;
            }
            goto LABEL_30;
          }
LABEL_27:
          if ( v21 == v20 )
            goto LABEL_30;
          if ( ++v6 == v19 )
            break;
        }
      }
      v7 = (unsigned __int16 *)&v18[2 * *((_QWORD *)Src + 2)];
      v6 = v7;
LABEL_30:
      if ( v6 == v7 )
        break;
      v8 = *(_QWORD *)v48;
      v9 = *((_QWORD *)v48 + 1);
    }
  }
  if ( *((_QWORD *)v5 + 3) < 8ui64 )
    v22 = v5;
  else
    v22 = *(unsigned __int16 **)v5;
  sub_140029200(&v48, (__int64 *)&v36, (__int64)v12, v13, &v22[*((_QWORD *)v5 + 2)]);
  if ( v40 )
  {
    v48 = (unsigned __int16 *)v41;
    v29 = sub_140028920((__int64 *)&v36, v41);
    v30 = sub_140028900((__int64 *)&v36, v45);
    if ( *((_QWORD *)v5 + 3) < 8ui64 )
      v31 = v5;
    else
      v31 = *(unsigned __int16 **)v5;
    sub_1400289D0(v5, (__int64)&v31[*((_QWORD *)v5 + 2)], (__int64)v30, (__int64)v29);
  }
  else
  {
    v23 = *((_QWORD *)v5 + 3);
    if ( v23 < 8 )
      v24 = v5;
    else
      v24 = *(unsigned __int16 **)v5;
    v25 = &v24[*((_QWORD *)v5 + 2)];
    if ( v23 < 8 )
      v26 = v5;
    else
      v26 = *(unsigned __int16 **)v5;
    if ( v48 )
      v27 = v48 - v26;
    else
      v27 = 0i64;
    if ( v25 )
      v28 = v25 - v48;
    else
      v28 = 0i64;
    sub_140009570(v5, v27, v28);
  }
  v32 = v40;
  if ( v40 )
  {
    v33 = v39;
    do
    {
      if ( !--v32 )
        v33 = 0i64;
      v39 = v33;
    }
    while ( v32 );
    v40 = 0i64;
  }
  v34 = v38;
  v35 = (void **)Block;
  while ( v34 )
  {
    if ( v35[--v34] )
    {
      j_free(v35[v34]);
      v35 = (void **)Block;
    }
  }
  if ( v35 )
    j_free(v35);
  v38 = 0i64;
  Block = 0i64;
  j_free(v36);
}
// 14002A150: using guessed type __int64 __fastcall sub_14002A150(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 140028AC0: using guessed type _QWORD var_58[11];

//----- (0000000140028E40) ----------------------------------------------------
void __fastcall sub_140028E40(void *Src, __int64 a2, __int64 a3, unsigned __int16 **a4)
{
  unsigned __int16 *v6; // r12
  unsigned __int16 *v7; // rsi
  _QWORD *v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int16 *v10; // rdi
  unsigned __int16 *v11; // rbx
  __int64 *****v12; // rax
  __int64 *****v13; // r13
  __int64 **v14; // r12
  __int64 ***v15; // rcx
  __int64 v16; // r13
  unsigned __int16 *v17; // rcx
  unsigned __int16 *v18; // rax
  _WORD *v19; // r8
  _WORD *v20; // rdx
  unsigned __int16 *v21; // rcx
  unsigned __int64 v22; // rdx
  unsigned __int16 *v23; // rcx
  unsigned __int16 *v24; // r8
  unsigned __int16 *v25; // rcx
  __int64 v26; // rdx
  __int64 v27; // r8
  _QWORD *v28; // rbx
  _QWORD *v29; // r8
  unsigned __int16 *v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rcx
  __int64 v33; // rbx
  void **v34; // rcx
  void *v35; // [rsp+38h] [rbp-71h] BYREF
  void *Block; // [rsp+40h] [rbp-69h]
  __int64 v37; // [rsp+48h] [rbp-61h]
  __int64 v38; // [rsp+50h] [rbp-59h]
  __int64 v39; // [rsp+58h] [rbp-51h]
  char v40[8]; // [rsp+68h] [rbp-41h] BYREF
  __int64 v41[3]; // [rsp+70h] [rbp-39h] BYREF
  char *v42; // [rsp+88h] [rbp-21h] BYREF
  unsigned __int16 *v43[2]; // [rsp+90h] [rbp-19h] BYREF
  __int64 pExceptionObject[3]; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v45[4]; // [rsp+B8h] [rbp+Fh] BYREF
  char *v46; // [rsp+120h] [rbp+77h] BYREF

  v43[1] = (unsigned __int16 *)-2i64;
  v6 = *a4;
  v7 = a4[1];
  v35 = 0i64;
  v8 = operator new(0x10ui64);
  if ( !v8 )
  {
    v42 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v42);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v35 = v8;
  *v8 = 0i64;
  v8[1] = 0i64;
  *(_QWORD *)v35 = &v35;
  Block = 0i64;
  v37 = 0i64;
  v38 = 0i64;
  v39 = 0i64;
  v9 = *((_QWORD *)Src + 3);
  if ( v9 < 8 )
    v10 = (unsigned __int16 *)Src;
  else
    v10 = *(unsigned __int16 **)Src;
  if ( v9 < 8 )
    v11 = (unsigned __int16 *)Src;
  else
    v11 = *(unsigned __int16 **)Src;
  while ( v6 != v7 )
  {
    sub_140029200(v43, (__int64 *)&v35, (__int64)v10, v11, v6);
    v10 = v43[0];
    v11 = v7;
    v12 = (__int64 *****)sub_140028920((__int64 *)&v35, v45);
    v13 = v12;
    v14 = 0i64;
    if ( *v12 )
    {
      v15 = **v12;
      if ( v15 )
      {
        v14 = *v15;
      }
      else
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v46, 3);
        std::_Lockit::~_Lockit((std::_Lockit *)&v46);
      }
    }
    v16 = (__int64)v13[2];
    v41[0] = 0i64;
    v41[1] = 0i64;
    if ( v14 )
    {
      if ( *v14 )
      {
        v41[0] = **v14;
      }
      else
      {
        std::_Lockit::_Lockit((std::_Lockit *)v40, 3);
        std::_Lockit::~_Lockit((std::_Lockit *)v40);
      }
    }
    v41[2] = v16;
    sub_14002A150(&v35, v41, 0i64, 0i64);
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v17 = (unsigned __int16 *)Src;
    else
      v17 = *(unsigned __int16 **)Src;
    v18 = &v17[*((_QWORD *)Src + 2)];
    v6 = v7;
    if ( v7 != v18 )
    {
      v19 = *(_WORD **)(a2 + 8);
      while ( *(_WORD **)a2 != v19 )
      {
        v7 = v6;
        v20 = *(_WORD **)a2;
        if ( v6 != v18 )
        {
          while ( v20 != v19 )
          {
            if ( *v7 == *v20 )
            {
              ++v7;
              ++v20;
              if ( v7 != v18 )
                continue;
            }
            goto LABEL_27;
          }
          goto LABEL_30;
        }
LABEL_27:
        if ( v20 == v19 )
          goto LABEL_30;
        if ( ++v6 == v18 )
          break;
      }
    }
    v7 = &v17[*((_QWORD *)Src + 2)];
    v6 = v7;
LABEL_30:
    ;
  }
  if ( *((_QWORD *)Src + 3) < 8ui64 )
    v21 = (unsigned __int16 *)Src;
  else
    v21 = *(unsigned __int16 **)Src;
  sub_140029200((unsigned __int16 **)&v46, (__int64 *)&v35, (__int64)v10, v11, &v21[*((_QWORD *)Src + 2)]);
  if ( v39 )
  {
    v46 = (char *)v41;
    v28 = sub_140028920((__int64 *)&v35, v41);
    v29 = sub_140028900((__int64 *)&v35, v45);
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v30 = (unsigned __int16 *)Src;
    else
      v30 = *(unsigned __int16 **)Src;
    sub_1400289D0(Src, (__int64)&v30[*((_QWORD *)Src + 2)], (__int64)v29, (__int64)v28);
  }
  else
  {
    v22 = *((_QWORD *)Src + 3);
    if ( v22 < 8 )
      v23 = (unsigned __int16 *)Src;
    else
      v23 = *(unsigned __int16 **)Src;
    v24 = &v23[*((_QWORD *)Src + 2)];
    if ( v22 < 8 )
      v25 = (unsigned __int16 *)Src;
    else
      v25 = *(unsigned __int16 **)Src;
    if ( v46 )
      v26 = (v46 - (char *)v25) >> 1;
    else
      v26 = 0i64;
    if ( v24 )
      v27 = ((char *)v24 - v46) >> 1;
    else
      v27 = 0i64;
    sub_140009570(Src, v26, v27);
  }
  v31 = v39;
  if ( v39 )
  {
    v32 = v38;
    do
    {
      if ( !--v31 )
        v32 = 0i64;
      v38 = v32;
    }
    while ( v31 );
    v39 = 0i64;
  }
  v33 = v37;
  v34 = (void **)Block;
  while ( v33 )
  {
    if ( v34[--v33] )
    {
      j_free(v34[v33]);
      v34 = (void **)Block;
    }
  }
  if ( v34 )
    j_free(v34);
  v37 = 0i64;
  Block = 0i64;
  j_free(v35);
}
// 14002A150: using guessed type __int64 __fastcall sub_14002A150(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 140028E40: using guessed type _QWORD var_40[4];
// 140028E40: using guessed type char var_90[8];

//----- (00000001400291A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400291A0(_QWORD *a1, __int64 a2)
{
  _QWORD *v4; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  *a1 = 0i64;
  a1[1] = 0i64;
  if ( *(_QWORD *)a2 )
  {
    v4 = **(_QWORD ***)a2;
    if ( v4 )
    {
      *a1 = *v4;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v6, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v6);
    }
  }
  a1[2] = *(_QWORD *)(a2 + 16);
  return a1;
}

//----- (0000000140029200) ----------------------------------------------------
unsigned __int16 **__fastcall sub_140029200(
        unsigned __int16 **a1,
        __int64 *a2,
        __int64 a3,
        void *a4,
        unsigned __int16 *a5)
{
  unsigned __int16 *v7; // rbx
  unsigned __int16 **result; // rax
  size_t v9; // rdi
  __int64 **v10; // r8
  __int64 v11; // rax
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // r8
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18[7]; // [rsp+20h] [rbp-38h] BYREF
  void *v19; // [rsp+68h] [rbp+10h] BYREF
  void *Src; // [rsp+78h] [rbp+20h]

  Src = a4;
  sub_140029790(&v19, a2, a3, (__int64)a4);
  v7 = (unsigned __int16 *)v19;
  if ( a2[4] )
  {
    if ( v19 != a5 )
    {
      do
      {
        sub_140029470((__int64)a2, v7);
        v10 = (__int64 **)sub_140028900(a2, v18);
        if ( *v10 )
          v11 = **v10;
        else
          v11 = 0i64;
        v12 = *(_QWORD *)(v11 + 16);
        v13 = (unsigned __int64)v10[2];
        v14 = v13 & 7;
        v15 = v13 >> 3;
        if ( v12 <= v15 )
          v15 -= v12;
        *v7 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8) + 8 * v15) + 2 * v14);
        v16 = a2[4];
        if ( v16 )
        {
          v17 = ++a2[3];
          if ( 8 * a2[2] <= v17 )
            v17 = 0i64;
          a2[4] = v16 - 1;
          a2[3] = v17;
          if ( v16 == 1 )
            a2[3] = 0i64;
        }
        ++v7;
      }
      while ( v7 != a5 );
    }
    *a1 = v7;
    return a1;
  }
  else if ( v19 == Src )
  {
    *a1 = a5;
    return a1;
  }
  else
  {
    v9 = ((char *)a5 - (_BYTE *)Src) >> 1;
    memmove(v19, Src, v9 * 2);
    result = a1;
    *a1 = &v7[v9];
  }
  return result;
}
// 140029200: using guessed type __int64 var_38[7];

//----- (0000000140029340) ----------------------------------------------------
__int64 __fastcall sub_140029340(void *Src, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v7; // rax
  __int64 *v8; // rax
  __int64 v10[3]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v11[6]; // [rsp+48h] [rbp-30h] BYREF
  char v13; // [rsp+90h] [rbp+18h] BYREF
  char v14; // [rsp+98h] [rbp+20h] BYREF

  v10[0] = 0i64;
  v10[1] = 0i64;
  if ( *(_QWORD *)a4 )
  {
    v7 = **(__int64 ***)a4;
    if ( v7 )
    {
      v10[0] = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v13, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v13);
    }
  }
  v10[2] = *(_QWORD *)(a4 + 16);
  v11[0] = 0i64;
  v11[1] = 0i64;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(__int64 ***)a3;
    if ( v8 )
    {
      v11[0] = *v8;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v14, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v14);
    }
  }
  v11[2] = *(_QWORD *)(a3 + 16);
  return sub_140029AE0(Src, a2, (__int64)v11, (__int64)v10);
}

//----- (0000000140029430) ----------------------------------------------------
void __fastcall sub_140029430(_QWORD *a1)
{
  __int64 v1; // r8
  unsigned __int64 v2; // rdx

  v1 = a1[4];
  if ( v1 )
  {
    v2 = ++a1[3];
    if ( 8i64 * a1[2] <= v2 )
      v2 = 0i64;
    a1[4] = v1 - 1;
    a1[3] = v2;
    if ( v1 == 1 )
      a1[3] = 0i64;
  }
}

//----- (0000000140029470) ----------------------------------------------------
__int64 __fastcall sub_140029470(__int64 a1, unsigned __int16 *a2)
{
  __int64 v3; // rcx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  void *v8; // rax
  __int64 result; // rax
  _WORD *v10; // rcx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v12; // [rsp+50h] [rbp+8h] BYREF

  v3 = *(_QWORD *)(a1 + 32);
  if ( ((*(_BYTE *)(a1 + 24) + (_BYTE)v3) & 7) == 0 && *(_QWORD *)(a1 + 16) <= (unsigned __int64)(v3 + 8) >> 3 )
    sub_140029560((_QWORD *)a1);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
  v7 = v6 >> 3;
  if ( v5 <= v6 >> 3 )
    v7 -= v5;
  if ( !*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7) )
  {
    v8 = operator new(0x10ui64);
    if ( !v8 )
    {
      v12 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7) = v8;
  }
  result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7);
  v10 = (_WORD *)(result + 2 * (v6 & 7));
  if ( v10 )
  {
    result = *a2;
    *v10 = result;
  }
  ++*(_QWORD *)(a1 + 32);
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140029560) ----------------------------------------------------
void __fastcall sub_140029560(_QWORD *a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rax
  char *v5; // r12
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // rcx
  __int64 v8; // r13
  unsigned __int64 v9; // rbx
  char *v10; // rax
  const void *v11; // rdx
  char *v12; // rcx
  char *v13; // rax
  void *v14; // rcx
  size_t v15; // r8
  char *v16; // rax
  void *v17; // rcx
  __int64 pExceptionObject[4]; // [rsp+20h] [rbp-48h] BYREF
  char *v19; // [rsp+70h] [rbp+8h] BYREF

  v2 = a1[2];
  v3 = 1i64;
  if ( v2 == 0xFFFFFFFFFFFFFFFi64 )
    sub_14002B5F8("deque<T> too long");
  v4 = v2 >> 1;
  if ( v2 >> 1 >= 8 )
  {
    if ( v4 <= 1 )
      goto LABEL_8;
  }
  else
  {
    v4 = 8i64;
  }
  if ( v2 <= 0xFFFFFFFFFFFFFFFi64 - v4 )
    v3 = v4;
LABEL_8:
  v5 = 0i64;
  v6 = a1[3] >> 3;
  v7 = v3 + v2;
  if ( v7 )
  {
    if ( v7 > 0x1FFFFFFFFFFFFFFFi64 || (v5 = (char *)operator new(8 * v7)) == 0i64 )
    {
      v19 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v19);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  v8 = 8 * v6;
  v9 = (8i64 * a1[2] - 8 * v6) & 0xFFFFFFFFFFFFFFF8ui64;
  v10 = (char *)memmove(&v5[8 * v6], (const void *)(8 * v6 + a1[1]), v9);
  v11 = (const void *)a1[1];
  v12 = &v10[v9];
  if ( v6 > v3 )
  {
    memmove(v12, v11, 8 * v3);
    v16 = (char *)memmove(v5, (const void *)(8 * v3 + a1[1]), 8 * ((__int64)(v8 - 8 * v3) >> 3))
        + 8 * ((__int64)(v8 - 8 * v3) >> 3);
    v14 = v16;
    v15 = 8 * v3;
    goto LABEL_19;
  }
  v13 = (char *)memmove(v12, v11, 8 * (v8 >> 3)) + 8 * (v8 >> 3);
  if ( v3 != v6 )
    memset(v13, 0, 8 * (v3 - v6));
  if ( v6 )
  {
    v14 = v5;
    v15 = 8 * v6;
LABEL_19:
    memset(v14, 0, v15);
  }
  v17 = (void *)a1[1];
  if ( v17 )
    j_free(v17);
  a1[2] += v3;
  a1[1] = v5;
}
// 1400296FD: conditional instruction was optimized away because rsi.8!=0
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140029750) ----------------------------------------------------
__int64 __fastcall sub_140029750(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // rcx
  __int64 v4; // r8
  unsigned __int64 v5; // rcx

  v1 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
    v1 = (_QWORD *)*v1;
  v2 = v1[2];
  v3 = *(_QWORD *)(a1 + 16);
  v4 = v3 & 7;
  v5 = v3 >> 3;
  if ( v2 <= v5 )
    v5 -= v2;
  return *(_QWORD *)(v1[1] + 8 * v5) + 2 * v4;
}

//----- (0000000140029790) ----------------------------------------------------
_QWORD *__fastcall sub_140029790(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  bool v4; // zf
  __int64 **v7; // r11
  __int64 v8; // rax
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // r8
  unsigned __int64 v13; // rcx
  __int64 v15[5]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v16; // [rsp+68h] [rbp+20h]

  v16 = a4;
  v4 = a2[4] == 0;
  *a1 = a3;
  if ( v4 )
    return a1;
  while ( *a1 != a4 )
  {
    v7 = (__int64 **)sub_140028900(a2, v15);
    v8 = 0i64;
    if ( *v7 )
      v8 = **v7;
    v9 = *(_QWORD *)(v8 + 16);
    v10 = (unsigned __int64)v7[2] >> 3;
    if ( v9 <= v10 )
      v10 -= v9;
    v11 = *a1;
    *(_WORD *)*a1 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 8 * v10) + 2 * ((unsigned __int64)v7[2] & 7));
    v12 = a2[4];
    if ( v12 )
    {
      v13 = ++a2[3];
      if ( 8 * a2[2] <= v13 )
        v13 = 0i64;
      a2[4] = v12 - 1;
      a2[3] = v13;
      if ( v12 == 1 )
        a2[3] = 0i64;
    }
    *a1 = v11 + 2;
    if ( !a2[4] )
      break;
    a4 = v16;
  }
  return a1;
}
// 140029790: using guessed type __int64 var_28[5];

//----- (0000000140029890) ----------------------------------------------------
unsigned __int16 *__fastcall sub_140029890(__int64 *a1, __int64 a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int64 v5; // r13
  unsigned __int64 v6; // rbx
  unsigned __int16 *result; // rax
  unsigned __int16 *v8; // rcx
  __int64 v9; // rsi
  _QWORD *v10; // rax
  _QWORD *v11; // rbx
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  _QWORD *v14; // rax
  _QWORD *v15; // rdi
  _QWORD *v16; // rax
  _QWORD *v17; // rbx
  _QWORD *v18; // rax
  _QWORD *v19; // r9
  _QWORD *v20; // r8
  _QWORD *v21; // rdx
  __int64 *v22; // rcx
  _QWORD *v23; // rdi
  _QWORD *v24; // rax
  _QWORD *v25; // rbx
  _QWORD *v26; // rax
  _QWORD *v27; // rax
  __int64 v28[3]; // [rsp+20h] [rbp-D8h] BYREF
  __int64 v29[4]; // [rsp+38h] [rbp-C0h] BYREF
  __int64 v30[3]; // [rsp+58h] [rbp-A0h] BYREF
  __int64 v31[3]; // [rsp+70h] [rbp-88h] BYREF
  __int64 v32[3]; // [rsp+88h] [rbp-70h] BYREF
  __int64 v33[3]; // [rsp+A0h] [rbp-58h] BYREF
  __int64 v34[8]; // [rsp+B8h] [rbp-40h] BYREF

  v29[3] = -2i64;
  v5 = *(_QWORD *)(a2 + 16) - sub_140028900(a1, v29)[2];
  v6 = a1[4];
  result = a3;
  v8 = a4;
  if ( a3 != a4 )
  {
    if ( v5 > v6 >> 1 )
    {
      while ( result != v8 )
      {
        sub_140029470((__int64)a1, result);
        result = ++a3;
        v8 = a4;
      }
      v23 = sub_140028920(a1, v29);
      v24 = sub_140028900(a1, v34);
      v25 = sub_140029CD0((__int64)v24, v28, v6);
      v26 = sub_140028900(a1, v32);
      v27 = sub_140029CD0((__int64)v26, v31, v5);
      v19 = v23;
      v20 = v25;
      v21 = v27;
      v22 = v33;
    }
    else
    {
      while ( result != v8 )
      {
        sub_140029BE0(a1, result);
        result = ++a3;
        v8 = a4;
      }
      v9 = a1[4] - v6;
      v10 = sub_140028900(a1, v29);
      v11 = sub_140029CD0((__int64)v10, v28, v9);
      v12 = sub_140028900(a1, v30);
      sub_140029D80((__int64)v12, (__int64)v11);
      v13 = sub_140028900(a1, v30);
      v14 = sub_140029CD0((__int64)v13, v33, v9);
      v15 = sub_140029CD0((__int64)v14, v28, v5);
      v16 = sub_140028900(a1, v31);
      v17 = sub_140029CD0((__int64)v16, v29, v9);
      v18 = sub_140028900(a1, v32);
      v19 = v15;
      v20 = v17;
      v21 = v18;
      v22 = v34;
    }
    return (unsigned __int16 *)sub_140029EE0(v22, v21, v20, v19);
  }
  return result;
}
// 140029EE0: using guessed type __int64 __fastcall sub_140029EE0(_QWORD, _QWORD, _QWORD, _QWORD);
// 140029890: using guessed type _QWORD var_D8[3];
// 140029890: using guessed type _QWORD var_A0[3];
// 140029890: using guessed type _QWORD var_58[3];
// 140029890: using guessed type _QWORD var_88[3];
// 140029890: using guessed type _QWORD var_70[3];
// 140029890: using guessed type _QWORD var_40[8];

//----- (0000000140029AE0) ----------------------------------------------------
__int64 __fastcall sub_140029AE0(void *Src, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v7; // rax
  __int64 *v8; // rax
  __int64 v10[3]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v11[6]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v12; // [rsp+98h] [rbp+10h]
  char v13; // [rsp+A0h] [rbp+18h] BYREF
  char v14; // [rsp+A8h] [rbp+20h] BYREF

  v12 = a2;
  v10[0] = 0i64;
  v10[1] = 0i64;
  if ( *(_QWORD *)a4 )
  {
    v7 = **(__int64 ***)a4;
    if ( v7 )
    {
      v10[0] = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v13, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v13);
      a2 = v12;
    }
  }
  v10[2] = *(_QWORD *)(a4 + 16);
  v11[0] = 0i64;
  v11[1] = 0i64;
  if ( *(_QWORD *)a3 )
  {
    v8 = **(__int64 ***)a3;
    if ( v8 )
    {
      v11[0] = *v8;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v14, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v14);
      a2 = v12;
    }
  }
  v11[2] = *(_QWORD *)(a3 + 16);
  return sub_14002A050(Src, a2, a2, (__int64)v11, (__int64)v10);
}

//----- (0000000140029BE0) ----------------------------------------------------
__int64 __fastcall sub_140029BE0(_QWORD *a1, unsigned __int16 *a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  void *v7; // rax
  __int64 result; // rax
  _WORD *v9; // rdx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v11; // [rsp+50h] [rbp+8h] BYREF

  if ( (a1[3] & 7) == 0 && a1[2] <= (unsigned __int64)(a1[4] + 8i64) >> 3 )
    sub_140029560(a1);
  v4 = a1[3];
  if ( !v4 )
    v4 = 8i64 * a1[2];
  v5 = v4 - 1;
  v6 = v5 >> 3;
  if ( !*(_QWORD *)(a1[1] + 8 * (v5 >> 3)) )
  {
    v7 = operator new(0x10ui64);
    if ( !v7 )
    {
      v11 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v11);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *(_QWORD *)(a1[1] + 8 * v6) = v7;
  }
  result = *(_QWORD *)(a1[1] + 8 * v6);
  v9 = (_WORD *)(result + 2 * (v5 & 7));
  if ( v9 )
  {
    result = *a2;
    *v9 = result;
  }
  ++a1[4];
  a1[3] = v5;
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140029CD0) ----------------------------------------------------
_QWORD *__fastcall sub_140029CD0(__int64 a1, _QWORD *a2, __int64 a3)
{
  _QWORD **v3; // rsi
  _QWORD ***v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdi
  char v11; // [rsp+30h] [rbp+8h] BYREF

  v3 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v7 = **(_QWORD *****)a1;
    if ( v7 )
    {
      v3 = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v11, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v11);
    }
  }
  v8 = *(_QWORD *)(a1 + 16);
  *a2 = 0i64;
  a2[1] = 0i64;
  v9 = a3 + v8;
  if ( v3 )
  {
    if ( *v3 )
    {
      *a2 = **v3;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v11, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v11);
    }
  }
  a2[2] = v9;
  return a2;
}

//----- (0000000140029D80) ----------------------------------------------------
__int64 __fastcall sub_140029D80(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 *v5; // rdi
  __int64 **v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 *v9; // rdi
  __int64 **v10; // rax
  __int64 result; // rax
  unsigned __int64 v12; // r10
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // r8
  __int64 v16; // r11
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rdx
  __int64 v19; // rbx
  __int64 v20; // r8
  __int64 v21; // rdx
  __int16 v22; // cx
  __int128 v23; // [rsp+20h] [rbp-28h]
  __int64 v24; // [rsp+20h] [rbp-28h]
  __int128 v25; // [rsp+30h] [rbp-18h]
  char v26; // [rsp+50h] [rbp+8h] BYREF

  v2 = 0i64;
  v5 = 0i64;
  if ( *(_QWORD *)a2 )
  {
    v6 = **(__int64 ****)a2;
    if ( v6 )
    {
      v5 = *v6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v26, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v26);
    }
  }
  v7 = *(_QWORD *)(a2 + 16);
  v8 = 0i64;
  if ( v5 )
    v8 = *v5;
  *(_QWORD *)&v23 = v8;
  *((_QWORD *)&v23 + 1) = v7;
  v25 = v23;
  v9 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v10 = **(__int64 ****)a1;
    if ( v10 )
    {
      v9 = *v10;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v26, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v26);
    }
  }
  result = *(_QWORD *)(a1 + 16);
  if ( v9 )
    v2 = *v9;
  v24 = v2;
  if ( result != v7 )
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *((_QWORD *)&v25 + 1);
    do
    {
      if ( v12 == --v13 )
        break;
      v14 = *(_QWORD *)(v25 + 16);
      v15 = v13 >> 3;
      v16 = v13 & 7;
      if ( v14 <= v13 >> 3 )
        v15 -= v14;
      v17 = *(_QWORD *)(v24 + 16);
      v18 = v12 >> 3;
      v19 = v12 & 7;
      if ( v17 <= v12 >> 3 )
        v18 -= v17;
      ++v12;
      v20 = *(_QWORD *)(*(_QWORD *)(v25 + 8) + 8 * v15);
      v21 = *(_QWORD *)(*(_QWORD *)(v24 + 8) + 8 * v18);
      result = *(unsigned __int16 *)(v20 + 2 * v16);
      v22 = *(_WORD *)(v21 + 2 * v19);
      *(_WORD *)(v21 + 2 * v19) = result;
      *(_WORD *)(v20 + 2 * v16) = v22;
    }
    while ( v12 != v13 );
  }
  return result;
}

//----- (000000014002A050) ----------------------------------------------------
__int64 __fastcall sub_14002A050(void *Src, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v7; // rbx
  __int64 *v8; // rax
  __int64 *v9; // rax
  __int64 v11[3]; // [rsp+40h] [rbp-48h] BYREF
  __int64 v12; // [rsp+58h] [rbp-30h]
  __int64 v13; // [rsp+60h] [rbp-28h]
  __int64 v14; // [rsp+68h] [rbp-20h]
  char v15; // [rsp+A8h] [rbp+20h] BYREF

  v11[0] = 0i64;
  v11[1] = 0i64;
  v7 = a5;
  if ( *(_QWORD *)a5 )
  {
    v8 = **(__int64 ***)a5;
    if ( v8 )
    {
      v11[0] = *v8;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&a5, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&a5);
    }
  }
  v11[2] = *(_QWORD *)(v7 + 16);
  v12 = 0i64;
  v13 = 0i64;
  if ( *(_QWORD *)a4 )
  {
    v9 = **(__int64 ***)a4;
    if ( v9 )
    {
      v12 = *v9;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v15, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v15);
    }
  }
  v14 = *(_QWORD *)(a4 + 16);
  return sub_14002A420(Src, (__int64)v11);
}

//----- (000000014002A370) ----------------------------------------------------
__int64 __fastcall sub_14002A370(_QWORD *a1, __int64 a2)
{
  __int64 *v4; // rax
  __int64 v5; // rax
  __int64 v7[2]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v8; // [rsp+38h] [rbp-10h]
  char v9; // [rsp+50h] [rbp+8h] BYREF
  char v10; // [rsp+58h] [rbp+10h] BYREF
  __int64 *v11; // [rsp+60h] [rbp+18h]

  v11 = v7;
  v7[0] = 0i64;
  v7[1] = 0i64;
  if ( *(_QWORD *)a2 )
  {
    v4 = **(__int64 ***)a2;
    if ( v4 )
    {
      v7[0] = *v4;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v9, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v9);
    }
  }
  v5 = *(_QWORD *)(a2 + 16);
  v8 = v5;
  if ( *a1 && !*(_QWORD *)*a1 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v5 = v8;
  }
  return v5 - a1[2];
}

//----- (000000014002A580) ----------------------------------------------------
__int64 __fastcall sub_14002A580(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // r10
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // r12
  __int64 v11; // rax
  __int64 v12; // rt2
  __int64 v13; // rsi
  __int128 *v14; // rax
  __int128 v15; // xmm0
  unsigned __int64 v16; // r9
  __int64 v17; // rcx
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // r8
  __int64 v20; // r11
  __int64 v21; // rdi
  unsigned __int64 v22; // rax
  __int64 v23; // rbx
  __int64 v24; // rdx
  __int64 v25; // r8
  __int64 v26; // rdx
  __int16 v27; // cx
  __int64 v28; // rcx
  __int128 *v29; // r9
  __int128 v30; // [rsp+0h] [rbp-49h]
  __int128 v31; // [rsp+10h] [rbp-39h]
  __int128 v32; // [rsp+20h] [rbp-29h]
  __int128 v33; // [rsp+30h] [rbp-19h]
  __int128 v34; // [rsp+40h] [rbp-9h]
  __int128 v35; // [rsp+50h] [rbp+7h]
  __int128 v36; // [rsp+60h] [rbp+17h] BYREF
  __int128 v37; // [rsp+70h] [rbp+27h] BYREF
  __int128 v38; // [rsp+80h] [rbp+37h] BYREF

  result = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a2 + 8) - result;
  v7 = *(_QWORD *)(a3 + 8);
  v8 = v5;
  v9 = v7 - result;
  v10 = v7 - result;
  if ( *(_QWORD *)(a2 + 8) != result )
  {
    do
    {
      v11 = v10;
      v10 = v8;
      v12 = v11 % v8;
      result = v11 / v8;
      v8 = v12;
    }
    while ( v12 );
  }
  if ( v10 < v9 && v10 > 0 )
  {
    do
    {
      v31 = *(_OWORD *)a1;
      v13 = v10 + *(_QWORD *)(a1 + 8);
      *((_QWORD *)&v31 + 1) = v13;
      v32 = v31;
      if ( v13 + v5 == v7 )
      {
        v14 = (__int128 *)a1;
      }
      else
      {
        *(_QWORD *)&v34 = v31;
        *((_QWORD *)&v34 + 1) = v13 + v5;
        v14 = &v36;
        v36 = v34;
      }
      v15 = *v14;
      v16 = *((_QWORD *)v14 + 1);
      v17 = *(_QWORD *)v14;
      while ( 1 )
      {
        v18 = *(_QWORD *)(v17 + 16);
        v19 = v16 >> 3;
        v20 = v16 & 7;
        if ( v18 <= v16 >> 3 )
          v19 -= v18;
        v21 = v32;
        v22 = *(_QWORD *)(v32 + 16);
        v23 = BYTE8(v32) & 7;
        v24 = *((_QWORD *)&v32 + 1) >> 3;
        if ( v22 <= *((_QWORD *)&v32 + 1) >> 3 )
          v24 -= v22;
        v32 = v15;
        v25 = *(_QWORD *)(*(_QWORD *)(v17 + 8) + 8 * v19);
        v26 = *(_QWORD *)(*(_QWORD *)(v21 + 8) + 8 * v24);
        v27 = *(_WORD *)(v26 + 2 * v23);
        *(_WORD *)(v26 + 2 * v23) = *(_WORD *)(v25 + 2 * v20);
        *(_WORD *)(v25 + 2 * v20) = v27;
        v7 = *(_QWORD *)(a3 + 8);
        v28 = v7 - v16;
        if ( v5 >= (__int64)(v7 - v16) )
        {
          v29 = &v38;
          result = v5 - v28;
          v33 = *(_OWORD *)a1;
          *((_QWORD *)&v33 + 1) = v5 - v28 + *(_QWORD *)(a1 + 8);
          v38 = v33;
        }
        else
        {
          result = v16 + v5;
          *(_QWORD *)&v35 = v15;
          v29 = &v37;
          *((_QWORD *)&v35 + 1) = result;
          v37 = v35;
        }
        v17 = *(_QWORD *)v29;
        v16 = *((_QWORD *)v29 + 1);
        *(_QWORD *)&v30 = v17;
        *((_QWORD *)&v30 + 1) = v16;
        if ( v16 == v13 )
          break;
        v15 = v30;
      }
      --v10;
    }
    while ( v10 > 0 );
  }
  return result;
}

//----- (000000014002A760) ----------------------------------------------------
void *__fastcall sub_14002A760(void *Src, __int64 a2, __int64 a3)
{
  __int64 *v6; // rax
  __int64 *v7; // rax
  __int64 v9[3]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v10[7]; // [rsp+40h] [rbp-38h] BYREF
  char v11; // [rsp+80h] [rbp+8h] BYREF
  char v12; // [rsp+88h] [rbp+10h] BYREF
  __int64 *v13; // [rsp+90h] [rbp+18h]

  *((_QWORD *)Src + 3) = 7i64;
  *((_QWORD *)Src + 2) = 0i64;
  *(_WORD *)Src = 0;
  v13 = v9;
  v9[0] = 0i64;
  v9[1] = 0i64;
  if ( *(_QWORD *)a3 )
  {
    v6 = **(__int64 ***)a3;
    if ( v6 )
    {
      v9[0] = *v6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v11, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v11);
    }
  }
  v9[2] = *(_QWORD *)(a3 + 16);
  v10[0] = 0i64;
  v10[1] = 0i64;
  if ( *(_QWORD *)a2 )
  {
    v7 = **(__int64 ***)a2;
    if ( v7 )
    {
      v10[0] = *v7;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v12, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v12);
    }
  }
  v10[2] = *(_QWORD *)(a2 + 16);
  sub_14002A850(Src, (__int64)v10, (__int64)v9);
  return Src;
}

//----- (000000014002A850) ----------------------------------------------------
__int64 __fastcall sub_14002A850(void *Src, __int64 a2, __int64 a3)
{
  __int64 **v6; // rcx
  __int64 ****v7; // rax
  _QWORD *v8; // rsi
  _QWORD **v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdi
  _WORD *v14; // rax
  __int64 result; // rax
  __int16 v16; // si
  __int64 v17; // r8
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rax
  _WORD *v20; // rax
  _WORD *v21; // rax
  _WORD *v22; // rax
  __int64 v23[2]; // [rsp+28h] [rbp-70h] BYREF
  __int64 v24; // [rsp+38h] [rbp-60h]
  __int64 v25[2]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v26; // [rsp+50h] [rbp-48h]
  __int64 v27; // [rsp+A8h] [rbp+10h] BYREF
  char v28; // [rsp+B0h] [rbp+18h] BYREF
  __int64 *v29; // [rsp+B8h] [rbp+20h]

  v29 = v23;
  v6 = 0i64;
  v23[0] = 0i64;
  v23[1] = 0i64;
  v7 = *(__int64 *****)a3;
  if ( *(_QWORD *)a3 )
  {
    if ( *v7 )
    {
      v6 = **v7;
      v23[0] = (__int64)v6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v27, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v27);
      v6 = (__int64 **)v23[0];
    }
  }
  v24 = *(_QWORD *)(a3 + 16);
  v8 = 0i64;
  if ( *(_QWORD *)a2 )
  {
    v9 = **(_QWORD ****)a2;
    if ( v9 )
    {
      v8 = *v9;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v28, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v28);
      v6 = (__int64 **)v23[0];
    }
  }
  v10 = *(_QWORD *)(a2 + 16);
  v29 = v25;
  v25[0] = 0i64;
  v25[1] = 0i64;
  if ( v6 )
  {
    if ( *v6 )
    {
      v25[0] = **v6;
    }
    else
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v27, 3);
      std::_Lockit::~_Lockit((std::_Lockit *)&v27);
    }
  }
  v11 = v24;
  v26 = v24;
  if ( v8 && !*v8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v28, 3);
    std::_Lockit::~_Lockit((std::_Lockit *)&v28);
    v11 = v26;
  }
  v12 = v11 - v10;
  v13 = *((_QWORD *)Src + 2);
  if ( v13 <= v12 && *((_QWORD *)Src + 3) != v12 && sub_140009900((const void **)Src, v12, 1) )
  {
    *((_QWORD *)Src + 2) = v13;
    if ( *((_QWORD *)Src + 3) < 8ui64 )
      v14 = Src;
    else
      v14 = *(_WORD **)Src;
    v14[v13] = 0;
  }
  while ( 1 )
  {
    result = *(_QWORD *)(a3 + 16);
    if ( *(_QWORD *)(a2 + 16) == result )
      return result;
    v16 = *(_WORD *)sub_140029750(a2);
    v17 = *((_QWORD *)Src + 2);
    if ( v17 == -1 || v17 == -2 )
      sub_14002B5F8("string too long");
    v18 = v17 + 1;
    if ( (unsigned __int64)(v17 + 1) > 0x7FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("string too long");
    v19 = *((_QWORD *)Src + 3);
    if ( v19 < v18 )
    {
      sub_1400097B0(Src, v17 + 1, (const void *)v17);
      if ( !v18 )
        goto LABEL_43;
LABEL_36:
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v21 = Src;
      else
        v21 = *(_WORD **)Src;
      v21[*((_QWORD *)Src + 2)] = v16;
      *((_QWORD *)Src + 2) = v18;
      if ( *((_QWORD *)Src + 3) < 8ui64 )
        v22 = Src;
      else
        v22 = *(_WORD **)Src;
      v22[v18] = 0;
      goto LABEL_43;
    }
    if ( v17 != -1 )
      goto LABEL_36;
    *((_QWORD *)Src + 2) = 0i64;
    if ( v19 < 8 )
      v20 = Src;
    else
      v20 = *(_WORD **)Src;
    *v20 = 0;
LABEL_43:
    ++*(_QWORD *)(a2 + 16);
  }
}

//----- (000000014002AAB0) ----------------------------------------------------
void **__fastcall sub_14002AAB0(__int64 a1, void **a2)
{
  *a2 = Gettnames();
  return a2;
}

//----- (000000014002AB60) ----------------------------------------------------
void __fastcall sub_14002AB60(ULONG_PTR dwData, int a2)
{
  int v4; // er14
  LRESULT v5; // rax
  __int64 v6; // rcx
  int v7; // esi
  UINT v8; // edx
  int v9; // er11
  HWND v10; // rbx
  unsigned int WindowLongW; // eax
  _QWORD *v12; // rax
  _QWORD *v13; // rbx
  WCHAR *v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // er12
  int v18; // er11
  int v19; // eax
  HWND v20; // rcx
  LPITEMIDLIST v21; // r13
  HWND v22; // rcx
  __int64 v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // r12
  char *v26; // rax
  __int64 v27; // rdx
  HWND v28; // rbx
  unsigned int v29; // eax
  bool v30; // zf
  int v31; // ebx
  __int64 v32; // rdx
  WCHAR *v33; // rcx
  WCHAR v34; // ax
  _QWORD **v35; // r11
  _QWORD *v36; // rcx
  _QWORD *v37; // rbx
  LPARAM v38; // [rsp+20h] [rbp-E0h] BYREF
  LPARAM v39; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v40; // [rsp+30h] [rbp-D0h]
  LRESULT v41; // [rsp+38h] [rbp-C8h]
  _DWORD lParam[6]; // [rsp+40h] [rbp-C0h] BYREF
  WCHAR *v43; // [rsp+58h] [rbp-A8h]
  int v44; // [rsp+64h] [rbp-9Ch]
  __int64 v45; // [rsp+68h] [rbp-98h]
  int v46; // [rsp+74h] [rbp-8Ch]
  LPARAM v47; // [rsp+90h] [rbp-70h] BYREF
  int v48; // [rsp+9Ch] [rbp-64h]
  int v49; // [rsp+A0h] [rbp-60h]
  WCHAR pszPath[264]; // [rsp+E0h] [rbp-20h] BYREF

  v4 = 0;
  v5 = SendMessageW(*(HWND *)(dwData + 56), 0x1004u, 0i64, 0i64);
  v6 = *(_QWORD *)(dwData + 952);
  *(_DWORD *)(dwData + 968) = v6;
  v7 = v5;
  v41 = v5;
  if ( (_DWORD)v5 + (_DWORD)v6 )
  {
    if ( !*(_DWORD *)(dwData + 2560) )
      SendMessageW(*(HWND *)(dwData + 64), 0x80C9u, *(int *)(dwData + 852), 0i64);
    SendMessageW(*(HWND *)(dwData + 56), 0x102Fu, (unsigned int)(v7 + *(_DWORD *)(dwData + 968)), 0i64);
    v9 = 7;
    lParam[2] = 0;
    if ( a2 )
      v9 = 263;
    lParam[0] = v9;
    if ( *(_DWORD *)(dwData + 812) )
    {
      v10 = *(HWND *)(dwData + 56);
      WindowLongW = GetWindowLongW(v10, -16);
      if ( (WindowLongW & 0x100) != 0 )
        WindowLongW &= ~0x100u;
      SetWindowLongPtrW(v10, -16, WindowLongW);
    }
    v12 = *(_QWORD **)(dwData + 944);
    v13 = (_QWORD *)*v12;
    if ( (_QWORD *)*v12 != v12 )
    {
      do
      {
        if ( sub_140068D50(dwData, *((_DWORD *)v13 + 5)) )
        {
          v25 = *(_QWORD *)(dwData + 1512);
          v26 = sub_1400246F0(v25, *(_QWORD *)(v25 + 8), (_DWORD *)v13 + 5);
          v27 = *(_QWORD *)(dwData + 1520);
          if ( v27 == 0x3FFFFFFFFFFFFFFEi64 )
            sub_14002B5F8("list<T> too long");
          *(_QWORD *)(dwData + 1520) = v27 + 1;
          *(_QWORD *)(v25 + 8) = v26;
          **((_QWORD **)v26 + 1) = v26;
        }
        else
        {
          lParam[1] = *((_DWORD *)v13 + 4);
          v14 = sub_140068810(dwData, *((_DWORD *)v13 + 5));
          v44 = -1;
          v43 = v14;
          v45 = *((int *)v13 + 5);
          if ( a2 )
            v46 = sub_140063B50(dwData, *((_DWORD *)v13 + 5), v15, v16);
          v17 = SendMessageW(*(HWND *)(dwData + 56), 0x104Du, 0i64, (LPARAM)lParam);
          if ( *((_DWORD *)v13 + 6) && *(_DWORD *)(dwData + 708) != 4 )
          {
            if ( *((_DWORD *)v13 + 7) == -1 )
            {
              v19 = 0;
              v18 = 0;
              v38 = 0i64;
            }
            else
            {
              SendMessageW(*(HWND *)(dwData + 56), 0x1010u, *((int *)v13 + 7), (LPARAM)&v38);
              v18 = HIDWORD(v38);
              v19 = v38;
            }
            v20 = *(HWND *)(dwData + 56);
            LODWORD(v39) = v19;
            HIDWORD(v39) = v18;
            SendMessageW(v20, 0x1031u, v17, (LPARAM)&v39);
          }
          if ( *(_DWORD *)(dwData + 708) == 5 )
            sub_140074700(dwData, v17, *((_DWORD *)v13 + 5));
          if ( *(_DWORD *)(dwData + 972) )
          {
            v21 = ILCombine(
                    *(LPCITEMIDLIST *)(dwData + 136),
                    *(LPCITEMIDLIST *)(568i64 * *((int *)v13 + 5) + *(_QWORD *)(dwData + 96)));
            if ( (unsigned int)sub_14007DCB0((__int64)v21, *(_QWORD *)(dwData + 976)) )
              *(_DWORD *)(dwData + 972) = 0;
            *(_DWORD *)(dwData + 984) = v17;
            CoTaskMemFree(v21);
          }
          if ( (*(_BYTE *)(592i64 * *((int *)v13 + 5) + *(_QWORD *)(dwData + 88)) & 2) != 0 )
          {
            v22 = *(HWND *)(dwData + 56);
            v49 = 4;
            v48 = 4;
            SendMessageW(v22, 0x102Bu, v17, (LPARAM)&v47);
          }
          v23 = *(_QWORD *)(dwData + 88);
          v24 = 592i64 * *((int *)v13 + 5);
          LODWORD(v40) = *(_DWORD *)(v24 + v23 + 32);
          HIDWORD(v40) = *(_DWORD *)(v24 + v23 + 28);
          *(_QWORD *)(dwData + 680) += v40;
          ++v4;
        }
        v13 = (_QWORD *)*v13;
      }
      while ( v13 != *(_QWORD **)(dwData + 944) );
      v7 = v41;
    }
    if ( *(_DWORD *)(dwData + 812) )
    {
      v28 = *(HWND *)(dwData + 56);
      v29 = GetWindowLongW(v28, -16);
      if ( (v29 & 0x100) == 0 )
        v29 |= 0x100u;
      SetWindowLongPtrW(v28, -16, v29);
    }
    v30 = *(_DWORD *)(dwData + 708) == 4;
    *(_DWORD *)(dwData + 752) = v7 + v4;
    if ( v30 )
    {
      v31 = 0;
      QueueUserAPC(sub_14006DCB0, *(HANDLE *)(dwData + 112), dwData);
      v32 = 260i64;
      v33 = pszPath;
      while ( v32 != -2147483386 )
      {
        v34 = *(WCHAR *)((char *)v33 + dwData + 160 - (_QWORD)pszPath);
        if ( !v34 )
          break;
        *v33++ = v34;
        if ( !--v32 )
        {
          --v33;
          break;
        }
      }
      *v33 = 0;
      PathStripToRootW(pszPath);
      if ( GetDriveTypeW(pszPath) == 2 || GetDriveTypeW(pszPath) == 4 )
        v31 = 1;
      if ( *(_DWORD *)(dwData + 732) && (!*(_DWORD *)(dwData + 736) || !v31) )
        QueueUserAPC(sub_14006C2F0, *(HANDLE *)(dwData + 120), dwData);
    }
    sub_14006F450(dwData);
    v35 = *(_QWORD ***)(dwData + 944);
    v36 = *v35;
    *v35 = v35;
    *(_QWORD *)(*(_QWORD *)(dwData + 944) + 8i64) = *(_QWORD *)(dwData + 944);
    *(_QWORD *)(dwData + 952) = 0i64;
    if ( v36 != *(_QWORD **)(dwData + 944) )
    {
      do
      {
        v37 = (_QWORD *)*v36;
        j_free(v36);
        v36 = v37;
      }
      while ( v37 != *(_QWORD **)(dwData + 944) );
    }
    *(_DWORD *)(dwData + 968) = 0;
  }
  else
  {
    v8 = 32970;
    if ( !*(_DWORD *)(dwData + 2560) )
      v8 = 32969;
    SendMessageW(*(HWND *)(dwData + 64), v8, *(int *)(dwData + 852), 1i64);
    *(_DWORD *)(dwData + 752) = 0;
  }
}
// 14002AF74: conditional instruction was optimized away because rdx.8!=0
// 14002ACF6: variable 'v15' is possibly undefined
// 14002ACF6: variable 'v16' is possibly undefined

//----- (000000014002B060) ----------------------------------------------------
__int64 __fastcall sub_14002B060(__int64 a1, int a2, int a3, int a4)
{
  int v5; // ebx
  __int64 v6; // rsi
  int v7; // eax
  __int64 v8; // rdx
  char *v9; // r11
  __int64 v10; // rax
  int v12[6]; // [rsp+20h] [rbp-18h] BYREF

  if ( a2 == -1 )
  {
    v5 = *(_DWORD *)(a1 + 968) + *(_DWORD *)(a1 + 752) - 1;
    v12[0] = v5;
  }
  else
  {
    v5 = a2;
    v12[0] = a2;
  }
  v6 = *(_QWORD *)(a1 + 944);
  v7 = a2 - 1;
  v12[1] = a3;
  v8 = *(_QWORD *)(v6 + 8);
  v12[2] = a4;
  v12[3] = v7;
  v9 = sub_140024640(v6, v8, v12);
  v10 = *(_QWORD *)(a1 + 952);
  if ( v10 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 952) = v10 + 1;
  *(_QWORD *)(v6 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  sub_14006B870(a1, v5);
  sub_14006B7F0(a1, v5);
  return 0i64;
}

//----- (000000014002B130) ----------------------------------------------------
__int64 __fastcall sub_14002B130(__int64 a1, const ITEMIDLIST *a2, const ITEMIDLIST *a3, _WORD *a4)
{
  __int64 v4; // rbx
  int v9; // eax
  void *v10; // rax
  __int64 v11; // rdx
  void *v12; // rcx
  void *v13; // rax
  void *v14; // rcx
  size_t v15; // rdx
  void *v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  unsigned int v20; // eax
  __int64 v21; // r12
  __int64 v22; // r13
  _WORD *v23; // r8
  __int64 v24; // rsi
  _WORD *v25; // rcx
  __int64 v26; // rdx
  ITEMIDLIST *v27; // rbx
  bool v28; // zf
  __int64 v29; // rax
  HANDLE FirstFileW; // rax
  WCHAR *v31; // r8
  _WORD *v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // r12
  _WORD *v35; // rcx
  unsigned int v36; // [rsp+20h] [rbp-268h]
  WCHAR pszPath[264]; // [rsp+30h] [rbp-258h] BYREF

  ++*(_DWORD *)(a1 + 968);
  v4 = *(int *)(a1 + 768);
  if ( *(_DWORD *)(a1 + 752) + *(_DWORD *)(a1 + 968) > (int)v4 - 1 )
  {
    if ( (int)v4 <= 5000 )
    {
      v9 = v4 + 1000;
      if ( (int)v4 <= 1000 )
        v9 = v4 + 250;
    }
    else
    {
      v9 = v4 + 5000;
    }
    *(_DWORD *)(a1 + 768) = v9;
    v10 = realloc(*(void **)(a1 + 88), 592i64 * v9);
    v11 = *(int *)(a1 + 768);
    v12 = *(void **)(a1 + 96);
    *(_QWORD *)(a1 + 88) = v10;
    v13 = realloc(v12, 568 * v11);
    v14 = *(void **)(a1 + 792);
    v15 = 4i64 * *(int *)(a1 + 768);
    *(_QWORD *)(a1 + 96) = v13;
    v16 = realloc(v14, v15);
    v17 = *(int *)(a1 + 768);
    v18 = v4;
    for ( *(_QWORD *)(a1 + 792) = v16; v18 < v17; *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4 * v18 - 4) = 0 )
      ++v18;
    *(_DWORD *)(a1 + 772) = 0;
    if ( !*(_QWORD *)(a1 + 88) || !*(_QWORD *)(a1 + 96) )
      return 2147942414i64;
  }
  *(_DWORD *)(a1 + 1020) = *(_DWORD *)(a1 + 752) + *(_DWORD *)(a1 + 968);
  v20 = sub_14006E280(a1);
  v21 = (int)v20;
  v36 = v20;
  v22 = 568i64 * (int)v20;
  *(_QWORD *)(v22 + *(_QWORD *)(a1 + 96)) = ILClone(a3);
  v23 = a4;
  *(_DWORD *)(v22 + *(_QWORD *)(a1 + 96) + 532) = 0;
  *(_DWORD *)(v22 + *(_QWORD *)(a1 + 96) + 536) = 0;
  *(_DWORD *)(v22 + *(_QWORD *)(a1 + 96) + 544) = 0;
  v24 = 260i64;
  v25 = (_WORD *)(v22 + *(_QWORD *)(a1 + 96) + 8);
  v26 = 260i64;
  while ( v26 != -2147483386 && *v23 )
  {
    *v25++ = *v23++;
    if ( !--v26 )
    {
      --v25;
      break;
    }
  }
  *v25 = 0;
  v27 = ILCombine(a2, a3);
  SHGetPathFromIDListW(v27, pszPath);
  CoTaskMemFree(v27);
  v28 = !PathIsRootW(pszPath);
  v29 = *(_QWORD *)(a1 + 96);
  if ( !v28 )
  {
    *(_DWORD *)(v22 + v29 + 548) = 1;
    v31 = pszPath;
    v32 = (_WORD *)(v22 + *(_QWORD *)(a1 + 96) + 552);
    v33 = 4i64;
    while ( v33 != -2147483642 && *v31 )
    {
      *v32++ = *v31++;
      if ( !--v33 )
      {
        *(v32 - 1) = 0;
        goto LABEL_26;
      }
    }
    LODWORD(v33) = 0;
    *v32 = 0;
    goto LABEL_26;
  }
  *(_DWORD *)(v22 + v29 + 548) = 0;
  FirstFileW = FindFirstFileW(pszPath, (LPWIN32_FIND_DATAW)(*(_QWORD *)(a1 + 88) + 592 * v21));
  if ( FirstFileW == (HANDLE)-1i64 )
  {
    LODWORD(v33) = 0;
LABEL_26:
    v34 = 592 * v21;
    v35 = (_WORD *)(v34 + *(_QWORD *)(a1 + 88) + 44);
    while ( v24 != -2147483386 && *a4 )
    {
      *v35++ = *a4++;
      if ( !--v24 )
      {
        --v35;
        break;
      }
    }
    *v35 = v33;
    *(_DWORD *)(v34 + *(_QWORD *)(a1 + 88) + 32) = v33;
    *(_DWORD *)(v34 + *(_QWORD *)(a1 + 88) + 28) = v33;
    *(_DWORD *)(v34 + *(_QWORD *)(a1 + 88)) = 16;
    *(_DWORD *)(v22 + *(_QWORD *)(a1 + 96) + 528) = v33;
    return v36;
  }
  *(_DWORD *)(v22 + *(_QWORD *)(a1 + 96) + 528) = 1;
  FindClose(FirstFileW);
  return v36;
}
// 14002B2ED: conditional instruction was optimized away because rdx.8!=0
// 14002B3D1: conditional instruction was optimized away because rdx.8!=0
// 14002B41A: conditional instruction was optimized away because rsi.8!=0

//----- (000000014002B490) ----------------------------------------------------
char *__fastcall sub_14002B490(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x418ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x408ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014002B540) ----------------------------------------------------
char *__fastcall sub_14002B540(__int64 a1, __int64 a2, const void *a3)
{
  char *v6; // rax
  char *v7; // rbx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF
  char *v10; // [rsp+68h] [rbp+20h] BYREF

  v6 = (char *)operator new(0x220ui64);
  v7 = v6;
  v10 = v6;
  if ( !v6 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)v6 = a1;
  *((_QWORD *)v6 + 1) = a2;
  if ( v6 != (char *)-16i64 )
    memmove(v6 + 16, a3, 0x210ui64);
  return v7;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014002B5F8) ----------------------------------------------------
void __fastcall __noreturn sub_14002B5F8(char *a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v2; // [rsp+50h] [rbp+8h] BYREF

  v2 = a1;
  std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
  pExceptionObject[0] = (__int64)&std::length_error::`vftable';
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}
// 1400E41E0: using guessed type void *std::length_error::`vftable';

//----- (000000014002B630) ----------------------------------------------------
void __fastcall __noreturn sub_14002B630(char *a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v2; // [rsp+50h] [rbp+8h] BYREF

  v2 = a1;
  std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
  pExceptionObject[0] = (__int64)&std::out_of_range::`vftable';
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}
// 1400E41F8: using guessed type void *std::out_of_range::`vftable';

//----- (000000014002B668) ----------------------------------------------------
std::exception *__fastcall sub_14002B668(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::out_of_range::`vftable';
  return a1;
}
// 1400E41F8: using guessed type void *std::out_of_range::`vftable';

//----- (000000014002B68C) ----------------------------------------------------
void __fastcall __noreturn sub_14002B68C(char *a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v2; // [rsp+50h] [rbp+8h] BYREF

  v2 = a1;
  std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v2);
  pExceptionObject[0] = (__int64)&std::runtime_error::`vftable';
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
}
// 1400E4210: using guessed type void *std::runtime_error::`vftable';

//----- (000000014002B6C4) ----------------------------------------------------
void *__fastcall sub_14002B6C4(void *Block, char a2)
{
  sub_14004AEC0((std::exception *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}

//----- (000000014002B7FC) ----------------------------------------------------
__int64 __fastcall sub_14002B7FC(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000014002B804) ----------------------------------------------------
__int64 __fastcall sub_14002B804(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (000000014002B818) ----------------------------------------------------
__int64 (__fastcall **sub_14002B818())()
{
  return &off_14011B110;
}
// 14011B110: using guessed type __int64 (__fastcall *off_14011B110)();

//----- (000000014002B820) ----------------------------------------------------
_QWORD *__fastcall sub_14002B820(_QWORD *a1, char a2)
{
  *a1 = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}
// 1400E4230: using guessed type void *std::error_category::`vftable';

//----- (000000014002BB90) ----------------------------------------------------
__int64 sub_14002BB90()
{
  return qword_14012C0A0;
}
// 14012C0A0: using guessed type __int64 qword_14012C0A0;

//----- (000000014002CC7C) ----------------------------------------------------
std::exception *__fastcall sub_14002CC7C(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::tr1::regex_error::`vftable';
  *((_DWORD *)a1 + 6) = *((_DWORD *)a2 + 6);
  return a1;
}
// 1400E44B0: using guessed type void *std::tr1::regex_error::`vftable';

//----- (000000014002CF88) ----------------------------------------------------
char sub_14002CF88()
{
  return 1;
}

//----- (000000014002CF8C) ----------------------------------------------------
__int64 sub_14002CF8C()
{
  return 1i64;
}

//----- (000000014002CF94) ----------------------------------------------------
int __fastcall sub_14002CF94(__int64 a1, unsigned __int8 a2)
{
  return Tolower(a2, (const _Ctypevec *)(a1 + 16));
}

//----- (000000014002CFEC) ----------------------------------------------------
int __fastcall sub_14002CFEC(__int64 a1, unsigned __int8 a2)
{
  return Toupper(a2, (const _Ctypevec *)(a1 + 16));
}

//----- (000000014002D044) ----------------------------------------------------
char __fastcall sub_14002D044(__int64 a1, char a2)
{
  return a2;
}

//----- (000000014002D7FC) ----------------------------------------------------
__int64 __fastcall sub_14002D7FC(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_get<char,std::istreambuf_iterator<char>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 14002D879: variable 'v7' is possibly undefined
// 1400E4568: using guessed type void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (000000014002D8B4) ----------------------------------------------------
__int64 __fastcall sub_14002D8B4(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 14002D931: variable 'v7' is possibly undefined
// 1400E45D8: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (000000014002D96C) ----------------------------------------------------
char __fastcall sub_14002D96C(__int64 a1)
{
  return *(_BYTE *)(a1 + 24);
}

//----- (000000014002D970) ----------------------------------------------------
char __fastcall sub_14002D970(__int64 a1)
{
  return *(_BYTE *)(a1 + 25);
}

//----- (000000014002D974) ----------------------------------------------------
void *__fastcall sub_14002D974(void *Block, char a2)
{
  *(_QWORD *)Block = &std::numpunct<char>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 4));
  j_j_free(*((void **)Block + 5));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E4710: using guessed type void *std::numpunct<char>::`vftable';

//----- (000000014002D9D0) ----------------------------------------------------
__int64 __fastcall sub_14002D9D0(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x30ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::numpunct<char>::`vftable';
      LOBYTE(v8) = 1;
      std::numpunct<char>::_Init(v5, v7, v8);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 4i64;
}
// 14002DA54: variable 'v8' is possibly undefined
// 14002D3BC: using guessed type __int64 __fastcall std::numpunct<char>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E4710: using guessed type void *std::numpunct<char>::`vftable';

//----- (000000014002DD80) ----------------------------------------------------
__int64 __fastcall sub_14002DD80(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C300;
  v12 = qword_14012C300;
  v3 = qword_14012C0C0;
  if ( !qword_14012C0C0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C0C0 == v3 )
      qword_14012C0C0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C0C0;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( std::ctype<char>::_Getcat(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C300 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14002D630: using guessed type __int64 __fastcall std::ctype<char>::_Getcat(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C300: using guessed type __int64 qword_14012C300;

//----- (000000014002DED4) ----------------------------------------------------
__int64 __fastcall sub_14002DED4(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C308;
  v12 = qword_14012C308;
  v3 = qword_140130F58;
  if ( !qword_140130F58 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F58 == v3 )
      qword_140130F58 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F58;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14002D7FC(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C308 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C308: using guessed type __int64 qword_14012C308;

//----- (000000014002E028) ----------------------------------------------------
__int64 __fastcall sub_14002E028(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C310;
  v12 = qword_14012C310;
  v3 = qword_140130F68;
  if ( !qword_140130F68 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F68 == v3 )
      qword_140130F68 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F68;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14002D8B4(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C310 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C310: using guessed type __int64 qword_14012C310;

//----- (000000014002E17C) ----------------------------------------------------
__int64 __fastcall sub_14002E17C(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C318;
  v12 = qword_14012C318;
  v3 = qword_140130F60;
  if ( !qword_140130F60 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_140130F60 == v3 )
      qword_140130F60 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_140130F60;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14002D9D0(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C318 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C318: using guessed type __int64 qword_14012C318;

//----- (000000014002E2D0) ----------------------------------------------------
__int64 __fastcall sub_14002E2D0(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C320;
  v12 = qword_14012C320;
  v3 = qword_14012C348;
  if ( !qword_14012C348 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C348 == v3 )
      qword_14012C348 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C348;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( std::codecvt<char,char,int>::_Getcat(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C320 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14002DA88: using guessed type __int64 __fastcall std::codecvt<char,char,int>::_Getcat(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C320: using guessed type __int64 qword_14012C320;

//----- (00000001400309F8) ----------------------------------------------------
_OWORD *__fastcall sub_1400309F8(int a1, _OWORD *a2, _OWORD *a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  __int64 *v11; // r11
  unsigned int v12; // eax
  __int64 v13; // rbx
  int v15; // [rsp+30h] [rbp-88h] BYREF
  char *v16; // [rsp+38h] [rbp-80h] BYREF
  __int64 v17[2]; // [rsp+40h] [rbp-78h] BYREF
  char v18[32]; // [rsp+50h] [rbp-68h] BYREF

  v17[1] = -2i64;
  v15 = 0;
  v11 = sub_140008F00(a5, v17);
  v12 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(
          a1,
          (unsigned int)v18,
          (_DWORD)a3,
          a4,
          *(_DWORD *)(a5 + 24),
          (__int64)v11);
  v13 = Stollx(v18, &v16, v12, &v15);
  sub_140008FC0(v17);
  if ( (unsigned __int8)std::istreambuf_iterator<char>::equal(a3, a4) )
    *a6 |= 1u;
  if ( v16 == v18 || v15 )
    *a6 |= 2u;
  else
    *a7 = v13;
  *a2 = *a3;
  return a2;
}
// 14002C824: using guessed type __int64 __fastcall Stollx(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002D560: using guessed type __int64 __fastcall std::istreambuf_iterator<char>::equal(_QWORD, _QWORD);
// 14002F130: using guessed type __int64 __fastcall std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000140030AFC) ----------------------------------------------------
_OWORD *__fastcall sub_140030AFC(int a1, _OWORD *a2, _OWORD *a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  __int64 *v11; // r11
  unsigned int v12; // eax
  __int64 v13; // rbx
  int v15; // [rsp+30h] [rbp-88h] BYREF
  char *v16; // [rsp+38h] [rbp-80h] BYREF
  __int64 v17[2]; // [rsp+40h] [rbp-78h] BYREF
  char v18[32]; // [rsp+50h] [rbp-68h] BYREF

  v17[1] = -2i64;
  v15 = 0;
  v11 = sub_140008F00(a5, v17);
  v12 = std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(
          a1,
          (unsigned int)v18,
          (_DWORD)a3,
          a4,
          *(_DWORD *)(a5 + 24),
          (__int64)v11);
  v13 = Stoullx(v18, &v16, v12, &v15);
  sub_140008FC0(v17);
  if ( (unsigned __int8)std::istreambuf_iterator<char>::equal(a3, a4) )
    *a6 |= 1u;
  if ( v16 == v18 || v15 )
    *a6 |= 2u;
  else
    *a7 = v13;
  *a2 = *a3;
  return a2;
}
// 14002C918: using guessed type __int64 __fastcall Stoullx(_QWORD, _QWORD, _QWORD, _QWORD);
// 14002D560: using guessed type __int64 __fastcall std::istreambuf_iterator<char>::equal(_QWORD, _QWORD);
// 14002F130: using guessed type __int64 __fastcall std::num_get<char,std::istreambuf_iterator<char>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400330C4) ----------------------------------------------------
char sub_1400330C4()
{
  return 0;
}

//----- (00000001400330C8) ----------------------------------------------------
__int64 sub_1400330C8()
{
  return 5i64;
}

//----- (0000000140033478) ----------------------------------------------------
__int64 __fastcall sub_140033478(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

//----- (00000001400334DC) ----------------------------------------------------
__int64 sub_1400334DC()
{
  return 0xFFFFFFFFi64;
}

//----- (00000001400334E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400334E0(_QWORD *a1, char a2)
{
  *a1 = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(a1);
  return a1;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';

//----- (0000000140033508) ----------------------------------------------------
__int64 __fastcall sub_140033508(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 26);
}

//----- (0000000140033510) ----------------------------------------------------
__int64 __fastcall sub_140033510(__int64 a1)
{
  return *(unsigned int *)(a1 + 56);
}

//----- (0000000140033520) ----------------------------------------------------
void *__fastcall sub_140033520(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
  free(*((void **)Block + 2));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E5090: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0000000140034250) ----------------------------------------------------
__int64 __fastcall sub_140034250(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  char v8[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x10ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v8, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::messages<wchar_t>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v8);
  }
  return 6i64;
}
// 1400E4E20: using guessed type void *std::messages<wchar_t>::`vftable';

//----- (0000000140034300) ----------------------------------------------------
__int64 __fastcall sub_140034300(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 14003437D: variable 'v7' is possibly undefined
// 1400E4E48: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (00000001400343B8) ----------------------------------------------------
__int64 __fastcall sub_1400343B8(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 140034435: variable 'v7' is possibly undefined
// 1400E4E68: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140034470) ----------------------------------------------------
__int64 __fastcall sub_140034470(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 1400344ED: variable 'v7' is possibly undefined
// 1400E4EE8: using guessed type void *std::num_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (0000000140034528) ----------------------------------------------------
__int64 __fastcall sub_140034528(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 4i64;
}
// 1400345A5: variable 'v7' is possibly undefined
// 1400E4F58: using guessed type void *std::num_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (00000001400345E0) ----------------------------------------------------
void *__fastcall sub_1400345E0(void *Block, char a2)
{
  *(_QWORD *)Block = &std::numpunct<unsigned short>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 4));
  j_j_free(*((void **)Block + 5));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E5388: using guessed type void *std::numpunct<unsigned short>::`vftable';

//----- (00000001400346F4) ----------------------------------------------------
__int64 __fastcall sub_1400346F4(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  char v8[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x10ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v8, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::messages<unsigned short>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v8);
  }
  return 6i64;
}
// 1400E4FD0: using guessed type void *std::messages<unsigned short>::`vftable';

//----- (00000001400347A4) ----------------------------------------------------
__int64 __fastcall sub_1400347A4(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 140034821: variable 'v7' is possibly undefined
// 1400E4FF8: using guessed type void *std::money_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (000000014003485C) ----------------------------------------------------
__int64 __fastcall sub_14003485C(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 1400348D9: variable 'v7' is possibly undefined
// 1400E5018: using guessed type void *std::money_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0000000140034914) ----------------------------------------------------
__int64 __fastcall sub_140034914(_QWORD *a1, __int64 a2)
{
  char v4; // bp
  _QWORD *v5; // rdi
  const char *v6; // rdx
  __int64 v7; // rbx
  _Cvtvec *v8; // rcx
  void **v9; // rax
  char v11[72]; // [rsp+28h] [rbp-50h] BYREF
  void *Block; // [rsp+80h] [rbp+8h] BYREF

  v4 = 0;
  LODWORD(Block) = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x20ui64);
    Block = v5;
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v11, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';
      v5[2] = 0i64;
      v5[3] = Getcvt(v8);
      v9 = sub_14002AAB0(v7, &Block);
      v5[2] = *v9;
      *v9 = 0i64;
      free(Block);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v11);
  }
  return 5i64;
}
// 1400349A0: variable 'v8' is possibly undefined
// 1400E5090: using guessed type void *std::time_put<unsigned short,std::ostreambuf_iterator<unsigned short>>::`vftable';

//----- (0000000140034F28) ----------------------------------------------------
__int64 __fastcall sub_140034F28(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C3E8;
  v12 = qword_14012C3E8;
  v3 = qword_14012C0D8;
  if ( !qword_14012C0D8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C0D8 == v3 )
      qword_14012C0D8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C0D8;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( std::ctype<wchar_t>::_Getcat(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C3E8 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 140034168: using guessed type __int64 __fastcall std::ctype<wchar_t>::_Getcat(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C3E8: using guessed type __int64 qword_14012C3E8;

//----- (000000014003507C) ----------------------------------------------------
__int64 __fastcall sub_14003507C(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C3F0;
  v12 = qword_14012C3F0;
  v3 = qword_14012C490;
  if ( !qword_14012C490 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C490 == v3 )
      qword_14012C490 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C490;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140034250(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C3F0 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C3F0: using guessed type __int64 qword_14012C3F0;

//----- (00000001400351D0) ----------------------------------------------------
__int64 __fastcall sub_1400351D0(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C3F8;
  v12 = qword_14012C3F8;
  v3 = qword_14012C4A0;
  if ( !qword_14012C4A0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4A0 == v3 )
      qword_14012C4A0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4A0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140034300(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C3F8 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C3F8: using guessed type __int64 qword_14012C3F8;

//----- (0000000140035324) ----------------------------------------------------
__int64 __fastcall sub_140035324(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C400;
  v12 = qword_14012C400;
  v3 = qword_14012C4F8;
  if ( !qword_14012C4F8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4F8 == v3 )
      qword_14012C4F8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4F8;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400343B8(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C400 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C400: using guessed type __int64 qword_14012C400;

//----- (0000000140035478) ----------------------------------------------------
__int64 __fastcall sub_140035478(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C408;
  v12 = qword_14012C408;
  v3 = qword_14012C0C8;
  if ( !qword_14012C0C8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C0C8 == v3 )
      qword_14012C0C8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C0C8;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( std::codecvt<wchar_t,char,int>::_Getcat(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C408 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 140033FF8: using guessed type __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C408: using guessed type __int64 qword_14012C408;

//----- (00000001400355CC) ----------------------------------------------------
__int64 __fastcall sub_1400355CC(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C410;
  v12 = qword_14012C410;
  v3 = qword_14012C508;
  if ( !qword_14012C508 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C508 == v3 )
      qword_14012C508 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C508;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140034470(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C410 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C410: using guessed type __int64 qword_14012C410;

//----- (0000000140035720) ----------------------------------------------------
__int64 __fastcall sub_140035720(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C418;
  v12 = qword_14012C418;
  v3 = qword_14012C4A8;
  if ( !qword_14012C4A8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4A8 == v3 )
      qword_14012C4A8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4A8;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140034528(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C418 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C418: using guessed type __int64 qword_14012C418;

//----- (0000000140035874) ----------------------------------------------------
__int64 __fastcall sub_140035874(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C420;
  v12 = qword_14012C420;
  v3 = qword_14012C4B8;
  if ( !qword_14012C4B8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4B8 == v3 )
      qword_14012C4B8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4B8;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14003463C(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C420 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14003463C: using guessed type __int64 __fastcall sub_14003463C(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C420: using guessed type __int64 qword_14012C420;

//----- (00000001400359C8) ----------------------------------------------------
__int64 __fastcall sub_1400359C8(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C428;
  v12 = qword_14012C428;
  v3 = qword_14012C488;
  if ( !qword_14012C488 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C488 == v3 )
      qword_14012C488 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C488;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400346F4(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C428 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C428: using guessed type __int64 qword_14012C428;

//----- (0000000140035B1C) ----------------------------------------------------
__int64 __fastcall sub_140035B1C(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C430;
  v12 = qword_14012C430;
  v3 = qword_14012C4B0;
  if ( !qword_14012C4B0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4B0 == v3 )
      qword_14012C4B0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4B0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400347A4(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C430 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C430: using guessed type __int64 qword_14012C430;

//----- (0000000140035C70) ----------------------------------------------------
__int64 __fastcall sub_140035C70(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C438;
  v12 = qword_14012C438;
  v3 = qword_14012C498;
  if ( !qword_14012C498 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C498 == v3 )
      qword_14012C498 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C498;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14003485C(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C438 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C438: using guessed type __int64 qword_14012C438;

//----- (0000000140035DC4) ----------------------------------------------------
__int64 __fastcall sub_140035DC4(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C440;
  v12 = qword_14012C440;
  v3 = qword_14012C500;
  if ( !qword_14012C500 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C500 == v3 )
      qword_14012C500 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C500;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140034914(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C440 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C440: using guessed type __int64 qword_14012C440;

//----- (0000000140035F18) ----------------------------------------------------
__int64 __fastcall sub_140035F18(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C448;
  v12 = qword_14012C448;
  v3 = qword_14012C0B8;
  if ( !qword_14012C0B8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C0B8 == v3 )
      qword_14012C0B8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C0B8;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( std::codecvt<wchar_t,char,int>::_Getcat(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C448 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 1400340B0: using guessed type __int64 __fastcall std::codecvt<wchar_t,char,int>::_Getcat(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C448: using guessed type __int64 qword_14012C448;

//----- (000000014003606C) ----------------------------------------------------
__int64 __fastcall sub_14003606C(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<wchar_t>::`vftable';
      *((_BYTE *)v5 + 68) = 0;
      LOBYTE(v8) = 1;
      std::_Mpunct<wchar_t>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<wchar_t,0>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 1400360FC: variable 'v8' is possibly undefined
// 140033900: using guessed type __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E4E88: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 1400E5708: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';

//----- (0000000140036138) ----------------------------------------------------
__int64 __fastcall sub_140036138(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<wchar_t>::`vftable';
      *((_BYTE *)v5 + 68) = 1;
      LOBYTE(v8) = 1;
      std::_Mpunct<wchar_t>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<wchar_t,1>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 1400361C8: variable 'v8' is possibly undefined
// 140033900: using guessed type __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E4E88: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 1400E5788: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';

//----- (0000000140036204) ----------------------------------------------------
void *__fastcall sub_140036204(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 3));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E5808: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140036254) ----------------------------------------------------
__int64 __fastcall sub_140036254(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  char v9[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x30ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
      std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(v5, v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 5i64;
}
// 140034A04: using guessed type __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(_QWORD, _QWORD);
// 1400E5808: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';

//----- (0000000140036308) ----------------------------------------------------
__int64 __fastcall sub_140036308(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<unsigned short>::`vftable';
      *((_BYTE *)v5 + 68) = 0;
      LOBYTE(v8) = 1;
      std::_Mpunct<wchar_t>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<unsigned short,0>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 140036398: variable 'v8' is possibly undefined
// 140033C20: using guessed type __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E5038: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 1400E5878: using guessed type void *std::moneypunct<unsigned short,0>::`vftable';

//----- (00000001400363D4) ----------------------------------------------------
__int64 __fastcall sub_1400363D4(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<unsigned short>::`vftable';
      *((_BYTE *)v5 + 68) = 1;
      LOBYTE(v8) = 1;
      std::_Mpunct<wchar_t>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<unsigned short,1>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 140036464: variable 'v8' is possibly undefined
// 140033C20: using guessed type __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E5038: using guessed type void *std::_Mpunct<unsigned short>::`vftable';
// 1400E58F8: using guessed type void *std::moneypunct<unsigned short,1>::`vftable';

//----- (00000001400364A0) ----------------------------------------------------
void *__fastcall sub_1400364A0(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 3));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E5978: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00000001400364F0) ----------------------------------------------------
__int64 __fastcall sub_1400364F0(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  char v9[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x30ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';
      std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(v5, v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 5i64;
}
// 140034B10: using guessed type __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(_QWORD, _QWORD);
// 1400E5978: using guessed type void *std::time_get<unsigned short,std::istreambuf_iterator<unsigned short>>::`vftable';

//----- (00000001400373C0) ----------------------------------------------------
__int64 __fastcall sub_1400373C0(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C450;
  v12 = qword_14012C450;
  v3 = qword_14012C4D8;
  if ( !qword_14012C4D8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4D8 == v3 )
      qword_14012C4D8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4D8;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14003606C(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C450 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C450: using guessed type __int64 qword_14012C450;

//----- (0000000140037514) ----------------------------------------------------
__int64 __fastcall sub_140037514(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C458;
  v12 = qword_14012C458;
  v3 = qword_14012C4C8;
  if ( !qword_14012C4C8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4C8 == v3 )
      qword_14012C4C8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4C8;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140036138(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C458 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C458: using guessed type __int64 qword_14012C458;

//----- (0000000140037668) ----------------------------------------------------
__int64 __fastcall sub_140037668(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C460;
  v12 = qword_14012C460;
  v3 = qword_14012C4F0;
  if ( !qword_14012C4F0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4F0 == v3 )
      qword_14012C4F0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4F0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140036254(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C460 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C460: using guessed type __int64 qword_14012C460;

//----- (00000001400377BC) ----------------------------------------------------
__int64 __fastcall sub_1400377BC(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C468;
  v12 = qword_14012C468;
  v3 = qword_14012C4E8;
  if ( !qword_14012C4E8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4E8 == v3 )
      qword_14012C4E8 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4E8;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140036308(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C468 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C468: using guessed type __int64 qword_14012C468;

//----- (0000000140037910) ----------------------------------------------------
__int64 __fastcall sub_140037910(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C470;
  v12 = qword_14012C470;
  v3 = qword_14012C4E0;
  if ( !qword_14012C4E0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4E0 == v3 )
      qword_14012C4E0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4E0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400363D4(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C470 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C470: using guessed type __int64 qword_14012C470;

//----- (0000000140037A64) ----------------------------------------------------
__int64 __fastcall sub_140037A64(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C478;
  v12 = qword_14012C478;
  v3 = qword_14012C4D0;
  if ( !qword_14012C4D0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4D0 == v3 )
      qword_14012C4D0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4D0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400364F0(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C478 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C478: using guessed type __int64 qword_14012C478;

//----- (000000014003956C) ----------------------------------------------------
_OWORD *__fastcall sub_14003956C(int a1, _OWORD *a2, _OWORD *a3, int a4, int a5, _DWORD *a6, __int64 a7)
{
  int v9; // eax
  _DWORD *v10; // rdx
  int v11; // ecx
  _OWORD *result; // rax
  int v13; // [rsp+48h] [rbp+10h] BYREF

  v13 = 0;
  v9 = std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(a1, (_DWORD)a3, a4, 0, 2035, (__int64)&v13);
  v10 = a6;
  *a6 |= v9;
  if ( (*v10 & 2) == 0 )
  {
    v11 = v13;
    if ( v13 < 1900 )
    {
      if ( v13 > 135 )
        *v10 |= 2u;
    }
    else
    {
      v11 = v13 - 1900;
    }
    *(_DWORD *)(a7 + 20) = v11;
  }
  result = a2;
  *a2 = *a3;
  return result;
}
// 140036E74: using guessed type __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014003B444) ----------------------------------------------------
_OWORD *__fastcall sub_14003B444(__int64 a1, _OWORD *a2, __int64 *a3, __int64 *a4, int a5, _DWORD *a6, __int64 a7)
{
  int v9; // er11
  _OWORD *result; // rax

  v9 = sub_140007350(a3, a4, 0i64, *(__int16 **)(a1 + 16));
  if ( v9 >= 0 )
    *(_DWORD *)(a7 + 24) = v9 >> 1;
  else
    *a6 |= 2u;
  result = a2;
  *a2 = *(_OWORD *)a3;
  return result;
}

//----- (000000014003B49C) ----------------------------------------------------
_OWORD *__fastcall sub_14003B49C(__int64 a1, _OWORD *a2, __int64 *a3, __int64 *a4, int a5, _DWORD *a6, __int64 a7)
{
  int v9; // er11
  _OWORD *result; // rax

  v9 = sub_140007350(a3, a4, 0i64, *(__int16 **)(a1 + 24));
  if ( v9 >= 0 )
    *(_DWORD *)(a7 + 16) = v9 >> 1;
  else
    *a6 |= 2u;
  result = a2;
  *a2 = *(_OWORD *)a3;
  return result;
}

//----- (000000014003BDC0) ----------------------------------------------------
__int128 *__fastcall sub_14003BDC0(
        __int64 *a1,
        __int128 *a2,
        __int128 *a3,
        __int128 *a4,
        __int64 a5,
        _DWORD *a6,
        _DWORD *a7,
        char a8)
{
  _DWORD *v8; // rbx
  _DWORD *v12; // rax
  int v13; // er9
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  const char *v16; // rax
  __int128 *v17; // r9
  __int128 *v18; // r8
  char *v19; // rdx
  int v20; // ecx
  __int128 v21; // xmm1
  __int64 v22; // r10
  __int128 v23; // xmm5
  __int128 v24; // xmm1
  __int64 v25; // r10
  __int128 v26; // xmm1
  __int128 v27; // xmm0
  __int128 v28; // xmm1
  __int64 v29; // r10
  int v30; // eax
  __int128 *result; // rax
  int v32; // [rsp+20h] [rbp-C1h]
  _DWORD *v33; // [rsp+28h] [rbp-B9h]
  __int128 v34; // [rsp+40h] [rbp-A1h] BYREF
  __int128 v35; // [rsp+50h] [rbp-91h] BYREF
  __int128 v36; // [rsp+60h] [rbp-81h] BYREF
  __int128 v37; // [rsp+70h] [rbp-71h] BYREF
  __int128 v38; // [rsp+80h] [rbp-61h] BYREF
  char v39; // [rsp+90h] [rbp-51h] BYREF
  char v40; // [rsp+A0h] [rbp-41h] BYREF
  char v41; // [rsp+B0h] [rbp-31h] BYREF
  char v42; // [rsp+C0h] [rbp-21h] BYREF
  char v43; // [rsp+D0h] [rbp-11h] BYREF
  char v44; // [rsp+E0h] [rbp-1h] BYREF
  char v45; // [rsp+F0h] [rbp+Fh] BYREF
  int v46; // [rsp+128h] [rbp+47h] BYREF

  v46 = 0;
  v8 = a6;
  if ( a8 <= 97 )
  {
    if ( a8 == 97 )
    {
LABEL_32:
      v24 = *a3;
      v25 = *a1;
      v35 = *a4;
      v34 = v24;
      (*(void (__fastcall **)(__int64 *, __int128 *, __int128 *, __int128 *, __int64, _DWORD *, _DWORD *))(v25 + 32))(
        a1,
        &v37,
        &v34,
        &v35,
        a5,
        a6,
        a7);
      v23 = v37;
      goto LABEL_33;
    }
    if ( a8 <= 82 )
    {
      if ( a8 != 82 )
      {
        if ( a8 != 65 )
        {
          if ( a8 != 66 )
          {
            if ( a8 != 67 )
            {
              if ( a8 != 68 )
              {
                switch ( a8 )
                {
                  case 'H':
                    v33 = a7 + 2;
                    v32 = 23;
                    goto LABEL_16;
                  case 'I':
                    v33 = a7 + 2;
                    v32 = 11;
                    goto LABEL_16;
                  case 'M':
                    v12 = a7 + 1;
LABEL_13:
                    v33 = v12;
                    v32 = 59;
LABEL_16:
                    v13 = 0;
LABEL_47:
                    *v8 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(
                             (_DWORD)a1,
                             (_DWORD)a3,
                             (_DWORD)a4,
                             v13,
                             v32,
                             (__int64)v33);
                    goto LABEL_69;
                }
                goto LABEL_67;
              }
              v14 = *a4;
              v15 = *a3;
              v16 = "%m / %d / %y";
              v17 = &v34;
              v18 = &v35;
              v19 = &v39;
              v34 = v14;
              v35 = v15;
LABEL_50:
              *a3 = *(_OWORD *)std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(
                                 (_DWORD)a1,
                                 (_DWORD)v19,
                                 (_DWORD)v18,
                                 (_DWORD)v17,
                                 a5,
                                 (__int64)a6,
                                 (__int64)a7,
                                 v16,
                                 v34,
                                 v35);
              goto LABEL_69;
            }
            *v8 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(
                     (_DWORD)a1,
                     (_DWORD)a3,
                     (_DWORD)a4,
                     0,
                     99,
                     (__int64)&v46);
            if ( (*(_BYTE *)v8 & 2) != 0 )
              goto LABEL_69;
            v20 = 100 * (v46 - 19);
LABEL_20:
            a7[5] = v20;
            goto LABEL_69;
          }
          goto LABEL_51;
        }
        goto LABEL_32;
      }
      v16 = "%H : %M";
      v19 = &v44;
LABEL_49:
      v26 = *a3;
      v27 = *a4;
      v18 = &v34;
      v17 = &v35;
      v34 = v26;
      v35 = v27;
      goto LABEL_50;
    }
    switch ( a8 )
    {
      case 'S':
        v12 = a7;
        goto LABEL_13;
      case 'T':
        goto LABEL_30;
      case 'U':
      case 'W':
        v33 = a7 + 7;
        v32 = 53;
        goto LABEL_16;
      case 'X':
LABEL_30:
        v16 = "%H : %M : S";
        v19 = &v42;
        goto LABEL_49;
      case 'Y':
        v21 = *a3;
        v22 = *a1;
        v35 = *a4;
        v34 = v21;
        (*(void (__fastcall **)(__int64 *, __int128 *, __int128 *, __int128 *, __int64, _DWORD *, _DWORD *))(v22 + 48))(
          a1,
          &v36,
          &v34,
          &v35,
          a5,
          a6,
          a7);
        v23 = v36;
LABEL_33:
        *a3 = v23;
        goto LABEL_69;
    }
LABEL_67:
    *v8 |= 2u;
    goto LABEL_69;
  }
  if ( a8 > 110 )
  {
    if ( a8 == 112 )
    {
      v30 = std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>(a3, a4, 0i64, ":AM:am:PM:pm");
      if ( v30 < 0 )
        goto LABEL_67;
      a7[2] += 12 * v30;
      goto LABEL_69;
    }
    if ( a8 == 114 )
    {
      v16 = "%I : %M : %S %p";
      v19 = &v45;
      goto LABEL_49;
    }
    if ( a8 != 116 )
    {
      switch ( a8 )
      {
        case 'w':
          v33 = a7 + 6;
          v32 = 6;
          goto LABEL_16;
        case 'x':
          v16 = "%d / %m / %y";
          v19 = &v41;
          goto LABEL_49;
        case 'y':
          *v8 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(
                   (_DWORD)a1,
                   (_DWORD)a3,
                   (_DWORD)a4,
                   0,
                   99,
                   (__int64)&v46);
          if ( (*(_BYTE *)v8 & 2) != 0 )
            goto LABEL_69;
          v20 = v46;
          if ( v46 < 69 )
            v20 = v46 + 100;
          goto LABEL_20;
      }
      goto LABEL_67;
    }
LABEL_64:
    v16 = " ";
    v19 = &v43;
    goto LABEL_49;
  }
  switch ( a8 )
  {
    case 'n':
      goto LABEL_64;
    case 'b':
      goto LABEL_51;
    case 'c':
      v16 = "%b %d %H : %M : %S %Y";
      v19 = &v40;
      goto LABEL_49;
  }
  if ( a8 <= 101 )
  {
    v33 = a7 + 3;
    v32 = 31;
    goto LABEL_46;
  }
  if ( a8 == 104 )
  {
LABEL_51:
    v28 = *a3;
    v29 = *a1;
    v35 = *a4;
    v34 = v28;
    (*(void (__fastcall **)(__int64 *, __int128 *, __int128 *, __int128 *, __int64, _DWORD *, _DWORD *))(v29 + 40))(
      a1,
      &v38,
      &v34,
      &v35,
      a5,
      a6,
      a7);
    v23 = v38;
    goto LABEL_33;
  }
  if ( a8 == 106 )
  {
    v33 = a7 + 7;
    v32 = 366;
LABEL_46:
    v13 = 1;
    goto LABEL_47;
  }
  if ( a8 != 109 )
    goto LABEL_67;
  *v8 |= std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(
           (_DWORD)a1,
           (_DWORD)a3,
           (_DWORD)a4,
           1,
           12,
           (__int64)&v46);
  if ( (*(_BYTE *)v8 & 2) == 0 )
    a7[4] = v46 - 1;
LABEL_69:
  if ( (unsigned __int8)unknown_libname_61(a3, a4) )
    *v8 |= 1u;
  result = a2;
  *a2 = *a3;
  return result;
}
// 14003C022: conditional instruction was optimized away because er10.4 is in (64..6D)
// 140033F10: using guessed type __int64 __fastcall unknown_libname_61(_QWORD, _QWORD);
// 140036C20: using guessed type __int64 std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getfmt(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, ...);
// 140036E74: using guessed type __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getint(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 14003B21C: using guessed type __int64 __fastcall std::_Getloctxt<char,std::istreambuf_iterator<wchar_t>>(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014003E8A8) ----------------------------------------------------
_OWORD *__fastcall sub_14003E8A8(int a1, _OWORD *a2, _OWORD *a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  __int64 *v11; // r11
  unsigned int v12; // eax
  __int64 v13; // rbx
  int v15; // [rsp+30h] [rbp-88h] BYREF
  char *v16; // [rsp+38h] [rbp-80h] BYREF
  __int64 v17[2]; // [rsp+40h] [rbp-78h] BYREF
  char v18[32]; // [rsp+50h] [rbp-68h] BYREF

  v17[1] = -2i64;
  v15 = 0;
  v11 = sub_140008F00(a5, v17);
  v12 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          a1,
          (unsigned int)v18,
          (_DWORD)a3,
          a4,
          *(_DWORD *)(a5 + 24),
          (__int64)v11);
  v13 = Stollx(v18, &v16, v12, &v15);
  sub_140008FC0(v17);
  if ( (unsigned __int8)unknown_libname_61(a3, a4) )
    *a6 |= 1u;
  if ( v16 == v18 || v15 )
    *a6 |= 2u;
  else
    *a7 = v13;
  *a2 = *a3;
  return a2;
}
// 14002C824: using guessed type __int64 __fastcall Stollx(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033F10: using guessed type __int64 __fastcall unknown_libname_61(_QWORD, _QWORD);
// 14003C418: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014003E9AC) ----------------------------------------------------
_OWORD *__fastcall sub_14003E9AC(int a1, _OWORD *a2, _OWORD *a3, __int64 a4, __int64 a5, _DWORD *a6, __int64 *a7)
{
  __int64 *v11; // r11
  unsigned int v12; // eax
  __int64 v13; // rbx
  int v15; // [rsp+30h] [rbp-88h] BYREF
  char *v16; // [rsp+38h] [rbp-80h] BYREF
  __int64 v17[2]; // [rsp+40h] [rbp-78h] BYREF
  char v18[32]; // [rsp+50h] [rbp-68h] BYREF

  v17[1] = -2i64;
  v15 = 0;
  v11 = sub_140008F00(a5, v17);
  v12 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(
          a1,
          (unsigned int)v18,
          (_DWORD)a3,
          a4,
          *(_DWORD *)(a5 + 24),
          (__int64)v11);
  v13 = Stoullx(v18, &v16, v12, &v15);
  sub_140008FC0(v17);
  if ( (unsigned __int8)unknown_libname_61(a3, a4) )
    *a6 |= 1u;
  if ( v16 == v18 || v15 )
    *a6 |= 2u;
  else
    *a7 = v13;
  *a2 = *a3;
  return a2;
}
// 14002C918: using guessed type __int64 __fastcall Stoullx(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033F10: using guessed type __int64 __fastcall unknown_libname_61(_QWORD, _QWORD);
// 14003C418: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getifld(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014003EAB0) ----------------------------------------------------
_OWORD *__fastcall sub_14003EAB0(int a1, _OWORD *a2, _OWORD *a3, __int64 a4, __int64 a5, _DWORD *a6, float *a7)
{
  unsigned int v10; // eax
  double v11; // xmm0_8
  float v12; // xmm6_4
  _OWORD *result; // rax
  int v14; // [rsp+38h] [rbp-61h] BYREF
  int v15; // [rsp+3Ch] [rbp-5Dh] BYREF
  char *v16; // [rsp+40h] [rbp-59h] BYREF
  char v17[64]; // [rsp+48h] [rbp-51h] BYREF

  v14 = 0;
  v15 = 0;
  v10 = std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(
          a1,
          (unsigned int)v17,
          (_DWORD)a3,
          a4,
          a5,
          (__int64)&v15);
  v11 = Stofx(v17, &v16, v10, &v14);
  v12 = *(float *)&v11;
  if ( v15 )
    v12 = ldexp(*(float *)&v11, 4 * v15);
  if ( (unsigned __int8)unknown_libname_61(a3, a4) )
    *a6 |= 1u;
  if ( v16 == v17 || v14 )
    *a6 |= 2u;
  else
    *a7 = v12;
  result = a2;
  *a2 = *a3;
  return result;
}
// 14002CB04: using guessed type double __fastcall Stofx(_QWORD, _QWORD, _QWORD, _QWORD);
// 140033F10: using guessed type __int64 __fastcall unknown_libname_61(_QWORD, _QWORD);
// 14003CB40: using guessed type __int64 __fastcall std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Getffld(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64);

//----- (000000014003F320) ----------------------------------------------------
__int64 __fastcall sub_14003F320(_QWORD *a1, __int64 a2)
{
  char v4; // bl
  _QWORD *v5; // rdi
  const char *v6; // rax
  _Collvec *v7; // rcx
  char v9[72]; // [rsp+38h] [rbp-90h] BYREF
  void *Block[5]; // [rsp+80h] [rbp-48h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = (const char *)sub_140015280(a2, Block);
      if ( *((_QWORD *)v6 + 3) >= 0x10ui64 )
        v6 = *(const char **)v6;
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 3;
      v5[1] = 0i64;
      *v5 = &std::collate<unsigned short>::`vftable';
      v5[2] = Getcoll(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 2) != 0 )
    {
      v4 &= ~2u;
      sub_140008C40((std::_Lockit *)v9);
    }
    if ( (v4 & 1) != 0 && Block[3] >= (void *)0x10 )
      j_free(Block[0]);
  }
  return 1i64;
}
// 14003F3C3: variable 'v7' is possibly undefined
// 1400E4FA8: using guessed type void *std::collate<unsigned short>::`vftable';

//----- (0000000140040E6C) ----------------------------------------------------
__int64 __fastcall sub_140040E6C(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C480;
  v12 = qword_14012C480;
  v3 = qword_14012C4C0;
  if ( !qword_14012C4C0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C4C0 == v3 )
      qword_14012C4C0 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C4C0;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_14003F320(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C480 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C480: using guessed type __int64 qword_14012C480;

//----- (0000000140040FC0) ----------------------------------------------------
void __fastcall sub_140040FC0(__int64 a1, int a2, struct std::locale::_Locimp *a3, __int64 *a4)
{
  int v8; // er15
  struct std::locale::facet *v9; // rax
  struct std::locale::facet *v10; // rbx
  _Ctypevec *v11; // rax
  _Cvtvec *Table; // rcx
  unsigned __int64 v13; // r8
  struct std::locale::facet *v14; // rdx
  unsigned __int64 v15; // rbx
  __int64 v16; // rax
  struct std::locale::facet *v17; // rax
  _Cvtvec *v18; // rcx
  struct std::locale::facet *v19; // rbx
  unsigned __int64 v20; // r8
  struct std::locale::facet *v21; // rdx
  unsigned __int64 v22; // rbx
  __int64 v23; // rax
  struct std::locale::facet *v24; // rax
  _Cvtvec *v25; // rcx
  struct std::locale::facet *v26; // rbx
  unsigned __int64 v27; // r8
  struct std::locale::facet *v28; // rdx
  unsigned __int64 v29; // rbx
  __int64 v30; // rax
  struct std::locale::facet *v31; // rax
  struct std::locale::facet *v32; // rbx
  unsigned __int64 v33; // r8
  struct std::locale::facet *v34; // rdx
  unsigned __int64 v35; // rbx
  __int64 v36; // rax
  struct std::locale::facet *v37; // rax
  _Collvec *v38; // rcx
  struct std::locale::facet *v39; // rbx
  unsigned __int64 v40; // r8
  struct std::locale::facet *v41; // rdx
  unsigned __int64 v42; // rbx
  __int64 v43; // rax
  struct std::locale::facet *v44; // rax
  struct std::locale::facet *v45; // rbx
  unsigned __int64 v46; // r8
  struct std::locale::facet *v47; // rdx
  unsigned __int64 v48; // rbx
  __int64 v49; // rax
  struct std::locale::facet *v50; // rax
  _Cvtvec *v51; // rcx
  struct std::locale::facet *v52; // rbx
  unsigned __int64 v53; // r8
  struct std::locale::facet *v54; // rdx
  unsigned __int64 v55; // rbx
  __int64 v56; // rax
  struct std::locale::facet *v57; // rax
  _Cvtvec *v58; // rcx
  struct std::locale::facet *v59; // rbx
  unsigned __int64 v60; // r8
  struct std::locale::facet *v61; // rdx
  unsigned __int64 v62; // rbx
  __int64 v63; // rax
  struct std::locale::facet *v64; // rax
  struct std::locale::facet *v65; // rbx
  unsigned __int64 v66; // r8
  struct std::locale::facet *v67; // rdx
  unsigned __int64 v68; // rbx
  __int64 v69; // rax
  struct std::locale::facet *v70; // rax
  struct std::locale::facet *v71; // rbx
  unsigned __int64 v72; // r8
  struct std::locale::facet *v73; // rdx
  unsigned __int64 v74; // rbx
  __int64 v75; // rax
  int v76; // er13
  struct std::locale::facet *v77; // rax
  struct std::locale::facet *v78; // rbx
  unsigned __int64 v79; // r8
  struct std::locale::facet *v80; // rdx
  unsigned __int64 v81; // rbx
  __int64 v82; // rax
  struct std::locale::facet *v83; // rax
  _Cvtvec *v84; // rcx
  struct std::locale::facet *v85; // rbx
  void **v86; // rax
  unsigned __int64 v87; // r8
  struct std::locale::facet *v88; // rdx
  unsigned __int64 v89; // rbx
  __int64 v90; // rax
  struct std::locale::facet *v91; // rax
  _Cvtvec *v92; // rcx
  struct std::locale::facet *v93; // rbx
  unsigned __int64 v94; // r8
  struct std::locale::facet *v95; // rdx
  unsigned __int64 v96; // rbx
  __int64 v97; // rax
  void *Block[2]; // [rsp+20h] [rbp-30h] BYREF
  _Ctypevec v99; // [rsp+30h] [rbp-20h] BYREF
  int v100; // [rsp+88h] [rbp+38h] BYREF

  Block[1] = (void *)-2i64;
  v100 = 0;
  v8 = a2 & 2;
  if ( (a2 & 2) != 0 )
  {
    if ( a4 )
    {
      v15 = qword_14012C0E0;
      if ( !qword_14012C0E0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C0E0 )
          qword_14012C0E0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v15 = qword_14012C0E0;
      }
      v16 = sub_140008DB0(a4);
      v13 = v15;
      v14 = (struct std::locale::facet *)v16;
    }
    else
    {
      v9 = (struct std::locale::facet *)operator new(0x30ui64);
      v10 = v9;
      if ( v9 )
      {
        *((_QWORD *)v9 + 1) = 0i64;
        *(_QWORD *)v9 = &std::ctype<wchar_t>::`vftable';
        v11 = Getctype(&v99);
        *((_QWORD *)v10 + 2) = *(_QWORD *)&v11->_Page;
        Table = (_Cvtvec *)v11->_Table;
        *((_QWORD *)v10 + 3) = Table;
        *((_QWORD *)v10 + 4) = *(_QWORD *)&v11->_Delfl;
        *((_QWORD *)v10 + 5) = Getcvt(Table);
      }
      else
      {
        v10 = 0i64;
      }
      v13 = qword_14012C0E0;
      if ( !qword_14012C0E0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C0E0 )
          qword_14012C0E0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v13 = qword_14012C0E0;
      }
      v14 = v10;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v14, v13);
  }
  if ( (a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v22 = qword_140130F40;
      if ( !qword_140130F40 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( qword_140130F40 == v22 )
          qword_140130F40 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v22 = qword_140130F40;
      }
      v23 = sub_1400070B0((__int64)a4);
      v20 = v22;
      v21 = (struct std::locale::facet *)v23;
    }
    else
    {
      v17 = (struct std::locale::facet *)operator new(0x18ui64);
      v19 = v17;
      if ( v17 )
      {
        *((_QWORD *)v17 + 1) = 0i64;
        *(_QWORD *)v17 = &std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
        *((_QWORD *)v17 + 2) = Getcvt(v18);
      }
      else
      {
        v19 = 0i64;
      }
      v20 = qword_140130F40;
      if ( !qword_140130F40 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F40 )
          qword_140130F40 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v20 = qword_140130F40;
      }
      v21 = v19;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v21, v20);
  }
  if ( (a2 & 8) != 0 )
  {
    if ( a4 )
    {
      v29 = qword_140130F50;
      if ( !qword_140130F50 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( qword_140130F50 == v29 )
          qword_140130F50 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v29 = qword_140130F50;
      }
      v30 = sub_14000F240((__int64)a4);
      v27 = v29;
      v28 = (struct std::locale::facet *)v30;
    }
    else
    {
      v24 = (struct std::locale::facet *)operator new(0x18ui64);
      v26 = v24;
      if ( v24 )
      {
        *((_QWORD *)v24 + 1) = 0i64;
        *(_QWORD *)v24 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_QWORD *)v24 + 2) = Getcvt(v25);
      }
      else
      {
        v26 = 0i64;
      }
      v27 = qword_140130F50;
      if ( !qword_140130F50 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F50 )
          qword_140130F50 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v27 = qword_140130F50;
      }
      v28 = v26;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v28, v27);
    if ( a4 )
    {
      v35 = qword_140130F38;
      if ( !qword_140130F38 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F38 )
          qword_140130F38 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v35 = qword_140130F38;
      }
      v36 = sub_140007200(a4);
      v33 = v35;
      v34 = (struct std::locale::facet *)v36;
    }
    else
    {
      v31 = (struct std::locale::facet *)operator new(0x30ui64);
      v32 = v31;
      Block[0] = v31;
      if ( v31 )
      {
        *((_QWORD *)v31 + 1) = 0i64;
        *(_QWORD *)v31 = &std::numpunct<wchar_t>::`vftable';
        sub_140007990((__int64)v31, a1, 0);
      }
      else
      {
        v32 = 0i64;
      }
      v33 = qword_140130F38;
      if ( !qword_140130F38 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F38 )
          qword_140130F38 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v33 = qword_140130F38;
      }
      v34 = v32;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v34, v33);
  }
  if ( ((1 << sub_140011E70(0i64, 0i64) >> 1) & a2) != 0 )
  {
    if ( a4 )
    {
      v42 = qword_140130F48;
      if ( !qword_140130F48 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F48 )
          qword_140130F48 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v42 = qword_140130F48;
      }
      v43 = sub_140011CF0(a4);
      v40 = v42;
      v41 = (struct std::locale::facet *)v43;
    }
    else
    {
      v37 = (struct std::locale::facet *)operator new(0x18ui64);
      v39 = v37;
      if ( v37 )
      {
        *((_QWORD *)v37 + 1) = 0i64;
        *(_QWORD *)v37 = &std::collate<wchar_t>::`vftable';
        *((_QWORD *)v37 + 2) = Getcoll(v38);
      }
      else
      {
        v39 = 0i64;
      }
      v40 = qword_140130F48;
      if ( !qword_140130F48 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F48 )
          qword_140130F48 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v40 = qword_140130F48;
      }
      v41 = v39;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v41, v40);
  }
  if ( (a2 & 0x20) != 0 )
  {
    if ( a4 )
    {
      v48 = qword_14012C490;
      if ( !qword_14012C490 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C490 )
          qword_14012C490 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v48 = qword_14012C490;
      }
      v49 = sub_14003507C((__int64)a4);
      v46 = v48;
      v47 = (struct std::locale::facet *)v49;
    }
    else
    {
      v44 = (struct std::locale::facet *)operator new(0x10ui64);
      v45 = v44;
      if ( v44 )
      {
        *((_QWORD *)v44 + 1) = 0i64;
        *(_QWORD *)v44 = &std::messages<wchar_t>::`vftable';
      }
      else
      {
        v45 = 0i64;
      }
      v46 = qword_14012C490;
      if ( !qword_14012C490 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C490 )
          qword_14012C490 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v46 = qword_14012C490;
      }
      v47 = v45;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v47, v46);
  }
  if ( (a2 & 4) != 0 )
  {
    if ( a4 )
    {
      v55 = qword_14012C4A0;
      if ( !qword_14012C4A0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( qword_14012C4A0 == v55 )
          qword_14012C4A0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v55 = qword_14012C4A0;
      }
      v56 = sub_1400351D0((__int64)a4);
      v53 = v55;
      v54 = (struct std::locale::facet *)v56;
    }
    else
    {
      v50 = (struct std::locale::facet *)operator new(0x18ui64);
      v52 = v50;
      if ( v50 )
      {
        *((_QWORD *)v50 + 1) = 0i64;
        *(_QWORD *)v50 = &std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
        *((_QWORD *)v50 + 2) = Getcvt(v51);
      }
      else
      {
        v52 = 0i64;
      }
      v53 = qword_14012C4A0;
      if ( !qword_14012C4A0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4A0 )
          qword_14012C4A0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v53 = qword_14012C4A0;
      }
      v54 = v52;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v54, v53);
  }
  if ( (a2 & 4) != 0 )
  {
    if ( a4 )
    {
      v62 = qword_14012C4F8;
      if ( !qword_14012C4F8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( qword_14012C4F8 == v62 )
          qword_14012C4F8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v62 = qword_14012C4F8;
      }
      v63 = sub_140035324((__int64)a4);
      v60 = v62;
      v61 = (struct std::locale::facet *)v63;
    }
    else
    {
      v57 = (struct std::locale::facet *)operator new(0x18ui64);
      v59 = v57;
      if ( v57 )
      {
        *((_QWORD *)v57 + 1) = 0i64;
        *(_QWORD *)v57 = &std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_QWORD *)v57 + 2) = Getcvt(v58);
      }
      else
      {
        v59 = 0i64;
      }
      v60 = qword_14012C4F8;
      if ( !qword_14012C4F8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4F8 )
          qword_14012C4F8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v60 = qword_14012C4F8;
      }
      v61 = v59;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v61, v60);
    if ( a4 )
    {
      v68 = qword_14012C4D8;
      if ( !qword_14012C4D8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( qword_14012C4D8 == v68 )
          qword_14012C4D8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v68 = qword_14012C4D8;
      }
      v69 = sub_1400373C0((__int64)a4);
      v66 = v68;
      v67 = (struct std::locale::facet *)v69;
    }
    else
    {
      v64 = (struct std::locale::facet *)operator new(0x50ui64);
      v65 = v64;
      Block[0] = v64;
      if ( v64 )
      {
        *((_QWORD *)v64 + 1) = 0i64;
        *(_QWORD *)v64 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v64 + 68) = 0;
        std::_Mpunct<wchar_t>::_Init(v64, a1, 0i64);
        *(_QWORD *)v65 = &std::moneypunct<wchar_t,0>::`vftable';
      }
      else
      {
        v65 = 0i64;
      }
      v66 = qword_14012C4D8;
      if ( !qword_14012C4D8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4D8 )
          qword_14012C4D8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v66 = qword_14012C4D8;
      }
      v67 = v65;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v67, v66);
    if ( a4 )
    {
      v74 = qword_14012C4C8;
      if ( !qword_14012C4C8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4C8 )
          qword_14012C4C8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v74 = qword_14012C4C8;
      }
      v75 = sub_140037514((__int64)a4);
      v72 = v74;
      v73 = (struct std::locale::facet *)v75;
    }
    else
    {
      v70 = (struct std::locale::facet *)operator new(0x50ui64);
      v71 = v70;
      Block[0] = v70;
      if ( v70 )
      {
        *((_QWORD *)v70 + 1) = 0i64;
        *(_QWORD *)v70 = &std::_Mpunct<wchar_t>::`vftable';
        *((_BYTE *)v70 + 68) = 1;
        std::_Mpunct<wchar_t>::_Init(v70, a1, 0i64);
        *(_QWORD *)v71 = &std::moneypunct<wchar_t,1>::`vftable';
      }
      else
      {
        v71 = 0i64;
      }
      v72 = qword_14012C4C8;
      if ( !qword_14012C4C8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4C8 )
          qword_14012C4C8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v72 = qword_14012C4C8;
      }
      v73 = v71;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v73, v72);
  }
  v76 = a2 & 0x10;
  if ( v76 )
  {
    if ( a4 )
    {
      v81 = qword_14012C4F0;
      if ( !qword_14012C4F0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4F0 )
          qword_14012C4F0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v81 = qword_14012C4F0;
      }
      v82 = sub_140037668((__int64)a4);
      v79 = v81;
      v80 = (struct std::locale::facet *)v82;
    }
    else
    {
      v77 = (struct std::locale::facet *)operator new(0x30ui64);
      v78 = v77;
      Block[0] = v77;
      if ( v77 )
      {
        *((_QWORD *)v77 + 1) = 0i64;
        *(_QWORD *)v77 = &std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
        std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(v77, a1);
      }
      else
      {
        v78 = 0i64;
      }
      v79 = qword_14012C4F0;
      if ( !qword_14012C4F0 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C4F0 )
          qword_14012C4F0 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v79 = qword_14012C4F0;
      }
      v80 = v78;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v80, v79);
  }
  if ( v76 )
  {
    if ( a4 )
    {
      v89 = qword_140130F70;
      if ( !qword_140130F70 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F70 )
          qword_140130F70 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v89 = qword_140130F70;
      }
      v90 = sub_140026610(a4);
      v87 = v89;
      v88 = (struct std::locale::facet *)v90;
    }
    else
    {
      v83 = (struct std::locale::facet *)operator new(0x20ui64);
      v85 = v83;
      if ( v83 )
      {
        *((_QWORD *)v83 + 1) = 0i64;
        *(_QWORD *)v83 = &std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
        *((_QWORD *)v83 + 2) = 0i64;
        *((_QWORD *)v83 + 3) = Getcvt(v84);
        v86 = sub_14002AAB0(a1, Block);
        *((_QWORD *)v85 + 2) = *v86;
        *v86 = 0i64;
        free(Block[0]);
      }
      else
      {
        v85 = 0i64;
      }
      v87 = qword_140130F70;
      if ( !qword_140130F70 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_140130F70 )
          qword_140130F70 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v87 = qword_140130F70;
      }
      v88 = v85;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v88, v87);
  }
  if ( v8 )
  {
    if ( a4 )
    {
      v96 = qword_14012C0C8;
      if ( !qword_14012C0C8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C0C8 )
          qword_14012C0C8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v96 = qword_14012C0C8;
      }
      v97 = sub_140035478(a4);
      v94 = v96;
      v95 = (struct std::locale::facet *)v97;
    }
    else
    {
      v91 = (struct std::locale::facet *)operator new(0x18ui64);
      v93 = v91;
      if ( v91 )
      {
        *((_QWORD *)v91 + 1) = 0i64;
        *(_QWORD *)v91 = &std::codecvt<wchar_t,char,int>::`vftable';
        *((_QWORD *)v91 + 2) = Getcvt(v92);
      }
      else
      {
        v93 = 0i64;
      }
      v94 = qword_14012C0C8;
      if ( !qword_14012C0C8 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v100, 0);
        if ( !qword_14012C0C8 )
          qword_14012C0C8 = ++dword_14012C0B0;
        std::_Lockit::~_Lockit((std::_Lockit *)&v100);
        v94 = qword_14012C0C8;
      }
      v95 = v93;
    }
    std::locale::_Locimp::_Locimp_Addfac(a3, v95, v94);
  }
}
// 1400412CD: conditional instruction was optimized away because edi.4 is in (1..FF)
// 14004175E: conditional instruction was optimized away because edi.4 is in (1..FF)
// 14004185C: conditional instruction was optimized away because edi.4 is in (1..FF)
// 140041132: variable 'v18' is possibly undefined
// 140041214: variable 'v25' is possibly undefined
// 140041402: variable 'v38' is possibly undefined
// 1400415C3: variable 'v51' is possibly undefined
// 1400416A5: variable 'v58' is possibly undefined
// 140041A7D: variable 'v84' is possibly undefined
// 140041B7F: variable 'v92' is possibly undefined
// 140011E70: using guessed type __int64 __fastcall sub_140011E70(_QWORD, _QWORD);
// 140026610: using guessed type __int64 __fastcall sub_140026610(_QWORD);
// 140033900: using guessed type __int64 __fastcall std::_Mpunct<wchar_t>::_Init(_QWORD, _QWORD, _QWORD);
// 140034A04: using guessed type __int64 __fastcall std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::_Init(_QWORD, _QWORD);
// 1400E4B98: using guessed type void *std::codecvt<wchar_t,char,int>::`vftable';
// 1400E4C38: using guessed type void *std::ctype<wchar_t>::`vftable';
// 1400E4D18: using guessed type void *std::time_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 1400E4D38: using guessed type void *std::num_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 1400E4DA8: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 1400E4DF8: using guessed type void *std::collate<wchar_t>::`vftable';
// 1400E4E20: using guessed type void *std::messages<wchar_t>::`vftable';
// 1400E4E48: using guessed type void *std::money_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 1400E4E68: using guessed type void *std::money_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 1400E4E88: using guessed type void *std::_Mpunct<wchar_t>::`vftable';
// 1400E5288: using guessed type void *std::numpunct<wchar_t>::`vftable';
// 1400E5708: using guessed type void *std::moneypunct<wchar_t,0>::`vftable';
// 1400E5788: using guessed type void *std::moneypunct<wchar_t,1>::`vftable';
// 1400E5808: using guessed type void *std::time_get<wchar_t,std::istreambuf_iterator<wchar_t>>::`vftable';
// 14012C0B0: using guessed type int dword_14012C0B0;

//----- (0000000140045320) ----------------------------------------------------
void *__fastcall sub_140045320(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';
  free(*((void **)Block + 2));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E6210: using guessed type void *std::time_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (0000000140045770) ----------------------------------------------------
__int64 __fastcall sub_140045770(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  char v8[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x10ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v8, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::messages<char>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v8);
  }
  return 6i64;
}
// 1400E6148: using guessed type void *std::messages<char>::`vftable';

//----- (0000000140045820) ----------------------------------------------------
__int64 __fastcall sub_140045820(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_get<char,std::istreambuf_iterator<char>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 14004589D: variable 'v7' is possibly undefined
// 1400E6170: using guessed type void *std::money_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00000001400458D8) ----------------------------------------------------
__int64 __fastcall sub_1400458D8(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  _Cvtvec *v7; // rcx
  char v9[72]; // [rsp+28h] [rbp-50h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x18ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      std::_Locinfo::_Locinfo((std::_Locinfo *)v9, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';
      v5[2] = Getcvt(v7);
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v9);
  }
  return 3i64;
}
// 140045955: variable 'v7' is possibly undefined
// 1400E6190: using guessed type void *std::money_put<char,std::ostreambuf_iterator<char>>::`vftable';

//----- (0000000140045BA4) ----------------------------------------------------
__int64 __fastcall sub_140045BA4(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C510;
  v12 = qword_14012C510;
  v3 = qword_14012C550;
  if ( !qword_14012C550 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C550 == v3 )
      qword_14012C550 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C550;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140045770(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C510 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C510: using guessed type __int64 qword_14012C510;

//----- (0000000140045CF8) ----------------------------------------------------
__int64 __fastcall sub_140045CF8(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C518;
  v12 = qword_14012C518;
  v3 = qword_14012C568;
  if ( !qword_14012C568 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C568 == v3 )
      qword_14012C568 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C568;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140045820(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C518 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C518: using guessed type __int64 qword_14012C518;

//----- (0000000140045E4C) ----------------------------------------------------
__int64 __fastcall sub_140045E4C(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C520;
  v12 = qword_14012C520;
  v3 = qword_14012C560;
  if ( !qword_14012C560 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C560 == v3 )
      qword_14012C560 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C560;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400458D8(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C520 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C520: using guessed type __int64 qword_14012C520;

//----- (0000000140045FA0) ----------------------------------------------------
__int64 __fastcall sub_140045FA0(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C528;
  v12 = qword_14012C528;
  v3 = qword_14012C580;
  if ( !qword_14012C580 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C580 == v3 )
      qword_14012C580 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C580;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_140045990(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C528 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 140045990: using guessed type __int64 __fastcall sub_140045990(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C528: using guessed type __int64 qword_14012C528;

//----- (00000001400460F4) ----------------------------------------------------
__int64 __fastcall sub_1400460F4(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<char>::`vftable';
      *((_BYTE *)v5 + 68) = 0;
      LOBYTE(v8) = 1;
      std::_Mpunct<char>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<char,0>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 140046184: variable 'v8' is possibly undefined
// 14004550C: using guessed type __int64 __fastcall std::_Mpunct<char>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E61B8: using guessed type void *std::_Mpunct<char>::`vftable';
// 1400E63B8: using guessed type void *std::moneypunct<char,0>::`vftable';

//----- (00000001400461C0) ----------------------------------------------------
__int64 __fastcall sub_1400461C0(_QWORD *a1, __int64 a2)
{
  char v4; // si
  _QWORD *v5; // rbx
  const char *v6; // rdx
  __int64 v7; // rax
  __int64 v8; // r8
  char v10[96]; // [rsp+28h] [rbp-60h] BYREF

  v4 = 0;
  if ( a1 && !*a1 )
  {
    v5 = operator new(0x50ui64);
    if ( v5 )
    {
      v6 = *(const char **)(*(_QWORD *)a2 + 40i64);
      if ( !v6 )
        v6 = (const char *)(*(_QWORD *)a2 + 48i64);
      v7 = std::_Locinfo::_Locinfo((std::_Locinfo *)v10, v6);
      v4 = 1;
      v5[1] = 0i64;
      *v5 = &std::_Mpunct<char>::`vftable';
      *((_BYTE *)v5 + 68) = 1;
      LOBYTE(v8) = 1;
      std::_Mpunct<char>::_Init(v5, v7, v8);
      *v5 = &std::moneypunct<char,1>::`vftable';
    }
    else
    {
      v5 = 0i64;
    }
    *a1 = v5;
    if ( (v4 & 1) != 0 )
      sub_140008C40((std::_Lockit *)v10);
  }
  return 3i64;
}
// 140046250: variable 'v8' is possibly undefined
// 14004550C: using guessed type __int64 __fastcall std::_Mpunct<char>::_Init(_QWORD, _QWORD, _QWORD);
// 1400E61B8: using guessed type void *std::_Mpunct<char>::`vftable';
// 1400E6438: using guessed type void *std::moneypunct<char,1>::`vftable';

//----- (000000014004628C) ----------------------------------------------------
__int64 __fastcall sub_14004628C(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (0000000140046290) ----------------------------------------------------
void *__fastcall sub_140046290(void *Block, char a2)
{
  *(_QWORD *)Block = &std::time_get<char,std::istreambuf_iterator<char>>::`vftable';
  j_j_free(*((void **)Block + 2));
  j_j_free(*((void **)Block + 3));
  *(_QWORD *)Block = &std::locale::facet::`vftable';
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E4360: using guessed type void *std::locale::facet::`vftable';
// 1400E64B8: using guessed type void *std::time_get<char,std::istreambuf_iterator<char>>::`vftable';

//----- (00000001400468DC) ----------------------------------------------------
__int64 __fastcall sub_1400468DC(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C530;
  v12 = qword_14012C530;
  v3 = qword_14012C588;
  if ( !qword_14012C588 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C588 == v3 )
      qword_14012C588 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C588;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400460F4(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C530 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C530: using guessed type __int64 qword_14012C530;

//----- (0000000140046A30) ----------------------------------------------------
__int64 __fastcall sub_140046A30(__int64 a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C538;
  v12 = qword_14012C538;
  v3 = qword_14012C558;
  if ( !qword_14012C558 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C558 == v3 )
      qword_14012C558 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C558;
  }
  v4 = *(_QWORD *)a1;
  if ( v3 >= *(_QWORD *)(*(_QWORD *)a1 + 24i64) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400461C0(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C538 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C538: using guessed type __int64 qword_14012C538;

//----- (0000000140046B84) ----------------------------------------------------
__int64 __fastcall sub_140046B84(__int64 *a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rcx
  char pExceptionObject[48]; // [rsp+28h] [rbp-30h] BYREF
  char v10; // [rsp+60h] [rbp+8h] BYREF
  char v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)&v11, 0);
  v2 = qword_14012C540;
  v12 = qword_14012C540;
  v3 = qword_14012C578;
  if ( !qword_14012C578 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    if ( qword_14012C578 == v3 )
      qword_14012C578 = ++dword_14012C0B0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
    v3 = qword_14012C578;
  }
  v4 = *a1;
  if ( v3 >= *(_QWORD *)(*a1 + 24) )
    v5 = 0i64;
  else
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 16) + 8 * v3);
  if ( !v5 )
  {
    if ( *(_BYTE *)(v4 + 36) )
    {
      v6 = sub_14002BB90();
      if ( v3 >= *(_QWORD *)(v6 + 24) )
        v5 = 0i64;
      else
        v5 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * v3);
    }
    if ( !v5 )
    {
      if ( v2 )
      {
        v5 = v2;
      }
      else
      {
        if ( sub_1400462E0(&v12, a1) == -1 )
        {
          sub_14004AED0((std::exception *)pExceptionObject, "bad cast");
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
        }
        v5 = v12;
        qword_14012C540 = v12;
        std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
        v7 = *(_QWORD *)(v5 + 8);
        if ( v7 != -1 )
          *(_QWORD *)(v5 + 8) = v7 + 1;
        std::_Lockit::~_Lockit((std::_Lockit *)&v10);
        unknown_libname_19(v5);
      }
    }
  }
  std::_Lockit::~_Lockit((std::_Lockit *)&v11);
  return v5;
}
// 14002BAC0: using guessed type __int64 __fastcall unknown_libname_19(_QWORD);
// 1400462E0: using guessed type __int64 __fastcall sub_1400462E0(_QWORD, _QWORD);
// 14012C0B0: using guessed type int dword_14012C0B0;
// 14012C540: using guessed type __int64 qword_14012C540;

//----- (000000014004AAC4) ----------------------------------------------------
void *__fastcall sub_14004AAC4(void *Block, char a2)
{
  *(_QWORD *)Block = &type_info::`vftable';
  unknown_libname_86();
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 140052CE8: using guessed type __int64 unknown_libname_86(void);
// 1400E6780: using guessed type void *type_info::`vftable';

//----- (000000014004AEC0) ----------------------------------------------------
void __fastcall sub_14004AEC0(std::exception *a1)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  std::exception::_Tidy(a1);
}
// 1400E6790: using guessed type void *std::exception::`vftable';

//----- (000000014004AED0) ----------------------------------------------------
std::exception *__fastcall sub_14004AED0(std::exception *a1, char *a2)
{
  std::exception *result; // rax
  char *v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = a2;
  std::exception::exception(a1, (const char *const *)&v4);
  result = a1;
  *(_QWORD *)a1 = &std::bad_cast::`vftable';
  return result;
}
// 1400E67C0: using guessed type void *std::bad_cast::`vftable';

//----- (000000014004AEFC) ----------------------------------------------------
void *__fastcall sub_14004AEFC(void *Block, char a2)
{
  *(_QWORD *)Block = &std::exception::`vftable';
  std::exception::_Tidy((std::exception *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E6790: using guessed type void *std::exception::`vftable';

//----- (000000014004AF64) ----------------------------------------------------
std::exception *__fastcall sub_14004AF64(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::bad_cast::`vftable';
  return a1;
}
// 1400E67C0: using guessed type void *std::bad_cast::`vftable';

//----- (000000014004DD20) ----------------------------------------------------
__int64 sub_14004DD20()
{
  return 0i64;
}

//----- (0000000140050030) ----------------------------------------------------
void __fastcall sub_140050030(std::exception *a1)
{
  *(_QWORD *)a1 = &std::bad_exception::`vftable';
  sub_14004AEC0(a1);
}
// 1400E72B8: using guessed type void *std::bad_exception::`vftable';

//----- (0000000140050040) ----------------------------------------------------
void *__fastcall sub_140050040(void *Block, char a2)
{
  *(_QWORD *)Block = &std::bad_exception::`vftable';
  sub_14004AEC0((std::exception *)Block);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E72B8: using guessed type void *std::bad_exception::`vftable';

//----- (000000014005116C) ----------------------------------------------------
std::exception *__fastcall sub_14005116C(std::exception *a1, const struct std::exception *a2)
{
  std::exception::exception(a1, a2);
  *(_QWORD *)a1 = &std::bad_exception::`vftable';
  return a1;
}
// 1400E72B8: using guessed type void *std::bad_exception::`vftable';

//----- (0000000140052AD0) ----------------------------------------------------
void __fastcall sub_140052AD0(void *a1)
{
  qword_14012CB50 = a1;
}

//----- (000000014005343C) ----------------------------------------------------
void __fastcall sub_14005343C(void *a1)
{
  qword_14012D1F0 = a1;
}

//----- (00000001400545E0) ----------------------------------------------------
PVOID sub_1400545E0()
{
  return EncodePointer(0i64);
}

//----- (0000000140054EBC) ----------------------------------------------------
void __fastcall sub_140054EBC(void *a1)
{
  qword_14012D208 = a1;
}

//----- (000000014005592C) ----------------------------------------------------
void sub_14005592C()
{
  void (**i)(void); // rbx

  for ( i = qword_140100138; i < qword_140100138; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140100138: using guessed type void (*qword_140100138[2])(void);

//----- (0000000140055964) ----------------------------------------------------
void __fastcall sub_140055964()
{
  void (**i)(void); // rbx

  for ( i = &qword_140100148; i < &qword_140100148; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140100148: using guessed type void (*qword_140100148)(void);

//----- (0000000140056298) ----------------------------------------------------
__int64 __fastcall sub_140056298(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_14011CA64;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14011CA64: using guessed type int dword_14011CA64;

//----- (00000001400562C8) ----------------------------------------------------
__int64 __fastcall sub_1400562C8(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_14011CA68;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14011CA68: using guessed type int dword_14011CA68;

//----- (00000001400562F8) ----------------------------------------------------
__int64 __fastcall sub_1400562F8(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_14011CA60;
    return 0i64;
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
    return 22i64;
  }
}
// 14011CA60: using guessed type int dword_14011CA60;

//----- (0000000140056328) ----------------------------------------------------
int *sub_140056328()
{
  return &dword_14011CA64;
}
// 14011CA64: using guessed type int dword_14011CA64;

//----- (0000000140056330) ----------------------------------------------------
int *sub_140056330()
{
  return &dword_14011CA68;
}
// 14011CA68: using guessed type int dword_14011CA68;

//----- (0000000140056338) ----------------------------------------------------
int *sub_140056338()
{
  return &dword_14011CA60;
}
// 14011CA60: using guessed type int dword_14011CA60;

//----- (0000000140056340) ----------------------------------------------------
void **sub_140056340()
{
  return &off_14011CAF0;
}
// 14011CAF0: using guessed type void *off_14011CAF0;

//----- (0000000140056B58) ----------------------------------------------------
void *sub_140056B58()
{
  return &unk_14011CC80;
}

//----- (0000000140056B60) ----------------------------------------------------
char **sub_140056B60()
{
  return off_14011CB20;
}
// 14011CB20: using guessed type char *off_14011CB20[44];

//----- (000000014005A644) ----------------------------------------------------
PVOID sub_14005A644()
{
  return DecodePointer((PVOID)qword_14012D640);
}
// 14012D640: using guessed type __int64 qword_14012D640;

//----- (000000014005A888) ----------------------------------------------------
void sub_14005A888()
{
  dword_140131FA4 = 0;
}
// 140131FA4: using guessed type int dword_140131FA4;

//----- (000000014005B300) ----------------------------------------------------
void **sub_14005B300()
{
  return &off_14011CF40;
}
// 14011CF40: using guessed type void *off_14011CF40;

//----- (000000014005B8D4) ----------------------------------------------------
void __fastcall sub_14005B8D4(__int64 a1)
{
  qword_14012D6D0 = a1;
}
// 14012D6D0: using guessed type __int64 qword_14012D6D0;

//----- (000000014005B9A4) ----------------------------------------------------
__int64 __fastcall sub_14005B9A4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // rbx
  PVOID v7; // rdi
  HMODULE LibraryW; // rax
  HMODULE v9; // rsi
  int (__stdcall *MessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT); // rax
  HWND (__stdcall *GetActiveWindow)(); // rax
  HWND (__stdcall *GetLastActivePopup)(HWND); // rax
  BOOL (__stdcall *GetUserObjectInformationW)(HANDLE, int, PVOID, DWORD, LPDWORD); // rax
  PVOID v14; // r11
  HWINSTA (__stdcall *GetProcessWindowStation)(); // rax
  PVOID v16; // rax
  __int64 (*v17)(void); // rsi
  unsigned int (__fastcall *v18)(__int64, __int64, char *); // rax
  unsigned int (__fastcall *v19)(__int64, __int64, char *); // r12
  __int64 v20; // rax
  __int64 (*v21)(void); // rax
  __int64 (__fastcall *v22)(__int64); // rax
  __int64 (__fastcall *v23)(__int64, __int64, __int64, _QWORD); // rax
  char v25[16]; // [rsp+38h] [rbp-50h] BYREF

  v6 = 0i64;
  v7 = sub_1400545E0();
  if ( qword_14012D6D8 )
  {
    v16 = qword_14012D6F0;
    goto LABEL_8;
  }
  LibraryW = LoadLibraryW(L"USER32.DLL");
  v9 = LibraryW;
  if ( !LibraryW )
    return 0i64;
  MessageBoxW = (int (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))GetProcAddress(LibraryW, "MessageBoxW");
  if ( !MessageBoxW )
    return 0i64;
  qword_14012D6D8 = EncodePointer(MessageBoxW);
  GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v9, "GetActiveWindow");
  qword_14012D6E0 = EncodePointer(GetActiveWindow);
  GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v9, "GetLastActivePopup");
  qword_14012D6E8 = EncodePointer(GetLastActivePopup);
  GetUserObjectInformationW = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                        v9,
                                                                                        "GetUserObjectInformationW");
  v14 = EncodePointer(GetUserObjectInformationW);
  qword_14012D6F8 = v14;
  if ( v14 )
  {
    GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v9, "GetProcessWindowStation");
    v16 = EncodePointer(GetProcessWindowStation);
    qword_14012D6F0 = v16;
LABEL_8:
    v14 = qword_14012D6F8;
    goto LABEL_9;
  }
  v16 = qword_14012D6F0;
LABEL_9:
  if ( v16 == v7
    || v14 == v7
    || (v17 = (__int64 (*)(void))DecodePointer(v16),
        v18 = (unsigned int (__fastcall *)(__int64, __int64, char *))DecodePointer(qword_14012D6F8),
        v19 = v18,
        !v17)
    || !v18
    || (v20 = v17()) != 0 && v19(v20, 1i64, v25) && (v25[8] & 1) != 0 )
  {
    if ( qword_14012D6E0 != v7 )
    {
      v21 = (__int64 (*)(void))DecodePointer(qword_14012D6E0);
      if ( v21 )
      {
        v6 = v21();
        if ( v6 )
        {
          if ( qword_14012D6E8 != v7 )
          {
            v22 = (__int64 (__fastcall *)(__int64))DecodePointer(qword_14012D6E8);
            if ( v22 )
              v6 = v22(v6);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v23 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))DecodePointer(qword_14012D6D8);
  if ( v23 )
    return v23(v6, a1, a2, a3);
  return 0i64;
}

//----- (000000014005D248) ----------------------------------------------------
__int64 __fastcall sub_14005D248(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  char v5; // bl
  int v6; // eax
  char v8[16]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v9; // [rsp+50h] [rbp-30h]
  char v10; // [rsp+58h] [rbp-28h]
  char v11; // [rsp+60h] [rbp-20h] BYREF
  __int16 v12[8]; // [rsp+68h] [rbp-18h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v8, a3);
  v5 = _strgtold12_l((unsigned int)v12, (unsigned int)&v11, a2, 0, 0, 0, 0, (__int64)v8);
  v6 = sub_14005D6A0((unsigned __int16 *)v12, a1);
  if ( (v5 & 3) != 0 )
  {
    if ( (v5 & 1) != 0 )
    {
LABEL_7:
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 4i64;
    }
    if ( (v5 & 2) != 0 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3i64;
    }
  }
  else
  {
    if ( v6 == 1 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3i64;
    }
    if ( v6 == 2 )
      goto LABEL_7;
  }
  if ( v10 )
    *(_DWORD *)(v9 + 200) &= ~2u;
  return 0i64;
}
// 14005E238: using guessed type __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 14005D248: using guessed type unsigned __int16 var_18[8];

//----- (000000014005D348) ----------------------------------------------------
__int64 __fastcall sub_14005D348(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  char v5; // bl
  int v6; // eax
  char v8[16]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v9; // [rsp+50h] [rbp-30h]
  char v10; // [rsp+58h] [rbp-28h]
  char v11; // [rsp+60h] [rbp-20h] BYREF
  __int16 v12[8]; // [rsp+68h] [rbp-18h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v8, a3);
  v5 = _strgtold12_l((unsigned int)v12, (unsigned int)&v11, a2, 0, 0, 0, 0, (__int64)v8);
  v6 = sub_14005DC6C((unsigned __int16 *)v12, a1);
  if ( (v5 & 3) != 0 )
  {
    if ( (v5 & 1) != 0 )
    {
LABEL_7:
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 4i64;
    }
    if ( (v5 & 2) != 0 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3i64;
    }
  }
  else
  {
    if ( v6 == 1 )
    {
      if ( v10 )
        *(_DWORD *)(v9 + 200) &= ~2u;
      return 3i64;
    }
    if ( v6 == 2 )
      goto LABEL_7;
  }
  if ( v10 )
    *(_DWORD *)(v9 + 200) &= ~2u;
  return 0i64;
}
// 14005E238: using guessed type __int64 __fastcall _strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 14005D348: using guessed type unsigned __int16 var_18[8];

//----- (000000014005D6A0) ----------------------------------------------------
__int64 __fastcall sub_14005D6A0(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned int v2; // ebx
  unsigned __int16 v3; // di
  int v4; // edi
  __int64 v5; // r12
  int v6; // er8
  __int64 v7; // rax
  int v8; // er13
  int v9; // er10
  unsigned int v10; // er11
  int v11; // ecx
  __int64 j; // rax
  int v13; // er8
  __int64 v14; // r9
  unsigned int v15; // eax
  unsigned int v16; // edx
  unsigned int v17; // ecx
  int v18; // er8
  __int64 i; // rdx
  unsigned int v20; // eax
  int v21; // er9
  __int64 *v22; // r8
  __int64 v23; // r10
  int v24; // eax
  int v25; // er11
  __int64 n; // r8
  int v27; // er10
  unsigned int v28; // er11
  int v29; // ecx
  __int64 jj; // rax
  int v31; // er8
  __int64 v32; // r13
  unsigned int v33; // eax
  unsigned int v34; // er9
  int v35; // ecx
  unsigned int v36; // edx
  int v37; // er8
  __int64 ii; // rdx
  unsigned int v39; // eax
  int v40; // er9
  __int64 *v41; // r8
  int v42; // eax
  int v43; // er10
  __int64 kk; // r8
  int v45; // edx
  char v46; // al
  char v47; // al
  int v48; // er10
  int v49; // er9
  __int64 *v50; // r8
  __int64 m; // rdi
  char v52; // al
  int v53; // er11
  int v54; // er10
  __int64 *v55; // r9
  __int64 k; // rdi
  int v57; // er8
  int v58; // eax
  int v60; // [rsp+20h] [rbp-40h]
  int v61; // [rsp+20h] [rbp-40h]
  int v62; // [rsp+20h] [rbp-40h]
  int v63; // [rsp+20h] [rbp-40h]
  int v64; // [rsp+20h] [rbp-40h]
  int v65; // [rsp+24h] [rbp-3Ch]
  _DWORD *v66; // [rsp+28h] [rbp-38h]
  __int64 v67; // [rsp+30h] [rbp-30h] BYREF
  int v68; // [rsp+38h] [rbp-28h]
  __int64 v69; // [rsp+40h] [rbp-20h]
  int v70; // [rsp+48h] [rbp-18h]

  v2 = 0;
  v3 = a1[5];
  v66 = a2;
  v65 = v3 & 0x8000;
  LODWORD(v67) = *(_DWORD *)(a1 + 3);
  v4 = (v3 & 0x7FFF) - 0x3FFF;
  HIDWORD(v67) = *(_DWORD *)(a1 + 1);
  v5 = 3i64;
  v68 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v6 = 0;
    v7 = 0i64;
    while ( !*((_DWORD *)&v67 + v7) )
    {
      if ( ++v7 >= 3 )
        goto LABEL_80;
    }
    v67 = 0i64;
    v68 = 0;
    v2 = 2;
  }
  else
  {
    v60 = v4;
    v69 = v67;
    v8 = 0;
    v70 = v68;
    v9 = dword_14011D388 / 32;
    v10 = 31 - dword_14011D388 % 32;
    v11 = *((_DWORD *)&v67 + dword_14011D388 / 32);
    if ( _bittest(&v11, v10) )
    {
      if ( (~(-1 << v10) & *((_DWORD *)&v67 + v9)) != 0 )
      {
LABEL_14:
        v13 = (dword_14011D388 - 1) / 32;
        v14 = v13;
        v15 = *((_DWORD *)&v67 + v13);
        v16 = 1 << (31 - (dword_14011D388 - 1) % 32);
        v17 = v15 + v16;
        if ( v15 + v16 < v15 || v17 < v16 )
          v8 = 1;
        v18 = v13 - 1;
        *((_DWORD *)&v67 + v14) = v17;
        for ( i = v18; i >= 0; *((_DWORD *)&v67 + i--) = v20 + 1 )
        {
          if ( !v8 )
            break;
          v20 = *((_DWORD *)&v67 + i);
          v8 = 0;
          if ( v20 + 1 < v20 || v20 == -1 )
            v8 = 1;
        }
      }
      else
      {
        for ( j = v9 + 1; j < 3; ++j )
        {
          if ( *((_DWORD *)&v67 + j) )
            goto LABEL_14;
        }
      }
    }
    *((_DWORD *)&v67 + v9) &= -1 << v10;
    if ( v9 + 1 < 3i64 )
      memset((char *)&v67 + 4 * v9 + 4, 0, 4 * (3i64 - (v9 + 1)));
    if ( v8 )
      ++v4;
    if ( v4 >= dword_14011D384 - dword_14011D388 )
    {
      if ( v4 > dword_14011D384 )
      {
        v45 = (dword_14011D38C >> 31) & 0x1F;
        v46 = v45 + dword_14011D38C;
        if ( v4 < dword_14011D380 )
        {
          LODWORD(v67) = v67 & 0x7FFFFFFF;
          v6 = v4 + dword_14011D394;
          v52 = (v46 & 0x1F) - v45;
          v53 = dword_14011D38C / 32;
          v54 = 0;
          v55 = &v67;
          do
          {
            v64 = ~(-1 << v52) & *(_DWORD *)v55;
            *(_DWORD *)v55 = v54 | (*(_DWORD *)v55 >> v52);
            v55 = (__int64 *)((char *)v55 + 4);
            v54 = v64 << (32 - v52);
            --v5;
          }
          while ( v5 );
          for ( k = 2i64; k >= 0; --k )
          {
            if ( k < v53 )
              *((_DWORD *)&v67 + k) = 0;
            else
              *((_DWORD *)&v67 + k) = *(_DWORD *)((char *)&v67 + 4 * k - 4i64 * v53);
          }
        }
        else
        {
          v47 = (v46 & 0x1F) - v45;
          v67 = 0x80000000i64;
          v48 = dword_14011D38C / 32;
          v68 = 0;
          v49 = 0;
          v50 = &v67;
          do
          {
            v63 = ~(-1 << v47) & *(_DWORD *)v50;
            *(_DWORD *)v50 = v49 | (*(_DWORD *)v50 >> v47);
            v50 = (__int64 *)((char *)v50 + 4);
            v49 = v63 << (32 - v47);
            --v5;
          }
          while ( v5 );
          for ( m = 2i64; m >= 0; --m )
          {
            if ( m < v48 )
              *((_DWORD *)&v67 + m) = 0;
            else
              *((_DWORD *)&v67 + m) = *(_DWORD *)((char *)&v67 + 4 * m - 4i64 * v48);
          }
          v2 = 1;
          v6 = dword_14011D380 + dword_14011D394;
        }
      }
      else
      {
        v21 = 0;
        v22 = &v67;
        v67 = v69;
        v68 = v70;
        v23 = 3i64;
        v24 = (dword_14011D384 - v60) % 32;
        v25 = (dword_14011D384 - v60) / 32;
        do
        {
          v61 = ~(-1 << v24) & *(_DWORD *)v22;
          *(_DWORD *)v22 = v21 | (*(_DWORD *)v22 >> v24);
          v22 = (__int64 *)((char *)v22 + 4);
          v21 = v61 << (32 - v24);
          --v23;
        }
        while ( v23 );
        for ( n = 2i64; n >= 0; --n )
        {
          if ( n < v25 )
            *((_DWORD *)&v67 + n) = 0;
          else
            *((_DWORD *)&v67 + n) = *(_DWORD *)((char *)&v67 + 4 * n - 4i64 * v25);
        }
        v27 = dword_14011D388 / 32;
        v28 = 31 - dword_14011D388 % 32;
        v29 = *((_DWORD *)&v67 + dword_14011D388 / 32);
        if ( _bittest(&v29, v28) )
        {
          if ( (~(-1 << v28) & *((_DWORD *)&v67 + v27)) != 0 )
          {
LABEL_44:
            v31 = (dword_14011D388 - 1) / 32;
            v32 = v31;
            v33 = *((_DWORD *)&v67 + v31);
            v34 = 1 << (31 - (dword_14011D388 - 1) % 32);
            v35 = 0;
            v36 = v33 + v34;
            if ( v33 + v34 < v33 || v36 < v34 )
              v35 = 1;
            v37 = v31 - 1;
            *((_DWORD *)&v67 + v32) = v36;
            for ( ii = v37; ii >= 0; *((_DWORD *)&v67 + ii--) = v39 + 1 )
            {
              if ( !v35 )
                break;
              v39 = *((_DWORD *)&v67 + ii);
              v35 = 0;
              if ( v39 + 1 < v39 || v39 == -1 )
                v35 = 1;
            }
          }
          else
          {
            for ( jj = v27 + 1; jj < 3; ++jj )
            {
              if ( *((_DWORD *)&v67 + jj) )
                goto LABEL_44;
            }
          }
        }
        *((_DWORD *)&v67 + v27) &= -1 << v28;
        if ( v27 + 1 < 3i64 )
          memset((char *)&v67 + 4 * v27 + 4, 0, 4 * (3i64 - (v27 + 1)));
        v40 = 0;
        v41 = &v67;
        v42 = (dword_14011D38C + 1) % 32;
        v43 = (dword_14011D38C + 1) / 32;
        do
        {
          v62 = ~(-1 << v42) & *(_DWORD *)v41;
          *(_DWORD *)v41 = v40 | (*(_DWORD *)v41 >> v42);
          v41 = (__int64 *)((char *)v41 + 4);
          v40 = v62 << (32 - v42);
          --v5;
        }
        while ( v5 );
        for ( kk = 2i64; kk >= 0; --kk )
        {
          if ( kk < v43 )
            *((_DWORD *)&v67 + kk) = 0;
          else
            *((_DWORD *)&v67 + kk) = *(_DWORD *)((char *)&v67 + 4 * kk - 4i64 * v43);
        }
        v6 = 0;
        v2 = 2;
      }
    }
    else
    {
      v67 = 0i64;
      v68 = 0;
      v6 = 0;
      v2 = 2;
    }
    a2 = v66;
  }
LABEL_80:
  v57 = v67 | (v65 != 0 ? 0x80000000 : 0) | (v6 << (31 - dword_14011D38C));
  if ( dword_14011D390 == 64 )
  {
    v58 = HIDWORD(v67);
    a2[1] = v57;
    *a2 = v58;
  }
  else if ( dword_14011D390 == 32 )
  {
    *a2 = v57;
  }
  return v2;
}
// 14011D380: using guessed type int dword_14011D380;
// 14011D384: using guessed type int dword_14011D384;
// 14011D388: using guessed type int dword_14011D388;
// 14011D38C: using guessed type int dword_14011D38C;
// 14011D390: using guessed type int dword_14011D390;
// 14011D394: using guessed type int dword_14011D394;

//----- (000000014005DC6C) ----------------------------------------------------
__int64 __fastcall sub_14005DC6C(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned int v2; // ebx
  unsigned __int16 v3; // di
  int v4; // edi
  __int64 v5; // r12
  int v6; // er8
  __int64 v7; // rax
  int v8; // er13
  int v9; // er10
  unsigned int v10; // er11
  int v11; // ecx
  __int64 j; // rax
  int v13; // er8
  __int64 v14; // r9
  unsigned int v15; // eax
  unsigned int v16; // edx
  unsigned int v17; // ecx
  int v18; // er8
  __int64 i; // rdx
  unsigned int v20; // eax
  int v21; // er9
  __int64 *v22; // r8
  __int64 v23; // r10
  int v24; // eax
  int v25; // er11
  __int64 n; // r8
  int v27; // er10
  unsigned int v28; // er11
  int v29; // ecx
  __int64 jj; // rax
  int v31; // er8
  __int64 v32; // r13
  unsigned int v33; // eax
  unsigned int v34; // er9
  int v35; // ecx
  unsigned int v36; // edx
  int v37; // er8
  __int64 ii; // rdx
  unsigned int v39; // eax
  int v40; // er9
  __int64 *v41; // r8
  int v42; // eax
  int v43; // er10
  __int64 kk; // r8
  int v45; // edx
  char v46; // al
  char v47; // al
  int v48; // er10
  int v49; // er9
  __int64 *v50; // r8
  __int64 m; // rdi
  char v52; // al
  int v53; // er11
  int v54; // er10
  __int64 *v55; // r9
  __int64 k; // rdi
  int v57; // er8
  int v58; // eax
  int v60; // [rsp+20h] [rbp-40h]
  int v61; // [rsp+20h] [rbp-40h]
  int v62; // [rsp+20h] [rbp-40h]
  int v63; // [rsp+20h] [rbp-40h]
  int v64; // [rsp+20h] [rbp-40h]
  int v65; // [rsp+24h] [rbp-3Ch]
  _DWORD *v66; // [rsp+28h] [rbp-38h]
  __int64 v67; // [rsp+30h] [rbp-30h] BYREF
  int v68; // [rsp+38h] [rbp-28h]
  __int64 v69; // [rsp+40h] [rbp-20h]
  int v70; // [rsp+48h] [rbp-18h]

  v2 = 0;
  v3 = a1[5];
  v66 = a2;
  v65 = v3 & 0x8000;
  LODWORD(v67) = *(_DWORD *)(a1 + 3);
  v4 = (v3 & 0x7FFF) - 0x3FFF;
  HIDWORD(v67) = *(_DWORD *)(a1 + 1);
  v5 = 3i64;
  v68 = *a1 << 16;
  if ( v4 == -16383 )
  {
    v6 = 0;
    v7 = 0i64;
    while ( !*((_DWORD *)&v67 + v7) )
    {
      if ( ++v7 >= 3 )
        goto LABEL_80;
    }
    v67 = 0i64;
    v68 = 0;
    v2 = 2;
  }
  else
  {
    v60 = v4;
    v69 = v67;
    v8 = 0;
    v70 = v68;
    v9 = dword_14011D3A0 / 32;
    v10 = 31 - dword_14011D3A0 % 32;
    v11 = *((_DWORD *)&v67 + dword_14011D3A0 / 32);
    if ( _bittest(&v11, v10) )
    {
      if ( (~(-1 << v10) & *((_DWORD *)&v67 + v9)) != 0 )
      {
LABEL_14:
        v13 = (dword_14011D3A0 - 1) / 32;
        v14 = v13;
        v15 = *((_DWORD *)&v67 + v13);
        v16 = 1 << (31 - (dword_14011D3A0 - 1) % 32);
        v17 = v15 + v16;
        if ( v15 + v16 < v15 || v17 < v16 )
          v8 = 1;
        v18 = v13 - 1;
        *((_DWORD *)&v67 + v14) = v17;
        for ( i = v18; i >= 0; *((_DWORD *)&v67 + i--) = v20 + 1 )
        {
          if ( !v8 )
            break;
          v20 = *((_DWORD *)&v67 + i);
          v8 = 0;
          if ( v20 + 1 < v20 || v20 == -1 )
            v8 = 1;
        }
      }
      else
      {
        for ( j = v9 + 1; j < 3; ++j )
        {
          if ( *((_DWORD *)&v67 + j) )
            goto LABEL_14;
        }
      }
    }
    *((_DWORD *)&v67 + v9) &= -1 << v10;
    if ( v9 + 1 < 3i64 )
      memset((char *)&v67 + 4 * v9 + 4, 0, 4 * (3i64 - (v9 + 1)));
    if ( v8 )
      ++v4;
    if ( v4 >= dword_14011D39C - dword_14011D3A0 )
    {
      if ( v4 > dword_14011D39C )
      {
        v45 = (dword_14011D3A4 >> 31) & 0x1F;
        v46 = v45 + dword_14011D3A4;
        if ( v4 < dword_14011D398 )
        {
          LODWORD(v67) = v67 & 0x7FFFFFFF;
          v6 = v4 + dword_14011D3AC;
          v52 = (v46 & 0x1F) - v45;
          v53 = dword_14011D3A4 / 32;
          v54 = 0;
          v55 = &v67;
          do
          {
            v64 = ~(-1 << v52) & *(_DWORD *)v55;
            *(_DWORD *)v55 = v54 | (*(_DWORD *)v55 >> v52);
            v55 = (__int64 *)((char *)v55 + 4);
            v54 = v64 << (32 - v52);
            --v5;
          }
          while ( v5 );
          for ( k = 2i64; k >= 0; --k )
          {
            if ( k < v53 )
              *((_DWORD *)&v67 + k) = 0;
            else
              *((_DWORD *)&v67 + k) = *(_DWORD *)((char *)&v67 + 4 * k - 4i64 * v53);
          }
        }
        else
        {
          v47 = (v46 & 0x1F) - v45;
          v67 = 0x80000000i64;
          v48 = dword_14011D3A4 / 32;
          v68 = 0;
          v49 = 0;
          v50 = &v67;
          do
          {
            v63 = ~(-1 << v47) & *(_DWORD *)v50;
            *(_DWORD *)v50 = v49 | (*(_DWORD *)v50 >> v47);
            v50 = (__int64 *)((char *)v50 + 4);
            v49 = v63 << (32 - v47);
            --v5;
          }
          while ( v5 );
          for ( m = 2i64; m >= 0; --m )
          {
            if ( m < v48 )
              *((_DWORD *)&v67 + m) = 0;
            else
              *((_DWORD *)&v67 + m) = *(_DWORD *)((char *)&v67 + 4 * m - 4i64 * v48);
          }
          v2 = 1;
          v6 = dword_14011D398 + dword_14011D3AC;
        }
      }
      else
      {
        v21 = 0;
        v22 = &v67;
        v67 = v69;
        v68 = v70;
        v23 = 3i64;
        v24 = (dword_14011D39C - v60) % 32;
        v25 = (dword_14011D39C - v60) / 32;
        do
        {
          v61 = ~(-1 << v24) & *(_DWORD *)v22;
          *(_DWORD *)v22 = v21 | (*(_DWORD *)v22 >> v24);
          v22 = (__int64 *)((char *)v22 + 4);
          v21 = v61 << (32 - v24);
          --v23;
        }
        while ( v23 );
        for ( n = 2i64; n >= 0; --n )
        {
          if ( n < v25 )
            *((_DWORD *)&v67 + n) = 0;
          else
            *((_DWORD *)&v67 + n) = *(_DWORD *)((char *)&v67 + 4 * n - 4i64 * v25);
        }
        v27 = dword_14011D3A0 / 32;
        v28 = 31 - dword_14011D3A0 % 32;
        v29 = *((_DWORD *)&v67 + dword_14011D3A0 / 32);
        if ( _bittest(&v29, v28) )
        {
          if ( (~(-1 << v28) & *((_DWORD *)&v67 + v27)) != 0 )
          {
LABEL_44:
            v31 = (dword_14011D3A0 - 1) / 32;
            v32 = v31;
            v33 = *((_DWORD *)&v67 + v31);
            v34 = 1 << (31 - (dword_14011D3A0 - 1) % 32);
            v35 = 0;
            v36 = v33 + v34;
            if ( v33 + v34 < v33 || v36 < v34 )
              v35 = 1;
            v37 = v31 - 1;
            *((_DWORD *)&v67 + v32) = v36;
            for ( ii = v37; ii >= 0; *((_DWORD *)&v67 + ii--) = v39 + 1 )
            {
              if ( !v35 )
                break;
              v39 = *((_DWORD *)&v67 + ii);
              v35 = 0;
              if ( v39 + 1 < v39 || v39 == -1 )
                v35 = 1;
            }
          }
          else
          {
            for ( jj = v27 + 1; jj < 3; ++jj )
            {
              if ( *((_DWORD *)&v67 + jj) )
                goto LABEL_44;
            }
          }
        }
        *((_DWORD *)&v67 + v27) &= -1 << v28;
        if ( v27 + 1 < 3i64 )
          memset((char *)&v67 + 4 * v27 + 4, 0, 4 * (3i64 - (v27 + 1)));
        v40 = 0;
        v41 = &v67;
        v42 = (dword_14011D3A4 + 1) % 32;
        v43 = (dword_14011D3A4 + 1) / 32;
        do
        {
          v62 = ~(-1 << v42) & *(_DWORD *)v41;
          *(_DWORD *)v41 = v40 | (*(_DWORD *)v41 >> v42);
          v41 = (__int64 *)((char *)v41 + 4);
          v40 = v62 << (32 - v42);
          --v5;
        }
        while ( v5 );
        for ( kk = 2i64; kk >= 0; --kk )
        {
          if ( kk < v43 )
            *((_DWORD *)&v67 + kk) = 0;
          else
            *((_DWORD *)&v67 + kk) = *(_DWORD *)((char *)&v67 + 4 * kk - 4i64 * v43);
        }
        v6 = 0;
        v2 = 2;
      }
    }
    else
    {
      v67 = 0i64;
      v68 = 0;
      v6 = 0;
      v2 = 2;
    }
    a2 = v66;
  }
LABEL_80:
  v57 = v67 | (v65 != 0 ? 0x80000000 : 0) | (v6 << (31 - dword_14011D3A4));
  if ( dword_14011D3A8 == 64 )
  {
    v58 = HIDWORD(v67);
    a2[1] = v57;
    *a2 = v58;
  }
  else if ( dword_14011D3A8 == 32 )
  {
    *a2 = v57;
  }
  return v2;
}
// 14011D398: using guessed type int dword_14011D398;
// 14011D39C: using guessed type int dword_14011D39C;
// 14011D3A0: using guessed type int dword_14011D3A0;
// 14011D3A4: using guessed type int dword_14011D3A4;
// 14011D3A8: using guessed type int dword_14011D3A8;
// 14011D3AC: using guessed type int dword_14011D3AC;

//----- (0000000140060290) ----------------------------------------------------
BOOL sub_140060290()
{
  BOOL result; // eax

  if ( hObject != (HANDLE)-1i64 && hObject != (HANDLE)-2i64 )
    return CloseHandle(hObject);
  return result;
}

//----- (0000000140060C30) ----------------------------------------------------
__int64 __fastcall sub_140060C30(__int64 a1)
{
  return off_14011D678(a1, 0i64);
}
// 14011D678: using guessed type __int64 (__fastcall *off_14011D678)(_QWORD, _QWORD);

//----- (0000000140060C40) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_140060C40(_QWORD *a1))(void *Block)
{
  __int64 (__fastcall **result)(void *); // rax
  __int64 v3; // rcx
  void *v4; // rcx

  result = &off_1400E9D80;
  *a1 = &off_1400E9D80;
  v3 = a1[2];
  if ( v3 )
    result = (__int64 (__fastcall **)(void *))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
  v4 = (void *)a1[3];
  if ( v4 )
    return (__int64 (__fastcall **)(void *))LocalFree(v4);
  return result;
}
// 1400E9D80: using guessed type __int64 (__fastcall *off_1400E9D80)(void *Block);

//----- (0000000140060C80) ----------------------------------------------------
void __fastcall __noreturn sub_140060C80(int a1, __int64 a2)
{
  __int64 (__fastcall **pExceptionObject)(void *); // [rsp+20h] [rbp-28h] BYREF
  int v3; // [rsp+28h] [rbp-20h]
  __int64 v4; // [rsp+30h] [rbp-18h]
  __int64 v5; // [rsp+38h] [rbp-10h]

  v3 = a1;
  v4 = a2;
  v5 = 0i64;
  pExceptionObject = &off_1400E9D80;
  CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI1_AV_com_error__);
}
// 1400E9D80: using guessed type __int64 (__fastcall *off_1400E9D80)(void *Block);

//----- (0000000140060CC0) ----------------------------------------------------
__int64 __fastcall sub_140060CC0(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  *(_QWORD *)a1 = &off_1400E9D80;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 16) = v3;
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  return a1;
}
// 1400E9D80: using guessed type __int64 (__fastcall *off_1400E9D80)(void *Block);

//----- (0000000140060D00) ----------------------------------------------------
void *__fastcall sub_140060D00(void *Block, char a2)
{
  __int64 v4; // rcx
  void *v5; // rcx

  *(_QWORD *)Block = &off_1400E9D80;
  v4 = *((_QWORD *)Block + 2);
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16i64))(v4);
  v5 = (void *)*((_QWORD *)Block + 3);
  if ( v5 )
    LocalFree(v5);
  if ( (a2 & 1) != 0 )
    j_free(Block);
  return Block;
}
// 1400E9D80: using guessed type __int64 (__fastcall *off_1400E9D80)(void *Block);

//----- (0000000140060E00) ----------------------------------------------------
int __fastcall sub_140060E00(HWND hWnd, int *a2)
{
  int WindowLongPtrW; // esi
  int result; // eax
  WPARAM v6; // r8
  int v7; // er8
  LPARAM v8; // r9
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  WindowLongPtrW = GetWindowLongPtrW(hWnd, -16);
  result = GetClientRect(hWnd, &Rect);
  if ( (*(_QWORD *)&WindowLongPtrW & 0x100000i64) != 0 )
  {
    if ( *a2 >= 20 )
    {
      result = Rect.right - 20;
      if ( *a2 <= Rect.right - 20 )
        goto LABEL_7;
      v6 = 10i64;
    }
    else
    {
      v6 = -10i64;
    }
    result = SendMessageW(hWnd, 0x1014u, v6, 0i64);
  }
LABEL_7:
  if ( (*(_QWORD *)&WindowLongPtrW & 0x200000i64) == 0 )
    return result;
  v7 = a2[1];
  if ( v7 >= 20 )
  {
    result = Rect.bottom - 20;
    if ( v7 <= Rect.bottom - 20 )
      return result;
    v8 = 10i64;
  }
  else
  {
    v8 = -10i64;
  }
  return SendMessageW(hWnd, 0x1014u, 0i64, v8);
}

//----- (0000000140060F10) ----------------------------------------------------
__int64 __fastcall sub_140060F10(__int64 a1, __int64 a2, __int64 a3)
{
  return (unsigned int)(*(_DWORD *)(568 * a1 + *(_QWORD *)(a3 + 96) + 560)
                      - *(_DWORD *)(568 * a2 + *(_QWORD *)(a3 + 96) + 560));
}

//----- (0000000140060F40) ----------------------------------------------------
__int64 __fastcall sub_140060F40(__int64 a1, __int64 *a2)
{
  __int64 v3; // rax
  unsigned int v4; // ebx
  HDROP v5; // rax
  HDROP v6; // rdi
  __int16 v8; // [rsp+20h] [rbp-478h] BYREF
  __int64 v9; // [rsp+28h] [rbp-470h]
  int v10; // [rsp+30h] [rbp-468h]
  int v11; // [rsp+34h] [rbp-464h]
  int v12; // [rsp+38h] [rbp-460h]
  char v13[8]; // [rsp+40h] [rbp-458h] BYREF
  HGLOBAL hMem; // [rsp+48h] [rbp-450h]
  WCHAR szFile[264]; // [rsp+60h] [rbp-438h] BYREF
  WCHAR pszPath1[264]; // [rsp+270h] [rbp-228h] BYREF

  v8 = 15;
  v3 = *a2;
  v4 = 0;
  v10 = 1;
  v11 = -1;
  v12 = 1;
  v9 = 0i64;
  if ( (*(unsigned int (__fastcall **)(__int64 *, __int16 *, char *))(v3 + 24))(a2, &v8, v13) )
    return 0i64;
  v5 = (HDROP)GlobalLock(hMem);
  v6 = v5;
  if ( v5 )
  {
    if ( (int)DragQueryFileW(v5, 0xFFFFFFFF, 0i64, 0) > 0 )
    {
      DragQueryFileW(v6, 0, szFile, 0x104u);
      (*(void (__fastcall **)(__int64, __int64, WCHAR *))(*(_QWORD *)(a1 + 16) + 104i64))(a1 + 16, 260i64, pszPath1);
      LOBYTE(v4) = PathIsSameRootW(pszPath1, szFile);
    }
    GlobalUnlock(hMem);
  }
  return v4;
}
// 140060F40: using guessed type char var_458[8];

//----- (0000000140061070) ----------------------------------------------------
__int64 __fastcall sub_140061070(__int64 a1)
{
  WPARAM v2; // r8
  HWND v3; // rcx
  __int64 result; // rax
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v6; // [rsp+2Ch] [rbp-4Ch]
  int v7; // [rsp+30h] [rbp-48h]

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 1352) + 32i64))(*(_QWORD *)(a1 + 1352));
  sub_140081900(*(HWND *)(a1 + 24), 0i64);
  if ( *(_DWORD *)(a1 + 1428) )
  {
    v2 = *(int *)(a1 + 1440);
    v3 = *(HWND *)(a1 + 24);
    v7 = 2;
    v6 = 0;
    SendMessageW(v3, 0x102Bu, v2, (LPARAM)&lParam);
  }
  result = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (00000001400610E0) ----------------------------------------------------
_QWORD *__fastcall sub_1400610E0(WPARAM wParam, struct tagPOINT *a2)
{
  HWND v3; // rcx
  HWND v4; // rbx
  unsigned int WindowLongW; // eax
  _QWORD *result; // rax
  _QWORD *v7; // rbx
  WPARAM v8; // rcx
  WPARAM v9; // r12
  HWND v10; // rcx
  BOOL v11; // er14
  int v12; // er13
  int v13; // esi
  int v14; // er12
  int v15; // er15
  int v16; // er12
  int v17; // er14
  HWND v18; // rcx
  int v19; // er13
  int v20; // er14
  int v21; // esi
  HWND v22; // rcx
  int v23; // eax
  HWND v24; // rcx
  HWND v25; // rcx
  HWND v26; // rcx
  int v27; // eax
  int v28; // eax
  HWND v29; // rcx
  int v30; // er12
  int v31; // eax
  HWND v32; // rcx
  WPARAM v33; // r8
  int *v34; // r9
  int v35; // eax
  int v36; // er11
  HWND v37; // rbx
  unsigned int v38; // eax
  struct tagPOINT Point; // [rsp+20h] [rbp-99h] BYREF
  int v40; // [rsp+28h] [rbp-91h]
  int v41; // [rsp+30h] [rbp-89h] BYREF
  int v42; // [rsp+34h] [rbp-85h]
  LPARAM v43; // [rsp+38h] [rbp-81h] BYREF
  int v44[2]; // [rsp+40h] [rbp-79h] BYREF
  int v45[2]; // [rsp+48h] [rbp-71h] BYREF
  LPARAM v46; // [rsp+50h] [rbp-69h] BYREF
  LPARAM lParam; // [rsp+58h] [rbp-61h] BYREF
  _DWORD v48[6]; // [rsp+60h] [rbp-59h] BYREF
  struct tagPOINT v49; // [rsp+78h] [rbp-41h]
  int v50; // [rsp+80h] [rbp-39h]
  int v51; // [rsp+88h] [rbp-31h]
  LPARAM v52; // [rsp+B0h] [rbp-9h] BYREF
  int v53; // [rsp+B8h] [rbp-1h]
  LONG v54; // [rsp+BCh] [rbp+3h]
  LPARAM v55; // [rsp+C0h] [rbp+7h] BYREF
  char v56; // [rsp+C8h] [rbp+Fh]
  int v57; // [rsp+CCh] [rbp+13h]

  v3 = *(HWND *)(wParam + 56);
  Point = *a2;
  ScreenToClient(v3, &Point);
  if ( *(_DWORD *)(wParam + 812) )
  {
    v4 = *(HWND *)(wParam + 56);
    WindowLongW = GetWindowLongW(v4, -16);
    if ( (WindowLongW & 0x100) != 0 )
      WindowLongW &= ~0x100u;
    SetWindowLongPtrW(v4, -16, WindowLongW);
  }
  result = *(_QWORD **)(wParam + 1416);
  v7 = (_QWORD *)*result;
  if ( (_QWORD *)*result != result )
  {
    v8 = wParam + 16;
    while ( 1 )
    {
      result = (_QWORD *)(*(__int64 (__fastcall **)(WPARAM, _QWORD *))(*(_QWORD *)v8 + 360i64))(v8, v7 + 2);
      v9 = (int)result;
      v40 = (int)result;
      if ( (_DWORD)result != -1 )
        break;
LABEL_55:
      v7 = (_QWORD *)*v7;
      v8 = wParam + 16;
      if ( v7 == *(_QWORD **)(wParam + 1416) )
        goto LABEL_56;
    }
    v10 = *(HWND *)(wParam + 56);
    if ( *(_DWORD *)(wParam + 708) == 4 )
    {
      v11 = 1;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = SendMessageW(v10, 0x1004u, 0i64, 0i64);
      if ( v15 > 0 )
      {
        while ( 1 )
        {
          SendMessageW(*(HWND *)(wParam + 56), 0x1010u, v14, (LPARAM)&lParam);
          if ( v11 )
          {
            if ( Point.y - HIDWORD(lParam) < 0 )
              break;
          }
          if ( v14 == v15 - 1 )
            v12 = v15;
          v11 = Point.y - HIDWORD(lParam) > 0;
          if ( ++v14 >= v15 )
            goto LABEL_17;
        }
        v12 = v14 - 1;
      }
LABEL_17:
      v16 = 0;
      if ( v15 > 0 )
      {
        v17 = v40;
        do
        {
          v18 = *(HWND *)(wParam + 56);
          v48[0] = 4;
          v48[1] = v16;
          v48[2] = 0;
          if ( (unsigned int)SendMessageW(v18, 0x104Bu, 0i64, (LPARAM)v48) )
          {
            if ( v16 == v17 )
            {
              *(_DWORD *)(568i64 * v51 + *(_QWORD *)(wParam + 96) + 560) = v12;
            }
            else
            {
              if ( v13 == v12 )
                ++v13;
              *(_DWORD *)(568i64 * v51 + *(_QWORD *)(wParam + 96) + 560) = v13;
            }
          }
          ++v16;
          ++v13;
        }
        while ( v16 < v15 );
      }
      result = (_QWORD *)SendMessageW(*(HWND *)(wParam + 56), 0x1030u, wParam, (LPARAM)sub_140060F10);
      goto LABEL_55;
    }
    if ( !*(_DWORD *)(wParam + 812) )
    {
      SendMessageW(v10, 0x1029u, 0i64, (LPARAM)&v43);
      v32 = *(HWND *)(wParam + 56);
      v36 = Point.x + v43 - *(_DWORD *)(wParam + 1444);
      v33 = v9;
      v34 = (int *)&v46;
      HIDWORD(v46) = Point.y + HIDWORD(v43) - *(_DWORD *)(wParam + 1448);
      LODWORD(v46) = v36;
LABEL_54:
      result = (_QWORD *)SendMessageW(v32, 0x1031u, v33, (LPARAM)v34);
      goto LABEL_55;
    }
    v19 = 0;
    v20 = 0;
    v55 = (LPARAM)Point;
    v21 = SendMessageW(v10, 0x1012u, 0i64, (LPARAM)&v55);
    if ( v21 != -1 && (v56 & 0xE) != 0 )
    {
      v22 = *(HWND *)(wParam + 56);
      LODWORD(v52) = 0;
      SendMessageW(v22, 0x100Eu, v57, (LPARAM)&v52);
      if ( Point.x - (int)v52 <= (v53 - (int)v52) / 2 )
      {
        v23 = SendMessageW(*(HWND *)(wParam + 56), 0x100Cu, v21, 1024i64);
        if ( v23 == -1 )
          v23 = v21;
        v21 = v23;
        LOBYTE(v20) = (unsigned int)SendMessageW(*(HWND *)(wParam + 56), 0x100Cu, v23, 1024i64) == -1;
      }
      goto LABEL_46;
    }
    v24 = *(HWND *)(wParam + 56);
    v49 = Point;
    v48[0] = 64;
    v50 = 38;
    v21 = SendMessageW(v24, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v48);
    if ( v21 == -1 )
    {
      v25 = *(HWND *)(wParam + 56);
      v49 = Point;
      v48[0] = 64;
      v50 = 37;
      v21 = SendMessageW(v25, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v48);
    }
    v26 = *(HWND *)(wParam + 56);
    LODWORD(v52) = 0;
    SendMessageW(v26, 0x100Eu, v21, (LPARAM)&v52);
    if ( Point.x > (int)v52 + (v53 - (int)v52) / 2 )
    {
      if ( Point.y > v54 )
      {
        v27 = SendMessageW(*(HWND *)(wParam + 56), 0x100Cu, v21, 512i64);
        if ( v27 != -1 )
          v21 = v27;
      }
      v19 = 1;
    }
    v28 = SendMessageW(*(HWND *)(wParam + 56), 0x1004u, 0i64, 0i64);
    v29 = *(HWND *)(wParam + 56);
    v30 = v28 - 1;
    LODWORD(v52) = 0;
    SendMessageW(v29, 0x100Eu, v28 - 1, (LPARAM)&v52);
    v31 = (v53 - (int)v52) / 2;
    if ( Point.x <= v31 + (int)v52 || Point.x >= v31 + v53 + 2 || Point.y <= SHIDWORD(v52) )
    {
      if ( !v19 )
      {
        v35 = SendMessageW(*(HWND *)(wParam + 56), 0x100Cu, v21, 1024i64);
        LODWORD(v9) = v40;
        if ( v35 == -1 )
          v20 = 1;
        else
          v21 = v35;
        goto LABEL_46;
      }
    }
    else
    {
      v21 = v30;
    }
    LODWORD(v9) = v40;
LABEL_46:
    SendMessageW(*(HWND *)(wParam + 56), 0x1010u, v21, (LPARAM)&v41);
    v32 = *(HWND *)(wParam + 56);
    v33 = (int)v9;
    if ( v20 )
    {
      v44[0] = 0;
      v34 = v44;
      v44[1] = v42;
    }
    else
    {
      v34 = v45;
      v45[0] = v41 + 1;
      v45[1] = v42;
    }
    goto LABEL_54;
  }
LABEL_56:
  if ( *(_DWORD *)(wParam + 812) )
  {
    v37 = *(HWND *)(wParam + 56);
    v38 = GetWindowLongW(v37, -16);
    if ( (v38 & 0x100) == 0 )
      v38 |= 0x100u;
    result = (_QWORD *)SetWindowLongPtrW(v37, -16, v38);
  }
  *(_DWORD *)(wParam + 72) = 0;
  *(_DWORD *)(wParam + 1456) = 0;
  return result;
}

//----- (0000000140061630) ----------------------------------------------------
LRESULT __fastcall sub_140061630(__int64 a1, __int64 *a2)
{
  HWND v3; // rcx
  int v4; // er12
  int v5; // esi
  int v6; // ebp
  int v7; // ebx
  LRESULT result; // rax
  int v9; // edx
  HWND v10; // rcx
  WPARAM v11; // r8
  HWND v12; // rcx
  _QWORD **v13; // rax
  _QWORD *v14; // rbx
  char v15; // al
  WPARAM v16; // r8
  HWND v17; // rcx
  LPARAM v18; // [rsp+20h] [rbp-E8h] BYREF
  int v19; // [rsp+2Ch] [rbp-DCh]
  int v20; // [rsp+30h] [rbp-D8h]
  _DWORD lParam[10]; // [rsp+70h] [rbp-98h] BYREF
  int v22; // [rsp+98h] [rbp-70h]
  __int64 v23; // [rsp+C0h] [rbp-48h] BYREF
  char v24; // [rsp+C8h] [rbp-40h]
  int v25; // [rsp+CCh] [rbp-3Ch]

  v3 = *(HWND *)(a1 + 56);
  v4 = 0;
  v23 = *a2;
  v5 = -1;
  v6 = 0;
  v7 = 0;
  result = SendMessageW(v3, 0x1012u, 0i64, (LPARAM)&v23);
  if ( (v24 & 1) == 0 )
  {
    v9 = v25;
    if ( v25 == -1 )
      goto LABEL_8;
    v10 = *(HWND *)(a1 + 56);
    lParam[1] = v25;
    lParam[0] = 4;
    lParam[2] = 0;
    result = SendMessageW(v10, 0x104Bu, 0i64, (LPARAM)lParam);
    v5 = v22;
    if ( v22 != -1 )
    {
      v7 = 1;
      if ( *(_DWORD *)(a1 + 1468) )
      {
        v9 = v25;
        if ( v25 == *(_DWORD *)(a1 + 1472) )
          return result;
        goto LABEL_8;
      }
    }
  }
  v9 = v25;
LABEL_8:
  if ( *(_DWORD *)(a1 + 1468) && *(_DWORD *)(a1 + 1460) )
  {
    v11 = *(int *)(a1 + 1472);
    v12 = *(HWND *)(a1 + 56);
    v20 = 2;
    v19 = 0;
    result = SendMessageW(v12, 0x102Bu, v11, (LPARAM)&v18);
    v9 = v25;
  }
  *(_DWORD *)(a1 + 1468) = 0;
  if ( v7 )
  {
    result = *(_QWORD *)(a1 + 88);
    if ( (*(_BYTE *)(592i64 * v5 + result) & 0x10) != 0 )
    {
      if ( !*(_DWORD *)(a1 + 1456) )
        goto LABEL_19;
      v13 = *(_QWORD ***)(a1 + 1416);
      v14 = *v13;
      if ( *v13 == v13 )
        goto LABEL_19;
      do
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)(a1 + 16) + 360i64))(a1 + 16, v14 + 2);
        v9 = v25;
        v14 = (_QWORD *)*v14;
        if ( v25 == (_DWORD)result )
          v6 = 1;
      }
      while ( v14 != *(_QWORD **)(a1 + 1416) );
      if ( !v6 )
      {
LABEL_19:
        v15 = SendMessageW(*(HWND *)(a1 + 56), 0x102Cu, v9, 2i64);
        v16 = v25;
        v17 = *(HWND *)(a1 + 56);
        v20 = 2;
        v19 = 2;
        LOBYTE(v4) = (v15 & 2) != 2;
        *(_DWORD *)(a1 + 1460) = v4;
        result = SendMessageW(v17, 0x102Bu, v16, (LPARAM)&v18);
        *(_DWORD *)(a1 + 1472) = v25;
        *(_DWORD *)(a1 + 1468) = 1;
      }
    }
  }
  return result;
}

//----- (0000000140061850) ----------------------------------------------------
__int64 __fastcall sub_140061850(__int64 a1, char a2, struct tagPOINT a3, unsigned int *a4)
{
  unsigned int v4; // eax
  unsigned int v6; // edx
  __int64 v7; // rcx
  struct tagPOINT *p_Point; // rdx
  struct tagPOINT Point; // [rsp+20h] [rbp-28h] BYREF
  struct tagRECT Rect; // [rsp+28h] [rbp-20h] BYREF

  v4 = *a4;
  if ( *(_DWORD *)(a1 + 1420) )
  {
    if ( ((a2 & 8) != 0 && (a2 & 4) != 0 || (a2 & 0x20) != 0) && (v4 & 4) != 0 )
    {
      v6 = 4;
    }
    else if ( (a2 & 4) != 0 && (v4 & 2) != 0 )
    {
      v6 = 2;
    }
    else if ( (a2 & 8) == 8 && (v4 & 1) != 0 )
    {
      v6 = 1;
    }
    else if ( *(_DWORD *)(a1 + 1432) && (v4 & 2) != 0 )
    {
      v6 = 2;
    }
    else if ( (v4 & 1) != 0 )
    {
      v6 = 1;
    }
    else if ( (v4 & 2) != 0 )
    {
      v6 = 2;
    }
    else
    {
      v6 = *a4 & 4;
    }
  }
  else
  {
    v6 = 0;
  }
  *a4 = v6;
  v7 = *(_QWORD *)(a1 + 1352);
  Point = a3;
  (*(void (__fastcall **)(__int64, struct tagPOINT *, _QWORD))(*(_QWORD *)v7 + 40i64))(v7, &Point, v6);
  ScreenToClient(*(HWND *)(a1 + 24), &Point);
  GetClientRect(*(HWND *)(a1 + 24), &Rect);
  sub_140060E00(*(HWND *)(a1 + 24), (int *)&Point);
  sub_140061630(a1 - 32, (__int64 *)&Point);
  if ( *(_DWORD *)(a1 + 1420) )
  {
    if ( *(_DWORD *)(a1 + 1436) )
      p_Point = 0i64;
    else
      p_Point = &Point;
    sub_140081900(*(HWND *)(a1 + 24), (__int64)p_Point);
  }
  return 0i64;
}

//----- (0000000140061990) ----------------------------------------------------
__int64 __fastcall sub_140061990(__int64 a1, __int64 *a2, char a3, __int64 a4, int *a5)
{
  int *v8; // rbp
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  _QWORD *v11; // rbx
  int v12; // er11
  int v13; // ecx
  int v14; // eax
  _QWORD *v15; // rcx
  _QWORD *v16; // rbx
  char *v18[2]; // [rsp+30h] [rbp-88h] BYREF
  void *Block[3]; // [rsp+40h] [rbp-78h] BYREF
  __int64 pExceptionObject[3]; // [rsp+58h] [rbp-60h] BYREF
  __int64 v21[4]; // [rsp+70h] [rbp-48h] BYREF
  int v22; // [rsp+C0h] [rbp+8h] BYREF
  int v23; // [rsp+C4h] [rbp+Ch]
  __int64 v24; // [rsp+D8h] [rbp+20h]

  v24 = a4;
  v18[1] = (char *)-2i64;
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 1428) = 0;
  *(_DWORD *)(a1 + 1440) = -1;
  if ( !*(_DWORD *)(a1 + 680) || *(_DWORD *)(a1 + 1424) )
  {
    Block[1] = 0i64;
    v9 = operator new(0x30ui64);
    if ( !v9 )
    {
      v18[0] = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v18);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    Block[0] = v9;
    *v9 = v9;
    v9[1] = v9;
    sub_1400762E0((__int64 *)Block);
    v10 = Block[0];
    v11 = *(_QWORD **)Block[0];
    if ( *(void **)Block[0] == Block[0] )
    {
LABEL_31:
      *(_DWORD *)(a1 + 1420) = 0;
      v8 = a5;
      *a5 = 0;
    }
    else
    {
      while ( 1 )
      {
        v21[0] = v11[2];
        v21[1] = v11[3];
        v21[2] = v11[4];
        v21[3] = v11[5];
        if ( !(*(unsigned int (__fastcall **)(__int64 *, __int64 *))(*a2 + 40))(a2, v21) )
          break;
        v11 = (_QWORD *)*v11;
        if ( v11 == v10 )
          goto LABEL_31;
      }
      *(_DWORD *)(a1 + 1420) = 1;
      v12 = sub_140060F40(a1 - 32, a2);
      *(_DWORD *)(a1 + 1432) = v12;
      v8 = a5;
      v13 = *a5;
      if ( *(_DWORD *)(a1 + 1420) )
      {
        if ( ((a3 & 8) != 0 && (a3 & 4) != 0 || (a3 & 0x20) != 0) && (v13 & 4) != 0 )
        {
          v14 = 4;
        }
        else if ( (a3 & 4) != 0 && (v13 & 2) != 0 )
        {
          v14 = 2;
        }
        else if ( (a3 & 8) == 8 && (v13 & 1) != 0 )
        {
          v14 = 1;
        }
        else if ( v12 && (v13 & 2) != 0 )
        {
          v14 = 2;
        }
        else if ( (v13 & 1) != 0 )
        {
          v14 = 1;
        }
        else if ( (v13 & 2) != 0 )
        {
          v14 = 2;
        }
        else
        {
          v14 = *a5 & 4;
        }
      }
      else
      {
        v14 = 0;
      }
      *a5 = v14;
    }
    v15 = (_QWORD *)*v10;
    *v10 = v10;
    v10[1] = v10;
    if ( v15 != v10 )
    {
      do
      {
        v16 = (_QWORD *)*v15;
        j_free(v15);
        v15 = v16;
      }
      while ( v16 != v10 );
    }
    j_free(v10);
    LODWORD(a4) = v24;
  }
  else
  {
    *(_DWORD *)(a1 + 1420) = 0;
    v8 = a5;
    *a5 = 0;
  }
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)(a1 + 1408) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *(_DWORD *)(a1 + 1408) = 1;
  }
  v22 = a4;
  v23 = HIDWORD(v24);
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, int *, int))(**(_QWORD **)(a1 + 1352) + 24i64))(
    *(_QWORD *)(a1 + 1352),
    *(_QWORD *)(a1 + 24),
    a2,
    &v22,
    *v8);
  return 0i64;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140061C50) ----------------------------------------------------
void __fastcall sub_140061C50(__int64 a1, _QWORD **a2, struct tagPOINT *a3)
{
  _QWORD *v6; // rbp
  _QWORD *i; // rbx
  void **v8; // r8
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  signed __int64 v11; // r8
  WCHAR v12; // ax
  __int64 v13; // rdi
  char *v14; // rax
  __int64 v15; // rdx
  struct tagPOINT Point; // [rsp+20h] [rbp-288h] BYREF
  LPARAM lParam; // [rsp+28h] [rbp-280h] BYREF
  __int64 v18; // [rsp+30h] [rbp-278h]
  void *Block[3]; // [rsp+38h] [rbp-270h] BYREF
  unsigned __int64 v20; // [rsp+50h] [rbp-258h]
  WCHAR pszPath[260]; // [rsp+60h] [rbp-248h] BYREF
  int v22; // [rsp+268h] [rbp-40h]
  int v23; // [rsp+26Ch] [rbp-3Ch]

  v18 = -2i64;
  if ( !*(_DWORD *)(a1 + 1428) )
  {
    SendMessageW(*(HWND *)(a1 + 16), 0x1029u, 0i64, (LPARAM)&lParam);
    Point = *a3;
    ScreenToClient(*(HWND *)(a1 + 16), &Point);
    v22 = lParam + Point.x;
    v23 = Point.y + HIDWORD(lParam);
    v6 = *a2;
    for ( i = (_QWORD *)**a2; i != v6; i = (_QWORD *)*i )
    {
      v20 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      sub_140009610(Block, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v8 = Block;
      if ( v20 >= 8 )
        v8 = (void **)Block[0];
      v9 = 260i64;
      v10 = pszPath;
      v11 = (char *)v8 - (char *)pszPath;
      while ( v9 != -2147483386 )
      {
        v12 = *(WCHAR *)((char *)v10 + v11);
        if ( !v12 )
          break;
        *v10++ = v12;
        if ( !--v9 )
        {
          --v10;
          break;
        }
      }
      *v10 = 0;
      PathStripPathW(pszPath);
      v13 = *(_QWORD *)(a1 + 1352);
      v14 = sub_14002B540(v13, *(_QWORD *)(v13 + 8), pszPath);
      v15 = *(_QWORD *)(a1 + 1360);
      if ( v15 == 0x7C1F07C1F07C1Ei64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 1360) = v15 + 1;
      *(_QWORD *)(v13 + 8) = v14;
      **((_QWORD **)v14 + 1) = v14;
      if ( v20 >= 8 )
        j_free(Block[0]);
    }
  }
}
// 140061D77: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140061E30) ----------------------------------------------------
__int64 __fastcall sub_140061E30(__int64 a1, __int64 a2, int a3, __int64 a4, _DWORD *a5)
{
  __int64 v7; // rcx
  __int64 v8; // r9
  WPARAM v11; // r8
  HWND v12; // rcx
  __int64 v13; // rax
  HWND v14; // rcx
  HDROP v15; // rax
  _DWORD *v16; // rax
  __int64 v17; // rsi
  __int64 v18; // r8
  int v19; // edx
  __int64 v20; // rcx
  struct tagPOINT v22; // [rsp+20h] [rbp-E0h] BYREF
  struct tagPOINT v23; // [rsp+28h] [rbp-D8h] BYREF
  __int16 v24; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v25; // [rsp+38h] [rbp-C8h]
  int v26; // [rsp+40h] [rbp-C0h]
  int v27; // [rsp+44h] [rbp-BCh]
  int v28; // [rsp+48h] [rbp-B8h]
  char v29[8]; // [rsp+50h] [rbp-B0h] BYREF
  HGLOBAL hMem; // [rsp+58h] [rbp-A8h]
  _DWORD v31[20]; // [rsp+70h] [rbp-90h] BYREF
  LPARAM lParam; // [rsp+C0h] [rbp-40h] BYREF
  int v33; // [rsp+CCh] [rbp-34h]
  int v34; // [rsp+D0h] [rbp-30h]
  WCHAR pszPath[264]; // [rsp+110h] [rbp+10h] BYREF

  v7 = *(_QWORD *)(a1 + 1352);
  v8 = (unsigned int)*a5;
  v24 = 15;
  v26 = 1;
  v28 = 1;
  v25 = 0i64;
  v27 = -1;
  (*(void (__fastcall **)(__int64, __int64, struct tagPOINT *, __int64, __int64))(*(_QWORD *)v7 + 48i64))(
    v7,
    a2,
    &v23,
    v8,
    a4);
  if ( *(_DWORD *)(a1 + 1428) )
  {
    v11 = *(int *)(a1 + 1440);
    v12 = *(HWND *)(a1 + 24);
    v34 = 2;
    v33 = 0;
    SendMessageW(v12, 0x102Bu, v11, (LPARAM)&lParam);
  }
  v23.y = v22.y;
  v13 = *(_QWORD *)(a1 - 16);
  *(_DWORD *)(a1 + 40) = 0;
  v23.x = a4;
  (*(void (__fastcall **)(__int64, __int64, WCHAR *))(v13 + 104))(a1 - 16, 261i64, pszPath);
  if ( *(_DWORD *)(a1 + 1436) )
  {
    v14 = *(HWND *)(a1 + 24);
    v31[1] = *(_DWORD *)(a1 + 1440);
    v31[0] = 4;
    v31[2] = 0;
    SendMessageW(v14, 0x104Bu, 0i64, (LPARAM)v31);
    PathAppendW(pszPath, (LPCWSTR)(592i64 * v31[10] + *(_QWORD *)(a1 + 56) + 44));
  }
  pszPath[lstrlenW(pszPath) + 1] = 0;
  if ( *(_DWORD *)(a1 + 1420) )
  {
    if ( !*(_DWORD *)(a1 + 1408)
      && *(_DWORD *)(a1 + 1424)
      && !*(_DWORD *)(a1 + 1436)
      && !(*(unsigned int (__fastcall **)(__int64, __int16 *, char *))(*(_QWORD *)a2 + 24i64))(a2, &v24, v29)
      && (v15 = (HDROP)GlobalLock(hMem)) != 0i64
      && (DragQueryFileW(v15, 0xFFFFFFFF, 0i64, 0), *(_DWORD *)(a1 + 1420))
      && (unsigned int)sub_14007DD80(a3, *a5, *(_DWORD *)(a1 + 1432)) == 2 )
    {
      v22 = v23;
      sub_1400610E0(a1 - 32, &v22);
    }
    else
    {
      v16 = operator new(0x50ui64);
      v17 = (__int64)v16;
      if ( v16 )
      {
        v16[2] = 1;
        *(_QWORD *)v16 = &CDropHandler::`vftable';
      }
      else
      {
        v17 = 0i64;
      }
      if ( a1 == 32 )
        v18 = 0i64;
      else
        v18 = a1 + 8;
      v19 = *(_DWORD *)(a1 + 1408);
      v20 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(v17 + 16) = a2;
      *(_DWORD *)(v17 + 32) = a3;
      *(_QWORD *)(v17 + 36) = a4;
      *(_DWORD *)(v17 + 44) = *a5;
      *(_QWORD *)(v17 + 48) = v20;
      *(_DWORD *)(v17 + 56) = v19;
      *(_QWORD *)(v17 + 24) = v18;
      *(_DWORD *)(v17 + 72) = 0;
      *(_QWORD *)(v17 + 64) = pszPath;
      if ( v19 )
      {
        if ( v19 == 1 )
          sub_1400761A0(v17);
      }
      else
      {
        sub_1400783F0(v17, a2, (int *)(v17 + 36));
      }
      if ( !*(_DWORD *)(a1 + 1436) )
        sub_140081CC0(*(HWND *)(a1 + 24));
      if ( !_InterlockedDecrement((volatile signed __int32 *)(v17 + 8)) )
        (**(void (__fastcall ***)(__int64, __int64))v17)(v17, 1i64);
    }
  }
  sub_140081900(*(HWND *)(a1 + 24), 0i64);
  return 0i64;
}
// 1400F7C20: using guessed type void *CDropHandler::`vftable';
// 140061E30: using guessed type char var_310[8];

//----- (0000000140062110) ----------------------------------------------------
LRESULT __fastcall sub_140062110(__int64 a1, int a2, int a3)
{
  HWND v3; // rcx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v3 = *(HWND *)(a1 + 56);
  lParam[1] = a2;
  lParam[13] = a3;
  lParam[0] = 256;
  lParam[2] = 0;
  return SendMessageW(v3, 0x104Cu, 0i64, (LPARAM)lParam);
}

//----- (0000000140062150) ----------------------------------------------------
void __fastcall sub_140062150(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 800) = a2;
}

//----- (0000000140062190) ----------------------------------------------------
__int64 __fastcall sub_140062190(int a1, int a2)
{
  unsigned int v2; // ebx
  __int64 *v3; // r9
  __int64 *v4; // rax
  __int64 *v5; // r8
  const WCHAR *v6; // rsi
  const WCHAR *v7; // rdi

  v2 = 0;
  v3 = *(__int64 **)qword_14012DF30;
  v4 = **(__int64 ***)qword_14012DF30;
  v5 = v4;
  if ( v4 == *(__int64 **)qword_14012DF30 )
  {
LABEL_4:
    v6 = 0i64;
  }
  else
  {
    while ( *((_DWORD *)v5 + 260) != a1 )
    {
      v5 = (__int64 *)*v5;
      if ( v5 == v3 )
        goto LABEL_4;
    }
    v6 = (const WCHAR *)(v5 + 2);
  }
  if ( v4 == v3 )
  {
LABEL_8:
    v7 = 0i64;
  }
  else
  {
    while ( *((_DWORD *)v4 + 260) != a2 )
    {
      v4 = (__int64 *)*v4;
      if ( v4 == v3 )
        goto LABEL_8;
    }
    v7 = (const WCHAR *)(v4 + 2);
  }
  if ( lstrcmpiW(v6, L"Unspecified") || !lstrcmpiW(v7, L"Unspecified") )
  {
    if ( !lstrcmpiW(v6, L"Unspecified") || lstrcmpiW(v7, L"Unspecified") )
    {
      if ( lstrcmpiW(v6, L"Unspecified") || lstrcmpiW(v7, L"Unspecified") )
        v2 = StrCmpLogicalW(v6, v7);
    }
    else
    {
      v2 = -1;
    }
  }
  else
  {
    v2 = 1;
  }
  if ( !dword_14012DB30 )
    return -v2;
  return v2;
}
// 14012DB30: using guessed type int dword_14012DB30;
// 14012DF30: using guessed type __int64 qword_14012DF30;

//----- (00000001400622B0) ----------------------------------------------------
__int64 __fastcall sub_1400622B0(int a1, int a2)
{
  unsigned int v2; // ebx
  __int64 *v3; // r9
  __int64 *v4; // rax
  __int64 *v5; // r8
  const WCHAR *v6; // rsi
  const WCHAR *v7; // rdi

  v2 = 0;
  v3 = *(__int64 **)qword_14012DF30;
  v4 = **(__int64 ***)qword_14012DF30;
  v5 = v4;
  if ( v4 == *(__int64 **)qword_14012DF30 )
  {
LABEL_4:
    v6 = 0i64;
  }
  else
  {
    while ( *((_DWORD *)v5 + 260) != a1 )
    {
      v5 = (__int64 *)*v5;
      if ( v5 == v3 )
        goto LABEL_4;
    }
    v6 = (const WCHAR *)(v5 + 2);
  }
  if ( v4 == v3 )
  {
LABEL_8:
    v7 = 0i64;
  }
  else
  {
    while ( *((_DWORD *)v4 + 260) != a2 )
    {
      v4 = (__int64 *)*v4;
      if ( v4 == v3 )
        goto LABEL_8;
    }
    v7 = (const WCHAR *)(v4 + 2);
  }
  if ( lstrcmpiW(v6, L"Other") || !lstrcmpiW(v7, L"Other") )
  {
    if ( !lstrcmpiW(v6, L"Other") || lstrcmpiW(v7, L"Other") )
    {
      if ( lstrcmpiW(v6, L"Other") || lstrcmpiW(v7, L"Other") )
        v2 = StrCmpLogicalW(v6, v7);
    }
    else
    {
      v2 = -1;
    }
  }
  else
  {
    v2 = 1;
  }
  if ( !dword_14012DB30 )
    return -v2;
  return v2;
}
// 14012DB30: using guessed type int dword_14012DB30;
// 14012DF30: using guessed type __int64 qword_14012DF30;

//----- (00000001400623D0) ----------------------------------------------------
__int64 __fastcall sub_1400623D0(__int64 a1, char *a2)
{
  IP_ADAPTER_ADDRESSES_LH *v4; // rax
  __int64 v5; // r11
  signed __int64 v6; // rcx
  __int64 result; // rax
  ULONG SizePointer[4]; // [rsp+30h] [rbp-68h] BYREF
  WCHAR Buffer; // [rsp+40h] [rbp-58h] BYREF
  __int64 v10; // [rsp+42h] [rbp-56h]
  __int64 v11; // [rsp+4Ah] [rbp-4Eh]
  __int64 v12; // [rsp+52h] [rbp-46h]
  __int64 v13; // [rsp+5Ah] [rbp-3Eh]
  __int64 v14; // [rsp+62h] [rbp-36h]
  __int64 v15; // [rsp+6Ah] [rbp-2Eh]
  __int64 v16; // [rsp+72h] [rbp-26h]
  int v17; // [rsp+7Ah] [rbp-1Eh]
  __int16 v18; // [rsp+7Eh] [rbp-1Ah]

  Buffer = 0;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  v18 = 0;
  SizePointer[0] = 0;
  GetAdaptersAddresses(0, 0, 0i64, 0i64, SizePointer);
  v4 = (IP_ADAPTER_ADDRESSES_LH *)malloc(SizePointer[0]);
  GetAdaptersAddresses(0, 0, 0i64, v4, SizePointer);
  LoadStringW(*(HINSTANCE *)(a1 + 144), 0, &Buffer, 32);
  v5 = 512i64;
  v6 = (char *)&Buffer - a2;
  while ( 1 )
  {
    result = v5 + 2147483134;
    if ( v5 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a2[v6];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a2 = result;
    a2 += 2;
    if ( !--v5 )
    {
      *((_WORD *)a2 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a2 = 0;
  return result;
}
// 1400624BA: conditional instruction was optimized away because r11.8!=0

//----- (00000001400624F0) ----------------------------------------------------
void __fastcall sub_1400624F0(__int64 a1, int a2, char *a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  const ITEMIDLIST *v5; // rcx
  ITEMIDLIST *v7; // rsi
  __int64 v8; // rbx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  WCHAR v11; // ax
  __int64 v12; // rcx
  signed __int64 v13; // rdx
  __int16 v14; // ax
  void *v15; // rcx
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp-568h] BYREF
  void *ppv; // [rsp+48h] [rbp-560h] BYREF
  STRRET pstr; // [rsp+50h] [rbp-558h] BYREF
  WCHAR FileSystemNameBuffer[264]; // [rsp+160h] [rbp-448h] BYREF
  WCHAR pszBuf[264]; // [rsp+370h] [rbp-238h] BYREF

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(const ITEMIDLIST **)(a1 + 136);
  ppv = 0i64;
  ppidlLast = 0i64;
  v7 = ILCombine(v5, *(LPCITEMIDLIST *)(568 * v3 + v4));
  SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  v8 = 260i64;
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  if ( PathIsRootW(pszBuf) )
  {
    if ( GetVolumeInformationW(pszBuf, 0i64, 0, 0i64, 0i64, 0i64, FileSystemNameBuffer, 0x104u)
      && FileSystemNameBuffer[0] )
    {
      goto LABEL_17;
    }
    v9 = FileSystemNameBuffer;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v9 + (char *)L"Unspecified" - (char *)FileSystemNameBuffer);
      if ( !v10 )
        break;
      *v9++ = v10;
      if ( !--v8 )
        goto LABEL_15;
    }
  }
  else
  {
    v9 = FileSystemNameBuffer;
    while ( v8 != -2147483386 )
    {
      v11 = *(WCHAR *)((char *)v9 + (char *)L"Unspecified" - (char *)FileSystemNameBuffer);
      if ( !v11 )
        break;
      *v9++ = v11;
      if ( !--v8 )
      {
LABEL_15:
        --v9;
        break;
      }
    }
  }
  *v9 = 0;
LABEL_17:
  v12 = 512i64;
  v13 = (char *)FileSystemNameBuffer - a3;
  while ( v12 != -2147483134 )
  {
    v14 = *(_WORD *)&a3[v13];
    if ( !v14 )
      break;
    *(_WORD *)a3 = v14;
    a3 += 2;
    if ( !--v12 )
    {
      a3 -= 2;
      break;
    }
  }
  v15 = ppv;
  *(_WORD *)a3 = 0;
  (*(void (__fastcall **)(void *, signed __int64))(*(_QWORD *)v15 + 16i64))(v15, v13);
  CoTaskMemFree(v7);
}
// 140062676: conditional instruction was optimized away because rbx.8!=0
// 1400626B6: conditional instruction was optimized away because rcx.8!=0
// 1400EA1A8: using guessed type wchar_t aUnspecified_5[12];
// 1400EA1C0: using guessed type wchar_t aUnspecified_6[12];

//----- (0000000140062700) ----------------------------------------------------
__int64 __fastcall sub_140062700(__int64 a1, int a2, char *a3)
{
  __int64 v4; // r9
  WCHAR *v5; // r8
  WCHAR v6; // ax
  __int64 v7; // rax
  LPWSTR ExtensionW; // rax
  __int64 v9; // rdx
  signed __int64 v10; // rcx
  __int64 result; // rax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-228h] BYREF

  v4 = 260i64;
  v5 = pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + a1 + 160 - (_QWORD)pszPath);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = *(_QWORD *)(a1 + 88);
  *v5 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v7 + 44));
  ExtensionW = PathFindExtensionW(pszPath);
  v9 = 512i64;
  if ( *ExtensionW )
    return sub_140001240(a3, 0x200ui64, (__int64)ExtensionW);
  v10 = (char *)L"None" - a3;
  while ( 1 )
  {
    result = v9 + 2147483134;
    if ( v9 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a3[v10];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a3 = result;
    a3 += 2;
    if ( !--v9 )
    {
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a3 = 0;
  return result;
}
// 140062768: conditional instruction was optimized away because r9.8!=0
// 1400627DE: conditional instruction was optimized away because rdx.8!=0
// 1400EA198: using guessed type wchar_t aNone[5];

//----- (0000000140062820) ----------------------------------------------------
__int64 __fastcall sub_140062820(__int64 a1, int a2, int a3, _WORD *a4)
{
  __int64 v7; // rsi
  int v8; // ebx
  const FILETIME *v9; // rcx
  int v10; // edx
  struct _FILETIME LocalFileTime; // [rsp+20h] [rbp-69h] BYREF
  __int64 v13[12]; // [rsp+30h] [rbp-59h]
  struct _SYSTEMTIME v14; // [rsp+90h] [rbp+7h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+A0h] [rbp+17h] BYREF

  v13[0] = (__int64)L"Today";
  v13[1] = (__int64)L"Yesterday";
  v13[2] = (__int64)L"This Week";
  v7 = a2;
  v13[3] = (__int64)L"Last Week";
  v13[4] = (__int64)L"This Month";
  v13[5] = (__int64)L"Last Month";
  v13[6] = (__int64)L"This Year";
  v13[7] = (__int64)L"Last Year";
  v13[8] = (__int64)L"Two Years Ago";
  v13[9] = (__int64)L"Long ago";
  v13[10] = (__int64)L"Unspecified";
  GetLocalTime(&SystemTime);
  if ( a3 )
  {
    v8 = a3 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
        goto LABEL_8;
      v9 = (const FILETIME *)(592 * v7 + *(_QWORD *)(a1 + 88) + 12);
    }
    else
    {
      v9 = (const FILETIME *)(592 * v7 + *(_QWORD *)(a1 + 88) + 20);
    }
  }
  else
  {
    v9 = (const FILETIME *)(592 * v7 + *(_QWORD *)(a1 + 88) + 4);
  }
  FileTimeToLocalFileTime(v9, &LocalFileTime);
LABEL_8:
  FileTimeToSystemTime(&LocalFileTime, &v14);
  if ( v14.wYear == SystemTime.wYear )
  {
    if ( v14.wMonth == SystemTime.wMonth )
    {
      if ( v14.wDay == SystemTime.wDay )
      {
        v10 = 0;
      }
      else if ( v14.wDay == SystemTime.wDay - 1 )
      {
        v10 = 1;
      }
      else
      {
        v10 = (v14.wDay < SystemTime.wDay - 7) + 3;
      }
    }
    else
    {
      v10 = (v14.wMonth != SystemTime.wMonth - 1) + 5;
    }
  }
  else if ( v14.wYear == SystemTime.wYear - 1 )
  {
    v10 = 6;
  }
  else
  {
    v10 = (v14.wYear != SystemTime.wYear - 2) + 7;
  }
  return sub_140001240(a4, 0x200ui64, v13[v10]);
}
// 1400EA018: using guessed type wchar_t aToday[6];
// 1400EA028: using guessed type wchar_t aYesterday[10];
// 1400EA040: using guessed type wchar_t aThisWeek[10];
// 1400EA058: using guessed type wchar_t aLastWeek[10];
// 1400EA070: using guessed type wchar_t aThisMonth[11];
// 1400EA088: using guessed type wchar_t aLastMonth[11];
// 1400EA0A0: using guessed type wchar_t aThisYear[10];
// 1400EA0B8: using guessed type wchar_t aLastYear[10];
// 1400EA0D0: using guessed type wchar_t aTwoYearsAgo[14];
// 1400EA0F0: using guessed type wchar_t aLongAgo[9];
// 1400EA108: using guessed type wchar_t aUnspecified_7[12];

//----- (00000001400629F0) ----------------------------------------------------
__int64 __fastcall sub_1400629F0(__int64 a1, int a2, _WORD *a3)
{
  int v3; // edi
  __int64 v4; // rbp
  __int64 v6; // rax
  __int64 v7; // rbx
  double v8; // xmm0_8
  __int64 v9; // rax
  double v10; // xmm5_8
  __m128i v11; // xmm0
  __int64 v13[5]; // [rsp+20h] [rbp-58h]
  _QWORD v14[2]; // [rsp+48h] [rbp-30h]
  int v15; // [rsp+58h] [rbp-20h]
  int v16; // [rsp+5Ch] [rbp-1Ch]
  int v17; // [rsp+60h] [rbp-18h]
  int v18; // [rsp+64h] [rbp-14h]

  v3 = 0;
  v13[0] = (__int64)L"Folders";
  v14[1] = 0i64;
  v4 = 592i64 * a2;
  v13[1] = (__int64)L"Tiny";
  v13[2] = (__int64)L"Small";
  v15 = 0x8000;
  v13[3] = (__int64)L"Medium";
  v16 = 102400;
  v13[4] = (__int64)L"Large";
  v17 = 0x100000;
  v14[0] = L"Huge";
  v6 = *(_QWORD *)(a1 + 88);
  v18 = 10485760;
  if ( (*(_BYTE *)(v6 + v4) & 0x10) == 0 )
  {
    v3 = 5;
    v7 = v6;
    v8 = pow(2.0, 32.0);
    v9 = 5i64;
    v10 = v8 * (double)*(int *)(v7 + v4 + 28) + (double)*(int *)(v7 + v4 + 32);
    if ( v10 < 10485760.0 )
    {
      do
      {
        if ( v9 <= 0 )
          break;
        v11 = _mm_cvtsi32_si128(*((_DWORD *)v14 + v9-- + 1));
        --v3;
      }
      while ( _mm_cvtepi32_pd(v11).m128d_f64[0] > v10 );
    }
  }
  return sub_140001240(a3, 0x200ui64, v13[v3]);
}
// 1400E9F58: using guessed type wchar_t aFolders[8];
// 1400E9F68: using guessed type wchar_t aTiny[5];
// 1400E9F78: using guessed type wchar_t aSmall[6];
// 1400E9F88: using guessed type wchar_t aMedium[7];
// 1400E9F98: using guessed type wchar_t aLarge[6];
// 1400E9FA8: using guessed type wchar_t aHuge[5];
// 1400629F0: using guessed type __int64 var_58[5];

//----- (0000000140062B50) ----------------------------------------------------
__int64 __fastcall sub_140062B50(__int64 a1, int a2, wchar_t *a3, __int64 a4, __int64 a5)
{
  wint_t v6; // di
  wint_t v7; // ax
  __int64 result; // rax
  __int64 v9; // rcx
  signed __int64 v10; // rdx
  wchar_t v11; // ax

  v6 = *(_WORD *)(568i64 * a2 + *(_QWORD *)(a1 + 96) + 8);
  if ( iswalpha(v6) )
  {
    v7 = towupper(v6);
    return sub_140001000(a3, 0x200ui64, L"%c", v7, a5);
  }
  else
  {
    v9 = 512i64;
    v10 = (char *)L"Other" - (char *)a3;
    while ( v9 != -2147483134 )
    {
      v11 = *(wchar_t *)((char *)a3 + v10);
      if ( !v11 )
        break;
      *a3++ = v11;
      if ( !--v9 )
      {
        --a3;
        break;
      }
    }
    result = 0i64;
    *a3 = 0;
  }
  return result;
}
// 140062BE6: conditional instruction was optimized away because rcx.8!=0
// 1400E9F40: using guessed type wchar_t aC_0[3];
// 1400E9F48: using guessed type wchar_t aOther_5[6];

//----- (0000000140062C10) ----------------------------------------------------
__int64 __fastcall sub_140062C10(__int64 a1, const WCHAR *a2, WPARAM a3)
{
  const WCHAR **v3; // rax
  const WCHAR *v6; // rbx
  WPARAM *v8; // r12
  __int64 v9; // rdx
  char *v10; // rcx
  __int16 v11; // ax
  HWND v12; // rcx
  WPARAM *v13; // r8
  int *v14; // r9
  UINT v15; // edx
  __int64 v16; // rbx
  __int64 v17; // rdx
  char *v18; // r11
  __int64 v19; // rax
  unsigned int v20; // eax
  WPARAM wParam[2]; // [rsp+30h] [rbp-D0h] BYREF
  int v23; // [rsp+40h] [rbp-C0h]
  int v24; // [rsp+44h] [rbp-BCh]
  __int16 *v25; // [rsp+48h] [rbp-B8h]
  int v26; // [rsp+64h] [rbp-9Ch]
  int v27; // [rsp+68h] [rbp-98h]
  int v28; // [rsp+6Ch] [rbp-94h]
  int v29[2]; // [rsp+80h] [rbp-80h] BYREF
  __int16 *v30; // [rsp+88h] [rbp-78h]
  struct _OSVERSIONINFOW VersionInformation; // [rsp+C0h] [rbp-40h] BYREF
  char v32[1024]; // [rsp+1E0h] [rbp+E0h] BYREF
  int v33; // [rsp+5E0h] [rbp+4E0h]
  int v34; // [rsp+5E4h] [rbp+4E4h]
  __int16 v35[512]; // [rsp+5F0h] [rbp+4F0h] BYREF

  v3 = *(const WCHAR ***)(a1 + 1480);
  v6 = *v3;
  if ( *v3 == (const WCHAR *)v3 )
  {
LABEL_4:
    LODWORD(v8) = *(_DWORD *)(a1 + 1504);
    v9 = 512i64;
    v10 = v32;
    *(_DWORD *)(a1 + 1504) = (_DWORD)v8 + 1;
    while ( v9 != -2147483134 )
    {
      v11 = *(_WORD *)&v10[(char *)a2 - v32];
      if ( !v11 )
        break;
      *(_WORD *)v10 = v11;
      v10 += 2;
      if ( !--v9 )
      {
        v10 -= 2;
        break;
      }
    }
    v16 = *(_QWORD *)(a1 + 1480);
    v17 = *(_QWORD *)(v16 + 8);
    *(_WORD *)v10 = 0;
    v33 = (int)v8;
    v34 = 1;
    v18 = sub_14002B490(v16, v17, v32);
    v19 = *(_QWORD *)(a1 + 1488);
    if ( v19 == 0x3F80FE03F80FDFi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 1488) = v19 + 1;
    *(_QWORD *)(v16 + 8) = v18;
    **((_QWORD **)v18 + 1) = v18;
    v20 = *(_DWORD *)(a1 + 700);
    if ( v20 < 6 )
    {
      if ( v20 >= 5 )
        sub_140001000((wchar_t *)v35, 0x200ui64, L"%s", a2);
    }
    else
    {
      sub_140001000((wchar_t *)v35, 0x200ui64, L"%s (%d)", a2, 1);
    }
    v23 = 56;
    v24 = 17;
    v26 = (int)v8;
    v27 = 0;
    v25 = v35;
    VersionInformation.dwOSVersionInfoSize = 276;
    if ( GetVersionExW(&VersionInformation) && VersionInformation.dwMajorVersion > 5 )
    {
      v24 |= 4u;
      v28 = 8;
    }
    v12 = *(HWND *)(a1 + 56);
    wParam[0] = a3;
    v14 = 0i64;
    v13 = wParam;
    v15 = 4255;
    wParam[1] = (WPARAM)v12;
    goto LABEL_21;
  }
  while ( lstrcmpiW(a2, v6 + 8) )
  {
    v6 = *(const WCHAR **)v6;
    if ( v6 == *(const WCHAR **)(a1 + 1480) )
      goto LABEL_4;
  }
  v8 = (WPARAM *)*((int *)v6 + 260);
  ++*((_DWORD *)v6 + 261);
  if ( *(_DWORD *)(a1 + 700) >= 6u )
  {
    sub_140001000((wchar_t *)v35, 0x200ui64, L"%s (%d)", a2, *((_DWORD *)v6 + 261));
    v12 = *(HWND *)(a1 + 56);
    v30 = v35;
    v29[0] = 56;
    v29[1] = 1;
    v13 = v8;
    v14 = v29;
    v15 = 4243;
LABEL_21:
    SendMessageW(v12, v15, (WPARAM)v13, (LPARAM)v14);
  }
  return (unsigned int)v8;
}
// 140062D38: conditional instruction was optimized away because rdx.8!=0
// 1400E9F18: using guessed type wchar_t aSD[8];
// 1400E9F28: using guessed type wchar_t aSD_0[8];
// 1400E9F38: using guessed type wchar_t aS_0[3];
// 140062C10: using guessed type wchar_t var_440[512];

//----- (0000000140062EA0) ----------------------------------------------------
__int64 __fastcall sub_140062EA0(__int64 a1, int a2, int a3, char *a4)
{
  __int64 v6; // r10
  WCHAR *v7; // r9
  WCHAR v8; // ax
  __int64 v9; // rax
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int16 *v13; // rcx
  __int16 v14; // ax
  signed __int64 v15; // rcx
  __int64 result; // rax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-638h] BYREF
  __int16 v18[512]; // [rsp+230h] [rbp-428h] BYREF

  v6 = 260i64;
  v7 = pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v7 + a1 + 160 - (_QWORD)pszPath);
    if ( !v8 )
      break;
    *v7++ = v8;
    if ( !--v6 )
    {
      --v7;
      break;
    }
  }
  v9 = *(_QWORD *)(a1 + 88);
  *v7 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v9 + 44));
  v10 = sub_140082350((__int64)pszPath, a3, (WCHAR *)v18);
  v11 = 512i64;
  if ( !v10 )
  {
    v12 = 512i64;
    v13 = v18;
    while ( v12 != -2147483134 )
    {
      v14 = *(__int16 *)((char *)v13 + (char *)L"Other" - (char *)v18);
      if ( !v14 )
        break;
      *v13++ = v14;
      if ( !--v12 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  v15 = (char *)v18 - a4;
  while ( 1 )
  {
    result = v11 + 2147483134;
    if ( v11 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a4[v15];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a4 = result;
    a4 += 2;
    if ( !--v11 )
    {
      *((_WORD *)a4 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a4 = 0;
  return result;
}
// 140062F0B: conditional instruction was optimized away because r10.8!=0
// 140062F97: conditional instruction was optimized away because r8.8!=0
// 140062FDA: conditional instruction was optimized away because rdx.8!=0
// 1400EA188: using guessed type wchar_t aOther_6[6];
// 140062EA0: using guessed type WCHAR var_428[512];

//----- (0000000140063010) ----------------------------------------------------
__int64 __fastcall sub_140063010(__int64 a1, int a2, __int64 a3, char *a4)
{
  __int64 v6; // r9
  WCHAR *v7; // r8
  WCHAR v8; // ax
  __int64 v9; // rax
  DWORD FileVersionInfoSizeW; // eax
  __int64 v11; // rdi
  __int64 v12; // rdx
  __int16 *v13; // rcx
  __int16 v14; // ax
  signed __int64 v15; // rcx
  __int64 result; // rax
  int dwHandle[4]; // [rsp+20h] [rbp-658h] BYREF
  WCHAR pszPath[264]; // [rsp+30h] [rbp-648h] BYREF
  __int16 v19[512]; // [rsp+240h] [rbp-438h] BYREF

  v6 = 260i64;
  v7 = pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v7 + a1 + 160 - (_QWORD)pszPath);
    if ( !v8 )
      break;
    *v7++ = v8;
    if ( !--v6 )
    {
      --v7;
      break;
    }
  }
  v9 = *(_QWORD *)(a1 + 88);
  *v7 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v9 + 44));
  dwHandle[0] = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszPath, (LPDWORD)dwHandle);
  v11 = 512i64;
  if ( !FileVersionInfoSizeW || !(unsigned int)sub_140082920(pszPath, a3, v19, FileVersionInfoSizeW) )
  {
    v12 = 512i64;
    v13 = v19;
    while ( v12 != -2147483134 )
    {
      v14 = *(__int16 *)((char *)v13 + (char *)L"Unspecified" - (char *)v19);
      if ( !v14 )
        break;
      *v13++ = v14;
      if ( !--v12 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  v15 = (char *)v19 - a4;
  while ( 1 )
  {
    result = v11 + 2147483134;
    if ( v11 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a4[v15];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a4 = result;
    a4 += 2;
    if ( !--v11 )
    {
      *((_WORD *)a4 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a4 = 0;
  return result;
}
// 140063079: conditional instruction was optimized away because r9.8!=0
// 140063127: conditional instruction was optimized away because rdx.8!=0
// 14006316A: conditional instruction was optimized away because rdi.8!=0
// 1400EA170: using guessed type wchar_t aUnspecified_8[12];
// 140063010: using guessed type DWORD dwHandle[4];
// 140063010: using guessed type _WORD var_438[512];

//----- (00000001400631A0) ----------------------------------------------------
__int64 __fastcall sub_1400631A0(__int64 a1, int a2, char *a3)
{
  __int64 v4; // r9
  WCHAR *v5; // r8
  WCHAR v6; // ax
  __int64 v7; // rax
  __int64 v8; // r11
  signed __int64 v9; // rcx
  __int64 result; // rax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-628h] BYREF
  __int16 v12[512]; // [rsp+230h] [rbp-418h] BYREF

  v4 = 260i64;
  v5 = pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + a1 + 160 - (_QWORD)pszPath);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = *(_QWORD *)(a1 + 88);
  *v5 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v7 + 44));
  sub_140082CD0(pszPath, (wchar_t *)v12);
  v8 = 512i64;
  v9 = (char *)v12 - a3;
  while ( 1 )
  {
    result = v8 + 2147483134;
    if ( v8 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a3[v9];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a3 = result;
    a3 += 2;
    if ( !--v8 )
    {
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a3 = 0;
  return result;
}
// 140063208: conditional instruction was optimized away because r9.8!=0
// 14006328A: conditional instruction was optimized away because r11.8!=0
// 1400631A0: using guessed type wchar_t var_418[512];

//----- (00000001400632C0) ----------------------------------------------------
__int64 __fastcall sub_1400632C0(__int64 a1, int a2, char *a3)
{
  __int64 v4; // r9
  WCHAR *v5; // r8
  WCHAR v6; // ax
  __int64 v7; // rax
  __int64 v8; // rdx
  char *v9; // rcx
  __int16 v10; // ax
  HANDLE v11; // r11
  __int64 v12; // rcx
  signed __int64 v13; // rdx
  __int64 result; // rax
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+20h] [rbp-4B8h] BYREF
  char v16[64]; // [rsp+270h] [rbp-268h] BYREF
  WCHAR pszPath[264]; // [rsp+2B0h] [rbp-228h] BYREF

  v4 = 260i64;
  v5 = pszPath;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + a1 + 160 - (_QWORD)pszPath);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = *(_QWORD *)(a1 + 88);
  *v5 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v7 + 44));
  if ( FindFirstFileW(pszPath, &FindFileData) == (HANDLE)-1i64 )
  {
    v8 = 32i64;
    v9 = v16;
    while ( v8 != -2147483614 )
    {
      v10 = *(_WORD *)&v9[&unk_1400EAC9C - (_UNKNOWN *)v16];
      if ( !v10 )
        break;
      *(_WORD *)v9 = v10;
      v9 += 2;
      if ( !--v8 )
      {
        *((_WORD *)v9 - 1) = 0;
        goto LABEL_14;
      }
    }
    *(_WORD *)v9 = 0;
  }
  else
  {
    sub_140082FB0(FindFileData.dwFileAttributes, v16, 0x20u);
    FindClose(v11);
  }
LABEL_14:
  v12 = 512i64;
  v13 = v16 - a3;
  while ( 1 )
  {
    result = v12 + 2147483134;
    if ( v12 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a3[v13];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a3 = result;
    a3 += 2;
    if ( !--v12 )
    {
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a3 = 0;
  return result;
}
// 140063338: conditional instruction was optimized away because r9.8!=0
// 1400633CE: conditional instruction was optimized away because rdx.8!=0
// 14006343A: conditional instruction was optimized away because rcx.8!=0
// 1400633F3: variable 'v11' is possibly undefined

//----- (0000000140063470) ----------------------------------------------------
__int64 __fastcall sub_140063470(__int64 a1, int a2, char *a3)
{
  __int64 v5; // rax
  const ITEMIDLIST *v6; // rcx
  __int64 v7; // rsi
  ITEMIDLIST *v8; // rbx
  __int64 v9; // rsi
  BOOL DiskFreeSpace; // ebx
  __int16 *v11; // rcx
  __int16 v12; // ax
  __int64 v13; // rcx
  signed __int64 v14; // rdx
  __int64 result; // rax
  LPCITEMIDLIST pidl1; // [rsp+20h] [rbp-E0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+28h] [rbp-D8h] BYREF
  void *ppv; // [rsp+30h] [rbp-D0h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [rsp+38h] [rbp-C8h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+40h] [rbp-C0h] BYREF
  STRRET pstr; // [rsp+50h] [rbp-B0h] BYREF
  __int16 v22[264]; // [rsp+160h] [rbp+60h] BYREF
  WCHAR pszBuf[264]; // [rsp+370h] [rbp+270h] BYREF

  v5 = a1 + 160;
  v6 = 0i64;
  v7 = a2;
  ppv = 0i64;
  ppidlLast = 0i64;
  pidl1 = 0i64;
  if ( v5 )
  {
    sub_14007F810(v5, (__int64)&pidl1);
    v6 = pidl1;
  }
  v8 = ILCombine(v6, *(LPCITEMIDLIST *)(568 * v7 + *(_QWORD *)(a1 + 96)));
  SHBindToParent(v8, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  v9 = 260i64;
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree((LPVOID)pidl1);
  CoTaskMemFree(v8);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  if ( !PathIsRootW(pszBuf)
    || (DiskFreeSpace = GetDiskFreeSpaceExW(pszBuf, 0i64, &TotalNumberOfBytes, &TotalNumberOfFreeBytes),
        sub_140001000(
          (wchar_t *)v22,
          0x104ui64,
          L"%I64d%% free",
          10 * (100 * TotalNumberOfFreeBytes.QuadPart / TotalNumberOfBytes.QuadPart / 0xA)),
        !DiskFreeSpace) )
  {
    v11 = v22;
    while ( v9 != -2147483386 )
    {
      v12 = *(__int16 *)((char *)v11 + (char *)L"Unspecified" - (char *)v22);
      if ( !v12 )
        break;
      *v11++ = v12;
      if ( !--v9 )
      {
        --v11;
        break;
      }
    }
    *v11 = 0;
  }
  v13 = 512i64;
  v14 = (char *)v22 - a3;
  while ( 1 )
  {
    result = v13 + 2147483134;
    if ( v13 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a3[v14];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a3 = result;
    a3 += 2;
    if ( !--v13 )
    {
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a3 = 0;
  return result;
}
// 140063607: conditional instruction was optimized away because rsi.8!=0
// 14006364B: conditional instruction was optimized away because rcx.8!=0
// 1400EA138: using guessed type wchar_t aI64dFree[13];
// 1400EA158: using guessed type wchar_t aUnspecified_9[12];
// 140063470: using guessed type wchar_t var_450[264];

//----- (0000000140063680) ----------------------------------------------------
__int64 __fastcall sub_140063680(__int64 a1, int a2, int a3, char *a4)
{
  __int64 v6; // r10
  WCHAR *v7; // r9
  WCHAR v8; // ax
  __int64 v9; // rax
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int16 *v13; // rcx
  __int16 v14; // ax
  signed __int64 v15; // rcx
  __int64 result; // rax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-638h] BYREF
  __int16 v18[512]; // [rsp+230h] [rbp-428h] BYREF

  v6 = 260i64;
  v7 = pszPath;
  while ( v6 != -2147483386 )
  {
    v8 = *(WCHAR *)((char *)v7 + a1 + 160 - (_QWORD)pszPath);
    if ( !v8 )
      break;
    *v7++ = v8;
    if ( !--v6 )
    {
      --v7;
      break;
    }
  }
  v9 = *(_QWORD *)(a1 + 88);
  *v7 = 0;
  PathAppendW(pszPath, (LPCWSTR)(592i64 * a2 + v9 + 44));
  v10 = sub_140082600((__int64)pszPath, a3, (WCHAR *)v18);
  v11 = 512i64;
  if ( v10 == -1 )
  {
    v12 = 512i64;
    v13 = v18;
    while ( v12 != -2147483134 )
    {
      v14 = *(__int16 *)((char *)v13 + (char *)L"Unspecified" - (char *)v18);
      if ( !v14 )
        break;
      *v13++ = v14;
      if ( !--v12 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  v15 = (char *)v18 - a4;
  while ( 1 )
  {
    result = v11 + 2147483134;
    if ( v11 == -2147483134 )
      break;
    result = *(unsigned __int16 *)&a4[v15];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a4 = result;
    a4 += 2;
    if ( !--v11 )
    {
      *((_WORD *)a4 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a4 = 0;
  return result;
}
// 1400636EB: conditional instruction was optimized away because r10.8!=0
// 140063777: conditional instruction was optimized away because r8.8!=0
// 1400637BA: conditional instruction was optimized away because rdx.8!=0
// 1400EA120: using guessed type wchar_t aUnspecified_10[12];
// 140063680: using guessed type WCHAR var_428[512];

//----- (00000001400637F0) ----------------------------------------------------
void __fastcall sub_1400637F0(__int64 a1, int a2, char *a3)
{
  __int64 v5; // rax
  const ITEMIDLIST *v6; // rcx
  __int64 v7; // rsi
  LPITEMIDLIST v8; // rdi
  signed __int64 v9; // rcx
  __int64 v10; // r11
  __int16 v11; // ax
  void *pidl1[2]; // [rsp+30h] [rbp-2F8h] BYREF
  SHFILEINFOW psfi; // [rsp+40h] [rbp-2E8h] BYREF

  v5 = a1 + 160;
  v6 = 0i64;
  v7 = a2;
  pidl1[0] = 0i64;
  if ( v5 )
  {
    sub_14007F810(v5, (__int64)pidl1);
    v6 = (const ITEMIDLIST *)pidl1[0];
  }
  v8 = ILCombine(v6, *(LPCITEMIDLIST *)(568 * v7 + *(_QWORD *)(a1 + 96)));
  SHGetFileInfoW(&v8->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
  v9 = (char *)psfi.szTypeName - a3;
  v10 = 512i64;
  while ( v10 != -2147483134 )
  {
    v11 = *(_WORD *)&a3[v9];
    if ( !v11 )
      break;
    *(_WORD *)a3 = v11;
    a3 += 2;
    if ( !--v10 )
    {
      a3 -= 2;
      break;
    }
  }
  *(_WORD *)a3 = 0;
  CoTaskMemFree(v8);
  CoTaskMemFree(pidl1[0]);
}
// 1400638B6: conditional instruction was optimized away because r11.8!=0
// 1400637F0: using guessed type LPCITEMIDLIST pidl1[2];

//----- (0000000140063900) ----------------------------------------------------
__int64 __fastcall sub_140063900(__int64 a1, int a2, _WORD *a3)
{
  const ITEMIDLIST *v4; // rcx
  __int64 v6; // r12
  ITEMIDLIST *v7; // r12
  BOOL DiskFreeSpace; // esi
  int v9; // er11
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 result; // rax
  void *ppv; // [rsp+20h] [rbp-E0h] BYREF
  LPCITEMIDLIST pidl1; // [rsp+28h] [rbp-D8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+30h] [rbp-D0h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v18[5]; // [rsp+40h] [rbp-C0h]
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [rsp+68h] [rbp-98h] BYREF
  STRRET pstr; // [rsp+70h] [rbp-90h] BYREF
  __int64 v21[6]; // [rsp+180h] [rbp+80h]
  WCHAR pszBuf[264]; // [rsp+1B0h] [rbp+B0h] BYREF

  v18[0] = (__int64)L"Unspecified";
  v18[1] = (__int64)L"Small";
  v4 = 0i64;
  v18[2] = (__int64)L"Medium";
  v18[3] = (__int64)L"Huge";
  v6 = a2;
  v18[4] = (__int64)L"Gigantic";
  ppv = 0i64;
  v21[3] = 0x500000000i64;
  pidl1 = 0i64;
  ppidlLast = 0i64;
  v21[0] = 0i64;
  v21[1] = 0i64;
  v21[2] = 0x40000000i64;
  v21[4] = 0x1900000000i64;
  if ( a1 != -160 )
  {
    sub_14007F810(a1 + 160, (__int64)&pidl1);
    v4 = pidl1;
  }
  v7 = ILCombine(v4, *(LPCITEMIDLIST *)(568 * v6 + *(_QWORD *)(a1 + 96)));
  SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  if ( !PathIsRootW(pszBuf) )
    goto LABEL_8;
  DiskFreeSpace = GetDiskFreeSpaceExW(pszBuf, 0i64, &TotalNumberOfBytes, &TotalNumberOfFreeBytes);
  CoTaskMemFree((LPVOID)pidl1);
  CoTaskMemFree(v7);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  v9 = 4;
  v10 = 4i64;
  if ( TotalNumberOfBytes.QuadPart < 0x1900000000i64 )
  {
    do
    {
      if ( v10 <= 0 )
        break;
      --v10;
      --v9;
    }
    while ( TotalNumberOfBytes.QuadPart < v21[v10] );
  }
  if ( !DiskFreeSpace )
LABEL_8:
    v9 = 0;
  v11 = 512i64;
  v12 = v18[v9] - (_QWORD)a3;
  while ( 1 )
  {
    result = v11 + 2147483134;
    if ( v11 == -2147483134 )
      break;
    result = *(unsigned __int16 *)((char *)a3 + v12);
    if ( !(_WORD)result )
      break;
    *a3++ = result;
    if ( !--v11 )
    {
      *(a3 - 1) = 0;
      return result;
    }
  }
  *a3 = 0;
  return result;
}
// 140063B0A: conditional instruction was optimized away because rcx.8!=0
// 1400E9FB8: using guessed type wchar_t aUnspecified_11[12];
// 1400E9FD0: using guessed type wchar_t aSmall_0[6];
// 1400E9FE0: using guessed type wchar_t aMedium_0[7];
// 1400E9FF0: using guessed type wchar_t aHuge_0[5];
// 1400EA000: using guessed type wchar_t aGigantic[9];

//----- (0000000140063B50) ----------------------------------------------------
__int64 __fastcall sub_140063B50(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v4)(int, int); // rbx
  __int64 v5; // rdi
  int v7; // er8
  __int64 v8; // rcx
  __int16 *v9; // rdx
  __int64 v10; // r8
  __int16 v11; // ax
  int v12; // er8
  __int64 v13; // rcx
  __int16 *v14; // rdx
  __int64 v15; // r8
  __int16 v16; // ax
  int v17; // er8
  __int64 v18; // rcx
  __int16 *v19; // rdx
  __int64 v20; // r8
  __int16 v21; // ax
  struct _FILETIME LocalFileTime; // [rsp+20h] [rbp-E0h] BYREF
  const wchar_t *v24; // [rsp+30h] [rbp-D0h]
  const wchar_t *v25; // [rsp+38h] [rbp-C8h]
  const wchar_t *v26; // [rsp+40h] [rbp-C0h]
  const wchar_t *v27; // [rsp+48h] [rbp-B8h]
  const wchar_t *v28; // [rsp+50h] [rbp-B0h]
  const wchar_t *v29; // [rsp+58h] [rbp-A8h]
  const wchar_t *v30; // [rsp+60h] [rbp-A0h]
  const wchar_t *v31; // [rsp+68h] [rbp-98h]
  const wchar_t *v32; // [rsp+70h] [rbp-90h]
  const wchar_t *v33; // [rsp+78h] [rbp-88h]
  const wchar_t *v34; // [rsp+80h] [rbp-80h]
  struct _SYSTEMTIME SystemTime; // [rsp+90h] [rbp-70h] BYREF
  struct _SYSTEMTIME v36; // [rsp+A0h] [rbp-60h] BYREF
  __int16 v37[512]; // [rsp+B0h] [rbp-50h] BYREF

  v4 = 0i64;
  v5 = a2;
  switch ( *(_DWORD *)(a1 + 704) )
  {
    case 1:
    case 0xC:
      sub_140062B50(a1, a2, (wchar_t *)v37, a4, *(_QWORD *)&LocalFileTime);
      goto LABEL_77;
    case 2:
      v24 = L"Today";
      v25 = L"Yesterday";
      v26 = L"This Week";
      v27 = L"Last Week";
      v28 = L"This Month";
      v29 = L"Last Month";
      v30 = L"This Year";
      v31 = L"Last Year";
      v32 = L"Two Years Ago";
      v33 = L"Long ago";
      v34 = L"Unspecified";
      GetLocalTime(&SystemTime);
      FileTimeToLocalFileTime((const FILETIME *)(592 * v5 + *(_QWORD *)(a1 + 88) + 20), &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &v36);
      if ( v36.wYear == SystemTime.wYear )
      {
        if ( v36.wMonth == SystemTime.wMonth )
        {
          if ( v36.wDay == SystemTime.wDay )
          {
            v7 = 0;
          }
          else if ( v36.wDay == SystemTime.wDay - 1 )
          {
            v7 = 1;
          }
          else
          {
            v7 = (v36.wDay < SystemTime.wDay - 7) + 3;
          }
        }
        else
        {
          v7 = (v36.wMonth != SystemTime.wMonth - 1) + 5;
        }
      }
      else if ( v36.wYear == SystemTime.wYear - 1 )
      {
        v7 = 6;
      }
      else
      {
        v7 = (v36.wYear != SystemTime.wYear - 2) + 7;
      }
      v8 = 512i64;
      v9 = v37;
      v10 = (char *)(&v24)[v7] - (char *)v37;
      while ( v8 != -2147483134 )
      {
        v11 = *(__int16 *)((char *)v9 + v10);
        if ( !v11 )
          break;
        *v9++ = v11;
        if ( !--v8 )
        {
          *(v9 - 1) = 0;
          goto LABEL_77;
        }
      }
      *v9 = 0;
      goto LABEL_77;
    case 3:
      sub_1400629F0(a1, a2, v37);
      goto LABEL_77;
    case 4:
    case 0x23:
      sub_1400637F0(a1, a2, (char *)v37);
      goto LABEL_77;
    case 5:
      sub_140063900(a1, a2, v37);
      goto LABEL_77;
    case 6:
      sub_140063470(a1, a2, (char *)v37);
      v4 = sub_140062190;
      return sub_140062C10(a1, (const WCHAR *)v37, (WPARAM)v4);
    case 7:
      sub_140063680(a1, a2, 6, (char *)v37);
      goto LABEL_77;
    case 0xA:
      sub_1400632C0(a1, a2, (char *)v37);
      goto LABEL_77;
    case 0xD:
      sub_1400631A0(a1, a2, (char *)v37);
      goto LABEL_77;
    case 0xE:
      sub_140063010(a1, a2, (__int64)L"ProductName", (char *)v37);
      goto LABEL_77;
    case 0xF:
      sub_140063010(a1, a2, (__int64)L"CompanyName", (char *)v37);
      goto LABEL_77;
    case 0x10:
      sub_140063010(a1, a2, (__int64)L"FileDescription", (char *)v37);
      goto LABEL_77;
    case 0x11:
      sub_140063010(a1, a2, (__int64)L"FileVersion", (char *)v37);
      goto LABEL_77;
    case 0x12:
      sub_140063010(a1, a2, (__int64)L"ProductVersion", (char *)v37);
      goto LABEL_77;
    case 0x15:
      sub_140062700(a1, a2, (char *)v37);
      goto LABEL_77;
    case 0x16:
      v24 = L"Today";
      v25 = L"Yesterday";
      v26 = L"This Week";
      v27 = L"Last Week";
      v28 = L"This Month";
      v29 = L"Last Month";
      v30 = L"This Year";
      v31 = L"Last Year";
      v32 = L"Two Years Ago";
      v33 = L"Long ago";
      v34 = L"Unspecified";
      GetLocalTime(&v36);
      FileTimeToLocalFileTime((const FILETIME *)(592 * v5 + *(_QWORD *)(a1 + 88) + 4), &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      if ( SystemTime.wYear == v36.wYear )
      {
        if ( SystemTime.wMonth == v36.wMonth )
        {
          if ( SystemTime.wDay == v36.wDay )
          {
            v12 = 0;
          }
          else if ( SystemTime.wDay == v36.wDay - 1 )
          {
            v12 = 1;
          }
          else
          {
            v12 = (SystemTime.wDay < v36.wDay - 7) + 3;
          }
        }
        else
        {
          v12 = (SystemTime.wMonth != v36.wMonth - 1) + 5;
        }
      }
      else if ( SystemTime.wYear == v36.wYear - 1 )
      {
        v12 = 6;
      }
      else
      {
        v12 = (SystemTime.wYear != v36.wYear - 2) + 7;
      }
      v13 = 512i64;
      v14 = v37;
      v15 = (char *)(&v24)[v12] - (char *)v37;
      while ( v13 != -2147483134 )
      {
        v16 = *(__int16 *)((char *)v14 + v15);
        if ( !v16 )
          break;
        *v14++ = v16;
        if ( !--v13 )
        {
          *(v14 - 1) = 0;
          goto LABEL_77;
        }
      }
      *v14 = 0;
      goto LABEL_77;
    case 0x17:
      v24 = L"Today";
      v25 = L"Yesterday";
      v26 = L"This Week";
      v27 = L"Last Week";
      v28 = L"This Month";
      v29 = L"Last Month";
      v30 = L"This Year";
      v31 = L"Last Year";
      v32 = L"Two Years Ago";
      v33 = L"Long ago";
      v34 = L"Unspecified";
      GetLocalTime(&v36);
      FileTimeToLocalFileTime((const FILETIME *)(592 * v5 + *(_QWORD *)(a1 + 88) + 12), &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      if ( SystemTime.wYear == v36.wYear )
      {
        if ( SystemTime.wMonth == v36.wMonth )
        {
          if ( SystemTime.wDay == v36.wDay )
          {
            v17 = 0;
          }
          else if ( SystemTime.wDay == v36.wDay - 1 )
          {
            v17 = 1;
          }
          else
          {
            v17 = (SystemTime.wDay < v36.wDay - 7) + 3;
          }
        }
        else
        {
          v17 = (SystemTime.wMonth != v36.wMonth - 1) + 5;
        }
      }
      else if ( SystemTime.wYear == v36.wYear - 1 )
      {
        v17 = 6;
      }
      else
      {
        v17 = (SystemTime.wYear != v36.wYear - 2) + 7;
      }
      v18 = 512i64;
      v19 = v37;
      v20 = (char *)(&v24)[v17] - (char *)v37;
      break;
    case 0x18:
      sub_140063680(a1, a2, 2, (char *)v37);
      goto LABEL_77;
    case 0x19:
      sub_140063680(a1, a2, 3, (char *)v37);
      goto LABEL_77;
    case 0x1A:
      sub_140063680(a1, a2, 4, (char *)v37);
      goto LABEL_77;
    case 0x1B:
      sub_140063680(a1, a2, 5, (char *)v37);
      goto LABEL_77;
    case 0x1D:
      sub_140062EA0(a1, a2, 272, (char *)v37);
      goto LABEL_77;
    case 0x1E:
      sub_140062EA0(a1, a2, 306, (char *)v37);
      goto LABEL_77;
    case 0x1F:
      sub_140062EA0(a1, a2, 256, (char *)v37);
      goto LABEL_77;
    case 0x20:
      sub_140062EA0(a1, a2, 257, (char *)v37);
      goto LABEL_77;
    case 0x22:
      sub_1400624F0(a1, a2, (char *)v37);
      goto LABEL_77;
    case 0x28:
      sub_1400623D0(a1, (char *)v37);
      goto LABEL_77;
    default:
      return sub_140062C10(a1, (const WCHAR *)v37, (WPARAM)v4);
  }
  while ( v18 != -2147483134 )
  {
    v21 = *(__int16 *)((char *)v19 + v20);
    if ( !v21 )
      break;
    *v19++ = v21;
    if ( !--v18 )
    {
      *(v19 - 1) = 0;
      goto LABEL_77;
    }
  }
  *v19 = 0;
LABEL_77:
  v4 = sub_1400622B0;
  return sub_140062C10(a1, (const WCHAR *)v37, (WPARAM)v4);
}
// 140063D72: conditional instruction was optimized away because rcx.8!=0
// 140064001: conditional instruction was optimized away because rcx.8!=0
// 1400641A4: conditional instruction was optimized away because rcx.8!=0
// 1400E9E90: using guessed type wchar_t aProductname[12];
// 1400E9EA8: using guessed type wchar_t aCompanyname[12];
// 1400E9EC0: using guessed type wchar_t aFiledescriptio[16];
// 1400E9EE0: using guessed type wchar_t aFileversion[12];
// 1400E9EF8: using guessed type wchar_t aProductversion[15];
// 1400EA018: using guessed type wchar_t aToday[6];
// 1400EA028: using guessed type wchar_t aYesterday[10];
// 1400EA040: using guessed type wchar_t aThisWeek[10];
// 1400EA058: using guessed type wchar_t aLastWeek[10];
// 1400EA070: using guessed type wchar_t aThisMonth[11];
// 1400EA088: using guessed type wchar_t aLastMonth[11];
// 1400EA0A0: using guessed type wchar_t aThisYear[10];
// 1400EA0B8: using guessed type wchar_t aLastYear[10];
// 1400EA0D0: using guessed type wchar_t aTwoYearsAgo[14];
// 1400EA0F0: using guessed type wchar_t aLongAgo[9];
// 1400EA108: using guessed type wchar_t aUnspecified_7[12];
// 140063B50: using guessed type wchar_t var_420[512];

//----- (0000000140064380) ----------------------------------------------------
LRESULT __fastcall sub_140064380(__int64 a1)
{
  int v2; // ebp
  _QWORD **v3; // rdx
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  int v6; // eax
  int v7; // ebx
  HWND v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  int v11; // eax
  HWND v12; // rcx
  _DWORD lParam[20]; // [rsp+20h] [rbp-A8h] BYREF
  _DWORD v15[20]; // [rsp+70h] [rbp-58h] BYREF

  SendMessageW(*(HWND *)(a1 + 56), 0x10A0u, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 56), 0x109Du, 1ui64, 0i64);
  v2 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 56), 0xBu, 0i64, 0i64);
  v3 = *(_QWORD ***)(a1 + 1480);
  v4 = *v3;
  *v3 = v3;
  *(_QWORD *)(*(_QWORD *)(a1 + 1480) + 8i64) = *(_QWORD *)(a1 + 1480);
  *(_QWORD *)(a1 + 1488) = 0i64;
  if ( v4 != *(_QWORD **)(a1 + 1480) )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)(a1 + 1480) );
  }
  v6 = *(_DWORD *)(a1 + 820);
  *(_DWORD *)(a1 + 1504) = 0;
  qword_14012DF30 = a1 + 1480;
  v7 = 0;
  for ( dword_14012DB30 = v6; v7 < v2; ++v7 )
  {
    v8 = *(HWND *)(a1 + 56);
    lParam[0] = 4;
    lParam[1] = v7;
    lParam[2] = 0;
    SendMessageW(v8, 0x104Bu, 0i64, (LPARAM)lParam);
    v15[0] = 256;
    v15[1] = v7;
    v15[2] = 0;
    v11 = sub_140063B50(a1, lParam[10], v9, v10);
    v12 = *(HWND *)(a1 + 56);
    v15[13] = v11;
    SendMessageW(v12, 0x104Cu, 0i64, (LPARAM)v15);
  }
  return SendMessageW(*(HWND *)(a1 + 56), 0xBu, 1ui64, 0i64);
}
// 140064491: variable 'v9' is possibly undefined
// 140064491: variable 'v10' is possibly undefined
// 14012DB30: using guessed type int dword_14012DB30;
// 14012DF30: using guessed type __int64 qword_14012DF30;

//----- (0000000140064500) ----------------------------------------------------
LRESULT __fastcall sub_140064500(__int64 a1)
{
  BOOL v2; // eax

  v2 = *(_DWORD *)(a1 + 800) == 0;
  *(_DWORD *)(a1 + 800) = v2;
  if ( v2 )
    return sub_140064380(a1 - 16);
  SendMessageW(*(HWND *)(a1 + 40), 0x109Du, 0i64, 0i64);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 - 16) + 32i64))(
           a1 - 16,
           *(unsigned int *)(a1 + 688));
}

//----- (0000000140064560) ----------------------------------------------------
LRESULT __fastcall sub_140064560(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 800) = a2;
  if ( a2 )
    return sub_140064380(a1 - 16);
  SendMessageW(*(HWND *)(a1 + 40), 0x109Du, 0i64, 0i64);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 - 16) + 32i64))(
           a1 - 16,
           *(unsigned int *)(a1 + 688));
}

//----- (00000001400645B0) ----------------------------------------------------
void __fastcall sub_1400645B0(HWND a1, __int64 a2, UINT_PTR a3)
{
  KillTimer(a1, a3);
  SendMessageW(a1, 0x8033u, a3, 0i64);
}

//----- (00000001400645F0) ----------------------------------------------------
void __fastcall sub_1400645F0(__int64 a1, const WCHAR *a2)
{
  void **v2; // rax
  WCHAR *v5; // rbx

  v2 = *(void ***)(a1 + 920);
  v5 = (WCHAR *)*v2;
  if ( *v2 == v2 )
  {
LABEL_4:
    dword_14012DB2C = sub_14006E5B0(a1, a2);
  }
  else
  {
    while ( lstrcmpW(a2, v5 + 8) )
    {
      v5 = *(WCHAR **)v5;
      if ( v5 == *(WCHAR **)(a1 + 920) )
        goto LABEL_4;
    }
    dword_14012DD4C = 1;
    if ( v5 != *(WCHAR **)(a1 + 920) )
    {
      **((_QWORD **)v5 + 1) = *(_QWORD *)v5;
      *(_QWORD *)(*(_QWORD *)v5 + 8i64) = *((_QWORD *)v5 + 1);
      j_free(v5);
      --*(_QWORD *)(a1 + 928);
    }
  }
}
// 14012DB2C: using guessed type int dword_14012DB2C;
// 14012DD4C: using guessed type int dword_14012DD4C;

//----- (00000001400646B0) ----------------------------------------------------
void __fastcall sub_1400646B0(__int64 a1, const WCHAR *a2)
{
  void **v2; // rax
  WCHAR *v5; // rbx
  int v6; // eax

  v2 = *(void ***)(a1 + 920);
  v5 = (WCHAR *)*v2;
  if ( *v2 == v2 )
  {
LABEL_4:
    v6 = sub_14006E5B0(a1, a2);
    if ( v6 != -1 )
      sub_140068710(a1, v6);
  }
  else
  {
    while ( lstrcmpW(a2, v5 + 8) )
    {
      v5 = *(WCHAR **)v5;
      if ( v5 == *(WCHAR **)(a1 + 920) )
        goto LABEL_4;
    }
    if ( v5 != *(WCHAR **)(a1 + 920) )
    {
      **((_QWORD **)v5 + 1) = *(_QWORD *)v5;
      *(_QWORD *)(*(_QWORD *)v5 + 8i64) = *((_QWORD *)v5 + 1);
      j_free(v5);
      --*(_QWORD *)(a1 + 928);
    }
  }
}

//----- (0000000140064770) ----------------------------------------------------
void __fastcall sub_140064770(__int64 a1, int a2, const WCHAR *a3)
{
  int v3; // edx
  __int64 v6; // rdx
  __int64 v7; // r8
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  WCHAR pszPath[264]; // [rsp+20h] [rbp-228h] BYREF

  v3 = a2 - 4;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( *(_DWORD *)(a1 + 704) )
      {
        PathRemoveFileSpecW((LPWSTR)(a1 + 144));
        PathAppendW((LPWSTR)(a1 + 144), a3);
        SendMessageW(*(HWND *)(a1 + 48), 0x8011u, 0i64, 0i64);
      }
    }
  }
  else
  {
    v6 = 260i64;
    v7 = a1 + 144 - (_QWORD)pszPath;
    v8 = pszPath;
    while ( v6 != -2147483386 )
    {
      v9 = *(WCHAR *)((char *)v8 + v7);
      if ( !v9 )
        break;
      *v8++ = v9;
      if ( !--v6 )
      {
        --v8;
        break;
      }
    }
    *v8 = 0;
    PathStripPathW(pszPath);
    *(_DWORD *)(a1 + 704) = lstrcmpW(pszPath, a3) == 0;
  }
}
// 140064827: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140064890) ----------------------------------------------------
void __fastcall sub_140064890(__int64 a1, int a2, __int64 a3, int a4, int a5)
{
  UINT_PTR v6; // rbx
  __int64 v9; // r11
  __int64 v10; // rdi
  char *v11; // rcx
  __int16 v12; // ax
  __int64 v13; // rbx
  __int64 v14; // rdx
  char *v15; // r11
  __int64 v16; // rax
  char v17[520]; // [rsp+20h] [rbp-248h] BYREF
  int v18; // [rsp+228h] [rbp-40h]
  int v19; // [rsp+22Ch] [rbp-3Ch]

  v6 = a4;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
  SetTimer(*(HWND *)(a1 + 48), v6, 0xC8u, (TIMERPROC)sub_1400645B0);
  v9 = 260i64;
  v10 = a3 - (_QWORD)v17;
  v11 = v17;
  while ( v9 != -2147483386 )
  {
    v12 = *(_WORD *)&v11[v10];
    if ( !v12 )
      break;
    *(_WORD *)v11 = v12;
    v11 += 2;
    if ( !--v9 )
    {
      v11 -= 2;
      break;
    }
  }
  v13 = *(_QWORD *)(a1 + 880);
  v14 = *(_QWORD *)(v13 + 8);
  *(_WORD *)v11 = 0;
  v18 = a2;
  v19 = a5;
  v15 = sub_14002B540(v13, v14, v17);
  v16 = *(_QWORD *)(a1 + 888);
  if ( v16 == 0x7C1F07C1F07C1Ei64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 888) = v16 + 1;
  *(_QWORD *)(v13 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
}
// 140064926: conditional instruction was optimized away because r11.8!=0

//----- (00000001400649D0) ----------------------------------------------------
void __fastcall sub_1400649D0(_QWORD *a1, const WCHAR *a2)
{
  LPARAM v2; // r13
  char *v5; // r8
  __int64 v6; // rdi
  WCHAR *v7; // rcx
  signed __int64 v8; // r8
  __int64 v9; // rdx
  WCHAR v10; // ax
  int v11; // ebx
  WCHAR *v12; // r8
  _WORD *v13; // rcx
  __int64 v14; // rdx
  _WORD *v15; // rdx
  HWND v16; // rcx
  int v17; // eax
  int v18; // ebx
  WCHAR *v19; // rax
  HWND v20; // rcx
  const WCHAR *v21; // r9
  __int64 v22; // r8
  _WORD *v23; // rdx
  _WORD *v24; // rcx
  LPCITEMIDLIST pidl; // [rsp+30h] [rbp-D0h] BYREF
  LPVOID pv; // [rsp+38h] [rbp-C8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp-C0h] BYREF
  void *ppv; // [rsp+48h] [rbp-B8h] BYREF
  _DWORD v29[6]; // [rsp+50h] [rbp-B0h] BYREF
  WCHAR *v30; // [rsp+68h] [rbp-98h]
  int iIcon; // [rsp+74h] [rbp-8Ch]
  LPARAM lParam[6]; // [rsp+A0h] [rbp-60h] BYREF
  SHFILEINFOW psfi; // [rsp+D0h] [rbp-30h] BYREF
  WCHAR pszPath[264]; // [rsp+390h] [rbp+290h] BYREF
  WCHAR pszBuf[264]; // [rsp+5A0h] [rbp+4A0h] BYREF

  v2 = dword_14012DB2C;
  ppv = 0i64;
  pidl = 0i64;
  ppidlLast = 0i64;
  if ( dword_14012DB2C != -1 )
  {
    v5 = (char *)(a1 + 20);
    v6 = 260i64;
    v7 = pszPath;
    v8 = v5 - (char *)pszPath;
    v9 = 260i64;
    while ( v9 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v7 + v8);
      if ( !v10 )
        break;
      *v7++ = v10;
      if ( !--v9 )
      {
        --v7;
        break;
      }
    }
    *v7 = 0;
    PathAppendW(pszPath, a2);
    if ( (int)sub_14007F810((__int64)pszPath, (__int64)&pidl) < 0 )
    {
      v21 = a2;
      v22 = 260i64;
      v23 = (_WORD *)(568 * v2 + a1[12] + 8);
      while ( v22 != -2147483386 && *v21 )
      {
        *v23++ = *v21++;
        if ( !--v22 )
        {
          --v23;
          break;
        }
      }
      *v23 = 0;
      v24 = (_WORD *)(592 * v2 + a1[11] + 44);
      while ( v6 != -2147483386 && *a2 )
      {
        *v24++ = *a2++;
        if ( !--v6 )
        {
          --v24;
          break;
        }
      }
      *v24 = 0;
    }
    else
    {
      if ( SHBindToParent(pidl, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        pv = 0i64;
        v11 = sub_14007F810((__int64)pszPath, (__int64)&pv);
        if ( v11 >= 0 )
          v11 = sub_14007E270((LPCITEMIDLIST)pv, pszBuf, 0x8001u);
        CoTaskMemFree(pv);
        if ( v11 >= 0 )
        {
          *(_QWORD *)(568 * v2 + a1[12]) = ILClone(ppidlLast);
          v12 = pszBuf;
          v13 = (_WORD *)(568 * v2 + a1[12] + 8);
          v14 = 260i64;
          while ( v14 != -2147483386 && *v12 )
          {
            *v13++ = *v12++;
            if ( !--v14 )
            {
              --v13;
              break;
            }
          }
          *v13 = 0;
          v15 = (_WORD *)(592 * v2 + a1[11] + 44);
          while ( v6 != -2147483386 && *a2 )
          {
            *v15++ = *a2++;
            if ( !--v6 )
            {
              --v15;
              break;
            }
          }
          *v15 = 0;
          if ( SHGetFileInfoW(&pidl->mkid.cb, 0, &psfi, 0x2B8u, 0x148u) )
          {
            v16 = (HWND)a1[7];
            LODWORD(lParam[0]) = 1;
            lParam[2] = v2;
            v17 = SendMessageW(v16, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam);
            v18 = v17;
            if ( v17 != -1 )
            {
              v29[0] = 11;
              iIcon = psfi.iIcon;
              v29[1] = v17;
              v29[2] = 0;
              v19 = sub_140068810((__int64)a1, v2);
              v20 = (HWND)a1[7];
              v30 = v19;
              v29[4] = 3840;
              v29[3] = (psfi.iIcon >> 16) & 0xFFFFFF00;
              SendMessageW(v20, 0x104Cu, 0i64, (LPARAM)v29);
              if ( sub_140068D50((__int64)a1, v2) )
                sub_14006F330((__int64)a1, v18, v2);
            }
            DestroyIcon(psfi.hIcon);
          }
        }
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
      CoTaskMemFree((LPVOID)pidl);
    }
  }
}
// 140064A77: conditional instruction was optimized away because rdx.8!=0
// 140064B8A: conditional instruction was optimized away because rdx.8!=0
// 140064BD9: conditional instruction was optimized away because rdi.8!=0
// 140064D2A: conditional instruction was optimized away because r8.8!=0
// 140064D79: conditional instruction was optimized away because rdi.8!=0
// 14012DB2C: using guessed type int dword_14012DB2C;

//----- (0000000140064DB0) ----------------------------------------------------
int __fastcall sub_140064DB0(__int64 a1, const WCHAR *a2)
{
  __int64 v4; // rax
  unsigned int v5; // esi
  WPARAM v6; // rbp
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx
  HWND v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rbx
  int v12; // eax
  HWND v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rdx
  WCHAR *v16; // rcx
  WCHAR v17; // ax
  HANDLE FirstFileW; // r12
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 v21; // rax
  HWND v22; // rcx
  bool v23; // zf
  _QWORD **v24; // rax
  _QWORD *v25; // rax
  _QWORD *v26; // rbx
  __int64 v28; // [rsp+20h] [rbp-2F8h]
  __int64 v29; // [rsp+20h] [rbp-2F8h]
  __int64 v30; // [rsp+20h] [rbp-2F8h]
  __int64 v31; // [rsp+20h] [rbp-2F8h]
  LPARAM v32; // [rsp+30h] [rbp-2E8h] BYREF
  int v33; // [rsp+3Ch] [rbp-2DCh]
  int v34; // [rsp+40h] [rbp-2D8h]
  _DWORD lParam[20]; // [rsp+80h] [rbp-298h] BYREF
  WCHAR pszPath[264]; // [rsp+D0h] [rbp-248h] BYREF

  LODWORD(v4) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 360i64))(a1 + 16);
  v5 = 0;
  v6 = (int)v4;
  if ( (_DWORD)v4 == -1 )
  {
    v7 = *(_QWORD **)(a1 + 944);
    v8 = (_QWORD *)*v7;
    if ( (_QWORD *)*v7 == v7 )
      return v4;
    while ( 1 )
    {
      LODWORD(v4) = lstrcmpW((LPCWSTR)(592i64 * *((int *)v8 + 5) + *(_QWORD *)(a1 + 88) + 44), a2);
      if ( !(_DWORD)v4 )
        break;
      v8 = (_QWORD *)*v8;
      if ( v8 == *(_QWORD **)(a1 + 944) )
        return v4;
    }
    LODWORD(v4) = *((_DWORD *)v8 + 5);
  }
  else
  {
    v9 = *(HWND *)(a1 + 56);
    lParam[0] = 4;
    lParam[1] = v4;
    lParam[2] = 0;
    LODWORD(v4) = SendMessageW(v9, 0x104Bu, 0i64, (LPARAM)lParam);
    if ( !(_DWORD)v4 )
      return v4;
    LODWORD(v4) = lParam[10];
  }
  if ( (_DWORD)v4 != -1 )
  {
    v10 = *(_QWORD *)(a1 + 88);
    v11 = 592i64 * (int)v4;
    LODWORD(v28) = *(_DWORD *)(v11 + v10 + 32);
    v12 = *(_DWORD *)(v11 + v10 + 28);
    v13 = *(HWND *)(a1 + 56);
    HIDWORD(v28) = v12;
    *(_QWORD *)(a1 + 680) -= v28;
    if ( (unsigned int)SendMessageW(v13, 0x102Cu, v6, 2i64) == 2 )
    {
      v14 = *(_QWORD *)(a1 + 88);
      LODWORD(v29) = *(_DWORD *)(v11 + v14 + 32);
      HIDWORD(v29) = *(_DWORD *)(v11 + v14 + 28);
      *(_QWORD *)(a1 + 688) -= v29;
    }
    v15 = 260i64;
    v16 = pszPath;
    while ( v15 != -2147483386 )
    {
      v17 = *(WCHAR *)((char *)v16 + a1 + 160 - (_QWORD)pszPath);
      if ( !v17 )
        break;
      *v16++ = v17;
      if ( !--v15 )
      {
        --v16;
        break;
      }
    }
    *v16 = 0;
    PathAppendW(pszPath, a2);
    FirstFileW = FindFirstFileW(pszPath, (LPWIN32_FIND_DATAW)(v11 + *(_QWORD *)(a1 + 88)));
    if ( FirstFileW == (HANDLE)-1i64 )
    {
      *(_DWORD *)(v11 + *(_QWORD *)(a1 + 88) + 32) = 0;
      v4 = *(_QWORD *)(a1 + 88);
      *(_DWORD *)(v11 + v4 + 28) = 0;
    }
    else
    {
      v19 = *(_QWORD *)(a1 + 88);
      LODWORD(v30) = *(_DWORD *)(v11 + v19 + 32);
      HIDWORD(v30) = *(_DWORD *)(v11 + v19 + 28);
      *(_QWORD *)(a1 + 680) += v30;
      if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 56), 0x102Cu, v6, 2i64) == 2 )
      {
        v20 = *(_QWORD *)(a1 + 88);
        LODWORD(v31) = *(_DWORD *)(v11 + v20 + 32);
        HIDWORD(v31) = *(_DWORD *)(v11 + v20 + 28);
        *(_QWORD *)(a1 + 688) += v31;
      }
      v21 = *(_QWORD *)(a1 + 88);
      v22 = *(HWND *)(a1 + 56);
      v34 = 4;
      v23 = (*(_BYTE *)(v11 + v21) & 2) == 0;
      v33 = 4;
      if ( v23 )
        v33 = 0;
      SendMessageW(v22, 0x102Bu, v6, (LPARAM)&v32);
      if ( *(_DWORD *)(a1 + 708) == 4 )
      {
        v24 = *(_QWORD ***)(a1 + 1184);
        if ( v24 )
        {
          v25 = *v24;
          v26 = (_QWORD *)*v25;
          if ( (_QWORD *)*v25 != v25 )
          {
            do
            {
              if ( *((_DWORD *)v26 + 5) )
                sub_14006D410(a1, *((_DWORD *)v26 + 4), v6, v5++);
              v26 = (_QWORD *)*v26;
            }
            while ( v26 != **(_QWORD ***)(a1 + 1184) );
          }
        }
      }
      LODWORD(v4) = FindClose(FirstFileW);
    }
  }
  return v4;
}
// 140064F38: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400650A0) ----------------------------------------------------
void __fastcall sub_1400650A0(ULONG_PTR dwData, LPCWSTR pszMore)
{
  __int64 v3; // rdi
  ULONG_PTR v5; // rcx
  int v6; // ebx
  __int64 v7; // r8
  WCHAR *v8; // rdx
  WCHAR v9; // ax
  __int64 v10; // r8
  int v11; // er13
  const WCHAR **v12; // rax
  const WCHAR *v13; // rbx
  int v14; // ebx
  int v15; // eax
  int v16; // er9
  int v17; // er8
  int v18; // edx
  int v19; // eax
  char *v20; // rcx
  signed __int64 v21; // r12
  __int16 v22; // ax
  __int64 v23; // rbx
  char *v24; // r11
  __int64 v25; // rax
  LPCITEMIDLIST ppidlLast; // [rsp+20h] [rbp-E0h] BYREF
  void *ppv; // [rsp+28h] [rbp-D8h] BYREF
  void *pidl[2]; // [rsp+30h] [rbp-D0h] BYREF
  STRRET pstr; // [rsp+40h] [rbp-C0h] BYREF
  char v30[528]; // [rsp+150h] [rbp+50h] BYREF
  WCHAR pszBuf[264]; // [rsp+360h] [rbp+260h] BYREF
  WCHAR pszPath[264]; // [rsp+570h] [rbp+470h] BYREF

  v3 = 260i64;
  ppv = 0i64;
  pidl[0] = 0i64;
  ppidlLast = 0i64;
  v5 = dwData + 160 - (_QWORD)pszPath;
  v6 = 0;
  v7 = 260i64;
  v8 = pszPath;
  while ( v7 != -2147483386 )
  {
    v9 = *(WCHAR *)((char *)v8 + v5);
    if ( !v9 )
      break;
    *v8++ = v9;
    if ( !--v7 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathAppendW(pszPath, pszMore);
  if ( (int)sub_14007F810((__int64)pszPath, (__int64)pidl) < 0 )
    goto LABEL_24;
  if ( SHBindToParent((LPCITEMIDLIST)pidl[0], &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
  {
    v10 = 1i64;
    if ( !*(_DWORD *)(dwData + 712) )
      v10 = 32769i64;
    if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
           ppv,
           ppidlLast,
           v10,
           &pstr) >= 0 )
    {
      StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
      v11 = 0;
      if ( *(_QWORD *)(dwData + 1400) )
      {
        v12 = *(const WCHAR ***)(dwData + 1392);
        v13 = *v12;
        if ( *v12 != (const WCHAR *)v12 )
        {
          while ( lstrcmpW(pszBuf, v13 + 8) )
          {
            v13 = *(const WCHAR **)v13;
            if ( v13 == *(const WCHAR **)(dwData + 1392) )
              goto LABEL_17;
          }
          v11 = 1;
        }
      }
LABEL_17:
      if ( !*(_DWORD *)(dwData + 848) || v11 )
      {
        v19 = sub_14002B130(dwData, *(const ITEMIDLIST **)(dwData + 136), ppidlLast, pszBuf);
        v16 = 0;
        v18 = -1;
        v17 = v19;
      }
      else
      {
        v14 = sub_14002B130(dwData, *(const ITEMIDLIST **)(dwData + 136), ppidlLast, pszBuf);
        v15 = sub_140070270(dwData, v14);
        v16 = 1;
        v17 = v14;
        v18 = v15;
      }
      sub_14002B060(dwData, v18, v17, v16);
      sub_14002AB60(dwData, *(_DWORD *)(dwData + 816));
      v6 = 1;
    }
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  CoTaskMemFree(pidl[0]);
  if ( !v6 )
  {
LABEL_24:
    v20 = v30;
    v21 = (char *)pszMore - v30;
    while ( v3 != -2147483386 )
    {
      v22 = *(_WORD *)&v20[v21];
      if ( !v22 )
        break;
      *(_WORD *)v20 = v22;
      v20 += 2;
      if ( !--v3 )
      {
        v20 -= 2;
        break;
      }
    }
    v23 = *(_QWORD *)(dwData + 920);
    *(_WORD *)v20 = 0;
    v24 = sub_140024790(v23, *(_QWORD *)(v23 + 8), v30);
    v25 = *(_QWORD *)(dwData + 928);
    if ( v25 == 0x7E07E07E07E07Di64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(dwData + 928) = v25 + 1;
    *(_QWORD *)(v23 + 8) = v24;
    **((_QWORD **)v24 + 1) = v24;
  }
}
// 140065136: conditional instruction was optimized away because r8.8!=0
// 140065307: conditional instruction was optimized away because rdi.8!=0
// 1400650A0: using guessed type LPCITEMIDLIST pidl[2];

//----- (00000001400653A0) ----------------------------------------------------
void __fastcall sub_1400653A0(_QWORD *a1, const WCHAR *a2)
{
  if ( dword_14012DD4C )
  {
    sub_1400650A0((ULONG_PTR)a1, a2);
    dword_14012DD4C = 0;
  }
  else
  {
    sub_1400649D0(a1, a2);
  }
}
// 14012DD4C: using guessed type int dword_14012DD4C;

//----- (00000001400653D0) ----------------------------------------------------
void __fastcall sub_1400653D0(__int64 a1)
{
  int v2; // ebp
  _QWORD *v3; // rdi
  _QWORD *i; // rbx
  _QWORD *v5; // rcx
  _QWORD **v6; // rax
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx
  void **v9; // rax
  int v10; // er12
  char *v11; // rbx
  char *v12; // rdx
  int v13; // eax
  HWND v14; // rcx
  WPARAM v15; // rdi
  HWND v16; // rcx
  char *v17; // rdi
  LPARAM lParam; // [rsp+20h] [rbp-298h] BYREF
  int v19; // [rsp+2Ch] [rbp-28Ch]
  int v20; // [rsp+30h] [rbp-288h]
  WCHAR pszMore[260]; // [rsp+70h] [rbp-248h] BYREF
  int v22; // [rsp+278h] [rbp-40h]
  int v23; // [rsp+27Ch] [rbp-3Ch]

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
  v2 = *(_DWORD *)(a1 + 956);
  SendMessageW(*(HWND *)(a1 + 40), 0xBu, 0i64, 0i64);
  v3 = *(_QWORD **)(a1 + 880);
  for ( i = (_QWORD *)*v3; i != v3; i = (_QWORD *)*i )
  {
    memmove(pszMore, i + 2, 0x210ui64);
    if ( v23 == *(_DWORD *)(a1 + 788) )
    {
      switch ( v22 )
      {
        case 1:
          sub_1400650A0(a1 - 16, pszMore);
          break;
        case 2:
          sub_1400646B0(a1 - 16, pszMore);
          break;
        case 3:
          sub_140064DB0(a1 - 16, pszMore);
          break;
        case 4:
          sub_1400645F0(a1 - 16, pszMore);
          break;
        case 5:
          v5 = (_QWORD *)(a1 - 16);
          if ( dword_14012DD4C )
          {
            sub_1400650A0((ULONG_PTR)v5, pszMore);
            dword_14012DD4C = 0;
          }
          else
          {
            sub_1400649D0(v5, pszMore);
          }
          break;
      }
    }
  }
  SendMessageW(*(HWND *)(a1 + 40), 0xBu, 1ui64, 0i64);
  if ( *(_DWORD *)(a1 + 784) != -1 )
  {
    if ( !(unsigned int)SendMessageW(*(HWND *)(a1 + 40), 0x10B6u, *(int *)(a1 + 784), 0i64) )
      SendMessageW(*(HWND *)(a1 + 40), 0x1013u, *(int *)(a1 + 784), 1i64);
    *(_DWORD *)(a1 + 784) = -1;
  }
  SendMessageW(*(HWND *)(a1 + 48), 0x80CCu, *(int *)(a1 + 836), 0i64);
  if ( v2 && !*(_DWORD *)(a1 + 956) )
    SendMessageW(*(HWND *)(a1 + 48), 0x80C8u, 0i64, *(int *)(a1 + 968));
  v6 = *(_QWORD ***)(a1 + 880);
  v7 = *v6;
  *v6 = v6;
  *(_QWORD *)(*(_QWORD *)(a1 + 880) + 8i64) = *(_QWORD *)(a1 + 880);
  *(_QWORD *)(a1 + 888) = 0i64;
  if ( v7 != *(_QWORD **)(a1 + 880) )
  {
    do
    {
      v8 = (_QWORD *)*v7;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != *(_QWORD **)(a1 + 880) );
  }
  v9 = *(void ***)(a1 + 976);
  v10 = 0;
  v11 = (char *)*v9;
  if ( *v9 != v9 )
  {
    do
    {
      if ( *((_QWORD *)v11 + 5) < 8ui64 )
        v12 = v11 + 16;
      else
        v12 = (char *)*((_QWORD *)v11 + 2);
      v13 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 360i64))(a1, v12);
      if ( v13 == -1 )
      {
        v11 = *(char **)v11;
      }
      else
      {
        v14 = *(HWND *)(a1 + 40);
        v15 = v13;
        v20 = 2;
        v19 = 2;
        SendMessageW(v14, 0x102Bu, v13, (LPARAM)&lParam);
        if ( !v10 )
        {
          v16 = *(HWND *)(a1 + 40);
          v20 = 1;
          v19 = 1;
          SendMessageW(v16, 0x102Bu, v15, (LPARAM)&lParam);
          SendMessageW(*(HWND *)(a1 + 40), 0x1013u, v15, 1i64);
          v10 = 1;
        }
        v17 = *(char **)v11;
        if ( v11 != *(char **)(a1 + 976) )
        {
          **((_QWORD **)v11 + 1) = v17;
          *(_QWORD *)(*(_QWORD *)v11 + 8i64) = *((_QWORD *)v11 + 1);
          if ( *((_QWORD *)v11 + 5) >= 8ui64 )
            j_free(*((void **)v11 + 2));
          *((_QWORD *)v11 + 5) = 7i64;
          *((_QWORD *)v11 + 4) = 0i64;
          *((_WORD *)v11 + 8) = 0;
          j_free(v11);
          --*(_QWORD *)(a1 + 984);
        }
        v11 = v17;
      }
    }
    while ( v11 != *(char **)(a1 + 976) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
}
// 14012DD4C: using guessed type int dword_14012DD4C;

//----- (0000000140065730) ----------------------------------------------------
__int64 __fastcall sub_140065730(__int64 a1, int a2, int a3)
{
  ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a2 + *(_QWORD *)(a1 + 96)));
  ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a3 + *(_QWORD *)(a1 + 96)));
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  return 0i64;
}

//----- (00000001400657A0) ----------------------------------------------------
__int64 __fastcall sub_1400657A0(int a1, int a2, __int64 a3)
{
  ILCombine(*(LPCITEMIDLIST *)(a3 + 136), *(LPCITEMIDLIST *)(568i64 * a1 + *(_QWORD *)(a3 + 96)));
  ILCombine(*(LPCITEMIDLIST *)(a3 + 136), *(LPCITEMIDLIST *)(568i64 * a2 + *(_QWORD *)(a3 + 96)));
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a3 + 80i64))(a3);
  return 0i64;
}

//----- (0000000140065810) ----------------------------------------------------
__int64 __fastcall sub_140065810(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // r9
  unsigned int v8; // ebx
  int v9; // eax
  LPITEMIDLIST v11; // rdi
  LPITEMIDLIST v12; // rbx
  SHFILEINFOW v13; // [rsp+30h] [rbp-5A8h] BYREF
  SHFILEINFOW psfi; // [rsp+2F0h] [rbp-2E8h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = a3;
  v6 = v3 + 592i64 * a2;
  v7 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v6 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v7 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v8 = StrCmpIW((PCWSTR)(v6 + 44), (PCWSTR)(v7 + 44));
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  }
  else
  {
    if ( (*(_DWORD *)v7 & 0x10) == 16 )
      return 1i64;
    v11 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a2 + *(_QWORD *)(a1 + 96)));
    v12 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568 * v5 + *(_QWORD *)(a1 + 96)));
    SHGetFileInfoW(&v11->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
    SHGetFileInfoW(&v12->mkid.cb, 0, &v13, 0x2B8u, 0x408u);
    v8 = lstrcmpW(psfi.szTypeName, v13.szTypeName);
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  }
  if ( !v9 )
    return -v8;
  return v8;
}

//----- (00000001400659B0) ----------------------------------------------------
__int64 __fastcall sub_1400659B0(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // r9
  unsigned int v8; // ebx
  int v9; // eax
  LPITEMIDLIST v11; // rdi
  LPITEMIDLIST v12; // rbx
  SHFILEINFOW v13; // [rsp+30h] [rbp-5A8h] BYREF
  SHFILEINFOW psfi; // [rsp+2F0h] [rbp-2E8h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = a3;
  v6 = v3 + 592i64 * a2;
  v7 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v6 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v7 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v8 = StrCmpIW((PCWSTR)(v6 + 44), (PCWSTR)(v7 + 44));
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  }
  else
  {
    if ( (*(_DWORD *)v7 & 0x10) == 16 )
      return 1i64;
    v11 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a2 + *(_QWORD *)(a1 + 96)));
    v12 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568 * v5 + *(_QWORD *)(a1 + 96)));
    SHGetFileInfoW(&v11->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
    SHGetFileInfoW(&v12->mkid.cb, 0, &v13, 0x2B8u, 0x408u);
    v8 = lstrcmpW(psfi.szTypeName, v13.szTypeName);
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  }
  if ( !v9 )
    return -v8;
  return v8;
}

//----- (0000000140065B50) ----------------------------------------------------
__int64 __fastcall sub_140065B50(_QWORD *a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // r9
  __int64 v6; // r10
  unsigned int v7; // ebx

  v3 = a1[11];
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
    {
      v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
      if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
        return -v7;
      return v7;
    }
    else
    {
      return 0xFFFFFFFFi64;
    }
  }
  else if ( (*(_DWORD *)v6 & 0x10) == 16 )
  {
    return 1i64;
  }
  else
  {
    (*(void (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1);
    return 0i64;
  }
}

//----- (0000000140065C20) ----------------------------------------------------
__int64 __fastcall sub_140065C20(_QWORD *a1, int a2, int a3)
{
  BOOL v5; // ebx
  BOOL v6; // eax
  unsigned int v7; // ebx
  DWORD v8; // ebx
  BYTE *v9; // rsi
  DWORD v10; // ebx
  BYTE *v11; // rdi
  DWORD cbBuf; // [rsp+50h] [rbp+8h] BYREF
  HANDLE phPrinter; // [rsp+58h] [rbp+10h] BYREF
  HANDLE hPrinter; // [rsp+60h] [rbp+18h] BYREF

  v5 = OpenPrinterW((LPWSTR)(568i64 * a2 + a1[12] + 8), &phPrinter, 0i64);
  v6 = OpenPrinterW((LPWSTR)(568i64 * a3 + a1[12] + 8), &hPrinter, 0i64);
  if ( v5 )
  {
    if ( v6 )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = cbBuf;
      v9 = (BYTE *)malloc(cbBuf);
      GetPrinterW(phPrinter, 2u, v9, v8, &cbBuf);
      GetPrinterW(hPrinter, 2u, 0i64, 0, &cbBuf);
      v10 = cbBuf;
      v11 = (BYTE *)malloc(cbBuf);
      GetPrinterW(hPrinter, 2u, v11, v10, &cbBuf);
      v7 = *((_DWORD *)v9 + 32) < *((_DWORD *)v11 + 32);
      free(v9);
      free(v11);
    }
    else
    {
      v7 = -1;
    }
  }
  else
  {
    v7 = v6;
  }
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v7;
  return v7;
}

//----- (0000000140065DB0) ----------------------------------------------------
__int64 __fastcall sub_140065DB0(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // edi
  __int64 v5; // rdx
  const ITEMIDLIST *v7; // rcx
  ITEMIDLIST *v9; // rbx
  __int64 v10; // rdx
  const ITEMIDLIST *v11; // rcx
  ITEMIDLIST *v12; // rbx
  BOOL IsRootW; // eax
  LPITEMIDLIST v15; // rdi
  LPITEMIDLIST v16; // rbx
  unsigned int v17; // esi
  void *ppv; // [rsp+30h] [rbp-D0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+38h] [rbp-C8h] BYREF
  STRRET pstr; // [rsp+40h] [rbp-C0h] BYREF
  SHFILEINFOW psfi; // [rsp+150h] [rbp+50h] BYREF
  SHFILEINFOW v22; // [rsp+410h] [rbp+310h] BYREF
  WCHAR pszBuf[264]; // [rsp+6D0h] [rbp+5D0h] BYREF
  WCHAR pszPath[264]; // [rsp+8E0h] [rbp+7E0h] BYREF

  v4 = a2;
  v5 = *(_QWORD *)(a1 + 96);
  v7 = *(const ITEMIDLIST **)(a1 + 136);
  ppv = 0i64;
  ppidlLast = 0i64;
  v9 = ILCombine(v7, *(LPCITEMIDLIST *)(568 * a2 + v5));
  SHBindToParent(v9, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v9);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  v10 = *(_QWORD *)(a1 + 96);
  v11 = *(const ITEMIDLIST **)(a1 + 136);
  ppv = 0i64;
  v12 = ILCombine(v11, *(LPCITEMIDLIST *)(568 * a3 + v10));
  SHBindToParent(v12, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(v12);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  ppv = 0i64;
  LODWORD(v12) = PathIsRootW(pszBuf);
  IsRootW = PathIsRootW(pszPath);
  if ( (_DWORD)v12 )
  {
    if ( !IsRootW )
      return 0xFFFFFFFFi64;
  }
  else if ( IsRootW )
  {
    return 1i64;
  }
  v15 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * v4 + *(_QWORD *)(a1 + 96)));
  v16 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * (int)a3 + *(_QWORD *)(a1 + 96)));
  SHGetFileInfoW(&v15->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
  SHGetFileInfoW(&v16->mkid.cb, 0, &v22, 0x2B8u, 0x408u);
  v17 = lstrcmpW(psfi.szTypeName, v22.szTypeName);
  CoTaskMemFree(v15);
  CoTaskMemFree(v16);
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v17;
  return v17;
}

//----- (0000000140066060) ----------------------------------------------------
__int64 __fastcall sub_140066060(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx
  unsigned int v5; // esi
  const ITEMIDLIST *v7; // rcx
  ITEMIDLIST *v9; // rbx
  __int64 v10; // rdx
  const ITEMIDLIST *v11; // rcx
  ITEMIDLIST *v12; // rbx
  BOOL IsRootW; // eax
  BOOL VolumeInformationW; // ebx
  void *ppv; // [rsp+40h] [rbp-C0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+48h] [rbp-B8h] BYREF
  STRRET pstr; // [rsp+50h] [rbp-B0h] BYREF
  WCHAR FileSystemNameBuffer[32]; // [rsp+160h] [rbp+60h] BYREF
  WCHAR String2[32]; // [rsp+1A0h] [rbp+A0h] BYREF
  WCHAR pszBuf[264]; // [rsp+1E0h] [rbp+E0h] BYREF
  WCHAR pszPath[264]; // [rsp+3F0h] [rbp+2F0h] BYREF

  v4 = a1[12];
  v5 = 0;
  v7 = (const ITEMIDLIST *)a1[17];
  ppidlLast = 0i64;
  ppv = 0i64;
  v9 = ILCombine(v7, *(LPCITEMIDLIST *)(568 * a2 + v4));
  SHBindToParent(v9, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v9);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  v10 = a1[12];
  v11 = (const ITEMIDLIST *)a1[17];
  ppv = 0i64;
  v12 = ILCombine(v11, *(LPCITEMIDLIST *)(568 * a3 + v10));
  SHBindToParent(v12, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(v12);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  ppv = 0i64;
  LODWORD(v12) = PathIsRootW(pszBuf);
  IsRootW = PathIsRootW(pszPath);
  if ( !(_DWORD)v12 )
    goto LABEL_8;
  if ( !IsRootW )
  {
    v5 = -1;
    goto LABEL_10;
  }
  VolumeInformationW = GetVolumeInformationW(pszBuf, 0i64, 0, 0i64, 0i64, 0i64, FileSystemNameBuffer, 0x20u);
  IsRootW = GetVolumeInformationW(pszPath, 0i64, 0, 0i64, 0i64, 0i64, String2, 0x20u);
  if ( VolumeInformationW )
  {
    if ( IsRootW )
      v5 = lstrcmpW(FileSystemNameBuffer, String2);
    else
      v5 = -1;
  }
  else
  {
LABEL_8:
    if ( IsRootW )
      v5 = 1;
  }
LABEL_10:
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v5;
  return v5;
}

//----- (00000001400662D0) ----------------------------------------------------
__int64 __fastcall sub_1400662D0(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rsi
  __int64 v6; // rdi
  int v7; // eax
  const WCHAR *ExtensionW; // rbx
  const WCHAR *v10; // rax
  unsigned int v11; // ebx
  __int16 pszDest[264]; // [rsp+20h] [rbp-448h] BYREF
  __int16 v13[264]; // [rsp+230h] [rbp-238h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW((LPWSTR)pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW((LPWSTR)v13, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    ExtensionW = PathFindExtensionW((LPCWSTR)(v5 + 44));
    v10 = PathFindExtensionW((LPCWSTR)(v6 + 44));
    v7 = lstrcmpW(ExtensionW, v10);
  }
  v11 = v7;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v11;
  return v11;
}
// 1400662D0: using guessed type WCHAR pszDest[264];
// 1400662D0: using guessed type WCHAR var_238[264];

//----- (0000000140066410) ----------------------------------------------------
__int64 __fastcall sub_140066410(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v5; // r10
  __int64 v6; // r11
  int v7; // eax
  unsigned int v9; // ebx

  v3 = a1[11];
  v5 = v3 + 592i64 * (int)a2;
  v6 = v3 + 592i64 * (int)a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    v7 = lstrcmpW((LPCWSTR)(592 * a2 + a1[11] + 564), (LPCWSTR)(592 * a3 + a1[11] + 564));
  }
  v9 = v7;
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v9;
  return v9;
}

//----- (0000000140066500) ----------------------------------------------------
__int64 __fastcall sub_140066500(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  return 0i64;
}

//----- (0000000140066520) ----------------------------------------------------
__int64 __fastcall sub_140066520(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  return 0i64;
}

//----- (0000000140066540) ----------------------------------------------------
__int64 __fastcall sub_140066540(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v5; // rdx
  unsigned int v6; // esi
  __int64 v7; // rbx
  const ITEMIDLIST *v8; // rcx
  ITEMIDLIST *v11; // r12
  ITEMIDLIST *v12; // rdi
  BOOL IsRootW; // eax
  ULARGE_INTEGER v15; // rax
  ULARGE_INTEGER v16; // rcx
  LPCITEMIDLIST pidl; // [rsp+20h] [rbp-E0h] BYREF
  void *v18; // [rsp+28h] [rbp-D8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+30h] [rbp-D0h] BYREF
  void *ppv; // [rsp+38h] [rbp-C8h] BYREF
  ULARGE_INTEGER v21; // [rsp+40h] [rbp-C0h] BYREF
  ULARGE_INTEGER v22; // [rsp+48h] [rbp-B8h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+50h] [rbp-B0h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [rsp+58h] [rbp-A8h] BYREF
  STRRET pstr; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR pszBuf[264]; // [rsp+170h] [rbp+70h] BYREF
  WCHAR pszPath[264]; // [rsp+380h] [rbp+280h] BYREF

  v5 = *(_QWORD *)(a1 + 96);
  v6 = 0;
  v7 = a1;
  v8 = *(const ITEMIDLIST **)(a1 + 136);
  ppv = 0i64;
  v18 = 0i64;
  ppidlLast = 0i64;
  pidl = 0i64;
  v11 = ILCombine(v8, *(LPCITEMIDLIST *)(568 * a2 + v5));
  SHBindToParent(v11, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  v12 = ILCombine(*(LPCITEMIDLIST *)(v7 + 136), *(LPCITEMIDLIST *)(568 * a3 + *(_QWORD *)(v7 + 96)));
  SHBindToParent(v12, &stru_1400E3FB0, &v18, &pidl);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)v18 + 88i64))(
    v18,
    pidl,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, pidl, pszPath, 0x104u);
  LODWORD(v7) = PathIsRootW(pszBuf);
  IsRootW = PathIsRootW(pszPath);
  if ( (_DWORD)v7 )
  {
    if ( !IsRootW )
      return 0xFFFFFFFFi64;
    GetDiskFreeSpaceExW(pszBuf, 0i64, &TotalNumberOfBytes, &TotalNumberOfFreeBytes);
    GetDiskFreeSpaceExW(pszPath, 0i64, &v22, &v21);
    CoTaskMemFree(v12);
    CoTaskMemFree(v11);
    (*(void (__fastcall **)(void *))(*(_QWORD *)v18 + 16i64))(v18);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    if ( a4 )
    {
      v15 = TotalNumberOfBytes;
      v16 = v22;
    }
    else
    {
      v15 = TotalNumberOfFreeBytes;
      v16 = v21;
    }
    if ( v15.QuadPart != v16.QuadPart )
    {
      v6 = -1;
      if ( v15.QuadPart > v16.QuadPart )
        return 1;
    }
  }
  else
  {
    LOBYTE(v6) = IsRootW;
  }
  return v6;
}

//----- (0000000140066780) ----------------------------------------------------
__int64 __fastcall sub_140066780(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // r10
  unsigned int v5; // ebx
  __int64 v7; // rsi
  __int64 v8; // r8
  int v9; // er9
  const FILETIME *v10; // rdx
  const FILETIME *v11; // rcx

  v4 = a1[11];
  v5 = 0;
  v7 = 592 * a2;
  v8 = 592 * a3;
  if ( (*(_DWORD *)(v4 + 592 * a2) & 0x10) == 16 )
  {
    if ( (*(_DWORD *)(v8 + v4) & 0x10) != 16 )
      return 0xFFFFFFFFi64;
  }
  else if ( (*(_DWORD *)(v8 + v4) & 0x10) == 16 )
  {
    return 1i64;
  }
  if ( !a4 )
  {
    v11 = (const FILETIME *)(v4 + v7 + 4);
    v10 = (const FILETIME *)(v4 + v8 + 4);
    goto LABEL_12;
  }
  v9 = a4 - 1;
  if ( !v9 )
  {
    v10 = (const FILETIME *)(v4 + v8 + 20);
    v11 = (const FILETIME *)(v4 + v7 + 20);
    goto LABEL_12;
  }
  if ( v9 == 1 )
  {
    v10 = (const FILETIME *)(v4 + v8 + 12);
    v11 = (const FILETIME *)(v4 + v7 + 12);
LABEL_12:
    v5 = CompareFileTime(v11, v10);
  }
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v5;
  return v5;
}

//----- (0000000140066860) ----------------------------------------------------
__int64 __fastcall sub_140066860(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  return 0i64;
}

//----- (0000000140066880) ----------------------------------------------------
__int64 __fastcall sub_140066880(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
  return 0i64;
}

//----- (00000001400668A0) ----------------------------------------------------
__int64 __fastcall sub_1400668A0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v5; // r8
  unsigned int v7; // ebx

  v3 = a1[11];
  v5 = 592 * a3;
  if ( (*(_DWORD *)(v3 + 592 * a2) & 0x10) == 16 )
  {
    if ( (*(_DWORD *)(v5 + v3) & 0x10) != 16 )
      return 0xFFFFFFFFi64;
  }
  else if ( (*(_DWORD *)(v5 + v3) & 0x10) == 16 )
  {
    return 1i64;
  }
  v7 = CompareFileTime((const FILETIME *)(v3 + 592 * a2 + 20), (const FILETIME *)(v3 + v5 + 20));
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v7;
  return v7;
}

//----- (0000000140066980) ----------------------------------------------------
int __fastcall sub_140066980(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // edi
  __int64 v8; // rdx
  const ITEMIDLIST *v9; // rcx
  ITEMIDLIST *v10; // rbx
  __int64 v11; // rdx
  const ITEMIDLIST *v12; // rcx
  ITEMIDLIST *v13; // rbx
  BOOL IsRootW; // eax
  __int64 v16; // rdx
  LPITEMIDLIST v17; // rdi
  LPITEMIDLIST v18; // rbx
  int v19; // ebx
  void *ppv; // [rsp+30h] [rbp-D0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+38h] [rbp-C8h] BYREF
  LPCITEMIDLIST pidl; // [rsp+40h] [rbp-C0h] BYREF
  void *v23; // [rsp+48h] [rbp-B8h] BYREF
  LPCITEMIDLIST v24; // [rsp+50h] [rbp-B0h] BYREF
  void *v25; // [rsp+58h] [rbp-A8h] BYREF
  STRRET pstr; // [rsp+60h] [rbp-A0h] BYREF
  STRRET v27; // [rsp+170h] [rbp+70h] BYREF
  SHFILEINFOW psfi; // [rsp+280h] [rbp+180h] BYREF
  SHFILEINFOW v29; // [rsp+540h] [rbp+440h] BYREF
  WCHAR v30[264]; // [rsp+800h] [rbp+700h] BYREF
  WCHAR pszPath[264]; // [rsp+A10h] [rbp+910h] BYREF
  WCHAR v32[264]; // [rsp+C20h] [rbp+B20h] BYREF
  WCHAR pszBuf[264]; // [rsp+E30h] [rbp+D30h] BYREF

  v3 = 0;
  v25 = 0i64;
  v23 = 0i64;
  pidl = 0i64;
  v24 = 0i64;
  if ( *(_DWORD *)(a1 + 712) )
  {
    v8 = *(_QWORD *)(a1 + 96);
    v9 = *(const ITEMIDLIST **)(a1 + 136);
    ppv = 0i64;
    ppidlLast = 0i64;
    v10 = ILCombine(v9, *(LPCITEMIDLIST *)(568 * a2 + v8));
    SHBindToParent(v10, &stru_1400E3FB0, &ppv, &ppidlLast);
    (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
      ppv,
      ppidlLast,
      0x8000i64,
      &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    SHGetFileInfoW(&v10->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
    CoTaskMemFree(v10);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    v11 = *(_QWORD *)(a1 + 96);
    v12 = *(const ITEMIDLIST **)(a1 + 136);
    ppv = 0i64;
    v13 = ILCombine(v12, *(LPCITEMIDLIST *)(568 * a3 + v11));
    SHBindToParent(v13, &stru_1400E3FB0, &ppv, &ppidlLast);
    (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
      ppv,
      ppidlLast,
      0x8000i64,
      &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
    SHGetFileInfoW(&v13->mkid.cb, 0, &v29, 0x2B8u, 0x408u);
    CoTaskMemFree(v13);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    ppv = 0i64;
    LODWORD(v13) = PathIsRootW(pszBuf);
    IsRootW = PathIsRootW(pszPath);
    if ( (_DWORD)v13 )
    {
      if ( IsRootW )
        return lstrcmpW(psfi.szTypeName, v29.szTypeName);
      return -1;
    }
    if ( IsRootW )
      return 1;
  }
  v16 = *(_QWORD *)(a1 + 88);
  LOBYTE(v3) = (*(_DWORD *)(592i64 * (int)a3 + v16) & 0x10) == 16;
  if ( (*(_DWORD *)(592i64 * (int)a2 + v16) & 0x10) == 16 )
  {
    if ( !v3 )
      return -1;
  }
  else if ( v3 )
  {
    return 1;
  }
  v17 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568 * a2 + *(_QWORD *)(a1 + 96)));
  v18 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568 * a3 + *(_QWORD *)(a1 + 96)));
  SHGetFileInfoW(&v17->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
  SHGetFileInfoW(&v18->mkid.cb, 0, &v29, 0x2B8u, 0x408u);
  SHBindToParent(v17, &stru_1400E3FB0, &v25, &pidl);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)v25 + 88i64))(
    v25,
    pidl,
    0x8000i64,
    &v27);
  StrRetToBufW(&v27, pidl, v30, 0x104u);
  SHBindToParent(v18, &stru_1400E3FB0, &v23, &v24);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)v23 + 88i64))(v23, v24, 0x8000i64, &v27);
  StrRetToBufW(&v27, v24, v32, 0x104u);
  PathIsRootW(v30);
  PathIsRootW(v32);
  (*(void (__fastcall **)(void *))(*(_QWORD *)v23 + 16i64))(v23);
  (*(void (__fastcall **)(void *))(*(_QWORD *)v25 + 16i64))(v25);
  CoTaskMemFree(v18);
  CoTaskMemFree(v17);
  v19 = lstrcmpW(psfi.szTypeName, v29.szTypeName);
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v19;
  return v19;
}

//----- (0000000140066DB0) ----------------------------------------------------
__int64 __fastcall sub_140066DB0(_QWORD *a1, int a2, int a3)
{
  __int64 v3; // rax
  unsigned int v4; // ebx
  _DWORD *v6; // rsi
  _DWORD *v7; // rbp
  __int64 v8; // rcx
  double v9; // xmm0_8
  double v10; // xmm3_8
  int v11; // eax
  double v13; // xmm0_8
  double v14; // xmm3_8

  v3 = a1[11];
  v4 = 0;
  v6 = (_DWORD *)(v3 + 592i64 * a2);
  v7 = (_DWORD *)(v3 + 592i64 * a3);
  if ( (*v6 & 0x10) != 16 )
  {
    if ( (*v7 & 0x10) == 16 )
      return 1i64;
    v13 = pow(2.0, 32.0);
    v14 = (double)(int)v6[7] * v13 + (double)(int)v6[8] - ((double)(int)v7[7] * v13 + (double)(int)v7[8]);
    if ( v14 <= 0.0 )
    {
      if ( v14 < 0.0 )
        v4 = -1;
    }
    else
    {
      v4 = 1;
    }
    goto LABEL_21;
  }
  if ( (*v7 & 0x10) != 16 )
    return 0xFFFFFFFFi64;
  v8 = a1[12];
  if ( !*(_DWORD *)(568i64 * a2 + v8 + 544) )
  {
    if ( *(_DWORD *)(568i64 * a3 + v8 + 544) )
      return 1;
    goto LABEL_9;
  }
  if ( *(_DWORD *)(568i64 * a3 + v8 + 544) )
  {
LABEL_9:
    v9 = pow(2.0, 32.0);
    v10 = (double)(int)v6[7] * v9 + (double)(int)v6[8] - ((double)(int)v7[7] * v9 + (double)(int)v7[8]);
    if ( v10 > 0.0 )
    {
      v4 = 1;
      v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1);
      goto LABEL_22;
    }
    if ( v10 < 0.0 )
      v4 = -1;
LABEL_21:
    v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1);
LABEL_22:
    if ( !v11 )
      return -v4;
    return v4;
  }
  return (unsigned int)-1;
}
// 140066E4D: conditional instruction was optimized away because er8.4!=0

//----- (0000000140066FD0) ----------------------------------------------------
__int64 __fastcall sub_140066FD0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v5; // r8
  unsigned int v7; // ebx

  v3 = a1[11];
  v5 = 592 * a3;
  if ( (*(_DWORD *)(v3 + 592 * a2) & 0x10) == 16 )
  {
    if ( (*(_DWORD *)(v5 + v3) & 0x10) != 16 )
      return 0xFFFFFFFFi64;
  }
  else if ( (*(_DWORD *)(v5 + v3) & 0x10) == 16 )
  {
    return 1i64;
  }
  v7 = CompareFileTime((const FILETIME *)(v3 + 592 * a2 + 12), (const FILETIME *)(v3 + v5 + 12));
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v7;
  return v7;
}

//----- (00000001400670B0) ----------------------------------------------------
__int64 __fastcall sub_1400670B0(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v5; // r8
  unsigned int v7; // ebx

  v3 = a1[11];
  v5 = 592 * a3;
  if ( (*(_DWORD *)(v3 + 592 * a2) & 0x10) == 16 )
  {
    if ( (*(_DWORD *)(v5 + v3) & 0x10) != 16 )
      return 0xFFFFFFFFi64;
  }
  else if ( (*(_DWORD *)(v5 + v3) & 0x10) == 16 )
  {
    return 1i64;
  }
  v7 = CompareFileTime((const FILETIME *)(v3 + 592 * a2 + 4), (const FILETIME *)(v3 + v5 + 4));
  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 80i64))(a1) )
    return -v7;
  return v7;
}

//----- (0000000140067190) ----------------------------------------------------
__int64 __fastcall sub_140067190(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rcx
  __int64 v6; // rsi
  unsigned int v7; // ebx
  int v9; // ebx
  WCHAR pszDest[264]; // [rsp+20h] [rbp-448h] BYREF
  WCHAR v11[264]; // [rsp+230h] [rbp-238h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW(v11, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    v9 = sub_140081380(pszDest);
    v7 = v9 - sub_140081380(v11);
  }
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v7;
  return v7;
}

//----- (00000001400672D0) ----------------------------------------------------
__int64 __fastcall sub_1400672D0(char *a1, int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  __int64 v6; // rdi
  __int64 v7; // rsi
  unsigned int v8; // ebx
  int v9; // eax
  double v11; // xmm0_8
  __int64 v12; // rdx
  WCHAR *v13; // rcx
  double v14; // xmm2_8
  __int64 v15; // rdi
  double v16; // xmm1_8
  __int64 v17; // rsi
  WCHAR v18; // ax
  DWORD v19; // er11
  __int64 v20; // rdi
  DWORD BytesPerSector; // [rsp+30h] [rbp-248h] BYREF
  int SectorsPerCluster[3]; // [rsp+34h] [rbp-244h] BYREF
  WCHAR pszPath[264]; // [rsp+40h] [rbp-238h] BYREF

  v3 = *((_QWORD *)a1 + 11);
  v4 = 0;
  v6 = v3 + 592i64 * a2;
  v7 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v6 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v7 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v8 = StrCmpIW((PCWSTR)(v6 + 44), (PCWSTR)(v7 + 44));
    v9 = (*(__int64 (__fastcall **)(char *))(*(_QWORD *)a1 + 80i64))(a1);
  }
  else
  {
    if ( (*(_DWORD *)v7 & 0x10) == 16 )
      return 1i64;
    v11 = pow(2.0, 32.0);
    v12 = 260i64;
    v13 = pszPath;
    v14 = (double)*(int *)(v6 + 28) * v11 + (double)*(int *)(v6 + 32);
    v15 = (unsigned int)(int)v14;
    v16 = (double)*(int *)(v7 + 28) * v11 + (double)*(int *)(v7 + 32);
    v17 = (unsigned int)(int)v16;
    while ( v12 != -2147483386 )
    {
      v18 = *(WCHAR *)((char *)v13 + a1 + 160 - (char *)pszPath);
      if ( !v18 )
        break;
      *v13++ = v18;
      if ( !--v12 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
    PathStripToRootW(pszPath);
    GetDiskFreeSpaceW(pszPath, (LPDWORD)SectorsPerCluster, &BytesPerSector, 0i64, 0i64);
    v19 = BytesPerSector * SectorsPerCluster[0];
    if ( (int)v14 )
      v15 += v19 - v15 % v19;
    if ( (int)v16 )
      v17 += v19 - v17 % v19;
    v20 = v15 - v17;
    if ( v20 <= 0 )
    {
      LOBYTE(v4) = v20 >= 0;
      v8 = v4 - 1;
    }
    else
    {
      v8 = 1;
    }
    v9 = (*(__int64 (__fastcall **)(char *))(*(_QWORD *)a1 + 80i64))(a1);
  }
  if ( !v9 )
    return -v8;
  return v8;
}
// 140067407: conditional instruction was optimized away because rdx.8!=0
// 1400672D0: using guessed type DWORD SectorsPerCluster[3];

//----- (00000001400674E0) ----------------------------------------------------
int __fastcall sub_1400674E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v7; // rdx
  const ITEMIDLIST *v8; // rcx
  ITEMIDLIST *v9; // rbx
  __int64 v10; // rdx
  const ITEMIDLIST *v11; // rcx
  ITEMIDLIST *v12; // rbx
  BOOL IsRootW; // eax
  __int64 v15; // rdx
  int v16; // ebx
  void *ppv; // [rsp+20h] [rbp-E0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+28h] [rbp-D8h] BYREF
  STRRET pstr; // [rsp+30h] [rbp-D0h] BYREF
  WCHAR pszBuf[264]; // [rsp+140h] [rbp+40h] BYREF
  WCHAR pszPath[264]; // [rsp+350h] [rbp+250h] BYREF

  if ( !*(_DWORD *)(a1 + 712) )
  {
LABEL_8:
    sub_14007E090(10, pszBuf);
    if ( !StrCmpW((PCWSTR)(a1 + 160), pszBuf) )
      goto LABEL_13;
    v15 = *(_QWORD *)(a1 + 88);
    if ( (*(_DWORD *)(592 * a2 + v15) & 0x10) != 0 && (*(_BYTE *)(592 * a3 + v15) & 0x10) == 0 )
      return -1;
    if ( (*(_DWORD *)(592 * a2 + v15) & 0x10) == 16 || (*(_BYTE *)(592 * a3 + v15) & 0x10) == 0 )
    {
LABEL_13:
      v16 = StrCmpLogicalW((PCWSTR)(568 * a2 + *(_QWORD *)(a1 + 96) + 8), (PCWSTR)(568 * a3 + *(_QWORD *)(a1 + 96) + 8));
      if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
        return -v16;
      return v16;
    }
    return 1;
  }
  v7 = *(_QWORD *)(a1 + 96);
  v8 = *(const ITEMIDLIST **)(a1 + 136);
  ppidlLast = 0i64;
  ppv = 0i64;
  v9 = ILCombine(v8, *(LPCITEMIDLIST *)(568 * a2 + v7));
  SHBindToParent(v9, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
  CoTaskMemFree(v9);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  v10 = *(_QWORD *)(a1 + 96);
  v11 = *(const ITEMIDLIST **)(a1 + 136);
  ppv = 0i64;
  v12 = ILCombine(v11, *(LPCITEMIDLIST *)(568 * a3 + v10));
  SHBindToParent(v12, &stru_1400E3FB0, &ppv, &ppidlLast);
  (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
    ppv,
    ppidlLast,
    0x8000i64,
    &pstr);
  StrRetToBufW(&pstr, ppidlLast, pszPath, 0x104u);
  CoTaskMemFree(v12);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  ppv = 0i64;
  LODWORD(v12) = PathIsRootW(pszBuf);
  IsRootW = PathIsRootW(pszPath);
  if ( !(_DWORD)v12 )
  {
    if ( IsRootW )
      return 1;
    goto LABEL_8;
  }
  if ( !IsRootW )
    return -1;
  PathStripToRootW(pszBuf);
  PathStripToRootW(pszPath);
  return lstrcmpW(pszBuf, pszPath);
}

//----- (00000001400677A0) ----------------------------------------------------
__int64 __fastcall sub_1400677A0(__int64 *a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // r9
  int v8; // eax
  unsigned int v10; // ebx
  WCHAR String2[512]; // [rsp+30h] [rbp-818h] BYREF
  WCHAR String1[512]; // [rsp+430h] [rbp-418h] BYREF

  v3 = a1[11];
  v5 = a3;
  v6 = v3 + 592i64 * a2;
  v7 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v6 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v7 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v8 = StrCmpIW((PCWSTR)(v6 + 44), (PCWSTR)(v7 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v7 & 0x10) == 16 )
      return 1i64;
    sub_14007F650(a1[8], a1[17], a1[12] + 568i64 * a2, String1, 0x200u);
    sub_14007F650(a1[8], a1[17], a1[12] + 568 * v5, String2, 0x200u);
    v8 = lstrcmpW(String1, String2);
  }
  v10 = v8;
  if ( !(*(unsigned int (__fastcall **)(__int64 *))(*a1 + 80))(a1) )
    return -v10;
  return v10;
}

//----- (0000000140067900) ----------------------------------------------------
__int64 __fastcall sub_140067900(__int64 a1, int a2, int a3, int a4)
{
  __int64 v4; // rax
  __int64 v7; // rcx
  __int64 v8; // rsi
  int v9; // eax
  unsigned int v11; // ebx
  WCHAR v12[264]; // [rsp+20h] [rbp-C48h] BYREF
  WCHAR pszDest[264]; // [rsp+230h] [rbp-A38h] BYREF
  WCHAR String2[512]; // [rsp+440h] [rbp-828h] BYREF
  WCHAR String1[512]; // [rsp+840h] [rbp-428h] BYREF

  v4 = *(_QWORD *)(a1 + 88);
  v7 = v4 + 592i64 * a2;
  v8 = v4 + 592i64 * a3;
  if ( (*(_DWORD *)v7 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v8 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v9 = StrCmpIW((PCWSTR)(v7 + 44), (PCWSTR)(v8 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v8 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v7 + 44));
    PathCombineW(v12, (LPCWSTR)(a1 + 160), (LPCWSTR)(v8 + 44));
    sub_140082350((__int64)pszDest, a4, String1);
    sub_140082350((__int64)v12, a4, String2);
    v9 = lstrcmpW(String1, String2);
  }
  v11 = v9;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v11;
  return v11;
}

//----- (0000000140067B40) ----------------------------------------------------
__int64 __fastcall sub_140067B40(__int64 a1, int a2, int a3, int a4)
{
  __int64 v4; // rax
  __int64 v7; // rcx
  __int64 v8; // rsi
  int v9; // eax
  unsigned int v11; // ebx
  WCHAR v12[264]; // [rsp+20h] [rbp-C48h] BYREF
  WCHAR pszDest[264]; // [rsp+230h] [rbp-A38h] BYREF
  WCHAR String2[512]; // [rsp+440h] [rbp-828h] BYREF
  WCHAR String1[512]; // [rsp+840h] [rbp-428h] BYREF

  v4 = *(_QWORD *)(a1 + 88);
  v7 = v4 + 592i64 * a2;
  v8 = v4 + 592i64 * a3;
  if ( (*(_DWORD *)v7 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v8 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v9 = StrCmpIW((PCWSTR)(v7 + 44), (PCWSTR)(v8 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v8 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v7 + 44));
    PathCombineW(v12, (LPCWSTR)(a1 + 160), (LPCWSTR)(v8 + 44));
    sub_140082600((__int64)pszDest, a4, String1);
    sub_140082600((__int64)v12, a4, String2);
    v9 = lstrcmpW(String1, String2);
  }
  v11 = v9;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v11;
  return v11;
}

//----- (0000000140067DC0) ----------------------------------------------------
__int64 __fastcall sub_140067DC0(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // r9
  __int64 v6; // rsi
  int v7; // eax
  unsigned int v9; // ebx
  SHFILEINFOW psfi; // [rsp+30h] [rbp-B28h] BYREF
  WCHAR pszPath[264]; // [rsp+2F0h] [rbp-868h] BYREF
  WCHAR pszDest[264]; // [rsp+500h] [rbp-658h] BYREF
  WCHAR String2[264]; // [rsp+710h] [rbp-448h] BYREF
  WCHAR String1[264]; // [rsp+920h] [rbp-238h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW(pszPath, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    if ( SHGetFileInfoW(pszDest, 0, &psfi, 0x2B8u, 0x800u) )
      sub_1400D2C10(0i64, 1u, (__int64)pszDest, String1, (__int64)&psfi);
    if ( SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x800u) )
      sub_1400D2C10(0i64, 1u, (__int64)pszPath, String2, (__int64)&psfi);
    v7 = lstrcmpW(String1, String2);
  }
  v9 = v7;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v9;
  return v9;
}

//----- (0000000140067F80) ----------------------------------------------------
__int64 __fastcall sub_140067F80(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // r9
  __int64 v6; // rsi
  int v7; // eax
  DWORD FileVersionInfoSizeW; // eax
  DWORD v10; // eax
  unsigned int v11; // ebx
  DWORD dwHandle[4]; // [rsp+20h] [rbp-C58h] BYREF
  WCHAR tstrFilename[264]; // [rsp+30h] [rbp-C48h] BYREF
  WCHAR pszDest[264]; // [rsp+240h] [rbp-A38h] BYREF
  WCHAR String2[512]; // [rsp+450h] [rbp-828h] BYREF
  WCHAR String1[512]; // [rsp+850h] [rbp-428h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW(tstrFilename, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    dwHandle[0] = 0;
    FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszDest, dwHandle);
    if ( FileVersionInfoSizeW )
      sub_140082920(pszDest, (__int64)L"ProductName", String1, FileVersionInfoSizeW);
    dwHandle[0] = 0;
    v10 = GetFileVersionInfoSizeW(tstrFilename, dwHandle);
    if ( v10 )
      sub_140082920(tstrFilename, (__int64)L"ProductName", String2, v10);
    v7 = lstrcmpW(String1, String2);
  }
  v11 = v7;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v11;
  return v11;
}
// 1400EA1D8: using guessed type wchar_t aProductname_0[12];
// 1400EA1F0: using guessed type wchar_t aProductname_1[12];

//----- (00000001400681F0) ----------------------------------------------------
__int64 __fastcall sub_1400681F0(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rcx
  __int64 v6; // rsi
  int v7; // eax
  unsigned int v9; // ebx
  WCHAR FileName[264]; // [rsp+20h] [rbp-C48h] BYREF
  WCHAR pszDest[264]; // [rsp+230h] [rbp-A38h] BYREF
  WCHAR String1[512]; // [rsp+440h] [rbp-828h] BYREF
  __int16 String2[512]; // [rsp+840h] [rbp-428h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW(FileName, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    sub_140082CD0(pszDest, String1);
    sub_140082CD0(FileName, String1);
    v7 = lstrcmpW(String1, (LPCWSTR)String2);
  }
  v9 = v7;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v9;
  return v9;
}
// 1400681F0: using guessed type WCHAR String2[512];

//----- (0000000140068340) ----------------------------------------------------
__int64 __fastcall sub_140068340(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v5; // rcx
  __int64 v6; // rdi
  int v7; // eax
  __int64 v9; // rbx
  __int64 v10; // rdx
  WCHAR *v11; // rcx
  WCHAR v12; // ax
  HANDLE v13; // r11
  WCHAR *v14; // rcx
  WCHAR v15; // ax
  HANDLE v16; // r11
  unsigned int v17; // ebx
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+20h] [rbp-718h] BYREF
  WCHAR String1[32]; // [rsp+270h] [rbp-4C8h] BYREF
  WCHAR String2[32]; // [rsp+2B0h] [rbp-488h] BYREF
  WCHAR pszDest[264]; // [rsp+2F0h] [rbp-448h] BYREF
  WCHAR FileName[264]; // [rsp+500h] [rbp-238h] BYREF

  v3 = *(_QWORD *)(a1 + 88);
  v5 = v3 + 592i64 * a2;
  v6 = v3 + 592i64 * a3;
  if ( (*(_DWORD *)v5 & 0x10) == 16 )
  {
    if ( (*(_DWORD *)v6 & 0x10) != 16 )
      return 0xFFFFFFFFi64;
    v7 = StrCmpIW((PCWSTR)(v5 + 44), (PCWSTR)(v6 + 44));
  }
  else
  {
    if ( (*(_DWORD *)v6 & 0x10) == 16 )
      return 1i64;
    PathCombineW(pszDest, (LPCWSTR)(a1 + 160), (LPCWSTR)(v5 + 44));
    PathCombineW(FileName, (LPCWSTR)(a1 + 160), (LPCWSTR)(v6 + 44));
    v9 = 32i64;
    if ( FindFirstFileW(pszDest, &FindFileData) == (HANDLE)-1i64 )
    {
      v10 = 32i64;
      v11 = String1;
      while ( v10 != -2147483614 )
      {
        v12 = *(WCHAR *)((char *)v11 + &unk_1400EAC9C - (_UNKNOWN *)String1);
        if ( !v12 )
          break;
        *v11++ = v12;
        if ( !--v10 )
        {
          *(v11 - 1) = 0;
          goto LABEL_15;
        }
      }
      *v11 = 0;
    }
    else
    {
      sub_140082FB0(FindFileData.dwFileAttributes, (char *)String1, 0x20u);
      FindClose(v13);
    }
LABEL_15:
    if ( FindFirstFileW(FileName, &FindFileData) == (HANDLE)-1i64 )
    {
      v14 = String2;
      while ( v9 != -2147483614 )
      {
        v15 = *(WCHAR *)((char *)v14 + &unk_1400EAC9C - (_UNKNOWN *)String2);
        if ( !v15 )
          break;
        *v14++ = v15;
        if ( !--v9 )
        {
          *(v14 - 1) = 0;
          goto LABEL_23;
        }
      }
      *v14 = 0;
    }
    else
    {
      sub_140082FB0(FindFileData.dwFileAttributes, (char *)String2, 0x20u);
      FindClose(v16);
    }
LABEL_23:
    v7 = lstrcmpW(String1, String2);
  }
  v17 = v7;
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1) )
    return -v17;
  return v17;
}
// 14006846F: conditional instruction was optimized away because rdx.8!=0
// 1400684FD: conditional instruction was optimized away because rbx.8!=0
// 140068491: variable 'v13' is possibly undefined
// 14006851F: variable 'v16' is possibly undefined

//----- (00000001400685A0) ----------------------------------------------------
int __fastcall sub_1400685A0(__int64 a1, __int64 a2, __int64 a3)
{
  int result; // eax

  result = sub_14006FF50(a1, a2, a3);
  if ( !result )
    return StrCmpLogicalW((PCWSTR)(568 * a2 + *(_QWORD *)(a1 + 96) + 8), (PCWSTR)(568 * a3 + *(_QWORD *)(a1 + 96) + 8));
  return result;
}

//----- (0000000140068600) ----------------------------------------------------
int __fastcall sub_140068600(__int64 a1, __int64 a2, __int64 a3)
{
  int result; // eax

  result = sub_14006FF50(a3, a1, a2);
  if ( !result )
    return StrCmpLogicalW((PCWSTR)(568 * a1 + *(_QWORD *)(a3 + 96) + 8), (PCWSTR)(568 * a2 + *(_QWORD *)(a3 + 96) + 8));
  return result;
}

//----- (0000000140068670) ----------------------------------------------------
__int64 __fastcall sub_140068670(WPARAM wParam, int a2)
{
  bool v2; // zf

  v2 = *(_DWORD *)(wParam + 816) == 0;
  *(_DWORD *)(wParam + 704) = a2;
  if ( !v2 )
  {
    SendMessageW(*(HWND *)(wParam + 56), 0x109Du, 0i64, 0i64);
    SendMessageW(*(HWND *)(wParam + 56), 0x10A0u, 0i64, 0i64);
    SendMessageW(*(HWND *)(wParam + 56), 0x109Du, 1ui64, 0i64);
    (*(void (__fastcall **)(WPARAM, __int64))(*(_QWORD *)(wParam + 16) + 208i64))(wParam + 16, 1i64);
  }
  SendMessageW(*(HWND *)(wParam + 56), 0x1030u, wParam, (LPARAM)sub_140068600);
  if ( *(_DWORD *)(wParam + 708) == 4 )
    sub_14006A340(wParam);
  return 0i64;
}

//----- (0000000140068710) ----------------------------------------------------
void __fastcall sub_140068710(__int64 a1, int a2)
{
  LPARAM v3; // rdi
  __int64 v4; // rdx
  HWND v5; // rcx
  int v6; // eax
  int v7; // eax
  LPARAM lParam[7]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v9; // [rsp+70h] [rbp+18h]

  if ( a2 != -1 )
  {
    v3 = a2;
    CoTaskMemFree(*(LPVOID *)(568i64 * a2 + *(_QWORD *)(a1 + 96)));
    v4 = *(_QWORD *)(a1 + 88);
    v5 = *(HWND *)(a1 + 56);
    LODWORD(v9) = *(_DWORD *)(592 * v3 + v4 + 32);
    HIDWORD(v9) = *(_DWORD *)(592 * v3 + v4 + 28);
    LODWORD(lParam[0]) = 1;
    lParam[2] = v3;
    *(_QWORD *)(a1 + 680) -= v9;
    v6 = SendMessageW(v5, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam);
    if ( v6 != -1 )
      SendMessageW(*(HWND *)(a1 + 56), 0x1008u, v6, 0i64);
    *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4 * v3) = 0;
    v7 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
    --*(_DWORD *)(a1 + 752);
    if ( !v7 && !*(_DWORD *)(a1 + 2560) )
      SendMessageW(*(HWND *)(a1 + 64), 0x80C9u, *(int *)(a1 + 852), 1i64);
  }
}

//----- (0000000140068810) ----------------------------------------------------
WCHAR *__fastcall sub_140068810(__int64 a1, int a2)
{
  __int64 v2; // rdi
  int v4; // esi
  const WCHAR *ExtensionW; // rax
  WCHAR *v6; // r8
  __int64 v7; // rdx
  WCHAR *v8; // rcx

  v2 = a2;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 844) )
  {
    if ( (*(_BYTE *)(592i64 * a2 + *(_QWORD *)(a1 + 88)) & 0x10) == 0 )
    {
      ExtensionW = PathFindExtensionW((LPCWSTR)(568i64 * a2 + *(_QWORD *)(a1 + 96) + 8));
      if ( *ExtensionW )
      {
        if ( !lstrcmpiW(ExtensionW, L".lnk") )
          v4 = 1;
      }
    }
  }
  if ( *(_DWORD *)(a1 + 836) && !v4 )
    return (WCHAR *)(568 * v2 + *(_QWORD *)(a1 + 96) + 8);
  v6 = (WCHAR *)(568 * v2 + *(_QWORD *)(a1 + 96) + 8);
  if ( *v6 == 46 || (*(_BYTE *)(592 * v2 + *(_QWORD *)(a1 + 88)) & 0x10) != 0 )
    return (WCHAR *)(568 * v2 + *(_QWORD *)(a1 + 96) + 8);
  v7 = 260i64;
  v8 = &word_14012EAE0;
  while ( v7 != -2147483386 && *v6 )
  {
    *v8++ = *v6++;
    if ( !--v7 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathRemoveExtensionW(&word_14012EAE0);
  return &word_14012EAE0;
}
// 1400688FA: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140068950) ----------------------------------------------------
__int64 __fastcall sub_140068950(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  unsigned int v6; // ebx
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  pv[0] = 0i64;
  if ( !a2 )
    return 2147500037i64;
  result = sub_14007F810(a2, (__int64)pv);
  if ( (int)result >= 0 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64, void *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, pv[0], a3);
    CoTaskMemFree(pv[0]);
    return v6;
  }
  return result;
}
// 140068950: using guessed type LPVOID pv[3];

//----- (00000001400689D0) ----------------------------------------------------
__int64 __fastcall sub_1400689D0(__int64 a1, const ITEMIDLIST *a2)
{
  unsigned int v2; // esi
  HRESULT v5; // eax
  int v6; // edi
  __int64 v7; // r8
  __int64 v8; // r8
  int v9; // eax
  LPCITEMIDLIST pidl; // [rsp+30h] [rbp-D0h] BYREF
  IShellFolder *v12; // [rsp+38h] [rbp-C8h] BYREF
  int v13; // [rsp+40h] [rbp-C0h] BYREF
  int v14; // [rsp+44h] [rbp-BCh] BYREF
  __int64 v15; // [rsp+48h] [rbp-B8h] BYREF
  IShellFolder *ppshf; // [rsp+50h] [rbp-B0h] BYREF
  STRRET pstr; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR pszBuf[264]; // [rsp+170h] [rbp+70h] BYREF

  v2 = 0;
  ppshf = 0i64;
  v12 = 0i64;
  v15 = 0i64;
  pidl = 0i64;
  sub_14006F280(a1, a2);
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    if ( (unsigned int)sub_14007DF90((__int64)a2) )
      v5 = SHGetDesktopFolder(&v12);
    else
      v5 = ((__int64 (__fastcall *)(IShellFolder *, const ITEMIDLIST *, _QWORD, const IID *, IShellFolder **))ppshf->lpVtbl->BindToObject)(
             ppshf,
             a2,
             0i64,
             &stru_1400E3FB0,
             &v12);
    v6 = v5;
    *(_QWORD *)(a1 + 136) = ILClone(a2);
    if ( v6 >= 0 )
    {
      v7 = 96i64;
      if ( *(_DWORD *)(a1 + 832) )
        v7 = 224i64;
      if ( ((int (__fastcall *)(IShellFolder *, _QWORD, __int64, __int64 *))v12->lpVtbl->EnumObjects)(
             v12,
             *(_QWORD *)(a1 + 64),
             v7,
             &v15) >= 0
        && v15 )
      {
        v13 = 1;
        while ( !(*(unsigned int (__fastcall **)(__int64, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)v15 + 24i64))(
                   v15,
                   1i64,
                   &pidl,
                   &v13) )
        {
          if ( v13 != 1 )
            break;
          v14 = 0x20000000;
          ((void (__fastcall *)(IShellFolder *, __int64, LPCITEMIDLIST *, int *))v12->lpVtbl->GetAttributesOf)(
            v12,
            1i64,
            &pidl,
            &v14);
          if ( !*(_DWORD *)(a1 + 712) )
          {
            v8 = 32769i64;
            if ( (v14 & 0x20000000) == 0 )
              continue;
          }
          v8 = 1i64;
          if ( ((int (__fastcall *)(IShellFolder *, LPCITEMIDLIST, __int64, STRRET *))v12->lpVtbl->GetDisplayNameOf)(
                 v12,
                 pidl,
                 v8,
                 &pstr) >= 0 )
          {
            StrRetToBufW(&pstr, pidl, pszBuf, 0x104u);
            v9 = sub_14002B130(a1, a2, pidl, pszBuf);
            sub_14002B060(a1, -1, v9, 0);
            ++v2;
          }
          CoTaskMemFree((LPVOID)pidl);
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
      }
      ((void (__fastcall *)(IShellFolder *))v12->lpVtbl->Release)(v12);
    }
    ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
  }
  return v2;
}

//----- (0000000140068C20) ----------------------------------------------------
__int64 __fastcall sub_140068C20(__int64 a1, LPITEMIDLIST *a2, int a3, _DWORD *a4)
{
  unsigned int v4; // ebp
  ITEMIDLIST *v9; // rbx
  __int64 *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax

  v4 = 0;
  if ( (a3 & 0x1000) == 0 )
  {
    if ( (a3 & 0x2000) != 0 )
    {
      sub_14007DFF0(*(LPCITEMIDLIST *)(a1 + 136), a2);
      goto LABEL_11;
    }
    if ( (a3 & 0x4000) != 0 )
    {
      if ( !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 104) + 24i64))(*(_QWORD *)(a1 + 104)) )
        goto LABEL_8;
      v11 = *(__int64 **)(a1 + 104);
      *a4 = 0;
      v12 = 0xFFFFFFFFi64;
      v13 = *v11;
    }
    else
    {
      if ( (a3 & 0x8000) == 0 )
      {
        if ( a2 )
          goto LABEL_11;
        return 2147942487i64;
      }
      if ( !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 104) + 32i64))(*(_QWORD *)(a1 + 104)) )
      {
LABEL_8:
        SetFocus(*(HWND *)(a1 + 56));
        return 2147500037i64;
      }
      v11 = *(__int64 **)(a1 + 104);
      *a4 = 0;
      v12 = 1i64;
      v13 = *v11;
    }
    *a2 = (LPITEMIDLIST)(*(__int64 (__fastcall **)(__int64 *, __int64))(v13 + 88))(v11, v12);
    goto LABEL_11;
  }
  if ( !a2 )
    return 2147942487i64;
  v9 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *a2);
  *a2 = ILClone(v9);
  CoTaskMemFree(v9);
LABEL_11:
  if ( (a3 & 0x8000000) != 0 )
    *a4 = 0;
  if ( !(unsigned int)sub_14007FB00(*a2) )
    return (unsigned int)-2147467259;
  return v4;
}

//----- (0000000140068D50) ----------------------------------------------------
_BOOL8 __fastcall sub_140068D50(__int64 a1, int a2)
{
  int v2; // edi
  BOOL v3; // er9
  __int64 v4; // rsi

  v2 = 0;
  v3 = 0;
  v4 = a2;
  if ( *(_DWORD *)(a1 + 2560) && (*(_BYTE *)(592i64 * a2 + *(_QWORD *)(a1 + 88)) & 0x10) == 0 )
    v3 = sub_140082100((LPCWSTR)(a1 + 1536), (LPCWSTR)(568i64 * a2 + *(_QWORD *)(a1 + 96) + 8), *(_DWORD *)(a1 + 2564)) == 0;
  if ( *(_DWORD *)(a1 + 840) )
    LOBYTE(v2) = (*(_DWORD *)(592 * v4 + *(_QWORD *)(a1 + 88)) & 4) == 4;
  return v3 || v2;
}

//----- (0000000140068E10) ----------------------------------------------------
__int64 __fastcall sub_140068E10(__int64 a1, const ITEMIDLIST *a2, int a3)
{
  HCURSOR CursorW; // rax
  LPITEMIDLIST v7; // rax
  bool v8; // zf
  HCURSOR v9; // rax
  _QWORD **v11; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rbx
  ITEMIDLIST *v14; // rbx
  _WORD *v15; // rcx
  __int64 v16; // r11
  __int16 v17; // ax
  HCURSOR v18; // rax
  int v19; // [rsp+20h] [rbp-248h] BYREF
  LPVOID pv; // [rsp+28h] [rbp-240h] BYREF
  __int16 lParam[264]; // [rsp+30h] [rbp-238h] BYREF

  v19 = 1;
  CursorW = LoadCursorW(0i64, (LPCWSTR)0x7F02);
  SetCursor(CursorW);
  v7 = ILClone(a2);
  v8 = *(_DWORD *)(a1 + 700) == 0;
  pv = v7;
  if ( !v8 )
    sub_14006A1D0(a1 - 16);
  if ( (unsigned int)sub_140068C20(a1 - 16, (LPITEMIDLIST *)&pv, a3, &v19) )
  {
    v9 = LoadCursorW(0i64, (LPCWSTR)0x7F00);
    SetCursor(v9);
    return 2147500037i64;
  }
  else
  {
    *(_DWORD *)(a1 + 2552) = 1;
    sub_14006FA40(a1 - 16);
    EnterCriticalSection(&stru_14012DAD0);
    LeaveCriticalSection(&stru_14012DAD0);
    sub_14006A140(a1 - 16);
    sub_14006A0B0(a1 - 16);
    *(_DWORD *)(a1 + 2552) = 0;
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
    v11 = *(_QWORD ***)(a1 + 904);
    v12 = *v11;
    *v11 = v11;
    *(_QWORD *)(*(_QWORD *)(a1 + 904) + 8i64) = *(_QWORD *)(a1 + 904);
    *(_QWORD *)(a1 + 912) = 0i64;
    if ( v12 != *(_QWORD **)(a1 + 904) )
    {
      do
      {
        v13 = (_QWORD *)*v12;
        j_free(v12);
        v12 = v13;
      }
      while ( v13 != *(_QWORD **)(a1 + 904) );
    }
    sub_14000A630(a1 + 976);
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 840));
    v14 = (ITEMIDLIST *)pv;
    sub_14007E270((LPCITEMIDLIST)pv, (LPWSTR)lParam, 0x8000u);
    SendMessageW(*(HWND *)(a1 + 48), 0x8037u, *(int *)(a1 + 836), (LPARAM)lParam);
    v15 = (_WORD *)(a1 + 144);
    v16 = 260i64;
    while ( v16 != -2147483386 )
    {
      v17 = *(_WORD *)((char *)v15 + (_QWORD)&lParam[-72] - a1);
      if ( !v17 )
        break;
      *v15++ = v17;
      if ( !--v16 )
      {
        --v15;
        break;
      }
    }
    *v15 = 0;
    if ( v19 )
      (*(void (__fastcall **)(_QWORD, ITEMIDLIST *))(**(_QWORD **)(a1 + 88) + 64i64))(*(_QWORD *)(a1 + 88), v14);
    if ( *(_DWORD *)(a1 + 700) )
      sub_140070F60(a1 - 16);
    *(_DWORD *)(a1 + 736) = 0;
    sub_1400689D0(a1 - 16, v14);
    CoTaskMemFree(v14);
    SendMessageW(*(HWND *)(a1 + 40), 0xBu, 0i64, 0i64);
    SendMessageW(*(HWND *)(a1 + 40), 0x1009u, 0i64, 0i64);
    *(_QWORD *)(a1 + 744) = 0i64;
    *(_QWORD *)(a1 + 664) = 0i64;
    *(_QWORD *)(a1 + 672) = 0i64;
    sub_14006A550(a1 - 16);
    sub_140074550(a1 - 16, *(_DWORD *)(a1 + 692));
    sub_14002AB60(a1 - 16, 0);
    sub_14006F0C0(a1 - 16);
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 - 16) + 32i64))(a1 - 16, *(unsigned int *)(a1 + 688));
    SendMessageW(*(HWND *)(a1 + 40), 0x1013u, 0i64, 0i64);
    SendMessageW(*(HWND *)(a1 + 40), 0xBu, 1ui64, 0i64);
    *(_DWORD *)(a1 + 700) = 1;
    v18 = LoadCursorW(0i64, (LPCWSTR)0x7F00);
    SetCursor(v18);
    ++*(_DWORD *)(a1 + 788);
    return 0i64;
  }
}
// 140068FD6: conditional instruction was optimized away because r11.8!=0
// 140068E10: using guessed type WCHAR lParam[264];

//----- (0000000140069120) ----------------------------------------------------
__int64 __fastcall sub_140069120(_WORD *a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // r8
  unsigned int v5; // er11
  __int64 v6; // r10
  __int16 v7; // ax
  __int64 result; // rax

  v3 = 32i64;
  v4 = a3 - (_QWORD)a1;
  v5 = 0;
  v6 = 0i64;
  while ( v3 != -2147483614 )
  {
    v7 = *(_WORD *)((char *)a1 + v4);
    if ( !v7 )
      break;
    *a1++ = v7;
    ++v6;
    if ( !--v3 )
    {
      --a1;
      v5 = -2147024774;
      --v6;
      break;
    }
  }
  *a1 = 0;
  result = v5;
  if ( a2 )
    *a2 = v6;
  return result;
}
// 14006916A: conditional instruction was optimized away because r9.8!=0

//----- (00000001400691C0) ----------------------------------------------------
__int64 __fastcall sub_1400691C0(__int64 a1, unsigned __int64 a2)
{
  if ( a2 > 2 )
    memset((void *)(a1 + 2), 0, a2 - 2);
  return 0i64;
}

//----- (0000000140069230) ----------------------------------------------------
__int64 __fastcall sub_140069230(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 1i64;
      break;
    case 2:
      result = 4i64;
      break;
    case 3:
      result = 3i64;
      break;
    case 4:
      result = 2i64;
      break;
    case 5:
      result = 10i64;
      break;
    case 6:
      result = 11i64;
      break;
    case 7:
      result = 12i64;
      break;
    case 8:
      result = 13i64;
      break;
    case 9:
      result = 14i64;
      break;
    case 10:
      result = 15i64;
      break;
    case 11:
      result = 16i64;
      break;
    case 12:
      result = 17i64;
      break;
    case 13:
      result = 18i64;
      break;
    case 14:
      result = 19i64;
      break;
    case 15:
      result = 20i64;
      break;
    case 16:
      result = 21i64;
      break;
    case 17:
      result = 22i64;
      break;
    case 18:
      result = 23i64;
      break;
    case 19:
      result = 24i64;
      break;
    case 20:
      result = 25i64;
      break;
    case 21:
      result = 26i64;
      break;
    case 22:
      result = 27i64;
      break;
    case 23:
      result = 7i64;
      break;
    case 24:
      result = 29i64;
      break;
    case 25:
      result = 30i64;
      break;
    case 26:
      result = 31i64;
      break;
    case 27:
      result = 32i64;
      break;
    case 28:
      result = 33i64;
      break;
    case 29:
      result = 5i64;
      break;
    case 30:
      result = 6i64;
      break;
    case 31:
      result = 34i64;
      break;
    case 32:
      result = 35i64;
      break;
    case 33:
      result = 9i64;
      break;
    case 34:
      result = 8i64;
      break;
    case 35:
      result = 36i64;
      break;
    case 36:
      result = 37i64;
      break;
    case 37:
      result = 38i64;
      break;
    case 38:
      result = 39i64;
      break;
    case 39:
      result = 40i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001400693F0) ----------------------------------------------------
LRESULT __fastcall sub_1400693F0(__int64 a1, unsigned int a2, int a3, int a4)
{
  WPARAM v5; // r12
  LPARAM v7; // rdi
  UINT v8; // eax
  int v9; // ebx
  HWND v10; // rax
  LPARAM lParam; // [rsp+20h] [rbp-128h] BYREF
  int v13; // [rsp+28h] [rbp-120h]
  WCHAR *v14; // [rsp+30h] [rbp-118h]
  LPARAM v15[8]; // [rsp+50h] [rbp-F8h] BYREF
  WCHAR Buffer[64]; // [rsp+90h] [rbp-B8h] BYREF

  v5 = a3;
  v7 = a2;
  v8 = SendMessageW(*(HWND *)(a1 + 64), 0x80CBu, a2, 0i64);
  LoadStringW(*(HINSTANCE *)(a1 + 144), v8, Buffer, 64);
  LODWORD(lParam) = 6;
  v14 = Buffer;
  v13 = a4;
  if ( (_DWORD)v7 == 3 || (_DWORD)v7 == 6 || (_DWORD)v7 == 29 || (_DWORD)v7 == 30 )
    lParam = 0x100000007i64;
  v9 = SendMessageW(*(HWND *)(a1 + 56), 0x1061u, v5, (LPARAM)&lParam);
  v10 = (HWND)SendMessageW(*(HWND *)(a1 + 56), 0x101Fu, 0i64, 0i64);
  LODWORD(v15[0]) = 8;
  v15[4] = v7;
  return SendMessageW(v10, 0x120Cu, v9, (LPARAM)v15);
}

//----- (0000000140069500) ----------------------------------------------------
LRESULT __fastcall sub_140069500(__int64 a1, int a2, int a3)
{
  WPARAM v5; // rsi
  IP_ADAPTER_ADDRESSES_LH *v6; // rbx
  HWND v7; // rcx
  ULONG SizePointer[4]; // [rsp+30h] [rbp-C8h] BYREF
  LPARAM lParam; // [rsp+40h] [rbp-B8h] BYREF
  int v11; // [rsp+48h] [rbp-B0h]
  WCHAR *p_Buffer; // [rsp+58h] [rbp-A0h]
  WCHAR Buffer; // [rsp+90h] [rbp-68h] BYREF
  __int64 v14; // [rsp+92h] [rbp-66h]
  __int64 v15; // [rsp+9Ah] [rbp-5Eh]
  __int64 v16; // [rsp+A2h] [rbp-56h]
  __int64 v17; // [rsp+AAh] [rbp-4Eh]
  __int64 v18; // [rsp+B2h] [rbp-46h]
  __int64 v19; // [rsp+BAh] [rbp-3Eh]
  __int64 v20; // [rsp+C2h] [rbp-36h]
  int v21; // [rsp+CAh] [rbp-2Eh]
  __int16 v22; // [rsp+CEh] [rbp-2Ah]

  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v5 = a2;
  Buffer = 0;
  SizePointer[0] = 0;
  GetAdaptersAddresses(0, 0, 0i64, 0i64, SizePointer);
  v6 = (IP_ADAPTER_ADDRESSES_LH *)malloc(SizePointer[0]);
  GetAdaptersAddresses(0, 0, 0i64, v6, SizePointer);
  free(v6);
  LoadStringW(*(HINSTANCE *)(a1 + 144), 0, &Buffer, 32);
  v7 = *(HWND *)(a1 + 56);
  p_Buffer = &Buffer;
  v11 = a3;
  return SendMessageW(v7, 0x1074u, v5, (LPARAM)&lParam);
}

//----- (0000000140069620) ----------------------------------------------------
__int64 __fastcall sub_140069620(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v4; // rdi
  LPWSTR ExtensionW; // rax
  HWND v8; // rcx
  void *v9; // rax
  LPARAM v11; // [rsp+20h] [rbp-A8h] BYREF
  int v12; // [rsp+28h] [rbp-A0h]
  void *v13; // [rsp+38h] [rbp-90h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-58h] BYREF

  v4 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    ExtensionW = PathFindExtensionW((LPCWSTR)(592i64 * lParam[10] + *(_QWORD *)(a1 + 88) + 44));
    v8 = *(HWND *)(a1 + 56);
    v12 = a4;
    if ( *ExtensionW == 46 )
      v9 = ExtensionW + 1;
    else
      v9 = &unk_1400E9FDC;
    v13 = v9;
    SendMessageW(v8, 0x1074u, v4, (LPARAM)&v11);
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (00000001400696E0) ----------------------------------------------------
__int64 __fastcall sub_1400696E0(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v4; // rdi
  int v7; // eax
  __int64 v8; // rcx
  bool v9; // cc
  __int64 v10; // rax
  __int64 v11; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-A8h] BYREF
  int v14; // [rsp+48h] [rbp-80h]
  LPARAM v15; // [rsp+70h] [rbp-58h] BYREF
  int v16; // [rsp+78h] [rbp-50h]
  __int64 v17; // [rsp+88h] [rbp-40h]

  v4 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v7 = lstrlenW((LPCWSTR)(592i64 * v14 + *(_QWORD *)(a1 + 88) + 564));
    v16 = a4;
    v8 = 592i64 * v14;
    v9 = v7 <= 0;
    v10 = *(_QWORD *)(a1 + 88);
    if ( v9 )
      v11 = v8 + v10 + 44;
    else
      v11 = v8 + v10 + 564;
    v17 = v11;
    SendMessageW(*(HWND *)(a1 + 56), 0x1074u, v4, (LPARAM)&v15);
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (00000001400697C0) ----------------------------------------------------
void __fastcall sub_1400697C0(__int64 a1, int a2, int a3)
{
  WPARAM v3; // rsi
  HWND v5; // rcx
  LPITEMIDLIST v7; // rbx
  HWND v8; // rcx
  _DWORD lParam[20]; // [rsp+30h] [rbp-388h] BYREF
  LPARAM v10; // [rsp+80h] [rbp-338h] BYREF
  int v11; // [rsp+88h] [rbp-330h]
  WCHAR *szTypeName; // [rsp+98h] [rbp-320h]
  SHFILEINFOW psfi; // [rsp+D0h] [rbp-2E8h] BYREF

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v7 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96)));
    SHGetFileInfoW(&v7->mkid.cb, 0, &psfi, 0x2B8u, 0x408u);
    v8 = *(HWND *)(a1 + 56);
    v11 = a3;
    szTypeName = psfi.szTypeName;
    SendMessageW(v8, 0x1074u, v3, (LPARAM)&v10);
    CoTaskMemFree(v7);
  }
}

//----- (00000001400698D0) ----------------------------------------------------
__int64 __fastcall sub_1400698D0(__int64 a1, unsigned int a2, int a3)
{
  WPARAM v5; // rdi
  HWND v6; // rcx
  LPARAM lParam; // [rsp+30h] [rbp-548h] BYREF
  int v9; // [rsp+38h] [rbp-540h]
  WCHAR *szTypeName; // [rsp+48h] [rbp-530h]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-4F8h] BYREF
  WCHAR pszPath[264]; // [rsp+340h] [rbp-238h] BYREF

  v5 = (int)a2;
  (*(void (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)(a1 + 16) + 96i64))(a1 + 16, a2, pszPath);
  SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x400u);
  v6 = *(HWND *)(a1 + 56);
  szTypeName = psfi.szTypeName;
  v9 = a3;
  SendMessageW(v6, 0x1074u, v5, (LPARAM)&lParam);
  return *(unsigned int *)(a1 + 752);
}

//----- (0000000140069980) ----------------------------------------------------
__int64 __fastcall sub_140069980(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 1168) + 8i64);
}

//----- (00000001400699A0) ----------------------------------------------------
LRESULT __fastcall sub_1400699A0(__int64 a1, int a2, int a3)
{
  WPARAM v3; // r12
  HWND v5; // rcx
  LRESULT result; // rax
  BYTE *v8; // rdi
  _BYTE *v9; // r8
  __int64 v10; // rdx
  __int16 *v11; // rcx
  signed __int64 v12; // r8
  __int16 v13; // ax
  HWND v14; // rcx
  DWORD cbBuf; // [rsp+30h] [rbp-D0h] BYREF
  HANDLE phPrinter; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[20]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v18; // [rsp+90h] [rbp-70h] BYREF
  int v19; // [rsp+98h] [rbp-68h]
  __int16 *v20; // [rsp+A8h] [rbp-58h]
  __int16 v21; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v22; // [rsp+E2h] [rbp-1Eh]
  __int64 v23; // [rsp+EAh] [rbp-16h]
  __int64 v24; // [rsp+F2h] [rbp-Eh]
  __int64 v25; // [rsp+FAh] [rbp-6h]
  __int64 v26; // [rsp+102h] [rbp+2h]
  __int64 v27; // [rsp+10Ah] [rbp+Ah]
  __int64 v28; // [rsp+112h] [rbp+12h]
  int v29; // [rsp+11Ah] [rbp+1Ah]
  __int16 v30; // [rsp+11Eh] [rbp+1Eh]

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  v21 = 0;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  result = SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    if ( OpenPrinterW((LPWSTR)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96) + 8), &phPrinter, 0i64) )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = (BYTE *)malloc(cbBuf);
      if ( GetPrinterW(phPrinter, 2u, v8, cbBuf, &cbBuf) )
      {
        v9 = &unk_1400EA214;
        v10 = 32i64;
        if ( *((_QWORD *)v8 + 4) )
          v9 = (_BYTE *)*((_QWORD *)v8 + 4);
        v11 = &v21;
        v12 = v9 - (_BYTE *)&v21;
        while ( v10 != -2147483614 )
        {
          v13 = *(__int16 *)((char *)v11 + v12);
          if ( !v13 )
            break;
          *v11++ = v13;
          if ( !--v10 )
          {
            --v11;
            break;
          }
        }
        *v11 = 0;
      }
      free(v8);
    }
    v14 = *(HWND *)(a1 + 56);
    v20 = &v21;
    v19 = a3;
    return SendMessageW(v14, 0x1074u, v3, (LPARAM)&v18);
  }
  return result;
}
// 140069AF7: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140069B60) ----------------------------------------------------
LRESULT __fastcall sub_140069B60(__int64 a1, int a2, int a3)
{
  WPARAM v3; // r12
  HWND v5; // rcx
  LRESULT result; // rax
  BYTE *v8; // rdi
  _BYTE *v9; // r8
  __int64 v10; // rdx
  __int16 *v11; // rcx
  signed __int64 v12; // r8
  __int16 v13; // ax
  HWND v14; // rcx
  DWORD cbBuf; // [rsp+30h] [rbp-D0h] BYREF
  HANDLE phPrinter; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[20]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v18; // [rsp+90h] [rbp-70h] BYREF
  int v19; // [rsp+98h] [rbp-68h]
  __int16 *v20; // [rsp+A8h] [rbp-58h]
  __int16 v21; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v22; // [rsp+E2h] [rbp-1Eh]
  __int64 v23; // [rsp+EAh] [rbp-16h]
  __int64 v24; // [rsp+F2h] [rbp-Eh]
  __int64 v25; // [rsp+FAh] [rbp-6h]
  __int64 v26; // [rsp+102h] [rbp+2h]
  __int64 v27; // [rsp+10Ah] [rbp+Ah]
  __int64 v28; // [rsp+112h] [rbp+12h]
  int v29; // [rsp+11Ah] [rbp+1Ah]
  __int16 v30; // [rsp+11Eh] [rbp+1Eh]

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  v21 = 0;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  result = SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    if ( OpenPrinterW((LPWSTR)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96) + 8), &phPrinter, 0i64) )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = (BYTE *)malloc(cbBuf);
      if ( GetPrinterW(phPrinter, 2u, v8, cbBuf, &cbBuf) )
      {
        v9 = &unk_1400EA214;
        v10 = 32i64;
        if ( *((_QWORD *)v8 + 6) )
          v9 = (_BYTE *)*((_QWORD *)v8 + 6);
        v11 = &v21;
        v12 = v9 - (_BYTE *)&v21;
        while ( v10 != -2147483614 )
        {
          v13 = *(__int16 *)((char *)v11 + v12);
          if ( !v13 )
            break;
          *v11++ = v13;
          if ( !--v10 )
          {
            --v11;
            break;
          }
        }
        *v11 = 0;
      }
      free(v8);
    }
    v14 = *(HWND *)(a1 + 56);
    v20 = &v21;
    v19 = a3;
    return SendMessageW(v14, 0x1074u, v3, (LPARAM)&v18);
  }
  return result;
}
// 140069CB7: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140069D20) ----------------------------------------------------
LRESULT __fastcall sub_140069D20(__int64 a1, int a2, int a3)
{
  WPARAM v3; // r12
  HWND v5; // rcx
  LRESULT result; // rax
  BYTE *v8; // rdi
  _BYTE *v9; // r8
  __int64 v10; // rdx
  __int16 *v11; // rcx
  signed __int64 v12; // r8
  __int16 v13; // ax
  HWND v14; // rcx
  DWORD cbBuf; // [rsp+30h] [rbp-D0h] BYREF
  HANDLE phPrinter; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[20]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v18; // [rsp+90h] [rbp-70h] BYREF
  int v19; // [rsp+98h] [rbp-68h]
  __int16 *v20; // [rsp+A8h] [rbp-58h]
  __int16 v21; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v22; // [rsp+E2h] [rbp-1Eh]
  __int64 v23; // [rsp+EAh] [rbp-16h]
  __int64 v24; // [rsp+F2h] [rbp-Eh]
  __int64 v25; // [rsp+FAh] [rbp-6h]
  __int64 v26; // [rsp+102h] [rbp+2h]
  __int64 v27; // [rsp+10Ah] [rbp+Ah]
  __int64 v28; // [rsp+112h] [rbp+12h]
  int v29; // [rsp+11Ah] [rbp+1Ah]
  __int16 v30; // [rsp+11Eh] [rbp+1Eh]

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  v21 = 0;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  result = SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    if ( OpenPrinterW((LPWSTR)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96) + 8), &phPrinter, 0i64) )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = (BYTE *)malloc(cbBuf);
      if ( GetPrinterW(phPrinter, 2u, v8, cbBuf, &cbBuf) )
      {
        v9 = &unk_1400EA214;
        v10 = 32i64;
        if ( *((_QWORD *)v8 + 5) )
          v9 = (_BYTE *)*((_QWORD *)v8 + 5);
        v11 = &v21;
        v12 = v9 - (_BYTE *)&v21;
        while ( v10 != -2147483614 )
        {
          v13 = *(__int16 *)((char *)v11 + v12);
          if ( !v13 )
            break;
          *v11++ = v13;
          if ( !--v10 )
          {
            --v11;
            break;
          }
        }
        *v11 = 0;
      }
      free(v8);
    }
    v14 = *(HWND *)(a1 + 56);
    v20 = &v21;
    v19 = a3;
    return SendMessageW(v14, 0x1074u, v3, (LPARAM)&v18);
  }
  return result;
}
// 140069E77: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140069EE0) ----------------------------------------------------
LRESULT __fastcall sub_140069EE0(__int64 a1, int a2, int a3)
{
  WPARAM v3; // r12
  HWND v5; // rcx
  LRESULT result; // rax
  BYTE *v8; // rsi
  const wchar_t *v9; // rax
  const wchar_t *v10; // r8
  __int64 v11; // rdx
  __int16 *v12; // rcx
  signed __int64 v13; // r8
  __int16 v14; // ax
  HWND v15; // rcx
  DWORD cbBuf; // [rsp+30h] [rbp-D0h] BYREF
  HANDLE phPrinter; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[20]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v19; // [rsp+90h] [rbp-70h] BYREF
  int v20; // [rsp+98h] [rbp-68h]
  __int16 *v21; // [rsp+A8h] [rbp-58h]
  __int16 v22; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v23; // [rsp+E2h] [rbp-1Eh]
  __int64 v24; // [rsp+EAh] [rbp-16h]
  __int64 v25; // [rsp+F2h] [rbp-Eh]
  __int64 v26; // [rsp+FAh] [rbp-6h]
  __int64 v27; // [rsp+102h] [rbp+2h]
  __int64 v28; // [rsp+10Ah] [rbp+Ah]
  __int64 v29; // [rsp+112h] [rbp+12h]
  int v30; // [rsp+11Ah] [rbp+1Ah]
  __int16 v31; // [rsp+11Eh] [rbp+1Eh]

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  v22 = 0;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0;
  v31 = 0;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  result = SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    if ( OpenPrinterW((LPWSTR)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96) + 8), &phPrinter, 0i64) )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = (BYTE *)malloc(cbBuf);
      if ( GetPrinterW(phPrinter, 2u, v8, cbBuf, &cbBuf) )
      {
        v9 = sub_140080780(*((_DWORD *)v8 + 31));
        v10 = (const wchar_t *)&unk_1400EA214;
        v11 = 32i64;
        v12 = &v22;
        if ( v9 )
          v10 = v9;
        v13 = (char *)v10 - (char *)&v22;
        while ( v11 != -2147483614 )
        {
          v14 = *(__int16 *)((char *)v12 + v13);
          if ( !v14 )
            break;
          *v12++ = v14;
          if ( !--v11 )
          {
            --v12;
            break;
          }
        }
        *v12 = 0;
      }
      free(v8);
      ClosePrinter(phPrinter);
    }
    v15 = *(HWND *)(a1 + 56);
    v21 = &v22;
    v20 = a3;
    return SendMessageW(v15, 0x1074u, v3, (LPARAM)&v19);
  }
  return result;
}
// 14006A03A: conditional instruction was optimized away because rdx.8!=0

//----- (000000014006A0B0) ----------------------------------------------------
void __fastcall sub_14006A0B0(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
  v2 = *(_QWORD ***)(a1 + 1104);
  v3 = *v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 1104) + 8i64) = *(_QWORD *)(a1 + 1104);
  *(_QWORD *)(a1 + 1112) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 1104) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 1104) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
}

//----- (000000014006A140) ----------------------------------------------------
void __fastcall sub_14006A140(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
  v2 = *(_QWORD ***)(a1 + 1032);
  v3 = *v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8i64) = *(_QWORD *)(a1 + 1032);
  *(_QWORD *)(a1 + 1040) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 1032) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 1032) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
}

//----- (000000014006A1D0) ----------------------------------------------------
int __fastcall sub_14006A1D0(__int64 a1)
{
  int v2; // ebp
  __int64 **v3; // rax
  __int64 ***v4; // rsi
  __int64 *i; // rbx
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  v2 = 0;
  sub_14007E090(3, psz2);
  LODWORD(v3) = StrCmpW((PCWSTR)(a1 + 160), psz2);
  if ( (_DWORD)v3 )
  {
    sub_14007E090(17, psz2);
    LODWORD(v3) = StrCmpW((PCWSTR)(a1 + 160), psz2);
    if ( (_DWORD)v3 )
    {
      LODWORD(v3) = sub_14006EC20(a1, 10);
      if ( (_DWORD)v3 )
      {
        v4 = (__int64 ***)(a1 + 1264);
      }
      else
      {
        LODWORD(v3) = sub_14006EC20(a1, 4);
        if ( (_DWORD)v3 )
        {
          v4 = (__int64 ***)(a1 + 1288);
        }
        else
        {
          LODWORD(v3) = sub_14006EC20(a1, 49);
          if ( (_DWORD)v3 )
          {
            v4 = (__int64 ***)(a1 + 1312);
          }
          else
          {
            LODWORD(v3) = sub_14006EC20(a1, 18);
            v4 = (__int64 ***)(a1 + 1336);
            if ( !(_DWORD)v3 )
              v4 = (__int64 ***)(a1 + 1192);
          }
        }
      }
    }
    else
    {
      v4 = (__int64 ***)(a1 + 1216);
    }
  }
  else
  {
    v4 = (__int64 ***)(a1 + 1240);
  }
  if ( *(_DWORD *)(a1 + 708) == 4 )
  {
    v3 = *v4;
    for ( i = **v4; i != (__int64 *)*v4; i = (__int64 *)*i )
    {
      if ( *((_DWORD *)i + 5) )
      {
        LODWORD(v3) = SendMessageW(*(HWND *)(a1 + 56), 0x101Du, v2++, 0i64);
        *((_DWORD *)i + 6) = (_DWORD)v3;
      }
    }
  }
  return (int)v3;
}

//----- (000000014006A340) ----------------------------------------------------
LRESULT __fastcall sub_14006A340(__int64 a1)
{
  int v2; // esi
  int v3; // edi
  int v4; // er12
  HWND v5; // rax
  __int64 ***v6; // rdx
  HWND v7; // rbp
  __int64 *v8; // rcx
  unsigned int v9; // er11
  __int64 **v10; // rax
  __int64 *v11; // r8
  LRESULT result; // rax
  int lParam[7]; // [rsp+20h] [rbp-48h] BYREF
  unsigned int v14; // [rsp+3Ch] [rbp-2Ch]

  v2 = 0;
  v3 = 0;
  v4 = -1;
  v5 = (HWND)SendMessageW(*(HWND *)(a1 + 56), 0x101Fu, 0i64, 0i64);
  v6 = *(__int64 ****)(a1 + 1184);
  v7 = v5;
  v8 = **v6;
  if ( v8 == (__int64 *)*v6 )
    goto LABEL_13;
  while ( !*((_DWORD *)v8 + 5) )
  {
LABEL_5:
    v8 = (__int64 *)*v8;
    if ( v8 == (__int64 *)*v6 )
      goto LABEL_13;
  }
  if ( *(_DWORD *)(a1 + 1372) != *((_DWORD *)v8 + 4) )
  {
    ++v3;
    goto LABEL_5;
  }
  lParam[0] = 4;
  SendMessageW(v5, 0x120Bu, v3, (LPARAM)lParam);
  if ( (v14 & 0x400) != 0 )
  {
    v9 = v14 & 0xFFFFFBFF;
    goto LABEL_11;
  }
  if ( (v14 & 0x200) != 0 )
  {
    v9 = v14 & 0xFFFFFDFF;
LABEL_11:
    v14 = v9;
  }
  SendMessageW(v7, 0x120Cu, v3, (LPARAM)lParam);
LABEL_13:
  v10 = *(__int64 ***)(a1 + 1184);
  v11 = (__int64 *)**v10;
  if ( v11 == *v10 )
    goto LABEL_20;
  while ( 2 )
  {
    if ( !*((_DWORD *)v11 + 5) )
    {
LABEL_17:
      v11 = (__int64 *)*v11;
      if ( v11 == **(__int64 ***)(a1 + 1184) )
        goto LABEL_20;
      continue;
    }
    break;
  }
  if ( (unsigned int)sub_140069230(*((_DWORD *)v11 + 4)) != *(_DWORD *)(a1 + 704) )
  {
    ++v2;
    goto LABEL_17;
  }
  v4 = *((_DWORD *)v11 + 4);
LABEL_20:
  lParam[0] = 4;
  SendMessageW(v7, 0x120Bu, v2, (LPARAM)lParam);
  if ( *(_DWORD *)(a1 + 820) )
    v14 |= 0x400u;
  else
    v14 |= 0x200u;
  result = SendMessageW(v7, 0x120Cu, v2, (LPARAM)lParam);
  *(_DWORD *)(a1 + 1372) = v4;
  return result;
}
// 14006A441: variable 'v11' is possibly undefined
// 14006A340: using guessed type _DWORD lParam[7];

//----- (000000014006A4D0) ----------------------------------------------------
__int64 __fastcall sub_14006A4D0(__int64 a1, int a2)
{
  int v2; // er8
  __int64 **v4; // rcx
  unsigned int v5; // edi
  int v6; // er9
  __int64 *i; // rax

  v2 = 0;
  v4 = **(__int64 ****)(a1 + 1168);
  v5 = 0;
  v6 = 0;
  for ( i = *v4; i != (__int64 *)v4; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 5) )
    {
      if ( v2 == a2 )
      {
        v5 = sub_140069230(*((_DWORD *)i + 4));
        break;
      }
      ++v2;
    }
  }
  if ( *(_DWORD *)(a1 + 1356) == v6 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 464i64))(a1);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 - 16) + 32i64))(a1 - 16, v5);
}
// 14006A524: variable 'v6' is possibly undefined

//----- (000000014006A550) ----------------------------------------------------
__int64 __fastcall sub_14006A550(__int64 a1)
{
  __int64 result; // rax
  bool v3; // zf
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(3, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 160), psz2) )
  {
    sub_14007E090(17, psz2);
    if ( StrCmpW((PCWSTR)(a1 + 160), psz2) )
    {
      if ( sub_14006EC20(a1, 10) )
      {
        result = a1 + 1264;
      }
      else if ( sub_14006EC20(a1, 4) )
      {
        result = a1 + 1288;
      }
      else if ( sub_14006EC20(a1, 49) )
      {
        result = a1 + 1312;
      }
      else
      {
        v3 = !sub_14006EC20(a1, 18);
        result = a1 + 1336;
        if ( v3 )
          result = a1 + 1192;
      }
    }
    else
    {
      result = a1 + 1216;
    }
  }
  else
  {
    result = a1 + 1240;
  }
  if ( *(_QWORD *)(a1 + 1184) != result )
  {
    *(_QWORD *)(a1 + 1184) = result;
    *(_DWORD *)(a1 + 1360) = 0;
  }
  return result;
}

//----- (000000014006A680) ----------------------------------------------------
_QWORD **__fastcall sub_14006A680(__int64 a1)
{
  _QWORD **result; // rax
  int v2; // esi
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  int v6; // ecx
  int v7; // ebx

  result = *(_QWORD ***)(a1 + 1184);
  v2 = 0;
  *(_DWORD *)(a1 + 1368) = 0;
  if ( result )
  {
    v4 = *result;
    v5 = (_QWORD *)*v4;
    if ( (_QWORD *)*v4 != v4 )
    {
      do
      {
        if ( *((_DWORD *)v5 + 5) )
        {
          sub_1400693F0(a1, *((_DWORD *)v5 + 4), v2++, *((_DWORD *)v5 + 6));
          ++*(_DWORD *)(a1 + 1368);
        }
        v5 = (_QWORD *)*v5;
      }
      while ( v5 != **(_QWORD ***)(a1 + 1184) );
    }
    v6 = *(_DWORD *)(a1 + 1368);
    v7 = v6 + *(_DWORD *)(a1 + 1364);
    if ( v7 >= v6 )
    {
      do
        SendMessageW(*(HWND *)(a1 + 56), 0x101Cu, v7--, 0i64);
      while ( v7 >= *(_DWORD *)(a1 + 1368) );
    }
    result = (_QWORD **)*(unsigned int *)(a1 + 1368);
    *(_DWORD *)(a1 + 1364) = (_DWORD)result;
  }
  return result;
}

//----- (000000014006A750) ----------------------------------------------------
LRESULT __fastcall sub_14006A750(__int64 a1, int a2, int a3)
{
  WPARAM v4; // r12
  HWND v5; // rcx
  LRESULT result; // rax
  BYTE *v8; // rdi
  HWND v9; // rcx
  DWORD cbBuf; // [rsp+30h] [rbp-D0h] BYREF
  HANDLE phPrinter; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[20]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v13; // [rsp+90h] [rbp-70h] BYREF
  int v14; // [rsp+98h] [rbp-68h]
  wchar_t *v15; // [rsp+A8h] [rbp-58h]
  wchar_t v16; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v17; // [rsp+E2h] [rbp-1Eh]
  __int64 v18; // [rsp+EAh] [rbp-16h]
  __int64 v19; // [rsp+F2h] [rbp-Eh]
  __int64 v20; // [rsp+FAh] [rbp-6h]
  __int64 v21; // [rsp+102h] [rbp+2h]
  __int64 v22; // [rsp+10Ah] [rbp+Ah]
  __int64 v23; // [rsp+112h] [rbp+12h]
  int v24; // [rsp+11Ah] [rbp+1Ah]
  __int16 v25; // [rsp+11Eh] [rbp+1Eh]

  v4 = a2;
  v16 = 0;
  lParam[2] = 0;
  v5 = *(HWND *)(a1 + 56);
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0;
  v25 = 0;
  lParam[0] = 4;
  lParam[1] = a2;
  result = SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    if ( OpenPrinterW((LPWSTR)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96) + 8), &phPrinter, 0i64) )
    {
      GetPrinterW(phPrinter, 2u, 0i64, 0, &cbBuf);
      v8 = (BYTE *)malloc(cbBuf);
      if ( GetPrinterW(phPrinter, 2u, v8, cbBuf, &cbBuf) )
        sub_140001000(&v16, 0x20ui64, L"%d", *((unsigned int *)v8 + 32));
      free(v8);
    }
    v9 = *(HWND *)(a1 + 56);
    v15 = &v16;
    v14 = a3;
    return SendMessageW(v9, 0x1074u, v4, (LPARAM)&v13);
  }
  return result;
}
// 1400EA2A8: using guessed type wchar_t aD[3];

//----- (000000014006A8D0) ----------------------------------------------------
__int64 __fastcall sub_14006A8D0(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v4; // rdi
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  __int64 v10; // rax
  unsigned int v11; // eax
  __int16 *v12; // rax
  HWND v13; // rcx
  LPARAM v15; // [rsp+20h] [rbp-328h] BYREF
  int v16; // [rsp+28h] [rbp-320h]
  __int16 *v17; // [rsp+38h] [rbp-310h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-2D8h] BYREF
  __int16 v19[32]; // [rsp+C0h] [rbp-288h] BYREF
  WCHAR pszPath[264]; // [rsp+100h] [rbp-248h] BYREF

  v4 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v7 = 260i64;
    v8 = pszPath;
    while ( v7 != -2147483386 )
    {
      v9 = *(WCHAR *)((char *)v8 + a1 + 160 - (_QWORD)pszPath);
      if ( !v9 )
        break;
      *v8++ = v9;
      if ( !--v7 )
      {
        --v8;
        break;
      }
    }
    v10 = *(_QWORD *)(a1 + 88);
    *v8 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592i64 * lParam[10] + v10 + 44));
    v11 = sub_140081380(pszPath);
    if ( v11 == -1 )
    {
      v12 = (__int16 *)&unk_1400E9FB4;
    }
    else
    {
      sub_140001000((wchar_t *)v19, 0x20ui64, L"%ld", v11);
      v12 = v19;
    }
    v13 = *(HWND *)(a1 + 56);
    v16 = a4;
    v17 = v12;
    SendMessageW(v13, 0x1074u, v4, (LPARAM)&v15);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006A977: conditional instruction was optimized away because rdx.8!=0
// 1400EA2A0: using guessed type wchar_t aLd[4];
// 14006A8D0: using guessed type wchar_t var_288[32];

//----- (000000014006AA30) ----------------------------------------------------
void __fastcall sub_14006AA30(__int64 a1, int a2, int a3)
{
  WPARAM v3; // rsi
  HWND v5; // rcx
  ITEMIDLIST *v7; // r13
  __int64 v8; // rbx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  WCHAR *v11; // rax
  HWND v12; // rcx
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp-C0h] BYREF
  void *ppv; // [rsp+48h] [rbp-B8h] BYREF
  LPARAM v15; // [rsp+50h] [rbp-B0h] BYREF
  int v16; // [rsp+58h] [rbp-A8h]
  WCHAR *v17; // [rsp+68h] [rbp-98h]
  _DWORD lParam[20]; // [rsp+A0h] [rbp-60h] BYREF
  STRRET pstr; // [rsp+F0h] [rbp-10h] BYREF
  WCHAR FileSystemNameBuffer[264]; // [rsp+200h] [rbp+100h] BYREF
  WCHAR pszBuf[264]; // [rsp+410h] [rbp+310h] BYREF

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  ppv = 0i64;
  ppidlLast = 0i64;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v7 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96)));
    SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast);
    (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
      ppv,
      ppidlLast,
      0x8000i64,
      &pstr);
    v8 = 260i64;
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    if ( PathIsRootW(pszBuf) )
    {
      if ( !GetVolumeInformationW(pszBuf, 0i64, 0, 0i64, 0i64, 0i64, FileSystemNameBuffer, 0x104u) )
      {
        v9 = FileSystemNameBuffer;
        while ( v8 != -2147483386 )
        {
          v10 = *(WCHAR *)((char *)v9 + &unk_1400E9DEC - (_UNKNOWN *)FileSystemNameBuffer);
          if ( !v10 )
            break;
          *v9++ = v10;
          if ( !--v8 )
          {
            v11 = FileSystemNameBuffer;
            *(v9 - 1) = 0;
            goto LABEL_12;
          }
        }
        *v9 = 0;
      }
      v11 = FileSystemNameBuffer;
    }
    else
    {
      v11 = (WCHAR *)&unk_1400E9DFC;
    }
LABEL_12:
    v12 = *(HWND *)(a1 + 56);
    v16 = a3;
    v17 = v11;
    SendMessageW(v12, 0x1074u, v3, (LPARAM)&v15);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    CoTaskMemFree(v7);
  }
}
// 14006ABB5: conditional instruction was optimized away because rbx.8!=0

//----- (000000014006AC40) ----------------------------------------------------
__int64 __fastcall sub_14006AC40(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v5; // rdi
  _DWORD lParam[20]; // [rsp+20h] [rbp-A8h] BYREF
  LPARAM v10; // [rsp+70h] [rbp-58h] BYREF
  int v11; // [rsp+78h] [rbp-50h]
  WCHAR *v12; // [rsp+88h] [rbp-40h]

  v5 = a3;
  lParam[0] = 4;
  lParam[2] = 0;
  lParam[1] = a3;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v11 = a4;
    v12 = sub_140068810(a1, lParam[10]);
    SendMessageW(a2, 0x1074u, v5, (LPARAM)&v10);
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (000000014006ACF0) ----------------------------------------------------
__int64 __fastcall sub_14006ACF0(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // ebx
  void *v5; // rcx
  _DWORD *v6; // rbx

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
  SetEvent(*(HANDLE *)(a1 + 1168));
  if ( *(_QWORD *)(a1 + 1112) )
  {
    v5 = *(void **)(a1 + 1168);
    v6 = *(_DWORD **)(*(_QWORD *)(a1 + 1104) + 8i64);
    *a2 = v6[4];
    ResetEvent(v5);
    if ( v6 != *(_DWORD **)(a1 + 1104) )
    {
      **((_QWORD **)v6 + 1) = *(_QWORD *)v6;
      *(_QWORD *)(*(_QWORD *)v6 + 8i64) = *((_QWORD *)v6 + 1);
      j_free(v6);
      --*(_QWORD *)(a1 + 1112);
    }
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
  return v4;
}

//----- (000000014006ADB0) ----------------------------------------------------
__int64 __fastcall sub_14006ADB0(__int64 a1, _DWORD *a2)
{
  unsigned int v4; // ebx
  _DWORD *v5; // rbx

  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
  if ( *(_QWORD *)(a1 + 1040) )
  {
    v5 = **(_DWORD ***)(a1 + 1032);
    *a2 = v5[4];
    ResetEvent(*(HANDLE *)(a1 + 1096));
    if ( v5 != *(_DWORD **)(a1 + 1032) )
    {
      **((_QWORD **)v5 + 1) = *(_QWORD *)v5;
      *(_QWORD *)(*(_QWORD *)v5 + 8i64) = *((_QWORD *)v5 + 1);
      j_free(v5);
      --*(_QWORD *)(a1 + 1040);
    }
    v4 = 1;
  }
  else
  {
    SetEvent(*(HANDLE *)(a1 + 1096));
    v4 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
  return v4;
}

//----- (000000014006AE70) ----------------------------------------------------
__int64 **__fastcall sub_14006AE70(__int64 **a1, __int64 **a2)
{
  sub_14006A1D0((__int64)(a1 - 2));
  sub_14000BD40(a2 + 6, a1 + 153);
  sub_14000BD40(a2 + 3, a1 + 150);
  sub_14000BD40(a2 + 18, a1 + 165);
  sub_14000BD40(a2 + 15, a1 + 162);
  sub_14000BD40(a2 + 12, a1 + 159);
  sub_14000BD40(a2, a1 + 147);
  return sub_14000BD40(a2 + 9, a1 + 156);
}

//----- (000000014006AF10) ----------------------------------------------------
__int64 __fastcall sub_14006AF10(__int64 a1, HWND a2, int a3, int a4, int a5)
{
  WPARAM v5; // rdi
  __int64 v8; // rdx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  __int64 v11; // rax
  int v12; // eax
  HWND v13; // rcx
  bool v14; // zf
  __int16 *v15; // rax
  LPARAM v17; // [rsp+20h] [rbp-6E8h] BYREF
  int v18; // [rsp+28h] [rbp-6E0h]
  __int16 *v19; // [rsp+38h] [rbp-6D0h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-698h] BYREF
  WCHAR pszPath[264]; // [rsp+C0h] [rbp-648h] BYREF
  __int16 v22[512]; // [rsp+2D0h] [rbp-438h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v8 = 260i64;
    v9 = pszPath;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v9 + a1 + 160 - (_QWORD)pszPath);
      if ( !v10 )
        break;
      *v9++ = v10;
      if ( !--v8 )
      {
        --v9;
        break;
      }
    }
    v11 = *(_QWORD *)(a1 + 88);
    *v9 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592i64 * lParam[10] + v11 + 44));
    v12 = sub_140082350((__int64)pszPath, a5, (WCHAR *)v22);
    v13 = *(HWND *)(a1 + 56);
    v18 = a4;
    v14 = v12 == 0;
    v15 = v22;
    if ( v14 )
      v15 = (__int16 *)&unk_1400EA014;
    v19 = v15;
    SendMessageW(v13, 0x1074u, v5, (LPARAM)&v17);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006AFB7: conditional instruction was optimized away because rdx.8!=0
// 14006AF10: using guessed type WCHAR var_438[512];

//----- (000000014006B060) ----------------------------------------------------
__int64 __fastcall sub_14006B060(__int64 a1, HWND a2, int a3, int a4, int a5)
{
  WPARAM v5; // rdi
  __int64 v8; // rdx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  __int64 v11; // rax
  int v12; // eax
  HWND v13; // rcx
  bool v14; // zf
  __int16 *v15; // rax
  LPARAM v17; // [rsp+20h] [rbp-6E8h] BYREF
  int v18; // [rsp+28h] [rbp-6E0h]
  __int16 *v19; // [rsp+38h] [rbp-6D0h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-698h] BYREF
  WCHAR pszPath[264]; // [rsp+C0h] [rbp-648h] BYREF
  __int16 v22[512]; // [rsp+2D0h] [rbp-438h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v8 = 260i64;
    v9 = pszPath;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v9 + a1 + 160 - (_QWORD)pszPath);
      if ( !v10 )
        break;
      *v9++ = v10;
      if ( !--v8 )
      {
        --v9;
        break;
      }
    }
    v11 = *(_QWORD *)(a1 + 88);
    *v9 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592i64 * lParam[10] + v11 + 44));
    v12 = sub_140082600((__int64)pszPath, a5, (WCHAR *)v22);
    v13 = *(HWND *)(a1 + 56);
    v18 = a4;
    v14 = v12 == -1;
    v15 = (__int16 *)&unk_1400E9FFC;
    if ( !v14 )
      v15 = v22;
    v19 = v15;
    SendMessageW(v13, 0x1074u, v5, (LPARAM)&v17);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006B107: conditional instruction was optimized away because rdx.8!=0
// 14006B060: using guessed type WCHAR var_438[512];

//----- (000000014006B1B0) ----------------------------------------------------
__int64 __fastcall sub_14006B1B0(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v4; // rdi
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  __int64 v10; // rax
  bool v11; // sf
  __int16 *v12; // rax
  HWND v13; // rcx
  LPARAM v15; // [rsp+30h] [rbp-7B8h] BYREF
  int v16; // [rsp+38h] [rbp-7B0h]
  __int16 *v17; // [rsp+48h] [rbp-7A0h]
  _DWORD lParam[20]; // [rsp+80h] [rbp-768h] BYREF
  SHFILEINFOW psfi; // [rsp+D0h] [rbp-718h] BYREF
  WCHAR pszPath[264]; // [rsp+390h] [rbp-458h] BYREF
  __int16 v21[264]; // [rsp+5A0h] [rbp-248h] BYREF

  v4 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v7 = 260i64;
    v8 = pszPath;
    while ( v7 != -2147483386 )
    {
      v9 = *(WCHAR *)((char *)v8 + a1 + 160 - (_QWORD)pszPath);
      if ( !v9 )
        break;
      *v8++ = v9;
      if ( !--v7 )
      {
        --v8;
        break;
      }
    }
    v10 = *(_QWORD *)(a1 + 88);
    *v8 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592i64 * lParam[10] + v10 + 44));
    if ( !SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x800u)
      || (v11 = (int)sub_1400D2C10(0i64, 1u, (__int64)pszPath, v21, (__int64)&psfi) < 0, v12 = v21, v11) )
    {
      v12 = (__int16 *)&unk_1400E9FA4;
    }
    v13 = *(HWND *)(a1 + 56);
    v16 = a4;
    v17 = v12;
    SendMessageW(v13, 0x1074u, v4, (LPARAM)&v15);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006B267: conditional instruction was optimized away because rdx.8!=0
// 14006B1B0: using guessed type _WORD var_248[264];

//----- (000000014006B350) ----------------------------------------------------
__int64 __fastcall sub_14006B350(__int64 a1, HWND a2, int a3, int a4, __int64 a5)
{
  WPARAM v5; // rdi
  __int64 v8; // rdx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  __int64 v11; // rax
  DWORD FileVersionInfoSizeW; // eax
  bool v13; // zf
  __int16 *v14; // rax
  HWND v15; // rcx
  int dwHandle[4]; // [rsp+20h] [rbp-6F8h] BYREF
  LPARAM v18; // [rsp+30h] [rbp-6E8h] BYREF
  int v19; // [rsp+38h] [rbp-6E0h]
  __int16 *v20; // [rsp+48h] [rbp-6D0h]
  _DWORD lParam[20]; // [rsp+80h] [rbp-698h] BYREF
  WCHAR pszPath[264]; // [rsp+D0h] [rbp-648h] BYREF
  __int16 v23[512]; // [rsp+2E0h] [rbp-438h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v8 = 260i64;
    v9 = pszPath;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v9 + a1 + 160 - (_QWORD)pszPath);
      if ( !v10 )
        break;
      *v9++ = v10;
      if ( !--v8 )
      {
        --v9;
        break;
      }
    }
    v11 = *(_QWORD *)(a1 + 88);
    *v9 = 0;
    PathAppendW(pszPath, (LPCWSTR)(592i64 * lParam[10] + v11 + 44));
    dwHandle[0] = 0;
    FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszPath, (LPDWORD)dwHandle);
    if ( !FileVersionInfoSizeW
      || (v13 = (unsigned int)sub_140082920(pszPath, a5, v23, FileVersionInfoSizeW) == 0, v14 = v23, v13) )
    {
      v14 = (__int16 *)&unk_1400E9F84;
    }
    v15 = *(HWND *)(a1 + 56);
    v19 = a4;
    v20 = v14;
    SendMessageW(v15, 0x1074u, v5, (LPARAM)&v18);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006B408: conditional instruction was optimized away because rdx.8!=0
// 14006B350: using guessed type DWORD dwHandle[4];
// 14006B350: using guessed type _WORD var_438[512];

//----- (000000014006B4D0) ----------------------------------------------------
__int64 __fastcall sub_14006B4D0(__int64 a1, unsigned int a2, int a3)
{
  WPARAM v5; // rdi
  HWND v6; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-688h] BYREF
  int v9; // [rsp+28h] [rbp-680h]
  wchar_t *v10; // [rsp+38h] [rbp-670h]
  WCHAR FileName[264]; // [rsp+70h] [rbp-638h] BYREF
  wchar_t v12[512]; // [rsp+280h] [rbp-428h] BYREF

  v5 = (int)a2;
  memset(v12, 0, sizeof(v12));
  if ( (*(int (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)(a1 + 16) + 96i64))(a1 + 16, a2, FileName) >= 0 )
  {
    sub_140082CD0(FileName, v12);
    v6 = *(HWND *)(a1 + 56);
    v10 = v12;
    v9 = a3;
    SendMessageW(v6, 0x1074u, v5, (LPARAM)&lParam);
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (000000014006B590) ----------------------------------------------------
__int64 __fastcall sub_14006B590(__int64 a1, unsigned int a2, int a3)
{
  WPARAM v5; // rdi
  __int64 v6; // rdx
  char *v7; // rcx
  __int16 v8; // ax
  HANDLE v9; // r11
  HWND v10; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-518h] BYREF
  int v13; // [rsp+28h] [rbp-510h]
  char *v14; // [rsp+38h] [rbp-500h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+70h] [rbp-4C8h] BYREF
  char v16[64]; // [rsp+2C0h] [rbp-278h] BYREF
  WCHAR FileName[264]; // [rsp+300h] [rbp-238h] BYREF

  v5 = (int)a2;
  if ( (*(int (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)(a1 + 16) + 96i64))(a1 + 16, a2, FileName) >= 0 )
  {
    if ( FindFirstFileW(FileName, &FindFileData) == (HANDLE)-1i64 )
    {
      v6 = 32i64;
      v7 = v16;
      while ( v6 != -2147483614 )
      {
        v8 = *(_WORD *)&v7[&unk_1400EAC9C - (_UNKNOWN *)v16];
        if ( !v8 )
          break;
        *(_WORD *)v7 = v8;
        v7 += 2;
        if ( !--v6 )
        {
          *((_WORD *)v7 - 1) = 0;
          goto LABEL_10;
        }
      }
      *(_WORD *)v7 = 0;
    }
    else
    {
      sub_140082FB0(FindFileData.dwFileAttributes, v16, 0x20u);
      FindClose(v9);
    }
LABEL_10:
    v10 = *(HWND *)(a1 + 56);
    v14 = v16;
    v13 = a3;
    SendMessageW(v10, 0x1074u, v5, (LPARAM)&lParam);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006B640: conditional instruction was optimized away because rdx.8!=0
// 14006B667: variable 'v9' is possibly undefined

//----- (000000014006B6C0) ----------------------------------------------------
__int64 __fastcall sub_14006B6C0(__int64 a1, HWND a2, int a3, int a4, int a5)
{
  WPARAM v5; // rdi
  const FILETIME *v8; // rcx
  bool v9; // zf
  char *v10; // rax
  HWND v11; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-148h] BYREF
  int v14; // [rsp+48h] [rbp-120h]
  LPARAM v15; // [rsp+70h] [rbp-F8h] BYREF
  int v16; // [rsp+78h] [rbp-F0h]
  char *v17; // [rsp+88h] [rbp-E0h]
  char v18[128]; // [rsp+C0h] [rbp-A8h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        v8 = (const FILETIME *)(592i64 * v14 + *(_QWORD *)(a1 + 88) + 4);
      }
      else
      {
        if ( a5 != 2 )
        {
LABEL_10:
          v10 = (char *)&unk_1400E9F54;
LABEL_11:
          v11 = *(HWND *)(a1 + 56);
          v16 = a4;
          v17 = v10;
          SendMessageW(v11, 0x1074u, v5, (LPARAM)&v15);
          return *(unsigned int *)(a1 + 752);
        }
        v8 = (const FILETIME *)(592i64 * v14 + *(_QWORD *)(a1 + 88) + 12);
      }
    }
    else
    {
      v8 = (const FILETIME *)(592i64 * v14 + *(_QWORD *)(a1 + 88) + 20);
    }
    if ( v8 )
    {
      v9 = (unsigned int)sub_1400835A0(v8, v18, 64, *(_DWORD *)(a1 + 824)) == -1;
      v10 = v18;
      if ( !v9 )
        goto LABEL_11;
    }
    goto LABEL_10;
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (000000014006B7F0) ----------------------------------------------------
char **__fastcall sub_14006B7F0(__int64 a1, int a2)
{
  __int64 v2; // rdi
  char *v4; // r11
  __int64 v5; // rax
  char **result; // rax
  int v7; // [rsp+38h] [rbp+10h] BYREF

  v7 = a2;
  v2 = *(_QWORD *)(a1 + 1104);
  v4 = sub_1400246F0(v2, *(_QWORD *)(v2 + 8), &v7);
  v5 = *(_QWORD *)(a1 + 1112);
  if ( v5 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 1112) = v5 + 1;
  *(_QWORD *)(v2 + 8) = v4;
  result = (char **)*((_QWORD *)v4 + 1);
  *result = v4;
  return result;
}

//----- (000000014006B870) ----------------------------------------------------
char **__fastcall sub_14006B870(__int64 a1, int a2)
{
  __int64 v2; // rdi
  char *v4; // r11
  __int64 v5; // rax
  char **result; // rax
  int v7; // [rsp+38h] [rbp+10h] BYREF

  v7 = a2;
  v2 = *(_QWORD *)(a1 + 1032);
  v4 = sub_1400246F0(v2, *(_QWORD *)(v2 + 8), &v7);
  v5 = *(_QWORD *)(a1 + 1040);
  if ( v5 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 1040) = v5 + 1;
  *(_QWORD *)(v2 + 8) = v4;
  result = (char **)*((_QWORD *)v4 + 1);
  *result = v4;
  return result;
}

//----- (000000014006B8F0) ----------------------------------------------------
LRESULT __fastcall sub_14006B8F0(_QWORD *a1, int a2, int a3)
{
  WPARAM v3; // rbp
  HWND v5; // rcx
  int v7; // edi
  WCHAR *v8; // rbx
  WCHAR *v9; // rax
  HWND v10; // rcx
  LPARAM lParam; // [rsp+30h] [rbp-488h] BYREF
  int v13; // [rsp+38h] [rbp-480h]
  WCHAR *v14; // [rsp+48h] [rbp-470h]
  int v15; // [rsp+58h] [rbp-460h]
  WCHAR String[512]; // [rsp+80h] [rbp-438h] BYREF

  v3 = a2;
  v5 = (HWND)a1[7];
  v7 = 0;
  LODWORD(lParam) = 4;
  HIDWORD(lParam) = a2;
  v13 = 0;
  if ( (unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)&lParam)
    && (int)sub_14007F650(a1[8], a1[17], a1[12] + 568i64 * v15, String, 0x200u) >= 0 )
  {
    if ( lstrlenW(String) > 0 )
    {
      v8 = String;
      do
      {
        if ( *v8 == 10 )
          *v8 = 32;
        ++v7;
        ++v8;
      }
      while ( v7 < lstrlenW(String) );
    }
    v9 = String;
  }
  else
  {
    v9 = (WCHAR *)&unk_1400EA024;
  }
  v10 = (HWND)a1[7];
  v13 = a3;
  v14 = v9;
  return SendMessageW(v10, 0x1074u, v3, (LPARAM)&lParam);
}

//----- (000000014006BA40) ----------------------------------------------------
char *__fastcall sub_14006BA40(__int64 a1, char **a2)
{
  sub_140073AB0(a1 + 1224, a2 + 6);
  sub_140073AB0(a1 + 1200, a2 + 3);
  sub_140073AB0(a1 + 1320, a2 + 18);
  sub_140073AB0(a1 + 1296, a2 + 15);
  sub_140073AB0(a1 + 1272, a2 + 12);
  sub_140073AB0(a1 + 1176, a2);
  return sub_140073AB0(a1 + 1248, a2 + 9);
}

//----- (000000014006BAE0) ----------------------------------------------------
void __fastcall sub_14006BAE0(__int64 a1, int a2, int a3, int a4)
{
  WPARAM v4; // rdi
  HWND v6; // rcx
  ITEMIDLIST *v9; // r13
  int v10; // er9
  char *v11; // rax
  __int64 v12; // rdx
  char *v13; // rcx
  __int16 v14; // ax
  HWND v15; // rcx
  int v16; // [rsp+20h] [rbp-E0h]
  LPCITEMIDLIST ppidlLast; // [rsp+30h] [rbp-D0h] BYREF
  void *ppv; // [rsp+38h] [rbp-C8h] BYREF
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [rsp+40h] [rbp-C0h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+48h] [rbp-B8h] BYREF
  LPARAM v21; // [rsp+50h] [rbp-B0h] BYREF
  int v22; // [rsp+58h] [rbp-A8h]
  char *v23; // [rsp+68h] [rbp-98h]
  _DWORD lParam[20]; // [rsp+A0h] [rbp-60h] BYREF
  STRRET pstr; // [rsp+F0h] [rbp-10h] BYREF
  char v26[64]; // [rsp+200h] [rbp+100h] BYREF
  WCHAR pszBuf[264]; // [rsp+240h] [rbp+140h] BYREF

  v4 = a2;
  v6 = *(HWND *)(a1 + 56);
  ppv = 0i64;
  ppidlLast = 0i64;
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v6, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v9 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 96)));
    SHBindToParent(v9, &stru_1400E3FB0, &ppv, &ppidlLast);
    (*(void (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
      ppv,
      ppidlLast,
      0x8000i64,
      &pstr);
    StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
    if ( PathIsRootW(pszBuf) )
    {
      if ( GetDiskFreeSpaceExW(pszBuf, 0i64, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) )
      {
        v10 = *(_DWORD *)(a1 + 744);
        v16 = *(_DWORD *)(a1 + 748);
        if ( a4 )
          sub_140083DE0(TotalNumberOfBytes.QuadPart, v26, 0x20ui64, v10, v16);
        else
          sub_140083DE0(TotalNumberOfFreeBytes.QuadPart, v26, 0x20ui64, v10, v16);
        v11 = v26;
      }
      else
      {
        v12 = 32i64;
        v13 = v26;
        while ( v12 != -2147483614 )
        {
          v14 = *(_WORD *)&v13[&unk_1400E9DCC - (_UNKNOWN *)v26];
          if ( !v14 )
            break;
          *(_WORD *)v13 = v14;
          v13 += 2;
          if ( !--v12 )
          {
            v11 = v26;
            *((_WORD *)v13 - 1) = 0;
            goto LABEL_15;
          }
        }
        *(_WORD *)v13 = 0;
        v11 = v26;
      }
    }
    else
    {
      v11 = (char *)&unk_1400E9DDC;
    }
LABEL_15:
    v15 = *(HWND *)(a1 + 56);
    v22 = a3;
    v23 = v11;
    SendMessageW(v15, 0x1074u, v4, (LPARAM)&v21);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    CoTaskMemFree(v9);
  }
}
// 14006BC98: conditional instruction was optimized away because rdx.8!=0

//----- (000000014006BD20) ----------------------------------------------------
__int64 __fastcall sub_14006BD20(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v5; // rsi
  __int64 v8; // rdx
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  __int64 v11; // r8
  char *v12; // rcx
  __int16 v13; // ax
  __int64 v14; // r9
  __int64 v15; // r8
  unsigned int v16; // ecx
  DWORD v17; // er11
  unsigned int v18; // eax
  int v19; // er9
  DWORD BytesPerSector[2]; // [rsp+30h] [rbp-D0h] BYREF
  DWORD SectorsPerCluster; // [rsp+38h] [rbp-C8h] BYREF
  _DWORD lParam[10]; // [rsp+40h] [rbp-C0h] BYREF
  int v24; // [rsp+68h] [rbp-98h]
  LPARAM v25; // [rsp+90h] [rbp-70h] BYREF
  int v26; // [rsp+98h] [rbp-68h]
  char *v27; // [rsp+A8h] [rbp-58h]
  char v28[64]; // [rsp+E0h] [rbp-20h] BYREF
  WCHAR pszPath[264]; // [rsp+120h] [rbp+20h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[1] = a3;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v8 = 260i64;
    v9 = pszPath;
    while ( v8 != -2147483386 )
    {
      v10 = *(WCHAR *)((char *)v9 + a1 + 160 - (_QWORD)pszPath);
      if ( !v10 )
        break;
      *v9++ = v10;
      if ( !--v8 )
      {
        --v9;
        break;
      }
    }
    *v9 = 0;
    PathStripToRootW(pszPath);
    if ( (*(_BYTE *)(592i64 * v24 + *(_QWORD *)(a1 + 88)) & 0x10) != 0 )
    {
      v11 = 32i64;
      v12 = v28;
      while ( v11 != -2147483614 )
      {
        v13 = *(_WORD *)&v12[&unk_1400E9DBC - (_UNKNOWN *)v28];
        if ( !v13 )
          break;
        *(_WORD *)v12 = v13;
        v12 += 2;
        if ( !--v11 )
        {
          *((_WORD *)v12 - 1) = 0;
          goto LABEL_18;
        }
      }
      *(_WORD *)v12 = 0;
    }
    else
    {
      GetDiskFreeSpaceW(pszPath, &SectorsPerCluster, BytesPerSector, 0i64, 0i64);
      v14 = *(_QWORD *)(a1 + 88);
      v15 = 592i64 * v24;
      v16 = *(_DWORD *)(v15 + v14 + 32);
      v17 = BytesPerSector[0] * SectorsPerCluster;
      if ( v16 && v16 % v17 )
        v16 += v17 - v16 % v17;
      v18 = *(_DWORD *)(v15 + v14 + 28);
      v19 = *(_DWORD *)(a1 + 744);
      *(_QWORD *)BytesPerSector = __PAIR64__(v18, v16);
      sub_140083DE0(__SPAIR64__(v18, v16), v28, 0x20ui64, v19, *(_DWORD *)(a1 + 748));
    }
LABEL_18:
    v26 = a4;
    v27 = v28;
    SendMessageW(a2, 0x1074u, v5, (LPARAM)&v25);
  }
  return *(unsigned int *)(a1 + 752);
}
// 14006BDC7: conditional instruction was optimized away because rdx.8!=0
// 14006BE41: conditional instruction was optimized away because r8.8!=0

//----- (000000014006BF20) ----------------------------------------------------
__int64 __fastcall sub_14006BF20(__int64 a1, HWND a2, int a3, int a4)
{
  WPARAM v5; // rsi
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v11; // [rsp+30h] [rbp-128h]
  _DWORD lParam[20]; // [rsp+40h] [rbp-118h] BYREF
  LPARAM v13; // [rsp+90h] [rbp-C8h] BYREF
  int v14; // [rsp+98h] [rbp-C0h]
  char *v15; // [rsp+A8h] [rbp-B0h]
  char v16[64]; // [rsp+E0h] [rbp-78h] BYREF

  v5 = a3;
  lParam[0] = 4;
  lParam[2] = 0;
  lParam[1] = a3;
  if ( (unsigned int)SendMessageW(a2, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    v8 = *(_QWORD *)(a1 + 88);
    v9 = 592i64 * lParam[10];
    if ( (*(_BYTE *)(v9 + v8) & 0x10) == 0 )
    {
      LODWORD(v11) = *(_DWORD *)(v8 + v9 + 32);
      HIDWORD(v11) = *(_DWORD *)(v8 + v9 + 28);
      sub_140083DE0(v11, v16, 0x20ui64, *(_DWORD *)(a1 + 744), *(_DWORD *)(a1 + 748));
      v15 = v16;
      v14 = a4;
      SendMessageW(a2, 0x1074u, v5, (LPARAM)&v13);
    }
  }
  return *(unsigned int *)(a1 + 752);
}

//----- (000000014006C030) ----------------------------------------------------
__int64 __fastcall sub_14006C030(__int64 a1)
{
  int v2; // esi
  int v3; // er12
  HWND v4; // rcx
  __int64 **v5; // rax
  __int64 *v6; // rbx
  HWND v7; // rcx
  __int64 v8; // rcx
  HWND v9; // rcx
  int v10; // ebx
  _DWORD *v11; // rbx
  int v13; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v14; // [rsp+38h] [rbp-C8h] BYREF
  int v15[4]; // [rsp+40h] [rbp-C0h] BYREF
  _DWORD v16[10]; // [rsp+50h] [rbp-B0h] BYREF
  int v17; // [rsp+78h] [rbp-88h]
  _DWORD lParam[20]; // [rsp+A0h] [rbp-60h] BYREF
  LPARAM v19; // [rsp+F0h] [rbp-10h] BYREF
  int v20; // [rsp+F8h] [rbp-8h]
  char *v21; // [rsp+108h] [rbp+8h]
  char v22[64]; // [rsp+140h] [rbp+40h] BYREF
  char v23[528]; // [rsp+180h] [rbp+80h] BYREF

  v2 = 0;
  if ( (unsigned int)sub_14006ACF0(a1, &v13) )
  {
    v3 = v13;
    do
    {
      v4 = *(HWND *)(a1 + 56);
      lParam[0] = 4;
      lParam[1] = v3;
      lParam[2] = 0;
      SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam);
      if ( (*(_BYTE *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 88)) & 0x10) != 0 )
      {
        v5 = *(__int64 ***)(a1 + 1184);
        v6 = (__int64 *)**v5;
        if ( v6 != *v5 )
        {
          do
          {
            if ( *((_DWORD *)v6 + 5) )
            {
              if ( *((_DWORD *)v6 + 4) == 3 )
              {
                v7 = *(HWND *)(a1 + 56);
                v16[0] = 4;
                v16[1] = v3;
                v16[2] = 0;
                if ( (unsigned int)SendMessageW(v7, 0x104Bu, 0i64, (LPARAM)v16) )
                {
                  (*(void (__fastcall **)(__int64, _QWORD, char *))(*(_QWORD *)(a1 + 16) + 96i64))(
                    a1 + 16,
                    (unsigned int)v3,
                    v23);
                  sub_1400D6760((__int64)v23, v15, &v13, &v14);
                  if ( *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4i64 * v17) == 1 )
                  {
                    v8 = v14;
                    *(_DWORD *)(592i64 * v17 + *(_QWORD *)(a1 + 88) + 32) = v14;
                    *(_DWORD *)(592i64 * v17 + *(_QWORD *)(a1 + 88) + 28) = HIDWORD(v14);
                    *(_DWORD *)(568i64 * v17 + *(_QWORD *)(a1 + 96) + 544) = 1;
                    sub_140083DE0(v8, v22, 0x20ui64, *(_DWORD *)(a1 + 744), *(_DWORD *)(a1 + 748));
                    v9 = *(HWND *)(a1 + 56);
                    v20 = v2;
                    v21 = v22;
                    SendMessageW(v9, 0x1074u, v3, (LPARAM)&v19);
                  }
                }
              }
              if ( *((_DWORD *)v6 + 5) )
                ++v2;
            }
            v6 = (__int64 *)*v6;
          }
          while ( v6 != **(__int64 ***)(a1 + 1184) );
        }
      }
      v2 = 0;
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
      SetEvent(*(HANDLE *)(a1 + 1168));
      if ( *(_QWORD *)(a1 + 1112) )
      {
        v11 = *(_DWORD **)(*(_QWORD *)(a1 + 1104) + 8i64);
        v3 = v11[4];
        ResetEvent(*(HANDLE *)(a1 + 1168));
        if ( v11 != *(_DWORD **)(a1 + 1104) )
        {
          **((_QWORD **)v11 + 1) = *(_QWORD *)v11;
          *(_QWORD *)(*(_QWORD *)v11 + 8i64) = *((_QWORD *)v11 + 1);
          j_free(v11);
          --*(_QWORD *)(a1 + 1112);
        }
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
    }
    while ( v10 );
  }
  sub_14006A340(a1);
  return 0i64;
}
// 14006C030: using guessed type int var_380[4];

//----- (000000014006D410) ----------------------------------------------------
void __fastcall sub_14006D410(__int64 a1, int a2, unsigned int a3, unsigned int a4)
{
  WPARAM v5; // rdi
  HWND v7; // rcx
  __int64 v8; // rax
  bool v9; // zf
  char *v10; // rax
  HWND v11; // rcx
  __int64 v12; // r9
  LPARAM v13; // [rsp+30h] [rbp-148h] BYREF
  unsigned int v14; // [rsp+38h] [rbp-140h]
  char *v15; // [rsp+48h] [rbp-130h]
  _DWORD lParam[10]; // [rsp+80h] [rbp-F8h] BYREF
  int v17; // [rsp+A8h] [rbp-D0h]
  char v18[128]; // [rsp+D0h] [rbp-A8h] BYREF

  v5 = (int)a3;
  switch ( a2 )
  {
    case 1:
      sub_14006AC40(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 2:
      sub_1400698D0(a1, a3, a4);
      return;
    case 3:
      sub_14006BF20(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 4:
      sub_14006B6C0(a1, *(HWND *)(a1 + 56), a3, a4, 0);
      return;
    case 5:
      sub_14006B590(a1, a3, a4);
      return;
    case 6:
      sub_14006BD20(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 7:
      sub_1400696E0(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 8:
      sub_14006B4D0(a1, a3, a4);
      return;
    case 9:
      sub_14006B350(a1, *(HWND *)(a1 + 56), a3, a4, (__int64)L"ProductName");
      return;
    case 10:
      sub_14006B350(a1, *(HWND *)(a1 + 56), a3, a4, (__int64)L"CompanyName");
      return;
    case 11:
      sub_14006B350(a1, *(HWND *)(a1 + 56), a3, a4, (__int64)L"FileDescription");
      return;
    case 12:
      sub_14006B350(a1, *(HWND *)(a1 + 56), a3, a4, (__int64)L"FileVersion");
      return;
    case 13:
      sub_14006B350(a1, *(HWND *)(a1 + 56), a3, a4, (__int64)L"ProductVersion");
      return;
    case 14:
      sub_14006B1B0(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 15:
      sub_14006A8D0(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 16:
      sub_140069620(a1, *(HWND *)(a1 + 56), a3, a4);
      return;
    case 17:
      sub_14006B6C0(a1, *(HWND *)(a1 + 56), a3, a4, 1);
      return;
    case 18:
      v7 = *(HWND *)(a1 + 56);
      lParam[0] = 4;
      lParam[1] = a3;
      lParam[2] = 0;
      if ( (unsigned int)SendMessageW(v7, 0x104Bu, 0i64, (LPARAM)lParam) )
      {
        v8 = *(_QWORD *)(a1 + 88);
        if ( 592i64 * v17 + v8 == -12
          || (v9 = (unsigned int)sub_1400835A0(
                                   (const FILETIME *)(592i64 * v17 + v8 + 12),
                                   v18,
                                   64,
                                   *(_DWORD *)(a1 + 824)) == -1,
              v10 = v18,
              v9) )
        {
          v10 = (char *)&unk_1400E9F54;
        }
        v11 = *(HWND *)(a1 + 56);
        v14 = a4;
        v15 = v10;
        SendMessageW(v11, 0x1074u, v5, (LPARAM)&v13);
      }
      return;
    case 19:
      sub_14006B060(a1, *(HWND *)(a1 + 56), a3, a4, 2);
      return;
    case 20:
      sub_14006B060(a1, *(HWND *)(a1 + 56), a3, a4, 3);
      return;
    case 21:
      sub_14006B060(a1, *(HWND *)(a1 + 56), a3, a4, 4);
      return;
    case 22:
      sub_14006B060(a1, *(HWND *)(a1 + 56), a3, a4, 5);
      return;
    case 23:
      sub_14006B060(a1, *(HWND *)(a1 + 56), a3, a4, 6);
      return;
    case 24:
      sub_14006AF10(a1, *(HWND *)(a1 + 56), a3, a4, 272);
      return;
    case 25:
      sub_14006AF10(a1, *(HWND *)(a1 + 56), a3, a4, 36867);
      return;
    case 26:
      sub_14006AF10(a1, *(HWND *)(a1 + 56), a3, a4, 256);
      return;
    case 27:
      sub_14006AF10(a1, *(HWND *)(a1 + 56), a3, a4, 257);
      return;
    case 28:
      sub_14006B8F0((_QWORD *)a1, a3, a4);
      return;
    case 29:
      sub_14006BAE0(a1, a3, a4, 1);
      return;
    case 30:
      sub_14006BAE0(a1, a3, a4, 0);
      return;
    case 31:
      sub_14006AA30(a1, a3, a4);
      return;
    case 32:
      sub_1400697C0(a1, a3, a4);
      return;
    case 35:
      sub_14006A750(a1, a3, a4);
      return;
    case 36:
      sub_140069EE0(a1, a3, a4);
      return;
    case 37:
      sub_140069D20(a1, a3, a4);
      return;
    case 38:
      sub_140069B60(a1, a3, a4);
      return;
    case 39:
      sub_140069500(a1, a3, a4);
      return;
    case 40:
      v12 = 0i64;
      goto LABEL_68;
    case 41:
      v12 = 1i64;
      goto LABEL_68;
    case 42:
      v12 = 2i64;
      goto LABEL_68;
    case 43:
      v12 = 3i64;
      goto LABEL_68;
    case 44:
      v12 = 4i64;
      goto LABEL_68;
    case 45:
      v12 = 5i64;
      goto LABEL_68;
    case 46:
      v12 = 6i64;
      goto LABEL_68;
    case 47:
      v12 = 7i64;
      goto LABEL_68;
    case 48:
      v12 = 8i64;
      goto LABEL_68;
    case 49:
      v12 = 9i64;
      goto LABEL_68;
    case 50:
      v12 = 10i64;
      goto LABEL_68;
    case 51:
      v12 = 11i64;
      goto LABEL_68;
    case 52:
      v12 = 12i64;
      goto LABEL_68;
    case 53:
      v12 = 13i64;
      goto LABEL_68;
    case 54:
      v12 = 14i64;
      goto LABEL_68;
    case 55:
      v12 = 15i64;
      goto LABEL_68;
    case 56:
      v12 = 16i64;
      goto LABEL_68;
    case 57:
      v12 = 17i64;
      goto LABEL_68;
    case 58:
      v12 = 18i64;
      goto LABEL_68;
    case 59:
      v12 = 19i64;
      goto LABEL_68;
    case 60:
      v12 = 20i64;
      goto LABEL_68;
    case 61:
      v12 = 21i64;
      goto LABEL_68;
    case 62:
      v12 = 22i64;
      goto LABEL_68;
    case 63:
      v12 = 23i64;
LABEL_68:
      sub_14006C300(a1, a3, a4, v12);
      break;
    case 64:
      sub_1400699A0(a1, a3, a4);
      break;
    default:
      return;
  }
}
// 14006C300: using guessed type __int64 __fastcall sub_14006C300(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400EA218: using guessed type wchar_t aProductname_2[12];
// 1400EA230: using guessed type wchar_t aCompanyname_0[12];
// 1400EA248: using guessed type wchar_t aFiledescriptio_0[16];
// 1400EA268: using guessed type wchar_t aFileversion_0[12];
// 1400EA280: using guessed type wchar_t aProductversion_0[15];

//----- (000000014006DA70) ----------------------------------------------------
__int64 __fastcall sub_14006DA70(__int64 a1)
{
  __int64 *v2; // rax
  __int64 *v3; // rsi
  unsigned int v4; // er12
  void **v5; // rax
  _QWORD *v6; // r13
  _QWORD *v7; // rbx
  __int64 *v8; // rcx
  __int64 *v9; // rdi
  _DWORD *v10; // rbx
  void *v11; // rcx
  int v12; // ebx
  _DWORD *v13; // rbx
  __int64 *v14; // rcx
  __int64 *v15; // rbx
  void *Block; // [rsp+28h] [rbp-60h] BYREF
  __int64 v18; // [rsp+30h] [rbp-58h]
  __int64 pExceptionObject[9]; // [rsp+40h] [rbp-48h] BYREF
  unsigned int v20; // [rsp+98h] [rbp+10h] BYREF
  char *v21; // [rsp+A0h] [rbp+18h] BYREF

  v18 = 0i64;
  v2 = (__int64 *)operator new(0x20ui64);
  v3 = v2;
  if ( !v2 )
  {
    v21 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v2;
  *v2 = (__int64)v2;
  v2[1] = (__int64)v2;
  v4 = 0;
  v5 = *(void ***)(a1 + 1184);
  if ( &Block != v5 )
  {
    v6 = *v5;
    v7 = *(_QWORD **)*v5;
    v8 = (__int64 *)*v3;
    *v3 = (__int64)v3;
    v3[1] = (__int64)v3;
    v18 = 0i64;
    if ( v8 != v3 )
    {
      do
      {
        v9 = (__int64 *)*v8;
        j_free(v8);
        v8 = v9;
      }
      while ( v9 != v3 );
    }
    sub_14000BDC0((__int64)&Block, *v3, v7, v6);
    v3 = (__int64 *)Block;
  }
  if ( (unsigned int)sub_14006ADB0(a1, &v20) )
  {
    while ( !*(_DWORD *)(a1 + 2568) )
    {
      v3 = (__int64 *)Block;
      v10 = *(_DWORD **)Block;
      if ( *(void **)Block != Block )
      {
        while ( !*(_DWORD *)(a1 + 2568) )
        {
          if ( v10[5] )
            sub_14006D410(a1, v10[4], v20, v4++);
          v10 = *(_DWORD **)v10;
          v3 = (__int64 *)Block;
          if ( v10 == Block )
            goto LABEL_13;
        }
        break;
      }
LABEL_13:
      v4 = 0;
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
      v11 = *(void **)(a1 + 1096);
      if ( *(_QWORD *)(a1 + 1040) )
      {
        v13 = **(_DWORD ***)(a1 + 1032);
        v20 = v13[4];
        ResetEvent(v11);
        if ( v13 != *(_DWORD **)(a1 + 1032) )
        {
          **((_QWORD **)v13 + 1) = *(_QWORD *)v13;
          *(_QWORD *)(*(_QWORD *)v13 + 8i64) = *((_QWORD *)v13 + 1);
          j_free(v13);
          --*(_QWORD *)(a1 + 1040);
        }
        v12 = 1;
      }
      else
      {
        SetEvent(v11);
        v12 = 0;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
      if ( !v12 )
        goto LABEL_21;
    }
    v3 = (__int64 *)Block;
  }
  else
  {
LABEL_21:
    sub_14006A340(a1);
  }
  v14 = (__int64 *)*v3;
  *v3 = (__int64)v3;
  v3[1] = (__int64)v3;
  if ( v14 != v3 )
  {
    do
    {
      v15 = (__int64 *)*v14;
      j_free(v14);
      v14 = v15;
    }
    while ( v15 != v3 );
  }
  j_free(v3);
  return 1i64;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014006DCC0) ----------------------------------------------------
__int64 __fastcall sub_14006DCC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 788);
}

//----- (000000014006DCD0) ----------------------------------------------------
void __fastcall sub_14006DCD0(__int64 a1, const WCHAR *a2)
{
  int v4; // edi
  HWND v5; // rcx
  __int64 v6; // rax
  __int64 v7; // r11
  LPARAM v8; // rdi
  __int64 v9; // rcx
  int v10; // eax
  HWND v11; // rcx
  int v12; // eax
  int v13; // eax
  LPARAM v14[6]; // [rsp+20h] [rbp-88h] BYREF
  _DWORD lParam[10]; // [rsp+50h] [rbp-58h] BYREF
  int v16; // [rsp+78h] [rbp-30h]
  __int64 v17; // [rsp+B0h] [rbp+8h]

  v4 = 0;
  if ( *(int *)(a1 + 752) > 0 )
  {
    while ( 1 )
    {
      v5 = *(HWND *)(a1 + 56);
      lParam[0] = 4;
      lParam[1] = v4;
      lParam[2] = 0;
      SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
      v6 = *(_QWORD *)(a1 + 96);
      v7 = 568i64 * v16;
      if ( *(_DWORD *)(v7 + v6 + 548) )
      {
        if ( !lstrcmpW(a2, (LPCWSTR)(v7 + v6 + 552)) )
          break;
      }
      if ( ++v4 >= *(_DWORD *)(a1 + 752) )
        return;
    }
    if ( v16 != -1 )
    {
      v8 = v16;
      CoTaskMemFree(*(LPVOID *)(568i64 * v16 + *(_QWORD *)(a1 + 96)));
      v9 = *(_QWORD *)(a1 + 88);
      LODWORD(v17) = *(_DWORD *)(592 * v8 + v9 + 32);
      v10 = *(_DWORD *)(592 * v8 + v9 + 28);
      v11 = *(HWND *)(a1 + 56);
      HIDWORD(v17) = v10;
      LODWORD(v14[0]) = 1;
      v14[2] = v8;
      *(_QWORD *)(a1 + 680) -= v17;
      v12 = SendMessageW(v11, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v14);
      if ( v12 != -1 )
        SendMessageW(*(HWND *)(a1 + 56), 0x1008u, v12, 0i64);
      *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4 * v8) = 0;
      v13 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
      --*(_DWORD *)(a1 + 752);
      if ( !v13 && !*(_DWORD *)(a1 + 2560) )
        SendMessageW(*(HWND *)(a1 + 64), 0x80C9u, *(int *)(a1 + 852), 1i64);
    }
  }
}

//----- (000000014006DE80) ----------------------------------------------------
__int64 __fastcall sub_14006DE80(__int64 a1)
{
  return *(unsigned int *)(a1 + 56);
}

//----- (000000014006DE90) ----------------------------------------------------
_BOOL8 __fastcall sub_14006DE90(__int64 a1)
{
  _BOOL8 result; // rax

  result = *(_DWORD *)(a1 + 816) == 0;
  *(_DWORD *)(a1 + 816) = result;
  return result;
}

//----- (000000014006DEB0) ----------------------------------------------------
__int64 __fastcall sub_14006DEB0(__int64 a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 816) = a2;
  return a2;
}

//----- (000000014006DEC0) ----------------------------------------------------
__int64 __fastcall sub_14006DEC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 816);
}

//----- (000000014006DED0) ----------------------------------------------------
__int64 __fastcall sub_14006DED0(__int64 a1)
{
  return *(unsigned int *)(a1 + 796);
}

//----- (000000014006DEE0) ----------------------------------------------------
__int64 __fastcall sub_14006DEE0(__int64 a1)
{
  return *(unsigned int *)(a1 + 804);
}

//----- (000000014006DEF0) ----------------------------------------------------
__int64 __fastcall sub_14006DEF0(__int64 a1)
{
  return *(unsigned int *)(a1 + 804);
}

//----- (000000014006DF00) ----------------------------------------------------
__int64 __fastcall sub_14006DF00(__int64 a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 804) = a2;
  return a2;
}

//----- (000000014006DF10) ----------------------------------------------------
_BOOL8 __fastcall sub_14006DF10(__int64 a1)
{
  _BOOL8 result; // rax

  result = *(_DWORD *)(a1 + 804) == 0;
  *(_DWORD *)(a1 + 804) = result;
  return result;
}

//----- (000000014006DF30) ----------------------------------------------------
__int64 __fastcall sub_14006DF30(__int64 a1)
{
  return *(unsigned int *)(a1 + 2548);
}

//----- (000000014006DF40) ----------------------------------------------------
void __fastcall sub_14006DF40(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 2548) = a2;
}

//----- (000000014006DF50) ----------------------------------------------------
__int64 __fastcall sub_14006DF50(__int64 a1)
{
  return *(unsigned int *)(a1 + 2544);
}

//----- (000000014006DF60) ----------------------------------------------------
__int64 __fastcall sub_14006DF60(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  *a2 = *(_QWORD *)(a1 + 664);
  result = *(_QWORD *)(a1 + 672);
  a2[1] = result;
  return result;
}

//----- (000000014006DF80) ----------------------------------------------------
__int64 __fastcall sub_14006DF80(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 744) + *(_DWORD *)(a1 + 748));
}

//----- (000000014006DFA0) ----------------------------------------------------
__int64 __fastcall sub_14006DFA0(__int64 a1)
{
  return *(unsigned int *)(a1 + 748);
}

//----- (000000014006DFB0) ----------------------------------------------------
__int64 __fastcall sub_14006DFB0(__int64 a1)
{
  return *(unsigned int *)(a1 + 744);
}

//----- (000000014006DFC0) ----------------------------------------------------
__int64 __fastcall sub_14006DFC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 736);
}

//----- (000000014006DFD0) ----------------------------------------------------
__int64 __fastcall sub_14006DFD0(__int64 a1, int a2, int a3)
{
  WPARAM v3; // rdi
  HWND v5; // rcx
  HWND v8; // rcx
  LPARAM v9; // [rsp+20h] [rbp-A8h] BYREF
  int v10; // [rsp+2Ch] [rbp-9Ch]
  int v11; // [rsp+30h] [rbp-98h]
  _DWORD lParam[20]; // [rsp+70h] [rbp-58h] BYREF

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    if ( (*(_BYTE *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 88)) & 2) != 0 )
      return 0i64;
    v8 = *(HWND *)(a1 + 56);
    v11 = 4;
    v10 = 4;
    if ( !a3 )
      v10 = 0;
    SendMessageW(v8, 0x102Bu, v3, (LPARAM)&v9);
  }
  return 1i64;
}

//----- (000000014006E090) ----------------------------------------------------
__int64 __fastcall sub_14006E090(__int64 a1, int a2)
{
  WPARAM v2; // rdi
  HWND v4; // rcx
  HWND v6; // rcx
  _DWORD lParam[20]; // [rsp+20h] [rbp-A8h] BYREF
  LPARAM v8; // [rsp+70h] [rbp-58h] BYREF
  int v9; // [rsp+7Ch] [rbp-4Ch]
  int v10; // [rsp+80h] [rbp-48h]

  v2 = a2;
  v4 = *(HWND *)(a1 + 40);
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    if ( (*(_BYTE *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 72)) & 2) != 0 )
      return 0i64;
    v6 = *(HWND *)(a1 + 40);
    v10 = 4;
    v9 = 0;
    SendMessageW(v6, 0x102Bu, v2, (LPARAM)&v8);
  }
  return 1i64;
}

//----- (000000014006E150) ----------------------------------------------------
__int64 __fastcall sub_14006E150(__int64 a1, int a2)
{
  WPARAM v2; // rdi
  HWND v4; // rcx
  HWND v6; // rcx
  _DWORD lParam[20]; // [rsp+20h] [rbp-A8h] BYREF
  LPARAM v8; // [rsp+70h] [rbp-58h] BYREF
  int v9; // [rsp+7Ch] [rbp-4Ch]
  int v10; // [rsp+80h] [rbp-48h]

  v2 = a2;
  v4 = *(HWND *)(a1 + 40);
  lParam[0] = 4;
  lParam[1] = a2;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam) )
  {
    if ( (*(_BYTE *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 72)) & 2) != 0 )
      return 0i64;
    v6 = *(HWND *)(a1 + 40);
    v10 = 4;
    v9 = 4;
    SendMessageW(v6, 0x102Bu, v2, (LPARAM)&v8);
  }
  return 1i64;
}

//----- (000000014006E210) ----------------------------------------------------
__int64 __fastcall sub_14006E210(__int64 a1, int a2)
{
  HWND v3; // rcx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v3 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam) )
    return *(unsigned int *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 80) + 528);
  else
    return 0i64;
}

//----- (000000014006E280) ----------------------------------------------------
__int64 __fastcall sub_14006E280(__int64 a1)
{
  __int64 v2; // rcx
  unsigned int v3; // edx
  __int64 v4; // r9
  _DWORD *v5; // rax
  unsigned int v6; // edx
  _DWORD *v7; // rax
  __int64 result; // rax

  v2 = *(int *)(a1 + 772);
  v3 = v2;
  if ( (int)v2 >= *(_DWORD *)(a1 + 768) )
  {
LABEL_5:
    v6 = 0;
    if ( (int)v2 <= 0 )
    {
LABEL_9:
      *(_DWORD *)(a1 + 772) = 0;
      return 0xFFFFFFFFi64;
    }
    else
    {
      v7 = *(_DWORD **)(a1 + 792);
      while ( *v7 )
      {
        ++v6;
        ++v7;
        if ( (signed int)v6 >= *(_DWORD *)(a1 + 772) )
          goto LABEL_9;
      }
      result = v6;
      *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4i64 * (int)v6) = 1;
      *(_DWORD *)(a1 + 772) = v6;
    }
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 792);
    v5 = (_DWORD *)(v4 + 4 * v2);
    while ( *v5 )
    {
      ++v3;
      ++v5;
      if ( (signed int)v3 >= *(_DWORD *)(a1 + 768) )
        goto LABEL_5;
    }
    *(_DWORD *)(v4 + 4i64 * (int)v3) = 1;
    *(_DWORD *)(a1 + 772) = v3;
    return v3;
  }
  return result;
}

//----- (000000014006E320) ----------------------------------------------------
__int64 __fastcall sub_14006E320(__int64 a1)
{
  return *(unsigned int *)(a1 + 764);
}

//----- (000000014006E330) ----------------------------------------------------
__int64 __fastcall sub_14006E330(__int64 a1)
{
  return *(unsigned int *)(a1 + 760);
}

//----- (000000014006E340) ----------------------------------------------------
void __fastcall sub_14006E340(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 764) = a2;
}

//----- (000000014006E350) ----------------------------------------------------
void __fastcall sub_14006E350(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 760) = a2;
}

//----- (000000014006E360) ----------------------------------------------------
__int64 __fastcall sub_14006E360(__int64 a1, int a2)
{
  unsigned int v2; // ebx
  HWND v4; // rcx
  _DWORD v6[22]; // [rsp+20h] [rbp-58h] BYREF
  IShellFolder *ppshf; // [rsp+80h] [rbp+8h] BYREF
  int v8; // [rsp+88h] [rbp+10h] BYREF
  LPVOID pv; // [rsp+90h] [rbp+18h] BYREF

  v2 = 0;
  v4 = *(HWND *)(a1 + 40);
  v6[1] = a2;
  ppshf = 0i64;
  pv = 0i64;
  v8 = 32;
  v6[0] = 4;
  v6[2] = 0;
  SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)v6);
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    pv = ILCombine(*(LPCITEMIDLIST *)(a1 + 120), *(LPCITEMIDLIST *)(568i64 * v6[10] + *(_QWORD *)(a1 + 80)));
    ((void (__fastcall *)(IShellFolder *, __int64, LPVOID *, int *))ppshf->lpVtbl->GetAttributesOf)(
      ppshf,
      1i64,
      &pv,
      &v8);
    ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    CoTaskMemFree(pv);
  }
  LOBYTE(v2) = (v8 & 0x20) == 32;
  return v2;
}

//----- (000000014006E440) ----------------------------------------------------
__int64 __fastcall sub_14006E440(__int64 a1)
{
  return *(unsigned int *)(a1 + 696);
}

//----- (000000014006E450) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_14006E450(__int64 a1, int a2)
{
  HWND v3; // rcx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v3 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam) )
    return ILClone(*(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 80)));
  else
    return 0i64;
}

//----- (000000014006E4C0) ----------------------------------------------------
void sub_14006E4C0()
{
  EnterCriticalSection(&stru_14012DB00);
  dword_14012DAFC = 0;
  LeaveCriticalSection(&stru_14012DB00);
}
// 14012DAFC: using guessed type int dword_14012DAFC;

//----- (000000014006E500) ----------------------------------------------------
__int64 __fastcall sub_14006E500(__int64 a1, int a2)
{
  HWND v3; // rcx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v3 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam);
  return *(_QWORD *)(a1 + 72) + 592i64 * lParam[10];
}

//----- (000000014006E550) ----------------------------------------------------
__int64 __fastcall sub_14006E550(__int64 a1, int a2)
{
  HWND v3; // rcx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v3 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam);
  return *(unsigned int *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 72));
}

//----- (000000014006E5B0) ----------------------------------------------------
__int64 __fastcall sub_14006E5B0(__int64 a1, const WCHAR *a2)
{
  int v4; // ebx
  HWND v5; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-58h] BYREF
  unsigned int v8; // [rsp+48h] [rbp-30h]

  v4 = 0;
  if ( *(int *)(a1 + 752) <= 0 )
    return 0xFFFFFFFFi64;
  while ( 1 )
  {
    v5 = *(HWND *)(a1 + 56);
    lParam[0] = 4;
    lParam[1] = v4;
    lParam[2] = 0;
    SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
    if ( !lstrcmpW((LPCWSTR)(592i64 * (int)v8 + *(_QWORD *)(a1 + 88) + 44), a2)
      || !lstrcmpW((LPCWSTR)(592i64 * (int)v8 + *(_QWORD *)(a1 + 88) + 564), a2) )
    {
      break;
    }
    if ( ++v4 >= *(_DWORD *)(a1 + 752) )
      return 0xFFFFFFFFi64;
  }
  return v8;
}

//----- (000000014006E680) ----------------------------------------------------
LRESULT __fastcall sub_14006E680(__int64 a1, const WCHAR *a2)
{
  int v3; // eax
  HWND v4; // rcx
  LPARAM lParam[7]; // [rsp+20h] [rbp-38h] BYREF

  v3 = sub_14006E5B0(a1 - 16, a2);
  if ( v3 == -1 )
    return 0xFFFFFFFFi64;
  v4 = *(HWND *)(a1 + 40);
  LODWORD(lParam[0]) = 1;
  lParam[2] = v3;
  return SendMessageW(v4, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam);
}

//----- (000000014006E6E0) ----------------------------------------------------
__int64 __fastcall sub_14006E6E0(__int64 a1)
{
  return *(unsigned int *)(a1 + 820);
}

//----- (000000014006E6F0) ----------------------------------------------------
__int64 sub_14006E6F0()
{
  return 0i64;
}

//----- (000000014006E700) ----------------------------------------------------
__int64 __fastcall sub_14006E700(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 72i64))(*(_QWORD *)(a1 + 88));
}

//----- (000000014006E720) ----------------------------------------------------
__int64 __fastcall sub_14006E720(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 80i64))(*(_QWORD *)(a1 + 88));
}

//----- (000000014006E740) ----------------------------------------------------
__int64 __fastcall sub_14006E740(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 56i64))(*(_QWORD *)(a1 + 88));
}

//----- (000000014006E760) ----------------------------------------------------
__int64 __fastcall sub_14006E760(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 48i64))(*(_QWORD *)(a1 + 88));
}

//----- (000000014006E780) ----------------------------------------------------
_BOOL8 __fastcall sub_14006E780(__int64 a1)
{
  return (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 32i64))(*(_QWORD *)(a1 + 88)) != 0;
}

//----- (000000014006E7B0) ----------------------------------------------------
_BOOL8 __fastcall sub_14006E7B0(__int64 a1)
{
  return (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 24i64))(*(_QWORD *)(a1 + 88)) != 0;
}

//----- (000000014006E7E0) ----------------------------------------------------
__int64 __fastcall sub_14006E7E0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, unsigned int a5)
{
  unsigned int v7; // eax
  __int64 v8; // rdx

  v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 88) + 40i64))(
         *(_QWORD *)(a1 + 88),
         a2,
         a4,
         a5);
  v8 = v7;
  if ( !v7 )
    return 2147500037i64;
  if ( a5 )
    v8 = -v7;
  *a3 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 88) + 72i64))(*(_QWORD *)(a1 + 88), v8);
  return 0i64;
}

//----- (000000014006E850) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_14006E850(__int64 a1)
{
  return ILClone(*(LPCITEMIDLIST *)(a1 + 120));
}

//----- (000000014006E870) ----------------------------------------------------
__int64 __fastcall sub_14006E870(__int64 a1, int a2, int a3)
{
  __int64 v3; // r9
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 result; // rax
  __int64 v7; // [rsp+8h] [rbp+8h]

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 72);
  v5 = 592 * v3;
  LODWORD(v7) = *(_DWORD *)(v5 + v4 + 32);
  HIDWORD(v7) = *(_DWORD *)(v5 + v4 + 28);
  if ( a3 )
  {
    result = v7;
    if ( (*(_DWORD *)(v5 + v4) & 0x10) == 16 )
      ++*(_DWORD *)(a1 + 748);
    else
      ++*(_DWORD *)(a1 + 744);
    *(_QWORD *)(a1 + 672) += v7;
  }
  else
  {
    result = v7;
    if ( (*(_DWORD *)(v5 + v4) & 0x10) == 16 )
      --*(_DWORD *)(a1 + 748);
    else
      --*(_DWORD *)(a1 + 744);
    *(_QWORD *)(a1 + 672) -= v7;
  }
  return result;
}

//----- (000000014006E900) ----------------------------------------------------
__int64 __fastcall sub_14006E900(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 680) = a2;
  return 0i64;
}

//----- (000000014006E910) ----------------------------------------------------
__int64 __fastcall sub_14006E910(__int64 a1, const WCHAR *a2, _DWORD *a3)
{
  int v6; // ebx

  v6 = 0;
  if ( StrCmpW(a2, (PCWSTR)(*(_QWORD *)(a1 + 64) + 44i64)) )
  {
    do
      ++v6;
    while ( StrCmpW(a2, (PCWSTR)(592i64 * v6 + *(_QWORD *)(a1 + 64) + 44)) );
  }
  if ( (*(_BYTE *)(592i64 * v6 + *(_QWORD *)(a1 + 64)) & 2) != 0 )
    *a3 &= 0x8000u;
  return 0i64;
}

//----- (000000014006E9B0) ----------------------------------------------------
__int64 __fastcall sub_14006E9B0(__int64 a1, int a2)
{
  HWND v3; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v6; // [rsp+48h] [rbp-30h]

  if ( a2 == -1 )
    return 0i64;
  v3 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( !(unsigned int)SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam) )
    return 0i64;
  else
    return *(_QWORD *)(a1 + 72) + 592 * v6;
}

//----- (000000014006EA20) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_14006EA20(__int64 a1, const ITEMIDLIST *a2)
{
  int v4; // er13
  int v5; // edi
  HWND v6; // rcx
  LPITEMIDLIST v7; // rax
  LPITEMIDLIST v8; // rsi
  BOOL v9; // ebx
  LPITEMIDLIST result; // rax
  IShellFolder *ppshf; // [rsp+20h] [rbp-2B8h] BYREF
  _DWORD lParam[20]; // [rsp+30h] [rbp-2A8h] BYREF
  __int16 pszBuf[264]; // [rsp+80h] [rbp-258h] BYREF

  sub_14007E270(a2, (LPWSTR)pszBuf, 1u);
  v4 = SendMessageW(*(HWND *)(a1 + 40), 0x1004u, 0i64, 0i64);
  v5 = 0;
  if ( v4 <= 0 )
  {
LABEL_7:
    *(_DWORD *)(a1 + 956) = 1;
    result = ILClone(a2);
    *(_QWORD *)(a1 + 960) = result;
  }
  else
  {
    while ( 1 )
    {
      v6 = *(HWND *)(a1 + 40);
      lParam[0] = 4;
      lParam[1] = v5;
      lParam[2] = 0;
      SendMessageW(v6, 0x104Bu, 0i64, (LPARAM)lParam);
      v7 = ILCombine(*(LPCITEMIDLIST *)(a1 + 120), *(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 80)));
      v8 = v7;
      if ( a2 )
      {
        if ( v7 )
        {
          ppshf = 0i64;
          if ( SHGetDesktopFolder(&ppshf) >= 0 )
          {
            v9 = ((unsigned __int16 (__fastcall *)(IShellFolder *, _QWORD, const ITEMIDLIST *, LPITEMIDLIST))ppshf->lpVtbl->CompareIDs)(
                   ppshf,
                   0i64,
                   a2,
                   v8) == 0;
            ((void (*)(void))ppshf->lpVtbl->Release)();
            if ( v9 )
              break;
          }
        }
      }
      CoTaskMemFree(v8);
      if ( ++v5 >= v4 )
        goto LABEL_7;
    }
    CoTaskMemFree(v8);
    return (LPITEMIDLIST)SendMessageW(*(HWND *)(a1 + 40), 0x1076u, v5, 0i64);
  }
  return result;
}
// 14006EA20: using guessed type WCHAR pszBuf[264];

//----- (000000014006EBA0) ----------------------------------------------------
__int64 __fastcall sub_14006EBA0(__int64 a1)
{
  HWND v1; // rsi
  BOOL v3; // ebx
  unsigned int WindowLongW; // eax

  v1 = *(HWND *)(a1 + 40);
  v3 = *(_DWORD *)(a1 + 796) == 0;
  *(_DWORD *)(a1 + 796) = v3;
  WindowLongW = GetWindowLongW(v1, -16);
  if ( v3 )
  {
    if ( (WindowLongW & 0x100) == 0 )
      WindowLongW |= 0x100u;
  }
  else if ( (WindowLongW & 0x100) != 0 )
  {
    WindowLongW &= ~0x100u;
  }
  SetWindowLongPtrW(v1, -16, WindowLongW);
  return *(unsigned int *)(a1 + 796);
}

//----- (000000014006EC20) ----------------------------------------------------
_BOOL8 __fastcall sub_14006EC20(__int64 a1, int a2)
{
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(a2, psz2);
  return StrCmpW((PCWSTR)(a1 + 160), psz2) == 0;
}

//----- (000000014006EC90) ----------------------------------------------------
__int64 __fastcall sub_14006EC90(__int64 *a1)
{
  unsigned int v2; // ebx
  LPITEMIDLIST ppidl; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0;
  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) >= 0 )
  {
    if ( !(*(unsigned int (__fastcall **)(__int64 *))(*a1 + 288))(a1)
      || (unsigned int)sub_14007DCB0(a1[15], (__int64)ppidl) )
    {
      v2 = 1;
    }
    CoTaskMemFree(ppidl);
  }
  return v2;
}

//----- (000000014006ED10) ----------------------------------------------------
void __fastcall sub_14006ED10(__int64 a1)
{
  _QWORD **v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD ***)(a1 + 1400);
  v3 = *v1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)(a1 + 1400) + 8i64) = *(_QWORD *)(a1 + 1400);
  *(_QWORD *)(a1 + 1408) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 1400) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 1400) );
  }
  *(_DWORD *)(a1 + 1440) = 0;
}

//----- (000000014006ED80) ----------------------------------------------------
__int64 __fastcall sub_14006ED80(HWND *a1)
{
  int v2; // eax
  HWND v3; // rcx
  WPARAM v4; // rbx
  HWND v5; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v8; // [rsp+2Ch] [rbp-4Ch]
  int v9; // [rsp+30h] [rbp-48h]

  v2 = (*((__int64 (__fastcall **)(HWND *))*a1 + 45))(a1);
  if ( v2 == -1 )
    return 0i64;
  v3 = a1[5];
  v4 = v2;
  v9 = 1;
  v8 = 1;
  SendMessageW(v3, 0x102Bu, v2, (LPARAM)&lParam);
  v5 = a1[5];
  v9 = 2;
  v8 = 2;
  SendMessageW(v5, 0x102Bu, v4, (LPARAM)&lParam);
  SendMessageW(a1[5], 0x1013u, v4, 0i64);
  return 1i64;
}

//----- (000000014006EE30) ----------------------------------------------------
__int64 __fastcall sub_14006EE30(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // ebx
  int v3; // edi
  LPITEMIDLIST ppidl; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 120);
  v2 = 0;
  ppidl = 0i64;
  v3 = 0;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) >= 0 )
  {
    v3 = sub_14007DCB0(v1, (__int64)ppidl);
    CoTaskMemFree(ppidl);
  }
  LOBYTE(v2) = v3 == 0;
  return v2;
}

//----- (000000014006EEB0) ----------------------------------------------------
void __fastcall sub_14006EEB0(__int64 a1, int a2, WCHAR *a3)
{
  ITEMIDLIST *v4; // rbx

  v4 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a2 + *(_QWORD *)(a1 + 96)));
  sub_14007E270(v4, a3, 0x8000u);
  CoTaskMemFree(v4);
}

//----- (000000014006EF10) ----------------------------------------------------
__int64 __fastcall sub_14006EF10(__int64 a1, int a2, WCHAR *a3)
{
  HWND v4; // rcx
  ITEMIDLIST *v6; // rbx
  _DWORD lParam[22]; // [rsp+20h] [rbp-58h] BYREF

  v4 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( !(unsigned int)SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam) )
    return 2147500037i64;
  v6 = ILCombine(*(LPCITEMIDLIST *)(a1 + 120), *(LPCITEMIDLIST *)(568i64 * lParam[10] + *(_QWORD *)(a1 + 80)));
  sub_14007E270(v6, a3, 0x8000u);
  CoTaskMemFree(v6);
  return 0i64;
}

//----- (000000014006F000) ----------------------------------------------------
__int64 ***__fastcall sub_14006F000(__int64 a1, __int64 *a2)
{
  __int64 ***result; // rax
  __int64 *i; // rbx
  int v6; // eax
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rcx
  char *v10; // rax
  __int64 v11; // rdx
  int v12; // [rsp+40h] [rbp+8h] BYREF

  result = *(__int64 ****)(a1 + 1168);
  for ( i = **result; i != (__int64 *)*result; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 5) )
    {
      v6 = sub_140069230(*((_DWORD *)i + 4));
      v7 = *a2;
      v8 = *(_QWORD *)(*a2 + 8);
      v9 = *a2;
      v12 = v6;
      v10 = sub_1400246F0(v9, v8, &v12);
      v11 = a2[1];
      if ( v11 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      a2[1] = v11 + 1;
      *(_QWORD *)(v7 + 8) = v10;
      **((_QWORD **)v10 + 1) = v10;
    }
    result = *(__int64 ****)(a1 + 1168);
  }
  return result;
}

//----- (000000014006F0C0) ----------------------------------------------------
unsigned int __fastcall sub_14006F0C0(__int64 a1)
{
  unsigned int result; // eax
  _DWORD *v3; // rcx
  _DWORD *v4; // rcx
  _DWORD *v5; // rcx
  _DWORD *v6; // rcx
  BOOL v7; // eax
  int v8; // edx
  _DWORD *v9; // rcx
  _DWORD *v10; // rcx
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(3, psz2);
  result = StrCmpW((PCWSTR)(a1 + 160), psz2);
  if ( result )
  {
    sub_14007E090(17, psz2);
    result = StrCmpW((PCWSTR)(a1 + 160), psz2);
    if ( result )
    {
      if ( sub_14006EC20(a1, 10) )
      {
        result = 0;
        v5 = &unk_1400EA658;
        while ( *(_DWORD *)(a1 + 704) != *v5 )
        {
          ++result;
          ++v5;
          if ( result >= 6 )
            goto LABEL_29;
        }
      }
      else if ( sub_14006EC20(a1, 4) )
      {
        result = 0;
        v6 = &unk_1400EA670;
        while ( *(_DWORD *)(a1 + 704) != *v6 )
        {
          ++result;
          ++v6;
          if ( result >= 5 )
            goto LABEL_29;
        }
      }
      else
      {
        v7 = sub_14006EC20(a1, 49);
        v8 = *(_DWORD *)(a1 + 704);
        if ( v7 )
        {
          result = 0;
          v9 = &unk_1400EA688;
          while ( v8 != *v9 )
          {
            ++result;
            ++v9;
            if ( result >= 4 )
              goto LABEL_29;
          }
        }
        else
        {
          result = 0;
          v10 = &unk_1400EA5D0;
          while ( v8 != *v10 )
          {
            ++result;
            ++v10;
            if ( result >= 0x1B )
            {
LABEL_29:
              *(_DWORD *)(a1 + 704) = 1;
              return result;
            }
          }
        }
      }
    }
    else
    {
      v4 = &unk_1400EA640;
      while ( *(_DWORD *)(a1 + 704) != *v4 )
      {
        ++result;
        ++v4;
        if ( result >= 6 )
          goto LABEL_29;
      }
    }
  }
  else
  {
    v3 = &unk_1400EA578;
    while ( *(_DWORD *)(a1 + 704) != *v3 )
    {
      ++result;
      ++v3;
      if ( result >= 2 )
        goto LABEL_29;
    }
  }
  return result;
}

//----- (000000014006F260) ----------------------------------------------------
__int64 __fastcall sub_14006F260(__int64 a1, _WORD *a2, int a3)
{
  return sub_140001240(a2, a3, a1 + 1520);
}

//----- (000000014006F280) ----------------------------------------------------
int __fastcall sub_14006F280(__int64 a1, const ITEMIDLIST *a2)
{
  int result; // eax
  WCHAR psz2[264]; // [rsp+20h] [rbp-438h] BYREF
  __int16 pszPath[264]; // [rsp+230h] [rbp-228h] BYREF

  result = SHGetPathFromIDListW(a2, (LPWSTR)pszPath);
  *(_DWORD *)(a1 + 712) = result == 0;
  if ( !result )
  {
    sub_14007E090(10, psz2);
    result = StrCmpW((PCWSTR)(a1 + 160), psz2);
    if ( result )
    {
      result = sub_14006EC20(a1, 0);
      if ( result )
        *(_DWORD *)(a1 + 712) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 712) = 1;
    }
  }
  return result;
}
// 14006F280: using guessed type WCHAR pszPath[264];

//----- (000000014006F330) ----------------------------------------------------
char **__fastcall sub_14006F330(__int64 a1, int a2, int a3)
{
  WPARAM v3; // rsi
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rcx
  int v8; // eax
  HWND v9; // rcx
  __int64 v10; // rdi
  char *v11; // r11
  __int64 v12; // rax
  char **result; // rax
  __int64 v14; // [rsp+30h] [rbp+8h]
  __int64 v15; // [rsp+30h] [rbp+8h]
  int v16; // [rsp+40h] [rbp+18h] BYREF

  v16 = a3;
  v3 = a2;
  v5 = a3;
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 56), 0x102Cu, a2, 2i64) == 2 )
  {
    v6 = *(_QWORD *)(a1 + 88);
    LODWORD(v14) = *(_DWORD *)(592 * v5 + v6 + 32);
    HIDWORD(v14) = *(_DWORD *)(592 * v5 + v6 + 28);
    *(_QWORD *)(a1 + 688) -= v14;
  }
  v7 = *(_QWORD *)(a1 + 88);
  LODWORD(v15) = *(_DWORD *)(592 * v5 + v7 + 32);
  v8 = *(_DWORD *)(592 * v5 + v7 + 28);
  v9 = *(HWND *)(a1 + 56);
  HIDWORD(v15) = v8;
  *(_QWORD *)(a1 + 680) -= v15;
  SendMessageW(v9, 0x1008u, v3, 0i64);
  --*(_DWORD *)(a1 + 752);
  v10 = *(_QWORD *)(a1 + 1512);
  v11 = sub_1400246F0(v10, *(_QWORD *)(v10 + 8), &v16);
  v12 = *(_QWORD *)(a1 + 1520);
  if ( v12 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 1520) = v12 + 1;
  *(_QWORD *)(v10 + 8) = v11;
  result = (char **)*((_QWORD *)v11 + 1);
  *result = v11;
  return result;
}

//----- (000000014006F450) ----------------------------------------------------
void __fastcall sub_14006F450(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  HWND v5; // rbx
  unsigned int WindowLongW; // eax
  void **v7; // rax
  _DWORD *v8; // rbx
  __int64 v9; // rcx
  int v10; // eax
  WPARAM v11; // r14
  bool v12; // zf
  HWND v13; // rcx
  int v14; // er13
  int v15; // er15
  int v16; // er12
  HWND v17; // rcx
  int v18; // eax
  HWND v19; // rcx
  HWND v20; // rcx
  HWND v21; // rcx
  int v22; // eax
  int v23; // edi
  int v24; // eax
  HWND v25; // rcx
  int v26; // eax
  int v27; // eax
  HWND v28; // rcx
  WPARAM v29; // rdi
  WPARAM v30; // r8
  int *v31; // r9
  HWND v32; // rcx
  HWND v33; // rcx
  _DWORD *v34; // rdi
  HWND v35; // rbx
  unsigned int v36; // eax
  int v37; // [rsp+20h] [rbp-89h]
  BOOL v38; // [rsp+24h] [rbp-85h]
  __int64 v39; // [rsp+28h] [rbp-81h]
  LPARAM v40; // [rsp+28h] [rbp-81h]
  int v41; // [rsp+30h] [rbp-79h] BYREF
  int v42; // [rsp+34h] [rbp-75h]
  int v43[2]; // [rsp+38h] [rbp-71h] BYREF
  LPARAM v44; // [rsp+40h] [rbp-69h] BYREF
  int lParam; // [rsp+48h] [rbp-61h] BYREF
  int lParam_4; // [rsp+4Ch] [rbp-5Dh]
  int v47[4]; // [rsp+50h] [rbp-59h] BYREF
  LPARAM v48; // [rsp+60h] [rbp-49h] BYREF
  int v49; // [rsp+6Ch] [rbp-3Dh]
  int v50; // [rsp+70h] [rbp-39h]
  LPARAM v51; // [rsp+78h] [rbp-31h]
  int v52; // [rsp+80h] [rbp-29h]
  LPARAM v53; // [rsp+B0h] [rbp+7h] BYREF
  int v54; // [rsp+B8h] [rbp+Fh]
  int v55; // [rsp+BCh] [rbp+13h]
  LPARAM v56; // [rsp+C0h] [rbp+17h] BYREF
  char v57; // [rsp+C8h] [rbp+1Fh]
  int v58; // [rsp+CCh] [rbp+23h]

  if ( *(_DWORD *)(a1 + 708) == 4 )
  {
    v2 = *(_QWORD ***)(a1 + 1392);
    v3 = *v2;
    *v2 = v2;
    *(_QWORD *)(*(_QWORD *)(a1 + 1392) + 8i64) = *(_QWORD *)(a1 + 1392);
    *(_QWORD *)(a1 + 1400) = 0i64;
    if ( v3 != *(_QWORD **)(a1 + 1392) )
    {
      do
      {
        v4 = (_QWORD *)*v3;
        j_free(v3);
        v3 = v4;
      }
      while ( v4 != *(_QWORD **)(a1 + 1392) );
    }
  }
  else if ( *(_QWORD *)(a1 + 1400) )
  {
    if ( *(_DWORD *)(a1 + 812) )
    {
      v5 = *(HWND *)(a1 + 56);
      WindowLongW = GetWindowLongW(v5, -16);
      if ( (WindowLongW & 0x100) != 0 )
        WindowLongW &= ~0x100u;
      SetWindowLongPtrW(v5, -16, WindowLongW);
    }
    v7 = *(void ***)(a1 + 1392);
    v8 = *v7;
    if ( *v7 != v7 )
    {
      v9 = a1 + 16;
      do
      {
        v10 = (*(__int64 (__fastcall **)(__int64, _DWORD *))(*(_QWORD *)v9 + 360i64))(v9, v8 + 4);
        v11 = v10;
        if ( v10 == -1 )
        {
          v8 = *(_DWORD **)v8;
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 812) == 0;
          *(_DWORD *)(a1 + 800) = v10;
          if ( v12 )
          {
            v28 = *(HWND *)(a1 + 56);
            v29 = v10;
            LODWORD(v44) = v8[134];
            v31 = (int *)&v44;
            v30 = v10;
            HIDWORD(v44) = v8[135];
          }
          else
          {
            v39 = *((_QWORD *)v8 + 67);
            v38 = 0;
            SendMessageW(*(HWND *)(a1 + 56), 0x1029u, 0i64, (LPARAM)&lParam);
            v13 = *(HWND *)(a1 + 56);
            v14 = v39 - lParam;
            v15 = HIDWORD(v39) - lParam_4;
            LODWORD(v40) = v39 - lParam;
            HIDWORD(v40) = HIDWORD(v39) - lParam_4;
            v56 = v40;
            v16 = SendMessageW(v13, 0x1012u, 0i64, (LPARAM)&v56);
            if ( v16 == -1 || (v57 & 0xE) == 0 )
            {
              v19 = *(HWND *)(a1 + 56);
              LODWORD(v48) = 64;
              v51 = v40;
              v52 = 38;
              v16 = SendMessageW(v19, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)&v48);
              if ( v16 == -1 )
              {
                v20 = *(HWND *)(a1 + 56);
                LODWORD(v48) = 64;
                v51 = v40;
                v52 = 37;
                v16 = SendMessageW(v20, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)&v48);
              }
              v21 = *(HWND *)(a1 + 56);
              LODWORD(v53) = 0;
              SendMessageW(v21, 0x100Eu, v16, (LPARAM)&v53);
              if ( v14 <= (int)v53 + (v54 - (int)v53) / 2 )
              {
                v23 = 0;
              }
              else
              {
                if ( v15 > v55 )
                {
                  v22 = SendMessageW(*(HWND *)(a1 + 56), 0x100Cu, v16, 512i64);
                  if ( v22 != -1 )
                    v16 = v22;
                }
                v23 = 1;
              }
              v24 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
              v25 = *(HWND *)(a1 + 56);
              LODWORD(v53) = 0;
              v37 = v24 - 1;
              SendMessageW(v25, 0x100Eu, v24 - 1, (LPARAM)&v53);
              v26 = (v54 - (int)v53) / 2;
              if ( v14 <= v26 + (int)v53 || v14 >= v26 + v54 + 2 || v15 <= SHIDWORD(v53) )
              {
                if ( !v23 )
                {
                  v27 = SendMessageW(*(HWND *)(a1 + 56), 0x100Cu, v16, 1024i64);
                  if ( v27 == -1 )
                    v38 = 1;
                  else
                    v16 = v27;
                }
              }
              else
              {
                v16 = v37;
              }
            }
            else
            {
              v17 = *(HWND *)(a1 + 56);
              LODWORD(v53) = 0;
              SendMessageW(v17, 0x100Eu, v58, (LPARAM)&v53);
              if ( v14 - (int)v53 <= (v54 - (int)v53) / 2 )
              {
                v18 = SendMessageW(*(HWND *)(a1 + 56), 0x100Cu, v16, 1024i64);
                if ( v18 == -1 )
                  v18 = v16;
                v16 = v18;
                v38 = SendMessageW(*(HWND *)(a1 + 56), 0x100Cu, v18, 1024i64) == -1;
              }
            }
            SendMessageW(*(HWND *)(a1 + 56), 0x1010u, v16, (LPARAM)&v41);
            v28 = *(HWND *)(a1 + 56);
            v29 = v11;
            v30 = v11;
            if ( v38 )
            {
              v43[0] = 0;
              v31 = v43;
              v43[1] = v42;
            }
            else
            {
              v31 = v47;
              v47[0] = v41 + 1;
              v47[1] = v42;
            }
          }
          SendMessageW(v28, 0x1031u, v30, (LPARAM)v31);
          v32 = *(HWND *)(a1 + 56);
          v50 = 2;
          v49 = 2;
          SendMessageW(v32, 0x102Bu, v29, (LPARAM)&v48);
          v33 = *(HWND *)(a1 + 56);
          v50 = 1;
          v49 = 1;
          SendMessageW(v33, 0x102Bu, v29, (LPARAM)&v48);
          v34 = *(_DWORD **)v8;
          if ( v8 != *(_DWORD **)(a1 + 1392) )
          {
            **((_QWORD **)v8 + 1) = v34;
            *(_QWORD *)(*(_QWORD *)v8 + 8i64) = *((_QWORD *)v8 + 1);
            j_free(v8);
            --*(_QWORD *)(a1 + 1400);
          }
          v8 = v34;
        }
        v9 = a1 + 16;
      }
      while ( v8 != *(_DWORD **)(a1 + 1392) );
    }
    if ( *(_DWORD *)(a1 + 812) )
    {
      v35 = *(HWND *)(a1 + 56);
      v36 = GetWindowLongW(v35, -16);
      if ( (v36 & 0x100) == 0 )
        v36 |= 0x100u;
      SetWindowLongPtrW(v35, -16, v36);
    }
  }
}

//----- (000000014006F960) ----------------------------------------------------
__int64 __fastcall sub_14006F960(_QWORD *a1, void *a2)
{
  unsigned int v4; // ebx
  _QWORD *v5; // rbx
  void *v6; // rcx

  EnterCriticalSection(&stru_14012DB00);
  if ( a2 )
    SetEvent(a2);
  if ( qword_14012E0B8 )
  {
    v5 = (_QWORD *)*((_QWORD *)qword_14012E0B0 + 1);
    *a1 = v5[2];
    a1[1] = v5[3];
    a1[2] = v5[4];
    a1[3] = v5[5];
    v6 = (void *)v5[6];
    a1[4] = v6;
    ResetEvent(v6);
    if ( v5 != qword_14012E0B0 )
    {
      *(_QWORD *)v5[1] = *v5;
      *(_QWORD *)(*v5 + 8i64) = v5[1];
      j_free(v5);
      --qword_14012E0B8;
    }
    v4 = 1;
  }
  else
  {
    dword_14012DAFC = 1;
    v4 = 0;
    ++dword_14012DAF8;
  }
  LeaveCriticalSection(&stru_14012DB00);
  return v4;
}
// 14012DAF8: using guessed type int dword_14012DAF8;
// 14012DAFC: using guessed type int dword_14012DAFC;
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (000000014006FA40) ----------------------------------------------------
void __fastcall sub_14006FA40(__int64 a1)
{
  _QWORD *v2; // r11
  _QWORD *v3; // rbx
  _QWORD *v4; // rdi

  EnterCriticalSection(&stru_14012DB00);
  v2 = qword_14012E0B0;
  v3 = *(_QWORD **)qword_14012E0B0;
  if ( *(void **)qword_14012E0B0 != qword_14012E0B0 )
  {
    do
    {
      if ( v3[2] == *(_QWORD *)(a1 + 56) )
      {
        CoTaskMemFree((LPVOID)v3[3]);
        v2 = qword_14012E0B0;
        v4 = (_QWORD *)*v3;
        if ( v3 != qword_14012E0B0 )
        {
          *(_QWORD *)v3[1] = v4;
          *(_QWORD *)(*v3 + 8i64) = v3[1];
          j_free(v3);
          --qword_14012E0B8;
          v2 = qword_14012E0B0;
        }
        v3 = v4;
      }
      else
      {
        v3 = (_QWORD *)*v3;
      }
    }
    while ( v3 != v2 );
  }
  LeaveCriticalSection(&stru_14012DB00);
}
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (000000014006FAF0) ----------------------------------------------------
LRESULT __fastcall sub_14006FAF0(__int64 a1, int a2, _DWORD *a3)
{
  LRESULT result; // rax
  unsigned int i; // edi
  __int64 v7; // rsi
  char *v8; // rax
  __int64 v9; // rdx
  LPARAM v10; // [rsp+20h] [rbp-248h] BYREF
  LPARAM lParam; // [rsp+28h] [rbp-240h] BYREF
  char v12[528]; // [rsp+30h] [rbp-238h] BYREF

  if ( a2 != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 40), 0x1010u, a2, (LPARAM)&lParam);
    SendMessageW(*(HWND *)(a1 + 40), 0x1029u, 0i64, (LPARAM)&v10);
    *(_DWORD *)(a1 + 1428) = v10 + *a3 - lParam;
    *(_DWORD *)(a1 + 1432) = HIDWORD(v10) + a3[1] - HIDWORD(lParam);
  }
  result = SendMessageW(*(HWND *)(a1 + 40), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  for ( i = result; (_DWORD)result != -1; i = result )
  {
    (*(void (__fastcall **)(__int64, _QWORD, __int64, char *))(*(_QWORD *)a1 + 128i64))(a1, i, 260i64, v12);
    v7 = *(_QWORD *)(a1 + 1400);
    v8 = sub_140024790(v7, *(_QWORD *)(v7 + 8), v12);
    v9 = *(_QWORD *)(a1 + 1408);
    if ( v9 == 0x7E07E07E07E07Di64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 1408) = v9 + 1;
    *(_QWORD *)(v7 + 8) = v8;
    **((_QWORD **)v8 + 1) = v8;
    result = SendMessageW(*(HWND *)(a1 + 40), 0x100Cu, (int)i, 2i64);
  }
  *(_DWORD *)(a1 + 1440) = 1;
  return result;
}

//----- (000000014006FC80) ----------------------------------------------------
int __fastcall sub_14006FC80(__int64 a1, int a2, _WORD *a3)
{
  const WCHAR *v3; // rbx
  unsigned __int64 v5; // rdi

  v3 = (const WCHAR *)(a1 + 144);
  v5 = a2;
  if ( a2 >= lstrlenW((LPCWSTR)(a1 + 144)) + 1 )
    sub_140001240(a3, v5, (__int64)v3);
  return lstrlenW(v3);
}

//----- (000000014006FCE0) ----------------------------------------------------
__int64 __fastcall sub_14006FCE0(__int64 a1, int a2, _WORD *a3)
{
  HWND v4; // rcx
  __int64 v6; // rcx
  unsigned __int16 *i; // rdx
  __int64 result; // rax
  _DWORD lParam[20]; // [rsp+20h] [rbp-58h] BYREF

  v4 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam);
  v6 = 260i64;
  for ( i = (unsigned __int16 *)(592i64 * lParam[10] + *(_QWORD *)(a1 + 72) + 44); ; ++i )
  {
    result = v6 + 2147483386;
    if ( v6 == -2147483386 )
      break;
    result = *i;
    if ( !(_WORD)result )
      break;
    *a3++ = result;
    if ( !--v6 )
    {
      *(a3 - 1) = 0;
      return result;
    }
  }
  *a3 = 0;
  return result;
}
// 14006FD7D: conditional instruction was optimized away because rcx.8!=0

//----- (000000014006FDB0) ----------------------------------------------------
int __fastcall sub_14006FDB0(__int64 a1, int a2, unsigned int a3, WCHAR *a4)
{
  HWND v5; // rcx
  _DWORD lParam[20]; // [rsp+20h] [rbp-58h] BYREF

  v5 = *(HWND *)(a1 + 40);
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam);
  sub_140001240(a4, a3, 592i64 * lParam[10] + *(_QWORD *)(a1 + 72) + 44);
  return lstrlenW(a4);
}

//----- (000000014006FE40) ----------------------------------------------------
__int64 __fastcall sub_14006FE40(__int64 a1, int a2, _WORD *a3, unsigned int a4)
{
  HWND v5; // rcx
  unsigned __int64 v6; // rdi
  _DWORD lParam[10]; // [rsp+20h] [rbp-58h] BYREF
  int v10; // [rsp+48h] [rbp-30h]

  v5 = *(HWND *)(a1 + 40);
  v6 = a4;
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( !(unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)lParam)
    || (unsigned int)v6 < lstrlenW((LPCWSTR)(592i64 * v10 + *(_QWORD *)(a1 + 72) + 44)) + 1 )
  {
    return 2147500037i64;
  }
  sub_140001240(a3, v6, 592i64 * v10 + *(_QWORD *)(a1 + 72) + 44);
  return 0i64;
}

//----- (000000014006FF00) ----------------------------------------------------
void __fastcall sub_14006FF00(__int64 a1)
{
  sub_14006FA40(a1);
  EnterCriticalSection(&stru_14012DAD0);
  LeaveCriticalSection(&stru_14012DAD0);
  sub_14006A140(a1);
  sub_14006A0B0(a1);
  *(_DWORD *)(a1 + 76) = 1;
}

//----- (000000014006FF50) ----------------------------------------------------
int __fastcall sub_14006FF50(__int64 a1, __int64 a2, __int64 a3)
{
  int result; // eax

  switch ( *(_DWORD *)(a1 + 704) )
  {
    case 1:
      result = sub_1400674E0(a1, a2, a3);
      break;
    case 2:
      result = sub_1400668A0((_QWORD *)a1, a2, a3);
      break;
    case 3:
      result = sub_140066DB0((_QWORD *)a1, a2, a3);
      break;
    case 4:
      result = sub_140066980(a1, a2, a3);
      break;
    case 5:
      result = sub_140066540(a1, a2, a3, 1);
      break;
    case 6:
      result = sub_140066540(a1, a2, a3, 0);
      break;
    case 7:
      result = sub_140067B40(a1, a2, a3, 6);
      break;
    case 8:
    case 9:
      (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 80i64))(a1);
      goto LABEL_9;
    case 0xA:
      result = sub_140068340(a1, a2, a3);
      break;
    case 0xB:
      result = sub_1400672D0((char *)a1, a2, a3);
      break;
    case 0xC:
      result = sub_140066410((_QWORD *)a1, a2, a3);
      break;
    case 0xD:
      result = sub_1400681F0(a1, a2, a3);
      break;
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
      result = sub_140067F80(a1, a2, a3);
      break;
    case 0x13:
      result = sub_140067DC0(a1, a2, a3);
      break;
    case 0x14:
      result = sub_140067190(a1, a2, a3);
      break;
    case 0x15:
      result = sub_1400662D0(a1, a2, a3);
      break;
    case 0x16:
      result = sub_1400670B0((_QWORD *)a1, a2, a3);
      break;
    case 0x17:
      result = sub_140066FD0((_QWORD *)a1, a2, a3);
      break;
    case 0x18:
      result = sub_140067B40(a1, a2, a3, 2);
      break;
    case 0x19:
      result = sub_140067B40(a1, a2, a3, 3);
      break;
    case 0x1A:
      result = sub_140067B40(a1, a2, a3, 4);
      break;
    case 0x1B:
      result = sub_140067B40(a1, a2, a3, 5);
      break;
    case 0x1D:
      result = sub_140067900(a1, a2, a3, 272);
      break;
    case 0x1E:
      result = sub_140067900(a1, a2, a3, 306);
      break;
    case 0x1F:
      result = sub_140067900(a1, a2, a3, 256);
      break;
    case 0x20:
      result = sub_140067900(a1, a2, a3, 257);
      break;
    case 0x21:
      result = sub_1400677A0((__int64 *)a1, a2, a3);
      break;
    case 0x22:
      result = sub_140066060((_QWORD *)a1, a2, a3);
      break;
    case 0x23:
      result = sub_140065DB0(a1, a2, a3);
      break;
    case 0x24:
      result = sub_140065C20((_QWORD *)a1, a2, a3);
      break;
    case 0x25:
      result = sub_140065B50((_QWORD *)a1, a2, a3);
      break;
    case 0x26:
      result = sub_1400659B0(a1, a2, a3);
      break;
    case 0x27:
      result = sub_140065810(a1, a2, a3);
      break;
    case 0x28:
      result = sub_1400657A0(a2, a3, a1);
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}

//----- (0000000140070210) ----------------------------------------------------
int __fastcall sub_140070210(__int64 a1, __int64 a2, __int64 a3)
{
  int result; // eax

  result = sub_14006FF50(a1, a2, a3);
  if ( !result )
    return StrCmpLogicalW((PCWSTR)(568 * a2 + *(_QWORD *)(a1 + 96) + 8), (PCWSTR)(568 * a3 + *(_QWORD *)(a1 + 96) + 8));
  return result;
}

//----- (0000000140070270) ----------------------------------------------------
__int64 __fastcall sub_140070270(__int64 a1, __int64 a2)
{
  int v4; // edi
  unsigned int v5; // ebx
  int v6; // er12
  HWND v7; // rcx
  __int64 v8; // rsi
  __int64 result; // rax
  _DWORD lParam[10]; // [rsp+20h] [rbp-68h] BYREF
  __int64 v11; // [rsp+48h] [rbp-40h]

  v4 = 1;
  v5 = 0;
  v6 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  do
  {
    if ( (int)v5 >= v6 )
      break;
    v7 = *(HWND *)(a1 + 56);
    lParam[0] = 4;
    lParam[1] = v5;
    lParam[2] = 0;
    if ( (unsigned int)SendMessageW(v7, 0x104Bu, 0i64, (LPARAM)lParam) )
    {
      v8 = v11;
      v4 = sub_14006FF50(a1, a2, v11);
      if ( !v4 )
        v4 = StrCmpLogicalW(
               (PCWSTR)(568 * a2 + *(_QWORD *)(a1 + 96) + 8),
               (PCWSTR)(568 * v8 + *(_QWORD *)(a1 + 96) + 8));
    }
    else
    {
      v4 = 0;
    }
    ++v5;
  }
  while ( v4 > 0 );
  if ( v5 - 1 != v6 - 1 )
    return v5 - 1;
  result = v5;
  if ( v4 <= 0 )
    return v5 - 1;
  return result;
}

//----- (0000000140070390) ----------------------------------------------------
__int64 __fastcall sub_140070390(_QWORD *a1, int a2, _WORD *a3)
{
  HWND v4; // rcx
  _DWORD lParam[22]; // [rsp+30h] [rbp-58h] BYREF

  v4 = (HWND)a1[7];
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  if ( (unsigned int)SendMessageW(v4, 0x104Bu, 0i64, (LPARAM)lParam) )
    return sub_14007F650(a1[8], a1[17], a1[12] + 568i64 * lParam[10], a3, 0x200u);
  else
    return 2147500037i64;
}

//----- (0000000140070430) ----------------------------------------------------
void __fastcall sub_140070430(ULONG_PTR Parameter)
{
  void *v1; // rdi
  __int64 v2; // rbp
  WCHAR *v3; // rsi
  HWND v4; // r12
  int v5; // ebx
  void *v6; // rbx
  int v7; // ebx
  void *v8; // rbx
  HWND hWnd; // [rsp+30h] [rbp-368h]
  LPCWSTR pszPath; // [rsp+38h] [rbp-360h]
  int v11; // [rsp+40h] [rbp-358h]
  HANDLE hEvent; // [rsp+50h] [rbp-348h]
  _DWORD lParam[20]; // [rsp+60h] [rbp-338h] BYREF
  SHFILEINFOW psfi; // [rsp+B0h] [rbp-2E8h] BYREF

  EnterCriticalSection(&stru_14012DB00);
  dword_14012DAFC = 0;
  LeaveCriticalSection(&stru_14012DB00);
  EnterCriticalSection(&stru_14012DB00);
  if ( qword_14012E0B8 )
  {
    v6 = (void *)*((_QWORD *)qword_14012E0B0 + 1);
    v1 = (void *)*((_QWORD *)v6 + 6);
    v4 = (HWND)*((_QWORD *)v6 + 2);
    v3 = (WCHAR *)*((_QWORD *)v6 + 3);
    v2 = *((_QWORD *)v6 + 4);
    ResetEvent(v1);
    if ( v6 != qword_14012E0B0 )
    {
      **((_QWORD **)v6 + 1) = *(_QWORD *)v6;
      *(_QWORD *)(*(_QWORD *)v6 + 8i64) = *((_QWORD *)v6 + 1);
      j_free(v6);
      --qword_14012E0B8;
    }
    v5 = 1;
  }
  else
  {
    ++dword_14012DAF8;
    v1 = hEvent;
    LODWORD(v2) = v11;
    v3 = (WCHAR *)pszPath;
    v4 = hWnd;
    dword_14012DAFC = 1;
    v5 = 0;
  }
  LeaveCriticalSection(&stru_14012DB00);
  if ( v5 )
  {
    do
    {
      if ( SHGetFileInfoW(v3, 0, &psfi, 0x2B8u, 0x148u) )
      {
        lParam[9] = psfi.iIcon;
        lParam[0] = 10;
        lParam[1] = v2;
        lParam[2] = 0;
        lParam[4] = 3840;
        lParam[3] = (psfi.iIcon >> 16) & 0xFFFFFF00;
        SendMessageW(v4, 0x104Cu, 0i64, (LPARAM)lParam);
        DestroyIcon(psfi.hIcon);
        CoTaskMemFree(v3);
      }
      EnterCriticalSection(&stru_14012DB00);
      if ( v1 )
        SetEvent(v1);
      if ( qword_14012E0B8 )
      {
        v8 = (void *)*((_QWORD *)qword_14012E0B0 + 1);
        v1 = (void *)*((_QWORD *)v8 + 6);
        v4 = (HWND)*((_QWORD *)v8 + 2);
        v3 = (WCHAR *)*((_QWORD *)v8 + 3);
        v2 = *((_QWORD *)v8 + 4);
        ResetEvent(v1);
        if ( v8 != qword_14012E0B0 )
        {
          **((_QWORD **)v8 + 1) = *(_QWORD *)v8;
          *(_QWORD *)(*(_QWORD *)v8 + 8i64) = *((_QWORD *)v8 + 1);
          j_free(v8);
          --qword_14012E0B8;
        }
        v7 = 1;
      }
      else
      {
        ++dword_14012DAF8;
        dword_14012DAFC = 1;
        v7 = 0;
      }
      LeaveCriticalSection(&stru_14012DB00);
    }
    while ( v7 );
  }
}
// 14007049D: variable 'hEvent' is possibly undefined
// 1400704A2: variable 'v11' is possibly undefined
// 1400704A7: variable 'pszPath' is possibly undefined
// 1400704AC: variable 'hWnd' is possibly undefined
// 14012DAF8: using guessed type int dword_14012DAF8;
// 14012DAFC: using guessed type int dword_14012DAFC;
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (00000001400706B0) ----------------------------------------------------
void __fastcall sub_1400706B0(ULONG_PTR dwData, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // r11
  const ITEMIDLIST *v6; // rcx
  __int64 v7; // rax
  LPITEMIDLIST v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // rdx
  char *v11; // rax
  void *v12; // rdx
  __int64 v13[2]; // [rsp+20h] [rbp-38h] BYREF
  int v14; // [rsp+30h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-18h]

  EnterCriticalSection(&stru_14012DB00);
  v4 = *(_QWORD *)(dwData + 96);
  v5 = *(_QWORD *)(dwData + 56);
  v6 = *(const ITEMIDLIST **)(dwData + 136);
  v14 = *(_DWORD *)(a2 + 4);
  v7 = *(int *)(a2 + 40);
  v13[0] = v5;
  v8 = ILCombine(v6, *(LPCITEMIDLIST *)(568 * v7 + v4));
  v9 = qword_14012E0B0;
  v10 = *((_QWORD *)qword_14012E0B0 + 1);
  v13[1] = (__int64)v8;
  v15 = *(_QWORD *)(dwData + 152);
  v11 = sub_14001C600((__int64)qword_14012E0B0, v10, v13);
  if ( qword_14012E0B8 == 0x666666666666665i64 )
    sub_14002B5F8("list<T> too long");
  ++qword_14012E0B8;
  v9[1] = v11;
  **((_QWORD **)v11 + 1) = v11;
  if ( dword_14012DAF8 == dword_14012DACC )
  {
    v12 = *(void **)(dwData + 112);
    ++dword_14012DACC;
    QueueUserAPC((PAPCFUNC)sub_140070430, v12, dwData);
  }
  LeaveCriticalSection(&stru_14012DB00);
}
// 14012DACC: using guessed type int dword_14012DACC;
// 14012DAF8: using guessed type int dword_14012DAF8;
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (00000001400707B0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400707B0(__int64 a1, const WCHAR *a2)
{
  return (unsigned int)sub_140082100((LPCWSTR)(a1 + 1536), a2, *(_DWORD *)(a1 + 2564)) == 0;
}

//----- (00000001400707E0) ----------------------------------------------------
void __fastcall sub_1400707E0(__int64 a1, const WCHAR *a2)
{
  int v4; // er14
  int v5; // er15
  int v6; // edi
  HWND v7; // rcx
  LPITEMIDLIST v8; // rax
  LPVOID v9; // rbx
  LPITEMIDLIST v10; // r12
  BOOL v11; // ebx
  __int64 v12; // r8
  WCHAR *v13; // r11
  __int64 v14; // rdx
  _WORD *v15; // rcx
  HWND v16; // rcx
  __int64 v17; // rdx
  LPVOID pv; // [rsp+30h] [rbp-D0h] BYREF
  LPVOID v19; // [rsp+38h] [rbp-C8h] BYREF
  int lParam; // [rsp+40h] [rbp-C0h] BYREF
  int lParam_4; // [rsp+44h] [rbp-BCh]
  int v22; // [rsp+48h] [rbp-B8h]
  __int64 v23; // [rsp+58h] [rbp-A8h]
  int iIcon; // [rsp+64h] [rbp-9Ch]
  int v25; // [rsp+68h] [rbp-98h]
  SHFILEINFOW psfi; // [rsp+90h] [rbp-70h] BYREF
  WCHAR pszBuf[264]; // [rsp+350h] [rbp+250h] BYREF

  if ( a2 )
  {
    v4 = -1;
    v19 = 0i64;
    pv = 0i64;
    v5 = -1;
    if ( (int)sub_14007F810((__int64)a2, (__int64)&pv) >= 0 )
      sub_14007E270((LPCITEMIDLIST)pv, pszBuf, 1u);
    CoTaskMemFree(pv);
    if ( (int)sub_14007F810((__int64)a2, (__int64)&v19) >= 0 )
    {
      v6 = 0;
      if ( *(int *)(a1 + 752) > 0 )
      {
        while ( 1 )
        {
          v7 = *(HWND *)(a1 + 56);
          lParam = 4;
          lParam_4 = v6;
          v22 = 0;
          SendMessageW(v7, 0x104Bu, 0i64, (LPARAM)&lParam);
          v8 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * v25 + *(_QWORD *)(a1 + 96)));
          v9 = v19;
          v10 = v8;
          if ( v19 )
          {
            if ( v8 )
            {
              pv = 0i64;
              if ( SHGetDesktopFolder((IShellFolder **)&pv) >= 0 )
              {
                v11 = (*(unsigned __int16 (__fastcall **)(LPVOID, _QWORD, LPVOID, LPITEMIDLIST))(*(_QWORD *)pv + 56i64))(
                        pv,
                        0i64,
                        v9,
                        v10) == 0;
                (*(void (**)(void))(*(_QWORD *)pv + 16i64))();
                if ( v11 )
                  break;
              }
            }
          }
          CoTaskMemFree(v10);
          if ( ++v6 >= *(_DWORD *)(a1 + 752) )
            goto LABEL_13;
        }
        v5 = v25;
        v4 = v6;
        CoTaskMemFree(v10);
      }
LABEL_13:
      CoTaskMemFree(v19);
      if ( v4 != -1 )
      {
        SHGetFileInfoW(a2, 0, &psfi, 0x2B8u, 0x4000u);
        v12 = 568i64 * v5;
        v13 = pszBuf;
        v14 = 260i64;
        v15 = (_WORD *)(*(_QWORD *)(a1 + 96) + v12 + 8);
        while ( v14 != -2147483386 && *v13 )
        {
          *v15++ = *v13++;
          if ( !--v14 )
          {
            --v15;
            break;
          }
        }
        *v15 = 0;
        v16 = *(HWND *)(a1 + 56);
        iIcon = psfi.iIcon;
        v17 = *(_QWORD *)(a1 + 96) + v12 + 8;
        lParam = 3;
        v23 = v17;
        lParam_4 = v4;
        v22 = 0;
        SendMessageW(v16, 0x104Cu, 0i64, (LPARAM)&lParam);
      }
    }
  }
}
// 1400709EA: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140070A60) ----------------------------------------------------
void __fastcall sub_140070A60(__int64 a1)
{
  int i; // ebx
  HWND v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // r11
  const ITEMIDLIST *v6; // rcx
  LPITEMIDLIST v7; // rax
  _QWORD *v8; // rbp
  __int64 v9; // rdx
  char *v10; // rax
  void *v11; // rdx
  __int64 v12[2]; // [rsp+20h] [rbp-98h] BYREF
  int v13; // [rsp+30h] [rbp-88h]
  __int64 v14; // [rsp+40h] [rbp-78h]
  int lParam; // [rsp+50h] [rbp-68h] BYREF
  int lParam_4; // [rsp+54h] [rbp-64h]
  int v17; // [rsp+58h] [rbp-60h]
  int v18; // [rsp+78h] [rbp-40h]

  for ( i = 0; i < *(_DWORD *)(a1 + 736); ++i )
  {
    v3 = *(HWND *)(a1 + 40);
    lParam = 4;
    lParam_4 = i;
    v17 = 0;
    SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)&lParam);
    EnterCriticalSection(&stru_14012DB00);
    v4 = *(_QWORD *)(a1 + 80);
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(const ITEMIDLIST **)(a1 + 120);
    v13 = lParam_4;
    v12[0] = v5;
    v7 = ILCombine(v6, *(LPCITEMIDLIST *)(568i64 * v18 + v4));
    v8 = qword_14012E0B0;
    v9 = *((_QWORD *)qword_14012E0B0 + 1);
    v12[1] = (__int64)v7;
    v14 = *(_QWORD *)(a1 + 136);
    v10 = sub_14001C600((__int64)qword_14012E0B0, v9, v12);
    if ( qword_14012E0B8 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    ++qword_14012E0B8;
    v8[1] = v10;
    **((_QWORD **)v10 + 1) = v10;
    if ( dword_14012DAF8 == dword_14012DACC )
    {
      v11 = *(void **)(a1 + 96);
      ++dword_14012DACC;
      QueueUserAPC((PAPCFUNC)sub_140070430, v11, a1 - 16);
    }
    LeaveCriticalSection(&stru_14012DB00);
  }
}
// 14012DACC: using guessed type int dword_14012DACC;
// 14012DAF8: using guessed type int dword_14012DAF8;
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (0000000140070BE0) ----------------------------------------------------
__int64 ***__fastcall sub_140070BE0(__int64 a1, __int64 *a2)
{
  __int64 ***result; // rax
  int v3; // esi
  __int64 *i; // rbx
  int v7; // eax
  __int64 v8; // rbp
  __int64 v9; // rdx
  char *v10; // rax
  __int64 v11; // rdx
  int v12[10]; // [rsp+20h] [rbp-28h] BYREF

  result = *(__int64 ****)(a1 + 1168);
  v3 = 0;
  for ( i = **result; i != (__int64 *)*result; i = (__int64 *)*i )
  {
    if ( *(_DWORD *)(a1 + 692) == 4 && *((_DWORD *)i + 5) )
    {
      v7 = SendMessageW(*(HWND *)(a1 + 40), 0x101Du, v3++, 0i64);
      *((_DWORD *)i + 6) = v7;
    }
    v8 = *a2;
    v9 = *(_QWORD *)(*a2 + 8);
    v12[0] = *((_DWORD *)i + 4);
    v12[1] = *((_DWORD *)i + 5);
    v12[2] = *((_DWORD *)i + 6);
    v10 = sub_140017AD0(v8, v9, v12);
    v11 = a2[1];
    if ( v11 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    a2[1] = v11 + 1;
    *(_QWORD *)(v8 + 8) = v10;
    **((_QWORD **)v10 + 1) = v10;
    result = *(__int64 ****)(a1 + 1168);
  }
  return result;
}

//----- (0000000140070CE0) ----------------------------------------------------
void __fastcall sub_140070CE0(__int64 a1)
{
  int i; // ebx
  HWND v3; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-58h] BYREF
  int v5; // [rsp+48h] [rbp-30h]

  if ( *(_DWORD *)(a1 + 2560) )
  {
    for ( i = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64) - 1; i >= 0; --i )
    {
      v3 = *(HWND *)(a1 + 56);
      lParam[0] = 4;
      lParam[1] = i;
      lParam[2] = 0;
      SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam);
      if ( (*(_BYTE *)(592i64 * v5 + *(_QWORD *)(a1 + 88)) & 0x10) == 0
        && !(unsigned int)sub_140082100(
                            (LPCWSTR)(a1 + 1536),
                            (LPCWSTR)(568i64 * v5 + *(_QWORD *)(a1 + 96) + 8),
                            *(_DWORD *)(a1 + 2564)) )
      {
        sub_14006F330(a1, i, v5);
      }
    }
    SendMessageW(*(HWND *)(a1 + 64), 0x8011u, 0i64, 0i64);
  }
}

//----- (0000000140070DE0) ----------------------------------------------------
__int64 __fastcall sub_140070DE0(__int64 a1, int a2)
{
  __int64 v3; // rsi
  ITEMIDLIST *v4; // rbx
  SHFILEINFOW psfi; // [rsp+30h] [rbp-4E8h] BYREF
  WCHAR pszPath[264]; // [rsp+2F0h] [rbp-228h] BYREF

  v3 = 568i64 * a2;
  v4 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 96) + v3));
  sub_14007E270(v4, pszPath, 0x8000u);
  CoTaskMemFree(v4);
  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 96) + v3 + 532) )
  {
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x4000u);
    *(_DWORD *)(*(_QWORD *)(a1 + 96) + v3 + 532) = 1;
    *(_DWORD *)(*(_QWORD *)(a1 + 96) + v3 + 540) = psfi.iIcon;
  }
  return sub_14000A470(*(_QWORD *)(a1 + 80), *(_DWORD *)(*(_QWORD *)(a1 + 96) + v3 + 540), 0);
}

//----- (0000000140070EE0) ----------------------------------------------------
__int64 __fastcall sub_140070EE0(_QWORD *a1, int a2)
{
  HWND v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rax
  _DWORD lParam[10]; // [rsp+20h] [rbp-58h] BYREF
  int v8; // [rsp+48h] [rbp-30h]

  v3 = (HWND)a1[5];
  lParam[1] = a2;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(v3, 0x104Bu, 0i64, (LPARAM)lParam);
  v4 = a1[10];
  v5 = 568i64 * v8;
  if ( *(_DWORD *)(v5 + v4 + 532) )
    return sub_14000A470(a1[8], *(_DWORD *)(v5 + v4 + 540), 0);
  else
    return sub_140070DE0((__int64)(a1 - 2), v8);
}

//----- (0000000140070F60) ----------------------------------------------------
void __fastcall sub_140070F60(__int64 a1)
{
  int v2; // ebx
  __int64 v3; // rsi
  __int64 v4; // rbp
  __int64 v5; // rbx
  unsigned int v6; // eax
  __int64 v7; // rax
  _QWORD **v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rbx
  void *v11; // rcx
  void *v12; // rax
  void *v13; // rcx
  size_t v14; // rdx
  void *v15; // rax
  void *v16; // rcx
  size_t v17; // rdx
  void *v18; // rax
  __int64 v19; // rdx
  __int64 i; // rcx
  void *v21; // rcx
  _QWORD **v22; // rax
  _QWORD *v23; // rcx
  _QWORD *v24; // rbx
  _QWORD **v25; // rax
  _QWORD *v26; // rcx
  _QWORD *v27; // rbx

  v2 = 0;
  if ( *(int *)(a1 + 768) > 0 )
  {
    v3 = 0i64;
    v4 = 0i64;
    do
    {
      if ( *(_DWORD *)(v3 + *(_QWORD *)(a1 + 792)) == 1 )
        CoTaskMemFree(*(LPVOID *)(*(_QWORD *)(a1 + 96) + v4));
      ++v2;
      v3 += 4i64;
      v4 += 568i64;
    }
    while ( v2 < *(_DWORD *)(a1 + 768) );
  }
  if ( *(_DWORD *)(a1 + 708) == 6 )
  {
    EnterCriticalSection(&stru_14012DAD0);
    v5 = SendMessageW(*(HWND *)(a1 + 56), 0x1002u, 0i64, 0i64);
    v6 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
    v7 = sub_1400016D0(0x78u, 0x78u, 0x20u, v6, v6 + 100);
    SendMessageW(*(HWND *)(a1 + 56), 0x1003u, 0i64, v7);
    sub_14000A390(v5);
    LeaveCriticalSection(&stru_14012DAD0);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 856));
  v8 = *(_QWORD ***)(a1 + 896);
  v9 = *v8;
  *v8 = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 896) + 8i64) = *(_QWORD *)(a1 + 896);
  *(_QWORD *)(a1 + 904) = 0i64;
  if ( v9 != *(_QWORD **)(a1 + 896) )
  {
    do
    {
      v10 = (_QWORD *)*v9;
      j_free(v9);
      v9 = v10;
    }
    while ( v10 != *(_QWORD **)(a1 + 896) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 856));
  v11 = *(void **)(a1 + 88);
  *(_DWORD *)(a1 + 768) = 250;
  v12 = realloc(v11, 0x24220ui64);
  v13 = *(void **)(a1 + 96);
  v14 = 568i64 * *(int *)(a1 + 768);
  *(_QWORD *)(a1 + 88) = v12;
  v15 = realloc(v13, v14);
  v16 = *(void **)(a1 + 792);
  v17 = 4i64 * *(int *)(a1 + 768);
  *(_QWORD *)(a1 + 96) = v15;
  v18 = realloc(v16, v17);
  v19 = *(int *)(a1 + 768);
  *(_QWORD *)(a1 + 792) = v18;
  for ( i = 0i64; i < v19; *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4 * i - 4) = 0 )
    ++i;
  v21 = *(void **)(a1 + 136);
  *(_DWORD *)(a1 + 772) = 0;
  CoTaskMemFree(v21);
  v22 = *(_QWORD ***)(a1 + 1512);
  v23 = *v22;
  *v22 = v22;
  *(_QWORD *)(*(_QWORD *)(a1 + 1512) + 8i64) = *(_QWORD *)(a1 + 1512);
  *(_QWORD *)(a1 + 1520) = 0i64;
  if ( v23 != *(_QWORD **)(a1 + 1512) )
  {
    do
    {
      v24 = (_QWORD *)*v23;
      j_free(v23);
      v23 = v24;
    }
    while ( v24 != *(_QWORD **)(a1 + 1512) );
  }
  v25 = *(_QWORD ***)(a1 + 944);
  v26 = *v25;
  *v25 = v25;
  *(_QWORD *)(*(_QWORD *)(a1 + 944) + 8i64) = *(_QWORD *)(a1 + 944);
  *(_QWORD *)(a1 + 952) = 0i64;
  if ( v26 != *(_QWORD **)(a1 + 944) )
  {
    do
    {
      v27 = (_QWORD *)*v26;
      j_free(v26);
      v26 = v27;
    }
    while ( v27 != *(_QWORD **)(a1 + 944) );
  }
  *(_DWORD *)(a1 + 1016) = 0;
}

//----- (00000001400711E0) ----------------------------------------------------
void __fastcall sub_1400711E0(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  int v4; // eax
  int v5; // eax

  v3 = a2 + 24;
  if ( *(_DWORD *)(a1 + 692) == 6 )
  {
    v4 = sub_140071D90(a1 - 16, 0, *(_DWORD *)(a2 + 64), 0i64);
    *(_DWORD *)v3 |= 0x1000u;
    *(_DWORD *)(v3 + 36) = v4;
    if ( !*(_DWORD *)(a1 + 60) )
      sub_140072270(a1 - 16, *(_QWORD *)(v3 + 40));
  }
  else
  {
    if ( (*(_BYTE *)v3 & 2) != 0 )
    {
      if ( (*(_BYTE *)(592i64 * *(_QWORD *)(a2 + 64) + *(_QWORD *)(a1 + 72)) & 0x10) != 0 )
        v5 = *(_DWORD *)(a1 + 768);
      else
        v5 = *(_DWORD *)(a1 + 772);
      *(_DWORD *)(a2 + 60) = v5;
      if ( !*(_DWORD *)(a1 + 60) )
        sub_1400706B0(a1 - 16, a2 + 24);
    }
    *(_DWORD *)v3 |= 0x1000u;
  }
}

//----- (0000000140071490) ----------------------------------------------------
void __fastcall sub_140071490(__int64 a1, __int64 **a2)
{
  __int64 v2; // rbx
  signed int v3; // esi
  int i; // er14
  _QWORD *v7; // r8
  _QWORD *v8; // rax
  unsigned int v9; // edx
  __int64 **v10; // rcx
  __int64 *j; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rax
  signed int k; // edi
  _QWORD *v15; // rcx
  _QWORD *v16; // rax
  __int64 **v17; // rbp
  __int64 *v18; // rbx
  __int64 *v19; // rcx
  _QWORD *v20; // rdi
  __int64 *v21; // rsi

  v2 = **a2;
  v3 = 0;
  for ( i = 0; (__int64 *)v2 != *a2; v2 = *(_QWORD *)v2 )
  {
    if ( !*(_DWORD *)(v2 + 20) && (unsigned int)sub_140069230(*(_DWORD *)(v2 + 16)) == *(_DWORD *)(a1 + 688) )
    {
      v8 = (_QWORD *)*v7;
      if ( (_QWORD *)*v7 != v7 )
      {
        while ( !*((_DWORD *)v8 + 5) )
        {
          v8 = (_QWORD *)*v8;
          if ( v8 == v7 )
            goto LABEL_9;
        }
        i = 1;
        *(_DWORD *)(a1 + 688) = sub_140069230(*((_DWORD *)v8 + 4));
      }
    }
LABEL_9:
    v9 = *(_DWORD *)(v2 + 16);
    v10 = **(__int64 ****)(a1 + 1168);
    for ( j = *v10; j != (__int64 *)v10; j = (__int64 *)*j )
    {
      if ( *((_DWORD *)j + 4) == v9 )
        break;
    }
    if ( *(_DWORD *)(v2 + 20) )
    {
      if ( *(_DWORD *)(a1 + 692) == 4 )
      {
        v12 = **(_QWORD ***)(a1 + 1168);
        v13 = (_QWORD *)*v12;
        if ( (_QWORD *)*v12 != v12 )
        {
          do
          {
            if ( *((_DWORD *)v13 + 4) == v9 )
              break;
            v13 = (_QWORD *)*v13;
          }
          while ( v13 != **(_QWORD ***)(a1 + 1168) );
        }
        if ( !*((_DWORD *)v13 + 5) )
        {
          sub_1400693F0(a1 - 16, v9, v3, *(_DWORD *)(v2 + 24));
          for ( k = 0; k < *(_DWORD *)(a1 + 736); ++k )
            sub_14006D410(a1 - 16, *(_DWORD *)(v2 + 16), k, v3);
        }
      }
      ++v3;
    }
    else
    {
      v15 = **(_QWORD ***)(a1 + 1168);
      v16 = (_QWORD *)*v15;
      if ( (_QWORD *)*v15 != v15 )
      {
        do
        {
          if ( *((_DWORD *)v16 + 4) == v9 )
            break;
          v16 = (_QWORD *)*v16;
        }
        while ( v16 != **(_QWORD ***)(a1 + 1168) );
      }
      if ( *((_DWORD *)v16 + 5) )
        SendMessageW(*(HWND *)(a1 + 40), 0x101Cu, v3, 0i64);
    }
  }
  v17 = *(__int64 ***)(a1 + 1168);
  if ( v17 != a2 )
  {
    v18 = *a2;
    v19 = (__int64 *)**v17;
    v20 = (_QWORD *)**a2;
    **v17 = (__int64)*v17;
    (*v17)[1] = (__int64)*v17;
    v17[1] = 0i64;
    if ( v19 != *v17 )
    {
      do
      {
        v21 = (__int64 *)*v19;
        j_free(v19);
        v19 = v21;
      }
      while ( v21 != *v17 );
    }
    sub_14000BDC0((__int64)v17, **v17, v20, v18);
  }
  if ( i )
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 - 16) + 32i64))(a1 - 16, *(unsigned int *)(a1 + 688));
  *(_DWORD *)(a1 + 1344) = 0;
}
// 1400714E8: variable 'v7' is possibly undefined

//----- (00000001400716D0) ----------------------------------------------------
LRESULT __fastcall sub_1400716D0(ULONG_PTR dwData)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rbx
  int v4; // eax
  __int64 v5; // rsi
  __int64 v6; // rdx
  char *v7; // rax
  __int64 v8; // rdx
  _QWORD **v9; // rax
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx
  int v13[6]; // [rsp+20h] [rbp-18h] BYREF

  v1 = *(_QWORD **)(dwData + 1512);
  v3 = (_QWORD *)*v1;
  if ( (_QWORD *)*v1 != v1 )
  {
    v13[2] = 1;
    do
    {
      v4 = sub_140070270(dwData, *((int *)v3 + 4));
      v5 = *(_QWORD *)(dwData + 944);
      v6 = *(_QWORD *)(v5 + 8);
      v13[0] = v4;
      v13[3] = v4 - 1;
      v13[1] = *((_DWORD *)v3 + 4);
      v7 = sub_140024640(v5, v6, v13);
      v8 = *(_QWORD *)(dwData + 952);
      if ( v8 == 0xFFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(dwData + 952) = v8 + 1;
      *(_QWORD *)(v5 + 8) = v7;
      **((_QWORD **)v7 + 1) = v7;
      v3 = (_QWORD *)*v3;
    }
    while ( v3 != *(_QWORD **)(dwData + 1512) );
  }
  v9 = *(_QWORD ***)(dwData + 1512);
  v10 = *v9;
  *v9 = v9;
  *(_QWORD *)(*(_QWORD *)(dwData + 1512) + 8i64) = *(_QWORD *)(dwData + 1512);
  *(_QWORD *)(dwData + 1520) = 0i64;
  if ( v10 != *(_QWORD **)(dwData + 1512) )
  {
    do
    {
      v11 = (_QWORD *)*v10;
      j_free(v10);
      v10 = v11;
    }
    while ( v11 != *(_QWORD **)(dwData + 1512) );
  }
  sub_14002AB60(dwData, *(_DWORD *)(dwData + 816));
  return SendMessageW(*(HWND *)(dwData + 64), 0x8011u, 0i64, 0i64);
}

//----- (0000000140071810) ----------------------------------------------------
LRESULT __fastcall sub_140071810(ULONG_PTR a1)
{
  LPARAM v2; // r9
  UINT v3; // edx

  if ( *(_DWORD *)(a1 + 2560) )
  {
    sub_140070CE0(a1);
    v2 = 1i64;
LABEL_6:
    v3 = 32970;
    return SendMessageW(*(HWND *)(a1 + 64), v3, *(int *)(a1 + 852), v2);
  }
  sub_1400716D0(a1);
  if ( *(_DWORD *)(a1 + 752) )
  {
    v2 = 0i64;
    goto LABEL_6;
  }
  v3 = 32969;
  v2 = 1i64;
  return SendMessageW(*(HWND *)(a1 + 64), v3, *(int *)(a1 + 852), v2);
}

//----- (0000000140071870) ----------------------------------------------------
LRESULT __fastcall sub_140071870(__int64 a1, int a2)
{
  __int64 v2; // rbx
  bool v3; // zf
  ULONG_PTR v4; // rcx
  LPARAM v5; // r9
  UINT v6; // edx

  v2 = a1 - 16;
  *(_DWORD *)(a1 + 2544) = a2;
  v3 = *(_DWORD *)(a1 - 16 + 2560) == 0;
  v4 = a1 - 16;
  if ( !v3 )
  {
    sub_140070CE0(v4);
    v5 = 1i64;
LABEL_6:
    v6 = 32970;
    return SendMessageW(*(HWND *)(v2 + 64), v6, *(int *)(v2 + 852), v5);
  }
  sub_1400716D0(v4);
  if ( *(_DWORD *)(v2 + 752) )
  {
    v5 = 0i64;
    goto LABEL_6;
  }
  v6 = 32969;
  v5 = 1i64;
  return SendMessageW(*(HWND *)(v2 + 64), v6, *(int *)(v2 + 852), v5);
}

//----- (00000001400718E0) ----------------------------------------------------
LRESULT __fastcall sub_1400718E0(__int64 a1, __int64 a2)
{
  _WORD *v2; // r8
  __int64 v3; // r9
  __int64 v4; // rdx
  __int16 v5; // ax
  LRESULT result; // rax
  ULONG_PTR v7; // rbx
  LPARAM v8; // r9
  UINT v9; // edx

  v2 = (_WORD *)(a1 + 1520);
  v3 = 512i64;
  v4 = a2 - (a1 + 1520);
  while ( v3 != -2147483134 )
  {
    v5 = *(_WORD *)((char *)v2 + v4);
    if ( !v5 )
      break;
    *v2++ = v5;
    if ( !--v3 )
    {
      --v2;
      break;
    }
  }
  result = 0i64;
  *v2 = 0;
  if ( *(_DWORD *)(a1 + 2544) )
  {
    v7 = a1 - 16;
    sub_1400716D0(a1 - 16);
    if ( *(_DWORD *)(v7 + 2560) )
    {
      sub_140070CE0(v7);
      v8 = 1i64;
    }
    else
    {
      sub_1400716D0(v7);
      if ( !*(_DWORD *)(v7 + 752) )
      {
        v9 = 32969;
        v8 = 1i64;
        return SendMessageW(*(HWND *)(v7 + 64), v9, *(int *)(v7 + 852), v8);
      }
      v8 = 0i64;
    }
    v9 = 32970;
    return SendMessageW(*(HWND *)(v7 + 64), v9, *(int *)(v7 + 852), v8);
  }
  return result;
}
// 14007191C: conditional instruction was optimized away because r9.8!=0

//----- (00000001400719A0) ----------------------------------------------------
void __fastcall sub_1400719A0(__int64 a1, __int64 a2, __int64 a3)
{
  int v6; // eax
  __int64 v7; // rbx
  unsigned int i; // ecx
  ULONG_PTR v9; // rcx
  unsigned int v10; // ecx
  __int16 j; // ax
  WCHAR pszMore[8]; // [rsp+20h] [rbp-238h] BYREF
  WCHAR psz2[264]; // [rsp+30h] [rbp-228h] BYREF

  sub_14007E090(17, psz2);
  v6 = StrCmpW((PCWSTR)(a1 + 144), psz2);
  if ( !v6 )
  {
    v7 = a2 - 0x8000;
    if ( v7 )
    {
      if ( v7 == 4 && *(_DWORD *)(a3 + 4) == 2 )
      {
        for ( i = *(_DWORD *)(a3 + 12); (i & 1) == 0; LOWORD(v6) = v6 + 1 )
          i >>= 1;
        sub_140001000(pszMore, 4ui64, L"%c:\\", (unsigned __int16)(v6 + 65));
        v9 = a1 - 16;
        if ( (*(_BYTE *)(a3 + 16) & 1) == 0 )
        {
          sub_14006DCD0(v9, pszMore);
          return;
        }
LABEL_13:
        sub_1400707E0(v9, pszMore);
      }
    }
    else
    {
      if ( *(_DWORD *)(a3 + 4) != 2 )
        return;
      v10 = *(_DWORD *)(a3 + 12);
      for ( j = 0; (v10 & 1) == 0; ++j )
        v10 >>= 1;
      sub_140001000(pszMore, 4ui64, L"%c:\\", (unsigned __int16)(j + 65));
      v9 = a1 - 16;
      if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
        goto LABEL_13;
      sub_1400650A0(v9, pszMore);
    }
  }
}
// 1400EA698: using guessed type wchar_t aC_2[5];
// 1400EA6A8: using guessed type wchar_t aC_1[5];

//----- (0000000140071AE0) ----------------------------------------------------
BOOL __fastcall sub_140071AE0(HDC hdc, HANDLE h)
{
  HDC hdcSrc; // rbp
  HGDIOBJ v5; // rdi
  char pv[4]; // [rsp+50h] [rbp-28h] BYREF
  int v8; // [rsp+54h] [rbp-24h]
  int v9; // [rsp+58h] [rbp-20h]

  hdcSrc = CreateCompatibleDC(hdc);
  v5 = SelectObject(hdcSrc, h);
  GetObjectW(h, 32, pv);
  BitBlt(hdc, (120 - v8) / 2, (120 - v9) / 2, 120, 120, hdcSrc, 0, 0, 0xCC0020u);
  SelectObject(hdcSrc, v5);
  return DeleteDC(hdcSrc);
}
// 140071AE0: using guessed type char pv[4];

//----- (0000000140071BB0) ----------------------------------------------------
void sub_140071BB0()
{
  EnterCriticalSection(&stru_14012DAD0);
  LeaveCriticalSection(&stru_14012DAD0);
}

//----- (0000000140071BE0) ----------------------------------------------------
__int64 __fastcall sub_140071BE0(_QWORD *a1)
{
  unsigned int v2; // ebx
  _QWORD *v3; // rdx
  _QWORD *v4; // rcx

  EnterCriticalSection(&stru_14012DAD0);
  if ( qword_14012E0A0 )
  {
    v3 = qword_14012E098;
    v4 = (_QWORD *)*((_QWORD *)qword_14012E098 + 1);
    *a1 = v4[2];
    a1[1] = v4[3];
    a1[2] = v4[4];
    a1[3] = v4[5];
    a1[4] = v4[6];
    if ( v4 != v3 )
    {
      *(_QWORD *)v4[1] = *v4;
      *(_QWORD *)(*v4 + 8i64) = v4[1];
      j_free(v4);
      --qword_14012E0A0;
    }
    v2 = 1;
  }
  else
  {
    v2 = 0;
    ++dword_14012DD48;
  }
  LeaveCriticalSection(&stru_14012DAD0);
  return v2;
}
// 14012DD48: using guessed type int dword_14012DD48;
// 14012E0A0: using guessed type __int64 qword_14012E0A0;

//----- (0000000140071C90) ----------------------------------------------------
BOOL __fastcall sub_140071C90(__int64 a1, HDC a2, int a3)
{
  LPITEMIDLIST v5; // rax
  HICON v6; // rdi
  int v8; // [rsp+50h] [rbp-2F8h] BYREF
  int v9[3]; // [rsp+54h] [rbp-2F4h] BYREF
  SHFILEINFOW psfi; // [rsp+60h] [rbp-2E8h] BYREF

  v5 = ILCombine(*(LPCITEMIDLIST *)(a1 + 136), *(LPCITEMIDLIST *)(568i64 * a3 + *(_QWORD *)(a1 + 96)));
  SHGetFileInfoW(&v5->mkid.cb, 0, &psfi, 0x2B8u, 0x4008u);
  v6 = (HICON)sub_14000A470(*(_QWORD *)(a1 + 80), psfi.iIcon, 0);
  sub_1400182D0(*(_QWORD *)(a1 + 80), (__int64)&v8, (__int64)v9);
  DrawIconEx(a2, (120 - v8) / 2, (120 - v9[0]) / 2, v6, 0, 0, 0, 0i64, 3u);
  return DestroyIcon(v6);
}
// 140071C90: using guessed type int var_2F4[3];

//----- (0000000140071D90) ----------------------------------------------------
__int64 __fastcall sub_140071D90(__int64 a1, int a2, int a3, void *a4)
{
  HDC DC; // r14
  HDC CompatibleDC; // rbx
  HBITMAP CompatibleBitmap; // rsi
  HGDIOBJ v11; // r15
  COLORREF v12; // eax
  HBRUSH SolidBrush; // rax
  __int64 v14; // rax
  unsigned int v15; // ebx
  RECT rc; // [rsp+20h] [rbp-58h] BYREF

  DC = GetDC(*(HWND *)(a1 + 56));
  CompatibleDC = CreateCompatibleDC(DC);
  CompatibleBitmap = CreateCompatibleBitmap(DC, 120, 120);
  v11 = SelectObject(CompatibleDC, CompatibleBitmap);
  v12 = SendMessageW(*(HWND *)(a1 + 56), 0x1000u, 0i64, 0i64);
  SolidBrush = CreateSolidBrush(v12);
  *(_QWORD *)&rc.left = 0i64;
  rc.right = 120;
  rc.bottom = 120;
  FillRect(CompatibleDC, &rc, SolidBrush);
  if ( a2 )
  {
    if ( a2 == 1 )
      sub_140071AE0(CompatibleDC, a4);
  }
  else
  {
    sub_140071C90(a1, CompatibleDC, a3);
  }
  SelectObject(CompatibleDC, v11);
  DeleteDC(CompatibleDC);
  ReleaseDC(*(HWND *)(a1 + 56), DC);
  v14 = SendMessageW(*(HWND *)(a1 + 56), 0x1002u, 0i64, 0i64);
  v15 = sub_1400012C0(v14, (__int64)CompatibleBitmap, 0i64);
  DeleteObject(CompatibleBitmap);
  return v15;
}

//----- (0000000140071F30) ----------------------------------------------------
void __fastcall sub_140071F30(ULONG_PTR Parameter)
{
  bool v1; // zf
  HWND v3; // rsi
  const ITEMIDLIST *v4; // r12
  __int64 v5; // r13
  __int64 v6; // r14
  ITEMIDLIST *v7; // rdi
  const ITEMIDLIST *ID; // rax
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  void *v13; // rcx
  __int64 v14; // [rsp+40h] [rbp-C0h] BYREF
  LPVOID pv; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v16; // [rsp+50h] [rbp-B0h] BYREF
  int v17; // [rsp+58h] [rbp-A8h] BYREF
  IShellFolder *ppshf; // [rsp+60h] [rbp-A0h] BYREF
  int v19[2]; // [rsp+68h] [rbp-98h] BYREF
  HGDIOBJ ho; // [rsp+70h] [rbp-90h] BYREF
  char v21[8]; // [rsp+78h] [rbp-88h] BYREF
  HWND hWnd[2]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v23; // [rsp+90h] [rbp-70h]
  __int64 v24; // [rsp+98h] [rbp-68h]
  __int64 v25; // [rsp+A0h] [rbp-60h]
  _DWORD lParam[20]; // [rsp+B0h] [rbp-50h] BYREF
  char v27[528]; // [rsp+100h] [rbp+0h] BYREF

  v1 = *(_DWORD *)(Parameter + 76) == 0;
  v14 = 0i64;
  ppshf = 0i64;
  v16 = 0i64;
  pv = 0i64;
  if ( v1 && (unsigned int)sub_140071BE0(hWnd) )
  {
    v3 = hWnd[0];
    v4 = (const ITEMIDLIST *)hWnd[1];
    v5 = v24;
    LODWORD(v6) = v23;
    do
    {
      v7 = ILClone(v4);
      ILRemoveLastID(v7);
      ID = ILFindLastID(v4);
      pv = ILClone(ID);
      if ( SHGetDesktopFolder(&ppshf) >= 0 )
      {
        if ( ((int (__fastcall *)(IShellFolder *, ITEMIDLIST *, _QWORD, const IID *, __int64 *))ppshf->lpVtbl->BindToObject)(
               ppshf,
               v7,
               0i64,
               &stru_1400E3FB0,
               &v16) >= 0 )
        {
          if ( (*(int (__fastcall **)(__int64, _QWORD, __int64, LPVOID *, void *, _QWORD, __int64 *))(*(_QWORD *)v16 + 80i64))(
                 v16,
                 0i64,
                 1i64,
                 &pv,
                 &unk_1400E4060,
                 0i64,
                 &v14) >= 0 )
          {
            v17 = 520;
            v19[0] = 120;
            v19[1] = 120;
            (*(void (__fastcall **)(__int64, char *, __int64, char *, int *, int, int *))(*(_QWORD *)v14 + 24i64))(
              v14,
              v27,
              260i64,
              v21,
              v19,
              32,
              &v17);
            if ( (*(int (__fastcall **)(__int64, HGDIOBJ *))(*(_QWORD *)v14 + 32i64))(v14, &ho) >= 0 )
            {
              v9 = sub_140071D90(Parameter, 1, 0, ho);
              v23 = (int)v6;
              v10 = v9;
              LODWORD(hWnd[0]) = 1;
              v11 = SendMessageW(v3, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)hWnd);
              if ( v11 != -1 )
              {
                lParam[0] = 2;
                lParam[1] = v11;
                lParam[2] = 0;
                lParam[9] = v10;
                SendMessageW(v3, 0x104Cu, 0i64, (LPARAM)lParam);
                *(_DWORD *)(v5 + 536) = 1;
              }
              DeleteObject(ho);
            }
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 16i64))(v14);
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
        }
        ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
      }
      CoTaskMemFree(v7);
      CoTaskMemFree(pv);
      EnterCriticalSection(&stru_14012DAD0);
      if ( qword_14012E0A0 )
      {
        v13 = (void *)*((_QWORD *)qword_14012E098 + 1);
        v3 = (HWND)*((_QWORD *)v13 + 2);
        v4 = (const ITEMIDLIST *)*((_QWORD *)v13 + 3);
        v6 = *((_QWORD *)v13 + 4);
        v5 = *((_QWORD *)v13 + 5);
        v25 = *((_QWORD *)v13 + 6);
        if ( v13 != qword_14012E098 )
        {
          **((_QWORD **)v13 + 1) = *(_QWORD *)v13;
          *(_QWORD *)(*(_QWORD *)v13 + 8i64) = *((_QWORD *)v13 + 1);
          j_free(v13);
          --qword_14012E0A0;
        }
        v12 = 1;
      }
      else
      {
        v12 = 0;
        ++dword_14012DD48;
      }
      LeaveCriticalSection(&stru_14012DAD0);
    }
    while ( v12 );
  }
}
// 14012DD48: using guessed type int dword_14012DD48;
// 14012E0A0: using guessed type __int64 qword_14012E0A0;
// 140071F30: using guessed type char var_2C8[8];
// 140071F30: using guessed type char var_240[528];

//----- (0000000140072270) ----------------------------------------------------
void __fastcall sub_140072270(ULONG_PTR dwData, int a2)
{
  __int64 v4; // rdx
  __int64 v5; // r11
  const ITEMIDLIST *v6; // rcx
  __int64 v7; // rbx
  const ITEMIDLIST *v8; // rdx
  __int64 v9; // rcx
  _QWORD *v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rdx
  char *v13; // rax
  void *v14; // rdx
  __int64 v15[2]; // [rsp+20h] [rbp-38h] BYREF
  int v16; // [rsp+30h] [rbp-28h]
  __int64 v17; // [rsp+38h] [rbp-20h]
  __int64 v18; // [rsp+40h] [rbp-18h]

  EnterCriticalSection(&stru_14012DAD0);
  v4 = *(_QWORD *)(dwData + 96);
  v5 = *(_QWORD *)(dwData + 56);
  v6 = *(const ITEMIDLIST **)(dwData + 136);
  v16 = a2;
  v7 = 568i64 * a2;
  v8 = *(const ITEMIDLIST **)(v4 + v7);
  v15[0] = v5;
  v15[1] = (__int64)ILCombine(v6, v8);
  v9 = v7 + *(_QWORD *)(dwData + 96);
  v10 = qword_14012E098;
  v11 = *(_QWORD *)(dwData + 152);
  v12 = *((_QWORD *)qword_14012E098 + 1);
  v17 = v9;
  v18 = v11;
  v13 = sub_14001C600((__int64)qword_14012E098, v12, v15);
  if ( qword_14012E0A0 == 0x666666666666665i64 )
    sub_14002B5F8("list<T> too long");
  ++qword_14012E0A0;
  v10[1] = v13;
  **((_QWORD **)v13 + 1) = v13;
  if ( dword_14012DD48 == dword_14012DD44 )
  {
    v14 = *(void **)(dwData + 112);
    ++dword_14012DD44;
    QueueUserAPC((PAPCFUNC)sub_140071F30, v14, dwData);
  }
  LeaveCriticalSection(&stru_14012DAD0);
}
// 14012DD44: using guessed type int dword_14012DD44;
// 14012DD48: using guessed type int dword_14012DD48;
// 14012E0A0: using guessed type __int64 qword_14012E0A0;

//----- (0000000140072380) ----------------------------------------------------
__int64 __fastcall sub_140072380(__int64 a1)
{
  int v2; // esi
  int i; // ebx
  HWND v4; // rcx
  __int64 v5; // rax
  __int64 result; // rax
  _DWORD lParam[20]; // [rsp+20h] [rbp-58h] BYREF

  SendMessageW(*(HWND *)(a1 + 56), 0x1036u, 0x8000ui64, 0i64);
  SendMessageW(*(HWND *)(a1 + 56), 0x1035u, 0i64, -1i64);
  v2 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  EnterCriticalSection(&stru_14012DAD0);
  LeaveCriticalSection(&stru_14012DAD0);
  for ( i = 0; i < v2; ++i )
  {
    v4 = *(HWND *)(a1 + 56);
    lParam[0] = 2;
    lParam[1] = i;
    lParam[2] = 0;
    lParam[9] = -1;
    SendMessageW(v4, 0x104Cu, 0i64, (LPARAM)lParam);
  }
  v5 = SendMessageW(*(HWND *)(a1 + 56), 0x1002u, 0i64, 0i64);
  result = sub_14000A390(v5);
  *(_DWORD *)(a1 + 1176) = 0;
  return result;
}

//----- (0000000140072480) ----------------------------------------------------
LRESULT __fastcall sub_140072480(__int64 a1)
{
  signed int v2; // esi
  LRESULT v3; // rax
  HWND v4; // rcx
  __int64 v5; // rax
  LRESULT result; // rax
  signed int i; // ebx
  HWND v8; // rcx
  _DWORD lParam[20]; // [rsp+30h] [rbp-58h] BYREF
  void *ppvObj; // [rsp+90h] [rbp+8h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  ppvObj = 0i64;
  SHGetImageList(0, &stru_1400E4120, &ppvObj);
  SendMessageW(*(HWND *)(a1 + 56), 0x1003u, 0i64, (LPARAM)ppvObj);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppvObj + 16i64))(ppvObj);
  v3 = SendMessageW(*(HWND *)(a1 + 56), 0x1002u, 0i64, 0i64);
  v4 = *(HWND *)(a1 + 56);
  *(_QWORD *)(a1 + 80) = v3;
  SendMessageW(v4, 0x1036u, 0x8000ui64, 0x8000i64);
  SendMessageW(*(HWND *)(a1 + 56), 0x1035u, 0i64, 9175180i64);
  v5 = sub_1400016D0(0x78u, 0x78u, 0x20u, v2, v2 + 100);
  result = SendMessageW(*(HWND *)(a1 + 56), 0x1003u, 0i64, v5);
  for ( i = 0; i < v2; ++i )
  {
    v8 = *(HWND *)(a1 + 56);
    lParam[0] = 2;
    lParam[1] = i;
    lParam[2] = 0;
    lParam[9] = -1;
    result = SendMessageW(v8, 0x104Cu, 0i64, (LPARAM)lParam);
  }
  *(_DWORD *)(a1 + 1176) = 1;
  return result;
}

//----- (00000001400725E0) ----------------------------------------------------
__int64 __fastcall sub_1400725E0(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 12));
}

//----- (00000001400725F0) ----------------------------------------------------
__int64 __fastcall sub_1400725F0(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 12) - 1);
}

//----- (0000000140072600) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_140072600(__int64 a1, int a2)
{
  __int64 v2; // r8

  v2 = *(int *)(a1 + 12);
  if ( (int)v2 + a2 < 0 || (int)v2 + a2 > *(_DWORD *)(a1 + 16) )
    return 0i64;
  else
    return ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 24) + 8 * (a2 + v2) - 8));
}

//----- (0000000140072630) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_140072630(__int64 a1, int a2)
{
  int v2; // er8

  v2 = a2 + *(_DWORD *)(a1 + 12);
  if ( v2 < 0 || v2 > *(_DWORD *)(a1 + 16) )
    return 0i64;
  *(_DWORD *)(a1 + 12) = v2;
  return ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 24) + 8i64 * v2 - 8));
}

//----- (0000000140072670) ----------------------------------------------------
__int64 __fastcall sub_140072670(__int64 a1, int a2)
{
  __int64 result; // rax
  __int64 v3; // r9

  result = (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
  if ( a2 >= (int)result )
  {
    --*(_DWORD *)(a1 + 16);
  }
  else
  {
    v3 = 8i64 * a2;
    do
    {
      ++a2;
      v3 += 8i64;
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + v3 - 8) = *(_QWORD *)(*(_QWORD *)(a1 + 24) + v3);
      result = (unsigned int)(*(_DWORD *)(a1 + 16) - 1);
    }
    while ( a2 < (int)result );
    --*(_DWORD *)(a1 + 16);
  }
  return result;
}

//----- (00000001400726C0) ----------------------------------------------------
__int64 __fastcall sub_1400726C0(__int64 a1, const ITEMIDLIST *a2)
{
  int v3; // ecx
  int v5; // eax
  void *v6; // rcx
  __int64 result; // rax

  v3 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 12) >= v3 - 1 )
  {
    v5 = v3 + 10;
    v6 = *(void **)(a1 + 24);
    *(_DWORD *)(a1 + 20) = v5;
    *(_QWORD *)(a1 + 24) = realloc(v6, 8i64 * v5);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64 * (int)(*(_DWORD *)(a1 + 12))++) = ILClone(a2);
  result = *(unsigned int *)(a1 + 12);
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (0000000140072730) ----------------------------------------------------
__int64 __fastcall sub_140072730(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0000000140072760) ----------------------------------------------------
__int64 __fastcall sub_140072760(__int64 a1)
{
  void *v2; // rax

  *(_QWORD *)(a1 + 8) = 1i64;
  *(_QWORD *)a1 = &CPathManager::`vftable';
  *(_DWORD *)(a1 + 20) = 10;
  v2 = malloc(0x50ui64);
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = v2;
  return a1;
}
// 1400F8248: using guessed type void *CPathManager::`vftable';

//----- (00000001400727B0) ----------------------------------------------------
BOOL __fastcall sub_1400727B0(__int64 a1, HWND a2, int *a3, int a4)
{
  HMENU PopupMenu; // r14
  int v8; // ecx
  int v9; // er12
  int v10; // ecx
  __int64 v11; // r13
  __int64 v12; // rbx
  int v13; // er12
  const ITEMIDLIST *v14; // rdi
  int v15; // ecx
  __int64 v16; // rdx
  __int64 v17; // r13
  __int64 v18; // rbx
  int v19; // er12
  const ITEMIDLIST *v20; // rdi
  void *ppv; // [rsp+40h] [rbp-C0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+48h] [rbp-B8h] BYREF
  HWND hWnd; // [rsp+50h] [rbp-B0h]
  STRRET pstr; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR pszBuf[264]; // [rsp+170h] [rbp+70h] BYREF

  hWnd = a2;
  PopupMenu = CreatePopupMenu();
  if ( a4 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
    v8 = *(_DWORD *)(a1 + 12);
    v9 = v8 - 1;
    if ( v8 <= 10 )
      v10 = 0;
    else
      v10 = v8 - 10;
    v11 = v10;
    v12 = v9 - 1;
    if ( v12 >= v10 )
    {
      v13 = 1;
      do
      {
        v14 = *(const ITEMIDLIST **)(*(_QWORD *)(a1 + 24) + 8 * v12);
        if ( v14 )
        {
          ppv = 0i64;
          ppidlLast = 0i64;
          if ( SHBindToParent(v14, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
          {
            if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
                   ppv,
                   ppidlLast,
                   1i64,
                   &pstr) >= 0 )
              StrRetToBufW(&pstr, v14, pszBuf, 0x104u);
            (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
          }
        }
        AppendMenuW(PopupMenu, 0, v13, pszBuf);
        --v12;
        ++v13;
      }
      while ( v12 >= v11 );
    }
  }
  else
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 32i64))(a1);
    v15 = *(_DWORD *)(a1 + 16);
    v16 = *(int *)(a1 + 12);
    if ( v15 - (int)v16 > 10 )
      v15 = *(_DWORD *)(a1 + 12) + 10;
    v17 = v15;
    v18 = *(int *)(a1 + 12);
    if ( v16 < v15 )
    {
      v19 = 1;
      do
      {
        v20 = *(const ITEMIDLIST **)(*(_QWORD *)(a1 + 24) + 8 * v18);
        if ( v20 )
        {
          ppv = 0i64;
          ppidlLast = 0i64;
          if ( SHBindToParent(v20, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
          {
            if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
                   ppv,
                   ppidlLast,
                   1i64,
                   &pstr) >= 0 )
              StrRetToBufW(&pstr, v20, pszBuf, 0x104u);
            (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
          }
        }
        AppendMenuW(PopupMenu, 0, v19, pszBuf);
        ++v18;
        ++v19;
      }
      while ( v18 < v17 );
    }
  }
  return TrackPopupMenu(PopupMenu, 0x100u, *a3, a3[1], 0, hWnd, 0i64);
}

//----- (0000000140072A10) ----------------------------------------------------
__int64 __fastcall sub_140072A10(_DWORD *a1)
{
  bool v1; // zf
  __int64 result; // rax

  v1 = a1[2]-- == 1;
  result = (unsigned int)a1[2];
  if ( v1 )
  {
    *(_QWORD *)a1 = &CPathManager::`vftable';
    j_free(a1);
    return 0i64;
  }
  return result;
}
// 1400F8248: using guessed type void *CPathManager::`vftable';

//----- (0000000140072A40) ----------------------------------------------------
__int64 __fastcall sub_140072A40(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // er9
  bool v4; // cf
  unsigned __int64 v5; // r10

  v3 = 0;
  *a3 = 0i64;
  v4 = 0;
  if ( *a2 || (v5 = a2[1], v4 = v5 < *(_QWORD *)stru_1400E4110.Data4, v5 != *(_QWORD *)stru_1400E4110.Data4) )
    v3 = -v4 - (v4 - 1);
  if ( v3 )
    return 2147500034i64;
  *a3 = a1;
  if ( !a1 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}

//----- (0000000140072AA0) ----------------------------------------------------
char *__fastcall sub_140072AA0(__int64 a1, __int64 *a2)
{
  int v4; // er8
  __int64 v5; // rcx
  char *result; // rax
  __int64 v7; // rsi
  __int64 v8; // rbx
  LPITEMIDLIST v9; // rax
  __int64 v10; // r12
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  LPITEMIDLIST v14; // [rsp+40h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 32i64))(a1);
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(int *)(a1 + 12);
  result = (char *)(unsigned int)(v4 - v5);
  if ( (int)result > 10 )
    v4 = *(_DWORD *)(a1 + 12) + 10;
  v7 = v4;
  v8 = *(int *)(a1 + 12);
  if ( v5 < v4 )
  {
    do
    {
      v9 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 24) + 8 * v8));
      v10 = *a2;
      v11 = *(_QWORD *)(*a2 + 8);
      v12 = *a2;
      v14 = v9;
      result = sub_14000BB70(v12, v11, &v14);
      v13 = a2[1];
      if ( v13 == 0x1FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      ++v8;
      a2[1] = v13 + 1;
      *(_QWORD *)(v10 + 8) = result;
      **((_QWORD **)result + 1) = result;
    }
    while ( v8 < v7 );
  }
  return result;
}

//----- (0000000140072B70) ----------------------------------------------------
char *__fastcall sub_140072B70(__int64 a1, __int64 *a2)
{
  int v4; // eax
  int v5; // er8
  char *result; // rax
  __int64 v7; // rbp
  __int64 i; // rbx
  LPITEMIDLIST v9; // rax
  __int64 v10; // r12
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  LPITEMIDLIST v14; // [rsp+40h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  v4 = *(_DWORD *)(a1 + 12);
  if ( v4 <= 10 )
    v5 = 0;
  else
    v5 = v4 - 10;
  result = (char *)(unsigned int)(v4 - 2);
  v7 = v5;
  for ( i = (int)result; i >= v7; **((_QWORD **)result + 1) = result )
  {
    v9 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(a1 + 24) + 8 * i));
    v10 = *a2;
    v11 = *(_QWORD *)(*a2 + 8);
    v12 = *a2;
    v14 = v9;
    result = sub_14000BB70(v12, v11, &v14);
    v13 = a2[1];
    if ( v13 == 0x1FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    --i;
    a2[1] = v13 + 1;
    *(_QWORD *)(v10 + 8) = result;
  }
  return result;
}

//----- (0000000140072C40) ----------------------------------------------------
LPITEMIDLIST __fastcall sub_140072C40(__int64 a1, int a2)
{
  __int64 v3; // rcx
  __int64 v4; // rdi
  int v5; // eax
  __int64 v6; // rcx

  v3 = *(int *)(a1 + 12);
  v4 = a2;
  if ( (int)v3 + a2 < 0 || (int)v3 + a2 > *(_DWORD *)(a1 + 16) )
    return 0i64;
  v5 = sub_14007FB00(*(const ITEMIDLIST **)(*(_QWORD *)(a1 + 24) + 8 * (a2 + v3) - 8));
  v6 = *(_QWORD *)(a1 + 24);
  if ( v5 )
  {
    *(_DWORD *)(a1 + 12) += v4;
    return ILClone(*(LPCITEMIDLIST *)(v6 + 8i64 * *(int *)(a1 + 12) - 8));
  }
  else
  {
    CoTaskMemFree(*(LPVOID *)(v6 + 8 * (v4 + *(int *)(a1 + 12)) - 8));
    sub_140072670(a1, v4 + *(_DWORD *)(a1 + 12) - 1);
    return 0i64;
  }
}

//----- (0000000140072CF0) ----------------------------------------------------
LRESULT __fastcall sub_140072CF0(__int64 a1)
{
  SendMessageW(*(HWND *)(a1 + 56), 0x101Cu, 3ui64, 0i64);
  SendMessageW(*(HWND *)(a1 + 56), 0x101Cu, 2ui64, 0i64);
  return SendMessageW(*(HWND *)(a1 + 56), 0x101Cu, 1ui64, 0i64);
}

//----- (0000000140072D50) ----------------------------------------------------
LRESULT __fastcall sub_140072D50(__int64 a1)
{
  HWND v2; // rcx
  HWND v3; // rcx
  HWND v4; // rcx
  HWND v5; // rcx
  int lParam[4]; // [rsp+20h] [rbp-68h] BYREF
  void *v8; // [rsp+30h] [rbp-58h]
  _DWORD v9[10]; // [rsp+48h] [rbp-40h] BYREF

  v2 = *(HWND *)(a1 + 56);
  lParam[0] = 4;
  v8 = &unk_1400EA2FC;
  SendMessageW(v2, 0x1061u, 1ui64, (LPARAM)lParam);
  v3 = *(HWND *)(a1 + 56);
  v8 = &unk_1400EA32C;
  lParam[0] = 4;
  SendMessageW(v3, 0x1061u, 2ui64, (LPARAM)lParam);
  v4 = *(HWND *)(a1 + 56);
  lParam[0] = 4;
  v8 = &unk_1400EA354;
  SendMessageW(v4, 0x1061u, 3ui64, (LPARAM)lParam);
  v5 = *(HWND *)(a1 + 56);
  v9[0] = 40;
  *(_QWORD *)&v9[1] = 2i64;
  v9[5] = 2;
  return SendMessageW(v5, 0x10A2u, 0i64, (LPARAM)v9);
}
// 140072D50: using guessed type _DWORD lParam[4];

//----- (0000000140072E50) ----------------------------------------------------
void __fastcall sub_140072E50(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 732) = a2;
}

//----- (0000000140072E60) ----------------------------------------------------
void __fastcall sub_140072E60(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 728) = a2;
}

//----- (0000000140072E70) ----------------------------------------------------
__int64 __fastcall sub_140072E70(__int64 a1)
{
  return *(unsigned int *)(a1 + 832);
}

//----- (0000000140072E80) ----------------------------------------------------
void __fastcall sub_140072E80(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 832) = a2;
}

//----- (0000000140072E90) ----------------------------------------------------
__int64 __fastcall sub_140072E90(__int64 a1)
{
  return *(unsigned int *)(a1 + 808);
}

//----- (0000000140072EA0) ----------------------------------------------------
void __fastcall sub_140072EA0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 808) = a2;
}

//----- (0000000140072EB0) ----------------------------------------------------
void __fastcall sub_140072EB0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 720) = a2;
}

//----- (0000000140072EC0) ----------------------------------------------------
__int64 __fastcall sub_140072EC0(__int64 a1)
{
  return *(unsigned int *)(a1 + 716);
}

//----- (0000000140072ED0) ----------------------------------------------------
void __fastcall sub_140072ED0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 716) = a2;
}

//----- (0000000140072EE0) ----------------------------------------------------
__int64 __fastcall sub_140072EE0(__int64 a1)
{
  return *(unsigned int *)(a1 + 828);
}

//----- (0000000140072EF0) ----------------------------------------------------
void __fastcall sub_140072EF0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 828) = a2;
}

//----- (0000000140072F00) ----------------------------------------------------
__int64 __fastcall sub_140072F00(__int64 a1)
{
  return *(unsigned int *)(a1 + 820);
}

//----- (0000000140072F10) ----------------------------------------------------
void __fastcall sub_140072F10(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 820) = a2;
}

//----- (0000000140072F20) ----------------------------------------------------
__int64 __fastcall sub_140072F20(__int64 a1)
{
  return *(unsigned int *)(a1 + 824);
}

//----- (0000000140072F30) ----------------------------------------------------
void __fastcall sub_140072F30(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 824) = a2;
}

//----- (0000000140072F40) ----------------------------------------------------
__int64 __fastcall sub_140072F40(__int64 a1)
{
  (*(void (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)(a1 + 8) + 24i64))(
    a1 + 8,
    *(_QWORD *)(a1 + 128),
    134217729i64);
  return 0i64;
}

//----- (0000000140072F70) ----------------------------------------------------
void __fastcall sub_140072F70(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 144) = a2;
}

//----- (0000000140072F80) ----------------------------------------------------
__int64 __fastcall sub_140072F80(__int64 a1)
{
  return *(unsigned int *)(a1 + 812);
}

//----- (0000000140072F90) ----------------------------------------------------
void *__fastcall sub_140072F90(__int64 a1)
{
  void *result; // rax

  *(_QWORD *)(a1 + 88) = malloc(0x24220ui64);
  result = malloc(0x22AB0ui64);
  *(_DWORD *)(a1 + 768) = 250;
  *(_QWORD *)(a1 + 96) = result;
  return result;
}

//----- (0000000140072FD0) ----------------------------------------------------
void __fastcall sub_140072FD0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 852) = a2;
}

//----- (0000000140072FE0) ----------------------------------------------------
__int64 __fastcall sub_140072FE0(__int64 a1)
{
  return *(unsigned int *)(a1 + 852);
}

//----- (0000000140072FF0) ----------------------------------------------------
__int64 __fastcall sub_140072FF0(_DWORD *a1, _DWORD *a2)
{
  __int64 result; // rax

  a1[205] = *a2;
  a1[202] = a2[2];
  result = (unsigned int)a2[3];
  a1[179] = result;
  return result;
}

//----- (0000000140073020) ----------------------------------------------------
int *__fastcall sub_140073020(_DWORD *a1)
{
  dword_14012E1E4 = a1[199];
  dword_14012E1E8 = a1[203];
  dword_14012E1E0 = a1[204];
  dword_14012E1DC = a1[200];
  dword_14012E1D8 = a1[201];
  dword_14012E1D0 = a1[172];
  dword_14012E1D4 = a1[173];
  return &dword_14012E1D0;
}
// 14012E1D0: using guessed type int dword_14012E1D0;
// 14012E1D4: using guessed type int dword_14012E1D4;
// 14012E1D8: using guessed type int dword_14012E1D8;
// 14012E1DC: using guessed type int dword_14012E1DC;
// 14012E1E0: using guessed type int dword_14012E1E0;
// 14012E1E4: using guessed type int dword_14012E1E4;
// 14012E1E8: using guessed type int dword_14012E1E8;

//----- (0000000140073090) ----------------------------------------------------
HRESULT __fastcall sub_140073090(__int64 a1)
{
  _QWORD *v1; // rbx
  HRESULT result; // eax
  int v4; // ebx

  v1 = (_QWORD *)(a1 + 1376);
  result = CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)(a1 + 1376));
  if ( result >= 0 )
  {
    v4 = (**(__int64 (__fastcall ***)(_QWORD, void *, __int64))*v1)(*v1, &unk_1400E4040, a1 + 1384);
    RegisterDragDrop(*(HWND *)(a1 + 56), (LPDROPTARGET)(a1 + 32));
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16i64))(a1);
    return v4;
  }
  return result;
}

//----- (0000000140073150) ----------------------------------------------------
__int64 __fastcall sub_140073150(__int64 a1)
{
  return *(unsigned int *)(a1 + 816);
}

//----- (0000000140073160) ----------------------------------------------------
__int64 __fastcall sub_140073160(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 704) = a2;
  return 0i64;
}

//----- (0000000140073170) ----------------------------------------------------
__int64 __fastcall sub_140073170(__int64 a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 704);
  return 0i64;
}

//----- (0000000140073190) ----------------------------------------------------
__int64 __fastcall sub_140073190(__int64 a1, _DWORD *a2)
{
  if ( !a2 )
    return 2147942487i64;
  *a2 = *(_DWORD *)(a1 + 708);
  return 0i64;
}

//----- (00000001400731B0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400731B0(__int64 a1)
{
  return *(_DWORD *)(a1 + 812) != 0;
}

//----- (00000001400731D0) ----------------------------------------------------
__int64 __fastcall sub_1400731D0(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 48) + 1);
  *(_DWORD *)(a1 + 48) = result;
  return result;
}

//----- (00000001400731E0) ----------------------------------------------------
LRESULT __fastcall sub_1400731E0(__int64 a1)
{
  HWND v1; // rdi
  BOOL v2; // ebx
  unsigned int v3; // eax

  v1 = *(HWND *)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 812) == 0;
  *(_DWORD *)(a1 + 812) = v2;
  v3 = SendMessageW(v1, 0x1037u, 0i64, 0i64);
  if ( v2 )
  {
    v3 |= 1u;
  }
  else if ( (v3 & 1) != 0 )
  {
    v3 &= ~1u;
  }
  return SendMessageW(v1, 0x1036u, 0i64, v3);
}

//----- (0000000140073250) ----------------------------------------------------
__int64 __fastcall sub_140073250(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // rax
  bool v5; // cf
  unsigned __int64 v6; // r11
  __int64 v7; // rdx
  bool v8; // cf
  unsigned __int64 v9; // r11
  bool v10; // cf
  unsigned __int64 v11; // r11
  bool v12; // cf
  unsigned __int64 v13; // r10

  v3 = 0i64;
  *a3 = 0i64;
  v5 = *a2 < 0x4519CCC9CDE725B0ui64;
  if ( *a2 == 0x4519CCC9CDE725B0i64 && (v6 = a2[1], v5 = v6 < 0xCEB4FA725D327E91ui64, v6 == 0xCEB4FA725D327E91ui64) )
    v7 = 0i64;
  else
    v7 = -v5 - ((unsigned int)v5 - 1);
  if ( (_DWORD)v7 )
  {
    v8 = *a2 < 0x214E3ui64;
    if ( *a2 == 136419i64 && (v9 = a2[1], v8 = v9 < 0x46000000000000C0i64, v9 == 0x46000000000000C0i64) )
      v7 = 0i64;
    else
      v7 = -v8 - ((unsigned int)v8 - 1);
    if ( (_DWORD)v7 )
    {
      v10 = *a2 < 0x214E2ui64;
      if ( *a2 == 136418i64 && (v11 = a2[1], v10 = v11 < 0x46000000000000C0i64, v11 == 0x46000000000000C0i64) )
        v7 = 0i64;
      else
        v7 = -v10 - ((unsigned int)v10 - 1);
      if ( (_DWORD)v7 )
      {
        v12 = *a2 < 0x214E6ui64;
        if ( *a2 == 136422i64 && (v13 = a2[1], v12 = v13 < 0x46000000000000C0i64, v13 == 0x46000000000000C0i64) )
          v7 = 0i64;
        else
          v7 = -v12 - ((unsigned int)v12 - 1);
        if ( (_DWORD)v7 )
          return 2147500034i64;
        if ( a1 )
          v3 = a1 + 24;
      }
      else if ( a1 )
      {
        v3 = a1 + 16;
      }
    }
    else if ( a1 )
    {
      v3 = a1 + 8;
    }
    *a3 = v3;
  }
  else
  {
    *a3 = a1;
  }
  if ( *a3 )
  {
    (*(void (__fastcall **)(__int64, __int64, _QWORD *, _QWORD *))(*(_QWORD *)a1 + 8i64))(a1, v7, a3, a2);
    return 0i64;
  }
  return 2147500034i64;
}

//----- (0000000140073350) ----------------------------------------------------
void __fastcall sub_140073350(__int64 a1)
{
  int v2; // esi
  int i; // ebx
  _QWORD **v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  _QWORD **v7; // rax
  _QWORD *v8; // rcx
  _QWORD *v9; // rbx
  _QWORD **v10; // rax
  _QWORD *v11; // rcx
  _QWORD *v12; // rbx
  _QWORD **v13; // rax
  _QWORD *v14; // rcx
  _QWORD *v15; // rbx
  _QWORD **v16; // rax
  _QWORD *v17; // rcx
  _QWORD *v18; // rbx
  _QWORD **v19; // rax
  _QWORD *v20; // rcx
  _QWORD *v21; // rbx
  _QWORD **v22; // rax
  _QWORD *v23; // rcx
  _QWORD *v24; // rbx
  _QWORD **v25; // rax
  _QWORD *v26; // rcx
  _QWORD *v27; // rbx
  _QWORD **v28; // rax
  _QWORD *v29; // rcx
  _QWORD *v30; // rbx
  _QWORD **v31; // rax
  _QWORD *v32; // rcx
  _QWORD *v33; // rbx
  _QWORD **v34; // rax
  _QWORD *v35; // rcx
  _QWORD *v36; // rbx
  _QWORD **v37; // rax
  _QWORD *v38; // rcx
  _QWORD *v39; // rbx
  _QWORD **v40; // rax
  _QWORD *v41; // rcx
  _QWORD *v42; // rbx
  void **v43; // rax
  void **v44; // rbx
  void **v45; // rsi
  _QWORD **v46; // rax
  _QWORD *v47; // rcx
  _QWORD *v48; // rbx
  _QWORD **v49; // rax
  _QWORD *v50; // rcx
  _QWORD *v51; // rbx
  _QWORD **v52; // rax
  _QWORD *v53; // rcx
  _QWORD *v54; // rbx
  _DWORD lParam[10]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v56; // [rsp+58h] [rbp-30h]

  *(_QWORD *)a1 = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 8) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 16) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 24) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 32) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 40) = &CFolderView::`vftable';
  sub_14006FA40(a1);
  EnterCriticalSection(&stru_14012DAD0);
  LeaveCriticalSection(&stru_14012DAD0);
  sub_14006A140(a1);
  sub_14006A0B0(a1);
  WaitForSingleObject(*(HANDLE *)(a1 + 152), 0xFFFFFFFF);
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 1384) + 16i64))(*(_QWORD *)(a1 + 1384));
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 1376) + 16i64))(*(_QWORD *)(a1 + 1376));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 856));
  v2 = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  for ( i = 0; i < v2; ++i )
  {
    lParam[0] = 4;
    lParam[1] = i;
    lParam[2] = 0;
    SendMessageW(*(HWND *)(a1 + 56), 0x104Bu, 0i64, (LPARAM)lParam);
    CoTaskMemFree(*(LPVOID *)(568 * v56 + *(_QWORD *)(a1 + 96)));
  }
  CoTaskMemFree(*(LPVOID *)(a1 + 136));
  *(_QWORD *)(a1 + 1016) = 0i64;
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 104) + 16i64))(*(_QWORD *)(a1 + 104));
  free(*(void **)(a1 + 792));
  free(*(void **)(a1 + 96));
  free(*(void **)(a1 + 88));
  v4 = *(_QWORD ***)(a1 + 1512);
  v5 = *v4;
  *v4 = v4;
  *(_QWORD *)(*(_QWORD *)(a1 + 1512) + 8i64) = *(_QWORD *)(a1 + 1512);
  *(_QWORD *)(a1 + 1520) = 0i64;
  if ( v5 != *(_QWORD **)(a1 + 1512) )
  {
    do
    {
      v6 = (_QWORD *)*v5;
      j_free(v5);
      v5 = v6;
    }
    while ( v6 != *(_QWORD **)(a1 + 1512) );
  }
  j_free(*(void **)(a1 + 1512));
  v7 = *(_QWORD ***)(a1 + 1480);
  v8 = *v7;
  *v7 = v7;
  *(_QWORD *)(*(_QWORD *)(a1 + 1480) + 8i64) = *(_QWORD *)(a1 + 1480);
  *(_QWORD *)(a1 + 1488) = 0i64;
  if ( v8 != *(_QWORD **)(a1 + 1480) )
  {
    do
    {
      v9 = (_QWORD *)*v8;
      j_free(v8);
      v8 = v9;
    }
    while ( v9 != *(_QWORD **)(a1 + 1480) );
  }
  j_free(*(void **)(a1 + 1480));
  v10 = *(_QWORD ***)(a1 + 1416);
  v11 = *v10;
  *v10 = v10;
  *(_QWORD *)(*(_QWORD *)(a1 + 1416) + 8i64) = *(_QWORD *)(a1 + 1416);
  *(_QWORD *)(a1 + 1424) = 0i64;
  if ( v11 != *(_QWORD **)(a1 + 1416) )
  {
    do
    {
      v12 = (_QWORD *)*v11;
      j_free(v11);
      v11 = v12;
    }
    while ( v12 != *(_QWORD **)(a1 + 1416) );
  }
  j_free(*(void **)(a1 + 1416));
  v13 = *(_QWORD ***)(a1 + 1392);
  v14 = *v13;
  *v13 = v13;
  *(_QWORD *)(*(_QWORD *)(a1 + 1392) + 8i64) = *(_QWORD *)(a1 + 1392);
  *(_QWORD *)(a1 + 1400) = 0i64;
  if ( v14 != *(_QWORD **)(a1 + 1392) )
  {
    do
    {
      v15 = (_QWORD *)*v14;
      j_free(v14);
      v14 = v15;
    }
    while ( v15 != *(_QWORD **)(a1 + 1392) );
  }
  j_free(*(void **)(a1 + 1392));
  v16 = *(_QWORD ***)(a1 + 1336);
  v17 = *v16;
  *v16 = v16;
  *(_QWORD *)(*(_QWORD *)(a1 + 1336) + 8i64) = *(_QWORD *)(a1 + 1336);
  *(_QWORD *)(a1 + 1344) = 0i64;
  if ( v17 != *(_QWORD **)(a1 + 1336) )
  {
    do
    {
      v18 = (_QWORD *)*v17;
      j_free(v17);
      v17 = v18;
    }
    while ( v18 != *(_QWORD **)(a1 + 1336) );
  }
  j_free(*(void **)(a1 + 1336));
  v19 = *(_QWORD ***)(a1 + 1312);
  v20 = *v19;
  *v19 = v19;
  *(_QWORD *)(*(_QWORD *)(a1 + 1312) + 8i64) = *(_QWORD *)(a1 + 1312);
  *(_QWORD *)(a1 + 1320) = 0i64;
  if ( v20 != *(_QWORD **)(a1 + 1312) )
  {
    do
    {
      v21 = (_QWORD *)*v20;
      j_free(v20);
      v20 = v21;
    }
    while ( v21 != *(_QWORD **)(a1 + 1312) );
  }
  j_free(*(void **)(a1 + 1312));
  v22 = *(_QWORD ***)(a1 + 1288);
  v23 = *v22;
  *v22 = v22;
  *(_QWORD *)(*(_QWORD *)(a1 + 1288) + 8i64) = *(_QWORD *)(a1 + 1288);
  *(_QWORD *)(a1 + 1296) = 0i64;
  if ( v23 != *(_QWORD **)(a1 + 1288) )
  {
    do
    {
      v24 = (_QWORD *)*v23;
      j_free(v23);
      v23 = v24;
    }
    while ( v24 != *(_QWORD **)(a1 + 1288) );
  }
  j_free(*(void **)(a1 + 1288));
  v25 = *(_QWORD ***)(a1 + 1264);
  v26 = *v25;
  *v25 = v25;
  *(_QWORD *)(*(_QWORD *)(a1 + 1264) + 8i64) = *(_QWORD *)(a1 + 1264);
  *(_QWORD *)(a1 + 1272) = 0i64;
  if ( v26 != *(_QWORD **)(a1 + 1264) )
  {
    do
    {
      v27 = (_QWORD *)*v26;
      j_free(v26);
      v26 = v27;
    }
    while ( v27 != *(_QWORD **)(a1 + 1264) );
  }
  j_free(*(void **)(a1 + 1264));
  v28 = *(_QWORD ***)(a1 + 1240);
  v29 = *v28;
  *v28 = v28;
  *(_QWORD *)(*(_QWORD *)(a1 + 1240) + 8i64) = *(_QWORD *)(a1 + 1240);
  *(_QWORD *)(a1 + 1248) = 0i64;
  if ( v29 != *(_QWORD **)(a1 + 1240) )
  {
    do
    {
      v30 = (_QWORD *)*v29;
      j_free(v29);
      v29 = v30;
    }
    while ( v30 != *(_QWORD **)(a1 + 1240) );
  }
  j_free(*(void **)(a1 + 1240));
  v31 = *(_QWORD ***)(a1 + 1216);
  v32 = *v31;
  *v31 = v31;
  *(_QWORD *)(*(_QWORD *)(a1 + 1216) + 8i64) = *(_QWORD *)(a1 + 1216);
  *(_QWORD *)(a1 + 1224) = 0i64;
  if ( v32 != *(_QWORD **)(a1 + 1216) )
  {
    do
    {
      v33 = (_QWORD *)*v32;
      j_free(v32);
      v32 = v33;
    }
    while ( v33 != *(_QWORD **)(a1 + 1216) );
  }
  j_free(*(void **)(a1 + 1216));
  v34 = *(_QWORD ***)(a1 + 1192);
  v35 = *v34;
  *v34 = v34;
  *(_QWORD *)(*(_QWORD *)(a1 + 1192) + 8i64) = *(_QWORD *)(a1 + 1192);
  *(_QWORD *)(a1 + 1200) = 0i64;
  if ( v35 != *(_QWORD **)(a1 + 1192) )
  {
    do
    {
      v36 = (_QWORD *)*v35;
      j_free(v35);
      v35 = v36;
    }
    while ( v36 != *(_QWORD **)(a1 + 1192) );
  }
  j_free(*(void **)(a1 + 1192));
  v37 = *(_QWORD ***)(a1 + 1104);
  v38 = *v37;
  *v37 = v37;
  *(_QWORD *)(*(_QWORD *)(a1 + 1104) + 8i64) = *(_QWORD *)(a1 + 1104);
  *(_QWORD *)(a1 + 1112) = 0i64;
  if ( v38 != *(_QWORD **)(a1 + 1104) )
  {
    do
    {
      v39 = (_QWORD *)*v38;
      j_free(v38);
      v38 = v39;
    }
    while ( v39 != *(_QWORD **)(a1 + 1104) );
  }
  j_free(*(void **)(a1 + 1104));
  v40 = *(_QWORD ***)(a1 + 1032);
  v41 = *v40;
  *v40 = v40;
  *(_QWORD *)(*(_QWORD *)(a1 + 1032) + 8i64) = *(_QWORD *)(a1 + 1032);
  *(_QWORD *)(a1 + 1040) = 0i64;
  if ( v41 != *(_QWORD **)(a1 + 1032) )
  {
    do
    {
      v42 = (_QWORD *)*v41;
      j_free(v41);
      v41 = v42;
    }
    while ( v42 != *(_QWORD **)(a1 + 1032) );
  }
  j_free(*(void **)(a1 + 1032));
  v43 = *(void ***)(a1 + 992);
  v44 = (void **)*v43;
  *v43 = v43;
  *(_QWORD *)(*(_QWORD *)(a1 + 992) + 8i64) = *(_QWORD *)(a1 + 992);
  *(_QWORD *)(a1 + 1000) = 0i64;
  if ( v44 != *(void ***)(a1 + 992) )
  {
    do
    {
      v45 = (void **)*v44;
      if ( (unsigned __int64)v44[5] >= 8 )
        j_free(v44[2]);
      v44[5] = (void *)7;
      v44[4] = 0i64;
      *((_WORD *)v44 + 8) = 0;
      j_free(v44);
      v44 = v45;
    }
    while ( v45 != *(void ***)(a1 + 992) );
  }
  j_free(*(void **)(a1 + 992));
  v46 = *(_QWORD ***)(a1 + 944);
  v47 = *v46;
  *v46 = v46;
  *(_QWORD *)(*(_QWORD *)(a1 + 944) + 8i64) = *(_QWORD *)(a1 + 944);
  *(_QWORD *)(a1 + 952) = 0i64;
  if ( v47 != *(_QWORD **)(a1 + 944) )
  {
    do
    {
      v48 = (_QWORD *)*v47;
      j_free(v47);
      v47 = v48;
    }
    while ( v48 != *(_QWORD **)(a1 + 944) );
  }
  j_free(*(void **)(a1 + 944));
  v49 = *(_QWORD ***)(a1 + 920);
  v50 = *v49;
  *v49 = v49;
  *(_QWORD *)(*(_QWORD *)(a1 + 920) + 8i64) = *(_QWORD *)(a1 + 920);
  *(_QWORD *)(a1 + 928) = 0i64;
  if ( v50 != *(_QWORD **)(a1 + 920) )
  {
    do
    {
      v51 = (_QWORD *)*v50;
      j_free(v50);
      v50 = v51;
    }
    while ( v51 != *(_QWORD **)(a1 + 920) );
  }
  j_free(*(void **)(a1 + 920));
  v52 = *(_QWORD ***)(a1 + 896);
  v53 = *v52;
  *v52 = v52;
  *(_QWORD *)(*(_QWORD *)(a1 + 896) + 8i64) = *(_QWORD *)(a1 + 896);
  *(_QWORD *)(a1 + 904) = 0i64;
  if ( v53 != *(_QWORD **)(a1 + 896) )
  {
    do
    {
      v54 = (_QWORD *)*v53;
      j_free(v53);
      v53 = v54;
    }
    while ( v54 != *(_QWORD **)(a1 + 896) );
  }
  j_free(*(void **)(a1 + 896));
}
// 1400F7DE8: using guessed type void *CFolderView::`vftable';
// 1400F7E68: using guessed type void *CFolderView::`vftable';
// 1400F7E98: using guessed type void *CFolderView::`vftable';
// 1400F81C0: using guessed type void *CFolderView::`vftable';
// 1400F81F8: using guessed type void *CFolderView::`vftable';
// 1400F8238: using guessed type void *CFolderView::`vftable';

//----- (0000000140073A70) ----------------------------------------------------
__int64 __fastcall sub_140073A70(void *Block)
{
  if ( (*((_DWORD *)Block + 12))-- != 1 )
    return *((unsigned int *)Block + 12);
  sub_140073350((__int64)Block);
  j_free(Block);
  return 0i64;
}

//----- (0000000140073AB0) ----------------------------------------------------
char *__fastcall sub_140073AB0(__int64 a1, char **a2)
{
  _QWORD *v2; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  char *result; // rax
  char *i; // rbx
  _QWORD *v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rdx
  int v12[6]; // [rsp+20h] [rbp-18h] BYREF

  v2 = *(_QWORD **)a1;
  v5 = **(_QWORD ***)a1;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v5 != *(_QWORD **)a1 )
  {
    do
    {
      v6 = (_QWORD *)*v5;
      j_free(v5);
      v5 = v6;
    }
    while ( v6 != *(_QWORD **)a1 );
  }
  result = *a2;
  for ( i = *(char **)*a2; i != *a2; i = *(char **)i )
  {
    v9 = *(_QWORD **)a1;
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v12[0] = *((_DWORD *)i + 4);
    v12[1] = *((_DWORD *)i + 5);
    v12[2] = *((_DWORD *)i + 6);
    result = sub_140017AD0((__int64)v9, v10, v12);
    v11 = *(_QWORD *)(a1 + 8);
    if ( v11 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 8) = v11 + 1;
    v9[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  return result;
}

//----- (0000000140073BB0) ----------------------------------------------------
LRESULT __fastcall sub_140073BB0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v5; // r8
  int v6; // eax
  __int64 v7; // rdx
  __int16 v8; // ax
  int v9; // ebx
  HWND v10; // rdi
  unsigned int v11; // eax

  *(_DWORD *)(a1 + 796) = *(_DWORD *)(a2 + 20);
  v3 = a1 + 1520;
  *(_DWORD *)(v3 - 708) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(v3 - 704) = *(_DWORD *)(a2 + 16);
  v5 = a2 + 60 - v3;
  *(_DWORD *)(v3 - 720) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v3 - 716) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v3 - 832) = *(_DWORD *)a2;
  *(_DWORD *)(v3 - 828) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v3 + 1024) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(v3 + 1028) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(v3 - 804) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(v3 - 800) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(v3 - 696) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(v3 - 692) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v3 - 792) = *(_DWORD *)(a2 + 52);
  v6 = *(_DWORD *)(a2 + 56);
  v7 = 512i64;
  *(_DWORD *)(v3 - 788) = v6;
  while ( v7 != -2147483134 )
  {
    v8 = *(_WORD *)(v5 + v3);
    if ( !v8 )
      break;
    *(_WORD *)v3 = v8;
    v3 += 2i64;
    if ( !--v7 )
    {
      v3 -= 2i64;
      break;
    }
  }
  *(_WORD *)v3 = 0;
  sub_140073AB0(a1 + 1224, *(char ***)(a2 + 1104));
  sub_140073AB0(a1 + 1200, *(char ***)(a2 + 1096));
  sub_140073AB0(a1 + 1320, *(char ***)(a2 + 1136));
  sub_140073AB0(a1 + 1296, *(char ***)(a2 + 1128));
  sub_140073AB0(a1 + 1272, *(char ***)(a2 + 1120));
  sub_140073AB0(a1 + 1176, *(char ***)(a2 + 1088));
  sub_140073AB0(a1 + 1248, *(char ***)(a2 + 1112));
  v9 = *(_DWORD *)(a1 + 812);
  v10 = *(HWND *)(a1 + 40);
  v11 = SendMessageW(v10, 0x1037u, 0i64, 0i64);
  if ( v9 )
  {
    v11 |= 1u;
  }
  else if ( (v11 & 1) != 0 )
  {
    v11 &= ~1u;
  }
  return SendMessageW(v10, 0x1036u, 0i64, v11);
}
// 140073C87: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140073D70) ----------------------------------------------------
__int64 __fastcall sub_140073D70(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  _QWORD *v14; // rax
  _QWORD *v15; // rax
  _QWORD *v16; // rbx
  int v17; // ebx
  HWND v18; // rsi
  unsigned int WindowLongW; // eax
  int v20; // ebx
  HWND v21; // rsi
  unsigned int v22; // eax
  __int64 v23; // rbx
  __int64 v24; // rcx
  char *v26; // [rsp+38h] [rbp-D0h] BYREF
  char *v27; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v28[3]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 pExceptionObject[5]; // [rsp+60h] [rbp-A8h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+88h] [rbp-80h] BYREF
  SHFILEINFOW psfi; // [rsp+1A8h] [rbp+A0h] BYREF

  pExceptionObject[4] = -2i64;
  pExceptionObject[3] = a1;
  *(_QWORD *)a1 = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 8) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 16) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 24) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 32) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 40) = &CFolderView::`vftable';
  *(_QWORD *)(a1 + 904) = 0i64;
  v10 = operator new(0x220ui64);
  if ( !v10 )
  {
    v26 = 0i64;
    std::exception::exception((std::exception *)v28, (const char *const *)&v26);
    v28[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v28, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 896) = v10;
  *v10 = v10;
  *(_QWORD *)(*(_QWORD *)(a1 + 896) + 8i64) = *(_QWORD *)(a1 + 896);
  *(_QWORD *)(a1 + 928) = 0i64;
  v11 = operator new(0x218ui64);
  if ( !v11 )
  {
    v27 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 920) = v11;
  *v11 = v11;
  *(_QWORD *)(*(_QWORD *)(a1 + 920) + 8i64) = *(_QWORD *)(a1 + 920);
  *(_QWORD *)(a1 + 952) = 0i64;
  v12 = operator new(0x20ui64);
  if ( !v12 )
  {
    v26 = 0i64;
    std::exception::exception((std::exception *)v28, (const char *const *)&v26);
    v28[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v28, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 944) = v12;
  *v12 = v12;
  *(_QWORD *)(*(_QWORD *)(a1 + 944) + 8i64) = *(_QWORD *)(a1 + 944);
  sub_14000A5B0((_QWORD *)(a1 + 992));
  sub_14000AB00((_QWORD *)(a1 + 1032));
  sub_14000AB00((_QWORD *)(a1 + 1104));
  sub_14000AB70((_QWORD *)(a1 + 1192));
  sub_14000AB70((_QWORD *)(a1 + 1216));
  sub_14000AB70((_QWORD *)(a1 + 1240));
  sub_14000AB70((_QWORD *)(a1 + 1264));
  sub_14000AB70((_QWORD *)(a1 + 1288));
  sub_14000AB70((_QWORD *)(a1 + 1312));
  sub_14000AB70((_QWORD *)(a1 + 1336));
  *(_QWORD *)(a1 + 1400) = 0i64;
  v13 = operator new(0x220ui64);
  if ( !v13 )
  {
    v27 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 1392) = v13;
  *v13 = v13;
  *(_QWORD *)(*(_QWORD *)(a1 + 1392) + 8i64) = *(_QWORD *)(a1 + 1392);
  *(_QWORD *)(a1 + 1424) = 0i64;
  v14 = operator new(0x218ui64);
  if ( !v14 )
  {
    v26 = 0i64;
    std::exception::exception((std::exception *)v28, (const char *const *)&v26);
    v28[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v28, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 1416) = v14;
  *v14 = v14;
  *(_QWORD *)(*(_QWORD *)(a1 + 1416) + 8i64) = *(_QWORD *)(a1 + 1416);
  *(_QWORD *)(a1 + 1488) = 0i64;
  v15 = operator new(0x418ui64);
  if ( !v15 )
  {
    v27 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 1480) = v15;
  *v15 = v15;
  *(_QWORD *)(*(_QWORD *)(a1 + 1480) + 8i64) = *(_QWORD *)(a1 + 1480);
  sub_14000AB00((_QWORD *)(a1 + 1512));
  *(_DWORD *)(a1 + 48) = 1;
  *(_QWORD *)(a1 + 56) = a3;
  *(_QWORD *)(a1 + 64) = a2;
  sub_140073090(a1);
  *(_QWORD *)(a1 + 88) = malloc(0x24220ui64);
  *(_QWORD *)(a1 + 96) = malloc(0x22AB0ui64);
  *(_DWORD *)(a1 + 768) = 250;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) )
    *(_DWORD *)(a1 + 700) = VersionInformation.dwMajorVersion;
  v16 = operator new(0x20ui64);
  if ( v16 )
  {
    *v16 = &CPathManager::`vftable';
    v16[1] = 1i64;
    *((_DWORD *)v16 + 5) = 10;
    v16[3] = malloc(0x50ui64);
    *((_DWORD *)v16 + 4) = 0;
  }
  else
  {
    v16 = 0i64;
  }
  *(_QWORD *)(a1 + 104) = v16;
  *(_DWORD *)(a1 + 704) = 1;
  *(_DWORD *)(a1 + 708) = 1;
  *(_DWORD *)(a1 + 820) = 1;
  *(_QWORD *)(a1 + 812) = 1i64;
  *(_DWORD *)(a1 + 824) = 1;
  *(_QWORD *)(a1 + 2560) = 0i64;
  *(_QWORD *)(a1 + 828) = 1i64;
  *(_QWORD *)(a1 + 836) = 1i64;
  *(_DWORD *)(a1 + 844) = 0;
  *(_DWORD *)(a1 + 1468) = 0;
  *(_DWORD *)(a1 + 1456) = 0;
  *(_QWORD *)(a1 + 712) = 0i64;
  *(_DWORD *)(a1 + 1176) = 0;
  *(_QWORD *)(a1 + 1360) = 0i64;
  *(_QWORD *)(a1 + 776) = -1i64;
  *(_QWORD *)(a1 + 1016) = 0i64;
  *(_DWORD *)(a1 + 728) = 0;
  *(_QWORD *)(a1 + 1184) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 1368) = 0;
  *(_DWORD *)(a1 + 740) = 0;
  *(_DWORD *)(a1 + 972) = 0;
  *(_DWORD *)(a1 + 800) = -1;
  *(_DWORD *)(a1 + 804) = 0;
  *(_QWORD *)(a1 + 136) = 0i64;
  sub_140073BB0(a1 + 16, a4);
  v17 = *(_DWORD *)(a1 + 812);
  v18 = *(HWND *)(a1 + 56);
  WindowLongW = GetWindowLongW(v18, -16);
  if ( v17 )
  {
    if ( (WindowLongW & 0x100) == 0 )
      WindowLongW |= 0x100u;
  }
  else if ( (WindowLongW & 0x100) != 0 )
  {
    WindowLongW &= ~0x100u;
  }
  SetWindowLongPtrW(v18, -16, WindowLongW);
  v20 = *(_DWORD *)(a1 + 828);
  v21 = *(HWND *)(a1 + 56);
  v22 = SendMessageW(v21, 0x1037u, 0i64, 0i64);
  if ( v20 )
  {
    v22 |= 1u;
  }
  else if ( (v22 & 1) != 0 )
  {
    v22 &= ~1u;
  }
  SendMessageW(v21, 0x1036u, 0i64, v22);
  *(_DWORD *)(a1 + 968) = 0;
  v23 = *(int *)(a1 + 768);
  *(_QWORD *)(a1 + 792) = malloc(4 * v23);
  v24 = 0i64;
  if ( (int)v23 > 0 )
  {
    do
      *(_DWORD *)(*(_QWORD *)(a1 + 792) + 4 * v24++) = 0;
    while ( v24 < v23 );
  }
  *(_DWORD *)(a1 + 772) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 856));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 1056));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 1128));
  if ( !dword_14012DD40 )
  {
    InitializeCriticalSection(&stru_14012DAD0);
    dword_14012DD40 = 1;
  }
  *(_DWORD *)(a1 + 1024) = 1;
  *(_QWORD *)(a1 + 112) = a5;
  *(_QWORD *)(a1 + 120) = a6;
  SHGetFileInfoW(L"dummy", 0x90u, &psfi, 0x2B8u, 0x4010u);
  *(_DWORD *)(a1 + 784) = psfi.iIcon;
  SHGetFileInfoW(L"dummy", 0x80u, &psfi, 0x2B8u, 0x4010u);
  *(_DWORD *)(a1 + 788) = psfi.iIcon;
  *(_QWORD *)(a1 + 128) = 0i64;
  if ( !dword_14012DC9C )
  {
    dword_14012DAF8 = 0;
    dword_14012DACC = 0;
    dword_14012DAFC = 1;
    InitializeCriticalSection(&stru_14012DB00);
    dword_14012DB28 = 0;
    dword_14012DC9C = 1;
  }
  *(_QWORD *)(a1 + 152) = CreateEventW(0i64, 1, 1, 0i64);
  *(_QWORD *)(a1 + 1096) = CreateEventW(0i64, 1, 1, 0i64);
  *(_QWORD *)(a1 + 1168) = CreateEventW(0i64, 1, 1, 0i64);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F7DE8: using guessed type void *CFolderView::`vftable';
// 1400F7E68: using guessed type void *CFolderView::`vftable';
// 1400F7E98: using guessed type void *CFolderView::`vftable';
// 1400F81C0: using guessed type void *CFolderView::`vftable';
// 1400F81F8: using guessed type void *CFolderView::`vftable';
// 1400F8238: using guessed type void *CFolderView::`vftable';
// 1400F8248: using guessed type void *CPathManager::`vftable';
// 14012DACC: using guessed type int dword_14012DACC;
// 14012DAF8: using guessed type int dword_14012DAF8;
// 14012DAFC: using guessed type int dword_14012DAFC;
// 14012DB28: using guessed type int dword_14012DB28;
// 14012DC9C: using guessed type int dword_14012DC9C;
// 14012DD40: using guessed type int dword_14012DD40;

//----- (00000001400744C0) ----------------------------------------------------
void *__fastcall sub_1400744C0(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6)
{
  void *result; // rax

  result = operator new(0xA10ui64);
  if ( result )
  {
    result = (void *)sub_140073D70((__int64)result, a1, a2, a4, a5, a6);
    *a3 = result;
  }
  else
  {
    *a3 = 0i64;
  }
  return result;
}

//----- (0000000140074550) ----------------------------------------------------
LRESULT __fastcall sub_140074550(__int64 a1, unsigned int a2)
{
  int v2; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  HWND v6; // rbx
  unsigned int v7; // eax
  HWND v8; // rcx
  HWND v9; // rbp
  int v10; // ebx
  void *ppvObj; // [rsp+30h] [rbp+8h] BYREF

  v2 = a2;
  v4 = 4;
  if ( a2 )
  {
    if ( a2 <= 5 )
    {
      v5 = 0;
      goto LABEL_8;
    }
    if ( a2 == 7 )
    {
      v5 = 4;
      goto LABEL_8;
    }
    if ( a2 == 8 )
    {
      v5 = 2;
LABEL_8:
      ppvObj = 0i64;
      SHGetImageList(v5, &stru_1400E4120, &ppvObj);
      SendMessageW(*(HWND *)(a1 + 56), 0x1003u, 0i64, (LPARAM)ppvObj);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppvObj + 16i64))(ppvObj);
    }
  }
  if ( *(_DWORD *)(a1 + 708) == 5 && v2 != 5 )
    sub_140072CF0(a1);
  switch ( v2 )
  {
    case 1:
    case 7:
    case 8:
      goto LABEL_21;
    case 2:
      v4 = 2;
      break;
    case 3:
      v4 = 3;
      break;
    case 4:
      v4 = 1;
      if ( !*(_DWORD *)(a1 + 1360) )
      {
        sub_14006A680(a1);
        *(_DWORD *)(a1 + 1360) = 1;
      }
      break;
    case 5:
      sub_140072D50(a1);
      break;
    case 6:
      v4 = 0;
      if ( !*(_DWORD *)(a1 + 1176) )
        sub_140072480(a1);
      break;
    default:
      v2 = 1;
LABEL_21:
      v4 = 0;
      break;
  }
  *(_DWORD *)(a1 + 708) = v2;
  if ( v2 == 4 )
  {
    v9 = *(HWND *)(a1 + 56);
    v10 = *(_DWORD *)(a1 + 828);
    v7 = SendMessageW(v9, 0x1037u, 0i64, 0i64);
    if ( v10 )
    {
      v7 |= 1u;
    }
    else if ( (v7 & 1) != 0 )
    {
      v7 &= ~1u;
    }
    v8 = v9;
  }
  else
  {
    v6 = *(HWND *)(a1 + 56);
    v7 = SendMessageW(v6, 0x1037u, 0i64, 0i64);
    if ( (v7 & 1) != 0 )
      v7 &= ~1u;
    v8 = v6;
  }
  SendMessageW(v8, 0x1036u, 0i64, v7);
  return SendMessageW(*(HWND *)(a1 + 56), 0x108Eu, v4, 0i64);
}

//----- (0000000140074700) ----------------------------------------------------
LRESULT __fastcall sub_140074700(__int64 a1, int a2, int a3)
{
  WPARAM v3; // rbx
  HWND v5; // rcx
  __int64 v6; // rdi
  HWND v7; // rcx
  LRESULT result; // rax
  __int64 v9; // r11
  int v10; // er9
  HWND v11; // rcx
  int v12[2]; // [rsp+30h] [rbp-5C8h] BYREF
  __int64 v13; // [rsp+38h] [rbp-5C0h]
  _DWORD lParam[4]; // [rsp+40h] [rbp-5B8h] BYREF
  int *v15; // [rsp+50h] [rbp-5A8h]
  LPARAM v16; // [rsp+60h] [rbp-598h] BYREF
  int v17; // [rsp+68h] [rbp-590h]
  LPARAM *v18; // [rsp+78h] [rbp-580h]
  SHFILEINFOW psfi; // [rsp+B0h] [rbp-548h] BYREF
  LPARAM v20; // [rsp+370h] [rbp-288h] BYREF
  int v21; // [rsp+378h] [rbp-280h]
  WCHAR *szTypeName; // [rsp+388h] [rbp-270h]
  WCHAR pszPath[264]; // [rsp+3C0h] [rbp-238h] BYREF

  v3 = a2;
  v5 = *(HWND *)(a1 + 56);
  v6 = a3;
  v12[0] = 1;
  v12[1] = 2;
  lParam[0] = 24;
  lParam[1] = a2;
  lParam[2] = 2;
  v15 = v12;
  SendMessageW(v5, 0x10A4u, 0i64, (LPARAM)lParam);
  (*(void (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)(a1 + 16) + 96i64))(a1 + 16, (unsigned int)v3, pszPath);
  SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x400u);
  v7 = *(HWND *)(a1 + 56);
  szTypeName = psfi.szTypeName;
  v21 = 1;
  SendMessageW(v7, 0x1074u, v3, (LPARAM)&v20);
  result = *(_QWORD *)(a1 + 88);
  v9 = 592 * v6;
  if ( (*(_BYTE *)(592 * v6 + result) & 0x10) == 0 )
  {
    v10 = *(_DWORD *)(a1 + 744);
    LODWORD(v13) = *(_DWORD *)(v9 + result + 32);
    HIDWORD(v13) = *(_DWORD *)(v9 + result + 28);
    sub_140083DE0(v13, (char *)&v20, 0x20ui64, v10, *(_DWORD *)(a1 + 748));
    v11 = *(HWND *)(a1 + 56);
    v18 = &v20;
    v17 = 2;
    return SendMessageW(v11, 0x1074u, v3, (LPARAM)&v16);
  }
  return result;
}

//----- (0000000140074880) ----------------------------------------------------
LRESULT __fastcall sub_140074880(__int64 a1)
{
  LRESULT result; // rax
  int v3; // er13
  unsigned int v4; // edi
  WPARAM v5; // r12
  HWND v6; // rcx
  HWND v7; // rcx
  __int64 v8; // rbx
  HWND v9; // rcx
  __int64 v10; // r11
  int v11; // er9
  HWND v12; // rcx
  int v13[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v14; // [rsp+38h] [rbp-C8h]
  _DWORD v15[4]; // [rsp+40h] [rbp-C0h] BYREF
  int *v16; // [rsp+50h] [rbp-B0h]
  _DWORD lParam[20]; // [rsp+60h] [rbp-A0h] BYREF
  LPARAM v18; // [rsp+B0h] [rbp-50h] BYREF
  int v19; // [rsp+B8h] [rbp-48h]
  LPARAM *v20; // [rsp+C8h] [rbp-38h]
  SHFILEINFOW psfi; // [rsp+100h] [rbp+0h] BYREF
  LPARAM v22; // [rsp+3C0h] [rbp+2C0h] BYREF
  int v23; // [rsp+3C8h] [rbp+2C8h]
  WCHAR *szTypeName; // [rsp+3D8h] [rbp+2D8h]
  WCHAR pszPath[264]; // [rsp+410h] [rbp+310h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 56), 0x1004u, 0i64, 0i64);
  v3 = result;
  v4 = 0;
  if ( (int)result > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = *(HWND *)(a1 + 56);
      lParam[0] = 4;
      lParam[1] = v4;
      lParam[2] = 0;
      result = SendMessageW(v6, 0x104Bu, 0i64, (LPARAM)lParam);
      if ( (_DWORD)result )
      {
        v7 = *(HWND *)(a1 + 56);
        v8 = lParam[10];
        v16 = v13;
        v13[0] = 1;
        v13[1] = 2;
        v15[0] = 24;
        v15[1] = v4;
        v15[2] = 2;
        SendMessageW(v7, 0x10A4u, 0i64, (LPARAM)v15);
        (*(void (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)(a1 + 16) + 96i64))(a1 + 16, v4, pszPath);
        SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x400u);
        v9 = *(HWND *)(a1 + 56);
        szTypeName = psfi.szTypeName;
        v23 = 1;
        SendMessageW(v9, 0x1074u, v5, (LPARAM)&v22);
        result = *(_QWORD *)(a1 + 88);
        v10 = 592 * v8;
        if ( (*(_BYTE *)(592 * v8 + result) & 0x10) == 0 )
        {
          v11 = *(_DWORD *)(a1 + 744);
          LODWORD(v14) = *(_DWORD *)(result + v10 + 32);
          HIDWORD(v14) = *(_DWORD *)(result + v10 + 28);
          sub_140083DE0(v14, (char *)&v22, 0x20ui64, v11, *(_DWORD *)(a1 + 748));
          v12 = *(HWND *)(a1 + 56);
          v20 = &v22;
          v19 = 2;
          result = SendMessageW(v12, 0x1074u, v5, (LPARAM)&v18);
        }
      }
      ++v4;
      ++v5;
    }
    while ( (int)v4 < v3 );
  }
  return result;
}

//----- (0000000140074A80) ----------------------------------------------------
__int64 __fastcall sub_140074A80(ULONG_PTR dwData, unsigned int a2)
{
  int v2; // eax
  unsigned int v6; // edi
  int i; // edi

  v2 = *(_DWORD *)(dwData + 708);
  if ( a2 == v2 )
    return 1i64;
  if ( v2 == 6 && a2 != 6 )
    sub_140072380(dwData);
  sub_140074550(dwData, a2);
  v6 = a2 - 4;
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      sub_140074880(dwData);
      return 0i64;
    }
  }
  else
  {
    for ( i = 0; i < *(_DWORD *)(dwData + 752); ++i )
      sub_14006B870(dwData, i);
    QueueUserAPC(sub_14006DCB0, *(HANDLE *)(dwData + 112), dwData);
    if ( *(_DWORD *)(dwData + 732) )
      QueueUserAPC(sub_14006C2F0, *(HANDLE *)(dwData + 120), dwData);
  }
  return 0i64;
}

//----- (0000000140074B50) ----------------------------------------------------
__int64 sub_140074B50()
{
  return 2147500033i64;
}

//----- (0000000140074B60) ----------------------------------------------------
__int64 __fastcall sub_140074B60(__int64 a1)
{
  *(_DWORD *)(a1 + 40) = 0;
  return 0i64;
}

//----- (0000000140074B70) ----------------------------------------------------
__int64 __fastcall sub_140074B70(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 40) += a2;
  return 0i64;
}

//----- (0000000140074BA0) ----------------------------------------------------
__int64 __fastcall sub_140074BA0(__int64 a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  int v4; // edx
  _QWORD *v9; // rax
  int v10; // ecx
  _QWORD *v11; // rbx
  _DWORD *v12; // rax
  _DWORD *v13; // rcx

  v4 = *(_DWORD *)(a1 + 40);
  if ( v4 < *(_DWORD *)(a1 + 44) )
  {
    v9 = *(_QWORD **)(a1 + 16);
    v10 = 0;
    v11 = (_QWORD *)*v9;
    if ( (_QWORD *)*v9 != v9 )
    {
      while ( v10 != v4 )
      {
        v11 = (_QWORD *)*v11;
        ++v10;
        if ( v11 == v9 )
          goto LABEL_15;
      }
      *a3 = v11[2];
      a3[1] = v11[3];
      a3[2] = v11[4];
      a3[3] = v11[5];
      if ( v11[3] )
      {
        v12 = CoTaskMemAlloc(0x10ui64);
        a3[1] = v12;
        if ( !v12 )
          return 1i64;
        v13 = (_DWORD *)v11[3];
        if ( v13 )
        {
          *v12 = *v13;
          v12[1] = v13[1];
          v12[2] = v13[2];
          v12[3] = v13[3];
        }
        else
        {
          a3[1] = 0i64;
        }
      }
    }
LABEL_15:
    ++*(_DWORD *)(a1 + 40);
    if ( a4 )
      *a4 = 1;
    return 0i64;
  }
  else
  {
    if ( a4 )
      *a4 = 0;
    return 1i64;
  }
}

//----- (0000000140074CB0) ----------------------------------------------------
__int64 __fastcall sub_140074CB0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // er9
  bool v5; // cf
  unsigned __int64 v6; // r11
  int v7; // eax
  bool v8; // cf
  unsigned __int64 v9; // r8

  v3 = 0;
  *a3 = 0i64;
  v5 = *a2 < 0x103ui64;
  if ( *a2 == 259i64 && (v6 = a2[1], v5 = v6 < 0x46000000000000C0i64, v6 == 0x46000000000000C0i64) )
    v7 = 0;
  else
    v7 = -v5 - (v5 - 1);
  if ( v7 )
  {
    v8 = 0;
    if ( *a2 || (v9 = a2[1], v8 = v9 < *(_QWORD *)stru_1400E4110.Data4, v9 != *(_QWORD *)stru_1400E4110.Data4) )
      v3 = -v8 - (v8 - 1);
    if ( v3 )
      return 2147500034i64;
  }
  *a3 = a1;
  if ( !a1 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}

//----- (0000000140074D40) ----------------------------------------------------
void __fastcall sub_140074D40(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  *(_QWORD *)a1 = &CEnumFormatEtc::`vftable';
  v2 = *(_QWORD ***)(a1 + 16);
  v3 = *v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 16) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 16) );
  }
  j_free(*(void **)(a1 + 16));
}
// 1400F7C78: using guessed type void *CEnumFormatEtc::`vftable';

//----- (0000000140074DB0) ----------------------------------------------------
__int64 __fastcall sub_140074DB0(void *Block)
{
  __int64 result; // rax
  _QWORD **v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx

  result = (unsigned int)_InterlockedDecrement((volatile signed __int32 *)Block + 2);
  if ( !(_DWORD)result )
  {
    if ( Block )
    {
      *(_QWORD *)Block = &CEnumFormatEtc::`vftable';
      v3 = (_QWORD **)*((_QWORD *)Block + 2);
      v4 = *v3;
      *v3 = v3;
      *(_QWORD *)(*((_QWORD *)Block + 2) + 8i64) = *((_QWORD *)Block + 2);
      *((_QWORD *)Block + 3) = 0i64;
      if ( v4 != *((_QWORD **)Block + 2) )
      {
        do
        {
          v5 = (_QWORD *)*v4;
          j_free(v4);
          v4 = v5;
        }
        while ( v5 != *((_QWORD **)Block + 2) );
      }
      j_free(*((void **)Block + 2));
      j_free(Block);
    }
    return 0i64;
  }
  return result;
}
// 1400F7C78: using guessed type void *CEnumFormatEtc::`vftable';

//----- (0000000140074E40) ----------------------------------------------------
__int64 __fastcall sub_140074E40(__int64 a1, void **a2)
{
  _QWORD *v4; // r13
  _QWORD *v5; // rbx
  _DWORD *v6; // rdi
  _DWORD *v7; // rax
  __int64 v8; // rdi
  char *v9; // rax
  __int64 v10; // rdx
  void **v11; // rcx
  void **v12; // rbx
  __int64 v14; // [rsp+28h] [rbp-80h] BYREF
  _DWORD *v15; // [rsp+30h] [rbp-78h]
  __int64 v16; // [rsp+38h] [rbp-70h]
  __int64 v17; // [rsp+40h] [rbp-68h]
  __int64 v18; // [rsp+48h] [rbp-60h]
  __int64 v19; // [rsp+58h] [rbp-50h]
  __int64 v20; // [rsp+60h] [rbp-48h]

  *(_QWORD *)a1 = &CEnumFormatEtc::`vftable';
  sub_140017A60((_QWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 40) = 0;
  v4 = *a2;
  v5 = *(_QWORD **)*a2;
  if ( v5 != *a2 )
  {
    do
    {
      v18 = v5[2];
      v6 = (_DWORD *)v5[3];
      v19 = v5[4];
      v20 = v5[5];
      v14 = v5[2];
      v15 = v6;
      v16 = v5[4];
      v17 = v5[5];
      if ( v6 )
      {
        v7 = CoTaskMemAlloc(0x10ui64);
        v15 = v7;
        if ( v7 )
        {
          *v7 = *v6;
          v7[1] = v6[1];
          v7[2] = v6[2];
          v7[3] = v6[3];
        }
      }
      else
      {
        v15 = 0i64;
      }
      v8 = *(_QWORD *)(a1 + 16);
      v9 = sub_14001CB00(v8, *(_QWORD *)(v8 + 8), &v14);
      v10 = *(_QWORD *)(a1 + 24);
      if ( v10 == 0x7FFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 24) = v10 + 1;
      *(_QWORD *)(v8 + 8) = v9;
      **((_QWORD **)v9 + 1) = v9;
      v5 = (_QWORD *)*v5;
    }
    while ( v5 != v4 );
  }
  *(_DWORD *)(a1 + 44) = (unsigned int)a2[1];
  v11 = *(void ***)*a2;
  *(_QWORD *)*a2 = *a2;
  *((_QWORD *)*a2 + 1) = *a2;
  a2[1] = 0i64;
  if ( v11 != *a2 )
  {
    do
    {
      v12 = (void **)*v11;
      j_free(v11);
      v11 = v12;
    }
    while ( v12 != *a2 );
  }
  j_free(*a2);
  return a1;
}
// 1400F7C78: using guessed type void *CEnumFormatEtc::`vftable';

//----- (0000000140074FE0) ----------------------------------------------------
__int64 __fastcall sub_140074FE0(void **a1, _QWORD *a2)
{
  void *v4; // rax
  __int64 v5; // rbx
  void **v6; // rax
  void **v7; // rcx
  void **v8; // rbx
  __int64 *v10; // [rsp+28h] [rbp-20h] BYREF

  v4 = operator new(0x30ui64);
  v5 = (__int64)v4;
  if ( v4 )
  {
    v6 = (void **)sub_14001C990(&v10, (_QWORD ***)a1);
    v4 = (void *)sub_140074E40(v5, v6);
  }
  *a2 = v4;
  v7 = *(void ***)*a1;
  *(_QWORD *)*a1 = *a1;
  *((_QWORD *)*a1 + 1) = *a1;
  a1[1] = 0i64;
  if ( v7 != *a1 )
  {
    do
    {
      v8 = (void **)*v7;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != *a1 );
  }
  j_free(*a1);
  return 0i64;
}

//----- (0000000140075080) ----------------------------------------------------
void __fastcall sub_140075080(ULONG_PTR Parameter)
{
  CancelIo((HANDLE)Parameter);
  CloseHandle((HANDLE)Parameter);
}

//----- (00000001400750B0) ----------------------------------------------------
void __fastcall sub_1400750B0(ULONG_PTR Parameter)
{
  void *v2; // rax
  int v3; // er9
  BOOL DirectoryChangesW; // eax

  if ( *(_QWORD *)(Parameter + 32) == -1i64 )
  {
    free(*(void **)(Parameter + 72));
  }
  else
  {
    v2 = malloc(0x3E80ui64);
    v3 = *(_DWORD *)(Parameter + 604);
    *(_QWORD *)(Parameter + 16) = v2;
    DirectoryChangesW = ReadDirectoryChangesW(
                          *(HANDLE *)(Parameter + 32),
                          v2,
                          0x3E80u,
                          v3,
                          *(_DWORD *)(Parameter + 600),
                          0i64,
                          (LPOVERLAPPED)(Parameter + 40),
                          (LPOVERLAPPED_COMPLETION_ROUTINE)CompletionRoutine);
    *(_DWORD *)(Parameter + 612) = DirectoryChangesW;
    if ( !DirectoryChangesW )
    {
      free(*(void **)(Parameter + 16));
      CancelIo(*(HANDLE *)(Parameter + 32));
      CloseHandle(*(HANDLE *)(Parameter + 32));
    }
  }
}

//----- (0000000140075160) ----------------------------------------------------
void __fastcall __noreturn sub_140075160(ULONG_PTR Parameter)
{
  SetEvent(*(HANDLE *)(Parameter + 88));
  ExitThread(0);
}

//----- (0000000140075180) ----------------------------------------------------
void __fastcall __noreturn sub_140075180(LPVOID lpThreadParameter)
{
  SetErrorMode(1u);
  while ( 1 )
    SleepEx(0xFFFFFFFF, 1);
}

//----- (00000001400751B0) ----------------------------------------------------
__int64 __fastcall sub_1400751B0(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00000001400751E0) ----------------------------------------------------
__int64 __fastcall sub_1400751E0(__int64 a1, int a2)
{
  _QWORD *v5; // r11
  _QWORD *v6; // r8

  if ( a2 < 0 )
    return 0i64;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  v5 = *(_QWORD **)(a1 + 24);
  v6 = (_QWORD *)*v5;
  if ( (_QWORD *)*v5 != v5 )
  {
    while ( *((_DWORD *)v6 + 158) != a2 )
    {
      v6 = (_QWORD *)*v6;
      if ( v6 == v5 )
        goto LABEL_9;
    }
    if ( *((_DWORD *)v6 + 157) )
      QueueUserAPC((PAPCFUNC)sub_140075080, *(HANDLE *)(a1 + 16), v6[6]);
  }
LABEL_9:
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  return 1i64;
}

//----- (0000000140075280) ----------------------------------------------------
void __fastcall sub_140075280(__int64 a1)
{
  __int64 v1; // rdi
  void **v3; // rdx
  void **v4; // rcx

  v1 = *(_QWORD *)(a1 + 8);
  free(*(void **)(a1 + 16));
  free(*(void **)(a1 + 72));
  EnterCriticalSection((LPCRITICAL_SECTION)(v1 + 48));
  v3 = *(void ***)(v1 + 24);
  v4 = (void **)*v3;
  if ( *v3 != v3 )
  {
    while ( *((_DWORD *)v4 + 158) != *(_DWORD *)(a1 + 616) )
    {
      v4 = (void **)*v4;
      if ( v4 == v3 )
        goto LABEL_7;
    }
    if ( v4 != v3 )
    {
      *(_QWORD *)v4[1] = *v4;
      *((_QWORD *)*v4 + 1) = v4[1];
      j_free(v4);
      --*(_QWORD *)(v1 + 32);
    }
  }
LABEL_7:
  LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 48));
}

//----- (0000000140075320) ----------------------------------------------------
void __fastcall CompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
{
  HANDLE hEvent; // rsi
  char *v4; // rbx
  unsigned __int64 v5; // r8
  __int64 v6; // rdx
  __int16 *v7; // rcx
  __int16 v8; // ax
  unsigned int i; // er11
  unsigned __int64 v10; // r8
  __int64 v11; // rdx
  __int16 *v12; // rcx
  __int16 v13; // ax
  __int16 v14[264]; // [rsp+20h] [rbp-228h] BYREF

  if ( dwErrorCode )
  {
    if ( dwErrorCode == 995 )
      sub_140075280((__int64)lpOverlapped->hEvent);
  }
  else if ( dwNumberOfBytesTransfered )
  {
    hEvent = lpOverlapped->hEvent;
    if ( hEvent )
    {
      v4 = (char *)*((_QWORD *)hEvent + 2);
      v5 = (unsigned __int64)*((unsigned int *)v4 + 2) >> 1;
      if ( v5 <= 0x7FFFFFFE )
      {
        v6 = 260i64;
        v7 = v14;
        while ( v5 + v6 != 260 )
        {
          v8 = *(__int16 *)((char *)v7 + v4 + 12 - (char *)v14);
          if ( !v8 )
            break;
          *v7++ = v8;
          if ( !--v6 )
          {
            --v7;
            break;
          }
        }
        *v7 = 0;
      }
      else
      {
        v14[0] = 0;
      }
      (*(void (__fastcall **)(__int16 *, _QWORD, _QWORD))hEvent)(
        v14,
        *((unsigned int *)v4 + 1),
        *((_QWORD *)hEvent + 9));
      for ( i = *(_DWORD *)v4; *(_DWORD *)v4; i = *(_DWORD *)v4 )
      {
        v4 += i;
        v10 = (unsigned __int64)*((unsigned int *)v4 + 2) >> 1;
        if ( v10 <= 0x7FFFFFFE )
        {
          v11 = 260i64;
          v12 = v14;
          while ( v10 + v11 != 260 )
          {
            v13 = *(__int16 *)((char *)v12 + v4 - (char *)v14 + 12);
            if ( !v13 )
              break;
            *v12++ = v13;
            if ( !--v11 )
            {
              --v12;
              break;
            }
          }
          *v12 = 0;
        }
        else
        {
          v14[0] = 0;
        }
        (*(void (__fastcall **)(__int16 *, _QWORD, _QWORD))hEvent)(
          v14,
          *((unsigned int *)v4 + 1),
          *((_QWORD *)hEvent + 9));
      }
      free(*((void **)hEvent + 2));
      *((_QWORD *)hEvent + 2) = 0i64;
      sub_1400750B0((ULONG_PTR)hEvent);
    }
  }
}
// 1400753C8: conditional instruction was optimized away because rdx.8!=0
// 14007544B: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400754E0) ----------------------------------------------------
void __fastcall sub_1400754E0(ULONG_PTR dwData)
{
  void *v1; // rdx
  _QWORD **v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  _QWORD **v6; // r11
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx

  v1 = *(void **)(dwData + 16);
  *(_QWORD *)dwData = &CDirectoryMonitor::`vftable';
  QueueUserAPC((PAPCFUNC)sub_140075160, v1, dwData);
  CloseHandle(*(HANDLE *)(dwData + 16));
  WaitForSingleObject(*(HANDLE *)(dwData + 88), 0xFFFFFFFF);
  DeleteCriticalSection((LPCRITICAL_SECTION)(dwData + 48));
  v3 = *(_QWORD ***)(dwData + 24);
  v4 = *v3;
  *v3 = v3;
  *(_QWORD *)(*(_QWORD *)(dwData + 24) + 8i64) = *(_QWORD *)(dwData + 24);
  *(_QWORD *)(dwData + 32) = 0i64;
  if ( v4 != *(_QWORD **)(dwData + 24) )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)(dwData + 24) );
  }
  CloseHandle(*(HANDLE *)(dwData + 88));
  v6 = *(_QWORD ***)(dwData + 24);
  v7 = *v6;
  *v6 = v6;
  *(_QWORD *)(*(_QWORD *)(dwData + 24) + 8i64) = *(_QWORD *)(dwData + 24);
  *(_QWORD *)(dwData + 32) = 0i64;
  if ( v7 != *(_QWORD **)(dwData + 24) )
  {
    do
    {
      v8 = (_QWORD *)*v7;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != *(_QWORD **)(dwData + 24) );
  }
  j_free(*(void **)(dwData + 24));
}
// 1400F7C40: using guessed type void *CDirectoryMonitor::`vftable';

//----- (00000001400755C0) ----------------------------------------------------
__int64 __fastcall sub_1400755C0(__int64 a1)
{
  _QWORD *v2; // rax
  __int64 pExceptionObject[5]; // [rsp+30h] [rbp-28h] BYREF
  char *v5; // [rsp+60h] [rbp+8h] BYREF

  *(_QWORD *)a1 = &CDirectoryMonitor::`vftable';
  *(_QWORD *)(a1 + 32) = 0i64;
  v2 = operator new(0x280ui64);
  if ( !v2 )
  {
    v5 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v5);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 24) = v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 16) = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_140075180, 0i64, 0, (LPDWORD)(a1 + 12));
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  *(_QWORD *)(a1 + 88) = CreateEventW(0i64, 1, 0, 0i64);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F7C40: using guessed type void *CDirectoryMonitor::`vftable';

//----- (0000000140075690) ----------------------------------------------------
__int64 __fastcall sub_140075690(_QWORD *a1)
{
  void *v2; // rax

  v2 = operator new(0x68ui64);
  if ( v2 )
    v2 = (void *)sub_1400755C0((__int64)v2);
  *a1 = v2;
  return 0i64;
}

//----- (00000001400756D0) ----------------------------------------------------
__int64 __fastcall sub_1400756D0(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, int a6, __int64 a7)
{
  __int64 result; // rax
  __int64 v11; // rax
  __int64 v12; // r11
  char *v13; // rcx
  __int64 v14; // rbx
  __int16 v15; // ax
  __int64 v16; // rbx
  char *v17; // r11
  __int64 v18; // rax
  __int64 v19[10]; // [rsp+20h] [rbp-298h] BYREF
  char v20[520]; // [rsp+70h] [rbp-248h] BYREF
  int v21; // [rsp+278h] [rbp-40h]
  int v22; // [rsp+27Ch] [rbp-3Ch]
  int v23; // [rsp+280h] [rbp-38h]
  int v24; // [rsp+288h] [rbp-30h]

  if ( !a3 )
    return 0xFFFFFFFFi64;
  v11 = *(_QWORD *)(a1 + 16);
  v19[0] = a5;
  v19[3] = v11;
  v24 = *(_DWORD *)(a1 + 96);
  v19[1] = a1;
  v21 = a4;
  v19[9] = a7;
  v22 = a6;
  v23 = 0;
  SetErrorMode(1u);
  v12 = 260i64;
  v13 = v20;
  v14 = a3 - (_QWORD)v20;
  while ( v12 != -2147483386 )
  {
    v15 = *(_WORD *)&v13[v14];
    if ( !v15 )
      break;
    *(_WORD *)v13 = v15;
    v13 += 2;
    if ( !--v12 )
    {
      v13 -= 2;
      break;
    }
  }
  *(_WORD *)v13 = 0;
  v19[4] = a2;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  v16 = *(_QWORD *)(a1 + 24);
  v17 = sub_14001CD30(v16, *(_QWORD *)(v16 + 8), v19);
  v18 = *(_QWORD *)(a1 + 32);
  if ( v18 == 0x69069069069068i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 32) = v18 + 1;
  *(_QWORD *)(v16 + 8) = v17;
  **((_QWORD **)v17 + 1) = v17;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 80i64) = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 16i64;
  QueueUserAPC((PAPCFUNC)sub_1400750B0, *(HANDLE *)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 16i64);
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  result = *(unsigned int *)(a1 + 96);
  *(_DWORD *)(a1 + 96) = result + 1;
  return result;
}
// 1400757A6: conditional instruction was optimized away because r11.8!=0

//----- (0000000140075880) ----------------------------------------------------
__int64 __fastcall sub_140075880(__int64 a1, __int64 a2, int a3, __int64 a4, int a5, void *Block)
{
  __int64 v8; // rax
  __int64 v9; // r11
  WCHAR *v10; // rcx
  __int64 v11; // rbx
  WCHAR v12; // ax
  __int64 result; // rax
  __int64 v14; // rbx
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17[4]; // [rsp+40h] [rbp-298h] BYREF
  HANDLE FileW; // [rsp+60h] [rbp-278h]
  void *v19; // [rsp+88h] [rbp-250h]
  WCHAR FileName[260]; // [rsp+90h] [rbp-248h] BYREF
  int v21; // [rsp+298h] [rbp-40h]
  int v22; // [rsp+29Ch] [rbp-3Ch]
  int v23; // [rsp+2A0h] [rbp-38h]
  int v24; // [rsp+2A8h] [rbp-30h]

  if ( !a2 )
    return 0xFFFFFFFFi64;
  v8 = *(_QWORD *)(a1 + 16);
  v17[1] = a1;
  v17[3] = v8;
  v24 = *(_DWORD *)(a1 + 96);
  v21 = a3;
  v17[0] = a4;
  v22 = a5;
  v19 = Block;
  v23 = 0;
  SetErrorMode(1u);
  v9 = 260i64;
  v10 = FileName;
  v11 = a2 - (_QWORD)FileName;
  while ( v9 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v10 + v11);
    if ( !v12 )
      break;
    *v10++ = v12;
    if ( !--v9 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  FileW = CreateFileW(FileName, 1u, 7u, 0i64, 3u, 0x42000000u, 0i64);
  if ( FileW == (HANDLE)-1i64 )
  {
    free(Block);
    return 0xFFFFFFFFi64;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  v14 = *(_QWORD *)(a1 + 24);
  v15 = sub_14001CD30(v14, *(_QWORD *)(v14 + 8), v17);
  v16 = *(_QWORD *)(a1 + 32);
  if ( v16 == 0x69069069069068i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 32) = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 80i64) = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 16i64;
  QueueUserAPC((PAPCFUNC)sub_1400750B0, *(HANDLE *)(a1 + 16), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) + 16i64);
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
  result = *(unsigned int *)(a1 + 96);
  *(_DWORD *)(a1 + 96) = result + 1;
  return result;
}
// 140075938: conditional instruction was optimized away because r11.8!=0

//----- (0000000140075A50) ----------------------------------------------------
__int64 __fastcall sub_140075A50(void *Block)
{
  if ( (*((_DWORD *)Block + 2))-- != 1 )
    return *((unsigned int *)Block + 2);
  sub_1400754E0((ULONG_PTR)Block);
  j_free(Block);
  return 0i64;
}

//----- (0000000140075A90) ----------------------------------------------------
__int64 __fastcall sub_140075A90(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // er9
  bool v4; // cf
  unsigned __int64 v5; // r10

  v3 = 0;
  *a3 = 0i64;
  v4 = 0;
  if ( *a2 || (v5 = a2[1], v4 = v5 < *(_QWORD *)stru_1400E4110.Data4, v5 != *(_QWORD *)stru_1400E4110.Data4) )
    v3 = -v4 - (v4 - 1);
  if ( v3 )
    return 2147500034i64;
  *a3 = a1;
  if ( !a1 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}

//----- (0000000140075B00) ----------------------------------------------------
__int64 __fastcall sub_140075B00(const WCHAR *a1)
{
  DWORD BytesPerSector; // [rsp+48h] [rbp+10h] BYREF

  GetDiskFreeSpaceW(a1, 0i64, &BytesPerSector, 0i64, 0i64);
  return BytesPerSector;
}

//----- (0000000140075B30) ----------------------------------------------------
__int64 __fastcall sub_140075B30(const WCHAR *a1)
{
  DWORD SectorsPerCluster; // [rsp+48h] [rbp+10h] BYREF
  DWORD BytesPerSector; // [rsp+50h] [rbp+18h] BYREF

  GetDiskFreeSpaceW(a1, &SectorsPerCluster, &BytesPerSector, 0i64, 0i64);
  return BytesPerSector * SectorsPerCluster;
}

//----- (0000000140075B60) ----------------------------------------------------
__int64 __fastcall sub_140075B60(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
  if ( !(_DWORD)result )
  {
    if ( a1 )
      (**(void (__fastcall ***)(__int64, __int64))a1)(a1, 1i64);
    return 0i64;
  }
  return result;
}

//----- (0000000140075BF0) ----------------------------------------------------
__int64 __fastcall sub_140075BF0(__int64 a1, signed int a2)
{
  __int64 v3; // rcx
  unsigned int v5; // ebx
  HDROP v6; // rax
  HDROP v7; // rdi
  __int16 v9; // [rsp+20h] [rbp-278h] BYREF
  __int64 v10; // [rsp+28h] [rbp-270h]
  int v11; // [rsp+30h] [rbp-268h]
  int v12; // [rsp+34h] [rbp-264h]
  int v13; // [rsp+38h] [rbp-260h]
  STGMEDIUM v14; // [rsp+40h] [rbp-258h] BYREF
  WCHAR szFile[264]; // [rsp+60h] [rbp-238h] BYREF

  v3 = *(_QWORD *)(a1 + 16);
  v11 = 1;
  v12 = -1;
  v13 = 1;
  v9 = 15;
  v5 = 0;
  v10 = 0i64;
  if ( !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)v3 + 24i64))(v3, &v9, &v14) )
  {
    v6 = (HDROP)GlobalLock(v14.hBitmap);
    v7 = v6;
    if ( v6 )
    {
      if ( a2 < (int)DragQueryFileW(v6, 0xFFFFFFFF, 0i64, 0) )
      {
        DragQueryFileW(v7, a2, szFile, 0x104u);
        LOBYTE(v5) = PathIsSameRootW(*(LPCWSTR *)(a1 + 64), szFile);
      }
      GlobalUnlock(v14.hBitmap);
    }
    ReleaseStgMedium(&v14);
  }
  return v5;
}

//----- (0000000140075CF0) ----------------------------------------------------
LRESULT __fastcall sub_140075CF0(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  if ( uMsg != 32769 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)wParam + 56i64))(
    *(_QWORD *)wParam,
    *(unsigned int *)(wParam + 8),
    0i64,
    *(unsigned int *)(wParam + 12));
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)wParam + 16i64))(*(_QWORD *)wParam);
  RemoveWindowSubclass(hWnd, (SUBCLASSPROC)sub_140075CF0, 0x2710ui64);
  return 0i64;
}

//----- (0000000140075D60) ----------------------------------------------------
__int64 __fastcall sub_140075D60(__int64 a1, __int64 a2)
{
  int v2; // ebx
  int v5; // eax
  STGMEDIUM v7; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = -1;
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  *(_DWORD *)(a2 + 20) = v2;
  if ( v5 || (*(unsigned int (__fastcall **)(__int64, __int64, STGMEDIUM *))(*(_QWORD *)a1 + 24i64))(a1, a2, &v7) )
    return 0i64;
  ReleaseStgMedium(&v7);
  return 1i64;
}

//----- (0000000140075E20) ----------------------------------------------------
_DWORD *sub_140075E20()
{
  _DWORD *result; // rax

  result = operator new(0x50ui64);
  if ( result )
  {
    result[2] = 1;
    *(_QWORD *)result = &CDropHandler::`vftable';
  }
  return result;
}
// 1400F7C20: using guessed type void *CDropHandler::`vftable';

//----- (0000000140075E60) ----------------------------------------------------
__int64 __fastcall sub_140075E60(LPSTGMEDIUM a1)
{
  unsigned int v2; // ebx
  HRESULT v3; // ebp
  unsigned int *v4; // rax
  unsigned int *v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rsi
  HRESULT v8; // eax
  unsigned int *v9; // rsi
  IShellFolder *v11; // [rsp+50h] [rbp+8h] BYREF
  IShellFolder *ppshf; // [rsp+58h] [rbp+10h] BYREF

  v2 = 0;
  v3 = 0;
  v4 = (unsigned int *)GlobalLock(a1->hBitmap);
  v5 = v4;
  if ( v4 )
  {
    v6 = v4[1];
    v11 = 0i64;
    v7 = (__int64)v4 + v6;
    if ( v7 )
    {
      ppshf = 0i64;
      v11 = 0i64;
      v3 = SHGetDesktopFolder(&ppshf);
      if ( v3 >= 0 )
      {
        if ( (unsigned int)sub_14007DF90(v7) )
          v8 = SHGetDesktopFolder(&v11);
        else
          v8 = ((__int64 (__fastcall *)(IShellFolder *, __int64, _QWORD, const IID *, IShellFolder **))ppshf->lpVtbl->BindToObject)(
                 ppshf,
                 v7,
                 0i64,
                 &stru_1400E3FB0,
                 &v11);
        v3 = v8;
      }
      if ( v3 >= 0 )
      {
        ppshf = 0i64;
        if ( *v5 )
        {
          v9 = v5 + 2;
          do
          {
            v3 = ((__int64 (__fastcall *)(IShellFolder *, char *, _QWORD, const IID *, IShellFolder **))v11->lpVtbl->BindToStorage)(
                   v11,
                   (char *)v5 + *v9,
                   0i64,
                   &stru_1400E4180,
                   &ppshf);
            if ( v3 >= 0 )
              ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
            ++v2;
            ++v9;
          }
          while ( v2 < *v5 );
        }
        ((void (__fastcall *)(IShellFolder *))v11->lpVtbl->Release)(v11);
      }
    }
    else
    {
      v3 = -2147467259;
    }
    GlobalUnlock(a1->hBitmap);
  }
  ReleaseStgMedium(a1);
  return (unsigned int)v3;
}

//----- (0000000140075F90) ----------------------------------------------------
__int64 __fastcall sub_140075F90(LPCWSTR pszDir, LPCVOID lpBuffer, char *a3)
{
  int v6; // esi
  WCHAR *v7; // rdi
  __int64 v8; // rdi
  HANDLE FileW; // rsi
  int v10; // eax
  signed __int64 v11; // rcx
  __int16 v12; // ax
  __int64 result; // rax
  struct _FILETIME FileTime; // [rsp+40h] [rbp-898h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+48h] [rbp-890h] BYREF
  struct _FILETIME v16; // [rsp+50h] [rbp-888h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+58h] [rbp-880h] BYREF
  WCHAR pszDest[264]; // [rsp+70h] [rbp-868h] BYREF
  WCHAR String[512]; // [rsp+280h] [rbp-658h] BYREF
  WCHAR pszFile[264]; // [rsp+680h] [rbp-258h] BYREF

  GetLocalTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  LocalFileTimeToFileTime(&FileTime, &v16);
  sub_1400835A0(&v16, (char *)String, 512, 0);
  v6 = 0;
  if ( lstrlenW(String) > 0 )
  {
    v7 = String;
    do
    {
      if ( *v7 == 47 )
      {
        *v7 = 45;
      }
      else if ( *v7 == 58 )
      {
        *v7 = 46;
      }
      ++v6;
      ++v7;
    }
    while ( v6 < lstrlenW(String) );
  }
  v8 = 260i64;
  sub_140001000(pszFile, 0x104ui64, L"Clipboard Text (%s).txt", String);
  PathCombineW(pszDest, pszDir, pszFile);
  FileW = CreateFileW(pszDest, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
  if ( FileW == (HANDLE)-1i64 )
    return 2147500037i64;
  v10 = lstrlenW((LPCWSTR)lpBuffer);
  WriteFile(FileW, lpBuffer, 2 * v10, &NumberOfBytesWritten, 0i64);
  CloseHandle(FileW);
  v11 = (char *)pszDest - a3;
  while ( v8 != -2147483386 )
  {
    v12 = *(_WORD *)&a3[v11];
    if ( !v12 )
      break;
    *(_WORD *)a3 = v12;
    a3 += 2;
    if ( !--v8 )
    {
      result = 0i64;
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a3 = 0;
  return 0i64;
}
// 140076161: conditional instruction was optimized away because rdi.8!=0
// 1400EB8F8: using guessed type wchar_t aClipboardTextS[24];

//----- (00000001400761A0) ----------------------------------------------------
void __fastcall sub_1400761A0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // r9
  __int64 v5; // r8
  int v6; // [rsp+30h] [rbp-38h] BYREF
  __int64 v7; // [rsp+38h] [rbp-30h] BYREF
  __int64 v8; // [rsp+40h] [rbp-28h] BYREF
  IShellFolder *ppshf; // [rsp+48h] [rbp-20h] BYREF
  void *pv[3]; // [rsp+50h] [rbp-18h] BYREF

  v2 = *(_QWORD *)(a1 + 64);
  ppshf = 0i64;
  v8 = 0i64;
  v7 = 0i64;
  pv[0] = 0i64;
  if ( v2 && (int)sub_14007F810(v2, (__int64)pv) >= 0 )
  {
    if ( SHGetDesktopFolder(&ppshf) >= 0 )
    {
      if ( ((int (__fastcall *)(IShellFolder *, void *, _QWORD, const IID *, __int64 *))ppshf->lpVtbl->BindToObject)(
             ppshf,
             pv[0],
             0i64,
             &stru_1400E3FB0,
             &v8) >= 0 )
      {
        v3 = *(_QWORD *)(a1 + 48);
        v6 = *(_DWORD *)(a1 + 44);
        if ( (*(int (__fastcall **)(__int64, __int64, void *, __int64 *))(*(_QWORD *)v8 + 64i64))(
               v8,
               v3,
               &unk_1400E4100,
               &v7) >= 0 )
        {
          (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD, int *))(*(_QWORD *)v7 + 24i64))(
            v7,
            *(_QWORD *)(a1 + 16),
            2i64,
            *(_QWORD *)(a1 + 36),
            &v6);
          v4 = *(_QWORD *)(a1 + 36);
          v5 = *(unsigned int *)(a1 + 32);
          v6 = *(_DWORD *)(a1 + 44);
          (*(void (__fastcall **)(__int64, _QWORD, __int64, __int64, int *))(*(_QWORD *)v7 + 48i64))(
            v7,
            *(_QWORD *)(a1 + 16),
            v5,
            v4,
            &v6);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 40i64))(v7);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16i64))(v8);
      }
      ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    }
    CoTaskMemFree(pv[0]);
  }
}
// 1400761A0: using guessed type LPVOID pv[3];

//----- (00000001400762E0) ----------------------------------------------------
__int64 __fastcall sub_1400762E0(__int64 *a1)
{
  __int64 v1; // rsi
  char *v3; // r11
  __int64 v4; // rax
  __int64 v5; // rsi
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rsi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rsi
  char *v18; // r11
  __int64 v19; // rax

  v1 = *a1;
  v3 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), qword_14011D720);
  v4 = a1[1];
  if ( v4 == 0x7FFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v4 + 1;
  *(_QWORD *)(v1 + 8) = v3;
  **((_QWORD **)v3 + 1) = v3;
  v5 = *a1;
  v6 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), &word_14012E028);
  v7 = a1[1];
  if ( v7 == 0x7FFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v7 + 1;
  *(_QWORD *)(v5 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a1;
  v9 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), &word_14012E048);
  v10 = a1[1];
  if ( v10 == 0x7FFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a1;
  v12 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), qword_14011D740);
  v13 = a1[1];
  if ( v13 == 0x7FFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a1;
  v15 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), qword_14011D760);
  v16 = a1[1];
  if ( v16 == 0x7FFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a1;
  v18 = sub_14001CB00(*a1, *(_QWORD *)(*a1 + 8), qword_14011D780);
  v19 = a1[1];
  if ( 0x7FFFFFFFFFFFFFEi64 == v19 )
    sub_14002B5F8("list<T> too long");
  a1[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  return 0i64;
}
// 14011D720: using guessed type _QWORD qword_14011D720[2];
// 14011D740: using guessed type _QWORD qword_14011D740[4];
// 14011D760: using guessed type _QWORD qword_14011D760[4];
// 14011D780: using guessed type _QWORD qword_14011D780[136];
// 14012E028: using guessed type __int16 word_14012E028;
// 14012E048: using guessed type __int16 word_14012E048;

//----- (0000000140076C40) ----------------------------------------------------
__int64 __fastcall sub_140076C40(LPVOID lpThreadParameter)
{
  int v2; // ebx
  bool v3; // zf
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  WPARAM wParam; // [rsp+20h] [rbp-18h] BYREF
  int v7; // [rsp+28h] [rbp-10h]
  int v8; // [rsp+2Ch] [rbp-Ch]

  CoInitializeEx(0i64, 2u);
  v2 = sub_1400767B0(lpThreadParameter);
  CoUninitialize();
  wParam = *((_QWORD *)lpThreadParameter + 11);
  if ( v2 )
  {
    v3 = *((_DWORD *)lpThreadParameter + 20) == 0;
    v7 = 0;
    v8 = !v3 + 1;
  }
  else
  {
    v7 = -2147467259;
    v8 = 0;
  }
  SendMessageW(*((HWND *)lpThreadParameter + 1), 0x8001u, (WPARAM)&wParam, 0i64);
  v4 = *(void (__fastcall ****)(_QWORD, __int64))lpThreadParameter;
  if ( !_InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)lpThreadParameter + 8i64)) && v4 )
    (**v4)(v4, 1i64);
  if ( *((_QWORD *)lpThreadParameter + 8) >= 8ui64 )
    j_free(*((void **)lpThreadParameter + 5));
  *((_QWORD *)lpThreadParameter + 8) = 7i64;
  *((_QWORD *)lpThreadParameter + 7) = 0i64;
  *((_WORD *)lpThreadParameter + 20) = 0;
  sub_14000A630((__int64)lpThreadParameter + 16);
  j_free(*((void **)lpThreadParameter + 2));
  j_free(lpThreadParameter);
  return 0i64;
}
// 1400767B0: using guessed type __int64 __fastcall sub_1400767B0(_QWORD);

//----- (0000000140076F00) ----------------------------------------------------
void __fastcall sub_140076F00(__int64 a1, HDROP *a2, int a3, int a4)
{
  void **v6; // rax
  void **v7; // rsi
  void **v8; // rax
  void **v9; // r12
  int v10; // edi
  UINT v11; // ebx
  __int64 v12; // rdx
  WCHAR *v13; // rcx
  WCHAR v14; // ax
  char v15; // di
  int v16; // edi
  int v17; // ecx
  int v18; // edx
  __int64 v19; // rdx
  WCHAR *v20; // rcx
  WCHAR v21; // ax
  __int64 v22; // rcx
  WCHAR *v23; // rdi
  bool v24; // zf
  char *v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rcx
  WCHAR *v28; // rdi
  char *v29; // rax
  __int64 v30; // rdx
  void **v31; // rdi
  void **v32; // rbx
  void **v33; // rdi
  void **v34; // rbx
  unsigned int v35; // [rsp+20h] [rbp-E0h]
  char *v36; // [rsp+28h] [rbp-D8h] BYREF
  int v37; // [rsp+30h] [rbp-D0h]
  int v38; // [rsp+34h] [rbp-CCh]
  void **v39; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v40; // [rsp+40h] [rbp-C0h]
  void **v41; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v42; // [rsp+58h] [rbp-A8h]
  HDROP *v43; // [rsp+68h] [rbp-98h]
  char *v44[2]; // [rsp+70h] [rbp-90h] BYREF
  __int64 pExceptionObject[3]; // [rsp+80h] [rbp-80h] BYREF
  void *Block[2]; // [rsp+98h] [rbp-68h] BYREF
  __int64 v47; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v48; // [rsp+B0h] [rbp-50h]
  WCHAR szFile[264]; // [rsp+C0h] [rbp-40h] BYREF
  WCHAR pszPath[264]; // [rsp+2D0h] [rbp+1D0h] BYREF
  WCHAR v51[264]; // [rsp+4E0h] [rbp+3E0h] BYREF

  v44[1] = (char *)-2i64;
  v37 = a4;
  v38 = a3;
  v43 = a2;
  v40 = 0i64;
  v6 = (void **)operator new(0x38ui64);
  v7 = v6;
  if ( !v6 )
  {
    v36 = 0i64;
    std::exception::exception((std::exception *)Block, (const char *const *)&v36);
    Block[0] = &std::bad_alloc::`vftable';
    CxxThrowException(Block, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v39 = v6;
  *v6 = v6;
  v6[1] = v6;
  v42 = 0i64;
  v8 = (void **)operator new(0x38ui64);
  v9 = v8;
  if ( !v8 )
  {
    v44[0] = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v44);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v41 = v8;
  *v8 = v8;
  v8[1] = v8;
  v10 = *(_DWORD *)(a1 + 72);
  LODWORD(v36) = DragQueryFileW(*a2, 0xFFFFFFFF, 0i64, 0);
  v11 = 0;
  if ( (int)v36 > 0 )
  {
    while ( 1 )
    {
      DragQueryFileW(*v43, v11, szFile, 0x104u);
      v12 = 260i64;
      v13 = pszPath;
      while ( v12 != -2147483386 )
      {
        v14 = *(v13 - 264);
        if ( !v14 )
          break;
        *v13++ = v14;
        if ( !--v12 )
        {
          --v13;
          break;
        }
      }
      *v13 = 0;
      PathRemoveFileSpecW(pszPath);
      if ( !lstrcmpiW(*(LPCWSTR *)(a1 + 64), pszPath) )
        v10 = 1;
      v35 = v10;
      if ( v38 )
      {
        v15 = v37;
      }
      else
      {
        v16 = sub_140075BF0(a1, v11);
        v17 = *(_DWORD *)(a1 + 44);
        v18 = *(_DWORD *)(a1 + 32);
        if ( ((v18 & 8) != 0 && (v18 & 4) != 0 || (v18 & 0x20) != 0) && (v17 & 4) != 0 )
        {
          v15 = 4;
        }
        else if ( (v18 & 4) != 0 && (v17 & 2) != 0 )
        {
          v15 = 2;
        }
        else if ( (*(_DWORD *)(a1 + 32) & 8) == 8 && (v17 & 1) != 0 )
        {
          v15 = 1;
        }
        else if ( v16 && (v17 & 2) != 0 )
        {
          v15 = 2;
        }
        else if ( (v17 & 1) != 0 )
        {
          v15 = 1;
        }
        else if ( (v17 & 2) != 0 )
        {
          v15 = 2;
        }
        else
        {
          v15 = v17 & 4;
        }
      }
      v19 = 260i64;
      v20 = v51;
      while ( v19 != -2147483386 )
      {
        v21 = *(v20 - 528);
        if ( !v21 )
          break;
        *v20++ = v21;
        if ( !--v19 )
        {
          --v20;
          break;
        }
      }
      *v20 = 0;
      PathStripPathW(v51);
      if ( (v15 & 2) != 0 )
      {
        v48 = 7i64;
        v47 = 0i64;
        LOWORD(Block[0]) = 0;
        v22 = -1i64;
        v23 = szFile;
        do
        {
          if ( !v22 )
            break;
          v24 = *v23++ == 0;
          --v22;
        }
        while ( !v24 );
        sub_1400099E0(Block, szFile, -v22 - 2);
        v25 = sub_14000A760((__int64)v9, (__int64)v9[1], Block);
        if ( v42 == 0x666666666666665i64 )
          sub_14002B5F8("list<T> too long");
        v26 = ++v42;
        v9[1] = v25;
        **((_QWORD **)v25 + 1) = v25;
        if ( v48 >= 8 )
          j_free(Block[0]);
      }
      else
      {
        if ( (v15 & 1) != 0 )
        {
          v48 = 7i64;
          v47 = 0i64;
          LOWORD(Block[0]) = 0;
          v27 = -1i64;
          v28 = szFile;
          do
          {
            if ( !v27 )
              break;
            v24 = *v28++ == 0;
            --v27;
          }
          while ( !v24 );
          sub_1400099E0(Block, szFile, -v27 - 2);
          v29 = sub_14000A760((__int64)v7, (__int64)v7[1], Block);
          if ( v40 == 0x666666666666665i64 )
            sub_14002B5F8("list<T> too long");
          v30 = ++v40;
          v7[1] = v29;
          **((_QWORD **)v29 + 1) = v29;
          if ( v48 < 8 )
          {
            v26 = v42;
            goto LABEL_56;
          }
          j_free(Block[0]);
        }
        else if ( (v15 & 4) != 0 )
        {
          sub_1400764D0(a1, szFile);
        }
        v26 = v42;
      }
      v30 = v40;
LABEL_56:
      if ( (int)++v11 >= (int)v36 )
      {
        if ( v30 )
          sub_140076D20(a1, &v39, 1i64, v35);
        if ( v26 )
          sub_140076D20(a1, &v41, 0i64, v35);
        break;
      }
      v10 = v35;
    }
  }
  v31 = (void **)*v9;
  *v9 = v9;
  v9[1] = v9;
  if ( v31 != v9 )
  {
    do
    {
      v32 = (void **)*v31;
      if ( (unsigned __int64)v31[5] >= 8 )
        j_free(v31[2]);
      v31[5] = (void *)7;
      v31[4] = 0i64;
      *((_WORD *)v31 + 8) = 0;
      j_free(v31);
      v31 = v32;
    }
    while ( v32 != v9 );
  }
  j_free(v9);
  v33 = (void **)*v7;
  *v7 = v7;
  v7[1] = v7;
  if ( v33 != v7 )
  {
    do
    {
      v34 = (void **)*v33;
      if ( (unsigned __int64)v33[5] >= 8 )
        j_free(v33[2]);
      v33[5] = (void *)7;
      v33[4] = 0i64;
      *((_WORD *)v33 + 8) = 0;
      j_free(v33);
      v33 = v34;
    }
    while ( v34 != v7 );
  }
  j_free(v7);
}
// 140077037: conditional instruction was optimized away because rdx.8!=0
// 140077137: conditional instruction was optimized away because rdx.8!=0
// 1400764D0: using guessed type __int64 __fastcall sub_1400764D0(_QWORD, _QWORD);
// 140076D20: using guessed type __int64 __fastcall sub_140076D20(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140077420) ----------------------------------------------------
__int64 __fastcall sub_140077420(__int64 a1, __int64 *a2, STGMEDIUM *a3)
{
  _DWORD *v6; // rdi
  int v7; // ebx
  WCHAR *v8; // rdi
  __int64 v9; // r12
  HANDLE FileW; // r14
  DWORD v11; // ebx
  char *v12; // rsi
  SIZE_T v13; // rax
  WCHAR *v14; // rcx
  WCHAR v15; // ax
  __int64 v16; // rcx
  WCHAR *v17; // rdi
  bool v18; // zf
  __int64 v19; // rdi
  char *v20; // rdx
  __int64 v21; // rax
  _DWORD *v23; // [rsp+40h] [rbp-C0h]
  struct _FILETIME FileTime; // [rsp+48h] [rbp-B8h] BYREF
  struct _FILETIME v25; // [rsp+50h] [rbp-B0h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v27; // [rsp+60h] [rbp-A0h]
  void *Block[3]; // [rsp+68h] [rbp-98h] BYREF
  unsigned __int64 v29; // [rsp+80h] [rbp-80h]
  struct _SYSTEMTIME SystemTime; // [rsp+90h] [rbp-70h] BYREF
  WCHAR pszPath[264]; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR pszDest[264]; // [rsp+2B0h] [rbp+1B0h] BYREF
  WCHAR String[512]; // [rsp+4C0h] [rbp+3C0h] BYREF
  WCHAR pszFile[264]; // [rsp+8C0h] [rbp+7C0h] BYREF

  v27 = -2i64;
  v6 = GlobalLock(a3->hBitmap);
  v23 = v6;
  if ( v6 )
  {
    GetLocalTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    LocalFileTimeToFileTime(&FileTime, &v25);
    sub_1400835A0(&v25, (char *)String, 512, 0);
    v7 = 0;
    if ( lstrlenW(String) > 0 )
    {
      v8 = String;
      do
      {
        if ( *v8 == 47 )
        {
          *v8 = 45;
        }
        else if ( *v8 == 58 )
        {
          *v8 = 46;
        }
        ++v7;
        ++v8;
      }
      while ( v7 < lstrlenW(String) );
      v6 = v23;
    }
    v9 = 260i64;
    sub_140001000(pszFile, 0x104ui64, L"Clipboard Image (%s).bmp", String);
    PathCombineW(pszDest, *(LPCWSTR *)(a1 + 64), pszFile);
    FileW = CreateFileW(pszDest, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
    if ( FileW != (HANDLE)-1i64 )
    {
      v11 = GlobalSize(a3->hBitmap) + 14;
      v12 = (char *)operator new(v11);
      *(_WORD *)v12 = 19778;
      *(_DWORD *)(v12 + 2) = *v6;
      *(_DWORD *)(v12 + 6) = 0;
      *(_DWORD *)(v12 + 10) = 14;
      memmove(v12 + 14, v6, 0x28ui64);
      v13 = GlobalSize(a3->hBitmap);
      memmove(v12 + 54, v23 + 10, v13 - 40);
      WriteFile(FileW, v12, v11, &NumberOfBytesWritten, 0i64);
      CloseHandle(FileW);
      j_j_free(v12);
      v14 = pszPath;
      while ( v9 != -2147483386 )
      {
        v15 = v14[264];
        if ( !v15 )
          break;
        *v14++ = v15;
        if ( !--v9 )
        {
          --v14;
          break;
        }
      }
      *v14 = 0;
      PathStripPathW(pszPath);
      v29 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v16 = -1i64;
      v17 = pszPath;
      do
      {
        if ( !v16 )
          break;
        v18 = *v17++ == 0;
        --v16;
      }
      while ( !v18 );
      sub_1400099E0(Block, pszPath, -v16 - 2);
      v19 = *a2;
      v20 = sub_14000A760(*a2, *(_QWORD *)(*a2 + 8), Block);
      v21 = a2[1];
      if ( v21 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      a2[1] = v21 + 1;
      *(_QWORD *)(v19 + 8) = v20;
      **((_QWORD **)v20 + 1) = v20;
      if ( v29 >= 8 )
        j_free(Block[0]);
    }
    GlobalUnlock(a3->hBitmap);
  }
  ReleaseStgMedium(a3);
  return 0i64;
}
// 140077667: conditional instruction was optimized away because r12.8!=0
// 1400EB8B0: using guessed type wchar_t aClipboardImage[25];

//----- (0000000140077760) ----------------------------------------------------
__int64 __fastcall sub_140077760(__int64 a1, __int64 *a2, STGMEDIUM *a3)
{
  unsigned int v6; // er12
  const char *v7; // rsi
  WCHAR *lpWideCharStr; // r14
  __int64 v9; // rax
  WCHAR *v10; // rdx
  WCHAR v11; // cx
  __int64 v12; // rcx
  WCHAR *v13; // rdi
  bool v14; // zf
  __int64 v15; // rdi
  char *v16; // rdx
  __int64 v17; // rax
  void *Block[3]; // [rsp+38h] [rbp-490h] BYREF
  unsigned __int64 v20; // [rsp+50h] [rbp-478h]
  WCHAR pszPath[264]; // [rsp+60h] [rbp-468h] BYREF
  char v22[528]; // [rsp+270h] [rbp-258h] BYREF

  v6 = 0;
  v7 = (const char *)GlobalLock(a3->hBitmap);
  if ( v7 )
  {
    lpWideCharStr = (WCHAR *)operator new(saturated_mul(strlen(v7) + 1, 2ui64));
    MultiByteToWideChar(0, 0, v7, -1, lpWideCharStr, strlen(v7) + 1);
    v6 = sub_140075F90(*(LPCWSTR *)(a1 + 64), lpWideCharStr, v22);
    if ( !v6 )
    {
      v9 = 260i64;
      v10 = pszPath;
      while ( v9 != -2147483386 )
      {
        v11 = *(WCHAR *)((char *)v10 + v22 - (char *)pszPath);
        if ( !v11 )
          break;
        *v10++ = v11;
        if ( !--v9 )
        {
          --v10;
          break;
        }
      }
      *v10 = 0;
      PathStripPathW(pszPath);
      v20 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v12 = -1i64;
      v13 = pszPath;
      do
      {
        if ( !v12 )
          break;
        v14 = *v13++ == 0;
        --v12;
      }
      while ( !v14 );
      sub_1400099E0(Block, pszPath, -v12 - 2);
      v15 = *a2;
      v16 = sub_14000A760(*a2, *(_QWORD *)(*a2 + 8), Block);
      v17 = a2[1];
      if ( v17 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      a2[1] = v17 + 1;
      *(_QWORD *)(v15 + 8) = v16;
      **((_QWORD **)v16 + 1) = v16;
      if ( v20 >= 8 )
        j_free(Block[0]);
    }
    j_j_free(lpWideCharStr);
    GlobalUnlock(a3->hBitmap);
  }
  ReleaseStgMedium(a3);
  return v6;
}
// 14007786A: conditional instruction was optimized away because rax.8!=0

//----- (0000000140077970) ----------------------------------------------------
__int64 __fastcall sub_140077970(__int64 a1, __int64 *a2, STGMEDIUM *a3)
{
  unsigned int v6; // esi
  const void *v7; // rax
  __int64 v8; // rax
  WCHAR *v9; // rdx
  WCHAR v10; // cx
  __int64 v11; // rcx
  WCHAR *v12; // rdi
  bool v13; // zf
  __int64 v14; // rdi
  char *v15; // rdx
  __int64 v16; // rax
  void *Block[3]; // [rsp+28h] [rbp-480h] BYREF
  unsigned __int64 v19; // [rsp+40h] [rbp-468h]
  WCHAR pszPath[264]; // [rsp+50h] [rbp-458h] BYREF
  char v21[528]; // [rsp+260h] [rbp-248h] BYREF

  v6 = 0;
  v7 = GlobalLock(a3->hBitmap);
  if ( v7 )
  {
    v6 = sub_140075F90(*(LPCWSTR *)(a1 + 64), v7, v21);
    if ( !v6 )
    {
      v8 = 260i64;
      v9 = pszPath;
      while ( v8 != -2147483386 )
      {
        v10 = *(WCHAR *)((char *)v9 + v21 - (char *)pszPath);
        if ( !v10 )
          break;
        *v9++ = v10;
        if ( !--v8 )
        {
          --v9;
          break;
        }
      }
      *v9 = 0;
      PathStripPathW(pszPath);
      v19 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v11 = -1i64;
      v12 = pszPath;
      do
      {
        if ( !v11 )
          break;
        v13 = *v12++ == 0;
        --v11;
      }
      while ( !v13 );
      sub_1400099E0(Block, pszPath, -v11 - 2);
      v14 = *a2;
      v15 = sub_14000A760(*a2, *(_QWORD *)(*a2 + 8), Block);
      v16 = a2[1];
      if ( v16 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      a2[1] = v16 + 1;
      *(_QWORD *)(v14 + 8) = v15;
      **((_QWORD **)v15 + 1) = v15;
      if ( v19 >= 8 )
        j_free(Block[0]);
    }
    GlobalUnlock(a3->hBitmap);
  }
  ReleaseStgMedium(a3);
  return v6;
}
// 140077A19: conditional instruction was optimized away because rax.8!=0

//----- (0000000140077B00) ----------------------------------------------------
__int64 __fastcall sub_140077B00(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned int v4; // er12
  unsigned int *v5; // rax
  unsigned int *v6; // rdx
  unsigned int v7; // ebx
  _DWORD *v8; // rax
  int v9; // ecx
  int v10; // er13
  int v11; // er14
  void *v12; // r15
  int v13; // edi
  int v14; // eax
  __int16 *v15; // rdx
  int v16; // edi
  int v17; // eax
  int v18; // edi
  int v19; // eax
  __int64 v20; // rdx
  WCHAR *v21; // rcx
  __int64 v22; // rdi
  WCHAR v23; // ax
  WCHAR *v24; // rbx
  __int64 v25; // rcx
  WCHAR *v26; // rdi
  bool v27; // zf
  __int64 *v28; // rbx
  __int64 v29; // rdi
  char *v30; // rax
  __int64 v31; // rdx
  unsigned int v32; // edi
  SIZE_T v33; // rax
  SIZE_T v34; // rax
  const void *v35; // rdi
  SIZE_T v36; // rax
  __int64 v37; // rdx
  WCHAR *v38; // rcx
  __int64 v39; // rdi
  WCHAR v40; // ax
  HANDLE FileW; // rax
  void *v42; // rdi
  __int64 v43; // rdx
  WCHAR *v44; // rcx
  WCHAR v45; // ax
  __int64 v46; // rcx
  WCHAR *v47; // rdi
  __int64 *v48; // r13
  __int64 v49; // rdi
  char *v50; // rax
  __int64 v51; // rdx
  HBITMAP v52; // rdi
  unsigned int v54; // [rsp+40h] [rbp-C0h]
  DWORD dwFlagsAndAttributes; // [rsp+44h] [rbp-BCh]
  SIZE_T nNumberOfBytesToWrite; // [rsp+48h] [rbp-B8h]
  STGMEDIUM v57; // [rsp+50h] [rbp-B0h] BYREF
  void *ppObjectOpen; // [rsp+68h] [rbp-98h] BYREF
  _BYTE *v59; // [rsp+70h] [rbp-90h]
  unsigned int *v60; // [rsp+78h] [rbp-88h]
  STGMEDIUM v61; // [rsp+80h] [rbp-80h] BYREF
  __int64 *v62; // [rsp+98h] [rbp-68h]
  FILETIME *lpLastAccessTime; // [rsp+A0h] [rbp-60h]
  FILETIME *lpCreationTime; // [rsp+A8h] [rbp-58h]
  FILETIME *lpLastWriteTime; // [rsp+B0h] [rbp-50h]
  __int64 v66; // [rsp+B8h] [rbp-48h]
  __int16 v67; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v68; // [rsp+C8h] [rbp-38h]
  int v69; // [rsp+D0h] [rbp-30h]
  int v70; // [rsp+D4h] [rbp-2Ch]
  int v71; // [rsp+D8h] [rbp-28h]
  __int16 v72; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v73; // [rsp+E8h] [rbp-18h]
  int v74; // [rsp+F0h] [rbp-10h]
  int v75; // [rsp+F4h] [rbp-Ch]
  int v76; // [rsp+F8h] [rbp-8h]
  __int16 v77; // [rsp+100h] [rbp+0h] BYREF
  __int64 v78; // [rsp+108h] [rbp+8h]
  int v79; // [rsp+110h] [rbp+10h]
  int v80; // [rsp+114h] [rbp+14h]
  int v81; // [rsp+118h] [rbp+18h]
  char v82[4]; // [rsp+120h] [rbp+20h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+124h] [rbp+24h] BYREF
  __int16 v84; // [rsp+128h] [rbp+28h] BYREF
  __int64 v85; // [rsp+130h] [rbp+30h]
  int v86; // [rsp+138h] [rbp+38h]
  int v87; // [rsp+13Ch] [rbp+3Ch]
  int v88; // [rsp+140h] [rbp+40h]
  STGMEDIUM v89; // [rsp+148h] [rbp+48h] BYREF
  __int64 v90; // [rsp+160h] [rbp+60h]
  char v91[16]; // [rsp+170h] [rbp+70h] BYREF
  size_t Size; // [rsp+180h] [rbp+80h]
  void *Block[2]; // [rsp+1C0h] [rbp+C0h] BYREF
  __int64 v94; // [rsp+1D0h] [rbp+D0h]
  unsigned __int64 v95; // [rsp+1D8h] [rbp+D8h]
  void *Src[3]; // [rsp+1E8h] [rbp+E8h] BYREF
  unsigned __int64 v97; // [rsp+200h] [rbp+100h]
  WCHAR pszPath[264]; // [rsp+210h] [rbp+110h] BYREF
  WCHAR FileName[264]; // [rsp+420h] [rbp+320h] BYREF

  v90 = -2i64;
  v62 = a3;
  v66 = a1;
  v4 = (*(__int64 (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(a2, &word_14012E028, &v89);
  if ( !v4 )
  {
    v5 = (unsigned int *)GlobalLock(v89.hBitmap);
    v6 = v5;
    v60 = v5;
    if ( v5 )
    {
      lpCreationTime = 0i64;
      lpLastAccessTime = 0i64;
      lpLastWriteTime = 0i64;
      dwFlagsAndAttributes = 128;
      LODWORD(nNumberOfBytesToWrite) = 0;
      v7 = 0;
      v54 = 0;
      if ( *v5 )
      {
        v8 = v5 + 1;
        v59 = v8;
        while ( 1 )
        {
          v9 = *v8;
          if ( (*v8 & 4) != 0 )
            dwFlagsAndAttributes = v8[9];
          if ( (v9 & 0x40) != 0 )
            nNumberOfBytesToWrite = (unsigned int)v8[17];
          if ( (v9 & 8) != 0 )
            lpCreationTime = (FILETIME *)&v6[148 * v7 + 11];
          if ( (v9 & 0x10) != 0 )
            lpLastAccessTime = (FILETIME *)&v6[148 * v7 + 13];
          if ( (v9 & 0x20) != 0 )
            lpLastWriteTime = (FILETIME *)&v6[148 * v7 + 15];
          v57.tymed = 0;
          v57.hBitmap = 0i64;
          v57.pUnkForRelease = 0i64;
          v10 = 0;
          v11 = 0;
          v12 = 0i64;
          v67 = RegisterClipboardFormatW(L"FileContents");
          v71 = 1;
          v70 = v7;
          v69 = 1;
          v68 = 0i64;
          v77 = RegisterClipboardFormatW(L"FileContents");
          v81 = 4;
          v80 = v7;
          v79 = 1;
          v78 = 0i64;
          v72 = RegisterClipboardFormatW(L"FileContents");
          v76 = 8;
          v75 = v7;
          v74 = 1;
          v73 = 0i64;
          v13 = v70;
          v70 = -1;
          v14 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a2 + 40i64))(a2, &v67);
          v70 = v13;
          if ( !v14
            && !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
                  a2,
                  &v67,
                  &v61) )
          {
            ReleaseStgMedium(&v61);
            v15 = &v67;
            goto LABEL_24;
          }
          v16 = v80;
          v80 = -1;
          v17 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a2 + 40i64))(a2, &v77);
          v80 = v16;
          if ( !v17
            && !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
                  a2,
                  &v77,
                  &v61) )
          {
            break;
          }
          v18 = v75;
          v75 = -1;
          v19 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a2 + 40i64))(a2, &v72);
          v75 = v18;
          if ( !v19
            && !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
                  a2,
                  &v72,
                  &v61) )
          {
            ReleaseStgMedium(&v61);
            v15 = &v72;
LABEL_24:
            v4 = (*(__int64 (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(a2, v15, &v57);
            if ( !v4 )
            {
              switch ( v57.tymed )
              {
                case 1u:
                  v34 = GlobalSize(v57.hBitmap);
                  v12 = malloc(v34);
                  if ( v12 )
                  {
                    if ( (*v59 & 0x40) == 0 )
                      nNumberOfBytesToWrite = GlobalSize(v57.hBitmap);
                    v35 = GlobalLock(v57.hBitmap);
                    if ( v35 )
                    {
                      v36 = GlobalSize(v57.hBitmap);
                      memmove(v12, v35, v36);
                      GlobalUnlock(v57.hBitmap);
                      v11 = 1;
                    }
                  }
                  break;
                case 4u:
                  v4 = (*(__int64 (__fastcall **)(HBITMAP, char *, __int64))(*(_QWORD *)v57.hBitmap + 96i64))(
                         v57.hBitmap,
                         v91,
                         1i64);
                  if ( !v4 )
                  {
                    v32 = Size;
                    v12 = malloc((unsigned int)Size);
                    if ( v12 )
                    {
                      v33 = nNumberOfBytesToWrite;
                      if ( (*v59 & 0x40) == 0 )
                        v33 = v32;
                      nNumberOfBytesToWrite = v33;
                      (*(void (__fastcall **)(HBITMAP, void *, _QWORD, char *))(*(_QWORD *)v57.hBitmap + 24i64))(
                        v57.hBitmap,
                        v12,
                        v32,
                        v82);
                      v11 = v4 + 1;
                    }
                  }
                  break;
                case 8u:
                  v20 = 260i64;
                  v21 = pszPath;
                  v22 = *(_QWORD *)(v66 + 64) - (_QWORD)pszPath;
                  while ( v20 != -2147483386 )
                  {
                    v23 = *(WCHAR *)((char *)v21 + v22);
                    if ( !v23 )
                      break;
                    *v21++ = v23;
                    if ( !--v20 )
                    {
                      --v21;
                      break;
                    }
                  }
                  *v21 = 0;
                  v24 = (WCHAR *)&v60[148 * v7 + 19];
                  PathAppendW(pszPath, v24);
                  ppObjectOpen = 0i64;
                  v4 = StgCreateStorageEx(pszPath, 0x11002u, 0, 0, 0i64, 0i64, &stru_1400E4180, &ppObjectOpen);
                  if ( !v4 )
                  {
                    v4 = (*(__int64 (__fastcall **)(HBITMAP, _QWORD, _QWORD, _QWORD, void *))(*(_QWORD *)v57.hBitmap
                                                                                            + 56i64))(
                           v57.hBitmap,
                           0i64,
                           0i64,
                           0i64,
                           ppObjectOpen);
                    if ( !v4 )
                    {
                      v4 = (*(__int64 (__fastcall **)(void *, _QWORD))(*(_QWORD *)ppObjectOpen + 72i64))(
                             ppObjectOpen,
                             0i64);
                      if ( !v4 )
                      {
                        v95 = 7i64;
                        v94 = 0i64;
                        LOWORD(Block[0]) = 0;
                        v25 = -1i64;
                        v26 = v24;
                        do
                        {
                          if ( !v25 )
                            break;
                          v27 = *v26++ == 0;
                          --v25;
                        }
                        while ( !v27 );
                        sub_1400099E0(Block, v24, -v25 - 2);
                        v28 = v62;
                        v29 = *v62;
                        v30 = sub_14000A760(*v62, *(_QWORD *)(*v62 + 8), Block);
                        v31 = v28[1];
                        if ( v31 == 0x666666666666665i64 )
                          sub_14002B5F8("list<T> too long");
                        v28[1] = v31 + 1;
                        *(_QWORD *)(v29 + 8) = v30;
                        **((_QWORD **)v30 + 1) = v30;
                        if ( v95 >= 8 )
                          j_free(Block[0]);
                        v95 = 7i64;
                        v94 = 0i64;
                        LOWORD(Block[0]) = 0;
                        v10 = 1;
                      }
                    }
                    (*(void (__fastcall **)(void *))(*(_QWORD *)ppObjectOpen + 16i64))(ppObjectOpen);
                  }
                  v7 = v54;
                  break;
              }
              ReleaseStgMedium(&v57);
              if ( v11 && !v10 )
              {
                v37 = 260i64;
                v38 = FileName;
                v39 = *(_QWORD *)(v66 + 64) - (_QWORD)FileName;
                while ( v37 != -2147483386 )
                {
                  v40 = *(WCHAR *)((char *)v38 + v39);
                  if ( !v40 )
                    break;
                  *v38++ = v40;
                  if ( !--v37 )
                  {
                    --v38;
                    break;
                  }
                }
                *v38 = 0;
                PathAppendW(FileName, (LPCWSTR)&v60[148 * v7 + 19]);
                FileW = CreateFileW(FileName, 0x40000000u, 0, 0i64, 2u, dwFlagsAndAttributes, 0i64);
                v42 = FileW;
                if ( FileW != (HANDLE)-1i64 )
                {
                  SetFileTime(FileW, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
                  WriteFile(v42, v12, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0i64);
                  CloseHandle(v42);
                  v43 = 260i64;
                  v44 = pszPath;
                  while ( v43 != -2147483386 )
                  {
                    v45 = v44[264];
                    if ( !v45 )
                      break;
                    *v44++ = v45;
                    if ( !--v43 )
                    {
                      --v44;
                      break;
                    }
                  }
                  *v44 = 0;
                  PathStripPathW(pszPath);
                  v97 = 7i64;
                  Src[2] = 0i64;
                  LOWORD(Src[0]) = 0;
                  v46 = -1i64;
                  v47 = pszPath;
                  do
                  {
                    if ( !v46 )
                      break;
                    v27 = *v47++ == 0;
                    --v46;
                  }
                  while ( !v27 );
                  sub_1400099E0(Src, pszPath, -v46 - 2);
                  v48 = v62;
                  v49 = *v62;
                  v50 = sub_14000A760(*v62, *(_QWORD *)(*v62 + 8), Src);
                  v51 = v48[1];
                  if ( v51 == 0x666666666666665i64 )
                    sub_14002B5F8("list<T> too long");
                  v48[1] = v51 + 1;
                  *(_QWORD *)(v49 + 8) = v50;
                  **((_QWORD **)v50 + 1) = v50;
                  if ( v97 >= 8 )
                    j_free(Src[0]);
                }
                v84 = RegisterClipboardFormatW(L"Performed DropEffect");
                v85 = 0i64;
                v86 = 1;
                v87 = -1;
                v88 = 1;
                v52 = (HBITMAP)GlobalAlloc(2u, 4ui64);
                *(_DWORD *)GlobalLock(v52) = 1;
                GlobalUnlock(v52);
                v61.tymed = 1;
                v61.pUnkForRelease = 0i64;
                v61.hBitmap = v52;
                (*(void (__fastcall **)(__int64, __int16 *, STGMEDIUM *, _QWORD))(*(_QWORD *)a2 + 56i64))(
                  a2,
                  &v84,
                  &v61,
                  0i64);
              }
              if ( v12 )
                free(v12);
            }
          }
          v54 = ++v7;
          v8 = v59 + 592;
          v59 += 592;
          v6 = v60;
          if ( v7 >= *v60 )
            goto LABEL_81;
        }
        ReleaseStgMedium(&v61);
        v15 = &v77;
        goto LABEL_24;
      }
LABEL_81:
      GlobalUnlock(v89.hBitmap);
    }
    ReleaseStgMedium(&v89);
  }
  return v4;
}
// 140077DF6: conditional instruction was optimized away because rdx.8!=0
// 1400780BA: conditional instruction was optimized away because rdx.8!=0
// 1400781A6: conditional instruction was optimized away because rdx.8!=0
// 140077FB8: variable 'nNumberOfBytesToWrite' is possibly undefined
// 14012E028: using guessed type __int16 word_14012E028;
// 140077B00: using guessed type char var_500[16];
// 140077B00: using guessed type char var_550[4];

//----- (0000000140078370) ----------------------------------------------------
__int64 __fastcall sub_140078370(__int64 a1, int a2, int a3, STGMEDIUM *a4)
{
  HDROP v9; // [rsp+48h] [rbp+20h] BYREF

  v9 = (HDROP)GlobalLock(a4->hBitmap);
  if ( v9 )
  {
    sub_140076F00(a1, &v9, a2, a3);
    GlobalUnlock(a4->hBitmap);
  }
  ReleaseStgMedium(a4);
  return 0i64;
}

//----- (00000001400783F0) ----------------------------------------------------
void __fastcall sub_1400783F0(__int64 a1, __int64 a2, int *a3)
{
  int v5; // er12
  int v6; // er13
  int *v7; // rax
  int v8; // eax
  _QWORD *v9; // rax
  int v10; // ebx
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // ebx
  int v17; // eax
  void **v18; // rbx
  void *v19; // rcx
  void **v20; // rdi
  STGMEDIUM v21; // [rsp+20h] [rbp-79h] BYREF
  void *Block; // [rsp+38h] [rbp-61h] BYREF
  __int64 v23; // [rsp+40h] [rbp-59h]
  int v24[2]; // [rsp+50h] [rbp-49h] BYREF
  char *v25; // [rsp+58h] [rbp-41h] BYREF
  HDROP v26; // [rsp+60h] [rbp-39h] BYREF
  __int16 v27; // [rsp+68h] [rbp-31h] BYREF
  __int64 v28; // [rsp+70h] [rbp-29h]
  int v29; // [rsp+78h] [rbp-21h]
  int v30; // [rsp+7Ch] [rbp-1Dh]
  int v31; // [rsp+80h] [rbp-19h]
  STGMEDIUM v32; // [rsp+88h] [rbp-11h] BYREF
  __int64 pExceptionObject[10]; // [rsp+A0h] [rbp+7h] BYREF

  pExceptionObject[3] = -2i64;
  v5 = 0;
  v6 = 0;
  v24[0] = *a3;
  v24[1] = a3[1];
  v27 = RegisterClipboardFormatW(L"Preferred DropEffect");
  v31 = 1;
  v30 = -1;
  v29 = 1;
  v28 = 0i64;
  if ( !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(a2, &v27, &v32) )
  {
    v7 = (int *)GlobalLock(v32.hBitmap);
    if ( v7 )
    {
      v8 = *v7;
      if ( v8 )
      {
        v5 = v8;
        v6 = 1;
        GlobalUnlock(v32.hBitmap);
      }
    }
    ReleaseStgMedium(&v32);
  }
  v23 = 0i64;
  v9 = operator new(0x38ui64);
  if ( !v9 )
  {
    v25 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v9;
  *v9 = v9;
  *((_QWORD *)Block + 1) = Block;
  v10 = dword_14011D734;
  dword_14011D734 = -1;
  v11 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)a2 + 40i64))(a2, qword_14011D720);
  dword_14011D734 = v10;
  if ( !v11
    && !(*(unsigned int (__fastcall **)(__int64, _QWORD *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
          a2,
          qword_14011D720,
          &v21) )
  {
    ReleaseStgMedium(&v21);
    v12 = (*(__int64 (__fastcall **)(__int64, _QWORD *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(a2, qword_14011D720, &v21);
    if ( !v12 )
    {
      v26 = (HDROP)GlobalLock(v21.hBitmap);
      if ( v26 )
      {
        sub_140076F00(a1, &v26, v6, v5);
        GlobalUnlock(v21.hBitmap);
      }
      ReleaseStgMedium(&v21);
    }
    goto LABEL_30;
  }
  v13 = dword_14012E05C;
  dword_14012E05C = -1;
  v14 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a2 + 40i64))(a2, &word_14012E048);
  dword_14012E05C = v13;
  if ( v14
    || (*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
         a2,
         &word_14012E048,
         &v21) )
  {
    v16 = dword_14012E03C;
    dword_14012E03C = -1;
    v17 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)a2 + 40i64))(a2, &word_14012E028);
    dword_14012E03C = v16;
    if ( !v17
      && !(*(unsigned int (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
            a2,
            &word_14012E028,
            &v21) )
    {
      ReleaseStgMedium(&v21);
      v15 = sub_140077B00(a1, a2, (__int64 *)&Block);
      goto LABEL_29;
    }
    if ( (unsigned int)sub_140075D60(a2, (__int64)qword_14011D760) )
    {
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
              a2,
              qword_14011D760,
              &v21);
      if ( !v12 )
      {
        v15 = sub_140077970(a1, (__int64 *)&Block, &v21);
        goto LABEL_29;
      }
    }
    else if ( (unsigned int)sub_140075D60(a2, (__int64)qword_14011D740) )
    {
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
              a2,
              qword_14011D740,
              &v21);
      if ( !v12 )
      {
        v15 = sub_140077760(a1, (__int64 *)&Block, &v21);
        goto LABEL_29;
      }
    }
    else
    {
      if ( !(unsigned int)sub_140075D60(a2, (__int64)qword_14011D780) )
        goto LABEL_34;
      v12 = (*(__int64 (__fastcall **)(__int64, _QWORD *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
              a2,
              qword_14011D780,
              &v21);
      if ( !v12 )
      {
        v15 = sub_140077420(a1, (__int64 *)&Block, &v21);
        goto LABEL_29;
      }
    }
  }
  else
  {
    ReleaseStgMedium(&v21);
    v12 = (*(__int64 (__fastcall **)(__int64, __int16 *, STGMEDIUM *))(*(_QWORD *)a2 + 24i64))(
            a2,
            &word_14012E048,
            &v21);
    if ( !v12 )
    {
      v15 = sub_140075E60(&v21);
LABEL_29:
      v12 = v15;
    }
  }
LABEL_30:
  if ( !v12 && v23 && *(_QWORD *)(a1 + 24) )
    (***(void (__fastcall ****)(_QWORD, void **, int *))(a1 + 24))(*(_QWORD *)(a1 + 24), &Block, v24);
LABEL_34:
  v18 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  *((_QWORD *)Block + 1) = Block;
  v23 = 0i64;
  v19 = Block;
  if ( v18 != Block )
  {
    do
    {
      v20 = (void **)*v18;
      if ( (unsigned __int64)v18[5] >= 8 )
        j_free(v18[2]);
      v18[5] = (void *)7;
      v18[4] = 0i64;
      *((_WORD *)v18 + 8) = 0;
      j_free(v18);
      v18 = v20;
      v19 = Block;
    }
    while ( v20 != Block );
  }
  j_free(v19);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14011D720: using guessed type _QWORD qword_14011D720[2];
// 14011D734: using guessed type int dword_14011D734;
// 14011D740: using guessed type _QWORD qword_14011D740[4];
// 14011D760: using guessed type _QWORD qword_14011D760[4];
// 14011D780: using guessed type _QWORD qword_14011D780[136];
// 14012E028: using guessed type __int16 word_14012E028;
// 14012E03C: using guessed type int dword_14012E03C;
// 14012E048: using guessed type __int16 word_14012E048;
// 14012E05C: using guessed type int dword_14012E05C;

//----- (00000001400787D0) ----------------------------------------------------
void __fastcall sub_1400787D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  __int64 v6; // rax

  v6 = a5;
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 24) = v6;
  LODWORD(v6) = a6;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 72) = v6;
  *(_DWORD *)(a1 + 44) = 1;
  a5 = 0i64;
  *(_QWORD *)(a1 + 64) = a4;
  sub_1400783F0(a1, a2, (int *)&a5);
}

//----- (0000000140078820) ----------------------------------------------------
void __fastcall sub_140078820(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        int *a5,
        __int64 a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  int v9; // er8

  *(_DWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 36) = a4;
  v9 = *a5;
  *(_QWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 44) = v9;
  *(_QWORD *)(a1 + 64) = a8;
  *(_QWORD *)(a1 + 24) = a9;
  *(_DWORD *)(a1 + 56) = a7;
  *(_DWORD *)(a1 + 72) = 0;
  if ( a7 )
  {
    if ( a7 == 1 )
      sub_1400761A0(a1);
  }
  else
  {
    sub_1400783F0(a1, a2, (int *)(a1 + 36));
  }
}

//----- (0000000140078890) ----------------------------------------------------
__int64 __fastcall sub_140078890(__int64 a1)
{
  *(_DWORD *)(a1 + 40) = 1;
  return 0i64;
}

//----- (00000001400788A0) ----------------------------------------------------
__int64 __fastcall sub_1400788A0(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 44) = a2;
  return 0i64;
}

//----- (00000001400788B0) ----------------------------------------------------
__int64 __fastcall sub_1400788B0(__int64 a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 40);
  return 0i64;
}

//----- (00000001400788C0) ----------------------------------------------------
__int64 __fastcall sub_1400788C0(__int64 a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 44);
  return 0i64;
}

//----- (00000001400788D0) ----------------------------------------------------
__int64 __fastcall sub_1400788D0(__int64 a1)
{
  *(_DWORD *)(a1 + 40) = 0;
  return 0i64;
}

//----- (00000001400788E0) ----------------------------------------------------
__int64 sub_1400788E0()
{
  return 2147745795i64;
}

//----- (00000001400788F0) ----------------------------------------------------
__int64 sub_1400788F0()
{
  return 2147745795i64;
}

//----- (0000000140078900) ----------------------------------------------------
__int64 sub_140078900()
{
  return 2147500033i64;
}

//----- (0000000140078910) ----------------------------------------------------
__int64 __fastcall sub_140078910(__int64 a1, __int64 a2, __int64 a3)
{
  if ( !a3 )
    return 2147942487i64;
  *(_QWORD *)(a3 + 8) = 0i64;
  return 2147500033i64;
}

//----- (0000000140078930) ----------------------------------------------------
__int64 sub_140078930()
{
  return 2147745897i64;
}

//----- (0000000140078940) ----------------------------------------------------
__int64 __fastcall sub_140078940(__int64 a1, int *a2, __int64 a3)
{
  int v3; // eax
  __int64 result; // rax

  v3 = *a2;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_DWORD *)a1 = v3;
  if ( *((_QWORD *)a2 + 2) )
  {
    *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
    (*(void (__fastcall **)(_QWORD))(**((_QWORD **)a2 + 2) + 8i64))(*((_QWORD *)a2 + 2));
  }
  result = (unsigned int)(*(_DWORD *)(a3 + 24) - 1);
  switch ( *(_DWORD *)(a3 + 24) )
  {
    case 1:
    case 2:
    case 0x10:
    case 0x20:
    case 0x40:
      result = (__int64)OleDuplicateData(*((HANDLE *)a2 + 1), *(_WORD *)a3, 0);
      *(_QWORD *)(a1 + 8) = result;
      break;
    case 4:
    case 8:
      *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
      result = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a2 + 1) + 8i64))(*((_QWORD *)a2 + 1));
      break;
    default:
      return result;
  }
  return result;
}

//----- (0000000140078A40) ----------------------------------------------------
__int64 __fastcall sub_140078A40(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 16));
}

//----- (0000000140078A60) ----------------------------------------------------
__int64 __fastcall sub_140078A60(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rcx
  _QWORD *v4; // rax

  if ( !a2 )
    return 2147942487i64;
  v3 = *(_QWORD **)(a1 + 24);
  v4 = (_QWORD *)*v3;
  if ( (_QWORD *)*v3 == v3 )
    return 2147745892i64;
  while ( *((_WORD *)v4 + 8) != *(_WORD *)a2
       || ((unsigned int)v4[5] & *(_DWORD *)(a2 + 24)) == 0
       || (unsigned int)v4[4] != *(_DWORD *)(a2 + 16) )
  {
    v4 = (_QWORD *)*v4;
    if ( v4 == v3 )
      return 2147745892i64;
  }
  return 0i64;
}

//----- (0000000140078AF0) ----------------------------------------------------
__int64 __fastcall sub_140078AF0(_QWORD *a1, __int16 *a2, __int64 a3)
{
  _QWORD *v7; // rcx
  _QWORD *v8; // rax
  __int16 v9; // r11
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r10
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15[4]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v16[5]; // [rsp+40h] [rbp-28h] BYREF

  if ( !a2 || !a3 )
    return 2147942487i64;
  if ( (*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 40i64))(a1) == -2147221404 )
    return 2147745892i64;
  v7 = (_QWORD *)a1[3];
  v8 = (_QWORD *)*v7;
  if ( (_QWORD *)*v7 == v7 )
    return 2147745892i64;
  v9 = *a2;
  while ( 1 )
  {
    v10 = v8[2];
    v11 = v8[4];
    v12 = v8[5];
    v15[1] = v8[3];
    v16[0] = v8[6];
    v13 = v8[7];
    v15[0] = v10;
    v16[1] = v13;
    v14 = v8[8];
    v15[2] = v11;
    v15[3] = v12;
    v16[2] = v14;
    if ( (_WORD)v10 == v9 && ((unsigned int)v12 & *((_DWORD *)a2 + 6)) != 0 && (_DWORD)v11 == *((_DWORD *)a2 + 4) )
      break;
    v8 = (_QWORD *)*v8;
    if ( v8 == v7 )
      return 2147745892i64;
  }
  sub_140078940(a3, (int *)v16, (__int64)v15);
  return 0i64;
}

//----- (0000000140078BF0) ----------------------------------------------------
__int64 __fastcall sub_140078BF0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v5; // rdx
  bool v6; // cf
  unsigned __int64 v7; // r11
  int v8; // eax
  bool v9; // cf
  unsigned __int64 v10; // r11
  int v11; // eax
  bool v12; // cf
  unsigned __int64 v13; // r10
  int v14; // eax

  if ( !a3 )
    return 2147500035i64;
  v5 = 0i64;
  *a3 = 0i64;
  v6 = *a2 < 0x10Eui64;
  if ( *a2 == 270i64 && (v7 = a2[1], v6 = v7 < 0x46000000000000C0i64, v7 == 0x46000000000000C0i64) )
    v8 = 0;
  else
    v8 = -v6 - (v6 - 1);
  if ( v8
    && ((v9 = 0, *a2) || (v10 = a2[1], v9 = v10 < 0x46000000000000C0i64, v10 != 0x46000000000000C0i64) ? (v11 = -v9 - (v9 - 1)) : (v11 = 0),
        v11) )
  {
    v12 = *a2 < 0x11D2F6913D8B0590ui64;
    if ( *a2 == 0x11D2F6913D8B0590i64
      && (v13 = a2[1], v12 = v13 < 0xD45BDF976000A98Eui64, v13 == 0xD45BDF976000A98Eui64) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -v12 - (v12 - 1);
    }
    if ( v14 )
      return 2147500034i64;
    if ( a1 )
      v5 = a1 + 8;
    *a3 = v5;
  }
  else
  {
    *a3 = a1;
  }
  if ( *a3 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
    return 0i64;
  }
  return 2147500034i64;
}
// 1400E41B0: using guessed type __int64 qword_1400E41B0;

//----- (0000000140078CD0) ----------------------------------------------------
void __fastcall sub_140078CD0(__int64 a1)
{
  __int64 **v2; // rdi
  __int64 *i; // rbx
  _QWORD **v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  STGMEDIUM v7; // [rsp+40h] [rbp-28h] BYREF

  *(_QWORD *)a1 = &CDataObject::`vftable';
  *(_QWORD *)(a1 + 8) = &CDataObject::`vftable';
  v2 = *(__int64 ***)(a1 + 24);
  for ( i = *v2; i != (__int64 *)v2; i = (__int64 *)*i )
  {
    v7 = *(STGMEDIUM *)((_BYTE *)i + 2);
    ReleaseStgMedium(&v7);
  }
  v4 = *(_QWORD ***)(a1 + 24);
  v5 = *v4;
  *v4 = v4;
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0i64;
  if ( v5 != *(_QWORD **)(a1 + 24) )
  {
    do
    {
      v6 = (_QWORD *)*v5;
      j_free(v5);
      v5 = v6;
    }
    while ( v6 != *(_QWORD **)(a1 + 24) );
  }
  j_free(*(void **)(a1 + 24));
}
// 1400F7B68: using guessed type void *CDataObject::`vftable';
// 1400F7BD8: using guessed type void *CDataObject::`vftable';

//----- (0000000140078DC0) ----------------------------------------------------
__int64 __fastcall sub_140078DC0(__int64 a1, _QWORD *a2, __int64 a3, int a4)
{
  __int64 v5; // rdi
  char *v6; // r11
  __int64 v7; // rax
  __int64 v9[4]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v10[5]; // [rsp+40h] [rbp-28h] BYREF

  if ( !a2 || !a3 )
    return 2147942487i64;
  v9[0] = *a2;
  v9[1] = a2[1];
  v9[2] = a2[2];
  v9[3] = a2[3];
  if ( a4 )
  {
    v10[0] = *(_QWORD *)a3;
    v10[1] = *(_QWORD *)(a3 + 8);
    v10[2] = *(_QWORD *)(a3 + 16);
  }
  else
  {
    sub_140078940((__int64)v10, (int *)a3, (__int64)a2);
  }
  v5 = *(_QWORD *)(a1 + 24);
  v6 = sub_14001CA30(v5, *(_QWORD *)(v5 + 8), v9);
  v7 = *(_QWORD *)(a1 + 32);
  if ( v7 == 0x492492492492491i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 32) = v7 + 1;
  *(_QWORD *)(v5 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  return 0i64;
}
// 140078DC0: using guessed type _QWORD var_28[5];
// 140078DC0: using guessed type _QWORD var_48[4];

//----- (0000000140078EA0) ----------------------------------------------------
__int64 __fastcall sub_140078EA0(void *Block)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedDecrement((volatile signed __int32 *)Block + 4);
  if ( !(_DWORD)result )
  {
    if ( Block )
    {
      sub_140078CD0((__int64)Block);
      j_free(Block);
    }
    return 0i64;
  }
  return result;
}

//----- (0000000140078EE0) ----------------------------------------------------
__int64 __fastcall sub_140078EE0(__int64 a1, __int64 *a2, __int64 *a3)
{
  _QWORD *v6; // rax
  __int64 i; // rsi
  __int64 v8; // rbx
  char *v9; // rax
  __int64 v10; // rdx
  __int64 pExceptionObject[3]; // [rsp+28h] [rbp-80h] BYREF
  __int64 v13[8]; // [rsp+40h] [rbp-68h] BYREF
  char *v14; // [rsp+C8h] [rbp+20h] BYREF

  *(_QWORD *)a1 = &CDataObject::`vftable';
  *(_QWORD *)(a1 + 8) = &CDataObject::`vftable';
  *(_QWORD *)(a1 + 32) = 0i64;
  v6 = operator new(0x48ui64);
  if ( !v6 )
  {
    v14 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v14);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 24) = v6;
  *v6 = v6;
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8i64) = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 16) = 1;
  for ( i = 0i64; i < 2; ++i )
  {
    v13[0] = *a2;
    v13[1] = a2[1];
    v13[2] = a2[2];
    v13[3] = a2[3];
    v13[4] = *a3;
    v13[5] = a3[1];
    v13[6] = a3[2];
    v8 = *(_QWORD *)(a1 + 24);
    v9 = sub_14001CA30(v8, *(_QWORD *)(v8 + 8), v13);
    v10 = *(_QWORD *)(a1 + 32);
    if ( v10 == 0x492492492492491i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 32) = v10 + 1;
    *(_QWORD *)(v8 + 8) = v9;
    **((_QWORD **)v9 + 1) = v9;
    a2 += 4;
    a3 += 3;
  }
  *(_QWORD *)(a1 + 48) = 0i64;
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F7B68: using guessed type void *CDataObject::`vftable';
// 1400F7BD8: using guessed type void *CDataObject::`vftable';

//----- (0000000140079060) ----------------------------------------------------
__int64 __fastcall sub_140079060(__int64 *a1, __int64 *a2, _QWORD *a3)
{
  void *v6; // rax

  v6 = operator new(0x38ui64);
  if ( v6 )
    v6 = (void *)sub_140078EE0((__int64)v6, a1, a2);
  *a3 = v6;
  return 0i64;
}

//----- (00000001400790C0) ----------------------------------------------------
__int64 __fastcall sub_1400790C0(__int64 a1, int a2, _QWORD *a3)
{
  __int64 v6; // rsi
  _QWORD *v7; // rax
  _QWORD *v8; // rdi
  _QWORD *v9; // rbp
  _QWORD *i; // rbx
  char *v11; // rax
  void **v12; // rax
  unsigned int v13; // esi
  _QWORD *v14; // rcx
  _QWORD *v15; // rbx
  _QWORD **v16; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v17; // [rsp+28h] [rbp-A0h]
  __int64 v18[7]; // [rsp+38h] [rbp-90h] BYREF
  __int64 pExceptionObject[4]; // [rsp+70h] [rbp-58h] BYREF
  __int64 *v20; // [rsp+90h] [rbp-38h] BYREF
  char *v21; // [rsp+E0h] [rbp+18h] BYREF

  pExceptionObject[3] = -2i64;
  if ( !a3 )
    return 2147942487i64;
  if ( a2 != 1 )
    return 2147500033i64;
  v6 = 0i64;
  v17 = 0i64;
  v7 = operator new(0x30ui64);
  v8 = v7;
  if ( !v7 )
  {
    v21 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v16 = (_QWORD **)v7;
  *v7 = v7;
  v7[1] = v7;
  v9 = *(_QWORD **)(a1 + 24);
  for ( i = (_QWORD *)*v9; i != v9; i = (_QWORD *)*i )
  {
    v18[0] = i[2];
    v18[1] = i[3];
    v18[2] = i[4];
    v18[3] = i[5];
    v18[4] = i[6];
    v18[5] = i[7];
    v18[6] = i[8];
    v11 = sub_14001CB00((__int64)v8, v8[1], v18);
    if ( v6 == 0x7FFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    v17 = ++v6;
    v8[1] = v11;
    **((_QWORD **)v11 + 1) = v11;
  }
  v12 = (void **)sub_14001C990(&v20, &v16);
  v13 = sub_140074FE0(v12, a3);
  v14 = (_QWORD *)*v8;
  *v8 = v8;
  v8[1] = v8;
  if ( v14 != v8 )
  {
    do
    {
      v15 = (_QWORD *)*v14;
      j_free(v14);
      v14 = v15;
    }
    while ( v15 != v8 );
  }
  j_free(v8);
  return v13;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400792A0) ----------------------------------------------------
void __fastcall sub_1400792A0(__int64 a1)
{
  void **v1; // rbx

  v1 = (void **)(a1 + 24);
  sub_14000A630(a1 + 24);
  j_free(*v1);
}

//----- (00000001400792D0) ----------------------------------------------------
__int64 __fastcall sub_1400792D0(__int64 a1, __int64 a2)
{
  sub_14000A5B0((_QWORD *)(a1 + 24));
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

//----- (0000000140079310) ----------------------------------------------------
void __fastcall sub_140079310(__int64 a1)
{
  WPARAM v1; // rax
  int v3; // ebp
  _QWORD *v4; // rdi
  _QWORD *i; // rbx
  LPARAM *v6; // r9
  LPARAM lParam[3]; // [rsp+20h] [rbp-48h] BYREF
  unsigned __int64 v8; // [rsp+38h] [rbp-30h]

  v1 = *(int *)(a1 + 8);
  v3 = 0;
  if ( (_DWORD)v1 )
  {
    SendMessageW(*(HWND *)a1, 0x404u, v1, *(_QWORD *)(a1 + 16));
    j_free(*(void **)(a1 + 16));
    v4 = *(_QWORD **)(a1 + 24);
    for ( i = (_QWORD *)*v4; i != v4; i = (_QWORD *)*i )
    {
      v8 = 7i64;
      lParam[2] = 0i64;
      LOWORD(lParam[0]) = 0;
      sub_140009610(lParam, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v6 = lParam;
      if ( v8 >= 8 )
        v6 = (LPARAM *)lParam[0];
      SendMessageW(*(HWND *)a1, 0x40Bu, v3++, (LPARAM)v6);
      if ( v8 >= 8 )
        j_free((void *)lParam[0]);
    }
    *(_DWORD *)(a1 + 8) = 0;
    sub_14000A630(a1 + 24);
    *(_BYTE *)(a1 + 48) = 0;
  }
}

//----- (0000000140079430) ----------------------------------------------------
void **__fastcall sub_140079430(__int64 a1)
{
  void **result; // rax
  int v3; // ebp
  void *v4; // rax
  int i; // ebx
  __int64 v6; // rcx
  LPARAM *v7; // rdi
  bool v8; // zf
  __int64 v9; // rdi
  char *v10; // rax
  __int64 v11; // rdx
  LPARAM v12[2]; // [rsp+20h] [rbp-478h] BYREF
  void *Block[3]; // [rsp+30h] [rbp-468h] BYREF
  unsigned __int64 v14; // [rsp+48h] [rbp-450h]
  LPARAM lParam[128]; // [rsp+60h] [rbp-438h] BYREF
  void *retaddr; // [rsp+498h] [rbp+0h] BYREF

  result = &retaddr;
  v12[1] = -2i64;
  if ( !*(_BYTE *)(a1 + 48) )
  {
    v3 = SendMessageW(*(HWND *)a1, 0x406u, 0i64, 0i64);
    v4 = operator new(saturated_mul(v3, 4ui64));
    *(_QWORD *)(a1 + 16) = v4;
    SendMessageW(*(HWND *)a1, 0x406u, v3, (LPARAM)v4);
    for ( i = 0; i < v3; ++i )
    {
      SendMessageW(*(HWND *)a1, 0x40Du, i, (LPARAM)lParam);
      v14 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v6 = -1i64;
      v7 = lParam;
      do
      {
        if ( !v6 )
          break;
        v8 = *(_WORD *)v7 == 0;
        v7 = (LPARAM *)((char *)v7 + 2);
        --v6;
      }
      while ( !v8 );
      sub_1400099E0(Block, lParam, -v6 - 2);
      v9 = *(_QWORD *)(a1 + 24);
      v10 = sub_14000A760(v9, *(_QWORD *)(v9 + 8), Block);
      v11 = *(_QWORD *)(a1 + 32);
      if ( v11 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 32) = v11 + 1;
      *(_QWORD *)(v9 + 8) = v10;
      **((_QWORD **)v10 + 1) = v10;
      if ( v14 >= 8 )
        j_free(Block[0]);
    }
    *(_DWORD *)(a1 + 8) = v3;
    LODWORD(v12[0]) = -1;
    result = (void **)SendMessageW(*(HWND *)a1, 0x404u, 1ui64, (LPARAM)v12);
    *(_BYTE *)(a1 + 48) = 1;
  }
  return result;
}

//----- (00000001400795F0) ----------------------------------------------------
__int64 __fastcall sub_1400795F0(HMENU hMenu)
{
  unsigned int v2; // ebx

  v2 = 0;
  if ( GetMenuItemCount(hMenu) <= 0 )
    return 0xFFFFFFFFi64;
  while ( GetMenuItemID(hMenu, v2) != 40060 )
  {
    if ( (int)++v2 >= GetMenuItemCount(hMenu) )
      return 0xFFFFFFFFi64;
  }
  return v2;
}

//----- (0000000140079660) ----------------------------------------------------
__int64 __fastcall sub_140079660(const ITEMIDLIST *a1)
{
  int v1; // eax
  int v3; // [rsp+30h] [rbp+8h] BYREF
  void *ppv; // [rsp+38h] [rbp+10h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp+18h] BYREF

  v1 = 1610612736;
  v3 = 1610612736;
  if ( a1 )
  {
    ppv = 0i64;
    ppidlLast = 0i64;
    if ( SHBindToParent(a1, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
    {
      (*(void (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
        ppv,
        1i64,
        &ppidlLast,
        &v3);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    }
    v1 = v3;
  }
  if ( (v1 & 0x20000000) != 0 && (v1 & 0x40000000) != 0 )
    return 1i64;
  if ( (v1 & 0x20000000) == 0 || (v1 & 0x40000000) != 0 )
    return 2i64;
  return 0i64;
}

//----- (0000000140079700) ----------------------------------------------------
_QWORD *__fastcall sub_140079700(__int64 a1, __int64 a2, unsigned int a3)
{
  _QWORD *v3; // rcx
  _QWORD *result; // rax
  __int64 v7; // r8
  __int64 v8; // rdx
  __int64 *v9; // r8
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // [rsp+20h] [rbp-48h] BYREF
  __int64 v13; // [rsp+28h] [rbp-40h]
  __int64 v14; // [rsp+30h] [rbp-38h]
  __int64 v15; // [rsp+38h] [rbp-30h]
  __int64 v16; // [rsp+40h] [rbp-28h]
  int v17; // [rsp+48h] [rbp-20h]

  v3 = *(_QWORD **)(a1 + 24);
  for ( result = (_QWORD *)*v3; result != v3; result = (_QWORD *)*result )
  {
    v7 = result[2];
    v13 = result[3];
    v8 = result[4];
    v12 = v7;
    v9 = (__int64 *)result[5];
    v14 = v8;
    v10 = result[6];
    v16 = v10;
    if ( a3 >= (unsigned int)v10 && a3 < HIDWORD(v16) )
    {
      v15 = 0i64;
      v16 = 0i64;
      v14 = (unsigned __int8)(a3 - v10);
      v11 = *v9;
      v12 = 56i64;
      v13 = a2;
      v17 = 5;
      return (_QWORD *)(*(__int64 (__fastcall **)(__int64 *, __int64 *))(v11 + 32))(v9, &v12);
    }
  }
  return result;
}

//----- (00000001400797A0) ----------------------------------------------------
__int64 __fastcall sub_1400797A0(__int64 a1, unsigned int a2)
{
  _QWORD *v2; // rcx
  _QWORD *i; // rax
  __int64 v5; // r10
  __int64 v6; // rdx

  v2 = *(_QWORD **)(a1 + 24);
  for ( i = (_QWORD *)*v2; i != v2; i = (_QWORD *)*i )
  {
    v5 = i[5];
    v6 = i[6];
    if ( a2 >= (unsigned int)v6 && a2 < HIDWORD(v6) )
    {
      if ( v5 )
        return (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)v5 + 40i64))(
                 v5,
                 a2 - (unsigned int)v6,
                 5i64);
      return 2147500037i64;
    }
  }
  return 2147500037i64;
}

//----- (0000000140079830) ----------------------------------------------------
__int64 __fastcall sub_140079830(__int64 a1, unsigned int a2, HMENU a3, HMENU a4, __int64 a5)
{
  UINT MenuItemID; // er10
  char v6; // bp
  _QWORD *v11; // rcx
  _QWORD *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r11
  __int64 v16; // [rsp+50h] [rbp-18h]

  MenuItemID = -1;
  v6 = 0;
  switch ( a2 )
  {
    case 0x2Bu:
    case 0x2Cu:
      MenuItemID = *((_DWORD *)a4 + 2);
      break;
    case 0x117u:
      MenuItemID = GetMenuItemID(a3, 0);
      break;
    case 0x120u:
      v6 = 1;
      MenuItemID = GetMenuItemID(a4, 0);
      break;
  }
  if ( MenuItemID == -1 )
    return 2147500037i64;
  v11 = *(_QWORD **)(a1 + 24);
  v12 = (_QWORD *)*v11;
  if ( (_QWORD *)*v11 == v11 )
    return 2147500037i64;
  while ( 1 )
  {
    v13 = v12[2];
    v14 = v12[3];
    v16 = v12[6];
    if ( MenuItemID >= (unsigned int)v16 && MenuItemID < HIDWORD(v16) )
      break;
    v12 = (_QWORD *)*v12;
    if ( v12 == v11 )
      return 2147500037i64;
  }
  if ( v13 )
    return (*(__int64 (__fastcall **)(__int64, _QWORD, HMENU, HMENU, __int64))(*(_QWORD *)v13 + 56i64))(
             v13,
             a2,
             a3,
             a4,
             a5);
  if ( !v14 || v6 )
    return 2147500037i64;
  return (*(__int64 (__fastcall **)(__int64, _QWORD, HMENU, HMENU))(*(_QWORD *)v14 + 48i64))(v14, a2, a3, a4);
}

//----- (0000000140079960) ----------------------------------------------------
void __fastcall sub_140079960(HMENU hMenu)
{
  UINT *v2; // rdi
  UINT *v3; // rbx
  __int64 v4; // rbp
  bool v5; // si
  int v6; // er12
  bool v7; // r13
  __int64 v8; // rsi
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  UINT *v17; // [rsp+28h] [rbp-A0h] BYREF
  UINT *v18; // [rsp+30h] [rbp-98h]
  __int64 v19; // [rsp+38h] [rbp-90h]
  struct tagMENUITEMINFOW mii; // [rsp+50h] [rbp-78h] BYREF
  int i; // [rsp+D8h] [rbp+10h] BYREF

  v2 = 0i64;
  v17 = 0i64;
  v3 = 0i64;
  v18 = 0i64;
  v4 = 0i64;
  v19 = 0i64;
  v5 = 0;
  v6 = 0;
  for ( i = 0; v6 < GetMenuItemCount(hMenu); i = v6 )
  {
    mii.cbSize = 80;
    mii.fMask = 256;
    GetMenuItemInfoW(hMenu, v6, 1, &mii);
    v7 = (mii.fType & 0x800) != 0;
    if ( v5 && (mii.fType & 0x800) != 0 )
    {
      if ( &i >= (int *)v3 || v2 > (UINT *)&i )
      {
        if ( v3 == (UINT *)v4 )
        {
          v13 = v3 - v2;
          if ( v13 > 0x3FFFFFFFFFFFFFFEi64 )
            sub_14002B5F8("vector<T> too long");
          v14 = v13 + 1;
          v15 = (v4 - (__int64)v2) >> 2;
          if ( v14 > v15 )
          {
            if ( 0x3FFFFFFFFFFFFFFFi64 - (v15 >> 1) >= v15 )
              v16 = (v15 >> 1) + v15;
            else
              v16 = 0i64;
            if ( v16 < v14 )
              v16 = v14;
            sub_14001C6C0(&v17, v16);
            v4 = v19;
            v3 = v18;
            v2 = v17;
          }
        }
        if ( v3 )
          *v3 = v6;
      }
      else
      {
        v8 = ((char *)&i - (char *)v2) >> 2;
        if ( v3 == (UINT *)v4 )
        {
          v9 = v3 - v2;
          if ( v9 > 0x3FFFFFFFFFFFFFFEi64 )
            sub_14002B5F8("vector<T> too long");
          v10 = v9 + 1;
          v11 = (v4 - (__int64)v2) >> 2;
          if ( v10 > v11 )
          {
            if ( 0x3FFFFFFFFFFFFFFFi64 - (v11 >> 1) >= v11 )
              v12 = (v11 >> 1) + v11;
            else
              v12 = 0i64;
            if ( v12 < v10 )
              v12 = v10;
            sub_14001C6C0(&v17, v12);
            v4 = v19;
            v3 = v18;
            v2 = v17;
          }
        }
        if ( v3 )
          *v3 = v2[v8];
      }
      v18 = ++v3;
    }
    v5 = v7;
    ++v6;
  }
  while ( v3 != v2 )
    DeleteMenu(hMenu, *--v3, 0x400u);
  if ( v2 )
    j_free(v2);
}
// 14001C6C0: using guessed type __int64 __fastcall sub_14001C6C0(_QWORD, _QWORD);

//----- (0000000140079BD0) ----------------------------------------------------
void __fastcall sub_140079BD0(__int64 a1, HMENU a2)
{
  int v3; // esi
  int v5; // ebp
  int v6; // ebx
  UINT v7; // ebp
  _QWORD *v8; // rax
  _QWORD *v9; // rbx
  __int64 v10; // rcx
  int v11; // er12
  int v12; // eax
  MENUITEMINFOW mi; // [rsp+30h] [rbp-68h] BYREF

  v3 = 0;
  v5 = -1;
  v6 = 0;
  if ( GetMenuItemCount(a2) > 0 )
  {
    while ( GetMenuItemID(a2, v6) != 40060 )
    {
      if ( ++v6 >= GetMenuItemCount(a2) )
        goto LABEL_6;
    }
    v5 = v6;
  }
LABEL_6:
  mi.cbSize = 80;
  mi.fMask = 256;
  mi.fType = 2048;
  InsertMenuItemW(a2, v5 + 1, 1, &mi);
  v7 = v5 + 2;
  InsertMenuItemW(a2, v7, 1, &mi);
  v8 = *(_QWORD **)(a1 + 24);
  v9 = (_QWORD *)*v8;
  if ( (_QWORD *)*v8 != v8 )
  {
    do
    {
      v10 = v9[5];
      if ( v10 )
      {
        v11 = v3 + 1;
        v12 = (*(__int64 (__fastcall **)(__int64, HMENU, _QWORD, _QWORD, int, int))(*(_QWORD *)v10 + 24i64))(
                v10,
                a2,
                v7,
                (unsigned int)(v3 + 1),
                1000,
                4);
        if ( v12 >= 0 )
        {
          if ( (_WORD)v12 )
          {
            v3 += (unsigned __int16)v12;
            *((_DWORD *)v9 + 12) = v11;
            *((_DWORD *)v9 + 13) = v3 + 1;
            v7 = sub_1400795F0(a2) + 2;
          }
        }
      }
      v9 = (_QWORD *)*v9;
    }
    while ( v9 != *(_QWORD **)(a1 + 24) );
  }
  sub_140079960(a2);
}

//----- (000000014007A0F0) ----------------------------------------------------
LRESULT __fastcall sub_14007A0F0(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  __int64 v11; // [rsp+30h] [rbp-448h] BYREF
  __int64 lParama[128]; // [rsp+40h] [rbp-438h] BYREF

  if ( uMsg < 0x2B )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  if ( uMsg > 0x2C && uMsg != 279 )
  {
    if ( uMsg == 287 )
    {
      if ( WORD1(wParam) == 0xFFFF && !lParam )
      {
        sub_140079310(*(_QWORD *)(dwRefData + 56));
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      sub_140079430(*(_QWORD *)(dwRefData + 56));
      if ( (unsigned int)(unsigned __int16)wParam < *(_DWORD *)(dwRefData + 48)
        || (unsigned int)(unsigned __int16)wParam > *(_DWORD *)(dwRefData + 52)
        || (unsigned int)sub_1400797A0(dwRefData, (unsigned __int16)wParam) )
      {
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      SendMessageW(**(HWND **)(dwRefData + 56), 0x40Bu, 0i64, (LPARAM)lParama);
      return 0i64;
    }
    if ( uMsg != 288 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  if ( (int)sub_140079830(dwRefData, uMsg, (HMENU)wParam, (HMENU)lParam, (__int64)&v11) < 0 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  if ( uMsg == 279 )
    return 0i64;
  if ( uMsg == 44 || uMsg == 43 )
    return 1i64;
  else
    return v11;
}
// 14007A0F0: using guessed type LPARAM lParam[128];

//----- (000000014007A230) ----------------------------------------------------
char __fastcall sub_14007A230(DWORD_PTR dwRefData, HWND hWnd, HMENU hMenu, int *a4, __int64 a5)
{
  unsigned int v9; // ebx

  if ( !hMenu )
    return 0;
  *(_DWORD *)(dwRefData + 48) = 1;
  *(_QWORD *)(dwRefData + 56) = a5;
  *(_DWORD *)(dwRefData + 52) = 1000;
  sub_140079BD0(dwRefData, hMenu);
  SetWindowSubclass(hWnd, (SUBCLASSPROC)sub_14007A0F0, 1ui64, dwRefData);
  v9 = TrackPopupMenu(hMenu, 0x142u, *a4, a4[1], 0, hWnd, 0i64);
  RemoveWindowSubclass(hWnd, (SUBCLASSPROC)sub_14007A0F0, 1ui64);
  if ( v9 )
  {
    if ( v9 <= 0x3E8 )
    {
      sub_140079700(dwRefData, (__int64)hWnd, v9);
      return 1;
    }
    SendMessageW(hWnd, 0x111u, (unsigned __int16)v9, 0i64);
  }
  return 1;
}
// 14007A2D8: conditional instruction was optimized away because ebx.4!=0

//----- (000000014007A340) ----------------------------------------------------
__int64 __fastcall sub_14007A340(__int64 a1, _DWORD *a2)
{
  UINT v4; // edx
  HMENU v5; // rcx
  int v6; // esi
  HWND v8; // rcx
  HDC DC; // r14
  HDC CompatibleDC; // rax
  HDC v11; // r13
  void *StockObject; // rax
  void *v13; // r12
  int v14; // er11
  __int16 v15; // cx
  int v16; // eax
  DWORD TabbedTextExtentW; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int nTabStopPositions[4]; // [rsp+30h] [rbp-318h] BYREF
  struct tagMENUITEMINFOW mii; // [rsp+40h] [rbp-308h] BYREF
  int pvParam[56]; // [rsp+90h] [rbp-2B8h] BYREF
  LOGFONTW lf; // [rsp+170h] [rbp-1D8h] BYREF
  __int16 String[64]; // [rsp+290h] [rbp-B8h] BYREF

  if ( *a2 != 1 )
    return 1i64;
  v4 = a2[2];
  v5 = *(HMENU *)(a1 + 8);
  mii.cbSize = 80;
  mii.fMask = 256;
  GetMenuItemInfoW(v5, v4, 0, &mii);
  v6 = 0;
  if ( (mii.fType & 0x800) != 0 )
  {
    a2[3] = 0;
    a2[4] = 5;
    return 1i64;
  }
  else
  {
    v8 = *(HWND *)a1;
    nTabStopPositions[0] = 0;
    DC = GetDC(v8);
    CompatibleDC = CreateCompatibleDC(DC);
    pvParam[0] = 500;
    v11 = CompatibleDC;
    if ( SystemParametersInfoW(0x29u, 0x1F4u, pvParam, 0) )
      StockObject = CreateFontIndirectW(&lf);
    else
      StockObject = GetStockObject(13);
    v13 = StockObject;
    SelectObject(v11, StockObject);
    GetMenuStringW(*(HMENU *)(a1 + 8), a2[2], (LPWSTR)String, 64, 0);
    v14 = nTabStopPositions[0];
    v15 = String[nTabStopPositions[0]];
    if ( v15 )
    {
      do
      {
        if ( v15 == 9 )
          break;
        v15 = String[++v14];
      }
      while ( v15 );
      nTabStopPositions[0] = v14;
    }
    if ( String[v14] == 9 )
      v6 = 1;
    v16 = lstrlenW((LPCWSTR)String);
    TabbedTextExtentW = GetTabbedTextExtentW(v11, (LPCWSTR)String, v16, v6, nTabStopPositions);
    v18 = 20;
    v19 = (unsigned __int16)TabbedTextExtentW;
    v20 = HIWORD(TabbedTextExtentW) + 4;
    a2[3] = v19 + 22;
    if ( v20 > 20 )
      v18 = v20;
    a2[4] = v18;
    DeleteObject(v13);
    DeleteDC(v11);
    ReleaseDC(*(HWND *)a1, DC);
    return 1i64;
  }
}
// 14007A340: using guessed type INT nTabStopPositions[4];
// 14007A340: using guessed type int pvParam[56];
// 14007A340: using guessed type WCHAR String[64];

//----- (000000014007A580) ----------------------------------------------------
__int64 __fastcall sub_14007A580(__int64 a1)
{
  int v2; // er12
  int v3; // eax
  DWORD SysColor; // edi
  struct tagRECT *v5; // r13
  HBRUSH SolidBrush; // rbx
  LONG v7; // ecx
  LONG v8; // eax
  __int64 v9; // rcx
  __int64 v10; // rdi
  __int64 v11; // rbx
  DWORD v12; // eax
  HBRUSH v13; // rbx
  UINT MenuState; // ebx
  DWORD v15; // eax
  UINT v16; // edx
  HMENU v17; // rcx
  WCHAR v18; // ax
  WCHAR *v19; // r11
  __int16 *v20; // rcx
  bool v21; // zf
  int v22; // edx
  __int16 v23; // ax
  __int16 *v24; // r11
  __int16 *v25; // rcx
  int v26; // ebx
  int v27; // eax
  int v28; // eax
  __int64 v30; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v31; // [rsp+38h] [rbp-C8h] BYREF
  struct tagMENUITEMINFOW mii; // [rsp+40h] [rbp-C0h] BYREF
  struct tagRECT rc; // [rsp+90h] [rbp-70h] BYREF
  struct tagRECT v34; // [rsp+A0h] [rbp-60h] BYREF
  struct tagRECT v35; // [rsp+B0h] [rbp-50h] BYREF
  __int16 chText[64]; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v37[64]; // [rsp+140h] [rbp+40h] BYREF
  WCHAR String[64]; // [rsp+1C0h] [rbp+C0h] BYREF

  v2 = 0;
  if ( *(_DWORD *)a1 == 1 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    if ( (v3 & 1) != 0 || (v3 & 2) != 0 )
    {
      if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
      {
        SysColor = GetSysColor(29);
        v5 = (struct tagRECT *)(a1 + 40);
        SolidBrush = CreateSolidBrush(0);
        FrameRect(*(HDC *)(a1 + 32), (const RECT *)(a1 + 40), SolidBrush);
        DeleteObject(SolidBrush);
        v7 = *(_DWORD *)(a1 + 40);
        rc.top = *(_DWORD *)(a1 + 44);
        v8 = *(_DWORD *)(a1 + 48);
        rc.left = v7;
        rc.right = v8;
        rc.bottom = *(_DWORD *)(a1 + 52);
        InflateRect(&rc, -1, -1);
        v31 = 0i64;
        GdipCreateSolidFill(
          BYTE2(SysColor) | ((BYTE1(SysColor) | (((unsigned __int8)SysColor | 0x6400u) << 8)) << 8),
          &v31);
        v9 = *(_QWORD *)(a1 + 32);
        v10 = v31;
        v30 = 0i64;
        GdipCreateFromHDC(v9, &v30);
        v11 = v30;
        GdipFillRectangleI(v30, v10);
        GdipDeleteGraphics(v11);
        GdipDeleteBrush(v10);
      }
      else
      {
        v12 = GetSysColor(4);
        v5 = (struct tagRECT *)(a1 + 40);
        v13 = CreateSolidBrush(v12);
        FillRect(*(HDC *)(a1 + 32), (const RECT *)(a1 + 40), v13);
        DeleteObject(v13);
      }
      SetBkMode(*(HDC *)(a1 + 32), 1);
      MenuState = GetMenuState(*(HMENU *)(a1 + 24), *(_DWORD *)(a1 + 8), 0);
      if ( (MenuState & 1) != 0 )
      {
        v15 = GetSysColor(17);
        SetTextColor(*(HDC *)(a1 + 32), v15);
      }
      if ( (MenuState & 0x800) != 0 && (MenuState & 0x10) == 0 || MenuState == -1 )
      {
        rc = *v5;
        OffsetRect(&rc, 0, (rc.bottom - rc.top) / 2);
        DrawEdge(*(HDC *)(a1 + 32), &rc, 6u, 2u);
      }
      if ( (MenuState & 8) != 0 )
        ImageList_Draw(himl, 21, *(HDC *)(a1 + 32), v5->left + 2, *(_DWORD *)(a1 + 44) + 2, 0);
      v16 = *(_DWORD *)(a1 + 8);
      v17 = *(HMENU *)(a1 + 24);
      mii.cbSize = 80;
      mii.fMask = 32;
      GetMenuItemInfoW(v17, v16, 0, &mii);
      if ( *(_DWORD *)(mii.dwItemData + 4) )
        ImageList_Draw(himl, *(_DWORD *)mii.dwItemData, *(HDC *)(a1 + 32), v5->left + 2, *(_DWORD *)(a1 + 44) + 2, 0);
      GetMenuStringW(*(HMENU *)(a1 + 24), *(_DWORD *)(a1 + 8), String, 64, 0);
      v18 = String[0];
      v19 = String;
      if ( String[0] )
      {
        v20 = chText;
        do
        {
          if ( v18 == 9 )
            break;
          ++v19;
          *v20 = v18;
          ++v2;
          v18 = *v19;
          ++v20;
        }
        while ( *v19 );
      }
      v21 = *v19 == 9;
      v22 = 0;
      chText[v2] = 0;
      if ( v21 )
      {
        v23 = v19[1];
        v24 = (__int16 *)(v19 + 1);
        if ( v23 )
        {
          v25 = v37;
          do
          {
            ++v24;
            *v25 = v23;
            ++v22;
            v23 = *v24;
            ++v25;
          }
          while ( *v24 );
        }
      }
      v26 = *(_DWORD *)(a1 + 16);
      v37[v22] = 0;
      v35 = *v5;
      OffsetRect(&v35, 22, 0);
      v27 = lstrlenW((LPCWSTR)chText);
      DrawTextW(*(HDC *)(a1 + 32), (LPCWSTR)chText, v27, &v35, ((v26 & 0x100) << 12) | 0x64);
      v34 = *v5;
      InflateRect(&v34, -10, 0);
      v28 = lstrlenW((LPCWSTR)v37);
      DrawTextW(*(HDC *)(a1 + 32), (LPCWSTR)v37, v28, &v34, 0x100026u);
    }
  }
  return 1i64;
}
// 1400E3CE8: using guessed type double __fastcall GdipFillRectangleI(_QWORD, _QWORD);
// 1400E3CF0: using guessed type __int64 __fastcall GdipDeleteGraphics(_QWORD);
// 1400E3CF8: using guessed type __int64 __fastcall GdipCreateFromHDC(_QWORD, _QWORD);
// 1400E3D08: using guessed type __int64 __fastcall GdipDeleteBrush(_QWORD);
// 1400E3D10: using guessed type __int64 __fastcall GdipCreateSolidFill(_QWORD, _QWORD);
// 14007A580: using guessed type WCHAR chText[64];
// 14007A580: using guessed type WCHAR var_130[64];

//----- (000000014007A9F0) ----------------------------------------------------
_QWORD *__fastcall sub_14007A9F0(_QWORD *a1)
{
  sub_14001C460(a1);
  return a1;
}

//----- (000000014007B1C0) ----------------------------------------------------
void __fastcall sub_14007B1C0(__int64 *a1)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rax
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 *v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rdx
  void *v10; // rdi
  __int64 v11; // rax
  __int64 v12[3]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v13[4]; // [rsp+38h] [rbp-20h] BYREF

  if ( a1[4] )
  {
    v2 = sub_140028920(a1, v12);
    v3 = sub_14001C4E0((__int64)v2, v13);
    v4 = (_QWORD *)*v3;
    if ( *v3 )
      v4 = (_QWORD *)*v4;
    v5 = v3[2];
    v6 = v4[2];
    if ( v6 <= v5 )
      v5 -= v6;
    v7 = *(__int64 **)(v4[1] + 8 * v5);
    v8 = a1[4];
    v9 = *v7;
    v10 = (void *)v7[1];
    if ( v8 )
    {
      v11 = v8 - 1;
      a1[4] = v11;
      if ( !v11 )
        a1[3] = 0i64;
    }
    if ( !(_DWORD)v9 )
      sub_14007ADD0(a1, v10);
    j_free(v10);
  }
}
// 14007ADD0: using guessed type __int64 __fastcall sub_14007ADD0(_QWORD, _QWORD);
// 14007B1C0: using guessed type __int64 var_38[3];
// 14007B1C0: using guessed type __int64 var_20[4];

//----- (000000014007B260) ----------------------------------------------------
__int64 __fastcall sub_14007B260(_QWORD *a1, HWND a2, _QWORD **a3, int a4)
{
  __int64 result; // rax
  unsigned int v7; // ebx
  __int64 **v8; // rax
  __int64 v9[4]; // [rsp+28h] [rbp-20h] BYREF

  result = sub_1400D3500(a2, a3, a4);
  v7 = result;
  if ( (_DWORD)result )
  {
    v8 = (__int64 **)operator new(0x18ui64);
    v9[0] = (__int64)v8;
    if ( v8 )
      v8 = sub_14000B180(v8, (_QWORD ***)a3);
    LODWORD(v9[0]) = 3;
    v9[1] = (__int64)v8;
    sub_14001C1B0(a1, v9);
    return v7;
  }
  return result;
}

//----- (000000014007B2F0) ----------------------------------------------------
__int64 __fastcall sub_14007B2F0(HKEY a1, const WCHAR *a2, BYTE *lpData, DWORD a4)
{
  __int64 v5; // rdi
  unsigned int v6; // er11
  __int64 result; // rax
  int Type[6]; // [rsp+30h] [rbp-18h] BYREF
  DWORD cbData; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  cbData = a4;
  v6 = RegQueryValueExW(a1, a2, 0i64, (LPDWORD)Type, lpData, &cbData);
  if ( !cbData || Type[0] != 1 )
  {
    *(_WORD *)lpData = 0;
    return v6;
  }
  if ( !*(_WORD *)&lpData[2 * cbData - 2] )
    return v6;
  if ( cbData < (unsigned int)v5 )
    v5 = cbData;
  result = v6;
  *(_WORD *)&lpData[2 * v5] = 0;
  return result;
}
// 14007B2F0: using guessed type DWORD Type[6];

//----- (000000014007B370) ----------------------------------------------------
LSTATUS __fastcall sub_14007B370(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData)
{
  int v6; // eax

  v6 = lstrlenW((LPCWSTR)lpData);
  return RegSetValueExW(hKey, lpValueName, 0, 1u, lpData, 2 * v6);
}

//----- (000000014007B3D0) ----------------------------------------------------
LSTATUS __fastcall sub_14007B3D0(HKEY a1, const WCHAR *a2, BYTE *lpData)
{
  DWORD cbData; // [rsp+58h] [rbp+20h] BYREF

  cbData = 4;
  return RegQueryValueExW(a1, a2, 0i64, 0i64, lpData, &cbData);
}

//----- (000000014007B410) ----------------------------------------------------
LSTATUS __fastcall sub_14007B410(HKEY a1, const WCHAR *a2, int a3)
{
  int Data; // [rsp+50h] [rbp+18h] BYREF

  Data = a3;
  return RegSetValueExW(a1, a2, 0, 4u, (const BYTE *)&Data, 4u);
}

//----- (000000014007B450) ----------------------------------------------------
__int64 __fastcall sub_14007B450(HKEY hKey, __int64 a2, _QWORD **a3)
{
  _QWORD *v3; // rdi
  _QWORD *v5; // rbx
  int v7; // ebp
  const WCHAR *v8; // rsi
  int v9; // eax
  unsigned int v10; // esi
  BYTE *lpData; // [rsp+20h] [rbp-188h]
  LPCWSTR lpString[3]; // [rsp+30h] [rbp-178h] BYREF
  unsigned __int64 v14; // [rsp+48h] [rbp-160h]
  WCHAR ValueName[128]; // [rsp+60h] [rbp-148h] BYREF

  v3 = *a3;
  v5 = (_QWORD *)**a3;
  v7 = 0;
  if ( v5 == *a3 )
    return 0i64;
  while ( 1 )
  {
    v14 = 7i64;
    lpString[2] = 0i64;
    LOWORD(lpString[0]) = 0;
    sub_140009610(lpString, v5 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    LODWORD(lpData) = v7;
    sub_140001000(ValueName, 0x80ui64, L"%s%d", a2, lpData);
    ++v7;
    v8 = (const WCHAR *)lpString;
    if ( v14 >= 8 )
      v8 = lpString[0];
    v9 = lstrlenW(v8);
    v10 = RegSetValueExW(hKey, ValueName, 0, 1u, (const BYTE *)v8, 2 * v9);
    if ( v10 )
      break;
    if ( v14 >= 8 )
      j_free((void *)lpString[0]);
    v5 = (_QWORD *)*v5;
    if ( v5 == v3 )
      return 0i64;
  }
  if ( v14 >= 8 )
    j_free((void *)lpString[0]);
  return v10;
}
// 14007B4D1: variable 'lpData' is possibly undefined
// 1400EBA68: using guessed type wchar_t aSD_1[5];

//----- (000000014007B580) ----------------------------------------------------
__int64 __fastcall sub_14007B580(HKEY hKey, __int64 a2, __int64 *a3)
{
  int v6; // ebx
  unsigned int v7; // edi
  __int64 v8; // rcx
  __int64 v9; // rcx
  BYTE *v10; // rdi
  bool v11; // zf
  __int64 v12; // rdi
  char *v13; // rax
  __int64 v14; // rdx
  LPBYTE lpData; // [rsp+20h] [rbp-598h]
  DWORD cbData; // [rsp+30h] [rbp-588h] BYREF
  DWORD Type; // [rsp+34h] [rbp-584h] BYREF
  __int64 v19; // [rsp+38h] [rbp-580h]
  void *Block[3]; // [rsp+40h] [rbp-578h] BYREF
  unsigned __int64 v21; // [rsp+58h] [rbp-560h]
  WCHAR ValueName[128]; // [rsp+70h] [rbp-548h] BYREF
  BYTE Data[2]; // [rsp+170h] [rbp-448h] BYREF

  v19 = -2i64;
  v6 = 0;
  while ( 1 )
  {
    LODWORD(lpData) = v6;
    sub_140001000(ValueName, 0x80ui64, L"%s%d", a2, lpData);
    ++v6;
    cbData = 512;
    v7 = RegQueryValueExW(hKey, ValueName, 0i64, &Type, Data, &cbData);
    if ( cbData && Type == 1 )
    {
      if ( *(_WORD *)&Data[2 * cbData - 2] )
      {
        v8 = 512i64;
        if ( cbData < 0x200 )
          v8 = cbData;
        *(_WORD *)&Data[2 * v8] = 0;
      }
    }
    else
    {
      *(_WORD *)Data = 0;
    }
    if ( v7 )
      break;
    v21 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    v9 = -1i64;
    v10 = Data;
    do
    {
      if ( !v9 )
        break;
      v11 = *(_WORD *)v10 == 0;
      v10 += 2;
      --v9;
    }
    while ( !v11 );
    sub_1400099E0(Block, Data, -v9 - 2);
    v12 = *a3;
    v13 = sub_14000A760(*a3, *(_QWORD *)(*a3 + 8), Block);
    v14 = a3[1];
    if ( v14 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    a3[1] = v14 + 1;
    *(_QWORD *)(v12 + 8) = v13;
    **((_QWORD **)v13 + 1) = v13;
    if ( v21 >= 8 )
      j_free(Block[0]);
  }
  return v7;
}
// 14007B5E8: variable 'lpData' is possibly undefined
// 1400EBA78: using guessed type wchar_t aSD_2[5];

//----- (000000014007B740) ----------------------------------------------------
__int64 __fastcall sub_14007B740(HKEY a1, __int64 a2, void *a3)
{
  __int64 v4; // rbx
  __int64 v5; // rdi
  LSTATUS v6; // eax
  unsigned int v7; // esi
  __int64 v8; // rcx
  BYTE *v9; // rdi
  bool v10; // zf
  DWORD cbData; // [rsp+30h] [rbp-458h] BYREF
  DWORD Type; // [rsp+34h] [rbp-454h] BYREF
  __int64 v14; // [rsp+38h] [rbp-450h]
  __int64 v15; // [rsp+40h] [rbp-448h]
  BYTE Data[2]; // [rsp+50h] [rbp-438h] BYREF

  v14 = -2i64;
  v4 = a2;
  v15 = a2;
  if ( *(_QWORD *)(a2 + 24) >= 8ui64 )
    a2 = *(_QWORD *)a2;
  v5 = 512i64;
  cbData = 512;
  v6 = RegQueryValueExW(a1, (LPCWSTR)a2, 0i64, &Type, Data, &cbData);
  v7 = v6;
  if ( cbData && Type == 1 )
  {
    if ( *(_WORD *)&Data[2 * cbData - 2] )
    {
      if ( cbData < 0x200 )
        v5 = cbData;
      *(_WORD *)&Data[2 * v5] = 0;
    }
  }
  else
  {
    *(_WORD *)Data = 0;
  }
  if ( !v6 )
  {
    v8 = -1i64;
    v9 = Data;
    do
    {
      if ( !v8 )
        break;
      v10 = *(_WORD *)v9 == 0;
      v9 += 2;
      --v8;
    }
    while ( !v10 );
    sub_1400099E0(a3, Data, -v8 - 2);
  }
  if ( *(_QWORD *)(v4 + 24) >= 8ui64 )
    j_free(*(void **)v4);
  *(_QWORD *)(v4 + 24) = 7i64;
  *(_QWORD *)(v4 + 16) = 0i64;
  *(_WORD *)v4 = 0;
  return v7;
}

//----- (000000014007B860) ----------------------------------------------------
OLECHAR *__fastcall sub_14007B860(int a1)
{
  itow_s(a1, Buffer, 0x40ui64, 10);
  return Buffer;
}
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (000000014007B890) ----------------------------------------------------
_BOOL8 __fastcall sub_14007B890(const WCHAR *a1)
{
  return lstrcmpW(a1, L"yes") == 0;
}

//----- (000000014007B8E0) ----------------------------------------------------
__int64 __fastcall sub_14007B8E0(__int64 a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 result; // rax
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v2 = *a2;
  v4 = 0i64;
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64 *))(v2 + 168))(a2, a1, &v4);
  if ( v4 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 16i64))(v4);
  return result;
}

//----- (000000014007B920) ----------------------------------------------------
__int64 __fastcall sub_14007B920(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF
  __int64 v7; // [rsp+40h] [rbp+18h] BYREF

  v3 = *a1;
  v6 = 0i64;
  v7 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v3 + 392))(a1, a2, &v6);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a3 + 168i64))(a3, v6, &v7);
  if ( v6 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 16i64))(v6);
  v6 = 0i64;
  if ( v7 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
  return result;
}

//----- (000000014007B9A0) ----------------------------------------------------
VARIANTARG *__fastcall sub_14007B9A0(VARIANTARG *a1, const OLECHAR *a2)
{
  VariantInit(a1);
  a1->llVal = (LONGLONG)SysAllocString(a2);
  a1->vt = 8;
  return a1;
}

//----- (000000014007B9E0) ----------------------------------------------------
__int64 __fastcall sub_14007B9E0(__int64 *a1, __int64 *a2, const OLECHAR *a3, const OLECHAR *a4, OLECHAR *psz)
{
  OLECHAR *v9; // r13
  OLECHAR *v10; // rbx
  OLECHAR *v11; // rbx
  BSTR v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  OLECHAR *v15; // rbx
  __int64 v16; // rax
  __int64 v18; // [rsp+20h] [rbp-50h] BYREF
  __int64 v19; // [rsp+28h] [rbp-48h] BYREF
  VARIANTARG v20; // [rsp+30h] [rbp-40h] BYREF
  VARIANTARG pvarg; // [rsp+50h] [rbp-20h] BYREF
  __int64 v22; // [rsp+A0h] [rbp+30h] BYREF
  __int64 *v23; // [rsp+A8h] [rbp+38h] BYREF

  v22 = 0i64;
  v23 = 0i64;
  v18 = 0i64;
  v9 = SysAllocString(L"\n\t\t");
  v10 = SysAllocString(a3);
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a1 + 376))(a1, v10, &v22);
  SysFreeString(v10);
  sub_14007B920(a1, (__int64)v9, v22);
  v11 = SysAllocString(L"name");
  VariantInit(&pvarg);
  v12 = SysAllocString(a4);
  pvarg.vt = 8;
  v20.llVal = (LONGLONG)v12;
  v13 = *a1;
  *(_QWORD *)&v20.vt = *(_QWORD *)&pvarg.vt;
  v20.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v13 + 424))(a1, v11, &v23);
  v14 = *v23;
  pvarg = v20;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v14 + 360))(v23, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v22 + 384i64))(v22, v23, &v18);
  SysFreeString(v11);
  if ( v18 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16i64))(v18);
    v18 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v23 + 16))(v23);
  v23 = 0i64;
  VariantClear(&v20);
  v15 = SysAllocString(psz);
  (*(void (__fastcall **)(__int64, OLECHAR *))(*(_QWORD *)v22 + 216i64))(v22, v15);
  SysFreeString(v15);
  SysFreeString(v9);
  v16 = *a2;
  v19 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v16 + 168))(a2, v22, &v19);
  if ( v19 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v22 + 16i64))(v22);
}

//----- (000000014007BBA0) ----------------------------------------------------
LPVOID sub_14007BBA0()
{
  LPVOID ppv; // [rsp+40h] [rbp+8h] BYREF

  ppv = 0i64;
  if ( CoCreateInstance(&stru_1400F7B18, 0i64, 1u, &stru_1400F7B08, &ppv) >= 0 )
  {
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv + 504i64))(ppv, 0i64);
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv + 544i64))(ppv, 0i64);
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv + 560i64))(ppv, 0i64);
    (*(void (__fastcall **)(LPVOID, __int64))(*(_QWORD *)ppv + 576i64))(ppv, 0xFFFFFFFFi64);
  }
  return ppv;
}

//----- (000000014007BC30) ----------------------------------------------------
__int64 __fastcall sub_14007BC30(__int64 a1)
{
  unsigned __int8 v1; // di
  unsigned __int8 v2; // si
  unsigned __int8 v3; // bp
  int i; // ebx
  __int64 v6[7]; // [rsp+20h] [rbp-38h] BYREF
  int v7; // [rsp+60h] [rbp+8h] BYREF
  __int64 v8; // [rsp+68h] [rbp+10h] BYREF
  __int64 v9; // [rsp+70h] [rbp+18h] BYREF
  LPCWSTR lpString1; // [rsp+78h] [rbp+20h] BYREF

  v1 = 0;
  v9 = 0i64;
  v8 = 0i64;
  v2 = 0;
  v3 = 0;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 136i64))(a1, &v8);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v8 + 88i64))(v8, &v7);
  for ( i = 1; i < v7; ++i )
  {
    (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v8 + 80i64))(v8, (unsigned int)i, &v9);
    (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v9 + 56i64))(v9, &lpString1);
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v9 + 208i64))(v9, v6);
    if ( lstrcmpW(lpString1, &word_1400EA684) )
    {
      if ( lstrcmpW(lpString1, L"g") )
      {
        if ( !lstrcmpW(lpString1, L"b") )
          v3 = sub_14004B61C(v6[0]);
      }
      else
      {
        v2 = sub_14004B61C(v6[0]);
      }
    }
    else
    {
      v1 = sub_14004B61C(v6[0]);
    }
  }
  return v1 | (v3 << 16) | (v2 << 8);
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 14007BC30: using guessed type __int64 var_38[7];

//----- (000000014007BD50) ----------------------------------------------------
__int64 __fastcall sub_14007BD50(__int64 *a1, _QWORD *a2, __int64 *a3, const OLECHAR *a4, OLECHAR *psz)
{
  OLECHAR *v8; // rbx
  OLECHAR *v9; // rbx
  BSTR v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 result; // rax
  VARIANTARG v16; // [rsp+20h] [rbp-40h] BYREF
  VARIANTARG pvarg; // [rsp+40h] [rbp-20h] BYREF
  __int64 *v18; // [rsp+90h] [rbp+30h] BYREF
  __int64 v19; // [rsp+98h] [rbp+38h] BYREF
  __int64 v20; // [rsp+A0h] [rbp+40h] BYREF

  v18 = 0i64;
  v19 = 0i64;
  v8 = SysAllocString(a4);
  (*(void (__fastcall **)(__int64 *, OLECHAR *, _QWORD *))(*a1 + 376))(a1, v8, a2);
  SysFreeString(v8);
  v9 = SysAllocString(L"name");
  VariantInit(&pvarg);
  v10 = SysAllocString(psz);
  pvarg.vt = 8;
  v16.llVal = (LONGLONG)v10;
  v11 = *a1;
  *(_QWORD *)&v16.vt = *(_QWORD *)&pvarg.vt;
  v16.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v11 + 424))(a1, v9, &v18);
  v12 = *v18;
  pvarg = v16;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v12 + 360))(v18, &pvarg);
  (*(void (__fastcall **)(_QWORD, __int64 *, __int64 *))(*(_QWORD *)*a2 + 384i64))(*a2, v18, &v19);
  SysFreeString(v9);
  if ( v19 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
    v19 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
  v18 = 0i64;
  VariantClear(&v16);
  v13 = *a3;
  v14 = *a2;
  v20 = 0i64;
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64 *))(v13 + 168))(a3, v14, &v20);
  if ( v20 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v20 + 16i64))(v20);
  return result;
}

//----- (000000014007BEA0) ----------------------------------------------------
HRESULT __fastcall sub_14007BEA0(__int64 *a1, __int64 a2, const OLECHAR *a3, const OLECHAR *a4)
{
  OLECHAR *v7; // rsi
  BSTR v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  VARIANTARG v12; // [rsp+20h] [rbp-40h] BYREF
  VARIANTARG pvarg; // [rsp+40h] [rbp-20h] BYREF
  __int64 *v14; // [rsp+90h] [rbp+30h] BYREF
  __int64 v15; // [rsp+98h] [rbp+38h] BYREF

  v14 = 0i64;
  v15 = 0i64;
  v7 = SysAllocString(a3);
  VariantInit(&pvarg);
  v8 = SysAllocString(a4);
  pvarg.vt = 8;
  v12.llVal = (LONGLONG)v8;
  v9 = *a1;
  *(_QWORD *)&v12.vt = *(_QWORD *)&pvarg.vt;
  v12.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v9 + 424))(a1, v7, &v14);
  v10 = *v14;
  pvarg = v12;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v10 + 360))(v14, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a2 + 384i64))(a2, v14, &v15);
  SysFreeString(v7);
  if ( v15 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
    v15 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v14 + 16))(v14);
  v14 = 0i64;
  return VariantClear(&v12);
}

//----- (000000014007BFA0) ----------------------------------------------------
HFONT __fastcall sub_14007BFA0(__int64 *a1)
{
  __int64 v1; // rax
  int i; // ebx
  __int64 v3; // rdx
  signed __int64 v4; // r8
  WCHAR *lfFaceName; // rcx
  WCHAR v6; // ax
  LPCWSTR v8; // [rsp+20h] [rbp-49h] BYREF
  LPCWSTR lpString1; // [rsp+28h] [rbp-41h] BYREF
  int v10; // [rsp+30h] [rbp-39h] BYREF
  __int64 v11; // [rsp+38h] [rbp-31h] BYREF
  __int64 v12; // [rsp+40h] [rbp-29h] BYREF
  LOGFONTW lf; // [rsp+50h] [rbp-19h] BYREF

  v1 = *a1;
  v12 = 0i64;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *))(v1 + 136))(a1, &v11);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 88i64))(v11, &v10);
  for ( i = 1; i < v10; ++i )
  {
    (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v11 + 80i64))(v11, (unsigned int)i, &v12);
    (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v12 + 56i64))(v12, &lpString1);
    (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v12 + 208i64))(v12, &v8);
    if ( lstrcmpW(lpString1, L"Height") )
    {
      if ( lstrcmpW(lpString1, L"Width") )
      {
        if ( lstrcmpW(lpString1, L"Weight") )
        {
          if ( lstrcmpW(lpString1, L"Italic") )
          {
            if ( lstrcmpW(lpString1, L"Underline") )
            {
              if ( lstrcmpW(lpString1, L"Strikeout") )
              {
                if ( !lstrcmpW(lpString1, L"Font") )
                {
                  v3 = 32i64;
                  v4 = (char *)v8 - (char *)lf.lfFaceName;
                  lfFaceName = lf.lfFaceName;
                  while ( v3 != -2147483614 )
                  {
                    v6 = *(WCHAR *)((char *)lfFaceName + v4);
                    if ( !v6 )
                      break;
                    *lfFaceName++ = v6;
                    if ( !--v3 )
                    {
                      --lfFaceName;
                      break;
                    }
                  }
                  *lfFaceName = 0;
                }
              }
              else
              {
                lf.lfStrikeOut = lstrcmpW(v8, L"yes") == 0;
              }
            }
            else
            {
              lf.lfUnderline = lstrcmpW(v8, L"yes") == 0;
            }
          }
          else
          {
            lf.lfItalic = lstrcmpW(v8, L"yes") == 0;
          }
        }
        else
        {
          lf.lfWeight = sub_14004B61C(v8);
        }
      }
      else
      {
        lf.lfWidth = sub_14004B61C(v8);
      }
    }
    else
    {
      lf.lfHeight = sub_14004B61C(v8);
    }
  }
  lf.lfWeight = 500;
  lf.lfCharSet = 1;
  *(_QWORD *)&lf.lfEscapement = 0i64;
  *(_DWORD *)&lf.lfOutPrecision = 822214656;
  return CreateFontIndirectW(&lf);
}
// 14007C187: conditional instruction was optimized away because rdx.8!=0
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (000000014007C1F0) ----------------------------------------------------
unsigned int *__fastcall sub_14007C1F0(unsigned int *a1, __int64 *a2)
{
  __int64 v3; // rax
  unsigned __int8 v4; // di
  unsigned __int8 v5; // si
  unsigned __int8 v6; // bp
  int i; // ebx
  unsigned int *result; // rax
  __int64 v9[7]; // [rsp+20h] [rbp-38h] BYREF
  int v10; // [rsp+60h] [rbp+8h] BYREF
  __int64 v11; // [rsp+68h] [rbp+10h] BYREF
  __int64 v12; // [rsp+70h] [rbp+18h] BYREF
  LPCWSTR lpString1; // [rsp+78h] [rbp+20h] BYREF

  v12 = 0i64;
  v11 = 0i64;
  v3 = *a2;
  *a1 = -16777216;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  (*(void (__fastcall **)(__int64 *, __int64 *))(v3 + 136))(a2, &v11);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 88i64))(v11, &v10);
  for ( i = 1; i < v10; ++i )
  {
    (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v11 + 80i64))(v11, (unsigned int)i, &v12);
    (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v12 + 56i64))(v12, &lpString1);
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v12 + 208i64))(v12, v9);
    if ( lstrcmpW(lpString1, &word_1400EA6EC) )
    {
      if ( lstrcmpW(lpString1, &word_1400EA6FC) )
      {
        if ( !lstrcmpW(lpString1, &word_1400EA71C) )
          v6 = sub_14004B61C(v9[0]);
      }
      else
      {
        v5 = sub_14004B61C(v9[0]);
      }
    }
    else
    {
      v4 = sub_14004B61C(v9[0]);
    }
  }
  result = a1;
  *a1 = v6 | ((v5 | ((v4 | 0xFFFFFF00) << 8)) << 8);
  return result;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 14007C1F0: using guessed type __int64 var_38[7];

//----- (000000014007C330) ----------------------------------------------------
void __fastcall sub_14007C330(__int64 *a1, __int64 a2, __int64 a3, _QWORD **a4)
{
  int v7; // esi
  _QWORD *v8; // rdi
  _QWORD *v9; // rbx
  void **v10; // r9
  __int64 v11; // [rsp+20h] [rbp-108h]
  void *Block[3]; // [rsp+38h] [rbp-F0h] BYREF
  unsigned __int64 v13; // [rsp+50h] [rbp-D8h]
  __int16 v14[64]; // [rsp+60h] [rbp-C8h] BYREF

  v7 = 0;
  v8 = *a4;
  v9 = (_QWORD *)**a4;
  if ( v9 != *a4 )
  {
    do
    {
      v13 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      sub_140009610(Block, v9 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      LODWORD(v11) = v7;
      sub_140001000((wchar_t *)v14, 0x40ui64, L"%s%d", a3, v11);
      ++v7;
      v10 = Block;
      if ( v13 >= 8 )
        v10 = (void **)Block[0];
      sub_14007BEA0(a1, a2, (const OLECHAR *)v14, (const OLECHAR *)v10);
      if ( v13 >= 8 )
        j_free(Block[0]);
      v9 = (_QWORD *)*v9;
    }
    while ( v9 != v8 );
  }
}
// 14007C3C2: variable 'v11' is possibly undefined
// 1400EBD68: using guessed type wchar_t aSD_3[5];
// 14007C330: using guessed type OLECHAR var_C8[64];

//----- (000000014007C470) ----------------------------------------------------
void __fastcall sub_14007C470(__int64 a1, __int64 a2, int a3)
{
  unsigned int v3; // edi
  __int64 v7[5]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v8; // [rsp+50h] [rbp+8h] BYREF
  LPCWSTR lpString1; // [rsp+68h] [rbp+20h] BYREF

  v3 = 1;
  v7[0] = 0i64;
  if ( a3 > 1 )
  {
    while ( 1 )
    {
      (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)a2 + 80i64))(a2, v3, v7);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v7[0] + 56i64))(v7[0], &lpString1);
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v7[0] + 208i64))(v7[0], &v8);
      if ( !*(_BYTE *)(a1 + 540) )
        break;
      if ( lstrcmpiW(lpString1, L"PosX") )
      {
        if ( lstrcmpiW(lpString1, L"PosY") )
        {
          if ( lstrcmpiW(lpString1, L"Width") )
          {
            if ( lstrcmpiW(lpString1, L"Height") )
              break;
            *(_DWORD *)(a1 + 24) = sub_14004B61C(v8);
          }
          else
          {
            *(_DWORD *)(a1 + 20) = sub_14004B61C(v8);
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) = sub_14004B61C(v8);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 12) = sub_14004B61C(v8);
      }
LABEL_12:
      if ( (int)++v3 >= a3 )
      {
        *(_DWORD *)(a1 + 8) = 1;
        return;
      }
    }
    (*(void (__fastcall **)(__int64, LPCWSTR, __int64))(*(_QWORD *)a1 + 32i64))(a1, lpString1, v8);
    goto LABEL_12;
  }
  *(_DWORD *)(a1 + 8) = 1;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 14007C470: using guessed type __int64 var_28[5];

//----- (000000014007C5C0) ----------------------------------------------------
LSTATUS __fastcall sub_14007C5C0(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  HKEY v4; // rcx
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  DWORD lpcbData; // [rsp+50h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+58h] [rbp+20h] BYREF

  result = RegOpenKeyExW(a2, (LPCWSTR)(a1 + 28), 0, 0x20019u, &hKey);
  if ( !result )
  {
    if ( *(_BYTE *)(a1 + 540) )
    {
      cbData = 8;
      RegQueryValueExW(hKey, L"Position", 0i64, 0i64, (LPBYTE)(a1 + 12), &cbData);
      lpcbData = 4;
      RegQueryValueExW(hKey, L"Width", 0i64, 0i64, (LPBYTE)(a1 + 20), &lpcbData);
      lpcbData = 4;
      RegQueryValueExW(hKey, L"Height", 0i64, 0i64, (LPBYTE)(a1 + 24), &lpcbData);
    }
    (*(void (__fastcall **)(__int64, HKEY))(*(_QWORD *)a1 + 16i64))(a1, hKey);
    v4 = hKey;
    *(_DWORD *)(a1 + 8) = 1;
    return RegCloseKey(v4);
  }
  return result;
}

//----- (000000014007C6D0) ----------------------------------------------------
LSTATUS __fastcall sub_14007C6D0(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  int Data; // [rsp+60h] [rbp+8h] BYREF
  DWORD dwDisposition; // [rsp+70h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+78h] [rbp+20h] BYREF

  result = (int)a2;
  if ( *(_DWORD *)(a1 + 8) )
  {
    result = RegCreateKeyExW(a2, (LPCWSTR)(a1 + 28), 0, 0i64, 0, 0x20006u, 0i64, &hKey, &dwDisposition);
    if ( !result )
    {
      if ( *(_BYTE *)(a1 + 540) )
      {
        RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)(a1 + 12), 8u);
        Data = *(_DWORD *)(a1 + 20);
        RegSetValueExW(hKey, L"Width", 0, 4u, (const BYTE *)&Data, 4u);
        Data = *(_DWORD *)(a1 + 24);
        RegSetValueExW(hKey, L"Height", 0, 4u, (const BYTE *)&Data, 4u);
      }
      (*(void (__fastcall **)(__int64, HKEY))(*(_QWORD *)a1 + 8i64))(a1, hKey);
      return RegCloseKey(hKey);
    }
  }
  return result;
}

//----- (000000014007C820) ----------------------------------------------------
__int64 __fastcall sub_14007C820(_DWORD *a1, HWND a2)
{
  LONG left; // er11
  LONG top; // edx
  LONG right; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetWindowRect(a2, &Rect);
  left = Rect.left;
  top = Rect.top;
  right = Rect.right;
  a1[3] = Rect.left;
  a1[4] = top;
  a1[5] = right - left;
  result = (unsigned int)(Rect.bottom - top);
  a1[6] = result;
  return result;
}

//----- (000000014007C890) ----------------------------------------------------
void __fastcall sub_14007C890(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rax
  __int64 v7; // [rsp+40h] [rbp+8h] BYREF

  if ( *(_DWORD *)(a1 + 8) )
  {
    v7 = 0i64;
    v6 = SysAllocString(L"\n\t\t");
    sub_14007B920(a2, (__int64)v6, (__int64)a3);
    sub_14007BD50(a2, &v7, a3, L"DialogState", (OLECHAR *)(a1 + 28));
    if ( *(_BYTE *)(a1 + 540) )
    {
      itow_s(*(_DWORD *)(a1 + 12), Buffer, 0x40ui64, 10);
      sub_14007BEA0(a2, v7, L"PosX", Buffer);
      itow_s(*(_DWORD *)(a1 + 16), Buffer, 0x40ui64, 10);
      sub_14007BEA0(a2, v7, L"PosY", Buffer);
      itow_s(*(_DWORD *)(a1 + 20), Buffer, 0x40ui64, 10);
      sub_14007BEA0(a2, v7, L"Width", Buffer);
      itow_s(*(_DWORD *)(a1 + 24), Buffer, 0x40ui64, 10);
      sub_14007BEA0(a2, v7, L"Height", Buffer);
    }
    (*(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)a1 + 24i64))(a1, a2, v7);
  }
}
// 1400EBE90: using guessed type wchar_t aDialogstate[12];
// 1400EBEA8: using guessed type wchar_t aPosx_0[5];
// 1400EBEB8: using guessed type wchar_t aPosy_0[5];
// 1400EBEC8: using guessed type wchar_t aWidth_3[6];
// 1400EBED8: using guessed type wchar_t aHeight_3[7];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (000000014007CA00) ----------------------------------------------------
BOOL __fastcall sub_14007CA00(_DWORD *a1, HWND a2, char a3)
{
  int v4; // er9
  bool v5; // zf
  int v6; // er8
  HWND Parent; // rax

  if ( a1[2] )
  {
    v4 = a1[4];
    v5 = a3 == 0;
    v6 = a1[3];
    if ( v5 )
      return SetWindowPos(a2, 0i64, v6, v4, 0, 0, 5u);
    else
      return SetWindowPos(a2, 0i64, v6, v4, a1[5], a1[6], 4u);
  }
  else
  {
    Parent = GetParent(a2);
    return sub_140081E00(Parent, a2);
  }
}

//----- (000000014007CB00) ----------------------------------------------------
LRESULT __fastcall sub_14007CB00(HWND a1, int a2)
{
  int v4; // eax
  unsigned int v5; // eax

  v4 = SendMessageW(a1, 0x1037u, 0i64, 0i64);
  if ( a2 )
    v5 = v4 | 0x20;
  else
    v5 = v4 & 0xFFFFFFDF;
  return SendMessageW(a1, 0x1036u, 0i64, v5);
}

//----- (000000014007CB60) ----------------------------------------------------
__int64 __fastcall sub_14007CB60(HWND hWnd, int cx, int a3)
{
  struct tagRECT Rect; // [rsp+40h] [rbp-38h] BYREF

  GetWindowRect(hWnd, &Rect);
  SetWindowPos(hWnd, 0i64, 0, Rect.top + a3 - Rect.bottom, cx, 24, 4u);
  return 0i64;
}

//----- (000000014007CBE0) ----------------------------------------------------
HWND __fastcall sub_14007CBE0(HWND hWndParent)
{
  DWORD v1; // edi
  HMODULE hInstance; // rax
  HWND Window; // rbx
  HFONT FontW; // rax

  v1 = dwStyle;
  hInstance = GetModuleHandleW(0i64);
  Window = CreateWindowExW(0, L"SysTabControl32", &WindowName, v1, 0, 0, 0, 0, hWndParent, 0i64, hInstance, 0i64);
  FontW = CreateFontW(15, 0, 0, 0, 500, 0, 0, 0, 0, 0, 0, 2u, 0, 0i64);
  SendMessageW(Window, 0x30u, (WPARAM)FontW, 1i64);
  return Window;
}

//----- (000000014007CCC0) ----------------------------------------------------
HWND __fastcall sub_14007CCC0(HWND hWndParent)
{
  HMODULE hInstance; // rax

  hInstance = GetModuleHandleW(0i64);
  return CreateWindowExW(
           0x80u,
           L"ComboBoxEx32",
           &word_1400EA7EC,
           0x56010042u,
           0,
           0,
           0,
           200,
           hWndParent,
           0i64,
           hInstance,
           0i64);
}

//----- (000000014007CD30) ----------------------------------------------------
HWND __fastcall sub_14007CD30(HWND hWndParent, DWORD dwStyle, LPARAM lParam)
{
  unsigned int v4; // esi
  HMODULE hInstance; // rax
  HWND result; // rax
  HWND v8; // rbx

  v4 = lParam;
  hInstance = GetModuleHandleW(0i64);
  result = CreateWindowExW(
             0,
             L"ToolbarWindow32",
             &word_1400EA7B4,
             dwStyle,
             0,
             0,
             0,
             0,
             hWndParent,
             0i64,
             hInstance,
             0i64);
  v8 = result;
  if ( result )
  {
    SendMessageW(result, 0x454u, 0i64, v4);
    return v8;
  }
  return result;
}

//----- (000000014007CDD0) ----------------------------------------------------
HWND __fastcall sub_14007CDD0(HWND hWndParent)
{
  DWORD v1; // edi
  HMODULE hInstance; // rax

  v1 = dword_14011FC14;
  hInstance = GetModuleHandleW(0i64);
  return CreateWindowExW(0, L"msctls_statusbar32", &word_1400EA78C, v1, 0, 0, 0, 0, hWndParent, 0i64, hInstance, 0i64);
}

//----- (000000014007CE40) ----------------------------------------------------
HWND __fastcall sub_14007CE40(HWND hWndParent)
{
  HMODULE hInstance; // rax
  HWND Window; // rbx
  HIMAGELIST phimlSmall; // [rsp+78h] [rbp+10h] BYREF

  hInstance = GetModuleHandleW(0i64);
  Window = CreateWindowExW(
             0,
             L"SysTreeView32",
             &word_1400EA76C,
             0x5000022Bu,
             0,
             0,
             0,
             0,
             hWndParent,
             0i64,
             hInstance,
             0i64);
  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(Window, 0x1109u, 0i64, (LPARAM)phimlSmall);
  return Window;
}

//----- (000000014007CED0) ----------------------------------------------------
HWND __fastcall sub_14007CED0(HWND hWndParent)
{
  HMODULE hInstance; // rax
  HWND Window; // rbx

  hInstance = GetModuleHandleW(0i64);
  Window = CreateWindowExW(
             0,
             L"SysListView32",
             &word_1400EA74C,
             0x56010348u,
             0,
             0,
             0,
             0,
             hWndParent,
             0i64,
             hInstance,
             0i64);
  SendMessageW(Window, 0x1036u, 0i64, 66560i64);
  return Window;
}

//----- (000000014007CF50) ----------------------------------------------------
int __fastcall sub_14007CF50(HWND hWnd, LPWSTR pszPath)
{
  __int64 v4; // r11
  WCHAR *v5; // rcx
  WCHAR v6; // ax
  HANDLE FirstFileW; // rax
  void *v8; // rbx
  HIMAGELIST phimlSmall; // [rsp+30h] [rbp-D0h] BYREF
  LPARAM lParam[3]; // [rsp+38h] [rbp-C8h] BYREF
  int v12; // [rsp+50h] [rbp-B0h]
  int iIcon; // [rsp+54h] [rbp-ACh]
  int v14; // [rsp+58h] [rbp-A8h]
  int v15; // [rsp+5Ch] [rbp-A4h]
  int v16; // [rsp+60h] [rbp-A0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+70h] [rbp-90h] BYREF
  SHFILEINFOW psfi; // [rsp+2C0h] [rbp+1C0h] BYREF
  WCHAR pszPatha[264]; // [rsp+580h] [rbp+480h] BYREF

  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(hWnd, 0x402u, 0i64, (LPARAM)phimlSmall);
  SendMessageW(hWnd, 0x14Bu, 0i64, 0i64);
  v4 = 260i64;
  v5 = pszPatha;
  while ( v4 != -2147483386 )
  {
    v6 = *(WCHAR *)((char *)v5 + (char *)pszPath - (char *)pszPatha);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  PathAppendW(pszPatha, &pszMore);
  FirstFileW = FindFirstFileW(pszPatha, &FindFileData);
  v8 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    if ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      do
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 && StrCmpW(FindFileData.cFileName, L"..") )
        {
          PathAppendW(pszPath, FindFileData.cFileName);
          SHGetFileInfoW(pszPath, 0, &psfi, 0, 0x4000u);
          PathRemoveFileSpecW(pszPath);
          iIcon = psfi.iIcon;
          v14 = psfi.iIcon;
          LODWORD(lParam[0]) = 23;
          lParam[1] = -1i64;
          v16 = 1;
          lParam[2] = (LPARAM)FindFileData.cFileName;
          v15 = 1;
          v12 = lstrlenW(FindFileData.cFileName);
          SendMessageW(hWnd, 0x40Bu, 0i64, (LPARAM)lParam);
        }
      }
      while ( FindNextFileW(v8, &FindFileData) );
    }
    LODWORD(FirstFileW) = FindClose(v8);
  }
  return (int)FirstFileW;
}
// 14007CFF6: conditional instruction was optimized away because r11.8!=0

//----- (000000014007D150) ----------------------------------------------------
void __fastcall sub_14007D150(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 *i; // rdi
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rcx

  if ( !*(_DWORD *)(a2 + 1540) )
  {
    v4 = *(_QWORD *)(a2 + 2088);
    for ( i = (__int64 *)(v4 + 2080); *i; i = (__int64 *)(*i + 2080) )
    {
      sub_14007D150(a1, v4);
      v4 = *i;
    }
  }
  v6 = *(_QWORD *)(a2 + 2072);
  v7 = *(_QWORD *)(a2 + 2080);
  if ( v6 )
  {
    *(_QWORD *)(v6 + 2080) = v7;
    v9 = *(_QWORD *)(a2 + 2080);
    if ( v9 )
      *(_QWORD *)(v9 + 2072) = *(_QWORD *)(a2 + 2072);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a2 + 2064) + 2088i64) = v7;
    v8 = *(_QWORD *)(a2 + 2080);
    if ( v8 )
    {
      *(_QWORD *)(v8 + 2072) = 0i64;
      free((void *)a2);
      return;
    }
  }
  free((void *)a2);
}

//----- (000000014007D240) ----------------------------------------------------
__int64 __fastcall sub_14007D240(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r11
  __int64 v4; // rbp
  char *v5; // rcx
  __int64 v6; // rdx
  __int16 v7; // ax
  _WORD *v8; // r9
  __int64 v9; // rsi
  __int64 v10; // rdx
  char *v11; // rcx
  __int16 v12; // ax
  _WORD *v13; // r10
  __int64 v14; // rdi
  char *v15; // rcx
  __int64 v16; // rdx
  __int16 v17; // ax
  _DWORD *v18; // r12
  _QWORD *v19; // r13
  _DWORD *v20; // rbx
  _QWORD *v21; // r14
  int v22; // er15
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int16 v26; // ax
  char *v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int16 v30; // ax
  char *v31; // rcx
  __int64 v32; // r8
  __int64 v33; // r9
  __int16 v34; // ax
  int *v35; // r9
  int *v36; // r10
  _QWORD *v37; // rbx
  _QWORD *v38; // r12
  char *v39; // r8
  __int16 v40; // ax
  char *v41; // r8
  __int16 v42; // ax
  char *v43; // rdx
  __int16 v44; // ax
  int v45; // eax
  __int64 result; // rax
  char v47[512]; // [rsp+0h] [rbp-878h] BYREF
  char v48[1024]; // [rsp+200h] [rbp-678h] BYREF
  int v49; // [rsp+600h] [rbp-278h]
  int v50; // [rsp+604h] [rbp-274h]
  char v51[520]; // [rsp+608h] [rbp-270h] BYREF
  __int64 v52; // [rsp+810h] [rbp-68h]
  __int64 v53; // [rsp+828h] [rbp-50h]

  v2 = *(_QWORD *)(a1 + 2064);
  v3 = *(_QWORD *)(a2 + 2064);
  v4 = 256i64;
  v5 = v47;
  v6 = 256i64;
  while ( v6 != -2147483390 )
  {
    v7 = *(_WORD *)&v5[v2 - (_QWORD)v47];
    if ( !v7 )
      break;
    *(_WORD *)v5 = v7;
    v5 += 2;
    if ( !--v6 )
    {
      v5 -= 2;
      break;
    }
  }
  v8 = (_WORD *)(v2 + 512);
  v9 = 512i64;
  *(_WORD *)v5 = 0;
  v10 = 512i64;
  v11 = v48;
  while ( v10 != -2147483134 )
  {
    v12 = *(_WORD *)&v11[v2 + 512 - (_QWORD)v48];
    if ( !v12 )
      break;
    *(_WORD *)v11 = v12;
    v11 += 2;
    if ( !--v10 )
    {
      v11 -= 2;
      break;
    }
  }
  v13 = (_WORD *)(v2 + 1544);
  v14 = 260i64;
  *(_WORD *)v11 = 0;
  v15 = v51;
  v16 = 260i64;
  while ( v16 != -2147483386 )
  {
    v17 = *(_WORD *)&v15[v2 + 1544 - (_QWORD)v51];
    if ( !v17 )
      break;
    *(_WORD *)v15 = v17;
    v15 += 2;
    if ( !--v16 )
    {
      v15 -= 2;
      break;
    }
  }
  *(_WORD *)v15 = 0;
  v18 = (_DWORD *)(v2 + 1540);
  v19 = (_QWORD *)(v2 + 2064);
  v20 = (_DWORD *)(v2 + 1536);
  v21 = (_QWORD *)(v2 + 2088);
  v22 = *(_DWORD *)(v2 + 1536);
  v50 = *(_DWORD *)(v2 + 1540);
  v52 = *(_QWORD *)(v2 + 2064);
  v23 = *(_QWORD *)(v2 + 2088);
  v49 = v22;
  v24 = 256i64;
  v25 = v3 - v2;
  v53 = v23;
  while ( v24 != -2147483390 )
  {
    v26 = *(_WORD *)(v25 + v2);
    if ( !v26 )
      break;
    *(_WORD *)v2 = v26;
    v2 += 2i64;
    if ( !--v24 )
    {
      v2 -= 2i64;
      break;
    }
  }
  v27 = (char *)(v3 + 512);
  v28 = 512i64;
  *(_WORD *)v2 = 0;
  v29 = v3 + 512 - (_QWORD)v8;
  while ( v28 != -2147483134 )
  {
    v30 = *(_WORD *)((char *)v8 + v29);
    if ( !v30 )
      break;
    *v8++ = v30;
    if ( !--v28 )
    {
      --v8;
      break;
    }
  }
  v31 = (char *)(v3 + 1544);
  v32 = 260i64;
  *v8 = 0;
  v33 = v3 + 1544 - (_QWORD)v13;
  while ( v32 != -2147483386 )
  {
    v34 = *(_WORD *)((char *)v13 + v33);
    if ( !v34 )
      break;
    *v13++ = v34;
    if ( !--v32 )
    {
      --v13;
      break;
    }
  }
  v35 = (int *)(v3 + 1536);
  *v13 = 0;
  v36 = (int *)(v3 + 1540);
  *v20 = *(_DWORD *)(v3 + 1536);
  v37 = (_QWORD *)(v3 + 2064);
  *v18 = *(_DWORD *)(v3 + 1540);
  v38 = (_QWORD *)(v3 + 2088);
  *v19 = *(_QWORD *)(v3 + 2064);
  v39 = &v47[-v3];
  *v21 = *(_QWORD *)(v3 + 2088);
  while ( v4 != -2147483390 )
  {
    v40 = *(_WORD *)&v39[v3];
    if ( !v40 )
      break;
    *(_WORD *)v3 = v40;
    v3 += 2i64;
    if ( !--v4 )
    {
      v3 -= 2i64;
      break;
    }
  }
  v41 = (char *)(v48 - v27);
  *(_WORD *)v3 = 0;
  while ( v9 != -2147483134 )
  {
    v42 = *(_WORD *)&v41[(_QWORD)v27];
    if ( !v42 )
      break;
    *(_WORD *)v27 = v42;
    v27 += 2;
    if ( !--v9 )
    {
      v27 -= 2;
      break;
    }
  }
  *(_WORD *)v27 = 0;
  v43 = (char *)(v51 - v31);
  while ( v14 != -2147483386 )
  {
    v44 = *(_WORD *)&v43[(_QWORD)v31];
    if ( !v44 )
      break;
    *(_WORD *)v31 = v44;
    v31 += 2;
    if ( !--v14 )
    {
      v31 -= 2;
      break;
    }
  }
  v45 = v50;
  *(_WORD *)v31 = 0;
  *v35 = v22;
  *v36 = v45;
  *v37 = v52;
  result = v53;
  *v38 = v53;
  return result;
}
// 14007D2B7: conditional instruction was optimized away because rdx.8!=0
// 14007D317: conditional instruction was optimized away because rdx.8!=0
// 14007D376: conditional instruction was optimized away because rdx.8!=0
// 14007D3FA: conditional instruction was optimized away because rcx.8!=0
// 14007D448: conditional instruction was optimized away because rcx.8!=0
// 14007D48C: conditional instruction was optimized away because r8.8!=0
// 14007D508: conditional instruction was optimized away because rbp.8!=0
// 14007D547: conditional instruction was optimized away because rsi.8!=0
// 14007D586: conditional instruction was optimized away because rdi.8!=0

//----- (000000014007D5F0) ----------------------------------------------------
__int64 __fastcall sub_14007D5F0(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  _WORD *v5; // r8
  __int16 v6; // ax
  __int64 v7; // r8
  __int64 v8; // rdx
  _WORD *v9; // rcx
  __int64 v10; // r8
  __int16 v11; // ax
  bool v12; // zf
  _WORD *v13; // rcx
  __int64 v14; // rdx
  __int16 v15; // ax
  __int64 result; // rax

  v4 = 256i64;
  v5 = (_WORD *)a1;
  while ( v4 != -2147483390 )
  {
    v6 = *(_WORD *)((char *)v5 + a2 - a1);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  v7 = a2 + 512;
  v8 = 512i64;
  v9 = (_WORD *)(a1 + 512);
  v10 = v7 - (_QWORD)v9;
  while ( v8 != -2147483134 )
  {
    v11 = *(_WORD *)((char *)v9 + v10);
    if ( !v11 )
      break;
    *v9++ = v11;
    if ( !--v8 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  v12 = *(_DWORD *)(a1 + 1540) == 1;
  *(_DWORD *)(a1 + 1536) = *(_DWORD *)(a2 + 1536);
  if ( v12 )
  {
    v13 = (_WORD *)(a1 + 1544);
    v14 = 260i64;
    while ( v14 != -2147483386 )
    {
      v15 = *(_WORD *)((char *)v13 + a2 - a1);
      if ( !v15 )
        break;
      *v13++ = v15;
      if ( !--v14 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  result = *(unsigned int *)(a1 + 1540);
  *(_QWORD *)(a2 + 2064) = a1;
  *(_DWORD *)(a2 + 1540) = result;
  return result;
}
// 14007D638: conditional instruction was optimized away because r9.8!=0
// 14007D687: conditional instruction was optimized away because rdx.8!=0
// 14007D6E7: conditional instruction was optimized away because rdx.8!=0

//----- (000000014007D720) ----------------------------------------------------
__int64 __fastcall sub_14007D720(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  _WORD *v5; // r8
  __int16 v6; // ax
  __int64 v7; // rdx
  __int64 v8; // r8
  _WORD *v9; // rcx
  __int64 v10; // r8
  __int16 v11; // ax
  __int64 result; // rax
  _WORD *v13; // rcx
  __int64 v14; // rdx

  v4 = 256i64;
  v5 = (_WORD *)a2;
  while ( v4 != -2147483390 )
  {
    v6 = *(_WORD *)((char *)v5 + a1 - a2);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = 512i64;
  *v5 = 0;
  v8 = a1 + 512;
  v9 = (_WORD *)(a2 + 512);
  v10 = v8 - (a2 + 512);
  while ( v7 != -2147483134 )
  {
    v11 = *(_WORD *)((char *)v9 + v10);
    if ( !v11 )
      break;
    *v9++ = v11;
    if ( !--v7 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  *(_DWORD *)(a2 + 1540) = *(_DWORD *)(a1 + 1540);
  result = *(unsigned int *)(a1 + 1536);
  *(_DWORD *)(a2 + 1536) = result;
  if ( *(_DWORD *)(a1 + 1540) == 1 )
  {
    v13 = (_WORD *)(a2 + 1544);
    v14 = 260i64;
    while ( 1 )
    {
      result = v14 + 2147483386;
      if ( v14 == -2147483386 )
        break;
      result = *(unsigned __int16 *)((char *)v13 + a1 - a2);
      if ( !(_WORD)result )
        break;
      *v13++ = result;
      if ( !--v14 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  *(_QWORD *)(a2 + 2064) = a1;
  return result;
}
// 14007D768: conditional instruction was optimized away because r9.8!=0
// 14007D7B7: conditional instruction was optimized away because rdx.8!=0
// 14007D827: conditional instruction was optimized away because rdx.8!=0

//----- (000000014007D850) ----------------------------------------------------
__int64 __fastcall sub_14007D850(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  _WORD *v5; // r8
  __int16 v6; // ax
  __int64 v7; // r8
  __int64 v8; // rdx
  _WORD *v9; // rcx
  __int64 v10; // r8
  __int16 v11; // ax
  __int64 result; // rax
  _WORD *v13; // rcx
  __int64 v14; // rdx

  v4 = 256i64;
  v5 = (_WORD *)a1;
  while ( v4 != -2147483390 )
  {
    v6 = *(_WORD *)((char *)v5 + a2 - a1);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  v7 = a2 + 512;
  v8 = 512i64;
  v9 = (_WORD *)(a1 + 512);
  v10 = v7 - (_QWORD)v9;
  while ( v8 != -2147483134 )
  {
    v11 = *(_WORD *)((char *)v9 + v10);
    if ( !v11 )
      break;
    *v9++ = v11;
    if ( !--v8 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  *(_DWORD *)(a1 + 1540) = *(_DWORD *)(a2 + 1540);
  result = *(unsigned int *)(a2 + 1536);
  *(_QWORD *)(a1 + 2088) = 0i64;
  *(_DWORD *)(a1 + 1536) = result;
  *(_QWORD *)(a1 + 2080) = 0i64;
  if ( *(_DWORD *)(a2 + 1540) == 1 )
  {
    v13 = (_WORD *)(a1 + 1544);
    v14 = 260i64;
    while ( 1 )
    {
      result = v14 + 2147483386;
      if ( v14 == -2147483386 )
        break;
      result = *(unsigned __int16 *)((char *)v13 + a2 - a1);
      if ( !(_WORD)result )
        break;
      *v13++ = result;
      if ( !--v14 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  *(_QWORD *)(a2 + 2064) = a1;
  return result;
}
// 14007D898: conditional instruction was optimized away because r9.8!=0
// 14007D8E7: conditional instruction was optimized away because rdx.8!=0
// 14007D967: conditional instruction was optimized away because rdx.8!=0

//----- (000000014007D990) ----------------------------------------------------
__int64 __fastcall sub_14007D990(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 2064) + 2080i64);
  if ( !v2 )
    return 2147500037i64;
  while ( *(_DWORD *)(v2 + 1540) )
  {
    v2 = *(_QWORD *)(v2 + 2080);
    if ( !v2 )
      return 2147500037i64;
  }
  sub_14007D720(v2, a2);
  return 0i64;
}

//----- (000000014007D9E0) ----------------------------------------------------
__int64 __fastcall sub_14007D9E0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_14007D720(*(_QWORD *)(a3 + 2080), a2);
  return 0i64;
}

//----- (000000014007DA00) ----------------------------------------------------
__int64 __fastcall sub_14007DA00(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = *(_QWORD *)(a3 + 2088);
  if ( !v3 )
    return 2147500037i64;
  while ( *(_DWORD *)(v3 + 1540) )
  {
    v3 = *(_QWORD *)(v3 + 2080);
    if ( !v3 )
      return 2147500037i64;
  }
  sub_14007D720(v3, a2);
  return 0i64;
}

//----- (000000014007DA50) ----------------------------------------------------
__int64 __fastcall sub_14007DA50(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = *(_QWORD *)(a3 + 2088);
  if ( !v3 )
    return 2147500037i64;
  sub_14007D720(v3, a2);
  return 0i64;
}

//----- (000000014007DA80) ----------------------------------------------------
__int64 __fastcall sub_14007DA80(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  _WORD *v5; // r8
  __int16 v6; // ax
  __int64 v7; // rdx
  __int64 v8; // r8
  _WORD *v9; // rcx
  __int64 v10; // r8
  __int16 v11; // ax
  __int64 result; // rax

  v4 = 256i64;
  v5 = (_WORD *)a2;
  while ( v4 != -2147483390 )
  {
    v6 = *(_WORD *)((char *)v5 + a1 - a2);
    if ( !v6 )
      break;
    *v5++ = v6;
    if ( !--v4 )
    {
      --v5;
      break;
    }
  }
  v7 = 512i64;
  *v5 = 0;
  v8 = a1 + 512;
  v9 = (_WORD *)(a2 + 512);
  v10 = v8 - (a2 + 512);
  while ( v7 != -2147483134 )
  {
    v11 = *(_WORD *)((char *)v9 + v10);
    if ( !v11 )
      break;
    *v9++ = v11;
    if ( !--v7 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  *(_DWORD *)(a2 + 1540) = *(_DWORD *)(a1 + 1540);
  result = *(unsigned int *)(a1 + 1536);
  *(_QWORD *)(a2 + 2064) = a1;
  *(_DWORD *)(a2 + 1536) = result;
  return result;
}
// 14007DAC8: conditional instruction was optimized away because r9.8!=0
// 14007DB17: conditional instruction was optimized away because rdx.8!=0

//----- (000000014007DBC0) ----------------------------------------------------
_QWORD *__fastcall sub_14007DBC0(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rdi
  _QWORD *result; // rax
  __int64 v6; // rdx

  v4 = malloc(0x830ui64);
  result = (_QWORD *)sub_14007D850((__int64)v4, a2);
  v4[258] = a1;
  v6 = *(_QWORD *)(a1 + 2088);
  if ( v6 )
  {
    for ( result = (_QWORD *)(v6 + 2080); *result; result = (_QWORD *)(*result + 2080i64) )
      v6 = *result;
    *(_QWORD *)(v6 + 2080) = v4;
    v4[259] = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 2088) = v4;
    v4[259] = 0i64;
  }
  return result;
}

//----- (000000014007DCB0) ----------------------------------------------------
__int64 __fastcall sub_14007DCB0(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  IShellFolder *ppshf; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1 || !a2 )
    return 0i64;
  v4 = 0;
  ppshf = 0i64;
  if ( SHGetDesktopFolder(&ppshf) >= 0 )
  {
    if ( !((unsigned __int16 (__fastcall *)(IShellFolder *, _QWORD, __int64, __int64))ppshf->lpVtbl->CompareIDs)(
            ppshf,
            0i64,
            a1,
            a2) )
      v4 = 1;
    ((void (*)(void))ppshf->lpVtbl->Release)();
  }
  return v4;
}

//----- (000000014007DD40) ----------------------------------------------------
_BOOL8 __fastcall sub_14007DD40(__int64 a1)
{
  return lstrlenW((LPCWSTR)a1) > 2 && *(_WORD *)a1 == 58 && *(_WORD *)(a1 + 2) == 58;
}

//----- (000000014007DD80) ----------------------------------------------------
__int64 __fastcall sub_14007DD80(char a1, char a2, int a3)
{
  if ( ((a1 & 8) != 0 && (a1 & 4) != 0 || (a1 & 0x20) != 0) && (a2 & 4) != 0 )
    return 4i64;
  if ( (a1 & 4) != 0 && (a2 & 2) != 0 )
    return 2i64;
  if ( (a1 & 8) == 8 && (a2 & 1) != 0 )
    return 1i64;
  if ( a3 && (a2 & 2) != 0 )
    return 2i64;
  if ( (a2 & 1) != 0 )
    return 1i64;
  if ( (a2 & 2) != 0 )
    return 2i64;
  else
    return a2 & 4;
}

//----- (000000014007DDE0) ----------------------------------------------------
__int64 __fastcall sub_14007DDE0(LPCWSTR lpSrc, LPWSTR lpDest, HANDLE hObject)
{
  unsigned int v6; // ebx
  HANDLE TokenHandle; // [rsp+48h] [rbp+20h] BYREF

  v6 = OpenProcessToken(hObject, 0xCu, &TokenHandle);
  if ( v6 )
  {
    v6 = ExpandEnvironmentStringsForUserW(TokenHandle, lpSrc, lpDest, 0x104u);
    CloseHandle(TokenHandle);
  }
  CloseHandle(hObject);
  return v6;
}

//----- (000000014007DE60) ----------------------------------------------------
__int64 __fastcall sub_14007DE60(int a1)
{
  DWORD v1; // edx
  SHFILEINFOW psfi; // [rsp+30h] [rbp-2D8h] BYREF

  v1 = 128;
  if ( !a1 )
    v1 = 144;
  SHGetFileInfoW(L"dummy", v1, &psfi, 0x2B8u, 0x4010u);
  return (unsigned int)psfi.iIcon;
}

//----- (000000014007DED0) ----------------------------------------------------
__int64 sub_14007DED0()
{
  SHFILEINFOW psfi; // [rsp+30h] [rbp-2D8h] BYREF

  SHGetFileInfoW(L"dummy", 0x80u, &psfi, 0x2B8u, 0x4010u);
  return (unsigned int)psfi.iIcon;
}

//----- (000000014007DF30) ----------------------------------------------------
__int64 sub_14007DF30()
{
  SHFILEINFOW psfi; // [rsp+30h] [rbp-2D8h] BYREF

  SHGetFileInfoW(L"dummy", 0x90u, &psfi, 0x2B8u, 0x4010u);
  return (unsigned int)psfi.iIcon;
}

//----- (000000014007DF90) ----------------------------------------------------
__int64 __fastcall sub_14007DF90(__int64 a1)
{
  unsigned int v2; // ebx
  LPITEMIDLIST ppidl; // [rsp+48h] [rbp+10h] BYREF

  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) < 0 )
    return 0i64;
  v2 = sub_14007DCB0(a1, (__int64)ppidl);
  CoTaskMemFree(ppidl);
  return v2;
}

//----- (000000014007DFF0) ----------------------------------------------------
__int64 __fastcall sub_14007DFF0(LPCITEMIDLIST pidl, LPITEMIDLIST *a2)
{
  int v4; // ebx
  LPITEMIDLIST ppidl; // [rsp+50h] [rbp+18h] BYREF

  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) >= 0
    && (v4 = sub_14007DCB0((__int64)pidl, (__int64)ppidl), CoTaskMemFree(ppidl), v4) )
  {
    *a2 = 0i64;
    return 0i64;
  }
  else
  {
    ILRemoveLastID((LPITEMIDLIST)pidl);
    *a2 = ILClone(pidl);
    return 0i64;
  }
}

//----- (000000014007E090) ----------------------------------------------------
HRESULT __fastcall sub_14007E090(int csidl, LPWSTR pszBuf)
{
  HRESULT result; // eax
  LPITEMIDLIST ppidl; // [rsp+30h] [rbp-128h] BYREF
  IShellFolder *ppshf; // [rsp+38h] [rbp-120h] BYREF
  STRRET pstr; // [rsp+40h] [rbp-118h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+170h] [rbp+18h] BYREF
  void *ppv; // [rsp+178h] [rbp+20h] BYREF

  ppv = 0i64;
  ppshf = 0i64;
  ppidl = 0i64;
  ppidlLast = 0i64;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    if ( SHGetFolderLocation(0i64, csidl, 0i64, 0, &ppidl) >= 0 )
    {
      if ( SHBindToParent(ppidl, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               0x8000i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, ppidlLast, pszBuf, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
      CoTaskMemFree(ppidl);
    }
    return ((__int64 (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
  }
  return result;
}

//----- (000000014007E190) ----------------------------------------------------
BOOL __fastcall sub_14007E190(HWND a1, const WCHAR *a2, const WCHAR *a3, const WCHAR *a4, void *a5)
{
  SHELLEXECUTEINFOW v6; // [rsp+20h] [rbp-78h] BYREF

  v6.cbSize = 112;
  v6.fMask = 12;
  v6.hwnd = a1;
  v6.lpIDList = a5;
  v6.lpVerb = a2;
  v6.nShow = 5;
  v6.lpFile = 0i64;
  v6.hInstApp = 0i64;
  v6.lpParameters = a3;
  v6.lpDirectory = a4;
  return ShellExecuteExW(&v6);
}

//----- (000000014007E1F0) ----------------------------------------------------
__int64 __fastcall sub_14007E1F0(const ITEMIDLIST *a1, __int64 a2)
{
  HRESULT v4; // ebx
  void *ppv; // [rsp+38h] [rbp+10h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp+18h] BYREF

  if ( !a2 )
    return 2147500037i64;
  ppv = 0i64;
  ppidlLast = 0i64;
  v4 = SHBindToParent(a1, &stru_1400E3FB0, &ppv, &ppidlLast);
  if ( v4 >= 0 )
  {
    v4 = (*(__int64 (__fastcall **)(void *, __int64, LPCITEMIDLIST *, __int64))(*(_QWORD *)ppv + 72i64))(
           ppv,
           1i64,
           &ppidlLast,
           a2);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  return (unsigned int)v4;
}

//----- (000000014007E270) ----------------------------------------------------
__int64 __fastcall sub_14007E270(LPCITEMIDLIST pidl, LPWSTR pszBuf, unsigned int a3)
{
  HRESULT v6; // esi
  STRRET pstr; // [rsp+20h] [rbp-128h] BYREF
  void *v9; // [rsp+150h] [rbp+8h] BYREF
  LPCITEMIDLIST v10; // [rsp+168h] [rbp+20h] BYREF

  if ( !pidl || !pszBuf )
    return 2147500037i64;
  v9 = 0i64;
  v10 = 0i64;
  v6 = SHBindToParent(pidl, &stru_1400E3FB0, &v9, &v10);
  if ( v6 >= 0 )
  {
    v6 = (*(__int64 (__fastcall **)(void *, LPCITEMIDLIST, _QWORD, STRRET *))(*(_QWORD *)v9 + 88i64))(
           v9,
           v10,
           a3,
           &pstr);
    if ( v6 >= 0 )
      StrRetToBufW(&pstr, pidl, pszBuf, 0x104u);
    (*(void (__fastcall **)(void *))(*(_QWORD *)v9 + 16i64))(v9);
  }
  return (unsigned int)v6;
}

//----- (000000014007E340) ----------------------------------------------------
__int64 __fastcall sub_14007E340(__int64 a1, const WCHAR *a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6)
{
  HRESULT v10; // ebx
  LPVOID ppv; // [rsp+30h] [rbp-88h] BYREF
  __int64 v13; // [rsp+38h] [rbp-80h] BYREF
  __int64 v14; // [rsp+40h] [rbp-78h] BYREF
  LPWSTR ppwsz[2]; // [rsp+48h] [rbp-70h] BYREF
  CLSID pclsid; // [rsp+58h] [rbp-60h] BYREF
  int v17; // [rsp+68h] [rbp-50h]

  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return 2147500037i64;
  ppv = 0i64;
  v10 = CoCreateInstance(&stru_1400E40A0, 0i64, 1u, &stru_1400E3FE0, &ppv);
  if ( v10 >= 0 )
  {
    (*(void (__fastcall **)(LPVOID, __int64))(*(_QWORD *)ppv + 160i64))(ppv, a3);
    (*(void (__fastcall **)(LPVOID, __int64))(*(_QWORD *)ppv + 88i64))(ppv, a4);
    (*(void (__fastcall **)(LPVOID, __int64, _QWORD))(*(_QWORD *)ppv + 136i64))(ppv, a5, a6);
    v13 = 0i64;
    v10 = (**(__int64 (__fastcall ***)(LPVOID, void *, __int64 *))ppv)(ppv, &unk_1400E4150, &v13);
    if ( v10 >= 0 )
    {
      LOWORD(v14) = 31;
      if ( SHStrDupW(a2, ppwsz) < 0 )
      {
        v14 = 0i64;
        ppwsz[0] = 0i64;
        ppwsz[1] = 0i64;
      }
      CLSIDFromString(L"{F29F85E0-4FF9-1068-AB91-08002B27B3D9}", &pclsid);
      v17 = 2;
      (*(void (__fastcall **)(__int64, CLSID *, __int64 *))(*(_QWORD *)v13 + 48i64))(v13, &pclsid, &v14);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 56i64))(v13);
      (*(void (__fastcall **)(__int64, LPVOID))(*(_QWORD *)a1 + 40i64))(a1, ppv);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
    }
    (*(void (__fastcall **)(LPVOID))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  return (unsigned int)v10;
}

//----- (000000014007E500) ----------------------------------------------------
int __fastcall sub_14007E500(__int64 a1, IShellFolder **a2)
{
  int result; // eax
  IShellFolder *ppshf; // [rsp+48h] [rbp+10h] BYREF

  if ( !a2 )
    return -2147467259;
  ppshf = 0i64;
  *a2 = 0i64;
  result = SHGetDesktopFolder(&ppshf);
  if ( result >= 0 )
  {
    if ( (unsigned int)sub_14007DF90(a1) )
      return SHGetDesktopFolder(a2);
    else
      return ((__int64 (__fastcall *)(IShellFolder *, __int64, _QWORD, const IID *, IShellFolder **))ppshf->lpVtbl->BindToObject)(
               ppshf,
               a1,
               0i64,
               &stru_1400E3FB0,
               a2);
  }
  return result;
}

//----- (000000014007E590) ----------------------------------------------------
HRESULT __fastcall sub_14007E590(int csidl, LPWSTR pszBuf)
{
  HRESULT result; // eax
  int v4; // ebx
  LPITEMIDLIST ppidl; // [rsp+50h] [rbp+18h] BYREF

  ppidl = 0i64;
  result = SHGetFolderLocation(0i64, csidl, 0i64, 0, &ppidl);
  if ( !result )
  {
    v4 = sub_14007E270(ppidl, pszBuf, 1u);
    CoTaskMemFree(ppidl);
    return v4;
  }
  return result;
}

//----- (000000014007E5F0) ----------------------------------------------------
__int64 __fastcall sub_14007E5F0(PCNZWCH lpString2, LPWSTR pszBuf)
{
  LPITEMIDLIST ppidl[2]; // [rsp+30h] [rbp-D0h] BYREF
  WCHAR String1[264]; // [rsp+40h] [rbp-C0h] BYREF

  ppidl[0] = 0i64;
  SHGetFolderLocation(0i64, 3, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(3, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 10, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(10, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 17, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(17, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 18, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(18, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 49, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(49, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 4, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(4, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 6, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
    sub_14007E090(6, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 39, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
    goto LABEL_16;
  SHGetFolderLocation(0i64, 13, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
  {
LABEL_18:
    sub_14007E090(13, pszBuf);
    return 0i64;
  }
  SHGetFolderLocation(0i64, 14, 0i64, 0, ppidl);
  sub_14007E270(ppidl[0], String1, 1u);
  CoTaskMemFree(ppidl[0]);
  if ( !lstrcmpiW(String1, lpString2) )
    goto LABEL_20;
  if ( CompareStringW(0x7Fu, 1u, L"Desktop", -1, lpString2, -1) == 2 )
  {
    sub_14007E090(0, pszBuf);
    return 0i64;
  }
  else
  {
    if ( CompareStringW(0x7Fu, 1u, L"Pictures", -1, lpString2, -1) == 2 )
    {
LABEL_16:
      sub_14007E090(39, pszBuf);
      return 0i64;
    }
    if ( CompareStringW(0x7Fu, 1u, L"Music", -1, lpString2, -1) == 2 )
      goto LABEL_18;
    if ( CompareStringW(0x7Fu, 1u, L"Videos", -1, lpString2, -1) == 2 )
    {
LABEL_20:
      sub_14007E090(14, pszBuf);
      return 0i64;
    }
    if ( CompareStringW(0x7Fu, 1u, L"Documents", -1, lpString2, -1) == 2 )
    {
      sub_14007E090(5, pszBuf);
      return 0i64;
    }
    else
    {
      return 2147500037i64;
    }
  }
}

//----- (000000014007EB20) ----------------------------------------------------
__int64 __fastcall sub_14007EB20(const ITEMIDLIST *a1)
{
  unsigned int v2; // [rsp+30h] [rbp+8h] BYREF
  void *ppv; // [rsp+38h] [rbp+10h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp+18h] BYREF

  v2 = 0x20000000;
  if ( a1 )
  {
    ppv = 0i64;
    ppidlLast = 0i64;
    if ( SHBindToParent(a1, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
    {
      (*(void (__fastcall **)(void *, __int64, LPCITEMIDLIST *, unsigned int *))(*(_QWORD *)ppv + 72i64))(
        ppv,
        1i64,
        &ppidlLast,
        &v2);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    }
  }
  return (v2 >> 29) & 1;
}

//----- (000000014007EBA0) ----------------------------------------------------
__int64 __fastcall sub_14007EBA0(LPCOLESTR lpsz, HMODULE *a2)
{
  HMODULE LibraryW; // rbx
  __int64 v5; // rdi
  LSTATUS v6; // eax
  HMODULE v7; // rax
  DWORD cbData; // [rsp+30h] [rbp-668h] BYREF
  DWORD Type[2]; // [rsp+38h] [rbp-660h] BYREF
  HKEY hKey; // [rsp+40h] [rbp-658h] BYREF
  HKEY phkResult; // [rsp+48h] [rbp-650h] BYREF
  CLSID pclsid; // [rsp+50h] [rbp-648h] BYREF
  __int16 Data[264]; // [rsp+60h] [rbp-638h] BYREF
  WCHAR SubKey[512]; // [rsp+270h] [rbp-428h] BYREF

  LibraryW = 0i64;
  sub_140001000(SubKey, 0x200ui64, L"%s\\%s", L"Software\\Classes\\CLSID", lpsz);
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, SubKey, 0, 0x20019u, &hKey) )
  {
    if ( !RegOpenKeyExW(hKey, L"InProcServer32", 0, 0x20019u, &phkResult) )
    {
      v5 = 260i64;
      cbData = 260;
      v6 = RegQueryValueExW(phkResult, 0i64, 0i64, Type, (LPBYTE)Data, &cbData);
      if ( cbData && Type[0] == 1 )
      {
        if ( Data[cbData - 1] )
        {
          if ( cbData < 0x104 )
            v5 = cbData;
          Data[v5] = 0;
        }
      }
      else
      {
        Data[0] = 0;
      }
      if ( !v6 )
        LibraryW = LoadLibraryW((LPCWSTR)Data);
      RegCloseKey(phkResult);
    }
    RegCloseKey(hKey);
  }
  if ( CLSIDFromString(lpsz, &pclsid)
    || (*(_QWORD *)Type = 0i64, CoCreateInstance(&pclsid, 0i64, 1u, &stru_1400E4110, (LPVOID *)Type)) )
  {
    if ( LibraryW )
      FreeLibrary(LibraryW);
    return 0i64;
  }
  else
  {
    v7 = *(HMODULE *)Type;
    *a2 = LibraryW;
    a2[1] = v7;
    return 1i64;
  }
}
// 1400EC110: using guessed type wchar_t aSoftwareClasse[23];
// 1400EC140: using guessed type wchar_t aSS[6];
// 14007EBA0: using guessed type WCHAR Data[264];

//----- (000000014007ED80) ----------------------------------------------------
__int64 __fastcall sub_14007ED80(LPCWSTR lpSubKey, __int64 *a2)
{
  unsigned int v4; // ebx
  DWORD v5; // esi
  LSTATUS v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rdi
  char *v9; // rax
  __int64 v10; // rdx
  DWORD cchName; // [rsp+40h] [rbp-C0h] BYREF
  DWORD cbData; // [rsp+44h] [rbp-BCh] BYREF
  HKEY hKey; // [rsp+48h] [rbp-B8h] BYREF
  DWORD Type; // [rsp+50h] [rbp-B0h] BYREF
  HKEY phkResult; // [rsp+58h] [rbp-A8h] BYREF
  void *v17[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int16 Data[256]; // [rsp+70h] [rbp-90h] BYREF
  WCHAR Name[512]; // [rsp+270h] [rbp+170h] BYREF
  WCHAR SubKey[512]; // [rsp+670h] [rbp+570h] BYREF

  v4 = 0;
  hKey = 0i64;
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, lpSubKey, 0, 0x20019u, &hKey) )
  {
    v5 = 0;
    cchName = 512;
    if ( !RegEnumKeyExW(hKey, 0, Name, &cchName, 0i64, 0i64, 0i64, 0i64) )
    {
      do
      {
        sub_140001000(SubKey, 0x200ui64, L"%s\\%s", lpSubKey, Name);
        if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, SubKey, 0, 0x20019u, &phkResult) )
        {
          cbData = 256;
          v6 = RegQueryValueExW(phkResult, 0i64, 0i64, &Type, (LPBYTE)Data, &cbData);
          if ( cbData && Type == 1 )
          {
            if ( Data[cbData - 1] )
            {
              v7 = 256i64;
              if ( cbData < 0x100 )
                v7 = cbData;
              Data[v7] = 0;
            }
          }
          else
          {
            Data[0] = 0;
          }
          if ( !v6 && (unsigned int)sub_14007EBA0((LPCOLESTR)Data, (HMODULE *)v17) )
          {
            v8 = *a2;
            v9 = sub_14001BDE0(*a2, *(_QWORD *)(*a2 + 8), v17);
            v10 = a2[1];
            if ( v10 == 0xFFFFFFFFFFFFFFEi64 )
              sub_14002B5F8("list<T> too long");
            a2[1] = v10 + 1;
            *(_QWORD *)(v8 + 8) = v9;
            **((_QWORD **)v9 + 1) = v9;
          }
          RegCloseKey(phkResult);
        }
        ++v5;
        cchName = 512;
      }
      while ( !RegEnumKeyExW(hKey, v5, Name, &cchName, 0i64, 0i64, 0i64, 0i64) );
    }
    RegCloseKey(hKey);
    return 1;
  }
  return v4;
}
// 1400EC100: using guessed type wchar_t aSS_0[6];
// 14007ED80: using guessed type OLECHAR Data[256];
// 14007ED80: using guessed type HMODULE var_A40[2];

//----- (000000014007EFF0) ----------------------------------------------------
__int64 __fastcall sub_14007EFF0(__int64 a1, void **a2)
{
  const WCHAR *v4; // rsi
  const WCHAR *v5; // rbx
  void **v6; // rcx
  void **v7; // rbx

  v4 = (const WCHAR *)*a2;
  v5 = *(const WCHAR **)*a2;
  if ( v5 != *a2 )
  {
    do
    {
      sub_14007E340(
        a1,
        *((const WCHAR **)v5 + 2),
        *((_QWORD *)v5 + 3),
        *((_QWORD *)v5 + 4),
        *((_QWORD *)v5 + 5),
        *((_QWORD *)v5 + 6));
      v5 = *(const WCHAR **)v5;
    }
    while ( v5 != v4 );
  }
  v6 = *(void ***)*a2;
  *(_QWORD *)*a2 = *a2;
  *((_QWORD *)*a2 + 1) = *a2;
  a2[1] = 0i64;
  if ( v6 != *a2 )
  {
    do
    {
      v7 = (void **)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *a2 );
  }
  j_free(*a2);
  return 0i64;
}

//----- (000000014007F0B0) ----------------------------------------------------
int __fastcall sub_14007F0B0(PCNZWCH lpString2, __int64 a2, char *a3)
{
  int result; // eax
  __int64 v7; // rdi
  signed __int64 v8; // rcx
  DWORD CurrentProcessId; // eax
  HANDLE v10; // rax
  __int64 v11; // rdi
  void *v12; // rbp
  BOOL v13; // er13
  __int64 v14; // rdx
  WCHAR *v15; // rcx
  signed __int64 v16; // rsi
  WCHAR v17; // ax
  signed __int64 v18; // rcx
  signed __int64 v19; // rcx
  HANDLE TokenHandle; // [rsp+20h] [rbp-678h] BYREF
  WCHAR pszBuf[264]; // [rsp+30h] [rbp-668h] BYREF
  WCHAR Dest[264]; // [rsp+240h] [rbp-458h] BYREF
  WCHAR v23[264]; // [rsp+450h] [rbp-248h] BYREF

  if ( lstrlenW(lpString2) >= 2 && *lpString2 == 58 && lpString2[1] == 58 )
    return sub_140001240(a3, 0x104ui64, (__int64)lpString2);
  if ( (int)sub_14007E5F0(lpString2, v23) < 0 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v10 = OpenProcess(0x400u, 0, CurrentProcessId);
    v11 = 260i64;
    v12 = v10;
    if ( !v10 )
      goto LABEL_16;
    v13 = OpenProcessToken(v10, 0xCu, &TokenHandle);
    if ( v13 )
    {
      v13 = ExpandEnvironmentStringsForUserW(TokenHandle, lpString2, Dest, 0x104u);
      CloseHandle(TokenHandle);
    }
    CloseHandle(v12);
    if ( !v13 )
    {
LABEL_16:
      v14 = 260i64;
      v15 = Dest;
      v16 = (char *)lpString2 - (char *)Dest;
      while ( v14 != -2147483386 )
      {
        v17 = *(WCHAR *)((char *)v15 + v16);
        if ( !v17 )
          break;
        *v15++ = v17;
        if ( !--v14 )
        {
          --v15;
          break;
        }
      }
      *v15 = 0;
    }
    PathCanonicalizeW(pszBuf, Dest);
    if ( PathIsURLW(pszBuf) )
    {
      v18 = (char *)pszBuf - a3;
      while ( 1 )
      {
        result = v11 + 2147483386;
        if ( v11 == -2147483386 )
          break;
        result = *(unsigned __int16 *)&a3[v18];
        if ( !(_WORD)result )
          break;
        *(_WORD *)a3 = result;
        a3 += 2;
        if ( !--v11 )
          goto LABEL_36;
      }
    }
    else
    {
      if ( PathIsRelativeW(pszBuf) )
      {
        sub_140001240(a3, 0x104ui64, a2);
        return PathAppendW((LPWSTR)a3, pszBuf);
      }
      v19 = (char *)pszBuf - a3;
      while ( 1 )
      {
        result = v11 + 2147483386;
        if ( v11 == -2147483386 )
          break;
        result = *(unsigned __int16 *)&a3[v19];
        if ( !(_WORD)result )
          break;
        *(_WORD *)a3 = result;
        a3 += 2;
        if ( !--v11 )
        {
LABEL_36:
          a3 -= 2;
          break;
        }
      }
    }
  }
  else
  {
    v7 = 260i64;
    v8 = (char *)v23 - a3;
    while ( 1 )
    {
      result = v7 + 2147483386;
      if ( v7 == -2147483386 )
        break;
      result = *(unsigned __int16 *)&a3[v8];
      if ( !(_WORD)result )
        break;
      *(_WORD *)a3 = result;
      a3 += 2;
      if ( !--v7 )
      {
        a3 -= 2;
        break;
      }
    }
  }
  *(_WORD *)a3 = 0;
  return result;
}
// 14007F161: conditional instruction was optimized away because rdi.8!=0
// 14007F238: conditional instruction was optimized away because rdx.8!=0
// 14007F2F6: conditional instruction was optimized away because rdi.8!=0

//----- (000000014007F330) ----------------------------------------------------
__int64 __fastcall sub_14007F330(__int64 a1, __int64 a2, const ITEMIDLIST *a3, __int64 ***a4)
{
  __int64 v6; // r15
  __int16 v8; // ax
  int v9; // er13
  UINT v10; // eax
  __int64 **v11; // rdi
  unsigned int v12; // esi
  __int64 *v13; // rbx
  UINT v14; // eax
  HGLOBAL v15; // rax
  void *v16; // rsi
  _DWORD *v18; // rax
  _DWORD *v19; // r13
  char *v20; // rbx
  UINT v21; // eax
  UINT v22; // eax
  __int64 **v23; // rdi
  __int64 *v24; // rbx
  UINT v25; // er11
  _DWORD *v26; // r13
  const ITEMIDLIST *v27; // rbp
  char *v28; // rsi
  UINT v29; // eax
  UINT v30; // eax
  __int64 *v31; // rcx
  __int64 **v32; // rbx
  __int64 *v33; // rcx
  __int64 **v34; // rbx
  _DWORD *v35; // [rsp+20h] [rbp-48h]
  HGLOBAL v36; // [rsp+28h] [rbp-40h]
  unsigned int v37; // [rsp+70h] [rbp+8h]

  v6 = a2;
  if ( a1 && a2 && a3 && a4[1] )
  {
    v8 = RegisterClipboardFormatW(L"Shell IDList Array");
    *(_DWORD *)(a1 + 24) = 1;
    *(_DWORD *)(a1 + 20) = -1;
    *(_DWORD *)(a1 + 16) = 1;
    *(_WORD *)a1 = v8;
    *(_QWORD *)(a1 + 8) = 0i64;
    v9 = *((_DWORD *)a4 + 2);
    v37 = 4 * v9 + 8;
    v10 = ILGetSize(a3);
    v11 = *a4;
    v12 = v37 + v10;
    v13 = **a4;
    if ( v13 != (__int64 *)*a4 )
    {
      do
      {
        v14 = ILGetSize((LPCITEMIDLIST)v13[2]);
        v13 = (__int64 *)*v13;
        v12 += v14;
      }
      while ( v13 != (__int64 *)v11 );
    }
    v15 = GlobalAlloc(2u, v12);
    v16 = v15;
    v36 = v15;
    if ( v15 )
    {
      v18 = GlobalLock(v15);
      *v18 = v9;
      v19 = v18 + 1;
      v18[1] = v37;
      v35 = v18;
      v20 = (char *)v18 + v37;
      v21 = ILGetSize(a3);
      memmove(v20, a3, v21);
      v22 = ILGetSize(a3);
      v23 = *a4;
      v24 = **a4;
      v25 = v22;
      if ( v24 != (__int64 *)*a4 )
      {
        v26 = v19 + 1;
        do
        {
          v27 = (const ITEMIDLIST *)v24[2];
          *v26 = v25 + *(v26 - 1);
          v28 = (char *)v35 + (unsigned int)*v26;
          v29 = ILGetSize(v27);
          memmove(v28, v27, v29);
          v30 = ILGetSize(v27);
          v24 = (__int64 *)*v24;
          ++v26;
          v25 = v30;
        }
        while ( v24 != (__int64 *)v23 );
        v6 = a2;
        v16 = v36;
      }
      GlobalUnlock(v16);
      *(_QWORD *)(v6 + 16) = 0i64;
      *(_QWORD *)(v6 + 8) = v16;
      *(_DWORD *)v6 = 1;
      v31 = **a4;
      **a4 = (__int64 *)*a4;
      (*a4)[1] = (__int64 *)*a4;
      a4[1] = 0i64;
      if ( v31 != (__int64 *)*a4 )
      {
        do
        {
          v32 = (__int64 **)*v31;
          j_free(v31);
          v31 = (__int64 *)v32;
        }
        while ( v32 != *a4 );
      }
      j_free(*a4);
      return 0i64;
    }
    else
    {
      sub_14000AA30((void **)a4);
      return 2147500037i64;
    }
  }
  else
  {
    v33 = **a4;
    **a4 = (__int64 *)*a4;
    (*a4)[1] = (__int64 *)*a4;
    a4[1] = 0i64;
    if ( v33 != (__int64 *)*a4 )
    {
      do
      {
        v34 = (__int64 **)*v33;
        j_free(v33);
        v33 = (__int64 *)v34;
      }
      while ( v34 != *a4 );
    }
    j_free(*a4);
    return 2147500037i64;
  }
}

//----- (000000014007F5B0) ----------------------------------------------------
__int64 __fastcall sub_14007F5B0(void *Src)
{
  HGLOBAL v2; // rax
  unsigned int v3; // esi
  void *v4; // rdi
  void *v5; // rax
  __int64 v6; // r8

  EmptyClipboard();
  v2 = GlobalAlloc(2u, 2i64 * *((_QWORD *)Src + 2) + 2);
  v3 = 0;
  v4 = v2;
  if ( v2 )
  {
    v5 = GlobalLock(v2);
    v6 = *((_QWORD *)Src + 2);
    if ( *((_QWORD *)Src + 3) >= 8ui64 )
      Src = *(void **)Src;
    memmove(v5, Src, 2 * v6 + 2);
    GlobalUnlock(v4);
    if ( SetClipboardData(0xDu, v4) )
      v3 = 1;
  }
  CloseClipboard();
  return v3;
}

//----- (000000014007F650) ----------------------------------------------------
__int64 __fastcall sub_14007F650(__int64 a1, __int64 a2, __int64 a3, _WORD *a4, unsigned int a5)
{
  HRESULT v9; // ebx
  HRESULT v10; // eax
  LPVOID pv; // [rsp+40h] [rbp-38h] BYREF
  __int64 v13; // [rsp+48h] [rbp-30h] BYREF
  IShellFolder *v14; // [rsp+50h] [rbp-28h] BYREF
  IShellFolder *ppshf; // [rsp+88h] [rbp+10h] BYREF

  if ( !a2 || !a3 || !a4 || !a5 )
    return 2147500037i64;
  v14 = 0i64;
  ppshf = 0i64;
  v13 = 0i64;
  pv = 0i64;
  v9 = SHGetDesktopFolder(&v14);
  if ( v9 >= 0 )
  {
    if ( (unsigned int)sub_14007DF90(a2) )
      v10 = SHGetDesktopFolder(&ppshf);
    else
      v10 = ((__int64 (__fastcall *)(IShellFolder *, __int64, _QWORD, const IID *, IShellFolder **))v14->lpVtbl->BindToObject)(
              v14,
              a2,
              0i64,
              &stru_1400E3FB0,
              &ppshf);
    v9 = v10;
    if ( v10 >= 0 )
    {
      v9 = ((__int64 (__fastcall *)(IShellFolder *, __int64, __int64, __int64, void *, _QWORD, __int64 *))ppshf->lpVtbl->GetUIObjectOf)(
             ppshf,
             a1,
             1i64,
             a3,
             &unk_1400E3FF0,
             0i64,
             &v13);
      if ( v9 >= 0 )
      {
        v9 = (*(__int64 (__fastcall **)(__int64, __int64, LPVOID *))(*(_QWORD *)v13 + 24i64))(v13, 8i64, &pv);
        if ( v9 >= 0 && pv )
        {
          sub_140001240(a4, a5, (__int64)pv);
          CoTaskMemFree(pv);
        }
        else
        {
          sub_140001240(a4, a5, (__int64)&unk_1400EAA84);
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
      }
      ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
    }
    ((void (__fastcall *)(IShellFolder *))v14->lpVtbl->Release)(v14);
  }
  return (unsigned int)v9;
}

//----- (000000014007F810) ----------------------------------------------------
__int64 __fastcall sub_14007F810(__int64 a1, __int64 a2)
{
  HRESULT v5; // edi
  __int64 v6; // rdx
  char *v7; // rcx
  __int64 v8; // rbx
  __int16 v9; // ax
  IShellFolder *ppshf; // [rsp+40h] [rbp-238h] BYREF
  char v11[528]; // [rsp+50h] [rbp-228h] BYREF

  if ( !a2 )
    return 2147500037i64;
  ppshf = 0i64;
  v5 = SHGetDesktopFolder(&ppshf);
  if ( v5 >= 0 )
  {
    v6 = 260i64;
    v7 = v11;
    v8 = a1 - (_QWORD)v11;
    while ( v6 != -2147483386 )
    {
      v9 = *(_WORD *)&v7[v8];
      if ( !v9 )
        break;
      *(_WORD *)v7 = v9;
      v7 += 2;
      if ( !--v6 )
      {
        v7 -= 2;
        break;
      }
    }
    *(_WORD *)v7 = 0;
    v5 = ((__int64 (__fastcall *)(IShellFolder *, _QWORD, _QWORD, char *, _QWORD, __int64, _QWORD))ppshf->lpVtbl->ParseDisplayName)(
           ppshf,
           0i64,
           0i64,
           v11,
           0i64,
           a2,
           0i64);
    ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
  }
  return (unsigned int)v5;
}
// 14007F8A6: conditional instruction was optimized away because rdx.8!=0

//----- (000000014007FB00) ----------------------------------------------------
__int64 __fastcall sub_14007FB00(const ITEMIDLIST *a1)
{
  void *pv[2]; // [rsp+20h] [rbp-238h] BYREF
  WCHAR pszBuf[264]; // [rsp+30h] [rbp-228h] BYREF

  pv[0] = 0i64;
  if ( (int)sub_14007E270(a1, pszBuf, 0x8000u) < 0 || (int)sub_14007F810((__int64)pszBuf, (__int64)pv) < 0 )
    return 0i64;
  CoTaskMemFree(pv[0]);
  return 1i64;
}
// 14007FB00: using guessed type LPVOID pv[2];

//----- (000000014007FBA0) ----------------------------------------------------
__int64 __fastcall sub_14007FBA0(__int64 a1, __int64 a2)
{
  int v4; // ebx
  unsigned int v5; // ebx
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( !a2 )
    return 2147500037i64;
  pv[0] = 0i64;
  v4 = sub_14007F810(a1, (__int64)pv);
  if ( v4 >= 0 )
  {
    if ( pv[0] )
    {
      v5 = sub_14007E1F0((const ITEMIDLIST *)pv[0], a2);
      CoTaskMemFree(pv[0]);
      return v5;
    }
    v4 = -2147467259;
    CoTaskMemFree(0i64);
  }
  return (unsigned int)v4;
}
// 14007FBA0: using guessed type LPVOID pv[3];

//----- (000000014007FC30) ----------------------------------------------------
__int64 __fastcall sub_14007FC30(__int64 a1, WCHAR *a2, unsigned int a3)
{
  int v6; // ebx
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( !a2 )
    return 2147500037i64;
  pv[0] = 0i64;
  v6 = sub_14007F810(a1, (__int64)pv);
  if ( v6 >= 0 )
    v6 = sub_14007E270((LPCITEMIDLIST)pv[0], a2, a3);
  CoTaskMemFree(pv[0]);
  return (unsigned int)v6;
}
// 14007FC30: using guessed type LPVOID pv[3];

//----- (0000000140080090) ----------------------------------------------------
__int64 __fastcall sub_140080090(HWND hWnd, HWND a2)
{
  __int64 result; // rax
  int v5; // ebx
  int v6; // edi
  LPARAM lParam[11]; // [rsp+20h] [rbp-78h] BYREF
  int v8; // [rsp+78h] [rbp-20h]
  LPARAM v9; // [rsp+B0h] [rbp+18h] BYREF

  result = SendMessageW(hWnd, 0x40Cu, 0i64, 0i64);
  v5 = 0;
  v6 = result;
  if ( (int)result > 0 )
  {
    while ( 1 )
    {
      lParam[0] = 0x1000000070i64;
      result = SendMessageW(hWnd, 0x41Cu, v5, (LPARAM)lParam);
      if ( (HWND)lParam[5] == a2 )
        break;
      if ( ++v5 >= v6 )
        return result;
    }
    if ( v5 != -1 )
    {
      SendMessageW(a2, 0x453u, 0i64, (LPARAM)&v9);
      v8 = v9;
      lParam[0] = 0x20000000070i64;
      return SendMessageW(hWnd, 0x40Bu, v5, (LPARAM)lParam);
    }
  }
  return result;
}

//----- (0000000140080180) ----------------------------------------------------
LRESULT __fastcall sub_140080180(HWND hWnd, int a2, unsigned int a3)
{
  LPARAM v3; // rbp
  unsigned int v6; // edi
  unsigned int v7; // eax
  LPARAM v8; // r9
  UINT v9; // edx

  v3 = a3;
  v6 = 0;
  v7 = SendMessageW(hWnd, 0x1037u, 0i64, 0i64);
  if ( a2 )
  {
    if ( (v7 & 8) == 0 )
      v6 = 8;
    if ( (v7 & 0x40) == 0 )
      v6 |= 0x40u;
    if ( (v7 & 0x800) == 0 )
      v6 |= 0x800u;
    SendMessageW(hWnd, 0x1036u, 0i64, v6 | (unsigned __int64)v7);
    v8 = v3;
    v9 = 4167;
  }
  else
  {
    if ( (v7 & 8) != 0 )
      v6 = 8;
    if ( (v7 & 0x40) != 0 )
      v6 |= 0x40u;
    if ( (v7 & 0x800) != 0 )
      v6 |= 0x800u;
    v9 = 4150;
    v8 = v7 & ~v6;
  }
  return SendMessageW(hWnd, v9, 0i64, v8);
}

//----- (0000000140080240) ----------------------------------------------------
__int64 __fastcall sub_140080240(__int64 a1, __int64 a2, _QWORD *a3, HMODULE a4)
{
  int v8; // ebx
  HRESULT (__stdcall *WMCreateEditor)(IWMMetadataEditor **); // rax
  void *v10; // rax
  __int16 v12[2]; // [rsp+30h] [rbp-38h] BYREF
  __int16 v13[2]; // [rsp+34h] [rbp-34h] BYREF
  char v14[8]; // [rsp+38h] [rbp-30h] BYREF
  __int64 v15; // [rsp+40h] [rbp-28h] BYREF
  __int64 v16[4]; // [rsp+48h] [rbp-20h] BYREF

  v16[0] = 0i64;
  v15 = 0i64;
  v8 = -2147467259;
  WMCreateEditor = (HRESULT (__stdcall *)(IWMMetadataEditor **))GetProcAddress(a4, "WMCreateEditor");
  if ( WMCreateEditor )
  {
    v8 = ((__int64 (__fastcall *)(__int64 *))WMCreateEditor)(v16);
    if ( v8 >= 0 )
    {
      v8 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v16[0] + 24i64))(v16[0], a1);
      if ( v8 >= 0 )
      {
        v8 = (**(__int64 (__fastcall ***)(__int64, void *, __int64 *))v16[0])(v16[0], &unk_1400F78D0, &v15);
        if ( v8 >= 0 )
        {
          v13[0] = 0;
          v8 = (*(__int64 (__fastcall **)(__int64, __int16 *, __int64, char *, _QWORD, __int16 *))(*(_QWORD *)v15 + 40i64))(
                 v15,
                 v13,
                 a2,
                 v14,
                 0i64,
                 v12);
          if ( v8 >= 0 )
          {
            v10 = malloc(2i64 * (unsigned __int16)v12[0]);
            *a3 = v10;
            if ( v10 )
              v8 = (*(__int64 (__fastcall **)(__int64, __int16 *, __int64, char *, void *, __int16 *))(*(_QWORD *)v15 + 40i64))(
                     v15,
                     v13,
                     a2,
                     v14,
                     v10,
                     v12);
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
        }
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v16[0] + 16i64))(v16[0]);
    }
  }
  FreeLibrary(a4);
  return (unsigned int)v8;
}
// 140080240: using guessed type __int64 var_20[4];
// 140080240: using guessed type char var_30[8];

//----- (0000000140080390) ----------------------------------------------------
__int64 __fastcall sub_140080390(LPCWSTR lptstrFilename, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3; // ebx
  DWORD FileVersionInfoSizeW; // esi
  void *v8; // rax
  void *v9; // rdi
  _DWORD *v10; // rcx
  unsigned int puLen; // [rsp+58h] [rbp+10h] BYREF
  DWORD dwHandle; // [rsp+60h] [rbp+18h] BYREF
  LPVOID lpBuffer; // [rsp+68h] [rbp+20h] BYREF

  v3 = 0;
  *a2 = 0;
  lpBuffer = 0i64;
  *a3 = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(lptstrFilename, &dwHandle);
  if ( !FileVersionInfoSizeW )
    return 0i64;
  v8 = malloc(FileVersionInfoSizeW);
  v9 = v8;
  if ( v8 )
  {
    GetFileVersionInfoW(lptstrFilename, 0, FileVersionInfoSizeW, v8);
    VerQueryValueW(v9, &SubBlock, &lpBuffer, &puLen);
    if ( puLen )
    {
      v10 = lpBuffer;
      v3 = 1;
      *a2 = *((_DWORD *)lpBuffer + 5);
      *a3 = v10[4];
    }
    free(v9);
  }
  return v3;
}

//----- (0000000140080450) ----------------------------------------------------
__int64 __fastcall sub_140080450(LPCWSTR lptstrFilename, size_t Size)
{
  unsigned __int16 v3; // bx
  DWORD v4; // esi
  void *v5; // rax
  void *v6; // rdi
  unsigned int puLen; // [rsp+48h] [rbp+10h] BYREF
  LPVOID lpBuffer; // [rsp+50h] [rbp+18h] BYREF

  v3 = 0;
  lpBuffer = 0i64;
  v4 = Size;
  v5 = malloc((unsigned int)Size);
  v6 = v5;
  if ( v5 )
  {
    GetFileVersionInfoW(lptstrFilename, 0, v4, v5);
    VerQueryValueW(v6, L"\\VarFileInfo\\Translation", &lpBuffer, &puLen);
    if ( puLen >= 4 )
      v3 = *(_WORD *)lpBuffer & 0x3FF;
    free(v6);
  }
  return v3;
}

//----- (00000001400804E0) ----------------------------------------------------
__int64 __fastcall sub_1400804E0(__int64 a1, void *a2)
{
  unsigned int ModuleFileName; // ebx

  ModuleFileName = GetModuleFileNameExW(a2, 0i64, a1, 260i64);
  CloseHandle(a2);
  return ModuleFileName;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140080520) ----------------------------------------------------
LONG_PTR __fastcall sub_140080520(HWND a1, unsigned int a2, int a3)
{
  __int64 v3; // rdi
  LONG_PTR WindowLongPtrW; // rax
  LONG_PTR v7; // r8

  v3 = a2;
  WindowLongPtrW = GetWindowLongPtrW(a1, -16);
  v7 = WindowLongPtrW;
  if ( a3 )
  {
    if ( ((unsigned int)WindowLongPtrW & (unsigned int)v3) != v3 )
      v7 = v3 | WindowLongPtrW;
  }
  else if ( (WindowLongPtrW & v3) == v3 )
  {
    v7 = ~(_DWORD)v3 & (unsigned int)WindowLongPtrW;
  }
  return SetWindowLongPtrW(a1, -16, v7);
}

//----- (00000001400805D0) ----------------------------------------------------
__int16 *__fastcall sub_1400805D0(__int16 *a1, _WORD *a2)
{
  _WORD *v2; // r9
  int v3; // er8
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 *v7; // rcx

  v2 = a2;
  v3 = 0;
  if ( *a1 )
  {
    while ( *a1 == 32 || *a1 == 9 )
      ++a1;
    v5 = *a1;
    if ( *a1 == 34 )
    {
      v6 = a1[1];
      v7 = a1 + 1;
      if ( v6 )
      {
        do
        {
          if ( v6 == 34 )
            break;
          ++v7;
          *a2 = v6;
          ++v3;
          v6 = *v7;
          ++a2;
        }
        while ( *v7 );
      }
      a1 = v7 + 1;
    }
    else if ( v5 )
    {
      do
      {
        if ( v5 == 32 )
          break;
        if ( v5 == 9 )
          break;
        ++a1;
        *a2 = v5;
        ++v3;
        v5 = *a1;
        ++a2;
      }
      while ( *a1 );
    }
    v2[v3] = 0;
    while ( *a1 == 32 || *a1 == 9 )
      ++a1;
    return a1;
  }
  else
  {
    *a2 = 0;
    return 0i64;
  }
}

//----- (0000000140080690) ----------------------------------------------------
int __fastcall sub_140080690(LPCWSTR lpString)
{
  int v2; // edi
  int result; // eax
  WCHAR *v4; // rbx

  v2 = 0;
  result = lstrlenW(lpString);
  if ( result > 0 )
  {
    v4 = (WCHAR *)lpString;
    do
    {
      if ( *v4 == 10 )
        *v4 = 32;
      ++v2;
      ++v4;
      result = lstrlenW(lpString);
    }
    while ( v2 < result );
  }
  return result;
}

//----- (0000000140080700) ----------------------------------------------------
__int64 __fastcall sub_140080700(const WCHAR *a1)
{
  LPWSTR ExtensionW; // rax
  const WCHAR *v2; // rdi
  LPCWSTR *v3; // rbx

  ExtensionW = PathFindExtensionW(a1);
  if ( !ExtensionW )
    return 0i64;
  v2 = ExtensionW + 1;
  if ( ExtensionW == (LPWSTR)-2i64 )
    return 0i64;
  v3 = (LPCWSTR *)off_14012B9C0;
  while ( lstrcmpiW(v2, *v3) )
  {
    if ( (__int64)++v3 >= (__int64)aYes_0 )
      return 0i64;
  }
  return 1i64;
}
// 14012B9C0: using guessed type wchar_t *off_14012B9C0[10];
// 14012BA10: using guessed type wchar_t aYes_0[4];

//----- (0000000140080780) ----------------------------------------------------
const wchar_t *__fastcall sub_140080780(int a1)
{
  if ( !a1 )
    return L"Ready";
  if ( (a1 & 0x200) != 0 )
    return L"Busy";
  if ( (a1 & 2) != 0 )
    return L"Error";
  if ( (a1 & 0x8000) != 0 )
    return L"Initializing";
  if ( (a1 & 0x100) != 0 )
    return L"Active";
  if ( (a1 & 0x1000) != 0 )
    return L"Unavailable";
  if ( (a1 & 0x80u) != 0 )
    return L"Offline";
  if ( (a1 & 0x200000) != 0 )
    return L"Out of memory";
  if ( (a1 & 0x40000) != 0 )
    return L"Out of toner";
  return 0i64;
}
// 1400EC4B0: using guessed type wchar_t aReady[6];
// 1400EC4C0: using guessed type wchar_t aBusy[5];
// 1400EC4D8: using guessed type wchar_t aError[6];
// 1400EC4E8: using guessed type wchar_t aInitializing[13];
// 1400EC508: using guessed type wchar_t aActive[7];
// 1400EC518: using guessed type wchar_t aUnavailable[12];
// 1400EC530: using guessed type wchar_t aOffline[8];
// 1400EC540: using guessed type wchar_t aOutOfMemory[14];
// 1400EC560: using guessed type wchar_t aOutOfToner[13];

//----- (0000000140080810) ----------------------------------------------------
_BOOL8 __fastcall sub_140080810(LPCWSTR lpSrcStr, LPCWSTR a2, int a3)
{
  LPCWSTR v3; // rdi
  WCHAR v6; // ax
  int v7; // ecx
  WCHAR lpDestStr; // [rsp+40h] [rbp+8h] BYREF
  WCHAR DestStr; // [rsp+58h] [rbp+20h] BYREF

  v3 = lpSrcStr;
  v6 = *lpSrcStr;
  v7 = 1;
  if ( v6 )
  {
    while ( 1 )
    {
      if ( !*a2 || !v7 )
        goto LABEL_22;
      if ( v6 == 42 )
      {
        v7 = 0;
        if ( v3[1] )
          v7 = sub_140082100(++v3, a2, a3);
        for ( ; *v3; v7 = sub_140082100(v3, a2, a3) )
        {
          if ( !*a2 )
            break;
          if ( v7 )
            goto LABEL_17;
          ++a2;
        }
        if ( v7 )
        {
LABEL_17:
          while ( *v3 )
            ++v3;
          for ( --v3; *a2; ++a2 )
            ;
        }
        goto LABEL_21;
      }
      if ( v6 == 63 )
        goto LABEL_9;
      if ( !a3 )
        break;
      v7 = v6 == *a2++;
LABEL_21:
      v6 = v3[1];
      ++v3;
      if ( !v6 )
        goto LABEL_22;
    }
    LCMapStringW(0x400u, 0x100u, v3, 1, &DestStr, 1);
    LCMapStringW(0x400u, 0x100u, a2, 1, &lpDestStr, 1);
    v7 = DestStr == lpDestStr;
LABEL_9:
    ++a2;
    goto LABEL_21;
  }
LABEL_22:
  while ( *v3 == 42 )
    ++v3;
  return !*v3 && !*a2 && v7;
}

//----- (00000001400809C0) ----------------------------------------------------
LRESULT __fastcall sub_1400809C0(HWND a1, int a2, LPARAM a3)
{
  LPARAM lParam[7]; // [rsp+20h] [rbp-38h] BYREF

  lParam[2] = a3;
  LODWORD(lParam[0]) = 1;
  return SendMessageW(a1, 0x133Du, a2, (LPARAM)lParam);
}

//----- (00000001400809F0) ----------------------------------------------------
__int64 __fastcall sub_1400809F0(HWND hWnd, int a2, int a3)
{
  WPARAM v3; // r15
  WPARAM v4; // rbx
  __int64 result; // rax
  __int64 v7; // r13
  int v8; // er14
  WPARAM v9; // rsi
  __int64 v10; // rbx
  int v11; // edi
  int lParam[4]; // [rsp+20h] [rbp-E0h] BYREF
  char *v13; // [rsp+30h] [rbp-D0h]
  int v14; // [rsp+38h] [rbp-C8h]
  int v15; // [rsp+3Ch] [rbp-C4h]
  __int64 v16; // [rsp+40h] [rbp-C0h]
  char v17[1024]; // [rsp+50h] [rbp-B0h] BYREF
  char v18[1024]; // [rsp+450h] [rbp+350h] BYREF

  v3 = a2;
  v4 = a3;
  v13 = v17;
  lParam[0] = 11;
  v14 = 512;
  result = SendMessageW(hWnd, 0x133Cu, a2, (LPARAM)lParam);
  if ( (_DWORD)result )
  {
    v7 = v16;
    v8 = v15;
    v13 = v18;
    lParam[0] = 11;
    v14 = 512;
    v9 = v4;
    result = SendMessageW(hWnd, 0x133Cu, v4, (LPARAM)lParam);
    if ( (_DWORD)result )
    {
      v10 = v16;
      v11 = v15;
      v13 = v17;
      lParam[0] = 11;
      v16 = v7;
      v15 = v8;
      SendMessageW(hWnd, 0x133Du, v9, (LPARAM)lParam);
      v13 = v18;
      lParam[0] = 11;
      v16 = v10;
      v15 = v11;
      return SendMessageW(hWnd, 0x133Du, v3, (LPARAM)lParam);
    }
  }
  return result;
}
// 1400809F0: using guessed type _DWORD lParam[4];

//----- (0000000140080B70) ----------------------------------------------------
LRESULT __fastcall sub_140080B70(HWND a1, int a2, int a3)
{
  WPARAM v3; // rdi
  WPARAM v4; // rsi
  int v5; // er14
  LRESULT result; // rax
  int v8; // ebx
  HWND v9; // rax
  int v10; // eax
  __int64 v11; // r13
  int v12; // eax
  int v13; // ebx
  unsigned int v14; // ebx
  int lParam; // [rsp+20h] [rbp-E0h] BYREF
  int lParam_4; // [rsp+24h] [rbp-DCh]
  int v17; // [rsp+28h] [rbp-D8h]
  char *v18; // [rsp+38h] [rbp-C8h]
  int v19; // [rsp+40h] [rbp-C0h]
  LPARAM v20; // [rsp+70h] [rbp-90h] BYREF
  int v21; // [rsp+7Ch] [rbp-84h]
  int v22; // [rsp+80h] [rbp-80h]
  char v23[1024]; // [rsp+C0h] [rbp-40h] BYREF
  char v24[1024]; // [rsp+4C0h] [rbp+3C0h] BYREF
  char v25[1024]; // [rsp+8C0h] [rbp+7C0h] BYREF
  char v26[1024]; // [rsp+CC0h] [rbp+BC0h] BYREF

  v3 = a2;
  v4 = a3;
  v5 = 0;
  v18 = v25;
  lParam = 1;
  lParam_4 = a2;
  v17 = 0;
  v19 = 512;
  result = SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
  if ( (_DWORD)result )
  {
    lParam = 1;
    v18 = v23;
    lParam_4 = v4;
    v17 = 0;
    v19 = 512;
    result = SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
    if ( (_DWORD)result )
    {
      v18 = v23;
      lParam = 1;
      lParam_4 = v3;
      v17 = 0;
      SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
      v18 = v25;
      lParam = 1;
      lParam_4 = v4;
      v17 = 0;
      SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
      v8 = 1;
      v9 = (HWND)SendMessageW(a1, 0x101Fu, 0i64, 0i64);
      v10 = SendMessageW(v9, 0x1200u, 0i64, 0i64);
      if ( v10 > 0 )
      {
        v11 = (unsigned int)v10;
        do
        {
          lParam = 1;
          v18 = v26;
          lParam_4 = v3;
          v17 = v8;
          v19 = 512;
          SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
          v18 = v24;
          lParam = 1;
          lParam_4 = v4;
          v17 = v8;
          v19 = 512;
          SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
          v18 = v24;
          lParam = 1;
          lParam_4 = v3;
          v17 = v8;
          SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
          v18 = v26;
          lParam = 1;
          lParam_4 = v4;
          v17 = v8;
          SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
          ++v8;
          --v11;
        }
        while ( v11 );
      }
      v12 = SendMessageW(a1, 0x102Cu, v3, 7i64);
      v22 = 7;
      v13 = v12;
      v21 = SendMessageW(a1, 0x102Cu, v4, 7i64);
      SendMessageW(a1, 0x102Bu, v3, (LPARAM)&v20);
      v22 = 7;
      v21 = v13;
      SendMessageW(a1, 0x102Bu, v4, (LPARAM)&v20);
      v14 = (unsigned int)SendMessageW(a1, 0x102Cu, v3, 61440i64) >> 12;
      v22 = 61440;
      v21 = (((unsigned int)SendMessageW(a1, 0x102Cu, v4, 61440i64) >> 12 != 1) + 1) << 12;
      SendMessageW(a1, 0x102Bu, v3, (LPARAM)&v20);
      LOBYTE(v5) = v14 != 1;
      v22 = 61440;
      v21 = (v5 + 1) << 12;
      return SendMessageW(a1, 0x102Bu, v4, (LPARAM)&v20);
    }
  }
  return result;
}

//----- (0000000140080F00) ----------------------------------------------------
LRESULT __fastcall sub_140080F00(HWND a1, int a2, int a3)
{
  WPARAM v3; // rdi
  WPARAM v4; // rsi
  int v5; // er14
  LRESULT result; // rax
  __int64 v8; // rbx
  int v9; // ebx
  HWND v10; // rax
  int v11; // er13
  int v12; // eax
  int v13; // ebx
  unsigned int v14; // ebx
  int lParam; // [rsp+20h] [rbp-E0h] BYREF
  int lParam_4; // [rsp+24h] [rbp-DCh]
  int v17; // [rsp+28h] [rbp-D8h]
  char *v18; // [rsp+38h] [rbp-C8h]
  int v19; // [rsp+40h] [rbp-C0h]
  __int64 v20; // [rsp+48h] [rbp-B8h]
  LPARAM v21; // [rsp+70h] [rbp-90h] BYREF
  int v22; // [rsp+7Ch] [rbp-84h]
  int v23; // [rsp+80h] [rbp-80h]
  char v24[1024]; // [rsp+C0h] [rbp-40h] BYREF
  char v25[1024]; // [rsp+4C0h] [rbp+3C0h] BYREF
  char v26[1024]; // [rsp+8C0h] [rbp+7C0h] BYREF
  char v27[1024]; // [rsp+CC0h] [rbp+BC0h] BYREF

  v3 = a2;
  v4 = a3;
  v5 = 0;
  v18 = v26;
  lParam = 5;
  lParam_4 = a2;
  v17 = 0;
  v19 = 512;
  result = SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
  if ( (_DWORD)result )
  {
    v8 = v20;
    v18 = v24;
    lParam = 5;
    lParam_4 = v4;
    v17 = 0;
    v19 = 512;
    result = SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
    if ( (_DWORD)result )
    {
      v18 = v24;
      lParam = 5;
      lParam_4 = v3;
      v17 = 0;
      SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
      v18 = v26;
      lParam = 5;
      lParam_4 = v4;
      v17 = 0;
      v20 = v8;
      SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
      v9 = 1;
      v10 = (HWND)SendMessageW(a1, 0x101Fu, 0i64, 0i64);
      v11 = SendMessageW(v10, 0x1200u, 0i64, 0i64);
      if ( v11 > 1 )
      {
        do
        {
          lParam = 1;
          v18 = v27;
          lParam_4 = v3;
          v17 = v9;
          v19 = 512;
          SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
          v18 = v25;
          lParam = 1;
          lParam_4 = v4;
          v17 = v9;
          v19 = 512;
          SendMessageW(a1, 0x104Bu, 0i64, (LPARAM)&lParam);
          v18 = v25;
          lParam = 1;
          lParam_4 = v3;
          v17 = v9;
          SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
          v18 = v27;
          lParam = 1;
          lParam_4 = v4;
          v17 = v9;
          SendMessageW(a1, 0x104Cu, 0i64, (LPARAM)&lParam);
          ++v9;
        }
        while ( v9 < v11 );
      }
      v12 = SendMessageW(a1, 0x102Cu, v3, 7i64);
      v23 = 7;
      v13 = v12;
      v22 = SendMessageW(a1, 0x102Cu, v4, 7i64);
      SendMessageW(a1, 0x102Bu, v3, (LPARAM)&v21);
      v23 = 7;
      v22 = v13;
      SendMessageW(a1, 0x102Bu, v4, (LPARAM)&v21);
      v14 = (unsigned int)SendMessageW(a1, 0x102Cu, v3, 61440i64) >> 12;
      v23 = 61440;
      v22 = (((unsigned int)SendMessageW(a1, 0x102Cu, v4, 61440i64) >> 12 != 1) + 1) << 12;
      SendMessageW(a1, 0x102Bu, v3, (LPARAM)&v21);
      LOBYTE(v5) = v14 != 1;
      v23 = 61440;
      v22 = (v5 + 1) << 12;
      return SendMessageW(a1, 0x102Bu, v4, (LPARAM)&v21);
    }
  }
  return result;
}

//----- (0000000140081290) ----------------------------------------------------
LONG_PTR __fastcall sub_140081290(HWND a1, int a2)
{
  unsigned int WindowLongW; // eax

  WindowLongW = GetWindowLongW(a1, -16);
  if ( a2 )
  {
    if ( (WindowLongW & 0x100) == 0 )
      WindowLongW |= 0x100u;
  }
  else if ( (WindowLongW & 0x100) != 0 )
  {
    WindowLongW &= ~0x100u;
  }
  return SetWindowLongPtrW(a1, -16, WindowLongW);
}

//----- (00000001400812F0) ----------------------------------------------------
BOOL __fastcall sub_1400812F0(HWND a1, WCHAR *a2, const WCHAR *a3)
{
  struct tagOFNW v4; // [rsp+20h] [rbp-A8h] BYREF

  v4.hwndOwner = a1;
  v4.lStructSize = 152;
  v4.lpstrCustomFilter = 0i64;
  v4.lpstrFilter = L"Text Document (*.txt)";
  *(_QWORD *)&v4.nMaxCustFilter = 0i64;
  v4.lpstrFile = a2;
  v4.nMaxFile = 260;
  v4.lpstrFileTitle = 0i64;
  v4.nMaxFileTitle = 0;
  v4.lpstrTitle = 0i64;
  v4.lCustData = 0i64;
  v4.lpfnHook = 0i64;
  v4.pvReserved = 0i64;
  *(_QWORD *)&v4.dwReserved = 0i64;
  v4.lpstrInitialDir = a3;
  v4.Flags = 8912898;
  v4.lpstrDefExt = L"txt";
  return GetSaveFileNameW(&v4);
}
// 1400EC430: using guessed type wchar_t aTextDocumentTx[22];
// 1400EC488: using guessed type wchar_t aTxt[4];

//----- (0000000140081380) ----------------------------------------------------
__int64 __fastcall sub_140081380(const WCHAR *a1)
{
  HANDLE FileW; // rax
  void *v2; // rdi
  __int64 result; // rax
  BOOL FileInformationByHandle; // ebx
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [rsp+40h] [rbp-48h] BYREF

  FileW = CreateFileW(a1, 0x80u, 1u, 0i64, 3u, 0, 0i64);
  v2 = FileW;
  if ( FileW == (HANDLE)-1i64 )
    return 0i64;
  FileInformationByHandle = GetFileInformationByHandle(FileW, &FileInformation);
  CloseHandle(v2);
  result = FileInformation.nNumberOfLinks;
  if ( !FileInformationByHandle )
    return 0i64;
  return result;
}

//----- (0000000140081430) ----------------------------------------------------
_BOOL8 __fastcall sub_140081430(int a1)
{
  DWORD v1; // er9
  int v2; // ecx
  int v3; // ecx
  BOOL IsMember; // [rsp+60h] [rbp-28h] BYREF
  PSID SidToCheck; // [rsp+68h] [rbp-20h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [rsp+70h] [rbp-18h] BYREF

  *(_DWORD *)pIdentifierAuthority.Value = 0;
  *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
  v1 = 0;
  IsMember = 0;
  if ( a1 )
  {
    v2 = a1 - 1;
    if ( v2 )
    {
      v3 = v2 - 1;
      if ( v3 )
      {
        if ( v3 == 1 )
          v1 = 546;
      }
      else
      {
        v1 = 545;
      }
    }
    else
    {
      v1 = 547;
    }
  }
  else
  {
    v1 = 544;
  }
  if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, v1, 0, 0, 0, 0, 0, 0, &SidToCheck) )
  {
    CheckTokenMembership(0i64, SidToCheck, &IsMember);
    FreeSid(SidToCheck);
  }
  return IsMember;
}

//----- (0000000140081530) ----------------------------------------------------
LRESULT __fastcall sub_140081530(HWND a1, int a2)
{
  unsigned int v4; // eax

  v4 = SendMessageW(a1, 0x1037u, 0i64, 0i64);
  if ( a2 )
  {
    v4 |= 1u;
  }
  else if ( (v4 & 1) != 0 )
  {
    v4 &= ~1u;
  }
  return SendMessageW(a1, 0x1036u, 0i64, v4);
}

//----- (00000001400815D0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400815D0(const WCHAR *a1, const WCHAR *a2)
{
  SHFILEINFOW v4; // [rsp+30h] [rbp-598h] BYREF
  SHFILEINFOW psfi; // [rsp+2F0h] [rbp-2D8h] BYREF

  SHGetFileInfoW(a1, 0, &psfi, 0x2B8u, 0x400u);
  SHGetFileInfoW(a2, 0, &v4, 0x2B8u, 0x400u);
  return StrCmpW(psfi.szTypeName, v4.szTypeName) == 0;
}

//----- (0000000140081670) ----------------------------------------------------
BOOL __fastcall sub_140081670(LPCWSTR lpName, int a2, void *a3)
{
  HANDLE TokenHandle; // [rsp+30h] [rbp-38h] BYREF
  struct _LUID Luid; // [rsp+38h] [rbp-30h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+40h] [rbp-28h] BYREF

  OpenProcessToken(a3, 0xF01FFu, &TokenHandle);
  LookupPrivilegeValueW(0i64, lpName, &Luid);
  NewState.Privileges[0].Luid = Luid;
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Attributes = a2 != 0 ? 2 : 0;
  CloseHandle(a3);
  return AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0i64, 0i64);
}

//----- (0000000140081730) ----------------------------------------------------
BOOL __fastcall sub_140081730(SYSTEMTIME *lpLocalTime, LPFILETIME lpFileTime)
{
  struct _SYSTEMTIME UniversalTime; // [rsp+20h] [rbp-28h] BYREF

  TzSpecificLocalTimeToSystemTime(0i64, lpLocalTime, &UniversalTime);
  return SystemTimeToFileTime(&UniversalTime, lpFileTime);
}

//----- (0000000140081780) ----------------------------------------------------
BOOL __fastcall sub_140081780(const FILETIME *a1, struct _SYSTEMTIME *a2)
{
  struct _SYSTEMTIME SystemTime; // [rsp+20h] [rbp-28h] BYREF

  FileTimeToSystemTime(a1, &SystemTime);
  return SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, a2);
}

//----- (00000001400817D0) ----------------------------------------------------
__int64 __fastcall sub_1400817D0(HMENU a1, UINT a2, int a3)
{
  if ( a3 )
  {
    EnableMenuItem(a1, a2, 0);
    return 1i64;
  }
  else
  {
    EnableMenuItem(a1, a2, 1u);
    return 0i64;
  }
}

//----- (0000000140081810) ----------------------------------------------------
__int64 __fastcall sub_140081810(HMENU a1, UINT a2, int a3)
{
  if ( a3 )
  {
    CheckMenuItem(a1, a2, 8u);
    return 1i64;
  }
  else
  {
    CheckMenuItem(a1, a2, 0);
    return 0i64;
  }
}

//----- (0000000140081850) ----------------------------------------------------
HINSTANCE __fastcall sub_140081850(LPCWSTR lpParameters)
{
  WCHAR pszFile[4]; // [rsp+30h] [rbp-448h] BYREF
  __int64 v4; // [rsp+38h] [rbp-440h]
  WCHAR pszPath[264]; // [rsp+40h] [rbp-438h] BYREF
  WCHAR pszDest[264]; // [rsp+250h] [rbp-228h] BYREF

  *(_QWORD *)pszFile = 0x2E0064006D0063i64;
  v4 = 0x6500780065i64;
  if ( !SHGetSpecialFolderPathW(0i64, pszPath, 37, 0) )
    return 0i64;
  PathCombineW(pszDest, pszPath, pszFile);
  return ShellExecuteW(0i64, L"open", pszDest, lpParameters, lpParameters, 5);
}

//----- (0000000140081900) ----------------------------------------------------
LRESULT __fastcall sub_140081900(HWND hWnd, __int64 a2)
{
  int v5; // ebx
  int v6; // er13
  LPARAM v7; // rax
  int v8; // eax
  int v9; // eax
  int v10; // er12
  int v11; // eax
  int v12[6]; // [rsp+20h] [rbp-39h] BYREF
  LPARAM v13; // [rsp+38h] [rbp-21h]
  int v14; // [rsp+40h] [rbp-19h]
  LPARAM v15; // [rsp+48h] [rbp-11h] BYREF
  int v16; // [rsp+50h] [rbp-9h]
  int v17; // [rsp+54h] [rbp-5h]
  LPARAM lParam; // [rsp+58h] [rbp-1h] BYREF
  int v19; // [rsp+60h] [rbp+7h]
  LPARAM v20; // [rsp+68h] [rbp+Fh] BYREF
  char v21; // [rsp+70h] [rbp+17h]
  int v22; // [rsp+74h] [rbp+1Bh]

  if ( !a2 )
  {
    lParam = 16i64;
    v19 = -1;
    return SendMessageW(hWnd, 0x10A6u, 0i64, (LPARAM)&lParam);
  }
  v20 = *(_QWORD *)a2;
  v5 = SendMessageW(hWnd, 0x1012u, 0i64, (LPARAM)&v20);
  if ( v5 == -1 || (v21 & 0xE) == 0 )
  {
    v13 = *(_QWORD *)a2;
    v6 = 0;
    v12[0] = 64;
    v14 = 38;
    v5 = SendMessageW(hWnd, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v12);
    if ( v5 == -1 )
    {
      v7 = *(_QWORD *)a2;
      v12[0] = 64;
      v13 = v7;
      v14 = 37;
      v5 = SendMessageW(hWnd, 0x1053u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v12);
    }
    LODWORD(v15) = 0;
    SendMessageW(hWnd, 0x100Eu, v5, (LPARAM)&v15);
    if ( *(_DWORD *)a2 > (int)v15 + (v16 - (int)v15) / 2 )
    {
      if ( *(_DWORD *)(a2 + 4) > v17 )
      {
        v8 = SendMessageW(hWnd, 0x100Cu, v5, 512i64);
        if ( v8 != -1 )
          v5 = v8;
      }
      v6 = 1;
    }
    v9 = SendMessageW(hWnd, 0x1004u, 0i64, 0i64);
    LODWORD(v15) = 0;
    v10 = v9 - 1;
    SendMessageW(hWnd, 0x100Eu, v9 - 1, (LPARAM)&v15);
    v11 = (v16 - (int)v15) / 2;
    if ( *(_DWORD *)a2 <= v11 + (int)v15 || *(_DWORD *)a2 >= v11 + v16 + 2 || *(_DWORD *)(a2 + 4) <= SHIDWORD(v15) )
      goto LABEL_19;
    v5 = v10;
    goto LABEL_18;
  }
  LODWORD(v15) = 0;
  SendMessageW(hWnd, 0x100Eu, v22, (LPARAM)&v15);
  if ( *(_DWORD *)a2 - (int)v15 > (v16 - (int)v15) / 2 )
  {
LABEL_18:
    v6 = 1;
    goto LABEL_19;
  }
  v6 = 0;
LABEL_19:
  LODWORD(lParam) = 16;
  HIDWORD(lParam) = v6;
  v19 = v5;
  return SendMessageW(hWnd, 0x10A6u, 0i64, (LPARAM)&lParam);
}
// 140081900: using guessed type _DWORD var_90[6];

//----- (0000000140081B50) ----------------------------------------------------
LRESULT __fastcall sub_140081B50(HWND a1, int a2)
{
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v4; // [rsp+2Ch] [rbp-4Ch]
  int v5; // [rsp+30h] [rbp-48h]

  v5 = 1;
  v4 = 1;
  return SendMessageW(a1, 0x102Bu, a2, (LPARAM)&lParam);
}

//----- (0000000140081B90) ----------------------------------------------------
LRESULT __fastcall sub_140081B90(HWND a1, int a2, int a3)
{
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v5; // [rsp+2Ch] [rbp-4Ch]
  int v6; // [rsp+30h] [rbp-48h]

  v6 = 2;
  v5 = a3 != 0 ? 2 : 0;
  return SendMessageW(a1, 0x102Bu, a2, (LPARAM)&lParam);
}

//----- (0000000140081BD0) ----------------------------------------------------
__int64 __fastcall sub_140081BD0(HWND hWnd)
{
  unsigned int v2; // ebp
  int v4; // eax
  __int64 v5; // rsi
  WPARAM v6; // rbx
  int v7; // eax
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v9; // [rsp+2Ch] [rbp-4Ch]
  int v10; // [rsp+30h] [rbp-48h]

  v2 = 0;
  if ( !hWnd )
    return 0xFFFFFFFFi64;
  v4 = SendMessageW(hWnd, 0x1004u, 0i64, 0i64);
  if ( v4 > 0 )
  {
    v5 = (unsigned int)v4;
    v6 = 0i64;
    do
    {
      v7 = SendMessageW(hWnd, 0x102Cu, v6, 2i64);
      v10 = 2;
      if ( v7 == 2 )
      {
        v9 = 0;
        SendMessageW(hWnd, 0x102Bu, v6, (LPARAM)&lParam);
      }
      else
      {
        v9 = 2;
        SendMessageW(hWnd, 0x102Bu, v6, (LPARAM)&lParam);
        ++v2;
      }
      ++v6;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}

//----- (0000000140081CC0) ----------------------------------------------------
__int64 __fastcall sub_140081CC0(HWND hWnd)
{
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v4; // [rsp+2Ch] [rbp-4Ch]
  int v5; // [rsp+30h] [rbp-48h]

  if ( !hWnd )
    return 0xFFFFFFFFi64;
  SendMessageW(hWnd, 0xBu, 0i64, 0i64);
  v5 = 2;
  v4 = 0;
  SendMessageW(hWnd, 0x102Bu, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)&lParam);
  SendMessageW(hWnd, 0xBu, 1ui64, 0i64);
  return 0i64;
}

//----- (0000000140081D30) ----------------------------------------------------
__int64 __fastcall sub_140081D30(HWND hWnd)
{
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v4; // [rsp+2Ch] [rbp-4Ch]
  int v5; // [rsp+30h] [rbp-48h]

  if ( !hWnd )
    return 0xFFFFFFFFi64;
  SendMessageW(hWnd, 0xBu, 0i64, 0i64);
  v5 = 2;
  v4 = 2;
  SendMessageW(hWnd, 0x102Bu, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)&lParam);
  SendMessageW(hWnd, 0xBu, 1ui64, 0i64);
  return 0i64;
}

//----- (0000000140081E00) ----------------------------------------------------
BOOL __fastcall sub_140081E00(HWND hWndFrom, HWND hWnd)
{
  struct tagPOINT Points; // [rsp+40h] [rbp-38h] BYREF
  struct tagRECT v6; // [rsp+48h] [rbp-30h] BYREF
  struct tagRECT Rect; // [rsp+58h] [rbp-20h] BYREF

  GetClientRect(hWndFrom, &Rect);
  GetClientRect(hWnd, &v6);
  Points.x = (v6.left + Rect.right - v6.right - Rect.left) / 2;
  Points.y = (int)((double)(Rect.bottom + v6.top - v6.bottom - Rect.top) * 0.45);
  MapWindowPoints(hWndFrom, 0i64, &Points, 1u);
  return SetWindowPos(hWnd, 0i64, Points.x, Points.y, 0, 0, 0x45u);
}

//----- (0000000140081EE0) ----------------------------------------------------
__int64 __fastcall sub_140081EE0(_BYTE *a1)
{
  __int64 v17; // rcx
  signed __int64 v18; // rdx
  __int64 result; // rax
  __int128 v20; // [rsp+0h] [rbp-60h]
  __int128 v21[4]; // [rsp+10h] [rbp-50h] BYREF

  _RAX = 2147483650i64;
  __asm { cpuid }
  *((_QWORD *)&v20 + 1) = __PAIR64__(_RDX, _RCX);
  *(_QWORD *)&v20 = __PAIR64__(_RBX, _RAX);
  _RAX = 2147483651i64;
  __asm { cpuid }
  v21[0] = v20;
  HIDWORD(v20) = _RDX;
  LODWORD(v20) = _RAX;
  *(_QWORD *)((char *)&v20 + 4) = __PAIR64__(_RCX, _RBX);
  _RAX = 2147483652i64;
  __asm { cpuid }
  v21[1] = v20;
  *((_QWORD *)&v20 + 1) = __PAIR64__(_RDX, _RCX);
  *(_QWORD *)&v20 = __PAIR64__(_RBX, _RAX);
  v17 = 64i64;
  v18 = (char *)v21 - a1;
  v21[2] = v20;
  while ( 1 )
  {
    result = v17 + 2147483582;
    if ( v17 == -2147483582 )
      break;
    result = (unsigned __int8)a1[v18];
    if ( !(_BYTE)result )
      break;
    *a1++ = result;
    if ( !--v17 )
    {
      *(a1 - 1) = 0;
      return result;
    }
  }
  *a1 = 0;
  return result;
}
// 140081F9A: conditional instruction was optimized away because rcx.8!=0

//----- (0000000140081FD0) ----------------------------------------------------
HRESULT __fastcall sub_140081FD0(const ITEMIDLIST *a1, _WORD *a2)
{
  HRESULT result; // eax
  int v4; // ebx
  LPCITEMIDLIST v5; // [rsp+40h] [rbp-18h] BYREF
  __int64 v6; // [rsp+48h] [rbp-10h] BYREF
  __int64 v7; // [rsp+70h] [rbp+18h] BYREF
  void *v8; // [rsp+78h] [rbp+20h] BYREF

  v8 = 0i64;
  v7 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  result = SHBindToParent(a1, &stru_1400E3FB0, &v8, &v5);
  if ( result >= 0 )
  {
    v4 = (*(__int64 (__fastcall **)(void *, _QWORD, __int64, LPCITEMIDLIST *, void *, _QWORD, __int64 *))(*(_QWORD *)v8 + 80i64))(
           v8,
           0i64,
           1i64,
           &v5,
           &unk_1400E3FF0,
           0i64,
           &v7);
    if ( v4 >= 0 )
    {
      v4 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v7 + 24i64))(v7, 1i64, &v6);
      if ( v4 >= 0 )
        sub_140001240(a2, 0x400ui64, v6);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
    }
    (*(void (__fastcall **)(void *))(*(_QWORD *)v8 + 16i64))(v8);
    return v4;
  }
  return result;
}

//----- (00000001400820A0) ----------------------------------------------------
__int64 __fastcall sub_1400820A0(__int64 a1, _WORD *a2)
{
  __int64 result; // rax
  unsigned int v4; // ebx
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  pv[0] = 0i64;
  if ( !a1 )
    return 2147500037i64;
  result = sub_14007F810(a1, (__int64)pv);
  if ( (int)result >= 0 )
  {
    v4 = sub_140081FD0((const ITEMIDLIST *)pv[0], a2);
    CoTaskMemFree(pv[0]);
    return v4;
  }
  return result;
}
// 1400820A0: using guessed type LPVOID pv[3];

//----- (0000000140082100) ----------------------------------------------------
__int64 __fastcall sub_140082100(LPCWSTR lpSrcStr, LPCWSTR a2, int a3)
{
  int v5; // esi
  LPCWSTR i; // rbx
  __int64 v9; // rdx
  signed __int64 v10; // rdi
  wchar_t *v11; // rcx
  wchar_t v12; // ax
  WCHAR *v13; // rbx
  wchar_t *Context[2]; // [rsp+20h] [rbp-448h] BYREF
  wchar_t String[512]; // [rsp+30h] [rbp-438h] BYREF

  v5 = 0;
  if ( lstrlenW(lpSrcStr) <= 0 )
    return sub_140080810(lpSrcStr, a2, a3);
  for ( i = lpSrcStr; *i != 58; ++i )
  {
    if ( ++v5 >= lstrlenW(lpSrcStr) )
      return sub_140080810(lpSrcStr, a2, a3);
  }
  Context[0] = 0i64;
  v9 = 512i64;
  v10 = (char *)lpSrcStr - (char *)String;
  v11 = String;
  while ( v9 != -2147483134 )
  {
    v12 = *(wchar_t *)((char *)v11 + v10);
    if ( !v12 )
      break;
    *v11++ = v12;
    if ( !--v9 )
    {
      --v11;
      break;
    }
  }
  *v11 = 0;
  v13 = wcstok_s(String, asc_1400EACE4, Context);
  PathRemoveBlanksW(v13);
  if ( !v13 )
    return 0i64;
  while ( !sub_140080810(v13, a2, a3) )
  {
    v13 = wcstok_s(Context[0], asc_1400EACFC, Context);
    PathRemoveBlanksW(v13);
    if ( !v13 )
      return 0i64;
  }
  return 1i64;
}
// 1400821D6: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140082260) ----------------------------------------------------
__int64 __fastcall sub_140082260(HWND hWnd, int a2)
{
  unsigned int v5; // ebx
  __int16 *v6; // r11
  LPARAM lParam[3]; // [rsp+30h] [rbp-468h] BYREF
  int v8; // [rsp+4Ch] [rbp-44Ch]
  int v9; // [rsp+50h] [rbp-448h]
  WCHAR Filename[264]; // [rsp+60h] [rbp-438h] BYREF
  __int16 v11[264]; // [rsp+270h] [rbp-228h] BYREF

  if ( !hWnd )
    return 2147942487i64;
  GetModuleFileNameW(0i64, Filename, 0x104u);
  LODWORD(lParam[0]) = 2;
  sub_140001000((wchar_t *)v11, 0x104ui64, L"res://%s/#2/#%d", Filename, a2);
  v5 = 0;
  v6 = v11;
  if ( !a2 )
    v6 = 0i64;
  v8 = 45;
  lParam[2] = (LPARAM)v6;
  v9 = 50;
  if ( !(unsigned int)SendMessageW(hWnd, 0x108Au, 0i64, (LPARAM)lParam) )
    return (unsigned int)-2147467259;
  return v5;
}
// 1400EC490: using guessed type wchar_t aResS2D[16];
// 140082260: using guessed type wchar_t var_228[264];

//----- (0000000140082350) ----------------------------------------------------
__int64 __fastcall sub_140082350(__int64 a1, int a2, WCHAR *a3)
{
  unsigned int v6; // edi
  __int64 v7; // rbx
  __int64 v8; // r11
  char *v9; // rcx
  __int16 v10; // ax
  __int64 v11; // rbx
  int v12; // eax
  __int64 v14; // rcx
  int ImageWidth; // eax
  const wchar_t *v16; // r8
  int ImageHeight; // eax
  int PropertySize; // eax
  _DWORD *v19; // rax
  _DWORD *v20; // r12
  unsigned int v21; // edx
  int AllPropertyItems; // eax
  __int64 v23; // rax
  _DWORD *v24; // rcx
  _DWORD *v25; // rcx
  unsigned int v26; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v27; // [rsp+34h] [rbp-CCh] BYREF
  size_t Size; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v29; // [rsp+40h] [rbp-C0h] BYREF
  int v30; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v31; // [rsp+50h] [rbp-B0h]
  __int64 v32; // [rsp+58h] [rbp-A8h]
  char v33[528]; // [rsp+60h] [rbp-A0h] BYREF
  CHAR MultiByteStr[512]; // [rsp+270h] [rbp+170h] BYREF

  v6 = 0;
  v30 = 1;
  v31 = 0i64;
  v32 = 0i64;
  GdiplusStartup(&v29, &v30, 0i64);
  v7 = a1 - (_QWORD)v33;
  v8 = 260i64;
  v9 = v33;
  while ( v8 != -2147483386 )
  {
    v10 = *(_WORD *)&v9[v7];
    if ( !v10 )
      break;
    *(_WORD *)v9 = v10;
    v9 += 2;
    if ( !--v8 )
    {
      v9 -= 2;
      break;
    }
  }
  *(_WORD *)v9 = 0;
  v11 = GdipAlloc(24i64);
  if ( v11 )
  {
    *(_QWORD *)(v11 + 8) = 0i64;
    *(_QWORD *)v11 = &Gdiplus::Image::`vftable';
    *(_DWORD *)(v11 + 16) = GdipLoadImageFromFile(v33);
  }
  else
  {
    v11 = 0i64;
  }
  v12 = *(_DWORD *)(v11 + 16);
  *(_DWORD *)(v11 + 16) = 0;
  if ( v12 )
  {
    (**(void (__fastcall ***)(__int64, __int64))v11)(v11, 1i64);
    return 0i64;
  }
  v14 = *(_QWORD *)(v11 + 8);
  if ( a2 != 256 )
  {
    if ( a2 == 257 )
    {
      v26 = 0;
      ImageHeight = GdipGetImageHeight(v14, &v26);
      if ( ImageHeight )
        *(_DWORD *)(v11 + 16) = ImageHeight;
      v16 = L"%u pixels";
      goto LABEL_19;
    }
    PropertySize = GdipGetPropertySize(v14, &Size, &v27);
    if ( PropertySize )
      *(_DWORD *)(v11 + 16) = PropertySize;
    v19 = malloc((unsigned int)Size);
    v20 = v19;
    if ( v19 )
    {
      AllPropertyItems = GdipGetAllPropertyItems(*(_QWORD *)(v11 + 8), (unsigned int)Size, v27, v19);
      if ( AllPropertyItems )
      {
        *(_DWORD *)(v11 + 16) = AllPropertyItems;
        v21 = v27;
      }
      else
      {
        v21 = v27;
        v23 = 0i64;
        if ( v27 )
        {
          v24 = v20;
          while ( *v24 != a2 )
          {
            v23 = (unsigned int)(v23 + 1);
            v24 += 6;
            if ( (unsigned int)v23 >= v27 )
              goto LABEL_30;
          }
          goto LABEL_38;
        }
      }
    }
    else
    {
      *(_DWORD *)(v11 + 16) = 2;
      v21 = v27;
    }
LABEL_30:
    if ( a2 != 36867 || (v23 = 0i64, !v21) )
    {
LABEL_35:
      a3 = 0i64;
LABEL_36:
      MultiByteToWideChar(0, 0, MultiByteStr, -1, a3, 512);
      free(v20);
      goto LABEL_37;
    }
    v25 = v20;
    while ( *v25 != 306 )
    {
      v23 = (unsigned int)(v23 + 1);
      v25 += 6;
      if ( (unsigned int)v23 >= v21 )
        goto LABEL_35;
    }
LABEL_38:
    v6 = 1;
    memmove(MultiByteStr, *(const void **)&v20[6 * v23 + 4], (unsigned int)v20[6 * v23 + 1]);
    goto LABEL_36;
  }
  v26 = 0;
  ImageWidth = GdipGetImageWidth(v14, &v26);
  if ( ImageWidth )
    *(_DWORD *)(v11 + 16) = ImageWidth;
  v16 = L"%u pixels";
LABEL_19:
  v6 = 1;
  sub_140001000(a3, 0x200ui64, v16, v26);
LABEL_37:
  (**(void (__fastcall ***)(__int64, __int64))v11)(v11, 1i64);
  GdiplusShutdown(v29);
  return v6;
}
// 1400823E6: conditional instruction was optimized away because r11.8!=0
// 1400E3D18: using guessed type __int64 __fastcall GdiplusShutdown(_QWORD);
// 1400E3D20: using guessed type __int64 __fastcall GdipGetAllPropertyItems(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E3D28: using guessed type __int64 __fastcall GdipGetPropertySize(_QWORD, _QWORD, _QWORD);
// 1400E3D30: using guessed type __int64 __fastcall GdiplusStartup(_QWORD, _QWORD, _QWORD);
// 1400E3D58: using guessed type __int64 __fastcall GdipGetImageWidth(_QWORD, _QWORD);
// 1400E3D68: using guessed type __int64 __fastcall GdipGetImageHeight(_QWORD, _QWORD);
// 1400E3D88: using guessed type __int64 __fastcall GdipLoadImageFromFile(_QWORD);
// 1400E3D98: using guessed type __int64 __fastcall GdipAlloc(_QWORD);
// 1400EC358: using guessed type wchar_t aUPixels[10];
// 1400EC370: using guessed type wchar_t aUPixels_0[10];
// 1400F7468: using guessed type void *Gdiplus::Image::`vftable';

//----- (0000000140082600) ----------------------------------------------------
__int64 __fastcall sub_140082600(__int64 a1, int a2, WCHAR *a3)
{
  int v5; // esi
  HANDLE FileW; // rax
  void *v7; // rdi
  unsigned int v9; // ebx
  DWORD v10; // ebx
  void *v11; // rsi
  DWORD NumberOfBytesRead; // [rsp+40h] [rbp-C0h] BYREF
  DWORD nNumberOfBytesToRead; // [rsp+44h] [rbp-BCh] BYREF
  LONG Buffer; // [rsp+48h] [rbp-B8h] BYREF
  int v15; // [rsp+4Ch] [rbp-B4h] BYREF
  unsigned int v16; // [rsp+50h] [rbp-B0h] BYREF
  int v17; // [rsp+54h] [rbp-ACh] BYREF
  UINT CodePage; // [rsp+58h] [rbp-A8h] BYREF
  int v19; // [rsp+5Ch] [rbp-A4h] BYREF
  char v20[4]; // [rsp+60h] [rbp-A0h] BYREF
  char v21[12]; // [rsp+64h] [rbp-9Ch] BYREF
  WCHAR FileName[512]; // [rsp+70h] [rbp-90h] BYREF

  v15 = 0;
  v17 = 0;
  CodePage = 0;
  v5 = 0;
  sub_140001000(FileName, 0x200ui64, L"%s:%cSummaryInformation", a1, 5);
  FileW = CreateFileW(FileName, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
  v7 = FileW;
  if ( FileW == (HANDLE)-1i64 )
    return 0xFFFFFFFFi64;
  SetFilePointer(FileW, 44, 0i64, 1u);
  ReadFile(v7, &Buffer, 4u, &NumberOfBytesRead, 0i64);
  SetFilePointer(v7, Buffer, 0i64, 0);
  ReadFile(v7, v21, 4u, &NumberOfBytesRead, 0i64);
  ReadFile(v7, &v16, 4u, &NumberOfBytesRead, 0i64);
  v9 = 0;
  if ( !v16 )
    goto LABEL_15;
  do
  {
    ReadFile(v7, &v19, 4u, &NumberOfBytesRead, 0i64);
    if ( v19 == 1 )
    {
      ReadFile(v7, &v17, 4u, &NumberOfBytesRead, 0i64);
    }
    else if ( v19 == a2 )
    {
      v5 = 1;
      ReadFile(v7, &v15, 4u, &NumberOfBytesRead, 0i64);
    }
    else
    {
      SetFilePointer(v7, 4, 0i64, 1u);
    }
    ++v9;
  }
  while ( v9 < v16 );
  if ( !v5 )
    goto LABEL_15;
  if ( v17 )
  {
    SetFilePointer(v7, Buffer + v17 + 4, 0i64, 0);
    ReadFile(v7, &CodePage, 4u, &NumberOfBytesRead, 0i64);
  }
  SetFilePointer(v7, v15 + Buffer, 0i64, 0);
  ReadFile(v7, v20, 4u, &NumberOfBytesRead, 0i64);
  ReadFile(v7, &nNumberOfBytesToRead, 4u, &NumberOfBytesRead, 0i64);
  v10 = nNumberOfBytesToRead;
  v11 = malloc(nNumberOfBytesToRead);
  ReadFile(v7, v11, v10, &NumberOfBytesRead, 0i64);
  if ( NumberOfBytesRead == nNumberOfBytesToRead )
  {
    MultiByteToWideChar(CodePage, 1u, (LPCCH)v11, nNumberOfBytesToRead, a3, 512);
    nNumberOfBytesToRead = lstrlenW(a3) + 1;
    free(v11);
    CloseHandle(v7);
    return nNumberOfBytesToRead;
  }
  else
  {
LABEL_15:
    CloseHandle(v7);
    return 0xFFFFFFFFi64;
  }
}
// 1400EC2F8: using guessed type wchar_t aSCsummaryinfor[24];
// 140082600: using guessed type char var_43C[12];
// 140082600: using guessed type char var_440[4];

//----- (0000000140082920) ----------------------------------------------------
__int64 __fastcall sub_140082920(LPCWSTR lptstrFilename, __int64 a2, _WORD *a3, DWORD a4)
{
  unsigned int v5; // esi
  void *v9; // rax
  void *v10; // rbp
  unsigned __int8 UserDefaultLangID; // r12
  unsigned int v12; // edx
  unsigned int v13; // edi
  __int64 v14; // rbx
  unsigned __int16 v15; // cx
  __int64 v17; // [rsp+20h] [rbp-108h]
  unsigned int puLen; // [rsp+30h] [rbp-F8h] BYREF
  LPVOID lpBuffer; // [rsp+38h] [rbp-F0h] BYREF
  int v20[4]; // [rsp+40h] [rbp-E8h] BYREF
  WCHAR SubBlock[64]; // [rsp+50h] [rbp-D8h] BYREF

  v5 = 0;
  lpBuffer = 0i64;
  v9 = malloc(a4);
  v10 = v9;
  if ( v9 )
  {
    if ( GetFileVersionInfoW(lptstrFilename, 0, a4, v9) )
    {
      UserDefaultLangID = GetUserDefaultLangID();
      VerQueryValueW(v10, L"\\VarFileInfo\\Translation", &::lpBuffer, &puLen);
      v12 = puLen;
      v13 = 0;
      if ( (puLen & 0xFFFFFFFC) != 0 )
      {
        v14 = 0i64;
        do
        {
          v15 = *(_WORD *)((char *)::lpBuffer + v14);
          if ( (unsigned __int8)v15 == (unsigned __int16)UserDefaultLangID || !v15 )
          {
            LODWORD(v17) = *(unsigned __int16 *)((char *)::lpBuffer + v14 + 2);
            sub_140001000(SubBlock, 0x40ui64, L"\\StringFileInfo\\%04X%04X\\%s", v15, v17, a2);
            if ( VerQueryValueW(v10, SubBlock, &lpBuffer, (PUINT)v20) && lpBuffer )
            {
              sub_140001240(a3, 0x200ui64, (__int64)lpBuffer);
              v5 = 1;
              break;
            }
            v12 = puLen;
          }
          ++v13;
          v14 += 4i64;
        }
        while ( v13 < v12 >> 2 );
      }
    }
    free(v10);
  }
  return v5;
}
// 140082A22: variable 'v17' is possibly undefined
// 1400EC2C0: using guessed type wchar_t aStringfileinfo[28];
// 140082920: using guessed type unsigned int var_E8[4];

//----- (0000000140082AC0) ----------------------------------------------------
__int64 __fastcall sub_140082AC0(wchar_t *a1)
{
  __int64 v1; // rdi
  unsigned int v3; // esi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // r12
  PSID *v7; // rbp
  signed __int64 v8; // rcx
  wchar_t v9; // ax
  DWORD TokenInformationLength; // [rsp+40h] [rbp-858h] BYREF
  DWORD cchName; // [rsp+44h] [rbp-854h] BYREF
  DWORD cchReferencedDomainName; // [rsp+48h] [rbp-850h] BYREF
  LPWSTR StringSid; // [rsp+50h] [rbp-848h] BYREF
  HANDLE TokenHandle; // [rsp+58h] [rbp-840h] BYREF
  enum _SID_NAME_USE peUse; // [rsp+60h] [rbp-838h] BYREF
  int ReturnLength[3]; // [rsp+64h] [rbp-834h] BYREF
  WCHAR Name[512]; // [rsp+70h] [rbp-828h] BYREF
  WCHAR ReferencedDomainName[512]; // [rsp+470h] [rbp-428h] BYREF

  v1 = 512i64;
  cchName = 512;
  cchReferencedDomainName = 512;
  TokenInformationLength = 0;
  v3 = 0;
  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v6 = v5;
  if ( v5 )
  {
    if ( !OpenProcessToken(v5, 0xF01FFu, &TokenHandle)
      || (GetTokenInformation(TokenHandle, TokenUser, 0i64, 0, &TokenInformationLength),
          (v7 = (PSID *)GlobalAlloc(0, TokenInformationLength)) == 0i64) )
    {
LABEL_10:
      CloseHandle(v6);
      if ( v3 )
        return v3;
      goto LABEL_11;
    }
    GetTokenInformation(TokenHandle, TokenUser, v7, TokenInformationLength, (PDWORD)ReturnLength);
    if ( LookupAccountSidW(0i64, *v7, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      sub_140001000(a1, 0x200ui64, L"%s\\%s", ReferencedDomainName, Name);
    }
    else
    {
      if ( !ConvertSidToStringSidW(*v7, &StringSid) )
      {
LABEL_9:
        GlobalFree(v7);
        goto LABEL_10;
      }
      sub_140001240(a1, 0x200ui64, (__int64)StringSid);
      LocalFree(StringSid);
    }
    v3 = 1;
    goto LABEL_9;
  }
LABEL_11:
  v8 = &unk_1400EACCC - (_UNKNOWN *)a1;
  while ( v1 != -2147483134 )
  {
    v9 = *(wchar_t *)((char *)a1 + v8);
    if ( !v9 )
      break;
    *a1++ = v9;
    if ( !--v1 )
    {
      --a1;
      break;
    }
  }
  *a1 = 0;
  return v3;
}
// 140082C86: conditional instruction was optimized away because rdi.8!=0
// 1400EC278: using guessed type wchar_t aSS_1[6];
// 140082AC0: using guessed type DWORD var_834[3];

//----- (0000000140082CD0) ----------------------------------------------------
__int64 __fastcall sub_140082CD0(LPCWSTR lpFileName, wchar_t *a2)
{
  __int64 v4; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v6; // rax
  void *v7; // rbx
  HANDLE FileW; // rbx
  WCHAR *v10; // rcx
  DWORD v11; // eax
  HANDLE v12; // rax
  void *v13; // rbx
  PSID ppsidOwner; // [rsp+40h] [rbp-C0h] BYREF
  LPWSTR StringSid; // [rsp+48h] [rbp-B8h] BYREF
  DWORD cchName; // [rsp+50h] [rbp-B0h] BYREF
  DWORD cchReferencedDomainName; // [rsp+54h] [rbp-ACh] BYREF
  HANDLE TokenHandle; // [rsp+58h] [rbp-A8h] BYREF
  struct _LUID Luid; // [rsp+60h] [rbp-A0h] BYREF
  PSECURITY_DESCRIPTOR hMem; // [rsp+68h] [rbp-98h] BYREF
  enum _SID_NAME_USE peUse; // [rsp+70h] [rbp-90h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+78h] [rbp-88h] BYREF
  WCHAR Name[512]; // [rsp+90h] [rbp-70h] BYREF
  WCHAR ReferencedDomainName[512]; // [rsp+490h] [rbp+390h] BYREF

  cchName = 512;
  cchReferencedDomainName = 512;
  v4 = 0i64;
  CurrentProcessId = GetCurrentProcessId();
  v6 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v7 = v6;
  if ( !v6 )
    return 0i64;
  OpenProcessToken(v6, 0xF01FFu, &TokenHandle);
  LookupPrivilegeValueW(0i64, L"SeSecurityPrivilege", &Luid);
  NewState.PrivilegeCount = 1;
  NewState.Privileges[0].Attributes = 2;
  NewState.Privileges[0].Luid = Luid;
  CloseHandle(v7);
  if ( !AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0i64, 0i64) )
    return 0i64;
  FileW = CreateFileW(lpFileName, 0x1020000u, 1u, 0i64, 3u, 0x2000000u, 0i64);
  if ( FileW != (HANDLE)-1i64 )
  {
    ppsidOwner = GlobalAlloc(0, 8ui64);
    hMem = GlobalAlloc(0, 8ui64);
    if ( GetSecurityInfo(FileW, SE_FILE_OBJECT, 1u, &ppsidOwner, 0i64, 0i64, 0i64, &hMem) )
    {
      CloseHandle(FileW);
      return 0i64;
    }
    if ( LookupAccountSidW(0i64, ppsidOwner, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      sub_140001000(a2, 0x200ui64, L"%s\\%s", ReferencedDomainName, Name);
      v10 = Name;
    }
    else
    {
      if ( !ConvertSidToStringSidW(ppsidOwner, &StringSid) )
      {
LABEL_12:
        LocalFree(&hMem);
        CloseHandle(FileW);
        goto LABEL_13;
      }
      sub_140001240(a2, 0x200ui64, (__int64)StringSid);
      LocalFree(StringSid);
      v10 = StringSid;
    }
    v4 = lstrlenW(v10);
    goto LABEL_12;
  }
LABEL_13:
  v11 = GetCurrentProcessId();
  v12 = OpenProcess(0x1F0FFFu, 0, v11);
  v13 = v12;
  if ( v12 )
  {
    OpenProcessToken(v12, 0xF01FFu, (PHANDLE)&Luid);
    LookupPrivilegeValueW(0i64, L"SeSecurityPrivilege", (PLUID)&TokenHandle);
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = (LUID)TokenHandle;
    NewState.Privileges[0].Attributes = 0;
    CloseHandle(v13);
    AdjustTokenPrivileges(*(HANDLE *)&Luid, 0, &NewState, 0, 0i64, 0i64);
  }
  return v4;
}
// 1400EC240: using guessed type wchar_t aSS_2[6];

//----- (0000000140082FB0) ----------------------------------------------------
void __fastcall sub_140082FB0(__int16 a1, char *a2, unsigned int a3)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  signed __int64 v5; // r9
  __int16 v6; // ax
  __int16 v7; // [rsp+0h] [rbp-28h] BYREF
  __int16 v8; // [rsp+2h] [rbp-26h]
  __int16 v9; // [rsp+4h] [rbp-24h]
  __int16 v10; // [rsp+6h] [rbp-22h]
  __int16 v11; // [rsp+8h] [rbp-20h]
  __int16 v12; // [rsp+Ah] [rbp-1Eh]
  __int16 v13; // [rsp+Ch] [rbp-1Ch]
  __int16 v14; // [rsp+Eh] [rbp-1Ah]

  if ( (a1 & 0x20) != 0 )
    v7 = 65;
  else
    v7 = 45;
  if ( (a1 & 2) != 0 )
    v8 = 72;
  else
    v8 = 45;
  if ( (a1 & 1) != 0 )
    v9 = 82;
  else
    v9 = 45;
  if ( (a1 & 4) != 0 )
    v10 = 83;
  else
    v10 = 45;
  if ( (a1 & 0x10) != 0 )
    v11 = 68;
  else
    v11 = 45;
  if ( (a1 & 0x800) != 0 )
    v12 = 67;
  else
    v12 = 45;
  if ( (a1 & 0x4000) != 0 )
    v13 = 69;
  else
    v13 = 45;
  v3 = a3;
  v14 = 0;
  if ( a3 && a3 <= 0x7FFFFFFFui64 )
  {
    v4 = 2147483646i64 - a3;
    v5 = (char *)&v7 - a2;
    while ( v4 + v3 )
    {
      v6 = *(_WORD *)&a2[v5];
      if ( !v6 )
        break;
      *(_WORD *)a2 = v6;
      a2 += 2;
      if ( !--v3 )
        goto LABEL_30;
    }
    if ( v3 )
      goto LABEL_31;
LABEL_30:
    a2 -= 2;
LABEL_31:
    *(_WORD *)a2 = 0;
  }
}

//----- (00000001400830E0) ----------------------------------------------------
__int64 __fastcall sub_1400830E0(const WCHAR *a1, char *a2)
{
  __int64 v3; // rcx
  signed __int64 v4; // rdx
  __int16 v5; // ax
  __int64 result; // rax
  HANDLE v7; // r11
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+20h] [rbp-268h] BYREF

  if ( FindFirstFileW(a1, &FindFileData) == (HANDLE)-1i64 )
  {
    v3 = 32i64;
    v4 = &unk_1400EAC9C - (_UNKNOWN *)a2;
    while ( v3 != -2147483614 )
    {
      v5 = *(_WORD *)&a2[v4];
      if ( !v5 )
        break;
      *(_WORD *)a2 = v5;
      a2 += 2;
      if ( !--v3 )
      {
        result = 0i64;
        *((_WORD *)a2 - 1) = 0;
        return result;
      }
    }
    result = 0i64;
    *(_WORD *)a2 = 0;
  }
  else
  {
    sub_140082FB0(FindFileData.dwFileAttributes, a2, 0x20u);
    FindClose(v7);
    return FindFileData.dwFileAttributes;
  }
  return result;
}
// 140083150: conditional instruction was optimized away because rcx.8!=0
// 140083172: variable 'v7' is possibly undefined

//----- (00000001400831A0) ----------------------------------------------------
wchar_t *__fastcall sub_1400831A0(__int64 a1)
{
  __int16 *v2; // rdi
  double v3; // xmm0_8
  unsigned __int64 v4; // rax
  double v5; // xmm0_8
  int v6; // er9
  unsigned __int64 v7; // r10

  v2 = &word_14012ED02;
  v3 = pow(2.0, 32.0);
  v4 = 0i64;
  v5 = v3 * (double)SHIDWORD(a1) + (double)(int)a1;
  if ( v5 > 9.223372036854776e18 )
  {
    v5 = v5 - 9.223372036854776e18;
    if ( v5 < 9.223372036854776e18 )
      v4 = 0x8000000000000000ui64;
  }
  v6 = 0;
  v7 = v4 + (unsigned int)(int)v5;
  if ( v7 )
  {
    word_14012ED02 = 0;
    do
    {
      if ( v6 == 3 * (v6 / 3) )
      {
        if ( v6 )
          *--v2 = 44;
      }
      --v2;
      ++v6;
      *v2 = v7 % 0xA + 48;
      v7 /= 0xAui64;
    }
    while ( v7 );
    return (wchar_t *)v2;
  }
  else
  {
    sub_140001000(word_14012ECE8, 0xEui64, L"%d");
    return word_14012ECE8;
  }
}
// 1400EC20C: using guessed type wchar_t aD_0[3];
// 14012ECE8: using guessed type wchar_t word_14012ECE8[13];
// 14012ED02: using guessed type __int16 word_14012ED02;

//----- (0000000140083300) ----------------------------------------------------
__int64 __fastcall sub_140083300(const WCHAR *a1)
{
  unsigned int v1; // ebx
  HANDLE FileW; // rax
  void *v5; // rbp
  DWORD FileSize; // eax
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  signed int v9; // esi
  signed __int64 v10; // rdi
  WCHAR v11; // ax
  signed int i; // er11
  int BytesPerSector[4]; // [rsp+40h] [rbp-238h] BYREF
  WCHAR pszPath[264]; // [rsp+50h] [rbp-228h] BYREF

  v1 = 0;
  if ( !a1 )
    return 0xFFFFFFFFi64;
  FileW = CreateFileW(a1, 0x80000000, 3u, 0i64, 3u, 0, 0i64);
  v5 = FileW;
  if ( FileW == (HANDLE)-1i64 )
    return 0xFFFFFFFFi64;
  FileSize = GetFileSize(FileW, 0i64);
  v7 = 260i64;
  v8 = pszPath;
  v9 = FileSize;
  v10 = (char *)a1 - (char *)pszPath;
  while ( v7 != -2147483386 )
  {
    v11 = *(WCHAR *)((char *)v8 + v10);
    if ( !v11 )
      break;
    *v8++ = v11;
    if ( !--v7 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathStripToRootW(pszPath);
  GetDiskFreeSpaceW(pszPath, 0i64, (LPDWORD)BytesPerSector, 0i64, 0i64);
  for ( i = 0; i < v9; ++v1 )
    i += BytesPerSector[0];
  CloseHandle(v5);
  return v1;
}
// 1400833B9: conditional instruction was optimized away because rdx.8!=0
// 140083300: using guessed type DWORD BytesPerSector[4];

//----- (0000000140083440) ----------------------------------------------------
__int64 __fastcall sub_140083440(char *a1, LARGE_INTEGER *a2)
{
  char *v3; // rbx
  HANDLE FileW; // rax
  void *v5; // rdi
  LARGE_INTEGER v7; // r11
  __int64 v8; // rdx
  WCHAR *v9; // rcx
  signed __int64 v10; // rbx
  WCHAR v11; // ax
  LONGLONG v12; // rdx
  DWORD BytesPerSector; // [rsp+40h] [rbp-248h] BYREF
  DWORD SectorsPerCluster; // [rsp+44h] [rbp-244h] BYREF
  LARGE_INTEGER FileSize; // [rsp+48h] [rbp-240h] BYREF
  WCHAR pszPath[264]; // [rsp+50h] [rbp-238h] BYREF

  v3 = a1;
  if ( *((_QWORD *)a1 + 3) >= 8ui64 )
    a1 = *(char **)a1;
  FileW = CreateFileW((LPCWSTR)a1, 0x80000000, 3u, 0i64, 3u, 0, 0i64);
  v5 = FileW;
  if ( FileW == (HANDLE)-1i64 )
    return 0i64;
  GetFileSizeEx(FileW, &FileSize);
  v7 = FileSize;
  *a2 = FileSize;
  if ( v7.QuadPart )
  {
    if ( *((_QWORD *)v3 + 3) >= 8ui64 )
      v3 = *(char **)v3;
    v8 = 260i64;
    v9 = pszPath;
    v10 = v3 - (char *)pszPath;
    while ( v8 != -2147483386 )
    {
      v11 = *(WCHAR *)((char *)v9 + v10);
      if ( !v11 )
        break;
      *v9++ = v11;
      if ( !--v8 )
      {
        --v9;
        break;
      }
    }
    *v9 = 0;
    PathStripToRootW(pszPath);
    GetDiskFreeSpaceW(pszPath, &SectorsPerCluster, &BytesPerSector, 0i64, 0i64);
    v12 = a2->QuadPart % (int)(BytesPerSector * SectorsPerCluster);
    if ( v12 )
      a2->QuadPart += (int)(BytesPerSector * SectorsPerCluster) - v12;
  }
  CloseHandle(v5);
  return 1i64;
}
// 140083507: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400835A0) ----------------------------------------------------
__int64 __fastcall sub_1400835A0(const FILETIME *a1, char *a2, int a3, int a4)
{
  unsigned __int64 v6; // rsi
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  int DateFormatW; // ebx
  __int64 v11; // rdx
  WCHAR *v12; // rcx
  WCHAR v13; // ax
  int TimeFormatW; // eax
  unsigned __int64 v15; // rcx
  signed __int64 v16; // r8
  __int16 v17; // ax
  struct _FILETIME LocalFileTime; // [rsp+30h] [rbp-D0h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+38h] [rbp-C8h] BYREF
  struct _SYSTEMTIME v21; // [rsp+48h] [rbp-B8h] BYREF
  WCHAR DateStr[512]; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR String[512]; // [rsp+460h] [rbp+360h] BYREF
  WCHAR TimeStr[512]; // [rsp+860h] [rbp+760h] BYREF

  v6 = a3;
  FileTimeToLocalFileTime(a1, &LocalFileTime);
  FileTimeToSystemTime(&LocalFileTime, &SystemTime);
  GetLocalTime(&v21);
  if ( !a4 || v21.wYear != SystemTime.wYear || v21.wMonth != SystemTime.wMonth )
    goto LABEL_18;
  if ( v21.wDay == SystemTime.wDay )
  {
    v7 = 512i64;
    v8 = DateStr;
    while ( v7 != -2147483134 )
    {
      v9 = *(WCHAR *)((char *)v8 + (char *)L"Today" - (char *)DateStr);
      if ( !v9 )
        break;
      *v8++ = v9;
      if ( !--v7 )
      {
        DateFormatW = 1;
        *(v8 - 1) = 0;
        goto LABEL_19;
      }
    }
    *v8 = 0;
    DateFormatW = 1;
    goto LABEL_19;
  }
  if ( v21.wDay != SystemTime.wDay + 1 )
  {
LABEL_18:
    DateFormatW = GetDateFormatW(0x400u, 0x40000000u, &SystemTime, 0i64, DateStr, 512);
    goto LABEL_19;
  }
  v11 = 512i64;
  v12 = DateStr;
  while ( v11 != -2147483134 )
  {
    v13 = *(WCHAR *)((char *)v12 + (char *)L"Yesterday" - (char *)DateStr);
    if ( !v13 )
      break;
    *v12++ = v13;
    if ( !--v11 )
    {
      DateFormatW = 1;
      *(v12 - 1) = 0;
      goto LABEL_19;
    }
  }
  *v12 = 0;
  DateFormatW = 1;
LABEL_19:
  TimeFormatW = GetTimeFormatW(0x400u, 0x40000000u, &SystemTime, 0i64, TimeStr, 512);
  if ( !DateFormatW || !TimeFormatW )
    return 0xFFFFFFFFi64;
  sub_140001000(String, 0x200ui64, L"%s, %s", DateStr, TimeStr);
  if ( (int)v6 >= lstrlenW(String) + 1 )
  {
    v15 = v6;
    if ( (_DWORD)v6 )
    {
      if ( v6 <= 0x7FFFFFFF )
      {
        v16 = (char *)String - a2;
        while ( 2147483646 - v6 + v15 )
        {
          v17 = *(_WORD *)&a2[v16];
          if ( !v17 )
            break;
          *(_WORD *)a2 = v17;
          a2 += 2;
          if ( !--v15 )
            goto LABEL_30;
        }
        if ( v15 )
          goto LABEL_31;
LABEL_30:
        a2 -= 2;
LABEL_31:
        *(_WORD *)a2 = 0;
      }
    }
  }
  return (unsigned int)(lstrlenW(String) + 1);
}
// 140083685: conditional instruction was optimized away because rdx.8!=0
// 1400836F2: conditional instruction was optimized away because rdx.8!=0
// 1400EC1A0: using guessed type wchar_t aToday_0[6];
// 1400EC1B0: using guessed type wchar_t aYesterday_0[10];
// 1400EC1C8: using guessed type wchar_t aSS_3[7];

//----- (0000000140083840) ----------------------------------------------------
_QWORD *__fastcall sub_140083840(char *a1, _QWORD *a2)
{
  __int64 v3; // rax

  v3 = sub_14001B490(a1, a2);
  return sub_140009570(a1, v3 + 1, 0xFFFFFFFFFFFFFFFFui64);
}

//----- (0000000140083870) ----------------------------------------------------
__int64 __fastcall sub_140083870(LPCWSTR lpString, char *a2, __int64 a3)
{
  int v6; // edi
  int v7; // esi
  LPCWSTR v8; // rbp
  __int64 v9; // r11
  __int16 *v10; // rax
  __int64 v11; // rcx
  __int16 *v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  __int16 v15; // dx
  signed __int64 v16; // rcx
  __int64 v17; // r11
  __int64 result; // rax
  __int16 v19[1024]; // [rsp+20h] [rbp-838h] BYREF

  v6 = 0;
  v19[0] = 0;
  v7 = 0;
  if ( lstrlenW(lpString) > 0 )
  {
    v8 = lpString;
    do
    {
      if ( *v8 == 38 )
      {
        sub_14001BA20(v19, (__int64)&lpString[v6], v7 - v6);
        v9 = 1024i64;
        v10 = v19;
        while ( *v10 )
        {
          ++v10;
          if ( !--v9 )
            goto LABEL_14;
        }
        v11 = v9;
        v12 = &v19[1024 - v9];
        v13 = 0x7FFFFFFFi64;
        v14 = a3 - (_QWORD)v12;
        while ( v13 )
        {
          v15 = *(__int16 *)((char *)v12 + v14);
          if ( !v15 )
            break;
          *v12++ = v15;
          --v13;
          if ( !--v11 )
          {
            --v12;
            break;
          }
        }
        *v12 = 0;
LABEL_14:
        v6 = v7 + 1;
      }
      ++v7;
      ++v8;
    }
    while ( v7 < lstrlenW(lpString) );
  }
  sub_14001BA20(v19, (__int64)&lpString[v6], v7 - v6);
  v16 = (char *)v19 - a2;
  v17 = 260i64;
  while ( 1 )
  {
    result = v17 + 2147483386;
    if ( v17 == -2147483386 )
      break;
    result = *(unsigned __int16 *)&a2[v16];
    if ( !(_WORD)result )
      break;
    *(_WORD *)a2 = result;
    a2 += 2;
    if ( !--v17 )
    {
      *((_WORD *)a2 - 1) = 0;
      return result;
    }
  }
  *(_WORD *)a2 = 0;
  return result;
}
// 140083914: conditional instruction was optimized away because r11.8!=0
// 14008392B: conditional instruction was optimized away because r11.8!=0
// 140083963: conditional instruction was optimized away because rcx.8!=0
// 1400839FF: conditional instruction was optimized away because r11.8!=0
// 140083870: using guessed type __int16 var_838[1024];

//----- (0000000140083A30) ----------------------------------------------------
void __fastcall sub_140083A30(HWND hWnd, void *Src)
{
  int v4; // edi
  WCHAR *v5; // rbx
  __int64 v6; // rcx
  WCHAR *v7; // rdi
  bool v8; // zf

  v4 = GetWindowTextLengthW(hWnd) + 1;
  v5 = (WCHAR *)operator new(saturated_mul(v4, 2ui64));
  GetWindowTextW(hWnd, v5, v4);
  v6 = -1i64;
  v7 = v5;
  do
  {
    if ( !v6 )
      break;
    v8 = *v7++ == 0;
    --v6;
  }
  while ( !v8 );
  sub_1400099E0(Src, v5, -v6 - 2);
  j_j_free(v5);
}

//----- (0000000140083AD0) ----------------------------------------------------
__int64 __fastcall sub_140083AD0(void *a1, void *Destination)
{
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // rdi
  HANDLE FileW; // rbx
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  WCHAR v11; // ax
  DWORD FileSize; // eax
  __int64 v13; // rcx
  _WORD *v14; // rdi
  __int64 v15; // r12
  bool v16; // zf
  LONGLONG v17; // rdi
  int v18; // er14
  int v19; // er13
  unsigned int v20; // er14
  DWORD v21; // er13
  void *v22; // rax
  const void *v23; // rdi
  DWORD BytesPerSector; // [rsp+40h] [rbp-C0h] BYREF
  DWORD NumberOfBytesRead; // [rsp+44h] [rbp-BCh] BYREF
  HANDLE TokenHandle; // [rsp+48h] [rbp-B8h] BYREF
  struct _LUID Luid; // [rsp+50h] [rbp-B0h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+58h] [rbp-A8h] BYREF
  void *Block[3]; // [rsp+68h] [rbp-98h] BYREF
  unsigned __int64 v30; // [rsp+80h] [rbp-80h]
  WCHAR pszPath[264]; // [rsp+90h] [rbp-70h] BYREF

  NumberOfBytesRead = 0;
  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x1F0FFFu, 0, CurrentProcessId);
  v6 = v5;
  if ( v5 )
  {
    OpenProcessToken(v5, 0xF01FFu, &TokenHandle);
    LookupPrivilegeValueW(0i64, L"SeManageVolumePrivilege", &Luid);
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = Luid;
    NewState.Privileges[0].Attributes = 2;
    CloseHandle(v6);
    AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0i64, 0i64);
  }
  if ( GetLastError() )
    return 0xFFFFFFFFi64;
  FileW = CreateFileW((LPCWSTR)a1, 0xC0000000, 7u, 0i64, 3u, 0, 0i64);
  if ( FileW == (HANDLE)-1i64 )
    return 0xFFFFFFFFi64;
  v9 = 260i64;
  v10 = pszPath;
  while ( v9 != -2147483386 )
  {
    v11 = *(WCHAR *)((char *)v10 + (_BYTE *)a1 - (_BYTE *)pszPath);
    if ( !v11 )
      break;
    *v10++ = v11;
    if ( !--v9 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  PathStripToRootW(pszPath);
  if ( GetDiskFreeSpaceW(pszPath, 0i64, &BytesPerSector, 0i64, 0i64) )
  {
    FileSize = GetFileSize(FileW, 0i64);
    v13 = -1i64;
    v14 = a1;
    v15 = FileSize;
    do
    {
      if ( !v13 )
        break;
      v16 = *v14++ == 0;
      --v13;
    }
    while ( !v16 );
    v30 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    sub_1400099E0(Block, a1, -v13 - 2);
    sub_140083440((char *)Block, (LARGE_INTEGER *)&TokenHandle);
    if ( v30 >= 8 )
      j_free(Block[0]);
    v17 = (LONGLONG)TokenHandle;
    if ( (__int64)TokenHandle > v15 )
    {
      v18 = sub_140083300((const WCHAR *)a1);
      v19 = v17 / BytesPerSector - v18;
      SetFilePointerEx(FileW, (LARGE_INTEGER)v17, 0i64, 0);
      SetEndOfFile(FileW);
      SetFileValidData(FileW, v17);
      v20 = BytesPerSector * v18;
      if ( v20 > (unsigned int)v15 )
      {
        SetFilePointer(FileW, v20, 0i64, 0);
        v21 = BytesPerSector * v19;
        v22 = malloc(v21);
        v23 = v22;
        if ( v22 )
        {
          ReadFile(FileW, v22, v21, &NumberOfBytesRead, 0i64);
          memcpy_s(Destination, 0x1000ui64, v23, NumberOfBytesRead);
        }
      }
      SetFilePointer(FileW, v15, 0i64, 0);
      SetEndOfFile(FileW);
      SetFileValidData(FileW, v15);
    }
  }
  CloseHandle(FileW);
  return NumberOfBytesRead;
}
// 140083C16: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140083DE0) ----------------------------------------------------
void __fastcall sub_140083DE0(__int64 a1, char *a2, unsigned __int64 a3, int a4, int a5)
{
  unsigned __int64 v5; // rsi
  char *v6; // rdi
  double v7; // xmm6_8
  int v8; // ebx
  double v9; // xmm2_8
  int v10; // er14
  __int64 v11; // rcx
  double v12; // xmm0_8
  signed __int64 v13; // rdx
  __int16 v14; // ax
  double v15; // xmm0_8
  unsigned int v16; // eax
  double v17; // xmm1_8
  double v18; // xmm4_8
  unsigned int v19; // eax
  double v20; // xmm0_8
  __int64 *v21; // rax
  __int64 v22; // r13
  __int64 v23; // rax
  void (__fastcall ***v24)(_QWORD, __int64); // r12
  struct std::locale::_Locimp *v25; // r12
  __int64 v26; // rax
  struct std::locale::_Locimp *v27; // r13
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // rax
  void **v31; // r11
  void *v32; // r8
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  signed __int64 v35; // r11
  __int16 v36; // ax
  __int64 v37; // [rsp+28h] [rbp-E0h] BYREF
  struct std::locale::_Locimp *v38; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v39; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v40[2]; // [rsp+48h] [rbp-C0h] BYREF
  int *v41; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v42[15]; // [rsp+60h] [rbp-A8h] BYREF
  int v43; // [rsp+D8h] [rbp-30h]
  __int64 v44[2]; // [rsp+E0h] [rbp-28h] BYREF
  int v45; // [rsp+F0h] [rbp-18h]
  __int64 *v46; // [rsp+128h] [rbp+20h]
  __int64 v47; // [rsp+130h] [rbp+28h]
  __int16 v48; // [rsp+138h] [rbp+30h]
  __int64 v49[7]; // [rsp+148h] [rbp+40h]
  void *Block[3]; // [rsp+180h] [rbp+78h] BYREF
  unsigned __int64 v51; // [rsp+198h] [rbp+90h]

  v49[6] = -2i64;
  v5 = a3;
  v6 = a2;
  LODWORD(v37) = 0;
  v49[0] = (__int64)L"bytes";
  v49[1] = (__int64)L"KB";
  v49[2] = (__int64)L"MB";
  v49[3] = (__int64)L"GB";
  v49[4] = (__int64)L"TB";
  v49[5] = (__int64)L"PB";
  v7 = (double)(int)a1;
  if ( a1 < 0 )
    v7 = v7 + 1.844674407370955e19;
  v8 = 0;
  v9 = 10.0;
  v10 = 2;
  if ( a4 )
  {
    switch ( a5 )
    {
      case 2:
        v8 = 1;
        break;
      case 3:
        v8 = 2;
        break;
      case 4:
        v8 = 3;
        break;
      case 5:
        v8 = 4;
        break;
      case 6:
        v8 = 5;
        break;
      default:
        break;
    }
    if ( v8 > 0 )
    {
      v11 = (unsigned int)v8;
      do
      {
        v7 = v7 * 0.0009765625;
        --v11;
      }
      while ( v11 );
    }
    goto LABEL_27;
  }
  v12 = v7 * 0.0009765625;
  if ( v7 * 0.0009765625 < 1.0 )
  {
LABEL_30:
    v10 = 0;
LABEL_31:
    v15 = 10.0;
    v16 = v10 + 1;
    if ( v10 + 1 < 0 )
      v16 = -v16;
    v17 = 1.0;
    while ( 1 )
    {
      if ( (v16 & 1) != 0 )
        v17 = v17 * v15;
      v16 >>= 1;
      if ( !v16 )
        break;
      v15 = v15 * v15;
    }
    if ( v10 + 1 >= 0 )
      v18 = v17;
    else
      v18 = 1.0 / v17;
    if ( (int)((v7 - (double)(int)v7) * v18) >= 5 )
    {
      v19 = -1 - v10;
      if ( -1 - v10 < 0 )
        v19 = v10 + 1;
      v20 = 1.0;
      while ( 1 )
      {
        if ( (v19 & 1) != 0 )
          v20 = v20 * v9;
        v19 >>= 1;
        if ( !v19 )
          break;
        v9 = v9 * v9;
      }
    }
    v40[0] = (__int64)&unk_1400F7230;
    v41 = (int *)&unk_1400F7238;
    LODWORD(v37) = 1;
    v44[0] = (__int64)&std::wistream::`vftable';
    v40[1] = 0i64;
    sub_140008270((__int64)v44);
    v46 = v42;
    v47 = 0i64;
    v48 = sub_1400056C0((__int64)v44);
    if ( !v46 )
      sub_140009260((__int64)v44, v45 | 4, 0);
    *(__int64 *)((char *)&v42[-1] + v41[1]) = (__int64)&std::wostream::`vftable';
    *(__int64 *)((char *)v40 + *(int *)(v40[0] + 4)) = (__int64)&std::wiostream::`vftable';
    *(__int64 *)((char *)v40 + *(int *)(v40[0] + 4)) = (__int64)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
    sub_140003840(v42);
    v42[0] = (__int64)&std::wstringbuf::`vftable';
    v42[14] = 0i64;
    v43 = 0;
    v21 = (__int64 *)sub_14001BC10(&v38, (const char *)&unk_1400E9DBF);
    sub_14001B3E0((__int64)v40 + *(int *)(v40[0] + 4), &v39, v21);
    v22 = v39;
    if ( v39 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v37, 0);
      v23 = *(_QWORD *)(v22 + 8);
      if ( v23 && v23 != -1 )
        *(_QWORD *)(v22 + 8) = v23 - 1;
      v24 = 0i64;
      if ( !*(_QWORD *)(v22 + 8) )
        v24 = (void (__fastcall ***)(_QWORD, __int64))v22;
      std::_Lockit::~_Lockit((std::_Lockit *)&v37);
      if ( v24 )
        (**v24)(v24, 1i64);
    }
    v25 = v38;
    if ( v38 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)&v37, 0);
      v26 = *((_QWORD *)v25 + 1);
      if ( v26 && v26 != -1 )
        *((_QWORD *)v25 + 1) = v26 - 1;
      v27 = 0i64;
      if ( !*((_QWORD *)v25 + 1) )
        v27 = v25;
      std::_Lockit::~_Lockit((std::_Lockit *)&v37);
      if ( v27 )
        (**(void (__fastcall ***)(struct std::locale::_Locimp *, __int64))v27)(v27, 1i64);
    }
    *(__int64 *)((char *)&v42[1] + *(int *)(v40[0] + 4)) = v10;
    v28 = v41[1];
    *(_DWORD *)((char *)&v42[2] + v28) &= ~0x1000u;
    *(_DWORD *)((char *)&v42[2] + v28) |= 0x2000u;
    v29 = sub_14001B200((__int64)&v41);
    v30 = sub_14001B5D0(v29, word_1400EABE4);
    sub_14001B5D0(v30, (_WORD *)v49[v8]);
    sub_14000C460((__int64)v40, (__int64)Block);
    v31 = Block;
    v32 = Block[0];
    v33 = v51;
    if ( v51 >= 8 )
      v31 = (void **)Block[0];
    if ( v5 && v5 <= 0x7FFFFFFF )
    {
      v34 = 2147483646 - v5;
      v35 = (char *)v31 - v6;
      while ( v34 + v5 )
      {
        v36 = *(_WORD *)&v6[v35];
        if ( !v36 )
          break;
        *(_WORD *)v6 = v36;
        v6 += 2;
        if ( !--v5 )
        {
          v6 -= 2;
          break;
        }
      }
      *(_WORD *)v6 = 0;
    }
    if ( v33 >= 8 )
      j_free(v32);
    v51 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    v38 = (struct std::locale::_Locimp *)v44;
    *(__int64 *)((char *)v40 + *(int *)(v40[0] + 4)) = (__int64)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
    sub_140001E20((__int64)v42);
    *(__int64 *)((char *)v40 + *(int *)(v40[0] + 4)) = (__int64)&std::wiostream::`vftable';
    *(__int64 *)((char *)&v42[-1] + v41[1]) = (__int64)&std::wostream::`vftable';
    *(__int64 *)((char *)v40 + *(int *)(v40[0] + 4)) = (__int64)&std::wistream::`vftable';
    v44[0] = (__int64)&std::ios_base::`vftable';
    std::ios_base::_Ios_base_dtor((struct std::ios_base *)v44);
    return;
  }
  do
  {
    v7 = v12;
    ++v8;
    v12 = v12 * 0.0009765625;
  }
  while ( v12 >= 1.0 );
  if ( (unsigned int)v8 <= 5 )
  {
LABEL_27:
    if ( v8 )
    {
      if ( v7 < 10.0 )
        goto LABEL_31;
      v10 = 1;
      if ( v7 < 100.0 )
        goto LABEL_31;
    }
    goto LABEL_30;
  }
  if ( a3 && a3 <= 0x7FFFFFFF )
  {
    v13 = &unk_1400EAB1C - (_UNKNOWN *)a2;
    while ( 2147483646 - a3 + v5 )
    {
      v14 = *(_WORD *)&v6[v13];
      if ( !v14 )
        break;
      *(_WORD *)v6 = v14;
      v6 += 2;
      if ( !--v5 )
        goto LABEL_25;
    }
    if ( v5 )
      goto LABEL_26;
LABEL_25:
    v6 -= 2;
LABEL_26:
    *(_WORD *)v6 = 0;
  }
}
// 140083EF4: conditional instruction was optimized away because ebx.4<6u
// 1400842F9: conditional instruction was optimized away because rsi.8!=0
// 140003840: using guessed type __int64 __fastcall sub_140003840(_QWORD);
// 1400EABE4: using guessed type _WORD word_1400EABE4[92];
// 1400EC0A8: using guessed type wchar_t aKb[3];
// 1400EC170: using guessed type wchar_t aBytes[6];
// 1400EC17C: using guessed type wchar_t aMb[3];
// 1400EC184: using guessed type wchar_t aGb[3];
// 1400EC18C: using guessed type wchar_t aTb[3];
// 1400EC194: using guessed type wchar_t aPb[3];
// 1400F6838: using guessed type void *std::wstringbuf::`vftable';
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';
// 1400F7218: using guessed type void *std::wiostream::`vftable';
// 1400F7228: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';

//----- (0000000140084450) ----------------------------------------------------
__int64 sub_140084450()
{
  return 0i64;
}

//----- (0000000140084460) ----------------------------------------------------
__int64 sub_140084460()
{
  return 0i64;
}

//----- (0000000140084470) ----------------------------------------------------
__int64 sub_140084470()
{
  return 0i64;
}

//----- (0000000140084480) ----------------------------------------------------
__int64 sub_140084480()
{
  return 0i64;
}

//----- (0000000140084490) ----------------------------------------------------
__int64 sub_140084490()
{
  return 0i64;
}

//----- (00000001400844A0) ----------------------------------------------------
__int64 sub_1400844A0()
{
  return 0i64;
}

//----- (00000001400844B0) ----------------------------------------------------
__int64 sub_1400844B0()
{
  return 1i64;
}

//----- (00000001400844C0) ----------------------------------------------------
__int64 sub_1400844C0()
{
  return 0i64;
}

//----- (00000001400844D0) ----------------------------------------------------
__int64 sub_1400844D0()
{
  return 0i64;
}

//----- (00000001400844E0) ----------------------------------------------------
__int64 sub_1400844E0()
{
  return 1i64;
}

//----- (0000000140084540) ----------------------------------------------------
void __fastcall sub_140084540(_QWORD *a1)
{
  __int64 v1; // rdi
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = a1[9];
  *a1 = &CBaseDialog::`vftable';
  if ( v1 )
  {
    v2 = *(_QWORD ***)(v1 + 8);
    v3 = *v2;
    *v2 = v2;
    *(_QWORD *)(*(_QWORD *)(v1 + 8) + 8i64) = *(_QWORD *)(v1 + 8);
    *(_QWORD *)(v1 + 16) = 0i64;
    if ( v3 != *(_QWORD **)(v1 + 8) )
    {
      do
      {
        v4 = (_QWORD *)*v3;
        j_free(v3);
        v3 = v4;
      }
      while ( v4 != *(_QWORD **)(v1 + 8) );
    }
    j_free(*(void **)(v1 + 8));
    j_free((void *)v1);
  }
}
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';

//----- (00000001400849D0) ----------------------------------------------------
INT_PTR __fastcall DialogFunc(HWND a1, unsigned int a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rdi
  char *v9; // rax
  unsigned __int64 v10; // r11
  __int64 v11; // r11
  HWND *i; // rax
  HWND *v13; // rcx
  __int64 v15[4]; // [rsp+38h] [rbp-20h] BYREF

  if ( a2 == 272 )
  {
    v15[0] = (__int64)a1;
    v8 = *(_QWORD *)qword_14012DFD8;
    v15[1] = a4;
    v9 = sub_14001B150(v8, *(_QWORD *)(v8 + 8), v15);
    if ( qword_14012DFE0 == 0xFFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    ++qword_14012DFE0;
    *(_QWORD *)(v8 + 8) = v9;
    **((_QWORD **)v9 + 1) = v9;
    sub_14001ADF0(
      &word_14012DFD0,
      (__int64)v15,
      (unsigned __int64 *)(*(_QWORD *)qword_14012DFD8 + 16i64),
      *(_QWORD *)qword_14012DFD8);
  }
  v10 = qword_14012E010 & sub_14001AD60((unsigned __int64)a1);
  if ( qword_14012E018 <= v10 )
    v10 += -1i64 - ((unsigned __int64)qword_14012E010 >> 1);
  v11 = 2 * v10;
  for ( i = (HWND *)*((_QWORD *)Block + v11); ; i = (HWND *)*i )
  {
    v13 = *((void **)Block + v11) == qword_14012DFD8 ? (HWND *)qword_14012DFD8 : (HWND *)**((_QWORD **)Block + v11 + 1);
    if ( i == v13 )
      break;
    if ( a1 == i[2] )
    {
      if ( i != qword_14012DFD8 )
        return sub_1400845C0(i[3], a1, a2, a3, a4);
      return 0i64;
    }
  }
  return 0i64;
}
// 1400845C0: using guessed type __int64 __fastcall sub_1400845C0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14012DFD0: using guessed type __int16 word_14012DFD0;
// 14012DFE0: using guessed type __int64 qword_14012DFE0;
// 14012E010: using guessed type __int64 qword_14012E010;
// 14012E018: using guessed type __int64 qword_14012E018;
// 1400849D0: using guessed type _QWORD var_20[4];

//----- (0000000140084B40) ----------------------------------------------------
HWND __fastcall sub_140084B40(LPARAM dwInitParam, __int64 a2)
{
  HWND result; // rax

  if ( *(_DWORD *)(dwInitParam + 48) )
    return 0i64;
  result = CreateDialogParamW(
             *(HINSTANCE *)(dwInitParam + 16),
             (LPCWSTR)*(unsigned __int16 *)(dwInitParam + 24),
             *(HWND *)(dwInitParam + 32),
             (DLGPROC)DialogFunc,
             dwInitParam);
  if ( result )
    *(_DWORD *)(dwInitParam + 48) = 1;
  *(_QWORD *)(dwInitParam + 40) = a2;
  return result;
}

//----- (0000000140084BB0) ----------------------------------------------------
INT_PTR __fastcall sub_140084BB0(LPARAM dwInitParam)
{
  return DialogBoxParamW(
           *(HINSTANCE *)(dwInitParam + 16),
           (LPCWSTR)*(unsigned __int16 *)(dwInitParam + 24),
           *(HWND *)(dwInitParam + 32),
           (DLGPROC)DialogFunc,
           dwInitParam);
}

//----- (0000000140084BE0) ----------------------------------------------------
_BOOL8 sub_140084BE0()
{
  BOOL v0; // esi
  LPVOID v1; // rbx
  DWORD CurrentProcessId; // eax
  HANDLE v3; // rax
  void *v4; // rdi
  BSTR v5; // rax
  int v6; // edi
  BSTR v7; // rax
  int i; // ebx
  __int16 v10; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v11; // [rsp+28h] [rbp-D8h] BYREF
  int v12; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v13; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v14; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v15; // [rsp+48h] [rbp-B8h] BYREF
  VARIANTARG pvarg; // [rsp+50h] [rbp-B0h] BYREF
  LPCWSTR v17; // [rsp+68h] [rbp-98h] BYREF
  LPCWSTR lpString1; // [rsp+70h] [rbp-90h] BYREF
  VARIANTARG v19; // [rsp+78h] [rbp-88h] BYREF
  VARIANTARG v20; // [rsp+90h] [rbp-70h] BYREF
  WCHAR pszPath[264]; // [rsp+B0h] [rbp-50h] BYREF

  v0 = 1;
  v1 = sub_14007BBA0();
  if ( v1 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v3 = OpenProcess(0x410u, 0, CurrentProcessId);
    v4 = v3;
    if ( v3 )
    {
      GetModuleFileNameExW(v3, 0i64, pszPath, 260i64);
      CloseHandle(v4);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit(&pvarg);
    v5 = SysAllocString(pszPath);
    pvarg.llVal = (LONGLONG)v5;
    pvarg.vt = 8;
    *(_OWORD *)&v19.decVal.Lo32 = __PAIR128__((unsigned __int64)pvarg.pRecInfo, (unsigned __int64)v5);
    *(_QWORD *)&v19.vt = *(_QWORD *)&pvarg.vt;
    v20 = pvarg;
    (*(void (__fastcall **)(LPVOID, VARIANTARG *, __int16 *))(*(_QWORD *)v1 + 464i64))(v1, &v20, &v10);
    if ( v10 == -1 )
    {
      v14 = 0i64;
      v11 = 0i64;
      v15 = 0i64;
      v13 = 0i64;
      v6 = 0;
      v7 = SysAllocString(L"//Settings/*");
      (*(void (__fastcall **)(LPVOID, BSTR, __int64 *))(*(_QWORD *)v1 + 288i64))(v1, v7, &v14);
      if ( v14 )
      {
        (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v14 + 64i64))(v14, &v12);
        for ( i = 0; i < v12; v11 = 0i64 )
        {
          if ( v6 )
            break;
          (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v14 + 56i64))(v14, (unsigned int)i, &v11);
          if ( (*(int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v11 + 136i64))(v11, &v15) >= 0
            && (*(int (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v15 + 80i64))(v15, 0i64, &v13) >= 0 )
          {
            (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v13 + 208i64))(v13, &lpString1);
            (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v11 + 208i64))(v11, &v17);
            if ( !lstrcmpW(lpString1, L"AllowMultipleInstances") )
            {
              v6 = 1;
              v0 = lstrcmpW(v17, L"yes") == 0;
            }
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
            v13 = 0i64;
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
          ++i;
        }
      }
    }
  }
  VariantClear(&v19);
  return v0;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140084E80) ----------------------------------------------------
__int64 __fastcall sub_140084E80(_DWORD *a1)
{
  OLECHAR *v2; // r12
  LPVOID v3; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // rsi
  IRecordInfo *v7; // rax
  __int64 v8; // rcx
  int i; // edi
  LPCWSTR lpString1; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v12; // [rsp+30h] [rbp-D8h] BYREF
  __int16 v13; // [rsp+38h] [rbp-D0h] BYREF
  int v14; // [rsp+3Ch] [rbp-CCh] BYREF
  __int64 v15; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v16; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v17; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v18; // [rsp+58h] [rbp-B0h] BYREF
  VARIANTARG pvarg; // [rsp+60h] [rbp-A8h] BYREF
  unsigned __int64 v20; // [rsp+78h] [rbp-90h]
  VARIANTARG v21; // [rsp+80h] [rbp-88h] BYREF
  __int128 v22; // [rsp+98h] [rbp-70h] BYREF
  unsigned __int64 v23; // [rsp+A8h] [rbp-60h]
  WCHAR pszPath[264]; // [rsp+B8h] [rbp-50h] BYREF

  v16 = 0i64;
  v15 = 0i64;
  v17 = 0i64;
  *(_QWORD *)&pvarg.vt = 0i64;
  v2 = 0i64;
  v3 = sub_14007BBA0();
  if ( v3 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v5 = OpenProcess(0x410u, 0, CurrentProcessId);
    v6 = v5;
    if ( v5 )
    {
      GetModuleFileNameExW(v5, 0i64, pszPath, 260i64);
      CloseHandle(v6);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit((VARIANTARG *)&pvarg.decVal.8);
    v7 = (IRecordInfo *)SysAllocString(pszPath);
    v23 = v20;
    pvarg.pRecInfo = v7;
    pvarg.iVal = 8;
    *(_OWORD *)&v21.decVal.Lo32 = __PAIR128__(v20, (unsigned __int64)v7);
    *(_QWORD *)&v21.vt = pvarg.llVal;
    v22 = *(_OWORD *)&pvarg.decVal.Lo32;
    (*(void (__fastcall **)(LPVOID, __int128 *, __int16 *))(*(_QWORD *)v3 + 464i64))(v3, &v22, &v13);
    if ( v13 == -1 )
    {
      v2 = SysAllocString(L"//WindowPosition/*");
      (*(void (__fastcall **)(LPVOID, OLECHAR *, __int64 *))(*(_QWORD *)v3 + 288i64))(v3, v2, &v16);
      v8 = v16;
      *a1 = 44;
      if ( v8 )
      {
        (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v8 + 64i64))(v8, &v18);
        if ( (_DWORD)v18 == 1 )
        {
          (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v16 + 56i64))(v16, 0i64, &v15);
          if ( (*(int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v15 + 136i64))(v15, &v17) >= 0 )
          {
            (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v17 + 88i64))(v17, &v14);
            for ( i = 1; i < v14; ++i )
            {
              (*(void (__fastcall **)(__int64, _QWORD, VARIANTARG *))(*(_QWORD *)v17 + 80i64))(
                v17,
                (unsigned int)i,
                &pvarg);
              (*(void (__fastcall **)(_QWORD, LPCWSTR *))(**(_QWORD **)&pvarg.vt + 56i64))(
                *(_QWORD *)&pvarg.vt,
                &lpString1);
              (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)&pvarg.vt + 208i64))(*(_QWORD *)&pvarg.vt, &v12);
              if ( lstrcmpW(lpString1, L"Flags") )
              {
                if ( lstrcmpW(lpString1, L"ShowCmd") )
                {
                  if ( lstrcmpW(lpString1, L"MinPositionX") )
                  {
                    if ( lstrcmpW(lpString1, L"MinPositionY") )
                    {
                      if ( lstrcmpW(lpString1, L"MaxPositionX") )
                      {
                        if ( lstrcmpW(lpString1, L"MaxPositionY") )
                        {
                          if ( lstrcmpW(lpString1, L"NormalPositionLeft") )
                          {
                            if ( lstrcmpW(lpString1, L"NormalPositionTop") )
                            {
                              if ( lstrcmpW(lpString1, L"NormalPositionRight") )
                              {
                                if ( !lstrcmpW(lpString1, L"NormalPositionBottom") )
                                  a1[10] = sub_14004B61C(v12);
                              }
                              else
                              {
                                a1[9] = sub_14004B61C(v12);
                              }
                            }
                            else
                            {
                              a1[8] = sub_14004B61C(v12);
                            }
                          }
                          else
                          {
                            a1[7] = sub_14004B61C(v12);
                          }
                        }
                        else
                        {
                          a1[6] = sub_14004B61C(v12);
                        }
                      }
                      else
                      {
                        a1[5] = sub_14004B61C(v12);
                      }
                    }
                    else
                    {
                      a1[4] = sub_14004B61C(v12);
                    }
                  }
                  else
                  {
                    a1[3] = sub_14004B61C(v12);
                  }
                }
                else
                {
                  a1[2] = sub_14004B61C(v12);
                }
              }
              else
              {
                a1[1] = sub_14004B61C(v12);
              }
            }
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
          v15 = 0i64;
        }
      }
    }
  }
  VariantClear(&v21);
  if ( v2 )
    SysFreeString(v2);
  if ( v16 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  return 1i64;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400852B0) ----------------------------------------------------
__int64 __fastcall sub_1400852B0(__int64 a1)
{
  BSTR v2; // rax
  __int64 v3; // r8
  __int64 *v4; // rcx
  DWORD CurrentProcessId; // eax
  HANDLE v6; // rbx
  BSTR v7; // rax
  __int64 *v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 result; // rax
  __int64 v12; // [rsp+20h] [rbp-268h] BYREF
  VARIANTARG pvarg; // [rsp+28h] [rbp-260h] BYREF
  __int128 v14; // [rsp+40h] [rbp-248h] BYREF
  IRecordInfo *pRecInfo; // [rsp+50h] [rbp-238h]
  WCHAR pszPath[264]; // [rsp+60h] [rbp-228h] BYREF

  v2 = SysAllocString(L"\n");
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(__int64 **)(a1 + 32);
  v12 = 0i64;
  sub_14007B920(v4, (__int64)v2, v3);
  (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(a1 + 32) + 272i64))(*(_QWORD *)(a1 + 32), &v12);
  CurrentProcessId = GetCurrentProcessId();
  v6 = OpenProcess(0x410u, 0, CurrentProcessId);
  GetModuleFileNameExW(v6, 0i64, pszPath, 260i64);
  CloseHandle(v6);
  PathRemoveFileSpecW(pszPath);
  PathAppendW(pszPath, L"config.xml");
  VariantInit(&pvarg);
  v7 = SysAllocString(pszPath);
  v8 = *(__int64 **)(a1 + 32);
  pRecInfo = pvarg.pRecInfo;
  pvarg.llVal = (LONGLONG)v7;
  pvarg.vt = 8;
  v9 = *v8;
  v14 = *(_OWORD *)&pvarg.vt;
  (*(void (__fastcall **)(__int64 *, __int128 *))(v9 + 528))(v8, &v14);
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 48) + 16i64))(*(_QWORD *)(a1 + 48));
  v10 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = 0i64;
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
  *(_QWORD *)(a1 + 32) = 0i64;
  return result;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140085400) ----------------------------------------------------
__int64 __fastcall sub_140085400(__int64 a1)
{
  BSTR v2; // rsi
  __int64 result; // rax
  OLECHAR *v4; // rbx
  OLECHAR *v5; // rbp
  __int64 *v6; // rcx
  __int64 v7; // r9
  OLECHAR *v8; // rbx
  __int64 *v9; // rcx
  __int64 v10; // r9
  OLECHAR *v11; // rbx
  __int64 *v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // [rsp+50h] [rbp+8h] BYREF
  __int64 v16; // [rsp+58h] [rbp+10h] BYREF
  __int64 v17; // [rsp+60h] [rbp+18h] BYREF

  v15 = 0i64;
  v16 = 0i64;
  v2 = SysAllocString(L"\n\t");
  result = (__int64)sub_14007BBA0();
  *(_QWORD *)(a1 + 32) = result;
  if ( result )
  {
    v4 = SysAllocString(L"xml");
    v5 = SysAllocString(L"version='1.0'");
    (*(void (__fastcall **)(_QWORD, OLECHAR *, OLECHAR *, __int64 *))(**(_QWORD **)(a1 + 32) + 416i64))(
      *(_QWORD *)(a1 + 32),
      v4,
      v5,
      &v15);
    v6 = *(__int64 **)(a1 + 32);
    v7 = *v6;
    v17 = 0i64;
    (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v7 + 168))(v6, v15, &v17);
    if ( v17 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16i64))(v17);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
    v15 = 0i64;
    SysFreeString(v4);
    SysFreeString(v5);
    v8 = SysAllocString(L" Preference file for Explorer++ ");
    (*(void (__fastcall **)(_QWORD, OLECHAR *, __int64 *))(**(_QWORD **)(a1 + 32) + 400i64))(
      *(_QWORD *)(a1 + 32),
      v8,
      &v16);
    v9 = *(__int64 **)(a1 + 32);
    v10 = *v9;
    v17 = 0i64;
    (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v10 + 168))(v9, v16, &v17);
    if ( v17 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16i64))(v17);
    SysFreeString(v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
    v16 = 0i64;
    v11 = SysAllocString(L"ExplorerPlusPlus");
    (*(void (__fastcall **)(_QWORD, OLECHAR *, __int64))(**(_QWORD **)(a1 + 32) + 376i64))(
      *(_QWORD *)(a1 + 32),
      v11,
      a1 + 48);
    SysFreeString(v11);
    v12 = *(__int64 **)(a1 + 32);
    v13 = *(_QWORD *)(a1 + 48);
    v14 = *v12;
    v17 = 0i64;
    (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v14 + 168))(v12, v13, &v17);
    if ( v17 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16i64))(v17);
    result = sub_14007B920(*(__int64 **)(a1 + 32), (__int64)v2, *(_QWORD *)(a1 + 48));
  }
  if ( v15 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  if ( v16 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
  return result;
}

//----- (00000001400855F0) ----------------------------------------------------
__int64 __fastcall sub_1400855F0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 40) )
  {
    result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 16i64))(*(_QWORD *)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0i64;
  }
  return result;
}

//----- (0000000140085620) ----------------------------------------------------
HRESULT __fastcall sub_140085620(__int64 a1)
{
  LPVOID v2; // rax
  DWORD CurrentProcessId; // eax
  HANDLE v4; // rax
  void *v5; // rdi
  BSTR v6; // rax
  __int16 v8; // [rsp+20h] [rbp-288h] BYREF
  VARIANTARG pvarg; // [rsp+28h] [rbp-280h] BYREF
  VARIANTARG v10; // [rsp+40h] [rbp-268h] BYREF
  VARIANTARG v11; // [rsp+60h] [rbp-248h] BYREF
  WCHAR pszPath[264]; // [rsp+80h] [rbp-228h] BYREF

  *(_DWORD *)(a1 + 40) = 0;
  v2 = sub_14007BBA0();
  *(_QWORD *)(a1 + 32) = v2;
  if ( v2 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v4 = OpenProcess(0x410u, 0, CurrentProcessId);
    v5 = v4;
    if ( v4 )
    {
      GetModuleFileNameExW(v4, 0i64, pszPath, 260i64);
      CloseHandle(v5);
    }
    PathRemoveFileSpecW(pszPath);
    PathAppendW(pszPath, L"config.xml");
    VariantInit(&pvarg);
    v6 = SysAllocString(L"config.xml");
    pvarg.vt = 8;
    pvarg.llVal = (LONGLONG)v6;
    *(_OWORD *)&v10.decVal.Lo32 = __PAIR128__((unsigned __int64)pvarg.pRecInfo, (unsigned __int64)v6);
    *(_QWORD *)&v10.vt = *(_QWORD *)&pvarg.vt;
    v11 = pvarg;
    (*(void (__fastcall **)(_QWORD, VARIANTARG *, __int16 *))(**(_QWORD **)(a1 + 32) + 464i64))(
      *(_QWORD *)(a1 + 32),
      &v11,
      &v8);
    if ( v8 == -1 )
      *(_DWORD *)(a1 + 40) = 1;
  }
  return VariantClear(&v10);
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140085770) ----------------------------------------------------
__int64 __fastcall sub_140085770(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0000000140085780) ----------------------------------------------------
__int64 __fastcall sub_140085780(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 2147500034i64;
}

//----- (00000001400857A0) ----------------------------------------------------
void **__fastcall sub_1400857A0(__int64 a1)
{
  bool v1; // zf
  void **result; // rax

  v1 = *(_DWORD *)(a1 + 24) == 0;
  result = &Explorerplusplus::CLoadSaveXML::`vftable';
  *(_QWORD *)a1 = &Explorerplusplus::CLoadSaveXML::`vftable';
  if ( v1 )
    return (void **)sub_1400852B0(a1);
  if ( *(_DWORD *)(a1 + 40) )
  {
    result = (void **)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 16i64))(*(_QWORD *)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0i64;
  }
  return result;
}
// 1400F79C8: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (00000001400857F0) ----------------------------------------------------
__int64 __fastcall sub_1400857F0(__int64 a1, __int64 a2, int a3)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(_QWORD *)a1 = &Explorerplusplus::CLoadSaveXML::`vftable';
  if ( a3 )
    sub_140085620(a1);
  else
    sub_140085400(a1);
  return a1;
}
// 1400F79C8: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (0000000140085870) ----------------------------------------------------
void __fastcall sub_140085870(__int64 a1, __int64 a2)
{
  OLECHAR *v4; // r13
  __int64 v5; // rcx
  int v6; // esi
  _DWORD *v7; // rbx
  BOOL v8; // er12
  int i; // edi
  __int64 v10; // [rsp+20h] [rbp-48h] BYREF
  __int64 v11; // [rsp+28h] [rbp-40h] BYREF
  __int64 v12; // [rsp+30h] [rbp-38h] BYREF
  LPCWSTR lpString1; // [rsp+38h] [rbp-30h] BYREF
  __int64 v14; // [rsp+40h] [rbp-28h] BYREF
  int v15; // [rsp+98h] [rbp+30h] BYREF
  int v16; // [rsp+A0h] [rbp+38h] BYREF
  __int64 v17; // [rsp+A8h] [rbp+40h] BYREF

  if ( a2 )
  {
    v17 = 0i64;
    v10 = 0i64;
    v11 = 0i64;
    v12 = 0i64;
    v4 = SysAllocString(L"//Toolbars/*");
    (*(void (__fastcall **)(__int64, OLECHAR *, __int64 *))(*(_QWORD *)a2 + 288i64))(a2, v4, &v17);
    v5 = v17;
    if ( v17 )
    {
      (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v17 + 64i64))(v17, &v16);
      v6 = 0;
      if ( v16 > 0 )
      {
        v7 = (_DWORD *)(a1 + 61096);
        do
        {
          if ( (*(int (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v17 + 56i64))(v17, (unsigned int)v6, &v10) >= 0
            && (*(int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 136i64))(v10, &v11) >= 0 )
          {
            v8 = (*v7 & 0x200) != 0;
            (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 88i64))(v11, &v15);
            for ( i = 1; i < v15; ++i )
            {
              (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v11 + 80i64))(v11, (unsigned int)i, &v12);
              (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v12 + 56i64))(v12, &lpString1);
              (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v12 + 208i64))(v12, &v14);
              if ( lstrcmpW(lpString1, L"id") )
              {
                if ( lstrcmpW(lpString1, L"Style") )
                {
                  if ( !lstrcmpW(lpString1, L"Length") )
                    v7[12] = sub_14004B61C(v14);
                }
                else
                {
                  *v7 = sub_14004B61C(v14);
                }
              }
              else
              {
                v7[16] = sub_14004B61C(v14);
              }
            }
            if ( v8 )
              *v7 |= 0x200u;
          }
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
          ++v6;
          v7 += 28;
          v10 = 0i64;
        }
        while ( v6 < v16 );
      }
      v5 = v17;
    }
    if ( v4 )
    {
      SysFreeString(v4);
      v5 = v17;
    }
    if ( v5 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16i64))(v5);
    if ( v10 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
  }
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (0000000140085A90) ----------------------------------------------------
void __fastcall sub_140085A90(__int64 a1)
{
  sub_140085870(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (0000000140085AB0) ----------------------------------------------------
__int64 __fastcall sub_140085AB0(void *Block)
{
  bool v1; // zf

  v1 = (*((_DWORD *)Block + 2))-- == 1;
  if ( !v1 )
    return *((unsigned int *)Block + 2);
  v1 = *((_DWORD *)Block + 6) == 0;
  *(_QWORD *)Block = &Explorerplusplus::CLoadSaveXML::`vftable';
  if ( v1 )
  {
    sub_1400852B0((__int64)Block);
  }
  else if ( *((_DWORD *)Block + 10) )
  {
    (*(void (__fastcall **)(_QWORD))(**((_QWORD **)Block + 4) + 16i64))(*((_QWORD *)Block + 4));
    *((_QWORD *)Block + 4) = 0i64;
    j_free(Block);
    return 0i64;
  }
  j_free(Block);
  return 0i64;
}
// 1400F79C8: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (0000000140085B20) ----------------------------------------------------
void __fastcall sub_140085B20(__int64 a1, __int64 *a2, __int64 *a3)
{
  __int64 v3; // rbx
  OLECHAR *v6; // r15
  OLECHAR *v7; // rax
  HWND v8; // rcx
  int v9; // er13
  WPARAM v10; // r14
  __int64 v11; // rax
  HWND v12; // rcx
  OLECHAR *v13; // rbx
  OLECHAR *v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rdi
  OLECHAR *v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rdi
  OLECHAR *v23; // rbx
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rdi
  OLECHAR *v27; // rbx
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 *v30; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v31; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v32; // [rsp+30h] [rbp-D0h] BYREF
  VARIANTARG v33; // [rsp+38h] [rbp-C8h] BYREF
  VARIANTARG pvarg; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v35; // [rsp+68h] [rbp-98h] BYREF
  BSTR bstrString; // [rsp+70h] [rbp-90h]
  __int64 v37; // [rsp+78h] [rbp-88h]
  LRESULT v38; // [rsp+80h] [rbp-80h]
  VARIANTARG v39; // [rsp+90h] [rbp-70h] BYREF
  VARIANTARG v40; // [rsp+B0h] [rbp-50h] BYREF
  VARIANTARG v41; // [rsp+D0h] [rbp-30h] BYREF
  VARIANTARG v42; // [rsp+F0h] [rbp-10h] BYREF
  LPARAM lParam; // [rsp+110h] [rbp+10h] BYREF
  int v44; // [rsp+118h] [rbp+18h]
  int v45; // [rsp+148h] [rbp+48h]
  int Value; // [rsp+158h] [rbp+58h]
  WCHAR psz[32]; // [rsp+180h] [rbp+80h] BYREF

  v3 = a1;
  v37 = a1;
  v32 = 0i64;
  v6 = SysAllocString(L"\n\t\t");
  v7 = SysAllocString(L"\n\t\t\t");
  v8 = *(HWND *)(v3 + 120);
  bstrString = v7;
  v9 = 0;
  v38 = SendMessageW(v8, 0x40Cu, 0i64, 0i64);
  if ( (int)v38 > 0 )
  {
    v10 = 0i64;
    do
    {
      v11 = *a2;
      v30 = 0i64;
      v31 = 0i64;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v11 + 392))(a2, v6, &v30);
      (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*a3 + 168))(a3, v30, &v31);
      if ( v30 )
        (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
      v30 = 0i64;
      if ( v31 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
      v12 = *(HWND *)(v3 + 120);
      lParam = 0x15100000070i64;
      SendMessageW(v12, 0x41Cu, v10, (LPARAM)&lParam);
      wsprintfW(psz, L"%d", (unsigned int)v9);
      v30 = 0i64;
      v31 = 0i64;
      v13 = SysAllocString(L"Toolbar");
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 376))(a2, v13, &v32);
      SysFreeString(v13);
      v14 = SysAllocString(L"name");
      VariantInit(&pvarg);
      v33.llVal = (LONGLONG)SysAllocString(psz);
      pvarg.vt = 8;
      v33.pRecInfo = pvarg.pRecInfo;
      v15 = *a2;
      *(_QWORD *)&v33.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v15 + 424))(a2, v14, &v30);
      v16 = *v30;
      v39 = v33;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v16 + 360))(v30, &v39);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v32 + 384i64))(v32, v30, &v31);
      SysFreeString(v14);
      if ( v31 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
        v31 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
      v30 = 0i64;
      VariantClear(&v33);
      v17 = *a3;
      v35 = 0i64;
      (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v17 + 168))(a3, v32, &v35);
      if ( v35 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v35 + 16i64))(v35);
      itow_s(Value, Buffer, 0x40ui64, 10);
      v18 = v32;
      v30 = 0i64;
      v31 = 0i64;
      v19 = SysAllocString(L"id");
      VariantInit(&pvarg);
      v33.llVal = (LONGLONG)SysAllocString(Buffer);
      pvarg.vt = 8;
      v33.pRecInfo = pvarg.pRecInfo;
      v20 = *a2;
      *(_QWORD *)&v33.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v20 + 424))(a2, v19, &v30);
      v21 = *v30;
      v41 = v33;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v21 + 360))(v30, &v41);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v18 + 384i64))(v18, v30, &v31);
      SysFreeString(v19);
      if ( v31 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
        v31 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
      v30 = 0i64;
      VariantClear(&v33);
      itow_s(v44, Buffer, 0x40ui64, 10);
      v22 = v32;
      v30 = 0i64;
      v31 = 0i64;
      v23 = SysAllocString(L"Style");
      VariantInit(&pvarg);
      v33.llVal = (LONGLONG)SysAllocString(Buffer);
      pvarg.vt = 8;
      v33.pRecInfo = pvarg.pRecInfo;
      v24 = *a2;
      *(_QWORD *)&v33.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v24 + 424))(a2, v23, &v30);
      v25 = *v30;
      v42 = v33;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v25 + 360))(v30, &v42);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v22 + 384i64))(v22, v30, &v31);
      SysFreeString(v23);
      if ( v31 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
        v31 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
      v30 = 0i64;
      VariantClear(&v33);
      itow_s(v45, Buffer, 0x40ui64, 10);
      v26 = v32;
      v30 = 0i64;
      v31 = 0i64;
      v27 = SysAllocString(L"Length");
      VariantInit(&pvarg);
      v33.llVal = (LONGLONG)SysAllocString(Buffer);
      pvarg.vt = 8;
      v33.pRecInfo = pvarg.pRecInfo;
      v28 = *a2;
      *(_QWORD *)&v33.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v28 + 424))(a2, v27, &v30);
      v29 = *v30;
      v40 = v33;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v29 + 360))(v30, &v40);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v26 + 384i64))(v26, v30, &v31);
      SysFreeString(v27);
      if ( v31 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16i64))(v31);
        v31 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
      v30 = 0i64;
      VariantClear(&v33);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v32 + 16i64))(v32);
      v3 = v37;
      ++v9;
      ++v10;
      v32 = 0i64;
    }
    while ( v9 < (int)v38 );
  }
  SysFreeString(v6);
  SysFreeString(bstrString);
}
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (0000000140086100) ----------------------------------------------------
__int64 __fastcall sub_140086100(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rdi
  OLECHAR *v7; // rbx
  __int64 v8; // rax
  __int64 *v10; // [rsp+48h] [rbp+10h] BYREF
  __int64 v11; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v7 = SysAllocString(L"Toolbars");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  sub_140085B20(a1, a2, v10);
  sub_14007B920(a2, (__int64)v6, (__int64)v10);
  v8 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v8 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  return (*(__int64 (__fastcall **)(__int64 *))(*v10 + 16))(v10);
}

//----- (00000001400861F0) ----------------------------------------------------
__int64 __fastcall sub_1400861F0(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rax
  HWND v7; // rcx
  __int64 v8; // rbx
  __int64 v10; // [rsp+30h] [rbp-40h] BYREF
  WINDOWPLACEMENT wndpl; // [rsp+38h] [rbp-38h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t\t");
  v7 = *(HWND *)(a1 + 104);
  wndpl.length = 44;
  v8 = (__int64)v6;
  GetWindowPlacement(v7, &wndpl);
  sub_14007B920(a2, v8, (__int64)a3);
  sub_14007BD50(a2, &v10, a3, L"Setting", L"Position");
  itow_s(wndpl.flags, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"Flags", Buffer);
  itow_s(wndpl.showCmd, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"ShowCmd", Buffer);
  itow_s(wndpl.ptMinPosition.x, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"MinPositionX", Buffer);
  itow_s(wndpl.ptMinPosition.y, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"MinPositionY", Buffer);
  itow_s(wndpl.ptMaxPosition.x, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"MaxPositionX", Buffer);
  itow_s(wndpl.ptMaxPosition.y, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"MaxPositionY", Buffer);
  itow_s(wndpl.rcNormalPosition.left, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"NormalPositionLeft", Buffer);
  itow_s(wndpl.rcNormalPosition.top, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"NormalPositionTop", Buffer);
  itow_s(wndpl.rcNormalPosition.right, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"NormalPositionRight", Buffer);
  itow_s(wndpl.rcNormalPosition.bottom, Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v10, L"NormalPositionBottom", Buffer);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
}
// 1400EDC98: using guessed type wchar_t aPosition_1[9];
// 1400EDCB0: using guessed type wchar_t aSetting[8];
// 1400EDCC0: using guessed type wchar_t aFlags_0[6];
// 1400EDCD0: using guessed type wchar_t aShowcmd_0[8];
// 1400EDCE0: using guessed type wchar_t aMinpositionx_0[13];
// 1400EDD00: using guessed type wchar_t aMinpositiony_0[13];
// 1400EDD20: using guessed type wchar_t aMaxpositionx_0[13];
// 1400EDD40: using guessed type wchar_t aMaxpositiony_0[13];
// 1400EDD60: using guessed type wchar_t aNormalposition_3[19];
// 1400EDD88: using guessed type wchar_t aNormalposition_4[18];
// 1400EDDB0: using guessed type wchar_t aNormalposition_5[20];
// 1400EDDD8: using guessed type wchar_t aNormalposition_6[21];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (00000001400864A0) ----------------------------------------------------
__int64 __fastcall sub_1400864A0(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rsi
  OLECHAR *v7; // rbx
  __int64 v8; // rax
  __int64 *v10; // [rsp+48h] [rbp+10h] BYREF
  __int64 v11; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  v7 = SysAllocString(L"WindowPosition");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  sub_1400861F0(a1, a2, v10);
  sub_14007B920(a2, (__int64)v6, (__int64)v10);
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v8 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v8 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  return (*(__int64 (__fastcall **)(__int64 *))(*v10 + 16))(v10);
}

//----- (0000000140086590) ----------------------------------------------------
__int64 __fastcall sub_140086590(__int64 a1)
{
  return sub_140086100(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (00000001400865B0) ----------------------------------------------------
int __fastcall sub_1400865B0(LPCWSTR lpString1, LPCWSTR a2, int *a3, _DWORD *a4)
{
  int result; // eax
  int *v9; // rcx
  __int64 v10; // rdx
  signed __int64 v11; // rbx
  __int64 v12; // rdx
  signed __int64 v13; // rbx

  if ( !lstrcmpW(lpString1, L"ApplyFilter") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[7] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"AutoArrange") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[5] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"Filter") )
  {
    v9 = a3 + 15;
    v10 = 512i64;
    v11 = (char *)a2 - (char *)(a3 + 15);
    while ( 1 )
    {
      result = v10 + 2147483134;
      if ( v10 == -2147483134 )
        break;
      result = *(unsigned __int16 *)((char *)v9 + v11);
      if ( !(_WORD)result )
        break;
      *(_WORD *)v9 = result;
      v9 = (int *)((char *)v9 + 2);
      if ( !--v10 )
        goto LABEL_38;
    }
LABEL_39:
    *(_WORD *)v9 = 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"FilterCaseSensitive") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[8] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"ShowGridlines") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[6] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"ShowHidden") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[4] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"ShowInGroups") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[3] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"SortAscending") )
  {
    result = lstrcmpW(a2, L"yes");
    a3[2] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"SortMode") )
  {
    result = sub_14004B61C(a2);
    *a3 = result;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"ViewMode") )
  {
    result = sub_14004B61C(a2);
    a3[1] = result;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"Locked") )
  {
    result = lstrcmpW(a2, L"yes");
    *a4 = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"AddressLocked") )
  {
    result = lstrcmpW(a2, L"yes");
    a4[1] = result == 0;
    return result;
  }
  if ( !lstrcmpW(lpString1, L"UseCustomName") )
  {
    result = lstrcmpW(a2, L"yes");
    a4[2] = result == 0;
    return result;
  }
  result = lstrcmpW(lpString1, L"CustomName");
  if ( !result )
  {
    v9 = a4 + 3;
    v12 = 260i64;
    v13 = (char *)a2 - (char *)(a4 + 3);
    while ( 1 )
    {
      result = v12 + 2147483386;
      if ( v12 == -2147483386 )
        goto LABEL_39;
      result = *(unsigned __int16 *)((char *)v9 + v13);
      if ( !(_WORD)result )
        goto LABEL_39;
      *(_WORD *)v9 = result;
      v9 = (int *)((char *)v9 + 2);
      if ( !--v12 )
      {
LABEL_38:
        v9 = (int *)((char *)v9 - 2);
        goto LABEL_39;
      }
    }
  }
  return result;
}
// 1400868B6: conditional instruction was optimized away because rdx.8!=0
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (00000001400868E0) ----------------------------------------------------
__int64 __fastcall sub_1400868E0(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v5; // rdi
  OLECHAR *v6; // rbx
  OLECHAR *v7; // r13
  OLECHAR *v8; // rax
  OLECHAR *v9; // r11
  OLECHAR *v10; // r11
  OLECHAR *v11; // r11
  OLECHAR *v12; // r11
  OLECHAR *v13; // r11
  OLECHAR *v14; // r11
  OLECHAR *v15; // r11
  int v16; // ebx
  const OLECHAR *v17; // r9
  const OLECHAR *v18; // r9
  const OLECHAR *v19; // r9
  int v20; // ebx
  int v21; // ebx
  OLECHAR *v22; // r11
  OLECHAR *v23; // r11
  OLECHAR *v24; // r11
  OLECHAR *v25; // r11
  OLECHAR *v26; // r11
  OLECHAR *v27; // r11
  OLECHAR *v28; // r11
  OLECHAR *v29; // r11
  OLECHAR *v30; // r11
  OLECHAR *v31; // r11
  OLECHAR *v32; // r11
  OLECHAR *v33; // r11
  OLECHAR *v34; // r11
  OLECHAR *v35; // r11
  OLECHAR *v36; // r11
  OLECHAR *v37; // r11
  OLECHAR *v38; // r11
  OLECHAR *v39; // r11
  OLECHAR *v40; // r11
  OLECHAR *v41; // r11
  OLECHAR *v42; // r11
  OLECHAR *v43; // r11
  OLECHAR *v44; // r11
  OLECHAR *v45; // r11
  OLECHAR *v46; // r11
  OLECHAR *v47; // r11
  OLECHAR *v48; // r11
  OLECHAR *v49; // r11
  OLECHAR *v50; // r11
  OLECHAR *v51; // r11
  OLECHAR *v52; // r11
  OLECHAR *v53; // r11
  OLECHAR *v54; // r11
  OLECHAR *v55; // r11
  OLECHAR *v56; // r11
  OLECHAR *v57; // r11
  OLECHAR *v58; // r11
  OLECHAR *v59; // r11
  OLECHAR *v60; // r11
  int v61; // er12
  int v62; // er15
  WPARAM v63; // r13
  int v64; // er11
  UINT v65; // ebx
  HMODULE ModuleHandleW; // rax
  __int64 v67; // rdi
  OLECHAR *v68; // rbx
  __int64 v69; // rax
  __int64 v70; // rax
  __int64 v71; // rax
  __int64 *v72; // rbx
  __int64 v73; // rax
  __int64 *v74; // rbx
  __int64 v75; // rax
  __int64 *v76; // rbx
  __int64 v77; // rax
  __int64 *v78; // rbx
  __int64 *v79; // rbx
  __int64 v80; // rax
  __int64 *v82; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v83; // [rsp+38h] [rbp-C8h] BYREF
  __int64 *v84; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v85; // [rsp+48h] [rbp-B8h] BYREF
  __int64 *v86; // [rsp+50h] [rbp-B0h]
  WPARAM wParam; // [rsp+58h] [rbp-A8h] BYREF
  OLECHAR *v88; // [rsp+60h] [rbp-A0h]
  VARIANTARG v89; // [rsp+68h] [rbp-98h] BYREF
  BSTR v90; // [rsp+80h] [rbp-80h]
  VARIANTARG pvarg; // [rsp+88h] [rbp-78h] BYREF
  VARIANTARG v92; // [rsp+A0h] [rbp-60h] BYREF
  int pv[5]; // [rsp+C0h] [rbp-40h] BYREF
  char v94; // [rsp+D4h] [rbp-2Ch]
  char v95; // [rsp+D5h] [rbp-2Bh]
  char v96; // [rsp+D6h] [rbp-2Ah]
  __int16 v97[34]; // [rsp+DCh] [rbp-24h] BYREF
  LPARAM lParam; // [rsp+120h] [rbp+20h] BYREF
  wchar_t v99[32]; // [rsp+140h] [rbp+40h] BYREF
  OLECHAR psz[32]; // [rsp+180h] [rbp+80h] BYREF
  WCHAR Buffer[256]; // [rsp+1C0h] [rbp+C0h] BYREF

  v86 = a3;
  v82 = 0i64;
  v83 = 0i64;
  v90 = SysAllocString(L"\n\t");
  v5 = SysAllocString(L"\n\t\t");
  v88 = v5;
  v6 = SysAllocString(L"Settings");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v6, &v82);
  SysFreeString(v6);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v7 = aYes_0;
  v8 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60852) )
    v8 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"AllowMultipleInstances", v8);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v9 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60788) )
    v9 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"AlwaysOpenInNewTab", v9);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v10 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60776) )
    v10 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"AlwaysShowTabBar", v10);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v11 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60952) )
    v11 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"AutoArrangeGlobal", v11);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v12 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60876) )
    v12 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"CheckBoxSelection", v12);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v13 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60884) )
    v13 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"CloseMainWindowOnTabClose", v13);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v14 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60808) )
    v14 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ConfirmCloseTabs", v14);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v15 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60796) )
    v15 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"DisableFolderSizesNetworkRemovable", v15);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007BD50(a2, &v83, v82, L"Setting", L"DisplayCentreColor");
  v16 = SendMessageW(*(HWND *)(a1 + 128), 0x806Bu, 0i64, 0i64);
  itow_s((unsigned __int8)v16, ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"r", ::Buffer);
  itow_s(BYTE1(v16), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"g", ::Buffer);
  itow_s(BYTE2(v16), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"b", ::Buffer);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 16i64))(v83);
  v83 = 0i64;
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007BD50(a2, &v83, v82, L"Setting", L"DisplayFont");
  SendMessageW(*(HWND *)(a1 + 128), 0x806Fu, (WPARAM)&wParam, 0i64);
  GetObjectW((HANDLE)wParam, 92, pv);
  itow_s(pv[0], ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"Height", ::Buffer);
  itow_s(pv[1], ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"Width", ::Buffer);
  itow_s(pv[4], ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"Weight", ::Buffer);
  v17 = aYes_0;
  if ( !v94 )
    v17 = aNo;
  sub_14007BEA0(a2, v83, L"Italic", v17);
  v18 = aYes_0;
  if ( !v95 )
    v18 = aNo;
  sub_14007BEA0(a2, v83, L"Underline", v18);
  v19 = aYes_0;
  if ( !v96 )
    v19 = aNo;
  sub_14007BEA0(a2, v83, L"Strikeout", v19);
  sub_14007BEA0(a2, v83, L"Font", (const OLECHAR *)v97);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007BD50(a2, &v83, v82, L"Setting", L"DisplaySurroundColor");
  v20 = SendMessageW(*(HWND *)(a1 + 128), 0x8067u, 0i64, 0i64);
  itow_s((unsigned __int8)v20, ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"r", ::Buffer);
  itow_s(BYTE1(v20), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"g", ::Buffer);
  itow_s(BYTE2(v20), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"b", ::Buffer);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 16i64))(v83);
  v83 = 0i64;
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007BD50(a2, &v83, v82, L"Setting", L"DisplayTextColor");
  v21 = SendMessageW(*(HWND *)(a1 + 128), 0x8071u, 0i64, 0i64);
  itow_s((unsigned __int8)v21, ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"r", ::Buffer);
  itow_s(BYTE1(v21), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"g", ::Buffer);
  itow_s(BYTE2(v21), ::Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, v83, L"b", ::Buffer);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 16i64))(v83);
  v83 = 0i64;
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 7012), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"DisplayWindowHeight", v99);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v22 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60860) )
    v22 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"DoubleClickTabClose", v22);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v23 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60824) )
    v23 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ExtendTabControl", v23);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v24 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60856) )
    v24 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ForceSameTabWidth", v24);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v25 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60880) )
    v25 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ForceSize", v25);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v26 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60864) )
    v26 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"HandleZipFiles", v26);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v27 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60972) )
    v27 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"HideLinkExtensionGlobal", v27);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v28 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60968) )
    v28 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"HideSystemFilesGlobal", v28);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 60932), ::Buffer, 0x40ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"InfoTipType", ::Buffer);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v29 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60868) )
    v29 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"InsertSorted", v29);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 7000), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"Language", v99);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v30 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60908) )
    v30 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"LargeToolbarIcons", v30);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 7056), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"LastSelectedTab", v99);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v31 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60820) )
    v31 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"LockToolbars", v31);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v32 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60804) )
    v32 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"NextToCurrent", v32);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007B9E0(a2, v82, L"Setting", L"NewTabDirectory", (OLECHAR *)(a1 + 5960));
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v33 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60844) )
    v33 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"OneClickActivate", v33);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 60848), ::Buffer, 0x40ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"OneClickActivateHoverTime", ::Buffer);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v34 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60872) )
    v34 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"OverwriteExistingFilesConfirmation", v34);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v35 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60912) )
    v35 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"PlayNavigationSound", v35);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 60924), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"ReplaceExplorerMode", v99);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v36 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60752) )
    v36 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowAddressBar", v36);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v37 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60772) )
    v37 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowApplicationToolbar", v37);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v38 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60764) )
    v38 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowBookmarksToolbar", v38);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v39 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60768) )
    v39 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowDrivesToolbar", v39);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v40 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60756) )
    v40 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowDisplayWindow", v40);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v41 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60944) )
    v41 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowExtensions", v41);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v42 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60840) )
    v42 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowFilePreviews", v42);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v43 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60748) )
    v43 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowFolders", v43);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v44 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60792) )
    v44 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowFolderSizes", v44);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v45 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60960) )
    v45 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowFriendlyDates", v45);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v46 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60784) )
    v46 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowFullTitlePath", v46);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v47 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60964) )
    v47 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowGridlinesGlobal", v47);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v48 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60940) )
    v48 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowHiddenGlobal", v48);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v49 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60928) )
    v49 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowInfoTips", v49);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v50 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60948) )
    v50 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowInGroupsGlobal", v50);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v51 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60836) )
    v51 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowPrivilegeLevelInTitleBar", v51);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v52 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60744) )
    v52 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowStatusBar", v52);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v53 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60888) )
    v53 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowTabBarAtBottom", v53);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v54 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60892) )
    v54 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowTaskbarThumbnails", v54);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v55 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60760) )
    v55 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowToolbar", v55);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v56 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60832) )
    v56 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"ShowUserNameTitleBar", v56);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 60916), ::Buffer, 0x40ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"SizeDisplayFormat", ::Buffer);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v57 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60956) )
    v57 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"SortAscendingGlobal", v57);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  itow_s(*(_DWORD *)(a1 + 60920), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"StartupMode", v99);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v58 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60900) )
    v58 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"SynchronizeTreeview", v58);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v59 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60904) )
    v59 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"TVAutoExpandSelected", v59);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  v60 = aYes_0;
  if ( !*(_DWORD *)(a1 + 60828) )
    v60 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"UseFullRowSelect", v60);
  sub_14007B920(a2, (__int64)v5, (__int64)v82);
  sub_14007BD50(a2, &v83, v82, L"Setting", L"ToolbarState");
  v61 = 0;
  v62 = SendMessageW(*(HWND *)(a1 + 176), 0x418u, 0i64, 0i64);
  if ( v62 > 0 )
  {
    v63 = 0i64;
    do
    {
      SendMessageW(*(HWND *)(a1 + 176), 0x417u, v63, (LPARAM)&lParam);
      sub_140001000(psz, 0x20ui64, L"Button%d", (unsigned int)v61);
      v64 = HIDWORD(lParam);
      if ( !HIDWORD(lParam) )
        v64 = 45001;
      if ( (unsigned int)(v64 - 45001) > 0x15 )
        v65 = 0;
      else
        v65 = sub_1400BC740(v64 - 45001);
      ModuleHandleW = GetModuleHandleW(0i64);
      LoadStringW(ModuleHandleW, v65, Buffer, 256);
      v67 = v83;
      v84 = 0i64;
      v85 = 0i64;
      v68 = SysAllocString(psz);
      VariantInit(&pvarg);
      v89.llVal = (LONGLONG)SysAllocString(Buffer);
      pvarg.vt = 8;
      v89.pRecInfo = pvarg.pRecInfo;
      v69 = *a2;
      *(_QWORD *)&v89.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v69 + 424))(a2, v68, &v84);
      v70 = *v84;
      v92 = v89;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v70 + 360))(v84, &v92);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v67 + 384i64))(v67, v84, &v85);
      SysFreeString(v68);
      if ( v85 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
        v85 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v84 + 16))(v84);
      v84 = 0i64;
      VariantClear(&v89);
      ++v61;
      ++v63;
    }
    while ( v61 < v62 );
    v5 = v88;
    v7 = aYes_0;
  }
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v83 + 16i64))(v83);
  v71 = *a2;
  v72 = v82;
  v83 = 0i64;
  v84 = 0i64;
  v85 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v71 + 392))(a2, v5, &v84);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*v72 + 168))(v72, v84, &v85);
  if ( v84 )
    (*(void (__fastcall **)(__int64 *))(*v84 + 16))(v84);
  v84 = 0i64;
  if ( v85 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
  if ( !*(_DWORD *)(a1 + 60812) )
    v7 = aNo;
  sub_14007B9E0(a2, v82, L"Setting", L"TreeViewDelayEnabled", v7);
  v73 = *a2;
  v74 = v82;
  v84 = 0i64;
  v85 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v73 + 392))(a2, v5, &v84);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*v74 + 168))(v74, v84, &v85);
  if ( v84 )
    (*(void (__fastcall **)(__int64 *))(*v84 + 16))(v84);
  v84 = 0i64;
  if ( v85 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
  itow_s(*(_DWORD *)(a1 + 7044), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"TreeViewWidth", v99);
  v75 = *a2;
  v76 = v82;
  v84 = 0i64;
  v85 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v75 + 392))(a2, v5, &v84);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*v76 + 168))(v76, v84, &v85);
  if ( v84 )
    (*(void (__fastcall **)(__int64 *))(*v84 + 16))(v84);
  v84 = 0i64;
  if ( v85 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
  itow_s(*(_DWORD *)(a1 + 60936), v99, 0x20ui64, 10);
  sub_14007B9E0(a2, v82, L"Setting", L"ViewModeGlobal", v99);
  v77 = *a2;
  v78 = v82;
  v84 = 0i64;
  v85 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v77 + 392))(a2, v90, &v84);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*v78 + 168))(v78, v84, &v85);
  if ( v84 )
    (*(void (__fastcall **)(__int64 *))(*v84 + 16))(v84);
  v84 = 0i64;
  if ( v85 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
  v79 = v86;
  v80 = *v86;
  v85 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v80 + 168))(v86, v82, &v85);
  if ( v85 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v85 + 16i64))(v85);
  (*(void (__fastcall **)(__int64 *))(*v82 + 16))(v82);
  v82 = 0i64;
  return sub_1400864A0(a1, a2, v79);
}
// 1400EAF14: using guessed type wchar_t aR_3[2];
// 1400EAF34: using guessed type wchar_t aG_3[2];
// 1400EAF64: using guessed type wchar_t aB_8[2];
// 1400EAF84: using guessed type wchar_t aR_4[2];
// 1400EAFA4: using guessed type wchar_t aG_4[2];
// 1400EAFCC: using guessed type wchar_t aB_9[2];
// 1400EB004: using guessed type wchar_t aR_5[2];
// 1400EB26C: using guessed type wchar_t aG_5[2];
// 1400EB29C: using guessed type wchar_t aB_10[2];
// 1400EC7B8: using guessed type wchar_t aAllowmultiplei_0[23];
// 1400EC7E8: using guessed type wchar_t aSetting_0[8];
// 1400EC7F8: using guessed type wchar_t aAlwaysopeninne[19];
// 1400EC820: using guessed type wchar_t aSetting_1[8];
// 1400EC830: using guessed type wchar_t aAlwaysshowtabb[17];
// 1400EC858: using guessed type wchar_t aSetting_2[8];
// 1400EC868: using guessed type wchar_t aAutoarrangeglo[18];
// 1400EC890: using guessed type wchar_t aSetting_3[8];
// 1400EC8A0: using guessed type wchar_t aCheckboxselect[18];
// 1400EC8C8: using guessed type wchar_t aSetting_4[8];
// 1400EC8D8: using guessed type wchar_t aClosemainwindo[26];
// 1400EC910: using guessed type wchar_t aSetting_5[8];
// 1400EC920: using guessed type wchar_t aConfirmcloseta[17];
// 1400EC948: using guessed type wchar_t aSetting_6[8];
// 1400EC958: using guessed type wchar_t aDisplaycentrec[19];
// 1400EC980: using guessed type wchar_t aDisablefolders[35];
// 1400EC9C8: using guessed type wchar_t aSetting_7[8];
// 1400EC9D8: using guessed type wchar_t aSetting_8[8];
// 1400EC9E8: using guessed type wchar_t aDisplayfont[12];
// 1400ECA00: using guessed type wchar_t aSetting_9[8];
// 1400ECA10: using guessed type wchar_t aHeight_4[7];
// 1400ECA20: using guessed type wchar_t aWidth_4[6];
// 1400ECA30: using guessed type wchar_t aWeight_0[7];
// 1400ECA40: using guessed type wchar_t aItalic_0[7];
// 1400ECA50: using guessed type wchar_t aUnderline_0[10];
// 1400ECA68: using guessed type wchar_t aStrikeout_0[10];
// 1400ECA80: using guessed type wchar_t aFont_0[5];
// 1400ECA90: using guessed type wchar_t aDisplaysurroun[21];
// 1400ECAC0: using guessed type wchar_t aSetting_10[8];
// 1400ECAD0: using guessed type wchar_t aDisplaytextcol[17];
// 1400ECAF8: using guessed type wchar_t aSetting_11[8];
// 1400ECB08: using guessed type wchar_t aDisplaywindowh[20];
// 1400ECB30: using guessed type wchar_t aSetting_12[8];
// 1400ECB40: using guessed type wchar_t aDoubleclicktab[20];
// 1400ECB68: using guessed type wchar_t aSetting_13[8];
// 1400ECB78: using guessed type wchar_t aExtendtabcontr[17];
// 1400ECBA0: using guessed type wchar_t aSetting_14[8];
// 1400ECBB0: using guessed type wchar_t aForcesametabwi[18];
// 1400ECBD8: using guessed type wchar_t aSetting_15[8];
// 1400ECBE8: using guessed type wchar_t aForcesize[10];
// 1400ECC00: using guessed type wchar_t aSetting_16[8];
// 1400ECC10: using guessed type wchar_t aHandlezipfiles[15];
// 1400ECC30: using guessed type wchar_t aSetting_17[8];
// 1400ECC40: using guessed type wchar_t aHidelinkextens[24];
// 1400ECC70: using guessed type wchar_t aSetting_18[8];
// 1400ECC80: using guessed type wchar_t aHidesystemfile[22];
// 1400ECCB0: using guessed type wchar_t aSetting_19[8];
// 1400ECCC0: using guessed type wchar_t aInfotiptype[12];
// 1400ECCD8: using guessed type wchar_t aSetting_20[8];
// 1400ECCE8: using guessed type wchar_t aInsertsorted[13];
// 1400ECD08: using guessed type wchar_t aSetting_21[8];
// 1400ECD18: using guessed type wchar_t aLanguage[9];
// 1400ECD30: using guessed type wchar_t aSetting_22[8];
// 1400ECD40: using guessed type wchar_t aLargetoolbaric[18];
// 1400ECD68: using guessed type wchar_t aSetting_23[8];
// 1400ECD78: using guessed type wchar_t aLastselectedta[16];
// 1400ECD98: using guessed type wchar_t aSetting_24[8];
// 1400ECDA8: using guessed type wchar_t aLocktoolbars[13];
// 1400ECDC8: using guessed type wchar_t aSetting_25[8];
// 1400ECDD8: using guessed type wchar_t aNexttocurrent[14];
// 1400ECDF8: using guessed type wchar_t aSetting_26[8];
// 1400ECE08: using guessed type wchar_t aNewtabdirector[16];
// 1400ECE28: using guessed type wchar_t aSetting_27[8];
// 1400ECE38: using guessed type wchar_t aOneclickactiva[17];
// 1400ECE60: using guessed type wchar_t aSetting_28[8];
// 1400ECE70: using guessed type wchar_t aOneclickactiva_0[26];
// 1400ECEA8: using guessed type wchar_t aSetting_29[8];
// 1400ECEB8: using guessed type wchar_t aPlaynavigation[20];
// 1400ECEE0: using guessed type wchar_t aOverwriteexist[35];
// 1400ECF28: using guessed type wchar_t aSetting_30[8];
// 1400ECF38: using guessed type wchar_t aSetting_31[8];
// 1400ECF48: using guessed type wchar_t aReplaceexplore[20];
// 1400ECF70: using guessed type wchar_t aSetting_32[8];
// 1400ECF80: using guessed type wchar_t aShowaddressbar[15];
// 1400ECFA0: using guessed type wchar_t aSetting_33[8];
// 1400ECFB0: using guessed type wchar_t aShowapplicatio[23];
// 1400ECFE0: using guessed type wchar_t aSetting_34[8];
// 1400ECFF0: using guessed type wchar_t aShowbookmarkst[21];
// 1400ED020: using guessed type wchar_t aSetting_35[8];
// 1400ED030: using guessed type wchar_t aShowdrivestool[18];
// 1400ED058: using guessed type wchar_t aSetting_36[8];
// 1400ED068: using guessed type wchar_t aShowdisplaywin[18];
// 1400ED090: using guessed type wchar_t aSetting_37[8];
// 1400ED0A0: using guessed type wchar_t aShowextensions[15];
// 1400ED0C0: using guessed type wchar_t aSetting_38[8];
// 1400ED0D0: using guessed type wchar_t aShowfileprevie[17];
// 1400ED0F8: using guessed type wchar_t aSetting_39[8];
// 1400ED108: using guessed type wchar_t aShowfolders[12];
// 1400ED120: using guessed type wchar_t aSetting_40[8];
// 1400ED130: using guessed type wchar_t aShowfoldersize[16];
// 1400ED150: using guessed type wchar_t aSetting_41[8];
// 1400ED160: using guessed type wchar_t aShowfriendlyda[18];
// 1400ED188: using guessed type wchar_t aSetting_42[8];
// 1400ED198: using guessed type wchar_t aShowfulltitlep[18];
// 1400ED1C0: using guessed type wchar_t aSetting_43[8];
// 1400ED1D0: using guessed type wchar_t aShowgridlinesg[20];
// 1400ED1F8: using guessed type wchar_t aSetting_44[8];
// 1400ED208: using guessed type wchar_t aShowhiddenglob[17];
// 1400ED230: using guessed type wchar_t aSetting_45[8];
// 1400ED240: using guessed type wchar_t aShowinfotips[13];
// 1400ED260: using guessed type wchar_t aSetting_46[8];
// 1400ED270: using guessed type wchar_t aShowingroupsgl[19];
// 1400ED298: using guessed type wchar_t aSetting_47[8];
// 1400ED2A8: using guessed type wchar_t aShowprivilegel[29];
// 1400ED2E8: using guessed type wchar_t aSetting_48[8];
// 1400ED2F8: using guessed type wchar_t aShowstatusbar[14];
// 1400ED318: using guessed type wchar_t aSetting_49[8];
// 1400ED328: using guessed type wchar_t aShowtabbaratbo[19];
// 1400ED350: using guessed type wchar_t aSetting_50[8];
// 1400ED360: using guessed type wchar_t aShowtaskbarthu[22];
// 1400ED390: using guessed type wchar_t aSetting_51[8];
// 1400ED3A0: using guessed type wchar_t aShowtoolbar[12];
// 1400ED3B8: using guessed type wchar_t aSetting_52[8];
// 1400ED3C8: using guessed type wchar_t aShowusernameti[21];
// 1400ED3F8: using guessed type wchar_t aSetting_53[8];
// 1400ED408: using guessed type wchar_t aSizedisplayfor[18];
// 1400ED430: using guessed type wchar_t aSetting_54[8];
// 1400ED440: using guessed type wchar_t aSortascendingg[20];
// 1400ED468: using guessed type wchar_t aSetting_55[8];
// 1400ED478: using guessed type wchar_t aStartupmode[12];
// 1400ED490: using guessed type wchar_t aSetting_56[8];
// 1400ED4A0: using guessed type wchar_t aSynchronizetre[20];
// 1400ED4C8: using guessed type wchar_t aSetting_57[8];
// 1400ED4D8: using guessed type wchar_t aTvautoexpandse[21];
// 1400ED508: using guessed type wchar_t aSetting_58[8];
// 1400ED518: using guessed type wchar_t aUsefullrowsele[17];
// 1400ED540: using guessed type wchar_t aSetting_59[8];
// 1400ED550: using guessed type wchar_t aToolbarstate[13];
// 1400ED570: using guessed type wchar_t aSetting_60[8];
// 1400ED580: using guessed type wchar_t aButtonD[9];
// 1400ED598: using guessed type wchar_t aTreeviewdelaye[21];
// 1400ED5C8: using guessed type wchar_t aSetting_61[8];
// 1400ED5D8: using guessed type wchar_t aTreeviewwidth[14];
// 1400ED5F8: using guessed type wchar_t aSetting_62[8];
// 1400ED608: using guessed type wchar_t aViewmodeglobal[15];
// 1400ED628: using guessed type wchar_t aSetting_63[8];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 14012E660: using guessed type OLECHAR Buffer[64];
// 1400868E0: using guessed type OLECHAR var_324[34];

//----- (0000000140088040) ----------------------------------------------------
__int64 __fastcall sub_140088040(__int64 a1)
{
  return sub_1400868E0(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (0000000140088060) ----------------------------------------------------
int __fastcall sub_140088060(__int64 a1, __int64 *a2, const WCHAR *a3, const WCHAR *a4)
{
  UINT v4; // ebx
  int v8; // ecx
  CHAR *v9; // r11
  _QWORD **v10; // rax
  __int64 v11; // rax
  BOOL v12; // esi
  int i; // er12
  HWND v14; // rcx
  __int64 *v15; // rsi
  int v16; // er12
  int v17; // ebx
  __int64 v18; // rdi
  __int64 v19; // rdx
  char *v20; // rdi
  __int64 v21; // rcx
  char *v22; // rsi
  int v24; // [rsp+40h] [rbp-C0h] BYREF
  LPCWSTR lpString1; // [rsp+48h] [rbp-B8h] BYREF
  LPCWSTR v26; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v27; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v28; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v29; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v30; // [rsp+6Ch] [rbp-94h] BYREF
  unsigned int v31; // [rsp+70h] [rbp-90h] BYREF
  char v32[8]; // [rsp+78h] [rbp-88h] BYREF
  WINDOWPLACEMENT wndpl; // [rsp+80h] [rbp-80h] BYREF
  CHAR MultiByteStr[512]; // [rsp+B0h] [rbp-50h] BYREF

  v4 = 0;
  WideCharToMultiByte(0, 0, a3, -1, MultiByteStr, 512, 0i64, 0i64);
  v8 = (unsigned __int8)MultiByteStr[0];
  v9 = MultiByteStr;
  LODWORD(v10) = 5381;
  if ( MultiByteStr[0] )
  {
    do
    {
      ++v9;
      LODWORD(v10) = v8 + 33 * (_DWORD)v10;
      v8 = (unsigned __int8)*v9;
    }
    while ( *v9 );
    if ( (unsigned int)v10 > 0x7674C254 )
    {
      if ( (unsigned int)v10 > 0xCE783598 )
      {
        if ( (unsigned int)v10 > 0xE15C9D5D )
        {
          if ( (unsigned int)v10 > 0xF452395C )
          {
            switch ( (_DWORD)v10 )
            {
              case 0xFB1A605F:
                LODWORD(v10) = sub_14007BC30((__int64)a2);
                *(_DWORD *)(a1 + 7108) = (_DWORD)v10;
                break;
              case 0xFCAFEEAE:
                LODWORD(v10) = lstrcmpW(a4, L"yes");
                LOBYTE(v4) = (_DWORD)v10 == 0;
                *(_DWORD *)(a1 + 60948) = v4;
                break;
              case 0xFDC88F50:
                LODWORD(v10) = sub_14004B61C(a4);
                *(_DWORD *)(a1 + 7044) = (_DWORD)v10;
                break;
            }
          }
          else
          {
            switch ( (_DWORD)v10 )
            {
              case 0xF452395C:
                LODWORD(v10) = lstrcmpW(a4, L"yes");
                LOBYTE(v4) = (_DWORD)v10 == 0;
                *(_DWORD *)(a1 + 60888) = v4;
                break;
              case 0xE50EFE54:
                LODWORD(v10) = lstrcmpW(a4, L"yes");
                LOBYTE(v4) = (_DWORD)v10 == 0;
                *(_DWORD *)(a1 + 60820) = v4;
                break;
              case 0xF2AF1973:
                LODWORD(v10) = lstrcmpW(a4, L"yes");
                LOBYTE(v4) = (_DWORD)v10 == 0;
                *(_DWORD *)(a1 + 60836) = v4;
                break;
              case 0xF4407AC5:
                LODWORD(v10) = lstrcmpW(a4, L"yes");
                LOBYTE(v4) = (_DWORD)v10 == 0;
                *(_DWORD *)(a1 + 60824) = v4;
                break;
            }
          }
        }
        else if ( (_DWORD)v10 == -514024099 )
        {
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60828) = v4;
        }
        else if ( (unsigned int)v10 > 0xD4CB11FB )
        {
          switch ( (_DWORD)v10 )
          {
            case 0xDB9FB3B0:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60792) = v4;
              break;
            case 0xDF22B9D6:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60944) = v4;
              break;
            case 0xDF234196:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 60936) = (_DWORD)v10;
              break;
          }
        }
        else
        {
          switch ( (_DWORD)v10 )
          {
            case 0xD4CB11FB:
              v20 = (char *)(a1 + 5960);
              v21 = 260i64;
              v22 = (char *)((char *)a4 - v20);
              while ( 1 )
              {
                LODWORD(v10) = v21 + 2147483386;
                if ( v21 == -2147483386 )
                  break;
                LODWORD(v10) = *(unsigned __int16 *)&v22[(_QWORD)v20];
                if ( !(_WORD)v10 )
                  break;
                *(_WORD *)v20 = (_WORD)v10;
                v20 += 2;
                if ( !--v21 )
                {
                  *((_WORD *)v20 - 1) = 0;
                  return (int)v10;
                }
              }
              *(_WORD *)v20 = 0;
              break;
            case 0xD230A5A9:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 7000) = (_DWORD)v10;
              *(_DWORD *)(a1 + 7036) = 1;
              break;
            case 0xD37C201F:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 60916) = (_DWORD)v10;
              break;
            case 0xD3DF567F:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60744) = v4;
              break;
          }
        }
      }
      else if ( (_DWORD)v10 == -830982760 )
      {
        LODWORD(v10) = lstrcmpW(a4, L"yes");
        LOBYTE(v4) = (_DWORD)v10 == 0;
        *(_DWORD *)(a1 + 60852) = v4;
      }
      else if ( (unsigned int)v10 > 0x9D29B993 )
      {
        if ( (unsigned int)v10 > 0xC4DDB601 )
        {
          switch ( (_DWORD)v10 )
          {
            case 0xC8A89AC0:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 60932) = (_DWORD)v10;
              break;
            case 0xCAE71A7B:
              *(_DWORD *)(a1 + 7100) = *sub_14007C1F0(&v31, a2);
              v10 = (_QWORD **)sub_14007C1F0(&v29, a2);
              *(_DWORD *)(a1 + 7100) = *(_DWORD *)v10;
              break;
            case 0xCCD46DF9:
              v15 = (__int64 *)(a1 + 62072);
              v27 = 0i64;
              v28 = 0i64;
              sub_14000ABE0(a1 + 62072);
              (*(void (__fastcall **)(__int64 *, __int64 *))(*a2 + 136))(a2, &v28);
              LODWORD(v10) = (*(__int64 (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v28 + 88i64))(v28, &v26);
              v16 = 1;
              if ( (int)v26 > 1 )
              {
                v17 = v24;
                do
                {
                  (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v28 + 80i64))(
                    v28,
                    (unsigned int)v16,
                    &v27);
                  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v27 + 56i64))(v27, v32);
                  (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v27 + 208i64))(v27, &lpString1);
                  if ( lstrcmpiW(lpString1, L"Separator") )
                  {
                    if ( lstrcmpiW(lpString1, L"Back") )
                    {
                      if ( lstrcmpiW(lpString1, L"Forward") )
                      {
                        if ( lstrcmpiW(lpString1, L"Up") )
                        {
                          if ( lstrcmpiW(lpString1, L"Folders") )
                          {
                            if ( lstrcmpiW(lpString1, L"Copy To") )
                            {
                              if ( lstrcmpiW(lpString1, L"Move To") )
                              {
                                if ( lstrcmpiW(lpString1, L"New Folder") )
                                {
                                  if ( lstrcmpiW(lpString1, L"Copy") )
                                  {
                                    if ( lstrcmpiW(lpString1, L"Cut") )
                                    {
                                      if ( lstrcmpiW(lpString1, L"Paste") )
                                      {
                                        if ( lstrcmpiW(lpString1, L"Delete") )
                                        {
                                          if ( lstrcmpiW(lpString1, L"Delete Permanently") )
                                          {
                                            if ( lstrcmpiW(lpString1, L"Views") )
                                            {
                                              if ( lstrcmpiW(lpString1, L"Search") )
                                              {
                                                if ( lstrcmpiW(lpString1, L"Properties") )
                                                {
                                                  if ( lstrcmpiW(lpString1, L"Refresh") )
                                                  {
                                                    if ( lstrcmpiW(lpString1, L"Bookmark the current tab") )
                                                    {
                                                      if ( lstrcmpiW(lpString1, L"Organize Bookmarks") )
                                                      {
                                                        if ( lstrcmpiW(lpString1, L"Create a new tab") )
                                                        {
                                                          if ( !lstrcmpiW(lpString1, L"Show Command Prompt") )
                                                            v17 = 45020;
                                                        }
                                                        else
                                                        {
                                                          v17 = 45019;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v17 = 45021;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v17 = 45018;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v17 = 45017;
                                                  }
                                                }
                                                else
                                                {
                                                  v17 = 45015;
                                                }
                                              }
                                              else
                                              {
                                                v17 = 45014;
                                              }
                                            }
                                            else
                                            {
                                              v17 = 45013;
                                            }
                                          }
                                          else
                                          {
                                            v17 = 45022;
                                          }
                                        }
                                        else
                                        {
                                          v17 = 45012;
                                        }
                                      }
                                      else
                                      {
                                        v17 = 45011;
                                      }
                                    }
                                    else
                                    {
                                      v17 = 45010;
                                    }
                                  }
                                  else
                                  {
                                    v17 = 45009;
                                  }
                                }
                                else
                                {
                                  v17 = 45008;
                                }
                              }
                              else
                              {
                                v17 = 45007;
                              }
                            }
                            else
                            {
                              v17 = 45006;
                            }
                          }
                          else
                          {
                            v17 = 45005;
                          }
                        }
                        else
                        {
                          v17 = 45004;
                        }
                      }
                      else
                      {
                        v17 = 45003;
                      }
                    }
                    else
                    {
                      v17 = 45002;
                    }
                  }
                  else
                  {
                    v17 = 45001;
                  }
                  v18 = *v15;
                  v24 = v17;
                  v10 = (_QWORD **)sub_1400246F0(v18, *(_QWORD *)(v18 + 8), &v24);
                  v19 = v15[1];
                  if ( v19 == 0x3FFFFFFFFFFFFFFEi64 )
                    sub_14002B5F8("list<T> too long");
                  ++v16;
                  v15[1] = v19 + 1;
                  *(_QWORD *)(v18 + 8) = v10;
                  *v10[1] = v10;
                }
                while ( v16 < (int)v26 );
              }
              break;
          }
        }
        else
        {
          switch ( (_DWORD)v10 )
          {
            case 0xC4DDB601:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60752) = v4;
              break;
            case 0xB3E39EB2:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60928) = v4;
              break;
            case 0xB4350631:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 60848) = (_DWORD)v10;
              break;
            case 0xC4B4DE9A:
              v11 = *a2;
              v28 = 0i64;
              v27 = 0i64;
              v12 = 0;
              (*(void (__fastcall **)(__int64 *, __int64 *))(v11 + 136))(a2, &v27);
              (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v27 + 88i64))(v27, &v24);
              for ( i = 1; i < v24; ++i )
              {
                (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v27 + 80i64))(
                  v27,
                  (unsigned int)i,
                  &v28);
                (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v28 + 56i64))(v28, &lpString1);
                (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v28 + 208i64))(v28, &v26);
                if ( lstrcmpW(lpString1, L"Left") )
                {
                  if ( lstrcmpW(lpString1, L"Top") )
                  {
                    if ( lstrcmpW(lpString1, L"Right") )
                    {
                      if ( lstrcmpW(lpString1, L"Bottom") )
                      {
                        if ( !lstrcmpW(lpString1, L"Maximized") )
                          v12 = lstrcmpW(v26, L"yes") == 0;
                      }
                      else
                      {
                        wndpl.rcNormalPosition.bottom = sub_14004B61C(v26);
                      }
                    }
                    else
                    {
                      wndpl.rcNormalPosition.right = sub_14004B61C(v26);
                    }
                  }
                  else
                  {
                    wndpl.rcNormalPosition.top = sub_14004B61C(v26);
                  }
                }
                else
                {
                  wndpl.rcNormalPosition.left = sub_14004B61C(v26);
                }
              }
              v14 = *(HWND *)(a1 + 104);
              if ( v12 )
                v4 = 3;
              wndpl.length = 44;
              wndpl.showCmd = v4;
              LODWORD(v10) = SetWindowPlacement(v14, &wndpl);
              break;
          }
        }
      }
      else if ( (_DWORD)v10 == -1658209901 )
      {
        LODWORD(v10) = lstrcmpW(a4, L"yes");
        LOBYTE(v4) = (_DWORD)v10 == 0;
        *(_DWORD *)(a1 + 60808) = v4;
      }
      else if ( (unsigned int)v10 > 0x906146F7 )
      {
        switch ( (_DWORD)v10 )
        {
          case 0x9B4EE1AA:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60956) = v4;
            break;
          case 0x9B9BCF2A:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60796) = v4;
            break;
          case 0x9C0E4F7D:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60832) = v4;
            break;
        }
      }
      else
      {
        switch ( (_DWORD)v10 )
        {
          case 0x906146F7:
            LODWORD(v10) = sub_14004B61C(a4);
            *(_DWORD *)(a1 + 60924) = (_DWORD)v10;
            break;
          case 0x783F4F6C:
            LODWORD(v10) = sub_14004B61C(a4);
            *(_DWORD *)(a1 + 7012) = (_DWORD)v10;
            break;
          case 0x82556F0A:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60812) = v4;
            break;
          case 0x834852A5:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60892) = v4;
            break;
          case 0x8A04E311:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60856) = v4;
            break;
        }
      }
    }
    else if ( (_DWORD)v10 == 1987363412 )
    {
      LODWORD(v10) = lstrcmpW(a4, L"yes");
      LOBYTE(v4) = (_DWORD)v10 == 0;
      *(_DWORD *)(a1 + 60912) = v4;
    }
    else if ( (unsigned int)v10 > 0x42F48700 )
    {
      if ( (unsigned int)v10 > 0x65CCF038 )
      {
        if ( (unsigned int)v10 > 0x6E708939 )
        {
          switch ( (_DWORD)v10 )
          {
            case 0x6F3C3233:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60860) = v4;
              break;
            case 0x6F89A708:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60784) = v4;
              break;
            case 0x725F7FCF:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60880) = v4;
              break;
          }
        }
        else
        {
          switch ( (_DWORD)v10 )
          {
            case 0x6E708939:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60760) = v4;
              break;
            case 0x6611BC79:
              LODWORD(v10) = sub_14004B61C(a4);
              *(_DWORD *)(a1 + 7056) = (_DWORD)v10;
              break;
            case 0x6BBD3F3C:
              v10 = (_QWORD **)sub_14007C1F0(&v30, a2);
              *(_DWORD *)(a1 + 7104) = *(_DWORD *)v10;
              break;
            case 0x6D5EAD1B:
              LODWORD(v10) = lstrcmpW(a4, L"yes");
              LOBYTE(v4) = (_DWORD)v10 == 0;
              *(_DWORD *)(a1 + 60840) = v4;
              break;
          }
        }
      }
      else if ( (_DWORD)v10 == 1707929656 )
      {
        LODWORD(v10) = lstrcmpW(a4, L"yes");
        LOBYTE(v4) = (_DWORD)v10 == 0;
        *(_DWORD *)(a1 + 60964) = v4;
      }
      else if ( (unsigned int)v10 > 0x501FDC9D )
      {
        switch ( (_DWORD)v10 )
        {
          case 0x60E0C373:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60872) = v4;
            break;
          case 0x6361D848:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60968) = v4;
            break;
          case 0x6499988C:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60900) = v4;
            break;
        }
      }
      else
      {
        switch ( (_DWORD)v10 )
        {
          case 0x501FDC9D:
            LODWORD(v10) = sub_14004B61C(a4);
            *(_DWORD *)(a1 + 60920) = (_DWORD)v10;
            break;
          case 0x44A77D42:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60884) = v4;
            break;
          case 0x48823982:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60764) = v4;
            break;
          case 0x493ED671:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60904) = v4;
            break;
        }
      }
    }
    else if ( (_DWORD)v10 == 1123321600 )
    {
      LODWORD(v10) = lstrcmpW(a4, L"yes");
      LOBYTE(v4) = (_DWORD)v10 == 0;
      *(_DWORD *)(a1 + 60788) = v4;
    }
    else if ( (unsigned int)v10 > 0x21457403 )
    {
      if ( (unsigned int)v10 > 0x3FF6377B )
      {
        switch ( (_DWORD)v10 )
        {
          case 0x40072DF7:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60864) = v4;
            break;
          case 0x421FAC2B:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60868) = v4;
            break;
          case 0x42A60BBE:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60844) = v4;
            break;
        }
      }
      else
      {
        switch ( (_DWORD)v10 )
        {
          case 0x3FF6377B:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60972) = v4;
            break;
          case 0x2C4BCE0A:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60804) = v4;
            break;
          case 0x35970C86:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60768) = v4;
            break;
          case 0x38869915:
            LODWORD(v10) = lstrcmpW(a4, L"yes");
            LOBYTE(v4) = (_DWORD)v10 == 0;
            *(_DWORD *)(a1 + 60748) = v4;
            break;
        }
      }
    }
    else if ( (_DWORD)v10 == 558199811 )
    {
      LODWORD(v10) = lstrcmpW(a4, L"yes");
      LOBYTE(v4) = (_DWORD)v10 == 0;
      *(_DWORD *)(a1 + 60940) = v4;
    }
    else if ( (unsigned int)v10 > 0x14F219F4 )
    {
      switch ( (_DWORD)v10 )
      {
        case 0x159F3E52:
          v10 = (_QWORD **)sub_14007BFA0(a2);
          *(_QWORD *)(a1 + 7112) = v10;
          break;
        case 0x1B385692:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60876) = v4;
          break;
        case 0x1BDF6BD4:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60960) = v4;
          break;
      }
    }
    else
    {
      switch ( (_DWORD)v10 )
      {
        case 0x14F219F4:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60756) = v4;
          break;
        case 0xA63E9F:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60908) = v4;
          break;
        case 0x60DD9ED:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60772) = v4;
          break;
        case 0x8D25F43:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60776) = v4;
          break;
        case 0x907D16F:
          LODWORD(v10) = lstrcmpW(a4, L"yes");
          LOBYTE(v4) = (_DWORD)v10 == 0;
          *(_DWORD *)(a1 + 60952) = v4;
          break;
      }
    }
  }
  return (int)v10;
}
// 140088EA0: conditional instruction was optimized away because rcx.8!=0
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 140088060: using guessed type char var_278[8];

//----- (0000000140089050) ----------------------------------------------------
void __fastcall sub_140089050(__int64 *a1, __int64 *a2, __int64 a3)
{
  OLECHAR *v6; // r13
  __int64 v7; // r11
  __int64 v8; // rdx
  __int16 *v9; // rcx
  __int64 v10; // rcx
  __int16 *v11; // rax
  __int64 v12; // rdx
  char *v13; // r9
  __int16 v14; // r8
  BSTR v15; // rax
  __int64 v16; // r9
  OLECHAR *v17; // rbx
  OLECHAR *v18; // rax
  const OLECHAR *v19; // r9
  __int64 v20; // rdi
  OLECHAR *v21; // rbx
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rdi
  OLECHAR *v25; // rbx
  BSTR v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rdi
  OLECHAR *v30; // rbx
  BSTR v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rdi
  OLECHAR *v35; // rbx
  BSTR v36; // rax
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 *v39; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v40; // [rsp+38h] [rbp-C8h] BYREF
  VARIANTARG pvarg; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v42; // [rsp+60h] [rbp-A0h] BYREF
  VARIANTARG v43; // [rsp+68h] [rbp-98h] BYREF
  __int16 psz[128]; // [rsp+80h] [rbp-80h] BYREF

  v42 = 0i64;
  v6 = SysAllocString(L"\n\t\t");
  sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
  v7 = 2i64;
  do
  {
    v8 = 128i64;
    v9 = psz;
    while ( *v9 )
    {
      ++v9;
      if ( !--v8 )
        goto LABEL_12;
    }
    v10 = v8;
    v11 = &psz[128 - v8];
    v12 = 0x7FFFFFFFi64;
    v13 = (char *)((char *)L"\t" - (char *)v11);
    while ( v12 )
    {
      v14 = *(__int16 *)((char *)v11 + (_QWORD)v13);
      if ( !v14 )
        break;
      *v11++ = v14;
      --v12;
      if ( !--v10 )
      {
        --v11;
        break;
      }
    }
    *v11 = 0;
LABEL_12:
    --v7;
  }
  while ( v7 );
  v15 = SysAllocString((const OLECHAR *)psz);
  v16 = *a1;
  v17 = v15;
  v39 = 0i64;
  v40 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v16 + 392))(a1, v15, &v39);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*a2 + 168))(a2, v39, &v40);
  if ( v39 )
    (*(void (__fastcall **)(__int64 *))(*v39 + 16))(v39);
  v39 = 0i64;
  if ( v40 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
  SysFreeString(v17);
  if ( *(_QWORD *)(a3 + 24) < 8ui64 )
    v18 = (OLECHAR *)a3;
  else
    v18 = *(OLECHAR **)a3;
  sub_14007BD50(a1, &v42, a2, L"ColorRule", v18);
  v19 = (const OLECHAR *)(a3 + 40);
  if ( *(_QWORD *)(a3 + 64) >= 8ui64 )
    v19 = *(const OLECHAR **)v19;
  sub_14007BEA0(a1, v42, L"FilenamePattern", v19);
  itow_s(*(_DWORD *)(a3 + 80), Buffer, 0x40ui64, 10);
  v20 = v42;
  v39 = 0i64;
  v40 = 0i64;
  v21 = SysAllocString(L"Attributes");
  VariantInit(&pvarg);
  v43.llVal = (LONGLONG)SysAllocString(Buffer);
  pvarg.vt = 8;
  v43.pRecInfo = pvarg.pRecInfo;
  v22 = *a1;
  *(_QWORD *)&v43.vt = *(_QWORD *)&pvarg.vt;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v22 + 424))(a1, v21, &v39);
  v23 = *v39;
  pvarg = v43;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v23 + 360))(v39, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v20 + 384i64))(v20, v39, &v40);
  SysFreeString(v21);
  if ( v40 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
    v40 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v39 + 16))(v39);
  v39 = 0i64;
  VariantClear(&v43);
  itow_s(*(unsigned __int8 *)(a3 + 84), Buffer, 0x40ui64, 10);
  v24 = v42;
  v39 = 0i64;
  v40 = 0i64;
  v25 = SysAllocString(L"r");
  VariantInit(&pvarg);
  v26 = SysAllocString(Buffer);
  pvarg.vt = 8;
  *(_QWORD *)&v43.vt = *(_QWORD *)&pvarg.vt;
  v43.llVal = (LONGLONG)v26;
  v27 = *a1;
  v43.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v27 + 424))(a1, v25, &v39);
  v28 = *v39;
  pvarg = v43;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v28 + 360))(v39, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v24 + 384i64))(v24, v39, &v40);
  SysFreeString(v25);
  if ( v40 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
    v40 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v39 + 16))(v39);
  v39 = 0i64;
  VariantClear(&v43);
  itow_s(*(unsigned __int8 *)(a3 + 85), Buffer, 0x40ui64, 10);
  v29 = v42;
  v39 = 0i64;
  v40 = 0i64;
  v30 = SysAllocString(L"g");
  VariantInit(&pvarg);
  v31 = SysAllocString(Buffer);
  pvarg.vt = 8;
  *(_QWORD *)&v43.vt = *(_QWORD *)&pvarg.vt;
  v43.llVal = (LONGLONG)v31;
  v32 = *a1;
  v43.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v32 + 424))(a1, v30, &v39);
  v33 = *v39;
  pvarg = v43;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v33 + 360))(v39, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v29 + 384i64))(v29, v39, &v40);
  SysFreeString(v30);
  if ( v40 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
    v40 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v39 + 16))(v39);
  v39 = 0i64;
  VariantClear(&v43);
  itow_s(*(unsigned __int8 *)(a3 + 86), Buffer, 0x40ui64, 10);
  v34 = v42;
  v39 = 0i64;
  v40 = 0i64;
  v35 = SysAllocString(L"b");
  VariantInit(&pvarg);
  v36 = SysAllocString(Buffer);
  pvarg.vt = 8;
  *(_QWORD *)&v43.vt = *(_QWORD *)&pvarg.vt;
  v43.llVal = (LONGLONG)v36;
  v37 = *a1;
  v43.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v37 + 424))(a1, v35, &v39);
  v38 = *v39;
  pvarg = v43;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v38 + 360))(v39, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v34 + 384i64))(v34, v39, &v40);
  SysFreeString(v35);
  if ( v40 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
    v40 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v39 + 16))(v39);
  v39 = 0i64;
  VariantClear(&v43);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v42 + 16i64))(v42);
  v42 = 0i64;
  SysFreeString(v6);
}
// 1400890E4: conditional instruction was optimized away because rdx.8!=0
// 1400890FC: conditional instruction was optimized away because rdx.8!=0
// 140089135: conditional instruction was optimized away because rcx.8!=0
// 1400EB73C: using guessed type wchar_t asc_1400EB73C[2];
// 1400EB75C: using guessed type wchar_t asc_1400EB75C[2];
// 1400EDF98: using guessed type wchar_t aColorrule[10];
// 1400EDFB0: using guessed type wchar_t aFilenamepatter[16];
// 14012E660: using guessed type OLECHAR Buffer[64];
// 140089050: using guessed type OLECHAR psz[128];

//----- (0000000140089650) ----------------------------------------------------
void __fastcall sub_140089650(__int64 a1, __int64 *a2, __int64 *a3, OLECHAR *a4)
{
  OLECHAR *v6; // rbp
  __int64 v7; // r11
  __int64 v8; // rdx
  __int16 *v9; // rcx
  __int64 v10; // rcx
  __int16 *v11; // rax
  __int64 v12; // rdx
  char *v13; // r9
  __int16 v14; // r8
  BSTR v15; // rax
  __int64 v16; // r9
  OLECHAR *v17; // rbx
  OLECHAR *v18; // rbx
  const OLECHAR *v19; // r9
  OLECHAR *v20; // r9
  __int64 v21; // [rsp+30h] [rbp-168h] BYREF
  __int64 v22; // [rsp+38h] [rbp-160h] BYREF
  __int64 v23; // [rsp+40h] [rbp-158h] BYREF
  __int64 v24; // [rsp+48h] [rbp-150h]
  OLECHAR *v25; // [rsp+50h] [rbp-148h]
  __int16 psz[128]; // [rsp+60h] [rbp-138h] BYREF

  v24 = a1;
  v25 = a4;
  v21 = 0i64;
  v6 = SysAllocString(L"\n\t\t");
  sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
  v7 = 2i64;
  do
  {
    v8 = 128i64;
    v9 = psz;
    while ( *v9 )
    {
      ++v9;
      if ( !--v8 )
        goto LABEL_12;
    }
    v10 = v8;
    v11 = &psz[128 - v8];
    v12 = 0x7FFFFFFFi64;
    v13 = (char *)((char *)L"\t" - (char *)v11);
    while ( v12 )
    {
      v14 = *(__int16 *)((char *)v11 + (_QWORD)v13);
      if ( !v14 )
        break;
      *v11++ = v14;
      --v12;
      if ( !--v10 )
      {
        --v11;
        break;
      }
    }
    *v11 = 0;
LABEL_12:
    --v7;
  }
  while ( v7 );
  v15 = SysAllocString((const OLECHAR *)psz);
  v16 = *a2;
  v17 = v15;
  v22 = 0i64;
  v23 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 *))(v16 + 392))(a2, v15, &v22);
  (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(*a3 + 168))(a3, v22, &v23);
  if ( v22 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 16i64))(v22);
  v22 = 0i64;
  if ( v23 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 16i64))(v23);
  SysFreeString(v17);
  v18 = v25;
  sub_14007BD50(a2, &v21, a3, L"ApplicationButton", v25);
  sub_14007BEA0(a2, v21, L"Command", v18 + 512);
  v19 = aYes_0;
  if ( !*((_DWORD *)v18 + 512) )
    v19 = aNo;
  sub_14007BEA0(a2, v21, L"ShowNameOnToolbar", v19);
  v20 = (OLECHAR *)*((_QWORD *)v18 + 257);
  if ( v20 )
    sub_140089650(v24, a2, a3, v20);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v21 + 16i64))(v21);
  v21 = 0i64;
  SysFreeString(v6);
}
// 1400896D3: conditional instruction was optimized away because rdx.8!=0
// 1400896EB: conditional instruction was optimized away because rdx.8!=0
// 140089725: conditional instruction was optimized away because rcx.8!=0
// 1400EB5D4: using guessed type wchar_t asc_1400EB5D4[2];
// 1400EB5FC: using guessed type wchar_t asc_1400EB5FC[2];
// 1400EDEB0: using guessed type wchar_t aApplicationbut[18];
// 1400EDED8: using guessed type wchar_t aCommand[8];
// 1400EDEE8: using guessed type wchar_t aShownameontool[18];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 140089650: using guessed type OLECHAR psz[128];

//----- (0000000140089880) ----------------------------------------------------
void __fastcall sub_140089880(__int64 a1, __int64 *a2, __int64 *a3)
{
  OLECHAR *v6; // rdi
  OLECHAR *v7; // rbx
  OLECHAR *v8; // r9
  __int64 v9; // rax
  __int64 *v10; // [rsp+40h] [rbp+8h] BYREF
  __int64 v11; // [rsp+48h] [rbp+10h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v7 = SysAllocString(L"ApplicationToolbar");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  v8 = *(OLECHAR **)(a1 + 62104);
  if ( v8 )
    sub_140089650(a1, a2, v10, v8);
  sub_14007B920(a2, (__int64)v6, (__int64)v10);
  v9 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v9 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  (*(void (__fastcall **)(__int64 *))(*v10 + 16))(v10);
  v10 = 0i64;
  SysFreeString(v6);
}

//----- (0000000140089990) ----------------------------------------------------
__int64 __fastcall sub_140089990(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rax
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  __int64 result; // rax
  __int64 v7; // rdx
  signed __int64 v8; // r8
  char *v9; // rcx
  __int16 v10; // ax
  __int64 v11; // rdx
  signed __int64 v12; // r8
  char *v13; // rcx
  __int16 v14; // ax
  void *v15; // rax
  __int64 v16; // rbx
  int v17; // [rsp+30h] [rbp-D0h]
  int v19; // [rsp+40h] [rbp-C0h] BYREF
  _QWORD *v20; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v21; // [rsp+50h] [rbp-B0h] BYREF
  LPCWSTR v22; // [rsp+58h] [rbp-A8h] BYREF
  LPCWSTR lpString1; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v24; // [rsp+68h] [rbp-98h] BYREF
  _QWORD *v25; // [rsp+70h] [rbp-90h]
  char v26[1024]; // [rsp+80h] [rbp-80h] BYREF
  char v27[1024]; // [rsp+480h] [rbp+380h] BYREF

  v2 = *a2;
  v3 = 0;
  v25 = a2;
  v24 = 0i64;
  v21 = 0i64;
  v20 = 0i64;
  v4 = 0;
  v5 = 0;
  v17 = 1;
  result = (*(__int64 (__fastcall **)(_QWORD *, __int64 *))(v2 + 136))(a2, &v24);
  if ( (int)result >= 0 )
  {
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v24 + 88i64))(v24, &v19);
    if ( v19 <= 0 )
      goto LABEL_24;
    do
    {
      (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v24 + 80i64))(v24, (unsigned int)v3, &v21);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v21 + 56i64))(v21, &lpString1);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v21 + 208i64))(v21, &v22);
      if ( lstrcmpiW(lpString1, L"Name") )
      {
        if ( lstrcmpiW(lpString1, L"Command") )
        {
          if ( !lstrcmpiW(lpString1, L"ShowNameOnToolbar") )
            v17 = lstrcmpW(v22, L"yes") == 0;
        }
        else
        {
          v11 = 512i64;
          v12 = (char *)v22 - v26;
          v13 = v26;
          while ( v11 != -2147483134 )
          {
            v14 = *(_WORD *)&v13[v12];
            if ( !v14 )
              break;
            *(_WORD *)v13 = v14;
            v13 += 2;
            if ( !--v11 )
            {
              v5 = 1;
              *((_WORD *)v13 - 1) = 0;
              goto LABEL_19;
            }
          }
          *(_WORD *)v13 = 0;
          v5 = 1;
        }
      }
      else
      {
        v7 = 512i64;
        v8 = (char *)v22 - v27;
        v9 = v27;
        while ( v7 != -2147483134 )
        {
          v10 = *(_WORD *)&v9[v8];
          if ( !v10 )
            break;
          *(_WORD *)v9 = v10;
          v9 += 2;
          if ( !--v7 )
          {
            v4 = 1;
            *((_WORD *)v9 - 1) = 0;
            goto LABEL_19;
          }
        }
        *(_WORD *)v9 = 0;
        v4 = 1;
      }
LABEL_19:
      ++v3;
    }
    while ( v3 < v19 );
    if ( v4 && v5 )
    {
      v15 = malloc(0x820ui64);
      v16 = a1;
      if ( v15 )
        sub_1400CD750(a1, (__int64)v27, (__int64)v26, v17, (__int64)v15);
    }
    else
    {
LABEL_24:
      v16 = a1;
    }
    result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD **))(*v25 + 128i64))(v25, &v20);
    if ( !(_DWORD)result )
    {
      result = (*(__int64 (__fastcall **)(_QWORD *, _QWORD **))(*v20 + 128i64))(v20, &v20);
      if ( !(_DWORD)result )
        return sub_140089990(v16, v20);
    }
  }
  return result;
}
// 140089AC6: conditional instruction was optimized away because rdx.8!=0
// 140089B37: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140089C30) ----------------------------------------------------
void __fastcall sub_140089C30(__int64 a1, __int64 a2)
{
  OLECHAR *v4; // rbx
  _QWORD *v5; // [rsp+38h] [rbp+10h] BYREF

  if ( a2 )
  {
    v5 = 0i64;
    v4 = SysAllocString(L"//ApplicationButton");
    if ( !(*(unsigned int (__fastcall **)(__int64, OLECHAR *, _QWORD **))(*(_QWORD *)a2 + 296i64))(a2, v4, &v5) )
      sub_140089990(a1, v5);
    if ( v4 )
      SysFreeString(v4);
    if ( v5 )
      (*(void (__fastcall **)(_QWORD *))(*v5 + 16i64))(v5);
  }
}

//----- (0000000140089CD0) ----------------------------------------------------
void __fastcall sub_140089CD0(__int64 *a1, __int64 *a2, __int64 ***a3, OLECHAR *a4, int a5)
{
  const OLECHAR *v9; // r12
  __int64 v10; // r10
  __int64 v11; // rcx
  __int16 *v12; // rax
  __int16 *v13; // rax
  __int64 v14; // rdx
  char *v15; // r9
  __int16 v16; // r8
  BSTR v17; // rax
  __int64 v18; // r9
  OLECHAR *v19; // r13
  __int64 *v20; // rbx
  unsigned int v21; // eax
  _DWORD *v22; // rcx
  const OLECHAR *v23; // r9
  __int64 v24; // rsi
  OLECHAR *v25; // rdi
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 *v28; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v29; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v30; // [rsp+40h] [rbp-C0h] BYREF
  VARIANTARG v31; // [rsp+48h] [rbp-B8h] BYREF
  OLECHAR *v32; // [rsp+60h] [rbp-A0h]
  VARIANTARG pvarg; // [rsp+68h] [rbp-98h] BYREF
  VARIANTARG v34; // [rsp+80h] [rbp-80h] BYREF
  OLECHAR v35[32]; // [rsp+A0h] [rbp-60h] BYREF
  __int16 psz[128]; // [rsp+E0h] [rbp-20h] BYREF

  v30 = 0i64;
  v9 = 0i64;
  SysAllocString(L"\n\t\t\t\t");
  sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
  if ( a5 > 0 )
  {
    v10 = (unsigned int)a5;
    do
    {
      v11 = 128i64;
      v12 = psz;
      while ( *v12 )
      {
        ++v12;
        if ( !--v11 )
          goto LABEL_13;
      }
      v13 = &psz[128 - v11];
      v14 = 0x7FFFFFFFi64;
      v15 = (char *)((char *)L"\t" - (char *)v13);
      while ( v14 )
      {
        v16 = *(__int16 *)((char *)v13 + (_QWORD)v15);
        if ( !v16 )
          break;
        *v13++ = v16;
        --v14;
        if ( !--v11 )
        {
          --v13;
          break;
        }
      }
      *v13 = 0;
LABEL_13:
      --v10;
    }
    while ( v10 );
  }
  v17 = SysAllocString((const OLECHAR *)psz);
  v18 = *a1;
  v19 = v17;
  v32 = v17;
  v28 = 0i64;
  v29 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v18 + 392))(a1, v17, &v28);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*a2 + 168))(a2, v28, &v29);
  if ( v28 )
    (*(void (__fastcall **)(__int64 *))(*v28 + 16))(v28);
  v28 = 0i64;
  if ( v29 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 16i64))(v29);
  sub_14007BD50(a1, &v30, a2, L"Column", a4);
  v20 = **a3;
  if ( v20 != (__int64 *)*a3 )
  {
    do
    {
      v21 = 0;
      v22 = &unk_14011DC40;
      while ( *v22 != *((_DWORD *)v20 + 4) )
      {
        ++v21;
        v22 += 33;
        if ( v21 >= 0x22 )
          goto LABEL_24;
      }
      v9 = &aName_2[66 * v21];
LABEL_24:
      v23 = aYes_0;
      if ( !*((_DWORD *)v20 + 5) )
        v23 = aNo;
      sub_14007BEA0(a1, v30, v9, v23);
      sub_140001000(v35, 0x20ui64, L"%s_Width", v9);
      itow_s(*((_DWORD *)v20 + 6), Buffer, 0x40ui64, 10);
      v24 = v30;
      v28 = 0i64;
      v29 = 0i64;
      v25 = SysAllocString(v35);
      VariantInit(&pvarg);
      v31.llVal = (LONGLONG)SysAllocString(Buffer);
      pvarg.vt = 8;
      v31.pRecInfo = pvarg.pRecInfo;
      v26 = *a1;
      *(_QWORD *)&v31.vt = *(_QWORD *)&pvarg.vt;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v26 + 424))(a1, v25, &v28);
      v27 = *v28;
      v34 = v31;
      (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v27 + 360))(v28, &v34);
      (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v24 + 384i64))(v24, v28, &v29);
      SysFreeString(v25);
      if ( v29 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v29 + 16i64))(v29);
        v29 = 0i64;
      }
      (*(void (__fastcall **)(__int64 *))(*v28 + 16))(v28);
      v28 = 0i64;
      VariantClear(&v31);
      v20 = (__int64 *)*v20;
    }
    while ( v20 != (__int64 *)*a3 );
    v19 = v32;
  }
  SysFreeString(v19);
}
// 140089D73: conditional instruction was optimized away because rcx.8!=0
// 140089D8A: conditional instruction was optimized away because rcx.8!=0
// 140089DC5: conditional instruction was optimized away because rcx.8!=0
// 1400EB554: using guessed type wchar_t asc_1400EB554[2];
// 1400EB584: using guessed type wchar_t asc_1400EB584[2];
// 1400EDC40: using guessed type wchar_t aColumn[7];
// 1400EDC50: using guessed type wchar_t aSWidth[9];
// 14011DBC0: using guessed type wchar_t aName_2[5];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 14012E660: using guessed type OLECHAR Buffer[64];
// 140089CD0: using guessed type OLECHAR psz[128];

//----- (000000014008A040) ----------------------------------------------------
void __fastcall sub_14008A040(__int64 ***a1, __int64 *a2, __int64 *a3)
{
  sub_140089CD0(a2, a3, a1 + 7779, L"Generic", 2);
  sub_140089CD0(a2, a3, a1 + 7782, L"MyComputer", 2);
  sub_140089CD0(a2, a3, a1 + 7785, L"ControlPanel", 2);
  sub_140089CD0(a2, a3, a1 + 7788, L"RecycleBin", 2);
  sub_140089CD0(a2, a3, a1 + 7791, L"Printers", 2);
  sub_140089CD0(a2, a3, a1 + 7794, L"Network", 2);
  sub_140089CD0(a2, a3, a1 + 7797, L"NetworkPlaces", 2);
}
// 1400EDB88: using guessed type wchar_t aGeneric[8];
// 1400EDB98: using guessed type wchar_t aMycomputer[11];
// 1400EDBB0: using guessed type wchar_t aControlpanel[13];
// 1400EDBD0: using guessed type wchar_t aRecyclebin[11];
// 1400EDBE8: using guessed type wchar_t aPrinters[9];
// 1400EDC00: using guessed type wchar_t aNetwork[8];
// 1400EDC10: using guessed type wchar_t aNetworkplaces[14];

//----- (000000014008A160) ----------------------------------------------------
__int64 __fastcall sub_14008A160(__int64 ***a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rsi
  OLECHAR *v7; // rbx
  __int64 v8; // rax
  __int64 *v10; // [rsp+48h] [rbp+10h] BYREF
  __int64 v11; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  v7 = SysAllocString(L"DefaultColumns");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  sub_14008A040(a1, a2, v10);
  sub_14007B920(a2, (__int64)v6, (__int64)v10);
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v8 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v8 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  return (*(__int64 (__fastcall **)(__int64 *))(*v10 + 16))(v10);
}

//----- (000000014008A250) ----------------------------------------------------
void __fastcall sub_14008A250(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  __int64 v6; // r10
  __int64 v7; // rcx
  __int16 *v8; // rax
  __int16 *v9; // rax
  __int64 v10; // rdx
  char *v11; // r9
  __int16 v12; // r8
  BSTR v13; // rax
  __int64 v14; // r9
  OLECHAR *v15; // rbx
  __int64 v16; // rdi
  OLECHAR *v17; // rbx
  BSTR v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rbx
  const OLECHAR *v22; // r9
  __int64 v23; // rax
  __int64 v24; // rcx
  __int64 v25; // r10
  __int64 v26; // rcx
  __int16 *v27; // rax
  __int16 *v28; // rax
  __int64 v29; // rdx
  char *v30; // r9
  __int16 v31; // r8
  BSTR v32; // rax
  __int64 v33; // r9
  __int64 v34; // rbx
  OLECHAR *v35; // rdi
  OLECHAR *v36; // rbx
  __int64 *v37; // rbx
  __int64 v38; // rax
  __int64 v39; // r10
  __int64 v40; // rcx
  __int16 *v41; // rax
  __int16 *v42; // rax
  __int64 v43; // rdx
  char *v44; // r9
  __int16 v45; // r8
  BSTR v46; // rax
  __int64 v47; // r9
  __int64 v48; // rbx
  OLECHAR *v49; // rdi
  __int64 v50; // rcx
  __int64 v51; // [rsp+30h] [rbp-D0h] BYREF
  __int64 *v52; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v53; // [rsp+40h] [rbp-C0h] BYREF
  __int64 *v54; // [rsp+48h] [rbp-B8h] BYREF
  __int64 *v55; // [rsp+50h] [rbp-B0h]
  __int64 v56; // [rsp+58h] [rbp-A8h]
  __int64 v57; // [rsp+60h] [rbp-A0h]
  VARIANTARG pvarg; // [rsp+70h] [rbp-90h] BYREF
  BSTR bstrString; // [rsp+90h] [rbp-70h]
  VARIANTARG v60; // [rsp+98h] [rbp-68h] BYREF
  char v61[2080]; // [rsp+B0h] [rbp-50h] BYREF
  char v62[2080]; // [rsp+8D0h] [rbp+7D0h] BYREF
  __int16 psz[128]; // [rsp+10F0h] [rbp+FF0h] BYREF

  v56 = a1;
  v57 = a4;
  v55 = a3;
  v54 = 0i64;
  bstrString = SysAllocString(L"\n\t\t");
  sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
  if ( dword_14012B984 > 0 )
  {
    v6 = (unsigned int)dword_14012B984;
    do
    {
      v7 = 128i64;
      v8 = psz;
      while ( *v8 )
      {
        ++v8;
        if ( !--v7 )
          goto LABEL_13;
      }
      v9 = &psz[128 - v7];
      v10 = 0x7FFFFFFFi64;
      v11 = (char *)((char *)L"\t" - (char *)v9);
      while ( v10 )
      {
        v12 = *(_WORD *)&v11[(_QWORD)v9];
        if ( !v12 )
          break;
        *v9++ = v12;
        --v10;
        if ( !--v7 )
        {
          --v9;
          break;
        }
      }
      *v9 = 0;
LABEL_13:
      --v6;
    }
    while ( v6 );
  }
  v13 = SysAllocString((const OLECHAR *)psz);
  v14 = *a2;
  v15 = v13;
  v52 = 0i64;
  v51 = 0i64;
  (*(void (__fastcall **)(__int64 *, BSTR, __int64 **))(v14 + 392))(a2, v13, &v52);
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(*v55 + 168))(v55, v52, &v51);
  if ( v52 )
    (*(void (__fastcall **)(__int64 *))(*v52 + 16))(v52);
  v52 = 0i64;
  if ( v51 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v51 + 16i64))(v51);
  SysFreeString(v15);
  sub_14007BD50(a2, &v54, v55, L"Bookmark", (OLECHAR *)a4);
  sub_14007BEA0(a2, (__int64)v54, L"Description", (const OLECHAR *)(a4 + 512));
  itow_s(*(_DWORD *)(a4 + 1540), Buffer, 0x40ui64, 10);
  v16 = (__int64)v54;
  v52 = 0i64;
  v51 = 0i64;
  v17 = SysAllocString(L"Type");
  VariantInit(&pvarg);
  v18 = SysAllocString(Buffer);
  pvarg.vt = 8;
  v60.llVal = (LONGLONG)v18;
  v19 = *a2;
  *(_QWORD *)&v60.vt = *(_QWORD *)&pvarg.vt;
  v60.pRecInfo = pvarg.pRecInfo;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(v19 + 424))(a2, v17, &v52);
  v20 = *v52;
  pvarg = v60;
  (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v20 + 360))(v52, &pvarg);
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v16 + 384i64))(v16, v52, &v51);
  SysFreeString(v17);
  if ( v51 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v51 + 16i64))(v51);
    v51 = 0i64;
  }
  (*(void (__fastcall **)(__int64 *))(*v52 + 16))(v52);
  v52 = 0i64;
  VariantClear(&v60);
  v21 = v57;
  v22 = aYes_0;
  if ( !*(_DWORD *)(v57 + 1536) )
    v22 = aNo;
  sub_14007BEA0(a2, (__int64)v54, L"ShowOnBookmarksToolbar", v22);
  if ( *(_DWORD *)(v21 + 1540) == 1 )
    sub_14007BEA0(a2, (__int64)v54, L"Location", (const OLECHAR *)(v21 + 1544));
  if ( !*(_DWORD *)(v21 + 1540) )
  {
    v23 = *(_QWORD *)(v21 + 2064);
    if ( !*(_DWORD *)(v23 + 1540) )
    {
      v24 = *(_QWORD *)(v23 + 2088);
      if ( v24 )
      {
        sub_14007D720(v24, (__int64)v62);
        ++dword_14012B984;
        v52 = 0i64;
        sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
        if ( dword_14012B984 > 0 )
        {
          v25 = (unsigned int)dword_14012B984;
          do
          {
            v26 = 128i64;
            v27 = psz;
            while ( *v27 )
            {
              ++v27;
              if ( !--v26 )
                goto LABEL_39;
            }
            v28 = &psz[128 - v26];
            v29 = 0x7FFFFFFFi64;
            v30 = (char *)((char *)L"\t" - (char *)v28);
            while ( v29 )
            {
              v31 = *(_WORD *)&v30[(_QWORD)v28];
              if ( !v31 )
                break;
              *v28++ = v31;
              --v29;
              if ( !--v26 )
              {
                --v28;
                break;
              }
            }
            *v28 = 0;
LABEL_39:
            --v25;
          }
          while ( v25 );
        }
        v32 = SysAllocString((const OLECHAR *)psz);
        v33 = *a2;
        v34 = (__int64)v54;
        v35 = v32;
        v51 = 0i64;
        v53 = 0i64;
        (*(void (__fastcall **)(__int64 *, BSTR, __int64 *))(v33 + 392))(a2, v32, &v51);
        (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v34 + 168i64))(v34, v51, &v53);
        if ( v51 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v51 + 16i64))(v51);
        v51 = 0i64;
        if ( v53 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 16i64))(v53);
        v36 = SysAllocString(L"Bookmarks");
        (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v36, &v52);
        SysFreeString(v36);
        ++dword_14012B984;
        sub_14008A250(v56, a2, v52, (__int64)v62);
        --dword_14012B984;
        v37 = v52;
        v51 = 0i64;
        v53 = 0i64;
        (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 392))(a2, v35, &v51);
        (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(*v37 + 168))(v37, v51, &v53);
        if ( v51 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v51 + 16i64))(v51);
        v51 = 0i64;
        if ( v53 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 16i64))(v53);
        SysFreeString(v35);
        v38 = *v54;
        v53 = 0i64;
        (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v38 + 168))(v54, v52, &v53);
        if ( v53 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 16i64))(v53);
        (*(void (__fastcall **)(__int64 *))(*v52 + 16))(v52);
        --dword_14012B984;
        v52 = 0i64;
        sub_140001000((wchar_t *)psz, 0x80ui64, L"\n");
        if ( dword_14012B984 > 0 )
        {
          v39 = (unsigned int)dword_14012B984;
          do
          {
            v40 = 128i64;
            v41 = psz;
            while ( *v41 )
            {
              ++v41;
              if ( !--v40 )
                goto LABEL_62;
            }
            v42 = &psz[128 - v40];
            v43 = 0x7FFFFFFFi64;
            v44 = (char *)((char *)L"\t" - (char *)v42);
            while ( v43 )
            {
              v45 = *(_WORD *)&v44[(_QWORD)v42];
              if ( !v45 )
                break;
              *v42++ = v45;
              --v43;
              if ( !--v40 )
              {
                --v42;
                break;
              }
            }
            *v42 = 0;
LABEL_62:
            --v39;
          }
          while ( v39 );
        }
        v46 = SysAllocString((const OLECHAR *)psz);
        v47 = *a2;
        v48 = (__int64)v54;
        v49 = v46;
        v51 = 0i64;
        v53 = 0i64;
        (*(void (__fastcall **)(__int64 *, BSTR, __int64 *))(v47 + 392))(a2, v46, &v51);
        (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v48 + 168i64))(v48, v51, &v53);
        if ( v51 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v51 + 16i64))(v51);
        v51 = 0i64;
        if ( v53 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v53 + 16i64))(v53);
        SysFreeString(v49);
        v21 = v57;
      }
    }
  }
  v50 = *(_QWORD *)(*(_QWORD *)(v21 + 2064) + 2080i64);
  if ( v50 )
  {
    sub_14007D720(v50, (__int64)v61);
    sub_14008A250(v56, a2, v55, (__int64)v61);
  }
  (*(void (__fastcall **)(__int64 *))(*v54 + 16))(v54);
  v54 = 0i64;
  SysFreeString(bstrString);
}
// 14008A303: conditional instruction was optimized away because rcx.8!=0
// 14008A31D: conditional instruction was optimized away because rcx.8!=0
// 14008A356: conditional instruction was optimized away because rcx.8!=0
// 14008A614: conditional instruction was optimized away because rcx.8!=0
// 14008A62E: conditional instruction was optimized away because rcx.8!=0
// 14008A667: conditional instruction was optimized away because rcx.8!=0
// 14008A843: conditional instruction was optimized away because rcx.8!=0
// 14008A85D: conditional instruction was optimized away because rcx.8!=0
// 14008A896: conditional instruction was optimized away because rcx.8!=0
// 1400EB3F4: using guessed type wchar_t asc_1400EB3F4[2];
// 1400EB4AC: using guessed type wchar_t asc_1400EB4AC[2];
// 1400EB4DC: using guessed type wchar_t asc_1400EB4DC[2];
// 1400EB4F4: using guessed type wchar_t asc_1400EB4F4[2];
// 1400EB50C: using guessed type wchar_t asc_1400EB50C[2];
// 1400EB524: using guessed type wchar_t asc_1400EB524[2];
// 1400EDA98: using guessed type wchar_t aBookmark[9];
// 1400EDAB0: using guessed type wchar_t aDescription[12];
// 1400EDAD8: using guessed type wchar_t aShowonbookmark[23];
// 1400EDB08: using guessed type wchar_t aLocation[9];
// 14012B984: using guessed type int dword_14012B984;
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 14012E660: using guessed type OLECHAR Buffer[64];
// 14008A250: using guessed type OLECHAR psz[128];

//----- (000000014008A9A0) ----------------------------------------------------
void __fastcall sub_14008A9A0(__int64 a1, __int64 *a2, __int64 *a3)
{
  OLECHAR *v6; // rdi
  OLECHAR *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // [rsp+20h] [rbp-1088h] BYREF
  __int64 v11; // [rsp+28h] [rbp-1080h] BYREF
  char v12[2064]; // [rsp+30h] [rbp-1078h] BYREF
  __int64 v13; // [rsp+840h] [rbp-868h]
  char v14[2080]; // [rsp+850h] [rbp-858h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v7 = SysAllocString(L"Bookmarks");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  sub_14007DA80(a1 + 2664, (__int64)v12);
  if ( !*(_DWORD *)(v13 + 1540) )
  {
    v8 = *(_QWORD *)(v13 + 2088);
    if ( v8 )
    {
      sub_14007D720(v8, (__int64)v14);
      sub_14008A250(a1, a2, v10, (__int64)v14);
    }
  }
  sub_14007B920(a2, (__int64)v6, (__int64)v10);
  v9 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *))(v9 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  (*(void (__fastcall **)(__int64 *))(*v10 + 16))(v10);
  v10 = 0i64;
  SysFreeString(v6);
}
// 14008A9A0: using guessed type char var_1078[2064];

//----- (000000014008AB00) ----------------------------------------------------
__int64 __fastcall sub_14008AB00(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // ebx
  __int64 v5; // rsi
  __int64 result; // rax
  __int64 v7; // rdx
  signed __int64 v8; // r8
  __int16 *v9; // rcx
  __int16 v10; // ax
  __int64 v11; // rdx
  signed __int64 v12; // r8
  __int64 *v13; // rcx
  __int16 v14; // ax
  __int64 v15; // rdx
  signed __int64 v16; // r8
  __int64 *v17; // rcx
  __int16 v18; // ax
  _QWORD *v19; // rax
  _QWORD *v20; // rbx
  __int64 v21; // rcx
  _QWORD *j; // rax
  int v23; // eax
  __int64 v24; // rbx
  __int64 v25; // rcx
  _QWORD *i; // rax
  __int64 v27; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v28; // [rsp+28h] [rbp-D8h]
  LPCWSTR v29; // [rsp+30h] [rbp-D0h] BYREF
  int v30; // [rsp+38h] [rbp-C8h] BYREF
  LPCWSTR lpString1; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v32; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v33; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v34; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v35; // [rsp+60h] [rbp-A0h]
  __int16 v36[256]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v37[196]; // [rsp+270h] [rbp+170h] BYREF

  v3 = 0;
  v28 = a1;
  v5 = a2;
  v35 = a2;
  v33 = 0i64;
  v34 = 0i64;
  v27 = 0i64;
  v32 = 0i64;
  memset(v36, 0, sizeof(v36));
  memset(v37, 0, 0x618ui64);
  result = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 136i64))(v5, &v33);
  if ( (int)result < 0 )
    return result;
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v33 + 88i64))(v33, &v30);
  if ( v30 > 0 )
  {
    do
    {
      (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v33 + 80i64))(v33, (unsigned int)v3, &v34);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v34 + 56i64))(v34, &lpString1);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v34 + 208i64))(v34, &v29);
      if ( lstrcmpiW(lpString1, L"Name") )
      {
        if ( lstrcmpiW(lpString1, L"Description") )
        {
          if ( lstrcmpiW(lpString1, L"Location") )
          {
            if ( lstrcmpiW(lpString1, L"Type") )
            {
              if ( !lstrcmpiW(lpString1, L"ShowOnBookmarksToolbar") )
                LODWORD(v37[128]) = lstrcmpW(v29, L"yes") == 0;
            }
            else
            {
              HIDWORD(v37[128]) = sub_14004B61C(v29);
            }
          }
          else
          {
            v15 = 260i64;
            v16 = (char *)v29 - (char *)&v37[129];
            v17 = &v37[129];
            while ( v15 != -2147483386 )
            {
              v18 = *(_WORD *)((char *)v17 + v16);
              if ( !v18 )
                break;
              *(_WORD *)v17 = v18;
              v17 = (__int64 *)((char *)v17 + 2);
              if ( !--v15 )
              {
                *((_WORD *)v17 - 1) = 0;
                goto LABEL_28;
              }
            }
            *(_WORD *)v17 = 0;
          }
        }
        else
        {
          v11 = 512i64;
          v12 = (char *)v29 - (char *)v37;
          v13 = v37;
          while ( v11 != -2147483134 )
          {
            v14 = *(_WORD *)((char *)v13 + v12);
            if ( !v14 )
              break;
            *(_WORD *)v13 = v14;
            v13 = (__int64 *)((char *)v13 + 2);
            if ( !--v11 )
            {
              *((_WORD *)v13 - 1) = 0;
              goto LABEL_28;
            }
          }
          *(_WORD *)v13 = 0;
        }
      }
      else
      {
        v7 = 256i64;
        v8 = (char *)v29 - (char *)v36;
        v9 = v36;
        while ( v7 != -2147483390 )
        {
          v10 = *(__int16 *)((char *)v9 + v8);
          if ( !v10 )
            break;
          *v9++ = v10;
          if ( !--v7 )
          {
            *(v9 - 1) = 0;
            goto LABEL_28;
          }
        }
        *v9 = 0;
      }
LABEL_28:
      ++v3;
    }
    while ( v3 < v30 );
    v5 = v35;
  }
  v19 = malloc(0x830ui64);
  v20 = v19;
  if ( HIDWORD(v37[128]) )
  {
    sub_14007D850((__int64)v19, (__int64)v36);
    v20[258] = a3;
    v25 = *(_QWORD *)(a3 + 2088);
    if ( v25 )
    {
      for ( i = (_QWORD *)(v25 + 2080); *i; i = (_QWORD *)(*i + 2080i64) )
        v25 = *i;
      *(_QWORD *)(v25 + 2080) = v20;
      v20[259] = v25;
    }
    else
    {
      *(_QWORD *)(a3 + 2088) = v20;
      v20[259] = 0i64;
    }
  }
  else
  {
    sub_14007D850((__int64)v19, (__int64)v36);
    v20[258] = a3;
    v21 = *(_QWORD *)(a3 + 2088);
    if ( v21 )
    {
      for ( j = (_QWORD *)(v21 + 2080); *j; j = (_QWORD *)(*j + 2080i64) )
        v21 = *j;
      *(_QWORD *)(v21 + 2080) = v20;
      v20[259] = v21;
    }
    else
    {
      *(_QWORD *)(a3 + 2088) = v20;
      v20[259] = 0i64;
    }
    if ( !(*(unsigned int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 104i64))(v5, &v27)
      && !(*(unsigned int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v27 + 128i64))(v27, &v27)
      && !(*(unsigned int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v27 + 104i64))(v27, &v27) )
    {
      v23 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v27 + 128i64))(v27, &v27);
      v24 = v28;
      if ( !v23 )
        sub_14008AB00(v28, v27, v37[194]);
      goto LABEL_47;
    }
  }
  v24 = v28;
LABEL_47:
  result = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v5 + 128i64))(v5, &v32);
  if ( !(_DWORD)result )
  {
    result = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v32 + 128i64))(v32, &v32);
    if ( !(_DWORD)result )
      return sub_14008AB00(v24, v32, a3);
  }
  return result;
}
// 14008AC43: conditional instruction was optimized away because rdx.8!=0
// 14008ACB3: conditional instruction was optimized away because rdx.8!=0
// 14008AD20: conditional instruction was optimized away because rdx.8!=0
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (000000014008AF60) ----------------------------------------------------
__int64 __fastcall sub_14008AF60(__int64 a1, __int64 a2)
{
  OLECHAR *v4; // rbx
  __int64 v6; // [rsp+20h] [rbp-848h] BYREF
  char v7[2064]; // [rsp+30h] [rbp-838h] BYREF
  __int64 v8; // [rsp+840h] [rbp-28h]

  v6 = 0i64;
  if ( a2 )
  {
    v4 = SysAllocString(L"//Bookmark");
    if ( !(*(unsigned int (__fastcall **)(__int64, OLECHAR *, __int64 *))(*(_QWORD *)a2 + 296i64))(a2, v4, &v6) )
    {
      sub_14007DA80(a1 + 2664, (__int64)v7);
      sub_14008AB00(a1, v6, v8);
    }
    if ( v4 )
      SysFreeString(v4);
    if ( v6 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16i64))(v6);
  }
  return 0i64;
}
// 14008AF60: using guessed type char var_838[2064];

//----- (000000014008B040) ----------------------------------------------------
void __fastcall sub_14008B040(__int64 a1, __int64 *a2, __int64 a3)
{
  OLECHAR *v6; // r15
  int i; // er13
  OLECHAR *v8; // rbx
  OLECHAR *v9; // rbx
  BSTR v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rdi
  OLECHAR *v13; // rbx
  BSTR v14; // rax
  __int64 v15; // rcx
  int v16; // eax
  const OLECHAR *v17; // r9
  __int64 v18; // rcx
  int v19; // eax
  const OLECHAR *v20; // r9
  __int64 v21; // rcx
  __int64 v22; // rdi
  OLECHAR *v23; // rbx
  BSTR v24; // rax
  __int64 v25; // rcx
  int v26; // eax
  const OLECHAR *v27; // r9
  __int64 v28; // rcx
  int v29; // eax
  const OLECHAR *v30; // r9
  __int64 v31; // rcx
  int v32; // eax
  const OLECHAR *v33; // r9
  __int64 v34; // rcx
  int v35; // eax
  const OLECHAR *v36; // r9
  __int64 v37; // rcx
  int v38; // eax
  const OLECHAR *v39; // r9
  __int64 v40; // rcx
  __int64 v41; // rdi
  OLECHAR *v42; // rbx
  BSTR v43; // rax
  __int64 v44; // rcx
  __int64 v45; // rdi
  OLECHAR *v46; // rbx
  BSTR v47; // rax
  OLECHAR *v48; // rbx
  _QWORD *v49; // rax
  __int64 **v50; // rax
  __int64 **v51; // rax
  __int64 **v52; // rax
  __int64 **v53; // rax
  __int64 **v54; // rax
  __int64 **v55; // rax
  __int64 v56; // rcx
  __int64 *v57; // rbx
  const OLECHAR *v58; // r9
  const OLECHAR *v59; // r9
  const OLECHAR *v60; // r9
  __int64 v61; // r11
  __int64 v62; // rdi
  OLECHAR *v63; // rbx
  BSTR v64; // rax
  __int64 v65; // rbx
  __int64 v66; // rbx
  __int64 v67; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v68; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v69; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v70; // [rsp+48h] [rbp-B8h] BYREF
  __int64 *v71; // [rsp+50h] [rbp-B0h] BYREF
  VARIANTARG v72; // [rsp+58h] [rbp-A8h] BYREF
  VARIANTARG pvarg; // [rsp+70h] [rbp-90h] BYREF
  BSTR bstrString; // [rsp+88h] [rbp-78h]
  int Value; // [rsp+90h] [rbp-70h] BYREF
  int v76; // [rsp+94h] [rbp-6Ch] BYREF
  __int64 lParam[4]; // [rsp+98h] [rbp-68h] BYREF
  int v78; // [rsp+B8h] [rbp-48h]
  char *v79; // [rsp+C0h] [rbp-40h] BYREF
  char *v80; // [rsp+C8h] [rbp-38h] BYREF
  LRESULT v81; // [rsp+D0h] [rbp-30h]
  char *v82; // [rsp+D8h] [rbp-28h] BYREF
  char *v83; // [rsp+E0h] [rbp-20h] BYREF
  char *v84; // [rsp+E8h] [rbp-18h] BYREF
  char *v85; // [rsp+F0h] [rbp-10h] BYREF
  char *v86; // [rsp+F8h] [rbp-8h] BYREF
  void *v87[3]; // [rsp+100h] [rbp+0h] BYREF
  __int64 **v88[3]; // [rsp+118h] [rbp+18h] BYREF
  __int64 **v89[3]; // [rsp+130h] [rbp+30h] BYREF
  __int64 **v90[3]; // [rsp+148h] [rbp+48h] BYREF
  __int64 **v91[3]; // [rsp+160h] [rbp+60h] BYREF
  __int64 **v92[3]; // [rsp+178h] [rbp+78h] BYREF
  __int64 **v93[4]; // [rsp+190h] [rbp+90h] BYREF
  VARIANTARG v94; // [rsp+1B0h] [rbp+B0h] BYREF
  __int64 v95[3]; // [rsp+1D0h] [rbp+D0h] BYREF
  __int64 v96[3]; // [rsp+1E8h] [rbp+E8h] BYREF
  VARIANTARG v97; // [rsp+200h] [rbp+100h] BYREF
  __int64 v98[4]; // [rsp+220h] [rbp+120h] BYREF
  VARIANTARG v99; // [rsp+240h] [rbp+140h] BYREF
  __int64 v100[3]; // [rsp+260h] [rbp+160h] BYREF
  __int64 v101[3]; // [rsp+278h] [rbp+178h] BYREF
  VARIANTARG v102; // [rsp+290h] [rbp+190h] BYREF
  __int64 v103; // [rsp+2B0h] [rbp+1B0h]
  __int64 v104[3]; // [rsp+2B8h] [rbp+1B8h] BYREF
  VARIANTARG v105; // [rsp+2D0h] [rbp+1D0h] BYREF
  VARIANTARG v106; // [rsp+2F0h] [rbp+1F0h] BYREF
  __int64 pExceptionObject[4]; // [rsp+310h] [rbp+210h] BYREF
  WCHAR psz[32]; // [rsp+330h] [rbp+230h] BYREF
  OLECHAR v109[264]; // [rsp+370h] [rbp+270h] BYREF
  OLECHAR v110[512]; // [rsp+580h] [rbp+480h] BYREF

  v103 = -2i64;
  v69 = 0i64;
  v71 = 0i64;
  v6 = SysAllocString(L"\n\t\t");
  bstrString = SysAllocString(L"\n\t\t\t");
  v81 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  for ( i = 0; i < (int)v81; ++i )
  {
    v67 = 0i64;
    v68 = 0i64;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 392))(a2, v6, &v67);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a3 + 168i64))(a3, v67, &v68);
    if ( v67 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    if ( v68 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
    LODWORD(lParam[0]) = 8;
    SendMessageW(*(HWND *)(a1 + 136), 0x133Cu, i, (LPARAM)lParam);
    wsprintfW(psz, L"%d", (unsigned int)i);
    v67 = 0i64;
    v68 = 0i64;
    v8 = SysAllocString(L"Tab");
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 376))(a2, v8, &v69);
    SysFreeString(v8);
    v9 = SysAllocString(L"name");
    VariantInit(&pvarg);
    v10 = SysAllocString(psz);
    pvarg.vt = 8;
    *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
    v72.llVal = (LONGLONG)v10;
    v72.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v9, &v67);
    v102 = v72;
    (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v102);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v69 + 384i64))(v69, v67, &v68);
    SysFreeString(v9);
    if ( v68 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
      v68 = 0i64;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    VariantClear(&v72);
    v70 = 0i64;
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)a3 + 168i64))(a3, v69, &v70);
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 16i64))(v70);
    v11 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    (*(void (__fastcall **)(__int64, __int64, OLECHAR *))(*(_QWORD *)v11 + 104i64))(v11, 260i64, v109);
    v12 = v69;
    v67 = 0i64;
    v68 = 0i64;
    v13 = SysAllocString(L"Directory");
    VariantInit(&pvarg);
    v14 = SysAllocString(v109);
    pvarg.vt = 8;
    *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
    v72.llVal = (LONGLONG)v14;
    v72.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v13, &v67);
    v106 = v72;
    (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v106);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v12 + 384i64))(v12, v67, &v68);
    SysFreeString(v13);
    if ( v68 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
      v68 = 0i64;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    VariantClear(&v72);
    v15 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 432i64))(v15);
    v17 = aYes_0;
    if ( !v16 )
      v17 = aNo;
    sub_14007BEA0(a2, v69, L"ApplyFilter", v17);
    v18 = *(_QWORD *)(a1 + 8i64 * v78 + 1032);
    v19 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v18 + 24i64))(v18);
    v20 = aYes_0;
    if ( !v19 )
      v20 = aNo;
    sub_14007BEA0(a2, v69, L"AutoArrange", v20);
    v21 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    (*(void (__fastcall **)(__int64, OLECHAR *, __int64))(*(_QWORD *)v21 + 416i64))(v21, v110, 512i64);
    v22 = v69;
    v67 = 0i64;
    v68 = 0i64;
    v23 = SysAllocString(L"Filter");
    VariantInit(&pvarg);
    v24 = SysAllocString(v110);
    pvarg.vt = 8;
    *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
    v72.llVal = (LONGLONG)v24;
    v72.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v23, &v67);
    v94 = v72;
    (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v94);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v22 + 384i64))(v22, v67, &v68);
    SysFreeString(v23);
    if ( v68 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
      v68 = 0i64;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    VariantClear(&v72);
    v25 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    v26 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v25 + 448i64))(v25);
    v27 = aYes_0;
    if ( !v26 )
      v27 = aNo;
    sub_14007BEA0(a2, v69, L"FilterCaseSensitive", v27);
    v28 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    v29 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 608i64))(v28);
    v30 = aYes_0;
    if ( !v29 )
      v30 = aNo;
    sub_14007BEA0(a2, v69, L"ShowGridlines", v30);
    v31 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    v32 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v31 + 496i64))(v31);
    v33 = aYes_0;
    if ( !v32 )
      v33 = aNo;
    sub_14007BEA0(a2, v69, L"ShowHidden", v33);
    v34 = *(_QWORD *)(a1 + 8i64 * v78 + 1032);
    v35 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v34 + 72i64))(v34);
    v36 = aYes_0;
    if ( !v35 )
      v36 = aNo;
    sub_14007BEA0(a2, v69, L"ShowInGroups", v36);
    v37 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v37 + 480i64))(v37);
    v39 = aYes_0;
    if ( !v38 )
      v39 = aNo;
    sub_14007BEA0(a2, v69, L"SortAscending", v39);
    v40 = *(_QWORD *)(a1 + 8i64 * v78 + 1032);
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v40 + 56i64))(v40, &Value);
    itow_s(Value, Buffer, 0x40ui64, 10);
    v41 = v69;
    v67 = 0i64;
    v68 = 0i64;
    v42 = SysAllocString(L"SortMode");
    VariantInit(&pvarg);
    v43 = SysAllocString(Buffer);
    pvarg.vt = 8;
    *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
    v72.llVal = (LONGLONG)v43;
    v72.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v42, &v67);
    v97 = v72;
    (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v97);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v41 + 384i64))(v41, v67, &v68);
    SysFreeString(v42);
    if ( v68 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
      v68 = 0i64;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    VariantClear(&v72);
    v44 = *(_QWORD *)(a1 + 8i64 * v78 + 1032);
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v44 + 48i64))(v44, &v76);
    itow_s(v76, Buffer, 0x40ui64, 10);
    v45 = v69;
    v67 = 0i64;
    v68 = 0i64;
    v46 = SysAllocString(L"ViewMode");
    VariantInit(&pvarg);
    v47 = SysAllocString(Buffer);
    pvarg.vt = 8;
    *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
    v72.llVal = (LONGLONG)v47;
    v72.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v46, &v67);
    v105 = v72;
    (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v105);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v45 + 384i64))(v45, v67, &v68);
    SysFreeString(v46);
    if ( v68 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
      v68 = 0i64;
    }
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    VariantClear(&v72);
    v48 = SysAllocString(L"Columns");
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v48, &v71);
    SysFreeString(v48);
    v87[1] = 0i64;
    v49 = operator new(0x20ui64);
    if ( !v49 )
    {
      v80 = 0i64;
      std::exception::exception((std::exception *)v100, (const char *const *)&v80);
      v100[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v100, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v87[0] = v49;
    *v49 = v49;
    *((void **)v87[0] + 1) = v87[0];
    v88[1] = 0i64;
    v50 = (__int64 **)operator new(0x20ui64);
    if ( !v50 )
    {
      v82 = 0i64;
      std::exception::exception((std::exception *)v98, (const char *const *)&v82);
      v98[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v98, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v88[0] = v50;
    *v50 = (__int64 *)v50;
    *((__int64 ***)v88[0] + 1) = v88[0];
    v89[1] = 0i64;
    v51 = (__int64 **)operator new(0x20ui64);
    if ( !v51 )
    {
      v79 = 0i64;
      std::exception::exception((std::exception *)v96, (const char *const *)&v79);
      v96[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v96, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v89[0] = v51;
    *v51 = (__int64 *)v51;
    *((__int64 ***)v89[0] + 1) = v89[0];
    v90[1] = 0i64;
    v52 = (__int64 **)operator new(0x20ui64);
    if ( !v52 )
    {
      v85 = 0i64;
      std::exception::exception((std::exception *)v95, (const char *const *)&v85);
      v95[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v95, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v90[0] = v52;
    *v52 = (__int64 *)v52;
    *((__int64 ***)v90[0] + 1) = v90[0];
    v91[1] = 0i64;
    v53 = (__int64 **)operator new(0x20ui64);
    if ( !v53 )
    {
      v83 = 0i64;
      std::exception::exception((std::exception *)v104, (const char *const *)&v83);
      v104[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v104, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v91[0] = v53;
    *v53 = (__int64 *)v53;
    *((__int64 ***)v91[0] + 1) = v91[0];
    v92[1] = 0i64;
    v54 = (__int64 **)operator new(0x20ui64);
    if ( !v54 )
    {
      v86 = 0i64;
      std::exception::exception((std::exception *)v101, (const char *const *)&v86);
      v101[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(v101, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v92[0] = v54;
    *v54 = (__int64 *)v54;
    *((__int64 ***)v92[0] + 1) = v92[0];
    v93[1] = 0i64;
    v55 = (__int64 **)operator new(0x20ui64);
    if ( !v55 )
    {
      v84 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v84);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v93[0] = v55;
    *v55 = (__int64 *)v55;
    *((__int64 ***)v93[0] + 1) = v93[0];
    v56 = *(_QWORD *)(a1 + 8i64 * v78 + 1832);
    (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v56 + 648i64))(v56, v87);
    sub_140089CD0(a2, v71, (__int64 ***)v87, L"Generic", 4);
    sub_140089CD0(a2, v71, v88, L"MyComputer", 4);
    sub_140089CD0(a2, v71, v89, L"ControlPanel", 4);
    sub_140089CD0(a2, v71, v90, L"RecycleBin", 4);
    sub_140089CD0(a2, v71, v91, L"Printers", 4);
    sub_140089CD0(a2, v71, v92, L"Network", 4);
    sub_140089CD0(a2, v71, v93, L"NetworkPlaces", 4);
    v57 = v71;
    v67 = 0i64;
    v70 = 0i64;
    (*(void (__fastcall **)(__int64 *, BSTR, __int64 *))(*a2 + 392))(a2, bstrString, &v67);
    (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(*v57 + 168))(v57, v67, &v70);
    if ( v67 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 16i64))(v70);
    v58 = aYes_0;
    if ( !*(_DWORD *)(532i64 * v78 + a1 + 7120) )
      v58 = aNo;
    sub_14007BEA0(a2, v69, L"Locked", v58);
    v59 = aYes_0;
    if ( !*(_DWORD *)(532i64 * v78 + a1 + 7124) )
      v59 = aNo;
    sub_14007BEA0(a2, v69, L"AddressLocked", v59);
    v60 = aYes_0;
    if ( !*(_DWORD *)(532i64 * v78 + a1 + 7128) )
      v60 = aNo;
    sub_14007BEA0(a2, v69, L"UseCustomName", v60);
    v61 = 532i64 * v78;
    if ( *(_DWORD *)(v61 + a1 + 7128) )
    {
      sub_14007BEA0(a2, v69, L"CustomName", (const OLECHAR *)(v61 + a1 + 7132));
    }
    else
    {
      v62 = v69;
      v67 = 0i64;
      v68 = 0i64;
      v63 = SysAllocString(L"CustomName");
      VariantInit(&pvarg);
      v64 = SysAllocString(&word_1400EB32C);
      pvarg.vt = 8;
      *(_QWORD *)&v72.vt = *(_QWORD *)&pvarg.vt;
      v72.llVal = (LONGLONG)v64;
      v72.pRecInfo = pvarg.pRecInfo;
      (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 424))(a2, v63, &v67);
      v99 = v72;
      (*(void (__fastcall **)(__int64, VARIANTARG *))(*(_QWORD *)v67 + 360i64))(v67, &v99);
      (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v62 + 384i64))(v62, v67, &v68);
      SysFreeString(v63);
      if ( v68 )
      {
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v68 + 16i64))(v68);
        v68 = 0i64;
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
      v67 = 0i64;
      VariantClear(&v72);
    }
    v65 = v69;
    v67 = 0i64;
    v70 = 0i64;
    (*(void (__fastcall **)(__int64 *, BSTR, __int64 *))(*a2 + 392))(a2, bstrString, &v67);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v65 + 168i64))(v65, v67, &v70);
    if ( v67 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 16i64))(v70);
    v70 = 0i64;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v69 + 168i64))(v69, v71, &v70);
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 16i64))(v70);
    (*(void (__fastcall **)(__int64 *))(*v71 + 16))(v71);
    v71 = 0i64;
    v66 = v69;
    v67 = 0i64;
    v70 = 0i64;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 392))(a2, v6, &v67);
    (*(void (__fastcall **)(__int64, __int64, __int64 *))(*(_QWORD *)v66 + 168i64))(v66, v67, &v70);
    if ( v67 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v67 + 16i64))(v67);
    v67 = 0i64;
    if ( v70 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v70 + 16i64))(v70);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v69 + 16i64))(v69);
    v69 = 0i64;
    sub_140017CA0(v87);
  }
  SysFreeString(v6);
  SysFreeString(bstrString);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400ED6C0: using guessed type wchar_t aApplyfilter_0[12];
// 1400ED6D8: using guessed type wchar_t aAutoarrange_0[12];
// 1400ED700: using guessed type wchar_t aFiltercasesens_0[20];
// 1400ED728: using guessed type wchar_t aShowgridlines_0[14];
// 1400ED748: using guessed type wchar_t aShowhidden_0[11];
// 1400ED760: using guessed type wchar_t aShowingroups_0[13];
// 1400ED780: using guessed type wchar_t aSortascending_0[14];
// 1400ED7E0: using guessed type wchar_t aGeneric_0[8];
// 1400ED7F0: using guessed type wchar_t aMycomputer_0[11];
// 1400ED808: using guessed type wchar_t aControlpanel_0[13];
// 1400ED828: using guessed type wchar_t aRecyclebin_0[11];
// 1400ED840: using guessed type wchar_t aPrinters_0[9];
// 1400ED858: using guessed type wchar_t aNetwork_0[8];
// 1400ED868: using guessed type wchar_t aNetworkplaces_0[14];
// 1400ED888: using guessed type wchar_t aLocked_0[7];
// 1400ED898: using guessed type wchar_t aAddresslocked_0[14];
// 1400ED8B8: using guessed type wchar_t aUsecustomname_0[14];
// 1400ED8D8: using guessed type wchar_t aCustomname_0[11];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 14012E660: using guessed type OLECHAR Buffer[64];
// 14008B040: using guessed type LPARAM lParam[4];

//----- (000000014008C010) ----------------------------------------------------
__int64 __fastcall sub_14008C010(__int64 a1, __int64 *a2, __int64 *a3)
{
  BSTR v6; // rdi
  OLECHAR *v7; // rbx
  __int64 v8; // rax
  __int64 v10; // [rsp+48h] [rbp+10h] BYREF
  __int64 v11; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  v6 = SysAllocString(L"\n\t");
  sub_14007B920(a2, (__int64)v6, (__int64)a3);
  v7 = SysAllocString(L"Tabs");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 376))(a2, v7, &v10);
  SysFreeString(v7);
  sub_14008B040(a1, a2, v10);
  sub_14007B920(a2, (__int64)v6, v10);
  v8 = *a3;
  v11 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(v8 + 168))(a3, v10, &v11);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 16i64))(v10);
}

//----- (000000014008C100) ----------------------------------------------------
void __fastcall sub_14008C100(__int64 a1, __int64 a2)
{
  BSTR v4; // rax
  int i; // ebx
  __int64 v6; // [rsp+20h] [rbp-20h] BYREF
  __int64 v7; // [rsp+28h] [rbp-18h] BYREF
  const WCHAR *v8; // [rsp+30h] [rbp-10h] BYREF
  const WCHAR *v9; // [rsp+38h] [rbp-8h] BYREF
  int v10; // [rsp+68h] [rbp+28h] BYREF
  __int64 *v11; // [rsp+70h] [rbp+30h] BYREF
  __int64 v12; // [rsp+78h] [rbp+38h] BYREF

  if ( a2 )
  {
    v6 = 0i64;
    v11 = 0i64;
    v7 = 0i64;
    v12 = 0i64;
    v4 = SysAllocString(L"//Settings/*");
    (*(void (__fastcall **)(__int64, BSTR, __int64 *))(*(_QWORD *)a2 + 288i64))(a2, v4, &v6);
    if ( v6 )
    {
      (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v6 + 64i64))(v6, &v10);
      for ( i = 0; i < v10; v11 = 0i64 )
      {
        (*(void (__fastcall **)(__int64, _QWORD, __int64 **))(*(_QWORD *)v6 + 56i64))(v6, (unsigned int)i, &v11);
        if ( (*(int (__fastcall **)(__int64 *, __int64 *))(*v11 + 136))(v11, &v7) >= 0
          && (*(int (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v7 + 80i64))(v7, 0i64, &v12) >= 0 )
        {
          (*(void (__fastcall **)(__int64, const WCHAR **))(*(_QWORD *)v12 + 208i64))(v12, &v9);
          (*(void (__fastcall **)(__int64 *, const WCHAR **))(*v11 + 208))(v11, &v8);
          sub_140088060(a1, v11, v9, v8);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16i64))(v12);
          v12 = 0i64;
        }
        (*(void (__fastcall **)(__int64 *))(*v11 + 16))(v11);
        ++i;
      }
    }
  }
}

//----- (000000014008C230) ----------------------------------------------------
void __fastcall sub_14008C230(__int64 a1)
{
  sub_140089880(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (000000014008C250) ----------------------------------------------------
__int64 __fastcall sub_14008C250(__int64 a1)
{
  return sub_14008A160(*(__int64 ****)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (000000014008C270) ----------------------------------------------------
__int64 __fastcall sub_14008C270(__int64 a1)
{
  return sub_14008C010(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (000000014008C290) ----------------------------------------------------
void __fastcall sub_14008C290(__int64 a1)
{
  sub_14008A9A0(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(__int64 **)(a1 + 48));
}

//----- (000000014008C2B0) ----------------------------------------------------
void __fastcall sub_14008C2B0(__int64 a1)
{
  sub_140089C30(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (000000014008C2D0) ----------------------------------------------------
__int64 __fastcall sub_14008C2D0(__int64 a1)
{
  return sub_14008AF60(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (000000014008C2F0) ----------------------------------------------------
void __fastcall sub_14008C2F0(__int64 a1)
{
  sub_14008C100(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (000000014008C310) ----------------------------------------------------
__int64 __fastcall sub_14008C310(__int64 a1, __int64 *a2)
{
  _QWORD **v2; // rax
  _QWORD *v4; // rcx
  unsigned int v5; // er12
  _QWORD *v7; // rbx
  int i; // er14
  unsigned int v9; // edi
  __int64 v10; // rsi
  int v11; // eax
  __int64 v12; // rbx
  __int64 v13; // rdx
  char *v14; // rax
  __int64 v15; // rdx
  LPCWSTR v17; // [rsp+20h] [rbp-59h] BYREF
  int v18; // [rsp+28h] [rbp-51h] BYREF
  __int64 v19; // [rsp+30h] [rbp-49h] BYREF
  LPCWSTR lpString1; // [rsp+38h] [rbp-41h] BYREF
  __int64 v21; // [rsp+40h] [rbp-39h] BYREF
  int v22[6]; // [rsp+48h] [rbp-31h] BYREF
  WCHAR String2[32]; // [rsp+60h] [rbp-19h] BYREF

  v2 = (_QWORD **)*a2;
  v21 = 0i64;
  v19 = 0i64;
  v4 = *v2;
  *v2 = v2;
  v5 = -1;
  *(_QWORD *)(*a2 + 8) = *a2;
  a2[1] = 0i64;
  if ( v4 != (_QWORD *)*a2 )
  {
    do
    {
      v7 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v7;
    }
    while ( v7 != (_QWORD *)*a2 );
  }
  if ( (*(int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 136i64))(a1, &v21) >= 0 )
  {
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v21 + 88i64))(v21, &v18);
    for ( i = 0; i < v18; ++i )
    {
      (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v21 + 80i64))(v21, (unsigned int)i, &v19);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v19 + 56i64))(v19, &lpString1);
      (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v19 + 208i64))(v19, &v17);
      if ( lstrcmpW(lpString1, L"name") )
      {
        v9 = 0;
        v10 = 0i64;
        while ( 1 )
        {
          sub_140001000(String2, 0x20ui64, L"%s_Width", &aName_2[66 * v9]);
          if ( !lstrcmpW(lpString1, &aName_2[66 * v9]) )
            break;
          if ( !lstrcmpW(lpString1, String2) )
          {
            if ( a2[1] )
              *(_DWORD *)(*(_QWORD *)(*a2 + 8) + 24i64) = sub_14004B61C(v17);
            goto LABEL_29;
          }
          ++v9;
          ++v10;
          if ( v9 >= 0x22 )
            goto LABEL_29;
        }
        v22[0] = *(_DWORD *)&aName_2[66 * v10 + 64];
        v11 = lstrcmpW(v17, L"yes");
        v12 = *a2;
        v13 = *(_QWORD *)(*a2 + 8);
        v22[1] = v11 == 0;
        v14 = sub_140017AD0(v12, v13, v22);
        v15 = a2[1];
        if ( v15 == 0x1555555555555554i64 )
          sub_14002B5F8("list<T> too long");
        a2[1] = v15 + 1;
        *(_QWORD *)(v12 + 8) = v14;
        **((_QWORD **)v14 + 1) = v14;
      }
      else if ( lstrcmpW(v17, L"Generic") )
      {
        if ( lstrcmpW(v17, L"MyComputer") )
        {
          if ( lstrcmpW(v17, L"ControlPanel") )
          {
            if ( lstrcmpW(v17, L"RecycleBin") )
            {
              if ( lstrcmpW(v17, L"Printers") )
              {
                if ( lstrcmpW(v17, L"Network") )
                {
                  if ( !lstrcmpW(v17, L"NetworkPlaces") )
                    v5 = 6;
                }
                else
                {
                  v5 = 5;
                }
              }
              else
              {
                v5 = 4;
              }
            }
            else
            {
              v5 = 3;
            }
          }
          else
          {
            v5 = 2;
          }
        }
        else
        {
          v5 = 1;
        }
      }
      else
      {
        v5 = 0;
      }
LABEL_29:
      ;
    }
  }
  return v5;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 1400ED9C0: using guessed type wchar_t aSWidth_0[9];
// 14011DBC0: using guessed type wchar_t aName_2[5];

//----- (000000014008C640) ----------------------------------------------------
__int64 __fastcall sub_14008C640(__int64 **a1, __int64 a2)
{
  __int64 *v4; // rax
  __int64 *v5; // rdi
  OLECHAR *v6; // r12
  __int64 v7; // rcx
  int v8; // ebx
  __int64 **v9; // rcx
  __int64 *v10; // rcx
  __int64 *v11; // rbx
  __int64 v13; // [rsp+20h] [rbp-50h] BYREF
  char *v14[2]; // [rsp+28h] [rbp-48h] BYREF
  __int64 *v15[3]; // [rsp+38h] [rbp-38h] BYREF
  __int64 pExceptionObject[4]; // [rsp+50h] [rbp-20h] BYREF
  int v17; // [rsp+B0h] [rbp+40h] BYREF
  __int64 v18; // [rsp+B8h] [rbp+48h] BYREF

  v14[1] = (char *)-2i64;
  v18 = 0i64;
  v13 = 0i64;
  v15[1] = 0i64;
  v4 = (__int64 *)operator new(0x20ui64);
  v5 = v4;
  if ( !v4 )
  {
    v14[0] = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v14);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v15[0] = v4;
  *v4 = (__int64)v4;
  v4[1] = (__int64)v4;
  if ( !a2 )
    goto LABEL_19;
  v6 = SysAllocString(L"//DefaultColumns/*");
  (*(void (__fastcall **)(__int64, OLECHAR *, __int64 *))(*(_QWORD *)a2 + 288i64))(a2, v6, &v18);
  v7 = v18;
  if ( v18 )
  {
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v18 + 64i64))(v18, &v17);
    v8 = 0;
    if ( v17 > 0 )
    {
      do
      {
        (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v18 + 56i64))(v18, (unsigned int)v8, &v13);
        switch ( (unsigned int)sub_14008C310(v13, (__int64 *)v15) )
        {
          case 0u:
            v9 = a1 + 7779;
            goto LABEL_13;
          case 1u:
            v9 = a1 + 7782;
            goto LABEL_13;
          case 2u:
            v9 = a1 + 7785;
            goto LABEL_13;
          case 3u:
            v9 = a1 + 7788;
            goto LABEL_13;
          case 4u:
            v9 = a1 + 7791;
            goto LABEL_13;
          case 5u:
            v9 = a1 + 7794;
            goto LABEL_13;
          case 6u:
            v9 = a1 + 7797;
LABEL_13:
            sub_14000BD40(v9, v15);
            break;
          default:
            break;
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
        v13 = 0i64;
        ++v8;
      }
      while ( v8 < v17 );
      v5 = v15[0];
    }
    v7 = v18;
  }
  if ( v6 )
  {
    SysFreeString(v6);
LABEL_19:
    v7 = v18;
  }
  if ( v7 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
  if ( v13 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v13 + 16i64))(v13);
  v10 = (__int64 *)*v5;
  *v5 = (__int64)v5;
  v5[1] = (__int64)v5;
  if ( v10 != v5 )
  {
    do
    {
      v11 = (__int64 *)*v10;
      j_free(v10);
      v10 = v11;
    }
    while ( v11 != v5 );
  }
  j_free(v5);
  return 0i64;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014008C850) ----------------------------------------------------
__int64 __fastcall sub_14008C850(__int64 a1)
{
  return sub_14008C640(*(__int64 ***)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (000000014008C870) ----------------------------------------------------
void __fastcall sub_14008C870(__int64 a1, __int64 *a2, __int64 a3)
{
  OLECHAR *v6; // r14
  OLECHAR *v7; // rbx
  __int64 v8; // rdi
  __int64 i; // rbx
  __int64 *v10; // rbx
  __int64 *v11; // [rsp+20h] [rbp-69h] BYREF
  __int64 v12; // [rsp+28h] [rbp-61h] BYREF
  __int64 v13[2]; // [rsp+30h] [rbp-59h] BYREF
  void *Src[3]; // [rsp+40h] [rbp-49h] BYREF
  unsigned __int64 v15; // [rsp+58h] [rbp-31h]
  void *Block; // [rsp+68h] [rbp-21h] BYREF
  __int64 v17; // [rsp+78h] [rbp-11h]
  unsigned __int64 v18; // [rsp+80h] [rbp-9h]
  int v19; // [rsp+90h] [rbp+7h]
  int v20; // [rsp+94h] [rbp+Bh]

  v13[1] = -2i64;
  v11 = 0i64;
  v6 = SysAllocString(L"\n\t");
  sub_14007B920(a2, (__int64)v6, a3);
  v7 = SysAllocString(L"ColorRules");
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 376))(a2, v7, &v11);
  SysFreeString(v7);
  v8 = *(_QWORD *)(a1 + 80);
  for ( i = *(_QWORD *)(a1 + 72); i != v8; i += 88i64 )
  {
    v15 = 7i64;
    Src[2] = 0i64;
    LOWORD(Src[0]) = 0;
    sub_140009610(Src, (_QWORD *)i, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v18 = 7i64;
    v17 = 0i64;
    LOWORD(Block) = 0;
    sub_140009610(&Block, (_QWORD *)(i + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v19 = *(_DWORD *)(i + 80);
    v20 = *(_DWORD *)(i + 84);
    sub_140089050(a2, v11, (__int64)Src);
    if ( v18 >= 8 )
      j_free(Block);
    v18 = 7i64;
    v17 = 0i64;
    LOWORD(Block) = 0;
    if ( v15 >= 8 )
      j_free(Src[0]);
  }
  v10 = v11;
  v13[0] = 0i64;
  v12 = 0i64;
  (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 *))(*a2 + 392))(a2, v6, v13);
  (*(void (__fastcall **)(__int64 *, __int64, __int64 *))(*v10 + 168))(v10, v13[0], &v12);
  if ( v13[0] )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v13[0] + 16i64))(v13[0]);
  v13[0] = 0i64;
  if ( v12 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16i64))(v12);
  v12 = 0i64;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a3 + 168i64))(a3, v11, &v12);
  if ( v12 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16i64))(v12);
  (*(void (__fastcall **)(__int64 *))(*v11 + 16))(v11);
  v11 = 0i64;
  SysFreeString(v6);
}

//----- (000000014008CA80) ----------------------------------------------------
void __fastcall sub_14008CA80(__int64 a1)
{
  sub_14008C870(*(_QWORD *)(a1 + 16), *(__int64 **)(a1 + 32), *(_QWORD *)(a1 + 48));
}

//----- (000000014008CF10) ----------------------------------------------------
void __fastcall sub_14008CF10(__int64 a1, __int64 a2)
{
  OLECHAR *v4; // rsi
  _DWORD *v5; // rcx
  _DWORD *v6; // r8
  _QWORD *v7; // rbx
  __int64 v8; // [rsp+38h] [rbp+10h] BYREF

  if ( a2 )
  {
    v8 = 0i64;
    v4 = SysAllocString(L"//ColorRule");
    if ( !(*(unsigned int (__fastcall **)(__int64, OLECHAR *, __int64 *))(*(_QWORD *)a2 + 296i64))(a2, v4, &v8) )
    {
      v5 = *(_DWORD **)(a1 + 80);
      v6 = *(_DWORD **)(a1 + 72);
      if ( v6 != v5 )
      {
        v7 = sub_14000A200(v5, *(_DWORD **)(a1 + 80), v6);
        sub_14000A280(v7, *(_QWORD **)(a1 + 80));
        *(_QWORD *)(a1 + 80) = v7;
      }
      sub_14008CAA0(a1, v8);
    }
    if ( v4 )
      SysFreeString(v4);
    if ( v8 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16i64))(v8);
  }
}
// 14008CAA0: using guessed type __int64 __fastcall sub_14008CAA0(_QWORD, _QWORD);

//----- (000000014008CFD0) ----------------------------------------------------
void __fastcall sub_14008CFD0(__int64 a1)
{
  sub_14008CF10(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}

//----- (000000014008D3E0) ----------------------------------------------------
void __fastcall sub_14008D3E0(__int64 a1)
{
  OLECHAR *v2; // rdi
  __int64 v3; // rcx
  int v4; // ebx
  __int64 *v5; // rax
  __int64 v6; // [rsp+20h] [rbp-30h] BYREF
  __int64 v7; // [rsp+28h] [rbp-28h] BYREF
  __int64 v8; // [rsp+30h] [rbp-20h] BYREF
  char v9[16]; // [rsp+38h] [rbp-18h] BYREF
  int v10; // [rsp+70h] [rbp+20h] BYREF
  int v11; // [rsp+78h] [rbp+28h] BYREF
  __int64 v12; // [rsp+80h] [rbp+30h] BYREF
  LPCWSTR lpString1; // [rsp+88h] [rbp+38h] BYREF

  if ( a1 )
  {
    v6 = 0i64;
    v7 = 0i64;
    v12 = 0i64;
    v8 = 0i64;
    v2 = SysAllocString(L"//State/*");
    (*(void (__fastcall **)(__int64, OLECHAR *, __int64 *))(*(_QWORD *)a1 + 288i64))(a1, v2, &v6);
    v3 = v6;
    if ( v6 )
    {
      (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v6 + 64i64))(v6, &v11);
      v4 = 0;
      if ( v11 > 0 )
      {
        while ( 1 )
        {
          if ( (*(int (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v6 + 56i64))(v6, (unsigned int)v4, &v7) < 0 )
            goto LABEL_34;
          if ( (*(int (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v7 + 136i64))(v7, &v12) < 0 )
            goto LABEL_34;
          (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v12 + 88i64))(v12, &v10);
          if ( v10 < 1 )
            goto LABEL_34;
          (*(void (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v12 + 80i64))(v12, 0i64, &v8);
          (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v8 + 56i64))(v8, v9);
          (*(void (__fastcall **)(__int64, LPCWSTR *))(*(_QWORD *)v8 + 208i64))(v8, &lpString1);
          if ( !lstrcmpiW(lpString1, L"ColorRules") )
            break;
          if ( !lstrcmpiW(lpString1, L"CustomizeColors") )
          {
            v5 = sub_1400C7E00();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"Search") )
          {
            v5 = (__int64 *)sub_14009F9F0();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"WildcardSelect") )
          {
            v5 = (__int64 *)sub_140091E70();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"RenameTab") )
          {
            v5 = sub_1400A2F70();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"MassRename") )
          {
            v5 = sub_1400BAF50();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"Filter") )
          {
            v5 = (__int64 *)sub_1400C2AE0();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"SplitFile") )
          {
            v5 = (__int64 *)sub_140098DF0();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"DestroyFiles") )
          {
            v5 = sub_1400C6F70();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"MergeFiles") )
          {
            v5 = sub_1400B91E0();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"SetFileAttributes") )
          {
            v5 = sub_14009B9D0();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"SelectColumns") )
          {
            v5 = sub_14009DE30();
            goto LABEL_33;
          }
          if ( !lstrcmpiW(lpString1, L"SetDefaultColumns") )
          {
            v5 = sub_14009C690();
            goto LABEL_33;
          }
LABEL_34:
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
          ++v4;
          v7 = 0i64;
          if ( v4 >= v11 )
            goto LABEL_35;
        }
        v5 = sub_1400C91E0();
LABEL_33:
        sub_14007C470((__int64)v5, v12, v10);
        goto LABEL_34;
      }
LABEL_35:
      v3 = v6;
    }
    if ( v2 )
    {
      SysFreeString(v2);
      v3 = v6;
    }
    if ( v3 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
    if ( v7 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
  }
}
// 140091E70: using guessed type __int64 sub_140091E70(void);
// 140098DF0: using guessed type __int64 sub_140098DF0(void);
// 14009F9F0: using guessed type __int64 sub_14009F9F0(void);
// 1400C2AE0: using guessed type __int64 sub_1400C2AE0(void);
// 14008D3E0: using guessed type char var_18[16];

//----- (000000014008D6D0) ----------------------------------------------------
__int64 __fastcall sub_14008D6D0(__int64 a1)
{
  return sub_14008CFF0(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 48));
}
// 14008CFF0: using guessed type __int64 __fastcall sub_14008CFF0(_QWORD, _QWORD);

//----- (000000014008D6F0) ----------------------------------------------------
void __fastcall sub_14008D6F0(__int64 a1)
{
  sub_14008D3E0(*(_QWORD *)(a1 + 32));
}

//----- (000000014008E970) ----------------------------------------------------
__int64 __fastcall sub_14008E970(__int64 a1)
{
  return sub_14008D700(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
}
// 14008D700: using guessed type __int64 __fastcall sub_14008D700(_QWORD, _QWORD);

//----- (000000014008E980) ----------------------------------------------------
int sub_14008E980()
{
  if ( SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++") )
    return MessageBoxW(0i64, L"Settings could not be cleared.", L"Explorer++", 0x30u);
  else
    return MessageBoxW(0i64, L"Settings cleared successfully.", L"Explorer++", 0);
}

//----- (000000014008E9E0) ----------------------------------------------------
int sub_14008E9E0()
{
  WCHAR Text[312]; // [rsp+20h] [rbp-288h] BYREF

  memmove(
    Text,
    L"Usage:\n"
     "explorer++.exe dir1 dir2 ... dirN\n"
     " where dir1 to dirN are the directories to open.\n"
     "\n"
     "e.g. explorer++.exe C:\\ D:\\\n"
     "will open the directories C:\\ and D:\\, each in their own tabs\n"
     "\n"
     "Virtual folders can be opened simply by supplying their name:\n"
     "e.g. explorer++.exe \"control panel\"\n"
     "will open the Control Panel\n",
    0x26Aui64);
  return MessageBoxW(0i64, Text, L"Explorer++", 0);
}
// 1400EEC20: using guessed type wchar_t aUsageExplorerE[309];

//----- (000000014008EA50) ----------------------------------------------------
HMODULE __fastcall sub_14008EA50(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HMODULE result; // rax
  HMODULE v3; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // rbx
  HANDLE FileW; // r12
  DWORD CurrentThreadId; // eax
  DWORD v9; // ebx
  HANDLE CurrentProcess; // rax
  HANDLE TokenHandle; // [rsp+60h] [rbp-A0h] BYREF
  DWORD v12; // [rsp+68h] [rbp-98h] BYREF
  struct _EXCEPTION_POINTERS *v13; // [rsp+6Ch] [rbp-94h]
  int v14; // [rsp+74h] [rbp-8Ch]
  struct _SYSTEMTIME SystemTime; // [rsp+78h] [rbp-88h] BYREF
  __int64 v16[2]; // [rsp+88h] [rbp-78h] BYREF
  int v17; // [rsp+98h] [rbp-68h]
  __int16 v18; // [rsp+9Ch] [rbp-64h]
  WCHAR Dest[264]; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR FileName[264]; // [rsp+2B0h] [rbp+1B0h] BYREF

  v16[0] = 0x6C007000780045i64;
  v16[1] = 0x7200650072006Fi64;
  v17 = 2818091;
  v18 = 0;
  result = sub_14000AF70(L"Dbghelp.dll");
  if ( result )
  {
    result = (HMODULE)GetProcAddress(result, "MiniDumpWriteDump");
    v3 = result;
    if ( result )
    {
      GetLocalTime(&SystemTime);
      CurrentProcessId = GetCurrentProcessId();
      v5 = OpenProcess(0x400u, 0, CurrentProcessId);
      v6 = v5;
      if ( v5 )
      {
        if ( OpenProcessToken(v5, 0xCu, &TokenHandle) )
        {
          ExpandEnvironmentStringsForUserW(TokenHandle, L"%TEMP%", Dest, 0x104u);
          CloseHandle(TokenHandle);
        }
        CloseHandle(v6);
      }
      sub_140001000(
        FileName,
        0x104ui64,
        L"%s\\%s%s-%02d%02d%04d-%02d%02d%02d.dmp",
        Dest,
        v16,
        L"1.3.4.485",
        SystemTime.wDay,
        SystemTime.wMonth,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);
      FileW = CreateFileW(FileName, 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);
      if ( FileW != (HANDLE)-1i64 )
      {
        CurrentThreadId = GetCurrentThreadId();
        v13 = ExceptionInfo;
        v14 = 0;
        v12 = CurrentThreadId;
        v9 = GetCurrentProcessId();
        CurrentProcess = GetCurrentProcess();
        ((void (__fastcall *)(HANDLE, _QWORD, HANDLE, _QWORD, DWORD *, _QWORD, _QWORD))v3)(
          CurrentProcess,
          v9,
          FileW,
          0i64,
          &v12,
          0i64,
          0i64);
      }
      return 0i64;
    }
  }
  return result;
}
// 1400EEF90: using guessed type wchar_t a134485[10];
// 1400EEFB0: using guessed type wchar_t aSSS02d02d04d02[38];

//----- (000000014008EC90) ----------------------------------------------------
__int64 __fastcall sub_14008EC90(__int16 *a1)
{
  unsigned int v2; // er12
  void **v3; // rdi
  void **v4; // rbx
  __int16 *v5; // rbx
  __int64 v6; // rcx
  __int16 v7; // ax
  __int16 *v8; // rbx
  __int16 i; // ax
  __int64 v10; // rcx
  __int16 v11; // ax
  __int16 *v12; // rbx
  __int16 j; // ax
  __int64 v14; // rdx
  _WORD *v15; // rcx
  __int16 v16; // ax
  HANDLE MutexW; // rsi
  HWND WindowW; // rax
  HWND v19; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v21; // rax
  void *v22; // rdi
  __int64 v23; // rcx
  char *v24; // rdi
  bool v25; // zf
  _QWORD *v26; // rdi
  char *v27; // rdx
  LPARAM lParam; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v30; // [rsp+38h] [rbp-D0h]
  __int64 v31; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v32; // [rsp+48h] [rbp-C0h]
  __int16 psz1[264]; // [rsp+58h] [rbp-B0h] BYREF
  char v34[528]; // [rsp+268h] [rbp+160h] BYREF
  WCHAR pszPath[264]; // [rsp+478h] [rbp+370h] BYREF
  WCHAR Text[312]; // [rsp+688h] [rbp+580h] BYREF

  v2 = 0;
  v3 = *(void ***)qword_14012DFB8;
  *(_QWORD *)qword_14012DFB8 = qword_14012DFB8;
  *((_QWORD *)qword_14012DFB8 + 1) = qword_14012DFB8;
  qword_14012DFC0 = 0i64;
  if ( v3 != qword_14012DFB8 )
  {
    do
    {
      v4 = (void **)*v3;
      if ( (unsigned __int64)v3[5] >= 8 )
        j_free(v3[2]);
      v3[5] = (void *)7;
      v3[4] = 0i64;
      *((_WORD *)v3 + 8) = 0;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != qword_14012DFB8 );
  }
  if ( a1 )
  {
    v5 = sub_1400805D0(a1, psz1);
  }
  else
  {
    psz1[0] = 0;
    v5 = 0i64;
  }
  while ( 1 )
  {
    v6 = 0i64;
    if ( !v5 || !*v5 )
      return v2;
    while ( *v5 == 32 || *v5 == 9 )
      ++v5;
    v7 = *v5;
    if ( *v5 == 34 )
    {
      v8 = v5 + 1;
      for ( i = *v8; *v8; i = *v8 )
      {
        if ( i == 34 )
          break;
        psz1[v6++] = i;
        ++v8;
      }
      v5 = v8 + 1;
    }
    else if ( v7 )
    {
      do
      {
        if ( v7 == 32 )
          break;
        if ( v7 == 9 )
          break;
        psz1[v6++] = v7;
        v7 = *++v5;
      }
      while ( *v5 );
    }
    psz1[v6] = 0;
    while ( *v5 == 32 || *v5 == 9 )
      ++v5;
    if ( !StrCmpW((PCWSTR)psz1, L"/?") )
    {
      memmove(
        Text,
        L"Usage:\n"
         "explorer++.exe dir1 dir2 ... dirN\n"
         " where dir1 to dirN are the directories to open.\n"
         "\n"
         "e.g. explorer++.exe C:\\ D:\\\n"
         "will open the directories C:\\ and D:\\, each in their own tabs\n"
         "\n"
         "Virtual folders can be opened simply by supplying their name:\n"
         "e.g. explorer++.exe \"control panel\"\n"
         "will open the Control Panel\n",
        0x26Aui64);
      MessageBoxW(0i64, Text, L"Explorer++", 0);
      v2 = 1;
    }
    if ( lstrcmpW((LPCWSTR)psz1, L"-l") )
    {
      if ( lstrcmpW((LPCWSTR)psz1, L"-clear_settings") )
      {
        if ( lstrcmpW((LPCWSTR)psz1, L"-remove_as_default") )
        {
          if ( lstrcmpW((LPCWSTR)psz1, L"-set_as_default") )
          {
            if ( lstrcmpW((LPCWSTR)psz1, L"-open_new_tab") )
            {
              CurrentProcessId = GetCurrentProcessId();
              v21 = OpenProcess(0x410u, 0, CurrentProcessId);
              v22 = v21;
              if ( v21 )
              {
                GetModuleFileNameExW(v21, 0i64, pszPath, 260i64);
                CloseHandle(v22);
              }
              PathRemoveFileSpecW(pszPath);
              sub_14007F0B0((PCNZWCH)psz1, (__int64)pszPath, v34);
              v32 = 7i64;
              v31 = 0i64;
              LOWORD(lParam) = 0;
              v23 = -1i64;
              v24 = v34;
              do
              {
                if ( !v23 )
                  break;
                v25 = *(_WORD *)v24 == 0;
                v24 += 2;
                --v23;
              }
              while ( !v25 );
              sub_1400099E0(&lParam, v34, -v23 - 2);
              v26 = qword_14012DFB8;
              v27 = sub_14000A760((__int64)qword_14012DFB8, *((_QWORD *)qword_14012DFB8 + 1), &lParam);
              if ( qword_14012DFC0 == 0x666666666666665i64 )
                sub_14002B5F8("list<T> too long");
              ++qword_14012DFC0;
              v26[1] = v27;
              **((_QWORD **)v27 + 1) = v27;
              if ( v32 >= 8 )
                j_free((void *)lParam);
            }
            else
            {
              MutexW = CreateMutexW(0i64, 1, L"Explorer++");
              if ( GetLastError() == 183 )
              {
                WindowW = FindWindowW(L"Explorer++", 0i64);
                v19 = WindowW;
                if ( WindowW )
                {
                  LODWORD(v30) = 0;
                  v31 = 0i64;
                  SendMessageW(WindowW, 0x4Au, 0i64, (LPARAM)&lParam);
                  SetForegroundWindow(v19);
                  ShowWindow(v19, 5);
                }
              }
              if ( MutexW )
                CloseHandle(MutexW);
              v2 = 1;
            }
          }
          else if ( (unsigned int)sub_1400D1DE0(2, L"openinexplorer++", L"Open In Explorer++") )
          {
            MessageBoxW(0i64, L"Explorer++ successfully set as default file manager.", L"Explorer++", 0);
          }
          else
          {
            MessageBoxW(
              0i64,
              L"Could not set Explorer++ as default file manager. Please ensure you have administrator privileges.",
              L"Explorer++",
              0x30u);
          }
        }
        else if ( (unsigned int)sub_1400D1B10(2, (__int64)L"openinexplorer++") )
        {
          MessageBoxW(0i64, L"Explorer++ successfully removed as default file manager.", L"Explorer++", 0);
        }
        else
        {
          MessageBoxW(
            0i64,
            L"Could not remove Explorer++ as default file manager. Please ensure you have administrator privileges.",
            L"Explorer++",
            0x30u);
        }
      }
      else if ( SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++") )
      {
        MessageBoxW(0i64, L"Settings could not be cleared.", L"Explorer++", 0x30u);
      }
      else
      {
        MessageBoxW(0i64, L"Settings cleared successfully.", L"Explorer++", 0);
      }
    }
    else
    {
      v10 = 0i64;
      if ( *v5 )
      {
        while ( *v5 == 32 || *v5 == 9 )
          ++v5;
        v11 = *v5;
        if ( *v5 == 34 )
        {
          v12 = v5 + 1;
          for ( j = *v12; *v12; j = *v12 )
          {
            if ( j == 34 )
              break;
            psz1[v10++] = j;
            ++v12;
          }
          v5 = v12 + 1;
        }
        else if ( v11 )
        {
          do
          {
            if ( v11 == 32 )
              break;
            if ( v11 == 9 )
              break;
            psz1[v10++] = v11;
            v11 = *++v5;
          }
          while ( *v5 );
        }
        psz1[v10] = 0;
        while ( *v5 == 32 || *v5 == 9 )
          ++v5;
        dword_14012DB90 = 1;
        v14 = 32i64;
        v15 = &unk_14012DA20;
        while ( v14 != -2147483614 )
        {
          v16 = *(_WORD *)((char *)v15 + (char *)psz1 - (char *)&unk_14012DA20);
          if ( !v16 )
            break;
          *v15++ = v16;
          if ( !--v14 )
          {
            --v15;
            break;
          }
        }
        *v15 = 0;
      }
      else
      {
        psz1[0] = 0;
        v5 = 0i64;
      }
    }
  }
}
// 14008EF66: conditional instruction was optimized away because rdx.8!=0
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400EE8F0: using guessed type wchar_t aOpeninexplorer[17];
// 1400EE938: using guessed type wchar_t aOpenInExplorer[19];
// 1400EE9D8: using guessed type wchar_t aOpeninexplorer_0[17];
// 1400EEC20: using guessed type wchar_t aUsageExplorerE[309];
// 14012DB90: using guessed type int dword_14012DB90;
// 14012DFC0: using guessed type __int64 qword_14012DFC0;
// 14008EC90: using guessed type WCHAR psz1[264];

//----- (000000014008F2A0) ----------------------------------------------------
__int64 __fastcall sub_14008F2A0(HINSTANCE hInst)
{
  WNDCLASSEXW v3; // [rsp+30h] [rbp-58h] BYREF

  *(_QWORD *)&v3.cbSize = 80i64;
  v3.lpfnWndProc = (WNDPROC)sub_1400DA990;
  v3.cbClsExtra = 0;
  v3.cbWndExtra = 8;
  v3.hInstance = hInst;
  v3.hIcon = (HICON)LoadImageW(hInst, (LPCWSTR)0x69, 1u, 48, 48, 0x80u);
  v3.hIconSm = (HICON)LoadImageW(hInst, (LPCWSTR)0xCE, 1u, 16, 16, 0x80u);
  v3.hCursor = LoadCursorW(0i64, (LPCWSTR)0x7F00);
  v3.hbrBackground = 0i64;
  v3.lpszClassName = L"Explorer++";
  v3.lpszMenuName = 0i64;
  return sub_14001A9F0(&v3);
}

//----- (000000014008F380) ----------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  HINSTANCE v4; // r15
  __int16 *CommandLineW; // rax
  int v8; // er13
  WCHAR *v9; // rbx
  __int64 v10; // rcx
  int v11; // eax
  int v12; // er12
  DWORD CurrentProcessId; // eax
  HANDLE v14; // rax
  void *v15; // rdi
  const WCHAR *v16; // r9
  WCHAR *v17; // rdi
  int v18; // esi
  int v19; // eax
  int v20; // ebx
  HANDLE MutexW; // r13
  HWND WindowW; // rax
  HWND v23; // r12
  _QWORD *v24; // rdi
  _QWORD *v25; // rbx
  void **v26; // r8
  __int64 v27; // rdx
  WCHAR *v28; // rcx
  signed __int64 v29; // r8
  WCHAR v30; // ax
  int v31; // eax
  HMODULE v32; // r12
  const WCHAR *v33; // rdx
  HWND v34; // rdi
  int v35; // ebx
  int SystemMetrics; // ebx
  int v37; // eax
  HACCEL AcceleratorsW; // rbx
  LPCITEMIDLIST pidl2; // [rsp+50h] [rbp-B0h] BYREF
  LPCITEMIDLIST pidl1; // [rsp+58h] [rbp-A8h] BYREF
  LPITEMIDLIST ppidl; // [rsp+60h] [rbp-A0h] BYREF
  HKEY phkResult; // [rsp+68h] [rbp-98h] BYREF
  HANDLE TokenHandle; // [rsp+70h] [rbp-90h] BYREF
  int v44[2]; // [rsp+78h] [rbp-88h] BYREF
  LPARAM lParam; // [rsp+80h] [rbp-80h] BYREF
  int v46; // [rsp+88h] [rbp-78h]
  WCHAR *v47; // [rsp+90h] [rbp-70h]
  struct tagMSG Msg; // [rsp+98h] [rbp-68h] BYREF
  WINDOWPLACEMENT Data; // [rsp+C8h] [rbp-38h] BYREF
  void *Block[2]; // [rsp+F8h] [rbp-8h] BYREF
  __int64 v51; // [rsp+108h] [rbp+8h]
  unsigned __int64 v52; // [rsp+110h] [rbp+10h]
  struct _OSVERSIONINFOW VersionInformation; // [rsp+120h] [rbp+20h] BYREF
  WCHAR Dest[264]; // [rsp+240h] [rbp+140h] BYREF

  v4 = hInstance;
  phkResult = (HKEY)hInstance;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) && VersionInformation.dwMajorVersion < 5 )
  {
    MessageBoxW(0i64, L"This application needs at least Windows XP or above to run properly.", L"Explorer++", 0x10u);
    return 0;
  }
  v44[0] = 8;
  v44[1] = 50693;
  sub_14001AB20((__int64)v44);
  OleInitialize(0i64);
  CommandLineW = (__int16 *)GetCommandLineW();
  v8 = sub_14008EC90(CommandLineW);
  if ( !qword_14012DFC0 )
    goto LABEL_43;
  ppidl = 0i64;
  pidl2 = 0i64;
  if ( SHGetFolderLocation(0i64, 3, 0i64, 0, &ppidl) < 0 )
    goto LABEL_43;
  v9 = *(WCHAR **)qword_14012DFB8;
  if ( *(void **)qword_14012DFB8 == qword_14012DFB8 )
    goto LABEL_40;
  do
  {
    if ( *((_QWORD *)v9 + 5) < 8ui64 )
      v10 = (__int64)(v9 + 8);
    else
      v10 = *((_QWORD *)v9 + 2);
    if ( v10 )
      v11 = sub_14007F810(v10, (__int64)&pidl2);
    else
      v11 = -2147467259;
    v12 = 0;
    if ( v11 >= 0 )
    {
      if ( !ILIsParent(ppidl, pidl2, 0) || (unsigned int)sub_14007DCB0((__int64)ppidl, (__int64)pidl2) )
      {
        VersionInformation.dwOSVersionInfoSize = 276;
        if ( !GetVersionExW(&VersionInformation) )
          goto LABEL_36;
        if ( VersionInformation.dwMajorVersion < 6 )
          goto LABEL_36;
        pidl1 = 0i64;
        if ( (int)sub_14007F810((__int64)L"::{26EE0668-A00A-44D7-9371-BEB064C98683}", (__int64)&pidl1) < 0 )
          goto LABEL_36;
        if ( ILIsParent(pidl1, pidl2, 0) && !(unsigned int)sub_14007DCB0((__int64)pidl1, (__int64)pidl2) )
          v12 = 1;
        CoTaskMemFree((LPVOID)pidl1);
        if ( !v12 )
        {
LABEL_36:
          CoTaskMemFree((LPVOID)pidl2);
          if ( v12 )
            continue;
          goto LABEL_37;
        }
      }
      else
      {
        v12 = 1;
      }
      CurrentProcessId = GetCurrentProcessId();
      v14 = OpenProcess(0x400u, 0, CurrentProcessId);
      v15 = v14;
      if ( v14 )
      {
        if ( OpenProcessToken(v14, 0xCu, &TokenHandle) )
        {
          ExpandEnvironmentStringsForUserW(TokenHandle, L"%windir%\\explorer.exe", Dest, 0x104u);
          CloseHandle(TokenHandle);
        }
        CloseHandle(v15);
      }
      if ( *((_QWORD *)v9 + 5) < 8ui64 )
        v16 = v9 + 8;
      else
        v16 = (const WCHAR *)*((_QWORD *)v9 + 2);
      ShellExecuteW(0i64, L"open", Dest, v16, 0i64, 1);
      v17 = *(WCHAR **)v9;
      if ( v9 != qword_14012DFB8 )
      {
        **((_QWORD **)v9 + 1) = v17;
        *(_QWORD *)(*(_QWORD *)v9 + 8i64) = *((_QWORD *)v9 + 1);
        if ( *((_QWORD *)v9 + 5) >= 8ui64 )
          j_free(*((void **)v9 + 2));
        *((_QWORD *)v9 + 5) = 7i64;
        *((_QWORD *)v9 + 4) = 0i64;
        v9[8] = 0;
        j_free(v9);
        --qword_14012DFC0;
      }
      v9 = v17;
      goto LABEL_36;
    }
LABEL_37:
    v9 = *(WCHAR **)v9;
  }
  while ( v9 != qword_14012DFB8 );
  v4 = (HINSTANCE)phkResult;
LABEL_40:
  if ( !qword_14012DFC0 )
    v8 = 1;
  CoTaskMemFree(ppidl);
LABEL_43:
  if ( v8 )
    return 0;
  v18 = sub_1400B0390();
  if ( v18 )
    v19 = sub_140084BE0();
  else
    v19 = sub_1400A4710();
  v20 = v19;
  MutexW = CreateMutexW(0i64, 1, L"Explorer++");
  if ( v20 || GetLastError() != 183 || (WindowW = FindWindowW(L"Explorer++", 0i64), (v23 = WindowW) == 0i64) )
  {
    v32 = sub_14000AF70(L"Riched20.dll");
    if ( (unsigned __int16)sub_14008F2A0(v4) )
    {
      SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)sub_14008EA50);
      v34 = sub_14001A730(
              L"Explorer++",
              L"Explorer++",
              0xCF0000u,
              0x80000000,
              0x80000000,
              0x80000000,
              0x80000000,
              0i64,
              v4,
              0i64);
      if ( v34 )
      {
        if ( v18 )
        {
          v35 = sub_140084E80(&Data);
        }
        else
        {
          v35 = 0;
          if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &phkResult) )
          {
            LODWORD(pidl2) = 44;
            RegQueryValueExW(phkResult, L"Position", 0i64, 0i64, (LPBYTE)&Data, (LPDWORD)&pidl2);
            if ( (_DWORD)pidl2 == 44 && Data.length == 44 )
              v35 = 1;
          }
        }
        if ( !v35 )
        {
          Data.showCmd = nShowCmd;
          *(_QWORD *)&Data.length = 44i64;
          Data.ptMinPosition = 0i64;
          Data.ptMaxPosition = (POINT)-1i64;
          SystemMetrics = GetSystemMetrics(0);
          v37 = GetSystemMetrics(1);
          Data.rcNormalPosition.left = (int)((double)SystemMetrics * 0.02);
          Data.rcNormalPosition.right = Data.rcNormalPosition.left - (int)((double)SystemMetrics * -0.96);
          Data.rcNormalPosition.top = (int)((double)v37 * 0.05);
          Data.rcNormalPosition.bottom = Data.rcNormalPosition.top - (int)((double)v37 * -0.82);
        }
        if ( nShowCmd == 6 || nShowCmd == 2 || nShowCmd == 3 )
          Data.showCmd = nShowCmd;
        SetWindowPlacement(v34, &Data);
        UpdateWindow(v34);
        AcceleratorsW = LoadAcceleratorsW(v4, (LPCWSTR)0x98);
        while ( GetMessageW(&Msg, 0i64, 0, 0) > 0 )
        {
          if ( !IsDialogMessageW(hDlg, &Msg)
            && !(unsigned int)SendMessageW(hWnd, 0x475u, 0i64, (LPARAM)&Msg)
            && !TranslateAcceleratorW(v34, AcceleratorsW, &Msg) )
          {
            TranslateMessage(&Msg);
            DispatchMessageW(&Msg);
          }
          if ( !SendMessageW(hWnd, 0x476u, 0i64, 0i64) )
          {
            DestroyWindow(hWnd);
            hWnd = 0i64;
          }
        }
        FreeLibrary(v32);
        OleUninitialize();
        if ( MutexW )
          CloseHandle(MutexW);
        return Msg.wParam;
      }
      v33 = L"Could not create main window.";
    }
    else
    {
      v33 = L"Could not register class";
    }
    MessageBoxW(0i64, v33, L"Explorer++", 0x10u);
    FreeLibrary(v32);
    OleUninitialize();
    return 0;
  }
  if ( qword_14012DFC0 )
  {
    v24 = qword_14012DFB8;
    v25 = *(_QWORD **)qword_14012DFB8;
    if ( *(void **)qword_14012DFB8 != qword_14012DFB8 )
    {
      do
      {
        v52 = 7i64;
        v51 = 0i64;
        LOWORD(Block[0]) = 0;
        sub_140009610(Block, v25 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
        v26 = Block;
        v27 = 260i64;
        if ( v52 >= 8 )
          v26 = (void **)Block[0];
        v28 = Dest;
        v29 = (char *)v26 - (char *)Dest;
        while ( v27 != -2147483386 )
        {
          v30 = *(WCHAR *)((char *)v28 + v29);
          if ( !v30 )
            break;
          *v28++ = v30;
          if ( !--v27 )
          {
            --v28;
            break;
          }
        }
        v31 = v51;
        *v28 = 0;
        v46 = 2 * v31 + 2;
        v47 = Dest;
        SendMessageW(v23, 0x4Au, 0i64, (LPARAM)&lParam);
        if ( v52 >= 8 )
          j_free(Block[0]);
        v25 = (_QWORD *)*v25;
      }
      while ( v25 != v24 );
    }
  }
  else
  {
    v46 = 0;
    v47 = 0i64;
    SendMessageW(WindowW, 0x4Au, 0i64, (LPARAM)&lParam);
  }
  SetForegroundWindow(v23);
  ShowWindow(v23, 9);
  CloseHandle(MutexW);
  return 0;
}
// 14008F7C7: conditional instruction was optimized away because rdx.8!=0
// 1400EF0C0: using guessed type wchar_t a26ee0668A00a44[41];
// 1400EF178: using guessed type wchar_t aCouldNotRegist[25];
// 14012DFC0: using guessed type __int64 qword_14012DFC0;

//----- (000000014008FB90) ----------------------------------------------------
LRESULT __fastcall sub_14008FB90(__int64 a1)
{
  unsigned __int16 v2; // di
  LPARAM *v3; // r9
  unsigned int v4; // eax
  HWND v5; // rcx
  __int64 lParam[6]; // [rsp+20h] [rbp-78h] BYREF
  int v8; // [rsp+50h] [rbp-48h]
  unsigned int v9; // [rsp+54h] [rbp-44h]
  unsigned int v10; // [rsp+6Ch] [rbp-2Ch]
  unsigned int v11; // [rsp+70h] [rbp-28h]

  if ( *(_DWORD *)(a1 + 60908) )
  {
    v2 = 24;
    v3 = (LPARAM *)(a1 + 61656);
  }
  else
  {
    v2 = 16;
    v3 = (LPARAM *)(a1 + 61648);
  }
  SendMessageW(*(HWND *)(a1 + 176), 0x430u, 0i64, *v3);
  SendMessageW(*(HWND *)(a1 + 176), 0x41Fu, 0i64, v2 | (unsigned __int64)(v2 << 16));
  SendMessageW(*(HWND *)(a1 + 176), 0x421u, 0i64, 0i64);
  v4 = SendMessageW(*(HWND *)(a1 + 176), 0x43Au, 0i64, 0i64);
  v5 = *(HWND *)(a1 + 120);
  lParam[0] = 0x2000000070i64;
  v8 = 0;
  v9 = HIWORD(v4);
  v10 = HIWORD(v4);
  v11 = HIWORD(v4);
  return SendMessageW(v5, 0x40Bu, 0i64, (LPARAM)lParam);
}
// 14008FB90: using guessed type LPARAM lParam[6];

//----- (000000014008FCC0) ----------------------------------------------------
BOOL __fastcall sub_14008FCC0(__int64 a1, HWND a2)
{
  int v4; // esi
  int v5; // er12
  int v6; // edi
  HWND v7; // rcx
  int v8; // er13
  int v9; // ebp
  int cy; // ebp
  struct tagRECT Rect; // [rsp+40h] [rbp-48h] BYREF

  v4 = 0;
  v5 = 0;
  v6 = 0;
  GetClientRect(*(HWND *)(a1 + 104), &Rect);
  v7 = *(HWND *)(a1 + 120);
  v8 = Rect.right - Rect.left;
  v9 = Rect.bottom - Rect.top;
  if ( v7 )
  {
    GetWindowRect(v7, &Rect);
    v6 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 60744) )
  {
    GetWindowRect(*(HWND *)(a1 + 112), &Rect);
    v4 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 60756) )
    v4 += *(_DWORD *)(a1 + 7012);
  if ( *(_DWORD *)(a1 + 60748) )
  {
    GetClientRect(*(HWND *)(a1 + 160), &Rect);
    v5 = Rect.right - Rect.left;
  }
  if ( *(_DWORD *)(a1 + 60780) )
  {
    if ( *(_DWORD *)(a1 + 60888) )
    {
LABEL_14:
      cy = v9 - v6 - v4 - 24;
      return SetWindowPos(a2, 0i64, v5, v6, v8 - v5, cy, 0x84u);
    }
    v6 += 24;
  }
  if ( *(_DWORD *)(a1 + 60888) )
    goto LABEL_14;
  cy = v9 - v6 - v4;
  return SetWindowPos(a2, 0i64, v5, v6, v8 - v5, cy, 0x84u);
}

//----- (000000014008FE00) ----------------------------------------------------
LRESULT __fastcall sub_14008FE00(__int64 a1)
{
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetClientRect(*(HWND *)(a1 + 104), &Rect);
  return SendMessageW(*(HWND *)(a1 + 104), 5u, 0i64, LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
}

//----- (000000014008FE70) ----------------------------------------------------
LRESULT __fastcall sub_14008FE70(__int64 a1, int a2)
{
  HWND v2; // rcx
  _DWORD lParam[4]; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(HWND *)(a1 + 112);
  lParam[2] = a2;
  lParam[0] = (int)((double)a2 * 0.5);
  lParam[1] = (int)((double)a2 * 0.75);
  return SendMessageW(v2, 0x404u, 3ui64, (LPARAM)lParam);
}

//----- (000000014008FEF0) ----------------------------------------------------
LRESULT __fastcall sub_14008FEF0(__int64 a1)
{
  BOOL v2; // eax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(_DWORD *)(a1 + 60748) == 0;
  *(_DWORD *)(a1 + 60748) = v2;
  ShowWindow(*(HWND *)(a1 + 160), v2 ? 5 : 0);
  ShowWindow(*(HWND *)(a1 + 152), *(_DWORD *)(a1 + 60748) != 0 ? 5 : 0);
  SendMessageW(*(HWND *)(a1 + 176), 0x402u, 0xAFCDui64, *(int *)(a1 + 60748));
  GetClientRect(*(HWND *)(a1 + 104), &Rect);
  return SendMessageW(*(HWND *)(a1 + 104), 5u, 0i64, LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
}

//----- (000000014008FFC0) ----------------------------------------------------
__int64 __fastcall sub_14008FFC0(__int64 a1)
{
  __int64 v1; // rax
  int v2; // er8
  char v3; // al
  int v4; // er8
  __int64 v5; // r9
  int v6; // eax
  __int64 v7; // r9
  unsigned __int64 v8; // rdx
  _WORD *v9; // rcx
  __int64 v10; // r8
  unsigned __int64 v11; // r8
  char *v12; // r9
  __int16 v13; // ax
  __int64 result; // rax

  v1 = *(int *)(a1 + 24);
  if ( (int)v1 < 0 || (unsigned int)v1 >= 0x14 )
    return 0i64;
  v2 = dword_1400EF1F0[v1];
  *(_BYTE *)(a1 + 40) = 4;
  v3 = sub_1400BC5B0(v2);
  *(_DWORD *)(v5 + 36) = v4;
  *(_BYTE *)(v5 + 41) = v3 | 0x10;
  v6 = sub_1400BC640(v4);
  v8 = *(int *)(v7 + 64);
  v9 = *(_WORD **)(v7 + 72);
  *(_DWORD *)(v7 + 32) = v6;
  *(_QWORD *)(v7 + 48) = 0i64;
  *(_QWORD *)(v7 + 56) = v10 - 45002;
  if ( v8 && v8 <= 0x7FFFFFFF )
  {
    v11 = 2147483646 - v8;
    v12 = (char *)(&unk_14012ED10 - (_UNKNOWN *)v9);
    while ( v11 + v8 )
    {
      v13 = *(_WORD *)((char *)v9 + (_QWORD)v12);
      if ( !v13 )
        break;
      *v9++ = v13;
      if ( !--v8 )
      {
        result = 1i64;
        *(v9 - 1) = 0;
        return result;
      }
    }
    *v9 = 0;
  }
  return 1i64;
}
// 140090077: conditional instruction was optimized away because rdx.8!=0
// 14008FFF7: variable 'v4' is possibly undefined
// 14008FFF7: variable 'v5' is possibly undefined
// 140090006: variable 'v7' is possibly undefined
// 140090015: variable 'v10' is possibly undefined
// 1400EF1F0: using guessed type _DWORD dword_1400EF1F0[20];

//----- (00000001400900A0) ----------------------------------------------------
HRESULT __fastcall sub_1400900A0(__int64 a1)
{
  IDataObject *v2; // rbx
  HRESULT result; // eax
  IDropSource *v4; // rdi
  ITEMIDLIST *v5; // r13
  HGLOBAL v6; // r14
  _DWORD *v7; // rsi
  __int64 v8; // r11
  __int64 v9; // rdx
  __int16 *v10; // rcx
  __int64 v11; // rcx
  __int16 *v12; // rax
  __int64 v13; // rdx
  char *v14; // r9
  __int16 v15; // r8
  _WORD *v16; // rcx
  __int16 v17; // ax
  HGLOBAL v18; // rsi
  IStream *v19; // rax
  LPVOID v20; // [rsp+38h] [rbp-D0h] BYREF
  LPSTREAM ppstm; // [rsp+40h] [rbp-C8h] BYREF
  LPVOID ppv; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v23; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v24; // [rsp+58h] [rbp-B0h] BYREF
  DWORD pdwEffect; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v26[2]; // [rsp+68h] [rbp-A0h] BYREF
  int v27; // [rsp+78h] [rbp-90h]
  int v28; // [rsp+7Ch] [rbp-8Ch]
  int v29; // [rsp+80h] [rbp-88h]
  __int16 v30; // [rsp+88h] [rbp-80h]
  __int64 v31; // [rsp+90h] [rbp-78h]
  int v32; // [rsp+98h] [rbp-70h]
  int v33; // [rsp+9Ch] [rbp-6Ch]
  int v34; // [rsp+A0h] [rbp-68h]
  __int64 v35[3]; // [rsp+A8h] [rbp-60h] BYREF
  int v36; // [rsp+C0h] [rbp-48h]
  HGLOBAL v37; // [rsp+C8h] [rbp-40h]
  __int64 v38; // [rsp+D0h] [rbp-38h]
  __int64 v39; // [rsp+D8h] [rbp-30h]
  __int16 pszBuf[264]; // [rsp+E8h] [rbp-20h] BYREF
  WCHAR v41[264]; // [rsp+2F8h] [rbp+1F0h] BYREF

  v39 = -2i64;
  v2 = 0i64;
  ppv = 0i64;
  result = CoCreateInstance(&rclsid, 0i64, 0x17u, &riid, &ppv);
  if ( result >= 0 )
  {
    v4 = (IDropSource *)operator new(0x10ui64);
    if ( v4 )
    {
      v4->lpVtbl = (struct IDropSourceVtbl *)&CDropSource::`vftable';
      v4[1].lpVtbl = (struct IDropSourceVtbl *)1;
    }
    else
    {
      v4 = 0i64;
    }
    v5 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
    LOWORD(v26[0]) = RegisterClipboardFormatW(L"FileGroupDescriptorW");
    v29 = 1;
    v28 = -1;
    v27 = 1;
    v26[1] = 0i64;
    v6 = GlobalAlloc(2u, 0x3E8ui64);
    v7 = GlobalLock(v6);
    *v7 = 1;
    v7[1] = 68;
    v7[10] = 128;
    v7[18] = 0x4000;
    v7[17] = 0;
    sub_14007E270(v5, (LPWSTR)pszBuf, 1u);
    v8 = 260i64;
    v9 = 260i64;
    v10 = pszBuf;
    while ( *v10 )
    {
      ++v10;
      if ( !--v9 )
        goto LABEL_15;
    }
    v11 = v9;
    v12 = &pszBuf[260 - v9];
    v13 = 0x7FFFFFFFi64;
    v14 = (char *)((char *)L".lnk" - (char *)v12);
    while ( v13 )
    {
      v15 = *(__int16 *)((char *)v12 + (_QWORD)v14);
      if ( !v15 )
        break;
      *v12++ = v15;
      --v13;
      if ( !--v11 )
      {
        --v12;
        break;
      }
    }
    *v12 = 0;
LABEL_15:
    v16 = v7 + 19;
    while ( v8 != -2147483386 )
    {
      v17 = *(_WORD *)((char *)v16 + (char *)pszBuf - (char *)(v7 + 19));
      if ( !v17 )
        break;
      *v16++ = v17;
      if ( !--v8 )
      {
        --v16;
        break;
      }
    }
    *v16 = 0;
    GlobalUnlock(v6);
    v35[2] = 0i64;
    v35[1] = (__int64)v6;
    LODWORD(v35[0]) = 1;
    v30 = RegisterClipboardFormatW(L"FileContents");
    v34 = 1;
    v33 = -1;
    v32 = 1;
    v31 = 0i64;
    v18 = GlobalAlloc(2u, 0x4000ui64);
    v20 = 0i64;
    v24 = 0i64;
    if ( CoCreateInstance(&stru_1400E40A0, 0i64, 1u, &stru_1400E3FE0, &v20) >= 0 )
    {
      sub_14007E270(v5, v41, 0x8000u);
      (*(void (__fastcall **)(LPVOID, WCHAR *))(*(_QWORD *)v20 + 160i64))(v20, v41);
      if ( (**(int (__fastcall ***)(LPVOID, void *, __int64 *))v20)(v20, &unk_1400E4170, &v24) >= 0 )
      {
        ppstm = 0i64;
        CreateStreamOnHGlobal(v18, 0, &ppstm);
        (*(void (__fastcall **)(__int64, LPSTREAM, __int64))(*(_QWORD *)v24 + 48i64))(v24, ppstm, 1i64);
      }
    }
    GlobalUnlock(v18);
    v38 = 0i64;
    v37 = v18;
    v36 = 1;
    v23 = 0i64;
    v19 = (IStream *)operator new(0x38ui64);
    ppstm = v19;
    if ( v19 )
      v2 = (IDataObject *)sub_140078EE0((__int64)v19, v26, v35);
    (*(void (__fastcall **)(LPVOID, _QWORD, __int64 *, IDataObject *))(*(_QWORD *)ppv + 32i64))(
      ppv,
      *(_QWORD *)(a1 + 168),
      &v23,
      v2);
    DoDragDrop(v2, v4, 4u, &pdwEffect);
    CoTaskMemFree(v5);
    ((void (__fastcall *)(IDataObject *))v2->lpVtbl->Release)(v2);
    ((void (__fastcall *)(IDropSource *))v4->lpVtbl->Release)(v4);
    return (*(__int64 (__fastcall **)(LPVOID))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  return result;
}
// 1400901E6: conditional instruction was optimized away because rdx.8!=0
// 1400901F9: conditional instruction was optimized away because rdx.8!=0
// 140090235: conditional instruction was optimized away because rcx.8!=0
// 140090276: conditional instruction was optimized away because r11.8!=0
// 1400EF370: using guessed type wchar_t aLnk_1[5];
// 1400F7068: using guessed type void *CDropSource::`vftable';
// 1400900A0: using guessed type WCHAR pszBuf[264];

//----- (0000000140090450) ----------------------------------------------------
void __fastcall sub_140090450(__int64 a1, char *a2)
{
  unsigned __int64 v2; // r9
  _WORD *v3; // r8
  char *v4; // rdi
  unsigned __int64 v6; // rcx
  __int16 v7; // ax
  int v8; // eax
  const ITEMIDLIST *v9; // rax
  unsigned __int64 v10; // r11
  char *v11; // rcx
  unsigned __int64 v12; // rbx
  signed __int64 v13; // rdx
  __int16 v14; // ax
  const ITEMIDLIST *v15; // rax
  unsigned __int64 v16; // r11
  char *v17; // rcx
  unsigned __int64 v18; // rbx
  signed __int64 v19; // rdx
  __int16 v20; // ax
  int v21; // eax
  int v22; // eax
  HRESULT v23; // ebx
  int v24; // eax
  LPVOID pv; // [rsp+30h] [rbp-D0h] BYREF
  LPARAM lParam[2]; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v27; // [rsp+48h] [rbp-B8h]
  char v28[1540]; // [rsp+60h] [rbp-A0h] BYREF
  int v29; // [rsp+664h] [rbp+564h]
  char v30[536]; // [rsp+668h] [rbp+568h] BYREF
  WCHAR pszBuf[264]; // [rsp+880h] [rbp+780h] BYREF
  __int16 v32[1024]; // [rsp+A90h] [rbp+990h] BYREF

  v2 = *((int *)a2 + 8);
  v3 = (_WORD *)*((_QWORD *)a2 + 3);
  v4 = a2;
  if ( *((_DWORD *)a2 + 8) && v2 <= 0x7FFFFFFF )
  {
    v6 = 2147483646 - v2;
    a2 = (char *)(&unk_1400EB8AC - (_UNKNOWN *)v3);
    while ( v6 + v2 )
    {
      v7 = *(_WORD *)((char *)v3 + (_QWORD)a2);
      if ( !v7 )
        break;
      *v3++ = v7;
      if ( !--v2 )
        goto LABEL_9;
    }
    if ( v2 )
      goto LABEL_10;
LABEL_9:
    --v3;
LABEL_10:
    *v3 = 0;
  }
  v8 = *((_DWORD *)v4 + 9);
  if ( v8 == 45002 )
  {
    if ( (*(unsigned int (__fastcall **)(_QWORD, char *, _WORD *))(**(_QWORD **)(a1 + 2640) + 136i64))(
           *(_QWORD *)(a1 + 2640),
           a2,
           v3) )
    {
      v9 = (const ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 2640) + 168i64))(
                                 *(_QWORD *)(a1 + 2640),
                                 0xFFFFFFFFi64);
      sub_14007E270(v9, pszBuf, 1u);
      sub_140001000((wchar_t *)v32, 0x400ui64, L"Back to %s", pszBuf);
      v10 = *((int *)v4 + 8);
      v11 = (char *)*((_QWORD *)v4 + 3);
      if ( *((_DWORD *)v4 + 8) )
      {
        if ( v10 <= 0x7FFFFFFF )
        {
          v12 = 2147483646 - v10;
          v13 = (char *)v32 - v11;
          while ( v12 + v10 )
          {
            v14 = *(_WORD *)&v11[v13];
            if ( !v14 )
              break;
            *(_WORD *)v11 = v14;
            v11 += 2;
            if ( !--v10 )
            {
              *((_WORD *)v11 - 1) = 0;
              return;
            }
          }
          if ( !v10 )
            v11 -= 2;
          *(_WORD *)v11 = 0;
        }
      }
    }
  }
  else if ( v8 == 45003 )
  {
    if ( (*(unsigned int (__fastcall **)(_QWORD, char *, _WORD *))(**(_QWORD **)(a1 + 2640) + 144i64))(
           *(_QWORD *)(a1 + 2640),
           a2,
           v3) )
    {
      v15 = (const ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 2640) + 168i64))(
                                  *(_QWORD *)(a1 + 2640),
                                  1i64);
      sub_14007E270(v15, pszBuf, 1u);
      sub_140001000((wchar_t *)v32, 0x400ui64, L"Forward to %s", pszBuf);
      v16 = *((int *)v4 + 8);
      v17 = (char *)*((_QWORD *)v4 + 3);
      if ( *((_DWORD *)v4 + 8) )
      {
        if ( v16 <= 0x7FFFFFFF )
        {
          v18 = 2147483646 - v16;
          v19 = (char *)v32 - v17;
          while ( v18 + v16 )
          {
            v20 = *(_WORD *)&v17[v19];
            if ( !v20 )
              break;
            *(_WORD *)v17 = v20;
            v17 += 2;
            if ( !--v16 )
            {
              *((_WORD *)v17 - 1) = 0;
              return;
            }
          }
          if ( !v16 )
            v17 -= 2;
          *(_WORD *)v17 = 0;
        }
      }
    }
  }
  else
  {
    if ( v8 < 49000 )
    {
      if ( v8 < 47000 )
      {
        if ( v8 < 46000 )
          return;
        v24 = SendMessageW(*(HWND *)(a1 + 1008), 0x419u, *((int *)v4 + 9), 0i64);
        if ( v24 == -1 )
          return;
        SendMessageW(*(HWND *)(a1 + 1008), 0x417u, v24, (LPARAM)lParam);
        sub_14007D720(v27, (__int64)v28);
        if ( v29 != 1 )
          return;
        sub_140001000((wchar_t *)v32, 0x400ui64, L"%s\n%s", v28, v30);
      }
      else
      {
        v22 = SendMessageW(*(HWND *)(a1 + 1016), 0x419u, *((int *)v4 + 9), 0i64);
        if ( v22 == -1 )
          return;
        if ( !SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v22, (LPARAM)lParam) )
          return;
        pv = 0i64;
        if ( !v27 )
          return;
        if ( (int)sub_14007F810(v27, (__int64)&pv) < 0 )
          return;
        v23 = sub_140081FD0((const ITEMIDLIST *)pv, v32);
        CoTaskMemFree(pv);
        if ( v23 < 0 )
          return;
      }
      sub_140001240(*((_WORD **)v4 + 3), *((int *)v4 + 8), (__int64)v32);
      return;
    }
    v21 = SendMessageW(*(HWND *)(a1 + 1024), 0x419u, *((int *)v4 + 9), 0i64);
    if ( v21 != -1 && SendMessageW(*(HWND *)(a1 + 1024), 0x417u, v21, (LPARAM)lParam) )
      sub_140001000(*((wchar_t **)v4 + 3), *((int *)v4 + 8), L"%s\n%s");
  }
}
// 1400EF2E8: using guessed type wchar_t aBackToS[11];
// 1400EF300: using guessed type wchar_t aForwardToS[14];
// 1400EF320: using guessed type wchar_t aSS_4[6];
// 1400EF330: using guessed type wchar_t aSS_5[6];
// 140090450: using guessed type wchar_t var_820[1024];
// 140090450: using guessed type char var_C48[536];

//----- (0000000140090870) ----------------------------------------------------
void __fastcall sub_140090870(__int64 a1)
{
  unsigned int v2; // ebx
  char *v3; // rax
  _QWORD *v4; // rdx
  _QWORD *v5; // r8
  char *v6; // rsi
  char *v7; // r9
  int v8; // ecx
  int v9; // eax
  _BYTE *v10; // r9
  __int64 v11; // r8
  int v12; // eax
  char v13; // al

  v2 = 0;
  v3 = (char *)malloc(32i64 * *(_QWORD *)(a1 + 62080));
  v4 = *(_QWORD **)(a1 + 62072);
  v5 = (_QWORD *)*v4;
  v6 = v3;
  if ( (_QWORD *)*v4 != v4 )
  {
    v7 = v3 + 8;
    do
    {
      if ( (unsigned __int64)v2 < *(_QWORD *)(a1 + 62080) )
      {
        v8 = *((_DWORD *)v5 + 4);
        if ( v8 == 45001 )
        {
          *((_QWORD *)v7 - 1) = 0i64;
          *(_WORD *)v7 = 260;
          *((_QWORD *)v7 + 1) = 0i64;
          *((_QWORD *)v7 + 2) = 0i64;
        }
        else
        {
          v9 = sub_1400BC640(v8);
          *((_DWORD *)v10 - 2) = v9;
          v12 = *(_DWORD *)(v11 + 16);
          *v10 = 4;
          *((_DWORD *)v10 - 1) = v12;
          v13 = sub_1400BC5B0(*(_DWORD *)(v11 + 16));
          *((_QWORD *)v7 + 1) = 0i64;
          v7[1] = v13 | 0x10;
          *((_QWORD *)v7 + 2) = *((int *)v5 + 4) - 45002i64;
        }
        ++v2;
        v7 += 32;
      }
      v5 = (_QWORD *)*v5;
    }
    while ( v5 != *(_QWORD **)(a1 + 62072) );
  }
  SendMessageW(*(HWND *)(a1 + 176), 0x444u, v2, (LPARAM)v6);
  free(v6);
}
// 1400908E1: variable 'v10' is possibly undefined
// 1400908E5: variable 'v11' is possibly undefined
// 1400908FA: variable 'v7' is possibly undefined
// 140090904: variable 'v5' is possibly undefined

//----- (0000000140090960) ----------------------------------------------------
void __fastcall sub_140090960(__int64 a1)
{
  HWND v2; // rax
  bool v3; // zf
  unsigned __int16 v4; // dx
  LPARAM *v5; // rdi
  HWND v6; // rcx
  LPARAM lParam[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = sub_14007CD30(*(HWND *)(a1 + 120), 0x54009964u, 153i64);
  v3 = *(_DWORD *)(a1 + 60908) == 0;
  *(_QWORD *)(a1 + 176) = v2;
  if ( v3 )
  {
    v4 = 16;
    v5 = (LPARAM *)(a1 + 61648);
  }
  else
  {
    v4 = 24;
    v5 = (LPARAM *)(a1 + 61656);
  }
  SendMessageW(v2, 0x420u, 0i64, v4 | (v4 << 16));
  SendMessageW(*(HWND *)(a1 + 176), 0x41Eu, 0x20ui64, 0i64);
  SendMessageW(*(HWND *)(a1 + 176), 0x430u, 0i64, *v5);
  sub_1400BC840(a1);
  sub_140090870(a1);
  if ( !*(_DWORD *)(a1 + 7096) )
  {
    if ( *(_DWORD *)(a1 + 7032) )
    {
      v6 = *(HWND *)(a1 + 176);
      lParam[1] = (LPARAM)L"Software\\Explorer++\\Settings";
      lParam[0] = -2147483647i64;
      lParam[2] = (LPARAM)L"ToolbarState";
      SendMessageW(v6, 0x44Cu, 0i64, (LPARAM)lParam);
    }
  }
}
// 1400EF288: using guessed type wchar_t aSoftwareExplor_1[29];
// 1400EF2C8: using guessed type wchar_t aToolbarstate_0[13];

//----- (0000000140090A70) ----------------------------------------------------
LRESULT __fastcall sub_140090A70(__int64 a1)
{
  int v2; // ebx
  WPARAM v3; // rdi

  v2 = SendMessageW(*(HWND *)(a1 + 176), 0x418u, 0i64, 0i64) - 1;
  if ( v2 >= 0 )
  {
    v3 = v2;
    do
    {
      SendMessageW(*(HWND *)(a1 + 176), 0x416u, v3--, 0i64);
      --v2;
    }
    while ( v2 >= 0 );
  }
  sub_140090870(a1);
  return sub_1400BD730(a1);
}

//----- (0000000140090B00) ----------------------------------------------------
__int64 __fastcall sub_140090B00(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, LPARAM a5)
{
  if ( a3 == 7 )
  {
    sub_1400BD730(a1);
  }
  else if ( a3 == 256 )
  {
    if ( a4 == 13 )
    {
      SendMessageW(*(HWND *)(a1 + 104), 0x8002u, 0xDui64, 0i64);
      return 0i64;
    }
  }
  else if ( a3 == 522 && (unsigned int)sub_140095060(a1, 2, a4, a5) )
  {
    return 0i64;
  }
  return sub_140001A20(a2, a3, a4, a5);
}

//----- (0000000140090BB0) ----------------------------------------------------
__int64 __fastcall sub_140090BB0(__int64 a1, unsigned int a2, __int64 a3, LPARAM a4, int a5, __int64 a6)
{
  return sub_140090B00(a6, a1, a2, a3, a4);
}

//----- (0000000140090BE0) ----------------------------------------------------
HWND __fastcall sub_140090BE0(HWND a1, int a2, __int64 a3)
{
  HWND v5; // r13
  __int64 v6; // rsi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  int v9; // edi
  LPARAM lParam; // [rsp+30h] [rbp-58h] BYREF
  __int16 v12; // [rsp+38h] [rbp-50h]
  __int64 v13; // [rsp+40h] [rbp-48h]
  __int64 v14; // [rsp+48h] [rbp-40h]

  v5 = sub_14007CD30(a1, 0x5400994Cu, 136i64);
  SendMessageW(v5, 0x420u, 0i64, 458759i64);
  SendMessageW(v5, 0x41Eu, 0x20ui64, 0i64);
  v6 = sub_1400016D0(7u, 7u, 0x21u, 0, 2);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0x66);
  v9 = sub_1400012C0(v6, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(v5, 0x430u, 0i64, v6);
  LODWORD(lParam) = v9;
  HIDWORD(lParam) = a2;
  v12 = 4100;
  v13 = 0i64;
  v14 = a3;
  SendMessageW(v5, 0x444u, 1ui64, (LPARAM)&lParam);
  SendMessageW(v5, 0x41Fu, 0i64, 1048592i64);
  SendMessageW(v5, 0x421u, 0i64, 0i64);
  return v5;
}

//----- (0000000140090D40) ----------------------------------------------------
HRESULT __fastcall sub_140090D40(__int64 a1)
{
  HWND v2; // rax
  IDropTarget *v3; // rax

  v2 = sub_14007CD30(*(HWND *)(a1 + 120), 0x56009944u, 153i64);
  *(_QWORD *)(a1 + 1008) = v2;
  sub_140009C20((__int64)v2, (__int64)sub_1400CB8D0, 0i64, a1);
  SendMessageW(*(HWND *)(a1 + 1008), 0x420u, 0i64, 1048592i64);
  SendMessageW(*(HWND *)(a1 + 1008), 0x41Eu, 0x20ui64, 0i64);
  v3 = (IDropTarget *)operator new(0x30ui64);
  if ( v3 )
    v3 = (IDropTarget *)sub_1400C9FF0(v3, a1);
  return RegisterDragDrop(*(HWND *)(a1 + 1008), v3);
}

//----- (0000000140090E00) ----------------------------------------------------
HRESULT __fastcall sub_140090E00(__int64 a1)
{
  HWND hWndParent; // rbx
  HMODULE hInstance; // rax
  HWND v4; // rbx
  HIMAGELIST phimlSmall; // [rsp+70h] [rbp+8h] BYREF

  hWndParent = *(HWND *)(a1 + 1000);
  hInstance = GetModuleHandleW(0i64);
  *(_QWORD *)(a1 + 168) = CreateWindowExW(
                            0x80u,
                            L"ComboBoxEx32",
                            &word_1400EA7EC,
                            0x56010042u,
                            0,
                            0,
                            0,
                            200,
                            hWndParent,
                            0i64,
                            hInstance,
                            0i64);
  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(*(HWND *)(a1 + 168), 0x402u, 0i64, (LPARAM)phimlSmall);
  v4 = (HWND)SendMessageW(*(HWND *)(a1 + 168), 0x407u, 0i64, 0i64);
  sub_140009C20((__int64)v4, (__int64)sub_140090BB0, 0i64, a1);
  return SHAutoComplete(v4, 0x10000001u);
}

//----- (0000000140090EF0) ----------------------------------------------------
LRESULT __fastcall sub_140090EF0(__int64 a1)
{
  HWND v2; // rax
  __int64 v3; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  HWND v6; // rcx
  LPARAM lParam; // [rsp+30h] [rbp-98h] BYREF
  __int16 v9; // [rsp+38h] [rbp-90h]
  __int64 v10; // [rsp+40h] [rbp-88h]
  __int64 v11; // [rsp+48h] [rbp-80h]
  int v12; // [rsp+50h] [rbp-78h]
  int v13; // [rsp+54h] [rbp-74h]
  __int16 v14; // [rsp+58h] [rbp-70h]
  __int64 v15; // [rsp+60h] [rbp-68h]
  WCHAR *v16; // [rsp+68h] [rbp-60h]
  WCHAR Buffer[32]; // [rsp+70h] [rbp-58h] BYREF

  v2 = sub_14007CD30(*(HWND *)(a1 + 120), 0x56009944u, 136i64);
  *(_QWORD *)(a1 + 1000) = v2;
  SendMessageW(v2, 0x420u, 0i64, 1048592i64);
  SendMessageW(*(HWND *)(a1 + 1000), 0x41Eu, 0x20ui64, 0i64);
  v3 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 1);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xC2);
  sub_1400012C0(v3, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(*(HWND *)(a1 + 1000), 0x430u, 0i64, v3);
  lParam = 0i64;
  v9 = 260;
  v10 = 0i64;
  v11 = 0i64;
  LoadStringW(hInstance, 0x1F6Fu, Buffer, 32);
  v6 = *(HWND *)(a1 + 1000);
  v12 = 0;
  v13 = 48000;
  v16 = Buffer;
  v14 = 4100;
  v15 = 0i64;
  return SendMessageW(v6, 0x444u, 2ui64, (LPARAM)&lParam);
}

//----- (0000000140091070) ----------------------------------------------------
void __fastcall sub_140091070(__int64 a1)
{
  HWND v2; // rax

  v2 = sub_14007CD30(*(HWND *)(a1 + 120), 0x56009944u, 144i64);
  *(_QWORD *)(a1 + 1016) = v2;
  sub_140009C20((__int64)v2, (__int64)sub_1400C55D0, 0i64, a1);
  SendMessageW(*(HWND *)(a1 + 1016), 0x420u, 0i64, 1048592i64);
  SendMessageW(*(HWND *)(a1 + 1016), 0x41Eu, 0x20ui64, 0i64);
  sub_1400C51C0(a1);
}

//----- (00000001400910F0) ----------------------------------------------------
__int64 __fastcall sub_1400910F0(__int64 a1, __int64 a2, unsigned int a3, WPARAM a4, LPARAM lParam)
{
  HWND v10; // rax
  HWND v11; // rcx
  WPARAM v12; // r8
  int v13; // eax
  HWND v14; // rcx
  WPARAM v15; // r8
  int v16; // eax
  _QWORD *v17; // rax
  _QWORD *v18; // rdi
  void **v19; // rax
  __int64 v20; // rbx
  char KeyState; // al
  _QWORD *v22; // rcx
  _QWORD *v23; // rbx
  HWND v24; // rcx
  WPARAM v25; // r8
  DWORD MessagePos; // eax
  LPVOID pv; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v28; // [rsp+48h] [rbp-B8h] BYREF
  char *v29; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD **v30[3]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 pExceptionObject[4]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v32; // [rsp+90h] [rbp-70h] BYREF
  int v33; // [rsp+98h] [rbp-68h]
  void *Block[3]; // [rsp+A8h] [rbp-58h] BYREF
  char v35; // [rsp+C0h] [rbp-40h]
  DWORD_PTR dwRefData[12]; // [rsp+D0h] [rbp-30h] BYREF
  __int64 *v37; // [rsp+130h] [rbp+30h] BYREF
  __int64 v38[2]; // [rsp+148h] [rbp+48h] BYREF
  __int64 v39; // [rsp+158h] [rbp+58h]

  pExceptionObject[3] = -2i64;
  if ( a3 != 78 )
  {
    if ( a3 == 278 )
    {
      SendMessageW(*(HWND *)(a1 + 104), 0x116u, a4, lParam);
    }
    else if ( a3 == 287 )
    {
      SendMessageW(*(HWND *)(a1 + 104), 0x11Fu, a4, lParam);
    }
    return sub_140001A20(a2, a3, a4, lParam);
  }
  if ( *(_DWORD *)(lParam + 16) != -5 )
    return sub_140001A20(a2, a3, a4, lParam);
  v10 = *(HWND *)lParam;
  v11 = *(HWND *)(a1 + 1008);
  if ( *(HWND *)lParam != v11 )
  {
    v14 = *(HWND *)(a1 + 1016);
    if ( v10 == v14 )
    {
      v15 = *(_QWORD *)(lParam + 24);
      if ( v15 != -1i64 )
      {
        v16 = SendMessageW(v14, 0x419u, v15, 0i64);
        if ( v16 != -1 )
        {
          if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v16, (LPARAM)v38) )
          {
            pv = 0i64;
            if ( v39 )
            {
              if ( (int)sub_14007F810(v39, (__int64)&pv) >= 0 )
              {
                ClientToScreen(*(HWND *)(a1 + 1016), (LPPOINT)(lParam + 40));
                v30[1] = 0i64;
                v17 = operator new(0x18ui64);
                v18 = v17;
                if ( !v17 )
                {
                  v29 = 0i64;
                  std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v29);
                  pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
                  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
                }
                v30[0] = (_QWORD **)v17;
                *v17 = v17;
                v17[1] = v17;
                v19 = (void **)sub_14000B220(&v37, v30);
                sub_1400D2390(dwRefData, *(void **)(a1 + 1016), (const ITEMIDLIST *)pv, v19);
                LODWORD(v28) = 3;
                v20 = *(_QWORD *)(a1 + 112);
                sub_14000A5B0(Block);
                v32 = v20;
                v35 = 0;
                v33 = 0;
                KeyState = GetKeyState(16);
                if ( dwRefData[3] )
                  sub_1400D2910(
                    (DWORD_PTR)dwRefData,
                    a1 + 40,
                    (int *)(lParam + 40),
                    (__int64)&v32,
                    (__int64)&v28,
                    0,
                    KeyState & 0x80);
                CoTaskMemFree(pv);
                sub_14000A630((__int64)Block);
                j_free(Block[0]);
                sub_1400D22C0(dwRefData);
                v22 = (_QWORD *)*v18;
                *v18 = v18;
                v18[1] = v18;
                if ( v22 != v18 )
                {
                  do
                  {
                    v23 = (_QWORD *)*v22;
                    j_free(v22);
                    v22 = v23;
                  }
                  while ( v23 != v18 );
                }
                j_free(v18);
              }
            }
          }
        }
        return 1i64;
      }
    }
    else
    {
      v24 = *(HWND *)(a1 + 1024);
      if ( v10 == v24 )
      {
        v25 = *(_QWORD *)(lParam + 24);
        if ( v25 == -1i64 )
        {
          sub_1400CCC60(a1);
        }
        else
        {
          *(_DWORD *)(a1 + 62064) = SendMessageW(v24, 0x419u, v25, 0i64);
          SetFocus(*(HWND *)(a1 + 1024));
          MessagePos = GetMessagePos();
          TrackPopupMenu(
            *(HMENU *)(a1 + 4896),
            0,
            (__int16)MessagePos,
            SHIWORD(MessagePos),
            0,
            *(HWND *)(a1 + 120),
            0i64);
        }
        return 1i64;
      }
    }
    goto LABEL_28;
  }
  v12 = *(_QWORD *)(lParam + 24);
  if ( v12 == -1i64 )
  {
LABEL_28:
    sub_1400AFF90(a1);
    return 1i64;
  }
  v13 = SendMessageW(v11, 0x419u, v12, 0i64);
  sub_1400AFF20(a1, v13);
  return 1i64;
}
// 1400D22C0: using guessed type __int64 __fastcall sub_1400D22C0(_QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400910F0: using guessed type LPARAM var_58[2];

//----- (0000000140091440) ----------------------------------------------------
__int64 __fastcall sub_140091440(__int64 a1, unsigned int a2, WPARAM a3, LPARAM a4, int a5, __int64 a6)
{
  return sub_1400910F0(a6, a1, a2, a3, a4);
}

//----- (0000000140091470) ----------------------------------------------------
LRESULT __fastcall sub_140091470(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HWND v3; // rax
  unsigned int *v4; // rbx
  LPARAM v5; // rsi
  __int64 v6; // rbp
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // eax
  int v12; // eax
  __int64 v13; // rax
  unsigned int v14; // eax
  int v15; // eax
  unsigned int v16; // eax
  int v17; // eax
  unsigned int v18; // eax
  int v19; // eax
  LRESULT result; // rax
  int lParam[4]; // [rsp+50h] [rbp-68h] BYREF
  WCHAR Buffer[32]; // [rsp+60h] [rbp-58h] BYREF

  if ( *(_DWORD *)(a1 + 60820) )
    dword_14011F58C |= 0x800u;
  ModuleHandleW = GetModuleHandleW(0i64);
  v3 = sub_14001A730(
         L"ReBarWindow32",
         &word_1400EB87C,
         dword_14011F58C,
         0,
         0,
         0,
         0,
         *(HWND *)(a1 + 104),
         ModuleHandleW,
         0i64);
  *(_QWORD *)(a1 + 120) = v3;
  sub_140009C20((__int64)v3, (__int64)sub_140091440, 0i64, a1);
  v4 = (unsigned int *)(a1 + 61140);
  v5 = a1 + 61088;
  v6 = 5i64;
  do
  {
    v7 = v4[5];
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          v10 = v9 - 1;
          if ( v10 )
          {
            if ( v10 != 1 )
              goto LABEL_23;
            sub_1400CD550(a1);
            v11 = (unsigned int)SendMessageW(*(HWND *)(a1 + 1024), 0x43Au, 0i64, 0i64) >> 16;
            *v4 = v11;
            v4[7] = v11;
            v4[6] = v11;
            SendMessageW(*(HWND *)(a1 + 1024), 0x453u, 0i64, (LPARAM)lParam);
            v12 = lParam[0];
            if ( !v4[1] )
              v4[1] = lParam[0];
            v4[9] = v12;
            v13 = *(_QWORD *)(a1 + 1024);
          }
          else
          {
            sub_140091070(a1);
            v14 = (unsigned int)SendMessageW(*(HWND *)(a1 + 1016), 0x43Au, 0i64, 0i64) >> 16;
            *v4 = v14;
            v4[7] = v14;
            v4[6] = v14;
            SendMessageW(*(HWND *)(a1 + 1016), 0x453u, 0i64, (LPARAM)lParam);
            v15 = lParam[0];
            if ( !v4[1] )
              v4[1] = lParam[0];
            v4[9] = v15;
            v13 = *(_QWORD *)(a1 + 1016);
          }
        }
        else
        {
          sub_140090D40(a1);
          v16 = (unsigned int)SendMessageW(*(HWND *)(a1 + 1008), 0x43Au, 0i64, 0i64) >> 16;
          *v4 = v16;
          v4[7] = v16;
          v4[6] = v16;
          SendMessageW(*(HWND *)(a1 + 1008), 0x453u, 0i64, (LPARAM)lParam);
          v17 = lParam[0];
          if ( !v4[1] )
            v4[1] = lParam[0];
          v4[9] = v17;
          v13 = *(_QWORD *)(a1 + 1008);
        }
      }
      else
      {
        sub_140090EF0(a1);
        sub_140090E00(a1);
        LoadStringW(hInstance, 0x1F6Eu, Buffer, 32);
        *v4 = (unsigned int)SendMessageW(*(HWND *)(a1 + 1000), 0x43Au, 0i64, 0i64) >> 16;
        *(_QWORD *)(v4 - 7) = Buffer;
        v13 = *(_QWORD *)(a1 + 1000);
      }
    }
    else
    {
      sub_140090960(a1);
      v18 = (unsigned int)SendMessageW(*(HWND *)(a1 + 176), 0x43Au, 0i64, 0i64) >> 16;
      *v4 = v18;
      v4[7] = v18;
      v4[6] = v18;
      SendMessageW(*(HWND *)(a1 + 176), 0x453u, 0i64, (LPARAM)lParam);
      v19 = lParam[0];
      if ( !v4[1] )
        v4[1] = lParam[0];
      v4[9] = v19;
      v13 = *(_QWORD *)(a1 + 176);
    }
    *(_QWORD *)(v4 - 3) = v13;
LABEL_23:
    *(v4 - 13) = 112;
    result = SendMessageW(*(HWND *)(a1 + 120), 0x40Au, 0xFFFFFFFFFFFFFFFFui64, v5);
    v5 += 112i64;
    v4 += 28;
    --v6;
  }
  while ( v6 );
  return result;
}
// 140091470: using guessed type _DWORD lParam[4];

//----- (0000000140091790) ----------------------------------------------------
HWND __fastcall sub_140091790(__int64 a1)
{
  DWORD v2; // edi
  HWND hWndParent; // rbx
  HMODULE hInstance; // rax
  LPVOID v5; // rbp
  HWND Window; // rax
  HWND v7; // rax
  void *v8; // rax
  HWND result; // rax
  WCHAR Buffer[32]; // [rsp+70h] [rbp-58h] BYREF

  v2 = 1174405120;
  if ( *(_DWORD *)(a1 + 60748) )
    v2 = 1442840576;
  hWndParent = *(HWND *)(a1 + 104);
  sub_14001EB60();
  hInstance = GetModuleHandleW(0i64);
  v5 = 0i64;
  Window = CreateWindowExW(0, L"Holder", L"Folders", v2, 0, 0, 0, 0, hWndParent, 0i64, hInstance, 0i64);
  *(_QWORD *)(a1 + 160) = Window;
  sub_140009C20((__int64)Window, (__int64)sub_1400941D0, 0i64, a1);
  v7 = sub_14007CE40(*(HWND *)(a1 + 160));
  *(_QWORD *)(a1 + 152) = v7;
  SetWindowTheme(v7, L"Explorer", 0i64);
  SetWindowLongPtrW(*(HWND *)(a1 + 152), -20, 512i64);
  v8 = operator new(0x748ui64);
  if ( v8 )
    v5 = sub_14001EFD0(v8, *(HWND *)(a1 + 152), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 2648), *(_QWORD *)(a1 + 4784));
  *(_QWORD *)(a1 + 2656) = v5;
  sub_140009C20(*(_QWORD *)(a1 + 152), (__int64)sub_140092CF0, 1i64, a1);
  LoadStringW(::hInstance, 0x1F70u, Buffer, 32);
  result = sub_140090BE0(*(HWND *)(a1 + 160), 6000, (__int64)Buffer);
  *(_QWORD *)(a1 + 984) = result;
  return result;
}

//----- (0000000140091950) ----------------------------------------------------
__int64 __fastcall sub_140091950(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 96));
  return 0i64;
}

//----- (0000000140091970) ----------------------------------------------------
__int64 __fastcall sub_140091970(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400919B0) ----------------------------------------------------
int __fastcall sub_1400919B0(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  HWND DlgItem; // rax
  int result; // eax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 104);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1098);
  result = GetWindowTextW(DlgItem, (LPWSTR)(*(_QWORD *)(a1 + 104) + 544i64), 256);
  *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8i64) = 1;
  return result;
}

//----- (0000000140091A80) ----------------------------------------------------
LRESULT __fastcall sub_140091A80(__int64 a1, const WCHAR *a2)
{
  HWND v4; // r12
  LRESULT result; // rax
  unsigned int v6; // ebx
  int v7; // esi
  WPARAM v8; // rdi
  __int64 v9; // rax
  bool v10; // cf
  LPARAM lParam; // [rsp+20h] [rbp-298h] BYREF
  int v12; // [rsp+2Ch] [rbp-28Ch]
  int v13; // [rsp+30h] [rbp-288h]
  WCHAR v14[264]; // [rsp+70h] [rbp-248h] BYREF

  v4 = (HWND)(***(__int64 (__fastcall ****)(_QWORD))(a1 + 80))(*(_QWORD *)(a1 + 80));
  result = SendMessageW(v4, 0x1004u, 0i64, 0i64);
  v6 = 0;
  v7 = result;
  if ( (int)result > 0 )
  {
    v8 = 0i64;
    do
    {
      v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
      (*(void (__fastcall **)(__int64, _QWORD, WCHAR *))(*(_QWORD *)v9 + 88i64))(v9, v6, v14);
      result = sub_140082100(a2, v14, 0);
      if ( (_DWORD)result == 1 )
      {
        v10 = *(_DWORD *)(a1 + 88) != 0;
        v13 = 2;
        v12 = v10 ? 2 : 0;
        result = SendMessageW(v4, 0x102Bu, v8, (LPARAM)&lParam);
      }
      ++v6;
      ++v8;
    }
    while ( (int)v6 < v7 );
  }
  return result;
}

//----- (0000000140091B80) ----------------------------------------------------
char **__fastcall sub_140091B80(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v3; // rdi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  char *v11; // r11
  __int64 v12; // rax
  __int64 v13; // rdi
  char *v14; // r11
  __int64 v15; // rax
  __int64 v16; // rdi
  char *v17; // r11
  __int64 v18; // rax
  char **result; // rax
  __int64 v20; // [rsp+20h] [rbp-18h] BYREF
  int v21; // [rsp+28h] [rbp-10h]

  *a2 = 1;
  v3 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  v20 = 0x10000044Ai64;
  v21 = 1;
  v6 = sub_140017AD0(v3, v5, &v20);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v7 + 1;
  *(_QWORD *)(v3 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  v9 = *(_QWORD *)(*a3 + 8);
  v10 = *a3;
  v20 = 1i64;
  v21 = 0;
  v11 = sub_140017AD0(v10, v9, &v20);
  v12 = a3[1];
  if ( v12 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  v20 = 2i64;
  a3[1] = v12 + 1;
  *(_QWORD *)(v8 + 8) = v11;
  **((_QWORD **)v11 + 1) = v11;
  v13 = *a3;
  v21 = 0;
  v14 = sub_140017AD0(v13, *(_QWORD *)(v13 + 8), &v20);
  v15 = a3[1];
  if ( v15 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  v20 = 1304i64;
  a3[1] = v15 + 1;
  *(_QWORD *)(v13 + 8) = v14;
  **((_QWORD **)v14 + 1) = v14;
  v16 = *a3;
  v21 = 0;
  v17 = sub_140017AD0(v16, *(_QWORD *)(v16 + 8), &v20);
  v18 = a3[1];
  if ( 0x1555555555555554i64 == v18 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v18 + 1;
  *(_QWORD *)(v16 + 8) = v17;
  result = (char **)*((_QWORD *)v17 + 1);
  *result = v17;
  return result;
}

//----- (0000000140091D20) ----------------------------------------------------
void __fastcall sub_140091D20(__int64 a1)
{
  __int64 v2; // rcx

  v2 = a1 + 1056;
  *(_QWORD *)(v2 - 1056) = &CWildcardSelectDialogPersistentSettings::`vftable';
  sub_14000A630(v2);
  j_free(*(void **)(a1 + 1056));
  *(_QWORD *)a1 = &CDialogSettings::`vftable';
}
// 1400F7978: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (0000000140091D70) ----------------------------------------------------
__int64 *sub_140091D70()
{
  __int64 v0; // rbx
  __int64 v1; // rdx
  _WORD *v2; // rcx
  __int16 v3; // ax
  _WORD *v4; // rcx
  __int16 v5; // ax

  v0 = 256i64;
  v1 = 256i64;
  v2 = &unk_14013016C;
  while ( v1 != -2147483390 )
  {
    v3 = *(_WORD *)((char *)v2 + (char *)L"WildcardSelect" - (char *)&unk_14013016C);
    if ( !v3 )
      break;
    *v2++ = v3;
    if ( !--v1 )
    {
      --v2;
      break;
    }
  }
  *v2 = 0;
  byte_14013036C = 1;
  dword_140130158 = 0;
  qword_140130150 = (__int64)&CWildcardSelectDialogPersistentSettings::`vftable';
  sub_14000A5B0(&qword_140130570);
  v4 = &unk_140130370;
  while ( v0 != -2147483390 )
  {
    v5 = *(_WORD *)((char *)v4 + &unk_1400EB8F4 - &unk_140130370);
    if ( !v5 )
      break;
    *v4++ = v5;
    if ( !--v0 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  return &qword_140130150;
}
// 140091DD7: conditional instruction was optimized away because rdx.8!=0
// 140091E46: conditional instruction was optimized away because rbx.8!=0
// 1400EF3A0: using guessed type wchar_t aWildcardselect_0[15];
// 1400F7978: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 140130150: using guessed type __int64 qword_140130150;
// 140130158: using guessed type int dword_140130158;
// 14013036C: using guessed type char byte_14013036C;

//----- (0000000140091F50) ----------------------------------------------------
HRESULT __fastcall sub_140091F50(__int64 a1, __int64 *a2, __int64 a3)
{
  sub_14007C330(a2, a3, (__int64)L"Pattern", (_QWORD **)(a1 + 1056));
  return sub_14007BEA0(a2, a3, L"CurrentText", (const OLECHAR *)(a1 + 544));
}
// 1400EF410: using guessed type wchar_t aPattern[8];
// 1400EF420: using guessed type wchar_t aCurrenttext[12];

//----- (0000000140091FB0) ----------------------------------------------------
LSTATUS __fastcall sub_140091FB0(__int64 a1, HKEY a2)
{
  const WCHAR *lpData; // rbx
  int v4; // eax

  lpData = (const WCHAR *)a1;
  sub_14007B450(a2, (__int64)L"Pattern", (_QWORD **)(a1 + 1056));
  lpData += 272;
  v4 = lstrlenW(lpData);
  return RegSetValueExW(a2, L"CurrentText", 0, 1u, (const BYTE *)lpData, 2 * v4);
}
// 1400EF3C0: using guessed type wchar_t aPattern_0[8];

//----- (0000000140092020) ----------------------------------------------------
__int64 __fastcall sub_140092020(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HICON IconW; // rax
  HWND v4; // rcx
  HWND DlgItem; // rax
  _QWORD *v6; // rdi
  HWND v7; // rbp
  _QWORD *i; // rbx
  LPARAM *v9; // r9
  _DWORD *v10; // rdx
  HWND v11; // rbx
  HWND Parent; // rax
  LPARAM lParam[3]; // [rsp+40h] [rbp-D8h] BYREF
  unsigned __int64 v15; // [rsp+58h] [rbp-C0h]
  WCHAR Buffer[64]; // [rsp+70h] [rbp-A8h] BYREF

  ModuleHandleW = GetModuleHandleW(0i64);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  v4 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 96) = IconW;
  SetClassLongPtrW(v4, -34, (LONG_PTR)IconW);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1098);
  v6 = *(_QWORD **)(*(_QWORD *)(a1 + 104) + 1056i64);
  v7 = DlgItem;
  for ( i = (_QWORD *)*v6; i != v6; i = (_QWORD *)*i )
  {
    v15 = 7i64;
    lParam[2] = 0i64;
    LOWORD(lParam[0]) = 0;
    sub_140009610(lParam, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v9 = lParam;
    if ( v15 >= 8 )
      v9 = (LPARAM *)lParam[0];
    SendMessageW(v7, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v9);
    if ( v15 >= 8 )
      j_free((void *)lParam[0]);
  }
  SetWindowTextW(v7, (LPCWSTR)(*(_QWORD *)(a1 + 104) + 544i64));
  if ( !*(_DWORD *)(a1 + 88) )
  {
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0x847u, Buffer, 64);
    SetWindowTextW(*(HWND *)(a1 + 8), Buffer);
  }
  SetFocus(v7);
  v10 = *(_DWORD **)(a1 + 104);
  v11 = *(HWND *)(a1 + 8);
  if ( v10[2] )
  {
    SetWindowPos(v11, 0i64, v10[3], v10[4], v10[5], v10[6], 4u);
  }
  else
  {
    Parent = GetParent(v11);
    sub_140081E00(Parent, v11);
  }
  return 0i64;
}

//----- (00000001400921F0) ----------------------------------------------------
void __fastcall sub_1400921F0(__int64 a1, const WCHAR *a2, _WORD *a3)
{
  __int64 v6; // rdx
  _WORD *v7; // rcx
  char *v8; // rbx
  __int16 v9; // ax
  __int64 v10; // rcx
  _WORD *v11; // rdi
  bool v12; // zf
  __int64 v13; // rdi
  char *v14; // rdx
  __int64 v15; // rax
  void *Block[3]; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int64 v17; // [rsp+40h] [rbp-38h]

  if ( lstrcmpiW(a2, L"CurrentText") )
  {
    if ( (unsigned int)sub_140082100(L"Pattern*", a2, 1) )
    {
      v17 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v10 = -1i64;
      v11 = a3;
      do
      {
        if ( !v10 )
          break;
        v12 = *v11++ == 0;
        --v10;
      }
      while ( !v12 );
      sub_1400099E0(Block, a3, -v10 - 2);
      v13 = *(_QWORD *)(a1 + 1056);
      v14 = sub_14000A760(v13, *(_QWORD *)(v13 + 8), Block);
      v15 = *(_QWORD *)(a1 + 1064);
      if ( v15 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 1064) = v15 + 1;
      *(_QWORD *)(v13 + 8) = v14;
      **((_QWORD **)v14 + 1) = v14;
      if ( v17 >= 8 )
        j_free(Block[0]);
    }
  }
  else
  {
    v6 = 256i64;
    v7 = (_WORD *)(a1 + 544);
    v8 = (char *)a3 - a1 - 544;
    while ( v6 != -2147483390 )
    {
      v9 = *(_WORD *)((char *)v7 + (_QWORD)v8);
      if ( !v9 )
        break;
      *v7++ = v9;
      if ( !--v6 )
      {
        --v7;
        break;
      }
    }
    *v7 = 0;
  }
}
// 140092266: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140092350) ----------------------------------------------------
int __fastcall sub_140092350(__int64 a1, HKEY a2)
{
  BYTE *lpData; // rbx
  __int64 v5; // rsi
  __int64 v6; // rax
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  DWORD Type; // [rsp+50h] [rbp+18h] BYREF

  sub_14007B580(a2, (__int64)L"Pattern", (__int64 *)(a1 + 1056));
  lpData = (BYTE *)(a1 + 544);
  v5 = 256i64;
  cbData = 256;
  LODWORD(v6) = RegQueryValueExW(a2, L"CurrentText", 0i64, &Type, lpData, &cbData);
  if ( cbData && Type == 1 )
  {
    v6 = cbData - 1;
    if ( *(_WORD *)&lpData[2 * v6] )
    {
      if ( cbData < 0x100 )
        v5 = cbData;
      *(_WORD *)&lpData[2 * v5] = 0;
    }
  }
  else
  {
    *(_WORD *)lpData = 0;
  }
  return v6;
}
// 1400EF3E8: using guessed type wchar_t aPattern_2[8];

//----- (0000000140092410) ----------------------------------------------------
BOOL __fastcall sub_140092410(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rax
  const WCHAR *v4; // rcx
  __int64 v5; // rcx
  WCHAR *v6; // rdi
  bool v7; // zf
  __int64 v8; // rsi
  __int64 v9; // rdi
  char *v10; // r11
  __int64 v11; // rax
  void *Block[3]; // [rsp+28h] [rbp-440h] BYREF
  unsigned __int64 v14; // [rsp+40h] [rbp-428h]
  WCHAR String[512]; // [rsp+50h] [rbp-418h] BYREF

  GetDlgItemTextW(*(HWND *)(a1 + 8), 1098, String, 512);
  if ( lstrcmpW(String, &word_1400EB8E4) )
  {
    sub_140091A80(a1, String);
    v2 = *(_QWORD *)(a1 + 104);
    v3 = **(_QWORD **)(v2 + 1056);
    if ( v3 == *(_QWORD *)(v2 + 1056) )
      goto LABEL_6;
    v4 = (const WCHAR *)(v3 + 16);
    if ( *(_QWORD *)(v3 + 40) >= 8ui64 )
      v4 = *(const WCHAR **)v4;
    if ( lstrcmpW(v4, String) )
    {
LABEL_6:
      v14 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v5 = -1i64;
      v6 = String;
      do
      {
        if ( !v5 )
          break;
        v7 = *v6++ == 0;
        --v5;
      }
      while ( !v7 );
      sub_1400099E0(Block, String, -v5 - 2);
      v8 = *(_QWORD *)(a1 + 104);
      v9 = **(_QWORD **)(v8 + 1056);
      v10 = sub_14000A760(v9, *(_QWORD *)(v9 + 8), Block);
      v11 = *(_QWORD *)(v8 + 1064);
      if ( v11 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(v8 + 1064) = v11 + 1;
      *(_QWORD *)(v9 + 8) = v10;
      **((_QWORD **)v10 + 1) = v10;
      if ( v14 >= 8 )
        j_free(Block[0]);
    }
  }
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (00000001400925A0) ----------------------------------------------------
__int64 __fastcall sub_1400925A0(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    sub_140092410(a1);
  }
  else if ( a2 == 2 )
  {
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
  return 0i64;
}

//----- (00000001400925E0) ----------------------------------------------------
__int64 __fastcall sub_1400925E0(__int64 a1, __int64 a2)
{
  LPARAM v2; // rax
  __int64 v3; // rbx
  HWND v5; // rcx
  const ITEMIDLIST *v6; // rax
  LPARAM lParam[6]; // [rsp+20h] [rbp-58h] BYREF
  int v9; // [rsp+50h] [rbp-28h]

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD *)(a1 + 2656);
  v5 = *(HWND *)(v3 + 24);
  LODWORD(lParam[0]) = 20;
  lParam[1] = v2;
  SendMessageW(v5, 0x113Eu, 0i64, (LPARAM)lParam);
  v6 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v3 + 640) + 16i64 * v9));
  sub_14007E270(v6, (LPWSTR)(a1 + 6480), 0x8000u);
  return 0i64;
}

//----- (0000000140092660) ----------------------------------------------------
UINT_PTR __fastcall sub_140092660(__int64 a1, __int64 a2)
{
  UINT_PTR result; // rax
  bool v3; // zf
  HWND v4; // rcx

  if ( *(_DWORD *)(a1 + 7020) || *(_DWORD *)(a1 + 7016) || (result = *(_QWORD *)(a1 + 2656), *(_DWORD *)(result + 680)) )
  {
    *(_DWORD *)(a1 + 7020) = 0;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 60812) == 0;
    v4 = *(HWND *)(a1 + 160);
    qword_14012DA18 = *(_QWORD *)(a2 + 96);
    if ( v3 )
      return SetTimer(v4, 0i64, 0, 0i64);
    else
      return SetTimer(v4, 0i64, 0x1F4u, 0i64);
  }
  return result;
}

//----- (00000001400926D0) ----------------------------------------------------
LRESULT __fastcall sub_1400926D0(__int64 a1)
{
  LPARAM v2; // rax

  SetFocus(*(HWND *)(a1 + 152));
  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  return SendMessageW(*(HWND *)(a1 + 152), 0x1141u, 0i64, v2);
}

//----- (0000000140092730) ----------------------------------------------------
__int64 __fastcall sub_140092730(__int64 a1, __int16 a2)
{
  if ( a2 == 6000 )
    sub_14008FEF0(a1);
  return 1i64;
}

//----- (0000000140092760) ----------------------------------------------------
void __fastcall sub_140092760(__int64 a1)
{
  LRESULT v2; // rax
  __int64 v3; // rbx
  HWND v4; // rcx
  ITEMIDLIST *v5; // rbx
  LPARAM lParam[6]; // [rsp+30h] [rbp-58h] BYREF
  int v7; // [rsp+60h] [rbp-28h]

  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  v3 = *(_QWORD *)(a1 + 2656);
  v4 = *(HWND *)(v3 + 24);
  LODWORD(lParam[0]) = 20;
  lParam[1] = v2;
  SendMessageW(v4, 0x113Eu, 0i64, (LPARAM)lParam);
  v5 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v3 + 640) + 16i64 * v7));
  sub_14009A080(a1, v5, 0i64, 0, L"properties", 0);
  CoTaskMemFree(v5);
}
// 1400EFED0: using guessed type wchar_t aProperties_0[11];

//----- (0000000140092820) ----------------------------------------------------
void __fastcall sub_140092820(__int64 a1, int a2)
{
  int v4; // ebp
  LPARAM v5; // rsi
  LPARAM v6; // rax
  __int64 v7; // rbx
  HWND v8; // rcx
  const ITEMIDLIST *v9; // rax
  ITEMIDLIST *v10; // rbx
  LPARAM lParam[6]; // [rsp+30h] [rbp-58h] BYREF
  int v12; // [rsp+60h] [rbp-28h]

  v4 = 0;
  v5 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  v6 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 3ui64, v5);
  SendMessageW(*(HWND *)(a1 + 152), 0x110Bu, 9ui64, v6);
  if ( v5 )
  {
    v7 = *(_QWORD *)(a1 + 2656);
    v8 = *(HWND *)(v7 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v5;
    SendMessageW(v8, 0x113Eu, 0i64, (LPARAM)lParam);
    v9 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v7 + 640) + 16i64 * v12));
    v10 = (ITEMIDLIST *)v9;
    if ( a2 )
      v4 = 0x10000000;
    sub_14009A080(a1, v9, 0i64, 0, L"delete", v4);
    CoTaskMemFree(v10);
  }
}
// 1400EF468: using guessed type wchar_t aDelete_0[7];

//----- (0000000140092950) ----------------------------------------------------
void __fastcall sub_140092950(__int64 a1)
{
  LRESULT v2; // rdi
  _QWORD *v3; // rax
  _QWORD *v4; // rsi
  __int64 v5; // rbx
  ITEMIDLIST *v6; // rdi
  HANDLE FirstFileW; // rax
  char *v8; // rax
  __int64 **v9; // rax
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx
  char *v12; // [rsp+38h] [rbp-D0h] BYREF
  _QWORD **v13; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v14; // [rsp+48h] [rbp-C0h]
  __int64 pExceptionObject[4]; // [rsp+58h] [rbp-B0h] BYREF
  LPARAM lParam[6]; // [rsp+78h] [rbp-90h] BYREF
  int v17; // [rsp+A8h] [rbp-60h]
  __int64 *v18; // [rsp+C8h] [rbp-40h] BYREF
  LPARAM dwInitParam[3]; // [rsp+E8h] [rbp-20h] BYREF
  unsigned __int16 v20; // [rsp+100h] [rbp-8h]
  HWND hWndParent; // [rsp+108h] [rbp+0h]
  int v22; // [rsp+118h] [rbp+10h]
  WCHAR FileName[260]; // [rsp+1B8h] [rbp+B0h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+3C0h] [rbp+2B8h] BYREF

  pExceptionObject[3] = -2i64;
  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  if ( v2 )
  {
    v14 = 0i64;
    v3 = operator new(0x468ui64);
    v4 = v3;
    if ( !v3 )
    {
      v12 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v12);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v13 = (_QWORD **)v3;
    *v3 = v3;
    v3[1] = v3;
    v5 = *(_QWORD *)(a1 + 2656);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v2;
    SendMessageW(*(HWND *)(v5 + 24), 0x113Eu, 0i64, (LPARAM)lParam);
    v6 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v5 + 640) + 16i64 * v17));
    LODWORD(v5) = sub_14007E270(v6, FileName, 0x8000u);
    CoTaskMemFree(v6);
    if ( !(_DWORD)v5 )
    {
      FirstFileW = FindFirstFileW(FileName, &FindFileData);
      if ( FirstFileW != (HANDLE)-1i64 )
      {
        FindClose(FirstFileW);
        v8 = sub_14000B500((__int64)v4, v4[1], FileName);
        v14 = 1i64;
        v4[1] = v8;
        **((_QWORD **)v8 + 1) = v8;
        v9 = sub_14000B2C0(&v18, &v13);
        sub_14009BA10((__int64)dwInitParam, *(_QWORD *)(a1 + 104), v9);
        if ( !v22 )
          DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v20, hWndParent, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
        sub_14009AAE0((__int64)dwInitParam);
      }
    }
    v10 = (_QWORD *)*v4;
    *v4 = v4;
    v4[1] = v4;
    if ( v10 != v4 )
    {
      do
      {
        v11 = (_QWORD *)*v10;
        j_free(v10);
        v10 = v11;
      }
      while ( v11 != v4 );
    }
    j_free(v4);
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140092B70) ----------------------------------------------------
__int64 __fastcall sub_140092B70(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, LPARAM a5)
{
  HWND v10; // rcx
  LPITEMIDLIST v11; // rbx
  HWND v12; // rcx
  LPARAM v13; // rax
  int lParam; // [rsp+30h] [rbp-38h] BYREF
  int lParam_4; // [rsp+34h] [rbp-34h]
  int v16; // [rsp+38h] [rbp-30h]
  LPARAM v17; // [rsp+40h] [rbp-28h]

  switch ( a3 )
  {
    case 7u:
      sub_1400BD730((__int64)a1);
      break;
    case 0x207u:
      v12 = (HWND)a1[19];
      lParam = (unsigned __int16)a5;
      lParam_4 = WORD1(a5);
      SendMessageW(v12, 0x1111u, 0i64, (LPARAM)&lParam);
      if ( v16 == 1 || (v13 = v17) == 0 )
        v13 = 0i64;
      a1[7909] = v13;
      break;
    case 0x208u:
      v10 = (HWND)a1[19];
      lParam = (unsigned __int16)a5;
      lParam_4 = WORD1(a5);
      SendMessageW(v10, 0x1111u, 0i64, (LPARAM)&lParam);
      if ( v16 != 1 && v17 && v17 == a1[7909] )
      {
        v11 = sub_140020BE0(a1[332], v17);
        (*(void (__fastcall **)(_QWORD *, LPITEMIDLIST, _QWORD, __int64, _DWORD, _DWORD))(a1[7] + 80i64))(
          a1 + 7,
          v11,
          0i64,
          1i64,
          0,
          0);
        CoTaskMemFree(v11);
      }
      break;
    default:
      if ( a3 == 522 && (unsigned int)sub_140095060((__int64)a1, 1, a4, a5) )
        return 0i64;
      break;
  }
  return sub_140001A20(a2, a3, a4, a5);
}

//----- (0000000140092CF0) ----------------------------------------------------
__int64 __fastcall sub_140092CF0(__int64 a1, unsigned int a2, __int64 a3, LPARAM a4, int a5, _QWORD *a6)
{
  return sub_140092B70(a6, a1, a2, a3, a4);
}

//----- (0000000140092D20) ----------------------------------------------------
int __fastcall sub_140092D20(__int64 a1)
{
  LRESULT v2; // rax
  LPARAM v3; // rbp
  _DWORD *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rbx
  HWND v7; // rcx
  ITEMIDLIST *v8; // rbx
  int v9; // eax
  bool v10; // zf
  __int64 v11; // rcx
  LPDATAOBJECT v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rdx
  LPDATAOBJECT ppDataObj; // [rsp+20h] [rbp-298h] BYREF
  __int64 v17; // [rsp+28h] [rbp-290h] BYREF
  LPARAM lParam[6]; // [rsp+30h] [rbp-288h] BYREF
  int v19; // [rsp+60h] [rbp-258h]
  WCHAR String[264]; // [rsp+80h] [rbp-238h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  v3 = v2;
  if ( v2 )
  {
    ppDataObj = 0i64;
    LODWORD(v2) = OleGetClipboard(&ppDataObj);
    if ( !(_DWORD)v2 )
    {
      v4 = operator new(0x50ui64);
      v5 = (__int64)v4;
      if ( v4 )
      {
        v4[2] = 1;
        *(_QWORD *)v4 = &CDropHandler::`vftable';
      }
      else
      {
        v5 = 0i64;
      }
      v6 = *(_QWORD *)(a1 + 2656);
      v7 = *(HWND *)(v6 + 24);
      LODWORD(lParam[0]) = 20;
      lParam[1] = v3;
      SendMessageW(v7, 0x113Eu, 0i64, (LPARAM)lParam);
      v8 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v6 + 640) + 16i64 * v19));
      sub_14007E270(v8, String, 0x8000u);
      v9 = lstrlenW(String);
      v10 = *(_DWORD *)(a1 + 60872) == 0;
      v11 = v9;
      v12 = ppDataObj;
      String[v11 + 1] = 0;
      v13 = *(_QWORD *)(a1 + 152);
      *(_QWORD *)(v5 + 16) = v12;
      *(_DWORD *)(v5 + 72) = v10;
      v14 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v5 + 48) = v13;
      *(_DWORD *)(v5 + 44) = 1;
      *(_QWORD *)(v5 + 24) = 0i64;
      v17 = 0i64;
      *(_QWORD *)(v5 + 64) = String;
      sub_1400783F0(v5, v14, (int *)&v17);
      CoTaskMemFree(v8);
      if ( !_InterlockedDecrement((volatile signed __int32 *)(v5 + 8)) )
        (**(void (__fastcall ***)(__int64, __int64))v5)(v5, 1i64);
      LODWORD(v2) = ((__int64 (__fastcall *)(LPDATAOBJECT))ppDataObj->lpVtbl->Release)(ppDataObj);
    }
  }
  return v2;
}
// 1400F7C20: using guessed type void *CDropHandler::`vftable';

//----- (00000001400935F0) ----------------------------------------------------
void __fastcall sub_1400935F0(__int64 a1)
{
  LRESULT v2; // rax
  __int64 v3; // rdi
  HWND v4; // rcx
  ITEMIDLIST *v5; // rbx
  DWORD UniversalNameW; // eax
  __int64 v7; // rcx
  WCHAR *v8; // rdx
  WCHAR *v9; // rdi
  bool v10; // zf
  DWORD BufferSize; // [rsp+20h] [rbp-E0h] BYREF
  WCHAR *Buffer; // [rsp+28h] [rbp-D8h] BYREF
  LPARAM lParam[6]; // [rsp+30h] [rbp-D0h] BYREF
  int v14; // [rsp+60h] [rbp-A0h]
  void *Block[3]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v16; // [rsp+98h] [rbp-68h]
  WCHAR LocalPath[264]; // [rsp+B0h] [rbp-50h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  if ( v2 )
  {
    v3 = *(_QWORD *)(a1 + 2656);
    v4 = *(HWND *)(v3 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v2;
    SendMessageW(v4, 0x113Eu, 0i64, (LPARAM)lParam);
    v5 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v3 + 640) + 16i64 * v14));
    sub_14007E270(v5, LocalPath, 0x8000u);
    BufferSize = 8;
    UniversalNameW = WNetGetUniversalNameW(LocalPath, 1u, &Buffer, &BufferSize);
    v7 = -1i64;
    v16 = 7i64;
    if ( UniversalNameW )
    {
      v9 = LocalPath;
      v8 = LocalPath;
    }
    else
    {
      v8 = Buffer;
      v9 = Buffer;
    }
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    do
    {
      if ( !v7 )
        break;
      v10 = *v9++ == 0;
      --v7;
    }
    while ( !v10 );
    sub_1400099E0(Block, v8, -v7 - 2);
    if ( OpenClipboard(0i64) )
      sub_14007F5B0(Block);
    if ( v16 >= 8 )
      j_free(Block[0]);
    CoTaskMemFree(v5);
  }
}

//----- (0000000140093760) ----------------------------------------------------
void __fastcall sub_140093760(__int64 a1)
{
  LRESULT v2; // rax
  __int64 v3; // rdi
  HWND v4; // rcx
  ITEMIDLIST *v5; // rbx
  __int64 v6; // rcx
  WCHAR *v7; // rdi
  bool v8; // zf
  HGLOBAL v9; // rax
  void *v10; // rdi
  void *v11; // rax
  void **v12; // rdx
  LPARAM lParam[6]; // [rsp+20h] [rbp-2A8h] BYREF
  int v14; // [rsp+50h] [rbp-278h]
  void *Block[2]; // [rsp+70h] [rbp-258h] BYREF
  __int64 v16; // [rsp+80h] [rbp-248h]
  unsigned __int64 v17; // [rsp+88h] [rbp-240h]
  WCHAR pszBuf[264]; // [rsp+A0h] [rbp-228h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  if ( v2 )
  {
    v3 = *(_QWORD *)(a1 + 2656);
    v4 = *(HWND *)(v3 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v2;
    SendMessageW(v4, 0x113Eu, 0i64, (LPARAM)lParam);
    v5 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v3 + 640) + 16i64 * v14));
    sub_14007E270(v5, pszBuf, 0x8000u);
    v6 = -1i64;
    v7 = pszBuf;
    v17 = 7i64;
    do
    {
      if ( !v6 )
        break;
      v8 = *v7++ == 0;
      --v6;
    }
    while ( !v8 );
    v16 = 0i64;
    LOWORD(Block[0]) = 0;
    sub_1400099E0(Block, pszBuf, -v6 - 2);
    if ( OpenClipboard(0i64) )
    {
      EmptyClipboard();
      v9 = GlobalAlloc(2u, 2 * v16 + 2);
      v10 = v9;
      if ( v9 )
      {
        v11 = GlobalLock(v9);
        v12 = Block;
        if ( v17 >= 8 )
          v12 = (void **)Block[0];
        memmove(v11, v12, 2 * v16 + 2);
        GlobalUnlock(v10);
        SetClipboardData(0xDu, v10);
      }
      CloseClipboard();
    }
    if ( v17 >= 8 )
      j_free(Block[0]);
    CoTaskMemFree(v5);
  }
}

//----- (0000000140093C40) ----------------------------------------------------
_BOOL8 __fastcall sub_140093C40(__int64 a1, __int64 a2)
{
  int v2; // eax
  char KeyState; // al

  v2 = *(unsigned __int16 *)(a2 + 24);
  switch ( v2 )
  {
    case '.':
      KeyState = GetKeyState(16);
      sub_140092820(a1, KeyState < 0);
      break;
    case 'C':
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_1400932D0(a1, 1i64);
      break;
    case 'V':
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_140092D20(a1);
      break;
    default:
      if ( v2 == 88
        && (GetKeyState(17) & 0x80u) != 0
        && (GetKeyState(16) & 0x80u) == 0
        && (GetKeyState(18) & 0x80u) == 0 )
      {
        sub_1400932D0(a1, 0i64);
      }
      break;
  }
  return (GetKeyState(17) & 0x80u) != 0;
}
// 1400932D0: using guessed type __int64 __fastcall sub_1400932D0(_QWORD, _QWORD);

//----- (0000000140093D70) ----------------------------------------------------
BOOL __fastcall sub_140093D70(__int64 a1)
{
  __int64 v1; // rbx
  HWND v3; // rcx
  ITEMIDLIST *v4; // rbx
  __int64 v5; // rax
  LPARAM lParam[6]; // [rsp+20h] [rbp-58h] BYREF
  int v8; // [rsp+50h] [rbp-28h]

  v1 = *(_QWORD *)(a1 + 2656);
  v3 = *(HWND *)(v1 + 24);
  LODWORD(lParam[0]) = 20;
  lParam[1] = qword_14012DA18;
  SendMessageW(v3, 0x113Eu, 0i64, (LPARAM)lParam);
  v4 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v1 + 640) + 16i64 * v8));
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  if ( !*(_DWORD *)(a1 + 7020) && !*(_DWORD *)(a1 + 7016) && !(unsigned int)sub_14007DCB0((__int64)v4, v5) )
  {
    sub_1400B40A0(a1, v4);
    if ( *(_DWORD *)(a1 + 60904) )
      SendMessageW(*(HWND *)(a1 + 152), 0x1102u, 2ui64, qword_14012DA18);
  }
  CoTaskMemFree(v4);
  return KillTimer(*(HWND *)(a1 + 160), 0i64);
}

//----- (0000000140093E60) ----------------------------------------------------
__int64 __fastcall sub_140093E60(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  LPARAM v5; // rax
  HWND v6; // rcx
  ITEMIDLIST *v7; // rbx
  LPARAM v8; // rax
  LPARAM v9; // rdx
  ITEMIDLIST *v10; // rbx
  LPARAM lParam[6]; // [rsp+20h] [rbp-58h] BYREF
  int v13; // [rsp+50h] [rbp-28h]

  if ( SendMessageW(*(HWND *)a2, 0x110Au, 3ui64, *(_QWORD *)(a2 + 96)) )
  {
    if ( *(_DWORD *)(a2 + 24) == 2 )
    {
      v4 = *(_QWORD *)(a1 + 2656);
      v5 = *(_QWORD *)(a2 + 96);
      v6 = *(HWND *)(v4 + 24);
      LODWORD(lParam[0]) = 20;
      lParam[1] = v5;
      SendMessageW(v6, 0x113Eu, 0i64, (LPARAM)lParam);
      v7 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v4 + 640) + 16i64 * v13));
      sub_14001F8B0(*(_QWORD *)(a1 + 2656), *(_QWORD *)(a2 + 96), v7);
      CoTaskMemFree(v7);
    }
    else
    {
      v8 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
      if ( v8 )
      {
        do
          v8 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 3ui64, v8);
        while ( v8 != *(_QWORD *)(a2 + 96) && v8 );
        v9 = *(_QWORD *)(a2 + 96);
        if ( v8 == v9 )
        {
          v10 = sub_140020BE0(*(_QWORD *)(a1 + 2656), v9);
          sub_1400B40A0(a1, v10);
          CoTaskMemFree(v10);
        }
      }
      sub_1400216B0(*(_QWORD *)(a1 + 2656), *(_QWORD *)(a2 + 96));
      SendMessageW(*(HWND *)a2, 0x1102u, 0x8001ui64, *(_QWORD *)(a2 + 96));
    }
  }
  return 0i64;
}

//----- (0000000140093FD0) ----------------------------------------------------
__int64 __fastcall sub_140093FD0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 result; // rax
  DWORD MessagePos; // eax
  HWND v6; // rcx
  struct tagPOINT Point; // [rsp+20h] [rbp-28h] BYREF
  char v8; // [rsp+28h] [rbp-20h]
  __int64 v9; // [rsp+30h] [rbp-18h]
  struct tagPOINT v10; // [rsp+58h] [rbp+10h] BYREF

  v2 = *(_DWORD *)(a2 + 16);
  if ( v2 > 0xFFFFFE64 )
  {
    if ( v2 == -5 && *(_QWORD *)a2 == *(_QWORD *)(a1 + 152) )
    {
      MessagePos = GetMessagePos();
      v10.x = (__int16)MessagePos;
      v6 = *(HWND *)(a1 + 152);
      v10.y = SHIWORD(MessagePos);
      Point = v10;
      ScreenToClient(v6, &Point);
      SendMessageW(*(HWND *)(a1 + 152), 0x1111u, 0i64, (LPARAM)&Point);
      if ( (v8 & 1) == 0 )
        sub_140093910(a1, v9, &v10);
    }
    return 0i64;
  }
  else if ( v2 == -412 )
  {
    return sub_140093C40(a1, a2);
  }
  else
  {
    switch ( v2 )
    {
      case 0xFFFFFE34:
        sub_140092EF0(a1);
        result = 0i64;
        break;
      case 0xFFFFFE35:
        sub_1400925E0(a1, a2);
        result = 0i64;
        break;
      case 0xFFFFFE38:
      case 0xFFFFFE3C:
        SendMessageW(*(HWND *)(a1 + 152), 0x4Eu, 0i64, a2);
        result = 0i64;
        break;
      case 0xFFFFFE3A:
        result = (int)sub_140093E60(a1, a2);
        break;
      case 0xFFFFFE3D:
        sub_140092660(a1, a2);
        result = 0i64;
        break;
      default:
        return 0i64;
    }
  }
  return result;
}
// 140092EF0: using guessed type __int64 __fastcall sub_140092EF0(_QWORD);
// 140093910: using guessed type __int64 __fastcall sub_140093910(_QWORD, _QWORD, _QWORD);

//----- (0000000140094130) ----------------------------------------------------
__int64 __fastcall sub_140094130(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  if ( a3 == 78 )
    return sub_140093FD0(a1, a5);
  if ( a3 == 273 )
  {
    if ( (_WORD)a4 == 6000 )
      sub_14008FEF0(a1);
    return 1i64;
  }
  else
  {
    if ( a3 == 275 )
      sub_140093D70(a1);
    return sub_140001A20(a2, a3, a4, a5);
  }
}

//----- (00000001400941D0) ----------------------------------------------------
__int64 __fastcall sub_1400941D0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  return sub_140094130(a6, a1, a2, a3, a4);
}

//----- (0000000140094200) ----------------------------------------------------
__int64 __fastcall sub_140094200(__int64 a1)
{
  return *(unsigned int *)(a1 + 6992);
}

//----- (0000000140094210) ----------------------------------------------------
LRESULT __fastcall sub_140094210(__int64 a1)
{
  __int64 v2; // rax
  LPARAM v3; // r9

  if ( (int)SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) <= 1
    || (v2 = 532i64 * *(int *)(a1 + 7048), *(_DWORD *)(v2 + a1 + 7120))
    || (v3 = 4i64, *(_DWORD *)(v2 + a1 + 7124)) )
  {
    v3 = 16i64;
  }
  return SendMessageW(*(HWND *)(a1 + 144), 0x411u, 0x13A9ui64, v3);
}

//----- (0000000140094290) ----------------------------------------------------
void __fastcall sub_140094290(__int64 a1, int a2)
{
  int v4; // eax
  int v5; // esi
  int v6; // er12
  int v7; // eax
  int v8; // edi
  WPARAM v9; // rbp
  int v10; // eax
  HWND v11; // rcx
  LPARAM v12; // [rsp+20h] [rbp-48h] BYREF
  int v13; // [rsp+28h] [rbp-40h]
  LPARAM lParam; // [rsp+30h] [rbp-38h] BYREF
  int v15; // [rsp+38h] [rbp-30h]

  if ( *(_DWORD *)(a1 + 62472) )
  {
    v4 = SendMessageW(*(HWND *)(a1 + 136), 0x132Fu, 0i64, 0i64);
    v5 = (unsigned __int16)a2;
    LODWORD(v12) = (unsigned __int16)a2;
    HIDWORD(v12) = HIWORD(a2);
    lParam = v12;
    v6 = v4;
    v7 = SendMessageW(*(HWND *)(a1 + 136), 0x130Du, 0i64, (LPARAM)&lParam);
    v8 = v7;
    if ( v15 != 1 && v7 != v6 && (v5 < *(_DWORD *)(a1 + 62476) || v5 > *(_DWORD *)(a1 + 62484)) )
    {
      v9 = v7;
      SendMessageW(*(HWND *)(a1 + 136), 0x130Au, v7, (LPARAM)&v12);
      v10 = *(_DWORD *)(a1 + 62484);
      if ( v5 <= v10 )
      {
        *(_DWORD *)(a1 + 62484) = *(_DWORD *)(a1 + 62476);
        *(_DWORD *)(a1 + 62476) = v12;
      }
      else
      {
        *(_DWORD *)(a1 + 62476) = v10;
        *(_DWORD *)(a1 + 62484) = v13;
      }
      sub_1400809F0(*(HWND *)(a1 + 136), v6, v8);
      v11 = *(HWND *)(a1 + 136);
      *(_DWORD *)(a1 + 7060) = v8;
      SendMessageW(v11, 0x1330u, v9, 0i64);
    }
  }
}

//----- (0000000140094400) ----------------------------------------------------
int __fastcall sub_140094400(__int64 a1)
{
  HWND Capture; // rax

  Capture = GetCapture();
  if ( Capture == *(HWND *)(a1 + 136) )
    LODWORD(Capture) = ReleaseCapture();
  *(_DWORD *)(a1 + 62472) = 0;
  return (int)Capture;
}

//----- (0000000140094440) ----------------------------------------------------
LRESULT __fastcall sub_140094440(__int64 a1, int a2)
{
  HWND v3; // rcx
  LRESULT result; // rax
  _DWORD lParam[4]; // [rsp+20h] [rbp-28h] BYREF

  v3 = *(HWND *)(a1 + 136);
  lParam[0] = (unsigned __int16)a2;
  lParam[1] = HIWORD(a2);
  result = SendMessageW(v3, 0x130Du, 0i64, (LPARAM)lParam);
  if ( lParam[2] != 1 )
  {
    SendMessageW(*(HWND *)(a1 + 136), 0x130Au, (int)result, a1 + 62476);
    result = (LRESULT)SetCapture(*(HWND *)(a1 + 136));
    *(_DWORD *)(a1 + 62472) = 1;
  }
  return result;
}

//----- (00000001400944E0) ----------------------------------------------------
BOOL __fastcall sub_1400944E0(__int64 a1, HMENU a2)
{
  WPARAM v2; // r8
  HWND v4; // rcx
  UINT v6; // er8
  UINT v7; // er8
  __int64 v8; // rax
  BOOL v9; // er8
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v12; // [rsp+40h] [rbp-18h]

  v2 = *(int *)(a1 + 62492);
  v4 = *(HWND *)(a1 + 136);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v4, 0x133Cu, v2, (LPARAM)lParam);
  if ( *(_DWORD *)(532i64 * v12 + a1 + 7120) )
    v6 = 8;
  else
    v6 = 0;
  CheckMenuItem(a2, 0x9D39u, v6);
  if ( *(_DWORD *)(532i64 * v12 + a1 + 7124) )
    v7 = 8;
  else
    v7 = 0;
  CheckMenuItem(a2, 0x9D3Du, v7);
  v8 = 532i64 * v12;
  v9 = *(_DWORD *)(v8 + a1 + 7120) || *(_DWORD *)(v8 + a1 + 7124);
  return EnableMenuItem(a2, 0x9D3Bu, v9);
}
// 1400944E0: using guessed type LPARAM lParam[4];

//----- (00000001400945C0) ----------------------------------------------------
LRESULT __fastcall sub_1400945C0(__int64 a1)
{
  LRESULT result; // rax
  WPARAM v3; // rdi
  __int64 v4; // rbp
  HWND v5; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  unsigned int v7; // [rsp+40h] [rbp-18h]

  result = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( (int)result > 0 )
  {
    v3 = 0i64;
    v4 = (unsigned int)result;
    do
    {
      v5 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v5, 0x133Cu, v3, (LPARAM)lParam);
      result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 32i64))(a1 + 56, v7);
      ++v3;
      --v4;
    }
    while ( v4 );
  }
  return result;
}
// 1400945C0: using guessed type LPARAM lParam[4];

//----- (0000000140094660) ----------------------------------------------------
__int64 __fastcall sub_140094660(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 result; // rax

  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 60992) + 88i64))(
    *(_QWORD *)(a1 + 60992),
    a2,
    *(_QWORD *)(a1 + 104));
  (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(**(_QWORD **)(a1 + 60992) + 104i64))(
    *(_QWORD *)(a1 + 60992),
    a2,
    0i64);
  result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 60992) + 152i64))(
             *(_QWORD *)(a1 + 60992),
             a2,
             a3);
  if ( a4 )
    return (*(__int64 (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(**(_QWORD **)(a1 + 60992) + 112i64))(
             *(_QWORD *)(a1 + 60992),
             a2,
             *(_QWORD *)(a1 + 104),
             0i64);
  return result;
}

//----- (00000001400947A0) ----------------------------------------------------
_QWORD *__fastcall sub_1400947A0(__int64 a1, int a2, HICON a3)
{
  _QWORD *result; // rax
  _QWORD *v5; // rbx
  HICON ClassLongPtrW; // rax
  HICON v7; // rax

  result = *(_QWORD **)(a1 + 61000);
  v5 = (_QWORD *)*result;
  if ( (_QWORD *)*result != result )
  {
    while ( *((_DWORD *)v5 + 8) != a2 )
    {
      v5 = (_QWORD *)*v5;
      if ( v5 == result )
        return result;
    }
    ClassLongPtrW = (HICON)GetClassLongPtrW((HWND)v5[3], -34);
    DestroyIcon(ClassLongPtrW);
    v7 = CopyIcon(a3);
    return (_QWORD *)SetClassLongPtrW((HWND)v5[3], -34, (LONG_PTR)v7);
  }
  return result;
}

//----- (0000000140094820) ----------------------------------------------------
__int64 __fastcall sub_140094820(__int64 a1, int a2, __int64 a3)
{
  HWND v6; // rbx
  HDC DC; // r13
  HDC hdcSrc; // rdi
  __int64 v9; // r14
  BOOL v10; // esi
  HWND v11; // rcx
  HGDIOBJ v12; // rdx
  int v13; // eax
  __int64 v15; // [rsp+60h] [rbp-A8h] BYREF
  HGDIOBJ h; // [rsp+68h] [rbp-A0h] BYREF
  HGDIOBJ v17; // [rsp+70h] [rbp-98h]
  struct tagPOINT pt; // [rsp+78h] [rbp-90h] BYREF
  struct tagRECT Rect; // [rsp+80h] [rbp-88h] BYREF
  struct tagMENUBARINFO pmbi; // [rsp+90h] [rbp-78h] BYREF

  v6 = *(HWND *)(a1 + 8i64 * a2 + 184);
  DC = GetDC(v6);
  hdcSrc = CreateCompatibleDC(DC);
  GetClientRect(v6, &Rect);
  v15 = 0i64;
  GdipCreateBitmapFromScan0(
    (unsigned int)(Rect.right - Rect.left),
    (unsigned int)(Rect.bottom - Rect.top),
    0i64,
    2498570i64,
    0i64,
    &v15);
  v9 = v15;
  GdipCreateHBITMAPFromBitmap(v15, &h, 4278190080i64);
  v17 = SelectObject(hdcSrc, h);
  v10 = IsWindowVisible(v6);
  if ( !v10 )
    ShowWindow(v6, 5);
  PrintWindow(v6, hdcSrc, 1u);
  if ( !v10 )
    ShowWindow(v6, 0);
  SetStretchBltMode(hdcSrc, 4);
  SetBrushOrgEx(hdcSrc, 0, 0, &pt);
  StretchBlt(
    hdcSrc,
    0,
    0,
    Rect.right - Rect.left,
    Rect.bottom - Rect.top,
    hdcSrc,
    0,
    0,
    Rect.right - Rect.left,
    Rect.bottom - Rect.top,
    0xCC0020u);
  MapWindowPoints(v6, *(HWND *)(a1 + 104), (LPPOINT)&Rect, 2u);
  v11 = *(HWND *)(a1 + 104);
  pmbi.cbSize = 48;
  GetMenuBarInfo(v11, -3, 0, &pmbi);
  v12 = v17;
  v13 = Rect.top + pmbi.rcBar.bottom - pmbi.rcBar.top;
  *(_DWORD *)(a3 + 16) = Rect.left;
  *(_DWORD *)a3 = a2;
  *(_DWORD *)(a3 + 20) = v13;
  *(_QWORD *)(a3 + 8) = h;
  SelectObject(hdcSrc, v12);
  DeleteDC(hdcSrc);
  ReleaseDC(v6, DC);
  return GdipDisposeImage(v9);
}
// 1400E3D40: using guessed type __int64 __fastcall GdipDisposeImage(_QWORD);
// 1400E3D48: using guessed type __int64 __fastcall GdipCreateBitmapFromScan0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400E3D50: using guessed type __int64 __fastcall GdipCreateHBITMAPFromBitmap(_QWORD, _QWORD, _QWORD);

//----- (0000000140094A70) ----------------------------------------------------
HGDIOBJ __fastcall sub_140094A70(__int64 a1, int a2)
{
  HWND v3; // rbx
  HDC hdcSrc; // r14
  HDC CompatibleDC; // r13
  HDC DC; // r15
  HDC v7; // rdi
  BOOL v8; // esi
  HDC v9; // rsi
  HGDIOBJ v10; // rdi
  HGDIOBJ v11; // rbx
  HGDIOBJ v12; // rbx
  HGDIOBJ v14; // [rsp+50h] [rbp-39h] BYREF
  HGDIOBJ v15; // [rsp+58h] [rbp-31h] BYREF
  __int64 v16; // [rsp+60h] [rbp-29h] BYREF
  HGDIOBJ h; // [rsp+68h] [rbp-21h] BYREF
  HGDIOBJ ho; // [rsp+70h] [rbp-19h]
  __int64 v19; // [rsp+78h] [rbp-11h]
  struct tagPOINT pt; // [rsp+80h] [rbp-9h] BYREF
  struct tagRECT Rect; // [rsp+88h] [rbp-1h] BYREF
  struct tagRECT v22; // [rsp+98h] [rbp+Fh] BYREF

  v3 = *(HWND *)(a1 + 8i64 * a2 + 184);
  GetClientRect(*(HWND *)(a1 + 104), &Rect);
  GetClientRect(v3, &v22);
  hdcSrc = GetDC(*(HWND *)(a1 + 104));
  CompatibleDC = CreateCompatibleDC(hdcSrc);
  v16 = 0i64;
  GdipCreateBitmapFromScan0(
    (unsigned int)(Rect.right - Rect.left),
    (unsigned int)(Rect.bottom - Rect.top),
    0i64,
    2498570i64,
    0i64,
    &v16);
  v19 = v16;
  GdipCreateHBITMAPFromBitmap(v16, &h, 4278190080i64);
  SelectObject(CompatibleDC, h);
  BitBlt(CompatibleDC, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, hdcSrc, 0, 0, 0xCC0020u);
  DC = GetDC(v3);
  v7 = CreateCompatibleDC(DC);
  ho = CreateCompatibleBitmap(DC, v22.right - v22.left, v22.bottom - v22.top);
  v14 = SelectObject(v7, ho);
  v8 = IsWindowVisible(v3);
  if ( !v8 )
    ShowWindow(v3, 5);
  PrintWindow(v3, v7, 1u);
  if ( !v8 )
    ShowWindow(v3, 0);
  MapWindowPoints(v3, *(HWND *)(a1 + 104), (LPPOINT)&v22, 2u);
  BitBlt(CompatibleDC, v22.left, v22.top, v22.right - v22.left, v22.bottom - v22.top, v7, 0, 0, 0xCC0020u);
  SelectObject(v7, v14);
  DeleteObject(ho);
  DeleteDC(v7);
  ReleaseDC(v3, DC);
  v9 = CreateCompatibleDC(hdcSrc);
  v14 = 0i64;
  GdipCreateBitmapFromScan0(
    (unsigned int)(Rect.right - Rect.left),
    (unsigned int)(Rect.bottom - Rect.top),
    0i64,
    2498570i64,
    0i64,
    &v14);
  v10 = v14;
  GdipCreateHBITMAPFromBitmap(v14, &v15, 4278190080i64);
  v11 = SelectObject(v9, v15);
  SetStretchBltMode(v9, 4);
  SetBrushOrgEx(v9, 0, 0, &pt);
  BitBlt(v9, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, CompatibleDC, 0, 0, 0xCC0020u);
  SetBitmapDimensionEx((HBITMAP)v15, Rect.right - Rect.left, Rect.bottom - Rect.top, 0i64);
  SelectObject(v9, v11);
  DeleteDC(v9);
  DeleteObject(h);
  SelectObject(CompatibleDC, v11);
  DeleteDC(CompatibleDC);
  ReleaseDC(*(HWND *)(a1 + 104), hdcSrc);
  v12 = v15;
  GdipDisposeImage(v10);
  GdipDisposeImage(v19);
  return v12;
}
// 1400E3D40: using guessed type __int64 __fastcall GdipDisposeImage(_QWORD);
// 1400E3D48: using guessed type __int64 __fastcall GdipCreateBitmapFromScan0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400E3D50: using guessed type __int64 __fastcall GdipCreateHBITMAPFromBitmap(_QWORD, _QWORD, _QWORD);

//----- (0000000140094DD0) ----------------------------------------------------
void __fastcall sub_140094DD0(__int64 a1, int a2, __int64 *a3, int a4)
{
  WPARAM v4; // rbp
  HWND v6; // rcx
  _WORD *v9; // rdx
  __int64 v10; // r8
  _WORD *v11; // rcx
  __int64 v12; // r8
  __int64 v13; // rdx
  char *v14; // rcx
  __int64 v15; // r8
  __int16 v16; // ax
  HWND v17; // rcx
  LPARAM lParam[4]; // [rsp+20h] [rbp-268h] BYREF
  int v19; // [rsp+40h] [rbp-248h]
  char v20[512]; // [rsp+50h] [rbp-238h] BYREF

  v4 = a2;
  v6 = *(HWND *)(a1 + 80);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v6, 0x133Cu, a2, (LPARAM)lParam);
  if ( (unsigned __int64)a3[3] < 8 )
    v9 = a3;
  else
    v9 = (_WORD *)*a3;
  v10 = 260i64;
  v11 = (_WORD *)(532i64 * v19 + a1 + 7076);
  while ( v10 != -2147483386 && *v9 )
  {
    *v11++ = *v9++;
    if ( !--v10 )
    {
      --v11;
      break;
    }
  }
  *v11 = 0;
  *(_DWORD *)(532i64 * v19 + a1 + 7072) = a4;
  if ( (unsigned __int64)a3[3] < 8 )
    v12 = (__int64)a3;
  else
    v12 = *a3;
  v13 = 256i64;
  v14 = v20;
  v15 = v12 - (_QWORD)v20;
  while ( v13 != -2147483390 )
  {
    v16 = *(_WORD *)&v14[v15];
    if ( !v16 )
      break;
    *(_WORD *)v14 = v16;
    v14 += 2;
    if ( !--v13 )
    {
      v14 -= 2;
      break;
    }
  }
  *(_WORD *)v14 = 0;
  v17 = *(HWND *)(a1 + 80);
  LODWORD(lParam[0]) = 1;
  lParam[2] = (LPARAM)v20;
  SendMessageW(v17, 0x133Du, v4, (LPARAM)lParam);
  if ( (unsigned __int64)a3[3] >= 8 )
    j_free((void *)*a3);
  a3[3] = 7i64;
  a3[2] = 0i64;
  *(_WORD *)a3 = 0;
}
// 140094E6D: conditional instruction was optimized away because r8.8!=0
// 140094ED7: conditional instruction was optimized away because rdx.8!=0

//----- (0000000140094F50) ----------------------------------------------------
void __fastcall sub_140094F50(__int64 a1, int a2)
{
  __int64 v3; // rcx
  int v4; // ebx
  void *pv[2]; // [rsp+30h] [rbp-238h] BYREF
  char v6[528]; // [rsp+40h] [rbp-228h] BYREF

  v3 = *(_QWORD *)(a1 + 8i64 * a2 + 1832);
  (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v3 + 104i64))(v3, 260i64, v6);
  pv[0] = 0i64;
  v4 = sub_14007F810((__int64)v6, (__int64)pv);
  (*(void (__fastcall **)(__int64, void *, _QWORD, __int64, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    pv[0],
    0i64,
    1i64,
    0,
    0);
  if ( v4 >= 0 )
    CoTaskMemFree(pv[0]);
}
// 140094F50: using guessed type LPVOID pv[2];

//----- (0000000140095010) ----------------------------------------------------
void __fastcall sub_140095010(__int64 a1, int a2)
{
  HWND v3; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v5; // [rsp+40h] [rbp-18h]

  v3 = *(HWND *)(a1 + 136);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v3, 0x133Cu, a2, (LPARAM)lParam);
  sub_140094F50(a1, v5);
}
// 140095010: using guessed type LPARAM lParam[4];

//----- (0000000140095060) ----------------------------------------------------
__int64 __fastcall sub_140095060(__int64 a1, int a2, __int64 a3, LPARAM a4)
{
  DWORD MessagePos; // eax
  HWND v9; // rax
  HWND v10; // rcx
  unsigned int v11; // esi
  signed int i; // edi
  int v13; // ecx
  signed int v14; // edi
  int v15; // eax
  bool v16; // zf
  LPARAM v17; // r9
  __int64 v18; // r8
  UINT v19; // edx
  HWND v20; // rcx
  HWND Window; // rax
  HWND v22; // rbp
  int v23; // edi
  __int64 wParam[5]; // [rsp+20h] [rbp-28h] BYREF
  POINT Point; // [rsp+50h] [rbp+8h] BYREF
  LPARAM lParam; // [rsp+60h] [rbp+18h] BYREF

  *(_DWORD *)(a1 + 63264) += SWORD1(a3);
  MessagePos = GetMessagePos();
  Point.x = (__int16)MessagePos;
  Point.y = SHIWORD(MessagePos);
  v9 = WindowFromPoint(Point);
  v10 = *(HWND *)(a1 + 4800);
  v11 = 0;
  if ( v9 != v10 )
  {
    v10 = *(HWND *)(a1 + 152);
    if ( v9 != v10 )
    {
      v20 = *(HWND *)(a1 + 136);
      if ( v9 != v20 )
        goto LABEL_29;
      v11 = 1;
      Window = FindWindowExW(v20, 0i64, L"msctls_updown32", 0i64);
      v22 = Window;
      if ( !Window )
        goto LABEL_29;
      v23 = SendMessageW(Window, 0x472u, 0i64, (LPARAM)&Point);
      if ( !Point.x )
        goto LABEL_29;
      SendMessageW(v22, 0x470u, (WPARAM)wParam, (LPARAM)&lParam);
      if ( *(int *)(a1 + 63264) >= 0 )
      {
        if ( v23 > SLODWORD(wParam[0]) )
          LOWORD(v23) = v23 - 1;
      }
      else if ( v23 < (int)lParam )
      {
        LOWORD(v23) = v23 + 1;
      }
      v10 = *(HWND *)(a1 + 136);
      v19 = 276;
      v18 = ((unsigned __int16)v23 << 16) | 4i64;
      v17 = 0i64;
LABEL_28:
      SendMessageW(v10, v19, v18, v17);
      goto LABEL_29;
    }
    v16 = a2 == 1;
LABEL_15:
    if ( v16 )
      goto LABEL_29;
    v11 = 1;
    v17 = a4;
    v18 = a3;
    v19 = 522;
    goto LABEL_28;
  }
  if ( (a3 & 8) != 0 )
  {
    for ( i = 0; i < (int)abs32(*(_DWORD *)(a1 + 63264) / 120); ++i )
      sub_1400B1600(a1, *(_DWORD *)(a1 + 63264) > 0);
    goto LABEL_29;
  }
  if ( (a3 & 4) == 0 )
  {
    v16 = a2 == 0;
    goto LABEL_15;
  }
  v13 = *(_DWORD *)(a1 + 63264);
  v14 = 0;
  v15 = abs32(v13 / 120);
  if ( v13 >= 0 )
  {
    if ( v15 > 0 )
    {
      do
      {
        sub_1400B1460(a1);
        ++v14;
      }
      while ( v14 < (int)abs32(*(_DWORD *)(a1 + 63264) / 120) );
    }
  }
  else if ( v15 > 0 )
  {
    do
    {
      sub_1400B14E0(a1);
      ++v14;
    }
    while ( v14 < (int)abs32(*(_DWORD *)(a1 + 63264) / 120) );
  }
LABEL_29:
  if ( (int)abs32(*(_DWORD *)(a1 + 63264)) >= 120 )
    *(int *)(a1 + 63264) %= 120;
  return v11;
}
// 140095060: using guessed type WPARAM wParam[5];

//----- (0000000140095300) ----------------------------------------------------
void __fastcall sub_140095300(__int64 a1, int a2)
{
  HWND v4; // rcx
  int v5; // esi
  __int64 v6; // rax
  __int64 v7; // rcx
  WCHAR *v8; // rbx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v10; // [rsp+40h] [rbp-18h]

  v4 = *(HWND *)(a1 + 136);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v4, 0x133Cu, a2, (LPARAM)lParam);
  *(_DWORD *)(532i64 * v10 + a1 + 7124) = *(_DWORD *)(532i64 * v10 + a1 + 7124) == 0;
  v5 = v10;
  v6 = 532i64 * v10;
  if ( *(_DWORD *)(v6 + a1 + 7124) )
  {
    *(_DWORD *)(v6 + a1 + 7120) = 0;
    v5 = v10;
  }
  v7 = *(_QWORD *)(a1 + 8i64 * v5 + 1832);
  v8 = (WCHAR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 112i64))(v7);
  sub_1400D12A0(a1, a2, v5, v8);
  CoTaskMemFree(v8);
  if ( v10 == *(_DWORD *)(a1 + 7048) )
    sub_140094210(a1);
}
// 140095300: using guessed type LPARAM lParam[4];

//----- (00000001400953F0) ----------------------------------------------------
void __fastcall sub_1400953F0(__int64 a1, int a2, int a3)
{
  __int64 v6; // rcx
  BOOL v7; // eax
  __int64 v8; // rcx
  WCHAR *v9; // rbx

  v6 = 532i64 * a3;
  v7 = *(_DWORD *)(v6 + a1 + 7120) == 0;
  *(_DWORD *)(v6 + a1 + 7120) = v7;
  if ( v7 )
    *(_DWORD *)(v6 + a1 + 7124) = 0;
  v8 = *(_QWORD *)(a1 + 8i64 * a3 + 1832);
  v9 = (WCHAR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 112i64))(v8);
  sub_1400D12A0(a1, a2, a3, v9);
  CoTaskMemFree(v9);
  if ( a3 == *(_DWORD *)(a1 + 7048) )
    sub_140094210(a1);
}

//----- (0000000140095490) ----------------------------------------------------
void __fastcall sub_140095490(__int64 a1, int a2)
{
  HWND v4; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v6; // [rsp+40h] [rbp-18h]

  v4 = *(HWND *)(a1 + 136);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v4, 0x133Cu, a2, (LPARAM)lParam);
  sub_1400953F0(a1, a2, v6);
}
// 140095490: using guessed type LPARAM lParam[4];

//----- (00000001400954F0) ----------------------------------------------------
LRESULT __fastcall sub_1400954F0(__int64 a1, const ITEMIDLIST *a2, int a3, int a4)
{
  LPARAM v4; // rbp
  WPARAM v5; // r13
  __int64 v8; // rdi
  char *v9; // rcx
  signed __int64 v10; // rdx
  __int64 v11; // r11
  __int16 v12; // ax
  HWND v13; // rcx
  LRESULT result; // rax
  HWND v15; // rcx
  LPARAM lParam[5]; // [rsp+20h] [rbp-4A8h] BYREF
  struct tagRECT Rect; // [rsp+48h] [rbp-480h] BYREF
  WCHAR pszBuf[264]; // [rsp+60h] [rbp-468h] BYREF
  char v19[528]; // [rsp+270h] [rbp-258h] BYREF

  v4 = a4;
  v5 = a3;
  v8 = 532i64 * a4;
  if ( !*(_DWORD *)(v8 + a1 + 7128) )
  {
    sub_14007E270(a2, pszBuf, 1u);
    v9 = (char *)(v8 + a1 + 7132);
    v10 = (char *)pszBuf - v9;
    v11 = 260i64;
    while ( v11 != -2147483386 )
    {
      v12 = *(_WORD *)&v9[v10];
      if ( !v12 )
        break;
      *(_WORD *)v9 = v12;
      v9 += 2;
      if ( !--v11 )
      {
        v9 -= 2;
        break;
      }
    }
    *(_WORD *)v9 = 0;
  }
  sub_140083870((LPCWSTR)(v8 + a1 + 7132), v19, (__int64)L"&&");
  v13 = *(HWND *)(a1 + 136);
  lParam[2] = (LPARAM)v19;
  LODWORD(lParam[0]) = 9;
  lParam[4] = v4;
  SendMessageW(v13, 0x133Eu, v5, (LPARAM)lParam);
  result = sub_1400D12A0(a1, v5, v4, &a2->mkid.cb);
  if ( !*(_DWORD *)(a1 + 60776) )
  {
    result = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
    if ( (int)result > 1 )
    {
      v15 = *(HWND *)(a1 + 104);
      *(_DWORD *)(a1 + 60780) = 1;
      GetClientRect(v15, &Rect);
      return SendMessageW(
               *(HWND *)(a1 + 104),
               5u,
               0i64,
               LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
    }
  }
  return result;
}
// 140095586: conditional instruction was optimized away because r11.8!=0
// 1400EEFA4: using guessed type wchar_t asc_1400EEFA4[3];

//----- (0000000140095680) ----------------------------------------------------
__int64 __fastcall sub_140095680(__int64 a1)
{
  __int64 v2; // rbx
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rax
  HICON v5; // rax
  ICONINFO piconinfo; // [rsp+30h] [rbp-28h] BYREF

  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  v5 = (HICON)sub_14000A470(v2, 0x1Du, 1u);
  GetIconInfo(v5, &piconinfo);
  sub_1400012C0(a1, (__int64)piconinfo.hbmColor, (__int64)piconinfo.hbmMask);
  DeleteObject(piconinfo.hbmColor);
  DeleteObject(piconinfo.hbmMask);
  return sub_14000A390(v2);
}

//----- (0000000140095730) ----------------------------------------------------
_QWORD *__fastcall sub_140095730(__int64 a1, _QWORD *a2, int a3)
{
  HWND v4; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  _WORD *v8; // rdx
  _WORD *v9; // rdi
  bool v10; // zf
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v13; // [rsp+40h] [rbp-18h]

  v4 = *(HWND *)(a1 + 80);
  LODWORD(lParam[0]) = 8;
  SendMessageW(v4, 0x133Cu, a3, (LPARAM)lParam);
  v6 = v13;
  v7 = -1i64;
  a2[3] = 7i64;
  a2[2] = 0i64;
  *(_WORD *)a2 = 0;
  v8 = (_WORD *)(532 * v6 + a1 + 7076);
  v9 = v8;
  do
  {
    if ( !v7 )
      break;
    v10 = *v9++ == 0;
    --v7;
  }
  while ( !v10 );
  sub_1400099E0(a2, v8, -v7 - 2);
  return a2;
}
// 140095730: using guessed type LPARAM lParam[4];

//----- (00000001400957D0) ----------------------------------------------------
int __fastcall sub_1400957D0(__int64 a1, int a2)
{
  WPARAM v2; // r8
  HWND v4; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  _QWORD *v8; // rax
  _QWORD *v9; // rdi
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  HWND v13; // rcx
  _QWORD *v14; // r11
  _QWORD *v15; // rbx
  int v17[8]; // [rsp+20h] [rbp-58h] BYREF
  int v18; // [rsp+40h] [rbp-38h]
  __int64 lParam[4]; // [rsp+48h] [rbp-30h] BYREF
  int v20; // [rsp+68h] [rbp-10h]

  v2 = *(int *)(a1 + 7060);
  v4 = *(HWND *)(a1 + 136);
  v17[0] = 8;
  SendMessageW(v4, 0x133Cu, v2, (LPARAM)v17);
  ShowWindow(*(HWND *)(a1 + 4800), 0);
  v6 = v18;
  *(_DWORD *)(a1 + 7048) = v18;
  *(_QWORD *)(a1 + 4800) = *(_QWORD *)(a1 + 8 * v6 + 184);
  v7 = *(_QWORD *)(a1 + 8 * v6 + 1832);
  *(_QWORD *)(a1 + 2640) = v7;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v7 + 104i64))(v7, 260i64, a1 + 4920);
  SetCurrentDirectoryW((LPCWSTR)(a1 + 4920));
  *(_DWORD *)(a1 + 62416) = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 584i64))(*(_QWORD *)(a1 + 2640));
  sub_1400CBF40(a1);
  sub_1400CCA00(a1);
  sub_1400D1700(a1);
  LODWORD(v8) = ShowWindow(*(HWND *)(a1 + 4800), 5);
  if ( *(_DWORD *)(a1 + 61028) )
  {
    v8 = *(_QWORD **)(a1 + 61000);
    v9 = (_QWORD *)*v8;
    if ( (_QWORD *)*v8 != v8 )
    {
      LODWORD(v8) = *(_DWORD *)(a1 + 7048);
      while ( *((_DWORD *)v9 + 8) != (_DWORD)v8 )
      {
        v9 = (_QWORD *)*v9;
        if ( v9 == *(_QWORD **)(a1 + 61000) )
          goto LABEL_14;
      }
      v10 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
      v11 = *(_DWORD *)(a1 + 7060);
      if ( v11 == v10 - 1 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 60992) + 104i64))(
          *(_QWORD *)(a1 + 60992),
          v9[3],
          0i64);
      }
      else
      {
        v12 = v11 + 1;
        v13 = *(HWND *)(a1 + 136);
        LODWORD(lParam[0]) = 8;
        SendMessageW(v13, 0x133Cu, v12, (LPARAM)lParam);
        v14 = *(_QWORD **)(a1 + 61000);
        v15 = (_QWORD *)*v14;
        if ( (_QWORD *)*v14 != v14 )
        {
          do
          {
            if ( *((_DWORD *)v15 + 8) == v20 )
              (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 60992) + 104i64))(
                *(_QWORD *)(a1 + 60992),
                v9[3],
                v15[3]);
            v15 = (_QWORD *)*v15;
          }
          while ( v15 != *(_QWORD **)(a1 + 61000) );
        }
      }
      LODWORD(v8) = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 60992) + 112i64))(
                      *(_QWORD *)(a1 + 60992),
                      v9[3],
                      *(_QWORD *)(a1 + 104),
                      0i64);
    }
  }
LABEL_14:
  if ( a2 )
    LODWORD(v8) = (unsigned int)SetFocus(*(HWND *)(a1 + 4800));
  return (int)v8;
}
// 1400957D0: using guessed type LPARAM lParam[4];
// 1400957D0: using guessed type int anonymous_0[8];

//----- (00000001400959D0) ----------------------------------------------------
int __fastcall sub_1400959D0(__int64 a1)
{
  *(_DWORD *)(a1 + 7060) = SendMessageW(*(HWND *)(a1 + 136), 0x130Bu, 0i64, 0i64);
  return sub_1400957D0(a1, 1);
}

//----- (0000000140095A10) ----------------------------------------------------
void __fastcall sub_140095A10(__int64 a1, int a2)
{
  __int64 v2; // rbp
  __int64 v4; // rcx
  void *v5; // rdi

  v2 = a2;
  v4 = *(_QWORD *)(a1 + 8i64 * a2 + 1776);
  v5 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 112i64))(v4);
  if ( (*(int (__fastcall **)(_QWORD, void *, __int64))(**(_QWORD **)(a1 + 8 * v2 + 1776) + 24i64))(
         *(_QWORD *)(a1 + 8 * v2 + 1776),
         v5,
         134217729i64) >= 0 )
    sub_1400B3BC0(a1 - 56, v2);
  CoTaskMemFree(v5);
}

//----- (0000000140095A90) ----------------------------------------------------
__int64 __fastcall sub_140095A90(__int64 a1, int a2)
{
  WPARAM v3; // rbx
  int v4; // er12
  HWND v6; // rcx
  __int64 v7; // rdi
  WPARAM v8; // r13
  __int64 v9; // rax
  __int64 v10; // r14
  int v11; // ecx
  int v12; // eax
  HWND v13; // rcx
  WPARAM v14; // r8
  UINT v15; // edx
  int v16; // eax
  void **v17; // rax
  void **v18; // rbx
  void *WindowLongPtrW; // rdi
  HICON ClassLongPtrW; // rdi
  HMODULE ModuleHandleW; // rax
  __int64 v22; // rbx
  unsigned int v23; // eax
  __int64 v24; // rcx
  HWND v25; // rcx
  __int64 lParam[3]; // [rsp+20h] [rbp-78h] BYREF
  int v27; // [rsp+3Ch] [rbp-5Ch]
  int v28; // [rsp+40h] [rbp-58h]
  struct tagRECT Rect; // [rsp+48h] [rbp-50h] BYREF

  v3 = a2;
  v4 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( v4 == 1 )
  {
    if ( *(_DWORD *)(a1 + 60884) )
      SendMessageW(*(HWND *)(a1 + 104), 0x10u, 0i64, 0i64);
    return 0i64;
  }
  else
  {
    v6 = *(HWND *)(a1 + 136);
    LODWORD(lParam[0]) = 10;
    SendMessageW(v6, 0x133Cu, v3, (LPARAM)lParam);
    v7 = v28;
    v8 = v27;
    v9 = 532i64 * v28;
    if ( *(_DWORD *)(v9 + a1 + 7120) || *(_DWORD *)(v9 + a1 + 7124) )
    {
      return 1i64;
    }
    else
    {
      EnterCriticalSection(&stru_14012D7C0);
      v10 = v7;
      *(_DWORD *)(a1 + 4 * v7 + 60320) = 0;
      LeaveCriticalSection(&stru_14012D7C0);
      v11 = *(_DWORD *)(a1 + 7060);
      if ( (_DWORD)v3 == v11 )
      {
        if ( (_DWORD)v3 == v4 - 1 )
        {
          v12 = v11 - 1;
          v13 = *(HWND *)(a1 + 136);
          *(_DWORD *)(a1 + 7060) = v12;
          SendMessageW(v13, 0x130Cu, v12, 0i64);
          v14 = v3;
          v15 = 4872;
        }
        else
        {
          SendMessageW(*(HWND *)(a1 + 136), 0x1308u, v3, 0i64);
          v14 = *(int *)(a1 + 7060);
          v15 = 4876;
        }
        SendMessageW(*(HWND *)(a1 + 136), v15, v14, 0i64);
        sub_1400957D0(a1, 1);
      }
      else
      {
        SendMessageW(*(HWND *)(a1 + 136), 0x1308u, v3, 0i64);
        v16 = *(_DWORD *)(a1 + 7060);
        if ( (int)v3 < v16 )
          *(_DWORD *)(a1 + 7060) = v16 - 1;
      }
      SendMessageW(*(HWND *)(a1 + 136), 0x132Au, v8, 0i64);
      if ( *(_DWORD *)(a1 + 61028) )
      {
        v17 = *(void ***)(a1 + 61000);
        v18 = (void **)*v17;
        if ( *v17 != v17 )
        {
          while ( *((_DWORD *)v18 + 8) != (_DWORD)v7 )
          {
            v18 = (void **)*v18;
            if ( v18 == v17 )
              goto LABEL_21;
          }
          (*(void (__fastcall **)(_QWORD, void *))(**(_QWORD **)(a1 + 60992) + 96i64))(*(_QWORD *)(a1 + 60992), v18[3]);
          WindowLongPtrW = (void *)GetWindowLongPtrW((HWND)v18[3], -21);
          DestroyWindow((HWND)v18[3]);
          free(WindowLongPtrW);
          ClassLongPtrW = (HICON)GetClassLongPtrW((HWND)v18[3], -34);
          ModuleHandleW = GetModuleHandleW(0i64);
          sub_14001A910((LPCWSTR)*((unsigned __int8 *)v18 + 16), ModuleHandleW);
          DestroyIcon(ClassLongPtrW);
          if ( v18 != *(void ***)(a1 + 61000) )
          {
            *(_QWORD *)v18[1] = *v18;
            *((_QWORD *)*v18 + 1) = v18[1];
            j_free(v18);
            --*(_QWORD *)(a1 + 61008);
          }
        }
      }
LABEL_21:
      v22 = **(_QWORD **)(a1 + 2648);
      v23 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v10 + 1832) + 328i64))(*(_QWORD *)(a1 + 8 * v10 + 1832));
      (*(void (__fastcall **)(_QWORD, _QWORD))(v22 + 40))(*(_QWORD *)(a1 + 2648), v23);
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v10 + 1032) + 104i64))(*(_QWORD *)(a1 + 8 * v10 + 1032));
      DestroyWindow(*(HWND *)(a1 + 8 * v10 + 184));
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v10 + 1832) + 16i64))(*(_QWORD *)(a1 + 8 * v10 + 1832));
      v24 = *(_QWORD *)(a1 + 8 * v10 + 1032);
      *(_QWORD *)(a1 + 8 * v10 + 1832) = 0i64;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 16i64))(v24);
      *(_QWORD *)(a1 + 8 * v10 + 1032) = 0i64;
      sub_140094210(a1);
      if ( !*(_DWORD *)(a1 + 60776) && (unsigned int)SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) == 1 )
      {
        v25 = *(HWND *)(a1 + 104);
        *(_DWORD *)(a1 + 60780) = 0;
        GetClientRect(v25, &Rect);
        SendMessageW(*(HWND *)(a1 + 104), 5u, 0i64, LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
      }
      return 0i64;
    }
  }
}
// 140095A90: using guessed type LPARAM lParam[3];

//----- (0000000140095E30) ----------------------------------------------------
__int64 __fastcall sub_140095E30(__int64 a1)
{
  int v2; // eax

  v2 = SendMessageW(*(HWND *)(a1 + 136), 0x130Bu, 0i64, 0i64);
  return sub_140095A90(a1, v2);
}

//----- (0000000140095E70) ----------------------------------------------------
int __fastcall sub_140095E70(__int64 a1, int a2, int a3)
{
  int v6; // eax

  v6 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( a2 == -1 || a2 >= v6 )
    *(_DWORD *)(a1 + 7060) = v6 - 1;
  else
    *(_DWORD *)(a1 + 7060) = a2;
  SendMessageW(*(HWND *)(a1 + 136), 0x130Cu, *(int *)(a1 + 7060), 0i64);
  return sub_1400957D0(a1, a3);
}

//----- (0000000140095F20) ----------------------------------------------------
int __fastcall sub_140095F20(__int64 a1, int a2)
{
  int v4; // eax
  int v5; // er11
  int v6; // ecx
  int v7; // eax
  int v8; // eax

  v4 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  v5 = v4;
  if ( !a2 )
  {
    v8 = *(_DWORD *)(a1 + 7060);
    if ( v8 )
      v7 = v8 - 1;
    else
      v7 = v5 - 1;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(a1 + 7060);
  if ( v6 != v4 - 1 )
  {
    v7 = v6 + 1;
LABEL_8:
    *(_DWORD *)(a1 + 7060) = v7;
    goto LABEL_9;
  }
  *(_DWORD *)(a1 + 7060) = 0;
LABEL_9:
  SendMessageW(*(HWND *)(a1 + 136), 0x130Cu, *(int *)(a1 + 7060), 0i64);
  return sub_1400957D0(a1, 1);
}

//----- (0000000140095FC0) ----------------------------------------------------
LRESULT __fastcall sub_140095FC0(__int64 a1, int a2)
{
  LRESULT result; // rax
  int i; // ebx

  result = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  for ( i = result - 1; i >= 0; --i )
  {
    if ( i != a2 )
      result = sub_140095A90(a1, i);
  }
  return result;
}

//----- (0000000140096020) ----------------------------------------------------
LRESULT __fastcall sub_140096020(__int64 a1, HWND a2, UINT a3, WPARAM a4, LPARAM a5, int a6)
{
  int v10; // eax
  int v11; // ebx
  int v12; // edi
  HMODULE v14; // rax
  HMODULE v15; // rbx
  HRESULT (__stdcall *DwmSetIconicLivePreviewBitmap)(HWND, HBITMAP, POINT *, DWORD); // rax
  unsigned int v17; // er12
  unsigned int v18; // er13
  HMODULE ModuleHandleW; // rax
  HBITMAP ImageW; // rbp
  int wSrc; // er15
  LONG cy; // ebx
  int v23; // ebx
  int v24; // eax
  HDC v25; // rbx
  HDC v26; // rbx
  HDC v27; // rdi
  HGDIOBJ v28; // r12
  HMODULE v29; // rax
  HMODULE v30; // rdi
  HRESULT (__stdcall *DwmSetIconicThumbnail)(HWND, HBITMAP, DWORD); // rax
  HGDIOBJ h; // [rsp+60h] [rbp-98h] BYREF
  void *v33; // [rsp+68h] [rbp-90h] BYREF
  HDC hdc; // [rsp+70h] [rbp-88h]
  struct tagSIZE size; // [rsp+78h] [rbp-80h] BYREF
  HDC hdcDest; // [rsp+80h] [rbp-78h]
  LPARAM lParam; // [rsp+88h] [rbp-70h] BYREF
  HGDIOBJ ho; // [rsp+90h] [rbp-68h]
  int v39[6]; // [rsp+98h] [rbp-60h] BYREF
  HGDIOBJ v40; // [rsp+B0h] [rbp-48h]
  HDC hdcSrc; // [rsp+B8h] [rbp-40h]
  struct tagPOINT pt; // [rsp+C0h] [rbp-38h] BYREF
  __int64 v43; // [rsp+C8h] [rbp-30h]
  LONG hSrc; // [rsp+110h] [rbp+18h]

  v43 = -2i64;
  if ( a3 > 0x112 )
  {
    if ( a3 == 803 )
    {
      v17 = WORD1(a5);
      v18 = (unsigned __int16)a5;
      if ( IsIconic(*(HWND *)(a1 + 104)) )
      {
        ModuleHandleW = GetModuleHandleW(0i64);
        ImageW = (HBITMAP)LoadImageW(ModuleHandleW, (LPCWSTR)0xEC, 0, 0, 0, 0);
        SetBitmapDimensionEx(ImageW, 223, 130, 0i64);
      }
      else
      {
        ImageW = (HBITMAP)sub_140094A70(a1, a6);
      }
      GetBitmapDimensionEx(ImageW, &size);
      wSrc = size.cx;
      cy = size.cy;
      hSrc = size.cy;
      hdc = GetDC(*(HWND *)(a1 + 104));
      hdcSrc = CreateCompatibleDC(hdc);
      SelectObject(hdcSrc, ImageW);
      hdcDest = CreateCompatibleDC(hdc);
      if ( wSrc / WORD1(a5) <= cy / (unsigned __int16)a5 )
        v17 = (unsigned __int16)a5 * wSrc / cy;
      else
        v18 = WORD1(a5) * cy / wSrc;
      lParam = (LPARAM)&Gdiplus::Bitmap::`vftable';
      v33 = 0i64;
      v23 = GdipCreateBitmapFromScan0(v17, v18, 0i64, 2498570i64, 0i64, &v33);
      ho = v33;
      v24 = GdipCreateHBITMAPFromBitmap(v33, &h, 4278190080i64);
      if ( v24 )
        v23 = v24;
      v39[0] = v23;
      v25 = hdcDest;
      v40 = SelectObject(hdcDest, h);
      SetStretchBltMode(v25, 4);
      SetBrushOrgEx(v25, 0, 0, &pt);
      v26 = hdcSrc;
      v27 = hdcDest;
      StretchBlt(hdcDest, 0, 0, v17, v18, hdcSrc, 0, 0, wSrc, hSrc, 0xCC0020u);
      v28 = v40;
      SelectObject(v27, v40);
      DeleteDC(v27);
      v29 = sub_14000AF70(L"dwmapi.dll");
      v30 = v29;
      if ( v29 )
      {
        DwmSetIconicThumbnail = (HRESULT (__stdcall *)(HWND, HBITMAP, DWORD))GetProcAddress(
                                                                               v29,
                                                                               "DwmSetIconicThumbnail");
        if ( DwmSetIconicThumbnail )
          ((void (__fastcall *)(HWND, HGDIOBJ, _QWORD))DwmSetIconicThumbnail)(a2, h, 0i64);
      }
      FreeLibrary(v30);
      DeleteObject(ImageW);
      SelectObject(v26, v28);
      DeleteObject(h);
      DeleteDC(v26);
      ReleaseDC(*(HWND *)(a1 + 104), hdc);
      GdipDisposeImage(v33);
      return 0i64;
    }
    if ( a3 == 806 )
    {
      ho = 0i64;
      if ( !IsIconic(*(HWND *)(a1 + 104)) )
        sub_140094820(a1, a6, (__int64)&lParam);
      v14 = sub_14000AF70(L"dwmapi.dll");
      v15 = v14;
      if ( v14 )
      {
        DwmSetIconicLivePreviewBitmap = (HRESULT (__stdcall *)(HWND, HBITMAP, POINT *, DWORD))GetProcAddress(
                                                                                                v14,
                                                                                                "DwmSetIconicLivePreviewBitmap");
        if ( DwmSetIconicLivePreviewBitmap )
          ((void (__fastcall *)(HWND, HGDIOBJ, int *, _QWORD))DwmSetIconicLivePreviewBitmap)(a2, ho, v39, 0i64);
      }
      FreeLibrary(v15);
      if ( ho )
        DeleteObject(ho);
      return 0i64;
    }
    return DefWindowProcW(a2, a3, a4, a5);
  }
  if ( a3 == 274 )
  {
    if ( a4 != 61536 )
      SendMessageW(*(HWND *)(a1 + 8i64 * a6 + 184), 0x112u, a4, a5);
    return DefWindowProcW(a2, a3, a4, a5);
  }
  if ( a3 != 6 )
  {
    if ( a3 == 7 )
    {
      SetFocus(*(HWND *)(a1 + 8i64 * a6 + 184));
    }
    else if ( a3 == 16 )
    {
      v10 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
      v11 = v10;
      if ( v10 == 1 )
      {
        SendMessageW(*(HWND *)(a1 + 104), 0x10u, 0i64, 0i64);
      }
      else
      {
        v12 = 0;
        if ( v10 > 0 )
        {
          while ( 1 )
          {
            LODWORD(lParam) = 8;
            SendMessageW(*(HWND *)(a1 + 136), 0x133Cu, v12, (LPARAM)&lParam);
            if ( v39[4] == a6 )
              break;
            if ( ++v12 >= v11 )
              return DefWindowProcW(a2, a3, a4, a5);
          }
          sub_140095A90(a1, v12);
        }
      }
    }
    return DefWindowProcW(a2, a3, a4, a5);
  }
  if ( IsIconic(*(HWND *)(a1 + 104)) )
    ShowWindow(*(HWND *)(a1 + 104), 9);
  sub_140095E70(a1, a6, 0);
  return 0i64;
}
// 1400E3D40: using guessed type __int64 __fastcall GdipDisposeImage(_QWORD);
// 1400E3D48: using guessed type __int64 __fastcall GdipCreateBitmapFromScan0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400E3D50: using guessed type __int64 __fastcall GdipCreateHBITMAPFromBitmap(_QWORD, _QWORD, _QWORD);
// 1400F78E8: using guessed type void *Gdiplus::Bitmap::`vftable';

//----- (0000000140096530) ----------------------------------------------------
LRESULT __fastcall sub_140096530(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG_PTR WindowLongPtrW; // rbx

  WindowLongPtrW = GetWindowLongPtrW(hWnd, -21);
  if ( Msg == 1 )
  {
    WindowLongPtrW = *(_QWORD *)lParam;
    SetWindowLongPtrW(hWnd, -21, *(_QWORD *)lParam);
  }
  if ( WindowLongPtrW )
    return sub_140096020(*(_QWORD *)WindowLongPtrW, hWnd, Msg, wParam, lParam, *(_DWORD *)(WindowLongPtrW + 8));
  else
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (00000001400965E0) ----------------------------------------------------
__int64 __fastcall sub_1400965E0(const WCHAR *a1)
{
  WNDCLASSEXW v3; // [rsp+20h] [rbp-58h] BYREF

  *(_QWORD *)&v3.cbSize = 80i64;
  v3.cbWndExtra = 8;
  v3.lpfnWndProc = (WNDPROC)sub_140096530;
  v3.cbClsExtra = 0;
  v3.hIcon = 0i64;
  v3.hInstance = GetModuleHandleW(0i64);
  v3.hIconSm = 0i64;
  v3.hbrBackground = 0i64;
  v3.lpszMenuName = 0i64;
  v3.hCursor = LoadCursorW(0i64, (LPCWSTR)0x7F00);
  v3.lpszClassName = a1;
  return sub_14001A9F0(&v3);
}

//----- (0000000140096670) ----------------------------------------------------
void __fastcall sub_140096670(__int64 a1, unsigned int a2, int a3)
{
  int i; // ebx
  __int64 v6; // rax
  HWND v7; // r8
  HINSTANCE v8; // r10
  __int64 v9; // rdi
  _QWORD **v10; // rax
  _QWORD *v11; // rcx
  _QWORD *v12; // rbx
  HWND v13; // rcx
  __int64 v14; // rcx
  ITEMIDLIST *v15; // rsi
  void *v16; // rbx
  LPVOID pv; // [rsp+30h] [rbp-D0h] BYREF
  __int64 lParam[4]; // [rsp+38h] [rbp-C8h] BYREF
  int v19; // [rsp+58h] [rbp-A8h]
  __int64 dwInitParam[2]; // [rsp+60h] [rbp-A0h] BYREF
  HINSTANCE v21; // [rsp+70h] [rbp-90h]
  int v22; // [rsp+78h] [rbp-88h]
  HWND hWndParent; // [rsp+80h] [rbp-80h]
  int v24; // [rsp+90h] [rbp-70h]
  char v25; // [rsp+94h] [rbp-6Ch]
  __int64 v26; // [rsp+A8h] [rbp-58h]
  __int64 *v27; // [rsp+B0h] [rbp-50h]
  __int64 v28; // [rsp+B8h] [rbp-48h]
  int v29; // [rsp+C0h] [rbp-40h]

  if ( a2 <= 0x9D3B )
  {
    switch ( a2 )
    {
      case 0x9D3Bu:
        sub_140095A90(a1, a3);
        return;
      case 0x9CDAu:
        sub_140095FC0(a1, a3);
        return;
      case 0x9CDFu:
        sub_1400945C0(a1);
        return;
      case 0x9D37u:
        sub_140095010(a1, a3);
        return;
      case 0x9D39u:
        sub_140095490(a1, a3);
        return;
      case 0x9D3Au:
        (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 32i64))(a1 + 56, (unsigned int)a3);
        return;
    }
    goto LABEL_18;
  }
  switch ( a2 )
  {
    case 0x9D3Du:
      sub_140095300(a1, a3);
      break;
    case 0x9D7Fu:
      v13 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v13, 0x133Cu, a3, (LPARAM)lParam);
      v14 = *(_QWORD *)(a1 + 8i64 * v19 + 1832);
      v15 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 112i64))(v14);
      pv = 0i64;
      if ( (int)sub_14007DFF0(v15, (LPITEMIDLIST *)&pv) >= 0 )
      {
        v16 = pv;
        (*(void (__fastcall **)(__int64, LPVOID, _QWORD, __int64, int, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
          a1 + 56,
          pv,
          0i64,
          1i64,
          1,
          0);
        CoTaskMemFree(v16);
      }
      CoTaskMemFree(v15);
      break;
    case 0x9D81u:
      v6 = a1 + 56;
      if ( !a1 )
        v6 = 0i64;
      v7 = *(HWND *)(a1 + 104);
      v8 = hInstance;
      v28 = v6;
      v21 = hInstance;
      v22 = 213;
      hWndParent = v7;
      v25 = 0;
      v26 = 0i64;
      v24 = 0;
      dwInitParam[0] = (__int64)&CRenameTabDialog::`vftable';
      v29 = a3;
      if ( (dword_140130A38 & 1) == 0 )
      {
        dword_140130A38 |= 1u;
        sub_1400A2DD0();
        atexit(sub_1400E1FC0);
        v7 = hWndParent;
        v8 = v21;
      }
      v27 = &qword_14012F400;
      DialogBoxParamW(v8, (LPCWSTR)(unsigned __int16)v22, v7, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
      v9 = v26;
      dwInitParam[0] = (__int64)&CBaseDialog::`vftable';
      if ( v26 )
      {
        v10 = *(_QWORD ***)(v26 + 8);
        v11 = *v10;
        *v10 = v10;
        *(_QWORD *)(*(_QWORD *)(v9 + 8) + 8i64) = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 16) = 0i64;
        if ( v11 != *(_QWORD **)(v9 + 8) )
        {
          do
          {
            v12 = (_QWORD *)*v11;
            j_free(v11);
            v11 = v12;
          }
          while ( v12 != *(_QWORD **)(v9 + 8) );
        }
        j_free(*(void **)(v9 + 8));
        j_free((void *)v9);
      }
      break;
    case 0x9DEDu:
      for ( i = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) - 1; i > a3; --i )
        sub_140095A90(a1, i);
      break;
    default:
LABEL_18:
      SendMessageW(
        *(HWND *)(a1 + 104),
        0x111u,
        (unsigned __int16)a2 | (unsigned __int64)((unsigned __int16)a3 << 16),
        0i64);
      return;
  }
}
// 140096821: conditional instruction was optimized away because ecx.4==0
// 1400F74D8: using guessed type void *CRenameTabDialog::`vftable';
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';
// 14012F400: using guessed type __int64 qword_14012F400;
// 140130A38: using guessed type int dword_140130A38;
// 140096670: using guessed type LPARAM var_290[2];
// 140096670: using guessed type LPARAM lParam[4];

//----- (0000000140096960) ----------------------------------------------------
void __fastcall sub_140096960(__int64 a1, int a2)
{
  HWND v3; // rcx
  int v4; // edi
  int y; // er9
  int x; // er8
  HMENU v7; // rcx
  unsigned int v8; // eax
  HWND hWnd; // [rsp+28h] [rbp-40h]
  struct tagPOINT Point; // [rsp+40h] [rbp-28h] BYREF
  LPARAM lParam; // [rsp+48h] [rbp-20h] BYREF
  int v12; // [rsp+50h] [rbp-18h]

  v3 = *(HWND *)(a1 + 136);
  Point.x = (unsigned __int16)a2;
  Point.y = HIWORD(a2);
  lParam = (LPARAM)Point;
  v4 = SendMessageW(v3, 0x130Du, 0i64, (LPARAM)&lParam);
  if ( v12 != 1 )
  {
    ClientToScreen(*(HWND *)(a1 + 136), &Point);
    y = Point.y;
    x = Point.x;
    v7 = *(HMENU *)(a1 + 4872);
    hWnd = *(HWND *)(a1 + 136);
    *(_DWORD *)(a1 + 62492) = v4;
    v8 = TrackPopupMenu(v7, 0x142u, x, y, 0, hWnd, 0i64);
    sub_140096670(a1, v8, v4);
  }
}

//----- (0000000140096A40) ----------------------------------------------------
__int64 __fastcall sub_140096A40(__int64 a1, HWND a2, unsigned int a3, HMENU a4, LPARAM lParam)
{
  DWORD MessagePos; // eax
  HWND v10; // rcx
  int v11; // eax
  struct tagPOINT Point; // [rsp+20h] [rbp-48h] BYREF
  _DWORD v14[4]; // [rsp+28h] [rbp-40h] BYREF

  if ( a3 > 0x200 )
  {
    switch ( a3 )
    {
      case 0x201u:
        sub_140094440(a1, lParam);
        break;
      case 0x202u:
        sub_140094400(a1);
        break;
      case 0x203u:
        MessagePos = GetMessagePos();
        Point.x = (__int16)MessagePos;
        Point.y = SHIWORD(MessagePos);
        ScreenToClient(a2, &Point);
        v10 = *(HWND *)(a1 + 136);
        v14[0] = (unsigned __int16)lParam;
        v14[1] = WORD1(lParam);
        v11 = SendMessageW(v10, 0x130Du, 0i64, (LPARAM)v14);
        if ( v14[2] != 1 && *(_DWORD *)(a1 + 60860) )
          sub_140095A90(a1, v11);
        break;
      case 0x205u:
        sub_140096960(a1, lParam);
        break;
      case 0x208u:
        SendMessageW(*(HWND *)(a1 + 104), 0x8035u, (WPARAM)a4, lParam);
        break;
      case 0x215u:
        if ( (HWND)lParam != a2 )
          ReleaseCapture();
        *(_DWORD *)(a1 + 62472) = 0;
        break;
      default:
        return sub_140001A20((__int64)a2, a3, (__int64)a4, lParam);
    }
  }
  else
  {
    switch ( a3 )
    {
      case 0x200u:
        sub_140094290(a1, lParam);
        break;
      case 0x2Bu:
        SendMessageW(*(HWND *)(a1 + 104), 0x2Bu, (WPARAM)a4, lParam);
        break;
      case 0x2Cu:
        SendMessageW(*(HWND *)(a1 + 104), 0x2Cu, (WPARAM)a4, lParam);
        break;
      case 0x116u:
        sub_1400944E0(a1, a4);
        SendMessageW(*(HWND *)(a1 + 104), 0x116u, (WPARAM)a4, lParam);
        break;
      case 0x11Fu:
        SendMessageW(*(HWND *)(a1 + 104), 0x11Fu, (WPARAM)a4, lParam);
        break;
    }
  }
  return sub_140001A20((__int64)a2, a3, (__int64)a4, lParam);
}

//----- (0000000140096C90) ----------------------------------------------------
__int64 __fastcall sub_140096C90(HWND a1, unsigned int a2, HMENU a3, LPARAM a4, int a5, __int64 a6)
{
  return sub_140096A40(a6, a1, a2, a3, a4);
}

//----- (0000000140096CC0) ----------------------------------------------------
int __fastcall sub_140096CC0(__int64 a1, int a2, int a3)
{
  HMODULE v3; // rax
  bool v7; // cf
  __int64 v8; // r9
  __int16 v9; // r14
  _DWORD *v10; // rax
  void *v11; // rbx
  HMODULE ModuleHandleW; // rax
  __int64 v13; // rbp
  HMODULE v14; // rbx
  HRESULT (__stdcall *DwmSetWindowAttribute)(HWND, DWORD, LPCVOID, DWORD); // rax
  HRESULT (__stdcall *v16)(HWND, DWORD, LPCVOID, DWORD); // rsi
  __int64 v17; // rsi
  __int64 v18; // rdx
  char *v19; // r11
  __int64 v20; // rax
  int v22; // [rsp+50h] [rbp-4A8h] BYREF
  _QWORD v23[2]; // [rsp+58h] [rbp-4A0h] BYREF
  int v24; // [rsp+68h] [rbp-490h]
  WNDCLASSEXW v25; // [rsp+70h] [rbp-488h] BYREF
  WCHAR ClassName[512]; // [rsp+C0h] [rbp-438h] BYREF

  LODWORD(v3) = *(_DWORD *)(a1 + 7004);
  v22 = 1;
  v7 = (unsigned int)v3 < 6;
  if ( (_DWORD)v3 == 6 )
  {
    if ( !*(_DWORD *)(a1 + 7008) )
      return (int)v3;
    v7 = 0;
  }
  if ( !v7 )
  {
    if ( *(_DWORD *)(a1 + 60892) )
    {
      v8 = (unsigned int)dword_14012E1B0++;
      sub_140001000(ClassName, 0x200ui64, L"Explorer++TabProxy%d", v8);
      *(_QWORD *)&v25.cbSize = 80i64;
      v25.cbClsExtra = 0;
      v25.lpfnWndProc = (WNDPROC)sub_140096530;
      v25.cbWndExtra = 8;
      v25.hIcon = 0i64;
      v25.hInstance = GetModuleHandleW(0i64);
      v25.hIconSm = 0i64;
      v25.hCursor = LoadCursorW(0i64, (LPCWSTR)0x7F00);
      v25.hbrBackground = 0i64;
      v25.lpszMenuName = 0i64;
      v25.lpszClassName = ClassName;
      LODWORD(v3) = sub_14001A9F0(&v25);
      v9 = (__int16)v3;
      if ( (_WORD)v3 )
      {
        v10 = malloc(0x10ui64);
        *(_QWORD *)v10 = a1;
        v10[2] = a2;
        v11 = v10;
        ModuleHandleW = GetModuleHandleW(0i64);
        v3 = (HMODULE)sub_14001A730(ClassName, &word_1400EBAA4, 0xCF0000u, 0, 0, 0, 0, 0i64, ModuleHandleW, v11);
        v13 = (__int64)v3;
        if ( v3 )
        {
          v3 = sub_14000AF70(L"dwmapi.dll");
          v14 = v3;
          if ( v3 )
          {
            DwmSetWindowAttribute = (HRESULT (__stdcall *)(HWND, DWORD, LPCVOID, DWORD))GetProcAddress(
                                                                                          v3,
                                                                                          "DwmSetWindowAttribute");
            v16 = DwmSetWindowAttribute;
            if ( DwmSetWindowAttribute )
            {
              ((void (__fastcall *)(__int64, __int64, int *))DwmSetWindowAttribute)(v13, 7i64, &v22);
              ((void (__fastcall *)(__int64, __int64, int *))v16)(v13, 10i64, &v22);
              if ( *(_DWORD *)(a1 + 61028) )
                sub_140094660(a1, v13, (__int64)&unk_1400EBAFC, a3);
              v17 = *(_QWORD *)(a1 + 61000);
              v23[1] = v13;
              v18 = *(_QWORD *)(v17 + 8);
              v24 = a2;
              LOWORD(v23[0]) = v9;
              v19 = sub_14001A860(v17, v18, v23);
              v20 = *(_QWORD *)(a1 + 61008);
              if ( v20 == 0xAAAAAAAAAAAAAA9i64 )
                sub_14002B5F8("list<T> too long");
              *(_QWORD *)(a1 + 61008) = v20 + 1;
              *(_QWORD *)(v17 + 8) = v19;
              **((_QWORD **)v19 + 1) = v19;
            }
            LODWORD(v3) = FreeLibrary(v14);
          }
        }
      }
    }
  }
  return (int)v3;
}
// 1400EF478: using guessed type wchar_t aExplorerTabpro[21];
// 14012E1B0: using guessed type int dword_14012E1B0;

//----- (0000000140096F90) ----------------------------------------------------
__int64 __fastcall sub_140096F90(__int64 a1, const ITEMIDLIST *a2, int *a3, const void *a4, int a5, int *a6)
{
  int v10; // er15
  int v11; // esi
  __int64 v12; // rdx
  _DWORD *i; // rcx
  __int64 v14; // rax
  HWND v15; // rax
  _QWORD *v16; // r14
  _QWORD *j; // rbx
  __int64 v18; // rdx
  char *v19; // rcx
  __int16 v20; // ax
  _QWORD *v21; // r14
  _DWORD *v22; // rax
  _QWORD *v23; // rbx
  int v24; // er12
  __int64 v26; // [rsp+40h] [rbp-C0h]
  char v27[184]; // [rsp+48h] [rbp-B8h] BYREF
  int v28[7]; // [rsp+100h] [rbp+0h] BYREF
  __int64 v29; // [rsp+11Ch] [rbp+1Ch]
  int v30; // [rsp+124h] [rbp+24h]
  int v31; // [rsp+128h] [rbp+28h]
  int v32; // [rsp+12Ch] [rbp+2Ch]
  int v33; // [rsp+130h] [rbp+30h]
  char v34[1028]; // [rsp+13Ch] [rbp+3Ch] BYREF
  __int64 v35; // [rsp+540h] [rbp+440h]
  __int64 v36; // [rsp+548h] [rbp+448h]
  __int64 v37; // [rsp+550h] [rbp+450h]
  __int64 v38; // [rsp+558h] [rbp+458h]
  __int64 v39; // [rsp+560h] [rbp+460h]
  __int64 v40; // [rsp+568h] [rbp+468h]
  __int64 v41; // [rsp+570h] [rbp+470h]

  if ( !(unsigned int)sub_14007FB00(a2) || !(unsigned int)sub_14007EB20(a2) )
    return 2147500037i64;
  v10 = *(_DWORD *)(a1 + 60804) ? *(_DWORD *)(a1 + 7060) + 1 : SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  v11 = 0;
  v12 = 0i64;
  for ( i = (_DWORD *)(a1 + 60320); *i; ++i )
  {
    ++v11;
    if ( ++v12 >= 100 )
      return 2147500037i64;
  }
  *(_DWORD *)(a1 + 4i64 * v11 + 60320) = 1;
  if ( v11 == -1 )
    return 2147500037i64;
  v14 = 532i64 * v11;
  if ( a4 )
  {
    memmove((void *)(v14 + a1 + 7120), a4, 0x214ui64);
  }
  else
  {
    *(_QWORD *)(v14 + a1 + 7120) = 0i64;
    *(_DWORD *)(v14 + a1 + 7128) = 0;
  }
  v15 = sub_1400BE090(a1, *(HWND *)(a1 + 104));
  *(_QWORD *)(a1 + 8i64 * v11 + 184) = v15;
  if ( !v15 )
    return 2147500037i64;
  sub_140080180(v15, *(_DWORD *)(a1 + 60844), *(_DWORD *)(a1 + 60848));
  sub_14008FCC0(a1, *(HWND *)(a1 + 8i64 * v11 + 184));
  if ( !a3 )
  {
    v28[6] = *(_DWORD *)(a1 + 60964);
    v28[4] = *(_DWORD *)(a1 + 60940);
    v28[3] = *(_DWORD *)(a1 + 60948);
    v28[2] = *(_DWORD *)(a1 + 60956);
    v28[5] = *(_DWORD *)(a1 + 60952);
    v30 = *(_DWORD *)(a1 + 60792);
    v31 = *(_DWORD *)(a1 + 60796);
    v32 = *(_DWORD *)(a1 + 60968);
    v33 = *(_DWORD *)(a1 + 60972);
    v16 = *(_QWORD **)(a1 + 60720);
    for ( j = (_QWORD *)*v16; j != v16; j = (_QWORD *)*j )
    {
      v26 = j[2];
      sub_140017E60((__int64)v27, (__int64)(j + 3));
      sub_14007DCB0((__int64)a2, v26);
      sub_14000AD00((__int64)v27);
    }
    v28[0] = 1;
    v28[1] = *(_DWORD *)(a1 + 60936);
    v29 = 0i64;
    v18 = 512i64;
    v19 = v34;
    while ( v18 != -2147483134 )
    {
      v20 = *(_WORD *)&v19[&unk_1400EBA84 - (_UNKNOWN *)v34];
      if ( !v20 )
        break;
      *(_WORD *)v19 = v20;
      v19 += 2;
      if ( !--v18 )
      {
        v19 -= 2;
        break;
      }
    }
    *(_WORD *)v19 = 0;
    v37 = a1 + 62280;
    v36 = a1 + 62256;
    v41 = a1 + 62376;
    v40 = a1 + 62352;
    v39 = a1 + 62328;
    v35 = a1 + 62232;
    v38 = a1 + 62304;
    a3 = v28;
  }
  a3[13] = *(_DWORD *)(a1 + 60880);
  a3[14] = *(_DWORD *)(a1 + 60916);
  v21 = (_QWORD *)(a1 + 8i64 * v11 + 1032);
  sub_1400744C0(
    *(_QWORD *)(a1 + 104),
    *(_QWORD *)(a1 + 8i64 * v11 + 184),
    v21,
    (__int64)a3,
    *(_QWORD *)(a1 + 4776),
    *(_QWORD *)(a1 + 4792));
  if ( a3[7] )
    sub_140082260(*(HWND *)(a1 + 8i64 * v11 + 184), 104);
  v22 = malloc(0x10ui64);
  *(_QWORD *)v22 = a1;
  v22[2] = v11;
  SetWindowLongPtrW(*(HWND *)(a1 + 8i64 * v11 + 184), -21, (LONG_PTR)v22);
  lpPrevWndFunc = (WNDPROC)SetWindowLongPtrW(*(HWND *)(a1 + 8i64 * v11 + 184), -4, (LONG_PTR)sub_1400C20F0);
  v23 = (_QWORD *)(a1 + 8i64 * v11 + 1832);
  (**(void (__fastcall ***)(_QWORD, __int64 *, _QWORD *))*v21)(*v21, &qword_1400E3F80, v23);
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v21 + 96i64))(*v21, (unsigned int)v11);
  (*(void (__fastcall **)(_QWORD, HINSTANCE))(*(_QWORD *)*v21 + 112i64))(*v21, hInstance);
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 680i64))(*v23, *(unsigned int *)(a1 + 60968));
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 696i64))(*v23, *(unsigned int *)(a1 + 60944));
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 712i64))(*v23, *(unsigned int *)(a1 + 60972));
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 728i64))(*v23, *(unsigned int *)(a1 + 60792));
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 752i64))(*v23, *(unsigned int *)(a1 + 60960));
  (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v23 + 768i64))(*v23, *(unsigned int *)(a1 + 60868));
  sub_1400954F0(a1, a2, v10, v11);
  if ( a5 )
  {
    SendMessageW(*(HWND *)(a1 + 136), 0x130Cu, v10, 0i64);
    ShowWindow(*(HWND *)(a1 + 4800), 0);
    ShowWindow(*(HWND *)(a1 + 8i64 * v11 + 184), 5);
    *(_DWORD *)(a1 + 7048) = v11;
    *(_DWORD *)(a1 + 7060) = v10;
    *(_QWORD *)(a1 + 4800) = *(_QWORD *)(a1 + 8i64 * v11 + 184);
    *(_QWORD *)(a1 + 2640) = *v23;
    SetFocus(*(HWND *)(a1 + 8i64 * v11 + 184));
  }
  sub_1400B53E0((_DWORD *)a1, v11);
  v24 = (*(__int64 (__fastcall **)(_QWORD, const ITEMIDLIST *, _QWORD))(*(_QWORD *)*v23 + 24i64))(*v23, a2, 0i64);
  if ( a5 )
    (*(void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*v23 + 104i64))(*v23, 260i64, a1 + 4920);
  if ( v24 )
    return 2147500037i64;
  if ( a6 )
    *a6 = v11;
  sub_140096CC0(a1, v11, a5);
  return 0i64;
}
// 1400971F7: conditional instruction was optimized away because rdx.8!=0
// 1400E3F80: using guessed type __int64 qword_1400E3F80;

//----- (00000001400974D0) ----------------------------------------------------
__int64 __fastcall sub_1400974D0(__int64 a1, const WCHAR *a2, int *a3, const void *a4)
{
  DWORD CurrentProcessId; // eax
  HANDLE v9; // rax
  __int64 v10; // rbx
  void *v11; // rbp
  BOOL v12; // esi
  WCHAR *v13; // rcx
  signed __int64 v14; // rdi
  WCHAR v15; // ax
  unsigned int v17; // ebx
  LPVOID pv; // [rsp+30h] [rbp-268h] BYREF
  HANDLE TokenHandle; // [rsp+38h] [rbp-260h] BYREF
  WCHAR Dest[264]; // [rsp+40h] [rbp-258h] BYREF

  pv = 0i64;
  CurrentProcessId = GetCurrentProcessId();
  v9 = OpenProcess(0x400u, 0, CurrentProcessId);
  v10 = 260i64;
  v11 = v9;
  if ( !v9 )
    goto LABEL_5;
  v12 = OpenProcessToken(v9, 0xCu, &TokenHandle);
  if ( v12 )
  {
    v12 = ExpandEnvironmentStringsForUserW(TokenHandle, a2, Dest, 0x104u);
    CloseHandle(TokenHandle);
  }
  CloseHandle(v11);
  if ( !v12 )
  {
LABEL_5:
    v13 = Dest;
    v14 = (char *)a2 - (char *)Dest;
    while ( v10 != -2147483386 )
    {
      v15 = *(WCHAR *)((char *)v13 + v14);
      if ( !v15 )
        break;
      *v13++ = v15;
      if ( !--v10 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
  if ( (int)sub_14007F810((__int64)Dest, (__int64)&pv) < 0 )
    return 2147500037i64;
  v17 = sub_140096F90(a1, (const ITEMIDLIST *)pv, a3, a4, 1, 0i64);
  CoTaskMemFree(pv);
  return v17;
}
// 1400975C6: conditional instruction was optimized away because rbx.8!=0

//----- (0000000140097650) ----------------------------------------------------
struct IDropTargetVtbl *__fastcall sub_140097650(LPDROPTARGET pDropTarget)
{
  __int64 v2; // rbx
  struct IDropTargetVtbl *result; // rax
  WCHAR Buffer[64]; // [rsp+30h] [rbp-98h] BYREF

  sub_1400DABD0((__int64)pDropTarget);
  if ( LODWORD(pDropTarget[7607].lpVtbl) )
    dwStyle |= 0x400u;
  pDropTarget[17].lpVtbl = (struct IDropTargetVtbl *)sub_14007CBE0((HWND)pDropTarget[124].lpVtbl);
  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 100);
  sub_140095680(v2);
  SendMessageW((HWND)pDropTarget[17].lpVtbl, 0x1303u, 0i64, v2);
  if ( CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)&pDropTarget[7815].lpVtbl) >= 0
    && (*(__int64 (__fastcall **)(struct IDropTargetVtbl *, void *, LPDROPTARGET))pDropTarget[7815].lpVtbl->QueryInterface)(
         pDropTarget[7815].lpVtbl,
         &unk_1400E4040,
         pDropTarget + 7816) >= 0 )
  {
    RegisterDragDrop((HWND)pDropTarget[17].lpVtbl, pDropTarget);
  }
  sub_140009C20((__int64)pDropTarget[17].lpVtbl, (__int64)sub_140096C90, 0i64, (__int64)pDropTarget);
  LoadStringW(hInstance, 0x2019u, Buffer, 64);
  result = (struct IDropTargetVtbl *)sub_140090BE0((HWND)pDropTarget[124].lpVtbl, 5033, (__int64)Buffer);
  pDropTarget[18].lpVtbl = result;
  return result;
}

//----- (00000001400977B0) ----------------------------------------------------
__int64 __fastcall sub_1400977B0(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 62528) + 32i64))(*(_QWORD *)(a1 + 62528));
  return 0i64;
}

//----- (00000001400977D0) ----------------------------------------------------
void __fastcall sub_1400977D0(HWND a1)
{
  dword_14012DA10 = 1;
}
// 14012DA10: using guessed type int dword_14012DA10;

//----- (00000001400977F0) ----------------------------------------------------
BOOL __fastcall sub_1400977F0(__int64 a1, int a2)
{
  __int64 v3; // rcx
  WCHAR pszPath1[264]; // [rsp+20h] [rbp-228h] BYREF

  v3 = *(_QWORD *)(a1 + 8i64 * a2 + 1832);
  (*(void (__fastcall **)(__int64, __int64, WCHAR *))(*(_QWORD *)v3 + 104i64))(v3, 260i64, pszPath1);
  return PathIsSameRootW(pszPath1, (LPCWSTR)(a1 + 62536));
}

//----- (0000000140097860) ----------------------------------------------------
void __fastcall sub_140097860(__int64 a1, __int64 *a2)
{
  __int64 v3; // rax
  HDROP v4; // rax
  HDROP v5; // rbx
  STGMEDIUM v6; // [rsp+20h] [rbp-48h] BYREF
  __int16 v7; // [rsp+38h] [rbp-30h] BYREF
  __int64 v8; // [rsp+40h] [rbp-28h]
  int v9; // [rsp+48h] [rbp-20h]
  int v10; // [rsp+4Ch] [rbp-1Ch]
  int v11; // [rsp+50h] [rbp-18h]

  v7 = 15;
  v3 = *a2;
  v8 = 0i64;
  v9 = 1;
  v10 = -1;
  v11 = 1;
  if ( !(*(unsigned int (__fastcall **)(__int64 *, __int16 *, STGMEDIUM *))(v3 + 24))(a2, &v7, &v6) )
  {
    v4 = (HDROP)GlobalLock(v6.hBitmap);
    v5 = v4;
    if ( v4 )
    {
      if ( (int)DragQueryFileW(v4, 0xFFFFFFFF, 0i64, 0) >= 1 )
        DragQueryFileW(v5, 0, (LPWSTR)(a1 + 62536), 0x104u);
      GlobalUnlock(v6.hBitmap);
    }
    ReleaseStgMedium(&v6);
  }
}

//----- (0000000140097920) ----------------------------------------------------
__int64 __fastcall sub_140097920(__int64 a1, __int64 *a2, char a3, struct tagPOINT a4, int *a5)
{
  _QWORD *v8; // rax
  _QWORD *v9; // rdi
  _QWORD *v10; // rbx
  int v11; // eax
  __int64 v12; // rcx
  BOOL IsSameRootW; // er11
  int v14; // ecx
  int v15; // eax
  _QWORD *v16; // rcx
  _QWORD *v17; // rbx
  struct tagPOINT v19; // [rsp+30h] [rbp-D0h] BYREF
  char *v20; // [rsp+38h] [rbp-C8h] BYREF
  LPARAM lParam[4]; // [rsp+40h] [rbp-C0h] BYREF
  int v22; // [rsp+60h] [rbp-A0h]
  void *Block[4]; // [rsp+68h] [rbp-98h] BYREF
  __int64 pExceptionObject[3]; // [rsp+88h] [rbp-78h] BYREF
  struct tagPOINT Point; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR pszPath1[264]; // [rsp+B0h] [rbp-50h] BYREF

  Block[3] = (void *)-2i64;
  v19 = a4;
  *(_DWORD *)(a1 + 63064) = *(_DWORD *)(a1 + 7060);
  dword_14012DA10 = 0;
  Block[1] = 0i64;
  v8 = operator new(0x30ui64);
  if ( !v8 )
  {
    v20 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v20);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v8;
  *v8 = v8;
  v8[1] = v8;
  sub_1400762E0((__int64 *)Block);
  v9 = Block[0];
  v10 = *(_QWORD **)Block[0];
  if ( *(void **)Block[0] == Block[0] )
  {
LABEL_29:
    *(_DWORD *)(a1 + 63060) = 0;
LABEL_30:
    *a5 = 0;
    goto LABEL_31;
  }
  while ( 1 )
  {
    lParam[0] = v10[2];
    lParam[1] = v10[3];
    lParam[2] = v10[4];
    lParam[3] = v10[5];
    if ( !(*(unsigned int (__fastcall **)(__int64 *, LPARAM *))(*a2 + 40))(a2, lParam) )
      break;
    v10 = (_QWORD *)*v10;
    if ( v10 == v9 )
      goto LABEL_29;
  }
  *(_DWORD *)(a1 + 63060) = 1;
  sub_140097860(a1, a2);
  Point = v19;
  ScreenToClient(*(HWND *)(a1 + 136), &Point);
  v11 = SendMessageW(*(HWND *)(a1 + 136), 0x130Du, 0i64, (LPARAM)&Point);
  if ( v11 == -1 )
    goto LABEL_30;
  LODWORD(lParam[0]) = 8;
  SendMessageW(*(HWND *)(a1 + 136), 0x133Cu, v11, (LPARAM)lParam);
  v12 = *(_QWORD *)(a1 + 8i64 * v22 + 1832);
  (*(void (__fastcall **)(__int64, __int64, WCHAR *))(*(_QWORD *)v12 + 104i64))(v12, 260i64, pszPath1);
  IsSameRootW = PathIsSameRootW(pszPath1, (LPCWSTR)(a1 + 62536));
  v14 = *a5;
  if ( *(_DWORD *)(a1 + 63060) )
  {
    if ( ((a3 & 8) != 0 && (a3 & 4) != 0 || (a3 & 0x20) != 0) && (v14 & 4) != 0 )
    {
      v15 = 4;
    }
    else if ( (a3 & 4) != 0 && (v14 & 2) != 0 )
    {
      v15 = 2;
    }
    else if ( (a3 & 8) == 8 && (v14 & 1) != 0 )
    {
      v15 = 1;
    }
    else if ( IsSameRootW && (v14 & 2) != 0 )
    {
      v15 = 2;
    }
    else if ( (v14 & 1) != 0 )
    {
      v15 = 1;
    }
    else if ( (v14 & 2) != 0 )
    {
      v15 = 2;
    }
    else
    {
      v15 = *a5 & 4;
    }
  }
  else
  {
    v15 = 0;
  }
  *a5 = v15;
LABEL_31:
  if ( (a3 & 1) != 0 )
  {
    *(_DWORD *)(a1 + 63056) = 0;
  }
  else if ( (a3 & 2) != 0 )
  {
    *(_DWORD *)(a1 + 63056) = 1;
  }
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, struct tagPOINT *, int))(**(_QWORD **)(a1 + 62528) + 24i64))(
    *(_QWORD *)(a1 + 62528),
    *(_QWORD *)(a1 + 136),
    a2,
    &v19,
    *a5);
  v16 = (_QWORD *)*v9;
  *v9 = v9;
  v9[1] = v9;
  if ( v16 != v9 )
  {
    do
    {
      v17 = (_QWORD *)*v16;
      j_free(v16);
      v16 = v17;
    }
    while ( v17 != v9 );
  }
  j_free(v9);
  return 0i64;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012DA10: using guessed type int dword_14012DA10;

//----- (0000000140097C20) ----------------------------------------------------
__int64 __fastcall sub_140097C20(__int64 a1, __int64 a2, int a3, struct tagPOINT a4, unsigned int *a5)
{
  HWND v8; // rcx
  int v9; // eax
  HWND v10; // rcx
  __int64 v11; // rcx
  _DWORD *v12; // rax
  __int64 v13; // r9
  __int64 v14; // rbx
  int v15; // edx
  __int64 v16; // rcx
  int *v17; // r8
  unsigned int v18; // eax
  struct tagPOINT v20; // [rsp+20h] [rbp-298h] BYREF
  __int64 lParam[4]; // [rsp+30h] [rbp-288h] BYREF
  int v22; // [rsp+50h] [rbp-268h]
  struct tagPOINT Point; // [rsp+58h] [rbp-260h] BYREF
  char v24[528]; // [rsp+70h] [rbp-248h] BYREF

  v20 = a4;
  (*(void (__fastcall **)(_QWORD, __int64, struct tagPOINT *, _QWORD))(**(_QWORD **)(a1 + 62528) + 48i64))(
    *(_QWORD *)(a1 + 62528),
    a2,
    &v20,
    *a5);
  v8 = *(HWND *)(a1 + 136);
  Point = v20;
  ScreenToClient(v8, &Point);
  v9 = SendMessageW(*(HWND *)(a1 + 136), 0x130Du, 0i64, (LPARAM)&Point);
  if ( v9 != -1 )
  {
    v10 = *(HWND *)(a1 + 136);
    LODWORD(lParam[0]) = 8;
    SendMessageW(v10, 0x133Cu, v9, (LPARAM)lParam);
    v11 = *(_QWORD *)(a1 + 8i64 * v22 + 1832);
    (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v11 + 104i64))(v11, 260i64, v24);
    if ( *(_DWORD *)(a1 + 63060) )
    {
      v12 = operator new(0x50ui64);
      v13 = 0i64;
      v14 = (__int64)v12;
      if ( v12 )
      {
        v12[2] = 1;
        *(_QWORD *)v12 = &CDropHandler::`vftable';
      }
      else
      {
        v14 = 0i64;
      }
      v15 = *(_DWORD *)(a1 + 63056);
      v16 = *(_QWORD *)(a1 + 136);
      *(struct tagPOINT *)(v14 + 36) = v20;
      v17 = (int *)(v14 + 36);
      *(_QWORD *)(v14 + 16) = a2;
      *(_DWORD *)(v14 + 32) = a3;
      v18 = *a5;
      *(_QWORD *)(v14 + 48) = v16;
      *(_DWORD *)(v14 + 44) = v18;
      *(_DWORD *)(v14 + 56) = v15;
      *(_QWORD *)(v14 + 24) = 0i64;
      *(_DWORD *)(v14 + 72) = 0;
      *(_QWORD *)(v14 + 64) = v24;
      if ( v15 )
      {
        if ( v15 == 1 )
          sub_1400761A0(v14);
      }
      else
      {
        sub_1400783F0(v14, a2, v17);
      }
      if ( !_InterlockedDecrement((volatile signed __int32 *)(v14 + 8)) )
        (**(void (__fastcall ***)(__int64, __int64, int *, __int64))v14)(v14, 1i64, v17, v13);
    }
  }
  return 0i64;
}
// 140097DA5: variable 'v17' is possibly undefined
// 140097DA5: variable 'v13' is possibly undefined
// 1400F7C20: using guessed type void *CDropHandler::`vftable';
// 140097C20: using guessed type LPARAM lParam[4];

//----- (0000000140097DE0) ----------------------------------------------------
__int64 __fastcall sub_140097DE0(__int64 a1, char a2, struct tagPOINT a3, unsigned int *a4)
{
  HWND v5; // rcx
  int v8; // eax
  int v9; // esi
  unsigned int v10; // ebx
  HWND v11; // rcx
  WPARAM v12; // r13
  HWND v13; // rcx
  __int64 v14; // rcx
  BOOL v15; // eax
  unsigned int v16; // ecx
  struct tagPOINT v18; // [rsp+20h] [rbp-78h] BYREF
  __int64 lParam[4]; // [rsp+28h] [rbp-70h] BYREF
  int v20; // [rsp+48h] [rbp-50h]
  struct tagPOINT Point; // [rsp+50h] [rbp-48h] BYREF

  v5 = *(HWND *)(a1 + 136);
  v18 = a3;
  Point = a3;
  ScreenToClient(v5, &Point);
  v8 = SendMessageW(*(HWND *)(a1 + 136), 0x130Du, 0i64, (LPARAM)&Point);
  v9 = v8;
  if ( v8 == -1 )
  {
    v10 = 0;
    goto LABEL_28;
  }
  v11 = *(HWND *)(a1 + 136);
  v12 = v8;
  LODWORD(lParam[0]) = 8;
  SendMessageW(v11, 0x133Cu, v8, (LPARAM)lParam);
  v10 = 0;
  if ( v9 == *(_DWORD *)(a1 + 7060) )
  {
    KillTimer(*(HWND *)(a1 + 136), 0i64);
    goto LABEL_9;
  }
  if ( v9 != *(_DWORD *)(a1 + 63064) )
  {
    SetTimer(*(HWND *)(a1 + 136), 0i64, 0x1F4u, (TIMERPROC)sub_1400977D0);
LABEL_9:
    *(_DWORD *)(a1 + 63064) = v9;
    goto LABEL_10;
  }
  if ( dword_14012DA10 )
  {
    v13 = *(HWND *)(a1 + 136);
    *(_DWORD *)(a1 + 7060) = v9;
    SendMessageW(v13, 0x130Cu, v12, 0i64);
    sub_1400957D0(a1, 1);
    dword_14012DA10 = 0;
  }
LABEL_10:
  v14 = *(_QWORD *)(a1 + 8i64 * v20 + 1832);
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v14 + 288i64))(v14) )
  {
    v15 = sub_1400977F0(a1, v20);
    v16 = *a4;
    if ( *(_DWORD *)(a1 + 63060) )
    {
      if ( ((a2 & 8) != 0 && (a2 & 4) != 0 || (a2 & 0x20) != 0) && (v16 & 4) != 0 )
      {
        v10 = 4;
        goto LABEL_28;
      }
      if ( (a2 & 4) == 0 || (v16 & 2) == 0 )
      {
        if ( (a2 & 8) == 8 && (v16 & 1) != 0 )
          goto LABEL_21;
        if ( !v15 || (v16 & 2) == 0 )
        {
          if ( (v16 & 1) != 0 )
          {
LABEL_21:
            v10 = 1;
            goto LABEL_28;
          }
          if ( (v16 & 2) == 0 )
          {
            v10 = *a4 & 4;
            goto LABEL_28;
          }
        }
      }
      v10 = 2;
    }
  }
LABEL_28:
  *a4 = v10;
  (*(void (__fastcall **)(_QWORD, struct tagPOINT *, _QWORD))(**(_QWORD **)(a1 + 62528) + 40i64))(
    *(_QWORD *)(a1 + 62528),
    &v18,
    v10);
  return 0i64;
}
// 14012DA10: using guessed type int dword_14012DA10;
// 140097DE0: using guessed type LPARAM lParam[4];

//----- (0000000140097FD0) ----------------------------------------------------
void __fastcall sub_140097FD0(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 152));
  *(_BYTE *)(a1 + 192) = 1;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 152));
}

//----- (0000000140098010) ----------------------------------------------------
BOOL __fastcall sub_140098010(__int64 a1)
{
  bool v1; // zf
  HINSTANCE v3; // rcx
  UINT v4; // edx
  __int64 v5; // rcx
  HWND v6; // rcx
  int v7; // eax
  WCHAR Buffer[64]; // [rsp+40h] [rbp-98h] BYREF

  v1 = *(_BYTE *)(a1 + 121) == 0;
  v3 = *(HINSTANCE *)(a1 + 16);
  v4 = 247;
  if ( !v1 )
    v4 = 248;
  LoadStringW(v3, v4, Buffer, 64);
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1309, Buffer);
  v5 = *(_QWORD *)(a1 + 216);
  if ( !_InterlockedDecrement((volatile signed __int32 *)(v5 + 8)) && v5 )
    (**(void (__fastcall ***)(__int64, __int64))v5)(v5, 1i64);
  v6 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 216) = 0i64;
  *(_WORD *)(a1 + 120) = 0;
  KillTimer(v6, 1ui64);
  v7 = SendDlgItemMessageW(*(HWND *)(a1 + 8), 1143, 0x407u, 0i64, 0i64);
  SendDlgItemMessageW(*(HWND *)(a1 + 8), 1143, 0x402u, v7, 0i64);
  return SetDlgItemTextW(*(HWND *)(a1 + 8), 1, (LPCWSTR)(a1 + 232));
}

//----- (0000000140098140) ----------------------------------------------------
int __fastcall sub_140098140(__int64 a1, int a2, WPARAM lParam)
{
  int v3; // edx
  int v5; // edx
  int v6; // edx
  __int64 v7; // rcx
  HWND v8; // rcx
  int result; // eax
  WCHAR Buffer[128]; // [rsp+40h] [rbp-118h] BYREF

  v3 = a2 - 32769;
  if ( !v3 )
    return SendDlgItemMessageW(*(HWND *)(a1 + 8), 1143, 0x406u, 0i64, lParam);
  v5 = v3 - 1;
  if ( !v5 )
    return SendDlgItemMessageW(*(HWND *)(a1 + 8), 1143, 0x402u, lParam, 0i64);
  v6 = v5 - 1;
  if ( !v6 )
    return sub_140098010(a1);
  if ( v6 == 1 )
  {
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0xF9u, Buffer, 128);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1309, Buffer);
    v7 = *(_QWORD *)(a1 + 216);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v7 + 8)) )
    {
      if ( v7 )
        (**(void (__fastcall ***)(__int64, __int64))v7)(v7, 1i64);
    }
    v8 = *(HWND *)(a1 + 8);
    *(_QWORD *)(a1 + 216) = 0i64;
    *(_WORD *)(a1 + 120) = 0;
    KillTimer(v8, 1ui64);
    return SetDlgItemTextW(*(HWND *)(a1 + 8), 1, (LPCWSTR)(a1 + 232));
  }
  return result;
}

//----- (0000000140098260) ----------------------------------------------------
__int64 __fastcall sub_140098260(__int64 a1)
{
  DeleteObject(*(HGDIOBJ *)(a1 + 224));
  return 0i64;
}

//----- (0000000140098280) ----------------------------------------------------
__int64 __fastcall sub_140098280(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400982A0) ----------------------------------------------------
HGDIOBJ __fastcall sub_1400982A0(__int64 a1, HWND a2, HDC a3)
{
  if ( a2 != GetDlgItem(*(HWND *)(a1 + 8), 1298) )
    return 0i64;
  SetTextColor(a3, 0x787878u);
  SetBkMode(a3, 1);
  return GetStockObject(5);
}

//----- (0000000140098310) ----------------------------------------------------
HRESULT __fastcall sub_140098310(__int64 a1, __int64 *a2, __int64 a3)
{
  const OLECHAR *v3; // r9
  const OLECHAR *v7; // r9

  v3 = (const OLECHAR *)(a1 + 544);
  if ( *(_QWORD *)(a1 + 568) >= 8ui64 )
    v3 = *(const OLECHAR **)v3;
  sub_14007BEA0(a2, a3, L"Size", v3);
  v7 = (const OLECHAR *)(a1 + 584);
  if ( *(_QWORD *)(a1 + 608) >= 8ui64 )
    v7 = *(const OLECHAR **)v7;
  return sub_14007BEA0(a2, a3, L"SizeGroup", v7);
}
// 1400EFE48: using guessed type wchar_t aSize[5];
// 1400EFE58: using guessed type wchar_t aSizegroup[10];

//----- (0000000140098390) ----------------------------------------------------
LSTATUS __fastcall sub_140098390(__int64 a1, HKEY a2)
{
  const WCHAR *lpData; // rbx
  int v5; // eax
  const WCHAR *v6; // rbx
  int v7; // eax

  lpData = (const WCHAR *)(a1 + 544);
  if ( *(_QWORD *)(a1 + 568) >= 8ui64 )
    lpData = *(const WCHAR **)lpData;
  v5 = lstrlenW(lpData);
  RegSetValueExW(a2, L"Size", 0, 1u, (const BYTE *)lpData, 2 * v5);
  v6 = (const WCHAR *)(a1 + 584);
  if ( *(_QWORD *)(a1 + 608) >= 8ui64 )
    v6 = *(const WCHAR **)v6;
  v7 = lstrlenW(v6);
  return RegSetValueExW(a2, L"SizeGroup", 0, 1u, (const BYTE *)v6, 2 * v7);
}

//----- (0000000140098440) ----------------------------------------------------
void **__fastcall sub_140098440(__int64 a1)
{
  void **result; // rax

  *(_QWORD *)a1 = &CSplitFileDialogPersistentSettings::`vftable';
  if ( *(_QWORD *)(a1 + 608) >= 8ui64 )
    j_free(*(void **)(a1 + 584));
  *(_QWORD *)(a1 + 608) = 7i64;
  *(_QWORD *)(a1 + 600) = 0i64;
  *(_WORD *)(a1 + 584) = 0;
  if ( *(_QWORD *)(a1 + 568) >= 8ui64 )
    j_free(*(void **)(a1 + 544));
  *(_QWORD *)(a1 + 568) = 7i64;
  *(_QWORD *)(a1 + 560) = 0i64;
  *(_WORD *)(a1 + 544) = 0;
  result = &CDialogSettings::`vftable';
  *(_QWORD *)a1 = &CDialogSettings::`vftable';
  return result;
}
// 1400F7898: using guessed type void *CSplitFileDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (00000001400984E0) ----------------------------------------------------
void **__fastcall sub_1400984E0(__int64 a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // rcx
  void **result; // rax

  v2 = (struct _RTL_CRITICAL_SECTION *)(a1 + 152);
  *(_QWORD *)&v2[-4].LockCount = &CSplitFile::`vftable';
  DeleteCriticalSection(v2);
  if ( *(_QWORD *)(a1 + 128) >= 8ui64 )
    j_free(*(void **)(a1 + 104));
  *(_QWORD *)(a1 + 128) = 7i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_WORD *)(a1 + 104) = 0;
  if ( *(_QWORD *)(a1 + 88) >= 8ui64 )
    j_free(*(void **)(a1 + 64));
  *(_QWORD *)(a1 + 88) = 7i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_WORD *)(a1 + 64) = 0;
  if ( *(_QWORD *)(a1 + 48) >= 8ui64 )
    j_free(*(void **)(a1 + 24));
  *(_QWORD *)(a1 + 48) = 7i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_WORD *)(a1 + 24) = 0;
  result = &CReferenceCount::`vftable';
  *(_QWORD *)a1 = &CReferenceCount::`vftable';
  return result;
}
// 1400F78C8: using guessed type void *CSplitFile::`vftable';
// 1400F7C30: using guessed type void *CReferenceCount::`vftable';

//----- (0000000140098590) ----------------------------------------------------
__int64 __fastcall sub_140098590(__int64 a1, int a2)
{
  unsigned int v3; // er9
  unsigned int v5; // [rsp+20h] [rbp-38h]
  unsigned int v6; // [rsp+28h] [rbp-30h]
  WCHAR String[12]; // [rsp+30h] [rbp-28h] BYREF

  if ( a2 == 1 )
  {
    v3 = ++*(_DWORD *)(a1 + 296);
    v6 = v3 % 0x3C;
    v5 = v3 / 0x3C % 0x3C;
    sub_140001000(String, 9ui64, L"%02d:%02d:%02d", v3 / 0xE10, v5, v6);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1301, String);
  }
  return 0i64;
}
// 1400EFDC8: using guessed type wchar_t a02d02d02d[15];

//----- (0000000140098650) ----------------------------------------------------
void __fastcall sub_140098650(__int64 a1)
{
  __int64 v2; // rsi
  __int64 v3; // rcx

  *(_QWORD *)a1 = &CSplitFileDialog::`vftable';
  v2 = *(_QWORD *)(a1 + 216);
  if ( v2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v2 + 152));
    *(_BYTE *)(v2 + 192) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 152));
    v3 = *(_QWORD *)(a1 + 216);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v3 + 8)) )
    {
      if ( v3 )
        (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1i64);
    }
  }
  sub_14001A540(a1 + 128);
  if ( *(_QWORD *)(a1 + 104) >= 8ui64 )
    j_free(*(void **)(a1 + 80));
  *(_QWORD *)(a1 + 104) = 7i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_WORD *)(a1 + 80) = 0;
  sub_140084540((_QWORD *)a1);
}
// 1400F7828: using guessed type void *CSplitFileDialog::`vftable';

//----- (0000000140098720) ----------------------------------------------------
__int64 __fastcall sub_140098720(__int64 a1, __int64 a2, void **a3, void **a4, void **a5, int a6)
{
  _QWORD *v9; // rcx

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &CSplitFile::`vftable';
  v9 = (_QWORD *)(a1 + 24);
  v9[3] = 7i64;
  v9[2] = 0i64;
  *(_WORD *)v9 = 0;
  *(_QWORD *)(a1 + 88) = 7i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_WORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 128) = 7i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_WORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  sub_140009610(v9, a3, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140009610((void *)(a1 + 64), a4, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_140009610((void *)(a1 + 104), a5, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  *(_DWORD *)(a1 + 144) = a6;
  *(_BYTE *)(a1 + 192) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 152));
  if ( (unsigned __int64)a3[3] >= 8 )
    j_free(*a3);
  a3[3] = (void *)7;
  a3[2] = 0i64;
  *(_WORD *)a3 = 0;
  if ( (unsigned __int64)a4[3] >= 8 )
    j_free(*a4);
  a4[3] = (void *)7;
  a4[2] = 0i64;
  *(_WORD *)a4 = 0;
  if ( (unsigned __int64)a5[3] >= 8 )
    j_free(*a5);
  a5[3] = (void *)7;
  a5[2] = 0i64;
  *(_WORD *)a5 = 0;
  return a1;
}
// 1400F78C8: using guessed type void *CSplitFile::`vftable';

//----- (00000001400988A0) ----------------------------------------------------
void __fastcall sub_1400988A0(__int64 a1, const WCHAR *a2, const OLECHAR *a3)
{
  BSTR *v6; // rax
  BSTR *v7; // rbx
  BSTR v8; // rax
  __int64 v9; // rcx
  BSTR v10; // rdi
  bool v11; // zf
  BSTR *v12; // rax
  BSTR v13; // rax
  __int64 v14; // rcx
  BSTR v15; // rdi
  BSTR v16; // rcx

  if ( lstrcmpiW(a2, L"Size") )
  {
    if ( lstrcmpiW(a2, L"SizeGroup") )
      return;
    v12 = (BSTR *)operator new(0x18ui64);
    v7 = v12;
    if ( v12 )
    {
      v12[1] = 0i64;
      *((_DWORD *)v12 + 4) = 1;
      v13 = SysAllocString(a3);
      *v7 = v13;
      if ( !v13 && a3 )
      {
        sub_140060C30(2147942414i64);
        __debugbreak();
      }
    }
    else
    {
      v7 = 0i64;
    }
    if ( !v7 )
      sub_140060C30(2147942414i64);
    v14 = -1i64;
    v15 = *v7;
    do
    {
      if ( !v14 )
        break;
      v11 = *v15++ == 0;
      --v14;
    }
    while ( !v11 );
    sub_1400099E0((void *)(a1 + 584), *v7, -v14 - 2);
  }
  else
  {
    v6 = (BSTR *)operator new(0x18ui64);
    v7 = v6;
    if ( v6 )
    {
      v6[1] = 0i64;
      *((_DWORD *)v6 + 4) = 1;
      v8 = SysAllocString(a3);
      *v7 = v8;
      if ( !v8 && a3 )
      {
        sub_140060C30(2147942414i64);
        __debugbreak();
      }
    }
    else
    {
      v7 = 0i64;
    }
    if ( !v7 )
      sub_140060C30(2147942414i64);
    v9 = -1i64;
    v10 = *v7;
    do
    {
      if ( !v9 )
        break;
      v11 = *v10++ == 0;
      --v9;
    }
    while ( !v11 );
    sub_1400099E0((void *)(a1 + 544), *v7, -v9 - 2);
  }
  if ( !_InterlockedDecrement((volatile signed __int32 *)v7 + 4) )
  {
    if ( *v7 )
      SysFreeString(*v7);
    v16 = v7[1];
    if ( v16 )
      j_j_free(v16);
    j_free(v7);
  }
}

//----- (0000000140098A50) ----------------------------------------------------
__int64 __fastcall sub_140098A50(__int64 a1, HKEY a2)
{
  __int16 Src[8]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v6; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+38h] [rbp-20h]

  v7 = 7i64;
  v6 = 0i64;
  Src[0] = 0;
  sub_1400099E0(Src, L"Size", 4ui64);
  sub_14007B740(a2, (__int64)Src, (void *)(a1 + 544));
  v7 = 7i64;
  v6 = 0i64;
  Src[0] = 0;
  sub_1400099E0(Src, L"SizeGroup", 9ui64);
  return sub_14007B740(a2, (__int64)Src, (void *)(a1 + 584));
}
// 1400EFE20: using guessed type wchar_t aSize_2[5];
// 1400EFE30: using guessed type wchar_t aSizegroup_2[10];

//----- (0000000140098B00) ----------------------------------------------------
__int64 *sub_140098B00()
{
  __int64 v0; // rdx
  _WORD *v1; // rcx
  __int16 v2; // ax

  v0 = 256i64;
  v1 = &unk_140130CDC;
  while ( v0 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v1 + (char *)L"SplitFile" - (char *)&unk_140130CDC);
    if ( !v2 )
      break;
    *v1++ = v2;
    if ( !--v0 )
    {
      --v1;
      break;
    }
  }
  *v1 = 0;
  byte_140130EDC = 1;
  dword_140130CC8 = 0;
  qword_140130CC0 = (__int64)&CSplitFileDialogPersistentSettings::`vftable';
  qword_140130EF8 = 7i64;
  qword_140130EF0 = 0i64;
  LOWORD(qword_140130EE0) = 0;
  qword_140130F20 = 7i64;
  qword_140130F18 = 0i64;
  LOWORD(qword_140130F08) = 0;
  sub_1400099E0(&qword_140130EE0, L"10", 2ui64);
  sub_1400099E0(&qword_140130F08, L"KB", 2ui64);
  return &qword_140130CC0;
}
// 140098B58: conditional instruction was optimized away because rdx.8!=0
// 1400EFD80: using guessed type wchar_t aSplitfile_0[10];
// 1400EFDE8: using guessed type wchar_t a10[3];
// 1400EFDF0: using guessed type wchar_t aKb_0[3];
// 1400F7898: using guessed type void *CSplitFileDialogPersistentSettings::`vftable';
// 140130CC0: using guessed type __int64 qword_140130CC0;
// 140130CC8: using guessed type int dword_140130CC8;
// 140130EDC: using guessed type char byte_140130EDC;
// 140130EF0: using guessed type __int64 qword_140130EF0;
// 140130EF8: using guessed type __int64 qword_140130EF8;
// 140130F18: using guessed type __int64 qword_140130F18;
// 140130F20: using guessed type __int64 qword_140130F20;

//----- (0000000140098BF0) ----------------------------------------------------
void __fastcall sub_140098BF0(__int64 a1)
{
  __int64 v2; // rcx
  WCHAR *v3; // rdi
  bool v4; // zf
  int v5; // edi
  const WCHAR *v6; // r8
  LPCWSTR lpString[3]; // [rsp+28h] [rbp-170h] BYREF
  unsigned __int64 v8; // [rsp+40h] [rbp-158h]
  void *Block[3]; // [rsp+50h] [rbp-148h] BYREF
  unsigned __int64 v10; // [rsp+68h] [rbp-130h]
  WCHAR Buffer[128]; // [rsp+80h] [rbp-118h] BYREF

  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x851u, Buffer, 128);
  v8 = 7i64;
  lpString[2] = 0i64;
  LOWORD(lpString[0]) = 0;
  v10 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  v2 = -1i64;
  v3 = Buffer;
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  sub_1400099E0(Block, Buffer, -v2 - 2);
  v5 = sub_1400D35A0(*(HWND *)(a1 + 8), (__int64)Block, lpString);
  if ( v10 >= 8 )
    j_free(Block[0]);
  if ( v5 )
  {
    v6 = (const WCHAR *)lpString;
    if ( v8 >= 8 )
      v6 = lpString[0];
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1141, v6);
  }
  if ( v8 >= 8 )
    j_free((void *)lpString[0]);
}

//----- (0000000140098D20) ----------------------------------------------------
void __fastcall sub_140098D20(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  __int64 v6; // rbx
  HWND DlgItem; // rax
  __int64 v8; // rbx
  HWND v9; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 304);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  v6 = *(_QWORD *)(a1 + 304);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1139);
  sub_140083A30(DlgItem, (void *)(v6 + 544));
  v8 = *(_QWORD *)(a1 + 304);
  v9 = GetDlgItem(*(HWND *)(a1 + 8), 1140);
  sub_140083A30(v9, (void *)(v8 + 584));
  *(_DWORD *)(*(_QWORD *)(a1 + 304) + 8i64) = 1;
}

//----- (0000000140098E40) ----------------------------------------------------
void __fastcall sub_140098E40(__int64 a1, __int64 a2, void *a3)
{
  _QWORD *v5; // rbx
  __int64 v6; // rax
  void *v7; // rax
  void *v8; // rax
  __int64 v9[2]; // [rsp+40h] [rbp-C0h] BYREF
  char v10[136]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v11[13]; // [rsp+D8h] [rbp-28h] BYREF
  void *Block[3]; // [rsp+140h] [rbp+40h] BYREF
  unsigned __int64 v13; // [rsp+158h] [rbp+58h]
  void *Src[3]; // [rsp+168h] [rbp+68h] BYREF
  unsigned __int64 v15; // [rsp+180h] [rbp+80h]
  void *v16[5]; // [rsp+190h] [rbp+90h] BYREF

  v15 = 7i64;
  Src[2] = 0i64;
  LOWORD(Src[0]) = 0;
  sub_140009610(Src, (_QWORD *)(a1 + 64), 0i64, 0xFFFFFFFFFFFFFFFFui64);
  sub_14000C330(v9);
  sub_14000C080((__int64)v10);
  v5 = (_QWORD *)sub_14000C460((__int64)v9, (__int64)Block);
  v6 = sub_14000CB60((char *)Src, L"/N", 2ui64);
  sub_14000C5C0(Src, v6, (char *)2, v5, 0i64, -1i64);
  if ( v13 >= 8 )
    j_free(Block[0]);
  v7 = sub_14001A5B0(v16, (_QWORD *)(a1 + 104), L"\\");
  v8 = sub_14000F1E0(Block, v7, Src);
  sub_14000B3F0(a3, v8);
  if ( v13 >= 8 )
    j_free(Block[0]);
  v13 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  if ( v16[3] >= (void *)8 )
    j_free(v16[0]);
  sub_14000C3E0((__int64)v11);
  v11[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v11);
  if ( v15 >= 8 )
    j_free(Src[0]);
}
// 1400EBC94: using guessed type wchar_t asc_1400EBC94[2];
// 1400EFD34: using guessed type wchar_t aN[3];
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 140098E40: using guessed type _QWORD var_1A0[2];
// 140098E40: using guessed type char var_190[136];

//----- (0000000140098FE0) ----------------------------------------------------
void __fastcall sub_140098FE0(__int64 a1, void *a2, _QWORD *a3)
{
  void *v6; // r13
  char v7; // si
  int v8; // er12
  __int64 v9; // rbx
  const WCHAR *v10; // rcx
  HANDLE FileW; // rax
  void *v12; // rdi
  DWORD NumberOfBytesRead; // [rsp+40h] [rbp-88h] BYREF
  DWORD NumberOfBytesWritten[2]; // [rsp+48h] [rbp-80h] BYREF
  __int64 v15; // [rsp+50h] [rbp-78h]
  LPCWSTR lpFileName[3]; // [rsp+58h] [rbp-70h] BYREF
  unsigned __int64 v17; // [rsp+70h] [rbp-58h]

  v15 = -2i64;
  *(_QWORD *)NumberOfBytesWritten = 0i64;
  v6 = operator new(*(unsigned int *)(a1 + 144));
  v7 = 0;
  v8 = 1;
  v9 = 0i64;
  while ( v9 < *a3 )
  {
    if ( v7 )
      break;
    ReadFile(a2, v6, *(_DWORD *)(a1 + 144), &NumberOfBytesRead, 0i64);
    v17 = 7i64;
    lpFileName[2] = 0i64;
    LOWORD(lpFileName[0]) = 0;
    sub_140098E40(a1, (unsigned int)v8, lpFileName);
    v10 = (const WCHAR *)lpFileName;
    if ( v17 >= 8 )
      v10 = lpFileName[0];
    FileW = CreateFileW(v10, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
    v12 = FileW;
    if ( FileW != (HANDLE)-1i64 )
    {
      WriteFile(FileW, v6, NumberOfBytesRead, NumberOfBytesWritten, 0i64);
      CloseHandle(v12);
    }
    PostMessageW(*(HWND *)(a1 + 16), 0x8002u, v8, 0i64);
    v9 += NumberOfBytesRead;
    ++v8;
    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 152));
    if ( *(_BYTE *)(a1 + 192) )
      v7 = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 152));
    if ( v17 >= 8 )
      j_free((void *)lpFileName[0]);
  }
  j_j_free(v6);
}

//----- (00000001400991A0) ----------------------------------------------------
int __fastcall sub_1400991A0(__int64 a1)
{
  __int64 v2; // rcx
  HANDLE FileW; // rax
  void *v4; // rdi
  WPARAM v6; // rax
  LARGE_INTEGER FileSize; // [rsp+50h] [rbp+8h] BYREF

  v2 = a1 + 24;
  if ( *(_QWORD *)(v2 + 24) >= 8ui64 )
    v2 = *(_QWORD *)v2;
  FileW = CreateFileW((LPCWSTR)v2, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
  v4 = FileW;
  if ( FileW == (HANDLE)-1i64 )
    return PostMessageW(*(HWND *)(a1 + 16), 0x8004u, 0i64, 0i64);
  GetFileSizeEx(FileW, &FileSize);
  v6 = FileSize.QuadPart / *(unsigned int *)(a1 + 144);
  if ( FileSize.QuadPart % *(unsigned int *)(a1 + 144) )
    ++v6;
  PostMessageW(*(HWND *)(a1 + 16), 0x8001u, v6, 0i64);
  sub_140098FE0(a1, v4, &FileSize);
  CloseHandle(v4);
  return SendMessageW(*(HWND *)(a1 + 16), 0x8003u, 0i64, 0i64);
}

//----- (0000000140099290) ----------------------------------------------------
__int64 __fastcall sub_140099290(LPVOID lpThreadParameter)
{
  sub_1400991A0((__int64)lpThreadParameter);
  return 0i64;
}

//----- (0000000140099790) ----------------------------------------------------
__int64 __fastcall sub_140099790(__int64 a1, int a2)
{
  __int16 v3; // di
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  __int16 v7; // ax

  v3 = a2;
  if ( HIWORD(a2) == 768 )
  {
    v4 = *(_DWORD *)(a1 + 300) - 1;
    if ( *(_DWORD *)(a1 + 300) == 1 || (v5 = v4 - 1) == 0 )
    {
      v7 = 1293;
    }
    else
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 1 )
          goto LABEL_11;
        v7 = 1139;
      }
      else
      {
        v7 = 1141;
      }
    }
    if ( (_WORD)a2 == v7 )
    {
      SetDlgItemTextW(*(HWND *)(a1 + 8), 1309, &String);
      *(_DWORD *)(a1 + 300) = 0;
    }
  }
LABEL_11:
  if ( v3 == 1 )
  {
    sub_1400992B0(a1);
    return 0i64;
  }
  if ( v3 != 2 )
  {
    if ( v3 == 1142 )
    {
      sub_140098BF0(a1);
      return 0i64;
    }
    return 0i64;
  }
  if ( *(_BYTE *)(a1 + 120) )
    *(_BYTE *)(a1 + 121) = 1;
  else
    EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}
// 1400992B0: using guessed type __int64 __fastcall sub_1400992B0(_QWORD);

//----- (0000000140099880) ----------------------------------------------------
__int64 __fastcall sub_140099880(__int64 a1)
{
  const WCHAR *v1; // rbx
  const WCHAR *v3; // rcx
  const WCHAR *v4; // r8
  const WCHAR *v5; // rcx
  HANDLE FileW; // rax
  void *v7; // rsi
  const WCHAR *v8; // r8
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  signed __int64 v11; // r8
  WCHAR v12; // ax
  HWND DlgItem; // r12
  int v14; // eax
  __int64 *v15; // rax
  __int64 v16; // r13
  char *v17; // r11
  __int64 v18; // rax
  int v19; // eax
  __int64 *v20; // rax
  __int64 v21; // r13
  char *v22; // r11
  __int64 v23; // rax
  int v24; // eax
  __int64 *v25; // rax
  __int64 v26; // r13
  char *v27; // r11
  __int64 v28; // rax
  int v29; // eax
  __int64 *v30; // rax
  __int64 v31; // r13
  char *v32; // r11
  __int64 v33; // rax
  _QWORD *v34; // r9
  HWND v35; // rax
  const WCHAR *v36; // rdx
  HWND v37; // rsi
  __int64 v38; // rdx
  WCHAR *v39; // rcx
  void *v40; // rax
  HFONT v41; // rax
  HWND v42; // rcx
  _DWORD *v43; // rax
  HWND v44; // rbx
  HWND Parent; // rax
  ICONINFO piconinfo; // [rsp+40h] [rbp-C0h] BYREF
  SHFILEINFOW psfi; // [rsp+60h] [rbp-A0h] BYREF
  LOGFONTW pv; // [rsp+320h] [rbp+220h] BYREF
  WCHAR Buffer[64]; // [rsp+380h] [rbp+280h] BYREF
  WCHAR String[32]; // [rsp+400h] [rbp+300h] BYREF
  WCHAR v52[264]; // [rsp+440h] [rbp+340h] BYREF
  WCHAR pszPath[264]; // [rsp+650h] [rbp+550h] BYREF

  v1 = (const WCHAR *)(a1 + 80);
  if ( *(_QWORD *)(a1 + 104) < 8ui64 )
    v3 = (const WCHAR *)(a1 + 80);
  else
    v3 = *(const WCHAR **)v1;
  if ( SHGetFileInfoW(v3, 0, &psfi, 0x2B8u, 0x100u) )
  {
    GetIconInfo(psfi.hIcon, &piconinfo);
    SendDlgItemMessageW(*(HWND *)(a1 + 8), 1297, 0x172u, 0i64, (LPARAM)piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmMask);
    DestroyIcon(psfi.hIcon);
  }
  if ( *((_QWORD *)v1 + 3) < 8ui64 )
    v4 = v1;
  else
    v4 = *(const WCHAR **)v1;
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1295, v4);
  if ( *((_QWORD *)v1 + 3) < 8ui64 )
    v5 = v1;
  else
    v5 = *(const WCHAR **)v1;
  FileW = CreateFileW(v5, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
  v7 = FileW;
  if ( FileW != (HANDLE)-1i64 )
  {
    GetFileSizeEx(FileW, (PLARGE_INTEGER)&piconinfo);
    sub_140083DE0(*(__int64 *)&piconinfo.fIcon, (char *)String, 0x20ui64, 0, 0);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1296, String);
    CloseHandle(v7);
  }
  if ( *((_QWORD *)v1 + 3) < 8ui64 )
    v8 = v1;
  else
    v8 = *(const WCHAR **)v1;
  v9 = 260i64;
  v10 = pszPath;
  v11 = (char *)v8 - (char *)pszPath;
  while ( v9 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v10 + v11);
    if ( !v12 )
      break;
    *v10++ = v12;
    if ( !--v9 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  PathRemoveFileSpecW(pszPath);
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1141, pszPath);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1140);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x86Eu, Buffer, 64);
  v14 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)Buffer);
  piconinfo.xHotspot = 0;
  piconinfo.fIcon = v14;
  v15 = *(__int64 **)(a1 + 136);
  v16 = *v15;
  v17 = sub_14001A690(*v15, *(_QWORD *)(*v15 + 8), &piconinfo);
  v18 = *(_QWORD *)(a1 + 144);
  if ( v18 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 144) = v18 + 1;
  *(_QWORD *)(v16 + 8) = v17;
  **((_QWORD **)v17 + 1) = v17;
  sub_140019DD0(
    (_QWORD *)(a1 + 128),
    (__int64)&piconinfo,
    (int *)(**(_QWORD **)(a1 + 136) + 16i64),
    **(_QWORD **)(a1 + 136));
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x86Fu, Buffer, 64);
  v19 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)Buffer);
  piconinfo.xHotspot = 1;
  piconinfo.fIcon = v19;
  v20 = *(__int64 **)(a1 + 136);
  v21 = *v20;
  v22 = sub_14001A690(*v20, *(_QWORD *)(*v20 + 8), &piconinfo);
  v23 = *(_QWORD *)(a1 + 144);
  if ( v23 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 144) = v23 + 1;
  *(_QWORD *)(v21 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  sub_140019DD0(
    (_QWORD *)(a1 + 128),
    (__int64)&piconinfo,
    (int *)(**(_QWORD **)(a1 + 136) + 16i64),
    **(_QWORD **)(a1 + 136));
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x870u, Buffer, 64);
  v24 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)Buffer);
  piconinfo.xHotspot = 2;
  piconinfo.fIcon = v24;
  v25 = *(__int64 **)(a1 + 136);
  v26 = *v25;
  v27 = sub_14001A690(*v25, *(_QWORD *)(*v25 + 8), &piconinfo);
  v28 = *(_QWORD *)(a1 + 144);
  if ( v28 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 144) = v28 + 1;
  *(_QWORD *)(v26 + 8) = v27;
  **((_QWORD **)v27 + 1) = v27;
  sub_140019DD0(
    (_QWORD *)(a1 + 128),
    (__int64)&piconinfo,
    (int *)(**(_QWORD **)(a1 + 136) + 16i64),
    **(_QWORD **)(a1 + 136));
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x871u, Buffer, 64);
  v29 = SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)Buffer);
  piconinfo.xHotspot = 3;
  piconinfo.fIcon = v29;
  v30 = *(__int64 **)(a1 + 136);
  v31 = *v30;
  v32 = sub_14001A690(*v30, *(_QWORD *)(*v30 + 8), &piconinfo);
  v33 = *(_QWORD *)(a1 + 144);
  if ( 0x1FFFFFFFFFFFFFFEi64 == v33 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 144) = v33 + 1;
  *(_QWORD *)(v31 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  sub_140019DD0(
    (_QWORD *)(a1 + 128),
    (__int64)&piconinfo,
    (int *)(**(_QWORD **)(a1 + 136) + 16i64),
    **(_QWORD **)(a1 + 136));
  v34 = (_QWORD *)(*(_QWORD *)(a1 + 304) + 584i64);
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 304) + 608i64) >= 8ui64 )
    v34 = (_QWORD *)*v34;
  SendMessageW(DlgItem, 0x14Du, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v34);
  v35 = GetDlgItem(*(HWND *)(a1 + 8), 1139);
  v36 = (const WCHAR *)(*(_QWORD *)(a1 + 304) + 544i64);
  v37 = v35;
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 304) + 568i64) >= 8ui64 )
    v36 = *(const WCHAR **)v36;
  SetWindowTextW(v35, v36);
  SendMessageW(v37, 0xB1u, 0i64, -1i64);
  SetFocus(v37);
  if ( *((_QWORD *)v1 + 3) >= 8ui64 )
    v1 = *(const WCHAR **)v1;
  v38 = 260i64;
  v39 = v52;
  while ( v38 != -2147483386 && *v1 )
  {
    *v39++ = *v1++;
    if ( !--v38 )
    {
      --v39;
      break;
    }
  }
  *v39 = 0;
  PathStripPathW(v52);
  sub_140001000(v52, 0x104ui64, L"%s.part%s", v52, L"/N");
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1293, v52);
  v40 = (void *)SendDlgItemMessageW(*(HWND *)(a1 + 8), 1298, 0x31u, 0i64, 0i64);
  GetObjectW(v40, 92, &pv);
  pv.lfItalic = 1;
  v41 = CreateFontIndirectW(&pv);
  v42 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 224) = v41;
  SendDlgItemMessageW(v42, 1298, 0x30u, (WPARAM)v41, 1i64);
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1301, L"00:00:00");
  v43 = *(_DWORD **)(a1 + 304);
  v44 = *(HWND *)(a1 + 8);
  if ( v43[2] )
  {
    SetWindowPos(v44, 0i64, v43[3], v43[4], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v44);
    sub_140081E00(Parent, v44);
  }
  return 0i64;
}
// 140099A37: conditional instruction was optimized away because rdx.8!=0
// 140099E09: conditional instruction was optimized away because rdx.8!=0
// 1400EFD34: using guessed type wchar_t aN[3];
// 1400EFD98: using guessed type wchar_t aSPartS[10];

//----- (000000014009A080) ----------------------------------------------------
__int64 __fastcall sub_14009A080(
        __int64 a1,
        const ITEMIDLIST *a2,
        __int64 a3,
        unsigned int a4,
        const WCHAR *lpWideCharStr,
        int a6)
{
  HRESULT v10; // ebx
  bool v11; // zf
  struct IShellFolderVtbl *lpVtbl; // rax
  __int64 v13; // rax
  __int64 v15; // [rsp+48h] [rbp-89h] BYREF
  IShellFolder *ppshf; // [rsp+50h] [rbp-81h] BYREF
  __int64 v17; // [rsp+58h] [rbp-79h] BYREF
  void *ppv; // [rsp+60h] [rbp-71h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+68h] [rbp-69h] BYREF
  int v20[2]; // [rsp+70h] [rbp-61h] BYREF
  __int64 v21; // [rsp+78h] [rbp-59h]
  CHAR *v22; // [rsp+80h] [rbp-51h]
  __int64 v23; // [rsp+88h] [rbp-49h]
  __int64 v24; // [rsp+90h] [rbp-41h]
  int v25; // [rsp+98h] [rbp-39h]
  CHAR MultiByteStr[32]; // [rsp+A8h] [rbp-29h] BYREF

  ppshf = 0i64;
  ppv = 0i64;
  v17 = 0i64;
  v15 = 0i64;
  ppidlLast = 0i64;
  if ( a4 )
  {
    v10 = SHGetDesktopFolder(&ppshf);
    if ( v10 >= 0 )
    {
      v11 = (unsigned int)sub_14007DF90((__int64)a2) == 0;
      lpVtbl = ppshf->lpVtbl;
      if ( v11 )
      {
        v10 = ((__int64 (__fastcall *)(IShellFolder *, const ITEMIDLIST *, _QWORD, const IID *, __int64 *))lpVtbl->BindToObject)(
                ppshf,
                a2,
                0i64,
                &stru_1400E3FB0,
                &v17);
        if ( v10 >= 0 )
        {
          v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int64, void *, _QWORD, __int64 *))(*(_QWORD *)v17 + 80i64))(
                  v17,
                  *(_QWORD *)(a1 + 104),
                  a4,
                  a3,
                  &unk_1400E3FA0,
                  0i64,
                  &v15);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v17 + 16i64))(v17);
          v17 = 0i64;
        }
      }
      else
      {
        v10 = ((__int64 (__fastcall *)(IShellFolder *, _QWORD, _QWORD, __int64, void *, _QWORD, __int64 *))lpVtbl->GetUIObjectOf)(
                ppshf,
                *(_QWORD *)(a1 + 104),
                a4,
                a3,
                &unk_1400E3FA0,
                0i64,
                &v15);
      }
      ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
      ppshf = 0i64;
    }
  }
  else
  {
    v10 = SHBindToParent(a2, &stru_1400E3FB0, &ppv, &ppidlLast);
    if ( v10 >= 0 )
    {
      v10 = (*(__int64 (__fastcall **)(void *, _QWORD, _QWORD, LPCITEMIDLIST *, void *, _QWORD, __int64 *))(*(_QWORD *)ppv + 80i64))(
              ppv,
              *(_QWORD *)(a1 + 104),
              a4 + 1,
              &ppidlLast,
              &unk_1400E3FA0,
              0i64,
              &v15);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      ppv = 0i64;
    }
  }
  if ( v15 )
  {
    WideCharToMultiByte(0, 0, lpWideCharStr, -1, MultiByteStr, 32, 0i64, 0i64);
    v20[1] = a6;
    v13 = *(_QWORD *)(a1 + 104);
    v20[0] = 56;
    v21 = v13;
    v23 = 0i64;
    v24 = 0i64;
    v25 = 5;
    v22 = MultiByteStr;
    v10 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v15 + 32i64))(v15, v20);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16i64))(v15);
  }
  return (unsigned int)v10;
}

//----- (000000014009A2D0) ----------------------------------------------------
__int64 __fastcall sub_14009A2D0(__int64 a1, const ITEMIDLIST *a2, __int64 a3, unsigned int a4)
{
  return sub_14009A080(a1, a2, a3, a4, L"properties", 0);
}
// 1400EFED0: using guessed type wchar_t aProperties_0[11];

//----- (000000014009A300) ----------------------------------------------------
void __fastcall sub_14009A300(__int64 a1, const ITEMIDLIST *a2, __int64 a3, int a4)
{
  _QWORD *v6; // rdx
  void *v7; // rbx
  ITEMIDLIST *v8; // rdi
  int v9; // ebx
  LPVOID pv; // [rsp+30h] [rbp-268h] BYREF
  void *Block[5]; // [rsp+38h] [rbp-260h] BYREF
  WCHAR pszBuf[264]; // [rsp+60h] [rbp-238h] BYREF

  if ( a4 == 1001 )
  {
    if ( *(_QWORD *)(a3 + 8) )
    {
      v6 = *(_QWORD **)a3;
      memset(Block, 0, 24);
      sub_14001C7D0((__int64 **)Block, (_QWORD *)*v6, v6);
      v7 = Block[0];
      v8 = ILCombine(a2, *(LPCITEMIDLIST *)Block[0]);
      j_free(v7);
    }
    else
    {
      v8 = ILClone(a2);
    }
    sub_14007E270(v8, pszBuf, 0x8000u);
    pv = 0i64;
    v9 = sub_14007F810((__int64)pszBuf, (__int64)&pv);
    (*(void (__fastcall **)(__int64, LPVOID, _QWORD, __int64, int, _DWORD))(*(_QWORD *)(a1 + 16) + 80i64))(
      a1 + 16,
      pv,
      0i64,
      1i64,
      1,
      0);
    if ( v9 >= 0 )
      CoTaskMemFree(pv);
    *(_DWORD *)(a1 + 7000) = 1;
    CoTaskMemFree(v8);
  }
}

//----- (000000014009A430) ----------------------------------------------------
void __fastcall sub_14009A430(__int64 a1, __int64 a2, __int64 a3, int *a4, HMENU hmenu)
{
  int v5; // eax
  _QWORD *v6; // rdx
  void *v7; // rbx
  const ITEMIDLIST *v8; // rcx
  int v9; // [rsp+20h] [rbp-128h] BYREF
  void *ppv; // [rsp+28h] [rbp-120h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+30h] [rbp-118h] BYREF
  void *Block[5]; // [rsp+38h] [rbp-110h] BYREF
  MENUITEMINFOW mi; // [rsp+60h] [rbp-E8h] BYREF
  WCHAR Buffer[64]; // [rsp+B0h] [rbp-98h] BYREF

  Block[4] = (void *)-2i64;
  v5 = *a4;
  if ( (!*a4 || v5 == 1 || v5 == 3) && *(_QWORD *)(a3 + 8) == 1i64 )
  {
    v9 = 0x20000000;
    v6 = *(_QWORD **)a3;
    memset(Block, 0, 24);
    sub_14001C7D0((__int64 **)Block, (_QWORD *)*v6, v6);
    v7 = Block[0];
    v8 = *(const ITEMIDLIST **)Block[0];
    if ( *(_QWORD *)Block[0] )
    {
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v8, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        (*(void (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
          ppv,
          1i64,
          &ppidlLast,
          &v9);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    if ( (v9 & 0x20000000) != 0 )
    {
      LoadStringW(hInstance, 0x86Du, Buffer, 64);
      mi.cbSize = 80;
      mi.fMask = 66;
      mi.wID = 1001;
      mi.dwTypeData = Buffer;
      InsertMenuItemW(hmenu, 1u, 1, &mi);
    }
    j_free(v7);
  }
}

//----- (000000014009A5B0) ----------------------------------------------------
__int64 __fastcall sub_14009A5B0(__int64 a1, const ITEMIDLIST *a2, __int64 ***a3, _DWORD *a4, const WCHAR *psz1)
{
  __int64 **v10; // rdi
  __int64 *v11; // rbx
  LPITEMIDLIST v12; // rsi

  if ( StrCmpIW(psz1, L"open") )
  {
    if ( StrCmpIW(psz1, L"rename") )
    {
      if ( StrCmpIW(psz1, L"copy") )
      {
        if ( StrCmpIW(psz1, L"cut") )
        {
          return 0i64;
        }
        else if ( *a4 )
        {
          if ( *a4 == 1 )
            sub_1400932D0(a1 - 40, 0i64);
          return 1i64;
        }
        else
        {
          sub_1400BF540(a1 - 40, 0i64);
          return 1i64;
        }
      }
      else if ( *a4 )
      {
        if ( *a4 == 1 )
          sub_1400932D0(a1 - 40, 1i64);
        return 1i64;
      }
      else
      {
        sub_1400BF540(a1 - 40, 1i64);
        return 1i64;
      }
    }
    else if ( *a4 )
    {
      if ( *a4 == 1 )
        sub_1400926D0(a1 - 40);
      return 1i64;
    }
    else
    {
      sub_1400D19A0(a1 - 40);
      return 1i64;
    }
  }
  else if ( a3[1] )
  {
    v10 = *a3;
    v11 = **a3;
    if ( v11 != (__int64 *)*a3 )
    {
      do
      {
        v12 = ILCombine(a2, (LPCITEMIDLIST)v11[2]);
        (*(void (__fastcall **)(__int64, LPITEMIDLIST, _QWORD, _QWORD))(*(_QWORD *)(a1 + 16) + 64i64))(
          a1 + 16,
          v12,
          0i64,
          0i64);
        CoTaskMemFree(v12);
        v11 = (__int64 *)*v11;
      }
      while ( v11 != (__int64 *)v10 );
    }
    *(_DWORD *)(a1 + 7000) = 1;
    return 1i64;
  }
  else
  {
    (*(void (__fastcall **)(__int64, const ITEMIDLIST *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 16) + 64i64))(
      a1 + 16,
      a2,
      0i64,
      0i64);
    *(_DWORD *)(a1 + 7000) = 1;
    return 1i64;
  }
}
// 1400932D0: using guessed type __int64 __fastcall sub_1400932D0(_QWORD, _QWORD);
// 1400BF540: using guessed type __int64 __fastcall sub_1400BF540(_QWORD, _QWORD);

//----- (000000014009A760) ----------------------------------------------------
void **__fastcall sub_14009A760(_QWORD *a1)
{
  void **result; // rax

  result = &CDialogSettings::`vftable';
  *a1 = &CDialogSettings::`vftable';
  return result;
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (000000014009A780) ----------------------------------------------------
LRESULT __fastcall sub_14009A780(HWND a1, int a2)
{
  LRESULT result; // rax

  if ( a2 )
    return SendMessageW(a1, 0xF4u, 3ui64, 0i64);
  return result;
}

//----- (000000014009A7E0) ----------------------------------------------------
void __fastcall sub_14009A7E0(__int64 a1, int a2)
{
  int v3; // edx
  HWND DlgItem; // rax
  int v5; // edx
  HWND v6; // rax
  LPARAM v7; // r9
  HWND v8; // rax
  HWND v9; // rax

  if ( a2 )
  {
    v3 = a2 - 1;
    if ( v3 )
    {
      if ( v3 != 1 )
        return;
      DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1051);
      SendMessageW(DlgItem, 0x1002u, 0i64, a1 + 152);
      v5 = 1052;
    }
    else
    {
      v8 = GetDlgItem(*(HWND *)(a1 + 8), 1049);
      SendMessageW(v8, 0x1002u, 0i64, a1 + 152);
      v5 = 1050;
    }
    v6 = GetDlgItem(*(HWND *)(a1 + 8), v5);
    v7 = a1 + 152;
  }
  else
  {
    v9 = GetDlgItem(*(HWND *)(a1 + 8), 1043);
    SendMessageW(v9, 0x1002u, 0i64, a1 + 136);
    v6 = GetDlgItem(*(HWND *)(a1 + 8), 1048);
    v7 = a1 + 136;
  }
  SendMessageW(v6, 0x1002u, 0i64, v7);
}

//----- (000000014009A8F0) ----------------------------------------------------
__int64 __fastcall sub_14009A8F0(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (000000014009A910) ----------------------------------------------------
__int64 __fastcall sub_14009A910(__int64 a1, __int64 a2)
{
  BOOL v4; // ebp
  BOOL v5; // ebx
  HWND v6; // rax
  int v7; // edx
  BOOL v8; // ebx
  HWND v9; // rax
  BOOL v10; // ebx
  HWND DlgItem; // rax
  HWND v12; // rax

  if ( *(_DWORD *)(a2 + 16) == -759 )
  {
    switch ( *(_QWORD *)(a2 + 8) )
    {
      case 0x413i64:
        v4 = 0;
        *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 24) == 0;
        v10 = *(_DWORD *)(a2 + 24) == 0;
        DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1048);
        EnableWindow(DlgItem, v10);
        v7 = 1111;
        break;
      case 0x419i64:
        v4 = 0;
        *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 24) == 0;
        v8 = *(_DWORD *)(a2 + 24) == 0;
        v9 = GetDlgItem(*(HWND *)(a1 + 8), 1050);
        EnableWindow(v9, v8);
        v7 = 1054;
        break;
      case 0x41Bi64:
        v4 = 0;
        *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 24) == 0;
        v5 = *(_DWORD *)(a2 + 24) == 0;
        v6 = GetDlgItem(*(HWND *)(a1 + 8), 1052);
        EnableWindow(v6, v5);
        v7 = 1055;
        break;
      default:
        return 0i64;
    }
    LOBYTE(v4) = *(_DWORD *)(a2 + 24) == 0;
    v12 = GetDlgItem(*(HWND *)(a1 + 8), v7);
    EnableWindow(v12, v4);
    return 0i64;
  }
  return 0i64;
}

//----- (000000014009AA50) ----------------------------------------------------
__int64 __fastcall sub_14009AA50(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 128);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 128);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (000000014009AAE0) ----------------------------------------------------
void __fastcall sub_14009AAE0(__int64 a1)
{
  _QWORD **v2; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  _QWORD **v5; // rax
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx

  *(_QWORD *)a1 = &CSetFileAttributesDialog::`vftable';
  v2 = *(_QWORD ***)(a1 + 104);
  v3 = *v2;
  *v2 = v2;
  *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8i64) = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 112) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 104) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 104) );
  }
  j_free(*(void **)(a1 + 104));
  v5 = *(_QWORD ***)(a1 + 80);
  v6 = *v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8i64) = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 88) = 0i64;
  if ( v6 != *(_QWORD **)(a1 + 80) )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *(_QWORD **)(a1 + 80) );
  }
  j_free(*(void **)(a1 + 80));
  sub_140084540((_QWORD *)a1);
}
// 1400F7788: using guessed type void *CSetFileAttributesDialog::`vftable';

//----- (000000014009AB90) ----------------------------------------------------
__int64 *sub_14009AB90()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012EDAC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"SetFileAttributes" - (char *)&unk_14012EDAC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012ED98 = 0;
  qword_14012ED90 = (__int64)&CSetFileAttributesDialogPersistentSettings::`vftable';
  result = &qword_14012ED90;
  byte_14012EFAC = 1;
  return result;
}
// 14009ABD7: conditional instruction was optimized away because rdx.8!=0
// 1400EFEE8: using guessed type wchar_t aSetfileattribu_0[18];
// 1400F77F8: using guessed type void *CSetFileAttributesDialogPersistentSettings::`vftable';
// 14012ED90: using guessed type __int64 qword_14012ED90;
// 14012ED98: using guessed type int dword_14012ED98;
// 14012EFAC: using guessed type char byte_14012EFAC;

//----- (000000014009AC10) ----------------------------------------------------
BOOL __fastcall sub_14009AC10(__int64 a1)
{
  int v2; // er14
  struct _FILETIME *p_FileTime; // r15
  HWND DlgItem; // rax
  HWND v5; // rax
  HWND v6; // rax
  HWND v7; // rax
  HWND v8; // rax
  HWND v9; // rax
  _QWORD *v10; // rdi
  _QWORD *v11; // rbx
  int v12; // er12
  HWND v13; // rcx
  int v14; // esi
  int v15; // eax
  HWND v16; // rax
  int v17; // eax
  _QWORD *v18; // rdi
  _QWORD *i; // rbx
  __int64 **v20; // rcx
  DWORD v21; // er11
  __int64 *j; // rax
  unsigned int v23; // er8
  int v24; // er9
  unsigned int v25; // edx
  HANDLE FileW; // rax
  void *v27; // rsi
  struct _FILETIME *lpCreationTime; // [rsp+40h] [rbp-C0h]
  struct _FILETIME *lpLastAccessTime; // [rsp+48h] [rbp-B8h]
  struct _FILETIME v31; // [rsp+50h] [rbp-B0h] BYREF
  struct _FILETIME FileTime; // [rsp+58h] [rbp-A8h] BYREF
  struct _FILETIME v33; // [rsp+60h] [rbp-A0h] BYREF
  SYSTEMTIME LocalTime; // [rsp+68h] [rbp-98h] BYREF
  LPARAM v35; // [rsp+78h] [rbp-88h] BYREF
  unsigned __int64 v36; // [rsp+80h] [rbp-80h]
  LPARAM lParam; // [rsp+88h] [rbp-78h] BYREF
  WORD v38; // [rsp+90h] [rbp-70h]
  WORD v39; // [rsp+92h] [rbp-6Eh]
  WORD v40; // [rsp+94h] [rbp-6Ch]
  WORD v41; // [rsp+96h] [rbp-6Ah]
  struct _SYSTEMTIME UniversalTime; // [rsp+98h] [rbp-68h] BYREF
  WCHAR FileName[260]; // [rsp+B0h] [rbp-50h] BYREF
  int v44; // [rsp+2B8h] [rbp+1B8h]

  v2 = 128;
  p_FileTime = 0i64;
  lpCreationTime = 0i64;
  lpLastAccessTime = 0i64;
  if ( *(_DWORD *)(a1 + 184) )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1043);
    SendMessageW(DlgItem, 0x1001u, 0i64, (LPARAM)&lParam);
    v5 = GetDlgItem(*(HWND *)(a1 + 8), 1048);
    SendMessageW(v5, 0x1001u, 0i64, (LPARAM)&v35);
    *(_QWORD *)&LocalTime.wHour = v36;
    *(_QWORD *)&LocalTime.wYear = lParam;
    TzSpecificLocalTimeToSystemTime(0i64, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &FileTime);
    p_FileTime = &FileTime;
  }
  if ( *(_DWORD *)(a1 + 188) )
  {
    v6 = GetDlgItem(*(HWND *)(a1 + 8), 1049);
    SendMessageW(v6, 0x1001u, 0i64, (LPARAM)&v35);
    v7 = GetDlgItem(*(HWND *)(a1 + 8), 1050);
    SendMessageW(v7, 0x1001u, 0i64, (LPARAM)&lParam);
    LocalTime.wHour = v38;
    *(_QWORD *)&LocalTime.wYear = v35;
    LocalTime.wMinute = v39;
    LocalTime.wSecond = v40;
    LocalTime.wMilliseconds = v41;
    TzSpecificLocalTimeToSystemTime(0i64, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &v33);
    lpCreationTime = &v33;
  }
  if ( *(_DWORD *)(a1 + 192) )
  {
    v8 = GetDlgItem(*(HWND *)(a1 + 8), 1051);
    SendMessageW(v8, 0x1001u, 0i64, (LPARAM)&v35);
    v9 = GetDlgItem(*(HWND *)(a1 + 8), 1052);
    SendMessageW(v9, 0x1001u, 0i64, (LPARAM)&lParam);
    LocalTime.wHour = v38;
    *(_QWORD *)&LocalTime.wYear = v35;
    LocalTime.wMinute = v39;
    LocalTime.wSecond = v40;
    LocalTime.wMilliseconds = v41;
    TzSpecificLocalTimeToSystemTime(0i64, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &v31);
    lpLastAccessTime = &v31;
  }
  v10 = *(_QWORD **)(a1 + 104);
  v11 = (_QWORD *)*v10;
  if ( (_QWORD *)*v10 != v10 )
  {
    while ( 1 )
    {
      v12 = *((_DWORD *)v11 + 4);
      v13 = *(HWND *)(a1 + 8);
      v14 = *((_DWORD *)v11 + 7);
      HIDWORD(v35) = *((_DWORD *)v11 + 5);
      v15 = *((_DWORD *)v11 + 6);
      LODWORD(v35) = v12;
      LODWORD(v36) = v15;
      v16 = GetDlgItem(v13, SHIDWORD(v35));
      v17 = SendMessageW(v16, 0xF0u, 0i64, 0i64);
      if ( !v14 )
        break;
      if ( v17 != 1 )
        goto LABEL_12;
LABEL_13:
      v11 = (_QWORD *)*v11;
      if ( v11 == v10 )
        goto LABEL_14;
    }
    if ( v17 != 1 )
      goto LABEL_13;
LABEL_12:
    v2 |= v12;
    goto LABEL_13;
  }
LABEL_14:
  v18 = *(_QWORD **)(a1 + 80);
  for ( i = (_QWORD *)*v18; i != v18; i = (_QWORD *)*i )
  {
    memmove(FileName, i + 2, 0x458ui64);
    v20 = *(__int64 ***)(a1 + 104);
    v21 = v2;
    for ( j = *v20; j != (__int64 *)v20; j = (__int64 *)*j )
    {
      v23 = *((_DWORD *)j + 6);
      v24 = *((_DWORD *)j + 4);
      HIDWORD(v35) = *((_DWORD *)j + 5);
      v25 = *((_DWORD *)j + 7);
      v36 = __PAIR64__(v25, v23);
      if ( __PAIR64__(v25, v23) == 2 && (v24 & v44) != 0 )
        v21 |= v24;
    }
    SetFileAttributesW(FileName, v21);
    FileW = CreateFileW(FileName, 0x100u, 0, 0i64, 3u, 0, 0i64);
    v27 = FileW;
    if ( FileW != (HANDLE)-1i64 )
    {
      SetFileTime(FileW, lpCreationTime, lpLastAccessTime, p_FileTime);
      CloseHandle(v27);
    }
  }
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (000000014009B060) ----------------------------------------------------
__int64 __fastcall sub_14009B060(__int64 a1, __int16 a2)
{
  HWND v3; // rax
  HWND v4; // rax
  LPARAM v5; // r9
  HWND v6; // rax
  int v7; // edx
  HWND DlgItem; // rax

  if ( a2 == 1 )
  {
    sub_14009AC10(a1);
    return 0i64;
  }
  else
  {
    if ( a2 != 2 )
    {
      switch ( a2 )
      {
        case 1054:
          DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1049);
          SendMessageW(DlgItem, 0x1002u, 0i64, a1 + 152);
          v7 = 1050;
          break;
        case 1055:
          v6 = GetDlgItem(*(HWND *)(a1 + 8), 1051);
          SendMessageW(v6, 0x1002u, 0i64, a1 + 152);
          v7 = 1052;
          break;
        case 1111:
          v3 = GetDlgItem(*(HWND *)(a1 + 8), 1043);
          SendMessageW(v3, 0x1002u, 0i64, a1 + 136);
          v4 = GetDlgItem(*(HWND *)(a1 + 8), 1048);
          v5 = a1 + 136;
LABEL_9:
          SendMessageW(v4, 0x1002u, 0i64, v5);
          return 0i64;
        default:
          return 0i64;
      }
      v4 = GetDlgItem(*(HWND *)(a1 + 8), v7);
      v5 = a1 + 152;
      goto LABEL_9;
    }
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
}

//----- (000000014009B190) ----------------------------------------------------
char **__fastcall sub_14009B190(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // rdx
  char *v4; // r11
  __int64 v5; // rax
  __int64 v6; // rsi
  __int64 v7; // rdx
  char *v8; // r11
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdx
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rdx
  char *v16; // r11
  __int64 v17; // rax
  __int64 v18; // rsi
  __int64 v19; // rdx
  char *v20; // r11
  __int64 v21; // rax
  char **result; // rax
  int v23; // [rsp+20h] [rbp-18h] BYREF
  int v24; // [rsp+24h] [rbp-14h]
  int v25; // [rsp+2Ch] [rbp-Ch]

  v1 = *(_QWORD *)(a1 + 104);
  v3 = *(_QWORD *)(v1 + 8);
  v23 = 32;
  v24 = 1060;
  v25 = 0;
  v4 = sub_140024640(v1, v3, &v23);
  v5 = *(_QWORD *)(a1 + 112);
  if ( v5 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v23 = 2;
  *(_QWORD *)(a1 + 112) = v5 + 1;
  *(_QWORD *)(v1 + 8) = v4;
  **((_QWORD **)v4 + 1) = v4;
  v6 = *(_QWORD *)(a1 + 104);
  v24 = 1061;
  v7 = *(_QWORD *)(v6 + 8);
  v25 = 0;
  v8 = sub_140024640(v6, v7, &v23);
  v9 = *(_QWORD *)(a1 + 112);
  if ( v9 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v23 = 4;
  *(_QWORD *)(a1 + 112) = v9 + 1;
  *(_QWORD *)(v6 + 8) = v8;
  **((_QWORD **)v8 + 1) = v8;
  v10 = *(_QWORD *)(a1 + 104);
  v24 = 1059;
  v11 = *(_QWORD *)(v10 + 8);
  v25 = 0;
  v12 = sub_140024640(v10, v11, &v23);
  v13 = *(_QWORD *)(a1 + 112);
  if ( v13 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v23 = 1;
  *(_QWORD *)(a1 + 112) = v13 + 1;
  *(_QWORD *)(v10 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *(_QWORD *)(a1 + 104);
  v24 = 1062;
  v15 = *(_QWORD *)(v14 + 8);
  v25 = 0;
  v16 = sub_140024640(v14, v15, &v23);
  v17 = *(_QWORD *)(a1 + 112);
  if ( v17 == 0xFFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v23 = 0x2000;
  *(_QWORD *)(a1 + 112) = v17 + 1;
  *(_QWORD *)(v14 + 8) = v16;
  **((_QWORD **)v16 + 1) = v16;
  v18 = *(_QWORD *)(a1 + 104);
  v24 = 1063;
  v19 = *(_QWORD *)(v18 + 8);
  v25 = 1;
  v20 = sub_140024640(v18, v19, &v23);
  v21 = *(_QWORD *)(a1 + 112);
  if ( 0xFFFFFFFFFFFFFFEi64 == v21 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 112) = v21 + 1;
  *(_QWORD *)(v18 + 8) = v20;
  result = (char **)*((_QWORD *)v20 + 1);
  *result = v20;
  return result;
}

//----- (000000014009B3A0) ----------------------------------------------------
BOOL __fastcall sub_14009B3A0(__int64 a1)
{
  __int64 v2; // rbx
  HWND DlgItem; // rax
  HWND v4; // rax
  HWND v5; // rax
  HWND v6; // rax
  HWND v7; // rax
  HWND v8; // rax
  HWND v9; // rax
  HWND v10; // rax
  HWND v11; // rax
  HWND v12; // rax
  HWND v13; // rax
  HWND v14; // rax
  HWND v15; // rax
  HWND v16; // rax
  HWND v17; // rax
  struct _SYSTEMTIME SystemTime; // [rsp+20h] [rbp-28h] BYREF

  v2 = **(_QWORD **)(a1 + 80);
  FileTimeToSystemTime((const FILETIME *)(v2 + 556), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, (LPSYSTEMTIME)(a1 + 136));
  FileTimeToSystemTime((const FILETIME *)(v2 + 540), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, (LPSYSTEMTIME)(a1 + 152));
  FileTimeToSystemTime((const FILETIME *)(v2 + 548), &SystemTime);
  SystemTimeToTzSpecificLocalTime(0i64, &SystemTime, (LPSYSTEMTIME)(a1 + 152));
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1043);
  SendMessageW(DlgItem, 0x1002u, 0i64, a1 + 136);
  v4 = GetDlgItem(*(HWND *)(a1 + 8), 1048);
  SendMessageW(v4, 0x1002u, 0i64, a1 + 136);
  v5 = GetDlgItem(*(HWND *)(a1 + 8), 1049);
  SendMessageW(v5, 0x1002u, 0i64, a1 + 152);
  v6 = GetDlgItem(*(HWND *)(a1 + 8), 1050);
  SendMessageW(v6, 0x1002u, 0i64, a1 + 152);
  v7 = GetDlgItem(*(HWND *)(a1 + 8), 1051);
  SendMessageW(v7, 0x1002u, 0i64, a1 + 152);
  v8 = GetDlgItem(*(HWND *)(a1 + 8), 1052);
  SendMessageW(v8, 0x1002u, 0i64, a1 + 152);
  v9 = GetDlgItem(*(HWND *)(a1 + 8), 1043);
  SendMessageW(v9, 0x1002u, 1ui64, 0i64);
  v10 = GetDlgItem(*(HWND *)(a1 + 8), 1048);
  EnableWindow(v10, 0);
  v11 = GetDlgItem(*(HWND *)(a1 + 8), 1111);
  EnableWindow(v11, 0);
  v12 = GetDlgItem(*(HWND *)(a1 + 8), 1049);
  SendMessageW(v12, 0x1002u, 1ui64, 0i64);
  v13 = GetDlgItem(*(HWND *)(a1 + 8), 1050);
  EnableWindow(v13, 0);
  v14 = GetDlgItem(*(HWND *)(a1 + 8), 1054);
  EnableWindow(v14, 0);
  v15 = GetDlgItem(*(HWND *)(a1 + 8), 1051);
  SendMessageW(v15, 0x1002u, 1ui64, 0i64);
  v16 = GetDlgItem(*(HWND *)(a1 + 8), 1052);
  EnableWindow(v16, 0);
  v17 = GetDlgItem(*(HWND *)(a1 + 8), 1055);
  return EnableWindow(v17, 0);
}

//----- (000000014009B660) ----------------------------------------------------
__int64 __fastcall sub_14009B660(__int64 a1)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx
  int v4; // esi
  int v5; // er12
  int v6; // er14
  int v7; // er15
  int v8; // er13
  int v9; // edi
  int v10; // ebx
  HWND DlgItem; // rax
  BOOL v12; // ebx
  HWND v13; // rax
  BOOL v14; // ebx
  HWND v15; // rax
  BOOL v16; // ebx
  HWND v17; // rax
  HWND v18; // rax
  HWND v19; // rax
  unsigned int v20; // ecx
  HWND v21; // rax
  unsigned int v22; // ecx
  HWND v23; // rax
  unsigned int v24; // ecx
  HWND v25; // rax
  unsigned int v26; // ecx
  HWND v27; // rax
  unsigned int v28; // ecx
  _DWORD *v29; // rax
  HWND v30; // rbx
  HWND Parent; // rax
  char v33[520]; // [rsp+40h] [rbp-498h] BYREF
  int v34; // [rsp+248h] [rbp-290h]
  int v35; // [rsp+4E0h] [rbp+8h]
  int v36; // [rsp+4E8h] [rbp+10h]

  sub_14009B190(a1);
  sub_14009B3A0(a1);
  v2 = *(_QWORD **)(a1 + 80);
  v3 = (_QWORD *)*v2;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v35 = *(_DWORD *)(a1 + 88);
  v36 = 1;
  if ( (_QWORD *)*v2 == v2 )
  {
    v9 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    do
    {
      memmove(v33, v3 + 2, 0x458ui64);
      if ( (v34 & 0x20) != 0 )
        ++v4;
      if ( (v34 & 2) != 0 )
        ++v5;
      if ( (v34 & 4) != 0 )
        ++v6;
      if ( (v34 & 1) != 0 )
        ++v7;
      if ( (v34 & 0x2000) == 0 )
        ++v8;
      v3 = (_QWORD *)*v3;
    }
    while ( v3 != v2 );
    v9 = v35;
    if ( v4 && v4 != v35 )
    {
      v10 = 0;
      goto LABEL_18;
    }
  }
  v10 = 1;
LABEL_18:
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1060);
  if ( v10 )
    SendMessageW(DlgItem, 0xF4u, 3ui64, 0i64);
  v12 = !v5 || v5 == v9;
  v13 = GetDlgItem(*(HWND *)(a1 + 8), 1061);
  if ( v12 )
    SendMessageW(v13, 0xF4u, 3ui64, 0i64);
  v14 = !v6 || v6 == v9;
  v15 = GetDlgItem(*(HWND *)(a1 + 8), 1059);
  if ( v14 )
    SendMessageW(v15, 0xF4u, 3ui64, 0i64);
  v16 = !v7 || v7 == v9;
  v17 = GetDlgItem(*(HWND *)(a1 + 8), 1062);
  if ( v16 )
    SendMessageW(v17, 0xF4u, 3ui64, 0i64);
  if ( v8 && v8 != v9 )
    v36 = 0;
  v18 = GetDlgItem(*(HWND *)(a1 + 8), 1063);
  if ( v36 )
    SendMessageW(v18, 0xF4u, 3ui64, 0i64);
  v19 = GetDlgItem(*(HWND *)(a1 + 8), 1060);
  v20 = 0;
  if ( v4 )
  {
    LOBYTE(v20) = v4 != v9;
    ++v20;
  }
  SendMessageW(v19, 0xF1u, v20, 0i64);
  v21 = GetDlgItem(*(HWND *)(a1 + 8), 1061);
  v22 = 0;
  if ( v5 )
  {
    LOBYTE(v22) = v5 != v9;
    ++v22;
  }
  SendMessageW(v21, 0xF1u, v22, 0i64);
  v23 = GetDlgItem(*(HWND *)(a1 + 8), 1059);
  v24 = 0;
  if ( v6 )
  {
    LOBYTE(v24) = v6 != v9;
    ++v24;
  }
  SendMessageW(v23, 0xF1u, v24, 0i64);
  v25 = GetDlgItem(*(HWND *)(a1 + 8), 1062);
  v26 = 0;
  if ( v7 )
  {
    LOBYTE(v26) = v7 != v9;
    ++v26;
  }
  SendMessageW(v25, 0xF1u, v26, 0i64);
  v27 = GetDlgItem(*(HWND *)(a1 + 8), 1063);
  v28 = 0;
  if ( v8 )
  {
    LOBYTE(v28) = v8 != v9;
    ++v28;
  }
  SendMessageW(v27, 0xF1u, v28, 0i64);
  v29 = *(_DWORD **)(a1 + 128);
  *(_DWORD *)(a1 + 192) = 0;
  v30 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 184) = 0i64;
  if ( v29[2] )
  {
    SetWindowPos(v30, 0i64, v29[3], v29[4], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(v30);
    sub_140081E00(Parent, v30);
  }
  return 0i64;
}
// 14009B660: using guessed type char var_498[520];

//----- (000000014009B9D0) ----------------------------------------------------
__int64 *sub_14009B9D0()
{
  if ( (dword_140130588 & 1) == 0 )
  {
    dword_140130588 |= 1u;
    sub_14009AB90();
    atexit(sub_1400E2090);
  }
  return &qword_14012ED90;
}
// 14012ED90: using guessed type __int64 qword_14012ED90;
// 140130588: using guessed type int dword_140130588;

//----- (000000014009BA10) ----------------------------------------------------
__int64 __fastcall sub_14009BA10(__int64 a1, __int64 a2, __int64 **a3)
{
  _QWORD *v5; // rax
  __int64 *v6; // rcx
  __int64 *v7; // rbx
  __int64 pExceptionObject[6]; // [rsp+28h] [rbp-30h] BYREF
  char *v10; // [rsp+68h] [rbp+10h] BYREF
  __int64 **v11; // [rsp+70h] [rbp+18h]

  v11 = a3;
  *(_QWORD *)(a1 + 16) = hInstance;
  *(_DWORD *)(a1 + 24) = 167;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 52) = 0;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CSetFileAttributesDialog::`vftable';
  sub_14000B490((_QWORD *)(a1 + 80));
  *(_QWORD *)(a1 + 112) = 0i64;
  v5 = operator new(0x20ui64);
  if ( !v5 )
  {
    v10 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v10);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 104) = v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8i64) = *(_QWORD *)(a1 + 104);
  sub_14001A170((__int64 **)(a1 + 80), a3);
  if ( (dword_140130588 & 1) == 0 )
  {
    dword_140130588 |= 1u;
    sub_14009AB90();
    atexit(sub_1400E2090);
  }
  *(_QWORD *)(a1 + 128) = &qword_14012ED90;
  v6 = (__int64 *)**a3;
  **a3 = (__int64)*a3;
  (*a3)[1] = (__int64)*a3;
  a3[1] = 0i64;
  if ( v6 != *a3 )
  {
    do
    {
      v7 = (__int64 *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *a3 );
  }
  j_free(*a3);
  return a1;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F7788: using guessed type void *CSetFileAttributesDialog::`vftable';
// 14012ED90: using guessed type __int64 qword_14012ED90;
// 140130588: using guessed type int dword_140130588;

//----- (000000014009BB50) ----------------------------------------------------
int __fastcall sub_14009BB50(__int64 a1, const WCHAR *a2, __int64 a3)
{
  int result; // eax

  result = lstrcmpiW(a2, L"Folder");
  if ( !result )
  {
    result = sub_14004B61C(a3);
    *(_DWORD *)(a1 + 544) = result;
  }
  return result;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (000000014009BBA0) ----------------------------------------------------
LSTATUS __fastcall sub_14009BBA0(__int64 a1, HKEY a2)
{
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF

  cbData = 4;
  return RegQueryValueExW(a2, L"Folder", 0i64, 0i64, (LPBYTE)(a1 + 544), &cbData);
}

//----- (000000014009BBF0) ----------------------------------------------------
LSTATUS __fastcall sub_14009BBF0(__int64 a1, HKEY a2)
{
  int Data; // [rsp+40h] [rbp+8h] BYREF

  Data = *(_DWORD *)(a1 + 544);
  return RegSetValueExW(a2, L"Folder", 0, 4u, (const BYTE *)&Data, 4u);
}

//----- (000000014009BC60) ----------------------------------------------------
HWND __fastcall sub_14009BC60(__int64 a1, char a2)
{
  HWND DlgItem; // rbx
  HWND result; // rax
  int v5; // er8

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( (_DWORD)result != -1 )
  {
    v5 = (_DWORD)result - 1;
    if ( !a2 )
      v5 = (_DWORD)result + 1;
    sub_140080F00(DlgItem, (int)result, v5);
    return SetFocus(DlgItem);
  }
  return result;
}

//----- (000000014009BCD0) ----------------------------------------------------
void __fastcall sub_14009BCD0(__int64 a1, __int64 a2)
{
  HWND DlgItem; // rax
  UINT v5; // eax
  _DWORD lParam[20]; // [rsp+20h] [rbp-168h] BYREF
  WCHAR Buffer[128]; // [rsp+70h] [rbp-118h] BYREF

  if ( (*(_BYTE *)(a2 + 32) & 2) != 0 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
    lParam[1] = *(_DWORD *)(a2 + 24);
    lParam[0] = 4;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 80) + 56i64))(*(_QWORD *)(a1 + 80), lParam[10]);
    LoadStringW(*(HINSTANCE *)(a1 + 16), v5, Buffer, 128);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1001, Buffer);
  }
}

//----- (000000014009BE30) ----------------------------------------------------
__int64 __fastcall sub_14009BE30(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 240));
  return 0i64;
}

//----- (000000014009BE50) ----------------------------------------------------
__int64 __fastcall sub_14009BE50(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (000000014009BE70) ----------------------------------------------------
__int64 __fastcall sub_14009BE70(__int64 a1, __int64 a2)
{
  if ( *(_DWORD *)(a2 + 16) == -100 )
    sub_14009BCD0(a1, a2);
  return 0i64;
}

//----- (000000014009BE90) ----------------------------------------------------
HRESULT __fastcall sub_14009BE90(__int64 a1, __int64 *a2, __int64 a3)
{
  itow_s(*(_DWORD *)(a1 + 544), Buffer, 0x40ui64, 10);
  return sub_14007BEA0(a2, a3, L"Folder", Buffer);
}
// 1400EFF58: using guessed type wchar_t aFolder_2[7];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (000000014009BEF0) ----------------------------------------------------
__int64 *sub_14009BEF0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012EFCC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"SetDefaultColumns" - (char *)&unk_14012EFCC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  qword_14012EFB0 = (__int64)&CSetDefaultColumnsDialogPersistentSettings::`vftable';
  result = &qword_14012EFB0;
  byte_14012F1CC = 1;
  dword_14012EFB8 = 0;
  dword_14012F1D0 = 0;
  return result;
}
// 14009BF37: conditional instruction was optimized away because rdx.8!=0
// 1400EFF10: using guessed type wchar_t aSetdefaultcolu_0[18];
// 1400F7758: using guessed type void *CSetDefaultColumnsDialogPersistentSettings::`vftable';
// 14012EFB0: using guessed type __int64 qword_14012EFB0;
// 14012EFB8: using guessed type int dword_14012EFB8;
// 14012F1CC: using guessed type char byte_14012F1CC;
// 14012F1D0: using guessed type int dword_14012F1D0;

//----- (000000014009BF80) ----------------------------------------------------
LRESULT __fastcall sub_14009BF80(__int64 a1, int a2)
{
  __int64 ***v3; // rbx
  HWND DlgItem; // r14
  __int64 **v5; // rbx
  int v6; // er15
  __int64 *i; // rdi
  __int64 v8; // rcx
  __int64 v9; // rbp
  int v10; // er12
  HINSTANCE v11; // rsi
  UINT v12; // eax
  _DWORD lParam[6]; // [rsp+20h] [rbp-168h] BYREF
  WCHAR *v15; // [rsp+38h] [rbp-150h]
  __int64 v16; // [rsp+48h] [rbp-140h]
  LPARAM v17; // [rsp+70h] [rbp-118h] BYREF
  int v18; // [rsp+7Ch] [rbp-10Ch]
  int v19; // [rsp+80h] [rbp-108h]
  int v20; // [rsp+C8h] [rbp-C0h]
  WCHAR Buffer[64]; // [rsp+D0h] [rbp-B8h] BYREF

  switch ( a2 )
  {
    case 0:
      v3 = *(__int64 ****)(a1 + 88);
      break;
    case 1:
      v3 = *(__int64 ****)(a1 + 96);
      break;
    case 2:
      v3 = *(__int64 ****)(a1 + 104);
      break;
    case 3:
      v3 = *(__int64 ****)(a1 + 128);
      break;
    case 4:
      v3 = *(__int64 ****)(a1 + 136);
      break;
    case 5:
      v3 = *(__int64 ****)(a1 + 120);
      break;
    case 6:
      v3 = *(__int64 ****)(a1 + 112);
      break;
    default:
      v3 = 0i64;
      break;
  }
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
  SendMessageW(DlgItem, 0x1009u, 0i64, 0i64);
  v5 = *v3;
  v6 = 0;
  for ( i = *v5; i != (__int64 *)v5; ++v6 )
  {
    v8 = *(_QWORD *)(a1 + 80);
    v9 = *((unsigned int *)i + 4);
    v10 = *((_DWORD *)i + 5);
    v11 = *(HINSTANCE *)(a1 + 16);
    v20 = *((_DWORD *)i + 6);
    v12 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v8 + 48i64))(v8, (unsigned int)v9);
    LoadStringW(v11, v12, Buffer, 64);
    v15 = Buffer;
    lParam[0] = 5;
    lParam[1] = v6;
    lParam[2] = 0;
    v16 = v9;
    SendMessageW(DlgItem, 0x104Du, 0i64, (LPARAM)lParam);
    v19 = 61440;
    v18 = ((v10 != 0) + 1) << 12;
    SendMessageW(DlgItem, 0x102Bu, v6, (LPARAM)&v17);
    i = (__int64 *)*i;
  }
  v19 = 2;
  v18 = 2;
  return SendMessageW(DlgItem, 0x102Bu, 0i64, (LPARAM)&v17);
}

//----- (000000014009C180) ----------------------------------------------------
__int64 __fastcall sub_14009C180(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  __int64 result; // rax
  int v7; // [rsp+30h] [rbp-28h] BYREF
  struct tagRECT Rect; // [rsp+38h] [rbp-20h] BYREF

  v1 = *(_QWORD *)(a1 + 248);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  v7 = SendDlgItemMessageW(*(HWND *)(a1 + 8), 1186, 0x147u, 0i64, 0i64);
  sub_140019CD0((_QWORD *)(a1 + 144), (__int64 **)&Rect, &v7);
  *(_DWORD *)(*(_QWORD *)(a1 + 248) + 544i64) = *(_DWORD *)(*(_QWORD *)&Rect.left + 20i64);
  result = *(_QWORD *)(a1 + 248);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (000000014009C260) ----------------------------------------------------
char **__fastcall sub_14009C260(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rsi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rsi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rsi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rdx
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  char *v25; // r11
  __int64 v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rdx
  char *v29; // r11
  __int64 v30; // rax
  __int64 v31; // rsi
  char *v32; // r11
  __int64 v33; // rax
  __int64 v34; // rsi
  char *v35; // r11
  __int64 v36; // rax
  __int64 v37; // rsi
  char *v38; // r11
  __int64 v39; // rax
  char **result; // rax
  _BYTE v41[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v41 = 1085;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_QWORD *)&v41[4] = 1i64;
  v6 = sub_140017AD0(v4, v5, v41);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1053i64;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v41[8] = 1;
  v9 = sub_140017AD0(v8, *(_QWORD *)(v8 + 8), v41);
  v10 = a3[1];
  if ( v10 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1054i64;
  a3[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a3;
  *(_DWORD *)&v41[8] = 1;
  v12 = sub_140017AD0(v11, *(_QWORD *)(v11 + 8), v41);
  v13 = a3[1];
  if ( v13 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1174i64;
  a3[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v15 = sub_140017AD0(v14, *(_QWORD *)(v14 + 8), v41);
  v16 = a3[1];
  if ( v16 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1001i64;
  a3[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v18 = sub_140017AD0(v17, *(_QWORD *)(v17 + 8), v41);
  v19 = a3[1];
  if ( v19 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v41 = 1001;
  a3[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *a3;
  *(_DWORD *)&v41[4] = 1;
  v21 = *(_QWORD *)(v20 + 8);
  *(_DWORD *)&v41[8] = 1;
  v22 = sub_140017AD0(v20, v21, v41);
  v23 = a3[1];
  if ( v23 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1254i64;
  a3[1] = v23 + 1;
  *(_QWORD *)(v20 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v25 = sub_140017AD0(v24, *(_QWORD *)(v24 + 8), v41);
  v26 = a3[1];
  if ( v26 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v41 = 1254;
  a3[1] = v26 + 1;
  *(_QWORD *)(v24 + 8) = v25;
  **((_QWORD **)v25 + 1) = v25;
  v27 = *a3;
  *(_DWORD *)&v41[4] = 1;
  v28 = *(_QWORD *)(v27 + 8);
  *(_DWORD *)&v41[8] = 1;
  v29 = sub_140017AD0(v27, v28, v41);
  v30 = a3[1];
  if ( v30 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1i64;
  a3[1] = v30 + 1;
  *(_QWORD *)(v27 + 8) = v29;
  **((_QWORD **)v29 + 1) = v29;
  v31 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v32 = sub_140017AD0(v31, *(_QWORD *)(v31 + 8), v41);
  v33 = a3[1];
  if ( v33 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 2i64;
  a3[1] = v33 + 1;
  *(_QWORD *)(v31 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  v34 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v35 = sub_140017AD0(v34, *(_QWORD *)(v34 + 8), v41);
  v36 = a3[1];
  if ( v36 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1304i64;
  a3[1] = v36 + 1;
  *(_QWORD *)(v34 + 8) = v35;
  **((_QWORD **)v35 + 1) = v35;
  v37 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v38 = sub_140017AD0(v37, *(_QWORD *)(v37 + 8), v41);
  v39 = a3[1];
  if ( 0x1555555555555554i64 == v39 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v39 + 1;
  *(_QWORD *)(v37 + 8) = v38;
  result = (char **)*((_QWORD *)v38 + 1);
  *result = v38;
  return result;
}

//----- (000000014009C650) ----------------------------------------------------
void __fastcall sub_14009C650(_QWORD *a1)
{
  _QWORD *v2; // rcx

  v2 = a1 + 18;
  *(v2 - 18) = &CSetDefaultColumnsDialog::`vftable';
  sub_14001A540((__int64)v2);
  sub_140084540(a1);
}
// 1400F76E8: using guessed type void *CSetDefaultColumnsDialog::`vftable';

//----- (000000014009C690) ----------------------------------------------------
__int64 *sub_14009C690()
{
  if ( (dword_14013058C & 1) == 0 )
  {
    dword_14013058C |= 1u;
    sub_14009BEF0();
    atexit(sub_1400E2080);
  }
  return &qword_14012EFB0;
}
// 14012EFB0: using guessed type __int64 qword_14012EFB0;
// 14013058C: using guessed type int dword_14013058C;

//----- (000000014009C6D0) ----------------------------------------------------
__int64 __fastcall sub_14009C6D0(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HICON IconW; // rax
  HWND v4; // rcx
  HWND DlgItem; // r12
  __int64 *v6; // rax
  __int64 v7; // r13
  char *v8; // r11
  __int64 v9; // rax
  __int64 *v10; // rax
  __int64 v11; // r13
  char *v12; // r11
  __int64 v13; // rax
  __int64 *v14; // rax
  __int64 v15; // r13
  char *v16; // r11
  __int64 v17; // rax
  __int64 *v18; // rax
  __int64 v19; // r13
  char *v20; // r11
  __int64 v21; // rax
  __int64 *v22; // rax
  __int64 v23; // r13
  char *v24; // r11
  __int64 v25; // rax
  __int64 *v26; // rax
  __int64 v27; // r13
  char *v28; // r11
  __int64 v29; // rax
  __int64 *v30; // rax
  __int64 v31; // r13
  char *v32; // r11
  __int64 v33; // rax
  __int64 **v34; // rcx
  __int64 *i; // rax
  HWND v36; // rcx
  HWND v37; // rbx
  _DWORD *v38; // rdx
  HWND v39; // rbx
  HWND Parent; // rax
  LPITEMIDLIST ppidl[2]; // [rsp+40h] [rbp-C0h] BYREF
  LPARAM v43; // [rsp+50h] [rbp-B0h] BYREF
  int v44; // [rsp+58h] [rbp-A8h]
  __int16 lParam[264]; // [rsp+80h] [rbp-80h] BYREF

  ModuleHandleW = GetModuleHandleW(0i64);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  v4 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 240) = IconW;
  SetClassLongPtrW(v4, -34, (LONG_PTR)IconW);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1186);
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 3, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x200000000i64);
  v6 = *(__int64 **)(a1 + 152);
  v7 = *v6;
  v8 = sub_14001A690(*v6, *(_QWORD *)(*v6 + 8), ppidl);
  v9 = *(_QWORD *)(a1 + 160);
  if ( v9 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v9 + 1;
  *(_QWORD *)(v7 + 8) = v8;
  **((_QWORD **)v8 + 1) = v8;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x2014u, (LPWSTR)lParam, 260);
  ppidl[0] = (LPITEMIDLIST)(unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam);
  v10 = *(__int64 **)(a1 + 152);
  v11 = *v10;
  v12 = sub_14001A690(*v10, *(_QWORD *)(*v10 + 8), ppidl);
  v13 = *(_QWORD *)(a1 + 160);
  if ( v13 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 17, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x100000000i64);
  v14 = *(__int64 **)(a1 + 152);
  v15 = *v14;
  v16 = sub_14001A690(*v14, *(_QWORD *)(*v14 + 8), ppidl);
  v17 = *(_QWORD *)(a1 + 160);
  if ( v17 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v17 + 1;
  *(_QWORD *)(v15 + 8) = v16;
  **((_QWORD **)v16 + 1) = v16;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 49, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x300000000i64);
  v18 = *(__int64 **)(a1 + 152);
  v19 = *v18;
  v20 = sub_14001A690(*v18, *(_QWORD *)(*v18 + 8), ppidl);
  v21 = *(_QWORD *)(a1 + 160);
  if ( v21 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v21 + 1;
  *(_QWORD *)(v19 + 8) = v20;
  **((_QWORD **)v20 + 1) = v20;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 18, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x400000000i64);
  v22 = *(__int64 **)(a1 + 152);
  v23 = *v22;
  v24 = sub_14001A690(*v22, *(_QWORD *)(*v22 + 8), ppidl);
  v25 = *(_QWORD *)(a1 + 160);
  if ( v25 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v25 + 1;
  *(_QWORD *)(v23 + 8) = v24;
  **((_QWORD **)v24 + 1) = v24;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 4, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x500000000i64);
  v26 = *(__int64 **)(a1 + 152);
  v27 = *v26;
  v28 = sub_14001A690(*v26, *(_QWORD *)(*v26 + 8), ppidl);
  v29 = *(_QWORD *)(a1 + 160);
  if ( v29 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v29 + 1;
  *(_QWORD *)(v27 + 8) = v28;
  **((_QWORD **)v28 + 1) = v28;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  ppidl[0] = 0i64;
  if ( !SHGetFolderLocation(0i64, 10, 0i64, 0, ppidl) )
  {
    sub_14007E270(ppidl[0], (LPWSTR)lParam, 1u);
    CoTaskMemFree(ppidl[0]);
  }
  ppidl[0] = (LPITEMIDLIST)((unsigned int)SendMessageW(DlgItem, 0x14Au, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)lParam) | 0x600000000i64);
  v30 = *(__int64 **)(a1 + 152);
  v31 = *v30;
  v32 = sub_14001A690(*v30, *(_QWORD *)(*v30 + 8), ppidl);
  v33 = *(_QWORD *)(a1 + 160);
  if ( 0x1FFFFFFFFFFFFFFEi64 == v33 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 160) = v33 + 1;
  *(_QWORD *)(v31 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  sub_140019DD0((_QWORD *)(a1 + 144), (__int64)ppidl, (int *)(**(_QWORD **)(a1 + 152) + 16i64), **(_QWORD **)(a1 + 152));
  v34 = *(__int64 ***)(a1 + 152);
  for ( i = *v34; i != (__int64 *)v34; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 5) == *(_DWORD *)(*(_QWORD *)(a1 + 248) + 544i64) )
      break;
  }
  SendMessageW(DlgItem, 0x14Eu, *((int *)i + 4), 0i64);
  v36 = *(HWND *)(a1 + 8);
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(*(_QWORD *)(a1 + 248) + 544i64);
  v37 = GetDlgItem(v36, 1085);
  SendMessageW(v37, 0x1036u, 4ui64, 4i64);
  LODWORD(v43) = 2;
  v44 = 180;
  SendMessageW(v37, 0x1061u, 0i64, (LPARAM)&v43);
  sub_14009BF80(a1, *(_DWORD *)(*(_QWORD *)(a1 + 248) + 544i64));
  SetFocus(v37);
  v38 = *(_DWORD **)(a1 + 248);
  v39 = *(HWND *)(a1 + 8);
  if ( v38[2] )
  {
    SetWindowPos(v39, 0i64, v38[3], v38[4], v38[5], v38[6], 4u);
  }
  else
  {
    Parent = GetParent(v39);
    sub_140081E00(Parent, v39);
  }
  return 0i64;
}
// 14009C6D0: using guessed type WCHAR lParam[264];

//----- (000000014009CE50) ----------------------------------------------------
__int64 __fastcall sub_14009CE50(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  *(_QWORD *)(a1 + 16) = hInstance;
  *(_DWORD *)(a1 + 24) = 187;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 52) = 1;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CSetDefaultColumnsDialog::`vftable';
  sub_14001A490(a1 + 144);
  *(_QWORD *)(a1 + 80) = a3;
  *(_QWORD *)(a1 + 88) = a4;
  *(_QWORD *)(a1 + 96) = a5;
  *(_QWORD *)(a1 + 104) = a6;
  *(_QWORD *)(a1 + 112) = a7;
  *(_QWORD *)(a1 + 120) = a8;
  *(_QWORD *)(a1 + 128) = a9;
  *(_QWORD *)(a1 + 136) = a10;
  if ( (dword_14013058C & 1) == 0 )
  {
    dword_14013058C |= 1u;
    sub_14009BEF0();
    atexit(sub_1400E2080);
  }
  *(_QWORD *)(a1 + 248) = &qword_14012EFB0;
  return a1;
}
// 14001A490: using guessed type __int64 __fastcall sub_14001A490(_QWORD);
// 1400F76E8: using guessed type void *CSetDefaultColumnsDialog::`vftable';
// 14012EFB0: using guessed type __int64 qword_14012EFB0;
// 14013058C: using guessed type int dword_14013058C;

//----- (000000014009CF50) ----------------------------------------------------
void __fastcall sub_14009CF50(__int64 a1, int a2)
{
  HWND DlgItem; // r12
  __int64 **v5; // rbp
  __int64 v6; // rdi
  _QWORD *v7; // rax
  _QWORD *v8; // rsi
  int i; // ebx
  __int64 j; // rax
  char *v11; // rax
  _QWORD *v12; // rbx
  __int64 *v13; // rcx
  __int64 *v14; // rdi
  _QWORD *v15; // rcx
  _QWORD *v16; // rbx
  int v17[4]; // [rsp+20h] [rbp-C8h] BYREF
  _QWORD *v18; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v19; // [rsp+38h] [rbp-B0h]
  __int64 pExceptionObject[5]; // [rsp+48h] [rbp-A0h] BYREF
  _DWORD lParam[10]; // [rsp+70h] [rbp-78h] BYREF
  int v22; // [rsp+98h] [rbp-50h]
  char *v23; // [rsp+F0h] [rbp+8h] BYREF

  pExceptionObject[3] = -2i64;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
  switch ( a2 )
  {
    case 0:
      v5 = *(__int64 ***)(a1 + 88);
      break;
    case 1:
      v5 = *(__int64 ***)(a1 + 96);
      break;
    case 2:
      v5 = *(__int64 ***)(a1 + 104);
      break;
    case 3:
      v5 = *(__int64 ***)(a1 + 128);
      break;
    case 4:
      v5 = *(__int64 ***)(a1 + 136);
      break;
    case 5:
      v5 = *(__int64 ***)(a1 + 120);
      break;
    case 6:
      v5 = *(__int64 ***)(a1 + 112);
      break;
    default:
      v5 = 0i64;
      break;
  }
  v6 = 0i64;
  v19 = 0i64;
  v7 = operator new(0x20ui64);
  v8 = v7;
  if ( !v7 )
  {
    v23 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v23);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v18 = v7;
  *v7 = v7;
  v7[1] = v7;
  for ( i = 0; i < (int)SendMessageW(DlgItem, 0x1004u, 0i64, 0i64); ++i )
  {
    lParam[0] = 4;
    lParam[1] = i;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    for ( j = **v5; (__int64 *)j != *v5; j = *(_QWORD *)j )
    {
      if ( *(_DWORD *)(j + 16) == v22 )
        break;
    }
    v17[0] = v22;
    v17[2] = *(_DWORD *)(j + 24);
    v17[1] = ((unsigned int)SendMessageW(DlgItem, 0x102Cu, i, 61440i64) >> 12) - 1;
    v11 = sub_140017AD0((__int64)v8, v8[1], v17);
    if ( v6 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    v19 = ++v6;
    v8[1] = v11;
    **((_QWORD **)v11 + 1) = v11;
  }
  if ( v5 != &v18 )
  {
    v12 = (_QWORD *)*v8;
    v13 = (__int64 *)**v5;
    **v5 = (__int64)*v5;
    (*v5)[1] = (__int64)*v5;
    v5[1] = 0i64;
    if ( v13 != *v5 )
    {
      do
      {
        v14 = (__int64 *)*v13;
        j_free(v13);
        v13 = v14;
      }
      while ( v14 != *v5 );
    }
    sub_14000BDC0((__int64)v5, **v5, v12, v8);
  }
  v15 = (_QWORD *)*v8;
  *v8 = v8;
  v8[1] = v8;
  if ( v15 != v8 )
  {
    do
    {
      v16 = (_QWORD *)*v15;
      j_free(v15);
      v15 = v16;
    }
    while ( v16 != v8 );
  }
  j_free(v8);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014009D200) ----------------------------------------------------
LRESULT __fastcall sub_14009D200(__int64 a1)
{
  HWND DlgItem; // rax
  __int64 *v3; // rbx
  LRESULT result; // rax
  int v5; // [rsp+30h] [rbp+8h] BYREF
  __int64 *v6; // [rsp+38h] [rbp+10h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1186);
  v5 = SendMessageW(DlgItem, 0x147u, 0i64, 0i64);
  sub_140019CD0((_QWORD *)(a1 + 144), &v6, &v5);
  sub_14009CF50(a1, *(_DWORD *)(a1 + 232));
  v3 = v6;
  result = sub_14009BF80(a1, *((_DWORD *)v6 + 5));
  *(_DWORD *)(a1 + 232) = *((_DWORD *)v3 + 5);
  return result;
}

//----- (000000014009D290) ----------------------------------------------------
BOOL __fastcall sub_14009D290(__int64 a1)
{
  HWND DlgItem; // rax
  int v4; // [rsp+30h] [rbp+8h] BYREF
  __int64 *v5; // [rsp+38h] [rbp+10h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1186);
  v4 = SendMessageW(DlgItem, 0x147u, 0i64, 0i64);
  sub_140019CD0((_QWORD *)(a1 + 144), &v5, &v4);
  sub_14009CF50(a1, *((_DWORD *)v5 + 5));
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (000000014009D310) ----------------------------------------------------
__int64 __fastcall sub_14009D310(__int64 a1, int a2)
{
  __int16 v2; // di
  HWND DlgItem; // rbx
  int v5; // eax
  int v6; // er8

  v2 = a2;
  if ( HIWORD(a2) == 1 )
    sub_14009D200(a1);
  switch ( v2 )
  {
    case 1:
      sub_14009D290(a1);
      break;
    case 2:
      EndDialog(*(HWND *)(a1 + 8), 0i64);
      return 0i64;
    case 1053:
      DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
      v5 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
      if ( v5 != -1 )
      {
        v6 = v5 - 1;
        goto LABEL_9;
      }
      break;
    case 1054:
      DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
      v5 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
      if ( v5 != -1 )
      {
        v6 = v5 + 1;
LABEL_9:
        sub_140080F00(DlgItem, v5, v6);
        SetFocus(DlgItem);
        return 0i64;
      }
      break;
  }
  return 0i64;
}

//----- (000000014009D430) ----------------------------------------------------
HWND __fastcall sub_14009D430(__int64 a1, char a2)
{
  HWND DlgItem; // rbx
  HWND result; // rax
  int v6; // er8

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( (_DWORD)result != -1 )
  {
    v6 = (_DWORD)result - 1;
    if ( !a2 )
      v6 = (_DWORD)result + 1;
    sub_140080F00(DlgItem, (int)result, v6);
    *(_DWORD *)(a1 + 88) = 1;
    return SetFocus(DlgItem);
  }
  return result;
}

//----- (000000014009D4C0) ----------------------------------------------------
void __fastcall sub_14009D4C0(__int64 a1, __int64 a2)
{
  HWND DlgItem; // rax
  UINT v5; // eax
  _DWORD lParam[20]; // [rsp+20h] [rbp-168h] BYREF
  WCHAR Buffer[128]; // [rsp+70h] [rbp-118h] BYREF

  if ( (*(_BYTE *)(a2 + 32) & 2) != 0 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
    lParam[1] = *(_DWORD *)(a2 + 24);
    lParam[0] = 4;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 80) + 56i64))(*(_QWORD *)(a1 + 80), lParam[10]);
    LoadStringW(*(HINSTANCE *)(a1 + 16), v5, Buffer, 128);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1001, Buffer);
  }
}

//----- (000000014009D5B0) ----------------------------------------------------
__int64 __fastcall sub_14009D5B0(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 96));
  return 0i64;
}

//----- (000000014009D5D0) ----------------------------------------------------
__int64 __fastcall sub_14009D5D0(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (000000014009D5F0) ----------------------------------------------------
__int64 __fastcall sub_14009D5F0(__int64 a1, __int64 a2)
{
  if ( *(_DWORD *)(a2 + 16) == -100 )
    sub_14009D4C0(a1, a2);
  return 0i64;
}

//----- (000000014009D610) ----------------------------------------------------
__int64 __fastcall sub_14009D610(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 104);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 104);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (000000014009D6B0) ----------------------------------------------------
__int64 *sub_14009D6B0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012F1FC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"SelectColumns" - (char *)&unk_14012F1FC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012F1E8 = 0;
  qword_14012F1E0 = (__int64)&CSelectColumnsDialogPersistentSettings::`vftable';
  result = &qword_14012F1E0;
  byte_14012F3FC = 1;
  return result;
}
// 14009D6F7: conditional instruction was optimized away because rdx.8!=0
// 1400EFF78: using guessed type wchar_t aSelectcolumns_0[14];
// 1400F76B8: using guessed type void *CSelectColumnsDialogPersistentSettings::`vftable';
// 14012F1E0: using guessed type __int64 qword_14012F1E0;
// 14012F1E8: using guessed type int dword_14012F1E8;
// 14012F3FC: using guessed type char byte_14012F3FC;

//----- (000000014009D730) ----------------------------------------------------
char **__fastcall sub_14009D730(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rsi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rsi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rsi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rdx
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  char *v25; // r11
  __int64 v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rdx
  char *v29; // r11
  __int64 v30; // rax
  __int64 v31; // rsi
  char *v32; // r11
  __int64 v33; // rax
  __int64 v34; // rsi
  char *v35; // r11
  __int64 v36; // rax
  __int64 v37; // rsi
  char *v38; // r11
  __int64 v39; // rax
  char **result; // rax
  _BYTE v41[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v41 = 1085;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_QWORD *)&v41[4] = 1i64;
  v6 = sub_140017AD0(v4, v5, v41);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1053i64;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v41[8] = 1;
  v9 = sub_140017AD0(v8, *(_QWORD *)(v8 + 8), v41);
  v10 = a3[1];
  if ( v10 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1054i64;
  a3[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a3;
  *(_DWORD *)&v41[8] = 1;
  v12 = sub_140017AD0(v11, *(_QWORD *)(v11 + 8), v41);
  v13 = a3[1];
  if ( v13 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1174i64;
  a3[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v15 = sub_140017AD0(v14, *(_QWORD *)(v14 + 8), v41);
  v16 = a3[1];
  if ( v16 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1001i64;
  a3[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v18 = sub_140017AD0(v17, *(_QWORD *)(v17 + 8), v41);
  v19 = a3[1];
  if ( v19 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v41 = 1001;
  a3[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *a3;
  *(_DWORD *)&v41[4] = 1;
  v21 = *(_QWORD *)(v20 + 8);
  *(_DWORD *)&v41[8] = 1;
  v22 = sub_140017AD0(v20, v21, v41);
  v23 = a3[1];
  if ( v23 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1254i64;
  a3[1] = v23 + 1;
  *(_QWORD *)(v20 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *a3;
  *(_DWORD *)&v41[8] = 2;
  v25 = sub_140017AD0(v24, *(_QWORD *)(v24 + 8), v41);
  v26 = a3[1];
  if ( v26 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v41 = 1254;
  a3[1] = v26 + 1;
  *(_QWORD *)(v24 + 8) = v25;
  **((_QWORD **)v25 + 1) = v25;
  v27 = *a3;
  *(_DWORD *)&v41[4] = 1;
  v28 = *(_QWORD *)(v27 + 8);
  *(_DWORD *)&v41[8] = 1;
  v29 = sub_140017AD0(v27, v28, v41);
  v30 = a3[1];
  if ( v30 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1i64;
  a3[1] = v30 + 1;
  *(_QWORD *)(v27 + 8) = v29;
  **((_QWORD **)v29 + 1) = v29;
  v31 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v32 = sub_140017AD0(v31, *(_QWORD *)(v31 + 8), v41);
  v33 = a3[1];
  if ( v33 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 2i64;
  a3[1] = v33 + 1;
  *(_QWORD *)(v31 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  v34 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v35 = sub_140017AD0(v34, *(_QWORD *)(v34 + 8), v41);
  v36 = a3[1];
  if ( v36 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v41 = 1304i64;
  a3[1] = v36 + 1;
  *(_QWORD *)(v34 + 8) = v35;
  **((_QWORD **)v35 + 1) = v35;
  v37 = *a3;
  *(_DWORD *)&v41[8] = 0;
  v38 = sub_140017AD0(v37, *(_QWORD *)(v37 + 8), v41);
  v39 = a3[1];
  if ( 0x1555555555555554i64 == v39 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v39 + 1;
  *(_QWORD *)(v37 + 8) = v38;
  result = (char **)*((_QWORD *)v38 + 1);
  *result = v38;
  return result;
}

//----- (000000014009DE30) ----------------------------------------------------
__int64 *sub_14009DE30()
{
  if ( (dword_140130590 & 1) == 0 )
  {
    dword_140130590 |= 1u;
    sub_14009D6B0();
    atexit(sub_1400E2070);
  }
  return &qword_14012F1E0;
}
// 14012F1E0: using guessed type __int64 qword_14012F1E0;
// 140130590: using guessed type int dword_140130590;

//----- (000000014009DE70) ----------------------------------------------------
__int64 __fastcall sub_14009DE70(__int64 a1, __int64 a2, __int64 a3)
{
  HINSTANCE v3; // rax
  int v5; // eax

  v3 = hInstance;
  *(_DWORD *)(a1 + 24) = 174;
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)a1 = &CSelectColumnsDialog::`vftable';
  v5 = dword_140130590;
  *(_BYTE *)(a1 + 52) = 1;
  *(_QWORD *)(a1 + 80) = a3;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  if ( (v5 & 1) == 0 )
  {
    dword_140130590 = v5 | 1;
    sub_14009D6B0();
    atexit(sub_1400E2070);
  }
  *(_QWORD *)(a1 + 104) = &qword_14012F1E0;
  return a1;
}
// 1400F7648: using guessed type void *CSelectColumnsDialog::`vftable';
// 14012F1E0: using guessed type __int64 qword_14012F1E0;
// 140130590: using guessed type int dword_140130590;

//----- (000000014009DEF0) ----------------------------------------------------
void __fastcall sub_14009DEF0(__int64 a1)
{
  HWND DlgItem; // rsi
  _QWORD *v3; // rax
  _QWORD *v4; // rax
  __int64 v5; // rax
  int i; // ebx
  void **j; // rax
  char *v8; // rax
  __int64 v9; // rax
  __int64 *v10; // rax
  __int64 v11; // rbx
  unsigned int v12; // eax
  void **v13; // rcx
  void *v14; // rax
  void **v15; // rbx
  void **v16; // rcx
  void *v17; // rax
  void **v18; // rbx
  void *v19; // [rsp+28h] [rbp-89h] BYREF
  __int64 v20; // [rsp+30h] [rbp-81h]
  void *Block; // [rsp+40h] [rbp-71h] BYREF
  __int64 v22; // [rsp+48h] [rbp-69h]
  void **v23; // [rsp+58h] [rbp-59h] BYREF
  int v24; // [rsp+60h] [rbp-51h]
  __int64 pExceptionObject[5]; // [rsp+70h] [rbp-41h] BYREF
  _DWORD lParam[10]; // [rsp+98h] [rbp-19h] BYREF
  int v27; // [rsp+C0h] [rbp+Fh]
  char *v28; // [rsp+118h] [rbp+67h] BYREF
  char *v29; // [rsp+120h] [rbp+6Fh] BYREF

  pExceptionObject[3] = -2i64;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
  v20 = 0i64;
  v3 = operator new(0x20ui64);
  if ( !v3 )
  {
    v29 = 0i64;
    std::exception::exception((std::exception *)&v23, (const char *const *)&v29);
    v23 = &std::bad_alloc::`vftable';
    CxxThrowException(&v23, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v19 = v3;
  *v3 = v3;
  *((_QWORD *)v19 + 1) = v19;
  v22 = 0i64;
  v4 = operator new(0x20ui64);
  if ( !v4 )
  {
    v28 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v28);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v4;
  *v4 = v4;
  *((_QWORD *)Block + 1) = Block;
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  (*(void (__fastcall **)(__int64, void **))(*(_QWORD *)v5 + 624i64))(v5, &Block);
  for ( i = 0; i < (int)SendMessageW(DlgItem, 0x1004u, 0i64, 0i64); ++i )
  {
    lParam[0] = 4;
    lParam[1] = i;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    for ( j = *(void ***)Block; j != Block; j = (void **)*j )
    {
      if ( *((_DWORD *)j + 4) == v27 )
        break;
    }
    LODWORD(v23) = v27;
    v24 = *((_DWORD *)j + 6);
    HIDWORD(v23) = ((unsigned int)SendMessageW(DlgItem, 0x102Cu, i, 61440i64) >> 12) - 1;
    v8 = sub_140017AD0((__int64)v19, *((_QWORD *)v19 + 1), &v23);
    if ( v20 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v20;
    *((_QWORD *)v19 + 1) = v8;
    **((_QWORD **)v8 + 1) = v8;
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  (*(void (__fastcall **)(__int64, void **, _QWORD))(*(_QWORD *)v9 + 632i64))(v9, &v19, *(unsigned int *)(a1 + 88));
  if ( *(_DWORD *)(a1 + 88) )
  {
    v10 = *(__int64 **)(a1 + 80);
    v11 = *v10;
    v12 = (*(__int64 (__fastcall **)(__int64 *))(*v10 + 40))(v10);
    (*(void (__fastcall **)(_QWORD, _QWORD))(v11 + 32))(*(_QWORD *)(a1 + 80), v12);
  }
  EndDialog(*(HWND *)(a1 + 8), 1i64);
  v13 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  *((_QWORD *)Block + 1) = Block;
  v22 = 0i64;
  v14 = Block;
  if ( v13 != Block )
  {
    do
    {
      v15 = (void **)*v13;
      j_free(v13);
      v13 = v15;
      v14 = Block;
    }
    while ( v15 != Block );
  }
  j_free(v14);
  v16 = *(void ***)v19;
  *(_QWORD *)v19 = v19;
  *((_QWORD *)v19 + 1) = v19;
  v20 = 0i64;
  v17 = v19;
  if ( v16 != v19 )
  {
    do
    {
      v18 = (void **)*v16;
      j_free(v16);
      v16 = v18;
      v17 = v19;
    }
    while ( v18 != v19 );
  }
  j_free(v17);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014009E1E0) ----------------------------------------------------
__int64 __fastcall sub_14009E1E0(__int64 a1, __int16 a2)
{
  HWND DlgItem; // rdi
  int v4; // eax
  int v5; // er8

  if ( a2 == 1 )
  {
    sub_14009DEF0(a1);
    return 0i64;
  }
  else
  {
    if ( a2 != 2 )
    {
      if ( a2 == 1053 )
      {
        DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
        v4 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
        if ( v4 == -1 )
          return 0i64;
        v5 = v4 - 1;
      }
      else
      {
        if ( a2 != 1054 )
          return 0i64;
        DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1085);
        v4 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
        if ( v4 == -1 )
          return 0i64;
        v5 = v4 + 1;
      }
      sub_140080F00(DlgItem, v4, v5);
      *(_DWORD *)(a1 + 88) = 1;
      SetFocus(DlgItem);
      return 0i64;
    }
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
}

//----- (000000014009E2D0) ----------------------------------------------------
void __fastcall sub_14009E2D0(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
  *(_DWORD *)(a1 + 1160) = 1;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
}

//----- (000000014009E320) ----------------------------------------------------
__int64 __fastcall sub_14009E320(__int64 a1)
{
  DestroyWindow(*(HWND *)(a1 + 8));
  return 0i64;
}

//----- (000000014009E340) ----------------------------------------------------
__int64 __fastcall sub_14009E340(HWND a1, int a2, __int64 a3, LPARAM a4)
{
  if ( a2 == 1 )
    SendMessageW(a1, 0x467u, 1ui64, a4);
  return 0i64;
}

//----- (000000014009E370) ----------------------------------------------------
UINT __fastcall sub_14009E370(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  HWND DlgItem; // rbx
  UINT result; // eax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 840);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1104i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1282) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1100i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1281) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1096i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1249) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1108i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1060) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1112i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1061) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1116i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1062) == 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1120i64) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1059) == 1;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1226);
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1168i64) = SendMessageW(DlgItem, 0x101Du, 0i64, 0i64);
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1172i64) = SendMessageW(DlgItem, 0x101Du, 1ui64, 0i64);
  result = GetDlgItemTextW(*(HWND *)(a1 + 8), 1225, (LPWSTR)(*(_QWORD *)(a1 + 840) + 544i64), 260);
  *(_DWORD *)(*(_QWORD *)(a1 + 840) + 8i64) = 1;
  return result;
}

//----- (000000014009E570) ----------------------------------------------------
LRESULT __fastcall sub_14009E570(__int64 a1)
{
  HWND DlgItem; // rax
  HWND v3; // rax
  HWND v4; // rbp
  WPARAM v5; // r8
  unsigned int v6; // er11
  __int64 v7; // rdx
  int v8; // ebx
  _DWORD *v9; // rcx
  _DWORD *i; // rax
  LRESULT result; // rax
  int lParam[7]; // [rsp+30h] [rbp-48h] BYREF
  unsigned int v13; // [rsp+4Ch] [rbp-2Ch]

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1226);
  v3 = (HWND)SendMessageW(DlgItem, 0x101Fu, 0i64, 0i64);
  v4 = v3;
  if ( *(_DWORD *)(a1 + 820) != -1 )
  {
    v5 = *(int *)(a1 + 820);
    lParam[0] = 4;
    SendMessageW(v3, 0x120Bu, v5, (LPARAM)lParam);
    if ( (v13 & 0x400) != 0 )
    {
      v6 = v13 & 0xFFFFFBFF;
    }
    else
    {
      if ( (v13 & 0x200) == 0 )
      {
LABEL_7:
        SendMessageW(v4, 0x120Cu, *(int *)(a1 + 820), (LPARAM)lParam);
        goto LABEL_8;
      }
      v6 = v13 & 0xFFFFFDFF;
    }
    v13 = v6;
    goto LABEL_7;
  }
LABEL_8:
  v7 = *(_QWORD *)(a1 + 840);
  v8 = 0;
  v9 = *(_DWORD **)(v7 + 1136);
  for ( i = *(_DWORD **)(v7 + 1128); i != v9; ++v8 )
  {
    if ( *i == *(_DWORD *)(v7 + 1160) )
      break;
    i += 3;
  }
  lParam[0] = 4;
  SendMessageW(v4, 0x120Bu, v8, (LPARAM)lParam);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1164i64) )
    v13 |= 0x400u;
  else
    v13 |= 0x200u;
  result = SendMessageW(v4, 0x120Cu, v8, (LPARAM)lParam);
  *(_DWORD *)(a1 + 820) = v8;
  return result;
}
// 14009E570: using guessed type _DWORD lParam[7];

//----- (000000014009E6E0) ----------------------------------------------------
int __fastcall sub_14009E6E0(__int64 a1, int a2, int a3)
{
  _QWORD *v3; // rbx
  __int64 *v5; // r11
  __int64 v6; // rdx
  WCHAR *v7; // rcx
  signed __int64 v8; // r11
  __int64 v9; // r8
  WCHAR v10; // ax
  __int64 *v11; // r8
  WCHAR *v12; // rcx
  signed __int64 v13; // r8
  WCHAR v14; // ax
  int v16; // [rsp+20h] [rbp-458h] BYREF
  __int64 *v17; // [rsp+28h] [rbp-450h] BYREF
  __int64 *v18; // [rsp+30h] [rbp-448h] BYREF
  WCHAR psz2[264]; // [rsp+40h] [rbp-438h] BYREF
  WCHAR pszPath[264]; // [rsp+250h] [rbp-228h] BYREF

  v3 = (_QWORD *)(a1 + 728);
  v16 = a2;
  sub_140019CD0((_QWORD *)(a1 + 728), &v18, &v16);
  v16 = a3;
  sub_140019CD0(v3, &v17, &v16);
  v5 = v18 + 3;
  if ( (unsigned __int64)v18[6] >= 8 )
    v5 = (__int64 *)*v5;
  v6 = 260i64;
  v7 = pszPath;
  v8 = (char *)v5 - (char *)pszPath;
  v9 = 260i64;
  while ( v9 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)v7 + v8);
    if ( !v10 )
      break;
    *v7++ = v10;
    if ( !--v9 )
    {
      --v7;
      break;
    }
  }
  v11 = v17 + 3;
  *v7 = 0;
  if ( (unsigned __int64)v11[3] >= 8 )
    v11 = (__int64 *)*v11;
  v12 = psz2;
  v13 = (char *)v11 - (char *)psz2;
  while ( v6 != -2147483386 )
  {
    v14 = *(WCHAR *)((char *)v12 + v13);
    if ( !v14 )
      break;
    *v12++ = v14;
    if ( !--v6 )
    {
      --v12;
      break;
    }
  }
  *v12 = 0;
  PathRemoveFileSpecW(pszPath);
  PathRemoveFileSpecW(psz2);
  return StrCmpLogicalW(pszPath, psz2);
}
// 14009E78A: conditional instruction was optimized away because r8.8!=0
// 14009E7E7: conditional instruction was optimized away because rdx.8!=0

//----- (000000014009E850) ----------------------------------------------------
int __fastcall sub_14009E850(__int64 a1, int a2, int a3)
{
  _QWORD *v3; // rbx
  __int64 *v5; // r11
  __int64 v6; // rdx
  WCHAR *v7; // rcx
  signed __int64 v8; // r11
  __int64 v9; // r8
  WCHAR v10; // ax
  __int64 *v11; // r8
  WCHAR *v12; // rcx
  signed __int64 v13; // r8
  WCHAR v14; // ax
  int v16; // [rsp+20h] [rbp-458h] BYREF
  __int64 *v17; // [rsp+28h] [rbp-450h] BYREF
  __int64 *v18; // [rsp+30h] [rbp-448h] BYREF
  WCHAR psz2[264]; // [rsp+40h] [rbp-438h] BYREF
  WCHAR pszPath[264]; // [rsp+250h] [rbp-228h] BYREF

  v3 = (_QWORD *)(a1 + 728);
  v16 = a2;
  sub_140019CD0((_QWORD *)(a1 + 728), &v18, &v16);
  v16 = a3;
  sub_140019CD0(v3, &v17, &v16);
  v5 = v18 + 3;
  if ( (unsigned __int64)v18[6] >= 8 )
    v5 = (__int64 *)*v5;
  v6 = 260i64;
  v7 = pszPath;
  v8 = (char *)v5 - (char *)pszPath;
  v9 = 260i64;
  while ( v9 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)v7 + v8);
    if ( !v10 )
      break;
    *v7++ = v10;
    if ( !--v9 )
    {
      --v7;
      break;
    }
  }
  v11 = v17 + 3;
  *v7 = 0;
  if ( (unsigned __int64)v11[3] >= 8 )
    v11 = (__int64 *)*v11;
  v12 = psz2;
  v13 = (char *)v11 - (char *)psz2;
  while ( v6 != -2147483386 )
  {
    v14 = *(WCHAR *)((char *)v12 + v13);
    if ( !v14 )
      break;
    *v12++ = v14;
    if ( !--v6 )
    {
      --v12;
      break;
    }
  }
  *v12 = 0;
  PathStripPathW(pszPath);
  PathStripPathW(psz2);
  return StrCmpLogicalW(pszPath, psz2);
}
// 14009E8FA: conditional instruction was optimized away because r8.8!=0
// 14009E957: conditional instruction was optimized away because rdx.8!=0

//----- (000000014009E9C0) ----------------------------------------------------
__int64 __fastcall sub_14009E9C0(__int64 a1, int a2, int a3)
{
  unsigned int v3; // er10
  int v5; // eax

  v3 = 0;
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1160i64) == 1 )
  {
    v5 = sub_14009E850(a1, a2, a3);
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1160i64) != 2 )
      goto LABEL_6;
    v5 = sub_14009E6E0(a1, a2, a3);
  }
  v3 = v5;
LABEL_6:
  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 840) + 1164i64) )
    return -v3;
  return v3;
}

//----- (000000014009EA20) ----------------------------------------------------
__int64 __fastcall sub_14009EA20(int a1, int a2, __int64 a3)
{
  unsigned int v3; // er10
  int v5; // eax

  v3 = 0;
  if ( *(_DWORD *)(*(_QWORD *)(a3 + 840) + 1160i64) == 1 )
  {
    v5 = sub_14009E850(a3, a1, a2);
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)(a3 + 840) + 1160i64) != 2 )
      goto LABEL_6;
    v5 = sub_14009E6E0(a3, a1, a2);
  }
  v3 = v5;
LABEL_6:
  if ( !*(_DWORD *)(*(_QWORD *)(a3 + 840) + 1164i64) )
    return -v3;
  return v3;
}

//----- (000000014009EA90) ----------------------------------------------------
char **__fastcall sub_14009EA90(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rsi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  char *v10; // r11
  __int64 v11; // rax
  __int64 v12; // rsi
  char *v13; // r11
  __int64 v14; // rax
  __int64 v15; // rsi
  char *v16; // r11
  __int64 v17; // rax
  __int64 v18; // rsi
  char *v19; // r11
  __int64 v20; // rax
  __int64 v21; // rsi
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  __int64 v25; // rdx
  char *v26; // r11
  __int64 v27; // rax
  __int64 v28; // rsi
  char *v29; // r11
  __int64 v30; // rax
  __int64 v31; // rsi
  __int64 v32; // rdx
  char *v33; // r11
  __int64 v34; // rax
  __int64 v35; // rsi
  char *v36; // r11
  __int64 v37; // rax
  __int64 v38; // rsi
  __int64 v39; // rdx
  char *v40; // r11
  __int64 v41; // rax
  __int64 v42; // rsi
  char *v43; // r11
  __int64 v44; // rax
  __int64 v45; // rsi
  char *v46; // r11
  __int64 v47; // rax
  __int64 v48; // rsi
  char *v49; // r11
  __int64 v50; // rax
  char **result; // rax
  _BYTE v52[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v52 = 1225;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_DWORD *)&v52[4] = 1;
  *(_DWORD *)&v52[8] = 1;
  v6 = sub_140017AD0(v4, v5, v52);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v52 = 1224;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v52[4] = 1;
  v9 = *(_QWORD *)(v8 + 8);
  *(_DWORD *)&v52[8] = 1;
  v10 = sub_140017AD0(v8, v9, v52);
  v11 = a3[1];
  if ( v11 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1229i64;
  a3[1] = v11 + 1;
  *(_QWORD *)(v8 + 8) = v10;
  **((_QWORD **)v10 + 1) = v10;
  v12 = *a3;
  *(_DWORD *)&v52[8] = 1;
  v13 = sub_140017AD0(v12, *(_QWORD *)(v12 + 8), v52);
  v14 = a3[1];
  if ( v14 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v52 = 1226;
  a3[1] = v14 + 1;
  *(_QWORD *)(v12 + 8) = v13;
  **((_QWORD **)v13 + 1) = v13;
  v15 = *a3;
  *(_QWORD *)&v52[4] = 1i64;
  v16 = sub_140017AD0(v15, *(_QWORD *)(v15 + 8), v52);
  v17 = a3[1];
  if ( v17 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1255i64;
  a3[1] = v17 + 1;
  *(_QWORD *)(v15 + 8) = v16;
  **((_QWORD **)v16 + 1) = v16;
  v18 = *a3;
  *(_DWORD *)&v52[8] = 2;
  v19 = sub_140017AD0(v18, *(_QWORD *)(v18 + 8), v52);
  v20 = a3[1];
  if ( v20 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1250i64;
  a3[1] = v20 + 1;
  *(_QWORD *)(v18 + 8) = v19;
  **((_QWORD **)v19 + 1) = v19;
  v21 = *a3;
  *(_DWORD *)&v52[8] = 2;
  v22 = sub_140017AD0(v21, *(_QWORD *)(v21 + 8), v52);
  v23 = a3[1];
  if ( v23 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v52 = 1250;
  a3[1] = v23 + 1;
  *(_QWORD *)(v21 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *a3;
  *(_DWORD *)&v52[4] = 1;
  v25 = *(_QWORD *)(v24 + 8);
  *(_DWORD *)&v52[8] = 1;
  v26 = sub_140017AD0(v24, v25, v52);
  v27 = a3[1];
  if ( v27 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1285i64;
  a3[1] = v27 + 1;
  *(_QWORD *)(v24 + 8) = v26;
  **((_QWORD **)v26 + 1) = v26;
  v28 = *a3;
  *(_DWORD *)&v52[8] = 2;
  v29 = sub_140017AD0(v28, *(_QWORD *)(v28 + 8), v52);
  v30 = a3[1];
  if ( v30 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v52 = 1285;
  a3[1] = v30 + 1;
  *(_QWORD *)(v28 + 8) = v29;
  **((_QWORD **)v29 + 1) = v29;
  v31 = *a3;
  *(_DWORD *)&v52[4] = 1;
  v32 = *(_QWORD *)(v31 + 8);
  *(_DWORD *)&v52[8] = 1;
  v33 = sub_140017AD0(v31, v32, v52);
  v34 = a3[1];
  if ( v34 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1254i64;
  a3[1] = v34 + 1;
  *(_QWORD *)(v31 + 8) = v33;
  **((_QWORD **)v33 + 1) = v33;
  v35 = *a3;
  *(_DWORD *)&v52[8] = 2;
  v36 = sub_140017AD0(v35, *(_QWORD *)(v35 + 8), v52);
  v37 = a3[1];
  if ( v37 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v52 = 1254;
  a3[1] = v37 + 1;
  *(_QWORD *)(v35 + 8) = v36;
  **((_QWORD **)v36 + 1) = v36;
  v38 = *a3;
  *(_DWORD *)&v52[4] = 1;
  v39 = *(_QWORD *)(v38 + 8);
  *(_DWORD *)&v52[8] = 1;
  v40 = sub_140017AD0(v38, v39, v52);
  v41 = a3[1];
  if ( v41 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1227i64;
  a3[1] = v41 + 1;
  *(_QWORD *)(v38 + 8) = v40;
  **((_QWORD **)v40 + 1) = v40;
  v42 = *a3;
  *(_DWORD *)&v52[8] = 0;
  v43 = sub_140017AD0(v42, *(_QWORD *)(v42 + 8), v52);
  v44 = a3[1];
  if ( v44 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1228i64;
  a3[1] = v44 + 1;
  *(_QWORD *)(v42 + 8) = v43;
  **((_QWORD **)v43 + 1) = v43;
  v45 = *a3;
  *(_DWORD *)&v52[8] = 0;
  v46 = sub_140017AD0(v45, *(_QWORD *)(v45 + 8), v52);
  v47 = a3[1];
  if ( v47 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v52 = 1304i64;
  a3[1] = v47 + 1;
  *(_QWORD *)(v45 + 8) = v46;
  **((_QWORD **)v46 + 1) = v46;
  v48 = *a3;
  *(_DWORD *)&v52[8] = 0;
  v49 = sub_140017AD0(v48, *(_QWORD *)(v48 + 8), v52);
  v50 = a3[1];
  if ( 0x1555555555555554i64 == v50 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v50 + 1;
  *(_QWORD *)(v48 + 8) = v49;
  result = (char **)*((_QWORD *)v49 + 1);
  *result = v49;
  return result;
}

//----- (000000014009EF90) ----------------------------------------------------
void __fastcall sub_14009EF90(__int64 a1)
{
  __int64 *v1; // rbx
  void *v3; // rcx

  v1 = *(__int64 **)(a1 + 1088);
  *(_QWORD *)a1 = &CSearchDialogPersistentSettings::`vftable';
  if ( v1 )
  {
    sub_140018EA0(v1);
    if ( *v1 )
      j_free((void *)*v1);
    j_free(v1);
  }
  v3 = *(void **)(a1 + 1128);
  if ( v3 )
    j_free(v3);
  *(_QWORD *)(a1 + 1128) = 0i64;
  *(_QWORD *)(a1 + 1136) = 0i64;
  *(_QWORD *)(a1 + 1144) = 0i64;
  sub_14000A630(a1 + 1064);
  j_free(*(void **)(a1 + 1064));
  *(_QWORD *)a1 = &CDialogSettings::`vftable';
}
// 1400F7608: using guessed type void *CSearchDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (000000014009F030) ----------------------------------------------------
__int64 *sub_14009F030()
{
  __int64 v0; // rdx
  _WORD *v1; // rcx
  __int16 v2; // ax
  __int64 v3; // rdx
  _WORD *v4; // rcx
  __int16 v5; // ax
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  char *v8; // rax
  char *v10[2]; // [rsp+20h] [rbp-58h] BYREF
  __int64 pExceptionObject[4]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v12; // [rsp+50h] [rbp-28h] BYREF
  char v13; // [rsp+58h] [rbp-20h]

  pExceptionObject[3] = -2i64;
  v10[1] = (char *)&qword_1401305A0;
  v0 = 256i64;
  v1 = &unk_1401305BC;
  while ( v0 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v1 + (char *)L"Search" - (char *)&unk_1401305BC);
    if ( !v2 )
      break;
    *v1++ = v2;
    if ( !--v0 )
    {
      --v1;
      break;
    }
  }
  *v1 = 0;
  byte_1401307BC = 1;
  dword_1401305A8 = 0;
  qword_1401305A0 = (__int64)&CSearchDialogPersistentSettings::`vftable';
  sub_14000A5B0(&qword_1401309C8);
  qword_140130A08 = 0i64;
  qword_140130A10 = 0i64;
  qword_140130A18 = 0i64;
  qword_1401309E8 = 1i64;
  qword_1401309F0 = 0i64;
  qword_1401309F8 = 0i64;
  dword_140130A00 = 0;
  qword_140130A30 = -1i64;
  v3 = 260i64;
  v4 = &unk_1401307C0;
  while ( v3 != -2147483386 )
  {
    v5 = *(_WORD *)((char *)v4 + &unk_1400EBDFC - &unk_1401307C0);
    if ( !v5 )
      break;
    *v4++ = v5;
    if ( !--v3 )
    {
      --v4;
      break;
    }
  }
  *v4 = 0;
  v6 = operator new(0x30ui64);
  v7 = v6;
  v12 = (__int64)v6;
  if ( v6 )
  {
    v6[4] = 0i64;
    v8 = (char *)operator new(0x320ui64);
    if ( !v8 )
    {
      v10[0] = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v10);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v7 = v8;
    v7[1] = v8 + 800;
    v7[3] = v8;
    v7[2] = v8;
  }
  else
  {
    v7 = 0i64;
  }
  qword_1401309E0 = v7;
  v12 = 0x85D00000001i64;
  v13 = 1;
  sub_140018780((__int64 *)&qword_140130A08, &v12);
  v12 = 0x85E00000002i64;
  v13 = 1;
  sub_140018780((__int64 *)&qword_140130A08, &v12);
  dword_140130A28 = *(_DWORD *)qword_140130A08;
  dword_140130A2C = *((unsigned __int8 *)qword_140130A08 + 8);
  return &qword_1401305A0;
}
// 14009F0A7: conditional instruction was optimized away because rdx.8!=0
// 14009F157: conditional instruction was optimized away because rdx.8!=0
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F00E0: using guessed type wchar_t aSearch_1[7];
// 1400F7608: using guessed type void *CSearchDialogPersistentSettings::`vftable';
// 1401305A0: using guessed type __int64 qword_1401305A0;
// 1401305A8: using guessed type int dword_1401305A8;
// 1401307BC: using guessed type char byte_1401307BC;
// 1401309E8: using guessed type __int64 qword_1401309E8;
// 1401309F0: using guessed type __int64 qword_1401309F0;
// 1401309F8: using guessed type __int64 qword_1401309F8;
// 140130A00: using guessed type int dword_140130A00;
// 140130A10: using guessed type __int64 qword_140130A10;
// 140130A18: using guessed type __int64 qword_140130A18;
// 140130A28: using guessed type int dword_140130A28;
// 140130A2C: using guessed type int dword_140130A2C;
// 140130A30: using guessed type __int64 qword_140130A30;

//----- (000000014009F270) ----------------------------------------------------
void **__fastcall sub_14009F270(__int64 a1)
{
  void **result; // rax

  *(_QWORD *)a1 = &CSearch::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
  sub_14000CC60((__int64 *)(a1 + 1088));
  sub_140008FC0((__int64 *)(a1 + 1112));
  result = &CReferenceCount::`vftable';
  *(_QWORD *)a1 = &CReferenceCount::`vftable';
  return result;
}
// 1400F7638: using guessed type void *CSearch::`vftable';
// 1400F7C30: using guessed type void *CReferenceCount::`vftable';

//----- (000000014009F2E0) ----------------------------------------------------
__int64 __fastcall sub_14009F2E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, int a8)
{
  __int64 v12; // rbp
  __int64 v13; // rcx
  _WORD *v14; // rcx
  int v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rsi
  __int16 v18; // ax
  _WORD *v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rdi
  __int16 v22; // ax
  char v24; // [rsp+40h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &CSearch::`vftable';
  *(_QWORD *)(a1 + 1088) = 0i64;
  *(_QWORD *)(a1 + 1096) = 0i64;
  *(_QWORD *)(a1 + 1104) = 0i64;
  *(_QWORD *)(a1 + 1112) = std::locale::_Init();
  v12 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)&v24, 0);
  v13 = *(_QWORD *)(v12 + 8);
  if ( v13 != -1 )
    *(_QWORD *)(v12 + 8) = v13 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v24);
  v14 = (_WORD *)(a1 + 24);
  *(_DWORD *)(a1 + 1068) = a5;
  v15 = a6;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 1072) = v15;
  v16 = 260i64;
  *(_DWORD *)(a1 + 1076) = a7;
  v17 = a3 - (a1 + 24);
  *(_DWORD *)(a1 + 1080) = a8;
  while ( v16 != -2147483386 )
  {
    v18 = *(_WORD *)((char *)v14 + v17);
    if ( !v18 )
      break;
    *v14++ = v18;
    if ( !--v16 )
    {
      --v14;
      break;
    }
  }
  *v14 = 0;
  v19 = (_WORD *)(a1 + 544);
  v20 = 262i64;
  v21 = a4 - (a1 + 544);
  while ( v20 != -2147483384 )
  {
    v22 = *(_WORD *)((char *)v19 + v21);
    if ( !v22 )
      break;
    *v19++ = v22;
    if ( !--v20 )
    {
      --v19;
      break;
    }
  }
  *v19 = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
  *(_DWORD *)(a1 + 1160) = 0;
  return a1;
}
// 14009F3C6: conditional instruction was optimized away because rdx.8!=0
// 14009F406: conditional instruction was optimized away because rdx.8!=0
// 1400F7638: using guessed type void *CSearch::`vftable';

//----- (000000014009F450) ----------------------------------------------------
void __fastcall sub_14009F450(__int64 a1, int a2, __int64 a3, int a4)
{
  int v4; // edx
  int v8; // edx
  int v9; // edx
  HWND DlgItem; // rax
  HWND v11; // rax
  __int64 v12; // rcx
  HWND v13; // rcx
  bool v14; // zf
  HINSTANCE v15; // rcx
  const WCHAR *v16; // r8
  __int64 v17; // rcx
  HWND v18; // rcx
  __int64 v19; // rdi
  char *v20; // r11
  __int64 v21; // rax
  __int64 v22; // [rsp+30h] [rbp-BB8h] BYREF
  WCHAR v23[64]; // [rsp+40h] [rbp-BA8h] BYREF
  WCHAR v24[128]; // [rsp+C0h] [rbp-B28h] BYREF
  WCHAR v25[128]; // [rsp+1C0h] [rbp-A28h] BYREF
  WCHAR Buffer[128]; // [rsp+2C0h] [rbp-928h] BYREF
  WCHAR String[512]; // [rsp+3C0h] [rbp-828h] BYREF
  __int16 v28[512]; // [rsp+7C0h] [rbp-428h] BYREF

  v4 = a2 - 32769;
  if ( v4 )
  {
    v8 = v4 - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        if ( v9 == 1 )
        {
          DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1285);
          ShowWindow(DlgItem, 5);
          v11 = GetDlgItem(*(HWND *)(a1 + 8), 1250);
          ShowWindow(v11, 0);
          LoadStringW(*(HINSTANCE *)(a1 + 16), 0x861u, Buffer, 128);
          SetDlgItemTextW(*(HWND *)(a1 + 8), 1285, Buffer);
          v12 = *(_QWORD *)(a1 + 696);
          if ( !_InterlockedDecrement((volatile signed __int32 *)(v12 + 8)) )
          {
            if ( v12 )
              (**(void (__fastcall ***)(__int64, __int64))v12)(v12, 1i64);
          }
          v13 = *(HWND *)(a1 + 8);
          *(_QWORD *)(a1 + 696) = 0i64;
          *(_QWORD *)(a1 + 624) = 0i64;
          SetDlgItemTextW(v13, 1227, (LPCWSTR)(a1 + 632));
        }
      }
      else
      {
        LoadStringW(*(HINSTANCE *)(a1 + 16), 0x84Au, v23, 64);
        sub_140001000(String, 0x200ui64, v23, a3);
        SetDlgItemTextW(*(HWND *)(a1 + 8), 1250, String);
      }
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 628) == 0;
      v15 = *(HINSTANCE *)(a1 + 16);
      if ( v14 )
      {
        LoadStringW(v15, 0x85Fu, v24, 128);
        sub_140001000((wchar_t *)v28, 0x200ui64, v24, (unsigned __int16)a4, HIWORD(a4));
        v16 = (const WCHAR *)v28;
      }
      else
      {
        LoadStringW(v15, 0x860u, v25, 128);
        v16 = v25;
      }
      SetDlgItemTextW(*(HWND *)(a1 + 8), 1250, v16);
      v17 = *(_QWORD *)(a1 + 696);
      if ( !_InterlockedDecrement((volatile signed __int32 *)(v17 + 8)) && v17 )
        (**(void (__fastcall ***)(__int64, __int64))v17)(v17, 1i64);
      v18 = *(HWND *)(a1 + 8);
      *(_QWORD *)(a1 + 696) = 0i64;
      *(_QWORD *)(a1 + 624) = 0i64;
      SetDlgItemTextW(v18, 1227, (LPCWSTR)(a1 + 632));
    }
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 704);
    v22 = a3;
    v20 = sub_14000BB70(v19, *(_QWORD *)(v19 + 8), &v22);
    v21 = *(_QWORD *)(a1 + 712);
    if ( v21 == 0x1FFFFFFFFFFFFFFEi64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 712) = v21 + 1;
    *(_QWORD *)(v19 + 8) = v20;
    **((_QWORD **)v20 + 1) = v20;
    if ( *(_DWORD *)(a1 + 824) )
    {
      SetTimer(*(HWND *)(a1 + 8), 0i64, 0x32u, 0i64);
      *(_DWORD *)(a1 + 824) = 0;
    }
  }
}
// 14009F450: using guessed type wchar_t var_428[512];

//----- (000000014009F720) ----------------------------------------------------
void __fastcall sub_14009F720(__int64 a1, const ITEMIDLIST *a2, __int64 a3, int a4)
{
  ITEMIDLIST *v7; // rbx
  __int64 v8; // rax
  WCHAR pszBuf[264]; // [rsp+30h] [rbp-238h] BYREF

  if ( a4 == 1001 )
  {
    (*(void (__fastcall **)(_QWORD, const ITEMIDLIST *, _QWORD, __int64, int, _DWORD))(**(_QWORD **)(a1 + 752) + 80i64))(
      *(_QWORD *)(a1 + 752),
      a2,
      0i64,
      1i64,
      1,
      0);
    v7 = ILCombine(a2, *(LPCITEMIDLIST *)(**(_QWORD **)a3 + 16i64));
    sub_14007E270(v7, pszBuf, 0x8001u);
    CoTaskMemFree(v7);
    v8 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 752) + 8i64))(*(_QWORD *)(a1 + 752));
    (*(void (__fastcall **)(__int64, WCHAR *))(*(_QWORD *)v8 + 232i64))(v8, pszBuf);
  }
}

//----- (000000014009F7F0) ----------------------------------------------------
__int64 __fastcall sub_14009F7F0(__int64 a1, const ITEMIDLIST *a2, __int64 ****a3, __int64 a4, const WCHAR *psz1)
{
  __int64 ***v8; // rdi
  __int64 **i; // rbx
  LPITEMIDLIST v10; // rsi

  if ( StrCmpIW(psz1, L"open") )
    return 0i64;
  v8 = *a3;
  for ( i = *v8; i != (__int64 **)v8; i = (__int64 **)*i )
  {
    v10 = ILCombine(a2, (LPCITEMIDLIST)i[2]);
    (*(void (__fastcall **)(_QWORD, LPITEMIDLIST, _QWORD, _QWORD))(**(_QWORD **)(a1 + 752) + 64i64))(
      *(_QWORD *)(a1 + 752),
      v10,
      0i64,
      0i64);
    CoTaskMemFree(v10);
  }
  return 1i64;
}

//----- (000000014009F8C0) ----------------------------------------------------
BOOL __fastcall sub_14009F8C0(__int64 a1, const ITEMIDLIST *a2, __int64 a3, __int64 a4, HMENU hmenu)
{
  const ITEMIDLIST *v6; // rax
  ITEMIDLIST *v7; // rbx
  UINT v8; // edx
  int v10; // [rsp+20h] [rbp-118h] BYREF
  void *ppv; // [rsp+28h] [rbp-110h] BYREF
  LPCITEMIDLIST ppidlLast[2]; // [rsp+30h] [rbp-108h] BYREF
  MENUITEMINFOW mi; // [rsp+40h] [rbp-F8h] BYREF
  WCHAR Buffer[64]; // [rsp+90h] [rbp-A8h] BYREF

  v6 = ILCombine(a2, *(LPCITEMIDLIST *)(**(_QWORD **)a3 + 16i64));
  v10 = 0x20000000;
  v7 = (ITEMIDLIST *)v6;
  if ( v6 )
  {
    ppv = 0i64;
    ppidlLast[0] = 0i64;
    if ( SHBindToParent(v6, &stru_1400E3FB0, &ppv, ppidlLast) >= 0 )
    {
      (*(void (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
        ppv,
        1i64,
        ppidlLast,
        &v10);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    }
  }
  CoTaskMemFree(v7);
  v8 = 2153;
  if ( (v10 & 0x20000000) == 0 )
    v8 = 2152;
  LoadStringW(*(HINSTANCE *)(a1 - 64), v8, Buffer, 64);
  mi.dwTypeData = Buffer;
  mi.cbSize = 80;
  mi.fMask = 66;
  mi.wID = 1001;
  return InsertMenuItemW(hmenu, 1u, 1, &mi);
}

//----- (000000014009FB80) ----------------------------------------------------
void __fastcall sub_14009FB80(__int64 a1)
{
  __int64 v2; // rsi
  __int64 v3; // rcx
  void *v4; // rcx
  _QWORD **v5; // rax
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx

  *(_QWORD *)a1 = &CSearchDialog::`vftable';
  *(_QWORD *)(a1 + 80) = &CSearchDialog::`vftable';
  DestroyIcon(*(HICON *)(a1 + 608));
  DestroyIcon(*(HICON *)(a1 + 616));
  v2 = *(_QWORD *)(a1 + 696);
  if ( v2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v2 + 1120));
    *(_DWORD *)(v2 + 1160) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 1120));
    v3 = *(_QWORD *)(a1 + 696);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v3 + 8)) )
    {
      if ( v3 )
        (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1i64);
    }
  }
  v4 = *(void **)(a1 + 760);
  if ( v4 )
    j_free(v4);
  *(_QWORD *)(a1 + 760) = 0i64;
  *(_QWORD *)(a1 + 768) = 0i64;
  *(_QWORD *)(a1 + 776) = 0i64;
  sub_140018CF0(a1 + 736);
  j_free(*(void **)(a1 + 736));
  v5 = *(_QWORD ***)(a1 + 704);
  v6 = *v5;
  *v5 = v5;
  *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8i64) = *(_QWORD *)(a1 + 704);
  *(_QWORD *)(a1 + 712) = 0i64;
  if ( v6 != *(_QWORD **)(a1 + 704) )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      j_free(v6);
      v6 = v7;
    }
    while ( v7 != *(_QWORD **)(a1 + 704) );
  }
  j_free(*(void **)(a1 + 704));
  sub_140084540((_QWORD *)a1);
}
// 1400F7578: using guessed type void *CSearchDialog::`vftable';
// 1400F75E8: using guessed type void *CSearchDialog::`vftable';

//----- (000000014009FCD0) ----------------------------------------------------
__int64 __fastcall sub_14009FCD0(void *Block)
{
  if ( Block )
  {
    sub_14009FB80((__int64)Block);
    j_free(Block);
  }
  return 0i64;
}

//----- (000000014009FD00) ----------------------------------------------------
__int64 __fastcall sub_14009FD00(__int64 a1)
{
  __int64 v2; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  __int64 v5; // rax
  HWND v6; // rcx
  HWND DlgItem; // rax
  HWND v8; // r14
  __int64 v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // rbx
  int i; // esi
  double v13; // xmm0_8
  double v14; // xmm0_8
  HWND v15; // r13
  LRESULT v16; // rax
  int v17; // esi
  _QWORD *v18; // rdi
  HWND v19; // r15
  _QWORD *j; // rbx
  LPARAM *v21; // r8
  __int64 v22; // rdx
  char *v23; // rcx
  signed __int64 v24; // r8
  __int16 v25; // ax
  HWND v26; // r13
  LRESULT v27; // rax
  __int64 v28; // rdi
  HWND v29; // r15
  int v30; // esi
  _QWORD *v31; // rbx
  LPARAM *v32; // r8
  __int64 v33; // rdx
  char *v34; // rcx
  signed __int64 v35; // r8
  __int16 v36; // ax
  __int64 v37; // r11
  _DWORD *v38; // rdx
  HWND v39; // rbx
  HWND Parent; // rax
  HWND v41; // rax
  HIMAGELIST phimlSmall; // [rsp+60h] [rbp-A8h] BYREF
  LPARAM v44; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v45; // [rsp+70h] [rbp-98h]
  char *v46; // [rsp+78h] [rbp-90h]
  LPARAM lParam[2]; // [rsp+A0h] [rbp-68h] BYREF
  WCHAR *v48; // [rsp+B0h] [rbp-58h]
  unsigned __int64 v49; // [rsp+B8h] [rbp-50h]
  struct tagRECT Rect; // [rsp+C8h] [rbp-40h] BYREF
  char v51[528]; // [rsp+D8h] [rbp-30h] BYREF
  WCHAR Buffer[128]; // [rsp+2E8h] [rbp+1E0h] BYREF

  SetDlgItemTextW(*(HWND *)(a1 + 8), 1225, (LPCWSTR)(*(_QWORD *)(a1 + 840) + 544i64));
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1224, (LPCWSTR)(a1 + 88));
  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  *(_QWORD *)(a1 + 616) = sub_14000A470(v2, 0xFu, 0);
  v5 = sub_14000A470(v2, 0x11u, 0);
  v6 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 608) = v5;
  DlgItem = GetDlgItem(v6, 1229);
  SendMessageW(DlgItem, 0xF7u, 1ui64, *(_QWORD *)(a1 + 616));
  SetClassLongPtrW(*(HWND *)(a1 + 8), -34, *(_QWORD *)(a1 + 608));
  DeleteObject(BitmapW);
  sub_14000A390(v2);
  v8 = GetDlgItem(*(HWND *)(a1 + 8), 1226);
  SendMessageW(v8, 0x1036u, 0x10001ui64, 65537i64);
  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(v8, 0x1003u, 1ui64, (LPARAM)phimlSmall);
  SetWindowTheme(v8, L"Explorer", 0i64);
  v9 = *(_QWORD *)(a1 + 840);
  v10 = *(_QWORD *)(v9 + 1136);
  v11 = *(_QWORD *)(v9 + 1128);
  for ( i = 0; v11 != v10; ++i )
  {
    LoadStringW(*(HINSTANCE *)(a1 + 16), *(_DWORD *)(v11 + 4), Buffer, 128);
    v48 = Buffer;
    LODWORD(lParam[0]) = 4;
    SendMessageW(v8, 0x1061u, i, (LPARAM)lParam);
    v11 += 12i64;
  }
  GetClientRect(v8, &Rect);
  v13 = (double)(Rect.right - Rect.left) * 0.3333333333333333;
  if ( v13 > 9.223372036854776e18 )
    v13 = v13 - 9.223372036854776e18;
  SendMessageW(v8, 0x101Eu, 0i64, (unsigned __int16)(int)v13);
  v14 = (double)(Rect.right - Rect.left) * 0.6;
  if ( v14 > 9.223372036854776e18 )
    v14 = v14 - 9.223372036854776e18;
  SendMessageW(v8, 0x101Eu, 1ui64, (unsigned __int16)(int)v14);
  sub_14009E570(a1);
  CheckDlgButton(*(HWND *)(a1 + 8), 1060, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1108i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1061, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1112i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1062, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1116i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1059, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1120i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1249, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1096i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1282, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1104i64) != 0);
  CheckDlgButton(*(HWND *)(a1 + 8), 1281, *(_DWORD *)(*(_QWORD *)(a1 + 840) + 1100i64) != 0);
  v15 = GetDlgItem(*(HWND *)(a1 + 8), 1224);
  v16 = SendMessageW(v15, 0x406u, 0i64, 0i64);
  v17 = 0;
  v18 = *(_QWORD **)(*(_QWORD *)(a1 + 840) + 1064i64);
  v19 = (HWND)v16;
  for ( j = (_QWORD *)*v18; j != v18; j = (_QWORD *)*j )
  {
    v49 = 7i64;
    v48 = 0i64;
    LOWORD(lParam[0]) = 0;
    sub_140009610(lParam, j + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v21 = lParam;
    v22 = 260i64;
    if ( v49 >= 8 )
      v21 = (LPARAM *)lParam[0];
    v23 = v51;
    v24 = (char *)v21 - v51;
    while ( v22 != -2147483386 )
    {
      v25 = *(_WORD *)&v23[v24];
      if ( !v25 )
        break;
      *(_WORD *)v23 = v25;
      v23 += 2;
      if ( !--v22 )
      {
        v23 -= 2;
        break;
      }
    }
    *(_WORD *)v23 = 0;
    v45 = v17;
    LODWORD(v44) = 1;
    v46 = v51;
    ++v17;
    SendMessageW(v15, 0x40Bu, 0i64, (LPARAM)&v44);
    if ( v49 >= 8 )
      j_free((void *)lParam[0]);
  }
  SendMessageW(v19, 0x14Eu, 0i64, 0i64);
  v26 = GetDlgItem(*(HWND *)(a1 + 8), 1225);
  v27 = SendMessageW(v26, 0x406u, 0i64, 0i64);
  v28 = *(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64);
  v29 = (HWND)v27;
  v30 = 0;
  v31 = 0i64;
  if ( *(_QWORD *)(v28 + 32) )
    v31 = *(_QWORD **)(v28 + 16);
  if ( v31 )
  {
    do
    {
      v49 = 7i64;
      v48 = 0i64;
      LOWORD(lParam[0]) = 0;
      sub_140009610(lParam, v31, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v32 = lParam;
      v33 = 260i64;
      if ( v49 >= 8 )
        v32 = (LPARAM *)lParam[0];
      v34 = v51;
      v35 = (char *)v32 - v51;
      while ( v33 != -2147483386 )
      {
        v36 = *(_WORD *)&v34[v35];
        if ( !v36 )
          break;
        *(_WORD *)v34 = v36;
        v34 += 2;
        if ( !--v33 )
        {
          v34 -= 2;
          break;
        }
      }
      *(_WORD *)v34 = 0;
      v45 = v30;
      LODWORD(v44) = 1;
      v46 = v51;
      ++v30;
      SendMessageW(v26, 0x40Bu, 0i64, (LPARAM)&v44);
      if ( v49 >= 8 )
        j_free((void *)lParam[0]);
      v31 += 5;
      if ( v31 == *(_QWORD **)(v28 + 8) )
        v31 = *(_QWORD **)v28;
    }
    while ( v31 != *(_QWORD **)(v28 + 24) && v31 );
  }
  SendMessageW(v29, 0x14Eu, 0i64, 0i64);
  v37 = *(_QWORD *)(a1 + 840);
  if ( *(_DWORD *)(v37 + 8) && *(_DWORD *)(v37 + 1168) != -1 && *(_DWORD *)(v37 + 1172) != -1 )
  {
    SendMessageW(v8, 0x101Eu, 0i64, *(unsigned __int16 *)(v37 + 1168));
    SendMessageW(v8, 0x101Eu, 1ui64, *(unsigned __int16 *)(*(_QWORD *)(a1 + 840) + 1172i64));
  }
  v38 = *(_DWORD **)(a1 + 840);
  v39 = *(HWND *)(a1 + 8);
  if ( v38[2] )
  {
    SetWindowPos(v39, 0i64, v38[3], v38[4], v38[5], v38[6], 4u);
  }
  else
  {
    Parent = GetParent(v39);
    sub_140081E00(Parent, v39);
  }
  v41 = GetDlgItem(*(HWND *)(a1 + 8), 1225);
  SetFocus(v41);
  return 0i64;
}
// 1400A01AA: conditional instruction was optimized away because rdx.8!=0
// 1400A02D9: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400A0460) ----------------------------------------------------
void __fastcall sub_1400A0460(__int64 a1, const WCHAR *a2, _WORD *a3)
{
  __int64 v6; // rcx
  _WORD *v7; // rdi
  bool v8; // zf
  __int64 v9; // rdi
  char *v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rcx
  _WORD *v13; // rdi
  __int64 v14; // rdx
  _WORD *v15; // rcx
  char *v16; // rbx
  __int16 v17; // ax
  int v18; // eax
  void *Block[2]; // [rsp+28h] [rbp-50h] BYREF
  __int64 v20; // [rsp+38h] [rbp-40h]
  unsigned __int64 v21; // [rsp+40h] [rbp-38h]

  if ( !lstrcmpiW(a2, L"ColumnWidth1") )
  {
    *(_DWORD *)(a1 + 1168) = sub_14004B61C(a3);
    return;
  }
  if ( !lstrcmpiW(a2, L"ColumnWidth2") )
  {
    *(_DWORD *)(a1 + 1172) = sub_14004B61C(a3);
    return;
  }
  if ( (unsigned int)sub_140082100(L"Directory*", a2, 1) )
  {
    v21 = 7i64;
    v20 = 0i64;
    LOWORD(Block[0]) = 0;
    v6 = -1i64;
    v7 = a3;
    do
    {
      if ( !v6 )
        break;
      v8 = *v7++ == 0;
      --v6;
    }
    while ( !v8 );
    sub_1400099E0(Block, a3, -v6 - 2);
    v9 = *(_QWORD *)(a1 + 1064);
    v10 = sub_14000A760(v9, *(_QWORD *)(v9 + 8), Block);
    v11 = *(_QWORD *)(a1 + 1072);
    if ( v11 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 1072) = v11 + 1;
    *(_QWORD *)(v9 + 8) = v10;
    **((_QWORD **)v10 + 1) = v10;
LABEL_17:
    if ( v21 >= 8 )
      j_free(Block[0]);
    return;
  }
  if ( (unsigned int)sub_140082100(L"Pattern*", a2, 1) )
  {
    v21 = 7i64;
    v20 = 0i64;
    LOWORD(Block[0]) = 0;
    v12 = -1i64;
    v13 = a3;
    do
    {
      if ( !v12 )
        break;
      v8 = *v13++ == 0;
      --v12;
    }
    while ( !v8 );
    sub_1400099E0(Block, a3, -v12 - 2);
    sub_1400188F0(*(_QWORD *)(a1 + 1088), Block);
    goto LABEL_17;
  }
  if ( lstrcmpiW(a2, L"SearchDirectoryText") )
  {
    if ( lstrcmpiW(a2, L"SearchSubFolders") )
    {
      if ( lstrcmpiW(a2, L"UseRegularExpressions") )
      {
        if ( lstrcmpiW(a2, L"CaseInsensitive") )
        {
          if ( lstrcmpiW(a2, L"Archive") )
          {
            if ( lstrcmpiW(a2, L"Hidden") )
            {
              if ( lstrcmpiW(a2, L"ReadOnly") )
              {
                if ( lstrcmpiW(a2, L"System") )
                {
                  if ( lstrcmpiW(a2, L"SortMode") )
                  {
                    if ( !lstrcmpiW(a2, L"SortAscending") )
                      *(_DWORD *)(a1 + 1164) = lstrcmpW(a3, L"yes") == 0;
                  }
                  else
                  {
                    v18 = sub_14004B61C(a3) - 1;
                    if ( v18 )
                    {
                      if ( v18 == 1 )
                        *(_DWORD *)(a1 + 1160) = 2;
                    }
                    else
                    {
                      *(_DWORD *)(a1 + 1160) = 1;
                    }
                  }
                }
                else
                {
                  *(_DWORD *)(a1 + 1120) = lstrcmpW(a3, L"yes") == 0;
                }
              }
              else
              {
                *(_DWORD *)(a1 + 1116) = lstrcmpW(a3, L"yes") == 0;
              }
            }
            else
            {
              *(_DWORD *)(a1 + 1112) = lstrcmpW(a3, L"yes") == 0;
            }
          }
          else
          {
            *(_DWORD *)(a1 + 1108) = lstrcmpW(a3, L"yes") == 0;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 1104) = lstrcmpW(a3, L"yes") == 0;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 1100) = lstrcmpW(a3, L"yes") == 0;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 1096) = lstrcmpW(a3, L"yes") == 0;
    }
  }
  else
  {
    v14 = 260i64;
    v15 = (_WORD *)(a1 + 544);
    v16 = (char *)a3 - a1 - 544;
    while ( v14 != -2147483386 )
    {
      v17 = *(_WORD *)((char *)v15 + (_QWORD)v16);
      if ( !v17 )
        break;
      *v15++ = v17;
      if ( !--v14 )
      {
        --v15;
        break;
      }
    }
    *v15 = 0;
  }
}
// 1400A0648: conditional instruction was optimized away because rdx.8!=0
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (00000001400A0860) ----------------------------------------------------
void __fastcall sub_1400A0860(__int64 a1, __int64 *a2, __int64 a3)
{
  _QWORD *v6; // rax
  const OLECHAR *v7; // rbx
  const OLECHAR *v8; // r9
  const OLECHAR *v9; // r9
  const OLECHAR *v10; // r9
  const OLECHAR *v11; // r9
  const OLECHAR *v12; // r9
  const OLECHAR *v13; // r9
  const OLECHAR *v14; // r9
  void **v15; // rsi
  void **v16; // rbx
  void **v17; // rdi
  void *Block[3]; // [rsp+28h] [rbp-50h] BYREF
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-38h] BYREF
  char *v20; // [rsp+80h] [rbp+8h] BYREF

  itow_s(*(_DWORD *)(a1 + 1168), Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"ColumnWidth1", Buffer);
  itow_s(*(_DWORD *)(a1 + 1172), Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"ColumnWidth2", Buffer);
  sub_14007C330(a2, a3, (__int64)L"Directory", (_QWORD **)(a1 + 1064));
  Block[1] = 0i64;
  v6 = operator new(0x38ui64);
  if ( !v6 )
  {
    v20 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v20);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v6;
  *v6 = v6;
  v6[1] = v6;
  sub_140019320(*(_QWORD *)(a1 + 1088), (__int64 *)Block);
  sub_14007C330(a2, a3, (__int64)L"Pattern", (_QWORD **)Block);
  sub_14007BEA0(a2, a3, L"SearchDirectoryText", (const OLECHAR *)(a1 + 544));
  v7 = aYes_0;
  v8 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1096) )
    v8 = aNo;
  sub_14007BEA0(a2, a3, L"SearchSubFolders", v8);
  v9 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1100) )
    v9 = aNo;
  sub_14007BEA0(a2, a3, L"UseRegularExpressions", v9);
  v10 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1104) )
    v10 = aNo;
  sub_14007BEA0(a2, a3, L"CaseInsensitive", v10);
  v11 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1108) )
    v11 = aNo;
  sub_14007BEA0(a2, a3, L"Archive", v11);
  v12 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1112) )
    v12 = aNo;
  sub_14007BEA0(a2, a3, L"Hidden", v12);
  v13 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1116) )
    v13 = aNo;
  sub_14007BEA0(a2, a3, L"ReadOnly", v13);
  v14 = aYes_0;
  if ( !*(_DWORD *)(a1 + 1120) )
    v14 = aNo;
  sub_14007BEA0(a2, a3, L"System", v14);
  itow_s(*(_DWORD *)(a1 + 1160), Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"SortMode", Buffer);
  if ( !*(_DWORD *)(a1 + 1164) )
    v7 = aNo;
  sub_14007BEA0(a2, a3, L"SortAscending", v7);
  v15 = (void **)Block[0];
  v16 = *(void ***)Block[0];
  *(_QWORD *)Block[0] = Block[0];
  v15[1] = v15;
  if ( v16 != v15 )
  {
    do
    {
      v17 = (void **)*v16;
      if ( (unsigned __int64)v16[5] >= 8 )
        j_free(v16[2]);
      v16[5] = (void *)7;
      v16[4] = 0i64;
      *((_WORD *)v16 + 8) = 0;
      j_free(v16);
      v16 = v17;
    }
    while ( v17 != v15 );
  }
  j_free(v15);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F0450: using guessed type wchar_t aColumnwidth1_0[13];
// 1400F0470: using guessed type wchar_t aColumnwidth2_0[13];
// 1400F0490: using guessed type wchar_t aDirectory_3[10];
// 1400F04A8: using guessed type wchar_t aPattern_4[8];
// 1400F04B8: using guessed type wchar_t aSearchdirector_0[20];
// 1400F04E0: using guessed type wchar_t aSearchsubfolde_0[17];
// 1400F0508: using guessed type wchar_t aUseregularexpr_0[22];
// 1400F0538: using guessed type wchar_t aCaseinsensitiv_0[16];
// 1400F0558: using guessed type wchar_t aArchive_0[8];
// 1400F0568: using guessed type wchar_t aHidden_0[7];
// 1400F0578: using guessed type wchar_t aReadonly_0[9];
// 1400F0590: using guessed type wchar_t aSystem_0[7];
// 1400F05A0: using guessed type wchar_t aSortmode_2[9];
// 1400F05B8: using guessed type wchar_t aSortascending_2[14];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 14012BA18: using guessed type wchar_t aNo[3];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (00000001400A0F90) ----------------------------------------------------
void __fastcall sub_1400A0F90(__int64 a1, HKEY a2)
{
  int v4; // eax
  _QWORD *v5; // rax
  void **v6; // rsi
  void **v7; // rbx
  void **v8; // rdi
  void *Block[3]; // [rsp+38h] [rbp-38h] BYREF
  __int64 pExceptionObject[4]; // [rsp+50h] [rbp-20h] BYREF
  const char *Data; // [rsp+90h] [rbp+20h] BYREF

  LODWORD(Data) = *(_DWORD *)(a1 + 1168);
  RegSetValueExW(a2, L"ColumnWidth1", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1172);
  RegSetValueExW(a2, L"ColumnWidth2", 0, 4u, (const BYTE *)&Data, 4u);
  v4 = lstrlenW((LPCWSTR)(a1 + 544));
  RegSetValueExW(a2, L"SearchDirectoryText", 0, 1u, (const BYTE *)(a1 + 544), 2 * v4);
  LODWORD(Data) = *(_DWORD *)(a1 + 1096);
  RegSetValueExW(a2, L"SearchSubFolders", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1100);
  RegSetValueExW(a2, L"UseRegularExpressions", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1104);
  RegSetValueExW(a2, L"CaseInsensitive", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1108);
  RegSetValueExW(a2, L"Archive", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1112);
  RegSetValueExW(a2, L"Hidden", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1116);
  RegSetValueExW(a2, L"ReadOnly", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1120);
  RegSetValueExW(a2, L"System", 0, 4u, (const BYTE *)&Data, 4u);
  sub_14007B450(a2, (__int64)L"Directory", (_QWORD **)(a1 + 1064));
  Block[1] = 0i64;
  v5 = operator new(0x38ui64);
  if ( !v5 )
  {
    Data = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, &Data);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v5;
  *v5 = v5;
  v5[1] = v5;
  sub_140019320(*(_QWORD *)(a1 + 1088), (__int64 *)Block);
  sub_14007B450(a2, (__int64)L"Pattern", (_QWORD **)Block);
  LODWORD(Data) = *(_DWORD *)(a1 + 1160);
  RegSetValueExW(a2, L"SortMode", 0, 4u, (const BYTE *)&Data, 4u);
  LODWORD(Data) = *(_DWORD *)(a1 + 1164);
  RegSetValueExW(a2, L"SortAscending", 0, 4u, (const BYTE *)&Data, 4u);
  v6 = (void **)Block[0];
  v7 = *(void ***)Block[0];
  *(_QWORD *)Block[0] = Block[0];
  v6[1] = v6;
  if ( v7 != v6 )
  {
    do
    {
      v8 = (void **)*v7;
      if ( (unsigned __int64)v7[5] >= 8 )
        j_free(v7[2]);
      v7[5] = (void *)7;
      v7[4] = 0i64;
      *((_WORD *)v7 + 8) = 0;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != v6 );
  }
  j_free(v6);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F0268: using guessed type wchar_t aDirectory_5[10];
// 1400F0280: using guessed type wchar_t aPattern_6[8];

//----- (00000001400A1330) ----------------------------------------------------
__int64 __fastcall sub_1400A1330(__int64 a1, int a2)
{
  __int64 v4; // r14
  int v5; // er13
  void *i; // rbx
  ITEMIDLIST *v7; // rsi
  __int64 v8; // rcx
  WCHAR *v9; // rdi
  bool v10; // zf
  __int64 v11; // rdi
  char *v12; // rax
  __int64 v13; // rdx
  HWND v14; // rdi
  int v15; // eax
  void *v16; // rdi
  void *ppv; // [rsp+38h] [rbp-D0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+40h] [rbp-C8h] BYREF
  HWND hWnd; // [rsp+48h] [rbp-C0h]
  LRESULT v20; // [rsp+50h] [rbp-B8h]
  __int64 v21; // [rsp+58h] [rbp-B0h]
  _DWORD lParam[6]; // [rsp+68h] [rbp-A0h] BYREF
  WCHAR *v23; // [rsp+80h] [rbp-88h]
  int iIcon; // [rsp+8Ch] [rbp-7Ch]
  __int64 v25; // [rsp+90h] [rbp-78h]
  char v26[16]; // [rsp+B8h] [rbp-50h] BYREF
  STRRET pstr; // [rsp+C8h] [rbp-40h] BYREF
  LPARAM v28; // [rsp+1D8h] [rbp+D0h] BYREF
  void *Block; // [rsp+1E0h] [rbp+D8h] BYREF
  WCHAR *v30; // [rsp+1F0h] [rbp+E8h]
  unsigned __int64 v31; // [rsp+1F8h] [rbp+F0h]
  SHFILEINFOW psfi; // [rsp+228h] [rbp+120h] BYREF
  WCHAR pszBuf[264]; // [rsp+4E8h] [rbp+3E0h] BYREF
  WCHAR v34[264]; // [rsp+6F8h] [rbp+5F0h] BYREF
  WCHAR v35[264]; // [rsp+908h] [rbp+800h] BYREF

  v21 = -2i64;
  if ( a2 )
    return 1i64;
  hWnd = GetDlgItem(*(HWND *)(a1 + 8), 1226);
  v20 = SendMessageW(hWnd, 0x1004u, 0i64, 0i64);
  v4 = *(_QWORD *)(a1 + 712);
  if ( (int)v4 >= 100 )
    LODWORD(v4) = 100;
  v5 = 0;
  for ( i = **(void ***)(a1 + 704); v5 < (int)v4; ++v5 )
  {
    v7 = (ITEMIDLIST *)*((_QWORD *)i + 2);
    if ( v7 )
    {
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               0x8000i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v7, pszBuf, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    PathRemoveFileSpecW(pszBuf);
    if ( v7 )
    {
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               0x8000i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v7, v34, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
      ppv = 0i64;
      ppidlLast = 0i64;
      if ( SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
      {
        if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
               ppv,
               ppidlLast,
               32769i64,
               &pstr) >= 0 )
          StrRetToBufW(&pstr, v7, v35, 0x104u);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    SHGetFileInfoW(&v7->mkid.cb, 0, &psfi, 0x2B8u, 0x4008u);
    LODWORD(v28) = *(_DWORD *)(a1 + 816);
    v31 = 7i64;
    v30 = 0i64;
    LOWORD(Block) = 0;
    v8 = -1i64;
    v9 = v34;
    do
    {
      if ( !v8 )
        break;
      v10 = *v9++ == 0;
      --v8;
    }
    while ( !v10 );
    sub_1400099E0(&Block, v34, -v8 - 2);
    v11 = **(_QWORD **)(a1 + 736);
    v12 = sub_140019BF0(v11, *(_QWORD *)(v11 + 8), &v28);
    v13 = *(_QWORD *)(a1 + 744);
    if ( v13 == 0x555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 744) = v13 + 1;
    *(_QWORD *)(v11 + 8) = v12;
    **((_QWORD **)v12 + 1) = v12;
    sub_140019470((_QWORD *)(a1 + 728), (__int64)v26, (int *)(**(_QWORD **)(a1 + 736) + 16i64), **(_QWORD **)(a1 + 736));
    if ( v31 >= 8 )
      j_free(Block);
    lParam[0] = 7;
    v23 = v35;
    lParam[1] = v5 + v20;
    lParam[2] = 0;
    iIcon = psfi.iIcon;
    v25 = *(int *)(a1 + 816);
    *(_DWORD *)(a1 + 816) = v25 + 1;
    v14 = hWnd;
    v15 = SendMessageW(hWnd, 0x104Du, 0i64, (LPARAM)lParam);
    LODWORD(Block) = 1;
    v30 = pszBuf;
    SendMessageW(v14, 0x1074u, v15, (LPARAM)&v28);
    CoTaskMemFree(v7);
    v16 = *(void **)i;
    if ( i != *(void **)(a1 + 704) )
    {
      **((_QWORD **)i + 1) = v16;
      *(_QWORD *)(*(_QWORD *)i + 8i64) = *((_QWORD *)i + 1);
      j_free(i);
      --*(_QWORD *)(a1 + 712);
    }
    i = v16;
  }
  *(_DWORD *)(a1 + 824) = 1;
  return 0i64;
}
// 1400A14D8: conditional instruction was optimized away because rsi.8!=0
// 1400A1330: using guessed type char var_A90[16];

//----- (00000001400A1780) ----------------------------------------------------
__int64 __fastcall sub_1400A1780(WPARAM wParam, __int64 a2)
{
  int v4; // eax
  HWND v5; // rsi
  int v6; // eax
  __int64 *v7; // rcx
  HWND v8; // rsi
  int v9; // eax
  __int64 *v10; // rcx
  _QWORD *v11; // rax
  _QWORD *v12; // rsi
  char *v13; // rax
  LPITEMIDLIST v14; // r12
  void **v15; // rax
  DWORD MessagePos; // eax
  int v17; // er13
  __int64 v18; // rax
  _QWORD *v19; // rcx
  _QWORD *v20; // rbx
  __int64 v21; // r8
  HWND DlgItem; // rax
  LPVOID pv; // [rsp+40h] [rbp-C0h] BYREF
  int v25[2]; // [rsp+48h] [rbp-B8h] BYREF
  __int64 *ID; // [rsp+50h] [rbp-B0h] BYREF
  char *v27; // [rsp+58h] [rbp-A8h] BYREF
  _QWORD **v28; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v29; // [rsp+68h] [rbp-98h]
  int lParam; // [rsp+80h] [rbp-80h] BYREF
  int lParam_4; // [rsp+84h] [rbp-7Ch]
  int v32; // [rsp+88h] [rbp-78h]
  int v33; // [rsp+A8h] [rbp-58h]
  __int64 v34; // [rsp+D0h] [rbp-30h]
  __int64 pExceptionObject[3]; // [rsp+D8h] [rbp-28h] BYREF
  DWORD_PTR dwRefData[12]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 *v37; // [rsp+150h] [rbp+50h] BYREF

  v34 = -2i64;
  v4 = *(_DWORD *)(a2 + 16);
  switch ( v4 )
  {
    case -108:
      v21 = *(_QWORD *)(wParam + 840);
      if ( *(_DWORD *)(*(_QWORD *)(v21 + 1128) + 12i64 * *(int *)(a2 + 28)) == *(_DWORD *)(v21 + 1160) )
      {
        *(_DWORD *)(v21 + 1164) = *(_DWORD *)(v21 + 1164) == 0;
      }
      else
      {
        *(_DWORD *)(v21 + 1160) = *(_DWORD *)(*(_QWORD *)(v21 + 1128) + 12i64 * *(int *)(a2 + 28));
        *(_DWORD *)(*(_QWORD *)(wParam + 840) + 1164i64) = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(wParam + 840)
                                                                                          + 1128i64)
                                                                              + 12i64 * *(int *)(a2 + 28)
                                                                              + 8);
      }
      DlgItem = GetDlgItem(*(HWND *)(wParam + 8), 1226);
      SendMessageW(DlgItem, 0x1030u, wParam, (LPARAM)sub_14009EA20);
      sub_14009E570(wParam);
      break;
    case -5:
      if ( *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 8), 1226) )
      {
        v8 = GetDlgItem(*(HWND *)(wParam + 8), 1226);
        v9 = SendMessageW(v8, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
        if ( v9 != -1 )
        {
          lParam = 4;
          lParam_4 = v9;
          v32 = 0;
          if ( (unsigned int)SendMessageW(v8, 0x104Bu, 0i64, (LPARAM)&lParam) )
          {
            v25[0] = v33;
            sub_140019CD0((_QWORD *)(wParam + 728), &ID, v25);
            pv = 0i64;
            v10 = ID + 3;
            if ( (unsigned __int64)ID[6] >= 8 )
              v10 = (__int64 *)*v10;
            if ( v10 && !(unsigned int)sub_14007F810((__int64)v10, (__int64)&pv) )
            {
              v29 = 0i64;
              v11 = operator new(0x18ui64);
              v12 = v11;
              if ( !v11 )
              {
                v27 = 0i64;
                std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v27);
                pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
                CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
              }
              v28 = (_QWORD **)v11;
              *v11 = v11;
              v11[1] = v11;
              ID = (__int64 *)ILFindLastID((LPCITEMIDLIST)pv);
              v13 = sub_14000BB70((__int64)v12, v12[1], &ID);
              v29 = 1i64;
              v12[1] = v13;
              **((_QWORD **)v13 + 1) = v13;
              v14 = ILClone((LPCITEMIDLIST)pv);
              ILRemoveLastID(v14);
              v15 = (void **)sub_14000B220(&v37, &v28);
              sub_1400D2390(dwRefData, *(void **)(wParam + 8), v14, v15);
              MessagePos = GetMessagePos();
              v25[0] = (__int16)MessagePos;
              v25[1] = SHIWORD(MessagePos);
              v17 = GetKeyState(16) & 0x80;
              v18 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(wParam + 832) + 72i64))(*(_QWORD *)(wParam + 832));
              if ( dwRefData[3] )
                sub_1400D2910((DWORD_PTR)dwRefData, wParam + 80, v25, v18, 0i64, 0, v17);
              CoTaskMemFree(v14);
              CoTaskMemFree(pv);
              sub_1400D22C0(dwRefData);
              v19 = (_QWORD *)*v12;
              *v12 = v12;
              v12[1] = v12;
              if ( v19 != v12 )
              {
                do
                {
                  v20 = (_QWORD *)*v19;
                  j_free(v19);
                  v19 = v20;
                }
                while ( v20 != v12 );
              }
              j_free(v12);
            }
          }
        }
      }
      break;
    case -3:
      if ( *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 8), 1226) )
      {
        v5 = GetDlgItem(*(HWND *)(wParam + 8), 1226);
        v6 = SendMessageW(v5, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
        if ( v6 != -1 )
        {
          lParam = 4;
          lParam_4 = v6;
          v32 = 0;
          if ( (unsigned int)SendMessageW(v5, 0x104Bu, 0i64, (LPARAM)&lParam) )
          {
            v25[0] = v33;
            sub_140019CD0((_QWORD *)(wParam + 728), &ID, v25);
            pv = 0i64;
            v7 = ID + 3;
            if ( (unsigned __int64)ID[6] >= 8 )
              v7 = (__int64 *)*v7;
            if ( v7 && !(unsigned int)sub_14007F810((__int64)v7, (__int64)&pv) )
            {
              (*(void (__fastcall **)(_QWORD, LPVOID, _QWORD, _QWORD))(**(_QWORD **)(wParam + 832) + 64i64))(
                *(_QWORD *)(wParam + 832),
                pv,
                0i64,
                0i64);
              CoTaskMemFree(pv);
            }
          }
        }
      }
      break;
    default:
      if ( v4 == -2 && *(HWND *)a2 == GetDlgItem(*(HWND *)(wParam + 8), 1285) )
        ShellExecuteW(0i64, L"open", (LPCWSTR)(a2 + 136), 0i64, 0i64, 5);
      break;
  }
  return 0i64;
}
// 1400D22C0: using guessed type __int64 __fastcall sub_1400D22C0(_QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400A1C10) ----------------------------------------------------
int __fastcall sub_1400A1C10(__int64 a1, const WCHAR *a2, __int64 *a3)
{
  HANDLE FirstFileW; // rax
  void *v6; // r14
  char v7; // r13
  int v8; // er12
  int v9; // esi
  __int64 v10; // rcx
  WCHAR *cFileName; // rdi
  bool v12; // zf
  int v13; // edx
  char dwFileAttributes; // cl
  const WCHAR *v15; // rsi
  LPITEMIDLIST v16; // rax
  __int64 v17; // rcx
  WCHAR *v18; // rdi
  __int64 v19; // rdi
  char *v20; // rax
  __int64 v21; // rdx
  LPCITEMIDLIST pidl[2]; // [rsp+28h] [rbp-D8h] BYREF
  void *Block[3]; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v26; // [rsp+50h] [rbp-B0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR v28[264]; // [rsp+2B0h] [rbp+1B0h] BYREF
  WCHAR pszDest[264]; // [rsp+4C0h] [rbp+3C0h] BYREF

  pidl[1] = (LPCITEMIDLIST)-2i64;
  PathCombineW(pszDest, a2, L"*");
  FirstFileW = FindFirstFileW(pszDest, &FindFileData);
  v6 = FirstFileW;
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    v7 = 0;
    if ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      v8 = 0;
      while ( 1 )
      {
        if ( v7 )
          goto LABEL_38;
        if ( lstrcmpiW(FindFileData.cFileName, L".") && lstrcmpiW(FindFileData.cFileName, L"..") )
          break;
LABEL_33:
        EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
        if ( *(_DWORD *)(a1 + 1160) )
          v7 = 1;
        LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
        if ( !FindNextFileW(v6, &FindFileData) )
          goto LABEL_38;
      }
      v9 = 0;
      if ( lstrcmpW((LPCWSTR)(a1 + 544), &word_1400EBDE4) )
      {
        if ( *(_DWORD *)(a1 + 1072) )
        {
          v10 = -1i64;
          cFileName = FindFileData.cFileName;
          do
          {
            if ( !v10 )
              break;
            v12 = *cFileName++ == 0;
            --v10;
          }
          while ( !v12 );
          if ( !sub_1400199D0(
                  (__int64)FindFileData.cFileName,
                  (__int64)&FindFileData.cFileName[~v10 - 1],
                  (__int64 *)(a1 + 1088),
                  16) )
            goto LABEL_16;
        }
        else if ( !(unsigned int)sub_140082100((LPCWSTR)(a1 + 544), FindFileData.cFileName, *(_DWORD *)(a1 + 1076) == 0) )
        {
          goto LABEL_16;
        }
      }
      v9 = 1;
LABEL_16:
      v13 = *(_DWORD *)(a1 + 1068);
      dwFileAttributes = FindFileData.dwFileAttributes;
      if ( !v13 || (FindFileData.dwFileAttributes & v13) == v13 )
        v8 = 1;
      if ( v9 && v8 )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
          ++*(_DWORD *)(a1 + 1164);
        else
          ++*(_DWORD *)(a1 + 1168);
        v8 = 0;
        pidl[0] = 0i64;
        v15 = a2;
        PathCombineW(v28, a2, FindFileData.cFileName);
        sub_14007F810((__int64)v28, (__int64)pidl);
        v16 = ILClone(pidl[0]);
        PostMessageW(*(HWND *)(a1 + 16), 0x8001u, (WPARAM)v16, 0i64);
        CoTaskMemFree((LPVOID)pidl[0]);
        dwFileAttributes = FindFileData.dwFileAttributes;
      }
      else
      {
        v8 = 0;
        v15 = a2;
      }
      if ( (dwFileAttributes & 0x10) != 0 )
      {
        PathCombineW(v28, v15, FindFileData.cFileName);
        v26 = 7i64;
        Block[2] = 0i64;
        LOWORD(Block[0]) = 0;
        v17 = -1i64;
        v18 = v28;
        do
        {
          if ( !v17 )
            break;
          v12 = *v18++ == 0;
          --v17;
        }
        while ( !v12 );
        sub_1400099E0(Block, v28, -v17 - 2);
        v19 = *a3;
        v20 = sub_14000A760(*a3, *(_QWORD *)(*a3 + 8), Block);
        v21 = a3[1];
        if ( v21 == 0x666666666666665i64 )
          sub_14002B5F8("list<T> too long");
        a3[1] = v21 + 1;
        *(_QWORD *)(v19 + 8) = v20;
        **((_QWORD **)v20 + 1) = v20;
        if ( v26 >= 8 )
          j_free(Block[0]);
      }
      goto LABEL_33;
    }
LABEL_38:
    LODWORD(FirstFileW) = FindClose(v6);
  }
  return (int)FirstFileW;
}

//----- (00000001400A1F50) ----------------------------------------------------
void __fastcall sub_1400A1F50(__int64 a1, const WCHAR *a2)
{
  _QWORD *v4; // rax
  bool v5; // bl
  void **v6; // rdi
  void **v7; // rbx
  void **v8; // rsi
  void **v9; // rbx
  WPARAM *v10; // rdx
  void **v11; // rbx
  void **v12; // rsi
  char *v13; // [rsp+20h] [rbp-88h] BYREF
  void *Block[3]; // [rsp+28h] [rbp-80h] BYREF
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-68h] BYREF
  WPARAM wParam[3]; // [rsp+60h] [rbp-48h] BYREF
  unsigned __int64 v17; // [rsp+78h] [rbp-30h]

  pExceptionObject[3] = -2i64;
  SendMessageW(*(HWND *)(a1 + 16), 0x8003u, (WPARAM)a2, 0i64);
  Block[1] = 0i64;
  v4 = operator new(0x38ui64);
  if ( !v4 )
  {
    v13 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v13);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v4;
  *v4 = v4;
  v4[1] = v4;
  sub_1400A1C10(a1, a2, (__int64 *)Block);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
  v5 = *(_DWORD *)(a1 + 1160) != 0;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 1120));
  if ( v5 )
  {
    v6 = (void **)Block[0];
    v7 = *(void ***)Block[0];
    *(_QWORD *)Block[0] = Block[0];
    v6[1] = v6;
    if ( v7 != v6 )
    {
      do
      {
        v8 = (void **)*v7;
        if ( (unsigned __int64)v7[5] >= 8 )
          j_free(v7[2]);
        v7[5] = (void *)7;
        v7[4] = 0i64;
        *((_WORD *)v7 + 8) = 0;
        j_free(v7);
        v7 = v8;
      }
      while ( v8 != v6 );
    }
  }
  else
  {
    v6 = (void **)Block[0];
    if ( *(_DWORD *)(a1 + 1080) )
    {
      v9 = *(void ***)Block[0];
      if ( *(void **)Block[0] != Block[0] )
      {
        do
        {
          v17 = 7i64;
          wParam[2] = 0i64;
          LOWORD(wParam[0]) = 0;
          sub_140009610(wParam, v9 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
          v10 = wParam;
          if ( v17 >= 8 )
            v10 = (WPARAM *)wParam[0];
          sub_1400A1F50(a1, (const WCHAR *)v10);
          if ( v17 >= 8 )
            j_free((void *)wParam[0]);
          v9 = (void **)*v9;
        }
        while ( v9 != v6 );
      }
    }
    v11 = (void **)*v6;
    *v6 = v6;
    v6[1] = v6;
    if ( v11 != v6 )
    {
      do
      {
        v12 = (void **)*v11;
        if ( (unsigned __int64)v11[5] >= 8 )
          j_free(v11[2]);
        v11[5] = (void *)7;
        v11[4] = 0i64;
        *((_WORD *)v11 + 8) = 0;
        j_free(v11);
        v11 = v12;
      }
      while ( v12 != v6 );
    }
  }
  j_free(v6);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400A2180) ----------------------------------------------------
__int64 __fastcall sub_1400A2180(__int64 a1)
{
  __int64 *v2; // rcx
  __int64 v3; // rdx
  __int64 result; // rax

  *(_QWORD *)(a1 + 1164) = 0i64;
  if ( lstrcmpW((LPCWSTR)(a1 + 544), &word_1400EBD74) && *(_DWORD *)(a1 + 1072) )
  {
    v2 = (__int64 *)(a1 + 1088);
    v3 = a1 + 544;
    if ( *(_DWORD *)(a1 + 1076) )
      sub_14000C290(v2, v3, 0x100u);
    else
      sub_14000C290(v2, v3, 1u);
  }
  sub_1400A1F50(a1, (const WCHAR *)(a1 + 24));
  SendMessageW(
    *(HWND *)(a1 + 16),
    0x8002u,
    0i64,
    *(unsigned __int16 *)(a1 + 1164) | (unsigned __int64)(*(unsigned __int16 *)(a1 + 1168) << 16));
  result = (unsigned int)_InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
  if ( !(_DWORD)result )
    return (**(__int64 (__fastcall ***)(__int64, __int64))a1)(a1, 1i64);
  return result;
}
// 1400A2180: could not find valid save-restore pair for rbp

//----- (00000001400A2260) ----------------------------------------------------
__int64 __fastcall sub_1400A2260(LPVOID lpThreadParameter)
{
  sub_1400A2180((__int64)lpThreadParameter);
  return 0i64;
}

//----- (00000001400A2280) ----------------------------------------------------
void __fastcall sub_1400A2280(__int64 a1)
{
  HWND DlgItem; // rax
  HWND v3; // rax
  _QWORD **v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rdi
  HWND v7; // rax
  int v8; // er12
  int v9; // ebx
  int v10; // er13
  __int64 v11; // rdx
  WCHAR *v12; // rcx
  WCHAR v13; // ax
  int v14; // edi
  void *v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  const WCHAR *v19; // rdx
  __int64 v20; // rcx
  WCHAR *v21; // rdi
  bool v22; // zf
  __int64 v23; // rdi
  __int64 *v24; // rax
  __int64 v25; // rbx
  char *v26; // rdx
  __int64 v27; // rax
  HWND v28; // rbx
  HWND v29; // rdi
  __int64 v30; // rdx
  const WCHAR *v31; // rdx
  __int64 v32; // rcx
  WCHAR *v33; // rdi
  __int64 v34; // rax
  __int64 v35; // rcx
  HWND v36; // r12
  HWND v37; // r13
  __int64 v38; // r14
  __int64 v39; // rdx
  __int64 v40; // rax
  __int64 v41; // rbx
  __int64 v42; // rdi
  __int64 v43; // rax
  __int64 v44; // rcx
  WCHAR *v45; // rdi
  unsigned __int64 v46; // rdi
  int v47; // eax
  HANDLE Thread; // rax
  __int64 v49; // rbx
  __int64 v50[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v51[2]; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v52[2]; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v53[2]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v54[2]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v55; // [rsp+98h] [rbp-70h] BYREF
  __int64 v56; // [rsp+A0h] [rbp-68h]
  __int16 Src[8]; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v58; // [rsp+B8h] [rbp-50h]
  __int64 v59; // [rsp+C0h] [rbp-48h]
  __int64 v60; // [rsp+D0h] [rbp-38h]
  LPARAM v61[7]; // [rsp+D8h] [rbp-30h] BYREF
  LPARAM lParam[7]; // [rsp+110h] [rbp+8h] BYREF
  __int64 v63; // [rsp+148h] [rbp+40h] BYREF
  void *v64[3]; // [rsp+158h] [rbp+50h] BYREF
  unsigned __int64 v65; // [rsp+170h] [rbp+68h]
  void *v66[3]; // [rsp+180h] [rbp+78h] BYREF
  unsigned __int64 v67; // [rsp+198h] [rbp+90h]
  void *Block[3]; // [rsp+1A8h] [rbp+A0h] BYREF
  unsigned __int64 v69; // [rsp+1C0h] [rbp+B8h]
  WCHAR pszPath[264]; // [rsp+1D8h] [rbp+D0h] BYREF
  WCHAR Buffer[64]; // [rsp+3E8h] [rbp+2E0h] BYREF
  WCHAR String[264]; // [rsp+468h] [rbp+360h] BYREF
  WCHAR v74[264]; // [rsp+678h] [rbp+570h] BYREF
  __int16 v75[264]; // [rsp+888h] [rbp+780h] BYREF

  v60 = -2i64;
  if ( *(_DWORD *)(a1 + 624) )
  {
    *(_DWORD *)(a1 + 628) = 1;
    v49 = *(_QWORD *)(a1 + 696);
    if ( v49 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(v49 + 1120));
      *(_DWORD *)(v49 + 1160) = 1;
      LeaveCriticalSection((LPCRITICAL_SECTION)(v49 + 1120));
    }
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1285);
    ShowWindow(DlgItem, 0);
    v3 = GetDlgItem(*(HWND *)(a1 + 8), 1250);
    ShowWindow(v3, 5);
    v4 = *(_QWORD ***)(a1 + 704);
    v5 = *v4;
    *v4 = v4;
    *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8i64) = *(_QWORD *)(a1 + 704);
    *(_QWORD *)(a1 + 712) = 0i64;
    if ( v5 != *(_QWORD **)(a1 + 704) )
    {
      do
      {
        v6 = (_QWORD *)*v5;
        j_free(v5);
        v5 = v6;
      }
      while ( v6 != *(_QWORD **)(a1 + 704) );
    }
    sub_140018CF0(a1 + 736);
    sub_140018C50((_QWORD *)(a1 + 728), 8i64);
    v7 = GetDlgItem(*(HWND *)(a1 + 8), 1226);
    SendMessageW(v7, 0x1009u, 0i64, 0i64);
    GetDlgItemTextW(*(HWND *)(a1 + 8), 1224, String, 260);
    PathRemoveBlanksW(String);
    GetDlgItemTextW(*(HWND *)(a1 + 8), 1225, pszPath, 260);
    PathRemoveBlanksW(pszPath);
    v8 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1249) == 1;
    v9 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1281) == 1;
    v10 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1282) == 1;
    if ( !v9 && lstrlenW(pszPath) > 0 && pszPath[0] != 42 && pszPath[lstrlenW(pszPath) - 1] != 42 )
    {
      sub_140001000((wchar_t *)v75, 0x104ui64, L"*%s*", pszPath);
      v11 = 260i64;
      v12 = pszPath;
      while ( v11 != -2147483386 )
      {
        v13 = v12[856];
        if ( !v13 )
          break;
        *v12++ = v13;
        if ( !--v11 )
        {
          --v12;
          break;
        }
      }
      *v12 = 0;
    }
    v14 = 0;
    if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1060) == 1 )
      v14 = 32;
    if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1061) == 1 )
      v14 |= 2u;
    if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1062) == 1 )
      v14 |= 1u;
    if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1059) == 1 )
      v14 |= 4u;
    v15 = operator new(0x498ui64);
    if ( v15 )
      v16 = sub_14009F2E0((__int64)v15, *(_QWORD *)(a1 + 8), (__int64)String, (__int64)pszPath, v14, v9, v10, v8);
    else
      v16 = 0i64;
    *(_QWORD *)(a1 + 696) = v16;
    _InterlockedIncrement((volatile signed __int32 *)(v16 + 8));
    v17 = *(_QWORD *)(a1 + 840);
    if ( !*(_QWORD *)(v17 + 1072) )
      goto LABEL_29;
    v18 = *(_QWORD *)(v17 + 1064);
    v19 = (const WCHAR *)(*(_QWORD *)v18 + 16i64);
    if ( *(_QWORD *)(*(_QWORD *)v18 + 40i64) >= 8ui64 )
      v19 = *(const WCHAR **)v19;
    if ( lstrcmpW(String, v19) )
    {
LABEL_29:
      v69 = 7i64;
      Block[2] = 0i64;
      LOWORD(Block[0]) = 0;
      v20 = -1i64;
      v21 = String;
      do
      {
        if ( !v20 )
          break;
        v22 = *v21++ == 0;
        --v20;
      }
      while ( !v22 );
      sub_1400099E0(Block, String, -v20 - 2);
      v23 = *(_QWORD *)(a1 + 840);
      v24 = *(__int64 **)(v23 + 1064);
      v25 = *v24;
      v26 = sub_14000A760(*v24, *(_QWORD *)(*v24 + 8), Block);
      v27 = *(_QWORD *)(v23 + 1072);
      if ( v27 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(v23 + 1072) = v27 + 1;
      *(_QWORD *)(v25 + 8) = v26;
      **((_QWORD **)v26 + 1) = v26;
      if ( v69 >= 8 )
        j_free(Block[0]);
      v28 = GetDlgItem(*(HWND *)(a1 + 8), 1224);
      v29 = (HWND)SendMessageW(v28, 0x406u, 0i64, 0i64);
      LODWORD(lParam[0]) = 1;
      lParam[1] = 0i64;
      lParam[2] = (LPARAM)String;
      SendMessageW(v28, 0x40Bu, 0i64, (LPARAM)lParam);
      SendMessageW(v29, 0x14Eu, 0i64, 0i64);
    }
    v30 = *(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64);
    if ( !*(_QWORD *)(v30 + 32) )
      goto LABEL_41;
    v31 = *(const WCHAR **)(v30 + 16);
    if ( *((_QWORD *)v31 + 3) >= 8ui64 )
      v31 = *(const WCHAR **)v31;
    if ( lstrcmpW(pszPath, v31) )
    {
LABEL_41:
      GetDlgItemTextW(*(HWND *)(a1 + 8), 1225, v74, 260);
      v67 = 7i64;
      v66[2] = 0i64;
      LOWORD(v66[0]) = 0;
      v32 = -1i64;
      v33 = v74;
      do
      {
        if ( !v32 )
          break;
        v22 = *v33++ == 0;
        --v32;
      }
      while ( !v22 );
      sub_1400099E0(v66, v74, -v32 - 2);
      v59 = 7i64;
      v58 = 0i64;
      Src[0] = 0;
      sub_140009610(Src, v66, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v34 = *(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64);
      v53[0] = v34;
      v53[1] = 0i64;
      v35 = 0i64;
      if ( *(_QWORD *)(v34 + 32) )
        v35 = *(_QWORD *)(v34 + 16);
      v54[0] = v34;
      v54[1] = v35;
      sub_140019210(&v55, v54, v53, Src);
      v36 = GetDlgItem(*(HWND *)(a1 + 8), 1225);
      v37 = (HWND)SendMessageW(v36, 0x406u, 0i64, 0i64);
      SendMessageW(v37, 0x14Eu, 0xFFFFFFFFFFFFFFFFui64, 0i64);
      v38 = v56;
      if ( v56 )
      {
        v39 = *(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64);
        v40 = 0i64;
        if ( *(_QWORD *)(v39 + 32) )
          v40 = *(_QWORD *)(v39 + 16);
        v41 = v55;
        v50[0] = v55;
        v50[1] = v56;
        v51[0] = v39;
        v51[1] = v40;
        v42 = sub_140019B70((__int64)v50, (__int64)v51);
        v43 = sub_140019B70((__int64)v50, (__int64)v50);
        SendMessageW(v36, 0x144u, (v43 - v42) / 40, 0i64);
        v52[0] = v41;
        v52[1] = v38;
        sub_140018A90(*(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64), &v63, v52);
      }
      v65 = 7i64;
      v64[2] = 0i64;
      LOWORD(v64[0]) = 0;
      v44 = -1i64;
      v45 = v74;
      do
      {
        if ( !v44 )
          break;
        v22 = *v45++ == 0;
        --v44;
      }
      while ( !v22 );
      sub_1400099E0(v64, v74, -v44 - 2);
      sub_1400189C0(*(__int64 **)(*(_QWORD *)(a1 + 840) + 1088i64), v64);
      if ( v65 >= 8 )
        j_free(v64[0]);
      LODWORD(v61[0]) = 1;
      v61[1] = 0i64;
      v61[2] = (LPARAM)v74;
      SendMessageW(v36, 0x40Bu, 0i64, (LPARAM)v61);
      v46 = (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 840) + 1088i64) + 8i64)
           - **(_QWORD **)(*(_QWORD *)(a1 + 840) + 1088i64))
          / 40i64;
      if ( (int)SendMessageW(v37, 0x146u, 0i64, 0i64) > v46 )
      {
        v47 = SendMessageW(v37, 0x146u, 0i64, 0i64);
        SendMessageW(v36, 0x144u, v47 - 1, 0i64);
      }
      if ( v67 >= 8 )
        j_free(v66[0]);
    }
    GetDlgItemTextW(*(HWND *)(a1 + 8), 1227, (LPWSTR)(a1 + 632), 32);
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0x849u, Buffer, 64);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1227, Buffer);
    *(_DWORD *)(a1 + 624) = 1;
    Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400A2260, *(LPVOID *)(a1 + 696), 0, 0i64);
    CloseHandle(Thread);
  }
}
// 1400A24C9: conditional instruction was optimized away because rdx.8!=0
// 140019210: using guessed type __int64 __fastcall sub_140019210(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400F0108: using guessed type wchar_t aS_1[5];
// 1400A2280: using guessed type wchar_t var_240[264];

//----- (00000001400A2B00) ----------------------------------------------------
__int64 __fastcall sub_1400A2B00(__int64 a1, __int16 a2)
{
  HWND v3; // r11
  const ITEMIDLIST *v4; // rax
  ITEMIDLIST *v5; // rdi
  struct _browseinfoW bi; // [rsp+20h] [rbp-888h] BYREF
  WCHAR String[264]; // [rsp+60h] [rbp-848h] BYREF
  WCHAR pszBuf[264]; // [rsp+270h] [rbp-638h] BYREF
  WCHAR Buffer[256]; // [rsp+480h] [rbp-428h] BYREF
  char v11; // [rsp+680h] [rbp-228h] BYREF

  switch ( a2 )
  {
    case 2:
      goto LABEL_8;
    case 1227:
      sub_1400A2280(a1);
      return 0i64;
    case 1228:
LABEL_8:
      DestroyWindow(*(HWND *)(a1 + 8));
      return 0i64;
  }
  if ( a2 != 1229 )
    return 0i64;
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x84Du, Buffer, 256);
  GetDlgItemTextW(*(HWND *)(a1 + 8), 1224, String, 260);
  v3 = *(HWND *)(a1 + 8);
  bi.pszDisplayName = (LPWSTR)&v11;
  bi.lpszTitle = Buffer;
  bi.hwndOwner = v3;
  bi.lpfn = (BFFCALLBACK)sub_14009E340;
  bi.pidlRoot = 0i64;
  bi.lParam = (LPARAM)String;
  bi.ulFlags = 65;
  v4 = SHBrowseForFolderW(&bi);
  v5 = (ITEMIDLIST *)v4;
  if ( v4 )
  {
    sub_14007E270(v4, pszBuf, 0x8000u);
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1224, pszBuf);
    CoTaskMemFree(v5);
  }
  return 0i64;
}

//----- (00000001400A2CA0) ----------------------------------------------------
HWND __fastcall sub_1400A2CA0(__int64 a1)
{
  HWND DlgItem; // rbx

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1184);
  EnableWindow(DlgItem, 1);
  return SetFocus(DlgItem);
}

//----- (00000001400A2CE0) ----------------------------------------------------
BOOL __fastcall sub_1400A2CE0(__int64 a1)
{
  HWND DlgItem; // rax

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1184);
  return EnableWindow(DlgItem, 0);
}

//----- (00000001400A2D10) ----------------------------------------------------
__int64 __fastcall sub_1400A2D10(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400A2D30) ----------------------------------------------------
__int64 __fastcall sub_1400A2D30(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 80);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 80);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400A2DD0) ----------------------------------------------------
__int64 *sub_1400A2DD0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012F41C;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"RenameTab" - (char *)&unk_14012F41C);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012F408 = 0;
  qword_14012F400 = (__int64)&CRenameTabDialogPersistentSettings::`vftable';
  result = &qword_14012F400;
  byte_14012F61C = 1;
  return result;
}
// 1400A2E17: conditional instruction was optimized away because rdx.8!=0
// 1400F0768: using guessed type wchar_t aRenametab_0[10];
// 1400F7548: using guessed type void *CRenameTabDialogPersistentSettings::`vftable';
// 14012F400: using guessed type __int64 qword_14012F400;
// 14012F408: using guessed type int dword_14012F408;
// 14012F61C: using guessed type char byte_14012F61C;

//----- (00000001400A2E50) ----------------------------------------------------
__int64 __fastcall sub_1400A2E50(__int64 a1)
{
  HWND DlgItem; // rbx
  __int64 v3; // rax
  _DWORD *v4; // rax
  HWND v5; // rbx
  HWND Parent; // rax
  void *Block[5]; // [rsp+40h] [rbp-38h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1184);
  v3 = (*(__int64 (__fastcall **)(_QWORD, void **, _QWORD))(**(_QWORD **)(a1 + 88) + 16i64))(
         *(_QWORD *)(a1 + 88),
         Block,
         *(unsigned int *)(a1 + 96));
  if ( *(_QWORD *)(v3 + 24) >= 8ui64 )
    v3 = *(_QWORD *)v3;
  SetWindowTextW(DlgItem, (LPCWSTR)v3);
  if ( Block[3] >= (void *)8 )
    j_free(Block[0]);
  CheckDlgButton(*(HWND *)(a1 + 8), 1074, 1u);
  EnableWindow(DlgItem, 1);
  SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
  SetFocus(DlgItem);
  v4 = *(_DWORD **)(a1 + 80);
  v5 = *(HWND *)(a1 + 8);
  if ( v4[2] )
  {
    SetWindowPos(v5, 0i64, v4[3], v4[4], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(*(HWND *)(a1 + 8));
    sub_140081E00(Parent, v5);
  }
  return 0i64;
}

//----- (00000001400A2F70) ----------------------------------------------------
__int64 *sub_1400A2F70()
{
  if ( (dword_140130A38 & 1) == 0 )
  {
    dword_140130A38 |= 1u;
    sub_1400A2DD0();
    atexit(sub_1400E1FC0);
  }
  return &qword_14012F400;
}
// 14012F400: using guessed type __int64 qword_14012F400;
// 140130A38: using guessed type int dword_140130A38;

//----- (00000001400A2FB0) ----------------------------------------------------
__int64 __fastcall sub_1400A2FB0(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  HINSTANCE v4; // rax
  int v6; // eax

  v4 = hInstance;
  *(_DWORD *)(a1 + 24) = 213;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CRenameTabDialog::`vftable';
  v6 = dword_140130A38;
  *(_BYTE *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 96) = a3;
  *(_QWORD *)(a1 + 88) = a4;
  if ( (v6 & 1) == 0 )
  {
    dword_140130A38 = v6 | 1;
    sub_1400A2DD0();
    atexit(sub_1400E1FC0);
  }
  *(_QWORD *)(a1 + 80) = &qword_14012F400;
  return a1;
}
// 1400F74D8: using guessed type void *CRenameTabDialog::`vftable';
// 14012F400: using guessed type __int64 qword_14012F400;
// 140130A38: using guessed type int dword_140130A38;

//----- (00000001400A3030) ----------------------------------------------------
BOOL __fastcall sub_1400A3030(__int64 a1)
{
  UINT v2; // ebp
  __int64 v3; // rax
  ITEMIDLIST *v4; // rdi
  HWND DlgItem; // rax
  __int64 v6; // rcx
  WCHAR *v7; // rdi
  bool v8; // zf
  __int16 Src[8]; // [rsp+20h] [rbp-258h] BYREF
  __int64 v11; // [rsp+30h] [rbp-248h]
  __int64 v12; // [rsp+38h] [rbp-240h]
  WCHAR String[264]; // [rsp+50h] [rbp-228h] BYREF

  v2 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1183);
  if ( v2 == 1 )
  {
    v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 8i64))(*(_QWORD *)(a1 + 88));
    v4 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 112i64))(v3);
    sub_14007E270(v4, String, 1u);
    CoTaskMemFree(v4);
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1184);
    GetWindowTextW(DlgItem, String, 260);
  }
  if ( lstrlenW(String) > 0 )
  {
    v6 = -1i64;
    v7 = String;
    do
    {
      if ( !v6 )
        break;
      v8 = *v7++ == 0;
      --v6;
    }
    while ( !v8 );
    v12 = 7i64;
    v11 = 0i64;
    Src[0] = 0;
    sub_1400099E0(Src, String, -v6 - 2);
    (*(void (__fastcall **)(_QWORD, _QWORD, __int16 *, bool))(**(_QWORD **)(a1 + 88) + 24i64))(
      *(_QWORD *)(a1 + 88),
      *(unsigned int *)(a1 + 96),
      Src,
      v2 != 1);
  }
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (00000001400A3170) ----------------------------------------------------
__int64 __fastcall sub_1400A3170(__int64 a1, __int16 a2)
{
  HWND v2; // rax
  HWND DlgItem; // rbx

  switch ( a2 )
  {
    case 1:
      sub_1400A3030(a1);
      break;
    case 2:
      EndDialog(*(HWND *)(a1 + 8), 0i64);
      return 0i64;
    case 1074:
      DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1184);
      EnableWindow(DlgItem, 1);
      SetFocus(DlgItem);
      return 0i64;
    case 1183:
      v2 = GetDlgItem(*(HWND *)(a1 + 8), 1184);
      EnableWindow(v2, 0);
      return 0i64;
  }
  return 0i64;
}

//----- (00000001400A3210) ----------------------------------------------------
LSTATUS __fastcall sub_1400A3210(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD cbData; // [rsp+50h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+58h] [rbp+20h] BYREF

  result = RegOpenKeyExW(a2, L"OrganizeBookmarks", 0, 0x20019u, &hKey);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(hKey, L"Position", 0i64, 0i64, (LPBYTE)(a1 + 63084), &cbData) )
      *(_DWORD *)(a1 + 63080) = 1;
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A32A0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A32A0(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD cbData; // [rsp+50h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+58h] [rbp+20h] BYREF

  result = RegOpenKeyExW(a2, L"DisplayColors", 0, 0x20019u, &hKey);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(hKey, L"Position", 0i64, 0i64, (LPBYTE)(a1 + 63096), &cbData) )
      *(_DWORD *)(a1 + 63092) = 1;
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A3330) ----------------------------------------------------
LSTATUS __fastcall sub_1400A3330(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD cbData; // [rsp+50h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+58h] [rbp+20h] BYREF

  result = RegOpenKeyExW(a2, L"AddBookmark", 0, 0x20019u, &hKey);
  if ( !result )
  {
    cbData = 8;
    if ( !RegQueryValueExW(hKey, L"Position", 0i64, 0i64, (LPBYTE)(a1 + 63072), &cbData) )
      *(_DWORD *)(a1 + 63068) = 1;
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A33C0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A33C0(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [rsp+70h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+78h] [rbp+20h] BYREF

  result = RegCreateKeyExW(a2, L"OrganizeBookmarks", 0, 0i64, 0, 0x20006u, 0i64, &hKey, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 63080) )
      RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)(a1 + 63084), 8u);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A3460) ----------------------------------------------------
LSTATUS __fastcall sub_1400A3460(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [rsp+70h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+78h] [rbp+20h] BYREF

  result = RegCreateKeyExW(a2, L"DisplayColors", 0, 0i64, 0, 0x20006u, 0i64, &hKey, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 63092) )
      RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)(a1 + 63096), 8u);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A3500) ----------------------------------------------------
LSTATUS __fastcall sub_1400A3500(__int64 a1, HKEY a2)
{
  LSTATUS result; // eax
  DWORD dwDisposition; // [rsp+70h] [rbp+18h] BYREF
  HKEY hKey; // [rsp+78h] [rbp+20h] BYREF

  result = RegCreateKeyExW(a2, L"AddBookmark", 0, 0i64, 0, 0x20006u, 0i64, &hKey, &dwDisposition);
  if ( !result )
  {
    if ( *(_DWORD *)(a1 + 63068) )
      RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)(a1 + 63072), 8u);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A35A0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A35A0(__int64 a1, HKEY a2, __int64 a3, int a4)
{
  HKEY v6; // rbx
  int v7; // eax
  HKEY v8; // rdi
  int v9; // eax
  LSTATUS result; // eax
  __int64 v11; // r8
  HKEY hKey; // [rsp+50h] [rbp-A8h] BYREF
  int v13; // [rsp+58h] [rbp-A0h]
  BYTE Data[4]; // [rsp+60h] [rbp-98h] BYREF
  DWORD dwDisposition; // [rsp+68h] [rbp-90h] BYREF
  __int64 v16; // [rsp+70h] [rbp-88h]
  WCHAR SubKey[32]; // [rsp+80h] [rbp-78h] BYREF

  v16 = a1;
  v13 = a4;
  itow_s(a4, SubKey, 0x20ui64, 10);
  RegCreateKeyExW(a2, SubKey, 0, 0i64, 0, 0x20006u, 0i64, &hKey, &dwDisposition);
  v6 = hKey;
  v7 = lstrlenW((LPCWSTR)a3);
  RegSetValueExW(v6, L"Name", 0, 1u, (const BYTE *)a3, 2 * v7);
  v8 = hKey;
  v9 = lstrlenW((LPCWSTR)(a3 + 1024));
  RegSetValueExW(v8, L"Command", 0, 1u, (const BYTE *)(a3 + 1024), 2 * v9);
  *(_DWORD *)Data = *(_DWORD *)(a3 + 2048);
  RegSetValueExW(hKey, L"ShowNameOnToolbar", 0, 4u, Data, 4u);
  result = RegCloseKey(hKey);
  v11 = *(_QWORD *)(a3 + 2056);
  if ( v11 )
    return sub_1400A35A0(v16, a2, v11, v13 + 1);
  return result;
}

//----- (00000001400A3720) ----------------------------------------------------
LSTATUS __fastcall sub_1400A3720(__int64 a1)
{
  LSTATUS result; // eax
  __int64 v3; // r8
  DWORD dwDisposition; // [rsp+68h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+70h] [rbp+18h] BYREF

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ApplicationToolbar");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\ApplicationToolbar",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    v3 = *(_QWORD *)(a1 + 62104);
    if ( v3 )
      sub_1400A35A0(a1, hKey, v3, 0);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A37C0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A37C0(__int64 a1)
{
  LSTATUS result; // eax
  HWND v3; // rcx
  HKEY v4; // rdi
  int v5; // eax
  int v6; // eax
  HWND v7; // rcx
  int v8; // eax
  HWND v9; // rcx
  int v10; // eax
  HWND v11; // rcx
  HWND v12; // rcx
  BYTE Data[4]; // [rsp+50h] [rbp-B0h] BYREF
  HKEY hKey; // [rsp+58h] [rbp-A8h] BYREF
  BYTE v15[4]; // [rsp+60h] [rbp-A0h] BYREF
  BYTE v16[4]; // [rsp+64h] [rbp-9Ch] BYREF
  BYTE v17[4]; // [rsp+68h] [rbp-98h] BYREF
  DWORD dwDisposition; // [rsp+6Ch] [rbp-94h] BYREF
  WPARAM wParam; // [rsp+70h] [rbp-90h] BYREF
  LPARAM lParam[3]; // [rsp+78h] [rbp-88h] BYREF
  WINDOWPLACEMENT wndpl; // [rsp+90h] [rbp-70h] BYREF
  BYTE pv[96]; // [rsp+C0h] [rbp-40h] BYREF

  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Settings",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    v3 = *(HWND *)(a1 + 104);
    wndpl.length = 44;
    GetWindowPlacement(v3, &wndpl);
    RegSetValueExW(hKey, L"Position", 0, 3u, (const BYTE *)&wndpl, 0x2Cu);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 7056);
    RegSetValueExW(hKey, L"LastSelectedTab", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60944);
    RegSetValueExW(hKey, L"ShowExtensions", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60744);
    RegSetValueExW(hKey, L"ShowStatusBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60748);
    RegSetValueExW(hKey, L"ShowFolders", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60752);
    RegSetValueExW(hKey, L"ShowAddressBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60760);
    RegSetValueExW(hKey, L"ShowToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60764);
    RegSetValueExW(hKey, L"ShowBookmarksToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60768);
    RegSetValueExW(hKey, L"ShowDrivesToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60772);
    RegSetValueExW(hKey, L"ShowApplicationToolbar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60784);
    RegSetValueExW(hKey, L"ShowFullTitlePath", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60788);
    RegSetValueExW(hKey, L"AlwaysOpenNewTab", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 7044);
    RegSetValueExW(hKey, L"TreeViewWidth", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60960);
    RegSetValueExW(hKey, L"ShowFriendlyDates", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60756);
    RegSetValueExW(hKey, L"ShowDisplayWindow", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60792);
    RegSetValueExW(hKey, L"ShowFolderSizes", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60796);
    RegSetValueExW(hKey, L"DisableFolderSizesNetworkRemovable", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60920);
    RegSetValueExW(hKey, L"StartupMode", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60804);
    RegSetValueExW(hKey, L"NextToCurrent", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60808);
    RegSetValueExW(hKey, L"ConfirmCloseTabs", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60928);
    RegSetValueExW(hKey, L"ShowInfoTips", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60932);
    RegSetValueExW(hKey, L"InfoTipType", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60812);
    RegSetValueExW(hKey, L"TreeViewDelayEnabled", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60820);
    RegSetValueExW(hKey, L"LockToolbars", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60824);
    RegSetValueExW(hKey, L"ExtendTabControl", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60828);
    RegSetValueExW(hKey, L"UseFullRowSelect", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60840);
    RegSetValueExW(hKey, L"ShowFilePreviews", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60924);
    RegSetValueExW(hKey, L"ReplaceExplorerMode", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60832);
    RegSetValueExW(hKey, L"ShowUserNameTitleBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60852);
    RegSetValueExW(hKey, L"AllowMultipleInstances", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60844);
    RegSetValueExW(hKey, L"OneClickActivate", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60848);
    RegSetValueExW(hKey, L"OneClickActivateHoverTime", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60856);
    RegSetValueExW(hKey, L"ForceSameTabWidth", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60860);
    RegSetValueExW(hKey, L"DoubleClickTabClose", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60864);
    RegSetValueExW(hKey, L"HandleZipFiles", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60868);
    RegSetValueExW(hKey, L"InsertSorted", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60836);
    RegSetValueExW(hKey, L"ShowPrivilegeLevelInTitleBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60776);
    RegSetValueExW(hKey, L"AlwaysShowTabBar", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60876);
    RegSetValueExW(hKey, L"CheckBoxSelection", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60880);
    RegSetValueExW(hKey, L"ForceSize", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60916);
    RegSetValueExW(hKey, L"SizeDisplayFormat", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60884);
    RegSetValueExW(hKey, L"CloseMainWindowOnTabClose", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60888);
    RegSetValueExW(hKey, L"ShowTabBarAtBottom", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60872);
    RegSetValueExW(hKey, L"OverwriteExistingFilesConfirmation", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60908);
    RegSetValueExW(hKey, L"LargeToolbarIcons", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60912);
    RegSetValueExW(hKey, L"PlayNavigationSound", 0, 4u, Data, 4u);
    v4 = hKey;
    v5 = lstrlenW((LPCWSTR)(a1 + 5960));
    RegSetValueExW(v4, L"NewTabDirectory", 0, 1u, (const BYTE *)(a1 + 5960), 2 * v5);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 7000);
    RegSetValueExW(hKey, L"Language", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60940);
    RegSetValueExW(hKey, L"ShowHiddenGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60936);
    RegSetValueExW(hKey, L"ViewModeGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60964);
    RegSetValueExW(hKey, L"ShowGridlinesGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60948);
    RegSetValueExW(hKey, L"ShowInGroupsGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60952);
    RegSetValueExW(hKey, L"AutoArrangeGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60956);
    RegSetValueExW(hKey, L"SortAscendingGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60968);
    RegSetValueExW(hKey, L"HideSystemFilesGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60972);
    RegSetValueExW(hKey, L"HideLinkExtensionGlobal", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60892);
    RegSetValueExW(hKey, L"ShowTaskbarThumbnails", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60900);
    RegSetValueExW(hKey, L"SynchronizeTreeview", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 60904);
    RegSetValueExW(hKey, L"TVAutoExpandSelected", 0, 4u, Data, 4u);
    *(_DWORD *)Data = *(_DWORD *)(a1 + 7012);
    RegSetValueExW(hKey, L"DisplayWindowHeight", 0, 4u, Data, 4u);
    v6 = SendMessageW(*(HWND *)(a1 + 128), 0x806Bu, 0i64, 0i64);
    v7 = *(HWND *)(a1 + 128);
    *(_DWORD *)v17 = v6;
    v8 = SendMessageW(v7, 0x8067u, 0i64, 0i64);
    v9 = *(HWND *)(a1 + 128);
    *(_DWORD *)v15 = v8;
    v10 = SendMessageW(v9, 0x8071u, 0i64, 0i64);
    v11 = *(HWND *)(a1 + 128);
    *(_DWORD *)v16 = v10;
    SendMessageW(v11, 0x806Fu, (WPARAM)&wParam, 0i64);
    RegSetValueExW(hKey, L"DisplayCentreColor", 0, 3u, v17, 4u);
    RegSetValueExW(hKey, L"DisplaySurroundColor", 0, 3u, v15, 4u);
    RegSetValueExW(hKey, L"DisplayTextColor", 0, 3u, v16, 4u);
    GetObjectW((HANDLE)wParam, 92, pv);
    RegSetValueExW(hKey, L"DisplayFont", 0, 3u, pv, 0x5Cu);
    v12 = *(HWND *)(a1 + 176);
    lParam[1] = (LPARAM)L"Software\\Explorer++\\Settings";
    lParam[0] = -2147483647i64;
    lParam[2] = (LPARAM)L"ToolbarState";
    SendMessageW(v12, 0x44Cu, 1ui64, (LPARAM)lParam);
    RegCloseKey(hKey);
    return 0;
  }
  return result;
}
// 1400F1380: using guessed type wchar_t aSoftwareExplor_5[29];
// 1400F13C0: using guessed type wchar_t aToolbarstate_1[13];

//----- (00000001400A4710) ----------------------------------------------------
__int64 sub_1400A4710()
{
  unsigned int Data; // [rsp+40h] [rbp+8h] BYREF
  DWORD cbData; // [rsp+48h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+50h] [rbp+18h] BYREF

  Data = 1;
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &hKey) )
  {
    cbData = 4;
    RegQueryValueExW(hKey, L"AllowMultipleInstances", 0i64, 0i64, (LPBYTE)&Data, &cbData);
    RegCloseKey(hKey);
  }
  return Data;
}

//----- (00000001400A47A0) ----------------------------------------------------
__int64 __fastcall sub_1400A47A0(LPBYTE lpData, HKEY *a2)
{
  HKEY v3; // rcx
  unsigned int v4; // ebx
  DWORD cbData; // [rsp+50h] [rbp+18h] BYREF

  v3 = *a2;
  v4 = 0;
  cbData = 44;
  RegQueryValueExW(v3, L"Position", 0i64, 0i64, lpData, &cbData);
  if ( cbData == 44 && *(_DWORD *)lpData == 44 )
    return 1;
  return v4;
}

//----- (00000001400A4810) ----------------------------------------------------
LSTATUS __fastcall sub_1400A4810(__int64 a1)
{
  return sub_1400A3720(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A4820) ----------------------------------------------------
LSTATUS __fastcall sub_1400A4820(__int64 a1)
{
  return sub_1400A37C0(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A4830) ----------------------------------------------------
LSTATUS __fastcall sub_1400A4830(__int64 a1)
{
  unsigned int v2; // ebp
  LSTATUS result; // eax
  _DWORD *v4; // rsi
  BOOL v5; // edi
  __int64 v6; // rbx
  DWORD cbData; // [rsp+30h] [rbp-148h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-140h] BYREF
  HKEY hKey; // [rsp+40h] [rbp-138h] BYREF
  WCHAR SubKey[128]; // [rsp+50h] [rbp-128h] BYREF

  v2 = 0;
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Toolbars", 0, 0x20019u, &hKey);
  if ( !result )
  {
    sub_140001000(SubKey, 0x80ui64, L"%d", 0i64);
    if ( !RegOpenKeyExW(hKey, SubKey, 0, 0x20019u, &phkResult) )
    {
      v4 = (_DWORD *)(a1 + 61096);
      do
      {
        v5 = (*v4 & 0x200) != 0;
        cbData = 4;
        v6 = 112i64 * (int)v2;
        RegQueryValueExW(phkResult, L"id", 0i64, 0i64, (LPBYTE)(v6 + a1 + 61160), &cbData);
        cbData = 4;
        RegQueryValueExW(phkResult, L"Style", 0i64, 0i64, (LPBYTE)(v6 + a1 + 61096), &cbData);
        cbData = 4;
        RegQueryValueExW(phkResult, L"Length", 0i64, 0i64, (LPBYTE)(v6 + a1 + 61144), &cbData);
        if ( v5 )
          *v4 |= 0x200u;
        RegCloseKey(phkResult);
        ++v2;
        v4 += 28;
        sub_140001000(SubKey, 0x80ui64, L"%d", v2);
      }
      while ( !RegOpenKeyExW(hKey, SubKey, 0, 0x20019u, &phkResult) );
    }
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400F31FC: using guessed type wchar_t aD_3[3];
// 1400F3230: using guessed type wchar_t aD_4[3];

//----- (00000001400A4A70) ----------------------------------------------------
LSTATUS __fastcall sub_1400A4A70(__int64 a1)
{
  LSTATUS result; // eax
  int v3; // ebx
  int v4; // esi
  WPARAM v5; // rdi
  HWND v6; // rcx
  BYTE Data[4]; // [rsp+50h] [rbp-B0h] BYREF
  HKEY phkResult; // [rsp+58h] [rbp-A8h] BYREF
  DWORD dwDisposition; // [rsp+60h] [rbp-A0h] BYREF
  HKEY hKey; // [rsp+68h] [rbp-98h] BYREF
  LPARAM lParam; // [rsp+70h] [rbp-90h] BYREF
  int v12; // [rsp+78h] [rbp-88h]
  int v13; // [rsp+A8h] [rbp-58h]
  int v14; // [rsp+B8h] [rbp-48h]
  WCHAR SubKey[128]; // [rsp+E0h] [rbp-20h] BYREF

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Toolbars");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Toolbars",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    v3 = 0;
    v4 = SendMessageW(*(HWND *)(a1 + 120), 0x40Cu, 0i64, 0i64);
    if ( v4 > 0 )
    {
      v5 = 0i64;
      do
      {
        sub_140001000(SubKey, 0x80ui64, L"%d", (unsigned int)v3);
        if ( !RegCreateKeyExW(hKey, SubKey, 0, 0i64, 0, 0x20006u, 0i64, &phkResult, &dwDisposition) )
        {
          v6 = *(HWND *)(a1 + 120);
          lParam = 0x15100000070i64;
          SendMessageW(v6, 0x41Cu, v5, (LPARAM)&lParam);
          *(_DWORD *)Data = v14;
          RegSetValueExW(phkResult, L"id", 0, 4u, Data, 4u);
          *(_DWORD *)Data = v12;
          RegSetValueExW(phkResult, L"Style", 0, 4u, Data, 4u);
          *(_DWORD *)Data = v13;
          RegSetValueExW(phkResult, L"Length", 0, 4u, Data, 4u);
          RegCloseKey(phkResult);
        }
        ++v3;
        ++v5;
      }
      while ( v3 < v4 );
    }
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400F2EF4: using guessed type wchar_t aD_5[3];

//----- (00000001400A4CD0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A4CD0(HKEY hKey, __int64 a2, int a3)
{
  const WCHAR *v5; // rdi
  HKEY v6; // rbx
  int v7; // eax
  const WCHAR *v8; // rdi
  HKEY v9; // rbx
  int v10; // eax
  HKEY hKeya; // [rsp+50h] [rbp-88h] BYREF
  BYTE Data[4]; // [rsp+58h] [rbp-80h] BYREF
  int dwDisposition[4]; // [rsp+60h] [rbp-78h] BYREF
  WCHAR SubKey[32]; // [rsp+70h] [rbp-68h] BYREF

  itow_s(a3, SubKey, 0x20ui64, 10);
  RegCreateKeyExW(hKey, SubKey, 0, 0i64, 0, 0x20006u, 0i64, &hKeya, (LPDWORD)dwDisposition);
  if ( *(_QWORD *)(a2 + 24) < 8ui64 )
    v5 = (const WCHAR *)a2;
  else
    v5 = *(const WCHAR **)a2;
  v6 = hKeya;
  v7 = lstrlenW(v5);
  RegSetValueExW(v6, L"Description", 0, 1u, (const BYTE *)v5, 2 * v7);
  v8 = (const WCHAR *)(a2 + 40);
  if ( *(_QWORD *)(a2 + 64) >= 8ui64 )
    v8 = *(const WCHAR **)v8;
  v9 = hKeya;
  v10 = lstrlenW(v8);
  RegSetValueExW(v9, L"FilenamePattern", 0, 1u, (const BYTE *)v8, 2 * v10);
  *(_DWORD *)Data = *(_DWORD *)(a2 + 80);
  RegSetValueExW(hKeya, L"Attributes", 0, 4u, Data, 4u);
  RegSetValueExW(hKeya, L"Color", 0, 3u, (const BYTE *)(a2 + 84), 4u);
  return RegCloseKey(hKeya);
}
// 1400A4CD0: using guessed type DWORD dwDisposition[4];

//----- (00000001400A4E60) ----------------------------------------------------
void __fastcall sub_1400A4E60(HKEY hKey, LPCWSTR lpValueName, __int64 ***a3)
{
  const BYTE *lpData; // rax
  __int64 *v7; // r9
  BYTE *v8; // rdi
  const BYTE *v9; // r8

  lpData = (const BYTE *)malloc(8i64 * (_QWORD)a3[1]);
  v7 = **a3;
  v8 = (BYTE *)lpData;
  if ( v7 != (__int64 *)*a3 )
  {
    v9 = lpData;
    do
    {
      v9 += 8;
      *((_DWORD *)v9 - 2) = *((_DWORD *)v7 + 4);
      *((_DWORD *)v9 - 1) = *((_DWORD *)v7 + 5);
      v7 = (__int64 *)*v7;
    }
    while ( v7 != (__int64 *)*a3 );
  }
  RegSetValueExW(hKey, lpValueName, 0, 3u, lpData, 8 * *((_DWORD *)a3 + 2));
  free(v8);
}

//----- (00000001400A4F10) ----------------------------------------------------
void __fastcall sub_1400A4F10(HKEY hKey, LPCWSTR lpValueName, __int64 ***a3)
{
  const BYTE *lpData; // rax
  __int64 *v7; // r9
  BYTE *v8; // rdi
  const BYTE *v9; // r8

  lpData = (const BYTE *)malloc(8i64 * (_QWORD)a3[1]);
  v7 = **a3;
  v8 = (BYTE *)lpData;
  if ( v7 != (__int64 *)*a3 )
  {
    v9 = lpData;
    do
    {
      v9 += 8;
      *((_DWORD *)v9 - 2) = *((_DWORD *)v7 + 4);
      *((_DWORD *)v9 - 1) = *((_DWORD *)v7 + 6);
      v7 = (__int64 *)*v7;
    }
    while ( v7 != (__int64 *)*a3 );
  }
  RegSetValueExW(hKey, lpValueName, 0, 3u, lpData, 8 * *((_DWORD *)a3 + 2));
  free(v8);
}

//----- (00000001400A5010) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5010(__int64 a1, HKEY a2, __int64 a3, int a4)
{
  HKEY v7; // rbx
  int v8; // eax
  HKEY v9; // rdi
  int v10; // eax
  int v11; // ebx
  bool v12; // zf
  HKEY v13; // rdi
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // rcx
  LSTATUS result; // eax
  __int64 v18; // rcx
  HKEY hKey; // [rsp+50h] [rbp-10E8h] BYREF
  BYTE Data[4]; // [rsp+58h] [rbp-10E0h] BYREF
  int v21; // [rsp+60h] [rbp-10D8h]
  HKEY v22; // [rsp+68h] [rbp-10D0h]
  int dwDisposition[4]; // [rsp+70h] [rbp-10C8h] BYREF
  char v24[2080]; // [rsp+80h] [rbp-10B8h] BYREF
  char v25[2080]; // [rsp+8A0h] [rbp-898h] BYREF
  WCHAR SubKey[32]; // [rsp+10C0h] [rbp-78h] BYREF

  v22 = a2;
  v21 = a4;
  itow_s(a4, SubKey, 0x20ui64, 10);
  RegCreateKeyExW(a2, SubKey, 0, 0i64, 0, 0x20006u, 0i64, &hKey, (LPDWORD)dwDisposition);
  v7 = hKey;
  v8 = lstrlenW((LPCWSTR)a3);
  RegSetValueExW(v7, L"Name", 0, 1u, (const BYTE *)a3, 2 * v8);
  v9 = hKey;
  v10 = lstrlenW((LPCWSTR)(a3 + 512));
  RegSetValueExW(v9, L"Description", 0, 1u, (const BYTE *)(a3 + 512), 2 * v10);
  *(_DWORD *)Data = *(_DWORD *)(a3 + 1540);
  RegSetValueExW(hKey, L"Type", 0, 4u, Data, 4u);
  *(_DWORD *)Data = *(_DWORD *)(a3 + 1536);
  RegSetValueExW(hKey, L"ShowOnBookmarksToolbar", 0, 4u, Data, 4u);
  v11 = v21 + 1;
  v12 = *(_DWORD *)(a3 + 1540) == 1;
  ++v21;
  if ( v12 )
  {
    v13 = hKey;
    v14 = lstrlenW((LPCWSTR)(a3 + 1544));
    RegSetValueExW(v13, L"Location", 0, 1u, (const BYTE *)(a3 + 1544), 2 * v14);
    v11 = v21;
  }
  if ( !*(_DWORD *)(a3 + 1540) )
  {
    v15 = *(_QWORD *)(a3 + 2064);
    if ( !*(_DWORD *)(v15 + 1540) )
    {
      v16 = *(_QWORD *)(v15 + 2088);
      if ( v16 )
      {
        sub_14007D720(v16, (__int64)v25);
        sub_1400A5010(a1, hKey, (__int64)v25, 0);
      }
    }
  }
  result = RegCloseKey(hKey);
  v18 = *(_QWORD *)(*(_QWORD *)(a3 + 2064) + 2080i64);
  if ( v18 )
  {
    sub_14007D720(v18, (__int64)v24);
    return sub_1400A5010(a1, v22, (__int64)v24, v11);
  }
  return result;
}
// 1400A5010: using guessed type DWORD dwDisposition[4];

//----- (00000001400A5280) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5280(__int64 a1)
{
  LSTATUS result; // eax
  __int64 v3; // rcx
  HKEY hKey; // [rsp+50h] [rbp-1068h] BYREF
  DWORD dwDisposition; // [rsp+58h] [rbp-1060h] BYREF
  char v6[2064]; // [rsp+60h] [rbp-1058h] BYREF
  __int64 v7; // [rsp+870h] [rbp-848h]
  char v8[2080]; // [rsp+880h] [rbp-838h] BYREF

  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Bookmarks");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Bookmarks",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    sub_14007DA80(a1 + 2664, (__int64)v6);
    if ( !*(_DWORD *)(v7 + 1540) )
    {
      v3 = *(_QWORD *)(v7 + 2088);
      if ( v3 )
      {
        sub_14007D720(v3, (__int64)v8);
        sub_1400A5010(a1, hKey, (__int64)v8, 0);
      }
    }
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400A5280: using guessed type char var_1058[2064];

//----- (00000001400A5380) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5380(__int64 a1)
{
  return sub_1400A4A70(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A5390) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5390(__int64 a1)
{
  return sub_1400A5280(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A53A0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A53A0(__int64 a1)
{
  return sub_1400A4830(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A53B0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A53B0(__int64 a1, HKEY a2)
{
  int v4; // er12
  LSTATUS result; // eax
  LSTATUS v6; // edi
  __int64 v7; // rcx
  LSTATUS v8; // ebx
  __int64 v9; // rcx
  void *v10; // rax
  DWORD cbData; // [rsp+30h] [rbp-D0h] BYREF
  BYTE v12[4]; // [rsp+34h] [rbp-CCh] BYREF
  HKEY hKey; // [rsp+38h] [rbp-C8h] BYREF
  DWORD v14; // [rsp+40h] [rbp-C0h] BYREF
  int Type[3]; // [rsp+44h] [rbp-BCh] BYREF
  WCHAR SubKey[256]; // [rsp+50h] [rbp-B0h] BYREF
  BYTE v17[2]; // [rsp+250h] [rbp+150h] BYREF
  BYTE Data[2]; // [rsp+650h] [rbp+550h] BYREF

  *(_DWORD *)v12 = 1;
  v4 = 0;
  sub_140001000(SubKey, 0x100ui64, L"%d", 0i64);
  for ( result = RegOpenKeyExW(a2, SubKey, 0, 0x20019u, &hKey);
        !result;
        result = RegOpenKeyExW(a2, SubKey, 0, 0x20019u, &hKey) )
  {
    cbData = 512;
    v6 = RegQueryValueExW(hKey, L"Name", 0i64, (LPDWORD)Type, Data, &cbData);
    if ( cbData && Type[0] == 1 )
    {
      if ( *(_WORD *)&Data[2 * cbData - 2] )
      {
        v7 = 512i64;
        if ( cbData < 0x200 )
          v7 = cbData;
        *(_WORD *)&Data[2 * v7] = 0;
      }
    }
    else
    {
      *(_WORD *)Data = 0;
    }
    cbData = 512;
    v8 = RegQueryValueExW(hKey, L"Command", 0i64, &v14, v17, &cbData);
    if ( cbData && v14 == 1 )
    {
      if ( *(_WORD *)&v17[2 * cbData - 2] )
      {
        v9 = 512i64;
        if ( cbData < 0x200 )
          v9 = cbData;
        *(_WORD *)&v17[2 * v9] = 0;
      }
    }
    else
    {
      *(_WORD *)v17 = 0;
    }
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowNameOnToolbar", 0i64, 0i64, v12, &cbData);
    if ( !v6 && !v8 )
    {
      v10 = malloc(0x820ui64);
      if ( v10 )
        sub_1400CD750(a1, (__int64)Data, (__int64)v17, *(int *)v12, (__int64)v10);
    }
    RegCloseKey(hKey);
    sub_140001000(SubKey, 0x100ui64, L"%d", (unsigned int)++v4);
  }
  return result;
}
// 1400F2B54: using guessed type wchar_t aD_6[3];
// 1400F2E04: using guessed type wchar_t aD_7[3];
// 1400A53B0: using guessed type DWORD Type[3];

//----- (00000001400A5630) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5630(__int64 a1)
{
  LSTATUS result; // eax
  HKEY hKey; // [rsp+48h] [rbp+10h] BYREF

  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ApplicationToolbar", 0, 0x20019u, &hKey);
  if ( !result )
  {
    sub_1400A53B0(a1, hKey);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A5690) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5690(_QWORD *a1)
{
  LSTATUS result; // eax
  HKEY v3; // rsi
  const BYTE *v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rdx
  BYTE *v7; // rdi
  const BYTE *v8; // r8
  HKEY v9; // rsi
  const BYTE *v10; // rax
  _QWORD *v11; // rcx
  _QWORD *v12; // rdx
  BYTE *v13; // rdi
  const BYTE *v14; // r8
  HKEY v15; // rsi
  const BYTE *v16; // rax
  _QWORD *v17; // rcx
  _QWORD *v18; // rdx
  BYTE *v19; // rdi
  const BYTE *v20; // r8
  HKEY v21; // rsi
  const BYTE *v22; // rax
  _QWORD *v23; // rcx
  _QWORD *v24; // rdx
  BYTE *v25; // rdi
  const BYTE *v26; // r8
  HKEY v27; // rsi
  const BYTE *v28; // rax
  _QWORD *v29; // rcx
  _QWORD *v30; // rdx
  BYTE *v31; // rdi
  const BYTE *v32; // r8
  HKEY v33; // rsi
  const BYTE *v34; // rax
  _QWORD *v35; // rcx
  _QWORD *v36; // rdx
  BYTE *v37; // rdi
  const BYTE *v38; // r8
  HKEY v39; // rsi
  const BYTE *v40; // rax
  _QWORD *v41; // rcx
  _QWORD *v42; // rdx
  BYTE *v43; // rdi
  const BYTE *v44; // r8
  HKEY v45; // rsi
  const BYTE *v46; // rax
  _QWORD *v47; // rcx
  _QWORD *v48; // rdx
  BYTE *v49; // rdi
  const BYTE *v50; // r8
  HKEY v51; // rsi
  const BYTE *v52; // rax
  _QWORD *v53; // rcx
  _QWORD *v54; // rdx
  BYTE *v55; // rdi
  const BYTE *v56; // r8
  HKEY v57; // rsi
  const BYTE *v58; // rax
  _QWORD *v59; // rcx
  _QWORD *v60; // rdx
  BYTE *v61; // rdi
  const BYTE *v62; // r8
  HKEY v63; // rsi
  const BYTE *v64; // rax
  _QWORD *v65; // rcx
  _QWORD *v66; // rdx
  BYTE *v67; // rdi
  const BYTE *v68; // r8
  HKEY v69; // rsi
  const BYTE *v70; // rax
  _QWORD *v71; // rcx
  _QWORD *v72; // rdx
  BYTE *v73; // rdi
  const BYTE *v74; // r8
  HKEY v75; // rsi
  const BYTE *v76; // rax
  _QWORD *v77; // rcx
  _QWORD *v78; // rdx
  BYTE *v79; // rdi
  const BYTE *v80; // r8
  HKEY v81; // rsi
  const BYTE *v82; // rax
  _QWORD *v83; // rcx
  _QWORD *v84; // rdx
  BYTE *v85; // rdi
  const BYTE *v86; // r8
  DWORD dwDisposition; // [rsp+68h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+70h] [rbp+18h] BYREF

  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\DefaultColumns",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    v3 = hKey;
    v4 = (const BYTE *)malloc(8i64 * a1[7786]);
    v5 = (_QWORD *)a1[7785];
    v6 = (_QWORD *)*v5;
    v7 = (BYTE *)v4;
    if ( (_QWORD *)*v5 != v5 )
    {
      v8 = v4;
      do
      {
        v8 += 8;
        *((_DWORD *)v8 - 2) = *((_DWORD *)v6 + 4);
        *((_DWORD *)v8 - 1) = *((_DWORD *)v6 + 5);
        v6 = (_QWORD *)*v6;
      }
      while ( v6 != (_QWORD *)a1[7785] );
    }
    RegSetValueExW(v3, L"ControlPanelColumns", 0, 3u, v4, 8 * *((_DWORD *)a1 + 15572));
    free(v7);
    v9 = hKey;
    v10 = (const BYTE *)malloc(8i64 * a1[7786]);
    v11 = (_QWORD *)a1[7785];
    v12 = (_QWORD *)*v11;
    v13 = (BYTE *)v10;
    if ( (_QWORD *)*v11 != v11 )
    {
      v14 = v10;
      do
      {
        v14 += 8;
        *((_DWORD *)v14 - 2) = *((_DWORD *)v12 + 4);
        *((_DWORD *)v14 - 1) = *((_DWORD *)v12 + 6);
        v12 = (_QWORD *)*v12;
      }
      while ( v12 != (_QWORD *)a1[7785] );
    }
    RegSetValueExW(v9, L"ControlPanelColumnWidths", 0, 3u, v10, 8 * *((_DWORD *)a1 + 15572));
    free(v13);
    v15 = hKey;
    v16 = (const BYTE *)malloc(8i64 * a1[7783]);
    v17 = (_QWORD *)a1[7782];
    v18 = (_QWORD *)*v17;
    v19 = (BYTE *)v16;
    if ( (_QWORD *)*v17 != v17 )
    {
      v20 = v16;
      do
      {
        v20 += 8;
        *((_DWORD *)v20 - 2) = *((_DWORD *)v18 + 4);
        *((_DWORD *)v20 - 1) = *((_DWORD *)v18 + 5);
        v18 = (_QWORD *)*v18;
      }
      while ( v18 != (_QWORD *)a1[7782] );
    }
    RegSetValueExW(v15, L"MyComputerColumns", 0, 3u, v16, 8 * *((_DWORD *)a1 + 15566));
    free(v19);
    v21 = hKey;
    v22 = (const BYTE *)malloc(8i64 * a1[7783]);
    v23 = (_QWORD *)a1[7782];
    v24 = (_QWORD *)*v23;
    v25 = (BYTE *)v22;
    if ( (_QWORD *)*v23 != v23 )
    {
      v26 = v22;
      do
      {
        v26 += 8;
        *((_DWORD *)v26 - 2) = *((_DWORD *)v24 + 4);
        *((_DWORD *)v26 - 1) = *((_DWORD *)v24 + 6);
        v24 = (_QWORD *)*v24;
      }
      while ( v24 != (_QWORD *)a1[7782] );
    }
    RegSetValueExW(v21, L"MyComputerColumnWidths", 0, 3u, v22, 8 * *((_DWORD *)a1 + 15566));
    free(v25);
    v27 = hKey;
    v28 = (const BYTE *)malloc(8i64 * a1[7780]);
    v29 = (_QWORD *)a1[7779];
    v30 = (_QWORD *)*v29;
    v31 = (BYTE *)v28;
    if ( (_QWORD *)*v29 != v29 )
    {
      v32 = v28;
      do
      {
        v32 += 8;
        *((_DWORD *)v32 - 2) = *((_DWORD *)v30 + 4);
        *((_DWORD *)v32 - 1) = *((_DWORD *)v30 + 5);
        v30 = (_QWORD *)*v30;
      }
      while ( v30 != (_QWORD *)a1[7779] );
    }
    RegSetValueExW(v27, L"RealFolderColumns", 0, 3u, v28, 8 * *((_DWORD *)a1 + 15560));
    free(v31);
    v33 = hKey;
    v34 = (const BYTE *)malloc(8i64 * a1[7780]);
    v35 = (_QWORD *)a1[7779];
    v36 = (_QWORD *)*v35;
    v37 = (BYTE *)v34;
    if ( (_QWORD *)*v35 != v35 )
    {
      v38 = v34;
      do
      {
        v38 += 8;
        *((_DWORD *)v38 - 2) = *((_DWORD *)v36 + 4);
        *((_DWORD *)v38 - 1) = *((_DWORD *)v36 + 6);
        v36 = (_QWORD *)*v36;
      }
      while ( v36 != (_QWORD *)a1[7779] );
    }
    RegSetValueExW(v33, L"RealFolderColumnWidths", 0, 3u, v34, 8 * *((_DWORD *)a1 + 15560));
    free(v37);
    v39 = hKey;
    v40 = (const BYTE *)malloc(8i64 * a1[7789]);
    v41 = (_QWORD *)a1[7788];
    v42 = (_QWORD *)*v41;
    v43 = (BYTE *)v40;
    if ( (_QWORD *)*v41 != v41 )
    {
      v44 = v40;
      do
      {
        v44 += 8;
        *((_DWORD *)v44 - 2) = *((_DWORD *)v42 + 4);
        *((_DWORD *)v44 - 1) = *((_DWORD *)v42 + 5);
        v42 = (_QWORD *)*v42;
      }
      while ( v42 != (_QWORD *)a1[7788] );
    }
    RegSetValueExW(v39, L"RecycleBinColumns", 0, 3u, v40, 8 * *((_DWORD *)a1 + 15578));
    free(v43);
    v45 = hKey;
    v46 = (const BYTE *)malloc(8i64 * a1[7789]);
    v47 = (_QWORD *)a1[7788];
    v48 = (_QWORD *)*v47;
    v49 = (BYTE *)v46;
    if ( (_QWORD *)*v47 != v47 )
    {
      v50 = v46;
      do
      {
        v50 += 8;
        *((_DWORD *)v50 - 2) = *((_DWORD *)v48 + 4);
        *((_DWORD *)v50 - 1) = *((_DWORD *)v48 + 6);
        v48 = (_QWORD *)*v48;
      }
      while ( v48 != (_QWORD *)a1[7788] );
    }
    RegSetValueExW(v45, L"RecycleBinColumnWidths", 0, 3u, v46, 8 * *((_DWORD *)a1 + 15578));
    free(v49);
    v51 = hKey;
    v52 = (const BYTE *)malloc(8i64 * a1[7792]);
    v53 = (_QWORD *)a1[7791];
    v54 = (_QWORD *)*v53;
    v55 = (BYTE *)v52;
    if ( (_QWORD *)*v53 != v53 )
    {
      v56 = v52;
      do
      {
        v56 += 8;
        *((_DWORD *)v56 - 2) = *((_DWORD *)v54 + 4);
        *((_DWORD *)v56 - 1) = *((_DWORD *)v54 + 5);
        v54 = (_QWORD *)*v54;
      }
      while ( v54 != (_QWORD *)a1[7791] );
    }
    RegSetValueExW(v51, L"PrinterColumns", 0, 3u, v52, 8 * *((_DWORD *)a1 + 15584));
    free(v55);
    v57 = hKey;
    v58 = (const BYTE *)malloc(8i64 * a1[7792]);
    v59 = (_QWORD *)a1[7791];
    v60 = (_QWORD *)*v59;
    v61 = (BYTE *)v58;
    if ( (_QWORD *)*v59 != v59 )
    {
      v62 = v58;
      do
      {
        v62 += 8;
        *((_DWORD *)v62 - 2) = *((_DWORD *)v60 + 4);
        *((_DWORD *)v62 - 1) = *((_DWORD *)v60 + 6);
        v60 = (_QWORD *)*v60;
      }
      while ( v60 != (_QWORD *)a1[7791] );
    }
    RegSetValueExW(v57, L"PrinterColumnWidths", 0, 3u, v58, 8 * *((_DWORD *)a1 + 15584));
    free(v61);
    v63 = hKey;
    v64 = (const BYTE *)malloc(8i64 * a1[7795]);
    v65 = (_QWORD *)a1[7794];
    v66 = (_QWORD *)*v65;
    v67 = (BYTE *)v64;
    if ( (_QWORD *)*v65 != v65 )
    {
      v68 = v64;
      do
      {
        v68 += 8;
        *((_DWORD *)v68 - 2) = *((_DWORD *)v66 + 4);
        *((_DWORD *)v68 - 1) = *((_DWORD *)v66 + 5);
        v66 = (_QWORD *)*v66;
      }
      while ( v66 != (_QWORD *)a1[7794] );
    }
    RegSetValueExW(v63, L"NetworkColumns", 0, 3u, v64, 8 * *((_DWORD *)a1 + 15590));
    free(v67);
    v69 = hKey;
    v70 = (const BYTE *)malloc(8i64 * a1[7795]);
    v71 = (_QWORD *)a1[7794];
    v72 = (_QWORD *)*v71;
    v73 = (BYTE *)v70;
    if ( (_QWORD *)*v71 != v71 )
    {
      v74 = v70;
      do
      {
        v74 += 8;
        *((_DWORD *)v74 - 2) = *((_DWORD *)v72 + 4);
        *((_DWORD *)v74 - 1) = *((_DWORD *)v72 + 6);
        v72 = (_QWORD *)*v72;
      }
      while ( v72 != (_QWORD *)a1[7794] );
    }
    RegSetValueExW(v69, L"NetworkColumnWidths", 0, 3u, v70, 8 * *((_DWORD *)a1 + 15590));
    free(v73);
    v75 = hKey;
    v76 = (const BYTE *)malloc(8i64 * a1[7798]);
    v77 = (_QWORD *)a1[7797];
    v78 = (_QWORD *)*v77;
    v79 = (BYTE *)v76;
    if ( (_QWORD *)*v77 != v77 )
    {
      v80 = v76;
      do
      {
        v80 += 8;
        *((_DWORD *)v80 - 2) = *((_DWORD *)v78 + 4);
        *((_DWORD *)v80 - 1) = *((_DWORD *)v78 + 5);
        v78 = (_QWORD *)*v78;
      }
      while ( v78 != (_QWORD *)a1[7797] );
    }
    RegSetValueExW(v75, L"NetworkPlacesColumns", 0, 3u, v76, 8 * *((_DWORD *)a1 + 15596));
    free(v79);
    v81 = hKey;
    v82 = (const BYTE *)malloc(8i64 * a1[7798]);
    v83 = (_QWORD *)a1[7797];
    v84 = (_QWORD *)*v83;
    v85 = (BYTE *)v82;
    if ( (_QWORD *)*v83 != v83 )
    {
      v86 = v82;
      do
      {
        v86 += 8;
        *((_DWORD *)v86 - 2) = *((_DWORD *)v84 + 4);
        *((_DWORD *)v86 - 1) = *((_DWORD *)v84 + 6);
        v84 = (_QWORD *)*v84;
      }
      while ( v84 != (_QWORD *)a1[7797] );
    }
    RegSetValueExW(v81, L"NetworkPlacesColumnWidths", 0, 3u, v82, 8 * *((_DWORD *)a1 + 15596));
    free(v85);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A5E20) ----------------------------------------------------
LSTATUS __fastcall sub_1400A5E20(__int64 a1)
{
  LSTATUS result; // eax
  int v3; // er14
  unsigned int i; // er13
  __int64 v5; // rcx
  ITEMIDLIST *v6; // rbx
  DWORD v7; // eax
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  HKEY v18; // rbx
  int v19; // eax
  _QWORD *v20; // rax
  __int64 v21; // rcx
  HKEY v22; // rsi
  int v23; // ebx
  const BYTE *v24; // rax
  BYTE *v25; // rdi
  _QWORD *v26; // rdx
  BYTE *v27; // r8
  HKEY v28; // rsi
  int v29; // ebx
  const BYTE *v30; // rax
  BYTE *v31; // rdi
  _QWORD *v32; // rdx
  BYTE *v33; // r8
  HKEY v34; // rsi
  int v35; // ebx
  const BYTE *v36; // rax
  BYTE *v37; // rdi
  _DWORD *v38; // rdx
  BYTE *v39; // r8
  HKEY v40; // rsi
  int v41; // ebx
  const BYTE *v42; // rax
  BYTE *v43; // rdi
  _QWORD *v44; // rdx
  BYTE *v45; // r8
  HKEY v46; // rsi
  int v47; // ebx
  const BYTE *v48; // rax
  BYTE *v49; // rdi
  _QWORD *v50; // rdx
  BYTE *v51; // r8
  HKEY v52; // rsi
  int v53; // ebx
  const BYTE *v54; // rax
  BYTE *v55; // rdi
  _QWORD *v56; // rdx
  BYTE *v57; // r8
  HKEY v58; // rsi
  int v59; // ebx
  const BYTE *v60; // rax
  BYTE *v61; // rdi
  _QWORD *v62; // rdx
  BYTE *v63; // r8
  HKEY v64; // rsi
  int v65; // ebx
  const BYTE *v66; // rax
  BYTE *v67; // rdi
  _QWORD *v68; // rdx
  BYTE *v69; // r8
  HKEY v70; // rsi
  int v71; // ebx
  const BYTE *v72; // rax
  BYTE *v73; // rdi
  _QWORD *v74; // rdx
  BYTE *v75; // r8
  HKEY v76; // rsi
  int v77; // ebx
  const BYTE *v78; // rax
  BYTE *v79; // rdi
  _DWORD *v80; // rdx
  BYTE *v81; // r8
  HKEY v82; // rsi
  int v83; // ebx
  const BYTE *v84; // rax
  BYTE *v85; // rdi
  _QWORD *v86; // rdx
  BYTE *v87; // r8
  HKEY v88; // rsi
  int v89; // ebx
  const BYTE *v90; // rax
  BYTE *v91; // rdi
  _QWORD *v92; // rdx
  BYTE *v93; // r8
  HKEY v94; // rsi
  int v95; // ebx
  const BYTE *v96; // rax
  BYTE *v97; // rdi
  _QWORD *v98; // rdx
  BYTE *v99; // r8
  HKEY v100; // rsi
  int v101; // ebx
  const BYTE *v102; // rax
  BYTE *v103; // rdi
  _QWORD *v104; // rdx
  BYTE *v105; // r8
  __int64 v106; // r11
  const WCHAR *v107; // rbx
  HKEY v108; // rdi
  int v109; // eax
  HKEY v110; // rbx
  int v111; // eax
  HKEY phkResult; // [rsp+58h] [rbp-B0h] BYREF
  HKEY v113; // [rsp+60h] [rbp-A8h] BYREF
  int Data; // [rsp+68h] [rbp-A0h] BYREF
  DWORD dwDisposition; // [rsp+70h] [rbp-98h] BYREF
  BYTE v116[4]; // [rsp+78h] [rbp-90h] BYREF
  int v117; // [rsp+80h] [rbp-88h] BYREF
  BYTE v118[4]; // [rsp+88h] [rbp-80h] BYREF
  BYTE v119[4]; // [rsp+90h] [rbp-78h] BYREF
  BYTE v120[4]; // [rsp+98h] [rbp-70h] BYREF
  BYTE v121[4]; // [rsp+A0h] [rbp-68h] BYREF
  BYTE v122[4]; // [rsp+A8h] [rbp-60h] BYREF
  int v123; // [rsp+B0h] [rbp-58h] BYREF
  BYTE v124[4]; // [rsp+B8h] [rbp-50h] BYREF
  BYTE v125[4]; // [rsp+C0h] [rbp-48h] BYREF
  BYTE v126[4]; // [rsp+C8h] [rbp-40h] BYREF
  BYTE v127[4]; // [rsp+D0h] [rbp-38h] BYREF
  __int64 lParam[4]; // [rsp+D8h] [rbp-30h] BYREF
  int v129; // [rsp+F8h] [rbp-10h]
  _QWORD *v130; // [rsp+108h] [rbp+0h] BYREF
  __int64 v131; // [rsp+110h] [rbp+8h]
  _QWORD *v132; // [rsp+120h] [rbp+18h] BYREF
  __int64 v133; // [rsp+128h] [rbp+20h]
  _QWORD *v134; // [rsp+138h] [rbp+30h] BYREF
  __int64 v135; // [rsp+140h] [rbp+38h]
  _QWORD *v136; // [rsp+150h] [rbp+48h] BYREF
  __int64 v137; // [rsp+158h] [rbp+50h]
  _QWORD *v138; // [rsp+168h] [rbp+60h] BYREF
  __int64 v139; // [rsp+170h] [rbp+68h]
  _QWORD *v140; // [rsp+180h] [rbp+78h] BYREF
  __int64 v141; // [rsp+188h] [rbp+80h]
  _QWORD *v142; // [rsp+198h] [rbp+90h] BYREF
  __int64 v143; // [rsp+1A0h] [rbp+98h]
  HKEY hKey; // [rsp+1B8h] [rbp+B0h] BYREF
  char *v145[2]; // [rsp+1C0h] [rbp+B8h] BYREF
  __int64 pExceptionObject[3]; // [rsp+1D0h] [rbp+C8h] BYREF
  WCHAR SubKey[128]; // [rsp+1E8h] [rbp+E0h] BYREF
  WCHAR String[512]; // [rsp+2E8h] [rbp+1E0h] BYREF

  v145[1] = (char *)-2i64;
  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Tabs");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\Tabs",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  if ( !result )
  {
    v3 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
    LODWORD(lParam[0]) = 8;
    for ( i = 0; (int)i < v3; ++i )
    {
      SendMessageW(*(HWND *)(a1 + 136), 0x133Cu, (int)i, (LPARAM)lParam);
      sub_140001000(SubKey, 0x80ui64, L"%d", i);
      if ( !RegCreateKeyExW(hKey, SubKey, 0, 0i64, 0, 0x20006u, 0i64, &phkResult, &dwDisposition) )
      {
        v5 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        v6 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 112i64))(v5);
        v7 = ILGetSize(v6);
        RegSetValueExW(phkResult, L"Directory", 0, 3u, (const BYTE *)v6, v7);
        CoTaskMemFree(v6);
        v8 = *(_QWORD *)(a1 + 8i64 * v129 + 1032);
        (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v8 + 48i64))(v8, &v123);
        Data = v123;
        RegSetValueExW(phkResult, L"ViewMode", 0, 4u, (const BYTE *)&Data, 4u);
        v9 = *(_QWORD *)(a1 + 8i64 * v129 + 1032);
        (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v9 + 56i64))(v9, &v117);
        Data = v117;
        RegSetValueExW(phkResult, L"SortMode", 0, 4u, (const BYTE *)&Data, 4u);
        v10 = *(_QWORD *)(a1 + 8i64 * v129 + 1032);
        *(_DWORD *)v119 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 80i64))(v10);
        RegSetValueExW(phkResult, L"SortAscending", 0, 4u, v119, 4u);
        v11 = *(_QWORD *)(a1 + 8i64 * v129 + 1032);
        *(_DWORD *)v118 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 72i64))(v11);
        RegSetValueExW(phkResult, L"ShowInGroups", 0, 4u, v118, 4u);
        v12 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        *(_DWORD *)v125 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 432i64))(v12);
        RegSetValueExW(phkResult, L"ApplyFilter", 0, 4u, v125, 4u);
        v13 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        *(_DWORD *)v120 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 448i64))(v13);
        RegSetValueExW(phkResult, L"FilterCaseSensitive", 0, 4u, v120, 4u);
        v14 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        *(_DWORD *)v127 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 496i64))(v14);
        RegSetValueExW(phkResult, L"ShowHidden", 0, 4u, v127, 4u);
        v15 = *(_QWORD *)(a1 + 8i64 * v129 + 1032);
        *(_DWORD *)v124 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v15 + 24i64))(v15);
        RegSetValueExW(phkResult, L"AutoArrange", 0, 4u, v124, 4u);
        v16 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        *(_DWORD *)v122 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 608i64))(v16);
        RegSetValueExW(phkResult, L"ShowGridlines", 0, 4u, v122, 4u);
        v17 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
        (*(void (__fastcall **)(__int64, WCHAR *, __int64))(*(_QWORD *)v17 + 416i64))(v17, String, 512i64);
        v18 = phkResult;
        v19 = lstrlenW(String);
        RegSetValueExW(v18, L"Filter", 0, 1u, (const BYTE *)String, 2 * v19);
        if ( !RegCreateKeyExW(phkResult, L"Columns", 0, 0i64, 0, 0x20006u, 0i64, &v113, &dwDisposition) )
        {
          v131 = 0i64;
          v20 = operator new(0x20ui64);
          if ( !v20 )
          {
            v145[0] = 0i64;
            std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v145);
            pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
            CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
          v130 = v20;
          *v20 = v20;
          v130[1] = v130;
          sub_14000AB70(&v132);
          sub_14000AB70(&v134);
          sub_14000AB70(&v136);
          sub_14000AB70(&v138);
          sub_14000AB70(&v140);
          sub_14000AB70(&v142);
          v21 = *(_QWORD *)(a1 + 8i64 * v129 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD **))(*(_QWORD *)v21 + 648i64))(v21, &v130);
          v22 = v113;
          v23 = v135;
          v24 = (const BYTE *)malloc(8 * v135);
          v25 = (BYTE *)v24;
          v26 = (_QWORD *)*v134;
          if ( (_QWORD *)*v134 != v134 )
          {
            v27 = (BYTE *)v24;
            do
            {
              *(_DWORD *)v27 = *((_DWORD *)v26 + 4);
              *((_DWORD *)v27 + 1) = *((_DWORD *)v26 + 5);
              v27 += 8;
              v26 = (_QWORD *)*v26;
            }
            while ( v26 != v134 );
            v23 = v135;
          }
          RegSetValueExW(v22, L"ControlPanelColumns", 0, 3u, v24, 8 * v23);
          free(v25);
          v28 = v113;
          v29 = v133;
          v30 = (const BYTE *)malloc(8 * v133);
          v31 = (BYTE *)v30;
          v32 = (_QWORD *)*v132;
          if ( (_QWORD *)*v132 != v132 )
          {
            v33 = (BYTE *)v30;
            do
            {
              *(_DWORD *)v33 = *((_DWORD *)v32 + 4);
              *((_DWORD *)v33 + 1) = *((_DWORD *)v32 + 5);
              v33 += 8;
              v32 = (_QWORD *)*v32;
            }
            while ( v32 != v132 );
            v29 = v133;
          }
          RegSetValueExW(v28, L"MyComputerColumns", 0, 3u, v30, 8 * v29);
          free(v31);
          v34 = v113;
          v35 = v131;
          v36 = (const BYTE *)malloc(8 * v131);
          v37 = (BYTE *)v36;
          v38 = (_DWORD *)*v130;
          if ( (_QWORD *)*v130 != v130 )
          {
            v39 = (BYTE *)v36;
            do
            {
              *(_DWORD *)v39 = v38[4];
              *((_DWORD *)v39 + 1) = v38[5];
              v39 += 8;
              v38 = *(_DWORD **)v38;
            }
            while ( v38 != (_DWORD *)v130 );
            v35 = v131;
          }
          RegSetValueExW(v34, L"RealFolderColumns", 0, 3u, v36, 8 * v35);
          free(v37);
          v40 = v113;
          v41 = v137;
          v42 = (const BYTE *)malloc(8 * v137);
          v43 = (BYTE *)v42;
          v44 = (_QWORD *)*v136;
          if ( (_QWORD *)*v136 != v136 )
          {
            v45 = (BYTE *)v42;
            do
            {
              *(_DWORD *)v45 = *((_DWORD *)v44 + 4);
              *((_DWORD *)v45 + 1) = *((_DWORD *)v44 + 5);
              v45 += 8;
              v44 = (_QWORD *)*v44;
            }
            while ( v44 != v136 );
            v41 = v137;
          }
          RegSetValueExW(v40, L"RecycleBinColumns", 0, 3u, v42, 8 * v41);
          free(v43);
          v46 = v113;
          v47 = v139;
          v48 = (const BYTE *)malloc(8 * v139);
          v49 = (BYTE *)v48;
          v50 = (_QWORD *)*v138;
          if ( (_QWORD *)*v138 != v138 )
          {
            v51 = (BYTE *)v48;
            do
            {
              *(_DWORD *)v51 = *((_DWORD *)v50 + 4);
              *((_DWORD *)v51 + 1) = *((_DWORD *)v50 + 5);
              v51 += 8;
              v50 = (_QWORD *)*v50;
            }
            while ( v50 != v138 );
            v47 = v139;
          }
          RegSetValueExW(v46, L"PrinterColumns", 0, 3u, v48, 8 * v47);
          free(v49);
          v52 = v113;
          v53 = v141;
          v54 = (const BYTE *)malloc(8 * v141);
          v55 = (BYTE *)v54;
          v56 = (_QWORD *)*v140;
          if ( (_QWORD *)*v140 != v140 )
          {
            v57 = (BYTE *)v54;
            do
            {
              *(_DWORD *)v57 = *((_DWORD *)v56 + 4);
              *((_DWORD *)v57 + 1) = *((_DWORD *)v56 + 5);
              v57 += 8;
              v56 = (_QWORD *)*v56;
            }
            while ( v56 != v140 );
            v53 = v141;
          }
          RegSetValueExW(v52, L"NetworkColumns", 0, 3u, v54, 8 * v53);
          free(v55);
          v58 = v113;
          v59 = v143;
          v60 = (const BYTE *)malloc(8 * v143);
          v61 = (BYTE *)v60;
          v62 = (_QWORD *)*v142;
          if ( (_QWORD *)*v142 != v142 )
          {
            v63 = (BYTE *)v60;
            do
            {
              *(_DWORD *)v63 = *((_DWORD *)v62 + 4);
              *((_DWORD *)v63 + 1) = *((_DWORD *)v62 + 5);
              v63 += 8;
              v62 = (_QWORD *)*v62;
            }
            while ( v62 != v142 );
            v59 = v143;
          }
          RegSetValueExW(v58, L"NetworkPlacesColumns", 0, 3u, v60, 8 * v59);
          free(v61);
          v64 = v113;
          v65 = v135;
          v66 = (const BYTE *)malloc(8 * v135);
          v67 = (BYTE *)v66;
          v68 = (_QWORD *)*v134;
          if ( (_QWORD *)*v134 != v134 )
          {
            v69 = (BYTE *)v66;
            do
            {
              *(_DWORD *)v69 = *((_DWORD *)v68 + 4);
              *((_DWORD *)v69 + 1) = *((_DWORD *)v68 + 6);
              v69 += 8;
              v68 = (_QWORD *)*v68;
            }
            while ( v68 != v134 );
            v65 = v135;
          }
          RegSetValueExW(v64, L"ControlPanelColumnWidths", 0, 3u, v66, 8 * v65);
          free(v67);
          v70 = v113;
          v71 = v133;
          v72 = (const BYTE *)malloc(8 * v133);
          v73 = (BYTE *)v72;
          v74 = (_QWORD *)*v132;
          if ( (_QWORD *)*v132 != v132 )
          {
            v75 = (BYTE *)v72;
            do
            {
              *(_DWORD *)v75 = *((_DWORD *)v74 + 4);
              *((_DWORD *)v75 + 1) = *((_DWORD *)v74 + 6);
              v75 += 8;
              v74 = (_QWORD *)*v74;
            }
            while ( v74 != v132 );
            v71 = v133;
          }
          RegSetValueExW(v70, L"MyComputerColumnWidths", 0, 3u, v72, 8 * v71);
          free(v73);
          v76 = v113;
          v77 = v131;
          v78 = (const BYTE *)malloc(8 * v131);
          v79 = (BYTE *)v78;
          v80 = (_DWORD *)*v130;
          if ( (_QWORD *)*v130 != v130 )
          {
            v81 = (BYTE *)v78;
            do
            {
              *(_DWORD *)v81 = v80[4];
              *((_DWORD *)v81 + 1) = v80[6];
              v81 += 8;
              v80 = *(_DWORD **)v80;
            }
            while ( v80 != (_DWORD *)v130 );
            v77 = v131;
          }
          RegSetValueExW(v76, L"RealFolderColumnWidths", 0, 3u, v78, 8 * v77);
          free(v79);
          v82 = v113;
          v83 = v137;
          v84 = (const BYTE *)malloc(8 * v137);
          v85 = (BYTE *)v84;
          v86 = (_QWORD *)*v136;
          if ( (_QWORD *)*v136 != v136 )
          {
            v87 = (BYTE *)v84;
            do
            {
              *(_DWORD *)v87 = *((_DWORD *)v86 + 4);
              *((_DWORD *)v87 + 1) = *((_DWORD *)v86 + 6);
              v87 += 8;
              v86 = (_QWORD *)*v86;
            }
            while ( v86 != v136 );
            v83 = v137;
          }
          RegSetValueExW(v82, L"RecycleBinColumnWidths", 0, 3u, v84, 8 * v83);
          free(v85);
          v88 = v113;
          v89 = v139;
          v90 = (const BYTE *)malloc(8 * v139);
          v91 = (BYTE *)v90;
          v92 = (_QWORD *)*v138;
          if ( (_QWORD *)*v138 != v138 )
          {
            v93 = (BYTE *)v90;
            do
            {
              *(_DWORD *)v93 = *((_DWORD *)v92 + 4);
              *((_DWORD *)v93 + 1) = *((_DWORD *)v92 + 6);
              v93 += 8;
              v92 = (_QWORD *)*v92;
            }
            while ( v92 != v138 );
            v89 = v139;
          }
          RegSetValueExW(v88, L"PrinterColumnWidths", 0, 3u, v90, 8 * v89);
          free(v91);
          v94 = v113;
          v95 = v141;
          v96 = (const BYTE *)malloc(8 * v141);
          v97 = (BYTE *)v96;
          v98 = (_QWORD *)*v140;
          if ( (_QWORD *)*v140 != v140 )
          {
            v99 = (BYTE *)v96;
            do
            {
              *(_DWORD *)v99 = *((_DWORD *)v98 + 4);
              *((_DWORD *)v99 + 1) = *((_DWORD *)v98 + 6);
              v99 += 8;
              v98 = (_QWORD *)*v98;
            }
            while ( v98 != v140 );
            v95 = v141;
          }
          RegSetValueExW(v94, L"NetworkColumnWidths", 0, 3u, v96, 8 * v95);
          free(v97);
          v100 = v113;
          v101 = v143;
          v102 = (const BYTE *)malloc(8 * v143);
          v103 = (BYTE *)v102;
          v104 = (_QWORD *)*v142;
          if ( (_QWORD *)*v142 != v142 )
          {
            v105 = (BYTE *)v102;
            do
            {
              *(_DWORD *)v105 = *((_DWORD *)v104 + 4);
              *((_DWORD *)v105 + 1) = *((_DWORD *)v104 + 6);
              v105 += 8;
              v104 = (_QWORD *)*v104;
            }
            while ( v104 != v142 );
            v101 = v143;
          }
          RegSetValueExW(v100, L"NetworkPlacesColumnWidths", 0, 3u, v102, 8 * v101);
          free(v103);
          sub_140017CA0((void **)&v130);
        }
        *(_DWORD *)v116 = *(_DWORD *)(532i64 * v129 + a1 + 7120);
        RegSetValueExW(phkResult, L"Locked", 0, 4u, v116, 4u);
        *(_DWORD *)v126 = *(_DWORD *)(532i64 * v129 + a1 + 7124);
        RegSetValueExW(phkResult, L"AddressLocked", 0, 4u, v126, 4u);
        *(_DWORD *)v121 = *(_DWORD *)(532i64 * v129 + a1 + 7128);
        RegSetValueExW(phkResult, L"UseCustomName", 0, 4u, v121, 4u);
        v106 = 532i64 * v129;
        if ( *(_DWORD *)(v106 + a1 + 7128) )
        {
          v107 = (const WCHAR *)(v106 + a1 + 7132);
          v108 = phkResult;
          v109 = lstrlenW(v107);
          RegSetValueExW(v108, L"CustomName", 0, 1u, (const BYTE *)v107, 2 * v109);
        }
        else
        {
          v110 = phkResult;
          v111 = lstrlenW(&::Data);
          RegSetValueExW(v110, L"CustomName", 0, 1u, (const BYTE *)&::Data, 2 * v111);
        }
        RegCloseKey(phkResult);
      }
    }
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F202C: using guessed type wchar_t aD_8[3];
// 1400A5E20: using guessed type LPARAM lParam[4];

//----- (00000001400A6C50) ----------------------------------------------------
LSTATUS __fastcall sub_1400A6C50(__int64 a1, HKEY a2, __int64 a3)
{
  HKEY v3; // rbx
  DWORD v5; // esi
  LSTATUS result; // eax
  LSTATUS v7; // esi
  __int64 v8; // rax
  LSTATUS v9; // ebx
  __int64 v10; // rax
  _QWORD *v11; // rbx
  __int64 v12; // rcx
  _QWORD *j; // rax
  __int64 v14; // rax
  _QWORD *v15; // rbx
  __int64 v16; // rcx
  _QWORD *i; // rax
  DWORD cbData; // [rsp+40h] [rbp-C0h] BYREF
  HKEY hKey; // [rsp+48h] [rbp-B8h] BYREF
  DWORD cchName; // [rsp+50h] [rbp-B0h] BYREF
  DWORD v21; // [rsp+54h] [rbp-ACh] BYREF
  DWORD v22; // [rsp+58h] [rbp-A8h] BYREF
  DWORD dwIndex; // [rsp+5Ch] [rbp-A4h]
  DWORD Type; // [rsp+60h] [rbp-A0h] BYREF
  LSTATUS v25; // [rsp+64h] [rbp-9Ch]
  __int64 v26; // [rsp+68h] [rbp-98h]
  HKEY v27; // [rsp+70h] [rbp-90h]
  BYTE v28[2]; // [rsp+80h] [rbp-80h] BYREF
  BYTE v29[2]; // [rsp+280h] [rbp+180h] BYREF
  char v30[4]; // [rsp+680h] [rbp+580h] BYREF
  BYTE Data[4]; // [rsp+684h] [rbp+584h] BYREF
  BYTE v32[2]; // [rsp+688h] [rbp+588h] BYREF
  __int64 v33; // [rsp+890h] [rbp+790h]
  WCHAR Name[256]; // [rsp+8A0h] [rbp+7A0h] BYREF

  v3 = a2;
  v27 = a2;
  v26 = a1;
  v5 = 0;
  cchName = 256;
  for ( result = RegEnumKeyExW(a2, 0, Name, &cchName, 0i64, 0i64, 0i64, 0i64);
        !result;
        result = RegEnumKeyExW(v27, dwIndex, Name, &cchName, 0i64, 0i64, 0i64, 0i64) )
  {
    dwIndex = v5 + 1;
    RegOpenKeyExW(v3, Name, 0, 0x20019u, &hKey);
    cbData = 4;
    v7 = RegQueryValueExW(hKey, L"Type", 0i64, 0i64, Data, &cbData);
    cbData = 256;
    v25 = RegQueryValueExW(hKey, L"Name", 0i64, &Type, v28, &cbData);
    if ( cbData && Type == 1 )
    {
      if ( *(_WORD *)&v28[2 * cbData - 2] )
      {
        v8 = 256i64;
        if ( cbData < 0x100 )
          v8 = cbData;
        *(_WORD *)&v28[2 * v8] = 0;
      }
    }
    else
    {
      *(_WORD *)v28 = 0;
    }
    cbData = 4;
    v9 = RegQueryValueExW(hKey, L"ShowOnBookmarksToolbar", 0i64, 0i64, (LPBYTE)v30, &cbData);
    cbData = 512;
    RegQueryValueExW(hKey, L"Description", 0i64, &v22, v29, &cbData);
    if ( cbData && v22 == 1 )
    {
      if ( *(_WORD *)&v29[2 * cbData - 2] )
      {
        v10 = 512i64;
        if ( cbData < 0x200 )
          v10 = cbData;
        *(_WORD *)&v29[2 * v10] = 0;
      }
    }
    else
    {
      *(_WORD *)v29 = 0;
    }
    if ( !v7 && !v25 && !v9 )
    {
      if ( *(_DWORD *)Data )
      {
        cbData = 260;
        RegQueryValueExW(hKey, L"Location", 0i64, &v21, v32, &cbData);
        if ( cbData && v21 == 1 )
        {
          if ( *(_WORD *)&v32[2 * cbData - 2] )
          {
            v14 = 260i64;
            if ( cbData < 0x104 )
              v14 = cbData;
            *(_WORD *)&v32[2 * v14] = 0;
          }
        }
        else
        {
          *(_WORD *)v32 = 0;
        }
        v15 = malloc(0x830ui64);
        sub_14007D850((__int64)v15, (__int64)v28);
        v15[258] = a3;
        v16 = *(_QWORD *)(a3 + 2088);
        if ( v16 )
        {
          for ( i = (_QWORD *)(v16 + 2080); *i; i = (_QWORD *)(*i + 2080i64) )
            v16 = *i;
          *(_QWORD *)(v16 + 2080) = v15;
          v15[259] = v16;
        }
        else
        {
          *(_QWORD *)(a3 + 2088) = v15;
          v15[259] = 0i64;
        }
      }
      else
      {
        v11 = malloc(0x830ui64);
        sub_14007D850((__int64)v11, (__int64)v28);
        v11[258] = a3;
        v12 = *(_QWORD *)(a3 + 2088);
        if ( v12 )
        {
          for ( j = (_QWORD *)(v12 + 2080); *j; j = (_QWORD *)(*j + 2080i64) )
            v12 = *j;
          *(_QWORD *)(v12 + 2080) = v11;
          v11[259] = v12;
        }
        else
        {
          *(_QWORD *)(a3 + 2088) = v11;
          v11[259] = 0i64;
        }
        sub_1400A6C50(v26, hKey, v33);
      }
    }
    RegCloseKey(hKey);
    v5 = dwIndex;
    v3 = v27;
    cchName = 256;
  }
  return result;
}
// 1400A6C50: using guessed type BYTE var_440[4];

//----- (00000001400A7070) ----------------------------------------------------
LSTATUS __fastcall sub_1400A7070(__int64 a1)
{
  LSTATUS result; // eax
  HKEY hKey; // [rsp+30h] [rbp-848h] BYREF
  char v4[2064]; // [rsp+40h] [rbp-838h] BYREF
  __int64 v5; // [rsp+850h] [rbp-28h]

  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Bookmarks", 0, 0x20019u, &hKey);
  if ( !result )
  {
    sub_14007DA80(a1 + 2664, (__int64)v4);
    sub_1400A6C50(a1, hKey, v5);
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400A7070: using guessed type char var_838[2064];

//----- (00000001400A7110) ----------------------------------------------------
__int64 __fastcall sub_1400A7110(__int64 a1)
{
  LSTATUS v1; // edi
  LSTATUS v3; // er12
  LSTATUS v4; // er13
  LSTATUS v5; // er14
  unsigned int v6; // esi
  _WORD *v7; // r12
  __int64 v8; // rdi
  HFONT v9; // r11
  BYTE v10; // edx^2
  BYTE v11; // al
  unsigned int v12; // er8
  HKEY v13; // rcx
  DWORD cbData; // [rsp+70h] [rbp-90h] BYREF
  HKEY hKey; // [rsp+78h] [rbp-88h] BYREF
  DWORD Type; // [rsp+80h] [rbp-80h] BYREF
  DWORD v18; // [rsp+84h] [rbp-7Ch] BYREF
  DWORD lpcbData; // [rsp+88h] [rbp-78h] BYREF
  BYTE v20[4]; // [rsp+8Ch] [rbp-74h] BYREF
  BYTE Data[4]; // [rsp+90h] [rbp-70h] BYREF
  BYTE v22[4]; // [rsp+94h] [rbp-6Ch] BYREF
  LOGFONTW v23; // [rsp+A0h] [rbp-60h] BYREF

  v1 = 1;
  v3 = 1;
  v4 = 1;
  v5 = 1;
  v6 = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\Settings", 0, 0x20019u, &hKey);
  if ( !v6 )
  {
    cbData = 4;
    RegQueryValueExW(hKey, L"LastSelectedTab", 0i64, 0i64, (LPBYTE)(a1 + 7056), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowExtensions", 0i64, 0i64, (LPBYTE)(a1 + 60944), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowStatusBar", 0i64, 0i64, (LPBYTE)(a1 + 60744), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowFolders", 0i64, 0i64, (LPBYTE)(a1 + 60748), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowAddressBar", 0i64, 0i64, (LPBYTE)(a1 + 60752), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowToolbar", 0i64, 0i64, (LPBYTE)(a1 + 60760), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowBookmarksToolbar", 0i64, 0i64, (LPBYTE)(a1 + 60764), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowDrivesToolbar", 0i64, 0i64, (LPBYTE)(a1 + 60768), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowApplicationToolbar", 0i64, 0i64, (LPBYTE)(a1 + 60772), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowFullTitlePath", 0i64, 0i64, (LPBYTE)(a1 + 60784), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"AlwaysOpenNewTab", 0i64, 0i64, (LPBYTE)(a1 + 60788), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"TreeViewWidth", 0i64, 0i64, (LPBYTE)(a1 + 7044), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowFriendlyDates", 0i64, 0i64, (LPBYTE)(a1 + 60960), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowDisplayWindow", 0i64, 0i64, (LPBYTE)(a1 + 60756), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowFolderSizes", 0i64, 0i64, (LPBYTE)(a1 + 60792), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"DisableFolderSizesNetworkRemovable", 0i64, 0i64, (LPBYTE)(a1 + 60796), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"StartupMode", 0i64, 0i64, (LPBYTE)(a1 + 60920), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"NextToCurrent", 0i64, 0i64, (LPBYTE)(a1 + 60804), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ConfirmCloseTabs", 0i64, 0i64, (LPBYTE)(a1 + 60808), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowInfoTips", 0i64, 0i64, (LPBYTE)(a1 + 60928), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"InfoTipType", 0i64, 0i64, (LPBYTE)(a1 + 60932), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"TreeViewDelayEnabled", 0i64, 0i64, (LPBYTE)(a1 + 60812), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"LockToolbars", 0i64, 0i64, (LPBYTE)(a1 + 60820), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ExtendTabControl", 0i64, 0i64, (LPBYTE)(a1 + 60824), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"UseFullRowSelect", 0i64, 0i64, (LPBYTE)(a1 + 60828), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowFilePreviews", 0i64, 0i64, (LPBYTE)(a1 + 60840), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ReplaceExplorerMode", 0i64, 0i64, (LPBYTE)(a1 + 60924), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowUserNameTitleBar", 0i64, 0i64, (LPBYTE)(a1 + 60832), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"AllowMultipleInstances", 0i64, 0i64, (LPBYTE)(a1 + 60852), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"OneClickActivate", 0i64, 0i64, (LPBYTE)(a1 + 60844), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"OneClickActivateHoverTime", 0i64, 0i64, (LPBYTE)(a1 + 60848), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ForceSameTabWidth", 0i64, 0i64, (LPBYTE)(a1 + 60856), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"DoubleClickTabClose", 0i64, 0i64, (LPBYTE)(a1 + 60860), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"HandleZipFiles", 0i64, 0i64, (LPBYTE)(a1 + 60864), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"InsertSorted", 0i64, 0i64, (LPBYTE)(a1 + 60868), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowPrivilegeLevelInTitleBar", 0i64, 0i64, (LPBYTE)(a1 + 60836), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"AlwaysShowTabBar", 0i64, 0i64, (LPBYTE)(a1 + 60776), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"CheckBoxSelection", 0i64, 0i64, (LPBYTE)(a1 + 60876), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ForceSize", 0i64, 0i64, (LPBYTE)(a1 + 60880), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"SizeDisplayFormat", 0i64, 0i64, (LPBYTE)(a1 + 60916), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"CloseMainWindowOnTabClose", 0i64, 0i64, (LPBYTE)(a1 + 60884), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowTabBarAtBottom", 0i64, 0i64, (LPBYTE)(a1 + 60888), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"ShowTaskbarThumbnails", 0i64, 0i64, (LPBYTE)(a1 + 60892), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"SynchronizeTreeview", 0i64, 0i64, (LPBYTE)(a1 + 60900), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"TVAutoExpandSelected", 0i64, 0i64, (LPBYTE)(a1 + 60904), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"OverwriteExistingFilesConfirmation", 0i64, 0i64, (LPBYTE)(a1 + 60872), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"LargeToolbarIcons", 0i64, 0i64, (LPBYTE)(a1 + 60908), &cbData);
    cbData = 4;
    RegQueryValueExW(hKey, L"PlayNavigationSound", 0i64, 0i64, (LPBYTE)(a1 + 60912), &cbData);
    v7 = (_WORD *)(a1 + 5960);
    v8 = 260i64;
    cbData = 260;
    RegQueryValueExW(hKey, L"NewTabDirectory", 0i64, &Type, (LPBYTE)(a1 + 5960), &cbData);
    if ( cbData && Type == 1 )
    {
      if ( v7[cbData - 1] )
      {
        if ( cbData < 0x104 )
          v8 = cbData;
        v7[v8] = 0;
      }
    }
    else
    {
      *v7 = 0;
    }
    Type = 4;
    if ( !RegQueryValueExW(hKey, L"Language", 0i64, 0i64, (LPBYTE)(a1 + 7000), &Type) )
      *(_DWORD *)(a1 + 7036) = 1;
    Type = 4;
    RegQueryValueExW(hKey, L"ShowHiddenGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60940), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"ViewModeGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60936), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"ShowGridlinesGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60964), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"ShowInGroupsGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60948), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"AutoArrangeGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60952), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"SortAscendingGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60956), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"HideSystemFilesGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60968), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"HideLinkExtensionGlobal", 0i64, 0i64, (LPBYTE)(a1 + 60972), &Type);
    Type = 4;
    RegQueryValueExW(hKey, L"DisplayWindowHeight", 0i64, 0i64, (LPBYTE)(a1 + 7012), &Type);
    v18 = 3;
    lpcbData = 4;
    v3 = RegQueryValueExW(hKey, L"DisplaySurroundColor", 0i64, &v18, Data, &lpcbData);
    v18 = 3;
    lpcbData = 4;
    v1 = RegQueryValueExW(hKey, L"DisplayCentreColor", 0i64, &v18, v20, &lpcbData);
    v18 = 3;
    lpcbData = 4;
    v4 = RegQueryValueExW(hKey, L"DisplayTextColor", 0i64, &v18, v22, &lpcbData);
    v18 = 3;
    lpcbData = 92;
    v5 = RegQueryValueExW(hKey, L"DisplayFont", 0i64, &v18, (LPBYTE)&v23, &lpcbData);
    v9 = CreateFontIndirectW(&v23);
    v10 = Data[2];
    v11 = Data[1];
    v12 = (Data[0] | 0xFFFFFF00) << 8;
    *(_DWORD *)(a1 + 7100) = v20[2] | ((v20[1] | ((v20[0] | 0xFFFFFF00) << 8)) << 8);
    v13 = hKey;
    *(_QWORD *)(a1 + 7112) = v9;
    *(_DWORD *)(a1 + 7032) = 1;
    *(_DWORD *)(a1 + 7108) = *(_DWORD *)v22;
    *(_DWORD *)(a1 + 7104) = v10 | ((v11 | v12) << 8);
    RegCloseKey(v13);
  }
  sub_1400BCEA0(a1);
  if ( v3 )
    *(_DWORD *)(a1 + 7104) = -16753014;
  if ( v1 )
    *(_DWORD *)(a1 + 7100) = -1;
  if ( v4 )
    *(_DWORD *)(a1 + 7108) = 0;
  if ( v5 )
    *(_QWORD *)(a1 + 7112) = CreateFontW(-13, 0, 0, 0, 500, 0, 0, 0, 1u, 0, 0, 2u, 0x31u, L"Segoe UI");
  return v6;
}
// 1400A7110: using guessed type LOGFONTW var_90;

//----- (00000001400A8080) ----------------------------------------------------
LSTATUS __fastcall sub_1400A8080(__int64 a1)
{
  return sub_1400A5690(*(_QWORD **)(a1 + 16));
}

//----- (00000001400A8090) ----------------------------------------------------
LSTATUS __fastcall sub_1400A8090(__int64 a1)
{
  return sub_1400A5E20(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A80A0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A80A0(__int64 a1)
{
  __int64 v1; // rbx
  LSTATUS result; // eax
  HKEY hKey; // [rsp+40h] [rbp+8h] BYREF

  v1 = *(_QWORD *)(a1 + 16);
  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ApplicationToolbar", 0, 0x20019u, &hKey);
  if ( !result )
  {
    sub_1400A53B0(v1, hKey);
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A8100) ----------------------------------------------------
LSTATUS __fastcall sub_1400A8100(__int64 a1)
{
  return sub_1400A7070(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A8110) ----------------------------------------------------
__int64 __fastcall sub_1400A8110(__int64 a1)
{
  return sub_1400A7110(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A8120) ----------------------------------------------------
DWORD __fastcall sub_1400A8120(HKEY a1, const WCHAR *a2, __int64 *a3)
{
  DWORD result; // eax
  DWORD v5; // edi
  int *v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdx
  char *v9; // rax
  __int64 v10; // rdx
  DWORD cbData; // [rsp+30h] [rbp-258h] BYREF
  DWORD Type; // [rsp+34h] [rbp-254h] BYREF
  int v13[6]; // [rsp+38h] [rbp-250h] BYREF
  char Data[4]; // [rsp+50h] [rbp-238h] BYREF
  char v15; // [rsp+54h] [rbp-234h] BYREF

  Type = 3;
  cbData = 512;
  result = RegQueryValueExW(a1, a2, 0i64, &Type, (LPBYTE)Data, &cbData);
  v5 = 0;
  if ( (cbData & 0xFFFFFFF8) != 0 )
  {
    v13[2] = 150;
    v6 = (int *)&v15;
    do
    {
      v7 = *a3;
      v8 = *(_QWORD *)(*a3 + 8);
      v13[0] = *(v6 - 1);
      v13[1] = *v6;
      v9 = sub_140017AD0(v7, v8, v13);
      v10 = a3[1];
      if ( v10 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      ++v5;
      v6 += 2;
      a3[1] = v10 + 1;
      *(_QWORD *)(v7 + 8) = v9;
      **((_QWORD **)v9 + 1) = v9;
      result = cbData >> 3;
    }
    while ( v5 < cbData >> 3 );
  }
  return result;
}
// 1400A8120: using guessed type BYTE Data[4];

//----- (00000001400A8250) ----------------------------------------------------
DWORD __fastcall sub_1400A8250(HKEY a1, const WCHAR *a2, __int64 *a3)
{
  DWORD result; // eax
  DWORD v5; // ebx
  int *v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rdx
  char *v9; // rax
  __int64 v10; // rdx
  DWORD cbData; // [rsp+30h] [rbp-258h] BYREF
  DWORD Type; // [rsp+34h] [rbp-254h] BYREF
  int v13[6]; // [rsp+38h] [rbp-250h] BYREF
  char Data[4]; // [rsp+50h] [rbp-238h] BYREF
  char v15; // [rsp+54h] [rbp-234h] BYREF

  Type = 3;
  cbData = 512;
  result = RegQueryValueExW(a1, a2, 0i64, &Type, (LPBYTE)Data, &cbData);
  if ( !result )
  {
    v5 = 0;
    if ( (cbData & 0xFFFFFFF8) != 0 )
    {
      v6 = (int *)&v15;
      do
      {
        v7 = *a3;
        v8 = *(_QWORD *)(*a3 + 8);
        v13[0] = *(v6 - 1);
        v13[2] = *v6;
        v9 = sub_140017AD0(v7, v8, v13);
        v10 = a3[1];
        if ( v10 == 0x1555555555555554i64 )
          sub_14002B5F8("list<T> too long");
        ++v5;
        v6 += 2;
        a3[1] = v10 + 1;
        *(_QWORD *)(v7 + 8) = v9;
        **((_QWORD **)v9 + 1) = v9;
        result = cbData >> 3;
      }
      while ( v5 < cbData >> 3 );
    }
  }
  return result;
}
// 1400A8250: using guessed type BYTE Data[4];

//----- (00000001400A8C10) ----------------------------------------------------
__int64 __fastcall sub_1400A8C10(__int64 a1)
{
  return sub_1400A83A0(*(_QWORD *)(a1 + 16));
}
// 1400A83A0: using guessed type __int64 __fastcall sub_1400A83A0(_QWORD);

//----- (00000001400A8C20) ----------------------------------------------------
LSTATUS __fastcall sub_1400A8C20(__int64 a1)
{
  LSTATUS result; // eax
  int v3; // esi
  __int64 v4; // rdi
  __int64 i; // rbx
  HKEY hKey; // [rsp+50h] [rbp-98h] BYREF
  DWORD dwDisposition; // [rsp+58h] [rbp-90h] BYREF
  __int64 v8; // [rsp+60h] [rbp-88h]
  void *Src[3]; // [rsp+70h] [rbp-78h] BYREF
  unsigned __int64 v10; // [rsp+88h] [rbp-60h]
  void *Block; // [rsp+98h] [rbp-50h] BYREF
  __int64 v12; // [rsp+A8h] [rbp-40h]
  unsigned __int64 v13; // [rsp+B0h] [rbp-38h]
  int v14; // [rsp+C0h] [rbp-28h]
  int v15; // [rsp+C4h] [rbp-24h]

  v8 = -2i64;
  SHDeleteKeyW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ColorRules");
  result = RegCreateKeyExW(
             HKEY_CURRENT_USER,
             L"Software\\Explorer++\\ColorRules",
             0,
             0i64,
             0,
             0x20006u,
             0i64,
             &hKey,
             &dwDisposition);
  v3 = 0;
  if ( !result )
  {
    v4 = *(_QWORD *)(a1 + 80);
    for ( i = *(_QWORD *)(a1 + 72); i != v4; i += 88i64 )
    {
      v10 = 7i64;
      Src[2] = 0i64;
      LOWORD(Src[0]) = 0;
      sub_140009610(Src, (_QWORD *)i, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v13 = 7i64;
      v12 = 0i64;
      LOWORD(Block) = 0;
      sub_140009610(&Block, (_QWORD *)(i + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v14 = *(_DWORD *)(i + 80);
      v15 = *(_DWORD *)(i + 84);
      sub_1400A4CD0(hKey, (__int64)Src, v3++);
      if ( v13 >= 8 )
        j_free(Block);
      v13 = 7i64;
      v12 = 0i64;
      LOWORD(Block) = 0;
      if ( v10 >= 8 )
        j_free(Src[0]);
    }
    return RegCloseKey(hKey);
  }
  return result;
}

//----- (00000001400A8DF0) ----------------------------------------------------
LSTATUS __fastcall sub_1400A8DF0(__int64 a1)
{
  return sub_1400A8C20(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A9170) ----------------------------------------------------
LSTATUS __fastcall sub_1400A9170(__int64 a1)
{
  LSTATUS result; // eax
  _DWORD *v3; // rcx
  _DWORD *v4; // r8
  _QWORD *v5; // rbx
  HKEY hKey; // [rsp+48h] [rbp+10h] BYREF

  result = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Explorer++\\ColorRules", 0, 0x20019u, &hKey);
  if ( !result )
  {
    v3 = *(_DWORD **)(a1 + 80);
    v4 = *(_DWORD **)(a1 + 72);
    if ( v4 != v3 )
    {
      v5 = sub_14000A200(v3, *(_DWORD **)(a1 + 80), v4);
      sub_14000A280(v5, *(_QWORD **)(a1 + 80));
      *(_QWORD *)(a1 + 80) = v5;
    }
    sub_1400A8E00(a1, hKey);
    return RegCloseKey(hKey);
  }
  return result;
}
// 1400A8E00: using guessed type __int64 __fastcall sub_1400A8E00(_QWORD, _QWORD);

//----- (00000001400A9200) ----------------------------------------------------
LSTATUS __fastcall sub_1400A9200(__int64 a1)
{
  return sub_1400A9170(*(_QWORD *)(a1 + 16));
}

//----- (00000001400A9950) ----------------------------------------------------
__int64 __fastcall sub_1400A9950(__int64 a1)
{
  return sub_1400A9590(*(_QWORD *)(a1 + 16));
}
// 1400A9590: using guessed type __int64 __fastcall sub_1400A9590(_QWORD);

//----- (00000001400A9960) ----------------------------------------------------
__int64 __fastcall sub_1400A9960(__int64 a1)
{
  return sub_1400A9210(*(_QWORD *)(a1 + 16));
}
// 1400A9210: using guessed type __int64 __fastcall sub_1400A9210(_QWORD);

//----- (00000001400AB0A0) ----------------------------------------------------
__int64 __fastcall sub_1400AB0A0(__int64 a1)
{
  return sub_1400A9970(*(_QWORD *)(a1 + 16));
}
// 1400A9970: using guessed type __int64 __fastcall sub_1400A9970(_QWORD);

//----- (00000001400AB0B0) ----------------------------------------------------
__int64 __fastcall sub_1400AB0B0(_DWORD *a1, HWND a2)
{
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetWindowRect(a2, &Rect);
  result = (unsigned int)Rect.top;
  a1[15771] = Rect.left;
  a1[15772] = result;
  a1[15770] = 1;
  return result;
}

//----- (00000001400AB120) ----------------------------------------------------
int __fastcall sub_1400AB120(HWND hWnd)
{
  HWND DlgItem; // rbx
  DWORD MessagePos; // eax
  LONG v4; // esi
  int v5; // ebp
  int result; // eax
  HMODULE ModuleHandleW; // rax
  HMENU MenuW; // rbx
  HMENU SubMenu; // rax
  struct tagPOINT Point; // [rsp+40h] [rbp-28h] BYREF
  char v11; // [rsp+48h] [rbp-20h]
  int v12; // [rsp+4Ch] [rbp-1Ch]

  DlgItem = GetDlgItem(hWnd, 1114);
  MessagePos = GetMessagePos();
  v4 = (__int16)MessagePos;
  MessagePos >>= 16;
  v5 = (__int16)MessagePos;
  Point.x = v4;
  Point.y = (__int16)MessagePos;
  ScreenToClient(DlgItem, &Point);
  result = SendMessageW(DlgItem, 0x1012u, 0i64, (LPARAM)&Point);
  if ( (v11 & 1) == 0 && v12 != -1 )
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    MenuW = LoadMenuW(ModuleHandleW, (LPCWSTR)0xD4);
    SubMenu = GetSubMenu(MenuW, 0);
    dword_14012DA00 = v12;
    hMenu = SubMenu;
    TrackPopupMenu(SubMenu, 0, v4, v5, 0, hWnd, 0i64);
    return DestroyMenu(MenuW);
  }
  return result;
}
// 14012DA00: using guessed type int dword_14012DA00;

//----- (00000001400AB230) ----------------------------------------------------
LRESULT __fastcall sub_1400AB230(HWND a1, __int64 a2)
{
  HWND DlgItem; // rdi
  LPARAM v4; // rax
  LRESULT result; // rax
  LPARAM v6; // rbx
  LPARAM lParam[9]; // [rsp+20h] [rbp-48h] BYREF

  DlgItem = GetDlgItem(a1, 1175);
  v4 = SendMessageW(DlgItem, 0x110Au, 9ui64, 0i64);
  result = SendMessageW(DlgItem, 0x110Au, 4ui64, v4);
  v6 = result;
  if ( result )
  {
    while ( 1 )
    {
      LODWORD(lParam[0]) = 4;
      lParam[1] = v6;
      SendMessageW(DlgItem, 0x113Eu, 0i64, (LPARAM)lParam);
      if ( lParam[6] == a2 )
        break;
      result = SendMessageW(DlgItem, 0x110Au, 1ui64, v6);
      v6 = result;
      if ( !result )
        return result;
    }
    return SendMessageW(DlgItem, 0x110Bu, 9ui64, v6);
  }
  return result;
}

//----- (00000001400AB310) ----------------------------------------------------
int __fastcall sub_1400AB310(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  int result; // eax
  __int64 v6; // rcx
  int v7; // ebx
  void *pv[2]; // [rsp+30h] [rbp-10C8h] BYREF
  _DWORD lParam[10]; // [rsp+40h] [rbp-10B8h] BYREF
  __int64 v10; // [rsp+68h] [rbp-1090h]
  char v11[1540]; // [rsp+90h] [rbp-1068h] BYREF
  int v12; // [rsp+694h] [rbp-A64h]
  char v13[520]; // [rsp+698h] [rbp-A60h] BYREF
  __int64 v14; // [rsp+8A0h] [rbp-858h]
  char v15[2080]; // [rsp+8B0h] [rbp-848h] BYREF

  DlgItem = GetDlgItem(a2, 1114);
  result = dword_14012DA00;
  if ( dword_14012DA00 != -1 )
  {
    lParam[2] = 0;
    lParam[0] = 4;
    lParam[1] = dword_14012DA00;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    result = sub_14007D720(v10, (__int64)v11);
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        pv[0] = 0i64;
        v7 = sub_14007F810((__int64)v13, (__int64)pv);
        (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)(a1 + 56) + 80i64))(a1 + 56, pv[0], 1i64);
        if ( v7 >= 0 )
          CoTaskMemFree(pv[0]);
        return EndDialog(a2, 1i64);
      }
    }
    else
    {
      result = SendMessageW(DlgItem, 0x1009u, 0i64, 0i64);
      if ( !*(_DWORD *)(v14 + 1540) )
      {
        v6 = *(_QWORD *)(v14 + 2088);
        if ( v6 )
        {
          sub_14007D720(v6, (__int64)v15);
          return sub_1400CAC10(DlgItem, v15);
        }
      }
    }
  }
  return result;
}
// 14012DA00: using guessed type int dword_14012DA00;
// 1400AB310: using guessed type char var_1068[1540];
// 1400AB310: using guessed type LPVOID pv[2];
// 1400AB310: using guessed type char var_A60[520];

//----- (00000001400AB4B0) ----------------------------------------------------
HWND __fastcall sub_1400AB4B0(__int64 a1, HWND a2)
{
  HWND result; // rax
  int v4; // ebx
  int v5; // eax
  __int64 v6; // rcx
  _DWORD lParam[10]; // [rsp+20h] [rbp-888h] BYREF
  __int64 v8; // [rsp+48h] [rbp-860h]
  char v9[1536]; // [rsp+70h] [rbp-838h] BYREF
  int v10; // [rsp+670h] [rbp-238h]
  __int64 v11; // [rsp+880h] [rbp-28h]

  result = GetDlgItem(a2, 1114);
  if ( dword_14012DA00 != -1 )
  {
    lParam[1] = dword_14012DA00;
    v4 = 0;
    lParam[0] = 4;
    lParam[2] = 0;
    result = (HWND)SendMessageW(result, 0x104Bu, 0i64, (LPARAM)lParam);
    if ( (_DWORD)result )
    {
      sub_14007D720(v8, (__int64)v9);
      LOBYTE(v4) = v10 == 0;
      v10 = v4;
      if ( v4 )
      {
        v5 = sub_1400CA6E0(a1);
        sub_1400CA8E0(v6, (__int64)v9, v5);
      }
      else
      {
        sub_1400CA550(a1, v11);
      }
      return (HWND)sub_14007D5F0(v11, (__int64)v9);
    }
  }
  return result;
}
// 1400AB556: variable 'v6' is possibly undefined
// 14012DA00: using guessed type int dword_14012DA00;

//----- (00000001400AB5B0) ----------------------------------------------------
int __fastcall sub_1400AB5B0(HWND a1, HMENU a2)
{
  HWND DlgItem; // rax
  UINT v4; // er8
  _DWORD lParam[10]; // [rsp+20h] [rbp-888h] BYREF
  __int64 v7; // [rsp+48h] [rbp-860h]
  char v8[1536]; // [rsp+70h] [rbp-838h] BYREF
  int v9; // [rsp+670h] [rbp-238h]

  DlgItem = GetDlgItem(a1, 1114);
  if ( a2 == hMenu && dword_14012DA00 != -1 )
  {
    lParam[1] = dword_14012DA00;
    lParam[0] = 4;
    lParam[2] = 0;
    LODWORD(DlgItem) = SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    if ( (_DWORD)DlgItem )
    {
      sub_14007D720(v7, (__int64)v8);
      if ( v9 )
        v4 = 8;
      else
        v4 = 0;
      LODWORD(DlgItem) = CheckMenuItem(hMenu, 0x9D88u, v4);
    }
  }
  return (int)DlgItem;
}
// 14012DA00: using guessed type int dword_14012DA00;
// 1400AB5B0: using guessed type char var_838[1536];

//----- (00000001400AB670) ----------------------------------------------------
HWND __fastcall sub_1400AB670(__int64 a1, HWND a2)
{
  HWND DlgItem; // rdi
  int v5; // ebp
  HWND result; // rax
  int v7; // ebx
  _DWORD lParam[10]; // [rsp+20h] [rbp-8E8h] BYREF
  __int64 v9; // [rsp+48h] [rbp-8C0h]
  LPARAM v10; // [rsp+70h] [rbp-898h] BYREF
  int v11; // [rsp+7Ch] [rbp-88Ch]
  int v12; // [rsp+80h] [rbp-888h]
  char v13[1536]; // [rsp+C0h] [rbp-848h] BYREF
  int v14; // [rsp+6C0h] [rbp-248h]
  __int64 v15; // [rsp+8D0h] [rbp-38h]

  DlgItem = GetDlgItem(a2, 1114);
  v5 = SendMessageW(DlgItem, 0x1004u, 0i64, 0i64);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v7 = (int)result;
  if ( (_DWORD)result != -1 )
  {
    lParam[0] = 4;
    lParam[1] = (_DWORD)result;
    lParam[2] = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    sub_14007D720(v9, (__int64)v13);
    result = (HWND)sub_1400CA4B0(a1, a2, v9);
    if ( (_DWORD)result )
    {
      if ( v14 )
        sub_1400CA550(a1, v15);
      dword_14012DB34 = 1;
      SendMessageW(DlgItem, 0x1008u, v7, 0i64);
      sub_1400CB360(a1);
      if ( v7 == v5 - 1 )
        --v7;
      v12 = 2;
      v11 = 2;
      SendMessageW(DlgItem, 0x102Bu, v7, (LPARAM)&v10);
      return SetFocus(DlgItem);
    }
  }
  return result;
}
// 14012DB34: using guessed type int dword_14012DB34;
// 1400AB670: using guessed type char var_848[1536];

//----- (00000001400AB7F0) ----------------------------------------------------
__int64 __fastcall sub_1400AB7F0(HWND a1, __int64 a2)
{
  HWND DlgItem; // rbx
  __int64 result; // rax
  __int64 v6; // rcx
  char v7[2064]; // [rsp+20h] [rbp-1058h] BYREF
  __int64 v8; // [rsp+830h] [rbp-848h]
  char v9[2080]; // [rsp+840h] [rbp-838h] BYREF

  GetDlgItem(a1, 1175);
  DlgItem = GetDlgItem(a1, 1114);
  SendMessageW(DlgItem, 0x1009u, 0i64, 0i64);
  result = sub_14007D720(*(_QWORD *)(a2 + 136), (__int64)v7);
  if ( !*(_DWORD *)(v8 + 1540) )
  {
    v6 = *(_QWORD *)(v8 + 2088);
    if ( v6 )
    {
      sub_14007D720(v6, (__int64)v9);
      return sub_1400CAC10(DlgItem, v9);
    }
  }
  return result;
}
// 1400AB7F0: using guessed type char var_1058[2064];

//----- (00000001400AB8C0) ----------------------------------------------------
int __fastcall sub_1400AB8C0(__int64 a1, HWND a2, __int64 a3)
{
  HWND DlgItem; // rdi
  int result; // eax
  __int64 v8; // rbx
  __int64 v9; // rcx
  int v10; // ebx
  void *pv[2]; // [rsp+30h] [rbp-10D8h] BYREF
  _DWORD lParam[10]; // [rsp+40h] [rbp-10C8h] BYREF
  __int64 v13; // [rsp+68h] [rbp-10A0h]
  char v14[1540]; // [rsp+90h] [rbp-1078h] BYREF
  int v15; // [rsp+694h] [rbp-A74h]
  char v16[520]; // [rsp+698h] [rbp-A70h] BYREF
  __int64 v17; // [rsp+8A0h] [rbp-868h]
  char v18[2080]; // [rsp+8B0h] [rbp-858h] BYREF

  DlgItem = GetDlgItem(a2, 1114);
  result = *(_DWORD *)(a3 + 24);
  if ( result != -1 )
  {
    lParam[2] = 0;
    lParam[0] = 4;
    lParam[1] = result;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
    result = sub_14007D720(v13, (__int64)v14);
    if ( v15 )
    {
      if ( v15 == 1 )
      {
        pv[0] = 0i64;
        v10 = sub_14007F810((__int64)v16, (__int64)pv);
        (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)(a1 + 56) + 80i64))(a1 + 56, pv[0], 1i64);
        if ( v10 >= 0 )
          CoTaskMemFree(pv[0]);
        return EndDialog(a2, 1i64);
      }
    }
    else
    {
      SendMessageW(DlgItem, 0x1009u, 0i64, 0i64);
      v8 = v17;
      if ( !*(_DWORD *)(v17 + 1540) )
      {
        v9 = *(_QWORD *)(v17 + 2088);
        if ( v9 )
        {
          sub_14007D720(v9, (__int64)v18);
          sub_1400CAC10(DlgItem, v18);
        }
      }
      return sub_1400AB230(a2, v8);
    }
  }
  return result;
}
// 1400AB8C0: using guessed type char var_1078[1540];
// 1400AB8C0: using guessed type LPVOID pv[2];
// 1400AB8C0: using guessed type char var_A70[520];

//----- (00000001400ABA40) ----------------------------------------------------
BOOL __fastcall sub_1400ABA40(_DWORD *a1, HWND a2)
{
  LONG top; // eax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  sub_1400CB360((__int64)a1);
  GetWindowRect(a2, &Rect);
  top = Rect.top;
  a1[15771] = Rect.left;
  a1[15772] = top;
  a1[15770] = 1;
  return EndDialog(a2, 1i64);
}

//----- (00000001400ABAC0) ----------------------------------------------------
LRESULT __fastcall sub_1400ABAC0(HWND a1, int a2)
{
  HWND DlgItem; // rsi
  LRESULT result; // rax
  int v5; // ebx
  int v6; // edi
  int lParam; // [rsp+20h] [rbp-10A8h] BYREF
  int lParam_4; // [rsp+24h] [rbp-10A4h]
  int v9; // [rsp+28h] [rbp-10A0h]
  __int64 v10; // [rsp+48h] [rbp-1080h]
  char v11[2080]; // [rsp+70h] [rbp-1058h] BYREF
  char v12[2080]; // [rsp+890h] [rbp-838h] BYREF

  DlgItem = GetDlgItem(a1, 1114);
  result = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v5 = result;
  if ( (_DWORD)result != -1 )
  {
    lParam = 4;
    lParam_4 = result;
    v9 = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)&lParam);
    result = sub_14007D720(v10, (__int64)v12);
    if ( a2 )
    {
      if ( !v5 )
        return result;
      v6 = v5 - 1;
    }
    else
    {
      result = (unsigned int)SendMessageW(DlgItem, 0x1004u, 0i64, 0i64) - 1;
      if ( v5 == (_DWORD)result )
        return result;
      v6 = v5 + 1;
    }
    lParam = 4;
    lParam_4 = v6;
    v9 = 0;
    SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)&lParam);
    sub_14007D720(v10, (__int64)v11);
    sub_14007D240((__int64)v12, (__int64)v11);
    return sub_140080B70(DlgItem, v5, v6);
  }
  return result;
}

//----- (00000001400ABC10) ----------------------------------------------------
LRESULT __fastcall sub_1400ABC10(HWND a1, int a2)
{
  WPARAM v2; // rbx
  HWND DlgItem; // rdi
  LPARAM v5; // [rsp+20h] [rbp-8D8h] BYREF
  int v6; // [rsp+28h] [rbp-8D0h]
  char *v7; // [rsp+38h] [rbp-8C0h]
  _DWORD lParam[10]; // [rsp+70h] [rbp-888h] BYREF
  __int64 v9; // [rsp+98h] [rbp-860h]
  char v10[512]; // [rsp+C0h] [rbp-838h] BYREF
  char v11; // [rsp+2C0h] [rbp-638h] BYREF
  int v12; // [rsp+6C4h] [rbp-234h]
  char v13; // [rsp+6C8h] [rbp-230h] BYREF

  v2 = a2;
  lParam[0] = 4;
  DlgItem = GetDlgItem(a1, 1114);
  lParam[1] = v2;
  lParam[2] = 0;
  SendMessageW(DlgItem, 0x104Bu, 0i64, (LPARAM)lParam);
  sub_14007D720(v9, (__int64)v10);
  v7 = v10;
  v6 = 0;
  SendMessageW(DlgItem, 0x1074u, v2, (LPARAM)&v5);
  if ( v12 == 1 )
  {
    v6 = 1;
    v7 = &v13;
    SendMessageW(DlgItem, 0x1074u, v2, (LPARAM)&v5);
  }
  v6 = 2;
  v7 = &v11;
  return SendMessageW(DlgItem, 0x1074u, v2, (LPARAM)&v5);
}

//----- (00000001400ABD40) ----------------------------------------------------
HWND __fastcall sub_1400ABD40(LPARAM a1, HWND a2, HWND a3, int a4)
{
  INT_PTR (__stdcall *v8)(HWND, UINT, WPARAM, LPARAM); // r8
  __int64 v9; // rcx
  LPARAM dwInitParam[2]; // [rsp+20h] [rbp-8B8h] BYREF
  _DWORD lParam[10]; // [rsp+30h] [rbp-8A8h] BYREF
  __int64 v13; // [rsp+58h] [rbp-880h]
  char v14[1540]; // [rsp+80h] [rbp-858h] BYREF
  int v15; // [rsp+684h] [rbp-254h]

  lParam[1] = a4;
  lParam[0] = 4;
  lParam[2] = 0;
  SendMessageW(a3, 0x104Bu, 0i64, (LPARAM)lParam);
  sub_14007D720(v13, (__int64)v14);
  dwInitParam[1] = v13;
  dwInitParam[0] = a1;
  if ( v15 )
  {
    v8 = (INT_PTR (__stdcall *)(HWND, UINT, WPARAM, LPARAM))sub_1400D6610;
    v9 = 182i64;
  }
  else
  {
    v8 = (INT_PTR (__stdcall *)(HWND, UINT, WPARAM, LPARAM))sub_1400D6410;
    v9 = 212i64;
  }
  if ( sub_140001150((LPCWSTR)v9, a2, v8, (LPARAM)dwInitParam) == 1 )
  {
    sub_1400ABC10(a2, a4);
    dword_14012DB34 = 1;
  }
  return SetFocus(a3);
}
// 14012DB34: using guessed type int dword_14012DB34;
// 1400ABD40: using guessed type char var_858[1540];

//----- (00000001400ABE30) ----------------------------------------------------
HWND __fastcall sub_1400ABE30(LPARAM a1, HWND a2)
{
  HWND DlgItem; // rdi
  HWND result; // rax

  DlgItem = GetDlgItem(a2, 1114);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( (_DWORD)result != -1 )
    return sub_1400ABD40(a1, a2, DlgItem, (int)result);
  return result;
}

//----- (00000001400ABEA0) ----------------------------------------------------
BOOL __fastcall sub_1400ABEA0(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbp
  HWND v5; // rdi
  __int64 v6; // rsi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  LPARAM v9; // rax
  LPARAM v10; // rax
  int lParam[4]; // [rsp+40h] [rbp-918h] BYREF
  WCHAR *v13; // [rsp+50h] [rbp-908h]
  LPARAM v14; // [rsp+70h] [rbp-8E8h] BYREF
  int v15; // [rsp+7Ch] [rbp-8DCh]
  int v16; // [rsp+80h] [rbp-8D8h]
  char v17[2080]; // [rsp+C0h] [rbp-898h] BYREF
  WCHAR Buffer[32]; // [rsp+8E0h] [rbp-78h] BYREF

  DlgItem = GetDlgItem(a2, 1114);
  SendMessageW(DlgItem, 0x1036u, 0x20ui64, 32i64);
  SendMessageW(DlgItem, 0x1036u, 0x4000ui64, 0x4000i64);
  LoadStringW(hInstance, 0x200Cu, Buffer, 32);
  v13 = Buffer;
  lParam[0] = 4;
  SendMessageW(DlgItem, 0x1061u, 0i64, (LPARAM)lParam);
  LoadStringW(hInstance, 0x200Du, Buffer, 32);
  v13 = Buffer;
  lParam[0] = 4;
  SendMessageW(DlgItem, 0x1061u, 1ui64, (LPARAM)lParam);
  LoadStringW(hInstance, 0x200Eu, Buffer, 32);
  v13 = Buffer;
  lParam[0] = 4;
  SendMessageW(DlgItem, 0x1061u, 2ui64, (LPARAM)lParam);
  v5 = GetDlgItem(a2, 1175);
  v6 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 1);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v6, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(v5, 0x1109u, 0i64, v6);
  sub_14007DA80(a1 + 2664, (__int64)v17);
  sub_1400CAD70(a1, v5, 0i64, (__int64)v17);
  v9 = SendMessageW(v5, 0x110Au, 0i64, 0i64);
  SendMessageW(v5, 0x1102u, 2ui64, v9);
  SendMessageW(DlgItem, 0x101Eu, 0i64, 100i64);
  SendMessageW(DlgItem, 0x101Eu, 1ui64, 220i64);
  SendMessageW(DlgItem, 0x101Eu, 2ui64, 180i64);
  v10 = SendMessageW(v5, 0x110Au, 0i64, 0i64);
  SendMessageW(v5, 0x110Bu, 9ui64, v10);
  v16 = 2;
  v15 = 2;
  SendMessageW(DlgItem, 0x102Bu, 0i64, (LPARAM)&v14);
  SetFocus(DlgItem);
  v16 = 1;
  v15 = 1;
  SendMessageW(DlgItem, 0x102Bu, 0i64, (LPARAM)&v14);
  SendMessageW(DlgItem, 0x1003u, 1ui64, v6);
  if ( *(_DWORD *)(a1 + 63080) )
    return SetWindowPos(a2, 0i64, *(_DWORD *)(a1 + 63084), *(_DWORD *)(a1 + 63088), 0, 0, 5u);
  else
    return sub_140081E00(*(HWND *)(a1 + 104), a2);
}
// 1400ABEA0: using guessed type _DWORD lParam[4];

//----- (00000001400AC220) ----------------------------------------------------
__int64 __fastcall sub_1400AC220(HWND hDlg, int a2, HMENU a3, __int64 a4)
{
  int v4; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v10; // eax

  v4 = a2 - 16;
  if ( !v4 )
  {
    sub_1400AB0B0((_DWORD *)qword_14012E1A8, hDlg);
    goto LABEL_35;
  }
  v6 = v4 - 62;
  if ( !v6 )
  {
    v10 = *(_DWORD *)(a4 + 16);
    switch ( v10 )
    {
      case -451:
        sub_1400AB7F0(hDlg, a4);
        return 0i64;
      case -5:
        sub_1400AB120(hDlg);
        return 0i64;
      case -3:
        sub_1400AB8C0(qword_14012E1A8, hDlg, a4);
        return 0i64;
    }
    return 0i64;
  }
  v7 = v6 - 194;
  if ( !v7 )
  {
    sub_1400ABEA0(qword_14012E1A8, hDlg);
    return 0i64;
  }
  v8 = v7 - 1;
  if ( v8 )
  {
    if ( v8 == 5 )
    {
      sub_1400AB5B0(hDlg, a3);
      return 0i64;
    }
    return 0i64;
  }
  if ( (unsigned __int16)a3 > 0x45Du )
  {
    if ( (unsigned __int16)a3 == 40311 || (unsigned __int16)a3 == 40312 )
    {
      sub_1400AB310(qword_14012E1A8, hDlg);
      return 0i64;
    }
    if ( (unsigned __int16)a3 != 40314 )
    {
      if ( (unsigned __int16)a3 != 40317 )
      {
        if ( (unsigned __int16)a3 == 40328 )
        {
          sub_1400AB4B0(qword_14012E1A8, hDlg);
          return 0i64;
        }
        return 0i64;
      }
LABEL_14:
      sub_1400ABE30(qword_14012E1A8, hDlg);
      return 0i64;
    }
LABEL_24:
    sub_1400AB670(qword_14012E1A8, hDlg);
    return 0i64;
  }
  switch ( (unsigned __int16)a3 )
  {
    case 0x45Du:
      sub_1400ABAC0(hDlg, 1);
      return 0i64;
    case 1u:
      sub_1400ABA40((_DWORD *)qword_14012E1A8, hDlg);
      return 0i64;
    case 2u:
LABEL_35:
      EndDialog(hDlg, 0i64);
      return 0i64;
    case 0x41Eu:
      sub_1400ABAC0(hDlg, 0);
      return 0i64;
    case 0x45Bu:
      goto LABEL_24;
    case 0x45Cu:
      goto LABEL_14;
  }
  return 0i64;
}
// 14012E1A8: using guessed type __int64 qword_14012E1A8;

//----- (00000001400AC400) ----------------------------------------------------
INT_PTR __fastcall sub_1400AC400(HWND hDlg, int a2, HMENU a3, __int64 a4)
{
  __int64 v4; // rax

  v4 = qword_14012E1A8;
  if ( a2 == 272 )
    v4 = a4;
  qword_14012E1A8 = v4;
  return sub_1400AC220(hDlg, a2, a3, a4);
}
// 14012E1A8: using guessed type __int64 qword_14012E1A8;

//----- (00000001400AC420) ----------------------------------------------------
BOOL __fastcall sub_1400AC420(HWND hDlg)
{
  HWND DlgItem; // rdi
  UINT v3; // eax

  DlgItem = GetDlgItem(hDlg, 1268);
  v3 = IsDlgButtonChecked(hDlg, 1003);
  return EnableWindow(DlgItem, v3 == 1);
}

//----- (00000001400AC470) ----------------------------------------------------
BOOL __fastcall sub_1400AC470(HWND hDlg)
{
  HWND v1; // rbx
  HWND DlgItem; // rsi
  HWND v3; // rdi

  v1 = hDlg;
  DlgItem = GetDlgItem(hDlg, 1193);
  v3 = GetDlgItem(v1, 1194);
  LODWORD(v1) = IsDlgButtonChecked(v1, 1195) == 1;
  EnableWindow(DlgItem, (BOOL)v1);
  return EnableWindow(v3, (BOOL)v1);
}

//----- (00000001400AC4F0) ----------------------------------------------------
LRESULT __fastcall sub_1400AC4F0(HWND a1, int a2)
{
  WPARAM v2; // rbx
  HWND DlgItem; // rax

  v2 = a2;
  DlgItem = GetDlgItem(a1, 1162);
  return SendMessageW(DlgItem, 0x150u, v2, 0i64);
}

//----- (00000001400AC530) ----------------------------------------------------
LRESULT __fastcall sub_1400AC530(HWND hWnd, LPCITEMIDLIST pidl)
{
  unsigned int v4; // edi
  int v6; // [rsp+20h] [rbp-248h] BYREF
  void *ppv; // [rsp+28h] [rbp-240h] BYREF
  LPCITEMIDLIST ppidlLast[2]; // [rsp+30h] [rbp-238h] BYREF
  __int16 lParam[264]; // [rsp+40h] [rbp-228h] BYREF

  v6 = 0x40000000;
  v4 = 1;
  if ( pidl )
  {
    ppv = 0i64;
    ppidlLast[0] = 0i64;
    if ( SHBindToParent(pidl, &stru_1400E3FB0, &ppv, ppidlLast) >= 0 )
    {
      (*(void (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
        ppv,
        1i64,
        ppidlLast,
        &v6);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    }
  }
  if ( (v6 & 0x40000000) != 0 )
    v4 = 0x8000;
  sub_14007E270(pidl, (LPWSTR)lParam, v4);
  return SendMessageW(hWnd, 0xCu, 0i64, (LPARAM)lParam);
}
// 1400AC530: using guessed type WCHAR lParam[264];

//----- (00000001400AC620) ----------------------------------------------------
__int64 __fastcall sub_1400AC620(HWND a1, int a2)
{
  if ( a2 == 1 )
    SendMessageW(a1, 0x467u, 1ui64, (LPARAM)&qword_14012D7F0);
  return 0i64;
}

//----- (00000001400AC650) ----------------------------------------------------
__int64 __fastcall sub_1400AC650(HWND a1, int a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( a2 == 1 )
    qword_14012DB38 = a1;
  return result;
}

//----- (00000001400AC670) ----------------------------------------------------
__int64 __fastcall sub_1400AC670(HWND hWnd, __int64 a2, const WCHAR *a3)
{
  unsigned __int16 v3; // bx
  __int64 v6; // r8
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  DWORD FileVersionInfoSizeW; // edi
  void *v11; // rax
  void *v12; // rsi
  __int64 v13; // rdx
  WCHAR *v14; // rcx
  WCHAR v15; // ax
  int v16; // er11
  LPVOID lpBuffer; // [rsp+20h] [rbp-288h] BYREF
  unsigned int puLen; // [rsp+28h] [rbp-280h] BYREF
  DWORD dwHandle; // [rsp+2Ch] [rbp-27Ch] BYREF
  WCHAR LCData[32]; // [rsp+30h] [rbp-278h] BYREF
  WCHAR pszPath[264]; // [rsp+70h] [rbp-238h] BYREF

  v3 = 0;
  v6 = 260i64;
  v7 = a2 - (_QWORD)pszPath;
  lpBuffer = 0i64;
  v8 = pszPath;
  while ( v6 != -2147483386 )
  {
    v9 = *(WCHAR *)((char *)v8 + v7);
    if ( !v9 )
      break;
    *v8++ = v9;
    if ( !--v6 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  PathAppendW(pszPath, a3);
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszPath, &dwHandle);
  if ( !FileVersionInfoSizeW )
    return 0i64;
  v11 = malloc(FileVersionInfoSizeW);
  v12 = v11;
  if ( v11 )
  {
    GetFileVersionInfoW(pszPath, 0, FileVersionInfoSizeW, v11);
    VerQueryValueW(v12, L"\\VarFileInfo\\Translation", &lpBuffer, &puLen);
    if ( puLen >= 4 )
    {
      if ( *(_WORD *)lpBuffer == 1115 )
      {
        v13 = 32i64;
        v14 = LCData;
        while ( v13 != -2147483614 )
        {
          v15 = *(WCHAR *)((char *)v14 + (char *)L"Sinhala" - (char *)LCData);
          if ( !v15 )
            break;
          *v14++ = v15;
          if ( !--v13 )
          {
            *(v14 - 1) = 0;
            goto LABEL_17;
          }
        }
        *v14 = 0;
      }
      else
      {
        GetLocaleInfoW(*(unsigned __int16 *)lpBuffer, 4u, LCData, 32);
      }
LABEL_17:
      v16 = SendMessageW(hWnd, 0x143u, 0i64, (LPARAM)LCData);
      if ( v16 != -1 )
        SendMessageW(hWnd, 0x151u, v16, *(_WORD *)lpBuffer & 0x3FF);
      v3 = *(_WORD *)lpBuffer & 0x3FF;
    }
    free(v12);
  }
  return v3;
}
// 1400AC6D6: conditional instruction was optimized away because r8.8!=0
// 1400AC7BE: conditional instruction was optimized away because rdx.8!=0
// 1400F3950: using guessed type wchar_t aSinhala[8];

//----- (00000001400AC870) ----------------------------------------------------
LRESULT __fastcall sub_1400AC870(__int64 a1, HWND a2)
{
  int v3; // edi
  HWND DlgItem; // rbp
  DWORD CurrentProcessId; // eax
  HANDLE v6; // rax
  __int64 v7; // rbx
  void *v8; // rsi
  WCHAR *v9; // rcx
  WCHAR v10; // ax
  HANDLE FirstFileW; // rsi
  int v12; // ebx
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+20h] [rbp-698h] BYREF
  WCHAR pszPath[264]; // [rsp+270h] [rbp-448h] BYREF
  WCHAR FileName[264]; // [rsp+480h] [rbp-238h] BYREF

  v3 = 0;
  DlgItem = GetDlgItem(a2, 1162);
  SendMessageW(DlgItem, 0x143u, 0i64, (LPARAM)L"English");
  SendMessageW(DlgItem, 0x151u, 0i64, 9i64);
  CurrentProcessId = GetCurrentProcessId();
  v6 = OpenProcess(0x410u, 0, CurrentProcessId);
  v7 = 260i64;
  v8 = v6;
  if ( v6 )
  {
    GetModuleFileNameExW(v6, 0i64, pszPath, 260i64);
    CloseHandle(v8);
  }
  PathRemoveFileSpecW(pszPath);
  v9 = FileName;
  while ( v7 != -2147483386 )
  {
    v10 = *(WCHAR *)((char *)v9 + (char *)pszPath - (char *)FileName);
    if ( !v10 )
      break;
    *v9++ = v10;
    if ( !--v7 )
    {
      --v9;
      break;
    }
  }
  *v9 = 0;
  PathAppendW(FileName, L"Explorer++??.dll");
  FirstFileW = FindFirstFileW(FileName, &FindFileData);
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    v12 = 2;
    if ( (unsigned __int16)sub_1400AC670(DlgItem, (__int64)pszPath, FindFileData.cFileName) == *(_DWORD *)(a1 + 7000) )
      v3 = 1;
    for ( ; FindNextFileW(FirstFileW, &FindFileData); ++v12 )
    {
      if ( (unsigned __int16)sub_1400AC670(DlgItem, (__int64)pszPath, FindFileData.cFileName) == *(_DWORD *)(a1 + 7000) )
        v3 = v12;
    }
    FindClose(FirstFileW);
  }
  return SendMessageW(DlgItem, 0x14Eu, v3, 0i64);
}
// 1400AC976: conditional instruction was optimized away because rbx.8!=0
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400ACA90) ----------------------------------------------------
void __fastcall sub_1400ACA90(HWND hWnd, __int64 a2)
{
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( a2 )
  {
    pv[0] = 0i64;
    if ( (int)sub_14007F810(a2, (__int64)pv) >= 0 )
    {
      sub_1400AC530(hWnd, (LPCITEMIDLIST)pv[0]);
      CoTaskMemFree(pv[0]);
    }
  }
}
// 1400ACA90: using guessed type LPVOID pv[3];

//----- (00000001400ACAE0) ----------------------------------------------------
void __fastcall sub_1400ACAE0(HWND hDlg)
{
  __int64 v2; // rbx
  int v3; // eax
  LPARAM *v4; // rcx
  __int16 v5; // ax
  __int16 v6; // ax
  ITEMIDLIST *v7; // rbx
  HWND DlgItem; // rax
  struct _browseinfoW bi; // [rsp+20h] [rbp-888h] BYREF
  WCHAR String[264]; // [rsp+60h] [rbp-848h] BYREF
  WCHAR pszBuf[264]; // [rsp+270h] [rbp-638h] BYREF
  WCHAR Buffer[256]; // [rsp+480h] [rbp-428h] BYREF
  char v13; // [rsp+680h] [rbp-228h] BYREF

  LoadStringW(hInstance, 0x2012u, Buffer, 256);
  v2 = 260i64;
  GetDlgItemTextW(hDlg, 1188, String, 260);
  v3 = sub_14007E5F0(String, pszBuf);
  v4 = &qword_14012D7F0;
  if ( v3 < 0 )
  {
    while ( v2 != -2147483386 )
    {
      v6 = *(_WORD *)((char *)v4 + (char *)String - (char *)&qword_14012D7F0);
      if ( !v6 )
        break;
      *(_WORD *)v4 = v6;
      v4 = (LPARAM *)((char *)v4 + 2);
      if ( !--v2 )
      {
LABEL_11:
        v4 = (LPARAM *)((char *)v4 - 2);
        break;
      }
    }
  }
  else
  {
    while ( v2 != -2147483386 )
    {
      v5 = *(_WORD *)((char *)v4 + (char *)pszBuf - (char *)&qword_14012D7F0);
      if ( !v5 )
        break;
      *(_WORD *)v4 = v5;
      v4 = (LPARAM *)((char *)v4 + 2);
      if ( !--v2 )
        goto LABEL_11;
    }
  }
  *(_WORD *)v4 = 0;
  CoInitializeEx(0i64, 2u);
  bi.pszDisplayName = (LPWSTR)&v13;
  bi.hwndOwner = hDlg;
  bi.lpszTitle = Buffer;
  bi.pidlRoot = 0i64;
  bi.lpfn = (BFFCALLBACK)sub_1400AC620;
  bi.ulFlags = 64;
  v7 = SHBrowseForFolderW(&bi);
  CoUninitialize();
  if ( v7 )
  {
    DlgItem = GetDlgItem(hDlg, 1188);
    sub_1400AC530(DlgItem, v7);
    CoTaskMemFree(v7);
  }
}
// 1400ACBC6: conditional instruction was optimized away because rbx.8!=0

//----- (00000001400ACC80) ----------------------------------------------------
__int64 __fastcall sub_1400ACC80(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  int v4; // edx
  __int64 v5; // rbx
  int v7; // edx
  int v8; // edx
  HWND DlgItem; // rax
  UINT v11; // eax
  int v12; // er8
  HWND v13; // rcx

  v4 = a2 - 16;
  v5 = qword_14012F620;
  if ( !v4 )
  {
    EndDialog(hDlg, 0i64);
    return 0i64;
  }
  v7 = v4 - 62;
  if ( !v7 )
  {
    if ( *(_DWORD *)(a4 + 16) == -202 )
    {
      *(_DWORD *)(v5 + 60896) = IsDlgButtonChecked(hDlg, 1278) == 1;
      *(_DWORD *)(v5 + 60856) = IsDlgButtonChecked(hDlg, 1138) == 1;
      *(_DWORD *)(v5 + 60808) = IsDlgButtonChecked(hDlg, 1042) == 1;
      *(_DWORD *)(v5 + 60804) = IsDlgButtonChecked(hDlg, 1137) == 1;
      *(_DWORD *)(v5 + 60788) = IsDlgButtonChecked(hDlg, 1006) == 1;
      *(_DWORD *)(v5 + 60860) = IsDlgButtonChecked(hDlg, 1218) == 1;
      v11 = IsDlgButtonChecked(hDlg, 1268);
      v12 = *(_DWORD *)(v5 + 60856);
      v13 = *(HWND *)(v5 + 136);
      *(_DWORD *)(v5 + 60884) = v11 == 1;
      sub_140080520(v13, 0x400u, v12);
      sub_1400B0500(v5);
      return 0i64;
    }
    return 0i64;
  }
  v8 = v7 - 194;
  if ( !v8 )
  {
    if ( *(_DWORD *)(qword_14012F620 + 7004) != 6 || !*(_DWORD *)(qword_14012F620 + 7008) )
    {
      DlgItem = GetDlgItem(hDlg, 1278);
      EnableWindow(DlgItem, 0);
      if ( !*(_DWORD *)(v5 + 60896) )
        goto LABEL_21;
      *(_DWORD *)(v5 + 60896) = 0;
    }
    if ( *(_DWORD *)(v5 + 60896) )
      CheckDlgButton(hDlg, 1278, 1u);
LABEL_21:
    if ( *(_DWORD *)(v5 + 60856) )
      CheckDlgButton(hDlg, 1138, 1u);
    if ( *(_DWORD *)(v5 + 60808) )
      CheckDlgButton(hDlg, 1042, 1u);
    if ( *(_DWORD *)(v5 + 60804) )
      CheckDlgButton(hDlg, 1137, 1u);
    if ( *(_DWORD *)(v5 + 60788) )
      CheckDlgButton(hDlg, 1006, 1u);
    if ( *(_DWORD *)(v5 + 60860) )
      CheckDlgButton(hDlg, 1218, 1u);
    if ( *(_DWORD *)(v5 + 60884) )
    {
      CheckDlgButton(hDlg, 1268, 1u);
      return 0i64;
    }
    return 0i64;
  }
  if ( v8 == 1 )
  {
    if ( a3 <= 0x4C2u )
    {
      if ( a3 != 1218 && a3 != 1006 && a3 != 1042 )
      {
        if ( a3 > 0x470u )
        {
          if ( a3 > 0x472u )
            return 0i64;
          goto LABEL_14;
        }
        return 0i64;
      }
LABEL_14:
      SendMessageW(qword_14012DB38, 0x468u, (WPARAM)hDlg, 0i64);
      return 0i64;
    }
    if ( a3 == 1268 || a3 == 1278 )
      goto LABEL_14;
  }
  return 0i64;
}
// 14012F620: using guessed type __int64 qword_14012F620;

//----- (00000001400ACF80) ----------------------------------------------------
__int64 __fastcall sub_1400ACF80(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  if ( a2 == 272 )
    qword_14012F620 = *(_QWORD *)(a4 + 48);
  return sub_1400ACC80(hDlg, a2, a3, a4);
}
// 14012F620: using guessed type __int64 qword_14012F620;

//----- (00000001400ACFA0) ----------------------------------------------------
__int64 __fastcall sub_1400ACFA0(HWND hDlg, int a2, int a3, __int64 a4)
{
  int v4; // edx
  __int64 v5; // rdi
  int v7; // edx
  int v8; // edx
  bool v9; // zf
  int v10; // edi
  UINT v11; // eax
  BOOL v12; // er12
  int v13; // edx
  HWND v14; // rax
  BOOL v15; // ebx
  HWND v16; // rax
  HWND v18; // rax
  HWND v19; // rax
  int v20; // edx
  BOOL v21; // er12
  int *v22; // rbp
  signed int v23; // ebx
  HWND v24; // r14
  HWND v25; // rbx
  WPARAM v26; // r12
  HWND DlgItem; // rbx
  int v28; // eax
  int v29; // eax
  HWND v30; // rcx
  int v31; // eax
  __int64 v32; // rsi
  HWND v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // rcx
  __int64 v38; // rcx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rcx
  __int64 v42; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-58h] BYREF
  unsigned int v44; // [rsp+40h] [rbp-38h]

  v4 = a2 - 16;
  v5 = qword_14012F628;
  if ( !v4 )
  {
    EndDialog(hDlg, 0i64);
    return 0i64;
  }
  v7 = v4 - 62;
  if ( !v7 )
  {
    if ( *(_DWORD *)(a4 + 16) == -202 )
    {
      v26 = 0i64;
      *(_DWORD *)(v5 + 60968) = IsDlgButtonChecked(hDlg, 1241) == 1;
      *(_DWORD *)(v5 + 60944) = IsDlgButtonChecked(hDlg, 1002) != 1;
      *(_DWORD *)(v5 + 60972) = IsDlgButtonChecked(hDlg, 1240) == 1;
      *(_DWORD *)(v5 + 60868) = IsDlgButtonChecked(hDlg, 1221) == 1;
      *(_DWORD *)(v5 + 60844) = IsDlgButtonChecked(hDlg, 1242) == 1;
      *(_DWORD *)(v5 + 60848) = GetDlgItemInt(hDlg, 1302, 0i64, 0);
      *(_DWORD *)(v5 + 60872) = IsDlgButtonChecked(hDlg, 1275) == 1;
      *(_DWORD *)(v5 + 60912) = IsDlgButtonChecked(hDlg, 1280) == 1;
      *(_DWORD *)(v5 + 60792) = IsDlgButtonChecked(hDlg, 1003) == 1;
      *(_DWORD *)(v5 + 60796) = IsDlgButtonChecked(hDlg, 1268) == 1;
      *(_DWORD *)(v5 + 60880) = IsDlgButtonChecked(hDlg, 1108) == 1;
      *(_DWORD *)(v5 + 60864) = IsDlgButtonChecked(hDlg, 1218) == 1;
      *(_DWORD *)(v5 + 60960) = IsDlgButtonChecked(hDlg, 1081) == 1;
      *(_DWORD *)(v5 + 60928) = IsDlgButtonChecked(hDlg, 1195) == 1;
      *(_DWORD *)(v5 + 60932) = IsDlgButtonChecked(hDlg, 1193) != 1;
      DlgItem = GetDlgItem(hDlg, 1276);
      v28 = SendMessageW(DlgItem, 0x147u, 0i64, 0i64);
      v29 = SendMessageW(DlgItem, 0x150u, v28, 0i64);
      v30 = *(HWND *)(v5 + 136);
      *(_DWORD *)(v5 + 60916) = v29;
      v31 = SendMessageW(v30, 0x1304u, 0i64, 0i64);
      if ( v31 > 0 )
      {
        v32 = (unsigned int)v31;
        do
        {
          v33 = *(HWND *)(v5 + 136);
          LODWORD(lParam[0]) = 8;
          SendMessageW(v33, 0x133Cu, v26, (LPARAM)lParam);
          v34 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v34 + 680i64))(v34, *(unsigned int *)(v5 + 60968));
          v35 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v35 + 696i64))(v35, *(unsigned int *)(v5 + 60944));
          v36 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v36 + 712i64))(v36, *(unsigned int *)(v5 + 60972));
          v37 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v37 + 728i64))(v37, *(unsigned int *)(v5 + 60792));
          v38 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v38 + 744i64))(v38, *(unsigned int *)(v5 + 60796));
          v39 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v39 + 752i64))(v39, *(unsigned int *)(v5 + 60960));
          v40 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v40 + 768i64))(v40, *(unsigned int *)(v5 + 60868));
          v41 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v41 + 784i64))(v41, *(unsigned int *)(v5 + 60880));
          v42 = *(_QWORD *)(v5 + 8i64 * (int)v44 + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v42 + 792i64))(v42, *(unsigned int *)(v5 + 60916));
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(v5 + 56) + 32i64))(v5 + 56, v44);
          sub_140080180(*(HWND *)(v5 + 8i64 * (int)v44 + 184), *(_DWORD *)(v5 + 60844), *(_DWORD *)(v5 + 60848));
          ++v26;
          --v32;
        }
        while ( v32 );
      }
      sub_1400B0500(v5);
      return 0i64;
    }
    return 0i64;
  }
  v8 = v7 - 194;
  if ( v8 )
  {
    if ( v8 == 1 )
    {
      if ( HIWORD(a3) )
      {
        v9 = HIWORD(a3) == 1;
      }
      else
      {
        v10 = (unsigned __int16)a3;
        if ( (unsigned __int16)a3 <= 0x4F4u )
        {
          if ( (unsigned __int16)a3 != 1268 )
          {
            switch ( (__int16)a3 )
            {
              case 1002:
              case 1081:
              case 1218:
              case 1221:
              case 1240:
              case 1241:
                goto LABEL_20;
              case 1003:
                sub_1400AC420(hDlg);
                goto LABEL_20;
              case 1108:
                v11 = IsDlgButtonChecked(hDlg, (unsigned __int16)a3);
                v12 = 0;
                v13 = 1276;
                break;
              case 1193:
              case 1194:
                v9 = IsDlgButtonChecked(hDlg, (unsigned __int16)a3) == 1;
                goto LABEL_19;
              case 1195:
                sub_1400AC470(hDlg);
                goto LABEL_20;
              case 1242:
                v12 = 0;
                v15 = IsDlgButtonChecked(hDlg, (unsigned __int16)a3) == 1;
                v16 = GetDlgItem(hDlg, 1302);
                EnableWindow(v16, v15);
                v11 = IsDlgButtonChecked(hDlg, v10);
                v13 = 1303;
                break;
              default:
                return 0i64;
            }
            LOBYTE(v12) = v11 == 1;
            v14 = GetDlgItem(hDlg, v13);
            EnableWindow(v14, v12);
          }
          goto LABEL_20;
        }
        if ( (unsigned __int16)a3 == 1275 || (unsigned __int16)a3 == 1280 )
        {
LABEL_20:
          SendMessageW(qword_14012DB38, 0x468u, (WPARAM)hDlg, 0i64);
          return 0i64;
        }
        v9 = (unsigned __int16)a3 == 1302;
      }
LABEL_19:
      if ( v9 )
        goto LABEL_20;
    }
    return 0i64;
  }
  if ( *(_DWORD *)(qword_14012F628 + 60968) )
    CheckDlgButton(hDlg, 1241, 1u);
  if ( !*(_DWORD *)(v5 + 60944) )
    CheckDlgButton(hDlg, 1002, 1u);
  if ( *(_DWORD *)(v5 + 60972) )
    CheckDlgButton(hDlg, 1240, 1u);
  if ( *(_DWORD *)(v5 + 60868) )
    CheckDlgButton(hDlg, 1221, 1u);
  if ( *(_DWORD *)(v5 + 60844) )
    CheckDlgButton(hDlg, 1242, 1u);
  SetDlgItemInt(hDlg, 1302, *(_DWORD *)(v5 + 60848), 0);
  v18 = GetDlgItem(hDlg, 1302);
  EnableWindow(v18, *(_DWORD *)(v5 + 60844));
  v19 = GetDlgItem(hDlg, 1303);
  EnableWindow(v19, *(_DWORD *)(v5 + 60844));
  if ( *(_DWORD *)(v5 + 60872) )
    CheckDlgButton(hDlg, 1275, 1u);
  if ( *(_DWORD *)(v5 + 60912) )
    CheckDlgButton(hDlg, 1280, 1u);
  if ( *(_DWORD *)(v5 + 60792) )
    CheckDlgButton(hDlg, 1003, 1u);
  if ( *(_DWORD *)(v5 + 60796) )
    CheckDlgButton(hDlg, 1268, 1u);
  if ( *(_DWORD *)(v5 + 60880) )
    CheckDlgButton(hDlg, 1108, 1u);
  if ( *(_DWORD *)(v5 + 60864) )
    CheckDlgButton(hDlg, 1218, 1u);
  if ( *(_DWORD *)(v5 + 60960) )
    CheckDlgButton(hDlg, 1081, 1u);
  if ( *(_DWORD *)(v5 + 60928) )
    CheckDlgButton(hDlg, 1195, 1u);
  v20 = 1193;
  if ( *(_DWORD *)(v5 + 60932) )
    v20 = 1194;
  CheckDlgButton(hDlg, v20, 1u);
  v21 = 0;
  v22 = (int *)&unk_1400F3460;
  v23 = 0;
  v24 = GetDlgItem(hDlg, 1276);
  do
  {
    SendMessageW(v24, 0x143u, 0i64, (LPARAM)&aBytes_0[66 * v23]);
    SendMessageW(v24, 0x151u, v23, *v22);
    if ( *v22 == *(_DWORD *)(v5 + 60916) )
      SendMessageW(v24, 0x14Eu, v23, 0i64);
    ++v23;
    v22 += 33;
  }
  while ( (unsigned int)v23 < 6 );
  EnableWindow(v24, *(_DWORD *)(v5 + 60880));
  sub_1400AC470(hDlg);
  v25 = GetDlgItem(hDlg, 1268);
  LOBYTE(v21) = IsDlgButtonChecked(hDlg, 1003) == 1;
  EnableWindow(v25, v21);
  return 0i64;
}
// 1400F3464: using guessed type wchar_t aBytes_0[6];
// 14012F628: using guessed type __int64 qword_14012F628;
// 1400ACFA0: using guessed type LPARAM lParam[4];

//----- (00000001400AD8E0) ----------------------------------------------------
__int64 __fastcall sub_1400AD8E0(HWND hDlg, int a2, int a3, __int64 a4)
{
  if ( a2 == 272 )
    qword_14012F628 = *(_QWORD *)(a4 + 48);
  return sub_1400ACFA0(hDlg, a2, a3, a4);
}
// 14012F628: using guessed type __int64 qword_14012F628;

//----- (00000001400AD900) ----------------------------------------------------
__int64 __fastcall sub_1400AD900(HWND hDlg, int a2, int a3, __int64 a4)
{
  int v4; // edx
  __int64 v5; // rdi
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  HWND DlgItem; // rax
  int v12; // ebx
  HWND v13; // rax
  HWND v14; // rbx
  int v15; // ebx
  int v16; // ebp
  int v17; // edx
  int v18; // er12
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  int v22; // ebp
  int v23; // edx
  HWND v24; // rax
  __int64 v25; // rbx
  int v26; // eax
  char *v27; // rcx
  signed __int64 v28; // rdx
  __int16 v29; // ax
  signed __int64 v30; // rdx
  __int16 v31; // ax
  HWND v32; // rax
  int v33; // ebx
  HWND v34; // rax
  void *pv[2]; // [rsp+20h] [rbp-658h] BYREF
  __int16 lParam[264]; // [rsp+30h] [rbp-648h] BYREF
  WCHAR Buffer[256]; // [rsp+240h] [rbp-438h] BYREF
  WCHAR pszBuf[264]; // [rsp+440h] [rbp-238h] BYREF

  v4 = a2 - 2;
  v5 = qword_14012F630;
  if ( !v4 )
  {
    DestroyIcon((HICON)hIcon);
    return 0i64;
  }
  v7 = v4 - 14;
  if ( !v7 )
  {
    EndDialog(hDlg, 0i64);
    return 0i64;
  }
  v8 = v7 - 62;
  if ( v8 )
  {
    v9 = v8 - 194;
    if ( v9 )
    {
      if ( v9 == 1 )
      {
        if ( HIWORD(a3) )
        {
          if ( HIWORD(a3) == 1 || HIWORD(a3) == 768 )
LABEL_14:
            SendMessageW(qword_14012DB38, 0x468u, (WPARAM)hDlg, 0i64);
        }
        else
        {
          switch ( (__int16)a3 )
          {
            case 1073:
            case 1074:
              if ( IsDlgButtonChecked(hDlg, (unsigned __int16)a3) == 1 )
                goto LABEL_14;
              break;
            case 1176:
            case 1202:
            case 1266:
            case 1267:
              goto LABEL_14;
            case 1187:
              sub_1400ACAE0(hDlg);
              goto LABEL_14;
            default:
              return 0i64;
          }
        }
      }
      return 0i64;
    }
    if ( *(_DWORD *)(qword_14012F630 + 60920) != 1 )
    {
      if ( *(_DWORD *)(qword_14012F630 + 60920) == 2 )
      {
        v10 = 1073;
        goto LABEL_19;
      }
      *(_DWORD *)(qword_14012F630 + 60920) = 1;
    }
    v10 = 1074;
LABEL_19:
    CheckDlgButton(hDlg, v10, 1u);
    if ( *(_DWORD *)(v5 + 7004) == 5 )
    {
      DlgItem = GetDlgItem(hDlg, 1267);
      EnableWindow(DlgItem, 0);
      if ( *(_DWORD *)(v5 + 60924) == 3 )
        *(_DWORD *)(v5 + 60924) = 1;
    }
    if ( *(_DWORD *)(v5 + 60924) != 1 )
    {
      if ( *(_DWORD *)(v5 + 60924) == 2 )
      {
        v12 = 1202;
        goto LABEL_29;
      }
      if ( *(_DWORD *)(v5 + 60924) == 3 )
      {
        v12 = 1267;
LABEL_29:
        CheckDlgButton(hDlg, v12, 1u);
        if ( *(_DWORD *)(v5 + 60816) )
          CheckDlgButton(hDlg, 1176, 1u);
        v13 = GetDlgItem(hDlg, 1187);
        SendMessageW(v13, 0xF7u, 1ui64, hIcon);
        v14 = GetDlgItem(hDlg, 1188);
        pv[0] = 0i64;
        if ( v5 != -5960 && (int)sub_14007F810(v5 + 5960, (__int64)pv) >= 0 )
        {
          sub_1400AC530(v14, (LPCITEMIDLIST)pv[0]);
          CoTaskMemFree(pv[0]);
        }
        sub_1400AC870(v5, hDlg);
        sub_140081E00(*(HWND *)(v5 + 104), qword_14012DB38);
        return 0i64;
      }
    }
    v12 = 1266;
    goto LABEL_29;
  }
  if ( *(_DWORD *)(a4 + 16) != -202 )
    return 0i64;
  if ( IsDlgButtonChecked(hDlg, 1074) == 1 )
  {
    *(_DWORD *)(v5 + 60920) = 1;
  }
  else if ( IsDlgButtonChecked(hDlg, 1073) == 1 )
  {
    *(_DWORD *)(v5 + 60920) = 2;
  }
  v15 = 1266;
  if ( IsDlgButtonChecked(hDlg, 1266) == 1 )
  {
    v16 = 1;
  }
  else if ( IsDlgButtonChecked(hDlg, 1202) == 1 )
  {
    v16 = 2;
  }
  else
  {
    v16 = 1;
    if ( IsDlgButtonChecked(hDlg, 1267) == 1 )
      v16 = 3;
  }
  v17 = *(_DWORD *)(v5 + 60924);
  if ( v17 != v16 )
  {
    v18 = 1;
    if ( v16 == 1 )
    {
      v20 = v17 - 2;
      if ( v20 )
      {
        if ( v20 != 1 )
          goto LABEL_56;
        v19 = sub_1400D1C80((__int64)L"openinexplorer++");
      }
      else
      {
        v19 = sub_1400D1B10(2, (__int64)L"openinexplorer++");
      }
    }
    else if ( v16 == 2 )
    {
      sub_1400D1B10(2, (__int64)L"openinexplorer++");
      sub_1400D1C80((__int64)L"openinexplorer++");
      v19 = sub_1400D1DE0(2, L"openinexplorer++", L"Open In Explorer++");
    }
    else
    {
      sub_1400D1B10(2, (__int64)L"openinexplorer++");
      sub_1400D1C80((__int64)L"openinexplorer++");
      v19 = sub_1400D2040();
    }
    v18 = v19;
LABEL_56:
    LoadStringW(hInstance, 0x7F9u, Buffer, 256);
    if ( v18 )
    {
      *(_DWORD *)(v5 + 60924) = v16;
      goto LABEL_70;
    }
    MessageBoxW(hDlg, Buffer, L"Explorer++", 0x30u);
    v21 = v16 - 1;
    if ( v21 )
    {
      v22 = v21 - 1;
      if ( !v22 )
      {
        v23 = 1202;
        goto LABEL_64;
      }
      if ( v22 == 1 )
      {
        v23 = 1267;
LABEL_64:
        CheckDlgButton(hDlg, v23, 0);
        if ( *(_DWORD *)(v5 + 60924) != 1 )
        {
          if ( *(_DWORD *)(v5 + 60924) == 2 )
          {
            v15 = 1202;
          }
          else if ( *(_DWORD *)(v5 + 60924) == 3 )
          {
            v15 = 1267;
          }
        }
        CheckDlgButton(hDlg, v15, 1u);
        goto LABEL_70;
      }
    }
    v23 = 1266;
    goto LABEL_64;
  }
LABEL_70:
  *(_DWORD *)(v5 + 60816) = IsDlgButtonChecked(hDlg, 1176) == 1;
  v24 = GetDlgItem(hDlg, 1188);
  v25 = 260i64;
  SendMessageW(v24, 0xDu, 0x104ui64, (LPARAM)lParam);
  v26 = sub_14007E5F0((PCNZWCH)lParam, pszBuf);
  v27 = (char *)(v5 + 5960);
  if ( v26 < 0 )
  {
    v30 = (char *)lParam - v27;
    while ( v25 != -2147483386 )
    {
      v31 = *(_WORD *)&v27[v30];
      if ( !v31 )
        break;
      *(_WORD *)v27 = v31;
      v27 += 2;
      if ( !--v25 )
      {
LABEL_82:
        v27 -= 2;
        break;
      }
    }
  }
  else
  {
    v28 = (char *)pszBuf - v27;
    while ( v25 != -2147483386 )
    {
      v29 = *(_WORD *)&v27[v28];
      if ( !v29 )
        break;
      *(_WORD *)v27 = v29;
      v27 += 2;
      if ( !--v25 )
        goto LABEL_82;
    }
  }
  *(_WORD *)v27 = 0;
  v32 = GetDlgItem(hDlg, 1162);
  v33 = SendMessageW(v32, 0x147u, 0i64, 0i64);
  v34 = GetDlgItem(hDlg, 1162);
  *(_DWORD *)(v5 + 7000) = SendMessageW(v34, 0x150u, v33, 0i64);
  sub_1400B0500(v5);
  return 0i64;
}
// 1400ADDF6: conditional instruction was optimized away because rbx.8!=0
// 1400ADBF3: conditional instruction was optimized away because ebp.4==3
// 1400F3438: using guessed type wchar_t aOpeninexplorer_7[17];
// 1400F3778: using guessed type wchar_t aOpeninexplorer_6[17];
// 1400F37A0: using guessed type wchar_t aOpeninexplorer_3[17];
// 1400F37C8: using guessed type wchar_t aOpeninexplorer_4[17];
// 1400F37F0: using guessed type wchar_t aOpenInExplorer_0[19];
// 1400F3818: using guessed type wchar_t aOpeninexplorer_5[17];
// 1400F3840: using guessed type wchar_t aOpeninexplorer_1[17];
// 1400F3868: using guessed type wchar_t aOpeninexplorer_2[17];
// 14012F630: using guessed type __int64 qword_14012F630;
// 1400AD900: using guessed type LPVOID pv[2];
// 1400AD900: using guessed type WCHAR lParam[264];

//----- (00000001400ADF70) ----------------------------------------------------
__int64 __fastcall sub_1400ADF70(HWND hDlg, int a2, int a3, __int64 a4)
{
  if ( a2 == 272 )
    qword_14012F630 = *(_QWORD *)(a4 + 48);
  return sub_1400AD900(hDlg, a2, a3, a4);
}
// 14012F630: using guessed type __int64 qword_14012F630;

//----- (00000001400ADF90) ----------------------------------------------------
__int64 __fastcall sub_1400ADF90(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  int v4; // edx
  _DWORD *v5; // rbx
  int v7; // edx
  int v8; // edx
  __int64 v9; // rbp
  void *v10; // rdi
  _QWORD **v11; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rbx
  LPARAM dwInitParam[3]; // [rsp+50h] [rbp-108h] BYREF
  unsigned __int16 v16; // [rsp+68h] [rbp-F0h]
  HWND hWndParent; // [rsp+70h] [rbp-E8h]
  int v18; // [rsp+80h] [rbp-D8h]
  void *Block; // [rsp+98h] [rbp-C0h]
  char v20[112]; // [rsp+E0h] [rbp-78h] BYREF

  v4 = a2 - 16;
  v5 = (_DWORD *)qword_140130CA8;
  if ( v4 )
  {
    v7 = v4 - 62;
    if ( v7 )
    {
      v8 = v7 - 194;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          switch ( a3 )
          {
            case 0x431u:
            case 0x432u:
            case 0x464u:
            case 0x465u:
            case 0x466u:
            case 0x46Fu:
              if ( IsDlgButtonChecked(hDlg, a3) == 1 )
                goto LABEL_7;
              break;
            case 0x463u:
            case 0x468u:
            case 0x469u:
            case 0x46Au:
LABEL_7:
              SendMessageW(qword_14012DB38, 0x468u, (WPARAM)hDlg, 0i64);
              break;
            case 0x4E5u:
              v9 = qword_140130CA8 + 56;
              if ( !qword_140130CA8 )
                v9 = 0i64;
              sub_14009CE50(
                (__int64)dwInitParam,
                (__int64)hDlg,
                v9,
                qword_140130CA8 + 62232,
                qword_140130CA8 + 62256,
                qword_140130CA8 + 62280,
                qword_140130CA8 + 62304,
                qword_140130CA8 + 62328,
                qword_140130CA8 + 62352,
                qword_140130CA8 + 62376);
              if ( !v18 )
                DialogBoxParamW(
                  (HINSTANCE)dwInitParam[2],
                  (LPCWSTR)v16,
                  hWndParent,
                  (DLGPROC)DialogFunc,
                  (LPARAM)dwInitParam);
              dwInitParam[0] = (LPARAM)&CSetDefaultColumnsDialog::`vftable';
              sub_14001A540((__int64)v20);
              v10 = Block;
              dwInitParam[0] = (LPARAM)&CBaseDialog::`vftable';
              if ( Block )
              {
                v11 = (_QWORD **)*((_QWORD *)Block + 1);
                v12 = *v11;
                *v11 = v11;
                *(_QWORD *)(*((_QWORD *)v10 + 1) + 8i64) = *((_QWORD *)v10 + 1);
                *((_QWORD *)v10 + 2) = 0i64;
                if ( v12 != *((_QWORD **)v10 + 1) )
                {
                  do
                  {
                    v13 = (_QWORD *)*v12;
                    j_free(v12);
                    v12 = v13;
                  }
                  while ( v13 != *((_QWORD **)v10 + 1) );
                }
                j_free(*((void **)v10 + 1));
                j_free(v10);
              }
              break;
            default:
              return 0i64;
          }
        }
      }
      else
      {
        if ( *(_DWORD *)(qword_140130CA8 + 60940) )
          CheckDlgButton(hDlg, 1123, 1u);
        if ( v5[15237] )
          CheckDlgButton(hDlg, 1130, 1u);
        if ( v5[15238] )
          CheckDlgButton(hDlg, 1129, 1u);
        if ( v5[15239] )
          CheckDlgButton(hDlg, 1128, 1u);
        switch ( v5[15234] )
        {
          case 1:
            goto LABEL_31;
          case 2:
            CheckDlgButton(hDlg, 1124, 1u);
            break;
          case 3:
            CheckDlgButton(hDlg, 1125, 1u);
            break;
          case 4:
            CheckDlgButton(hDlg, 1126, 1u);
            break;
          case 5:
            CheckDlgButton(hDlg, 1074, 1u);
            break;
          case 6:
            CheckDlgButton(hDlg, 1135, 1u);
            break;
          default:
            v5[15234] = 1;
LABEL_31:
            CheckDlgButton(hDlg, 1073, 1u);
            break;
        }
      }
    }
    else if ( *(_DWORD *)(a4 + 16) == -202 )
    {
      v5[15235] = IsDlgButtonChecked(hDlg, 1123) == 1;
      v5[15237] = IsDlgButtonChecked(hDlg, 1130) == 1;
      v5[15238] = IsDlgButtonChecked(hDlg, 1129) == 1;
      v5[15239] = IsDlgButtonChecked(hDlg, 1128) == 1;
      if ( IsDlgButtonChecked(hDlg, 1135) == 1 )
      {
        v5[15234] = 6;
        sub_1400B0500((__int64)v5);
      }
      else if ( IsDlgButtonChecked(hDlg, 1074) == 1 )
      {
        v5[15234] = 5;
        sub_1400B0500((__int64)v5);
      }
      else if ( IsDlgButtonChecked(hDlg, 1073) == 1 )
      {
        v5[15234] = 1;
        sub_1400B0500((__int64)v5);
      }
      else if ( IsDlgButtonChecked(hDlg, 1124) == 1 )
      {
        v5[15234] = 2;
        sub_1400B0500((__int64)v5);
      }
      else if ( IsDlgButtonChecked(hDlg, 1125) == 1 )
      {
        v5[15234] = 3;
        sub_1400B0500((__int64)v5);
      }
      else
      {
        if ( IsDlgButtonChecked(hDlg, 1126) == 1 )
          v5[15234] = 4;
        sub_1400B0500((__int64)v5);
      }
    }
  }
  else
  {
    EndDialog(hDlg, 0i64);
  }
  return 0i64;
}
// 1400F76E8: using guessed type void *CSetDefaultColumnsDialog::`vftable';
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';
// 140130CA8: using guessed type __int64 qword_140130CA8;
// 1400ADF90: using guessed type char var_78[112];

//----- (00000001400AE500) ----------------------------------------------------
__int64 __fastcall sub_1400AE500(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  if ( a2 == 272 )
    qword_140130CA8 = *(_QWORD *)(a4 + 48);
  return sub_1400ADF90(hDlg, a2, a3, a4);
}
// 140130CA8: using guessed type __int64 qword_140130CA8;

//----- (00000001400AE520) ----------------------------------------------------
__int64 __fastcall sub_1400AE520(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  int v4; // edx
  __int64 v5; // rdi
  int v7; // edx
  int v8; // edx
  WPARAM v9; // rsi
  int v10; // ebp
  int v11; // eax
  __int64 v12; // r13
  WPARAM v13; // rbp
  __int64 v14; // r12
  HWND v15; // rcx
  int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  __int64 v19; // r12
  HWND v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rcx
  int v23; // ebx
  HWND v24; // rbp
  int v25; // eax
  unsigned int v26; // eax
  __int64 v28[4]; // [rsp+20h] [rbp-88h] BYREF
  int v29; // [rsp+40h] [rbp-68h]
  __int64 lParam[4]; // [rsp+48h] [rbp-60h] BYREF
  int v31; // [rsp+68h] [rbp-40h]
  struct tagRECT Rect; // [rsp+70h] [rbp-38h] BYREF

  v4 = a2 - 16;
  v5 = qword_140130CB0;
  if ( v4 )
  {
    v7 = v4 - 62;
    if ( v7 )
    {
      v8 = v7 - 194;
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          if ( a3 > 0x488u )
          {
            switch ( a3 )
            {
              case 0x48Bu:
              case 0x4ACu:
              case 0x4ADu:
              case 0x4B3u:
              case 0x4B4u:
              case 0x4C5u:
              case 0x4F0u:
              case 0x4F4u:
              case 0x4F8u:
              case 0x4F9u:
              case 0x4FAu:
              case 0x4FDu:
              case 0x4FFu:
                goto LABEL_8;
              default:
                return 0i64;
            }
          }
          else if ( a3 == 1160 || a3 == 1004 )
          {
LABEL_8:
            SendMessageW(qword_14012DB38, 0x468u, (WPARAM)hDlg, 0i64);
          }
        }
      }
      else
      {
        if ( *(_DWORD *)(qword_140130CB0 + 60852) )
          CheckDlgButton(hDlg, 1221, 1u);
        if ( *(_DWORD *)(v5 + 60908) )
          CheckDlgButton(hDlg, 1279, 1u);
        if ( *(_DWORD *)(v5 + 60776) )
          CheckDlgButton(hDlg, 1268, 1u);
        if ( *(_DWORD *)(v5 + 60888) )
          CheckDlgButton(hDlg, 1274, 1u);
        if ( *(_DWORD *)(v5 + 60840) )
          CheckDlgButton(hDlg, 1203, 1u);
        if ( *(_DWORD *)(v5 + 60784) )
          CheckDlgButton(hDlg, 1004, 1u);
        if ( *(_DWORD *)(v5 + 60832) )
          CheckDlgButton(hDlg, 1204, 1u);
        if ( *(_DWORD *)(v5 + 60836) )
          CheckDlgButton(hDlg, 1264, 1u);
        if ( *(_DWORD *)(v5 + 60900) )
          CheckDlgButton(hDlg, 1272, 1u);
        if ( *(_DWORD *)(v5 + 60904) )
          CheckDlgButton(hDlg, 1277, 1u);
        if ( !*(_DWORD *)(v5 + 60812) )
          CheckDlgButton(hDlg, 1163, 1u);
        if ( *(_DWORD *)(v5 + 60824) )
          CheckDlgButton(hDlg, 1196, 1u);
        if ( *(_DWORD *)(v5 + 60964) )
          CheckDlgButton(hDlg, 1160, 1u);
        if ( *(_DWORD *)(v5 + 60876) )
          CheckDlgButton(hDlg, 1273, 1u);
        if ( *(_DWORD *)(v5 + 60828) )
          CheckDlgButton(hDlg, 1197, 1u);
      }
    }
    else if ( *(_DWORD *)(a4 + 16) == -202 )
    {
      v9 = 0i64;
      *(_DWORD *)(v5 + 60852) = IsDlgButtonChecked(hDlg, 1221) == 1;
      *(_DWORD *)(v5 + 60776) = IsDlgButtonChecked(hDlg, 1268) == 1;
      *(_DWORD *)(v5 + 60888) = IsDlgButtonChecked(hDlg, 1274) == 1;
      *(_DWORD *)(v5 + 60840) = IsDlgButtonChecked(hDlg, 1203) == 1;
      *(_DWORD *)(v5 + 60784) = IsDlgButtonChecked(hDlg, 1004) == 1;
      *(_DWORD *)(v5 + 60832) = IsDlgButtonChecked(hDlg, 1204) == 1;
      *(_DWORD *)(v5 + 60836) = IsDlgButtonChecked(hDlg, 1264) == 1;
      *(_DWORD *)(v5 + 60900) = IsDlgButtonChecked(hDlg, 1272) == 1;
      *(_DWORD *)(v5 + 60904) = IsDlgButtonChecked(hDlg, 1277) == 1;
      *(_DWORD *)(v5 + 60812) = IsDlgButtonChecked(hDlg, 1163) != 1;
      *(_DWORD *)(v5 + 60824) = IsDlgButtonChecked(hDlg, 1196) == 1;
      *(_DWORD *)(v5 + 60964) = IsDlgButtonChecked(hDlg, 1160) == 1;
      v10 = IsDlgButtonChecked(hDlg, 1273) == 1;
      if ( *(_DWORD *)(v5 + 60876) != v10 )
      {
        v11 = SendMessageW(*(HWND *)(v5 + 136), 0x1304u, 0i64, 0i64);
        v12 = v10;
        if ( v11 > 0 )
        {
          v13 = 0i64;
          v14 = (unsigned int)v11;
          do
          {
            v15 = *(HWND *)(v5 + 136);
            LODWORD(lParam[0]) = 8;
            SendMessageW(v15, 0x133Cu, v13, (LPARAM)lParam);
            v16 = SendMessageW(*(HWND *)(v5 + 8i64 * v31 + 184), 0x1037u, 0i64, 0i64);
            if ( v12 )
              v17 = v16 | 4;
            else
              v17 = v16 & 0xFFFFFFFB;
            SendMessageW(*(HWND *)(v5 + 8i64 * v31 + 184), 0x1036u, 0i64, v17);
            ++v13;
            --v14;
          }
          while ( v14 );
        }
        *(_DWORD *)(v5 + 60876) = IsDlgButtonChecked(hDlg, 1273) == 1;
      }
      *(_DWORD *)(v5 + 60828) = IsDlgButtonChecked(hDlg, 1197) == 1;
      if ( *(_DWORD *)(v5 + 60908) != (IsDlgButtonChecked(hDlg, 1279) == 1) )
      {
        *(_DWORD *)(v5 + 60908) = IsDlgButtonChecked(hDlg, 1279) == 1;
        sub_14008FB90(v5);
      }
      sub_1400D05E0(v5);
      if ( *(_DWORD *)(v5 + 60776) )
        *(_DWORD *)(v5 + 60780) = 1;
      else
        *(_DWORD *)(v5 + 60780) = (int)SendMessageW(*(HWND *)(v5 + 136), 0x1304u, 0i64, 0i64) > 1;
      GetClientRect(*(HWND *)(v5 + 104), &Rect);
      SendMessageW(*(HWND *)(v5 + 104), 5u, 0i64, LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
      v18 = SendMessageW(*(HWND *)(v5 + 136), 0x1304u, 0i64, 0i64);
      if ( v18 > 0 )
      {
        v19 = (unsigned int)v18;
        do
        {
          v20 = *(HWND *)(v5 + 136);
          LODWORD(v28[0]) = 8;
          SendMessageW(v20, 0x133Cu, v9, (LPARAM)v28);
          v21 = *(_QWORD *)(v5 + 8i64 * v29 + 1832);
          if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v21 + 608i64))(v21) != *(_DWORD *)(v5 + 60964) )
          {
            v22 = *(_QWORD *)(v5 + 8i64 * v29 + 1832);
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v22 + 600i64))(v22);
          }
          v23 = *(_DWORD *)(v5 + 60828);
          v24 = *(HWND *)(v5 + 8i64 * v29 + 184);
          v25 = SendMessageW(v24, 0x1037u, 0i64, 0i64);
          if ( v23 )
            v26 = v25 | 0x20;
          else
            v26 = v25 & 0xFFFFFFDF;
          SendMessageW(v24, 0x1036u, 0i64, v26);
          ++v9;
          --v19;
        }
        while ( v19 );
      }
      sub_1400B0500(v5);
    }
  }
  else
  {
    EndDialog(hDlg, 0i64);
  }
  return 0i64;
}
// 140130CB0: using guessed type __int64 qword_140130CB0;
// 1400AE520: using guessed type LPARAM lParam[4];
// 1400AE520: using guessed type LPARAM var_88[4];

//----- (00000001400AEC60) ----------------------------------------------------
__int64 __fastcall sub_1400AEC60(HWND hDlg, int a2, unsigned __int16 a3, __int64 a4)
{
  if ( a2 == 272 )
    qword_140130CB0 = *(_QWORD *)(a4 + 48);
  return sub_1400AE520(hDlg, a2, a3, a4);
}
// 140130CB0: using guessed type __int64 qword_140130CB0;

//----- (00000001400AEC80) ----------------------------------------------------
HWND __fastcall sub_1400AEC80(__int64 a1)
{
  __int64 v2; // rsi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  __int64 v5; // rax
  HWND result; // rax
  __int64 v7[6]; // [rsp+30h] [rbp-D0h] BYREF
  int v8[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v9; // [rsp+68h] [rbp-98h]
  __int64 v10; // [rsp+78h] [rbp-88h]
  WCHAR *v11; // [rsp+80h] [rbp-80h]
  int v12; // [rsp+88h] [rbp-78h]
  int v13; // [rsp+90h] [rbp-70h]
  __int64 *v14; // [rsp+98h] [rbp-68h]
  __int64 (__fastcall *v15)(HWND, int); // [rsp+A0h] [rbp-60h]
  __int64 v16[12]; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v17[12]; // [rsp+120h] [rbp+20h] BYREF
  __int64 v18[12]; // [rsp+180h] [rbp+80h] BYREF
  __int64 v19[12]; // [rsp+1E0h] [rbp+E0h] BYREF
  __int64 v20[12]; // [rsp+240h] [rbp+140h] BYREF
  WCHAR Buffer[64]; // [rsp+2A0h] [rbp+1A0h] BYREF

  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  hIcon = sub_14000A470(v2, 0xFu, 0);
  v16[1] = (__int64)hInstance;
  v16[0] = 96i64;
  v16[2] = 135i64;
  v16[5] = (__int64)sub_1400ADF70;
  v16[6] = a1;
  v7[0] = sub_140018580((__int64)v16);
  v17[1] = (__int64)hInstance;
  v17[0] = 96i64;
  v17[2] = 9i64;
  v17[6] = a1;
  v17[5] = (__int64)sub_1400AD8E0;
  v5 = sub_140018580((__int64)v17);
  v18[0] = 96i64;
  v7[1] = v5;
  v18[2] = 227i64;
  v18[1] = (__int64)hInstance;
  v18[6] = a1;
  v18[5] = (__int64)sub_1400AEC60;
  v7[2] = sub_140018580((__int64)v18);
  v19[0] = 96i64;
  v19[1] = (__int64)hInstance;
  v19[2] = 166i64;
  v19[5] = (__int64)sub_1400ACF80;
  v19[6] = a1;
  v7[3] = sub_140018580((__int64)v19);
  v20[1] = (__int64)hInstance;
  v20[0] = 96i64;
  v20[2] = 181i64;
  v20[6] = a1;
  v20[5] = (__int64)sub_1400AE500;
  v7[4] = sub_140018580((__int64)v20);
  LoadStringW(hInstance, 0x2011u, Buffer, 64);
  v8[0] = 96;
  v8[1] = 33555714;
  v9 = *(_QWORD *)(a1 + 104);
  v12 = 5;
  v13 = 0;
  v11 = Buffer;
  v10 = sub_14000A470(v2, 0x19u, 1u);
  v14 = v7;
  v15 = sub_1400AC650;
  DeleteObject(BitmapW);
  sub_14000A390(v2);
  result = (HWND)sub_1400183D0((__int64)v8);
  hWnd = result;
  return result;
}

//----- (00000001400AEF20) ----------------------------------------------------
__int64 __fastcall sub_1400AEF20(__int64 a1)
{
  return *(_QWORD *)(a1 + 2584);
}

//----- (00000001400AEF30) ----------------------------------------------------
__int64 __fastcall sub_1400AEF30(__int64 a1)
{
  return *(_QWORD *)(a1 + 4744);
}

//----- (00000001400AEF40) ----------------------------------------------------
HWND __fastcall sub_1400AEF40(__int64 a1, int a2)
{
  HWND result; // rax

  result = hDlg;
  if ( a2 == 224 )
    result = 0i64;
  hDlg = result;
  return result;
}

//----- (00000001400AEF70) ----------------------------------------------------
BOOL __fastcall sub_1400AEF70(__int64 a1)
{
  BOOL result; // eax

  if ( *(_DWORD *)(a1 + 60912) )
    return PlaySoundW((LPCWSTR)0xEB, 0i64, 0x40005u);
  return result;
}

//----- (00000001400AEFA0) ----------------------------------------------------
__int64 __fastcall sub_1400AEFA0(__int64 a1, unsigned int a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  int v9; // [rsp+30h] [rbp+8h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v4 + 56i64))(v4, &v9);
  v5 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 72i64))(v5) && a2 == v9 )
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 464i64))(*(_QWORD *)(a1 + 2640));
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
    if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 72i64))(v6) )
      (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 2640) + 216i64))(*(_QWORD *)(a1 + 2640), 1i64);
  }
  v7 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 32i64))(v7, a2);
}

//----- (00000001400AF050) ----------------------------------------------------
__int64 __fastcall sub_1400AF050(__int64 a1, unsigned int a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  int v9; // [rsp+30h] [rbp+8h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v4 + 56i64))(v4, &v9);
  v5 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 72i64))(v5) || a2 != v9 )
  {
    v6 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
    if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 72i64))(v6) )
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 208i64))(*(_QWORD *)(a1 + 2640), 0i64);
  }
  else
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 464i64))(*(_QWORD *)(a1 + 2640));
  }
  v7 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 32i64))(v7, a2);
}

//----- (00000001400AF190) ----------------------------------------------------
__int64 __fastcall sub_1400AF190(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 60002i64;
      break;
    case 2:
      result = 60003i64;
      break;
    case 3:
      result = 60004i64;
      break;
    case 4:
      result = 60005i64;
      break;
    case 5:
      result = 60001i64;
      break;
    case 6:
      result = 60000i64;
      break;
    case 7:
      result = 60008i64;
      break;
    case 8:
      result = 60007i64;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (00000001400AF210) ----------------------------------------------------
BOOL __fastcall sub_1400AF210(__int64 a1, int a2)
{
  HWND v3; // rcx
  struct tagPOINT Point; // [rsp+50h] [rbp+8h] BYREF

  v3 = *(HWND *)(a1 + 128);
  Point.x = (__int16)a2;
  Point.y = SHIWORD(a2);
  ClientToScreen(v3, &Point);
  return TrackPopupMenu(*(HMENU *)(a1 + 4904), 0x42u, Point.x, Point.y, 0, *(HWND *)(a1 + 104), 0i64);
}

//----- (00000001400AF280) ----------------------------------------------------
LRESULT __fastcall sub_1400AF280(__int64 a1, __int64 a2, int a3)
{
  LPARAM v4; // r12
  LRESULT result; // rax
  unsigned int v7; // ebx
  unsigned int v8; // edi
  HWND v9; // rcx
  LPARAM lParam[14]; // [rsp+20h] [rbp-78h] BYREF

  v4 = a3;
  result = SendMessageW(*(HWND *)(a1 + 120), 0x40Cu, 0i64, 0i64);
  v7 = 0;
  v8 = result;
  if ( (_DWORD)result )
  {
    while ( 1 )
    {
      v9 = *(HWND *)(a1 + 120);
      lParam[0] = 0x1000000070i64;
      result = SendMessageW(v9, 0x41Cu, v7, (LPARAM)lParam);
      if ( result )
      {
        if ( a2 == lParam[5] )
          break;
      }
      if ( ++v7 >= v8 )
        return result;
    }
    return SendMessageW(*(HWND *)(a1 + 120), 0x423u, v7, v4);
  }
  return result;
}

//----- (00000001400AF340) ----------------------------------------------------
__int64 __fastcall sub_1400AF340(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v3; // rbx
  int v4; // eax

  v1 = *(__int64 **)(a1 + 2640);
  v3 = *v1;
  v4 = (*(__int64 (__fastcall **)(__int64 *))(*v1 + 432))(v1);
  return (*(__int64 (__fastcall **)(_QWORD, bool))(v3 + 440))(*(_QWORD *)(a1 + 2640), v4 == 0);
}

//----- (00000001400AF3B0) ----------------------------------------------------
LRESULT __fastcall sub_1400AF3B0(__int64 a1, int a2)
{
  LRESULT result; // rax

  if ( a2 != -1 )
    return SendMessageW(*(HWND *)(a1 + 4800), 0x1076u, a2, 0i64);
  return result;
}

//----- (00000001400AF3E0) ----------------------------------------------------
LONG_PTR __fastcall sub_1400AF3E0(__int64 a1)
{
  WPARAM v2; // rbx
  unsigned int v3; // eax
  __int64 i; // rsi
  HWND v5; // rcx
  unsigned int v6; // eax
  int v7; // eax
  int v8; // ebx
  HWND v9; // rdi
  LONG_PTR WindowLongPtrW; // rax
  LPARAM lParam; // [rsp+20h] [rbp-78h] BYREF
  int v13; // [rsp+28h] [rbp-70h]

  v2 = 0i64;
  *(_DWORD *)(a1 + 60820) = *(_DWORD *)(a1 + 60820) == 0;
  v3 = SendMessageW(*(HWND *)(a1 + 120), 0x40Cu, 0i64, 0i64);
  if ( v3 )
  {
    for ( i = v3; i; --i )
    {
      v5 = *(HWND *)(a1 + 120);
      lParam = 0x100000070i64;
      SendMessageW(v5, 0x41Cu, v2, (LPARAM)&lParam);
      v6 = v13;
      if ( *(_DWORD *)(a1 + 60820) )
      {
        if ( (v13 & 0x80u) != 0 )
        {
          v6 = v13 & 0xFFFFFF7F;
          v13 &= ~0x80u;
        }
        if ( (v6 & 0x100) != 0 )
          goto LABEL_13;
        v7 = v6 | 0x100;
      }
      else
      {
        if ( (v13 & 0x100) != 0 )
        {
          v6 = v13 & 0xFFFFFEFF;
          v13 &= ~0x100u;
        }
        if ( (v6 & 0x80u) != 0 )
          goto LABEL_13;
        v7 = v6 | 0x80;
      }
      v13 = v7;
LABEL_13:
      SendMessageW(*(HWND *)(a1 + 120), 0x40Bu, v2++, (LPARAM)&lParam);
    }
  }
  v8 = *(_DWORD *)(a1 + 60820);
  v9 = *(HWND *)(a1 + 120);
  WindowLongPtrW = GetWindowLongPtrW(v9, -16);
  if ( v8 )
  {
    if ( (WindowLongPtrW & 0x800) == 0 )
      WindowLongPtrW |= 0x800ui64;
  }
  else if ( (WindowLongPtrW & 0x800) != 0 )
  {
    WindowLongPtrW = (unsigned int)WindowLongPtrW & 0xFFFFF7FF;
  }
  return SetWindowLongPtrW(v9, -16, WindowLongPtrW);
}

//----- (00000001400AF530) ----------------------------------------------------
void __fastcall sub_1400AF530(HMENU hMenu, UINT uPosition, int csidl)
{
  LPITEMIDLIST ppidl; // [rsp+30h] [rbp-288h] BYREF
  MENUITEMINFOW mii; // [rsp+40h] [rbp-278h] BYREF
  WCHAR pszBuf[264]; // [rsp+90h] [rbp-228h] BYREF

  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, csidl, 0i64, 0, &ppidl) )
  {
    mii.cbSize = 80;
    mii.fMask = 32;
    GetMenuItemInfoW(hMenu, uPosition, 0, &mii);
    free((void *)mii.dwItemData);
    DeleteMenu(hMenu, uPosition, 0);
  }
  else
  {
    sub_14007E270(ppidl, pszBuf, 1u);
    mii.dwTypeData = pszBuf;
    mii.cbSize = 80;
    mii.fMask = 64;
    SetMenuItemInfoW(hMenu, uPosition, 0, &mii);
    CoTaskMemFree(ppidl);
  }
}

//----- (00000001400AF640) ----------------------------------------------------
HWND __fastcall sub_1400AF640(__int64 a1)
{
  HWND v2; // rax
  HWND result; // rax
  HWND v4; // rcx
  HWND v5; // rdi

  if ( *(_DWORD *)(a1 + 62464) )
  {
    v2 = (HWND)SendMessageW(*(HWND *)(a1 + 4800), 0x1018u, 0i64, 0i64);
    return (HWND)SendMessageW(v2, 0x8037u, 9ui64, 0i64);
  }
  result = GetFocus();
  v4 = *(HWND *)(a1 + 4800);
  v5 = result;
  if ( result == v4 )
  {
    if ( *(_DWORD *)(a1 + 60752) )
      return SetFocus(*(HWND *)(a1 + 168));
    if ( *(_DWORD *)(a1 + 60748) )
      return SetFocus(*(HWND *)(a1 + 152));
  }
  else
  {
    if ( result != *(HWND *)(a1 + 152) )
    {
      result = (HWND)SendMessageW(*(HWND *)(a1 + 168), 0x407u, 0i64, 0i64);
      if ( v5 != result )
        return result;
      if ( *(_DWORD *)(a1 + 60748) )
        return SetFocus(*(HWND *)(a1 + 152));
      v4 = *(HWND *)(a1 + 4800);
    }
    return SetFocus(v4);
  }
  return result;
}

//----- (00000001400AF730) ----------------------------------------------------
HWND __fastcall sub_1400AF730(__int64 a1)
{
  HWND result; // rax
  HWND v3; // rcx
  HWND v4; // rdi

  result = GetFocus();
  v3 = *(HWND *)(a1 + 4800);
  v4 = result;
  if ( result == v3 )
  {
    if ( *(_DWORD *)(a1 + 60748) )
      return SetFocus(*(HWND *)(a1 + 152));
    if ( *(_DWORD *)(a1 + 60752) )
      return SetFocus(*(HWND *)(a1 + 168));
  }
  else
  {
    if ( result == *(HWND *)(a1 + 152) )
    {
      if ( *(_DWORD *)(a1 + 60752) )
        return SetFocus(*(HWND *)(a1 + 168));
    }
    else
    {
      result = (HWND)SendMessageW(*(HWND *)(a1 + 168), 0x407u, 0i64, 0i64);
      if ( v4 != result )
        return result;
      v3 = *(HWND *)(a1 + 4800);
    }
    return SetFocus(v3);
  }
  return result;
}

//----- (00000001400AF800) ----------------------------------------------------
__int64 __fastcall sub_1400AF800(__int64 a1, unsigned int a2)
{
  __int64 result; // rax
  __int64 v5; // rcx
  __int64 v6; // rcx
  unsigned int v7; // [rsp+38h] [rbp+10h] BYREF

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 512i64))(*(_QWORD *)(a1 + 2640));
  if ( a2 != (_DWORD)result )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 520i64))(*(_QWORD *)(a1 + 2640), a2);
    v5 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
    (*(void (__fastcall **)(__int64, unsigned int *))(*(_QWORD *)v5 + 56i64))(v5, &v7);
    v6 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 32i64))(v6, v7);
  }
  return result;
}

//----- (00000001400AF8A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400AF8A0(__int64 a1)
{
  unsigned __int64 result; // rax
  unsigned int v3; // ebx
  unsigned __int64 i; // rsi

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 592i64))(*(_QWORD *)(a1 + 2640));
  v3 = 0;
  for ( i = result; v3 < i; result = v3 )
    SendMessageW(*(HWND *)(a1 + 4800), 0x101Eu, (int)v3++, 0xFFFFi64);
  return result;
}

//----- (00000001400AF910) ----------------------------------------------------
LRESULT __fastcall sub_1400AF910(__int64 a1, int a2)
{
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  if ( a2 >= 70 )
    *(_DWORD *)(a1 + 7012) = a2;
  GetClientRect(*(HWND *)(a1 + 104), &Rect);
  return SendMessageW(*(HWND *)(a1 + 104), 5u, 0i64, LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
}

//----- (00000001400AF980) ----------------------------------------------------
LRESULT __fastcall sub_1400AF980(LRESULT a1, WPARAM a2, LPARAM a3)
{
  LRESULT result; // rax
  HWND v4; // rcx

  result = a1;
  v4 = *(HWND *)(a1 + 4816);
  if ( (HWND)a2 == v4 )
  {
    *(_QWORD *)(result + 4816) = a3;
  }
  else if ( v4 )
  {
    return SendMessageW(v4, 0x30Du, a2, a3);
  }
  return result;
}

//----- (00000001400AF9E0) ----------------------------------------------------
LRESULT __fastcall sub_1400AF9E0(__int64 a1, __int64 a2)
{
  LRESULT result; // rax
  WPARAM v5; // r8
  HWND v6; // rcx
  __int64 v7; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v9; // [rsp+40h] [rbp-18h]

  result = SendMessageW(*(HWND *)(a1 + 136), 0x132Du, 0i64, 0i64);
  if ( *(_QWORD *)a2 == result )
  {
    v5 = *(int *)(a2 + 8);
    v6 = *(HWND *)(a1 + 136);
    LODWORD(lParam[0]) = 8;
    SendMessageW(v6, 0x133Cu, v5, (LPARAM)lParam);
    v7 = *(_QWORD *)(a1 + 8i64 * v9 + 1832);
    result = (*(__int64 (__fastcall **)(__int64, __int64, void *))(*(_QWORD *)v7 + 104i64))(v7, 512i64, &unk_14012E6E0);
    *(_QWORD *)(a2 + 24) = &unk_14012E6E0;
  }
  return result;
}
// 1400AF9E0: using guessed type LPARAM lParam[4];

//----- (00000001400AFA70) ----------------------------------------------------
__int64 __fastcall sub_1400AFA70(__int64 a1, int a2, int a3)
{
  HWND v4; // rcx
  int v5; // er14
  int v6; // esi
  int v7; // er13
  int v9; // ebx
  int v10; // ecx
  int v11; // er15
  int v12; // er8
  UINT uFlags; // eax
  int v14; // er9
  int cy; // er12
  int v16; // ebx
  int v17; // er12
  int v18; // er13
  int v19; // eax
  int v20; // er12
  int v21; // ebx
  WPARAM v22; // r13
  __int64 v23; // r14
  HWND v24; // rcx
  UINT v25; // edx
  HWND v26; // rbx
  HWND v27; // rcx
  unsigned __int16 v28; // r13
  HWND v29; // rcx
  __int64 v33[2]; // [rsp+48h] [rbp-81h] BYREF
  unsigned __int16 v34; // [rsp+5Ah] [rbp-6Fh]
  __int64 lParam[4]; // [rsp+78h] [rbp-51h] BYREF
  int v36; // [rsp+98h] [rbp-31h]
  struct tagRECT Rect; // [rsp+A0h] [rbp-29h] BYREF
  struct tagRECT v38; // [rsp+B0h] [rbp-19h] BYREF
  struct tagRECT v39; // [rsp+C0h] [rbp-9h] BYREF
  struct tagRECT v40; // [rsp+D0h] [rbp+7h] BYREF

  v4 = *(HWND *)(a1 + 120);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v9 = a2;
  if ( v4 )
  {
    GetWindowRect(v4, &Rect);
    v7 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 60744) )
  {
    GetWindowRect(*(HWND *)(a1 + 112), &Rect);
    v5 = Rect.bottom - Rect.top;
  }
  if ( *(_DWORD *)(a1 + 60756) )
    v5 += *(_DWORD *)(a1 + 7012);
  if ( *(_DWORD *)(a1 + 60748) )
  {
    GetClientRect(*(HWND *)(a1 + 160), &Rect);
    v6 = Rect.right - Rect.left;
  }
  v10 = *(_DWORD *)(a1 + 60780);
  v11 = v7;
  if ( v10 && !*(_DWORD *)(a1 + 60888) )
    v11 = v7 + 24;
  if ( *(_DWORD *)(a1 + 60824) )
  {
    v12 = 0;
  }
  else
  {
    v12 = v6;
    v9 -= v6;
  }
  uFlags = 128;
  if ( v10 )
    uFlags = 64;
  if ( *(_DWORD *)(a1 + 60888) )
    v14 = a3 - v5 - 24;
  else
    v14 = v7;
  SetWindowPos(*(HWND *)(a1 + 992), *(HWND *)(a1 + 128), v12, v14, v9, 24, uFlags);
  SetWindowPos(*(HWND *)(a1 + 136), 0i64, 0, 0, v9 - 25, 24, 0x44u);
  SetWindowPos(*(HWND *)(a1 + 144), 0i64, v9 - 20, 5, 20, 20, 0x44u);
  if ( !*(_DWORD *)(a1 + 60824) )
    goto LABEL_26;
  if ( !*(_DWORD *)(a1 + 60888) )
    v7 = v11;
  if ( *(_DWORD *)(a1 + 60888) && *(_DWORD *)(a1 + 60780) )
    cy = a3 - v7 - v5 - 24;
  else
LABEL_26:
    cy = a3 - v7 - v5;
  v16 = *(_DWORD *)(a1 + 7044);
  SetWindowPos(*(HWND *)(a1 + 160), 0i64, 0, v7, v16, cy, 4u);
  SetWindowPos(*(HWND *)(a1 + 152), 0i64, 1, 20, v16 - 5, cy - 20, 4u);
  SetWindowPos(*(HWND *)(a1 + 984), 0i64, v16 - 20, 3, 16, 16, 0x44u);
  v17 = a3;
  v18 = a2;
  SetWindowPos(*(HWND *)(a1 + 128), 0i64, 0, a3 - v5, a2, *(_DWORD *)(a1 + 7012), 0x44u);
  v19 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( v19 > 0 )
  {
    v20 = a2 - v6;
    v21 = a3 - v11 - v5;
    v22 = 0i64;
    v23 = (unsigned int)v19;
    do
    {
      v24 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v24, 0x133Cu, v22, (LPARAM)lParam);
      v25 = 4;
      if ( v36 == *(_DWORD *)(a1 + 7048) )
        v25 = 68;
      if ( *(_DWORD *)(a1 + 60888) && *(_DWORD *)(a1 + 60780) )
        SetWindowPos(*(HWND *)(a1 + 8i64 * v36 + 184), 0i64, v6, v11, v20, v21 - 24, v25);
      else
        SetWindowPos(*(HWND *)(a1 + 8i64 * v36 + 184), 0i64, v6, v11, v20, v21, v25);
      ++v22;
      --v23;
    }
    while ( v23 );
    v17 = a3;
    v18 = a2;
  }
  v26 = *(HWND *)(a1 + 112);
  GetWindowRect(v26, &v38);
  SetWindowPos(v26, 0i64, 0, v38.top + v17 - v38.bottom, v18, 24, 4u);
  v27 = *(HWND *)(a1 + 112);
  v38.right = v18;
  v38.left = (int)((double)v18 * 0.5);
  v38.top = (int)((double)v18 * 0.75);
  SendMessageW(v27, 0x404u, 3ui64, (LPARAM)&v38);
  MoveWindow(*(HWND *)(a1 + 120), 0, 0, v18, 0, 0);
  GetWindowRect(*(HWND *)(a1 + 104), &v39);
  GetWindowRect(*(HWND *)(a1 + 168), &v40);
  v28 = LOWORD(v39.left) + v18 - LOWORD(v40.left) - 22;
  MoveWindow(*(HWND *)(a1 + 168), 0, 0, v28, 0, 0);
  v29 = *(HWND *)(a1 + 1000);
  v33[0] = 0x8000004000000030ui64;
  v34 = v28;
  SendMessageW(v29, 0x440u, 0i64, (LPARAM)v33);
  SetFocus(*(HWND *)(a1 + 4808));
  return 1i64;
}
// 1400AFC09: conditional instruction was optimized away because er11.4!=0
// 1400AFA70: using guessed type LPARAM lParam[4];
// 1400AFA70: using guessed type LPARAM var_D8[2];

//----- (00000001400AFF20) ----------------------------------------------------
BOOL __fastcall sub_1400AFF20(__int64 a1, int a2)
{
  DWORD MessagePos; // eax
  HMENU v5; // rcx
  HWND hWnd; // [rsp+28h] [rbp-20h]

  SetFocus(*(HWND *)(a1 + 176));
  MessagePos = GetMessagePos();
  hWnd = *(HWND *)(a1 + 120);
  v5 = *(HMENU *)(a1 + 4888);
  *(_DWORD *)(a1 + 62064) = a2;
  return TrackPopupMenu(v5, 0, (__int16)MessagePos, SHIWORD(MessagePos), 0, hWnd, 0i64);
}

//----- (00000001400AFF90) ----------------------------------------------------
BOOL __fastcall sub_1400AFF90(__int64 a1)
{
  HMENU v2; // rcx
  UINT v3; // er8
  UINT v4; // er8
  UINT v5; // er8
  UINT v6; // er8
  UINT v7; // er8
  UINT v8; // er8
  DWORD MessagePos; // eax

  v2 = *(HMENU *)(a1 + 4880);
  if ( *(_DWORD *)(a1 + 60752) )
    v3 = 8;
  else
    v3 = 0;
  CheckMenuItem(v2, 0x9D5Au, v3);
  if ( *(_DWORD *)(a1 + 60760) )
    v4 = 8;
  else
    v4 = 0;
  CheckMenuItem(*(HMENU *)(a1 + 4880), 0x9D63u, v4);
  if ( *(_DWORD *)(a1 + 60764) )
    v5 = 8;
  else
    v5 = 0;
  CheckMenuItem(*(HMENU *)(a1 + 4880), 0x9D64u, v5);
  if ( *(_DWORD *)(a1 + 60768) )
    v6 = 8;
  else
    v6 = 0;
  CheckMenuItem(*(HMENU *)(a1 + 4880), 0x9D8Bu, v6);
  if ( *(_DWORD *)(a1 + 60772) )
    v7 = 8;
  else
    v7 = 0;
  CheckMenuItem(*(HMENU *)(a1 + 4880), 0x9D9Du, v7);
  if ( *(_DWORD *)(a1 + 60820) )
    v8 = 8;
  else
    v8 = 0;
  CheckMenuItem(*(HMENU *)(a1 + 4880), 0x9D98u, v8);
  SetFocus(*(HWND *)(a1 + 176));
  MessagePos = GetMessagePos();
  return TrackPopupMenu(
           *(HMENU *)(a1 + 4880),
           0,
           (__int16)MessagePos,
           SHIWORD(MessagePos),
           0,
           *(HWND *)(a1 + 120),
           0i64);
}

//----- (00000001400B00D0) ----------------------------------------------------
void __fastcall sub_1400B00D0(__int64 a1, ITEMIDLIST *a2, const WCHAR *a3)
{
  LPITEMIDLIST v6; // rsi
  HWND v7; // rcx
  SHELLEXECUTEINFOW pExecInfo; // [rsp+20h] [rbp-2A8h] BYREF
  WCHAR pszBuf[264]; // [rsp+90h] [rbp-238h] BYREF

  v6 = ILClone(a2);
  ILRemoveLastID(v6);
  sub_14007E270(v6, pszBuf, 0x8000u);
  v7 = *(HWND *)(a1 + 104);
  pExecInfo.lpVerb = (LPCWSTR)&unk_1400EBF44;
  pExecInfo.hwnd = v7;
  pExecInfo.lpDirectory = pszBuf;
  pExecInfo.cbSize = 112;
  pExecInfo.fMask = 12;
  pExecInfo.lpIDList = a2;
  pExecInfo.lpFile = 0i64;
  pExecInfo.hInstApp = 0i64;
  pExecInfo.nShow = 5;
  pExecInfo.lpParameters = a3;
  ShellExecuteExW(&pExecInfo);
  CoTaskMemFree(v6);
}

//----- (00000001400B01C0) ----------------------------------------------------
void __fastcall sub_1400B01C0(__int64 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  ITEMIDLIST *v8; // rdi
  const ITEMIDLIST *v9; // rax
  ITEMIDLIST *v10; // rsi
  LPITEMIDLIST v11; // rbx

  v8 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  v9 = (const ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                             *(_QWORD *)(a1 + 2640),
                             a2);
  v10 = (ITEMIDLIST *)v9;
  if ( v9 )
  {
    v11 = ILCombine(v8, v9);
    (*(void (__fastcall **)(__int64, LPITEMIDLIST, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 64i64))(a1 + 56, v11, a3, a4);
    CoTaskMemFree(v11);
    CoTaskMemFree(v10);
  }
  CoTaskMemFree(v8);
}

//----- (00000001400B0270) ----------------------------------------------------
int __fastcall sub_1400B0270(HMENU a1, UINT a2, int a3)
{
  _DWORD *dwItemData; // rax
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-58h] BYREF

  mii.cbSize = 80;
  mii.fMask = 32;
  LODWORD(dwItemData) = GetMenuItemInfoW(a1, a2, 0, &mii);
  if ( (_DWORD)dwItemData )
  {
    dwItemData = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *dwItemData = a3;
  }
  return (int)dwItemData;
}

//----- (00000001400B02C0) ----------------------------------------------------
BOOL __fastcall sub_1400B02C0(HMENU hmenu, UINT item)
{
  _DWORD *v4; // rax
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-58h] BYREF

  mii.cbSize = 80;
  mii.fMask = 258;
  GetMenuItemInfoW(hmenu, item, 1, &mii);
  if ( (mii.fType & 0x100) == 0 )
    mii.fType |= 0x100u;
  v4 = malloc(0x10ui64);
  v4[1] = 0;
  *((_QWORD *)v4 + 1) = 0i64;
  mii.fMask |= 0x20u;
  mii.dwItemData = (ULONG_PTR)v4;
  return SetMenuItemInfoW(hmenu, item, 1, &mii);
}

//----- (00000001400B0350) ----------------------------------------------------
void __fastcall sub_1400B0350(__int64 a1, HMENU a2)
{
  int MenuItemCount; // eax

  MenuItemCount = GetMenuItemCount(a2);
  sub_1400B08E0(a1, a2, MenuItemCount);
}

//----- (00000001400B0390) ----------------------------------------------------
__int64 sub_1400B0390()
{
  DWORD CurrentProcessId; // eax
  HANDLE v1; // rax
  void *v2; // rbx
  HANDLE FileW; // rax
  WCHAR pszPath[264]; // [rsp+40h] [rbp-228h] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v1 = OpenProcess(0x410u, 0, CurrentProcessId);
  v2 = v1;
  if ( v1 )
  {
    GetModuleFileNameExW(v1, 0i64, pszPath, 260i64);
    CloseHandle(v2);
  }
  PathRemoveFileSpecW(pszPath);
  PathAppendW(pszPath, L"config.xml");
  FileW = CreateFileW(pszPath, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
  if ( FileW == (HANDLE)-1i64 )
    return 0i64;
  CloseHandle(FileW);
  return 1i64;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400B0470) ----------------------------------------------------
__int64 __fastcall sub_1400B0470(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 7096) = 0;
  result = sub_1400B0390();
  *(_DWORD *)(a1 + 7096) = result;
  return result;
}

//----- (00000001400B04B0) ----------------------------------------------------
void __fastcall sub_1400B04B0(ULONG_PTR Parameter)
{
  CoInitializeEx(0i64, 2u);
}

//----- (00000001400B04D0) ----------------------------------------------------
void __fastcall __noreturn sub_1400B04D0(LPVOID lpThreadParameter)
{
  while ( 1 )
    SleepEx(0xFFFFFFFF, 1);
}

//----- (00000001400B0500) ----------------------------------------------------
__int64 __fastcall sub_1400B0500(__int64 a1)
{
  _DWORD *v2; // rbx

  if ( *(_DWORD *)(a1 + 60816) )
  {
    v2 = operator new(0x38ui64);
    if ( v2 )
    {
      *(_QWORD *)v2 = &Explorerplusplus::CLoadSaveXML::`vftable';
      v2[2] = 1;
      *((_QWORD *)v2 + 2) = a1;
      v2[6] = 0;
      sub_140085400((__int64)v2);
    }
    else
    {
      v2 = 0i64;
    }
  }
  else
  {
    v2 = operator new(0x18ui64);
    if ( v2 )
    {
      *(_QWORD *)v2 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
      v2[2] = 1;
      *((_QWORD *)v2 + 2) = a1;
    }
    else
    {
      v2 = 0i64;
    }
  }
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 88i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 104i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 112i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 96i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 120i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 128i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 136i64))(v2);
  (*(void (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 144i64))(v2);
  return (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v2 + 16i64))(v2);
}
// 1400F6EB8: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';
// 1400F79C8: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (00000001400B0600) ----------------------------------------------------
BOOL __fastcall sub_1400B0600(__int64 a1)
{
  HWND v2; // rcx
  __int64 v3; // rcx
  UINT v4; // eax
  struct tagPOINT Point; // [rsp+40h] [rbp-38h] BYREF
  int v7; // [rsp+48h] [rbp-30h] BYREF
  LPARAM lParam; // [rsp+50h] [rbp-28h] BYREF
  LONG v9; // [rsp+5Ch] [rbp-1Ch]

  SendMessageW(*(HWND *)(a1 + 176), 0x433u, 0xAFD5ui64, (LPARAM)&lParam);
  v2 = *(HWND *)(a1 + 176);
  Point.x = lParam;
  Point.y = v9;
  ClientToScreen(v2, &Point);
  v3 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v3 + 48i64))(v3, &v7);
  v4 = sub_1400AF190(v7);
  CheckMenuRadioItem(*(HMENU *)(a1 + 4912), 0xEA60u, 0xEA68u, v4, 0);
  return TrackPopupMenu(*(HMENU *)(a1 + 4912), 0, Point.x, Point.y, 0, *(HWND *)(a1 + 104), 0i64);
}

//----- (00000001400B0710) ----------------------------------------------------
__int64 __fastcall sub_1400B0710(__int64 a1, int a2)
{
  __int64 v2; // rbp
  __int64 v4; // rcx
  unsigned int v5; // eax
  unsigned int v6; // eax
  _QWORD *v7; // rbx
  int v8; // eax
  char v10[528]; // [rsp+30h] [rbp-448h] BYREF
  __int16 pszBuf[264]; // [rsp+240h] [rbp-238h] BYREF

  v2 = a2;
  v4 = *(_QWORD *)(a1 + 8i64 * a2 + 1832);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 328i64))(v4);
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2648) + 40i64))(*(_QWORD *)(a1 + 2648), v5);
  (*(void (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 + 8 * v2 + 1832) + 104i64))(
    *(_QWORD *)(a1 + 8 * v2 + 1832),
    260i64,
    v10);
  sub_14007E090(10, (LPWSTR)pszBuf);
  if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v2 + 1832) + 288i64))(*(_QWORD *)(a1 + 8 * v2 + 1832)) )
  {
    v6 = -1;
  }
  else
  {
    v7 = malloc(0x10ui64);
    *(_DWORD *)v7 = v2;
    v8 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v2 + 1832) + 48i64))(*(_QWORD *)(a1 + 8 * v2 + 1832));
    v7[1] = a1;
    *((_DWORD *)v7 + 1) = v8;
    v6 = (*(__int64 (__fastcall **)(_QWORD, char *, __int64, void (__fastcall *)(__int64, unsigned int, int *), _DWORD, _QWORD *))(**(_QWORD **)(a1 + 2648) + 32i64))(
           *(_QWORD *)(a1 + 2648),
           v10,
           383i64,
           sub_1400B5510,
           0,
           v7);
  }
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8 * v2 + 1832) + 312i64))(
           *(_QWORD *)(a1 + 8 * v2 + 1832),
           v6);
}
// 1400B0710: using guessed type WCHAR pszBuf[264];

//----- (00000001400B0830) ----------------------------------------------------
__int64 __fastcall sub_1400B0830(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 60808)
    && (int)SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) > 1
    && MessageBoxW(*(HWND *)(a1 + 104), L"Are you sure you want to close all the current tabs?", L"Explorer++", 0x44u) == 7 )
  {
    return 1i64;
  }
  *(_DWORD *)(a1 + 7056) = *(_DWORD *)(a1 + 7060);
  *(_DWORD *)(a1 + 60892) = *(_DWORD *)(a1 + 60896);
  sub_1400B0500(a1);
  RevokeDragDrop(*(HWND *)(a1 + 136));
  DestroyWindow(*(HWND *)(a1 + 104));
  return 0i64;
}

//----- (00000001400B08E0) ----------------------------------------------------
void __fastcall sub_1400B08E0(__int64 a1, HMENU a2, int a3)
{
  signed int i; // ebx
  _DWORD *v6; // rax
  HMENU hSubMenu; // rdi
  int MenuItemCount; // eax
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-A8h] BYREF
  struct tagMENUITEMINFOW v10; // [rsp+70h] [rbp-58h] BYREF

  if ( a3 > 0 )
  {
    for ( i = 0; i < a3; ++i )
    {
      mii.cbSize = 80;
      mii.fMask = 258;
      GetMenuItemInfoW(a2, i, 1, &mii);
      if ( (mii.fType & 0x100) == 0 )
        mii.fType |= 0x100u;
      v6 = malloc(0x10ui64);
      v6[1] = 0;
      *((_QWORD *)v6 + 1) = 0i64;
      mii.fMask |= 0x20u;
      mii.dwItemData = (ULONG_PTR)v6;
      SetMenuItemInfoW(a2, i, 1, &mii);
      v10.cbSize = 80;
      v10.fMask = 4;
      GetMenuItemInfoW(a2, i, 1, &v10);
      hSubMenu = v10.hSubMenu;
      if ( v10.hSubMenu )
      {
        MenuItemCount = GetMenuItemCount(v10.hSubMenu);
        sub_1400B08E0(a1, hSubMenu, MenuItemCount);
      }
    }
  }
}

//----- (00000001400B0A00) ----------------------------------------------------
BOOL __fastcall sub_1400B0A00(__int64 a1)
{
  DWORD CurrentProcessId; // eax
  HANDLE v3; // rax
  void *v4; // rbx
  SHELLEXECUTEINFOW pExecInfo; // [rsp+20h] [rbp-6B8h] BYREF
  char v7[528]; // [rsp+90h] [rbp-648h] BYREF
  char v8[528]; // [rsp+2A0h] [rbp-438h] BYREF
  __int16 v9[264]; // [rsp+4B0h] [rbp-228h] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  v4 = v3;
  if ( v3 )
  {
    GetModuleFileNameExW(v3, 0i64, v8, 260i64);
    CloseHandle(v4);
  }
  (*(void (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    v7);
  sub_140001000((wchar_t *)v9, 0x104ui64, L"\"%s\"", v7);
  pExecInfo.lpVerb = L"open";
  pExecInfo.lpDirectory = 0i64;
  pExecInfo.lpFile = (LPCWSTR)v8;
  pExecInfo.hwnd = 0i64;
  *(_QWORD *)&pExecInfo.cbSize = 112i64;
  pExecInfo.nShow = 5;
  pExecInfo.lpParameters = (LPCWSTR)v9;
  return ShellExecuteExW(&pExecInfo);
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400F3C98: using guessed type wchar_t aS_2[5];
// 1400F3CA8: using guessed type wchar_t aOpen_5[5];
// 1400B0A00: using guessed type wchar_t var_228[264];

//----- (00000001400B0B20) ----------------------------------------------------
void __fastcall sub_1400B0B20(__int64 a1)
{
  HWND v2; // rcx
  void *pv[2]; // [rsp+20h] [rbp-10428h] BYREF
  WCHAR Buffer[512]; // [rsp+30h] [rbp-10418h] BYREF
  char v5[65536]; // [rsp+430h] [rbp-10018h] BYREF

  pv[0] = 0i64;
  if ( (int)sub_1400D2E20((const WCHAR *)(a1 + 4920), v5) < 0 )
  {
    LoadStringW(hInstance, 0x200Bu, Buffer, 512);
    MessageBoxW(*(HWND *)(a1 + 104), Buffer, L"Explorer++", 0x10u);
  }
  else
  {
    v2 = *(HWND *)(a1 + 4800);
    *(_DWORD *)(a1 + 62404) = 1;
    sub_140081CC0(v2);
    SetFocus(*(HWND *)(a1 + 4800));
    sub_14007F810((__int64)v5, (__int64)pv);
    (*(void (__fastcall **)(_QWORD, void *))(**(_QWORD **)(a1 + 2640) + 656i64))(*(_QWORD *)(a1 + 2640), pv[0]);
    CoTaskMemFree(pv[0]);
  }
}
// 1400B0B20: using guessed type LPVOID pv[2];

//----- (00000001400B0C20) ----------------------------------------------------
__int64 __fastcall sub_1400B0C20(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, int a5)
{
  void *v6; // rdx
  int v10; // eax
  int v11; // ebx
  void *pv[5]; // [rsp+30h] [rbp-28h] BYREF

  v6 = 0i64;
  pv[0] = 0i64;
  if ( a2 )
  {
    v10 = sub_14007F810(a2, (__int64)pv);
    v6 = pv[0];
    v11 = v10;
  }
  else
  {
    v11 = -2147467259;
  }
  (*(void (__fastcall **)(__int64, void *, _QWORD, _QWORD, int, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    v6,
    a3,
    a4,
    a5,
    0);
  if ( v11 >= 0 )
    CoTaskMemFree(pv[0]);
  return (unsigned int)v11;
}
// 1400B0C20: using guessed type LPVOID pv[5];

//----- (00000001400B0CD0) ----------------------------------------------------
LRESULT __fastcall sub_1400B0CD0(__int64 a1, int a2, __int64 a3)
{
  LRESULT result; // rax
  __int16 lParam[512]; // [rsp+20h] [rbp-418h] BYREF

  if ( a2 == *(_DWORD *)(a1 + 7048) )
  {
    sub_140001000((wchar_t *)lParam, 0x200ui64, L"Loading %s...", a3);
    SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 0i64, (LPARAM)lParam);
    SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 1ui64, (LPARAM)&unk_1400EBFCC);
    return SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 2ui64, (LPARAM)&unk_1400EC00C);
  }
  return result;
}
// 1400F3B90: using guessed type wchar_t aLoadingS[14];
// 1400B0CD0: using guessed type wchar_t lParam[512];

//----- (00000001400B0D80) ----------------------------------------------------
HWND __fastcall sub_1400B0D80(__int64 a1)
{
  HWND result; // rax
  __int64 v3; // rbx
  __int64 v4; // rdx
  WCHAR *v5; // rcx
  WCHAR v6; // ax
  int v7; // ebx
  void *pv[2]; // [rsp+30h] [rbp-918h] BYREF
  SHFILEINFOW psfi; // [rsp+40h] [rbp-908h] BYREF
  WCHAR v10[264]; // [rsp+300h] [rbp-648h] BYREF
  WCHAR v11[264]; // [rsp+510h] [rbp-438h] BYREF
  WCHAR pszPath[264]; // [rsp+720h] [rbp-228h] BYREF

  result = (HWND)SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 1i64);
  if ( (_DWORD)result != -1 )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
      *(_QWORD *)(a1 + 2640),
      (unsigned int)result,
      pszPath);
    v3 = *(_QWORD *)(a1 + 104);
    result = (HWND)SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x800u);
    if ( result )
    {
      result = (HWND)sub_1400D2C10(v3, 0, (__int64)pszPath, v10, (__int64)&psfi);
      if ( !(_DWORD)result )
      {
        v4 = 260i64;
        v5 = v11;
        while ( v4 != -2147483386 )
        {
          v6 = *(WCHAR *)((char *)v5 + (char *)v10 - (char *)v11);
          if ( !v6 )
            break;
          *v5++ = v6;
          if ( !--v4 )
          {
            --v5;
            break;
          }
        }
        *v5 = 0;
        PathRemoveFileSpecW(v11);
        pv[0] = 0i64;
        v7 = sub_14007F810((__int64)v11, (__int64)pv);
        result = (HWND)(*(__int64 (__fastcall **)(__int64, void *, _QWORD, __int64, int, _DWORD))(*(_QWORD *)(a1 + 56)
                                                                                                + 80i64))(
                         a1 + 56,
                         pv[0],
                         0i64,
                         1i64,
                         1,
                         0);
        if ( v7 >= 0 )
        {
          CoTaskMemFree(pv[0]);
          PathStripPathW(v10);
          (*(void (__fastcall **)(_QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 232i64))(*(_QWORD *)(a1 + 2640), v10);
          return SetFocus(*(HWND *)(a1 + 4800));
        }
      }
    }
  }
  return result;
}
// 1400B0E97: conditional instruction was optimized away because rdx.8!=0
// 1400B0D80: using guessed type LPVOID pv[2];

//----- (00000001400B0F60) ----------------------------------------------------
void __fastcall sub_1400B0F60(__int64 a1, __int64 a2)
{
  void *pv[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( a2 )
  {
    pv[0] = 0i64;
    if ( (int)sub_14007F810(a2, (__int64)pv) >= 0 )
    {
      (*(void (__fastcall **)(__int64, void *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 64i64))(
        a1 + 56,
        pv[0],
        0i64,
        0i64);
      CoTaskMemFree(pv[0]);
    }
  }
}
// 1400B0F60: using guessed type LPVOID pv[3];

//----- (00000001400B0FC0) ----------------------------------------------------
void __fastcall sub_1400B0FC0(__int64 a1)
{
  unsigned int v2; // eax
  int v3; // ebx
  void *pv[2]; // [rsp+30h] [rbp-238h] BYREF
  WCHAR pszPath[264]; // [rsp+40h] [rbp-228h] BYREF

  v2 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 3i64);
  if ( v2 == -1
    || ((*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
          *(_QWORD *)(a1 + 2640),
          v2,
          pszPath),
        !PathIsDirectoryW(pszPath)) )
  {
    if ( (int)sub_1400B0C20(a1, a1 + 5960, 0, 1u, 1) < 0 )
      sub_1400B0C20(a1, a1 + 5440, 0, 1u, 1);
  }
  else
  {
    pv[0] = 0i64;
    v3 = sub_14007F810((__int64)pszPath, (__int64)pv);
    (*(void (__fastcall **)(__int64, void *, _QWORD, __int64, int, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
      a1 + 56,
      pv[0],
      0i64,
      1i64,
      1,
      0);
    if ( v3 >= 0 )
      CoTaskMemFree(pv[0]);
  }
}
// 1400B0FC0: using guessed type LPVOID pv[2];

//----- (00000001400B10F0) ----------------------------------------------------
void sub_1400B10F0()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v3; // rax
  void *v4; // rbx
  char *v5; // rax
  __int64 **v6; // rax
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx
  char *v9; // [rsp+20h] [rbp-498h] BYREF
  __int64 *v10[4]; // [rsp+28h] [rbp-490h] BYREF
  int v11; // [rsp+48h] [rbp-470h]
  _QWORD **v12; // [rsp+50h] [rbp-468h] BYREF
  __int64 v13; // [rsp+58h] [rbp-460h]
  __int64 pExceptionObject[5]; // [rsp+68h] [rbp-450h] BYREF
  char v15[528]; // [rsp+90h] [rbp-428h] BYREF
  WCHAR Buffer[256]; // [rsp+2A0h] [rbp-218h] BYREF

  pExceptionObject[3] = -2i64;
  v13 = 0i64;
  v0 = operator new(0x38ui64);
  v1 = v0;
  if ( !v0 )
  {
    v9 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v9);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v12 = (_QWORD **)v0;
  *v0 = v0;
  v0[1] = v0;
  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  v4 = v3;
  if ( v3 )
  {
    GetModuleFileNameExW(v3, 0i64, v15, 260i64);
    CloseHandle(v4);
  }
  LoadStringW(hInstance, 0x84Cu, Buffer, 256);
  v10[0] = (__int64 *)Buffer;
  v10[1] = (__int64 *)v15;
  v10[2] = (__int64 *)L"-open_new_tab";
  v10[3] = (__int64 *)v15;
  v11 = 1;
  v5 = sub_14001C600((__int64)v1, v1[1], v10);
  v13 = 1i64;
  v1[1] = v5;
  **((_QWORD **)v5 + 1) = v5;
  v6 = sub_140017FB0(v10, &v12);
  sub_14007F920(v6);
  v7 = (_QWORD *)*v1;
  *v1 = v1;
  v1[1] = v1;
  if ( v7 != v1 )
  {
    do
    {
      v8 = (_QWORD *)*v7;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != v1 );
  }
  j_free(v1);
}
// 14007F920: using guessed type __int64 __fastcall sub_14007F920(_QWORD);
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F39A8: using guessed type wchar_t aOpenNewTab_0[14];

//----- (00000001400B12B0) ----------------------------------------------------
__int64 __fastcall sub_1400B12B0(__int64 a1)
{
  int v2; // ebx
  void *pv[2]; // [rsp+30h] [rbp-238h] BYREF
  WCHAR pszPath[264]; // [rsp+40h] [rbp-228h] BYREF

  (*(void (__fastcall **)(_QWORD, __int64, WCHAR *))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    pszPath);
  PathStripPathW(pszPath);
  pv[0] = 0i64;
  v2 = sub_14007F810((__int64)&unk_1400EC10C, (__int64)pv);
  (*(void (__fastcall **)(__int64, void *, __int64, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    pv[0],
    8193i64,
    0i64,
    0,
    0);
  if ( v2 >= 0 )
    CoTaskMemFree(pv[0]);
  return (*(__int64 (__fastcall **)(_QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 232i64))(
           *(_QWORD *)(a1 + 2640),
           pszPath);
}
// 1400B12B0: using guessed type LPVOID pv[2];

//----- (00000001400B1390) ----------------------------------------------------
void __fastcall sub_1400B1390(__int64 a1)
{
  bool v2; // zf
  __int64 v3; // rcx
  LPVOID v4; // rdx
  int v5; // edi
  int v6; // eax
  int v7; // esi
  LPVOID v8; // rdx
  int v9; // eax
  LPVOID pv[5]; // [rsp+30h] [rbp-28h] BYREF

  v2 = a1 == -5960;
  v3 = a1 + 5960;
  v4 = 0i64;
  v5 = -2147467259;
  pv[0] = 0i64;
  if ( v2 )
  {
    v7 = -2147467259;
  }
  else
  {
    v6 = sub_14007F810(v3, (__int64)pv);
    v4 = pv[0];
    v7 = v6;
  }
  (*(void (__fastcall **)(__int64, LPVOID, _QWORD, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    v4,
    0i64,
    0i64,
    0,
    0);
  if ( v7 >= 0 )
    goto LABEL_8;
  v8 = 0i64;
  pv[0] = 0i64;
  if ( a1 != -5440 )
  {
    v9 = sub_14007F810(a1 + 5440, (__int64)pv);
    v8 = pv[0];
    v5 = v9;
  }
  (*(void (__fastcall **)(__int64, LPVOID, _QWORD, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    v8,
    0i64,
    0i64,
    0,
    0);
  if ( v5 >= 0 )
LABEL_8:
    CoTaskMemFree(pv[0]);
}

//----- (00000001400B1460) ----------------------------------------------------
void __fastcall sub_1400B1460(__int64 a1)
{
  int v2; // edi
  void *pv[3]; // [rsp+30h] [rbp-18h] BYREF

  pv[0] = 0i64;
  v2 = sub_14007F810((__int64)&unk_1400EC044, (__int64)pv);
  (*(void (__fastcall **)(__int64, void *, __int64, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    pv[0],
    32769i64,
    0i64,
    0,
    0);
  if ( v2 >= 0 )
    CoTaskMemFree(pv[0]);
}
// 1400B1460: using guessed type LPVOID pv[3];

//----- (00000001400B14E0) ----------------------------------------------------
void __fastcall sub_1400B14E0(__int64 a1)
{
  int v2; // edi
  void *pv[3]; // [rsp+30h] [rbp-18h] BYREF

  pv[0] = 0i64;
  v2 = sub_14007F810((__int64)&unk_1400EC034, (__int64)pv);
  (*(void (__fastcall **)(__int64, void *, __int64, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    pv[0],
    16385i64,
    0i64,
    0,
    0);
  if ( v2 >= 0 )
    CoTaskMemFree(pv[0]);
}
// 1400B14E0: using guessed type LPVOID pv[3];

//----- (00000001400B1560) ----------------------------------------------------
_QWORD *__fastcall sub_1400B1560(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // rsi
  __int64 v4; // rbx

  if ( *(_DWORD *)(a1 + 60744) )
    dword_14011FC14 |= 0x10000000u;
  *(_QWORD *)(a1 + 112) = sub_14007CDD0(*(HWND *)(a1 + 104));
  result = operator new(0x38ui64);
  v3 = result;
  if ( result )
  {
    v4 = *(_QWORD *)(a1 + 112);
    result = sub_14000A5B0(result + 3);
    *v3 = v4;
    *((_BYTE *)v3 + 48) = 0;
    *((_DWORD *)v3 + 2) = 0;
    *(_QWORD *)(a1 + 4768) = v3;
  }
  else
  {
    *(_QWORD *)(a1 + 4768) = 0i64;
  }
  return result;
}

//----- (00000001400B1600) ----------------------------------------------------
__int64 __fastcall sub_1400B1600(__int64 a1, int a2)
{
  __int64 v4; // rcx
  __int64 **v5; // r11
  __int64 *v6; // rdx
  __int64 *i; // rax
  __int64 v8; // rcx
  int v10; // [rsp+38h] [rbp+10h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v4 + 48i64))(v4, &v10);
  v5 = *(__int64 ***)(a1 + 7072);
  v6 = *v5;
  for ( i = *v5; i != (__int64 *)v5; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 4) == v10 )
      break;
  }
  if ( a2 )
  {
    if ( i != v5[1] )
      v6 = (__int64 *)*i;
  }
  else if ( i == v6 )
  {
    v6 = v5[1];
  }
  else
  {
    v6 = (__int64 *)i[1];
  }
  v8 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v8 + 40i64))(v8, *((unsigned int *)v6 + 4));
}

//----- (00000001400B16A0) ----------------------------------------------------
__int64 __fastcall sub_1400B16A0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 **v3; // r11
  __int64 *v4; // rdx
  __int64 *i; // rax
  __int64 v6; // rcx
  int v8; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v2 + 48i64))(v2, &v8);
  v3 = *(__int64 ***)(a1 + 7072);
  v4 = *v3;
  for ( i = *v3; i != (__int64 *)v3; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 4) == v8 )
      break;
  }
  if ( i != v3[1] )
    v4 = (__int64 *)*i;
  v6 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 40i64))(v6, *((unsigned int *)v4 + 4));
}

//----- (00000001400B1720) ----------------------------------------------------
void __fastcall sub_1400B1720(__int64 a1, __int64 a2)
{
  if ( a2 == 13 )
    sub_1400D6690(a1);
}

//----- (00000001400B1740) ----------------------------------------------------
void __fastcall sub_1400B1740(__int64 a1)
{
  HMODULE v2; // rax
  FARPROC ProcAddress; // rbp
  WPARAM v4; // rsi
  __int64 v5; // rax
  int v6; // eax
  HKEY v7; // rbx
  int v8; // eax
  HKEY v9; // rbx
  int v10; // eax
  int v11; // eax
  __int64 v12; // rbx
  HWND v13; // rcx
  __int64 v14; // rcx
  DWORD cbData; // [rsp+30h] [rbp-D8h] BYREF
  HKEY hKey; // [rsp+38h] [rbp-D0h] BYREF
  DWORD Type; // [rsp+40h] [rbp-C8h] BYREF
  __int64 lParam[4]; // [rsp+48h] [rbp-C0h] BYREF
  int v19; // [rsp+68h] [rbp-A0h]
  __int16 Data[32]; // [rsp+70h] [rbp-98h] BYREF
  WCHAR String[32]; // [rsp+B0h] [rbp-58h] BYREF

  v2 = sub_14000AF70(L"shell32.dll");
  ProcAddress = GetProcAddress(v2, (LPCSTR)0x294);
  v4 = 0i64;
  if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Control Panel\\Desktop\\WindowMetrics", 0, 0x2001Fu, &hKey) )
  {
    cbData = 32;
    RegQueryValueExW(hKey, L"Shell Icon Size", 0i64, &Type, (LPBYTE)Data, &cbData);
    if ( cbData && Type == 1 )
    {
      if ( Data[cbData - 1] )
      {
        v5 = 32i64;
        if ( cbData < 0x20 )
          v5 = cbData;
        Data[v5] = 0;
      }
    }
    else
    {
      Data[0] = 0;
    }
    v6 = sub_14004B61C(Data);
    sub_140001000(String, 0x20ui64, L"%d", (unsigned int)(v6 + 1));
    v7 = hKey;
    v8 = lstrlenW(String);
    RegSetValueExW(v7, L"Shell Icon Size", 0, 1u, (const BYTE *)String, 2 * v8);
    if ( ProcAddress )
      ((void (__fastcall *)(__int64))ProcAddress)(1i64);
    v9 = hKey;
    v10 = lstrlenW((LPCWSTR)Data);
    RegSetValueExW(v9, L"Shell Icon Size", 0, 1u, (const BYTE *)Data, 2 * v10);
    if ( ProcAddress )
      ((void (__fastcall *)(_QWORD))ProcAddress)(0i64);
    RegCloseKey(hKey);
  }
  v11 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( v11 > 0 )
  {
    v12 = (unsigned int)v11;
    do
    {
      v13 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v13, 0x133Cu, v4, (LPARAM)lParam);
      v14 = *(_QWORD *)(a1 + 8i64 * v19 + 1832);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 664i64))(v14);
      ++v4;
      --v12;
    }
    while ( v12 );
  }
  sub_140021E80(*(_QWORD *)(a1 + 2656));
  sub_1400C4D10(a1);
  sub_1400D0130(a1);
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 1400F3BE8: using guessed type wchar_t aD_11[3];
// 1400B1740: using guessed type WCHAR Data[32];
// 1400B1740: using guessed type LPARAM lParam[4];

//----- (00000001400B19A0) ----------------------------------------------------
char *__fastcall sub_1400B19A0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_140123678 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_14012367C + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 2 );
  return result;
}

//----- (00000001400B1AA0) ----------------------------------------------------
char *__fastcall sub_1400B1AA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_140123738 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_14012373C + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 4 );
  return result;
}

//----- (00000001400B1BA0) ----------------------------------------------------
char *__fastcall sub_1400B1BA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_1401236F0 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_1401236F4 + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 6 );
  return result;
}

//----- (00000001400B1CA0) ----------------------------------------------------
char *__fastcall sub_1400B1CA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_140123690 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_140123694 + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 6 );
  return result;
}

//----- (00000001400B1DA0) ----------------------------------------------------
char *__fastcall sub_1400B1DA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_140123630 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_140123634 + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 6 );
  return result;
}

//----- (00000001400B1EA0) ----------------------------------------------------
char *__fastcall sub_1400B1EA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[10]; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = 0i64;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(_DWORD *)((char *)&unk_140123618 + v6);
    v11[1] = *(_DWORD *)((char *)&unk_14012361C + v6);
    v11[2] = *(_DWORD *)((char *)&unk_1401233B8 + v6);
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 12i64;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 2 );
  return result;
}

//----- (00000001400B1FA0) ----------------------------------------------------
char *__fastcall sub_1400B1FA0(__int64 a1)
{
  _QWORD *v1; // rax
  unsigned int v3; // esi
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  int *v6; // rbx
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  char *result; // rax
  __int64 v10; // rdx
  int v11[6]; // [rsp+20h] [rbp-18h] BYREF

  v1 = *(_QWORD **)a1;
  v3 = 0;
  v4 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8i64) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  if ( v4 != *(_QWORD **)a1 )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)a1 );
  }
  v6 = (int *)&unk_1401233B4;
  do
  {
    v7 = *(_QWORD **)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    v11[0] = *(v6 - 1);
    v11[1] = *v6;
    v11[2] = v6[1];
    result = sub_140017AD0((__int64)v7, v8, v11);
    v10 = *(_QWORD *)(a1 + 8);
    if ( v10 == 0x1555555555555554i64 )
      sub_14002B5F8("list<T> too long");
    ++v3;
    v6 += 3;
    *(_QWORD *)(a1 + 8) = v10 + 1;
    v7[1] = result;
    **((_QWORD **)result + 1) = result;
  }
  while ( v3 < 0x33 );
  return result;
}

//----- (00000001400B2090) ----------------------------------------------------
char *__fastcall sub_1400B2090(__int64 a1)
{
  sub_1400B1FA0(a1 + 62232);
  sub_1400B1EA0(a1 + 62280);
  sub_1400B1DA0(a1 + 62256);
  sub_1400B1CA0(a1 + 62304);
  sub_1400B1BA0(a1 + 62328);
  sub_1400B1AA0(a1 + 62352);
  return sub_1400B19A0(a1 + 62376);
}

//----- (00000001400B2260) ----------------------------------------------------
int __fastcall sub_1400B2260(__int64 a1)
{
  int v1; // er14
  DWORD CurrentProcessId; // eax
  HANDLE v4; // rax
  void *v5; // rbx
  unsigned __int16 v6; // bx
  DWORD FileVersionInfoSizeW; // eax
  DWORD v8; // esi
  void *v9; // rax
  void *v10; // rdi
  HINSTANCE ModuleHandleW; // rax
  DWORD v12; // eax
  HANDLE v13; // rax
  void *v14; // rbx
  __int64 v15; // r11
  WCHAR *v16; // rcx
  WCHAR v17; // ax
  HINSTANCE v18; // r15
  __int64 v19; // r8
  WCHAR *v20; // rdx
  WCHAR v21; // ax
  unsigned __int16 v22; // di
  DWORD v23; // eax
  DWORD v24; // er12
  void *v25; // rax
  void *v26; // rbx
  __int64 v27; // rdx
  WCHAR *v28; // rcx
  WCHAR v29; // ax
  DWORD v30; // eax
  DWORD v31; // er12
  void *v32; // rax
  void *v33; // rbx
  HMODULE v34; // rax
  UINT v35; // edx
  unsigned int puLen[2]; // [rsp+28h] [rbp-E0h] BYREF
  LPVOID lpBuffer; // [rsp+30h] [rbp-D8h] BYREF
  DWORD dwHandle; // [rsp+38h] [rbp-D0h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+48h] [rbp-C0h] BYREF
  WCHAR Buffer[256]; // [rsp+298h] [rbp+190h] BYREF
  WCHAR tstrFilename[264]; // [rsp+498h] [rbp+390h] BYREF
  WCHAR pszPath[264]; // [rsp+6A8h] [rbp+5A0h] BYREF
  WCHAR FileName[264]; // [rsp+8B8h] [rbp+7B0h] BYREF
  WCHAR pszMore[264]; // [rsp+AC8h] [rbp+9C0h] BYREF

  v1 = 0;
  if ( dword_14012DB90 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v4 = OpenProcess(0x410u, 0, CurrentProcessId);
    v5 = v4;
    if ( v4 )
    {
      GetModuleFileNameExW(v4, 0i64, pszPath, 260i64);
      CloseHandle(v5);
    }
    PathRemoveFileSpecW(pszPath);
    sub_140001000(pszMore, 0x104ui64, L"Explorer++%2s.dll", &unk_14012DA20);
    PathAppendW(pszPath, pszMore);
    lpBuffer = 0i64;
    v6 = 0;
    FileVersionInfoSizeW = GetFileVersionInfoSizeW(pszPath, &dwHandle);
    v8 = FileVersionInfoSizeW;
    if ( FileVersionInfoSizeW )
    {
      v9 = malloc(FileVersionInfoSizeW);
      v10 = v9;
      if ( v9 )
      {
        GetFileVersionInfoW(pszPath, 0, v8, v9);
        VerQueryValueW(v10, L"\\VarFileInfo\\Translation", &lpBuffer, puLen);
        if ( puLen[0] >= 4 )
          v6 = *(_WORD *)lpBuffer & 0x3FF;
        free(v10);
      }
    }
    *(_DWORD *)(a1 + 7000) = v6;
  }
  else if ( !*(_DWORD *)(a1 + 7036) )
  {
    *(_DWORD *)(a1 + 7000) = GetUserDefaultUILanguage() & 0x3FF;
  }
  if ( *(_DWORD *)(a1 + 7000) == 9 )
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    hInstance = ModuleHandleW;
    goto LABEL_68;
  }
  v12 = GetCurrentProcessId();
  v13 = OpenProcess(0x410u, 0, v12);
  v14 = v13;
  if ( v13 )
  {
    GetModuleFileNameExW(v13, 0i64, pszPath, 260i64);
    CloseHandle(v14);
  }
  PathRemoveFileSpecW(pszPath);
  v15 = 260i64;
  v16 = FileName;
  while ( v15 != -2147483386 )
  {
    v17 = *(v16 - 264);
    if ( !v17 )
      break;
    *v16++ = v17;
    if ( !--v15 )
    {
      --v16;
      break;
    }
  }
  *v16 = 0;
  PathAppendW(FileName, L"Explorer++??.dll");
  ModuleHandleW = (HINSTANCE)FindFirstFileW(FileName, &FindFileData);
  v18 = ModuleHandleW;
  if ( ModuleHandleW != (HINSTANCE)-1i64 )
  {
    v19 = 260i64;
    v20 = tstrFilename;
    while ( v19 != -2147483386 )
    {
      v21 = v20[264];
      if ( !v21 )
        break;
      *v20++ = v21;
      if ( !--v19 )
      {
        --v20;
        break;
      }
    }
    *v20 = 0;
    PathAppendW(tstrFilename, FindFileData.cFileName);
    lpBuffer = 0i64;
    v22 = 0;
    v23 = GetFileVersionInfoSizeW(tstrFilename, &dwHandle);
    v24 = v23;
    if ( v23 )
    {
      v25 = malloc(v23);
      v26 = v25;
      if ( v25 )
      {
        GetFileVersionInfoW(tstrFilename, 0, v24, v25);
        VerQueryValueW(v26, L"\\VarFileInfo\\Translation", &lpBuffer, puLen);
        if ( puLen[0] >= 4 )
          v22 = *(_WORD *)lpBuffer & 0x3FF;
        free(v26);
      }
    }
    if ( v22 != *(_DWORD *)(a1 + 7000) )
    {
      if ( !FindNextFileW(v18, &FindFileData) )
        goto LABEL_50;
      while ( 1 )
      {
        v27 = 260i64;
        v28 = tstrFilename;
        while ( v27 != -2147483386 )
        {
          v29 = v28[264];
          if ( !v29 )
            break;
          *v28++ = v29;
          if ( !--v27 )
          {
            --v28;
            break;
          }
        }
        *v28 = 0;
        PathAppendW(tstrFilename, FindFileData.cFileName);
        lpBuffer = 0i64;
        v22 = 0;
        v30 = GetFileVersionInfoSizeW(tstrFilename, &dwHandle);
        v31 = v30;
        if ( v30 )
        {
          v32 = malloc(v30);
          v33 = v32;
          if ( v32 )
          {
            GetFileVersionInfoW(tstrFilename, 0, v31, v32);
            VerQueryValueW(v33, L"\\VarFileInfo\\Translation", &lpBuffer, puLen);
            if ( puLen[0] >= 4 )
              v22 = *(_WORD *)lpBuffer & 0x3FF;
            free(v33);
          }
        }
        if ( v22 == *(_DWORD *)(a1 + 7000) )
          break;
        if ( !FindNextFileW(v18, &FindFileData) )
          goto LABEL_50;
      }
    }
    if ( sub_1400B50D0(tstrFilename) )
      hInstance = sub_14000AF70(tstrFilename);
    else
      v1 = 1;
LABEL_50:
    LODWORD(ModuleHandleW) = FindClose(v18);
    if ( v1 )
    {
      switch ( v22 )
      {
        case 4u:
          v34 = GetModuleHandleW(0i64);
          v35 = 232;
          break;
        case 5u:
          v34 = GetModuleHandleW(0i64);
          v35 = 233;
          break;
        case 6u:
          v34 = GetModuleHandleW(0i64);
          v35 = 234;
          break;
        case 7u:
          v34 = GetModuleHandleW(0i64);
          v35 = 237;
          break;
        case 0xAu:
          v34 = GetModuleHandleW(0i64);
          v35 = 245;
          break;
        case 0xCu:
          v34 = GetModuleHandleW(0i64);
          v35 = 236;
          break;
        case 0x10u:
          v34 = GetModuleHandleW(0i64);
          v35 = 238;
          break;
        case 0x11u:
          v34 = GetModuleHandleW(0i64);
          v35 = 239;
          break;
        case 0x12u:
          v34 = GetModuleHandleW(0i64);
          v35 = 240;
          break;
        case 0x13u:
          v34 = GetModuleHandleW(0i64);
          v35 = 235;
          break;
        case 0x14u:
          v34 = GetModuleHandleW(0i64);
          v35 = 241;
          break;
        case 0x16u:
          v34 = GetModuleHandleW(0i64);
          v35 = 242;
          break;
        case 0x18u:
          v34 = GetModuleHandleW(0i64);
          v35 = 243;
          break;
        case 0x19u:
          v34 = GetModuleHandleW(0i64);
          v35 = 244;
          break;
        default:
          v34 = GetModuleHandleW(0i64);
          v35 = 2162;
          break;
      }
      LoadStringW(v34, v35, Buffer, 256);
      LODWORD(ModuleHandleW) = MessageBoxW(0i64, Buffer, L"Explorer++", 0x30u);
    }
  }
LABEL_68:
  if ( !hInstance )
  {
    ModuleHandleW = GetModuleHandleW(0i64);
    *(_DWORD *)(a1 + 7000) = 9;
    hInstance = ModuleHandleW;
  }
  return (int)ModuleHandleW;
}
// 1400B248A: conditional instruction was optimized away because r11.8!=0
// 1400B2516: conditional instruction was optimized away because r8.8!=0
// 1400B2616: conditional instruction was optimized away because rdx.8!=0
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400F39F8: using guessed type wchar_t aExplorer2sDll[18];
// 14012DB90: using guessed type int dword_14012DB90;

//----- (00000001400B2930) ----------------------------------------------------
void __fastcall sub_1400B2930(__int64 a1, _QWORD *a2)
{
  int v4; // eax
  _DWORD *v5; // rdi
  _DWORD *v6; // rax
  int v7; // eax

  *(_DWORD *)(a1 + 7096) = 0;
  v4 = sub_1400B0390();
  *(_DWORD *)(a1 + 7096) = v4;
  if ( v4 )
  {
    v5 = operator new(0x38ui64);
    if ( v5 )
    {
      *(_QWORD *)v5 = &Explorerplusplus::CLoadSaveXML::`vftable';
      v5[2] = 1;
      *((_QWORD *)v5 + 2) = a1;
      v5[6] = 1;
      sub_140085620((__int64)v5);
    }
    else
    {
      v5 = 0i64;
    }
    *a2 = v5;
    *(_DWORD *)(a1 + 60816) = 1;
  }
  else
  {
    v6 = operator new(0x18ui64);
    if ( v6 )
    {
      *(_QWORD *)v6 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
      v6[2] = 1;
      *((_QWORD *)v6 + 2) = a1;
    }
    *a2 = v6;
  }
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 32i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 24i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 48i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 56i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 64i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 72i64))(*a2);
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 80i64))(*a2);
  if ( !*(_DWORD *)(a1 + 7044) )
    *(_DWORD *)(a1 + 7044) = 208;
  v7 = *(_DWORD *)(a1 + 7012);
  if ( v7 < 70 )
    v7 = 90;
  *(_DWORD *)(a1 + 7012) = v7;
  sub_1400B6860((_QWORD *)a1);
  sub_1400B6DB0(a1);
}
// 1400F6EB8: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';
// 1400F79C8: using guessed type void *Explorerplusplus::CLoadSaveXML::`vftable';

//----- (00000001400B2A70) ----------------------------------------------------
__int64 __fastcall sub_1400B2A70(__int64 a1)
{
  IDataObject *v2; // rcx
  void **v3; // rsi

  v2 = *(IDataObject **)(a1 + 62432);
  if ( v2 && !OleIsCurrentClipboard(v2) )
    OleFlushClipboard();
  QueueUserAPC((PAPCFUNC)CoUninitialize, *(HANDLE *)(a1 + 4776), 0i64);
  sub_14000A390(*(_QWORD *)(a1 + 61648));
  sub_14000A390(*(_QWORD *)(a1 + 61656));
  v3 = *(void ***)(a1 + 4768);
  if ( v3 )
  {
    sub_14000A630((__int64)(v3 + 3));
    j_free(v3[3]);
    j_free(v3);
  }
  ChangeClipboardChain(*(HWND *)(a1 + 104), *(HWND *)(a1 + 4816));
  PostQuitMessage(0);
  return 0i64;
}

//----- (00000001400B2B30) ----------------------------------------------------
__int64 __fastcall sub_1400B2B30(__int64 a1, __int64 a2)
{
  int v4; // er14
  __int64 v5; // rdi
  __int64 v6; // rbx
  int v7; // er11
  int v8; // er12
  int v9; // esi
  void **v10; // rcx
  int v11; // eax
  void *Src[3]; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v14; // [rsp+48h] [rbp-B8h]
  void *Block[2]; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v16; // [rsp+68h] [rbp-98h]
  unsigned __int64 v17; // [rsp+70h] [rbp-90h]
  int v18; // [rsp+80h] [rbp-80h]
  int v19; // [rsp+84h] [rbp-7Ch]
  WCHAR pszPath[264]; // [rsp+90h] [rbp-70h] BYREF

  if ( *(_QWORD *)a2 != *(_QWORD *)(a1 + 4800) )
    return 0i64;
  if ( *(_DWORD *)(a2 + 24) == 1 )
    return 32i64;
  if ( *(_DWORD *)(a2 + 24) != 65537 )
    return 32i64;
  v4 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 248i64))(
         *(_QWORD *)(a1 + 2640),
         *(unsigned int *)(a2 + 56));
  (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
    *(_QWORD *)(a1 + 2640),
    *(unsigned int *)(a2 + 56),
    pszPath);
  PathStripPathW(pszPath);
  v5 = *(_QWORD *)(a1 + 80);
  v6 = *(_QWORD *)(a1 + 72);
  if ( v6 == v5 )
    return 32i64;
  while ( 1 )
  {
    v14 = 7i64;
    Src[2] = 0i64;
    LOWORD(Src[0]) = 0;
    sub_140009610(Src, (_QWORD *)v6, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v17 = 7i64;
    v16 = 0i64;
    LOWORD(Block[0]) = 0;
    sub_140009610(Block, (_QWORD *)(v6 + 40), 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v7 = *(_DWORD *)(v6 + 80);
    v18 = v7;
    v19 = *(_DWORD *)(v6 + 84);
    v8 = 0;
    v9 = 0;
    if ( !v16 )
      goto LABEL_9;
    v10 = Block;
    if ( v17 >= 8 )
      v10 = (void **)Block[0];
    v11 = sub_140082100((LPCWSTR)v10, pszPath, 1);
    v7 = v18;
    if ( v11 == 1 )
LABEL_9:
      v8 = 1;
    if ( !v7 || (v7 & v4) != 0 )
      v9 = 1;
    if ( v8 && v9 )
      break;
    if ( v17 >= 8 )
      j_free(Block[0]);
    v17 = 7i64;
    v16 = 0i64;
    LOWORD(Block[0]) = 0;
    if ( v14 >= 8 )
      j_free(Src[0]);
    v6 += 88i64;
    if ( v6 == v5 )
      return 32i64;
  }
  *(_DWORD *)(a2 + 80) = v19;
  if ( v17 >= 8 )
    j_free(Block[0]);
  v17 = 7i64;
  v16 = 0i64;
  LOWORD(Block[0]) = 0;
  if ( v14 >= 8 )
    j_free(Src[0]);
  return 2i64;
}

//----- (00000001400B2D70) ----------------------------------------------------
LRESULT __fastcall sub_1400B2D70(__int64 a1)
{
  IDataObject *v2; // rcx
  LPARAM v3; // rsi
  _QWORD *v4; // rbp
  _QWORD *i; // rbx
  __int64 v6; // rcx
  LPARAM *v7; // rdx
  unsigned int v8; // eax
  __int64 v9; // rcx
  LPARAM v10; // rax
  LPARAM lParam[2]; // [rsp+28h] [rbp-60h] BYREF
  __int64 v13; // [rsp+38h] [rbp-50h]
  unsigned __int64 v14; // [rsp+40h] [rbp-48h]

  v2 = *(IDataObject **)(a1 + 62432);
  v3 = 0i64;
  if ( v2 && OleIsCurrentClipboard(v2) == 1 )
  {
    v4 = *(_QWORD **)(a1 + 63104);
    for ( i = (_QWORD *)*v4; i != v4; i = (_QWORD *)*i )
    {
      v14 = 7i64;
      v13 = 0i64;
      LOWORD(lParam[0]) = 0;
      sub_140009610(lParam, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v6 = *(int *)(a1 + 63128);
      if ( *(_DWORD *)(a1 + 4 * v6 + 60320) )
      {
        v7 = lParam;
        if ( v14 >= 8 )
          v7 = (LPARAM *)lParam[0];
        v8 = (*(__int64 (__fastcall **)(_QWORD, LPARAM *))(**(_QWORD **)(a1 + 8 * v6 + 1832) + 360i64))(
               *(_QWORD *)(a1 + 8 * v6 + 1832),
               v7);
        if ( v8 != -1 )
        {
          v9 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 63128) + 1832);
          (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + 368i64))(v9, v8);
        }
      }
      if ( v14 >= 8 )
        j_free((void *)lParam[0]);
    }
    sub_14000A630(a1 + 63104);
    v10 = *(_QWORD *)(a1 + 62440);
    if ( v10 )
    {
      LODWORD(lParam[0]) = 24;
      lParam[1] = v10;
      v13 = 0x400000000i64;
      SendMessageW(*(HWND *)(a1 + 152), 0x113Fu, 0i64, (LPARAM)lParam);
      *(_QWORD *)(a1 + 62440) = 0i64;
    }
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 62432) + 16i64))(*(_QWORD *)(a1 + 62432));
    *(_QWORD *)(a1 + 62432) = 0i64;
  }
  if ( !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640))
    && IsClipboardFormatAvailable(0xFu) )
  {
    v3 = 1i64;
  }
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD3ui64, v3);
  return SendMessageW(*(HWND *)(a1 + 4816), 0x308u, 0i64, 0i64);
}

//----- (00000001400B35A0) ----------------------------------------------------
int __fastcall sub_1400B35A0(__int64 a1)
{
  HANDLE FileW; // rax
  DWORD v3; // edi
  void *v4; // rbx
  DWORD NumberOfBytesWritten; // [rsp+40h] [rbp-C0h] BYREF
  struct tagOFNW v7; // [rsp+50h] [rbp-B0h] BYREF
  WCHAR FileName[264]; // [rsp+F0h] [rbp-10h] BYREF
  char v9[528]; // [rsp+300h] [rbp+200h] BYREF
  char Buffer[8192]; // [rsp+510h] [rbp+410h] BYREF

  memset(FileName, 0, 520);
  v7.hwndOwner = *(HWND *)(a1 + 104);
  v7.lStructSize = 152;
  v7.lpstrFilter = L"Text Document (*.txt)";
  v7.lpstrCustomFilter = 0i64;
  v7.lpstrFile = FileName;
  *(_QWORD *)&v7.nMaxCustFilter = 0i64;
  v7.lpstrInitialDir = (LPCWSTR)(a1 + 4920);
  v7.nMaxFile = 260;
  v7.lpstrFileTitle = 0i64;
  v7.nMaxFileTitle = 0;
  v7.lpstrTitle = 0i64;
  v7.lpstrDefExt = L"txt";
  v7.Flags = 8912898;
  v7.lCustData = 0i64;
  v7.lpfnHook = 0i64;
  v7.pvReserved = 0i64;
  *(_QWORD *)&v7.dwReserved = 0i64;
  LODWORD(FileW) = GetSaveFileNameW(&v7);
  if ( (_DWORD)FileW )
  {
    LODWORD(FileW) = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 1i64);
    if ( (_DWORD)FileW != -1 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(
        *(_QWORD *)(a1 + 2640),
        (unsigned int)FileW,
        v9);
      LODWORD(FileW) = sub_140083AD0(v9, Buffer);
      v3 = (unsigned int)FileW;
      if ( (_DWORD)FileW != -1 )
      {
        FileW = CreateFileW(FileName, 0x40000000u, 0, 0i64, 4u, 0, 0i64);
        v4 = FileW;
        if ( FileW != (HANDLE)-1i64 )
        {
          WriteFile(FileW, Buffer, v3, &NumberOfBytesWritten, 0i64);
          LODWORD(FileW) = CloseHandle(v4);
        }
      }
    }
  }
  return (int)FileW;
}
// 1400EC430: using guessed type wchar_t aTextDocumentTx[22];
// 1400EC488: using guessed type wchar_t aTxt[4];

//----- (00000001400B3750) ----------------------------------------------------
void __fastcall sub_1400B3750(__int64 a1, int a2)
{
  HWND v4; // rcx
  struct tagPOINT Point; // [rsp+30h] [rbp+8h] BYREF

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  v4 = *(HWND *)(a1 + 128);
  Point.x = (__int16)a2;
  Point.y = SHIWORD(a2);
  ClientToScreen(v4, &Point);
  sub_1400C0ED0(a1, &Point);
}

//----- (00000001400B37C0) ----------------------------------------------------
void __fastcall sub_1400B37C0(__int64 a1)
{
  HWND Focus; // rax
  HWND v3; // rcx
  int v4; // eax
  __int64 v5; // rcx
  _BOOL8 v6; // r8
  __int64 v7; // rax
  HWND v8; // rcx
  LPARAM v9; // rax
  HWND v10; // rcx
  LPARAM v11; // rdi
  HWND v12; // rcx
  struct tagPOINT Point; // [rsp+20h] [rbp-30h] BYREF
  int v14; // [rsp+28h] [rbp-28h] BYREF
  int v15; // [rsp+2Ch] [rbp-24h] BYREF
  int v16; // [rsp+30h] [rbp-20h] BYREF
  LPARAM lParam; // [rsp+38h] [rbp-18h] BYREF
  int v18; // [rsp+44h] [rbp-Ch]

  Focus = GetFocus();
  v3 = *(HWND *)(a1 + 4800);
  if ( Focus == v3 )
  {
    Point = 0i64;
    if ( (unsigned int)SendMessageW(v3, 0x1032u, 0i64, 0i64) )
    {
      v4 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 1i64);
      if ( v4 != -1 )
      {
        SendMessageW(*(HWND *)(a1 + 4800), 0x1010u, v4, (LPARAM)&lParam);
        ClientToScreen(*(HWND *)(a1 + 4800), (LPPOINT)&lParam);
        v5 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
        (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v5 + 48i64))(v5, &v16);
        v6 = v16 == 2 || v16 == 3 || v16 == 4;
        v7 = SendMessageW(*(HWND *)(a1 + 4800), 0x1002u, v6, 0i64);
        sub_1400182D0(v7, (__int64)&v15, (__int64)&v14);
        Point.x = lParam + v15 / 2;
        Point.y = HIDWORD(lParam) + v14 / 2;
      }
      sub_1400C0ED0(a1, &Point);
    }
    else
    {
      GetCursorPos(&Point);
      sub_1400C0ED0(a1, &Point);
    }
  }
  else
  {
    v8 = *(HWND *)(a1 + 152);
    if ( Focus == v8 )
    {
      v9 = SendMessageW(v8, 0x110Au, 9ui64, 0i64);
      v10 = *(HWND *)(a1 + 152);
      v11 = v9;
      lParam = v9;
      SendMessageW(v10, 0x1104u, 1ui64, (LPARAM)&lParam);
      v12 = *(HWND *)(a1 + 152);
      Point = (struct tagPOINT)lParam;
      ClientToScreen(v12, &Point);
      Point.y += (v18 - HIDWORD(lParam)) / 2;
      if ( v11 )
        sub_140093910(a1, v11, &Point);
    }
  }
}
// 140093910: using guessed type __int64 __fastcall sub_140093910(_QWORD, _QWORD, _QWORD);

//----- (00000001400B39C0) ----------------------------------------------------
void __fastcall sub_1400B39C0(__int64 a1, int a2)
{
  if ( a2 == *(_DWORD *)(a1 + 7048) )
  {
    sub_1400B82C0(a1);
    sub_1400B8250(a1);
  }
}

//----- (00000001400B39F0) ----------------------------------------------------
void __fastcall sub_1400B39F0(__int64 a1)
{
  HWND v2; // rdx
  _WORD *v3; // rbx
  __int64 v4; // rcx
  __int128 *v5; // rdi
  bool v6; // zf
  __int64 v7; // rcx
  _WORD *v8; // rdi
  struct tagOFNW v9; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v10; // [rsp+C8h] [rbp-40h]
  void *Block[2]; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v12; // [rsp+E0h] [rbp-28h]
  unsigned __int64 v13; // [rsp+E8h] [rbp-20h]
  void *Src[3]; // [rsp+F8h] [rbp-10h] BYREF
  unsigned __int64 v15; // [rsp+110h] [rbp+8h]
  __int128 v16[2]; // [rsp+128h] [rbp+20h] BYREF
  __int64 v17; // [rsp+148h] [rbp+40h]
  int v18; // [rsp+150h] [rbp+48h]
  char v19[476]; // [rsp+154h] [rbp+4Ch] BYREF

  v10 = -2i64;
  v16[0] = xmmword_1400F3AE8;
  v16[1] = xmmword_1400F3AF8;
  v17 = 0x780074002E0067i64;
  v18 = 116;
  memset(v19, 0, sizeof(v19));
  v2 = *(HWND *)(a1 + 104);
  v9.lStructSize = 152;
  v9.hwndOwner = v2;
  v9.lpstrFilter = L"Text Document (*.txt)";
  v9.lpstrCustomFilter = 0i64;
  *(_QWORD *)&v9.nMaxCustFilter = 0i64;
  v9.lpstrFile = (LPWSTR)v16;
  v9.nMaxFile = 260;
  v9.lpstrFileTitle = 0i64;
  v9.nMaxFileTitle = 0;
  v3 = (_WORD *)(a1 + 4920);
  v9.lpstrInitialDir = (LPCWSTR)(a1 + 4920);
  v9.lpstrTitle = 0i64;
  v9.Flags = 8912898;
  v9.lpstrDefExt = L"txt";
  v9.lCustData = 0i64;
  v9.lpfnHook = 0i64;
  v9.pvReserved = 0i64;
  *(_QWORD *)&v9.dwReserved = 0i64;
  if ( GetSaveFileNameW(&v9) )
  {
    v15 = 7i64;
    Src[2] = 0i64;
    LOWORD(Src[0]) = 0;
    v4 = -1i64;
    v5 = v16;
    do
    {
      if ( !v4 )
        break;
      v6 = *(_WORD *)v5 == 0;
      v5 = (__int128 *)((char *)v5 + 2);
      --v4;
    }
    while ( !v6 );
    sub_1400099E0(Src, v16, -v4 - 2);
    v13 = 7i64;
    v12 = 0i64;
    LOWORD(Block[0]) = 0;
    v7 = -1i64;
    v8 = v3;
    do
    {
      if ( !v7 )
        break;
      v6 = *v8++ == 0;
      --v7;
    }
    while ( !v6 );
    sub_1400099E0(Block, v3, -v7 - 2);
    sub_1400D3E30(Block, Src);
    if ( v13 >= 8 )
      j_free(Block[0]);
    v13 = 7i64;
    v12 = 0i64;
    LOWORD(Block[0]) = 0;
    if ( v15 >= 8 )
      j_free(Src[0]);
  }
}
// 1400D3E30: using guessed type __int64 __fastcall sub_1400D3E30(_QWORD, _QWORD);
// 1400EC430: using guessed type wchar_t aTextDocumentTx[22];
// 1400EC488: using guessed type wchar_t aTxt[4];
// 1400F3AE8: using guessed type __int128 xmmword_1400F3AE8;
// 1400F3AF8: using guessed type __int128 xmmword_1400F3AF8;

//----- (00000001400B3BC0) ----------------------------------------------------
void __fastcall sub_1400B3BC0(__int64 a1, int a2)
{
  HWND v4; // rcx
  _QWORD *v5; // rax
  _QWORD *v6; // rbx
  WCHAR *v7; // rbx
  LPARAM lParam; // [rsp+20h] [rbp-58h] BYREF
  int v9; // [rsp+2Ch] [rbp-4Ch]
  int v10; // [rsp+30h] [rbp-48h]

  (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    a1 + 4920);
  SetCurrentDirectoryW((LPCWSTR)(a1 + 4920));
  sub_1400B0710(a1, a2);
  sub_1400CCA00(a1);
  v4 = *(HWND *)(a1 + 4800);
  *(_DWORD *)(a1 + 62416) = 0;
  v10 = 1;
  v9 = 1;
  SendMessageW(v4, 0x102Bu, 0i64, (LPARAM)&lParam);
  sub_1400D1700(a1);
  if ( *(_QWORD *)(a1 + 60976) )
  {
    v5 = *(_QWORD **)(a1 + 61000);
    v6 = (_QWORD *)*v5;
    if ( (_QWORD *)*v5 != v5 )
    {
      do
      {
        if ( *((_DWORD *)v6 + 8) == a2 )
          (*(void (__fastcall **)(_QWORD))(a1 + 60976))(v6[3]);
        v6 = (_QWORD *)*v6;
      }
      while ( v6 != *(_QWORD **)(a1 + 61000) );
    }
  }
  v7 = (WCHAR *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  sub_1400D12A0(a1, *(_DWORD *)(a1 + 7060), *(_DWORD *)(a1 + 7048), v7);
  CoTaskMemFree(v7);
}

//----- (00000001400B3CD0) ----------------------------------------------------
void __fastcall sub_1400B3CD0(__int64 a1, unsigned __int64 a2)
{
  switch ( (a2 >> 16) & 0xFFF )
  {
    case 1ui64:
      SendMessageW(*(HWND *)(a1 + 104), 0x1Fu, 0i64, 0i64);
      sub_1400B14E0(a1);
      break;
    case 2ui64:
      SendMessageW(*(HWND *)(a1 + 104), 0x1Fu, 0i64, 0i64);
      sub_1400B1460(a1);
      break;
    case 3ui64:
      SendMessageW(*(HWND *)(a1 + 104), 0x1Fu, 0i64, 0i64);
      (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 32i64))(a1 + 56, *(unsigned int *)(a1 + 7048));
      break;
    case 0x1Fui64:
      SendMessageW(*(HWND *)(a1 + 104), 0x1Fu, 0i64, 0i64);
      sub_140095E30(a1);
      break;
    case 0x22ui64:
      sub_14007B1C0((__int64 *)(a1 + 61040));
      break;
    case 0x24ui64:
      sub_1400D1A20(a1, 1u);
      break;
    case 0x25ui64:
      sub_1400D1A20(a1, 0);
      break;
    case 0x26ui64:
      sub_1400D1840(a1);
      break;
    default:
      return;
  }
}

//----- (00000001400B3E30) ----------------------------------------------------
HWND __fastcall sub_1400B3E30(__int64 a1, int a2)
{
  HWND v2; // rdi
  HWND result; // rax
  int lParam[4]; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(HWND *)(a1 + 136);
  result = GetFocus();
  if ( result == v2 )
  {
    lParam[0] = (unsigned __int16)a2;
    lParam[1] = HIWORD(a2);
    result = (HWND)SendMessageW(v2, 0x130Du, 0i64, (LPARAM)lParam);
    if ( (_DWORD)result != -1 )
      return (HWND)sub_140095A90(a1, (int)result);
  }
  return result;
}
// 1400B3E30: using guessed type _DWORD lParam[4];

//----- (00000001400B3EC0) ----------------------------------------------------
__int64 __fastcall sub_1400B3EC0(__int64 a1, const ITEMIDLIST *a2, __int64 a3, int a4, int a5, int a6)
{
  DWORD CurrentProcessId; // eax
  HANDLE v9; // rax
  void *v10; // rbx
  int v12; // edi
  int v13; // edx
  int v14; // eax
  int v15[4]; // [rsp+30h] [rbp-8B8h] BYREF
  SHELLEXECUTEINFOW pExecInfo; // [rsp+40h] [rbp-8A8h] BYREF
  WCHAR pszBuf[264]; // [rsp+B0h] [rbp-838h] BYREF
  char v18[528]; // [rsp+2C0h] [rbp-628h] BYREF
  __int16 v19[512]; // [rsp+4D0h] [rbp-418h] BYREF

  v15[0] = -1;
  if ( a6 )
  {
    CurrentProcessId = GetCurrentProcessId();
    v9 = OpenProcess(0x410u, 0, CurrentProcessId);
    v10 = v9;
    if ( v9 )
    {
      GetModuleFileNameExW(v9, 0i64, v18, 260i64);
      CloseHandle(v10);
    }
    sub_14007E270(a2, pszBuf, 0x8000u);
    sub_140001000((wchar_t *)v19, 0x200ui64, L"\"%s\"", pszBuf);
    pExecInfo.lpVerb = L"open";
    *(_QWORD *)&pExecInfo.cbSize = 112i64;
    pExecInfo.lpFile = (LPCWSTR)v18;
    pExecInfo.lpDirectory = 0i64;
    pExecInfo.lpParameters = (LPCWSTR)v19;
    pExecInfo.nShow = 5;
    ShellExecuteExW(&pExecInfo);
    return 2147500037i64;
  }
  else
  {
    if ( a4 || *(_DWORD *)(532i64 * *(int *)(a1 + 6992) + a1 + 7068) )
    {
      if ( *(_DWORD *)(532i64 * *(int *)(a1 + 6992) + a1 + 7068) )
        v14 = sub_140096F90(a1 - 56, a2, 0i64, 0i64, 1, v15);
      else
        v14 = sub_140096F90(a1 - 56, a2, 0i64, 0i64, a5, v15);
      v13 = v15[0];
      v12 = v14;
    }
    else
    {
      v12 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2584) + 24i64))(*(_QWORD *)(a1 + 2584));
      if ( v12 >= 0 && *(_DWORD *)(a1 + 60856) )
        PlaySoundW((LPCWSTR)0xEB, 0i64, 0x40005u);
      v13 = *(_DWORD *)(a1 + 6992);
    }
    if ( v12 >= 0 )
      sub_1400B3BC0(a1 - 56, v13);
    return (unsigned int)v12;
  }
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400F3BB0: using guessed type wchar_t aS_3[5];
// 1400F3BC0: using guessed type wchar_t aOpen_6[5];
// 1400B3EC0: using guessed type wchar_t var_418[512];

//----- (00000001400B40A0) ----------------------------------------------------
__int64 __fastcall sub_1400B40A0(__int64 a1, const ITEMIDLIST *a2)
{
  __int64 v2; // rax
  int v4; // edi
  int v5; // edx
  int v6; // eax
  int v8; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(int *)(a1 + 7048);
  v8 = -1;
  if ( *(_DWORD *)(532 * v2 + a1 + 7124) )
  {
    v6 = sub_140096F90(a1, a2, 0i64, 0i64, 1, &v8);
    v5 = v8;
    v4 = v6;
  }
  else
  {
    v4 = (*(__int64 (__fastcall **)(_QWORD, const ITEMIDLIST *))(**(_QWORD **)(a1 + 2640) + 24i64))(
           *(_QWORD *)(a1 + 2640),
           a2);
    if ( v4 >= 0 && *(_DWORD *)(a1 + 60912) )
      PlaySoundW((LPCWSTR)0xEB, 0i64, 0x40005u);
    v5 = *(_DWORD *)(a1 + 7048);
  }
  if ( v4 >= 0 )
    sub_1400B3BC0(a1, v5);
  return (unsigned int)v4;
}

//----- (00000001400B4150) ----------------------------------------------------
void __fastcall sub_1400B4150(__int64 a1, __int64 a2)
{
  HWND v3; // rcx
  int v5; // eax
  int v6; // eax
  LPVOID pv; // [rsp+30h] [rbp-38h] BYREF
  int v8[2]; // [rsp+38h] [rbp-30h] BYREF
  struct tagRECT Rect; // [rsp+40h] [rbp-28h] BYREF

  v3 = *(HWND *)(a1 + 176);
  pv = 0i64;
  GetWindowRect(v3, &Rect);
  v8[0] = Rect.left;
  v8[1] = Rect.bottom - 4;
  v5 = *(_DWORD *)(a2 + 24);
  switch ( v5 )
  {
    case 45002:
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, LPVOID *, int *, int))(**(_QWORD **)(a1 + 2640) + 120i64))(
             *(_QWORD *)(a1 + 2640),
             *(_QWORD *)(a1 + 104),
             &pv,
             v8,
             1);
      goto LABEL_5;
    case 45003:
      SendMessageW(*(HWND *)(a1 + 176), 0x433u, 0xAFCAui64, (LPARAM)&Rect);
      v8[0] += Rect.right;
      v6 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, LPVOID *, int *, _DWORD))(**(_QWORD **)(a1 + 2640) + 120i64))(
             *(_QWORD *)(a1 + 2640),
             *(_QWORD *)(a1 + 104),
             &pv,
             v8,
             0);
LABEL_5:
      if ( v6 >= 0 )
      {
        sub_1400B40A0(a1, (const ITEMIDLIST *)pv);
        CoTaskMemFree(pv);
      }
      return;
    case 45013:
      sub_1400B0600(a1);
      break;
  }
}

//----- (00000001400B4260) ----------------------------------------------------
__int64 __fastcall sub_1400B4260(__int64 a1, const ITEMIDLIST *a2, int a3, int a4)
{
  if ( a4 || *(_DWORD *)(a1 + 60788) || a3 )
    return (*(__int64 (__fastcall **)(__int64, const ITEMIDLIST *, __int64))(*(_QWORD *)(a1 + 56) + 80i64))(
             a1 + 56,
             a2,
             1i64);
  else
    return sub_1400B40A0(a1, a2);
}

//----- (00000001400B42E0) ----------------------------------------------------
void __fastcall sub_1400B42E0(__int64 a1, const ITEMIDLIST *a2, int a3, int a4)
{
  int v8; // er12
  int v9; // ebx
  int v10; // eax
  __int64 v11; // rcx
  ITEMIDLIST *v12; // rdx
  const WCHAR *v13; // r8
  __int64 v14; // rbx
  int v15; // ebx
  void *v16; // rcx
  int v17; // eax
  int v18; // ebx
  DWORD CurrentProcessId; // eax
  HANDLE v20; // rax
  void *v21; // rbx
  void *ppv; // [rsp+30h] [rbp-D0h] BYREF
  int v23; // [rsp+38h] [rbp-C8h] BYREF
  LPITEMIDLIST ppidl; // [rsp+40h] [rbp-C0h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+48h] [rbp-B8h] BYREF
  SHFILEINFOW psfi; // [rsp+50h] [rbp-B0h] BYREF
  WCHAR Parameters[264]; // [rsp+310h] [rbp+210h] BYREF
  WCHAR pszPath[264]; // [rsp+520h] [rbp+420h] BYREF

  v23 = 541130752;
  ppidl = 0i64;
  v8 = 0;
  if ( SHGetFolderLocation(0i64, 3, 0i64, 0, &ppidl) >= 0 )
  {
    if ( ILIsParent(ppidl, a2, 0) && !(unsigned int)sub_14007DCB0((__int64)ppidl, (__int64)a2) )
      v8 = 1;
    CoTaskMemFree(ppidl);
  }
  if ( *(_DWORD *)(a1 + 6948) >= 6u
    && !v8
    && (int)sub_14007F810((__int64)L"::{26EE0668-A00A-44D7-9371-BEB064C98683}", (__int64)&ppidl) >= 0 )
  {
    if ( ILIsParent(ppidl, a2, 0) && !(unsigned int)sub_14007DCB0((__int64)ppidl, (__int64)a2) )
      v8 = 1;
    CoTaskMemFree(ppidl);
  }
  if ( a2 )
  {
    ppv = 0i64;
    ppidlLast = 0i64;
    if ( SHBindToParent(a2, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
    {
      v9 = (*(__int64 (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
             ppv,
             1i64,
             &ppidlLast,
             &v23);
      (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      if ( v9 >= 0 )
      {
        v10 = v23 & 0x20000000;
        if ( (v23 & 0x20000000) != 0 && (v23 & 0x400000) != 0 )
        {
          v11 = a1 - 56;
          v12 = (ITEMIDLIST *)a2;
          if ( *(_DWORD *)(a1 + 60808) )
          {
            sub_1400B4260(v11, a2, a3, a4);
            return;
          }
          v13 = (const WCHAR *)&unk_1400EBEF4;
          goto LABEL_51;
        }
        if ( v10 && !v8 )
        {
          sub_1400B4260(a1 - 56, a2, a3, a4);
          return;
        }
        if ( (v23 & 0x10000) != 0 )
        {
          if ( !v8 )
          {
            sub_14007E270(a2, pszPath, 0x8000u);
            v14 = *(_QWORD *)(a1 + 48);
            if ( SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x800u) )
            {
              v15 = sub_1400D2C10(v14, 0, (__int64)pszPath, Parameters, (__int64)&psfi);
              if ( v15 )
                goto LABEL_40;
              v23 = 541065216;
              ppv = 0i64;
              if ( (int)sub_14007F810((__int64)Parameters, (__int64)&ppv) >= 0 )
              {
                v16 = ppv;
                if ( ppv )
                {
                  v17 = sub_14007E1F0((const ITEMIDLIST *)ppv, (__int64)&v23);
                  v16 = ppv;
                  v18 = v17;
                }
                else
                {
                  v18 = -2147467259;
                }
                CoTaskMemFree(v16);
                if ( v18 >= 0
                  && ((v23 & 0x20000000) != 0 && (v23 & 0x400000) == 0
                   || (v23 & 0x20000000) != 0 && (v23 & 0x400000) != 0 && *(_DWORD *)(a1 + 60808)) )
                {
                  ppv = 0i64;
                  v15 = sub_14007F810((__int64)Parameters, (__int64)&ppv);
                  if ( v15 >= 0 )
                  {
                    sub_1400B4260(a1 - 56, (const ITEMIDLIST *)ppv, a3, a4);
                    CoTaskMemFree(ppv);
LABEL_40:
                    if ( v15 >= 0 )
                      return;
                  }
                }
              }
            }
            v13 = (const WCHAR *)&unk_1400EBF04;
LABEL_50:
            v12 = (ITEMIDLIST *)a2;
            v11 = a1 - 56;
LABEL_51:
            sub_1400B00D0(v11, v12, v13);
            return;
          }
        }
        else if ( !v8 )
        {
          goto LABEL_49;
        }
        if ( v10 )
        {
          sub_14007E270(a2, Parameters, 0x8000u);
          CurrentProcessId = GetCurrentProcessId();
          v20 = OpenProcess(0x400u, 0, CurrentProcessId);
          v21 = v20;
          if ( v20 )
          {
            if ( OpenProcessToken(v20, 0xCu, (PHANDLE)&ppidlLast) )
            {
              ExpandEnvironmentStringsForUserW((HANDLE)ppidlLast, L"%windir%\\explorer.exe", pszPath, 0x104u);
              CloseHandle((HANDLE)ppidlLast);
            }
            CloseHandle(v21);
          }
          ShellExecuteW(*(HWND *)(a1 + 48), L"open", pszPath, Parameters, 0i64, 1);
          return;
        }
LABEL_49:
        v13 = (const WCHAR *)&unk_1400EBF14;
        goto LABEL_50;
      }
    }
  }
}
// 1400F3A80: using guessed type wchar_t a26ee0668A00a44_0[41];

//----- (00000001400B46F0) ----------------------------------------------------
void __fastcall sub_1400B46F0(__int64 a1, int a2)
{
  LPITEMIDLIST ppidl; // [rsp+50h] [rbp+18h] BYREF

  ppidl = 0i64;
  if ( !SHGetFolderLocation(0i64, a2, 0i64, 0, &ppidl) )
  {
    sub_1400B40A0(a1, ppidl);
    CoTaskMemFree(ppidl);
  }
}

//----- (00000001400B4750) ----------------------------------------------------
HWND __fastcall sub_1400B4750(LPDROPTARGET pDropTarget)
{
  __int64 v2; // rcx
  struct IDropTargetVtbl *Thread; // rax
  struct IDropTargetVtbl *v4; // rax
  struct IDropTargetVtbl *v5; // rax
  HMENU MenuW; // rax
  HMENU v7; // rax
  HMENU v8; // rax
  HMENU v9; // rax
  HMENU v10; // rax
  HMENU Menu; // rax
  HMENU v12; // rax
  HMENU v13; // rax
  HMENU v14; // rax
  HMENU v15; // rax
  HMENU v16; // rax
  HMENU v17; // rax
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  HMODULE v20; // rax
  HBITMAP v21; // rbx
  void *v22; // rax
  struct IDropTargetVtbl *v23; // rax
  __int64 v24; // rbx
  HMENU v25; // rax
  __int64 v27; // [rsp+30h] [rbp-48h] BYREF
  SHChangeNotifyEntry pshcne; // [rsp+38h] [rbp-40h] BYREF
  __int64 v29; // [rsp+48h] [rbp-30h]
  struct tagRECT Rect; // [rsp+50h] [rbp-28h] BYREF

  v29 = -2i64;
  v27 = 0i64;
  HIDWORD(pDropTarget[7628].lpVtbl) = 0;
  LODWORD(pDropTarget[7628].lpVtbl) = RegisterWindowMessageW(L"TaskbarButtonCreated");
  sub_1400B2930((__int64)pDropTarget, &v27);
  sub_1400B5E90(pDropTarget);
  sub_1400B2260(v2);
  Thread = (struct IDropTargetVtbl *)CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400B04D0, 0i64, 0, 0i64);
  pDropTarget[597].lpVtbl = Thread;
  SetThreadPriority(Thread, -1);
  QueueUserAPC((PAPCFUNC)sub_1400B04B0, pDropTarget[597].lpVtbl, 0i64);
  v4 = (struct IDropTargetVtbl *)CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400B04D0, 0i64, 0, 0i64);
  pDropTarget[598].lpVtbl = v4;
  SetThreadPriority(v4, -1);
  QueueUserAPC((PAPCFUNC)sub_1400B04B0, pDropTarget[598].lpVtbl, 0i64);
  v5 = (struct IDropTargetVtbl *)CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400B04D0, 0i64, 0, 0i64);
  pDropTarget[599].lpVtbl = v5;
  SetThreadPriority(v5, -1);
  QueueUserAPC((PAPCFUNC)sub_1400B04B0, pDropTarget[599].lpVtbl, 0i64);
  MenuW = LoadMenuW(hInstance, (LPCWSTR)0x97);
  SetMenu((HWND)pDropTarget[13].lpVtbl, MenuW);
  v7 = LoadMenuW(hInstance, (LPCWSTR)0x9C);
  pDropTarget[604].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v7, 0);
  v8 = LoadMenuW(hInstance, (LPCWSTR)0x9C);
  pDropTarget[606].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v8, 0);
  v9 = LoadMenuW(hInstance, (LPCWSTR)0xE1);
  pDropTarget[605].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v9, 0);
  v10 = LoadMenuW(hInstance, (LPCWSTR)0xE1);
  pDropTarget[607].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v10, 0);
  Menu = GetMenu((HWND)pDropTarget[13].lpVtbl);
  pDropTarget[608].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(Menu, 6);
  v12 = LoadMenuW(hInstance, (LPCWSTR)0xA4);
  pDropTarget[609].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v12, 0);
  v13 = LoadMenuW(hInstance, (LPCWSTR)0xC4);
  pDropTarget[610].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v13, 0);
  v14 = LoadMenuW(hInstance, (LPCWSTR)0xD2);
  pDropTarget[611].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v14, 0);
  v15 = LoadMenuW(hInstance, (LPCWSTR)0xD9);
  pDropTarget[612].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v15, 0);
  v16 = LoadMenuW(hInstance, (LPCWSTR)0xDB);
  pDropTarget[613].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v16, 0);
  v17 = LoadMenuW(hInstance, (LPCWSTR)0xC3);
  pDropTarget[614].lpVtbl = (struct IDropTargetVtbl *)GetSubMenu(v17, 0);
  pDropTarget[7706].lpVtbl = (struct IDropTargetVtbl *)sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 47);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0((__int64)pDropTarget[7706].lpVtbl, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  pDropTarget[7707].lpVtbl = (struct IDropTargetVtbl *)sub_1400016D0(0x18u, 0x18u, 0x21u, 0, 47);
  v20 = GetModuleHandleW(0i64);
  v21 = LoadBitmapW(v20, (LPCWSTR)0xED);
  sub_1400012C0((__int64)pDropTarget[7707].lpVtbl, (__int64)v21, 0i64);
  DeleteObject(v21);
  v22 = operator new(0x68ui64);
  *(_QWORD *)&Rect.left = v22;
  if ( v22 )
    v23 = (struct IDropTargetVtbl *)sub_1400755C0((__int64)v22);
  else
    v23 = 0i64;
  pDropTarget[331].lpVtbl = v23;
  sub_1400B1560((__int64)pDropTarget);
  sub_140091470((__int64)pDropTarget);
  sub_1400D5C30((__int64)pDropTarget);
  sub_140097650(pDropTarget);
  sub_140091790((__int64)pDropTarget);
  GetClientRect((HWND)pDropTarget[13].lpVtbl, &Rect);
  SendMessageW(
    (HWND)pDropTarget[13].lpVtbl,
    5u,
    0i64,
    LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16));
  HIDWORD(pDropTarget[332].lpVtbl[10].Release) = HIDWORD(pDropTarget[7617].lpVtbl);
  if ( HIDWORD(pDropTarget[875].lpVtbl) != 6 || !LODWORD(pDropTarget[876].lpVtbl) )
    HIDWORD(pDropTarget[7611].lpVtbl) = 0;
  LODWORD(pDropTarget[7612].lpVtbl) = HIDWORD(pDropTarget[7611].lpVtbl);
  v24 = v27;
  sub_1400B85E0((__int64)pDropTarget, v27);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 16i64))(v24);
  pshcne.fRecursive = 1;
  pshcne.pidl = 0i64;
  SHChangeNotifyRegister((HWND)pDropTarget[13].lpVtbl, 2, 0x8000000, 0x8036u, 1, &pshcne);
  sub_1400D5030((__int64)pDropTarget);
  v25 = GetMenu((HWND)pDropTarget[13].lpVtbl);
  GetSubMenu(v25, 6);
  memset(&pDropTarget[7708], 0, 0x190ui64);
  sub_1400CB360((__int64)pDropTarget);
  sub_1400CB930((__int64)pDropTarget);
  sub_1400CC320((__int64)pDropTarget);
  pDropTarget[602].lpVtbl = (struct IDropTargetVtbl *)SetClipboardViewer((HWND)pDropTarget[13].lpVtbl);
  return SetFocus((HWND)pDropTarget[600].lpVtbl);
}
// 1400B47AF: variable 'v2' is possibly undefined

//----- (00000001400B4C70) ----------------------------------------------------
__int64 __fastcall sub_1400B4C70(__int64 a1)
{
  return *(_QWORD *)(a1 + 4712);
}

//----- (00000001400B4C80) ----------------------------------------------------
__int64 __fastcall sub_1400B4C80(__int64 a1, int a2)
{
  __int64 result; // rax

  switch ( a2 )
  {
    case 1:
      result = 2000i64;
      break;
    case 2:
    case 32:
      result = 2001i64;
      break;
    case 3:
      result = 2002i64;
      break;
    case 4:
      result = 2003i64;
      break;
    case 5:
      result = 2004i64;
      break;
    case 6:
      result = 2005i64;
      break;
    case 7:
      result = 2006i64;
      break;
    case 8:
      result = 2007i64;
      break;
    case 9:
      result = 2008i64;
      break;
    case 10:
      result = 2009i64;
      break;
    case 11:
      result = 2010i64;
      break;
    case 12:
      result = 2011i64;
      break;
    case 13:
      result = 2012i64;
      break;
    case 14:
      result = 2013i64;
      break;
    case 15:
      result = 2014i64;
      break;
    case 16:
      result = 2015i64;
      break;
    case 17:
      result = 2016i64;
      break;
    case 18:
      result = 2017i64;
      break;
    case 19:
      result = 2018i64;
      break;
    case 20:
      result = 2019i64;
      break;
    case 21:
      result = 2020i64;
      break;
    case 22:
      result = 2021i64;
      break;
    case 23:
    case 28:
      result = 2022i64;
      break;
    case 24:
      result = 2023i64;
      break;
    case 25:
      result = 2024i64;
      break;
    case 26:
      result = 2025i64;
      break;
    case 27:
      result = 2026i64;
      break;
    case 29:
      result = 2027i64;
      break;
    case 30:
      result = 2028i64;
      break;
    case 31:
      result = 2029i64;
      break;
    case 35:
      result = 2030i64;
      break;
    case 37:
      result = 2031i64;
      break;
    case 38:
      result = 2032i64;
      break;
    case 39:
      result = 2033i64;
      break;
    case 40:
      result = 2092i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001400B4E20) ----------------------------------------------------
__int64 __fastcall sub_1400B4E20(__int64 a1, int a2)
{
  __int64 result; // rax

  switch ( a2 )
  {
    case 1:
      result = 2049i64;
      break;
    case 2:
      result = 2050i64;
      break;
    case 3:
      result = 2051i64;
      break;
    case 4:
      result = 2052i64;
      break;
    case 5:
      result = 2053i64;
      break;
    case 6:
      result = 2054i64;
      break;
    case 7:
      result = 2055i64;
      break;
    case 8:
      result = 2056i64;
      break;
    case 9:
      result = 2057i64;
      break;
    case 10:
      result = 2058i64;
      break;
    case 11:
      result = 2059i64;
      break;
    case 12:
      result = 2060i64;
      break;
    case 13:
      result = 2061i64;
      break;
    case 14:
      result = 2062i64;
      break;
    case 15:
      result = 2063i64;
      break;
    case 16:
      result = 2064i64;
      break;
    case 17:
      result = 2065i64;
      break;
    case 18:
      result = 2066i64;
      break;
    case 19:
      result = 2067i64;
      break;
    case 20:
      result = 2068i64;
      break;
    case 21:
      result = 2069i64;
      break;
    case 22:
      result = 2070i64;
      break;
    case 23:
      result = 2071i64;
      break;
    case 24:
      result = 2072i64;
      break;
    case 25:
      result = 2073i64;
      break;
    case 26:
      result = 2074i64;
      break;
    case 27:
      result = 2075i64;
      break;
    case 28:
      result = 2076i64;
      break;
    case 29:
      result = 2077i64;
      break;
    case 30:
      result = 2078i64;
      break;
    case 31:
      result = 2079i64;
      break;
    case 32:
      result = 2080i64;
      break;
    case 33:
      result = 2081i64;
      break;
    case 34:
      result = 2082i64;
      break;
    case 35:
      result = 2083i64;
      break;
    case 36:
      result = 2084i64;
      break;
    case 37:
      result = 2085i64;
      break;
    case 38:
      result = 2086i64;
      break;
    case 39:
      result = 2087i64;
      break;
    case 40:
      result = 2093i64;
      break;
    case 41:
      result = 2094i64;
      break;
    case 42:
      result = 2095i64;
      break;
    case 43:
      result = 2096i64;
      break;
    case 44:
      result = 2097i64;
      break;
    case 45:
      result = 2098i64;
      break;
    case 46:
      result = 2099i64;
      break;
    case 47:
      result = 2100i64;
      break;
    case 48:
      result = 2101i64;
      break;
    case 49:
      result = 2102i64;
      break;
    case 50:
      result = 2103i64;
      break;
    case 51:
      result = 2104i64;
      break;
    case 52:
      result = 2105i64;
      break;
    case 53:
      result = 2106i64;
      break;
    case 54:
      result = 2107i64;
      break;
    case 55:
      result = 2108i64;
      break;
    case 56:
      result = 2109i64;
      break;
    case 57:
      result = 2110i64;
      break;
    case 58:
      result = 2111i64;
      break;
    case 59:
      result = 2112i64;
      break;
    case 60:
      result = 2113i64;
      break;
    case 61:
      result = 2114i64;
      break;
    case 62:
      result = 2115i64;
      break;
    case 63:
      result = 2116i64;
      break;
    case 64:
      result = 2117i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001400B50D0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B50D0(LPCWSTR lptstrFilename)
{
  DWORD CurrentProcessId; // eax
  HANDLE v3; // rax
  void *v4; // rdi
  int ModuleFileName; // ebx
  int v6; // ebx
  int v7; // er14
  int v8; // esi
  int v9; // er12
  DWORD FileVersionInfoSizeW; // eax
  DWORD v11; // ebp
  void *v12; // rax
  void *v13; // rdi
  int v14; // edi
  int v15; // ebp
  DWORD v16; // eax
  DWORD v17; // er15
  void *v18; // rax
  void *v19; // r13
  unsigned int puLen; // [rsp+20h] [rbp-268h] BYREF
  LPVOID lpBuffer; // [rsp+28h] [rbp-260h] BYREF
  DWORD dwHandle; // [rsp+30h] [rbp-258h] BYREF
  LPCWSTR lptstrFilenamea; // [rsp+38h] [rbp-250h]
  WCHAR tstrFilename[264]; // [rsp+40h] [rbp-248h] BYREF

  lptstrFilenamea = lptstrFilename;
  CurrentProcessId = GetCurrentProcessId();
  v3 = OpenProcess(0x410u, 0, CurrentProcessId);
  v4 = v3;
  if ( !v3 )
    return 0i64;
  ModuleFileName = GetModuleFileNameExW(v3, 0i64, tstrFilename, 260i64);
  CloseHandle(v4);
  if ( !ModuleFileName )
    return 0i64;
  v6 = 0;
  lpBuffer = 0i64;
  v7 = 0;
  HIWORD(v8) = 0;
  v9 = 0;
  FileVersionInfoSizeW = GetFileVersionInfoSizeW(tstrFilename, &dwHandle);
  v11 = FileVersionInfoSizeW;
  if ( FileVersionInfoSizeW )
  {
    v12 = malloc(FileVersionInfoSizeW);
    v13 = v12;
    if ( v12 )
    {
      GetFileVersionInfoW(tstrFilename, 0, v11, v12);
      VerQueryValueW(v13, &SubBlock, &lpBuffer, &puLen);
      if ( puLen )
      {
        v7 = 1;
        v8 = *((_DWORD *)lpBuffer + 5);
        v9 = *((_DWORD *)lpBuffer + 4);
      }
      free(v13);
    }
  }
  lpBuffer = 0i64;
  HIWORD(v14) = 0;
  v15 = 0;
  v16 = GetFileVersionInfoSizeW(lptstrFilename, &dwHandle);
  v17 = v16;
  if ( v16 )
  {
    v18 = malloc(v16);
    v19 = v18;
    if ( v18 )
    {
      GetFileVersionInfoW(lptstrFilenamea, 0, v17, v18);
      VerQueryValueW(v19, &SubBlock, &lpBuffer, &puLen);
      if ( puLen )
      {
        v6 = 1;
        v14 = *((_DWORD *)lpBuffer + 5);
        v15 = *((_DWORD *)lpBuffer + 4);
      }
      free(v19);
    }
  }
  return v7 && v6 && v15 == v9 && HIWORD(v14) == HIWORD(v8);
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400B52C0) ----------------------------------------------------
__int64 __fastcall sub_1400B52C0(__int64 a1)
{
  HWND Focus; // rax
  HWND v3; // rcx
  HWND v5; // rcx

  Focus = GetFocus();
  v3 = *(HWND *)(a1 + 4800);
  if ( Focus == v3 )
  {
    if ( (unsigned int)SendMessageW(v3, 0x1032u, 0i64, 0i64) )
      return 1i64;
  }
  else
  {
    v5 = *(HWND *)(a1 + 152);
    if ( Focus == v5 && SendMessageW(v5, 0x110Au, 9ui64, 0i64) )
      return 1i64;
  }
  return 0i64;
}

//----- (00000001400B5340) ----------------------------------------------------
BOOL __fastcall sub_1400B5340(__int64 a1, int *a2)
{
  __int64 v4; // rcx
  UINT v5; // eax
  int v7; // [rsp+50h] [rbp+8h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v4 + 48i64))(v4, &v7);
  v5 = sub_1400AF190(v7);
  CheckMenuRadioItem(*(HMENU *)(a1 + 4912), 0xEA60u, 0xEA68u, v5, 0);
  return TrackPopupMenu(*(HMENU *)(a1 + 4912), 0, *a2, a2[1], 0, *(HWND *)(a1 + 104), 0i64);
}

//----- (00000001400B53E0) ----------------------------------------------------
__int64 __fastcall sub_1400B53E0(_DWORD *a1, int a2)
{
  int v3[4]; // [rsp+20h] [rbp-28h] BYREF

  v3[0] = a1[15236];
  v3[2] = a1[15240];
  v3[3] = a1[15198];
  return (*(__int64 (__fastcall **)(_QWORD, int *))(**(_QWORD **)&a1[2 * a2 + 458] + 576i64))(
           *(_QWORD *)&a1[2 * a2 + 458],
           v3);
}

//----- (00000001400B5450) ----------------------------------------------------
BOOL __fastcall sub_1400B5450(__int64 a1, __int64 a2, _QWORD *a3)
{
  _DWORD *v6; // rax

  v6 = malloc(0x10ui64);
  *(_QWORD *)v6 = *a3;
  v6[2] = *(_DWORD *)(a2 + 8);
  return PostMessageW(*(HWND *)(a1 + 104), 0x8003u, (WPARAM)v6, 0i64);
}

//----- (00000001400B54B0) ----------------------------------------------------
void __fastcall sub_1400B54B0(__int64 a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  __int64 v4; // rdi
  _DWORD *v7; // rax

  v4 = *(_QWORD *)a4;
  v7 = malloc(0x10ui64);
  *(_QWORD *)v7 = *a3;
  v7[2] = a4[2];
  PostMessageW(*(HWND *)(v4 + 104), 0x8003u, (WPARAM)v7, 0i64);
  free(a4);
}

//----- (00000001400B5510) ----------------------------------------------------
void __fastcall sub_1400B5510(__int64 a1, unsigned int a2, int *a3)
{
  __int64 v6; // rcx
  __int64 v7; // r9

  EnterCriticalSection(&stru_14012D7C0);
  v6 = *((_QWORD *)a3 + 1);
  v7 = *a3;
  if ( *(_DWORD *)(v6 + 4 * v7 + 60320) == 1 )
    (*(void (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(v6 + 8 * v7 + 1832) + 56i64))(
      *(_QWORD *)(v6 + 8 * v7 + 1832),
      a2,
      a1);
  LeaveCriticalSection(&stru_14012D7C0);
}

//----- (00000001400B5590) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B5590(__int64 a1, int a2)
{
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(a2, psz2);
  return StrCmpW((PCWSTR)(a1 + 4920), psz2) == 0;
}

//----- (00000001400B5600) ----------------------------------------------------
__int64 __fastcall sub_1400B5600(__int64 a1)
{
  unsigned int v3; // edi

  if ( !*(_DWORD *)(a1 + 62416) )
    return 0i64;
  v3 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v3 == -1 )
    return 1i64;
  while ( (*(unsigned int (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 352i64))(
            *(_QWORD *)(a1 + 2640),
            v3) )
  {
    v3 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)v3, 2i64);
    if ( v3 == -1 )
      return 1i64;
  }
  return 0i64;
}

//----- (00000001400B56A0) ----------------------------------------------------
__int64 __fastcall sub_1400B56A0(__int64 a1)
{
  HWND Focus; // rax
  unsigned int v4; // ebx
  HWND v5; // rcx
  LPARAM v6; // rax
  const ITEMIDLIST *v7; // rax
  ITEMIDLIST *v8; // rsi
  HRESULT v9; // edi
  int v10; // [rsp+40h] [rbp+8h] BYREF
  void *ppv; // [rsp+48h] [rbp+10h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+50h] [rbp+18h] BYREF

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
    return *(_DWORD *)(a1 + 62416) && (unsigned int)sub_1400B5600(a1);
  v5 = *(HWND *)(a1 + 152);
  if ( Focus == v5 )
  {
    v6 = SendMessageW(v5, 0x110Au, 9ui64, 0i64);
    if ( v6 )
    {
      v7 = sub_140020BE0(*(_QWORD *)(a1 + 2656), v6);
      v4 = 1;
      v8 = (ITEMIDLIST *)v7;
      v10 = 1;
      if ( v7 )
      {
        ppv = 0i64;
        ppidlLast = 0i64;
        v9 = SHBindToParent(v7, &stru_1400E3FB0, &ppv, &ppidlLast);
        if ( v9 >= 0 )
        {
          v9 = (*(__int64 (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
                 ppv,
                 1i64,
                 &ppidlLast,
                 &v10);
          (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
        }
      }
      else
      {
        v9 = -2147467259;
      }
      CoTaskMemFree(v8);
      if ( !v9 )
        return v4;
    }
  }
  return 0i64;
}

//----- (00000001400B57C0) ----------------------------------------------------
__int64 __fastcall sub_1400B57C0(__int64 a1, __int64 a2)
{
  unsigned int v4; // edi
  LRESULT v5; // rax
  __int64 v6; // rbx
  HWND v7; // rcx
  const ITEMIDLIST *v8; // rax
  ITEMIDLIST *v9; // rbx
  LPARAM lParam[6]; // [rsp+20h] [rbp-58h] BYREF
  int v12; // [rsp+50h] [rbp-28h]

  v4 = -2147467259;
  v5 = SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64);
  if ( v5 )
  {
    v6 = *(_QWORD *)(a1 + 2656);
    v7 = *(HWND *)(v6 + 24);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v5;
    SendMessageW(v7, 0x113Eu, 0i64, (LPARAM)lParam);
    v8 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v6 + 640) + 16i64 * v12));
    v9 = (ITEMIDLIST *)v8;
    if ( v8 )
      v4 = sub_14007E1F0(v8, a2);
    CoTaskMemFree(v9);
  }
  return v4;
}

//----- (00000001400B5880) ----------------------------------------------------
__int64 __fastcall sub_1400B5880(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  unsigned int v5; // ebp
  ITEMIDLIST *v6; // r12
  ITEMIDLIST *v7; // rbp
  const ITEMIDLIST *v8; // rax
  ITEMIDLIST *v9; // rdi

  v4 = -2147467259;
  v5 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v5 != -1 )
  {
    v6 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
    v7 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                         *(_QWORD *)(a1 + 2640),
                         v5);
    v8 = ILCombine(v6, v7);
    v9 = (ITEMIDLIST *)v8;
    if ( v8 )
      v4 = sub_14007E1F0(v8, a2);
    CoTaskMemFree(v9);
    CoTaskMemFree(v7);
    CoTaskMemFree(v6);
  }
  return v4;
}

//----- (00000001400B5950) ----------------------------------------------------
LRESULT __fastcall sub_1400B5950(HWND hWnd, LPCWSTR pszPath, LPARAM a3)
{
  LPARAM lParam[3]; // [rsp+30h] [rbp-318h] BYREF
  int iIcon; // [rsp+4Ch] [rbp-2FCh]
  int v8; // [rsp+50h] [rbp-2F8h]
  int v9; // [rsp+54h] [rbp-2F4h]
  int v10; // [rsp+58h] [rbp-2F0h]
  SHFILEINFOW psfi; // [rsp+70h] [rbp-2D8h] BYREF

  SHGetFileInfoW(pszPath, 0, &psfi, 0, 0x4008u);
  SendMessageW(hWnd, 0x14Bu, 0i64, 0i64);
  iIcon = psfi.iIcon;
  v8 = psfi.iIcon;
  LODWORD(lParam[0]) = 23;
  lParam[1] = -1i64;
  v10 = 1;
  v9 = 1;
  lParam[2] = a3;
  return SendMessageW(hWnd, 0x40Cu, 0i64, (LPARAM)lParam);
}

//----- (00000001400B5A20) ----------------------------------------------------
void __fastcall sub_1400B5A20(__int64 a1, unsigned int a2)
{
  int v4; // er13
  unsigned int v5; // er12
  unsigned int v6; // edi
  ITEMIDLIST *v7; // rbp
  const ITEMIDLIST *v8; // rax
  ITEMIDLIST *v9; // r14
  LPITEMIDLIST v10; // rbx

  v4 = 0;
  v5 = -1;
  v6 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v6 != -1 )
  {
    do
    {
      if ( ((*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 248i64))(*(_QWORD *)(a1 + 2640), v6) & 0x10) != 0 )
      {
        v4 = 1;
        v5 = v6;
      }
      else
      {
        v7 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
        v8 = (const ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                                   *(_QWORD *)(a1 + 2640),
                                   v6);
        v9 = (ITEMIDLIST *)v8;
        if ( v8 )
        {
          v10 = ILCombine(v7, v8);
          (*(void (__fastcall **)(__int64, LPITEMIDLIST, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 64i64))(
            a1 + 56,
            v10,
            0i64,
            0i64);
          CoTaskMemFree(v10);
          CoTaskMemFree(v9);
        }
        CoTaskMemFree(v7);
      }
      v6 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)v6, 2i64);
    }
    while ( v6 != -1 );
    if ( v4 )
      sub_1400B01C0(a1, v5, a2, 0);
  }
}

//----- (00000001400B5B60) ----------------------------------------------------
__int64 __fastcall sub_1400B5B60(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 504i64))(*(_QWORD *)(a1 + 2640));
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 32i64))(
           a1 + 56,
           *(unsigned int *)(a1 + 7048));
}

//----- (00000001400B5BA0) ----------------------------------------------------
BOOL __fastcall sub_1400B5BA0(__int64 a1)
{
  int v2; // esi
  int v3; // edi
  BOOL result; // eax
  HWND v5; // rcx
  int v6; // ebp
  struct tagRECT v7; // [rsp+40h] [rbp-38h] BYREF
  struct tagRECT Rect; // [rsp+50h] [rbp-28h] BYREF

  v2 = 0;
  v3 = 0;
  result = GetClientRect(*(HWND *)(a1 + 104), &Rect);
  v5 = *(HWND *)(a1 + 120);
  v6 = Rect.bottom - Rect.top;
  if ( v5 )
  {
    result = GetWindowRect(v5, &v7);
    v2 = v7.bottom - v7.top;
  }
  if ( *(_DWORD *)(a1 + 60744) )
  {
    result = GetWindowRect(*(HWND *)(a1 + 112), &v7);
    v3 = v7.bottom - v7.top;
  }
  if ( *(_DWORD *)(a1 + 60756) )
  {
    result = GetWindowRect(*(HWND *)(a1 + 128), &v7);
    v3 += v7.bottom - v7.top;
  }
  if ( *(_DWORD *)(a1 + 60748) )
  {
    GetClientRect(*(HWND *)(a1 + 160), &v7);
    return SetWindowPos(*(HWND *)(a1 + 160), 0i64, 0, v2, v7.right, v6 - v3 - v2, 0x44u);
  }
  return result;
}

//----- (00000001400B5CC0) ----------------------------------------------------
__int64 __fastcall sub_1400B5CC0(__int64 a1, HWND a2)
{
  unsigned int v4; // ebp
  unsigned int v5; // eax
  int v7; // edi
  int v8; // er12
  WPARAM v9; // rbx
  int v10; // eax
  LPARAM lParam; // [rsp+30h] [rbp-A28h] BYREF
  int v12; // [rsp+3Ch] [rbp-A1Ch]
  int v13; // [rsp+40h] [rbp-A18h]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-9D8h] BYREF
  SHFILEINFOW v15; // [rsp+340h] [rbp-718h] BYREF
  WCHAR v16[264]; // [rsp+600h] [rbp-458h] BYREF
  WCHAR pszPath[264]; // [rsp+810h] [rbp-248h] BYREF

  v4 = 0;
  v5 = SendMessageW(a2, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v5 == -1 )
    return 0xFFFFFFFFi64;
  if ( (*(int (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
         *(_QWORD *)(a1 + 2640),
         v5,
         v16) >= 0 )
  {
    v7 = 0;
    v8 = SendMessageW(a2, 0x1004u, 0i64, 0i64);
    if ( v8 > 0 )
    {
      v9 = 0i64;
      do
      {
        (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
          *(_QWORD *)(a1 + 2640),
          (unsigned int)v7,
          pszPath);
        SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x400u);
        SHGetFileInfoW(v16, 0, &v15, 0x2B8u, 0x400u);
        v10 = StrCmpW(psfi.szTypeName, v15.szTypeName);
        v13 = 2;
        if ( v10 )
        {
          v12 = 0;
          SendMessageW(a2, 0x102Bu, v9, (LPARAM)&lParam);
        }
        else
        {
          v12 = 2;
          SendMessageW(a2, 0x102Bu, v9, (LPARAM)&lParam);
          ++v4;
        }
        ++v7;
        ++v9;
      }
      while ( v7 < v8 );
    }
  }
  return v4;
}

//----- (00000001400B5E90) ----------------------------------------------------
void __fastcall sub_1400B5E90(_DWORD *a1)
{
  _DWORD *v1; // r9
  __int64 v2; // r11
  int v3; // er8
  _DWORD *v4; // r10
  __int64 v5; // rbx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx

  v1 = a1 + 15274;
  v2 = 5i64;
  v3 = 0;
  v4 = a1 + 15274;
  v5 = 5i64;
  do
  {
    v6 = v4[16];
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          v9 = v8 - 1;
          if ( v9 )
          {
            if ( v9 == 1 )
              v3 = a1[15193];
          }
          else
          {
            v3 = a1[15192];
          }
        }
        else
        {
          v3 = a1[15191];
        }
      }
      else
      {
        v3 = a1[15188];
      }
    }
    else
    {
      v3 = a1[15190];
    }
    if ( !v3 && (*v4 & 8) == 0 )
      *v4 |= 8u;
    v4 += 28;
    --v5;
  }
  while ( v5 );
  if ( a1[15205] )
  {
    do
    {
      if ( (*v1 & 0x100) == 0 )
        *v1 |= 0x100u;
      v1 += 28;
      --v2;
    }
    while ( v2 );
  }
}

//----- (00000001400B5F60) ----------------------------------------------------
__int64 __fastcall sub_1400B5F60(__int64 a1, __int64 a2)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
    return sub_1400B5880(a1, a2);
  if ( Focus == *(HWND *)(a1 + 152) )
    return sub_1400B57C0(a1, a2);
  return 2147500037i64;
}

//----- (00000001400B5FD0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B5FD0(__int64 a1)
{
  HWND Focus; // rax
  int v3; // eax
  int v5; // [rsp+30h] [rbp+8h] BYREF

  v5 = 32;
  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    v3 = sub_1400B5880(a1, (__int64)&v5);
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 152) )
      return 0i64;
    v3 = sub_1400B57C0(a1, (__int64)&v5);
  }
  if ( v3 >= 0 )
    return (v5 & 0x20) == 32;
  return 0i64;
}

//----- (00000001400B6040) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B6040(__int64 a1)
{
  HWND Focus; // rax
  int v3; // eax
  int v5; // [rsp+30h] [rbp+8h] BYREF

  v5 = 16;
  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    v3 = sub_1400B5880(a1, (__int64)&v5);
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 152) )
      return 0i64;
    v3 = sub_1400B57C0(a1, (__int64)&v5);
  }
  if ( v3 >= 0 )
    return (v5 & 0x10) == 16;
  return 0i64;
}

//----- (00000001400B60B0) ----------------------------------------------------
void __fastcall sub_1400B60B0(__int64 a1)
{
  ITEMIDLIST *v2; // rsi
  LPARAM v3; // rdi
  WCHAR pszPath[264]; // [rsp+20h] [rbp-438h] BYREF
  WCHAR RootPathName[264]; // [rsp+230h] [rbp-228h] BYREF

  if ( *(_DWORD *)(a1 + 60900) )
  {
    v2 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
    sub_14007E270(v2, pszPath, 0x8000u);
    if ( !PathIsUNCW(pszPath) )
    {
      PathStripToRootW(RootPathName);
      if ( GetDriveTypeW(RootPathName) != 4 )
      {
        v3 = sub_140020E30(*(_QWORD *)(a1 + 2656), v2, 0);
        if ( v3 )
        {
          if ( SendMessageW(*(HWND *)(a1 + 152), 0x110Au, 9ui64, 0i64) != v3 )
            *(_DWORD *)(a1 + 7020) = 1;
          SendMessageW(*(HWND *)(a1 + 152), 0x110Bu, 9ui64, v3);
        }
      }
    }
    CoTaskMemFree(v2);
  }
}

//----- (00000001400B61E0) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B61E0(__int64 a1)
{
  HWND Focus; // rax
  int v3; // eax
  int v5; // [rsp+30h] [rbp+8h] BYREF

  v5 = 64;
  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    v3 = sub_1400B5880(a1, (__int64)&v5);
  }
  else
  {
    if ( Focus != *(HWND *)(a1 + 152) )
      return 0i64;
    v3 = sub_1400B57C0(a1, (__int64)&v5);
  }
  if ( v3 >= 0 )
    return (v5 & 0x40) == 64;
  return 0i64;
}

//----- (00000001400B6250) ----------------------------------------------------
__int64 __fastcall sub_1400B6250(__int64 a1)
{
  HWND Focus; // r14
  _QWORD *v3; // rax
  unsigned int v4; // er13
  __int64 *v5; // rdi
  __int64 **v6; // rbx
  unsigned int v7; // esi
  __int64 *v8; // rcx
  __int64 *v9; // rbx
  HWND v11; // rcx
  LRESULT v12; // rax
  __int64 v13; // rbx
  const ITEMIDLIST *v14; // rax
  ITEMIDLIST *v15; // r12
  HRESULT v16; // ebx
  __int64 *v17; // rcx
  __int64 *v18; // rbx
  __int64 *v19; // rcx
  __int64 *v20; // rbx
  char *v21; // [rsp+20h] [rbp-89h] BYREF
  void *Block[3]; // [rsp+28h] [rbp-81h] BYREF
  __int64 pExceptionObject[8]; // [rsp+40h] [rbp-69h] BYREF
  LPARAM lParam[6]; // [rsp+80h] [rbp-29h] BYREF
  int v25; // [rsp+B0h] [rbp+7h]
  int v26; // [rsp+118h] [rbp+6Fh] BYREF
  void *ppv; // [rsp+120h] [rbp+77h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+128h] [rbp+7Fh] BYREF

  pExceptionObject[3] = -2i64;
  Focus = GetFocus();
  Block[1] = 0i64;
  v3 = operator new(0x30ui64);
  if ( !v3 )
  {
    v21 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block[0] = v3;
  *v3 = v3;
  v3[1] = v3;
  sub_1400762E0((__int64 *)Block);
  v4 = 0;
  v5 = (__int64 *)Block[0];
  v6 = *(__int64 ***)Block[0];
  v7 = 1;
  if ( *(void **)Block[0] != Block[0] )
  {
    while ( 1 )
    {
      pExceptionObject[5] = (__int64)v6[3];
      pExceptionObject[6] = (__int64)v6[4];
      pExceptionObject[7] = (__int64)v6[5];
      if ( IsClipboardFormatAvailable(*((unsigned __int16 *)v6 + 8)) )
        break;
      v6 = (__int64 **)*v6;
      if ( v6 == (__int64 **)v5 )
        goto LABEL_7;
    }
    v4 = 1;
  }
LABEL_7:
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    if ( !v4 || !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 304i64))(*(_QWORD *)(a1 + 2640)) )
      v7 = 0;
    v8 = (__int64 *)*v5;
    *v5 = (__int64)v5;
    v5[1] = (__int64)v5;
    if ( v8 != v5 )
    {
      do
      {
        v9 = (__int64 *)*v8;
        j_free(v8);
        v8 = v9;
      }
      while ( v9 != v5 );
    }
    j_free(v5);
    return v7;
  }
  else
  {
    v11 = *(HWND *)(a1 + 152);
    if ( Focus != v11 )
      goto LABEL_24;
    v12 = SendMessageW(v11, 0x110Au, 9ui64, 0i64);
    if ( !v12 )
      goto LABEL_24;
    v13 = *(_QWORD *)(a1 + 2656);
    LODWORD(lParam[0]) = 20;
    lParam[1] = v12;
    SendMessageW(*(HWND *)(v13 + 24), 0x113Eu, 0i64, (LPARAM)lParam);
    v14 = ILClone(*(LPCITEMIDLIST *)(*(_QWORD *)(v13 + 640) + 16i64 * v25));
    v15 = (ITEMIDLIST *)v14;
    v26 = 0x40000000;
    if ( v14 )
    {
      ppv = 0i64;
      ppidlLast = 0i64;
      v16 = SHBindToParent(v14, &stru_1400E3FB0, &ppv, &ppidlLast);
      if ( v16 >= 0 )
      {
        v16 = (*(__int64 (__fastcall **)(void *, __int64, LPCITEMIDLIST *, int *))(*(_QWORD *)ppv + 72i64))(
                ppv,
                1i64,
                &ppidlLast,
                &v26);
        (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
      }
    }
    else
    {
      v16 = -2147467259;
    }
    CoTaskMemFree(v15);
    if ( !v16 )
    {
      v17 = (__int64 *)*v5;
      *v5 = (__int64)v5;
      v5[1] = (__int64)v5;
      if ( v17 != v5 )
      {
        do
        {
          v18 = (__int64 *)*v17;
          j_free(v17);
          v17 = v18;
        }
        while ( v18 != v5 );
      }
      j_free(v5);
      return v4;
    }
    else
    {
LABEL_24:
      v19 = (__int64 *)*v5;
      *v5 = (__int64)v5;
      v5[1] = (__int64)v5;
      if ( v19 != v5 )
      {
        do
        {
          v20 = (__int64 *)*v19;
          j_free(v19);
          v19 = v20;
        }
        while ( v20 != v5 );
      }
      j_free(v5);
      return 0i64;
    }
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400B64E0) ----------------------------------------------------
__int64 __fastcall sub_1400B64E0(HWND *a1, WPARAM a2, LPARAM a3)
{
  int v6; // eax
  __int16 v7; // bx
  __int64 v8; // r13
  WPARAM v9; // r12
  HWND v10; // rcx
  HWND v11; // rcx
  WPARAM v12; // rbp
  unsigned int j; // eax
  unsigned int i; // eax
  __int64 lParam[4]; // [rsp+20h] [rbp-68h] BYREF
  int v17; // [rsp+40h] [rbp-48h]
  wchar_t v18; // [rsp+48h] [rbp-40h] BYREF

  v6 = SendMessageW(a1[17], 0x1304u, 0i64, 0i64);
  v7 = 0;
  if ( v6 > 0 )
  {
    v8 = (unsigned int)v6;
    v9 = 0i64;
    do
    {
      v10 = a1[17];
      LODWORD(lParam[0]) = 8;
      SendMessageW(v10, 0x133Cu, v9, (LPARAM)lParam);
      v11 = a1[v17 + 229];
      (*(void (__fastcall **)(HWND, WPARAM, LPARAM))(*(_QWORD *)v11 + 672i64))(v11, a2, a3);
      ++v9;
      --v8;
    }
    while ( v8 );
  }
  SendMessageW(a1[19], 0x219u, a2, a3);
  v12 = a2 - 0x8000;
  if ( !v12 )
  {
    if ( *(_DWORD *)(a3 + 4) == 2 )
    {
      for ( i = *(_DWORD *)(a3 + 12); (i & 1) == 0; ++v7 )
        i >>= 1;
      sub_140001000(&v18, 4ui64, L"%c:\\", (unsigned __int16)(v7 + 65));
      if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
      {
        sub_1400C4E10((__int64)a1, &v18);
      }
      else
      {
        sub_1400C4FE0((__int64)a1, &v18);
        sub_140080090(a1[15], a1[127]);
      }
    }
    return 2147500033i64;
  }
  if ( v12 != 4 )
    return 2147500033i64;
  if ( *(_DWORD *)(a3 + 4) == 2 )
  {
    for ( j = *(_DWORD *)(a3 + 12); (j & 1) == 0; ++v7 )
      j >>= 1;
    sub_140001000(&v18, 4ui64, L"%c:\\", (unsigned __int16)(v7 + 65));
    if ( (*(_BYTE *)(a3 + 16) & 1) != 0 )
    {
      sub_1400C4E10((__int64)a1, &v18);
      return 1i64;
    }
    sub_1400C4F00((__int64)a1, &v18);
    sub_140080090(a1[15], a1[127]);
  }
  return 1i64;
}
// 1400F3CC0: using guessed type wchar_t aC_4[5];
// 1400F3CD0: using guessed type wchar_t aC_3[5];
// 1400B64E0: using guessed type LPARAM lParam[4];

//----- (00000001400B66C0) ----------------------------------------------------
void __fastcall sub_1400B66C0(int a1, __int64 ****a2)
{
  unsigned int v2; // er12
  int *v4; // rsi
  unsigned int v5; // ebx
  void *v6; // rax
  void *v7; // r13
  __int64 ***v8; // rbp
  __int64 **v9; // rax
  __int64 v10; // rdx
  char *v11; // rax
  __int64 ***v12; // rdx
  int v13[10]; // [rsp+20h] [rbp-28h] BYREF

  v2 = 0;
  v4 = 0i64;
  v5 = 0;
  switch ( a1 )
  {
    case 0:
      v5 = 51;
      v4 = (int *)&unk_1401237D0;
      break;
    case 1:
      v4 = (int *)&unk_140123A38;
      goto LABEL_9;
    case 2:
      v5 = 6;
      v4 = (int *)&unk_140123A50;
      break;
    case 3:
      v5 = 6;
      v4 = (int *)&unk_140123AB0;
      break;
    case 4:
      v5 = 6;
      v4 = (int *)&unk_140123B10;
      break;
    case 5:
      v5 = 4;
      v4 = (int *)&unk_140123B58;
      break;
    case 6:
      v4 = (int *)&unk_140123A98;
LABEL_9:
      v5 = 2;
      break;
    default:
      break;
  }
  v6 = malloc(4i64 * v5);
  v7 = v6;
  if ( v5 )
    memset(v6, 0, 4i64 * v5);
  if ( v5 )
  {
    do
    {
      v8 = *a2;
      v9 = **a2;
      if ( v9 == (__int64 **)*a2 )
      {
LABEL_16:
        v10 = (__int64)v8[1];
        v13[0] = *v4;
        v13[1] = v4[1];
        v13[2] = 150;
        v11 = sub_140017AD0((__int64)v8, v10, v13);
        v12 = a2[1];
        if ( v12 == (__int64 ***)0x1555555555555554i64 )
          sub_14002B5F8("list<T> too long");
        a2[1] = (__int64 ***)((char *)v12 + 1);
        v8[1] = (__int64 **)v11;
        **((_QWORD **)v11 + 1) = v11;
      }
      else
      {
        while ( *((_DWORD *)v9 + 4) != *v4 )
        {
          v9 = (__int64 **)*v9;
          if ( v9 == (__int64 **)v8 )
            goto LABEL_16;
        }
      }
      ++v2;
      v4 += 3;
    }
    while ( v2 < v5 );
  }
  free(v7);
}

//----- (00000001400B6860) ----------------------------------------------------
void __fastcall sub_1400B6860(_QWORD *a1)
{
  void *v2; // r13
  unsigned int v3; // er14
  int *v4; // rsi
  unsigned int i; // er12
  _QWORD *v6; // rdi
  _QWORD *v7; // rcx
  __int64 v8; // rdx
  char *v9; // rax
  __int64 v10; // rdx
  _QWORD *v11; // rax
  unsigned int v12; // er12
  int *v13; // rsi
  void *v14; // r13
  _QWORD *v15; // rdi
  _QWORD *v16; // rcx
  __int64 v17; // rdx
  char *v18; // rax
  __int64 v19; // rdx
  _QWORD *v20; // rax
  unsigned int v21; // er12
  int *v22; // rsi
  void *v23; // r13
  _QWORD *v24; // rdi
  _QWORD *v25; // rcx
  __int64 v26; // rdx
  char *v27; // rax
  __int64 v28; // rdx
  _QWORD *v29; // rax
  unsigned int v30; // er12
  int *v31; // rsi
  void *v32; // r13
  _QWORD *v33; // rdi
  _QWORD *v34; // rcx
  __int64 v35; // rdx
  char *v36; // rax
  __int64 v37; // rdx
  _QWORD *v38; // rax
  unsigned int v39; // er12
  int *v40; // rsi
  void *v41; // r13
  _QWORD *v42; // rdi
  _QWORD *v43; // rcx
  __int64 v44; // rdx
  char *v45; // rax
  __int64 v46; // rdx
  _QWORD *v47; // rax
  unsigned int v48; // er12
  int *v49; // rsi
  void *v50; // r13
  _QWORD *v51; // rdi
  _QWORD *v52; // rcx
  __int64 v53; // rdx
  char *v54; // rax
  __int64 v55; // rdx
  _QWORD *v56; // rax
  int *v57; // rsi
  void *v58; // r12
  _QWORD *v59; // rdi
  _QWORD *v60; // rcx
  __int64 v61; // rdx
  char *v62; // rax
  __int64 v63; // rdx
  int v64; // [rsp+20h] [rbp-10h] BYREF
  int v65; // [rsp+24h] [rbp-Ch]
  int v66; // [rsp+28h] [rbp-8h]

  v2 = malloc(0xCCui64);
  memset(v2, 0, 0xCCui64);
  v3 = 0;
  v4 = (int *)&unk_1401237D0;
  for ( i = 0; i < 0x33; ++i )
  {
    v6 = (_QWORD *)a1[7779];
    v7 = (_QWORD *)*v6;
    if ( (_QWORD *)*v6 == v6 )
    {
LABEL_5:
      v8 = v6[1];
      v64 = *v4;
      v65 = v4[1];
      v66 = 150;
      v9 = sub_140017AD0((__int64)v6, v8, &v64);
      v10 = a1[7780];
      if ( v10 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7780] = v10 + 1;
      v6[1] = v9;
      **((_QWORD **)v9 + 1) = v9;
    }
    else
    {
      while ( *((_DWORD *)v7 + 4) != *v4 )
      {
        v7 = (_QWORD *)*v7;
        if ( v7 == v6 )
          goto LABEL_5;
      }
    }
    v4 += 3;
  }
  free(v2);
  v11 = malloc(8ui64);
  v12 = 0;
  v13 = (int *)&unk_140123A38;
  *v11 = 0i64;
  v14 = v11;
  do
  {
    v15 = (_QWORD *)a1[7785];
    v16 = (_QWORD *)*v15;
    if ( (_QWORD *)*v15 == v15 )
    {
LABEL_12:
      v17 = v15[1];
      v64 = *v13;
      v65 = v13[1];
      v66 = 150;
      v18 = sub_140017AD0((__int64)v15, v17, &v64);
      v19 = a1[7786];
      if ( v19 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7786] = v19 + 1;
      v15[1] = v18;
      **((_QWORD **)v18 + 1) = v18;
    }
    else
    {
      while ( *((_DWORD *)v16 + 4) != *v13 )
      {
        v16 = (_QWORD *)*v16;
        if ( v16 == v15 )
          goto LABEL_12;
      }
    }
    ++v12;
    v13 += 3;
  }
  while ( v12 < 2 );
  free(v14);
  v20 = malloc(0x18ui64);
  v21 = 0;
  v22 = (int *)&unk_140123A50;
  *v20 = 0i64;
  v20[1] = 0i64;
  v20[2] = 0i64;
  v23 = v20;
  do
  {
    v24 = (_QWORD *)a1[7782];
    v25 = (_QWORD *)*v24;
    if ( (_QWORD *)*v24 == v24 )
    {
LABEL_19:
      v26 = v24[1];
      v64 = *v22;
      v65 = v22[1];
      v66 = 150;
      v27 = sub_140017AD0((__int64)v24, v26, &v64);
      v28 = a1[7783];
      if ( v28 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7783] = v28 + 1;
      v24[1] = v27;
      **((_QWORD **)v27 + 1) = v27;
    }
    else
    {
      while ( *((_DWORD *)v25 + 4) != *v22 )
      {
        v25 = (_QWORD *)*v25;
        if ( v25 == v24 )
          goto LABEL_19;
      }
    }
    ++v21;
    v22 += 3;
  }
  while ( v21 < 6 );
  free(v23);
  v29 = malloc(0x18ui64);
  v30 = 0;
  v31 = (int *)&unk_140123AB0;
  *v29 = 0i64;
  v29[1] = 0i64;
  v29[2] = 0i64;
  v32 = v29;
  do
  {
    v33 = (_QWORD *)a1[7788];
    v34 = (_QWORD *)*v33;
    if ( (_QWORD *)*v33 == v33 )
    {
LABEL_26:
      v35 = v33[1];
      v64 = *v31;
      v65 = v31[1];
      v66 = 150;
      v36 = sub_140017AD0((__int64)v33, v35, &v64);
      v37 = a1[7789];
      if ( v37 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7789] = v37 + 1;
      v33[1] = v36;
      **((_QWORD **)v36 + 1) = v36;
    }
    else
    {
      while ( *((_DWORD *)v34 + 4) != *v31 )
      {
        v34 = (_QWORD *)*v34;
        if ( v34 == v33 )
          goto LABEL_26;
      }
    }
    ++v30;
    v31 += 3;
  }
  while ( v30 < 6 );
  free(v32);
  v38 = malloc(0x18ui64);
  v39 = 0;
  v40 = (int *)&unk_140123B10;
  *v38 = 0i64;
  v38[1] = 0i64;
  v38[2] = 0i64;
  v41 = v38;
  do
  {
    v42 = (_QWORD *)a1[7791];
    v43 = (_QWORD *)*v42;
    if ( (_QWORD *)*v42 == v42 )
    {
LABEL_33:
      v44 = v42[1];
      v64 = *v40;
      v65 = v40[1];
      v66 = 150;
      v45 = sub_140017AD0((__int64)v42, v44, &v64);
      v46 = a1[7792];
      if ( v46 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7792] = v46 + 1;
      v42[1] = v45;
      **((_QWORD **)v45 + 1) = v45;
    }
    else
    {
      while ( *((_DWORD *)v43 + 4) != *v40 )
      {
        v43 = (_QWORD *)*v43;
        if ( v43 == v42 )
          goto LABEL_33;
      }
    }
    ++v39;
    v40 += 3;
  }
  while ( v39 < 6 );
  free(v41);
  v47 = malloc(0x10ui64);
  v48 = 0;
  v49 = (int *)&unk_140123B58;
  *v47 = 0i64;
  v47[1] = 0i64;
  v50 = v47;
  do
  {
    v51 = (_QWORD *)a1[7794];
    v52 = (_QWORD *)*v51;
    if ( (_QWORD *)*v51 == v51 )
    {
LABEL_40:
      v53 = v51[1];
      v64 = *v49;
      v65 = v49[1];
      v66 = 150;
      v54 = sub_140017AD0((__int64)v51, v53, &v64);
      v55 = a1[7795];
      if ( v55 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7795] = v55 + 1;
      v51[1] = v54;
      **((_QWORD **)v54 + 1) = v54;
    }
    else
    {
      while ( *((_DWORD *)v52 + 4) != *v49 )
      {
        v52 = (_QWORD *)*v52;
        if ( v52 == v51 )
          goto LABEL_40;
      }
    }
    ++v48;
    v49 += 3;
  }
  while ( v48 < 4 );
  free(v50);
  v56 = malloc(8ui64);
  v57 = (int *)&unk_140123A98;
  *v56 = 0i64;
  v58 = v56;
  do
  {
    v59 = (_QWORD *)a1[7797];
    v60 = (_QWORD *)*v59;
    if ( (_QWORD *)*v59 == v59 )
    {
LABEL_47:
      v61 = v59[1];
      v64 = *v57;
      v65 = v57[1];
      v66 = 150;
      v62 = sub_140017AD0((__int64)v59, v61, &v64);
      v63 = a1[7798];
      if ( v63 == 0x1555555555555554i64 )
        sub_14002B5F8("list<T> too long");
      a1[7798] = v63 + 1;
      v59[1] = v62;
      **((_QWORD **)v62 + 1) = v62;
    }
    else
    {
      while ( *((_DWORD *)v60 + 4) != *v57 )
      {
        v60 = (_QWORD *)*v60;
        if ( v60 == v59 )
          goto LABEL_47;
      }
    }
    ++v3;
    v57 += 3;
  }
  while ( v3 < 2 );
  free(v58);
}

//----- (00000001400B6DB0) ----------------------------------------------------
void __fastcall sub_1400B6DB0(__int64 a1)
{
  _QWORD *v2; // rax
  int **v3; // rcx
  __int64 v4; // rdx
  void *v5; // rbx
  int *v6; // rax

  v2 = malloc(0x50ui64);
  v3 = *(int ***)(a1 + 62072);
  v4 = 0i64;
  *v2 = 0i64;
  v2[1] = 0i64;
  v2[2] = 0i64;
  v2[3] = 0i64;
  v2[4] = 0i64;
  v2[5] = 0i64;
  v2[6] = 0i64;
  v2[7] = 0i64;
  v2[8] = 0i64;
  v2[9] = 0i64;
  v5 = v2;
  v6 = *v3;
  if ( *v3 == (int *)v3 )
  {
LABEL_4:
    while ( *((int *)v5 + v4) <= 1 )
    {
      if ( ++v4 >= 20 )
      {
        free(v5);
        return;
      }
    }
  }
  else
  {
    while ( v6[4] >= 45000 )
    {
      v6 = *(int **)v6;
      if ( v6 == (int *)v3 )
        goto LABEL_4;
    }
  }
  sub_1400BCEA0(a1);
  free(v5);
}

//----- (00000001400B6E60) ----------------------------------------------------
void __fastcall sub_1400B6E60(__int64 a1)
{
  int v1; // eax
  int v3; // eax

  v1 = *(_DWORD *)(a1 + 7044);
  if ( !v1 )
    v1 = 208;
  *(_DWORD *)(a1 + 7044) = v1;
  v3 = *(_DWORD *)(a1 + 7012);
  if ( v3 < 70 )
    v3 = 90;
  *(_DWORD *)(a1 + 7012) = v3;
  sub_1400B6860((_QWORD *)a1);
  sub_1400B6DB0(a1);
}

//----- (00000001400B6EC0) ----------------------------------------------------
void __fastcall sub_1400B6EC0(__int64 a1)
{
  __int64 v2; // rax
  HWND v3; // r8
  HINSTANCE v4; // r10
  void *v5; // rdi
  _QWORD **v6; // rax
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx
  __int64 dwInitParam[2]; // [rsp+40h] [rbp-78h] BYREF
  HINSTANCE v10; // [rsp+50h] [rbp-68h]
  int v11; // [rsp+58h] [rbp-60h]
  HWND hWndParent; // [rsp+60h] [rbp-58h]
  int v13; // [rsp+70h] [rbp-48h]
  char v14; // [rsp+74h] [rbp-44h]
  void *Block; // [rsp+88h] [rbp-30h]
  __int64 v16; // [rsp+90h] [rbp-28h]
  int v17; // [rsp+98h] [rbp-20h]
  __int64 *v18; // [rsp+A8h] [rbp-10h]

  if ( a1 )
    v2 = a1 + 56;
  else
    v2 = 0i64;
  v3 = *(HWND *)(a1 + 104);
  v4 = hInstance;
  v10 = hInstance;
  v11 = 174;
  hWndParent = v3;
  v14 = 1;
  Block = 0i64;
  v13 = 0;
  dwInitParam[0] = (__int64)&CSelectColumnsDialog::`vftable';
  v16 = v2;
  v17 = 0;
  if ( (dword_140130590 & 1) == 0 )
  {
    dword_140130590 |= 1u;
    sub_14009D6B0();
    atexit(sub_1400E2070);
    v3 = hWndParent;
    v4 = v10;
  }
  v18 = &qword_14012F1E0;
  DialogBoxParamW(v4, (LPCWSTR)(unsigned __int16)v11, v3, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
  sub_1400CCA00(a1);
  dwInitParam[0] = (__int64)&CBaseDialog::`vftable';
  v5 = Block;
  if ( Block )
  {
    v6 = (_QWORD **)*((_QWORD *)Block + 1);
    v7 = *v6;
    *v6 = v6;
    *(_QWORD *)(*((_QWORD *)v5 + 1) + 8i64) = *((_QWORD *)v5 + 1);
    *((_QWORD *)v5 + 2) = 0i64;
    if ( v7 != *((_QWORD **)v5 + 1) )
    {
      do
      {
        v8 = (_QWORD *)*v7;
        j_free(v7);
        v7 = v8;
      }
      while ( v8 != *((_QWORD **)v5 + 1) );
    }
    j_free(*((void **)v5 + 1));
    j_free(v5);
  }
}
// 1400B6F7C: conditional instruction was optimized away because ecx.4==0
// 1400F7648: using guessed type void *CSelectColumnsDialog::`vftable';
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';
// 14012F1E0: using guessed type __int64 qword_14012F1E0;
// 140130590: using guessed type int dword_140130590;
// 1400B6EC0: using guessed type LPARAM var_78[2];

//----- (00000001400B7020) ----------------------------------------------------
void __fastcall sub_1400B7020(__int64 a1, int a2)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rsi
  unsigned int i; // er12
  __int64 v8; // rcx
  char *v9; // rdi
  bool v10; // zf
  char *v11; // rax
  __int64 v12; // rcx
  WCHAR *v13; // rdi
  void **v14; // rbx
  void **v15; // rdi
  void **v16; // rsi
  char *v17; // [rsp+20h] [rbp-E0h] BYREF
  void *v18; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v19; // [rsp+30h] [rbp-D0h]
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-C0h] BYREF
  void *Block[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v22; // [rsp+70h] [rbp-90h]
  unsigned __int64 v23; // [rsp+78h] [rbp-88h]
  WCHAR Buffer[128]; // [rsp+90h] [rbp-70h] BYREF
  char v25[528]; // [rsp+190h] [rbp+90h] BYREF

  pExceptionObject[3] = -2i64;
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64) )
  {
    v4 = 0i64;
    v19 = 0i64;
    v5 = operator new(0x38ui64);
    v6 = (__int64)v5;
    if ( !v5 )
    {
      v17 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v17);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v18 = v5;
    *v5 = v5;
    v5[1] = v5;
    for ( i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
          i != -1;
          i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)i, 2i64) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(
        *(_QWORD *)(a1 + 2640),
        i,
        v25);
      v23 = 7i64;
      v22 = 0i64;
      LOWORD(Block[0]) = 0;
      v8 = -1i64;
      v9 = v25;
      do
      {
        if ( !v8 )
          break;
        v10 = *(_WORD *)v9 == 0;
        v9 += 2;
        --v8;
      }
      while ( !v10 );
      sub_1400099E0(Block, v25, -v8 - 2);
      v11 = sub_14000A760(v6, *(_QWORD *)(v6 + 8), Block);
      if ( v4 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      v19 = ++v4;
      *(_QWORD *)(v6 + 8) = v11;
      **((_QWORD **)v11 + 1) = v11;
      if ( v23 >= 8 )
        j_free(Block[0]);
    }
    LoadStringW(hInstance, 0x86Au, Buffer, 128);
    v23 = 7i64;
    v22 = 0i64;
    LOWORD(Block[0]) = 0;
    v12 = -1i64;
    v13 = Buffer;
    do
    {
      if ( !v12 )
        break;
      v10 = *v13++ == 0;
      --v12;
    }
    while ( !v10 );
    sub_1400099E0(Block, Buffer, -v12 - 2);
    sub_1400D3CE0(*(HWND *)(a1 + 104), Block, (_QWORD **)&v18, a2);
    if ( v23 >= 8 )
      j_free(Block[0]);
    v14 = (void **)v18;
    v15 = *(void ***)v18;
    *(_QWORD *)v18 = v18;
    v14[1] = v14;
    if ( v15 != v14 )
    {
      do
      {
        v16 = (void **)*v15;
        if ( (unsigned __int64)v15[5] >= 8 )
          j_free(v15[2]);
        v15[5] = (void *)7;
        v15[4] = 0i64;
        *((_WORD *)v15 + 8) = 0;
        j_free(v15);
        v15 = v16;
      }
      while ( v16 != v14 );
    }
    j_free(v14);
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400B72E0) ----------------------------------------------------
__int64 __fastcall sub_1400B72E0(__int64 a1, int a2, __int64 a3)
{
  unsigned __int16 v4; // di
  WCHAR Buffer[512]; // [rsp+20h] [rbp-418h] BYREF

  v4 = a2;
  if ( HIWORD(a2) != 0xFFFF || a3 )
  {
    sub_140079430(*(_QWORD *)(a1 + 4768));
    LoadStringW(hInstance, v4, Buffer, 512);
    SetWindowTextW(*(HWND *)(a1 + 112), Buffer);
  }
  else
  {
    sub_140079310(*(_QWORD *)(a1 + 4768));
  }
  return 0i64;
}

//----- (00000001400B7390) ----------------------------------------------------
int __fastcall sub_1400B7390(char *a1, __int64 *a2, __int64 *a3)
{
  __int64 v3; // rbx
  double v6; // xmm0_8
  double v7; // xmm0_8
  double v8; // xmm1_8
  __int64 v9; // rcx
  signed __int64 v10; // rdx
  __int16 v11; // ax
  WCHAR Buffer[16]; // [rsp+30h] [rbp-488h] BYREF
  char v14[64]; // [rsp+50h] [rbp-468h] BYREF
  WCHAR String[512]; // [rsp+90h] [rbp-428h] BYREF

  v3 = *a3;
  sub_140083DE0(*a3, v14, 0x20ui64, 0, 0);
  LoadStringW(hInstance, 0x1FF4u, Buffer, 16);
  v6 = (double)(int)v3;
  if ( v3 < 0 )
    v6 = v6 + 1.844674407370955e19;
  v7 = v6 * 100.0;
  v8 = (double)(int)*a2;
  if ( *a2 < 0 )
    v8 = v8 + 1.844674407370955e19;
  sub_140001000(String, 0x20ui64, L"%s %s (%.0f%%)", v14, Buffer, v7 / v8);
  if ( lstrlenW(String) < 64 )
  {
    v9 = 64i64;
    v10 = (char *)String - a1;
    while ( v9 != -2147483582 )
    {
      v11 = *(_WORD *)&a1[v10];
      if ( !v11 )
        break;
      *(_WORD *)a1 = v11;
      a1 += 2;
      if ( !--v9 )
      {
        a1 -= 2;
        break;
      }
    }
    *(_WORD *)a1 = 0;
  }
  return lstrlenW(String);
}
// 1400B74A6: conditional instruction was optimized away because rcx.8!=0
// 1400F3F88: using guessed type wchar_t aSS0f[15];

//----- (00000001400B74F0) ----------------------------------------------------
LRESULT __fastcall sub_1400B74F0(__int64 a1)
{
  HWND v2; // rcx
  unsigned int v3; // ebx
  char v5[8]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v6; // [rsp+38h] [rbp-C8h]
  __int16 v7; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v8; // [rsp+42h] [rbp-BEh]
  __int64 v9; // [rsp+4Ah] [rbp-B6h]
  __int64 v10; // [rsp+52h] [rbp-AEh]
  __int64 v11; // [rsp+5Ah] [rbp-A6h]
  __int64 v12; // [rsp+62h] [rbp-9Eh]
  __int64 v13; // [rsp+6Ah] [rbp-96h]
  __int64 v14; // [rsp+72h] [rbp-8Eh]
  int v15; // [rsp+7Ah] [rbp-86h]
  __int16 v16; // [rsp+7Eh] [rbp-82h]
  wchar_t lParam[64]; // [rsp+80h] [rbp-80h] BYREF
  wchar_t v18[64]; // [rsp+100h] [rbp+0h] BYREF
  WCHAR Buffer[64]; // [rsp+180h] [rbp+80h] BYREF
  WCHAR v20[64]; // [rsp+200h] [rbp+100h] BYREF

  memset(lParam, 0, sizeof(lParam));
  memset(v18, 0, sizeof(v18));
  v2 = *(HWND *)(a1 + 128);
  v7 = 0;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0;
  v16 = 0;
  SendMessageW(v2, 0x8066u, (WPARAM)&unk_1400EC36C, 0i64);
  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 584i64))(*(_QWORD *)(a1 + 2640));
  LoadStringW(hInstance, 0x1FF0u, Buffer, 64);
  sub_140001000(lParam, 0x40ui64, L"%d %s", v3, Buffer);
  SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lParam);
  if ( !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640)) )
  {
    (*(void (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 2640) + 408i64))(*(_QWORD *)(a1 + 2640), v5);
    sub_140083DE0(v6, (char *)&v7, 0x20ui64, *(_DWORD *)(a1 + 60880), *(_DWORD *)(a1 + 60916));
    LoadStringW(hInstance, 0x2017u, v20, 64);
    sub_140001000(v18, 0x40ui64, L"%s: %s", v20, &v7);
  }
  return SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)v18);
}
// 1400F3F68: using guessed type wchar_t aDS[6];
// 1400F3F78: using guessed type wchar_t aSS_6[7];
// 1400B74F0: using guessed type char var_260[8];

//----- (00000001400B76E0) ----------------------------------------------------
unsigned int __fastcall sub_1400B76E0(__int64 a1)
{
  unsigned int result; // eax
  unsigned int v3; // esi
  __int64 v4; // rdi
  int v5; // eax
  __int64 *v6; // rcx
  bool v7; // zf
  __int64 v8; // rax
  __int64 v9; // r13
  char FileAttributesW; // al
  int v11; // er14
  _QWORD *v12; // rsi
  _DWORD *v13; // rax
  _WORD *v14; // rcx
  __int16 v15; // ax
  __int64 v16; // rdi
  DWORD v17; // eax
  __int64 v18; // rdx
  char *v19; // r11
  __int64 v20; // rax
  HANDLE Thread; // rax
  LPWSTR ExtensionW; // rax
  const WCHAR *v23; // rsi
  LPCWSTR *v24; // rdi
  unsigned int v25; // esi
  __int64 v26; // rdi
  int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // eax
  int ImagePixelFormat; // eax
  __int64 v31; // rcx
  int ImageHorizontalResolution; // eax
  __int64 v33; // rcx
  int ImageVerticalResolution; // eax
  LPARAM v35; // r9
  WCHAR *v36; // r8
  DWORD ThreadId[2]; // [rsp+40h] [rbp-C0h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+48h] [rbp-B8h] BYREF
  int v39; // [rsp+50h] [rbp-B0h]
  SHFILEINFOW psfi; // [rsp+60h] [rbp-A0h] BYREF
  WCHAR v41[64]; // [rsp+320h] [rbp+220h] BYREF
  WCHAR Buffer[64]; // [rsp+3A0h] [rbp+2A0h] BYREF
  __int16 lpFileSystemNameBuffer[264]; // [rsp+420h] [rbp+320h] BYREF
  WCHAR FileName[264]; // [rsp+630h] [rbp+530h] BYREF
  char v45[512]; // [rsp+840h] [rbp+740h] BYREF
  WCHAR v46[256]; // [rsp+A40h] [rbp+940h] BYREF
  LPARAM lParam[66]; // [rsp+C40h] [rbp+B40h] BYREF
  __int16 v48[512]; // [rsp+E50h] [rbp+D50h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v3 = result;
  if ( result == -1 )
    return result;
  v4 = 260i64;
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64, LPARAM *))(**(_QWORD **)(a1 + 2640) + 128i64))(
    *(_QWORD *)(a1 + 2640),
    result,
    260i64,
    lParam);
  SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lParam);
  (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 96i64))(
    *(_QWORD *)(a1 + 2640),
    v3,
    FileName);
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640));
  v6 = *(__int64 **)(a1 + 2640);
  v7 = v5 == 0;
  v8 = *v6;
  if ( v7 )
  {
    (*(void (__fastcall **)(__int64 *, _QWORD, WCHAR *))(v8 + 96))(v6, v3, FileName);
    v9 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 264i64))(*(_QWORD *)(a1 + 2640), v3);
    FileAttributesW = GetFileAttributesW(FileName);
    v11 = FileAttributesW & 0x10;
    if ( (FileAttributesW & 0x10) != 0 && *(_DWORD *)(a1 + 60792) )
    {
      v12 = malloc(0x218ui64);
      if ( v12 )
      {
        v13 = malloc(0x10ui64);
        if ( v13 )
        {
          *(_QWORD *)v13 = a1;
          v13[2] = *(_DWORD *)(a1 + 62224);
          v12[65] = v13;
          v14 = v12;
          v12[66] = sub_1400B54B0;
          while ( v4 != -2147483386 )
          {
            v15 = *(_WORD *)((char *)v14 + (char *)FileName - (char *)v12);
            if ( !v15 )
              break;
            *v14++ = v15;
            if ( !--v4 )
            {
              --v14;
              break;
            }
          }
          *v14 = 0;
          LoadStringW(hInstance, 0x1FF6u, Buffer, 64);
          LoadStringW(hInstance, 0x2018u, v41, 64);
          sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"%s: %s", Buffer, v41);
          SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
          v16 = *(_QWORD *)(a1 + 62200);
          v17 = *(_DWORD *)(a1 + 7048);
          v18 = *(_QWORD *)(v16 + 8);
          TotalNumberOfBytes.LowPart = *(_DWORD *)(a1 + 62224);
          TotalNumberOfBytes.HighPart = v17;
          v39 = 1;
          v19 = sub_140017AD0(v16, v18, &TotalNumberOfBytes);
          v20 = *(_QWORD *)(a1 + 62208);
          if ( v20 == 0x1555555555555554i64 )
            sub_14002B5F8("list<T> too long");
          *(_QWORD *)(a1 + 62208) = v20 + 1;
          *(_QWORD *)(v16 + 8) = v19;
          **((_QWORD **)v19 + 1) = v19;
          Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400D6A50, v12, 0, ThreadId);
          CloseHandle(Thread);
          ++*(_DWORD *)(a1 + 62224);
        }
        else
        {
          free(v12);
        }
      }
    }
    else
    {
      SHGetFileInfoW(FileName, *(_DWORD *)v9, &psfi, 0x2B8u, 0x410u);
      SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)psfi.szTypeName);
    }
    if ( v9 != -20 )
      sub_1400835A0((const FILETIME *)(v9 + 20), v45, 256, *(_DWORD *)(a1 + 60960));
    LoadStringW(hInstance, 0x2015u, v46, 256);
    sub_140001000((wchar_t *)v48, 0x200ui64, L"%s: %s", v46, v45);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)v48);
    ExtensionW = PathFindExtensionW(FileName);
    if ( !ExtensionW )
      goto LABEL_46;
    v23 = ExtensionW + 1;
    if ( ExtensionW == (LPWSTR)-2i64 )
      goto LABEL_46;
    v24 = (LPCWSTR *)off_14012B9C0;
    while ( lstrcmpiW(v23, *v24) )
    {
      if ( (__int64)++v24 >= (__int64)aYes_0 )
        goto LABEL_46;
    }
    v25 = 24;
    v26 = GdipAlloc(24i64);
    if ( v26 )
    {
      *(_QWORD *)(v26 + 8) = 0i64;
      *(_QWORD *)v26 = &Gdiplus::Image::`vftable';
      *(_DWORD *)(v26 + 16) = GdipLoadImageFromFile(FileName);
    }
    else
    {
      v26 = 0i64;
    }
    v27 = *(_DWORD *)(v26 + 16);
    *(_DWORD *)(v26 + 16) = 0;
    if ( v27 )
    {
LABEL_45:
      (**(void (__fastcall ***)(__int64, __int64))v26)(v26, 1i64);
LABEL_46:
      if ( v11 != 16 && *(_DWORD *)(a1 + 60840) && *(_DWORD *)(a1 + 60756) )
      {
        v35 = 1i64;
        v36 = FileName;
      }
      else
      {
        v35 = 0i64;
        v36 = (WCHAR *)&unk_1400EC214;
      }
      return SendMessageW(*(HWND *)(a1 + 128), 0x8066u, (WPARAM)v36, v35);
    }
    v28 = sub_140017C00(v26);
    sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"Width: %u pixels", v28);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
    v29 = sub_140017BC0(v26);
    sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"Height: %u pixels", v29);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
    ImagePixelFormat = GdipGetImagePixelFormat(*(_QWORD *)(v26 + 8), ThreadId);
    if ( ImagePixelFormat )
      *(_DWORD *)(v26 + 16) = ImagePixelFormat;
    if ( (int)ThreadId[0] <= 397319 )
    {
      if ( ThreadId[0] != 397319 )
      {
        if ( (int)ThreadId[0] > 196865 )
        {
          if ( ThreadId[0] == 197634 )
          {
            v25 = 4;
            goto LABEL_40;
          }
          if ( ThreadId[0] == 198659 )
          {
            v25 = 8;
            goto LABEL_40;
          }
          goto LABEL_64;
        }
        if ( ThreadId[0] == 196865 )
        {
          v25 = 1;
          goto LABEL_40;
        }
        if ( (int)ThreadId[0] < 135173 )
        {
LABEL_64:
          v25 = 0;
          goto LABEL_40;
        }
        if ( (int)ThreadId[0] > 135174 )
        {
          if ( ThreadId[0] == 137224 )
          {
LABEL_40:
            sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"Bit depth: %u", v25);
            SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
            v31 = *(_QWORD *)(v26 + 8);
            ThreadId[0] = 0;
            ImageHorizontalResolution = GdipGetImageHorizontalResolution(v31, ThreadId);
            if ( ImageHorizontalResolution )
              *(_DWORD *)(v26 + 16) = ImageHorizontalResolution;
            sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"Horizontal resolution: %.0f dpi", ThreadId[0]);
            SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
            v33 = *(_QWORD *)(v26 + 8);
            ThreadId[0] = 0;
            ImageVerticalResolution = GdipGetImageVerticalResolution(v33, ThreadId);
            if ( ImageVerticalResolution )
              *(_DWORD *)(v26 + 16) = ImageVerticalResolution;
            sub_140001000((wchar_t *)lpFileSystemNameBuffer, 0x100ui64, L"Vertical resolution: %.0f dpi", ThreadId[0]);
            SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lpFileSystemNameBuffer);
            goto LABEL_45;
          }
          if ( ThreadId[0] == 139273 )
          {
LABEL_39:
            v25 = 32;
            goto LABEL_40;
          }
          goto LABEL_64;
        }
      }
LABEL_61:
      v25 = 16;
      goto LABEL_40;
    }
    if ( (int)ThreadId[0] > 1851406 )
    {
      if ( ThreadId[0] == 2498570 )
        goto LABEL_39;
      if ( ThreadId[0] != 3424269 )
        goto LABEL_64;
    }
    else if ( ThreadId[0] != 1851406 )
    {
      if ( ThreadId[0] == 925707 )
        goto LABEL_39;
      if ( ThreadId[0] != 1052676 )
      {
        if ( ThreadId[0] == 1060876 )
        {
          v25 = 48;
          goto LABEL_40;
        }
        goto LABEL_64;
      }
      goto LABEL_61;
    }
    v25 = 64;
    goto LABEL_40;
  }
  (*(void (__fastcall **)(__int64 *, _QWORD, WCHAR *))(v8 + 96))(v6, v3, FileName);
  result = PathIsRootW(FileName);
  if ( result )
  {
    if ( GetDiskFreeSpaceExW(FileName, 0i64, &TotalNumberOfBytes, (PULARGE_INTEGER)ThreadId) )
    {
      sub_140083DE0(*(__int64 *)ThreadId, (char *)Buffer, 0x20ui64, 0, 0);
      sub_140001000(v41, 0x40ui64, L"Free Space: %s", Buffer);
      SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)v41);
      sub_140083DE0(TotalNumberOfBytes.QuadPart, (char *)Buffer, 0x20ui64, 0, 0);
      sub_140001000(v41, 0x40ui64, L"Total Size: %s", Buffer);
      SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)v41);
    }
    result = GetVolumeInformationW(FileName, 0i64, 0, 0i64, 0i64, 0i64, (LPWSTR)lpFileSystemNameBuffer, 0x105u);
    if ( result )
    {
      sub_140001000(v41, 0x40ui64, L"File System: %s", lpFileSystemNameBuffer);
      return SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)v41);
    }
  }
  return result;
}
// 1400B7896: conditional instruction was optimized away because rdi.8!=0
// 1400E3D70: using guessed type __int64 __fastcall GdipGetImagePixelFormat(_QWORD, _QWORD);
// 1400E3D78: using guessed type __int64 __fastcall GdipGetImageHorizontalResolution(_QWORD, _QWORD);
// 1400E3D88: using guessed type __int64 __fastcall GdipLoadImageFromFile(_QWORD);
// 1400E3D98: using guessed type __int64 __fastcall GdipAlloc(_QWORD);
// 1400E3DA8: using guessed type __int64 __fastcall GdipGetImageVerticalResolution(_QWORD, _QWORD);
// 1400F3D58: using guessed type wchar_t aSS_7[7];
// 1400F3D68: using guessed type wchar_t aSS_8[7];
// 1400F3D78: using guessed type wchar_t aWidthUPixels[17];
// 1400F3DA0: using guessed type wchar_t aHeightUPixels[18];
// 1400F3DF0: using guessed type wchar_t aBitDepthU[14];
// 1400F3E10: using guessed type wchar_t aHorizontalReso[32];
// 1400F3E50: using guessed type wchar_t aVerticalResolu[30];
// 1400F3E90: using guessed type wchar_t aFreeSpaceS[15];
// 1400F3EB0: using guessed type wchar_t aTotalSizeS[15];
// 1400F3ED0: using guessed type wchar_t aFileSystemS[16];
// 1400F7468: using guessed type void *Gdiplus::Image::`vftable';
// 14012B9C0: using guessed type wchar_t *off_14012B9C0[10];
// 14012BA10: using guessed type wchar_t aYes_0[4];
// 1400B76E0: using guessed type wchar_t var_E70[264];
// 1400B76E0: using guessed type wchar_t var_440[512];

//----- (00000001400B7FB0) ----------------------------------------------------
void __fastcall sub_1400B7FB0(__int64 a1)
{
  HWND v2; // rcx
  WCHAR *v3; // rdi
  WCHAR *szTypeName; // r9
  DWORD nSize[2]; // [rsp+30h] [rbp-D0h] BYREF
  LPITEMIDLIST ppidl; // [rsp+38h] [rbp-C8h] BYREF
  struct _MEMORYSTATUSEX v7; // [rsp+40h] [rbp-C0h] BYREF
  SHFILEINFOW psfi; // [rsp+80h] [rbp-80h] BYREF
  CHAR MultiByteStr[64]; // [rsp+340h] [rbp+240h] BYREF
  WCHAR WideCharStr[64]; // [rsp+380h] [rbp+280h] BYREF
  WCHAR Buffer[512]; // [rsp+400h] [rbp+300h] BYREF
  char v12[528]; // [rsp+800h] [rbp+700h] BYREF
  __int16 lParam[264]; // [rsp+A10h] [rbp+910h] BYREF
  char v14[1024]; // [rsp+C20h] [rbp+B20h] BYREF

  v2 = *(HWND *)(a1 + 128);
  ppidl = 0i64;
  SendMessageW(v2, 0x8074u, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x8066u, (WPARAM)&unk_1400EC1C4, 0i64);
  (*(void (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    v12);
  v3 = (WCHAR *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  SHGetFolderLocation(0i64, 17, 0i64, 0, &ppidl);
  if ( (unsigned int)sub_14007DCB0((__int64)v3, (__int64)ppidl) )
  {
    nSize[0] = 512;
    GetComputerNameW(Buffer, nSize);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)Buffer);
    sub_140081EE0(MultiByteStr);
    MultiByteToWideChar(0, 0, MultiByteStr, -1, WideCharStr, 64);
    sub_140001000(Buffer, 0x200ui64, L"Processor: %s", WideCharStr);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)Buffer);
    v7.dwLength = 64;
    GlobalMemoryStatusEx(&v7);
    sub_140083DE0(v7.ullTotalPhys, v14, 0x200ui64, 0, 0);
    sub_140001000(Buffer, 0x200ui64, L"Memory: %s", v14);
    szTypeName = Buffer;
  }
  else
  {
    *(_QWORD *)nSize = 0i64;
    if ( (int)sub_14007F810((__int64)v12, (__int64)nSize) >= 0 )
      sub_14007E270(*(LPCITEMIDLIST *)nSize, (LPWSTR)lParam, 1u);
    CoTaskMemFree(*(LPVOID *)nSize);
    SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)lParam);
    SHGetFileInfoW(v3, 0, &psfi, 0x2B8u, 0x408u);
    szTypeName = psfi.szTypeName;
  }
  SendMessageW(*(HWND *)(a1 + 128), 0x8073u, 0i64, (LPARAM)szTypeName);
  CoTaskMemFree(v3);
}
// 1400F3D20: using guessed type wchar_t aProcessorS[14];
// 1400F3D40: using guessed type wchar_t aMemoryS[11];
// 1400B7FB0: using guessed type WCHAR lParam[264];

//----- (00000001400B8250) ----------------------------------------------------
void __fastcall sub_1400B8250(__int64 a1)
{
  int v2; // eax

  SendMessageW(*(HWND *)(a1 + 128), 0x8074u, 0i64, 0i64);
  v2 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 584i64))(*(_QWORD *)(a1 + 2640));
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      sub_1400B76E0(a1);
    }
    else if ( v2 > 1 )
    {
      sub_1400B74F0(a1);
    }
  }
  else
  {
    sub_1400B7FB0(a1);
  }
}

//----- (00000001400B82C0) ----------------------------------------------------
__int64 __fastcall sub_1400B82C0(__int64 a1)
{
  DWORD v2; // ebx
  int v3; // er14
  int v4; // eax
  int v5; // er12
  __int64 v6; // rbx
  wchar_t *v7; // r13
  wchar_t *v8; // rax
  bool v9; // zf
  wchar_t *v10; // r13
  __int64 v11; // rcx
  __int64 v12; // r8
  WCHAR *v13; // rcx
  WCHAR v14; // ax
  char *v15; // rcx
  __int16 v16; // ax
  ULARGE_INTEGER TotalNumberOfFreeBytes; // [rsp+38h] [rbp-D0h] BYREF
  ULARGE_INTEGER TotalNumberOfBytes; // [rsp+40h] [rbp-C8h] BYREF
  ULARGE_INTEGER FreeBytesAvailableToCaller; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v21[2]; // [rsp+50h] [rbp-B8h] BYREF
  WCHAR v22[32]; // [rsp+68h] [rbp-A0h] BYREF
  WCHAR Buffer[64]; // [rsp+A8h] [rbp-60h] BYREF
  __int16 lParam[64]; // [rsp+128h] [rbp+20h] BYREF
  char v25[128]; // [rsp+1A8h] [rbp+A0h] BYREF

  v2 = (*(__int64 (**)(void))(**(_QWORD **)(a1 + 2640) + 384i64))();
  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 392i64))(*(_QWORD *)(a1 + 2640));
  v4 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 400i64))(*(_QWORD *)(a1 + 2640));
  v5 = v4 + v3;
  TotalNumberOfFreeBytes.HighPart = 0;
  if ( v4 + v3 )
  {
    TotalNumberOfFreeBytes.LowPart = v4 + v3;
    v6 = 64i64;
    v7 = sub_1400831A0(TotalNumberOfFreeBytes.QuadPart);
    if ( v5 == 1 )
    {
      LoadStringW(hInstance, 0x1FEFu, Buffer, 64);
      sub_140001000((wchar_t *)lParam, 0x40ui64, L"%s %s", v7, Buffer);
    }
    else
    {
      LoadStringW(hInstance, 0x1FF0u, Buffer, 64);
      sub_140001000((wchar_t *)lParam, 0x40ui64, L"%s %s", v7, Buffer);
    }
  }
  else
  {
    TotalNumberOfFreeBytes.LowPart = v2;
    v8 = sub_1400831A0(TotalNumberOfFreeBytes.QuadPart);
    v9 = v2 == 1;
    v6 = 64i64;
    v10 = v8;
    if ( v9 )
    {
      LoadStringW(hInstance, 0x1FF1u, Buffer, 64);
      sub_140001000((wchar_t *)lParam, 0x40ui64, L"%s %s", v10, Buffer);
    }
    else
    {
      LoadStringW(hInstance, 0x1FF2u, Buffer, 64);
      sub_140001000((wchar_t *)lParam, 0x40ui64, L"%s %s", v10, Buffer);
    }
  }
  SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 0i64, (LPARAM)lParam);
  if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640)) )
  {
    LoadStringW(hInstance, 0x1FF3u, v22, 32);
    goto LABEL_21;
  }
  (*(void (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(a1 + 2640) + 408i64))(*(_QWORD *)(a1 + 2640), v21);
  if ( !v5 )
  {
    v11 = v21[0];
LABEL_20:
    sub_140083DE0(v11, (char *)v22, 0x20ui64, *(_DWORD *)(a1 + 60880), *(_DWORD *)(a1 + 60916));
    goto LABEL_21;
  }
  if ( v3 )
  {
    v11 = v21[1];
    goto LABEL_20;
  }
  v12 = 32i64;
  v13 = v22;
  while ( v12 != -2147483614 )
  {
    v14 = *(WCHAR *)((char *)v13 + &unk_1400EC19C - (_UNKNOWN *)v22);
    if ( !v14 )
      break;
    *v13++ = v14;
    if ( !--v12 )
    {
      *(v13 - 1) = 0;
      goto LABEL_21;
    }
  }
  *v13 = 0;
LABEL_21:
  SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 1ui64, (LPARAM)v22);
  if ( !GetDiskFreeSpaceExW(
          (LPCWSTR)(a1 + 4920),
          &FreeBytesAvailableToCaller,
          &TotalNumberOfBytes,
          &TotalNumberOfFreeBytes)
    || sub_1400B7390(v25, (__int64 *)&TotalNumberOfBytes, (__int64 *)&TotalNumberOfFreeBytes) == -1 )
  {
    v15 = v25;
    while ( v6 != -2147483582 )
    {
      v16 = *(_WORD *)&v15[&unk_1400EC1AC - (_UNKNOWN *)v25];
      if ( !v16 )
        break;
      *(_WORD *)v15 = v16;
      v15 += 2;
      if ( !--v6 )
      {
        v15 -= 2;
        break;
      }
    }
    *(_WORD *)v15 = 0;
  }
  SendMessageW(*(HWND *)(a1 + 112), 0x40Bu, 2ui64, (LPARAM)v25);
  return 0i64;
}
// 1400B84BD: conditional instruction was optimized away because r8.8!=0
// 1400B8596: conditional instruction was optimized away because rbx.8!=0
// 1400F3CE0: using guessed type wchar_t aSS_9[6];
// 1400F3CF0: using guessed type wchar_t aSS_10[6];
// 1400F3D00: using guessed type wchar_t aSS_11[6];
// 1400F3D10: using guessed type wchar_t aSS_12[6];
// 1400B82C0: using guessed type wchar_t lParam[64];
// 1400B82C0: using guessed type char var_B0[128];

//----- (00000001400B85E0) ----------------------------------------------------
__int64 __fastcall sub_1400B85E0(__int64 a1, __int64 a2)
{
  int v3; // er12
  _QWORD *v4; // rdi
  _QWORD *v5; // rbx
  LPCWSTR *v6; // r8
  LPCWSTR v7; // r9
  unsigned __int64 v8; // r10
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  signed __int64 v11; // r8
  WCHAR v12; // ax
  LPCWSTR *v13; // rcx
  const WCHAR *v14; // rcx
  bool v15; // cc
  int v16; // eax
  bool v17; // zf
  WPARAM v18; // rbx
  __int64 v19; // rdi
  int v20; // ebx
  LPCWSTR lpString1[3]; // [rsp+28h] [rbp-D8h] BYREF
  unsigned __int64 v23; // [rsp+40h] [rbp-C0h]
  int v24; // [rsp+48h] [rbp-B8h]
  WCHAR Buffer[264]; // [rsp+50h] [rbp-B0h] BYREF

  v3 = 0;
  if ( qword_14012DFC0 )
  {
    v4 = qword_14012DFB8;
    v5 = *(_QWORD **)qword_14012DFB8;
    if ( *(void **)qword_14012DFB8 != qword_14012DFB8 )
    {
      do
      {
        v23 = 7i64;
        lpString1[2] = 0i64;
        LOWORD(lpString1[0]) = 0;
        sub_140009610(lpString1, v5 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
        v6 = lpString1;
        v7 = lpString1[0];
        v8 = v23;
        if ( v23 >= 8 )
          v6 = (LPCWSTR *)lpString1[0];
        v9 = 260i64;
        v10 = Buffer;
        v11 = (char *)v6 - (char *)Buffer;
        while ( v9 != -2147483386 )
        {
          v12 = *(WCHAR *)((char *)v10 + v11);
          if ( !v12 )
            break;
          *v10++ = v12;
          if ( !--v9 )
          {
            --v10;
            break;
          }
        }
        *v10 = 0;
        v13 = lpString1;
        if ( v8 >= 8 )
          v13 = (LPCWSTR *)v7;
        if ( lstrcmpW((LPCWSTR)v13, L"..") )
        {
          v14 = (const WCHAR *)lpString1;
          if ( v23 >= 8 )
            v14 = lpString1[0];
          if ( !lstrcmpW(v14, L".") )
            GetCurrentDirectoryW(0x104u, Buffer);
        }
        else
        {
          GetCurrentDirectoryW(0x104u, Buffer);
          PathRemoveFileSpecW(Buffer);
        }
        if ( !(unsigned int)sub_1400974D0(a1, Buffer, 0i64, 0i64) )
          ++v3;
        if ( v23 >= 8 )
          j_free((void *)lpString1[0]);
        v5 = (_QWORD *)*v5;
      }
      while ( v5 != v4 );
LABEL_26:
      v15 = v3 <= 0;
      if ( v3 )
        goto LABEL_31;
    }
  }
  else if ( *(_DWORD *)(a1 + 60920) == 1 )
  {
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 40i64))(a2);
    goto LABEL_26;
  }
  v16 = sub_1400974D0(a1, (const WCHAR *)(a1 + 5960), 0i64, 0i64);
  v17 = v16 == 0;
  if ( v16 < 0 )
    v17 = (unsigned int)sub_1400974D0(a1, (const WCHAR *)(a1 + 5440), 0i64, 0i64) == 0;
  if ( !v17 )
    return 2147500037i64;
  v3 = 1;
  v15 = 0;
LABEL_31:
  if ( !v15 )
  {
    v18 = 0i64;
    v19 = (unsigned int)v3;
    do
    {
      LODWORD(lpString1[0]) = 8;
      SendMessageW(*(HWND *)(a1 + 136), 0x133Cu, v18, (LPARAM)lpString1);
      sub_1400B0710(a1, v24);
      ++v18;
      --v19;
    }
    while ( v19 );
  }
  if ( !*(_DWORD *)(a1 + 60776) && v3 == 1 )
    *(_DWORD *)(a1 + 60780) = 0;
  v20 = *(_DWORD *)(a1 + 7056);
  if ( v20 >= (int)SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) || v20 < 0 )
    *(_DWORD *)(a1 + 7056) = 0;
  SendMessageW(*(HWND *)(a1 + 136), 0x130Cu, *(int *)(a1 + 7056), 0i64);
  *(_DWORD *)(a1 + 7060) = *(_DWORD *)(a1 + 7056);
  sub_1400957D0(a1, 1);
  return 0i64;
}
// 1400B86C7: conditional instruction was optimized away because rdx.8!=0
// 14012DFC0: using guessed type __int64 qword_14012DFC0;

//----- (00000001400B88E0) ----------------------------------------------------
void __fastcall sub_1400B88E0(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 88));
  *(_BYTE *)(a1 + 128) = 1;
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 88));
}

//----- (00000001400B8920) ----------------------------------------------------
BOOL __fastcall sub_1400B8920(__int64 a1)
{
  __int64 v2; // rcx
  HWND v3; // rcx
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 152);
  if ( !_InterlockedDecrement((volatile signed __int32 *)(v2 + 8)) && v2 )
    (**(void (__fastcall ***)(__int64, __int64))v2)(v2, 1i64);
  v3 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 152) = 0i64;
  *(_WORD *)(a1 + 160) = 0;
  v4 = SendDlgItemMessageW(v3, 1152, 0x407u, 0i64, 0i64);
  SendDlgItemMessageW(*(HWND *)(a1 + 8), 1152, 0x402u, v4, 0i64);
  return SetDlgItemTextW(*(HWND *)(a1 + 8), 1, (LPCWSTR)(a1 + 162));
}

//----- (00000001400B89F0) ----------------------------------------------------
int __fastcall sub_1400B89F0(__int64 a1, int a2, WPARAM lParam)
{
  int v3; // edx
  int v5; // edx
  int v6; // edx
  __int64 v7; // rcx
  HWND v8; // rcx
  int result; // eax
  WCHAR Buffer[64]; // [rsp+40h] [rbp-98h] BYREF

  v3 = a2 - 32769;
  if ( !v3 )
    return SendDlgItemMessageW(*(HWND *)(a1 + 8), 1152, 0x406u, 0i64, lParam);
  v5 = v3 - 1;
  if ( !v5 )
    return SendDlgItemMessageW(*(HWND *)(a1 + 8), 1152, 0x402u, lParam, 0i64);
  v6 = v5 - 1;
  if ( !v6 )
    return sub_1400B8920(a1);
  if ( v6 == 1 )
  {
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0xFAu, Buffer, 64);
    MessageBoxW(*(HWND *)(a1 + 8), Buffer, L"Explorer++", 0x30u);
    v7 = *(_QWORD *)(a1 + 152);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v7 + 8)) )
    {
      if ( v7 )
        (**(void (__fastcall ***)(__int64, __int64))v7)(v7, 1i64);
    }
    v8 = *(HWND *)(a1 + 8);
    *(_QWORD *)(a1 + 152) = 0i64;
    *(_WORD *)(a1 + 160) = 0;
    return SetDlgItemTextW(v8, 1, (LPCWSTR)(a1 + 162));
  }
  return result;
}

//----- (00000001400B8B10) ----------------------------------------------------
__int64 __fastcall sub_1400B8B10(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 232));
  return 0i64;
}

//----- (00000001400B8B30) ----------------------------------------------------
__int64 __fastcall sub_1400B8B30(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400B8B50) ----------------------------------------------------
__int64 __fastcall sub_1400B8B50(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 240);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 240);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400B8BE0) ----------------------------------------------------
__int64 *sub_1400B8BE0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012F65C;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"MergeFiles" - (char *)&unk_14012F65C);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012F648 = 0;
  qword_14012F640 = (__int64)&CMergeFilesDialogPersistentSettings::`vftable';
  result = &qword_14012F640;
  byte_14012F85C = 1;
  return result;
}
// 1400B8C27: conditional instruction was optimized away because rdx.8!=0
// 1400F40F0: using guessed type wchar_t aMergefiles_0[11];
// 1400F7428: using guessed type void *CMergeFilesDialogPersistentSettings::`vftable';
// 14012F640: using guessed type __int64 qword_14012F640;
// 14012F648: using guessed type int dword_14012F648;
// 14012F85C: using guessed type char byte_14012F85C;

//----- (00000001400B8C60) ----------------------------------------------------
char **__fastcall sub_1400B8C60(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rsi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rsi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rsi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rsi
  __int64 v21; // rdx
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  char *v25; // r11
  __int64 v26; // rax
  __int64 v27; // rsi
  char *v28; // r11
  __int64 v29; // rax
  __int64 v30; // rsi
  __int64 v31; // rdx
  char *v32; // r11
  __int64 v33; // rax
  __int64 v34; // rsi
  char *v35; // r11
  __int64 v36; // rax
  __int64 v37; // rsi
  __int64 v38; // rdx
  char *v39; // r11
  __int64 v40; // rax
  __int64 v41; // rsi
  char *v42; // r11
  __int64 v43; // rax
  __int64 v44; // rsi
  char *v45; // r11
  __int64 v46; // rax
  __int64 v47; // rsi
  char *v48; // r11
  __int64 v49; // rax
  char **result; // rax
  _BYTE v51[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v51 = 1150;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_QWORD *)&v51[4] = 1i64;
  v6 = sub_140017AD0(v4, v5, v51);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1153i64;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v51[8] = 1;
  v9 = sub_140017AD0(v8, *(_QWORD *)(v8 + 8), v51);
  v10 = a3[1];
  if ( v10 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1054i64;
  a3[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a3;
  *(_DWORD *)&v51[8] = 1;
  v12 = sub_140017AD0(v11, *(_QWORD *)(v11 + 8), v51);
  v13 = a3[1];
  if ( v13 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1307i64;
  a3[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a3;
  *(_DWORD *)&v51[8] = 2;
  v15 = sub_140017AD0(v14, *(_QWORD *)(v14 + 8), v51);
  v16 = a3[1];
  if ( v16 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1151i64;
  a3[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a3;
  *(_DWORD *)&v51[8] = 2;
  v18 = sub_140017AD0(v17, *(_QWORD *)(v17 + 8), v51);
  v19 = a3[1];
  if ( v19 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v51 = 1151;
  a3[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *a3;
  *(_DWORD *)&v51[4] = 1;
  v21 = *(_QWORD *)(v20 + 8);
  *(_DWORD *)&v51[8] = 1;
  v22 = sub_140017AD0(v20, v21, v51);
  v23 = a3[1];
  if ( v23 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1154i64;
  a3[1] = v23 + 1;
  *(_QWORD *)(v20 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *a3;
  *(_DWORD *)&v51[8] = 0;
  v25 = sub_140017AD0(v24, *(_QWORD *)(v24 + 8), v51);
  v26 = a3[1];
  if ( v26 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1152i64;
  a3[1] = v26 + 1;
  *(_QWORD *)(v24 + 8) = v25;
  **((_QWORD **)v25 + 1) = v25;
  v27 = *a3;
  *(_DWORD *)&v51[8] = 2;
  v28 = sub_140017AD0(v27, *(_QWORD *)(v27 + 8), v51);
  v29 = a3[1];
  if ( v29 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v51 = 1152;
  a3[1] = v29 + 1;
  *(_QWORD *)(v27 + 8) = v28;
  **((_QWORD **)v28 + 1) = v28;
  v30 = *a3;
  *(_DWORD *)&v51[4] = 1;
  v31 = *(_QWORD *)(v30 + 8);
  *(_DWORD *)&v51[8] = 1;
  v32 = sub_140017AD0(v30, v31, v51);
  v33 = a3[1];
  if ( v33 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1308i64;
  a3[1] = v33 + 1;
  *(_QWORD *)(v30 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  v34 = *a3;
  *(_DWORD *)&v51[8] = 2;
  v35 = sub_140017AD0(v34, *(_QWORD *)(v34 + 8), v51);
  v36 = a3[1];
  if ( v36 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v51 = 1308;
  a3[1] = v36 + 1;
  *(_QWORD *)(v34 + 8) = v35;
  **((_QWORD **)v35 + 1) = v35;
  v37 = *a3;
  *(_DWORD *)&v51[4] = 1;
  v38 = *(_QWORD *)(v37 + 8);
  *(_DWORD *)&v51[8] = 1;
  v39 = sub_140017AD0(v37, v38, v51);
  v40 = a3[1];
  if ( v40 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1i64;
  a3[1] = v40 + 1;
  *(_QWORD *)(v37 + 8) = v39;
  **((_QWORD **)v39 + 1) = v39;
  v41 = *a3;
  *(_DWORD *)&v51[8] = 0;
  v42 = sub_140017AD0(v41, *(_QWORD *)(v41 + 8), v51);
  v43 = a3[1];
  if ( v43 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 2i64;
  a3[1] = v43 + 1;
  *(_QWORD *)(v41 + 8) = v42;
  **((_QWORD **)v42 + 1) = v42;
  v44 = *a3;
  *(_DWORD *)&v51[8] = 0;
  v45 = sub_140017AD0(v44, *(_QWORD *)(v44 + 8), v51);
  v46 = a3[1];
  if ( v46 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v51 = 1304i64;
  a3[1] = v46 + 1;
  *(_QWORD *)(v44 + 8) = v45;
  **((_QWORD **)v45 + 1) = v45;
  v47 = *a3;
  *(_DWORD *)&v51[8] = 0;
  v48 = sub_140017AD0(v47, *(_QWORD *)(v47 + 8), v51);
  v49 = a3[1];
  if ( 0x1555555555555554i64 == v49 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v49 + 1;
  *(_QWORD *)(v47 + 8) = v48;
  result = (char **)*((_QWORD *)v48 + 1);
  *result = v48;
  return result;
}

//----- (00000001400B9150) ----------------------------------------------------
_BOOL8 __fastcall sub_1400B9150(const WCHAR *a1, const WCHAR *a2)
{
  const WCHAR *v2; // rbx
  const WCHAR *v3; // rdi
  bool v4; // si

  v2 = a2;
  v3 = a1;
  if ( *((_QWORD *)a2 + 3) >= 8ui64 )
    a2 = *(const WCHAR **)a2;
  if ( *((_QWORD *)a1 + 3) >= 8ui64 )
    a1 = *(const WCHAR **)a1;
  v4 = StrCmpLogicalW(a1, a2) <= 0;
  if ( *((_QWORD *)v3 + 3) >= 8ui64 )
    j_free(*(void **)v3);
  *((_QWORD *)v3 + 3) = 7i64;
  *((_QWORD *)v3 + 2) = 0i64;
  *v3 = 0;
  if ( *((_QWORD *)v2 + 3) >= 8ui64 )
    j_free(*(void **)v2);
  *((_QWORD *)v2 + 3) = 7i64;
  *((_QWORD *)v2 + 2) = 0i64;
  *v2 = 0;
  return v4;
}

//----- (00000001400B91E0) ----------------------------------------------------
__int64 *sub_1400B91E0()
{
  if ( (dword_140130A3C & 1) == 0 )
  {
    dword_140130A3C |= 1u;
    sub_1400B8BE0();
    atexit(sub_1400E1FB0);
  }
  return &qword_14012F640;
}
// 14012F640: using guessed type __int64 qword_14012F640;
// 140130A3C: using guessed type int dword_140130A3C;

//----- (00000001400B9220) ----------------------------------------------------
void **__fastcall sub_1400B9220(__int64 a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // rcx
  void **result; // rax

  v2 = (struct _RTL_CRITICAL_SECTION *)(a1 + 88);
  v2[-3].SpinCount = (ULONG_PTR)&CMergeFiles::`vftable';
  DeleteCriticalSection(v2);
  sub_14000A630(a1 + 64);
  j_free(*(void **)(a1 + 64));
  if ( *(_QWORD *)(a1 + 48) >= 8ui64 )
    j_free(*(void **)(a1 + 24));
  *(_QWORD *)(a1 + 48) = 7i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_WORD *)(a1 + 24) = 0;
  result = &CReferenceCount::`vftable';
  *(_QWORD *)a1 = &CReferenceCount::`vftable';
  return result;
}
// 1400F7458: using guessed type void *CMergeFiles::`vftable';
// 1400F7C30: using guessed type void *CReferenceCount::`vftable';

//----- (00000001400B92A0) ----------------------------------------------------
void __fastcall sub_1400B92A0(__int64 a1)
{
  __int64 v2; // rsi
  __int64 v3; // rcx

  *(_QWORD *)a1 = &CMergeFilesDialog::`vftable';
  v2 = *(_QWORD *)(a1 + 152);
  if ( v2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(v2 + 88));
    *(_BYTE *)(v2 + 128) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(v2 + 88));
    v3 = *(_QWORD *)(a1 + 152);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v3 + 8)) )
    {
      if ( v3 )
        (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1i64);
    }
  }
  sub_14000A630(a1 + 120);
  j_free(*(void **)(a1 + 120));
  if ( *(_QWORD *)(a1 + 104) >= 8ui64 )
    j_free(*(void **)(a1 + 80));
  *(_QWORD *)(a1 + 104) = 7i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_WORD *)(a1 + 80) = 0;
  sub_140084540((_QWORD *)a1);
}
// 1400F73B8: using guessed type void *CMergeFilesDialog::`vftable';

//----- (00000001400B9370) ----------------------------------------------------
int __fastcall sub_1400B9370(__int64 a1)
{
  int v2; // er15
  char v3; // r12
  const WCHAR *v4; // rcx
  HANDLE FileW; // r14
  HWND v6; // rcx
  _QWORD *v8; // r13
  _QWORD *v9; // rbx
  const WCHAR *v10; // rcx
  HANDLE v11; // rax
  void *v12; // rsi
  void *v13; // rdi
  DWORD NumberOfBytesRead; // [rsp+40h] [rbp-78h] BYREF
  LARGE_INTEGER FileSize; // [rsp+48h] [rbp-70h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+50h] [rbp-68h] BYREF
  __int64 v17; // [rsp+58h] [rbp-60h]
  LPCWSTR lpFileName[3]; // [rsp+60h] [rbp-58h] BYREF
  unsigned __int64 v19; // [rsp+78h] [rbp-40h]

  v17 = -2i64;
  v2 = 1;
  v3 = 0;
  v4 = (const WCHAR *)(a1 + 24);
  if ( *((_QWORD *)v4 + 3) >= 8ui64 )
    v4 = *(const WCHAR **)v4;
  FileW = CreateFileW(v4, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
  v6 = *(HWND *)(a1 + 16);
  if ( FileW == (HANDLE)-1i64 )
    return PostMessageW(v6, 0x8004u, 0i64, 0i64);
  PostMessageW(v6, 0x8001u, *(_QWORD *)(a1 + 72), 0i64);
  v8 = *(_QWORD **)(a1 + 64);
  v9 = (_QWORD *)*v8;
  if ( (_QWORD *)*v8 != v8 )
  {
    while ( 1 )
    {
      v19 = 7i64;
      lpFileName[2] = 0i64;
      LOWORD(lpFileName[0]) = 0;
      sub_140009610(lpFileName, v9 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      if ( v3 )
        break;
      v10 = (const WCHAR *)lpFileName;
      if ( v19 >= 8 )
        v10 = lpFileName[0];
      v11 = CreateFileW(v10, 0x80000000, 1u, 0i64, 3u, 0, 0i64);
      v12 = v11;
      if ( v11 != (HANDLE)-1i64 )
      {
        GetFileSizeEx(v11, &FileSize);
        if ( FileSize.QuadPart )
        {
          v13 = operator new(FileSize.LowPart);
          ReadFile(v12, v13, FileSize.LowPart, &NumberOfBytesRead, 0i64);
          WriteFile(FileW, v13, NumberOfBytesRead, &NumberOfBytesWritten, 0i64);
          j_j_free(v13);
        }
        CloseHandle(v12);
        PostMessageW(*(HWND *)(a1 + 16), 0x8002u, v2++, 0i64);
        EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 88));
        if ( *(_BYTE *)(a1 + 128) )
          v3 = 1;
        LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 88));
      }
      if ( v19 >= 8 )
        j_free((void *)lpFileName[0]);
      v9 = (_QWORD *)*v9;
      if ( v9 == v8 )
        goto LABEL_21;
    }
    if ( v19 >= 8 )
      j_free((void *)lpFileName[0]);
  }
LABEL_21:
  CloseHandle(FileW);
  return SendMessageW(*(HWND *)(a1 + 16), 0x8003u, 0i64, 0i64);
}

//----- (00000001400B95F0) ----------------------------------------------------
__int64 __fastcall sub_1400B95F0(LPVOID lpThreadParameter)
{
  sub_1400B9370((__int64)lpThreadParameter);
  return 0i64;
}

//----- (00000001400B9730) ----------------------------------------------------
LRESULT __fastcall sub_1400B9730(__int64 a1, char a2)
{
  HWND DlgItem; // rbp
  LRESULT result; // rax
  int v6; // ebx
  int v7; // edi
  int v8; // eax
  _QWORD *i; // rcx
  __int64 v10; // r8
  int j; // eax
  __int64 v12; // r9

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1150);
  result = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v6 = result;
  if ( (_DWORD)result != -1 )
  {
    if ( a2 )
    {
      if ( !(_DWORD)result )
        return result;
      v7 = result - 1;
    }
    else
    {
      result = (unsigned int)(*(_DWORD *)(a1 + 128) - 1);
      if ( v6 == (_DWORD)result )
        return result;
      v7 = v6 + 1;
    }
    v8 = v6;
    for ( i = **(_QWORD ***)(a1 + 120); v8 > 0; --v8 )
      i = (_QWORD *)*i;
    if ( v8 < 0 )
    {
      v10 = (unsigned int)-v8;
      do
      {
        --v10;
        i = (_QWORD *)i[1];
      }
      while ( v10 );
    }
    for ( j = v7; j > 0; --j )
      i = (_QWORD *)*i;
    if ( j < 0 )
    {
      v12 = (unsigned int)-j;
      do
      {
        --v12;
        i = (_QWORD *)i[1];
      }
      while ( v12 );
    }
    sub_14000B0A0((__int64)i, **(_QWORD **)(a1 + 120));
    return sub_140080B70(DlgItem, v6, v7);
  }
  return result;
}

//----- (00000001400B9990) ----------------------------------------------------
void __fastcall sub_1400B9990(__int64 a1)
{
  __int64 v2; // rcx
  WCHAR *v3; // rdi
  bool v4; // zf
  int v5; // edi
  const WCHAR *v6; // r8
  LPCWSTR lpString[3]; // [rsp+28h] [rbp-170h] BYREF
  unsigned __int64 v8; // [rsp+40h] [rbp-158h]
  void *Block[3]; // [rsp+50h] [rbp-148h] BYREF
  unsigned __int64 v10; // [rsp+68h] [rbp-130h]
  WCHAR Buffer[128]; // [rsp+80h] [rbp-118h] BYREF

  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x1F48u, Buffer, 128);
  v8 = 7i64;
  lpString[2] = 0i64;
  LOWORD(lpString[0]) = 0;
  v10 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  v2 = -1i64;
  v3 = Buffer;
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  sub_1400099E0(Block, Buffer, -v2 - 2);
  v5 = sub_1400D35A0(*(HWND *)(a1 + 8), (__int64)Block, lpString);
  if ( v10 >= 8 )
    j_free(Block[0]);
  if ( v5 )
  {
    v6 = (const WCHAR *)lpString;
    if ( v8 >= 8 )
      v6 = lpString[0];
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1151, v6);
  }
  if ( v8 >= 8 )
    j_free((void *)lpString[0]);
}

//----- (00000001400B9AC0) ----------------------------------------------------
void __fastcall sub_1400B9AC0(__int64 a1)
{
  HWND DlgItem; // rdi
  void *v3; // r12
  __int64 **v4; // rbx
  __int64 v5; // rcx
  WCHAR *v6; // rdi
  bool v7; // zf
  __int64 v8; // rax
  HANDLE Thread; // rdi
  __int64 v10; // rbx
  __int16 Src[8]; // [rsp+40h] [rbp-388h] BYREF
  __int64 v12; // [rsp+50h] [rbp-378h]
  __int64 v13; // [rsp+58h] [rbp-370h]
  __int64 v14; // [rsp+68h] [rbp-360h]
  __int64 *v15; // [rsp+70h] [rbp-358h] BYREF
  WCHAR v16[64]; // [rsp+90h] [rbp-338h] BYREF
  WCHAR Buffer[64]; // [rsp+110h] [rbp-2B8h] BYREF
  WCHAR String[264]; // [rsp+190h] [rbp-238h] BYREF

  v14 = -2i64;
  if ( *(_BYTE *)(a1 + 160) )
  {
    *(_BYTE *)(a1 + 161) = 1;
    v10 = *(_QWORD *)(a1 + 152);
    if ( v10 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(v10 + 88));
      *(_BYTE *)(v10 + 128) = 1;
      LeaveCriticalSection((LPCRITICAL_SECTION)(v10 + 88));
    }
  }
  else
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1151);
    if ( GetWindowTextLengthW(DlgItem) )
    {
      GetWindowTextW(DlgItem, String, 260);
      v3 = operator new(0x88ui64);
      if ( v3 )
      {
        v4 = sub_14000B180(&v15, (_QWORD ***)(a1 + 120));
        v13 = 7i64;
        v12 = 0i64;
        Src[0] = 0;
        v5 = -1i64;
        v6 = String;
        do
        {
          if ( !v5 )
            break;
          v7 = *v6++ == 0;
          --v5;
        }
        while ( !v7 );
        sub_1400099E0(Src, String, -v5 - 2);
        v8 = sub_1400B9610(v3, *(_QWORD *)(a1 + 8), Src, v4);
      }
      else
      {
        v8 = 0i64;
      }
      *(_QWORD *)(a1 + 152) = v8;
      SendDlgItemMessageW(*(HWND *)(a1 + 8), 1152, 0x402u, 0i64, 0i64);
      GetDlgItemTextW(*(HWND *)(a1 + 8), 1, (LPWSTR)(a1 + 162), 32);
      LoadStringW(*(HINSTANCE *)(a1 + 16), 0x1F47u, v16, 64);
      SetDlgItemTextW(*(HWND *)(a1 + 8), 1, v16);
      *(_BYTE *)(a1 + 160) = 1;
      Thread = CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)sub_1400B95F0, *(LPVOID *)(a1 + 152), 0, 0i64);
      SetThreadPriority(Thread, -2);
      CloseHandle(Thread);
    }
    else
    {
      LoadStringW(*(HINSTANCE *)(a1 + 16), 0x1F46u, Buffer, 64);
      MessageBoxW(*(HWND *)(a1 + 8), Buffer, L"Explorer++", 0x30u);
    }
  }
}
// 1400B9610: using guessed type __int64 __fastcall sub_1400B9610(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400B9D20) ----------------------------------------------------
__int64 __fastcall sub_1400B9D20(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    sub_1400B9AC0(a1);
    return 0i64;
  }
  if ( a2 != 2 )
  {
    switch ( a2 )
    {
      case 1054:
        sub_1400B9730(a1, 0);
        return 0i64;
      case 1153:
        sub_1400B9730(a1, 1);
        return 0i64;
      case 1154:
        sub_1400B9990(a1);
        return 0i64;
    }
    return 0i64;
  }
  if ( *(_BYTE *)(a1 + 160) )
    *(_BYTE *)(a1 + 161) = 1;
  else
    EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400B9DB0) ----------------------------------------------------
__int64 __fastcall sub_1400B9DB0(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HICON IconW; // rax
  void (__fastcall ***v4)(_QWORD, __int64); // rsi
  __int64 v5; // rbx
  __int64 v6; // rcx
  __int64 v7; // rax
  int *v8; // rdi
  bool v9; // zf
  int *v10; // rbx
  int *v11; // rcx
  _QWORD *v12; // rax
  __int64 *v13; // rax
  _QWORD *v14; // r14
  _QWORD *v15; // rbx
  void **v16; // rcx
  void *v17; // r11
  unsigned __int64 v18; // r10
  void **v19; // rdx
  bool v20; // r13
  __int64 v21; // r12
  __int64 v22; // rax
  void (__fastcall ***v23)(_QWORD, __int64); // rdi
  _QWORD *v24; // rax
  __int64 v25; // rax
  int *v26; // rdi
  int *v27; // rbx
  int *v28; // rcx
  _QWORD *v29; // rax
  LPCWSTR *v30; // rbx
  const WCHAR *v31; // r8
  const WCHAR *v32; // rdx
  HWND DlgItem; // r12
  int v34; // er13
  _QWORD *v35; // r14
  _QWORD *i; // rbx
  void **v37; // r8
  __int64 v38; // rdx
  WCHAR *v39; // rcx
  signed __int64 v40; // r8
  WCHAR v41; // ax
  HWND v42; // rax
  HWND v43; // rax
  HWND v44; // rbx
  _DWORD *v45; // rdx
  HWND Parent; // rax
  int *v47; // rbx
  int *v48; // rcx
  _QWORD *v49; // rax
  __int64 v50; // rbx
  __int64 v51; // rax
  char v53; // [rsp+48h] [rbp-C0h]
  unsigned __int64 v54; // [rsp+50h] [rbp-B8h] BYREF
  int *v55; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v56[2]; // [rsp+60h] [rbp-A8h] BYREF
  struct std::locale::_Locimp *v57; // [rsp+70h] [rbp-98h]
  char v58[16]; // [rsp+78h] [rbp-90h] BYREF
  LPARAM v59; // [rsp+88h] [rbp-80h] BYREF
  const wchar_t *v60; // [rsp+90h] [rbp-78h]
  wchar_t *v61; // [rsp+98h] [rbp-70h]
  char *szTypeName; // [rsp+A0h] [rbp-68h]
  int v63; // [rsp+A8h] [rbp-60h]
  __int64 v64[2]; // [rsp+B0h] [rbp-58h] BYREF
  int v65; // [rsp+C0h] [rbp-48h]
  int v66; // [rsp+C4h] [rbp-44h]
  __int64 *v67; // [rsp+C8h] [rbp-40h]
  int v68; // [rsp+D0h] [rbp-38h]
  int v69; // [rsp+D4h] [rbp-34h]
  __int64 *v70; // [rsp+D8h] [rbp-30h]
  int v71; // [rsp+E0h] [rbp-28h]
  int v72; // [rsp+ECh] [rbp-1Ch]
  int lParam[4]; // [rsp+F8h] [rbp-10h] BYREF
  WCHAR *v74; // [rsp+108h] [rbp+0h]
  HIMAGELIST phimlSmall[3]; // [rsp+120h] [rbp+18h] BYREF
  _DWORD v76[6]; // [rsp+138h] [rbp+30h] BYREF
  WCHAR *v77; // [rsp+150h] [rbp+48h]
  int iIcon; // [rsp+15Ch] [rbp+54h]
  void *FileInformation[2]; // [rsp+188h] [rbp+80h] BYREF
  __int64 v80; // [rsp+198h] [rbp+90h] BYREF
  unsigned __int64 v81; // [rsp+1A0h] [rbp+98h]
  unsigned int v82; // [rsp+1A8h] [rbp+A0h]
  LPCWSTR pszFile[2]; // [rsp+1B0h] [rbp+A8h] BYREF
  LPCWSTR v84; // [rsp+1C0h] [rbp+B8h]
  unsigned __int64 v85; // [rsp+1C8h] [rbp+C0h]
  void *Block[2]; // [rsp+1D8h] [rbp+D0h] BYREF
  __int64 v87; // [rsp+1E8h] [rbp+E0h]
  unsigned __int64 v88; // [rsp+1F0h] [rbp+E8h]
  SHFILEINFOW psfi; // [rsp+208h] [rbp+100h] BYREF
  HICON v90; // [rsp+628h] [rbp+520h]
  HICON v91; // [rsp+638h] [rbp+530h]
  char *v92; // [rsp+640h] [rbp+538h]
  __int16 v93; // [rsp+650h] [rbp+548h]
  __int64 v94; // [rsp+668h] [rbp+560h]
  char v95; // [rsp+670h] [rbp+568h]
  WCHAR Buffer[32]; // [rsp+678h] [rbp+570h] BYREF
  char v97[64]; // [rsp+6B8h] [rbp+5B0h] BYREF
  char v98[64]; // [rsp+6F8h] [rbp+5F0h] BYREF
  WCHAR pszPath[264]; // [rsp+738h] [rbp+630h] BYREF
  WCHAR pszDest[264]; // [rsp+948h] [rbp+840h] BYREF

  phimlSmall[1] = (HIMAGELIST)-2i64;
  ModuleHandleW = GetModuleHandleW(0i64);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *(_QWORD *)(a1 + 232) = IconW;
  SetClassLongPtrW(*(HWND *)(a1 + 8), -34, (LONG_PTR)IconW);
  v4 = 0i64;
  v55 = 0i64;
  v56[0] = 0i64;
  v56[1] = 0i64;
  v57 = std::locale::_Init();
  v5 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)v58, 0);
  v6 = *(_QWORD *)(v5 + 8);
  if ( v6 != -1 )
    *(_QWORD *)(v5 + 8) = v6 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v58);
  v53 = 1;
  v59 = (LPARAM)L".*[\\.]?part[0-9]+";
  v60 = L".*[\\.]?part[0-9]+";
  v61 = L"";
  szTypeName = 0i64;
  v63 = 0;
  sub_140010150((__int64)v64, (__int64)v56, 0x100u);
  v70 = v56;
  v71 = 256;
  v72 = 142040571;
  sub_14000FDE0((__int64)&v59);
  v7 = sub_14000F6D0((__int64)&v59);
  v8 = (int *)v7;
  if ( v7 )
    ++*(_DWORD *)(v7 + 40);
  if ( v55 )
  {
    v9 = v55[10]-- == 1;
    if ( v9 )
    {
      v10 = v55;
      while ( v10 )
      {
        v11 = v10;
        v12 = v10 + 4;
        v10 = (int *)*((_QWORD *)v10 + 2);
        *v12 = 0i64;
        (**(void (__fastcall ***)(int *, __int64))v11)(v11, 1i64);
      }
    }
  }
  v55 = v8;
  v13 = (__int64 *)(a1 + 120);
  v14 = *(_QWORD **)(a1 + 120);
  v15 = (_QWORD *)*v14;
  if ( (_QWORD *)*v14 != v14 )
  {
    while ( 1 )
    {
      v81 = 7i64;
      v80 = 0i64;
      LOWORD(FileInformation[0]) = 0;
      sub_140009610(FileInformation, v15 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v16 = FileInformation;
      v17 = FileInformation[0];
      v18 = v81;
      if ( v81 >= 8 )
        v16 = (void **)FileInformation[0];
      v19 = FileInformation;
      if ( v81 >= 8 )
        v19 = (void **)FileInformation[0];
      if ( !v55 )
        break;
      sub_14000F760((__int64)&psfi, (__int64)v19, (__int64)v16 + 2 * v80, (__int64)v55, v55[9], v55[8], 16);
      v90 = v91;
      psfi.hIcon = v91;
      psfi.iIcon = 0;
      v95 = 1;
      v93 = 0;
      v20 = sub_140010B40((__int64 *)&psfi, v92, 0i64);
      v21 = v94;
      if ( v94 )
      {
        std::_Lockit::_Lockit((std::_Lockit *)&v54, 0);
        v22 = *(_QWORD *)(v21 + 8);
        if ( v22 && v22 != -1 )
          *(_QWORD *)(v21 + 8) = v22 - 1;
        v23 = 0i64;
        if ( !*(_QWORD *)(v21 + 8) )
          v23 = (void (__fastcall ***)(_QWORD, __int64))v21;
        std::_Lockit::~_Lockit((std::_Lockit *)&v54);
        if ( v23 )
          (**v23)(v23, 1i64);
      }
      if ( !v20 )
      {
        v18 = v81;
        v17 = FileInformation[0];
        break;
      }
      if ( v81 >= 8 )
        j_free(FileInformation[0]);
      v15 = (_QWORD *)*v15;
      if ( v15 == v14 )
        goto LABEL_31;
    }
    v53 = 0;
    if ( v18 >= 8 )
      j_free(v17);
LABEL_31:
    v13 = (__int64 *)(a1 + 120);
  }
  v85 = 7i64;
  v84 = 0i64;
  LOWORD(pszFile[0]) = 0;
  if ( v53 )
  {
    sub_140015570(v13);
    v59 = (LPARAM)L"[\\.]?part[0-9]+";
    v60 = L"[\\.]?part[0-9]+";
    v61 = L"";
    szTypeName = 0i64;
    v63 = 0;
    v24 = operator new(0x30ui64);
    if ( v24 )
    {
      v24[1] = 20i64;
      v24[2] = 0i64;
      v24[3] = 0i64;
      *v24 = &off_1400F7258;
      *((_DWORD *)v24 + 10) = 0;
    }
    else
    {
      v24 = 0i64;
    }
    v64[0] = (__int64)v24;
    v64[1] = (__int64)v24;
    v65 = 0;
    v66 = 256;
    v67 = v56;
    v68 = 256;
    v69 = 4;
    v70 = v56;
    v71 = 256;
    v72 = 142040571;
    sub_14000FDE0((__int64)&v59);
    v25 = sub_14000F6D0((__int64)&v59);
    v26 = (int *)v25;
    if ( v25 )
      ++*(_DWORD *)(v25 + 40);
    if ( v55 )
    {
      v9 = v55[10]-- == 1;
      if ( v9 )
      {
        v27 = v55;
        while ( v27 )
        {
          v28 = v27;
          v29 = v27 + 4;
          v27 = (int *)*((_QWORD *)v27 + 2);
          *v29 = 0i64;
          (**(void (__fastcall ***)(int *, __int64))v28)(v28, 1i64);
        }
      }
    }
    v55 = v26;
    v88 = 7i64;
    v87 = 0i64;
    LOWORD(Block[0]) = 0;
    sub_1400099E0(Block, &unk_1400EC5D4, 0i64);
    v30 = (LPCWSTR *)sub_140015890(
                       FileInformation,
                       (_QWORD *)(**(_QWORD **)(a1 + 120) + 16i64),
                       (__int64 *)&v55,
                       (__int16 *)Block);
    if ( pszFile != v30 )
    {
      if ( v85 >= 8 )
        j_free((void *)pszFile[0]);
      v85 = 7i64;
      v84 = 0i64;
      LOWORD(pszFile[0]) = 0;
      if ( (unsigned __int64)v30[3] >= 8 )
      {
        pszFile[0] = *v30;
        *v30 = 0i64;
      }
      else
      {
        memmove(pszFile, v30, 2i64 * ((_QWORD)v30[2] + 1));
      }
      v84 = v30[2];
      v85 = (unsigned __int64)v30[3];
      v30[3] = (LPCWSTR)7;
      v30[2] = 0i64;
      *(_WORD *)v30 = 0;
    }
    if ( v81 >= 8 )
      j_free(FileInformation[0]);
    v81 = 7i64;
    v80 = 0i64;
    LOWORD(FileInformation[0]) = 0;
    if ( v88 >= 8 )
      j_free(Block[0]);
  }
  else
  {
    sub_1400099E0(pszFile, L"output", 6ui64);
  }
  v31 = (const WCHAR *)pszFile;
  if ( v85 >= 8 )
    v31 = pszFile[0];
  v32 = (const WCHAR *)(a1 + 80);
  if ( *(_QWORD *)(a1 + 104) >= 8ui64 )
    v32 = *(const WCHAR **)v32;
  PathCombineW(pszDest, v32, v31);
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1151, pszDest);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1150);
  Shell_GetImageLists(0i64, phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1ui64, (LPARAM)phimlSmall[0]);
  SetWindowTheme(DlgItem, L"Explorer", 0i64);
  SendMessageW(DlgItem, 0x1036u, 0x10021ui64, 65569i64);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x1F43u, Buffer, 32);
  lParam[0] = 4;
  v74 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0i64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x862u, Buffer, 32);
  lParam[0] = 4;
  v74 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1ui64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x863u, Buffer, 32);
  lParam[0] = 4;
  v74 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2ui64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x864u, Buffer, 32);
  lParam[0] = 4;
  v74 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 3ui64, (LPARAM)lParam);
  v34 = 0;
  v35 = *(_QWORD **)(a1 + 120);
  for ( i = (_QWORD *)*v35; i != v35; i = (_QWORD *)*i )
  {
    v88 = 7i64;
    v87 = 0i64;
    LOWORD(Block[0]) = 0;
    sub_140009610(Block, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v37 = Block;
    if ( v88 >= 8 )
      v37 = (void **)Block[0];
    v38 = 260i64;
    v39 = pszPath;
    v40 = (char *)v37 - (char *)pszPath;
    while ( v38 != -2147483386 )
    {
      v41 = *(WCHAR *)((char *)v39 + v40);
      if ( !v41 )
        break;
      *v39++ = v41;
      if ( !--v38 )
      {
        --v39;
        break;
      }
    }
    *v39 = 0;
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x4400u);
    v76[0] = 3;
    v76[1] = v34;
    v76[2] = 0;
    v77 = pszPath;
    iIcon = psfi.iIcon;
    SendMessageW(DlgItem, 0x104Du, 0i64, (LPARAM)v76);
    LODWORD(v60) = 1;
    szTypeName = (char *)psfi.szTypeName;
    SendMessageW(DlgItem, 0x1074u, v34, (LPARAM)&v59);
    GetFileAttributesExW(pszPath, GetFileExInfoStandard, FileInformation);
    v54 = __PAIR64__(HIDWORD(v81), v82);
    sub_140083DE0(__SPAIR64__(HIDWORD(v81), v82), v97, 0x20ui64, 0, 0);
    LODWORD(v60) = 2;
    szTypeName = v97;
    SendMessageW(DlgItem, 0x1074u, v34, (LPARAM)&v59);
    sub_1400835A0((const FILETIME *)((char *)&v80 + 4), v98, 32, *(_DWORD *)(a1 + 144));
    LODWORD(v60) = 3;
    szTypeName = v98;
    SendMessageW(DlgItem, 0x1074u, v34++, (LPARAM)&v59);
    if ( v88 >= 8 )
      j_free(Block[0]);
  }
  SendMessageW(DlgItem, 0x101Eu, 0i64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 1ui64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 2ui64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 3ui64, 65534i64);
  v42 = GetDlgItem(*(HWND *)(a1 + 8), 1151);
  SendMessageW(v42, 0xB1u, 0i64, -1i64);
  v43 = GetDlgItem(*(HWND *)(a1 + 8), 1151);
  SetFocus(v43);
  v44 = *(HWND *)(a1 + 8);
  v45 = *(_DWORD **)(a1 + 240);
  if ( v45[2] )
  {
    SetWindowPos(v44, 0i64, v45[3], v45[4], v45[5], v45[6], 4u);
  }
  else
  {
    Parent = GetParent(v44);
    sub_140081E00(Parent, v44);
  }
  if ( v85 >= 8 )
    j_free((void *)pszFile[0]);
  v85 = 7i64;
  v84 = 0i64;
  LOWORD(pszFile[0]) = 0;
  if ( v55 )
  {
    v9 = v55[10]-- == 1;
    if ( v9 )
    {
      v47 = v55;
      while ( v47 )
      {
        v48 = v47;
        v49 = v47 + 4;
        v47 = (int *)*((_QWORD *)v47 + 2);
        *v49 = 0i64;
        (**(void (__fastcall ***)(int *, __int64))v48)(v48, 1i64);
      }
    }
  }
  v55 = 0i64;
  v50 = (__int64)v57;
  if ( v57 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v54, 0);
    v51 = *(_QWORD *)(v50 + 8);
    if ( v51 && v51 != -1 )
      *(_QWORD *)(v50 + 8) = v51 - 1;
    if ( !*(_QWORD *)(v50 + 8) )
      v4 = (void (__fastcall ***)(_QWORD, __int64))v50;
    std::_Lockit::~_Lockit((std::_Lockit *)&v54);
    if ( v4 )
      (**v4)(v4, 1i64);
  }
  return 0i64;
}
// 1400BA567: conditional instruction was optimized away because rdx.8!=0
// 1400F4108: using guessed type wchar_t aPart09[18];
// 1400F4130: using guessed type wchar_t aPart09_0[16];
// 1400F4150: using guessed type wchar_t aOutput[7];
// 1400F7258: using guessed type __int64 (__fastcall *off_1400F7258)();
// 1400B9DB0: using guessed type _DWORD lParam[4];

//----- (00000001400BA8B0) ----------------------------------------------------
int __fastcall sub_1400BA8B0(__int64 a1, const WCHAR *a2, __int64 a3)
{
  int result; // eax

  if ( lstrcmpiW(a2, L"ColumnWidth1") )
  {
    result = lstrcmpiW(a2, L"ColumnWidth2");
    if ( !result )
    {
      result = sub_14004B61C(a3);
      *(_DWORD *)(a1 + 548) = result;
    }
  }
  else
  {
    result = sub_14004B61C(a3);
    *(_DWORD *)(a1 + 544) = result;
  }
  return result;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (00000001400BA940) ----------------------------------------------------
LSTATUS __fastcall sub_1400BA940(__int64 a1, HKEY a2)
{
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF

  cbData = 4;
  RegQueryValueExW(a2, L"ColumnWidth1", 0i64, 0i64, (LPBYTE)(a1 + 544), &cbData);
  cbData = 4;
  return RegQueryValueExW(a2, L"ColumnWidth2", 0i64, 0i64, (LPBYTE)(a1 + 548), &cbData);
}

//----- (00000001400BA9D0) ----------------------------------------------------
LSTATUS __fastcall sub_1400BA9D0(__int64 a1, HKEY a2)
{
  int Data; // [rsp+40h] [rbp+8h] BYREF

  Data = *(_DWORD *)(a1 + 544);
  RegSetValueExW(a2, L"ColumnWidth1", 0, 4u, (const BYTE *)&Data, 4u);
  Data = *(_DWORD *)(a1 + 548);
  return RegSetValueExW(a2, L"ColumnWidth2", 0, 4u, (const BYTE *)&Data, 4u);
}

//----- (00000001400BAAA0) ----------------------------------------------------
__int64 __fastcall sub_1400BAAA0(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 112));
  DestroyIcon(*(HICON *)(a1 + 104));
  return 0i64;
}

//----- (00000001400BAAD0) ----------------------------------------------------
__int64 __fastcall sub_1400BAAD0(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400BAAF0) ----------------------------------------------------
HRESULT __fastcall sub_1400BAAF0(__int64 a1, __int64 *a2, __int64 a3)
{
  itow_s(*(_DWORD *)(a1 + 544), Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"ColumnWidth1", Buffer);
  itow_s(*(_DWORD *)(a1 + 548), Buffer, 0x40ui64, 10);
  return sub_14007BEA0(a2, a3, L"ColumnWidth2", Buffer);
}
// 1400F43A8: using guessed type wchar_t aColumnwidth1_6[13];
// 1400F43C8: using guessed type wchar_t aColumnwidth2_6[13];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (00000001400BAB90) ----------------------------------------------------
__int64 __fastcall sub_1400BAB90(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  HWND DlgItem; // rbx
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 128);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1094);
  *(_DWORD *)(*(_QWORD *)(a1 + 128) + 544i64) = SendMessageW(DlgItem, 0x101Du, 0i64, 0i64);
  *(_DWORD *)(*(_QWORD *)(a1 + 128) + 548i64) = SendMessageW(DlgItem, 0x101Du, 1ui64, 0i64);
  result = *(_QWORD *)(a1 + 128);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400BAC70) ----------------------------------------------------
__int64 *sub_1400BAC70()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012F87C;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"MassRename" - (char *)&unk_14012F87C);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012F868 = 0;
  qword_14012F860 = (__int64)&CMassRenameDialogPersistentSettings::`vftable';
  byte_14012FA7C = 1;
  dword_14012FA80 = 250;
  result = &qword_14012F860;
  dword_14012FA84 = 250;
  return result;
}
// 1400BACB7: conditional instruction was optimized away because rdx.8!=0
// 1400F42A8: using guessed type wchar_t aMassrename_0[11];
// 1400F7358: using guessed type void *CMassRenameDialogPersistentSettings::`vftable';
// 14012F860: using guessed type __int64 qword_14012F860;
// 14012F868: using guessed type int dword_14012F868;
// 14012FA7C: using guessed type char byte_14012FA7C;
// 14012FA80: using guessed type int dword_14012FA80;
// 14012FA84: using guessed type int dword_14012FA84;

//----- (00000001400BAD00) ----------------------------------------------------
char **__fastcall sub_1400BAD00(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rdi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rdi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rdi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rdi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rdi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rdi
  char *v21; // r11
  __int64 v22; // rax
  char **result; // rax
  _BYTE v24[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v24 = 1095;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_DWORD *)&v24[4] = 1;
  *(_DWORD *)&v24[8] = 1;
  v6 = sub_140017AD0(v4, v5, v24);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v24 = 1219i64;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v24[8] = 1;
  v9 = sub_140017AD0(v8, *(_QWORD *)(v8 + 8), v24);
  v10 = a3[1];
  if ( v10 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v24 = 1094;
  a3[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a3;
  *(_QWORD *)&v24[4] = 1i64;
  v12 = sub_140017AD0(v11, *(_QWORD *)(v11 + 8), v24);
  v13 = a3[1];
  if ( v13 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v24 = 1i64;
  a3[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a3;
  *(_DWORD *)&v24[8] = 0;
  v15 = sub_140017AD0(v14, *(_QWORD *)(v14 + 8), v24);
  v16 = a3[1];
  if ( v16 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v24 = 2i64;
  a3[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a3;
  *(_DWORD *)&v24[8] = 0;
  v18 = sub_140017AD0(v17, *(_QWORD *)(v17 + 8), v24);
  v19 = a3[1];
  if ( v19 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v24 = 1304i64;
  a3[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *a3;
  *(_DWORD *)&v24[8] = 0;
  v21 = sub_140017AD0(v20, *(_QWORD *)(v20 + 8), v24);
  v22 = a3[1];
  if ( 0x1555555555555554i64 == v22 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v22 + 1;
  *(_QWORD *)(v20 + 8) = v21;
  result = (char **)*((_QWORD *)v21 + 1);
  *result = v21;
  return result;
}

//----- (00000001400BAF50) ----------------------------------------------------
__int64 *sub_1400BAF50()
{
  if ( (dword_140130A40 & 1) == 0 )
  {
    dword_140130A40 |= 1u;
    sub_1400BAC70();
    atexit(sub_1400E1FA0);
  }
  return &qword_14012F860;
}
// 14012F860: using guessed type __int64 qword_14012F860;
// 140130A40: using guessed type int dword_140130A40;

//----- (00000001400BAF90) ----------------------------------------------------
void __fastcall sub_1400BAF90(__int64 a1)
{
  __int64 v2; // rcx

  v2 = a1 + 80;
  *(_QWORD *)(v2 - 80) = &CMassRenameDialog::`vftable';
  sub_14000A630(v2);
  j_free(*(void **)(a1 + 80));
  sub_140084540((_QWORD *)a1);
}
// 1400F72E8: using guessed type void *CMassRenameDialog::`vftable';

//----- (00000001400BAFE0) ----------------------------------------------------
__int64 __fastcall sub_1400BAFE0(__int64 a1)
{
  __int64 v2; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  __int64 v5; // rax
  HWND v6; // rcx
  __int64 lParam; // rax
  HWND v8; // rcx
  HWND DlgItem; // r12
  LONG WindowLongW; // eax
  _QWORD *v11; // rdi
  _QWORD *v12; // rbx
  int i; // esi
  const WCHAR *v14; // rcx
  LPCWSTR *v15; // r11
  __int64 v16; // rdx
  signed __int64 v17; // r11
  WCHAR *v18; // rcx
  WCHAR v19; // ax
  HWND v20; // rax
  HWND v21; // rax
  _DWORD *v22; // rdx
  HWND v23; // rbx
  HWND Parent; // rax
  HIMAGELIST phimlSmall; // [rsp+40h] [rbp-C0h] BYREF
  int v27; // [rsp+50h] [rbp-B0h] BYREF
  int v28; // [rsp+54h] [rbp-ACh]
  int v29; // [rsp+58h] [rbp-A8h]
  WCHAR *v30; // [rsp+68h] [rbp-98h]
  int iIcon; // [rsp+74h] [rbp-8Ch]
  int v32[4]; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR *v33; // [rsp+B0h] [rbp-50h]
  LPCWSTR pszPath[3]; // [rsp+C8h] [rbp-38h] BYREF
  unsigned __int64 v35; // [rsp+E0h] [rbp-20h]
  struct tagRECT Rect; // [rsp+F0h] [rbp-10h] BYREF
  SHFILEINFOW psfi; // [rsp+100h] [rbp+0h] BYREF
  WCHAR Buffer[64]; // [rsp+3C0h] [rbp+2C0h] BYREF
  WCHAR v39[264]; // [rsp+440h] [rbp+340h] BYREF

  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  v5 = sub_14000A470(v2, 0x18u, 0);
  v6 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 104) = v5;
  SetClassLongPtrW(v6, -34, v5);
  lParam = sub_14000A470(v2, 0x16u, 0);
  v8 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 112) = lParam;
  SendDlgItemMessageW(v8, 1219, 0xF7u, 1ui64, lParam);
  DeleteObject(BitmapW);
  sub_14000A390(v2);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1094);
  WindowLongW = GetWindowLongW(DlgItem, -16);
  SetWindowLongPtrW(DlgItem, -16, WindowLongW | 0x40i64);
  SetWindowTheme(DlgItem, L"Explorer", 0i64);
  SendMessageW(DlgItem, 0x1036u, 0x10023ui64, 65571i64);
  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1ui64, (LPARAM)phimlSmall);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x853u, Buffer, 64);
  v32[0] = 4;
  v33 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1ui64, (LPARAM)v32);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x854u, Buffer, 64);
  v33 = Buffer;
  v32[0] = 4;
  SendMessageW(DlgItem, 0x1061u, 2ui64, (LPARAM)v32);
  GetClientRect(DlgItem, &Rect);
  SendMessageW(DlgItem, 0x101Eu, 0i64, *(int *)(*(_QWORD *)(a1 + 128) + 544i64));
  SendMessageW(DlgItem, 0x101Eu, 1ui64, *(int *)(*(_QWORD *)(a1 + 128) + 548i64));
  v11 = *(_QWORD **)(a1 + 80);
  v12 = (_QWORD *)*v11;
  for ( i = 0; v12 != v11; v12 = (_QWORD *)*v12 )
  {
    v35 = 7i64;
    pszPath[2] = 0i64;
    LOWORD(pszPath[0]) = 0;
    sub_140009610(pszPath, v12 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v14 = (const WCHAR *)pszPath;
    if ( v35 >= 8 )
      v14 = pszPath[0];
    SHGetFileInfoW(v14, 0, &psfi, 0x2B8u, 0x4000u);
    v15 = pszPath;
    if ( v35 >= 8 )
      v15 = (LPCWSTR *)pszPath[0];
    v16 = 260i64;
    v17 = (char *)v15 - (char *)v39;
    v18 = v39;
    while ( v16 != -2147483386 )
    {
      v19 = *(WCHAR *)((char *)v18 + v17);
      if ( !v19 )
        break;
      *v18++ = v19;
      if ( !--v16 )
      {
        --v18;
        break;
      }
    }
    *v18 = 0;
    PathStripPathW(v39);
    iIcon = psfi.iIcon;
    v27 = 3;
    v30 = v39;
    v28 = i;
    v29 = 0;
    SendMessageW(DlgItem, 0x104Du, 0i64, (LPARAM)&v27);
    v30 = v39;
    v27 = 1;
    v28 = i;
    v29 = 1;
    SendMessageW(DlgItem, 0x104Cu, 0i64, (LPARAM)&v27);
    ++i;
    if ( v35 >= 8 )
      j_free((void *)pszPath[0]);
  }
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1095, L"/F");
  v20 = GetDlgItem(*(HWND *)(a1 + 8), 1095);
  SendMessageW(v20, 0xB1u, 0i64, -1i64);
  v21 = GetDlgItem(*(HWND *)(a1 + 8), 1095);
  SetFocus(v21);
  v22 = *(_DWORD **)(a1 + 128);
  v23 = *(HWND *)(a1 + 8);
  if ( v22[2] )
  {
    SetWindowPos(v23, 0i64, v22[3], v22[4], v22[5], v22[6], 4u);
  }
  else
  {
    Parent = GetParent(v23);
    sub_140081E00(Parent, v23);
  }
  return 0i64;
}
// 1400BB2D8: conditional instruction was optimized away because rdx.8!=0
// 1400BAFE0: using guessed type _DWORD var_5E0[4];

//----- (00000001400BB450) ----------------------------------------------------
__int64 __fastcall sub_1400BB450(__int64 a1, __int64 a2, void **a3, __int64 a4)
{
  __int64 **v7; // r13
  _QWORD *v8; // rdi
  _QWORD *v9; // rbx

  *(_QWORD *)(a1 + 16) = hInstance;
  *(_DWORD *)(a1 + 24) = 175;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 52) = 1;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CMassRenameDialog::`vftable';
  v7 = (__int64 **)(a1 + 80);
  sub_14000A5B0((_QWORD *)(a1 + 80));
  if ( v7 != (__int64 **)a3 )
  {
    v8 = *a3;
    v9 = *(_QWORD **)*a3;
    sub_14000A630((__int64)v7);
    sub_14000A6B0((__int64)v7, **v7, v9, v8);
  }
  *(_QWORD *)(a1 + 120) = a4;
  if ( (dword_140130A40 & 1) == 0 )
  {
    dword_140130A40 |= 1u;
    sub_1400BAC70();
    atexit(sub_1400E1FA0);
  }
  *(_QWORD *)(a1 + 128) = &qword_14012F860;
  sub_14000A630((__int64)a3);
  j_free(*a3);
  return a1;
}
// 1400F72E8: using guessed type void *CMassRenameDialog::`vftable';
// 14012F860: using guessed type __int64 qword_14012F860;
// 140130A40: using guessed type int dword_140130A40;

//----- (00000001400BB540) ----------------------------------------------------
void __fastcall sub_1400BB540(_QWORD *a1, const WCHAR *a2, __int64 a3, __int64 *a4)
{
  int v7; // er13
  const WCHAR *v8; // rdi
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  signed __int64 v11; // rdi
  WCHAR v12; // ax
  const WCHAR *v13; // rcx
  __int64 v14; // rdi
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // r12
  bool v18; // zf
  __int64 v19; // rdi
  void (__fastcall ***v20)(_QWORD, __int64); // rcx
  _QWORD *v21; // rax
  char v22; // r14
  unsigned __int64 v23; // rax
  unsigned __int16 *v24; // rcx
  __int64 v25; // rdx
  char v26; // al
  __int64 *v27; // rdi
  __int64 v28; // r12
  __int64 *v29; // rax
  __int64 v30; // rdx
  __int64 v31; // rax
  _QWORD *v32; // r9
  __int64 *v33; // rcx
  __int64 v34; // r8
  __int64 *v35; // rax
  __int64 v36; // rax
  WCHAR *v37; // rsi
  __int64 i; // r15
  __int64 j; // r11
  __int64 v40; // rcx
  WCHAR *v41; // rdi
  __int64 v42; // r11
  char *v43; // r15
  __int64 v44; // rcx
  char *v45; // rdi
  __int64 v46; // rdi
  void (__fastcall ***v47)(_QWORD, __int64); // rcx
  _QWORD *v48; // rax
  char v49[4]; // [rsp+34h] [rbp-CCh] BYREF
  __int64 v50; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v51[2]; // [rsp+40h] [rbp-C0h] BYREF
  struct std::locale::_Locimp *v52; // [rsp+50h] [rbp-B0h] BYREF
  __int64 *v53; // [rsp+58h] [rbp-A8h]
  _QWORD *v54; // [rsp+60h] [rbp-A0h]
  const wchar_t *v55; // [rsp+70h] [rbp-90h] BYREF
  void *v56; // [rsp+78h] [rbp-88h]
  wchar_t *v57; // [rsp+80h] [rbp-80h]
  __int64 v58; // [rsp+88h] [rbp-78h]
  int v59; // [rsp+90h] [rbp-70h]
  __int64 v60[2]; // [rsp+98h] [rbp-68h] BYREF
  char v61; // [rsp+A8h] [rbp-58h]
  __int64 v62; // [rsp+B0h] [rbp-50h]
  __int64 v63; // [rsp+B8h] [rbp-48h]
  __int64 *v64; // [rsp+C0h] [rbp-40h]
  __int64 v65; // [rsp+C8h] [rbp-38h] BYREF
  __int64 v66; // [rsp+D0h] [rbp-30h]
  char v67; // [rsp+D8h] [rbp-28h]
  LPWSTR ExtensionW; // [rsp+E0h] [rbp-20h]
  const WCHAR *v69; // [rsp+E8h] [rbp-18h]
  __int64 v70[2]; // [rsp+F0h] [rbp-10h] BYREF
  int *v71; // [rsp+100h] [rbp+0h] BYREF
  __int64 v72[15]; // [rsp+108h] [rbp+8h] BYREF
  int v73; // [rsp+180h] [rbp+80h]
  __int64 v74[2]; // [rsp+188h] [rbp+88h] BYREF
  int v75; // [rsp+198h] [rbp+98h]
  __int64 *v76; // [rsp+1D0h] [rbp+D0h]
  __int64 v77; // [rsp+1D8h] [rbp+D8h]
  __int16 v78; // [rsp+1E0h] [rbp+E0h]
  __int64 v79; // [rsp+1F0h] [rbp+F0h]
  char v80[16]; // [rsp+1F8h] [rbp+F8h] BYREF
  _QWORD *v81; // [rsp+208h] [rbp+108h]
  const WCHAR *v82; // [rsp+210h] [rbp+110h]
  void *Block[5]; // [rsp+218h] [rbp+118h] BYREF
  WCHAR pszPath[268]; // [rsp+240h] [rbp+140h] BYREF

  v79 = -2i64;
  v69 = a2;
  v54 = a1;
  v81 = a1;
  v82 = a2;
  v7 = 0;
  LODWORD(v53) = 0;
  if ( *((_QWORD *)a2 + 3) < 8ui64 )
    v8 = a2;
  else
    v8 = *(const WCHAR **)a2;
  v9 = 260i64;
  v10 = pszPath;
  v11 = (char *)v8 - (char *)pszPath;
  while ( v9 != -2147483386 )
  {
    v12 = *(WCHAR *)((char *)v10 + v11);
    if ( !v12 )
      break;
    *v10++ = v12;
    if ( !--v9 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  PathRemoveExtensionW(pszPath);
  if ( *((_QWORD *)a2 + 3) < 8ui64 )
    v13 = a2;
  else
    v13 = *(const WCHAR **)a2;
  ExtensionW = PathFindExtensionW(v13);
  sub_140009610(a4, a1, 0i64, 0xFFFFFFFFFFFFFFFFui64);
  v50 = 0i64;
  v51[0] = 0i64;
  v51[1] = 0i64;
  v52 = std::locale::_Init();
  v14 = sub_14002BB90();
  std::_Lockit::_Lockit((std::_Lockit *)v49, 0);
  v15 = *(_QWORD *)(v14 + 8);
  if ( v15 != -1 )
    *(_QWORD *)(v14 + 8) = v15 + 1;
  std::_Lockit::~_Lockit((std::_Lockit *)v49);
  v55 = L"/[0]*N";
  v56 = L"/[0]*N";
  v57 = L"";
  v58 = 0i64;
  v59 = 0;
  sub_140010150((__int64)v60, (__int64)v51, 1u);
  v64 = v51;
  LODWORD(v65) = 1;
  HIDWORD(v66) = 142040571;
  sub_14000FDE0((__int64)&v55);
  v16 = sub_14000F6D0((__int64)&v55);
  v17 = v16;
  if ( v16 )
    ++*(_DWORD *)(v16 + 40);
  if ( v50 )
  {
    v18 = (*(_DWORD *)(v50 + 40))-- == 1;
    if ( v18 )
    {
      v19 = v50;
      while ( v19 )
      {
        v20 = (void (__fastcall ***)(_QWORD, __int64))v19;
        v21 = (_QWORD *)(v19 + 16);
        v19 = *(_QWORD *)(v19 + 16);
        *v21 = 0i64;
        (**v20)(v20, 1i64);
      }
    }
  }
  v50 = v17;
  v22 = 0;
  do
  {
    v55 = 0i64;
    v56 = 0i64;
    v57 = 0i64;
    v58 = 0i64;
    v60[0] = 0i64;
    v60[1] = 0i64;
    v61 = 0;
    v62 = 0i64;
    v63 = 0i64;
    LOBYTE(v64) = 0;
    v65 = 0i64;
    v66 = 0i64;
    v67 = 0;
    v23 = a4[3];
    if ( v23 < 8 )
      v24 = (unsigned __int16 *)a4;
    else
      v24 = (unsigned __int16 *)*a4;
    if ( v23 < 8 )
      v25 = (__int64)a4;
    else
      v25 = *a4;
    v26 = sub_14000F450(v24, (unsigned __int16 *)(v25 + 2 * a4[2]), &v55, &v50, (__int64)v24);
    v27 = (__int64 *)v56;
    if ( v26 )
    {
      v70[0] = (__int64)&unk_1400F7230;
      v71 = (int *)&unk_1400F7238;
      v7 |= 1u;
      LODWORD(v53) = v7;
      v74[0] = (__int64)&std::wistream::`vftable';
      v70[1] = 0i64;
      sub_140008270((__int64)v74);
      v76 = v72;
      v77 = 0i64;
      v78 = sub_1400056C0((__int64)v74);
      if ( !v76 )
        sub_140009260((__int64)v74, v75 | 4, 0);
      *(__int64 *)((char *)&v72[-1] + v71[1]) = (__int64)&std::wostream::`vftable';
      *(__int64 *)((char *)v70 + *(int *)(v70[0] + 4)) = (__int64)&std::wiostream::`vftable';
      *(__int64 *)((char *)v70 + *(int *)(v70[0] + 4)) = (__int64)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
      sub_140003840(v72);
      v72[0] = (__int64)&std::wstringbuf::`vftable';
      v72[14] = 0i64;
      v73 = 0;
      v28 = ((char *)v57 - (char *)v27) / 24;
      v29 = &v65;
      if ( v28 )
        v29 = v27;
      if ( *((_BYTE *)v29 + 16) )
        v30 = (v29[1] - *v29) >> 1;
      else
        v30 = 0i64;
      *(_WORD *)((char *)&v72[10] + v71[1]) = 48;
      v31 = std::setw(v80, v30 - 1);
      (*(void (__fastcall **)(char *, _QWORD))v31)((char *)&v72[-1] + v71[1], *(_QWORD *)(v31 + 8));
      sub_14000C080((__int64)&v71);
      v32 = (_QWORD *)sub_14000C460((__int64)v70, (__int64)Block);
      v33 = &v65;
      if ( v28 )
        v33 = v27;
      if ( *((_BYTE *)v33 + 16) )
        v34 = (v33[1] - *v33) >> 1;
      else
        v34 = 0i64;
      v35 = &v65;
      if ( v28 )
        v35 = v27;
      sub_14000C5C0(a4, (*v35 - (__int64)v55) >> 1, (char *)v34, v32, 0i64, -1i64);
      if ( Block[3] >= (void *)8 )
        j_free(Block[0]);
      v53 = v74;
      *(__int64 *)((char *)v70 + *(int *)(v70[0] + 4)) = (__int64)&std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
      sub_140001E20((__int64)v72);
      *(__int64 *)((char *)v70 + *(int *)(v70[0] + 4)) = (__int64)&std::wiostream::`vftable';
      *(__int64 *)((char *)&v72[-1] + v71[1]) = (__int64)&std::wostream::`vftable';
      *(__int64 *)((char *)v70 + *(int *)(v70[0] + 4)) = (__int64)&std::wistream::`vftable';
      v74[0] = (__int64)&std::ios_base::`vftable';
      std::ios_base::_Ios_base_dtor((struct std::ios_base *)v74);
    }
    else
    {
      v22 = 1;
    }
    if ( v27 )
      j_free(v27);
  }
  while ( !v22 );
  v36 = sub_14000CB60((char *)a4, L"/F", 2ui64);
  v37 = (WCHAR *)v69;
  for ( i = (__int64)v54; v36 != -1; v36 = sub_14000CB60((char *)a4, L"/F", 2ui64) )
    sub_14000C5C0(a4, v36, (char *)2, v37, 0i64, -1i64);
  for ( j = sub_14000CB60((char *)a4, L"/B", 2ui64); j != -1; j = sub_14000CB60((char *)a4, L"/B", 2ui64) )
  {
    v40 = -1i64;
    v41 = pszPath;
    do
    {
      if ( !v40 )
        break;
      v18 = *v41++ == 0;
      --v40;
    }
    while ( !v18 );
    sub_14000C940(a4, j, (char *)pszPath, -v40 - 2);
  }
  v42 = sub_14000CB60((char *)a4, L"/E", 2ui64);
  if ( v42 != -1 )
  {
    v43 = (char *)ExtensionW;
    do
    {
      v44 = -1i64;
      v45 = v43;
      do
      {
        if ( !v44 )
          break;
        v18 = *(_WORD *)v45 == 0;
        v45 += 2;
        --v44;
      }
      while ( !v18 );
      sub_14000C940(a4, v42, v43, -v44 - 2);
      v42 = sub_14000CB60((char *)a4, L"/E", 2ui64);
    }
    while ( v42 != -1 );
    i = (__int64)v54;
  }
  if ( v50 )
  {
    v18 = (*(_DWORD *)(v50 + 40))-- == 1;
    if ( v18 )
    {
      v46 = v50;
      while ( v46 )
      {
        v47 = (void (__fastcall ***)(_QWORD, __int64))v46;
        v48 = (_QWORD *)(v46 + 16);
        v46 = *(_QWORD *)(v46 + 16);
        *v48 = 0i64;
        (**v47)(v47, 1i64);
      }
    }
  }
  v50 = 0i64;
  sub_140008FC0((__int64 *)&v52);
  if ( *(_QWORD *)(i + 24) >= 8ui64 )
    j_free(*(void **)i);
  *(_QWORD *)(i + 24) = 7i64;
  *(_QWORD *)(i + 16) = 0i64;
  *(_WORD *)i = 0;
  if ( *((_QWORD *)v37 + 3) >= 8ui64 )
    j_free(*(void **)v37);
  *((_QWORD *)v37 + 3) = 7i64;
  *((_QWORD *)v37 + 2) = 0i64;
  *v37 = 0;
}
// 1400BB5F6: conditional instruction was optimized away because rdx.8!=0
// 140003840: using guessed type __int64 __fastcall sub_140003840(_QWORD);
// 14002CBD4: using guessed type __int64 __fastcall std::setw(_QWORD, _QWORD);
// 1400F4300: using guessed type wchar_t a0N[7];
// 1400F4310: using guessed type wchar_t asc_1400F4310[3];
// 1400F4318: using guessed type wchar_t aB_3[3];
// 1400F4320: using guessed type wchar_t aE[3];
// 1400F6838: using guessed type void *std::wstringbuf::`vftable';
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';
// 1400F7218: using guessed type void *std::wiostream::`vftable';
// 1400F7228: using guessed type void *std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`vftable';
// 1400F73A8: using guessed type void *std::wostream::`vftable';
// 1400BB540: using guessed type char var_2A8[16];

//----- (00000001400BC5B0) ----------------------------------------------------
char __fastcall sub_1400BC5B0(int a1)
{
  char result; // al

  switch ( a1 )
  {
    case 45002:
    case 45003:
    case 45013:
      result = 8;
      break;
    case 45005:
      result = 66;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00000001400BC640) ----------------------------------------------------
__int64 __fastcall sub_1400BC640(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 45002:
      result = 0i64;
      break;
    case 45003:
      result = 1i64;
      break;
    case 45004:
      result = 8i64;
      break;
    case 45005:
      result = 14i64;
      break;
    case 45006:
      result = 11i64;
      break;
    case 45007:
      result = 10i64;
      break;
    case 45008:
      result = 9i64;
      break;
    case 45009:
      result = 3i64;
      break;
    case 45010:
      result = 2i64;
      break;
    case 45011:
      result = 4i64;
      break;
    case 45012:
      result = 5i64;
      break;
    case 45013:
      result = 7i64;
      break;
    case 45014:
      result = 17i64;
      break;
    case 45015:
      result = 6i64;
      break;
    case 45017:
      result = 12i64;
      break;
    case 45018:
      result = 19i64;
      break;
    case 45019:
      result = 15i64;
      break;
    case 45020:
      result = 18i64;
      break;
    case 45021:
      result = 20i64;
      break;
    case 45022:
      result = 31i64;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (00000001400BC740) ----------------------------------------------------
__int64 __fastcall sub_1400BC740(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 0:
      result = 8187i64;
      break;
    case 1:
      result = 8050i64;
      break;
    case 2:
      result = 8051i64;
      break;
    case 3:
      result = 8052i64;
      break;
    case 4:
      result = 8096i64;
      break;
    case 5:
      result = 8097i64;
      break;
    case 6:
      result = 8098i64;
      break;
    case 7:
      result = 8166i64;
      break;
    case 8:
      result = 8167i64;
      break;
    case 9:
      result = 8168i64;
      break;
    case 10:
      result = 8169i64;
      break;
    case 11:
      result = 8170i64;
      break;
    case 12:
      result = 8171i64;
      break;
    case 13:
      result = 8172i64;
      break;
    case 14:
      result = 8173i64;
      break;
    case 15:
      result = 0i64;
      break;
    case 16:
      result = 8174i64;
      break;
    case 17:
      result = 8183i64;
      break;
    case 18:
      result = 8184i64;
      break;
    case 19:
      result = 8185i64;
      break;
    case 20:
      result = 8186i64;
      break;
    case 21:
      result = 8188i64;
      break;
  }
  return result;
}

//----- (00000001400BC840) ----------------------------------------------------
LRESULT __fastcall sub_1400BC840(__int64 a1)
{
  UINT v2; // eax
  UINT v3; // eax
  UINT v4; // eax
  UINT v5; // eax
  UINT v6; // eax
  UINT v7; // eax
  UINT v8; // eax
  UINT v9; // eax
  UINT v10; // eax
  UINT v11; // eax
  UINT v12; // eax
  UINT v13; // eax
  UINT v14; // eax
  UINT v15; // eax
  UINT v16; // eax
  UINT v17; // eax
  UINT v18; // eax
  UINT v19; // eax
  UINT v20; // eax
  UINT v21; // eax
  WCHAR Buffer[64]; // [rsp+20h] [rbp-39h] BYREF

  v2 = sub_1400BC740(1);
  LoadStringW(hInstance, v2, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v3 = sub_1400BC740(2);
  LoadStringW(hInstance, v3, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v4 = sub_1400BC740(3);
  LoadStringW(hInstance, v4, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v5 = sub_1400BC740(4);
  LoadStringW(hInstance, v5, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v6 = sub_1400BC740(5);
  LoadStringW(hInstance, v6, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v7 = sub_1400BC740(6);
  LoadStringW(hInstance, v7, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v8 = sub_1400BC740(7);
  LoadStringW(hInstance, v8, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v9 = sub_1400BC740(8);
  LoadStringW(hInstance, v9, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v10 = sub_1400BC740(9);
  LoadStringW(hInstance, v10, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v11 = sub_1400BC740(10);
  LoadStringW(hInstance, v11, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v12 = sub_1400BC740(11);
  LoadStringW(hInstance, v12, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v13 = sub_1400BC740(12);
  LoadStringW(hInstance, v13, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v14 = sub_1400BC740(13);
  LoadStringW(hInstance, v14, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v15 = sub_1400BC740(14);
  LoadStringW(hInstance, v15, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  LoadStringW(hInstance, 0, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v16 = sub_1400BC740(16);
  LoadStringW(hInstance, v16, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v17 = sub_1400BC740(17);
  LoadStringW(hInstance, v17, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v18 = sub_1400BC740(18);
  LoadStringW(hInstance, v18, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v19 = sub_1400BC740(19);
  LoadStringW(hInstance, v19, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v20 = sub_1400BC740(20);
  LoadStringW(hInstance, v20, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
  v21 = sub_1400BC740(21);
  LoadStringW(hInstance, v21, Buffer, 64);
  Buffer[lstrlenW(Buffer) + 1] = 0;
  return SendMessageW(*(HWND *)(a1 + 176), 0x44Du, 0i64, (LPARAM)Buffer);
}

//----- (00000001400BCEA0) ----------------------------------------------------
char **__fastcall sub_1400BCEA0(__int64 a1)
{
  _QWORD **v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  __int64 v5; // rsi
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rsi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rsi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rsi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rsi
  char *v21; // r11
  __int64 v22; // rax
  __int64 v23; // rsi
  char *v24; // r11
  __int64 v25; // rax
  __int64 v26; // rsi
  char *v27; // r11
  __int64 v28; // rax
  __int64 v29; // rsi
  char *v30; // r11
  __int64 v31; // rax
  __int64 v32; // rsi
  char *v33; // r11
  __int64 v34; // rax
  __int64 v35; // rsi
  char *v36; // r11
  __int64 v37; // rax
  __int64 v38; // rsi
  char *v39; // r11
  __int64 v40; // rax
  __int64 v41; // rsi
  char *v42; // r11
  __int64 v43; // rax
  __int64 v44; // rsi
  char *v45; // r11
  __int64 v46; // rax
  __int64 v47; // rsi
  char *v48; // r11
  __int64 v49; // rax
  __int64 v50; // rsi
  char *v51; // r11
  __int64 v52; // rax
  __int64 v53; // rsi
  char *v54; // r11
  __int64 v55; // rax
  __int64 v56; // rsi
  char *v57; // r11
  __int64 v58; // rax
  __int64 v59; // rsi
  char *v60; // r11
  __int64 v61; // rax
  __int64 v62; // rsi
  char *v63; // r11
  __int64 v64; // rax
  __int64 v65; // rsi
  char *v66; // r11
  __int64 v67; // rax
  __int64 v68; // rsi
  char *v69; // r11
  __int64 v70; // rax
  __int64 v71; // rsi
  char *v72; // r11
  __int64 v73; // rax
  __int64 v74; // rsi
  char *v75; // r11
  __int64 v76; // rax
  char **result; // rax
  int v78; // [rsp+30h] [rbp+10h] BYREF

  v1 = *(_QWORD ***)(a1 + 62072);
  v3 = *v1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)(a1 + 62072) + 8i64) = *(_QWORD *)(a1 + 62072);
  *(_QWORD *)(a1 + 62080) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 62072) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 62072) );
  }
  v5 = *(_QWORD *)(a1 + 62072);
  v78 = 45002;
  v6 = sub_1400246F0(v5, *(_QWORD *)(v5 + 8), &v78);
  v7 = *(_QWORD *)(a1 + 62080);
  if ( v7 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45003;
  *(_QWORD *)(a1 + 62080) = v7 + 1;
  *(_QWORD *)(v5 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *(_QWORD *)(a1 + 62072);
  v9 = sub_1400246F0(v8, *(_QWORD *)(v8 + 8), &v78);
  v10 = *(_QWORD *)(a1 + 62080);
  if ( v10 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45004;
  *(_QWORD *)(a1 + 62080) = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *(_QWORD *)(a1 + 62072);
  v12 = sub_1400246F0(v11, *(_QWORD *)(v11 + 8), &v78);
  v13 = *(_QWORD *)(a1 + 62080);
  if ( v13 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45001;
  *(_QWORD *)(a1 + 62080) = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *(_QWORD *)(a1 + 62072);
  v15 = sub_1400246F0(v14, *(_QWORD *)(v14 + 8), &v78);
  v16 = *(_QWORD *)(a1 + 62080);
  if ( v16 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45005;
  *(_QWORD *)(a1 + 62080) = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *(_QWORD *)(a1 + 62072);
  v18 = sub_1400246F0(v17, *(_QWORD *)(v17 + 8), &v78);
  v19 = *(_QWORD *)(a1 + 62080);
  if ( v19 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45001;
  *(_QWORD *)(a1 + 62080) = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *(_QWORD *)(a1 + 62072);
  v21 = sub_1400246F0(v20, *(_QWORD *)(v20 + 8), &v78);
  v22 = *(_QWORD *)(a1 + 62080);
  if ( v22 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45010;
  *(_QWORD *)(a1 + 62080) = v22 + 1;
  *(_QWORD *)(v20 + 8) = v21;
  **((_QWORD **)v21 + 1) = v21;
  v23 = *(_QWORD *)(a1 + 62072);
  v24 = sub_1400246F0(v23, *(_QWORD *)(v23 + 8), &v78);
  v25 = *(_QWORD *)(a1 + 62080);
  if ( v25 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45009;
  *(_QWORD *)(a1 + 62080) = v25 + 1;
  *(_QWORD *)(v23 + 8) = v24;
  **((_QWORD **)v24 + 1) = v24;
  v26 = *(_QWORD *)(a1 + 62072);
  v27 = sub_1400246F0(v26, *(_QWORD *)(v26 + 8), &v78);
  v28 = *(_QWORD *)(a1 + 62080);
  if ( v28 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45011;
  *(_QWORD *)(a1 + 62080) = v28 + 1;
  *(_QWORD *)(v26 + 8) = v27;
  **((_QWORD **)v27 + 1) = v27;
  v29 = *(_QWORD *)(a1 + 62072);
  v30 = sub_1400246F0(v29, *(_QWORD *)(v29 + 8), &v78);
  v31 = *(_QWORD *)(a1 + 62080);
  if ( v31 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45012;
  *(_QWORD *)(a1 + 62080) = v31 + 1;
  *(_QWORD *)(v29 + 8) = v30;
  **((_QWORD **)v30 + 1) = v30;
  v32 = *(_QWORD *)(a1 + 62072);
  v33 = sub_1400246F0(v32, *(_QWORD *)(v32 + 8), &v78);
  v34 = *(_QWORD *)(a1 + 62080);
  if ( v34 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45022;
  *(_QWORD *)(a1 + 62080) = v34 + 1;
  *(_QWORD *)(v32 + 8) = v33;
  **((_QWORD **)v33 + 1) = v33;
  v35 = *(_QWORD *)(a1 + 62072);
  v36 = sub_1400246F0(v35, *(_QWORD *)(v35 + 8), &v78);
  v37 = *(_QWORD *)(a1 + 62080);
  if ( v37 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45015;
  *(_QWORD *)(a1 + 62080) = v37 + 1;
  *(_QWORD *)(v35 + 8) = v36;
  **((_QWORD **)v36 + 1) = v36;
  v38 = *(_QWORD *)(a1 + 62072);
  v39 = sub_1400246F0(v38, *(_QWORD *)(v38 + 8), &v78);
  v40 = *(_QWORD *)(a1 + 62080);
  if ( v40 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45014;
  *(_QWORD *)(a1 + 62080) = v40 + 1;
  *(_QWORD *)(v38 + 8) = v39;
  **((_QWORD **)v39 + 1) = v39;
  v41 = *(_QWORD *)(a1 + 62072);
  v42 = sub_1400246F0(v41, *(_QWORD *)(v41 + 8), &v78);
  v43 = *(_QWORD *)(a1 + 62080);
  if ( v43 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45001;
  *(_QWORD *)(a1 + 62080) = v43 + 1;
  *(_QWORD *)(v41 + 8) = v42;
  **((_QWORD **)v42 + 1) = v42;
  v44 = *(_QWORD *)(a1 + 62072);
  v45 = sub_1400246F0(v44, *(_QWORD *)(v44 + 8), &v78);
  v46 = *(_QWORD *)(a1 + 62080);
  if ( v46 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45008;
  *(_QWORD *)(a1 + 62080) = v46 + 1;
  *(_QWORD *)(v44 + 8) = v45;
  **((_QWORD **)v45 + 1) = v45;
  v47 = *(_QWORD *)(a1 + 62072);
  v48 = sub_1400246F0(v47, *(_QWORD *)(v47 + 8), &v78);
  v49 = *(_QWORD *)(a1 + 62080);
  if ( v49 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45006;
  *(_QWORD *)(a1 + 62080) = v49 + 1;
  *(_QWORD *)(v47 + 8) = v48;
  **((_QWORD **)v48 + 1) = v48;
  v50 = *(_QWORD *)(a1 + 62072);
  v51 = sub_1400246F0(v50, *(_QWORD *)(v50 + 8), &v78);
  v52 = *(_QWORD *)(a1 + 62080);
  if ( v52 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45007;
  *(_QWORD *)(a1 + 62080) = v52 + 1;
  *(_QWORD *)(v50 + 8) = v51;
  **((_QWORD **)v51 + 1) = v51;
  v53 = *(_QWORD *)(a1 + 62072);
  v54 = sub_1400246F0(v53, *(_QWORD *)(v53 + 8), &v78);
  v55 = *(_QWORD *)(a1 + 62080);
  if ( v55 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45001;
  *(_QWORD *)(a1 + 62080) = v55 + 1;
  *(_QWORD *)(v53 + 8) = v54;
  **((_QWORD **)v54 + 1) = v54;
  v56 = *(_QWORD *)(a1 + 62072);
  v57 = sub_1400246F0(v56, *(_QWORD *)(v56 + 8), &v78);
  v58 = *(_QWORD *)(a1 + 62080);
  if ( v58 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45013;
  *(_QWORD *)(a1 + 62080) = v58 + 1;
  *(_QWORD *)(v56 + 8) = v57;
  **((_QWORD **)v57 + 1) = v57;
  v59 = *(_QWORD *)(a1 + 62072);
  v60 = sub_1400246F0(v59, *(_QWORD *)(v59 + 8), &v78);
  v61 = *(_QWORD *)(a1 + 62080);
  if ( v61 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45020;
  *(_QWORD *)(a1 + 62080) = v61 + 1;
  *(_QWORD *)(v59 + 8) = v60;
  **((_QWORD **)v60 + 1) = v60;
  v62 = *(_QWORD *)(a1 + 62072);
  v63 = sub_1400246F0(v62, *(_QWORD *)(v62 + 8), &v78);
  v64 = *(_QWORD *)(a1 + 62080);
  if ( v64 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45017;
  *(_QWORD *)(a1 + 62080) = v64 + 1;
  *(_QWORD *)(v62 + 8) = v63;
  **((_QWORD **)v63 + 1) = v63;
  v65 = *(_QWORD *)(a1 + 62072);
  v66 = sub_1400246F0(v65, *(_QWORD *)(v65 + 8), &v78);
  v67 = *(_QWORD *)(a1 + 62080);
  if ( v67 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45001;
  *(_QWORD *)(a1 + 62080) = v67 + 1;
  *(_QWORD *)(v65 + 8) = v66;
  **((_QWORD **)v66 + 1) = v66;
  v68 = *(_QWORD *)(a1 + 62072);
  v69 = sub_1400246F0(v68, *(_QWORD *)(v68 + 8), &v78);
  v70 = *(_QWORD *)(a1 + 62080);
  if ( v70 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45018;
  *(_QWORD *)(a1 + 62080) = v70 + 1;
  *(_QWORD *)(v68 + 8) = v69;
  **((_QWORD **)v69 + 1) = v69;
  v71 = *(_QWORD *)(a1 + 62072);
  v72 = sub_1400246F0(v71, *(_QWORD *)(v71 + 8), &v78);
  v73 = *(_QWORD *)(a1 + 62080);
  if ( v73 == 0x3FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  v78 = 45021;
  *(_QWORD *)(a1 + 62080) = v73 + 1;
  *(_QWORD *)(v71 + 8) = v72;
  **((_QWORD **)v72 + 1) = v72;
  v74 = *(_QWORD *)(a1 + 62072);
  v75 = sub_1400246F0(v74, *(_QWORD *)(v74 + 8), &v78);
  v76 = *(_QWORD *)(a1 + 62080);
  if ( 0x3FFFFFFFFFFFFFFEi64 == v76 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 62080) = v76 + 1;
  *(_QWORD *)(v74 + 8) = v75;
  result = (char **)*((_QWORD *)v75 + 1);
  *result = v75;
  return result;
}

//----- (00000001400BD730) ----------------------------------------------------
LRESULT __fastcall sub_1400BD730(__int64 a1)
{
  int v2; // ebp
  int v3; // eax
  int v4; // eax
  int v5; // eax
  LPARAM v6; // rdi
  LPARAM v7; // rsi
  HWND Focus; // rax
  LPARAM v9; // r9
  int v10; // eax
  int v11; // eax
  int v12; // eax
  BOOL v13; // eax
  BOOL v14; // eax
  BOOL v15; // eax

  v2 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640));
  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 184i64))(*(_QWORD *)(a1 + 2640));
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFCCui64, v3);
  v4 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 136i64))(*(_QWORD *)(a1 + 2640));
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFCAui64, v4);
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 144i64))(*(_QWORD *)(a1 + 2640));
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFCBui64, v5);
  v6 = 0i64;
  v7 = 1i64;
  if ( !(unsigned int)sub_1400B56A0(a1) || (Focus = GetFocus(), v9 = 1i64, Focus == *(HWND *)(a1 + 152)) )
    v9 = 0i64;
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFCEui64, v9);
  if ( !(unsigned int)sub_1400B56A0(a1) || GetFocus() == *(HWND *)(a1 + 152) )
    v7 = 0i64;
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFCFui64, v7);
  v10 = sub_1400B56A0(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD1ui64, v10);
  v11 = sub_1400B56A0(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD2ui64, v11);
  v12 = sub_1400B6250(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD3ui64, v12);
  v13 = sub_1400B61E0(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD7ui64, v13);
  v14 = sub_1400B5FD0(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD4ui64, v14);
  v15 = sub_1400B5FD0(a1);
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFDEui64, v15);
  LOBYTE(v6) = v2 == 0;
  SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFDCui64, v6);
  return SendMessageW(*(HWND *)(a1 + 176), 0x401u, 0xAFD0ui64, v6);
}

//----- (00000001400BD980) ----------------------------------------------------
__int64 __fastcall sub_1400BD980(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2608) + 584i64))(*(_QWORD *)(a1 + 2608));
  if ( !(_DWORD)result )
    return (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 2608) + 240i64))(*(_QWORD *)(a1 + 2608), a2);
  return result;
}

//----- (00000001400BD9D0) ----------------------------------------------------
void __fastcall sub_1400BD9D0(__int64 a1)
{
  signed int v2; // eax
  __int64 v3; // rdi
  signed int v4; // er12
  _QWORD *v5; // rsi
  unsigned int v6; // er13
  _QWORD *v7; // rbx
  ITEMIDLIST *v8; // rbx

  v2 = SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64);
  v3 = 0i64;
  v4 = v2;
  if ( v2 )
  {
    v5 = malloc(8i64 * v2);
    v6 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
    if ( v6 != -1 )
    {
      v7 = v5;
      do
      {
        *v7++ = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                  *(_QWORD *)(a1 + 2640),
                  v6);
        v6 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)v6, 2i64);
      }
      while ( v6 != -1 );
    }
  }
  else
  {
    v5 = 0i64;
  }
  v8 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  sub_14009A080(a1, v8, (__int64)v5, v4, L"properties", 0);
  CoTaskMemFree(v8);
  if ( v4 > 0i64 )
  {
    do
      CoTaskMemFree((LPVOID)v5[v3++]);
    while ( v3 < v4 );
  }
  free(v5);
}
// 1400EFED0: using guessed type wchar_t aProperties_0[11];

//----- (00000001400BDB10) ----------------------------------------------------
void __fastcall sub_1400BDB10(__int64 a1, _QWORD *a2)
{
  DWORD MessagePos; // eax
  HWND v4; // rcx
  HWND v5; // rcx
  SHORT KeyState; // bx
  SHORT v7; // si
  SHORT v8; // ax
  __int64 v9; // rcx
  ITEMIDLIST *v10; // rbx
  unsigned int v11; // er8
  unsigned int v12; // er9
  LPVOID pv; // [rsp+30h] [rbp-38h] BYREF
  struct tagPOINT Point; // [rsp+38h] [rbp-30h] BYREF
  LPARAM lParam; // [rsp+40h] [rbp-28h] BYREF
  int v16; // [rsp+48h] [rbp-20h]
  unsigned int v17; // [rsp+4Ch] [rbp-1Ch]

  if ( *a2 == *(_QWORD *)(a1 + 4800) )
  {
    MessagePos = GetMessagePos();
    Point.x = (__int16)MessagePos;
    v4 = *(HWND *)(a1 + 4800);
    Point.y = SHIWORD(MessagePos);
    ScreenToClient(v4, &Point);
    v5 = *(HWND *)(a1 + 4800);
    lParam = (LPARAM)Point;
    SendMessageW(v5, 0x1012u, 0i64, (LPARAM)&lParam);
    if ( v16 != 1 && v17 != -1 )
    {
      KeyState = GetKeyState(18);
      v7 = GetKeyState(17);
      v8 = GetKeyState(16);
      if ( KeyState < 0 )
      {
        v9 = *(_QWORD *)(a1 + 2640);
        pv = 0i64;
        v10 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 112i64))(v9);
        pv = (LPVOID)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                       *(_QWORD *)(a1 + 2640),
                       v17);
        sub_14009A080(a1, v10, (__int64)&pv, 1u, L"properties", 0);
        CoTaskMemFree(pv);
        CoTaskMemFree(v10);
        return;
      }
      if ( (v7 & 0x8000) != 0 )
      {
        v11 = 1;
      }
      else
      {
        v11 = 0;
        if ( (v8 & 0x8000) != 0 )
        {
          v12 = 1;
          goto LABEL_9;
        }
      }
      v12 = 0;
LABEL_9:
      sub_1400B01C0(a1, v17, v11, v12);
    }
  }
}
// 1400EFED0: using guessed type wchar_t aProperties_0[11];

//----- (00000001400BDC90) ----------------------------------------------------
__int64 __fastcall sub_1400BDC90(__int64 a1, _QWORD *a2)
{
  void *v5; // rax
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(3, psz2);
  if ( !StrCmpW((PCWSTR)(a1 + 4920), psz2) )
  {
    *a2 = &unk_140125028;
    return 2i64;
  }
  sub_14007E090(10, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 4920), psz2) )
  {
    if ( sub_1400B5590(a1, 49) )
    {
      *a2 = &unk_140125048;
      return 4i64;
    }
    if ( sub_1400B5590(a1, 18) )
    {
      *a2 = &unk_140125058;
      return 2i64;
    }
    if ( sub_1400B5590(a1, 4) )
    {
      *a2 = &unk_140125060;
      return 5i64;
    }
    v5 = &unk_140124F98;
  }
  else
  {
    v5 = &unk_140125078;
  }
  *a2 = v5;
  return 6i64;
}

//----- (00000001400BDDF0) ----------------------------------------------------
__int64 __fastcall sub_1400BDDF0(__int64 a1, _QWORD *a2)
{
  int v4; // ebp
  int v5; // ebx
  int v6; // edi
  HWND v7; // rcx
  __int64 v8; // rcx
  __int64 lParam[4]; // [rsp+20h] [rbp-38h] BYREF
  int v11; // [rsp+40h] [rbp-18h]

  v4 = 0;
  v5 = 0;
  v6 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  if ( *a2 != *(_QWORD *)(a1 + 184) )
  {
    do
    {
      if ( v5 >= v6 )
        break;
      v7 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v7, 0x133Cu, v5, (LPARAM)lParam);
      v4 = v11;
      ++v5;
    }
    while ( *a2 != *(_QWORD *)(a1 + 8i64 * v11 + 184) );
  }
  v8 = *(_QWORD *)(a1 + 8i64 * v4 + 1832);
  return (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v8 + 272i64))(v8, a2);
}
// 1400BDDF0: using guessed type LPARAM lParam[4];

//----- (00000001400BDEC0) ----------------------------------------------------
__int64 __fastcall sub_1400BDEC0(__int64 a1, HWND a2)
{
  __int64 result; // rax

  result = *(int *)(GetWindowLongPtrW(a2, -21) + 8);
  if ( (int)result >= 100 || *(_DWORD *)(a1 + 4 * result + 60320) != 1 )
    return 0xFFFFFFFFi64;
  return result;
}

//----- (00000001400BDF00) ----------------------------------------------------
LRESULT __fastcall sub_1400BDF00(__int64 a1, int a2)
{
  HWND v3; // rcx
  LRESULT result; // rax
  HWND v5; // rcx
  WPARAM v6; // r8
  LPARAM v7; // [rsp+20h] [rbp-78h] BYREF
  int v8; // [rsp+2Ch] [rbp-6Ch]
  int v9; // [rsp+30h] [rbp-68h]
  _DWORD lParam[3]; // [rsp+70h] [rbp-28h] BYREF
  int v11; // [rsp+7Ch] [rbp-1Ch]

  v3 = *(HWND *)(a1 + 4800);
  lParam[0] = (unsigned __int16)a2;
  lParam[1] = HIWORD(a2);
  result = SendMessageW(v3, 0x1012u, 0i64, (LPARAM)lParam);
  if ( lParam[2] == 1 || (result = v11, v11 == -1) )
  {
    *(_DWORD *)(a1 + 62424) = -1;
  }
  else
  {
    v5 = *(HWND *)(a1 + 4800);
    v6 = v11;
    *(_DWORD *)(a1 + 62424) = v11;
    v9 = 1;
    v8 = 1;
    return SendMessageW(v5, 0x102Bu, v6, (LPARAM)&v7);
  }
  return result;
}

//----- (00000001400BDFC0) ----------------------------------------------------
LRESULT __fastcall sub_1400BDFC0(__int64 a1, WPARAM a2, LPARAM a3)
{
  HWND v4; // rcx
  _DWORD lParam[6]; // [rsp+30h] [rbp-38h] BYREF

  v4 = *(HWND *)(a1 + 4800);
  lParam[0] = (unsigned __int16)a3;
  lParam[1] = WORD1(a3);
  SendMessageW(v4, 0x1012u, 0i64, (LPARAM)lParam);
  if ( lParam[2] == 1 )
  {
    *(_DWORD *)(a1 + 62412) = 1;
    if ( (a2 & 8) == 0 && *(int *)(a1 + 62416) > 1 )
      *(_DWORD *)(a1 + 62404) = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 62412) = 0;
  }
  return CallWindowProcW(lpPrevWndFunc, *(HWND *)(a1 + 4800), 0x201u, a2, a3);
}

//----- (00000001400BE090) ----------------------------------------------------
HWND __fastcall sub_1400BE090(__int64 a1, HWND a2)
{
  HWND v3; // rbx
  unsigned int v4; // eax
  void *ppvObj; // [rsp+30h] [rbp+8h] BYREF

  ppvObj = 0i64;
  v3 = sub_14007CED0(a2);
  SHGetImageList(1, &stru_1400E4120, &ppvObj);
  SendMessageW(v3, 0x1003u, 1ui64, (LPARAM)ppvObj);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppvObj + 16i64))(ppvObj);
  v4 = SendMessageW(v3, 0x1037u, 0i64, 0i64);
  if ( *(_DWORD *)(a1 + 60828) )
    v4 |= 0x20u;
  if ( *(_DWORD *)(a1 + 60876) )
    v4 |= 4u;
  SendMessageW(v3, 0x1036u, 0i64, v4);
  SetWindowTheme(v3, L"Explorer", 0i64);
  return v3;
}

//----- (00000001400BE160) ----------------------------------------------------
void __fastcall sub_1400BE160(__int64 a1, __int64 a2)
{
  int *v2; // rbx
  __int64 v4; // rdi
  _QWORD *v5; // rax
  UINT v6; // er15
  HMENU SubMenu; // r14
  _DWORD *v8; // r12
  int v9; // eax
  __int64 v10; // rsi
  _QWORD *v11; // rax
  _QWORD *v12; // rbx
  UINT v13; // eax
  int MenuItemCount; // eax
  HMENU v15; // rbx
  void **v16; // rcx
  void *v17; // rax
  void **v18; // rbx
  void *Block; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v20; // [rsp+48h] [rbp-B8h]
  _DWORD *v21; // [rsp+58h] [rbp-A8h] BYREF
  HMENU hmenu; // [rsp+60h] [rbp-A0h]
  char *v23; // [rsp+68h] [rbp-98h] BYREF
  int *v24; // [rsp+70h] [rbp-90h]
  __int64 v25; // [rsp+78h] [rbp-88h]
  MENUITEMINFOW mi; // [rsp+80h] [rbp-80h] BYREF
  __int64 pExceptionObject[4]; // [rsp+D0h] [rbp-30h] BYREF
  WCHAR Buffer[256]; // [rsp+F0h] [rbp-10h] BYREF
  WCHAR psz2[264]; // [rsp+2F0h] [rbp+1F0h] BYREF

  v25 = -2i64;
  v2 = (int *)a2;
  v24 = (int *)a2;
  v4 = 0i64;
  v20 = 0i64;
  v5 = operator new(0x20ui64);
  if ( !v5 )
  {
    v23 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v23);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v5;
  *v5 = v5;
  *((_QWORD *)Block + 1) = Block;
  v21 = 0i64;
  v6 = 0;
  hmenu = LoadMenuW(hInstance, (LPCWSTR)0xDA);
  SubMenu = GetSubMenu(hmenu, 0);
  (*(void (__fastcall **)(_QWORD, void **))(**(_QWORD **)(a1 + 2640) + 624i64))(*(_QWORD *)(a1 + 2640), &Block);
  sub_14007E090(17, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 4920), psz2) )
  {
    v9 = sub_1400BDC90(a1, &v21);
    v8 = v21;
  }
  else
  {
    v8 = &unk_140125030;
    v9 = 6;
  }
  v10 = v9;
  if ( v9 > 0 )
  {
    v11 = Block;
    do
    {
      v12 = (_QWORD *)*v11;
      if ( (_QWORD *)*v11 != v11 )
      {
        while ( *((_DWORD *)v12 + 4) != v8[v4] )
        {
          v12 = (_QWORD *)*v12;
          if ( v12 == v11 )
            goto LABEL_12;
        }
        v13 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 48i64))(
                a1 + 56,
                *((unsigned int *)v12 + 4));
        LoadStringW(hInstance, v13, Buffer, 256);
        mi.fState = *((_DWORD *)v12 + 5) != 0 ? 8 : 0;
        mi.cbSize = 80;
        mi.fMask = 67;
        mi.dwTypeData = Buffer;
        mi.wID = v6 + 12000;
        InsertMenuItemW(SubMenu, v6++, 1, &mi);
        v11 = Block;
      }
LABEL_12:
      ++v4;
    }
    while ( v4 < v10 );
    v2 = v24;
  }
  MenuItemCount = GetMenuItemCount(SubMenu);
  sub_1400B08E0(a1, SubMenu, MenuItemCount);
  TrackPopupMenu(SubMenu, 0x42u, *v2, v2[1], 0, *(HWND *)(a1 + 104), 0i64);
  mi.cbSize = 80;
  mi.fMask = 32;
  v15 = hmenu;
  GetMenuItemInfoW(hmenu, 0, 1, &mi);
  free((void *)mi.dwItemData);
  DestroyMenu(v15);
  v16 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  *((_QWORD *)Block + 1) = Block;
  v20 = 0i64;
  v17 = Block;
  if ( v16 != Block )
  {
    do
    {
      v18 = (void **)*v16;
      j_free(v16);
      v16 = v18;
      v17 = Block;
    }
    while ( v18 != Block );
  }
  j_free(v17);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400BE430) ----------------------------------------------------
void __fastcall sub_1400BE430(__int64 a1, unsigned int a2, _WORD *a3)
{
  const FILETIME *v6; // rax
  __int64 v7; // rcx
  void *v8; // rbp
  void *v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdi
  signed __int64 v12; // rcx
  __int16 v13; // ax
  void *pv[2]; // [rsp+30h] [rbp-448h] BYREF
  char v15[512]; // [rsp+40h] [rbp-438h] BYREF
  WCHAR Buffer[256]; // [rsp+240h] [rbp-238h] BYREF

  if ( !*(_DWORD *)(a1 + 60932)
    || (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640)) )
  {
    v7 = *(_QWORD *)(a1 + 2640);
    pv[0] = 0i64;
    v8 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 112i64))(v7);
    v9 = (void *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                   *(_QWORD *)(a1 + 2640),
                   a2);
    v10 = *(_QWORD *)(a1 + 104);
    v11 = 512i64;
    pv[0] = v9;
    if ( (int)sub_14007F650(v10, (__int64)v8, (__int64)pv, a3, 0x200u) < 0 )
    {
      v12 = &unk_1400ECA64 - (_UNKNOWN *)a3;
      while ( v11 != -2147483134 )
      {
        v13 = *(_WORD *)((char *)a3 + v12);
        if ( !v13 )
          break;
        *a3++ = v13;
        if ( !--v11 )
        {
          --a3;
          break;
        }
      }
      *a3 = 0;
    }
    CoTaskMemFree(v8);
    CoTaskMemFree(pv[0]);
  }
  else
  {
    v6 = (const FILETIME *)((*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 264i64))(
                              *(_QWORD *)(a1 + 2640),
                              a2)
                          + 20);
    if ( v6 )
      sub_1400835A0(v6, v15, 256, *(_DWORD *)(a1 + 60960));
    LoadStringW(hInstance, 0x2015u, Buffer, 256);
    sub_140001000(a3, 0x200ui64, L"%s: %s", Buffer, v15);
  }
}
// 1400BE586: conditional instruction was optimized away because rdi.8!=0
// 1400F45F0: using guessed type wchar_t aSS_13[7];
// 1400BE430: using guessed type LPVOID pv[2];

//----- (00000001400BE5E0) ----------------------------------------------------
int __fastcall sub_1400BE5E0(__int64 a1, int a2)
{
  HWND v3; // rcx
  int result; // eax
  void *v5; // rsi
  int v6; // ebx
  LPCITEMIDLIST pidl; // [rsp+30h] [rbp-D0h] BYREF
  int v8; // [rsp+38h] [rbp-C8h] BYREF
  IShellFolder *v9; // [rsp+40h] [rbp-C0h] BYREF
  LPVOID pv; // [rsp+48h] [rbp-B8h] BYREF
  IShellFolder *ppshf; // [rsp+50h] [rbp-B0h] BYREF
  STRRET pstr; // [rsp+60h] [rbp-A0h] BYREF
  _DWORD lParam[3]; // [rsp+170h] [rbp+70h] BYREF
  unsigned int v14; // [rsp+17Ch] [rbp+7Ch]
  WCHAR pszBuf[264]; // [rsp+190h] [rbp+90h] BYREF

  v3 = *(HWND *)(a1 + 4800);
  lParam[0] = (unsigned __int16)a2;
  lParam[1] = HIWORD(a2);
  result = SendMessageW(v3, 0x1012u, 0i64, (LPARAM)lParam);
  if ( lParam[2] != 1 )
  {
    result = *(_DWORD *)(a1 + 62424);
    if ( v14 == result )
    {
      ppshf = 0i64;
      v9 = 0i64;
      pidl = 0i64;
      v8 = 541065216;
      result = SHGetDesktopFolder(&ppshf);
      if ( result >= 0 )
      {
        v5 = (void *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
        if ( ((int (__fastcall *)(IShellFolder *, void *, _QWORD, const IID *, IShellFolder **))ppshf->lpVtbl->BindToObject)(
               ppshf,
               v5,
               0i64,
               &stru_1400E3FB0,
               &v9) >= 0
          || SHGetDesktopFolder(&v9) >= 0 )
        {
          pidl = (LPCITEMIDLIST)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(
                                  *(_QWORD *)(a1 + 2640),
                                  v14);
          if ( ((int (__fastcall *)(IShellFolder *, __int64, LPCITEMIDLIST *, int *))v9->lpVtbl->GetAttributesOf)(
                 v9,
                 1i64,
                 &pidl,
                 &v8) >= 0
            && (v8 & 0x20000000) != 0
            && (v8 & 0x400000) == 0 )
          {
            ((void (__fastcall *)(IShellFolder *, LPCITEMIDLIST, __int64, STRRET *))v9->lpVtbl->GetDisplayNameOf)(
              v9,
              pidl,
              0x8000i64,
              &pstr);
            StrRetToBufW(&pstr, pidl, pszBuf, 0x104u);
            pv = 0i64;
            v6 = sub_14007F810((__int64)pszBuf, (__int64)&pv);
            (*(void (__fastcall **)(__int64, LPVOID, _QWORD, __int64, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
              a1 + 56,
              pv,
              0i64,
              1i64,
              0,
              0);
            if ( v6 >= 0 )
              CoTaskMemFree(pv);
          }
          CoTaskMemFree((LPVOID)pidl);
          ((void (__fastcall *)(IShellFolder *))v9->lpVtbl->Release)(v9);
        }
        CoTaskMemFree(v5);
        return ((__int64 (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
      }
    }
  }
  return result;
}

//----- (00000001400BE810) ----------------------------------------------------
HMENU __fastcall sub_1400BE810(__int64 a1)
{
  HMENU MenuW; // rax
  HMENU SubMenu; // rax
  __int64 **v4; // rdi
  __int64 *v5; // rbx
  HMENU i; // rbp
  int v7; // esi
  UINT v8; // edx
  unsigned int v9; // eax
  UINT v10; // eax
  __int64 v11; // rcx
  int v13[4]; // [rsp+20h] [rbp-108h] BYREF
  MENUITEMINFOW mi; // [rsp+30h] [rbp-F8h] BYREF
  WCHAR Buffer[64]; // [rsp+80h] [rbp-A8h] BYREF

  MenuW = LoadMenuW(hInstance, (LPCWSTR)0x9B);
  SubMenu = GetSubMenu(MenuW, 0);
  v4 = *(__int64 ***)(a1 + 7072);
  v5 = *v4;
  for ( i = SubMenu; v5 != (__int64 *)v4; v5 = (__int64 *)*v5 )
  {
    v7 = *((_DWORD *)v5 + 4) - 1;
    switch ( *((_DWORD *)v5 + 4) )
    {
      case 1:
        v9 = *(_DWORD *)(a1 + 7004);
        if ( v9 < 6 )
        {
          if ( v9 < 5 )
            goto LABEL_14;
          v8 = 2047;
        }
        else
        {
          v8 = 2046;
        }
        break;
      case 2:
        v8 = 2048;
        break;
      case 3:
        v8 = 2088;
        break;
      case 4:
        v8 = 2089;
        break;
      case 5:
        v8 = 2091;
        break;
      case 6:
        v8 = 2090;
        break;
      case 7:
        v8 = 2044;
        break;
      case 8:
        v8 = 2045;
        break;
      default:
LABEL_14:
        v8 = -1;
        break;
    }
    LoadStringW(hInstance, v8, Buffer, 64);
    mi.cbSize = 80;
    mi.fMask = 66;
    switch ( v7 )
    {
      case 0:
        v10 = 60002;
        break;
      case 1:
        v10 = 60003;
        break;
      case 2:
        v10 = 60004;
        break;
      case 3:
        v10 = 60005;
        break;
      case 4:
        v10 = 60001;
        break;
      case 5:
        v10 = 60000;
        break;
      case 6:
        v10 = 60008;
        break;
      case 7:
        v10 = 60007;
        break;
      default:
        v10 = -1;
        break;
    }
    mi.wID = v10;
    mi.dwTypeData = Buffer;
    InsertMenuItemW(i, 0x9DEEu, 0, &mi);
  }
  DeleteMenu(i, 0x9DEEu, 0);
  mi.hSubMenu = *(HMENU *)(a1 + 4848);
  mi.cbSize = 80;
  mi.fMask = 4;
  SetMenuItemInfoW(i, 0x9DBBu, 0, &mi);
  mi.hSubMenu = *(HMENU *)(a1 + 4856);
  mi.cbSize = 80;
  mi.fMask = 4;
  SetMenuItemInfoW(i, 0x9DBAu, 0, &mi);
  v11 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 48i64))(v11, v13);
  EnableMenuItem(i, 0x9DBAu, v13[0] == 3);
  return i;
}
// 1400BE810: using guessed type int var_108[4];

//----- (00000001400BEAF0) ----------------------------------------------------
void __fastcall sub_1400BEAF0(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rdx
  _WORD *v4; // rcx
  unsigned __int64 v5; // r8
  char *v6; // r9
  __int16 v7; // ax
  __int16 v8[512]; // [rsp+20h] [rbp-418h] BYREF

  if ( *(_DWORD *)(a1 + 60928) )
  {
    sub_1400BE430(a1, *(_DWORD *)(a2 + 44), v8);
    if ( lstrlenW(*(LPCWSTR *)(a2 + 32)) > 0 )
      sub_140001080(*(_WORD **)(a2 + 32), *(int *)(a2 + 40), (__int64)L"\n");
    sub_140001080(*(_WORD **)(a2 + 32), *(int *)(a2 + 40), (__int64)v8);
  }
  else
  {
    v3 = *(int *)(a2 + 40);
    v4 = *(_WORD **)(a2 + 32);
    if ( v3 && v3 <= 0x7FFFFFFF )
    {
      v5 = 2147483646 - v3;
      v6 = (char *)(&unk_1400ECA2C - (_UNKNOWN *)v4);
      while ( v5 + v3 )
      {
        v7 = *(_WORD *)((char *)v4 + (_QWORD)v6);
        if ( !v7 )
          break;
        *v4++ = v7;
        if ( !--v3 )
        {
          --v4;
          break;
        }
      }
      *v4 = 0;
    }
  }
}
// 1400BEBA7: conditional instruction was optimized away because rdx.8!=0
// 1400EC944: using guessed type wchar_t asc_1400EC944[2];
// 1400BEAF0: using guessed type _WORD var_418[512];

//----- (00000001400BEBE0) ----------------------------------------------------
void __fastcall sub_1400BEBE0(__int64 a1)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  _QWORD *v4; // rdi
  unsigned int i; // esi
  const void *v6; // rax
  char *v7; // rax
  __int64 **v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rbx
  char *v11; // [rsp+30h] [rbp-5B8h] BYREF
  _QWORD **v12; // [rsp+38h] [rbp-5B0h] BYREF
  __int64 v13; // [rsp+40h] [rbp-5A8h]
  __int64 pExceptionObject[4]; // [rsp+50h] [rbp-598h] BYREF
  __int64 *v15; // [rsp+70h] [rbp-578h] BYREF
  LPARAM dwInitParam[3]; // [rsp+90h] [rbp-558h] BYREF
  unsigned __int16 v17; // [rsp+A8h] [rbp-540h]
  HWND hWndParent; // [rsp+B0h] [rbp-538h]
  int v19; // [rsp+C0h] [rbp-528h]
  char v20[520]; // [rsp+160h] [rbp-488h] BYREF
  char v21[600]; // [rsp+368h] [rbp-280h] BYREF

  pExceptionObject[3] = -2i64;
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64) )
  {
    v2 = 0i64;
    v13 = 0i64;
    v3 = operator new(0x468ui64);
    v4 = v3;
    if ( !v3 )
    {
      v11 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v11);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v12 = (_QWORD **)v3;
    *v3 = v3;
    v3[1] = v3;
    for ( i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
          i != -1;
          i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)i, 2i64) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(
        *(_QWORD *)(a1 + 2640),
        i,
        v20);
      v6 = (const void *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 264i64))(
                           *(_QWORD *)(a1 + 2640),
                           i);
      memmove(v21, v6, 0x250ui64);
      v7 = sub_14000B500((__int64)v4, v4[1], v20);
      if ( v2 == 0x3AEF6CA9705866i64 )
        sub_14002B5F8("list<T> too long");
      v13 = ++v2;
      v4[1] = v7;
      **((_QWORD **)v7 + 1) = v7;
    }
    v8 = sub_14000B2C0(&v15, &v12);
    sub_14009BA10((__int64)dwInitParam, *(_QWORD *)(a1 + 104), v8);
    if ( !v19 )
      DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v17, hWndParent, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
    sub_14009AAE0((__int64)dwInitParam);
    v9 = (_QWORD *)*v4;
    *v4 = v4;
    v4[1] = v4;
    if ( v9 != v4 )
    {
      do
      {
        v10 = (_QWORD *)*v9;
        j_free(v9);
        v9 = v10;
      }
      while ( v10 != v4 );
    }
    j_free(v4);
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400BEBE0: using guessed type char var_280[600];

//----- (00000001400BEE30) ----------------------------------------------------
__int64 __fastcall sub_1400BEE30(__int64 a1, HWND a2, unsigned int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r12
  int v9; // ebx
  __int64 v10; // rcx
  int v11; // eax
  int v12; // eax
  LPARAM v13; // r9
  HWND Parent; // rax
  int v15; // ebx
  HWND v16; // rax
  int v17; // esi
  HWND v18; // rax
  HWND v19; // rax
  int v21; // eax
  __int64 v22; // rcx
  LPARAM v23; // [rsp+20h] [rbp-2A8h] BYREF
  int v24; // [rsp+2Ch] [rbp-29Ch]
  int v25; // [rsp+30h] [rbp-298h]
  __int16 lParam[264]; // [rsp+70h] [rbp-258h] BYREF

  v5 = a4;
  if ( a3 == 177 )
  {
    if ( *(_DWORD *)(a1 + 62460) && !a4 && a5 == -1 )
    {
      SendMessageW(a2, 0xDu, 0x104ui64, (LPARAM)lParam);
      if ( ((*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 248i64))(
              *(_QWORD *)(a1 + 2640),
              *(unsigned int *)(a1 + 62468)) & 0x10) == 0 )
      {
        v21 = lstrlenW((LPCWSTR)lParam) - 1;
        v22 = v21;
        if ( v21 >= 0 )
        {
          while ( lParam[v22] != 46 )
          {
            --v21;
            if ( --v22 < 0 )
              goto LABEL_29;
          }
          v5 = 0i64;
          a5 = v21;
        }
      }
LABEL_29:
      *(_DWORD *)(a1 + 62460) = 0;
    }
    return sub_140001A20((__int64)a2, a3, v5, a5);
  }
  if ( a3 != 32823 )
    return sub_140001A20((__int64)a2, a3, v5, a5);
  if ( a4 != 9 )
  {
    if ( a4 != 113 )
      return sub_140001A20((__int64)a2, a3, v5, a5);
    SendMessageW(a2, 0xDu, 0x104ui64, (LPARAM)lParam);
    if ( ((*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 248i64))(
            *(_QWORD *)(a1 + 2640),
            *(unsigned int *)(a1 + 62468)) & 0x10) != 0 )
      return sub_140001A20((__int64)a2, a3, v5, a5);
    v9 = lstrlenW((LPCWSTR)lParam) - 1;
    v10 = v9;
    if ( v9 < 0 )
      return sub_140001A20((__int64)a2, a3, v5, a5);
    while ( lParam[v10] != 46 )
    {
      --v9;
      if ( --v10 < 0 )
        return sub_140001A20((__int64)a2, a3, v5, a5);
    }
    v11 = *(_DWORD *)(a1 + 7064);
    if ( v11 )
    {
      if ( v11 == 1 )
      {
        *(_DWORD *)(a1 + 7064) = 2;
        v13 = -1i64;
      }
      else
      {
        if ( v11 != 2 )
          return sub_140001A20((__int64)a2, a3, v5, a5);
        v13 = v9;
        *(_DWORD *)(a1 + 7064) = 0;
      }
      SendMessageW(a2, 0xB1u, 0i64, v13);
      return sub_140001A20((__int64)a2, a3, v5, a5);
    }
    v12 = lstrlenW((LPCWSTR)lParam);
    SendMessageW(a2, 0xB1u, v9 + 1, v12);
    *(_DWORD *)(a1 + 7064) = 1;
    return sub_140001A20((__int64)a2, a3, v5, a5);
  }
  Parent = GetParent(a2);
  v15 = SendMessageW(Parent, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v16 = GetParent(a2);
  v17 = 0;
  v25 = 2;
  v24 = 0;
  SendMessageW(v16, 0x102Bu, v15, (LPARAM)&v23);
  v18 = GetParent(a2);
  if ( v15 != (unsigned int)SendMessageW(v18, 0x1004u, 0i64, 0i64) - 1 )
    v17 = v15 + 1;
  v19 = GetParent(a2);
  SendMessageW(v19, 0x1076u, v17, 0i64);
  return 0i64;
}
// 1400BEE30: using guessed type WCHAR lParam[264];

//----- (00000001400BF0D0) ----------------------------------------------------
__int64 __fastcall sub_1400BF0D0(HWND a1, unsigned int a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  return sub_1400BEE30(a6, a1, a2, a3, a4);
}

//----- (00000001400BF100) ----------------------------------------------------
__int64 __fastcall sub_1400BF100(__int64 a1, __int64 a2)
{
  __int64 v5; // rax

  if ( !sub_1400B6040(a1) )
    return 1i64;
  v5 = SendMessageW(*(HWND *)(a1 + 4800), 0x1018u, 0i64, 0i64);
  sub_140009C20(v5, (__int64)sub_1400BF0D0, 0i64, a1);
  *(_DWORD *)(a1 + 7064) = 0;
  *(_DWORD *)(a1 + 62468) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 62464) = 1;
  *(_DWORD *)(a1 + 62460) = 1;
  return 0i64;
}

//----- (00000001400BF190) ----------------------------------------------------
void __fastcall sub_1400BF190(__int64 a1, HWND a2, __int64 **a3)
{
  __int64 v6; // rsi
  void **v7; // rax
  void **v8; // rbx
  unsigned int i; // ebp
  __int64 v10; // rcx
  char *v11; // rdi
  bool v12; // zf
  char *v13; // rax
  void **v14; // rdi
  void **v15; // rdi
  void **v16; // rsi
  char *v17[2]; // [rsp+20h] [rbp-2C8h] BYREF
  __int64 v18; // [rsp+30h] [rbp-2B8h]
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-2A8h] BYREF
  void *Block[3]; // [rsp+60h] [rbp-288h] BYREF
  unsigned __int64 v21; // [rsp+78h] [rbp-270h]
  char v22[528]; // [rsp+90h] [rbp-258h] BYREF

  pExceptionObject[3] = -2i64;
  v6 = 0i64;
  v18 = 0i64;
  v7 = (void **)operator new(0x38ui64);
  v8 = v7;
  if ( !v7 )
  {
    v17[0] = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v17);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  v17[1] = (char *)v7;
  *v7 = v7;
  v7[1] = v7;
  for ( i = SendMessageW(a2, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64); i != -1; i = SendMessageW(
                                                                                    a2,
                                                                                    0x100Cu,
                                                                                    (int)i,
                                                                                    2i64) )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(*(_QWORD *)(a1 + 2640), i, v22);
    v21 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    v10 = -1i64;
    v11 = v22;
    do
    {
      if ( !v10 )
        break;
      v12 = *(_WORD *)v11 == 0;
      v11 += 2;
      --v10;
    }
    while ( !v12 );
    sub_1400099E0(Block, v22, -v10 - 2);
    v13 = sub_14000A760((__int64)v8, (__int64)v8[1], Block);
    if ( v6 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    v18 = ++v6;
    v8[1] = v13;
    **((_QWORD **)v13 + 1) = v13;
    if ( v21 >= 8 )
      j_free(Block[0]);
  }
  v14 = (void **)*v8;
  sub_14000A630((__int64)a3);
  sub_14000A6B0((__int64)a3, **a3, v14, v8);
  v15 = (void **)*v8;
  *v8 = v8;
  v8[1] = v8;
  if ( v15 != v8 )
  {
    do
    {
      v16 = (void **)*v15;
      if ( (unsigned __int64)v15[5] >= 8 )
        j_free(v15[2]);
      v15[5] = (void *)7;
      v15[4] = 0i64;
      *((_WORD *)v15 + 8) = 0;
      j_free(v15);
      v15 = v16;
    }
    while ( v16 != v8 );
  }
  j_free(v8);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400BF3D0) ----------------------------------------------------
HRESULT __fastcall sub_1400BF3D0(__int64 a1)
{
  HRESULT result; // eax
  _DWORD *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rdx
  WCHAR *v6; // rcx
  WCHAR v7; // ax
  int v8; // eax
  __int64 v9; // r8
  __int64 v10; // rcx
  bool v11; // zf
  __int64 v12; // rdx
  LPDATAOBJECT ppDataObj; // [rsp+20h] [rbp-238h] BYREF
  __int64 v14; // [rsp+28h] [rbp-230h] BYREF
  WCHAR String[264]; // [rsp+30h] [rbp-228h] BYREF

  ppDataObj = 0i64;
  result = OleGetClipboard(&ppDataObj);
  if ( !result )
  {
    v3 = operator new(0x50ui64);
    v4 = (__int64)v3;
    if ( v3 )
    {
      v3[2] = 1;
      *(_QWORD *)v3 = &CDropHandler::`vftable';
    }
    else
    {
      v4 = 0i64;
    }
    v5 = 261i64;
    v6 = String;
    while ( v5 != -2147483385 )
    {
      v7 = *(WCHAR *)((char *)v6 + a1 + 4920 - (_QWORD)String);
      if ( !v7 )
        break;
      *v6++ = v7;
      if ( !--v5 )
      {
        --v6;
        break;
      }
    }
    *v6 = 0;
    v8 = lstrlenW(String);
    v9 = a1 + 32;
    String[v8 + 1] = 0;
    if ( !a1 )
      v9 = 0i64;
    v10 = *(_QWORD *)(a1 + 104);
    v11 = *(_DWORD *)(a1 + 60872) == 0;
    *(_QWORD *)(v4 + 16) = ppDataObj;
    *(_QWORD *)(v4 + 24) = v9;
    *(_QWORD *)(v4 + 48) = v10;
    *(_DWORD *)(v4 + 72) = v11;
    v12 = *(_QWORD *)(v4 + 16);
    *(_DWORD *)(v4 + 44) = 1;
    *(_QWORD *)(v4 + 64) = String;
    v14 = 0i64;
    sub_1400783F0(v4, v12, (int *)&v14);
    if ( !_InterlockedDecrement((volatile signed __int32 *)(v4 + 8)) )
      (**(void (__fastcall ***)(__int64, __int64))v4)(v4, 1i64);
    return ((__int64 (__fastcall *)(LPDATAOBJECT))ppDataObj->lpVtbl->Release)(ppDataObj);
  }
  return result;
}
// 1400BF47A: conditional instruction was optimized away because rdx.8!=0
// 1400F7C20: using guessed type void *CDropHandler::`vftable';

//----- (00000001400BFEC0) ----------------------------------------------------
void __fastcall sub_1400BFEC0(__int64 a1)
{
  int v2; // eax
  int v3; // er15
  int v4; // eax
  __int64 v5; // rsi
  void **v6; // rax
  void **v7; // rbx
  int v8; // er14
  int i; // er12
  __int64 v10; // rcx
  char *v11; // rdi
  bool v12; // zf
  char *v13; // rax
  void **v14; // rax
  void *v15; // rsi
  _QWORD **v16; // rax
  _QWORD *v17; // rcx
  _QWORD *v18; // rdi
  void **v19; // rdi
  void **v20; // rsi
  char *v21; // [rsp+38h] [rbp-D0h] BYREF
  void **v22; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v23; // [rsp+48h] [rbp-C0h]
  __int64 pExceptionObject[4]; // [rsp+58h] [rbp-B0h] BYREF
  LPARAM dwInitParam[3]; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int16 v26; // [rsp+90h] [rbp-78h]
  HWND hWndParent; // [rsp+98h] [rbp-70h]
  int v28; // [rsp+A8h] [rbp-60h]
  void *v29; // [rsp+C0h] [rbp-48h]
  void *v30; // [rsp+C8h] [rbp-40h] BYREF
  void *Block[3]; // [rsp+108h] [rbp+0h] BYREF
  unsigned __int64 v32; // [rsp+120h] [rbp+18h]
  char v33[528]; // [rsp+138h] [rbp+30h] BYREF

  pExceptionObject[3] = -2i64;
  if ( !(*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640)) )
  {
    v2 = SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64);
    v3 = v2;
    if ( v2 == 1 )
    {
      v4 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 3i64);
      if ( v4 != -1 )
        SendMessageW(*(HWND *)(a1 + 4800), 0x1076u, v4, 0i64);
    }
    else if ( v2 > 1 )
    {
      v5 = 0i64;
      v23 = 0i64;
      v6 = (void **)operator new(0x38ui64);
      v7 = v6;
      if ( !v6 )
      {
        v21 = 0i64;
        std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v21);
        pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      v22 = v6;
      *v6 = v6;
      v6[1] = v6;
      v8 = -1;
      for ( i = 0; i < v3; ++i )
      {
        v8 = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, v8, 2i64);
        if ( v8 != -1 )
        {
          (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(
            *(_QWORD *)(a1 + 2640),
            (unsigned int)v8,
            v33);
          v32 = 7i64;
          Block[2] = 0i64;
          LOWORD(Block[0]) = 0;
          v10 = -1i64;
          v11 = v33;
          do
          {
            if ( !v10 )
              break;
            v12 = *(_WORD *)v11 == 0;
            v11 += 2;
            --v10;
          }
          while ( !v12 );
          sub_1400099E0(Block, v33, -v10 - 2);
          v13 = sub_14000A760((__int64)v7, (__int64)v7[1], Block);
          if ( v5 == 0x666666666666665i64 )
            sub_14002B5F8("list<T> too long");
          v23 = ++v5;
          v7[1] = v13;
          **((_QWORD **)v13 + 1) = v13;
          if ( v32 >= 8 )
            j_free(Block[0]);
        }
      }
      v14 = (void **)sub_14000B180((__int64 **)Block, (_QWORD ***)&v22);
      sub_1400BB450((__int64)dwInitParam, *(_QWORD *)(a1 + 104), v14, a1 + 61040);
      if ( !v28 )
        DialogBoxParamW((HINSTANCE)dwInitParam[2], (LPCWSTR)v26, hWndParent, (DLGPROC)DialogFunc, (LPARAM)dwInitParam);
      dwInitParam[0] = (LPARAM)&CMassRenameDialog::`vftable';
      sub_14000A630((__int64)&v30);
      j_free(v30);
      dwInitParam[0] = (LPARAM)&CBaseDialog::`vftable';
      v15 = v29;
      if ( v29 )
      {
        v16 = (_QWORD **)*((_QWORD *)v29 + 1);
        v17 = *v16;
        *v16 = v16;
        *(_QWORD *)(*((_QWORD *)v15 + 1) + 8i64) = *((_QWORD *)v15 + 1);
        *((_QWORD *)v15 + 2) = 0i64;
        if ( v17 != *((_QWORD **)v15 + 1) )
        {
          do
          {
            v18 = (_QWORD *)*v17;
            j_free(v17);
            v17 = v18;
          }
          while ( v18 != *((_QWORD **)v15 + 1) );
        }
        j_free(*((void **)v15 + 1));
        j_free(v15);
      }
      v19 = (void **)*v7;
      *v7 = v7;
      v7[1] = v7;
      if ( v19 != v7 )
      {
        do
        {
          v20 = (void **)*v19;
          if ( (unsigned __int64)v19[5] >= 8 )
            j_free(v19[2]);
          v19[5] = (void *)7;
          v19[4] = 0i64;
          *((_WORD *)v19 + 8) = 0;
          j_free(v19);
          v19 = v20;
        }
        while ( v20 != v7 );
      }
      j_free(v7);
    }
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400F72E8: using guessed type void *CMassRenameDialog::`vftable';
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';

//----- (00000001400C0210) ----------------------------------------------------
void __fastcall sub_1400C0210(__int64 a1, int a2)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rsi
  unsigned int i; // er12
  __int64 v8; // rcx
  char *v9; // rdi
  bool v10; // zf
  char *v11; // rax
  HWND v12; // rdi
  const WCHAR *v13; // rax
  WCHAR *v14; // rbx
  FILEOP_FLAGS v15; // cx
  int v16; // edi
  __int64 **v17; // rax
  __int64 **v18; // rax
  void **v19; // rbx
  void **v20; // rdi
  void **v21; // rsi
  void *Block; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v23; // [rsp+30h] [rbp-D8h]
  char *v24; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v25[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 pExceptionObject[4]; // [rsp+58h] [rbp-B0h] BYREF
  struct _SHFILEOPSTRUCTW FileOp; // [rsp+78h] [rbp-90h] BYREF
  char v28[528]; // [rsp+B8h] [rbp-50h] BYREF

  pExceptionObject[3] = -2i64;
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64) )
  {
    v4 = 0i64;
    v23 = 0i64;
    v5 = operator new(0x38ui64);
    v6 = (__int64)v5;
    if ( !v5 )
    {
      v24 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v24);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    Block = v5;
    *v5 = v5;
    v5[1] = v5;
    for ( i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
          i != -1;
          i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)i, 2i64) )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 2640) + 96i64))(
        *(_QWORD *)(a1 + 2640),
        i,
        v28);
      FileOp.pTo = (PCZZWSTR)7;
      FileOp.pFrom = 0i64;
      LOWORD(FileOp.hwnd) = 0;
      v8 = -1i64;
      v9 = v28;
      do
      {
        if ( !v8 )
          break;
        v10 = *(_WORD *)v9 == 0;
        v9 += 2;
        --v8;
      }
      while ( !v10 );
      sub_1400099E0(&FileOp, v28, -v8 - 2);
      v11 = sub_14000A760(v6, *(_QWORD *)(v6 + 8), &FileOp);
      if ( v4 == 0x666666666666665i64 )
        sub_14002B5F8("list<T> too long");
      v23 = ++v4;
      *(_QWORD *)(v6 + 8) = v11;
      **((_QWORD **)v11 + 1) = v11;
      if ( FileOp.pTo >= (PCZZWSTR)8 )
        j_free(FileOp.hwnd);
    }
    v12 = *(HWND *)(a1 + 104);
    v13 = sub_1400D33C0((_QWORD **)&Block);
    v14 = (WCHAR *)v13;
    v15 = 0;
    if ( !a2 )
      v15 = 64;
    FileOp.hwnd = v12;
    FileOp.wFunc = 3;
    FileOp.pFrom = v13;
    FileOp.pTo = 0i64;
    FileOp.fFlags = v15;
    memset(&FileOp.fAnyOperationsAborted, 0, 20);
    if ( SHFileOperationW(&FileOp) || (v16 = 1, FileOp.fAnyOperationsAborted) )
      v16 = 0;
    free(v14);
    if ( v16 )
    {
      v17 = (__int64 **)operator new(0x18ui64);
      v25[0] = (__int64)v17;
      if ( v17 )
        v18 = sub_14000B180(v17, (_QWORD ***)&Block);
      else
        v18 = 0i64;
      LODWORD(v25[0]) = 3;
      v25[1] = (__int64)v18;
      sub_14001C1B0((_QWORD *)(a1 + 61040), v25);
    }
    v19 = (void **)Block;
    v20 = *(void ***)Block;
    *(_QWORD *)Block = Block;
    v19[1] = v19;
    if ( v20 != v19 )
    {
      do
      {
        v21 = (void **)*v20;
        if ( (unsigned __int64)v20[5] >= 8 )
          j_free(v20[2]);
        v20[5] = (void *)7;
        v20[4] = 0i64;
        *((_WORD *)v20 + 8) = 0;
        j_free(v20);
        v20 = v21;
      }
      while ( v21 != v19 );
    }
    j_free(v19);
  }
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400C0A40) ----------------------------------------------------
void __fastcall sub_1400C0A40(__int64 a1, int *a2)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  _QWORD *v6; // rdi
  unsigned int i; // esi
  char *v8; // rax
  ITEMIDLIST *v9; // rsi
  void **v10; // rax
  __int64 v11; // rbx
  char KeyState; // al
  _QWORD *j; // rbx
  _QWORD *v14; // rcx
  _QWORD *v15; // rbx
  __int64 v16; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v17; // [rsp+50h] [rbp-B8h] BYREF
  char *v18; // [rsp+58h] [rbp-B0h] BYREF
  _QWORD **v19; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v20; // [rsp+68h] [rbp-A0h]
  __int64 pExceptionObject[4]; // [rsp+78h] [rbp-90h] BYREF
  __int64 v22; // [rsp+98h] [rbp-70h] BYREF
  int v23; // [rsp+A0h] [rbp-68h]
  void *Block[3]; // [rsp+B0h] [rbp-58h] BYREF
  char v25; // [rsp+C8h] [rbp-40h]
  DWORD_PTR dwRefData[12]; // [rsp+D8h] [rbp-30h] BYREF
  __int64 *v27; // [rsp+138h] [rbp+30h] BYREF

  pExceptionObject[3] = -2i64;
  if ( (int)SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64) > 0 )
  {
    v4 = 0i64;
    v20 = 0i64;
    v5 = operator new(0x18ui64);
    v6 = v5;
    if ( !v5 )
    {
      v18 = 0i64;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v18);
      pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    v19 = (_QWORD **)v5;
    *v5 = v5;
    v5[1] = v5;
    for ( i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
          i != -1;
          i = SendMessageW(*(HWND *)(a1 + 4800), 0x100Cu, (int)i, 2i64) )
    {
      v17 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 280i64))(*(_QWORD *)(a1 + 2640), i);
      v8 = sub_14000BB70((__int64)v6, v6[1], &v17);
      if ( v4 == 0x1FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      v20 = ++v4;
      v6[1] = v8;
      **((_QWORD **)v8 + 1) = v8;
    }
    v9 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
    v10 = (void **)sub_14000B220(&v27, &v19);
    sub_1400D2390(dwRefData, *(void **)(a1 + 4800), v9, v10);
    LODWORD(v16) = 0;
    v11 = *(_QWORD *)(a1 + 112);
    sub_14000A5B0(Block);
    v22 = v11;
    v25 = 0;
    v23 = 0;
    KeyState = GetKeyState(16);
    if ( dwRefData[3] )
      sub_1400D2910((DWORD_PTR)dwRefData, a1 + 40, a2, (__int64)&v22, (__int64)&v16, 1, KeyState & 0x80);
    CoTaskMemFree(v9);
    for ( j = (_QWORD *)*v6; j != v6; j = (_QWORD *)*j )
      CoTaskMemFree((LPVOID)j[2]);
    sub_14000A630((__int64)Block);
    j_free(Block[0]);
    sub_1400D22C0(dwRefData);
    v14 = (_QWORD *)*v6;
    *v6 = v6;
    v6[1] = v6;
    if ( v14 != v6 )
    {
      do
      {
        v15 = (_QWORD *)*v14;
        j_free(v14);
        v14 = v15;
      }
      while ( v15 != v6 );
    }
    j_free(v6);
  }
}
// 1400D22C0: using guessed type __int64 __fastcall sub_1400D22C0(_QWORD);
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400C0CD0) ----------------------------------------------------
BOOL __fastcall sub_1400C0CD0(__int64 a1, int *a2)
{
  HMENU v4; // r12
  ITEMIDLIST *v5; // rbp
  ITEMIDLIST *v6; // rsi
  int v7; // ebx
  HRESULT v8; // ebx
  HWND v9; // rdx
  DWORD_PTR dwRefData[15]; // [rsp+50h] [rbp-78h] BYREF
  IShellFolder *ppshf; // [rsp+D0h] [rbp+8h] BYREF
  LPITEMIDLIST ppidl; // [rsp+E0h] [rbp+18h] BYREF
  LPITEMIDLIST ID; // [rsp+E8h] [rbp+20h] BYREF

  v4 = sub_1400BE810(a1);
  v5 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  v6 = ILClone(v5);
  ILRemoveLastID(v6);
  ID = ILFindLastID(v5);
  ppshf = 0i64;
  ppidl = 0i64;
  if ( SHGetFolderLocation(0i64, 0, 0i64, 0, &ppidl) >= 0
    && (v7 = sub_14007DCB0((__int64)v6, (__int64)ppidl), CoTaskMemFree(ppidl), v7) )
  {
    v8 = SHGetDesktopFolder(&ppshf);
  }
  else
  {
    ppidl = 0i64;
    SHGetDesktopFolder((IShellFolder **)&ppidl);
    v8 = (*(__int64 (__fastcall **)(LPITEMIDLIST, ITEMIDLIST *, _QWORD, const IID *, IShellFolder **))(*(_QWORD *)&ppidl->mkid.cb + 40i64))(
           ppidl,
           v6,
           0i64,
           &stru_1400E3FB0,
           &ppshf);
    (*(void (__fastcall **)(LPITEMIDLIST))(*(_QWORD *)&ppidl->mkid.cb + 16i64))(ppidl);
  }
  if ( v8 >= 0 )
  {
    ppidl = 0i64;
    if ( ((int (__fastcall *)(IShellFolder *, _QWORD, __int64, LPITEMIDLIST *, __int64 *, _QWORD, LPITEMIDLIST *))ppshf->lpVtbl->GetUIObjectOf)(
           ppshf,
           0i64,
           1i64,
           &ID,
           &qword_1400E41B0,
           0i64,
           &ppidl) >= 0 )
    {
      sub_140079E40(dwRefData, v5, ppidl, a1);
      v9 = *(HWND *)(a1 + 104);
      if ( v9 )
        sub_14007A230((DWORD_PTR)dwRefData, v9, v4, a2, *(_QWORD *)(a1 + 4768));
      (*(void (__fastcall **)(LPITEMIDLIST))(*(_QWORD *)&ppidl->mkid.cb + 16i64))(ppidl);
      sub_140079D10(dwRefData);
    }
    ((void (__fastcall *)(IShellFolder *))ppshf->lpVtbl->Release)(ppshf);
  }
  CoTaskMemFree(v6);
  CoTaskMemFree(v5);
  return DestroyMenu(v4);
}
// 140079D10: using guessed type __int64 __fastcall sub_140079D10(_QWORD);
// 140079E40: using guessed type __int64 __fastcall sub_140079E40(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400E41B0: using guessed type __int64 qword_1400E41B0;

//----- (00000001400C0ED0) ----------------------------------------------------
void __fastcall sub_1400C0ED0(__int64 a1, struct tagPOINT *a2)
{
  HWND v4; // rcx
  HWND v5; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-78h] BYREF
  int v7; // [rsp+2Ch] [rbp-6Ch]
  int v8; // [rsp+30h] [rbp-68h]
  struct tagPOINT Point; // [rsp+70h] [rbp-28h] BYREF
  char v10; // [rsp+78h] [rbp-20h]
  int v11; // [rsp+7Ch] [rbp-1Ch]

  SetForegroundWindow(*(HWND *)(a1 + 104));
  if ( (GetKeyState(16) & 0x80u) != 0 && (GetKeyState(17) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
  {
    v4 = *(HWND *)(a1 + 4800);
    Point = *a2;
    ScreenToClient(v4, &Point);
    SendMessageW(*(HWND *)(a1 + 4800), 0x1012u, 0i64, (LPARAM)&Point);
    if ( (v10 & 1) == 0 && v11 != -1 && (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x102Cu, v11, 2i64) != 2 )
    {
      sub_140081CC0(*(HWND *)(a1 + 4800));
      v5 = *(HWND *)(a1 + 4800);
      v8 = 2;
      v7 = 2;
      SendMessageW(v5, 0x102Bu, v11, (LPARAM)&lParam);
    }
  }
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x1032u, 0i64, 0i64) )
    sub_1400C0A40(a1, (int *)a2);
  else
    sub_1400C0CD0(a1, (int *)a2);
}

//----- (00000001400C1030) ----------------------------------------------------
__int64 __fastcall sub_1400C1030(__int64 a1, __int64 a2)
{
  const WCHAR *v4; // rcx
  const WCHAR *v5; // rdi
  __int64 v6; // rdx
  __int16 *v7; // rcx
  __int16 v8; // ax
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  WCHAR v11; // ax
  const WCHAR *v12; // rax
  LPWSTR ExtensionW; // r11
  __int64 v14; // rdx
  __int16 *v15; // rcx
  __int64 v16; // rdi
  __int16 *v17; // rax
  __int64 v18; // rcx
  signed __int64 v19; // r11
  __int16 v20; // dx
  __int64 v21; // r13
  __int64 v22; // rcx
  WCHAR *v23; // rdi
  bool v24; // zf
  __int64 v25; // rcx
  __int16 *v26; // rdi
  _WORD *p_Block; // r14
  unsigned __int64 v28; // r15
  void **v29; // r8
  unsigned __int64 v30; // r12
  void **v31; // rax
  char *v32; // rdi
  __int64 v33; // rbx
  __int64 v34; // rcx
  _WORD *v35; // rax
  void **v36; // rax
  __int64 v37; // rdi
  unsigned __int64 v38; // rdi
  void **v39; // rdx
  void **v40; // rcx
  unsigned __int64 v41; // rdx
  void **v42; // rax
  _QWORD *v43; // rbx
  char *v44; // rax
  unsigned int v45; // er12
  void **v46; // rbx
  void **v47; // rdi
  void **v48; // rsi
  void *Block; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v51; // [rsp+30h] [rbp-D0h]
  __int64 v52; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v53; // [rsp+40h] [rbp-C0h]
  void *Src[3]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v55; // [rsp+68h] [rbp-98h]
  void *v56[2]; // [rsp+78h] [rbp-88h] BYREF
  unsigned __int64 v57; // [rsp+88h] [rbp-78h]
  unsigned __int64 v58; // [rsp+90h] [rbp-70h]
  __int16 v59[264]; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR pszPath[264]; // [rsp+2B0h] [rbp+1B0h] BYREF
  WCHAR Buffer[128]; // [rsp+4C0h] [rbp+3C0h] BYREF
  WCHAR pszMore[264]; // [rsp+5C0h] [rbp+4C0h] BYREF
  char v63[528]; // [rsp+7D0h] [rbp+6D0h] BYREF
  WCHAR Caption[256]; // [rsp+9E0h] [rbp+8E0h] BYREF
  WCHAR Text[256]; // [rsp+BE0h] [rbp+AE0h] BYREF

  *(_DWORD *)(a1 + 62464) = 0;
  v4 = *(const WCHAR **)(a2 + 48);
  if ( !v4 )
    return 0i64;
  if ( !lstrcmpW(v4, &word_1400EC8C4) )
    return 0i64;
  v5 = *(const WCHAR **)(a2 + 48);
  if ( v5[lstrlenW(v5) - 1] == 46 )
    return 0i64;
  if ( StrChrW(v5, 0x5Cu)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x2Fu)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x3Au)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x2Au)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x3Fu)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x22u)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x3Cu)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x3Eu)
    || StrChrW(*(PCWSTR *)(a2 + 48), 0x7Cu) )
  {
    LoadStringW(hInstance, 0x200Fu, Text, 256);
    LoadStringW(hInstance, 0x2010u, Caption, 256);
    MessageBoxW(*(HWND *)(a1 + 104), Text, Caption, 0x10u);
    return 0i64;
  }
  (*(void (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    v63);
  v6 = 261i64;
  v7 = v59;
  while ( v6 != -2147483385 )
  {
    v8 = v7[920];
    if ( !v8 )
      break;
    *v7++ = v8;
    if ( !--v6 )
    {
      --v7;
      break;
    }
  }
  *v7 = 0;
  v9 = 261i64;
  v10 = pszPath;
  while ( v9 != -2147483385 )
  {
    v11 = v10[656];
    if ( !v11 )
      break;
    *v10++ = v11;
    if ( !--v9 )
    {
      --v10;
      break;
    }
  }
  *v10 = 0;
  (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 2640) + 88i64))(
    *(_QWORD *)(a1 + 2640),
    *(unsigned int *)(a2 + 28),
    pszMore);
  PathAppendW(pszPath, pszMore);
  if ( !PathAppendW((LPWSTR)v59, *(LPCWSTR *)(a2 + 48)) )
    return 0i64;
  if ( ((*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 248i64))(
          *(_QWORD *)(a1 + 2640),
          *(unsigned int *)(a2 + 28)) & 0x10) == 0 )
  {
    if ( !*(_DWORD *)(a1 + 60944)
      || *(_DWORD *)(a1 + 60972) && (v12 = PathFindExtensionW(pszMore), !lstrcmpiW(v12, L".lnk")) )
    {
      ExtensionW = PathFindExtensionW(pszMore);
      if ( *ExtensionW == 46 )
      {
        v14 = 261i64;
        v15 = v59;
        while ( *v15 )
        {
          ++v15;
          if ( !--v14 )
            goto LABEL_39;
        }
        v16 = v14;
        v17 = &v59[261 - v14];
        v18 = 0x7FFFFFFFi64;
        v19 = (char *)ExtensionW - (char *)v17;
        while ( v18 )
        {
          v20 = *(__int16 *)((char *)v17 + v19);
          if ( !v20 )
            break;
          *v17++ = v20;
          --v18;
          if ( !--v16 )
          {
            --v17;
            break;
          }
        }
        *v17 = 0;
      }
    }
  }
LABEL_39:
  v55 = 7i64;
  Src[2] = 0i64;
  LOWORD(Src[0]) = 0;
  v58 = 7i64;
  v57 = 0i64;
  LOWORD(v56[0]) = 0;
  v21 = -1i64;
  v22 = -1i64;
  v23 = pszPath;
  do
  {
    if ( !v22 )
      break;
    v24 = *v23++ == 0;
    --v22;
  }
  while ( !v24 );
  sub_1400099E0(Src, pszPath, -v22 - 2);
  v25 = -1i64;
  v26 = v59;
  do
  {
    if ( !v25 )
      break;
    v24 = *v26++ == 0;
    --v25;
  }
  while ( !v24 );
  sub_1400099E0(v56, v59, -v25 - 2);
  v53 = 7i64;
  v52 = 0i64;
  LOWORD(Block) = 0;
  sub_1400099E0(&Block, L" ", 1ui64);
  p_Block = &Block;
  if ( v53 >= 8 )
    p_Block = Block;
  v28 = v58;
  v29 = (void **)v56[0];
  v30 = v57;
  if ( v57 )
  {
    v31 = v56;
    if ( v58 >= 8 )
      v31 = (void **)v56[0];
    v32 = (char *)v31 + 2 * v57 - 2;
    v33 = v52;
    while ( 1 )
    {
      v34 = v33;
      v35 = p_Block;
      if ( !v33 )
        break;
      while ( *v35 != *(_WORD *)v32 )
      {
        ++v35;
        if ( !--v34 )
          goto LABEL_57;
      }
      if ( v32 == (char *)sub_140009D30(v56) )
      {
        v29 = (void **)v56[0];
        goto LABEL_61;
      }
      v32 -= 2;
    }
LABEL_57:
    v36 = v56;
    v29 = (void **)v56[0];
    if ( v28 >= 8 )
      v36 = (void **)v56[0];
    v37 = (v32 - (char *)v36) >> 1;
  }
  else
  {
LABEL_61:
    v37 = -1i64;
  }
  v38 = v37 + 1;
  if ( v30 < v38 )
    sub_14002B630("invalid string position");
  if ( v30 - v38 == -1i64 || (v21 = v30 - v38, v30 != v38) )
  {
    v39 = v56;
    if ( v28 >= 8 )
      v39 = v29;
    v40 = v56;
    if ( v28 >= 8 )
      v40 = v29;
    memmove((char *)v40 + 2 * v38, (char *)v39 + 2 * v21 + 2 * v38, 2 * (v30 - v21 - v38));
    v41 = v57 - v21;
    v57 -= v21;
    v42 = v56;
    if ( v58 >= 8 )
      v42 = (void **)v56[0];
    *((_WORD *)v42 + v41) = 0;
  }
  if ( v53 >= 8 )
    j_free(Block);
  sub_14000B360(&Block);
  v43 = Block;
  v44 = sub_14000B650((__int64)Block, *((_QWORD *)Block + 1), Src);
  if ( v51 == 0x333333333333332i64 )
    sub_14002B5F8("list<T> too long");
  ++v51;
  v43[1] = v44;
  **((_QWORD **)v44 + 1) = v44;
  v45 = sub_14007AAE0(a1 + 61040, &Block);
  if ( !v45 )
  {
    LoadStringW(hInstance, 0x1F71u, Buffer, 128);
    MessageBoxW(*(HWND *)(a1 + 104), Buffer, L"Explorer++", 0x30u);
  }
  v46 = (void **)Block;
  v47 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  v46[1] = v46;
  if ( v47 != v46 )
  {
    do
    {
      v48 = (void **)*v47;
      if ( (unsigned __int64)v47[10] >= 8 )
        j_free(v47[7]);
      v47[10] = (void *)7;
      v47[9] = 0i64;
      *((_WORD *)v47 + 28) = 0;
      if ( (unsigned __int64)v47[5] >= 8 )
        j_free(v47[2]);
      v47[5] = (void *)7;
      v47[4] = 0i64;
      *((_WORD *)v47 + 8) = 0;
      j_free(v47);
      v47 = v48;
    }
    while ( v48 != v46 );
  }
  j_free(v46);
  if ( v58 >= 8 )
    j_free(v56[0]);
  v58 = 7i64;
  v57 = 0i64;
  LOWORD(v56[0]) = 0;
  if ( v55 >= 8 )
    j_free(Src[0]);
  return v45;
}
// 1400C11DB: conditional instruction was optimized away because rdx.8!=0
// 1400C1227: conditional instruction was optimized away because rdx.8!=0
// 1400C12F5: conditional instruction was optimized away because rdx.8!=0
// 1400C1305: conditional instruction was optimized away because rdx.8!=0
// 1400C1335: conditional instruction was optimized away because rdi.8!=0
// 14007AAE0: using guessed type __int64 __fastcall sub_14007AAE0(_QWORD, _QWORD);
// 1400EC90C: using guessed type wchar_t asc_1400EC90C[2];
// 1400C1030: using guessed type char var_650[528];
// 1400C1030: using guessed type WCHAR var_D80[264];

//----- (00000001400C1700) ----------------------------------------------------
__int64 __fastcall sub_1400C1700(__int64 a1, __int64 a2)
{
  ITEMIDLIST *v3; // rsi
  int v4; // ebx
  HWND v5; // rcx
  __int64 v6; // rdx
  int v7; // eax
  HWND v8; // rcx
  void *pv[2]; // [rsp+30h] [rbp-238h] BYREF
  WCHAR pszPath[264]; // [rsp+40h] [rbp-228h] BYREF

  switch ( *(_WORD *)(a2 + 24) )
  {
    case 8:
      if ( (GetKeyState(17) & 0x80u) == 0 || (GetKeyState(16) & 0x80u) != 0 || (GetKeyState(18) & 0x80u) != 0 )
      {
        sub_1400B12B0(a1);
      }
      else
      {
        v3 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
        sub_14007E270(v3, pszPath, 0x8000u);
        PathStripToRootW(pszPath);
        pv[0] = 0i64;
        v4 = sub_14007F810((__int64)pszPath, (__int64)pv);
        (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)(a1 + 56) + 80i64))(a1 + 56, pv[0], 1i64);
        if ( v4 >= 0 )
          CoTaskMemFree(pv[0]);
        CoTaskMemFree(v3);
      }
      break;
    case 0xD:
      if ( (GetKeyState(17) & 0x80u) == 0 || (GetKeyState(16) & 0x80u) != 0 || (GetKeyState(18) & 0x80u) != 0 )
        sub_1400B5A20(a1, 0);
      else
        sub_1400B5A20(a1, 1u);
      break;
    case 0x2E:
      if ( (GetKeyState(16) & 0x80u) == 0 )
        sub_1400C0210(a1, 0);
      else
        sub_1400C0210(a1, 1);
      break;
    case 0x41:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v5 = *(HWND *)(a1 + 4800);
        *(_DWORD *)(a1 + 62400) = 1;
        sub_140081D30(v5);
        SetFocus(*(HWND *)(a1 + 4800));
      }
      break;
    case 0x43:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v6 = 1i64;
        goto LABEL_37;
      }
      break;
    case 0x49:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v7 = *(_DWORD *)(a1 + 62416);
        v8 = *(HWND *)(a1 + 4800);
        *(_DWORD *)(a1 + 62408) = 1;
        *(_DWORD *)(a1 + 62420) = v7;
        sub_140081BD0(v8);
        SetFocus(*(HWND *)(a1 + 4800));
      }
      break;
    case 0x56:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
        sub_1400BF3D0(a1);
      break;
    case 0x58:
      if ( (GetKeyState(17) & 0x80u) != 0 && (GetKeyState(16) & 0x80u) == 0 && (GetKeyState(18) & 0x80u) == 0 )
      {
        v6 = 0i64;
LABEL_37:
        sub_1400BF540(a1, v6);
      }
      break;
    default:
      return 0i64;
  }
  return 0i64;
}
// 1400BF540: using guessed type __int64 __fastcall sub_1400BF540(_QWORD, _QWORD);
// 1400C1700: using guessed type LPVOID pv[2];

//----- (00000001400C20F0) ----------------------------------------------------
__int64 __fastcall sub_1400C20F0(HWND a1, unsigned int a2, __int64 a3, __int64 a4)
{
  _QWORD *WindowLongPtrW; // rax

  WindowLongPtrW = (_QWORD *)GetWindowLongPtrW(a1, -21);
  return sub_1400C1AD0(*WindowLongPtrW, a1, a2, a3, a4);
}
// 1400C1AD0: using guessed type __int64 __fastcall sub_1400C1AD0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400C2150) ----------------------------------------------------
__int64 __fastcall sub_1400C2150(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rbp
  unsigned int v6; // eax
  WPARAM v7; // r8
  HWND v8; // rcx
  unsigned int v9; // er13
  WPARAM v10; // r8
  HWND v11; // rcx
  _QWORD *v12; // rcx
  _QWORD *v13; // rax
  HWND v14; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-68h] BYREF
  int v16; // [rsp+2Ch] [rbp-5Ch]
  int v17; // [rsp+30h] [rbp-58h]

  result = GetWindowLongPtrW(*(HWND *)a2, -21);
  v5 = *(int *)(result + 8);
  if ( (int)v5 >= 100 )
    return result;
  if ( *(_DWORD *)(a1 + 4 * v5 + 60320) != 1 )
    return result;
  if ( (_DWORD)v5 == -1 )
    return result;
  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v5 + 1832) + 552i64))(*(_QWORD *)(a1 + 8 * v5 + 1832));
  if ( (_DWORD)result )
    return result;
  if ( *(_DWORD *)(a2 + 40) == 8 && (*(_DWORD *)(a2 + 32) & 0xF000) != 0 && (*(_DWORD *)(a2 + 36) & 0xF000) != 0 )
  {
    v6 = SendMessageW(*(HWND *)(a1 + 8 * v5 + 184), 0x102Cu, *(int *)(a2 + 24), 61440i64);
    v7 = *(int *)(a2 + 24);
    v8 = *(HWND *)(a1 + 8 * v5 + 184);
    v17 = 2;
    if ( v6 >> 12 == 1 )
      v16 = 0;
    else
      v16 = 2;
    return SendMessageW(v8, 0x102Bu, v7, (LPARAM)&lParam);
  }
  result = *(_DWORD *)(a2 + 32) & 2;
  if ( (*(_DWORD *)(a2 + 32) & 2) != 0 && (*(_BYTE *)(a2 + 36) & 2) != 0 )
    return result;
  if ( !(_DWORD)result )
  {
    if ( (*(_BYTE *)(a2 + 36) & 2) == 0 )
      return result;
    v9 = 0;
    if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 8 * v5 + 184), 0x102Cu, *(int *)(a2 + 24), 61440i64) >> 12 == 1 )
      goto LABEL_21;
    v16 = 4096;
    goto LABEL_20;
  }
  v9 = 1;
  if ( (unsigned int)SendMessageW(*(HWND *)(a1 + 8 * v5 + 184), 0x102Cu, *(int *)(a2 + 24), 61440i64) >> 12 == 1 )
  {
    v16 = 0x2000;
LABEL_20:
    v10 = *(int *)(a2 + 24);
    v11 = *(HWND *)(a1 + 8 * v5 + 184);
    v17 = 61440;
    SendMessageW(v11, 0x102Bu, v10, (LPARAM)&lParam);
  }
LABEL_21:
  v12 = *(_QWORD **)(a1 + 62200);
  v13 = (_QWORD *)*v12;
  if ( (_QWORD *)*v12 != v12 )
  {
    do
    {
      if ( *((_DWORD *)v13 + 5) == (_DWORD)v5 )
        *((_DWORD *)v13 + 6) = 0;
      v13 = (_QWORD *)*v13;
    }
    while ( v13 != *(_QWORD **)(a1 + 62200) );
  }
  if ( (_DWORD)v5 == *(_DWORD *)(a1 + 7048) )
  {
    if ( v9 )
    {
      v14 = *(HWND *)(a1 + 4800);
      ++*(_DWORD *)(a1 + 62416);
      if ( *(_DWORD *)(a1 + 62416) == (unsigned int)SendMessageW(v14, 0x1004u, 0i64, 0i64) )
        *(_DWORD *)(a1 + 62400) = 0;
    }
    else if ( (int)--*(_DWORD *)(a1 + 62416) <= 1 )
    {
      *(_DWORD *)(a1 + 62404) = 0;
    }
  }
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 8 * v5 + 1832) + 40i64))(
    *(_QWORD *)(a1 + 8 * v5 + 1832),
    *(unsigned int *)(a2 + 56),
    v9);
  result = (unsigned int)SendMessageW(*(HWND *)(a1 + 4800), 0x1004u, 0i64, 0i64) - *(_DWORD *)(a1 + 62416);
  if ( (_DWORD)result == *(_DWORD *)(a1 + 62420) )
    *(_DWORD *)(a1 + 62408) = 0;
  if ( !*(_DWORD *)(a1 + 62400) && !*(_DWORD *)(a1 + 62404) && !*(_DWORD *)(a1 + 62408) )
  {
    sub_1400B8250(a1);
    sub_1400B82C0(a1);
    return sub_1400BD730(a1);
  }
  return result;
}

//----- (00000001400C23F0) ----------------------------------------------------
__int64 sub_1400C23F0()
{
  return 262402i64;
}

//----- (00000001400C2400) ----------------------------------------------------
__int64 __fastcall sub_1400C2400(__int64 a1, int a2, int a3)
{
  int v3; // er9
  int v4; // eax

  v3 = *(_DWORD *)(a1 + 12);
  v4 = 0;
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( (a3 & 2) == 0 )
        return 262400i64;
      v4 = 1;
    }
  }
  else
  {
    if ( (a3 & 1) == 0 )
      return 262400i64;
    v4 = 2;
  }
  if ( a2 == 1 || (v4 & a3) != 0 )
    return 262401i64;
  else
    return 0i64;
}

//----- (00000001400C2490) ----------------------------------------------------
__int64 __fastcall sub_1400C2490(volatile signed __int32 *a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedDecrement(a1 + 2);
  if ( !(_DWORD)result )
  {
    if ( a1 )
    {
      *(_QWORD *)a1 = &CDropSource::`vftable';
      j_free((void *)a1);
    }
    return 0i64;
  }
  return result;
}
// 1400F7068: using guessed type void *CDropSource::`vftable';

//----- (00000001400C24F0) ----------------------------------------------------
__int64 __fastcall sub_1400C24F0(_QWORD *a1, int a2)
{
  _DWORD *v4; // rax

  v4 = operator new(0x10ui64);
  if ( v4 )
  {
    v4[2] = 1;
    v4[3] = a2;
    *(_QWORD *)v4 = &CDropSource::`vftable';
    *a1 = v4;
  }
  else
  {
    *a1 = 0i64;
  }
  return 0i64;
}
// 1400F7068: using guessed type void *CDropSource::`vftable';

//----- (00000001400C2550) ----------------------------------------------------
__int64 __fastcall sub_1400C2550(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  int v3; // er9
  bool v5; // cf
  unsigned __int64 v6; // r11
  int v7; // eax
  bool v8; // cf
  unsigned __int64 v9; // r8

  v3 = 0;
  *a3 = 0i64;
  v5 = *a2 < 0x121ui64;
  if ( *a2 == 289i64 && (v6 = a2[1], v5 = v6 < 0x46000000000000C0i64, v6 == 0x46000000000000C0i64) )
    v7 = 0;
  else
    v7 = -v5 - (v5 - 1);
  if ( v7 )
  {
    v8 = 0;
    if ( *a2 || (v9 = a2[1], v8 = v9 < *(_QWORD *)stru_1400E4110.Data4, v9 != *(_QWORD *)stru_1400E4110.Data4) )
      v3 = -v8 - (v8 - 1);
    if ( v3 )
      return 2147500034i64;
  }
  *a3 = a1;
  if ( !a1 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}

//----- (00000001400C25E0) ----------------------------------------------------
__int64 __fastcall sub_1400C25E0(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400C2600) ----------------------------------------------------
__int64 __fastcall sub_1400C2600(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 16);
  if ( (v2 == -4 || v2 == -2) && *(HWND *)a2 == GetDlgItem(*(HWND *)(a1 + 8), 1315) )
    ShellExecuteW(0i64, L"open", (LPCWSTR)(a2 + 136), 0i64, 0i64, 5);
  return 0i64;
}

//----- (00000001400C2670) ----------------------------------------------------
__int64 __fastcall sub_1400C2670(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    EndDialog(*(HWND *)(a1 + 8), 1i64);
  }
  else if ( a2 == 2 )
  {
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
  return 0i64;
}

//----- (00000001400C26C0) ----------------------------------------------------
__int64 __fastcall sub_1400C26C0(__int64 a1)
{
  HWND v1; // rbx
  HWND Parent; // rax

  v1 = *(HWND *)(a1 + 8);
  Parent = GetParent(v1);
  sub_140081E00(Parent, v1);
  return 1i64;
}

//----- (00000001400C2770) ----------------------------------------------------
__int64 __fastcall sub_1400C2770(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 88));
  return 0i64;
}

//----- (00000001400C2790) ----------------------------------------------------
__int64 __fastcall sub_1400C2790(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400C27B0) ----------------------------------------------------
__int64 __fastcall sub_1400C27B0(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 96);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 96);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400C2850) ----------------------------------------------------
char **__fastcall sub_1400C2850(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v3; // rdi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  char *v11; // r11
  __int64 v12; // rax
  __int64 v13; // rdi
  char *v14; // r11
  __int64 v15; // rax
  __int64 v16; // rdi
  char *v17; // r11
  __int64 v18; // rax
  char **result; // rax
  __int64 v20; // [rsp+20h] [rbp-18h] BYREF
  int v21; // [rsp+28h] [rbp-10h]

  *a2 = 1;
  v3 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  v20 = 0x100000458i64;
  v21 = 1;
  v6 = sub_140017AD0(v3, v5, &v20);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v7 + 1;
  *(_QWORD *)(v3 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  v9 = *(_QWORD *)(*a3 + 8);
  v10 = *a3;
  v20 = 1i64;
  v21 = 0;
  v11 = sub_140017AD0(v10, v9, &v20);
  v12 = a3[1];
  if ( v12 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  v20 = 2i64;
  a3[1] = v12 + 1;
  *(_QWORD *)(v8 + 8) = v11;
  **((_QWORD **)v11 + 1) = v11;
  v13 = *a3;
  v21 = 0;
  v14 = sub_140017AD0(v13, *(_QWORD *)(v13 + 8), &v20);
  v15 = a3[1];
  if ( v15 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  v20 = 1304i64;
  a3[1] = v15 + 1;
  *(_QWORD *)(v13 + 8) = v14;
  **((_QWORD **)v14 + 1) = v14;
  v16 = *a3;
  v21 = 0;
  v17 = sub_140017AD0(v16, *(_QWORD *)(v16 + 8), &v20);
  v18 = a3[1];
  if ( 0x1555555555555554i64 == v18 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v18 + 1;
  *(_QWORD *)(v16 + 8) = v17;
  result = (char **)*((_QWORD *)v17 + 1);
  *result = v17;
  return result;
}

//----- (00000001400C29F0) ----------------------------------------------------
void __fastcall sub_1400C29F0(__int64 a1)
{
  __int64 v2; // rcx

  v2 = a1 + 544;
  *(_QWORD *)(v2 - 544) = &CFilterDialogPersistentSettings::`vftable';
  sub_14000A630(v2);
  j_free(*(void **)(a1 + 544));
  *(_QWORD *)a1 = &CDialogSettings::`vftable';
}
// 1400F6FC8: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';

//----- (00000001400C2A40) ----------------------------------------------------
__int64 *sub_1400C2A40()
{
  __int64 v0; // rdx
  _WORD *v1; // rcx
  __int16 v2; // ax

  v0 = 256i64;
  v1 = &unk_140130A6C;
  while ( v0 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v1 + (char *)L"Filter" - (char *)&unk_140130A6C);
    if ( !v2 )
      break;
    *v1++ = v2;
    if ( !--v0 )
    {
      --v1;
      break;
    }
  }
  *v1 = 0;
  byte_140130C6C = 1;
  dword_140130A58 = 0;
  qword_140130A50 = (__int64)&CFilterDialogPersistentSettings::`vftable';
  sub_14000A5B0(&qword_140130C70);
  return &qword_140130A50;
}
// 1400C2A98: conditional instruction was optimized away because rdx.8!=0
// 1400F46E0: using guessed type wchar_t aFilter_4[7];
// 1400F6FC8: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 140130A50: using guessed type __int64 qword_140130A50;
// 140130A58: using guessed type int dword_140130A58;
// 140130C6C: using guessed type char byte_140130C6C;

//----- (00000001400C2BC0) ----------------------------------------------------
void __fastcall sub_1400C2BC0(__int64 a1, __int64 *a2, __int64 a3)
{
  sub_14007C330(a2, a3, (__int64)L"Filter", (_QWORD **)(a1 + 544));
}
// 1400F4710: using guessed type wchar_t aFilter_6[7];

//----- (00000001400C2BF0) ----------------------------------------------------
__int64 __fastcall sub_1400C2BF0(__int64 a1, HKEY a2)
{
  return sub_14007B450(a2, (__int64)L"Filter", (_QWORD **)(a1 + 544));
}
// 1400F46F0: using guessed type wchar_t aFilter_7[7];

//----- (00000001400C2C10) ----------------------------------------------------
__int64 __fastcall sub_1400C2C10(__int64 a1)
{
  __int64 v2; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  __int64 v5; // rax
  HWND v6; // rcx
  HWND DlgItem; // rbp
  _QWORD *v8; // rdi
  _QWORD *i; // rbx
  LPARAM *v10; // r9
  __int64 v11; // rax
  __int64 v12; // rax
  _DWORD *v13; // rdx
  HWND v14; // rbx
  HWND Parent; // rax
  LPARAM lParam[3]; // [rsp+40h] [rbp-458h] BYREF
  unsigned __int64 v18; // [rsp+58h] [rbp-440h]
  LPARAM v19[128]; // [rsp+70h] [rbp-428h] BYREF

  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  v5 = sub_14000A470(v2, 0x1Au, 0);
  v6 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 88) = v5;
  SetClassLongPtrW(v6, -34, v5);
  DeleteObject(BitmapW);
  sub_14000A390(v2);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1112);
  SetFocus(DlgItem);
  v8 = *(_QWORD **)(*(_QWORD *)(a1 + 96) + 544i64);
  for ( i = (_QWORD *)*v8; i != v8; i = (_QWORD *)*i )
  {
    v18 = 7i64;
    lParam[2] = 0i64;
    LOWORD(lParam[0]) = 0;
    sub_140009610(lParam, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v10 = lParam;
    if ( v18 >= 8 )
      v10 = (LPARAM *)lParam[0];
    SendMessageW(DlgItem, 0x143u, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v10);
    if ( v18 >= 8 )
      j_free((void *)lParam[0]);
  }
  v11 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  (*(void (__fastcall **)(__int64, LPARAM *, __int64))(*(_QWORD *)v11 + 416i64))(v11, v19, 512i64);
  SendMessageW(DlgItem, 0x14Du, 0xFFFFFFFFFFFFFFFFui64, (LPARAM)v19);
  SendMessageW(DlgItem, 0x142u, 0i64, 4294901760i64);
  v12 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v12 + 448i64))(v12) )
    CheckDlgButton(*(HWND *)(a1 + 8), 1290, 1u);
  v13 = *(_DWORD **)(a1 + 96);
  v14 = *(HWND *)(a1 + 8);
  if ( v13[2] )
  {
    SetWindowPos(v14, 0i64, v13[3], v13[4], v13[5], v13[6], 4u);
  }
  else
  {
    Parent = GetParent(v14);
    sub_140081E00(Parent, v14);
  }
  return 0i64;
}

//----- (00000001400C2E60) ----------------------------------------------------
void __fastcall sub_1400C2E60(__int64 a1, const WCHAR *a2, _WORD *a3)
{
  __int64 v5; // rcx
  _WORD *v6; // rdi
  bool v7; // zf
  __int64 v8; // rdi
  char *v9; // r11
  __int64 v10; // rax
  void *Block[3]; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int64 v12; // [rsp+40h] [rbp-38h]

  if ( (unsigned int)sub_140082100(L"Filter*", a2, 1) )
  {
    v12 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    v5 = -1i64;
    v6 = a3;
    do
    {
      if ( !v5 )
        break;
      v7 = *v6++ == 0;
      --v5;
    }
    while ( !v7 );
    sub_1400099E0(Block, a3, -v5 - 2);
    v8 = *(_QWORD *)(a1 + 544);
    v9 = sub_14000A760(v8, *(_QWORD *)(v8 + 8), Block);
    v10 = *(_QWORD *)(a1 + 552);
    if ( v10 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(a1 + 552) = v10 + 1;
    *(_QWORD *)(v8 + 8) = v9;
    **((_QWORD **)v9 + 1) = v9;
    if ( v12 >= 8 )
      j_free(Block[0]);
  }
}

//----- (00000001400C2F60) ----------------------------------------------------
__int64 __fastcall sub_1400C2F60(__int64 a1, HKEY a2)
{
  return sub_14007B580(a2, (__int64)L"Filter", (__int64 *)(a1 + 544));
}
// 1400F4700: using guessed type wchar_t aFilter_8[7];

//----- (00000001400C2F80) ----------------------------------------------------
BOOL __fastcall sub_1400C2F80(__int64 a1)
{
  HWND DlgItem; // rbx
  unsigned __int64 v3; // rdi
  _WORD *v4; // rbp
  __int64 v5; // rcx
  _QWORD *v6; // rdi
  unsigned int v7; // er12
  const WCHAR *v8; // rdx
  bool v9; // zf
  __int64 v10; // rax
  __int64 *v11; // r8
  __int64 *v12; // rdi
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  _WORD *v18; // rdi
  __int64 v19; // rbx
  __int64 v20; // rdi
  char *v21; // r11
  __int64 v22; // rax
  __int64 *v23; // rdi
  __int64 v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  void *Block[3]; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int64 v30; // [rsp+40h] [rbp-38h]

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1112);
  v3 = GetWindowTextLengthW(DlgItem) + 1;
  v4 = operator new(saturated_mul(v3, 2ui64));
  SendMessageW(DlgItem, 0xDu, v3, (LPARAM)v4);
  v5 = *(_QWORD *)(a1 + 96);
  v6 = **(_QWORD ***)(v5 + 544);
  v7 = 0;
  if ( v6 == *(_QWORD **)(v5 + 544) )
  {
LABEL_9:
    v30 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    v17 = -1i64;
    v18 = v4;
    do
    {
      if ( !v17 )
        break;
      v9 = *v18++ == 0;
      --v17;
    }
    while ( !v9 );
    sub_1400099E0(Block, v4, -v17 - 2);
    v19 = *(_QWORD *)(a1 + 96);
    v20 = **(_QWORD **)(v19 + 544);
    v21 = sub_14000A760(v20, *(_QWORD *)(v20 + 8), Block);
    v22 = *(_QWORD *)(v19 + 552);
    if ( v22 == 0x666666666666665i64 )
      sub_14002B5F8("list<T> too long");
    *(_QWORD *)(v19 + 552) = v22 + 1;
    *(_QWORD *)(v20 + 8) = v21;
    **((_QWORD **)v21 + 1) = v21;
    if ( v30 >= 8 )
      j_free(Block[0]);
  }
  else
  {
    while ( 1 )
    {
      v8 = (const WCHAR *)(v6 + 2);
      if ( v6[5] >= 8ui64 )
        v8 = *(const WCHAR **)v8;
      v9 = lstrcmpW(v4, v8) == 0;
      v10 = *(_QWORD *)(a1 + 96);
      if ( v9 )
        break;
      v6 = (_QWORD *)*v6;
      if ( v6 == *(_QWORD **)(v10 + 544) )
        goto LABEL_9;
    }
    v11 = (__int64 *)(**(_QWORD **)(v10 + 544) + 16i64);
    v12 = v6 + 2;
    if ( v12 != v11 )
    {
      v13 = *v12;
      v14 = v12[1];
      *v12 = *v11;
      v12[1] = v11[1];
      *v11 = v13;
      v11[1] = v14;
      v15 = v12[2];
      v12[2] = v11[2];
      v11[2] = v15;
      v16 = v12[3];
      v12[3] = v11[3];
      v11[3] = v16;
    }
  }
  v23 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  v24 = *v23;
  LOBYTE(v7) = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1290) == 1;
  (*(void (__fastcall **)(__int64 *, _QWORD))(v24 + 456))(v23, v7);
  v25 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  (*(void (__fastcall **)(__int64, _WORD *))(*(_QWORD *)v25 + 424i64))(v25, v4);
  v26 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
  if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v26 + 432i64))(v26) )
  {
    v27 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 80) + 8i64))(*(_QWORD *)(a1 + 80));
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v27 + 440i64))(v27, 1i64);
  }
  j_j_free(v4);
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (00000001400C3220) ----------------------------------------------------
__int64 __fastcall sub_1400C3220(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    sub_1400C2F80(a1);
  }
  else if ( a2 == 2 )
  {
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
  return 0i64;
}

//----- (00000001400C3260) ----------------------------------------------------
__int64 __fastcall sub_1400C3260(__int64 a1, __int64 a2, int a3)
{
  if ( a3 == 1 )
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2616) + 656i64))(*(_QWORD *)(a1 + 2616));
  return 0i64;
}

//----- (00000001400C3290) ----------------------------------------------------
__int64 __fastcall sub_1400C3290(__int64 a1, _DWORD *a2)
{
  *a2 = 3;
  return 0i64;
}

//----- (00000001400C32A0) ----------------------------------------------------
__int64 sub_1400C32A0()
{
  return 0i64;
}

//----- (00000001400C32B0) ----------------------------------------------------
__int64 sub_1400C32B0()
{
  return 0i64;
}

//----- (00000001400C32C0) ----------------------------------------------------
__int64 sub_1400C32C0()
{
  return 0i64;
}

//----- (00000001400C32D0) ----------------------------------------------------
__int64 sub_1400C32D0()
{
  return 0i64;
}

//----- (00000001400C32E0) ----------------------------------------------------
__int64 sub_1400C32E0()
{
  return 0i64;
}

//----- (00000001400C32F0) ----------------------------------------------------
__int64 sub_1400C32F0()
{
  return 0i64;
}

//----- (00000001400C3300) ----------------------------------------------------
__int64 sub_1400C3300()
{
  return 0i64;
}

//----- (00000001400C3310) ----------------------------------------------------
__int64 sub_1400C3310()
{
  return 0i64;
}

//----- (00000001400C3320) ----------------------------------------------------
__int64 sub_1400C3320()
{
  return 0i64;
}

//----- (00000001400C3330) ----------------------------------------------------
__int64 sub_1400C3330()
{
  return 0i64;
}

//----- (00000001400C3340) ----------------------------------------------------
__int64 sub_1400C3340()
{
  return 0i64;
}

//----- (00000001400C3350) ----------------------------------------------------
__int64 sub_1400C3350()
{
  return 0i64;
}

//----- (00000001400C3360) ----------------------------------------------------
__int64 sub_1400C3360()
{
  return 0i64;
}

//----- (00000001400C3370) ----------------------------------------------------
__int64 __fastcall sub_1400C3370(__int64 a1, const ITEMIDLIST *a2)
{
  ITEMIDLIST *v4; // rdi
  LPITEMIDLIST v5; // rbx

  v4 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2624) + 112i64))(*(_QWORD *)(a1 + 2624));
  v5 = ILCombine(v4, a2);
  (*(void (__fastcall **)(_QWORD, LPITEMIDLIST))(**(_QWORD **)(a1 + 2624) + 656i64))(*(_QWORD *)(a1 + 2624), v5);
  CoTaskMemFree(v4);
  CoTaskMemFree(v5);
  return 0i64;
}

//----- (00000001400C33F0) ----------------------------------------------------
__int64 sub_1400C33F0()
{
  return 0i64;
}

//----- (00000001400C3400) ----------------------------------------------------
__int64 sub_1400C3400()
{
  return 0i64;
}

//----- (00000001400C3410) ----------------------------------------------------
__int64 sub_1400C3410()
{
  return 0i64;
}

//----- (00000001400C3420) ----------------------------------------------------
__int64 __fastcall sub_1400C3420(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00000001400C3430) ----------------------------------------------------
__int64 __fastcall sub_1400C3430(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 2147500034i64;
}

//----- (00000001400C3490) ----------------------------------------------------
__int64 __fastcall sub_1400C3490(__int64 a1)
{
  __int64 result; // rax

  result = 0i64;
  *(_DWORD *)(a1 + 7028) = 1;
  *(_DWORD *)(a1 + 60800) = 1;
  *(_DWORD *)(a1 + 60920) = 1;
  *(_DWORD *)(a1 + 60924) = 1;
  *(_QWORD *)(a1 + 60840) = 1i64;
  *(_QWORD *)(a1 + 60804) = 0i64;
  *(_QWORD *)(a1 + 60784) = 0i64;
  *(_QWORD *)(a1 + 60792) = 0i64;
  *(_QWORD *)(a1 + 60832) = 0i64;
  *(_DWORD *)(a1 + 60880) = 0;
  *(_DWORD *)(a1 + 60908) = 0;
  *(_DWORD *)(a1 + 60828) = 0;
  *(_DWORD *)(a1 + 60888) = 0;
  *(_DWORD *)(a1 + 60972) = 0;
  *(_DWORD *)(a1 + 60848) = 500;
  *(_QWORD *)(a1 + 60852) = 1i64;
  *(_QWORD *)(a1 + 60860) = 1i64;
  *(_DWORD *)(a1 + 60868) = 1;
  *(_QWORD *)(a1 + 60872) = 1i64;
  *(_DWORD *)(a1 + 60916) = 1;
  *(_QWORD *)(a1 + 60900) = 1i64;
  *(_DWORD *)(a1 + 60884) = 1;
  *(_DWORD *)(a1 + 60892) = 1;
  *(_DWORD *)(a1 + 60912) = 1;
  *(_QWORD *)(a1 + 60928) = 1i64;
  *(_DWORD *)(a1 + 60744) = 1;
  *(_DWORD *)(a1 + 60748) = 1;
  *(_DWORD *)(a1 + 60752) = 1;
  *(_QWORD *)(a1 + 60760) = 1i64;
  *(_DWORD *)(a1 + 60756) = 1;
  *(_QWORD *)(a1 + 60768) = 1i64;
  *(_DWORD *)(a1 + 60776) = 1;
  *(_DWORD *)(a1 + 60780) = 1;
  *(_QWORD *)(a1 + 60820) = 1i64;
  *(_DWORD *)(a1 + 7012) = 90;
  *(_DWORD *)(a1 + 7044) = 208;
  *(_DWORD *)(a1 + 60936) = 1;
  *(_DWORD *)(a1 + 60940) = 1;
  *(_QWORD *)(a1 + 60944) = 1i64;
  *(_DWORD *)(a1 + 60952) = 1;
  *(_DWORD *)(a1 + 60956) = 1;
  *(_DWORD *)(a1 + 60960) = 1;
  *(_QWORD *)(a1 + 60964) = 1i64;
  return result;
}

//----- (00000001400C3640) ----------------------------------------------------
__int64 __fastcall sub_1400C3640(__int64 a1)
{
  __int64 result; // rax

  result = 0i64;
  *(_DWORD *)(a1 + 61092) = 881;
  *(_DWORD *)(a1 + 61096) = 513;
  *(_DWORD *)(a1 + 61272) = 1;
  *(_DWORD *)(a1 + 61204) = 373;
  *(_DWORD *)(a1 + 61208) = 1;
  *(_DWORD *)(a1 + 61160) = 0;
  *(_DWORD *)(a1 + 61144) = 0;
  *(_DWORD *)(a1 + 61136) = 0;
  *(_QWORD *)(a1 + 61172) = 0i64;
  *(_DWORD *)(a1 + 61192) = 0;
  *(_QWORD *)(a1 + 61112) = 0i64;
  *(_DWORD *)(a1 + 61256) = 0;
  *(_DWORD *)(a1 + 61248) = 0;
  *(_QWORD *)(a1 + 61284) = 0i64;
  *(_DWORD *)(a1 + 61304) = 0;
  *(_QWORD *)(a1 + 61224) = 0i64;
  *(_DWORD *)(a1 + 61368) = 0;
  *(_DWORD *)(a1 + 61360) = 0;
  *(_QWORD *)(a1 + 61396) = 0i64;
  *(_DWORD *)(a1 + 61416) = 0;
  *(_QWORD *)(a1 + 61336) = 0i64;
  *(_DWORD *)(a1 + 61480) = 0;
  *(_DWORD *)(a1 + 61472) = 0;
  *(_QWORD *)(a1 + 61508) = 0i64;
  *(_DWORD *)(a1 + 61528) = 0;
  *(_QWORD *)(a1 + 61448) = 0i64;
  *(_DWORD *)(a1 + 61592) = 0;
  *(_DWORD *)(a1 + 61584) = 0;
  *(_QWORD *)(a1 + 61620) = 0i64;
  *(_DWORD *)(a1 + 61640) = 0;
  *(_QWORD *)(a1 + 61560) = 0i64;
  *(_DWORD *)(a1 + 61384) = 2;
  *(_DWORD *)(a1 + 61316) = 881;
  *(_DWORD *)(a1 + 61320) = 513;
  *(_DWORD *)(a1 + 61496) = 3;
  *(_DWORD *)(a1 + 61428) = 881;
  *(_DWORD *)(a1 + 61432) = 513;
  *(_DWORD *)(a1 + 61608) = 4;
  *(_DWORD *)(a1 + 61540) = 881;
  *(_DWORD *)(a1 + 61544) = 513;
  return result;
}

//----- (00000001400C3780) ----------------------------------------------------
__int64 __fastcall sub_1400C3780(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 64) + 1);
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

//----- (00000001400C3790) ----------------------------------------------------
__int64 __fastcall sub_1400C3790(__int64 a1, __int64 a2, _QWORD *a3, _QWORD *a4)
{
  __int64 v4; // rax
  bool v6; // cf
  unsigned __int64 v7; // r11
  int v8; // ecx
  __int64 v9; // rcx
  bool v10; // cf
  unsigned __int64 v11; // r10
  int v12; // ecx

  v4 = 0i64;
  *a4 = 0i64;
  v6 = *a3 < 0x11CF357888E39E80ui64;
  if ( *a3 == 0x11CF357888E39E80i64 && (v7 = a3[1], v6 = v7 < 0x62122E2B000869AEi64, v7 == 0x62122E2B000869AEi64) )
    v8 = 0;
  else
    v8 = -v6 - (v6 - 1);
  if ( v8 )
  {
    v10 = *a3 < 0x451C3BB5DCB07FDCui64;
    if ( *a3 == 0x451C3BB5DCB07FDCi64
      && (v11 = a3[1], v10 = v11 < 0xB0D7FE446696BE90ui64, v11 == 0xB0D7FE446696BE90ui64) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -v10 - (v10 - 1);
    }
    if ( v12 )
      return 2147500034i64;
    v9 = a1 - 8;
    if ( a1 != 8 )
      v4 = a1 + 16;
  }
  else
  {
    v9 = a1 - 8;
    if ( a1 != 8 )
      v4 = a1 + 8;
  }
  *a4 = v4;
  if ( v4 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v9 + 8i64))(v9);
    return 0i64;
  }
  return 2147500034i64;
}

//----- (00000001400C3840) ----------------------------------------------------
__int64 __fastcall sub_1400C3840(_DWORD *a1)
{
  bool v1; // zf
  __int64 result; // rax

  v1 = a1[2]-- == 1;
  result = (unsigned int)a1[2];
  if ( v1 )
  {
    *(_QWORD *)a1 = &Explorerplusplus::CLoadSaveRegistry::`vftable';
    j_free(a1);
    return 0i64;
  }
  return result;
}
// 1400F6EB8: using guessed type void *Explorerplusplus::CLoadSaveRegistry::`vftable';

//----- (00000001400C3870) ----------------------------------------------------
HMENU __fastcall sub_1400C3870(__int64 a1, int a2)
{
  HMENU Menu; // rsi
  _QWORD *v5; // rax
  UINT v6; // er12
  __int64 *v7; // rcx
  __int64 v8; // rax
  int v9; // edi
  void ***v10; // rdx
  void **v11; // rbx
  int v12; // er14
  const ITEMIDLIST *v13; // rdi
  void **v14; // rcx
  void **v15; // rbx
  int MenuItemCount; // eax
  void **v17; // rcx
  void *v18; // rax
  void **v19; // rbx
  void *Block; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v22; // [rsp+30h] [rbp-D8h]
  void *ppv; // [rsp+40h] [rbp-C8h] BYREF
  LPCITEMIDLIST ppidlLast; // [rsp+48h] [rbp-C0h] BYREF
  char *v25; // [rsp+50h] [rbp-B8h] BYREF
  __int64 pExceptionObject[4]; // [rsp+58h] [rbp-B0h] BYREF
  MENUITEMINFOW mi; // [rsp+78h] [rbp-90h] BYREF
  STRRET pstr; // [rsp+C8h] [rbp-40h] BYREF
  WCHAR pszBuf[264]; // [rsp+1D8h] [rbp+D0h] BYREF

  pExceptionObject[3] = -2i64;
  Menu = 0i64;
  v22 = 0i64;
  v5 = operator new(0x18ui64);
  if ( !v5 )
  {
    v25 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v5;
  *v5 = v5;
  *((_QWORD *)Block + 1) = Block;
  v6 = 0;
  v7 = *(__int64 **)(a1 + 2640);
  v8 = *v7;
  if ( a2 )
  {
    (*(void (__fastcall **)(__int64 *, void **))(v8 + 152))(v7, &Block);
    v9 = 2000;
  }
  else
  {
    (*(void (__fastcall **)(__int64 *, void **))(v8 + 160))(v7, &Block);
    v9 = 3000;
  }
  if ( v22 )
  {
    Menu = CreateMenu();
    v10 = (void ***)Block;
    v11 = *(void ***)Block;
    if ( *(void **)Block != Block )
    {
      v12 = v9 + 1;
      do
      {
        v13 = (const ITEMIDLIST *)v11[2];
        if ( v13 )
        {
          ppv = 0i64;
          ppidlLast = 0i64;
          if ( SHBindToParent(v13, &stru_1400E3FB0, &ppv, &ppidlLast) >= 0 )
          {
            if ( (*(int (__fastcall **)(void *, LPCITEMIDLIST, __int64, STRRET *))(*(_QWORD *)ppv + 88i64))(
                   ppv,
                   ppidlLast,
                   1i64,
                   &pstr) >= 0 )
              StrRetToBufW(&pstr, v13, pszBuf, 0x104u);
            (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
          }
        }
        mi.cbSize = 80;
        mi.fMask = 66;
        mi.wID = v12 + v6;
        mi.dwTypeData = pszBuf;
        InsertMenuItemW(Menu, v6++, 1, &mi);
        CoTaskMemFree(v11[2]);
        v11 = (void **)*v11;
        v10 = (void ***)Block;
      }
      while ( v11 != Block );
    }
    v14 = *v10;
    *v10 = (void **)v10;
    *((_QWORD *)Block + 1) = Block;
    v22 = 0i64;
    if ( v14 != Block )
    {
      do
      {
        v15 = (void **)*v14;
        j_free(v14);
        v14 = v15;
      }
      while ( v15 != Block );
    }
    MenuItemCount = GetMenuItemCount(Menu);
    sub_1400B08E0(a1, Menu, MenuItemCount);
  }
  v17 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  *((_QWORD *)Block + 1) = Block;
  v22 = 0i64;
  v18 = Block;
  if ( v17 != Block )
  {
    do
    {
      v19 = (void **)*v17;
      j_free(v17);
      v17 = v19;
      v18 = Block;
    }
    while ( v19 != Block );
  }
  j_free(v18);
  return Menu;
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400C3B00) ----------------------------------------------------
__int64 __fastcall sub_1400C3B00(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // r9
  bool v4; // cf
  unsigned __int64 v5; // r10
  int v6; // eax

  v3 = 0i64;
  *a3 = 0i64;
  v4 = *a2 < 0x11CE74366D5140C1ui64;
  if ( *a2 == 0x11CE74366D5140C1i64 && (v5 = a2[1], v4 = v5 < qword_1400E40E0[1], v5 == qword_1400E40E0[1]) )
    v6 = 0;
  else
    v6 = -v4 - (v4 - 1);
  if ( v6 )
    return 2147500034i64;
  if ( a1 )
    v3 = a1 + 8;
  *a3 = v3;
  if ( !v3 )
    return 2147500034i64;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return 0i64;
}
// 1400E40E0: using guessed type _QWORD qword_1400E40E0[2];

//----- (00000001400C3B60) ----------------------------------------------------
void __fastcall sub_1400C3B60(__int64 a1)
{
  HMODULE v2; // rcx
  _QWORD **v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  _QWORD **v6; // rax
  _QWORD *v7; // rcx
  _QWORD *v8; // rbx
  _QWORD **v9; // rax
  _QWORD *v10; // rcx
  _QWORD *v11; // rbx
  _QWORD **v12; // rax
  _QWORD *v13; // rcx
  _QWORD *v14; // rbx
  _QWORD **v15; // rax
  _QWORD *v16; // rcx
  _QWORD *v17; // rbx
  _QWORD **v18; // rax
  _QWORD *v19; // rcx
  _QWORD *v20; // rbx
  _QWORD **v21; // rax
  _QWORD *v22; // rcx
  _QWORD *v23; // rbx
  _QWORD **v24; // rax
  _QWORD *v25; // rcx
  _QWORD *v26; // rbx
  _QWORD **v27; // rax
  _QWORD *v28; // rcx
  _QWORD *v29; // rbx
  _QWORD **v30; // rax
  _QWORD *v31; // rcx
  _QWORD *v32; // rbx
  _QWORD **v33; // rax
  _QWORD *v34; // rcx
  _QWORD *v35; // rbx
  _QWORD **v36; // rax
  _QWORD *v37; // rcx
  _QWORD *v38; // rbx
  _QWORD **v39; // rax
  _QWORD *v40; // rcx
  _QWORD *v41; // rbx
  _QWORD **v42; // rax
  _QWORD *v43; // rcx
  _QWORD *v44; // rbx
  _QWORD **v45; // rax
  _QWORD *v46; // rcx
  _QWORD *v47; // rbx
  _QWORD **v48; // rax
  _QWORD *v49; // rcx
  _QWORD *v50; // rbx
  _QWORD **v51; // rax
  _QWORD *v52; // rcx
  _QWORD *v53; // rbx
  _QWORD **v54; // rax
  _QWORD *v55; // rcx
  _QWORD *v56; // rbx
  _QWORD *v57; // rcx

  *(_QWORD *)a1 = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 8) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 16) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 24) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 32) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 40) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 48) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 56) = &Explorerplusplus::`vftable';
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2648) + 16i64))(*(_QWORD *)(a1 + 2648));
  v2 = *(HMODULE *)(a1 + 60984);
  if ( v2 )
    FreeLibrary(v2);
  v3 = *(_QWORD ***)(a1 + 63240);
  v4 = *v3;
  *v3 = v3;
  *(_QWORD *)(*(_QWORD *)(a1 + 63240) + 8i64) = *(_QWORD *)(a1 + 63240);
  *(_QWORD *)(a1 + 63248) = 0i64;
  if ( v4 != *(_QWORD **)(a1 + 63240) )
  {
    do
    {
      v5 = (_QWORD *)*v4;
      j_free(v4);
      v4 = v5;
    }
    while ( v5 != *(_QWORD **)(a1 + 63240) );
  }
  j_free(*(void **)(a1 + 63240));
  v6 = *(_QWORD ***)(a1 + 63216);
  v7 = *v6;
  *v6 = v6;
  *(_QWORD *)(*(_QWORD *)(a1 + 63216) + 8i64) = *(_QWORD *)(a1 + 63216);
  *(_QWORD *)(a1 + 63224) = 0i64;
  if ( v7 != *(_QWORD **)(a1 + 63216) )
  {
    do
    {
      v8 = (_QWORD *)*v7;
      j_free(v7);
      v7 = v8;
    }
    while ( v8 != *(_QWORD **)(a1 + 63216) );
  }
  j_free(*(void **)(a1 + 63216));
  v9 = *(_QWORD ***)(a1 + 63192);
  v10 = *v9;
  *v9 = v9;
  *(_QWORD *)(*(_QWORD *)(a1 + 63192) + 8i64) = *(_QWORD *)(a1 + 63192);
  *(_QWORD *)(a1 + 63200) = 0i64;
  if ( v10 != *(_QWORD **)(a1 + 63192) )
  {
    do
    {
      v11 = (_QWORD *)*v10;
      j_free(v10);
      v10 = v11;
    }
    while ( v11 != *(_QWORD **)(a1 + 63192) );
  }
  j_free(*(void **)(a1 + 63192));
  v12 = *(_QWORD ***)(a1 + 63168);
  v13 = *v12;
  *v12 = v12;
  *(_QWORD *)(*(_QWORD *)(a1 + 63168) + 8i64) = *(_QWORD *)(a1 + 63168);
  *(_QWORD *)(a1 + 63176) = 0i64;
  if ( v13 != *(_QWORD **)(a1 + 63168) )
  {
    do
    {
      v14 = (_QWORD *)*v13;
      j_free(v13);
      v13 = v14;
    }
    while ( v14 != *(_QWORD **)(a1 + 63168) );
  }
  j_free(*(void **)(a1 + 63168));
  v15 = *(_QWORD ***)(a1 + 63136);
  v16 = *v15;
  *v15 = v15;
  *(_QWORD *)(*(_QWORD *)(a1 + 63136) + 8i64) = *(_QWORD *)(a1 + 63136);
  *(_QWORD *)(a1 + 63144) = 0i64;
  if ( v16 != *(_QWORD **)(a1 + 63136) )
  {
    do
    {
      v17 = (_QWORD *)*v16;
      j_free(v16);
      v16 = v17;
    }
    while ( v17 != *(_QWORD **)(a1 + 63136) );
  }
  j_free(*(void **)(a1 + 63136));
  sub_14000A630(a1 + 63104);
  j_free(*(void **)(a1 + 63104));
  v18 = *(_QWORD ***)(a1 + 62376);
  v19 = *v18;
  *v18 = v18;
  *(_QWORD *)(*(_QWORD *)(a1 + 62376) + 8i64) = *(_QWORD *)(a1 + 62376);
  *(_QWORD *)(a1 + 62384) = 0i64;
  if ( v19 != *(_QWORD **)(a1 + 62376) )
  {
    do
    {
      v20 = (_QWORD *)*v19;
      j_free(v19);
      v19 = v20;
    }
    while ( v20 != *(_QWORD **)(a1 + 62376) );
  }
  j_free(*(void **)(a1 + 62376));
  v21 = *(_QWORD ***)(a1 + 62352);
  v22 = *v21;
  *v21 = v21;
  *(_QWORD *)(*(_QWORD *)(a1 + 62352) + 8i64) = *(_QWORD *)(a1 + 62352);
  *(_QWORD *)(a1 + 62360) = 0i64;
  if ( v22 != *(_QWORD **)(a1 + 62352) )
  {
    do
    {
      v23 = (_QWORD *)*v22;
      j_free(v22);
      v22 = v23;
    }
    while ( v23 != *(_QWORD **)(a1 + 62352) );
  }
  j_free(*(void **)(a1 + 62352));
  v24 = *(_QWORD ***)(a1 + 62328);
  v25 = *v24;
  *v24 = v24;
  *(_QWORD *)(*(_QWORD *)(a1 + 62328) + 8i64) = *(_QWORD *)(a1 + 62328);
  *(_QWORD *)(a1 + 62336) = 0i64;
  if ( v25 != *(_QWORD **)(a1 + 62328) )
  {
    do
    {
      v26 = (_QWORD *)*v25;
      j_free(v25);
      v25 = v26;
    }
    while ( v26 != *(_QWORD **)(a1 + 62328) );
  }
  j_free(*(void **)(a1 + 62328));
  v27 = *(_QWORD ***)(a1 + 62304);
  v28 = *v27;
  *v27 = v27;
  *(_QWORD *)(*(_QWORD *)(a1 + 62304) + 8i64) = *(_QWORD *)(a1 + 62304);
  *(_QWORD *)(a1 + 62312) = 0i64;
  if ( v28 != *(_QWORD **)(a1 + 62304) )
  {
    do
    {
      v29 = (_QWORD *)*v28;
      j_free(v28);
      v28 = v29;
    }
    while ( v29 != *(_QWORD **)(a1 + 62304) );
  }
  j_free(*(void **)(a1 + 62304));
  v30 = *(_QWORD ***)(a1 + 62280);
  v31 = *v30;
  *v30 = v30;
  *(_QWORD *)(*(_QWORD *)(a1 + 62280) + 8i64) = *(_QWORD *)(a1 + 62280);
  *(_QWORD *)(a1 + 62288) = 0i64;
  if ( v31 != *(_QWORD **)(a1 + 62280) )
  {
    do
    {
      v32 = (_QWORD *)*v31;
      j_free(v31);
      v31 = v32;
    }
    while ( v32 != *(_QWORD **)(a1 + 62280) );
  }
  j_free(*(void **)(a1 + 62280));
  v33 = *(_QWORD ***)(a1 + 62256);
  v34 = *v33;
  *v33 = v33;
  *(_QWORD *)(*(_QWORD *)(a1 + 62256) + 8i64) = *(_QWORD *)(a1 + 62256);
  *(_QWORD *)(a1 + 62264) = 0i64;
  if ( v34 != *(_QWORD **)(a1 + 62256) )
  {
    do
    {
      v35 = (_QWORD *)*v34;
      j_free(v34);
      v34 = v35;
    }
    while ( v35 != *(_QWORD **)(a1 + 62256) );
  }
  j_free(*(void **)(a1 + 62256));
  v36 = *(_QWORD ***)(a1 + 62232);
  v37 = *v36;
  *v36 = v36;
  *(_QWORD *)(*(_QWORD *)(a1 + 62232) + 8i64) = *(_QWORD *)(a1 + 62232);
  *(_QWORD *)(a1 + 62240) = 0i64;
  if ( v37 != *(_QWORD **)(a1 + 62232) )
  {
    do
    {
      v38 = (_QWORD *)*v37;
      j_free(v37);
      v37 = v38;
    }
    while ( v38 != *(_QWORD **)(a1 + 62232) );
  }
  j_free(*(void **)(a1 + 62232));
  v39 = *(_QWORD ***)(a1 + 62200);
  v40 = *v39;
  *v39 = v39;
  *(_QWORD *)(*(_QWORD *)(a1 + 62200) + 8i64) = *(_QWORD *)(a1 + 62200);
  *(_QWORD *)(a1 + 62208) = 0i64;
  if ( v40 != *(_QWORD **)(a1 + 62200) )
  {
    do
    {
      v41 = (_QWORD *)*v40;
      j_free(v40);
      v40 = v41;
    }
    while ( v41 != *(_QWORD **)(a1 + 62200) );
  }
  j_free(*(void **)(a1 + 62200));
  v42 = *(_QWORD ***)(a1 + 62176);
  v43 = *v42;
  *v42 = v42;
  *(_QWORD *)(*(_QWORD *)(a1 + 62176) + 8i64) = *(_QWORD *)(a1 + 62176);
  *(_QWORD *)(a1 + 62184) = 0i64;
  if ( v43 != *(_QWORD **)(a1 + 62176) )
  {
    do
    {
      v44 = (_QWORD *)*v43;
      j_free(v43);
      v43 = v44;
    }
    while ( v44 != *(_QWORD **)(a1 + 62176) );
  }
  j_free(*(void **)(a1 + 62176));
  v45 = *(_QWORD ***)(a1 + 62152);
  v46 = *v45;
  *v45 = v45;
  *(_QWORD *)(*(_QWORD *)(a1 + 62152) + 8i64) = *(_QWORD *)(a1 + 62152);
  *(_QWORD *)(a1 + 62160) = 0i64;
  if ( v46 != *(_QWORD **)(a1 + 62152) )
  {
    do
    {
      v47 = (_QWORD *)*v46;
      j_free(v46);
      v46 = v47;
    }
    while ( v47 != *(_QWORD **)(a1 + 62152) );
  }
  j_free(*(void **)(a1 + 62152));
  sub_14000AA90((void **)(a1 + 62128));
  v48 = *(_QWORD ***)(a1 + 62072);
  v49 = *v48;
  *v48 = v48;
  *(_QWORD *)(*(_QWORD *)(a1 + 62072) + 8i64) = *(_QWORD *)(a1 + 62072);
  *(_QWORD *)(a1 + 62080) = 0i64;
  if ( v49 != *(_QWORD **)(a1 + 62072) )
  {
    do
    {
      v50 = (_QWORD *)*v49;
      j_free(v49);
      v49 = v50;
    }
    while ( v50 != *(_QWORD **)(a1 + 62072) );
  }
  j_free(*(void **)(a1 + 62072));
  sub_14007AA10(a1 + 61040);
  v51 = *(_QWORD ***)(a1 + 61000);
  v52 = *v51;
  *v51 = v51;
  *(_QWORD *)(*(_QWORD *)(a1 + 61000) + 8i64) = *(_QWORD *)(a1 + 61000);
  *(_QWORD *)(a1 + 61008) = 0i64;
  if ( v52 != *(_QWORD **)(a1 + 61000) )
  {
    do
    {
      v53 = (_QWORD *)*v52;
      j_free(v52);
      v52 = v53;
    }
    while ( v53 != *(_QWORD **)(a1 + 61000) );
  }
  j_free(*(void **)(a1 + 61000));
  sub_14000A9C0((void **)(a1 + 60720));
  v54 = *(_QWORD ***)(a1 + 7072);
  v55 = *v54;
  *v54 = v54;
  *(_QWORD *)(*(_QWORD *)(a1 + 7072) + 8i64) = *(_QWORD *)(a1 + 7072);
  *(_QWORD *)(a1 + 7080) = 0i64;
  if ( v55 != *(_QWORD **)(a1 + 7072) )
  {
    do
    {
      v56 = (_QWORD *)*v55;
      j_free(v55);
      v55 = v56;
    }
    while ( v56 != *(_QWORD **)(a1 + 7072) );
  }
  j_free(*(void **)(a1 + 7072));
  v57 = *(_QWORD **)(a1 + 72);
  if ( v57 )
  {
    sub_14000A280(v57, *(_QWORD **)(a1 + 80));
    j_free(*(void **)(a1 + 72));
  }
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
}
// 14007AA10: using guessed type __int64 __fastcall sub_14007AA10(_QWORD);
// 1400F6CC8: using guessed type void *Explorerplusplus::`vftable';
// 1400F6D08: using guessed type void *Explorerplusplus::`vftable';
// 1400F6D38: using guessed type void *Explorerplusplus::`vftable';
// 1400F6DE0: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E10: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E20: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E40: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E58: using guessed type void *Explorerplusplus::`vftable';

//----- (00000001400C4200) ----------------------------------------------------
__int64 __fastcall sub_1400C4200(void *Block)
{
  if ( (*((_DWORD *)Block + 16))-- != 1 )
    return *((unsigned int *)Block + 16);
  sub_1400C3B60((__int64)Block);
  j_free(Block);
  return 0i64;
}

//----- (00000001400C4240) ----------------------------------------------------
__int64 __fastcall sub_1400C4240(__int64 a1, __int64 a2)
{
  __int64 v4; // r9
  __int64 v5; // rdx
  _WORD *v6; // rcx
  __int16 v7; // ax
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  _QWORD *v11; // rax
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rcx
  DWORD dwMajorVersion; // ecx
  __int64 v16; // rsi
  __int64 v17; // rdx
  char *v18; // r11
  __int64 v19; // rcx
  __int64 v20; // rsi
  char *v21; // r11
  __int64 v22; // rcx
  __int64 v23; // rsi
  char *v24; // r11
  __int64 v25; // rcx
  __int64 v26; // rsi
  char *v27; // r11
  __int64 v28; // rcx
  __int64 v29; // rsi
  char *v30; // r11
  __int64 v31; // rcx
  __int64 v32; // rsi
  char *v33; // r11
  __int64 v34; // rcx
  __int64 v35; // rsi
  char *v36; // r11
  __int64 v37; // rcx
  __int64 v38; // rsi
  char *v39; // r11
  __int64 v40; // rax
  char *v41; // r11
  __int64 v42; // rcx
  __int64 v43; // rsi
  char *v44; // r11
  __int64 v45; // rcx
  __int64 v46; // rsi
  char *v47; // r11
  __int64 v48; // rcx
  __int64 v49; // rsi
  char *v50; // r11
  __int64 v51; // rcx
  __int64 v52; // rsi
  char *v53; // r11
  __int64 v54; // rcx
  HMODULE v55; // rax
  char *v57; // [rsp+28h] [rbp-E0h] BYREF
  char *v58; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v59[3]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 pExceptionObject[5]; // [rsp+50h] [rbp-B8h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+78h] [rbp-90h] BYREF

  pExceptionObject[4] = -2i64;
  pExceptionObject[3] = a1;
  *(_QWORD *)a1 = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 8) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 16) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 24) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 32) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 40) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 48) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 56) = &Explorerplusplus::`vftable';
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  v4 = a1 + 2664;
  v5 = 256i64;
  v6 = (_WORD *)(a1 + 2664);
  while ( v5 != -2147483390 )
  {
    v7 = *(_WORD *)((char *)v6 + (_QWORD)L"Bookmarks" - v4);
    if ( !v7 )
      break;
    *v6++ = v7;
    if ( !--v5 )
    {
      --v6;
      break;
    }
  }
  *v6 = 0;
  *(_DWORD *)(v4 + 1540) = 0;
  *(_QWORD *)(v4 + 2080) = 0i64;
  *(_QWORD *)(v4 + 2088) = 0i64;
  *(_QWORD *)(a1 + 7080) = 0i64;
  v8 = operator new(0x18ui64);
  if ( !v8 )
  {
    v58 = 0i64;
    std::exception::exception((std::exception *)v59, (const char *const *)&v58);
    v59[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v59, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 7072) = v8;
  *v8 = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 7072) + 8i64) = *(_QWORD *)(a1 + 7072);
  *(_DWORD *)(a1 + 7100) = -16777216;
  *(_DWORD *)(a1 + 7104) = -16777216;
  *(_QWORD *)(a1 + 60728) = 0i64;
  v9 = operator new(0xC8ui64);
  if ( !v9 )
  {
    v57 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v57);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 60720) = v9;
  *v9 = v9;
  *(_QWORD *)(*(_QWORD *)(a1 + 60720) + 8i64) = *(_QWORD *)(a1 + 60720);
  *(_QWORD *)(a1 + 61008) = 0i64;
  v10 = operator new(0x28ui64);
  if ( !v10 )
  {
    v58 = 0i64;
    std::exception::exception((std::exception *)v59, (const char *const *)&v58);
    v59[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v59, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 61000) = v10;
  *v10 = v10;
  *(_QWORD *)(*(_QWORD *)(a1 + 61000) + 8i64) = *(_QWORD *)(a1 + 61000);
  sub_14001C460((_QWORD *)(a1 + 61040));
  *(_QWORD *)(a1 + 62080) = 0i64;
  v11 = operator new(0x18ui64);
  if ( !v11 )
  {
    v58 = 0i64;
    std::exception::exception((std::exception *)v59, (const char *const *)&v58);
    v59[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(v59, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 62072) = v11;
  *v11 = v11;
  *(_QWORD *)(*(_QWORD *)(a1 + 62072) + 8i64) = *(_QWORD *)(a1 + 62072);
  *(_QWORD *)(a1 + 62136) = 0i64;
  v12 = operator new(0x240ui64);
  if ( !v12 )
  {
    v57 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v57);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 62128) = v12;
  *v12 = v12;
  *(_QWORD *)(*(_QWORD *)(a1 + 62128) + 8i64) = *(_QWORD *)(a1 + 62128);
  sub_14000A910((_QWORD *)(a1 + 62152));
  sub_14000A910((_QWORD *)(a1 + 62176));
  *(_QWORD *)(a1 + 62208) = 0i64;
  v13 = operator new(0x20ui64);
  if ( !v13 )
  {
    v57 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v57);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *(_QWORD *)(a1 + 62200) = v13;
  *v13 = v13;
  *(_QWORD *)(*(_QWORD *)(a1 + 62200) + 8i64) = *(_QWORD *)(a1 + 62200);
  sub_14000AB70((_QWORD *)(a1 + 62232));
  sub_14000AB70((_QWORD *)(a1 + 62256));
  sub_14000AB70((_QWORD *)(a1 + 62280));
  sub_14000AB70((_QWORD *)(a1 + 62304));
  sub_14000AB70((_QWORD *)(a1 + 62328));
  sub_14000AB70((_QWORD *)(a1 + 62352));
  sub_14000AB70((_QWORD *)(a1 + 62376));
  sub_14000A5B0((_QWORD *)(a1 + 63104));
  sub_14000AB00((_QWORD *)(a1 + 63136));
  sub_14000AB00((_QWORD *)(a1 + 63168));
  sub_14000AB00((_QWORD *)(a1 + 63192));
  sub_14000AB00((_QWORD *)(a1 + 63216));
  sub_14000AB00((_QWORD *)(a1 + 63240));
  *(_DWORD *)(a1 + 64) = 1;
  *(_QWORD *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 7060) = 0;
  *(_DWORD *)(a1 + 62416) = 0;
  *(_QWORD *)(a1 + 7048) = 0i64;
  *(_QWORD *)(a1 + 62400) = 0i64;
  *(_QWORD *)(a1 + 62408) = 0i64;
  *(_QWORD *)(a1 + 7016) = 0i64;
  *(_DWORD *)(a1 + 62472) = 0;
  *(_QWORD *)(a1 + 60812) = 0i64;
  *(_QWORD *)(a1 + 7032) = 0i64;
  *(_DWORD *)(a1 + 62464) = 0;
  *(_QWORD *)(a1 + 62448) = 0i64;
  *(_DWORD *)(a1 + 62456) = 0;
  *(_QWORD *)(a1 + 2640) = 0i64;
  hDlg = 0i64;
  hWnd = 0i64;
  *(_DWORD *)(a1 + 62424) = -1;
  *(_DWORD *)(a1 + 62096) = 0;
  *(_DWORD *)(a1 + 63264) = 0;
  *(_DWORD *)(a1 + 63068) = 0;
  *(_DWORD *)(a1 + 63092) = 0;
  *(_DWORD *)(a1 + 63080) = 0;
  *(_QWORD *)(a1 + 60992) = 0i64;
  *(_DWORD *)(a1 + 63280) = 0;
  sub_1400D5D60(a1);
  sub_1400C3490(a1);
  sub_1400B2090(v14);
  memset((void *)(a1 + 60320), 0, 0x190ui64);
  sub_14007E090(17, (LPWSTR)(a1 + 5440));
  sub_14007E090(17, (LPWSTR)(a1 + 5960));
  sub_1400C3640(a1);
  *(_QWORD *)(a1 + 62104) = 0i64;
  *(_QWORD *)(a1 + 62120) = 0i64;
  InitializeCriticalSection(&stru_14012D7C0);
  *(_DWORD *)(a1 + 62224) = 0;
  *(_QWORD *)(a1 + 62432) = 0i64;
  *(_DWORD *)(a1 + 63128) = 0;
  *(_QWORD *)(a1 + 62440) = 0i64;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( GetVersionExW(&VersionInformation) )
  {
    dwMajorVersion = VersionInformation.dwMajorVersion;
    *(_DWORD *)(a1 + 7004) = VersionInformation.dwMajorVersion;
    *(_DWORD *)(a1 + 7008) = VersionInformation.dwMinorVersion;
    v16 = *(_QWORD *)(a1 + 7072);
    v17 = *(_QWORD *)(v16 + 8);
    if ( dwMajorVersion < 6 )
    {
      LODWORD(v57) = 6;
      v41 = sub_1400246F0(v16, v17, &v57);
      v42 = *(_QWORD *)(a1 + 7080);
      if ( v42 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v42 + 1;
      *(_QWORD *)(v16 + 8) = v41;
      **((_QWORD **)v41 + 1) = v41;
      LODWORD(v57) = 5;
      v43 = *(_QWORD *)(a1 + 7072);
      v44 = sub_1400246F0(v43, *(_QWORD *)(v43 + 8), &v57);
      v45 = *(_QWORD *)(a1 + 7080);
      if ( v45 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v45 + 1;
      *(_QWORD *)(v43 + 8) = v44;
      **((_QWORD **)v44 + 1) = v44;
      LODWORD(v57) = 1;
      v46 = *(_QWORD *)(a1 + 7072);
      v47 = sub_1400246F0(v46, *(_QWORD *)(v46 + 8), &v57);
      v48 = *(_QWORD *)(a1 + 7080);
      if ( v48 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v48 + 1;
      *(_QWORD *)(v46 + 8) = v47;
      **((_QWORD **)v47 + 1) = v47;
      LODWORD(v57) = 2;
      v49 = *(_QWORD *)(a1 + 7072);
      v50 = sub_1400246F0(v49, *(_QWORD *)(v49 + 8), &v57);
      v51 = *(_QWORD *)(a1 + 7080);
      if ( v51 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v51 + 1;
      *(_QWORD *)(v49 + 8) = v50;
      **((_QWORD **)v50 + 1) = v50;
      LODWORD(v57) = 3;
      v52 = *(_QWORD *)(a1 + 7072);
      v53 = sub_1400246F0(v52, *(_QWORD *)(v52 + 8), &v57);
      v54 = *(_QWORD *)(a1 + 7080);
      if ( v54 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v54 + 1;
      *(_QWORD *)(v52 + 8) = v53;
      **((_QWORD **)v53 + 1) = v53;
      LODWORD(v57) = 4;
      v38 = *(_QWORD *)(a1 + 7072);
      v39 = sub_1400246F0(v38, *(_QWORD *)(v38 + 8), &v57);
      v40 = *(_QWORD *)(a1 + 7080);
      if ( 0x3FFFFFFFFFFFFFFEi64 == v40 )
        sub_14002B5F8("list<T> too long");
    }
    else
    {
      LODWORD(v57) = 7;
      v18 = sub_1400246F0(v16, v17, &v57);
      v19 = *(_QWORD *)(a1 + 7080);
      if ( v19 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v19 + 1;
      *(_QWORD *)(v16 + 8) = v18;
      **((_QWORD **)v18 + 1) = v18;
      LODWORD(v57) = 8;
      v20 = *(_QWORD *)(a1 + 7072);
      v21 = sub_1400246F0(v20, *(_QWORD *)(v20 + 8), &v57);
      v22 = *(_QWORD *)(a1 + 7080);
      if ( v22 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v22 + 1;
      *(_QWORD *)(v20 + 8) = v21;
      **((_QWORD **)v21 + 1) = v21;
      LODWORD(v57) = 1;
      v23 = *(_QWORD *)(a1 + 7072);
      v24 = sub_1400246F0(v23, *(_QWORD *)(v23 + 8), &v57);
      v25 = *(_QWORD *)(a1 + 7080);
      if ( v25 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v25 + 1;
      *(_QWORD *)(v23 + 8) = v24;
      **((_QWORD **)v24 + 1) = v24;
      LODWORD(v57) = 2;
      v26 = *(_QWORD *)(a1 + 7072);
      v27 = sub_1400246F0(v26, *(_QWORD *)(v26 + 8), &v57);
      v28 = *(_QWORD *)(a1 + 7080);
      if ( v28 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v28 + 1;
      *(_QWORD *)(v26 + 8) = v27;
      **((_QWORD **)v27 + 1) = v27;
      LODWORD(v57) = 3;
      v29 = *(_QWORD *)(a1 + 7072);
      v30 = sub_1400246F0(v29, *(_QWORD *)(v29 + 8), &v57);
      v31 = *(_QWORD *)(a1 + 7080);
      if ( v31 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v31 + 1;
      *(_QWORD *)(v29 + 8) = v30;
      **((_QWORD **)v30 + 1) = v30;
      LODWORD(v57) = 4;
      v32 = *(_QWORD *)(a1 + 7072);
      v33 = sub_1400246F0(v32, *(_QWORD *)(v32 + 8), &v57);
      v34 = *(_QWORD *)(a1 + 7080);
      if ( v34 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v34 + 1;
      *(_QWORD *)(v32 + 8) = v33;
      **((_QWORD **)v33 + 1) = v33;
      LODWORD(v57) = 6;
      v35 = *(_QWORD *)(a1 + 7072);
      v36 = sub_1400246F0(v35, *(_QWORD *)(v35 + 8), &v57);
      v37 = *(_QWORD *)(a1 + 7080);
      if ( v37 == 0x3FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      *(_QWORD *)(a1 + 7080) = v37 + 1;
      *(_QWORD *)(v35 + 8) = v36;
      **((_QWORD **)v36 + 1) = v36;
      LODWORD(v57) = 5;
      v38 = *(_QWORD *)(a1 + 7072);
      v39 = sub_1400246F0(v38, *(_QWORD *)(v38 + 8), &v57);
      v40 = *(_QWORD *)(a1 + 7080);
      if ( 0x3FFFFFFFFFFFFFFEi64 == v40 )
        sub_14002B5F8("list<T> too long");
    }
    *(_QWORD *)(a1 + 7080) = v40 + 1;
    *(_QWORD *)(v38 + 8) = v39;
    **((_QWORD **)v39 + 1) = v39;
  }
  v55 = sub_14000AF70(L"dwmapi.dll");
  *(_QWORD *)(a1 + 60984) = v55;
  if ( v55 )
    *(_QWORD *)(a1 + 60976) = GetProcAddress(v55, "DwmInvalidateIconicBitmaps");
  else
    *(_QWORD *)(a1 + 60976) = 0i64;
  return a1;
}
// 1400C4328: conditional instruction was optimized away because rdx.8!=0
// 1400C4604: variable 'v14' is possibly undefined
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 1400EBFF8: using guessed type wchar_t aBookmarks_1[10];
// 1400F6CC8: using guessed type void *Explorerplusplus::`vftable';
// 1400F6D08: using guessed type void *Explorerplusplus::`vftable';
// 1400F6D38: using guessed type void *Explorerplusplus::`vftable';
// 1400F6DE0: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E10: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E20: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E40: using guessed type void *Explorerplusplus::`vftable';
// 1400F6E58: using guessed type void *Explorerplusplus::`vftable';

//----- (00000001400C4D10) ----------------------------------------------------
LRESULT __fastcall sub_1400C4D10(__int64 a1)
{
  LRESULT result; // rax
  __int64 v3; // rdi
  WPARAM v4; // rbx
  LPARAM lParam[4]; // [rsp+30h] [rbp-2F8h] BYREF
  SHFILEINFOW psfi; // [rsp+50h] [rbp-2D8h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 1016), 0x418u, 0i64, 0i64);
  if ( (int)result > 0 )
  {
    v3 = (unsigned int)result;
    v4 = 0i64;
    do
    {
      result = SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v4, (LPARAM)lParam);
      if ( result )
      {
        SHGetFileInfoW((LPCWSTR)lParam[2], 0, &psfi, 0x2B8u, 0x4000u);
        result = SendMessageW(*(HWND *)(a1 + 1016), 0x42Bu, SHIDWORD(lParam[0]), psfi.iIcon);
      }
      ++v4;
      --v3;
    }
    while ( v3 );
  }
  return result;
}

//----- (00000001400C4E10) ----------------------------------------------------
int __fastcall sub_1400C4E10(__int64 a1, const WCHAR *a2)
{
  LRESULT v4; // rax
  int v5; // ebx
  int v6; // edi
  LPARAM lParam[4]; // [rsp+30h] [rbp-308h] BYREF
  SHFILEINFOW psfi; // [rsp+50h] [rbp-2E8h] BYREF

  LODWORD(v4) = SendMessageW(*(HWND *)(a1 + 1016), 0x418u, 0i64, 0i64);
  v5 = 0;
  v6 = v4;
  if ( (int)v4 > 0 )
  {
    while ( 1 )
    {
      v4 = SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v5, (LPARAM)lParam);
      if ( v4 )
      {
        LODWORD(v4) = lstrcmpiW(a2, (LPCWSTR)lParam[2]);
        if ( !(_DWORD)v4 )
          break;
      }
      if ( ++v5 >= v6 )
        return v4;
    }
    SHGetFileInfoW(a2, 0, &psfi, 0x2B8u, 0x4000u);
    LODWORD(v4) = SendMessageW(*(HWND *)(a1 + 1016), 0x42Bu, SHIDWORD(lParam[0]), psfi.iIcon);
  }
  return v4;
}

//----- (00000001400C4F00) ----------------------------------------------------
LRESULT __fastcall sub_1400C4F00(__int64 a1, const WCHAR *a2)
{
  int v4; // ebx
  int v5; // esi
  LRESULT v6; // rdi
  LPARAM lParam[4]; // [rsp+20h] [rbp-48h] BYREF

  v4 = 0;
  v5 = SendMessageW(*(HWND *)(a1 + 1016), 0x418u, 0i64, 0i64);
  if ( v5 <= 0 )
    return 0i64;
  while ( 1 )
  {
    v6 = SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v4, (LPARAM)lParam);
    if ( v6 )
    {
      if ( !lstrcmpW(a2, (LPCWSTR)lParam[2]) )
        break;
    }
    if ( ++v4 >= v5 )
      return v6;
  }
  return SendMessageW(*(HWND *)(a1 + 1016), 0x416u, v4, 0i64);
}

//----- (00000001400C4FE0) ----------------------------------------------------
LRESULT __fastcall sub_1400C4FE0(__int64 a1, const WCHAR *a2)
{
  int v3; // edi
  WCHAR *v5; // r8
  __int64 v6; // r9
  WCHAR v7; // ax
  int v8; // eax
  WCHAR *v9; // r13
  int v10; // eax
  int v11; // ebx
  int v12; // er12
  HWND v13; // rcx
  int v14; // eax
  LRESULT result; // rax
  LPARAM lParam; // [rsp+30h] [rbp-358h] BYREF
  __int16 v17; // [rsp+38h] [rbp-350h]
  LPCWSTR lpString2; // [rsp+40h] [rbp-348h]
  WCHAR *v19; // [rsp+48h] [rbp-340h]
  SHFILEINFOW psfi; // [rsp+50h] [rbp-338h] BYREF
  WCHAR String[32]; // [rsp+310h] [rbp-78h] BYREF

  v3 = 0;
  v5 = String;
  v6 = 32i64;
  while ( v6 != -2147483614 )
  {
    v7 = *(WCHAR *)((char *)v5 + (char *)a2 - (char *)String);
    if ( !v7 )
      break;
    *v5++ = v7;
    if ( !--v6 )
    {
      --v5;
      break;
    }
  }
  *v5 = 0;
  if ( String[lstrlenW(String) - 1] == 92 )
    String[lstrlenW(String) - 1] = 0;
  SHGetFileInfoW(a2, 0, &psfi, 0x2B8u, 0x4010u);
  v8 = lstrlenW(a2);
  v9 = (WCHAR *)malloc(2i64 * (v8 + 1));
  v10 = lstrlenW(a2);
  sub_140001240(v9, v10 + 1, (__int64)a2);
  v11 = 0;
  v12 = SendMessageW(*(HWND *)(a1 + 1016), 0x418u, 0i64, 0i64);
  if ( v12 > 0 )
  {
    do
    {
      if ( SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v11, (LPARAM)&lParam) )
      {
        if ( lstrcmpW(a2, lpString2) < 0 )
          break;
        ++v3;
      }
      ++v11;
    }
    while ( v11 < v12 );
  }
  v13 = *(HWND *)(a1 + 1016);
  LODWORD(lParam) = psfi.iIcon;
  v14 = *(_DWORD *)(a1 + 62096);
  v17 = 20484;
  HIDWORD(lParam) = v14 + 47000;
  lpString2 = v9;
  v19 = String;
  result = SendMessageW(v13, 0x443u, v3, (LPARAM)&lParam);
  if ( result )
    ++*(_DWORD *)(a1 + 62096);
  return result;
}
// 1400C5049: conditional instruction was optimized away because r9.8!=0

//----- (00000001400C51C0) ----------------------------------------------------
void __fastcall sub_1400C51C0(__int64 a1)
{
  DWORD LogicalDriveStringsW; // ebx
  WCHAR *v3; // rax
  WCHAR *v4; // r14
  const WCHAR *i; // rbp
  int v6; // esi
  __int64 v7; // rdx
  WCHAR *v8; // rcx
  WCHAR v9; // ax
  int v10; // eax
  const WCHAR *v11; // r13
  int v12; // eax
  __int64 v13; // rdx
  WCHAR *v14; // rcx
  __int64 v15; // r8
  WCHAR v16; // ax
  int v17; // ebx
  int v18; // edi
  HWND v19; // rcx
  int v20; // eax
  HIMAGELIST phimlSmall; // [rsp+30h] [rbp-368h] BYREF
  LPARAM lParam; // [rsp+38h] [rbp-360h] BYREF
  __int16 v23; // [rsp+40h] [rbp-358h]
  LPCWSTR lpString2; // [rsp+48h] [rbp-350h]
  WCHAR *v25; // [rsp+50h] [rbp-348h]
  SHFILEINFOW psfi; // [rsp+60h] [rbp-338h] BYREF
  WCHAR String[32]; // [rsp+320h] [rbp-78h] BYREF

  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(*(HWND *)(a1 + 1016), 0x430u, 0i64, (LPARAM)phimlSmall);
  LogicalDriveStringsW = GetLogicalDriveStringsW(0, 0i64);
  v3 = (WCHAR *)malloc(2i64 * (LogicalDriveStringsW + 1));
  v4 = v3;
  if ( v3 )
  {
    if ( GetLogicalDriveStringsW(LogicalDriveStringsW, v3) )
    {
      for ( i = v4; *i; i += lstrlenW(i) + 1 )
      {
        v6 = 0;
        v7 = 32i64;
        v8 = String;
        while ( v7 != -2147483614 )
        {
          v9 = *(WCHAR *)((char *)v8 + (char *)i - (char *)String);
          if ( !v9 )
            break;
          *v8++ = v9;
          if ( !--v7 )
          {
            --v8;
            break;
          }
        }
        *v8 = 0;
        if ( String[lstrlenW(String) - 1] == 92 )
          String[lstrlenW(String) - 1] = 0;
        SHGetFileInfoW(i, 0, &psfi, 0x2B8u, 0x4010u);
        v10 = lstrlenW(i);
        v11 = (const WCHAR *)malloc(2i64 * (v10 + 1));
        v12 = lstrlenW(i) + 1;
        v13 = v12;
        if ( v12 && (unsigned __int64)v12 <= 0x7FFFFFFF )
        {
          v14 = (WCHAR *)v11;
          v15 = 2147483646i64 - v12;
          while ( v15 + v13 )
          {
            v16 = *(WCHAR *)((char *)v14 + (char *)i - (char *)v11);
            if ( !v16 )
              break;
            *v14++ = v16;
            if ( !--v13 )
              goto LABEL_19;
          }
          if ( v13 )
            goto LABEL_20;
LABEL_19:
          --v14;
LABEL_20:
          *v14 = 0;
        }
        v17 = 0;
        v18 = SendMessageW(*(HWND *)(a1 + 1016), 0x418u, 0i64, 0i64);
        if ( v18 > 0 )
        {
          do
          {
            if ( SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v17, (LPARAM)&lParam) )
            {
              if ( lstrcmpW(i, lpString2) < 0 )
                break;
              ++v6;
            }
            ++v17;
          }
          while ( v17 < v18 );
        }
        v19 = *(HWND *)(a1 + 1016);
        LODWORD(lParam) = psfi.iIcon;
        v20 = *(_DWORD *)(a1 + 62096);
        v23 = 20484;
        HIDWORD(lParam) = v20 + 47000;
        lpString2 = v11;
        v25 = String;
        if ( SendMessageW(v19, 0x443u, v6, (LPARAM)&lParam) )
          ++*(_DWORD *)(a1 + 62096);
      }
    }
    free(v4);
  }
}
// 1400C52C7: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400C54E0) ----------------------------------------------------
__int64 __fastcall sub_1400C54E0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  DWORD MessagePos; // eax
  HWND v10; // rdx
  int v11; // eax
  struct tagPOINT Points; // [rsp+30h] [rbp-58h] BYREF
  LPARAM lParam[4]; // [rsp+38h] [rbp-50h] BYREF

  if ( a3 == 520 )
  {
    MessagePos = GetMessagePos();
    v10 = *(HWND *)(a1 + 1016);
    Points.x = (__int16)MessagePos;
    Points.y = SHIWORD(MessagePos);
    MapWindowPoints(0i64, v10, &Points, 1u);
    v11 = SendMessageW(*(HWND *)(a1 + 1016), 0x445u, 0i64, (LPARAM)&Points);
    if ( v11 >= 0 )
    {
      if ( SendMessageW(*(HWND *)(a1 + 1016), 0x417u, v11, (LPARAM)lParam) )
        sub_1400B0C20(a1, lParam[2], 0, 1u, 1);
    }
  }
  return sub_140001A20(a2, a3, a4, a5);
}

//----- (00000001400C55D0) ----------------------------------------------------
__int64 __fastcall sub_1400C55D0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  return sub_1400C54E0(a6, a1, a2, a3, a4);
}

//----- (00000001400C5600) ----------------------------------------------------
__int64 __fastcall sub_1400C5600(_DWORD *a1, HWND a2)
{
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetWindowRect(a2, &Rect);
  result = (unsigned int)Rect.top;
  a1[15774] = Rect.left;
  a1[15775] = result;
  a1[15773] = 1;
  return result;
}

//----- (00000001400C5670) ----------------------------------------------------
LRESULT __fastcall sub_1400C5670(HWND hDlg, HWND hWnd)
{
  HWND v4; // rdi
  LPARAM v5; // rbp
  HWND DlgItem; // rax
  HWND v7; // rcx
  int v8; // edx
  HWND v9; // rax
  HWND v10; // rax
  HWND v11; // rax
  HWND v12; // rax
  unsigned __int8 v13; // di
  unsigned __int8 v14; // bl
  unsigned __int8 v15; // al
  unsigned __int8 v16; // di
  unsigned __int8 v17; // bl
  unsigned __int8 v18; // al
  WCHAR String[32]; // [rsp+30h] [rbp-68h] BYREF

  v4 = 0i64;
  GetWindowTextW(hWnd, String, 32);
  v5 = (int)sub_14004B61C(String);
  DlgItem = GetDlgItem(hDlg, 1105);
  v7 = hDlg;
  if ( hWnd == DlgItem )
  {
    v8 = 1104;
LABEL_13:
    v4 = GetDlgItem(v7, v8);
    goto LABEL_14;
  }
  v9 = GetDlgItem(hDlg, 1106);
  v7 = hDlg;
  if ( hWnd == v9 )
  {
    v8 = 1102;
    goto LABEL_13;
  }
  v10 = GetDlgItem(hDlg, 1107);
  v7 = hDlg;
  if ( hWnd == v10 )
  {
    v8 = 1103;
    goto LABEL_13;
  }
  v11 = GetDlgItem(hDlg, 1111);
  v7 = hDlg;
  if ( hWnd == v11 )
  {
    v8 = 1108;
    goto LABEL_13;
  }
  v12 = GetDlgItem(hDlg, 1112);
  v7 = hDlg;
  if ( hWnd == v12 )
  {
    v8 = 1109;
    goto LABEL_13;
  }
  if ( hWnd == GetDlgItem(hDlg, 1113) )
  {
    v8 = 1110;
    v7 = hDlg;
    goto LABEL_13;
  }
LABEL_14:
  SendMessageW(v4, 0x405u, 1ui64, v5);
  v13 = SendDlgItemMessageW(hDlg, 1104, 0x400u, 0i64, 0i64);
  v14 = SendDlgItemMessageW(hDlg, 1102, 0x400u, 0i64, 0i64);
  v15 = SendDlgItemMessageW(hDlg, 1103, 0x400u, 0i64, 0i64);
  SendMessageW(qword_14012D7B8, 0x8068u, v13 | (v14 << 8) | (v15 << 16), 0i64);
  v16 = SendDlgItemMessageW(hDlg, 1108, 0x400u, 0i64, 0i64);
  v17 = SendDlgItemMessageW(hDlg, 1109, 0x400u, 0i64, 0i64);
  v18 = SendDlgItemMessageW(hDlg, 1110, 0x400u, 0i64, 0i64);
  return SendMessageW(qword_14012D7B8, 0x806Cu, v16 | (v17 << 8) | (v18 << 16), 0i64);
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (00000001400C58B0) ----------------------------------------------------
UINT __fastcall sub_1400C58B0(HWND hDlg)
{
  UINT v2; // ebp
  UINT v3; // edi
  UINT v4; // esi
  UINT v5; // ebp
  UINT v6; // edi
  UINT v7; // esi
  UINT result; // eax

  v2 = SendDlgItemMessageW(hDlg, 1104, 0x400u, 0i64, 0i64);
  v3 = SendDlgItemMessageW(hDlg, 1102, 0x400u, 0i64, 0i64);
  v4 = SendDlgItemMessageW(hDlg, 1103, 0x400u, 0i64, 0i64);
  if ( GetDlgItemInt(hDlg, 1105, 0i64, 0) != v2 )
    SetDlgItemInt(hDlg, 1105, v2, 0);
  if ( GetDlgItemInt(hDlg, 1106, 0i64, 0) != v3 )
    SetDlgItemInt(hDlg, 1106, v3, 0);
  if ( GetDlgItemInt(hDlg, 1107, 0i64, 0) != v4 )
    SetDlgItemInt(hDlg, 1107, v4, 0);
  v5 = SendDlgItemMessageW(hDlg, 1108, 0x400u, 0i64, 0i64);
  v6 = SendDlgItemMessageW(hDlg, 1109, 0x400u, 0i64, 0i64);
  v7 = SendDlgItemMessageW(hDlg, 1110, 0x400u, 0i64, 0i64);
  if ( GetDlgItemInt(hDlg, 1111, 0i64, 0) != v5 )
    SetDlgItemInt(hDlg, 1111, v5, 0);
  if ( GetDlgItemInt(hDlg, 1112, 0i64, 0) != v6 )
    SetDlgItemInt(hDlg, 1112, v6, 0);
  result = GetDlgItemInt(hDlg, 1113, 0i64, 0);
  if ( result != v7 )
    return SetDlgItemInt(hDlg, 1113, v7, 0);
  return result;
}

//----- (00000001400C5AB0) ----------------------------------------------------
BOOL __fastcall sub_1400C5AB0(__int64 a1, HWND a2)
{
  unsigned __int8 v4; // di
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // al
  unsigned __int8 v7; // di
  unsigned __int8 v8; // bl
  unsigned __int8 v9; // al
  LONG top; // eax
  struct tagRECT Rect; // [rsp+30h] [rbp-38h] BYREF

  v4 = SendDlgItemMessageW(a2, 1104, 0x400u, 0i64, 0i64);
  v5 = SendDlgItemMessageW(a2, 1102, 0x400u, 0i64, 0i64);
  v6 = SendDlgItemMessageW(a2, 1103, 0x400u, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x8068u, v4 | (v5 << 8) | (v6 << 16), 0i64);
  v7 = SendDlgItemMessageW(a2, 1108, 0x400u, 0i64, 0i64);
  v8 = SendDlgItemMessageW(a2, 1109, 0x400u, 0i64, 0i64);
  v9 = SendDlgItemMessageW(a2, 1110, 0x400u, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x806Cu, v7 | (v8 << 8) | (v9 << 16), 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x8070u, wParam, 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x8072u, (unsigned int)dword_14012D73C, 0i64);
  GetWindowRect(a2, &Rect);
  top = Rect.top;
  *(_DWORD *)(a1 + 63096) = Rect.left;
  *(_DWORD *)(a1 + 63100) = top;
  *(_DWORD *)(a1 + 63092) = 1;
  return EndDialog(a2, 1i64);
}

//----- (00000001400C5C80) ----------------------------------------------------
LRESULT __fastcall sub_1400C5C80(__int64 a1)
{
  HFONT FontIndirectW; // rax
  __int64 wParam[2]; // [rsp+20h] [rbp-4F8h] BYREF
  int v5; // [rsp+30h] [rbp-4E8h] BYREF
  __int64 v6; // [rsp+38h] [rbp-4E0h]
  LOGFONTW *lplf; // [rsp+48h] [rbp-4D0h]
  int v8; // [rsp+54h] [rbp-4C4h]
  int v9; // [rsp+58h] [rbp-4C0h]
  __int64 v10; // [rsp+60h] [rbp-4B8h]
  char *v11; // [rsp+80h] [rbp-498h]
  char pv[96]; // [rsp+A0h] [rbp-478h] BYREF
  char v13; // [rsp+100h] [rbp-418h] BYREF

  SendMessageW(qword_14012D7B8, 0x806Fu, (WPARAM)wParam, 0i64);
  GetObjectW((HANDLE)wParam[0], 92, pv);
  lplf = (LOGFONTW *)pv;
  v5 = 104;
  v6 = a1;
  v8 = 65857;
  v9 = SendMessageW(qword_14012D7B8, 0x8071u, 0i64, 0i64);
  v10 = 0i64;
  v11 = &v13;
  sub_14000A830((__int64)&v5);
  FontIndirectW = CreateFontIndirectW(lplf);
  LODWORD(dword_14012D73C) = v9;
  ::wParam = (WPARAM)FontIndirectW;
  SendMessageW(qword_14012D7B8, 0x8070u, (WPARAM)FontIndirectW, 0i64);
  return SendMessageW(qword_14012D7B8, 0x8072u, (unsigned int)dword_14012D73C, 0i64);
}
// 1400C5C80: using guessed type WPARAM wParam[2];

//----- (00000001400C5DA0) ----------------------------------------------------
BOOL __fastcall sub_1400C5DA0(__int64 a1, HWND a2)
{
  int *v4; // rbx
  int *v5; // rbx
  unsigned int v6; // ebp
  unsigned int v7; // esi
  HWND DlgItem; // r12
  HMODULE ModuleHandleW; // rax
  HICON ImageW; // rax
  int v11; // ecx
  int v12; // ecx
  HMODULE v13; // rax
  HWND v14; // rax
  int v16; // [rsp+50h] [rbp-78h] BYREF
  int v17; // [rsp+54h] [rbp-74h]
  int v18; // [rsp+58h] [rbp-70h]
  __int64 v19; // [rsp+60h] [rbp-68h]
  HICON v20; // [rsp+68h] [rbp-60h]
  struct tagRECT Rect; // [rsp+70h] [rbp-58h] BYREF

  dword_14012D788 = 1108;
  dword_14012D78C = 1111;
  dword_14012D798 = 1109;
  dword_14012D79C = 1112;
  dword_14012D7A8 = 1110;
  dword_14012D7AC = 1113;
  dword_14012D758 = 1104;
  dword_14012D75C = 1105;
  dword_14012D768 = 1102;
  dword_14012D76C = 1106;
  dword_14012D778 = 1103;
  dword_14012D77C = 1107;
  v4 = &dword_14012D758;
  do
  {
    SendDlgItemMessageW(a2, *v4, 0x414u, 0xAui64, 0i64);
    SendDlgItemMessageW(a2, *v4, 0x406u, 1ui64, 16711680i64);
    SendDlgItemMessageW(a2, v4[1], 0xC5u, 3ui64, 0i64);
    v4 += 4;
  }
  while ( (__int64)v4 < (__int64)&dword_14012D788 );
  v5 = &dword_14012D788;
  do
  {
    SendDlgItemMessageW(a2, *v5, 0x414u, 0xAui64, 0i64);
    SendDlgItemMessageW(a2, *v5, 0x406u, 1ui64, 16711680i64);
    SendDlgItemMessageW(a2, v5[1], 0xC5u, 3ui64, 0i64);
    v5 += 4;
  }
  while ( (__int64)v5 < (__int64)&qword_14012D7B8 );
  v6 = SendMessageW(*(HWND *)(a1 + 128), 0x8067u, 0i64, 0i64);
  v7 = SendMessageW(*(HWND *)(a1 + 128), 0x806Bu, 0i64, 0i64);
  SendMessageW(*(HWND *)(a1 + 128), 0x806Fu, (WPARAM)&wParam, 0i64);
  LODWORD(dword_14012D73C) = SendMessageW(*(HWND *)(a1 + 128), 0x8071u, 0i64, 0i64);
  v16 = -16777216;
  v17 = -16777216;
  DlgItem = GetDlgItem(a2, 1118);
  ModuleHandleW = GetModuleHandleW(0i64);
  ImageW = (HICON)LoadImageW(ModuleHandleW, (LPCWSTR)0x6A, 1u, 0, 0, 0x2000u);
  v16 = *(_DWORD *)(a1 + 7100);
  v11 = *(_DWORD *)(a1 + 7104);
  qword_14012D748 = ImageW;
  v17 = v11;
  v12 = *(_DWORD *)(a1 + 7108);
  v20 = ImageW;
  v18 = v12;
  v19 = *(_QWORD *)(a1 + 7112);
  sub_14001CE90();
  v13 = GetModuleHandleW(0i64);
  v14 = sub_14001A730(L"DisplayWindow", &word_1400F7CF8, 0x54000000u, 0, 0, 0, 0, DlgItem, v13, &v16);
  *(_QWORD *)(a1 + 2632) = 0i64;
  qword_14012D7B8 = v14;
  SetDlgItemInt(a2, 1105, (unsigned __int8)v6, 0);
  SetDlgItemInt(a2, 1106, BYTE1(v6), 0);
  SetDlgItemInt(a2, 1107, BYTE2(v6), 0);
  SendDlgItemMessageW(a2, 1104, 0x405u, 1ui64, (unsigned __int8)v6);
  SendDlgItemMessageW(a2, 1102, 0x405u, 1ui64, BYTE1(v6));
  SendDlgItemMessageW(a2, 1103, 0x405u, 1ui64, BYTE2(v6));
  SetDlgItemInt(a2, 1111, (unsigned __int8)v7, 0);
  SetDlgItemInt(a2, 1112, BYTE1(v7), 0);
  SetDlgItemInt(a2, 1113, BYTE2(v7), 0);
  SendDlgItemMessageW(a2, 1108, 0x405u, 1ui64, (unsigned __int8)v7);
  SendDlgItemMessageW(a2, 1109, 0x405u, 1ui64, BYTE1(v7));
  SendDlgItemMessageW(a2, 1110, 0x405u, 1ui64, BYTE2(v7));
  SendMessageW(qword_14012D7B8, 0x8068u, v6, 0i64);
  SendMessageW(qword_14012D7B8, 0x806Cu, v7, 0i64);
  SendMessageW(qword_14012D7B8, 0x8070u, wParam, 0i64);
  SendMessageW(qword_14012D7B8, 0x8072u, (unsigned int)dword_14012D73C, 0i64);
  SendMessageW(qword_14012D7B8, 0x8074u, 0i64, 0i64);
  SendMessageW(qword_14012D7B8, 0x8073u, 0i64, (LPARAM)L"Filename");
  SendMessageW(qword_14012D7B8, 0x8073u, 0i64, (LPARAM)L"File Type");
  SendMessageW(qword_14012D7B8, 0x8073u, 0i64, (LPARAM)L"Modification Date");
  GetWindowRect(DlgItem, &Rect);
  SetWindowPos(qword_14012D7B8, 0i64, 0, 0, Rect.right, Rect.bottom, 0x44u);
  if ( *(_DWORD *)(a1 + 63092) )
    return SetWindowPos(a2, 0i64, *(_DWORD *)(a1 + 63096), *(_DWORD *)(a1 + 63100), 0, 0, 5u);
  else
    return sub_140081E00(*(HWND *)(a1 + 104), a2);
}
// 14012D758: using guessed type int dword_14012D758;
// 14012D75C: using guessed type int dword_14012D75C;
// 14012D768: using guessed type int dword_14012D768;
// 14012D76C: using guessed type int dword_14012D76C;
// 14012D778: using guessed type int dword_14012D778;
// 14012D77C: using guessed type int dword_14012D77C;
// 14012D788: using guessed type int dword_14012D788;
// 14012D78C: using guessed type int dword_14012D78C;
// 14012D798: using guessed type int dword_14012D798;
// 14012D79C: using guessed type int dword_14012D79C;
// 14012D7A8: using guessed type int dword_14012D7A8;
// 14012D7AC: using guessed type int dword_14012D7AC;

//----- (00000001400C6360) ----------------------------------------------------
__int64 __fastcall sub_1400C6360(HWND hDlg, int a2, int a3, HWND a4)
{
  int v4; // edx
  __int64 v5; // rbx
  __int16 v6; // di
  int v8; // edx
  int v9; // edx
  int v10; // edx
  unsigned int v12; // esi
  unsigned int v13; // er13
  HFONT FontW; // rax
  HWND v15; // rcx

  v4 = a2 - 2;
  v5 = qword_14012E150;
  v6 = a3;
  if ( v4 )
  {
    v8 = v4 - 14;
    if ( !v8 )
    {
      sub_1400C5600((_DWORD *)qword_14012E150, hDlg);
      EndDialog(hDlg, 0i64);
      return 0i64;
    }
    v9 = v8 - 256;
    if ( !v9 )
    {
      sub_1400C5DA0(qword_14012E150, hDlg);
      return 0i64;
    }
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 3 )
      {
        sub_1400C58B0(hDlg);
        return 0i64;
      }
    }
    else
    {
      if ( HIWORD(a3) == 768 )
        sub_1400C5670(hDlg, a4);
      switch ( v6 )
      {
        case 1:
          sub_1400C5AB0(v5, hDlg);
          return 0i64;
        case 2:
          sub_1400C5600((_DWORD *)v5, hDlg);
          EndDialog(hDlg, 0i64);
          return 0i64;
        case 1055:
          sub_1400C5C80((__int64)hDlg);
          return 0i64;
        case 1217:
          *(_DWORD *)(v5 + 7104) = -16753014;
          *(_DWORD *)(v5 + 7100) = -1;
          v12 = (*(unsigned __int8 *)(v5 + 7104) << 16) | (unsigned __int8)BYTE2(*(_DWORD *)(v5 + 7104)) | ((unsigned __int8)BYTE1(*(_DWORD *)(v5 + 7104)) << 8);
          v13 = (*(unsigned __int8 *)(v5 + 7100) << 16) | (unsigned __int8)BYTE2(*(_DWORD *)(v5 + 7100)) | ((unsigned __int8)BYTE1(*(_DWORD *)(v5 + 7100)) << 8);
          FontW = CreateFontW(-13, 0, 0, 0, 500, 0, 0, 0, 1u, 0, 0, 2u, 0x31u, L"Segoe UI");
          v15 = qword_14012D7B8;
          *(_QWORD *)(v5 + 7112) = FontW;
          wParam = (WPARAM)FontW;
          SendMessageW(v15, 0x8068u, v12, 0i64);
          SendMessageW(qword_14012D7B8, 0x806Cu, v13, 0i64);
          SendMessageW(qword_14012D7B8, 0x8070u, wParam, 0i64);
          SendMessageW(qword_14012D7B8, 0x8072u, (unsigned int)dword_14012D73C, 0i64);
          SetDlgItemInt(hDlg, 1105, (unsigned __int8)v12, 0);
          SetDlgItemInt(hDlg, 1106, BYTE1(v12), 0);
          SetDlgItemInt(hDlg, 1107, BYTE2(v12), 0);
          SendDlgItemMessageW(hDlg, 1104, 0x405u, 1ui64, (unsigned __int8)v12);
          SendDlgItemMessageW(hDlg, 1102, 0x405u, 1ui64, BYTE1(v12));
          SendDlgItemMessageW(hDlg, 1103, 0x405u, 1ui64, BYTE2(v12));
          SetDlgItemInt(hDlg, 1111, (unsigned __int8)v13, 0);
          SetDlgItemInt(hDlg, 1112, BYTE1(v13), 0);
          SetDlgItemInt(hDlg, 1113, BYTE2(v13), 0);
          SendDlgItemMessageW(hDlg, 1108, 0x405u, 1ui64, (unsigned __int8)v13);
          SendDlgItemMessageW(hDlg, 1109, 0x405u, 1ui64, BYTE1(v13));
          SendDlgItemMessageW(hDlg, 1110, 0x405u, 1ui64, BYTE2(v13));
          SendMessageW(qword_14012D7B8, 0x8068u, v12, 0i64);
          SendMessageW(qword_14012D7B8, 0x806Cu, v13, 0i64);
          SendMessageW(qword_14012D7B8, 0x8070u, wParam, 0i64);
          SendMessageW(qword_14012D7B8, 0x8072u, (unsigned int)dword_14012D73C, 0i64);
          return 0i64;
      }
    }
  }
  else
  {
    DestroyIcon(qword_14012D748);
  }
  return 0i64;
}
// 14012E150: using guessed type __int64 qword_14012E150;

//----- (00000001400C67E0) ----------------------------------------------------
INT_PTR __fastcall sub_1400C67E0(HWND hDlg, int a2, int a3, HWND a4)
{
  HWND v4; // rax

  v4 = (HWND)qword_14012E150;
  if ( a2 == 272 )
    v4 = a4;
  qword_14012E150 = (__int64)v4;
  return sub_1400C6360(hDlg, a2, a3, a4);
}
// 14012E150: using guessed type __int64 qword_14012E150;

//----- (00000001400C6800) ----------------------------------------------------
int __fastcall sub_1400C6800(__int64 a1, const WCHAR *a2, __int64 a3)
{
  int result; // eax

  result = lstrcmpiW(a2, L"OverwriteMethod");
  if ( !result )
  {
    result = sub_14004B61C(a3);
    *(_DWORD *)(a1 + 544) = result;
  }
  return result;
}
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);

//----- (00000001400C6850) ----------------------------------------------------
LSTATUS __fastcall sub_1400C6850(__int64 a1, HKEY a2)
{
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF

  cbData = 4;
  return RegQueryValueExW(a2, L"OverwriteMethod", 0i64, 0i64, (LPBYTE)(a1 + 544), &cbData);
}

//----- (00000001400C68A0) ----------------------------------------------------
LSTATUS __fastcall sub_1400C68A0(__int64 a1, HKEY a2)
{
  int Data; // [rsp+40h] [rbp+8h] BYREF

  Data = *(_DWORD *)(a1 + 544);
  return RegSetValueExW(a2, L"OverwriteMethod", 0, 4u, (const BYTE *)&Data, 4u);
}

//----- (00000001400C6930) ----------------------------------------------------
__int64 __fastcall sub_1400C6930(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 104));
  return 0i64;
}

//----- (00000001400C6950) ----------------------------------------------------
__int64 __fastcall sub_1400C6950(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400C6970) ----------------------------------------------------
HGDIOBJ __fastcall sub_1400C6970(__int64 a1, HWND a2, HDC a3)
{
  if ( a2 != GetDlgItem(*(HWND *)(a1 + 8), 1305) )
    return 0i64;
  SetTextColor(a3, 0xFFu);
  SetBkMode(a3, 1);
  return GetStockObject(5);
}

//----- (00000001400C69E0) ----------------------------------------------------
HRESULT __fastcall sub_1400C69E0(__int64 a1, __int64 *a2, __int64 a3)
{
  itow_s(*(_DWORD *)(a1 + 544), Buffer, 0x40ui64, 10);
  return sub_14007BEA0(a2, a3, L"OverwriteMethod", Buffer);
}
// 1400F4868: using guessed type wchar_t aOverwritemetho_2[16];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (00000001400C6A40) ----------------------------------------------------
__int64 __fastcall sub_1400C6A40(__int64 a1)
{
  __int64 v1; // rbx
  LONG top; // edx
  LONG left; // er11
  LONG right; // eax
  bool v6; // zf
  __int64 v7; // rax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 112);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  left = Rect.left;
  right = Rect.right;
  *(_QWORD *)(v1 + 12) = *(_QWORD *)&Rect.left;
  *(_DWORD *)(v1 + 20) = right - left;
  *(_DWORD *)(v1 + 24) = Rect.bottom - top;
  v6 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1073) == 1;
  v7 = *(_QWORD *)(a1 + 112);
  if ( v6 )
    *(_DWORD *)(v7 + 544) = 1;
  else
    *(_DWORD *)(v7 + 544) = 2;
  result = *(_QWORD *)(a1 + 112);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400C6AF0) ----------------------------------------------------
__int64 *sub_1400C6AF0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax

  v0 = &unk_14012FAAC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"DestroyFiles" - (char *)&unk_14012FAAC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012FA98 = 0;
  qword_14012FA90 = (__int64)&CDestroyFilesDialogPersistentSettings::`vftable';
  byte_14012FCAC = 1;
  dword_14012FCB0 = 1;
  return &qword_14012FA90;
}
// 1400C6B37: conditional instruction was optimized away because rdx.8!=0
// 1400F47F0: using guessed type wchar_t aDestroyfiles_0[13];
// 1400F6C88: using guessed type void *CDestroyFilesDialogPersistentSettings::`vftable';
// 14012FA90: using guessed type __int64 qword_14012FA90;
// 14012FA98: using guessed type int dword_14012FA98;
// 14012FCAC: using guessed type char byte_14012FCAC;
// 14012FCB0: using guessed type int dword_14012FCB0;

//----- (00000001400C6B80) ----------------------------------------------------
char **__fastcall sub_1400C6B80(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rsi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rdx
  char *v10; // r11
  __int64 v11; // rax
  __int64 v12; // rsi
  char *v13; // r11
  __int64 v14; // rax
  __int64 v15; // rsi
  char *v16; // r11
  __int64 v17; // rax
  __int64 v18; // rsi
  char *v19; // r11
  __int64 v20; // rax
  __int64 v21; // rsi
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  __int64 v25; // rdx
  char *v26; // r11
  __int64 v27; // rax
  __int64 v28; // rsi
  char *v29; // r11
  __int64 v30; // rax
  __int64 v31; // rsi
  char *v32; // r11
  __int64 v33; // rax
  __int64 v34; // rsi
  char *v35; // r11
  __int64 v36; // rax
  char **result; // rax
  _BYTE v38[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v38 = 1145;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_QWORD *)&v38[4] = 1i64;
  v6 = sub_140017AD0(v4, v5, v38);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v38 = 1306;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v38[4] = 1;
  v9 = *(_QWORD *)(v8 + 8);
  *(_DWORD *)&v38[8] = 1;
  v10 = sub_140017AD0(v8, v9, v38);
  v11 = a3[1];
  if ( v11 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1306i64;
  a3[1] = v11 + 1;
  *(_QWORD *)(v8 + 8) = v10;
  **((_QWORD **)v10 + 1) = v10;
  v12 = *a3;
  *(_DWORD *)&v38[8] = 2;
  v13 = sub_140017AD0(v12, *(_QWORD *)(v12 + 8), v38);
  v14 = a3[1];
  if ( v14 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1073i64;
  a3[1] = v14 + 1;
  *(_QWORD *)(v12 + 8) = v13;
  **((_QWORD **)v13 + 1) = v13;
  v15 = *a3;
  *(_DWORD *)&v38[8] = 2;
  v16 = sub_140017AD0(v15, *(_QWORD *)(v15 + 8), v38);
  v17 = a3[1];
  if ( v17 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1074i64;
  a3[1] = v17 + 1;
  *(_QWORD *)(v15 + 8) = v16;
  **((_QWORD **)v16 + 1) = v16;
  v18 = *a3;
  *(_DWORD *)&v38[8] = 2;
  v19 = sub_140017AD0(v18, *(_QWORD *)(v18 + 8), v38);
  v20 = a3[1];
  if ( v20 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1305i64;
  a3[1] = v20 + 1;
  *(_QWORD *)(v18 + 8) = v19;
  **((_QWORD **)v19 + 1) = v19;
  v21 = *a3;
  *(_DWORD *)&v38[8] = 2;
  v22 = sub_140017AD0(v21, *(_QWORD *)(v21 + 8), v38);
  v23 = a3[1];
  if ( v23 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_DWORD *)v38 = 1305;
  a3[1] = v23 + 1;
  *(_QWORD *)(v21 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *a3;
  *(_DWORD *)&v38[4] = 1;
  v25 = *(_QWORD *)(v24 + 8);
  *(_DWORD *)&v38[8] = 1;
  v26 = sub_140017AD0(v24, v25, v38);
  v27 = a3[1];
  if ( v27 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1i64;
  a3[1] = v27 + 1;
  *(_QWORD *)(v24 + 8) = v26;
  **((_QWORD **)v26 + 1) = v26;
  v28 = *a3;
  *(_DWORD *)&v38[8] = 0;
  v29 = sub_140017AD0(v28, *(_QWORD *)(v28 + 8), v38);
  v30 = a3[1];
  if ( v30 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 2i64;
  a3[1] = v30 + 1;
  *(_QWORD *)(v28 + 8) = v29;
  **((_QWORD **)v29 + 1) = v29;
  v31 = *a3;
  *(_DWORD *)&v38[8] = 0;
  v32 = sub_140017AD0(v31, *(_QWORD *)(v31 + 8), v38);
  v33 = a3[1];
  if ( v33 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v38 = 1304i64;
  a3[1] = v33 + 1;
  *(_QWORD *)(v31 + 8) = v32;
  **((_QWORD **)v32 + 1) = v32;
  v34 = *a3;
  *(_DWORD *)&v38[8] = 0;
  v35 = sub_140017AD0(v34, *(_QWORD *)(v34 + 8), v38);
  v36 = a3[1];
  if ( 0x1555555555555554i64 == v36 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v36 + 1;
  *(_QWORD *)(v34 + 8) = v35;
  result = (char **)*((_QWORD *)v35 + 1);
  *result = v35;
  return result;
}

//----- (00000001400C6F20) ----------------------------------------------------
void __fastcall sub_1400C6F20(__int64 a1)
{
  __int64 v2; // rcx

  v2 = a1 + 80;
  *(_QWORD *)(v2 - 80) = &CDestroyFilesDialog::`vftable';
  sub_14000A630(v2);
  j_free(*(void **)(a1 + 80));
  sub_140084540((_QWORD *)a1);
}
// 1400F6C18: using guessed type void *CDestroyFilesDialog::`vftable';

//----- (00000001400C6F70) ----------------------------------------------------
__int64 *sub_1400C6F70()
{
  if ( (dword_140130C88 & 1) == 0 )
  {
    dword_140130C88 |= 1u;
    sub_1400C6AF0();
    atexit(sub_1400E1E70);
  }
  return &qword_14012FA90;
}
// 14012FA90: using guessed type __int64 qword_14012FA90;
// 140130C88: using guessed type int dword_140130C88;

//----- (00000001400C6FB0) ----------------------------------------------------
BOOL __fastcall sub_1400C6FB0(__int64 a1)
{
  UINT v2; // eax
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  BOOL i; // ebp
  void *Block[3]; // [rsp+20h] [rbp-48h] BYREF
  unsigned __int64 v8; // [rsp+38h] [rbp-30h]

  v2 = IsDlgButtonChecked(*(HWND *)(a1 + 8), 1073);
  v3 = *(_QWORD **)(a1 + 80);
  v4 = (_QWORD *)*v3;
  for ( i = v2 != 1; v4 != v3; v4 = (_QWORD *)*v4 )
  {
    v8 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    sub_140009610(Block, v4 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    sub_1400D3120((LPCWSTR)Block, i + 1);
    if ( v8 >= 8 )
      j_free(Block[0]);
  }
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (00000001400C7090) ----------------------------------------------------
BOOL __fastcall sub_1400C7090(__int64 a1)
{
  WCHAR Buffer[128]; // [rsp+20h] [rbp-118h] BYREF

  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x855u, Buffer, 128);
  if ( MessageBoxW(*(HWND *)(a1 + 8), Buffer, L"Explorer++", 0x10134u) == 6 )
    return sub_1400C6FB0(a1);
  else
    return EndDialog(*(HWND *)(a1 + 8), 0i64);
}

//----- (00000001400C7120) ----------------------------------------------------
__int64 __fastcall sub_1400C7120(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    sub_1400C7090(a1);
  }
  else if ( a2 == 2 )
  {
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
  return 0i64;
}

//----- (00000001400C7160) ----------------------------------------------------
__int64 __fastcall sub_1400C7160(__int64 a1, __int64 a2, void **a3, int a4)
{
  __int64 **v7; // r13
  _QWORD *v8; // rdi
  _QWORD *v9; // rbx

  *(_QWORD *)(a1 + 16) = hInstance;
  *(_DWORD *)(a1 + 24) = 170;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 52) = 1;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CDestroyFilesDialog::`vftable';
  v7 = (__int64 **)(a1 + 80);
  sub_14000A5B0((_QWORD *)(a1 + 80));
  if ( v7 != (__int64 **)a3 )
  {
    v8 = *a3;
    v9 = *(_QWORD **)*a3;
    sub_14000A630((__int64)v7);
    sub_14000A6B0((__int64)v7, **v7, v9, v8);
  }
  *(_DWORD *)(a1 + 120) = a4;
  if ( (dword_140130C88 & 1) == 0 )
  {
    dword_140130C88 |= 1u;
    sub_1400C6AF0();
    atexit(sub_1400E1E70);
  }
  *(_QWORD *)(a1 + 112) = &qword_14012FA90;
  sub_14000A630((__int64)a3);
  j_free(*a3);
  return a1;
}
// 1400F6C18: using guessed type void *CDestroyFilesDialog::`vftable';
// 14012FA90: using guessed type __int64 qword_14012FA90;
// 140130C88: using guessed type int dword_140130C88;

//----- (00000001400C7250) ----------------------------------------------------
__int64 __fastcall sub_1400C7250(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HICON IconW; // rax
  HWND DlgItem; // rsi
  int v5; // er13
  _QWORD *v6; // r14
  _QWORD *i; // rbx
  void **v8; // r8
  __int64 v9; // rdx
  WCHAR *v10; // rcx
  signed __int64 v11; // r8
  WCHAR v12; // ax
  int v13; // edx
  HWND v14; // rbx
  _DWORD *v15; // rdx
  HWND Parent; // rax
  int lParam[4]; // [rsp+50h] [rbp-B8h] BYREF
  WCHAR *v19; // [rsp+60h] [rbp-A8h]
  HIMAGELIST phimlSmall[2]; // [rsp+78h] [rbp-90h] BYREF
  LPARAM v21; // [rsp+88h] [rbp-80h] BYREF
  int v22; // [rsp+90h] [rbp-78h]
  char *szTypeName; // [rsp+A0h] [rbp-68h]
  _DWORD v24[6]; // [rsp+D8h] [rbp-30h] BYREF
  WCHAR *v25; // [rsp+F0h] [rbp-18h]
  int iIcon; // [rsp+FCh] [rbp-Ch]
  void *Block[3]; // [rsp+128h] [rbp+20h] BYREF
  unsigned __int64 v28; // [rsp+140h] [rbp+38h]
  char FileInformation[20]; // [rsp+150h] [rbp+48h] BYREF
  FILETIME v30; // [rsp+164h] [rbp+5Ch] BYREF
  unsigned int v31; // [rsp+16Ch] [rbp+64h]
  unsigned int v32; // [rsp+170h] [rbp+68h]
  SHFILEINFOW psfi; // [rsp+178h] [rbp+70h] BYREF
  char v34[64]; // [rsp+438h] [rbp+330h] BYREF
  char v35[64]; // [rsp+478h] [rbp+370h] BYREF
  WCHAR Buffer[128]; // [rsp+4B8h] [rbp+3B0h] BYREF
  WCHAR pszPath[264]; // [rsp+5B8h] [rbp+4B0h] BYREF

  phimlSmall[1] = (HIMAGELIST)-2i64;
  ModuleHandleW = GetModuleHandleW(0i64);
  IconW = LoadIconW(ModuleHandleW, (LPCWSTR)0xCE);
  *(_QWORD *)(a1 + 104) = IconW;
  SetClassLongPtrW(*(HWND *)(a1 + 8), -34, (LONG_PTR)IconW);
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1145);
  Shell_GetImageLists(0i64, phimlSmall);
  SendMessageW(DlgItem, 0x1003u, 1ui64, (LPARAM)phimlSmall[0]);
  SetWindowTheme(DlgItem, L"Explorer", 0i64);
  SendMessageW(DlgItem, 0x1036u, 0x10021ui64, 65569i64);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x856u, Buffer, 128);
  lParam[0] = 4;
  v19 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 0i64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x857u, Buffer, 128);
  lParam[0] = 4;
  v19 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 1ui64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x858u, Buffer, 128);
  lParam[0] = 4;
  v19 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 2ui64, (LPARAM)lParam);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x859u, Buffer, 128);
  lParam[0] = 4;
  v19 = Buffer;
  SendMessageW(DlgItem, 0x1061u, 3ui64, (LPARAM)lParam);
  v5 = 0;
  v6 = *(_QWORD **)(a1 + 80);
  for ( i = (_QWORD *)*v6; i != v6; i = (_QWORD *)*i )
  {
    v28 = 7i64;
    Block[2] = 0i64;
    LOWORD(Block[0]) = 0;
    sub_140009610(Block, i + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
    v8 = Block;
    if ( v28 >= 8 )
      v8 = (void **)Block[0];
    v9 = 260i64;
    v10 = pszPath;
    v11 = (char *)v8 - (char *)pszPath;
    while ( v9 != -2147483386 )
    {
      v12 = *(WCHAR *)((char *)v10 + v11);
      if ( !v12 )
        break;
      *v10++ = v12;
      if ( !--v9 )
      {
        --v10;
        break;
      }
    }
    *v10 = 0;
    SHGetFileInfoW(pszPath, 0, &psfi, 0x2B8u, 0x4400u);
    v24[0] = 3;
    v24[1] = v5;
    v24[2] = 0;
    v25 = pszPath;
    iIcon = psfi.iIcon;
    SendMessageW(DlgItem, 0x104Du, 0i64, (LPARAM)v24);
    v22 = 1;
    szTypeName = (char *)psfi.szTypeName;
    SendMessageW(DlgItem, 0x1074u, v5, (LPARAM)&v21);
    GetFileAttributesExW(pszPath, GetFileExInfoStandard, FileInformation);
    sub_140083DE0(__SPAIR64__(v31, v32), v34, 0x20ui64, 0, 0);
    v22 = 2;
    szTypeName = v34;
    SendMessageW(DlgItem, 0x1074u, v5, (LPARAM)&v21);
    sub_1400835A0(&v30, v35, 32, *(_DWORD *)(a1 + 120));
    v22 = 3;
    szTypeName = v35;
    SendMessageW(DlgItem, 0x1074u, v5++, (LPARAM)&v21);
    if ( v28 >= 8 )
      j_free(Block[0]);
  }
  SendMessageW(DlgItem, 0x101Eu, 0i64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 1ui64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 2ui64, 65534i64);
  SendMessageW(DlgItem, 0x101Eu, 3ui64, 65534i64);
  if ( *(_DWORD *)(*(_QWORD *)(a1 + 112) + 544i64) == 1 )
  {
    v13 = 1073;
  }
  else
  {
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 112) + 544i64) != 2 )
      goto LABEL_17;
    v13 = 1074;
  }
  CheckDlgButton(*(HWND *)(a1 + 8), v13, 1u);
LABEL_17:
  v14 = *(HWND *)(a1 + 8);
  v15 = *(_DWORD **)(a1 + 112);
  if ( v15[2] )
  {
    SetWindowPos(v14, 0i64, v15[3], v15[4], v15[5], v15[6], 4u);
  }
  else
  {
    Parent = GetParent(v14);
    sub_140081E00(Parent, v14);
  }
  return 0i64;
}
// 1400C74D7: conditional instruction was optimized away because rdx.8!=0
// 1400C7250: using guessed type _DWORD lParam[4];
// 1400C7250: using guessed type char FileInformation[20];

//----- (00000001400C77A0) ----------------------------------------------------
__int64 __fastcall sub_1400C77A0(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 80));
  return 0i64;
}

//----- (00000001400C77C0) ----------------------------------------------------
__int64 __fastcall sub_1400C77C0(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400C77E0) ----------------------------------------------------
__int64 __fastcall sub_1400C77E0(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 96);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 96);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400C7860) ----------------------------------------------------
char **__fastcall sub_1400C7860(__int64 a1, _DWORD *a2, __int64 *a3)
{
  __int64 v4; // rdi
  __int64 v5; // rdx
  char *v6; // r11
  __int64 v7; // rax
  __int64 v8; // rdi
  char *v9; // r11
  __int64 v10; // rax
  __int64 v11; // rdi
  char *v12; // r11
  __int64 v13; // rax
  __int64 v14; // rdi
  char *v15; // r11
  __int64 v16; // rax
  __int64 v17; // rdi
  char *v18; // r11
  __int64 v19; // rax
  __int64 v20; // rdi
  char *v21; // r11
  __int64 v22; // rax
  __int64 v23; // rdi
  char *v24; // r11
  __int64 v25; // rax
  __int64 v26; // rdi
  char *v27; // r11
  __int64 v28; // rax
  __int64 v29; // rdi
  char *v30; // r11
  __int64 v31; // rax
  char **result; // rax
  _BYTE v33[12]; // [rsp+20h] [rbp-10h] BYREF

  *(_DWORD *)v33 = 1245;
  *a2 = 0;
  v4 = *a3;
  v5 = *(_QWORD *)(*a3 + 8);
  *(_QWORD *)&v33[4] = 1i64;
  v6 = sub_140017AD0(v4, v5, v33);
  v7 = a3[1];
  if ( v7 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1232i64;
  a3[1] = v7 + 1;
  *(_QWORD *)(v4 + 8) = v6;
  **((_QWORD **)v6 + 1) = v6;
  v8 = *a3;
  *(_DWORD *)&v33[8] = 1;
  v9 = sub_140017AD0(v8, *(_QWORD *)(v8 + 8), v33);
  v10 = a3[1];
  if ( v10 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1234i64;
  a3[1] = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  **((_QWORD **)v9 + 1) = v9;
  v11 = *a3;
  *(_DWORD *)&v33[8] = 1;
  v12 = sub_140017AD0(v11, *(_QWORD *)(v11 + 8), v33);
  v13 = a3[1];
  if ( v13 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1233i64;
  a3[1] = v13 + 1;
  *(_QWORD *)(v11 + 8) = v12;
  **((_QWORD **)v12 + 1) = v12;
  v14 = *a3;
  *(_DWORD *)&v33[8] = 1;
  v15 = sub_140017AD0(v14, *(_QWORD *)(v14 + 8), v33);
  v16 = a3[1];
  if ( v16 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1237i64;
  a3[1] = v16 + 1;
  *(_QWORD *)(v14 + 8) = v15;
  **((_QWORD **)v15 + 1) = v15;
  v17 = *a3;
  *(_DWORD *)&v33[8] = 1;
  v18 = sub_140017AD0(v17, *(_QWORD *)(v17 + 8), v33);
  v19 = a3[1];
  if ( v19 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1243i64;
  a3[1] = v19 + 1;
  *(_QWORD *)(v17 + 8) = v18;
  **((_QWORD **)v18 + 1) = v18;
  v20 = *a3;
  *(_DWORD *)&v33[8] = 1;
  v21 = sub_140017AD0(v20, *(_QWORD *)(v20 + 8), v33);
  v22 = a3[1];
  if ( v22 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1i64;
  a3[1] = v22 + 1;
  *(_QWORD *)(v20 + 8) = v21;
  **((_QWORD **)v21 + 1) = v21;
  v23 = *a3;
  *(_DWORD *)&v33[8] = 0;
  v24 = sub_140017AD0(v23, *(_QWORD *)(v23 + 8), v33);
  v25 = a3[1];
  if ( v25 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 2i64;
  a3[1] = v25 + 1;
  *(_QWORD *)(v23 + 8) = v24;
  **((_QWORD **)v24 + 1) = v24;
  v26 = *a3;
  *(_DWORD *)&v33[8] = 0;
  v27 = sub_140017AD0(v26, *(_QWORD *)(v26 + 8), v33);
  v28 = a3[1];
  if ( v28 == 0x1555555555555554i64 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)v33 = 1304i64;
  a3[1] = v28 + 1;
  *(_QWORD *)(v26 + 8) = v27;
  **((_QWORD **)v27 + 1) = v27;
  v29 = *a3;
  *(_DWORD *)&v33[8] = 0;
  v30 = sub_140017AD0(v29, *(_QWORD *)(v29 + 8), v33);
  v31 = a3[1];
  if ( 0x1555555555555554i64 == v31 )
    sub_14002B5F8("list<T> too long");
  a3[1] = v31 + 1;
  *(_QWORD *)(v29 + 8) = v30;
  result = (char **)*((_QWORD *)v30 + 1);
  *result = v30;
  return result;
}

//----- (00000001400C7BC0) ----------------------------------------------------
__int64 *sub_1400C7BC0()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  __int64 *result; // rax

  v0 = &unk_14012FCDC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"CustomizeColors" - (char *)&unk_14012FCDC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  *v0 = 0;
  dword_14012FCC8 = 0;
  qword_14012FCC0 = (__int64)&CCustomizeColorsDialogPersistentSettings::`vftable';
  result = &qword_14012FCC0;
  byte_14012FEDC = 1;
  return result;
}
// 1400C7C07: conditional instruction was optimized away because rdx.8!=0
// 1400F48C0: using guessed type wchar_t aCustomizecolor_0[16];
// 1400F6BB8: using guessed type void *CCustomizeColorsDialogPersistentSettings::`vftable';
// 14012FCC0: using guessed type __int64 qword_14012FCC0;
// 14012FCC8: using guessed type int dword_14012FCC8;
// 14012FEDC: using guessed type char byte_14012FEDC;

//----- (00000001400C7C40) ----------------------------------------------------
__int64 __fastcall sub_1400C7C40(HWND hWnd, char *a2, int a3)
{
  char *v5; // r9
  __int64 v6; // rdx
  char *v7; // rcx
  signed __int64 v8; // r9
  __int16 v9; // ax
  __int64 result; // rax
  int v11; // er11
  char *v12; // r8
  __int64 v13; // rdx
  char *v14; // rcx
  signed __int64 v15; // r8
  __int16 v16; // ax
  WPARAM v17; // rbx
  LPARAM v18; // [rsp+20h] [rbp-4B8h] BYREF
  int v19; // [rsp+28h] [rbp-4B0h]
  char *v20; // [rsp+38h] [rbp-4A0h]
  _DWORD lParam[6]; // [rsp+70h] [rbp-468h] BYREF
  char *v22; // [rsp+88h] [rbp-450h]
  char v23[1024]; // [rsp+C0h] [rbp-418h] BYREF

  if ( *((_QWORD *)a2 + 3) < 8ui64 )
    v5 = a2;
  else
    v5 = *(char **)a2;
  v6 = 512i64;
  v7 = v23;
  v8 = v5 - v23;
  while ( v6 != -2147483134 )
  {
    v9 = *(_WORD *)&v7[v8];
    if ( !v9 )
      break;
    *(_WORD *)v7 = v9;
    v7 += 2;
    if ( !--v6 )
    {
      v7 -= 2;
      break;
    }
  }
  lParam[1] = a3;
  *(_WORD *)v7 = 0;
  lParam[0] = 1;
  v22 = v23;
  lParam[2] = 0;
  result = SendMessageW(hWnd, 0x104Du, 0i64, (LPARAM)lParam);
  v11 = result;
  if ( (_DWORD)result != -1 )
  {
    v12 = a2 + 40;
    if ( *((_QWORD *)a2 + 8) >= 8ui64 )
      v12 = *(char **)v12;
    v13 = 512i64;
    v14 = v23;
    v15 = v12 - v23;
    while ( v13 != -2147483134 )
    {
      v16 = *(_WORD *)&v14[v15];
      if ( !v16 )
        break;
      *(_WORD *)v14 = v16;
      v14 += 2;
      if ( !--v13 )
      {
        v14 -= 2;
        break;
      }
    }
    *(_WORD *)v14 = 0;
    v17 = v11;
    v19 = 1;
    v20 = v23;
    SendMessageW(hWnd, 0x1074u, v11, (LPARAM)&v18);
    sub_140082FB0(*((_DWORD *)a2 + 20), v23, 0x200u);
    v20 = v23;
    v19 = 2;
    return SendMessageW(hWnd, 0x1074u, v17, (LPARAM)&v18);
  }
  return result;
}
// 1400C7CB8: conditional instruction was optimized away because rdx.8!=0
// 1400C7D57: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400C7E00) ----------------------------------------------------
__int64 *sub_1400C7E00()
{
  if ( (dword_140130C8C & 1) == 0 )
  {
    dword_140130C8C |= 1u;
    sub_1400C7BC0();
    atexit(sub_1400E1E60);
  }
  return &qword_14012FCC0;
}
// 14012FCC0: using guessed type __int64 qword_14012FCC0;
// 140130C8C: using guessed type int dword_140130C8C;

//----- (00000001400C7E40) ----------------------------------------------------
__int64 __fastcall sub_1400C7E40(__int64 a1, __int64 a2, __int64 a3)
{
  HINSTANCE v3; // rax
  int v5; // eax

  v3 = hInstance;
  *(_DWORD *)(a1 + 24) = 228;
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CCustomizeColorsDialog::`vftable';
  v5 = dword_140130C8C;
  *(_BYTE *)(a1 + 52) = 1;
  *(_QWORD *)(a1 + 88) = a3;
  if ( (v5 & 1) == 0 )
  {
    dword_140130C8C = v5 | 1;
    sub_1400C7BC0();
    atexit(sub_1400E1E60);
  }
  *(_QWORD *)(a1 + 96) = &qword_14012FCC0;
  return a1;
}
// 1400F6B48: using guessed type void *CCustomizeColorsDialog::`vftable';
// 14012FCC0: using guessed type __int64 qword_14012FCC0;
// 140130C8C: using guessed type int dword_140130C8C;

//----- (00000001400C7EC0) ----------------------------------------------------
void __fastcall sub_1400C7EC0(__int64 a1, int a2)
{
  HINSTANCE v2; // r10
  HWND v3; // r8
  WPARAM v4; // r12
  __int64 v5; // rdx
  __int64 v7; // rsi
  HWND DlgItem; // rdi
  char *v9; // r8
  __int64 v10; // rdx
  char *v11; // rcx
  signed __int64 v12; // r8
  __int16 v13; // ax
  _QWORD *v14; // r11
  char *v15; // r8
  __int64 v16; // rdx
  char *v17; // rcx
  signed __int64 v18; // r8
  __int16 v19; // ax
  __int64 v20; // rdi
  _QWORD **v21; // rax
  _QWORD *v22; // rcx
  _QWORD *v23; // rbx
  __int64 dwInitParam[2]; // [rsp+30h] [rbp-D0h] BYREF
  HINSTANCE v25; // [rsp+40h] [rbp-C0h]
  int v26; // [rsp+48h] [rbp-B8h]
  HWND hWndParent; // [rsp+50h] [rbp-B0h]
  int v28; // [rsp+60h] [rbp-A0h]
  char v29; // [rsp+64h] [rbp-9Ch]
  __int64 v30; // [rsp+78h] [rbp-88h]
  int v31; // [rsp+80h] [rbp-80h]
  __int64 v32; // [rsp+88h] [rbp-78h]
  __int64 *v33; // [rsp+98h] [rbp-68h]
  LPARAM lParam; // [rsp+A0h] [rbp-60h] BYREF
  int v35; // [rsp+A8h] [rbp-58h]
  char *v36; // [rsp+B8h] [rbp-48h]
  char v37[1024]; // [rsp+F0h] [rbp-10h] BYREF

  v2 = *(HINSTANCE *)(a1 + 16);
  v3 = *(HWND *)(a1 + 8);
  v4 = a2;
  v5 = **(_QWORD **)(a1 + 88);
  v25 = v2;
  v26 = 220;
  hWndParent = v3;
  v7 = 88 * v4;
  v29 = 0;
  v32 = 88 * v4 + v5;
  v30 = 0i64;
  v28 = 0;
  dwInitParam[0] = (__int64)&CColorRuleDialog::`vftable';
  v31 = 1;
  if ( (dword_140130C90 & 1) == 0 )
  {
    dword_140130C90 |= 1u;
    sub_1400C9140();
    atexit(sub_1400E1E50);
    v3 = hWndParent;
    v2 = v25;
  }
  v33 = &qword_14012FEE0;
  if ( DialogBoxParamW(v2, (LPCWSTR)(unsigned __int16)v26, v3, (DLGPROC)DialogFunc, (LPARAM)dwInitParam) == 1 )
  {
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1245);
    v9 = (char *)(v7 + **(_QWORD **)(a1 + 88));
    if ( *((_QWORD *)v9 + 3) >= 8ui64 )
      v9 = *(char **)v9;
    v10 = 512i64;
    v11 = v37;
    v12 = v9 - v37;
    while ( v10 != -2147483134 )
    {
      v13 = *(_WORD *)&v11[v12];
      if ( !v13 )
        break;
      *(_WORD *)v11 = v13;
      v11 += 2;
      if ( !--v10 )
      {
        v11 -= 2;
        break;
      }
    }
    *(_WORD *)v11 = 0;
    v36 = v37;
    v35 = 0;
    SendMessageW(DlgItem, 0x1074u, v4, (LPARAM)&lParam);
    v14 = *(_QWORD **)(a1 + 88);
    v15 = (char *)(*v14 + v7 + 40);
    if ( *(_QWORD *)(*v14 + v7 + 64) >= 8ui64 )
      v15 = *(char **)v15;
    v16 = 512i64;
    v17 = v37;
    v18 = v15 - v37;
    while ( v16 != -2147483134 )
    {
      v19 = *(_WORD *)&v17[v18];
      if ( !v19 )
        break;
      *(_WORD *)v17 = v19;
      v17 += 2;
      if ( !--v16 )
      {
        v17 -= 2;
        break;
      }
    }
    *(_WORD *)v17 = 0;
    v36 = v37;
    v35 = 1;
    SendMessageW(DlgItem, 0x1074u, v4, (LPARAM)&lParam);
    sub_140082FB0(*(_DWORD *)(**(_QWORD **)(a1 + 88) + v7 + 80), v37, 0x200u);
    v36 = v37;
    v35 = 2;
    SendMessageW(DlgItem, 0x1074u, v4, (LPARAM)&lParam);
  }
  v20 = v30;
  dwInitParam[0] = (__int64)&CBaseDialog::`vftable';
  if ( v30 )
  {
    v21 = *(_QWORD ***)(v30 + 8);
    v22 = *v21;
    *v21 = v21;
    *(_QWORD *)(*(_QWORD *)(v20 + 8) + 8i64) = *(_QWORD *)(v20 + 8);
    *(_QWORD *)(v20 + 16) = 0i64;
    if ( v22 != *(_QWORD **)(v20 + 8) )
    {
      do
      {
        v23 = (_QWORD *)*v22;
        j_free(v22);
        v22 = v23;
      }
      while ( v23 != *(_QWORD **)(v20 + 8) );
    }
    j_free(*(void **)(v20 + 8));
    j_free((void *)v20);
  }
}
// 1400C7F90: conditional instruction was optimized away because ecx.4==0
// 1400C8027: conditional instruction was optimized away because rdx.8!=0
// 1400C80A7: conditional instruction was optimized away because rdx.8!=0
// 1400F68D8: using guessed type void *CColorRuleDialog::`vftable';
// 1400F7A68: using guessed type void *CBaseDialog::`vftable';
// 14012FEE0: using guessed type __int64 qword_14012FEE0;
// 140130C90: using guessed type int dword_140130C90;
// 1400C7EC0: using guessed type LPARAM var_4F0[2];

//----- (00000001400C81A0) ----------------------------------------------------
HWND __fastcall sub_1400C81A0(__int64 a1)
{
  HWND DlgItem; // rax
  int v3; // eax

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1245);
  v3 = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  if ( v3 != -1 )
    sub_1400C7EC0(a1, v3);
  return SetFocus(*(HWND *)(a1 + 8));
}

//----- (00000001400C8200) ----------------------------------------------------
__int64 __fastcall sub_1400C8200(__int64 a1, __int64 a2)
{
  int v2; // edx

  if ( *(_DWORD *)(a2 + 16) == -3 )
  {
    v2 = *(_DWORD *)(a2 + 24);
    if ( v2 != -1 )
      sub_1400C7EC0(a1, v2);
  }
  return 0i64;
}

//----- (00000001400C8230) ----------------------------------------------------
HWND __fastcall sub_1400C8230(__int64 a1)
{
  HWND DlgItem; // r12
  HWND result; // rax
  int v4; // ebp
  _QWORD *v5; // rbx
  __int64 v6; // rsi
  LPARAM lParam; // [rsp+20h] [rbp-178h] BYREF
  int v8; // [rsp+2Ch] [rbp-16Ch]
  int v9; // [rsp+30h] [rbp-168h]
  WCHAR Buffer[128]; // [rsp+70h] [rbp-128h] BYREF

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1245);
  result = (HWND)SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v4 = (int)result;
  if ( (_DWORD)result != -1 )
  {
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0x846u, Buffer, 128);
    if ( MessageBoxW(*(HWND *)(a1 + 8), Buffer, L"Explorer++", 0x144u) == 6 )
    {
      v5 = *(_QWORD **)(a1 + 88);
      v6 = (v5[1] - *v5) / 88i64;
      sub_14000A200((_DWORD *)(*v5 + 88i64 * v4 + 88), (_DWORD *)v5[1], (_DWORD *)(*v5 + 88i64 * v4));
      sub_14000A280((_QWORD *)(v5[1] - 88i64), (_QWORD *)v5[1]);
      v5[1] -= 88i64;
      SendMessageW(DlgItem, 0x1008u, v4, 0i64);
      if ( v4 == (_DWORD)v6 - 1 )
        --v4;
      v9 = 2;
      v8 = 2;
      SendMessageW(DlgItem, 0x102Bu, v4, (LPARAM)&lParam);
    }
    return SetFocus(DlgItem);
  }
  return result;
}

//----- (00000001400C8750) ----------------------------------------------------
LRESULT __fastcall sub_1400C8750(__int64 a1, int a2)
{
  HWND DlgItem; // rbp
  LRESULT result; // rax
  int v6; // ebx
  int v7; // edi
  __int64 v8; // rcx

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1245);
  result = SendMessageW(DlgItem, 0x100Cu, 0xFFFFFFFFFFFFFFFFui64, 2i64);
  v6 = result;
  if ( (_DWORD)result != -1 )
  {
    if ( a2 )
    {
      if ( !(_DWORD)result )
        return result;
      v7 = result - 1;
    }
    else
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8i64) - **(_QWORD **)(a1 + 88);
      result = (unsigned __int64)((unsigned __int128)(v8 * (__int128)0x2E8BA2E8BA2E8BA3i64) >> 64) >> 63;
      if ( v6 == (int)v8 / 88 - 1 )
        return result;
      v7 = v6 + 1;
    }
    sub_14000A090((void *)(**(_QWORD **)(a1 + 88) + 88i64 * v6), (void *)(**(_QWORD **)(a1 + 88) + 88i64 * v7));
    return sub_140080B70(DlgItem, v6, v7);
  }
  return result;
}

//----- (00000001400C8A20) ----------------------------------------------------
__int64 __fastcall sub_1400C8A20(__int64 a1, unsigned __int16 a2)
{
  if ( a2 > 0x4D1u )
  {
    switch ( a2 )
    {
      case 0x4D2u:
        sub_1400C8750(a1, 0);
        break;
      case 0x4D5u:
        sub_1400C81A0(a1);
        return 0i64;
      case 0x4DBu:
        sub_1400C8820();
        return 0i64;
    }
  }
  else
  {
    switch ( a2 )
    {
      case 0x4D1u:
        sub_1400C8750(a1, 1);
        return 0i64;
      case 1u:
        EndDialog(*(HWND *)(a1 + 8), 1i64);
        return 0i64;
      case 2u:
        EndDialog(*(HWND *)(a1 + 8), 0i64);
        return 0i64;
      case 0x4D0u:
        sub_1400C8230(a1);
        return 0i64;
    }
  }
  return 0i64;
}
// 1400C8820: using guessed type __int64 sub_1400C8820(void);

//----- (00000001400C8AD0) ----------------------------------------------------
LSTATUS __fastcall sub_1400C8AD0(__int64 a1, HKEY a2)
{
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF

  cbData = 4;
  RegQueryValueExW(a2, L"InitialColor", 0i64, 0i64, (LPBYTE)(a1 + 544), &cbData);
  cbData = 64;
  return RegQueryValueExW(a2, L"CustomColors", 0i64, 0i64, (LPBYTE)(a1 + 548), &cbData);
}

//----- (00000001400C8B60) ----------------------------------------------------
LSTATUS __fastcall sub_1400C8B60(__int64 a1, HKEY a2)
{
  RegSetValueExW(a2, L"InitialColor", 0, 3u, (const BYTE *)(a1 + 544), 4u);
  return RegSetValueExW(a2, L"CustomColors", 0, 3u, (const BYTE *)(a1 + 548), 0x40u);
}

//----- (00000001400C8C00) ----------------------------------------------------
__int64 __fastcall sub_1400C8C00(__int64 a1)
{
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400C8C40) ----------------------------------------------------
__int64 __fastcall sub_1400C8C40(__int64 a1)
{
  _DWORD *v1; // rbx
  LONG top; // ecx
  int v4; // eax
  LONG bottom; // eax
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  v1 = *(_DWORD **)(a1 + 104);
  GetWindowRect(*(HWND *)(a1 + 8), &Rect);
  top = Rect.top;
  v4 = Rect.right - Rect.left;
  v1[3] = Rect.left;
  v1[5] = v4;
  bottom = Rect.bottom;
  v1[4] = top;
  v1[6] = bottom - top;
  result = *(_QWORD *)(a1 + 104);
  *(_DWORD *)(result + 8) = 1;
  return result;
}

//----- (00000001400C8CE0) ----------------------------------------------------
HRESULT __fastcall sub_1400C8CE0(unsigned __int8 *a1, __int64 *a2, __int64 a3)
{
  unsigned __int8 *v6; // rsi
  unsigned int i; // edi
  OLECHAR *v8; // rbx
  BSTR v9; // rax
  __int64 v10; // rax
  OLECHAR *v11; // rbx
  BSTR v12; // rax
  __int64 v13; // rax
  OLECHAR *v14; // rbx
  BSTR v15; // rax
  __int64 v16; // rax
  HRESULT result; // eax
  __int64 *v18; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v19; // [rsp+28h] [rbp-D8h] BYREF
  VARIANTARG v20; // [rsp+30h] [rbp-D0h] BYREF
  VARIANTARG pvarg; // [rsp+48h] [rbp-B8h] BYREF
  VARIANTARG v22; // [rsp+60h] [rbp-A0h] BYREF
  VARIANTARG v23; // [rsp+80h] [rbp-80h] BYREF
  VARIANTARG v24; // [rsp+A0h] [rbp-60h] BYREF
  OLECHAR psz[32]; // [rsp+C0h] [rbp-40h] BYREF

  itow_s(a1[544], Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"InitialColor_r", Buffer);
  itow_s(a1[545], Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"InitialColor_g", Buffer);
  itow_s(a1[546], Buffer, 0x40ui64, 10);
  sub_14007BEA0(a2, a3, L"InitialColor_b", Buffer);
  v6 = a1 + 548;
  for ( i = 0; i < 0x10; ++i )
  {
    sub_140001000(psz, 0x20ui64, L"r%d", i);
    itow_s(*v6, Buffer, 0x40ui64, 10);
    v18 = 0i64;
    v19 = 0i64;
    v8 = SysAllocString(psz);
    VariantInit(&pvarg);
    v9 = SysAllocString(Buffer);
    pvarg.vt = 8;
    v20.llVal = (LONGLONG)v9;
    *(_QWORD *)&v20.vt = *(_QWORD *)&pvarg.vt;
    v20.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 424))(a2, v8, &v18);
    v10 = *v18;
    v24 = v20;
    (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v10 + 360))(v18, &v24);
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a3 + 384i64))(a3, v18, &v19);
    SysFreeString(v8);
    if ( v19 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
      v19 = 0i64;
    }
    (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
    v18 = 0i64;
    VariantClear(&v20);
    sub_140001000(psz, 0x20ui64, L"g%d", i);
    itow_s(v6[1], Buffer, 0x40ui64, 10);
    v18 = 0i64;
    v19 = 0i64;
    v11 = SysAllocString(psz);
    VariantInit(&pvarg);
    v12 = SysAllocString(Buffer);
    pvarg.vt = 8;
    v20.llVal = (LONGLONG)v12;
    *(_QWORD *)&v20.vt = *(_QWORD *)&pvarg.vt;
    v20.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 424))(a2, v11, &v18);
    v13 = *v18;
    v22 = v20;
    (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v13 + 360))(v18, &v22);
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a3 + 384i64))(a3, v18, &v19);
    SysFreeString(v11);
    if ( v19 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
      v19 = 0i64;
    }
    (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
    v18 = 0i64;
    VariantClear(&v20);
    sub_140001000(psz, 0x20ui64, L"b%d", i);
    itow_s(v6[2], Buffer, 0x40ui64, 10);
    v18 = 0i64;
    v19 = 0i64;
    v14 = SysAllocString(psz);
    VariantInit(&pvarg);
    v15 = SysAllocString(Buffer);
    pvarg.vt = 8;
    v20.llVal = (LONGLONG)v15;
    *(_QWORD *)&v20.vt = *(_QWORD *)&pvarg.vt;
    v20.pRecInfo = pvarg.pRecInfo;
    (*(void (__fastcall **)(__int64 *, OLECHAR *, __int64 **))(*a2 + 424))(a2, v14, &v18);
    v16 = *v18;
    v23 = v20;
    (*(void (__fastcall **)(__int64 *, VARIANTARG *))(v16 + 360))(v18, &v23);
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a3 + 384i64))(a3, v18, &v19);
    SysFreeString(v14);
    if ( v19 )
    {
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16i64))(v19);
      v19 = 0i64;
    }
    (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
    v18 = 0i64;
    result = VariantClear(&v20);
    v6 += 4;
  }
  return result;
}
// 1400F4990: using guessed type wchar_t aInitialcolorR[15];
// 1400F49B0: using guessed type wchar_t aInitialcolorG[15];
// 1400F49D0: using guessed type wchar_t aInitialcolorB[15];
// 1400F49F0: using guessed type wchar_t aRD[4];
// 1400F49F8: using guessed type wchar_t aGD[4];
// 1400F4A00: using guessed type wchar_t aBD[4];
// 14012E660: using guessed type OLECHAR Buffer[64];

//----- (00000001400C9140) ----------------------------------------------------
__int64 *sub_1400C9140()
{
  _WORD *v0; // rcx
  __int64 v1; // rdx
  __int16 v2; // ax
  _DWORD *v3; // rdi
  __int64 v4; // rcx

  v0 = &unk_14012FEFC;
  v1 = 256i64;
  while ( v1 != -2147483390 )
  {
    v2 = *(_WORD *)((char *)v0 + (char *)L"ColorRules" - (char *)&unk_14012FEFC);
    if ( !v2 )
      break;
    *v0++ = v2;
    if ( !--v1 )
    {
      --v0;
      break;
    }
  }
  v3 = &unk_140130104;
  *v0 = 0;
  dword_14012FEE8 = 0;
  qword_14012FEE0 = (__int64)&CColorRuleDialogPersistentSettings::`vftable';
  v4 = 16i64;
  byte_1401300FC = 1;
  dword_140130100 = 9068032;
  while ( v4 )
  {
    *v3++ = 0xFFFFFF;
    --v4;
  }
  return &qword_14012FEE0;
}
// 1400C9186: conditional instruction was optimized away because rdx.8!=0
// 1400F48F8: using guessed type wchar_t aColorrules_1[11];
// 1400F6948: using guessed type void *CColorRuleDialogPersistentSettings::`vftable';
// 14012FEE0: using guessed type __int64 qword_14012FEE0;
// 14012FEE8: using guessed type int dword_14012FEE8;
// 1401300FC: using guessed type char byte_1401300FC;
// 140130100: using guessed type int dword_140130100;

//----- (00000001400C91E0) ----------------------------------------------------
__int64 *sub_1400C91E0()
{
  if ( (dword_140130C90 & 1) == 0 )
  {
    dword_140130C90 |= 1u;
    sub_1400C9140();
    atexit(sub_1400E1E50);
  }
  return &qword_14012FEE0;
}
// 14012FEE0: using guessed type __int64 qword_14012FEE0;
// 140130C90: using guessed type int dword_140130C90;

//----- (00000001400C9220) ----------------------------------------------------
__int64 __fastcall sub_1400C9220(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  int v6; // eax

  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &CColorRuleDialog::`vftable';
  *(_DWORD *)(a1 + 24) = 220;
  *(_DWORD *)(a1 + 80) = a5;
  v6 = dword_140130C90;
  *(_QWORD *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_QWORD *)(a1 + 88) = a4;
  if ( (v6 & 1) == 0 )
  {
    dword_140130C90 = v6 | 1;
    sub_1400C9140();
    atexit(sub_1400E1E50);
  }
  *(_QWORD *)(a1 + 104) = &qword_14012FEE0;
  return a1;
}
// 1400F68D8: using guessed type void *CColorRuleDialog::`vftable';
// 14012FEE0: using guessed type __int64 qword_14012FEE0;
// 140130C90: using guessed type int dword_140130C90;

//----- (00000001400C92A0) ----------------------------------------------------
int __fastcall sub_1400C92A0(__int64 a1)
{
  __int64 v1; // rax
  int result; // eax
  bool v4; // zf
  int v5; // ecx
  HWND DlgItem; // rax
  int v7; // [rsp+20h] [rbp-58h] BYREF
  __int64 v8; // [rsp+28h] [rbp-50h]
  int v9; // [rsp+38h] [rbp-40h]
  __int64 v10; // [rsp+40h] [rbp-38h]
  int v11; // [rsp+48h] [rbp-30h]

  v1 = *(_QWORD *)(a1 + 8);
  v7 = 72;
  v8 = v1;
  LODWORD(v1) = *(_DWORD *)(a1 + 96);
  v11 = 1;
  v9 = v1;
  v10 = *(_QWORD *)(a1 + 104) + 548i64;
  result = sub_140009B40((__int64)&v7);
  if ( result )
  {
    v4 = *(_DWORD *)(a1 + 80) == 0;
    v5 = v9;
    *(_DWORD *)(a1 + 96) = v9;
    if ( v4 )
      *(_DWORD *)(*(_QWORD *)(a1 + 104) + 544i64) = v5;
    DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1247);
    return InvalidateRect(DlgItem, 0i64, 1);
  }
  return result;
}

//----- (00000001400C9330) ----------------------------------------------------
__int64 __fastcall sub_1400C9330(__int64 a1, HWND a2, unsigned int a3, HDC a4, __int64 a5)
{
  HBRUSH SolidBrush; // rbx
  struct tagRECT Rect; // [rsp+20h] [rbp-38h] BYREF

  if ( a3 != 20 )
    return sub_140001A20((__int64)a2, a3, (__int64)a4, a5);
  GetClientRect(a2, &Rect);
  SolidBrush = CreateSolidBrush(*(_DWORD *)(a1 + 96));
  FillRect(a4, &Rect, SolidBrush);
  DeleteObject(SolidBrush);
  return 1i64;
}

//----- (00000001400C93C0) ----------------------------------------------------
__int64 __fastcall sub_1400C93C0(HWND a1, unsigned int a2, HDC a3, __int64 a4, int a5, __int64 a6)
{
  return sub_1400C9330(a6, a1, a2, a3, a4);
}

//----- (00000001400C93F0) ----------------------------------------------------
__int64 __fastcall sub_1400C93F0(__int64 a1)
{
  const WCHAR *v2; // r8
  const WCHAR *v3; // r8
  __int64 v4; // r11
  HWND DlgItem; // rax
  HWND v6; // rax
  HWND v7; // rax
  _DWORD *v8; // rax
  HWND v9; // rdi
  HWND Parent; // rax
  WCHAR Buffer[64]; // [rsp+40h] [rbp-98h] BYREF

  if ( *(_DWORD *)(a1 + 80) )
  {
    v2 = *(const WCHAR **)(a1 + 88);
    if ( *((_QWORD *)v2 + 3) >= 8ui64 )
      v2 = *(const WCHAR **)v2;
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1215, v2);
    v3 = (const WCHAR *)(*(_QWORD *)(a1 + 88) + 40i64);
    if ( *(_QWORD *)(*(_QWORD *)(a1 + 88) + 64i64) >= 8ui64 )
      v3 = *(const WCHAR **)v3;
    SetDlgItemTextW(*(HWND *)(a1 + 8), 1207, v3);
    v4 = *(_QWORD *)(a1 + 88);
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(v4 + 84);
    if ( (*(_DWORD *)(v4 + 80) & 0x800) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1204, 1u);
    if ( (*(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) & 0x4000) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1205, 1u);
    if ( (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 80i64) & 0x20) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1060, 1u);
    if ( (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 80i64) & 2) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1061, 1u);
    if ( (*(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) & 0x2000) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1063, 1u);
    if ( (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 80i64) & 1) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1062, 1u);
    if ( (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 80i64) & 4) != 0 )
      CheckDlgButton(*(HWND *)(a1 + 8), 1059, 1u);
    LoadStringW(*(HINSTANCE *)(a1 + 16), 0x848u, Buffer, 64);
    SetWindowTextW(*(HWND *)(a1 + 8), Buffer);
  }
  else
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 544i64);
  }
  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1247);
  sub_140009C20((__int64)DlgItem, (__int64)sub_1400C93C0, 0i64, a1);
  v6 = GetDlgItem(*(HWND *)(a1 + 8), 1215);
  SendMessageW(v6, 0xB1u, 0i64, -1i64);
  v7 = GetDlgItem(*(HWND *)(a1 + 8), 1215);
  SetFocus(v7);
  v8 = *(_DWORD **)(a1 + 104);
  v9 = *(HWND *)(a1 + 8);
  if ( v8[2] )
  {
    SetWindowPos(v9, 0i64, v8[3], v8[4], 0, 0, 5u);
  }
  else
  {
    Parent = GetParent(*(HWND *)(a1 + 8));
    sub_140081E00(Parent, v9);
  }
  return 0i64;
}

//----- (00000001400C9650) ----------------------------------------------------
void __fastcall sub_1400C9650(__int64 a1, WCHAR *a2, __int64 a3)
{
  unsigned __int8 v6; // di
  __int64 v7; // rcx
  WCHAR *v8; // rdi
  bool v9; // zf
  _QWORD *v10; // rdi
  unsigned __int64 v11; // r8
  __int64 v12; // r12
  int v13; // edi
  unsigned __int8 v14; // r13
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // [rsp+20h] [rbp-E0h] BYREF
  int v18; // [rsp+24h] [rbp-DCh]
  __int64 *v19; // [rsp+28h] [rbp-D8h]
  __int64 v20[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v21[15]; // [rsp+40h] [rbp-C0h] BYREF
  int v22; // [rsp+B8h] [rbp-48h]
  __int64 v23[2]; // [rsp+C0h] [rbp-40h] BYREF
  int v24; // [rsp+D0h] [rbp-30h]
  __int64 *v25; // [rsp+108h] [rbp+8h]
  __int64 v26; // [rsp+110h] [rbp+10h]
  __int16 v27; // [rsp+118h] [rbp+18h]
  __int64 v28; // [rsp+120h] [rbp+20h]
  void *Src[3]; // [rsp+128h] [rbp+28h] BYREF
  unsigned __int64 v30; // [rsp+140h] [rbp+40h]
  void *Block[3]; // [rsp+150h] [rbp+50h] BYREF
  unsigned __int64 v32; // [rsp+168h] [rbp+68h]

  v28 = -2i64;
  v18 = 0;
  if ( !(unsigned int)sub_140082100(L"r*", a2, 1)
    && !(unsigned int)sub_140082100(L"g*", a2, 1)
    && !(unsigned int)sub_140082100(L"b*", a2, 1) )
  {
    v6 = sub_14004B61C(a3);
    if ( lstrcmpiW(L"InitialColor_r", a2) )
    {
      if ( !lstrcmpiW(L"InitialColor_g", a2) || !lstrcmpiW(L"InitialColor_b", a2) )
        *(_DWORD *)(a1 + 544) = v6 | (*(unsigned __int8 *)(a1 + 546) << 16) | (*(unsigned __int8 *)(a1 + 545) << 8);
    }
    else
    {
      *(_DWORD *)(a1 + 544) = v6 | (*(unsigned __int8 *)(a1 + 546) << 16) | (*(unsigned __int8 *)(a1 + 545) << 8);
    }
    return;
  }
  if ( lstrlenW(a2) < 2 )
    return;
  v17 = 0;
  v30 = 7i64;
  Src[2] = 0i64;
  LOWORD(Src[0]) = 0;
  v7 = -1i64;
  v8 = a2;
  do
  {
    if ( !v7 )
      break;
    v9 = *v8++ == 0;
    --v7;
  }
  while ( !v9 );
  sub_1400099E0(Src, a2, -v7 - 2);
  v10 = sub_140001DE0(Src, Block, 1ui64, 0xFFFFFFFFFFFFFFFFui64);
  v20[0] = (__int64)&unk_1400F68C0;
  v18 = 1;
  v23[0] = (__int64)&std::wistream::`vftable';
  v20[1] = 0i64;
  sub_140008270((__int64)v23);
  v25 = v21;
  v26 = 0i64;
  v27 = sub_1400056C0((__int64)v23);
  if ( !v25 )
    sub_140009260((__int64)v23, v24 | 4, 0);
  *(__int64 *)((char *)v20 + *(int *)(v20[0] + 4)) = (__int64)&std::wistringstream::`vftable';
  v19 = v21;
  sub_140003840(v21);
  v21[0] = (__int64)&std::wstringbuf::`vftable';
  v11 = v10[2];
  if ( v10[3] >= 8ui64 )
    v10 = (_QWORD *)*v10;
  v21[14] = 0i64;
  v22 = 2;
  if ( v11 )
    sub_140003930((__int64)v21, v10, v11);
  if ( v32 >= 8 )
    j_free(Block[0]);
  v32 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  sub_140001BE0(v20, &v17);
  if ( (v17 & 0x80000000) == 0 && v17 <= 0x3F )
  {
    v12 = (int)v17;
    v13 = *(_DWORD *)(a1 + 4i64 * (int)v17 + 548);
    v14 = sub_14004B61C(a3);
    if ( (unsigned int)sub_140082100(L"r*", a2, 1) )
    {
      *(_DWORD *)(a1 + 4 * v12 + 548) = v14 | (BYTE2(v13) << 16) | (BYTE1(v13) << 8);
LABEL_30:
      sub_140001B60((__int64)v20);
      goto LABEL_32;
    }
    if ( (unsigned int)sub_140082100(L"g*", a2, 1) )
    {
      v15 = BYTE2(v13) << 16;
      v16 = v14 << 8;
    }
    else
    {
      if ( !(unsigned int)sub_140082100(L"b*", a2, 1) )
        goto LABEL_30;
      v15 = BYTE1(v13) << 8;
      v16 = v14 << 16;
    }
    *(_DWORD *)(a1 + 4 * v12 + 548) = (unsigned __int8)v13 | v16 | v15;
    goto LABEL_30;
  }
  v19 = v23;
  *(__int64 *)((char *)v20 + *(int *)(v20[0] + 4)) = (__int64)&std::wistringstream::`vftable';
  sub_140001E20((__int64)v21);
  *(__int64 *)((char *)v20 + *(int *)(v20[0] + 4)) = (__int64)&std::wistream::`vftable';
  v23[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v23);
LABEL_32:
  if ( v30 >= 8 )
    j_free(Src[0]);
}
// 140001BE0: using guessed type __int64 __fastcall sub_140001BE0(_QWORD, _QWORD);
// 140003840: using guessed type __int64 __fastcall sub_140003840(_QWORD);
// 14004B61C: using guessed type __int64 __fastcall sub_14004B61C(_QWORD);
// 1400F6838: using guessed type void *std::wstringbuf::`vftable';
// 1400F68B8: using guessed type void *std::wistringstream::`vftable';
// 1400F6A40: using guessed type void *std::ios_base::`vftable';
// 1400F6AE8: using guessed type void *std::wistream::`vftable';

//----- (00000001400C9A40) ----------------------------------------------------
BOOL __fastcall sub_1400C9A40(__int64 a1)
{
  HWND DlgItem; // rax
  __int64 v3; // rbx
  HWND v4; // rax

  DlgItem = GetDlgItem(*(HWND *)(a1 + 8), 1215);
  sub_140083A30(DlgItem, *(void **)(a1 + 88));
  v3 = *(_QWORD *)(a1 + 88);
  v4 = GetDlgItem(*(HWND *)(a1 + 8), 1207);
  sub_140083A30(v4, (void *)(v3 + 40));
  *(_DWORD *)(*(_QWORD *)(a1 + 88) + 84i64) = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) = 0;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1204) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 0x800u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1205) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 0x4000u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1060) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 0x20u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1061) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 2u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1062) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 1u;
  if ( IsDlgButtonChecked(*(HWND *)(a1 + 8), 1059) == 1 )
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 80i64) |= 4u;
  return EndDialog(*(HWND *)(a1 + 8), 1i64);
}

//----- (00000001400C9B70) ----------------------------------------------------
__int64 __fastcall sub_1400C9B70(__int64 a1, int a2)
{
  if ( HIWORD(a2) )
  {
    if ( HIWORD(a2) == 1 )
    {
LABEL_3:
      sub_1400C92A0(a1);
      return 0i64;
    }
  }
  else
  {
    switch ( (unsigned __int16)a2 )
    {
      case 1u:
        sub_1400C9A40(a1);
        break;
      case 2u:
        EndDialog(*(HWND *)(a1 + 8), 0i64);
        return 0i64;
      case 0x4E0u:
        goto LABEL_3;
    }
  }
  return 0i64;
}

//----- (00000001400C9BE0) ----------------------------------------------------
HRESULT __fastcall sub_1400C9BE0(__int64 a1)
{
  _QWORD *v1; // rdi
  HRESULT result; // eax

  v1 = (_QWORD *)(a1 + 24);
  result = CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)(a1 + 24));
  if ( result >= 0 )
    return (**(__int64 (__fastcall ***)(_QWORD, void *, __int64))*v1)(*v1, &unk_1400E4040, a1 + 32);
  return result;
}

//----- (00000001400C9C40) ----------------------------------------------------
__int64 __fastcall sub_1400C9C40(__int64 a1)
{
  __int64 v2; // rcx
  LPARAM lParam; // [rsp+30h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 16);
  LODWORD(lParam) = -1;
  SendMessageW(*(HWND *)(v2 + 1008), 0x450u, 0i64, (LPARAM)&lParam);
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(*(_QWORD *)(a1 + 32));
  return 0i64;
}

//----- (00000001400C9C90) ----------------------------------------------------
__int64 __fastcall sub_1400C9C90(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  int v5; // ebp
  __int64 v7; // rcx
  int v8; // eax
  HWND v9; // rcx
  int v10; // esi
  int v12; // [rsp+20h] [rbp-48h] BYREF
  int v13; // [rsp+24h] [rbp-44h]
  struct tagPOINT Point; // [rsp+28h] [rbp-40h] BYREF
  __int64 v15; // [rsp+30h] [rbp-38h] BYREF
  LPARAM lParam; // [rsp+38h] [rbp-30h] BYREF
  int v17; // [rsp+40h] [rbp-28h]

  v15 = a3;
  Point.x = a3;
  v5 = 0;
  *a4 = *(_DWORD *)(a1 + 40) != 0;
  v7 = *(_QWORD *)(a1 + 16);
  Point.y = HIDWORD(a3);
  ScreenToClient(*(HWND *)(v7 + 1008), &Point);
  v8 = SendMessageW(*(HWND *)(*(_QWORD *)(a1 + 16) + 1008i64), 0x445u, 0i64, (LPARAM)&Point);
  v9 = *(HWND *)(*(_QWORD *)(a1 + 16) + 1008i64);
  v10 = v8;
  if ( v8 >= 0 )
  {
    SendMessageW(v9, 0x41Du, v8, (LPARAM)&lParam);
    v12 = v10;
    LOBYTE(v5) = Point.x > (int)lParam + (v17 - (int)lParam) / 2;
    v13 = v5;
  }
  else
  {
    v13 = 1;
    v12 = SendMessageW(v9, 0x418u, 0i64, 0i64) - 1;
  }
  SendMessageW(*(HWND *)(*(_QWORD *)(a1 + 16) + 1008i64), 0x450u, 0i64, (LPARAM)&v12);
  (*(void (__fastcall **)(_QWORD, __int64 *, _QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(
    *(_QWORD *)(a1 + 32),
    &v15,
    (unsigned int)*a4);
  return 0i64;
}

//----- (00000001400C9DC0) ----------------------------------------------------
__int64 __fastcall sub_1400C9DC0(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  __int64 v6; // rax
  unsigned int v8; // er15
  int v9; // er13
  HDROP v10; // rax
  HDROP v11; // rsi
  UINT v12; // ebx
  signed int FileW; // edi
  __int64 v15; // [rsp+30h] [rbp-298h] BYREF
  __int16 v16; // [rsp+38h] [rbp-290h] BYREF
  __int64 v17; // [rsp+40h] [rbp-288h]
  int v18; // [rsp+48h] [rbp-280h]
  int v19; // [rsp+4Ch] [rbp-27Ch]
  int v20; // [rsp+50h] [rbp-278h]
  STGMEDIUM v21; // [rsp+58h] [rbp-270h] BYREF
  WCHAR szFile[264]; // [rsp+70h] [rbp-258h] BYREF

  v16 = 15;
  v6 = *a2;
  v15 = a4;
  v17 = 0i64;
  v18 = 1;
  v19 = -1;
  v20 = 1;
  v8 = (*(__int64 (__fastcall **)(__int64 *, __int16 *, STGMEDIUM *))(v6 + 24))(a2, &v16, &v21);
  if ( v8 )
    goto LABEL_11;
  v9 = 1;
  v10 = (HDROP)GlobalLock(v21.hBitmap);
  v11 = v10;
  if ( v10 )
  {
    v12 = 0;
    FileW = DragQueryFileW(v10, 0xFFFFFFFF, 0i64, 0);
    if ( FileW > 0 )
    {
      while ( 1 )
      {
        DragQueryFileW(v11, v12, szFile, 0x104u);
        if ( !PathIsDirectoryW(szFile) )
          break;
        if ( (int)++v12 >= FileW )
          goto LABEL_8;
      }
      v9 = 0;
    }
LABEL_8:
    GlobalUnlock(v21.hBitmap);
  }
  ReleaseStgMedium(&v21);
  if ( !v9 )
  {
LABEL_11:
    *(_DWORD *)(a1 + 40) = 0;
    *a5 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 1;
    *a5 = 1;
  }
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, __int64 *, _DWORD))(**(_QWORD **)(a1 + 32) + 24i64))(
    *(_QWORD *)(a1 + 32),
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 1008i64),
    a2,
    &v15,
    *a5);
  return v8;
}

//----- (00000001400C9F70) ----------------------------------------------------
__int64 __fastcall sub_1400C9F70(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00000001400C9F80) ----------------------------------------------------
__int64 __fastcall sub_1400C9F80(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 2147500034i64;
}

//----- (00000001400C9FC0) ----------------------------------------------------
__int64 __fastcall sub_1400C9FC0(_DWORD *a1)
{
  bool v1; // zf
  __int64 result; // rax

  v1 = a1[2]-- == 1;
  result = (unsigned int)a1[2];
  if ( v1 )
  {
    *(_QWORD *)a1 = &Explorerplusplus::CBookmarkToolbarDrop::`vftable';
    j_free(a1);
    return 0i64;
  }
  return result;
}
// 1400F67C8: using guessed type void *Explorerplusplus::CBookmarkToolbarDrop::`vftable';

//----- (00000001400C9FF0) ----------------------------------------------------
_QWORD *__fastcall sub_1400C9FF0(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rdi

  a1[2] = a2;
  v2 = a1 + 3;
  *a1 = &Explorerplusplus::CBookmarkToolbarDrop::`vftable';
  if ( CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)a1 + 3) >= 0 )
    (**(void (__fastcall ***)(_QWORD, void *, _QWORD *))*v2)(*v2, &unk_1400E4040, a1 + 4);
  return a1;
}
// 1400F67C8: using guessed type void *Explorerplusplus::CBookmarkToolbarDrop::`vftable';

//----- (00000001400CA060) ----------------------------------------------------
__int64 __fastcall sub_1400CA060(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, unsigned int *a5)
{
  __int64 v6; // rcx
  __int64 v8; // rax
  HDROP v9; // rax
  HDROP v10; // r14
  signed int FileW; // er13
  signed int v12; // edi
  __int64 v13; // rsi
  __int64 v14; // rdx
  WCHAR *v15; // rcx
  WCHAR v16; // ax
  __int64 v17; // r11
  char *v18; // rcx
  __int16 v19; // ax
  __int64 v20; // rdx
  char *v21; // rcx
  __int16 v22; // ax
  __int64 v23; // rdx
  char *v24; // rcx
  __int16 v25; // ax
  _QWORD *v26; // rbx
  __int64 v27; // rcx
  _QWORD *i; // rax
  __int64 v29; // r8
  int v30; // edx
  __int64 v31; // rax
  _DWORD *v32; // rcx
  int v33; // edx
  __int64 v34; // rbx
  int v35; // eax
  HWND v36; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v39; // [rsp+28h] [rbp-D8h] BYREF
  __int16 v40; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v41; // [rsp+38h] [rbp-C8h]
  int v42; // [rsp+40h] [rbp-C0h]
  int v43; // [rsp+44h] [rbp-BCh]
  int v44; // [rsp+48h] [rbp-B8h]
  STGMEDIUM v45; // [rsp+50h] [rbp-B0h] BYREF
  char v46[2064]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v47; // [rsp+880h] [rbp+780h]
  LPARAM v48; // [rsp+890h] [rbp+790h] BYREF
  __int16 v49; // [rsp+898h] [rbp+798h]
  __int64 v50; // [rsp+8A0h] [rbp+7A0h]
  char *v51; // [rsp+8A8h] [rbp+7A8h]
  char v52[512]; // [rsp+8B0h] [rbp+7B0h] BYREF
  char v53[1024]; // [rsp+AB0h] [rbp+9B0h] BYREF
  int v54; // [rsp+EB0h] [rbp+DB0h]
  int v55; // [rsp+EB4h] [rbp+DB4h]
  char v56; // [rsp+EB8h] [rbp+DB8h] BYREF
  unsigned int v57; // [rsp+10C0h] [rbp+FC0h]
  WCHAR pszPath[264]; // [rsp+10D0h] [rbp+FD0h] BYREF
  WCHAR szFile[264]; // [rsp+12E0h] [rbp+11E0h] BYREF

  v6 = *(_QWORD *)(a1 + 16);
  v39 = a4;
  LODWORD(lParam) = -1;
  SendMessageW(*(HWND *)(v6 + 1008), 0x450u, 0i64, (LPARAM)&lParam);
  v40 = 15;
  v8 = *a2;
  v42 = 1;
  v43 = -1;
  v44 = 1;
  v41 = 0i64;
  if ( !(*(unsigned int (__fastcall **)(__int64 *, __int16 *, STGMEDIUM *))(v8 + 24))(a2, &v40, &v45) )
  {
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64 *, _QWORD))(**(_QWORD **)(a1 + 32) + 48i64))(
      *(_QWORD *)(a1 + 32),
      a2,
      &v39,
      *a5);
    v9 = (HDROP)GlobalLock(v45.hBitmap);
    v10 = v9;
    if ( v9 )
    {
      FileW = DragQueryFileW(v9, 0xFFFFFFFF, 0i64, 0);
      sub_14007DA80(*(_QWORD *)(a1 + 16) + 2664i64, (__int64)v46);
      v12 = 0;
      if ( FileW > 0 )
      {
        v13 = v47;
        do
        {
          DragQueryFileW(v10, v12, szFile, 0x104u);
          if ( PathIsDirectoryW(szFile) )
          {
            v14 = 260i64;
            v15 = pszPath;
            while ( v14 != -2147483386 )
            {
              v16 = v15[264];
              if ( !v16 )
                break;
              *v15++ = v16;
              if ( !--v14 )
              {
                --v15;
                break;
              }
            }
            *v15 = 0;
            PathStripPathW(pszPath);
            v17 = 256i64;
            v18 = v52;
            while ( v17 != -2147483390 )
            {
              v19 = *((_WORD *)v18 + 1040);
              if ( !v19 )
                break;
              *(_WORD *)v18 = v19;
              v18 += 2;
              if ( !--v17 )
              {
                v18 -= 2;
                break;
              }
            }
            *(_WORD *)v18 = 0;
            v20 = 512i64;
            v21 = v53;
            while ( v20 != -2147483134 )
            {
              v22 = *(_WORD *)&v21[&unk_1400ECABC - (_UNKNOWN *)v53];
              if ( !v22 )
                break;
              *(_WORD *)v21 = v22;
              v21 += 2;
              if ( !--v20 )
              {
                v21 -= 2;
                break;
              }
            }
            *(_WORD *)v21 = 0;
            v23 = 260i64;
            v24 = &v56;
            while ( v23 != -2147483386 )
            {
              v25 = *((_WORD *)v24 + 532);
              if ( !v25 )
                break;
              *(_WORD *)v24 = v25;
              v24 += 2;
              if ( !--v23 )
              {
                v24 -= 2;
                break;
              }
            }
            *(_WORD *)v24 = 0;
            v55 = 1;
            v54 = 1;
            v26 = malloc(0x830ui64);
            sub_14007D850((__int64)v26, (__int64)v52);
            v26[258] = v13;
            v27 = *(_QWORD *)(v13 + 2088);
            if ( v27 )
            {
              for ( i = (_QWORD *)(v27 + 2080); *i; i = (_QWORD *)(*i + 2080i64) )
                v27 = *i;
              *(_QWORD *)(v27 + 2080) = v26;
              v26[259] = v27;
            }
            else
            {
              *(_QWORD *)(v13 + 2088) = v26;
              v26[259] = 0i64;
            }
            v29 = *(_QWORD *)(a1 + 16);
            v30 = 0;
            v31 = 0i64;
            v32 = (_DWORD *)(v29 + 61664);
            while ( *v32 )
            {
              ++v31;
              ++v30;
              ++v32;
              if ( v31 >= 100 )
              {
                v33 = -1;
                goto LABEL_36;
              }
            }
            *(_DWORD *)(v29 + 4 * v31 + 61664) = 1;
            v33 = v30 + 46000;
LABEL_36:
            v34 = *(_QWORD *)(a1 + 16);
            v35 = 20;
            HIDWORD(v48) = v33;
            if ( !v55 )
              v35 = 15;
            v36 = *(HWND *)(v34 + 1008);
            LODWORD(v48) = v35;
            v50 = v57;
            v49 = 28676;
            v51 = v52;
            SendMessageW(v36, 0x444u, 1ui64, (LPARAM)&v48);
            sub_140080090(*(HWND *)(v34 + 120), *(HWND *)(v34 + 1008));
          }
          ++v12;
        }
        while ( v12 < FileW );
      }
      GlobalUnlock(v45.hBitmap);
    }
    ReleaseStgMedium(&v45);
  }
  sub_1400CB360(*(_QWORD *)(a1 + 16));
  return 0i64;
}
// 1400CA207: conditional instruction was optimized away because rdx.8!=0
// 1400CA266: conditional instruction was optimized away because r11.8!=0
// 1400CA2B7: conditional instruction was optimized away because rdx.8!=0
// 1400CA307: conditional instruction was optimized away because rdx.8!=0
// 1400CA060: using guessed type char var_14C0[2064];

//----- (00000001400CA4B0) ----------------------------------------------------
__int64 __fastcall sub_1400CA4B0(__int64 a1, HWND a2, __int64 a3)
{
  WCHAR Buffer[128]; // [rsp+20h] [rbp-128h] BYREF

  LoadStringW(hInstance, 0x7FAu, Buffer, 128);
  if ( MessageBoxW(a2, Buffer, L"Explorer++", 0x144u) != 6 )
    return 0i64;
  sub_14007D150(a1 + 2664, a3);
  return 1i64;
}

//----- (00000001400CA550) ----------------------------------------------------
LRESULT __fastcall sub_1400CA550(__int64 a1, __int64 a2)
{
  LRESULT result; // rax
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  HWND v8; // rsi
  HWND v9; // rbp
  int v10; // edi
  __int64 v11[2]; // [rsp+20h] [rbp-C8h] BYREF
  LPARAM v12[11]; // [rsp+30h] [rbp-B8h] BYREF
  int v13; // [rsp+88h] [rbp-60h]
  LPARAM lParam[4]; // [rsp+A0h] [rbp-48h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 1008), 0x418u, 0i64, 0i64);
  v5 = 0;
  v6 = result;
  v7 = 0;
  if ( (int)result > 0 )
  {
    while ( 1 )
    {
      result = SendMessageW(*(HWND *)(a1 + 1008), 0x417u, v7, (LPARAM)lParam);
      if ( result )
      {
        if ( lParam[2] == a2 )
          break;
      }
      if ( ++v7 >= v6 )
        return result;
    }
    SendMessageW(*(HWND *)(a1 + 1008), 0x416u, v7, 0i64);
    v8 = *(HWND *)(a1 + 120);
    v9 = *(HWND *)(a1 + 1008);
    result = SendMessageW(v8, 0x40Cu, 0i64, 0i64);
    v10 = result;
    if ( (int)result > 0 )
    {
      while ( 1 )
      {
        v12[0] = 0x1000000070i64;
        result = SendMessageW(v8, 0x41Cu, v5, (LPARAM)v12);
        if ( (HWND)v12[5] == v9 )
          break;
        if ( ++v5 >= v10 )
          return result;
      }
      if ( v5 != -1 )
      {
        SendMessageW(v9, 0x453u, 0i64, (LPARAM)v11);
        v13 = v11[0];
        v12[0] = 0x20000000070i64;
        return SendMessageW(v8, 0x40Bu, v5, (LPARAM)v12);
      }
    }
  }
  return result;
}
// 1400CA550: using guessed type LPARAM var_C8[2];

//----- (00000001400CA6E0) ----------------------------------------------------
__int64 __fastcall sub_1400CA6E0(__int64 a1)
{
  int v1; // er8
  _DWORD *v2; // rax
  __int64 v3; // rdx

  v1 = 0;
  v2 = (_DWORD *)(a1 + 61664);
  v3 = 0i64;
  while ( *v2 )
  {
    ++v3;
    ++v1;
    ++v2;
    if ( v3 >= 100 )
      return 0xFFFFFFFFi64;
  }
  *(_DWORD *)(a1 + 4i64 * v1 + 61664) = 1;
  return (unsigned int)(v1 + 46000);
}

//----- (00000001400CA750) ----------------------------------------------------
__int64 __fastcall sub_1400CA750(HWND hWnd, __int64 a2)
{
  unsigned int v4; // ebx
  int v5; // edi
  LRESULT v6; // rax

  v4 = 0;
  v5 = SendMessageW(hWnd, 0x146u, 0i64, 0i64);
  if ( v5 <= 0 )
    return 0xFFFFFFFFi64;
  while ( 1 )
  {
    v6 = SendMessageW(hWnd, 0x150u, (int)v4, 0i64);
    if ( v6 != -1 && v6 == a2 )
      break;
    if ( (int)++v4 >= v5 )
      return 0xFFFFFFFFi64;
  }
  return v4;
}

//----- (00000001400CA7E0) ----------------------------------------------------
LRESULT __fastcall sub_1400CA7E0(__int64 a1, __int64 a2)
{
  LRESULT result; // rax
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  HWND v8; // rcx
  LPARAM v9; // [rsp+20h] [rbp-78h] BYREF
  int v10; // [rsp+2Ch] [rbp-6Ch]
  __int64 v11; // [rsp+38h] [rbp-60h]
  __int64 v12; // [rsp+40h] [rbp-58h]
  LPARAM lParam[4]; // [rsp+50h] [rbp-48h] BYREF

  result = SendMessageW(*(HWND *)(a1 + 1008), 0x418u, 0i64, 0i64);
  v5 = 0;
  v6 = result;
  if ( (int)result > 0 )
  {
    while ( 1 )
    {
      result = SendMessageW(*(HWND *)(a1 + 1008), 0x417u, v5, (LPARAM)lParam);
      if ( result )
      {
        result = *(_QWORD *)(a2 + 2064);
        if ( lParam[2] == result )
          break;
      }
      if ( ++v5 >= v6 )
        return result;
    }
    v7 = 20;
    if ( !*(_DWORD *)(a2 + 1540) )
      v7 = 15;
    v8 = *(HWND *)(a1 + 1008);
    v9 = 0x200000030i64;
    v10 = v7;
    v11 = *(_QWORD *)(a2 + 2064);
    v12 = a2;
    return SendMessageW(v8, 0x440u, SHIDWORD(lParam[0]), (LPARAM)&v9);
  }
  return result;
}

//----- (00000001400CA8E0) ----------------------------------------------------
__int64 __fastcall sub_1400CA8E0(__int64 a1, __int64 a2, int a3)
{
  bool v3; // zf
  int v5; // eax
  HWND v6; // rcx
  __int64 v7; // rax
  LPARAM lParam; // [rsp+20h] [rbp-38h] BYREF
  __int16 v10; // [rsp+28h] [rbp-30h]
  __int64 v11; // [rsp+30h] [rbp-28h]
  __int64 v12; // [rsp+38h] [rbp-20h]

  v3 = *(_DWORD *)(a2 + 1540) == 0;
  v5 = 20;
  HIDWORD(lParam) = a3;
  if ( v3 )
    v5 = 15;
  v6 = *(HWND *)(a1 + 1008);
  v12 = a2;
  LODWORD(lParam) = v5;
  v7 = *(unsigned int *)(a2 + 2064);
  v10 = 28676;
  v11 = v7;
  SendMessageW(v6, 0x444u, 1ui64, (LPARAM)&lParam);
  return sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1008));
}

//----- (00000001400CA970) ----------------------------------------------------
__int64 __fastcall sub_1400CA970(__int64 a1, const WCHAR *a2, unsigned int a3, int a4)
{
  DWORD CurrentProcessId; // eax
  HANDLE v9; // rax
  void *v10; // rbx
  int v11; // ebx
  HANDLE TokenHandle[2]; // [rsp+30h] [rbp-258h] BYREF
  WCHAR Dest[264]; // [rsp+40h] [rbp-248h] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v9 = OpenProcess(0x400u, 0, CurrentProcessId);
  v10 = v9;
  if ( v9 )
  {
    if ( OpenProcessToken(v9, 0xCu, TokenHandle) )
    {
      ExpandEnvironmentStringsForUserW(TokenHandle[0], a2, Dest, 0x104u);
      CloseHandle(TokenHandle[0]);
    }
    CloseHandle(v10);
  }
  TokenHandle[0] = 0i64;
  v11 = sub_14007F810((__int64)Dest, (__int64)TokenHandle);
  (*(void (__fastcall **)(__int64, HANDLE, _QWORD, _QWORD, int, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
    a1 + 56,
    TokenHandle[0],
    0i64,
    a3,
    a4,
    0);
  if ( v11 >= 0 )
    CoTaskMemFree(TokenHandle[0]);
  return (unsigned int)v11;
}

//----- (00000001400CAA90) ----------------------------------------------------
__int64 __fastcall sub_1400CAA90(int a1, HWND a2, LPARAM a3, int a4, int a5)
{
  __int64 v5; // rax
  int v9; // edi
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 result; // rax
  __int64 v13; // rcx
  LPARAM lParam[3]; // [rsp+38h] [rbp-10B0h] BYREF
  int v16; // [rsp+54h] [rbp-1094h]
  int v17; // [rsp+58h] [rbp-1090h]
  int v18; // [rsp+60h] [rbp-1088h]
  __int64 v19; // [rsp+68h] [rbp-1080h]
  char v20[2080]; // [rsp+70h] [rbp-1078h] BYREF
  char v21[2080]; // [rsp+890h] [rbp-858h] BYREF

  v5 = *(_QWORD *)(a3 + 2064);
  lParam[2] = a3;
  lParam[1] = a5;
  v9 = a5 + 1;
  LODWORD(lParam[0]) = 55;
  v16 = 15;
  v17 = 15;
  v18 = a4;
  v19 = v5;
  SendMessageW(a2, 0x40Bu, 0i64, (LPARAM)lParam);
  v10 = *(_QWORD *)(a3 + 2064);
  if ( !*(_DWORD *)(v10 + 1540) )
  {
    v11 = *(_QWORD *)(v10 + 2088);
    if ( v11 )
    {
      while ( *(_DWORD *)(v11 + 1540) )
      {
        v11 = *(_QWORD *)(v11 + 2080);
        if ( !v11 )
          goto LABEL_7;
      }
      sub_14007D720(v11, (__int64)v20);
      sub_1400CAA90(a1, a2, (LPARAM)v20, a4 + 1, v9);
    }
  }
LABEL_7:
  result = *(_QWORD *)(a3 + 2064);
  v13 = *(_QWORD *)(result + 2080);
  if ( v13 )
  {
    while ( *(_DWORD *)(v13 + 1540) )
    {
      v13 = *(_QWORD *)(v13 + 2080);
      if ( !v13 )
        return result;
    }
    sub_14007D720(v13, (__int64)v21);
    return sub_1400CAA90(a1, a2, (LPARAM)v21, a4, v9);
  }
  return result;
}

//----- (00000001400CAC10) ----------------------------------------------------
__int64 __fastcall sub_1400CAC10(HWND hWnd, char *a2)
{
  int v4; // esi
  int v5; // eax
  __int64 v6; // rax
  __int64 result; // rax
  int v8; // edx
  __int64 v9; // rcx
  _DWORD lParam[6]; // [rsp+20h] [rbp-8F8h] BYREF
  char *v11; // [rsp+38h] [rbp-8E0h]
  int v12; // [rsp+44h] [rbp-8D4h]
  __int64 v13; // [rsp+48h] [rbp-8D0h]
  LPARAM v14; // [rsp+70h] [rbp-8A8h] BYREF
  int v15; // [rsp+78h] [rbp-8A0h]
  char *v16; // [rsp+88h] [rbp-890h]
  char v17[2080]; // [rsp+C0h] [rbp-858h] BYREF

  v4 = 0;
  do
  {
    v5 = 15;
    if ( *((_DWORD *)a2 + 385) == 1 )
      v5 = 20;
    v12 = v5;
    v6 = *((_QWORD *)a2 + 258);
    lParam[0] = 7;
    lParam[1] = v4;
    lParam[2] = 0;
    v13 = v6;
    v11 = a2;
    SendMessageW(hWnd, 0x104Du, 0i64, (LPARAM)lParam);
    if ( *((_DWORD *)a2 + 385) == 1 )
    {
      v16 = a2 + 1544;
      v15 = 1;
      SendMessageW(hWnd, 0x1074u, v4, (LPARAM)&v14);
      v15 = 2;
      v16 = a2 + 512;
      SendMessageW(hWnd, 0x1074u, v4, (LPARAM)&v14);
    }
    result = *((_QWORD *)a2 + 258);
    v8 = -2147467259;
    v9 = *(_QWORD *)(result + 2080);
    if ( v9 )
    {
      result = sub_14007D720(v9, (__int64)v17);
      v8 = 0;
    }
    ++v4;
    a2 = v17;
  }
  while ( v8 >= 0 );
  return result;
}

//----- (00000001400CAD70) ----------------------------------------------------
__int64 __fastcall sub_1400CAD70(__int64 a1, HWND a2, LPARAM a3, __int64 a4)
{
  __int64 v5; // rcx
  int v6; // eax
  __int64 v9; // rcx
  LPARAM v10; // rax
  __int64 result; // rax
  __int64 v12; // rcx
  int v13; // [rsp+20h] [rbp-E0h]
  __int128 v15; // [rsp+30h] [rbp-D0h]
  __int128 v16; // [rsp+40h] [rbp-C0h]
  __int128 v17; // [rsp+50h] [rbp-B0h]
  __int128 v18; // [rsp+60h] [rbp-A0h]
  __int128 v19; // [rsp+70h] [rbp-90h]
  LPARAM lParam[2]; // [rsp+80h] [rbp-80h] BYREF
  __int128 v21; // [rsp+90h] [rbp-70h]
  __int128 v22; // [rsp+A0h] [rbp-60h]
  __int128 v23; // [rsp+B0h] [rbp-50h]
  __int128 v24; // [rsp+C0h] [rbp-40h]
  __int128 v25; // [rsp+D0h] [rbp-30h]
  char v26[2080]; // [rsp+E0h] [rbp-20h] BYREF
  char v27[2080]; // [rsp+900h] [rbp+800h] BYREF

  v5 = *(_QWORD *)(a4 + 2064);
  v6 = -2147467259;
  v13 = -2147467259;
  if ( !*(_DWORD *)(v5 + 1540) )
  {
    v9 = *(_QWORD *)(v5 + 2088);
    if ( v9 )
    {
      while ( *(_DWORD *)(v9 + 1540) )
      {
        v9 = *(_QWORD *)(v9 + 2080);
        if ( !v9 )
          goto LABEL_7;
      }
      sub_14007D720(v9, (__int64)v26);
      v6 = 0;
      v13 = 0;
    }
  }
LABEL_7:
  *(_QWORD *)&v18 = *(_QWORD *)(a4 + 2064);
  HIDWORD(v17) = v6 == 0;
  LODWORD(v15) = 103;
  *((_QWORD *)&v16 + 1) = a4;
  DWORD1(v17) = 15;
  DWORD2(v17) = 15;
  v21 = v15;
  v22 = v16;
  v24 = v18;
  lParam[0] = a3;
  lParam[1] = -65533i64;
  v23 = v17;
  v25 = v19;
  v10 = SendMessageW(a2, 0x1132u, 0i64, (LPARAM)lParam);
  if ( v13 >= 0 )
    sub_1400CAD70(a1, a2, v10, (__int64)v26);
  result = *(_QWORD *)(a4 + 2064);
  v12 = *(_QWORD *)(result + 2080);
  if ( v12 )
  {
    while ( *(_DWORD *)(v12 + 1540) )
    {
      v12 = *(_QWORD *)(v12 + 2080);
      if ( !v12 )
        return result;
    }
    sub_14007D720(v12, (__int64)v27);
    return sub_1400CAD70(a1, a2, a3, (__int64)v27);
  }
  return result;
}
// 1400CAE40: variable 'v15' is possibly undefined
// 1400CAE44: variable 'v16' is possibly undefined
// 1400CAE5D: variable 'v18' is possibly undefined
// 1400CAE6D: variable 'v17' is possibly undefined
// 1400CAE76: variable 'v19' is possibly undefined

//----- (00000001400CAF10) ----------------------------------------------------
void __fastcall sub_1400CAF10(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  int v5; // edx
  _DWORD *v6; // rcx
  __int64 v7; // rax
  int v8; // edx
  HWND v9; // rcx
  int v10; // eax
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rcx
  LPARAM lParam; // [rsp+20h] [rbp-1078h] BYREF
  __int16 v15; // [rsp+28h] [rbp-1070h]
  __int64 v16; // [rsp+30h] [rbp-1068h]
  char *v17; // [rsp+38h] [rbp-1060h]
  char v18[1536]; // [rsp+40h] [rbp-1058h] BYREF
  int v19; // [rsp+640h] [rbp-A58h]
  int v20; // [rsp+644h] [rbp-A54h]
  __int64 v21; // [rsp+850h] [rbp-848h]
  char v22[2080]; // [rsp+860h] [rbp-838h] BYREF

  v3 = *(_QWORD *)(a2 + 2064);
  if ( !*(_DWORD *)(v3 + 1540) )
  {
    v4 = *(_QWORD *)(v3 + 2088);
    if ( v4 )
    {
      sub_14007D720(v4, (__int64)v18);
      while ( 1 )
      {
        if ( v19 )
        {
          v5 = 0;
          v6 = (_DWORD *)(a1 + 61664);
          v7 = 0i64;
          while ( *v6 )
          {
            ++v7;
            ++v5;
            ++v6;
            if ( v7 >= 100 )
            {
              v8 = -1;
              goto LABEL_10;
            }
          }
          *(_DWORD *)(a1 + 4 * v7 + 61664) = 1;
          v8 = v5 + 46000;
LABEL_10:
          v9 = *(HWND *)(a1 + 1008);
          v10 = 20;
          if ( !v20 )
            v10 = 15;
          HIDWORD(lParam) = v8;
          LODWORD(lParam) = v10;
          v16 = (unsigned int)v21;
          v17 = v18;
          v15 = 28676;
          SendMessageW(v9, 0x444u, 1ui64, (LPARAM)&lParam);
          sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1008));
        }
        v11 = v21;
        if ( !v20 && !*(_DWORD *)(v21 + 1540) )
        {
          v12 = *(_QWORD *)(v21 + 2088);
          if ( v12 )
          {
            sub_14007D720(v12, (__int64)v22);
            sub_1400CAF10(a1, (__int64)v22);
            v11 = v21;
          }
        }
        v13 = *(_QWORD *)(v11 + 2080);
        if ( !v13 )
          break;
        sub_14007D720(v13, (__int64)v18);
      }
    }
  }
}

//----- (00000001400CB0B0) ----------------------------------------------------
int __fastcall sub_1400CB0B0(__int64 a1, HMENU a2, __int64 a3, UINT a4)
{
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  HMENU hmenu; // [rsp+30h] [rbp-D0h]
  MENUITEMINFOW mi; // [rsp+40h] [rbp-C0h] BYREF
  char v15[2080]; // [rsp+90h] [rbp-70h] BYREF
  char v16[2080]; // [rsp+8B0h] [rbp+7B0h] BYREF

  if ( a3 )
  {
    if ( *(_DWORD *)(a3 + 1540) == 1 )
    {
      mi.wID = dword_140120034;
      mi.cbSize = 80;
      mi.fMask = 66;
      ++dword_140120034;
      mi.dwTypeData = (LPWSTR)a3;
      InsertMenuItemW(a2, a4, 1, &mi);
      sub_1400B02C0(a2, a4);
      mi.cbSize = 80;
      mi.fMask = 32;
      GetMenuItemInfoW(a2, a4, 1, &mi);
      *(_QWORD *)(mi.dwItemData + 8) = *(_QWORD *)(a3 + 2064);
    }
    else
    {
      hmenu = CreateMenu();
      InsertMenuW(a2, a4, 0x410u, 0x3F2ui64, (LPCWSTR)a3);
      mi.hSubMenu = hmenu;
      mi.cbSize = 80;
      mi.fMask = 4;
      SetMenuItemInfoW(a2, a4, 1, &mi);
      sub_1400B02C0(a2, a4);
      mi.cbSize = 80;
      mi.fMask = 66;
      mi.wID = 40174;
      mi.dwTypeData = L"Bookmark This Tab...";
      InsertMenuItemW(hmenu, 0, 1, &mi);
      sub_1400B02C0(hmenu, 0);
      v8 = *(_QWORD *)(a3 + 2064);
      if ( !*(_DWORD *)(v8 + 1540) )
      {
        v9 = *(_QWORD *)(v8 + 2088);
        if ( v9 )
        {
          sub_14007D720(v9, (__int64)v15);
          mi.cbSize = 80;
          mi.fMask = 256;
          mi.fType = 2048;
          InsertMenuItemW(hmenu, 1u, 1, &mi);
          sub_1400B02C0(hmenu, 1u);
          sub_1400CB0B0(a1, hmenu, (__int64)v15, 2u);
        }
      }
    }
    v7 = *(_QWORD *)(a3 + 2064);
    v10 = *(_QWORD *)(v7 + 2080);
    if ( v10 )
    {
      sub_14007D720(v10, (__int64)v16);
      LODWORD(v7) = sub_1400CB0B0(a1, a2, (__int64)v16, a4 + 1);
    }
  }
  else
  {
    mi.cbSize = 80;
    mi.dwTypeData = L"Bookmark This Tab...";
    mi.fMask = 66;
    mi.wID = 40174;
    InsertMenuItemW(a2, 0, 1, &mi);
    LODWORD(v7) = sub_1400B02C0(a2, 0);
  }
  return v7;
}
// 1400F4AB0: using guessed type wchar_t aBookmarkThisTa[21];
// 1400F4AE0: using guessed type wchar_t aBookmarkThisTa_0[21];
// 140120034: using guessed type int dword_140120034;

//----- (00000001400CB360) ----------------------------------------------------
int __fastcall sub_1400CB360(__int64 a1)
{
  int v2; // eax
  int v3; // edi
  UINT v4; // esi
  HMENU v5; // rcx
  int result; // eax
  __int64 v7; // rcx
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-10A8h] BYREF
  char v9[2064]; // [rsp+70h] [rbp-1058h] BYREF
  __int64 v10; // [rsp+880h] [rbp-848h]
  char v11[2080]; // [rsp+890h] [rbp-838h] BYREF

  v2 = GetMenuItemCount(*(HMENU *)(a1 + 4864)) - 3;
  if ( v2 > 0 )
  {
    v3 = v2 - 1;
    if ( v2 - 1 >= 0 )
    {
      v4 = v3 + 3;
      do
      {
        v5 = *(HMENU *)(a1 + 4864);
        mii.cbSize = 80;
        mii.fMask = 32;
        GetMenuItemInfoW(v5, v4, 1, &mii);
        free((void *)mii.dwItemData);
        DeleteMenu(*(HMENU *)(a1 + 4864), v4--, 0x400u);
        --v3;
      }
      while ( v3 >= 0 );
    }
    dword_140120034 = 10000;
  }
  result = sub_14007DA80(a1 + 2664, (__int64)v9);
  if ( !*(_DWORD *)(v10 + 1540) )
  {
    v7 = *(_QWORD *)(v10 + 2088);
    if ( v7 )
    {
      sub_14007D720(v7, (__int64)v11);
      return sub_1400CB0B0(a1, *(HMENU *)(a1 + 4864), (__int64)v11, 3u);
    }
  }
  return result;
}
// 140120034: using guessed type int dword_140120034;
// 1400CB360: using guessed type char var_1058[2064];

//----- (00000001400CB4B0) ----------------------------------------------------
INT_PTR __fastcall sub_1400CB4B0(LPARAM a1, int a2)
{
  HWND v3; // rdx
  INT_PTR (__stdcall *v4)(HWND, UINT, WPARAM, LPARAM); // r8
  __int64 v5; // rcx
  INT_PTR result; // rax
  LPARAM dwInitParam[2]; // [rsp+20h] [rbp-868h] BYREF
  __int64 lParam[2]; // [rsp+30h] [rbp-858h] BYREF
  __int64 v9; // [rsp+40h] [rbp-848h]
  char v10[1540]; // [rsp+50h] [rbp-838h] BYREF
  int v11; // [rsp+654h] [rbp-234h]

  if ( a2 != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 1008), 0x417u, a2, (LPARAM)lParam);
    sub_14007D720(v9, (__int64)v10);
    v3 = *(HWND *)(a1 + 104);
    dwInitParam[1] = v9;
    dwInitParam[0] = a1;
    if ( v11 )
    {
      v4 = (INT_PTR (__stdcall *)(HWND, UINT, WPARAM, LPARAM))sub_1400D6610;
      v5 = 182i64;
    }
    else
    {
      v4 = (INT_PTR (__stdcall *)(HWND, UINT, WPARAM, LPARAM))sub_1400D6410;
      v5 = 212i64;
    }
    return sub_140001150((LPCWSTR)v5, v3, v4, (LPARAM)dwInitParam);
  }
  return result;
}
// 1400CB4B0: using guessed type LPARAM lParam[2];
// 1400CB4B0: using guessed type char var_838[1540];

//----- (00000001400CB560) ----------------------------------------------------
void __fastcall sub_1400CB560(__int64 a1, int a2)
{
  WPARAM v3; // rdi
  LPARAM lParam[4]; // [rsp+20h] [rbp-38h] BYREF

  if ( a2 != -1 )
  {
    v3 = a2;
    SendMessageW(*(HWND *)(a1 + 1008), 0x417u, a2, (LPARAM)lParam);
    if ( (unsigned int)sub_1400CA4B0(a1, *(HWND *)(a1 + 104), lParam[2]) )
    {
      SendMessageW(*(HWND *)(a1 + 1008), 0x416u, v3, 0i64);
      sub_1400CB360(a1);
    }
  }
}

//----- (00000001400CB600) ----------------------------------------------------
void __fastcall sub_1400CB600(__int64 a1, int a2, int a3)
{
  int v5; // eax
  __int64 v6; // r10
  __int64 v7; // rcx
  bool v8; // zf
  int v9; // ebx
  LPVOID pv; // [rsp+30h] [rbp-868h] BYREF
  LPARAM lParam[5]; // [rsp+38h] [rbp-860h] BYREF
  char v12[1540]; // [rsp+60h] [rbp-838h] BYREF
  int v13; // [rsp+664h] [rbp-234h]
  char v14[536]; // [rsp+668h] [rbp-230h] BYREF

  if ( a2 != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 1008), 0x417u, a2, (LPARAM)lParam);
    sub_14007D720(lParam[2], (__int64)v12);
    if ( v13 == 1 )
    {
      pv = 0i64;
      v5 = sub_14007F810((__int64)v14, (__int64)&pv);
      v6 = *(_QWORD *)(a1 + 56);
      v7 = a1 + 56;
      v8 = a3 == 0;
      v9 = v5;
      if ( v8 )
        (*(void (__fastcall **)(__int64, LPVOID, _QWORD, _QWORD, _DWORD, _DWORD))(v6 + 80))(v7, pv, 0i64, 0i64, 0, 0);
      else
        (*(void (__fastcall **)(__int64, LPVOID, _QWORD, __int64, int, _DWORD))(v6 + 80))(v7, pv, 0i64, 1i64, 1, 0);
      if ( v9 >= 0 )
        CoTaskMemFree(pv);
    }
  }
}
// 1400CB600: using guessed type char var_838[1540];
// 1400CB600: using guessed type char var_230[536];

//----- (00000001400CB700) ----------------------------------------------------
__int64 __fastcall sub_1400CB700(HMENU a1, UINT a2, char *a3)
{
  __int64 v4; // r11
  signed __int64 v5; // rcx
  __int16 v6; // ax
  __int64 result; // rax
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-888h] BYREF
  char v9[1544]; // [rsp+70h] [rbp-838h] BYREF
  char v10[536]; // [rsp+678h] [rbp-230h] BYREF

  mii.cbSize = 80;
  mii.fMask = 32;
  GetMenuItemInfoW(a1, a2, 0, &mii);
  sub_14007D720(*(_QWORD *)(mii.dwItemData + 8), (__int64)v9);
  v4 = 260i64;
  v5 = v10 - a3;
  while ( v4 != -2147483386 )
  {
    v6 = *(_WORD *)&a3[v5];
    if ( !v6 )
      break;
    *(_WORD *)a3 = v6;
    a3 += 2;
    if ( !--v4 )
    {
      result = 0i64;
      *((_WORD *)a3 - 1) = 0;
      return result;
    }
  }
  result = 0i64;
  *(_WORD *)a3 = 0;
  return result;
}
// 1400CB78C: conditional instruction was optimized away because r11.8!=0
// 1400CB700: using guessed type char var_838[1544];
// 1400CB700: using guessed type char var_230[536];

//----- (00000001400CB7C0) ----------------------------------------------------
__int64 __fastcall sub_1400CB7C0(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  DWORD MessagePos; // eax
  HWND v10; // rdx
  int v11; // eax
  struct tagPOINT Points; // [rsp+20h] [rbp-888h] BYREF
  LPARAM lParam[5]; // [rsp+28h] [rbp-880h] BYREF
  char v15[1540]; // [rsp+50h] [rbp-858h] BYREF
  int v16; // [rsp+654h] [rbp-254h]
  __int16 v17[268]; // [rsp+658h] [rbp-250h] BYREF

  if ( a3 == 520 )
  {
    MessagePos = GetMessagePos();
    v10 = *(HWND *)(a1 + 1008);
    Points.x = (__int16)MessagePos;
    Points.y = SHIWORD(MessagePos);
    MapWindowPoints(0i64, v10, &Points, 1u);
    v11 = SendMessageW(*(HWND *)(a1 + 1008), 0x445u, 0i64, (LPARAM)&Points);
    if ( v11 >= 0 )
    {
      SendMessageW(*(HWND *)(a1 + 1008), 0x417u, v11, (LPARAM)lParam);
      sub_14007D720(lParam[2], (__int64)v15);
      if ( v16 == 1 )
        sub_1400CA970(a1, (const WCHAR *)v17, 1u, 1);
    }
  }
  return sub_140001A20(a2, a3, a4, a5);
}
// 1400CB7C0: using guessed type char var_858[1540];
// 1400CB7C0: using guessed type WCHAR var_250[268];

//----- (00000001400CB8D0) ----------------------------------------------------
__int64 __fastcall sub_1400CB8D0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  return sub_1400CB7C0(a6, a1, a2, a3, a4);
}

//----- (00000001400CB930) ----------------------------------------------------
void __fastcall sub_1400CB930(__int64 a1)
{
  __int64 v2; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  char v5[2080]; // [rsp+30h] [rbp-838h] BYREF

  v2 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 1);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v2, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(*(HWND *)(a1 + 1008), 0x430u, 0i64, v2);
  sub_14007DA80(a1 + 2664, (__int64)v5);
  sub_1400CAF10(a1, (__int64)v5);
}

//----- (00000001400CBA10) ----------------------------------------------------
void __fastcall sub_1400CBA10(LPARAM a1, int a2)
{
  HWND v3; // rdx
  LPARAM v4; // rax
  LPARAM dwInitParam[3]; // [rsp+20h] [rbp-878h] BYREF
  int v6; // [rsp+38h] [rbp-860h]
  __int64 lParam[2]; // [rsp+40h] [rbp-858h] BYREF
  __int64 v8; // [rsp+50h] [rbp-848h]
  char v9[1540]; // [rsp+60h] [rbp-838h] BYREF
  int v10; // [rsp+664h] [rbp-234h]

  if ( a2 != -1 )
  {
    SendMessageW(*(HWND *)(a1 + 1008), 0x417u, a2, (LPARAM)lParam);
    sub_14007D720(v8, (__int64)v9);
    v3 = *(HWND *)(a1 + 104);
    v4 = 0i64;
    if ( !v10 )
      v4 = v8;
    dwInitParam[0] = a1;
    dwInitParam[2] = 0i64;
    v6 = 1;
    dwInitParam[1] = v4;
    sub_140001150((LPCWSTR)0xB3, v3, (DLGPROC)sub_1400CF380, (LPARAM)dwInitParam);
  }
}
// 1400CBA10: using guessed type LPARAM lParam[2];
// 1400CBA10: using guessed type char var_838[1540];

//----- (00000001400CBAC0) ----------------------------------------------------
BOOL __fastcall sub_1400CBAC0(__int64 a1)
{
  signed int i; // ebx
  HMENU v3; // rcx
  HMENU v4; // rcx
  BOOL result; // eax
  struct tagMENUITEMINFOW mii; // [rsp+20h] [rbp-58h] BYREF

  for ( i = *(_DWORD *)(a1 + 7052) - 1; i >= 0; --i )
  {
    v3 = *(HMENU *)(a1 + 4832);
    mii.cbSize = 80;
    mii.fMask = 32;
    GetMenuItemInfoW(v3, i, 1, &mii);
    free((void *)mii.dwItemData);
    v4 = *(HMENU *)(a1 + 4840);
    mii.cbSize = 80;
    mii.fMask = 32;
    GetMenuItemInfoW(v4, i, 1, &mii);
    free((void *)mii.dwItemData);
    DeleteMenu(*(HMENU *)(a1 + 4832), i, 0x400u);
    DeleteMenu(*(HMENU *)(a1 + 4848), i, 0x400u);
    DeleteMenu(*(HMENU *)(a1 + 4840), i, 0x400u);
    result = DeleteMenu(*(HMENU *)(a1 + 4856), i, 0x400u);
  }
  return result;
}

//----- (00000001400CBBC0) ----------------------------------------------------
__int64 __fastcall sub_1400CBBC0(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 50100i64;
      break;
    case 2:
      result = 50103i64;
      break;
    case 3:
      result = 50101i64;
      break;
    case 4:
      result = 50102i64;
      break;
    case 5:
      result = 50104i64;
      break;
    case 6:
      result = 50105i64;
      break;
    case 7:
      result = 50127i64;
      break;
    case 8:
      result = 50107i64;
      break;
    case 9:
      result = 50108i64;
      break;
    case 10:
      result = 50109i64;
      break;
    case 11:
      result = 50110i64;
      break;
    case 12:
      result = 50111i64;
      break;
    case 13:
      result = 50112i64;
      break;
    case 14:
      result = 50113i64;
      break;
    case 15:
      result = 50114i64;
      break;
    case 16:
      result = 50115i64;
      break;
    case 17:
      result = 50116i64;
      break;
    case 18:
      result = 50117i64;
      break;
    case 19:
      result = 50118i64;
      break;
    case 20:
      result = 50119i64;
      break;
    case 21:
      result = 50120i64;
      break;
    case 22:
      result = 50121i64;
      break;
    case 23:
      result = 50122i64;
      break;
    case 24:
      result = 50123i64;
      break;
    case 25:
      result = 50124i64;
      break;
    case 26:
      result = 50125i64;
      break;
    case 27:
      result = 50126i64;
      break;
    case 29:
      result = 50128i64;
      break;
    case 30:
      result = 50129i64;
      break;
    case 31:
      result = 50130i64;
      break;
    case 32:
      result = 50131i64;
      break;
    case 33:
      result = 50132i64;
      break;
    case 34:
      result = 50133i64;
      break;
    case 35:
      result = 50134i64;
      break;
    case 36:
      result = 50135i64;
      break;
    case 37:
      result = 50136i64;
      break;
    case 38:
      result = 50137i64;
      break;
    case 39:
      result = 50138i64;
      break;
    case 40:
      result = 50139i64;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (00000001400CBD80) ----------------------------------------------------
__int64 __fastcall sub_1400CBD80(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1:
      result = 50000i64;
      break;
    case 2:
      result = 50003i64;
      break;
    case 3:
      result = 50001i64;
      break;
    case 4:
      result = 50002i64;
      break;
    case 5:
      result = 50004i64;
      break;
    case 6:
      result = 50005i64;
      break;
    case 7:
      result = 50027i64;
      break;
    case 8:
      result = 50007i64;
      break;
    case 9:
      result = 50008i64;
      break;
    case 10:
      result = 50009i64;
      break;
    case 11:
      result = 50010i64;
      break;
    case 12:
      result = 50011i64;
      break;
    case 13:
      result = 50012i64;
      break;
    case 14:
      result = 50013i64;
      break;
    case 15:
      result = 50014i64;
      break;
    case 16:
      result = 50015i64;
      break;
    case 17:
      result = 50016i64;
      break;
    case 18:
      result = 50017i64;
      break;
    case 19:
      result = 50018i64;
      break;
    case 20:
      result = 50019i64;
      break;
    case 21:
      result = 50020i64;
      break;
    case 22:
      result = 50021i64;
      break;
    case 23:
      result = 50022i64;
      break;
    case 24:
      result = 50023i64;
      break;
    case 25:
      result = 50024i64;
      break;
    case 26:
      result = 50025i64;
      break;
    case 27:
      result = 50026i64;
      break;
    case 29:
      result = 50028i64;
      break;
    case 30:
      result = 50029i64;
      break;
    case 31:
      result = 50030i64;
      break;
    case 32:
      result = 50031i64;
      break;
    case 33:
      result = 50032i64;
      break;
    case 34:
      result = 50033i64;
      break;
    case 35:
      result = 50034i64;
      break;
    case 36:
      result = 50035i64;
      break;
    case 37:
      result = 50036i64;
      break;
    case 38:
      result = 50037i64;
      break;
    case 39:
      result = 50038i64;
      break;
    case 40:
      result = 50039i64;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (00000001400CBF40) ----------------------------------------------------
__int64 __fastcall sub_1400CBF40(__int64 a1)
{
  __int64 result; // rax
  bool v3; // zf
  WCHAR psz2[264]; // [rsp+20h] [rbp-228h] BYREF

  sub_14007E090(17, psz2);
  if ( StrCmpW((PCWSTR)(a1 + 4920), psz2) )
  {
    sub_14007E090(3, psz2);
    if ( StrCmpW((PCWSTR)(a1 + 4920), psz2) )
    {
      v3 = !sub_1400B5590(a1, 10);
      result = a1 + 63240;
      if ( v3 )
        result = a1 + 63168;
    }
    else
    {
      result = a1 + 63216;
    }
  }
  else
  {
    result = a1 + 63192;
  }
  *(_QWORD *)(a1 + 63160) = result;
  return result;
}

//----- (00000001400CC010) ----------------------------------------------------
__int64 __fastcall sub_1400CC010(int a1)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 50000:
      result = 8009i64;
      break;
    case 50001:
      result = 8010i64;
      break;
    case 50002:
    case 50034:
      result = 8011i64;
      break;
    case 50003:
      result = 8012i64;
      break;
    case 50004:
      result = 8013i64;
      break;
    case 50005:
      result = 8014i64;
      break;
    case 50007:
      result = 8015i64;
      break;
    case 50008:
      result = 8016i64;
      break;
    case 50009:
      result = 8017i64;
      break;
    case 50010:
      result = 8018i64;
      break;
    case 50011:
      result = 8019i64;
      break;
    case 50012:
      result = 8020i64;
      break;
    case 50013:
      result = 8021i64;
      break;
    case 50014:
      result = 8022i64;
      break;
    case 50015:
      result = 8023i64;
      break;
    case 50016:
      result = 8024i64;
      break;
    case 50017:
      result = 8025i64;
      break;
    case 50018:
      result = 8026i64;
      break;
    case 50019:
      result = 8027i64;
      break;
    case 50020:
      result = 8028i64;
      break;
    case 50021:
      result = 8029i64;
      break;
    case 50022:
      result = 8030i64;
      break;
    case 50023:
      result = 8031i64;
      break;
    case 50024:
      result = 8032i64;
      break;
    case 50025:
      result = 8033i64;
      break;
    case 50026:
      result = 8034i64;
      break;
    case 50027:
    case 50032:
    case 50037:
      result = 8035i64;
      break;
    case 50028:
      result = 8036i64;
      break;
    case 50029:
      result = 8037i64;
      break;
    case 50030:
      result = 8038i64;
      break;
    case 50031:
      result = 8039i64;
      break;
    case 50033:
      result = 8040i64;
      break;
    case 50035:
      result = 8041i64;
      break;
    case 50036:
      result = 8042i64;
      break;
    case 50038:
      result = 8043i64;
      break;
    case 50039:
      result = 8044i64;
      break;
    default:
      result = 0i64;
      break;
  }
  return result;
}

//----- (00000001400CC1C0) ----------------------------------------------------
__int64 __fastcall sub_1400CC1C0(__int64 a1, HMENU a2)
{
  __int64 **v2; // rax
  UINT v3; // edi
  __int64 *v6; // rbx
  UINT v7; // eax
  HMENU v8; // rcx
  MENUITEMINFOW mi; // [rsp+20h] [rbp-B8h] BYREF
  WCHAR Buffer[32]; // [rsp+70h] [rbp-68h] BYREF

  v2 = *(__int64 ***)(a1 + 63160);
  v3 = 0;
  v6 = (__int64 *)**v2;
  if ( v6 != *v2 )
  {
    do
    {
      v7 = sub_1400CC010(*((_DWORD *)v6 + 4));
      LoadStringW(hInstance, v7, Buffer, 32);
      mi.cbSize = 80;
      mi.dwTypeData = Buffer;
      mi.fMask = 66;
      mi.wID = *((_DWORD *)v6 + 4);
      InsertMenuItemW(a2, v3, 1, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 4848), v3, 1, &mi);
      memset(&mi, 0, sizeof(mi));
      v8 = *(HMENU *)(a1 + 4840);
      mi.dwTypeData = Buffer;
      mi.cbSize = 80;
      mi.fMask = 66;
      mi.wID = *((_DWORD *)v6 + 5);
      InsertMenuItemW(v8, v3, 1, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 4856), v3, 1, &mi);
      v6 = (__int64 *)*v6;
      ++v3;
    }
    while ( v6 != **(__int64 ***)(a1 + 63160) );
  }
  return v3;
}

//----- (00000001400CC320) ----------------------------------------------------
char **__fastcall sub_1400CC320(__int64 a1)
{
  HMENU Menu; // rax
  HMENU SubMenu; // rax
  HMENU v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rdx
  char *v7; // r11
  __int64 v8; // rax
  __int64 v9; // rsi
  char *v10; // r11
  __int64 v11; // rax
  __int64 v12; // rsi
  char *v13; // r11
  __int64 v14; // rax
  __int64 v15; // rsi
  char *v16; // r11
  __int64 v17; // rax
  __int64 v18; // rsi
  char *v19; // r11
  __int64 v20; // rax
  __int64 v21; // rsi
  char *v22; // r11
  __int64 v23; // rax
  __int64 v24; // rsi
  char *v25; // r11
  __int64 v26; // rax
  __int64 v27; // rsi
  char *v28; // r11
  __int64 v29; // rax
  __int64 v30; // rsi
  char *v31; // r11
  __int64 v32; // rax
  __int64 v33; // rsi
  char *v34; // r11
  __int64 v35; // rax
  __int64 v36; // rsi
  char *v37; // r11
  __int64 v38; // rax
  __int64 v39; // rsi
  char *v40; // r11
  __int64 v41; // rax
  __int64 v42; // rsi
  char *v43; // r11
  __int64 v44; // rax
  __int64 v45; // rsi
  char *v46; // r11
  __int64 v47; // rax
  __int64 v48; // rsi
  char *v49; // r11
  __int64 v50; // rax
  __int64 v51; // rsi
  char *v52; // r11
  __int64 v53; // rax
  __int64 v54; // rsi
  char *v55; // r11
  __int64 v56; // rax
  char **result; // rax
  MENUITEMINFOW mii; // [rsp+20h] [rbp-50h] BYREF
  __int64 v59; // [rsp+80h] [rbp+10h] BYREF

  Menu = GetMenu(*(HWND *)(a1 + 104));
  SubMenu = GetSubMenu(Menu, 3);
  mii.hSubMenu = *(HMENU *)(a1 + 4832);
  v4 = SubMenu;
  mii.cbSize = 80;
  mii.fMask = 4;
  SetMenuItemInfoW(SubMenu, 0x9D5Du, 0, &mii);
  mii.hSubMenu = *(HMENU *)(a1 + 4840);
  mii.cbSize = 80;
  mii.fMask = 4;
  SetMenuItemInfoW(v4, 0x9DB9u, 0, &mii);
  v5 = *(_QWORD *)(a1 + 63168);
  v6 = *(_QWORD *)(v5 + 8);
  v59 = 0xC3B40000C350i64;
  v7 = sub_14000BB70(v5, v6, &v59);
  v8 = *(_QWORD *)(a1 + 63176);
  if ( v8 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50001;
  *(_QWORD *)(a1 + 63176) = v8 + 1;
  *(_QWORD *)(v5 + 8) = v7;
  **((_QWORD **)v7 + 1) = v7;
  v9 = *(_QWORD *)(a1 + 63168);
  HIDWORD(v59) = 50101;
  v10 = sub_14000BB70(v9, *(_QWORD *)(v9 + 8), &v59);
  v11 = *(_QWORD *)(a1 + 63176);
  if ( v11 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50002;
  *(_QWORD *)(a1 + 63176) = v11 + 1;
  *(_QWORD *)(v9 + 8) = v10;
  **((_QWORD **)v10 + 1) = v10;
  v12 = *(_QWORD *)(a1 + 63168);
  HIDWORD(v59) = 50102;
  v13 = sub_14000BB70(v12, *(_QWORD *)(v12 + 8), &v59);
  v14 = *(_QWORD *)(a1 + 63176);
  if ( v14 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50003;
  *(_QWORD *)(a1 + 63176) = v14 + 1;
  *(_QWORD *)(v12 + 8) = v13;
  **((_QWORD **)v13 + 1) = v13;
  v15 = *(_QWORD *)(a1 + 63168);
  HIDWORD(v59) = 50103;
  v16 = sub_14000BB70(v15, *(_QWORD *)(v15 + 8), &v59);
  v17 = *(_QWORD *)(a1 + 63176);
  if ( v17 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50000;
  *(_QWORD *)(a1 + 63176) = v17 + 1;
  *(_QWORD *)(v15 + 8) = v16;
  **((_QWORD **)v16 + 1) = v16;
  v18 = *(_QWORD *)(a1 + 63192);
  HIDWORD(v59) = 50100;
  v19 = sub_14000BB70(v18, *(_QWORD *)(v18 + 8), &v59);
  v20 = *(_QWORD *)(a1 + 63200);
  if ( v20 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50002;
  *(_QWORD *)(a1 + 63200) = v20 + 1;
  *(_QWORD *)(v18 + 8) = v19;
  **((_QWORD **)v19 + 1) = v19;
  v21 = *(_QWORD *)(a1 + 63192);
  HIDWORD(v59) = 50102;
  v22 = sub_14000BB70(v21, *(_QWORD *)(v21 + 8), &v59);
  v23 = *(_QWORD *)(a1 + 63200);
  if ( v23 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50004;
  *(_QWORD *)(a1 + 63200) = v23 + 1;
  *(_QWORD *)(v21 + 8) = v22;
  **((_QWORD **)v22 + 1) = v22;
  v24 = *(_QWORD *)(a1 + 63192);
  HIDWORD(v59) = 50104;
  v25 = sub_14000BB70(v24, *(_QWORD *)(v24 + 8), &v59);
  v26 = *(_QWORD *)(a1 + 63200);
  if ( v26 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50005;
  *(_QWORD *)(a1 + 63200) = v26 + 1;
  *(_QWORD *)(v24 + 8) = v25;
  **((_QWORD **)v25 + 1) = v25;
  v27 = *(_QWORD *)(a1 + 63192);
  HIDWORD(v59) = 50105;
  v28 = sub_14000BB70(v27, *(_QWORD *)(v27 + 8), &v59);
  v29 = *(_QWORD *)(a1 + 63200);
  if ( v29 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50027;
  *(_QWORD *)(a1 + 63200) = v29 + 1;
  *(_QWORD *)(v27 + 8) = v28;
  **((_QWORD **)v28 + 1) = v28;
  v30 = *(_QWORD *)(a1 + 63192);
  HIDWORD(v59) = 50127;
  v31 = sub_14000BB70(v30, *(_QWORD *)(v30 + 8), &v59);
  v32 = *(_QWORD *)(a1 + 63200);
  if ( v32 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50000;
  *(_QWORD *)(a1 + 63200) = v32 + 1;
  *(_QWORD *)(v30 + 8) = v31;
  **((_QWORD **)v31 + 1) = v31;
  v33 = *(_QWORD *)(a1 + 63216);
  HIDWORD(v59) = 50100;
  v34 = sub_14000BB70(v33, *(_QWORD *)(v33 + 8), &v59);
  v35 = *(_QWORD *)(a1 + 63224);
  if ( v35 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50027;
  *(_QWORD *)(a1 + 63224) = v35 + 1;
  *(_QWORD *)(v33 + 8) = v34;
  **((_QWORD **)v34 + 1) = v34;
  v36 = *(_QWORD *)(a1 + 63216);
  HIDWORD(v59) = 50127;
  v37 = sub_14000BB70(v36, *(_QWORD *)(v36 + 8), &v59);
  v38 = *(_QWORD *)(a1 + 63224);
  if ( v38 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50000;
  *(_QWORD *)(a1 + 63224) = v38 + 1;
  *(_QWORD *)(v36 + 8) = v37;
  **((_QWORD **)v37 + 1) = v37;
  v39 = *(_QWORD *)(a1 + 63240);
  HIDWORD(v59) = 50100;
  v40 = sub_14000BB70(v39, *(_QWORD *)(v39 + 8), &v59);
  v41 = *(_QWORD *)(a1 + 63248);
  if ( v41 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50008;
  *(_QWORD *)(a1 + 63248) = v41 + 1;
  *(_QWORD *)(v39 + 8) = v40;
  **((_QWORD **)v40 + 1) = v40;
  v42 = *(_QWORD *)(a1 + 63240);
  HIDWORD(v59) = 50108;
  v43 = sub_14000BB70(v42, *(_QWORD *)(v42 + 8), &v59);
  v44 = *(_QWORD *)(a1 + 63248);
  if ( v44 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50007;
  *(_QWORD *)(a1 + 63248) = v44 + 1;
  *(_QWORD *)(v42 + 8) = v43;
  **((_QWORD **)v43 + 1) = v43;
  v45 = *(_QWORD *)(a1 + 63240);
  HIDWORD(v59) = 50107;
  v46 = sub_14000BB70(v45, *(_QWORD *)(v45 + 8), &v59);
  v47 = *(_QWORD *)(a1 + 63248);
  if ( v47 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  HIDWORD(v59) = 50101;
  *(_QWORD *)(a1 + 63248) = v47 + 1;
  *(_QWORD *)(v45 + 8) = v46;
  **((_QWORD **)v46 + 1) = v46;
  v48 = *(_QWORD *)(a1 + 63240);
  v49 = sub_14000BB70(v48, *(_QWORD *)(v48 + 8), &v59);
  v50 = *(_QWORD *)(a1 + 63248);
  if ( v50 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50002;
  *(_QWORD *)(a1 + 63248) = v50 + 1;
  *(_QWORD *)(v48 + 8) = v49;
  **((_QWORD **)v49 + 1) = v49;
  v51 = *(_QWORD *)(a1 + 63240);
  HIDWORD(v59) = 50102;
  v52 = sub_14000BB70(v51, *(_QWORD *)(v51 + 8), &v59);
  v53 = *(_QWORD *)(a1 + 63248);
  if ( v53 == 0x1FFFFFFFFFFFFFFEi64 )
    sub_14002B5F8("list<T> too long");
  LODWORD(v59) = 50003;
  *(_QWORD *)(a1 + 63248) = v53 + 1;
  *(_QWORD *)(v51 + 8) = v52;
  **((_QWORD **)v52 + 1) = v52;
  v54 = *(_QWORD *)(a1 + 63240);
  HIDWORD(v59) = 50103;
  v55 = sub_14000BB70(v54, *(_QWORD *)(v54 + 8), &v59);
  v56 = *(_QWORD *)(a1 + 63248);
  if ( 0x1FFFFFFFFFFFFFFEi64 == v56 )
    sub_14002B5F8("list<T> too long");
  *(_QWORD *)(a1 + 63248) = v56 + 1;
  *(_QWORD *)(v54 + 8) = v55;
  result = (char **)*((_QWORD *)v55 + 1);
  *result = v55;
  return result;
}

//----- (00000001400CCA00) ----------------------------------------------------
void __fastcall sub_1400CCA00(__int64 a1)
{
  _QWORD *v2; // rax
  __int64 *v3; // rsi
  _QWORD **v4; // rax
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  void ***v7; // r9
  void **v8; // rbx
  int v9; // er8
  unsigned int v10; // eax
  unsigned int v11; // er10
  __int64 v12; // rdi
  char *v13; // rax
  __int64 v14; // rdx
  void **v15; // rcx
  void **v16; // rbx
  int v17; // eax
  void **v18; // rcx
  void *v19; // rax
  void **v20; // rbx
  void *Block; // [rsp+28h] [rbp-38h] BYREF
  __int64 v22; // [rsp+30h] [rbp-30h]
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int64 v24; // [rsp+98h] [rbp+38h] BYREF
  char *v25; // [rsp+A0h] [rbp+40h] BYREF

  v22 = 0i64;
  v2 = operator new(0x18ui64);
  if ( !v2 )
  {
    v25 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v25);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  Block = v2;
  *v2 = v2;
  *((_QWORD *)Block + 1) = Block;
  sub_1400CBAC0(a1);
  (*(void (__fastcall **)(_QWORD, void **))(**(_QWORD **)(a1 + 2640) + 568i64))(*(_QWORD *)(a1 + 2640), &Block);
  v3 = (__int64 *)(a1 + 63136);
  v4 = *(_QWORD ***)(a1 + 63136);
  v5 = *v4;
  *v4 = v4;
  *(_QWORD *)(*(_QWORD *)(a1 + 63136) + 8i64) = *(_QWORD *)(a1 + 63136);
  *(_QWORD *)(a1 + 63144) = 0i64;
  if ( v5 != *(_QWORD **)(a1 + 63136) )
  {
    do
    {
      v6 = (_QWORD *)*v5;
      j_free(v5);
      v5 = v6;
    }
    while ( v6 != (_QWORD *)*v3 );
  }
  if ( v22 )
  {
    v7 = (void ***)Block;
    v8 = *(void ***)Block;
    if ( *(void **)Block != Block )
    {
      do
      {
        sub_1400CBD80(*((_DWORD *)v8 + 4));
        v10 = sub_1400CBBC0(v9);
        if ( v11 != -1 && v10 != -1 )
        {
          v24 = __PAIR64__(v10, v11);
          v12 = *v3;
          v13 = sub_14000BB70(*v3, *(_QWORD *)(*v3 + 8), &v24);
          v14 = *(_QWORD *)(a1 + 63144);
          if ( v14 == 0x1FFFFFFFFFFFFFFEi64 )
            sub_14002B5F8("list<T> too long");
          *(_QWORD *)(a1 + 63144) = v14 + 1;
          *(_QWORD *)(v12 + 8) = v13;
          **((_QWORD **)v13 + 1) = v13;
          v7 = (void ***)Block;
        }
        v8 = (void **)*v8;
      }
      while ( v8 != (void **)v7 );
    }
    *(_QWORD *)(a1 + 63160) = v3;
  }
  else
  {
    sub_1400CBF40(a1);
    v7 = (void ***)Block;
  }
  v15 = *v7;
  *v7 = (void **)v7;
  *((_QWORD *)Block + 1) = Block;
  v22 = 0i64;
  if ( v15 != Block )
  {
    do
    {
      v16 = (void **)*v15;
      j_free(v15);
      v15 = v16;
    }
    while ( v16 != Block );
  }
  v17 = sub_1400CC1C0(a1, *(HMENU *)(a1 + 4832));
  *(_DWORD *)(a1 + 7052) = v17;
  sub_1400B08E0(a1, *(HMENU *)(a1 + 4832), v17);
  sub_1400B08E0(a1, *(HMENU *)(a1 + 4840), *(_DWORD *)(a1 + 7052));
  v18 = *(void ***)Block;
  *(_QWORD *)Block = Block;
  *((_QWORD *)Block + 1) = Block;
  v22 = 0i64;
  v19 = Block;
  if ( v18 != Block )
  {
    do
    {
      v20 = (void **)*v18;
      j_free(v18);
      v18 = v20;
      v19 = Block;
    }
    while ( v20 != Block );
  }
  j_free(v19);
}
// 1400CCAE2: variable 'v9' is possibly undefined
// 1400CCAEB: variable 'v11' is possibly undefined
// 1400CCB39: variable 'v7' is possibly undefined
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400CCC60) ----------------------------------------------------
BOOL __fastcall sub_1400CCC60(__int64 a1)
{
  HMENU v2; // rcx
  HMENU v3; // rcx
  MENUITEMINFOW mi; // [rsp+20h] [rbp-58h] BYREF

  v2 = *(HMENU *)(a1 + 4880);
  mi.cbSize = 80;
  mi.fMask = 66;
  mi.wID = 40360;
  mi.dwTypeData = L"New Application Button...";
  InsertMenuItemW(v2, 7u, 1, &mi);
  sub_1400B02C0(*(HMENU *)(a1 + 4880), 7u);
  sub_1400AFF90(a1);
  v3 = *(HMENU *)(a1 + 4880);
  mi.cbSize = 80;
  mi.fMask = 32;
  GetMenuItemInfoW(v3, 7u, 1, &mi);
  free((void *)mi.dwItemData);
  return DeleteMenu(*(HMENU *)(a1 + 4880), 7u, 0x400u);
}
// 1400F4B80: using guessed type wchar_t aNewApplication[26];

//----- (00000001400CCD20) ----------------------------------------------------
HWND __fastcall sub_1400CCD20(HWND hWnd)
{
  HWND DlgItem; // rbx
  WCHAR Buffer[64]; // [rsp+20h] [rbp-98h] BYREF

  DlgItem = GetDlgItem(hWnd, 1200);
  CheckDlgButton(hWnd, 1222, 1u);
  LoadStringW(hInstance, 0x84Bu, Buffer, 64);
  SetWindowTextW(hWnd, Buffer);
  return SetFocus(DlgItem);
}

//----- (00000001400CCDC0) ----------------------------------------------------
HWND __fastcall sub_1400CCDC0(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbp
  HWND v5; // rbx

  DlgItem = GetDlgItem(a2, 1200);
  v5 = GetDlgItem(a2, 1199);
  SetWindowTextW(DlgItem, *(LPCWSTR *)(a1 + 62112));
  SetWindowTextW(v5, (LPCWSTR)(*(_QWORD *)(a1 + 62112) + 1024i64));
  CheckDlgButton(a2, 1222, *(_DWORD *)(*(_QWORD *)(a1 + 62112) + 2048i64) != 0);
  SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
  return SetFocus(DlgItem);
}

//----- (00000001400CCE80) ----------------------------------------------------
void __fastcall sub_1400CCE80(__int64 a1, int a2)
{
  LPARAM v3; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // rbx
  HWND v7; // rcx
  void *v8; // rax
  HANDLE TokenHandle; // [rsp+30h] [rbp-548h] BYREF
  LPARAM v10; // [rsp+38h] [rbp-540h] BYREF
  int iIcon; // [rsp+44h] [rbp-534h]
  void *v12; // [rsp+58h] [rbp-520h]
  LPARAM lParam[5]; // [rsp+68h] [rbp-510h] BYREF
  SHFILEINFOW psfi; // [rsp+90h] [rbp-4E8h] BYREF
  WCHAR Dest[264]; // [rsp+350h] [rbp-228h] BYREF

  if ( a2 != -1 && SendMessageW(*(HWND *)(a1 + 1024), 0x417u, a2, (LPARAM)lParam) )
  {
    v3 = lParam[2];
    CurrentProcessId = GetCurrentProcessId();
    v5 = OpenProcess(0x400u, 0, CurrentProcessId);
    v6 = v5;
    if ( v5 )
    {
      if ( OpenProcessToken(v5, 0xCu, &TokenHandle) )
      {
        ExpandEnvironmentStringsForUserW(TokenHandle, (LPCWSTR)(v3 + 1024), Dest, 0x104u);
        CloseHandle(TokenHandle);
      }
      CloseHandle(v6);
    }
    SHGetFileInfoW(Dest, 0, &psfi, 0x2B8u, 0x4000u);
    v7 = *(HWND *)(a1 + 1024);
    iIcon = psfi.iIcon;
    v10 = 0x300000030i64;
    v8 = &unk_1400ECAF4;
    if ( *(_DWORD *)(v3 + 2048) )
      v8 = (void *)v3;
    v12 = v8;
    SendMessageW(v7, 0x440u, SHIDWORD(lParam[0]), (LPARAM)&v10);
  }
}

//----- (00000001400CCFF0) ----------------------------------------------------
__int64 __fastcall sub_1400CCFF0(__int64 a1, __int64 a2)
{
  DWORD CurrentProcessId; // eax
  HANDLE v5; // rax
  void *v6; // rbx
  DWORD_PTR v7; // rax
  int iIcon; // ecx
  int v9; // ecx
  int v10; // eax
  HWND v11; // rcx
  HANDLE TokenHandle; // [rsp+30h] [rbp-518h] BYREF
  LPARAM lParam; // [rsp+38h] [rbp-510h] BYREF
  __int16 v15; // [rsp+40h] [rbp-508h]
  __int64 v16; // [rsp+48h] [rbp-500h]
  __int64 v17; // [rsp+50h] [rbp-4F8h]
  SHFILEINFOW psfi; // [rsp+60h] [rbp-4E8h] BYREF
  WCHAR Dest[264]; // [rsp+320h] [rbp-228h] BYREF

  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x400u, 0, CurrentProcessId);
  v6 = v5;
  if ( v5 )
  {
    if ( OpenProcessToken(v5, 0xCu, &TokenHandle) )
    {
      ExpandEnvironmentStringsForUserW(TokenHandle, (LPCWSTR)(a2 + 1024), Dest, 0x104u);
      CloseHandle(TokenHandle);
    }
    CloseHandle(v6);
  }
  v7 = SHGetFileInfoW(Dest, 0, &psfi, 0x2B8u, 0x4000u);
  iIcon = psfi.iIcon;
  v15 = 4100;
  v16 = a2;
  if ( !v7 )
    iIcon = 0;
  v17 = 0i64;
  psfi.iIcon = iIcon;
  LODWORD(lParam) = iIcon;
  v9 = *(_DWORD *)(a1 + 62124);
  HIDWORD(lParam) = v9 + 49000;
  if ( *(_DWORD *)(a2 + 2048) )
  {
    HIBYTE(v15) = 80;
    v17 = a2;
  }
  v10 = v9 + 1;
  v11 = *(HWND *)(a1 + 1024);
  *(_DWORD *)(a1 + 62124) = v10;
  SendMessageW(v11, 0x444u, 1ui64, (LPARAM)&lParam);
  return sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1024));
}

//----- (00000001400CD150) ----------------------------------------------------
void __fastcall sub_1400CD150(__int64 a1)
{
  __int64 v1; // rbx
  char *v3; // rax
  char *v4; // r12
  char *v5; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v7; // rax
  void *v8; // rbp
  DWORD_PTR v9; // rax
  int iIcon; // ecx
  int v11; // eax
  HANDLE TokenHandle; // [rsp+30h] [rbp-508h] BYREF
  SHFILEINFOW psfi; // [rsp+40h] [rbp-4F8h] BYREF
  WCHAR Dest[264]; // [rsp+300h] [rbp-238h] BYREF

  v1 = *(_QWORD *)(a1 + 62104);
  if ( v1 )
  {
    v3 = (char *)malloc(32i64 * *(int *)(a1 + 62120));
    v4 = v3;
    if ( v3 )
    {
      v5 = v3 + 8;
      do
      {
        CurrentProcessId = GetCurrentProcessId();
        v7 = OpenProcess(0x400u, 0, CurrentProcessId);
        v8 = v7;
        if ( v7 )
        {
          if ( OpenProcessToken(v7, 0xCu, &TokenHandle) )
          {
            ExpandEnvironmentStringsForUserW(TokenHandle, (LPCWSTR)(v1 + 1024), Dest, 0x104u);
            CloseHandle(TokenHandle);
          }
          CloseHandle(v8);
        }
        v9 = SHGetFileInfoW(Dest, 0, &psfi, 0x2B8u, 0x4000u);
        iIcon = psfi.iIcon;
        if ( !v9 )
          iIcon = 0;
        psfi.iIcon = iIcon;
        *((_DWORD *)v5 - 2) = iIcon;
        v11 = *(_DWORD *)(a1 + 62124) + 49000;
        *(_WORD *)v5 = 4100;
        *((_QWORD *)v5 + 1) = v1;
        *((_DWORD *)v5 - 1) = v11;
        *((_QWORD *)v5 + 2) = 0i64;
        if ( *(_DWORD *)(v1 + 2048) )
        {
          v5[1] = 80;
          *((_QWORD *)v5 + 2) = v1;
        }
        ++*(_DWORD *)(a1 + 62124);
        v1 = *(_QWORD *)(v1 + 2056);
        v5 += 32;
      }
      while ( v1 );
      SendMessageW(*(HWND *)(a1 + 1024), 0x444u, *(int *)(a1 + 62120), (LPARAM)v4);
      sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1024));
      free(v4);
    }
  }
}

//----- (00000001400CD320) ----------------------------------------------------
void __fastcall sub_1400CD320(__int64 a1, int a2)
{
  WPARAM v3; // rdi
  _QWORD *v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 lParam[2]; // [rsp+20h] [rbp-138h] BYREF
  void *Block; // [rsp+30h] [rbp-128h]
  WCHAR Buffer[128]; // [rsp+40h] [rbp-118h] BYREF

  if ( a2 != -1 )
  {
    v3 = a2;
    if ( SendMessageW(*(HWND *)(a1 + 1024), 0x417u, a2, (LPARAM)lParam) )
    {
      LoadStringW(hInstance, 0x7FBu, Buffer, 128);
      if ( MessageBoxW(*(HWND *)(a1 + 104), Buffer, L"Explorer++", 0x144u) == 6 )
      {
        v4 = Block;
        if ( *(void **)(a1 + 62104) == Block )
          *(_QWORD *)(a1 + 62104) = *((_QWORD *)Block + 257);
        v5 = v4[257];
        if ( v5 )
          *(_QWORD *)(v5 + 2064) = v4[258];
        v6 = v4[258];
        if ( v6 )
          *(_QWORD *)(v6 + 2056) = v4[257];
        free(v4);
        SendMessageW(*(HWND *)(a1 + 1024), 0x416u, v3, 0i64);
        sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1024));
      }
    }
  }
}
// 1400CD320: using guessed type LPARAM lParam[2];

//----- (00000001400CD480) ----------------------------------------------------
BOOL __fastcall sub_1400CD480(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  HWND v5; // rdi

  DlgItem = GetDlgItem(a2, 1200);
  v5 = GetDlgItem(a2, 1199);
  GetWindowTextW(DlgItem, *(LPWSTR *)(a1 + 62112), 512);
  GetWindowTextW(v5, (LPWSTR)(*(_QWORD *)(a1 + 62112) + 1024i64), 512);
  *(_DWORD *)(*(_QWORD *)(a1 + 62112) + 2048i64) = IsDlgButtonChecked(a2, 1222) == 1;
  sub_1400CCE80(a1, *(_DWORD *)(a1 + 62064));
  return EndDialog(a2, 1i64);
}

//----- (00000001400CD550) ----------------------------------------------------
HRESULT __fastcall sub_1400CD550(__int64 a1)
{
  HWND v2; // rax
  IDropTarget *v3; // rax
  HIMAGELIST phimlSmall; // [rsp+40h] [rbp+8h] BYREF
  IDropTarget *v6; // [rsp+48h] [rbp+10h]

  v2 = sub_14007CD30(*(HWND *)(a1 + 120), 0x56009944u, 153i64);
  *(_QWORD *)(a1 + 1024) = v2;
  SendMessageW(v2, 0x420u, 0i64, 1048592i64);
  SendMessageW(*(HWND *)(a1 + 1024), 0x41Eu, 0x20ui64, 0i64);
  Shell_GetImageLists(0i64, &phimlSmall);
  SendMessageW(*(HWND *)(a1 + 1024), 0x430u, 0i64, (LPARAM)phimlSmall);
  sub_1400CD150(a1);
  v3 = (IDropTarget *)operator new(0x30ui64);
  v6 = v3;
  if ( v3 )
    v3 = (IDropTarget *)sub_1400CDE90(v3, a1);
  return RegisterDragDrop(*(HWND *)(a1 + 1024), v3);
}

//----- (00000001400CD620) ----------------------------------------------------
void __fastcall sub_1400CD620(__int64 a1, int a2, const WCHAR *a3)
{
  HWND v4; // rcx
  LPARAM v6; // rdi
  DWORD CurrentProcessId; // eax
  HANDLE v8; // rax
  void *v9; // rbx
  LPVOID pv; // [rsp+20h] [rbp-268h] BYREF
  HANDLE TokenHandle; // [rsp+28h] [rbp-260h] BYREF
  LPARAM lParam[4]; // [rsp+30h] [rbp-258h] BYREF
  WCHAR Dest[264]; // [rsp+50h] [rbp-238h] BYREF

  v4 = *(HWND *)(a1 + 1024);
  pv = 0i64;
  if ( SendMessageW(v4, 0x417u, a2, (LPARAM)lParam) )
  {
    v6 = lParam[2];
    CurrentProcessId = GetCurrentProcessId();
    v8 = OpenProcess(0x400u, 0, CurrentProcessId);
    v9 = v8;
    if ( v8 )
    {
      if ( OpenProcessToken(v8, 0xCu, &TokenHandle) )
      {
        ExpandEnvironmentStringsForUserW(TokenHandle, (LPCWSTR)(v6 + 1024), Dest, 0x104u);
        CloseHandle(TokenHandle);
      }
      CloseHandle(v9);
    }
    if ( (int)sub_14007F810((__int64)Dest, (__int64)&pv) >= 0 )
    {
      sub_1400B00D0(a1, (ITEMIDLIST *)pv, a3);
      CoTaskMemFree(pv);
    }
  }
}

//----- (00000001400CD750) ----------------------------------------------------
__int64 __fastcall sub_1400CD750(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v7; // rdx
  _WORD *v9; // r10
  __int64 v10; // r9
  __int64 v11; // r11
  __int16 v12; // ax
  _WORD *v13; // rcx
  __int16 v14; // ax
  __int64 v15; // rax
  _QWORD *i; // rcx

  v7 = 512i64;
  v9 = (_WORD *)a5;
  v10 = a2 - a5;
  v11 = 512i64;
  while ( v11 != -2147483134 )
  {
    v12 = *(_WORD *)((char *)v9 + v10);
    if ( !v12 )
      break;
    *v9++ = v12;
    if ( !--v11 )
    {
      --v9;
      break;
    }
  }
  v13 = (_WORD *)(a5 + 1024);
  *v9 = 0;
  while ( v7 != -2147483134 )
  {
    v14 = *(_WORD *)((char *)v13 + a3 - (a5 + 1024));
    if ( !v14 )
      break;
    *v13++ = v14;
    if ( !--v7 )
    {
      --v13;
      break;
    }
  }
  *v13 = 0;
  *(_DWORD *)(a5 + 2048) = a4;
  *(_QWORD *)(a5 + 2056) = 0i64;
  v15 = *(_QWORD *)(a1 + 62104);
  if ( v15 )
  {
    for ( i = (_QWORD *)(v15 + 2056); *i; i = (_QWORD *)(*i + 2056i64) )
      v15 = *i;
    *(_QWORD *)(a5 + 2064) = v15;
    *(_QWORD *)(v15 + 2056) = a5;
  }
  else
  {
    *(_QWORD *)(a5 + 2064) = 0i64;
    *(_QWORD *)(a1 + 62104) = a5;
  }
  ++*(_DWORD *)(a1 + 62120);
  return a5;
}
// 1400CD7A8: conditional instruction was optimized away because r11.8!=0
// 1400CD7E6: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400CD870) ----------------------------------------------------
BOOL __fastcall sub_1400CD870(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  HWND v5; // rdi
  __int64 v6; // rbx
  int v7; // edi
  void *v8; // rax
  WCHAR v10[512]; // [rsp+30h] [rbp-828h] BYREF
  WCHAR String[512]; // [rsp+430h] [rbp-428h] BYREF

  DlgItem = GetDlgItem(a2, 1200);
  v5 = GetDlgItem(a2, 1199);
  GetWindowTextW(DlgItem, String, 512);
  GetWindowTextW(v5, v10, 512);
  v6 = 0i64;
  v7 = IsDlgButtonChecked(a2, 1222) == 1;
  v8 = malloc(0x820ui64);
  if ( v8 )
    v6 = sub_1400CD750(a1, (__int64)String, (__int64)v10, v7, (__int64)v8);
  sub_1400CCFF0(a1, v6);
  return EndDialog(a2, 1i64);
}

//----- (00000001400CD970) ----------------------------------------------------
int __fastcall sub_1400CD970(HWND hDlg)
{
  HWND DlgItem; // rdi
  int result; // eax
  int v4; // [rsp+20h] [rbp-E0h] BYREF
  HWND v5; // [rsp+28h] [rbp-D8h]
  const wchar_t *v6; // [rsp+38h] [rbp-C8h]
  __int64 v7; // [rsp+40h] [rbp-C0h]
  __int64 v8; // [rsp+48h] [rbp-B8h]
  WCHAR *v9; // [rsp+50h] [rbp-B0h]
  int v10; // [rsp+58h] [rbp-A8h]
  __int64 v11; // [rsp+60h] [rbp-A0h]
  int v12; // [rsp+68h] [rbp-98h]
  __int64 v13; // [rsp+70h] [rbp-90h]
  __int64 v14; // [rsp+78h] [rbp-88h]
  int v15; // [rsp+80h] [rbp-80h]
  const wchar_t *v16; // [rsp+88h] [rbp-78h]
  __int64 v17; // [rsp+90h] [rbp-70h]
  __int64 v18; // [rsp+98h] [rbp-68h]
  __int64 v19; // [rsp+A8h] [rbp-58h]
  __int64 v20; // [rsp+B0h] [rbp-50h]
  WCHAR String[264]; // [rsp+C0h] [rbp-40h] BYREF

  memset(String, 0, 520);
  v4 = 152;
  DlgItem = GetDlgItem(hDlg, 1199);
  v5 = hDlg;
  v6 = L"Programs (*.exe)";
  v7 = 0i64;
  v9 = String;
  v8 = 0i64;
  v10 = 260;
  v11 = 0i64;
  v12 = 0;
  v16 = L"exe";
  v13 = 0i64;
  v14 = 0i64;
  v15 = 8394752;
  v17 = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  result = sub_1400018B0((__int64)&v4);
  if ( result )
    return SetWindowTextW(DlgItem, String);
  return result;
}
// 1400F4B28: using guessed type wchar_t aExe[4];
// 1400F4B30: using guessed type wchar_t aProgramsExe[17];

//----- (00000001400CDA80) ----------------------------------------------------
__int64 __fastcall sub_1400CDA80(HWND a1, int a2, __int16 a3)
{
  int v3; // edx
  int v4; // edx

  v3 = a2 - 16;
  if ( !v3 )
  {
LABEL_10:
    EndDialog(a1, 0i64);
    return 0i64;
  }
  v4 = v3 - 256;
  if ( !v4 )
  {
    sub_1400CCD20(a1);
    return 0i64;
  }
  if ( v4 == 1 )
  {
    if ( a3 == 1 )
    {
      sub_1400CD870(qword_14012E0F0, a1);
      return 0i64;
    }
    if ( a3 != 2 )
    {
      if ( a3 == 1198 )
      {
        sub_1400CD970(a1);
        return 0i64;
      }
      return 0i64;
    }
    goto LABEL_10;
  }
  return 0i64;
}
// 14012E0F0: using guessed type __int64 qword_14012E0F0;

//----- (00000001400CDAF0) ----------------------------------------------------
__int64 __fastcall sub_1400CDAF0(HWND hDlg, int a2, __int16 a3, __int64 a4)
{
  __int64 v4; // r11
  int v5; // edx
  int v6; // edx

  v4 = qword_14012E0F0;
  if ( a2 == 272 )
    v4 = a4;
  v5 = a2 - 16;
  qword_14012E0F0 = v4;
  if ( !v5 )
  {
LABEL_10:
    EndDialog(hDlg, 0i64);
    return 0i64;
  }
  v6 = v5 - 256;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 != 2 )
      {
        if ( a3 == 1198 )
        {
          sub_1400CD970(hDlg);
          return 0i64;
        }
        return 0i64;
      }
      goto LABEL_10;
    }
    sub_1400CD870(v4, hDlg);
    return 0i64;
  }
  else
  {
    sub_1400CCD20(hDlg);
    return 0i64;
  }
}
// 14012E0F0: using guessed type __int64 qword_14012E0F0;

//----- (00000001400CDB80) ----------------------------------------------------
__int64 __fastcall sub_1400CDB80(HWND a1, int a2, __int16 a3)
{
  int v3; // edx
  int v4; // edx

  v3 = a2 - 16;
  if ( !v3 )
  {
LABEL_10:
    EndDialog(a1, 0i64);
    return 0i64;
  }
  v4 = v3 - 256;
  if ( !v4 )
  {
    sub_1400CCDC0(qword_14012E0E8, a1);
    return 0i64;
  }
  if ( v4 == 1 )
  {
    if ( a3 == 1 )
    {
      sub_1400CD480(qword_14012E0E8, a1);
      return 0i64;
    }
    if ( a3 != 2 )
    {
      if ( a3 == 1198 )
      {
        sub_1400CD970(a1);
        return 0i64;
      }
      return 0i64;
    }
    goto LABEL_10;
  }
  return 0i64;
}
// 14012E0E8: using guessed type __int64 qword_14012E0E8;

//----- (00000001400CDC00) ----------------------------------------------------
INT_PTR __fastcall sub_1400CDC00(HWND a1, int a2, __int16 a3, __int64 a4)
{
  __int64 v4; // rax

  v4 = qword_14012E0E8;
  if ( a2 == 272 )
    v4 = a4;
  qword_14012E0E8 = v4;
  return sub_1400CDB80(a1, a2, a3);
}
// 14012E0E8: using guessed type __int64 qword_14012E0E8;

//----- (00000001400CDC30) ----------------------------------------------------
void __fastcall sub_1400CDC30(LPARAM dwInitParam, int a2)
{
  HWND v3; // rdx
  LPARAM lParam[4]; // [rsp+20h] [rbp-38h] BYREF

  if ( a2 != -1 )
  {
    if ( SendMessageW(*(HWND *)(dwInitParam + 1024), 0x417u, a2, (LPARAM)lParam) )
    {
      v3 = *(HWND *)(dwInitParam + 104);
      *(_QWORD *)(dwInitParam + 62112) = lParam[2];
      sub_140001150((LPCWSTR)0xD8, v3, (DLGPROC)sub_1400CDC00, dwInitParam);
    }
  }
}

//----- (00000001400CDCD0) ----------------------------------------------------
HRESULT __fastcall sub_1400CDCD0(__int64 a1)
{
  _QWORD *v1; // rdi
  HRESULT result; // eax

  v1 = (_QWORD *)(a1 + 24);
  result = CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)(a1 + 24));
  if ( result >= 0 )
    return (**(__int64 (__fastcall ***)(_QWORD, void *, __int64))*v1)(*v1, &unk_1400E4040, a1 + 32);
  return result;
}

//----- (00000001400CDD30) ----------------------------------------------------
__int64 __fastcall sub_1400CDD30(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(*(_QWORD *)(a1 + 32));
  return 0i64;
}

//----- (00000001400CDD50) ----------------------------------------------------
__int64 __fastcall sub_1400CDD50(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  __int64 v5; // [rsp+40h] [rbp+18h] BYREF

  v5 = a3;
  *a4 = 1;
  (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32), &v5, 1i64);
  return 0i64;
}

//----- (00000001400CDD90) ----------------------------------------------------
__int64 sub_1400CDD90(__int64 a1, __int64 *a2, __int64 a3, ...)
{
  __int64 v5; // rax
  unsigned int v6; // edi
  _BOOL8 v7; // rbx
  __int16 v9; // [rsp+30h] [rbp-28h] BYREF
  __int64 v10; // [rsp+38h] [rbp-20h]
  int v11; // [rsp+40h] [rbp-18h]
  int v12; // [rsp+44h] [rbp-14h]
  int v13; // [rsp+48h] [rbp-10h]
  __int64 v14; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  _DWORD *v16; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _DWORD *);
  v9 = 15;
  v5 = *a2;
  v11 = 1;
  v12 = -1;
  v13 = 1;
  v10 = 0i64;
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int16 *))(v5 + 40))(a2, &v9);
  v7 = v6 == 0;
  *v16 = v7;
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64 *, __int64 *, _BOOL8))(**(_QWORD **)(a1 + 32) + 24i64))(
    *(_QWORD *)(a1 + 32),
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 1024i64),
    a2,
    (__int64 *)va,
    v7);
  return v6;
}

//----- (00000001400CDE40) ----------------------------------------------------
__int64 __fastcall sub_1400CDE40(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (00000001400CDE50) ----------------------------------------------------
__int64 __fastcall sub_1400CDE50(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 2147500034i64;
}

//----- (00000001400CDE90) ----------------------------------------------------
_QWORD *__fastcall sub_1400CDE90(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rdi

  a1[2] = a2;
  v2 = a1 + 3;
  *a1 = &Explorerplusplus::CApplicationToolbarDrop::`vftable';
  if ( CoCreateInstance(&rclsid, 0i64, 1u, &riid, (LPVOID *)a1 + 3) >= 0 )
    (**(void (__fastcall ***)(_QWORD, void *, _QWORD *))*v2)(*v2, &unk_1400E4040, a1 + 4);
  return a1;
}
// 1400F6718: using guessed type void *Explorerplusplus::CApplicationToolbarDrop::`vftable';

//----- (00000001400CDF00) ----------------------------------------------------
__int64 __fastcall sub_1400CDF00(_DWORD *a1)
{
  bool v1; // zf
  __int64 result; // rax

  v1 = a1[2]-- == 1;
  result = (unsigned int)a1[2];
  if ( v1 )
  {
    *(_QWORD *)a1 = &Explorerplusplus::CApplicationToolbarDrop::`vftable';
    j_free(a1);
    return 0i64;
  }
  return result;
}
// 1400F6718: using guessed type void *Explorerplusplus::CApplicationToolbarDrop::`vftable';

//----- (00000001400CDF30) ----------------------------------------------------
__int64 __fastcall sub_1400CDF30(__int64 a1, __int64 *a2, __int64 a3, struct tagPOINT a4, unsigned int *a5)
{
  __int64 v6; // rax
  __int64 v7; // r14
  signed int v8; // er12
  HDROP v9; // rax
  HDROP v10; // rsi
  UINT FileW; // eax
  int v12; // er15
  int v13; // er13
  int v14; // esi
  void *v15; // rdi
  HDROP v16; // r14
  int v17; // ebx
  signed int i; // edi
  __int64 v19; // r11
  WCHAR *v20; // rcx
  WCHAR v21; // ax
  void *v22; // rax
  __int64 v23; // rax
  struct tagPOINT v25; // [rsp+30h] [rbp-D0h] BYREF
  struct tagPOINT Point; // [rsp+38h] [rbp-C8h] BYREF
  HDROP hDrop; // [rsp+40h] [rbp-C0h]
  __int64 v28; // [rsp+48h] [rbp-B8h]
  __int16 v29; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v30; // [rsp+58h] [rbp-A8h]
  int v31; // [rsp+60h] [rbp-A0h]
  int v32; // [rsp+64h] [rbp-9Ch]
  int v33; // [rsp+68h] [rbp-98h]
  STGMEDIUM v34; // [rsp+70h] [rbp-90h] BYREF
  WCHAR szFile[264]; // [rsp+90h] [rbp-70h] BYREF
  WCHAR pszPath[512]; // [rsp+2A0h] [rbp+1A0h] BYREF
  WCHAR psz2[512]; // [rsp+6A0h] [rbp+5A0h] BYREF

  v29 = 15;
  v6 = *a2;
  v7 = a1;
  v28 = a1;
  v8 = 0;
  v25 = a4;
  v31 = 1;
  v32 = -1;
  v33 = 1;
  v30 = 0i64;
  if ( !(*(unsigned int (__fastcall **)(__int64 *, __int16 *, STGMEDIUM *))(v6 + 24))(a2, &v29, &v34) )
  {
    (*(void (__fastcall **)(_QWORD, __int64 *, struct tagPOINT *, _QWORD))(**(_QWORD **)(v7 + 32) + 48i64))(
      *(_QWORD *)(v7 + 32),
      a2,
      &v25,
      *a5);
    v9 = (HDROP)GlobalLock(v34.hBitmap);
    v10 = v9;
    hDrop = v9;
    if ( v9 )
    {
      FileW = DragQueryFileW(v9, 0xFFFFFFFF, 0i64, 0);
      Point = v25;
      v12 = FileW;
      ScreenToClient(*(HWND *)(*(_QWORD *)(v7 + 16) + 1024i64), &Point);
      v13 = SendMessageW(*(HWND *)(*(_QWORD *)(v7 + 16) + 1024i64), 0x445u, 0i64, (LPARAM)&Point);
      if ( v13 < 0 )
      {
        for ( i = 0; i < v12; ++i )
        {
          DragQueryFileW(v10, i, szFile, 0x104u);
          v19 = 512i64;
          v20 = pszPath;
          while ( v19 != -2147483134 )
          {
            v21 = *(v20 - 264);
            if ( !v21 )
              break;
            *v20++ = v21;
            if ( !--v19 )
            {
              --v20;
              break;
            }
          }
          *v20 = 0;
          PathStripPathW(pszPath);
          if ( pszPath[0] != 46 )
            PathRemoveExtensionW(pszPath);
          v22 = malloc(0x820ui64);
          if ( v22 )
            v23 = sub_1400CD750(*(_QWORD *)(v7 + 16), (__int64)pszPath, (__int64)szFile, 1, (__int64)v22);
          else
            v23 = 0i64;
          sub_1400CCFF0(*(_QWORD *)(v7 + 16), v23);
        }
      }
      else
      {
        v14 = 1024;
        v15 = malloc(0x800ui64);
        memset(v15, 0, 0x800ui64);
        if ( v15 )
        {
          if ( v12 > 0 )
          {
            v16 = hDrop;
            do
            {
              DragQueryFileW(v16, v8, szFile, 0x104u);
              v17 = lstrlenW((LPCWSTR)v15);
              if ( lstrlenW(szFile) + v17 > v14 )
              {
                v14 += 1024;
                v15 = realloc(v15, 2i64 * v14);
              }
              sub_140001000(psz2, 0x200ui64, L" \"%s\"", szFile);
              StrCatW((PWSTR)v15, psz2);
              ++v8;
            }
            while ( v8 < v12 );
            v7 = v28;
          }
          sub_1400CD620(*(_QWORD *)(v7 + 16), v13, (const WCHAR *)v15);
          free(v15);
        }
      }
      GlobalUnlock(v34.hBitmap);
    }
    ReleaseStgMedium(&v34);
  }
  return 0i64;
}
// 1400CE1A8: conditional instruction was optimized away because r11.8!=0
// 1400CE125: conditional instruction was optimized away because er13.4>=0
// 1400F4BB8: using guessed type wchar_t aS_4[6];

//----- (00000001400CE300) ----------------------------------------------------
__int64 __fastcall sub_1400CE300(_DWORD *a1, HWND a2)
{
  __int64 result; // rax
  struct tagRECT Rect; // [rsp+20h] [rbp-28h] BYREF

  GetWindowRect(a2, &Rect);
  result = (unsigned int)Rect.top;
  a1[15768] = Rect.left;
  a1[15769] = result;
  a1[15767] = 1;
  return result;
}

//----- (00000001400CE370) ----------------------------------------------------
BOOL __fastcall sub_1400CE370(HWND hWnd)
{
  HWND DlgItem; // rsi
  HWND v3; // r12
  HWND v4; // r13
  HWND v5; // r14
  HWND v6; // rdi
  HWND v7; // r15
  int v8; // edi
  const WCHAR *v9; // rdx
  BOOL result; // eax
  HWND hWnda; // [rsp+40h] [rbp-69h]
  HWND v12; // [rsp+48h] [rbp-61h]
  HWND v13; // [rsp+50h] [rbp-59h]
  HWND v14; // [rsp+58h] [rbp-51h]
  struct tagRECT v15; // [rsp+60h] [rbp-49h] BYREF
  struct tagRECT rc; // [rsp+70h] [rbp-39h] BYREF
  struct tagRECT Rect; // [rsp+80h] [rbp-29h] BYREF
  struct tagRECT v18; // [rsp+90h] [rbp-19h] BYREF
  struct tagRECT v19; // [rsp+A0h] [rbp-9h] BYREF
  struct tagRECT v20; // [rsp+B0h] [rbp+7h] BYREF
  struct tagRECT v21; // [rsp+C0h] [rbp+17h] BYREF

  DlgItem = GetDlgItem(hWnd, 1172);
  v3 = GetDlgItem(hWnd, 1);
  v13 = GetDlgItem(hWnd, 2);
  v4 = GetDlgItem(hWnd, 1165);
  v5 = GetDlgItem(hWnd, 1134);
  v6 = GetDlgItem(hWnd, 1173);
  v14 = v6;
  v12 = GetDlgItem(hWnd, 1174);
  hWnda = GetDlgItem(hWnd, 1054);
  v7 = GetDlgItem(hWnd, 1180);
  if ( dword_14012D734 )
  {
    GetWindowRect(hWnda, &Rect);
    GetWindowRect(DlgItem, &v15);
    OffsetRect(&Rect, 0, 6);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&Rect, 2u);
    v8 = 0;
    SetWindowPos(DlgItem, 0i64, v15.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(v3, &v15);
    GetWindowRect(DlgItem, &rc);
    OffsetRect(&rc, 0, 6);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&rc, 2u);
    SetWindowPos(v3, 0i64, v15.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(v13, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v13, 0i64, v15.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(hWnd, &v15);
    GetWindowRect(v3, &v18);
    InflateRect(&v18, 0, 10);
    SetWindowPos(hWnd, 0i64, 0, 0, v15.right - v15.left, v18.bottom - v15.top, 6u);
    GetWindowRect(v14, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v14, 0i64, v15.left, v15.top + 45, 0, 0, 5u);
    GetWindowRect(v4, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v4, 0i64, v15.left, v15.top + 45, 0, 0, 5u);
    GetWindowRect(v12, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v12, 0i64, v15.left, v15.top + 45, 0, 0, 5u);
    GetWindowRect(v5, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v5, 0i64, v15.left, v15.top + 45, 0, 0, 5u);
    GetWindowRect(v7, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v7, 0i64, v15.left, v15.top + 45, 0, 0, 5u);
    v9 = L"Details >>";
  }
  else
  {
    GetWindowRect(hWnda, &rc);
    GetWindowRect(v6, &v15);
    OffsetRect(&rc, 0, 5);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&rc, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    v8 = 0;
    SetWindowPos(v14, 0i64, v15.left, rc.bottom + 2, 0, 0, 5u);
    GetWindowRect(v4, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v4, 0i64, v15.left, rc.bottom, 0, 0, 5u);
    GetWindowRect(v4, &v19);
    GetWindowRect(v5, &v15);
    OffsetRect(&v19, 0, 5);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v19, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v5, 0i64, v15.left, v19.bottom, 0, 0, 5u);
    GetWindowRect(v12, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v12, 0i64, v15.left, v19.bottom + 2, 0, 0, 5u);
    GetWindowRect(v5, &v20);
    GetWindowRect(v7, &v15);
    OffsetRect(&v20, 0, 7);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v20, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v7, 0i64, v15.left, v20.bottom, 0, 0, 5u);
    GetWindowRect(DlgItem, &v15);
    GetWindowRect(v7, &v18);
    OffsetRect(&v18, 0, 6);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v18, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(DlgItem, 0i64, v15.left, v18.bottom, 0, 0, 5u);
    GetWindowRect(v3, &v15);
    GetWindowRect(DlgItem, &Rect);
    OffsetRect(&Rect, 0, 6);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&Rect, 2u);
    SetWindowPos(v3, 0i64, v15.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(v13, &v15);
    MapWindowPoints(0i64, hWnd, (LPPOINT)&v15, 2u);
    SetWindowPos(v13, 0i64, v15.left, Rect.bottom, 0, 0, 5u);
    GetWindowRect(hWnd, &v15);
    GetWindowRect(v3, &v21);
    InflateRect(&v21, 0, 10);
    SetWindowPos(hWnd, 0i64, 0, 0, v15.right - v15.left, v21.bottom - v15.top, 6u);
    v9 = L"Details <<";
  }
  result = SetWindowTextW(hWnda, v9);
  LOBYTE(v8) = dword_14012D734 == 0;
  dword_14012D734 = v8;
  return result;
}
// 1400F4BC8: using guessed type wchar_t aDetails[11];
// 14012D734: using guessed type int dword_14012D734;

//----- (00000001400CEB20) ----------------------------------------------------
BOOL __fastcall sub_1400CEB20(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  HWND v5; // rdi
  HWND v6; // rsi
  HWND v7; // r14
  WPARAM v8; // r13
  void *v9; // rax
  WPARAM v10; // rbx
  _BYTE *v11; // rax
  _BYTE *v12; // r15
  WPARAM v13; // rbx
  WCHAR *v14; // rax
  WCHAR *v15; // r13
  UINT v16; // eax
  __int64 v17; // r8
  UINT v18; // er14
  char *v19; // rdx
  __int64 v20; // r9
  __int16 v21; // cx
  int v22; // ebx
  __int64 v23; // rdx
  char *v24; // rcx
  __int16 v25; // ax
  int v26; // eax
  __int64 v27; // rcx
  char *v28; // rdx
  __int16 v29; // ax
  __int16 v30; // ax
  LPARAM v31; // rsi
  _QWORD *v32; // rdi
  __int64 v33; // rcx
  _QWORD *i; // rax
  __int64 v35; // rcx
  _DWORD *v36; // rax
  LONG v37; // ecx
  LONG v38; // eax
  HWND v39; // rcx
  LONG top; // eax
  LPARAM lParam[7]; // [rsp+28h] [rbp-D8h] BYREF
  struct tagRECT v44; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v45; // [rsp+70h] [rbp-90h]
  char *v46; // [rsp+78h] [rbp-88h]
  char v47[512]; // [rsp+80h] [rbp-80h] BYREF
  char v48[1024]; // [rsp+280h] [rbp+180h] BYREF
  BOOL v49; // [rsp+680h] [rbp+580h]
  int v50; // [rsp+684h] [rbp+584h]
  char v51[520]; // [rsp+688h] [rbp+588h] BYREF
  unsigned int v52; // [rsp+890h] [rbp+790h]
  WCHAR pszBuf[264]; // [rsp+8A0h] [rbp+7A0h] BYREF

  DlgItem = GetDlgItem(a2, 1113);
  v5 = GetDlgItem(a2, 1134);
  v6 = GetDlgItem(a2, 1165);
  v7 = GetDlgItem(a2, 1164);
  v8 = GetWindowTextLengthW(DlgItem) + 1;
  v9 = malloc(2 * v8);
  *(_QWORD *)&v44.left = v9;
  if ( v9 )
    SendMessageW(DlgItem, 0xDu, v8, (LPARAM)v9);
  v10 = GetWindowTextLengthW(v5) + 1;
  v11 = malloc(2 * v10);
  v12 = v11;
  if ( v11 )
    SendMessageW(v5, 0xDu, v10, (LPARAM)v11);
  v13 = GetWindowTextLengthW(v6) + 1;
  v14 = (WCHAR *)malloc(2 * v13);
  v15 = v14;
  if ( v14 )
    SendMessageW(v6, 0xDu, v13, (LPARAM)v14);
  LODWORD(lParam[0]) = 32;
  lParam[1] = (int)SendMessageW(v7, 0x147u, 0i64, 0i64);
  SendMessageW(v7, 0x40Du, 0i64, (LPARAM)lParam);
  v16 = IsDlgButtonChecked(a2, 1180);
  v17 = 256i64;
  v18 = v16;
  v19 = v47;
  v20 = *(_QWORD *)&v44.left - (_QWORD)v47;
  while ( v17 != -2147483390 )
  {
    v21 = *(_WORD *)&v19[v20];
    if ( !v21 )
      break;
    *(_WORD *)v19 = v21;
    v19 += 2;
    if ( !--v17 )
    {
      v19 -= 2;
      break;
    }
  }
  v22 = 0;
  *(_WORD *)v19 = 0;
  v23 = 512i64;
  v24 = v48;
  while ( v23 != -2147483134 )
  {
    v25 = *(_WORD *)&v24[v12 - v48];
    if ( !v25 )
      break;
    *(_WORD *)v24 = v25;
    v24 += 2;
    if ( !--v23 )
    {
      v24 -= 2;
      break;
    }
  }
  *(_WORD *)v24 = 0;
  v26 = sub_14007E5F0(v15, pszBuf);
  v27 = 260i64;
  v28 = v51;
  if ( v26 < 0 )
  {
    while ( v27 != -2147483386 )
    {
      v30 = *(_WORD *)&v28[(char *)v15 - v51];
      if ( !v30 )
        break;
      *(_WORD *)v28 = v30;
      v28 += 2;
      if ( !--v27 )
      {
LABEL_27:
        v28 -= 2;
        break;
      }
    }
  }
  else
  {
    while ( v27 != -2147483386 )
    {
      v29 = *(_WORD *)&v28[(char *)pszBuf - v51];
      if ( !v29 )
        break;
      *(_WORD *)v28 = v29;
      v28 += 2;
      if ( !--v27 )
        goto LABEL_27;
    }
  }
  v31 = lParam[6];
  *(_WORD *)v28 = 0;
  v50 = 1;
  v49 = v18 == 1;
  v32 = malloc(0x830ui64);
  sub_14007D850((__int64)v32, (__int64)v47);
  v32[258] = v31;
  v33 = *(_QWORD *)(v31 + 2088);
  if ( v33 )
  {
    for ( i = (_QWORD *)(v33 + 2080); *i; i = (_QWORD *)(*i + 2080i64) )
      v33 = *i;
    *(_QWORD *)(v33 + 2080) = v32;
    v32[259] = v33;
  }
  else
  {
    *(_QWORD *)(v31 + 2088) = v32;
    v32[259] = 0i64;
  }
  free(v12);
  free(*(void **)&v44.left);
  free(v15);
  if ( v18 == 1 )
  {
    v35 = 0i64;
    v36 = (_DWORD *)(a1 + 61664);
    while ( *v36 )
    {
      ++v35;
      ++v22;
      ++v36;
      if ( v35 >= 100 )
      {
        v37 = -1;
        goto LABEL_39;
      }
    }
    v37 = v22 + 46000;
    *(_DWORD *)(a1 + 4i64 * v22 + 61664) = 1;
LABEL_39:
    v38 = 20;
    if ( !v50 )
      v38 = 15;
    v44.top = v37;
    v39 = *(HWND *)(a1 + 1008);
    v44.left = v38;
    v45 = v52;
    LOWORD(v44.right) = 28676;
    v46 = v47;
    SendMessageW(v39, 0x444u, 1ui64, (LPARAM)&v44);
    sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1008));
  }
  GetWindowRect(a2, &v44);
  top = v44.top;
  *(_DWORD *)(a1 + 63072) = v44.left;
  *(_DWORD *)(a1 + 63076) = top;
  *(_DWORD *)(a1 + 63068) = 1;
  return EndDialog(a2, 1i64);
}
// 1400CECC7: conditional instruction was optimized away because r8.8!=0
// 1400CED17: conditional instruction was optimized away because rdx.8!=0
// 1400CEDA7: conditional instruction was optimized away because rcx.8!=0

//----- (00000001400CEF80) ----------------------------------------------------
BOOL __fastcall sub_1400CEF80(__int64 a1, HWND a2, __int64 a3)
{
  HWND DlgItem; // r14
  HWND v7; // rbx
  HWND v8; // rax
  const ITEMIDLIST *v9; // rcx
  HWND v10; // r13
  int v11; // eax
  unsigned int v12; // er8
  __int64 v13; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  __int64 v16; // rdx
  int v17; // eax
  char v19[2080]; // [rsp+40h] [rbp-C88h] BYREF
  WCHAR pszBuf[264]; // [rsp+860h] [rbp-468h] BYREF
  WCHAR String[264]; // [rsp+A70h] [rbp-258h] BYREF

  DlgItem = GetDlgItem(a2, 1113);
  v7 = GetDlgItem(a2, 1165);
  v8 = GetDlgItem(a2, 1164);
  v9 = *(const ITEMIDLIST **)(a3 + 16);
  v10 = v8;
  if ( v9 )
  {
    sub_14007E270(v9, String, 1u);
    SetWindowTextW(DlgItem, String);
    SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
    v11 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640));
    v12 = 0;
    if ( !v11 )
      v12 = 0x8000;
    sub_14007E270(*(LPCITEMIDLIST *)(a3 + 16), pszBuf, v12);
    SetWindowTextW(v7, pszBuf);
  }
  v13 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 1);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v13, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(v10, 0x402u, 0i64, v13);
  sub_14007DA80(a1 + 2664, (__int64)v19);
  sub_1400CAA90(a1, v10, (LPARAM)v19, 0, 0);
  v16 = *(_QWORD *)(a3 + 8);
  if ( v16 )
    v17 = sub_1400CA750(v10, v16);
  else
    v17 = 0;
  SendMessageW(v10, 0x14Eu, v17, 0i64);
  dword_14012D734 = *(_DWORD *)(a3 + 24) == 0;
  sub_1400CE370(a2);
  dword_14012D734 = *(_DWORD *)(a3 + 24);
  SetFocus(DlgItem);
  if ( *(_DWORD *)(a1 + 63068) )
    return SetWindowPos(a2, 0i64, *(_DWORD *)(a1 + 63072), *(_DWORD *)(a1 + 63076), 0, 0, 5u);
  else
    return sub_140081E00(*(HWND *)(a1 + 104), a2);
}
// 14012D734: using guessed type int dword_14012D734;

//----- (00000001400CF1C0) ----------------------------------------------------
INT_PTR __fastcall sub_1400CF1C0(LPARAM dwInitParam, HWND hWndParent)
{
  HWND DlgItem; // rdi
  INT_PTR result; // rax
  char v6[2080]; // [rsp+30h] [rbp-838h] BYREF

  DlgItem = GetDlgItem(hWndParent, 1164);
  dword_14012D730 = SendMessageW(DlgItem, 0x147u, 0i64, 0i64);
  result = sub_140001150((LPCWSTR)0xD3, hWndParent, (DLGPROC)sub_1400D6E70, dwInitParam);
  if ( result == 1 )
  {
    SendMessageW(DlgItem, 0x14Bu, 0i64, 0i64);
    sub_14007DA80(dwInitParam + 2664, (__int64)v6);
    sub_1400CAA90(dwInitParam, DlgItem, (LPARAM)v6, 0, 0);
    return SendMessageW(DlgItem, 0x14Eu, dword_14012D730 + 1, 0i64);
  }
  return result;
}
// 14012D730: using guessed type int dword_14012D730;

//----- (00000001400CF2C0) ----------------------------------------------------
__int64 __fastcall sub_1400CF2C0(HWND hWndParent, int a2, __int16 a3, __int64 a4)
{
  int v4; // edx
  int v6; // edx

  v4 = a2 - 16;
  if ( !v4 )
  {
LABEL_12:
    sub_1400CE300((_DWORD *)dwInitParam, hWndParent);
    EndDialog(hWndParent, 0i64);
    return 0i64;
  }
  v6 = v4 - 256;
  if ( !v6 )
  {
    sub_1400CEF80(dwInitParam, hWndParent, a4);
    return 0i64;
  }
  if ( v6 == 1 )
  {
    if ( a3 == 1 )
    {
      sub_1400CEB20(dwInitParam, hWndParent);
      return 0i64;
    }
    if ( a3 != 2 )
    {
      if ( a3 == 1054 )
      {
        sub_1400CE370(hWndParent);
        return 0i64;
      }
      if ( a3 == 1166 )
      {
        sub_1400CF1C0(dwInitParam, hWndParent);
        return 0i64;
      }
      return 0i64;
    }
    goto LABEL_12;
  }
  return 0i64;
}

//----- (00000001400CF380) ----------------------------------------------------
INT_PTR __fastcall sub_1400CF380(HWND hWndParent, int a2, __int16 a3, LPARAM *a4)
{
  if ( a2 == 272 )
    dwInitParam = *a4;
  return sub_1400CF2C0(hWndParent, a2, a3, (__int64)a4);
}

//----- (00000001400CF480) ----------------------------------------------------
__int64 __fastcall sub_1400CF480(wchar_t *a1, __int64 a2, const wchar_t *a3, va_list a4)
{
  unsigned __int64 v4; // rbx
  int v6; // eax
  bool v7; // zf
  __int64 result; // rax

  v4 = a2 - 1;
  v6 = vsnwprintf(a1, a2 - 1, a3, a4);
  if ( v6 < 0 || (v7 = v6 == v4, v6 > v4) )
  {
    result = 2147942522i64;
    goto LABEL_6;
  }
  result = 0i64;
  if ( v7 )
LABEL_6:
    a1[v4] = 0;
  return result;
}

//----- (00000001400CF4E0) ----------------------------------------------------
__int64 __fastcall sub_1400CF4E0(__int64 a1)
{
  DestroyIcon(*(HICON *)(a1 + 80));
  EndDialog(*(HWND *)(a1 + 8), 0i64);
  return 0i64;
}

//----- (00000001400CF510) ----------------------------------------------------
__int64 __fastcall sub_1400CF510(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 16);
  if ( (v2 == -4 || v2 == -2) && *(HWND *)a2 == GetDlgItem(*(HWND *)(a1 + 8), 1269) )
    ShellExecuteW(0i64, L"open", (LPCWSTR)(a2 + 136), 0i64, 0i64, 5);
  return 0i64;
}

//----- (00000001400CF580) ----------------------------------------------------
__int64 __fastcall sub_1400CF580(__int64 a1, __int16 a2)
{
  if ( a2 == 1 )
  {
    EndDialog(*(HWND *)(a1 + 8), 1i64);
  }
  else if ( a2 == 2 )
  {
    EndDialog(*(HWND *)(a1 + 8), 0i64);
    return 0i64;
  }
  return 0i64;
}

//----- (00000001400CF6A0) ----------------------------------------------------
__int64 __fastcall sub_1400CF6A0(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HANDLE ImageW; // rax
  HWND v4; // rcx
  HMODULE v5; // rbx
  HMODULE v6; // rax
  HBITMAP BitmapW; // rax
  __int64 v8; // r11
  __int16 *v9; // rax
  __int64 v10; // rcx
  __int16 *v11; // rax
  __int64 v12; // rdx
  char *v13; // r9
  __int16 v14; // r8
  __int64 v15; // rcx
  __int16 *v16; // rax
  __int16 *v17; // rax
  __int64 v18; // rdx
  char *v19; // r9
  __int16 v20; // r8
  HWND v21; // rbx
  HWND Parent; // rax
  WCHAR String[64]; // [rsp+30h] [rbp-218h] BYREF
  __int16 Buffer[64]; // [rsp+B0h] [rbp-198h] BYREF
  WCHAR v26[64]; // [rsp+130h] [rbp-118h] BYREF
  WCHAR v27[64]; // [rsp+1B0h] [rbp-98h] BYREF

  ModuleHandleW = GetModuleHandleW(0i64);
  ImageW = LoadImageW(ModuleHandleW, (LPCWSTR)0x69, 1u, 32, 32, 0x80u);
  v4 = *(HWND *)(a1 + 8);
  *(_QWORD *)(a1 + 80) = ImageW;
  SendMessageW(v4, 0x80u, 0i64, (LPARAM)ImageW);
  v5 = *(HMODULE *)(a1 + 16);
  if ( v5 != GetModuleHandleW(0i64) )
  {
    v6 = GetModuleHandleW(0i64);
    BitmapW = LoadBitmapW(v6, (LPCWSTR)0xE7);
    SendDlgItemMessageW(*(HWND *)(a1 + 8), 1149, 0x172u, 0i64, (LPARAM)BitmapW);
  }
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x865u, (LPWSTR)Buffer, 64);
  LoadStringW(*(HINSTANCE *)(a1 + 16), 0x867u, String, 64);
  v8 = 64i64;
  v9 = Buffer;
  while ( *v9 )
  {
    ++v9;
    if ( !--v8 )
      goto LABEL_13;
  }
  v10 = v8;
  v11 = &Buffer[64 - v8];
  v12 = 0x7FFFFFFFi64;
  v13 = (char *)((char *)L" " - (char *)v11);
  while ( v12 )
  {
    v14 = *(__int16 *)((char *)v11 + (_QWORD)v13);
    if ( !v14 )
      break;
    *v11++ = v14;
    --v12;
    if ( !--v10 )
    {
      --v11;
      break;
    }
  }
  *v11 = 0;
LABEL_13:
  v15 = 64i64;
  v16 = Buffer;
  while ( *v16 )
  {
    ++v16;
    if ( !--v15 )
      goto LABEL_23;
  }
  v17 = &Buffer[64 - v15];
  v18 = 0x7FFFFFFFi64;
  v19 = (char *)((char *)String - (char *)v17);
  while ( v18 )
  {
    v20 = *(__int16 *)((char *)v17 + (_QWORD)v19);
    if ( !v20 )
      break;
    *v17++ = v20;
    --v18;
    if ( !--v15 )
    {
      --v17;
      break;
    }
  }
  *v17 = 0;
LABEL_23:
  GetDlgItemTextW(*(HWND *)(a1 + 8), 1270, String, 64);
  sub_140001000(v26, 0x40ui64, String, L"1.3.4.485", Buffer);
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1270, v26);
  GetDlgItemTextW(*(HWND *)(a1 + 8), 1271, String, 64);
  sub_140001000(v27, 0x40ui64, String, L"12/11/2011 14:56:20");
  SetDlgItemTextW(*(HWND *)(a1 + 8), 1271, v27);
  v21 = *(HWND *)(a1 + 8);
  Parent = GetParent(v21);
  sub_140081E00(Parent, v21);
  return 1i64;
}
// 1400CF7A9: conditional instruction was optimized away because r11.8!=0
// 1400CF7C3: conditional instruction was optimized away because r11.8!=0
// 1400CF7FC: conditional instruction was optimized away because rcx.8!=0
// 1400CF827: conditional instruction was optimized away because rcx.8!=0
// 1400CF841: conditional instruction was optimized away because rcx.8!=0
// 1400CF878: conditional instruction was optimized away because rcx.8!=0
// 1400ECBD4: using guessed type wchar_t asc_1400ECBD4[2];
// 1400F4BF8: using guessed type wchar_t a134485_0[10];
// 1400F4C10: using guessed type wchar_t a12112011145620[20];
// 1400CF6A0: using guessed type WCHAR Buffer[64];

//----- (00000001400CF970) ----------------------------------------------------
HWND *__fastcall sub_1400CF970(__int64 a1, int a2, int a3)
{
  _QWORD *v3; // rdi
  _QWORD *v5; // rbx
  HWND *result; // rax
  int v7; // er14
  int v8; // esi
  int v9; // er12
  int v10; // er13
  HWND DlgItem; // rbp
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // er9
  int v16; // er8
  int v17; // esi
  int cy; // [rsp+28h] [rbp-80h]
  UINT uFlags; // [rsp+30h] [rbp-78h]
  struct tagRECT Rect; // [rsp+50h] [rbp-58h] BYREF

  v3 = *(_QWORD **)(a1 + 8);
  v5 = (_QWORD *)*v3;
  result = (HWND *)a1;
  if ( (_QWORD *)*v3 != v3 )
  {
    while ( 1 )
    {
      v7 = *((_DWORD *)v5 + 5);
      v8 = *((_DWORD *)v5 + 6);
      v9 = *((_DWORD *)v5 + 7);
      v10 = *((_DWORD *)v5 + 8);
      DlgItem = GetDlgItem(*result, *((_DWORD *)v5 + 4));
      GetWindowRect(DlgItem, &Rect);
      MapWindowPoints(0i64, *(HWND *)a1, (LPPOINT)&Rect, 2u);
      if ( !v7 )
        break;
      if ( v7 == 1 )
      {
        if ( !v8 )
        {
          v13 = a3 - Rect.top - v10;
          v14 = a2 - Rect.left - v9;
LABEL_8:
          uFlags = 6;
          v15 = 0;
          cy = v13;
          v16 = 0;
LABEL_17:
          SetWindowPos(DlgItem, 0i64, v16, v15, v14, cy, uFlags);
          goto LABEL_18;
        }
        v12 = v8 - 1;
        if ( !v12 )
        {
          v13 = Rect.bottom - Rect.top;
          v14 = a2 - Rect.left - v9;
          goto LABEL_8;
        }
        if ( v12 == 1 )
        {
          v13 = a3 - Rect.top - v10;
          v14 = Rect.right - Rect.left;
          goto LABEL_8;
        }
      }
LABEL_18:
      if ( (GetWindowLongW(DlgItem, -16) & 7) != 0 )
        InvalidateRect(DlgItem, 0i64, 1);
      v5 = (_QWORD *)*v5;
      result = (HWND *)a1;
      if ( v5 == v3 )
        return result;
    }
    if ( v8 )
    {
      v17 = v8 - 1;
      if ( v17 )
      {
        if ( v17 == 1 )
          SetWindowPos(DlgItem, 0i64, Rect.left, a3 - v10, 0, 0, 5u);
      }
      else
      {
        SetWindowPos(DlgItem, 0i64, a2 - v9, Rect.top, 0, 0, 5u);
      }
      goto LABEL_18;
    }
    uFlags = 5;
    v15 = a3 - v10;
    v16 = a2 - v9;
    v14 = 0;
    cy = 0;
    goto LABEL_17;
  }
  return result;
}

//----- (00000001400CFB70) ----------------------------------------------------
void __fastcall sub_1400CFB70(__int64 a1)
{
  _QWORD **v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD ***)(a1 + 8);
  v3 = *v1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0i64;
  if ( v3 != *(_QWORD **)(a1 + 8) )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_free(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 8) );
  }
  j_free(*(void **)(a1 + 8));
}

//----- (00000001400CFD80) ----------------------------------------------------
BOOL __fastcall sub_1400CFD80(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  int v4; // ebp
  int MenuItemCount; // esi
  signed int i; // edi
  signed int v7; // edi
  int v8; // esi
  HMENU v9; // rbp
  HMENU v10; // r12
  UINT v11; // esi
  UINT v12; // edi
  UINT v13; // er13
  __int64 v14; // rcx
  int v15; // eax
  int v16; // ebx
  int v18; // [rsp+60h] [rbp+8h] BYREF

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640));
  v2 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v2 + 56i64))(v2, &v18);
  v3 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 72i64))(v3);
  MenuItemCount = GetMenuItemCount(*(HMENU *)(a1 + 4832));
  for ( i = 0; i < MenuItemCount; ++i )
  {
    CheckMenuItem(*(HMENU *)(a1 + 4832), i, 0x400u);
    CheckMenuItem(*(HMENU *)(a1 + 4848), i, 0x400u);
  }
  v7 = 0;
  v8 = GetMenuItemCount(*(HMENU *)(a1 + 4840));
  if ( v8 > 0 )
  {
    do
    {
      CheckMenuItem(*(HMENU *)(a1 + 4840), v7, 0x400u);
      CheckMenuItem(*(HMENU *)(a1 + 4856), v7++, 0x400u);
    }
    while ( v7 < v8 );
  }
  if ( v4 )
  {
    v9 = *(HMENU *)(a1 + 4840);
    v10 = *(HMENU *)(a1 + 4856);
    v11 = 50100;
    v12 = sub_1400CBBC0(v18);
    if ( v12 == -1 )
      v12 = 50100;
    v13 = 50199;
    EnableMenuItem(*(HMENU *)(a1 + 4832), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4832), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4848), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4848), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4840), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4840), 0x9C9Au, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4856), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4856), 0x9C9Au, 0);
    CheckMenuRadioItem(*(HMENU *)(a1 + 4832), 0xC350u, 0xC3B3u, 0, 0);
    CheckMenuRadioItem(*(HMENU *)(a1 + 4848), 0xC350u, 0xC3B3u, 0, 0);
  }
  else
  {
    v9 = *(HMENU *)(a1 + 4832);
    v10 = *(HMENU *)(a1 + 4848);
    v12 = sub_1400CBD80(v18);
    v11 = 50000;
    v13 = 50099;
    if ( v12 == -1 )
      v12 = 50000;
    EnableMenuItem(*(HMENU *)(a1 + 4840), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4840), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4856), 0x9C99u, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4856), 0x9C9Au, 1u);
    EnableMenuItem(*(HMENU *)(a1 + 4832), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4832), 0x9C9Au, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4848), 0x9C99u, 0);
    EnableMenuItem(*(HMENU *)(a1 + 4848), 0x9C9Au, 0);
  }
  CheckMenuRadioItem(v9, v11, v13, v12, 0);
  CheckMenuRadioItem(v10, v11, v13, v12, 0);
  v14 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  v15 = -(*(int (__fastcall **)(__int64))(*(_QWORD *)v14 + 80i64))(v14);
  v16 = -(v15 != 0);
  CheckMenuRadioItem(v9, 0x9C99u, 0x9C9Au, 40090 - (v15 != 0), 0);
  return CheckMenuRadioItem(v10, 0x9C99u, 0x9C9Au, v16 + 40090, 0);
}

//----- (00000001400D0130) ----------------------------------------------------
void __fastcall sub_1400D0130(__int64 a1)
{
  ITEMIDLIST *v2; // rbx
  __int64 v3; // rdx
  WCHAR *v4; // rcx
  WCHAR v5; // ax
  WCHAR String[264]; // [rsp+20h] [rbp-438h] BYREF
  WCHAR pszBuf[264]; // [rsp+230h] [rbp-228h] BYREF

  v2 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  sub_14007E270(v2, String, 0x8000u);
  if ( lstrlenW(String) > 2 && String[0] == 58 && String[1] == 58 )
  {
    sub_14007E270(v2, pszBuf, 1u);
  }
  else
  {
    v3 = 260i64;
    v4 = pszBuf;
    while ( v3 != -2147483386 )
    {
      v5 = *(WCHAR *)((char *)v4 + (char *)String - (char *)pszBuf);
      if ( !v5 )
        break;
      *v4++ = v5;
      if ( !--v3 )
      {
        --v4;
        break;
      }
    }
    *v4 = 0;
  }
  sub_1400B5950(*(HWND *)(a1 + 168), &v2->mkid.cb, (LPARAM)pszBuf);
  CoTaskMemFree(v2);
}
// 1400D01F7: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400D0250) ----------------------------------------------------
void __fastcall sub_1400D0250(__int64 a1, int a2, int a3)
{
  WPARAM v4; // rbp
  __int64 v6; // rbx
  __int64 v7; // rcx
  ITEMIDLIST *v8; // r12
  char *v9; // rcx
  signed __int64 v10; // rdx
  __int64 v11; // r11
  __int16 v12; // ax
  HWND v13; // rcx
  _QWORD *v14; // rax
  _QWORD *v15; // rbx
  LPARAM lParam[6]; // [rsp+20h] [rbp-488h] BYREF
  WCHAR String[264]; // [rsp+50h] [rbp-458h] BYREF
  WCHAR pszBuf[264]; // [rsp+260h] [rbp-248h] BYREF

  v4 = a2;
  v6 = 532i64 * a3;
  if ( !*(_DWORD *)(v6 + a1 + 7128) )
  {
    v7 = *(_QWORD *)(a1 + 8i64 * a3 + 1832);
    v8 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 112i64))(v7);
    sub_14007E270(v8, pszBuf, 1u);
    v9 = (char *)(v6 + a1 + 7132);
    v10 = (char *)pszBuf - v9;
    v11 = 260i64;
    while ( v11 != -2147483386 )
    {
      v12 = *(_WORD *)&v9[v10];
      if ( !v12 )
        break;
      *(_WORD *)v9 = v12;
      v9 += 2;
      if ( !--v11 )
      {
        v9 -= 2;
        break;
      }
    }
    *(_WORD *)v9 = 0;
    sub_140083870(pszBuf, (char *)String, (__int64)L"&&");
    v13 = *(HWND *)(a1 + 136);
    lParam[2] = (LPARAM)String;
    LODWORD(lParam[0]) = 1;
    SendMessageW(v13, 0x133Du, v4, (LPARAM)lParam);
    if ( *(_DWORD *)(a1 + 61028) )
    {
      v14 = *(_QWORD **)(a1 + 61000);
      v15 = (_QWORD *)*v14;
      if ( (_QWORD *)*v14 != v14 )
      {
        while ( *((_DWORD *)v15 + 8) != a3 )
        {
          v15 = (_QWORD *)*v15;
          if ( v15 == v14 )
            goto LABEL_13;
        }
        SetWindowTextW((HWND)v15[3], String);
        (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 60992) + 152i64))(
          *(_QWORD *)(a1 + 60992),
          v15[3],
          String);
      }
    }
LABEL_13:
    CoTaskMemFree(v8);
  }
}
// 1400D0306: conditional instruction was optimized away because r11.8!=0
// 1400F46D4: using guessed type wchar_t asc_1400F46D4[3];

//----- (00000001400D03E0) ----------------------------------------------------
void __fastcall sub_1400D03E0(__int64 a1, int a2)
{
  __int64 v3; // rdi
  int v4; // ebp
  int v5; // ebx
  HWND v6; // rcx
  ITEMIDLIST *v7; // r12
  char *v8; // rcx
  signed __int64 v9; // rdx
  __int64 v10; // r11
  __int16 v11; // ax
  HWND v12; // rcx
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  LPARAM v15[5]; // [rsp+20h] [rbp-4A8h] BYREF
  __int64 lParam[4]; // [rsp+48h] [rbp-480h] BYREF
  int v17; // [rsp+68h] [rbp-460h]
  WCHAR String[264]; // [rsp+70h] [rbp-458h] BYREF
  WCHAR pszBuf[264]; // [rsp+280h] [rbp-248h] BYREF

  v3 = a2;
  v4 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  v5 = 0;
  if ( v4 > 0 )
  {
    while ( 1 )
    {
      v6 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v6, 0x133Cu, v5, (LPARAM)lParam);
      if ( v17 == (_DWORD)v3 )
        break;
      if ( ++v5 >= v4 )
        return;
    }
    if ( !*(_DWORD *)(a1 + 532 * v3 + 7128) )
    {
      v7 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * v3 + 1832) + 112i64))(*(_QWORD *)(a1 + 8 * v3 + 1832));
      sub_14007E270(v7, pszBuf, 1u);
      v8 = (char *)(a1 + 532 * v3 + 7132);
      v9 = (char *)pszBuf - v8;
      v10 = 260i64;
      while ( v10 != -2147483386 )
      {
        v11 = *(_WORD *)&v8[v9];
        if ( !v11 )
          break;
        *(_WORD *)v8 = v11;
        v8 += 2;
        if ( !--v10 )
        {
          v8 -= 2;
          break;
        }
      }
      *(_WORD *)v8 = 0;
      sub_140083870(pszBuf, (char *)String, (__int64)L"&&");
      v12 = *(HWND *)(a1 + 136);
      v15[2] = (LPARAM)String;
      LODWORD(v15[0]) = 1;
      SendMessageW(v12, 0x133Du, v5, (LPARAM)v15);
      if ( *(_DWORD *)(a1 + 61028) )
      {
        v13 = *(_QWORD **)(a1 + 61000);
        v14 = (_QWORD *)*v13;
        if ( (_QWORD *)*v13 != v13 )
        {
          while ( *((_DWORD *)v14 + 8) != (_DWORD)v3 )
          {
            v14 = (_QWORD *)*v14;
            if ( v14 == v13 )
              goto LABEL_17;
          }
          SetWindowTextW((HWND)v14[3], String);
          (*(void (__fastcall **)(_QWORD, _QWORD, WCHAR *))(**(_QWORD **)(a1 + 60992) + 152i64))(
            *(_QWORD *)(a1 + 60992),
            v14[3],
            String);
        }
      }
LABEL_17:
      CoTaskMemFree(v7);
    }
  }
}
// 1400D04E9: conditional instruction was optimized away because r11.8!=0
// 1400F46D4: using guessed type wchar_t asc_1400F46D4[3];
// 1400D03E0: using guessed type LPARAM lParam[4];

//----- (00000001400D05E0) ----------------------------------------------------
BOOL __fastcall sub_1400D05E0(__int64 a1)
{
  unsigned int v2; // er8
  int v3; // er10
  __int64 v4; // rcx
  __int16 *v5; // rax
  __int16 *v6; // rax
  __int64 v7; // r8
  char *v8; // r9
  __int16 v9; // dx
  __int64 v10; // r11
  __int16 *v11; // rax
  __int64 v12; // rcx
  __int16 *v13; // rax
  __int64 v14; // rdx
  char *v15; // r9
  __int16 v16; // r8
  const wchar_t *v17; // r8
  __int64 v18; // rcx
  __int16 *v19; // rax
  __int16 *v20; // rax
  __int64 v21; // r8
  char *v22; // r9
  __int16 v23; // dx
  __int64 v24; // rcx
  __int16 *i; // rax
  __int64 v26; // rbx
  __int16 *v27; // rax
  __int64 v28; // rcx
  char *v29; // r8
  __int16 v30; // dx
  BOOL IsMember; // [rsp+60h] [rbp-A0h] BYREF
  PSID SidToCheck; // [rsp+68h] [rbp-98h] BYREF
  LPVOID pv[2]; // [rsp+70h] [rbp-90h] BYREF
  __int16 v35[32]; // [rsp+80h] [rbp-80h] BYREF
  __int16 v36[32]; // [rsp+C0h] [rbp-40h] BYREF
  __int16 String[512]; // [rsp+100h] [rbp+0h] BYREF
  WCHAR pszBuf[264]; // [rsp+500h] [rbp+400h] BYREF
  __int16 v39[512]; // [rsp+710h] [rbp+610h] BYREF

  if ( !*(_DWORD *)(a1 + 60784)
    || (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640)) )
  {
    if ( a1 != -4920 )
    {
      pv[0] = 0i64;
      if ( (int)sub_14007F810(a1 + 4920, (__int64)pv) >= 0 )
      {
        v2 = 0;
        goto LABEL_9;
      }
LABEL_10:
      CoTaskMemFree(pv[0]);
    }
  }
  else if ( a1 != -4920 )
  {
    pv[0] = 0i64;
    if ( (int)sub_14007F810(a1 + 4920, (__int64)pv) >= 0 )
    {
      v2 = 0x8000;
LABEL_9:
      sub_14007E270((LPCITEMIDLIST)pv[0], pszBuf, v2);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  sub_140001000((wchar_t *)String, 0x200ui64, L"%s - Explorer++", pszBuf);
  v3 = *(_DWORD *)(a1 + 60832);
  if ( v3 || *(_DWORD *)(a1 + 60836) )
  {
    v4 = 512i64;
    v5 = String;
    while ( *v5 )
    {
      ++v5;
      if ( !--v4 )
        goto LABEL_23;
    }
    v6 = &String[512 - v4];
    v7 = 0x7FFFFFFFi64;
    v8 = (char *)((char *)L" [" - (char *)v6);
    while ( v7 )
    {
      v9 = *(_WORD *)&v8[(_QWORD)v6];
      if ( !v9 )
        break;
      *v6++ = v9;
      --v7;
      if ( !--v4 )
      {
        --v6;
        break;
      }
    }
    *v6 = 0;
  }
LABEL_23:
  if ( v3 )
  {
    sub_140082AC0((wchar_t *)v39);
    v10 = 512i64;
    v11 = String;
    while ( *v11 )
    {
      ++v11;
      if ( !--v10 )
        goto LABEL_34;
    }
    v12 = v10;
    v13 = &String[512 - v10];
    v14 = 0x7FFFFFFFi64;
    v15 = (char *)((char *)v39 - (char *)v13);
    while ( v14 )
    {
      v16 = *(_WORD *)&v15[(_QWORD)v13];
      if ( !v16 )
        break;
      *v13++ = v16;
      --v14;
      if ( !--v12 )
      {
        --v13;
        break;
      }
    }
    *v13 = 0;
  }
LABEL_34:
  if ( *(_DWORD *)(a1 + 60836) )
  {
    LODWORD(pv[0]) = 0;
    WORD2(pv[0]) = 1280;
    IsMember = 0;
    if ( AllocateAndInitializeSid((PSID_IDENTIFIER_AUTHORITY)pv, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &SidToCheck) )
    {
      CheckTokenMembership(0i64, SidToCheck, &IsMember);
      FreeSid(SidToCheck);
    }
    if ( IsMember )
    {
      sub_140001000((wchar_t *)v35, 0x20ui64, L"Administrators");
    }
    else
    {
      LODWORD(pv[0]) = 0;
      WORD2(pv[0]) = 1280;
      IsMember = 0;
      if ( AllocateAndInitializeSid((PSID_IDENTIFIER_AUTHORITY)pv, 2u, 0x20u, 0x223u, 0, 0, 0, 0, 0, 0, &SidToCheck) )
      {
        CheckTokenMembership(0i64, SidToCheck, &IsMember);
        FreeSid(SidToCheck);
      }
      if ( IsMember )
      {
        sub_140001000((wchar_t *)v35, 0x20ui64, L"Power Users");
      }
      else
      {
        LODWORD(pv[0]) = 0;
        WORD2(pv[0]) = 1280;
        IsMember = 0;
        if ( AllocateAndInitializeSid((PSID_IDENTIFIER_AUTHORITY)pv, 2u, 0x20u, 0x221u, 0, 0, 0, 0, 0, 0, &SidToCheck) )
        {
          CheckTokenMembership(0i64, SidToCheck, &IsMember);
          FreeSid(SidToCheck);
        }
        if ( IsMember )
        {
          sub_140001000((wchar_t *)v35, 0x20ui64, L"Users");
        }
        else
        {
          LODWORD(pv[0]) = 0;
          WORD2(pv[0]) = 1280;
          IsMember = 0;
          if ( AllocateAndInitializeSid((PSID_IDENTIFIER_AUTHORITY)pv, 2u, 0x20u, 0x222u, 0, 0, 0, 0, 0, 0, &SidToCheck) )
          {
            CheckTokenMembership(0i64, SidToCheck, &IsMember);
            FreeSid(SidToCheck);
          }
          if ( IsMember )
            sub_140001000((wchar_t *)v35, 0x20ui64, L"Users/Restricted");
        }
      }
    }
    v17 = L" - %s";
    if ( !*(_DWORD *)(a1 + 60832) )
      v17 = L"%s";
    sub_140001000((wchar_t *)v36, 0x20ui64, v17, v35);
    v18 = 512i64;
    v19 = String;
    while ( *v19 )
    {
      ++v19;
      if ( !--v18 )
        goto LABEL_63;
    }
    v20 = &String[512 - v18];
    v21 = 0x7FFFFFFFi64;
    v22 = (char *)((char *)v36 - (char *)v20);
    while ( v21 )
    {
      v23 = *(_WORD *)&v22[(_QWORD)v20];
      if ( !v23 )
        break;
      *v20++ = v23;
      --v21;
      if ( !--v18 )
      {
        --v20;
        break;
      }
    }
    *v20 = 0;
  }
LABEL_63:
  if ( *(_DWORD *)(a1 + 60832) || *(_DWORD *)(a1 + 60836) )
  {
    v24 = 512i64;
    for ( i = String; *i; ++i )
    {
      if ( !--v24 )
        return SetWindowTextW(*(HWND *)(a1 + 104), (LPCWSTR)String);
    }
    v26 = v24;
    v27 = &String[512 - v24];
    v28 = 0x7FFFFFFFi64;
    v29 = (char *)((char *)L"]" - (char *)v27);
    while ( v28 )
    {
      v30 = *(_WORD *)&v29[(_QWORD)v27];
      if ( !v30 )
        break;
      *v27++ = v30;
      --v28;
      if ( !--v26 )
      {
        --v27;
        break;
      }
    }
    *v27 = 0;
  }
  return SetWindowTextW(*(HWND *)(a1 + 104), (LPCWSTR)String);
}
// 1400D06E3: conditional instruction was optimized away because rcx.8!=0
// 1400D06F6: conditional instruction was optimized away because rcx.8!=0
// 1400D0733: conditional instruction was optimized away because rcx.8!=0
// 1400D0767: conditional instruction was optimized away because r11.8!=0
// 1400D077A: conditional instruction was optimized away because r11.8!=0
// 1400D07B5: conditional instruction was optimized away because rcx.8!=0
// 1400D0A06: conditional instruction was optimized away because rcx.8!=0
// 1400D0A19: conditional instruction was optimized away because rcx.8!=0
// 1400D0A53: conditional instruction was optimized away because rcx.8!=0
// 1400D0A86: conditional instruction was optimized away because rcx.8!=0
// 1400D0A96: conditional instruction was optimized away because rcx.8!=0
// 1400D0AD3: conditional instruction was optimized away because rbx.8!=0
// 1400ECA8C: using guessed type wchar_t asc_1400ECA8C[2];
// 1400F4628: using guessed type wchar_t aSExplorer[16];
// 1400F4648: using guessed type wchar_t asc_1400F4648[3];
// 1400F4650: using guessed type wchar_t aAdministrators[15];
// 1400F4670: using guessed type wchar_t aPowerUsers[12];
// 1400F4688: using guessed type wchar_t aUsers[6];
// 1400F4698: using guessed type wchar_t aUsersRestricte[17];
// 1400F46C0: using guessed type wchar_t aS_5[6];
// 1400F46CC: using guessed type wchar_t aS_6[3];
// 1400D05E0: using guessed type wchar_t String[512];
// 1400D05E0: using guessed type wchar_t var_410[512];
// 1400D05E0: using guessed type wchar_t var_AA0[32];
// 1400D05E0: using guessed type wchar_t var_A60[32];

//----- (00000001400D0B20) ----------------------------------------------------
BOOL __fastcall sub_1400D0B20(__int64 a1, HMENU a2)
{
  __int64 v4; // rcx
  int v5; // esi
  BOOL v6; // er8
  BOOL v7; // er8
  BOOL v8; // er8
  UINT v9; // er8
  BOOL v10; // er8
  BOOL v11; // er8
  BOOL v12; // er8
  BOOL v13; // er8
  BOOL v14; // er8
  BOOL v15; // er8
  BOOL v16; // er8
  BOOL v17; // er8
  BOOL v18; // er8
  BOOL v19; // er8
  BOOL v20; // er8
  BOOL v21; // er8
  UINT v22; // er8
  UINT v23; // er8
  UINT v24; // er8
  UINT v25; // er8
  UINT v26; // er8
  UINT v27; // er8
  UINT v28; // er8
  UINT v29; // er8
  UINT v30; // er8
  UINT v31; // er8
  UINT v32; // er8
  BOOL v33; // er8
  UINT v34; // eax
  BOOL v35; // er8
  BOOL v36; // er8
  BOOL v37; // er8
  BOOL v38; // er8
  UINT v39; // er8
  int v41; // [rsp+40h] [rbp+8h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
  (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v4 + 48i64))(v4, &v41);
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 288i64))(*(_QWORD *)(a1 + 2640));
  v6 = sub_1400B52C0(a1) == 0;
  EnableMenuItem(a2, 0x9C7Du, v6);
  v7 = sub_1400B52C0(a1) == 0;
  EnableMenuItem(a2, 0x9DD3u, v7);
  v8 = sub_1400B52C0(a1) == 0;
  EnableMenuItem(a2, 0x9CE8u, v8);
  if ( v5 )
  {
    EnableMenuItem(a2, 0x9C7Bu, 1u);
    v9 = 1;
  }
  else
  {
    EnableMenuItem(a2, 0x9C7Bu, 0);
    v9 = 0;
  }
  EnableMenuItem(a2, 0x1F42u, v9);
  v10 = !*(_DWORD *)(a1 + 62416) || v41 != 4;
  EnableMenuItem(a2, 0x9D2Du, v10);
  v11 = !sub_1400B6040(a1);
  EnableMenuItem(a2, 0x9C80u, v11);
  v12 = !sub_1400B5FD0(a1);
  EnableMenuItem(a2, 0x9C7Fu, v12);
  v13 = !sub_1400B5FD0(a1);
  EnableMenuItem(a2, 0x9CD1u, v13);
  v14 = !sub_1400B61E0(a1);
  EnableMenuItem(a2, 0x9C81u, v14);
  EnableMenuItem(a2, 0x9D85u, *(_QWORD *)(a1 + 61072) == 0i64);
  v15 = sub_1400B6250(a1) == 0;
  EnableMenuItem(a2, 0x9C86u, v15);
  v16 = sub_1400B6250(a1) == 0;
  EnableMenuItem(a2, 0x9C87u, v16);
  v17 = sub_1400B6250(a1) == 0;
  EnableMenuItem(a2, 0x9CFDu, v17);
  v18 = sub_1400B56A0(a1) == 0;
  EnableMenuItem(a2, 0x9C85u, v18);
  v19 = sub_1400B56A0(a1) == 0;
  EnableMenuItem(a2, 0x9C83u, v19);
  v20 = !(unsigned int)sub_1400B56A0(a1) || GetFocus() == *(HWND *)(a1 + 152);
  EnableMenuItem(a2, 0x9C88u, v20);
  v21 = !(unsigned int)sub_1400B56A0(a1) || GetFocus() == *(HWND *)(a1 + 152);
  EnableMenuItem(a2, 0x9C89u, v21);
  EnableMenuItem(a2, 0x9D0Cu, *(_DWORD *)(a1 + 62416) == 0);
  EnableMenuItem(a2, 0x9C8Cu, *(_DWORD *)(a1 + 62416) == 0);
  EnableMenuItem(a2, 0x9CEAu, *(_DWORD *)(a1 + 62416) == 0);
  EnableMenuItem(a2, 0x9CECu, *(_DWORD *)(a1 + 62416) == 0);
  if ( *(_DWORD *)(a1 + 60744) )
    v22 = 8;
  else
    v22 = 0;
  CheckMenuItem(a2, 0x9C8Du, v22);
  if ( *(_DWORD *)(a1 + 60748) )
    v23 = 8;
  else
    v23 = 0;
  CheckMenuItem(a2, 0x9C8Eu, v23);
  if ( *(_DWORD *)(a1 + 60756) )
    v24 = 8;
  else
    v24 = 0;
  CheckMenuItem(a2, 0x9D07u, v24);
  if ( *(_DWORD *)(a1 + 60752) )
    v25 = 8;
  else
    v25 = 0;
  CheckMenuItem(a2, 0x9D5Au, v25);
  if ( *(_DWORD *)(a1 + 60760) )
    v26 = 8;
  else
    v26 = 0;
  CheckMenuItem(a2, 0x9D63u, v26);
  if ( *(_DWORD *)(a1 + 60764) )
    v27 = 8;
  else
    v27 = 0;
  CheckMenuItem(a2, 0x9D64u, v27);
  if ( *(_DWORD *)(a1 + 60768) )
    v28 = 8;
  else
    v28 = 0;
  CheckMenuItem(a2, 0x9D8Bu, v28);
  if ( *(_DWORD *)(a1 + 60772) )
    v29 = 8;
  else
    v29 = 0;
  CheckMenuItem(a2, 0x9D9Du, v29);
  if ( *(_DWORD *)(a1 + 60820) )
    v30 = 8;
  else
    v30 = 0;
  CheckMenuItem(a2, 0x9D98u, v30);
  if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 496i64))(*(_QWORD *)(a1 + 2640)) )
    v31 = 8;
  else
    v31 = 0;
  CheckMenuItem(a2, 0x9CA8u, v31);
  if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 432i64))(*(_QWORD *)(a1 + 2640)) )
    v32 = 8;
  else
    v32 = 0;
  CheckMenuItem(a2, 0x9D25u, v32);
  EnableMenuItem(a2, 0x9D47u, v5 != 0);
  v33 = (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 392i64))(*(_QWORD *)(a1 + 2640)) != 1 || v5;
  EnableMenuItem(a2, 0x9D41u, v33);
  EnableMenuItem(a2, 0x9D44u, *(_DWORD *)(a1 + 62416) <= 1);
  EnableMenuItem(a2, 0x9D45u, *(_DWORD *)(a1 + 62416) == 0);
  GetWindowLongW(*(HWND *)(a1 + 4800), -16);
  v34 = sub_1400AF190(v41);
  CheckMenuRadioItem(a2, 0xEA60u, 0xEA68u, v34, 0);
  v35 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64) == 0;
  EnableMenuItem(a2, 0x9C79u, v35);
  v36 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 136i64))(*(_QWORD *)(a1 + 2640)) == 0;
  EnableMenuItem(a2, 0x9C9Du, v36);
  v37 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 144i64))(*(_QWORD *)(a1 + 2640)) == 0;
  EnableMenuItem(a2, 0x9C9Eu, v37);
  v38 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 184i64))(*(_QWORD *)(a1 + 2640)) == 0;
  EnableMenuItem(a2, 0x9C9Fu, v38);
  EnableMenuItem(a2, 0x9D49u, v41 != 4);
  if ( v41 != 4 )
  {
    if ( v41 == 3 )
    {
      EnableMenuItem(a2, 0x9DB9u, 1u);
      EnableMenuItem(a2, 0x9C9Cu, 1u);
    }
    else
    {
      EnableMenuItem(a2, 0x9DB9u, 0);
      EnableMenuItem(a2, 0x9C9Cu, 0);
      if ( (*(unsigned int (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 488i64))(*(_QWORD *)(a1 + 2640)) )
      {
        v39 = 8;
        goto LABEL_58;
      }
    }
    v39 = 0;
LABEL_58:
    CheckMenuItem(a2, 0x9C9Cu, v39);
    return sub_1400CFD80(a1);
  }
  EnableMenuItem(a2, 0x9C9Cu, 1u);
  CheckMenuItem(a2, 0x9C9Cu, 0);
  EnableMenuItem(a2, 0x9DB9u, 0);
  return sub_1400CFD80(a1);
}

//----- (00000001400D12A0) ----------------------------------------------------
LRESULT __fastcall sub_1400D12A0(__int64 a1, int a2, int a3, const WCHAR *a4)
{
  WPARAM v5; // rsi
  __int64 v7; // rax
  __int64 v8; // rax
  int v9; // ebp
  HWND v10; // rcx
  WPARAM v11; // rbx
  WPARAM v12; // rsi
  HWND v13; // rcx
  LRESULT result; // rax
  ICONINFO piconinfo; // [rsp+30h] [rbp-338h] BYREF
  int lParam[7]; // [rsp+50h] [rbp-318h] BYREF
  int v17; // [rsp+6Ch] [rbp-2FCh]
  SHFILEINFOW psfi; // [rsp+80h] [rbp-2E8h] BYREF

  v5 = a2;
  v7 = 532i64 * a3;
  if ( *(_DWORD *)(v7 + a1 + 7124) || *(_DWORD *)(v7 + a1 + 7120) )
  {
    v9 = 0;
  }
  else
  {
    SHGetFileInfoW(a4, 0, &psfi, 0x2B8u, 0x109u);
    sub_1400947A0(a1, a3, psfi.hIcon);
    GetIconInfo(psfi.hIcon, &piconinfo);
    v8 = SendMessageW(*(HWND *)(a1 + 136), 0x1302u, 0i64, 0i64);
    v9 = sub_1400012C0(v8, (__int64)piconinfo.hbmColor, (__int64)piconinfo.hbmMask);
    DeleteObject(piconinfo.hbmColor);
    DeleteObject(piconinfo.hbmMask);
    DestroyIcon(psfi.hIcon);
  }
  v10 = *(HWND *)(a1 + 136);
  lParam[0] = 2;
  v11 = v5;
  SendMessageW(v10, 0x133Cu, v5, (LPARAM)lParam);
  v12 = v17;
  v13 = *(HWND *)(a1 + 136);
  lParam[0] = 2;
  v17 = v9;
  result = SendMessageW(v13, 0x133Du, v11, (LPARAM)lParam);
  if ( (_DWORD)v12 )
    return SendMessageW(*(HWND *)(a1 + 136), 0x132Au, v12, 0i64);
  return result;
}
// 1400D12A0: using guessed type _DWORD lParam[7];

//----- (00000001400D1430) ----------------------------------------------------
void __fastcall sub_1400D1430(__int64 a1, int a2, int a3)
{
  __int64 v6; // rcx
  WCHAR *v7; // rbx

  v6 = *(_QWORD *)(a1 + 8i64 * a3 + 1832);
  v7 = (WCHAR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 112i64))(v6);
  sub_1400D12A0(a1, a2, a3, v7);
  CoTaskMemFree(v7);
}

//----- (00000001400D14A0) ----------------------------------------------------
void __fastcall sub_1400D14A0(__int64 a1, int a2)
{
  __int64 v4; // rcx
  __int64 v5; // rbp
  WCHAR *v6; // r13
  int v7; // er14
  int v8; // esi
  int v9; // ebx
  HWND v10; // rcx
  __int64 v11; // rbp
  __int64 v12; // rax
  HWND v13; // rcx
  WPARAM v14; // rsi
  HWND v15; // rcx
  ICONINFO piconinfo; // [rsp+30h] [rbp-368h] BYREF
  int v17[7]; // [rsp+50h] [rbp-348h] BYREF
  int v18; // [rsp+6Ch] [rbp-32Ch]
  __int64 lParam[4]; // [rsp+78h] [rbp-320h] BYREF
  int v20; // [rsp+98h] [rbp-300h]
  SHFILEINFOW psfi; // [rsp+A0h] [rbp-2F8h] BYREF

  v4 = *(_QWORD *)(a1 + 8i64 * a2 + 1832);
  v5 = a2;
  v6 = (WCHAR *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 112i64))(v4);
  v7 = 0;
  v8 = SendMessageW(*(HWND *)(a1 + 136), 0x1304u, 0i64, 0i64);
  v9 = 0;
  if ( v8 > 0 )
  {
    while ( 1 )
    {
      v10 = *(HWND *)(a1 + 136);
      LODWORD(lParam[0]) = 8;
      SendMessageW(v10, 0x133Cu, v9, (LPARAM)lParam);
      if ( v20 == a2 )
        break;
      if ( ++v9 >= v8 )
        goto LABEL_10;
    }
    v11 = 532 * v5;
    if ( !*(_DWORD *)(a1 + v11 + 7124) && !*(_DWORD *)(a1 + v11 + 7120) )
    {
      SHGetFileInfoW(v6, 0, &psfi, 0x2B8u, 0x109u);
      sub_1400947A0(a1, a2, psfi.hIcon);
      GetIconInfo(psfi.hIcon, &piconinfo);
      v12 = SendMessageW(*(HWND *)(a1 + 136), 0x1302u, 0i64, 0i64);
      v7 = sub_1400012C0(v12, (__int64)piconinfo.hbmColor, (__int64)piconinfo.hbmMask);
      DeleteObject(piconinfo.hbmColor);
      DeleteObject(piconinfo.hbmMask);
      DestroyIcon(psfi.hIcon);
    }
    v13 = *(HWND *)(a1 + 136);
    v17[0] = 2;
    SendMessageW(v13, 0x133Cu, v9, (LPARAM)v17);
    v14 = v18;
    v15 = *(HWND *)(a1 + 136);
    v17[0] = 2;
    v18 = v7;
    SendMessageW(v15, 0x133Du, v9, (LPARAM)v17);
    if ( (_DWORD)v14 )
      SendMessageW(*(HWND *)(a1 + 136), 0x132Au, v14, 0i64);
  }
LABEL_10:
  CoTaskMemFree(v6);
}
// 1400D14A0: using guessed type LPARAM lParam[4];
// 1400D14A0: using guessed type _DWORD var_348[7];

//----- (00000001400D16B0) ----------------------------------------------------
void __fastcall sub_1400D16B0(__int64 a1)
{
  WCHAR *v2; // rbx

  v2 = (WCHAR *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 2640) + 112i64))(*(_QWORD *)(a1 + 2640));
  sub_1400D12A0(a1, *(_DWORD *)(a1 + 7060), *(_DWORD *)(a1 + 7048), v2);
  CoTaskMemFree(v2);
}

//----- (00000001400D1700) ----------------------------------------------------
void __fastcall sub_1400D1700(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    a1 + 4920);
  sub_1400D05E0(a1);
  sub_1400D0130(a1);
  sub_1400BD730(a1);
  sub_1400D0250(a1, *(_DWORD *)(a1 + 7060), *(_DWORD *)(a1 + 7048));
  sub_1400B60B0(a1);
  sub_1400B82C0(a1);
  sub_140094210(a1);
  sub_1400B8250(a1);
  if ( *(_DWORD *)(a1 + 60748) )
    SendMessageW(*(HWND *)(a1 + 176), 0x402u, 0xAFCDui64, 1i64);
}

//----- (00000001400D17A0) ----------------------------------------------------
void __fastcall sub_1400D17A0(__int64 a1)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    sub_1400BD9D0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    sub_140092760(a1);
  }
}

//----- (00000001400D17F0) ----------------------------------------------------
void __fastcall sub_1400D17F0(__int64 a1)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    sub_1400BEBE0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    sub_140092950(a1);
  }
}

//----- (00000001400D1840) ----------------------------------------------------
int __fastcall sub_1400D1840(__int64 a1)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    LODWORD(Focus) = sub_1400BF3D0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    LODWORD(Focus) = sub_140092D20(a1);
  }
  return (int)Focus;
}

//----- (00000001400D1890) ----------------------------------------------------
void __fastcall sub_1400D1890(__int64 a1, HWND *a2)
{
  HWND v3; // rcx
  DWORD MessagePos; // eax
  HWND v5; // rdi
  DWORD v6; // eax
  struct tagPOINT v7; // [rsp+30h] [rbp+8h] BYREF

  v3 = *(HWND *)(a1 + 4800);
  if ( *a2 == v3 )
  {
    MessagePos = GetMessagePos();
    v7.x = (__int16)MessagePos;
    v7.y = SHIWORD(MessagePos);
    sub_1400C0ED0(a1, &v7);
  }
  else
  {
    v5 = *a2;
    if ( v5 == (HWND)SendMessageW(v3, 0x101Fu, 0i64, 0i64) )
    {
      v6 = GetMessagePos();
      v7.x = (__int16)v6;
      v7.y = SHIWORD(v6);
      sub_1400BE160(a1, (__int64)&v7);
    }
    else if ( v5 == *(HWND *)(a1 + 176) )
    {
      sub_1400AFF90(a1);
    }
  }
}

//----- (00000001400D1940) ----------------------------------------------------
void __fastcall sub_1400D1940(__int64 a1, int a2)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    sub_1400C0210(a1, a2);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    sub_140092820(a1, a2);
  }
}

//----- (00000001400D19A0) ----------------------------------------------------
void __fastcall sub_1400D19A0(__int64 a1)
{
  HWND v2; // rax
  HWND Focus; // rax

  if ( *(_DWORD *)(a1 + 62464) )
  {
    v2 = (HWND)SendMessageW(*(HWND *)(a1 + 4800), 0x1018u, 0i64, 0i64);
    SendMessageW(v2, 0x8037u, 0x71ui64, 0i64);
  }
  else
  {
    Focus = GetFocus();
    if ( Focus == *(HWND *)(a1 + 4800) )
    {
      sub_1400BFEC0(a1);
    }
    else if ( Focus == *(HWND *)(a1 + 152) )
    {
      sub_1400926D0(a1);
    }
  }
}

//----- (00000001400D1A20) ----------------------------------------------------
HWND __fastcall sub_1400D1A20(__int64 a1, unsigned int a2)
{
  HWND result; // rax

  result = GetFocus();
  if ( result == *(HWND *)(a1 + 4800) )
    return (HWND)sub_1400BF540(a1, a2);
  if ( result == *(HWND *)(a1 + 152) )
    return (HWND)sub_1400932D0(a1, a2);
  return result;
}
// 1400932D0: using guessed type __int64 __fastcall sub_1400932D0(_QWORD, _QWORD);
// 1400BF540: using guessed type __int64 __fastcall sub_1400BF540(_QWORD, _QWORD);

//----- (00000001400D1A80) ----------------------------------------------------
void __fastcall sub_1400D1A80(__int64 a1)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    sub_1400BF8A0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    sub_1400935F0(a1);
  }
}
// 1400BF8A0: using guessed type __int64 __fastcall sub_1400BF8A0(_QWORD);

//----- (00000001400D1AD0) ----------------------------------------------------
void __fastcall sub_1400D1AD0(__int64 a1)
{
  HWND Focus; // rax

  Focus = GetFocus();
  if ( Focus == *(HWND *)(a1 + 4800) )
  {
    sub_1400BFBF0(a1);
  }
  else if ( Focus == *(HWND *)(a1 + 152) )
  {
    sub_140093760(a1);
  }
}
// 1400BFBF0: using guessed type __int64 __fastcall sub_1400BFBF0(_QWORD);

//----- (00000001400D1B10) ----------------------------------------------------
__int64 __fastcall sub_1400D1B10(int a1, __int64 a2)
{
  int v5; // ebx
  const WCHAR *v6; // rbx
  const WCHAR *v7; // rdi
  unsigned int v8; // esi
  LSTATUS v9; // ebp
  int v10; // eax
  LSTATUS v11; // edi
  HKEY hKey; // [rsp+30h] [rbp-558h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+40h] [rbp-548h] BYREF
  WCHAR pszSubKey[512]; // [rsp+160h] [rbp-428h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && a1 == 3 )
    return 0i64;
  v5 = a1 - 2;
  if ( v5 && v5 == 1 )
  {
    v6 = L"Folder\\shell";
    v7 = &word_1400EA38C;
  }
  else
  {
    v7 = L"none";
    v6 = L"Directory\\shell";
  }
  v8 = 1;
  v9 = 1;
  if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, v6, 0, 0x20006u, &hKey) )
    return 0;
  v10 = lstrlenW(v7);
  v11 = RegSetValueExW(hKey, 0i64, 0, 1u, (const BYTE *)v7, 2 * v10 + 2);
  if ( !v11 )
  {
    sub_140001000(pszSubKey, 0x200ui64, L"%s\\%s", v6, a2);
    v9 = SHDeleteKeyW(HKEY_CLASSES_ROOT, pszSubKey);
  }
  RegCloseKey(hKey);
  if ( v11 || v9 )
    return 0;
  return v8;
}
// 1400EB730: using guessed type wchar_t aNone_0[5];
// 1400EB750: using guessed type wchar_t aSS_14[6];

//----- (00000001400D1C80) ----------------------------------------------------
_BOOL8 __fastcall sub_1400D1C80(__int64 a1)
{
  LSTATUS v3; // ebx
  int v4; // eax
  LSTATUS v5; // esi
  HKEY hKey; // [rsp+30h] [rbp-548h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+40h] [rbp-538h] BYREF
  WCHAR pszSubKey[512]; // [rsp+160h] [rbp-418h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 )
    return 0i64;
  v3 = 1;
  if ( RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Folder\\shell", 0, 0x20006u, &hKey) )
    return 0i64;
  v4 = lstrlenW(&word_1400EA38C);
  v5 = RegSetValueExW(hKey, 0i64, 0, 1u, (const BYTE *)&word_1400EA38C, 2 * v4 + 2);
  if ( !v5 )
  {
    sub_140001000(pszSubKey, 0x200ui64, L"%s\\%s", L"Folder\\shell", a1);
    v3 = SHDeleteKeyW(HKEY_CLASSES_ROOT, pszSubKey);
  }
  RegCloseKey(hKey);
  return !v5 && !v3;
}
// 1400EB750: using guessed type wchar_t aSS_14[6];

//----- (00000001400D1DE0) ----------------------------------------------------
__int64 __fastcall sub_1400D1DE0(int a1, const WCHAR *a2, const WCHAR *a3)
{
  int v7; // ebx
  const WCHAR *v8; // rdx
  unsigned int v9; // ebx
  int v10; // eax
  DWORD CurrentProcessId; // eax
  HANDLE v12; // rax
  void *v13; // rdi
  int v14; // eax
  int v15; // eax
  HKEY v16; // [rsp+50h] [rbp-778h] BYREF
  DWORD dwDisposition; // [rsp+58h] [rbp-770h] BYREF
  HKEY hKey; // [rsp+60h] [rbp-768h] BYREF
  HKEY v19; // [rsp+68h] [rbp-760h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+70h] [rbp-758h] BYREF
  char v21[528]; // [rsp+190h] [rbp-638h] BYREF
  WCHAR String[512]; // [rsp+3A0h] [rbp-428h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  if ( VersionInformation.dwMajorVersion == 5 && a1 == 3 )
    return 0i64;
  v7 = a1 - 2;
  if ( !v7 || (v8 = L"Folder\\shell", v7 != 1) )
    v8 = L"Directory\\shell";
  v9 = 0;
  if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, v8, 0, 0x20006u, &hKey) )
  {
    if ( !RegCreateKeyExW(hKey, a2, 0, 0i64, 0, 0x20006u, 0i64, &v16, &dwDisposition) )
    {
      v10 = lstrlenW(a3);
      RegSetValueExW(v16, 0i64, 0, 1u, (const BYTE *)a3, 2 * v10 + 2);
      if ( !RegCreateKeyExW(v16, L"command", 0, 0i64, 0, 0x20006u, 0i64, &v19, &dwDisposition) )
      {
        CurrentProcessId = GetCurrentProcessId();
        v12 = OpenProcess(0x410u, 0, CurrentProcessId);
        v13 = v12;
        if ( v12 )
        {
          GetModuleFileNameExW(v12, 0i64, v21, 260i64);
          CloseHandle(v13);
        }
        sub_140001000(String, 0x200ui64, L"\"%s\" \"%%1\"", v21);
        v14 = lstrlenW(String);
        if ( !RegSetValueExW(v19, 0i64, 0, 1u, (const BYTE *)String, 2 * v14 + 2) )
        {
          v15 = lstrlenW(a2);
          if ( !RegSetValueExW(hKey, 0i64, 0, 1u, (const BYTE *)a2, 2 * v15 + 2) )
            v9 = 1;
        }
        RegCloseKey(v19);
      }
      RegCloseKey(v16);
    }
    RegCloseKey(hKey);
  }
  return v9;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400EB6B8: using guessed type wchar_t aS1[11];

//----- (00000001400D2040) ----------------------------------------------------
__int64 sub_1400D2040()
{
  unsigned int v0; // ebx
  int v1; // eax
  DWORD CurrentProcessId; // eax
  HANDLE v3; // rax
  void *v4; // rdi
  int v5; // eax
  int v6; // eax
  HKEY v8; // [rsp+50h] [rbp-768h] BYREF
  DWORD dwDisposition; // [rsp+58h] [rbp-760h] BYREF
  HKEY hKey; // [rsp+60h] [rbp-758h] BYREF
  HKEY v11; // [rsp+68h] [rbp-750h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+70h] [rbp-748h] BYREF
  char v13[528]; // [rsp+190h] [rbp-628h] BYREF
  WCHAR String[512]; // [rsp+3A0h] [rbp-418h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  GetVersionExW(&VersionInformation);
  v0 = 0;
  if ( VersionInformation.dwMajorVersion != 5 && !RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Folder\\shell", 0, 0x20006u, &hKey) )
  {
    if ( !RegCreateKeyExW(hKey, L"openinexplorer++", 0, 0i64, 0, 0x20006u, 0i64, &v8, &dwDisposition) )
    {
      v1 = lstrlenW(L"Open In Explorer++");
      RegSetValueExW(v8, 0i64, 0, 1u, (const BYTE *)L"Open In Explorer++", 2 * v1 + 2);
      if ( !RegCreateKeyExW(v8, L"command", 0, 0i64, 0, 0x20006u, 0i64, &v11, &dwDisposition) )
      {
        CurrentProcessId = GetCurrentProcessId();
        v3 = OpenProcess(0x410u, 0, CurrentProcessId);
        v4 = v3;
        if ( v3 )
        {
          GetModuleFileNameExW(v3, 0i64, v13, 260i64);
          CloseHandle(v4);
        }
        sub_140001000(String, 0x200ui64, L"\"%s\" \"%%1\"", v13);
        v5 = lstrlenW(String);
        if ( !RegSetValueExW(v11, 0i64, 0, 1u, (const BYTE *)String, 2 * v5 + 2) )
        {
          v6 = lstrlenW(L"openinexplorer++");
          if ( !RegSetValueExW(hKey, 0i64, 0, 1u, (const BYTE *)L"openinexplorer++", 2 * v6 + 2) )
            v0 = 1;
        }
        RegCloseKey(v11);
      }
      RegCloseKey(v8);
    }
    RegCloseKey(hKey);
  }
  return v0;
}
// 1400E3670: using guessed type __int64 __fastcall GetModuleFileNameExW(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400EB6B8: using guessed type wchar_t aS1[11];

//----- (00000001400D2390) ----------------------------------------------------
_QWORD *__fastcall sub_1400D2390(_QWORD *a1, void *a2, const ITEMIDLIST *a3, void **a4)
{
  void *v6; // rdi
  LPCITEMIDLIST v8; // r14
  LPCITEMIDLIST v9; // rbx
  __int64 v10; // rdi
  char *v11; // rax
  __int64 v12; // rdx
  int v13; // edi
  int v14; // ebx
  HRESULT v15; // ebx
  _QWORD *v16; // rdx
  void *v17; // r13
  int v18; // eax
  int v19; // eax
  void **v20; // rcx
  void **v21; // rbx
  __int64 v23; // [rsp+40h] [rbp-40h] BYREF
  LPCITEMIDLIST ppidlLast[2]; // [rsp+48h] [rbp-38h] BYREF
  void *Block[5]; // [rsp+58h] [rbp-28h] BYREF
  void *ppv; // [rsp+C8h] [rbp+48h] BYREF
  void **v27; // [rsp+D8h] [rbp+58h]

  v27 = a4;
  ppv = a2;
  ppidlLast[1] = (LPCITEMIDLIST)-2i64;
  v6 = a2;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[4] = a2;
  a1[7] = ILClone(a3);
  sub_14000AB00(a1 + 8);
  v23 = 0i64;
  v8 = (LPCITEMIDLIST)*a4;
  v9 = *(LPCITEMIDLIST *)*a4;
  if ( v9 != *a4 )
  {
    do
    {
      ppidlLast[0] = ILClone(*(LPCITEMIDLIST *)((char *)&v9[5].mkid.cb + 1));
      v10 = a1[8];
      v11 = sub_14000BB70(v10, *(_QWORD *)(v10 + 8), ppidlLast);
      v12 = a1[9];
      if ( v12 == 0x1FFFFFFFFFFFFFFEi64 )
        sub_14002B5F8("list<T> too long");
      a1[9] = v12 + 1;
      *(_QWORD *)(v10 + 8) = v11;
      **((_QWORD **)v11 + 1) = v11;
      v9 = *(LPCITEMIDLIST *)&v9->mkid.cb;
    }
    while ( v9 != v8 );
    v6 = ppv;
  }
  a1[3] = 0i64;
  ppv = 0i64;
  ppidlLast[0] = 0i64;
  if ( a4[1] )
  {
    if ( SHGetFolderLocation(0i64, 0, 0i64, 0, (LPITEMIDLIST *)ppidlLast) >= 0
      && (v14 = sub_14007DCB0((__int64)a3, (__int64)ppidlLast[0]), CoTaskMemFree((LPVOID)ppidlLast[0]), v14) )
    {
      v15 = SHGetDesktopFolder((IShellFolder **)&ppv);
    }
    else
    {
      ppidlLast[0] = 0i64;
      SHGetDesktopFolder((IShellFolder **)ppidlLast);
      v15 = (*(__int64 (__fastcall **)(LPCITEMIDLIST, const ITEMIDLIST *, _QWORD, const IID *, void **))(*(_QWORD *)ppidlLast[0] + 40i64))(
              ppidlLast[0],
              a3,
              0i64,
              &stru_1400E3FB0,
              &ppv);
      (*(void (__fastcall **)(LPCITEMIDLIST))(*(_QWORD *)ppidlLast[0] + 16i64))(ppidlLast[0]);
    }
    if ( v15 < 0 )
      goto LABEL_20;
    v16 = *a4;
    memset(Block, 0, 24);
    sub_14001C7D0((__int64 **)Block, (_QWORD *)*v16, v16);
    v17 = Block[0];
    v13 = (*(__int64 (__fastcall **)(void *, void *, _QWORD, void *, void *, _QWORD, __int64 *))(*(_QWORD *)ppv + 80i64))(
            ppv,
            v6,
            *((unsigned int *)a4 + 2),
            Block[0],
            &unk_1400E3FA0,
            0i64,
            &v23);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
    if ( v17 )
      j_free(v17);
  }
  else
  {
    if ( SHBindToParent(a3, &stru_1400E3FB0, &ppv, ppidlLast) < 0 )
      goto LABEL_20;
    v13 = (*(__int64 (__fastcall **)(void *, void *, __int64, LPCITEMIDLIST *, void *, _QWORD, __int64 *))(*(_QWORD *)ppv + 80i64))(
            ppv,
            v6,
            1i64,
            ppidlLast,
            &unk_1400E3FA0,
            0i64,
            &v23);
    (*(void (__fastcall **)(void *))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  if ( v13 >= 0 )
  {
    v18 = (**(__int64 (__fastcall ***)(__int64, void *, _QWORD *))v23)(v23, &unk_1400E4010, a1);
    a1[3] = *a1;
    if ( v18 < 0 )
    {
      v19 = (**(__int64 (__fastcall ***)(__int64, void *, _QWORD *))v23)(v23, &unk_1400E3FD0, a1 + 1);
      a1[3] = a1[1];
      if ( v19 < 0 )
      {
        (**(void (__fastcall ***)(__int64, void *, _QWORD *))v23)(v23, &unk_1400E3FA0, a1 + 2);
        a1[3] = a1[2];
      }
    }
  }
LABEL_20:
  if ( v23 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 16i64))(v23);
  v20 = *(void ***)*a4;
  *(_QWORD *)*a4 = *a4;
  *((_QWORD *)*a4 + 1) = *a4;
  a4[1] = 0i64;
  if ( v20 != *a4 )
  {
    do
    {
      v21 = (void **)*v20;
      j_free(v20);
      v20 = v21;
    }
    while ( v21 != *a4 );
  }
  j_free(*a4);
  return a1;
}

//----- (00000001400D26B0) ----------------------------------------------------
LRESULT __fastcall sub_1400D26B0(__int64 *a1, HWND a2, UINT a3, WPARAM a4, LPARAM a5)
{
  __int64 v9; // rcx
  WPARAM v10; // rsi
  int v11; // edx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 lParam[128]; // [rsp+30h] [rbp-438h] BYREF

  if ( a3 == 43 )
  {
    if ( !a4 )
    {
      v15 = *a1;
      if ( v15 )
      {
        (*(void (__fastcall **)(__int64, __int64, _QWORD, LPARAM, _QWORD))(*(_QWORD *)v15 + 56i64))(
          v15,
          43i64,
          0i64,
          a5,
          0i64);
        return 1i64;
      }
      if ( a1[1] )
        (*(void (__fastcall **)(__int64, __int64, _QWORD, LPARAM))(*(_QWORD *)a1[1] + 48i64))(a1[1], 43i64, 0i64, a5);
    }
    return 1i64;
  }
  else
  {
    if ( a3 != 44 )
    {
      if ( a3 == 279 )
      {
        v13 = *a1;
        if ( v13 )
        {
          (*(void (__fastcall **)(__int64, __int64, WPARAM, LPARAM, _QWORD))(*(_QWORD *)v13 + 56i64))(
            v13,
            279i64,
            a4,
            a5,
            0i64);
        }
        else if ( a1[1] )
        {
          (*(void (__fastcall **)(__int64, __int64, WPARAM, LPARAM))(*(_QWORD *)a1[1] + 48i64))(a1[1], 279i64, a4, a5);
        }
      }
      else if ( a3 == 287 )
      {
        v9 = a1[6];
        if ( v9 )
        {
          v10 = a4 >> 16;
          if ( WORD1(a4) != 0xFFFF || a5 )
          {
            sub_140079430(v9);
            if ( (v10 & 0x10) == 0 )
            {
              v11 = *((_DWORD *)a1 + 10);
              if ( (unsigned __int16)a4 >= v11
                && (unsigned __int16)a4 <= *((int *)a1 + 11)
                && !(*(unsigned int (__fastcall **)(__int64, _QWORD, __int64))(*(_QWORD *)a1[3] + 40i64))(
                      a1[3],
                      (unsigned __int16)a4 - v11,
                      5i64) )
              {
                SendMessageW(*(HWND *)a1[6], 0x40Bu, 0i64, (LPARAM)lParam);
              }
            }
          }
          else
          {
            sub_140079310(v9);
          }
          return 0i64;
        }
      }
      return DefSubclassProc(a2, a3, a4, a5);
    }
    if ( a4 )
      return DefSubclassProc(a2, a3, a4, a5);
    v14 = *a1;
    if ( v14 )
    {
      (*(void (__fastcall **)(__int64, __int64, _QWORD, LPARAM, _QWORD))(*(_QWORD *)v14 + 56i64))(
        v14,
        44i64,
        0i64,
        a5,
        0i64);
      return 1i64;
    }
    else
    {
      if ( a1[1] )
        (*(void (__fastcall **)(__int64, __int64, _QWORD, LPARAM))(*(_QWORD *)a1[1] + 48i64))(a1[1], 44i64, 0i64, a5);
      return 1i64;
    }
  }
}
// 1400D26B0: using guessed type LPARAM lParam[128];

//----- (00000001400D28E0) ----------------------------------------------------
LRESULT __fastcall sub_1400D28E0(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        UINT_PTR uIdSubclass,
        DWORD_PTR dwRefData)
{
  return sub_1400D26B0((__int64 *)dwRefData, hWnd, uMsg, wParam, lParam);
}

//----- (00000001400D2910) ----------------------------------------------------
__int64 __fastcall sub_1400D2910(DWORD_PTR dwRefData, __int64 a2, int *a3, __int64 a4, __int64 a5, int a6, int a7)
{
  HMENU PopupMenu; // rax
  int v11; // edx
  HMENU v12; // rbp
  BOOL v13; // esi
  int v14; // esi
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v18[5]; // [rsp+40h] [rbp-108h] BYREF
  int v19; // [rsp+68h] [rbp-E0h]
  char v20[128]; // [rsp+80h] [rbp-C8h] BYREF

  if ( !a2 || !a3 )
    return 2147500037i64;
  *(_QWORD *)(dwRefData + 48) = a4;
  *(_DWORD *)(dwRefData + 40) = 1;
  *(_DWORD *)(dwRefData + 44) = 1000;
  PopupMenu = CreatePopupMenu();
  v11 = 0;
  v12 = PopupMenu;
  if ( a7 )
    v11 = 256;
  if ( a6 )
    v11 |= 0x10u;
  (*(void (__fastcall **)(_QWORD, HMENU, _QWORD, __int64, int, int))(**(_QWORD **)(dwRefData + 24) + 24i64))(
    *(_QWORD *)(dwRefData + 24),
    PopupMenu,
    0i64,
    1i64,
    1000,
    v11);
  (**(void (__fastcall ***)(__int64, _QWORD, DWORD_PTR, __int64, HMENU))a2)(
    a2,
    *(_QWORD *)(dwRefData + 56),
    dwRefData + 64,
    a5,
    v12);
  if ( *(_OWORD *)dwRefData != 0i64 )
    SetWindowSubclass(*(HWND *)(dwRefData + 32), (SUBCLASSPROC)sub_1400D28E0, 1ui64, dwRefData);
  v13 = TrackPopupMenu(v12, 0x100u, *a3, a3[1], 0, *(HWND *)(dwRefData + 32), 0i64);
  if ( *(_QWORD *)dwRefData || *(_QWORD *)(dwRefData + 8) )
    RemoveWindowSubclass(*(HWND *)(dwRefData + 32), (SUBCLASSPROC)sub_1400D28E0, 1ui64);
  if ( v13 < 1 || v13 > 1000 )
  {
    (*(void (__fastcall **)(__int64, _QWORD, DWORD_PTR, BOOL))(*(_QWORD *)a2 + 16i64))(
      a2,
      *(_QWORD *)(dwRefData + 56),
      dwRefData + 64,
      v13);
  }
  else
  {
    v14 = v13 - 1;
    if ( (*(int (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(dwRefData + 24) + 40i64))(
           *(_QWORD *)(dwRefData + 24),
           v14,
           4i64) < 0
      || !(*(unsigned int (__fastcall **)(__int64, _QWORD, DWORD_PTR, __int64, char *))(*(_QWORD *)a2 + 8i64))(
            a2,
            *(_QWORD *)(dwRefData + 56),
            dwRefData + 64,
            a5,
            v20) )
    {
      v15 = *(_QWORD *)(dwRefData + 32);
      v16 = *(_QWORD *)(dwRefData + 24);
      v18[0] = 56i64;
      v18[1] = v15;
      v18[3] = 0i64;
      v18[4] = 0i64;
      v19 = 5;
      v18[2] = (unsigned __int8)v14;
      (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v16 + 32i64))(v16, v18);
    }
  }
  DestroyMenu(v12);
  return 0i64;
}
// 1400D2910: using guessed type char var_C8[128];

//----- (00000001400D2B60) ----------------------------------------------------
__int64 __fastcall sub_1400D2B60(HWND a1, __int64 a2, LPITEMIDLIST *a3)
{
  unsigned int v6; // ebx
  bool v7; // cf
  ITEMIDLIST *v8; // rax
  struct _browseinfoW bi; // [rsp+20h] [rbp-278h] BYREF
  char v11; // [rsp+60h] [rbp-238h] BYREF

  CoInitializeEx(0i64, 2u);
  bi.hwndOwner = a1;
  v6 = 0;
  v7 = *(_QWORD *)(a2 + 24) < 8ui64;
  bi.pszDisplayName = (LPWSTR)&v11;
  bi.pidlRoot = 0i64;
  if ( v7 )
    bi.lpszTitle = (LPCWSTR)a2;
  else
    bi.lpszTitle = *(LPCWSTR *)a2;
  bi.ulFlags = 64;
  bi.lpfn = 0i64;
  v8 = SHBrowseForFolderW(&bi);
  *a3 = v8;
  LOBYTE(v6) = v8 != 0i64;
  CoUninitialize();
  return v6;
}

//----- (00000001400D2C10) ----------------------------------------------------
__int64 __fastcall sub_1400D2C10(__int64 a1, unsigned int a2, __int64 a3, _WORD *a4, __int64 a5)
{
  unsigned int v10; // ebx
  LPVOID ppv; // [rsp+30h] [rbp-258h] BYREF
  __int64 v12; // [rsp+38h] [rbp-250h] BYREF
  char v13[528]; // [rsp+40h] [rbp-248h] BYREF

  if ( (*(_DWORD *)(a5 + 12) & 0x10000) == 0 )
    return 2147500037i64;
  ppv = 0i64;
  v10 = CoCreateInstance(&stru_1400E40A0, 0i64, 1u, &stru_1400E3FE0, &ppv);
  if ( !v10 )
  {
    v12 = 0i64;
    v10 = (**(__int64 (__fastcall ***)(LPVOID, void *, __int64 *))ppv)(ppv, &unk_1400E4190, &v12);
    if ( !v10 )
    {
      v10 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v12 + 40i64))(v12, a3, 0i64);
      if ( !v10 )
      {
        (*(void (__fastcall **)(LPVOID, __int64, _QWORD))(*(_QWORD *)ppv + 152i64))(ppv, a1, a2);
        (*(void (__fastcall **)(LPVOID, char *, __int64, _QWORD, int))(*(_QWORD *)ppv + 24i64))(
          ppv,
          v13,
          260i64,
          0i64,
          2);
        sub_140001240(a4, 0x104ui64, (__int64)v13);
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16i64))(v12);
    }
    (*(void (__fastcall **)(LPVOID))(*(_QWORD *)ppv + 16i64))(ppv);
  }
  return v10;
}

//----- (00000001400D2D60) ----------------------------------------------------
__int64 __fastcall sub_1400D2D60(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v6; // rdx
  __int64 (__fastcall ***v8)(_QWORD, void *, __int64 *); // rcx
  int v9; // edi
  __int64 v11; // [rsp+30h] [rbp+8h] BYREF

  v6 = a1;
  if ( a1[3] >= 8ui64 )
    v6 = (_QWORD *)*a1;
  (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)*a4 + 160i64))(*a4, v6);
  if ( a3[3] >= 8ui64 )
    a3 = (_QWORD *)*a3;
  (*(void (__fastcall **)(_QWORD, _QWORD *))(*(_QWORD *)*a4 + 56i64))(*a4, a3);
  v8 = (__int64 (__fastcall ***)(_QWORD, void *, __int64 *))*a4;
  v11 = 0i64;
  v9 = (**v8)(v8, &unk_1400E4190, &v11);
  if ( v9 >= 0 )
  {
    if ( a2[3] >= 8ui64 )
      a2 = (_QWORD *)*a2;
    (*(void (__fastcall **)(__int64, _QWORD *, __int64))(*(_QWORD *)v11 + 48i64))(v11, a2, 1i64);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 16i64))(v11);
  }
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*a4 + 16i64))(*a4);
  return (unsigned int)v9;
}

//----- (00000001400D2E20) ----------------------------------------------------
__int64 __fastcall sub_1400D2E20(const WCHAR *a1, char *a2)
{
  int v4; // ebp
  __int64 result; // rax
  int v6; // eax
  __int64 v7; // rbx
  const wchar_t *v8; // r8
  HANDLE i; // rax
  int v10; // eax
  const wchar_t *v11; // r8
  signed __int64 v12; // rcx
  __int16 v13; // ax
  __int64 v14; // [rsp+20h] [rbp-20288h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+30h] [rbp-20278h] BYREF
  __int16 v16[32768]; // [rsp+280h] [rbp-20028h] BYREF
  WCHAR FileName[32768]; // [rsp+10280h] [rbp-10028h] BYREF

  v4 = 2;
  if ( !a1 )
    return 2147942487i64;
  v6 = lstrlenW(a1);
  v7 = 0x8000i64;
  v8 = L"%sNew Folder";
  if ( a1[v6 - 1] != 92 )
    v8 = L"%s\\New Folder";
  sub_140001000((wchar_t *)v16, 0x8000ui64, v8, a1);
  sub_140001000(FileName, 0x8000ui64, L"\\\\?\\%s", v16);
  for ( i = FindFirstFileW(FileName, &FindFileData); i != (HANDLE)-1i64; i = FindFirstFileW(FileName, &FindFileData) )
  {
    FindClose(i);
    v10 = lstrlenW(a1);
    LODWORD(v14) = v4;
    v11 = L"%sNew Folder (%d)";
    if ( a1[v10 - 1] != 92 )
      v11 = L"%s\\New Folder (%d)";
    sub_140001000((wchar_t *)v16, 0x8000ui64, v11, a1, v14);
    sub_140001000(FileName, 0x8000ui64, L"\\\\?\\%s", v16);
    ++v4;
  }
  if ( !CreateDirectoryW(FileName, 0i64) )
    return 2147500037i64;
  v12 = (char *)v16 - a2;
  while ( v7 != -2147450878 )
  {
    v13 = *(_WORD *)&a2[v12];
    if ( !v13 )
      break;
    *(_WORD *)a2 = v13;
    a2 += 2;
    if ( !--v7 )
    {
      a2 -= 2;
      break;
    }
  }
  result = 0i64;
  *(_WORD *)a2 = 0;
  return result;
}
// 1400D2FA6: conditional instruction was optimized away because rbx.8!=0
// 1400D2F10: variable 'v14' is possibly undefined
// 1400EB928: using guessed type wchar_t aSnewFolderD[18];
// 1400EB9F8: using guessed type wchar_t aSNewFolder[14];
// 1400EBA88: using guessed type wchar_t aSnewFolder[13];
// 1400EBAA8: using guessed type wchar_t aS_7[7];
// 1400EBAB8: using guessed type wchar_t aSNewFolderD[19];
// 1400EBAE0: using guessed type wchar_t aS_8[7];
// 1400D2E20: using guessed type wchar_t var_20028[32768];

//----- (00000001400D2FE0) ----------------------------------------------------
__int64 __fastcall sub_1400D2FE0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // r12
  _QWORD *v3; // rdi
  unsigned __int64 v4; // r8
  _QWORD *v5; // rbx
  size_t v6; // rax
  _QWORD *v7; // r13
  WCHAR *v8; // rsi
  WCHAR *v9; // rbp
  unsigned int v10; // ebx
  struct _SHFILEOPSTRUCTW FileOp; // [rsp+20h] [rbp-58h] BYREF

  v2 = a1 + 2;
  v3 = a2;
  v4 = a1[2] + 2i64;
  v5 = a1;
  v6 = 2 * v4;
  if ( !is_mul_ok(v4, 2ui64) )
    v6 = -1i64;
  v7 = a2 + 2;
  v8 = (WCHAR *)operator new(v6);
  v9 = (WCHAR *)operator new(saturated_mul(v3[2] + 2i64, 2ui64));
  if ( v5[3] >= 8ui64 )
    v5 = (_QWORD *)*v5;
  sub_140001240(v8, *v2 + 2i64, (__int64)v5);
  v10 = 0;
  v8[lstrlenW(v8) + 1] = 0;
  if ( v3[3] >= 8ui64 )
    v3 = (_QWORD *)*v3;
  sub_140001240(v9, *v7 + 2i64, (__int64)v3);
  v9[lstrlenW(v9) + 1] = 0;
  FileOp.hwnd = 0i64;
  FileOp.wFunc = 4;
  FileOp.pFrom = v8;
  FileOp.pTo = v9;
  FileOp.fFlags = 64;
  if ( !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted )
    v10 = 1;
  j_j_free(v8);
  j_j_free(v9);
  return v10;
}

//----- (00000001400D3120) ----------------------------------------------------
int __fastcall sub_1400D3120(LPCWSTR lpFileName, int a2)
{
  WCHAR *v3; // rdi
  HANDLE FirstFileW; // rax
  BOOL v5; // ebx
  const WCHAR *v6; // rcx
  void *v7; // rsi
  LARGE_INTEGER v8; // rbx
  int i; // ebp
  int j; // ebp
  int k; // ebp
  char v13; // [rsp+40h] [rbp-298h] BYREF
  char Buffer; // [rsp+41h] [rbp-297h] BYREF
  BYTE pbBuffer[2]; // [rsp+42h] [rbp-296h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+44h] [rbp-294h] BYREF
  HCRYPTPROV phProv; // [rsp+48h] [rbp-290h] BYREF
  LARGE_INTEGER liDistanceToMove; // [rsp+50h] [rbp-288h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+60h] [rbp-278h] BYREF

  v3 = (WCHAR *)lpFileName;
  if ( *((_QWORD *)lpFileName + 3) >= 8ui64 )
    lpFileName = *(LPCWSTR *)lpFileName;
  FirstFileW = FindFirstFileW(lpFileName, &FindFileData);
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    v5 = (FindFileData.dwFileAttributes & 0x10) == 16;
    LODWORD(FirstFileW) = FindClose(FirstFileW);
    if ( !v5 )
    {
      sub_140083440((char *)v3, &liDistanceToMove);
      v6 = *((_QWORD *)v3 + 3) < 8ui64 ? v3 : *(const WCHAR **)v3;
      FirstFileW = CreateFileW(v6, 2u, 0, 0i64, 3u, 0, 0i64);
      v7 = FirstFileW;
      if ( FirstFileW != (HANDLE)-1i64 )
      {
        v8 = liDistanceToMove;
        SetFilePointerEx(FirstFileW, liDistanceToMove, 0i64, 0);
        SetEndOfFile(v7);
        SetFilePointer(v7, 0, 0i64, 0);
        Buffer = 0;
        for ( i = 0; i < v8.QuadPart; ++i )
          WriteFile(v7, &Buffer, 1u, &NumberOfBytesWritten, 0i64);
        if ( a2 == 2 )
        {
          SetFilePointer(v7, 0, 0i64, 0);
          v13 = -1;
          for ( j = 0; j < v8.QuadPart; ++j )
            WriteFile(v7, &v13, 1u, &NumberOfBytesWritten, 0i64);
          SetFilePointer(v7, 0, 0i64, 0);
          CryptAcquireContextW(&phProv, L"SecureDelete", 0i64, 0x18u, 8u);
          for ( k = 0; k < v8.QuadPart; ++k )
          {
            CryptGenRandom(phProv, 1u, pbBuffer);
            WriteFile(v7, pbBuffer, 1u, &NumberOfBytesWritten, 0i64);
          }
          CryptAcquireContextW(&phProv, L"SecureDelete", 0i64, 0x18u, 0x10u);
        }
        FlushFileBuffers(v7);
        CloseHandle(v7);
        if ( *((_QWORD *)v3 + 3) >= 8ui64 )
          v3 = *(WCHAR **)v3;
        LODWORD(FirstFileW) = DeleteFileW(v3);
      }
    }
  }
  return (int)FirstFileW;
}

//----- (00000001400D33C0) ----------------------------------------------------
_WORD *__fastcall sub_1400D33C0(_QWORD **a1)
{
  _QWORD *v1; // rdi
  _QWORD *v2; // rbx
  void *v3; // r15
  int v4; // er14
  __int64 v5; // rbp
  char *v6; // rax
  unsigned __int64 v7; // rsi
  void *v8; // r13
  void **v9; // rdx
  _WORD *result; // rax
  void *Block[2]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v12; // [rsp+30h] [rbp-48h]
  unsigned __int64 v13; // [rsp+38h] [rbp-40h]

  v1 = *a1;
  v2 = (_QWORD *)**a1;
  v3 = 0i64;
  v4 = 0;
  if ( v2 != *a1 )
  {
    do
    {
      v13 = 7i64;
      v12 = 0i64;
      LOWORD(Block[0]) = 0;
      sub_140009610(Block, v2 + 2, 0i64, 0xFFFFFFFFFFFFFFFFui64);
      v5 = v12;
      v6 = (char *)realloc(v3, 2 * (v4 + v12) + 2);
      v7 = v13;
      v8 = Block[0];
      v9 = Block;
      if ( v13 >= 8 )
        v9 = (void **)Block[0];
      v3 = v6;
      memmove(&v6[2 * v4], v9, 2 * v5 + 2);
      v4 += v5 + 1;
      if ( v7 >= 8 )
        j_free(v8);
      v2 = (_QWORD *)*v2;
    }
    while ( v2 != v1 );
  }
  result = realloc(v3, 2i64 * (v4 + 1));
  result[v4] = 0;
  return result;
}

//----- (00000001400D3500) ----------------------------------------------------
__int64 __fastcall sub_1400D3500(HWND a1, _QWORD **a2, int a3)
{
  unsigned int v5; // edi
  WCHAR *v6; // rsi
  FILEOP_FLAGS v7; // ax
  struct _SHFILEOPSTRUCTW FileOp; // [rsp+20h] [rbp-48h] BYREF

  v5 = 0;
  v6 = sub_1400D33C0(a2);
  v7 = 0;
  if ( !a3 )
    v7 = 64;
  FileOp.hwnd = a1;
  FileOp.wFunc = 3;
  FileOp.pFrom = v6;
  FileOp.pTo = 0i64;
  FileOp.fFlags = v7;
  memset(&FileOp.fAnyOperationsAborted, 0, 20);
  if ( !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted )
    v5 = 1;
  free(v6);
  return v5;
}

//----- (00000001400D35A0) ----------------------------------------------------
__int64 __fastcall sub_1400D35A0(HWND a1, __int64 a2, void *a3)
{
  unsigned int v6; // ebx
  bool v7; // cf
  ITEMIDLIST *v8; // rsi
  __int64 v9; // rcx
  WCHAR *v10; // rdi
  bool v11; // zf
  struct _browseinfoW bi; // [rsp+20h] [rbp-488h] BYREF
  WCHAR pszPath[264]; // [rsp+60h] [rbp-448h] BYREF
  char v15; // [rsp+270h] [rbp-238h] BYREF

  CoInitializeEx(0i64, 2u);
  v6 = 0;
  v7 = *(_QWORD *)(a2 + 24) < 8ui64;
  bi.hwndOwner = a1;
  bi.pidlRoot = 0i64;
  bi.pszDisplayName = (LPWSTR)&v15;
  if ( v7 )
    bi.lpszTitle = (LPCWSTR)a2;
  else
    bi.lpszTitle = *(LPCWSTR *)a2;
  bi.ulFlags = 64;
  bi.lpfn = 0i64;
  v8 = SHBrowseForFolderW(&bi);
  CoUninitialize();
  LOBYTE(v6) = v8 != 0i64;
  if ( v6 )
  {
    SHGetPathFromIDListW(v8, pszPath);
    v9 = -1i64;
    v10 = pszPath;
    do
    {
      if ( !v9 )
        break;
      v11 = *v10++ == 0;
      --v9;
    }
    while ( !v11 );
    sub_1400099E0(a3, pszPath, -v9 - 2);
    CoTaskMemFree(v8);
  }
  return v6;
}

//----- (00000001400D3AB0) ----------------------------------------------------
__int64 __fastcall sub_1400D3AB0(void **a1, int a2, LPDATAOBJECT *a3)
{
  __int64 **v6; // rax
  HGLOBAL v7; // rbx
  void *v8; // rax
  IDataObject *v9; // rcx
  unsigned int v10; // ebx
  __int64 v12[4]; // [rsp+30h] [rbp-A8h] BYREF
  __int16 v13; // [rsp+50h] [rbp-88h]
  __int64 v14; // [rsp+58h] [rbp-80h]
  int v15; // [rsp+60h] [rbp-78h]
  int v16; // [rsp+64h] [rbp-74h]
  int v17; // [rsp+68h] [rbp-70h]
  __int64 v18[3]; // [rsp+70h] [rbp-68h] BYREF
  int v19; // [rsp+88h] [rbp-50h]
  HGLOBAL v20; // [rsp+90h] [rbp-48h]
  __int64 v21; // [rsp+98h] [rbp-40h]
  __int64 *v22; // [rsp+A0h] [rbp-38h] BYREF
  __int64 v23; // [rsp+F0h] [rbp+18h] BYREF
  void *v24; // [rsp+F8h] [rbp+20h]

  v6 = sub_14000B180(&v22, (_QWORD ***)a1);
  sub_14007FCB0(v12, v18, v6);
  v13 = RegisterClipboardFormatW(L"Preferred DropEffect");
  v14 = 0i64;
  v15 = 1;
  v16 = -1;
  v17 = 1;
  v7 = GlobalAlloc(2u, 4ui64);
  *(_DWORD *)GlobalLock(v7) = (a2 != 0) + 1;
  GlobalUnlock(v7);
  v21 = 0i64;
  v20 = v7;
  v19 = 1;
  v8 = operator new(0x38ui64);
  v24 = v8;
  if ( v8 )
    v9 = (IDataObject *)sub_140078EE0((__int64)v8, v12, v18);
  else
    v9 = 0i64;
  *a3 = v9;
  v23 = 0i64;
  ((void (__fastcall *)(IDataObject *, __int64 *, __int64 *))v9->lpVtbl->QueryInterface)(v9, &qword_1400E4160, &v23);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v23 + 24i64))(v23, 1i64);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v23 + 16i64))(v23);
  v10 = OleSetClipboard(*a3);
  sub_14000A630((__int64)a1);
  j_free(*a1);
  return v10;
}
// 14007FCB0: using guessed type __int64 __fastcall sub_14007FCB0(_QWORD, _QWORD, _QWORD);
// 1400E4160: using guessed type __int64 qword_1400E4160;
// 1400D3AB0: using guessed type __int64 var_68[3];
// 1400D3AB0: using guessed type __int64 var_A8[4];

//----- (00000001400D3C20) ----------------------------------------------------
__int64 __fastcall sub_1400D3C20(void **a1, LPDATAOBJECT *a2)
{
  void **v4; // rax
  __int64 *v6; // [rsp+28h] [rbp-20h] BYREF

  v4 = (void **)sub_14000B180(&v6, (_QWORD ***)a1);
  LODWORD(a2) = sub_1400D3AB0(v4, 1, a2);
  sub_14000A630((__int64)a1);
  j_free(*a1);
  return (unsigned int)a2;
}

//----- (00000001400D3C80) ----------------------------------------------------
__int64 __fastcall sub_1400D3C80(void **a1, LPDATAOBJECT *a2)
{
  void **v4; // rax
  __int64 *v6; // [rsp+28h] [rbp-20h] BYREF

  v4 = (void **)sub_14000B180(&v6, (_QWORD ***)a1);
  LODWORD(a2) = sub_1400D3AB0(v4, 0, a2);
  sub_14000A630((__int64)a1);
  j_free(*a1);
  return (unsigned int)a2;
}

//----- (00000001400D3CE0) ----------------------------------------------------
__int64 __fastcall sub_1400D3CE0(HWND a1, _QWORD *a2, _QWORD **a3, int a4)
{
  unsigned int v7; // ebx
  __int64 v8; // rcx
  _QWORD *v9; // rdi
  bool v10; // zf
  int v11; // edi
  WCHAR *v13; // rdi
  void **v14; // rax
  struct _SHFILEOPSTRUCTW FileOp; // [rsp+20h] [rbp-69h] BYREF
  __int64 v16; // [rsp+58h] [rbp-31h]
  void *v17[3]; // [rsp+60h] [rbp-29h] BYREF
  unsigned __int64 v18; // [rsp+78h] [rbp-11h]
  void *Block[3]; // [rsp+88h] [rbp-1h] BYREF
  unsigned __int64 v20; // [rsp+A0h] [rbp+17h]

  v16 = -2i64;
  v18 = 7i64;
  v7 = 0;
  v17[2] = 0i64;
  LOWORD(v17[0]) = 0;
  if ( a2[3] >= 8ui64 )
    a2 = (_QWORD *)*a2;
  v20 = 7i64;
  Block[2] = 0i64;
  LOWORD(Block[0]) = 0;
  v8 = -1i64;
  v9 = a2;
  do
  {
    if ( !v8 )
      break;
    v10 = *(_WORD *)v9 == 0;
    v9 = (_QWORD *)((char *)v9 + 2);
    --v8;
  }
  while ( !v10 );
  sub_1400099E0(Block, a2, -v8 - 2);
  v11 = sub_1400D35A0(a1, (__int64)Block, v17);
  if ( v20 >= 8 )
    j_free(Block[0]);
  if ( v11 )
  {
    v13 = sub_1400D33C0(a3);
    FileOp.wFunc = 2 - (a4 != 0);
    FileOp.hwnd = a1;
    FileOp.pFrom = v13;
    v14 = v17;
    if ( v18 >= 8 )
      v14 = (void **)v17[0];
    FileOp.pTo = (PCZZWSTR)v14;
    FileOp.fFlags = 64;
    if ( !SHFileOperationW(&FileOp) && !FileOp.fAnyOperationsAborted )
      v7 = 1;
    free(v13);
    if ( v18 >= 8 )
      j_free(v17[0]);
    return v7;
  }
  else
  {
    if ( v18 >= 8 )
      j_free(v17[0]);
    return 0i64;
  }
}

//----- (00000001400D5030) ----------------------------------------------------
void __fastcall sub_1400D5030(__int64 a1)
{
  HMENU Menu; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx
  HMENU v5; // rdi
  UINT v6; // edx
  unsigned int v7; // eax
  UINT v8; // eax
  int v9; // er12
  int MenuItemCount; // er13
  HMENU SubMenu; // rbx
  int v12; // eax
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // r12
  _DWORD *dwItemData; // rax
  _DWORD *v16; // rax
  _DWORD *v17; // rax
  _DWORD *v18; // rax
  _DWORD *v19; // rax
  _DWORD *v20; // rax
  _DWORD *v21; // rax
  _DWORD *v22; // rax
  _DWORD *v23; // rax
  _DWORD *v24; // rax
  _DWORD *v25; // rax
  _DWORD *v26; // rax
  _DWORD *v27; // rax
  _DWORD *v28; // rax
  _DWORD *v29; // rax
  _DWORD *v30; // rax
  _DWORD *v31; // rax
  _DWORD *v32; // rax
  _DWORD *v33; // rax
  _DWORD *v34; // rax
  _DWORD *v35; // rax
  _DWORD *v36; // rax
  _DWORD *v37; // rax
  _DWORD *v38; // rax
  _DWORD *v39; // rax
  HMENU v40; // rbx
  int v41; // eax
  HMENU v42; // rcx
  _DWORD *v43; // rax
  HMENU v44; // rcx
  _DWORD *v45; // rax
  HMENU v46; // rbx
  int v47; // eax
  HMENU v48; // rbx
  int v49; // eax
  HMENU v50; // rcx
  _DWORD *v51; // rax
  HMENU v52; // rcx
  _DWORD *v53; // rax
  HMENU v54; // rbx
  int v55; // eax
  HMENU v56; // rcx
  _DWORD *v57; // rax
  HMENU v58; // rcx
  _DWORD *v59; // rax
  HMENU v60; // rbx
  int v61; // eax
  HMENU v62; // rbx
  int v63; // eax
  _QWORD *v64; // rax
  __int64 v65; // rcx
  HMENU v66; // rbx
  int v67; // eax
  HMENU v68; // rbx
  int v69; // eax
  struct tagMENUITEMINFOW mii; // [rsp+30h] [rbp-D0h] BYREF
  MENUITEMINFOW mi; // [rsp+80h] [rbp-80h] BYREF
  WCHAR Buffer[64]; // [rsp+D0h] [rbp-30h] BYREF

  Menu = GetMenu(*(HWND *)(a1 + 104));
  v3 = *(_QWORD **)(a1 + 7072);
  v4 = (_QWORD *)*v3;
  v5 = Menu;
  if ( (_QWORD *)*v3 != v3 )
  {
    do
    {
      switch ( *((_DWORD *)v4 + 4) )
      {
        case 1:
          v7 = *(_DWORD *)(a1 + 7004);
          if ( v7 < 6 )
          {
            if ( v7 < 5 )
              goto LABEL_14;
            v6 = 2047;
          }
          else
          {
            v6 = 2046;
          }
          break;
        case 2:
          v6 = 2048;
          break;
        case 3:
          v6 = 2088;
          break;
        case 4:
          v6 = 2089;
          break;
        case 5:
          v6 = 2091;
          break;
        case 6:
          v6 = 2090;
          break;
        case 7:
          v6 = 2044;
          break;
        case 8:
          v6 = 2045;
          break;
        default:
LABEL_14:
          v6 = -1;
          break;
      }
      LoadStringW(hInstance, v6, Buffer, 64);
      mi.cbSize = 80;
      mi.fMask = 66;
      switch ( *((_DWORD *)v4 + 4) )
      {
        case 1:
          v8 = 60002;
          break;
        case 2:
          v8 = 60003;
          break;
        case 3:
          v8 = 60004;
          break;
        case 4:
          v8 = 60005;
          break;
        case 5:
          v8 = 60001;
          break;
        case 6:
          v8 = 60000;
          break;
        case 7:
          v8 = 60008;
          break;
        case 8:
          v8 = 60007;
          break;
        default:
          v8 = -1;
          break;
      }
      mi.wID = v8;
      mi.dwTypeData = Buffer;
      InsertMenuItemW(v5, 0x9DD8u, 0, &mi);
      InsertMenuItemW(*(HMENU *)(a1 + 4912), 0x9DD8u, 0, &mi);
      v4 = (_QWORD *)*v4;
    }
    while ( v4 != *(_QWORD **)(a1 + 7072) );
  }
  DeleteMenu(v5, 0x9DD8u, 0);
  DeleteMenu(*(HMENU *)(a1 + 4912), 0x9DD8u, 0);
  v9 = 0;
  MenuItemCount = GetMenuItemCount(v5);
  if ( MenuItemCount > 0 )
  {
    do
    {
      SubMenu = GetSubMenu(v5, v9);
      v12 = GetMenuItemCount(SubMenu);
      sub_1400B08E0(a1, SubMenu, v12);
      ++v9;
    }
    while ( v9 < MenuItemCount );
  }
  himl = (HIMAGELIST)sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 48);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0((__int64)himl, (__int64)BitmapW, 0i64);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C78u, 0, &mii) )
  {
    dwItemData = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *dwItemData = 15;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C7Bu, 0, &mii) )
  {
    v16 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v16 = 18;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C7Fu, 0, &mii) )
  {
    v17 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v17 = 5;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9CD1u, 0, &mii) )
  {
    v18 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v18 = 31;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C80u, 0, &mii) )
  {
    v19 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v19 = 24;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C81u, 0, &mii) )
  {
    v20 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v20 = 6;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9D85u, 0, &mii) )
  {
    v21 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v21 = 27;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C85u, 0, &mii) )
  {
    v22 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v22 = 3;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C83u, 0, &mii) )
  {
    v23 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v23 = 2;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C86u, 0, &mii) )
  {
    v24 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v24 = 4;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C87u, 0, &mii) )
  {
    v25 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v25 = 30;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C88u, 0, &mii) )
  {
    v26 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v26 = 11;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C89u, 0, &mii) )
  {
    v27 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v27 = 10;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9D47u, 0, &mii) )
  {
    v28 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v28 = 9;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9CA9u, 0, &mii) )
  {
    v29 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v29 = 12;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9D26u, 0, &mii) )
  {
    v30 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v30 = 26;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C9Du, 0, &mii) )
  {
    v31 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v31 = 0;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C9Eu, 0, &mii) )
  {
    v32 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v32 = 1;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9C9Fu, 0, &mii) )
  {
    v33 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v33 = 8;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9CEEu, 0, &mii) )
  {
    v34 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v34 = 19;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9D05u, 0, &mii) )
  {
    v35 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v35 = 20;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9DE1u, 0, &mii) )
  {
    v36 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v36 = 17;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9DDBu, 0, &mii) )
  {
    v37 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v37 = 23;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9CA5u, 0, &mii) )
  {
    v38 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v38 = 25;
  }
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v5, 0x9CA6u, 0, &mii) )
  {
    v39 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v39 = 16;
  }
  v40 = *(HMENU *)(a1 + 4872);
  v41 = GetMenuItemCount(v40);
  sub_1400B08E0(a1, v40, v41);
  v42 = *(HMENU *)(a1 + 4872);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v42, 0x9C78u, 0, &mii) )
  {
    v43 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v43 = 15;
  }
  v44 = *(HMENU *)(a1 + 4872);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v44, 0x9D3Au, 0, &mii) )
  {
    v45 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v45 = 12;
  }
  v46 = *(HMENU *)(a1 + 4880);
  v47 = GetMenuItemCount(v46);
  sub_1400B08E0(a1, v46, v47);
  v48 = *(HMENU *)(a1 + 4888);
  v49 = GetMenuItemCount(v48);
  sub_1400B08E0(a1, v48, v49);
  v50 = *(HMENU *)(a1 + 4888);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v50, 0x9D94u, 0, &mii) )
  {
    v51 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v51 = 5;
  }
  v52 = *(HMENU *)(a1 + 4888);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v52, 0x9D95u, 0, &mii) )
  {
    v53 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v53 = 6;
  }
  v54 = *(HMENU *)(a1 + 4896);
  v55 = GetMenuItemCount(v54);
  sub_1400B08E0(a1, v54, v55);
  v56 = *(HMENU *)(a1 + 4896);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v56, 0x9DA9u, 0, &mii) )
  {
    v57 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v57 = 5;
  }
  v58 = *(HMENU *)(a1 + 4896);
  mii.cbSize = 80;
  mii.fMask = 32;
  if ( GetMenuItemInfoW(v58, 0x9DAAu, 0, &mii) )
  {
    v59 = (_DWORD *)mii.dwItemData;
    *(_DWORD *)(mii.dwItemData + 4) = 1;
    *v59 = 6;
  }
  v60 = *(HMENU *)(a1 + 4904);
  v61 = GetMenuItemCount(v60);
  sub_1400B08E0(a1, v60, v61);
  v62 = *(HMENU *)(a1 + 4912);
  v63 = GetMenuItemCount(v62);
  sub_1400B08E0(a1, v62, v63);
  v64 = operator new(0x18ui64);
  if ( v64 )
  {
    v65 = *(_QWORD *)(a1 + 104);
    v64[1] = v5;
    *v64 = v65;
    v64[2] = himl;
  }
  *(_QWORD *)(a1 + 4760) = v64;
  sub_1400AF530(v5, 0x9CA0u, 17);
  sub_1400AF530(v5, 0x9CA1u, 5);
  sub_1400AF530(v5, 0x9CA2u, 13);
  sub_1400AF530(v5, 0x9CA3u, 39);
  sub_1400AF530(v5, 0x9CD3u, 0);
  sub_1400AF530(v5, 0x9D0Eu, 10);
  sub_1400AF530(v5, 0x9D11u, 3);
  sub_1400AF530(v5, 0x9D12u, 4);
  sub_1400AF530(v5, 0x9D14u, 59);
  sub_1400AF530(v5, 0x9D17u, 18);
  sub_1400AF530(v5, 0x9D28u, 49);
  DeleteObject(BitmapW);
  v66 = *(HMENU *)(a1 + 4832);
  v67 = GetMenuItemCount(v66);
  sub_1400B08E0(a1, v66, v67);
  v68 = *(HMENU *)(a1 + 4840);
  v69 = GetMenuItemCount(v68);
  sub_1400B08E0(a1, v68, v69);
}

//----- (00000001400D5C30) ----------------------------------------------------
HWND __fastcall sub_1400D5C30(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HANDLE ImageW; // rax
  HWND v4; // rbx
  HMODULE v5; // rax
  HWND result; // rax
  int v7[4]; // [rsp+50h] [rbp-28h] BYREF
  __int64 v8; // [rsp+60h] [rbp-18h]
  HANDLE v9; // [rsp+68h] [rbp-10h]

  v7[0] = *(_DWORD *)(a1 + 7100);
  v7[1] = *(_DWORD *)(a1 + 7104);
  v7[2] = *(_DWORD *)(a1 + 7108);
  v8 = *(_QWORD *)(a1 + 7112);
  ModuleHandleW = GetModuleHandleW(0i64);
  ImageW = LoadImageW(ModuleHandleW, (LPCWSTR)0x6A, 1u, 0, 0, 0x2000u);
  v4 = *(HWND *)(a1 + 104);
  v9 = ImageW;
  sub_14001CE90();
  v5 = GetModuleHandleW(0i64);
  result = sub_14001A730(L"DisplayWindow", &word_1400F7CF8, 0x54000000u, 0, 0, 0, 0, v4, v5, v7);
  *(_QWORD *)(a1 + 2632) = 0i64;
  *(_QWORD *)(a1 + 128) = result;
  return result;
}

//----- (00000001400D5D10) ----------------------------------------------------
void __fastcall sub_1400D5D10(__int64 a1)
{
  HMENU Menu; // rax

  Menu = GetMenu(*(HWND *)(a1 + 104));
  GetSubMenu(Menu, 6);
  memset((void *)(a1 + 61664), 0, 0x190ui64);
  sub_1400CB360(a1);
  sub_1400CB930(a1);
}

//----- (00000001400D5D60) ----------------------------------------------------
void __fastcall sub_1400D5D60(__int64 a1)
{
  __int64 v2; // rcx
  WCHAR *v3; // rdi
  bool v4; // zf
  __int64 v5; // rcx
  WCHAR *v6; // rdi
  void *Src[3]; // [rsp+38h] [rbp-D0h] BYREF
  unsigned __int64 v8; // [rsp+50h] [rbp-B8h]
  void *Block; // [rsp+60h] [rbp-A8h]
  __int64 v10; // [rsp+70h] [rbp-98h]
  unsigned __int64 v11; // [rsp+78h] [rbp-90h]
  int v12; // [rsp+88h] [rbp-80h]
  int v13; // [rsp+8Ch] [rbp-7Ch]
  WCHAR Buffer[64]; // [rsp+98h] [rbp-70h] BYREF

  v8 = 7i64;
  Src[2] = 0i64;
  LOWORD(Src[0]) = 0;
  v11 = 7i64;
  v10 = 0i64;
  LOWORD(Block) = 0;
  LoadStringW(hInstance, 0x86Bu, Buffer, 64);
  v2 = -1i64;
  v3 = Buffer;
  do
  {
    if ( !v2 )
      break;
    v4 = *v3++ == 0;
    --v2;
  }
  while ( !v4 );
  sub_1400099E0(Src, Buffer, -v2 - 2);
  v13 = 16711680;
  v12 = 2048;
  sub_140009DD0((unsigned __int64 *)(a1 + 72), (unsigned __int64)Src);
  LoadStringW(hInstance, 0x86Cu, Buffer, 64);
  v5 = -1i64;
  v6 = Buffer;
  do
  {
    if ( !v5 )
      break;
    v4 = *v6++ == 0;
    --v5;
  }
  while ( !v4 );
  sub_1400099E0(Src, Buffer, -v5 - 2);
  v13 = 0x8000;
  v12 = 0x4000;
  sub_140009DD0((unsigned __int64 *)(a1 + 72), (unsigned __int64)Src);
  if ( v11 >= 8 )
    j_free(Block);
  v11 = 7i64;
  v10 = 0i64;
  LOWORD(Block) = 0;
  if ( v8 >= 8 )
    j_free(Src[0]);
}

//----- (00000001400D5ED0) ----------------------------------------------------
BOOL __fastcall sub_1400D5ED0(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  HWND v5; // rdi
  int v6; // ebx
  __int64 v7; // rcx
  _DWORD *v8; // rax
  int v9; // ecx
  int v10; // eax
  HWND v11; // rcx
  LPARAM lParam[64]; // [rsp+20h] [rbp-868h] BYREF
  __int64 v14[128]; // [rsp+220h] [rbp-668h] BYREF
  int v15; // [rsp+620h] [rbp-268h]
  int v16; // [rsp+624h] [rbp-264h]
  __int64 v17; // [rsp+830h] [rbp-58h]
  LPARAM v18; // [rsp+840h] [rbp-48h] BYREF
  __int16 v19; // [rsp+848h] [rbp-40h]
  __int64 v20; // [rsp+850h] [rbp-38h]
  LPARAM *v21; // [rsp+858h] [rbp-30h]

  DlgItem = GetDlgItem(a2, 1177);
  v5 = GetDlgItem(a2, 1178);
  SendMessageW(DlgItem, 0xDu, 0x100ui64, (LPARAM)lParam);
  SendMessageW(v5, 0xDu, 0x200ui64, (LPARAM)v14);
  v6 = 0;
  v15 = IsDlgButtonChecked(a2, 1182) == 1;
  sub_14007D5F0(qword_14012D740, (__int64)lParam);
  if ( v15 != dword_14012D738 )
  {
    if ( v15 )
    {
      v7 = 0i64;
      v8 = (_DWORD *)(a1 + 61664);
      while ( *v8 )
      {
        ++v7;
        ++v6;
        ++v8;
        if ( v7 >= 100 )
        {
          v9 = -1;
          goto LABEL_8;
        }
      }
      v9 = v6 + 46000;
      *(_DWORD *)(a1 + 4i64 * v6 + 61664) = 1;
LABEL_8:
      v10 = 20;
      if ( !v16 )
        v10 = 15;
      HIDWORD(v18) = v9;
      v11 = *(HWND *)(a1 + 1008);
      LODWORD(v18) = v10;
      v20 = (unsigned int)v17;
      v19 = 28676;
      v21 = lParam;
      SendMessageW(v11, 0x444u, 1ui64, (LPARAM)&v18);
      sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1008));
    }
    else
    {
      sub_1400CA550(a1, v17);
    }
  }
  return EndDialog(a2, 1i64);
}
// 14012D738: using guessed type int dword_14012D738;
// 14012D740: using guessed type __int64 qword_14012D740;
// 1400D5ED0: using guessed type LPARAM var_668[128];

//----- (00000001400D60A0) ----------------------------------------------------
BOOL __fastcall sub_1400D60A0(__int64 a1, HWND a2)
{
  HWND DlgItem; // rbx
  HWND v5; // rdi
  HWND v6; // rsi
  int v7; // ebx
  __int64 v8; // rcx
  _DWORD *v9; // rax
  int v10; // ecx
  int v11; // eax
  HWND v12; // rcx
  LPARAM lParam[64]; // [rsp+20h] [rbp-868h] BYREF
  __int64 v15[128]; // [rsp+220h] [rbp-668h] BYREF
  int v16; // [rsp+620h] [rbp-268h]
  int v17; // [rsp+624h] [rbp-264h]
  __int64 v18[65]; // [rsp+628h] [rbp-260h] BYREF
  __int64 v19; // [rsp+830h] [rbp-58h]
  LPARAM v20; // [rsp+840h] [rbp-48h] BYREF
  __int16 v21; // [rsp+848h] [rbp-40h]
  __int64 v22; // [rsp+850h] [rbp-38h]
  LPARAM *v23; // [rsp+858h] [rbp-30h]

  DlgItem = GetDlgItem(a2, 1131);
  v5 = GetDlgItem(a2, 1132);
  v6 = GetDlgItem(a2, 1133);
  SendMessageW(DlgItem, 0xDu, 0x100ui64, (LPARAM)lParam);
  SendMessageW(v5, 0xDu, 0x104ui64, (LPARAM)v18);
  SendMessageW(v6, 0xDu, 0x200ui64, (LPARAM)v15);
  v7 = 0;
  v16 = IsDlgButtonChecked(a2, 1181) == 1;
  sub_14007D5F0(qword_14012D740, (__int64)lParam);
  if ( v16 == dword_14012D738 )
  {
    if ( v16 )
      sub_1400CA7E0(a1, (__int64)lParam);
  }
  else if ( v16 )
  {
    v8 = 0i64;
    v9 = (_DWORD *)(a1 + 61664);
    while ( *v9 )
    {
      ++v8;
      ++v7;
      ++v9;
      if ( v8 >= 100 )
      {
        v10 = -1;
        goto LABEL_8;
      }
    }
    v10 = v7 + 46000;
    *(_DWORD *)(a1 + 4i64 * v7 + 61664) = 1;
LABEL_8:
    v11 = 20;
    if ( !v17 )
      v11 = 15;
    HIDWORD(v20) = v10;
    v12 = *(HWND *)(a1 + 1008);
    LODWORD(v20) = v11;
    v22 = (unsigned int)v19;
    v21 = 28676;
    v23 = lParam;
    SendMessageW(v12, 0x444u, 1ui64, (LPARAM)&v20);
    sub_140080090(*(HWND *)(a1 + 120), *(HWND *)(a1 + 1008));
  }
  else
  {
    sub_1400CA550(a1, v19);
  }
  return EndDialog(a2, 1i64);
}
// 14012D738: using guessed type int dword_14012D738;
// 14012D740: using guessed type __int64 qword_14012D740;
// 1400D60A0: using guessed type LPARAM var_260[65];
// 1400D60A0: using guessed type LPARAM var_668[128];

//----- (00000001400D62B0) ----------------------------------------------------
LRESULT __fastcall sub_1400D62B0(HWND hDlg, __int64 a2)
{
  HWND DlgItem; // rdi
  HWND v4; // rbx
  WCHAR String[256]; // [rsp+20h] [rbp-838h] BYREF
  __int16 v7[512]; // [rsp+220h] [rbp-638h] BYREF
  int v8; // [rsp+620h] [rbp-238h]
  __int64 v9; // [rsp+830h] [rbp-28h]

  sub_14007D720(*(_QWORD *)(a2 + 8), (__int64)String);
  qword_14012D740 = v9;
  dword_14012D738 = v8;
  DlgItem = GetDlgItem(hDlg, 1177);
  v4 = GetDlgItem(hDlg, 1178);
  SetWindowTextW(DlgItem, String);
  SetWindowTextW(v4, (LPCWSTR)v7);
  if ( v8 )
    CheckDlgButton(hDlg, 1182, 1u);
  SetFocus(DlgItem);
  return SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
}
// 14012D738: using guessed type int dword_14012D738;
// 14012D740: using guessed type __int64 qword_14012D740;
// 1400D62B0: using guessed type WCHAR var_638[512];

//----- (00000001400D63B0) ----------------------------------------------------
__int64 __fastcall sub_1400D63B0(HWND a1, int a2, __int16 a3, __int64 a4)
{
  int v4; // edx
  int v5; // edx

  v4 = a2 - 16;
  if ( !v4 )
    goto LABEL_6;
  v5 = v4 - 256;
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_6:
        EndDialog(a1, 0i64);
      return 0i64;
    }
    sub_1400D5ED0(qword_14012E108, a1);
    return 0i64;
  }
  else
  {
    sub_1400D62B0(a1, a4);
    return 0i64;
  }
}
// 14012E108: using guessed type __int64 qword_14012E108;

//----- (00000001400D6410) ----------------------------------------------------
__int64 __fastcall sub_1400D6410(HWND hDlg, int a2, __int16 a3, __int64 *a4)
{
  __int64 v4; // r11
  int v5; // edx
  int v6; // edx

  if ( a2 == 272 )
  {
    v4 = *a4;
    qword_14012E108 = *a4;
  }
  else
  {
    v4 = qword_14012E108;
  }
  v5 = a2 - 16;
  if ( !v5 )
    goto LABEL_9;
  v6 = v5 - 256;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_9:
        EndDialog(hDlg, 0i64);
      return 0i64;
    }
    sub_1400D5ED0(v4, hDlg);
    return 0i64;
  }
  else
  {
    sub_1400D62B0(hDlg, (__int64)a4);
    return 0i64;
  }
}
// 14012E108: using guessed type __int64 qword_14012E108;

//----- (00000001400D6490) ----------------------------------------------------
LRESULT __fastcall sub_1400D6490(HWND hDlg, __int64 a2)
{
  HWND DlgItem; // rsi
  HWND v4; // rdi
  HWND v5; // rbx
  WCHAR String[256]; // [rsp+20h] [rbp-848h] BYREF
  __int16 v8[512]; // [rsp+220h] [rbp-648h] BYREF
  int v9; // [rsp+620h] [rbp-248h]
  __int16 v10[260]; // [rsp+628h] [rbp-240h] BYREF
  __int64 v11; // [rsp+830h] [rbp-38h]

  sub_14007D720(*(_QWORD *)(a2 + 8), (__int64)String);
  qword_14012D740 = v11;
  dword_14012D738 = v9;
  DlgItem = GetDlgItem(hDlg, 1131);
  v4 = GetDlgItem(hDlg, 1132);
  v5 = GetDlgItem(hDlg, 1133);
  SetWindowTextW(DlgItem, String);
  SetWindowTextW(v4, (LPCWSTR)v10);
  SetWindowTextW(v5, (LPCWSTR)v8);
  if ( v9 )
    CheckDlgButton(hDlg, 1181, 1u);
  SetFocus(DlgItem);
  return SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
}
// 14012D738: using guessed type int dword_14012D738;
// 14012D740: using guessed type __int64 qword_14012D740;
// 1400D6490: using guessed type WCHAR var_240[260];
// 1400D6490: using guessed type WCHAR var_648[512];

//----- (00000001400D65B0) ----------------------------------------------------
__int64 __fastcall sub_1400D65B0(HWND a1, int a2, __int16 a3, __int64 a4)
{
  int v4; // edx
  int v5; // edx

  v4 = a2 - 16;
  if ( !v4 )
    goto LABEL_6;
  v5 = v4 - 256;
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_6:
        EndDialog(a1, 0i64);
      return 0i64;
    }
    sub_1400D60A0(qword_14012E100, a1);
    return 0i64;
  }
  else
  {
    sub_1400D6490(a1, a4);
    return 0i64;
  }
}
// 14012E100: using guessed type __int64 qword_14012E100;

//----- (00000001400D6610) ----------------------------------------------------
__int64 __fastcall sub_1400D6610(HWND hDlg, int a2, __int16 a3, __int64 *a4)
{
  __int64 v4; // r11
  int v5; // edx
  int v6; // edx

  if ( a2 == 272 )
  {
    v4 = *a4;
    qword_14012E100 = *a4;
  }
  else
  {
    v4 = qword_14012E100;
  }
  v5 = a2 - 16;
  if ( !v5 )
    goto LABEL_9;
  v6 = v5 - 256;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_9:
        EndDialog(hDlg, 0i64);
      return 0i64;
    }
    sub_1400D60A0(v4, hDlg);
    return 0i64;
  }
  else
  {
    sub_1400D6490(hDlg, (__int64)a4);
    return 0i64;
  }
}
// 14012E100: using guessed type __int64 qword_14012E100;

//----- (00000001400D6690) ----------------------------------------------------
void __fastcall sub_1400D6690(__int64 a1)
{
  void *pv[2]; // [rsp+20h] [rbp-658h] BYREF
  char v3[528]; // [rsp+30h] [rbp-648h] BYREF
  __int16 lParam[264]; // [rsp+240h] [rbp-438h] BYREF
  char v5[528]; // [rsp+450h] [rbp-228h] BYREF

  SendMessageW(*(HWND *)(a1 + 168), 0xDu, 0x104ui64, (LPARAM)lParam);
  (*(void (__fastcall **)(_QWORD, __int64, char *))(**(_QWORD **)(a1 + 2640) + 104i64))(
    *(_QWORD *)(a1 + 2640),
    260i64,
    v3);
  sub_14007F0B0((PCNZWCH)lParam, (__int64)v3, v5);
  pv[0] = 0i64;
  if ( (int)sub_14007F810((__int64)v5, (__int64)pv) >= 0 )
  {
    (*(void (__fastcall **)(__int64, void *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 56) + 64i64))(a1 + 56, pv[0], 0i64, 0i64);
    CoTaskMemFree(pv[0]);
  }
}
// 1400D6690: using guessed type WCHAR lParam[264];
// 1400D6690: using guessed type LPVOID pv[2];

//----- (00000001400D6760) ----------------------------------------------------
__int64 __fastcall sub_1400D6760(__int64 a1, int *a2, int *a3, _QWORD *a4)
{
  int v4; // esi
  __int64 v5; // rbx
  __int64 v6; // r8
  __int64 v7; // rdx
  __int16 *v8; // rcx
  __int16 v9; // ax
  __int16 *v10; // rax
  __int64 v11; // rcx
  __int16 *v12; // rax
  __int64 v13; // r8
  char *v14; // r9
  __int16 v15; // dx
  HANDLE FirstFileW; // rdi
  __int64 v17; // r8
  __int64 v18; // rdx
  WCHAR *v19; // rcx
  WCHAR v20; // ax
  int v22; // [rsp+28h] [rbp-E0h]
  int v23; // [rsp+28h] [rbp-E0h]
  int v24; // [rsp+2Ch] [rbp-DCh] BYREF
  __int64 v25; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v26[2]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v27; // [rsp+48h] [rbp-C0h]
  _QWORD *v28; // [rsp+50h] [rbp-B8h]
  int *v29; // [rsp+58h] [rbp-B0h]
  int *v30; // [rsp+60h] [rbp-A8h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+68h] [rbp-A0h] BYREF
  __int16 FileName[264]; // [rsp+2B8h] [rbp+1B0h] BYREF
  WCHAR pszPath[264]; // [rsp+4C8h] [rbp+3C0h] BYREF

  v28 = a4;
  v30 = a3;
  v29 = a2;
  v27 = a1;
  v4 = 0;
  v22 = 0;
  v24 = 0;
  LODWORD(v25) = 0;
  if ( !a1 || !a2 || !a3 || !a4 )
    return 2147942487i64;
  v5 = 0i64;
  v26[0] = 0i64;
  v6 = a1 - (_QWORD)FileName;
  v7 = 262i64;
  v8 = FileName;
  while ( v7 != -2147483384 )
  {
    v9 = *(__int16 *)((char *)v8 + v6);
    if ( !v9 )
      break;
    *v8++ = v9;
    if ( !--v7 )
    {
      --v8;
      break;
    }
  }
  *v8 = 0;
  v10 = FileName;
  v11 = 262i64;
  while ( *v10 )
  {
    ++v10;
    if ( !--v11 )
      goto LABEL_20;
  }
  v12 = &FileName[262 - v11];
  v13 = 0x7FFFFFFFi64;
  v14 = (char *)((char *)L"\\*" - (char *)v12);
  while ( v13 )
  {
    v15 = *(__int16 *)((char *)v12 + (_QWORD)v14);
    if ( !v15 )
      break;
    *v12++ = v15;
    --v13;
    if ( !--v11 )
    {
      --v12;
      break;
    }
  }
  *v12 = 0;
LABEL_20:
  FirstFileW = FindFirstFileW((LPCWSTR)FileName, &FindFileData);
  if ( FirstFileW != (HANDLE)-1i64 )
  {
    if ( StrCmpW(FindFileData.cFileName, L".") )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        v22 = 1;
      else
        v4 = 1;
    }
    while ( FindNextFileW(FirstFileW, &FindFileData) )
    {
      if ( StrCmpW(FindFileData.cFileName, L"..") )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          v23 = v22 + 1;
          v17 = v27 - (_QWORD)pszPath;
          v18 = 262i64;
          v19 = pszPath;
          while ( v18 != -2147483384 )
          {
            v20 = *(WCHAR *)((char *)v19 + v17);
            if ( !v20 )
              break;
            *v19++ = v20;
            if ( !--v18 )
            {
              --v19;
              break;
            }
          }
          *v19 = 0;
          PathAppendW(pszPath, FindFileData.cFileName);
          sub_1400D6760((__int64)pszPath, (int *)&v25, &v24, v26);
          v4 += v24;
          v5 += v26[0];
          v22 = v25 + v23;
        }
        else
        {
          ++v4;
          v26[1] = __PAIR64__(FindFileData.nFileSizeHigh, FindFileData.nFileSizeLow);
          v5 += __PAIR64__(FindFileData.nFileSizeHigh, FindFileData.nFileSizeLow);
        }
      }
    }
    *v29 = v22;
    *v30 = v4;
    *v28 = v5;
    FindClose(FirstFileW);
  }
  return 0i64;
}
// 1400D6827: conditional instruction was optimized away because rdx.8!=0
// 1400D6853: conditional instruction was optimized away because rcx.8!=0
// 1400D686D: conditional instruction was optimized away because rcx.8!=0
// 1400D68A4: conditional instruction was optimized away because rcx.8!=0
// 1400D697A: conditional instruction was optimized away because rdx.8!=0
// 1400EA5C4: using guessed type wchar_t asc_1400EA5C4[3];
// 1400D6760: using guessed type WCHAR FileName[264];

//----- (00000001400D6A50) ----------------------------------------------------
__int64 __fastcall sub_1400D6A50(LPVOID lpThreadParameter)
{
  __int64 v3; // [rsp+30h] [rbp+8h] BYREF

  if ( !lpThreadParameter )
    return 0i64;
  sub_1400D6760((__int64)lpThreadParameter, &dword_140130C94, &dword_140130C98, &v3);
  (*((void (__fastcall **)(_QWORD, _QWORD, __int64 *, _QWORD))lpThreadParameter + 66))(
    (unsigned int)dword_140130C94,
    (unsigned int)dword_140130C98,
    &v3,
    *((_QWORD *)lpThreadParameter + 65));
  free(lpThreadParameter);
  return 1i64;
}
// 140130C94: using guessed type int dword_140130C94;
// 140130C98: using guessed type int dword_140130C98;

//----- (00000001400D6AB0) ----------------------------------------------------
BOOL __fastcall sub_1400D6AB0(HWND hDlg)
{
  HWND DlgItem; // rbx
  __int64 v3; // rsi
  HWND v4; // rdi
  char *v5; // rcx
  __int16 v6; // ax
  __int64 v7; // rdx
  char *v8; // rcx
  __int16 v9; // ax
  LPARAM v10; // rdi
  _QWORD *v11; // rbx
  __int64 v12; // rcx
  _QWORD *i; // rax
  LPARAM v15[8]; // [rsp+20h] [rbp-A78h] BYREF
  char v16[512]; // [rsp+60h] [rbp-A38h] BYREF
  char v17[1024]; // [rsp+260h] [rbp-838h] BYREF
  __int64 v18; // [rsp+660h] [rbp-438h]
  LPARAM lParam[64]; // [rsp+880h] [rbp-218h] BYREF

  DlgItem = GetDlgItem(hDlg, 1170);
  v3 = 256i64;
  v4 = GetDlgItem(hDlg, 1058);
  SendMessageW(DlgItem, 0xDu, 0x100ui64, (LPARAM)lParam);
  LODWORD(v15[0]) = 32;
  v15[1] = (int)SendMessageW(v4, 0x147u, 0i64, 0i64);
  SendMessageW(v4, 0x40Du, 0i64, (LPARAM)v15);
  v5 = v16;
  while ( v3 != -2147483390 )
  {
    v6 = *(_WORD *)&v5[(char *)lParam - v16];
    if ( !v6 )
      break;
    *(_WORD *)v5 = v6;
    v5 += 2;
    if ( !--v3 )
    {
      v5 -= 2;
      break;
    }
  }
  *(_WORD *)v5 = 0;
  v7 = 512i64;
  v8 = v17;
  while ( v7 != -2147483134 )
  {
    v9 = *(_WORD *)&v8[&unk_1400EBED4 - (_UNKNOWN *)v17];
    if ( !v9 )
      break;
    *(_WORD *)v8 = v9;
    v8 += 2;
    if ( !--v7 )
    {
      v8 -= 2;
      break;
    }
  }
  v10 = v15[6];
  *(_WORD *)v8 = 0;
  v18 = 0i64;
  v11 = malloc(0x830ui64);
  sub_14007D850((__int64)v11, (__int64)v16);
  v11[258] = v10;
  v12 = *(_QWORD *)(v10 + 2088);
  if ( v12 )
  {
    for ( i = (_QWORD *)(v12 + 2080); *i; i = (_QWORD *)(*i + 2080i64) )
      v12 = *i;
    *(_QWORD *)(v12 + 2080) = v11;
    v11[259] = v12;
  }
  else
  {
    *(_QWORD *)(v10 + 2088) = v11;
    v11[259] = 0i64;
  }
  return EndDialog(hDlg, 1i64);
}
// 1400D6B96: conditional instruction was optimized away because rsi.8!=0
// 1400D6BE7: conditional instruction was optimized away because rdx.8!=0

//----- (00000001400D6CB0) ----------------------------------------------------
HWND __fastcall sub_1400D6CB0(__int64 a1, HWND a2)
{
  HWND DlgItem; // r12
  HWND v5; // rsi
  __int64 v6; // rdi
  HMODULE ModuleHandleW; // rax
  HBITMAP BitmapW; // rbx
  char v10[2080]; // [rsp+30h] [rbp-848h] BYREF

  DlgItem = GetDlgItem(a2, 1170);
  v5 = GetDlgItem(a2, 1058);
  SetWindowTextW(DlgItem, L"New Folder");
  v6 = sub_1400016D0(0x10u, 0x10u, 0x21u, 0, 1);
  ModuleHandleW = GetModuleHandleW(0i64);
  BitmapW = LoadBitmapW(ModuleHandleW, (LPCWSTR)0xCD);
  sub_1400012C0(v6, (__int64)BitmapW, 0i64);
  DeleteObject(BitmapW);
  SendMessageW(v5, 0x402u, 0i64, v6);
  sub_14007DA80(a1 + 2664, (__int64)v10);
  sub_1400CAA90(a1, v5, (LPARAM)v10, 0, 0);
  SendMessageW(v5, 0x14Eu, dword_14012D730, 0i64);
  SendMessageW(DlgItem, 0xB1u, 0i64, -1i64);
  return SetFocus(DlgItem);
}
// 14012D730: using guessed type int dword_14012D730;

//----- (00000001400D6E10) ----------------------------------------------------
__int64 __fastcall sub_1400D6E10(HWND a1, int a2, __int16 a3)
{
  int v3; // edx
  int v4; // edx

  v3 = a2 - 16;
  if ( !v3 )
    goto LABEL_6;
  v4 = v3 - 256;
  if ( v4 )
  {
    if ( v4 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_6:
        EndDialog(a1, 0i64);
      return 0i64;
    }
    sub_1400D6AB0(a1);
    return 0i64;
  }
  else
  {
    sub_1400D6CB0(qword_14012E188, a1);
    return 0i64;
  }
}
// 14012E188: using guessed type __int64 qword_14012E188;

//----- (00000001400D6E70) ----------------------------------------------------
__int64 __fastcall sub_1400D6E70(HWND hDlg, int a2, __int16 a3, __int64 a4)
{
  __int64 v5; // rcx
  int v6; // edx
  int v7; // edx

  v5 = qword_14012E188;
  if ( a2 == 272 )
    v5 = a4;
  v6 = a2 - 16;
  qword_14012E188 = v5;
  if ( !v6 )
    goto LABEL_8;
  v7 = v6 - 256;
  if ( v7 )
  {
    if ( v7 != 1 )
      return 0i64;
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
LABEL_8:
        EndDialog(hDlg, 0i64);
      return 0i64;
    }
    sub_1400D6AB0(hDlg);
    return 0i64;
  }
  else
  {
    sub_1400D6CB0(v5, hDlg);
    return 0i64;
  }
}
// 14012E188: using guessed type __int64 qword_14012E188;

//----- (00000001400D6EE0) ----------------------------------------------------
void __fastcall sub_1400D6EE0(__int64 a1, int a2, HMENU a3)
{
  UINT MenuItemID; // eax
  int v6; // ebx
  void *pv[2]; // [rsp+30h] [rbp-238h] BYREF
  char v8[528]; // [rsp+40h] [rbp-228h] BYREF

  MenuItemID = GetMenuItemID(a3, a2);
  if ( MenuItemID - 10000 <= 0x3E8 )
  {
    sub_1400CB700(a3, MenuItemID, v8);
    pv[0] = 0i64;
    v6 = sub_14007F810((__int64)v8, (__int64)pv);
    (*(void (__fastcall **)(__int64, void *, _QWORD, _QWORD, _DWORD, _DWORD))(*(_QWORD *)(a1 + 56) + 80i64))(
      a1 + 56,
      pv[0],
      0i64,
      0i64,
      0,
      0);
    if ( v6 >= 0 )
      CoTaskMemFree(pv[0]);
  }
}
// 1400D6EE0: using guessed type LPVOID pv[2];

//----- (00000001400D6FB0) ----------------------------------------------------
__int64 __fastcall sub_1400D6FB0(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  HWND v6; // r15
  UINT v7; // er12
  HMENU PopupMenu; // rsi
  int v9; // edx
  int v10; // edx
  int v11; // edx
  signed int v12; // ebx
  WPARAM v13; // rsi
  __int64 v14; // rdx
  LPARAM *v15; // rcx
  __int64 v16; // r8
  __int16 v17; // ax
  int v18; // eax
  UINT v19; // ebx
  HMENU Menu; // rsi
  int v21; // eax
  HMENU v22; // rax
  __int64 v23; // rcx
  char *v24; // r8
  HMENU v25; // rdx
  signed int v26; // ebx
  int MenuItemCount; // er12
  HMENU v28; // rcx
  int v29; // edx
  HWND v30; // rcx
  BOOL v31; // eax
  unsigned int v32; // er11
  ITEMIDLIST *v33; // rbx
  __int64 v34; // rcx
  char v35; // al
  __int64 v36; // rcx
  int v37; // [rsp+40h] [rbp-C0h] BYREF
  UINT v38; // [rsp+44h] [rbp-BCh]
  struct tagPOINT Point; // [rsp+48h] [rbp-B8h] BYREF
  HMENU hmenu; // [rsp+50h] [rbp-B0h]
  WPARAM v41; // [rsp+58h] [rbp-A8h]
  HIMAGELIST phimlSmall; // [rsp+60h] [rbp-A0h] BYREF
  LRESULT v43; // [rsp+68h] [rbp-98h]
  struct _IMAGELIST *v44; // [rsp+70h] [rbp-90h]
  MENUITEMINFOW mi; // [rsp+80h] [rbp-80h] BYREF
  MENUINFO v46; // [rsp+D0h] [rbp-30h] BYREF
  int v47; // [rsp+F8h] [rbp-8h] BYREF
  signed int v48; // [rsp+FCh] [rbp-4h]
  char v49; // [rsp+101h] [rbp+1h]
  __int64 v50; // [rsp+108h] [rbp+8h]
  __int64 v51; // [rsp+110h] [rbp+10h]
  struct tagRECT Rect; // [rsp+118h] [rbp+18h] BYREF
  RECT lParam; // [rsp+128h] [rbp+28h] BYREF
  struct tagRECT rcDst; // [rsp+138h] [rbp+38h] BYREF
  char v55[2080]; // [rsp+150h] [rbp+50h] BYREF
  char v56[1540]; // [rsp+970h] [rbp+870h] BYREF
  int v57; // [rsp+F74h] [rbp+E74h]
  __int64 v58; // [rsp+1180h] [rbp+1080h]
  LPARAM v59[128]; // [rsp+1190h] [rbp+1090h] BYREF
  char v60[1024]; // [rsp+1590h] [rbp+1490h] BYREF

  v2 = *(_DWORD *)(a2 + 16);
  if ( v2 <= 0xFFFFFF4B )
  {
    if ( v2 == -181 )
    {
      if ( *(_DWORD *)(a1 + 7004) == 5 )
      {
        v34 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
        (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v34 + 48i64))(v34, &v37);
        v35 = SendMessageW(*(HWND *)(a1 + 4800), 0x1037u, 0i64, 0i64);
        if ( v37 == 4 && (v35 & 1) != 0 )
        {
          InvalidateRect(*(HWND *)(a1 + 4800), 0i64, 1);
          UpdateWindow(*(HWND *)(a1 + 4800));
        }
      }
      return 0i64;
    }
    switch ( v2 )
    {
      case 0xFFFFFCB7:
        v6 = 0i64;
        v7 = 0;
        v38 = 0;
        PopupMenu = CreatePopupMenu();
        hmenu = PopupMenu;
        v44 = himl;
        Shell_GetImageLists(0i64, &phimlSmall);
        v9 = *(_DWORD *)(a2 + 28);
        if ( v9 )
        {
          v10 = v9 - 2;
          if ( v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
              {
                v6 = *(HWND *)(a1 + 1024);
                himl = phimlSmall;
              }
            }
            else
            {
              v6 = *(HWND *)(a1 + 1016);
              himl = phimlSmall;
            }
          }
          else
          {
            v6 = *(HWND *)(a1 + 1008);
          }
        }
        else
        {
          v6 = *(HWND *)(a1 + 176);
        }
        v43 = SendMessageW(v6, 0x418u, 0i64, 0i64);
        GetClientRect(v6, &Rect);
        v12 = 0;
        v37 = 0;
        if ( (int)v43 <= 0 )
          goto LABEL_60;
        v13 = 0i64;
        v41 = 0i64;
        break;
      case 0xFFFFFCBD:
        SendMessageW(*(HWND *)(a1 + 120), 0x41Au, 0i64, -1i64);
        return 0i64;
      case 0xFFFFFCC1:
        sub_1400B5BA0(a1);
        sub_14008FE00(a1);
        return 0i64;
      case 0xFFFFFCD7:
        sub_1400900A0(a1);
        return 0i64;
      case 0xFFFFFD2D:
      case 0xFFFFFD3D:
      case 0xFFFFFD3E:
        return 1i64;
      case 0xFFFFFD30:
        return (int)sub_14008FFC0(a2);
      case 0xFFFFFD31:
        sub_140090450(a1, (char *)a2);
        return 0i64;
      case 0xFFFFFD3A:
        sub_1400B4150(a1, a2);
        return 0i64;
      case 0xFFFFFD3F:
        sub_140090A70(a1);
        return 0i64;
      case 0xFFFFFD40:
        sub_140080090(*(HWND *)(a1 + 120), *(HWND *)a2);
        return 0i64;
      default:
        return 0i64;
    }
    while ( 1 )
    {
      if ( !SendMessageW(v6, 0x41Du, v13, (LPARAM)&lParam)
        || IntersectRect(&rcDst, &Rect, &lParam) && lParam.right <= Rect.right )
      {
        goto LABEL_58;
      }
      SendMessageW(v6, 0x417u, v13, (LPARAM)&v47);
      if ( (v49 & 1) == 0 )
        break;
      mi.cbSize = 80;
      mi.fMask = 256;
      mi.fType = 2048;
      InsertMenuItemW(hmenu, v12, 1, &mi);
LABEL_57:
      v38 = ++v7;
LABEL_58:
      ++v12;
      ++v13;
      v37 = v12;
      v41 = v13;
      if ( v12 >= (int)v43 )
      {
        PopupMenu = hmenu;
LABEL_60:
        v30 = *(HWND *)(a1 + 120);
        Point.x = *(_DWORD *)(a2 + 40);
        Point.y = *(_DWORD *)(a2 + 52);
        ClientToScreen(v30, &Point);
        v31 = TrackPopupMenu(PopupMenu, 0x100u, Point.x, Point.y, 0, *(HWND *)(a1 + 120), 0i64);
        if ( v31 )
        {
          if ( (v31 < 2000 || v31 > 2999) && (unsigned int)(v31 - 3000) > 0x3E7 )
          {
            SendMessageW(*(HWND *)(a1 + 104), 0x111u, v31, 0i64);
          }
          else
          {
            if ( (unsigned int)(v31 - 2000) > 0x3E7 )
              v32 = v31 - 3000;
            else
              v32 = 2000 - v31;
            v33 = (ITEMIDLIST *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 176i64))(
                                  *(_QWORD *)(a1 + 2640),
                                  v32);
            sub_1400B40A0(a1, v33);
            CoTaskMemFree(v33);
          }
        }
        DestroyMenu(PopupMenu);
        himl = v44;
        return 0i64;
      }
    }
    if ( (v51 & 0xFFFFFFFFFFFF0000ui64) != 0 )
    {
      v14 = 512i64;
      v15 = v59;
      v16 = v51 - (_QWORD)v59;
      while ( v14 != -2147483134 )
      {
        v17 = *(_WORD *)((char *)v15 + v16);
        if ( !v17 )
          break;
        *(_WORD *)v15 = v17;
        v15 = (LPARAM *)((char *)v15 + 2);
        if ( !--v14 )
        {
          v15 = (LPARAM *)((char *)v15 - 2);
          break;
        }
      }
      *(_WORD *)v15 = 0;
    }
    else
    {
      SendMessageW(v6, 0x45Bu, ((unsigned __int16)v51 << 16) | 0x200i64, (LPARAM)v59);
    }
    v18 = *(_DWORD *)(a2 + 28);
    v19 = 66;
    Menu = 0i64;
    if ( v18 )
    {
      if ( v18 != 2 )
        goto LABEL_56;
      v21 = SendMessageW(*(HWND *)(a1 + 1008), 0x419u, v48, 0i64);
      if ( v21 == -1 )
        goto LABEL_56;
      SendMessageW(*(HWND *)(a1 + 1008), 0x417u, v21, (LPARAM)&v47);
      sub_14007D720(v50, (__int64)v56);
      if ( v57 )
        goto LABEL_56;
      Menu = CreateMenu();
      v22 = CreateMenu();
      v46.cbSize = 40;
      v46.fMask = 16;
      *(_QWORD *)(a1 + 4864) = v22;
      v46.dwStyle = 0x8000000;
      SetMenuInfo(Menu, &v46);
      if ( *(_DWORD *)(v58 + 1540) || (v23 = *(_QWORD *)(v58 + 2088)) == 0 )
      {
        dword_140120034 = 10000;
        sub_1400CB0B0(a1, Menu, 0i64, 0);
        v24 = 0i64;
      }
      else
      {
        sub_14007D720(v23, (__int64)v55);
        dword_140120034 = 10000;
        sub_1400CB0B0(a1, Menu, (__int64)v55, 0);
        v24 = v55;
      }
      v25 = *(HMENU *)(a1 + 4864);
      dword_140120034 = 10000;
      sub_1400CB0B0(a1, v25, (__int64)v24, 0);
      sub_1400B0350(a1, Menu);
      goto LABEL_55;
    }
    switch ( v48 )
    {
      case 45002:
        v29 = 1;
        break;
      case 45003:
        v29 = 0;
        break;
      case 45013:
        Menu = CreateMenu();
        v26 = 0;
        MenuItemCount = GetMenuItemCount(*(HMENU *)(a1 + 4912));
        if ( MenuItemCount > 0 )
        {
          do
          {
            v28 = *(HMENU *)(a1 + 4912);
            mi.dwTypeData = (LPWSTR)v60;
            mi.cbSize = 80;
            mi.fMask = 66;
            mi.cch = 512;
            if ( GetMenuItemInfoW(v28, v26, 1, &mi) )
            {
              mi.cbSize = 80;
              mi.dwTypeData = (LPWSTR)v60;
              mi.fMask = 66;
              InsertMenuItemW(Menu, v26, 1, &mi);
            }
            ++v26;
          }
          while ( v26 < MenuItemCount );
        }
        sub_1400B0350(a1, Menu);
        v7 = v38;
LABEL_55:
        v19 = 70;
        goto LABEL_56;
      default:
LABEL_56:
        mi.fMask = v19;
        mi.wID = v48;
        mi.dwTypeData = (LPWSTR)v59;
        mi.cbSize = 80;
        mi.hSubMenu = Menu;
        InsertMenuItemW(hmenu, v7, 1, &mi);
        sub_1400B02C0(hmenu, v7);
        sub_1400B0270(hmenu, v48, v47);
        v12 = v37;
        v13 = v41;
        goto LABEL_57;
    }
    Menu = sub_1400C3870(a1, v29);
    goto LABEL_55;
  }
  switch ( v2 )
  {
    case 0xFFFFFF4F:
      sub_1400BDDF0(a1, (_QWORD *)a2);
      return 0i64;
    case 0xFFFFFF50:
      return (int)sub_1400C1030(a1, a2);
    case 0xFFFFFF51:
      return (int)sub_1400BF100(a1, a2);
    case 0xFFFFFF62:
      sub_1400BEAF0(a1, a2);
      return 0i64;
    case 0xFFFFFF65:
      return sub_1400C1700(a1, a2);
    case 0xFFFFFF93:
      sub_1400C0510(a1, a2, 0i64);
      return 0i64;
    case 0xFFFFFF94:
      (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 2640) + 560i64))(
        *(_QWORD *)(a1 + 2640),
        *(unsigned int *)(a2 + 28));
      return 0i64;
    case 0xFFFFFF9B:
      sub_1400C2150(a1, a2);
      return 0i64;
    case 0xFFFFFF9C:
      v36 = *(_QWORD *)(a1 + 8i64 * *(int *)(a1 + 7048) + 1032);
      (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v36 + 48i64))(v36, &v37);
      if ( v37 != 3 || !*(_DWORD *)(a1 + 63280) )
        return 0i64;
      *(_DWORD *)(a1 + 63280) = 0;
      return 1i64;
    case 0xFFFFFFF4:
      return sub_1400B2B30(a1, a2);
    case 0xFFFFFFFB:
      sub_1400D1890(a1, (HWND *)a2);
      return 0i64;
    case 0xFFFFFFFD:
      goto LABEL_77;
    case 0xFFFFFFFE:
      if ( !*(_DWORD *)(a1 + 60844) || *(_DWORD *)(a1 + 62412) )
        return 0i64;
LABEL_77:
      sub_1400BDB10(a1, (_QWORD *)a2);
      break;
    default:
      return 0i64;
  }
  return 0i64;
}
// 1400D728A: conditional instruction was optimized away because rdx.8!=0
// 1400C0510: using guessed type __int64 __fastcall sub_1400C0510(_QWORD, _QWORD, _QWORD);
// 140120034: using guessed type int dword_140120034;
// 1400D6FB0: using guessed type char var_1060[1540];

//----- (00000001400DA110) ----------------------------------------------------
__int64 __fastcall sub_1400DA110(__int64 a1, HWND a2, UINT a3, WPARAM a4, HMENU a5)
{
  __int64 v8; // rsi
  unsigned int v9; // eax
  bool v10; // cf
  HMODULE v11; // rax
  HMODULE v12; // rdi
  FARPROC ChangeWindowsMessageFilter; // rax
  void (__fastcall *v14)(__int64, __int64); // rbp
  _QWORD *v15; // rbp
  __int64 v16; // rcx
  _QWORD *v17; // rax
  _QWORD *v18; // rbx
  __int64 v19; // r12
  BOOL v20; // edi
  __int64 v22; // rdx
  __int64 v23; // rbx
  __int64 v24; // rcx
  __int64 v25; // rcx
  HWND v26; // rcx
  WPARAM v27; // r8
  unsigned __int64 v28; // r9
  UINT v29; // edx
  HWND v30; // rcx
  void **v31; // rax
  int v32; // er13
  _DWORD *v33; // rcx
  struct tagRECT Rect; // [rsp+30h] [rbp-198h] BYREF
  char v35[64]; // [rsp+40h] [rbp-188h] BYREF
  WCHAR Buffer[64]; // [rsp+80h] [rbp-148h] BYREF
  __int16 lParam[64]; // [rsp+100h] [rbp-C8h] BYREF

  v8 = a1;
  if ( a3 == *(_DWORD *)(a1 + 61024) )
  {
    v9 = *(_DWORD *)(a1 + 7004);
    v10 = v9 < 6;
    if ( v9 == 6 )
    {
      if ( !*(_DWORD *)(a1 + 7008) )
        return 0i64;
      v10 = 0;
    }
    if ( !v10 && *(_DWORD *)(a1 + 60892) )
    {
      v11 = sub_14000AF70(L"user32.dll");
      v12 = v11;
      if ( v11 )
      {
        ChangeWindowsMessageFilter = GetProcAddress(v11, "ChangeWindowsMessageFilter");
        v14 = (void (__fastcall *)(__int64, __int64))ChangeWindowsMessageFilter;
        if ( ChangeWindowsMessageFilter )
        {
          ((void (__fastcall *)(__int64, __int64))ChangeWindowsMessageFilter)(803i64, 1i64);
          v14(806i64, 1i64);
        }
        FreeLibrary(v12);
      }
      v15 = (_QWORD *)(v8 + 60992);
      v16 = *(_QWORD *)(v8 + 60992);
      if ( v16 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16i64))(v16);
      CoCreateInstance(&stru_1400E40B0, 0i64, 1u, &stru_1400E4070, (LPVOID *)(v8 + 60992));
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v15 + 24i64))(*v15);
      *(_DWORD *)(v8 + 61028) = 1;
      sub_1400B10F0();
      v17 = *(_QWORD **)(v8 + 61000);
      v18 = (_QWORD *)*v17;
      if ( (_QWORD *)*v17 != v17 )
      {
        do
        {
          v19 = v18[3];
          v20 = *((_DWORD *)v18 + 8) == *(_DWORD *)(v8 + 7048);
          (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(*(_QWORD *)*v15 + 88i64))(*v15, v19, *(_QWORD *)(v8 + 104));
          (*(void (__fastcall **)(_QWORD, __int64, _QWORD))(*(_QWORD *)*v15 + 104i64))(*v15, v19, 0i64);
          (*(void (__fastcall **)(_QWORD, __int64, void *))(*(_QWORD *)*v15 + 152i64))(*v15, v19, &unk_1400EC7B4);
          if ( v20 )
            (*(void (__fastcall **)(_QWORD, __int64, _QWORD, _QWORD))(*(_QWORD *)*v15 + 112i64))(
              *v15,
              v19,
              *(_QWORD *)(v8 + 104),
              0i64);
          sub_1400D03E0(v8, *((_DWORD *)v18 + 8));
          sub_1400D14A0(v8, *((_DWORD *)v18 + 8));
          CoTaskMemFree(0i64);
          v18 = (_QWORD *)*v18;
        }
        while ( v18 != *(_QWORD **)(v8 + 61000) );
      }
    }
    return 0i64;
  }
  if ( a3 > 0x8002 )
  {
    if ( a3 <= 0x812C )
    {
      if ( a3 == 33068 )
      {
        *(_DWORD *)(a1 + 7044) = (_DWORD)a5 + 8;
        GetClientRect(*(HWND *)(a1 + 104), &Rect);
        v26 = *(HWND *)(v8 + 104);
        v28 = LOWORD(Rect.right) | (unsigned __int64)(LOWORD(Rect.bottom) << 16);
        v27 = 0i64;
        v29 = 5;
LABEL_93:
        SendMessageW(v26, v29, v27, v28);
      }
      else
      {
        switch ( a3 )
        {
          case 0x8003u:
            v31 = *(void ***)(a1 + 62200);
            v32 = 0;
            v33 = *v31;
            if ( *v31 == v31 )
              goto LABEL_89;
            break;
          case 0x8011u:
            sub_1400D1700(a1);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8033u:
            if ( *(_DWORD *)(a1 + 4i64 * (int)a4 + 60320) )
              (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8 * a4 + 1832) + 72i64))(*(_QWORD *)(a1 + 8 * a4 + 1832));
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8034u:
            v23 = (int)a4;
            v24 = *(_QWORD *)(a1 + 8i64 * (int)a4 + 1832);
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v24 + 16i64))(v24);
            v25 = *(_QWORD *)(v8 + 8 * v23 + 1032);
            *(_QWORD *)(v8 + 8 * v23 + 1832) = 0i64;
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v25 + 16i64))(v25);
            *(_QWORD *)(v8 + 8 * v23 + 1032) = 0i64;
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8035u:
            sub_1400B3E30(a1, (int)a5);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8036u:
            sub_1400B1740(a1);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8037u:
            sub_1400B0CD0(a1, a4, (__int64)a5);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8048u:
            *(_QWORD *)(a1 + 4808) = *(_QWORD *)(a1 + 152);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8064u:
            sub_1400AF910(a1, a4);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8065u:
            sub_1400B3750(a1, (int)a5);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x8066u:
            sub_1400AF210(a1, (int)a5);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x80C8u:
            if ( (_DWORD)a5 == -1 )
              return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
            v26 = *(HWND *)(a1 + 4800);
            v27 = (int)a5;
            v28 = 0i64;
            v29 = 4214;
            goto LABEL_93;
          case 0x80C9u:
            v30 = *(HWND *)(a1 + 8i64 * (int)a4 + 184);
            if ( (_DWORD)a5 != 1 )
              goto LABEL_72;
            sub_140082260(v30, 149);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x80CAu:
            v30 = *(HWND *)(a1 + 8i64 * (int)a4 + 184);
            if ( (_DWORD)a5 == 1 )
              sub_140082260(v30, 104);
            else
LABEL_72:
              sub_140082260(v30, 0);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          case 0x80CBu:
            return (*(int (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 56) + 48i64))(a1 + 56, (unsigned int)a4);
          case 0x80CCu:
            if ( (_DWORD)a4 == *(_DWORD *)(a1 + 7048) )
            {
              sub_1400B82C0(a1);
              sub_1400B8250(v8);
            }
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          default:
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
        }
        while ( v33[4] != *(_DWORD *)(a4 + 8) )
        {
          v33 = *(_DWORD **)v33;
          if ( v33 == *(_DWORD **)(v8 + 62200) )
          {
            free((void *)a4);
            return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
          }
        }
        if ( v33[5] == *(_DWORD *)(v8 + 7048) )
          v32 = v33[6];
        if ( v33 != *(_DWORD **)(v8 + 62200) )
        {
          **((_QWORD **)v33 + 1) = *(_QWORD *)v33;
          *(_QWORD *)(*(_QWORD *)v33 + 8i64) = *((_QWORD *)v33 + 1);
          j_free(v33);
          --*(_QWORD *)(v8 + 62208);
        }
        if ( v32 )
        {
          sub_140083DE0(*(_QWORD *)a4, v35, 0x20ui64, *(_DWORD *)(v8 + 60880), *(_DWORD *)(v8 + 60916));
          LoadStringW(hInstance, 0x1FF6u, Buffer, 64);
          sub_140001000((wchar_t *)lParam, 0x40ui64, L"%s: %s", Buffer, v35);
          SendMessageW(*(HWND *)(v8 + 128), 0x8075u, 1ui64, (LPARAM)lParam);
        }
LABEL_89:
        free((void *)a4);
      }
    }
  }
  else if ( a3 == 32770 )
  {
    if ( a4 == 13 )
      sub_1400D6690(a1);
  }
  else if ( a3 > 0x4E )
  {
    if ( a3 > 0x219 )
    {
      switch ( a3 )
      {
        case 0x308u:
          sub_1400B2D70(a1);
          break;
        case 0x30Du:
          sub_1400AF980(a1, a4, (LPARAM)a5);
          break;
        case 0x319u:
          sub_1400B3CD0(a1, (unsigned __int64)a5);
          break;
      }
    }
    else
    {
      switch ( a3 )
      {
        case 0x219u:
          sub_1400B64E0((HWND *)a1, a4, (LPARAM)a5);
          break;
        case 0x111u:
          return sub_1400D79A0(a1, a2, a4);
        case 0x116u:
          *(_QWORD *)(*(_QWORD *)(a1 + 4760) + 8i64) = a4;
          sub_1400D0B20(a1, (HMENU)a4);
          break;
        case 0x11Fu:
          sub_1400B72E0(a1, a4, (__int64)a5);
          break;
        case 0x126u:
          sub_1400D6EE0(a1, a4, a5);
          break;
      }
    }
  }
  else
  {
    if ( a3 == 78 )
      return sub_1400D6FB0(a1, (__int64)a5);
    switch ( a3 )
    {
      case 1u:
        sub_1400B4750((LPDROPTARGET)a1);
        return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
      case 2u:
        return (int)sub_1400B2A70(a1);
      case 5u:
        return (int)sub_1400AFA70(a1, (unsigned __int16)a5, WORD1(a5));
      case 7u:
        SetFocus(*(HWND *)(a1 + 4808));
        return 0i64;
      case 0x10u:
        return (int)sub_1400B0830(a1);
      case 0x2Bu:
        if ( *(_DWORD *)a5 != 1 )
          return 1i64;
        return (int)sub_14007A580((__int64)a5);
      case 0x2Cu:
        if ( *(_DWORD *)a5 == 1 )
          return (int)sub_14007A340(*(_QWORD *)(a1 + 4760), a5);
        else
          return 1i64;
      case 0x4Au:
        v22 = *((_QWORD *)a5 + 2);
        if ( v22 )
          goto LABEL_33;
        if ( (int)sub_1400B0C20(a1, a1 + 5960, 0, 1u, 1) < 0 )
        {
          v22 = v8 + 5440;
          a1 = v8;
LABEL_33:
          sub_1400B0C20(a1, v22, 0, 1u, 1);
        }
        break;
      default:
        return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
    }
  }
  return DefWindowProcW(a2, a3, a4, (LPARAM)a5);
}
// 1400D79A0: using guessed type __int64 __fastcall sub_1400D79A0(_QWORD, _QWORD, _QWORD);
// 1400F45A0: using guessed type wchar_t aSS_15[7];
// 1400DA110: using guessed type wchar_t lParam[64];

//----- (00000001400DA990) ----------------------------------------------------
__int64 __fastcall sub_1400DA990(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG_PTR WindowLongPtrW; // rbx
  void *v9; // rax

  WindowLongPtrW = GetWindowLongPtrW(hWnd, -21);
  if ( Msg == 129 )
  {
    v9 = operator new(0xF738ui64);
    if ( v9 )
      WindowLongPtrW = sub_1400C4240((__int64)v9, (__int64)hWnd);
    else
      WindowLongPtrW = 0i64;
    if ( !WindowLongPtrW )
    {
      PostQuitMessage(0);
      return 0i64;
    }
    SetWindowLongPtrW(hWnd, -21, WindowLongPtrW);
  }
  if ( WindowLongPtrW )
    return sub_1400DA110(WindowLongPtrW, hWnd, Msg, wParam, (HMENU)lParam);
  else
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (00000001400DAA70) ----------------------------------------------------
__int64 __fastcall sub_1400DAA70(__int64 a1, __int64 a2, unsigned int a3, WPARAM a4, __int64 lParam)
{
  int v9; // eax

  switch ( a3 )
  {
    case 0x2Cu:
      *(_DWORD *)(lParam + 12) = 20;
      *(_DWORD *)(lParam + 16) = 10;
      break;
    case 0x4Eu:
      v9 = *(_DWORD *)(lParam + 16);
      if ( v9 == -551 )
      {
        sub_1400959D0(a1);
      }
      else if ( v9 == -530 )
      {
        sub_1400AF9E0(a1, lParam);
      }
      break;
    case 0x111u:
      if ( (_WORD)a4 == 5033 )
        sub_140095E30(a1);
      break;
    case 0x116u:
      SendMessageW(*(HWND *)(a1 + 104), 0x116u, a4, lParam);
      break;
    default:
      if ( a3 == 515 && (int)sub_1400B0C20(a1, a1 + 5960, 0, 1u, 1) < 0 )
        sub_1400B0C20(a1, a1 + 5440, 0, 1u, 1);
      break;
  }
  return sub_140001A20(a2, a3, a4, lParam);
}

//----- (00000001400DABA0) ----------------------------------------------------
__int64 __fastcall sub_1400DABA0(__int64 a1, unsigned int a2, WPARAM a3, __int64 a4, int a5, __int64 a6)
{
  return sub_1400DAA70(a6, a1, a2, a3, a4);
}

//----- (00000001400DABD0) ----------------------------------------------------
__int64 __fastcall sub_1400DABD0(__int64 a1)
{
  HMODULE ModuleHandleW; // rax
  HWND v3; // rax

  ModuleHandleW = GetModuleHandleW(0i64);
  v3 = sub_14001A730(L"Static", &word_1400EBB3C, 0x54000100u, 0, 0, 0, 0, *(HWND *)(a1 + 104), ModuleHandleW, 0i64);
  *(_QWORD *)(a1 + 992) = v3;
  return sub_140009C20((__int64)v3, (__int64)sub_1400DABA0, 0i64, a1);
}

//----- (00000001400E1A90) ----------------------------------------------------
int sub_1400E1A90()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  v0 = operator new(0x410ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012DF88 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012DF88 + 1) = qword_14012DF88;
  return atexit(sub_1400E1E80);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E1B00) ----------------------------------------------------
int sub_1400E1B00()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  v0 = operator new(0x410ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012DFA0 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012DFA0 + 1) = qword_14012DFA0;
  return atexit(sub_1400E1EF0);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E1B70) ----------------------------------------------------
int sub_1400E1B70()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  v0 = operator new(0x38ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012DFB8 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012DFB8 + 1) = qword_14012DFB8;
  return atexit(sub_1400E2170);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E1BE0) ----------------------------------------------------
int sub_1400E1BE0()
{
  __int16 v1; // [rsp+30h] [rbp+8h] BYREF

  sub_14001AC90(&v1);
  return atexit(sub_1400E2200);
}

//----- (00000001400E1C00) ----------------------------------------------------
UINT sub_1400E1C00()
{
  UINT result; // eax

  result = RegisterClipboardFormatW(L"FileGroupDescriptorW");
  qword_14012E030 = 0i64;
  dword_14012E038 = 1;
  dword_14012E03C = -1;
  dword_14012E040 = 1;
  word_14012E028 = result;
  return result;
}
// 14012E028: using guessed type __int16 word_14012E028;
// 14012E030: using guessed type __int64 qword_14012E030;
// 14012E038: using guessed type int dword_14012E038;
// 14012E03C: using guessed type int dword_14012E03C;
// 14012E040: using guessed type int dword_14012E040;

//----- (00000001400E1C50) ----------------------------------------------------
UINT sub_1400E1C50()
{
  UINT result; // eax

  result = RegisterClipboardFormatW(L"Shell IDList Array");
  qword_14012E050 = 0i64;
  dword_14012E058 = 1;
  dword_14012E05C = -1;
  dword_14012E060 = 1;
  word_14012E048 = result;
  return result;
}
// 14012E048: using guessed type __int16 word_14012E048;
// 14012E050: using guessed type __int64 qword_14012E050;
// 14012E058: using guessed type int dword_14012E058;
// 14012E05C: using guessed type int dword_14012E05C;
// 14012E060: using guessed type int dword_14012E060;

//----- (00000001400E1CA0) ----------------------------------------------------
int sub_1400E1CA0()
{
  sub_14001E940();
  return atexit(sub_1400E2210);
}

//----- (00000001400E1CC0) ----------------------------------------------------
int sub_1400E1CC0()
{
  sub_1400223F0();
  return atexit(sub_1400E2280);
}

//----- (00000001400E1CE0) ----------------------------------------------------
int sub_1400E1CE0()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  v0 = operator new(0x38ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012E098 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012E098 + 1) = qword_14012E098;
  return atexit(sub_1400E22F0);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E1D50) ----------------------------------------------------
int sub_1400E1D50()
{
  _QWORD *v0; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  char *v3; // [rsp+50h] [rbp+8h] BYREF

  v0 = operator new(0x38ui64);
  if ( !v0 )
  {
    v3 = 0i64;
    std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
    pExceptionObject[0] = (__int64)&std::bad_alloc::`vftable';
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  qword_14012E0B0 = v0;
  *v0 = v0;
  *((_QWORD *)qword_14012E0B0 + 1) = qword_14012E0B0;
  return atexit(sub_1400E2360);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E1DC0) ----------------------------------------------------
int sub_1400E1DC0()
{
  return atexit((void (__cdecl *)())sub_1400E23C8);
}

//----- (00000001400E1DCC) ----------------------------------------------------
int sub_1400E1DCC()
{
  return atexit((void (__cdecl *)())sub_1400E23D8);
}

//----- (00000001400E1DD8) ----------------------------------------------------
int sub_1400E1DD8()
{
  return atexit((void (__cdecl *)())sub_1400E23E8);
}

//----- (00000001400E1DE4) ----------------------------------------------------
int sub_1400E1DE4()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_14012C090);
  return atexit(sub_1400E23F8);
}

//----- (00000001400E1E04) ----------------------------------------------------
int sub_1400E1E04()
{
  return atexit(unknown_libname_234);
}

//----- (00000001400E1E10) ----------------------------------------------------
int sub_1400E1E10()
{
  return atexit(sub_1400E2404);
}

//----- (00000001400E1E1C) ----------------------------------------------------
int sub_1400E1E1C()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_14012C3E0);
  return atexit(sub_1400E249C);
}

//----- (00000001400E1E3C) ----------------------------------------------------
int sub_1400E1E3C()
{
  return atexit(unknown_libname_235);
}

//----- (00000001400E1E50) ----------------------------------------------------
void __fastcall sub_1400E1E50()
{
  qword_14012FEE0 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012FEE0: using guessed type __int64 qword_14012FEE0;

//----- (00000001400E1E60) ----------------------------------------------------
void __fastcall sub_1400E1E60()
{
  qword_14012FCC0 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012FCC0: using guessed type __int64 qword_14012FCC0;

//----- (00000001400E1E70) ----------------------------------------------------
void __fastcall sub_1400E1E70()
{
  qword_14012FA90 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012FA90: using guessed type __int64 qword_14012FA90;

//----- (00000001400E1E80) ----------------------------------------------------
void __fastcall sub_1400E1E80()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012DF88;
  *(_QWORD *)qword_14012DF88 = qword_14012DF88;
  *((_QWORD *)qword_14012DF88 + 1) = qword_14012DF88;
  v1 = qword_14012DF88;
  qword_14012DF90 = 0i64;
  if ( v0 != qword_14012DF88 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012DF88;
      v0 = v2;
    }
    while ( v2 != qword_14012DF88 );
  }
  j_free(v1);
}
// 14012DF90: using guessed type __int64 qword_14012DF90;

//----- (00000001400E1EF0) ----------------------------------------------------
void __fastcall sub_1400E1EF0()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012DFA0;
  *(_QWORD *)qword_14012DFA0 = qword_14012DFA0;
  *((_QWORD *)qword_14012DFA0 + 1) = qword_14012DFA0;
  v1 = qword_14012DFA0;
  qword_14012DFA8 = 0i64;
  if ( v0 != qword_14012DFA0 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012DFA0;
      v0 = v2;
    }
    while ( v2 != qword_14012DFA0 );
  }
  j_free(v1);
}
// 14012DFA8: using guessed type __int64 qword_14012DFA8;

//----- (00000001400E1F60) ----------------------------------------------------
void __fastcall sub_1400E1F60()
{
  qword_140130A50 = (__int64)&CFilterDialogPersistentSettings::`vftable';
  sub_14000A630((__int64)&qword_140130C70);
  j_free(qword_140130C70);
  qword_140130A50 = (__int64)&CDialogSettings::`vftable';
}
// 1400F6FC8: using guessed type void *CFilterDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 140130A50: using guessed type __int64 qword_140130A50;

//----- (00000001400E1FA0) ----------------------------------------------------
void __fastcall sub_1400E1FA0()
{
  qword_14012F860 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012F860: using guessed type __int64 qword_14012F860;

//----- (00000001400E1FB0) ----------------------------------------------------
void __fastcall sub_1400E1FB0()
{
  qword_14012F640 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012F640: using guessed type __int64 qword_14012F640;

//----- (00000001400E1FC0) ----------------------------------------------------
void __fastcall sub_1400E1FC0()
{
  qword_14012F400 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012F400: using guessed type __int64 qword_14012F400;

//----- (00000001400E1FD0) ----------------------------------------------------
void __fastcall sub_1400E1FD0()
{
  void **v0; // rbx

  v0 = (void **)qword_1401309E0;
  qword_1401305A0 = (__int64)&CSearchDialogPersistentSettings::`vftable';
  if ( qword_1401309E0 )
  {
    sub_140018EA0((__int64 *)qword_1401309E0);
    if ( *v0 )
      j_free(*v0);
    j_free(v0);
  }
  if ( qword_140130A08 )
    j_free(qword_140130A08);
  qword_140130A08 = 0i64;
  qword_140130A10 = 0i64;
  qword_140130A18 = 0i64;
  sub_14000A630((__int64)&qword_1401309C8);
  j_free(qword_1401309C8);
  qword_1401305A0 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7608: using guessed type void *CSearchDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 1401305A0: using guessed type __int64 qword_1401305A0;
// 140130A10: using guessed type __int64 qword_140130A10;
// 140130A18: using guessed type __int64 qword_140130A18;

//----- (00000001400E2070) ----------------------------------------------------
void __fastcall sub_1400E2070()
{
  qword_14012F1E0 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012F1E0: using guessed type __int64 qword_14012F1E0;

//----- (00000001400E2080) ----------------------------------------------------
void __fastcall sub_1400E2080()
{
  qword_14012EFB0 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012EFB0: using guessed type __int64 qword_14012EFB0;

//----- (00000001400E2090) ----------------------------------------------------
void __fastcall sub_1400E2090()
{
  qword_14012ED90 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 14012ED90: using guessed type __int64 qword_14012ED90;

//----- (00000001400E20A0) ----------------------------------------------------
void __fastcall sub_1400E20A0()
{
  qword_140130CC0 = (__int64)&CSplitFileDialogPersistentSettings::`vftable';
  if ( (unsigned __int64)qword_140130F20 >= 8 )
    j_free(qword_140130F08);
  qword_140130F20 = 7i64;
  qword_140130F18 = 0i64;
  LOWORD(qword_140130F08) = 0;
  if ( (unsigned __int64)qword_140130EF8 >= 8 )
    j_free(qword_140130EE0);
  qword_140130EF8 = 7i64;
  qword_140130EF0 = 0i64;
  qword_140130CC0 = (__int64)&CDialogSettings::`vftable';
  LOWORD(qword_140130EE0) = 0;
}
// 1400F7898: using guessed type void *CSplitFileDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 140130CC0: using guessed type __int64 qword_140130CC0;
// 140130EF0: using guessed type __int64 qword_140130EF0;
// 140130EF8: using guessed type __int64 qword_140130EF8;
// 140130F18: using guessed type __int64 qword_140130F18;
// 140130F20: using guessed type __int64 qword_140130F20;

//----- (00000001400E2130) ----------------------------------------------------
void __fastcall sub_1400E2130()
{
  qword_140130150 = (__int64)&CWildcardSelectDialogPersistentSettings::`vftable';
  sub_14000A630((__int64)&qword_140130570);
  j_free(qword_140130570);
  qword_140130150 = (__int64)&CDialogSettings::`vftable';
}
// 1400F7978: using guessed type void *CWildcardSelectDialogPersistentSettings::`vftable';
// 1400F7AE0: using guessed type void *CDialogSettings::`vftable';
// 140130150: using guessed type __int64 qword_140130150;

//----- (00000001400E2170) ----------------------------------------------------
void __fastcall sub_1400E2170()
{
  void **v0; // rbx
  void *v1; // rcx
  void **v2; // rdi

  v0 = *(void ***)qword_14012DFB8;
  *(_QWORD *)qword_14012DFB8 = qword_14012DFB8;
  *((_QWORD *)qword_14012DFB8 + 1) = qword_14012DFB8;
  v1 = qword_14012DFB8;
  qword_14012DFC0 = 0i64;
  if ( v0 != qword_14012DFB8 )
  {
    do
    {
      v2 = (void **)*v0;
      if ( (unsigned __int64)v0[5] >= 8 )
        j_free(v0[2]);
      v0[5] = (void *)7;
      v0[4] = 0i64;
      *((_WORD *)v0 + 8) = 0;
      j_free(v0);
      v1 = qword_14012DFB8;
      v0 = v2;
    }
    while ( v2 != qword_14012DFB8 );
  }
  j_free(v1);
}
// 14012DFC0: using guessed type __int64 qword_14012DFC0;

//----- (00000001400E2210) ----------------------------------------------------
void __fastcall sub_1400E2210()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012E068;
  *(_QWORD *)qword_14012E068 = qword_14012E068;
  *((_QWORD *)qword_14012E068 + 1) = qword_14012E068;
  v1 = qword_14012E068;
  qword_14012E070 = 0i64;
  if ( v0 != qword_14012E068 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012E068;
      v0 = v2;
    }
    while ( v2 != qword_14012E068 );
  }
  j_free(v1);
}
// 14012E070: using guessed type __int64 qword_14012E070;

//----- (00000001400E2280) ----------------------------------------------------
void __fastcall sub_1400E2280()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012E080;
  *(_QWORD *)qword_14012E080 = qword_14012E080;
  *((_QWORD *)qword_14012E080 + 1) = qword_14012E080;
  v1 = qword_14012E080;
  qword_14012E088 = 0i64;
  if ( v0 != qword_14012E080 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012E080;
      v0 = v2;
    }
    while ( v2 != qword_14012E080 );
  }
  j_free(v1);
}
// 14012E088: using guessed type __int64 qword_14012E088;

//----- (00000001400E22F0) ----------------------------------------------------
void __fastcall sub_1400E22F0()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012E098;
  *(_QWORD *)qword_14012E098 = qword_14012E098;
  *((_QWORD *)qword_14012E098 + 1) = qword_14012E098;
  v1 = qword_14012E098;
  qword_14012E0A0 = 0i64;
  if ( v0 != qword_14012E098 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012E098;
      v0 = v2;
    }
    while ( v2 != qword_14012E098 );
  }
  j_free(v1);
}
// 14012E0A0: using guessed type __int64 qword_14012E0A0;

//----- (00000001400E2360) ----------------------------------------------------
void __fastcall sub_1400E2360()
{
  void **v0; // rdx
  void *v1; // rcx
  void **v2; // rbx

  v0 = *(void ***)qword_14012E0B0;
  *(_QWORD *)qword_14012E0B0 = qword_14012E0B0;
  *((_QWORD *)qword_14012E0B0 + 1) = qword_14012E0B0;
  v1 = qword_14012E0B0;
  qword_14012E0B8 = 0i64;
  if ( v0 != qword_14012E0B0 )
  {
    do
    {
      v2 = (void **)*v0;
      j_free(v0);
      v1 = qword_14012E0B0;
      v0 = v2;
    }
    while ( v2 != qword_14012E0B0 );
  }
  j_free(v1);
}
// 14012E0B8: using guessed type __int64 qword_14012E0B8;

//----- (00000001400E23C8) ----------------------------------------------------
void **sub_1400E23C8()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  off_14011B100 = (__int64 (__fastcall *)())&std::error_category::`vftable';
  return result;
}
// 1400E4230: using guessed type void *std::error_category::`vftable';
// 14011B100: using guessed type __int64 (__fastcall *off_14011B100)();

//----- (00000001400E23D8) ----------------------------------------------------
void **sub_1400E23D8()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  off_14011B110 = (__int64 (__fastcall *)())&std::error_category::`vftable';
  return result;
}
// 1400E4230: using guessed type void *std::error_category::`vftable';
// 14011B110: using guessed type __int64 (__fastcall *off_14011B110)();

//----- (00000001400E23E8) ----------------------------------------------------
void **sub_1400E23E8()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  off_14011B120 = (__int64 (__fastcall *)())&std::error_category::`vftable';
  return result;
}
// 1400E4230: using guessed type void *std::error_category::`vftable';
// 14011B120: using guessed type __int64 (__fastcall *off_14011B120)();

//----- (00000001400E23F8) ----------------------------------------------------
void __fastcall sub_1400E23F8()
{
  unknown_libname_18(&unk_14012C090);
}
// 14002B9C8: using guessed type __int64 __fastcall unknown_libname_18(_QWORD);

//----- (00000001400E2404) ----------------------------------------------------
void sub_1400E2404()
{
  sub_140008FC0(&qword_14012C0D0);
}
// 14012C0D0: using guessed type __int64 qword_14012C0D0;

//----- (00000001400E2464) ----------------------------------------------------
void __fastcall sub_1400E2464()
{
  qword_14012C328 = &std::bad_alloc::`vftable';
  sub_14004AEC0((std::exception *)&qword_14012C328);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';

//----- (00000001400E2480) ----------------------------------------------------
void __fastcall sub_1400E2480()
{
  qword_14012C2E0[0] = &std::bad_alloc::`vftable';
  sub_14004AEC0((std::exception *)qword_14012C2E0);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012C2E0: using guessed type _QWORD qword_14012C2E0[3];

//----- (00000001400E249C) ----------------------------------------------------
void __fastcall sub_1400E249C()
{
  unknown_libname_18(&unk_14012C3E0);
}
// 14002B9C8: using guessed type __int64 __fastcall unknown_libname_18(_QWORD);

//----- (00000001400E24E4) ----------------------------------------------------
void __fastcall sub_1400E24E4()
{
  qword_14012C590[0] = &std::bad_alloc::`vftable';
  sub_14004AEC0((std::exception *)qword_14012C590);
}
// 1400E42A8: using guessed type void *std::bad_alloc::`vftable';
// 14012C590: using guessed type _QWORD qword_14012C590[3];

// nfuncs=2904 queued=2128 decompiled=2128 lumina nreq=0 worse=0 better=0
// ALL OK, 2128 function(s) have been successfully decompiled
