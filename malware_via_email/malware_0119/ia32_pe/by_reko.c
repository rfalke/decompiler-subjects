// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr406004 = null; // 00406004
<anonymous> * g_ptr406008 = null; // 00406008
<anonymous> * g_ptr406010 = null; // 00406010
<anonymous> * g_ptr406014 = null; // 00406014
<anonymous> * g_ptr406018 = null; // 00406018
<anonymous> * g_ptr40601C = null; // 0040601C
<anonymous> * g_ptr406020 = null; // 00406020
<anonymous> * g_ptr406024 = null; // 00406024
<anonymous> * g_ptr406028 = null; // 00406028
<anonymous> * g_ptr40602C = null; // 0040602C
<anonymous> * g_ptr406030 = null; // 00406030
<anonymous> * g_ptr406034 = null; // 00406034
<anonymous> * g_ptr406038 = null; // 00406038
Eq_54 g_t40603C = // 0040603C
	{
		0
	};
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_1377 g_a405C60[] = // 00405C60
	{
	};
Eq_1375 g_a405C62[] = // 00405C62
	{
	};
Eq_1379 g_a405C64[] = // 00405C64
	{
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 fp;
	word32 ecx;
	<anonymous> * dwLoc14;
	fn00403640(35100, ecx, dwLoc14);
	Eq_13 eax_26 = fn004035B0();
	if (eax_26 == 0x00)
		return 0x00;
	<anonymous> * eax_42 = fn004034A0(2976162152, ~0x034A2B0F, eax_26);
	g_ptr406014 = eax_42;
	eax_42();
	<anonymous> * eax_68 = fn004034A0(2976162152, 3096863366, eax_26);
	g_ptr406010 = eax_68;
	eax_68();
	g_ptr406028 = fn004034A0(2976162152, 266432455, eax_26);
	<anonymous> * eax_109 = fn004034A0(2976162152, 0x5F21224B, eax_26);
	g_ptr406004 = eax_109;
	word32 eax_126;
	eax_109();
	if (eax_126 == ~0x00)
		return 0x00;
	Eq_54 ecx_139 = g_t40603C.u0;
	struct Eq_57 * ebx_141 = null;
	ui32 * esi_142 = (word32) fp - 15352;
	int32 eax_143 = ecx_139 * 0x04 + 0x04;
	ui32 edi_146 = ~0x27C4E228 << (byte) ecx_139;
	do
	{
		*esi_142 = ebx_141->dw401BC0 ^ edi_146;
		ebx_141 += eax_143 / 4201412;
		esi_142 += (uint32) (0x04 % (ecx_139 - 0x01));
	} while (ebx_141 <= (struct Eq_57 *) 5999);
	struct Eq_87 * edx_169 = null;
	int32 ecx_170 = ecx_139 - 0x01 & 0x04;
	while (true)
	{
		*esi_142 = (0x00 - (word32) (g_t40603C.u0 < 0x01) & 667214377) - 1334428754 ^ edx_169->dw404060;
		byte bLoc88DC_1521 = (byte) ecx_139;
		edx_169 += ecx_170 / 0x00404064;
		int32 eax_191 = (0x00 - (word32) (ecx_139 < 0x01) & ~0x03) + 0x08;
		if (edx_169 > (struct Eq_87 *) 7151)
			break;
		esi_142 += eax_191;
	}
	byte * dwLoc88C4_1522 = (word32) fp - 15352;
	ui32 esi_201 = 0x0108 << bLoc88DC_1521;
	if (esi_201 != 0x00)
	{
		struct Eq_136 * ebx_206 = &fp.u7->aFFFFF768->w0000;
		word16 edx_16_16_1369 = 0x00;
		cui16 dx_2160 = 0x00;
		do
		{
			ebx_206->w0000 = dx_2160;
			byte dl_211 = (byte) dx_2160;
			word32 edx_223 = SEQ(edx_16_16_1369, dx_2160);
			if ((dl_211 & 0x01) == 0x00)
			{
				ebx_206->b0004 = (byte) ((word32) *dwLoc88C4_1522 >> (0x00 - (byte) (ecx_139 < 0x01) & 252) + 0x08);
				edx_16_16_1369 = SLICE(edx_223 + 0x01, word16, 16);
				++ebx_206;
				dx_2160 = SEQ(SLICE(edx_223 + 0x01, byte, 8), dl_211 + 0x01);
				if (edx_223 + 0x01 == esi_201)
					break;
				continue;
			}
			ebx_206->b0004 = *dwLoc88C4_1522 & 0x0F;
			edx_16_16_1369 = SLICE(edx_223 + 0x01, word16, 16);
			++dwLoc88C4_1522;
			++ebx_206;
			dx_2160 = SEQ(SLICE(edx_223 + 0x01, byte, 8), dl_211 + 0x01);
		} while (edx_223 + 0x01 != esi_201);
	}
	int32 eax_252;
	for (eax_252 = 0x02; eax_252 != 0x11; ++eax_252)
		*((word32) (eax_252 - 1) + (fp - 32)) = (int32) 0x00;
	word32 ebx_260 = ~0x088F;
	do
	{
		byte bLoc88DC_1530 = (byte) ecx_139;
		ci8 al_268 = *((word32) (fp - 4) + (ebx_260 + 0x00));
		if (al_268 > 0x00)
		{
			int32 esi_274 = (int32) al_268;
			Eq_228 eax_284 = (uint32) ((uint64) ecx_139 /u (esi_274 | 0x01)) + esi_274;
			Mem286[fp - 32 + eax_284:byte] = Mem283[fp - 32 + eax_284:byte] + 0x01;
		}
		ebx_260 += 0x06;
		ui16 ebx_16_16_299 = SLICE(ebx_260, word16, 16);
	} while (ebx_260 != 0x0EC0);
	int32 edx_296;
	ui32 dwLoc88F8_1531 = 0x00;
	ui32 ebx_302 = SEQ(ebx_16_16_299, 0x01) << bLoc88DC_1530;
	for (edx_296 = 0x01; edx_296 != 0x10; ++edx_296)
	{
		ui32 v30_314 = dwLoc88F8_1531 + (int32) (*((word32) (fp - (ui32 (*)[]) 32) + (edx_296 - 1))) << (byte) ebx_302;
		((word32) (fp - 96) + edx_296 * 0x04)->u0 = ecx_139 ^ v30_314;
		dwLoc88F8_1531 = v30_314;
	}
	word32 ecx_323 = fp + ~0x0893;
	do
	{
		int32 edx_327 = (int32) *ecx_323;
		word32 eax_329 = *((word32) (fp - 96) + edx_327 * 0x04);
		ecx_323.u7->wFFFFFFFE = (word16) eax_329;
		((word32) (fp - 96) + edx_327 * 0x04)->u0 = eax_329 + 0x01;
		ecx_323 += 0x06;
	} while (ecx_323 != fp - 0x0264);
	uint32 ebx_1314;
	byte cl_1375 = 0x00;
	uint32 edx_1319 = 0x00;
	uint32 eax_342 = (ecx_139 << 0x08) + 0x0107;
	if (eax_342 <= 0x00)
	{
		do
		{
			byte * dwLoc88C4_1546 = dwLoc88C4_1522;
			if (cl_1375 == 0x00)
			{
				int32 edi_1068 = 0x80;
				Eq_352 dwLoc88BC_1539 = 0x00;
				Eq_354 ecx_358 = (word32) ecx_139 + 1 << 0x08;
				while (true)
				{
					while (true)
					{
						Eq_54 ebx_1386 = ecx_139;
						int32 esi_1053 = edi_1068;
						int32 edi_366 = 0x00;
						int32 dwLoc88A4_1543 = 0x00;
						Eq_354 dwLoc88C0_1544 = ~0x00;
						do
						{
							byte bLoc88DC_1830 = (byte) ecx_139;
							uint32 edx_374 = (word32) ecx_139 + 1;
							ui32 ecx_375 = 0x00;
							do
							{
								ecx_375 *= 0x02;
								if (((word32) *dwLoc88C4_1546 & esi_1053) != 0x00)
									ecx_375 |= 0x01;
								esi_1053 >>= 0x01;
								if (esi_1053 == 0x00)
								{
									++dwLoc88C4_1546;
									esi_1053 = 0x80;
								}
								--edx_374;
							} while (edx_374 != 0x00);
							int32 v35_429 = dwLoc88A4_1543 << 0x01 | ecx_375;
							ui32 eax_426 = ebx_1386 * 0x03;
							++edi_366;
							dwLoc88A4_1543 = v35_429;
							int32 edx_433 = (int32) *((word32) fp + (eax_426 * 0x02 - 0x0894));
							if (edi_366 > edx_433)
							{
								word32 eax_437 = fp + ~0x0897 + eax_426 * 0x02 + 0x0A;
								do
								{
									edx_433 = (int32) *eax_437;
									ebx_1386 = (word32) ebx_1386.u1 + 1;
									eax_437 += 0x06;
								} while (edi_366 > edx_433);
							}
							if (edi_366 == edx_433)
							{
								ui32 eax_452 = ebx_1386 * 0x03;
								word32 edx_460 = fp + ~0x0897 + eax_452 * 0x02;
								if ((int32) *((word32) fp + (eax_452 * 0x02 - 0x0896)) != v35_429)
								{
									do
									{
										ebx_1386 = (word32) ebx_1386 + 1;
										if ((int32) edx_2164.u7->b000A != edi_366)
											goto l004016BD;
										edx_460.u0 = (word32) edx_2164 + 6;
										edx_2164 = edx_460;
									} while ((int32) edx_2164.u7->w0008 != v35_429);
								}
								int32 eax_487 = (int32) *((word32) fp + (ebx_1386 * 0x06 - 0x0898));
								Eq_354 eax_496 = (uint32) ((uint64) ecx_139 /u (eax_487 | 0x01)) + eax_487;
								dwLoc88C0_1544 = eax_496;
								if (eax_496 >= 0x00)
									break;
								continue;
							}
l004016BD:
						} while (dwLoc88C0_1544 < 0x00);
						byte bLoc88C0_1890 = (byte) dwLoc88C0_1544;
						if (dwLoc88C0_1544 >= (word32) ecx_139 + 0x0100)
							break;
						Mem1309[fp + ~0x8897 + dwLoc88BC_1539:byte] = bLoc88C0_1890;
						edi_1068 = esi_1053;
						++dwLoc88BC_1539;
					}
					if (dwLoc88C0_1544 == ecx_358)
						break;
					word32 eax_1008 = 0x00 - (word32) (ecx_139 < 0x01);
					Eq_532 ecx_1015 = dwLoc88C0_1544 - ((word32) SEQ(SLICE(eax_1008, word16, 16), SLICE(eax_1008, byte, 8) & ~0x01, (byte) eax_1008) + 0x0202);
					int32 eax_1019 = (int32) g_a405C62[ecx_1015];
					uint32 dwLoc88B0_1775 = ~0x00;
					int32 ebx_1021 = (int32) g_a405C60[ecx_1015] & ecx_139 - 0x01;
					if (eax_1019 != ~0x00)
						dwLoc88B0_1775 = (uint32) ((uint64) eax_1019 % (ecx_139 - 0x01));
					int32 dwLoc88B4_1811;
					byte bLoc88DD_1785;
					byte bl_1047;
					ui32 edx_1050;
					word16 cx_1093 = g_a405C64[ecx_1015];
					if (ebx_1021 != 0x00)
					{
						bl_1047 = *dwLoc88C4_1546;
						dwLoc88B4_1811 = ebx_1021;
						edi_1068 = esi_1053 >> 0x01;
						bLoc88DD_1785 = bl_1047;
						edx_1050 = (word32) bl_1047;
					}
					else
					{
						bl_1047 = *dwLoc88C4_1546;
						ui32 eax_1042 = 0x00;
						bLoc88DD_1785 = bl_1047;
						do
						{
							edx_1050 = (word32) bl_1047;
							eax_1042 *= 0x02;
							if ((edx_1050 & esi_1053) != 0x00)
								eax_1042 |= 0x01;
							esi_1053 >>= 0x01;
							if (esi_1053 == 0x00)
							{
								byte * v49_1077 = dwLoc88C4_1546 + 1;
								uint32 v50_1083 = dwLoc88B0_1775 - 0x01;
								bl_1047 = *v49_1077;
								dwLoc88C4_1546 = v49_1077;
								esi_1053 = 0x80;
								edi_1068 = 0x40;
								dwLoc88B0_1775 = v50_1083;
								bLoc88DD_1785 = bl_1047;
								edx_1050 = (word32) bl_1047;
								if (v50_1083 == 0x00)
									break;
								continue;
							}
							uint32 v51_1073 = dwLoc88B0_1775 - 0x01;
							edi_1068 = esi_1053 >> 0x01;
							dwLoc88B0_1775 = v51_1073;
						} while (v51_1073 != 0x00);
						int32 ecx_1097 = (int32) cx_1093 *s ((word32) ecx_139 + 1);
						if (ecx_139 != 0x00)
							ecx_1097 *= 0x02;
						dwLoc88B4_1811 = ecx_1097 + eax_1042;
					}
					int32 dwLoc88F8_1818;
					ui32 eax_1145;
					if (edi_1068 != 0x00)
					{
						eax_1145 = edx_1050;
						dwLoc88F8_1818 = edi_1068 >> 0x01;
					}
					else
					{
						byte * v47_1137 = dwLoc88C4_1546 + 1;
						bl_1047 = *v47_1137;
						dwLoc88C4_1546 = v47_1137;
						edi_1068 = 0x80;
						dwLoc88F8_1818 = 0x40;
						eax_1145 = (word32) bl_1047;
						bLoc88DD_1785 = bl_1047;
					}
					byte bLoc88DC_1878;
					uint32 dwLoc88B8_1821 = 0x07;
					if ((edx_1050 & esi_1053) != 0x00)
					{
						if (dwLoc88F8_1818 == 0x00)
						{
							byte * v41_1173 = dwLoc88C4_1546 + 1;
							dwLoc88C4_1546 = v41_1173;
							dwLoc88F8_1818 = 0x80;
							bLoc88DD_1785 = *v41_1173;
						}
						bl_1047 = bLoc88DD_1785;
						edi_1068 = dwLoc88F8_1818;
						dwLoc88B8_1821 = (uint32) (int8) ((eax_1145 & edi_1068) != 0x00) + (0x08 << bLoc88DC_1830);
						bLoc88DC_1878 = (byte) ecx_139;
					}
					int32 esi_1207 = (int32) g_a405C62[dwLoc88B8_1821];
					uint32 edx_1215 = (uint32) ((uint64) ecx_139 /u (esi_1207 | 0x01)) + esi_1207;
					ui32 esi_1216 = 0x00;
					while (true)
					{
						esi_1216 *= 0x02;
						if (((word32) bl_1047 & edi_1068) != 0x00)
							esi_1216 |= 0x01;
						edi_1068 >>= 0x01;
						if (edi_1068 == 0x00)
						{
							++dwLoc88C4_1546;
							edi_1068 = 0x80;
						}
						--edx_1215;
						if (edx_1215 == 0x00)
							break;
						bl_1047 = *dwLoc88C4_1546;
					}
					word16 ax_1266 = g_a405C64[dwLoc88B8_1821];
					if (dwLoc88B4_1811 > 0x00)
					{
						word32 ebx_1268 = fp + ~0x8897 + dwLoc88BC_1539;
						int32 esi_1276 = 0x00;
						Eq_988 edx_1278 = ebx_1268 - (esi_1216 + ((int32) ax_1266 << bLoc88DC_1878) ^ ecx_139);
						do
						{
							word32 ecx_1282 = (word32) *edx_1278;
							ebx_1268->u0 = ((byte) ecx_139 << (byte) ecx_1282) + (byte) ecx_1282;
							++esi_1276;
							++edx_1278;
							++ebx_1268;
						} while (esi_1276 != dwLoc88B4_1811);
					}
					dwLoc88BC_1539 += (Mem1297[0x0040603C<p32>:word32] + 0x01) *s dwLoc88B4_1811;
				}
				word32 esi_561;
				int32 ebx_589;
				if (dwLoc88BC_1539 > 0x00)
				{
					struct Eq_651 * esi_1415 = (struct Eq_651 *) ~0x00;
					struct Eq_653 * edi_1417 = null;
					Eq_352 ebx_595 = 0x00;
					struct Eq_653 * edx_600 = (SLICE(ecx_139 *64 ~0x0F0F0F0E, word32, 32) >> 0x04) + 0x10;
					do
					{
						ui32 edx_612 = (word32) *((word32) (fp - (ui32 (*)[]) 4) + ((word32) ebx_595 - 0x00008894));
						Eq_672 ecx_623 = (uint32) ((uint64) ecx_139 /u (edx_612 | 0x01)) + edx_612;
						byte cl_662 = (byte) ecx_623;
						if (esi_1415 <= (struct Eq_651 *) 0x43)
						{
							if (edi_1417 < edx_600)
								edi_1417 = (uint32) (int8) (edi_1417->b404000 != cl_662) - 1 & (char *) edi_1417 + 1;
							else
							{
								++esi_1415;
								if (esi_1415 <= (struct Eq_651 *) 0x2F)
								{
									int32 ecx_649 = (int32) esi_1415[0x00404010];
									ecx_623 = (uint32) ((uint64) ecx_139 /u (ecx_649 | 0x01)) + ecx_649;
								}
								else if (esi_1415 <= (struct Eq_651 *) 0x3F)
									ecx_623.u0 = (int32) (esi_1415 - (ecx_139 << 0x30))->b404010;
								else
									ecx_623.u0 = (int32) (esi_1415 - (uint32) (0x40 % (ecx_139 - 0x01)))->b406000;
							}
						}
						ui8 al_685 = (byte) ecx_623;
						if (ecx_139 != 0x00)
							al_685 = (byte) ecx_623 * 0x02;
						((word32) (fp - (ui32 (*)[]) 4) + ((word32) ebx_595 - 0x00008894))->u0 = al_685;
						ebx_595.u0 = (word32) ebx_595 + 1;
					} while (ebx_595 != dwLoc88BC_1539);
					<anonymous> * eax_702 = fn004034A0(2976162152, 2441920163, eax_26);
					g_ptr40602C = eax_702;
					word32 eax_719;
					eax_702();
					<anonymous> * eax_734 = fn004034A0(2976162152, ~0x6A2DD289, eax_26);
					g_ptr406030 = eax_734;
					int32 eax_748;
					eax_734();
					esi_561 = eax_719;
					Eq_352 edx_756 = 0x00;
					ebx_589 = eax_748;
					do
					{
						((word32) edx_756 + eax_748)->u0 = *((word32) (fp - (ui32 (*)[]) 4) + ((word32) edx_756 - 0x00008894));
						edx_756.u0 = (word32) edx_756 + 1;
					} while (edx_756 != dwLoc88BC_1539);
				}
				else
				{
					<anonymous> * eax_533 = fn004034A0(2976162152, 2441920163, eax_26);
					g_ptr40602C = eax_533;
					word32 eax_550;
					eax_533();
					<anonymous> * eax_565 = fn004034A0(2976162152, ~0x6A2DD289, eax_26);
					g_ptr406030 = eax_565;
					int32 eax_579;
					eax_565();
					esi_561 = eax_550;
					ebx_589 = eax_579;
				}
				<anonymous> * eax_778 = fn004034A0(2976162152, 3533983127, eax_26);
				g_ptr406034 = eax_778;
				eax_778();
				<anonymous> * eax_802 = fn004034A0(2976162152, ~0x0C1531BF, eax_26);
				g_ptr406008 = eax_802;
				word32 ecx_815;
				eax_802();
				struct Eq_797 * esp_858;
				g_ptr406008();
				esp_858->t0004.u0 = (ui32 (*)[]) eax_26;
				esp_858->t0000.u0 = ~0x456B9945;
				esp_858->tFFFFFFFC.u0 = 2976162152;
				<anonymous> * eax_869 = fn004034A0(esp_858->tFFFFFFFC.u0, esp_858->t0000.u0, esp_858->t0004.u0);
				esp_858->tFFFFFFFC.u0 = (ui32 (*)[]) (fp - 0x0164);
				g_ptr40601C = eax_869;
				Eq_13 eax_880;
				eax_869();
				esp_858->t0000.u0 = (ui32 (*)[]) eax_26;
				esp_858->tFFFFFFFC.u0 = 2721421706;
				esp_858->tFFFFFFF8.u0 = 2976162152;
				<anonymous> * eax_895 = fn004034A0(esp_858->tFFFFFFF8.u0, esp_858->tFFFFFFFC.u0, esp_858->t0000.u0);
				esp_858->tFFFFFFFC.u0 = (ui32 (*)[]) (fp - 616);
				esp_858->t0000.u0 = 0x0104;
				esp_858->tFFFFFFF8.u0 = 0x00;
				g_ptr406018 = eax_895;
				eax_895();
				esp_858->tFFFFFFF4.u0 = (ui32 (*)[]) eax_880;
				esp_858->tFFFFFFF0.u0 = 3646652680;
				esp_858->tFFFFFFEC.u0 = 2976162152;
				<anonymous> * eax_921 = fn004034A0(esp_858->tFFFFFFEC.u0, esp_858->tFFFFFFF0.u0, esp_858->tFFFFFFF4.u0);
				esp_858->tFFFFFFEC.u0 = (ui32 (*)[]) (fp - 616);
				g_ptr406038 = eax_921;
				eax_921();
				esp_858->tFFFFFFF0.u0 = (ui32 (*)[]) eax_26;
				esp_858->tFFFFFFEC.u0 = 840618587;
				esp_858->tFFFFFFE8.u0 = 2976162152;
				<anonymous> * eax_945 = fn004034A0(esp_858->tFFFFFFE8.u0, esp_858->tFFFFFFEC.u0, esp_858->tFFFFFFF0.u0);
				esp_858->tFFFFFFE8.u0 = (ui32 (*)[]) eax_880;
				g_ptr406020 = eax_945;
				eax_945();
				esp_858->tFFFFFFEC.u0 = (ui32 (*)[]) eax_26;
				esp_858->tFFFFFFE8.u0 = 0x30E1FE37;
				esp_858->tFFFFFFE4.u0 = 2976162152;
				<anonymous> * eax_969 = fn004034A0(esp_858->tFFFFFFE4.u0, esp_858->tFFFFFFE8.u0, esp_858->tFFFFFFEC.u0);
				esp_858->tFFFFFFE4.u0 = 0x00;
				g_ptr406024 = eax_969;
				word32 edx_981;
				eax_969();
				return 0x00;
			}
			cl_1375 = 0x00;
			ebx_1314 = 0x00;
l00401330:
			edx_1319 = ebx_1314;
l00401332:
		} while (edx_1319 >= eax_342);
	}
	word32 edi_1328 = fp - 16 + edx_1319 * 0x06;
	ebx_1314 = edx_1319 + 1;
	Eq_333 al_1333 = edi_1328.u7->tFFFFF77C.u0;
	word32 eax_1337 = fp - 16 + ebx_1314 * 0x06;
	if (al_1333 > ((eax_1337.u7)->tFFFFF77C).u0)
	{
		word16 dx_1354 = edi_1328.u7->wFFFFF77A;
		Eq_365 cx_1359 = edi_1328.u7->tFFFFF778.u0;
		edi_1328.u7->tFFFFF778.u1 = eax_1337.u7->tFFFFF778.u1;
		edi_1328.u7->tFFFFF77C.u1 = eax_1337.u7->tFFFFF77C.u1;
		eax_1337.u7->wFFFFF77A = dx_1354;
		eax_1337.u7->tFFFFF77C.u0 = (ci8) al_1333;
		eax_1337.u7->tFFFFF778.u0 = (word16) cx_1359;
		cl_1375 = 0x01;
		edx_1319 = ebx_1314;
		goto l00401332;
	}
	goto l00401330;
}

// 00403350: Register int32 fn00403350(Stack int32 dwArg04, Stack Eq_1060 dwArg08, Stack (ptr32 byte) dwArg0C)
// Called from:
//      fn00403350
//      fn00403420
int32 fn00403350(int32 dwArg04, Eq_1060 dwArg08, byte * dwArg0C)
{
	ptr32 fp;
	Eq_54 edx_9 = g_t40603C.u0;
	int32 edi_16 = dwArg04;
	int32 ecx_21 = (0x00 - (word32) (edx_9 < 0x01) & ~0x63) + 200;
	byte bl_26 = *dwArg0C;
	if (bl_26 != 0x00)
	{
		int32 eax_65 = fn00403350((word32) bl_26 + dwArg08 *s dwArg04, ((uint32) (100 % (edx_9 - 1)) *s (((word32) edx_9 + 1) *s 0x55 + (0x25 << (byte) edx_9) *s ecx_21) + (edx_9 - 1 & 0x33)) *s dwArg08, dwArg0C + 1);
		<anonymous> * eax_71 = g_ptr406028;
		if (eax_71 != null)
			eax_71();
		edi_16 = eax_65;
	}
	return edi_16;
}

// 00403420: Register ui32 fn00403420(Stack Eq_13 dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn004034A0
ui32 fn00403420(Eq_13 dwArg04, byte * dwArg08)
{
	Eq_54 esi_16 = g_t40603C.u0;
	Eq_1120 edx_23 = SLICE(esi_16 *64 98685563, word32, 32);
	Eq_1124 edx_33 = SLICE(esi_16 *64 0x04104105, word32, 32);
	return dwArg04 ^ fn00403350(0x00, (((word32) ((word32) edx_23 + (esi_16 - edx_23 >> 0x01) >> 0x09) + 1000) *s ((word32) ((word32) edx_33 + (esi_16 - edx_33 >> 0x01) >> 0x05) + 63) + 0x02B1) + (SLICE(esi_16 *64 797903939, word32, 32) >> 0x07), dwArg08);
}

// 004034A0: Register ptr32 fn004034A0(Stack Eq_13 dwArg04, Stack Eq_13 dwArg08, Stack Eq_13 dwArg0C)
// Called from:
//      Win32CrtStartup
ptr32 fn004034A0(Eq_13 dwArg04, Eq_13 dwArg08, Eq_13 dwArg0C)
{
	uint32 esi_41;
	Eq_54 ebx_107 = g_t40603C.u0;
	word32 edi_33 = dwArg0C *s (ebx_107 + 1) + Mem17[(CONVERT(CONVERT(ebx_107, word32, uint64) /u (dwArg0C | 0x01), word32, uint32) + 0x0078) + (dwArg0C + Mem17[dwArg0C + 60:word32]):word32];
	word32 eax_34 = edi_33->dw0020;
	word32 ecx_35 = edi_33->dw0024;
	if (eax_34 != ~0x00)
		esi_41 = (uint32) ((uint64) eax_34 % (ebx_107 - 1));
	else
		esi_41 = ~0x00;
	if ((edi_33->dw0018 & ebx_107 - 1) != 0x00)
	{
		word32 esi_63[] = dwArg0C.u0 + esi_41 / 4;
		ui32 eax_66 = (dwArg0C << (byte) ebx_107) + ecx_35;
		uint32 esi_114 = 0x00;
		do
		{
			word16 * edx_83 = eax_66 + esi_114 * 0x02;
			word32 eax_85 = esi_63[esi_114];
			Eq_13 edx_86 = dwArg04;
			if (ebx_107 != 0x00)
				edx_86 = dwArg04 * 0x02;
			int32 eax_99 = fn00403420(edx_86, dwArg0C.u0 + eax_85 / 4);
			ebx_107.u0 = g_t40603C.u0;
			if (eax_99 == ((word32) ebx_107.u0 + 1) *s dwArg08)
			{
				int32 (* ecx_139)[][] = dwArg0C.u0 + edi_33->dw001C / 4;
				word32 esi_145 = dwArg0C + Mem98[(ecx_139 + CONVERT(Mem98[edx_83 + 0x00:word16], word16, word32) * 0x04) + (ebx_107 << SLICE(ecx_139, byte, 0)):word32];
				return (word32) esi_145 + (uint32) ((uint64) ebx_107 /u (esi_145 | 0x01));
			}
			++esi_114;
		} while ((ebx_107 - 1 & edi_33->dw0018) > esi_114);
	}
	return 0x00;
}

// 004035B0: Register ui32 fn004035B0()
// Called from:
//      Win32CrtStartup
ui32 fn004035B0()
{
	struct Eq_1268 * fs;
	Eq_54 esi_20 = g_t40603C.u0;
	uint32 eax_27 = *((word32) esi_20 + (((fs->ptr0018)->dw0030 ^ esi_20)->dw000C + 28));
	byte dl_98 = (byte) (0x6B % (esi_20 - 1));
	struct Eq_1292 * ebx_37 = eax_27 >> (byte) esi_20;
	ui8 bLoc18_121 = ((byte) esi_20 << 101) + 101;
	do
	{
		ui32 eax_124;
		struct Eq_1302 * ecx_48 = ebx_37->dw0020 & esi_20 - 1;
		if (ecx_48->b0000 == dl_98 && (ecx_48->b0002 == bLoc18_121 && ecx_48->b0004 == ((byte) esi_20 ^ 114)))
		{
			eax_124 = ebx_37->dw0008 | esi_20;
			return eax_124;
		}
		ebx_37 = ebx_37->dw0000 >> (byte) esi_20;
	} while (eax_27 != ebx_37->dw0000);
	eax_124 = 0x00;
	return eax_124;
}

// 00403640: void fn00403640(Register uint32 eax, Register word32 ecx, Stack (ptr32 code) dwArg00)
// Called from:
//      Win32CrtStartup
void fn00403640(uint32 eax, word32 ecx, <anonymous> * dwArg00)
{
	ptr32 fp;
	struct Eq_1338 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	dwArg00();
}

