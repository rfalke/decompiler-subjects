// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_2 g_t407000 = // 00407000
	{
		&g_a41E2
	};
Eq_2 g_t407004 = // 00407004
	{
		&g_a5600
	};
Eq_1076 g_a407008[] = // 00407008
	{
	};
Eq_2 g_t40B328 = // 0040B328
	{
		null
	};
word32 g_dw40B32C = 0x00; // 0040B32C
Eq_2 g_t40B330 = // 0040B330
	{
		null
	};
word32 g_dw40B334 = 0x00; // 0040B334
Eq_2 g_t40B338 = // 0040B338
	{
		null
	};
ptr32 g_ptr40B33C = 0x00; // 0040B33C
word32 g_dw40B340 = 0x00; // 0040B340
Eq_2 g_t40B344 = // 0040B344
	{
		null
	};
word32 g_dw40B348 = 0x00; // 0040B348
struct Eq_157 * g_ptr40B34C = null; // 0040B34C
<anonymous> * g_ptr40B350 = null; // 0040B350
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetModuleHandleA = &g_t1D0C; // 00401000
<anonymous> * __imp__CreateFileA = &g_t1D20; // 00401004
<anonymous> * __imp__lstrcatA = &g_t1D2E; // 00401008
<anonymous> * __imp__GetProcAddress = &g_t1D3A; // 0040100C
<anonymous> * __imp__LoadLibraryA = &g_t1D4C; // 00401010
<anonymous> * __imp__CloseHandle = &g_t1D5C; // 00401014
<anonymous> * __imp__VirtualAlloc = &g_t1D6A; // 00401018
<anonymous> * __imp__lstrcpyA = &g_t1D7A; // 0040101C
// 00401030: void fn00401030(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00401380
//      fn004019C0
void fn00401030(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	g_t40B330.u0 = 0x00;
	while (g_t40B330.u0 < dwArg0C)
	{
		Mem23[dwArg04 + Mem9[0x0040B330<p32>:word32]:byte] = Mem9[dwArg08 + Mem9[0x0040B330<p32>:word32]:byte];
		g_t40B330.u0 = (Eq_932 (*)[]) ((char *) g_t40B330.u0 + 1);
	}
}

// 004010C0: Register Eq_20 Win32CrtStartup()
Eq_20 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebx;
	word32 esi;
	word32 edi;
	struct Eq_25 * fs;
	Eq_26 tLoc74;
	Eq_2 dwArg04;
	GetProcAddress(LoadLibraryA(0x0040B204), 0x0040B1EC)();
	lstrcatA(&tLoc74, 0x0040B214);
	Eq_2 eax_67 = CreateFileA(&tLoc74, 0x01, 0x03, null, 0x03, 0x80, 0x00);
	if (eax_67 == ~0x00 || eax_67 == 0x00)
		return 0x00;
	if (GetProcAddress(LoadLibraryA(0x0040B230), 0x0040B224)() != 0x00 || (GetProcAddress)(LoadLibraryA(0x0040B254), 4239944)() == 0x00)
		return 0x00;
	Eq_2 eax_132 = GetModuleHandleA(0x00);
	if ((dwArg04 & 0xFFFF) != 0x00)
		g_dw40B348 = 0x00;
	else
		g_dw40B348 = 0x01;
	if (dwArg04 == 0x00)
	{
		g_dw40B348 = 0x01;
		--g_dw40B348;
	}
	if (g_dw40B348 != 0x00)
		g_t40B338.u0 = (Eq_932 (*)[]) dwArg04;
	Eq_2 edx_167 = g_t407000.u0;
	Eq_2 ecx_170 = g_t407004.u0;
	Eq_2 dwLoc08_367 = 0x00;
	while (dwLoc08_367 < edx_167)
	{
		dwLoc08_367.u9[0x00080E01] = (struct Eq_1115) (dwLoc08_367.u9[0x00080E01] ^ 11152423);
		&dwLoc08_367.u0->u0 = (word32) dwLoc08_367 + 8;
	}
	fn00401990(ecx_170);
	g_t40B344.u0 = (Eq_932 (*)[]) dwLoc08_367;
	fn00401B60(g_a407008, g_t40B344.u0, edx_167);
	g_dw40B334 = edi;
	g_dw40B32C = esi;
	g_dw40B340 = ebx;
	g_ptr40B34C = fs->ptr0018;
	g_ptr40B33C = fp - 4;
	if (g_dw40B348 != 0x00)
		fn004019C0(4199198 - dwArg04, dwArg04);
	else
		fn004019C0(4199198 - eax_132, eax_132);
	fn00401380(g_t40B344.u0);
	Eq_20 eax_279;
	g_ptr40B350();
	return eax_279;
}

// 00401360: void fn00401360(Stack Eq_2 dwArg04, Stack Eq_31 dwArg08)
// Called from:
//      fn00401380
void fn00401360(Eq_2 dwArg04, Eq_31 dwArg08)
{
	GetProcAddress(dwArg04, dwArg08);
}

// 00401380: void fn00401380(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00401380(Eq_2 dwArg04)
{
	ptr32 fp;
	Eq_26 tLocB4;
	lstrcpyA(&tLocB4, 0x0040B274);
	word32 eax_23 = dwArg04 + Mem20[dwArg04 + 60:word32];
	struct Eq_217 * dwLoc2C_721 = &eax_23->w0014 + 2 + (word32) eax_23->w0014 / 84;
	Eq_2 eax_40 = VirtualAlloc(0x00, eax_23->t0050.u0, 0x3000, 0x40);
	if (eax_40 == 0x00)
		return;
	fn00401030(eax_40, dwArg04, (word32) dwArg04.u6[0x0F].dw003C + 252 + (word32) eax_23->w0006 *s 0x28);
	Eq_38 eax_75 = GetProcAddress(GetModuleHandleA(4240024), 4240008);
	Eq_38 eax_86 = GetProcAddress(GetModuleHandleA(4240060), 4240040);
	up32 dwLoc10_738;
	for (dwLoc10_738 = 0x00; dwLoc10_738 < (word32) eax_23->w0006; ++dwLoc10_738)
	{
		if (dwLoc2C_721->dw0014 != 0x00 && dwLoc2C_721->dw0010 != 0x00)
			fn00401030(eax_40 + Mem657[dwLoc2C_721 + 0x0C:word32], dwArg04 + Mem652[dwLoc2C_721 + 20:word32], CONVERT(CONVERT(Mem91[dwLoc2C_721 + 16:word32] - 1 + Mem91[eax_23 + 60:word32], word32, uint64) /u Mem91[eax_23 + 60:word32], word32, uint32) *s Mem91[eax_23 + 60:word32]);
		++dwLoc2C_721;
	}
	word32 ecx_100 = eax_40 + Mem97[eax_40 + 60:word32];
	Eq_2 eax_121 = eax_86();
	if (eax_121 == 0x00)
		return;
	Eq_2 eax_133 = GetModuleHandleA(4240088);
	fn00401360(eax_133, 0x0040B2CC);
	word32 dwLocC0_755 = eax_40 + Mem139[ecx_100 + 0x80:word32];
	while (dwLocC0_755.u0[4] != 0x00)
	{
		Eq_355 dwLoc38_812;
		Eq_356 dwLoc28_811;
		word32 eax_524 = LoadLibraryA(eax_40 + Mem146[dwLocC0_755 + 0x0C:word32]);
		if (dwLocC0_755.u1->t0000.u0 != 0x00)
		{
			dwLoc28_811 = eax_40 + Mem526[dwLocC0_755 + 0x00:word32];
			dwLoc38_812 = eax_40 + Mem542[dwLocC0_755 + 16:word32];
		}
		else
		{
			dwLoc28_811 = eax_40 + Mem526[dwLocC0_755 + 16:word32];
			dwLoc38_812 = eax_40 + Mem533[dwLocC0_755 + 0x00:word32];
		}
		word32 dwLoc1C_815 = 0x00;
		if (dwLocC0_755.u0[4] != 0x00 && ((dwLocC0_755.u1)->t0000).u0 != 0x00)
			dwLoc1C_815 = 0x01;
		while (dwLoc28_811.u1->t0000.u0 != 0x00)
		{
			if ((dwLoc28_811.u1->t0000.u0 & 0x80000000) != 0x00)
			{
				ui32 eax_589 = dwLoc28_811.u1->t0000.u0;
				fn00401360(eax_524, eax_589 & 0x7FFFFFFF);
				dwLoc28_811.u1->t0000.u0 = eax_589 & 0x7FFFFFFF;
			}
			else
			{
				word32 eax_576 = Mem558[dwLoc28_811 + 0x00:word32] + 2 + eax_40;
				fn00401360(eax_524, eax_576);
				dwLoc28_811.u1->t0000.u0 = (struct Eq_1129 *) eax_576;
			}
			if (dwLoc28_811.u1->t0000.u0 == 0x00)
				return;
			if (dwLoc1C_815 != 0x00)
				dwLoc38_812.u1->t0000.u0 = dwLoc28_811.u1->t0000.u0;
			dwLoc28_811 += 0x04;
			dwLoc38_812 += 0x04;
		}
		dwLocC0_755 += 0x14;
	}
	if (g_dw40B348 != 0x00)
	{
		word32 edx_154 = g_t40B338.u0 - ((ecx_100.u0)->t0034).u0;
		if (ecx_100.u0->dw00A4 != 0x00)
		{
			word32 dwLoc24_760 = eax_40 + Mem155[ecx_100 + 0xA0:word32];
			while (dwLoc24_760.u0[1] != 0x00)
			{
				uint32 edx_472 = dwLoc24_760.u0[1] - 0x08 >> 0x01;
				word32 dwLocB8_799 = dwLoc24_760 + 0x08;
				uint32 dwLoc10_800;
				for (dwLoc10_800 = 0x00; dwLoc10_800 < edx_472; ++dwLoc10_800)
				{
					if ((word32) *((word32) dwLocB8_799 + dwLoc10_800 * 0x02) >> 0x0C == 0x03)
						Mem512[eax_40 + Mem480[dwLoc24_760 + 0x00:word32] + (CONVERT(dwLocB8_799[dwLoc10_800 * 0x02], word16, word32) & 0x0FFF):word32] = Mem480[eax_40 + Mem480[dwLoc24_760 + 0x00:word32] + (CONVERT(dwLocB8_799[dwLoc10_800 * 0x02], word16, word32) & 0x0FFF):word32] + edx_154;
				}
				dwLoc24_760 += Mem480[dwLoc24_760 + 4:word32];
			}
		}
	}
	Eq_38 eax_180 = GetProcAddress(GetModuleHandleA(4240120), 4240104);
	if (g_dw40B348 != 0x00)
		g_t40B328.u0 = (Eq_932 (*)[]) eax_180();
	else
		g_t40B328.u0 = (Eq_932 (*)[]) eax_180();
	struct Eq_556 * esp_243 = fp - 244;
	if (g_t40B328.u0 == 0x00)
	{
		ptr32 esp_248;
		if (g_dw40B348 != 0x00)
		{
			esp_248 = fp - 0xF8;
			if (eax_75() == 0x00)
			{
				Eq_2 edx_297 = g_t40B338.u0;
				word32 eax_301;
				eax_133();
				if (eax_301 == 0x00)
					return;
			}
		}
		else
		{
			esp_248 = fp - 0xF8;
			if (eax_75() == 0x00)
			{
				Eq_2 eax_263 = ecx_100.u0->t0034.u0;
				word32 eax_267;
				eax_133();
				if (eax_267 == 0x00)
					return;
			}
		}
		if (g_dw40B348 != 0x00)
		{
			struct Eq_705 * esp_345 = esp_248 - 4;
			esp_345->t0000.u0 = g_t40B338.u0;
			esp_345->dwFFFFFFFC = 0x00;
			esp_345->dwFFFFFFF8 = 0x00;
			esp_345->dwFFFFFFF4 = 0x00;
			esp_345->dwFFFFFFF0 = 0x22;
			esp_345->tFFFFFFEC.u0 = (Eq_932 (*)[]) eax_121;
			g_t40B328.u0 = (Eq_932 (*)[]) eax_180();
		}
		else
		{
			struct Eq_675 * esp_320 = esp_248 - 4;
			esp_320->t0000.u0 = ecx_100.u0->t0034.u0;
			esp_320->dwFFFFFFFC = 0x00;
			esp_320->dwFFFFFFF8 = 0x00;
			esp_320->dwFFFFFFF4 = 0x00;
			esp_320->dwFFFFFFF0 = 0x22;
			esp_320->tFFFFFFEC.u0 = (Eq_932 (*)[]) eax_121;
			g_t40B328.u0 = (Eq_932 (*)[]) eax_180();
		}
		esp_243 = esp_248 - 24;
		if (g_t40B328.u0 == 0x00)
		{
			if (g_dw40B348 == 0x00)
			{
				esp_243->tFFFFFFFC = 0x40;
				esp_243->tFFFFFFF8 = 0x3000;
				esp_243->tFFFFFFF4.u0 = ecx_100.u0->t0050.u0;
				esp_243->tFFFFFFF0.u0 = ecx_100.u0->t0034.u0;
				g_t40B328.u0 = (Eq_932 (*)[]) VirtualAlloc(esp_243->tFFFFFFF0, esp_243->tFFFFFFF4.u0, esp_243->tFFFFFFF8, esp_243->tFFFFFFFC);
			}
			else
			{
				esp_243->tFFFFFFFC = 0x40;
				esp_243->tFFFFFFF8 = 0x3000;
				esp_243->tFFFFFFF4.u0 = ecx_100.u0->t0050.u0;
				esp_243->tFFFFFFF0.u0 = g_t40B338.u0;
				g_t40B328.u0 = (Eq_932 (*)[]) VirtualAlloc(esp_243->tFFFFFFF0, esp_243->tFFFFFFF4.u0, esp_243->tFFFFFFF8, esp_243->tFFFFFFFC);
			}
		}
	}
	struct Eq_562 * esp_405 = esp_243 - 4;
	esp_405->t0000.u0 = (Eq_932 (*)[]) eax_121;
	CloseHandle(esp_405->t0000);
	esp_405->t0000.u0 = ecx_100.u0->t0050.u0;
	esp_405->tFFFFFFFC.u0 = (Eq_932 (*)[]) eax_40;
	esp_405->tFFFFFFF8.u0 = g_t40B328.u0;
	fn00401030(esp_405->tFFFFFFF8.u0, esp_405->tFFFFFFFC.u0, esp_405->t0000.u0);
	if (g_dw40B348 != 0x00)
	{
		Mem440[esp_405 + 0x00:word32] = Mem418[0x0040B328<p32>:word32] + Mem418[ecx_100 + 40:word32];
		esp_405->tFFFFFFFC.u0 = g_t40B338.u0;
		fn00401920(esp_405->tFFFFFFFC.u0, esp_405->t0000.u0);
	}
	else
	{
		esp_405->t0000.u0 = g_t40B328.u0;
		fn00401B30(esp_405->t0000.u0);
	}
	Mem460[0x0040B350<p32>:word32] = Mem455[0x0040B328<p32>:word32] + Mem455[ecx_100 + 40:word32];
	ecx_100.u0->ptr0028 = g_ptr40B350;
}

// 00401920: void fn00401920(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00401380
void fn00401920(Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_819 * ecx_15 = g_ptr40B34C->ptr0030->ptr000C->ptr000C;
	struct Eq_819 * dwLoc0C_61 = ecx_15;
	while (dwLoc0C_61 != null)
	{
		if (dwLoc0C_61->t0018.u0 == dwArg04)
		{
			dwLoc0C_61->t001C.u0 = (Eq_932 (*)[]) dwArg08;
			return;
		}
		struct Eq_819 * eax_37 = dwLoc0C_61->ptr0000;
		dwLoc0C_61 = eax_37;
		if (eax_37 == ecx_15)
			return;
	}
}

// 00401990: void fn00401990(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00401990(Eq_2 dwArg04)
{
	VirtualAlloc(0x00, dwArg04, 0x3000, 0x04);
}

// 004019C0: void fn004019C0(Stack ptr32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      Win32CrtStartup
void fn004019C0(ptr32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 dwLoc28_173;
	if (g_dw40B348 != 0x00)
		&dwLoc28_173.u0->u0 = g_t40B338.u0;
	else
		dwLoc28_173 = dwArg08;
	struct Eq_860 * ecx_24 = &(dwLoc28_173.u0 + ((dwLoc28_173.u0))[0x0F].u0 / 4)->u0;
	g_t40B328.u0 = (Eq_932 (*)[]) GetProcAddress(GetModuleHandleA(4240152), 0x0040B308)();
	if (g_t40B328.u0 == 0x00)
		return;
	fn00401030(g_t40B328.u0, dwLoc28_173, ecx_24->t0050.u0);
	int32 edx_77 = g_t40B328.u0 - dwLoc28_173;
	if (ecx_24->dw00A4 != 0x00)
	{
		word32 dwLoc0C_188 = dwLoc28_173 + Mem78[ecx_24 + 0xA0:word32];
		while (dwLoc0C_188.u1->t0004.u0 != 0x00)
		{
			uint32 edx_112 = dwLoc0C_188.u1->t0004.u0 - 0x08 >> 0x01;
			word32 dwLoc20_195 = dwLoc0C_188 + 0x08;
			uint32 dwLoc08_196;
			for (dwLoc08_196 = 0x00; dwLoc08_196 < edx_112; ++dwLoc08_196)
			{
				if ((word32) *((word32) dwLoc20_195 + dwLoc08_196 * 0x02) >> 0x0C == 0x03)
					Mem152[Mem120[0x0040B328<p32>:word32] + Mem120[dwLoc0C_188 + 0x00:word32] + (CONVERT(dwLoc20_195[dwLoc08_196 * 0x02], word16, word32) & 0x0FFF):word32] = Mem120[Mem120[0x0040B328<p32>:word32] + Mem120[dwLoc0C_188 + 0x00:word32] + (CONVERT(dwLoc20_195[dwLoc08_196 * 0x02], word16, word32) & 0x0FFF):word32] + edx_77;
			}
			dwLoc0C_188 += Mem120[dwLoc0C_188 + 4:word32];
		}
	}
	<anonymous> * ecx_95 = &(g_t40B328.u0 + dwArg04 / 4)->u0;
	ecx_95();
}

// 00401B30: void fn00401B30(Stack Eq_2 dwArg04)
// Called from:
//      fn00401380
void fn00401B30(Eq_2 dwArg04)
{
	g_ptr40B34C->ptr0030->t0008.u0 = (Eq_932 (*)[]) dwArg04;
}

// 00401B60: void fn00401B60(Stack (ptr32 byte) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn00401B60(byte * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_970 tLoc20;
	Eq_971 tLoc10;
	Eq_2 dwLoc0C_129 = 0x01;
	byte cl_12 = *dwArg04;
	int32 dwLoc18_132 = 0x00;
	do
	{
		byte al_19 = Mem16[dwArg04 + dwLoc0C_129:byte];
		&dwLoc0C_129.u0->u0 = (word32) dwLoc0C_129 + 1;
		if ((word32) al_19 == (word32) cl_12)
		{
			if ((word32) dwArg04[(word32) dwLoc0C_129 + 1] == 0x00)
			{
				dwArg08.u7[dwLoc18_132] = cl_12;
				++dwLoc18_132;
				&dwLoc0C_129.u0->u0 = (word32) dwLoc0C_129 + 2;
			}
			else
			{
				int32 eax_60 = fn00401C60(&tLoc10, dwArg04 + ((word32) dwLoc0C_129 + 1)) + ((word32) dwLoc0C_129 + 1);
				dwLoc0C_129 = fn00401C60(&tLoc20, dwArg04 + eax_60) + eax_60;
				up32 dwLoc1C_147;
				for (dwLoc1C_147 = 0x00; dwLoc1C_147 < tLoc10; ++dwLoc1C_147)
				{
					dwArg08.u7[dwLoc18_132] = dwArg08.u7[dwLoc18_132 - tLoc20];
					++dwLoc18_132;
				}
			}
		}
		else
		{
			dwArg08.u7[dwLoc18_132] = al_19;
			++dwLoc18_132;
		}
	} while (dwLoc0C_129 < dwArg0C);
}

// 00401C60: Register word32 fn00401C60(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn00401B60
word32 fn00401C60(ui32 * dwArg04, byte * dwArg08)
{
	ui32 dwLoc08_44 = 0x00;
	word32 dwLoc10_45 = 0x00;
	do
	{
		ui32 ecx_15 = (word32) *dwArg08;
		ui32 ecx_25 = ecx_15 & 0x7F | dwLoc08_44 << 0x07;
		++dwArg08;
		dwLoc08_44 = ecx_25;
		++dwLoc10_45;
	} while ((ecx_15 & 0x80) != 0x00);
	*dwArg04 = ecx_25;
	return dwLoc10_45;
}

word32 g_dw401CE8 = 0x1D0C; // 00401CE8
word32 g_dw401CEC = 0x1D20; // 00401CEC
word32 g_dw401CF0 = 7470; // 00401CF0
word32 g_dw401CF4 = 0x1D3A; // 00401CF4
word32 g_dw401CF8 = 7500; // 00401CF8
word32 g_dw401CFC = 0x1D5C; // 00401CFC
word32 g_dw401D00 = 0x1D6A; // 00401D00
word32 g_dw401D04 = 0x1D7A; // 00401D04
