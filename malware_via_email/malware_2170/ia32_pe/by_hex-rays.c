/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall sub_401000(int, int);
int __stdcall sub_401067(int);
HANDLE __stdcall sub_40112F(HINSTANCE hInst, BOOL bInitialState, LPCWSTR lpName, LPSECURITY_ATTRIBUTES lpEventAttributes);
// _DWORD *__userpurge sub_401466@<eax>(int@<edi>, _BYTE *, _DWORD *);
int __fastcall sub_40153A(int, _BYTE *);
void __stdcall sub_401584(_DWORD *, unsigned int, int);
// int __userpurge sub_4015D5@<eax>(unsigned int@<ebx>, _DWORD *, int, _DWORD *);
// void *__userpurge sub_40168F@<eax>(struct _SECURITY_ATTRIBUTES *lpEventAttributes, SIZE_T dwSize, int, HANDLE);
unsigned int __stdcall sub_4016F1(unsigned int);
// int __userpurge sub_401713@<eax>(int@<eax>, int);
int sub_40181B();
// HANDLE __userpurge ZfXtnlxWyhustKrybOty@<eax>(char@<bh>, __int16, HINSTANCE hInst, BOOL bInitialState, const WCHAR *lpszName);
int __stdcall sub_401901(_BYTE *);
struct _LIST_ENTRY *sub_40192D();
// int __usercall sub_40195A@<eax>(char *a1@<edx>, _BYTE *a2@<ecx>, int a3@<edi>);
// int __usercall IigGbliiYnqdwsdIovvTm@<eax>(char@<al>, _BYTE *@<ecx>, int@<edi>, int@<esi>);
// int __usercall sub_401996@<eax>(int *@<esi>);
_DWORD __stdcall sub_401A52(_DWORD, _DWORD, _DWORD); // weak
// unsigned int __userpurge KaqKcgzYxmcfxqXq@<eax>(_DWORD *@<ebp>, int@<esi>, int, int, int);
_BYTE *__stdcall sub_401AC8(int a1, int a2);
// _BYTE *__userpurge SzfkIjqwtBv@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, int a5, int a6);
_BYTE *__cdecl sub_401C1D(int a1, int a2);
// _BYTE *__userpurge CapPyyfdoxHghkvPrpqfoo@<eax>(int a1@<ebp>, int a2, int a3);

//-------------------------------------------------------------------------
// Data declarations

// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *CommConfigDialogW)(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern int (__cdecl *is_wctype)(wint_t C, wctype_t Type);
// extern char *(__cdecl *getenv)(const char *VarName);
// extern void *(__cdecl *memcpy)(void *, const void *Src, size_t Size);
// extern HANDLE (__stdcall *LoadImageA)(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);


//----- (00401000) --------------------------------------------------------
int __fastcall sub_401000(int a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // edi
  unsigned int i; // esi
  int v6; // esi
  unsigned int j; // edx

  v2 = *(_DWORD *)(a2 + *(_DWORD *)(a2 + 60) + 120);
  if ( v2 )
  {
    v3 = (_DWORD *)(a2 + v2);
    v3[7] += a1;
    v3[9] += a1;
    v3[8] += a1;
    v3[3] += a1;
    v4 = v3[7] + a2;
    for ( i = 0; i < v3[5]; ++i )
      *(_DWORD *)(v4 + 4 * i) += a1;
    v6 = a2 + v3[8];
    for ( j = 0; j < v3[6]; ++j )
      *(_DWORD *)(v6 + 4 * j) += a1;
  }
  return 1;
}

//----- (00401067) --------------------------------------------------------
int __stdcall sub_401067(int a1)
{
  int v1; // edi
  int v2; // eax
  int v4; // ebx
  _DWORD *v5; // eax
  int v6; // esi
  int *v7; // esi
  int *v8; // edi
  _BYTE *v9; // eax
  HMODULE LibraryA; // [esp+62h] [ebp-Ch]
  int v11; // [esp+66h] [ebp-8h]
  int v12; // [esp+6Ah] [ebp-4h]

  v1 = a1;
  v2 = *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 128);
  if ( !v2 )
    return 1;
  v11 = 0;
  v4 = v2 + a1;
  v5 = (_DWORD *)(v2 + a1 + 12);
  if ( !*v5 )
    return 1;
  v6 = v4;
  while ( 1 )
  {
    LibraryA = LoadLibraryA((LPCSTR)(v1 + *v5));
    if ( !LibraryA )
      return 0;
    v12 = 0;
    v7 = (int *)(v1 + *(_DWORD *)(v6 + 16));
    if ( *v7 )
    {
      v8 = v7;
      while ( 1 )
      {
        v9 = sub_401AC8((int)LibraryA, *v8);
        if ( !v9 )
          return 0;
        ++v12;
        *v8 = (int)v9;
        v8 = &v7[v12];
        if ( !*v8 )
        {
          v1 = a1;
          break;
        }
      }
    }
    ++v11;
    v6 = 20 * v11 + v4;
    v5 = (_DWORD *)(v6 + 12);
    if ( !*(_DWORD *)(v6 + 12) )
      return 1;
  }
}

//----- (0040112F) --------------------------------------------------------
HANDLE __stdcall sub_40112F(
        HINSTANCE hInst,
        BOOL bInitialState,
        LPCWSTR lpName,
        LPSECURITY_ATTRIBUTES lpEventAttributes)
{
  HINSTANCE ModuleHandleA; // eax
  HANDLE ImageA; // esi
  DWORD LastError; // eax
  struct _SECURITY_ATTRIBUTES *v7; // eax
  struct _SECURITY_ATTRIBUTES *v8; // esi
  _DWORD *v10; // eax
  int v11; // edi
  int v12; // esi
  int v13; // ebx
  char *v14; // esi
  int v15; // eax
  struct _LIST_ENTRY *v16; // eax
  void (__stdcall *v17)(int, int, int, char *); // eax
  int v18; // edi
  unsigned int v19; // edx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  _BYTE *v23; // ecx
  _DWORD *v24; // eax
  __int16 v25; // ax
  unsigned int v26; // edx
  _DWORD *v27; // eax
  const void *v28; // esi
  _DWORD v29[11]; // [esp-3Ch] [ebp-ACh] BYREF
  int v30; // [esp-10h] [ebp-80h]
  int v31; // [esp-Ch] [ebp-7Ch]
  HANDLE v32; // [esp-8h] [ebp-78h]
  int v33[11]; // [esp+0h] [ebp-70h] BYREF
  char v34[16]; // [esp+2Ch] [ebp-44h] BYREF
  char v35[16]; // [esp+3Ch] [ebp-34h] BYREF
  char v36[4]; // [esp+4Ch] [ebp-24h] BYREF
  LPVOID lpAddress; // [esp+50h] [ebp-20h]
  int v38; // [esp+54h] [ebp-1Ch]
  _DWORD *v39; // [esp+58h] [ebp-18h]
  unsigned int *v40; // [esp+5Ch] [ebp-14h]
  char *v41; // [esp+60h] [ebp-10h]
  unsigned int v42; // [esp+64h] [ebp-Ch]
  _DWORD *v43; // [esp+68h] [ebp-8h]
  _BYTE *v44; // [esp+6Ch] [ebp-4h]

  if ( lpEventAttributes )
    ModuleHandleA = hInst;
  else
    ModuleHandleA = GetModuleHandleA(0);
  v33[0] = (int)ModuleHandleA;
  ImageA = LoadImageA(ModuleHandleA, (LPCSTR)0xDC, 0, 0, 0, 0x40u);
  LastError = GetLastError();
  if ( ImageA || LastError != 1812 && LastError != 1813 )
  {
    qmemcpy(v29, v33, sizeof(v29));
    MEMORY[0x94994887](
      v29[0],
      v29[1],
      v29[2],
      v29[3],
      v29[4],
      v29[5],
      v29[6],
      v29[7],
      v29[8],
      v29[9],
      v29[10],
      LastError);
  }
  if ( !lpEventAttributes || bInitialState )
  {
    sub_401996(v33);
    v7 = (struct _SECURITY_ATTRIBUTES *)VirtualAlloc(0, v33[3], 0x3000u, 0x40u);
    v8 = v7;
    if ( !v7 )
      return 0;
    sub_40195A((char *)v33[1], v7, v33[3]);
    sub_4015D5(v33[3], v8, v33[5], (_DWORD *)v33[8]);
    v33[3] -= v33[7];
    strcpy(v35, "CreateEventA");
    sub_401466(v33[0], v35, (DWORD *)((char *)&v8->nLength + v33[3]));
    v10 = sub_40168F(v8, v33[2], v31, v32);
    v11 = (int)v10;
    lpAddress = v10;
    if ( !v10 )
      return 0;
    v12 = v10[15];
    v40 = (_DWORD *)((char *)v10 + v33[4]);
    v13 = v33[0] + *(_DWORD *)(v33[0] + 60);
    v14 = (char *)v10 + v12;
    v39 = (_DWORD *)(*(unsigned __int16 *)(v13 + 20) + v13 + 24);
    v15 = (int)&v14[*((unsigned __int16 *)v14 + 10) + 24];
    v30 = 706632649;
    v41 = (char *)v15;
    v16 = sub_40192D();
    v17 = (void (__stdcall *)(int, int, int, char *))sub_401AC8((int)v16, v30);
    v17(v13, 1, 4, v36);
    v44 = sub_401C1D(v11, v33[4]);
    v18 = (int)&v44[-v33[0]];
    v19 = 0;
    v38 = (int)&v44[-v33[0]];
    if ( lpEventAttributes && (v20 = *((_DWORD *)v14 + 30)) != 0 )
    {
      *(_DWORD *)(v13 + 120) = v18 + v20;
      *(_DWORD *)(v13 + 124) = *((_DWORD *)v14 + 31);
    }
    else
    {
      *(_DWORD *)(v13 + 120) = 0;
      *(_DWORD *)(v13 + 124) = 0;
    }
    v21 = *((_DWORD *)v14 + 34);
    if ( v21 )
    {
      *(_DWORD *)(v13 + 136) = v18 + v21;
      v22 = *(_DWORD *)(v13 + 136);
      *(_DWORD *)(v13 + 140) = *((_DWORD *)v14 + 35);
      sub_401A52(v33[0] + v22, v33[0] + v22, v18);
      *(_DWORD *)(v13 + 80) = -1 - v33[0];
    }
    v23 = &v44[-*((_DWORD *)v14 + 13)];
    v42 = v19;
    if ( *v40 > v19 )
    {
      v43 = v40 + 1;
      do
      {
        v24 = &v44[*v43];
        v43 = (_DWORD *)((char *)v43 + 3);
        v43 = (_DWORD *)((char *)v43 + 1);
        *v24 += v23;
        ++v42;
      }
      while ( v42 < *v40 );
    }
    if ( !sub_401067((int)v44) )
      return 0;
    if ( lpEventAttributes )
      sub_401000(v18, v33[0]);
    if ( !sub_401713((int)v44, (int)v44) )
      return 0;
    strcpy(v34, "CreateEventW");
    sub_401466(v33[0], v34, &v44[*((_DWORD *)v14 + 10)]);
    v25 = *((_WORD *)v14 + 3);
    v26 = 0;
    *(_WORD *)(v13 + 6) = v25;
    if ( v25 )
    {
      do
      {
        v27 = v39;
        v28 = v41;
        v41 += 5;
        v41 += 35;
        qmemcpy(v39, v28, 0x28u);
        v27[3] += v38;
        v39 = v27 + 10;
        ++v26;
      }
      while ( v26 < *(unsigned __int16 *)(v13 + 6) );
    }
    VirtualFree(lpAddress, 0, 0x8000u);
  }
  return CreateEventW(lpEventAttributes, (BOOL)hInst, bInitialState, lpName);
}
// 401335: variable 'v19' is possibly undefined
// 401A52: using guessed type _DWORD __stdcall sub_401A52(_DWORD, _DWORD, _DWORD);
// 40112F: using guessed type char var_24[4];

//----- (00401466) --------------------------------------------------------
_DWORD *__userpurge sub_401466@<eax>(int a1@<edi>, _BYTE *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  _DWORD *v9; // edx
  struct _LIST_ENTRY *v10; // eax
  _BYTE *v11; // eax
  char v12[4]; // [esp+0h] [ebp-Ch] BYREF
  HMODULE ModuleHandleA; // [esp+4h] [ebp-8h]
  _DWORD *v14; // [esp+8h] [ebp-4h]

  result = *(_DWORD **)(a1 + *(_DWORD *)(a1 + 60) + 128);
  v4 = 0;
  v14 = 0;
  if ( result )
  {
    result = (_DWORD *)((char *)result + a1 + 12);
    if ( *result )
    {
      v5 = result;
      do
      {
        if ( v14 )
          break;
        ModuleHandleA = GetModuleHandleA((LPCSTR)(a1 + *v5));
        v7 = sub_40153A(v6, a2);
        result = sub_401AC8((int)ModuleHandleA, v7);
        if ( result )
        {
          v8 = a1 + v5[1];
          while ( 1 )
          {
            v9 = *(_DWORD **)(v8 + 4 * v4);
            if ( !v9 )
              break;
            if ( v9 == result )
            {
              v14 = (_DWORD *)(v8 + 4 * v4);
              v10 = sub_40192D();
              v11 = sub_401AC8((int)v10, 706632649);
              ((void (__stdcall *)(_DWORD *, int, int, char *))v11)(v14, 4, 4, v12);
              result = a3;
              *v14 = a3;
              break;
            }
            ++v4;
          }
        }
        v5 += 5;
      }
      while ( *v5 );
    }
  }
  return result;
}
// 4014BF: variable 'v6' is possibly undefined
// 401466: using guessed type char var_C[4];

//----- (0040153A) --------------------------------------------------------
int __fastcall sub_40153A(int a1, _BYTE *a2)
{
  int v2; // esi
  int v3; // eax
  _BYTE *v4; // edx

  v2 = 0;
  v3 = sub_401901(a2);
  while ( *v4 )
    v2 = *(unsigned __int16 *)v4++ + 65599 * v2;
  if ( v2 < 0 )
    return (v3 + 23483) | v2 & 0x7FFF0000;
  return v2;
}
// 401548: variable 'v4' is possibly undefined

//----- (00401584) --------------------------------------------------------
void __stdcall sub_401584(_DWORD *a1, unsigned int a2, int a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // edi
  unsigned int v5; // ecx

  if ( a2 >= 4 )
  {
    v3 = a1;
    v4 = a1;
    v5 = a2 - 3;
    do
    {
      *v4 = a3 ^ *v3;
      v3 = (_DWORD *)((char *)v3 + 1);
      v4 = (_DWORD *)((char *)v4 + 1);
      a3 = __ROR4__(v5 + a3, 13);
      --v5;
    }
    while ( v5 );
  }
}

//----- (004015D5) --------------------------------------------------------
int __userpurge sub_4015D5@<eax>(unsigned int a1@<ebx>, _DWORD *a2, int a3, _DWORD *a4)
{
  _DWORD *v4; // edi
  unsigned __int8 v5; // al
  int v6; // esi
  char *v7; // eax
  _DWORD *v8; // ecx
  unsigned int v9; // edx
  int v10; // eax
  char v12[256]; // [esp+Eh] [ebp-108h] BYREF
  char *v13; // [esp+10Eh] [ebp-8h]
  unsigned __int8 v14; // [esp+114h] [ebp-2h]
  unsigned __int8 v15; // [esp+115h] [ebp-1h]

  v13 = v12;
  memset(v12, 0, sizeof(v12));
  v4 = a2;
  do
  {
    v5 = sub_40181B();
    v6 = v5;
    v14 = v5;
    v7 = &v12[v5];
    if ( !*v7 )
    {
      *v7 = 1;
      sub_401584(a2, a1, v6);
      v8 = a2;
      v9 = a1;
      v10 = 1207949762;
      do
      {
        v10 = *(unsigned __int8 *)v8 ^ (33 * v10);
        v8 = (_DWORD *)((char *)v8 + 1);
        --v9;
      }
      while ( v9 );
      v4 = (_DWORD *)v10;
      sub_401584(a2, a1, v6);
      v15 = v14;
    }
  }
  while ( v4 != a4 );
  sub_401584(a2, a1, v15);
  sub_401584(a2, a1, a3);
  return 1;
}

//----- (0040168F) --------------------------------------------------------
void *__userpurge sub_40168F@<eax>(struct _SECURITY_ATTRIBUTES *lpEventAttributes, SIZE_T dwSize, int a3, HANDLE a4)
{
  void *v4; // edi
  HANDLE EventA; // eax
  BOOL v7; // [esp+0h] [ebp-Ch]
  const CHAR *v8; // [esp+4h] [ebp-8h]
  LPVOID retaddr; // [esp+Ch] [ebp+0h]

  v4 = VirtualAlloc(0, dwSize, 0x3000u, 0x40u);
  EventA = CreateEventA(lpEventAttributes, (BOOL)v4, v7, v8);
  if ( EventA != a4 || EventA == (HANDLE)-1 )
  {
    VirtualFree(v4, 0, 0x8000u);
    v4 = 0;
  }
  VirtualFree(retaddr, 0, 0x8000u);
  return v4;
}
// 4016B6: variable 'v7' is possibly undefined
// 4016B6: variable 'v8' is possibly undefined

//----- (004016F1) --------------------------------------------------------
unsigned int __stdcall sub_4016F1(unsigned int a1)
{
  if ( a1 )
    return sub_40181B() % a1;
  else
    return 0;
}

//----- (00401713) --------------------------------------------------------
int __userpurge sub_401713@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  int *v3; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // ebx
  struct _LIST_ENTRY *v7; // eax
  int (__stdcall *v8)(int, int, int, int *); // eax
  unsigned int v9; // ecx
  int v11; // [esp+18h] [ebp-22h]
  int v12; // [esp+2Ah] [ebp-10h]
  int v13; // [esp+2Eh] [ebp-Ch] BYREF
  int *v14; // [esp+32h] [ebp-8h]
  unsigned int v15; // [esp+36h] [ebp-4h]

  v13 = 0;
  v15 = 0;
  v2 = a1 + *(_DWORD *)(a1 + 60);
  if ( *(_WORD *)(v2 + 6) )
  {
    v3 = (int *)(*(unsigned __int16 *)(v2 + 20) + v2 + 60);
    v14 = v3;
    do
    {
      v4 = *v3;
      v5 = 0;
      if ( (*v3 & 0x20000000) != 0 )
      {
        v5 = v4 < 0 ? 64 : 32;
        goto LABEL_10;
      }
      if ( v4 >= 0 )
      {
        if ( (v4 & 0x40000000) == 0 )
          goto LABEL_10;
        v11 = 2;
      }
      else
      {
        v11 = 4;
      }
      v5 = v11;
LABEL_10:
      if ( (v4 & 0x4000000) != 0 )
        v5 |= 0x200u;
      if ( v5 )
      {
        v6 = a2 + *(v3 - 6);
        v12 = *(v3 - 7);
        v7 = sub_40192D();
        v8 = (int (__stdcall *)(int, int, int, int *))sub_401AC8((int)v7, 706632649);
        if ( !v8(v6, v12, v5, &v13) )
          return 0;
        v3 = v14;
      }
      v9 = *(unsigned __int16 *)(v2 + 6);
      ++v15;
      v3 += 10;
      v14 = v3;
    }
    while ( v15 < v9 );
  }
  return 1;
}

//----- (0040181B) --------------------------------------------------------
int sub_40181B()
{
  unsigned int v0; // kr00_4
  unsigned __int64 v1; // rax
  unsigned int v3; // [esp-Ch] [ebp-Ch]

  v0 = __readeflags();
  v3 = v0;
  v1 = __rdtsc();
  return __ROL4__(v3 + v1 * HIDWORD(v1), v1 & 0xF) ^ v1;
}

//----- (00401833) --------------------------------------------------------
HANDLE __userpurge ZfXtnlxWyhustKrybOty@<eax>(
        char a1@<bh>,
        __int16 a2,
        HINSTANCE hInst,
        BOOL bInitialState,
        const WCHAR *lpszName)
{
  const char *ModuleHandleW; // eax
  char *v6; // eax
  int v8; // eax
  HANDLE v10; // eax
  bool v11; // zf
  char v12; // cc
  int v14; // [esp+46h] [ebp-14h]
  int v15; // [esp+46h] [ebp-14h]
  LPCOMMCONFIG v16; // [esp+4Ah] [ebp-10h] BYREF

  GetModuleHandleW(0);
  ModuleHandleW = (const char *)GetModuleHandleW(0);
  v6 = getenv(ModuleHandleW);
  _ECX = v14;
  if ( v6 || (v8 = is_wctype(0x66u, 0x61u), _ECX = v15, v8) )
  {
    do
    {
      __indword(0x68u);
      __asm { bound   esp, [ebp+var_59] }
      v11 = 2 * a1 == 0;
      v12 = ((a1 & 0x40) != 0) ^ __OFADD__(a1, a1);
      a1 *= 2;
      __asm { rcr     byte ptr [ecx+39h], 1 }
      if ( !v12 )
        JUMPOUT(0x4018E6);
    }
    while ( !v11 && CommConfigDialogW(lpszName, 0, v16) );
    return 0;
  }
  else
  {
    if ( !GetModuleHandleW(0)
      || (unsigned int)bInitialState >= 4
      || (_WORD)hInst
      || ((unsigned int)lpszName & 0xFFFFFFFE) != 0 )
    {
      v10 = sub_40112F(0, 0, 0, 0);
      ExitProcess((UINT)v10);
    }
    return sub_40112F(hInst, bInitialState, lpszName, (LPSECURITY_ATTRIBUTES)1);
  }
}
// 4018DC: control flows out of bounds to 4018E6
// 401833: could not find valid save-restore pair for ebp
// 401853: variable 'v14' is possibly undefined
// 401869: variable 'v15' is possibly undefined

//----- (00401901) --------------------------------------------------------
int __stdcall sub_401901(_BYTE *a1)
{
  int i; // ecx

  for ( i = 0; *a1++ != 0; ++i )
    ;
  return i;
}

//----- (0040192D) --------------------------------------------------------
struct _LIST_ENTRY *sub_40192D()
{
  struct _LIST_ENTRY *Flink; // esi
  struct _LIST_ENTRY *result; // eax
  struct _LIST_ENTRY *v2; // edi

  Flink = NtCurrentPeb()->Ldr->InInitializationOrderModuleList.Flink;
  do
  {
    do
    {
      result = Flink[1].Flink;
      v2 = Flink[4].Flink;
      Flink = Flink->Flink;
    }
    while ( LOBYTE(v2->Flink) != 107 );
  }
  while ( LOBYTE(v2[3].Flink) );
  return result;
}

//----- (0040195A) --------------------------------------------------------
int __usercall sub_40195A@<eax>(char *a1@<edx>, _BYTE *a2@<ecx>, int a3@<edi>)
{
  if ( a2 && a1 && a3 )
    return IigGbliiYnqdwsdIovvTm(*a1, a2, a3, a3);
  else
    return 0;
}
// 401972: control flows out of bounds to 401990
// 401972: conditional instruction was optimized away because edi.4!=0

//----- (00401980) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall IigGbliiYnqdwsdIovvTm@<eax>(char a1@<al>, _BYTE *a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  *a2 = a1;
  if ( a4 != 1 )
    JUMPOUT(0x40197D);
  return a3;
}
// 401990: positive sp value 4 has been found
// 401989: control flows out of bounds to 40197D

//----- (00401996) --------------------------------------------------------
int __usercall sub_401996@<eax>(int *a1@<esi>)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  _BYTE *v4; // eax
  int result; // eax
  int v6; // [esp+4h] [ebp-8h]
  _BYTE *v7; // [esp+8h] [ebp-4h]

  v1 = *a1;
  a1[1] = 0;
  v2 = v1 + (unsigned __int16)__ROR2__(*(_WORD *)(*(_DWORD *)(v1 + 60) + v1 + 8) ^ 0x68E1, 1);
  sub_40195A((char *)(v2 + 16), (_BYTE *)a1 + 8, 32);
  sub_401584(a1 + 2, 0x20u, 1937524871);
  v3 = a1[9];
  a1[4] -= v3;
  a1[7] += v3;
  a1[2] += -8 * v3;
  a1[6] += -16 * v3;
  a1[3] += -2 * v3;
  v4 = VirtualAlloc(0, a1[3] + 32, 0x3000u, 0x40u);
  a1[1] = (int)v4;
  v7 = v4;
  v6 = 4;
  do
  {
    sub_40195A((char *)(v2 + 16), v7, *(_DWORD *)(v2 + 8));
    result = *(_DWORD *)(v2 + 8);
    v7 += result;
    v2 = *a1 + (*(_DWORD *)(v2 + 12) ^ 0x46C368E1);
    --v6;
  }
  while ( v6 );
  a1[1] += 29;
  a1[1] += 3;
  return result;
}

//----- (00401A52) --------------------------------------------------------
#error "401A6E: positive sp value has been found (funcsize=11)"

//----- (00401A6F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __userpurge KaqKcgzYxmcfxqXq@<eax>(_DWORD *a1@<ebp>, int a2@<esi>, int a3, int a4, int a5)
{
  int v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  unsigned int result; // eax

  v5 = a1[4];
  v6 = a1[2];
  a1[3] = a2 + 20;
  do
  {
    v7 = *(_DWORD *)a1[3];
    if ( v7 >= 0 )
      *(_DWORD *)(v6 + v7) += v5;
    else
      sub_401A52(v6, v6 + (v7 & 0x7FFFFFFF), v5);
    v8 = *(unsigned __int16 *)(a2 + 14);
    v9 = *(unsigned __int16 *)(a2 + 12);
    ++*(a1 - 1);
    a1[3] += 6;
    a1[3] += 2;
    result = v9 + v8;
  }
  while ( *(a1 - 1) < result );
  return result;
}
// 401AC5: positive sp value C has been found
// 401A6F: could not find valid save-restore pair for ebx
// 401A52: using guessed type _DWORD __stdcall sub_401A52(_DWORD, _DWORD, _DWORD);

//----- (00401AC8) --------------------------------------------------------
_BYTE *__stdcall sub_401AC8(int a1, int a2)
{
  int savedregs; // [esp+6Eh] [ebp+0h] BYREF

  return SzfkIjqwtBv(
           a1 + *(_DWORD *)(a1 + 60),
           a1,
           (int)&savedregs,
           *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 120),
           a1,
           a2);
}

//----- (00401AE6) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_BYTE *__userpurge SzfkIjqwtBv@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<ebp>, int a4@<esi>, int a5, int a6)
{
  int v7; // edx
  _DWORD *v8; // esi
  int v9; // ebx
  int v10; // edi
  int v11; // eax
  int v12; // ebx
  int v13; // edi
  unsigned int v14; // edx
  int v15; // edi
  int v16; // edx
  bool v17; // zf
  _BYTE *v18; // edi
  size_t v19; // esi
  int v20; // ecx
  HMODULE LibraryA; // ebx
  int v22; // eax

  if ( !a4 )
    return 0;
  v7 = *(_DWORD *)(a3 + 12);
  v8 = (_DWORD *)(a2 + a4);
  v9 = v8[8];
  v10 = v8[7];
  *(_DWORD *)(a3 - 12) = *(_DWORD *)(a1 + 124);
  v11 = a2 + v8[9];
  v12 = a2 + v9;
  v13 = a2 + v10;
  *(_DWORD *)(a3 - 8) = v11;
  if ( v7 >= 0 )
  {
    v16 = 0;
    *(_DWORD *)(a3 - 4) = 0;
    v17 = v8[6] == 0;
    if ( v8[6] )
    {
      while ( *(_DWORD *)(a3 + 12) != sub_40153A(a2, (_BYTE *)(a2 + *(_DWORD *)(v12 + 4 * v16))) )
      {
        if ( ++*(_DWORD *)(a3 - 4) >= v8[6] )
          break;
        a2 = *(_DWORD *)(a3 + 8);
        v16 = *(_DWORD *)(a3 - 4);
      }
      v16 = *(_DWORD *)(a3 - 4);
      a2 = *(_DWORD *)(a3 + 8);
      v11 = *(_DWORD *)(a3 - 8);
      v17 = v16 == v8[6];
    }
    if ( v17 )
      return 0;
    v15 = *(_DWORD *)(v13 + 4 * *(unsigned __int16 *)(v11 + 2 * v16));
  }
  else
  {
    v14 = (v7 & 0x7FFFFFFF) - v8[4];
    if ( v14 >= v8[5] )
      return 0;
    v15 = *(_DWORD *)(v13 + 4 * v14);
  }
  v18 = (_BYTE *)(a2 + v15);
  if ( v18 && v18 < (_BYTE *)v8 + *(_DWORD *)(a3 - 12) && v18 >= (_BYTE *)v8 )
  {
    v19 = 0;
    if ( *v18 != 46 )
    {
      do
        ++v19;
      while ( v18[v19] != 46 );
    }
    memcpy((void *)(a3 - 272), v18, v19);
    *(_BYTE *)(a3 + v19 - 272) = 0;
    LibraryA = LoadLibraryA((LPCSTR)(a3 - 272));
    if ( !LibraryA )
      return 0;
    v22 = sub_40153A(v20, &v18[v19 + 1]);
    return sub_401AC8((int)LibraryA, v22);
  }
  return v18;
}
// 401C1A: positive sp value 8 has been found
// 401AE6: could not find valid save-restore pair for ebx
// 401AE6: could not find valid save-restore pair for edi
// 401C06: variable 'v20' is possibly undefined

//----- (00401C1D) --------------------------------------------------------
_BYTE *__cdecl sub_401C1D(int a1, int a2)
{
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  return CapPyyfdoxHghkvPrpqfoo((int)&savedregs, a1, a2);
}

//----- (00401C29) --------------------------------------------------------
_BYTE *__userpurge CapPyyfdoxHghkvPrpqfoo@<eax>(int a1@<ebp>, int a2, int a3)
{
  unsigned int v3; // esi
  LPVOID v4; // eax
  unsigned int v5; // ebx
  _BYTE *v6; // esi

  v3 = 0;
  while ( 1 )
  {
    v4 = VirtualAlloc(0, *(_DWORD *)(a1 + 12), 0x2000u, 4u);
    *(_DWORD *)(a1 + 4 * v3 - 800) = v4;
    if ( !v4 )
      break;
    if ( ++v3 >= 0xC8 )
    {
      v5 = sub_4016F1(v3);
      do
      {
        if ( v3 != v5 )
          VirtualFree(*(LPVOID *)(a1 + 4 * v3 - 800), 0, 0x8000u);
        --v3;
      }
      while ( v3 );
      v6 = *(_BYTE **)(a1 + 4 * v5 - 800);
      if ( VirtualAlloc(v6, *(_DWORD *)(a1 + 12), 0x1000u, 4u) )
      {
        sub_40195A(*(char **)(a1 + 8), v6, *(_DWORD *)(a1 + 12));
        return v6;
      }
      return 0;
    }
  }
  return 0;
}
// 401C79: conditional instruction was optimized away because esi.4>=C8u

// nfuncs=24 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 23 function(s)"
