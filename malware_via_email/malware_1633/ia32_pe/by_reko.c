// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t1165C; // 00411000
<anonymous> * __imp__LeaveCriticalSection = &g_t1166E; // 00411004
<anonymous> * __imp__DeleteCriticalSection = &g_t11686; // 00411008
<anonymous> * __imp__CreateThread = &g_t1169E; // 0041100C
<anonymous> * __imp__GetLastError = &g_t116AE; // 00411010
<anonymous> * __imp__LoadLibraryW = &g_t116BE; // 00411014
<anonymous> * __imp__QueryPerformanceCounter = &g_t116CE; // 00411018
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t116E8; // 0041101C
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t11702; // 00411020
<anonymous> * __imp__CreateEventW = &g_t1171E; // 00411024
<anonymous> * __imp__GetLastError = &g_t1172E; // 00411028
<anonymous> * __imp__LeaveCriticalSection = &g_t1173E; // 0041102C
<anonymous> * __imp__VirtualAlloc = &g_t11756; // 00411030
<anonymous> * __imp__LeaveCriticalSection = &g_t11766; // 00411034
<anonymous> * __imp__GetCurrentThreadId = &g_t1177E; // 00411038
<anonymous> * __imp__VirtualProtect = &g_t11794; // 0041103C
<anonymous> * __imp__GetVersionExA = &g_t117A6; // 00411040
<anonymous> * __imp__MultiByteToWideChar = &g_t117B6; // 00411044
<anonymous> * __imp__ReadFile = &g_t117CC; // 00411048
<anonymous> * __imp__lstrcmpiW = &g_t117D8; // 0041104C
<anonymous> * __imp__SetLastError = &g_t117E4; // 00411050
<anonymous> * __imp__LeaveCriticalSection = &g_t117F4; // 00411054
<anonymous> * __imp__GetCurrentProcessId = &g_t1180C; // 00411058
<anonymous> * __imp__InitializeCriticalSection = &g_t11822; // 0041105C
<anonymous> * __imp__HeapFree = &g_t1183E; // 00411060
<anonymous> * __imp__GetCurrentProcess = &g_t1184A; // 00411064
<anonymous> * __imp__GetCurrentProcess = &g_t1185E; // 00411068
<anonymous> * __imp__CreateFileW = &g_t11872; // 0041106C
<anonymous> * __imp__LeaveCriticalSection = &g_t11880; // 00411070
<anonymous> * __imp__HeapFree = &g_t11898; // 00411074
<anonymous> * __imp__CreateEventW = &g_t118A4; // 00411078
<anonymous> * __imp__HeapDestroy = &g_t118B4; // 0041107C
<anonymous> * __imp__LocalAlloc = &g_t118C2; // 00411080
<anonymous> * __imp__HeapFree = &g_t118D0; // 00411084
<anonymous> * __imp__MultiByteToWideChar = &g_t118DC; // 00411088
<anonymous> * __imp__GetProcAddress = &g_t118F2; // 0041108C
<anonymous> * __imp__GetModuleHandleW = &g_t11904; // 00411090
<anonymous> * __imp__GetProcessHeap = &g_t11918; // 00411094
<anonymous> * __imp__GetModuleHandleW = &g_t1192A; // 00411098
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t1193E; // 0041109C
<anonymous> * __imp__MultiByteToWideChar = &g_t11958; // 004110A0
<anonymous> * __imp__GetCurrentThreadId = &g_t1196E; // 004110A4
<anonymous> * __imp__Sleep = &g_t11984; // 004110A8
<anonymous> * __imp__GetProcessHeap = &g_t1198C; // 004110AC
<anonymous> * __imp__InterlockedExchange = &g_t1199E; // 004110B0
<anonymous> * __imp__GetLastError = &g_t119B4; // 004110B4
<anonymous> * __imp__GetProcessHeap = &g_t119C4; // 004110B8
<anonymous> * __imp__HeapDestroy = &g_t119D6; // 004110BC
<anonymous> * __imp__CreateThread = &g_t119E4; // 004110C0
<anonymous> * __imp__CreateFileW = &g_t119F4; // 004110C4
<anonymous> * __imp__LocalFree = &g_t11A02; // 004110C8
<anonymous> * __imp__HeapAlloc = &g_t11A0E; // 004110CC
<anonymous> * __imp__GetCurrentThreadId = &g_t11A1A; // 004110D0
<anonymous> * __imp__GetProcessHeap = &g_t11A30; // 004110D4
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t11A42; // 004110D8
<anonymous> * __imp__VirtualProtect = &g_t11A5E; // 004110DC
<anonymous> * __imp__GetCurrentProcessId = &g_t11A70; // 004110E0
<anonymous> * __imp__EnterCriticalSection = &g_t11A86; // 004110E4
<anonymous> * __imp__ReadFile = &g_t11A9E; // 004110E8
<anonymous> * __imp__LocalFree = &g_t11AAA; // 004110EC
<anonymous> * __imp__LoadLibraryA = &g_t11AB6; // 004110F0
<anonymous> * __imp__GetVersionExA = &g_t11AC6; // 004110F4
<anonymous> * __imp__SetCursor = &g_t11AE4; // 004110FC
<anonymous> * __imp__EnableWindow = &g_t11AF0; // 00411100
<anonymous> * __imp__SetCursor = &g_t11B00; // 00411104
<anonymous> * __imp__BeginPaint = &g_t11B0C; // 00411108
<anonymous> * __imp__LoadStringW = &g_t11B1A; // 0041110C
<anonymous> * __imp__SetCursor = &g_t11B28; // 00411110
<anonymous> * __imp__BeginPaint = &g_t11B34; // 00411114
<anonymous> * __imp__CreateWindowExW = &g_t11B42; // 00411118
<anonymous> * __imp__EndDialog = &g_t11B54; // 0041111C
<anonymous> * __imp__PostQuitMessage = &g_t11B60; // 00411120
<anonymous> * __imp__ShowWindow = &g_t11B72; // 00411124
<anonymous> * __imp__GetDC = &g_t11B80; // 00411128
<anonymous> * __imp__BeginPaint = &g_t11B88; // 0041112C
<anonymous> * __imp__KillTimer = &g_t11B96; // 00411130
<anonymous> * __imp__IsDlgButtonChecked = &g_t11BA2; // 00411134
<anonymous> * __imp__SetDlgItemTextW = &g_t11BB8; // 00411138
<anonymous> * __imp__EndDialog = &g_t11BCA; // 0041113C
<anonymous> * __imp__SetWindowTextW = &g_t11BD6; // 00411140
<anonymous> * __imp__SetForegroundWindow = &g_t11BE8; // 00411144
<anonymous> * __imp__SendMessageW = &g_t11BFE; // 00411148
<anonymous> * __imp__ReleaseDC = &g_t11C0E; // 0041114C
<anonymous> * __imp__LoadStringW = &g_t11C1A; // 00411150
<anonymous> * __imp__SetCursor = &g_t11C28; // 00411154
<anonymous> * __imp__DefWindowProcW = &g_t11C34; // 00411158
<anonymous> * __imp__BeginPaint = &g_t11C46; // 0041115C
<anonymous> * __imp__IsDlgButtonChecked = &g_t11C54; // 00411160
<anonymous> * __imp__GetClientRect = &g_t11C6A; // 00411164
<anonymous> * __imp__IsWindow = &g_t11C7A; // 00411168
<anonymous> * __imp__LoadStringW = &g_t11C86; // 0041116C
<anonymous> * __imp__GetFocus = &g_t11C94; // 00411170
<anonymous> * __imp__GetDlgItem = &g_t11CA0; // 00411174
<anonymous> * __imp__InvalidateRect = &g_t11CAE; // 00411178
<anonymous> * __imp__LoadCursorW = &g_t11CC0; // 0041117C
<anonymous> * __imp__DispatchMessageW = &g_t11CCE; // 00411180
<anonymous> * __imp__SetWindowTextW = &g_t11CE2; // 00411184
<anonymous> * __imp__GetFocus = &g_t11CF4; // 00411188
<anonymous> * __imp__LoadIconW = &g_t11D00; // 0041118C
<anonymous> * __imp__GetDesktopWindow = &g_t11D0C; // 00411190
<anonymous> * __imp__LoadCursorW = &g_t11D20; // 00411194
<anonymous> * __imp__IsDlgButtonChecked = &g_t11D2E; // 00411198
<anonymous> * __imp__GetFocus = &g_t11D44; // 0041119C
<anonymous> * __imp__IsDlgButtonChecked = &g_t11D50; // 004111A0
<anonymous> * __imp__DestroyWindow = &g_t11D66; // 004111A4
<anonymous> * __imp__GetSystemMetrics = &g_t11D76; // 004111A8
<anonymous> * __imp__PostMessageW = &g_t11D8A; // 004111AC
<anonymous> * __imp__TranslateMessage = &g_t11D9A; // 004111B0
<anonymous> * __imp__GetWindowLongW = &g_t11DAE; // 004111B4
<anonymous> * __imp__MessageBoxW = &g_t11DC0; // 004111B8
<anonymous> * __imp__GetWindowLongW = &g_t11DCE; // 004111BC
<anonymous> * __imp__SendMessageW = &g_t11DE0; // 004111C0
<anonymous> * __imp__SetWindowLongW = &g_t11DF0; // 004111C4
<anonymous> * __imp__GetSystemMetrics = &g_t11E02; // 004111C8
<anonymous> * __imp__SetWindowPos = &g_t11E16; // 004111CC
<anonymous> * __imp__SetTimer = &g_t11E26; // 004111D0
<anonymous> * __imp__SendDlgItemMessageW = &g_t11E32; // 004111D4
<anonymous> * __imp__CreateWindowExW = &g_t11E48; // 004111D8
<anonymous> * __imp__EnableWindow = &g_t11E5A; // 004111DC
<anonymous> * __imp__EnableWindow = &g_t11E6A; // 004111E0
<anonymous> * __imp__LoadIconW = &g_t11E7A; // 004111E4
<anonymous> * __imp__EndPaint = &g_t11E86; // 004111E8
<anonymous> * __imp__RoundRect = &g_t11E9E; // 004111F0
<anonymous> * __imp__BitBlt = &g_t11EAA; // 004111F4
<anonymous> * __imp__SelectObject = &g_t11EB4; // 004111F8
<anonymous> * __imp__GetPixel = &g_t11EC4; // 004111FC
<anonymous> * __imp__SetBkColor = &g_t11ED0; // 00411200
<anonymous> * __imp__GetBrushOrgEx = &g_t11EDE; // 00411204
<anonymous> * __imp__CreateFontA = &g_t11EEE; // 00411208
<anonymous> * __imp__GetBkMode = &g_t11EFC; // 0041120C
<anonymous> * __imp__SetTextColor = &g_t11F08; // 00411210
<anonymous> * __imp__BitBlt = &g_t11F18; // 00411214
<anonymous> * __imp__SetBkMode = &g_t11F22; // 00411218
<anonymous> * __imp__SetTextColor = &g_t11F2E; // 0041121C
<anonymous> * __imp__GetWindowExtEx = &g_t11F3E; // 00411220
<anonymous> * __imp__SetTextColor = &g_t11F50; // 00411224
<anonymous> * __imp__Rectangle = &g_t11F60; // 00411228
<anonymous> * __imp__BitBlt = &g_t11F6C; // 0041122C
<anonymous> * __imp__Ellipse = &g_t11F76; // 00411230
<anonymous> * __imp__GetPixel = &g_t11F80; // 00411234
<anonymous> * __imp__BitBlt = &g_t11F8C; // 00411238
<anonymous> * __imp__GetBrushOrgEx = &g_t11F96; // 0041123C
<anonymous> * __imp__BitBlt = &g_t11FA6; // 00411240
<anonymous> * __imp__BitBlt = &g_t11FB0; // 00411244
<anonymous> * __imp__GetPixel = &g_t11FBA; // 00411248
<anonymous> * __imp__SetPixel = &g_t11FC6; // 0041124C
<anonymous> * __imp__BitBlt = &g_t11FD2; // 00411250
<anonymous> * __imp__PatBlt = &g_t11FDC; // 00411254
<anonymous> * __imp__PatBlt = &g_t11FE6; // 00411258
<anonymous> * __imp__GetBrushOrgEx = &g_t11FF0; // 0041125C
<anonymous> * __imp__MoveToEx = &g_t12000; // 00411260
<anonymous> * __imp__SetBrushOrgEx = &g_t1200C; // 00411264
<anonymous> * __imp__CreateCompatibleDC = &g_t1201C; // 00411268
<anonymous> * __imp__PatBlt = &g_t12032; // 0041126C
<anonymous> * __imp__CombineRgn = &g_t1203C; // 00411270
<anonymous> * __imp__Rectangle = &g_t1204A; // 00411274
<anonymous> * __imp__SetWindowOrgEx = &g_t12056; // 00411278
<anonymous> * __imp__Polygon = &g_t12068; // 0041127C
<anonymous> * __imp__SetTextColor = &g_t12072; // 00411280
<anonymous> * __imp__Ellipse = &g_t12082; // 00411284
<anonymous> * __imp__SetBkColor = &g_t1208C; // 00411288
<anonymous> * __imp__GetCurrentObject = &g_t1209A; // 0041128C
<anonymous> * __imp__SetBkMode = &g_t120AE; // 00411290
<anonymous> * __imp__SetBkMode = &g_t120BA; // 00411294
<anonymous> * __imp__PatBlt = &g_t120C6; // 00411298
<anonymous> * __imp__GetBrushOrgEx = &g_t120D0; // 0041129C
<anonymous> * __imp__CreateFontIndirectA = &g_t120E0; // 004112A0
<anonymous> * __imp__Ellipse = &g_t120F6; // 004112A4
<anonymous> * __imp__SetPixel = &g_t12100; // 004112A8
<anonymous> * __imp__GetBkMode = &g_t1210C; // 004112AC
<anonymous> * __imp__LineTo = &g_t12118; // 004112B0
<anonymous> * __imp__CreateFontA = &g_t12122; // 004112B4
<anonymous> * __imp__SetBrushOrgEx = &g_t12130; // 004112B8
<anonymous> * __imp__SetBrushOrgEx = &g_t12140; // 004112BC
<anonymous> * __imp__Polygon = &g_t12150; // 004112C0
<anonymous> * __imp__CreatePen = &g_t1215A; // 004112C4
<anonymous> * __imp__SetTextColor = &g_t12166; // 004112C8
<anonymous> * __imp__BitBlt = &g_t12176; // 004112CC
<anonymous> * __imp__Ellipse = &g_t12180; // 004112D0
<anonymous> * __imp__GetBkMode = &g_t1218A; // 004112D4
<anonymous> * __imp__SetPixel = &g_t12196; // 004112D8
<anonymous> * __imp__GetPixel = &g_t121A2; // 004112DC
<anonymous> * __imp__Ellipse = &g_t121AE; // 004112E0
<anonymous> * __imp__GetCurrentObject = &g_t121B8; // 004112E4
<anonymous> * __imp__CreateDIBitmap = &g_t121CC; // 004112E8
<anonymous> * __imp__GetCurrentObject = &g_t121DE; // 004112EC
<anonymous> * __imp__SetPixel = &g_t121F2; // 004112F0
<anonymous> * __imp__CreateSolidBrush = &g_t121FE; // 004112F4
<anonymous> * __imp__Rectangle = &g_t12212; // 004112F8
<anonymous> * __imp__CreateCompatibleDC = &g_t1221E; // 004112FC
word32 g_dw411358 = 0x0001165C; // 00411358
word32 g_dw41135C = 0x0001166E; // 0041135C
word32 g_dw411360 = 0x00011686; // 00411360
word32 g_dw411364 = 0x0001169E; // 00411364
word32 g_dw411368 = 0x000116AE; // 00411368
word32 g_dw41136C = 0x000116BE; // 0041136C
word32 g_dw411370 = 0x000116CE; // 00411370
word32 g_dw411374 = 0x000116E8; // 00411374
word32 g_dw411378 = 0x00011702; // 00411378
word32 g_dw41137C = 0x0001171E; // 0041137C
word32 g_dw411380 = 0x0001172E; // 00411380
word32 g_dw411384 = 0x0001173E; // 00411384
word32 g_dw411388 = 0x00011756; // 00411388
word32 g_dw41138C = 0x00011766; // 0041138C
word32 g_dw411390 = 0x0001177E; // 00411390
word32 g_dw411394 = 0x00011794; // 00411394
word32 g_dw411398 = 0x000117A6; // 00411398
word32 g_dw41139C = 0x000117B6; // 0041139C
word32 g_dw4113A0 = 0x000117CC; // 004113A0
word32 g_dw4113A4 = 0x000117D8; // 004113A4
word32 g_dw4113A8 = 0x000117E4; // 004113A8
word32 g_dw4113AC = 0x000117F4; // 004113AC
word32 g_dw4113B0 = 0x0001180C; // 004113B0
word32 g_dw4113B4 = 0x00011822; // 004113B4
word32 g_dw4113B8 = 0x0001183E; // 004113B8
word32 g_dw4113BC = 0x0001184A; // 004113BC
word32 g_dw4113C0 = 71774; // 004113C0
word32 g_dw4113C4 = 0x00011872; // 004113C4
word32 g_dw4113C8 = 0x00011880; // 004113C8
word32 g_dw4113CC = 0x00011898; // 004113CC
word32 g_dw4113D0 = 0x000118A4; // 004113D0
word32 g_dw4113D4 = 0x000118B4; // 004113D4
word32 g_dw4113D8 = 0x000118C2; // 004113D8
word32 g_dw4113DC = 71888; // 004113DC
word32 g_dw4113E0 = 0x000118DC; // 004113E0
word32 g_dw4113E4 = 0x000118F2; // 004113E4
word32 g_dw4113E8 = 0x00011904; // 004113E8
word32 g_dw4113EC = 0x00011918; // 004113EC
word32 g_dw4113F0 = 0x0001192A; // 004113F0
word32 g_dw4113F4 = 0x0001193E; // 004113F4
word32 g_dw4113F8 = 0x00011958; // 004113F8
word32 g_dw4113FC = 0x0001196E; // 004113FC
word32 g_dw411400 = 0x00011984; // 00411400
word32 g_dw411404 = 0x0001198C; // 00411404
word32 g_dw411408 = 0x0001199E; // 00411408
word32 g_dw41140C = 0x000119B4; // 0041140C
word32 g_dw411410 = 0x000119C4; // 00411410
word32 g_dw411414 = 0x000119D6; // 00411414
word32 g_dw411418 = 0x000119E4; // 00411418
word32 g_dw41141C = 0x000119F4; // 0041141C
word32 g_dw411420 = 0x00011A02; // 00411420
word32 g_dw411424 = 0x00011A0E; // 00411424
word32 g_dw411428 = 0x00011A1A; // 00411428
word32 g_dw41142C = 0x00011A30; // 0041142C
word32 g_dw411430 = 0x00011A42; // 00411430
word32 g_dw411434 = 0x00011A5E; // 00411434
word32 g_dw411438 = 0x00011A70; // 00411438
word32 g_dw41143C = 0x00011A86; // 0041143C
word32 g_dw411440 = 0x00011A9E; // 00411440
word32 g_dw411444 = 0x00011AAA; // 00411444
word32 g_dw411448 = 0x00011AB6; // 00411448
word32 g_dw41144C = 0x00011AC6; // 0041144C
word32 g_dw411454 = 0x00011AE4; // 00411454
word32 g_dw411458 = 0x00011AF0; // 00411458
word32 g_dw41145C = 0x00011B00; // 0041145C
word32 g_dw411460 = 0x00011B0C; // 00411460
word32 g_dw411464 = 0x00011B1A; // 00411464
word32 g_dw411468 = 0x00011B28; // 00411468
word32 g_dw41146C = 0x00011B34; // 0041146C
word32 g_dw411470 = 0x00011B42; // 00411470
word32 g_dw411474 = 0x00011B54; // 00411474
word32 g_dw411478 = 0x00011B60; // 00411478
word32 g_dw41147C = 0x00011B72; // 0041147C
word32 g_dw411480 = 0x00011B80; // 00411480
word32 g_dw411484 = 0x00011B88; // 00411484
word32 g_dw411488 = 0x00011B96; // 00411488
word32 g_dw41148C = 0x00011BA2; // 0041148C
word32 g_dw411490 = 0x00011BB8; // 00411490
word32 g_dw411494 = 0x00011BCA; // 00411494
word32 g_dw411498 = 72662; // 00411498
word32 g_dw41149C = 0x00011BE8; // 0041149C
word32 g_dw4114A0 = 72702; // 004114A0
word32 g_dw4114A4 = 0x00011C0E; // 004114A4
word32 g_dw4114A8 = 0x00011C1A; // 004114A8
word32 g_dw4114AC = 72744; // 004114AC
word32 g_dw4114B0 = 0x00011C34; // 004114B0
word32 g_dw4114B4 = 72774; // 004114B4
word32 g_dw4114B8 = 72788; // 004114B8
word32 g_dw4114BC = 0x00011C6A; // 004114BC
word32 g_dw4114C0 = 0x00011C7A; // 004114C0
word32 g_dw4114C4 = 0x00011C86; // 004114C4
word32 g_dw4114C8 = 0x00011C94; // 004114C8
word32 g_dw4114CC = 0x00011CA0; // 004114CC
word32 g_dw4114D0 = 72878; // 004114D0
word32 g_dw4114D4 = 0x00011CC0; // 004114D4
word32 g_dw4114D8 = 0x00011CCE; // 004114D8
word32 g_dw4114DC = 0x00011CE2; // 004114DC
word32 g_dw4114E0 = 0x00011CF4; // 004114E0
word32 g_dw4114E4 = 0x00011D00; // 004114E4
word32 g_dw4114E8 = 72972; // 004114E8
word32 g_dw4114EC = 72992; // 004114EC
word32 g_dw4114F0 = 0x00011D2E; // 004114F0
word32 g_dw4114F4 = 0x00011D44; // 004114F4
word32 g_dw4114F8 = 0x00011D50; // 004114F8
word32 g_dw4114FC = 0x00011D66; // 004114FC
word32 g_dw411500 = 0x00011D76; // 00411500
word32 g_dw411504 = 0x00011D8A; // 00411504
word32 g_dw411508 = 0x00011D9A; // 00411508
word32 g_dw41150C = 0x00011DAE; // 0041150C
word32 g_dw411510 = 0x00011DC0; // 00411510
word32 g_dw411514 = 0x00011DCE; // 00411514
word32 g_dw411518 = 0x00011DE0; // 00411518
word32 g_dw41151C = 0x00011DF0; // 0041151C
word32 g_dw411520 = 0x00011E02; // 00411520
word32 g_dw411524 = 0x00011E16; // 00411524
word32 g_dw411528 = 0x00011E26; // 00411528
word32 g_dw41152C = 0x00011E32; // 0041152C
word32 g_dw411530 = 0x00011E48; // 00411530
word32 g_dw411534 = 0x00011E5A; // 00411534
word32 g_dw411538 = 73322; // 00411538
word32 g_dw41153C = 73338; // 0041153C
word32 g_dw411540 = 0x00011E86; // 00411540
word32 g_dw411548 = 0x00011E9E; // 00411548
word32 g_dw41154C = 0x00011EAA; // 0041154C
word32 g_dw411550 = 0x00011EB4; // 00411550
word32 g_dw411554 = 0x00011EC4; // 00411554
word32 g_dw411558 = 0x00011ED0; // 00411558
word32 g_dw41155C = 0x00011EDE; // 0041155C
word32 g_dw411560 = 0x00011EEE; // 00411560
word32 g_dw411564 = 0x00011EFC; // 00411564
word32 g_dw411568 = 0x00011F08; // 00411568
word32 g_dw41156C = 0x00011F18; // 0041156C
word32 g_dw411570 = 0x00011F22; // 00411570
word32 g_dw411574 = 0x00011F2E; // 00411574
word32 g_dw411578 = 0x00011F3E; // 00411578
word32 g_dw41157C = 0x00011F50; // 0041157C
word32 g_dw411580 = 0x00011F60; // 00411580
word32 g_dw411584 = 0x00011F6C; // 00411584
word32 g_dw411588 = 0x00011F76; // 00411588
word32 g_dw41158C = 0x00011F80; // 0041158C
word32 g_dw411590 = 0x00011F8C; // 00411590
word32 g_dw411594 = 0x00011F96; // 00411594
word32 g_dw411598 = 0x00011FA6; // 00411598
word32 g_dw41159C = 0x00011FB0; // 0041159C
word32 g_dw4115A0 = 0x00011FBA; // 004115A0
word32 g_dw4115A4 = 0x00011FC6; // 004115A4
word32 g_dw4115A8 = 0x00011FD2; // 004115A8
word32 g_dw4115AC = 0x00011FDC; // 004115AC
word32 g_dw4115B0 = 0x00011FE6; // 004115B0
word32 g_dw4115B4 = 0x00011FF0; // 004115B4
word32 g_dw4115B8 = 0x00012000; // 004115B8
word32 g_dw4115BC = 0x0001200C; // 004115BC
word32 g_dw4115C0 = 0x0001201C; // 004115C0
word32 g_dw4115C4 = 73778; // 004115C4
word32 g_dw4115C8 = 73788; // 004115C8
word32 g_dw4115CC = 0x0001204A; // 004115CC
word32 g_dw4115D0 = 0x00012056; // 004115D0
word32 g_dw4115D4 = 73832; // 004115D4
word32 g_dw4115D8 = 0x00012072; // 004115D8
word32 g_dw4115DC = 0x00012082; // 004115DC
word32 g_dw4115E0 = 73868; // 004115E0
word32 g_dw4115E4 = 73882; // 004115E4
word32 g_dw4115E8 = 0x000120AE; // 004115E8
word32 g_dw4115EC = 0x000120BA; // 004115EC
word32 g_dw4115F0 = 0x000120C6; // 004115F0
word32 g_dw4115F4 = 0x000120D0; // 004115F4
word32 g_dw4115F8 = 0x000120E0; // 004115F8
word32 g_dw4115FC = 73974; // 004115FC
word32 g_dw411600 = 0x00012100; // 00411600
word32 g_dw411604 = 0x0001210C; // 00411604
word32 g_dw411608 = 0x00012118; // 00411608
word32 g_dw41160C = 0x00012122; // 0041160C
word32 g_dw411610 = 0x00012130; // 00411610
word32 g_dw411614 = 0x00012140; // 00411614
word32 g_dw411618 = 0x00012150; // 00411618
word32 g_dw41161C = 74074; // 0041161C
word32 g_dw411620 = 0x00012166; // 00411620
word32 g_dw411624 = 0x00012176; // 00411624
word32 g_dw411628 = 0x00012180; // 00411628
word32 g_dw41162C = 0x0001218A; // 0041162C
word32 g_dw411630 = 0x00012196; // 00411630
word32 g_dw411634 = 0x000121A2; // 00411634
word32 g_dw411638 = 0x000121AE; // 00411638
word32 g_dw41163C = 0x000121B8; // 0041163C
word32 g_dw411640 = 0x000121CC; // 00411640
word32 g_dw411644 = 0x000121DE; // 00411644
word32 g_dw411648 = 0x000121F2; // 00411648
word32 g_dw41164C = 0x000121FE; // 0041164C
word32 g_dw411650 = 0x00012212; // 00411650
word32 g_dw411654 = 0x0001221E; // 00411654
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040C166: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
	dl &= 0x61;
	ah += al;
	v11 = (ebx & 0x01 << 0x20 - 0x0E) != 0x00;
	ebx = __rol<word32,byte>(ebx, 0x0E);
	edx <<= 0x07;
	cx >>= cl;
	ch -= ~0x24;
	SCZO = cond(ch);
	edi = esi;
	ebx = ebx + esi + C;
	esi.u0 = 0x082BBC25;
	cl &= ah;
	bl &= 0x22;
	dh >>= cl;
	edx <<= cl;
	edi -= ebx;
	SCZO = cond(edi);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			SCZO = cond(edi - *((byte) esi.u0 - 1766259599));
			ss = *esp;
			&esp.u4->u0 = (word32) esp + 2;
			goto l0040C1A0;
		}
	}
	ecx = ecx ^ edx;
	edx <<= 0x10;
	ch >>= cl;
	SCZ = cond(ch);
	v33 = (eax & 0x01 << cl) != 0x00;
	eax = __rcr<word32,byte>(eax, cl, C);
	edx >>= 0x03;
	v34 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rol<byte,byte>(ah, cl);
	edi >>= 0x02;
	SCZO = cond(edi);
l0040BF27:
	dl &= 0x5D;
	ebx = edi;
	ah <<= cl;
	SCZO = cond(ah);
	v35 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	C = v35;
	v42 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	C = v42;
	bh = bh - ch - C;
	al <<= cl;
	bh -= dl;
	v43 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	ebx >>= 0x12;
	bh |= 131;
	&eax.u4->u0 = (word32) eax + 1;
	ch = -ch;
	edi >>= 0x10;
	SCZ = cond(edi);
	dh = dh - bh - C;
	al = al ^ 222;
	C.u0 = false;
	&al.u4->u0 = (bool) C.u0 + ((byte) al + 122);
	SCZO = cond(al);
	cl |= 0x35;
	bl = (byte) bl + 99;
	dl >>= cl;
	&al.u4->u0 = (byte) al + 227;
	ecx >>= 0x18;
	SCZ = cond(ecx);
	bl = bl + ch + C;
	ecx <<= 0x06;
	edi <<= 0x11;
	bh &= 118;
	ebx >>= cl;
	SCZO = cond(ebx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
			return;
	}
l0040C1A0:
	dx <<= cl;
	edi <<= 0x13;
	cl &= 0x26;
	dh -= 0x32;
	dl >>= cl;
	ah >>= cl;
	SCZO = cond(ah);
	v26 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	&ecx.u4->u0 = (word32) ecx + 1;
	v29 = (bx & 0x01 << 0x10 - cl) != 0x00;
	bx = __rol<word16,byte>(bx, cl);
	ch &= ~0x24;
	ch = (byte) ch + 1;
	bl >>= cl;
	C = dx != 0x00;
	dx = -dx;
	SZO = cond(dx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			&ecx.u4->u0 = (word32) ecx + 1;
			SZP = cond(eax.u5->dwFFFFFF80 & ebp);
			O = false;
			C.u0 = false;
			fnEF1427F0();
			return;
		}
	}
	dx = dx ^ si;
	ah &= 181;
	ecx >>= cl;
	ecx += esi;
	dh = cl;
	C = ah != 0x00;
	ah = -ah;
	ax = ax + bx + C;
	SCZO = cond(ax);
	v38 = (eax & 0x01 << 0x19) != 0x00;
	eax = __rcr<word32,byte>(eax, 0x19, C);
	dh &= 88;
	bl >>= cl;
	&al.u4->u0 = (byte) al + 39;
	SCZO = cond(al);
	ax = ax - bx - C;
	SCZO = cond(ax);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			eax = *esp;
			&esp.u4->u0 = (word32) esp + 4;
			esp -= 4;
			*esp = ebp;
			ebp = esp;
			esp -= -0x00002811;
l0040C817:
			--bl;
			bl |= 0x2E;
			ecx |= ebx;
			&al.u4->u0 = (byte) al + 30;
			SCZO = cond(al);
			do
			{
				&ebx.u4->u0 = (word32) ebx + 1;
				SZO = cond(ebx);
l0040C823:
				v39 = (edx & 0x01 << 0x20 - 0x19) != 0x00;
				edx = __rol<word32,byte>(edx, 0x19);
				cl >>= cl;
				SCZ = cond(cl);
				dx = dx + si + C;
				bh &= al;
				C.u0 = false;
				ch = ch + dh + C;
				SCZO = cond(ch);
				v41 = (cx & 0x01 << 0x10 - cl) != 0x00;
				cx = __rol<word16,byte>(cx, cl);
				C = v41;
				if (Test(EQ,Z))
				{
l0040C49E:
					cl = (bool) C.u0 + ((byte) cl + 35);
					SCZO = cond(cl);
l0040C49F:
					eax <<= 0x0A;
					SCZO = cond(eax);
					cl = cl + bh + C;
					SCZO = cond(cl);
					ax = ax - dx - C;
					al.u0 = 0xE0;
					C = cl != 0x00;
					cl = -cl;
					SZO = cond(cl);
					v44 = (ecx & 0x01 << 0x19) != 0x00;
					ecx = __rcr<word32,byte>(ecx, 0x19, C);
					C = v44;
					if (Test(EQ,Z))
						goto l0040C845;
					eax = eax;
					if (Test(NE,Z))
						goto l0040C845;
					esp = ebp;
					ebp = *esp;
					&esp.u4->u0 = (word32) esp + 4;
					esp -= 4;
					*esp = ebp;
					ebp = esp;
					esp -= 0x00005B77;
					goto l0040C4C2;
				}
				eax = eax;
				if (Test(NE,Z))
					goto l0040C49E;
			} while (Test(LE,SZO));
			esi -= *(ui32 *) 584461285;
			SCZO = cond(esi);
l0040C845:
			if (Test(OV,O))
				__syscall<byte>(0x04);
			al = -al;
			esi <<= 0x0E;
			SCZO = cond(esi);
			edx = edx - esi - C;
			ch |= ~0x14;
			cx >>= cl;
			si = (word16) si + 1;
			ch = (byte) ch + 1;
			ax &= cx;
			C.u0 = false;
			v45 = (eax & 0x01 << 0x17) != 0x00;
			eax = __rcr<word32,byte>(eax, 0x17, C);
			dh |= 0x77;
			C.u0 = false;
			--ah;
			SZO = cond(ah);
			v46 = (esi & 0x01 << 0x20 - 0x02) != 0x00;
			esi = __rcl<word32,byte>(esi, 0x02, C);
			v47 = (dx & 0x01 << cl) != 0x00;
			dx = __ror<word16,byte>(dx, cl);
			C = v47;
l0040BEA3:
			ecx = edi;
			dh -= 0xC1;
			v48 = (edi & 0x01 << 0x0F) != 0x00;
			edi = __ror<word32,byte>(edi, 0x0F);
			bl &= 0x41;
			cx = cx ^ dx;
			ch &= bh;
			C.u0 = false;
			v49 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rcl<byte,byte>(ch, cl, C);
			C = v49;
			ch = ch + dh + C;
			SCZO = cond(ch);
			cl = cl + bl + C;
			SCZO = cond(cl);
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					v50 = ecx.u5->b22CE03B6 << cl;
					ecx.u5->b22CE03B6 = v50;
					SCZO = cond(v50);
					return;
				}
			}
			v51 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			--bh;
			edi >>= cl;
			edi |= eax;
			C.u0 = false;
			edx = edx - ecx - C;
			bh >>= cl;
			SCZO = cond(bh);
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					edx_eax = (int64) eax;
					ecx -= (struct Eq_443 *) 0x01;
					SZO = cond(ecx);
					eax = *(union Eq_3 *) 783307316;
l0040C2F9:
					al.u0 = 0x2E;
l0040C2FB:
					SCZO = cond(eax - 0xC000002E);
					if (Test(NE,Z))
					{
						di = (word16) di + 1;
						ch <<= cl;
						edx = -edx;
						v54 = (edi & 0x01 << 0x20 - 0x1A) != 0x00;
						edi = __rol<word32,byte>(edi, 0x1A);
						v55 = (dh & 0x01 << cl) != 0x00;
						dh = __ror<byte,byte>(dh, cl);
						esi <<= cl;
						v56 = (edx & 0x01 << 0x11) != 0x00;
						edx = __ror<word32,byte>(edx, 0x11);
						C = v56;
						bh = (bool) C.u0 + ((byte) bh + 0x00AC);
						SCZO = cond(bh);
						&al.u4->u0 = (bool) C.u0 + ((byte) al + 77);
						SCZO = cond(al);
						return;
					}
l0040C106:
					esi = esi ^ edi;
					dl |= cl;
					bl += al;
					ah += dl;
					SCZO = cond(ah);
					v58 = (bl & 0x01 << 0x08 - cl) != 0x00;
					bl = __rol<byte,byte>(bl, cl);
					C = v58;
					if (Test(NE,Z))
					{
						eax = eax;
						if (Test(EQ,Z))
						{
							eax = *esp;
							&esp.u4->u0 = (word32) esp + 4;
							*(union Eq_3 *) 0x062615E8 = eax;
							&ebx.u4->u0 = (word32) ebx + 1;
							SZO = cond(ebx);
l0040C125:
							cl <<= cl;
							v59 = (di & 0x01 << 0x10 - cl) != 0x00;
							di = __rol<word16,byte>(di, cl);
							C = v59;
							ch = dh;
							cl = cl + al + C;
							v60 = (ch & 0x01 << cl) != 0x00;
							ch = __ror<byte,byte>(ch, cl);
							C = v60;
							cl = cl - 0xD2 - C;
							ecx <<= 0x0C;
							v61 = (ecx & 0x01 << 0x20 - 0x06) != 0x00;
							ecx = __rol<word32,byte>(ecx, 0x06);
							ebx |= ecx;
							bh += al;
							SCZO = cond(bh);
							v62 = (bl & 0x01 << cl) != 0x00;
							bl = __rcr<byte,byte>(bl, cl, C);
							esi <<= cl;
							SCZO = cond(esi);
							fn0040DA87();
							while (true)
							{
								eax = eax - ecx - C;
								SCZO = cond(eax);
								ecx = *esp;
								&esp.u4->u0 = (word32) esp + 4;
								&esp.u4->u0 = (word32) esp + 1;
								SZO = cond(esp);
								&((byte) edi.u0 - 335113107)->u4->u0 = 0x8E;
								es = *esp;
								&esp.u4->u0 = (word32) esp + 2;
								if (Test(UGE,C))
									break;
								al = al ^ 0x2D;
								&((word32) edx + (esi * 0x02 + 2090873980))->u4->u0 = cs;
								esp = esp ^ *edx;
								SZ = cond(esp);
								O = false;
								C.u0 = false;
								if (Test(LT,SO))
								{
									esp -= 4;
									esp->u0 = 545016661;
									esp -= 4;
									*esp = eax;
									v68 = esp;
									esp = eax;
									eax = v68;
									*((byte) esi.u0 + (eax * 0x04 + 0x353C8C8C)) = *esp;
									&esp.u4->u0 = (word32) esp + 4;
									al |= 0x92;
									esp -= 4;
									*esp = eax;
									*((byte) esi.u0 - 330263925) = ds;
									edx.u5->t9F49B9A7.u4 = (Eq_3 (*)[]) *esp;
									&esp.u4->u0 = (word32) esp + 4;
									v69 = *(ui32 *) 0xD48F8C8C ^ ebp;
									*(ui32 *) 0xD48F8C8C = v69;
									SZ = cond(*(ui32 *) 0xD48F8C8C);
									v70 = *((byte) esi.u0 - 100) - edi;
									&((byte) esi.u0 - 100)->u4->u0 = v70;
									SCZO = cond(v70);
									edi.u0 = 0x8C8C2D46;
									--esi;
									cl = cl - *ecx - C;
									esp -= 4;
									esp->u0 = 1356116122;
									al = __in<byte>(dx);
									edx.u5->t9F49B9A7.u4 = (Eq_3 (*)[]) *esp;
									&esp.u4->u0 = (word32) esp + 4;
									v71 = ebx;
									ebx = eax;
									eax = v71;
									eax -= 1989119116;
									ch = ch ^ *esi.u0;
									SZ = cond(ch);
									O = false;
									C.u0 = false;
									fn4E3F69DB();
									return;
								}
								*(union Eq_3 *) ~0x54D0407C = al;
								Mem0[ebp + 3415166327 + edx:word16] = cs;
								&eax.u4->u0 = (bool) C.u0 + ((word32) eax + 0x35FA2ADD);
								SCZO = cond(eax);
								ds = *esp;
								&esp.u4->u0 = (word32) esp + 2;
								*ecx = *esp;
								&esp.u4->u0 = (word32) esp + 4;
								eax = eax;
								if (Test(NE,Z))
								{
									bx = (word16) bx + 1;
									bl &= ah;
									SZ = cond(bl);
									O = false;
									C.u0 = false;
									goto l0040C249;
								}
								&eax.u4->u0 = (word32) eax - 1251713276;
								SCZO = cond(eax);
								if (Test(OV,O))
									__syscall<byte>(0x04);
								&al.u4->u0 = (byte) al + 88;
								SCZO = cond(al);
								v74 = (eax & 0x01 << cl) != 0x00;
								eax = __rcr<word32,byte>(eax, cl, C);
								eax >>= cl;
								SCZO = cond(eax);
								v75 = (cl & 0x01 << cl) != 0x00;
								cl = __rcr<byte,byte>(cl, cl, C);
								v76 = (edi & 0x01 << 0x0D) != 0x00;
								edi = __ror<word32,byte>(edi, 0x0D);
								v77 = (cx & 0x01 << cl) != 0x00;
								cx = __ror<word16,byte>(cx, cl);
								C = v77;
								v78 = (ebx & 0x01 << cl) != 0x00;
								ebx = __rcr<word32,byte>(ebx, cl, C);
								bh = ~bh;
								C = esi != 0x00;
								esi = -esi;
								al = al - 0xC5 - C;
								SCZO = cond(al);
								v79 = (ecx & 0x01 << 0x1D) != 0x00;
								ecx = __rcr<word32,byte>(ecx, 0x1D, C);
								C = v79;
								if (Test(EQ,Z))
									goto l0040C817;
								eax = eax;
								if (Test(NE,Z))
									goto l0040C817;
								__out<byte>(dx, al);
								eax = *esi.u0;
								&esi.u4->u0 = (byte) esi.u0 + 4;
								v80 = *(ui8 *) 0xE8833EA4 ^ cl;
								*(ui8 *) 0xE8833EA4 = v80;
								SZ = cond(*(ui8 *) 0xE8833EA4);
								O = false;
								C.u0 = false;
							}
							&al.u4->u0 = (byte) al + 0x00FE;
							SCZO = cond(al);
							return;
						}
					}
					cx = (word16) cx + 1;
					ah += bh;
					ax = (word16) ax + 1;
					edx |= ecx;
					v67 = (ecx & 0x01 << 0x03) != 0x00;
					ecx = __ror<word32,byte>(ecx, 0x03);
					dx |= di;
					SZ = cond(dx);
					O = false;
					C.u0 = false;
					dl.u0 = 0x9A;
					ebx <<= cl;
					SCZO = cond(ebx);
l0040BFE3:
					dh >>= cl;
					cl = -cl;
					ch >>= cl;
					eax -= ecx;
					di <<= cl;
					SCZO = cond(di);
					v72 = (esi & 0x01 << 0x20 - 0x08) != 0x00;
					esi = __rcl<word32,byte>(esi, 0x08, C);
					cl = (byte) cl + 0x00F6;
					esi <<= 0x08;
					ecx |= ebx;
					SZ = cond(ecx);
					O = false;
					C.u0 = false;
					if (Test(NE,Z))
					{
						eax = eax;
						if (Test(EQ,Z))
						{
							v73 = *((byte) eax.u0 + 23) ^ bl;
							&((byte) eax.u0 + 23)->u4->u0 = v73;
							SZ = cond(*((byte) eax.u0 + 23));
							SZP = cond(ebp.u5->dwC34DD080 & esi);
							O = false;
							C.u0 = false;
						}
					}
					eax.u0 = 0x03;
l0040C3DD:
					v81 = (bl & 0x01 << cl) != 0x00;
					bl = __ror<byte,byte>(bl, cl);
					v82 = (edi & 0x01 << cl) != 0x00;
					edi = __ror<word32,byte>(edi, cl);
					C = v82;
					v83 = (cx & 0x01 << cl) != 0x00;
					cx = __rcr<word16,byte>(cx, cl, C);
					dh = ~dh;
					edi <<= 0x17;
					SCZO = cond(edi);
					cl = cl + ah + C;
					SCZO = cond(cl);
					v84 = (ecx & 0x01 << 0x17) != 0x00;
					ecx = __rcr<word32,byte>(ecx, 0x17, C);
					C = v84;
					bh = (byte) bh + 1;
					cl = cl + dl + C;
					bh -= dl;
					SCZO = cond(bh);
					ch = ch - al - C;
					SCZO = cond(ch);
l0040C4C2:
					__fldenv(esi.u5->w0013);
				}
			}
			v57 = (ebx & 0x01 << 0x0F) != 0x00;
			ebx = __rcr<word32,byte>(ebx, 0x0F, C);
			cl = (byte) cl + 229;
			SCZO = cond(cl);
			al = al - ah - C;
			SCZO = cond(al);
			return;
		}
	}
	bl = bl + bh + C;
	cx = dx;
	al -= dl;
	ch = ch ^ 0x09;
	--ah;
	al += bl;
	bh >>= cl;
	al -= dh;
	al |= ch;
	C.u0 = false;
	--ah;
	ch = (bool) C.u0 + ((byte) ch + 46);
	SCZO = cond(ch);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			v94 = gs->*((byte) edi.u0 - 1205211854) ^ ebx;
			&(gs->*((byte) edi.u0 - 1205211854)).u4->u0 = v94;
			SZ = cond(gs->*((byte) edi.u0 - 1205211854));
			O = false;
			C.u0 = false;
			goto l0040C3DD;
		}
	}
	dx -= ax;
	SCZO = cond(dx);
l0040C50A:
	bh = bh - ch - C;
	ch += al;
	SCZO = cond(ch);
	v100 = (dl & 0x01 << cl) != 0x00;
	dl = __rcr<byte,byte>(dl, cl, C);
	dh = (byte) dh + 1;
	bh <<= cl;
	eax >>= cl;
	ax = -ax;
	v101 = (edx & 0x01 << 0x1E) != 0x00;
	edx = __ror<word32,byte>(edx, 0x1E);
	C = v101;
	bx = di;
	v102 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	&ebx.u4->u0 = (word32) ebx + 1;
	SZO = cond(ebx);
	v103 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	C = v103;
	v108 = (edi & 0x01 << 11) != 0x00;
	edi = __rcr<word32,byte>(edi, 11, C);
	eax >>= cl;
	bh -= ~0x44;
	dl &= 0x07;
	di -= si;
	SCZO = cond(di);
	ch = (bool) C.u0 + ((byte) ch + 0x0087);
	dl >>= cl;
	al >>= cl;
	SCZO = cond(al);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			eax &= 4181294132;
			C = __aaa(al, ah, &al, &ah);
			edx <<= cl;
			al >>= cl;
			edi >>= 0x11;
			v109 = (bl & 0x01 << cl) != 0x00;
			bl = __ror<byte,byte>(bl, cl);
			C = v109;
			v110 = (si & 0x01 << 0x10 - cl) != 0x00;
			si = __rcl<word16,byte>(si, cl, C);
			C = v110;
			ch = (bool) C.u0 + ((byte) ch + 225);
			SCZO = cond(ch);
			v111 = (edx & 0x01 << 0x20 - cl) != 0x00;
			edx = __rcl<word32,byte>(edx, cl, C);
			edi >>= 0x08;
			SCZO = cond(edi);
			si = cx;
l0040C0DE:
			v112 = (eax & 0x01 << 0x0F) != 0x00;
			eax = __ror<word32,byte>(eax, 0x0F);
			--dh;
			v113 = (ebx & 0x01 << 0x20 - 0x19) != 0x00;
			ebx = __rol<word32,byte>(ebx, 0x19);
			C = v113;
			bh = bh - bl - C;
			bl += dh;
			dx = (word16) dx + 1;
			bx >>= cl;
			ah = ah ^ ch;
			SZ = cond(ah);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					v114 = (edx.u5->tFFFFFF97.u4 & 0x01 << cl) != 0x00;
					edx.u5->tFFFFFF97.u4 = (Eq_3 (*)[]) __rcr<word32,byte>(edx.u5->tFFFFFF97.u4, cl, C);
					C = v114;
					dl = dl + al + C;
					SCZO = cond(dl);
					goto l0040C106;
				}
			}
			dl = ~dl;
			cl <<= cl;
			ah <<= cl;
			ebx -= eax;
			bh >>= cl;
			al >>= cl;
			ax <<= cl;
			dl &= 166;
			v116 = (ah & 0x01 << cl) != 0x00;
			ah = __ror<byte,byte>(ah, cl);
			al = al ^ 22;
			al <<= cl;
			SCZO = cond(al);
			ah >>= cl;
			SCZ = cond(ah);
			if (Test(EQ,Z))
				return;
			eax = eax;
			if (Test(NE,Z))
				return;
			ds = *esp;
			&esp.u4->u0 = (word32) esp + 2;
			&esi.u4->u0 = (word32) esi + 0x66258226;
			goto l0040C50A;
		}
	}
	ah -= 225;
	SCZO = cond(ah);
	cl = cl + ah + C;
	SCZO = cond(cl);
l0040C8A3:
	v115 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	ch = ch ^ bl;
	edi >>= cl;
	bl = bl ^ al;
	dl = (byte) dl.u0 + 75;
	SCZO = cond(dl);
	--ecx;
	dh = bl;
	v117 = (ax & 0x01 << 0x10 - cl) != 0x00;
	ax = __rol<word16,byte>(ax, cl);
	bx &= dx;
	C.u0 = false;
	v118 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	--ch;
	--bl;
	bh >>= cl;
	SCZO = cond(bh);
l0040BF00:
	v119 = (eax & 0x01 << 0x01) != 0x00;
	eax = __ror<word32,byte>(eax, 0x01);
	bl |= 0x45;
	dl <<= cl;
	al <<= cl;
	SCZO = cond(al);
	cl = cl - dl - C;
	SCZO = cond(cl);
	bh = bl;
	ax <<= cl;
	SCZO = cond(ax);
	&al.u4->u0 = (bool) C.u0 + ((byte) al + 65);
	al |= ch;
	dl >>= cl;
	edi = edi ^ ecx;
	C.u0 = false;
	v131 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v131;
	dx = dx + cx + C;
	SCZO = cond(dx);
	dl = dl - 0x38 - C;
	SCZO = cond(dl);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(NS,S))
		{
			v133 = (bool) C.u0 + ((byte) ah + (esi.u5)->b0023);
			esi.u5->b0023 = v133;
			SCZO = cond(v133);
			return;
		}
	}
	while (true)
	{
		v134 = (ecx & 0x01 << 11) != 0x00;
		ecx = __ror<word32,byte>(ecx, 11);
		C = v134;
		v135 = (dl & 0x01 << 0x08 - cl) != 0x00;
		dl = __rcl<byte,byte>(dl, cl, C);
		dl |= bl;
		dh -= 0x04;
		eax <<= cl;
		dl = (byte) dl.u0 + 1;
		bl = bl ^ 0x89;
		C.u0 = false;
		dl = (bool) C.u0 + ((byte) dl + 211);
		di |= bx;
		SZ = cond(di);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				fn2D45_B63A();
				return;
			}
		}
		bh >>= cl;
		dl <<= cl;
		bh |= 223;
		ah >>= cl;
		ecx >>= 0x1E;
		SCZ = cond(ecx);
		dl = dl - ~0x41 - C;
		dx >>= cl;
		--cx;
		ah -= dh;
		SCZO = cond(ah);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(NE,Z))
				goto l0040BE75;
			fnDF82_FE55();
			&ecx.u4->u0 = (word32) ecx + 1;
			eax -= 3693232998;
			SCZO = cond(eax);
l0040C249:
			eax = eax ^ esi;
			ah = ah ^ ch;
			--cl;
			bx |= di;
			C.u0 = false;
			ax = (word16) ax + 1;
			SZO = cond(ax);
			v85 = (esi & 0x01 << 0x20 - 0x1E) != 0x00;
			esi = __rcl<word32,byte>(esi, 0x1E, C);
			C = v85;
			if (Test(EQ,Z))
			{
l0040C531:
				ecx <<= 0x05;
				al &= bl;
				ah = ah ^ 0x32;
				C.u0 = false;
				bl = bl + ch + C;
				eax -= ecx;
				SCZO = cond(eax);
				v96 = fs->t0030;
				esp -= 4;
				*esp = v96;
				eax = *esp;
				&esp.u4->u0 = (word32) esp + 4;
				v97 = (ebx & 0x01 << 0x20 - 0x07) != 0x00;
				ebx = __rcl<word32,byte>(ebx, 0x07, C);
				C = v97;
				--cl;
				bh = bh + al + C;
				cl += bh;
				SCZO = cond(cl);
				C = si != 0x00;
				si = -si;
				SZO = cond(si);
				goto l0040C7C7;
			}
			eax = eax;
			if (Test(NE,Z))
				goto l0040C531;
			FPUF.u0 = cond(Top->r0000 - Top->r0004);
			Top = (struct Eq_5 *) ((char *) &Top->r0000 + 1);
			if (Test(UGE,C))
			{
				*edi.u0 = al;
				++edi;
l0040C26A:
				v88 = (si & 0x01 << cl) != 0x00;
				si = __ror<word16,byte>(si, cl);
				C = v88;
				v89 = (ebx & 0x01 << 0x20 - 0x0C) != 0x00;
				ebx = __rcl<word32,byte>(ebx, 0x0C, C);
				si <<= cl;
				SCZO = cond(si);
				v90 = (edi & 0x01 << 0x20 - 0x11) != 0x00;
				edi = __rcl<word32,byte>(edi, 0x11, C);
				ecx <<= 0x1C;
				di &= cx;
				bx -= si;
				SCZO = cond(bx);
				v91 = (bx & 0x01 << cl) != 0x00;
				bx = __rcr<word16,byte>(bx, cl, C);
				C = v91;
				v92 = (cl & 0x01 << cl) != 0x00;
				cl = __rcr<byte,byte>(cl, cl, C);
				C = ebx != 0x00;
				ebx = -ebx;
				SZO = cond(ebx);
				bl = (bool) C.u0 + ((byte) bl + 229);
				SCZO = cond(bl);
				v98 = (bx & 0x01 << 0x10 - cl) != 0x00;
				bx = __rcl<word16,byte>(bx, cl, C);
				C = v98;
				v99 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rcl<byte,byte>(bl, cl, C);
				C = v99;
				ch = (bool) C.u0 + ((byte) ch + 80);
				SCZO = cond(ch);
				ch = ch - 0x25 - C;
				ch <<= cl;
				SCZO = cond(ch);
				ch = ah;
				SCZO = cond(edx - 0x0131C0A1);
				if (Test(EQ,Z))
				{
					v105 = (si & 0x01 << 0x10 - cl) != 0x00;
					si = __rol<word16,byte>(si, cl);
					C = v105;
					eax = eax - ebx - C;
					SCZO = cond(eax);
					bh = bh + al + C;
					SCZO = cond(bh);
					v106 = (ch & 0x01 << cl) != 0x00;
					ch = __rcr<byte,byte>(ch, cl, C);
					si >>= cl;
					v107 = (edx & 0x01 << 0x20 - 0x1E) != 0x00;
					edx = __rol<word32,byte>(edx, 0x1E);
					C = bh != 0x00;
					bh = -bh;
					&al.u4->u0 = (bool) C.u0 + ((byte) al + 48);
					bx -= si;
					ah -= 0x68;
					ebx >>= 0x01;
					SCZ = cond(ebx);
					O = false;
					dl = dl + bl + C;
					ah |= 0x6B;
					SZ = cond(ah);
					O = false;
					C.u0 = false;
					return;
				}
				bx = (word16) bx + 1;
				v120 = (cl & 0x01 << 0x08 - cl) != 0x00;
				cl = __rcl<byte,byte>(cl, cl, C);
				bl = bl ^ 0x66;
				C.u0 = false;
				bl = bl + bh + C;
				bx = bx ^ dx;
				di &= cx;
				ch += bh;
				SCZO = cond(ch);
				di = (word16) di + 1;
				ch = ch + dl + C;
				SCZO = cond(ch);
				v121 = (bl & 0x01 << cl) != 0x00;
				bl = __rcr<byte,byte>(bl, cl, C);
				C = v121;
				if (Test(NE,Z))
				{
					eax = eax;
					if (Test(EQ,Z))
					{
						C = __daa(al, &al);
						ah = SCZOP;
						C = __aaa(al, ah, &al, &ah);
						&esi.u4->u0 = &(esi.u4 + (esi.u5)->dwEF22EEBB / 8)->u0;
						SCZO = cond(esi);
						goto l0040C469;
					}
				}
				di &= bx;
				ch |= 244;
				C.u0 = false;
				bl = bl - dh - C;
				bx -= ax;
				SCZO = cond(bx);
				v143 = (eax & 0x01 << 0x01) != 0x00;
				eax = __ror<word32,byte>(eax, 0x01);
				C = v143;
				if (Test(UGE,C))
				{
					bx = -bx;
					cl = -cl;
					v144 = (si & 0x01 << cl) != 0x00;
					si = __ror<word16,byte>(si, cl);
					ebx = ebx ^ edi;
					C.u0 = false;
					v145 = (esi & 0x01 << 0x20 - 22) != 0x00;
					esi = __rcl<word32,byte>(esi, 22, C);
					cl >>= cl;
					bh += dl;
					SCZO = cond(bh);
					if (Test(EQ,Z))
						goto l0040C125;
					eax = eax;
					if (Test(NE,Z))
						goto l0040C125;
					esp -= 2;
					*esp = ss;
					eax = eax - 0xCC1286A9 - C;
					SCZO = cond(eax);
					goto l0040BF71;
				}
				si <<= cl;
				bl <<= cl;
				ch >>= cl;
				SCZ = cond(ch);
				v148 = (edi & 0x01 << 0x20 - 0x04) != 0x00;
				edi = __rcl<word32,byte>(edi, 0x04, C);
				v149 = (ebx & 0x01 << cl) != 0x00;
				ebx = __ror<word32,byte>(ebx, cl);
				edi = edi ^ edx;
				SZ = cond(edi);
				O = false;
				C.u0 = false;
				bh &= 0xA9;
				bl = -bl;
				cl = -cl;
				si >>= cl;
				SCZO = cond(si);
				bh = bh - ch - C;
				v157 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rol<byte,byte>(bl, cl);
				C = v157;
				ch = ch + ah + C;
				edi >>= 0x01;
				SCZO = cond(edi);
				v158 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rcl<byte,byte>(bl, cl, C);
				ebx |= edi;
				bl <<= cl;
				SCZO = cond(bl);
				v159 = (esi & 0x01 << 0x20 - 0x18) != 0x00;
				esi = __rol<word32,byte>(esi, 0x18);
				C = v159;
				v160 = (ch & 0x01 << cl) != 0x00;
				ch = __rcr<byte,byte>(ch, cl, C);
				C = v160;
				if (Test(NE,Z))
				{
					eax = eax;
					if (Test(EQ,Z))
					{
						esp |= *edi.u0;
						SCZO = cond(*((byte) edi.u0 - 61) - bl);
						esp -= 4;
						esp->u0 = 0x12E1EC80;
						goto l0040C8A3;
					}
				}
				ebx <<= 0x03;
				SCZO = cond(ebx);
				ch = ch - 233 - C;
				SCZO = cond(ch);
				ebx = ebx - edi - C;
				bh -= ah;
				ch >>= cl;
				ecx <<= 0x0F;
				SCZO = cond(ecx);
				esi >>= 0x1D;
				SCZO = cond(esi);
l0040C8DF:
				eax = gs;
				--cl;
				bh = bh + dh + C;
				SCZO = cond(bh);
				v165 = (ebx & 0x01 << 0x05) != 0x00;
				ebx = __rcr<word32,byte>(ebx, 0x05, C);
				ch >>= cl;
				bh <<= cl;
				SCZO = cond(bh);
				si = si - ax - C;
				edi = -edi;
				ecx = ecx ^ edi;
				C.u0 = false;
				bh = (byte) bh + 1;
				SZO = cond(bh);
				ch.u0 = ~0x62;
				v169 = (di & 0x01 << 0x10 - cl) != 0x00;
				di = __rol<word16,byte>(di, cl);
				v170 = (ch & 0x01 << cl) != 0x00;
				ch = __ror<byte,byte>(ch, cl);
				si = -si;
				v171 = (edi & 0x01 << 22) != 0x00;
				edi = __ror<word32,byte>(edi, 22);
				ebx <<= 0x04;
				SCZO = cond(ebx);
				v172 = (ebx & 0x01 << 0x20 - 0x1E) != 0x00;
				ebx = __rcl<word32,byte>(ebx, 0x1E, C);
				C = si != 0x00;
				si = -si;
				bh = (byte) bh + 1;
				di = di + dx + C;
				SCZO = cond(di);
l0040C469:
				cl = (bool) C.u0 + ((byte) cl + 43);
				v123 = (esi & 0x01 << 22) != 0x00;
				esi = __ror<word32,byte>(esi, 22);
				cx &= dx;
				&edx.u4->u0 = (word32) edx + 1;
				ch &= 0x46;
				ch = bl;
				v124 = (ecx & 0x01 << 0x20 - 0x01) != 0x00;
				ecx = __rol<word32,byte>(ecx, 0x01);
				v125 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rol<byte,byte>(bl, cl);
				si += bx;
				SCZO = cond(si);
				v126 = (ch & 0x01 << 0x08 - cl) != 0x00;
				ch = __rcl<byte,byte>(ch, cl, C);
				v127 = (cl & 0x01 << 0x08 - cl) != 0x00;
				cl = __rol<byte,byte>(cl, cl);
				C = si != 0x00;
				si = -si;
				SZO = cond(si);
				if (Test(NE,Z))
				{
					eax = eax;
					if (Test(EQ,Z))
					{
						v128 = *edx ^ ah;
						*edx = v128;
						SZ = cond(*edx);
						v129 = ecx.u5->b8025B3FF << cl;
						ecx.u5->b8025B3FF = v129;
						SCZO = cond(v129);
						goto l0040C49F;
					}
				}
				goto l0040C26A;
			}
l0040C2BB:
			v173 = (edx & 0x01 << 0x0C) != 0x00;
			edx = __rcr<word32,byte>(edx, 0x0C, C);
			SCZO = cond(esi - 652012437);
			if (Test(NE,Z))
				goto l0040BF27;
			dl = (byte) dl + 1;
			bh = bh - 0xA9 - C;
			SCZO = cond(bh);
l0040BF71:
			ebx = ebx ^ edx;
			al &= bh;
			C.u0 = false;
			ecx = ecx - eax - C;
			--cx;
			ebx = ebx ^ edi;
			C.u0 = false;
			ch = (bool) C.u0 + ((byte) ch.u0 + 0x008E);
			eax.u0 = 0x94C85CB5;
			ebx <<= 0x11;
			bl |= dh;
			SZ = cond(bl);
			O = false;
			C.u0 = false;
			v146 = (dh & 0x01 << cl) != 0x00;
			dh = __rcr<byte,byte>(dh, cl, C);
			v147 = (bx & 0x01 << 0x10 - cl) != 0x00;
			bx = __rol<word16,byte>(bx, cl);
			C = v147;
			dl |= bh;
			bh &= dh;
			SZ = cond(bh);
			O = false;
			C.u0 = false;
		}
l0040BE75:
		al &= 0x35;
		bl = ch;
		v150 = (cl & 0x01 << cl) != 0x00;
		cl = __ror<byte,byte>(cl, cl);
		v151 = (eax & 0x01 << 0x20 - 0x09) != 0x00;
		eax = __rol<word32,byte>(eax, 0x09);
		edx <<= 0x1B;
		edx >>= cl;
		bh |= 0x6A;
		C.u0 = false;
		v152 = (bh & 0x01 << cl) != 0x00;
		bh = __rcr<byte,byte>(bh, cl, C);
		C = cl != 0x00;
		cl = -cl;
		SZO = cond(cl);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				v153 = edx;
				edx = eax;
				eax = v153;
				esp -= 4;
				*esp = SCZDOP;
				if (Test(SG,S))
					goto l0040BF00;
				v155 = esi.u5->dw6602D6C1 - esp - C;
				esi.u5->dw6602D6C1 = v155;
				SCZO = cond(v155);
				goto l0040BEA3;
			}
		}
		cl = (byte) cl + 131;
		al <<= cl;
		ch <<= cl;
		v168 = (edx & 0x01 << 0x1D) != 0x00;
		edx = __ror<word32,byte>(edx, 0x1D);
		dx >>= cl;
		ax >>= cl;
		dl = dl ^ 0x7C;
		&esi.u4->u0 = (word32) esi + 0x7CD44458;
		cl >>= cl;
		&ebx.u4->u0 = (word32) ebx + 1;
		edx <<= 0x17;
		bl = bl ^ 0x3A;
		ax |= bx;
		SZ = cond(ax);
		O = false;
		C.u0 = false;
		if (Test(EQ,Z))
			break;
		eax = eax;
		if (Test(NE,Z))
			break;
		esp -= 4;
		*esp = edi;
		SZP = cond(ecx.u5->bFFFFFF93 & ~0x04);
		dl += bl;
		SCZO = cond(dl);
l0040C74E:
		ebx >>= cl;
		dh = dh ^ al;
		dl = dl ^ 244;
		bl &= ch;
		ecx += ebx;
		SCZO = cond(ecx);
		v156 = (dx & 0x01 << cl) != 0x00;
		dx = __rcr<word16,byte>(dx, cl, C);
		bl >>= cl;
		SCZO = cond(bl);
		bl >>= cl;
		--dh;
		dl.u0 = 0x86;
		ebx >>= cl;
		eax &= ~0x11111111;
		SZ = cond(eax);
		O = false;
		C.u0 = false;
		v161 = (si & 0x01 << 0x10 - cl) != 0x00;
		si = __rcl<word16,byte>(si, cl, C);
		C = v161;
		v162 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v162;
		v163 = (dl & 0x01 << 0x08 - cl) != 0x00;
		dl = __rcl<byte,byte>(dl, cl, C);
		cl <<= cl;
		v164 = (cx & 0x01 << cl) != 0x00;
		cx = __ror<word16,byte>(cx, cl);
		C = v164;
		dh = dh + bl + C;
		SCZO = cond(dh);
		dh = (bool) C.u0 + ((byte) dh + 0x00AC);
		SCZO = cond(dh);
		cl = ~cl;
		cl = cl + dl + C;
		eax -= ~0x11111111;
		ch = ch ^ dl;
		SZ = cond(ch);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				eax = eax ^ 3822318090;
				SZ = cond(eax);
				O = false;
				C.u0 = false;
				goto l0040BFE3;
			}
		}
		ch &= 111;
		bh >>= cl;
		SCZO = cond(bh);
		v166 = (dh & 0x01 << cl) != 0x00;
		dh = __rcr<byte,byte>(dh, cl, C);
		--cx;
		v167 = (cx & 0x01 << 0x10 - cl) != 0x00;
		cx = __rol<word16,byte>(cx, cl);
		C = v167;
		ch = ch - al - C;
		SCZO = cond(ch);
		ch = ch + bh + C;
		bh = dh;
		C = bl != 0x00;
		bl = -bl;
		bl = bl - al - C;
		SCZO = cond(bl);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(NE,Z))
				goto l0040C8B7;
			if (Test(LE,SZO))
				goto l0040C823;
			--ebx;
			eax |= 3740755594;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
l0040C7C7:
			esi >>= cl;
			edi = edi ^ ebx;
			dl |= dh;
			C.u0 = false;
			v104 = (di & 0x01 << cl) != 0x00;
			di = __rcr<word16,byte>(di, cl, C);
			bl -= ah;
			bh &= dh;
			SZ = cond(bh);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
					__cli();
			}
			v130 = *((byte) eax.u0 + 144);
			esp -= 4;
			*esp = v130;
			eax = *esp;
			&esp.u4->u0 = (word32) esp + 4;
			dh = (byte) dh + 18;
			ch = (byte) ch + 1;
			cx = -cx;
			esi <<= 22;
			bl |= ah;
			dh = dh ^ 0x7E;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					al = al ^ 0x35;
					SZ = cond(al);
					O = false;
					C.u0 = false;
					FPUF.u0 = cond(Top->r0000 - (real64) (ebp.u5)->w0079);
					Top = (struct Eq_5 *) ((char *) &Top->r0000 + 1);
					al.u0 = 0x66;
					goto l0040C0DE;
				}
			}
			cl = cl ^ al;
			dl = dl ^ 0x06;
			v136 = (ch & 0x01 << cl) != 0x00;
			ch = __ror<byte,byte>(ch, cl);
			ebx = ebx ^ eax;
			ebx >>= cl;
			SCZO = cond(ebx);
			v137 = *eax.u0;
			esp -= 4;
			*esp = v137;
			eax = *esp;
			&esp.u4->u0 = (word32) esp + 4;
			v138 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rol<byte,byte>(ch, cl);
			ch = ~ch;
			v139 = (dx & 0x01 << cl) != 0x00;
			dx = __ror<word16,byte>(dx, cl);
			ebx >>= 0x17;
			SCZ = cond(ebx);
			goto l0040C6C3;
		}
l0040C8B7:
		esi += ebx;
		eax |= eax;
		SZ = cond(eax);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax |= eax;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
				return;
		}
		dl += cl;
		v176 = (bl & 0x01 << cl) != 0x00;
		bl = __ror<byte,byte>(bl, cl);
		C = v176;
		v177 = (ebx & 0x01 << 0x1D) != 0x00;
		ebx = __rcr<word32,byte>(ebx, 0x1D, C);
		C = v177;
		bh = bh + dl + C;
		SCZO = cond(bh);
		--dx;
		SZO = cond(dx);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				__fldcw(*((word32) (ebp - 63) + edi * 0x02));
				goto l0040C8DF;
			}
		}
		edx += ebx;
		SCZO = cond(edx);
		v178 = (edx & 0x01 << 0x20 - cl) != 0x00;
		edx = __rcl<word32,byte>(edx, cl, C);
		dx >>= cl;
		v179 = (ebx & 0x01 << cl) != 0x00;
		ebx = __ror<word32,byte>(ebx, cl);
		bh >>= cl;
		SCZ = cond(bh);
		--dl;
		cx = cx + si + C;
		ecx |= edi;
		SZ = cond(ecx);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(NE,Z))
				goto l0040C558;
			ds_edi = *ecx;
			ch.u0 = 211;
l0040C6C3:
			dh <<= cl;
			esi <<= 0x02;
			dl -= 0x2D;
			SCZO = cond(dl);
			bh = (byte) bh + 1;
			dh = dh + cl + C;
			dx &= di;
			C.u0 = false;
			v140 = (ebx & 0x01 << 0x20 - 0x0A) != 0x00;
			ebx = __rcl<word32,byte>(ebx, 0x0A, C);
			edi <<= 0x01;
			SCZO = cond(edi);
			v141 = (edx & 0x01 << 0x04) != 0x00;
			edx = __rcr<word32,byte>(edx, 0x04, C);
			ecx = ecx ^ edi;
			SZ = cond(ecx);
			O = false;
			C.u0 = false;
			v142 = *((byte) eax.u0 + 8);
			esp -= 4;
			*esp = v142;
			eax = *esp;
			&esp.u4->u0 = (word32) esp + 4;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					esp += esp;
					SCZO = cond(esp);
					fnFE639DF8();
					return;
				}
			}
			esi <<= cl;
			SCZO = cond(esi);
			goto l0040C74E;
		}
l0040C558:
		cl = (byte) cl + 1;
		edx = edx ^ edx;
		esi >>= cl;
		si >>= cl;
		cl = cl ^ 252;
		edi >>= 0x03;
		SCZ = cond(edi);
		cx = cx + si + C;
		SCZO = cond(cx);
		v181 = (ch & 0x01 << cl) != 0x00;
		ch = __rcr<byte,byte>(ch, cl, C);
		C = v181;
		v182 = (ebx & 0x01 << 0x20 - 0x0A) != 0x00;
		ebx = __rcl<word32,byte>(ebx, 0x0A, C);
		C = v182;
		esi = esi - edi - C;
		C = ch != 0x00;
		ch = -ch;
		SZO = cond(ch);
		di = cx;
		__syscall<byte>(0x2E);
		edi = edi + ebx + C;
		--cx;
		v183 = (ebx & 0x01 << cl) != 0x00;
		ebx = __ror<word32,byte>(ebx, cl);
		di += bx;
		SCZO = cond(di);
		si >>= cl;
		ecx >>= cl;
		SCZ = cond(ecx);
		if (Test(EQ,Z))
		{
l0040C57D:
			v185 = (si & 0x01 << 0x10 - cl) != 0x00;
			si = __rol<word16,byte>(si, cl);
			C = v185;
			v186 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rcl<byte,byte>(ch, cl, C);
			--bl;
			di <<= cl;
			v187 = (cl & 0x01 << 0x08 - cl) != 0x00;
			cl = __rol<byte,byte>(cl, cl);
			esi >>= cl;
			v188 = (ch & 0x01 << 0x08 - cl) != 0x00;
			ch = __rol<byte,byte>(ch, cl);
			bx = bx ^ si;
			SCZO = cond(edx - ~0x00);
			if (Test(EQ,Z))
				goto l0040C2F9;
			al.u0 = edx.u5->tFFFFFFFF.u0;
			goto l0040C2FB;
		}
		eax = eax;
		if (Test(NE,Z))
			goto l0040C57D;
		if (Test(EQ,Z))
		{
			v184 = (*((word32) (ecx - 37) + eax * 0x08) & 0x01 << 0x20 - 0x10) != 0x00;
			&((word32) (ecx - 37) + eax * 0x08)->u1->u0 = __rcl<word32,byte>(*((word32) (ecx - 37) + eax * 0x08), 0x10, C);
			C = v184;
			return;
		}
	}
	v174 = (cx & 0x01 << 0x10 - cl) != 0x00;
	cx = __rol<word16,byte>(cx, cl);
	v175 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rol<word32,byte>(eax, cl);
	ah |= bh;
	SZ = cond(ah);
	O = false;
	C.u0 = false;
	goto l0040C2BB;
}

// 0040D513: define fn0040D513
// Called from:
//      fn0040D6EE
//      fn0040DEBA
define fn0040D513
{
	esp = fp;
	Top = null;
	al |= ~0x29;
	di <<= cl;
	ax = -ax;
	edi >>= 0x17;
	al = -al;
	eax = eax ^ edi;
	edi <<= 0x02;
	SCZO = cond(edi);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			edi.u0 = 303504245;
			fn0040D538();
			return;
		}
	}
	al &= ~0x0A;
	al <<= cl;
	ebx -= 0x4C462376;
	al >>= cl;
	v26 = (edi & 0x01 << 0x15) != 0x00;
	edi = __ror<word32,byte>(edi, 0x15);
	eax += edi;
	SCZO = cond(eax);
	--ah;
	SZO = cond(ah);
	al = ~al;
	v28 = (di & 0x01 << cl) != 0x00;
	di = __rcr<word16,byte>(di, cl, C);
	eax <<= cl;
	ah >>= cl;
	--edi;
	v29 = (di & 0x01 << 0x10 - cl) != 0x00;
	di = __rol<word16,byte>(di, cl);
	al &= ah;
	SCZO = cond(ebx - 3015302282);
	if (Test(NE,Z))
		fn0040D762();
	else
	{
		ebx >>= 0x18;
		SCZO = cond(ebx);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				SCZO = cond(*ebx - cl);
				esp -= 4;
				esp->t0000.u4 = (Eq_3 (*)[]) ecx;
				al = (uint8) (C.u5 + (al + 0xA8) /8 2090873980);
				SCZO = cond(al);
				esp = gs;
				ah = ~ah;
				v32 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				C = v32;
				al = 0x88;
				fn0040D62F();
				return;
			}
		}
		bl = (byte) ah.u1 + bl;
		bx |= ax;
		v33 = (ah & 0x01 << cl) != 0x00;
		ah = __ror<byte,byte>(ah, cl);
		C = v33;
		ecx = ecx + edx + C;
		edi >>= 0x13;
		ebx <<= 0x1D;
		SCZO = cond(ebx);
		v34 = (eax & 0x01 << cl) != 0x00;
		eax = __rcr<word32,byte>(eax, cl, C);
		edi = ebx;
		cl = cl ^ bh;
		SZ = cond(cl);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				CZP = cond(*Top - *Top);
				O = false;
				S = false;
				ecx.u5->ptrD315CEC1();
				fn0040DE0E();
				return;
			}
		}
		esi = esi - edx - C;
		ch += dh;
		ax <<= cl;
		ch >>= cl;
		edx <<= 0x15;
		v40 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v40;
		dl = dl - 141 - C;
		SCZO = cond(dl);
		ecx = ecx + edx + C;
		di >>= cl;
		SCZO = cond(di);
		v41 = (dx & 0x01 << cl) != 0x00;
		dx = __rcr<word16,byte>(dx, cl, C);
		C = v41;
		v42 = (ebx & 0x01 << 0x10) != 0x00;
		ebx = __rcr<word32,byte>(ebx, 0x10, C);
		C = v42;
		if (Test(EQ,Z))
			return;
		eax = eax;
		if (Test(NE,Z))
			return;
		Z = ebp->dwC3B80F86 == 0x00;
		edi = __bsf<word32>(ebp->dwC3B80F86);
		si <<= cl;
		cx = -cx;
		C = ah != 0x00;
		ah = -ah;
		ch = dh;
		bl = (ui8) ((bool) C.u0 + ((byte) cl + bl));
		v46 = (edi & 0x01 << 0x20 - 0x1E) != 0x00;
		edi = __rol<word32,byte>(edi, 0x1E);
		edx >>= 0x18;
		ah <<= cl;
		bl <<= cl;
		SCZO = cond(bl);
		v47 = (ecx & 0x01 << 0x20 - 0x06) != 0x00;
		ecx = __rol<word32,byte>(ecx, 0x06);
		C = v47;
		fn0040DF15();
	}
}

// 0040D538: define fn0040D538
// Called from:
//      fn0040D513
//      fn0040D894
define fn0040D538
{
	ptr32 fp;
	byte bh;
	byte al;
	bool C;
	word16 di;
	word32 esi;
	byte cl;
	word24 eax_24_8;
	byte bl;
	word16 edx_16_16;
	word16 ebx_16_16;
	esp_15 = fp;
	Top_16 = 0;
	bh_20 = bh + al + (byte) C;
	dx_22 = di;
	dh_34 = SLICE(di, byte, 8);
	esi_24 = esi << 0x04;
	dl_25 = ~0x11;
	esi_27 = esi << 0x04 << cl;
	bh_28 = bh_20 - 0x38;
	SCZO_29 = cond(bh_20 - 0x38);
	eax_31 = SEQ(eax_24_8, al);
	edx_35 = SEQ(edx_16_16, dh_34, ~0x11);
	ebx_24_8_37 = SEQ(ebx_16_16, bh_20 - 0x38);
	fn0040DC18();
	esp_41 = fp;
	eax_49 = SEQ(eax_24_8, al_38);
}

// 0040D552: define fn0040D552
// Called from:
//      fn0040D85D
//      fn0040DA87
define fn0040D552
{
	esp = fp;
	Top = 0;
	bl = 0xB4;
	edx <<= 0x14;
	v8 = (al & 0x01 << 0x1F) != 0x00;
	al = __ror<byte,byte>(al, 0x1F);
	C = bl != 0x00;
	bl = -bl;
	--bl;
	dh = (bool) C + ((byte) al + dh);
	SCZO = cond(dh);
	edi >>= cl;
	SCZ = cond(edi);
	ebx = eax;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			if (Test(NE,Z))
			{
				fn0040D579();
				return;
			}
			else
			{
				ebp = *esp;
				++esp;
				bl = 77;
				esp -= 4;
				*esp = ecx;
				esi->b001B = ~0x29;
				fn0040D579();
				return;
			}
		}
	}
	dl = ~dl;
	bh = (bool) C + (bh + ah);
	bl >>= cl;
	bx <<= cl;
	SCZO = cond(bx);
	fn0040D66E();
}

// 0040D579: define fn0040D579
// Called from:
//      fn0040D552
//      fn0040D894
define fn0040D579
{
	esp = fp;
	Top = 0;
	--dh;
	eax = eax ^ ~0x0137;
	bl &= dl;
	dl >>= cl;
	ebx <<= 0x0C;
	SCZO = cond(ebx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			ecx = 2161549511;
			v20 = (edi->t8006CFC1.u0 & 0x01 << 0x08 - cl) != 0x00;
			edi->t8006CFC1.u0 = (int8) __rcl<byte,byte>(edi->t8006CFC1.u0, cl, C);
			C = v20;
			fn32DB_80DF();
			return;
		}
	}
	v21 = (ebx & 0x01 << 0x20 - 0x14) != 0x00;
	ebx = __rcl<word32,byte>(ebx, 0x14, C);
	dh &= bh;
	--di;
	esi <<= 11;
	v26 = (dx & 0x01 << cl) != 0x00;
	dx = __ror<word16,byte>(dx, cl);
	++dh;
	SZO = cond(dh);
	esi >>= cl;
	SCZ = cond(esi);
	if (Test(EQ,Z))
		fn0040DE37();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040DE37();
		else
		{
			dl = dl - ((esp->a0056))[esi].b0000 - C;
			SCZO = cond(dl);
			fn0040D930();
		}
	}
}

// 0040D59C: define fn0040D59C
// Called from:
//      fn0040DA87
define fn0040D59C
{
	esp = fp;
	Top = 0;
	dl = (bool) C + ((byte) dl.u1 + 151);
	v7 = (edi & 0x01 << 0x06) != 0x00;
	edi = __ror<word32,byte>(edi, 0x06);
	dl -= 223;
	SCZO = cond(dl);
	bl = bl - 0x32 - C;
	v11 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	bh += 0x13;
	v14 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	dh &= ch;
	C.u0 = false;
	si = (word16) ((bool) C.u0 + (si + di));
	esi <<= 0x0F;
	v22 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	dl >>= cl;
	SCZO = cond(dl);
	v23 = (edi & 0x01 << 0x1B) != 0x00;
	edi = __ror<word32,byte>(edi, 0x1B);
	C = v23;
	if (Test(EQ,Z))
		fn0040DAA8();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040DAA8();
		else
		{
			cl.u0 = 0x51;
			SCZO = cond(*esi - *edi);
			++esi;
			&edi.u4->u0 = (word32) edi + 4;
			dl.u0 = 0x4B;
			&edx.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			fn0040D5D2();
		}
	}
}

// 0040D5D2: define fn0040D5D2
// Called from:
//      fn0040D59C
//      fn0040DE60
//      fn0040DEBA
//      fn0040DF15
//      fn0040DF2F
define fn0040D5D2
{
	esp = fp;
	Top = 0;
	v6 = (esi & 0x01 << 0x14) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x14, C);
	C = v6;
	v10 = (bx & 0x01 << 0x10 - cl) != 0x00;
	bx = __rcl<word16,byte>(bx, cl, C);
	bl |= ah;
	v16 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	C = v16;
	bh = bh + bl + C;
	eax = *edx;
	edx -= edi;
	SCZO = cond(edx);
	--bl;
	dh = dh - ah - C;
	v23 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	ebx >>= 0x08;
	SCZO = cond(ebx);
	dh -= al;
	dh &= 0x59;
	v26 = (bx & 0x01 << 0x10 - cl) != 0x00;
	bx = __rol<word16,byte>(bx, cl);
	C = v26;
	bh = bh - ~0x70 - C;
	v28 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	v30 = (si & 0x01 << cl) != 0x00;
	si = __ror<word16,byte>(si, cl);
	C = edi != 0x00;
	edi = -edi;
	SZO = cond(edi);
	eax();
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			v32 = *edx - bh - C;
			*edx = v32;
			eax &= 2331513702;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			v33 = (eax & 0x01 << cl) != 0x00;
			eax = __rcr<word32,byte>(eax, cl, C);
			ax -= si;
			SCZO = cond(ax);
			v35 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			--al;
			ah >>= cl;
			al = (byte) al + 0x00D8;
			al |= 0x2D;
			edi >>= cl;
			SCZO = cond(edi);
			ah = ah + bh + C;
			SCZO = cond(ah);
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					ebp.u0 = 3570900968;
					SCZO = cond(eax.u5->dwCBD2F5E3 - eax);
					fn0040DBF3();
					return;
				}
			}
			ah &= 0x5A;
			C.u0 = false;
			ebx = ebx - eax - C;
			SCZO = cond(ebx);
			while (true)
			{
				bl |= ah;
				edi <<= 0x01;
				SCZO = cond(edi);
				&esi->u4->u0 = dh;
				ah = (byte) ah.u0 + 1;
				SZO = cond(ah);
				ebx >>= cl;
				ah -= 33;
				eax >>= 0x05;
				SCZ = cond(eax);
				al = cl;
				v38 = (bh & 0x01 << cl) != 0x00;
				bh = __rcr<byte,byte>(bh, cl, C);
				ah = bl;
				v39 = (bl & 0x01 << cl) != 0x00;
				bl = __ror<byte,byte>(bl, cl);
				&esi.u4->u0 = (word32) esi + 1;
				eax >>= cl;
				v40 = (eax & 0x01 << cl) != 0x00;
				eax = __ror<word32,byte>(eax, cl);
				C = v40;
				bx = si;
				eax = eax - esi - C;
				SCZO = cond(eax);
				bh = bh - 0x5B - C;
				SCZO = cond(bh);
				if (Test(EQ,Z))
					break;
				eax = eax;
				if (Test(NE,Z))
					break;
				v41 = edi;
				edi = eax;
				eax = v41;
				bh = bh - dh - C;
				SCZO = cond(bh);
				v42 = esi;
				esi = eax;
				eax = v42;
				v44 = Mem0[edi + 458941568:word32] + ecx + C;
				edi.u5->dw1B5AE480 = v44;
				SCZO = cond(v44);
			}
			ah = (bool) C.u0 + ((byte) ah + ch);
			eax = edx;
			al.u0 = 0x61;
			bh -= ~0x58;
			SCZO = cond(bh);
			bl = bl + cl + C;
			--ecx;
			ax = ax ^ si;
			v46 = (ah & 0x01 << cl) != 0x00;
			ah = __ror<byte,byte>(ah, cl);
			C = v46;
			v47 = (bx & 0x01 << cl) != 0x00;
			bx = __rcr<word16,byte>(bx, cl, C);
			al |= cl;
			SZ = cond(al);
			O = false;
			C.u0 = false;
			fn0040D6EE();
			return;
		}
	}
	edi = esi;
	ecx |= edi;
	ebx = ebx ^ edx;
	esi <<= 11;
	v75 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	bl.u0 = 0xA2;
	v76 = (esi & 0x01 << 0x20 - 0x13) != 0x00;
	esi = __rol<word32,byte>(esi, 0x13);
	v77 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	edx |= ecx;
	SZ = cond(edx);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			&edi.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			&esi.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			&ebp.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			esp = (union Eq_3 *) ((char *) esp + 4);
			&ebx.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			&edx.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			&ecx.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			&eax.u4->u0 = esp->u4;
			esp = (union Eq_3 *) ((char *) esp + 4);
			ds = dx;
			fn0040DC02();
			return;
		}
	}
	dh <<= cl;
	SCZO = cond(dh);
	--esi;
	SZO = cond(esi);
	fn0040DA43();
}

// 0040D62F: define fn0040D62F
// Called from:
//      fn0040D801
//      fn0040DEBA
define fn0040D62F
{
	esp = fp;
	Top = 0;
	fn0040D869();
}

// 0040D647: define fn0040D647
// Called from:
//      fn0040D894
//      fn0040D8C1
define fn0040D647
{
	esp = fp;
	Top = 0;
	di <<= cl;
	eax += edx;
	dx = -dx;
	v14 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	C = v14;
	v16 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	esi <<= 0x01;
	SCZO = cond(esi);
	v17 = (di & 0x01 << 0x10 - cl) != 0x00;
	di = __rcl<word16,byte>(di, cl, C);
	esi <<= cl;
	esi -= ecx;
	SCZO = cond(esi);
	di = (word16) di + 1;
	dl = (byte) dl + 0x007F;
	--dh;
	eax += ebx;
	SCZO = cond(eax);
	dh = dh - 0x2E - C;
	SCZO = cond(dh);
	edx = edx - esi - C;
	v21 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	dh = (byte) dh + ch;
	dl |= 0x2E;
	C = si != 0x00;
	si = -si;
	SZO = cond(si);
	if (Test(EQ,Z))
		fn0040D579();
	else
		fn0040D7CD();
}

// 0040D66E: define fn0040D66E
// Called from:
//      fn0040D552
//      fn0040D894
define fn0040D66E
{
	esp = fp;
	Top = 0;
	al = al ^ 0x44;
	v9 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rol<word32,byte>(ebx, cl);
	bh += 0x3F;
	SCZO = cond(bh);
	bl = (bool) C + (bl + ~0x4C);
	SCZO = cond(bl);
	fn0040D8EA();
}

// 0040D6D0: define fn0040D6D0
// Called from:
//      fn0040D894
//      fn0040DF3E
define fn0040D6D0
{
	esp = fp;
	Top = 0;
	ah -= cl;
	SCZO = cond(ah);
	ax = (word16) (C.u5 + (ax + di) /16 2090873980);
	SCZO = cond(ax);
	v12 = (edi & 0x01 << 0x20 - 22) != 0x00;
	edi = __rcl<word32,byte>(edi, 22, C);
	C = v12;
	al = (byte) (C.u5 + (al + dl) /8 2090873980);
	--ah;
	v17 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	bh -= 0xC1;
	++ebx;
	esi <<= 0x0E;
	SCZO = cond(esi);
	fn0040D92F();
}

// 0040D6EE: define fn0040D6EE
// Called from:
//      fn0040D5D2
//      fn0040D739
//      fn0040DA43
define fn0040D6EE
{
	esp = fp;
	Top = 0;
	esi = *esp;
	++esp;
	v7 = (ecx & 0x01 << 0x20 - 0x07) != 0x00;
	ecx = __rol<word32,byte>(ecx, 0x07);
	edi = eax;
	eax <<= 0x1B;
	ch -= al;
	bl += 0x19;
	bx <<= cl;
	SCZO = cond(bx);
	edx >>= cl;
	SCZ = cond(edx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			ax &= 0x6342;
			SZ = cond(ax);
			O = false;
			C.u0 = false;
			ah = ah - 0x57 - C;
			di = cx;
			al -= dl;
			eax >>= 0x15;
			SCZO = cond(eax);
			edi = edi + edx + C;
			edi <<= 0x09;
			SCZO = cond(edi);
			v27 = (eax & 0x01 << cl) != 0x00;
			eax = __rcr<word32,byte>(eax, cl, C);
			C = v27;
			ebx = ecx;
			if (Test(EQ,Z))
			{
				fn0040D513();
				return;
			}
			else
			{
				eax = eax;
				if (Test(NE,Z))
				{
					fn0040D513();
					return;
				}
				else
				{
					bh = 252;
					do
						;
					while (Test(LE,SZO));
					fn0040D739();
					return;
				}
			}
		}
	}
	dh <<= cl;
	bl -= cl;
	v54 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	dx |= ax;
	edi >>= cl;
	v55 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	esi -= ~0x035E;
	SCZO = cond(esi);
	ch = (bool) C.u0 + (ch + al);
	SCZO = cond(ch);
	v56 = (edi & 0x01 << 0x20 - 0x0D) != 0x00;
	edi = __rcl<word32,byte>(edi, 0x0D, C);
	ch = 0x18;
	dh = ah;
	ecx <<= 0x03;
	SCZO = cond(ecx);
	fn0040D7DC();
}

// 0040D739: define fn0040D739
// Called from:
//      fn0040D6EE
//      fn0040DE0E
define fn0040D739
{
	esp = fp;
	Top = 0;
	fn0040D6EE();
}

// 0040D755: define fn0040D755
// Called from:
//      fn0040DA64
//      fn0040DA87
define fn0040D755
{
	word16 cx;
	word32 ebx;
	byte dl;
	cl = (byte) cx;
	byte dh;
	Top_3 = 0;
	v5_5 = (ebx & 0x00020000) != 0x00;
	ebx_6 = __ror<word32,byte>(ebx, 0x11);
	bh_17 = SLICE(ebx_6, byte, 8);
	dl_10 = dl - cl - v5_5;
	dx_12 = SEQ(dh, dl_10);
	cx_14 = cx;
	dx_15 = dx_12 + cx_14;
	dh_16 = SLICE(dx_15, byte, 8);
	dl_22 = (byte) dx_15;
	dh_18 = dh_16 & bh_17;
	SCZO_20 = cond(dh_18 + 0x7E);
	C_21 = SLICE(SCZO_20, bool, 1);
	dx_23 = SEQ(dh_18 + 0x7E, dl_22);
	O_24 = SLICE(SCZO_20, bool, 4);
	S_25 = (bool) SCZO_20;
	Z_26 = SLICE(SCZO_20, bool, 2);
	fn0040D762();
}

// 0040D762: define fn0040D762
// Called from:
//      fn0040D92F
//      fn0040DEBA
define fn0040D762
{
	esp = fp;
	Top = 0;
	++dh;
	dh &= 0x0A;
	SZ = cond(dh);
	O = false;
	C = false;
	fn0040D869();
}

// 0040D7CD: define fn0040D7CD
// Called from:
//      fn0040D85D
//      fn0040D894
define fn0040D7CD
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040D552();
	else
	{
		--esp;
		SZO = cond(esp);
		v9 = edx;
		edx = eax;
		eax = v9;
		--ecx;
		if (Test(EQ,Z) && ecx != 0x00)
			fn0040D801();
		else
		{
			esp = esp->ptr0000;
			esp = (struct Eq_4391 *) ((char *) &esp->ptr0000 + 4);
			SCZO = cond(al - 0xC5);
			fn0040D7DC();
		}
	}
}

// 0040D7DC: define fn0040D7DC
// Called from:
//      fn0040D85D
//      fn0040DEBA
define fn0040D7DC
{
	esp = fp;
	Top = 0;
	--bl;
	edi <<= cl;
	ah <<= cl;
	di >>= cl;
	++bh;
	bl -= ah;
	SCZO = cond(bl);
	v12 = (edx & 0x01 << 0x20 - 0x1E) != 0x00;
	edx = __rcl<word32,byte>(edx, 0x1E, C);
	C = v12;
	fn0040D92F();
}

// 0040D7F8: define fn0040D7F8
// Called from:
//      fn0040D85D
//      fn0040DE2C
define fn0040D7F8
{
	esp = fp;
	Top = 0;
	fn0040DE2C();
}

// 0040D801: define fn0040D801
// Called from:
//      fn0040D869
//      fn0040DE0E
define fn0040D801
{
	esp = fp;
	Top = 0;
	bh = bh ^ 118;
	dl = 0x30;
	eax |= eax;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
		fn0040D62F();
	else
	{
		bh = bh ^ ~0x22;
		bl = ah;
		edx >>= 0x05;
		SCZO = cond(edx);
		bx = bx - cx - C;
		SCZO = cond(bx);
		bh = ~bh;
		edi >>= cl;
		SCZ = cond(edi);
		fn0040DFCA();
	}
}

// 0040D847: define fn0040D847
// Called from:
//      fn0040D85D
//      fn0040DEBA
define fn0040D847
{
	esp = fp;
	Top = 0;
	v4 = (edi & 0x01 << 0x19) != 0x00;
	edi = __rcr<word32,byte>(edi, 0x19, C);
	C = v4;
	bh = (byte) (C.u5 + (bh + cl) /8 2090873980);
	dh >>= cl;
	SCZ = cond(dh);
	bl = (byte) (C.u5 + (bl + ah) /8 2090873980);
	SCZO = cond(bl);
	v14 = (esi & 0x01 << 0x14) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x14, C);
	dl <<= cl;
	SCZO = cond(dl);
	++bx;
	SZO = cond(bx);
	if (Test(EQ,Z))
		fn0040DEAF();
	else
		fn0040D85D();
}

// 0040D85D: define fn0040D85D
// Called from:
//      fn0040D847
//      fn0040D869
define fn0040D85D
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040DEAF();
	else
	{
		ax = __aad(ax);
		SCZO = cond((edx - 24)[edx].dw0000 - esp);
		ebx = ebx - ecx - C;
		dh &= 0x89;
		C.u0 = false;
		ax = (uint16) ((bool) C.u0 + (ax + bx));
		C = bh != 0x00;
		bh = -bh;
		v21 = (di & 0x01 << cl) != 0x00;
		di = __rcr<word16,byte>(di, cl, C);
		al |= ~0x06;
		C.u0 = false;
		v23 = (bh & 0x01 << cl) != 0x00;
		bh = __rcr<byte,byte>(bh, cl, C);
		C = v23;
		bl.u0 = 0x5A;
		ah = (bool) C.u0 + ((byte) ah + 121);
		SCZO = cond(ah);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				*edi = eax;
				&edi.u4->u0 = (word32) edi + 4;
			}
		}
		al = (byte) al + ch;
		SCZO = cond(al);
		while (true)
		{
			al.u0 = esi->u0;
			bl &= 0xA5;
			C.u0 = false;
			bx = bx - ax - C;
			dx = dx ^ bx;
			dl >>= cl;
			dx >>= cl;
			SCZO = cond(dx);
			bh = bh + ah + C;
			SCZO = cond(bh);
			v31 = (edx & 0x01 << 0x20 - 0x02) != 0x00;
			edx = __rcl<word32,byte>(edx, 0x02, C);
			ebx <<= 0x05;
			SCZO = cond(ebx);
			v32 = (dh & 0x01 << cl) != 0x00;
			dh = __rcr<byte,byte>(dh, cl, C);
			C = v32;
			v33 = (al & 0x01 << 0x08 - 0x12) != 0x00;
			al = __rol<byte,byte>(al, 0x12);
			v34 = (bh & 0x01 << cl) != 0x00;
			bh = __ror<byte,byte>(bh, cl);
			v35 = (dl & 0x01 << 0x08 - cl) != 0x00;
			dl = __rol<byte,byte>(dl, cl);
			dl -= cl;
			v36 = (dl & 0x01 << cl) != 0x00;
			dl = __ror<byte,byte>(dl, cl);
			bl = ~bl;
			bh >>= cl;
			ebx = eax;
			dl = ah;
			al = ~al;
			dl -= ~0x12;
			SCZO = cond(dl);
			v37 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rcl<byte,byte>(bh, cl, C);
			dh = dh ^ 0x04;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
			if (Test(EQ,Z))
				break;
			eax = eax;
			if (Test(NE,Z))
				break;
			--ecx;
			if (ecx != 0x00)
			{
				Z = __arpl(*edx, bx, &*edx);
				fn0040DFE1();
				return;
			}
			v38 = (*edx & 0x01 << 0x20 - 0xC5) != 0x00;
			*edx = __rol<word32,byte>(*edx, 0xC5);
			C = v38;
		}
		edi = -edi;
		dl = dl ^ 171;
		edx <<= 0x0D;
		dh = dh ^ ch;
		C.u0 = false;
		bh = ~bh;
		v39 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rcl<byte,byte>(bl, cl, C);
		C = v39;
		v40 = (edi & 0x01 << cl) != 0x00;
		edi = __rcr<word32,byte>(edi, cl, C);
		bl = (byte) bl.u0 + 0x00EA;
		SCZO = cond(bl);
		edx = edx + edi + C;
		dx = ax;
		v41 = (dl & 0x01 << cl) != 0x00;
		dl = __ror<byte,byte>(dl, cl);
		al -= 0x6A;
		SCZO = cond(al);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				v42 = ecx;
				ecx = eax;
				eax = v42;
				SCZO = ah;
				__halt();
			}
		}
		dh = dh - 0x39 - C;
		dl.u0 = 211;
		v43 = (edi & 0x01 << 0x20 - 0x0E) != 0x00;
		edi = __rol<word32,byte>(edi, 0x0E);
		edx -= eax;
		bh >>= cl;
		di <<= cl;
		SCZO = cond(di);
		if (Test(EQ,Z))
			fn0040D552();
		else
		{
			eax = eax;
			if (Test(NE,Z))
				fn0040D552();
			else if (Test(NS,S))
				fn0040D7CD();
			else
			{
				esp -= (word32 *) 4;
				*esp = ebp;
				v46 = (cl & 0x01 << 0x08 - 223) != 0x00;
				cl = __rol<byte,byte>(cl, 223);
				C = v46;
				fn0040D847();
			}
		}
	}
}

// 0040D869: define fn0040D869
// Called from:
//      fn0040D62F
//      fn0040D762
//      fn0040D92F
//      fn0040DA87
//      fn0040DF3E
//      fn0040E014
define fn0040D869
{
	esp = fp;
	Top = 0;
	al >>= cl;
	SCZO = cond(al);
	fn0040D85D();
}

// 0040D894: define fn0040D894
// Called from:
//      fn0040D59C
define fn0040D894
{
	esp = fp;
	Top = 0;
	dl <<= cl;
	v7 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	v10 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	bl &= dh;
	v15 = (di & 0x01 << 0x10 - cl) != 0x00;
	di = __rol<word16,byte>(di, cl);
	bx |= di;
	C.u0 = false;
	eax = eax->ptr0000;
	v19 = (ebx & 0x01 << 11) != 0x00;
	ebx = __rcr<word32,byte>(ebx, 11, C);
	esi &= eax;
	--ebx;
	v23 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	si <<= cl;
	SCZO = cond(si);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			al = *(byte *) 575099292;
			__cli();
			v27 = (esi & 0x01 << cl) != 0x00;
			esi = __ror<word32,byte>(esi, cl);
			v28 = (esi & 0x01 << 0x01) != 0x00;
			esi = __ror<word32,byte>(esi, 0x01);
			bl -= ~0x01;
			&ebx.u4->u0 = (word32) ah;
			si -= bx;
			SCZO = cond(si);
			v30 = (esi & 0x01 << cl) != 0x00;
			esi = __rcr<word32,byte>(esi, cl, C);
			esi >>= 0x1C;
			eax >>= 0x10;
			edi &= esi;
			di &= ax;
			di <<= cl;
			SCZO = cond(di);
			fn0040D647();
			return;
		}
	}
	v33 = (esi & 0x01 << 0x09) != 0x00;
	esi = __ror<word32,byte>(esi, 0x09);
	v34 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	v35 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	v36 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	eax += ecx / 4;
	edi <<= 0x04;
	SCZO = cond(edi);
	edi = edi + esi + C;
	SCZO = cond(edi);
	--di;
	&edi.u4->u0 = (word32) edi + 1;
	v38 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	bl &= dl;
	C.u0 = false;
	edx = edx - ebx - C;
	edx |= ecx;
	SZ = cond(edx);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D538();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D538();
		else
		{
			v40 = ebp;
			ebp = eax;
			eax = v40;
			dh.u0 = 0x36;
			if (Test(GT,SZO))
				fn0040D66E();
			else
			{
				esp = ebp;
				ebp = esp->ptr0000;
				esp = (struct Eq_4961 *) ((char *) &esp->ptr0000 + 4);
				fn0040D6D0();
			}
		}
	}
}

// 0040D8C1: define fn0040D8C1
// Called from:
//      fn0040E014
define fn0040D8C1
{
	esp = fp;
	Top = 0;
	bh &= dl;
	v10 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	v12 = (esi & 0x01 << 0x01) != 0x00;
	esi = __ror<word32,byte>(esi, 0x01);
	bl -= ~0x01;
	ebx = (word32) ah;
	si -= bx;
	SCZO = cond(si);
	v19 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	esi >>= 0x1C;
	eax >>= 0x10;
	edi &= esi;
	di &= ax;
	di <<= cl;
	SCZO = cond(di);
	fn0040D647();
}

// 0040D8EA: define fn0040D8EA
// Called from:
//      fn0040D552
//      fn0040D66E
define fn0040D8EA
{
	esp = fp;
	Top = 0;
	dl &= bh;
	C.u0 = false;
	v12 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	C = v12;
	v14 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	di -= si;
	v18 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	--edi;
	dl = dl ^ cl;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D92F();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D92F();
		else
		{
			++edx;
			SZO = cond(edx);
			v25 = ecx;
			ecx = eax;
			eax = v25;
		}
	}
}

// 0040D92F: define fn0040D92F
// Called from:
//      fn0040D7DC
//      fn0040D869
define fn0040D92F
{
	esp = fp;
	Top = 0;
	esp -= 4;
	*esp = esi;
	fn0040D930();
}

// 0040D930: define fn0040D930
// Called from:
//      fn0040D85D
//      fn0040D92F
define fn0040D930
{
	esp = fp;
	Top = 0;
	eax <<= cl;
	bh <<= cl;
	eax >>= 0x08;
	eax = -eax;
	v10 = (al & 0x01 << cl) != 0x00;
	al = __ror<byte,byte>(al, cl);
	ebx |= edx;
	bl = bl ^ 0x1E;
	SZ = cond(bl);
	O = false;
	C = false;
	fn0040DB41();
}

// 0040D982: define fn0040D982
// Called from:
//      fn0040DE0E
//      fn0040DE0F
define fn0040D982
{
	esp = fp;
	Top = 0;
	dh = (byte) (C.u5 + (dh + bl) /8 2090873980);
	ax -= cx;
	SCZO = cond(ax);
	v12 = (edx & 0x01 << 0x0C) != 0x00;
	edx = __rcr<word32,byte>(edx, 0x0C, C);
	esp -= 4;
	*esp = 0x05566305;
	v14 = (ebx & 0x01 << 0x13) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x13);
	cx |= ax;
	dl = dl ^ 188;
	v19 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rol<word32,byte>(ebx, cl);
	v20 = (ax & 0x01 << cl) != 0x00;
	ax = __ror<word16,byte>(ax, cl);
	ebx <<= 0x12;
	v22 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rol<byte,byte>(ch, cl);
	C = v22;
	&ebx.u4->u0 = (word32) ebx + 1;
	SZO = cond(ebx);
	bh |= 0x10;
	edi >>= 0x01;
	SCZO = cond(edi);
	v27 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	C = v27;
	ecx = *esp;
	++esp;
	bh = (int8) (C.u5 + (bh + bl) /8 2090873980);
	SCZO = cond(bh);
	bh = (int8) (C.u5 + (bh + al) /8 2090873980);
	edi <<= cl;
	SCZO = cond(edi);
	v31 = (dx & 0x01 << cl) != 0x00;
	dx = __ror<word16,byte>(dx, cl);
	C = v31;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			eax += ~0x002C0F96;
			SCZO = cond(eax);
			fn0040DFCA();
			return;
		}
	}
	--di;
	--dl;
	v35 = (edx & 0x01 << 0x20 - 0x0D) != 0x00;
	edx = __rol<word32,byte>(edx, 0x0D);
	bh >>= cl;
	v37 = (esi & 0x01 << 0x20 - 0x0E) != 0x00;
	esi = __rol<word32,byte>(esi, 0x0E);
	esi <<= 0x0E;
	ecx = ecx ^ 0x05566345;
	SZ = cond(ecx);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D739();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D739();
		else
		{
			ss = esi.u5->ptrFFFFFFCF;
			eax = *(word32 *) 1323750100;
			fn0040DA43();
		}
	}
}

// 0040DA43: define fn0040DA43
// Called from:
//      fn0040D5D2
//      fn0040DE0E
define fn0040DA43
{
	esp = fp;
	Top = 0;
	++bh;
	bh = 0x05;
	ch >>= cl;
	SCZO = cond(ch);
	ecx = *esp;
	++esp;
	esi = 0x00779054;
	if (Test(EQ,Z))
		fn0040D6EE();
	else
		fn0040DA55();
}

// 0040DA55: define fn0040DA55
// Called from:
//      fn0040D5D2
//      fn0040DA43
define fn0040DA55
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040D6EE();
	else
	{
		v9 = (edx & 0x01 << cl) != 0x00;
		edx = __ror<word32,byte>(edx, cl);
		v11 = esp;
		esp -= 4;
		*esp = eax;
		esp -= 4;
		*esp = ecx;
		esp -= 4;
		*esp = edx;
		esp -= 4;
		*esp = ebx;
		esp -= 4;
		*esp = v11;
		esp -= 4;
		*esp = ebp;
		esp -= 4;
		*esp = esi;
		esp -= 4;
		*esp = edi;
		ss = *esp;
		&esp.u4->u0 = (word32) esp + 2;
		esi = *esp;
		&esp.u4->u0 = (word32) esp + 4;
		dl = dl ^ dl;
		SZ = cond(dl);
		O = false;
		C = false;
		fn0040DA64();
	}
}

// 0040DA64: define fn0040DA64
// Called from:
//      fn0040D92F
//      fn0040DEBA
define fn0040DA64
{
	esp = fp;
	Top = 0;
}

// 0040DA87: define fn0040DA87
// Called from:
//      Win32CrtStartup
define fn0040DA87
{
fn0040DA87_entry:
	esp = fp
	Top = 0
	al = (byte) (C.u5 + (al + ah) /8 2090873980)
	ch = -ch
	eax = eax & esi
	ch = ch << cl
	ax = ax >> cl
	ecx = ecx | ebx
	SZ = cond(ecx)
	O = false
	C.u0 = false
	v19 = (ecx & 0x01 << cl) != 0x00
	ecx = __rcr<word32,byte>(ecx, cl, C)
	C = v19
	branch Test(EQ,Z) l0040DD29
	goto l0040DA9C
l0040DA87:
l0040DA9C:
	eax = eax
	branch Test(NE,Z) l0040DD29
l0040DAA4:
l0040DD29:
	dx = dx ^ bx
	esp = esp - 4
	esp->u4 = (Eq_3 (*)[]) ecx
	ebx = ebx >> 11
	al = al + bl
	v24 = (ebx & 0x01 << 0x07) != 0x00
	ebx = __ror<word32,byte>(ebx, 0x07)
	ebx = ebx >> 0x08
	al = al - ~0x25
	esi = esi ^ edx
	dh = dh >> cl
	ch = 0x4A
	dl = dl & bl
	SZ = cond(dl)
	O = false
	C.u0 = false
	branch Test(EQ,Z) l0040DE0A
l0040DD49:
	eax = eax
	branch Test(NE,Z) l0040DE0A
l0040DD51:
	branch Test(PE,P) l0040DCF0
	goto l0040DD53
l0040DD51_thunk_fn0040D869:
	fn0040D869()
	return
l0040DD53:
	v30 = esi.u5->bFFFFFFD7 - bh
	esi.u5->bFFFFFFD7 = v30
	SCZO = cond(v30)
	branch Test(NE,Z) l0040DCD8
l0040DE0A:
	v6242 = (esi & 0x01 << 0x15) != 0x00
	esi = __ror<word32,byte>(esi, 0x15)
	C = v6242
	v6243 = (edi & 0x01 << 0x20 - cl) != 0x00
	edi = __rcl<word32,byte>(edi, cl, C)
	C = v6243
	fn0040DE0F()
	return
l0040DE0D_thunk_fn0040DE0F:
fn0040DA87_exit:
}

// 0040DAA8: define fn0040DAA8
// Called from:
//      fn0040D59C
define fn0040DAA8
{
	word32 ecx;
	word32 eax;
	byte bl;
	al = (byte) eax;
	bool C;
	byte dh;
	cl = (byte) ecx;
	word24 ebx_24_8;
	word32 esi;
	word32 edi;
	byte dl;
	ecx_24_8 = SLICE(ecx, word24, 8);
	ch_46 = (byte) ecx_24_8;
	Top_3 = 0;
	bl_7 = bl + al + (byte) C;
	eax_9 = eax;
	dh_12 = -dh;
	dh_15 = __ror<byte,byte>(dh_12, cl);
	ebx_17 = SEQ(ebx_24_8, bl_7);
	esi_20 = esi - 0x01;
	ebx_23 = __ror<word32,byte>(ebx_17 + 0x01, cl);
	if (esi == 0x01 || esi != 0x01)
	{
		edi_30 = edi & esi - 0x01;
		ebx_33 = ebx_23 << cl;
		edi_34 = edi_30 >> cl;
		di_45 = (word16) edi_34;
		edi_16_16_59 = SLICE(edi_34, word16, 16);
		dl_37 = dl & 111;
		ecx_40 = ecx;
		ebx_41 = ebx_33 - ecx_40;
		eax_43 = eax_9 + 0x80;
		ebx_44 = ebx_41 - (esi - 0x01);
		cx_47 = SEQ(ch_46, cl);
		bh_50 = SLICE(ebx_44, byte, 8);
		ebx_16_16_56 = SLICE(ebx_44, word16, 16);
		bl_57 = (byte) ebx_44;
		di_48 = di_45 - cx_47;
		SCZO_49 = cond(di_48);
		O_62 = SLICE(SCZO_49, bool, 4);
		bh_51 = bh_50 >> cl;
		SCZ_52 = cond(bh_51);
		C_54 = SLICE(SCZ_52, bool, 1);
		ebx_58 = SEQ(ebx_16_16_56, bh_51, bl_57);
		edi_60 = SEQ(edi_16_16_59, di_48);
		S_63 = (bool) SCZ_52;
		Z_65 = SLICE(SCZ_52, bool, 2);
		fn0040D894();
	}
	else if (OVERFLOW<word32>(esi - 0x01))
		__syscall<byte>(0x04);
}

// 0040DAC6: define fn0040DAC6
// Called from:
//      fn0040DE60
define fn0040DAC6
{
	esp = fp;
	Top = 0;
	bh = bh - bl - C;
	SCZO = cond(bh);
	v9 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	bh >>= cl;
	ebx >>= cl;
	v12 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	bh = ch;
	bh = bh ^ 0x61;
	edx += ecx;
	SCZO = cond(edx);
	bl = C.u5 + ((byte) bl + dh) /8 2090873980;
	SCZO = cond(bl);
	if (Test(EQ,Z))
		fn0040DF15();
	else
	{
		eax = eax;
		if (Test(EQ,Z))
			return;
		fn0040DF15();
	}
}

// 0040DB41: define fn0040DB41
// Called from:
//      fn0040D92F
//      fn0040D930
define fn0040DB41
{
	esp = fp;
	Top = 0;
	v6 = (edx & 0x01 << 0x20 - 0x1E) != 0x00;
	edx = __rol<word32,byte>(edx, 0x1E);
	ch &= 0xC2;
	v13 = (dl & 0x01 << cl) != 0x00;
	dl = __ror<byte,byte>(dl, cl);
	v15 = (cx & 0x01 << 0x10 - cl) != 0x00;
	cx = __rol<word16,byte>(cx, cl);
	esi += ~0x035E;
	bh &= ~0x13;
	--dx;
	edi |= ecx;
	bh |= ch;
	dh <<= cl;
	SCZO = cond(dh);
	v25 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	C = v25;
	fn0040DA64();
}

// 0040DBF3: define fn0040DBF3
// Called from:
//      fn0040D92F
//      fn0040DEBA
define fn0040DBF3
{
	esp = fp;
	Top = 0;
	dl <<= cl;
	bl >>= cl;
	SCZ = cond(bl);
	bl = bl - bh - C;
	al += 0x30;
	edi = -edi;
	al &= 0x7B;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	eax = *esp;
	++esp;
	fn0040DC02();
}

// 0040DC02: define fn0040DC02
// Called from:
//      fn0040D5D2
//      fn0040DBF3
define fn0040DC02
{
	word16 di;
	byte cl;
	bool C;
	byte dh;
	word32 esi;
	word16 edi_16_16;
	Top_3 = 0;
	di_8 = __rcl<word16,byte>(di, cl, C);
	dx_11 = SEQ(dh, 0x3A);
	dx_13 = __rol<word16,byte>(dx_11, cl);
	edi_16 = SEQ(edi_16_16, di_8);
	esi_17 = esi + edi_16;
	SCZO_18 = cond(esi_17);
	C_19 = SLICE(SCZO_18, bool, 1);
	O_20 = SLICE(SCZO_18, bool, 4);
	S_21 = (bool) SCZO_18;
	Z_22 = SLICE(SCZO_18, bool, 2);
	fn0040E014();
}

// 0040DC18: define fn0040DC18
// Called from:
//      fn0040D513
//      fn0040D894
define fn0040DC18
{
	ptr32 fp;
	word32 eax;
	al_21 = (byte) eax;
	byte bl;
	byte cl;
	word32 edx;
	word24 ebx_24_8;
	bh_18 = (byte) ebx_24_8;
	ebx_16_16_28 = SLICE(ebx_24_8, word16, 8);
	Top_3 = 0;
	esp_7 = fp - 4;
	bl_11 = bl >> cl;
	ebx_14 = SEQ(ebx_24_8, bl_11);
	edx_15 = edx ^ ebx_14;
	dl_16 = (byte) edx_15;
	edx_24_8_30 = SLICE(edx_15, word24, 8);
	bx_19 = SEQ(bh_18, bl_11);
	bx_20 = bx_19 << cl;
	bh_24 = SLICE(bx_20, byte, 8);
	dl_22 = dl_16 - 0xAC - al_21;
	SCZO_23 = cond(dl_22);
	C_27 = SLICE(SCZO_23, bool, 1);
	O_32 = SLICE(SCZO_23, bool, 4);
	S_33 = (bool) SCZO_23;
	Z_34 = SLICE(SCZO_23, bool, 2);
	ebx_29 = SEQ(ebx_16_16_28, bh_24, bh_24);
	edx_31 = SEQ(edx_24_8_30, dl_22);
	fn0040DE60();
}

// 0040DCBE: define fn0040DCBE
// Called from:
//      fn0040D869
//      fn0040DFCA
define fn0040DCBE
{
	esp = fp;
	Top = 0;
	dh >>= cl;
	bx &= ax;
	dl |= dh;
	bl >>= cl;
	bx <<= cl;
	di = di ^ si;
	dl -= bl;
	edx <<= 0x1E;
	dl += ~0x24;
	--bx;
	eax += eax->dw003C / 64;
	SCZO = cond(eax);
	fn0040D92F();
}

// 0040DE0E: define fn0040DE0E
// Called from:
//      fn0040DEBA
define fn0040DE0E
{
	esp = fp;
	Top = 0;
	al = ebx[(uint32) al];
	fn0040DE0F();
}

// 0040DE0F: define fn0040DE0F
// Called from:
//      fn0040DA87
//      fn0040DE0E
define fn0040DE0F
{
	esp = fp;
	Top = 0;
	ebx <<= cl;
	bl = -bl;
	v10 = esp;
	esp -= 4;
	esp->ptr0000 = v10;
	ch <<= cl;
	SCZO = cond(ch);
	ax = (word16) (C.u5 + (ax + di) /16 2090873980);
	edx <<= 0x15;
	ecx = ecx ^ edx;
	C.u0 = false;
	v18 = (ecx & 0x01 << 0x18) != 0x00;
	ecx = __rcr<word32,byte>(ecx, 0x18, C);
	bh += dh;
	SCZO = cond(bh);
	v21 = (ecx & 0x01 << 0x20 - 0x0C) != 0x00;
	ecx = __rol<word32,byte>(ecx, 0x0C);
	C = v21;
	if (Test(EQ,Z))
		fn0040D982();
	else
		fn0040DE2C();
}

// 0040DE2C: define fn0040DE2C
// Called from:
//      fn0040D7F8
//      fn0040DE0E
//      fn0040DE0F
define fn0040DE2C
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040D982();
	else
	{
		dh = (bool) C + (dh + (edi)[eax].b0000);
		SCZO = cond(dh);
		fn0040DE37();
	}
}

// 0040DE37: define fn0040DE37
// Called from:
//      fn0040D579
//      fn0040D85D
//      fn0040DE2C
define fn0040DE37
{
	esp = fp;
	Top = 0;
	v5 = (esi & 0x01 << 0x20 - 0x0D) != 0x00;
	esi = __rcl<word32,byte>(esi, 0x0D, C);
	bx >>= cl;
	dl >>= cl;
	SCZ = cond(dl);
	v13 = (edx & 0x01 << 0x20 - 0x13) != 0x00;
	edx = __rcl<word32,byte>(edx, 0x13, C);
	C = v13;
	eax = ~eax;
	v16 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	v17 = (bx & 0x01 << cl) != 0x00;
	bx = __ror<word16,byte>(bx, cl);
	bh = -bh;
	edi <<= cl;
	--ebx;
	v23 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	C = v23;
	v24 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	C = v24;
	++dl;
	SZO = cond(dl);
	fn0040D7F8();
}

// 0040DE60: define fn0040DE60
// Called from:
//      fn0040DEBA
define fn0040DE60
{
	esp = fp;
	Top = 0;
	edx -= eax;
	edi |= ebx;
	C.u0 = false;
	edi = (int32) ((bool) C.u0 + (edi + ebx));
	SCZO = cond(edi);
	edx = *esp;
	++esp;
	edi = edi - edx - C;
	di >>= cl;
	bh >>= cl;
	SCZO = cond(bh);
	edi >>= 0x1A;
	SCZ = cond(edi);
	v16 = (esi & 0x01 << 0x20 - 0x19) != 0x00;
	esi = __rol<word32,byte>(esi, 0x19);
	v18 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	C = v18;
	if (Test(EQ,Z))
		fn0040DAC6();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040DAC6();
		else
		{
			do
				;
			while (Test(NS,S));
		}
	}
}

// 0040DEAF: define fn0040DEAF
// Called from:
//      fn0040D847
//      fn0040D869
define fn0040DEAF
{
	esp = fp;
	Top = 0;
	v6 = (cl & 0x01 << cl) != 0x00;
	cl = __ror<byte,byte>(cl, cl);
	C = v6;
	ecx = (word32) ((bool) C + (ecx + ebx));
	SCZO = cond(ecx);
	bl = 0x5B;
	fn0040DEBA();
	fn0040DEBA();
}

// 0040DEBA: define fn0040DEBA
// Called from:
//      fn0040DEAF
define fn0040DEBA
{
	esp = fp;
	Top = 0;
	v5 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	dl &= 122;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			v15 = (bool) C.u0 + (edx->b40481B67 + ch);
			edx->b40481B67 = v15;
			SCZO = cond(v15);
			fn0040D5D2();
			return;
		}
	}
	dx -= cx;
	cx &= ax;
	bx >>= cl;
	esi <<= 0x1B;
	v31 = (cx & 0x01 << cl) != 0x00;
	cx = __ror<word16,byte>(cx, cl);
	v32 = (bx & 0x01 << cl) != 0x00;
	bx = __ror<word16,byte>(bx, cl);
	C = v32;
	cl = (byte) cl + 1;
	SZO = cond(cl);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			ebp &= ebp->dw0073;
			v34.u2 = esi->u2;
			edi->u2 = (ui32) v34;
			esi = (union Eq_7 *) ((char *) esi + 4);
			edi = (union Eq_7 *) ((char *) edi + 4);
			edi->u0 = (int8) al;
			edi = (union Eq_7 *) ((char *) edi + 1);
			edi >>= 0x04;
			edi >>= 0x06;
			dh = ~dh;
			dh = (byte) dh + 122;
			bh += 141;
			SCZO = cond(bh);
			edx >>= cl;
			SCZ = cond(edx);
			di = (word16) ((bool) C.u0 + (di + ax));
			SCZO = cond(di);
			dh = al;
			fn0040D5D2();
			return;
		}
	}
	dh = (bool) C.u0 + ((byte) dh + ch);
	esi <<= cl;
	ecx = *esp;
	++esp;
	v93 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	dh = (byte) dh + 0x009E;
	bl = -bl;
	bl -= ch;
	eax &= edx;
	SZ = cond(eax);
	O = false;
	v94 = (eax & 0x01 << 0x1A) != 0x00;
	eax = __ror<word32,byte>(eax, 0x1A);
	C = v94;
	fn0040D5D2();
}

// 0040DF15: define fn0040DF15
// Called from:
//      fn0040D5D2
//      fn0040DAC6
//      fn0040DE60
define fn0040DF15
{
	esp = fp;
	Top = 0;
	++bl;
	bl = 88;
	bh = bh - al - C;
	SCZO = cond(bh);
	v12 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	bl |= 188;
	di <<= cl;
	SCZO = cond(di);
	v17 = (edi & 0x01 << 0x20 - 0x1C) != 0x00;
	edi = __rcl<word32,byte>(edi, 0x1C, C);
	ebx <<= 0x04;
	SCZO = cond(ebx);
	if (Test(EQ,Z))
		fn0040D5D2();
	else
		fn0040DF2F();
}

// 0040DF2F: define fn0040DF2F
// Called from:
//      fn0040D5D2
//      fn0040DE60
define fn0040DF2F
{
	esp = fp;
	Top = 0;
	fn0040D5D2();
}

// 0040DF3E: define fn0040DF3E
// Called from:
//      fn0040D62F
//      fn0040DEBA
define fn0040DF3E
{
	esp = fp;
	Top = 0;
	fn0040D869();
}

// 0040DFCA: define fn0040DFCA
// Called from:
//      fn0040D801
//      fn0040DE0E
define fn0040DFCA
{
	esp = fp;
	Top = 0;
	edx -= ebx;
	SCZO = cond(edx);
	dl = (bool) C + (dl + ah);
	SCZO = cond(dl);
	dl = ~dl;
	bl = bl - 0x5E - C;
	++si;
	dh = -dh;
	eax = ecx;
	bh = bh ^ cl;
	SZ = cond(bh);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040DCBE();
	else
		fn0040DFE1();
}

// 0040DFE1: define fn0040DFE1
// Called from:
//      fn0040D869
//      fn0040DFCA
define fn0040DFE1
{
	esp = fp;
	Top = null;
	eax = eax;
	if (Test(NE,Z))
		fn0040DCBE();
	else
	{
		C.u0 = false;
		v9 = mm2;
		v11.u0 = edx->t60B71FEC.u0;
		mm2 = __psubus<uint16[4]>(v9, v11);
		edx = edx - eax - C;
		edi >>= cl;
		bx = -bx;
		dh <<= cl;
		edi <<= 0x04;
		SCZO = cond(edi);
		si >>= cl;
		SCZ = cond(si);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				--ecx;
				if (Test(NE,Z) && ecx != 0x00)
				{
					fn0040D92F();
					return;
				}
				else
				{
					__sti();
					fn0040D92F();
					return;
				}
			}
		}
		edx <<= 0x01;
		bl = 229;
		bh += dl;
		dl = (byte) dl + 76;
		esi >>= 0x19;
		SCZ = cond(esi);
		dl = cl;
		edx = eax + 80;
		v25 = (si & 0x01 << cl) != 0x00;
		si = __rcr<word16,byte>(si, cl, C);
		C = v25;
		bl = (bool) C.u0 + (bl + dh);
		SCZO = cond(bl);
		v26 = (esi & 0x01 << cl) != 0x00;
		esi = __ror<word32,byte>(esi, cl);
		v28 = (ebx & 0x01 << 0x20 - 0x14) != 0x00;
		ebx = __rol<word32,byte>(ebx, 0x14);
		C = v28;
		v29 = (bh & 0x01 << cl) != 0x00;
		bh = __rcr<byte,byte>(bh, cl, C);
		C = v29;
		Top->r0003 = Top->r0000;
		edx();
		do
			;
		while (ecx == 0x00);
		edx->dwFED366DC = 1181154578;
		bh = ~bh;
		v30 = edx->t0000;
		esp -= 4;
		esp->u0 = (word32) v30;
		esi >>= 0x04;
		SCZ = cond(esi);
		edi = edi - edx - C;
		SCZO = cond(edi);
		bl = bl - al - C;
		SCZO = cond(bl);
		bh = (bool) C.u0 + ((byte) bh + 0x00C9);
		v32 = (esi & 0x01 << 0x11) != 0x00;
		esi = __ror<word32,byte>(esi, 0x11);
		C = v32;
		bl = (bool) C.u0 + ((byte) cl + bl);
		ebx >>= 0x10;
		dh = -dh;
		bh &= al;
		++dh;
		di &= si;
		C.u0 = false;
		++bx;
		SZO = cond(bx);
		esp -= 4;
		esp->u0 = (word32) ecx;
		fn0040D59C();
	}
}

// 0040E014: define fn0040E014
// Called from:
//      fn0040D92F
//      fn0040DEBA
define fn0040E014
{
	esp = fp;
	Top = null;
	fn0040D869();
}

