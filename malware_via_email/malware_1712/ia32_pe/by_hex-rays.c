/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD __far nullsub_1(); // weak
// unsigned int __userpurge start@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebx>, unsigned int a5@<edi>, int a6@<esi>, __m64 a7@<mm2>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
_DWORD nullsub_2(); // weak


//----- (0040C61A) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
unsigned int __userpurge start@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebx>, unsigned int a5@<edi>, int a6@<esi>, __m64 a7@<mm2>, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  int v65; // esi
  int v66; // edi
  int v67; // edx
  int v69; // edx
  unsigned int v70; // edi
  unsigned int v71; // ebx
  BOOL v72; // ett
  bool v73; // cf
  unsigned int v74; // ebx
  char v77; // cc
  bool v79; // pf
  _BYTE *v80; // edi
  unsigned int v81; // edx
  unsigned int v83; // eax
  unsigned int v97; // edi
  unsigned int v105; // edx
  bool v107; // cf
  char v109; // tt
  bool v110; // cc
  unsigned int v113; // esi
  char v114; // cf
  bool v116; // cf
  unsigned int v117; // esi
  unsigned int v118; // ett
  unsigned int v122; // edi
  int v124; // eax
  int v126; // eax
  int v127; // esi
  unsigned int v129; // edi
  BOOL v130; // ett
  unsigned int v133; // edi

  v126 = a1 + 1;
  SBYTE1(a4) >>= a3;
  BYTE1(a3) ^= a3;
  BYTE1(v126) <<= a3;
  LOBYTE(a4) = BYTE1(v126);
  LOBYTE(a3) = ((_BYTE)a3 << a3) & 0x88;
  BYTE1(a3) ^= 0x1Eu;
  v73 = __CFADD__((_BYTE)a3, 87);
  LOBYTE(a3) = a3 + 87;
  v127 = a3 + v73 + a6;
  _ECX = 2031180310;
  v127 >>= 22;
  v73 = __CFSHR__(v127, 22);
  _ESI = v127 >> 22;
  _EAX = __ROR4__(v126 - 1, 22) - (v73 + 2031180310);
  _EDI = a5 >> 22;
  __asm { rcl     ah, cl }
  _EAX = _EAX - 2031180310;
  _EDX = a4 ^ (a2 << 22);
  LOBYTE(_EDX) = BYTE1(_EDX) + __CFSHR__(BYTE1(a4), 22) + _EDX;
  do
  {
    LOBYTE(_EAX) = _EAX & 0x17;
    LOBYTE(_EDX) = (_BYTE)_EDX << _ECX;
    ++_EDI;
    v73 = __CFADD__(_ECX, 1237581516);
    _ECX += 1237581516;
    BYTE1(_EDX) -= v73 - 121;
    _EDX -= _ECX;
  }
  while ( _ECX != 1644854838 );
  __asm { rcr     esi, cl }
  v73 = __CFADD__((_BYTE)_EDX, 54);
  LOBYTE(_EDX) = _EDX + 54;
  BYTE1(a4) = _EDX + v73 + 126;
  v73 = a4 < _ESI;
  _EBX = a4 - _ESI;
  __asm { rcr     bh, cl }
  v118 = v73 + _EBX;
  v116 = _ESI < v118;
  v117 = _ESI - v118;
  do
  {
    ++BYTE1(_EBX);
    __asm
    {
      rcr     edi, cl
      rcr     dl, cl
    }
    if ( __SETP__(BYTE1(_EBX), 0) || !__SETP__(BYTE1(_EBX), 0) )
    {
      BYTE1(_EBX) ^= 0x7Du;
      __asm { rcr     dh, cl }
      BYTE1(_EDX) -= 14;
      v73 = __CFADD__(__CFSHR__(_EDI, 54), (_BYTE)_EBX);
      LOBYTE(_EBX) = __CFSHR__(_EDI, 54) + _EBX;
      v73 |= __CFADD__((_BYTE)_EBX, 20);
      LOBYTE(_EBX) = _EBX + 20;
      LOBYTE(_EDX) = -22;
      v97 = _EDX + v73 + (_EDI >> 22);
      LOBYTE(_EDX) = -2;
      _EDX = _EDX + 1;
      __asm { rcr     dl, cl }
      LOBYTE(_EDX) = _EDX + 1;
      v73 = v97 < _EBX;
      v70 = v97 - _EBX;
      LOBYTE(_EBX) = _EBX - (v73 - 75);
      BYTE1(_EDX) ^= _EDX;
      v73 = __CFSHR__(_EDX, 54);
      _EDX = _EDX >> 22;
      v72 = v73;
      v73 = __CFADD__(v73, _EBX);
      v71 = v72 + _EBX;
      v73 |= __CFADD__(_EAX, v71);
      v71 += _EAX;
      BYTE1(v71) -= v73 + 52;
      __asm { rcl     dh, cl }
      LOBYTE(v71) = v71 - 1;
      v73 = __CFSHR__(v71, 54);
      v74 = v71 >> 22;
      if ( !v73 && v74 != 0 && (v73 || v74 == 0) )
        JUMPOUT(0x40C052);
      LOBYTE(_EDX) = (char)(BYTE1(_EAX) & _EDX) >> 7;
      ++BYTE1(_EDX);
      v113 = _EAX;
      goto LABEL_29;
    }
  }
  while ( !v116 && BYTE1(_EBX) != 0 );
  v113 = v117 + 4;
  v70 = _EDI + 4;
  __asm { rep dec esp }
  if ( _SF ^ _OF | _ZF )
  {
    v122 = v70 + 1;
    LOBYTE(_EDX) = _EDX - 1 - (_CF + 119);
    _CL = 0;
    v124 = _EDX ^ (v113 | _EAX);
    __asm { rcr     bh, cl }
    v133 = v122 - 1920975104;
    BYTE1(_EDX) += 105;
    _EAX = v133 & (v124 + 1);
    _SF = (char)(_EAX + _EDX) < 0;
    LOBYTE(_EDX) = _EAX + _EDX;
    __asm { rcr     ah, cl }
    if ( !_SF && _SF )
    {
      _CL = _EBX;
      _EDX = _EDX << _EBX;
      __asm { rcr     dh, cl }
      JUMPOUT(0x40C3DC);
    }
    __asm { rcr     al, cl }
    v105 = _EBX + _EDX;
    BYTE1(v105) = (_EBX ^ BYTE1(v105)) & 0x15;
    _ECX = -1920975105;
    v107 = __CFSHL__(v113, -1);
    _ESI = v113 << 31;
    v130 = v107;
    v73 = __CFADD__(v107, v133);
    v129 = v130 + v133;
    v73 |= __CFADD__(_EAX, v129);
    _EDI = (_BYTE *)(_EAX + v129);
    --BYTE1(v105);
    __asm { rcr     eax, cl }
    LOBYTE(_ECX) = -1 - (v73 + 62);
    _EDX = v105 - _EBX;
    BYTE1(_EDX) <<= _ECX;
    LOBYTE(_EDX) = (char)_EDX >> _ECX;
    if ( ((_EDX & 0x80u) != 0) == _OF && ((_EDX & 0x80u) != 0) != _OF )
    {
      if ( (_BYTE)_EDX )
        JUMPOUT(0x40C792);
      JUMPOUT(0x40C743);
    }
    v73 = __CFADD__(BYTE1(_EAX), -85);
    _AH = BYTE1(_EAX) - 85;
    __asm { rcl     ah, cl }
    v109 = v73 + 6;
    v73 = (unsigned __int8)(v73 + 6) > 0x10u;
    BYTE1(_ECX) = 16 - v109;
    LOBYTE(_EAX) = 102 - v73;
    _ECX = _ECX - (_DWORD)&_EDI[(unsigned __int8)v73 > 0x66u];
    v110 = __CFADD__(BYTE1(_ECX), -116) || BYTE1(_ECX) == 116;
    BYTE1(_ECX) -= 116;
    if ( !v110 && v110 )
      JUMPOUT(0x40C484);
    goto LABEL_10;
  }
LABEL_29:
  __asm
  {
    rcl     dl, cl
    rcl     edx, cl
  }
  v73 = __CFADD__(v70 < 0x620A7E36, (_BYTE)_EDX);
  LOBYTE(_EDX) = (v70 < 0x620A7E36) + _EDX;
  v114 = v73 | __CFADD__((_BYTE)_EDX, -125);
  LOBYTE(_EDX) = _EDX - 125;
  if ( !__SETP__(_EDX, 0) && __SETP__(_EDX, 0) )
    JUMPOUT(0x40C4CA);
  v69 = _EDX - (v114 + 1644854838);
  _EBX = (int *)(_EAX + v113);
  BYTE1(v69) += 126;
  LOBYTE(v69) = 0;
  LOWORD(_EBX) = (unsigned __int8)(_EAX + v113 + 127);
  _EDI = v69 - (_DWORD)_EBX;
  BYTE1(v69) ^= 0x36u;
  _EDX = v69 - 1;
  BYTE1(_EBX) = 1;
  LOBYTE(_EDX) = __ROL1__(_EDX, 54);
  __asm
  {
    rcr     dl, cl
    rcr     edi, cl
  }
  LOBYTE(_EDX) = _EDX - 1;
  _ESI = (int)(v113 + 1) >> 22;
  v77 = (_ESI < 0) ^ _OF;
  do
  {
    LOBYTE(_EBX) = BYTE1(_EDX);
    if ( v77 || !v77 )
    {
      LOBYTE(_EBX) = -110;
      __asm { rcl     esi, cl }
      v65 = (int)_EBX;
      v66 = __ROL4__(__ROL4__(_EDI, 54), 54);
      v67 = v66;
      __asm { rcl     ebx, cl }
      LOBYTE(v67) = (char)v66 >> 7;
      LOBYTE(_EBX) = _EBX - 1;
      SBYTE1(_EBX) >>= 7;
      _EDX = (_EAX ^ v67) << 22;
      if ( !__CFSHL__(v66, 54) && _EDX != 0 && (__CFSHL__(v66, 54) || _EDX == 0) )
      {
        __asm { rcl     byte ptr [edx], 1 }
        if ( !__CFSHL__(v66, 54) )
        {
          BYTE1(_EBX) &= _EAX;
          _CL = _m_pextrw(a7, 4);
          __asm { rcl     ebx, cl }
          JUMPOUT(0x40C81D);
        }
        JUMPOUT(0x40C1CC);
      }
      BYTE1(_EDX) = 6;
      _EDX = _EDX ^ 0x620A7E36;
      LOBYTE(_EBX) = __CFSHL__(-9, 54) + 126;
      BYTE1(_EBX) = _EDX;
      _ESI = _EDX + (v65 >> 22) - 1;
      LOBYTE(_EDX) = _EDX ^ 0x80;
      __asm { rcl     dh, cl }
      ++_ESI;
      BYTE1(_EDX) = __ROL1__(BYTE1(_EDX), 54);
      __asm
      {
        rcl     esi, cl
        rcr     edx, cl
      }
      BYTE1(_EBX) = __ROR1__(SBYTE1(_EBX) >> 7, 54) - _EBX;
      LOBYTE(_EBX) = __ROL1__(_EBX, 54) - BYTE1(_EDX);
      _BX = __ROR4__(_EBX, 54);
      __asm { rcl     bh, cl }
      JUMPOUT(0x40C7F6);
    }
    v79 = __SETP__(*_EBX & 0xFFFFFFC8, 0);
    v77 = *_EBX < 0;
    *_EBX &= 0xFFFFFFC8;
    *_EDI++ = _EAX;
  }
  while ( !v79 );
LABEL_10:
  LOBYTE(_EAX) = __ROL1__(_EAX, _ECX);
  v80 = &_EDI[_EAX];
  LOBYTE(_ECX) = _ECX - 1;
  v81 = _EDX << _ECX;
  __asm { rcl     ecx, cl }
  v83 = v81 & (_EAX >> _ECX);
  _EDI = (_DWORD)v80 << _ECX << _ECX;
  BYTE1(_ECX) = __ROR1__(BYTE1(_ECX), _ECX);
  v73 = __CFSHR__(v81, _ECX);
  _EDX = v81 >> _ECX;
  LOBYTE(_ECX) = BYTE1(_EDX) + v73 + _ECX;
  __asm
  {
    rcl     edi, cl
    rcr     edx, cl
    rcr     ecx, cl
  }
  if ( !__OFSUB__(_ESI, _EDI) && __OFSUB__(_ESI, _EDI) )
    JUMPOUT(0x40C37B);
  BYTE1(v83) |= _ECX;
  return v83 >> __ROL4__(_ECX, _ECX);
}
// 40C92E: positive sp value 8 has been found
// 40BFE2: control flows out of bounds to 40BFE4
// 40C023: control flows out of bounds to 40C029
// 40C051: control flows out of bounds to 40C052
// 40C222: control flows out of bounds to 40C224
// 40C286: control flows out of bounds to 40C288
// 40C37A: control flows out of bounds to 40C37B
// 40C3DA: control flows out of bounds to 40C3DC
// 40C47E: control flows out of bounds to 40C484
// 40C4C8: control flows out of bounds to 40C4CA
// 40C6F5: control flows out of bounds to 40C6F6
// 40C73B: control flows out of bounds to 40C73D
// 40C742: control flows out of bounds to 40C743
// 40C790: control flows out of bounds to 40C792
// 40C962: control flows out of bounds to 40C964
// 40C109: control flows out of bounds to 40C10A
// 40C654: control flows out of bounds to 40C14F
// 40BF62: control flows out of bounds to 40C6A8
// 40BFFE: control flows out of bounds to 40C92F
// 40C066: control flows out of bounds to 40C2FF
// 40C56D: control flows out of bounds to 40C81D
// 40C5F0: control flows out of bounds to 40C202
// 40C70F: control flows out of bounds to 40C8C9
// 40C144: control flows out of bounds to 40C241
// 40C240: control flows out of bounds to 40C1CC
// 40C273: control flows out of bounds to 40C7F6
// 40C43F: control flows out of bounds to 40C44C
// 40C5CE: control flows out of bounds to 40C5C5
// 40C6A3: control flows out of bounds to 40C6E4
// 40C449: bad sp value at call
// 40C60F: bad sp value at call
// 40C023: conditional instruction was optimized away because of 'bl.1>=0'
// 40C2F3: conditional instruction was optimized away because of 'ecx.4==620A7E36'
// 40C079: variable '_OF' is possibly undefined
// 40C61A: too many input arguments, some ignored
// 40C3DD: using guessed type _DWORD __far nullsub_1();
// 40C685: using guessed type _DWORD nullsub_2();

// nfuncs=3 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
