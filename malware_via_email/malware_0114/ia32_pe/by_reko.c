// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 ebx_1235 = AddAce(null, 0x00, 0x00, null, 0x00) + 0x24 + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00);
	Eq_3 ebp_1015 = null;
	if (AreAnyAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_1235 = ebx_1235 - 0x22;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x065C);
	struct Eq_680 * esp_999 = fp - 1660;
	struct Eq_683 * eax_1003 = null;
	do
	{
		if (ebp_1015 == ebx_1235)
			ebp_1015 = null;
		eax_1003[0x004014A0] = (struct Eq_683) (eax_1003[0x004014A0] ^ ebp_1015[0x00404000]);
		eax_1003 = eax_1003 + 0x01;
		ebp_1015 = (Eq_3) (ebp_1015 + 0x01);
	} while (eax_1003 < (struct Eq_683 *) 5152);
	int32 ebx_1031 = 0x00401220;
	uint32 esi_1032 = 0x00;
	struct Eq_709 * edx_1035 = &globals->t402780;
	uint32 dwLoc0660_1038 = 0x00;
	do
	{
		Eq_715 eax_1046 = edx_1035->t0004;
		cui16 * ecx_1052 = (char *) &edx_1035->t0004 + 0x04;
		if (eax_1046 - 0x08 >> 0x01 > 0x00)
		{
			uint32 dwLoc0664_1203 = eax_1046 - 0x08 >> 0x01;
			do
			{
				if ((*ecx_1052 & 0xF000) == 0x3000)
				{
					struct Eq_737 * eax_1227 = ((word32) *ecx_1052 & 0x0FFF) + edx_1035->dw0000;
					eax_1227->dw401220 = eax_1227->dw401220 + 0xF0401220;
				}
				uint32 v18_1219 = dwLoc0664_1203 - 0x01;
				ecx_1052 = ecx_1052 + 0x01;
				dwLoc0664_1203 = v18_1219;
			} while (v18_1219 != 0x00);
			esi_1032 = dwLoc0660_1038;
		}
		esi_1032 = (word32) edx_1035->t0004 + esi_1032;
		dwLoc0660_1038 = esi_1032;
		edx_1035 = edx_1035 + Mem1022[edx_1035 + 0x04:word32];
	} while (esi_1032 < 228);
	struct Eq_764 * esi_1068 = &globals->t401F7C;
	esi_1095 = esi_1068;
	ebx_1097 = ebx_1031;
	esp_1099 = esp_999;
	if (globals->dw401F8C != 0x00)
	{
		do
		{
			struct Eq_764 * esi_1095;
			int32 ebx_1097;
			struct Eq_680 * esp_1099;
			esp_1099 = esp_1099 - 0x04 + 0x14;
			esp_1099->dw0000 = esi_1095->dw000C + ebx_1097;
			Eq_814 eax_1105 = LoadLibraryA(esp_1099->dw0000);
			esp_1099[0x06] = (struct Eq_680) eax_1105;
			Eq_814 edx_1106 = eax_1105;
			if (eax_1105 != null)
			{
				ptr32 ebp_1128 = esi_1095->dw0000;
				if (ebp_1128 == 0x00)
					ebp_1128 = esi_1095->dw0010;
				Eq_844 eax_1133 = ebp_1128 + ebx_1097;
				struct Eq_847 * ebp_1135 = ebp_1128 + ebx_1097;
				word32 * ebx_1137 = (word32) esp_1099[0x05].dw0000 + esi_1095->dw0010;
				if (eax_1133 != 0x00)
				{
					while (true)
					{
						Eq_872 eax_1171;
						if (eax_1133 < 0x00)
						{
							LPCSTR * esp_1186 = esp_1099 - 0x04;
							*esp_1186 = (LPCSTR *) (word32) ebp_1135->w0000;
							*(esp_1186 - 0x04) = (HMODULE *) edx_1106;
							eax_1171 = GetProcAddress(*(esp_1186 - 0x04), *esp_1186);
						}
						else
						{
							LPCSTR * esp_1196 = esp_1099 - 0x04;
							*esp_1196 = (word32) esp_1099[0x05].dw0000 + ((word32) eax_1133 + 0x02);
							*(esp_1196 - 0x04) = (HMODULE *) edx_1106;
							eax_1171 = GetProcAddress(*(esp_1196 - 0x04), *esp_1196);
						}
						*ebx_1137 = (word32) eax_1171;
						ebp_1135 = ebp_1135 + 0x01;
						esp_1099 = esp_1099 - 0x08;
						eax_1133.u1 = ebp_1135->w0000;
						ebx_1137 = ebx_1137 + 0x01;
						if (eax_1133 == 0x00)
							break;
						edx_1106 = (Eq_814) esp_1099[0x06];
					}
					esi_1095 = (struct Eq_764 *) esp_1099[0x07];
				}
				ebx_1097 = esp_1099->dw0000;
			}
			esi_1095 = esi_1095 + 0x01;
			esp_1099[0x07] = (struct Eq_680) esi_1095;
		} while (esi_1095->dw0010 != 0x00);
	}
	ptr32 esp_1075;
	byte SCZO_1076;
	word32 ebx_1077;
	word32 ebp_1078;
	word32 esi_1079;
	word32 edi_1080;
	byte SZO_1081;
	byte C_1082;
	word32 edx_1083;
	word32 eax_1084;
	byte Z_1085;
	byte cl_1086;
	word32 ecx_1087;
	word16 ax_1088;
	byte S_1089;
	globals->t401C70();
	*(esp_1075 - 0x04) = 0x00;
	ExitProcess(*(esp_1075 - 0x04));
}

