/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_401010@<eax>(unsigned int@<ebx>, unsigned int);
void __stdcall sub_401241(int, unsigned int, unsigned int);
// int __userpurge sub_401268@<eax>(int@<ebx>, unsigned int, _BYTE *);
// int __usercall sub_4012D3@<eax>(_DWORD *@<edi>);
// _BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>);
int sub_40138A();
char *__stdcall sub_401390(char *, int, int);
int __stdcall sub_4014E5(char *, int (__stdcall **)(char *));
// int __usercall sub_40159A@<eax>(_BYTE *@<eax>, int@<ecx>);
// int __userpurge sub_4015E7@<eax>(_DWORD *a1@<esi>, int a2);
// _BYTE *__usercall sub_401639@<eax>(int@<eax>);
// int __userpurge sub_40166B@<eax>(char **@<eax>, int@<edi>, int, int, int);
// _BYTE *__usercall sub_4016C9@<eax>(int@<eax>);
// int __userpurge sub_4016F7@<eax>(int@<eax>, int);
// _BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_401767@<eax>(int@<eax>);
// BOOL __usercall sub_401799@<eax>(int@<edx>, _DWORD *@<esi>);
// _BYTE *__usercall sub_40186E@<eax>(int@<eax>);
// unsigned int __userpurge sub_4018A0@<eax>(int@<edi>, _DWORD *);
// _DWORD *__userpurge sub_401A43@<eax>(int@<eax>, int@<esi>, int);
// _BYTE *__userpurge sub_401A68@<eax>(_BYTE *result@<eax>, _BYTE *@<ecx>, int);
int __stdcall start(HINSTANCE hInstance, int, int); // idb
HANDLE __stdcall GetKJgkdghkdfhd();
HANDLE __stdcall GetLKfsdgdkhd();
HANDLE __stdcall GetKkgdstkdgkd();
HANDLE __stdcall GetKfldskgdhkd();
HANDLE __stdcall GetKlfgdkgldshd();

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *BitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// extern BOOL (__stdcall *LineTo)(HDC hdc, int x, int y);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern BOOL (__stdcall *Polyline)(HDC hdc, const POINT *apt, int cpt);
// extern HPEN (__stdcall *CreatePen)(int iStyle, int cWidth, COLORREF color);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern BOOL (__stdcall *MoveToEx)(HDC hdc, int x, int y, LPPOINT lppt);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *TerminateThread)(HANDLE hThread, DWORD dwExitCode);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern BOOL (__stdcall *GetExitCodeThread)(HANDLE hThread, LPDWORD lpExitCode);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *InvalidateRect)(HWND hWnd, const RECT *lpRect, BOOL bErase);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *ModifyMenuA)(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// extern int (__stdcall *SetScrollInfo)(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// extern BOOL (__stdcall *SetWindowTextA)(HWND hWnd, LPCSTR lpString);
// extern HWND (__stdcall *GetActiveWindow)();
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern HACCEL (__stdcall *LoadAcceleratorsA)(HINSTANCE hInstance, LPCSTR lpTableName);
// extern int (__stdcall *TranslateAcceleratorA)(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *GetScrollInfo)(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern HWND (__stdcall *GetForegroundWindow)();
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern HWND (__stdcall *FindWindowA)(LPCSTR lpClassName, LPCSTR lpWindowName);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
const CHAR byte_4030FD[3] = { '\0', '\0', '\0' }; // idb


//----- (00401010) --------------------------------------------------------
int __userpurge sub_401010@<eax>(unsigned int a1@<ebx>, unsigned int a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // edi
  HDC DC; // esi
  HWND ForegroundWindow; // eax
  HDC v6; // edi
  HPEN Pen; // eax
  HDC CompatibleDC; // esi
  HANDLE EventA; // eax
  HWND WindowA; // esi
  char v11; // cl
  unsigned int *v12; // eax
  bool v14; // [esp+13h] [ebp-2Dh]
  unsigned int v15; // [esp+14h] [ebp-2Ch]
  unsigned int v16; // [esp+1Ch] [ebp-24h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  HWND hWnd; // [esp+2Ch] [ebp-14h]
  struct tagRECT Rect; // [esp+30h] [ebp-10h] BYREF

  v2 = 0;
  v3 = 0x40 / a2;
  if ( 0x40 / a2 )
  {
    v14 = 0;
    v17 = a1 % 0x41;
    do
    {
      v15 = v2;
      v16 = v2;
      if ( a1 % 0xF <= 0x14 )
      {
        v15 = v2 + 8 * v14 + 13;
      }
      else
      {
        DC = GetDC(0);
        TextOutA(DC, 10, 10, "Trololo", 32);
        if ( !DC || MoveToEx(DC, 10, 10, 0) )
          LineTo((HDC)((char *)DC + 10), 150, 200);
        else
          Polyline(DC, (const POINT *)0x324345, 20);
        ReleaseDC(0, DC);
      }
      if ( v17 <= 0x56 )
      {
        if ( v15 > v3 - 1 )
          v15 %= v3;
      }
      else
      {
        ForegroundWindow = GetForegroundWindow();
        hWnd = ForegroundWindow;
        if ( ForegroundWindow )
        {
          v6 = GetDC(ForegroundWindow);
          if ( v6 )
          {
            Pen = CreatePen(2, 3, 0x101010u);
            if ( Pen )
            {
              SelectObject(v6, Pen);
            }
            else
            {
              CompatibleDC = CreateCompatibleDC(v6);
              SelectObject(CompatibleDC, 0);
              BitBlt(v6, 0, 0, 50, 50, CompatibleDC, 0, 0, 0xCC0020u);
              DeleteDC(CompatibleDC);
            }
            ReleaseDC(hWnd, v6);
          }
          v3 = 0x40 / a2;
        }
      }
      if ( (a1 & 7) <= 0xA )
      {
        v14 = !v14;
      }
      else
      {
        EventA = CreateEventA(0, 1, 1, "TestEvent");
        SetEvent(EventA);
      }
      if ( v17 <= 0x50 )
      {
        if ( a2 == 1 )
        {
          v11 = *(_BYTE *)(a1 + v2);
          goto LABEL_32;
        }
        v16 = *(_DWORD *)(a1 + 4 * v2);
      }
      else
      {
        WindowA = FindWindowA(0, "MyWindow");
        if ( WindowA && GetWindowRect(WindowA, &Rect) )
          SetWindowPos(WindowA, 0, Rect.left, Rect.top, Rect.right + 50, Rect.bottom, 4u);
      }
      if ( a2 != 1 )
      {
        v12 = (unsigned int *)(a1 + 4 * v15);
        *(_DWORD *)(a1 + 4 * v2) = *v12;
        *v12 = v16;
        goto LABEL_34;
      }
      v11 = v16;
LABEL_32:
      *(_BYTE *)(a1 + v2) = *(_BYTE *)(a1 + v15);
      *(_BYTE *)(a1 + v15) = v11;
LABEL_34:
      v2 += 2;
    }
    while ( v2 < v3 );
  }
  return 64;
}

//----- (00401241) --------------------------------------------------------
void __stdcall sub_401241(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int i; // esi

  for ( i = 0; i < a2; i += sub_401010(i + a1, a3) )
    ;
}

//----- (00401268) --------------------------------------------------------
int __userpurge sub_401268@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // edi
  int v6; // [esp+10h] [ebp+8h]

  sub_401241(a1, a2, 1u);
  sub_401241(a1, a2, 4u);
  v3 = a1 + *(_DWORD *)(a1 + 60);
  sub_401A68(a3, (_BYTE *)a1, *(_DWORD *)(v3 + 84));
  v6 = 0;
  result = *(unsigned __int16 *)(v3 + 20) + v3 + 24;
  if ( *(_WORD *)(v3 + 6) )
  {
    v5 = (_DWORD *)(*(unsigned __int16 *)(v3 + 20) + v3 + 44);
    do
    {
      sub_401A68(&a3[*(v5 - 2)], (_BYTE *)(a1 + *v5), *(v5 - 1));
      result = *(unsigned __int16 *)(v3 + 6);
      v5 += 10;
      ++v6;
    }
    while ( v6 < result );
  }
  return result;
}

//----- (004012D3) --------------------------------------------------------
int __usercall sub_4012D3@<eax>(_DWORD *a1@<edi>)
{
  char *v1; // ecx
  char *v2; // eax
  int i; // esi
  char *v5; // [esp+0h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  _WORD *v8; // [esp+10h] [ebp-4h]

  v1 = (char *)a1 + a1[15];
  v2 = (char *)a1 + *((_DWORD *)v1 + 40);
  v5 = (char *)a1 - *((_DWORD *)v1 + 13);
  if ( v2 == (char *)a1 )
    return 0;
  v7 = 0;
  for ( i = *((_DWORD *)v2 + 1); i; i = *((_DWORD *)v2 + 1) )
  {
    if ( (unsigned int)(i - 8) >> 1 )
    {
      v8 = v2 + 8;
      v6 = (unsigned int)(i - 8) >> 1;
      do
      {
        if ( (*v8 & 0xF000) == 12288 )
          *(_DWORD *)((char *)a1 + (*v8 & 0xFFF) + *(_DWORD *)v2) += v5;
        ++v8;
        --v6;
      }
      while ( v6 );
    }
    v7 += i;
    v2 = (char *)a1 + v7 + *((_DWORD *)v1 + 40);
  }
  return 1;
}

//----- (00401367) --------------------------------------------------------
_BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>)
{
  _BYTE *v1; // ecx
  char v2; // dl

  if ( *result == 1 )
  {
    v1 = ++result;
    if ( *result )
    {
      do
      {
        if ( *v1 )
          v2 = *v1 + 30;
        else
          v2 = 0;
        *v1++ = v2;
      }
      while ( *v1 );
    }
  }
  return result;
}

//----- (0040138A) --------------------------------------------------------
int sub_40138A()
{
  return 6761486;
}

//----- (00401390) --------------------------------------------------------
char *__stdcall sub_401390(char *a1, int a2, int a3)
{
  int v4; // eax
  bool v5; // zf
  char *v6; // eax
  char *v7; // eax
  unsigned int v8; // ecx
  char *v9; // edi
  char *v10; // ebx
  _BYTE *v11; // edx
  unsigned int v12; // edx
  unsigned int v14; // eax
  unsigned int *v15; // ebx
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char *v18; // eax
  char v19; // dl
  char *v20; // eax
  int v21; // [esp+0h] [ebp-24h]
  int v22; // [esp+4h] [ebp-20h]
  unsigned int v23; // [esp+Ch] [ebp-18h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  char *v25; // [esp+14h] [ebp-10h]
  char *v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  unsigned int v28; // [esp+20h] [ebp-4h]
  unsigned int v29; // [esp+2Ch] [ebp+8h]
  _BYTE *v30; // [esp+2Ch] [ebp+8h]
  char *v31; // [esp+30h] [ebp+Ch]
  char *v32; // [esp+30h] [ebp+Ch]

  if ( a1 )
  {
    v4 = *((_DWORD *)a1 + 15);
    v5 = &a1[v4] == 0;
    v6 = &a1[v4];
    v26 = v6;
    if ( !v5 )
    {
      v7 = &a1[*((_DWORD *)v6 + 30)];
      if ( v7 != a1 )
      {
        v25 = &a1[*((_DWORD *)v7 + 9)];
        v8 = *((_DWORD *)v7 + 5);
        v9 = &a1[*((_DWORD *)v7 + 7)];
        v10 = &a1[*((_DWORD *)v7 + 8)];
        v23 = v8;
        v24 = *((_DWORD *)v7 + 6);
        v28 = v8;
        if ( v8 <= v24 )
          v28 = *((_DWORD *)v7 + 6);
        v11 = (_BYTE *)a2;
        if ( a2 >= 0 )
        {
          v14 = 0;
          v29 = 0;
          if ( v28 )
          {
            while ( 1 )
            {
              v27 = *(unsigned __int16 *)&v25[2 * v14];
              if ( v14 >= v24 || *(unsigned __int16 *)&v25[2 * v14] >= v23 )
                break;
              if ( sub_40159A(v11, (int)&a1[*(_DWORD *)&v10[4 * v29]]) )
              {
                v15 = (unsigned int *)&v9[4 * v27];
                v16 = *v15;
                v17 = *((_DWORD *)v26 + 30);
                if ( *v15 < v17 || v16 >= v17 + *((_DWORD *)v26 + 31) )
                  return &a1[v16];
                v18 = &a1[v16];
                do
                {
                  v19 = *v18++;
                  v31 = v18;
                }
                while ( v19 != 46 );
                v30 = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a3 + 8))(0, &v18[-v16] - a1, 12288, 4);
                if ( v30 )
                {
                  sub_401A68(v30, &a1[*v15], &v31[-*v15] - a1 - 1);
                  v20 = (char *)(*(int (__stdcall **)(_BYTE *, char *, int))a3)(v30, v31, a3);
                  v32 = sub_401390(v20, v21, v22);
                  (*(void (__stdcall **)(_BYTE *))(a3 + 12))(v30);
                  return v32;
                }
                return 0;
              }
              if ( ++v29 >= v28 )
                return 0;
              v11 = (_BYTE *)a2;
              v14 = v29;
            }
          }
        }
        else
        {
          v12 = (a2 & 0x7FFFFFFF) - *((_DWORD *)v7 + 4);
          if ( v12 < v8 )
            return &a1[*(_DWORD *)&v9[4 * v12]];
        }
      }
    }
  }
  return 0;
}
// 4014BC: variable 'v21' is possibly undefined
// 4014BC: variable 'v22' is possibly undefined

//----- (004014E5) --------------------------------------------------------
int __stdcall sub_4014E5(char *a1, int (__stdcall **a2)(char *))
{
  char *v2; // edx
  char *v3; // esi
  char *v5; // edi
  char *v6; // ebx
  unsigned int v7; // eax
  char *v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  char *v11; // eax
  int v12; // [esp-10h] [ebp-24h]
  char *v13; // [esp+4h] [ebp-10h]
  char *v14; // [esp+8h] [ebp-Ch]
  unsigned int v15; // [esp+Ch] [ebp-8h]
  unsigned int v16; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = &a1[*(_DWORD *)&a1[*((_DWORD *)a1 + 15) + 120]];
  v14 = &a1[*((_DWORD *)a1 + 15) + 120];
  if ( v3 == a1 )
    return 1;
  v5 = &a1[*((_DWORD *)v3 + 7)];
  v6 = &a1[*((_DWORD *)v3 + 9)];
  v15 = *((_DWORD *)v3 + 5);
  if ( v15 <= *((_DWORD *)v3 + 6) )
    v15 = *((_DWORD *)v3 + 6);
  v7 = 0;
  v16 = 0;
  if ( v15 )
  {
    while ( 1 )
    {
      if ( v7 < *((_DWORD *)v3 + 5) )
        v7 = *(unsigned __int16 *)&v6[2 * v7];
      v8 = &v5[4 * v7];
      v9 = &v2[*(_DWORD *)v8];
      v13 = v8;
      if ( v9 != v2 )
      {
        if ( v9 > v3 )
        {
          if ( v9 < &v3[40 * *((_DWORD *)v14 + 1)] )
          {
            v10 = &v2[*(_DWORD *)v8];
            do
              ++v10;
            while ( *v10 != 46 );
            *v10 = 0;
            v12 = (int)(v10 + 1);
            v11 = (char *)(*a2)(v9);
            v9 = sub_401390(v11, v12, (int)a2);
            v8 = v13;
          }
          v2 = a1;
        }
        if ( !v9 )
          return 0;
        *(_DWORD *)v8 = v9;
      }
      if ( ++v16 >= v15 )
        return 1;
      v7 = v16;
    }
  }
  return 1;
}

//----- (0040159A) --------------------------------------------------------
int __usercall sub_40159A@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  bool v2; // bl
  int v3; // esi
  int v4; // edx
  char v5; // cl
  bool v6; // zf

  v2 = *a1 == 1;
  if ( *a1 == 1 )
    ++a1;
  if ( *a1 == 2 )
    return 1;
  v3 = a2 - (_DWORD)a1;
  while ( 1 )
  {
    if ( v2 )
    {
      v4 = (char)*a1;
      if ( *a1 )
        v4 += 30;
      v5 = a1[v3];
      v6 = v5 == v4;
    }
    else
    {
      v5 = a1[v3];
      v6 = v5 == *a1;
    }
    if ( !v6 )
      break;
    if ( v5 )
    {
      if ( *++a1 != 2 )
        continue;
    }
    return 1;
  }
  return 0;
}

//----- (004015E7) --------------------------------------------------------
int __userpurge sub_4015E7@<eax>(_DWORD *a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v4; // ebx
  char **v5; // eax
  int v6; // [esp-14h] [ebp-14h]
  int v7; // [esp-10h] [ebp-10h]

  v2 = (_DWORD *)((char *)a1 + *(_DWORD *)((char *)a1 + a1[15] + 128));
  if ( v2 == a1 )
    return 1;
  if ( !*v2 )
    return 1;
  v4 = (_DWORD *)((char *)a1 + *(_DWORD *)((char *)a1 + a1[15] + 128));
  while ( 1 )
  {
    v7 = (int)a1 + *v4;
    v5 = (char **)((char *)a1 + v4[4]);
    v6 = (int)a1 + v4[3];
    v4 += 5;
    if ( !sub_40166B(v5, a2, v6, v7, (int)a1) )
      break;
    if ( !*v4 )
      return 1;
  }
  return 0;
}

//----- (00401639) --------------------------------------------------------
_BYTE *__usercall sub_401639@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[8] = 2;
  result[1] = 111;
  result[3] = 98;
  result[6] = 101;
  result[2] = 109;
  result[5] = 110;
  *result = 67;
  result[7] = 82;
  result[4] = 105;
  return result;
}

//----- (0040166B) --------------------------------------------------------
int __userpurge sub_40166B@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebx
  int *v8; // ecx
  int v9; // eax
  char *v10; // eax
  char *v11; // [esp+Ch] [ebp+8h]

  result = (*(int (__stdcall **)(int))(a2 + 16))(a3);
  v11 = (char *)result;
  if ( result )
  {
    v7 = a4 - (_DWORD)a1;
    while ( 1 )
    {
      v8 = (int *)((char *)a1 + v7);
      v9 = 0;
      if ( (char **)((char *)a1 + v7) )
        v9 = *v8;
      if ( !a1 || !*a1 )
        return 1;
      if ( v8 )
      {
        if ( v9 >= 0 )
          v9 += a5 + 2;
        v10 = sub_401390(v11, v9, a2);
        if ( !v10 )
          return 0;
        *a1 = v10;
      }
      ++a1;
    }
  }
  return result;
}

//----- (004016C9) --------------------------------------------------------
_BYTE *__usercall sub_4016C9@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 8, 12288, 4);
  *result = 67;
  result[7] = 2;
  result[2] = 101;
  result[5] = 101;
  result[3] = 97;
  result[1] = 114;
  result[6] = 82;
  result[4] = 116;
  return result;
}

//----- (004016F7) --------------------------------------------------------
int __userpurge sub_4016F7@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  unsigned int v3; // ebx
  _DWORD *v4; // edi
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 136);
  if ( v2 != a1 )
  {
    v6 = a1 - a2;
    if ( v6 )
    {
      v3 = 0;
      if ( *(_WORD *)(v2 + 14) )
      {
        v4 = (_DWORD *)(v2 + 20);
        do
        {
          sub_401A43((*v4 & 0x7FFFFFFF) + v2 + 16, v2, v6);
          v4 += 2;
          ++v3;
        }
        while ( v3 < *(unsigned __int16 *)(v2 + 14) );
      }
    }
  }
  return 1;
}

//----- (0040174B) --------------------------------------------------------
_BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>)
{
  *result = 71;
  result[1] = 101;
  result[5] = 103;
  result[6] = 2;
  result[2] = 116;
  result[4] = 101;
  result[3] = 82;
  return result;
}

//----- (00401767) --------------------------------------------------------
_BYTE *__usercall sub_401767@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 10, 12288, 4);
  result[7] = 108;
  result[6] = 100;
  result[3] = 51;
  result[8] = 108;
  *result = 103;
  result[1] = 100;
  result[4] = 50;
  result[5] = 46;
  result[2] = 105;
  return result;
}

//----- (00401799) --------------------------------------------------------
BOOL __usercall sub_401799@<eax>(int a1@<edx>, _DWORD *a2@<esi>)
{
  int v3; // edi
  int *v4; // ecx
  int *v5; // eax
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // ebx
  _BYTE *v11; // ebx
  int (__stdcall *v12)(char *); // eax
  int v13; // eax
  char v14[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128) == a1 )
    return 0;
  v3 = 0;
  v4 = (int *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  do
  {
    if ( !*v4 )
      return 0;
    v5 = v4;
    v6 = v4[3];
    v4 += 5;
  }
  while ( *(_BYTE *)(a1 + v6) != 75 );
  v7 = *v5;
  v8 = (_DWORD *)(a1 + v5[4]);
  v9 = a1 + v7;
  if ( !*v8 )
    return 0;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v9 + 4 * v3);
    if ( v10 >= 0 )
    {
      v11 = (_BYTE *)(a1 + v10);
      if ( v11[2] == 71 && v11[3] == 101 && v11[5] == 77 && v11[11] == 72 )
        break;
    }
    if ( !v8[++v3] )
      return 0;
  }
  v12 = (int (__stdcall *)(char *))v8[v3];
  strcpy(v14, "Kernel32.dll");
  v13 = v12(v14);
  sub_4018A0(v13, a2);
  return *a2 && a2[4] && a2[2] && a2[3] && a2[1] && a2[5];
}

//----- (0040186E) --------------------------------------------------------
_BYTE *__usercall sub_40186E@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[7] = 111;
  result[8] = 2;
  result[4] = 116;
  *result = 67;
  result[1] = 114;
  result[2] = 101;
  result[3] = 97;
  result[5] = 101;
  result[6] = 82;
  return result;
}

//----- (004018A0) --------------------------------------------------------
unsigned int __userpurge sub_4018A0@<eax>(int a1@<edi>, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // esi
  int v4; // ebx
  unsigned int result; // eax
  unsigned int v6; // edx
  _BYTE *v7; // eax
  int v8; // esi
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  unsigned int v14; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120));
  v9 = a1 + v2[9];
  v3 = a1 + v2[7];
  v4 = a1 + v2[8];
  v11 = v3;
  v10 = v4;
  v12 = v2[5];
  if ( v12 <= v2[6] )
    v12 = v2[6];
  result = 0;
  v14 = 0;
  v13 = 0;
  if ( v12 )
  {
    while ( 1 )
    {
      if ( v14 >= 6 )
        return result;
      v6 = *(unsigned __int16 *)(v9 + 2 * result);
      if ( result >= v2[6] || v6 >= v2[5] )
        return result;
      v7 = (_BYTE *)(a1 + *(_DWORD *)(v4 + 4 * result));
      v8 = a1 + *(_DWORD *)(v3 + 4 * v6);
      if ( *v7 == 71 && v7[1] == 101 )
      {
        if ( v7[2] == 116 && v7[3] == 77 && v7[15] == 65 )
        {
          *a2 = v8;
LABEL_47:
          ++v14;
          goto LABEL_48;
        }
        if ( v7[2] == 116 && v7[3] == 84 && v7[4] == 105 && v7[5] == 99 && v7[7] == 67 && v7[11] == 116 && !v7[12] )
        {
          a2[5] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 86 && v7[1] == 105 )
      {
        if ( v7[2] == 114 && v7[7] == 65 && v7[8] == v7[9] && !v7[12] )
        {
          a2[2] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 80 && v7[8] == 114 && !v7[14] )
        {
          a2[1] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 70 && v7[9] == v7[10] && !v7[11] )
        {
          a2[3] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 76 && v7[1] == 111 && v7[2] == 97 && v7[3] == 100 && v7[4] == 76 && v7[11] == 65 )
      {
        a2[4] = v8;
        goto LABEL_47;
      }
LABEL_48:
      result = ++v13;
      if ( v13 >= v12 )
        return result;
      v3 = v11;
      v4 = v10;
      result = v13;
    }
  }
  return result;
}
// 401950: conditional instruction was optimized away because dl.1==65
// 4019B9: conditional instruction was optimized away because dl.1==69
// 4019DE: conditional instruction was optimized away because dl.1==69

//----- (00401A43) --------------------------------------------------------
_DWORD *__userpurge sub_401A43@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ecx
  _DWORD *result; // eax

  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( (v3 & 0x80000000) == 0 )
      break;
    a1 = (v3 & 0x7FFFFFFF) + a2 + 16;
  }
  result = (_DWORD *)(a2 + *(_DWORD *)(a1 + 4));
  *result += a3;
  return result;
}

//----- (00401A68) --------------------------------------------------------
_BYTE *__userpurge sub_401A68@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3)
{
  while ( a3 )
  {
    --a3;
    *result++ = *a2++;
  }
  return result;
}

//----- (00401A7E) --------------------------------------------------------
int __stdcall start(HINSTANCE hInstance, int a2, int a3)
{
  const char *CommandLineA; // edx
  unsigned int v4; // eax
  int v5; // edi
  unsigned int v7; // eax
  int v8; // edi
  HMODULE ModuleHandleA; // edi
  HWND Window; // edi
  signed int i; // esi
  char *v14; // edi
  HWND v15; // eax
  char *v16; // eax
  HWND v17; // edi
  void *v18; // eax
  HMENU Menu; // eax
  _BYTE *v20; // eax
  HDC DC; // eax
  HMENU v22; // eax
  char *v23; // eax
  int *v24; // ecx
  unsigned int v25; // eax
  DWORD *v26; // eax
  DWORD v27; // edi
  DWORD v28; // esi
  HWND ActiveWindow; // eax
  HMODULE v30; // eax
  HANDLE CurrentProcess; // eax
  HWND v32; // esi
  HANDLE CurrentThread; // edi
  char *v34; // esi
  char *v35; // eax
  HANDLE v36; // eax
  char *v37; // eax
  HGLOBAL v38; // eax
  void *v39; // esi
  char *v40; // esi
  char *v41; // edi
  char *v42; // ebx
  int v43; // esi
  unsigned int v44; // ecx
  __int16 v45; // ax
  char *v46; // edx
  _DWORD *v47; // eax
  char *v48; // ebx
  char *v49; // eax
  int v50; // [esp+0h] [ebp-118h]
  int v51; // [esp+4h] [ebp-114h]
  int v52; // [esp+8h] [ebp-110h]
  LPARAM lParam[11]; // [esp+Ch] [ebp-10Ch] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+38h] [ebp-E0h] BYREF
  char *v55; // [esp+5Ch] [ebp-BCh]
  int v56; // [esp+60h] [ebp-B8h]
  int v57; // [esp+64h] [ebp-B4h]
  int v58; // [esp+68h] [ebp-B0h]
  int v59; // [esp+6Ch] [ebp-ACh]
  DWORD ExitCode; // [esp+70h] [ebp-A8h] BYREF
  int v61; // [esp+74h] [ebp-A4h]
  HACCEL v62; // [esp+78h] [ebp-A0h]
  DWORD dwExitCode; // [esp+7Ch] [ebp-9Ch]
  int v64; // [esp+80h] [ebp-98h]
  int v65; // [esp+84h] [ebp-94h]
  int v66; // [esp+88h] [ebp-90h]
  unsigned int v67; // [esp+8Ch] [ebp-8Ch]
  char *v68; // [esp+90h] [ebp-88h]
  char v69[7]; // [esp+94h] [ebp-84h] BYREF
  char v70[4]; // [esp+9Bh] [ebp-7Dh] BYREF
  char v71[12]; // [esp+A0h] [ebp-78h] BYREF
  DWORD v72; // [esp+ACh] [ebp-6Ch]
  int (__stdcall *v73)(char *); // [esp+B0h] [ebp-68h] BYREF
  void (__stdcall *v74)(char *, DWORD, int, int *); // [esp+B4h] [ebp-64h]
  char *v75; // [esp+B8h] [ebp-60h]
  void (__stdcall *v76)(HACCEL, _DWORD, int); // [esp+BCh] [ebp-5Ch]
  int (__stdcall *v77)(HACCEL); // [esp+C0h] [ebp-58h]
  int v78; // [esp+C8h] [ebp-50h]
  int v79; // [esp+CCh] [ebp-4Ch]
  int v80; // [esp+D0h] [ebp-48h] BYREF
  HWND v81; // [esp+D4h] [ebp-44h]
  int v82; // [esp+D8h] [ebp-40h]
  HWND hWnd; // [esp+DCh] [ebp-3Ch]
  char *v84; // [esp+E0h] [ebp-38h]
  char *v85; // [esp+E4h] [ebp-34h]
  DWORD v86; // [esp+E8h] [ebp-30h]
  HACCEL hAccTable; // [esp+ECh] [ebp-2Ch]
  HWND hWndParent; // [esp+F0h] [ebp-28h]
  char *v89; // [esp+F4h] [ebp-24h]
  HWND v90; // [esp+F8h] [ebp-20h] BYREF
  char *v91; // [esp+FCh] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+100h] [ebp-18h]

  if ( a2 % 0xAu == 20 )
  {
    TlsGetValue(0);
    TlsSetValue(0, (LPVOID)0x6546);
    memset(&SystemInfo, 0, sizeof(SystemInfo));
    GetSystemInfo(&SystemInfo);
    LOWORD(v90) = (unsigned __int8)(*(_BYTE *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 71) + 1);
    ms_exc.registration.TryLevel = 0;
    CommandLineA = GetCommandLineA();
    v4 = strlen(CommandLineA) + 1;
    v5 = 1050195;
    while ( *(_BYTE *)++v5 )
      ;
    qmemcpy((void *)v5, CommandLineA, v4);
    v7 = strlen((const char *)&v90) + 1;
    v8 = 1050195;
    while ( *(_BYTE *)++v8 )
      ;
    qmemcpy((void *)v8, &v90, v7);
    ms_exc.registration.TryLevel = -1;
  }
  v59 = 0;
  v90 = 0;
  if ( hInstance && (unsigned int)a2 <= 3 && (!a3 || a3 == 1) )
  {
    v59 = 1;
    v90 = (HWND)hInstance;
  }
  hWndParent = 0;
  if ( (unsigned int)hInstance % 0x17 <= 0x32 )
  {
    if ( !v90 )
      v90 = (HWND)(((unsigned int)start & 0xFFFFF000) - 4096);
  }
  else
  {
    ModuleHandleA = GetModuleHandleA(0);
    hWndParent = CreateWindowExA(0, (LPCSTR)0x8002, byte_4030FD, 0x10C00000u, 25, 35, 400, 400, 0, 0, hInstance, 0);
    if ( hWndParent && ModuleHandleA )
    {
      memset(&lParam[1], 0, 0x28u);
      lParam[0] = 15;
      Window = CreateWindowExA(
                 0,
                 "SysListView32",
                 byte_4030FD,
                 0x50000205u,
                 60,
                 80,
                 300,
                 300,
                 hWndParent,
                 (HMENU)0x234,
                 hInstance,
                 0);
      for ( i = 0; i < 11; ++i )
      {
        lParam[5] = i;
        lParam[3] = (LPARAM)&SystemInfo.dwPageSize;
        lParam[2] = 20;
        lParam[1] = i >= 2;
        if ( SendMessageA(Window, 0x101Bu, i, (LPARAM)lParam) == -1 )
          return 0;
      }
    }
  }
  v89 = 0;
  v80 = 0;
  dwExitCode = 0;
  v86 = 0;
  v64 = 0;
  v69[0] = 1;
  v69[1] = 80;
  v69[2] = 86;
  v69[3] = 70;
  v69[4] = 78;
  v69[5] = 78;
  v69[6] = 16;
  strcpy(v70, "FNN");
  v71[0] = 1;
  v71[1] = 46;
  v71[2] = 70;
  v71[3] = 84;
  v71[4] = 40;
  v71[5] = 75;
  v71[6] = 80;
  v71[7] = 70;
  v71[8] = 39;
  v71[9] = 2;
  v14 = (char *)v90 + *((_DWORD *)v90 + 15);
  v68 = v14;
  v65 = 0;
  v58 = 0;
  v66 = 0;
  v61 = 0;
  v57 = 0;
  v79 = 106194171;
  if ( !sub_401799((int)v90, &v73) )
    return 0;
  v78 = ((int (__stdcall *)(_DWORD, int, int, int))v75)(0, 7, 12288, 4);
  if ( hWndParent )
  {
    hAccTable = LoadAcceleratorsA(hInstance, (LPCSTR)0x64);
    hWnd = CreateWindowExA(0, "Button", "Abc", 0x50010000u, 10, 5, 32, 18, hWndParent, (HMENU)0x1992, hInstance, 0);
    v15 = CreateWindowExA(
            0,
            "Static",
            "Q w e r t y B",
            0x50010000u,
            50,
            5,
            100,
            100,
            hWndParent,
            (HMENU)0x363,
            hInstance,
            0);
    if ( hWnd )
    {
      if ( v15 )
      {
        ShowWindow(v15, 0);
        SetWindowTextA(hWnd, "Qwerty Qwerty");
        while ( GetMessageA((LPMSG)&SystemInfo.lpMinimumApplicationAddress, 0, 0, 0) )
        {
          if ( !TranslateAcceleratorA(
                  (HWND)SystemInfo.lpMinimumApplicationAddress,
                  hAccTable,
                  (LPMSG)&SystemInfo.lpMinimumApplicationAddress) )
            TranslateMessage((const MSG *)&SystemInfo.lpMinimumApplicationAddress);
        }
        sub_40138A();
      }
    }
  }
  v56 = *((_DWORD *)v14 + 20);
  v16 = sub_401367(v69);
  v55 = (char *)v73(v16);
  hAccTable = (HACCEL)sub_401767((int)&v73);
  v91 = (char *)v77(hAccTable);
  v76(hAccTable, 0, 0x8000);
  if ( !v91 )
    return 0;
  v72 = *((_DWORD *)v14 - 2);
  if ( !v72 )
    return 0;
  hAccTable = (HACCEL)sub_40186E((int)&v73);
  v85 = sub_401390(v91, (int)hAccTable, (int)&v73);
  v76(hAccTable, 0, 0x8000);
  if ( !v85 )
    return 0;
  v17 = (HWND)((char *)v90 + *((_DWORD *)v14 + 34));
  if ( v17 == v90 )
    return 1;
  hAccTable = (HACCEL)sub_401639((int)&v73);
  v84 = sub_401390(v91, (int)hAccTable, (int)&v73);
  v76(hAccTable, 0, 0x8000);
  if ( !v84 )
    return 0;
  v67 = (unsigned int)hInstance % 0x1B;
  if ( (unsigned int)hInstance % 0x1B > 0x32 )
  {
    if ( GetScrollInfo((HWND)0x654757, 0, (LPSCROLLINFO)&SystemInfo.lpMinimumApplicationAddress) )
    {
      SystemInfo.dwAllocationGranularity += 20;
      SetScrollInfo((HWND)0x6547547, 0, (LPCSCROLLINFO)&SystemInfo.lpMinimumApplicationAddress, 1);
    }
    else
    {
      v18 = VirtualAlloc(0, 0xAu, 0x2000u, 0x20u);
      if ( v18 )
        VirtualFree(v18, 0, 0x8000u);
    }
  }
  ExitCode = (DWORD)sub_4016C9((int)&v73);
  hWnd = (HWND)sub_401390(v91, ExitCode, (int)&v73);
  if ( !hWnd )
    return 0;
  v81 = v17 + 4;
  v82 = 0;
  hAccTable = (HACCEL)((unsigned int)hInstance % 0xA);
  if ( (unsigned int)hInstance % 0xA == 20 )
  {
    Menu = GetMenu(hWndParent);
    if ( Menu && ModifyMenuA(Menu, 0, 0x400u, 0, "Abcd") )
      MessageBoxA(0, "kglgkgfjgf", "jktylsfgkg", 0);
  }
  else
  {
    v79 = ((int (__stdcall *)(int, int, int, int, int, int))v85)(20, 20, 50, 50, 30, 120);
    if ( v79 )
      v66 = ((int (__stdcall *)(int, int, int, int))hWnd)(5, 7, 30, 29);
  }
  if ( !v66 )
    return 0;
  hWndParent = (HWND)45;
  v20 = sub_40174B((_BYTE *)v78);
  v91 = sub_401390(v91, (int)v20, (int)&v73);
  if ( !v91 )
    return 0;
  v62 = (HACCEL)((int (__stdcall *)(_DWORD, int, int, int))v75)(0, 100, 12288, 4);
  v79 = ((int (__stdcall *)(int, int, _DWORD))v91)(v79, 10, 0);
  v76(v62, 0, 0x8000);
  if ( a2 % 0xAu == 40 )
  {
    if ( v79 != 304 )
      return 0;
  }
  else
  {
    DC = GetDC(v90);
    DrawTextA(DC, "Qwerty", 32, (LPRECT)0x54645AF, 1u);
  }
  v62 = (HACCEL)((int (__stdcall *)(int, int, int, int, int, int))v85)(20, 20, 50, 60, 15, 15);
  if ( !v62 )
    return 0;
  v76((HACCEL)v78, 0, 0x8000);
  v76((HACCEL)ExitCode, 0, 0x8000);
  if ( *((_WORD *)v17 + 7) )
  {
    while ( 1 )
    {
      if ( *(_WORD *)v81 != 23 )
        goto LABEL_76;
      if ( (unsigned int)hInstance % 0x4C <= 0x64 )
      {
        v65 = ((int (__stdcall *)(int, int, int, int))hWnd)(15, 16, 20, 21);
      }
      else
      {
        v22 = GetMenu((HWND)0x654674);
        if ( v22 && ModifyMenuA(v22, 5u, 0x400u, 5u, 0) )
        {
          SendMessageA((HWND)0x654674, 0x1000Bu, 1u, 0);
        }
        else if ( GetWindowRect((HWND)0x654674, (LPRECT)&SystemInfo.dwNumberOfProcessors) )
        {
          SystemInfo.dwAllocationGranularity += 10;
          InvalidateRect((HWND)0x654674, (const RECT *)&SystemInfo.dwNumberOfProcessors, 1);
        }
      }
      if ( !v65 )
        return 0;
      if ( !v57 )
      {
        v61 = ((int (__stdcall *)(HACCEL, _DWORD, _DWORD))v91)(v62, 0, 0);
        v84 -= v61;
      }
      v23 = (char *)v17 + ((_DWORD)v81[1] & 0x7FFFFFFF);
      v24 = (int *)(v23 + 16);
      v57 = 1;
      v85 = 0;
      v25 = *((unsigned __int16 *)v23 + 7) + *((unsigned __int16 *)v23 + 6);
      if ( v25 )
        break;
LABEL_76:
      v81 += 2;
      if ( ++v82 >= (unsigned int)*((unsigned __int16 *)v17 + 7) )
        goto LABEL_77;
    }
    while ( 1 )
    {
      v78 = 0;
      if ( *v24 >= 0 )
      {
        if ( (unsigned int)*v24 > 0x5DC )
          goto LABEL_72;
        v78 = 1;
      }
      if ( v78 )
      {
        v26 = (DWORD *)((char *)v17 + *(_DWORD *)((char *)v17 + (v24[1] & 0x7FFFFFFF) + 20));
        hWndParent = (HWND)((char *)hWndParent + v61);
        dwExitCode = *v26;
        v86 = v26[1];
        v82 = *((unsigned __int16 *)v17 + 7);
        v58 = ((int (__stdcall *)(int, int, int, int))hWnd)(1, 2, 3, 4);
        if ( v58 )
        {
          v84 += 176;
          goto LABEL_76;
        }
        return 0;
      }
LABEL_72:
      v24 += 2;
      if ( (unsigned int)++v85 >= v25 )
        goto LABEL_76;
    }
  }
LABEL_77:
  v27 = dwExitCode;
  v28 = dwExitCode;
  if ( v67 <= 0x36 )
  {
    v28 = dwExitCode + 1;
  }
  else
  {
    ActiveWindow = GetActiveWindow();
    if ( ActiveWindow )
      ShowWindow(ActiveWindow, 3);
  }
  if ( v28 == 1 )
  {
    v30 = GetModuleHandleA(0);
    CloseHandle(v30);
    if ( hAccTable == (HACCEL)20 )
    {
      TerminateThread((HANDLE)0x54, 1u);
    }
    else
    {
      if ( (unsigned int)hInstance % 0xF != 16 )
        return 0;
      CurrentProcess = GetCurrentProcess();
      TerminateProcess(CurrentProcess, 0);
    }
  }
  v75 += v61;
  v32 = v90;
  v67 = (unsigned int)v90 + v27;
  if ( !(HWND)((char *)v90 + v27) )
    return 0;
  if ( hAccTable == (HACCEL)27 )
  {
    CurrentThread = GetCurrentThread();
    if ( CurrentThread && GetCurrentThreadId() )
      GetExitCodeThread(CurrentThread, &ExitCode);
  }
  else
  {
    v74((char *)v90 + v27, v86, 4, &v80);
    v75 -= 176;
  }
  v91 = 0;
  v34 = (char *)v32 + v56;
  do
  {
    if ( (unsigned int)v91 > 0x800 )
      break;
    v35 = v34;
    ++v91;
    v34 += 4096;
    v89 = (char *)((int (__stdcall *)(char *, DWORD, int, int))v75)(v35, v72, 12288, 4);
  }
  while ( !v89 );
  if ( (unsigned int)hInstance % 0x11 == 21 )
  {
    v36 = HeapCreate(0, 0x400u, 0x100000u);
    if ( v36 )
    {
      v37 = (char *)HeapAlloc(v36, 8u, 0x400u);
      qmemcpy(v37, (char *)v90 + 1893, 0x400u);
    }
  }
  else
  {
    v91 = (char *)((int (__stdcall *)(int, int, int, int))v84)(v58, v66, v65, 3);
  }
  if ( !v89 )
  {
    v89 = (char *)((int (__stdcall *)(_DWORD, DWORD, int, int))v75)(0, v72, 12288, 4);
    if ( !v89 )
      return 0;
  }
  if ( v79 == 304 )
    sub_401268((int)&v91[(_DWORD)hWndParent + v67 - 224], v86, v89);
  if ( !sub_4014E5(v89, &v73) )
    return 0;
  if ( (unsigned int)hInstance % 0xB == 15 )
  {
    v38 = GlobalAlloc(0x40u, 0x400u);
    v39 = v38;
    if ( v38 )
    {
      *(_BYTE *)((int (__stdcall *)(HGLOBAL, int))((char *)v90 + 1381))(v38, 1049926) = 1;
      GlobalFree(v39);
    }
  }
  v40 = v89;
  if ( !sub_4015E7(v89, (int)&v73) || !sub_4016F7((int)v40, (int)v90) )
    return 0;
  v41 = v40;
  v42 = &v40[*((_DWORD *)v40 + 15)];
  v43 = (int)v68;
  ((void (__stdcall *)(char *, int, int, int *, int, int, int, LPARAM))v74)(
    v68,
    248,
    64,
    &v80,
    v50,
    v51,
    v52,
    lParam[0]);
  *(_DWORD *)(v43 + 80) = -1 - (_DWORD)v90;
  *(_DWORD *)(v43 + 140) = *((_DWORD *)v42 + 35);
  *(_DWORD *)(v43 + 136) = &v41[*((_DWORD *)v42 + 34) - (_DWORD)v90];
  v44 = (unsigned int)(v42 + 248);
  v45 = *((_WORD *)v42 + 3);
  *(_WORD *)(v43 + 6) = v45;
  v86 = 0;
  if ( v45 )
  {
    v46 = v42 + 248;
    v47 = (_DWORD *)(v43 + 260);
    do
    {
      qmemcpy(v47 - 3, v46, 0x28u);
      *v47 += v89 - (char *)v90;
      ++v86;
      v47 += 10;
      v46 += 40;
      v44 = *((unsigned __int16 *)v68 + 3);
    }
    while ( v86 < v44 );
    v41 = v89;
    v43 = (int)v68;
  }
  ((void (__thiscall *)(unsigned int, int, int, int, int *))v74)(v44, v43, 248, v80, &v80);
  if ( !sub_4012D3(v41) )
    return 0;
  v74(v41, v72, 64, &v80);
  v48 = &v41[*((_DWORD *)v42 + 10)];
  if ( v59 )
  {
    v49 = sub_401390(v55, (int)v71, (int)&v73);
    if ( v49 )
    {
      v91 = 0;
      ((void (__stdcall *)(HINSTANCE, char **))v49)(hInstance, &v91);
      if ( v91 )
      {
        *((_DWORD *)v91 + 6) = v41;
        *((_DWORD *)v91 + 7) = v48;
        *((_DWORD *)v91 + 8) = v72;
        return ((int (__stdcall *)(int, char *, int, int))v48)(1, v41, a2, a3);
      }
    }
  }
  else
  {
    v64 = ((int (__stdcall *)(_DWORD, HINSTANCE, int, int))v48)(0, hInstance, a2, a3);
    v76((HACCEL)v41, 0, 0x8000);
  }
  return v64;
}
// 4024B8: variable 'v50' is possibly undefined
// 4024B8: variable 'v51' is possibly undefined
// 4024B8: variable 'v52' is possibly undefined

//----- (004025EF) --------------------------------------------------------
HANDLE __stdcall GetKJgkdghkdfhd()
{
  HANDLE EventA; // esi

  EventA = CreateEventA(0, 1, 1, "Jlkgfdkghdlhd");
  SetEvent(EventA);
  CloseHandle(EventA);
  return EventA;
}

//----- (00402615) --------------------------------------------------------
HANDLE __stdcall GetLKfsdgdkhd()
{
  HANDLE EventA; // esi

  EventA = CreateEventA(0, 1, 1, "flkhdfhdflhf");
  SetEvent(EventA);
  CloseHandle(EventA);
  return EventA;
}

//----- (0040263B) --------------------------------------------------------
HANDLE __stdcall GetKkgdstkdgkd()
{
  HANDLE EventA; // esi

  EventA = CreateEventA(0, 1, 1, "jfkgdkhgkhg");
  SetEvent(EventA);
  CloseHandle(EventA);
  return EventA;
}

//----- (00402661) --------------------------------------------------------
HANDLE __stdcall GetKfldskgdhkd()
{
  HANDLE EventA; // esi

  EventA = CreateEventA(0, 1, 1, "gdfs;lhkdkhmdf");
  SetEvent(EventA);
  CloseHandle(EventA);
  return EventA;
}

//----- (00402687) --------------------------------------------------------
HANDLE __stdcall GetKlfgdkgldshd()
{
  HANDLE EventA; // esi

  EventA = CreateEventA(0, 1, 1, "fmdsgkdkhmdjdhgf");
  SetEvent(EventA);
  CloseHandle(EventA);
  return EventA;
}

// nfuncs=30 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
