/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_401010@<eax>(unsigned int a1@<ebx>, unsigned int a2);
void __stdcall sub_401241(int a1, unsigned int a2, unsigned int a3);
// int __userpurge sub_401268@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3);
// int __usercall sub_4012D3@<eax>(_DWORD *a1@<edi>);
// _BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>);
int sub_40138A();
char *__stdcall sub_401390(char *a1, int a2, int a3);
int __stdcall sub_4014E5(char *a1, int (__stdcall **a2)(char *));
// int __usercall sub_40159A@<eax>(_BYTE *a1@<eax>, int a2@<ecx>);
// int __userpurge sub_4015E7@<eax>(int a1@<esi>, int a2);
// _BYTE *__usercall sub_401639@<eax>(int a1@<eax>);
// int __userpurge sub_40166B@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
// _BYTE *__usercall sub_4016C9@<eax>(int a1@<eax>);
// int __userpurge sub_4016F7@<eax>(int a1@<eax>, int a2);
// _BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_401767@<eax>(int a1@<eax>);
// BOOL __usercall sub_401799@<eax>(int a1@<edx>, _DWORD *a2@<esi>);
// _BYTE *__usercall sub_40186E@<eax>(int a1@<eax>);
// unsigned int __userpurge sub_4018A0@<eax>(int a1@<edi>, _DWORD *a2);
// _DWORD *__userpurge sub_401A43@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// _BYTE *__userpurge sub_401A68@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3);
int __stdcall start(HINSTANCE hInstance, int, int); // idb
HANDLE __stdcall GetKJgkdghkdfhd();
HANDLE __stdcall GetLKfsdgdkhd();
HANDLE __stdcall GetKkgdstkdgkd();
HANDLE __stdcall GetKfldskgdhkd();
HANDLE __stdcall GetKlfgdkgldshd();
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// BOOL __stdcall DeleteDC(HDC hdc);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// BOOL __stdcall Polyline(HDC hdc, const POINT *apt, int cpt);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetCurrentThreadId();
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// HANDLE __stdcall GetCurrentThread();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SetEvent(HANDLE hEvent);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// HWND __stdcall GetActiveWindow();
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HACCEL __stdcall LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
// int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
// HMENU __stdcall GetMenu(HWND hWnd);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// int __stdcall DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// HDC __stdcall GetDC(HWND hWnd);
// HWND __stdcall GetForegroundWindow();
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);

//-------------------------------------------------------------------------
// Data declarations

const CHAR byte_4030FD[3] = { '\0', '\0', '\0' }; // idb


//----- (00401010) --------------------------------------------------------
int __userpurge sub_401010@<eax>(unsigned int a1@<ebx>, unsigned int a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // edi
  HDC v4; // esi
  HWND v5; // eax
  HDC v6; // edi
  HPEN v7; // eax
  HDC v8; // esi
  HANDLE v9; // eax
  HWND v10; // esi
  char v11; // cl
  unsigned int *v12; // eax
  bool v14; // [esp+13h] [ebp-2Dh]
  unsigned int v15; // [esp+14h] [ebp-2Ch]
  unsigned int v16; // [esp+1Ch] [ebp-24h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  HWND hWnd; // [esp+2Ch] [ebp-14h]
  struct tagRECT Rect; // [esp+30h] [ebp-10h] BYREF

  v2 = 0;
  v3 = 0x40 / a2;
  if ( 0x40 / a2 )
  {
    v14 = 0;
    v17 = a1 % 0x41;
    do
    {
      v15 = v2;
      v16 = v2;
      if ( a1 % 0xF <= 0x14 )
      {
        v15 = v2 + 8 * v14 + 13;
      }
      else
      {
        v4 = GetDC(0);
        TextOutA(v4, 10, 10, "Trololo", 32);
        if ( !v4 || MoveToEx(v4, 10, 10, 0) )
          LineTo((HDC)((char *)v4 + 10), 150, 200);
        else
          Polyline(v4, (const POINT *)0x324345, 20);
        ReleaseDC(0, v4);
      }
      if ( v17 <= 0x56 )
      {
        if ( v15 > v3 - 1 )
          v15 %= v3;
      }
      else
      {
        v5 = GetForegroundWindow();
        hWnd = v5;
        if ( v5 )
        {
          v6 = GetDC(v5);
          if ( v6 )
          {
            v7 = CreatePen(2, 3, 0x101010u);
            if ( v7 )
            {
              SelectObject(v6, v7);
            }
            else
            {
              v8 = CreateCompatibleDC(v6);
              SelectObject(v8, 0);
              BitBlt(v6, 0, 0, 50, 50, v8, 0, 0, 0xCC0020u);
              DeleteDC(v8);
            }
            ReleaseDC(hWnd, v6);
          }
          v3 = 0x40 / a2;
        }
      }
      if ( (a1 & 7) <= 0xA )
      {
        v14 = !v14;
      }
      else
      {
        v9 = CreateEventA(0, 1, 1, "TestEvent");
        SetEvent(v9);
      }
      if ( v17 <= 0x50 )
      {
        if ( a2 == 1 )
        {
          v11 = *(_BYTE *)(a1 + v2);
          goto LABEL_32;
        }
        v16 = *(_DWORD *)(a1 + 4 * v2);
      }
      else
      {
        v10 = FindWindowA(0, "MyWindow");
        if ( v10 && GetWindowRect(v10, &Rect) )
          SetWindowPos(v10, 0, Rect.left, Rect.top, Rect.right + 50, Rect.bottom, 4u);
      }
      if ( a2 != 1 )
      {
        v12 = (unsigned int *)(a1 + 4 * v15);
        *(_DWORD *)(a1 + 4 * v2) = *v12;
        *v12 = v16;
        goto LABEL_34;
      }
      v11 = v16;
LABEL_32:
      *(_BYTE *)(a1 + v2) = *(_BYTE *)(a1 + v15);
      *(_BYTE *)(a1 + v15) = v11;
LABEL_34:
      v2 += 2;
    }
    while ( v2 < v3 );
  }
  return 64;
}

//----- (00401241) --------------------------------------------------------
void __stdcall sub_401241(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int i; // esi

  for ( i = 0; i < a2; i += sub_401010(i + a1, a3) )
    ;
}

//----- (00401268) --------------------------------------------------------
int __userpurge sub_401268@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // edi
  int v6; // [esp+10h] [ebp+8h]

  sub_401241(a1, a2, 1u);
  sub_401241(a1, a2, 4u);
  v3 = a1 + *(_DWORD *)(a1 + 60);
  sub_401A68(a3, (_BYTE *)a1, *(_DWORD *)(v3 + 84));
  v6 = 0;
  result = *(unsigned __int16 *)(v3 + 20) + v3 + 24;
  if ( *(_WORD *)(v3 + 6) )
  {
    v5 = (_DWORD *)(*(unsigned __int16 *)(v3 + 20) + v3 + 44);
    do
    {
      sub_401A68(&a3[*(v5 - 2)], (_BYTE *)(a1 + *v5), *(v5 - 1));
      result = *(unsigned __int16 *)(v3 + 6);
      v5 += 10;
      ++v6;
    }
    while ( v6 < result );
  }
  return result;
}

//----- (004012D3) --------------------------------------------------------
int __usercall sub_4012D3@<eax>(_DWORD *a1@<edi>)
{
  char *v1; // ecx
  _DWORD *v2; // eax
  int i; // esi
  char *v5; // [esp+0h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  _WORD *v8; // [esp+10h] [ebp-4h]

  v1 = (char *)a1 + a1[15];
  v2 = (_DWORD *)((char *)a1 + *((_DWORD *)v1 + 40));
  v5 = (char *)a1 - *((_DWORD *)v1 + 13);
  if ( v2 == a1 )
    return 0;
  v7 = 0;
  for ( i = v2[1]; i; i = v2[1] )
  {
    if ( (unsigned int)(i - 8) >> 1 )
    {
      v8 = v2 + 2;
      v6 = (unsigned int)(i - 8) >> 1;
      do
      {
        if ( (*v8 & 0xF000) == 12288 )
          *(_DWORD *)((char *)a1 + (*v8 & 0xFFF) + *v2) += v5;
        ++v8;
        --v6;
      }
      while ( v6 );
    }
    v7 += i;
    v2 = (_DWORD *)((char *)a1 + v7 + *((_DWORD *)v1 + 40));
  }
  return 1;
}

//----- (00401367) --------------------------------------------------------
_BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>)
{
  _BYTE *v1; // ecx
  char v2; // dl

  if ( *result == 1 )
  {
    v1 = ++result;
    if ( *result )
    {
      do
      {
        if ( *v1 )
          v2 = *v1 + 30;
        else
          v2 = 0;
        *v1++ = v2;
      }
      while ( *v1 );
    }
  }
  return result;
}

//----- (0040138A) --------------------------------------------------------
int sub_40138A()
{
  return 6761486;
}

//----- (00401390) --------------------------------------------------------
char *__stdcall sub_401390(char *a1, int a2, int a3)
{
  int v4; // eax
  bool v5; // zf
  char *v6; // eax
  char *v7; // eax
  unsigned int v8; // ecx
  char *v9; // edi
  char *v10; // ebx
  _BYTE *v11; // edx
  unsigned int v12; // edx
  unsigned int v14; // eax
  unsigned int *v15; // ebx
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char *v18; // eax
  char v19; // dl
  int v20; // eax
  int v21; // [esp+0h] [ebp-24h]
  int v22; // [esp+4h] [ebp-20h]
  unsigned int v23; // [esp+Ch] [ebp-18h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  char *v25; // [esp+14h] [ebp-10h]
  char *v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  unsigned int v28; // [esp+20h] [ebp-4h]
  unsigned int v29; // [esp+2Ch] [ebp+8h]
  _BYTE *v30; // [esp+2Ch] [ebp+8h]
  char *v31; // [esp+30h] [ebp+Ch]
  int v32; // [esp+30h] [ebp+Ch]

  if ( a1 )
  {
    v4 = *((_DWORD *)a1 + 15);
    v5 = &a1[v4] == 0;
    v6 = &a1[v4];
    v26 = v6;
    if ( !v5 )
    {
      v7 = &a1[*((_DWORD *)v6 + 30)];
      if ( v7 != a1 )
      {
        v25 = &a1[*((_DWORD *)v7 + 9)];
        v8 = *((_DWORD *)v7 + 5);
        v9 = &a1[*((_DWORD *)v7 + 7)];
        v10 = &a1[*((_DWORD *)v7 + 8)];
        v23 = v8;
        v24 = *((_DWORD *)v7 + 6);
        v28 = v8;
        if ( v8 <= v24 )
          v28 = *((_DWORD *)v7 + 6);
        v11 = (_BYTE *)a2;
        if ( a2 >= 0 )
        {
          v14 = 0;
          v29 = 0;
          if ( v28 )
          {
            while ( 1 )
            {
              v27 = *(unsigned __int16 *)&v25[2 * v14];
              if ( v14 >= v24 || *(unsigned __int16 *)&v25[2 * v14] >= v23 )
                break;
              if ( sub_40159A(v11, (int)&a1[*(_DWORD *)&v10[4 * v29]]) )
              {
                v15 = (unsigned int *)&v9[4 * v27];
                v16 = *v15;
                v17 = *((_DWORD *)v26 + 30);
                if ( *v15 < v17 || v16 >= v17 + *((_DWORD *)v26 + 31) )
                  return &a1[v16];
                v18 = &a1[v16];
                do
                {
                  v19 = *v18++;
                  v31 = v18;
                }
                while ( v19 != 46 );
                v30 = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a3 + 8))(0, &v18[-v16] - a1, 12288, 4);
                if ( v30 )
                {
                  sub_401A68(v30, &a1[*v15], &v31[-*v15] - a1 - 1);
                  v20 = (*(int (__stdcall **)(_BYTE *, char *, int))a3)(v30, v31, a3);
                  v32 = sub_401390(v20, v21, v22);
                  (*(void (__stdcall **)(_BYTE *))(a3 + 12))(v30);
                  return (char *)v32;
                }
                return 0;
              }
              if ( ++v29 >= v28 )
                return 0;
              v11 = (_BYTE *)a2;
              v14 = v29;
            }
          }
        }
        else
        {
          v12 = (a2 & 0x7FFFFFFF) - *((_DWORD *)v7 + 4);
          if ( v12 < v8 )
            return &a1[*(_DWORD *)&v9[4 * v12]];
        }
      }
    }
  }
  return 0;
}
// 4014BC: variable 'v21' is possibly undefined
// 4014BC: variable 'v22' is possibly undefined

//----- (004014E5) --------------------------------------------------------
int __stdcall sub_4014E5(char *a1, int (__stdcall **a2)(char *))
{
  char *v2; // edx
  char *v3; // esi
  char *v5; // edi
  char *v6; // ebx
  unsigned int v7; // eax
  char **v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  char *v11; // eax
  int v12; // [esp-10h] [ebp-24h]
  char **v13; // [esp+4h] [ebp-10h]
  int v14; // [esp+8h] [ebp-Ch]
  unsigned int v15; // [esp+Ch] [ebp-8h]
  unsigned int v16; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = &a1[*(_DWORD *)&a1[*((_DWORD *)a1 + 15) + 120]];
  v14 = (int)&a1[*((_DWORD *)a1 + 15) + 120];
  if ( v3 == a1 )
    return 1;
  v5 = &a1[*((_DWORD *)v3 + 7)];
  v6 = &a1[*((_DWORD *)v3 + 9)];
  v15 = *((_DWORD *)v3 + 5);
  if ( v15 <= *((_DWORD *)v3 + 6) )
    v15 = *((_DWORD *)v3 + 6);
  v7 = 0;
  v16 = 0;
  if ( v15 )
  {
    while ( 1 )
    {
      if ( v7 < *((_DWORD *)v3 + 5) )
        v7 = *(unsigned __int16 *)&v6[2 * v7];
      v8 = (char **)&v5[4 * v7];
      v9 = &(*v8)[(_DWORD)v2];
      v13 = v8;
      if ( v9 != v2 )
      {
        if ( v9 > v3 )
        {
          if ( v9 < &v3[40 * *(_DWORD *)(v14 + 4)] )
          {
            v10 = &(*v8)[(_DWORD)v2];
            do
              ++v10;
            while ( *v10 != 46 );
            *v10 = 0;
            v12 = (int)(v10 + 1);
            v11 = (char *)(*a2)(v9);
            v9 = sub_401390(v11, v12, (int)a2);
            v8 = v13;
          }
          v2 = a1;
        }
        if ( !v9 )
          return 0;
        *v8 = v9;
      }
      if ( ++v16 >= v15 )
        return 1;
      v7 = v16;
    }
  }
  return 1;
}

//----- (0040159A) --------------------------------------------------------
int __usercall sub_40159A@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  bool v2; // bl
  int v3; // esi
  int v4; // edx
  char v5; // cl
  bool v6; // zf

  v2 = *a1 == 1;
  if ( *a1 == 1 )
    ++a1;
  if ( *a1 == 2 )
    return 1;
  v3 = a2 - (_DWORD)a1;
  while ( 1 )
  {
    if ( v2 )
    {
      v4 = (char)*a1;
      if ( *a1 )
        v4 += 30;
      v5 = a1[v3];
      v6 = v5 == v4;
    }
    else
    {
      v5 = a1[v3];
      v6 = v5 == *a1;
    }
    if ( !v6 )
      break;
    if ( v5 )
    {
      if ( *++a1 != 2 )
        continue;
    }
    return 1;
  }
  return 0;
}

//----- (004015E7) --------------------------------------------------------
int __userpurge sub_4015E7@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v4; // ebx
  char **v5; // eax
  int v6; // [esp-14h] [ebp-14h]
  int v7; // [esp-10h] [ebp-10h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  if ( v2 == (_DWORD *)a1 )
    return 1;
  if ( !*v2 )
    return 1;
  v4 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  while ( 1 )
  {
    v7 = a1 + *v4;
    v5 = (char **)(a1 + v4[4]);
    v6 = a1 + v4[3];
    v4 += 5;
    if ( !sub_40166B(v5, a2, v6, v7, a1) )
      break;
    if ( !*v4 )
      return 1;
  }
  return 0;
}

//----- (00401639) --------------------------------------------------------
_BYTE *__usercall sub_401639@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[8] = 2;
  result[1] = 111;
  result[3] = 98;
  result[6] = 101;
  result[2] = 109;
  result[5] = 110;
  *result = 67;
  result[7] = 82;
  result[4] = 105;
  return result;
}

//----- (0040166B) --------------------------------------------------------
int __userpurge sub_40166B@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebx
  int *v8; // ecx
  int v9; // eax
  char *v10; // eax
  char *v11; // [esp+Ch] [ebp+8h]

  result = (*(int (__stdcall **)(int))(a2 + 16))(a3);
  v11 = (char *)result;
  if ( result )
  {
    v7 = a4 - (_DWORD)a1;
    while ( 1 )
    {
      v8 = (int *)((char *)a1 + v7);
      v9 = 0;
      if ( (char **)((char *)a1 + v7) )
        v9 = *v8;
      if ( !a1 || !*a1 )
        return 1;
      if ( v8 )
      {
        if ( v9 >= 0 )
          v9 += a5 + 2;
        v10 = sub_401390(v11, v9, a2);
        if ( !v10 )
          return 0;
        *a1 = v10;
      }
      ++a1;
    }
  }
  return result;
}

//----- (004016C9) --------------------------------------------------------
_BYTE *__usercall sub_4016C9@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 8, 12288, 4);
  *result = 67;
  result[7] = 2;
  result[2] = 101;
  result[5] = 101;
  result[3] = 97;
  result[1] = 114;
  result[6] = 82;
  result[4] = 116;
  return result;
}

//----- (004016F7) --------------------------------------------------------
int __userpurge sub_4016F7@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  unsigned int v3; // ebx
  _DWORD *v4; // edi
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 136);
  if ( v2 != a1 )
  {
    v6 = a1 - a2;
    if ( v6 )
    {
      v3 = 0;
      if ( *(_WORD *)(v2 + 14) )
      {
        v4 = (_DWORD *)(v2 + 20);
        do
        {
          sub_401A43((*v4 & 0x7FFFFFFF) + v2 + 16, v2, v6);
          v4 += 2;
          ++v3;
        }
        while ( v3 < *(unsigned __int16 *)(v2 + 14) );
      }
    }
  }
  return 1;
}

//----- (0040174B) --------------------------------------------------------
_BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>)
{
  *result = 71;
  result[1] = 101;
  result[5] = 103;
  result[6] = 2;
  result[2] = 116;
  result[4] = 101;
  result[3] = 82;
  return result;
}

//----- (00401767) --------------------------------------------------------
_BYTE *__usercall sub_401767@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 10, 12288, 4);
  result[7] = 108;
  result[6] = 100;
  result[3] = 51;
  result[8] = 108;
  *result = 103;
  result[1] = 100;
  result[4] = 50;
  result[5] = 46;
  result[2] = 105;
  return result;
}

//----- (00401799) --------------------------------------------------------
BOOL __usercall sub_401799@<eax>(int a1@<edx>, _DWORD *a2@<esi>)
{
  int v3; // edi
  int *v4; // ecx
  int *v5; // eax
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // ebx
  _BYTE *v11; // ebx
  int (__stdcall *v12)(char *); // eax
  int v13; // eax
  char v14[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128) == a1 )
    return 0;
  v3 = 0;
  v4 = (int *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  do
  {
    if ( !*v4 )
      return 0;
    v5 = v4;
    v6 = v4[3];
    v4 += 5;
  }
  while ( *(_BYTE *)(a1 + v6) != 75 );
  v7 = *v5;
  v8 = (_DWORD *)(a1 + v5[4]);
  v9 = a1 + v7;
  if ( !*v8 )
    return 0;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v9 + 4 * v3);
    if ( v10 >= 0 )
    {
      v11 = (_BYTE *)(a1 + v10);
      if ( v11[2] == 71 && v11[3] == 101 && v11[5] == 77 && v11[11] == 72 )
        break;
    }
    if ( !v8[++v3] )
      return 0;
  }
  v12 = (int (__stdcall *)(char *))v8[v3];
  strcpy(v14, "Kernel32.dll");
  v13 = v12(v14);
  sub_4018A0(v13, a2);
  return *a2 && a2[4] && a2[2] && a2[3] && a2[1] && a2[5];
}

//----- (0040186E) --------------------------------------------------------
_BYTE *__usercall sub_40186E@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[7] = 111;
  result[8] = 2;
  result[4] = 116;
  *result = 67;
  result[1] = 114;
  result[2] = 101;
  result[3] = 97;
  result[5] = 101;
  result[6] = 82;
  return result;
}

//----- (004018A0) --------------------------------------------------------
unsigned int __userpurge sub_4018A0@<eax>(int a1@<edi>, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // esi
  int v4; // ebx
  unsigned int result; // eax
  unsigned int v6; // edx
  _BYTE *v7; // eax
  int v8; // esi
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  unsigned int v14; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120));
  v9 = a1 + v2[9];
  v3 = a1 + v2[7];
  v4 = a1 + v2[8];
  v11 = v3;
  v10 = v4;
  v12 = v2[5];
  if ( v12 <= v2[6] )
    v12 = v2[6];
  result = 0;
  v14 = 0;
  v13 = 0;
  if ( v12 )
  {
    while ( 1 )
    {
      if ( v14 >= 6 )
        return result;
      v6 = *(unsigned __int16 *)(v9 + 2 * result);
      if ( result >= v2[6] || v6 >= v2[5] )
        return result;
      v7 = (_BYTE *)(a1 + *(_DWORD *)(v4 + 4 * result));
      v8 = a1 + *(_DWORD *)(v3 + 4 * v6);
      if ( *v7 == 71 && v7[1] == 101 )
      {
        if ( v7[2] == 116 && v7[3] == 77 && v7[15] == 65 )
        {
          *a2 = v8;
LABEL_47:
          ++v14;
          goto LABEL_48;
        }
        if ( v7[2] == 116 && v7[3] == 84 && v7[4] == 105 && v7[5] == 99 && v7[7] == 67 && v7[11] == 116 && !v7[12] )
        {
          a2[5] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 86 && v7[1] == 105 )
      {
        if ( v7[2] == 114 && v7[7] == 65 && v7[8] == v7[9] && !v7[12] )
        {
          a2[2] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 80 && v7[8] == 114 && !v7[14] )
        {
          a2[1] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 70 && v7[9] == v7[10] && !v7[11] )
        {
          a2[3] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 76 && v7[1] == 111 && v7[2] == 97 && v7[3] == 100 && v7[4] == 76 && v7[11] == 65 )
      {
        a2[4] = v8;
        goto LABEL_47;
      }
LABEL_48:
      result = ++v13;
      if ( v13 >= v12 )
        return result;
      v3 = v11;
      v4 = v10;
      result = v13;
    }
  }
  return result;
}
// 401950: conditional instruction was optimized away because of 'dl.1==65'
// 4019B9: conditional instruction was optimized away because of 'dl.1==69'
// 4019DE: conditional instruction was optimized away because of 'dl.1==69'

//----- (00401A43) --------------------------------------------------------
_DWORD *__userpurge sub_401A43@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ecx
  _DWORD *result; // eax

  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( (v3 & 0x80000000) == 0 )
      break;
    a1 = (v3 & 0x7FFFFFFF) + a2 + 16;
  }
  result = (_DWORD *)(a2 + *(_DWORD *)(a1 + 4));
  *result += a3;
  return result;
}

//----- (00401A68) --------------------------------------------------------
_BYTE *__userpurge sub_401A68@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3)
{
  while ( a3 )
  {
    --a3;
    *result++ = *a2++;
  }
  return result;
}

//----- (00401A7E) --------------------------------------------------------
int __stdcall start(HINSTANCE hInstance, int a2, int a3)
{
  const char *v3; // edx
  unsigned int v4; // eax
  int v5; // edi
  unsigned int v7; // eax
  int v8; // edi
  HMODULE v10; // edi
  HWND v11; // edi
  signed int i; // esi
  char *v14; // edi
  HWND v15; // eax
  char *v16; // eax
  HWND v17; // edi
  void *v18; // eax
  HMENU v19; // eax
  _BYTE *v20; // eax
  HDC v21; // eax
  HMENU v22; // eax
  char *v23; // eax
  int *v24; // ecx
  unsigned int v25; // eax
  DWORD *v26; // eax
  DWORD v27; // edi
  DWORD v28; // esi
  HWND v29; // eax
  HMODULE v30; // eax
  HANDLE v31; // eax
  HWND v32; // esi
  HANDLE v33; // edi
  char *v34; // esi
  char *v35; // eax
  HANDLE v36; // eax
  char *v37; // eax
  HGLOBAL v38; // eax
  void *v39; // esi
  char *v40; // esi
  char *v41; // edi
  char *v42; // ebx
  int v43; // esi
  unsigned int v44; // ecx
  __int16 v45; // ax
  char *v46; // edx
  _DWORD *v47; // eax
  char *v48; // ebx
  char *v49; // eax
  int v50; // [esp+0h] [ebp-118h]
  int v51; // [esp+4h] [ebp-114h]
  int v52; // [esp+8h] [ebp-110h]
  LPARAM lParam; // [esp+Ch] [ebp-10Ch] BYREF
  int v54[10]; // [esp+10h] [ebp-108h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+38h] [ebp-E0h] BYREF
  char *v56; // [esp+5Ch] [ebp-BCh]
  int v57; // [esp+60h] [ebp-B8h]
  int v58; // [esp+64h] [ebp-B4h]
  int v59; // [esp+68h] [ebp-B0h]
  int v60; // [esp+6Ch] [ebp-ACh]
  DWORD ExitCode; // [esp+70h] [ebp-A8h] BYREF
  int v62; // [esp+74h] [ebp-A4h]
  HACCEL v63; // [esp+78h] [ebp-A0h]
  DWORD dwExitCode; // [esp+7Ch] [ebp-9Ch]
  int v65; // [esp+80h] [ebp-98h]
  int v66; // [esp+84h] [ebp-94h]
  int v67; // [esp+88h] [ebp-90h]
  unsigned int v68; // [esp+8Ch] [ebp-8Ch]
  char *v69; // [esp+90h] [ebp-88h]
  char v70[7]; // [esp+94h] [ebp-84h] BYREF
  char v71[4]; // [esp+9Bh] [ebp-7Dh] BYREF
  char v72[12]; // [esp+A0h] [ebp-78h] BYREF
  DWORD v73; // [esp+ACh] [ebp-6Ch]
  int (__stdcall *v74)(char *); // [esp+B0h] [ebp-68h] BYREF
  void (__stdcall *v75)(char *, DWORD, int, int *); // [esp+B4h] [ebp-64h]
  char *v76; // [esp+B8h] [ebp-60h]
  void (__stdcall *v77)(HACCEL, _DWORD, int); // [esp+BCh] [ebp-5Ch]
  int (__stdcall *v78)(HACCEL); // [esp+C0h] [ebp-58h]
  int v79; // [esp+C8h] [ebp-50h]
  int v80; // [esp+CCh] [ebp-4Ch]
  int v81; // [esp+D0h] [ebp-48h] BYREF
  HWND v82; // [esp+D4h] [ebp-44h]
  int v83; // [esp+D8h] [ebp-40h]
  HWND hWnd; // [esp+DCh] [ebp-3Ch]
  char *v85; // [esp+E0h] [ebp-38h]
  char *v86; // [esp+E4h] [ebp-34h]
  DWORD v87; // [esp+E8h] [ebp-30h]
  HACCEL hAccTable; // [esp+ECh] [ebp-2Ch]
  HWND hWndParent; // [esp+F0h] [ebp-28h]
  char *v90; // [esp+F4h] [ebp-24h]
  HWND v91; // [esp+F8h] [ebp-20h] BYREF
  char *v92; // [esp+FCh] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+100h] [ebp-18h]

  if ( a2 % 0xAu == 20 )
  {
    TlsGetValue(0);
    TlsSetValue(0, (LPVOID)0x6546);
    SystemInfo.dwOemId = 0;
    memset(&SystemInfo.dwPageSize, 0, 0x20u);
    GetSystemInfo(&SystemInfo);
    LOWORD(v91) = (unsigned __int8)(*(_BYTE *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 71) + 1);
    ms_exc.registration.TryLevel = 0;
    v3 = GetCommandLineA();
    v4 = strlen(v3) + 1;
    v5 = 1050195;
    while ( *(_BYTE *)++v5 )
      ;
    qmemcpy((void *)v5, v3, v4);
    v7 = strlen((const char *)&v91) + 1;
    v8 = 1050195;
    while ( *(_BYTE *)++v8 )
      ;
    qmemcpy((void *)v8, &v91, v7);
    ms_exc.registration.TryLevel = -1;
  }
  v60 = 0;
  v91 = 0;
  if ( hInstance && (unsigned int)a2 <= 3 && (!a3 || a3 == 1) )
  {
    v60 = 1;
    v91 = (HWND)hInstance;
  }
  hWndParent = 0;
  if ( (unsigned int)hInstance % 0x17 <= 0x32 )
  {
    if ( !v91 )
      v91 = (HWND)(((unsigned int)start & 0xFFFFF000) - 4096);
  }
  else
  {
    v10 = GetModuleHandleA(0);
    hWndParent = CreateWindowExA(0, (LPCSTR)0x8002, byte_4030FD, 0x10C00000u, 25, 35, 400, 400, 0, 0, hInstance, 0);
    if ( hWndParent && v10 )
    {
      memset(v54, 0, sizeof(v54));
      lParam = 15;
      v11 = CreateWindowExA(
              0,
              "SysListView32",
              byte_4030FD,
              0x50000205u,
              60,
              80,
              300,
              300,
              hWndParent,
              (HMENU)0x234,
              hInstance,
              0);
      for ( i = 0; i < 11; ++i )
      {
        v54[4] = i;
        v54[2] = (int)&SystemInfo.dwPageSize;
        v54[1] = 20;
        v54[0] = i >= 2;
        if ( SendMessageA(v11, 0x101Bu, i, (LPARAM)&lParam) == -1 )
          return 0;
      }
    }
  }
  v90 = 0;
  v81 = 0;
  dwExitCode = 0;
  v87 = 0;
  v65 = 0;
  v70[0] = 1;
  v70[1] = 80;
  v70[2] = 86;
  v70[3] = 70;
  v70[4] = 78;
  v70[5] = 78;
  v70[6] = 16;
  strcpy(v71, "FNN");
  v72[0] = 1;
  v72[1] = 46;
  v72[2] = 70;
  v72[3] = 84;
  v72[4] = 40;
  v72[5] = 75;
  v72[6] = 80;
  v72[7] = 70;
  v72[8] = 39;
  v72[9] = 2;
  v14 = (char *)v91 + *((_DWORD *)v91 + 15);
  v69 = v14;
  v66 = 0;
  v59 = 0;
  v67 = 0;
  v62 = 0;
  v58 = 0;
  v80 = 106194171;
  if ( !sub_401799((int)v91, &v74) )
    return 0;
  v79 = ((int (__stdcall *)(_DWORD, int, int, int))v76)(0, 7, 12288, 4);
  if ( hWndParent )
  {
    hAccTable = LoadAcceleratorsA(hInstance, (LPCSTR)0x64);
    hWnd = CreateWindowExA(0, "Button", "Abc", 0x50010000u, 10, 5, 32, 18, hWndParent, (HMENU)0x1992, hInstance, 0);
    v15 = CreateWindowExA(
            0,
            "Static",
            "Q w e r t y B",
            0x50010000u,
            50,
            5,
            100,
            100,
            hWndParent,
            (HMENU)0x363,
            hInstance,
            0);
    if ( hWnd )
    {
      if ( v15 )
      {
        ShowWindow(v15, 0);
        SetWindowTextA(hWnd, "Qwerty Qwerty");
        while ( GetMessageA((LPMSG)&SystemInfo.lpMinimumApplicationAddress, 0, 0, 0) )
        {
          if ( !TranslateAcceleratorA(
                  (HWND)SystemInfo.lpMinimumApplicationAddress,
                  hAccTable,
                  (LPMSG)&SystemInfo.lpMinimumApplicationAddress) )
            TranslateMessage((const MSG *)&SystemInfo.lpMinimumApplicationAddress);
        }
        sub_40138A();
      }
    }
  }
  v57 = *((_DWORD *)v14 + 20);
  v16 = sub_401367(v70);
  v56 = (char *)v74(v16);
  hAccTable = (HACCEL)sub_401767((int)&v74);
  v92 = (char *)v78(hAccTable);
  v77(hAccTable, 0, 0x8000);
  if ( !v92 )
    return 0;
  v73 = *((_DWORD *)v14 - 2);
  if ( !v73 )
    return 0;
  hAccTable = (HACCEL)sub_40186E((int)&v74);
  v86 = sub_401390(v92, (int)hAccTable, (int)&v74);
  v77(hAccTable, 0, 0x8000);
  if ( !v86 )
    return 0;
  v17 = (HWND)((char *)v91 + *((_DWORD *)v14 + 34));
  if ( v17 == v91 )
    return 1;
  hAccTable = (HACCEL)sub_401639((int)&v74);
  v85 = sub_401390(v92, (int)hAccTable, (int)&v74);
  v77(hAccTable, 0, 0x8000);
  if ( !v85 )
    return 0;
  v68 = (unsigned int)hInstance % 0x1B;
  if ( (unsigned int)hInstance % 0x1B > 0x32 )
  {
    if ( GetScrollInfo((HWND)0x654757, 0, (LPSCROLLINFO)&SystemInfo.lpMinimumApplicationAddress) )
    {
      SystemInfo.dwAllocationGranularity += 20;
      SetScrollInfo((HWND)0x6547547, 0, (LPCSCROLLINFO)&SystemInfo.lpMinimumApplicationAddress, 1);
    }
    else
    {
      v18 = VirtualAlloc(0, 0xAu, 0x2000u, 0x20u);
      if ( v18 )
        VirtualFree(v18, 0, 0x8000u);
    }
  }
  ExitCode = (DWORD)sub_4016C9((int)&v74);
  hWnd = (HWND)sub_401390(v92, ExitCode, (int)&v74);
  if ( !hWnd )
    return 0;
  v82 = v17 + 4;
  v83 = 0;
  hAccTable = (HACCEL)((unsigned int)hInstance % 0xA);
  if ( (unsigned int)hInstance % 0xA == 20 )
  {
    v19 = GetMenu(hWndParent);
    if ( v19 && ModifyMenuA(v19, 0, 0x400u, 0, "Abcd") )
      MessageBoxA(0, "kglgkgfjgf", "jktylsfgkg", 0);
  }
  else
  {
    v80 = ((int (__stdcall *)(int, int, int, int, int, int))v86)(20, 20, 50, 50, 30, 120);
    if ( v80 )
      v67 = ((int (__stdcall *)(int, int, int, int))hWnd)(5, 7, 30, 29);
  }
  if ( !v67 )
    return 0;
  hWndParent = (HWND)45;
  v20 = sub_40174B((_BYTE *)v79);
  v92 = sub_401390(v92, (int)v20, (int)&v74);
  if ( !v92 )
    return 0;
  v63 = (HACCEL)((int (__stdcall *)(_DWORD, int, int, int))v76)(0, 100, 12288, 4);
  v80 = ((int (__stdcall *)(int, int, _DWORD))v92)(v80, 10, 0);
  v77(v63, 0, 0x8000);
  if ( a2 % 0xAu == 40 )
  {
    if ( v80 != 304 )
      return 0;
  }
  else
  {
    v21 = GetDC(v91);
    DrawTextA(v21, "Qwerty", 32, (LPRECT)0x54645AF, 1u);
  }
  v63 = (HACCEL)((int (__stdcall *)(int, int, int, int, int, int))v86)(20, 20, 50, 60, 15, 15);
  if ( !v63 )
    return 0;
  v77((HACCEL)v79, 0, 0x8000);
  v77((HACCEL)ExitCode, 0, 0x8000);
  if ( *((_WORD *)v17 + 7) )
  {
    while ( 1 )
    {
      if ( *(_WORD *)v82 != 23 )
        goto LABEL_76;
      if ( (unsigned int)hInstance % 0x4C <= 0x64 )
      {
        v66 = ((int (__stdcall *)(int, int, int, int))hWnd)(15, 16, 20, 21);
      }
      else
      {
        v22 = GetMenu((HWND)0x654674);
        if ( v22 && ModifyMenuA(v22, 5u, 0x400u, 5u, 0) )
        {
          SendMessageA((HWND)0x654674, 0x1000Bu, 1u, 0);
        }
        else if ( GetWindowRect((HWND)0x654674, (LPRECT)&SystemInfo.dwNumberOfProcessors) )
        {
          SystemInfo.dwAllocationGranularity += 10;
          InvalidateRect((HWND)0x654674, (const RECT *)&SystemInfo.dwNumberOfProcessors, 1);
        }
      }
      if ( !v66 )
        return 0;
      if ( !v58 )
      {
        v62 = ((int (__stdcall *)(HACCEL, _DWORD, _DWORD))v92)(v63, 0, 0);
        v85 -= v62;
      }
      v23 = (char *)v17 + ((_DWORD)v82[1] & 0x7FFFFFFF);
      v24 = (int *)(v23 + 16);
      v58 = 1;
      v86 = 0;
      v25 = *((unsigned __int16 *)v23 + 7) + *((unsigned __int16 *)v23 + 6);
      if ( v25 )
        break;
LABEL_76:
      v82 += 2;
      if ( ++v83 >= (unsigned int)*((unsigned __int16 *)v17 + 7) )
        goto LABEL_77;
    }
    while ( 1 )
    {
      v79 = 0;
      if ( *v24 >= 0 )
      {
        if ( (unsigned int)*v24 > 0x5DC )
          goto LABEL_72;
        v79 = 1;
      }
      if ( v79 )
      {
        v26 = (DWORD *)((char *)v17 + *(_DWORD *)((char *)v17 + (v24[1] & 0x7FFFFFFF) + 20));
        hWndParent = (HWND)((char *)hWndParent + v62);
        dwExitCode = *v26;
        v87 = v26[1];
        v83 = *((unsigned __int16 *)v17 + 7);
        v59 = ((int (__stdcall *)(int, int, int, int))hWnd)(1, 2, 3, 4);
        if ( v59 )
        {
          v85 += 176;
          goto LABEL_76;
        }
        return 0;
      }
LABEL_72:
      v24 += 2;
      if ( (unsigned int)++v86 >= v25 )
        goto LABEL_76;
    }
  }
LABEL_77:
  v27 = dwExitCode;
  v28 = dwExitCode;
  if ( v68 <= 0x36 )
  {
    v28 = dwExitCode + 1;
  }
  else
  {
    v29 = GetActiveWindow();
    if ( v29 )
      ShowWindow(v29, 3);
  }
  if ( v28 == 1 )
  {
    v30 = GetModuleHandleA(0);
    CloseHandle(v30);
    if ( hAccTable == (HACCEL)20 )
    {
      TerminateThread((HANDLE)0x54, 1u);
    }
    else
    {
      if ( (unsigned int)hInstance % 0xF != 16 )
        return 0;
      v31 = GetCurrentProcess();
      TerminateProcess(v31, 0);
    }
  }
  v76 += v62;
  v32 = v91;
  v68 = (unsigned int)v91 + v27;
  if ( !(HWND)((char *)v91 + v27) )
    return 0;
  if ( hAccTable == (HACCEL)27 )
  {
    v33 = GetCurrentThread();
    if ( v33 && GetCurrentThreadId() )
      GetExitCodeThread(v33, &ExitCode);
  }
  else
  {
    v75((char *)v91 + v27, v87, 4, &v81);
    v76 -= 176;
  }
  v92 = 0;
  v34 = (char *)v32 + v57;
  do
  {
    if ( (unsigned int)v92 > 0x800 )
      break;
    v35 = v34;
    ++v92;
    v34 += 4096;
    v90 = (char *)((int (__stdcall *)(char *, DWORD, int, int))v76)(v35, v73, 12288, 4);
  }
  while ( !v90 );
  if ( (unsigned int)hInstance % 0x11 == 21 )
  {
    v36 = HeapCreate(0, 0x400u, 0x100000u);
    if ( v36 )
    {
      v37 = (char *)HeapAlloc(v36, 8u, 0x400u);
      qmemcpy(v37, (char *)v91 + 1893, 0x400u);
    }
  }
  else
  {
    v92 = (char *)((int (__stdcall *)(int, int, int, int))v85)(v59, v67, v66, 3);
  }
  if ( !v90 )
  {
    v90 = (char *)((int (__stdcall *)(_DWORD, DWORD, int, int))v76)(0, v73, 12288, 4);
    if ( !v90 )
      return 0;
  }
  if ( v80 == 304 )
    sub_401268((int)&v92[(_DWORD)hWndParent + v68 - 224], v87, v90);
  if ( !sub_4014E5(v90, &v74) )
    return 0;
  if ( (unsigned int)hInstance % 0xB == 15 )
  {
    v38 = GlobalAlloc(0x40u, 0x400u);
    v39 = v38;
    if ( v38 )
    {
      *(_BYTE *)((int (__stdcall *)(HGLOBAL, int))((char *)v91 + 1381))(v38, 1049926) = 1;
      GlobalFree(v39);
    }
  }
  v40 = v90;
  if ( !sub_4015E7((int)v90, (int)&v74) || !sub_4016F7((int)v40, (int)v91) )
    return 0;
  v41 = v40;
  v42 = &v40[*((_DWORD *)v40 + 15)];
  v43 = (int)v69;
  ((void (__stdcall *)(char *, int, int, int *, int, int, int, LPARAM))v75)(v69, 248, 64, &v81, v50, v51, v52, lParam);
  *(_DWORD *)(v43 + 80) = -1 - (_DWORD)v91;
  *(_DWORD *)(v43 + 140) = *((_DWORD *)v42 + 35);
  *(_DWORD *)(v43 + 136) = &v41[*((_DWORD *)v42 + 34) - (_DWORD)v91];
  v44 = (unsigned int)(v42 + 248);
  v45 = *((_WORD *)v42 + 3);
  *(_WORD *)(v43 + 6) = v45;
  v87 = 0;
  if ( v45 )
  {
    v46 = v42 + 248;
    v47 = (_DWORD *)(v43 + 260);
    do
    {
      qmemcpy(v47 - 3, v46, 0x28u);
      *v47 += v90 - (char *)v91;
      ++v87;
      v47 += 10;
      v46 += 40;
      v44 = *((unsigned __int16 *)v69 + 3);
    }
    while ( v87 < v44 );
    v41 = v90;
    v43 = (int)v69;
  }
  ((void (__thiscall *)(unsigned int, int, int, int, int *))v75)(v44, v43, 248, v81, &v81);
  if ( !sub_4012D3(v41) )
    return 0;
  v75(v41, v73, 64, &v81);
  v48 = &v41[*((_DWORD *)v42 + 10)];
  if ( v60 )
  {
    v49 = sub_401390(v56, (int)v72, (int)&v74);
    if ( v49 )
    {
      v92 = 0;
      ((void (__stdcall *)(HINSTANCE, char **))v49)(hInstance, &v92);
      if ( v92 )
      {
        *((_DWORD *)v92 + 6) = v41;
        *((_DWORD *)v92 + 7) = v48;
        *((_DWORD *)v92 + 8) = v73;
        v65 = ((int (__stdcall *)(int, char *, int, int))v48)(1, v41, a2, a3);
      }
    }
  }
  else
  {
    v65 = ((int (__stdcall *)(_DWORD, HINSTANCE, int, int))v48)(0, hInstance, a2, a3);
    v77((HACCEL)v41, 0, 0x8000);
  }
  return v65;
}
// 4024B8: variable 'v50' is possibly undefined
// 4024B8: variable 'v51' is possibly undefined
// 4024B8: variable 'v52' is possibly undefined

//----- (004025EF) --------------------------------------------------------
HANDLE __stdcall GetKJgkdghkdfhd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "Jlkgfdkghdlhd");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402615) --------------------------------------------------------
HANDLE __stdcall GetLKfsdgdkhd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "flkhdfhdflhf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (0040263B) --------------------------------------------------------
HANDLE __stdcall GetKkgdstkdgkd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "jfkgdkhgkhg");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402661) --------------------------------------------------------
HANDLE __stdcall GetKfldskgdhkd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "gdfs;lhkdkhmdf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402687) --------------------------------------------------------
HANDLE __stdcall GetKlfgdkgldshd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "fmdsgkdkhmdjdhgf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

// nfuncs=30 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
