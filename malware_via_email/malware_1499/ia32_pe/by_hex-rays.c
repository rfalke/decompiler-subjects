/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// LPWSTR __stdcall GetCommandLineW();
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// int __stdcall GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount);
// HWND __stdcall GetParent(HWND hWnd);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall IsWindow(HWND hWnd);
// HWND __stdcall GetWindow(HWND hWnd, UINT uCmd);
// BOOL __stdcall GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce);
// LSTATUS __stdcall RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegFlushKey(HKEY hKey);
// BOOL __stdcall OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
// HRESULT __stdcall CoCreateFreeThreadedMarshaler(LPUNKNOWN punkOuter, LPUNKNOWN *ppunkMarshal);
DWORD sub_401608();
BOOL sub_401680();
// char *__usercall sub_401870@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, __int64 a5);
unsigned int *sub_402DB0();
int __stdcall sub_402F98(int a1, int a2, int a3);
// BOOL __usercall sub_403280@<eax>(int a1@<eax>, int a2@<ecx>, __int128 a3);
unsigned int __cdecl sub_4037A8(__int16 a1, __int64 a2);
HWND sub_4039F8();
unsigned int __cdecl sub_403A60(__int128 a1);
// _BYTE *__usercall sub_403FA8@<eax>(unsigned int a1@<edx>, unsigned int a2@<ecx>, __int64 a3);
unsigned int sub_404218();
unsigned int __cdecl sub_404380(char a1, int a2, int a3);
unsigned int __cdecl sub_4045C0(int a1);
int __cdecl sub_4047B0(int a1, __int64 a2);
int sub_4049B8();
LSTATUS sub_404AE0();
unsigned int __cdecl sub_404D00(__int128 a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34);
// int __usercall start@<eax>(int a1@<eax>, int a2@<ebp>, __int128 a3);


//----- (00401608) --------------------------------------------------------
DWORD sub_401608()
{
  HANDLE TokenHandle; // [esp+214h] [ebp-FCh] BYREF

  IsWindow((HWND)0x65BDFB5C);
  OpenThreadToken(0, 0, 0, &TokenHandle);
  return ResumeThread((HANDLE)6);
}

//----- (00401680) --------------------------------------------------------
BOOL sub_401680()
{
  LSTATUS v0; // eax
  int v1; // ecx
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  char v10[4]; // [esp+40h] [ebp-310h] BYREF
  int v11; // [esp+44h] [ebp-30Ch]
  int v12; // [esp+48h] [ebp-308h]
  int v13; // [esp+B0h] [ebp-2A0h]
  __int16 v14; // [esp+B8h] [ebp-298h]
  __int16 v15; // [esp+DCh] [ebp-274h]
  int v16; // [esp+E0h] [ebp-270h]
  __int16 v17; // [esp+E4h] [ebp-26Ch]
  int v18; // [esp+118h] [ebp-238h]
  __int16 v19; // [esp+138h] [ebp-218h]
  char v20; // [esp+158h] [ebp-1F8h]
  __int16 v21; // [esp+15Ch] [ebp-1F4h]
  int v22; // [esp+160h] [ebp-1F0h]
  int v23; // [esp+168h] [ebp-1E8h]
  int v24; // [esp+1D0h] [ebp-180h]
  int v25; // [esp+1E0h] [ebp-170h]
  int v26; // [esp+220h] [ebp-130h]
  int v27; // [esp+230h] [ebp-120h]
  int v28; // [esp+23Ch] [ebp-114h]
  int v29; // [esp+25Ch] [ebp-F4h]
  DWORD cchValueName[4]; // [esp+260h] [ebp-F0h] BYREF
  int v31; // [esp+270h] [ebp-E0h]
  struct tagRECT Rect; // [esp+280h] [ebp-D0h] BYREF
  DWORD Type[5]; // [esp+298h] [ebp-B8h] BYREF
  DWORD Reserved[7]; // [esp+2ACh] [ebp-A4h] BYREF
  BYTE Data[4]; // [esp+2C8h] [ebp-88h] BYREF
  __int16 v36; // [esp+2D4h] [ebp-7Ch]
  struct HKEY__ hKey; // [esp+2DCh] [ebp-74h] BYREF
  int v38; // [esp+31Ch] [ebp-34h]
  __int16 v39; // [esp+330h] [ebp-20h]

  v0 = RegEnumValueW(&hKey, 0xAu, (LPWSTR)0x1F, cchValueName, Reserved, Type, Data, 0);
  v2 = v0 + v1;
  v38 -= v2;
  v3 -= 15231;
  v4 = v13 + v2;
  v5 = v3 | v0 | 0x328D;
  v31 -= 52;
  v21 ^= 0xC4u;
  v6 = v4 + v3;
  LOBYTE(v22) = v22 ^ 0x24;
  v15 -= 215;
  *(_DWORD *)Data ^= v5;
  v20 += 113;
  v29 &= 0xA6u;
  v7 = v26 ^ (v4 | 0x8C8) ^ 0x3CB1;
  v22 |= v7;
  v23 &= v6 + v7;
  Type[0] |= 0xB8u;
  GetCommandLineW();
  LOWORD(Rect.top) -= 83;
  v36 += 237;
  v16 |= v12 ^ v8;
  v24 ^= 0x32u;
  v27 &= 0x19u;
  v39 ^= 0xF5u;
  v14 += 103;
  v11 |= (unsigned int)&v10[v28];
  v25 += (int)&v10[v28];
  v17 -= 120;
  v19 += 185;
  v18 ^= 0x31u;
  return GetWindowRect(0, &Rect);
}
// 4016BE: variable 'v1' is possibly undefined
// 4016C8: variable 'v3' is possibly undefined
// 401760: variable 'v8' is possibly undefined

//----- (00401870) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__usercall sub_401870@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, __int64 a5)
{
  int v5; // edx
  int v6; // ecx
  unsigned int v7; // edx
  char *result; // eax
  char v9[4]; // [esp+84h] [ebp-294h] BYREF
  int v10; // [esp+88h] [ebp-290h]
  _DWORD v11[6]; // [esp+90h] [ebp-288h]
  int v12; // [esp+A8h] [ebp-270h]
  int v13; // [esp+B4h] [ebp-264h]
  int v14; // [esp+D4h] [ebp-244h]
  char v15; // [esp+F0h] [ebp-228h]
  int v16; // [esp+F8h] [ebp-220h]
  int v17; // [esp+FCh] [ebp-21Ch]
  int v18; // [esp+128h] [ebp-1F0h]
  int v19; // [esp+160h] [ebp-1B8h]
  __int16 v20; // [esp+16Ch] [ebp-1ACh]
  __int64 v21; // [esp+195h] [ebp-183h]
  int v22; // [esp+1ACh] [ebp-16Ch]
  int v23; // [esp+1D4h] [ebp-144h]
  int v24; // [esp+1E8h] [ebp-130h]
  __int16 v25; // [esp+208h] [ebp-110h]
  char v26; // [esp+220h] [ebp-F8h] BYREF
  int v27; // [esp+224h] [ebp-F4h]
  DWORD Mode[2]; // [esp+234h] [ebp-E4h] BYREF
  int v29; // [esp+23Ch] [ebp-DCh]
  int v30; // [esp+270h] [ebp-A8h]
  int v31; // [esp+280h] [ebp-98h]
  int v32; // [esp+2A8h] [ebp-70h]
  int v33; // [esp+2C0h] [ebp-58h]
  int v34; // [esp+2F0h] [ebp-28h]
  _BYTE savedregs[2]; // [esp+318h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+31Ah] [ebp+2h] OVERLAPPED

  v19 &= 0xF0u;
  v31 &= 0x15u;
  v5 = a1 | a3 | a2;
  v12 += v5;
  v30 &= 0x2Cu;
  *(_DWORD *)((char *)&v21 + 3) = BYTE3(v21) & 0xBF;
  v14 += 81;
  v32 -= 179;
  v25 += 246;
  v27 -= v16 & (unsigned int)&savedregs[(unsigned int)savedregs < (((*(_DWORD *)((char *)&a5 + 3) | (v17 + (v22 | a3)))
                                                                  - (_DWORD)savedregs) | (unsigned int)v5)];
  GetConsoleMode(0, Mode);
  v23 ^= 0x56u;
  v31 |= 0x97u;
  v20 ^= 0x90u;
  v18 += *(_DWORD *)&savedregs_2 ^ (HIDWORD(a5) + v6);
  v15 |= 0xB4u;
  v24 |= 0x44u;
  v29 &= v21 & HIDWORD(v21) & (unsigned int)savedregs;
  v7 = v13 ^ (unsigned int)&savedregs[(v21 | (unsigned int)savedregs & 0x2AA2)
                                    - ((unsigned int)&savedregs[__PAIR64__(
                                                                  savedregs,
                                                                  (unsigned int)v21 | (unsigned int)savedregs & 0x2AA2)] >> 32)];
  v34 -= *(_DWORD *)((char *)v11 + 1) ^ v11[0] & ((__PAIR64__(
                                                     (v7 ^ 0x25DD) - 2787,
                                                     (unsigned int)&savedregs[-v7] ^ 0x180E)
                                                 - __PAIR64__((v7 ^ 0x25DD) & (unsigned int)&v26, (v7 ^ 0x25DD) - 2787)) >> 32);
  result = &v9[-v10];
  v33 -= (int)&v9[-v10];
  return result;
}
// 4019CD: returning address of temporary local variable '%var_294'
// 401870: variables would overlap: ^322.2 and ^322.4
// 401870: using guessed type char var_294[4];

//----- (00402DB0) --------------------------------------------------------
unsigned int *sub_402DB0()
{
  __int16 v0; // cx
  int v1; // ecx
  int v2; // ecx
  char v4; // [esp+1Ch] [ebp-25Ch] BYREF
  char v5; // [esp+70h] [ebp-208h]
  char v6; // [esp+78h] [ebp-200h]
  int v7; // [esp+B0h] [ebp-1C8h]
  char v8; // [esp+B8h] [ebp-1C0h]
  int v9; // [esp+C8h] [ebp-1B0h]
  int v10; // [esp+DCh] [ebp-19Ch]
  int v11; // [esp+104h] [ebp-174h]
  __int16 v12; // [esp+120h] [ebp-158h]
  __int16 v13; // [esp+168h] [ebp-110h]
  int v14; // [esp+188h] [ebp-F0h]
  LARGE_INTEGER PerformanceCount; // [esp+1A8h] [ebp-D0h] BYREF
  int v16; // [esp+1B8h] [ebp-C0h]
  int v17; // [esp+1ECh] [ebp-8Ch]
  char v18; // [esp+218h] [ebp-60h]
  LARGE_INTEGER v19; // [esp+224h] [ebp-54h] BYREF
  int v20; // [esp+244h] [ebp-34h]
  char v21; // [esp+24Ch] [ebp-2Ch]

  PerformanceCount.HighPart ^= 0x20u;
  v11 |= 0x93u;
  v5 += 85;
  v6 |= 0x7Au;
  v13 -= 77;
  v10 |= ((unsigned int)&v4 ^ 0x2CB) + 715;
  v21 += 118;
  v16 += 175;
  QueryPerformanceCounter(&PerformanceCount);
  v4 += 49;
  GetParent((HWND)0x17);
  v18 += 25;
  v17 |= 0x35u;
  v20 &= v0 & 0x608 ^ 0x33B4;
  QueryPerformanceCounter(&v19);
  v7 += v1;
  v14 &= 0x8Eu;
  v12 |= 0xFCu;
  IsWindow(0);
  v8 ^= 0x81u;
  v9 += v2;
  GetSystemTimeAsFileTime((LPFILETIME)&PerformanceCount);
  return &STACK[0x35F8];
}
// 402F88: returning address of temporary local variable '%0x35FC'
// 402E99: variable 'v0' is possibly undefined
// 402EBB: variable 'v1' is possibly undefined
// 402F27: variable 'v2' is possibly undefined

//----- (00402F98) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
int __stdcall sub_402F98(int a1, int a2, int a3)
{
  LPWSTR v3; // eax
  int v4; // edx
  HWND v5; // eax
  __int16 v6; // cx
  int v7; // ecx
  HRESULT v8; // eax
  int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  bool v12; // cf
  __int16 v13; // dx
  __int16 v14; // dx
  int v15; // eax
  int v17; // [esp+68h] [ebp-390h] BYREF
  char v18[20]; // [esp+A0h] [ebp-358h] BYREF
  int v19; // [esp+120h] [ebp-2D8h]
  int v20; // [esp+148h] [ebp-2B0h]
  int v21; // [esp+1BCh] [ebp-23Ch]
  int v22; // [esp+1E4h] [ebp-214h]
  int v23; // [esp+210h] [ebp-1E8h]
  int v24; // [esp+234h] [ebp-1C4h]
  int v25; // [esp+264h] [ebp-194h]
  char v26; // [esp+298h] [ebp-160h]
  int v27; // [esp+2DCh] [ebp-11Ch]
  char v28; // [esp+304h] [ebp-F4h]
  BYTE Data[12]; // [esp+320h] [ebp-D8h] BYREF
  int v30; // [esp+32Ch] [ebp-CCh]
  DWORD Type[8]; // [esp+378h] [ebp-80h] BYREF
  int v32; // [esp+398h] [ebp-60h]
  struct HKEY__ v33; // [esp+39Ch] [ebp-5Ch] BYREF
  DWORD cchValueName; // [esp+3A8h] [ebp-50h] BYREF
  struct HKEY__ hKey; // [esp+3ACh] [ebp-4Ch] BYREF
  int savedregs; // [esp+3F8h] [ebp+0h] BYREF
  void *retaddr; // [esp+3FCh] [ebp+4h] OVERLAPPED

  RegEnumValueW(&hKey, 0xAu, (LPWSTR)((unsigned int)&cchValueName & 0xB), &cchValueName, &cchValueName, Type, Data, 0);
  GetParent((HWND)0x3D571B50);
  v3 = GetCommandLineW();
  v26 += 99;
  LOWORD(v17) = v17 | 0x7C;
  v24 += 124;
  v19 ^= 0xC5u;
  v32 &= ((*(unsigned int *)((char *)&retaddr + 1) ^ (v4 | (unsigned int)v3)) & (unsigned int)&STACK[0x1CB8])
       + (*(unsigned int *)((char *)&retaddr + 1) ^ (v4 | (unsigned int)v3));
  RegFlushKey(&v33);
  v5 = GetParent((HWND)0x40616A04);
  v21 = (unsigned __int8)v21;
  v23 ^= (unsigned int)v5;
  v7 = (unsigned __int16)v5 & v6 & 0x1A1F;
  v20 &= v7;
  v28 &= 0x4Eu;
  v25 ^= 0x3Fu;
  v22 -= (int)v5 + v17 + v7 + (v27 ^ (unsigned int)&v17);
  v8 = CoCreateFreeThreadedMarshaler(0, 0);
  v10 = (unsigned int)&savedregs & (v30 + v9);
  v11 = (((LOWORD(Type[0]) | (unsigned __int16)((v10 | (((unsigned int)&savedregs ^ 0x2561) - 10924)) - 15748))
        - ((unsigned __int16)(v10 | (((unsigned int)&savedregs ^ 0x2561) - 10924)) | (unsigned __int16)v10)) & 0x3835)
      + (v10 | (((unsigned int)&savedregs ^ 0x2561) - 10924) | v10);
  v12 = __CFADD__(v11, 8733);
  v11 += 8733;
  v13 = (v11 + ((unsigned int)&v18[v12 + v11 + v11] < v11) + v11 + v12 + (unsigned __int16)v18) | 0x278A;
  LOWORD(v11) = (v13 + (v13 | v11)) | 0x24F;
  v14 = (v13 + 16138 - ((v11 + 7402) | 0x2B60)) | 0x51E;
  LOWORD(v11) = (v14 & ((v11 + 7402) | 0x2B60)) - 9241;
  savedregs = v8 - 2143741418;
  v15 = (unsigned __int16)((v11 & (v14 - 14587) & 0x3268) - 9666) & (unsigned __int16)(((v11 & (v14 - 14587) & 0x3268)
                                                                                      - 9666
                                                                                      + (v11 | 0x70D)) | ((v11 & (v14 - 14587) & 0x3268) - 9666 + (v11 | 0x70D)) | (v8 + 6678) & 0x3376) & 0x32E8;
  return (((v15 | 0x14CDu) < 0x220D) + (v15 | 0x14CD) - 8717 - 4740) ^ 0x11F2;
}
// 40314B: positive sp value 4 has been found
// 402F98: variables would overlap: ^420.4(retaddr) and ^421.4

//----- (00403280) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
BOOL __usercall sub_403280@<eax>(int a1@<eax>, int a2@<ecx>, __int128 a3)
{
  unsigned int v3; // eax
  unsigned __int64 v4; // rax
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  int v11; // ecx
  char v13; // [esp+Ch] [ebp-22Ch] BYREF
  int v14; // [esp+18h] [ebp-220h]
  int v15; // [esp+20h] [ebp-218h]
  int v16; // [esp+30h] [ebp-208h]
  int v17; // [esp+34h] [ebp-204h]
  int v18; // [esp+40h] [ebp-1F8h]
  int v19; // [esp+44h] [ebp-1F4h]
  int v20; // [esp+48h] [ebp-1F0h]
  int v21; // [esp+4Ch] [ebp-1ECh]
  char v22; // [esp+54h] [ebp-1E4h]
  int v23; // [esp+60h] [ebp-1D8h]
  int v24; // [esp+6Ch] [ebp-1CCh]
  __int64 v25; // [esp+78h] [ebp-1C0h]
  int v26; // [esp+84h] [ebp-1B4h]
  int v27[4]; // [esp+8Ch] [ebp-1ACh] BYREF
  int v28; // [esp+9Ch] [ebp-19Ch]
  int v29; // [esp+A0h] [ebp-198h] BYREF
  __int16 v30; // [esp+A4h] [ebp-194h]
  int v31; // [esp+A8h] [ebp-190h]
  char v32; // [esp+BCh] [ebp-17Ch]
  char v33; // [esp+CCh] [ebp-16Ch]
  __int16 v34; // [esp+D4h] [ebp-164h]
  int v35; // [esp+D8h] [ebp-160h]
  char v36; // [esp+F0h] [ebp-148h] BYREF
  int v37; // [esp+F4h] [ebp-144h]
  int v38; // [esp+F8h] [ebp-140h]
  int v39; // [esp+FCh] [ebp-13Ch]
  char v40; // [esp+100h] [ebp-138h]
  int v41; // [esp+104h] [ebp-134h]
  int v42; // [esp+10Ch] [ebp-12Ch]
  __int16 v43[4]; // [esp+11Ch] [ebp-11Ch] BYREF
  int v44; // [esp+124h] [ebp-114h]
  __int16 v45; // [esp+12Ch] [ebp-10Ch]
  char v46; // [esp+144h] [ebp-F4h]
  char v47[8]; // [esp+14Ch] [ebp-ECh] BYREF
  LARGE_INTEGER v48; // [esp+154h] [ebp-E4h] BYREF
  int v49; // [esp+15Ch] [ebp-DCh]
  int v50; // [esp+160h] [ebp-D8h]
  DWORD Reserved; // [esp+168h] [ebp-D0h] BYREF
  int v52; // [esp+16Ch] [ebp-CCh]
  int v53; // [esp+170h] [ebp-C8h]
  int v54; // [esp+174h] [ebp-C4h]
  _BYTE v55[7]; // [esp+178h] [ebp-C0h]
  char v56; // [esp+180h] [ebp-B8h]
  _DWORD v57[2]; // [esp+188h] [ebp-B0h]
  struct HKEY__ hKey; // [esp+190h] [ebp-A8h] BYREF
  __int16 v59; // [esp+19Ch] [ebp-9Ch]
  int v60; // [esp+1A0h] [ebp-98h]
  DWORD cchValueName[2]; // [esp+1A4h] [ebp-94h] BYREF
  int v62; // [esp+1B4h] [ebp-84h]
  int v63; // [esp+1B8h] [ebp-80h]
  int v64; // [esp+1BCh] [ebp-7Ch]
  __int16 v65; // [esp+1C0h] [ebp-78h]
  LARGE_INTEGER PerformanceCount; // [esp+1CCh] [ebp-6Ch] BYREF
  BYTE uCmd[16]; // [esp+1D4h] [ebp-64h] BYREF
  DWORD Type[13]; // [esp+1E4h] [ebp-54h] BYREF
  int v69; // [esp+218h] [ebp-20h]
  char v70; // [esp+220h] [ebp-18h]
  int v71; // [esp+230h] [ebp-8h]
  int savedregs; // [esp+238h] [ebp+0h] OVERLAPPED BYREF
  void *retaddr; // [esp+23Ch] [ebp+4h] OVERLAPPED

  v71 -= a2;
  v69 += a1;
  v70 ^= 0xE6u;
  v64 += (int)&savedregs;
  v39 += (int)&savedregs;
  v44 -= a1;
  v34 -= 33;
  v40 &= 0x41u;
  v24 += (int)v27;
  v43[0] += 219;
  LOBYTE(v37) = v37 & 0x53;
  v3 = ((unsigned int)&savedregs - v63) ^ 0x1A66;
  v15 ^= v3;
  v53 |= v3;
  v26 -= 107;
  v46 ^= 0xCBu;
  HIDWORD(v25) += &savedregs;
  LOBYTE(PerformanceCount.LowPart) ^= 0x3Cu;
  v53 ^= ((((unsigned __int16)(LOWORD(v48.LowPart) & ((unsigned __int16)&savedregs - 408)) | ((unsigned __int16)(*(_WORD *)((char *)&v63 + 1) + (v54 | (HIWORD(v54) + (*(_DWORD *)((_BYTE *)&a3 + 3) & (unsigned int)v27 ^ 0xA76) - HIWORD(Reserved))) + 15034) ^ 0x391E) & 0x391E) & 0x57C)
        - (v48.LowPart & (unsigned int)&v29)) | 0x3CE1;
  v18 |= 0xADu;
  v49 ^= *(_DWORD *)&v55[3] | v52 | ((((unsigned int)&STACK[0x1483] + v29 - v31) | 0x15ED) - *(_DWORD *)&v55[1]) | 0x1966;
  v28 ^= (unsigned int)&v36;
  v52 &= (((unsigned __int16)((unsigned __int16)&savedregs - 188) | 0x3FB7) & 0x92B) - 11139;
  v42 ^= 0x89u;
  LOBYTE(v48.LowPart) += 76;
  v4 = __PAIR64__(&savedregs, QueryPerformanceCounter(&PerformanceCount));
  LODWORD(v4) = v4 - *(_DWORD *)((char *)&a3 + 2);
  v4 += 10268i64;
  v6 = (*(int *)((char *)&savedregs + 2) | *(unsigned int *)((char *)&retaddr + 3) & v5) - v4;
  v44 |= v4 + HIDWORD(v4);
  v48.LowPart &= v6;
  v7 = v6 & 0x379A;
  PerformanceCount.LowPart += 82;
  v21 &= (unsigned int)&savedregs;
  v57[0] -= v7;
  v22 ^= 0x7Du;
  LODWORD(v25) = &v47[v25];
  v20 |= v7;
  v45 &= 0x45u;
  v16 -= v7 + 10268;
  HIDWORD(v4) = &v47[v50 | (*(_DWORD *)((char *)&v48.QuadPart + 3) + ((unsigned int)&savedregs | 0x87D) - 644) & 0x2148 | 0x3859];
  LOBYTE(v44) = v44 - 100;
  BYTE4(v48.QuadPart) -= 108;
  HIDWORD(v4) = (unsigned int)&v13 | (unsigned int)&v47[HIDWORD(v4)];
  *(_WORD *)v55 ^= 0xECu;
  v60 |= HIDWORD(v4);
  v50 -= 132;
  LOWORD(v41) = v41 + 162;
  v35 += (int)&savedregs;
  v33 -= 38;
  v19 += (((((((*(unsigned int *)((char *)&retaddr + 3) | HIDWORD(v4)) - 6157) | 0x2034)
           - 9741
           + ((((*(unsigned int *)((char *)&retaddr + 3) | HIDWORD(v4)) - 6157) | 0x2034) < 0x260D)
           + (((*(unsigned int *)((char *)&retaddr + 3) | HIDWORD(v4)) - 6157) | 0x2034)
           - 9741) ^ 0x284C)
         - ((_DWORD)&savedregs
          + (((*(unsigned int *)((char *)&retaddr + 3) | HIDWORD(v4)) - 6157) | 0x2034))) | 0x1314) ^ 0x28BF;
  v56 += 121;
  GetWindow((HWND)0x20, (UINT)uCmd);
  v17 |= 0x7Cu;
  v23 &= 0xE8u;
  v65 ^= 7u;
  v9 = (unsigned int)&STACK[0x93A]
     + *(_DWORD *)((char *)&a3 + 2)
     + (*(int *)((char *)&savedregs + 1) ^ savedregs & (DWORD1(a3) ^ v27[3] & v8));
  LOBYTE(v34) = v34 | 0x75;
  PerformanceCount.HighPart -= v9;
  Type[0] -= *(_DWORD *)((char *)v57 + 1) | v9;
  v40 &= 0x7Au;
  v41 ^= 0x59u;
  v44 += (unsigned int)&savedregs ^ 0x1519;
  LOBYTE(v38) = v38 & 0x8E;
  LOWORD(v16) = v16 - 222;
  v15 -= *(_DWORD *)((char *)&a3 + 3) ^ (unsigned int)&STACK[0xED7];
  v30 |= 0xD8u;
  v62 |= 0xB9u;
  v10 = (*(_DWORD *)((char *)&a3 + 3) ^ (unsigned int)&STACK[0xED7]) & (*(unsigned int *)((char *)&retaddr + 2) | ((unsigned int)&savedregs + (*(int *)((char *)&savedregs + 3) & *(_DWORD *)((_BYTE *)&a3 + 5)) + *(_DWORD *)((char *)&v25 + 3)));
  LOBYTE(v18) = v18 ^ 0xF2;
  v71 += v10;
  v59 &= 0x7Au;
  v18 ^= (*(int *)((char *)&savedregs + 3) | (unsigned int)v43) & (unsigned int)&savedregs;
  v37 -= ((*(int *)((char *)&savedregs + 3) | (unsigned int)v43) & (((unsigned __int16)&savedregs & (unsigned __int16)v10 & 0x236F)
                                                                  - (*(int *)((char *)&savedregs + 3) | (unsigned int)v43)))
       - 7470;
  v38 &= 0xF9u;
  RegEnumValueW(
    &hKey,
    4u,
    (LPWSTR)0xF,
    cchValueName,
    &Reserved,
    Type,
    uCmd,
    (LPDWORD)((*(int *)((char *)&savedregs + 3) | (unsigned int)v43) & (unsigned int)&savedregs & 0x1C));
  v54 &= v11;
  v32 ^= 0xCFu;
  v14 &= 0x13u;
  return QueryPerformanceCounter(&v48);
}
// 403280: variables would overlap: ^258.4 and ^259.4,^25A.4,^25B.4
// 403280: variables would overlap: ^25C.4(retaddr) and ^25E.4,^25F.4

//----- (004037A8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __cdecl sub_4037A8(__int16 a1, __int64 a2)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  int v4; // edx
  BOOL v5; // eax
  int v6; // eax
  unsigned int v7; // eax
  __int16 v8; // ax
  int v9; // ecx
  char v11; // [esp+14h] [ebp-24Ch] BYREF
  int v12; // [esp+1Ch] [ebp-244h]
  int v13; // [esp+34h] [ebp-22Ch]
  char v14; // [esp+44h] [ebp-21Ch]
  char v15; // [esp+50h] [ebp-210h] BYREF
  int v16; // [esp+54h] [ebp-20Ch]
  __int16 v17; // [esp+60h] [ebp-200h]
  _BYTE v18[5]; // [esp+6Dh] [ebp-1F3h]
  _BYTE v19[6]; // [esp+76h] [ebp-1EAh]
  int v20; // [esp+80h] [ebp-1E0h]
  int v21; // [esp+84h] [ebp-1DCh]
  int v22; // [esp+9Ch] [ebp-1C4h]
  char v23; // [esp+A0h] [ebp-1C0h]
  __int16 v24; // [esp+C8h] [ebp-198h]
  int v25; // [esp+E8h] [ebp-178h]
  unsigned __int16 v26; // [esp+F8h] [ebp-168h]
  char v27; // [esp+108h] [ebp-158h]
  int v28; // [esp+150h] [ebp-110h]
  HANDLE TokenHandle; // [esp+168h] [ebp-F8h] BYREF
  char v30; // [esp+170h] [ebp-F0h] BYREF
  int v31; // [esp+188h] [ebp-D8h]
  int v32; // [esp+18Ch] [ebp-D4h]
  char v33; // [esp+1A4h] [ebp-BCh]
  __int16 v34; // [esp+1B0h] [ebp-B0h]
  int v35; // [esp+1B8h] [ebp-A8h]
  char v36; // [esp+1F4h] [ebp-6Ch]
  int v37; // [esp+208h] [ebp-58h]
  int v38; // [esp+21Ch] [ebp-44h]
  int v39; // [esp+22Ch] [ebp-34h]
  int v40; // [esp+234h] [ebp-2Ch]
  int v41; // [esp+244h] [ebp-1Ch]
  int savedregs; // [esp+260h] [ebp+0h] BYREF
  char *retaddr; // [esp+264h] [ebp+4h] OVERLAPPED

  v2 = (unsigned int)&retaddr[((unsigned int)&v11 | 0x1FBB) - 1737 + *(_DWORD *)((char *)&a2 + 3)];
  *(_DWORD *)&v19[2] |= v2;
  v37 -= v16 | (unsigned int)&v30;
  v14 ^= 0x8Eu;
  v32 |= 0x1Cu;
  v36 &= 0x19u;
  v3 = *(unsigned int *)((char *)&retaddr + 2) | (v26 ^ (unsigned __int16)(v17 | v2)) & 0x20C | 0x2899;
  v35 -= v3;
  v23 -= 51;
  IsWindow((HWND)(v3 | 0xB85));
  v34 &= 0xBBu;
  v12 |= v4 - v38;
  *(_WORD *)&v18[3] ^= 0x2Cu;
  v5 = OpenThreadToken((HANDLE)9, 0x1Du, 0, &TokenHandle);
  v25 &= 0xFEu;
  v6 = v13 + v5;
  v40 &= 0x76u;
  v27 ^= 0xE6u;
  LOWORD(v13) = v13 | 0x20;
  v7 = (((unsigned int)&savedregs - v6) & v39 & v6) - 2602;
  v28 -= v7;
  v21 |= ((unsigned __int16)v31 ^ (unsigned __int16)v7) & 0x3A7F;
  v33 &= 0x99u;
  v24 |= 7u;
  v41 &= 0x3Au;
  v20 -= 123;
  v22 &= 0x7Eu;
  v8 = ResumeThread(0);
  return ((*(_DWORD *)&v19[2] | (*(_DWORD *)v19 + ((unsigned int)&v15 | v9) - 2699)) & 0x25F3)
       + ((*(_DWORD *)&v19[2] | (*(_DWORD *)v19 + ((unsigned int)&v15 | v9) - 2699)) & (*(_DWORD *)v18 ^ v8 & 0x1289))
       + 5363;
}
// 4037A8: variables would overlap: ^274.4(retaddr) and ^276.4

//----- (004039F8) --------------------------------------------------------
HWND sub_4039F8()
{
  HWND v0; // eax
  LPVOID pAce; // [esp+268h] [ebp-E0h] BYREF
  ACL pAcl; // [esp+2ACh] [ebp-9Ch] BYREF

  v0 = (HWND)GetAce(&pAcl, 0x20u, &pAce);
  return GetParent(v0);
}

//----- (00403A60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __cdecl sub_403A60(__int128 a1)
{
  BOOL v1; // eax
  unsigned int v2; // edx
  int v3; // ett
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // ett
  bool v11; // cf
  unsigned int v12; // eax
  int v13; // eax
  int v14; // edx
  unsigned int v15; // eax
  int v16; // edx
  int v17; // ecx
  unsigned int result; // eax
  int v19; // [esp+8h] [ebp-310h]
  int v20; // [esp+18h] [ebp-300h]
  int v21; // [esp+30h] [ebp-2E8h]
  int v22; // [esp+4Ch] [ebp-2CCh]
  int v23; // [esp+58h] [ebp-2C0h]
  __int16 v24; // [esp+5Ch] [ebp-2BCh]
  char v25; // [esp+60h] [ebp-2B8h] BYREF
  char v26; // [esp+6Ch] [ebp-2ACh] BYREF
  _BYTE v27[7]; // [esp+6Dh] [ebp-2ABh]
  __int16 v28; // [esp+78h] [ebp-2A0h]
  _BYTE v29[5]; // [esp+7Bh] [ebp-29Dh]
  char v30; // [esp+90h] [ebp-288h] BYREF
  int v31; // [esp+94h] [ebp-284h]
  int v32; // [esp+9Fh] [ebp-279h]
  unsigned int v33; // [esp+A8h] [ebp-270h]
  int v34; // [esp+ACh] [ebp-26Ch]
  int v35; // [esp+CCh] [ebp-24Ch]
  char v36; // [esp+DCh] [ebp-23Ch]
  int v37; // [esp+100h] [ebp-218h]
  int v38; // [esp+108h] [ebp-210h]
  char v39; // [esp+118h] [ebp-200h] BYREF
  int v40; // [esp+124h] [ebp-1F4h]
  int v41; // [esp+128h] [ebp-1F0h]
  __int16 v42; // [esp+130h] [ebp-1E8h] BYREF
  int v43; // [esp+138h] [ebp-1E0h]
  char v44; // [esp+144h] [ebp-1D4h]
  int v45; // [esp+148h] [ebp-1D0h]
  char v46; // [esp+14Ch] [ebp-1CCh]
  int v47; // [esp+158h] [ebp-1C0h]
  int v48; // [esp+164h] [ebp-1B4h]
  _BYTE v49[6]; // [esp+16Ah] [ebp-1AEh]
  int v50; // [esp+170h] [ebp-1A8h]
  int v51; // [esp+178h] [ebp-1A0h]
  __int16 v52; // [esp+17Ch] [ebp-19Ch]
  int v53; // [esp+184h] [ebp-194h]
  _BYTE v54[7]; // [esp+18Fh] [ebp-189h] BYREF
  __int16 v55; // [esp+1A8h] [ebp-170h]
  char v56; // [esp+1B4h] [ebp-164h]
  int v57; // [esp+1B8h] [ebp-160h]
  int v58; // [esp+1D0h] [ebp-148h]
  unsigned int v59; // [esp+1E8h] [ebp-130h]
  _BYTE v60[7]; // [esp+1ECh] [ebp-12Ch] BYREF
  char v61; // [esp+1F4h] [ebp-124h]
  int v62; // [esp+1F8h] [ebp-120h]
  int v63; // [esp+200h] [ebp-118h]
  int v64; // [esp+20Eh] [ebp-10Ah]
  LPVOID pAce; // [esp+228h] [ebp-F0h] BYREF
  int v66; // [esp+240h] [ebp-D8h] BYREF
  int v67; // [esp+24Dh] [ebp-CBh] BYREF
  int v68; // [esp+254h] [ebp-C4h]
  int v69; // [esp+258h] [ebp-C0h]
  int v70; // [esp+25Ch] [ebp-BCh]
  ACL v71; // [esp+264h] [ebp-B4h] BYREF
  int v72; // [esp+26Ch] [ebp-ACh] BYREF
  int v73; // [esp+270h] [ebp-A8h]
  _DWORD v74[3]; // [esp+278h] [ebp-A0h]
  char v75; // [esp+284h] [ebp-94h] BYREF
  LPVOID v76; // [esp+28Ch] [ebp-8Ch] BYREF
  ACL pAcl; // [esp+294h] [ebp-84h] BYREF
  LARGE_INTEGER PerformanceCount; // [esp+2A8h] [ebp-70h] BYREF
  LPVOID v79; // [esp+2B4h] [ebp-64h] BYREF
  __int16 v80; // [esp+2B8h] [ebp-60h]
  int v81; // [esp+2C0h] [ebp-58h]
  __int16 v82; // [esp+2C4h] [ebp-54h]
  char v83; // [esp+2D8h] [ebp-40h]
  int v84; // [esp+2DCh] [ebp-3Ch]
  __int16 v85; // [esp+2E4h] [ebp-34h]
  int v86; // [esp+2F4h] [ebp-24h]
  __int16 v87; // [esp+2FCh] [ebp-1Ch]
  int v88; // [esp+300h] [ebp-18h]
  int v89; // [esp+304h] [ebp-14h]
  int v90; // [esp+308h] [ebp-10h]
  char v91; // [esp+30Ch] [ebp-Ch]
  char v92; // [esp+314h] [ebp-4h]
  _BYTE savedregs[2]; // [esp+318h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+31Ah] [ebp+2h] OVERLAPPED
  void *retaddr; // [esp+31Ch] [ebp+4h] OVERLAPPED

  v56 ^= 0x1Fu;
  LOBYTE(v90) = v90 + 29;
  v57 += 225;
  v83 &= 0x42u;
  v1 = GetAce(&pAcl, 0x18u, &pAce);
  v3 = (__PAIR64__(v1, v2) + v59) >> 32;
  v59 += v2;
  v4 = v37 & v1;
  v22 ^= v5;
  *(_DWORD *)v60 ^= (v2 - v3) | 0x22A9;
  v53 -= ((unsigned __int16)v4 | (unsigned __int16)v5) & 0xC63;
  v6 = *(_DWORD *)&savedregs_2 & (DWORD1(a1) | *(_DWORD *)((char *)&a1 + 6) ^ v4 ^ 0xC63);
  v24 ^= 7u;
  v7 = *(_DWORD *)v54 ^ (*(_DWORD *)&v54[3] | (unsigned int)&savedregs[-*(_DWORD *)&v54[1]]);
  v45 += 213;
  *(_DWORD *)&v71.AceCount ^= v7;
  v81 ^= 0xF9u;
  v44 -= 66;
  LOWORD(v2) = v41 & ((unsigned __int16)savedregs - 404 - v6);
  LOWORD(pAce) = (_WORD)pAce + 66;
  v7 += 3394;
  v8 = v7 & v6;
  v9 = (((unsigned __int16)v69 & (unsigned __int16)v2) - (_WORD)v8 - (_WORD)v7 - (_WORD)v8 - 5306) & 0x14BA;
  v10 = (__PAIR64__(v7, v33) + 185) >> 32;
  v33 += 185;
  v11 = __CFADD__(v87, 64);
  v87 += 64;
  v57 ^= v9 & 0x23A5;
  v90 -= 207;
  v12 = *(unsigned int *)((char *)&retaddr + 1) + v8 - v10 - (v11 + v9) - 3860;
  v20 |= 0x62u;
  LOBYTE(v88) = v88 - 71;
  v51 &= v12;
  LOWORD(v58) = v58 & 0xFB;
  v47 &= v12 - (v7 - DWORD2(a1));
  *(_DWORD *)&pAcl.AclRevision |= 0xC3u;
  v84 ^= 0xFAu;
  v52 &= 0xD2u;
  v82 |= 0x6Fu;
  LOWORD(v58) = v58 - 88;
  v13 = *(_DWORD *)&v60[3]
      + (((*(_WORD *)((_BYTE *)&retaddr + 3) & (unsigned __int16)(*(_WORD *)((char *)&a1 + 3) | (*(_WORD *)((char *)&retaddr + 1)
                                                                                               + (v70 & (unsigned int)savedregs))))
        + ((unsigned __int16)savedregs | 0x234D)) & 0x25E);
  LOBYTE(v70) = v70 ^ 0xE3;
  LOBYTE(v70) = v70 | 0x27;
  v19 &= (unsigned int)v60;
  v66 -= (int)&v60[(v86 | v13) - 2183];
  v46 |= 0x32u;
  v43 += 205;
  v23 &= 0xCDu;
  v59 |= 0xF7u;
  *(_DWORD *)&v27[3] -= &v42;
  v61 -= 48;
  GetConsoleMode(0, (LPDWORD)((char *)&v67 + 3));
  LOBYTE(v57) = v57 | 0xFE;
  LOWORD(v89) = v89 & 0x7F;
  v23 -= (unsigned int)&savedregs[(unsigned int)savedregs ^ 0x3671] & ((unsigned int)savedregs ^ 0x3671) & 0x298;
  v91 -= 106;
  v51 &= (unsigned int)&v66
       - v67
       - (v73 & ((*(_DWORD *)((_BYTE *)&a1 + 5) & (unsigned int)&v25) - *(_DWORD *)((char *)&savedregs_2 + 1)));
  pAcl.AclRevision -= 117;
  v35 -= 101;
  LOBYTE(v31) = v31 + 84;
  v68 -= (int)&v39;
  v55 ^= 0x9Fu;
  v40 ^= (((unsigned int)savedregs | 0x352C) - (((unsigned int)&v75 | 0x1F75) - v34)) & ((unsigned int)&v54[*(_DWORD *)((char *)&a1 + 3) + 5] & 0x22B3 | 0x3B7D);
  GetAce(&v71, 7u, &v76);
  LOBYTE(v21) = v21 - 66;
  *(_WORD *)&v54[1] ^= 0xAu;
  *(_DWORD *)&v49[2] &= v14;
  v62 |= (unsigned int)savedregs;
  QueryPerformanceCounter(&PerformanceCount);
  v92 &= 0x46u;
  v28 |= 0x65u;
  v68 ^= (unsigned int)&STACK[0x37C2];
  v15 = *(_DWORD *)&pAcl.AclRevision | ((v74[0] ^ (*(_DWORD *)((char *)v74 + 2) | v74[0] | (((v63
                                                                                            + (v64 ^ (unsigned int)savedregs)) ^ 0x22EC)
                                                                                          + 13065)))
                                      + 11176);
  v38 &= (unsigned int)&v72;
  v89 ^= v15;
  *(_DWORD *)&v29[1] ^= (unsigned int)&v72 + v21;
  v84 |= (unsigned int)&v30;
  v48 |= 0x42u;
  v36 += 21;
  v72 |= v50 + (*(_DWORD *)v49 | (v31 + (v32 ^ v15) - 7948));
  LOBYTE(v73) = v73 ^ 0xE5;
  GetAce((PACL)&pAcl.AceCount, (unsigned int)&v79 & 0x16, &v79);
  GetParent((HWND)0xD7DA27E9);
  v88 += v16;
  result = ((unsigned int)&v26 & (*(_DWORD *)v29 ^ (unsigned int)savedregs)) - (_DWORD)&v26;
  v58 -= *(_DWORD *)v27 & (*(_DWORD *)((char *)&savedregs_2 + 1) | ((v16 ^ 0x1AEB) + v17));
  v80 ^= 0x63u;
  v42 += 129;
  v85 &= 0x21u;
  return result;
}
// 403F79: returning address of temporary local variable '%var_2AC'
// 403A60: variables would overlap: ^326.2 and ^326.4,^327.4
// 403A60: variables would overlap: ^328.4(retaddr) and ^329.4,^32B.2

//----- (00403FA8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_BYTE *__usercall sub_403FA8@<eax>(unsigned int a1@<edx>, unsigned int a2@<ecx>, __int64 a3)
{
  LSTATUS v3; // eax
  int v4; // ecx
  signed int v5; // ecx
  BOOL v6; // eax
  int v8; // [esp+70h] [ebp-258h] BYREF
  char v9; // [esp+8Ch] [ebp-23Ch]
  __int16 v10; // [esp+A8h] [ebp-220h]
  int v11; // [esp+E0h] [ebp-1E8h]
  __int16 v12; // [esp+E4h] [ebp-1E4h]
  int v13; // [esp+F4h] [ebp-1D4h]
  int v14; // [esp+138h] [ebp-190h]
  int v15; // [esp+164h] [ebp-164h]
  int v16; // [esp+180h] [ebp-148h]
  __int16 v17; // [esp+184h] [ebp-144h]
  int v18; // [esp+1A4h] [ebp-124h]
  int v19; // [esp+1C4h] [ebp-104h]
  DWORD Mode[2]; // [esp+1DCh] [ebp-ECh] BYREF
  DWORD v21; // [esp+1E4h] [ebp-E4h] BYREF
  int v22; // [esp+1E8h] [ebp-E0h]
  __int16 v23; // [esp+1F8h] [ebp-D0h]
  __int16 v24; // [esp+1FCh] [ebp-CCh]
  int v25; // [esp+20Ch] [ebp-BCh]
  char v26; // [esp+210h] [ebp-B8h]
  __int16 v27; // [esp+21Ch] [ebp-ACh]
  struct HKEY__ hKey; // [esp+228h] [ebp-A0h] BYREF
  int v29; // [esp+22Ch] [ebp-9Ch]
  int v30; // [esp+238h] [ebp-90h]
  int v31; // [esp+23Ch] [ebp-8Ch]
  struct tagRECT Rect; // [esp+248h] [ebp-80h] BYREF
  int v33; // [esp+298h] [ebp-30h]
  int v34; // [esp+2BCh] [ebp-Ch]
  _BYTE savedregs[3]; // [esp+2C8h] [ebp+0h] BYREF
  char savedregs_3; // [esp+2CBh] [ebp+3h] OVERLAPPED

  v25 &= (__PAIR64__(a2, a1) - __PAIR64__(a1 - 1858, 1858)) >> 32;
  GetConsoleMode(0, Mode);
  v33 ^= 0x34u;
  v8 ^= 0xAEu;
  v22 &= 0xF9u;
  v26 &= 0x5Du;
  LOBYTE(Mode[0]) += 54;
  v31 -= (int)savedregs;
  v17 -= 134;
  v23 += 53;
  v3 = RegFlushKey(&hKey);
  v29 -= v3;
  v14 &= (unsigned int)savedregs;
  LOWORD(v11) = v11 ^ 0x1E;
  v27 &= 0x1Eu;
  v18 -= (int)savedregs;
  v22 -= 130;
  v30 += 77;
  v5 = (signed int)&savedregs[(*(_WORD *)((char *)&a3 + 3) | (unsigned __int16)&savedregs[*(_DWORD *)((char *)&a3 + 1) | *(_DWORD *)((_BYTE *)&a3 + 3) & (*(_DWORD *)((char *)&a3 + 2) ^ *(_DWORD *)&savedregs_3 ^ (v4 - 3305) ^ 0x292F)]) & 0x24D];
  LOBYTE(v24) = v24 + 81;
  v19 -= v5;
  v12 = (unsigned __int8)v12;
  LOWORD(v33) = v33 & 0x99;
  Mode[0] |= v15 ^ v5;
  v24 -= 152;
  LOBYTE(v17) = v17 - 63;
  v6 = GetConsoleMode(0, &v21);
  v10 ^= 0xC6u;
  v9 -= 31;
  v13 += v16 & (unsigned int)savedregs;
  v34 &= v6 - (_DWORD)&v8;
  GetWindowRect((HWND)0xF5125519, &Rect);
  return savedregs;
}
// 404200: returning address of temporary local variable '%" s"'
// 403FA8: variables would overlap: ^2D3.1 and ^2D3.4

//----- (00404218) --------------------------------------------------------
unsigned int sub_404218()
{
  int savedregs; // [esp+268h] [ebp+0h] BYREF

  ResumeThread((HANDLE)0x3C08B69B);
  return (unsigned int)&STACK[0x1B8B] & ((unsigned int)&STACK[0x65D] + (_DWORD)&savedregs);
}
// 404375: returning address of temporary local variable '%0x1B8F'

//----- (00404380) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __cdecl sub_404380(char a1, int a2, int a3)
{
  unsigned __int64 v3; // kr00_8
  BOOL v4; // eax
  char v5; // cf
  int v6; // edx
  int v7; // ecx
  unsigned int v8; // edx
  int v10[3]; // [esp+28h] [ebp-218h] BYREF
  int v11; // [esp+34h] [ebp-20Ch]
  int v12; // [esp+38h] [ebp-208h]
  int v13; // [esp+5Ah] [ebp-1E6h]
  char v14[80]; // [esp+7Ch] [ebp-1C4h] BYREF
  unsigned int v15; // [esp+F0h] [ebp-150h]
  int v16; // [esp+10Ch] [ebp-134h]
  int v17; // [esp+120h] [ebp-120h]
  HANDLE TokenHandle; // [esp+140h] [ebp-100h] BYREF
  int v19; // [esp+160h] [ebp-E0h]
  char v20; // [esp+1A4h] [ebp-9Ch]
  int v21; // [esp+1A8h] [ebp-98h]
  int v22; // [esp+1F8h] [ebp-48h]
  int v23; // [esp+218h] [ebp-28h]
  int v24; // [esp+228h] [ebp-18h]
  _BYTE savedregs[2]; // [esp+240h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+242h] [ebp+2h] OVERLAPPED
  void *retaddr; // [esp+244h] [ebp+4h] OVERLAPPED

  LOBYTE(v22) = v22 - 111;
  v24 -= 69;
  v24 ^= (unsigned int)v14;
  LOBYTE(v11) = v11 & 0xB6;
  v3 = __PAIR64__(
         ((unsigned int)v14 & 0x27BA)
       + (((unsigned __int16)((unsigned __int16)savedregs - 276) | 0x9A6) & 0x3EAF | 0x782)
       + ((unsigned int)v14 & 0x27BA),
         v15)
     - __PAIR64__(savedregs, 151);
  v15 -= 151;
  v19 &= v21 + HIDWORD(v3);
  v4 = IsWindow((HWND)(v21 + HIDWORD(v3)));
  v20 += 8;
  v17 ^= (*(_DWORD *)&savedregs_2 | *(unsigned int *)((char *)&retaddr + 1) | (v5
                                                                             + v7
                                                                             + ((v6 + v5 + v7) | v23 | v4 | 0x1A9E)))
       - 15901;
  OpenThreadToken((HANDLE)0x18, 0x1Cu, 0, &TokenHandle);
  v8 = v11 ^ (v10[1] | v13 | (unsigned int)&savedregs[(a3 & (unsigned int)savedregs)
                                                    + __CFADD__(a3 & (unsigned int)savedregs, savedregs)
                                                    + (a3 & (unsigned int)savedregs)]);
  return v16 ^ ((v8 + (v12 & (unsigned int)&savedregs[a3 & (unsigned int)savedregs])) | ((unsigned int)v10 + (v8 & 0xA92)));
}
// 404380: variables would overlap: ^252.2 and ^252.4
// 404380: variables would overlap: ^254.4(retaddr) and ^255.4

//----- (004045C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __cdecl sub_4045C0(int a1)
{
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int v4; // edx
  unsigned int v5; // ecx
  int v6; // ett
  HWND v7; // eax
  int v8; // edx
  int v10; // [esp+30h] [ebp-1D8h]
  int v11; // [esp+3Ch] [ebp-1CCh]
  int v12; // [esp+40h] [ebp-1C8h]
  int v13; // [esp+78h] [ebp-190h]
  int v14; // [esp+9Ch] [ebp-16Ch] BYREF
  _DWORD v15[2]; // [esp+A3h] [ebp-165h]
  _DWORD v16[3]; // [esp+ACh] [ebp-15Ch]
  char v17; // [esp+B8h] [ebp-150h]
  char v18; // [esp+D8h] [ebp-130h]
  int v19; // [esp+F0h] [ebp-118h]
  int v20; // [esp+F8h] [ebp-110h]
  int v21; // [esp+130h] [ebp-D8h] BYREF
  char v22[12]; // [esp+13Ch] [ebp-CCh] BYREF
  __int16 v23; // [esp+148h] [ebp-C0h]
  int v24[6]; // [esp+150h] [ebp-B8h] BYREF
  LARGE_INTEGER PerformanceCount; // [esp+168h] [ebp-A0h] BYREF
  int v26; // [esp+17Eh] [ebp-8Ah]
  unsigned int v27; // [esp+1A4h] [ebp-64h]
  int v28; // [esp+1B8h] [ebp-50h]
  __int16 v29; // [esp+1C8h] [ebp-40h]
  int v30; // [esp+1D8h] [ebp-30h]
  char v31; // [esp+1ECh] [ebp-1Ch]
  int v32; // [esp+1FCh] [ebp-Ch]
  int v33; // [esp+200h] [ebp-8h]
  __int16 v34; // [esp+204h] [ebp-4h]
  int savedregs; // [esp+208h] [ebp+0h] OVERLAPPED BYREF

  v11 += (int)v24;
  v10 &= (unsigned int)&savedregs - 11837;
  QueryPerformanceCounter(&PerformanceCount);
  v3 = v21 | (v1 - v2);
  v2 |= 0x110Du;
  v18 -= 10;
  v4 = v32 + v15[0] + v16[0] + v2 + (v3 ^ 0x2FF7);
  v33 |= 0xD4u;
  v12 &= (unsigned int)&v14;
  v34 &= 0x62u;
  v17 -= 94;
  v5 = v13 + ((*(_DWORD *)((char *)v15 + 1) + (v2 & 0x3E2F)) | 0x251F) - v4;
  v24[0] ^= 0x7Cu;
  LOWORD(v13) = v13 + 4;
  v6 = (__PAIR64__(a1 & (v5 + v4) & v5, a1 & (v5 + v4) & v5) + v27) >> 32;
  v27 += a1 & (v5 + v4) & v5;
  v33 |= 0xF2u;
  v30 -= v6;
  v7 = GetParent((HWND)0x20);
  v30 -= 194;
  v23 += 115;
  v29 &= 0xD7u;
  v31 |= 0x9Fu;
  v28 |= 0xB9u;
  v27 -= *(_DWORD *)((char *)v16 + 2)
       + (*(_DWORD *)((char *)&v16[1] + 2) ^ (unsigned int)&v22[-((unsigned int)&v22[-(v8 - v19) - v20] ^ 0x2BE1)
                                                              - (*(int *)((char *)&savedregs + 2) ^ ((unsigned int)v7 + v14))
                                                              - v26]);
  return *(int *)((char *)&savedregs + 3) ^ (unsigned int)&v21;
}
// 404782: returning address of temporary local variable '%var_D8'
// 4046E5: inconsistent variable size for '^20C.4'
// 404782: inconsistent variable size for '^20C.4'

//----- (004047B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __cdecl sub_4047B0(int a1, __int64 a2)
{
  int v2; // ecx
  unsigned int v3; // eax
  int v4; // edx
  bool v5; // cf
  unsigned int v6; // eax
  int result; // eax
  int v8; // [esp+3Eh] [ebp-23Ah]
  int v9; // [esp+98h] [ebp-1E0h]
  int v10; // [esp+98h] [ebp-1E0h]
  __int64 v11; // [esp+A0h] [ebp-1D8h]
  int v12; // [esp+16Ch] [ebp-10Ch]
  __int16 v13; // [esp+194h] [ebp-E4h] BYREF
  int v14; // [esp+199h] [ebp-DFh]
  __int16 v15; // [esp+1A0h] [ebp-D8h]
  int v16; // [esp+1A3h] [ebp-D5h]
  int v17; // [esp+1A8h] [ebp-D0h]
  int v18; // [esp+1E4h] [ebp-94h]
  int v19; // [esp+1FCh] [ebp-7Ch]
  int v20; // [esp+21Ch] [ebp-5Ch]
  int v21; // [esp+220h] [ebp-58h]
  int v22; // [esp+228h] [ebp-50h]
  __int16 v23; // [esp+234h] [ebp-44h]
  struct HKEY__ hKey; // [esp+238h] [ebp-40h] BYREF
  int v25; // [esp+248h] [ebp-30h]
  int v26; // [esp+250h] [ebp-28h]
  int v27; // [esp+268h] [ebp-10h]
  int v28; // [esp+26Ch] [ebp-Ch]
  int v29; // [esp+270h] [ebp-8h]
  int savedregs; // [esp+278h] [ebp+0h] OVERLAPPED BYREF
  void *retaddr; // [esp+27Ch] [ebp+4h] OVERLAPPED

  v28 ^= (unsigned int)&savedregs;
  HIDWORD(v11) = BYTE4(v11) & 0x6C;
  RegFlushKey(&hKey);
  v10 = v9 | 0x6E;
  v13 -= 102;
  v17 |= 0x6Eu;
  v20 += 3;
  v25 |= (unsigned int)&savedregs;
  v15 &= 0xC3u;
  v22 |= 0x38u;
  v21 ^= 0xA4u;
  v23 ^= 0x8Eu;
  v19 += ((unsigned int)&savedregs | HIDWORD(a2) | ((v20 | (v18
                                                          + ((unsigned int)&savedregs & ((((*(_DWORD *)((char *)&a2 + 2)
                                                                                          + v2) | 0x3E99) ^ 0x2C6A)
                                                                                       + (v8 & (((unsigned int)&savedregs | 0x2158)
                                                                                              - 30
                                                                                              - v12))))
                                                          - (savedregs | (unsigned int)&savedregs)))
                                                  - *(_DWORD *)((char *)&a2 + 3)))
       + 9475;
  ++v26;
  v3 = *(unsigned int *)((char *)&retaddr + 3) | ((((unsigned int)&savedregs
                                                  + (*(int *)((char *)&savedregs + 3) ^ (savedregs | (unsigned int)&savedregs))) ^ 0x3DFC)
                                                - a1);
  v28 += (int)&savedregs;
  v4 = *(_DWORD *)((char *)&v11 + 3)
     + v3
     + (((unsigned int)&savedregs | 0x1CE9) < 0x399C)
     + ((unsigned int)&savedregs | 0x1CE9)
     - 14748
     - v11;
  v5 = __CFADD__(v10, v3);
  v6 = v10 + v3;
  v29 ^= v4 - (v5 + v6);
  result = (v16 ^ v14 ^ (v6 + 12341)) - (_DWORD)&v13;
  v27 -= result;
  return result;
}
// 4049AD: returning address of temporary local variable '%var_E4'
// 4047B0: variables would overlap: ^27C.4 and ^27F.4
// 4047B0: variables would overlap: ^280.4(retaddr) and ^283.4

//----- (004049B8) --------------------------------------------------------
int sub_4049B8()
{
  int v1; // [esp+D0h] [ebp-158h]
  char v2; // [esp+174h] [ebp-B4h] BYREF
  char v3; // [esp+17Ch] [ebp-ACh]
  CHAR String[4]; // [esp+1C4h] [ebp-64h] BYREF
  __int16 v5; // [esp+1D4h] [ebp-54h]
  int v6; // [esp+208h] [ebp-20h]

  v5 ^= 0x73u;
  v6 &= (unsigned int)&v2;
  v3 += 105;
  return v1 & GetWindowTextA((HWND)0x15CA88E, String, -1352121368);
}
// 404ACC: variable 'v1' is possibly undefined

//----- (00404AE0) --------------------------------------------------------
LSTATUS sub_404AE0()
{
  int v1; // [esp+94h] [ebp-2B4h]
  LARGE_INTEGER PerformanceCount; // [esp+260h] [ebp-E8h] BYREF
  struct HKEY__ hKey; // [esp+26Ch] [ebp-DCh] BYREF
  DWORD Reserved[13]; // [esp+278h] [ebp-D0h] BYREF
  char v5; // [esp+2ACh] [ebp-9Ch]
  int v6; // [esp+2B0h] [ebp-98h]
  int v7; // [esp+2B4h] [ebp-94h]
  DWORD Type[2]; // [esp+2C0h] [ebp-88h] BYREF
  BYTE Data[24]; // [esp+2C8h] [ebp-80h] BYREF
  char v10; // [esp+2E0h] [ebp-68h]
  DWORD cchValueName[8]; // [esp+2E8h] [ebp-60h] BYREF
  char v12; // [esp+31Ch] [ebp-2Ch]
  int savedregs; // [esp+348h] [ebp+0h] BYREF

  v12 ^= 0xA9u;
  v7 += v1 ^ (unsigned int)&savedregs;
  v6 ^= 0x3Cu;
  QueryPerformanceCounter(&PerformanceCount);
  v5 ^= 0x67u;
  v10 += 16;
  return RegEnumValueW(&hKey, 0x16u, (LPWSTR)0x11, cchValueName, Reserved, Type, Data, (LPDWORD)3);
}
// 404BCC: variable 'v1' is possibly undefined

//----- (00404D00) --------------------------------------------------------
unsigned int __cdecl sub_404D00(__int128 a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34)
{
  unsigned int v34; // eax
  int v35; // edx
  unsigned int v36; // ecx
  int v37; // kr00_4
  int v38; // ecx
  int v39; // eax
  int v40; // edx
  int v41; // edx
  HWND v42; // eax
  int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // eax
  char v47; // [esp+7Ch] [ebp-1CCh] BYREF
  int v48; // [esp+7Dh] [ebp-1CBh]
  int v49; // [esp+90h] [ebp-1B8h]
  __int16 v50; // [esp+94h] [ebp-1B4h]
  int v51; // [esp+A4h] [ebp-1A4h]
  int v52; // [esp+A8h] [ebp-1A0h]
  int v53; // [esp+E0h] [ebp-168h]
  int v54; // [esp+E4h] [ebp-164h]
  int v55; // [esp+F4h] [ebp-154h]
  char v56; // [esp+12Ch] [ebp-11Ch]
  char v57; // [esp+130h] [ebp-118h]
  int v58; // [esp+150h] [ebp-F8h]
  int v59; // [esp+154h] [ebp-F4h]
  int v60; // [esp+158h] [ebp-F0h]
  struct _FILETIME SystemTimeAsFileTime; // [esp+17Ch] [ebp-CCh] BYREF
  char v62; // [esp+184h] [ebp-C4h]
  int v63; // [esp+1A0h] [ebp-A8h] BYREF
  _BYTE v64[5]; // [esp+1AFh] [ebp-99h]
  __int16 v65; // [esp+1D0h] [ebp-78h]
  int v66; // [esp+1E8h] [ebp-60h]
  int v67; // [esp+1F0h] [ebp-58h]
  __int16 v68; // [esp+20Ch] [ebp-3Ch]
  int v69; // [esp+234h] [ebp-14h]
  int savedregs; // [esp+248h] [ebp+0h] BYREF

  v57 |= 0x8Eu;
  v34 = (unsigned int)GetCommandLineW() & 0x18B3;
  v53 ^= v34;
  v62 |= 0x58u;
  v37 = v34 + v35;
  v38 = v34 + v35 + ((v34 + __PAIR64__(v36, v35)) >> 32);
  v39 = v66 & (v34 | 0x37DD);
  v40 = v38 + v37 + 735;
  v60 |= v38 | 0x2F08;
  v68 |= 0xE2u;
  v66 |= v40;
  v51 -= v39;
  v41 = v40 & 0x2D3F | 0x25EA;
  v55 -= v41;
  v52 -= v41;
  v50 += 234;
  v42 = GetParent((HWND)0xD);
  LOBYTE(v60) = v60 & 0x1B;
  LOWORD(v59) = v59 + 53;
  v67 |= (unsigned int)&a34 + 3;
  v58 -= (int)v42;
  v54 &= 0xC3u;
  v43 = v48 | (unsigned int)v42;
  v51 |= v43;
  v49 ^= v43;
  v44 = *(_DWORD *)v64 & (unsigned int)(&v47 + v43);
  *(_DWORD *)&v64[1] ^= 0xF6u;
  v56 ^= 0x36u;
  v65 += 18;
  v45 = (unsigned int)&savedregs
      + ((unsigned int)&v63 | 0x1EBD)
      + *(_DWORD *)((char *)&a1 + 5)
      + v44
      + *(_DWORD *)((char *)&a1 + 2);
  v69 &= v45;
  v67 &= v45;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  return (unsigned int)&savedregs | 0x1020;
}
// 404F6E: returning address of temporary local variable '%" s"'
// 404D49: variable 'v35' is possibly undefined
// 404D49: variable 'v36' is possibly undefined

//----- (00404F80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// bad sp value at call has been detected, the output may be wrong!
int __usercall start@<eax>(int a1@<eax>, int a2@<ebp>, __int128 a3)
{
  unsigned int v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // edx
  int v6; // edx
  HRESULT v7; // eax
  int v9; // [esp-2F4h] [ebp-2F4h]
  int v10; // [esp-294h] [ebp-294h] BYREF
  __int16 v11; // [esp-254h] [ebp-254h]
  _BYTE v12[9]; // [esp-234h] [ebp-234h] BYREF
  _BYTE v13[7]; // [esp-22Bh] [ebp-22Bh]
  int v14; // [esp-224h] [ebp-224h]
  int v15; // [esp-218h] [ebp-218h]
  int v16; // [esp-20Ch] [ebp-20Ch] BYREF
  char v17; // [esp-1F4h] [ebp-1F4h]
  _DWORD v18[7]; // [esp-1ECh] [ebp-1ECh] BYREF
  _DWORD v19[2]; // [esp-1D0h] [ebp-1D0h] BYREF
  char v20; // [esp-1C8h] [ebp-1C8h]
  int v21; // [esp-1C4h] [ebp-1C4h]
  int v22; // [esp-1BCh] [ebp-1BCh]
  int v23; // [esp-198h] [ebp-198h]
  int v24; // [esp-178h] [ebp-178h]
  int v25; // [esp-164h] [ebp-164h]
  int v26; // [esp-15Ch] [ebp-15Ch]
  int v27; // [esp-150h] [ebp-150h]
  char v28; // [esp-124h] [ebp-124h]
  __int16 v29; // [esp-F0h] [ebp-F0h]
  __int16 v30; // [esp-E8h] [ebp-E8h]
  int v31; // [esp-E0h] [ebp-E0h]
  int v32; // [esp-BCh] [ebp-BCh]
  _BYTE v33[20]; // [esp-B4h] [ebp-B4h] BYREF
  _DWORD v34[2]; // [esp-A0h] [ebp-A0h] BYREF
  int v35; // [esp-98h] [ebp-98h]
  char v36; // [esp-80h] [ebp-80h]
  char v37; // [esp-68h] [ebp-68h]
  char v38; // [esp-2Ch] [ebp-2Ch]
  int v39; // [esp-4h] [ebp-4h] OVERLAPPED BYREF

  v39 = a2;
  v20 -= 11;
  v22 += v9 ^ (unsigned int)v12 | *(_DWORD *)v13 ^ (a1 + 296 - v14);
  v3 = (unsigned int)&v39 | (((v9 ^ (unsigned int)v12) & -*(_DWORD *)((char *)&a3 + 5)) - (v9 ^ (unsigned int)v12));
  v36 -= 88;
  v4 = v3 | (unsigned int)&v39;
  v5 = (v3 | (unsigned int)&v39) + v3;
  v26 |= (unsigned __int16)v5 & v4 & 0x1DD4 & 0x3123;
  v38 |= 0xEFu;
  v17 &= 0x7Fu;
  v6 = v18[1] ^ (v18[4] + v5);
  v27 |= v6;
  v15 ^= v6 & (unsigned int)v18;
  v29 &= 0x80u;
  v11 &= 0x52u;
  v21 &= (unsigned int)v34;
  v32 -= (int)v34;
  v31 ^= (unsigned int)v34 | *(_DWORD *)&v13[3] & (*(int *)((char *)&v39 + 1) ^ *(_DWORD *)((char *)&a3 + 3) ^ ((unsigned int)&v39 - *(int *)((char *)&v39 + 1)) | (unsigned int)&v10);
  v37 -= 49;
  v35 += (int)v33;
  v34[0] += 124;
  v25 -= 143;
  v20 |= 0xDDu;
  LOBYTE(v15) = v15 ^ 0x4B;
  v23 -= 40;
  v24 ^= 0xA4u;
  v28 += 83;
  v30 += 232;
  v7 = CoCreateFreeThreadedMarshaler(0, 0);
  return ((int (__fastcall *)(_DWORD *, char *))(v7 - 2143741418))(v19, (char *)&v16 - v19[1]);
}
// 404F80: could not find valid save-restore pair for ebp
// 404F80: variables would overlap: ^310.4 and ^311.4
// 4052FC: bad sp value at call

// nfuncs=18 queued=18 decompiled=18 lumina nreq=0 worse=0 better=0
// ALL OK, 18 function(s) have been successfully decompiled
