/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HRESULT __stdcall OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum);
// int *__usercall sub_401908@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, __int128 a4);
// int *__usercall sub_401F88@<eax>(int a1@<eax>, int a2@<ecx>, __int128 a3);
void __noreturn start(); // weak


//----- (00401908) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int *__usercall sub_401908@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, __int128 a4)
{
  int *v4; // ecx
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // ecx
  __int64 v9; // rax
  unsigned int v10; // ecx
  char *v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int *v14; // ecx
  unsigned int v15; // ecx
  int v16; // ecx
  bool v17; // cf
  int v18; // edx
  int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  int *v22; // eax
  int v23; // edx
  unsigned int v24; // eax
  unsigned int v25; // ecx
  int v26; // ecx
  unsigned int v27; // eax
  int v28; // eax
  int v29; // ecx
  unsigned int v30; // edx
  int v31; // ecx
  unsigned int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // ecx
  unsigned int v37; // edx
  int v38; // edx
  int v40[4]; // [esp+20h] [ebp-3A8h] BYREF
  int v41; // [esp+30h] [ebp-398h]
  __int16 v42; // [esp+3Ch] [ebp-38Ch]
  char v43[4]; // [esp+48h] [ebp-380h] BYREF
  _BYTE v44[11]; // [esp+4Ch] [ebp-37Ch] BYREF
  int v45; // [esp+60h] [ebp-368h]
  int v46; // [esp+64h] [ebp-364h]
  char v47; // [esp+70h] [ebp-358h]
  char v48; // [esp+78h] [ebp-350h]
  int v49; // [esp+8Ch] [ebp-33Ch]
  __int16 v50; // [esp+90h] [ebp-338h] BYREF
  int v51; // [esp+93h] [ebp-335h]
  int v52; // [esp+9Ah] [ebp-32Eh]
  int v53; // [esp+B4h] [ebp-314h]
  __int16 v54; // [esp+D0h] [ebp-2F8h]
  __int16 v55; // [esp+D4h] [ebp-2F4h]
  int v56; // [esp+DCh] [ebp-2ECh]
  int v57; // [esp+ECh] [ebp-2DCh]
  int v58; // [esp+FCh] [ebp-2CCh] BYREF
  char v59; // [esp+100h] [ebp-2C8h]
  _BYTE v60[9]; // [esp+109h] [ebp-2BFh] BYREF
  int v61; // [esp+118h] [ebp-2B0h]
  int v62; // [esp+120h] [ebp-2A8h]
  int v63; // [esp+124h] [ebp-2A4h]
  __int16 v64; // [esp+130h] [ebp-298h]
  int v65; // [esp+134h] [ebp-294h]
  __int16 v66; // [esp+140h] [ebp-288h]
  int v67; // [esp+144h] [ebp-284h]
  char v68; // [esp+14Ch] [ebp-27Ch] BYREF
  int v69; // [esp+150h] [ebp-278h]
  int v70; // [esp+15Ch] [ebp-26Ch] BYREF
  int v71; // [esp+160h] [ebp-268h]
  int v72; // [esp+16Ch] [ebp-25Ch]
  int v73; // [esp+17Dh] [ebp-24Bh]
  _DWORD v74[4]; // [esp+18Bh] [ebp-23Dh]
  char v75; // [esp+19Ch] [ebp-22Ch] BYREF
  _DWORD v76[2]; // [esp+19Fh] [ebp-229h]
  int v77; // [esp+1A8h] [ebp-220h]
  int v78[2]; // [esp+1BCh] [ebp-20Ch] BYREF
  __int64 v79; // [esp+1C4h] [ebp-204h]
  int v80; // [esp+1CCh] [ebp-1FCh]
  int v81; // [esp+1D0h] [ebp-1F8h]
  int v82; // [esp+1D4h] [ebp-1F4h]
  char v83; // [esp+1E0h] [ebp-1E8h]
  int v84; // [esp+1E8h] [ebp-1E0h]
  int v85; // [esp+208h] [ebp-1C0h]
  int v86; // [esp+214h] [ebp-1B4h]
  int v87; // [esp+219h] [ebp-1AFh]
  int v88; // [esp+220h] [ebp-1A8h]
  int v89; // [esp+228h] [ebp-1A0h]
  int v90; // [esp+238h] [ebp-190h]
  int v91; // [esp+23Ch] [ebp-18Ch]
  int v92; // [esp+250h] [ebp-178h]
  __int16 v93; // [esp+254h] [ebp-174h]
  int v94; // [esp+278h] [ebp-150h]
  char v95[8]; // [esp+284h] [ebp-144h] BYREF
  __int16 v96; // [esp+290h] [ebp-138h]
  int v97; // [esp+294h] [ebp-134h]
  int v98; // [esp+29Ch] [ebp-12Ch]
  int v99; // [esp+2ACh] [ebp-11Ch]
  __int16 v100; // [esp+2B4h] [ebp-114h]
  int v101; // [esp+2BCh] [ebp-10Ch]
  int v102; // [esp+2E0h] [ebp-E8h]
  int v103; // [esp+2ECh] [ebp-DCh]
  int v104; // [esp+2F0h] [ebp-D8h]
  int v105; // [esp+2F8h] [ebp-D0h] BYREF
  __int64 v106; // [esp+2FCh] [ebp-CCh] BYREF
  char v107; // [esp+30Ch] [ebp-BCh] BYREF
  int v108; // [esp+310h] [ebp-B8h]
  int v109; // [esp+314h] [ebp-B4h]
  int v110; // [esp+319h] [ebp-AFh]
  int v111; // [esp+324h] [ebp-A4h] BYREF
  int v112; // [esp+328h] [ebp-A0h]
  _DWORD v113[3]; // [esp+32Ch] [ebp-9Ch]
  char v114; // [esp+338h] [ebp-90h]
  int v115; // [esp+348h] [ebp-80h]
  int v116; // [esp+358h] [ebp-70h]
  int v117; // [esp+35Ch] [ebp-6Ch]
  int v118; // [esp+374h] [ebp-54h]
  __int16 v119; // [esp+37Ch] [ebp-4Ch]
  char v120; // [esp+38Ch] [ebp-3Ch]
  int v121; // [esp+3A8h] [ebp-20h]
  int v122; // [esp+3B8h] [ebp-10h]
  int v123; // [esp+3C4h] [ebp-4h]
  int savedregs; // [esp+3C8h] [ebp+0h] OVERLAPPED BYREF
  void *retaddr; // [esp+3CCh] [ebp+4h] OVERLAPPED

  if ( a2 )
    goto LABEL_7;
  v4 = (int *)(a1 + a3);
  if ( a1 )
    goto LABEL_11;
  v5 = (int)(v4 + 3630);
  v6 = 14520;
  if ( v5 )
    goto LABEL_9;
  a3 = 2302;
  if ( !HIDWORD(v79) )
  {
    a2 = 0;
    if ( !v81 )
    {
LABEL_8:
      v5 = 2 * (a3 | 0x1A82);
      v6 += a2 - 14960;
LABEL_9:
      v6 -= v5;
      v55 |= 0x81u;
      goto LABEL_10;
    }
    a3 = -12218;
LABEL_7:
    v6 = 0;
    goto LABEL_8;
  }
LABEL_10:
  v59 |= 0x49u;
  a1 = (v51 | v6) - v51;
  v4 = &savedregs;
  v114 &= 0x79u;
  v69 |= a1;
LABEL_11:
  LOBYTE(v104) = v104 | 0x53;
  v7 = v67 + (a1 & 0x28CB);
  v40[0] &= v7;
  v62 -= v7;
  HIDWORD(v9) = &savedregs;
  v8 = (unsigned int)v4 - DWORD1(a4);
  LODWORD(v9) = *(unsigned int *)((char *)&retaddr + 3) | v7;
  if ( (int *)v79 != &savedregs )
  {
    LODWORD(v9) = &savedregs;
    HIDWORD(v9) = *(_DWORD *)((char *)&a4 + 6) | (unsigned int)&savedregs;
    v64 -= 220;
    v8 = (*(_DWORD *)((char *)&a4 + 1) ^ ((unsigned int)&savedregs + v8) ^ 0x15C2) + 5570;
  }
  v116 &= 0x17u;
  if ( (_DWORD)v9 != 695 )
    goto LABEL_28;
  v10 = v8 - 4375;
  v65 += v10;
  LOWORD(v9) = v61 | 0x2B7;
  v11 = (char *)(v10 + 3198);
  if ( (v61 | 0x2B7) == v111 )
    goto LABEL_25;
  LODWORD(v9) = v95;
  v88 += 223;
  v12 = (int)(v11 - 4911);
  if ( HIDWORD(v9) != 644 )
    goto LABEL_23;
  v94 &= 0x284u;
  LODWORD(v9) = v12 & (unsigned int)v95;
  if ( v12 == 70 )
    goto LABEL_29;
  HIDWORD(v9) = v9 & (*(_DWORD *)((char *)v113 + 1) ^ *(_DWORD *)((char *)v113 + 2) ^ 0x284);
  LODWORD(v9) = v122 + v9;
  v11 = (char *)&v111 - v72 + 14592;
  if ( (char *)v9 != v11 )
    goto LABEL_26;
  v13 = (*(_DWORD *)&v60[1] | (unsigned int)&v11[-*(_DWORD *)v60]) ^ 0x24D5;
  HIDWORD(v9) = (char *)&v58 + v13;
  if ( (_DWORD)v9 == v112 )
  {
LABEL_22:
    v119 += 30;
    v86 -= HIDWORD(v9);
LABEL_23:
    v14 = v40;
    LODWORD(v9) = (*(int *)((char *)&v40[2] + 3) | v9) - (_DWORD)v40;
    HIDWORD(v9) = &v106;
    goto LABEL_24;
  }
  v14 = (int *)((__PAIR64__(v13, 16244) + v9) >> 32);
  HIDWORD(v9) = v43;
  LODWORD(v9) = *(_DWORD *)&v44[1] | *(_DWORD *)&v44[7] & (v9 + 16244);
  v100 ^= 0xE5u;
  if ( v43 != (char *)v9 )
  {
LABEL_24:
    v93 &= 0x23u;
    v16 = (HIDWORD(v9) + (((_WORD)v14 + 1879) & 0x3347)) | 0x1762;
    v54 |= 0xECu;
    HIDWORD(v9) = &v60[3];
    v11 = (char *)(v16 - *(_DWORD *)&v60[5] - *(_DWORD *)&v60[4]);
LABEL_25:
    LODWORD(v106) = HIDWORD(v9) + v106;
    LOBYTE(v122) = v122 - 24;
    LODWORD(v9) = HIDWORD(v9) | v9 & 0x1D72;
    HIDWORD(v9) += 13633;
LABEL_26:
    v58 -= v9;
    v17 = v78[0] < (unsigned int)v9;
    v78[0] -= v9;
    v18 = v9 + v17 + HIDWORD(v9);
    LODWORD(v9) = &v50;
    HIDWORD(v9) = v18 - v52;
    v15 = (unsigned int)&v11[HIDWORD(v9)];
    goto LABEL_27;
  }
  v15 = (unsigned int)&v43[*(_DWORD *)((char *)v76 + 3) - v76[0]] & 0x2AC | (unsigned int)&v75;
  LODWORD(v9) = *(_DWORD *)((_BYTE *)&v79 + 1) & (v78[1] | v76[0] ^ v9);
  HIDWORD(v9) = (unsigned int)v78 ^ 0x135B;
  if ( *(_DWORD *)v44 == ((unsigned int)v78 ^ 0x135B) )
  {
    LOWORD(v98) = v98 | 0x72;
    LODWORD(v9) = HIDWORD(v9) + v9;
    v53 ^= 0xB0u;
    goto LABEL_22;
  }
LABEL_27:
  v123 ^= 0xAAu;
  v118 &= HIDWORD(v9) & v15;
  BYTE2(v52) |= 0xD2u;
LABEL_28:
  v46 &= 4u;
  v71 += 164;
LABEL_29:
  v19 = *(_DWORD *)((_BYTE *)&a4 + 7) & v9;
  v103 &= 0x92u;
  v48 ^= 0xE9u;
  v20 = (unsigned int)&savedregs;
  if ( v101 == v19 )
  {
LABEL_41:
    v34 = v69 + v19 - (v49 ^ (v70 | v20));
    v21 = (unsigned int)&v68 | v49 ^ (v70 | v20);
    v22 = (int *)(v34 | 0x1D67);
    v50 -= 157;
    goto LABEL_42;
  }
  LOWORD(v102) = v102 & 6;
  v102 = (unsigned __int16)v102 ^ 0x3A;
  v21 = (unsigned int)&savedregs;
  v22 = &savedregs;
  v23 = (*(_DWORD *)((char *)&a4 + 1) ^ (&v44[-v57 + 8]
                                       - *(_BYTE **)((char *)&retaddr + 2)
                                       - *(_DWORD *)((char *)&retaddr + 2)))
      - *(_DWORD *)((char *)&retaddr + 3);
  if ( (int *)v23 == &savedregs )
  {
    v24 = (unsigned int)&savedregs;
    v25 = *(unsigned int *)((char *)&retaddr + 1) | (unsigned int)&savedregs & 0x743;
    if ( ((savedregs ^ v23) & 0x99) == 0 )
    {
      v83 |= 0x73u;
      v26 = v121 ^ (*(int *)((char *)&savedregs + 3) | *(int *)((char *)&savedregs + 1) & v25 | 0x1582);
      v27 = (unsigned int)&savedregs | 0x153;
      if ( v77 == ((unsigned int)&savedregs | 0x153) )
      {
LABEL_40:
        v19 = v115 ^ v27;
        v20 = (unsigned int)&v70;
        goto LABEL_41;
      }
      v41 ^= v27;
      v28 = v110 + v27;
      v29 = v108 ^ v26;
      v30 = v29 | (unsigned int)&v107;
      v31 = v29 + 14044;
      if ( v31 != v30 )
        goto LABEL_43;
      v32 = (unsigned int)&v105 & 0x187;
      if ( ((*(_DWORD *)((char *)&v106 + 1) + v30) & 0x312D) != 425 )
      {
LABEL_39:
        v91 += v32;
        v27 = v32 | 0x3784;
        goto LABEL_40;
      }
      v99 ^= v32;
      v33 = v32 + 7694 - *(_DWORD *)((char *)&retaddr + 2);
      v25 = v63 | (unsigned int)&STACK[0x3F98];
      LOBYTE(v98) = v98 - 91;
      if ( &savedregs != (int *)(v63 | (unsigned int)&STACK[0x3F98]) )
      {
LABEL_38:
        v92 |= v25;
        v32 = v33 - 8790;
        LOWORD(v90) = v90 ^ 0x35;
        v90 -= 62;
        goto LABEL_39;
      }
      v24 = (unsigned int)&savedregs | (v33 - v98) | 0xEF7;
      LOWORD(v112) = v112 + 108;
    }
    LOWORD(v115) = v115 + 9;
    v33 = v25 & v24;
    goto LABEL_38;
  }
LABEL_42:
  v28 = v74[0] & ((unsigned int)v22 - v73);
  v89 &= v28;
  v30 = (((unsigned __int16)((unsigned __int16)&savedregs - 588) ^ 0x4A6) - 6860) & 0x1EB7;
  v31 = *(_DWORD *)((char *)v74 + 1) + (v115 ^ v21) - 7863;
LABEL_43:
  LOWORD(v77) = v77 | 0xB7;
  v120 ^= 0xFBu;
  v66 &= 0xA9u;
  v96 &= 0x2Eu;
  if ( v28 | 0x3628 )
  {
    v117 |= 0xABu;
    v80 |= 0x2Du;
    v97 -= 216;
  }
  v35 = (int)&savedregs;
  v36 = *(int *)((char *)&savedregs + 1) | a4 & v31;
  v85 ^= v36;
  if ( v30 )
    goto LABEL_48;
  v47 ^= 0x63u;
  v37 = *(unsigned int *)((char *)&retaddr + 1) ^ (v87 - *(int *)((char *)&savedregs + 3));
  v122 -= (int)&savedregs;
  if ( &savedregs == (int *)941 )
  {
    v56 ^= v37;
    v36 = 321;
    v38 = MEMORY[0x149] & v37 | 0xCF7;
    v35 = 797 - v38;
    v30 = v38 - v113[0];
LABEL_48:
    v42 ^= 0x2Cu;
    v82 |= v35;
    BYTE1(v51) |= 0xF6u;
    *(_DWORD *)&v44[4] = v44[4] & 0xB1;
    v84 += *(_DWORD *)((char *)&a4 + 3) | HIDWORD(v106) & v45 & (v30 - (v36 - v35) - v109);
  }
  return &savedregs;
}
// 401E9E: conditional instruction was optimized away because of 'edx.4>=CF7u'
// 401F6B: returning address of temporary local variable '%" s"'
// 401908: variables would overlap: ^3C8.4 and ^3C9.4,^3CB.4
// 401908: variables would overlap: ^3CC.4(retaddr) and ^3CD.4,^3CE.4,^3CF.4

//----- (00401F88) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int *__usercall sub_401F88@<eax>(int a1@<eax>, int a2@<ecx>, __int128 a3)
{
  int v3; // eax
  unsigned int v4; // ecx
  HMODULE v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // eax
  char *v8; // edx
  bool v9; // cf
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // edx
  int v17; // ecx
  int v18; // ecx
  int v19; // eax
  char v21[15]; // [esp+B0h] [ebp-1D0h] BYREF
  int v22; // [esp+BFh] [ebp-1C1h]
  int v23; // [esp+D0h] [ebp-1B0h]
  char v24; // [esp+F0h] [ebp-190h] BYREF
  int v25; // [esp+10Ch] [ebp-174h]
  __int16 v26; // [esp+110h] [ebp-170h]
  __int16 v27; // [esp+120h] [ebp-160h]
  __int16 v28; // [esp+134h] [ebp-14Ch]
  int v29; // [esp+138h] [ebp-148h]
  int v30; // [esp+13Ch] [ebp-144h]
  char v31; // [esp+15Ch] [ebp-124h]
  int v32; // [esp+160h] [ebp-120h]
  int v33; // [esp+18Ch] [ebp-F4h]
  char v34[12]; // [esp+194h] [ebp-ECh] BYREF
  int v35; // [esp+1A4h] [ebp-DCh] BYREF
  int v36; // [esp+1E8h] [ebp-98h]
  char v37; // [esp+1ECh] [ebp-94h]
  int v38; // [esp+1FCh] [ebp-84h]
  int v39; // [esp+228h] [ebp-58h]
  int v40; // [esp+240h] [ebp-40h]
  int v41; // [esp+24Ch] [ebp-34h]
  int v42; // [esp+274h] [ebp-Ch]
  int savedregs; // [esp+280h] [ebp+0h] BYREF
  void *retaddr; // [esp+284h] [ebp+4h] OVERLAPPED

  v3 = a2 & a1;
  if ( a2 == v3 )
  {
    v37 -= 29;
    a2 = *(_DWORD *)((_BYTE *)&a3 + 3) & (v3 + a2);
  }
  v4 = (unsigned int)&savedregs | *(_DWORD *)((char *)&a3 + 6) | a2;
  v23 -= v4;
  v36 -= v4;
  LOBYTE(v40) = v40 | 0x3D;
  v28 -= 61;
  v40 += 254;
  v5 = GetModuleHandleA(0);
  v6 = (unsigned int)&v21[-v30];
  v7 = *(unsigned int *)((char *)&retaddr + 2) & (v22 | (unsigned int)v5);
  v8 = (char *)&savedregs + v6 - ((unsigned int)((unsigned int)&savedregs + __PAIR64__(v7, v6)) >> 32);
  v9 = (unsigned int)v8 < 0x30F;
  if ( v8 != (char *)783 )
    goto LABEL_10;
  v10 = 80;
  v11 = ((v7 & 0x202) - 80) | 0x50;
  if ( v11 == 211 )
  {
LABEL_12:
    v26 |= 0xDu;
    v42 += v10 - (v6 - v10);
    return &savedregs;
  }
  v12 = v32 ^ 0x50;
  v13 = 2 * (v11 - (v32 ^ 0x50));
  v14 = (v32 ^ 0x50) & v6;
  if ( (v32 ^ 0x50) == v13 )
  {
LABEL_11:
    v27 += 181;
    v6 = (unsigned int)&v35;
    v19 = v35 | v13;
    v10 = (int)&v24;
    v31 ^= 0xBBu;
    v33 ^= v19;
    goto LABEL_12;
  }
  v15 = v39 | (v14 - v12);
  v16 = v12 | 0x2616;
  v17 = v16 + v15;
  v29 -= v16;
  if ( v17 != 114 )
  {
    v18 = v17 ^ 0x1CC2;
    v7 = v13 - (_DWORD)v34;
    if ( v34 != (char *)v18 )
    {
      v38 &= v18;
      v25 |= 0xD1u;
    }
    v41 -= (int)v34;
    v9 = 0;
    v6 = 0;
LABEL_10:
    v13 = v9 + v7 - v6;
    goto LABEL_11;
  }
  return &savedregs;
}
// 401F88: variables would overlap: ^287.1 and ^287.4
// 401F88: variables would overlap: ^288.4(retaddr) and ^28A.4
// 40218D: returning address of temporary local variable '%" s"'
// 401F88: using guessed type char var_1D0[15];

//----- (00402308) --------------------------------------------------------
#error "40240D: call analysis failed (funcsize=1986)"

// nfuncs=3 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 3 function(s)"
