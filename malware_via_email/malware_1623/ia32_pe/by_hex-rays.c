/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall start(int a1@<eax>, __int16 a2@<dx>, __int16 a3@<cx>, int _EBX@<ebx>, int a5@<edi>, int _ESI@<esi>);
double sub_40DCA2(); // weak


//----- (0040C352) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall start(int a1@<eax>, __int16 a2@<dx>, __int16 a3@<cx>, int _EBX@<ebx>, int a5@<edi>, int _ESI@<esi>)
{
  bool v11; // cf
  int v12; // edi
  int v14; // ebx
  bool v19; // zf

  _DX = a3 + a2;
  HIBYTE(a3) ^= _EBX;
  HIBYTE(_DX) <<= a3;
  LOWORD(_ESI) = (a1 | _ESI) - __ROR2__(a3, a3);
  _CL = 29;
  HIBYTE(_DX) ^= 0xC0u;
  LOBYTE(_DX) = __ROL1__(29 - _DX, 29);
  LOWORD(_ESI) = _ESI - 1;
  LOBYTE(a1) = a1 + 1;
  BYTE1(_EBX) = BYTE1(_EBX) & 0xE8 | 0x77;
  __asm
  {
    rcl     esi, 0Dh
    rcr     dx, cl
  }
  LOBYTE(_EBX) = -(char)_EBX;
  v12 = a5 << 22;
  __asm { rcr     bh, cl }
  LOWORD(v12) = (v12 + 1) | 0xE81D;
  BYTE1(a1) = _EBX;
  _ESI = __ROR4__(_ESI, 29);
  _EBX = (int)__ROL4__(_EBX, 26) >> 21;
  BYTE1(a1) -= 29;
  _EAX = __ROR4__(a1, 19);
  v11 = __CFADD__(__CFSHR__(v12, 7), BYTE1(_EBX));
  BYTE1(_EBX) += __CFSHR__(v12, 7);
  v11 |= __CFADD__((_BYTE)_EBX, BYTE1(_EBX));
  BYTE1(_EBX) += _EBX;
  LOBYTE(_EBX) = _EAX + v11 + _EBX;
  _EBX >>= 29;
  LOWORD(_EAX) = -108;
  __asm
  {
    rcr     al, cl
    rcl     eax, cl
  }
  BYTE1(_EAX) -= 24;
  BYTE1(_EBX) = -103;
  __asm { rcr     bx, cl }
  HIBYTE(_DX) = -24;
  LOWORD(_EAX) = -(__int16)_EAX;
  __asm
  {
    rcr     esi, 0Ah
    rcl     dh, cl
  }
  v14 = (unsigned __int8)(HIBYTE(_DX) + __CFSHR__(_EAX, 27) + ((unsigned int)_EBX >> 29) + 8);
  _EDI = (int)__ROL4__(__ROL4__(1195304989, 20), 26) >> 22;
  __asm { rcl     di, cl }
  BYTE1(v14) = 0;
  _EBX = __ROR4__(v14 + 1, 13);
  LOWORD(_EBX) = -12288;
  _EBX >>= 29;
  BYTE1(_EBX) += 126;
  v19 = BYTE1(_EBX) == 0;
  __asm { rcr     ebx, cl }
  if ( !v19 && v19 )
  {
    __asm { iret }
    JUMPOUT(0x40C973);
  }
  JUMPOUT(0x40C43F);
}
// 40C782: positive sp value 20 has been found
// 40BF07: control flows out of bounds to 40BF09
// 40BF32: control flows out of bounds to 40BF33
// 40BFA2: control flows out of bounds to 40BFA3
// 40C0D8: control flows out of bounds to 40C0DE
// 40C1D5: control flows out of bounds to 40C1DB
// 40C253: control flows out of bounds to 40C254
// 40C2B3: control flows out of bounds to 40C2B5
// 40C407: control flows out of bounds to 40C40D
// 40C55C: control flows out of bounds to 40C55D
// 40C5AA: control flows out of bounds to 40C5AB
// 40C753: control flows out of bounds to 40C754
// 40C9B0: control flows out of bounds to 40C9B2
// 40C9FA: control flows out of bounds to 40C9FB
// 40C972: control flows out of bounds to 40C973
// 40BF9B: control flows out of bounds to 40C89F
// 40BFE9: control flows out of bounds to 40C787
// 40C12C: control flows out of bounds to 40BF5A
// 40C169: control flows out of bounds to 40C67E
// 40C264: control flows out of bounds to 40C336
// 40C5C6: control flows out of bounds to 40C840
// 40C851: control flows out of bounds to 40C8C5
// 40C946: control flows out of bounds to 40C655
// 40C0D0: control flows out of bounds to 40C517
// 40C2F2: control flows out of bounds to 40C04D
// 40C650: control flows out of bounds to 40C613
// 40C67D: control flows out of bounds to 40C652
// 40C7D2: control flows out of bounds to 40C209
// 40C7E0: control flows out of bounds to 40C7D7
// 40C82E: control flows out of bounds to 40C029
// 40C964: control flows out of bounds to 40C43F
// 40C989: control flows out of bounds to 40C942
// 40BF50: conditional instruction was optimized away because of 'bh.1>=99u'
// 40BF54: conditional instruction was optimized away because of 'bh.1>=99u'
// 40BFBB: conditional instruction was optimized away because of 'bl.1!=0'
// 40C1FF: conditional instruction was optimized away because of 'ah.1!=0'
// 40C705: conditional instruction was optimized away because of 'edi.4!=0'
// 40C751: conditional instruction was optimized away because of 'esi.4!=0'
// 40DCA2: using guessed type double sub_40DCA2();

//----- (0040DCA2) --------------------------------------------------------
#error "40DD3F: cannot convert to microcode (funcsize=702)"

// nfuncs=2 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2 function(s)"
