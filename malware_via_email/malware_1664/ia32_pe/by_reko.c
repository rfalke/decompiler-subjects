// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t11694; // 00411000
<anonymous> * __imp__InitializeCriticalSection = &g_t116A6; // 00411004
<anonymous> * __imp__LocalFree = &g_t116C2; // 00411008
<anonymous> * __imp__HeapDestroy = &g_t116CE; // 0041100C
<anonymous> * __imp__LocalFree = &g_t116DC; // 00411010
<anonymous> * __imp__CreateFileW = &g_t116E8; // 00411014
<anonymous> * __imp__InterlockedCompareExchange = &g_t116F6; // 00411018
<anonymous> * __imp__InterlockedIncrement = &g_t11714; // 0041101C
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t1172C; // 00411020
<anonymous> * __imp__LoadLibraryA = &g_t11748; // 00411024
<anonymous> * __imp__InterlockedIncrement = &g_t11758; // 00411028
<anonymous> * __imp__LoadLibraryW = &g_t11770; // 0041102C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t11780; // 00411030
<anonymous> * __imp__InterlockedCompareExchange = &g_t1179A; // 00411034
<anonymous> * __imp__CreateThread = &g_t117B8; // 00411038
<anonymous> * __imp__GetModuleHandleW = &g_t117C8; // 0041103C
<anonymous> * __imp__CreateThread = &g_t117DC; // 00411040
<anonymous> * __imp__LoadLibraryA = &g_t117EC; // 00411044
<anonymous> * __imp__GetModuleHandleW = &g_t117FC; // 00411048
<anonymous> * __imp__LoadLibraryW = &g_t11810; // 0041104C
<anonymous> * __imp__lstrlenA = &g_t11820; // 00411050
<anonymous> * __imp__DeleteCriticalSection = &g_t1182C; // 00411054
<anonymous> * __imp__InterlockedDecrement = &g_t11844; // 00411058
<anonymous> * __imp__HeapFree = &g_t1185C; // 0041105C
<anonymous> * __imp__GetTickCount = &g_t11868; // 00411060
<anonymous> * __imp__VirtualAlloc = &g_t11878; // 00411064
<anonymous> * __imp__UnhandledExceptionFilter = &g_t11888; // 00411068
<anonymous> * __imp__LeaveCriticalSection = &g_t118A4; // 0041106C
<anonymous> * __imp__HeapFree = &g_t118BC; // 00411070
<anonymous> * __imp__MultiByteToWideChar = &g_t118C8; // 00411074
<anonymous> * __imp__GetModuleHandleW = &g_t118DE; // 00411078
<anonymous> * __imp__GetModuleFileNameW = &g_t118F2; // 0041107C
<anonymous> * __imp__GetCurrentProcess = &g_t11908; // 00411080
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t1191C; // 00411084
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t11938; // 00411088
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t11952; // 0041108C
<anonymous> * __imp__GetModuleFileNameA = &g_t1196E; // 00411090
<anonymous> * __imp__GetProcessHeap = &g_t11984; // 00411094
<anonymous> * __imp__InterlockedDecrement = &g_t11996; // 00411098
<anonymous> * __imp__GetProcAddress = &g_t119AE; // 0041109C
<anonymous> * __imp__DeleteCriticalSection = &g_t119C0; // 004110A0
<anonymous> * __imp__VirtualProtect = &g_t119D8; // 004110A4
<anonymous> * __imp__GetModuleFileNameA = &g_t119EA; // 004110A8
<anonymous> * __imp__GetModuleFileNameA = &g_t11A00; // 004110AC
<anonymous> * __imp__InterlockedIncrement = &g_t11A16; // 004110B0
<anonymous> * __imp__lstrlenA = &g_t11A2E; // 004110B4
<anonymous> * __imp__GetModuleFileNameA = &g_t11A3A; // 004110B8
<anonymous> * __imp__GetModuleHandleA = &g_t11A50; // 004110BC
<anonymous> * __imp__InitializeCriticalSection = &g_t11A64; // 004110C0
<anonymous> * __imp__ReadFile = &g_t11A80; // 004110C4
<anonymous> * __imp__Sleep = &g_t11A8C; // 004110C8
<anonymous> * __imp__VirtualProtect = &g_t11A94; // 004110CC
<anonymous> * __imp__InterlockedIncrement = &g_t11AA6; // 004110D0
<anonymous> * __imp__CloseHandle = &g_t11ABE; // 004110D4
<anonymous> * __imp__MultiByteToWideChar = &g_t11ACC; // 004110D8
<anonymous> * __imp__VirtualAlloc = &g_t11AE2; // 004110DC
<anonymous> * __imp__GetLastError = &g_t11AF2; // 004110E0
<anonymous> * __imp__GetLastError = &g_t11B02; // 004110E4
<anonymous> * __imp__GetModuleFileNameA = &g_t11B12; // 004110E8
<anonymous> * __imp__GetProcessHeap = &g_t11B28; // 004110EC
<anonymous> * __imp__lstrcmpiW = &g_t11B3A; // 004110F0
<anonymous> * __imp__InterlockedIncrement = &g_t11B46; // 004110F4
<anonymous> * __imp__VirtualAlloc = &g_t11B5E; // 004110F8
<anonymous> * __imp__CloseHandle = &g_t11B6E; // 004110FC
<anonymous> * __imp__GetModuleFileNameW = &g_t11B7C; // 00411100
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t11B92; // 00411104
<anonymous> * __imp__HeapFree = &g_t11BAC; // 00411108
<anonymous> * __imp__GetModuleFileNameA = &g_t11BB8; // 0041110C
<anonymous> * __imp__FreeLibrary = &g_t11BCE; // 00411110
<anonymous> * __imp__ReleaseDC = &g_t11BEA; // 00411118
<anonymous> * __imp__DestroyWindow = &g_t11BF6; // 0041111C
<anonymous> * __imp__DestroyWindow = &g_t11C06; // 00411120
<anonymous> * __imp__MessageBoxW = &g_t11C16; // 00411124
<anonymous> * __imp__InvalidateRect = &g_t11C24; // 00411128
<anonymous> * __imp__GetDlgItem = &g_t11C36; // 0041112C
<anonymous> * __imp__LoadCursorW = &g_t11C44; // 00411130
<anonymous> * __imp__SetWindowPos = &g_t11C52; // 00411134
<anonymous> * __imp__DispatchMessageW = &g_t11C62; // 00411138
<anonymous> * __imp__PostMessageW = &g_t11C76; // 0041113C
<anonymous> * __imp__SetForegroundWindow = &g_t11C86; // 00411140
<anonymous> * __imp__TranslateMessage = &g_t11C9C; // 00411144
<anonymous> * __imp__IsWindow = &g_t11CB0; // 00411148
<anonymous> * __imp__SetWindowLongW = &g_t11CBC; // 0041114C
<anonymous> * __imp__SendDlgItemMessageW = &g_t11CCE; // 00411150
<anonymous> * __imp__EndPaint = &g_t11CE4; // 00411154
<anonymous> * __imp__GetDesktopWindow = &g_t11CF0; // 00411158
<anonymous> * __imp__SetWindowTextW = &g_t11D04; // 0041115C
<anonymous> * __imp__LoadIconW = &g_t11D16; // 00411160
<anonymous> * __imp__SetWindowPos = &g_t11D22; // 00411164
<anonymous> * __imp__GetFocus = &g_t11D32; // 00411168
<anonymous> * __imp__CreateWindowExW = &g_t11D3E; // 0041116C
<anonymous> * __imp__ReleaseDC = &g_t11D50; // 00411170
<anonymous> * __imp__PeekMessageW = &g_t11D5C; // 00411174
<anonymous> * __imp__SetWindowTextW = &g_t11D6C; // 00411178
<anonymous> * __imp__GetClientRect = &g_t11D7E; // 0041117C
<anonymous> * __imp__GetDlgItem = &g_t11D8E; // 00411180
<anonymous> * __imp__PostQuitMessage = &g_t11D9C; // 00411184
<anonymous> * __imp__TranslateMessage = &g_t11DAE; // 00411188
<anonymous> * __imp__EnableWindow = &g_t11DC2; // 0041118C
<anonymous> * __imp__SetTimer = &g_t11DD2; // 00411190
<anonymous> * __imp__GetClientRect = &g_t11DDE; // 00411194
<anonymous> * __imp__ShowWindow = &g_t11DEE; // 00411198
<anonymous> * __imp__wsprintfA = &g_t11DFC; // 0041119C
<anonymous> * __imp__ShowWindow = &g_t11E08; // 004111A0
<anonymous> * __imp__SetFocus = &g_t11E16; // 004111A4
<anonymous> * __imp__PeekMessageW = &g_t11E22; // 004111A8
<anonymous> * __imp__GetDesktopWindow = &g_t11E32; // 004111AC
<anonymous> * __imp__SetDlgItemTextW = &g_t11E46; // 004111B0
<anonymous> * __imp__GetSysColor = &g_t11E58; // 004111B4
<anonymous> * __imp__DispatchMessageW = &g_t11E66; // 004111B8
<anonymous> * __imp__ReleaseDC = &g_t11E7A; // 004111BC
<anonymous> * __imp__GetFocus = &g_t11E86; // 004111C0
<anonymous> * __imp__wsprintfA = &g_t11E92; // 004111C4
<anonymous> * __imp__SetWindowPos = &g_t11E9E; // 004111C8
<anonymous> * __imp__GetWindowLongW = &g_t11EAE; // 004111CC
<anonymous> * __imp__DispatchMessageW = &g_t11EC0; // 004111D0
<anonymous> * __imp__GetDlgItem = &g_t11ED4; // 004111D4
<anonymous> * __imp__MessageBoxW = &g_t11EE2; // 004111D8
<anonymous> * __imp__SendMessageW = &g_t11EF0; // 004111DC
<anonymous> * __imp__SetTimer = &g_t11F00; // 004111E0
<anonymous> * __imp__InvalidateRect = &g_t11F0C; // 004111E4
<anonymous> * __imp__GetWindowRect = &g_t11F1E; // 004111E8
<anonymous> * __imp__SendDlgItemMessageW = &g_t11F2E; // 004111EC
<anonymous> * __imp__BeginPaint = &g_t11F44; // 004111F0
<anonymous> * __imp__GetFocus = &g_t11F52; // 004111F4
<anonymous> * __imp__DialogBoxParamW = &g_t11F5E; // 004111F8
<anonymous> * __imp__EndPaint = &g_t11F70; // 004111FC
<anonymous> * __imp__ShowWindow = &g_t11F7C; // 00411200
<anonymous> * __imp__SetForegroundWindow = &g_t11F8A; // 00411204
<anonymous> * __imp__GetSystemMetrics = &g_t11FA0; // 00411208
<anonymous> * __imp__GetWindowExtEx = &g_t11FC0; // 00411210
<anonymous> * __imp__GetCurrentObject = &g_t11FD2; // 00411214
<anonymous> * __imp__LineTo = &g_t11FE6; // 00411218
<anonymous> * __imp__GetBkColor = &g_t11FF0; // 0041121C
<anonymous> * __imp__GetWindowExtEx = &g_t11FFE; // 00411220
<anonymous> * __imp__SetWindowExtEx = &g_t12010; // 00411224
<anonymous> * __imp__CreatePen = &g_t12022; // 00411228
<anonymous> * __imp__GetWindowOrgEx = &g_t1202E; // 0041122C
<anonymous> * __imp__GetPixel = &g_t12040; // 00411230
<anonymous> * __imp__CreatePen = &g_t1204C; // 00411234
<anonymous> * __imp__Polygon = &g_t12058; // 00411238
<anonymous> * __imp__SetPixel = &g_t12062; // 0041123C
<anonymous> * __imp__BitBlt = &g_t1206E; // 00411240
<anonymous> * __imp__BitBlt = &g_t12078; // 00411244
<anonymous> * __imp__GetCurrentObject = &g_t12082; // 00411248
<anonymous> * __imp__CreateDIBitmap = &g_t12096; // 0041124C
<anonymous> * __imp__Ellipse = &g_t120A8; // 00411250
<anonymous> * __imp__Ellipse = &g_t120B2; // 00411254
<anonymous> * __imp__GetBkMode = &g_t120BC; // 00411258
<anonymous> * __imp__StretchBlt = &g_t120C8; // 0041125C
<anonymous> * __imp__RoundRect = &g_t120D6; // 00411260
<anonymous> * __imp__CreateDIBSection = &g_t120E2; // 00411264
<anonymous> * __imp__SetTextColor = &g_t120F6; // 00411268
<anonymous> * __imp__MoveToEx = &g_t12106; // 0041126C
<anonymous> * __imp__MoveToEx = &g_t12112; // 00411270
<anonymous> * __imp__SetPixel = &g_t1211E; // 00411274
<anonymous> * __imp__SetWindowExtEx = &g_t1212A; // 00411278
<anonymous> * __imp__Ellipse = &g_t1213C; // 0041127C
<anonymous> * __imp__CreateFontIndirectA = &g_t12146; // 00411280
<anonymous> * __imp__Ellipse = &g_t1215C; // 00411284
<anonymous> * __imp__CreateFontIndirectA = &g_t12166; // 00411288
<anonymous> * __imp__CreateFontA = &g_t1217C; // 0041128C
<anonymous> * __imp__GetPixel = &g_t1218A; // 00411290
<anonymous> * __imp__CreateSolidBrush = &g_t12196; // 00411294
<anonymous> * __imp__GetWindowExtEx = &g_t121AA; // 00411298
<anonymous> * __imp__CreateSolidBrush = &g_t121BC; // 0041129C
<anonymous> * __imp__CreateFontIndirectA = &g_t121D0; // 004112A0
<anonymous> * __imp__Rectangle = &g_t121E6; // 004112A4
<anonymous> * __imp__SelectObject = &g_t121F2; // 004112A8
<anonymous> * __imp__Ellipse = &g_t12202; // 004112AC
<anonymous> * __imp__CreateDIBSection = &g_t1220C; // 004112B0
<anonymous> * __imp__CreateBitmapIndirect = &g_t12220; // 004112B4
<anonymous> * __imp__LineTo = &g_t12238; // 004112B8
<anonymous> * __imp__Ellipse = &g_t12242; // 004112BC
<anonymous> * __imp__SetWindowOrgEx = &g_t1224C; // 004112C0
<anonymous> * __imp__Polygon = &g_t1225E; // 004112C4
<anonymous> * __imp__SetPixel = &g_t12268; // 004112C8
<anonymous> * __imp__Ellipse = &g_t12274; // 004112CC
<anonymous> * __imp__SelectObject = &g_t1227E; // 004112D0
<anonymous> * __imp__GetWindowExtEx = &g_t1228E; // 004112D4
<anonymous> * __imp__SetTextColor = &g_t122A0; // 004112D8
<anonymous> * __imp__GetBkMode = &g_t122B0; // 004112DC
<anonymous> * __imp__StretchBlt = &g_t122BC; // 004112E0
<anonymous> * __imp__GetPixel = &g_t122CA; // 004112E4
<anonymous> * __imp__CombineRgn = &g_t122D6; // 004112E8
<anonymous> * __imp__MoveToEx = &g_t122E4; // 004112EC
<anonymous> * __imp__CreateBitmap = &g_t122F0; // 004112F0
<anonymous> * __imp__SetWindowOrgEx = &g_t12300; // 004112F4
<anonymous> * __imp__PatBlt = &g_t12312; // 004112F8
<anonymous> * __imp__BitBlt = &g_t1231C; // 004112FC
<anonymous> * __imp__GetPixel = &g_t12326; // 00411300
<anonymous> * __imp__CreateDIBSection = &g_t12332; // 00411304
<anonymous> * __imp__PatBlt = &g_t12346; // 00411308
<anonymous> * __imp__CreateRectRgn = &g_t12350; // 0041130C
<anonymous> * __imp__GetWindowExtEx = &g_t12360; // 00411310
<anonymous> * __imp__GetBkMode = &g_t12372; // 00411314
<anonymous> * __imp__GetBkMode = &g_t1237E; // 00411318
word32 g_dw411374 = 0x00011694; // 00411374
word32 g_dw411378 = 0x000116A6; // 00411378
word32 g_dw41137C = 0x000116C2; // 0041137C
word32 g_dw411380 = 0x000116CE; // 00411380
word32 g_dw411384 = 0x000116DC; // 00411384
word32 g_dw411388 = 0x000116E8; // 00411388
word32 g_dw41138C = 0x000116F6; // 0041138C
word32 g_dw411390 = 0x00011714; // 00411390
word32 g_dw411394 = 0x0001172C; // 00411394
word32 g_dw411398 = 0x00011748; // 00411398
word32 g_dw41139C = 0x00011758; // 0041139C
word32 g_dw4113A0 = 0x00011770; // 004113A0
word32 g_dw4113A4 = 0x00011780; // 004113A4
word32 g_dw4113A8 = 0x0001179A; // 004113A8
word32 g_dw4113AC = 0x000117B8; // 004113AC
word32 g_dw4113B0 = 0x000117C8; // 004113B0
word32 g_dw4113B4 = 0x000117DC; // 004113B4
word32 g_dw4113B8 = 0x000117EC; // 004113B8
word32 g_dw4113BC = 71676; // 004113BC
word32 g_dw4113C0 = 0x00011810; // 004113C0
word32 g_dw4113C4 = 71712; // 004113C4
word32 g_dw4113C8 = 0x0001182C; // 004113C8
word32 g_dw4113CC = 0x00011844; // 004113CC
word32 g_dw4113D0 = 71772; // 004113D0
word32 g_dw4113D4 = 0x00011868; // 004113D4
word32 g_dw4113D8 = 0x00011878; // 004113D8
word32 g_dw4113DC = 0x00011888; // 004113DC
word32 g_dw4113E0 = 0x000118A4; // 004113E0
word32 g_dw4113E4 = 0x000118BC; // 004113E4
word32 g_dw4113E8 = 0x000118C8; // 004113E8
word32 g_dw4113EC = 0x000118DE; // 004113EC
word32 g_dw4113F0 = 0x000118F2; // 004113F0
word32 g_dw4113F4 = 0x00011908; // 004113F4
word32 g_dw4113F8 = 0x0001191C; // 004113F8
word32 g_dw4113FC = 0x00011938; // 004113FC
word32 g_dw411400 = 0x00011952; // 00411400
word32 g_dw411404 = 0x0001196E; // 00411404
word32 g_dw411408 = 0x00011984; // 00411408
word32 g_dw41140C = 0x00011996; // 0041140C
word32 g_dw411410 = 0x000119AE; // 00411410
word32 g_dw411414 = 0x000119C0; // 00411414
word32 g_dw411418 = 0x000119D8; // 00411418
word32 g_dw41141C = 0x000119EA; // 0041141C
word32 g_dw411420 = 0x00011A00; // 00411420
word32 g_dw411424 = 0x00011A16; // 00411424
word32 g_dw411428 = 0x00011A2E; // 00411428
word32 g_dw41142C = 0x00011A3A; // 0041142C
word32 g_dw411430 = 72272; // 00411430
word32 g_dw411434 = 72292; // 00411434
word32 g_dw411438 = 0x00011A80; // 00411438
word32 g_dw41143C = 72332; // 0041143C
word32 g_dw411440 = 0x00011A94; // 00411440
word32 g_dw411444 = 0x00011AA6; // 00411444
word32 g_dw411448 = 0x00011ABE; // 00411448
word32 g_dw41144C = 0x00011ACC; // 0041144C
word32 g_dw411450 = 0x00011AE2; // 00411450
word32 g_dw411454 = 0x00011AF2; // 00411454
word32 g_dw411458 = 0x00011B02; // 00411458
word32 g_dw41145C = 0x00011B12; // 0041145C
word32 g_dw411460 = 0x00011B28; // 00411460
word32 g_dw411464 = 0x00011B3A; // 00411464
word32 g_dw411468 = 0x00011B46; // 00411468
word32 g_dw41146C = 0x00011B5E; // 0041146C
word32 g_dw411470 = 0x00011B6E; // 00411470
word32 g_dw411474 = 72572; // 00411474
word32 g_dw411478 = 0x00011B92; // 00411478
word32 g_dw41147C = 0x00011BAC; // 0041147C
word32 g_dw411480 = 0x00011BB8; // 00411480
word32 g_dw411484 = 0x00011BCE; // 00411484
word32 g_dw41148C = 0x00011BEA; // 0041148C
word32 g_dw411490 = 0x00011BF6; // 00411490
word32 g_dw411494 = 0x00011C06; // 00411494
word32 g_dw411498 = 0x00011C16; // 00411498
word32 g_dw41149C = 0x00011C24; // 0041149C
word32 g_dw4114A0 = 0x00011C36; // 004114A0
word32 g_dw4114A4 = 72772; // 004114A4
word32 g_dw4114A8 = 0x00011C52; // 004114A8
word32 g_dw4114AC = 0x00011C62; // 004114AC
word32 g_dw4114B0 = 72822; // 004114B0
word32 g_dw4114B4 = 0x00011C86; // 004114B4
word32 g_dw4114B8 = 0x00011C9C; // 004114B8
word32 g_dw4114BC = 0x00011CB0; // 004114BC
word32 g_dw4114C0 = 0x00011CBC; // 004114C0
word32 g_dw4114C4 = 0x00011CCE; // 004114C4
word32 g_dw4114C8 = 0x00011CE4; // 004114C8
word32 g_dw4114CC = 0x00011CF0; // 004114CC
word32 g_dw4114D0 = 0x00011D04; // 004114D0
word32 g_dw4114D4 = 0x00011D16; // 004114D4
word32 g_dw4114D8 = 0x00011D22; // 004114D8
word32 g_dw4114DC = 0x00011D32; // 004114DC
word32 g_dw4114E0 = 0x00011D3E; // 004114E0
word32 g_dw4114E4 = 0x00011D50; // 004114E4
word32 g_dw4114E8 = 0x00011D5C; // 004114E8
word32 g_dw4114EC = 0x00011D6C; // 004114EC
word32 g_dw4114F0 = 0x00011D7E; // 004114F0
word32 g_dw4114F4 = 0x00011D8E; // 004114F4
word32 g_dw4114F8 = 0x00011D9C; // 004114F8
word32 g_dw4114FC = 0x00011DAE; // 004114FC
word32 g_dw411500 = 0x00011DC2; // 00411500
word32 g_dw411504 = 0x00011DD2; // 00411504
word32 g_dw411508 = 0x00011DDE; // 00411508
word32 g_dw41150C = 0x00011DEE; // 0041150C
word32 g_dw411510 = 0x00011DFC; // 00411510
word32 g_dw411514 = 0x00011E08; // 00411514
word32 g_dw411518 = 0x00011E16; // 00411518
word32 g_dw41151C = 0x00011E22; // 0041151C
word32 g_dw411520 = 0x00011E32; // 00411520
word32 g_dw411524 = 0x00011E46; // 00411524
word32 g_dw411528 = 0x00011E58; // 00411528
word32 g_dw41152C = 0x00011E66; // 0041152C
word32 g_dw411530 = 73338; // 00411530
word32 g_dw411534 = 0x00011E86; // 00411534
word32 g_dw411538 = 0x00011E92; // 00411538
word32 g_dw41153C = 0x00011E9E; // 0041153C
word32 g_dw411540 = 0x00011EAE; // 00411540
word32 g_dw411544 = 0x00011EC0; // 00411544
word32 g_dw411548 = 0x00011ED4; // 00411548
word32 g_dw41154C = 0x00011EE2; // 0041154C
word32 g_dw411550 = 0x00011EF0; // 00411550
word32 g_dw411554 = 0x00011F00; // 00411554
word32 g_dw411558 = 0x00011F0C; // 00411558
word32 g_dw41155C = 0x00011F1E; // 0041155C
word32 g_dw411560 = 0x00011F2E; // 00411560
word32 g_dw411564 = 0x00011F44; // 00411564
word32 g_dw411568 = 0x00011F52; // 00411568
word32 g_dw41156C = 0x00011F5E; // 0041156C
word32 g_dw411570 = 0x00011F70; // 00411570
word32 g_dw411574 = 0x00011F7C; // 00411574
word32 g_dw411578 = 0x00011F8A; // 00411578
word32 g_dw41157C = 0x00011FA0; // 0041157C
word32 g_dw411584 = 0x00011FC0; // 00411584
word32 g_dw411588 = 0x00011FD2; // 00411588
word32 g_dw41158C = 0x00011FE6; // 0041158C
word32 g_dw411590 = 0x00011FF0; // 00411590
word32 g_dw411594 = 0x00011FFE; // 00411594
word32 g_dw411598 = 0x00012010; // 00411598
word32 g_dw41159C = 0x00012022; // 0041159C
word32 g_dw4115A0 = 73774; // 004115A0
word32 g_dw4115A4 = 0x00012040; // 004115A4
word32 g_dw4115A8 = 0x0001204C; // 004115A8
word32 g_dw4115AC = 0x00012058; // 004115AC
word32 g_dw4115B0 = 0x00012062; // 004115B0
word32 g_dw4115B4 = 73838; // 004115B4
word32 g_dw4115B8 = 73848; // 004115B8
word32 g_dw4115BC = 0x00012082; // 004115BC
word32 g_dw4115C0 = 73878; // 004115C0
word32 g_dw4115C4 = 0x000120A8; // 004115C4
word32 g_dw4115C8 = 0x000120B2; // 004115C8
word32 g_dw4115CC = 0x000120BC; // 004115CC
word32 g_dw4115D0 = 0x000120C8; // 004115D0
word32 g_dw4115D4 = 0x000120D6; // 004115D4
word32 g_dw4115D8 = 0x000120E2; // 004115D8
word32 g_dw4115DC = 73974; // 004115DC
word32 g_dw4115E0 = 0x00012106; // 004115E0
word32 g_dw4115E4 = 0x00012112; // 004115E4
word32 g_dw4115E8 = 0x0001211E; // 004115E8
word32 g_dw4115EC = 0x0001212A; // 004115EC
word32 g_dw4115F0 = 74044; // 004115F0
word32 g_dw4115F4 = 0x00012146; // 004115F4
word32 g_dw4115F8 = 0x0001215C; // 004115F8
word32 g_dw4115FC = 0x00012166; // 004115FC
word32 g_dw411600 = 0x0001217C; // 00411600
word32 g_dw411604 = 0x0001218A; // 00411604
word32 g_dw411608 = 0x00012196; // 00411608
word32 g_dw41160C = 0x000121AA; // 0041160C
word32 g_dw411610 = 0x000121BC; // 00411610
word32 g_dw411614 = 0x000121D0; // 00411614
word32 g_dw411618 = 0x000121E6; // 00411618
word32 g_dw41161C = 0x000121F2; // 0041161C
word32 g_dw411620 = 0x00012202; // 00411620
word32 g_dw411624 = 0x0001220C; // 00411624
word32 g_dw411628 = 0x00012220; // 00411628
word32 g_dw41162C = 0x00012238; // 0041162C
word32 g_dw411630 = 0x00012242; // 00411630
word32 g_dw411634 = 0x0001224C; // 00411634
word32 g_dw411638 = 74334; // 00411638
word32 g_dw41163C = 74344; // 0041163C
word32 g_dw411640 = 0x00012274; // 00411640
word32 g_dw411644 = 0x0001227E; // 00411644
word32 g_dw411648 = 0x0001228E; // 00411648
word32 g_dw41164C = 74400; // 0041164C
word32 g_dw411650 = 0x000122B0; // 00411650
word32 g_dw411654 = 0x000122BC; // 00411654
word32 g_dw411658 = 74442; // 00411658
word32 g_dw41165C = 74454; // 0041165C
word32 g_dw411660 = 0x000122E4; // 00411660
word32 g_dw411664 = 0x000122F0; // 00411664
word32 g_dw411668 = 0x00012300; // 00411668
word32 g_dw41166C = 0x00012312; // 0041166C
word32 g_dw411670 = 0x0001231C; // 00411670
word32 g_dw411674 = 0x00012326; // 00411674
word32 g_dw411678 = 0x00012332; // 00411678
word32 g_dw41167C = 74566; // 0041167C
word32 g_dw411680 = 74576; // 00411680
word32 g_dw411684 = 0x00012360; // 00411684
word32 g_dw411688 = 0x00012372; // 00411688
word32 g_dw41168C = 74622; // 0041168C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040C3E7: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
l0040C3E7:
	--ebx;
	&cl.u2->u0 = (byte) cl + 1;
	&cl.u2->u0 = (byte) cl + 1;
	&bh.u2->u0 = (byte) bh + 0x007C;
	ah -= 0x67;
	SCZO = cond(ah);
	v10 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rcl<byte,byte>(ah, cl, C);
	esi -= eax;
	v14 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rol<word32,byte>(eax, cl);
	bl = bl ^ ~0x22;
	--edx;
	edx -= edi;
	SCZO = cond(edx);
	ecx.u0 = 2590037053;
	ebx = ebx - edi - C;
	SCZO = cond(ebx);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			v22 = edx;
			edx = eax;
			eax = v22;
			if (Test(OV,O))
			{
l0040C45A:
				ebx = ebx - edi - C;
				v30 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				ebx |= ecx;
				cl &= 151;
				&cl.u2->u0 = (byte) cl + 1;
				v31 = (bl & 0x01 << 0x08 - cl) != 0x00;
				bl = __rol<byte,byte>(bl, cl);
				edi += eax;
				bh <<= cl;
				esi <<= cl;
				SCZO = cond(esi);
				--esi;
				C = bh != 0x00;
				bh = -bh;
				SZO = cond(bh);
				goto l0040C84C;
			}
l0040C416:
			ecx = (word32) mm0;
			bl = bl - 0x05 - C;
			&ah.u2->u0 = (byte) ah + 1;
			--edx;
			al -= bl;
			ah = ah ^ 0x5A;
			SZ = cond(ah);
			O = false;
			C.u0 = false;
			esi -= eax;
			SCZO = cond(esi);
l0040C5E9:
			dh.u0 = 0x26;
			al.u0 = 101;
			v32 = (bh & 0x01 << 0x08 - cl) != 0x00;
			bh = __rol<byte,byte>(bh, cl);
			C = v32;
			dh = dh + cl + C;
			SCZO = cond(dh);
			dl = dl + bl + C;
			SCZO = cond(dl);
l0040C5F4:
			SCZO = cond(ecx - 1218306202);
			if (Test(EQ,Z))
			{
l0040C564:
				edi = -edi;
				&bl.u2->u0 = (byte) bl + 60;
				SCZO = cond(bl);
				if (Test(NE,Z))
				{
					ecx = ecx;
					if (Test(EQ,Z))
					{
						fn2B3B_D2C0();
						return;
					}
				}
				esi >>= cl;
				ch |= dh;
				C.u0 = false;
				&al.u2->u0 = (byte) al + 1;
				bl = bl + ch + C;
				al = al ^ 0x86;
				cl -= 0x95;
				ah >>= cl;
				SCZO = cond(ah);
				&al.u2->u0 = (bool) C.u0 + ((byte) al + 77);
				ch >>= cl;
				v62 = Mem0[fs:0x30:word32];
				esp -= (union Eq_3 *) 4;
				*esp = v62;
				eax = *esp;
				esp += 4;
				v63 = (bl & 0x01 << cl) != 0x00;
				bl = __ror<byte,byte>(bl, cl);
				dh -= 0x36;
				SCZO = cond(dh);
				edx = edi;
				cl &= 0x90;
				dl -= 0x91;
				SCZO = cond(dl);
				cl = cl - 0x08 - C;
				bh -= dl;
				SCZO = cond(bh);
				bh = bh + dh + C;
				SCZO = cond(bh);
				bl = bl + ch + C;
				ebx >>= cl;
				--dl;
				edx = edx ^ eax;
				v64 = *((byte) eax.u0 + 144);
				esp -= (union Eq_3 *) 4;
				*esp = v64;
				eax = *esp;
				esp += 4;
				ebx = ebx ^ ecx;
				SZ = cond(ebx);
				O = false;
				C.u0 = false;
				if (Test(NE,Z))
				{
					ecx = ecx;
					if (Test(EQ,Z))
					{
						edi = *esp;
						esp += 4;
						esi = *((byte) eax.u0 - 2132433537);
						goto l0040C3C4;
					}
				}
				ecx = esi;
				bl <<= cl;
				ch -= bh;
				edx += ecx;
				cl -= dl;
				bh >>= cl;
				esi &= edx;
				edi = eax;
				v130 = (ch & 0x01 << 0x08 - cl) != 0x00;
				ch = __rol<byte,byte>(ch, cl);
				ebx = eax;
				dh &= 0xCC;
				SZ = cond(dh);
				O = false;
				C.u0 = false;
				bl -= ch;
				v133 = (edi & 0x01 << cl) != 0x00;
				edi = __ror<word32,byte>(edi, cl);
				v134 = *eax.u0;
				esp -= 4;
				*esp = v134;
				eax = *esp;
				esp += 4;
				cl |= 0x69;
				edi -= esi;
				SCZO = cond(edi);
				cl = cl + bl + C;
				bh.u0 = 0x4B;
				&dh.u2->u0 = (byte) dh.u0 + 1;
				C = ecx != 0x00;
				ecx = -ecx;
				SZO = cond(ecx);
				cl.u0 = 0x1C;
				goto l0040C7C5;
			}
			bl.u0 = 155;
			ebx = ebx + eax + C;
			cl &= dh;
			ah = dh;
			dl &= ah;
			cl &= dh;
			edx >>= cl;
			--esi;
			dl = ~dl;
			&ch.u2->u0 = (byte) ch + 0x0A;
			SCZO = cond(ch);
			ebx = ebx + edi + C;
			SCZO = cond(ebx);
			v38 = (ah & 0x01 << cl) != 0x00;
			ah = __ror<byte,byte>(ah, cl);
			C = v38;
			bh = bh + al + C;
			ch &= 0x60;
			esi += ecx;
			ah |= dl;
			C.u0 = false;
			cl = cl - ch - C;
			SCZO = cond(cl);
			v46 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v46;
			bh = bh + al + C;
			SCZO = cond(bh);
			ch = ch + bh + C;
			ah |= 0xC5;
			edi = edi ^ ebx;
			C.u0 = false;
			&ebx.u2->u0 = (word32) ebx + 1;
			SZO = cond(ebx);
l0040BF3F:
			dh = ~dh;
			dl = dh;
			v52 = (dh & 0x01 << cl) != 0x00;
			dh = __rcr<byte,byte>(dh, cl, C);
			ecx |= esi;
			C.u0 = false;
			v53 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rcl<byte,byte>(bl, cl, C);
			ebx |= edx;
			--edi;
			esi &= edx;
			ebx = ebx ^ ecx;
			C.u0 = false;
			edi = edi - ebx - C;
			SCZO = cond(edi);
			v54 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rol<byte,byte>(bl, cl);
			v55 = (edi & 0x01 << 0x20 - cl) != 0x00;
			edi = __rol<word32,byte>(edi, cl);
			C = v55;
			al = al ^ ~0x32;
			al &= 0x8A;
			cl += bl;
			dh |= 151;
			ah <<= cl;
			eax += ebx;
			SCZO = cond(eax);
			v57 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v57;
l0040C24F:
			ebx = ebx - esi - C;
			ch = -ch;
			edi <<= cl;
			SCZO = cond(edi);
			v58 = (ebx & 0x01 << 0x20 - cl) != 0x00;
			ebx = __rcl<word32,byte>(ebx, cl, C);
			C = v58;
			if (Test(NE,Z))
			{
				ecx = ecx;
				if (Test(EQ,Z))
				{
					dh.u0 = 0xD1;
					v59 = edi;
					edi = eax;
					eax = v59;
					esp -= (union Eq_3 *) 2;
					*esp = ss;
				}
			}
			ecx = ecx - eax - C;
			cl &= ~0x01;
			C.u0 = false;
			v69 = (bl & 0x01 << 0x08 - cl) != 0x00;
			bl = __rcl<byte,byte>(bl, cl, C);
			C = v69;
			ebx = ebx - eax - C;
			SCZO = cond(ebx);
			ch = bl;
			&al.u2->u0 = (bool) C.u0 + ((byte) al + 39);
			SCZO = cond(al);
			&bl.u2->u0 = (bool) C.u0 + ((byte) bl.u0 + 0x00A3);
			SCZO = cond(bl);
			v70 = (edi & 0x01 << cl) != 0x00;
			edi = __rcr<word32,byte>(edi, cl, C);
			C = v70;
			bh = bh - 227 - C;
			al >>= cl;
			&ch.u2->u0 = (byte) ch + 0x00B2;
			SCZO = cond(ch);
			v71 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			C = v71;
			if (Test(NE,Z))
			{
				ecx = ecx;
				if (Test(EQ,Z))
				{
					__syscall<byte>(0x43);
					v72 = ebp;
					ebp = eax;
					eax = v72;
					do
					{
						ch &= cl;
						bl &= dl;
						edi = ebx;
						C = ecx != 0x00;
						ecx = -ecx;
						esi = esi + ebx + C;
						++edi;
						bh -= 0x1B;
						SCZO = cond(bh);
						v73 = (eax & 0x01 << 0x01) != 0x00;
						eax = __ror<word32,byte>(eax, 0x01);
						C = v73;
						if (Test(ULT,C))
							goto l0040C7EF;
						bh = bh + bl + C;
						SCZO = cond(bh);
						bl = ~bl;
						if (Test(NE,Z))
						{
							ecx = ecx;
							if (Test(EQ,Z))
								;
						}
						v86 = (esi & 0x01 << cl) != 0x00;
						esi = __rcr<word32,byte>(esi, cl, C);
						C = v86;
						v87 = (bl & 0x01 << cl) != 0x00;
						bl = __rcr<byte,byte>(bl, cl, C);
						ch = ~ch;
						ch &= 44;
						C.u0 = false;
						ch = ch + al + C;
						SCZO = cond(ch);
						bh = bh - ah - C;
						cl >>= cl;
						C = edi != 0x00;
						edi = -edi;
						SZO = cond(edi);
						if (Test(EQ,Z))
						{
l0040C88C:
							v83 = (ch & 0x01 << 0x08 - cl) != 0x00;
							ch = __rol<byte,byte>(ch, cl);
							C = v83;
							v84 = (cl & 0x01 << cl) != 0x00;
							cl = __rcr<byte,byte>(cl, cl, C);
							cl <<= cl;
							SCZO = cond(cl);
							ebx = ebx - esi - C;
							SCZO = cond(ebx);
							edi >>= cl;
							SCZ = cond(edi);
l0040C895:
							esi |= edx;
							esi = esi ^ edx;
							C.u0 = false;
							ch = ch - dh - C;
							SCZO = cond(ch);
							do
							{
								ebx += edi;
								SCZO = cond(ebx);
								--edi;
								SZO = cond(edi);
								if (Test(NE,Z))
								{
									ecx = ecx;
									if (Test(EQ,Z))
									{
										ebx = ebx - *ecx - C;
										SCZO = cond(ebx);
										eax = *(union Eq_3 *) 0x2A57B04A;
										goto l0040C8B3;
									}
								}
								&bh.u2->u0 = (bool) C.u0 + ((byte) bh + 99);
								bl -= 0x2A;
								SCZO = cond(bl);
								v100 = (ecx & 0x01 << cl) != 0x00;
								ecx = __rcr<word32,byte>(ecx, cl, C);
								bh |= 0x6C;
								SZ = cond(bh);
								O = false;
								C.u0 = false;
								v101 = (ecx & 0x01 << 0x20 - cl) != 0x00;
								ecx = __rcl<word32,byte>(ecx, cl, C);
								C = v101;
								fn0040DCBC();
								al = *((word32) ebx + (uint32) al);
								ds = *esp;
								esp += 2;
							} while (Test(LE,SZO));
							int3();
							*((byte) eax.u0 + (eax * 0x02 - 415429568)) = *esp;
							esp += 4;
							SCZO = cond(*edx - ebp);
							ah = ah - cl - C;
							--ecx;
							++eax;
							++eax;
							++eax;
							++ecx;
							*Top *= (real64) *ebx;
							v106 = edx.u5->bFFFFFF9E >> 0xC4;
							edx.u5->bFFFFFF9E = v106;
							SCZ = cond(v106);
							esp -= (union Eq_3 *) 0x01;
							ax = __aad(ax);
							++eax;
							++eax;
							SZO = cond(eax);
							do
							{
								D = true;
								cl.u0 = 0x15;
								C.u0 = true;
								eax = __in<word32>(dx);
								edi -= 4;
								esp -= (union Eq_3 *) 4;
								esp->u0 = ~0x33;
								if (Test(NS,S))
								{
									++eax;
									++eax;
									SZO = cond(eax);
									if (Test(PO,P))
										goto l0040C895;
									ax = __aam(al);
									v109 = ebx;
									ebx = eax;
									eax = v109;
									bh &= edx.u5->bFFFFFF93;
									al = al ^ 0x41;
									v110 = *((word32) ecx + edi * 0x02);
									*((word32) ecx + edi * 0x02) = esp;
									esp = v110;
									v111 = (ecx.u5->tFFFFFF87.u0 & 0x01 << 0x08 - 0x01) != 0x00;
									ecx.u5->tFFFFFF87.u0 = (int8) __rol<byte,byte>(ecx.u5->tFFFFFF87.u0, 0x01);
									al &= 0x41;
									v112 = *edx;
									*edx = esi;
									esi = v112;
									++ecx;
									v113 = *((word32) ecx + eax * 0x02);
									*((word32) ecx + eax * 0x02) = esp;
									esp = v113;
									v114 = *edx;
									*edx = esi;
									esi = v114;
									++ecx;
									v115 = *edx;
									*edx = esi;
									esp -= (union Eq_3 *) 0x01;
									++eax;
									++eax;
									ch.u0 = 101;
									esi.u0 = 2273026476;
									SCZO = cond(*((byte) edi.u0 - 0x7C84C37A) - bh);
									SCZO = cond(*((byte) edi.u0 + 0x3F4C3C82) - bh);
									ebx.u0 = 0x6C6A4040;
								}
								else
								{
									esp -= (union Eq_3 *) 4;
									esp->u0 = 0x6C;
								}
								++eax;
								++eax;
								++eax;
								v119 = (byte) &(bh.u2 + (ecx.u5)->b403BCDFE /8 4)->u0;
								ecx.u5->b403BCDFE = v119;
								++eax;
								SCZO = cond(*esi.u0 - *edi.u0);
								--esi;
								--edi;
								++eax;
								++eax;
								++eax;
								v120 = (eax + 59)[ebx * 0x02] + cl;
								&((byte) eax.u0 + (ebx * 0x02 + 59))->u2->u0 = v120;
								++eax;
								++eax;
								SCZO = cond(al - ~0x42);
								al = *esi.u0;
								--esi;
								ecx.u5->tFFFFFFD8.u2 = (Eq_3 (*)[]) eax;
							} while (Test(PO,P));
							return;
						}
						ecx = ecx;
						if (Test(NE,Z))
							goto l0040C88C;
						SCZO = cond(ebx.u5->dwFFFFFFD6 - esi);
						ss = *esp;
						esp += 2;
						if (ecx == 0x00)
							goto l0040C24F;
						dl &= bl;
						SZ = cond(dl);
						O = false;
						C.u0 = false;
l0040C1D3:
						__out<byte>(dx, al);
						cl = cl ^ al;
						bl = bl ^ 0x36;
						__syscall<byte>(0x2E);
						ch = ~ch;
						cl = ch;
						++edi;
						v88 = (bl & 0x01 << 0x08 - cl) != 0x00;
						bl = __rol<byte,byte>(bl, cl);
						C = v88;
						ch = ch - bl - C;
						SCZO = cond(ch);
						ch.u0 = ~0x11;
						esi <<= cl;
						cl >>= cl;
						SCZO = cond(cl);
						ecx = ecx - ebx - C;
						SCZO = cond(ecx);
						v89 = (ecx & 0x01 << 0x20 - cl) != 0x00;
						ecx = __rcl<word32,byte>(ecx, cl, C);
						edi &= ebx;
						C.u0 = false;
						cl = cl + ch + C;
						&bh.u2->u0 = (byte) bh + 0x00D6;
						SCZO = cond(bh);
						if (Test(NE,Z))
						{
							ecx = ecx;
							if (Test(EQ,Z))
								;
						}
l0040C75A:
						&cl.u2->u0 = (byte) cl + 1;
						SCZO = cond(edx - ~0x00);
						if (Test(NE,Z))
							al.u0 = edx.u5->tFFFFFFFF.u0;
						else
							al.u0 = 0x2E;
						SCZO = cond(eax - 0xC000002E);
						if (Test(EQ,Z))
							goto l0040C676;
						edi += edx;
						cl = cl ^ bl;
						dl -= ah;
						SCZO = cond(dl);
						v93 = (al & 0x01 << 0x08 - cl) != 0x00;
						al = __rol<byte,byte>(al, cl);
						ecx >>= cl;
						SCZ = cond(ecx);
						if (Test(EQ,Z))
							goto l0040C5A6;
						ecx = ecx;
						if (Test(NE,Z))
							goto l0040C5A6;
						__sti();
						ah.u0 = 0x93;
						v94 = *ebx - ~0x35;
						*ebx = v94;
						SCZO = cond(v94);
l0040C790:
						esi -= edi;
						cl |= dh;
						v95 = (bl & 0x01 << 0x08 - cl) != 0x00;
						bl = __rol<byte,byte>(bl, cl);
						C = v95;
						&ch.u2->u0 = (bool) C.u0 + ((byte) ch.u0 + 79);
						bl <<= cl;
						SCZO = cond(edx - 20023777);
						if (Test(EQ,Z))
						{
							&ch.u2->u0 = (bool) C.u0 + ((byte) ch.u0 + 9);
							SCZO = cond(ch);
							v96 = (edx & 0x01 << cl) != 0x00;
							edx = __rcr<word32,byte>(edx, cl, C);
							v97 = (eax & 0x01 << 0x20 - cl) != 0x00;
							eax = __rol<word32,byte>(eax, cl);
							ah &= bh;
							C.u0 = false;
							ch = ch + al + C;
							SCZO = cond(ch);
							if (Test(NE,Z))
							{
								ecx = ecx;
								if (Test(EQ,Z))
								{
									v98 = (word32) ((bool) C.u0 + ((ebx.u5)->dwFFFFFFC3 + 0x0B4AEF80));
									ebx.u5->dwFFFFFFC3 = v98;
									SCZO = cond(v98);
l0040C7C5:
									&edx->u2->u0 = (int16) *Top;
									goto l0040C74D;
								}
							}
							ch -= 0x60;
							bh |= dl;
							SZ = cond(bh);
							O = false;
							C.u0 = false;
							return;
						}
						&ecx.u2->u0 = (word32) ecx + 1;
						SZO = cond(ecx);
						if (Test(NE,Z))
						{
							ecx = ecx;
							if (Test(EQ,Z))
							{
								esp -= (union Eq_3 *) 4;
								*esp = ecx;
								C = __aaa(al, ah, &al, &ah);
								v116 = *ebx.u0 & ebp;
								*ebx.u0 = v116;
								SZ = cond(*ebx.u0);
								O = false;
								C.u0 = false;
								goto l0040C5E9;
							}
						}
						cl += bh;
						ebx >>= cl;
						cl <<= cl;
						SCZO = cond(cl);
						ebx = edi;
						ch.u0 = ~0x50;
						cl = dl;
						if (Test(EQ,Z))
							continue;
						ecx = ecx;
					} while (Test(NE,Z));
					v121 = esp;
					esp = eax;
					eax = v121;
					esp -= 4;
					*esp = ebx;
					v122 = *esi.u0;
					*edi.u0 = v122;
					++esi;
					++edi;
l0040C640:
					v39 = (dh & 0x01 << cl) != 0x00;
					dh = __ror<byte,byte>(dh, cl);
					dh = ~dh;
					bh <<= cl;
					v40 = (bh & 0x01 << 0x08 - cl) != 0x00;
					bh = __rol<byte,byte>(bh, cl);
					edi += ecx;
					eax = -eax;
					&bh.u2->u0 = (byte) bh + 1;
					dl >>= cl;
					edi <<= cl;
					&dh.u2->u0 = (byte) dh + 69;
					eax >>= cl;
					SCZO = cond(eax);
					if (Test(NE,Z))
					{
						ecx = ecx;
						if (Test(EQ,Z))
						{
							if (Test(PE,P))
							{
								dl = -dl;
								&ebx.u2->u0 = (word32) ebx + 1;
								esp &= esp;
								v42 = (ecx & 0x01 << 0x20 - cl) != 0x00;
								ecx = __rol<word32,byte>(ecx, cl);
								C = v42;
								esi = esi - eax - C;
								ch = ~ch;
								&ebx.u2->u0 = (word32) ebx + 1;
								--ebx;
								edx <<= cl;
								SCZO = cond(edx);
l0040C676:
								dl = ~dl;
								edx += edi;
								SCZO = cond(edx);
								ah = ah + al + C;
								SCZO = cond(ah);
								v47 = (eax & 0x01 << cl) != 0x00;
								eax = __rcr<word32,byte>(eax, cl, C);
								C = v47;
								v48 = (bh & 0x01 << 0x08 - cl) != 0x00;
								bh = __rcl<byte,byte>(bh, cl, C);
								v49 = (cl & 0x01 << cl) != 0x00;
								cl = __ror<byte,byte>(cl, cl);
								C = v49;
								esi = esi + ebx + C;
								edi <<= cl;
								dl <<= cl;
								SCZO = cond(dl);
								v50 = (ecx & 0x01 << cl) != 0x00;
								ecx = __ror<word32,byte>(ecx, cl);
								C = v50;
								if (Test(NE,Z))
								{
									ecx = ecx;
									if (Test(EQ,Z))
									{
										eax = __in<word32>(dx);
										&edi.u2->u0 = (word32) edi + 4;
										*edi = eax;
										&edi.u2->u0 = (word32) edi + 4;
										eax = eax + Mem0[eax + ~0x042C4720:word32] + C;
										SCZO = cond(eax);
										goto l0040C0D9;
									}
								}
								ch = ch + bh + C;
								C = ebx != 0x00;
								ebx = -ebx;
								bl = bl - 199 - C;
								ah <<= cl;
								ah -= dl;
								SCZO = cond(ah);
								&ah.u2->u0 = (byte) ah + 1;
								ch = dl;
								bl = dh;
								dl = dl + bh + C;
								SCZO = cond(dl);
								ecx >>= cl;
								cl &= 0x36;
								ecx &= esi;
								&bh.u2->u0 = (byte) bh.u0 + 244;
								ebx |= esi;
								C.u0 = false;
								dh = dh - 117 - C;
								++eax;
								eax.u0 = 0x03;
								edi -= edx;
								dl <<= cl;
								SCZO = cond(dl);
								edi = ecx;
								cl = cl + dl + C;
								esi <<= cl;
								SCZO = cond(esi);
								v74 = (ebx & 0x01 << 0x20 - cl) != 0x00;
								ebx = __rcl<word32,byte>(ebx, cl, C);
								edi >>= cl;
								ch >>= cl;
								dh |= 0x32;
								v75 = (dl & 0x01 << 0x08 - cl) != 0x00;
								dl = __rol<byte,byte>(dl, cl);
								C = v75;
								v76 = (cl & 0x01 << cl) != 0x00;
								cl = __rcr<byte,byte>(cl, cl, C);
								cl = cl ^ bh;
								--edi;
								esi >>= cl;
								bh |= ~0x15;
								C.u0 = false;
								v77 = (ecx & 0x01 << 0x20 - cl) != 0x00;
								ecx = __rcl<word32,byte>(ecx, cl, C);
								bl -= 0x56;
								SCZO = cond(bl);
								v78 = (dh & 0x01 << cl) != 0x00;
								dh = __rcr<byte,byte>(dh, cl, C);
								C = v78;
								bh += ah;
								edx -= eax;
								dl = dl ^ bh;
								edx = edx ^ edx;
								ebx -= edi;
								SCZO = cond(ebx);
								ch = ch - bh - C;
								SCZO = cond(ch);
								bh = bh + bl + C;
								cl -= 223;
								bh = ~bh;
								C = ecx != 0x00;
								ecx = -ecx;
								SZO = cond(ecx);
								if (Test(NE,Z))
								{
									ecx = ecx;
									if (Test(EQ,Z))
									{
										edi.u0 = 3541740933;
										al &= cl;
										v81 = (ebx & 0x01 << cl) != 0x00;
										ebx = __ror<word32,byte>(ebx, cl);
										ebx >>= cl;
										SCZ = cond(ebx);
										&dl.u2->u0 = (byte) dl.u0 + 1;
										ah = ah + bl + C;
										SCZO = cond(ah);
										goto l0040C564;
									}
								}
								cl |= 0x2A;
								v124 = (cl & 0x01 << cl) != 0x00;
								cl = __ror<byte,byte>(cl, cl);
								C = v124;
								esi = esi + edx + C;
								gs = ax;
								cl -= ah;
								SCZO = cond(cl);
								--ebx;
								--cl;
								&ecx.u2->u0 = (word32) ecx + 1;
								SZO = cond(ecx);
l0040C8B3:
								al = __in<byte>(dx);
								bh &= dh;
								C.u0 = false;
								cl.u0 = 0x8B;
								v85 = (bh & 0x01 << 0x08 - cl) != 0x00;
								bh = __rcl<byte,byte>(bh, cl, C);
								bh = -bh;
								cl |= 0x6D;
								SZ = cond(cl);
								O = false;
								C.u0 = false;
								if (Test(NE,Z))
								{
									ecx = ecx;
									if (Test(EQ,Z))
										return;
								}
								esi <<= cl;
								SCZO = cond(esi);
								v90 = (edi & 0x01 << cl) != 0x00;
								edi = __ror<word32,byte>(edi, cl);
								C = v90;
								v91 = (edi & 0x01 << cl) != 0x00;
								edi = __rcr<word32,byte>(edi, cl, C);
								v92 = (ecx & 0x01 << 0x20 - cl) != 0x00;
								ecx = __rol<word32,byte>(ecx, cl);
								C = v92;
l0040C7EF:
								ecx = ecx - edi - C;
								SCZO = cond(ecx);
								cl = bh;
								bh = bh ^ al;
								v128 = (ebx & 0x01 << 0x20 - cl) != 0x00;
								ebx = __rol<word32,byte>(ebx, cl);
								edi <<= cl;
								SCZO = cond(edi);
								goto l0040C45A;
							}
							goto l0040C5F4;
						}
					}
					dl &= cl;
					edi &= ebx;
					v141 = (esi & 0x01 << 0x20 - cl) != 0x00;
					esi = __rol<word32,byte>(esi, cl);
					&dh.u2->u0 = (byte) dh + 1;
					v142 = (dl & 0x01 << 0x08 - cl) != 0x00;
					dl = __rol<byte,byte>(dl, cl);
					C = v142;
					--bl;
					edi = edi + ebx + C;
					dl |= ah;
					ah |= 161;
					SZ = cond(ah);
					O = false;
					C.u0 = false;
					if (Test(EQ,Z))
					{
l0040C2B0:
						bl &= 0x4A;
						bl = bl ^ 0xD1;
						C.u0 = false;
						dl = dl - ~0x62 - C;
						SCZO = cond(dl);
						v148 = (ebx & 0x01 << cl) != 0x00;
						ebx = __rcr<word32,byte>(ebx, cl, C);
						bl = bl ^ ch;
						ebx <<= cl;
						SCZO = cond(ebx);
						al -= 0x70;
						bl &= 0x12;
						--esi;
						&al.u2->u0 = (byte) al + 3;
						bl -= dh;
						SCZO = cond(bl);
						&bl.u2->u0 = (bool) C.u0 + ((byte) bl + 0x00AF);
						SCZO = cond(bl);
						if (Test(EQ,Z))
							return;
						ecx = ecx;
						if (Test(NE,Z))
							return;
						*(union Eq_3 *) 0xC7010E44 = al;
						SCZO = cond(eax - *edi.u0);
						edi += 4;
						v149 = *((byte) esi.u0 - 0x0A) | 223;
						&((byte) esi.u0 - 0x0A)->u2->u0 = v149;
						SZ = cond(*((byte) esi.u0 - 0x0A));
						O = false;
						C.u0 = false;
l0040C84C:
						v35 = (bl & 0x01 << cl) != 0x00;
						bl = __rcr<byte,byte>(bl, cl, C);
						eax = gs;
						ch <<= cl;
						ebx |= eax;
						SZ = cond(ebx);
						O = false;
						C.u0 = false;
						ch >>= cl;
						&bh.u2->u0 = (byte) bh + 0x00D5;
						esi |= edx;
						bl >>= cl;
						ecx &= esi;
						bh += bl;
						SCZO = cond(bh);
						cl = ~cl;
						v43 = (cl & 0x01 << cl) != 0x00;
						cl = __rcr<byte,byte>(cl, cl, C);
						v44 = (esi & 0x01 << cl) != 0x00;
						esi = __ror<word32,byte>(esi, cl);
						C = v44;
						v45 = (esi & 0x01 << cl) != 0x00;
						esi = __rcr<word32,byte>(esi, cl, C);
						C = v45;
						if (Test(NE,Z))
						{
							ecx = ecx;
							if (Test(EQ,Z))
							{
								C = __daa(al, &al);
								SCZO = cond(*((word32) edi + (ecx * 0x02 - 0x2D103158)) - bh);
l0040C5A6:
								eax = __in<word32>(211);
							}
						}
						esi = esi + edx + C;
						SCZO = cond(esi);
						bl.u0 = 0xA3;
						cl = cl + al + C;
						ebx >>= cl;
						SCZ = cond(ebx);
						cl = cl - 155 - C;
						v135 = (bl & 0x01 << 0x08 - cl) != 0x00;
						bl = __rol<byte,byte>(bl, cl);
						C = v135;
						v136 = (bh & 0x01 << cl) != 0x00;
						bh = __rcr<byte,byte>(bh, cl, C);
						bl -= 0xAA;
						SCZO = cond(bl);
						&edx.u2->u0 = (word32) edx + 1;
						v137 = (edi & 0x01 << 0x20 - cl) != 0x00;
						edi = __rcl<word32,byte>(edi, cl, C);
						edi -= eax;
						SCZO = cond(edi);
						if (Test(EQ,Z))
							goto l0040C7FF;
						ecx = ecx;
l0040C74D:
						if (Test(EQ,Z))
						{
							v102 = esi;
							esi = eax;
							eax = v102;
							ah = SCZOP;
							C = __aas(al, ah, &al, &ah);
							v104 = edx;
							edx = eax;
							eax = v104;
							&esi.u2->u0 = (word32) esi + 1;
							++esp;
							&esi.u2->u0 = (word32) esi + 1;
							SZO = cond(esi);
							goto l0040C75A;
						}
l0040C7FF:
						v117 = (bl & 0x01 << cl) != 0x00;
						bl = __ror<byte,byte>(bl, cl);
						&ch.u2->u0 = (byte) ch + 1;
						&bh.u2->u0 = (byte) bh + 1;
						esi += ebx;
						SCZO = cond(esi);
						v118 = (edi & 0x01 << cl) != 0x00;
						edi = __rcr<word32,byte>(edi, cl, C);
						bh = bh ^ al;
						C.u0 = false;
						ecx = edi;
						--ch;
						ch = ch - 11 - C;
						edi <<= cl;
						cl <<= cl;
						ebx >>= cl;
						bl |= bh;
						SZ = cond(bl);
						O = false;
						C.u0 = false;
						goto l0040C790;
					}
					ecx = ecx;
					if (Test(NE,Z))
						goto l0040C2B0;
					es->tD2C40253 = al;
					ah = ~ah;
					dh += cl;
					dh >>= cl;
					ah &= bh;
					v144 = (dl & 0x01 << 0x08 - cl) != 0x00;
					dl = __rol<byte,byte>(dl, cl);
					C = v144;
					++eax;
					&dh.u2->u0 = (bool) C.u0 + ((byte) dh + 0x00B9);
					SCZO = cond(dh);
					v145 = (dh & 0x01 << 0x08 - cl) != 0x00;
					dh = __rol<byte,byte>(dh, cl);
					C = v145;
					if (Test(NE,Z))
					{
						ecx = ecx;
						if (Test(EQ,Z))
						{
							al = *esi.u0;
							++esi;
							esp = esp - *edi.u0 - C;
							*edi.u0 = al;
							++edi;
							bl = bl ^ ch;
							C.u0 = false;
							bh = bh - 0x23 - C;
							--edx;
							edx |= esi;
							C.u0 = false;
							--dh;
							SZO = cond(dh);
							bl = ~bl;
							bl = bl - 0xCC - C;
							edi = edi ^ esi;
							C.u0 = false;
							bh = bh - cl - C;
							esi <<= cl;
							dl &= ch;
							eax &= ~0x11111111;
							ch = ch ^ bh;
							v146 = (ebx & 0x01 << 0x20 - cl) != 0x00;
							ebx = __rol<word32,byte>(ebx, cl);
							C = v146;
							--edx;
							SZO = cond(edx);
							if (Test(NE,Z))
							{
								ecx = ecx;
								if (Test(EQ,Z))
								{
									--ebx;
									SZO = cond(ebx);
									esp.u0 = 0x824C1421;
								}
							}
l0040C3C4:
							eax = __in<word32>(dx);
							esp -= 4;
							*esp = ebp;
							ebp = esp;
							esp -= -14246;
							__out<word32>(dx, eax);
							ecx += ebx;
							--ebx;
							eax -= ~0x11111111;
							bl = bl ^ 0x94;
							SZ = cond(bl);
							O = false;
							C.u0 = false;
							if (Test(NE,Z))
							{
								ecx = ecx;
								if (Test(EQ,Z))
								{
									++edx;
									SZO = cond(edx);
									&eax.u2->u0 = (int32) ax;
									esp -= (union Eq_3 *) 4;
									*esp = edx;
									goto l0040C3E7;
								}
							}
							dl &= 0x31;
							ch |= 0x41;
							bl &= cl;
							v79 = (cl & 0x01 << 0x08 - cl) != 0x00;
							cl = __rol<byte,byte>(cl, cl);
							C = v79;
							&bl.u2->u0 = (bool) C.u0 + ((byte) bl + 6);
							SCZO = cond(bl);
							cl = cl + bl + C;
							SCZO = cond(cl);
							ebx = ebx + eax + C;
							SCZO = cond(ebx);
							eax |= eax;
							SZ = cond(eax);
							O = false;
							C.u0 = false;
							if (Test(NE,Z))
							{
								eax |= eax;
								SZ = cond(eax);
								O = false;
								C.u0 = false;
								if (Test(NE,Z))
									return;
							}
							edi = edi - esi - C;
							SCZO = cond(edi);
							v123 = (dl & 0x01 << cl) != 0x00;
							dl = __rcr<byte,byte>(dl, cl, C);
							C = v123;
							ch = ch - cl - C;
							SCZO = cond(ch);
							bl = bl - ~0x00 - C;
							SCZO = cond(bl);
							&dl.u2->u0 = (byte) dl + 1;
							SZO = cond(dl);
							v125 = (ebx & 0x01 << cl) != 0x00;
							ebx = __ror<word32,byte>(ebx, cl);
							esi <<= cl;
							SCZO = cond(esi);
							bl = bl + ch + C;
							edx = edx ^ edx;
							C.u0 = false;
							ch = ch - ah - C;
							ch |= bh;
							C.u0 = false;
							ebx = ebx - eax - C;
							SCZO = cond(ebx);
							bl -= 0xC6;
							SCZO = cond(bl);
							ch = ch + dl + C;
							SCZO = cond(ch);
							bl = bl + al + C;
							SCZO = cond(bl);
							v129 = (bh & 0x01 << 0x08 - cl) != 0x00;
							bh = __rcl<byte,byte>(bh, cl, C);
							esi = -esi;
							cl = ~cl;
							ch = ch ^ 155;
							SZ = cond(ch);
							O = false;
							C.u0 = false;
							goto l0040C1D3;
						}
					}
					bl = -bl;
					&bl.u2->u0 = (byte) bl + 0x0033;
					SCZO = cond(bl);
					esi = esi + eax + C;
					SCZO = cond(esi);
					dl = dl - cl - C;
					ah >>= cl;
					SCZ = cond(ah);
					v147 = (esi & 0x01 << 0x20 - cl) != 0x00;
					esi = __rcl<word32,byte>(esi, cl, C);
					&dh.u2->u0 = (byte) dh + 222;
					--al;
					bl += cl;
					SCZO = cond(bl);
					if (Test(NE,Z))
					{
						ecx = ecx;
						if (Test(EQ,Z))
						{
							eax = *(union Eq_3 *) 0xD48D08D6;
							goto l0040C2B0;
						}
					}
					bl = bl - ah - C;
					esi = -esi;
					dh += bh;
					SCZO = cond(dh);
					&bl.u2->u0 = (bool) C.u0 + ((byte) bl + 200);
					dh = dh ^ ah;
					bl <<= cl;
					SCZO = cond(bl);
					if (Test(NE,Z))
					{
						ecx = ecx;
						if (Test(EQ,Z))
						{
							ds = *esp.u0;
							esp += 2;
							fs = ax;
							int3();
							eax = __in<word32>(dx);
							SZP = cond(eax & 0x80D70BB7);
							O = false;
							C.u0 = false;
l0040C513:
							dh <<= cl;
							v126 = (dl & 0x01 << 0x08 - cl) != 0x00;
							dl = __rol<byte,byte>(dl, cl);
							ch = ch ^ cl;
							ah &= cl;
							ecx = edx;
							cl &= 220;
							SZ = cond(cl);
							O = false;
							C.u0 = false;
							bl = ~bl;
							v127 = (edx & 0x01 << cl) != 0x00;
							edx = __rcr<word32,byte>(edx, cl, C);
							C = v127;
							edi = ebx;
							ch = ch + bl + C;
							SCZO = cond(ch);
							--edx;
							cl = cl - dh - C;
							bh = bh ^ 0x03;
							ah &= cl;
							bl <<= cl;
							edi >>= cl;
							dh = -dh;
							cl = cl ^ ~0x0E;
							C.u0 = false;
							cl = cl + bh + C;
							eax >>= cl;
							al >>= cl;
							SCZO = cond(al);
							if (Test(NE,Z))
							{
								ecx = ecx;
								if (Test(EQ,Z))
								{
									eax = *(union Eq_3 *) 4079794792;
									goto l0040BF3F;
								}
							}
							&al.u2->u0 = (byte) al.u0 + 1;
							bh = bh ^ 199;
							bl >>= cl;
							SCZ = cond(bl);
							v131 = (edi & 0x01 << cl) != 0x00;
							edi = __rcr<word32,byte>(edi, cl, C);
							C = v131;
							ah = bl;
							&dl.u2->u0 = (byte) dl + 1;
							v132 = (esi & 0x01 << 0x20 - cl) != 0x00;
							esi = __rcl<word32,byte>(esi, cl, C);
							ah -= bl;
							SCZO = cond(ah);
							ecx = ecx + eax + C;
							edi >>= cl;
							bl = bl ^ 0x7F;
							SZ = cond(bl);
							O = false;
							C.u0 = false;
							edi |= eax;
							ebx >>= cl;
							ebx += ecx;
							dl = ~dl;
							dl -= cl;
							v138 = (ch & 0x01 << 0x08 - cl) != 0x00;
							ch = __rol<byte,byte>(ch, cl);
							bh = -bh;
							C = esi != 0x00;
							esi = -esi;
							bh = bh - 0x8B - C;
							SCZO = cond(bh);
							ecx = ecx - esi - C;
							SCZO = cond(ecx);
							ch = ch + bh + C;
							&al.u2->u0 = (byte) al + 70;
							SCZO = cond(al);
							v139 = (edi & 0x01 << cl) != 0x00;
							edi = __rcr<word32,byte>(edi, cl, C);
							C = v139;
							if (Test(NE,Z))
							{
								ecx = ecx;
								if (Test(EQ,Z))
								{
									ds = *esp;
									esp += 2;
									ebx.u0 = 3528404325;
									return;
								}
							}
							bh = ch;
							ecx = -ecx;
							v140 = (edi & 0x01 << 0x20 - cl) != 0x00;
							edi = __rol<word32,byte>(edi, cl);
							&bh.u2->u0 = (byte) bh.u0 + 0x00A8;
							SCZO = cond(bh);
							return;
						}
					}
l0040C0D9:
					++esi;
					edx <<= cl;
					ebx >>= cl;
					bl = ch;
					--dl;
					dl = dl ^ 0x5E;
					SZ = cond(dl);
					O = false;
					C.u0 = false;
					ebx = edx;
					dh |= ah;
					&ecx.u2->u0 = (byte) ecx.u0 - 91138700;
					bh <<= cl;
					v56 = (edx & 0x01 << 0x20 - cl) != 0x00;
					edx = __rol<word32,byte>(edx, cl);
					bh <<= cl;
					esi <<= cl;
					SCZO = cond(esi);
					dh -= 0x36;
					SCZO = cond(dh);
					esi = esi - eax - C;
					&dh.u2->u0 = (byte) dh + 1;
					bh &= bl;
					edx = ecx;
					bh &= dh;
					bh.u0 = 0x24;
					esi >>= cl;
					SCZO = cond(ecx - 0x990A4B79);
					if (Test(EQ,Z))
					{
						al >>= cl;
						ecx &= eax;
						v67 = (esi & 0x01 << cl) != 0x00;
						esi = __ror<word32,byte>(esi, cl);
						&ah.u2->u0 = (byte) ah + 1;
						bl = bl ^ ~0x28;
						al -= 0x98;
						ah = bh;
						v68 = (eax & 0x01 << 0x20 - cl) != 0x00;
						eax = __rol<word32,byte>(eax, cl);
						cl = cl ^ ch;
						C.u0 = false;
						++eax;
						SZO = cond(eax);
						ch <<= cl;
						dl.u0 = 0x09;
						dl >>= cl;
						SCZO = cond(dl);
						eax.u0 = 1218306202;
						edx = edx - eax - C;
						ecx <<= cl;
						SCZO = cond(ecx);
						ch = ch + dl + C;
						edi <<= cl;
						SCZO = cond(edi);
						v80 = (dh & 0x01 << cl) != 0x00;
						dh = __ror<byte,byte>(dh, cl);
						C = v80;
						bh &= ~0x70;
						dh -= ch;
						ebx -= ecx;
						SCZO = cond(ebx);
						mm0 = (word64) eax;
						ch.u0 = 0x9C;
						dl = dl + ch + C;
						dh <<= cl;
						--bh;
						ebx <<= cl;
						SCZO = cond(ebx);
						cl = cl + ch + C;
						SCZO = cond(cl);
						esi = esi - ebx - C;
						bh <<= cl;
						SCZO = cond(bh);
						if (Test(NE,Z))
						{
							ecx = ecx;
							if (Test(EQ,Z))
							{
								SZP = cond(al & 0x90);
								C.u0 = false;
								*ebx = __fstcw();
								&ecx.u2->u0 = (word32) ecx + 1;
								SZO = cond(ecx);
								C = !C;
								goto l0040C88C;
							}
						}
						goto l0040C416;
					}
l0040BFB9:
					ah -= ~0x0C;
					ah = ah ^ bl;
					C.u0 = false;
					--edx;
					v29 = (edx & 0x01 << cl) != 0x00;
					edx = __rcr<word32,byte>(edx, cl, C);
					C = v29;
					ah = ah - 0x53 - C;
					dh >>= cl;
					SCZO = cond(dh);
					bl = bl + bh + C;
					SCZO = cond(bl);
					dl = dl + al + C;
					SCZO = cond(dl);
					ah = ah + dh + C;
					al = al ^ 0x5C;
					C.u0 = false;
					v33 = (dh & 0x01 << 0x08 - cl) != 0x00;
					dh = __rcl<byte,byte>(dh, cl, C);
					C = v33;
					&bl.u2->u0 = (byte) bl + 1;
					eax = eax + esi + C;
					ah = ~ah;
					al |= bl;
					ah -= cl;
					dh -= 0x5C;
					SCZO = cond(dh);
					v34 = (dl & 0x01 << cl) != 0x00;
					dl = __ror<byte,byte>(dl, cl);
					C = v34;
					goto l0040C640;
				}
			}
			edx |= edi;
			ch |= 0x2B;
			SZ = cond(ch);
			O = false;
			C.u0 = false;
			goto l0040C513;
		}
	}
	v25 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	eax -= edi;
	dh = bh;
	--al;
	C = bh != 0x00;
	bh = -bh;
	dl = dl - bh - C;
	SCZO = cond(dl);
	esi >>= cl;
	SCZ = cond(esi);
	goto l0040BFB9;
}

// 0040D456: define fn0040D456
// Called from:
//      fn0040D9C2
define fn0040D456
{
	esp = fp;
	Top = 0;
	bh -= ~0x45;
	&dh.u2->u0 = (byte) dh + 1;
	dh <<= cl;
	bh -= al;
	v10 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rol<word32,byte>(ebx, cl);
	C = v10;
	bh = bh - ~0x4C - C;
	dh = ~dh;
	eax = (struct Eq_2473 *) ((char *) &eax->ptr0000 + 8);
	esi = esi ^ eax;
	C.u0 = false;
	v17 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	edi |= edx;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	dl = (int8) ((bool) C.u0 + (dl + 0x39));
	dh |= dl;
	edi = -edi;
	dh <<= cl;
	bh >>= cl;
	SCZO = cond(bh);
	ebx = ebx - esi - C;
	bl &= 0xA2;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	eax = eax->ptr0000;
	v22 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	bl -= dh;
	dl >>= cl;
	bh <<= cl;
	ebx <<= cl;
	bh >>= cl;
	SCZ = cond(bh);
	bl = bl + ch + C;
	SCZO = cond(bl);
	v25 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	ebx -= eax;
	edx |= ecx;
	C.u0 = false;
	bl = bl - ~0x0E - C;
	SCZO = cond(bl);
	if (Test(EQ,Z))
		fn0040DBAD();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040DBAD();
		else
			SCZO = cond(eax->bD21FB83A - ah);
	}
}

// 0040D47B: define fn0040D47B
// Called from:
//      fn0040D828
define fn0040D47B
{
	esp = fp;
	Top = 0;
	bh = bh ^ ~0x12;
	&edx.u2->u0 = &(edx.u2 + eax / 4)->u0;
	SCZO = cond(edx);
	v12 = (al & 0x01 << cl) != 0x00;
	al = __rcr<byte,byte>(al, cl, C);
	C = v12;
	al = al - ~0x52 - C;
	ecx >>= 0x0F;
	SCZO = cond(ecx);
	v15 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	C = v15;
	edx = edx + ecx + C;
	al = -al;
	--dl;
	++edi;
	ah >>= cl;
	SCZO = cond(ah);
	fn0040DB2B();
}

// 0040D4D9: define fn0040D4D9
// Called from:
//      fn0040D68C
define fn0040D4D9
{
	esp = fp;
	Top = null;
	v5 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rol<byte,byte>(cl, cl);
	ah -= 0x38;
	edi = ecx;
	ch = ch ^ dl;
	C.u0 = false;
	v15 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	dh >>= cl;
	SCZ = cond(dh);
	ah = ah - 0x32 - C;
	SCZO = cond(ah);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			if (Test(LE,CZ))
				Top->r0000 = Top->r0007;
			__wait();
			fn0040D4FB();
			return;
		}
	}
	&ecx.u2->u0 = esp->u2;
	esp = (union Eq_3 *) ((char *) esp + 4);
	v21 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	C = v21;
	v23 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	bl = bl ^ al;
	esi <<= cl;
	edi |= ebx;
	--edi;
	bl |= bh;
	bl |= 228;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			SCZO = cond(ecx - ebp->dwFFFFFF8B);
			fn0040DCF6();
			return;
		}
	}
	al &= 0xB2;
	C.u0 = false;
	v34 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	C = v34;
	al = al - ch - C;
	bh &= bl;
	ecx = ecx ^ 0x05566345;
	dl -= 0x20;
	SCZO = cond(dl);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			--esp;
			v35 = edx.u5->bCFD38F2F & bl;
			edx.u5->bCFD38F2F = v35;
			SZ = cond(edx.u5->bCFD38F2F);
			++al;
			cl <<= cl;
			SCZO = cond(cl);
			al = al - 0x08 - C;
			bl -= ~0x45;
			SCZO = cond(bl);
			v36 = (ecx & 0x01 << cl) != 0x00;
			ecx = __rcr<word32,byte>(ecx, cl, C);
			C = v36;
			dl = (bool) C.u0 + (dl + dh);
			SCZO = cond(dl);
			v37 = (cl & 0x01 << cl) != 0x00;
			cl = __rcr<byte,byte>(cl, cl, C);
			C = v37;
			--bl;
			SZO = cond(bl);
			fn0040DCBC();
			return;
		}
	}
	dl = ~dl;
	esi -= edx;
	&bh.u2->u0 = (byte) bh + 0x008A;
	esi >>= cl;
	--ebx;
	dh |= ah;
	ebx &= ecx;
	esp -= 4;
	esp->u2 = (Eq_3 (*)[]) ecx;
	edx >>= cl;
	edx <<= cl;
	v38 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	bl = ~0x2A;
	dh += dl;
	SCZO = cond(dh);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			eax -= ecx;
			++ebx;
			__out<word32>(0xD1, eax);
			eax += Mem0[ecx + 18:word32];
			SCZO = cond(eax);
		}
	}
	v42 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	C = v42;
	v43 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	v44 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rol<byte,byte>(bh, cl);
	ch <<= cl;
	ch &= 0x78;
	SZ = cond(ch);
	O = false;
	C.u0 = false;
	v45 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v45;
	fn0040DAAA();
	esp = (union Eq_3 *) ((char *) esp + 6);
	fn0040DAAA();
}

// 0040D4FB: define fn0040D4FB
// Called from:
//      fn0040D4D9
//      fn0040DB68
define fn0040D4FB
{
	esp = fp;
	Top = 0;
	bh |= ~0x19;
	ebx |= eax;
	C.u0 = false;
	dh = dh - 0x5C - C;
	edx = eax;
	v14 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rol<byte,byte>(dl, cl);
	C = v14;
	dl = ~dl;
	bl = bl - 0x1B - C;
	SCZO = cond(bl);
	dl = dl + bl + C;
	SCZO = cond(dl);
	fn0040DCF6();
}

// 0040D518: define fn0040D518
// Called from:
//      fn0040D8DC
//      fn0040DD61
define fn0040D518
{
	esp = fp;
	Top = 0;
	--dh;
	v9 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	edx <<= cl;
	v13 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	edx >>= cl;
	SCZO = cond(edx);
	&bh.u2->u0 = &(C.u3 + ((byte) bh + 58) /8 4)->u0;
	SCZO = cond(bh);
	v15 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	dl |= dh;
	esi = &(edx.u2 + esi / 4)->u0;
	esp -= 4;
	*esp = ecx;
	dl &= 0x8E;
	edi = &(edx.u2 + edi / 4)->u0;
	&edx.u2->u0 = &(edx.u2 + esi / 4)->u0;
	SCZO = cond(edx);
	dl += cl;
	bl |= al;
	edi = edi ^ ecx;
	bl <<= cl;
	eax += 0x0078;
	bl <<= cl;
	bh += dl;
	SCZO = cond(bh);
	dh = bh;
	bl = dl;
	dl = dl - 0x19 - C;
	SCZO = cond(dl);
	ebx = ebx - eax - C;
	SCZO = cond(ebx);
	fn0040D456();
}

// 0040D62D: define fn0040D62D
// Called from:
//      fn0040D9E6
//      fn0040DBFF
define fn0040D62D
{
	esp = fp;
	Top = 0;
	__cli();
	dl |= dh;
	bl = bl ^ 0xA5;
	bl &= ah;
	SZ = cond(bl);
	O = false;
	C = false;
	edx = (word32) al;
	fn0040DA72();
}

// 0040D68C: define fn0040D68C
// Called from:
//      fn0040DCBC
define fn0040D68C
{
	esp = fp;
	Top = 0;
	al = al - 0xC5 - C;
	edi <<= cl;
	SCZO = cond(edi);
	fn0040D690();
}

// 0040D690: define fn0040D690
// Called from:
//      fn0040D68C
//      fn0040DB2B
define fn0040D690
{
	esp = fp;
	Top = 0;
	__out<word32>(0x47, eax);
	esi >>= cl;
	--edi;
	ecx |= eax;
	C.u0 = false;
	bl = (bool) C.u0 + (bl + 0x4A);
	SCZO = cond(bl);
	dl = ah;
	&cl.u2->u0 = (byte) cl + 1;
	v17 = esp;
	esp -= 4;
	esp->ptr0000 = v17;
	v18 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	ecx <<= cl;
	SCZO = cond(ecx);
	fn0040DAE2();
}

// 0040D711: define fn0040D711
// Called from:
//      fn0040D9E6
//      fn0040DDAE
define fn0040D711
{
	esp = fp;
	Top = 0;
	dh = dh - cl - C;
	edx >>= cl;
	dh = ~dh;
	dl |= 0x13;
	dl = dl ^ dh;
	ah |= cl;
	edx = edi;
	ah = ah ^ ~0x31;
	ah = -ah;
	eax |= ebx;
	C.u0 = false;
	&eax.u2->u0 = (word32) eax + 1;
	SZO = cond(eax);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			ah = ah ^ *ebx;
			SZ = cond(ah);
			O = false;
			C.u0 = false;
			dl.u0 = 0x05;
			__out<word32>(0x50, eax);
			eax = *(union Eq_3 *) 3905024035;
			fn0040D741();
			return;
		}
	}
	ah |= 151;
	C.u0 = false;
	esi = esi - edx - C;
	ah &= 0xA3;
	C.u0 = false;
	v22 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rcl<word32,byte>(esi, cl, C);
	esi >>= cl;
	edx -= 894040926;
	&ah.u2->u0 = &(ah.u2 + bh /8 4)->u0;
	SCZO = cond(ah);
	ah = ~ah;
	v24 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rol<byte,byte>(ah, cl);
	C = v24;
	&eax.u2->u0 = (word32) eax + 1;
	al = al - 0x14 - C;
	SCZO = cond(al);
	&esi.u2->u0 = (word32) esi + 1;
	ah = dl;
	al = ~al;
	ah = ah + dh + C;
	C = esi != 0x00;
	esi = -esi;
	ah = ah - bl - C;
	SCZO = cond(edx - 0xCAB604A2);
	if (Test(NE,Z))
		fn0040D78C();
	else
	{
		ch >>= cl;
		SCZO = cond(ch);
		ch >>= cl;
		SCZ = cond(ch);
		edx += edi;
		dh = dh ^ 0x8C;
		&eax.u2->u0 = (word32) eax + 1;
		++bl;
		cl <<= cl;
		ch -= cl;
		&esi.u2->u0 = &(esi.u2 + ecx / 4)->u0;
		ch += ah;
		esi >>= cl;
		al = ~al;
		bh |= cl;
		ah >>= cl;
		bl -= 0x1E;
		SCZO = cond(bl);
		ah = ah + 0x30 + C;
		&eax.u2->u0 = (word32) eax + 1;
		++edi;
		bh = (byte) ch + bh;
		edi <<= cl;
		ebx &= edx;
		ecx = edi;
		ebx |= eax;
		--bl;
		bl >>= cl;
		SCZO = cond(bl);
		dh = dh - 44 - C;
		SCZO = cond(dh);
		bh <<= cl;
		SCZO = cond(bh);
	}
}

// 0040D73D: define fn0040D73D
// Called from:
//      fn0040D884
//      fn0040DCF6
define fn0040D73D
{
	word32 esi;
	word32 eax;
	word32 ecx;
	word32 ebx;
	word32 edx;
	word32 edi;
	Top_3 = 0;
	esi_6 = esi & eax;
	fn0040D742();
}

// 0040D741: define fn0040D741
// Called from:
//      fn0040DB2B
define fn0040D741
{
	esp = fp;
	Top = 0;
	v7 = (bool) C + (*ebx + bl);
	*ebx = v7;
	SCZO = cond(v7);
	fn0040D742();
}

// 0040D742: define fn0040D742
// Called from:
//      fn0040D73D
//      fn0040D741
define fn0040D742
{
	word32 ecx;
	word32 esi;
	word32 eax;
	bool C;
	cl = (byte) ecx;
	word32 ebx;
	bh_51 = SLICE(ebx, byte, 8);
	word32 edx;
	word32 edi;
	Top_27 = 0;
	esi_31 = esi - eax - (word32) C;
	SCZO_32 = cond(esi_31);
	C_35.u0 = SLICE(SCZO_32, bool, 1);
	v9_34 = (esi_31 & 0x01 << 0x20 - cl) != 0x00;
	esi_36 = __rcl<word32,byte>(esi_31, cl, C_35);
	esi_39 = esi_36 - ebx - v9_34;
	eax_41 = eax + edx;
	ah_54 = SLICE(eax_41, byte, 8);
	edx_42 = edx >> cl;
	dl_44 = (byte) edx_42;
	dh_50 = SLICE(edx_42, byte, 8);
	edx_16_16_58 = SLICE(edx_42, word16, 16);
	dl_46 = dl_44 - 0x3B - (byte) (edx_42 < 0x00);
	edi_48 = edi >> cl;
	dh_53 = dh_50 + bh_51 + (byte) (edi_48 < 0x00);
	dl_55 = dl_46 + ah_54;
	SCZO_56 = cond(dl_55);
	Z_57 = SLICE(SCZO_56, bool, 2);
	edx_67 = SEQ(edx_16_16_58, dh_53, dl_55);
	ecx_69 = ecx;
	C_83 = SLICE(SCZO_56, bool, 1);
	O_92 = SLICE(SCZO_56, bool, 4);
	S_94 = (bool) SCZO_56;
	if (dl_55 == 0x00)
	{
		fn0040DAC5();
		ecx_86 = ecx;
	}
	else
		fn0040D75B();
}

// 0040D75B: define fn0040D75B
// Called from:
//      fn0040D741
//      fn0040D742
define fn0040D75B
{
	word32 edx;
	word32 ecx;
	bool Z;
	dl = (byte) edx;
	dh = SLICE(edx, byte, 8);
	edx_16_16 = SLICE(edx, word16, 16);
	word32 edi;
	word32 eax;
	word32 ebx;
	bool C;
	bool O;
	bool S;
	bh_24 = SLICE(ebx, byte, 8);
	bl_26 = (byte) ebx;
	Top_3 = 0;
	cl_11 = (byte) ecx;
	edx_32 = edx;
	if (Z)
		fn0040DAC5();
	else
	{
		eax_22 = 1634484386;
		fn0040D768();
	}
}

// 0040D768: define fn0040D768
// Called from:
//      fn0040D741
//      fn0040DBFF
define fn0040D768
{
	esp = fp;
	Top = 0;
	eax >>= cl;
	bl -= ah;
	ah >>= cl;
	dl += 111;
	SCZO = cond(dl);
	ah = ah - 155 - C;
	eax = eax ^ esi;
	ebx |= ecx;
	C.u0 = false;
	++dh;
	SZO = cond(dh);
	esp -= 4;
	*esp = ecx;
	fn0040DDA9();
}

// 0040D78C: define fn0040D78C
// Called from:
//      fn0040D9E6
//      fn0040DDAE
define fn0040D78C
{
	esp = fp;
	Top = 0;
	eax = eax ^ esi;
	dh &= 171;
	C.u0 = false;
	--edx;
	v15 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	al <<= cl;
	SCZO = cond(al);
	fn0040D9C2();
}

// 0040D80E: define fn0040D80E
// Called from:
//      fn0040DDAE
//      fn0040DDAF
define fn0040D80E
{
	esp = fp;
	Top = 0;
	dl -= ch;
	esi &= edx;
	SZ = cond(esi);
	O = false;
	C = false;
	fn0040D8A7();
}

// 0040D828: define fn0040D828
// Called from:
//      fn0040DB68
define fn0040D828
{
	esp = fp;
	Top = 0;
	v5 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rcl<byte,byte>(dl, cl, C);
	v8 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	C = v8;
	bl = bl - bh - C;
	SCZO = cond(bl);
	v13 = (dl & 0x01 << 0x08 - cl) != 0x00;
	dl = __rcl<byte,byte>(dl, cl, C);
	eax &= esi;
	v18 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	eax >>= cl;
	bl >>= cl;
	SCZO = cond(bl);
	fn0040D47B();
}

// 0040D844: define fn0040D844
// Called from:
//      fn0040D8DC
//      fn0040DAAA
define fn0040D844
{
	esp = fp;
	Top = 0;
	ah |= bl;
	dh = ~0x18;
	bl |= dl;
	al = al ^ dl;
	SZ = cond(al);
	O = false;
	C = false;
	fn0040D84C();
}

// 0040D84C: define fn0040D84C
// Called from:
//      fn0040D9C2
//      fn0040DB68
define fn0040D84C
{
	esp = fp;
	Top = 0;
	ah = ah ^ dl;
	C.u0 = false;
	edi = edi - eax - C;
	SCZO = cond(edi);
	if (Test(EQ,Z))
		fn0040D8BA();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040D8BA();
		else
		{
			al = al - 0x8A - C;
			SCZO = cond(al);
			fnD270_2B73();
			fn0040D85F();
		}
	}
}

// 0040D85F: define fn0040D85F
// Called from:
//      fn0040DB68
//      fn0040DCF6
define fn0040D85F
{
	esp = fp;
	Top = null;
	*edx = (int32) *Top;
}

// 0040D884: define fn0040D884
// Called from:
//      fn0040DB2B
//      fn0040DCF6
define fn0040D884
{
	esp = fp;
	Top = 0;
	edi |= ebx;
	esi |= edx;
	edi = edi ^ esi;
	edi >>= cl;
	v13 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v13;
	esi = esi - edx - C;
	esi = esi ^ ecx;
	SZ = cond(esi);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D73D();
	else
		fn0040D898();
}

// 0040D898: define fn0040D898
// Called from:
//      fn0040D884
//      fn0040DCF6
define fn0040D898
{
	esp = fp;
	Top = 0;
	ecx = ecx;
	if (Test(NE,Z))
		fn0040D73D();
	else
	{
		edx = 3057376596;
		if (Test(NO,O))
			fn0040D8A6();
		else
		{
			__syscall<byte>(0x04);
			fn0040D8A6();
		}
	}
}

// 0040D8A6: define fn0040D8A6
// Called from:
//      fn0040D898
//      fn0040D9C2
define fn0040D8A6
{
	esp = fp;
	Top = 0;
	ah = ah ^ *edx;
	SZ = cond(ah);
	O = false;
	C = false;
	fn0040D8A8();
}

// 0040D8A7: define fn0040D8A7
// Called from:
//      fn0040D995
//      fn0040DDAE
define fn0040D8A7
{
	esp = fp;
	Top = 0;
	dh &= al;
	SZ = cond(dh);
	O = false;
	C = false;
	fn0040D8A8();
}

// 0040D8A8: define fn0040D8A8
// Called from:
//      fn0040D8A6
//      fn0040D8A7
define fn0040D8A8
{
	ptr32 fp;
	byte dl;
	word32 ebx;
	byte cl;
	word24 edx_24_8;
	<unknown> Mem0;
	word24 ecx_24_8;
	word32 esi;
	word32 edi;
	word32 ebp;
	word32 dwArg00;
	esp_22 = fp;
	Top_23 = 0;
	__lock();
	dl_25 = dl + 0x38;
	v7_28 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx_29 = __rol<word32,byte>(ebx, cl);
	edx_31 = SEQ(edx_24_8, dl + 0x38);
	edx_32 = edx_31 << cl;
	SCZO_33 = cond(edx_32);
	ebx_34 = ebx_29 - 0x01;
	bh_41 = SLICE(ebx_29 - 0x01, byte, 8);
	SZO_35 = cond(ebx_29 - 0x01);
	edx_37 = dwArg00;
	esp_38 = fp + 4;
	ecx_40 = SEQ(ecx_24_8, cl);
	fn0040DA55();
	esp_51 = fp;
}

// 0040D8BA: define fn0040D8BA
// Called from:
//      fn0040DB68
define fn0040D8BA
{
	esp = fp;
	Top = 0;
	edx = edx ^ edi;
	C.u0 = false;
	v11 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	C = v11;
	dh = 100;
	ebx = edi;
	dh = dh - 0xB4 - C;
	edi |= eax;
	C.u0 = false;
	v16 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	al += 116;
	dh <<= cl;
	--ecx;
	edx = -edx;
	al >>= cl;
	SCZO = cond(al);
	fn0040D828();
}

// 0040D8DC: define fn0040D8DC
// Called from:
//      fn0040D9C2
//      fn0040D9C3
define fn0040D8DC
{
	esp = fp;
	Top = null;
	edx |= eax;
	dh |= bh;
	ah -= dl;
	SCZO = cond(ah);
	ah = ah + bh + C;
	ah |= ~0x62;
	dh |= bh;
	C.u0 = false;
	v16 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	v18 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	esi |= edi;
	C.u0 = false;
	ah = ah - 0xD2 - C;
	bh += 191;
	SCZO = cond(bh);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			if (Test(ULT,C))
			{
				fn0040D8A6();
				return;
			}
			else
			{
				esp -= 4;
				*esp = (byte **) edi;
				SCZO = cond(*esi - *edi);
				&esi.u2->u0 = (word32) esi + 1;
				++edi;
				do
					--ecx;
				while (Test(EQ,Z) && ecx != 0x00);
				edi = (byte *) 4157527002;
				ebx->w0059 = (int16) trunc(Top->r0000);
				Top = (struct Eq_4024 *) &Top->r0001;
				edx = edx ^ eax;
				ah = ah ^ bh;
				C.u0 = false;
				bl = bl - dl - C;
				bl = bl ^ ah;
				C.u0 = false;
				bh = (bool) C.u0 + (bh + bl);
				SCZO = cond(bh);
				v24 = (dh & 0x01 << 0x08 - cl) != 0x00;
				dh = __rol<byte,byte>(dh, cl);
				C = v24;
				fn0040D844();
				return;
			}
		}
	}
	dl = (ui8) ((bool) C.u0 + (dl + ch));
	eax &= ebx;
	ah <<= cl;
	v27 = (ah & 0x01 << cl) != 0x00;
	ah = __ror<byte,byte>(ah, cl);
	ah |= ~0x0C;
	&ah.u2->u0 = (byte) ah + 1;
	C = dl != 0x00;
	dl = -dl;
	--eax;
	SZO = cond(eax);
	if (Test(EQ,Z))
	{
		SZP = cond(eax & 0xE88017CF);
		dl = dl ^ dl;
		SZ = cond(dl);
		O = false;
		C.u0 = false;
	}
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
		{
			SZP = cond(eax & 0xE88017CF);
			dl = dl ^ dl;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
		}
		else
		{
			Top->r0000 += Top->r0001;
			eax |= ~0x05EC4E0F;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			fn0040DD7D();
		}
	}
}

// 0040D908: define fn0040D908
// Called from:
//      fn0040DAAA
define fn0040D908
{
	esp = fp;
	Top = 0;
	++bh;
	edx = -edx;
	v10 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	edi = -edi;
	--ebx;
	ecx = *esp;
	++esp;
	edx = edx ^ eax;
	ah = ah ^ bh;
	C.u0 = false;
	bl = bl - dl - C;
	bl = bl ^ ah;
	C.u0 = false;
	bh = (bool) C.u0 + (bh + bl);
	SCZO = cond(bh);
	v22 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rol<byte,byte>(dh, cl);
	C = v22;
	fn0040D844();
}

// 0040D995: define fn0040D995
// Called from:
//      fn0040D456
//      fn0040D8A7
//      fn0040DDAE
define fn0040D995
{
	esp = fp;
	Top = 0;
	bh = (bool) C + (bh + dh);
	dl = dl ^ bl;
	C.u0 = false;
	dh = (bool) C.u0 + (dh + bh);
	v13 = eax->dw0010;
	esp -= 4;
	*esp = v13;
	dh &= 0x04;
	C.u0 = false;
	bl = (bool) C.u0 + (bl + 0x87);
	ebx = ebx ^ ecx;
	bl &= 0x7C;
	dl &= 0xAC;
	C.u0 = false;
	esi = (word32) ((bool) C.u0 + (esi + edx));
	bl += ah;
	SCZO = cond(bl);
	if (Test(EQ,Z))
		fn0040D8A7();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040D8A7();
		else
		{
			eax = (struct Eq_4275 *) ((char *) &eax->dw0010 + 0x1AE78001);
			SCZO = cond(eax);
			fn0040D9C3();
		}
	}
}

// 0040D9C2: define fn0040D9C2
// Called from:
//      fn0040DB2B
define fn0040D9C2
{
	esp = fp;
	Top = 0;
	dl = dl - al - C;
	SCZO = cond(dl);
	fn0040D9C3();
}

// 0040D9C3: define fn0040D9C3
// Called from:
//      fn0040D9C2
//      fn0040DDAE
define fn0040D9C3
{
	esp = fp;
	Top = 0;
	v4 = (eax->tD3D2ADC4.u0 & 0x01 << 0x08 - 0x01) != 0x00;
	eax->tD3D2ADC4.u0 = (int8) __rol<byte,byte>(eax->tD3D2ADC4.u0, 0x01);
	dl -= ah;
	esi &= ebx;
	dl |= 0x5A;
	C.u0 = false;
	bh = bh + cl + C;
	SCZO = cond(bh);
	al = al - ch - C;
	eax |= edi;
	bh = *ecx;
	eax |= edi;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	fn0040D8DC();
}

// 0040D9E6: define fn0040D9E6
// Called from:
//      fn0040DB2B
define fn0040D9E6
{
	esp = fp;
	Top = 0;
	edx = edx ^ ebx;
	edi >>= cl;
	SCZ = cond(edi);
	&v13.u2->u0 = ecx->u2;
	esp -= 4;
	esp->u2 = (Eq_3 (*)[]) v13;
	v14 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	C = v14;
	v15 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	&bl.u2->u0 = (byte) bl + 0x00D2;
	v18 = (ebx & 0x01 << cl) != 0x00;
	ebx = __ror<word32,byte>(ebx, cl);
	C = v18;
	v19 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	C = v19;
	v20 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	dl &= dh;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	v24 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rcl<byte,byte>(ah, cl, C);
	C = v24;
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			SZP = cond(ecx & 1212721417);
			eax &= esi;
			dl <<= cl;
			dl |= 151;
			bl = bh;
			dh |= bh;
			dl = dl ^ cl;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				ecx = ecx;
				if (Test(EQ,Z))
				{
					SCZO = cond(al - 0x69);
					&eax.u2->u0 = (bool) C.u0 + ((word32) eax + 0x03A6EA60);
					SCZO = cond(eax);
					SZP = cond(eax & 0xE88017CF);
					dl = dl ^ dl;
					SZ = cond(dl);
					O = false;
					C.u0 = false;
					return;
				}
			}
			edx |= eax;
			C.u0 = false;
			v31 = (eax & 0x01 << cl) != 0x00;
			eax = __rcr<word32,byte>(eax, cl, C);
			edx = -edx;
			esi &= edx;
			esi = esi ^ edi;
			esi -= ecx;
			dl |= cl;
			SZ = cond(dl);
			O = false;
			C.u0 = false;
			ah <<= cl;
			SCZO = cond(ah);
			ecx->u0 = (int8) bl;
			&esi.u2->u0 = (word32) esi + 1;
			ah = ah + al + C;
			&ah.u2->u0 = &(ah.u2 + dh /8 4)->u0;
			ah -= 0x69;
			eax += edx;
			dh = dh ^ 0x8A;
			dh &= 0x06;
			--ah;
			dh = dh ^ ch;
			ecx = (union Eq_3 *) ((char *) ecx + 1);
			dh -= 0x61;
			SCZO = cond(dh);
			if (Test(NE,Z))
			{
				ecx = ecx;
				if (Test(EQ,Z))
				{
					__lock();
					&esi.u2->u0 = esp->u2;
					esp = (union Eq_3 *) ((char *) esp + 4);
					eax = eax - 3552958592 - C;
					SCZO = cond(eax);
					fn0040D690();
					return;
				}
			}
			dl = ~dl;
			++dh;
			dl = dl + ah + C;
			edx |= esi;
			edx |= edi;
			C.u0 = false;
			dl = (ui8) ((bool) C.u0 + (dl + ~0x61));
			al >>= cl;
			--edi;
			esi <<= cl;
			SCZO = cond(esi);
			fn0040DD8B();
			return;
		}
	}
	edx |= esi;
	&eax.u2->u0 = esp->u2;
	esp = (union Eq_3 *) ((char *) esp + 4);
	dl -= al;
	ebx &= ecx;
	dl -= bl;
	bh -= ~0x41;
	SCZO = cond(bh);
	edx -= esi;
	edi |= edx;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	fn0040D62D();
}

// 0040DA55: define fn0040DA55
// Called from:
//      fn0040D8A7
//      fn0040D8A8
define fn0040DA55
{
	word32 ecx;
	word32 edx;
	ptr32 fp;
	byte bh;
	dh = SLICE(edx, byte, 8);
	bool C;
	word32 esi;
	word32 edi;
	cl = (byte) ecx;
	ecx_24_8 = SLICE(ecx, word24, 8);
	<unknown> Mem0;
	word32 ebp;
	bool D;
	selector ss;
	esp_2 = fp;
	bh_7 = bh - dh - (byte) C;
	esi_10 = esi - edi;
	bh_12 = bh_7 << cl;
	v14_15 = (bh_12 & 133 & 0x01 << 0x08 - cl) != 0x00;
	esi_19 = __rcr<word32,byte>(esi_10, cl, v14_15);
	esi_26 = esi_19 << cl;
	edx_37 = edx;
	edi_34 = -(edi + 0x01);
	ecx_39 = ecx;
	edx_40 = edx_37 + ecx_39;
	dl_78 = (byte) edx_40;
	dh_105 = SLICE(edx_40, byte, 8);
	edx_16_16_107 = SLICE(edx_40, word16, 16);
	esi_45 = esi_26 - edi_34;
	esi_47 = __ror<word32,byte>(esi_45, cl);
	v25_51 = (esi_47 & 0x01 << 0x20 - cl) != 0x00;
	esi_52 = __rol<word32,byte>(esi_47, cl);
	edi_54 = edx_40;
	esi_56 = __rcr<word32,byte>(esi_52, cl, v25_51);
	bh_67 = SLICE(edx_40, byte, 8);
	bl_70 = (byte) edx_40;
	ebx_16_16_85 = SLICE(edx_40, word16, 16);
	eax_66 = (<anonymous> *) *edx_40;
	&ah_93.u2->u0 = SLICE(eax_66, byte, 8);
	al_100 = (byte) eax_66;
	bh_68 = bh_67 >> cl;
	bl_72 = (byte) (&(cl.u2 + bl_70 /8 4)->u0 + (byte) (bh_68 < 0x00));
	SCZO_73 = cond(bl_72);
	Z_74 = SLICE(SCZO_73, bool, 2);
	ecx_75 = ecx;
	ebx_86 = SEQ(ebx_16_16_85, bh_68, bl_72);
	O_261 = SLICE(SCZO_73, bool, 4);
	S_327 = (bool) SCZO_73;
	if (bl_72 != 0x00)
	{
		ecx_76 = ecx_75;
		if (bl_72 == 0x00)
		{
			C_260 = __aaa(al_100, ah_93, &al_100, &ah_93);
			if (OVERFLOW<byte>(bl_72))
				__syscall<byte>(0x04);
			Top_266 = 1;
			fn0040D711();
			return;
		}
	}
	v32_81 = (dl_78 & 0x01 << cl) != 0x00;
	dl_82 = __ror<byte,byte>(dl_78, cl);
	ebx_88 = ebx_86 + edx_40 + v32_81;
	bh_89 = SLICE(ebx_88, byte, 8);
	ebx_16_16_108 = SLICE(ebx_88, word16, 16);
	bl_109 = (byte) ebx_88;
	bh_90 = bh_89 >> cl;
	dl_94 = dl_82 ^ ah_93;
	esi_97 = -esi_56;
	ebx_88_110 = SEQ(ebx_16_16_108, bh_90 + 0x14, bl_109);
	eax_66();
	esp_115 = fp + 2;
	D_281 = SLICE(SCZDO_120, bool, 3);
	O_319 = SLICE(SCZDO_120, bool, 4);
	S_331 = (bool) SCZDO_120;
	Top_116 = 0;
	Z_121 = SLICE(SCZDO_120, bool, 2);
	C_128.u0 = SLICE(SCZDO_120, bool, 1);
	eax_24_8_153 = SLICE(eax_119, word24, 8);
	dl_166 = (byte) edx_117;
	&ah_176.u2->u0 = SLICE(eax_119, byte, 8);
	eax_16_16_186 = SLICE(eax_119, word16, 16);
	if (Z_121)
		fn0040DB45();
	else
	{
		ecx_122 = ecx_118;
		cl_135 = (byte) ecx_118;
		ebx_295 = SEQ(ebx_16_16_108, bh_90 + 0x14, bl_109);
		if (Z_121)
			fn0040DB45();
		else
		{
			esp_124 = fp;
			psegLoc02_350 = (selector) ecx_118;
			v34_129 = (char *) edx_40 + ebp->dwF223D52A + (word32) SCZDO_120;
			ebp->dwF223D52A = v34_129;
			al_133 = bh_90 + 0x14 + (bh_90 + 0x14) + (byte) (v34_129 < 0x00);
			ebx_134 = SEQ(ebx_16_16_108, bh_90 + 0x14, bl_109);
			ebx_136 = ebx_134 << cl_135;
			bh_139 = SLICE(ebx_136, byte, 8);
			bl_150 = (byte) ebx_136;
			ebx_16_16_151 = SLICE(ebx_136, word16, 16);
			cl_145 = (byte) ecx_118 + 0x81;
			ch_207 = SLICE(ecx_118 + ~0x017E, byte, 8);
			ecx_16_16_219 = SLICE(ecx_118 + ~0x017E, word16, 16);
			v35_146 = (bh_139 + 0x59 & 0x01 << cl_145) != 0x00;
			bh_147 = __rcr<byte,byte>(bh_139 + 0x59, cl_145, false);
			ebx_152 = SEQ(ebx_16_16_151, bh_147, bl_150);
			eax_154 = SEQ(eax_24_8_153, al_133 ^ 0x22);
			ebx_155 = ebx_152 - eax_154 - v35_146;
			ebx_156 = ebx_155 + eax_154;
			bh_169 = SLICE(ebx_156, byte, 8);
			bl_205 = (byte) ebx_156;
			ebx_16_16_251 = SLICE(ebx_156, word16, 16);
			v99_270 = SEQ(al_133 ^ 0x22, esi_97) >> cl_145;
			al_158 = SLICE(v99_270, byte, 32);
			esi_162 = (word32) v99_270;
			esi_163 = esi_162 ^ ebx_156;
			edi_165 = (<anonymous> **) 0xC8AA9040;
			al_167 = al_158 + dl_166;
			v100_271 = SEQ(bh_169, edx_117) >> cl_145;
			bh_170 = SLICE(v100_271, byte, 32);
			al_172 = ~al_167;
			edx_175 = (word32) v100_271;
			dl_202 = (byte) edx_175;
			edx_24_8_225 = SLICE(edx_175, word24, 8);
			v38_177 = (ah_176 & 0x01 << 0x08 - cl_145) != 0x00;
			ah_178 = __rol<byte,byte>(ah_176, cl_145);
			C_179 = v38_177;
			eax_24_8_187 = SEQ(eax_16_16_186, ah_178);
			ecx_353 = SEQ(ecx_16_16_219, ch_207, cl_145);
			if (bh_170 != 0x00)
			{
				ecx_181 = ecx_118 + ~0x017E;
				cl_192 = (byte) ecx_118 + 0x81;
				ch_208 = SLICE(ecx_118 + ~0x017E, byte, 8);
				ecx_16_16_220 = SLICE(ecx_118 + ~0x017E, word16, 16);
				eax_285 = SEQ(eax_24_8_187, al_172);
				ebx_293 = SEQ(ebx_16_16_251, bh_170, bl_205);
				ecx_354 = SEQ(ecx_16_16_220, ch_208, cl_192);
				if (bh_170 == 0x00)
				{
					esi_255 = esi_163 - 0x01;
					SZO_256 = cond(esi_163 - 0x01);
					O_316 = SLICE(SZO_256, bool, 4);
					S_328 = (bool) SZO_256;
					Z_343 = SLICE(SZO_256, bool, 2);
					ss_257 = psegLoc02_350;
					esp_258 = fp;
					D_259 = false;
					return;
				}
			}
			ecx_355 = (ecx_353, ecx_354);
			ch_206 = SLICE(ecx_355, byte, 8);
			cl_191 = (byte) ecx_355;
			al_184 = al_172 - 0xC0 - v38_177;
			eax_188 = SEQ(eax_24_8_187, al_184);
			eax_24_8_197 = SLICE(eax_188 - 0x01, word24, 8);
			ah_215 = SLICE(eax_188 - 0x01, byte, 8);
			eax_16_16_244 = SLICE(eax_188 - 0x01, word16, 16);
			al_193 = al_184 - 0x01 << cl_191;
			edi_195 = (<anonymous> **) 0x0B7B;
			eax_198 = SEQ(eax_24_8_197, al_193);
			esi_199 = esi_163 & eax_198;
			bl_209 = bl_205 + ch_206;
			bh_211 = bh_170 ^ cl_191;
			C_214.u0 = false;
			ah_216 = ~ah_215;
			ecx_221 = ecx_355;
			edx_226 = SEQ(edx_24_8_225, dl_202 + ~0x2A);
			eax_245 = SEQ(eax_16_16_244, ah_216, al_193);
			ebx_252 = SEQ(ebx_16_16_251, bh_211, bl_209);
			if (bh_211 != 0x00)
			{
				ecx_222 = ecx_221;
				if (bh_211 == 0x00)
				{
					eax_246 = eax_245 - 0x01;
					SZO_247 = cond(eax_245 - 0x01);
					O_317 = SLICE(SZO_247, bool, 4);
					S_329 = (bool) SZO_247;
					Z_344 = SLICE(SZO_247, bool, 2);
					esp_249 = fp;
					ebp_254 = (struct Eq_4721 *) 3560087583;
					fn0040DBAD();
					return;
				}
			}
			edx_228 = edx_226 - esi_199;
			dh_230 = SLICE(edx_228, byte, 8);
			edx_16_16_306 = SLICE(edx_228, word16, 16);
			dl_307 = (byte) edx_228;
			dh_234 = dh_230 + ch_206 + (byte) (edx_228 < 0x00);
			dh_237 = dh_234 + ch_206 + (byte) (dh_234 < 0x00);
			SCZO_238 = cond(dh_237);
			O_318 = SLICE(SCZO_238, bool, 4);
			S_330 = (bool) SCZO_238;
			Z_345 = SLICE(SCZO_238, bool, 2);
			v42_241 = (dh_237 & 0x01 << 0x08 - cl_191) != 0x00;
			dh_242 = __rol<byte,byte>(dh_237, cl_191);
			C_243 = v42_241;
			ecx_300 = ecx_355;
			edx_308 = SEQ(edx_16_16_306, dh_242, dl_307);
			fn0040D78C();
		}
	}
}

// 0040DA72: define fn0040DA72
// Called from:
//      fn0040D62D
//      fn0040D9E6
define fn0040DA72
{
	esp = fp;
	Top = 0;
	bh = bh - 117 - C;
	--bh;
	esi >>= cl;
	SCZO = cond(esi);
	v11 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	C = v11;
	esi = esi - edx - C;
	ebx <<= cl;
	SCZO = cond(ebx);
	esi = esi - ebx - C;
	--bh;
	v15 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	ebx |= eax;
	SZ = cond(ebx);
	O = false;
	ebx = (word32) ah;
	v20 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	C = v20;
	fn0040D884();
}

// 0040DAAA: define fn0040DAAA
// Called from:
//      fn0040D4D9
define fn0040DAAA
{
	esp = fp;
	Top = 0;
	edi <<= cl;
	v7 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rol<word32,byte>(ecx, cl);
	bh |= cl;
	SZ = cond(bh);
	O = false;
	C = false;
	if (Test(EQ,Z))
		fn0040D908();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040D908();
		else if (Test(SG,S))
		{
			SZP = cond(edx & eax);
			O = false;
			C = false;
		}
		else
		{
			&eax.u2->u0 = esp->u2;
			esp = (union Eq_3 *) ((char *) esp + 4);
			esp -= 4;
			esp->u2 = (Eq_3 (*)[]) 0x69;
			++esi;
			SZO = cond(esi);
			&ecx.u2->u0 = esp->u2;
			esp = (union Eq_3 *) ((char *) esp + 4);
			fn0040DAC5();
		}
	}
}

// 0040DAC5: define fn0040DAC5
// Called from:
//      fn0040D741
//      fn0040D742
//      fn0040DAAA
define fn0040DAC5
{
	byte dl;
	byte dh;
	word16 edx_16_16;
	word32 edi;
	byte cl;
	word32 eax;
	word32 ebx;
	bh_27 = SLICE(ebx, byte, 8);
	bl_30 = (byte) ebx;
	Top_3 = 0;
	dl_6 = dl | dh;
	edx_9 = SEQ(edx_16_16, dh, dl_6);
	edx_11 = edx_9 + edi;
	dh_12 = SLICE(edx_11, byte, 8);
	edx_16_16_14 = SLICE(edx_11, word16, 16);
	dl_15 = (byte) edx_11;
	dh_13 = -dh_12;
	edx_16 = SEQ(edx_16_16_14, dh_13, dl_15);
	edx_19 = __rol<word32,byte>(edx_16, cl);
	dl_24 = (byte) edx_19;
	edx_24_8_34 = SLICE(edx_19, word24, 8);
	eax_22 = eax + ebx;
	dl_26 = dl_24 - 100 - (byte) (eax_22 < 0x00);
	dl_28 = dl_26 | bh_27;
	bl_31 = bl_30 + bh_27;
	SCZO_32 = cond(bl_31);
	C_33 = SLICE(SCZO_32, bool, 1);
	edx_35 = SEQ(edx_24_8_34, dl_28);
	O_36 = SLICE(SCZO_32, bool, 4);
	S_37 = (bool) SCZO_32;
	Z_38 = SLICE(SCZO_32, bool, 2);
	fn0040DC55();
}

// 0040DAE2: define fn0040DAE2
// Called from:
//      fn0040D68C
//      fn0040D690
define fn0040DAE2
{
	esp = fp;
	Top = 0;
	edi <<= cl;
	SCZO = cond(edi);
	v8 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v8;
	v11 = (ecx & 0x01 << cl) != 0x00;
	ecx = __rcr<word32,byte>(ecx, cl, C);
	v12 = (cl & 0x01 << cl) != 0x00;
	cl = __ror<byte,byte>(cl, cl);
	dh &= 0x70;
	C.u0 = false;
	cl = cl + ch + C;
	esp -= 4;
	*esp = 0x05566305;
	dl >>= cl;
	C = bl != 0x00;
	bl = -bl;
	v21 = (eax & 0x01 << cl) != 0x00;
	eax = __rcr<word32,byte>(eax, cl, C);
	C = v21;
	edx = edx - edi - C;
	esi <<= cl;
	SCZO = cond(esi);
	fn0040D4D9();
}

// 0040DB2B: define fn0040DB2B
// Called from:
//      fn0040D47B
define fn0040DB2B
{
	esp = fp;
	Top = 0;
	dl = dl - cl - C;
	SCZO = cond(dl);
	while (true)
	{
		bh = -bh;
		ebx <<= cl;
		--dh;
		ecx <<= 0x0F;
		dl += dh;
		SCZO = cond(dl);
		eax = ecx;
		v14 = (bh & 0x01 << 0x08 - cl) != 0x00;
		bh = __rol<byte,byte>(bh, cl);
		C = v14;
		if (Test(NE,Z))
		{
			ecx = ecx;
			if (Test(EQ,Z))
				;
		}
		bl = 0x90;
		bl = bl ^ ah;
		edx >>= cl;
		SCZ = cond(edx);
		bh = bh + dl + C;
		SCZO = cond(bh);
		bl = bl - ~0x04 - C;
		SCZO = cond(bl);
		edx = (struct Eq_5411 *) ((char *) edx + 1);
		SZO = cond(edx);
		if (Test(EQ,Z))
		{
			fn0040D9E6();
			return;
		}
		ecx = ecx;
		if (Test(NE,Z))
		{
			fn0040D9E6();
			return;
		}
		esp -= ebx->dwFFFFFFAC;
		bh |= bl;
		SZ = cond(bh);
		O = false;
		C.u0 = false;
		__fldenv(edx->w001A);
	}
}

// 0040DB45: define fn0040DB45
// Called from:
//      fn0040D8A7
//      fn0040DDAE
define fn0040DB45
{
	esp = fp;
	Top = 0;
	edi = edi ^ ebx;
	esi = esi ^ edx;
	C.u0 = false;
	dl = (bool) C.u0 + (dl + bl);
	SCZO = cond(dl);
	esi = (ui32) ((bool) C.u0 + (esi + edx));
	v15 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	ebx += eax;
	dh &= ch;
	ebx = -ebx;
	esi <<= cl;
	SCZO = cond(esi);
	dl = (bool) C.u0 + (dl + bl);
	ch |= 0x6B;
	SZ = cond(ch);
	O = false;
	C.u0 = false;
	fn0040DBFF();
}

// 0040DB68: define fn0040DB68
// Called from:
//      fn0040DC55
define fn0040DB68
{
	esp = fp;
	Top = 0;
	bl += al;
	edx += esi;
	dl &= 177;
	C.u0 = false;
	ebx = (word32) ((bool) C.u0 + (ebx + esi));
	++ebx;
	ebx += esi;
	SCZO = cond(ebx);
	v16 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	C = v16;
	eax |= eax;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
		fn0040D84C();
	else
	{
		--dh;
		edx = edx ^ eax;
		esi += edx;
		edx += edi;
		SCZO = cond(edx);
		bh = bl;
		fn0040D4FB();
	}
}

// 0040DBAD: define fn0040DBAD
// Called from:
//      fn0040D456
//      fn0040D8A7
//      fn0040DBCD
define fn0040DBAD
{
	esp = fp;
	Top = 0;
	dl = dl ^ ah;
	C.u0 = false;
	ebx = ebx - edi - C;
	dl |= al;
	eax += ecx;
	SCZO = cond(eax);
	v17 = (bh & 0x01 << cl) != 0x00;
	bh = __rcr<byte,byte>(bh, cl, C);
	C = v17;
	dh = (bool) C.u0 + (dh + dl);
	SCZO = cond(dh);
	dl = (ui8) ((bool) C.u0 + (dl + 101));
	ebx -= edx;
	bl |= 0x09;
	bh <<= cl;
	SCZO = cond(bh);
	dl = (ui8) ((bool) C.u0 + (dl + al));
	SCZO = cond(dl);
	bl = 0x4F;
	if (Test(EQ,Z))
		fn0040D995();
	else
		fn0040DBCD();
}

// 0040DBCD: define fn0040DBCD
// Called from:
//      fn0040D456
//      fn0040DBAD
define fn0040DBCD
{
	esp = fp;
	Top = 0;
	fn0040DBAD();
}

// 0040DBDA: define fn0040DBDA
// Called from:
//      fn0040DCF6
//      fn0040DDAE
define fn0040DBDA
{
	esp = fp;
	Top = 0;
	dh = dh - 118 - C;
	SCZO = cond(dh);
	edi = edi - esi - C;
	--ebx;
	edi &= eax;
	edx = eax + 80;
	C = ebx != 0x00;
	ebx = -ebx;
	bl = bl - cl - C;
	SCZO = cond(bl);
	--bh;
	bh = 0x55;
	bl = bl - cl - C;
	bl = 0xA2;
	bl += ~0x44;
	SCZO = cond(bl);
	bl = bl - 0x19 - C;
	SCZO = cond(bl);
	fn0040DD61();
}

// 0040DBFF: define fn0040DBFF
// Called from:
//      fn0040DDAE
define fn0040DBFF
{
	esp = fp;
	Top = 0;
	ecx = ecx - eax - C;
	dl |= ~0x30;
	ecx = *esp;
	++esp;
	ecx = *esp;
	++esp;
	bh = (byte) &(ah.u2 + bh /8 4)->u0;
	--dh;
	esi = esi ^ eax;
	bh -= 0xCC;
	ah -= ch;
	SCZO = cond(ah);
	--bh;
	bl = bl - dl - C;
	SCZO = cond(bl);
	bh = (bool) C + (bh + 199);
	SCZO = cond(bh);
	ah <<= cl;
	SCZO = cond(ah);
	ebx = (word32) ((bool) C + (ebx + edx));
	edx += ecx;
	bl <<= cl;
	edx &= eax;
	C.u0 = false;
	ah = ah + bl + C;
	ecx -= ~0x017E;
	SCZO = cond(ecx);
	&ah.u2->u0 = (bool) C.u0 + ((byte) ah + 0x00C2);
	SCZO = cond(ah);
	&ah.u2->u0 = (bool) C.u0 + ((byte) ah + 0x008A);
	v21 = (ah & 0x01 << 0x08 - cl) != 0x00;
	ah = __rol<byte,byte>(ah, cl);
	esi += edx;
	SCZO = cond(esi);
	bh = 0x48;
	if (Test(EQ,Z))
		fn0040D768();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040D768();
		else
		{
			SZP = cond(*esi & 0x0BD62B30);
			O = false;
			C.u0 = false;
			fn0040D62D();
		}
	}
}

// 0040DC55: define fn0040DC55
// Called from:
//      fn0040D741
//      fn0040DAAA
define fn0040DC55
{
	esp = fp;
	Top = 0;
	bh >>= cl;
	esi |= ecx;
	bl <<= cl;
	edi -= ebx;
	SCZO.u0 = cond(edi);
	--edx;
	v18 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rcl<word32,byte>(esi, cl, C);
	edx = ebx;
	eax = eax ^ ~0x0137;
	edx += eax;
	SCZO.u0 = cond(edx);
	dh = dh - 0x22 - C;
	bl = bl ^ ch;
	dh &= bh;
	SZ = cond(dh);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			SCZO.u1 = esp->u1;
			esp = (union Eq_5845 *) ((char *) esp + 4);
			return;
		}
	}
	dl = ~dl;
	dl -= al;
	SCZO.u0 = cond(dl);
	bh = bh - 0xA2 - C;
	dl -= 0x1F;
	ebx &= edi;
	eax = ~eax;
	dh = dh ^ cl;
	v25 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	C = v25;
	esi = esi + edx + C;
	SCZO.u0 = cond(esi);
	fn0040DB68();
}

// 0040DCBC: define fn0040DCBC
// Called from:
//      Win32CrtStartup
//      fn0040D4D9
define fn0040DCBC
{
	esp = fp;
	Top = 0;
	edx &= esi;
	ch += bl;
	dl &= bl;
	ch &= ~0x46;
	bl >>= cl;
	--esi;
	ah = 117;
	cl &= 121;
	al -= bl;
	v18 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	C = v18;
	ch = ch - dl - C;
	SCZO = cond(ch);
	esp -= 4;
	*esp = ecx;
	fn0040D68C();
}

// 0040DCF6: define fn0040DCF6
// Called from:
//      fn0040D4D9
//      fn0040D4FB
define fn0040DCF6
{
	esp = fp;
	Top = 0;
	edi <<= ~0x24;
	SCZO = cond(edi);
	dh = ah;
	v11 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rcl<word32,byte>(esi, cl, C);
	C = v11;
	bh = bh - al - C;
	SCZO = cond(bh);
	edx = edx - ebx - C;
	bl -= 0x6D;
	bl <<= cl;
	dh += 55;
	eax += eax->dw003C / 64;
	dl = 0x11;
	dh <<= cl;
	SCZO = cond(dh);
	if (Test(NE,Z))
	{
		ecx = ecx;
		if (Test(EQ,Z))
		{
			esp -= 4;
			*esp = edi;
			__sti();
			return;
		}
	}
	v22 = (bl & 0x01 << cl) != 0x00;
	bl = __rcr<byte,byte>(bl, cl, C);
	C = v22;
	fn0040D85F();
}

// 0040DD61: define fn0040DD61
// Called from:
//      fn0040DBDA
//      fn0040DD7D
define fn0040DD61
{
	esp = fp;
	Top = 0;
	v5 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	edi |= edx;
	bh -= 0xC2;
	bl = bl ^ dh;
	esi >>= cl;
	v17 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	v18 = *edx;
	esp -= 4;
	*esp = v18;
	bl >>= cl;
	dl = dl ^ 114;
	C.u0 = false;
	bl = bl - dl - C;
	SCZO = cond(bl);
	if (Test(EQ,Z))
		fn0040D518();
	else
		fn0040DD7D();
}

// 0040DD7D: define fn0040DD7D
// Called from:
//      fn0040D8DC
//      fn0040DD61
define fn0040DD7D
{
}

// 0040DD8B: define fn0040DD8B
// Called from:
//      fn0040D9C2
//      fn0040D9E6
define fn0040DD8B
{
	esp = fp;
	Top = 0;
	dl = ~dl;
	al = al ^ ah;
	edx <<= cl;
	SCZO = cond(edx);
	v15 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	v17 = (eax & 0x01 << cl) != 0x00;
	eax = __ror<word32,byte>(eax, cl);
	C = al != 0x00;
	al = -al;
	SZO = cond(al);
	if (Test(EQ,Z))
		fn0040D711();
	else
	{
		ecx = ecx;
		if (Test(NE,Z))
			fn0040D711();
		else
		{
			v21 = *(int8 *) 2331706036 >> cl;
			*(int8 *) 2331706036 = v21;
			SCZ = cond(v21);
		}
	}
}

// 0040DDA9: define fn0040DDA9
// Called from:
//      fn0040DBFF
define fn0040DDA9
{
	esp = fp;
	Top = 0;
	bh += bl;
	bl = cl;
	bh >>= cl;
	SCZO = cond(bh);
	fn0040DDAF();
}

// 0040DDAE: define fn0040DDAE
// Called from:
//      fn0040D9C2
define fn0040DDAE
{
	esp = fp;
	Top = 0;
	__out<word32>(dx, eax);
	fn0040DDAF();
}

// 0040DDAF: define fn0040DDAF
// Called from:
//      fn0040DDA9
//      fn0040DDAE
define fn0040DDAF
{
	esp = fp;
	Top = 0;
	al -= 0x5F;
	--esi;
	bl += cl;
	eax &= edi;
	SZ = cond(eax);
	O = false;
	C = false;
	fn0040D80E();
}

