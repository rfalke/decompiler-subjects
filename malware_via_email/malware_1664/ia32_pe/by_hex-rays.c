/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall sub_40DCBC(int _EAX@<eax>, int@<edx>, int@<ecx>, int@<ebx>, int@<ebp>, int@<edi>, int@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40DAAA; // weak


//----- (0040DCBC) --------------------------------------------------------
void __usercall sub_40DCBC(
        int _EAX@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        int a6@<edi>,
        int a7@<esi>)
{
  int v7; // ebx
  int v12; // edx
  int v13; // edi
  unsigned int v17; // edx
  bool v20; // zf
  unsigned int v21; // esi
  int v22; // edx
  int v25; // edi
  unsigned int v29; // esi
  unsigned int v30; // eax
  unsigned int v32; // ett
  int v34; // esi
  bool v35; // tt
  int v36; // edi
  int v37; // esi
  unsigned int v38; // edi
  int v39; // edx
  int v42; // edi
  int v46; // esi
  __int16 v47; // bx
  bool v48; // zf
  int v49; // edx
  int v58; // esi
  int v59; // ebx
  char v63; // cl
  int v64; // eax
  int v69; // esi
  int v70; // edx
  char v71; // bh
  bool v72; // tt
  int v73; // ebx
  bool v75; // zf
  int v76; // esi
  int v77; // esi
  unsigned int v78; // edi
  int v80; // esi
  int v81; // ebx
  int v83; // edi
  int v85; // edx
  __int16 v88; // bx
  int v91; // edx
  bool v92; // tt
  bool v93; // cf
  unsigned __int8 v94; // tt
  int v96; // esi
  int v98; // [esp-4h] [ebp-4h] BYREF

  v91 = a7 & a2;
  LOBYTE(v91) = a4 & v91;
  BYTE1(a3) = (a4 + BYTE1(a3)) & 0xB9;
  LOBYTE(a4) = (char)a4 >> a3;
  BYTE1(_EAX) = 117;
  LOBYTE(a3) = a3 & 0x79;
  v92 = __CFSHR__(BYTE1(v91), a3);
  BYTE1(v91) = __ROR1__(BYTE1(v91), a3);
  v94 = v92 + v91;
  v93 = BYTE1(a3) < v94;
  BYTE1(a3) -= v94;
  v98 = a3;
  LOBYTE(_EAX) = _EAX - a4 - (v93 - 59);
  _ESI = (unsigned int)(a7 - 1) >> a3;
  v25 = a6 << a3;
  _ECX = _EAX | a3;
  LOBYTE(_ECX) = _ECX + 1;
  __asm { rcr     esi, cl }
  _ECX = _ECX << _ECX;
  _EDI = v25 << _ECX;
  __asm
  {
    rcr     edi, cl
    rcr     ecx, cl
  }
  BYTE1(v91) &= 0x70u;
  LOBYTE(_ECX) = BYTE1(_ECX) + __ROR1__(_ECX, _ECX);
  LOBYTE(v91) = 0x75u >> _ECX;
  LOBYTE(a4) = -(char)(a4 + 74);
  __asm { rcr     eax, cl }
  _EDX = v91 - (((_BYTE)a4 != 0) + _EDI);
  v69 = _ESI << _ECX;
  LOBYTE(_ECX) = __ROL1__(_ECX, _ECX);
  _EDI = _ECX;
  __asm { rcl     edi, cl }
  v93 = __CFSHR__(BYTE1(_EDX), _ECX);
  SBYTE1(_EDX) >>= _ECX;
  BYTE1(_EAX) = BYTE1(_EAX) - 56 - (v93 + 50);
  LOBYTE(_ECX) = 5;
  __asm
  {
    rcr     edx, cl
    rcl     edx, cl
  }
  LOBYTE(a4) = _EAX ^ a4;
  v96 = 32 * v69;
  _EDI = (a4 | _EDI) - 1;
  LOBYTE(a4) = BYTE1(a4) | a4 | 0xE4;
  __asm { rcl     edi, cl }
  LOBYTE(_EAX) = (_EAX & 0xB2) - 99;
  HIBYTE(v88) = a4 & BYTE1(a4);
  _ECX = 64;
  LOBYTE(_EDX) = _EDX - 32;
  LOBYTE(_EDX) = ~(_BYTE)_EDX;
  HIBYTE(v88) -= 118;
  v46 = v96 - _EDX;
  BYTE1(_EDX) |= BYTE1(_EAX);
  v47 = (v88 - 1) & 0x40;
  v49 = __ROL4__(_EDX, 64);
  LOBYTE(v47) = -43;
  v48 = (_BYTE)v49 + BYTE1(v49) == 0;
  BYTE1(v49) += v49;
  if ( BYTE1(v49) && v48 )
  {
    __outdword(0xD1u, _EAX - 64);
    JUMPOUT(0x40D996);
  }
  _ESI = __ROR4__(v46, 64);
  __asm { rcr     esi, cl }
  BYTE1(_ECX) = 0;
  __asm { rcr     edi, cl }
  v63 = __ROL4__(_ECX, 64);
  HIBYTE(v47) = (v63 | __ROL1__(HIBYTE(v47), 64)) + 1;
  _ESI = __ROR4__(_ESI, v63);
  v83 = -_EDI;
  _ECX = (_DWORD *)&loc_40DAAA;
  _EDX = _EAX ^ -v49;
  BYTE1(_EAX) = ((unsigned __int16)(v47 - 1) >> 8) ^ BYTE1(_EAX) ^ (-44 - _EDX) | ((unsigned __int16)(v47 - 1) >> 8) ^ BYTE1(_EAX);
  BYTE1(_EDX) = -25;
  LOBYTE(_EAX) = _EDX ^ _EAX;
  while ( 1 )
  {
    BYTE1(_EAX) ^= _EDX;
    v36 = v83 - _EAX;
    v39 = v36 ^ _EDX;
    __asm { rcr     esi, cl }
    _EBX = v36;
    v42 = _EAX | v36;
    __asm { rcl     ebx, cl }
    BYTE1(v39) = -80 << (char)_ECX;
    _ECX = (unsigned int)_ECX - 1;
    _EDX = -v39;
    LOBYTE(_EAX) = (unsigned __int8)(_EAX + 116) >> _ECX;
    __asm { rcl     dl, cl }
    v35 = __CFSHR__(_EBX, _ECX);
    v7 = __ROR4__(_EBX, _ECX);
    __asm { rcl     dl, cl }
    BYTE1(_EDX) = __ROR1__(BYTE1(_EDX), _ECX);
    _EAX = (_ESI & (unsigned int)_EAX) >> _ECX;
    LOBYTE(v7) = (unsigned __int8)(v7 - (v35 + BYTE1(v7))) >> _ECX;
    BYTE1(v7) ^= 0xEDu;
    _EDX = _EAX + _EDX;
    __asm { rcr     al, cl }
    v93 = __CFSHR__(_ECX, 15);
    _ECX = _ECX >> 15;
    __asm { rcl     edx, cl }
    v12 = _ECX + v93 + _EDX;
    LOBYTE(v12) = v12 - 1;
    v13 = v42 + 1;
    LOBYTE(v12) = v12 - (__CFSHR__(BYTE1(_EAX), _ECX) + _ECX);
    BYTE1(v7) = -BYTE1(v7);
    v73 = v7 << _ECX;
    --BYTE1(v12);
    _ECX = _ECX << 15;
    v75 = BYTE1(v12) + (_BYTE)v12 == 0;
    LOBYTE(v12) = BYTE1(v12) + v12;
    _EAX = _ECX;
    BYTE1(v73) = __ROL1__(BYTE1(v73), _ECX);
    if ( v75 || !v75 )
      break;
    __asm { icebp }
    --a5;
    __asm { into }
    v76 = v12 ^ _ESI;
    v93 = __CFADD__((_BYTE)v73, (_BYTE)v12);
    LOBYTE(v12) = v73 + v12;
    v77 = v12 + v93 + v76;
    v78 = __ROR4__(v73 ^ v13, _ECX);
    v81 = -(_ECX + v73);
    LOBYTE(v12) = (v81 + __CFSHL__(v77, _ECX) + v12) | 0xCF;
    BYTE1(v12) = (BYTE1(_ECX) & BYTE1(v12)) - 1;
    v80 = _ECX ^ (v77 << _ECX);
    BYTE1(_EAX) = BYTE1(_ECX) - ((unsigned __int16)&v98 >> 8);
    v93 = (unsigned __int8)v81 < (unsigned __int8)((BYTE1(_ECX) < (unsigned __int8)((unsigned __int16)&v98 >> 8)) + v12);
    LOBYTE(v81) = v81 - ((BYTE1(_ECX) < (unsigned __int8)((unsigned __int16)&v98 >> 8)) + v12);
    BYTE1(v81) = v93 + BYTE1(_ECX) + BYTE1(v81) + 51 - 57;
    v93 = __CFSHL__(BYTE1(_EAX), (unsigned __int8)&v98);
    BYTE1(_EAX) <<= (char)&v98;
    _EBX = v12 + v93 + v81;
    LOBYTE(_EBX) = (_BYTE)_EBX << (char)&v98;
    v17 = _EAX & ((unsigned int)&v98 + v12);
    _ECX = &STACK[0x17B];
    BYTE1(_EAX) = __ROL1__(
                    (__CFADD__((unsigned int)&v98 < 0xFFFFFE81, _EBX + BYTE1(_EAX)) | __CFADD__(
                                                                                        ((unsigned int)&v98 < 0xFFFFFE81)
                                                                                      + _EBX
                                                                                      + BYTE1(_EAX),
                                                                                        -62))
                  + ((unsigned int)&v98 < 0xFFFFFE81)
                  + _EBX
                  + BYTE1(_EAX)
                  - 62
                  - 118,
                    (unsigned __int8)&v98 + 127);
    v20 = v17 + v80 == 0;
    v21 = v17 + v80;
    if ( !v21 || !v20 )
      JUMPOUT(0x40DDA9);
    _disable();
    LOBYTE(_EBX) = BYTE1(_EAX) & (_EBX ^ 0xA5);
    v22 = (unsigned __int8)_EAX;
    BYTE1(_EBX) = -46;
    __asm { rcl     bh, cl }
    v58 = (v21 >> (char)&STACK[0x17B])
        - (__CFSHR__(v21, (unsigned __int8)&STACK[0x17B])
         + (unsigned __int8)_EAX)
        - (__CFSHL__(_EBX, (unsigned __int8)&STACK[0x17B])
         + (_EBX << (char)&STACK[0x17B]));
    v59 = BYTE1(_EAX);
    v37 = (unsigned __int8)_EAX | __ROR4__(v58, (char)&STACK[0x17B]);
    v38 = (v37 ^ (BYTE1(_EAX) | v78)) >> (char)&STACK[0x17B];
    v29 = _EAX & ((unsigned int)&STACK[0x17B] ^ (v37
                                               - (__CFSHL__(v38, (unsigned __int8)&STACK[0x17B])
                                                + (unsigned __int8)_EAX)));
    v93 = __CFSHR__(_EAX, 16);
    v30 = HIWORD(_EAX);
    v32 = v93 + v30;
    v93 = v29 < v32;
    _ESI = v29 - v32;
    __asm { rcl     esi, cl }
    v34 = _ESI - (v93 + v59);
    v64 = v59 + v22 + v30;
    LOBYTE(v59) = BYTE1(v59) + v59;
    SBYTE1(v59) >>= (char)&STACK[0x17B];
    _ESI = (unsigned int)&STACK[0x17B] | v34;
    LOBYTE(v59) = (_BYTE)v59 << (char)&STACK[0x17B];
    v83 = ((int)__ROL4__(v38, (char)&STACK[0x17B]) >> (char)&STACK[0x17B]) - v59;
    __asm { rcl     esi, cl }
    v64 ^= 0xFFFFFEC8;
    v85 = v64 + v59;
    BYTE1(v85) = BYTE1(v59) & (((unsigned __int16)(v64 + v59) >> 8) - (__CFADD__(v64, v59) + 34));
    LOBYTE(v85) = ~(v64 + v59);
    BYTE1(v59) -= ((unsigned __int8)v85 < (unsigned __int8)v64) - 94;
    LOBYTE(v85) = v85 - v64 - 31;
    _EAX = ~v64;
    BYTE1(v85) ^= (unsigned __int8)&STACK[0x17B];
    _ESI = v85 + __CFSHR__(BYTE1(v83) & BYTE1(v59), (unsigned __int8)&STACK[0x17B]) + _ESI;
    _EDX = _ESI + v85;
    LOBYTE(_EDX) = _EDX & 0xB1;
    __asm { rcl     dh, cl }
    if ( !_EAX )
      JUMPOUT(0x40DCF6);
  }
  v93 = __CFSHR__(v12, _ECX);
  v70 = v12 >> _ECX;
  v72 = v93;
  v93 = __CFADD__(v93, BYTE1(v73));
  v71 = v72 + BYTE1(v73);
  v93 |= __CFADD__((_BYTE)v70, v71);
  BYTE1(v73) = v70 + v71;
  LOBYTE(v73) = (BYTE1(_ECX) ^ 0x90) - (v93 - 5);
  if ( v70 != -1 )
    JUMPOUT(0x40DB1E);
  _EDX = v73;
  _EDI = v13 >> _ECX;
  __asm
  {
    rcr     edx, cl
    rcl     edi, cl
  }
  LOBYTE(v73) = v73 - 46;
  _BL = __ROR4__(v73, _ECX);
  __asm
  {
    rcl     bl, cl
    rcr     edx, cl
    rcl     ah, cl
  }
  JUMPOUT(0x40D62A);
}
// 40D4F7: inconsistent fpu stack
// 40D576: control flows out of bounds to 40D57C
// 40D689: control flows out of bounds to 40D68B
// 40D73A: control flows out of bounds to 40D73C
// 40D859: control flows out of bounds to 40D861
// 40D906: control flows out of bounds to 40D907
// 40D993: control flows out of bounds to 40D996
// 40DB1C: control flows out of bounds to 40DB1E
// 40DB1F: control flows out of bounds to 40DB21
// 40DDA5: control flows out of bounds to 40DDAC
// 40DC7E: control flows out of bounds to 40DC7F
// 40D50E: control flows out of bounds to 40DCF6
// 40D77B: control flows out of bounds to 40DDA9
// 40DD31: control flows out of bounds to 40D62A
// 40DDB7: control flows out of bounds to 40D80E
// 40D56E: control flows out of bounds to 40DBAD
// 40DBC7: control flows out of bounds to 40D995
// 40DD11: control flows out of bounds to 40D85E
// 40DD4C: control flows out of bounds to 40DA32
// 40DD85: control flows out of bounds to 40DD5D
// 40D4F1: conditional instruction was optimized away because ah.1!=0
// 40D855: conditional instruction was optimized away because edi.4!=0
// 40D89A: conditional instruction was optimized away because esi.4!=0
// 40DA05: conditional instruction was optimized away because dl.1!=0
// 40DAB8: conditional instruction was optimized away because bh.1!=0
// 40DC78: conditional instruction was optimized away because dh.1!=0
// 40DC9D: conditional instruction was optimized away because dl.1!=0
// 40DCED: conditional instruction was optimized away because bl.1>=E4u
// 40DCF1: conditional instruction was optimized away because bl.1>=E4u

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
