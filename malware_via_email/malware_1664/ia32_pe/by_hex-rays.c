/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall sub_40DCBC(int _EAX@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40DAAA; // weak


//----- (0040DCBC) --------------------------------------------------------
void __usercall sub_40DCBC(int _EAX@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, int a6@<edi>, int a7@<esi>)
{
  int v7; // ebx
  int v12; // edx
  int v13; // edi
  unsigned int v17; // edx
  bool v20; // zf
  unsigned int v21; // esi
  int v22; // edx
  int v25; // edi
  unsigned int v29; // esi
  unsigned int v30; // eax
  unsigned int v32; // ett
  int v34; // esi
  bool v35; // tt
  int v36; // edi
  int v37; // esi
  unsigned int v38; // edi
  int v39; // edx
  int v42; // edi
  int v46; // esi
  __int16 v47; // bx
  bool v48; // zf
  int v49; // edx
  int v58; // esi
  int v59; // ebx
  char v63; // cl
  int v64; // eax
  int v65; // ebx
  int v70; // esi
  int v71; // edx
  char v72; // bh
  bool v73; // tt
  int v74; // ebx
  bool v76; // zf
  int v77; // esi
  int v78; // esi
  unsigned int v79; // edi
  int v81; // esi
  int v82; // ebx
  int v84; // edi
  int v86; // edx
  __int16 v89; // bx
  int v92; // edx
  bool v93; // tt
  bool v94; // cf
  unsigned __int8 v95; // tt
  int v97; // esi
  int v99; // [esp-4h] [ebp-4h] BYREF

  v92 = a7 & a2;
  LOBYTE(v92) = a4 & v92;
  BYTE1(a3) = (a4 + BYTE1(a3)) & 0xB9;
  LOBYTE(a4) = (char)a4 >> a3;
  BYTE1(_EAX) = 117;
  LOBYTE(a3) = a3 & 0x79;
  v93 = __CFSHR__(BYTE1(v92), a3);
  BYTE1(v92) = __ROR1__(BYTE1(v92), a3);
  v95 = v93 + v92;
  v94 = BYTE1(a3) < v95;
  BYTE1(a3) -= v95;
  v99 = a3;
  LOBYTE(_EAX) = _EAX - a4 - (v94 - 59);
  _ESI = (unsigned int)(a7 - 1) >> a3;
  v25 = a6 << a3;
  _ECX = _EAX | a3;
  LOBYTE(_ECX) = _ECX + 1;
  __asm { rcr     esi, cl }
  _ECX = _ECX << _ECX;
  _EDI = v25 << _ECX;
  __asm
  {
    rcr     edi, cl
    rcr     ecx, cl
  }
  BYTE1(v92) &= 0x70u;
  LOBYTE(_ECX) = BYTE1(_ECX) + __ROR1__(_ECX, _ECX);
  LOBYTE(v92) = 0x75u >> _ECX;
  LOBYTE(a4) = -(char)(a4 + 74);
  __asm { rcr     eax, cl }
  _EDX = v92 - (((_BYTE)a4 != 0) + _EDI);
  v70 = _ESI << _ECX;
  LOBYTE(_ECX) = __ROL1__(_ECX, _ECX);
  _EDI = _ECX;
  __asm { rcl     edi, cl }
  v94 = __CFSHR__(BYTE1(_EDX), _ECX);
  SBYTE1(_EDX) >>= _ECX;
  BYTE1(_EAX) = BYTE1(_EAX) - 56 - (v94 + 50);
  LOBYTE(_ECX) = 5;
  __asm
  {
    rcr     edx, cl
    rcl     edx, cl
  }
  LOBYTE(a4) = _EAX ^ a4;
  v97 = 32 * v70;
  _EDI = (a4 | _EDI) - 1;
  LOBYTE(a4) = BYTE1(a4) | a4 | 0xE4;
  __asm { rcl     edi, cl }
  LOBYTE(_EAX) = (_EAX & 0xB2) - 99;
  HIBYTE(v89) = a4 & BYTE1(a4);
  _ECX = 64;
  LOBYTE(_EDX) = _EDX - 32;
  LOBYTE(_EDX) = ~(_BYTE)_EDX;
  HIBYTE(v89) -= 118;
  v46 = v97 - _EDX;
  BYTE1(_EDX) |= BYTE1(_EAX);
  v47 = (v89 - 1) & 0x40;
  v49 = __ROL4__(_EDX, 64);
  LOBYTE(v47) = -43;
  v48 = (_BYTE)v49 + BYTE1(v49) == 0;
  BYTE1(v49) += v49;
  if ( BYTE1(v49) && v48 )
  {
    __outdword(0xD1u, _EAX - 64);
    JUMPOUT(0x40D996);
  }
  _ESI = __ROR4__(v46, 64);
  __asm { rcr     esi, cl }
  BYTE1(_ECX) = 0;
  __asm { rcr     edi, cl }
  v63 = __ROL4__(_ECX, 64);
  HIBYTE(v47) = (v63 | __ROL1__(HIBYTE(v47), 64)) + 1;
  _ESI = __ROR4__(_ESI, v63);
  v84 = -_EDI;
  _ECX = (_DWORD *)&loc_40DAAA;
  _EDX = _EAX ^ -v49;
  BYTE1(_EAX) = ((unsigned __int16)(v47 - 1) >> 8) ^ BYTE1(_EAX) ^ (-44 - _EDX) | ((unsigned __int16)(v47 - 1) >> 8) ^ BYTE1(_EAX);
  BYTE1(_EDX) = -25;
  LOBYTE(_EAX) = _EDX ^ _EAX;
  while ( 1 )
  {
    BYTE1(_EAX) ^= _EDX;
    v36 = v84 - _EAX;
    v39 = v36 ^ _EDX;
    __asm { rcr     esi, cl }
    _EBX = v36;
    v42 = _EAX | v36;
    __asm { rcl     ebx, cl }
    BYTE1(v39) = -80 << (char)_ECX;
    _ECX = (unsigned int)_ECX - 1;
    _EDX = -v39;
    LOBYTE(_EAX) = (unsigned __int8)(_EAX + 116) >> _ECX;
    __asm { rcl     dl, cl }
    v35 = __CFSHR__(_EBX, _ECX);
    v7 = __ROR4__(_EBX, _ECX);
    __asm { rcl     dl, cl }
    BYTE1(_EDX) = __ROR1__(BYTE1(_EDX), _ECX);
    _EAX = (_ESI & (unsigned int)_EAX) >> _ECX;
    LOBYTE(v7) = (unsigned __int8)(v7 - (v35 + BYTE1(v7))) >> _ECX;
    BYTE1(v7) ^= 0xEDu;
    _EDX = _EAX + _EDX;
    __asm { rcr     al, cl }
    v94 = __CFSHR__(_ECX, 15);
    _ECX = _ECX >> 15;
    __asm { rcl     edx, cl }
    v12 = _ECX + v94 + _EDX;
    LOBYTE(v12) = v12 - 1;
    v13 = v42 + 1;
    LOBYTE(v12) = v12 - (__CFSHR__(BYTE1(_EAX), _ECX) + _ECX);
    BYTE1(v7) = -BYTE1(v7);
    v74 = v7 << _ECX;
    --BYTE1(v12);
    _ECX = _ECX << 15;
    v76 = BYTE1(v12) + (_BYTE)v12 == 0;
    LOBYTE(v12) = BYTE1(v12) + v12;
    _EAX = _ECX;
    BYTE1(v74) = __ROL1__(BYTE1(v74), _ECX);
    if ( v76 || !v76 )
      break;
    __asm { icebp }
    --a5;
    __asm { into }
    v77 = v12 ^ _ESI;
    v94 = __CFADD__((_BYTE)v74, (_BYTE)v12);
    LOBYTE(v12) = v74 + v12;
    v78 = v12 + v94 + v77;
    v79 = __ROR4__(v74 ^ v13, _ECX);
    v82 = -(_ECX + v74);
    LOBYTE(v12) = (v82 + __CFSHL__(v78, _ECX) + v12) | 0xCF;
    BYTE1(v12) = (BYTE1(_ECX) & BYTE1(v12)) - 1;
    v81 = _ECX ^ (v78 << _ECX);
    BYTE1(_EAX) = BYTE1(_ECX) - ((unsigned __int16)&v99 >> 8);
    v94 = (unsigned __int8)v82 < (unsigned __int8)((BYTE1(_ECX) < (unsigned __int8)((unsigned __int16)&v99 >> 8)) + v12);
    LOBYTE(v82) = v82 - ((BYTE1(_ECX) < (unsigned __int8)((unsigned __int16)&v99 >> 8)) + v12);
    BYTE1(v82) = v94 + BYTE1(_ECX) + BYTE1(v82) + 51 - 57;
    v94 = __CFSHL__(BYTE1(_EAX), (unsigned __int8)&v99);
    BYTE1(_EAX) <<= (char)&v99;
    _EBX = v12 + v94 + v82;
    LOBYTE(_EBX) = (_BYTE)_EBX << (char)&v99;
    v17 = _EAX & ((unsigned int)&v99 + v12);
    _ECX = &STACK[0x17B];
    BYTE1(_EAX) = __ROL1__(
                    (__CFADD__((unsigned int)&v99 < 0xFFFFFE81, _EBX + BYTE1(_EAX)) | __CFADD__(
                                                                                        ((unsigned int)&v99 < 0xFFFFFE81)
                                                                                      + _EBX
                                                                                      + BYTE1(_EAX),
                                                                                        -62))
                  + ((unsigned int)&v99 < 0xFFFFFE81)
                  + _EBX
                  + BYTE1(_EAX)
                  - 62
                  - 118,
                    (unsigned __int8)&v99 + 127);
    v20 = v17 + v81 == 0;
    v21 = v17 + v81;
    if ( !v21 || !v20 )
      JUMPOUT(0x40DDA9);
    _disable();
    LOBYTE(_EBX) = BYTE1(_EAX) & (_EBX ^ 0xA5);
    v22 = (unsigned __int8)_EAX;
    BYTE1(_EBX) = -46;
    __asm { rcl     bh, cl }
    v58 = (v21 >> (char)&STACK[0x17B])
        - (__CFSHR__(v21, (unsigned __int8)&STACK[0x17B])
         + (unsigned __int8)_EAX)
        - (__CFSHL__(_EBX, (unsigned __int8)&STACK[0x17B])
         + (_EBX << (char)&STACK[0x17B]));
    v59 = BYTE1(_EAX);
    v37 = (unsigned __int8)_EAX | __ROR4__(v58, (char)&STACK[0x17B]);
    v38 = (v37 ^ (BYTE1(_EAX) | v79)) >> (char)&STACK[0x17B];
    v29 = _EAX & ((unsigned int)&STACK[0x17B] ^ (v37
                                               - (__CFSHL__(v38, (unsigned __int8)&STACK[0x17B])
                                                + (unsigned __int8)_EAX)));
    v94 = __CFSHR__(_EAX, 16);
    v30 = HIWORD(_EAX);
    v32 = v94 + v30;
    v94 = v29 < v32;
    _ESI = v29 - v32;
    __asm { rcl     esi, cl }
    v34 = _ESI - (v94 + v59);
    v64 = v59 + v22 + v30;
    v65 = (unsigned __int8)(BYTE1(v59) + v59);
    SBYTE1(v65) >>= (char)&STACK[0x17B];
    _ESI = (unsigned int)&STACK[0x17B] | v34;
    LOBYTE(v65) = (_BYTE)v65 << (char)&STACK[0x17B];
    v84 = ((int)__ROL4__(v38, (char)&STACK[0x17B]) >> (char)&STACK[0x17B]) - v65;
    __asm { rcl     esi, cl }
    v64 ^= 0xFFFFFEC8;
    v86 = v64 + v65;
    BYTE1(v86) = BYTE1(v65) & (((unsigned __int16)(v64 + v65) >> 8) - (__CFADD__(v64, v65) + 34));
    LOBYTE(v86) = ~(v64 + v65);
    BYTE1(v65) -= ((unsigned __int8)v86 < (unsigned __int8)v64) - 94;
    LOBYTE(v86) = v86 - v64 - 31;
    _EAX = ~v64;
    BYTE1(v86) ^= (unsigned __int8)&STACK[0x17B];
    _ESI = v86 + __CFSHR__(BYTE1(v84) & BYTE1(v65), (unsigned __int8)&STACK[0x17B]) + _ESI;
    _EDX = _ESI + v86;
    LOBYTE(_EDX) = _EDX & 0xB1;
    __asm { rcl     dh, cl }
    if ( !_EAX )
      JUMPOUT(0x40DCF6);
  }
  v94 = __CFSHR__(v12, _ECX);
  v71 = v12 >> _ECX;
  v73 = v94;
  v94 = __CFADD__(v94, BYTE1(v74));
  v72 = v73 + BYTE1(v74);
  v94 |= __CFADD__((_BYTE)v71, v72);
  BYTE1(v74) = v71 + v72;
  LOBYTE(v74) = (BYTE1(_ECX) ^ 0x90) - (v94 - 5);
  if ( v71 != -1 )
    JUMPOUT(0x40DB1E);
  _EDX = v74;
  _EDI = v13 >> _ECX;
  __asm
  {
    rcr     edx, cl
    rcl     edi, cl
  }
  LOBYTE(v74) = v74 - 46;
  _BL = __ROR4__(v74, _ECX);
  __asm
  {
    rcl     bl, cl
    rcr     edx, cl
    rcl     ah, cl
  }
  JUMPOUT(0x40D62A);
}
// 40D4F7: inconsistent fpu stack
// 40D576: control flows out of bounds to 40D57C
// 40D689: control flows out of bounds to 40D68B
// 40D73A: control flows out of bounds to 40D73C
// 40D859: control flows out of bounds to 40D861
// 40D906: control flows out of bounds to 40D907
// 40D993: control flows out of bounds to 40D996
// 40DB1C: control flows out of bounds to 40DB1E
// 40DB1F: control flows out of bounds to 40DB21
// 40DDA5: control flows out of bounds to 40DDAC
// 40DC7E: control flows out of bounds to 40DC7F
// 40D50E: control flows out of bounds to 40DCF6
// 40D77B: control flows out of bounds to 40DDA9
// 40DD31: control flows out of bounds to 40D62A
// 40DDB7: control flows out of bounds to 40D80E
// 40D56E: control flows out of bounds to 40DBAD
// 40DBC7: control flows out of bounds to 40D995
// 40DD11: control flows out of bounds to 40D85E
// 40DD4C: control flows out of bounds to 40DA32
// 40DD85: control flows out of bounds to 40DD5D
// 40D4F1: conditional instruction was optimized away because of 'ah.1!=0'
// 40D855: conditional instruction was optimized away because of 'edi.4!=0'
// 40D89A: conditional instruction was optimized away because of 'esi.4!=0'
// 40DA05: conditional instruction was optimized away because of 'dl.1!=0'
// 40DAB8: conditional instruction was optimized away because of 'bh.1!=0'
// 40DC78: conditional instruction was optimized away because of 'dh.1!=0'
// 40DC9D: conditional instruction was optimized away because of 'dl.1!=0'
// 40DCED: conditional instruction was optimized away because of 'bl.1>=E4u'
// 40DCF1: conditional instruction was optimized away because of 'bl.1>=E4u'

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
