/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// HRESULT __stdcall OleRegEnumVerbs(const IID *const clsid, LPENUMOLEVERB *ppenum);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// int *__usercall sub_401920@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char a4, __int64 a5);
// unsigned int __usercall sub_401DD0@<eax>(int a1@<eax>, unsigned int a2@<ecx>, __int64 a3);
void __noreturn start(); // weak


//----- (00401920) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int *__usercall sub_401920@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, char a4, __int64 a5)
{
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  __int16 v8; // dx
  int v9; // ecx
  int v10; // edx
  unsigned int v11; // eax
  __int64 v12; // rax
  int v13; // ecx
  int v14; // ecx
  int v15; // edx
  int *v16; // ecx
  int v17; // edx
  int *v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // edx
  int v26; // ecx
  unsigned int v27; // ecx
  int v29; // [esp+4Ch] [ebp-1DCh]
  _BYTE v30[14]; // [esp+58h] [ebp-1D0h] BYREF
  int v31; // [esp+68h] [ebp-1C0h]
  int v32; // [esp+6Ch] [ebp-1BCh]
  char v33; // [esp+70h] [ebp-1B8h]
  int v34; // [esp+74h] [ebp-1B4h]
  int v35; // [esp+7Ch] [ebp-1ACh]
  __int16 v36; // [esp+80h] [ebp-1A8h]
  int v37; // [esp+94h] [ebp-194h]
  int v38; // [esp+98h] [ebp-190h]
  __int16 v39; // [esp+9Ch] [ebp-18Ch]
  char v40; // [esp+A4h] [ebp-184h] BYREF
  _BYTE v41[6]; // [esp+A6h] [ebp-182h]
  int v42; // [esp+ACh] [ebp-17Ch]
  __int16 v43; // [esp+B0h] [ebp-178h]
  int v44; // [esp+CCh] [ebp-15Ch]
  __int16 v45; // [esp+D4h] [ebp-154h]
  int v46; // [esp+D8h] [ebp-150h]
  int v47; // [esp+DCh] [ebp-14Ch]
  int v48; // [esp+F0h] [ebp-138h]
  int v49; // [esp+F4h] [ebp-134h]
  int v50; // [esp+F8h] [ebp-130h]
  int *v51; // [esp+104h] [ebp-124h]
  int v52; // [esp+108h] [ebp-120h]
  int v53; // [esp+114h] [ebp-114h]
  char v54[8]; // [esp+124h] [ebp-104h] BYREF
  __int16 v55; // [esp+130h] [ebp-F8h]
  int v56; // [esp+138h] [ebp-F0h]
  char v57; // [esp+140h] [ebp-E8h]
  int v58; // [esp+14Ch] [ebp-DCh]
  int v59; // [esp+154h] [ebp-D4h]
  __int16 v60; // [esp+158h] [ebp-D0h]
  int v61; // [esp+15Ch] [ebp-CCh]
  __int64 v62; // [esp+163h] [ebp-C5h]
  char v63; // [esp+16Ch] [ebp-BCh] BYREF
  int v64; // [esp+174h] [ebp-B4h]
  char v65[8]; // [esp+188h] [ebp-A0h] BYREF
  int v66; // [esp+190h] [ebp-98h]
  _DWORD v67[10]; // [esp+195h] [ebp-93h]
  __int16 v68; // [esp+1C0h] [ebp-68h]
  int v69; // [esp+1C4h] [ebp-64h]
  int v70; // [esp+1E0h] [ebp-48h]
  int v71; // [esp+1F0h] [ebp-38h]
  int v72; // [esp+1F4h] [ebp-34h]
  int v73; // [esp+20Ch] [ebp-1Ch]
  int *v74; // [esp+218h] [ebp-10h]
  char v75; // [esp+21Ch] [ebp-Ch]
  int savedregs; // [esp+228h] [ebp+0h] OVERLAPPED BYREF
  void *retaddr; // [esp+22Ch] [ebp+4h] OVERLAPPED

  v5 = a1 + (*(_DWORD *)((char *)&v67[5] + 3) < a3) + a3;
  v6 = a2 & a1;
  if ( a2 )
    goto LABEL_7;
  if ( v6 != v5 )
  {
LABEL_6:
    v5 = (int)&v63;
LABEL_7:
    v9 = -__CFADD__(v5, 12867);
    v44 &= 0x9Fu;
    LOWORD(a2) = v9 & a2;
    goto LABEL_8;
  }
  v7 = v5 & v6;
  v8 = 0;
  if ( v7 == 984 )
    goto LABEL_9;
  v9 = v5 - v31;
  LOWORD(a2) = 14456;
  if ( (v35 & (v7 ^ 0x2AB2)) != v9 )
  {
    v61 |= 0x2Eu;
    LOWORD(v32) = v32 | 0xF8;
    goto LABEL_6;
  }
LABEL_8:
  v8 = savedregs | a2;
  v5 = savedregs ^ v9 ^ 0x1DBA;
  v56 += v5;
  v7 = v54[4] & (unsigned __int8)&savedregs & 0x1A & 0x66;
  v58 ^= 0x66u;
LABEL_9:
  LOWORD(v66) = v66 ^ 0x62;
  v71 |= v5;
  v10 = (v8 - (_WORD)v5) & 0x2FC1;
  v11 = v66 | v38 ^ v7;
  if ( v10 == 991 )
    v11 |= 0x1FE7u;
  if ( v10 == v11 )
    v11 = (unsigned int)v54 | 0x36C1;
  LODWORD(v12) = WaitForSingleObject((HANDLE)(v11 & 6), 0);
  if ( !HIDWORD(v12) )
  {
    v39 += 110;
    LODWORD(v12) = &savedregs;
    v13 += v70;
  }
  HIDWORD(v12) += v12;
  if ( HIDWORD(v12) == v13 )
    goto LABEL_24;
  v14 = v13 - *(_DWORD *)((char *)&v62 + 2);
  v15 = v14 + (v62 | HIDWORD(v62) ^ HIDWORD(v12));
  LODWORD(v12) = &savedregs;
  v16 = (int *)(*(int *)((char *)&savedregs + 3) & v14);
  HIDWORD(v12) = *(char **)((char *)&retaddr + 1) + HIDWORD(a5) + v15;
  if ( v16 )
    goto LABEL_22;
  v36 |= 0xDDu;
  LODWORD(v12) = v47 ^ ((*(_DWORD *)((char *)&a5 + 1) | (unsigned int)&savedregs) - *(_DWORD *)((char *)&retaddr + 1));
  if ( &savedregs == (int *)v12 )
  {
    v53 |= 0x68u;
    v17 = v12 + ((unsigned int)&savedregs | 0x2F6D);
    v18 = &savedregs;
    if ( v51 != &savedregs )
    {
LABEL_25:
      v19 = (int)v18 + __CFADD__(v17, 11571) + v17 + 11571;
      HIDWORD(v12) = &v40;
      LODWORD(v12) = (*(_DWORD *)v41 | v19) - *(_DWORD *)&v41[2];
      v41[2] -= 103;
      goto LABEL_26;
    }
    v52 &= 0xDEu;
    HIDWORD(v12) = v30;
    v16 = &savedregs;
    LODWORD(v12) = savedregs | *(_DWORD *)((_BYTE *)&a5 + 2) & *(_DWORD *)&v30[3] & (v31 ^ (unsigned int)&savedregs);
    v68 ^= 0x4Cu;
    if ( !(_DWORD)v12 )
      goto LABEL_27;
    LOBYTE(v60) = v60 & 0x7C;
    LODWORD(v12) = &v30[v12];
    if ( v30 == (_BYTE *)691 )
      goto LABEL_23;
    v42 |= 0x64u;
    LODWORD(v12) = (unsigned int)&savedregs | (v12 - (_DWORD)&savedregs);
LABEL_22:
    LODWORD(v12) = v12 + 16346;
    LOWORD(v12) = WORD2(v12) & ((v12 + __PAIR64__(v12, (unsigned int)v16)) >> 32);
    v43 |= 0xBAu;
LABEL_23:
    v57 |= 0xD3u;
    v33 -= 61;
    v60 += 238;
LABEL_24:
    LODWORD(v12) = v12 & 0x34FC;
    HIDWORD(v12) += v12;
    LODWORD(v12) = HIDWORD(v12) & v12;
    v17 = v52 | HIDWORD(v12);
    goto LABEL_25;
  }
LABEL_26:
  LODWORD(v12) = v12 - 6664;
  LOWORD(v31) = v31 ^ 0xAF;
LABEL_27:
  v49 &= 0xC3u;
  v20 = (int)&savedregs;
  v69 -= (int)&savedregs;
  LODWORD(v12) = (v29 ^ ((unsigned int)&savedregs + (HIDWORD(v12) & v12))) - 3249;
  if ( v74 != &savedregs )
  {
    v52 |= v12;
    v21 = v73 | ((unsigned int)&savedregs - v12);
    if ( !HIDWORD(v12) )
      goto LABEL_31;
    v20 = v59 ^ v21 | 0xE0;
  }
  v21 = (v66 + (*(_DWORD *)((char *)&v67[7] + 3) & v20)) ^ 0x3880;
  HIDWORD(v12) += v64;
LABEL_31:
  LOBYTE(v48) = v48 | 0x49;
  LODWORD(v12) = v21 + (v12 & 0x137A);
  if ( HIDWORD(v12) == 392 )
  {
    v64 ^= v22 + 392;
    v55 |= 0x10u;
  }
  v44 -= 25;
  v23 = (v72 | v21 | 0x2C09) - 5641;
  v24 = (HIDWORD(v12) ^ 0x1569) + 5641;
  LOBYTE(v70) = v70 + 72;
  *(_DWORD *)v30 ^= v24;
  if ( v24 == 599 )
    goto LABEL_38;
  v50 -= v23;
  v25 = v67[0] ^ (v24 | 0x2049);
  v26 = (*(_DWORD *)((char *)v67 + 2) ^ v23) - (_DWORD)v65;
  if ( v25 != 186 )
  {
    v46 += 18;
    v27 = ((unsigned int)v65 | v26) - 11265;
    if ( v25 == 6965 )
    {
      v37 -= v27;
      v34 -= 161;
    }
    v75 &= 0x94u;
LABEL_38:
    v45 |= 0x3Au;
  }
  return &savedregs;
}
// 401D99: returning address of temporary local variable '%" s"'
// 401920: variables would overlap: ^230.4 and ^233.4
// 401920: variables would overlap: ^234.4(retaddr) and ^235.4

//----- (00401DD0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __usercall sub_401DD0@<eax>(int a1@<eax>, unsigned int a2@<ecx>, __int64 a3)
{
  unsigned int v3; // eax
  char *v4; // edx
  bool v5; // cf
  unsigned int v6; // edx
  int v7; // edx
  char *v8; // eax
  int v9; // edx
  signed int v10; // edx
  int v11; // ecx
  int v12; // ecx
  int v13; // edx
  char *v14; // ecx
  unsigned int result; // eax
  int v16; // [esp+14h] [ebp-2B4h]
  int v17; // [esp+34h] [ebp-294h]
  int v18; // [esp+84h] [ebp-244h]
  int v19; // [esp+88h] [ebp-240h]
  char v20[20]; // [esp+8Ch] [ebp-23Ch] BYREF
  int v21; // [esp+A0h] [ebp-228h]
  int v22; // [esp+A8h] [ebp-220h]
  char v23; // [esp+C8h] [ebp-200h]
  char v24; // [esp+ECh] [ebp-1DCh]
  int v25; // [esp+104h] [ebp-1C4h]
  int v26; // [esp+108h] [ebp-1C0h]
  int v27; // [esp+124h] [ebp-1A4h]
  char v28; // [esp+144h] [ebp-184h]
  int v29; // [esp+154h] [ebp-174h]
  int v30; // [esp+162h] [ebp-166h]
  int v31; // [esp+170h] [ebp-158h]
  int v32; // [esp+17Ch] [ebp-14Ch]
  __int16 v33; // [esp+18Ch] [ebp-13Ch]
  __int16 v34; // [esp+190h] [ebp-138h]
  int v35; // [esp+194h] [ebp-134h]
  int v36; // [esp+198h] [ebp-130h]
  char v37[6]; // [esp+1A8h] [ebp-120h] BYREF
  _BYTE v38[6]; // [esp+1AEh] [ebp-11Ah]
  __int64 v39; // [esp+1B4h] [ebp-114h]
  __int16 v40; // [esp+1C0h] [ebp-108h]
  int v41; // [esp+1D4h] [ebp-F4h]
  char v42; // [esp+1F0h] [ebp-D8h] BYREF
  _DWORD v43[3]; // [esp+1F1h] [ebp-D7h]
  _BYTE v44[5]; // [esp+1FFh] [ebp-C9h]
  int v45; // [esp+208h] [ebp-C0h]
  int v46; // [esp+210h] [ebp-B8h]
  char v47; // [esp+230h] [ebp-98h]
  char v48[9]; // [esp+234h] [ebp-94h] BYREF
  int v49; // [esp+23Dh] [ebp-8Bh]
  char v50[44]; // [esp+244h] [ebp-84h] BYREF
  char v51; // [esp+270h] [ebp-58h]
  int v52; // [esp+280h] [ebp-48h]
  int v53; // [esp+284h] [ebp-44h]
  int v54; // [esp+28Ch] [ebp-3Ch]
  __int16 v55; // [esp+29Ch] [ebp-2Ch]
  int v56; // [esp+2A4h] [ebp-24h]
  int v57; // [esp+2A8h] [ebp-20h]
  int v58; // [esp+2B0h] [ebp-18h]
  int savedregs; // [esp+2C8h] [ebp+0h] OVERLAPPED BYREF

  v3 = v49 | a1;
  v4 = &v48[-v3];
  v19 ^= 0xDAu;
  HIWORD(v30) += 218;
  v5 = a2 < (unsigned int)&v48[-v3];
  if ( (char *)a2 != &v48[-v3] )
  {
    v6 = (unsigned int)v48;
    if ( v48 == (char *)881 )
    {
LABEL_15:
      v33 ^= 0x2Bu;
      a2 += v6;
      v52 |= 0x8Cu;
      goto LABEL_16;
    }
    v6 = HIDWORD(a3) & (unsigned int)&v48[-887];
    a2 = *(int *)((char *)&savedregs + 3) | (unsigned int)&v48[((unsigned int)v48 < 0x371) + a2];
    if ( (v58 | (unsigned int)&savedregs) != 616 )
    {
LABEL_16:
      v16 += (int)&savedregs;
      v3 = (unsigned int)&savedregs | 0xFC5;
      v4 = (char *)(((unsigned int)&savedregs | 0xFC5) + (a3 ^ (*(_DWORD *)((char *)&a3 + 1) + v6)));
      v5 = 0;
      v56 ^= 0xC6u;
      goto LABEL_17;
    }
    v7 = *(_DWORD *)((char *)v43 + 1) ^ v6;
    v8 = (char *)((*(_DWORD *)v44 & (616 - (((v58 | (unsigned int)&savedregs) < 0x268) + a2))) - v43[0]);
    WORD2(v39) |= 0x29u;
    if ( &v42 == v8 )
      goto LABEL_12;
    v55 -= 186;
    v47 += 56;
    if ( (__PAIR64__(v7, &v42) - __PAIR64__(&v42, (unsigned int)v8)) >> 32 != v25 )
    {
      if ( (v31 & (unsigned int)&v50[v45]) != 289 )
      {
LABEL_13:
        v24 &= 0xACu;
        v34 &= 0x6Cu;
        v6 = (unsigned int)&savedregs;
        v23 += 13;
        goto LABEL_14;
      }
      v6 = v31 | v30 ^ ((2 * (v46 ^ 0x121)) | 0x15A7);
      v51 -= 81;
      if ( v20 != (char *)v6 )
      {
LABEL_14:
        v22 ^= 0xBAu;
        v53 += (int)&savedregs;
        v18 ^= 0x45u;
        a2 = (unsigned int)&savedregs - 1118;
        goto LABEL_15;
      }
      v9 = v21 ^ v6;
      v40 &= 0x9Du;
      if ( *(_DWORD *)&v44[1] != ((unsigned int)v20 & 0x1A0B) )
        goto LABEL_11;
      v48[0] &= 0x2Fu;
    }
    v9 = *(_DWORD *)&v38[2] + (*(_DWORD *)((_BYTE *)&v39 + 1) & (unsigned int)&savedregs);
LABEL_11:
    v7 = v9 | 0x2385;
LABEL_12:
    v29 += v7;
    goto LABEL_13;
  }
LABEL_17:
  v10 = (signed int)&v4[v5 + v3];
  v11 = (a2 | 0xA65) + 2956;
  if ( !v3 )
  {
    v54 |= v11;
    v12 = (v21 | v32 & v11) ^ 0x117E;
    v35 += v12;
    if ( v12 != v10 )
      goto LABEL_21;
    v31 -= v10;
    v26 ^= 0xF8u;
    v11 = v41 & v12;
  }
  v12 = v10 & v11;
  v10 ^= HIDWORD(v39);
LABEL_21:
  v28 ^= 0x83u;
  v13 = *(_DWORD *)v38 & v10;
  v14 = (char *)(v39 & v12);
  v26 &= v13;
  if ( (char *)v13 != v37 )
  {
    v14 = &v37[(unsigned __int16)v17 & (unsigned __int16)&savedregs & 0x31B0];
    v36 |= 0x15u;
  }
  result = v57 ^ (unsigned int)v37;
  v27 -= v13;
  if ( v13 )
    result = savedregs & (unsigned int)&v14[result];
  return result;
}
// 401DD0: variables would overlap: ^2C8.4 and ^2CB.4

//----- (00402320) --------------------------------------------------------
#error "4025DD: call analysis failed (funcsize=2594)"

// nfuncs=3 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 3 function(s)"
