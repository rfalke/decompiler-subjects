/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// double __usercall start@<st0>(int a1@<eax>, int a2@<edx>, __int64 a3@<ebx:ecx>, unsigned int a4@<edi>, double result@<st0>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40235F; // weak


//----- (004011CE) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __usercall start@<st0>(int a1@<eax>, int a2@<edx>, __int64 a3@<ebx:ecx>, unsigned int a4@<edi>, double result@<st0>)
{
  int v6; // esi
  int v7; // edx
  _BYTE *v8; // ebx
  unsigned int v9; // edx
  signed int v10; // edi
  int v11; // esi
  int v12; // ecx
  unsigned int v13; // ebx
  __int64 v14; // rax
  unsigned int v15; // edi
  int v16; // ecx
  __int64 v17; // kr20_8
  int v18; // esi
  int v19; // edi
  int v20; // esi
  int v21; // ebx
  unsigned int v22; // ecx
  int v24; // ecx
  int v25; // ebx
  int v26; // edx
  int v27; // edi
  char v28; // dl
  int v29; // ecx
  unsigned int v30; // ebx
  int v31; // esi
  int v32; // edi
  int v33; // eax
  unsigned int v34; // edi
  int v35; // ecx
  unsigned int v36; // ecx
  int v37; // ebx
  unsigned __int64 v38; // kr28_8
  unsigned __int64 v39; // kr08_8
  unsigned int v40; // ecx
  int v41; // ebx
  int v42; // edx
  int v43; // eax
  int v44; // edi
  unsigned int v45; // kr10_4
  unsigned int v46; // ebx
  int v47; // ecx
  int v48; // edx
  int v49; // eax
  int v50; // ecx
  int v51; // edx
  int v52; // eax
  int v53; // edx
  int v54; // ebx
  int v55; // esi
  char v56; // dl
  _BYTE *v57; // eax
  int v58; // edi
  int v59; // eax
  int v60; // esi
  int v61; // ebx
  int v62; // edi
  int v63; // edx
  int v64; // ecx
  unsigned int v65; // ebx
  int v66; // esi
  int v67; // ecx
  int v68; // edi
  int v69; // eax
  _BYTE *v70; // edx
  char v71; // cl
  unsigned int v72; // eax
  int v73; // esi
  int v74; // ebx
  unsigned __int64 v75; // kr18_8
  int v76; // esi
  int v77; // eax
  int v78; // edi
  unsigned int v79; // edi
  int v80; // esi
  int v81; // edi
  int v82; // ecx
  unsigned int v83; // edx
  int v84; // edi
  int v85; // esi
  unsigned int v86; // ebx
  bool v87; // cf
  unsigned int v88; // ebx
  int v89; // edi
  unsigned int v90; // ebx
  __int64 v91; // rdi
  unsigned __int8 v92; // al
  unsigned int v93; // kr00_4
  unsigned int vars0; // [esp+0h] [ebp+0h]

  while ( 1 )
  {
    v39 = __PAIR64__(HIDWORD(a3), a1) + a4;
    v40 = (a3 - __PAIR64__((int)a3 - HIDWORD(v39), (unsigned int)__CFADD__(a1, a4) + HIDWORD(a3))) >> 32;
    v41 = a1 | (2 * v40 - ((__PAIR64__(v40, v40) + v40) >> 32));
    v90 = (__PAIR64__((v41 & (unsigned int)-__CFADD__(a2, v39 | a1)) - a1, v41 & (unsigned int)-__CFADD__(a2, v39 | a1))
         - __PAIR64__(a1, a1)) >> 32;
    HIDWORD(v91) = (v90 | (a2 - a1)) - a2;
    LODWORD(v91) = a1 | (2 * v40 - ((__PAIR64__(v40, v40) + v40) >> 32));
    LODWORD(v91) = v91 + a1 - ((v91 + (unsigned __int64)(unsigned int)a1) >> 32);
    if ( a1 == 388396232 )
    {
      MEMORY[0x172674C8] &= 0xC8u;
      LOBYTE(STACK[0x2E4CE990]) += 35;
      *(_DWORD *)(v90 - 1946287119) = __ROR4__(*(_DWORD *)(v90 - 1946287119), 200);
      *(_BYTE *)v90 = __ROL1__(*(_BYTE *)v90, 1);
      result = result * (double)*(int *)(v90 + 871508978);
      *(_BYTE *)v90 = __ROL1__(*(_BYTE *)v90, 200);
      _enable();
      HIDWORD(v91) = 388396232;
      __asm { int     2Eh; DOS 2+ internal - EXECUTE COMMAND }
      v79 = v90
          - a2
          - (__CFADD__(
               v90,
               (((v91 - __PAIR64__(a2, a2)) >> 32) - (v91 - a2) - 388396232) & 0x172674C8 | (((((v91 - __PAIR64__(a2, a2)) >> 32)
                                                                                             - (v91
                                                                                              - a2)) & 0x172674C8)
                                                                                           - a2))
           + ((((v91 - __PAIR64__(a2, a2)) >> 32) - (v91 - a2) - 388396232) & 0x172674C8));
      v12 = 388396232;
      v13 = v90 - 388396232;
      if ( a2 == -1 )
        LOBYTE(a1) = 46;
      else
        LOBYTE(a1) = *(_BYTE *)(a2 - 1);
      v77 = a1 + 1073741778;
      if ( v77 )
      {
        v86 = v77 | v13;
        v87 = v86 < 0x172674C8;
        v88 = v86 - 388396232;
        v89 = v88 | v79;
        v24 = (((__PAIR64__(a2 - (v87 + v88), a2) - ((v87 + v88) | 0x172674C800000000i64)) >> 32) & 0x172674C8)
            - 388396232;
        v25 = v24 & v88;
        LOBYTE(v24) = (v77 | v89) & v24;
        v26 = v25 | v77 | v89;
        v27 = v26 | v89;
        v28 = v26 - v24;
        if ( v27 != -1166545598 )
          JUMPOUT(0x4012B5);
        MEMORY[0] &= v28;
      }
      else
      {
LABEL_16:
        v80 = v12;
        v81 = v79 - v12 - v12;
        v82 = v12 + v81;
        v83 = a2 - v77;
        if ( v83 == 941129949 )
        {
          *(_DWORD *)(v82 + v77) += v77;
          JUMPOUT(0x40135F);
        }
        v50 = v80 + v82;
        v51 = v81 & (v83 - ((v83 < 0x381880DD) + v77));
        v52 = v77 - v51;
        v53 = v80 | v51;
        v54 = v80;
        v55 = v50 & v80;
        v58 = v55;
        v59 = v55 | v52;
        v60 = v50 | v55;
        v61 = v58 + v54;
        v62 = v50 & v58;
        v63 = v53 - v60;
        v64 = v63 | v50;
        if ( v62 != 2038322830 )
          JUMPOUT(0x4012F8);
        v87 = __CFADD__((_BYTE)v64, *(_BYTE *)(v59 - 114621304));
        *(_BYTE *)(v59 - 114621304) += v64;
        v65 = v61 - (v87 + v59);
        v66 = v63 | v60;
        v67 = v64 - v59 - v63;
        v68 = v67 & (v65 + 2038322830);
        v69 = v67
            + v59
            - ((((unsigned int)v67 | 0x797E568E00000000i64) + (unsigned __int64)(unsigned int)v59) >> 32)
            - v63;
        v70 = (_BYTE *)(v65 + v63);
        if ( v69 != -2029540561 )
          JUMPOUT(0x401022);
        MEMORY[0x8707AB2F] &= 4u;
        MEMORY[0x12DFCE71] |= 0xF9u;
        v71 = v67 - 47;
        v72 = v65;
        v73 = v68 & v66;
        v74 = v65 | v73 | v65;
        if ( v70 == (_BYTE *)-380255950 )
        {
          *(_BYTE *)v72 |= 0x48u;
          *(_BYTE *)(v74 + 599991239) &= v71;
          *(_DWORD *)v74 = __ROR4__(*(_DWORD *)v74, v71);
          *(_DWORD *)(v74 + 466689015) = __ROR4__(*(_DWORD *)(v74 + 466689015), v71);
          JUMPOUT(0x401305);
        }
        v56 = v72 + (_BYTE)v70;
        v57 = (_BYTE *)(v73 & (v68 | v72));
        if ( v73 == -1457991910 )
        {
          *v57 &= v56;
          JUMPOUT(0x40129A);
        }
      }
      return result;
    }
    v36 = (__PAIR64__(a1, a1) - __PAIR64__(a2, 388396232)) >> 32;
    v37 = v36 | v90;
    v38 = __PAIR64__(v36, v37) + ((unsigned int)v37 | HIDWORD(v91));
    a4 = v91 - v38;
    HIDWORD(a3) = a4 | v37;
    LODWORD(a3) = HIDWORD(a3);
    a1 = a2 & (HIDWORD(v91) + a1 - HIDWORD(v38));
    if ( a2 != -1790590435 )
      break;
    *((_BYTE *)&vars0 + a1) |= a1;
    *(_BYTE *)a1 += BYTE4(a3);
  }
  v49 = HIDWORD(a3) + a1;
  LODWORD(a3) = a4;
  v84 = HIDWORD(a3);
  HIDWORD(a3) = 1825116880;
  v85 = v84 & 0x6CC912D0 | (2 * v38);
  v48 = (1825116880 - (v49 + a2)) | 0x6CC912D0;
  v44 = 1825116880;
  v47 = v48 & a3;
  do
  {
    v42 = v47 | v48;
    v45 = v44 - v46;
    v43 = (__PAIR64__(v49, v44) - __PAIR64__(v46, v46)) >> 32;
    v44 -= v46;
    v46 += 1286682900;
    v47 += v46;
    v48 = v85 | v85 | v42;
    v49 = v85 & v43;
  }
  while ( v46 != -403694764 );
  __asm { fnclex }
  v22 = 0;
  while ( 1 )
  {
    __asm { smsw    eax }
    if ( ++v22 == 2 )
      return result;
    if ( ((unsigned __int8)_EAX & 8) == 0 )
    {
      if ( v45 == 440570356 )
      {
        *(_BYTE *)v22 |= v48;
        LOBYTE(_EAX) = (_BYTE)_EAX + 8;
        *_EAX = v22;
        ((void (__thiscall *)(unsigned int))loc_40235F)(v22 & 0xE7F01B54);
        __outbyte(7u, v92);
        v93 = __readeflags();
        vars0 = v93;
        JUMPOUT(0x40141B);
      }
      do
        __asm { smsw    eax }
      while ( (_EAX & 2) == 0 );
      v6 = _EAX & v85;
      v7 = v48 - v22;
      v8 = (_BYTE *)(v22 + (_EAX | 0xE7F01B54));
      if ( v45 - _EAX == 898811676 )
      {
        *(_BYTE *)(_EAX + 4 * v22 - 120) = _EAX;
        *v8 = BYTE1(_EAX);
        _enable();
        v9 = (unsigned int)(v8 - 898811676);
        v10 = (signed int)(v8 + 898811676);
        v11 = ((__PAIR64__(v6 - v10, v6) - __PAIR64__(_EAX, v10)) >> 32) - _EAX;
        v29 = v11 | _EAX;
        v30 = _EAX;
        v31 = (v11 | _EAX) & v11;
        v32 = v9 & v10;
        v33 = -v29 - v32;
        v34 = v32 - v30;
        v35 = v30 & v30 & (v31 | v29);
        v20 = v33 & (v33 + v31);
        v21 = v33;
        if ( v20 == -1405269899 )
        {
          *(_DWORD *)v33 += v35;
          JUMPOUT(0x4010E6);
        }
        HIDWORD(v14) = v33 + v20;
        LODWORD(v14) = v35 | v33;
        v15 = v34 - v20;
        v16 = HIDWORD(v14) & (v20 + v35);
        v17 = v14 + HIDWORD(v14);
        v18 = v20 - HIDWORD(v17);
        v19 = v18 | v15;
        v12 = v18 & (v21 + (v17 | v16));
        v75 = __PAIR64__(v12, v12) + (unsigned int)v21;
        v76 = 2 * v17 - HIDWORD(v75) - v12;
        v77 = v12 & v21;
        a2 = v17 | v12 | v75;
        v78 = v19 - v76;
        if ( v76 != 1968215550 )
          JUMPOUT(0x401060);
        v87 = __CFADD__((_BYTE)v77, *(_BYTE *)(v77 - 551336959));
        *(_BYTE *)(v77 - 551336959) += v77;
        v79 = v78 - (v87 + (v17 | v12 | v75) - v17);
        goto LABEL_16;
      }
      if ( v7 - v22 != 462317424 )
        JUMPOUT(0x4013EB);
      MEMORY[0x8BC18B20] = v22;
      return result;
    }
  }
}
// 401298: control flows out of bounds to 40129A
// 4012FF: control flows out of bounds to 401305
// 40135C: control flows out of bounds to 40135F
// 4010E4: control flows out of bounds to 4010E6
// 401418: control flows out of bounds to 40141B
// 401204: control flows out of bounds to 4012B5
// 4012AF: control flows out of bounds to 4012F8
// 4012D1: control flows out of bounds to 401022
// 401330: control flows out of bounds to 401060
// 401057: control flows out of bounds to 4013EB
// 4013E8: exceedingly huge offset into the stack frame

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
