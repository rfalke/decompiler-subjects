/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD __cdecl __far start(_DWORD, char); // weak
// unsigned int __usercall sub_407EDE@<eax>(int@<eax>, int@<edx>, int _ECX@<ecx>, char@<bl>, int@<ebp>, int@<edi>, int _ESI@<esi>);


//----- (00406963) --------------------------------------------------------
#error "40718D: cannot convert to microcode (funcsize=1814)"

//----- (00407EDE) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int __usercall sub_407EDE@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int _ECX@<ecx>,
        char a4@<bl>,
        int a5@<ebp>,
        int a6@<edi>,
        int _ESI@<esi>)
{
  unsigned int v7; // eax
  __int16 v8; // bx
  char v13; // tt
  unsigned int v15; // ecx
  unsigned int i; // eax
  int v17; // edi
  char v18; // dl
  unsigned int v21; // esi
  unsigned int v23; // edi
  bool v25; // cf
  bool v27; // tt
  unsigned int v29; // edi
  bool v30; // zf
  int v31; // edx
  int v35; // edx
  unsigned int v36; // edi
  unsigned int result; // eax
  unsigned int v40; // eax
  unsigned int v41; // eax
  unsigned int v42; // edi
  int v43; // esi
  char v48; // cl
  int v50; // edi
  char v51; // sf
  unsigned __int64 v52; // rax
  int v53; // esi
  int v54; // ecx
  int v55; // edx
  int v56; // eax
  _BYTE *v59; // ebx
  int v60; // edi
  unsigned int v61; // esi
  bool v62; // cf
  bool v63; // tt
  unsigned int v64; // edi
  int v67; // esi
  unsigned int v70; // [esp-20h] [ebp-20h] BYREF
  int v71; // [esp-1Ch] [ebp-1Ch]
  int *v72; // [esp-18h] [ebp-18h]
  int v73; // [esp-14h] [ebp-14h] BYREF

  __asm { rcl     si, cl }
  LOBYTE(a1) = a1 + 1;
  v53 = 8 * _ESI;
  v54 = _ECX << 8;
  BYTE1(a2) = 1 - (a4 ^ BYTE1(a2));
  v25 = BYTE1(a2) != 0;
  v55 = a2 - 1;
  v56 = a6 + v25 + a1;
  LOBYTE(v54) = (char)v54 >> v54;
  SBYTE1(v54) >>= v54;
  v73 = v54 << 15;
  v72 = &v73;
  v71 = 64;
  if ( v56 == 186873717 )
  {
    if ( !__SETP__(186873717, 186873717) )
      __asm { retf }
    JUMPOUT(0x407E6E);
  }
  v70 = 4226086;
  v15 = 4226086;
  for ( i = 1; i; i = ~((BYTE1(v70) + (unsigned __int8)v70 + HIWORD(v70)) ^ 0xFFFFFEC8) )
  {
    v15 = (v15 - 1) >> 15 << 15;
    v70 = *(_DWORD *)v15;
    v55 = (unsigned __int8)v70;
  }
  v40 = *(_DWORD *)(v15 + 60) + v15;
  v70 = *(_DWORD *)(v40 + 80);
  v41 = v15 + *(_DWORD *)(v40 + 128);
  if ( v41 != 2020881433 )
    JUMPOUT(0x407DA7);
  v43 = v53 + 4;
  v42 = a6 + 4;
  LOBYTE(v41) = 9;
  result = v41 + 1;
  *(_BYTE *)(a5 + 285147396) += v15;
  _EBX = v70;
  LOWORD(v15) = -(__int16)v15;
  LOWORD(v55) = (unsigned __int8)result;
  _ECX = __ROR4__(__ROL4__(v15, 10), 13);
  if ( result != 1261083514 )
  {
    LOWORD(result) = (__int16)result >> _ECX;
    v35 = v55 << 21;
    SBYTE1(v35) >>= 7;
    v25 = v42 < 0x9C35BF0D;
    v36 = v42 + 1674199283;
    __asm { rcr     cl, 0Bh }
    LOBYTE(result) = BYTE1(_ECX) + v25 + result;
    LOWORD(_ECX) = v70 | (_ECX - v35);
    if ( result == -884378840 )
    {
      __asm { lock xchg eax, ebx }
      JUMPOUT(0x407D75);
    }
    v31 = _ECX & v35;
    LOWORD(result) = v36 + result;
    __asm { rcl     ecx, 5 }
    LOWORD(_ECX) = _ECX + 1;
    __asm { rcr     ecx, 12h }
    _EDX = v31 << _ECX;
    __asm { rcl     dl, cl }
    _ESI = v70 + 2779 + v43;
    LOWORD(_EDX) = _ESI + _EDX;
    BYTE1(_EDX) = BYTE1(_ECX) + (BYTE1(_EDX) << _ECX);
    v64 = v36 - (v70 + 2779);
    v70 += 2779;
    LOBYTE(_ECX) = 0;
    __asm { rcr     ecx, cl }
    v25 = (unsigned __int8)result < BYTE1(v70);
    LOBYTE(result) = result - BYTE1(v70);
    _EDX = v25 + _EDX + 1937080966;
    LOBYTE(_EDX) = BYTE1(_ECX) & _EDX;
    _ESI |= 0x6BA3CE05u;
    v7 = result << 25;
    __asm { rcl     dl, cl }
    v8 = v70 - 2779;
    __asm { rcr     esi, cl }
    BYTE1(_ECX) |= (unsigned __int16)(v70 - 2779) >> 8;
    LOBYTE(_EDX) = ((unsigned __int8)v7 ^ (unsigned __int8)_EDX) << _ECX;
    LOWORD(_ESI) = _ESI - v7;
    v21 = _ESI - v7;
    _AH = BYTE1(v7) | 0x4D;
    __asm { rcl     ah, 5 }
    LOWORD(_EDX) = v21 | (unsigned __int8)_EDX;
    _EAX = -865260775;
    LOWORD(_ECX) = __ROR2__(_ECX, _ECX);
    v25 = __CFADD__(_ECX, 1782913884);
    _ECX = _ECX + 1782913884;
    LOBYTE(_ECX) = v25 + _ECX + 103;
    LOBYTE(_EDX) = _EDX + 1;
    v23 = ~v64;
    v25 = v23 < 0x6C70B15B;
    if ( v23 == 1819324763 )
    {
      v59 = (_BYTE *)(v70 - 2780);
      __asm { rcr     dword ptr [eax-2Eh], 1 }
      LOBYTE(_EAX) = 0;
      v60 = _ECX + 1819324763;
      BYTE1(_EDX) = __ROL1__(__ROL1__(BYTE1(_EDX), 27), 27);
      v25 = v21 < 0x5625911A;
      v61 = v21 - 1445302554;
      LOBYTE(_EDX) = BYTE1(_ECX);
      BYTE1(_ECX) += (_BYTE)v59 + v25;
      v63 = __CFSHL__(_ECX, 8);
      _ECX = __ROL4__(_ECX, 8);
      v62 = v63;
      __asm { rcr     cl, cl }
      v48 = _CL - (v62 + BYTE1(_EDX));
      v25 = __CFADD__(v48, 70);
      LOBYTE(_ECX) = v48 + 70;
      v50 = v60 - (v25 + 748448687);
      *v59 = _EDX;
      if ( -v61 == -1948507465 )
      {
        v52 = *(unsigned int *)_EDX * (unsigned __int64)(unsigned int)_EAX;
        if ( v51 != (HIDWORD(v52) != 0) )
        {
          MEMORY[0xCF89E290] += BYTE1(v59) + (HIDWORD(v52) != 0);
          __asm { into }
          _ESI = v52;
          _CL = BYTE1(v52);
          __asm { rcl     esi, 7 }
          v67 = _ESI - 203940748;
          LOWORD(v67) = v67 + 1;
          _CH = 0;
          __asm { rcr     ch, cl }
          if ( v59 == (_BYTE *)-595773190 )
          {
            __asm
            {
              fstp1   st(2)
              int     0; - internal hardware - DIVIDE ERROR
            }
            JUMPOUT(0x407FF2);
          }
          _ESI = v67 << 18;
          __asm { rcl     esi, 0Ch }
          LOWORD(_ESI) = _ESI & 0xF5C0;
          __asm { rcl     esi, 1 }
          JUMPOUT(0x407E65);
        }
        JUMPOUT(0x407E8A);
      }
      _EDI = v50 >> _ECX;
      LOWORD(_ECX) = (unsigned __int8)__ROL1__(__ROL1__(((_ECX ^ 0xB1) - 36) & 0x56, 25), 7);
      _ECX = _ECX >> _ECX;
      LOBYTE(_ECX) = _ECX - 1;
      LOWORD(_EDI) = _EAX + _EDI;
      BYTE1(_ECX) = (_BYTE)v59 + 1;
      LOWORD(_ECX) = _ECX + 1;
      LOBYTE(_ECX) = __ROR4__(_ECX, 8) + 1;
      __asm { rcr     di, cl }
      LOWORD(_ECX) = (unsigned __int8)_ECX - 1;
      LOBYTE(_ECX) = _ECX - 43;
      BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), _ECX);
      __asm
      {
        rcr     cl, cl
        rcr     ch, cl
        rcr     ch, 0Bh
      }
      JUMPOUT(0x407EC3);
    }
    while ( 1 )
    {
      _EDX -= v25 + _EAX;
      _CX = _ECX - v8;
      _EAX ^= 0xCC6D205A;
      v27 = __CFSHR__(BYTE1(_EDX), _CX);
      BYTE1(_EDX) = __ROR1__(BYTE1(_EDX), _CX);
      LOBYTE(_EDX) = v8 & (__ROL1__(_EDX, 19) - 1);
      __asm { rcl     cl, cl }
      BYTE1(_EDX) = _CX | (v27 + BYTE1(_EDX) + 42);
      v29 = v23 << 11;
      LOWORD(v29) = v29 + 1;
      if ( v21 == 982131223 )
      {
        v30 = (unsigned int *)((char *)&v70 + *(_DWORD *)(_EDX + 1316285623)) == 0;
        *(_DWORD *)(_EDX + 1316285623) += &v70;
        if ( v30 )
          break;
      }
      v21 = (v21 >> _CX) + 1564527062;
      LOBYTE(_EDX) = (char)_EDX >> (v8 & _CX);
      LOBYTE(_CX) = 0;
      LOWORD(v21) = -(__int16)v21;
      _CX = _CX - 25467;
      BYTE1(_ECX) = __ROR1__(HIBYTE(_CX), _CX);
      v23 = v29 << _CX;
      __asm { rcr     cl, 16h }
      if ( v21 != 695812251 )
      {
        v17 = (v21 < 0x2979409B) + v23 - 468165150;
        __asm { rcl     dh, 3 }
        BYTE1(_EDX) -= _EAX;
        v18 = __ROL4__(_EDX, 16) - 38;
        if ( _EAX == -1137547282 )
        {
          _EDX = v71;
          __asm { fisubr  word ptr [edx] }
          JUMPOUT(0x407C6D);
        }
        _EDI = v17 ^ 0x8D84B675;
        v13 = __CFSHL__(v18, _ECX);
        LOBYTE(_DX) = __ROL1__(v18, _ECX);
        HIBYTE(_DX) = __ROR1__(-v13, 28);
        __asm
        {
          rcl     dx, cl
          rcl     edi, 1Ch
        }
        JUMPOUT(0x407F78);
      }
      v25 = 0;
    }
    JUMPOUT(0x407E14);
  }
  __asm { fdivr   st, st(4) }
  return result;
}
// 407C69: positive sp value 10 has been found
// 407C69: inconsistent fpu stack
// 407C6B: control flows out of bounds to 407C6D
// 407D21: control flows out of bounds to 407D22
// 407D72: control flows out of bounds to 407D75
// 407E62: control flows out of bounds to 407E65
// 407E6C: control flows out of bounds to 407E6E
// 407FF0: control flows out of bounds to 407FF2
// 407B6B: control flows out of bounds to 407EC3
// 407BF2: control flows out of bounds to 407F78
// 407D1B: control flows out of bounds to 407E14
// 407DA2: control flows out of bounds to 407DA7
// 407EBE: control flows out of bounds to 407E8A
// 407EBE: variable 'v51' is possibly undefined

// nfuncs=2 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2 function(s)"
