/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// unsigned int __usercall start@<eax>(int@<edx>, int@<ebx>, BOOL@<edi>, int@<esi>, char, __int64);

//-------------------------------------------------------------------------
// Data declarations

// extern HRESULT (__stdcall *CreateItemMoniker)(LPCOLESTR lpszDelim, LPCOLESTR lpszItem, LPMONIKER *ppmk);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern UINT (__stdcall *GetOEMCP)();
// extern BOOL (__stdcall *GetCPInfo)(UINT CodePage, LPCPINFO lpCPInfo);
// extern HANDLE (__stdcall *OpenEventA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__cdecl *_set_app_type)(_crt_app_type Type);
// extern void *(__cdecl *malloc)(size_t Size);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegEnumValueW)(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegEnumKeyA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName);
// extern BOOL (__stdcall *InitializeAcl)(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// extern LSTATUS (__stdcall *RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
_UNKNOWN unk_40A55C; // weak
_UNKNOWN unk_40B5AC; // weak


//----- (00401278) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
unsigned int __usercall start@<eax>(int a1@<edx>, int a2@<ebx>, BOOL a3@<edi>, int a4@<esi>, char a5, __int64 a6)
{
  int v6; // ecx
  UINT OEMCP; // eax
  int v8; // ecx
  int v9; // edx
  HANDLE v10; // eax
  int v11; // ecx
  unsigned int result; // eax
  int v13; // ecx
  int v14; // edx
  _DWORD *v15; // edx
  char *v16; // esi
  unsigned int v17; // ecx
  int v18; // edi
  int v19; // ebx
  int v20; // eax
  char *v21; // esi
  int v22; // ecx
  char v23; // cf
  int v24; // ecx
  _BYTE *v25; // [esp+0h] [ebp-2B8h]
  LPSTR lpName; // [esp+8h] [ebp-2B0h]
  int v27; // [esp+Ch] [ebp-2ACh]
  BOOL bInheritHandle; // [esp+18h] [ebp-2A0h]
  int v29; // [esp+1Ch] [ebp-29Ch]
  int v30; // [esp+20h] [ebp-298h] BYREF
  char v31; // [esp+30h] [ebp-288h] BYREF
  int v32; // [esp+32h] [ebp-286h]
  int v33; // [esp+38h] [ebp-280h]
  char *v34; // [esp+68h] [ebp-250h]
  int v35; // [esp+6Ch] [ebp-24Ch]
  int v36; // [esp+70h] [ebp-248h]
  int v37[3]; // [esp+80h] [ebp-238h] BYREF
  int v38; // [esp+8Ch] [ebp-22Ch]
  __int16 v39; // [esp+94h] [ebp-224h]
  int v40; // [esp+9Ch] [ebp-21Ch]
  __int16 v41; // [esp+A8h] [ebp-210h]
  char v42; // [esp+B8h] [ebp-200h]
  int v43; // [esp+C4h] [ebp-1F4h]
  int v44; // [esp+E8h] [ebp-1D0h] BYREF
  _BYTE v45[5]; // [esp+EFh] [ebp-1C9h]
  int v46; // [esp+108h] [ebp-1B0h]
  int v47; // [esp+12Ch] [ebp-18Ch] BYREF
  char v48; // [esp+140h] [ebp-178h]
  int v49; // [esp+148h] [ebp-170h]
  __int16 v50; // [esp+150h] [ebp-168h]
  __int16 v51; // [esp+184h] [ebp-134h]
  int v52; // [esp+1A0h] [ebp-118h]
  int v53; // [esp+1B8h] [ebp-100h]
  struct _cpinfo v54; // [esp+1BCh] [ebp-FCh] BYREF
  struct HKEY__ v55; // [esp+1D0h] [ebp-E8h] BYREF
  int v56; // [esp+1DCh] [ebp-DCh]
  struct _cpinfo v57; // [esp+1E4h] [ebp-D4h] BYREF
  struct HKEY__ v58; // [esp+1F8h] [ebp-C0h] BYREF
  DWORD cchValueName; // [esp+1FCh] [ebp-BCh] BYREF
  char v60[4]; // [esp+200h] [ebp-B8h] BYREF
  char v61; // [esp+204h] [ebp-B4h] BYREF
  char v62[4]; // [esp+20Ch] [ebp-ACh] BYREF
  DWORD v63; // [esp+210h] [ebp-A8h] BYREF
  struct HKEY__ v64; // [esp+214h] [ebp-A4h] BYREF
  DWORD Reserved; // [esp+218h] [ebp-A0h] BYREF
  __int16 v66; // [esp+21Ch] [ebp-9Ch]
  int v67; // [esp+220h] [ebp-98h]
  __int16 v68; // [esp+224h] [ebp-94h]
  char v69[4]; // [esp+22Ch] [ebp-8Ch] BYREF
  int v70[2]; // [esp+230h] [ebp-88h] BYREF
  HKEY phkResult; // [esp+238h] [ebp-80h] BYREF
  char v72[4]; // [esp+23Ch] [ebp-7Ch] BYREF
  struct HKEY__ Data; // [esp+240h] [ebp-78h] BYREF
  struct HKEY__ hKey; // [esp+244h] [ebp-74h] BYREF
  char Class[4]; // [esp+248h] [ebp-70h] BYREF
  char v76[8]; // [esp+24Ch] [ebp-6Ch] BYREF
  char v77[8]; // [esp+254h] [ebp-64h] BYREF
  DWORD v78; // [esp+25Ch] [ebp-5Ch] BYREF
  ACL v79; // [esp+260h] [ebp-58h] BYREF
  char v80; // [esp+268h] [ebp-50h]
  int v81; // [esp+26Ch] [ebp-4Ch]
  __int16 v82; // [esp+28Ch] [ebp-2Ch]
  int v83; // [esp+294h] [ebp-24h]
  int v84; // [esp+29Ch] [ebp-1Ch]
  char v85; // [esp+2A0h] [ebp-18h]
  _BYTE savedregs[2]; // [esp+2B8h] [ebp+0h] BYREF
  __int16 savedregs_2; // [esp+2BAh] [ebp+2h] OVERLAPPED
  void *retaddr; // [esp+2BCh] [ebp+4h] OVERLAPPED

  if ( a1 != 957 )
    v33 |= 0x22u;
  GetCPInfo(0, &v54);
  GetCurrentProcessId();
  GetCurrentThreadId();
  RegEnumKeyExA((HKEY)&v79, 0x12u, 0, &v78, (LPDWORD)v70, Class, (LPDWORD)&v57.LeadByte[6], (PFILETIME)2);
  v51 ^= 0x5Bu;
  OpenMutexA(0x15u, 0, v76);
  RegEnumValueW(&v64, 8u, (LPWSTR)0x17, &cchValueName, &Reserved, &Reserved, (LPBYTE)&Data, 0);
  OpenEventA(0, 0, v72);
  v43 += 18;
  InitializeAcl(&v79, 0x13u, 0x12u);
  if ( v6 - v53 != 902 )
  {
    v37[0] = v37[0] & 0x54;
    v68 += 21;
  }
  malloc(0);
  OEMCP = GetOEMCP();
  if ( (OEMCP & v8) == 804 )
    v39 -= 25;
  RegEnumKeyExA(&Data, 0, 0, (LPDWORD)&v79.AceCount, (LPDWORD)&v64, (LPSTR)&v63, &v63, (PFILETIME)0x14);
  _set_app_type(_crt_gui_app);
  v49 &= v9;
  OpenMutexA(0, 0, (LPCSTR)&cchValueName);
  RegOpenKeyA(&hKey, (LPCSTR)v57.DefaultChar, &phkResult);
  GetCPInfo(0, &v57);
  RegEnumKeyA(&v58, 0xAu, v77, 0);
  v48 ^= 0x73u;
  GetOEMCP();
  v66 ^= 0x33u;
  RegEnumKeyA((HKEY)&v54.LeadByte[10], 0, (LPSTR)&hKey, 0xAu);
  v10 = OpenMutexA(0xAu, 0, v69);
  v85 |= 0xA3u;
  if ( !v10 )
    v82 -= 163;
  RegOpenKeyA(&v55, v60, (PHKEY)&v57.LeadByte[10]);
  if ( v11 )
  {
    LOWORD(v84) = v84 ^ 0x42;
    v83 += 212;
  }
  GetLastError();
  LOBYTE(v54.MaxCharSize) += 22;
  result = CreateItemMoniker(0, 0, 0) ^ 0x80070057;
  if ( !result )
  {
    v29 = a4;
    bInheritHandle = a3;
    v27 = a2;
    lpName = (LPSTR)(*(_DWORD *)((char *)&a6 + 2) | v13);
    v25 = &savedregs[-2890];
    if ( (*(_DWORD *)((char *)&a6 + 2) | v13) != 219 )
      v81 |= *(_DWORD *)&v54.LeadByte[10] ^ ((unsigned int)&v61 | 0x3C57);
    HIWORD(v32) = BYTE2(v32) & 0xE4;
    v34 = (char *)VirtualAlloc(0, 0x3000u, 0x1000u, 0x40u);
    v84 += (*(unsigned int *)((char *)&retaddr + 1) & v14) - *(_DWORD *)((char *)&a6 + 1);
    v15 = &unk_40A55C;
    v56 |= 0x5Fu;
    v60[0] |= 0x9Fu;
    v16 = v34;
    v54.LeadByte[2] += 69;
    v17 = *(int *)((char *)v37 + 1) + (*(_DWORD *)v45 ^ (*(_DWORD *)&v45[1] | (unsigned int)savedregs)) - (_DWORD)&v44;
    v38 = 1839877483;
    if ( ((unsigned int)v37 | 0x34FC) == v36 )
      v17 = (unsigned int)&v47 ^ 0x30E;
    do
    {
      v18 = v38 + *v15;
      v38 -= 581846881;
      *(_DWORD *)v16 = v18;
      v80 += 47;
      if ( (char *)v17 != v62 )
      {
        v52 |= 0x9Bu;
        v46 ^= 0xC7u;
      }
      v19 = (__PAIR64__(v17, -810971396) + __PAIR64__(v62, (unsigned int)v15)) >> 32;
      v20 = (int)savedregs;
      v21 = v16 + 1332391190;
      v22 = (*(_DWORD *)&savedregs_2 ^ (HIDWORD(a6) + (HIDWORD(a6) | v17))) + 3751;
      ++v15;
      LOWORD(v78) = v78 - 179;
      v42 ^= 0xB3u;
      if ( v19 == 581 )
      {
        v20 = ((unsigned __int16)savedregs + 8372) & 0x6A9;
        v41 ^= 0xC0u;
        v35 &= 0x67u;
      }
      v16 = v21 - 1332391186;
      v17 = v22 ^ 0x2367;
    }
    while ( v15 != (_DWORD *)&unk_40B5AC );
    LOWORD(v17) = v20 & v17;
    if ( v67 == v20 )
    {
      v17 = (unsigned int)&v31;
      v19 &= v32;
      v50 |= 0x26u;
    }
    result = ((int (__thiscall *)(unsigned int, _BYTE *, _BYTE *, LPSTR, int, int *, _BYTE *, BOOL, int))v34)(
               v17 & 0x3326,
               v25,
               savedregs,
               lpName,
               v27,
               &v30,
               savedregs,
               bInheritHandle,
               v29);
    v40 &= v19;
    if ( v19 == v23 + v24 )
      result |= v63;
  }
  return result;
}
// 401278: variables would overlap: ^2CA.2 and ^2CA.4
// 401278: variables would overlap: ^2CC.4(retaddr) and ^2CD.4
// 401278: using guessed type CHAR Class[4];
// 401278: using guessed type _DWORD var_238[3];
// 401278: using guessed type CHAR var_B8[4];
// 401278: using guessed type char var_AC[4];
// 401278: using guessed type CHAR anonymous_2[4];
// 401278: using guessed type DWORD anonymous_3[2];
// 401278: using guessed type CHAR anonymous_4[4];
// 401278: using guessed type CHAR anonymous_5[8];

// nfuncs=1 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
