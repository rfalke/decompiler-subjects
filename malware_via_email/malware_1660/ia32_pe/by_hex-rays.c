/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall sub_40DB23(int@<eax>, int@<edx>, int@<ecx>, int@<ebx>, int@<edi>, unsigned int@<esi>);


//----- (0040C09E) --------------------------------------------------------
#error "40C85E: cannot convert to microcode (funcsize=640)"

//----- (0040DB23) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_40DB23(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<edi>, unsigned int a6@<esi>)
{
  unsigned int v6; // esi
  int v7; // edx
  int v14; // edx
  int v15; // esi
  unsigned int v18; // edx
  char v20; // bh
  int v21; // edi
  int v24; // esi
  char v25; // bl
  unsigned __int8 v26; // dh
  char v27; // di
  int v28; // esi
  int v29; // esi
  unsigned int v31; // esi
  int v32; // esi
  int v35; // edi
  char v36; // al
  int v38; // ebx
  int v40; // edx
  int v41; // ebx
  char v42; // of
  int v45; // edi
  int v46; // edx
  int v47; // ecx
  bool v48; // tt
  int v49; // edx
  int v50; // edi
  int v52; // edx
  bool v54; // cf
  int v60; // esi
  int v61; // edi
  int v62; // edx
  int v63; // edi
  int v64; // edi
  int v65; // edi
  int v66; // esi
  unsigned int v67; // edx
  unsigned int v68; // edx
  int v73; // edi
  bool v74; // pf
  int v75; // ebx
  int v76; // edi
  int v77; // edx
  int v78; // [esp-14h] [ebp-14h]
  int v79; // [esp-14h] [ebp-14h]
  int v80; // [esp-8h] [ebp-8h]

  BYTE1(a3) <<= a3;
  LOBYTE(a2) = __ROL1__(a2, a3);
  v48 = __CFSHR__(a3, a3);
  v47 = __ROR4__(a3, a3);
  v49 = a1 + v48 + a2;
  _EBX = a4 - a1;
  v50 = a5 - 1;
  LOBYTE(v49) = v49 + 32;
  LOBYTE(_EBX) = BYTE1(a1) ^ _EBX;
  v52 = (v49 + 1) << v47;
  v79 = v47;
  _EAX = v52 | a1;
  v54 = __CFADD__(a6, v47);
  _ECX = a6 + v47 + 1;
  if ( v54 || !v54 )
  {
    __asm { rcr     ch, cl }
    LOBYTE(_EBX) = _EBX - 1;
    BYTE1(_EAX) = __ROR1__(BYTE1(_EAX), _ECX);
    v31 = _EAX + a6;
    BYTE1(v52) = v52;
    BYTE1(_EAX) = v52 | BYTE1(_EAX) ^ 0x97;
    _EDX = v50 ^ _EBX ^ v52;
    BYTE1(_EDX) ^= 0x17u;
    _CL = BYTE1(_EBX) | _EAX;
    __asm
    {
      rcl     al, cl
      rcr     ebx, cl
      rcr     dh, cl
    }
    ++_EBX;
    LOBYTE(_EBX) = _EBX - 6;
    LOBYTE(_EDX) = _EDX - 1;
    v40 = __ROR4__(_EDX, 195);
    v41 = v50 | _EAX ^ _EBX;
    v61 = v50 + 1;
    LOBYTE(v40) = 8 * v40;
    _EAX >>= v80;
    v62 = v80 & (v80 + __CFSHL__(v61, -61) + v40);
    v63 = v41 ^ (8 * v61);
    _ECX = v80 ^ 0x5566345;
    BYTE1(_EAX) = (BYTE1(v80) | BYTE1(_EAX)) - 7;
    BYTE1(v62) = (BYTE1(v62) ^ 0xB8) + 14;
    BYTE1(v41) |= 0x7Eu;
    ++v62;
    LOBYTE(v62) = BYTE1(v41) + ((_BYTE)v62 << (v80 ^ 0x45));
    BYTE1(v41) &= BYTE1(v62);
    _EBX = v41 << (v80 ^ 0x45);
    __asm { rcl     ebx, cl }
    BYTE1(v62) = -29;
    _EDX = __ROL4__(v62, v80 ^ 0x45);
    LOBYTE(_EBX) = BYTE1(_EAX) & _EBX;
    BYTE1(_ECX) = __ROR1__(BYTE1(_ECX), _ECX);
    LOBYTE(_ECX) = _EBX ^ v80 ^ 0x45;
    __asm
    {
      rcr     edx, cl
      rcl     ecx, cl
    }
    LOBYTE(_ECX) = _ECX + 1;
    v45 = v63 << _ECX;
    BYTE1(_EBX) <<= _ECX;
    v46 = __ROR4__(_EDX, _ECX);
    _EBX = v45 + _EBX;
    LOWORD(_EBX) = __PAIR16__(BYTE1(_EBX), __ROR1__(_EAX, v80 ^ 0x45)) - 256;
    LOBYTE(v46) = (char)((_BYTE)v46 << _EBX) >> 3;
    LOBYTE(_EBX) = _EBX - v46;
    LOBYTE(_EAX) = BYTE1(v46);
    LOBYTE(v46) = BYTE1(v46) | v46;
    v76 = _EBX + v45;
    v77 = _EAX | v46;
    LOBYTE(_EBX) = (char)_EBX >> 3;
    v54 = __CFSHR__(v77, -125);
    v77 >>= 3;
    v6 = (__ROR4__(v31, 195) >> v80 << v80) - (v54 + _EBX);
    BYTE1(_EBX) *= 8;
    LOBYTE(_EBX) = BYTE1(v77) + (_EBX ^ 0xDA);
    a6 = v6 >> 3;
    v7 = _EAX ^ v77;
    LOBYTE(_EBX) = _EBX & 0x33;
    v54 = __CFSHR__(_EBX, -125);
    LOBYTE(_EBX) = (char)_EBX >> 3;
    v50 = v54 + v76 + 4250243;
    BYTE1(v7) = -31;
    _ECX = 4250242;
    _EDX = __ROL4__(v7, 130);
    if ( !v42 && v42 )
      JUMPOUT(0x40D9FB);
  }
  else
  {
    __asm { into }
    _EDX = v79;
  }
  BYTE1(_EDX) = BYTE1(_ECX) + (BYTE1(_EDX) << _ECX);
  _ESI = a6 - 1;
  LOBYTE(_EDX) = __ROR1__(BYTE1(_EBX) + _EDX, _ECX);
  __asm { rcr     esi, cl }
  _EBX = v50 & _EBX;
  v54 = __CFADD__(v50, _ESI);
  v60 = v50 + _ESI;
  __asm { rcr     bh, cl }
  v36 = _EAX - (v54 - 92);
  v54 = __CFSHR__(_ECX, 15);
  _ECX = _ECX >> 15;
  BYTE1(_EBX) = _EBX + v54 + (_EDX & BYTE1(_EBX));
  LOBYTE(_EDX) = _EDX ^ 0xE7;
  BYTE1(_EBX) <<= _ECX;
  v38 = _EDX & _EBX;
  LOBYTE(_EDX) = __CFSHR__(v50, _ECX) + (BYTE1(_EDX) ^ _EDX);
  _EDI = __ROR4__(v50, _ECX) - _ECX;
  v36 ^= 0x59u;
  LOBYTE(_EDX) = (_BYTE)_EDX << _ECX;
  __asm { rcl     edx, cl }
  BYTE1(v38) += 3;
  _ECX = _ECX << 15;
  v54 = __CFSHL__(v38, _ECX);
  LOBYTE(v38) = (_BYTE)v38 << _ECX;
  v24 = v38 ^ v60;
  v25 = v38 & 0xFA;
  BYTE1(_EDX) = __ROR1__(SBYTE1(_EDX) >> _ECX, _ECX);
  LOBYTE(_EDX) = (char)(v36 + v54 + ((char)_EDX >> _ECX)) >> _ECX;
  v32 = v24 << _ECX;
  _EDX = _EDX << _ECX;
  __asm { rcl     dh, cl }
  v78 = *(_DWORD *)_ECX;
  __asm { rcr     edi, cl }
  v35 = _EDX + __CFADD__(BYTE1(_ECX), v25 ^ v36) + _EDI;
  v73 = v32 & v35;
  v74 = __SETP__(-24, __CFSHR__(v78 | v25, _ECX) - 117);
  v75 = v73;
  if ( !v74 && v74 )
    JUMPOUT(0x40DCC6);
  v29 = v78 | v32;
  _DH = (unsigned __int8)(v73 & BYTE1(_EDX)) >> _ECX;
  v15 = v29 << _ECX;
  __asm { rcr     dh, cl }
  LOBYTE(v75) = __ROR1__(v73 + 11, _ECX);
  _EBX = v75 - 1;
  v18 = (unsigned __int8)v78;
  __asm { rcl     ebx, cl }
  v20 = ((_BYTE)_EBX << _ECX) + __CFSHL__(_EBX, _ECX) + BYTE1(_EBX);
  v21 = (unsigned __int8)v78 | v73;
  if ( !(((char)(v20 + 1) < 0) ^ __OFADD__(1, v20) | (v20 == -1))
    && ((char)(v20 + 1) < 0) ^ __OFADD__(1, v20) | (v20 == -1) )
  {
    JUMPOUT(0x40D57D);
  }
  v64 = v15 + __CFSHR__(v78, 16) + v21;
  v54 = __CFSHL__(v64, _ECX);
  v65 = v64 << _ECX;
  v66 = BYTE1(v78) + v54 + v15 - 1;
  v26 = __ROL1__(-5, _ECX);
  v27 = __ROR4__(v65 >> _ECX, _ECX);
  BYTE1(v18) = v26 + 68 - ((v26 < 0xBCu) + 121);
  v28 = _ECX & v66;
  if ( !__OFSUB__((char)v78 >> _ECX, BYTE1(v78)) && __OFSUB__((char)v78 >> _ECX, BYTE1(v78)) )
    JUMPOUT(0x40D5FC);
  LOBYTE(v18) = ((char)v78 >> _ECX) - BYTE1(v78) + 33;
  v54 = __CFSHR__(v18, _ECX);
  LOBYTE(v18) = (char)v18 >> _ECX;
  v67 = v18 >> _ECX;
  LOBYTE(v67) = v67 - 1;
  v68 = v28 + v67;
  _BL = (v27 - (v54 + v78 + BYTE2(v78))) & (__ROR4__(BYTE1(v78) << _ECX, _ECX) ^ 0xB7);
  LOBYTE(v68) = (unsigned __int8)v68 >> _ECX;
  v14 = __ROL4__(v68, _ECX);
  BYTE1(v14) ^= 0x65u;
  LOBYTE(v14) = BYTE1(v14) + v14;
  __asm { rcl     bl, cl }
  BYTE1(v14) += 63;
  LOBYTE(v14) = __ROL1__(v14, _ECX);
  _EDX = v14 << _ECX;
  __asm { rcl     dh, cl }
  JUMPOUT(0x40D683);
}
// 40D428: positive sp value 10 has been found
// 40D3F5: control flows out of bounds to 40D3F7
// 40D4B0: inconsistent fpu stack
// 40D4B0: control flows out of bounds to 40D4B3
// 40D577: control flows out of bounds to 40D57D
// 40D58C: control flows out of bounds to 40D58E
// 40D5A0: control flows out of bounds to 40D5A2
// 40D5D2: control flows out of bounds to 40D5D4
// 40D5F6: control flows out of bounds to 40D5FC
// 40D708: control flows out of bounds to 40D709
// 40D759: control flows out of bounds to 40D75B
// 40D7A6: control flows out of bounds to 40D7A7
// 40D874: control flows out of bounds to 40D87A
// 40D90F: control flows out of bounds to 40D916
// 40D950: control flows out of bounds to 40D952
// 40D9D6: control flows out of bounds to 40D9D8
// 40D9F5: control flows out of bounds to 40D9FB
// 40DC26: control flows out of bounds to 40DC27
// 40DCC0: control flows out of bounds to 40DCC6
// 40DD66: control flows out of bounds to 40DD68
// 40D550: control flows out of bounds to 40D913
// 40D6A0: control flows out of bounds to 40D6FF
// 40DB8D: control flows out of bounds to 40DCF1
// 40DC99: control flows out of bounds to 40D683
// 40DD3D: control flows out of bounds to 40DD36
// 40D4E5: control flows out of bounds to 40DAF3
// 40D90D: control flows out of bounds to 40D8FF
// 40D950: control flows out of bounds to 40D976
// 40DD52: control flows out of bounds to 40D484
// 40DD64: control flows out of bounds to 40DDB3
// 40D477: conditional instruction was optimized away because bl.1!=0
// 40D537: conditional instruction was optimized away because dl.1!=0
// 40D5CC: conditional instruction was optimized away because bl.1 is in (1..FA)
// 40D97D: conditional instruction was optimized away because edi.4!=0
// 40D9D0: conditional instruction was optimized away because ebx.4>=1
// 40DBB5: conditional instruction was optimized away because esi.4!=0
// 40DBF2: conditional instruction was optimized away because dh.1>=1
// 40DC1D: conditional instruction was optimized away because ebx.4>=1
// 40DD34: conditional instruction was optimized away because edx.4!=0
// 40DBA2: variable 'v80' is possibly undefined
// 40D9EB: variable 'v42' is possibly undefined

// nfuncs=3 queued=2 decompiled=2 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2 function(s)"
