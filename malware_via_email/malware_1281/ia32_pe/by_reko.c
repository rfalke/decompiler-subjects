// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_tB6E0; // 0040B000
<anonymous> * __imp__LeaveCriticalSection = &g_tB6F2; // 0040B004
<anonymous> * __imp__GetModuleFileNameA = &g_tB70A; // 0040B008
<anonymous> * __imp__EnterCriticalSection = &g_tB720; // 0040B00C
<anonymous> * __imp__VirtualProtect = &g_tB738; // 0040B010
<anonymous> * __imp__Sleep = &g_tB74A; // 0040B014
<anonymous> * __imp__CreateFileW = &g_tB752; // 0040B018
<anonymous> * __imp__GetCurrentProcess = &g_tB760; // 0040B01C
<anonymous> * __imp__lstrlenA = &g_tB774; // 0040B020
<anonymous> * __imp__LoadLibraryW = &g_tB780; // 0040B024
<anonymous> * __imp__CreateFileW = &g_tB790; // 0040B028
<anonymous> * __imp__HeapAlloc = &g_tB79E; // 0040B02C
<anonymous> * __imp__CreateFileW = &g_tB7AA; // 0040B030
<anonymous> * __imp__SetLastError = &g_tB7B8; // 0040B034
<anonymous> * __imp__QueryPerformanceCounter = &g_tB7C8; // 0040B038
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tB7E2; // 0040B03C
<anonymous> * __imp__LocalFree = &g_tB7FE; // 0040B040
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tB80A; // 0040B044
<anonymous> * __imp__ReadFile = &g_tB826; // 0040B048
<anonymous> * __imp__VirtualAlloc = &g_tB832; // 0040B04C
<anonymous> * __imp__CreateFileW = &g_tB842; // 0040B050
<anonymous> * __imp__InitializeCriticalSection = &g_tB850; // 0040B054
<anonymous> * __imp__VirtualAlloc = &g_tB86C; // 0040B058
<anonymous> * __imp__VirtualProtect = &g_tB87C; // 0040B05C
<anonymous> * __imp__SetLastError = &g_tB88E; // 0040B060
<anonymous> * __imp__HeapFree = &g_tB89E; // 0040B064
<anonymous> * __imp__GetModuleHandleA = &g_tB8AA; // 0040B068
<anonymous> * __imp__CreateThread = &g_tB8BE; // 0040B06C
<anonymous> * __imp__GetLastError = &g_tB8CE; // 0040B070
<anonymous> * __imp__GetTickCount = &g_tB8DE; // 0040B074
<anonymous> * __imp__GetCurrentThreadId = &g_tB8EE; // 0040B078
<anonymous> * __imp__GetCurrentProcess = &g_tB904; // 0040B07C
<anonymous> * __imp__HeapAlloc = &g_tB918; // 0040B080
<anonymous> * __imp__InitializeCriticalSection = &g_tB924; // 0040B084
<anonymous> * __imp__GetTickCount = &g_tB940; // 0040B088
<anonymous> * __imp__InterlockedIncrement = &g_tB950; // 0040B08C
<anonymous> * __imp__HeapDestroy = &g_tB968; // 0040B090
<anonymous> * __imp__GetCurrentProcess = &g_tB976; // 0040B094
<anonymous> * __imp__GetModuleHandleA = &g_tB98A; // 0040B098
<anonymous> * __imp__HeapAlloc = &g_tB99E; // 0040B09C
<anonymous> * __imp__InterlockedDecrement = &g_tB9AA; // 0040B0A0
<anonymous> * __imp__FreeLibrary = &g_tB9C2; // 0040B0A4
<anonymous> * __imp__CreateFileW = &g_tB9D0; // 0040B0A8
<anonymous> * __imp__InterlockedCompareExchange = &g_tB9DE; // 0040B0AC
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tB9FC; // 0040B0B0
<anonymous> * __imp__LoadLibraryW = &g_tBA16; // 0040B0B4
<anonymous> * __imp__InterlockedIncrement = &g_tBA26; // 0040B0B8
<anonymous> * __imp__CreateEventW = &g_tBA3E; // 0040B0BC
<anonymous> * __imp__CreateEventW = &g_tBA4E; // 0040B0C0
<anonymous> * __imp__Sleep = &g_tBA5E; // 0040B0C4
<anonymous> * __imp__VirtualProtect = &g_tBA66; // 0040B0C8
<anonymous> * __imp__GetLastError = &g_tBA78; // 0040B0CC
<anonymous> * __imp__GetCurrentThreadId = &g_tBA88; // 0040B0D0
<anonymous> * __imp__lstrlenA = &g_tBA9E; // 0040B0D4
<anonymous> * __imp__HeapFree = &g_tBAAA; // 0040B0D8
<anonymous> * __imp__lstrlenA = &g_tBAB6; // 0040B0DC
<anonymous> * __imp__GetTickCount = &g_tBAC2; // 0040B0E0
<anonymous> * __imp__InterlockedCompareExchange = &g_tBAD2; // 0040B0E4
<anonymous> * __imp__GetModuleFileNameW = &g_tBAF0; // 0040B0E8
<anonymous> * __imp__InterlockedExchange = &g_tBB06; // 0040B0EC
<anonymous> * __imp__GetModuleHandleW = &g_tBB1C; // 0040B0F0
<anonymous> * __imp__GetProcessHeap = &g_tBB30; // 0040B0F4
<anonymous> * __imp__CloseHandle = &g_tBB42; // 0040B0F8
<anonymous> * __imp__CloseHandle = &g_tBB50; // 0040B0FC
<anonymous> * __imp__FreeLibrary = &g_tBB5E; // 0040B100
<anonymous> * __imp__VirtualProtect = &g_tBB6C; // 0040B104
<anonymous> * __imp__EnterCriticalSection = &g_tBB7E; // 0040B108
<anonymous> * __imp__LocalFree = &g_tBB96; // 0040B10C
<anonymous> * __imp__Sleep = &g_tBBA2; // 0040B110
<anonymous> * __imp__Sleep = &g_tBBAA; // 0040B114
<anonymous> * __imp__InterlockedCompareExchange = &g_tBBB2; // 0040B118
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tBBD0; // 0040B11C
<anonymous> * __imp__GetCurrentProcess = &g_tBBEC; // 0040B120
<anonymous> * __imp__GetModuleFileNameW = &g_tBC00; // 0040B124
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tBC16; // 0040B128
<anonymous> * __imp__VirtualProtect = &g_tBC30; // 0040B12C
<anonymous> * __imp__LoadLibraryW = &g_tBC42; // 0040B130
<anonymous> * __imp__MultiByteToWideChar = &g_tBC52; // 0040B134
<anonymous> * __imp__CloseHandle = &g_tBC68; // 0040B138
<anonymous> * __imp__QueryPerformanceCounter = &g_tBC76; // 0040B13C
<anonymous> * __imp__GetModuleFileNameA = &g_tBC90; // 0040B140
<anonymous> * __imp__DisableThreadLibraryCalls = &g_tBCA6; // 0040B144
<anonymous> * __imp__GetCurrentProcess = &g_tBCC2; // 0040B148
<anonymous> * __imp__HeapFree = &g_tBCD6; // 0040B14C
<anonymous> * __imp__HeapAlloc = &g_tBCE2; // 0040B150
<anonymous> * __imp__GetModuleFileNameW = &g_tBCEE; // 0040B154
<anonymous> * __imp__InterlockedCompareExchange = &g_tBD04; // 0040B158
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_tBD22; // 0040B15C
<anonymous> * __imp__GetLastError = &g_tBD3C; // 0040B160
<anonymous> * __imp__GetModuleFileNameW = &g_tBD4C; // 0040B164
<anonymous> * __imp__InterlockedIncrement = &g_tBD62; // 0040B168
<anonymous> * __imp__SetLastError = &g_tBD7A; // 0040B16C
<anonymous> * __imp__UnhandledExceptionFilter = &g_tBD8A; // 0040B170
<anonymous> * __imp__MultiByteToWideChar = &g_tBDA6; // 0040B174
<anonymous> * __imp__GetCurrentProcess = &g_tBDBC; // 0040B178
<anonymous> * __imp__SetLastError = &g_tBDD0; // 0040B17C
<anonymous> * __imp__MultiByteToWideChar = &g_tBDE0; // 0040B180
<anonymous> * __imp__lstrlenA = &g_tBDF6; // 0040B184
<anonymous> * __imp__GetProcAddress = &g_tBE02; // 0040B188
<anonymous> * __imp__InterlockedExchange = &g_tBE14; // 0040B18C
<anonymous> * __imp__GetModuleHandleA = &g_tBE2A; // 0040B190
<anonymous> * __imp__CreateEventW = &g_tBE3E; // 0040B194
<anonymous> * __imp__LoadLibraryW = &g_tBE4E; // 0040B198
<anonymous> * __imp__InterlockedCompareExchange = &g_tBE5E; // 0040B19C
<anonymous> * __imp__InterlockedCompareExchange = &g_tBE7C; // 0040B1A0
<anonymous> * __imp__GetModuleFileNameW = &g_tBE9A; // 0040B1A4
<anonymous> * __imp__GetVersionExA = &g_tBEB0; // 0040B1A8
<anonymous> * __imp__GetCurrentProcess = &g_tBEC0; // 0040B1AC
<anonymous> * __imp__SetLastError = &g_tBED4; // 0040B1B0
<anonymous> * __imp__PostMessageW = &g_tBEF2; // 0040B1B8
<anonymous> * __imp__SendMessageW = &g_tBF02; // 0040B1BC
<anonymous> * __imp__ShowWindow = &g_tBF12; // 0040B1C0
<anonymous> * __imp__EndPaint = &g_tBF20; // 0040B1C4
<anonymous> * __imp__SendDlgItemMessageW = &g_tBF2C; // 0040B1C8
<anonymous> * __imp__PeekMessageW = &g_tBF42; // 0040B1CC
<anonymous> * __imp__SetForegroundWindow = &g_tBF52; // 0040B1D0
<anonymous> * __imp__ReleaseDC = &g_tBF68; // 0040B1D4
<anonymous> * __imp__GetFocus = &g_tBF74; // 0040B1D8
<anonymous> * __imp__GetWindowLongW = &g_tBF80; // 0040B1DC
<anonymous> * __imp__InvalidateRect = &g_tBF92; // 0040B1E0
<anonymous> * __imp__SetDlgItemTextW = &g_tBFA4; // 0040B1E4
<anonymous> * __imp__SetCursor = &g_tBFB6; // 0040B1E8
<anonymous> * __imp__SetWindowTextW = &g_tBFC2; // 0040B1EC
<anonymous> * __imp__CharNextW = &g_tBFD4; // 0040B1F0
<anonymous> * __imp__wsprintfA = &g_tBFE0; // 0040B1F4
<anonymous> * __imp__TranslateMessage = &g_tBFEC; // 0040B1F8
<anonymous> * __imp__GetParent = &g_tC000; // 0040B1FC
<anonymous> * __imp__SendDlgItemMessageW = &g_tC00C; // 0040B200
<anonymous> * __imp__SetForegroundWindow = &g_tC022; // 0040B204
<anonymous> * __imp__DestroyWindow = &g_tC038; // 0040B208
<anonymous> * __imp__GetClientRect = &g_tC048; // 0040B20C
<anonymous> * __imp__SendMessageW = &g_tC058; // 0040B210
<anonymous> * __imp__EndDialog = &g_tC068; // 0040B214
<anonymous> * __imp__TranslateMessage = &g_tC074; // 0040B218
<anonymous> * __imp__EndDialog = &g_tC088; // 0040B21C
<anonymous> * __imp__GetDC = &g_tC094; // 0040B220
<anonymous> * __imp__PostQuitMessage = &g_tC09C; // 0040B224
<anonymous> * __imp__DialogBoxParamW = &g_tC0AE; // 0040B228
<anonymous> * __imp__wsprintfA = &g_tC0C0; // 0040B22C
<anonymous> * __imp__CharNextW = &g_tC0CC; // 0040B230
<anonymous> * __imp__GetDC = &g_tC0D8; // 0040B234
<anonymous> * __imp__GetParent = &g_tC0E0; // 0040B238
<anonymous> * __imp__PostQuitMessage = &g_tC0EC; // 0040B23C
<anonymous> * __imp__LoadCursorW = &g_tC0FE; // 0040B240
<anonymous> * __imp__PostMessageW = &g_tC10C; // 0040B244
<anonymous> * __imp__SetTimer = &g_tC11C; // 0040B248
<anonymous> * __imp__EnableWindow = &g_tC128; // 0040B24C
<anonymous> * __imp__GetFocus = &g_tC138; // 0040B250
<anonymous> * __imp__SendMessageW = &g_tC144; // 0040B254
<anonymous> * __imp__CharNextW = &g_tC154; // 0040B258
<anonymous> * __imp__BeginPaint = &g_tC160; // 0040B25C
<anonymous> * __imp__PostQuitMessage = &g_tC16E; // 0040B260
<anonymous> * __imp__PeekMessageW = &g_tC180; // 0040B264
<anonymous> * __imp__GetSysColor = &g_tC190; // 0040B268
<anonymous> * __imp__EndDialog = &g_tC19E; // 0040B26C
<anonymous> * __imp__GetDC = &g_tC1AA; // 0040B270
<anonymous> * __imp__CreateWindowExW = &g_tC1B2; // 0040B274
<anonymous> * __imp__PeekMessageW = &g_tC1C4; // 0040B278
<anonymous> * __imp__BeginPaint = &g_tC1D4; // 0040B27C
<anonymous> * __imp__MessageBoxW = &g_tC1E2; // 0040B280
<anonymous> * __imp__CharNextW = &g_tC1F0; // 0040B284
<anonymous> * __imp__SetTimer = &g_tC1FC; // 0040B288
<anonymous> * __imp__GetWindowLongW = &g_tC208; // 0040B28C
<anonymous> * __imp__TranslateMessage = &g_tC21A; // 0040B290
<anonymous> * __imp__GetFocus = &g_tC22E; // 0040B294
<anonymous> * __imp__EndPaint = &g_tC23A; // 0040B298
<anonymous> * __imp__IsWindow = &g_tC246; // 0040B29C
<anonymous> * __imp__GetDlgItem = &g_tC252; // 0040B2A0
<anonymous> * __imp__wsprintfA = &g_tC260; // 0040B2A4
<anonymous> * __imp__PostQuitMessage = &g_tC26C; // 0040B2A8
<anonymous> * __imp__PostMessageW = &g_tC27E; // 0040B2AC
<anonymous> * __imp__GetFocus = &g_tC28E; // 0040B2B0
<anonymous> * __imp__GetSysColor = &g_tC29A; // 0040B2B4
<anonymous> * __imp__ReleaseDC = &g_tC2A8; // 0040B2B8
<anonymous> * __imp__InvalidateRect = &g_tC2B4; // 0040B2BC
<anonymous> * __imp__SetForegroundWindow = &g_tC2C6; // 0040B2C0
<anonymous> * __imp__IsDlgButtonChecked = &g_tC2DC; // 0040B2C4
<anonymous> * __imp__GetWindowRect = &g_tC2F2; // 0040B2C8
<anonymous> * __imp__SendDlgItemMessageW = &g_tC302; // 0040B2CC
<anonymous> * __imp__DefWindowProcW = &g_tC318; // 0040B2D0
<anonymous> * __imp__GetDesktopWindow = &g_tC32A; // 0040B2D4
<anonymous> * __imp__CharNextW = &g_tC33E; // 0040B2D8
<anonymous> * __imp__CharNextW = &g_tC34A; // 0040B2DC
<anonymous> * __imp__InvalidateRect = &g_tC356; // 0040B2E0
<anonymous> * __imp__GetDesktopWindow = &g_tC368; // 0040B2E4
<anonymous> * __imp__wsprintfA = &g_tC37C; // 0040B2E8
<anonymous> * __imp__LoadStringW = &g_tC388; // 0040B2EC
<anonymous> * __imp__SetForegroundWindow = &g_tC396; // 0040B2F0
<anonymous> * __imp__SetWindowLongW = &g_tC3AC; // 0040B2F4
<anonymous> * __imp__DialogBoxParamW = &g_tC3BE; // 0040B2F8
<anonymous> * __imp__ShowWindow = &g_tC3D0; // 0040B2FC
<anonymous> * __imp__GetFocus = &g_tC3DE; // 0040B300
<anonymous> * __imp__EndDialog = &g_tC3EA; // 0040B304
<anonymous> * __imp__CreateWindowExW = &g_tC3F6; // 0040B308
<anonymous> * __imp__DefWindowProcW = &g_tC408; // 0040B30C
<anonymous> * __imp__SetWindowPos = &g_tC41A; // 0040B310
<anonymous> * __imp__MessageBoxW = &g_tC42A; // 0040B314
<anonymous> * __imp__GetWindowLongW = &g_tC438; // 0040B318
<anonymous> * __imp__GetDlgItem = &g_tC44A; // 0040B31C
<anonymous> * __imp__GetSysColor = &g_tC458; // 0040B320
<anonymous> * __imp__GetFocus = &g_tC466; // 0040B324
<anonymous> * __imp__EnableWindow = &g_tC472; // 0040B328
<anonymous> * __imp__PostMessageW = &g_tC482; // 0040B32C
<anonymous> * __imp__SendMessageW = &g_tC492; // 0040B330
<anonymous> * __imp__SetForegroundWindow = &g_tC4A2; // 0040B334
<anonymous> * __imp__GetWindowLongW = &g_tC4B8; // 0040B338
<anonymous> * __imp__PostMessageW = &g_tC4CA; // 0040B33C
<anonymous> * __imp__LoadStringW = &g_tC4DA; // 0040B340
<anonymous> * __imp__CharNextW = &g_tC4E8; // 0040B344
<anonymous> * __imp__GetDesktopWindow = &g_tC4F4; // 0040B348
word32 g_dw40B390 = 0xB6E0; // 0040B390
word32 g_dw40B394 = 46834; // 0040B394
word32 g_dw40B398 = 0xB70A; // 0040B398
word32 g_dw40B39C = 0xB720; // 0040B39C
word32 g_dw40B3A0 = 46904; // 0040B3A0
word32 g_dw40B3A4 = 46922; // 0040B3A4
word32 g_dw40B3A8 = 0xB752; // 0040B3A8
word32 g_dw40B3AC = 46944; // 0040B3AC
word32 g_dw40B3B0 = 46964; // 0040B3B0
word32 g_dw40B3B4 = 0xB780; // 0040B3B4
word32 g_dw40B3B8 = 0xB790; // 0040B3B8
word32 g_dw40B3BC = 47006; // 0040B3BC
word32 g_dw40B3C0 = 0xB7AA; // 0040B3C0
word32 g_dw40B3C4 = 0xB7B8; // 0040B3C4
word32 g_dw40B3C8 = 47048; // 0040B3C8
word32 g_dw40B3CC = 47074; // 0040B3CC
word32 g_dw40B3D0 = 0xB7FE; // 0040B3D0
word32 g_dw40B3D4 = 47114; // 0040B3D4
word32 g_dw40B3D8 = 47142; // 0040B3D8
word32 g_dw40B3DC = 47154; // 0040B3DC
word32 g_dw40B3E0 = 47170; // 0040B3E0
word32 g_dw40B3E4 = 0xB850; // 0040B3E4
word32 g_dw40B3E8 = 47212; // 0040B3E8
word32 g_dw40B3EC = 47228; // 0040B3EC
word32 g_dw40B3F0 = 0xB88E; // 0040B3F0
word32 g_dw40B3F4 = 47262; // 0040B3F4
word32 g_dw40B3F8 = 47274; // 0040B3F8
word32 g_dw40B3FC = 0xB8BE; // 0040B3FC
word32 g_dw40B400 = 0xB8CE; // 0040B400
word32 g_dw40B404 = 0xB8DE; // 0040B404
word32 g_dw40B408 = 0xB8EE; // 0040B408
word32 g_dw40B40C = 0xB904; // 0040B40C
word32 g_dw40B410 = 47384; // 0040B410
word32 g_dw40B414 = 0xB924; // 0040B414
word32 g_dw40B418 = 47424; // 0040B418
word32 g_dw40B41C = 47440; // 0040B41C
word32 g_dw40B420 = 47464; // 0040B420
word32 g_dw40B424 = 47478; // 0040B424
word32 g_dw40B428 = 47498; // 0040B428
word32 g_dw40B42C = 0xB99E; // 0040B42C
word32 g_dw40B430 = 0xB9AA; // 0040B430
word32 g_dw40B434 = 47554; // 0040B434
word32 g_dw40B438 = 0xB9D0; // 0040B438
word32 g_dw40B43C = 0xB9DE; // 0040B43C
word32 g_dw40B440 = 0xB9FC; // 0040B440
word32 g_dw40B444 = 0xBA16; // 0040B444
word32 g_dw40B448 = 47654; // 0040B448
word32 g_dw40B44C = 47678; // 0040B44C
word32 g_dw40B450 = 47694; // 0040B450
word32 g_dw40B454 = 47710; // 0040B454
word32 g_dw40B458 = 0xBA66; // 0040B458
word32 g_dw40B45C = 47736; // 0040B45C
word32 g_dw40B460 = 0xBA88; // 0040B460
word32 g_dw40B464 = 47774; // 0040B464
word32 g_dw40B468 = 0xBAAA; // 0040B468
word32 g_dw40B46C = 0xBAB6; // 0040B46C
word32 g_dw40B470 = 0xBAC2; // 0040B470
word32 g_dw40B474 = 0xBAD2; // 0040B474
word32 g_dw40B478 = 0xBAF0; // 0040B478
word32 g_dw40B47C = 0xBB06; // 0040B47C
word32 g_dw40B480 = 0xBB1C; // 0040B480
word32 g_dw40B484 = 0xBB30; // 0040B484
word32 g_dw40B488 = 0xBB42; // 0040B488
word32 g_dw40B48C = 0xBB50; // 0040B48C
word32 g_dw40B490 = 0xBB5E; // 0040B490
word32 g_dw40B494 = 0xBB6C; // 0040B494
word32 g_dw40B498 = 0xBB7E; // 0040B498
word32 g_dw40B49C = 0xBB96; // 0040B49C
word32 g_dw40B4A0 = 0xBBA2; // 0040B4A0
word32 g_dw40B4A4 = 0xBBAA; // 0040B4A4
word32 g_dw40B4A8 = 0xBBB2; // 0040B4A8
word32 g_dw40B4AC = 0xBBD0; // 0040B4AC
word32 g_dw40B4B0 = 0xBBEC; // 0040B4B0
word32 g_dw40B4B4 = 0xBC00; // 0040B4B4
word32 g_dw40B4B8 = 0xBC16; // 0040B4B8
word32 g_dw40B4BC = 0xBC30; // 0040B4BC
word32 g_dw40B4C0 = 48194; // 0040B4C0
word32 g_dw40B4C4 = 0xBC52; // 0040B4C4
word32 g_dw40B4C8 = 48232; // 0040B4C8
word32 g_dw40B4CC = 48246; // 0040B4CC
word32 g_dw40B4D0 = 0xBC90; // 0040B4D0
word32 g_dw40B4D4 = 48294; // 0040B4D4
word32 g_dw40B4D8 = 0xBCC2; // 0040B4D8
word32 g_dw40B4DC = 48342; // 0040B4DC
word32 g_dw40B4E0 = 48354; // 0040B4E0
word32 g_dw40B4E4 = 0xBCEE; // 0040B4E4
word32 g_dw40B4E8 = 48388; // 0040B4E8
word32 g_dw40B4EC = 48418; // 0040B4EC
word32 g_dw40B4F0 = 48444; // 0040B4F0
word32 g_dw40B4F4 = 48460; // 0040B4F4
word32 g_dw40B4F8 = 48482; // 0040B4F8
word32 g_dw40B4FC = 0xBD7A; // 0040B4FC
word32 g_dw40B500 = 48522; // 0040B500
word32 g_dw40B504 = 48550; // 0040B504
word32 g_dw40B508 = 0xBDBC; // 0040B508
word32 g_dw40B50C = 0xBDD0; // 0040B50C
word32 g_dw40B510 = 0xBDE0; // 0040B510
word32 g_dw40B514 = 0xBDF6; // 0040B514
word32 g_dw40B518 = 0xBE02; // 0040B518
word32 g_dw40B51C = 48660; // 0040B51C
word32 g_dw40B520 = 48682; // 0040B520
word32 g_dw40B524 = 0xBE3E; // 0040B524
word32 g_dw40B528 = 0xBE4E; // 0040B528
word32 g_dw40B52C = 0xBE5E; // 0040B52C
word32 g_dw40B530 = 48764; // 0040B530
word32 g_dw40B534 = 48794; // 0040B534
word32 g_dw40B538 = 0xBEB0; // 0040B538
word32 g_dw40B53C = 0xBEC0; // 0040B53C
word32 g_dw40B540 = 48852; // 0040B540
word32 g_dw40B548 = 48882; // 0040B548
word32 g_dw40B54C = 48898; // 0040B54C
word32 g_dw40B550 = 48914; // 0040B550
word32 g_dw40B554 = 0xBF20; // 0040B554
word32 g_dw40B558 = 48940; // 0040B558
word32 g_dw40B55C = 0xBF42; // 0040B55C
word32 g_dw40B560 = 48978; // 0040B560
word32 g_dw40B564 = 49000; // 0040B564
word32 g_dw40B568 = 0xBF74; // 0040B568
word32 g_dw40B56C = 0xBF80; // 0040B56C
word32 g_dw40B570 = 49042; // 0040B570
word32 g_dw40B574 = 49060; // 0040B574
word32 g_dw40B578 = 0xBFB6; // 0040B578
word32 g_dw40B57C = 49090; // 0040B57C
word32 g_dw40B580 = 0xBFD4; // 0040B580
word32 g_dw40B584 = 0xBFE0; // 0040B584
word32 g_dw40B588 = 0xBFEC; // 0040B588
word32 g_dw40B58C = 0xC000; // 0040B58C
word32 g_dw40B590 = 0xC00C; // 0040B590
word32 g_dw40B594 = 0xC022; // 0040B594
word32 g_dw40B598 = 0xC038; // 0040B598
word32 g_dw40B59C = 49224; // 0040B59C
word32 g_dw40B5A0 = 0xC058; // 0040B5A0
word32 g_dw40B5A4 = 0xC068; // 0040B5A4
word32 g_dw40B5A8 = 0xC074; // 0040B5A8
word32 g_dw40B5AC = 0xC088; // 0040B5AC
word32 g_dw40B5B0 = 0xC094; // 0040B5B0
word32 g_dw40B5B4 = 0xC09C; // 0040B5B4
word32 g_dw40B5B8 = 0xC0AE; // 0040B5B8
word32 g_dw40B5BC = 0xC0C0; // 0040B5BC
word32 g_dw40B5C0 = 0xC0CC; // 0040B5C0
word32 g_dw40B5C4 = 0xC0D8; // 0040B5C4
word32 g_dw40B5C8 = 0xC0E0; // 0040B5C8
word32 g_dw40B5CC = 0xC0EC; // 0040B5CC
word32 g_dw40B5D0 = 0xC0FE; // 0040B5D0
word32 g_dw40B5D4 = 0xC10C; // 0040B5D4
word32 g_dw40B5D8 = 0xC11C; // 0040B5D8
word32 g_dw40B5DC = 49448; // 0040B5DC
word32 g_dw40B5E0 = 49464; // 0040B5E0
word32 g_dw40B5E4 = 0xC144; // 0040B5E4
word32 g_dw40B5E8 = 49492; // 0040B5E8
word32 g_dw40B5EC = 0xC160; // 0040B5EC
word32 g_dw40B5F0 = 0xC16E; // 0040B5F0
word32 g_dw40B5F4 = 0xC180; // 0040B5F4
word32 g_dw40B5F8 = 0xC190; // 0040B5F8
word32 g_dw40B5FC = 49566; // 0040B5FC
word32 g_dw40B600 = 0xC1AA; // 0040B600
word32 g_dw40B604 = 0xC1B2; // 0040B604
word32 g_dw40B608 = 0xC1C4; // 0040B608
word32 g_dw40B60C = 0xC1D4; // 0040B60C
word32 g_dw40B610 = 49634; // 0040B610
word32 g_dw40B614 = 0xC1F0; // 0040B614
word32 g_dw40B618 = 0xC1FC; // 0040B618
word32 g_dw40B61C = 0xC208; // 0040B61C
word32 g_dw40B620 = 49690; // 0040B620
word32 g_dw40B624 = 0xC22E; // 0040B624
word32 g_dw40B628 = 49722; // 0040B628
word32 g_dw40B62C = 49734; // 0040B62C
word32 g_dw40B630 = 0xC252; // 0040B630
word32 g_dw40B634 = 0xC260; // 0040B634
word32 g_dw40B638 = 0xC26C; // 0040B638
word32 g_dw40B63C = 49790; // 0040B63C
word32 g_dw40B640 = 0xC28E; // 0040B640
word32 g_dw40B644 = 49818; // 0040B644
word32 g_dw40B648 = 0xC2A8; // 0040B648
word32 g_dw40B64C = 49844; // 0040B64C
word32 g_dw40B650 = 0xC2C6; // 0040B650
word32 g_dw40B654 = 49884; // 0040B654
word32 g_dw40B658 = 0xC2F2; // 0040B658
word32 g_dw40B65C = 49922; // 0040B65C
word32 g_dw40B660 = 49944; // 0040B660
word32 g_dw40B664 = 49962; // 0040B664
word32 g_dw40B668 = 0xC33E; // 0040B668
word32 g_dw40B66C = 49994; // 0040B66C
word32 g_dw40B670 = 50006; // 0040B670
word32 g_dw40B674 = 50024; // 0040B674
word32 g_dw40B678 = 50044; // 0040B678
word32 g_dw40B67C = 50056; // 0040B67C
word32 g_dw40B680 = 50070; // 0040B680
word32 g_dw40B684 = 0xC3AC; // 0040B684
word32 g_dw40B688 = 50110; // 0040B688
word32 g_dw40B68C = 0xC3D0; // 0040B68C
word32 g_dw40B690 = 0xC3DE; // 0040B690
word32 g_dw40B694 = 50154; // 0040B694
word32 g_dw40B698 = 50166; // 0040B698
word32 g_dw40B69C = 0xC408; // 0040B69C
word32 g_dw40B6A0 = 50202; // 0040B6A0
word32 g_dw40B6A4 = 0xC42A; // 0040B6A4
word32 g_dw40B6A8 = 50232; // 0040B6A8
word32 g_dw40B6AC = 50250; // 0040B6AC
word32 g_dw40B6B0 = 0xC458; // 0040B6B0
word32 g_dw40B6B4 = 0xC466; // 0040B6B4
word32 g_dw40B6B8 = 50290; // 0040B6B8
word32 g_dw40B6BC = 50306; // 0040B6BC
word32 g_dw40B6C0 = 50322; // 0040B6C0
word32 g_dw40B6C4 = 50338; // 0040B6C4
word32 g_dw40B6C8 = 50360; // 0040B6C8
word32 g_dw40B6CC = 0xC4CA; // 0040B6CC
word32 g_dw40B6D0 = 0xC4DA; // 0040B6D0
word32 g_dw40B6D4 = 50408; // 0040B6D4
word32 g_dw40B6D8 = 0xC4F4; // 0040B6D8
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040803F: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 fp;
	byte dl;
	Eq_5 ah;
	word24 edx_24_8;
	word16 di;
	Eq_5 cl;
	byte bh;
	Eq_5 bl;
	Eq_5 ch;
	byte al;
	cui16 ebx_16_16;
	word16 edi_16_16;
	cui16 ecx_16_16;
	word16 eax_16_16;
	struct Eq_17 * ebp;
	struct Eq_18 * es;
	struct Eq_19 * ds;
	struct Eq_20 * eax_2200;
	Eq_3 esp_1097 = fp;
	Eq_22 Top_1145 = 0;
	struct Eq_20 * edx_8 = SEQ(edx_24_8, dl & ah);
	struct Eq_20 * edx_10 = __ror<word32,byte>(edx_8, 0x1C);
	Eq_5 cl_146 = __rcr<byte,byte>(cl, cl, (edx_8 & 0x10000000) != 0x00) ^ (byte) edx_10;
	byte bl_25 = __ror<byte,byte>(bl, cl_146) + ah + ((bl & 0x01 << cl_146) != 0x00);
	word16 ax_34 = SEQ(__ror<byte,byte>(ah, cl_146), al) + (di - 0x01);
	Eq_5 ch_30 = __rol<byte,byte>(ch, 22);
	byte ah_44 = SLICE(ax_34, byte, 8);
	uint8 al_123 = (byte) ax_34 ^ 0x3A;
	Eq_5 ah_111 = __ror<byte,byte>(ah_44 + 44 & 0x24, 0x13);
	Eq_5 ch_337 = __ror<byte,byte>(ch_30, cl_146);
	struct Eq_20 * edi_61 = SEQ(edi_16_16, di - 0x01);
	Eq_5 bh_113 = bh + 0x06 | ~0x61;
	Eq_5 bl_104 = bl_25 | 0x06;
	cui16 ebx_16_16_1374 = ebx_16_16 | 0xD45A;
	struct Eq_20 * edi_119 = __rcl<word32,byte>(edi_61, 0x1C, (ch_30 & 0x01 << cl_146) != 0x00);
l00408458:
	Eq_5 bh_67 = (byte) bh_113 + 0x008E + (byte) ((edi_61 & 0x10) != 0x00);
	Eq_44 ch_72 = __rcr<byte,byte>(ch_337, 0x19, SLICE(cond(bh_67), bool, 1));
	ui32 ebx_76 = SEQ(ebx_16_16_1374, bh_67, bl_104);
	Eq_135 v553_1897 = !PARITY_EVEN(edi_119 & ebx_76);
	Eq_142 v538_1882 = PARITY_EVEN(edi_119 & ebx_76);
	bh_113 = __rcl<byte,byte>(bh_67, cl_146, false);
	word32 ecx_96 = SEQ(ecx_16_16, ch_72, cl_146 + bh_113);
	ah_111 = ah_111 ^ 0x1F;
	edi_119 = (edi_119 | edx_10) >> 0x1E;
	al_123 = al_123 & SLICE(edx_10, byte, 8) ^ 0x1E;
	cui16 cx_108 = (word16) (ecx_96 >> 0x01);
	ecx_16_16 = SLICE(ecx_96 >> 0x01, word16, 16);
l00408474:
	byte cl_109 = (byte) cx_108;
	int16 bx_114 = SEQ(bh_113, __rol<byte,byte>(bl_104, 0x1E));
	ui16 cx_110 = cx_108 << cl_109;
	Eq_5 cl_115 = (byte) cx_110;
	uint16 bx_117 = __rol<word16,byte>(bx_114, cl_115);
	struct Eq_20 * edi_121 = __rcl<word32,byte>(edi_119, cl_115, (bx_114 & 0x01 << 0x10 - cl_115) != 0x00);
	ui8 ah_112 = ah_111 ^ 0x0D;
	bcu8 ch_127 = SLICE(cx_110, byte, 8);
	struct Eq_20 * eax_131 = SEQ(eax_16_16, ah_112, al_123);
	cup16 di_125 = (word16) edi_121 + SEQ(ah_112, al_123);
	struct Eq_20 * eax_141 = __rcl<word32,byte>(__rol<word32,byte>(eax_131, 0x1A), 0x1E, SLICE(cond(ch_127 >> 0x19), bool, 1));
	Eq_5 cl_129 = cl_115 - ch_127 - (byte) (di_125 < 0x00);
	Eq_5 ch_1000 = ch_127 >> 0x19;
	byte al_153 = (byte) eax_141;
	Eq_5 ah_1303 = SLICE(eax_141, byte, 8);
	eax_16_16 = SLICE(eax_141, word16, 16);
	ptr32 edi_1289 = SEQ(SLICE(edi_121, word16, 16), di_125);
	word16 bx_161 = SEQ((bool) ((eax_131 & 0x40) != 0x00) + (SLICE(bx_117, byte, 8) + ch_127), (byte) bx_117);
	struct Eq_20 * esi_1011 = 0xBA1544A7;
	struct Eq_20 * edx_2211 = edx_10;
l00407FDC:
	byte al_155 = al_153 - SLICE(edx_2211, byte, 8);
	cl_146 = ~cl_129 | ~0x29;
	Eq_44 ch_150 = __rcr<byte,byte>(ch_1000, 0x1B, false);
	ui32 edi_152 = -edi_1289;
	bool C_158 = SLICE(cond(al_155), bool, 1);
	struct Eq_20 * ax_1434 = SEQ(ah_1303, al_155);
	word16 bx_162 = ~bx_161;
	struct Eq_20 * edi_159 = __rcr<word32,byte>(edi_152, 0x04, C_158);
	ui32 ebx_1118 = SEQ(ebx_16_16_1374, bx_162);
	edx_10 = edx_2211;
	do
	{
		word16 edx_16_16_1668;
		struct Eq_20 * edx_1028;
		int32 edx_2193;
		struct Eq_20 * eax_1313;
		Eq_5 cl_1054;
		Eq_334 edi_1072;
		uipr32 ecx_2196;
		word24 ebx_24_8_1474;
		Eq_334 edi_2199;
		ui32 ebx_1344;
		cui16 edi_16_16_1457;
		word16 eax_16_16_1076;
		cui16 di_1358;
		Eq_2 eax_1616;
		byte dl_1327;
		byte dh_1315;
		Eq_5 cl_1311;
		struct Eq_20 * esi_1168;
		byte ah_1051;
		int16 * edx_1235;
		Eq_5 al_1074;
		struct Eq_20 * esi_1045;
		int16 cx_2202;
		ui16 ebx_16_16_1040;
		Eq_5 bl_1033;
		Eq_5 cl_1015;
		uint8 bh_1029;
		int32 edx_1023;
		word16 edi_16_16_1850;
		byte al_1821;
		word16 di_1819;
		struct Eq_20 * esi_439;
		Eq_5 cl_415;
		struct Eq_20 * eax_1078;
		word24 ecx_24_8_1544;
		byte bl_1781;
		Eq_5 cl_733;
		Eq_5 ah_189;
		word32 ebx_2190;
		ui32 ecx_2185;
		word24 ecx_16_16_dh_2180;
		int32 edx_2214;
		word16 eax_16_16_1683;
		word16 ax_1681;
		uint8 al_1659;
		ui32 ebx_1510;
		struct Eq_268 * ecx_1528;
		up32 eax_632;
		struct Eq_1187 * eax_369;
		Eq_5 ch_166 = __ror<byte,byte>(ch_150 >> 0x13, 0x15);
		word32 edi_174 = __rol<word32,byte>(edi_159, cl_146) - 3870143887 - ((edi_159 & 0x01 << 0x20 - cl_146) != 0x00);
		struct Eq_20 * eax_180 = __rcl<word32,byte>(SEQ(eax_16_16, ax_1434 << cl_146), 0x18, SLICE(cond(edi_174), bool, 1));
		word16 edx_16_16_1665 = SLICE(edx_10, word16, 16);
		byte dl_1662 = (byte) edx_10;
		byte dh_672 = SLICE(edx_10, byte, 8);
		byte ah_1656 = SLICE(eax_180, byte, 8);
		Eq_5 al_191 = (byte) eax_180;
		word16 eax_16_16_1660 = SLICE(eax_180, word16, 16);
		ui32 edi_181 = edi_174 ^ ~0x02F20EA9;
		word24 ecx_24_8_193 = SEQ(ecx_16_16, ch_166);
		if ((edi_174 ^ ~0x02F20EA9) == 0x00)
		{
l004082D8:
			ah_189 = ah_1656 << cl_146;
			ecx_16_16_dh_2180 = SEQ(ecx_16_16, dh_672);
			goto l004082DA;
		}
		ecx_1528 = SEQ(ecx_24_8_193, cl_146);
		ebx_1510 = ebx_1118;
		edx_1028 = edx_10;
		if ((edi_174 ^ ~0x02F20EA9) != 0x00)
			goto l004082D8;
		al_1659 = al_191 | ecx_1528->bF8E58027;
l004081F4:
		ui32 ecx_201 = ecx_1528 << 0x1C;
		byte cl_210 = (byte) ecx_201;
		byte ch_205 = -SLICE(ecx_201, byte, 8);
		cui16 si_217 = (word16) esi_1011;
		cui16 cx_216 = SEQ(ch_205, cl_210);
		ui32 ebx_203 = ebx_1510 ^ 0x97813990;
		byte bh_212 = SLICE(ebx_203, byte, 8);
		word16 ebx_16_16_224 = SLICE(ebx_203, word16, 16);
		uint8 bl_211 = (byte) ebx_203 - 0xAA >> cl_210;
		v553_1897 = !PARITY_EVEN(cx_216 & si_217);
		up32 eax_226 = SEQ(eax_16_16_1660, SEQ(ah_1656 << 0x1A, al_1659) + 0x01) - SEQ(ebx_16_16_224, bh_212 ^ 0x2A, bl_211);
		ecx_16_16 = SLICE(ecx_201, word16, 16);
		v538_1882 = PARITY_EVEN(cx_216 & si_217);
		byte al_230 = (byte) eax_226;
		byte ah_1680 = SLICE(eax_226, byte, 8);
		eax_16_16_1683 = SLICE(eax_226, word16, 16);
		esi_1045 = esi_1011;
		ebx_1118 = SEQ(ebx_16_16_224, bh_212 ^ 0x2A, bl_211);
		ax_1681 = SEQ(ah_1680, al_230 | bh_212 ^ 0x2A);
		cx_2202 = SEQ(ch_205 + cl_210 + (byte) (eax_226 < 0x00), cl_210);
l004082A4:
		uint16 dx_242 = (word16) edx_1028;
		cui16 ax_243 = ax_1681 + dx_242;
		Eq_5 cl_245 = (byte) cx_2202;
		word16 ax_248 = __rcl<word16,byte>(ax_243, cl_245, SLICE(cond(ax_243), bool, 1));
		ui32 eax_251 = SEQ(eax_16_16_1683, ax_248);
		Eq_5 ah_259 = __rcl<byte,byte>(SLICE(eax_251 << 0x09, byte, 8), 0x05, ((byte) ax_248 << 0x09 & 0x01 << cl_245) != 0x00);
		ui24 ebx_24_8_381 = SLICE(ebx_1118, word24, 8);
		uint16 cx_263 = __rol<word16,byte>(cx_2202, cl_245);
		bl_104 = (byte) ebx_1118;
		bh_113 = (byte) ebx_24_8_381;
		ebx_16_16_1374 = SLICE(ebx_24_8_381, word16, 8);
		byte dh_292 = SLICE(edx_1028, byte, 8);
		dl_1662 = (byte) edx_1028;
		edx_16_16_1665 = SLICE(edx_1028, word16, 16);
		esi_1011 = esi_1045 & ebx_1118;
		edi_181 = edx_1028 << cl_245;
		word16 eax_16_16_307 = SLICE(eax_251 << 0x09, word16, 16);
		byte ah_265 = ah_259 - 0x4B - ((cx_2202 & 0x01 << 0x10 - cl_245) != 0x00);
		ui32 ecx_267 = SEQ(ecx_16_16, cx_263);
		cu8 ch_277 = SLICE(cx_263, byte, 8) | 0x60;
		cl_146 = (byte) cx_263 | 0x26;
		ecx_16_16 |= 30282;
		if ((ecx_267 | 0x764A6026) >= 0x00 && (ecx_267 | 0x764A6026) < 0x00)
		{
			word32 eax_658 = __in<word32>(dx_242);
			esp_1097 -= 2;
			esp_1097.u1->w0000 = ds;
			edx_1028->bFFFFFFD2 -= 228;
			al_191 = (byte) eax_658;
			ah_189 = SLICE(eax_658, byte, 8);
			eax_16_16_1660 = SLICE(eax_658, word16, 16);
			ecx_16_16_dh_2180 = SEQ(ecx_16_16, dh_292);
l004082DA:
			ui32 edi_667 = edi_181 ^ ~0x00F2565B;
			Eq_5 cl_677 = __rol<byte,byte>(cl_146, cl_146);
			cui16 di_685 = (word16) edi_667;
			Eq_44 al_683 = __rcr<byte,byte>(al_191, 0x0E, (cl_146 & 0x01 << 0x08 - cl_146) != 0x00);
			byte SZ_668 = cond(edi_667);
			word16 di_687 = __rcl<word16,byte>(di_685, cl_677, false);
			word16 ebx_16_16_1476 = SLICE(ebx_1118, word16, 16);
			byte bh_725 = SLICE(ebx_1118, byte, 8);
			byte bl_707 = (byte) ebx_1118;
			bool Z_696 = SLICE(SZ_668, bool, 2);
			bool v56_691 = (ah_189 & 0x01 << cl_677) != 0x00;
			Eq_44 ah_692 = __rcr<byte,byte>(ah_189, cl_677, (di_685 & 0x01 << 0x10 - cl_677) != 0x00);
			word32 edi_700 = SEQ(SLICE(edi_667, word16, 16), di_687);
			edx_1028 = SEQ(edx_16_16_1665, SLICE(ecx_16_16_dh_2180, byte, 8), dl_1662);
			if (!(v56_691 | SLICE(SZ_668, bool, 2)))
			{
				word24 eax_24_8_1615 = SEQ(eax_16_16_1660, ah_692);
				if (!(v56_691 | Z_696))
				{
					eax_1616 = SEQ(eax_24_8_1615, al_683 | 166);
					return eax_1616;
				}
			}
			ui32 ecx_722 = SEQ(ecx_16_16_dh_2180, cl_677) ^ esi_1011;
			cl_733 = (byte) ecx_722;
			word16 bx_737 = ~SEQ(bh_725, bl_707 + 0x01);
			cui16 ax_735 = __rcr<word16,byte>(SEQ(ah_692 << cl_677 | 0x82, al_683 ^ bh_725), cl_733, false);
			edi_1072 = edi_700 - 2231453562;
			ecx_24_8_1544 = SLICE(ecx_722, word24, 8);
			bl_1781 = (byte) bx_737;
			eax_1078 = SEQ(eax_16_16_1660, SLICE(ax_735, byte, 8), (byte) ax_735 + 0x01);
			ebx_24_8_1474 = SEQ(ebx_16_16_1476, SLICE(bx_737, byte, 8));
			goto l004080FD;
		}
		ui8 cl_286 = -cl_146;
		char ch_293 = (byte) cl_146 + (ch_277 - 199) + (byte) (ch_277 < 199) + dh_292;
		edi_119 = edi_181 | 3900189830;
		di_1358 = (word16) edi_181 | 11398;
		edi_16_16_1457 = SLICE(edi_181, word16, 16) | 0xE878;
		word16 ax_298 = SEQ(ah_265, __rol<byte,byte>(cl_146, 0x09));
		word16 cx_300 = SEQ(ch_293, cl_286);
		if (ch_293 >= 0x00 && ch_293 < 0x00)
			;
		cup16 ax_303 = ax_298 + cx_300 + (word16) (ch_293 < 0x00);
		up32 eax_310 = SEQ(eax_16_16_307, ax_303) + 0x2F25F4CC + (word32) (ax_303 < 0x00);
		cu8 ah_315 = SLICE(eax_310, byte, 8) + dh_292 + (byte) (eax_310 < 0x00);
		word32 eax_321 = SEQ(SLICE(eax_310, word16, 16), ah_315, (byte) eax_310) + 0x5BC0C5A1 + (word32) (ah_315 < 0x00);
		byte al_322 = (byte) eax_321;
		byte al_324 = -al_322;
		ch_337 = ch_293 - bl_104;
		eax_1616 = SEQ(SLICE(eax_321, word16, 16), __rcr<byte,byte>(SLICE(eax_321, byte, 8), 0x0D, al_322 != 0x00), al_324 - 0x01);
		if (OVERFLOW<byte>(al_324 - 0x01) || !OVERFLOW<byte>(al_324 - 0x01))
			return eax_1616;
		edx_10 = (struct Eq_20 *) *esp_1097;
		Eq_3 esp_349 = (word32) esp_1097 + 4;
		esp_349.u1->ptrFFFFFFFC = (struct Eq_17 *) 0x050361A6;
		eax_369 = (esp_349.u1->ptrFFFFFFFC ^ 4574574) - 88517832;
		ax_1434 = (word16) eax_369;
		ebp = (struct Eq_17 *) ((char *) ebp + 1);
		cl_146 = cl_286 & ~0x48;
		uint32 esi_358 = (edi_181 | 3900189830) + 0xDB184124;
		esp_1097 = esp_349;
		byte al_478 = (byte) ax_1434;
		eax_16_16 = SLICE(eax_369, word16, 16);
		byte ah_499 = SLICE(ax_1434, byte, 8);
		al_123 = (byte) eax_369;
		ah_111 = SLICE(eax_369, byte, 8);
		if (eax_369 > null && eax_369 <= null)
		{
			if (v553_1897)
			{
				ecx_2196 = SEQ(ecx_16_16, ~0x46, cl_286 & ~0x48);
				goto l00408483;
			}
			cx_108 = SEQ(ch_337, cl_286 & ~0x48);
			if (eax_369 == null)
				goto l00408458;
			goto l00408474;
		}
		Eq_1207 edi_385 = (edi_181 | 3900189830) >> 0x1D;
		ebx_1118 = (SEQ(ebx_24_8_381, bl_104 + (cl_286 & ~0x48) + CONVERT(eax_369 <u 0x00, bool, byte)) << 0x1E) - 1934388443;
		v553_1897 = !PARITY_EVEN(edi_385 >> 0x09 & edx_10);
		byte bh_398 = SLICE(ebx_1118, byte, 8);
		Eq_5 bl_407 = (byte) ebx_1118;
		ebx_16_16_1040 = SLICE(ebx_1118, word16, 16);
		esi_1011 = esi_358 >> 0x1B;
		edi_159 = edi_385 >> 0x09;
		ch_150 = (byte) ch_337.u0 + 1;
		v538_1882 = PARITY_EVEN(edi_385 >> 0x09 & edx_10);
		word24 ecx_24_8_461 = SEQ(ecx_16_16, (byte) ch_337.u0 + 1);
		ch_1000 = (byte) ch_337.u0 + 1;
	} while (Test(UGE,false) && Test(ULT,false));
	edi_2199 = edi_385 >> 0x09 ^ 2837353270;
	Eq_5 cl_404 = __rcl<byte,byte>(cl_286 & ~0x48, cl_286 & ~0x48, SLICE(cond(bh_398 << 0x0A), bool, 1));
	byte SZ_412 = cond(edi_2199);
	bl_1033 = __rcl<byte,byte>(bl_407, 0x09, (cl_286 & ~0x48 & 0x01 << 0x08 - (cl_286 & ~0x48)) != 0x00);
	dl_1327 = 0x00;
	dh_1315 = 0x00;
	edx_16_16_1668 = 0x00;
	bh_1029 = bh_398 << 0x0A;
	bool Z_419 = SLICE(SZ_412, bool, 2);
	bool v128_414 = (cl_404 & 0x01 << cl_404) != 0x00;
	cl_415 = __ror<byte,byte>(cl_404, cl_404);
	word32 ebx_427 = SEQ(ebx_16_16_1040, bh_398 << 0x0A, bl_1033);
	if (!(v128_414 | SLICE(SZ_412, bool, 2)) && !(v128_414 | Z_419))
	{
		edx_1023 = eax_369->a001B[eax_369] *s ~0x55;
		cl_1015 = __rol<byte,byte>(cl_415, ~0x24);
		eax_2200 = SEQ(eax_16_16, ah_499, al_478);
	}
	else
	{
		ui32 ebx_430 = -ebx_427 << cl_415;
		ui16 bx_436 = (word16) ebx_430 ^ ax_1434;
		esi_439 = esi_358 >> 0x1B << cl_415;
		word16 ebx_16_16_471 = SLICE(ebx_430, word16, 16);
		byte bl_443 = (byte) bx_436;
		byte bh_445 = SLICE(bx_436, byte, 8);
		di_1819 = (word16) edi_2199 + 55371;
		edi_16_16_1850 = SLICE(edi_2199 + 388749387, word16, 16);
		cui16 si_539 = (word16) esi_439;
		ui24 eax_24_8_500 = SEQ(eax_16_16, ah_499);
		if (PARITY_EVEN(esi_358 >> 0x1B & 2544366605) || !PARITY_EVEN(esi_358 >> 0x1B & 2544366605))
		{
			__syscall<byte>(0x2E);
			byte bl_448 = bl_443 - bh_445 - (byte) (esi_439 < 0x00);
			struct Eq_20 * ecx_464 = __rol<word32,byte>(SEQ(ecx_24_8_461, cl_415), 0x0F);
			byte cl_474 = (byte) ecx_464;
			word32 edi_450 = edi_2199 + 388749387 << 0x07;
			word32 ebx_472 = SEQ(ebx_16_16_471, bh_445 | 0x47, bl_448);
			ecx_16_16 = SLICE(ecx_464, word16, 16);
			ch_1000 = -SLICE(ecx_464, byte, 8) | cl_474;
			word16 edi_16_16_552 = SLICE(edi_450, word16, 16);
			int16 di_453 = (word16) edi_450 >> cl_415;
			byte bh_509 = SLICE(ebx_472 + 1378175370, byte, 8);
			word16 ebx_16_16_543 = SLICE(ebx_472 + 1378175370, word16, 16);
			cl_1311 = cl_474 + al_478;
			word24 ecx_24_8_521 = SEQ(ecx_16_16, ch_1000);
			edi_1072 = SEQ(edi_16_16_552, di_453);
			word32 eax_631 = SEQ(eax_24_8_500, al_478);
			if (!OVERFLOW<word32>(0x01) && OVERFLOW<word32>(0x01))
			{
				esp_349.u1->ptrFFFFFFFC = ebp;
				__out<byte>(0x00, al_478);
				esp_1097 = esp_349 - 4;
				esi_1011 = esi_439 + 1;
				eax_632 = eax_631 - *((word32 *) 0xC9C0F91B);
				goto l00408379;
			}
			up32 eax_503 = SEQ(eax_24_8_500, *(union Eq_5 *) ~0x00);
			Eq_5 al_605 = *(union Eq_5 *) ~0x00;
			esi_1168 = esi_439;
			struct Eq_20 * ecx_590 = SEQ(ecx_24_8_521, cl_1311);
			if (eax_503 != 0xC000002E)
			{
				byte cl_598 = (byte) __rol<word32,byte>(ecx_590, 0x11);
				uint16 dx_602 = (uint16) bh_509;
				return SEQ(eax_24_8_500, __rcr<byte,byte>(al_605, 0x1C, SLICE(cond(dx_602 << cl_598), bool, 1))) << cl_598;
			}
			Eq_1716 ecx_523 = SEQ(ecx_24_8_521, cl_1311 - bh_509 - (byte) (eax_503 < 0xC000002E));
			cui16 bx_541 = SEQ(~bh_509, bl_448 + 0x8A << 0x1B) | si_539;
			byte bh_562 = SLICE(bx_541, byte, 8);
			byte bl_563 = (byte) bx_541;
			ui32 eax_546 = eax_503 ^ SEQ(ebx_16_16_543, bx_541);
			edx_1235 = SEQ(0x05BC, 0xA5 >> __ror<byte,byte>(ecx_523 << 0x08, 0x06), 226);
			ebx_2190 = SEQ(ebx_16_16_543, bh_562, bl_563);
			edi_1072 = SEQ(edi_16_16_552, di_453);
			if (eax_546 != 0x00)
			{
				ebx_2190 = SEQ(ebx_16_16_543, bh_562, bl_563);
				edi_1072 = SEQ(edi_16_16_552, di_453);
				if (eax_546 == 0x00)
					return fnB5E0_31D3();
			}
l00407FA0:
			*edx_1235 = (int16) trunc(Top_1145.u1->r0000);
			esi_1011 = fn0C77412A();
			struct Eq_20 * edx_1281 = __rcl<word32,byte>(edx_1267, 0x17, SLICE(SCZDOP_1271, bool, 1));
			struct Eq_20 * ecx_1293 = SEQ(SLICE(ecx_1269, word16, 16), SLICE(ecx_1269, byte, 8) >> 0x18, (byte) ecx_1269);
			Eq_5 ah_1287 = __ror<byte,byte>(SLICE(ebx_2190, byte, 8) ^ 111, 0x12);
			struct Eq_20 * ecx_1295 = __ror<word32,byte>(ecx_1293, 0x07);
			Eq_5 cl_1297 = (byte) ecx_1295;
			struct Eq_20 * ecx_1299 = __rcl<word32,byte>(ecx_1295, cl_1297, (ecx_1293 & 0x80) != 0x00);
			cl_129 = (byte) ecx_1299;
			word16 ebx_16_16_1261 = SLICE(ebx_2190, word16, 16);
			byte bl_1258 = (byte) ebx_2190;
			ah_1303 = __rcl<byte,byte>(ah_1287, cl_129, (ecx_1295 & 0x01 << 0x20 - cl_1297) != 0x00);
			&Top_1145.u1->r0000 = (word32) Top_1145 + 1;
			bx_161 = (word16) esi_1168;
			ebx_16_16_1374 = SLICE(esi_1168, word16, 16);
			eax_16_16 = ebx_16_16_1261;
			al_153 = bl_1258;
			dh_1315 = SLICE(edx_1281, byte, 8);
			dl_1327 = (byte) edx_1281;
			edx_16_16_1668 = SLICE(edx_1281, word16, 16);
			edi_1289 = (word32) edi_1072 + 0x4C0C3FFC;
			ch_1000 = SLICE(ecx_1299, byte, 8);
			ecx_16_16 = SLICE(ecx_1299, word16, 16);
			Eq_711 v97_1302 = (ah_1287 & 0x01 << 0x08 - cl_129) != 0x00;
			struct Eq_728 * eax_1535 = SEQ(ebx_16_16_1261, ah_1303, bl_1258);
			if (Test(UGE,v97_1302) && Test(ULT,v97_1302))
			{
				byte dh_1532 = dh_1315 - (edi_1072.u1)[0x4C0C3FFF];
				v553_1897 = !PARITY_EVEN(eax_1535->bA7BE7BFA & dh_1532);
				v538_1882 = PARITY_EVEN(eax_1535->bA7BE7BFA & dh_1532);
				edx_2211 = SEQ(edx_16_16_1668, dh_1532, dl_1327);
				esp_1097 = esp_1266;
				goto l00407FDC;
			}
			edi_1072 = (word32) edi_1072 + 0x4C0C3FFC - ecx_1299 - v97_1302;
			cl_1311 = __ror<byte,byte>(cl_129, 0x0E);
			esp_1097 = esp_1266;
l00408379:
			cl_1054 = cl_1311 - dh_1315 - (byte) (eax_632 < 0x00);
			uint32 esi_1323 = esi_1011 << cl_1054;
			di_1358 = (word16) edi_1072;
			edi_16_16_1457 = SLICE(edi_1072, word16, 16);
			eax_1313 = 0x03;
			ax_1434 = 0x03;
			byte dl_1392 = (byte) __ror<word16,byte>(SEQ(dh_1315 + 0x3D + (byte) (esi_1323 < 0x00), dl_1327), cl_1054);
			ebx_1344 = 0x03;
			bh_113.u0 = 0x00;
			bl_104.u0 = 0x03;
			ebx_16_16_1374 = 0x00;
			if ((esi_1323 & 2378188763) >= 0x00)
			{
				edx_1028 = SEQ(edx_16_16_1668, ~0x01, dl_1392);
				if ((esi_1323 & 2378188763) < 0x00)
				{
					word32 * esp_1467 = esp_1097 - 4;
					*esp_1467 = 0x03;
					&esp_1097.u1->w0000 = (char *) esp_1467 + 1;
					es = (esi_1011 << cl_1054)->ptrC9D081DC;
l004083B1:
					ui32 ebx_1487 = ebx_1344 | edi_1072;
					Eq_5 cl_1492 = cl_1054 | (byte) ebx_1487 << 0x13;
					struct Eq_20 * eax_1501 = __ror<word32,byte>(eax_1313, cl_1492);
					eax_16_16_1660 = SLICE(eax_1501 << 0x13, word16, 16);
					int32 ecx_1515 = SEQ(ecx_16_16, __rcr<word16,byte>(SEQ(ch_1000 - 0x04, cl_1492), cl_1492, (eax_1313 & 0x01 << cl_1492) != 0x00));
					ecx_1528 = ecx_1515 >> 0x1E >> (byte) (ecx_1515 >> 0x1E);
					word16 cx_1530 = (word16) ecx_1528;
					ebx_1510 = (word32) edi_1072 + (ebx_1487 << 0x13) + (word32) (eax_1501 << 0x13 < 0x00);
					esi_1011 = __rcr<word32,byte>(3395055695, 0x14, SLICE(cond(ecx_1515 >> 0x1E), bool, 1));
					ah_1656 = SLICE(cx_1530, byte, 8);
					al_1659 = (byte) cx_1530;
					goto l004081F4;
				}
			}
			ecx_2196 = 0x422DEFC2;
l00408483:
			al_1821 = (byte) ax_1434;
			cui16 cx_1354 = (word16) ecx_2196;
			byte bl_1404 = bl_104 | 0x62;
			cui16 ebx_16_16_1438 = ebx_16_16_1374 | 0x023E;
			Eq_5 bh_1386 = __ror<byte,byte>((byte) bh_113 + 0x009E + (byte) (eax_369 < null) | 0x0C, 0x15);
			word32 edi_1461 = SEQ(edi_16_16_1457, di_1358 + 0x01);
			cui16 si_1389 = ~cx_1354;
			cui16 cx_1397 = cx_1354 + 662 | si_1389;
			cu8 ch_1400 = SLICE(cx_1397 - 0x01, byte, 8);
			byte bl_1406 = (byte) bh_1386 + bl_1404 + (byte) (ch_1400 < 0x00);
			uint32 ecx_1413 = SEQ(SLICE(ecx_2196 + 0x0F850296, word16, 16), ch_1400, (byte) cx_1397 - 0x01);
			Eq_5 cl_1416 = (byte) (ecx_1413 >> 0x1D);
			Eq_5 cl_1418 = __ror<byte,byte>(cl_1416, cl_1416);
			struct Eq_20 * ecx_1423 = __rcr<word32,byte>(SEQ(SLICE(ecx_1413 >> 0x1D, word24, 8), cl_1418), cl_1418, (cl_1416 & 0x01 << cl_1416) != 0x00);
			Eq_5 cl_1432 = __ror<byte,byte>((byte) ecx_1423 | 0x0A, 0x15);
			ui24 ecx_24_8_1818 = SLICE(ecx_1423, word24, 8) | 0x00405095;
			esi_1045 = 0xD55916B0;
			eax_2200 = ax_1434;
			Eq_5 bl_1444 = __ror<byte,byte>((byte) __rcr<word32,byte>(SEQ(ebx_16_16_1438, SEQ(bh_1386, bl_1406 - 0x01) - si_1389), 0x0D, false), cl_1432);
			word32 edi_1463 = -edi_1461;
			Eq_5 cl_1449 = (byte) cl_1432 + (byte) (bl_1444 << cl_1432 < 0x00);
			di_1819 = (word16) edi_1463;
			edi_16_16_1850 = SLICE(edi_1463, word16, 16);
			ecx_2185 = SEQ(ecx_24_8_1818, __rcr<byte,byte>(cl_1449, cl_1449, SLICE(cond(cl_1449), bool, 1)));
			edx_2214 = 0x00;
			goto l0040857B;
		}
		esp_349.u1->ptrFFFFFFFC = ebp;
		ebp = esp_349 - 4;
		esp_1097 = esp_349 - 0x00006669;
		al_1821 = (byte) eax_369 + ((esi_358 >> 0x1B) << cl_415)->b0009;
		edx_2193 = 0x00;
l004084FF:
		word16 cx_923 = __ror<word16,byte>(SEQ(__rcl<byte,byte>(ch_1000, cl_415, false), cl_415), cl_415);
		v553_1897 = !PARITY_EVEN(esi_439 & 3418235433);
		Eq_5 cl_936 = (byte) cx_923;
		v538_1882 = PARITY_EVEN(esi_439 & 3418235433);
		byte dl_986 = (byte) edx_2193;
		Eq_5 ch_940 = __ror<byte,byte>(SLICE(cx_923, byte, 8) - 0xC4, cl_936);
		Eq_5 cl_967 = (byte) ch_940 + (cl_936 - al_1821 & ~0x22);
		byte ah_974 = SLICE(eax_2200, byte, 8);
		ui8 ch_975 = (__rcr<byte,byte>(ch_940, cl_967, SLICE(cond(cl_967), bool, 1)) << 0x01) + ah_974;
		byte bl_984 = (byte) esi_439;
		byte bh_1004 = SLICE(esi_439, byte, 8);
		word16 ebx_16_16_1017 = SLICE(esi_439, word16, 16);
		struct Eq_20 * edi_982 = __rol<word32,byte>(SEQ(edi_16_16_1850, ~di_1819), 0x1A);
		word24 ecx_24_8_992 = SEQ(ecx_16_16, ch_975);
		int32 ecx_993 = SEQ(ecx_24_8_992, cl_967 >> 0x1A | dl_986);
		byte cl_999 = (byte) (ecx_993 >> 0x0C);
		ch_1000 = SLICE(ecx_993 >> 0x0C, byte, 8) >> cl_999;
		uint8 bh_1005 = bh_1004 << cl_999;
		ui16 v570_1914 = SEQ(cl_999 + 0x59 + (byte) (bh_1005 < 0x00), (byte) ch_1000 + (bl_984 - ah_974) + (byte) (ch_1000 < 0x00)) << 0x01;
		byte cl_1014 = SLICE(v570_1914, byte, 8);
		cl_1015 = cl_1014 << cl_1014;
		ecx_16_16 = SLICE(ecx_993 >> 0x0C, word16, 16);
		edi_2199 = edi_982 + 1091161359 + (word32) (ecx_993 >> 0x0C < 0x00);
		esi_1011 = esi_439 - 0x01;
		ui32 ebx_1018 = SEQ(ebx_16_16_1017, bh_1005, (byte) v570_1914);
		bool C_1020 = SLICE(cond(cl_1015), bool, 1);
		edx_1023 = edx_2193;
		struct Eq_20 * ebx_1021 = __rcr<word32,byte>(ebx_1018, 0x0D, C_1020);
		bh_1029 = SLICE(ebx_1021, byte, 8);
		bl_1033 = (byte) ebx_1021;
		ebx_16_16_1040 = SLICE(ebx_1021, word16, 16);
	}
	cui16 di_1036 = (word16) edi_2199;
	ui32 ebx_1046 = (SEQ(ebx_16_16_1040, SEQ(bh_1029 >> cl_1015, bl_1033) | di_1036) << 0x19) + 0x01;
	word16 bx_1048 = (word16) ebx_1046 + di_1036;
	edx_1028 = edx_1023 + 0x01;
	ah_1051 = SLICE(eax_2200, byte, 8);
	byte bl_1053 = (byte) bx_1048;
	eax_16_16_1076 = SLICE(eax_2200, word16, 16);
	al_1074 = (byte) eax_2200;
	byte dl_1064 = (byte) edx_1028;
	esi_1045 = esi_1011 | 0x705750F9;
	word16 ebx_16_16_1117 = SLICE(ebx_1046, word16, 16);
	byte bh_1052 = SLICE(bx_1048, byte, 8) - ah_1051;
	cl_1054 = cl_1015 << 0x13 ^ bl_1053;
	edi_1072 = edi_2199;
	eax_1078 = eax_2200;
	ax_1681 = (word16) eax_2200;
	eax_16_16_1683 = eax_16_16_1076;
	if (cl_1054 > 0x00 && cl_1054 <= 0x00)
	{
		Top_1145.u1->r0000 = (real64) edi_2199.u1->dwFFFFFFBD / (Top_1145.u1)->r0000;
		*(byte *) 0xFA819FA0 = ~0x14;
		ebx_2190 = SEQ(ebx_16_16_1117, bh_1052, bl_1053);
l00407F64:
		ui32 edx_1162 = edx_1028 & 0x739C0871;
		struct Eq_20 * esi_1166 = __rol<word32,byte>(esi_1045, 0x09);
		byte dl_1173 = (byte) edx_1162;
		uint8 al_1182 = (bool) ((esi_1166 & 0x40000000) != 0x00) + ((byte) al_1074 + dl_1173) << cl_1054;
		esi_1168 = __rol<word32,byte>(esi_1166, 0x02);
		struct Eq_20 * ecx_1192 = __ror<word32,byte>(SEQ(ecx_16_16, ch_1000 - 0xA9 - (byte) (al_1182 < 0x00), cl_1054), cl_1054);
		bcu8 ch_1193 = SLICE(ecx_1192, byte, 8);
		byte cl_1199 = (byte) ecx_1192;
		edx_1235 = SEQ(SLICE(edx_1162, word16, 16), SLICE(edx_1162, byte, 8) | 88, dl_1173);
		word24 eax_24_8_1969 = SEQ(eax_16_16_1076, ah_1051);
		if (ch_1193 >> 0x15 < 0x00)
			return SEQ(eax_24_8_1969, al_1182 << cl_1199);
		eax_24_8_1969 = SEQ(eax_16_16_1076, ah_1051);
		if (ch_1193 >> 0x15 >= 0x00)
			return SEQ(eax_24_8_1969, al_1182 << cl_1199);
		goto l00407FA0;
	}
	cl_1054 = __rcl<byte,byte>(cl_1054, 0x07, (ch_1000 & 0x01 << 0x08 - cl_1054) != 0x00);
	cu8 bh_1091 = (bool) ((cl_1054 & 0x02) != 0x00) + (((bh_1052 - dl_1064) - (byte) (cl_1054 < 0x00)) + ~0x26);
	edi_1072 = edi_2199 - eax_2200;
	ch_1000 = al_1074;
	struct Eq_17 * ecx_1107 = SEQ(ecx_16_16, al_1074, cl_1054);
	ebx_1118 = SEQ(ebx_16_16_1117, bh_1091, bl_1053);
	if (bh_1091 < 0x00 || bh_1091 >= 0x00)
	{
		while (true)
		{
			esp_1097 -= 4;
			&esp_1097->u1->w0000 = edi_1072;
			do
			{
				word16 dx_845 = (word16) edx_1028;
				word32 edi_779 = edi_1072 - 4250958054;
				byte dh_1564 = SLICE(dx_845, byte, 8);
				word16 edx_16_16_1572 = SLICE(edx_1028, word16, 16);
				byte dl_1852 = (byte) dx_845;
				bl_1781 = 0x23;
				esi_1045 = ~0x6A02EF68;
				edi_1072 = edi_779 - 3605858805;
				word16 di_843 = (word16) edi_779 - 0x09F5;
				word16 edi_16_16_860 = SLICE(edi_779 - 3605858805, word16, 16);
				bool C_794 = SLICE(cond(edx_1028 - 20053104), bool, 1);
				word24 ecx_24_8_838 = SEQ(ecx_16_16, ch_1000);
				if (edx_1028 != 20053104)
				{
					ecx_2185 = SEQ(ecx_16_16, __rcl<byte,byte>(ch_1000, 0x18, C_794), cl_1054 & ~0x60);
l0040815E:
					struct Eq_20 * edi_863 = __rol<word32,byte>(SEQ(edi_16_16_860, di_843 - dx_845), (byte) ecx_2185);
					esp_1097 = fp - 5;
					di_1819 = (word16) (edi_863 >> 0x11);
					edi_16_16_1850 = SLICE(edi_863 >> 0x11, word16, 16);
					bool v81_874 = (eax_1078 & 0x02) != 0x00;
					al_1821 = (byte) __ror<word32,byte>(eax_1078, 0x01);
					word24 edx_24_8_1853 = SEQ(edx_16_16_1572, dh_1564);
					edx_2214 = SEQ(edx_24_8_1853, dl_1852);
					if (Test(UGE,v81_874))
					{
						Eq_2 edi_1575 = edx_1028 & 236058818;
						struct Eq_778 * edx_1594 = (struct Eq_778 *) <invalid>;
						word16 dx_2218;
						__out<byte>((word16) edx_1594, fn004094B1(out dx_2218));
						return edi_1575;
					}
l0040857B:
					ui32 ecx_887 = ecx_2185 << (byte) ecx_2185;
					byte cl_888 = (byte) ecx_887;
					word16 ecx_16_16_904 = SLICE(ecx_887, word16, 16);
					int32 ecx_905 = SEQ(ecx_16_16_904, 0x6D, cl_888 << 0x0F);
					esi_439 = esi_1045 + 0x67019F76;
					byte ch_908 = SLICE(ecx_905 >> 0x05, byte, 8);
					cl_415 = (byte) (ecx_905 >> 0x05);
					ecx_16_16 = SLICE(ecx_905 >> 0x05, word16, 16);
					ch_1000 = -ch_908;
					edx_2193 = edx_2214;
					goto l004084FF;
				}
				struct Eq_20 * eax_811 = __rcl<word32,byte>(eax_1078, cl_1054, C_794);
				al_1074 = (byte) eax_811;
				ah_1051 = SLICE(eax_811, byte, 8);
				eax_16_16_1076 = SLICE(eax_811, word16, 16);
				word32 ecx_839 = SEQ(ecx_24_8_838, cl_1054);
				if (v538_1882)
				{
l00407F61:
					ebx_2190 = ~0xDC;
					goto l00407F64;
				}
				ebx_24_8_1474 = ~0x00;
				if (v553_1897)
					goto l00407F61;
				eax_1078 = (struct Eq_20 *) *esp_1097;
				Eq_3 esp_822 = (word32) esp_1097 + 4;
				esp_822.u1->ptrFFFFFFFE = es;
				edx_1028[416661748] = (struct Eq_20) (edx_1028[416661748] ^ 2148916161);
				esp_1097 = esp_822;
				cl_733 = cl_1054 - 0x01;
				ecx_24_8_1544 = SLICE(ecx_839 - 0x01, word24, 8);
				ecx_2185 = SEQ(ecx_24_8_1544, cl_733);
				if (edx_1028[416661748] != 0x00 || ecx_839 == 0x01)
					goto l0040815E;
l004080FD:
				cl_1054 = cl_733 - 0x01;
				ch_1000 = (byte) ecx_24_8_1544;
				ecx_16_16 = SLICE(ecx_24_8_1544, word16, 8);
				struct Eq_514 * ecx_768 = SEQ(ecx_24_8_1544, cl_1054);
				ebx_1344 = SEQ(ebx_24_8_1474, bl_1781 & (byte) eax_1078);
				if (Test(ULT,false) || Test(UGE,false))
				{
					eax_1313 = (struct Eq_20 *) ((char *) eax_1078 - 1864485943);
					goto l004083B1;
				}
				--ebp;
			} while (ebp >= null);
			Eq_513 ds_eax_770 = ecx_768->t47B9D1D3.u1;
			ds = SLICE(ds_eax_770, selector, 32);
			eax_1078 = (word32) ds_eax_770;
		}
	}
	else
	{
		Eq_1454 esp_1101 = esp_1097 - 4;
		&esp_1101->u1->w0000 = eax_2200;
		esp_1101.u1->ptrFFFFFFFC = ecx_1107;
		esp_1101.u1->ptrFFFFFFF8 = edx_1028;
		esp_1101.u1->dwFFFFFFF4 = ebx_1118;
		esp_1101.u1->tFFFFFFF0.u1 = (struct Eq_3044 *) esp_1097;
		esp_1101.u1->ptrFFFFFFEC = ebp;
		esp_1101.u1->ptrFFFFFFE8 = esi_1045;
		esp_1101.u1->tFFFFFFE4.u1 = (struct Eq_3048 *) edi_1072;
		esp_1101.u1->ptrFFFFFFE0 = esp_1101 - 28;
		ecx_1107->dwAE9127B = ecx_1107->dwAE9127B - ecx_1107 - (esp_1101 - 32);
		v553_1897 = esp_1101 - 32;
		v538_1882 = esp_1101 - 32;
		esp_1097 = esp_1101 - 28;
		cx_2202 = SEQ(al_1074, cl_1054);
		goto l004082A4;
	}
}

// 00409151: void fn00409151(Register word32 edx)
// Called from:
//      fn00409435
void fn00409151(word32 edx)
{
	ui32 eax;
	struct Eq_778 * ecx;
	byte bh;
	byte bl;
	word16 ebx_16_16;
	word32 esi;
	word32 edx_5 = -edx;
	word16 dx_34;
	fn0040915E(eax, ecx, (byte) edx_5, bh, bl, ebx_16_16, esi, out dx_34);
}

// 0040915E: Register byte fn0040915E(Register ui32 eax, Register (ptr32 Eq_778) ecx, Register byte dl, Register byte bh, Register byte bl, Register word16 ebx_16_16, Register word32 esi, Register out Eq_788 dxOut)
// Called from:
//      fn00409151
//      fn00409435
//      fn0040957F
byte fn0040915E(ui32 eax, struct Eq_778 * ecx, byte dl, byte bh, byte bl, word16 ebx_16_16, word32 esi, union Eq_788 & dxOut)
{
	up32 esi_22 = esi + 0x4FE9FEAA - SEQ(ebx_16_16, bh, bl ^ 0x4E);
	if (esi_22 <= 0x00 || esi_22 > 0x00)
	{
		cu8 bh_55 = ecx->b0000;
		if (bh_55 <= 0x11)
		{
			word16 dx_240;
			uint32 eax_119 = (uint32) fn0040957F(eax, ecx, out dx_240);
			dxOut.u0 = <invalid>;
			return (byte) eax_119;
		}
		else if (bh_55 > 0x11)
		{
			word16 dx_241;
			uint32 eax_127 = (uint32) fn0040957F(eax, ecx, out dx_241);
			dxOut.u0 = <invalid>;
			return (byte) eax_127;
		}
		else
		{
			dxOut.u0 = <invalid>;
			return (byte) eax;
		}
	}
	else
	{
		word16 dx_242;
		uint32 eax_171 = (uint32) fn0040957F(eax, ecx, out dx_242);
		dxOut.u0 = <invalid>;
		return (byte) eax_171;
	}
}

// 00409229: Register byte fn00409229(Register byte al, Register word24 eax_24_8, Register (ptr32 Eq_778) ecx, Register bcu8 dh, Register byte dl, Register ui16 edx_16_16, Register (ptr32 Eq_20) ebx, Register (ptr32 Eq_20) edi, Register out Eq_788 dxOut)
// Called from:
//      fn0040939F
//      fn00409435
byte fn00409229(byte al, word24 eax_24_8, struct Eq_778 * ecx, bcu8 dh, byte dl, ui16 edx_16_16, struct Eq_20 * ebx, struct Eq_20 * edi, union Eq_788 & dxOut)
{
	Eq_1939 fp;
	ui32 eax;
	word32 edx;
	Eq_5 cl = (byte) ecx;
	struct Eq_20 * ebx_24 = __rcl<word32,byte>(__rcl<word32,byte>(ebx, cl, false), 0x18, SLICE(cond(al + 0xB0), bool, 1));
	byte bl_29 = (byte) ebx_24;
	word24 ebx_24_8_60 = SLICE(ebx_24, word24, 8);
	struct Eq_20 * edx_33 = SEQ(edx_16_16, dh & SLICE(ecx - ~0x027D, byte, 8), dl);
	struct Eq_20 * eax_45 = SEQ(eax_24_8, al + 0xB0);
	struct Eq_20 * edx_35 = __rol<word32,byte>(edx_33, 0x15);
	ui32 edx_52 = SEQ(SLICE(edx_35, word24, 8), (byte) edx_35 ^ 0x18) ^ ecx - ~0x027D;
	Eq_5 dh_69 = SLICE(edx_52, byte, 8);
	byte dl_75 = (byte) edx_52;
	bci8 al_56 = (byte) -(word16) __rol<word32,byte>(eax_45, 0x1E);
	word32 ebx_61 = SEQ(ebx_24_8_60, bl_29 << 0x1B);
	word32 ebx_62 = -ebx_61;
	word16 ebx_16_16_82 = SLICE(ebx_62, word16, 16);
	word16 bx_74 = SEQ(SLICE(ebx_62, byte, 8), (byte) ebx_62 + (al_56 >> 0x13 | 0x5D));
	word16 dx_76 = SEQ(__ror<byte,byte>(dh_69, cl - 0x82), dl_75);
	uint32 ebx_83 = SEQ(ebx_16_16_82, bx_74 + dx_76);
	word16 ebx_16_16_159 = SLICE(ebx_83 >> 0x1E, word16, 16);
	ui8 bl_92 = (byte) (ebx_83 >> 0x1E) << cl;
	ci8 dl_99 = dl_75 - bl_92;
	Eq_2027 ebx_171 = SEQ(ebx_16_16_159, 177, bl_92);
	if (dl_99 < 0x00 || dl_99 >= 0x00)
	{
		fn00409151(edx);
		dxOut.u0 = <invalid>;
		return 0x51;
	}
	else if (OVERFLOW<byte>(dl_99))
	{
		if (ebx_171 <= fp - 4)
		{
			ecx->bFFFFFFE9 = (byte) cl + ecx->bFFFFFFE9;
			word16 dx_220;
			fn0040957F(eax, ecx, out dx_220);
			dxOut.u0 = <invalid>;
			return 0x4F;
		}
		else
		{
			word16 dx_218;
			fn00409435(out dx_218);
			dxOut.u0 = <invalid>;
			return 0x4F;
		}
	}
}

// 00409283: void fn00409283()
// Called from:
//      fn00409435
void fn00409283()
{
	fn0040957A();
}

// 0040939F: Register byte fn0040939F(Register ui32 eax, Register byte dh, Register byte dl, Register ui16 edx_16_16, Register (ptr32 Eq_20) ebx, Register word32 ebp, Register uint16 si, Register word16 esi_16_16, Register (ptr32 Eq_20) edi, Register (ptr32 Eq_20) ds, Stack (ptr32 Eq_778) dwArg04, Register out Eq_788 dxOut)
// Called from:
//      fn00409435
//      fn0040957F
byte fn0040939F(ui32 eax, byte dh, byte dl, ui16 edx_16_16, struct Eq_20 * ebx, word32 ebp, uint16 si, word16 esi_16_16, struct Eq_20 * edi, struct Eq_20 * ds, struct Eq_778 * dwArg04, union Eq_788 & dxOut)
{
	bool C;
	struct Eq_778 * ecx;
	word32 esi;
	bcu8 dh_12 = dh + dl + (byte) C;
	Eq_5 cl_15 = (byte) dwArg04;
	struct Eq_20 * eax_18 = __rcr<word32,byte>(eax, cl_15, SLICE(cond(dh_12), bool, 1));
	cui16 si_113 = __rcr<word16,byte>(si, cl_15, (eax & 0x01 << cl_15) != 0x00);
	struct Eq_20 * ebx_26 = __rcl<word32,byte>(ebx, 0x06, false);
	byte al_35 = (byte) eax_18;
	word24 eax_24_8_37 = SLICE(eax_18, word24, 8);
	bool v20_31 = (ebx_26 & 0x01 << 0x20 - cl_15) != 0x00;
	struct Eq_20 * ebx_32 = __rcl<word32,byte>(ebx_26, cl_15, false);
	if (Test(ULT,v20_31))
	{
		word16 dx_719;
		uint32 eax_38 = (uint32) fn00409229(al_35, eax_24_8_37, dwArg04, dh_12, dl, edx_16_16, ebx_32, edi, out dx_719);
		dxOut.u0 = <invalid>;
		return (byte) eax_38;
	}
	else if (Test(UGE,v20_31))
	{
		word16 dx_720;
		uint32 eax_50 = (uint32) fn00409229(al_35, eax_24_8_37, dwArg04, dh_12, dl, edx_16_16, ebx_32, edi, out dx_720);
		dxOut.u0 = <invalid>;
		return (byte) eax_50;
	}
	else
	{
		word32 eax_65 = fn8C40_4C76();
		word16 eax_16_16_289 = SLICE(eax_65, word16, 16);
		cui16 ax_115 = (word16) eax_65;
		__sti();
l004093CE:
		struct Eq_778 * ecx_508;
		ui32 edx_577;
		uint32 edx_70 = edx_577 & ebx_32;
		uint32 edx_77 = ecx_508 + (edx_70 >> 0x1C) + (word32) (edx_70 >> 0x1C < 0x00);
		ci8 dl_78 = (byte) edx_77;
		struct Eq_20 * edi_83 = __rcl<word32,byte>(~edi, 0x07, SLICE(cond(dl_78 - 0x27), bool, 1));
		Eq_5 cl_89 = (byte) ecx_508;
		struct Eq_20 * edi_85 = __ror<word32,byte>(edi_83, 0x03);
		cui16 dx_91 = __rcr<word16,byte>(SEQ(SLICE(edx_77, byte, 8), dl_78 - 0x27), cl_89, (edi_83 & 0x08) != 0x00);
		ui16 edx_16_16_101 = SLICE(edx_77, word16, 16);
		byte al_287 = (byte) ax_115;
		byte ah_175 = SLICE(ax_115, byte, 8);
		Eq_5 bh_97 = SLICE(ebx_32, byte, 8);
		word16 ebx_16_16_484 = SLICE(ebx_32, word16, 16);
		byte bl_614 = (byte) ebx_32;
		bcu8 dh_556 = SLICE(dx_91, byte, 8);
		byte dl_558 = (byte) dx_91;
		struct Eq_2195 * edx_102 = SEQ(edx_16_16_101, dx_91);
		if (dl_78 > 0x27)
		{
			word24 eax_24_8_563 = SEQ(eax_16_16_289, ah_175);
			if (dl_78 <= 0x27)
			{
				edx_102->b003D >>= cl_89;
				word16 dx_722;
				uint32 eax_564 = (uint32) fn00409229(al_287, eax_24_8_563, ecx_508, dh_556, dl_558, edx_16_16_101, ebx_32, edi_85, out dx_722);
				dxOut.u0 = <invalid>;
				return (byte) eax_564;
			}
		}
		uint8 dl_118 = (byte) dx_91 << 0x09 << cl_89;
		Eq_5 bh_99 = __ror<byte,byte>(bh_97, 0x19);
		Eq_2217 v255_637 = SEQ(SLICE(edx_102 << 0x09, byte, 8), dh_106) >> cl_89;
		cui16 di_126 = __rcr<word16,byte>((word16) (edi_85 >> 0x07), cl_89, SLICE(cond(dl_118 + 0x14 + (byte) (dl_118 < 0x00)), bool, 1));
		int16 edx_16_16_142 = SLICE(edx_102 << 0x09, word16, 16);
		byte dh_106 = SLICE(v255_637, byte, 8);
		cui16 si_116 = si_113 | ax_115;
		bci8 dh_130 = ~__rol<byte,byte>((byte) v255_637 >> cl_89, 0x17);
		word16 cx_151 = (word16) ecx_508;
		struct Eq_20 * edi_158 = SEQ(SLICE(edi_85 >> 0x07, word16, 16), di_126);
		int32 edx_147 = SEQ(edx_16_16_142, dh_130 >> 0x1B, cl_89) - 242245460 - (word32) (dh_130 >> 0x1B < 0x00) >> 0x0D >> cl_89;
		byte bh_131 = -bh_99;
		byte dh_165 = SLICE(edx_147, byte, 8);
		bci8 dl_177 = (byte) edx_147;
		cui16 edx_16_16_178 = SLICE(edx_147, word16, 16);
		uint32 esi_169 = SEQ(esi_16_16, si_116 ^ 7607) ^ SEQ(0x7746, cx_151);
		while (true)
		{
			byte bh_157 = bh_131 - 0x4F;
			edi_158 = __ror<word32,byte>(edi_158, 0x1D) | 447070344;
			struct Eq_778 * ecx_708 = ecx_508;
			do
			{
				uint32 esi_171 = edi_158 + esi_169;
				bci8 dh_166 = ~dh_165;
				word16 di_202 = (word16) edi_158;
				Eq_5 cl_167 = (byte) ecx_708;
				word16 si_200 = (word16) esi_171;
				word16 esi_16_16_211 = SLICE(esi_171, word16, 16);
				byte * edx_179 = SEQ(edx_16_16_178, dh_166, dl_177);
				if (OVERFLOW<word32>(esi_171))
					__syscall<byte>(0x04);
				bci8 ah_184 = ah_175 + *edx_179 + (byte) (esi_171 < 0x00);
				__lock();
				struct Eq_20 * esi_214 = __rcl<word32,byte>(SEQ(esi_16_16_211, si_200 ^ di_202), cl_167, false);
				cui16 edx_16_16_231 = edx_16_16_178 | 0x80B5;
				byte dl_208 = ((bool) ((dh_166 >> 0x19 & 0x01 << cl_167) != 0x00) + (dl_177 + ah_184) >> cl_167 | 0x45) & ah_184;
				Eq_2350 edi_218 = edi_158 & esi_214;
				word32 eax_290 = SEQ(eax_16_16_289, ah_184, al_287);
				word24 eax_24_8_512 = SEQ(eax_16_16_289, ah_184);
				ecx_708->b0000 = bh_157;
				word32 edx_232 = SEQ(edx_16_16_231, __rcl<byte,byte>((bh_157 | 0x9A) << 0x08, cl_167, SLICE(cond((word32) edi_218 + 2106690480), bool, 1)), dl_208);
				struct Eq_20 * esi_235 = __rol<word32,byte>(esi_214, 0x0A);
				bcu8 dh_244 = SLICE(edx_232 - 3966455007, byte, 8);
				ui16 edx_16_16_261 = SLICE(edx_232 - 3966455007, word16, 16);
				word24 edx_24_8_576 = SLICE(edx_232 - 3966455007, word24, 8);
				si_113 = (word16) esi_235;
				esi_16_16 = SLICE(esi_235, word16, 16);
				byte dl_238 = dl_208 - 0x3B - ((esi_214 & 0x00400000) != 0x00);
				edi = (word32) edi_218 + 0x7D918BB1;
				word16 bx_312 = SEQ(bh_157, bl_614);
				bh_131 = bh_157;
				if (edi_218 > 2188276815)
				{
					struct Eq_20 * ebx_511 = SEQ(ebx_16_16_484, bx_312);
					if (edi_218 <= 2188276815)
					{
						ecx_508 = ecx_708 - 0x01;
						if (edi_218 == 2188276815 || ecx_708 == (struct Eq_778 *) 0x01)
						{
							word24 eax_24_8_537 = SEQ(eax_16_16_289, ah_184);
							word16 dx_721;
							uint32 eax_538 = (uint32) fn00409229(al_287, eax_24_8_537, ecx_708 - 0x01, dh_244, dl_238 & 0x33, edx_16_16_261, ebx_511, (word32) edi_218 + 0x7D918BB1, out dx_721);
							dxOut.u0 = <invalid>;
							return (byte) eax_538;
						}
						word32 eax_525 = SEQ(eax_24_8_512, al_287);
						edx_577 = SEQ(edx_24_8_576, dl_238 & 0x33);
						if (edi_218 <= 2188276815)
						{
							word16 dx_723;
							uint32 eax_513 = (uint32) fn00409229(al_287, eax_24_8_512, ecx_708 - 0x01, dh_244, dl_238 & 0x33, edx_16_16_261, ebx_511, (word32) edi_218 + 0x7D918BB1, out dx_723);
							dxOut.u0 = <invalid>;
							return (byte) eax_513;
						}
						else
						{
							eax_16_16_289 = SLICE(eax_525 + 0x01, word16, 16);
							ax_115 = (word16) eax_525 + 0x01;
							ebx_32 = ds;
							goto l004093CE;
						}
					}
				}
				uint32 edx_263 = SEQ(edx_16_16_261, (dh_244 >> cl_167) + 0x99, __rol<byte,byte>((dl_238 & 0x33) + ((byte) cl_167 + 1), 0x10) & 0x54) << (byte) cl_167 + 1;
				int16 cx_282 = (word16) ecx_708 + 0x01;
				ui32 edx_266 = edx_263 + 3336968766 + (word32) (edx_263 < 0x00);
				Eq_5 cl_292 = (byte) cx_282;
				word16 ecx_16_16_402 = SLICE(ecx_708 + 1, word16, 16);
				byte ch_605 = SLICE(cx_282, byte, 8);
				uint8 dl_272 = (byte) edx_266;
				int16 edx_16_16_296 = SLICE(edx_266, word16, 16);
				Eq_2466 dh_268 = SLICE(edx_266, byte, 8) << (byte) cl_167 + 1;
				if (dh_268 >= 0x00)
				{
					word32 * edx_460 = SEQ(edx_16_16_296, dh_268, dl_272);
					if (dh_268 < 0x00)
					{
						*edx_460 = ebp;
						fn0040957A();
						dxOut.u0 = <invalid>;
						return (byte) eax_504;
					}
				}
				int16 dx_280 = SEQ(dh_268, dl_272 - 0x01);
				word24 ecx_24_8_606 = SEQ(ecx_16_16_402, ch_605);
				int32 edx_298 = SEQ(edx_16_16_296, __rol<word16,byte>(dx_280 - cx_282, cl_292)) >> cl_292;
				Eq_5 dh_303 = __rcl<byte,byte>(SLICE(edx_298, byte, 8), 0x1B, SLICE(cond(edx_298), bool, 1));
				edi_158 = 0x39A9FD59 - (word32) (dh_268 < 0x00);
				byte SCZO_316 = cond((byte) dh_303 + 0x00A5);
				word16 di_329 = (word16) edi_158;
				ui16 edi_16_16_334 = SLICE(edi_158, word16, 16);
				ui32 eax_291 = eax_290 - 0x01;
				ah_175 = SLICE(eax_290 - 0x01, byte, 8);
				--al_287;
				eax_16_16_289 = SLICE(eax_290 - 0x01, word16, 16);
				edx_16_16_178 = SLICE(edx_298, word16, 16);
				dl_177 = (byte) edx_298;
				esi_169 = 0x16B142AD;
				dh_165 = (byte) dh_303 + 0x00A5;
				bool C_324 = SLICE(SCZO_316, bool, 1);
				bool Z_457 = SLICE(SCZO_316, bool, 2);
				word32 ebx_364 = SEQ(ebx_16_16_484, bx_312);
				if (dh_303 < 0x5B)
				{
l0040930F:
					while (true)
					{
						up32 edx_340 = eax_291 - 559767518;
						uint32 edi_343 = (SEQ(edi_16_16_334, ~~di_329) << 0x08 ^ 0x80363F81) + 0x20DC1617 + (word32) (edx_340 < 0x00);
						ui32 edi_346 = edi_343 + 4230303014 + (word32) (edi_343 < 0x00);
						byte ch_377 = SLICE(cx_282, byte, 8);
						Eq_5 cl_355 = (byte) cx_282;
						uint8 ah_387 = SLICE(eax_291, byte, 8);
						bcu8 al_397 = (byte) eax_291;
						word16 eax_16_16_398 = SLICE(eax_291, word16, 16);
						int32 esi_339 = esi_169 + 1575687770;
						cui16 dx_349 = (word16) edx_340;
						Eq_5 dl_361 = (byte) edx_340;
						word24 edx_24_8_410 = SLICE(edx_340, word24, 8);
						cui16 di_348 = (word16) edi_346;
						word16 edi_16_16_351 = SLICE(edi_346, word16, 16);
						int32 esi_356 = esi_339 >> cl_355;
						uint32 edi_357 = __rol<word32,byte>(SEQ(edi_16_16_351, di_348 & dx_349), 0x02) << cl_355;
						word24 ecx_24_8_403 = SEQ(ecx_16_16_402, ch_377);
						if (edx_340 != 0xDEA2A022)
							break;
						struct Eq_20 * edi_384 = __rol<word32,byte>(SEQ(SLICE(edi_357 >> 0x19, word16, 16), (word16) (edi_357 >> 0x19) - cx_282 * 0x02), cl_355);
						int40 esi_ah_634 = SEQ(esi_356, ah_387) + cl_355.u1;
						esi_169 = SLICE(esi_ah_634, word32, 8);
						Eq_5 dl_386 = __rol<byte,byte>(dl_361, cl_355);
						ui32 edi_394 = (char *) edi_384 - 0x5896954E + (word32) (esi_169 < 0x00);
						Eq_5 ah_396 = __ror<byte,byte>((byte) esi_ah_634, 0x0C);
						word32 ecx_404 = SEQ(ecx_24_8_403, cl_355);
						di_329 = (word16) edi_394;
						edi_16_16_334 = SLICE(edi_394, word16, 16);
						ui32 eax_399 = SEQ(eax_16_16_398, ah_396, al_397);
						byte ch_429 = SLICE(ecx_404 + 0x2100E452, byte, 8);
						ecx_16_16_402 = SLICE(ecx_404 + 0x2100E452, word16, 16);
						ui32 edx_411 = SEQ(edx_24_8_410, dl_386);
						eax_291 = SEQ(eax_16_16_398, ah_396, al_397 >> 0x0C);
						if (PARITY_EVEN(eax_399 & 0x85425B42) || !PARITY_EVEN(eax_399 & 0x85425B42))
						{
							struct Eq_20 * eax_418 = __rcr<word32,byte>(eax_291, 0x01, SLICE(cond(edx_411 << 0x1C), bool, 1));
							dxOut.u0 = <invalid>;
							return (byte) eax_418 + 0x60;
						}
						ebx_364 = 3535874476;
						cx_282 = SEQ(ch_429, (byte) cl_355.u1 + 82);
					}
					word16 dx_718;
					uint32 eax_370 = (uint32) fn0040915E(eax_291, ecx, dl, SLICE(ebx_364, byte, 8), (byte) ebx_364, SLICE(ebx_364, word16, 16), esi, out dx_718);
					dxOut.u0 = <invalid>;
					return (byte) eax_370;
				}
				ebx_364 = SEQ(ebx_16_16_484, bx_312);
				if (dh_303 >= 0x5B)
					goto l0040930F;
				ecx_708 = SEQ(ecx_24_8_606, cl_292);
			} while (C_324 | Z_457);
			ebp = 0x01A20303;
			ecx_508 = SEQ(ecx_24_8_606, cl_292);
		}
	}
}

// 00409435: Register byte fn00409435(Register out Eq_788 dxOut)
// Called from:
//      fn0040915E
//      fn004094B1
byte fn00409435(union Eq_788 & dxOut)
{
	word32 esi;
	struct Eq_778 * ecx;
	ui32 eax;
	byte dl;
	byte bh;
	byte bl;
	word16 ebx_16_16;
	word16 dx_40;
	uint32 eax_19 = (uint32) fn0040915E(eax, ecx, dl, bh, bl, ebx_16_16, esi, out dx_40);
	dxOut.u0 = <invalid>;
	return (byte) eax_19;
}

// 004094B1: Register byte fn004094B1(Register out Eq_788 dxOut)
// Called from:
//      Win32CrtStartup
byte fn004094B1(union Eq_788 & dxOut)
{
	word16 dx_38;
	uint32 eax_29 = (uint32) fn00409435(out dx_38);
	dxOut.u0 = <invalid>;
	return (byte) eax_29;
}

// 0040957A: Register word16 fn0040957A()
// Called from:
//      fn00409283
//      fn0040957F
word16 fn0040957A()
{
	word32 eax;
	struct Eq_778 * ecx;
	word16 dx_27;
	fn0040957F(eax - 311, ecx, out dx_27);
	return <invalid>;
}

// 0040957F: Register byte fn0040957F(Register ui32 eax, Register (ptr32 Eq_778) ecx, Register out Eq_788 dxOut)
// Called from:
//      fn0040915E
//      fn0040939F
//      fn0040957A
byte fn0040957F(ui32 eax, struct Eq_778 * ecx, union Eq_788 & dxOut)
{
	word32 esi;
	byte dh;
	byte dl;
	ui16 edx_16_16;
	struct Eq_20 * ebx;
	word32 ebp;
	struct Eq_20 * edi;
	struct Eq_20 * ds;
	if (eax == 0x00)
	{
		word32 eax_15 = ecx + Mem0[ecx + 60:word32];
		word32 eax_26 = ecx + Mem20[(Mem20[eax_15 + 0x80:word32] + ecx) + 16:word32];
		word32 * esp_27;
		ui32 eax_29;
		byte SCZOP_32;
		(*eax_26)();
		bool S_33 = (bool) SCZOP_32;
		if (S_33)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_778 * stackArg4 = (struct Eq_778 *) <invalid>;
			word16 dx_109;
			uint32 eax_36 = (uint32) fn0040939F(eax_29, dh, dl, edx_16_16, ebx, ebp, (word16) esi, SLICE(esi, word16, 16), edi, ds, stackArg4, out dx_109);
			dxOut.u0 = <invalid>;
			return (byte) eax_36;
		}
		else if (S_33)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_778 * stackArg4 = (struct Eq_778 *) <invalid>;
			word16 dx_111;
			uint32 eax_42 = (uint32) fn0040939F(eax_29, dh, dl, edx_16_16, ebx, ebp, (word16) esi, SLICE(esi, word16, 16), edi, ds, stackArg4, out dx_111);
			dxOut.u0 = <invalid>;
			return (byte) eax_42;
		}
		else
		{
			word32 esi_46 = *esp_27;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			struct Eq_778 * stackArg4 = (struct Eq_778 *) <invalid>;
			word16 dx_113;
			uint32 eax_52 = (uint32) fn0040939F(eax_29, dh, dl, edx_16_16, ebx, ebp, (word16) esi_46, SLICE(esi_46, word16, 16), edi, ds, stackArg4, out dx_113);
			dxOut.u0 = <invalid>;
			return (byte) eax_52;
		}
	}
}

