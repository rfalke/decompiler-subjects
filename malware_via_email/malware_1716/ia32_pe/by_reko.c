// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t116AC; // 00411000
<anonymous> * __imp__LoadLibraryA = &g_t116BE; // 00411004
<anonymous> * __imp__GetTickCount = &g_t116CE; // 00411008
<anonymous> * __imp__LocalFree = &g_t116DE; // 0041100C
<anonymous> * __imp__HeapAlloc = &g_t116EA; // 00411010
<anonymous> * __imp__LeaveCriticalSection = &g_t116F6; // 00411014
<anonymous> * __imp__GetCurrentProcessId = &g_t1170E; // 00411018
<anonymous> * __imp__VirtualAlloc = &g_t11724; // 0041101C
<anonymous> * __imp__MultiByteToWideChar = &g_t11734; // 00411020
<anonymous> * __imp__ReadFile = &g_t1174A; // 00411024
<anonymous> * __imp__ReadFile = &g_t11756; // 00411028
<anonymous> * __imp__DeleteCriticalSection = &g_t11762; // 0041102C
<anonymous> * __imp__GetProcAddress = &g_t1177A; // 00411030
<anonymous> * __imp__Sleep = &g_t1178C; // 00411034
<anonymous> * __imp__GetModuleFileNameW = &g_t11794; // 00411038
<anonymous> * __imp__HeapDestroy = &g_t117AA; // 0041103C
<anonymous> * __imp__LocalFree = &g_t117B8; // 00411040
<anonymous> * __imp__EnterCriticalSection = &g_t117C4; // 00411044
<anonymous> * __imp__HeapAlloc = &g_t117DC; // 00411048
<anonymous> * __imp__GetVersionExA = &g_t117E8; // 0041104C
<anonymous> * __imp__LoadLibraryA = &g_t117F8; // 00411050
<anonymous> * __imp__HeapDestroy = &g_t11808; // 00411054
<anonymous> * __imp__GetCurrentProcessId = &g_t11816; // 00411058
<anonymous> * __imp__InterlockedExchange = &g_t1182C; // 0041105C
<anonymous> * __imp__GetCurrentThreadId = &g_t11842; // 00411060
<anonymous> * __imp__InitializeCriticalSection = &g_t11858; // 00411064
<anonymous> * __imp__HeapAlloc = &g_t11874; // 00411068
<anonymous> * __imp__HeapAlloc = &g_t11880; // 0041106C
<anonymous> * __imp__GetModuleHandleA = &g_t1188C; // 00411070
<anonymous> * __imp__HeapDestroy = &g_t118A0; // 00411074
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t118AE; // 00411078
<anonymous> * __imp__UnhandledExceptionFilter = &g_t118C8; // 0041107C
<anonymous> * __imp__DeleteCriticalSection = &g_t118E4; // 00411080
<anonymous> * __imp__InterlockedIncrement = &g_t118FC; // 00411084
<anonymous> * __imp__GetVersionExA = &g_t11914; // 00411088
<anonymous> * __imp__LocalAlloc = &g_t11924; // 0041108C
<anonymous> * __imp__GetModuleFileNameA = &g_t11932; // 00411090
<anonymous> * __imp__GetModuleFileNameA = &g_t11948; // 00411094
<anonymous> * __imp__VirtualProtect = &g_t1195E; // 00411098
<anonymous> * __imp__QueryPerformanceCounter = &g_t11970; // 0041109C
<anonymous> * __imp__LoadLibraryW = &g_t1198A; // 004110A0
<anonymous> * __imp__GetVersionExA = &g_t1199A; // 004110A4
<anonymous> * __imp__InterlockedIncrement = &g_t119AA; // 004110A8
<anonymous> * __imp__lstrlenA = &g_t119C2; // 004110AC
<anonymous> * __imp__GetCurrentProcessId = &g_t119CE; // 004110B0
<anonymous> * __imp__CreateThread = &g_t119E4; // 004110B4
<anonymous> * __imp__MultiByteToWideChar = &g_t119F4; // 004110B8
<anonymous> * __imp__GetModuleHandleW = &g_t11A0A; // 004110BC
<anonymous> * __imp__CreateThread = &g_t11A1E; // 004110C0
<anonymous> * __imp__InitializeCriticalSection = &g_t11A2E; // 004110C4
<anonymous> * __imp__VirtualProtect = &g_t11A4A; // 004110C8
<anonymous> * __imp__VirtualProtect = &g_t11A5C; // 004110CC
<anonymous> * __imp__LoadLibraryW = &g_t11A6E; // 004110D0
<anonymous> * __imp__lstrlenA = &g_t11A7E; // 004110D4
<anonymous> * __imp__CreateFileW = &g_t11A8A; // 004110D8
<anonymous> * __imp__lstrlenA = &g_t11A98; // 004110DC
<anonymous> * __imp__DisableThreadLibraryCalls = &g_t11AA4; // 004110E0
<anonymous> * __imp__InterlockedDecrement = &g_t11AC0; // 004110E4
<anonymous> * __imp__VirtualProtect = &g_t11AD8; // 004110E8
<anonymous> * __imp__VirtualProtect = &g_t11AEA; // 004110EC
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t11AFC; // 004110F0
<anonymous> * __imp__VirtualAlloc = &g_t11B16; // 004110F4
<anonymous> * __imp__InterlockedDecrement = &g_t11B26; // 004110F8
<anonymous> * __imp__LocalFree = &g_t11B3E; // 004110FC
<anonymous> * __imp__GetTickCount = &g_t11B4A; // 00411100
<anonymous> * __imp__LoadLibraryW = &g_t11B5A; // 00411104
<anonymous> * __imp__VirtualProtect = &g_t11B6A; // 00411108
<anonymous> * __imp__GetCurrentThreadId = &g_t11B7C; // 0041110C
<anonymous> * __imp__CreateDIBitmap = &g_t11BA0; // 00411114
<anonymous> * __imp__SetBkColor = &g_t11BB2; // 00411118
<anonymous> * __imp__Ellipse = &g_t11BC0; // 0041111C
<anonymous> * __imp__GetBrushOrgEx = &g_t11BCA; // 00411120
<anonymous> * __imp__CreateRectRgn = &g_t11BDA; // 00411124
<anonymous> * __imp__SetWindowExtEx = &g_t11BEA; // 00411128
<anonymous> * __imp__CreateCompatibleDC = &g_t11BFC; // 0041112C
<anonymous> * __imp__CreateFontIndirectA = &g_t11C12; // 00411130
<anonymous> * __imp__GetWindowOrgEx = &g_t11C28; // 00411134
<anonymous> * __imp__Rectangle = &g_t11C3A; // 00411138
<anonymous> * __imp__CreateFontA = &g_t11C46; // 0041113C
<anonymous> * __imp__GetBkColor = &g_t11C54; // 00411140
<anonymous> * __imp__StretchBlt = &g_t11C62; // 00411144
<anonymous> * __imp__SetTextColor = &g_t11C70; // 00411148
<anonymous> * __imp__BitBlt = &g_t11C80; // 0041114C
<anonymous> * __imp__CreatePen = &g_t11C8A; // 00411150
<anonymous> * __imp__Polygon = &g_t11C96; // 00411154
<anonymous> * __imp__GetBkColor = &g_t11CA0; // 00411158
<anonymous> * __imp__SelectObject = &g_t11CAE; // 0041115C
<anonymous> * __imp__GetBkMode = &g_t11CBE; // 00411160
<anonymous> * __imp__GetPixel = &g_t11CCA; // 00411164
<anonymous> * __imp__GetWindowExtEx = &g_t11CD6; // 00411168
<anonymous> * __imp__GetCurrentObject = &g_t11CE8; // 0041116C
<anonymous> * __imp__BitBlt = &g_t11CFC; // 00411170
<anonymous> * __imp__GetBkColor = &g_t11D06; // 00411174
<anonymous> * __imp__Ellipse = &g_t11D14; // 00411178
<anonymous> * __imp__CreateDIBSection = &g_t11D1E; // 0041117C
<anonymous> * __imp__GetPixel = &g_t11D32; // 00411180
<anonymous> * __imp__SetBkColor = &g_t11D3E; // 00411184
<anonymous> * __imp__PatBlt = &g_t11D4C; // 00411188
<anonymous> * __imp__SetTextColor = &g_t11D56; // 0041118C
<anonymous> * __imp__CreateRectRgn = &g_t11D66; // 00411190
<anonymous> * __imp__SetPixel = &g_t11D76; // 00411194
<anonymous> * __imp__CreateFontIndirectA = &g_t11D82; // 00411198
<anonymous> * __imp__SetPixel = &g_t11D98; // 0041119C
<anonymous> * __imp__Rectangle = &g_t11DA4; // 004111A0
<anonymous> * __imp__GetWindowExtEx = &g_t11DB0; // 004111A4
<anonymous> * __imp__CreateRectRgn = &g_t11DC2; // 004111A8
<anonymous> * __imp__SetBkMode = &g_t11DD2; // 004111AC
<anonymous> * __imp__CreateBitmapIndirect = &g_t11DDE; // 004111B0
<anonymous> * __imp__CombineRgn = &g_t11DF6; // 004111B4
<anonymous> * __imp__CreateBitmapIndirect = &g_t11E04; // 004111B8
<anonymous> * __imp__Ellipse = &g_t11E1C; // 004111BC
<anonymous> * __imp__GetBrushOrgEx = &g_t11E26; // 004111C0
<anonymous> * __imp__PatBlt = &g_t11E36; // 004111C4
<anonymous> * __imp__SetBkMode = &g_t11E40; // 004111C8
<anonymous> * __imp__BitBlt = &g_t11E4C; // 004111CC
<anonymous> * __imp__SelectObject = &g_t11E56; // 004111D0
<anonymous> * __imp__SetPixel = &g_t11E66; // 004111D4
<anonymous> * __imp__GetPixel = &g_t11E72; // 004111D8
<anonymous> * __imp__BitBlt = &g_t11E7E; // 004111DC
<anonymous> * __imp__GetWindowExtEx = &g_t11E88; // 004111E0
<anonymous> * __imp__Rectangle = &g_t11E9A; // 004111E4
<anonymous> * __imp__GetBkMode = &g_t11EA6; // 004111E8
<anonymous> * __imp__PatBlt = &g_t11EB2; // 004111EC
<anonymous> * __imp__GetPixel = &g_t11EBC; // 004111F0
<anonymous> * __imp__Rectangle = &g_t11EC8; // 004111F4
<anonymous> * __imp__GetBkMode = &g_t11ED4; // 004111F8
<anonymous> * __imp__GetBkColor = &g_t11EE0; // 004111FC
<anonymous> * __imp__Ellipse = &g_t11EEE; // 00411200
<anonymous> * __imp__CreatePen = &g_t11EF8; // 00411204
<anonymous> * __imp__CreateFontIndirectA = &g_t11F04; // 00411208
<anonymous> * __imp__CreateDIBitmap = &g_t11F1A; // 0041120C
<anonymous> * __imp__GetBkColor = &g_t11F2C; // 00411210
<anonymous> * __imp__SelectObject = &g_t11F3A; // 00411214
<anonymous> * __imp__SetTextColor = &g_t11F4A; // 00411218
<anonymous> * __imp__Rectangle = &g_t11F5A; // 0041121C
<anonymous> * __imp__CreateDIBSection = &g_t11F66; // 00411220
<anonymous> * __imp__StretchBlt = &g_t11F7A; // 00411224
<anonymous> * __imp__Rectangle = &g_t11F88; // 00411228
<anonymous> * __imp__GetSystemMetrics = &g_t11F9E; // 00411230
<anonymous> * __imp__DefWindowProcW = &g_t11FB2; // 00411234
<anonymous> * __imp__PostQuitMessage = &g_t11FC4; // 00411238
<anonymous> * __imp__GetFocus = &g_t11FD6; // 0041123C
<anonymous> * __imp__TranslateMessage = &g_t11FE2; // 00411240
<anonymous> * __imp__DefWindowProcW = &g_t11FF6; // 00411244
<anonymous> * __imp__SetDlgItemTextW = &g_t12008; // 00411248
<anonymous> * __imp__EndPaint = &g_t1201A; // 0041124C
<anonymous> * __imp__DialogBoxParamW = &g_t12026; // 00411250
<anonymous> * __imp__SendDlgItemMessageW = &g_t12038; // 00411254
<anonymous> * __imp__GetDesktopWindow = &g_t1204E; // 00411258
<anonymous> * __imp__SetForegroundWindow = &g_t12062; // 0041125C
<anonymous> * __imp__InvalidateRect = &g_t12078; // 00411260
<anonymous> * __imp__GetSysColor = &g_t1208A; // 00411264
<anonymous> * __imp__PeekMessageW = &g_t12098; // 00411268
<anonymous> * __imp__SetWindowTextW = &g_t120A8; // 0041126C
<anonymous> * __imp__GetFocus = &g_t120BA; // 00411270
<anonymous> * __imp__SetDlgItemTextW = &g_t120C6; // 00411274
<anonymous> * __imp__SetWindowPos = &g_t120D8; // 00411278
<anonymous> * __imp__LoadIconW = &g_t120E8; // 0041127C
<anonymous> * __imp__DefWindowProcW = &g_t120F4; // 00411280
<anonymous> * __imp__LoadCursorW = &g_t12106; // 00411284
<anonymous> * __imp__SendMessageW = &g_t12114; // 00411288
<anonymous> * __imp__CreateWindowExW = &g_t12124; // 0041128C
<anonymous> * __imp__SendMessageW = &g_t12136; // 00411290
<anonymous> * __imp__SetWindowTextW = &g_t12146; // 00411294
<anonymous> * __imp__DialogBoxParamW = &g_t12158; // 00411298
<anonymous> * __imp__EndPaint = &g_t1216A; // 0041129C
<anonymous> * __imp__CreateWindowExW = &g_t12176; // 004112A0
<anonymous> * __imp__DefWindowProcW = &g_t12188; // 004112A4
<anonymous> * __imp__GetDesktopWindow = &g_t1219A; // 004112A8
<anonymous> * __imp__DestroyWindow = &g_t121AE; // 004112AC
<anonymous> * __imp__SetTimer = &g_t121BE; // 004112B0
<anonymous> * __imp__SetWindowPos = &g_t121CA; // 004112B4
<anonymous> * __imp__GetSysColor = &g_t121DA; // 004112B8
<anonymous> * __imp__SendDlgItemMessageW = &g_t121E8; // 004112BC
<anonymous> * __imp__DialogBoxParamW = &g_t121FE; // 004112C0
<anonymous> * __imp__LoadCursorW = &g_t12210; // 004112C4
<anonymous> * __imp__SendMessageW = &g_t1221E; // 004112C8
<anonymous> * __imp__EndPaint = &g_t1222E; // 004112CC
<anonymous> * __imp__KillTimer = &g_t1223A; // 004112D0
<anonymous> * __imp__LoadCursorW = &g_t12246; // 004112D4
<anonymous> * __imp__EndDialog = &g_t12254; // 004112D8
<anonymous> * __imp__SetForegroundWindow = &g_t12260; // 004112DC
<anonymous> * __imp__SetWindowPos = &g_t12276; // 004112E0
<anonymous> * __imp__InvalidateRect = &g_t12286; // 004112E4
<anonymous> * __imp__DispatchMessageW = &g_t12298; // 004112E8
<anonymous> * __imp__PostQuitMessage = &g_t122AC; // 004112EC
<anonymous> * __imp__IsDlgButtonChecked = &g_t122BE; // 004112F0
<anonymous> * __imp__SendDlgItemMessageW = &g_t122D4; // 004112F4
<anonymous> * __imp__SetWindowPos = &g_t122EA; // 004112F8
<anonymous> * __imp__SetCursor = &g_t122FA; // 004112FC
<anonymous> * __imp__SetDlgItemTextW = &g_t12306; // 00411300
<anonymous> * __imp__ShowWindow = &g_t12318; // 00411304
<anonymous> * __imp__GetClientRect = &g_t12326; // 00411308
<anonymous> * __imp__DialogBoxParamW = &g_t12336; // 0041130C
<anonymous> * __imp__GetClientRect = &g_t12348; // 00411310
<anonymous> * __imp__SendMessageW = &g_t12358; // 00411314
<anonymous> * __imp__KillTimer = &g_t12368; // 00411318
<anonymous> * __imp__ReleaseDC = &g_t12374; // 0041131C
<anonymous> * __imp__PostMessageW = &g_t12380; // 00411320
<anonymous> * __imp__PostQuitMessage = &g_t12390; // 00411324
word32 g_dw411380 = 0x000116AC; // 00411380
word32 g_dw411384 = 0x000116BE; // 00411384
word32 g_dw411388 = 0x000116CE; // 00411388
word32 g_dw41138C = 0x000116DE; // 0041138C
word32 g_dw411390 = 0x000116EA; // 00411390
word32 g_dw411394 = 0x000116F6; // 00411394
word32 g_dw411398 = 0x0001170E; // 00411398
word32 g_dw41139C = 0x00011724; // 0041139C
word32 g_dw4113A0 = 0x00011734; // 004113A0
word32 g_dw4113A4 = 0x0001174A; // 004113A4
word32 g_dw4113A8 = 0x00011756; // 004113A8
word32 g_dw4113AC = 0x00011762; // 004113AC
word32 g_dw4113B0 = 0x0001177A; // 004113B0
word32 g_dw4113B4 = 0x0001178C; // 004113B4
word32 g_dw4113B8 = 0x00011794; // 004113B8
word32 g_dw4113BC = 0x000117AA; // 004113BC
word32 g_dw4113C0 = 0x000117B8; // 004113C0
word32 g_dw4113C4 = 0x000117C4; // 004113C4
word32 g_dw4113C8 = 0x000117DC; // 004113C8
word32 g_dw4113CC = 0x000117E8; // 004113CC
word32 g_dw4113D0 = 0x000117F8; // 004113D0
word32 g_dw4113D4 = 0x00011808; // 004113D4
word32 g_dw4113D8 = 0x00011816; // 004113D8
word32 g_dw4113DC = 0x0001182C; // 004113DC
word32 g_dw4113E0 = 0x00011842; // 004113E0
word32 g_dw4113E4 = 0x00011858; // 004113E4
word32 g_dw4113E8 = 0x00011874; // 004113E8
word32 g_dw4113EC = 0x00011880; // 004113EC
word32 g_dw4113F0 = 0x0001188C; // 004113F0
word32 g_dw4113F4 = 0x000118A0; // 004113F4
word32 g_dw4113F8 = 0x000118AE; // 004113F8
word32 g_dw4113FC = 0x000118C8; // 004113FC
word32 g_dw411400 = 0x000118E4; // 00411400
word32 g_dw411404 = 0x000118FC; // 00411404
word32 g_dw411408 = 0x00011914; // 00411408
word32 g_dw41140C = 0x00011924; // 0041140C
word32 g_dw411410 = 0x00011932; // 00411410
word32 g_dw411414 = 0x00011948; // 00411414
word32 g_dw411418 = 0x0001195E; // 00411418
word32 g_dw41141C = 0x00011970; // 0041141C
word32 g_dw411420 = 0x0001198A; // 00411420
word32 g_dw411424 = 0x0001199A; // 00411424
word32 g_dw411428 = 0x000119AA; // 00411428
word32 g_dw41142C = 0x000119C2; // 0041142C
word32 g_dw411430 = 0x000119CE; // 00411430
word32 g_dw411434 = 0x000119E4; // 00411434
word32 g_dw411438 = 0x000119F4; // 00411438
word32 g_dw41143C = 72202; // 0041143C
word32 g_dw411440 = 72222; // 00411440
word32 g_dw411444 = 0x00011A2E; // 00411444
word32 g_dw411448 = 0x00011A4A; // 00411448
word32 g_dw41144C = 0x00011A5C; // 0041144C
word32 g_dw411450 = 0x00011A6E; // 00411450
word32 g_dw411454 = 0x00011A7E; // 00411454
word32 g_dw411458 = 0x00011A8A; // 00411458
word32 g_dw41145C = 0x00011A98; // 0041145C
word32 g_dw411460 = 0x00011AA4; // 00411460
word32 g_dw411464 = 0x00011AC0; // 00411464
word32 g_dw411468 = 0x00011AD8; // 00411468
word32 g_dw41146C = 0x00011AEA; // 0041146C
word32 g_dw411470 = 72444; // 00411470
word32 g_dw411474 = 0x00011B16; // 00411474
word32 g_dw411478 = 0x00011B26; // 00411478
word32 g_dw41147C = 0x00011B3E; // 0041147C
word32 g_dw411480 = 72522; // 00411480
word32 g_dw411484 = 0x00011B5A; // 00411484
word32 g_dw411488 = 0x00011B6A; // 00411488
word32 g_dw41148C = 72572; // 0041148C
word32 g_dw411494 = 0x00011BA0; // 00411494
word32 g_dw411498 = 0x00011BB2; // 00411498
word32 g_dw41149C = 0x00011BC0; // 0041149C
word32 g_dw4114A0 = 0x00011BCA; // 004114A0
word32 g_dw4114A4 = 72666; // 004114A4
word32 g_dw4114A8 = 0x00011BEA; // 004114A8
word32 g_dw4114AC = 72700; // 004114AC
word32 g_dw4114B0 = 72722; // 004114B0
word32 g_dw4114B4 = 72744; // 004114B4
word32 g_dw4114B8 = 72762; // 004114B8
word32 g_dw4114BC = 72774; // 004114BC
word32 g_dw4114C0 = 72788; // 004114C0
word32 g_dw4114C4 = 0x00011C62; // 004114C4
word32 g_dw4114C8 = 0x00011C70; // 004114C8
word32 g_dw4114CC = 0x00011C80; // 004114CC
word32 g_dw4114D0 = 0x00011C8A; // 004114D0
word32 g_dw4114D4 = 0x00011C96; // 004114D4
word32 g_dw4114D8 = 0x00011CA0; // 004114D8
word32 g_dw4114DC = 72878; // 004114DC
word32 g_dw4114E0 = 0x00011CBE; // 004114E0
word32 g_dw4114E4 = 0x00011CCA; // 004114E4
word32 g_dw4114E8 = 0x00011CD6; // 004114E8
word32 g_dw4114EC = 0x00011CE8; // 004114EC
word32 g_dw4114F0 = 0x00011CFC; // 004114F0
word32 g_dw4114F4 = 0x00011D06; // 004114F4
word32 g_dw4114F8 = 0x00011D14; // 004114F8
word32 g_dw4114FC = 0x00011D1E; // 004114FC
word32 g_dw411500 = 0x00011D32; // 00411500
word32 g_dw411504 = 0x00011D3E; // 00411504
word32 g_dw411508 = 0x00011D4C; // 00411508
word32 g_dw41150C = 0x00011D56; // 0041150C
word32 g_dw411510 = 0x00011D66; // 00411510
word32 g_dw411514 = 0x00011D76; // 00411514
word32 g_dw411518 = 0x00011D82; // 00411518
word32 g_dw41151C = 0x00011D98; // 0041151C
word32 g_dw411520 = 0x00011DA4; // 00411520
word32 g_dw411524 = 0x00011DB0; // 00411524
word32 g_dw411528 = 0x00011DC2; // 00411528
word32 g_dw41152C = 0x00011DD2; // 0041152C
word32 g_dw411530 = 0x00011DDE; // 00411530
word32 g_dw411534 = 0x00011DF6; // 00411534
word32 g_dw411538 = 0x00011E04; // 00411538
word32 g_dw41153C = 0x00011E1C; // 0041153C
word32 g_dw411540 = 0x00011E26; // 00411540
word32 g_dw411544 = 0x00011E36; // 00411544
word32 g_dw411548 = 0x00011E40; // 00411548
word32 g_dw41154C = 0x00011E4C; // 0041154C
word32 g_dw411550 = 0x00011E56; // 00411550
word32 g_dw411554 = 0x00011E66; // 00411554
word32 g_dw411558 = 73330; // 00411558
word32 g_dw41155C = 0x00011E7E; // 0041155C
word32 g_dw411560 = 0x00011E88; // 00411560
word32 g_dw411564 = 73370; // 00411564
word32 g_dw411568 = 0x00011EA6; // 00411568
word32 g_dw41156C = 0x00011EB2; // 0041156C
word32 g_dw411570 = 0x00011EBC; // 00411570
word32 g_dw411574 = 0x00011EC8; // 00411574
word32 g_dw411578 = 0x00011ED4; // 00411578
word32 g_dw41157C = 0x00011EE0; // 0041157C
word32 g_dw411580 = 0x00011EEE; // 00411580
word32 g_dw411584 = 0x00011EF8; // 00411584
word32 g_dw411588 = 0x00011F04; // 00411588
word32 g_dw41158C = 0x00011F1A; // 0041158C
word32 g_dw411590 = 0x00011F2C; // 00411590
word32 g_dw411594 = 0x00011F3A; // 00411594
word32 g_dw411598 = 0x00011F4A; // 00411598
word32 g_dw41159C = 0x00011F5A; // 0041159C
word32 g_dw4115A0 = 0x00011F66; // 004115A0
word32 g_dw4115A4 = 0x00011F7A; // 004115A4
word32 g_dw4115A8 = 0x00011F88; // 004115A8
word32 g_dw4115B0 = 0x00011F9E; // 004115B0
word32 g_dw4115B4 = 0x00011FB2; // 004115B4
word32 g_dw4115B8 = 0x00011FC4; // 004115B8
word32 g_dw4115BC = 0x00011FD6; // 004115BC
word32 g_dw4115C0 = 0x00011FE2; // 004115C0
word32 g_dw4115C4 = 0x00011FF6; // 004115C4
word32 g_dw4115C8 = 73736; // 004115C8
word32 g_dw4115CC = 0x0001201A; // 004115CC
word32 g_dw4115D0 = 73766; // 004115D0
word32 g_dw4115D4 = 73784; // 004115D4
word32 g_dw4115D8 = 0x0001204E; // 004115D8
word32 g_dw4115DC = 0x00012062; // 004115DC
word32 g_dw4115E0 = 73848; // 004115E0
word32 g_dw4115E4 = 73866; // 004115E4
word32 g_dw4115E8 = 73880; // 004115E8
word32 g_dw4115EC = 0x000120A8; // 004115EC
word32 g_dw4115F0 = 0x000120BA; // 004115F0
word32 g_dw4115F4 = 0x000120C6; // 004115F4
word32 g_dw4115F8 = 73944; // 004115F8
word32 g_dw4115FC = 0x000120E8; // 004115FC
word32 g_dw411600 = 73972; // 00411600
word32 g_dw411604 = 0x00012106; // 00411604
word32 g_dw411608 = 0x00012114; // 00411608
word32 g_dw41160C = 0x00012124; // 0041160C
word32 g_dw411610 = 0x00012136; // 00411610
word32 g_dw411614 = 0x00012146; // 00411614
word32 g_dw411618 = 0x00012158; // 00411618
word32 g_dw41161C = 0x0001216A; // 0041161C
word32 g_dw411620 = 0x00012176; // 00411620
word32 g_dw411624 = 0x00012188; // 00411624
word32 g_dw411628 = 0x0001219A; // 00411628
word32 g_dw41162C = 0x000121AE; // 0041162C
word32 g_dw411630 = 74174; // 00411630
word32 g_dw411634 = 0x000121CA; // 00411634
word32 g_dw411638 = 0x000121DA; // 00411638
word32 g_dw41163C = 0x000121E8; // 0041163C
word32 g_dw411640 = 0x000121FE; // 00411640
word32 g_dw411644 = 0x00012210; // 00411644
word32 g_dw411648 = 0x0001221E; // 00411648
word32 g_dw41164C = 0x0001222E; // 0041164C
word32 g_dw411650 = 0x0001223A; // 00411650
word32 g_dw411654 = 0x00012246; // 00411654
word32 g_dw411658 = 0x00012254; // 00411658
word32 g_dw41165C = 0x00012260; // 0041165C
word32 g_dw411660 = 0x00012276; // 00411660
word32 g_dw411664 = 74374; // 00411664
word32 g_dw411668 = 0x00012298; // 00411668
word32 g_dw41166C = 0x000122AC; // 0041166C
word32 g_dw411670 = 0x000122BE; // 00411670
word32 g_dw411674 = 0x000122D4; // 00411674
word32 g_dw411678 = 74474; // 00411678
word32 g_dw41167C = 0x000122FA; // 0041167C
word32 g_dw411680 = 0x00012306; // 00411680
word32 g_dw411684 = 0x00012318; // 00411684
word32 g_dw411688 = 0x00012326; // 00411688
word32 g_dw41168C = 0x00012336; // 0041168C
word32 g_dw411690 = 0x00012348; // 00411690
word32 g_dw411694 = 74584; // 00411694
word32 g_dw411698 = 74600; // 00411698
word32 g_dw41169C = 0x00012374; // 0041169C
word32 g_dw4116A0 = 74624; // 004116A0
word32 g_dw4116A4 = 74640; // 004116A4
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040C6AE: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	esp = fp;
	Top = null;
	v4 = (edx & 0x01 << 0x20 - 0x01) != 0x00;
	edx = __rol<word32,byte>(edx, 0x01);
	&ch.u5->u0 = (byte) ch + 0x0F;
	&SCZO.u5->u0 = cond(ch);
	&bh.u5->u0 = &(C.u3 + ((byte) bh + 24) /8 0x0A)->u0;
	edi >>= 0x09;
	cl -= bh;
	bl <<= cl;
	eax &= ebx;
	edx >>= cl;
	&SCZO.u5->u0 = cond(edx);
	v17 = (ebx & 0x01 << 0x15) != 0x00;
	ebx = __rcr<word32,byte>(ebx, 0x15, C);
	edi = -edi;
	edi += ecx;
	al |= dl;
	SZ = cond(al);
	O = false;
	C.u0 = false;
	edi.u0 = ~0x05095D94;
	dl = ~dl;
	if (Test(EQ,Z))
	{
l0040C321:
		esi >>= 0x1C;
		C = ch != 0x00;
		ch = -ch;
		edx = edx + ebx + C;
		edx >>= 0x1A;
		ecx |= eax;
		C.u0 = false;
		v33 = (esi & 0x01 << 0x02) != 0x00;
		esi = __rcr<word32,byte>(esi, 0x02, C);
		C = v33;
		ah = ah - 0x5A - C;
		esi -= ebx;
		&SCZO.u5->u0 = cond(esi);
		goto l0040C335;
	}
	eax = eax;
	if (Test(NE,Z))
		goto l0040C321;
	v23 = ecx.u7->dw519F9FBC | 0x1BD1C126;
	ecx.u7->dw519F9FBC = v23;
	SZ = cond(ecx.u7->dw519F9FBC);
	O = false;
	C.u0 = false;
l0040C6E7:
	cl = ch;
	edx >>= 0x1A;
	&SCZO.u5->u0 = cond(edx);
	v24 = (bh & 0x01 << cl) != 0x00;
	bh = __ror<byte,byte>(bh, cl);
	v25 = (ecx & 0x01 << 0x20 - 0x08) != 0x00;
	ecx = __rol<word32,byte>(ecx, 0x08);
	C = v25;
	v26 = (edx & 0x01 << 0x1E) != 0x00;
	edx = __rcr<word32,byte>(edx, 0x1E, C);
	C = v26;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			ebp.u0 = 2203336191;
			edx = edx + ebx + C;
			cl = -cl;
			eax >>= 0x04;
			v29 = (ecx & 0x01 << 0x09) != 0x00;
			ecx = __ror<word32,byte>(ecx, 0x09);
			esi = ebx;
			v31 = (edx & 0x01 << 0x1C) != 0x00;
			edx = __ror<word32,byte>(edx, 0x1C);
			al = bh;
			v32 = (ecx & 0x01 << 0x20 - 0x1B) != 0x00;
			ecx = __rol<word32,byte>(ecx, 0x1B);
			ecx &= ebx;
			SZ = cond(ecx);
			O = false;
			C.u0 = false;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					al = __in<byte>(0xB2);
					if (Test(OV,O))
						__syscall<byte>(0x04);
					eax = *esp;
					&esp.u5->u0 = (word32) esp + 4;
					v38 = (bl & 0x01 << cl) != 0x00;
					bl = __rcr<byte,byte>(bl, cl, C);
					C = v38;
l0040C736:
					v48 = (ecx & 0x01 << cl) != 0x00;
					ecx = __ror<word32,byte>(ecx, cl);
					v49 = (ecx & 0x01 << 0x07) != 0x00;
					ecx = __ror<word32,byte>(ecx, 0x07);
					&edi.u5->u0 = (byte) edi.u0 + 547967838;
					ch -= dh;
					v50 = (bh & 0x01 << 0x08 - cl) != 0x00;
					bh = __rol<byte,byte>(bh, cl);
					v51 = (ebx & 0x01 << 0x20 - 0x0D) != 0x00;
					ebx = __rol<word32,byte>(ebx, 0x0D);
					v52 = (esi & 0x01 << 0x20 - 0x12) != 0x00;
					esi = __rol<word32,byte>(esi, 0x12);
					dh = dh ^ 44;
					SZ = cond(dh);
					O = false;
					C.u0 = false;
					if (Test(NE,Z))
					{
						eax = eax;
						if (Test(EQ,Z))
						{
							al = al ^ ~0x50;
							esp -= 2;
							*esp = es;
							int3();
							&SCZO.u5->u0 = cond(eax - *edi);
							&edi.u5->u0 = (word32) edi + 4;
							ecx.u0 = 0x8005F1C1;
							v66 = *((byte) ebp.u0 + 2) >> cl;
							((byte) ebp.u0 + 2)->u1 = v66;
							&SCZO.u5->u0 = cond(v66);
l0040C768:
							v67 = (ebx & 0x01 << 0x20 - cl) != 0x00;
							ebx = __rcl<word32,byte>(ebx, cl, C);
							C = v67;
							Top -= (struct Eq_1222 *) 1;
							Top->r0000 = (real64) *ebx;
							Top->r0000 -= (real64) *edx;
						}
					}
					cl.u0 = 0x34;
					ch = ch + bl + C;
					&SCZO.u5->u0 = cond(ch);
l0040C3DF:
					bh += dl;
					ch = cl;
					dh <<= cl;
					&SCZO.u5->u0 = cond(edi - 4045115077);
					if (Test(EQ,Z))
					{
						dh = dh - ch - C;
						&SCZO.u5->u0 = cond(dh);
						v92 = (edx & 0x01 << 0x19) != 0x00;
						edx = __ror<word32,byte>(edx, 0x19);
						C = v92;
						esi = esi - ebx - C;
						C = eax != 0x00;
						eax = -eax;
						v93 = (bh & 0x01 << cl) != 0x00;
						bh = __rcr<byte,byte>(bh, cl, C);
						al -= 0x1D;
						&SCZO.u5->u0 = cond(al);
						v94 = (ebx & 0x01 << 0x11) != 0x00;
						ebx = __rcr<word32,byte>(ebx, 0x11, C);
						C = v94;
						v95 = (ebx & 0x01 << 0x20 - cl) != 0x00;
						ebx = __rcl<word32,byte>(ebx, cl, C);
						v96 = (edi & 0x01 << 0x20 - 0x04) != 0x00;
						edi = __rol<word32,byte>(edi, 0x04);
						v97 = (edi & 0x01 << 0x20 - cl) != 0x00;
						edi = __rol<word32,byte>(edi, cl);
						C = v97;
						bl = bl - cl - C;
						&SCZO.u5->u0 = cond(bl);
						v98 = (ecx & 0x01 << 0x17) != 0x00;
						ecx = __rcr<word32,byte>(ecx, 0x17, C);
						v99 = (cl & 0x01 << cl) != 0x00;
						cl = __ror<byte,byte>(cl, cl);
						C = v99;
						eax.u0 = 2045755127;
						if (Test(NE,Z))
						{
							eax = eax;
							if (Test(EQ,Z))
							{
								&ecx.u5->u0 = (byte) ecx.u0 + 1;
								SZO = cond(ecx);
								if (Test(UGT,CZ))
									return;
								Top->r0000 = Top->r0001 - Top->r0000;
l0040C630:
								v104 = edi;
								edi = eax;
								eax = v104;
								D = false;
							}
						}
						v106 = (edx & 0x01 << 0x20 - 0x1B) != 0x00;
						edx = __rol<word32,byte>(edx, 0x1B);
						dl -= al;
						ebx = ebx ^ edx;
						v107 = (dl & 0x01 << cl) != 0x00;
						dl = __ror<byte,byte>(dl, cl);
						dl = dl ^ ~0x12;
						&ebx.u5->u0 = (word32) ebx + 1;
						v108 = (bh & 0x01 << cl) != 0x00;
						bh = __ror<byte,byte>(bh, cl);
						edx = -edx;
						bl = bl ^ 0xAC;
						SZ = cond(bl);
						O = false;
						C.u0 = false;
						mm0 = (word64) eax;
						ecx = esi;
						ch >>= cl;
						ebx = ebx ^ edi;
						edi <<= 0x1A;
						ch |= cl;
						ebx >>= cl;
						&SCZO.u5->u0 = cond(ebx);
						dl = dl - 0x1D - C;
						bh <<= cl;
						esi -= ebx;
						&SCZO.u5->u0 = cond(esi);
						ch = ch - dh - C;
						v116 = (esi & 0x01 << 0x20 - cl) != 0x00;
						esi = __rol<word32,byte>(esi, cl);
						C = v116;
						--edx;
						SZO = cond(edx);
						ecx = (word32) mm0;
						edi |= eax;
						ebx -= edi;
						&SCZO.u5->u0 = cond(ebx);
						edi = edi + esi + C;
						esi >>= 0x1E;
						dh &= bh;
						edi <<= 0x1E;
						&SCZO.u5->u0 = cond(edi);
						bl = bl + dh + C;
						ah = ah ^ 0x04;
						C.u0 = false;
						al = al + ah + C;
						&SCZO.u5->u0 = cond(al);
						ah = ah + bh + C;
						ebx -= eax;
						&SCZO.u5->u0 = cond(ebx);
						goto l0040C630;
					}
l0040C335:
					bh <<= cl;
					&SCZO.u5->u0 = cond(bh);
					esi >>= 0x08;
					SCZ = cond(esi);
					v39 = (al & 0x01 << 0x08 - cl) != 0x00;
					al = __rol<byte,byte>(al, cl);
					ecx <<= cl;
					ebx >>= cl;
					SCZ = cond(ebx);
					v40 = (ecx & 0x01 << cl) != 0x00;
					ecx = __rcr<word32,byte>(ecx, cl, C);
					v41 = (esi & 0x01 << 0x20 - 0x13) != 0x00;
					esi = __rol<word32,byte>(esi, 0x13);
					v42 = (ebx & 0x01 << 0x02) != 0x00;
					ebx = __ror<word32,byte>(ebx, 0x02);
					eax |= edi;
					C.u0 = false;
					v43 = (esi & 0x01 << cl) != 0x00;
					esi = __rcr<word32,byte>(esi, cl, C);
					dl &= ah;
					C.u0 = false;
					--ch;
					SZO = cond(ch);
					v44 = (ebx & 0x01 << 0x20 - cl) != 0x00;
					ebx = __rcl<word32,byte>(ebx, cl, C);
					C = v44;
					cl -= 0x46;
					ah -= 0x54;
					--ebx;
					v54 = (edx & 0x01 << 0x20 - cl) != 0x00;
					edx = __rol<word32,byte>(edx, cl);
					al += dh;
					&SCZO.u5->u0 = cond(al);
					v55 = (esi & 0x01 << cl) != 0x00;
					esi = __rcr<word32,byte>(esi, cl, C);
					--esi;
					edx = edx ^ esi;
					v56 = (ecx & 0x01 << 0x20 - 0x15) != 0x00;
					ecx = __rol<word32,byte>(ecx, 0x15);
					dl |= ch;
					edx >>= cl;
					ch = ch ^ 0xC6;
					SZ = cond(ch);
					O = false;
					v57 = (eax & 0x01 << 0x05) != 0x00;
					eax = __ror<word32,byte>(eax, 0x05);
					C = v57;
					v68 = (ebx & 0x01 << 0x20 - cl) != 0x00;
					ebx = __rcl<word32,byte>(ebx, cl, C);
					ch >>= cl;
					esi <<= 0x0E;
					&SCZO.u5->u0 = cond(esi);
					goto l0040C103;
				}
			}
			edx += ecx;
			v111 = (eax & 0x01 << cl) != 0x00;
			eax = __ror<word32,byte>(eax, cl);
			ebx >>= 0x1D;
			bl.u0 = 0x87;
			v112 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			al -= 0x41;
			&SCZO.u5->u0 = cond(al);
			v113 = (esi & 0x01 << cl) != 0x00;
			esi = __rcr<word32,byte>(esi, cl, C);
			edx &= ecx;
			C.u0 = false;
			ch = ch - cl - C;
			dh <<= cl;
			&SCZO.u5->u0 = cond(dh);
			v114 = (eax & 0x01 << 0x20 - 0x0A) != 0x00;
			eax = __rol<word32,byte>(eax, 0x0A);
			C = v114;
			edx = edx ^ eax;
			dh |= ~0x02;
			SZ = cond(dh);
			O = false;
			C.u0 = false;
		}
	}
	dh += ch;
	v36 = (ecx & 0x01 << cl) != 0x00;
	ecx = __ror<word32,byte>(ecx, cl);
	ecx >>= cl;
	ch -= cl;
	edx -= edi;
	dl -= 66;
	ecx >>= 0x18;
	ebx = ebx ^ eax;
	esi >>= 0x10;
	&SCZO.u5->u0 = cond(esi);
	edx = edx + esi + C;
	&SCZO.u5->u0 = cond(edx);
	if (Test(EQ,Z))
	{
l0040C734:
		v109 = (bl & 0x01 << cl) != 0x00;
		bl = __rcr<byte,byte>(bl, cl, C);
		C = v109;
		goto l0040C736;
	}
	eax = eax;
	if (Test(NE,Z))
		goto l0040C734;
	((word32) (esi - 3) + eax * 0x08)->u0 = 0x8A;
	Top->r0000 += (real64) *edx;
	if (Test(OV,O))
		__syscall<byte>(0x04);
	v45 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	ecx |= eax;
	ch -= 0x89;
	eax = -eax;
	dh -= 0x17;
	&SCZO.u5->u0 = cond(dh);
	&bl.u5->u0 = (bool) C.u0 + ((byte) bl.u0 + 0x0095);
	&SCZO.u5->u0 = cond(bl);
	ah >>= cl;
	SCZ = cond(ah);
	if (Test(EQ,Z))
	{
l0040C762:
		ecx <<= 0x05;
		&SCZO.u5->u0 = cond(ecx);
		&dl.u5->u0 = (bool) C.u0 + ((byte) dl + 0x006D);
		&SCZO.u5->u0 = cond(dl);
		goto l0040C768;
	}
	eax = eax;
	if (Test(NE,Z))
		goto l0040C762;
	v46 = (dl & 0x01 << 0x08 - 0x01) != 0x00;
	dl = __rol<byte,byte>(dl, 0x01);
	esp -= 4;
	*esp = edi;
	--ecx;
	eax -= 3524912833;
	&SCZO.u5->u0 = cond(eax);
l0040C4C7:
	__sti();
	&ebx.u5->u0 = (word32) ebx + 1;
	esi = -esi;
	v47 = (edi & 0x01 << 0x20 - 0x1A) != 0x00;
	edi = __rol<word32,byte>(edi, 0x1A);
	ch |= ah;
	--ecx;
	bh &= 0x6B;
	bl = ~bl;
	ecx <<= 0x08;
	&SCZO.u5->u0 = cond(ecx);
	fn0040D786();
	es = *esp;
	&esp.u5->u0 = &esp.u7->b0002;
	ax = __aam(al);
	__out<byte>(0xB4, al);
	eax = *esi;
	&esi.u5->u0 = (word32) esi + 4;
	if (Test(NS,S))
	{
		al.u0 = ~0x0C;
		if (Test(NS,S))
		{
			ebp.u0 = 3012728013;
			v60 = Mem0[eax + 0x00:byte] + dh;
			*eax = v60;
			v61 = *((byte) ebp.u0 - 4) ^ dl;
			&((byte) ebp.u0 - 4)->u5->u0 = v61;
			SZ = cond(*((byte) ebp.u0 - 4));
			Top->r0000 *= (real64) esi.u7->rA5CA85;
			FPUF.u0 = cond(Top->r0005 - Top->r0000);
			Top = (struct Eq_5 *) &Top->r0000;
			ebx = ebx ^ (ebx.u7)->dwFFFFFFB0;
			v63 = *eax ^ dh;
			*eax = v63;
			SZ = cond(*eax);
			v64 = ebx.u7->b0011 ^ ch;
			ebx.u7->b0011 = v64;
			SZ = cond(ebx.u7->b0011);
			bl.u0 = 0x5B;
			esi &= ebx.u7->dw5BB3635B;
			*(union Eq_3 *) ~0x4F855D02 = al;
			v65 = *eax ^ dh;
			*eax = v65;
			SZ = cond(*eax);
			O = false;
			C.u0 = false;
			&eax.u5->u0 = (int32) ax;
			esp = *esp;
			&esp.u5->u0 = (word32) esp + 4;
			*(union Eq_3 *) ~0x4C5CA44C = al;
			ebx = *esp;
			&esp.u5->u0 = (word32) esp + 4;
			*(union Eq_3 *) 10654461 = al;
			v71 = *eax ^ dh;
			*eax = v71;
			SZ = cond(*eax);
			O = false;
			C.u0 = false;
			if (Test(EQ,Z))
				bl.u0 = 252;
		}
		else
		{
			v70 = edx;
			edx = eax;
			eax = v70;
			*(union Eq_3 *) 0x74303000 = al;
			al = *esi;
			&esi.u5->u0 = (word32) esi + 1;
		}
		&eax.u5->u0 = (bool) C.u0 + ((word32) eax + 656164655);
		v72 = edx.u7->dw30309090 ^ esp;
		edx.u7->dw30309090 = v72;
		SZ = cond(edx.u7->dw30309090);
		C.u0 = false;
		v73 = ebx[edi * 0x08] + esp + C;
		&((word32) ebx + edi * 0x08)->u5->u0 = v73;
		eax = eax ^ eax;
		C.u0 = false;
		eax = *esp;
		&esp.u5->u0 = (word32) esp + 4;
		al = *(union Eq_3 *) 0x92863030;
		v74 = esp;
		esp = eax;
		eax = v74;
		v75 = Mem0[eax + 0x00:byte] + dh + C;
		*eax = v75;
		v76 = edx.u7->b30305057 ^ ah;
		edx.u7->b30305057 = v76;
		SZ = cond(edx.u7->b30305057);
		O = false;
		C.u0 = false;
		if (Test(LE,SZO))
		{
			&eax.u5->u0 = (int32) ax;
			&SCZO.u5->u0 = cond(eax - *edi.u0);
			&edi.u5->u0 = (byte) edi.u0 + 4;
			eax.u0 = 4222820956;
			&SCZO.u5->u0 = cond(eax - *edi);
			&edi.u5->u0 = (word32) edi + 4;
			bl.u0 = ~0x04;
		}
		else
		{
			v77 = (eax.u7->tFFFFFFEC.u0 & 0x01 << 0x00) != 0x00;
			eax.u7->tFFFFFFEC.u0 = (int8) __rcr<byte,byte>(eax.u7->tFFFFFFEC.u0, 0x00, C);
			v78 = *eax ^ dh;
			*eax = v78;
			SZ = cond(*eax);
			*(union Eq_3 *) 0x30305046 = al;
			v79 = edx;
			edx = eax;
			eax = v79;
			Top->r0000 += (real64) *eax;
			v80 = *eax ^ dh;
			*eax = v80;
			SZ = cond(*eax);
			O = false;
			C.u0 = false;
			esp = *esp;
			&esp.u5->u0 = (word32) esp + 4;
		}
	}
	&ecx.u0->u5->u0 = (int32) Top->r0000;
	Top = (struct Eq_5 *) &Top->r0001;
	while (true)
	{
		v88 = (cl & 0x01 << cl) != 0x00;
		cl = __rcr<byte,byte>(cl, cl, C);
		ebx = -ebx;
		bh -= ch;
		ecx >>= cl;
		edi &= eax;
		bl = -bl;
		ch |= bh;
		SZ = cond(ch);
		O = false;
		C.u0 = false;
		cl = cl - 100 - C;
		bh = ~bh;
		esi = esi ^ edx;
		&edx.u5->u0 = (word32) edx + 1;
		v89 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rol<byte,byte>(bl, cl);
		C = v89;
		v90 = (bh & 0x01 << 0x08 - cl) != 0x00;
		bh = __rcl<byte,byte>(bh, cl, C);
		ecx >>= 0x02;
		bl = bl ^ 0xE0;
		bh <<= cl;
		&SCZO.u5->u0 = cond(bh);
		v91 = (bl & 0x01 << cl) != 0x00;
		bl = __ror<byte,byte>(bl, cl);
		C = v91;
		v101 = (bh & 0x01 << 0x08 - cl) != 0x00;
		bh = __rol<byte,byte>(bh, cl);
		C = v101;
		v102 = (bh & 0x01 << 0x08 - cl) != 0x00;
		bh = __rcl<byte,byte>(bh, cl, C);
		C = v102;
		ecx = esi;
		v103 = (edi & 0x01 << 0x20 - 0x17) != 0x00;
		edi = __rcl<word32,byte>(edi, 0x17, C);
		C = v103;
		esi = esi + edx + C;
		ch.u0 = ~0x13;
		--ecx;
		ch = -ch;
		&bl.u5->u0 = (byte) bl.u0 + 1;
		cl = cl ^ ah;
		bl <<= cl;
		bh &= ah;
		SZ = cond(bh);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				eax -= 284657042;
				&SCZO.u5->u0 = cond(*edx - esi);
				goto l0040C666;
			}
		}
		ch = ~ch;
		bl &= ch;
		ecx -= eax;
		ch -= dh;
		ecx |= ebx;
		ch <<= cl;
		ch -= 0x24;
		&SCZO.u5->u0 = cond(ch);
		&SCZO.u5->u0 = cond(edx - 20090611);
		if (Test(EQ,Z))
		{
			bl = bl - 99 - C;
			--al;
			ah <<= cl;
			&SCZO.u5->u0 = cond(ah);
			v110 = (edi & 0x01 << 0x09) != 0x00;
			edi = __rcr<word32,byte>(edi, 0x09, C);
			ecx = ecx ^ edx;
			edx <<= cl;
			edi <<= cl;
			&SCZO.u5->u0 = cond(edi);
			cl = ~cl;
			ebx >>= 0x05;
			SCZ = cond(ebx);
			return;
		}
		cl = cl ^ 244;
		SZ = cond(cl);
		O = false;
		C.u0 = false;
		cl = cl ^ ch;
		C.u0 = false;
		ebx = ebx + edx + C;
		&SCZO.u5->u0 = cond(ebx);
		&bh.u5->u0 = (byte) bh + 1;
		bl.u0 = 0x92;
		cl = cl - 181 - C;
		cl >>= cl;
		&SCZO.u5->u0 = cond(cl);
		ch = ch + ah + C;
		ch |= ~0x50;
		C.u0 = false;
		bl = bl + dl + C;
		&SCZO.u5->u0 = cond(bl);
		v117 = (eax & 0x01 << 0x01) != 0x00;
		eax = __ror<word32,byte>(eax, 0x01);
		C = v117;
		if (Test(UGE,C))
		{
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
				{
					al &= 227;
					SZ = cond(al);
					O = false;
					C.u0 = false;
					goto l0040C844;
				}
			}
			ch >>= cl;
			ch <<= cl;
			bh <<= cl;
			ch = -ch;
			&ch.u5->u0 = (byte) ch.u0 + 1;
			cl += dl;
			ch >>= cl;
			cl <<= cl;
			&SCZO.u5->u0 = cond(cl);
			--ch;
			SZO = cond(ch);
			goto l0040C4C7;
		}
l0040C413:
		edi >>= cl;
		&SCZO.u5->u0 = cond(edi);
l0040C1EA:
		bl = ~bl;
		ebx <<= 0x07;
		ebx &= edx;
		v125 = (ebx & 0x01 << 0x20 - 0x0F) != 0x00;
		ebx = __rol<word32,byte>(ebx, 0x0F);
		v126 = (cl & 0x01 << cl) != 0x00;
		cl = __ror<byte,byte>(cl, cl);
		ecx >>= 0x09;
		bh &= ah;
		ch &= dl;
		C.u0 = false;
		ebx = ebx - ecx - C;
		edi >>= 0x12;
		ebx <<= cl;
		ebx <<= cl;
		&SCZO.u5->u0 = cond(ebx);
		bl = bl + ch + C;
		&SCZO.u5->u0 = cond(bl);
		bh = bh + dl + C;
		&bl.u5->u0 = (byte) bl.u0 + 0x0067;
		bh <<= cl;
		v127 = (esi & 0x01 << cl) != 0x00;
		esi = __ror<word32,byte>(esi, cl);
		C = v127;
		cl = cl + dl + C;
		esi += ebx;
		edi &= edx;
		bl = bl ^ 0x67;
		O = false;
		edi >>= 11;
		SCZ = cond(edi);
		v128 = (edi & 0x01 << cl) != 0x00;
		edi = __rcr<word32,byte>(edi, cl, C);
		eax = gs;
		ecx >>= 0x02;
		SCZ = cond(ecx);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				C = __daa(al, &al);
				al = al ^ 0x5A;
				SZ = cond(al);
				O = false;
				C.u0 = false;
				if (ecx != 0x00)
					esi.u0 = 0xB002EBF0;
				goto l0040BF90;
			}
		}
		bl.u0 = 141;
		ch -= dh;
		esi >>= cl;
		&esi.u5->u0 = (word32) esi + 1;
		v131 = (ebx & 0x01 << 0x20 - 0x0A) != 0x00;
		ebx = __rol<word32,byte>(ebx, 0x0A);
		ebx &= edx;
		ecx <<= 0x18;
		&SCZO.u5->u0 = cond(ecx);
		v132 = (esi & 0x01 << 0x20 - 0x0D) != 0x00;
		esi = __rcl<word32,byte>(esi, 0x0D, C);
		--bl;
		bl = bl ^ dh;
		SZ = cond(bl);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
			break;
		esi -= eax;
		ch -= 0x34;
		ch <<= cl;
		&SCZO.u5->u0 = cond(ch);
		v137 = (ebx & 0x01 << 0x19) != 0x00;
		ebx = __rcr<word32,byte>(ebx, 0x19, C);
		C = v137;
	}
	eax = eax;
	if (Test(NE,Z))
		break;
	__lock();
	ebx.u0 = 3755112500;
	--ebx;
	v133 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	ecx >>= cl;
	cl &= ah;
	dh = dh ^ al;
	SZ = cond(dh);
	O = false;
	v134 = (esi & 0x01 << 0x07) != 0x00;
	esi = __ror<word32,byte>(esi, 0x07);
	C = v134;
	bh = ch;
	dh += ah;
	&SCZO.u5->u0 = cond(dh);
	v138 = (eax & 0x01 << 0x20 - 0x18) != 0x00;
	eax = __rcl<word32,byte>(eax, 0x18, C);
	C = v138;
	v140 = fs->t0030;
	esp -= 4;
	*esp = v140;
	eax = *esp;
	&esp.u5->u0 = (word32) esp + 4;
	esi = esi - ecx - C;
	&SCZO.u5->u0 = cond(esi);
	v141 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v141;
	--ch;
	v142 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	esi = esi ^ eax;
	C.u0 = false;
	ch = ch + bl + C;
	&SCZO.u5->u0 = cond(ch);
	v143 = (esi & 0x01 << 0x14) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x14, C);
	C = v143;
	edi = edi + ecx + C;
	bh <<= cl;
	v144 = *((byte) eax.u0 + 144);
	esp -= 4;
	*esp = v144;
	eax = *esp;
	&esp.u5->u0 = (word32) esp + 4;
	ecx <<= 0x07;
	edi &= eax;
	--edi;
	bh = ~bh;
	bh = ~bh;
	--ch;
	ch -= ah;
	&SCZO.u5->u0 = cond(ch);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(NE,Z))
			goto l0040C5D8;
		ebp = edx.u7->dw8BB83072 *s 335528386;
		dh.u0 = 232;
		v145 = (ecx & 0x01 << 0x15) != 0x00;
		ecx = __ror<word32,byte>(ecx, 0x15);
		C = v145;
		v146 = (edx & 0x01 << 0x14) != 0x00;
		edx = __rcr<word32,byte>(edx, 0x14, C);
		edx >>= cl;
		&SCZO.u5->u0 = cond(edx);
		al = al + ah + C;
		esi >>= cl;
		&SCZO.u5->u0 = cond(esi);
		if (Test(EQ,Z))
		{
l0040C44F:
			bl &= al;
			v150 = (dh & 0x01 << 0x08 - cl) != 0x00;
			dh = __rol<byte,byte>(dh, cl);
			&al.u5->u0 = (byte) al.u0 + 91;
			dl &= al;
			C.u0 = false;
			bh = bh - bl - C;
			eax &= ebx;
			ah.u0 = 0x2A;
			ecx <<= 11;
			&SCZO.u5->u0 = cond(ecx);
			al = al + dh + C;
			edi <<= cl;
			&SCZO.u5->u0 = cond(edi);
			v151 = (edi & 0x01 << 0x20 - cl) != 0x00;
			edi = __rcl<word32,byte>(edi, cl, C);
			C = v151;
			v152 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			edi <<= cl;
			&SCZO.u5->u0 = cond(edi);
			ebx >>= cl;
			SCZ = cond(ebx);
			v156 = (ecx & 0x01 << 0x20 - 0x15) != 0x00;
			ecx = __rcl<word32,byte>(ecx, 0x15, C);
			C = v156;
			v157 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			al |= dl;
			C.u0 = false;
			v158 = (edx & 0x01 << cl) != 0x00;
			edx = __rcr<word32,byte>(edx, cl, C);
			C = v158;
			v159 = (ecx & 0x01 << 0x20 - 0x01) != 0x00;
			ecx = __rcl<word32,byte>(ecx, 0x01, C);
			al |= cl;
			cl <<= cl;
			&SCZO.u5->u0 = cond(cl);
			v160 = (al & 0x01 << cl) != 0x00;
			al = __rcr<byte,byte>(al, cl, C);
			C = v160;
			dl >>= cl;
			&SCZO.u5->u0 = cond(dl);
			v162 = (dh & 0x01 << cl) != 0x00;
			dh = __rcr<byte,byte>(dh, cl, C);
			C = v162;
			v163 = (ah & 0x01 << 0x08 - cl) != 0x00;
			ah = __rcl<byte,byte>(ah, cl, C);
			dh |= ah;
			edx >>= 0x06;
			&SCZO.u5->u0 = cond(edx);
			edx = eax;
			bh = bh + dh + C;
			&SCZO.u5->u0 = cond(bh);
			ah >>= cl;
			SCZ = cond(ah);
l0040C844:
			ebx = eax;
			eax = -eax;
			ebx <<= 0x04;
			dh <<= cl;
			esi = -esi;
			eax <<= cl;
			al += bh;
			&SCZO.u5->u0 = cond(al);
			v122 = (edx & 0x01 << cl) != 0x00;
			edx = __rcr<word32,byte>(edx, cl, C);
			C = v122;
			v123 = (edx & 0x01 << 0x20 - cl) != 0x00;
			edx = __rcl<word32,byte>(edx, cl, C);
			--edi;
			bl = bl ^ 0x59;
			ecx += esi;
			--ecx;
			ecx <<= 0x1A;
			v124 = (edi & 0x01 << cl) != 0x00;
			edi = __ror<word32,byte>(edi, cl);
			edx <<= 22;
			ebx >>= 0x0E;
			ah &= al;
			SZ = cond(ah);
			O = false;
			C.u0 = false;
l0040C666:
			SCZO = *esp;
			&esp.u5->u0 = (word32) esp + 4;
			return;
		}
		eax = eax;
		if (Test(NE,Z))
			goto l0040C44F;
		&ecx.u5->u0 = (word32) ecx - 70;
		&SCZO.u5->u0 = cond(ecx);
l0040C2B4:
		ch <<= cl;
		cl = -cl;
		ebx &= ecx;
		v147 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v147;
		v148 = (ch & 0x01 << 0x08 - cl) != 0x00;
		ch = __rcl<byte,byte>(ch, cl, C);
		bh += bl;
		&SCZO.u5->u0 = cond(bh);
		v149 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v149;
		__syscall<byte>(0x2E);
		ebx = -ebx;
		edi <<= 0x1D;
		v153 = (ch & 0x01 << 0x08 - cl) != 0x00;
		ch = __rol<byte,byte>(ch, cl);
		C = v153;
		edi = edi + edx + C;
		ecx <<= cl;
		esi = -esi;
		v154 = (ch & 0x01 << cl) != 0x00;
		ch = __ror<byte,byte>(ch, cl);
		C = v154;
		ch = ch - ah - C;
		&SCZO.u5->u0 = cond(edx - ~0x00);
		if (Test(NE,Z))
		{
			al.u0 = edx.u7->tFFFFFFFF.u0;
			if (Test(NE,Z))
			{
				eax = eax;
				if (Test(EQ,Z))
					;
			}
			goto l0040BFDC;
		}
l0040BFDC:
		&SCZO.u5->u0 = cond(eax - 0xC000002E);
		if (Test(NE,Z))
		{
			ah >>= cl;
			esi <<= 0x11;
			edi >>= cl;
			al = al ^ 44;
			--ch;
			esi = esi ^ ebx;
			SZ = cond(esi);
			O = false;
			C.u0 = false;
			v130 = (edx & 0x01 << cl) != 0x00;
			edx = __rcr<word32,byte>(edx, cl, C);
			C = v130;
			goto l0040C50F;
		}
		bh >>= cl;
		&SCZO.u5->u0 = cond(bh);
		bl = bl - 0x8C - C;
		esi = -esi;
		eax <<= 0x08;
		&SCZO.u5->u0 = cond(eax);
		bh |= ch;
		&edx.u5->u0 = (word32) edx + 1;
		edi >>= cl;
		al.u0 = ~0x18;
		ecx |= esi;
		v155 = (esi & 0x01 << 0x20 - cl) != 0x00;
		esi = __rol<word32,byte>(esi, cl);
		&ch.u5->u0 = (byte) ch + 1;
		eax >>= cl;
		&SCZO.u5->u0 = cond(eax);
		&dl.u5->u0 = (byte) dl + 1;
		SZO = cond(dl);
		ah.u0 = 131;
		cl = cl ^ 202;
		ecx += eax;
		ch &= al;
		v161 = (ebx & 0x01 << 0x20 - cl) != 0x00;
		ebx = __rol<word32,byte>(ebx, cl);
		edx &= edi;
		SZ = cond(edx);
		O = false;
		C.u0 = false;
		eax.u0 = 0x03;
		&dl.u5->u0 = (byte) dl + 1;
		edi = -edi;
		bl >>= cl;
		edx >>= 11;
		edx = -edx;
		&dl.u5->u0 = (byte) dl + 93;
		edx >>= cl;
		C = edi != 0x00;
		edi = -edi;
		v164 = (ebx & 0x01 << cl) != 0x00;
		ebx = __rcr<word32,byte>(ebx, cl, C);
		C = v164;
		dh = dh - ~0x04 - C;
		edi += eax;
		bh -= 0x56;
		&SCZO.u5->u0 = cond(bh);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				esi = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				v165 = *esi.u0;
				*edi = v165;
				&esi.u5->u0 = (byte) esi.u0 + 1;
				edi = *esp;
				&esp.u5->u0 = (word32) esp + 4;
l0040C50F:
				v135 = (eax & 0x01 << cl) != 0x00;
				eax = __rcr<word32,byte>(eax, cl, C);
				dl = -dl;
				edx >>= cl;
				ebx = -ebx;
				dl += ch;
				bh = bh ^ bl;
				SZ = cond(bh);
				O = false;
				v136 = (dh & 0x01 << cl) != 0x00;
				dh = __ror<byte,byte>(dh, cl);
				C = v136;
				return;
			}
		}
		ecx <<= cl;
		cl = cl ^ 0x7E;
		ebx += ecx;
		bh = bh ^ cl;
		ch -= 0x1F;
		cl = cl ^ 0x6B;
		edx = edx ^ edx;
		edi <<= cl;
		&SCZO.u5->u0 = cond(edi);
		edi <<= cl;
		bl &= 0xC6;
		v168 = (esi & 0x01 << cl) != 0x00;
		esi = __ror<word32,byte>(esi, cl);
		C = v168;
		cl = cl - bh - C;
		v169 = (ecx & 0x01 << 0x20 - cl) != 0x00;
		ecx = __rol<word32,byte>(ecx, cl);
		C = v169;
		ecx = ecx + edx + C;
		bh = bh ^ ch;
		v170 = (ecx & 0x01 << cl) != 0x00;
		ecx = __ror<word32,byte>(ecx, cl);
		gs = ax;
		ecx += eax;
		edi <<= cl;
		&SCZO.u5->u0 = cond(edi);
		if (Test(NE,Z))
		{
			eax = eax;
			if (Test(EQ,Z))
			{
				ebx = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				esp -= 4;
				esp->u0 = 0x1D;
				edi = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				esi = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				ebp = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				&esp.u5->u0 = (word32) esp + 4;
				ebx = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				edx = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				ecx = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				eax = *esp;
				&esp.u5->u0 = (word32) esp + 4;
				&eax.u5->u0 = (byte) eax.u0 + 0x1234B12E;
				&SCZO.u5->u0 = cond(eax);
				goto l0040C3DF;
			}
		}
		v179 = (bl & 0x01 << 0x08 - cl) != 0x00;
		bl = __rcl<byte,byte>(bl, cl, C);
		cl |= 44;
		C.u0 = false;
		--edi;
		v180 = (esi & 0x01 << 0x20 - 0x04) != 0x00;
		esi = __rcl<word32,byte>(esi, 0x04, C);
		v181 = (bl & 0x01 << cl) != 0x00;
		bl = __ror<byte,byte>(bl, cl);
		C = v181;
		bh = bh - 0xD2 - C;
		&SCZO.u5->u0 = cond(bh);
		cl = cl - 0x38 - C;
		&SCZO.u5->u0 = cond(cl);
		v182 = (ecx & 0x01 << cl) != 0x00;
		ecx = __rcr<word32,byte>(ecx, cl, C);
		C = v182;
		v183 = (ch & 0x01 << cl) != 0x00;
		ch = __rcr<byte,byte>(ch, cl, C);
		C = v183;
		goto l0040C413;
	}
l0040C5D8:
	dl += bh;
	&SCZO.u5->u0 = cond(dl);
	bh = bh - ~0x02 - C;
	&SCZO.u5->u0 = cond(bh);
	v166 = *eax.u0;
	esp -= 4;
	*esp = v166;
	eax = *esp;
	&esp.u5->u0 = (word32) esp + 4;
	v167 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rcl<byte,byte>(ch, cl, C);
	ecx -= edi;
	&SCZO.u5->u0 = cond(ecx);
	edi = ebx;
	v171 = (cl & 0x01 << cl) != 0x00;
	cl = __ror<byte,byte>(cl, cl);
	C = v171;
	v172 = (edi & 0x01 << 11) != 0x00;
	edi = __rcr<word32,byte>(edi, 11, C);
	bl.u0 = ~0x09;
	v173 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	dh = dh ^ 0x61;
	ch &= bl;
	C.u0 = false;
	v174 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	C = v174;
	v175 = (bh & 0x01 << cl) != 0x00;
	bh = __rcr<byte,byte>(bh, cl, C);
	dh &= al;
	SZ = cond(dh);
	O = false;
	v176 = (edi & 0x01 << 0x0D) != 0x00;
	edi = __ror<word32,byte>(edi, 0x0D);
	C = v176;
	v177 = *((byte) eax.u0 + 8);
	esp -= 4;
	*esp = v177;
	eax = *esp;
	&esp.u5->u0 = (word32) esp + 4;
	v178 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	bh -= 0x43;
	bh += dh;
	&SCZO.u5->u0 = cond(bh);
	ecx = ecx + edi + C;
	edi &= ebx;
	O = false;
	cl = ah;
	ch >>= cl;
	SCZ = cond(ch);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(NE,Z))
			goto l0040C36D;
		eax.u0 = 1421947933;
		D = false;
		goto l0040C1EA;
	}
l0040C36D:
	dl = dl - bh - C;
	esi <<= cl;
	&SCZO.u5->u0 = cond(esi);
	v184 = (edx & 0x01 << 0x20 - 0x15) != 0x00;
	edx = __rcl<word32,byte>(edx, 0x15, C);
	v185 = (edi & 0x01 << 0x0F) != 0x00;
	edi = __ror<word32,byte>(edi, 0x0F);
	ch.u0 = 0x9C;
	cl = ~cl;
	eax &= ~0x11111111;
	C.u0 = false;
	ecx = ecx + ebx + C;
	&SCZO.u5->u0 = cond(ecx);
	ebx = ebx - ecx - C;
	edi >>= 0x09;
	C = esi != 0x00;
	esi = -esi;
	SZO = cond(esi);
	dh = bh;
	dl = -dl;
	ch >>= cl;
	v186 = (ch & 0x01 << cl) != 0x00;
	ch = __ror<byte,byte>(ch, cl);
	ebx <<= 0x09;
	&SCZO.u5->u0 = cond(ebx);
	v187 = (edi & 0x01 << 0x20 - 0x0C) != 0x00;
	edi = __rcl<word32,byte>(edi, 0x0C, C);
	v188 = (esi & 0x01 << 0x20 - cl) != 0x00;
	esi = __rol<word32,byte>(esi, cl);
	dh <<= cl;
	esi <<= 0x0F;
	&SCZO.u5->u0 = cond(esi);
	v189 = (edi & 0x01 << 0x0A) != 0x00;
	edi = __ror<word32,byte>(edi, 0x0A);
	C = v189;
	eax -= ~0x11111111;
	v190 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rol<byte,byte>(ch, cl);
	ecx -= edx;
	&SCZO.u5->u0 = cond(ecx);
	v191 = (bh & 0x01 << 0x08 - cl) != 0x00;
	bh = __rcl<byte,byte>(bh, cl, C);
	&ch.u5->u0 = (byte) ch.u0 + 0x00EE;
	edx += esi;
	&SCZO.u5->u0 = cond(edx);
	dh |= ah;
	C.u0 = false;
	esi = esi - eax - C;
	edx <<= cl;
	&SCZO.u5->u0 = cond(edx);
	cl.u0 = 0xF0;
	v192 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	dl >>= cl;
	ecx <<= cl;
	&SCZO.u5->u0 = cond(ecx);
	v193 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	bl -= 222;
	&SCZO.u5->u0 = cond(bl);
	eax |= eax;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		eax |= eax;
		SZ = cond(eax);
		O = false;
		C.u0 = false;
		if (Test(NE,Z))
			return;
	}
	v194 = (esi & 0x01 << 0x1E) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x1E, C);
	C = dl != 0x00;
	dl = -dl;
	SZO = cond(dl);
	esi = esi ^ eax;
	dh = dh ^ dl;
	dl.u0 = 229;
	v195 = (edx & 0x01 << 0x06) != 0x00;
	edx = __ror<word32,byte>(edx, 0x06);
	ebx = -ebx;
	edx >>= cl;
	edx = edx ^ edx;
	C.u0 = false;
	&esi.u5->u0 = (word32) esi + 1;
	SZO = cond(esi);
	if (Test(EQ,Z))
		goto l0040C2B4;
	eax = eax;
	if (Test(NE,Z))
		goto l0040C2B4;
	__cli();
	v196 = edi.u7->b0046 | dl;
	edi.u7->b0046 = v196;
	SZ = cond(edi.u7->b0046);
	&SCZO.u5->u0 = cond(eax - 2161128268);
}

// 0040D438: define fn0040D438
// Called from:
//      fn0040D786
//      fn0040D9A6
define fn0040D438
{
	word32 ecx;
	word32 eax;
	byte dh;
	ah = SLICE(eax, byte, 8);
	word32 edi;
	word32 esi;
	cl = (byte) ecx;
	byte dl;
	word16 edx_16_16;
	word32 ebx;
	<unknown> Mem0;
	ch = SLICE(ecx, byte, 8);
	word32 ebp;
	Top_3 = 0;
	dh_6 = dh | ah;
	edi_8 = edi << 11;
	eax_13 = eax;
	esi_15 = esi - eax_13 - (word32) (edi << 11 < 0x00);
	SCZO_17 = cond(&eax_13->dw0008);
	C_20.u0 = SLICE(SCZO_17, bool, 1);
	dh_21 = __rcl<byte,byte>(dh_6, cl, C_20);
	edx_25 = SEQ(edx_16_16, dh_21 - 0x8A, dl);
	edx_26 = edx_25 << cl;
	dh_43 = SLICE(edx_26, byte, 8);
	dl_59 = (byte) edx_26;
	ebx_29 = __rol<word32,byte>(ebx, 0x07);
	bh_30 = SLICE(ebx_29, byte, 8);
	ebx_16_16_34 = SLICE(ebx_29, word16, 16);
	bl_35 = (byte) ebx_29;
	bh_31 = bh_30 << cl;
	v62_112 = SEQ(ebx_36, esi_15) << 0x01;
	esi_32 = (word32) v62_112;
	ebx_36 = SEQ(ebx_16_16_34, bh_31, bl_35);
	ebx_39 = SLICE(v62_112, word32, 32);
	bh_42 = SLICE(ebx_39, byte, 8);
	bl_66 = (byte) ebx_39;
	ebx_16_16_83 = SLICE(ebx_39, word16, 16);
	esi_40 = esi_32 >> cl;
	bh_45 = bh_42 + dh_43 + (byte) (esi_40 < 0x00);
	if (bh_45 != 0x00)
	{
		ebx_100 = SEQ(ebx_16_16_83, bh_45, bl_66);
		if (bh_45 == 0x00)
		{
			ebp_97 = &eax_13->dw0008;
			fn0040D469();
			return;
		}
	}
	bh_51 = bh_45 + dh_43;
	edi_53 = (edi << 11) + 0x01;
	eax_57 = eax_13->dw0008;
	dl_62 = dl_59 & ch;
	v32_68 = (bl_66 & 0x01 << cl) != 0x00;
	ecx_78 = ecx;
	ebx_24_8_84 = SEQ(ebx_16_16_83, bh_51);
	edx_24_8_90 = SLICE(edx_26, word24, 8);
	dl_71 = (cu8) ((bool) v32_68 + (dl_62 + 0x96));
	bl_75 = dl_71 + 0x11 + (byte) (dl_71 < 0x00);
	edi_79 = edi_53 & ecx_78;
	bl_81 = ~(bl_75 + 0x01);
	ebx_85 = SEQ(ebx_24_8_84, bl_81);
	ebx_86 = ebx_85 - edi_79;
	edx_91 = SEQ(edx_24_8_90, dl_71);
	edx_93 = edx_91 + edi_79 + (word32) (ebx_86 < 0x00);
	SCZO_94 = cond(edx_93);
	C_114 = SLICE(SCZO_94, bool, 1);
	O_127 = SLICE(SCZO_94, bool, 4);
	S_129 = (bool) SCZO_94;
	Z_133 = SLICE(SCZO_94, bool, 2);
	fn0040D5DB();
}

// 0040D469: define fn0040D469
// Called from:
//      fn0040D438
//      fn0040DB4B
define fn0040D469
{
	byte dh;
	byte ch;
	word32 esi;
	word32 ebx;
	bh_30 = SLICE(ebx, byte, 8);
	byte cl;
	word32 eax;
	<unknown> Mem0;
	dh_23 = dh ^ ch;
	esi_26 = esi - ebx;
	eax();
	Top_47 = 0;
	dh_49 = SLICE(edx_44, byte, 8);
	cl_50 = (byte) ecx_45;
	dl_57 = (byte) edx_44;
	edx_16_16_58 = SLICE(edx_44, word16, 16);
	dh_51 = dh_49 >> cl_50;
	fn0040D746();
}

// 0040D4AB: define fn0040D4AB
// Called from:
//      fn0040D650
//      fn0040DB4B
define fn0040D4AB
{
	word32 edx;
	word32 eax;
	word32 edi;
	dh = SLICE(edx, byte, 8);
	dl = (byte) edx;
	word32 ebx;
	bh_90 = SLICE(ebx, byte, 8);
	bl_101 = (byte) ebx;
	ebx_16_16_102 = SLICE(ebx, word16, 16);
	<unknown> Mem0;
	selector ds;
	word32 ebp;
	Top_3 = 0;
	cl_7 = (byte) eax - 0x01;
	&ch_9.u5->u0 = SLICE(eax - 0x01, byte, 8);
	ecx_16_16_15 = SLICE(eax - 0x01, word16, 16);
	ch_11 = __ror<byte,byte>(ch_9, cl_7 + 0x01);
	ecx_16 = SEQ(ecx_16_16_15, ch_11 & 121, cl_7 + 0x01);
	ecx_18 = ecx_16 << cl_7 + 0x01;
	ecx_24_8_24 = SLICE(ecx_18, word24, 8);
	edi_20 = edi + ecx_16;
	ecx_25 = SEQ(ecx_24_8_24, 0x4A);
	ecx_27 = __rol<word32,byte>(ecx_25, 0x1B);
	ch_28 = SLICE(ecx_27, byte, 8);
	ecx_16_16_34 = SLICE(ecx_27, word16, 16);
	ch_30 = ch_28 & dh;
	esi_32 = eax - 0x01;
	ecx_35 = SEQ(ecx_16_16_34, ch_30, 0x5B);
	edi_36 = (edi_20 << 0x4A) + ecx_35;
	cl_37.u0 = 0x40;
	edx_40 = edx;
	edi_41 = edi_36 & edx_40;
	if (edi_41 != 0x00)
	{
		eax_46 = eax - 0x01;
		if (edi_41 == 0x00)
		{
			ebx.u7->tC108231D.u0 = (int8) __rcr<byte,byte>(ebx.u7->tC108231D.u0, 0x40, false);
			goto l0040DDDD;
		}
	}
	eax_59 = eax - 0x01;
	ah_94 = SLICE(eax - 0x01, byte, 8);
	eax_24_8_118 = SLICE(eax - 0x01, word24, 8);
	SCZO_49 = cond(0x49);
	C_52.u0 = SLICE(SCZO_49, bool, 1);
	edi_53 = __rcl<word32,byte>(edi_41, 0x14, C_52);
	edi_57 = edi_53 | eax - 0x01;
	esi_58 = eax - 2882985032;
	edi_60 = edi_57 - (eax - 0x01);
	ecx_64 = SEQ(ecx_16_16_34, ch_30 + 0xD8, 118);
	ch_68 = SLICE(ecx_64 << 118, byte, 8);
	ecx_16_16_184 = SLICE(ecx_64 << 118, word16, 16);
	ch_71 = ch_68 >> (ch_68 ^ ~0x09);
	ds_ebp_77 = *ebx;
	ds_171 = SLICE(ds_ebp_77, selector, 32);
	ebp_178 = (word32) ds_ebp_77;
	__cli();
	cl_78 = (ch_68 ^ ~0x09) << (ch_68 ^ ~0x09);
	edi_80 = (edi_60 >> 0x07) + (eax - 2882985032);
	SCZO_81 = cond(eax - 2882985032 - 1411982265);
	C_85.u0 = SLICE(SCZO_81, bool, 1);
	ecx_24_8_186 = SEQ(ecx_16_16_184, ch_71);
	if (eax != 0x01)
	{
		v38_84 = (edx_40 & 0x20) != 0x00;
		edx_86 = __rcr<word32,byte>(edx_40, 0x05, C_85);
		cl_88 = cl_78 - 233 - v38_84;
		cl_92 = cl_88 - bh_90 - (byte) (cl_88 < 0x00);
		SCZO_93 = cond(cl_92);
		C_168 = SLICE(SCZO_93, bool, 1);
		ecx_187 = SEQ(ecx_24_8_186, cl_92);
		O_198 = SLICE(SCZO_93, bool, 4);
		S_201 = (bool) SCZO_93;
		Z_207 = SLICE(SCZO_93, bool, 2);
		fn0040D5AC();
		return;
	}
	bh_97 = bh_90 | dl;
	ebx_103 = SEQ(ebx_16_16_102, bh_97, bl_101);
	eax_119 = SEQ(eax_24_8_118, ah_94);
	ebx_105 = __rcl<word32,byte>(ebx_103, 0x17, false);
l0040DDDD:
	ecx_16_16_183 = ϕ(ecx_16_16_184, ecx_16_16_34);
	ebp_177 = ϕ(ebp_178, ebp);
	ds_170 = ϕ(ds_171, ds);
	edi_126 = ϕ(edi_80, edi_41);
	ebx_123 = ϕ(ebx_105, ebx);
	eax_117 = ϕ(eax_119, eax_46);
	cl_113 = ϕ(cl_78, cl_37);
	esi_112 = ϕ(esi_58, esi_32);
	ch_110 = ϕ(ch_71, ch_30);
	ch_111 = ch_110 | ~0x52;
	esi_114 = esi_112 << cl_113;
	dl_132 = (byte) (edx_40 >> 0x1E);
	edx_24_8_190 = SLICE(edx_40 >> 0x1E, word24, 8);
	v23_120 = (eax_117 & 0x4000) != 0x00;
	eax_121 = __rol<word32,byte>(eax_117, 0x12);
	ah_129 = SLICE(eax_121, byte, 8);
	eax_16_16_142 = SLICE(eax_121, word16, 16);
	al_143 = (byte) eax_121;
	ebx_125 = __rcl<word32,byte>(ebx_123, cl_113, v23_120);
	ebx_16_16_138 = SLICE(ebx_125, word16, 16);
	bl_139 = (byte) ebx_125;
	edi_128 = __rol<word32,byte>(edi_126, cl_113);
	dl_134 = __rcr<byte,byte>(dl_132, cl_113, false);
	cl_136 = __ror<byte,byte>(cl_113, cl_113);
	ebx_140 = SEQ(ebx_16_16_138, ah_129 & ~0x28, bl_139);
	edi_141 = edi_128 ^ ebx_140;
	eax_144 = SEQ(eax_16_16_142, ah_129 & ~0x28, al_143);
	eax_146 = -eax_144;
	al_148 = (byte) eax_146;
	eax_24_8_151 = SLICE(eax_146, word24, 8);
	edx_191 = SEQ(edx_24_8_190, dl_134);
	eax_152 = SEQ(eax_24_8_151, al_148 | 0xC1);
	eax_154 = __rcr<word32,byte>(eax_152, cl_136, false);
	al_163 = (byte) eax_154 + 0x01;
	eax_24_8_174 = SLICE((word32) eax_154 + 1, word24, 8);
	bh_158 = (ah_129 & ~0x28) >> cl_136;
	v34_160 = (ch_111 & 0x01 << cl_136) != 0x00;
	ch_161 = __ror<byte,byte>(ch_111, cl_136);
	ebx_181 = SEQ(ebx_16_16_138, bh_158, cl_136);
	ecx_185 = SEQ(ecx_16_16_183, ch_161, cl_136);
	al_164 = al_163 - 0x53 - v34_160;
	SCZO_165 = cond(al_164);
	C_167 = SLICE(SCZO_165, bool, 1);
	eax_175 = SEQ(eax_24_8_174, al_164);
	O_197 = SLICE(SCZO_165, bool, 4);
	S_200 = (bool) SCZO_165;
	Z_206 = SLICE(SCZO_165, bool, 2);
}

// 0040D4EB: define fn0040D4EB
// Called from:
//      fn0040D564
//      fn0040D665
define fn0040D4EB
{
	esp = fp;
	Top = 0;
	bh = bh ^ bl;
	C.u0 = false;
	bh = bh + cl + C;
	eax &= ebx;
	ah = (ui8) &(cl.u5 + ah /8 0x0A)->u0;
	SCZO = cond(ah);
	v15 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	edi = -edi;
	ecx >>= 0x0F;
	al &= 0x86;
	C.u0 = false;
	dh = dh - cl - C;
	SCZO = cond(dh);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			SCZO = ah;
			esi.u7->wFFFFFFDB = 0x809D;
			fn0040D513();
			return;
		}
	}
	edx <<= cl;
	SCZO = cond(edx);
	ah = ah + bl + C;
	edi |= ecx;
	v23 = (edx & 0x01 << 0x0F) != 0x00;
	edx = __ror<word32,byte>(edx, 0x0F);
	C = v23;
	v24 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	eax <<= 0x0F;
	SCZO = cond(eax);
	v25 = (eax & 0x01 << 0x03) != 0x00;
	eax = __ror<word32,byte>(eax, 0x03);
	C = v25;
	al &= dh;
	bl -= bh;
	SCZO = cond(bl);
	ah = ah - bl - C;
	v26 = (ebx & 0x01 << 0x18) != 0x00;
	ebx = __ror<word32,byte>(ebx, 0x18);
	ecx <<= 0x0F;
	SCZO = cond(ecx);
	v27 = (ebx & 0x01 << 0x02) != 0x00;
	ebx = __rcr<word32,byte>(ebx, 0x02, C);
	C = v27;
	dl = (bool) C.u0 + (dl + ah);
	++dl;
	edi = edi ^ edx;
	al &= cl;
	C.u0 = false;
	bl = bl - bh - C;
	SCZO = cond(bl);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			SCZO = ah;
			__halt();
		}
	}
	edx = edx + ecx + C;
	SCZO = cond(edx);
	dl = dl - ~0x32 - C;
	ah = -ah;
	v29 = (eax & 0x01 << 0x20 - 0x12) != 0x00;
	eax = __rol<word32,byte>(eax, 0x12);
	v30 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	C = v30;
	&v31.u5->u0 = ecx->u5;
	esp -= 4;
	esp->u5 = (Eq_3 (*)[]) v31;
	bh = bh - ah - C;
	ah += ~0x32;
	SCZO = cond(ah);
	dh = ~dh;
	esi = esi + ebx + C;
	bl &= ch;
	C.u0 = false;
	v33 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	al -= 101;
	SCZO = cond(al);
	ah <<= cl;
	v34 = (edi & 0x01 << 0x14) != 0x00;
	edi = __ror<word32,byte>(edi, 0x14);
	&eax.u5->u0 = esp->u5;
	esp = (union Eq_3 *) ((char *) esp + 4);
	esi <<= cl;
	v35 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	ebx = ebx ^ edx;
	C.u0 = false;
	v36 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	esi |= eax;
	C.u0 = false;
	bl = bl + dh + C;
	SCZO = cond(bl);
	dl = (bool) C.u0 + (dl + ah);
	v37 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	C = v37;
	bh = bh - 0x88 - C;
	SCZO = cond(bh);
	fn0040DB09();
}

// 0040D513: define fn0040D513
// Called from:
//      fn0040D591
//      fn0040D665
define fn0040D513
{
	esp = fp;
	Top = 0;
	dh -= 0x6C;
	esi <<= 0x18;
	--ecx;
	v11 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	ch &= 199;
	ecx <<= cl;
	cl = -cl;
	ecx |= edi;
	esi <<= cl;
	dh += ~0x06;
	SCZO = cond(dh);
	if (Test(EQ,Z))
		fn0040D605();
	else
		fn0040D530();
}

// 0040D530: define fn0040D530
// Called from:
//      fn0040D591
//      fn0040D665
define fn0040D530
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040D605();
	else
	{
		eax += 3368082306;
		SCZO = cond(eax);
		esp -= 2;
		*esp = (struct Eq_3797 **) cs;
		fn0040D53E();
	}
}

// 0040D53E: define fn0040D53E
// Called from:
//      fn0040D665
//      fn0040D786
//      fn0040DD56
//      fn0040DD6A
define fn0040D53E
{
	word32 ebx;
	ptr32 fp;
	word32 edi;
	word32 edx;
	word32 eax;
	byte cl;
	bh = SLICE(ebx, byte, 8);
	word32 esi;
	Top_3 = 0;
	edi_6 = edi & edx;
	esp_7 = fp - 4;
	eax_13 = eax >> cl;
	ah_15 = SLICE(eax_13, byte, 8);
	al_29 = (byte) eax_13;
	eax_16_16_37 = SLICE(eax_13, word16, 16);
	ah_18 = ah_15 - bh - (byte) (eax_13 < 0x00);
	ebx_23 = ebx;
	ebx_25 = __rol<word32,byte>(ebx_23, 0x04);
	bh_26 = SLICE(ebx_25, byte, 8);
	bl_30 = (byte) ebx_25;
	ah_27 = ah_18 - bh_26;
	edi_28 = -edi_6;
	al_31 = al_29 + bl_30;
	SCZO_32 = cond(al_31);
	O_39 = SLICE(SCZO_32, bool, 4);
	esi_33 = esi << 0x13 >> cl;
	SCZ_34 = cond(esi_33);
	C_36 = SLICE(SCZ_34, bool, 1);
	eax_38 = SEQ(eax_16_16_37, ah_27, al_31);
	S_40 = (bool) SCZ_34;
	Z_41 = SLICE(SCZ_34, bool, 2);
	fn0040DC1F();
}

// 0040D564: define fn0040D564
// Called from:
//      fn0040D665
define fn0040D564
{
	esp = fp;
	Top = 0;
	v5 = (edx & 0x01 << 0x20 - 0x0E) != 0x00;
	edx = __rol<word32,byte>(edx, 0x0E);
	ah = 0x84;
	--ecx;
	eax &= edi;
	dh &= bl;
	C.u0 = false;
	v17 = (esi & 0x01 << 0x1B) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x1B, C);
	edx = -edx;
	al = ~al;
	C = dl != 0x00;
	dl = -dl;
	v20 = (edi & 0x01 << 0x15) != 0x00;
	edi = __rcr<word32,byte>(edi, 0x15, C);
	eax |= ecx;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D4EB();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D4EB();
		else
		{
			ebx = ebx ^ *((word32) edi + (ebp * 0x02 - 738536660));
			SZ = cond(ebx);
			O = false;
			C.u0 = false;
			fn0040D591();
		}
	}
}

// 0040D58E: define fn0040D58E
// Called from:
//      fn0040DAC5
define fn0040D58E
{
	esp = fp;
	Top = 0;
	edx >>= cl;
	edi >>= cl;
	SCZ = cond(edi);
	fn0040D591();
}

// 0040D591: define fn0040D591
// Called from:
//      fn0040D58E
//      fn0040D665
define fn0040D591
{
	esp = fp;
	Top = 0;
	++ecx;
	SZO = cond(ecx);
	--ecx;
	if (ecx != 0x00)
		fn0040D5AC();
	else
	{
		bl = (bool) C + (bl + ah);
		bh = -bh;
		eax += eax->dw003C / 64;
		bh >>= cl;
		SCZO = cond(bh);
		ebx = edi;
		edx >>= cl;
		SCZ = cond(edx);
		fn0040DC3B();
	}
}

// 0040D5AC: define fn0040D5AC
// Called from:
//      fn0040D591
//      fn0040D650
define fn0040D5AC
{
	esp = fp;
	Top = 0;
	edx -= ebx;
	SCZO = cond(edx);
	fn0040D5AE();
}

// 0040D5AE: define fn0040D5AE
// Called from:
//      fn0040D591
//      fn0040D622
define fn0040D5AE
{
	esp = fp;
	Top = 0;
	--dh;
	v6 = (esi & 0x01 << 0x10) != 0x00;
	esi = __ror<word32,byte>(esi, 0x10);
	C = v6;
	edi = edi + ebx + C;
	edi = edx;
	v14 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	cl -= bh;
	dh.u0 = ebx->u0;
	ch = ~ch;
	ch >>= cl;
	ecx = ecx ^ edx;
	C.u0 = false;
	v20 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rcl<word32,byte>(ecx, cl, C);
	cl = cl ^ 0xB8;
	SZ = cond(cl);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040DE07();
	else
		fn0040D5CE();
}

// 0040D5CE: define fn0040D5CE
// Called from:
//      fn0040D591
//      fn0040D5AE
define fn0040D5CE
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040DE07();
	else
	{
		al.u0 = ebx[(uint32) al].t0000.u0;
		*edi = eax;
		++edi;
		__out<byte>(0x13, al);
		fn0040D5DB();
	}
}

// 0040D5DB: define fn0040D5DB
// Called from:
//      fn0040D591
//      fn0040D9A6
define fn0040D5DB
{
	esp = fp;
	Top = 0;
	al = ebx[(uint32) al];
	eax += ecx;
	SCZO = cond(eax);
	--dh;
	v12 = (esi & 0x01 << 0x0D) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x0D, C);
	C = v12;
	v15 = (edi & 0x01 << 0x20 - 0x08) != 0x00;
	edi = __rcl<word32,byte>(edi, 0x08, C);
	C = v15;
	bh = (byte) &(C.u3 + (bh + ch) /8 0x0A)->u0;
	dh <<= cl;
	bh = ~bh;
	C = ebx != null;
	ebx = -ebx;
	esi = esi - edx - C;
	SCZO = cond(esi);
	if (Test(EQ,Z))
		fn0040DB4B();
	else
		fn0040D5F6();
}

// 0040D5F6: define fn0040D5F6
// Called from:
//      fn0040D5DB
//      fn0040D9A6
//      fn0040DA85
define fn0040D5F6
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040DB4B();
	else
	{
		eax.u0 = esp->u0;
		esp = (union Eq_4271 *) ((char *) esp + 4);
		edx_eax = (int64) eax;
		al = __in<byte>(~0x44);
		ds.u1 = esp->u1;
		esp = (union Eq_4271 *) ((char *) esp + 2);
		esi = esi ^ *ebx;
		SZ = cond(esi);
		O = false;
		C = false;
		fn0040D605();
	}
}

// 0040D605: define fn0040D605
// Called from:
//      fn0040D530
//      fn0040D591
//      fn0040D5F6
//      fn0040D665
define fn0040D605
{
	esp = fp;
	Top = 0;
	esi = esi ^ eax;
	&ecx.u5->u0 = &(ecx.u5 + esi / 0x0A)->u0;
	v13 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	v14 = (ecx & 0x01 << 0x09) != 0x00;
	ecx = __ror<word32,byte>(ecx, 0x09);
	--ecx;
	ch += ~0x15;
	ch = ch ^ bh;
	edi >>= 0x15;
	SCZO = cond(edi);
}

// 0040D61A: define fn0040D61A
// Called from:
//      fn0040DB09
define fn0040D61A
{
	esp = fp;
	Top = 0;
	v6 = *eax + al;
	*eax = v6;
	edi -= edx->dw1B8F216;
	SCZO = cond(edi);
	fn0040D622();
}

// 0040D622: define fn0040D622
// Called from:
//      fn0040D61A
//      fn0040DB09
define fn0040D622
{
	esp = fp;
	Top = 0;
	eax = &(C.u3 + (eax + edi) / 0x0A)->u0;
	SCZO = cond(eax);
	v8 = esi;
	esi = v8;
	++Top;
	ax = __aad(ax);
	--ecx;
	if (Test(NE,Z) || ecx == 0x00)
		fn0040D5AE();
}

// 0040D64B: define fn0040D64B
// Called from:
//      fn0040DA85
//      fn0040DB09
define fn0040D64B
{
	esp = fp;
	Top = 0;
	ch += bl;
	cl = cl ^ ~0x31;
	SZ = cond(cl);
	O = false;
	C = false;
	fn0040D650();
}

// 0040D650: define fn0040D650
// Called from:
//      fn0040D64B
define fn0040D650
{
	esp = fp;
	Top = 0;
	ch -= bh;
	SCZO = cond(ch);
	v8 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rcl<word32,byte>(ecx, cl, C);
	edi = edi ^ ecx;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	dl = dh;
	v16 = (esi & 0x01 << 0x20 - 0x13) != 0x00;
	esi = __rcl<word32,byte>(esi, 0x13, C);
	C = v16;
	cl.u0 = 0xCC;
	&ecx.u5->u0 = (word32) ecx + 1;
	esi <<= 0x1A;
	SCZO = cond(esi);
	cl.u0 = 0x81;
	edi = edi + ecx + C;
	esi >>= cl;
	--esi;
	edi >>= 0x1C;
	SCZO = cond(edi);
	ebx->u0 = (int8) dl;
	v21 = (ecx & 0x01 << 0x13) != 0x00;
	ecx = __rcr<word32,byte>(ecx, 0x13, C);
	v22 = (cl & 0x01 << cl) != 0x00;
	cl = __ror<byte,byte>(cl, cl);
	cl >>= cl;
	esi <<= 0x01;
	SCZO = cond(esi);
	C = esi != 0x00;
	esi = -esi;
	v23 = (esi & 0x01 << 0x20 - 0x0E) != 0x00;
	esi = __rcl<word32,byte>(esi, 0x0E, C);
	v24 = (ecx & 0x01 << cl) != 0x00;
	ecx = __ror<word32,byte>(ecx, cl);
	ch -= 0x67;
	v25 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rol<byte,byte>(cl, cl);
	ebx = (union Eq_3 *) ((char *) ebx + 1);
	ch += 0x8A;
	&cl.u5->u0 = (byte) cl.u0 + 1;
	cl &= 11;
	SZ = cond(cl);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			SZP = cond(edx.u7->bFFFFFF95 & al);
			dh = cl;
			eax >>= cl;
			bl <<= cl;
			&dh.u5->u0 = (byte) dh + 1;
			&dl.u5->u0 = &(dl.u5 + ah /8 0x0A)->u0;
			esp -= 4;
			esp->u5 = (Eq_3 (*)[]) ecx;
			edx >>= 0x18;
			bh <<= cl;
			edi |= esi;
			v33 = (edx & 0x01 << 0x20 - cl) != 0x00;
			edx = __rol<word32,byte>(edx, cl);
			C = v33;
			cl = cl - dh - C;
			SCZO = cond(cl);
			fn0040DAB9();
			return;
		}
	}
	edi >>= cl;
	SCZ = cond(edi);
	ch = ch - 0x1D - C;
	ch >>= cl;
	ch -= 44;
	SCZO = cond(ch);
	ch = (uint8) ((bool) C.u0 + (ch + 0x4B));
	ch &= ah;
	cl >>= cl;
	SCZO = cond(cl);
	ch = ch - bh - C;
	cl <<= cl;
	SCZO = cond(cl);
	if (Test(EQ,Z))
		fn0040D4AB();
	else
		fn0040D8D1();
}

// 0040D665: define fn0040D665
// Called from:
//      fn0040DAC5
define fn0040D665
{
	esp = fp;
	Top = 0;
	dl >>= cl;
	v7 = (edx & 0x01 << 0x1B) != 0x00;
	edx = __ror<word32,byte>(edx, 0x1B);
	C = v7;
	v10 = (ah & 0x01 << cl) != 0x00;
	ah = __rcr<byte,byte>(ah, cl, C);
	bh -= al;
	SCZO = cond(bh);
	bh = bh - ~0x15 - C;
	edi -= edx;
	al >>= cl;
	eax >>= cl;
	SCZO = cond(eax);
	if (Test(EQ,Z))
		fn0040D564();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D564();
		else
		{
			v18 = edx;
			edx = eax;
			eax = v18;
			SCZO = cond(eax - 3686677548);
			fn0040D68C();
		}
	}
}

// 0040D68C: define fn0040D68C
// Called from:
//      fn0040D665
//      fn0040DAC5
define fn0040D68C
{
	esp = fp;
	Top = 0;
	bl <<= cl;
	dl = dl ^ 0x3F;
	edi >>= 0x1C;
	SCZO = cond(edi);
	v12 = (edx & 0x01 << cl) != 0x00;
	edx = __rcr<word32,byte>(edx, cl, C);
	ebx >>= cl;
	dh = dh ^ 0x8C;
	C.u0 = false;
	bl = cl;
	v17 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v17;
	v18 = (dh & 0x01 << cl) != 0x00;
	dh = __rcr<byte,byte>(dh, cl, C);
	bh += 211;
	eax = ~eax;
	esi >>= cl;
	SCZO = cond(esi);
	&bl.u5->u0 = (byte) bl + 1;
	dl &= ah;
	v24 = (ebx & 0x01 << 0x20 - 0x0F) != 0x00;
	ebx = __rol<word32,byte>(ebx, 0x0F);
	v25 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v25;
	bl.u0 = 0x13;
	dh = dh + bh + C;
	SCZO = cond(dh);
	v26 = (ebx & 0x01 << 0x20 - cl) != 0x00;
	ebx = __rcl<word32,byte>(ebx, cl, C);
	C = v26;
	&edx.u5->u0 = (word32) edx + 1;
	--ebx;
	SZO = cond(ebx);
	fn0040D842();
}

// 0040D6D2: define fn0040D6D2
// Called from:
//      fn0040D84A
//      fn0040DAC5
define fn0040D6D2
{
	esp = fp;
	Top = 0;
	ebx -= ecx;
	dl |= 0xB8;
	dl = dl ^ al;
	C.u0 = false;
	dh = (ui8) ((bool) C.u0 + (dh + bl));
	bl <<= cl;
	bh = -bh;
	eax = ecx;
	bh |= 0x7F;
	v19 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	dh |= bh;
	C.u0 = false;
	bl = dh;
	bh = (bool) C.u0 + (bh + 0x77);
	dl = dl ^ bh;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	fn0040D58E();
}

// 0040D746: define fn0040D746
// Called from:
//      fn0040D438
//      fn0040D469
define fn0040D746
{
	ptr32 fp;
	byte dh;
	bool C;
	byte dl;
	word16 edx_16_16;
	word32 eax;
	word32 esi;
	word32 dwArg00;
	word32 dwArg04;
	Top_3 = 0;
	dh_7 = dh - 0x2E - (byte) C;
	edx_11 = SEQ(edx_16_16, dh_7, dl);
	edx_13 = edx_11 ^ eax;
	dh_22 = SLICE(edx_13, byte, 8);
	dl_60 = (byte) edx_13;
	edx_16_16_61 = SLICE(edx_13, word16, 16);
	dh_23 = -dh_22;
	esi_31 = esi >> 0x1E;
	ch_41 = SLICE(dwArg00, byte, 8);
	cl_42 = (byte) dwArg00;
	ecx_16_16_50 = SLICE(dwArg00, word16, 16);
	ebx_39 = dwArg04;
	esp_40 = fp + 8;
	ch_43 = (byte) &(cl_42.u5 + ch_41 /8 0x0A)->u0;
	SCZO_44 = cond(ch_43);
	C_46.u0 = SLICE(SCZO_44, bool, 1);
	v22_45 = (eax & 0x01 << 0x20 - cl_42) != 0x00;
	eax_47 = __rcl<word32,byte>(eax, cl_42, C_46);
	dh_49 = (bool) v22_45 + (dh_23 + ~0x0A);
	ecx_51 = SEQ(ecx_16_16_50, ch_43, cl_42);
	ecx_52 = ecx_51 >> cl_42;
	ch_53 = SLICE(ecx_52, byte, 8);
	cl_63 = (byte) ecx_52;
	ecx_16_16_73 = SLICE(ecx_52, word16, 16);
	SCZO_55 = cond(ch_53 - 191);
	C_65.u0 = SLICE(SCZO_55, bool, 1);
	ah_57 = SLICE((word32) eax_47 + 1, byte, 8);
	eax_16_16_70 = SLICE((word32) eax_47 + 1, word16, 16);
	al_71 = (byte) eax_47 + 0x01;
	SZO_59 = cond(ah_57 - 0x01);
	edx_62 = SEQ(edx_16_16_61, dh_49, dl_60);
	O_75 = SLICE(SZO_59, bool, 4);
	S_76 = (bool) SZO_59;
	Z_77 = SLICE(SZO_59, bool, 2);
	v24_64 = (edx_62 & 0x01 << 0x20 - cl_63) != 0x00;
	edx_66 = __rcl<word32,byte>(edx_62, cl_63, C_65);
	C_67 = v24_64;
	eax_72 = SEQ(eax_16_16_70, ah_57 - 0x01, al_71);
	ecx_74 = SEQ(ecx_16_16_73, ch_53 - 191, cl_63);
	fn0040DAE4();
}

// 0040D786: define fn0040D786
// Called from:
//      Win32CrtStartup
define fn0040D786
{
	esp = fp;
	Top = 0;
	v5 = (cl & 0x01 << cl) != 0x00;
	cl = __rcr<byte,byte>(cl, cl, C);
	dl = dl ^ bh;
	C.u0 = false;
	--bl;
	v13 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rcl<word32,byte>(edx, cl, C);
	v15 = (edx & 0x01 << 0x20 - 0x1D) != 0x00;
	edx = __rol<word32,byte>(edx, 0x1D);
	bl >>= cl;
	v17 = (ecx & 0x01 << 0x20 - cl) != 0x00;
	ecx = __rol<word32,byte>(ecx, cl);
	eax <<= cl;
	SCZO = cond(eax);
	v21 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	esp -= 4;
	*esp = ecx;
	ah &= ch;
	esi &= eax;
	C.u0 = false;
	dl = dl - 0x94 - C;
	SCZO = cond(dl);
	al = -al;
	bh = -bh;
	ah <<= cl;
	ah >>= cl;
	ecx |= ebx;
	C.u0 = false;
	v27 = (eax & 0x01 << cl) != 0x00;
	eax = __rcr<word32,byte>(eax, cl, C);
	ch |= 0x18;
	v28 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	edi >>= cl;
	SCZ = cond(edi);
	--ebx;
	SZO = cond(ebx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			if (Test(OV,O))
				__syscall<byte>(0x04);
			ax = __aad(ax);
			bh = ~0x14;
			if (Test(ULE,CZ))
			{
				fn0040D9A6();
				return;
			}
			else
			{
				fn0040D9A6();
				return;
			}
		}
	}
	v31 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	C = v31;
	v32 = esp;
	esp -= 4;
	*esp = v32;
	v33 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rcl<byte,byte>(bl, cl, C);
	C = v33;
	ebx = ebx + edx + C;
	SCZO = cond(ebx);
	fn0040DD56();
}

// 0040D7AA: define fn0040D7AA
// Called from:
//      fn0040D650
//      fn0040D84A
define fn0040D7AA
{
	esp = fp;
	Top = 0;
	eax += ebx;
	SCZO = cond(eax);
	dl = (bool) C + (dl + 0x04);
	v12 = (dh & 0x01 << cl) != 0x00;
	dh = __ror<byte,byte>(dh, cl);
	bh += bl;
	bl = 0x93;
	dh = ~dh;
	esi |= edi;
	++bl;
	bh = bh ^ 121;
	C.u0 = false;
	edi = (ui32) ((bool) C.u0 + (edi + eax));
	eax = eax ^ ~0x0137;
	SZ = cond(eax);
	O = false;
	C.u0 = false;
	fn0040D68C();
}

// 0040D81F: define fn0040D81F
// Called from:
//      fn0040DAC5
define fn0040D81F
{
	esp = fp;
	Top = 0;
	edx >>= 0x08;
	SCZ = cond(edx);
	v7 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rcl<byte,byte>(cl, cl, C);
	C = v7;
	bh = bh - cl - C;
	bl = bl ^ ~0x51;
	dh |= 0x38;
	bh = -bh;
	edx -= eax;
	SCZO = cond(edx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			C = __das(al, &al);
			v20 = Mem0[ebx + 0x00:word32] + edx + C;
			*ebx.u0 = v20;
			SCZO = cond(v20);
			--edi;
			SZO = cond(edi);
			fn0040D842();
			return;
		}
	}
	--ch;
	bh = bh - bl - C;
	ecx = *esp;
	++esp;
	ebx >>= 0x12;
	SCZ = cond(ebx);
	v24 = (eax & 0x01 << 0x20 - cl) != 0x00;
	eax = __rcl<word32,byte>(eax, cl, C);
	ebx.u0 += ecx;
	v26 = (esi & 0x01 << 0x13) != 0x00;
	esi = __ror<word32,byte>(esi, 0x13);
	ah <<= cl;
	C = ebx != 0x00;
	ebx = -ebx;
	SZO = cond(ebx);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			v29 = ax;
			ah = (int8) (v29 % edx->b9EC5189E);
			al = (int8) (v29 /8 edx->b9EC5189E);
			SCZO = cond(al);
		}
	}
	edx = edx + ebx + C;
	SCZO = cond(edx);
	al = 133;
	bh = ~0x22;
	al = (int8) &(C.u3 + (al + bl) /8 0x0A)->u0;
	SCZO = cond(al);
	edx >>= cl;
	SCZ = cond(edx);
	fn0040D928();
}

// 0040D842: define fn0040D842
// Called from:
//      fn0040D68C
//      fn0040DAC5
define fn0040D842
{
	esp = fp;
	Top = 0;
	eax |= eax;
	SZ = cond(eax);
	O = false;
	C = false;
	if (Test(NE,Z))
		fn0040D928();
	else
		fn0040D84A();
}

// 0040D84A: define fn0040D84A
// Called from:
//      fn0040D842
//      fn0040DAC5
define fn0040D84A
{
	esp = fp;
	Top = 0;
	edx <<= 0x07;
	SCZO = cond(edx);
	dl = dl - ah - C;
	ebx <<= cl;
	edx <<= cl;
	bh += 22;
	SCZO = cond(bh);
	bh = bh - bl - C;
	SCZO = cond(bh);
	if (Test(EQ,Z))
		fn0040D6D2();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D6D2();
		else
		{
			ebp = 3939662973;
			fn0040D869();
		}
	}
}

// 0040D869: define fn0040D869
// Called from:
//      fn0040D84A
//      fn0040DB09
define fn0040D869
{
	esp = fp;
	Top = 0;
	dl >>= cl;
	esi <<= cl;
	SCZO = cond(esi);
	&edx.u5->u0 = (word32) edx + 1;
	v10 = (edx & 0x01 << 0x04) != 0x00;
	edx = __rcr<word32,byte>(edx, 0x04, C);
	dl = -dl;
	dl = dl ^ al;
	esi <<= 0x02;
	dl &= 0x0C;
	SZ = cond(dl);
	O = false;
	C.u0 = false;
	fn0040D87B();
}

// 0040D87B: define fn0040D87B
// Called from:
//      fn0040D650
//      fn0040D869
define fn0040D87B
{
	esp = fp;
	Top = 0;
	fn0040D7AA();
}

// 0040D8D1: define fn0040D8D1
// Called from:
//      fn0040D650
//      fn0040DB4B
define fn0040D8D1
{
	word32 eax;
	bool Z;
	word32 edx;
	word32 edi;
	word32 ebx;
	bool O;
	bool C;
	selector ds;
	word32 ebp;
	word32 ecx;
	word32 esi;
	bool S;
	Top_3 = 0;
	eax_5 = eax;
	if (Z)
		fn0040D4AB();
	else if (O)
		fn0040D87B();
	else
	{
		edx_23 = ~edx;
		fn0040D4AB();
	}
}

// 0040D928: define fn0040D928
// Called from:
//      fn0040D842
//      fn0040DAC5
define fn0040D928
{
	esp = fp;
	Top = 0;
	bh -= bl;
	SCZO = cond(bh);
	fn0040D665();
}

// 0040D9A6: define fn0040D9A6
// Called from:
//      fn0040D786
//      fn0040DC3B
define fn0040D9A6
{
	esp = fp;
	Top = 0;
	edx -= edi;
	SCZO = cond(edx);
	dh = dh - 0xC3 - C;
	SCZO = cond(dh);
	edx = edx - esi - C;
	ebx <<= 0x01;
	bh <<= cl;
	bl += ah;
	++dl;
	bl |= 0x09;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			ebp = edi - 0x0E;
			__out<byte>(0xC4, al);
			ecx -= eax;
			SCZO = cond(ecx);
			edx->u0 = 0x80;
			fnD411DC3F();
			return;
		}
	}
	esp -= 4;
	esp->u0 = (word32) ecx;
	v25 = (edx & 0x01 << 0x0C) != 0x00;
	edx = __ror<word32,byte>(edx, 0x0C);
	dl |= 77;
	C.u0 = false;
	dl = dl - bl - C;
	bl = bl ^ cl;
	bl += 0xB4;
	dl |= ~0x11;
	edx <<= 0x15;
	SCZO = cond(edx);
	bl = bl - bh - C;
	v26 = (esi & 0x01 << 0x20 - 0x04) != 0x00;
	esi = __rol<word32,byte>(esi, 0x04);
	dh -= 100;
	SCZO = cond(dh);
	eax += 0x0078;
	v27 = (edx & 0x01 << 0x04) != 0x00;
	edx = __rcr<word32,byte>(edx, 0x04, C);
	C = v27;
	v28 = (esi & 0x01 << 0x12) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x12, C);
	--dh;
	bh >>= cl;
	ebx = (word32) ecx.u0 + ebx;
	SCZO = cond(ebx);
	bl = (ui8) ((bool) C.u0 + (bl + 0x5E));
	SCZO = cond(bl);
	v29 = (edx & 0x01 << 0x20 - 0x1C) != 0x00;
	edx = __rol<word32,byte>(edx, 0x1C);
	C = v29;
	if (Test(EQ,Z))
		fn0040D438();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D438();
		else
		{
			ds.u1 = esp->u1;
			esp = (union Eq_5658 *) ((char *) esp + 2);
		}
	}
}

// 0040DA85: define fn0040DA85
// Called from:
//      fn0040D605
//      fn0040D665
define fn0040DA85
{
	esp = fp;
	Top = null;
	fn0040D5F6();
}

// 0040DAB9: define fn0040DAB9
// Called from:
//      fn0040D5F6
//      fn0040D650
define fn0040DAB9
{
	esp = fp;
	Top = 0;
	ch = bl;
	v7 = (edi & 0x01 << cl) != 0x00;
	edi = __ror<word32,byte>(edi, cl);
	cl = cl ^ dh;
	SZ = cond(cl);
	O = false;
	C = false;
	fn0040DABF();
}

// 0040DABF: define fn0040DABF
// Called from:
//      fn0040D5F6
//      fn0040DAB9
define fn0040DABF
{
	esp = fp;
	Top = 0;
	++esi;
	SZO = cond(esi);
	fn0040DAC5();
	&esp.u5->u0 = (word32) esp + 0x0F0A;
	fn0040DAC5();
}

// 0040DAC5: define fn0040DAC5
// Called from:
//      fn0040DABF
define fn0040DAC5
{
	esp = fp;
	Top = 0;
	bl += bh;
	SCZO = cond(bl);
	ch = ch - ~0x24 - C;
	dl >>= cl;
	SCZO = cond(dl);
	esi >>= 0x17;
	SCZ = cond(esi);
	v13 = (edi & 0x01 << cl) != 0x00;
	edi = __rcr<word32,byte>(edi, cl, C);
	C = v13;
	if (Test(EQ,Z))
		fn0040D81F();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D81F();
		else
		{
			eax = eax ^ 493611949;
			SZ = cond(eax);
			O = false;
			C.u0 = false;
			fn0040DAE4();
		}
	}
}

// 0040DAE4: define fn0040DAE4
// Called from:
//      fn0040D9A6
//      fn0040DAC5
define fn0040DAE4
{
	esp = fp;
	Top = 0;
	v4 = (edx & 0x01 << 0x06) != 0x00;
	edx = __rcr<word32,byte>(edx, 0x06, C);
	ch >>= cl;
	dh -= 0x92;
	ecx <<= cl;
	ebx -= ~0x0528;
	esi = eax;
	ah &= bl;
	eax >>= cl;
	cl += dh;
	SCZO = cond(cl);
	if (Test(EQ,Z))
		fn0040DB25();
	else
		fn0040DAFE();
}

// 0040DAFE: define fn0040DAFE
// Called from:
//      fn0040DAC5
//      fn0040DAE4
define fn0040DAFE
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040DB25();
	else
	{
		al |= 0x93;
		v13 = edi->dw002C & esi;
		edi->dw002C = v13;
		SZ = cond(edi->dw002C);
		O = false;
		C = false;
	}
}

// 0040DB09: define fn0040DB09
// Called from:
//      fn0040D665
define fn0040DB09
{
	esp = fp;
	Top = 0;
	edx = (word32) al;
	v6 = (esi & 0x01 << 0x20 - 0x1D) != 0x00;
	esi = __rol<word32,byte>(esi, 0x1D);
	bh += cl;
	bh.u0 = ~0x04;
	ebx <<= 0x08;
	v13 = (bl & 0x01 << cl) != 0x00;
	bl = __ror<byte,byte>(bl, cl);
	++ebx;
	++ebx;
	SZO = cond(ebx);
	v16 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rol<word32,byte>(edi, cl);
	C = v16;
	bh <<= cl;
	SCZO = cond(bh);
	bh.u0 = 117;
	v18 = (bh & 0x01 << cl) != 0x00;
	bh = __rcr<byte,byte>(bh, cl, C);
	bl.u0 = 0x9A;
	ebx = (word32) ah;
	esi <<= 0x10;
	SCZO = cond(esi);
	v20 = (esi & 0x01 << 0x1B) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x1B, C);
	edi -= ebx;
	esi |= eax;
	eax >>= 0x10;
	SCZO = cond(eax);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			D = true;
			al += 0x1A;
			SCZO = cond(al);
			eax = *(uint32 *) ~0x2D88D9B2;
			--ecx;
			if (ecx != 0x00)
			{
				fn0040DD32();
				return;
			}
		}
	}
	&edi.u5->u0 = &(edi.u5 + ecx / 0x0A)->u0;
	SCZO = cond(edi);
	v27 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	--esi;
	v28 = (esi & 0x01 << 0x18) != 0x00;
	esi = __ror<word32,byte>(esi, 0x18);
	edi = edi ^ eax;
	edi <<= cl;
	SCZO = cond(edi);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			esp = esp->ptr0000;
			esp = (struct Eq_6057 *) ((char *) &esp->ptr0000 + 4);
			C = __aaa(al, ah, &al, &ah);
		}
	}
	esi <<= 0x04;
	&edi.u5->u0 = (word32) edi + 1;
	esi <<= 0x06;
	eax += edx;
	SCZO = cond(eax);
	edx = edx - esi - C;
	dh = (byte) bl.u0 + dh;
	SCZO = cond(dh);
	dl = (byte) &(C.u3 + ((byte) bl.u0 + dl) /8 0x0A)->u0;
	SCZO = cond(dl);
	dh = (byte) &(C.u3 + (dh + ah) /8 0x0A)->u0;
	esi >>= 0x09;
	SCZO = cond(esi);
	fn0040D869();
}

// 0040DB25: define fn0040DB25
// Called from:
//      fn0040DAC5
//      fn0040DAE4
define fn0040DB25
{
	esp = fp;
	Top = 0;
	v6 = (edx & 0x01 << 0x20 - 0x10) != 0x00;
	edx = __rol<word32,byte>(edx, 0x10);
	al += ah;
	cl &= bl;
	C.u0 = false;
	al = (bool) C.u0 + (al + 222);
	SCZO = cond(al);
	v16 = (esi & 0x01 << cl) != 0x00;
	esi = __rcr<word32,byte>(esi, cl, C);
	ch = 0x24;
	ah &= 0xC5;
	C.u0 = false;
	esi = esi - eax - C;
	ah += 0x12;
	eax >>= cl;
	SCZ = cond(eax);
	esp -= 4;
	*esp = ebx;
	--dh;
	SZO = cond(dh);
	fn0040DBC9();
}

// 0040DB4B: define fn0040DB4B
// Called from:
//      fn0040D5DB
//      fn0040D9A6
define fn0040DB4B
{
fn0040DB4B_entry:
	esp = fp
	Top = 0
	bl = bl | ah
	ebx = ebx - ecx
	bl = bl - 0x96
	&esi.u5->u0 = (word32) esi + 1
	&v16.u5->u0 = eax->t0010.u5
	esp = esp - 4
	esp->u5 = (Eq_3 (*)[]) v16
	esi = esi ^ eax
	bh = bh - al
	ebx = ecx
	edi = edi | esi
	bl = bl + 0x01
	edi = ebx
	ebx = ebx & ecx
	edi = edi << cl
	SCZO = cond(edi)
	bl = bl - 0x01
	edx = edx << cl
	SCZO = cond(edx)
	v22 = (edx & 0x01 << 0x20 - cl) != 0x00
	edx = __rcl<word32,byte>(edx, cl, C)
	&edx.u5->u0 = esp->u5
	esp = (union Eq_3 *) ((char *) esp + 4)
	v23 = (ebx & 0x01 << 0x20 - cl) != 0x00
	ebx = __rol<word32,byte>(ebx, cl)
	bl = bl << cl
	SCZO = cond(bl)
	v24 = (esi & 0x01 << 0x20 - cl) != 0x00
	esi = __rcl<word32,byte>(esi, cl, C)
	v25 = (ebx & 0x01 << cl) != 0x00
	ebx = __ror<word32,byte>(ebx, cl)
	ebx = ebx >> 0x08
	esi = esi << cl
	bh = bh >> cl
	SCZO = cond(bh)
	bh = (uint8) ((bool) C.u0 + (bh + 0xA9))
	SCZO = cond(bh)
	branch Test(EQ,Z) l0040D886
	goto l0040DC10
l0040DB4B:
l0040DBF1:
l0040DC0A_thunk_fn0040DC1F:
	fn0040DC1F()
	return
l0040DC10:
	eax = eax
	branch Test(NE,Z) l0040D886
fn0040DB4B_exit:
}

// 0040DBC9: define fn0040DBC9
// Called from:
//      fn0040D591
//      fn0040DAC5
define fn0040DBC9
{
	esp = fp;
	Top = 0;
	v6 = (esi & 0x01 << 0x15) != 0x00;
	esi = __rcr<word32,byte>(esi, 0x15, C);
	C = v6;
	ah = (byte) &(C.u3 + (ah + dl) /8 0x0A)->u0;
	dl = 0x56;
	&dh.u5->u0 = &(dh.u5 + ch /8 0x0A)->u0;
	dh |= 0x36;
	C.u0 = false;
	v16 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	C = v16;
	v17 = (cl & 0x01 << 0x08 - cl) != 0x00;
	cl = __rcl<byte,byte>(cl, cl, C);
	cl >>= cl;
	ebx += ~0x0528;
	v21 = (edx & 0x01 << 0x20 - cl) != 0x00;
	edx = __rol<word32,byte>(edx, cl);
	al >>= cl;
	ah &= ~0x25;
	SZ = cond(ah);
	O = false;
	C.u0 = false;
	fn0040DD2C();
}

// 0040DC1F: define fn0040DC1F
// Called from:
//      fn0040DB4B
//      fn0040DD6A
define fn0040DC1F
{
}

// 0040DC3B: define fn0040DC3B
// Called from:
//      fn0040D58E
//      fn0040D591
define fn0040DC3B
{
	esp = fp;
	Top = 0;
	dl &= ~0x58;
	edx <<= 0x15;
	&bl.u5->u0 = (byte) bl + 80;
	edi <<= cl;
	bh |= 0x7F;
	bl = bl ^ al;
	SZ = cond(bl);
	O = false;
	C.u0 = false;
	edi = esi;
	edx = eax + 80;
	v17 = (edi & 0x01 << 0x20 - cl) != 0x00;
	edi = __rcl<word32,byte>(edi, cl, C);
	v18 = (bl & 0x01 << 0x08 - cl) != 0x00;
	bl = __rol<byte,byte>(bl, cl);
	C = v18;
	esi = ecx;
	esi <<= cl;
	SCZO = cond(esi);
	&bl.u5->u0 = (byte) bl + 1;
	bh = (ui8) ((bool) C.u0 + (bh + 0x30));
	v21 = (edi & 0x01 << 0x20 - 0x12) != 0x00;
	edi = __rol<word32,byte>(edi, 0x12);
	bh = 0x86;
	esi >>= 0x18;
	v22 = (esi & 0x01 << cl) != 0x00;
	esi = __ror<word32,byte>(esi, cl);
	C = v22;
	bh = (ui8) ((bool) C.u0 + (bh + al));
	++bh;
	bh = bh ^ dh;
	C.u0 = false;
	v24 = *edx;
	esp -= 4;
	*esp = v24;
	--bh;
	SZO = cond(bh);
	bl.u0 = 0x01;
	if (Test(EQ,Z))
		fn0040D9A6();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D9A6();
		else
		{
			SCZO = cond(eax - *edi);
			&edi.u5->u0 = (word32) edi + 4;
		}
	}
}

// 0040DD2C: define fn0040DD2C
// Called from:
//      fn0040DAC5
define fn0040DD2C
{
	esp = fp;
	Top = 0;
	dl <<= cl;
	edi += esi;
	SCZO = cond(edi);
	fn0040DD30();
}

// 0040DD30: define fn0040DD30
// Called from:
//      fn0040DD2C
define fn0040DD30
{
	esp = fp;
	Top = 0;
	edi -= edx;
	SCZO = cond(edi);
	fn0040DD32();
}

// 0040DD32: define fn0040DD32
// Called from:
//      fn0040DB09
//      fn0040DD30
define fn0040DD32
{
	esp = fp;
	Top = 0;
	ah |= al;
	edi -= esi;
	SCZO = cond(edi);
	v15 = (eax & 0x01 << cl) != 0x00;
	eax = __ror<word32,byte>(eax, cl);
	dl = 0xA0;
	eax >>= cl;
	SCZ = cond(eax);
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
		{
			SCZO = cond(*esi - *edi);
			++esi;
			++edi;
			esp->aCFD3CB89[ecx] = 332649044;
			fn0040DD56();
			return;
		}
	}
	eax.u0 = 0x87C71301;
	fn0040D622();
}

// 0040DD56: define fn0040DD56
// Called from:
//      fn0040D786
//      fn0040DB09
define fn0040DD56
{
	esp = fp;
	Top = null;
	*Top -= (real64) *ebx;
	v8 = (edx & 0x01 << cl) != 0x00;
	edx = __ror<word32,byte>(edx, cl);
	edx <<= cl;
	SCZO = cond(edx);
	v11 = (dh & 0x01 << 0x08 - cl) != 0x00;
	dh = __rcl<byte,byte>(dh, cl, C);
	ch <<= cl;
	eax <<= 0x11;
	SCZO = cond(eax);
	if (Test(EQ,Z))
		fn0040D53E();
	else
		fn0040DD6A();
}

// 0040DD6A: define fn0040DD6A
// Called from:
//      fn0040D786
//      fn0040DD56
define fn0040DD6A
{
	esp = fp;
	Top = 0;
	eax = eax;
	if (Test(NE,Z))
		fn0040D53E();
	else
	{
		edi = 3333228464;
		fnDB38C54F();
		fn0040D9A6();
	}
}

// 0040DE07: define fn0040DE07
// Called from:
//      fn0040D591
//      fn0040D5AE
define fn0040DE07
{
	esp = fp;
	Top = 0;
	esi <<= 0x05;
	SCZO = cond(esi);
	edi = edi - ecx - C;
	ecx >>= 0x11;
	SCZO = cond(ecx);
	ecx = ecx + edx + C;
	SCZO = cond(ecx);
	v11 = (ecx & 0x01 << 0x20 - 0x14) != 0x00;
	ecx = __rcl<word32,byte>(ecx, 0x14, C);
	&ch.u5->u0 = (byte) ch.u1 + bh;
	v15 = (ch & 0x01 << 0x08 - cl) != 0x00;
	ch = __rol<byte,byte>(ch, cl);
	C = v15;
	dh = ~dh;
	ch = ch + al + C;
	esi <<= cl;
	v18 = (ch & 0x01 << cl) != 0x00;
	ch = __ror<byte,byte>(ch, cl);
	C = v18;
	esi = esi + edx + C;
	SCZO = cond(esi);
	v19 = (esi & 0x01 << 0x17) != 0x00;
	esi = __ror<word32,byte>(esi, 0x17);
	edi |= ecx;
	ecx = ebx;
	ch >>= cl;
	SCZO = cond(ch);
	ch = ch - ~0x49 - C;
	SCZO = cond(ch);
	ch = ~ch;
	if (Test(NE,Z))
	{
		eax = eax;
		if (Test(EQ,Z))
			__halt();
	}
	--esi;
	dh = -dh;
	ecx <<= 0x1E;
	v26 = (cl & 0x01 << cl) != 0x00;
	cl = __ror<byte,byte>(cl, cl);
	cl = cl ^ ~0x31;
	ch <<= cl;
	ch -= 116;
	edi -= ebx;
	SCZO = cond(edi);
	&ch.u5->u0 = &(C.u3 + ((byte) ch + 59) /8 0x0A)->u0;
	edi += eax;
	edi &= eax;
	SZ = cond(edi);
	O = false;
	C.u0 = false;
	if (Test(EQ,Z))
		fn0040D513();
	else
	{
		eax = eax;
		if (Test(NE,Z))
			fn0040D513();
		else
		{
			esp = esp->ptr0000;
			esp = (struct Eq_7063 *) ((char *) &esp->ptr0000 + 4);
			v27 = (edx->t005F.u5 & 0x01 << cl) != 0x00;
			edx->t005F.u5 = (Eq_3 (*)[]) __ror<word32,byte>(edx->t005F.u5, cl);
			C = v27;
			fn0040DBC9();
		}
	}
}

