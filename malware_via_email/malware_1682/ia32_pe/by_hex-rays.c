/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// char __usercall start@<al>(bool@<cf>, int@<eax>, int@<edx>, int _ECX@<ecx>, int@<ebx>, int _EBP@<ebp>, int@<edi>, int@<esi>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN nullsub_1; // weak


//----- (0040C5EF) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall start@<al>(
        bool a1@<cf>,
        int a2@<eax>,
        int a3@<edx>,
        int _ECX@<ecx>,
        int a5@<ebx>,
        int _EBP@<ebp>,
        int a7@<edi>,
        int a8@<esi>)
{
  unsigned int v9; // edi
  int v12; // edi
  bool v15; // zf
  bool v16; // cc
  unsigned int v21; // edi
  char v22; // of
  unsigned int v23; // edi
  bool v24; // tt
  unsigned int v25; // esi
  int v28; // eax
  int v29; // esi
  int v31; // edi
  unsigned int v32; // ebx
  bool v36; // of
  int v39; // esi
  int v40; // edi
  int v41; // eax
  int v45; // esi
  unsigned int v46; // eax
  unsigned int v48; // edx
  unsigned int v49; // ecx
  char v55; // of
  unsigned int v57; // ebx
  unsigned int v58; // ebx
  int v59; // edi
  int v60; // esi
  __m64 v61; // mm0
  unsigned int v62; // ebx
  int v63; // edx
  int v65; // ecx
  int v66; // ecx
  unsigned int v67; // eax
  char v68; // tt
  int v69; // edi
  int v72; // ecx
  int v73; // ecx
  int v74; // edx
  unsigned int v76; // ebx
  bool v77; // cf
  int v78; // edx
  bool v81; // tt
  __int16 v82; // si
  int v88; // edi
  char v90; // of
  unsigned int v91; // ebx
  int v97; // ecx
  int v98; // eax
  bool v99; // sf
  int v100; // ebx
  unsigned int v101; // esi
  int v102; // eax
  char v103; // of
  int v106; // esi
  int v107; // edi
  int v108; // edx
  int v111; // edi
  bool v112; // tt
  int v113; // edi
  int v114; // eax
  int v115; // esi
  char v122; // di
  char v127; // of
  int v128; // esi
  unsigned int v129; // eax
  int v132; // edi
  unsigned int v136; // esi
  int v139; // ebx
  unsigned int v142; // edi
  int v144; // edi
  int v148; // edi
  unsigned int v150; // [esp-4h] [ebp-4h] BYREF

  BYTE1(a2) += _ECX + a1;
  BYTE1(_ECX) -= _ECX;
  v113 = a3 | a7;
  LOBYTE(a2) = (unsigned __int8)a2 >> _ECX;
  LOBYTE(a5) = BYTE1(a3) + (BYTE1(_ECX) | a5);
  v114 = a5 ^ a2;
  --BYTE1(a3);
  a1 = BYTE1(v114) < 0x85u;
  BYTE1(v114) += 123;
  _EDX = a5 + a1 + a3;
  v115 = a8 - 1;
  v139 = -2007031045;
  _EAX = v113 | v114;
  BYTE1(_EAX) &= 0x10u;
  __asm { rcr     ecx, cl }
  LOBYTE(_ECX) = _ECX - (__CFADD__((_BYTE)_EDX, 60) + 34);
  v142 = v113 - 2007031045;
  LOBYTE(_EDX) = __ROL1__(_EDX + 60, _ECX) << _ECX;
  do
  {
    _ECX >>= _ECX;
    LOBYTE(_EDX) = BYTE1(_EAX) ^ _EDX;
    v144 = v142 >> _ECX;
    --BYTE1(_EAX);
    LOBYTE(_ECX) = BYTE1(v139) ^ _ECX;
    __asm { rcr     ah, cl }
    v139 -= 855542931;
    LOBYTE(_EAX) = _EAX - BYTE1(_ECX);
    v148 = v144 >> _ECX;
    BYTE1(_EAX) ^= BYTE1(v139);
    v142 = v148 - _EAX;
  }
  while ( v139 != -26981487 );
  LOBYTE(_ECX) = _ECX ^ 0x4B;
  BYTE1(_EAX) |= 0x5Cu;
  _ECX = _ECX - 26981487;
  LOBYTE(_EAX) = _EAX - 15;
  v40 = _EAX;
  LOBYTE(_ECX) = _ECX ^ 0x65;
  v41 = __ROL4__(_EAX, _ECX);
  BYTE1(_ECX) -= 90;
  _ESI = v115 ^ 0xFE644B91;
  LOBYTE(v41) = _EDX;
  v132 = _ESI | v41 & (v40 >> _ECX);
  _EAX = v41 << _ECX;
  LOBYTE(_ECX) = __ROL1__(_ECX, _ECX);
  if ( __SETP__(_EAX, 0) || !__SETP__(_EAX, 0) )
  {
    __asm { rcr     eax, cl }
    LOBYTE(_ECX) = _ECX - BYTE1(_EDX);
    LOBYTE(_EAX) = (_BYTE)_EAX << _ECX;
    LOBYTE(_ECX) = ((unsigned __int8)_ECX ^ 0x3C) << (_ECX ^ 0x3C);
    v81 = __CFSHR__(_ECX, _ECX);
    _ECX = __ROR4__(_ECX, _ECX);
    v82 = _ESI - 1;
    LOWORD(_EAX) = _EAX - (v81 + v82);
    BYTE1(_EAX) += _EDX;
    BYTE1(_ECX) = __ROR1__(BYTE1(_ECX), _ECX);
    __asm { rcr     cl, cl }
    BYTE1(_ECX) -= 63;
    __asm { rcr     ecx, cl }
    _ECX = __ROL4__(_ECX, _ECX);
    BYTE1(_ECX) += BYTE1(_EDX);
    __asm { rcl     ecx, cl }
    LOBYTE(_ECX) = _ECX | 2;
    LOBYTE(_EAX) = _ECX ^ (_EAX - 17);
    LOWORD(_EAX) = _ECX | (_EAX - 1);
    LOBYTE(_EAX) = _EAX + 111;
    BYTE1(_ECX) += _ECX + __CFSHR__(BYTE1(_EAX), _ECX);
    __asm { rcr     al, cl }
    LOBYTE(_ECX) = ((_BYTE)_ECX << _ECX) + 1;
    LOBYTE(_ECX) = v82 ^ __ROL4__(_ECX, _ECX);
    __asm { rcr     cl, cl }
    JUMPOUT(0x40C0CE);
  }
  _EAX = 57 * *(_DWORD *)v132;
  while ( 1 )
  {
    while ( 1 )
    {
      _ESI <<= _ECX;
      a1 = __CFADD__(_EAX, _EDX);
      _EDX += _EAX;
      BYTE1(v139) += v139 + a1;
      LOBYTE(v139) = BYTE1(_EAX) & v139;
      _ECX = _ECX >> _ECX;
      BYTE1(v139) |= 0x28u;
      v21 = (unsigned int)(v132 << _ECX) >> _ECX;
      LOBYTE(_ECX) = __ROR1__(_ECX, _ECX);
      v9 = v139 ^ v21;
      __asm { rcr     eax, cl }
      BYTE1(_EDX) -= 30;
      _ECX = __ROL4__(_ECX, _ECX);
      if ( v22 || !v22 )
        break;
      LOBYTE(_EDX) = *(_BYTE *)(_EAX + 61) | _EDX;
      BYTE1(_ECX) -= _ECX;
      while ( 1 )
      {
        LOBYTE(_ECX) = _ECX & 0x77;
        a1 = __CFSHR__(v9, _ECX);
        v23 = v9 >> _ECX;
        BYTE1(v139) -= a1 - 15;
        LOBYTE(v139) = v139 + 20;
        v24 = __CFSHL__(v139, _ECX);
        _EBX = __ROL4__(v139, _ECX);
        __asm { rcl     bl, cl }
        v25 = v23 + v24 + _ESI;
        LOBYTE(_EBX) = (_EAX | _EBX) - BYTE1(_EDX);
        BYTE1(_ECX) ^= 0x84u;
        if ( __SETP__(BYTE1(_ECX), 0) || !__SETP__(BYTE1(_ECX), 0) )
          JUMPOUT(0x40C1D2);
        LOBYTE(_EAX) = _EAX - 2;
        __asm { fsubp   st(5), st }
        BYTE1(_ECX) |= _EBX;
        _EBX = _EBX + 1;
        BYTE1(_EAX) += _EDX;
        v28 = _EAX >> _ECX;
        BYTE1(v28) &= 0x20u;
        LOBYTE(_ECX) = BYTE1(_EDX);
        BYTE1(_ECX) -= v28--;
        LOBYTE(v28) = BYTE1(_ECX) | v28;
        v65 = _ECX - (__CFSHL__(v28, BYTE1(_EDX)) + _EBX);
        LOBYTE(v28) = v65 ^ ((_BYTE)v28 << SBYTE1(_EDX));
        a1 = __CFSHL__(v65, v65);
        v66 = v65 << v65;
        v67 = _EBX + a1 + v28;
        --BYTE1(v67);
        a1 = __CFSHL__(BYTE1(v66), v66);
        BYTE1(v66) <<= v66;
        v68 = a1 - 70;
        a1 = BYTE1(v67) < (unsigned __int8)(a1 - 70);
        BYTE1(v67) -= v68;
        LOBYTE(v67) = BYTE1(_EDX) + a1 + ((_BYTE)v67 << v66);
        a1 = __CFADD__((_BYTE)_EDX, (_BYTE)v66);
        LOBYTE(v66) = _EDX + v66;
        _ECX = v66 - (a1 + _EDX);
        BYTE1(_ECX) = (BYTE1(_ECX) << _ECX) - 14;
        LOBYTE(_ECX) = _ECX - BYTE1(v67);
        BYTE1(v67) = BYTE1(v67) + 53 - ((BYTE1(v67) < 0xCBu) + _EDX);
        LOBYTE(_ECX) = BYTE1(_ECX) ^ _ECX;
        v12 = v23 - _ECX;
        _EAX = v67 >> _ECX;
        __asm { rcr     eax, cl }
        BYTE1(_EAX) = -55;
        v101 = v25 << _ECX;
        v102 = v12 & (_EAX << _ECX);
        BYTE1(_ECX) = (char)(BYTE1(_ECX) >> _ECX) >> _ECX;
        BYTE1(v102) += _ECX;
        _ECX = _ECX - 1;
        BYTE1(_ECX) &= 0x1Eu;
        BYTE1(v102) -= 69;
        BYTE1(_EDX) = 101;
        LOBYTE(_EDX) = BYTE1(v102) ^ _EDX;
        LOBYTE(_EBX) = __ROR1__(_EBX, _ECX);
        if ( v103 || !v103 )
        {
          v106 = __ROL4__(v101, _ECX);
          v107 = v102 & (v12 >> _ECX);
          BYTE1(_EDX) = 101 - _EDX;
          v108 = v107 | _EDX;
          _EAX = -786498748;
          _ECX = v107 ^ _ECX;
          __asm { rcl     ebx, cl }
          v112 = __CFSHR__(v107, _ECX);
          v111 = __ROR4__(v107, _ECX);
          BYTE1(_EBX) = 0;
          LOBYTE(v108) = (v112 + v108 + 119) | 0xC6;
          v60 = __ROL4__(v106, 149);
          v61 = _mm_cvtsi32_si64(0xD11EFB44);
          v62 = _EBX >> 21;
          v63 = v108 + 1;
          --BYTE1(_ECX);
          BYTE1(v63) -= 2;
          LOBYTE(_ECX) = 4;
          ++BYTE1(v63);
          LOBYTE(v62) = __ROR1__(v62, 149);
          v32 = v62 >> 4;
          _ECX = _ECX - v60;
          __asm { rcr     eax, cl }
          a1 = __CFSHR__(BYTE1(v63), _ECX);
          SBYTE1(v63) >>= _ECX;
          _EDX = v63 - (a1 + _ECX);
          __asm { rcr     edx, cl }
          v36 = __OFADD__(1, BYTE1(_EDX)++);
          if ( __SETP__(BYTE1(_EDX), 0) || !__SETP__(BYTE1(_EDX), 0) )
          {
            _EDX = v60 ^ _EDX;
            BYTE1(_EAX) += 20;
            __asm { rcl     edx, cl }
            _CL = _m_pextrw(v61, 4);
            __asm { rcr     dl, cl }
            BYTE1(_EDX) ^= (unsigned __int16)(v32 - 2) >> 8;
            _EDX = _EDX - (_EAX >> _CL);
            __asm
            {
              rcl     edx, cl
              rcr     dh, cl
            }
            JUMPOUT(0x40C2CD);
          }
          __readeflags();
          __asm { bound   ebp, [eax+13h] }
          if ( ((_EDX & 0x8000) != 0) ^ v36 | (BYTE1(_EDX) == 0) )
            JUMPOUT(0x40C1B2);
          LOBYTE(_ECX) = _ECX ^ 0x27;
          a1 = __CFSHL__(_ECX, _ECX);
          _ECX = _ECX << _ECX;
          __asm { rcr     dh, cl }
          v39 = v111 + a1 + v60;
          BYTE1(v32) <<= _ECX;
          LOBYTE(_ECX) = BYTE1(v32) | _ECX;
          __asm
          {
            rcl     al, cl
            rcl     cl, cl
          }
          LOBYTE(_EDX) = __ROR1__(_EDX, _ECX);
          v122 = __ROL4__(v39 & v111, _ECX);
          __asm { rcr     dl, cl }
          _EBX = v32 >> _ECX;
          _ECX = _EAX - 1;
          BYTE1(_EDX) = _EAX - 1 - v122;
          a1 = __CFSHL__(v39, _EAX - 1);
          v45 = v39 << (_EAX - 1);
          LOBYTE(_EBX) = BYTE1(_EBX) + a1 + _EBX - 2;
          v46 = 3;
          __asm { rcl     ebx, cl }
          v48 = _EDX + 1;
          --BYTE1(v48);
          BYTE1(_ECX) = 7;
          --v48;
          _EBX = _ECX;
          BYTE1(_EBX) = __ROR1__(7, _ECX);
          _ESI = _EBX ^ v45;
          BYTE1(_EBX) = __ROR1__(BYTE1(_EBX), _ECX);
          BYTE1(v48) = -100;
          LOBYTE(_ECX) = (((unsigned __int8)((unsigned __int16)(v48 >> _ECX) >> 8) >> _ECX)
                        + __CFSHR__((unsigned __int16)(v48 >> _ECX) >> 8, _ECX)
                        + _ECX) & 0x3F;
          BYTE1(_ECX) = 7 << _ECX;
          _EDX = 0;
          __asm { rcl     esi, cl }
        }
        else
        {
          v46 = v102 | 0xA387966B;
          _EBX = v150;
        }
        SBYTE1(_EBX) >>= _ECX;
        __asm { rcr     ch, cl }
        BYTE1(_ECX) -= __CFSHR__(BYTE1(_EBX), _ECX) + _EDX;
        BYTE1(_EBX) = BYTE1(_EBX) >> _ECX << _ECX;
        __asm { rcr     ebx, cl }
        _ECX = _EBX ^ _ECX;
        __GS__ = v46;
        BYTE1(_ECX) <<= _ECX;
        LOBYTE(_EBX) = __ROL1__(_EBX, _ECX);
        BYTE1(_EBX) = (char)((_EDX ^ BYTE1(_EBX) & 0xB1) + 1) >> _ECX++;
        LOBYTE(_ECX) = (_BYTE)_ECX << _ECX;
        __asm { rcr     cl, cl }
        BYTE1(_EBX) &= 0x2Au;
        LOBYTE(_ECX) = _ECX | 0xFE;
        __asm
        {
          rcr     cl, cl
          rcl     ch, cl
        }
        v49 = v46 + __ROR4__(_ECX, _ECX);
        --_EBX;
        _ECX = v49 >> v49;
        LOBYTE(_EBX) = (_BYTE)_EBX << _ECX;
        _ESI = 2 * v46;
        _EBX = (v46 - _EDX) ^ _EDX ^ _EBX;
        __asm { rcl     bl, cl }
        LOBYTE(_ECX) = (v46 & _ECX) + 1;
        BYTE1(_ECX) = 102;
        _EAX = __GS__;
        _ECX = _ECX - _ESI;
        LOBYTE(_EBX) = _EBX - BYTE1(_ECX) - (((unsigned __int8)_EBX < BYTE1(_ECX)) - 1);
        BYTE1(_ECX) >>= _ECX;
        BYTE1(_EBX) = (BYTE1(_EDX) ^ BYTE1(_EBX)) - 1;
        __asm { rcl     bh, cl }
        _ECX = _ESI + _ECX;
        LOBYTE(_ECX) = __ROL1__(_ECX, _ECX);
        BYTE1(_EBX) += BYTE1(_EDX);
        v69 = _EBX;
        a1 = __CFSHL__(BYTE1(_EBX), _ECX);
        BYTE1(_EBX) <<= _ECX;
        __asm { rcr     bh, cl }
        BYTE1(_ECX) ^= __GS^1__;
        _ECX = _ECX << _ECX;
        ++_EDX;
        BYTE1(_EBX) = BYTE1(_EBX) - 1 - ((BYTE1(_EBX) == 0) - 33);
        __asm { rcl     esi, cl }
        LOBYTE(_EBX) = __ROL1__(a1 + _EBX - 9, _ECX);
        v88 = (int)__ROR4__(__ROL4__(v69, _ECX), _ECX) >> _ECX;
        v139 = _EDX + _EBX;
        v29 = __ROR4__(_ESI, _ECX);
        BYTE1(_ECX) = __GS^1__ | (BYTE1(_ECX) >> _ECX);
        _ECX = __ROL4__(_ECX, _ECX);
        BYTE1(v139) = v139 ^ (BYTE1(v139) - 20);
        _ESI = __ROR4__(v29, _ECX);
        LOBYTE(_ECX) = BYTE1(_ECX) + _ECX;
        BYTE1(_ECX) = BYTE1(_ECX) << _ECX << _ECX;
        v31 = v88 - _ESI;
        LOBYTE(v139) = _EDX & v139;
        BYTE1(v139) -= 50;
        __asm { rcl     esi, cl }
        v132 = _ECX ^ v31;
        --BYTE1(_ECX);
        v15 = (_BYTE)_ECX == __GS__;
        v16 = (unsigned __int8)_ECX <= __GS__;
        LOBYTE(_ECX) = _ECX - __GS__;
        if ( !v16 && v16 )
          break;
        ++BYTE1(_ECX);
        v9 = __GS__ + v132 - 1;
        LOBYTE(_ECX) = _ECX + 108;
        if ( _EDX == 20078945 )
        {
          __asm { rcr     dl, cl }
          return __CFSHL__(__GS__, _ECX - (__CFSHL__(BYTE1(_ECX), _ECX) + 71) + 1)
               + (__GS__ << (_ECX - (__CFSHL__(BYTE1(_ECX), _ECX) + 71) + 1))
               + 97;
        }
      }
      _ECX = _ECX - 1;
      if ( !v15 || !_ECX )
      {
        _CL = _ECX - 1;
        __asm
        {
          rep ror dh, cl
          retn
        }
      }
    }
    LOBYTE(_EAX) = _EAX ^ 0x38;
    _EDX = _EDX - v9;
    ++BYTE1(_EDX);
    _ECX = _EDX + __ROL4__(_ECX, _ECX);
    BYTE1(_ECX) = BYTE1(v139);
    _EBX = v139 << _ECX;
    LOBYTE(_EDX) = (unsigned __int8)_EDX >> _ECX;
    _EAX = _EAX << _ECX;
    __asm { rcl     dl, cl }
    if ( _EAX < 0 == v55 && _EAX < 0 != v55 )
      break;
    a1 = __CFADD__((_BYTE)_EDX, (_BYTE)_EBX);
    LOBYTE(_EBX) = _EDX + _EBX;
    LOBYTE(_EAX) = a1 + _EAX - 25;
    BYTE1(_ECX) -= 2;
    BYTE1(_EBX) >>= _ECX;
    v128 = _ESI << _ECX;
    if ( (v128 < 0) ^ v127 | (v128 == 0) || !((v128 < 0) ^ v127 | (v128 == 0)) )
    {
      v72 = __ROL4__(_ECX, _ECX);
      v73 = v72 << v72;
      LOBYTE(v73) = 99;
      v74 = 8 * _EDX;
      _ECX = v74 & v73;
      BYTE1(_EBX) <<= _ECX;
      LOBYTE(_EBX) = __ROR1__(8 * _EBX, _ECX);
      v76 = _EBX << _ECX;
      BYTE1(v74) = 126;
      v77 = __CFSHL__(v74, _ECX);
      v78 = v74 << _ECX;
      _ESI = v78;
      LOBYTE(_EAX) = __ROL1__(_EAX, 99) - (v77 + v76);
      a1 = __CFADD__(BYTE1(_ECX), (_BYTE)_EAX);
      LOBYTE(_EAX) = BYTE1(_ECX) + _EAX;
      LOBYTE(_ECX) = _ECX - (a1 + 101);
      __asm { rcl     esi, cl }
      BYTE1(_ECX) = (char)(BYTE1(_ECX) + 35) >> _ECX;
      v97 = _EAX & _ECX;
      LOBYTE(v76) = v76 | 0x86;
      v98 = _EAX << v97;
      v99 = (int)(v97 + v76) < 0;
      v100 = v97 + v76;
      if ( v100 >= 0 && v99 )
        JUMPOUT(0x40C586);
      _BL = (v100 << v97) + 123;
      _CL = __ROL1__(v97 + 1, v97 + 1) + 1;
      _AL = _CL++ | v98;
      __asm { rcr     bl, cl }
      ++_CL;
      _AL |= 0x4Du;
      __asm { rcr     al, cl }
      JUMPOUT(0x40C02E);
    }
    LOBYTE(_EAX) = _EAX - 54;
    __asm { xlat }
    *(_BYTE *)(v9 + 4 * _EAX - 70002685) = _EBX;
    v129 = _EAX >> _ECX;
    LOBYTE(v129) = v129 - _EBX;
    LOBYTE(_EBX) = _EBX - BYTE1(_EBX);
    LOBYTE(_EDX) = _EDX + 1;
    _EAX = v129 >> _ECX;
    --BYTE1(_EDX);
    _ESI = _EDX & v128;
    BYTE1(_ECX) -= 78;
    a1 = __CFADD__(_ECX, _EDX);
    _DX = _ECX + _EDX;
    _CL = _EBX + a1 + _ECX;
    __asm { rcl     esi, cl }
    _CL = _ESI + 1;
    v139 = _EBX >> (_ESI + 1);
    v132 = _ESI & v9;
    HIBYTE(_DX) >>= _ESI + 1;
    BYTE1(_EAX) >>= _ESI + 1;
    __asm { rcr     dh, cl }
    LOBYTE(v139) = __ROR1__(v139, _CL) << _CL;
    _ECX = v132 | (_ESI + 1);
    BYTE1(_ECX) |= 0x6Bu;
    LOBYTE(_EAX) = BYTE1(_ECX);
    _EDX = v139;
  }
  BYTE1(_ECX) = 7;
  if ( (int)&v150 + 1 < 0 == __OFADD__(1, &v150) )
  {
    LOBYTE(_EBX) = (_BYTE)_EBX << _ECX;
    a1 = __CFSHL__(_EBX, _ECX);
    v57 = _EBX << _ECX;
    BYTE1(v57) -= a1 + _ECX;
    if ( _ECX != 64324 )
    {
      v58 = v57 + 1;
      v59 = __ROL4__(v9, _ECX);
      BYTE1(_EDX) = 103;
      LOBYTE(_ECX) = (_BYTE)_ECX << _ECX;
      LOBYTE(_EDX) = _EDX - 23;
      __asm { rcl     edx, cl }
      BYTE1(_ECX) = _EAX;
      v136 = _ESI << _ECX;
      _CL = __ROR4__(_ECX - (v59 - _ECX), _ECX - (v59 - _ECX));
      _ESI = v136 << _CL;
      __asm { rcl     esi, cl }
      v91 = v58 + 1;
      LOBYTE(v91) = (_BYTE)v91 << _CL;
      if ( !v90 && v90 )
      {
        --*(_BYTE *)(v91 + 1);
        __asm { retf    0F3D3h }
      }
      JUMPOUT(0x40C691);
    }
    JUMPOUT(0x40C8A1);
  }
  return ((int (*)(void))nullsub_1)();
}
// 40BF81: positive sp value 4 has been found
// 40BF7E: control flows out of bounds to 40BF7F
// 40C0C9: inconsistent fpu stack
// 40C15B: control flows out of bounds to 40C15E
// 40C585: control flows out of bounds to 40C586
// 40C97B: control flows out of bounds to 40C97C
// 40C7CB: control flows out of bounds to 40C257
// 40BF0E: control flows out of bounds to 40C0CE
// 40BF57: control flows out of bounds to 40C8A1
// 40C1E0: control flows out of bounds to 40C423
// 40C354: control flows out of bounds to 40C193
// 40C3E9: control flows out of bounds to 40C02E
// 40C497: control flows out of bounds to 40C2CD
// 40C555: control flows out of bounds to 40C500
// 40C8EF: control flows out of bounds to 40C877
// 40C0B7: control flows out of bounds to 40C1D2
// 40C13A: control flows out of bounds to 40C1B2
// 40C388: control flows out of bounds to 40C393
// 40C4EC: control flows out of bounds to 40C691
// 40C7ED: conditional instruction was optimized away because cl.1!=0
// 40C155: conditional instruction was optimized away because cl.1!=0
// 40C18A: conditional instruction was optimized away because cl.1!=0
// 40C220: conditional instruction was optimized away because ecx.4!=0
// 40C24B: conditional instruction was optimized away because cl.1!=0
// 40C2F2: conditional instruction was optimized away because ah.1!=0
// 40C382: conditional instruction was optimized away because cl.1==4
// 40C3AD: conditional instruction was optimized away because ah.1!=0
// 40C897: conditional instruction was optimized away because esi.4>=1
// 40C67B: variable 'v127' is possibly undefined
// 40C08A: variable 'v22' is possibly undefined
// 40C2B8: variable 'v55' is possibly undefined
// 40C4EC: variable 'v90' is possibly undefined
// 40C5A3: variable 'v103' is possibly undefined

// nfuncs=2 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
