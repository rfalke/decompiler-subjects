// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

CHAR g_t404010 = 'a'; // 00404010
word32 g_dw404064 = 0x00; // 00404064
Eq_2 g_t404068 = // 00404068
	{
		null
	};
int32 g_dw40406C = 0; // 0040406C
int32 g_dw404070 = 0; // 00404070
Eq_144 g_t404074 = // 00404074
	{
		0
	};
int32 g_dw404078 = 0; // 00404078
word32 g_dw40407C = 0x00; // 0040407C
Eq_2 g_t404080 = // 00404080
	{
		null
	};
ptr32 g_ptr404084 = 0x00; // 00404084
int32 g_dw404088 = 0; // 00404088
word32 g_dw40408C = 0x00; // 0040408C
int32 g_dw404090 = 0; // 00404090
Eq_2 g_t404094 = // 00404094
	{
		null
	};
word32 g_dw404098 = 0x00; // 00404098
Eq_33 g_t40409C = // 0040409C
	{
		0
	};
Eq_38 g_t4040A0 = // 004040A0
	{
		0
	};
Eq_2 g_t4040A4 = // 004040A4
	{
		null
	};
struct Eq_862 * g_ptr4040A8 = null; // 004040A8
<anonymous> * g_ptr4040AC = null; // 004040AC
Eq_102 g_t4040B0 = // 004040B0
	{
		0
	};
ui32 g_dw4040B4 = 0x00; // 004040B4
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetBkColor = &g_t352A; // 00403000
<anonymous> * __imp__AddAtomA = &g_t3214; // 00403008
<anonymous> * __imp__CloseHandle = &g_t3220; // 0040300C
<anonymous> * __imp__ReadFile = &g_t322E; // 00403010
<anonymous> * __imp__SetFilePointer = &g_t323A; // 00403014
<anonymous> * __imp__GetFileSize = &g_t324C; // 00403018
<anonymous> * __imp__GetModuleFileNameA = &g_t325A; // 0040301C
<anonymous> * __imp__GetStartupInfoA = &g_t3270; // 00403020
<anonymous> * __imp__GetModuleHandleA = &g_t3282; // 00403024
<anonymous> * __imp__HeapFree = &g_t3296; // 00403028
<anonymous> * __imp__ExitProcess = &g_t3206; // 0040302C
<anonymous> * __imp__HeapAlloc = &g_t32B4; // 00403030
<anonymous> * __imp__VirtualAlloc = &g_t32C0; // 00403034
<anonymous> * __imp__VirtualFree = &g_t32D0; // 00403038
<anonymous> * __imp__UnmapViewOfFile = &g_t32DE; // 0040303C
<anonymous> * __imp__MapViewOfFileEx = &g_t32F0; // 00403040
<anonymous> * __imp__CreateFileMappingA = &g_t3302; // 00403044
<anonymous> * __imp__GetProcAddress = &g_t3318; // 00403048
<anonymous> * __imp__LoadLibraryA = &g_t332A; // 0040304C
<anonymous> * __imp__GetProcessHeap = &g_t32A2; // 00403050
<anonymous> * __imp__CreateFileA = &g_t31F8; // 00403054
<anonymous> * __imp__SetParent = &g_t3360; // 0040305C
<anonymous> * __imp__GetDC = &g_t336C; // 00403060
<anonymous> * __imp__GetDesktopWindow = &g_t3374; // 00403064
<anonymous> * __imp__LoadIconA = &g_t3354; // 00403068
<anonymous> * __imp__SetCaretPos = &g_t3396; // 0040306C
<anonymous> * __imp__RegisterClassExW = &g_t33A4; // 00403070
<anonymous> * __imp__GetKeyState = &g_t33B8; // 00403074
<anonymous> * __imp__GetWindowModuleFileNameA = &g_t33C6; // 00403078
<anonymous> * __imp__DefDlgProcW = &g_t33E2; // 0040307C
<anonymous> * __imp__SetMenuItemBitmaps = &g_t33F0; // 00403080
<anonymous> * __imp__GetScrollRange = &g_t3406; // 00403084
<anonymous> * __imp__ExcludeUpdateRgn = &g_t3418; // 00403088
<anonymous> * __imp__DeleteMenu = &g_t342C; // 0040308C
<anonymous> * __imp__CopyRect = &g_t343A; // 00403090
<anonymous> * __imp__WindowFromDC = &g_t3446; // 00403094
<anonymous> * __imp__DdeAddData = &g_t3456; // 00403098
<anonymous> * __imp__SetCursor = &g_t3464; // 0040309C
<anonymous> * __imp__GetLastInputInfo = &g_t3470; // 004030A0
<anonymous> * __imp__CreateWindowExA = &g_t3484; // 004030A4
<anonymous> * __imp__RegisterClassA = &g_t3496; // 004030A8
<anonymous> * __imp__LoadCursorA = &g_t34A8; // 004030AC
<anonymous> * __imp__DefWindowProcA = &g_t34B6; // 004030B0
<anonymous> * __imp__CreateWindowExW = &g_t34C8; // 004030B4
<anonymous> * __imp__AdjustWindowRect = &g_t34DA; // 004030B8
<anonymous> * __imp__CloseClipboard = &g_t34EE; // 004030BC
<anonymous> * __imp__GetClientRect = &g_t3500; // 004030C0
<anonymous> * __imp__OemToCharA = &g_t3510; // 004030C4
<anonymous> * __imp__CopyIcon = &g_t3348; // 004030C8
<anonymous> * __imp__OemToCharW = &g_t3388; // 004030CC
word32 g_dw403124 = 13610; // 00403124
word32 g_dw40312C = 12820; // 0040312C
word32 g_dw403130 = 0x3220; // 00403130
word32 g_dw403134 = 0x322E; // 00403134
word32 g_dw403138 = 0x323A; // 00403138
word32 g_dw40313C = 0x324C; // 0040313C
word32 g_dw403140 = 0x325A; // 00403140
word32 g_dw403144 = 12912; // 00403144
word32 g_dw403148 = 0x3282; // 00403148
word32 g_dw40314C = 0x3296; // 0040314C
word32 g_dw403150 = 0x3206; // 00403150
word32 g_dw403154 = 0x32B4; // 00403154
word32 g_dw403158 = 12992; // 00403158
word32 g_dw40315C = 0x32D0; // 0040315C
word32 g_dw403160 = 13022; // 00403160
word32 g_dw403164 = 0x32F0; // 00403164
word32 g_dw403168 = 0x3302; // 00403168
word32 g_dw40316C = 0x3318; // 0040316C
word32 g_dw403170 = 0x332A; // 00403170
word32 g_dw403174 = 0x32A2; // 00403174
word32 g_dw403178 = 12792; // 00403178
word32 g_dw403180 = 0x3360; // 00403180
word32 g_dw403184 = 0x336C; // 00403184
word32 g_dw403188 = 0x3374; // 00403188
word32 g_dw40318C = 0x3354; // 0040318C
word32 g_dw403190 = 0x3396; // 00403190
word32 g_dw403194 = 0x33A4; // 00403194
word32 g_dw403198 = 0x33B8; // 00403198
word32 g_dw40319C = 0x33C6; // 0040319C
word32 g_dw4031A0 = 0x33E2; // 004031A0
word32 g_dw4031A4 = 0x33F0; // 004031A4
word32 g_dw4031A8 = 13318; // 004031A8
word32 g_dw4031AC = 13336; // 004031AC
word32 g_dw4031B0 = 13356; // 004031B0
word32 g_dw4031B4 = 0x343A; // 004031B4
word32 g_dw4031B8 = 0x3446; // 004031B8
word32 g_dw4031BC = 13398; // 004031BC
word32 g_dw4031C0 = 0x3464; // 004031C0
word32 g_dw4031C4 = 0x3470; // 004031C4
word32 g_dw4031C8 = 13444; // 004031C8
word32 g_dw4031CC = 0x3496; // 004031CC
word32 g_dw4031D0 = 0x34A8; // 004031D0
word32 g_dw4031D4 = 13494; // 004031D4
word32 g_dw4031D8 = 13512; // 004031D8
word32 g_dw4031DC = 13530; // 004031DC
word32 g_dw4031E0 = 0x34EE; // 004031E0
word32 g_dw4031E4 = 0x3500; // 004031E4
word32 g_dw4031E8 = 0x3510; // 004031E8
word32 g_dw4031EC = 0x3348; // 004031EC
word32 g_dw4031F0 = 0x3388; // 004031F0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      Win32CrtStartup
//      fn00401CD0
//      fn00401F60
void fn00401000(Eq_2 dwArg04, Eq_2 dwArg08, Eq_4 dwArg0C)
{
	word32 dwLoc1C;
	g_dw40406C = g_dw404070 - g_dw404078;
	if (GetBkColor((struct HDC__ *) 293789) == ~0x00)
	{
		g_dw404078 = 0x00207C0A;
		g_dw404088 = g_dw404070 >> ~0x24 - (byte) dwLoc1C;
	}
	Eq_4 dwLoc0C_65 = 0x00;
	while (dwLoc0C_65 < dwArg0C)
	{
		g_t4040A0.u0 = (int32) (g_t40409C.u0 - 0x000D4E0C - g_t404068.u0);
		Mem55[dwArg04 + dwLoc0C_65:byte] = Mem48[dwArg08 + dwLoc0C_65:byte];
		dwLoc0C_65.u3 = (word32) dwLoc0C_65 + 1;
	}
}

// 004010A0: void fn004010A0(Stack (ptr32 byte) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn004010A0(byte * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_50 tLoc2C;
	Eq_51 tLoc14;
	int32 dwLoc30;
	int32 dwLoc28;
	g_dw404070 = dwLoc30;
	Eq_55 eax_15 = LoadIconA(0x00, 0x00404000);
	g_dw404090 = dwLoc30;
	if (eax_15 != null)
		g_dw404090 = dwLoc30 + 0x001744E3;
	CopyIcon(eax_15);
	g_dw404078 = g_dw404078 *s 0x00908369 - dwLoc30;
	if (dwArg0C >= 0x01)
	{
		byte dl_46 = *dwArg04;
		Eq_2 dwLoc0C_212 = 0x01;
		int32 dwLoc1C_213 = 0x00;
		do
		{
			byte cl_54 = Mem51[dwArg04 + dwLoc0C_212:byte];
			g_t4040B0.u0 = (int32) (g_t404074.u0 *s 491973 + 195922);
			++dwLoc0C_212;
			if ((word32) cl_54 == (word32) dl_46)
			{
				if ((word32) dwArg04[(word32) dwLoc0C_212 + 1] == 0x00)
				{
					dwArg08.u8[dwLoc1C_213] = dl_46;
					g_t4040B0.u0 = (int32) (365600 << (byte) dwLoc28);
					++dwLoc1C_213;
					dwLoc0C_212 += 0x02;
				}
				else
				{
					g_t4040B0.u0 = (int32) (g_t4040B0.u0 *s dwLoc28 + 0x0014E415);
					int32 eax_109 = fn004012A0(&tLoc14, dwArg04 + ((word32) dwLoc0C_212 + 1)) + ((word32) dwLoc0C_212 + 1);
					dwLoc0C_212 = fn004012A0(&tLoc2C, dwArg04 + eax_109) + eax_109;
					up32 dwLoc20_232;
					for (dwLoc20_232 = 0x00; dwLoc20_232 < tLoc14; ++dwLoc20_232)
					{
						dwArg08.u8[dwLoc1C_213] = dwArg08.u8[dwLoc1C_213 - tLoc2C];
						++dwLoc1C_213;
					}
				}
			}
			else
			{
				dwArg08.u8[dwLoc1C_213] = cl_54;
				++dwLoc1C_213;
			}
		} while (dwLoc0C_212 < dwArg0C);
	}
}

// 004012A0: Register word32 fn004012A0(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      fn004010A0
word32 fn004012A0(ui32 * dwArg04, byte * dwArg08)
{
	word32 dwLoc18;
	int32 dwLoc14;
	int32 dwLoc10;
	ui32 dwLoc0C_52 = 0x00;
	word32 dwLoc24_53 = 0x00;
	do
	{
		ui32 ecx_15 = (word32) *dwArg08;
		g_t4040B0.u0 = (int32) (dwLoc14 >> (byte) dwLoc18 *s8 g_t404074);
		g_t404074.u0 = (int32) (dwLoc10 *s 0x000AD0DF);
		ui32 ecx_30 = dwLoc0C_52 << 0x07 | ecx_15 & 0x7F;
		++dwArg08;
		dwLoc0C_52 = ecx_30;
		++dwLoc24_53;
	} while ((ecx_15 & 0x80) != 0x00);
	*dwArg04 = ecx_30;
	return dwLoc24_53;
}

// 00401320: Register Eq_205 fn00401320(Stack Eq_59 dwArg04)
// Called from:
//      Win32CrtStartup
Eq_205 fn00401320(Eq_59 dwArg04)
{
	Eq_205 eax_38;
	g_t40409C.u0 = (int32) (g_t4040B0.u0 *s 497375);
	Eq_205 eax_27 = CreateFileA(dwArg04, 0x80000000, 0x01, null, 0x03, 0x80, null);
	if (eax_27 == (void *) ~0x00)
		eax_38 = null;
	else
		eax_38 = eax_27;
	return eax_38;
}

// 00401380: void fn00401380(Stack (ptr32 Eq_232) dwArg04, Stack byte bArg08, Stack int32 dwArg0C)
// Called from:
//      Win32CrtStartup
void fn00401380(struct _STARTUPINFOA * dwArg04, byte bArg08, int32 dwArg0C)
{
	word32 dwLoc14;
	word32 dwLoc20;
	g_t4040B0.u0 = (int32) SetParent;
	int32 dwLoc0C_41;
	for (dwLoc0C_41 = 0x00; dwLoc0C_41 < dwArg0C; ++dwLoc0C_41)
		dwArg04[dwLoc0C_41 / 0x0044] = (struct _STARTUPINFOA) bArg08;
	g_t4040A0.u0 = (int32) (0x00077A9E << (byte) dwLoc14 * 0x02 << (byte) dwLoc20);
}

// 004013E0: Register Eq_4 Win32CrtStartup()
Eq_4 Win32CrtStartup()
{
	ptr32 fp;
	word32 ebx;
	word32 esi;
	word32 edi;
	struct Eq_262 * fs;
	Eq_263 tLoc0100;
	Eq_264 tLocF0;
	Eq_265 tLocE0;
	Eq_264 tLocD0;
	Eq_267 tLocBC;
	Eq_4 tLoc84;
	Eq_269 tLoc7C;
	word32 dwLoc18;
	ui32 dwLoc24;
	int32 dwLoc0C;
	word32 dwLoc14;
	word32 dwArg08;
	Eq_2 dwArg04;
	ui32 dwLoc28;
	g_t40409C.u0 = (int32) (dwLoc24 << (byte) dwLoc18 *s 0x27);
	g_t4040A0.u0 = (int32) AdjustWindowRect;
	g_t40409C.u0 = (int32) CreateWindowExW;
	tLocBC.style = (UINT) 0x00;
	tLocBC.lpfnWndProc = (WNDPROC) DefWindowProcA;
	tLocBC.cbClsExtra = 0x00;
	tLocBC.cbWndExtra = 0x00;
	tLocBC.hInstance = (HINSTANCE) GetModuleHandleA(0x00);
	g_t4040B0.u0 = (int32) (g_t40409C.u0 >> ((word32) g_t40409C + 115) - (byte) dwLoc0C);
	tLocBC.hIcon = (HICON) LoadIconA(GetModuleHandleA(0x00), 0x00404008);
	tLocBC.hCursor = (HCURSOR) LoadCursorA(0x00, 0x7F00);
	g_t40409C.u0 = (int32) (0x00 >> (byte) dwLoc14 >> ~0x65);
	tLocBC.hbrBackground = (HBRUSH) null;
	tLocBC.lpszMenuName = (LPCSTR) null;
	tLocBC.lpszClassName = (LPCSTR) &g_t404010;
	g_t4040B0.u0 = (int32) (g_t40409C.u0 - dwLoc0C >> g_t404068);
	RegisterClassA(&tLocBC);
	if (dwArg08 != 0x01)
		g_dw404098 = 0x00;
	else
	{
		g_dw404098 = 0x01;
		g_t404080.u0 = (Eq_1877 (*)[]) dwArg04;
	}
	Eq_2 dwLoc30_881;
	CreateWindowExA(0x00, 0x00404028, 0x0040401C, 0x01, 492646, 0x0574, 0x00437887, 4796946, null, null, GetModuleHandleA(0x00), 0x00);
	g_t40409C.u0 = (int32) GetLastInputInfo;
	int32 edx_148 = g_t4040A0.u0 - g_t4040A0.u0 << (byte) dwLoc14;
	if (g_dw404098 == 0x00)
		dwLoc30_881 = GetModuleHandleA(0x00);
	else
		dwLoc30_881 = dwArg04;
	g_dw4040B4 = dwLoc28 << (byte) dwLoc28;
	Eq_366 eax_171 = LoadCursorA(0x00, 0x00404034);
	if (eax_171 != null)
	{
		g_dw404090 = 0x00;
		SetCursor(eax_171);
	}
	g_t4040A0.u0 = (int32) 4204422;
	word32 edx_199 = dwLoc30_881 + Mem196[dwLoc30_881 + 60:word32];
	fn00401380(&tLoc7C, 0x00, 0x44);
	tLoc7C.cb = (DWORD) 0x44;
	tLoc7C.lpDesktop = (LPSTR) null;
	g_t404068.u0 = (Eq_1877 (*)[]) (edx_148 *s edx_148 >> ~0x32);
	GetStartupInfoA(&tLoc7C);
	g_t404068.u0 = (Eq_1877 (*)[]) WindowFromDC;
	if (tLoc7C.lpDesktop == null)
		return 0x00;
	tLocD0.bottom = (LONG) 0x00034361;
	int32 ecx_246 = g_dw404078 *s 5137939 - 0x0016F766;
	tLocD0.left = (LONG) 0x00463388;
	g_dw404078 = g_dw404090;
	tLocD0.right = (LONG) 1176;
	g_dw404070 = ecx_246 * 0x02;
	tLocD0.top = (LONG) 0x6517;
	CopyRect(&tLocE0, &tLocD0);
	g_dw404078 >>= g_dw404070 + 110;
	g_t40409C.u0 = (int32) DeleteMenu;
	struct Eq_573 * eax_287 = edx_199 + 6 + (word32) edx_199[5] / 4 + ((word32) (edx_199->t0006).u1 - 0x01) *s 0x0A;
	Eq_59 eax_303 = (uint32) ((uint64) ((word32) edx_199[0x0F].unused + (eax_287->dw0010 - 1)) /u edx_199[0x0F]) *s edx_199[0x0F] + eax_287->dw0014;
	g_t4040A0.u0 = (int32) ExcludeUpdateRgn;
	fn00402730(0x0200);
	if (eax_303 == 0x00)
		return 0x00;
	g_t404068.u0 = (Eq_1877 (*)[]) GetScrollRange;
	GetModuleFileNameA(dwLoc30_881, eax_303, 0x0200);
	g_dw404090 = g_dw404090 *s 0x000B44DD - g_dw404078;
	tLocF0.bottom = (LONG) 0x3433;
	g_dw404088 = ~0x0071BBAC;
	tLocF0.left = (LONG) 6764679;
	g_dw404078 = 0x00;
	tLocF0.right = (LONG) 10136;
	g_dw40406C = 0x000B44DD - g_dw4040B4 + g_dw40406C;
	tLocF0.top = (LONG) 27012;
	CopyRect(&tLoc0100, &tLocF0);
	g_dw404078 = 0x00912CB0;
	Eq_205 eax_375 = fn00401320(eax_303);
	if (eax_375 == null)
		return 0x00;
	g_t40409C.u0 = (int32) SetMenuItemBitmaps;
	Eq_4 eax_400 = GetFileSize(eax_375, null) - eax_303;
	g_t404068.u0 = (Eq_1877 (*)[]) DefDlgProcW;
	if (eax_400 == 0x00)
		return 0x00;
	fn00402730(eax_400.u6.u0 + 4);
	if (DefDlgProcW == 0x00)
		return 0x00;
	g_t404074.u0 = (int32) (g_t404074.u0 << g_t404068);
	SetFilePointer(eax_375, eax_303, null, 0x00);
	if (ReadFile(eax_375, DefDlgProcW, eax_400, &tLoc84, null) == 0x00 || tLoc84 != eax_400)
		return 0x00;
	g_t404074.u0 = (int32) GetWindowModuleFileNameA;
	CloseHandle(eax_375);
	g_t40409C.u0 = (int32) GetKeyState;
	if (tLoc84 != eax_400)
		return 0x00;
	g_t404074.u0 = (int32) RegisterClassExW;
	fn00401000(DefDlgProcW, eax_400.u3 + (DefDlgProcW - (void *) 64), 0x40);
	g_t4040B0.u0 = (int32) SetCaretPos;
	int32 eax_502 = g_dw404088;
	if ((word32) AddAtomA(0x0040403C) == 0x00)
	{
		g_dw404078 = eax_502 *s 0x003C36F4;
		g_dw404088 = 183105;
	}
	g_dw40406C = 0x007CFCF7 >> g_dw404070;
	Eq_2 edx_527 = DefDlgProcW.u7->unused;
	g_t40409C.u0 = (int32) OemToCharW;
	if (GetDC(GetDesktopWindow()) == null)
		g_dw404088 = 4543457;
	Eq_4 ecx_557 = DefDlgProcW.u5->dw0004;
	Eq_2 dwLoc10_961;
	for (dwLoc10_961 = 0x00; dwLoc10_961 < edx_527; dwLoc10_961 += 0x08)
		Mem757[DefDlgProcW + dwLoc10_961 + 8:word32] = Mem561[DefDlgProcW + dwLoc10_961 + 8:word32] ^ 1111;
	fn00402730(ecx_557);
	g_t404094.u0 = (Eq_1877 (*)[]) dwLoc10_961;
	if (g_t404094.u0 != 0x00)
	{
		struct Eq_853 * ebp_644;
		fn004010A0((word32) DefDlgProcW + 8, g_t404094.u0, edx_527);
		g_ptr4040A8 = 24;
		g_dw40407C = edi;
		g_dw404064 = esi;
		g_dw40408C = ebx;
		g_ptr404084 = fp - 4;
		g_t404068.u0 = (Eq_1877 (*)[]) ((edx_148 >> 117) + g_t4040A0.u0);
		if (g_dw404098 != 0x00)
			ebp_644 = fn00401CD0(0x00401C03 - g_t404080.u0);
		else
			ebp_644 = fn00401CD0(0x00401C03 - GetModuleHandleA(0x00));
		if (fn00401F60(g_t404094.u0) != 0x00)
		{
			ebp_644->dwFFFFFFF8 = 689636 << g_t404074 << ebp_644->b0008;
			ebp_644->dwFFFFFFE0 = g_t4040B0.u0 + g_t4040B0.u0 >> ebp_644->b0020;
			g_t4040A0.u0 = (int32) (ebp_644->dwFFFFFFF0 >> g_t4040A0.u1);
			int32 eax_715 = g_t404068.u0 >> ebp_644->b0010;
			ebp_644->dwFFFFFFF0 = eax_715;
			int32 ecx_722 = ebp_644->dwFFFFFFF0;
			Eq_33 edx_726 = 346496 << g_t40409C >> (byte) ecx_722 + 33;
			g_t40409C.u0 = (int32) edx_726;
			word32 eax_733;
			g_ptr4040AC();
			return eax_733;
		}
		else
		{
			fn004026F0(g_t404094.u0);
			ExitProcess(0x00283338);
		}
	}
	else
		ExitProcess(0x9541);
}

// 00401CD0: Register word32 fn00401CD0(Stack ptr32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401CD0(ptr32 dwArg04)
{
	ptr32 fp;
	word32 ebp;
	int32 dwLoc10;
	int32 dwLoc20;
	int32 dwLoc08;
	int32 dwLoc1C;
	Eq_2 dwLoc40_212;
	g_t4040A0.u0 = (int32) OemToCharA;
	g_t40409C.u0 = (int32) GetClientRect;
	if (g_dw404098 != 0x00)
		dwLoc40_212 = Mem15[0x00404080<p32>:word32];
	else
		dwLoc40_212 = GetModuleHandleA(0x00);
	if (dwLoc40_212 == 0x00)
		return ebp;
	g_t4040B0.u0 = (int32) CloseClipboard;
	word32 edx_34 = dwLoc40_212 + Mem31[dwLoc40_212 + 60:word32];
	g_t4040A4.u0 = (Eq_1877 (*)[]) VirtualAlloc(0x00, edx_34[20], 0x3000, 0x40);
	if (g_t4040A4.u0 == 0x00)
		return ebp;
	g_t4040A0.u0 = (int32) (146514 << g_t4040A0.u1 + 0xA0);
	fn00401000(g_t4040A4.u0, dwLoc40_212, edx_34[20]);
	word32 ecx_78 = g_t4040A4.u0 - dwLoc40_212;
	if (Mem79[edx_34 + 0xA4:word32] != 0x00)
	{
		word32 dwLoc14_225 = dwLoc40_212 + Mem79[edx_34 + 0xA0:word32];
		while (dwLoc14_225[1] != 0x00)
		{
			Eq_1057 edx_123 = dwLoc14_225[1] - 0x08 >> 0x01;
			g_t40409C.u0 = (int32) (dwLoc08 - 0x000307D0);
			int32 eax_118 = dwLoc10 *s 0x000C3235 - 399158920;
			dwLoc20 = dwLoc1C - dwLoc20 *s dwLoc08 << (byte) dwLoc1C;
			Eq_1077 dwLoc3C_239 = dwLoc14_225 + 2;
			Eq_1057 dwLoc0C_240 = 0x00;
			while (dwLoc0C_240 < edx_123)
			{
				g_t404074.u0 = (int32) (eax_118 - dwLoc1C << ~0x58 - g_t4040A0.u1);
				if ((word32) *((word32) dwLoc3C_239 + dwLoc0C_240 * 0x02) >> 0x0C == 0x03)
					Mem181[Mem157[0x004040A4<p32>:word32] + Mem157[dwLoc14_225 + 0x00:word32] + (CONVERT(dwLoc3C_239[dwLoc0C_240 * 0x02], word16, word32) & 0x0FFF):word32] = Mem157[Mem157[0x004040A4<p32>:word32] + Mem157[dwLoc14_225 + 0x00:word32] + (CONVERT(dwLoc3C_239[dwLoc0C_240 * 0x02], word16, word32) & 0x0FFF):word32] + ecx_78;
				dwLoc0C_240 = (word32) dwLoc0C_240.u1 + 1;
			}
			dwLoc14_225 += Mem142[dwLoc14_225 + 4:word32];
		}
	}
	word32 eax_102 = dwArg04 + Mem99[0x004040A4<p32>:word32];
	word32 edx_113;
	eax_102();
	return fp - 4;
}

// 00401F60: Register word32 fn00401F60(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401F60(Eq_2 dwArg04)
{
	int32 dwLoc30;
	word32 dwLoc44;
	int32 dwLoc20;
	word32 eax_215;
	word32 edx_16 = dwArg04 + Mem13[dwArg04 + 60:word32];
	struct Eq_1145 * dwLoc2C_699 = &edx_16->w0014 + 2 + (word32) edx_16->w0014 / 84;
	Eq_2 eax_33 = VirtualAlloc(0x00, edx_16->t0050.u2, 0x3000, 0x40);
	if (eax_33 != 0x00)
	{
		g_t40409C.u0 = (int32) (dwLoc30 >> g_t4040A0.u1 + 0xA3 >> (byte) dwLoc44);
		fn00401000(eax_33, dwArg04, (word32) dwArg04.u5[3].dw003C + 252 + (word32) edx_16->w0006 *s 0x28);
		up32 dwLoc10_710;
		for (dwLoc10_710 = 0x00; dwLoc10_710 < (word32) edx_16->w0006; ++dwLoc10_710)
		{
			if (dwLoc2C_699->dw0014 != 0x00 && dwLoc2C_699->dw0010 != 0x00)
				fn00401000(eax_33 + Mem645[dwLoc2C_699 + 0x0C:word32], dwArg04 + Mem640[dwLoc2C_699 + 20:word32], CONVERT(CONVERT(Mem618[dwLoc2C_699 + 16:word32] - 1 + Mem618[edx_16 + 60:word32], word32, uint64) /u Mem618[edx_16 + 60:word32], word32, uint32) *s Mem618[edx_16 + 60:word32]);
			g_t404068.u0 = (Eq_1877 (*)[]) (dwLoc20 *s dwLoc30 + g_t404074.u0);
			++dwLoc2C_699;
		}
		word32 edx_82 = eax_33 + Mem79[eax_33 + 60:word32];
		word32 dwLoc58_716 = eax_33 + Mem83[edx_82 + 0x80:word32];
		while (dwLoc58_716.u0[4] != 0x00)
		{
			word32 eax_476 = GetModuleHandleA(eax_33 + Mem90[dwLoc58_716 + 0x0C:word32]);
			Eq_2 dwLoc18_818 = eax_476;
			if (eax_476 == 0x00)
			{
				if (g_dw404098 != 0x00)
				{
					eax_215 = 0x00;
					return eax_215;
				}
				word32 eax_492 = LoadLibraryA(eax_33 + Mem478[dwLoc58_716 + 0x0C:word32]);
				g_t404068.u0 = (Eq_1877 (*)[]) (g_t404068.u0 *s 626861 >> ~0x0A);
				dwLoc18_818 = eax_492;
				if (eax_492 == 0x00)
				{
					eax_215 = 0x00;
					return eax_215;
				}
			}
			Eq_1268 dwLoc40_824;
			Eq_1269 dwLoc28_823;
			g_t404068.u0 = (Eq_1877 (*)[]) (g_t40409C.u0 *s 0x00042D11);
			if (dwLoc58_716.u1->t0000.u0 != 0x00)
			{
				dwLoc28_823 = eax_33 + Mem504[dwLoc58_716 + 0x00:word32];
				dwLoc40_824 = eax_33 + Mem521[dwLoc58_716 + 16:word32];
			}
			else
			{
				dwLoc28_823 = eax_33 + Mem504[dwLoc58_716 + 16:word32];
				dwLoc40_824 = eax_33 + Mem512[dwLoc58_716 + 0x00:word32];
			}
			word32 dwLoc14_827 = 0x00;
			if (dwLoc58_716.u0[4] != 0x00 && ((dwLoc58_716.u1)->t0000).u0 != 0x00)
				dwLoc14_827 = 0x01;
			while (dwLoc28_823.u1->t0000.u0 != 0x00)
			{
				g_t404074.u0 = (int32) (0x00 << g_t40409C);
				if ((dwLoc28_823.u1->t0000.u0 & 0x80000000) != 0x00)
					dwLoc28_823.u1->t0000.u0 = (struct Eq_1921 *) GetProcAddress(dwLoc18_818, dwLoc28_823.u1->t0000.u0 & 0x7FFFFFFF);
				else
					Mem570[dwLoc28_823 + 0x00:word32] = GetProcAddress(dwLoc18_818, Mem549[dwLoc28_823 + 0x00:word32] + 2 + eax_33);
				if (dwLoc28_823.u1->t0000.u0 == 0x00)
				{
					eax_215 = 0x00;
					return eax_215;
				}
				if (dwLoc14_827 != 0x00)
					dwLoc40_824.u1->t0000.u0 = dwLoc28_823.u1->t0000.u0;
				dwLoc28_823 += 0x04;
				dwLoc40_824 += 0x04;
			}
			dwLoc58_716 += 0x14;
		}
		if (g_dw404098 != 0x00)
		{
			ptr32 ecx_98 = g_t404080.u0 - ((edx_82.u0)->t0034).u0;
			if (edx_82.u0->dw00A4 != 0x00)
			{
				word32 dwLoc1C_721 = eax_33 + Mem99[edx_82 + 0xA0:word32];
				while (dwLoc1C_721.u0[1] != 0x00)
				{
					uint32 ecx_418 = dwLoc1C_721.u0[1] - 0x08 >> 0x01;
					word32 dwLoc50_805 = dwLoc1C_721 + 0x08;
					uint32 dwLoc10_806;
					for (dwLoc10_806 = 0x00; dwLoc10_806 < ecx_418; ++dwLoc10_806)
					{
						if ((word32) *((word32) dwLoc50_805 + dwLoc10_806 * 0x02) >> 0x0C == 0x03)
							Mem464[eax_33 + Mem440[dwLoc1C_721 + 0x00:word32] + (CONVERT(dwLoc50_805[dwLoc10_806 * 0x02], word16, word32) & 0x0FFF):word32] = Mem440[eax_33 + Mem440[dwLoc1C_721 + 0x00:word32] + (CONVERT(dwLoc50_805[dwLoc10_806 * 0x02], word16, word32) & 0x0FFF):word32] + ecx_98;
					}
					dwLoc1C_721 += Mem426[dwLoc1C_721 + 4:word32];
				}
			}
		}
		Eq_205 eax_131 = CreateFileMappingA((void *) ~0x00, null, 0x04, 0x00, edx_82.u0->t0050.u2, 0x00);
		if (eax_131 != null)
		{
			g_t4040A0.u0 = (int32) (g_t404068.u0 *s g_t404074.u0 << (byte) dwLoc30);
			if (g_dw404098 != 0x00)
				g_t4040A4.u0 = (Eq_1877 (*)[]) MapViewOfFileEx(eax_131, 0x22, 0x00, 0x00, 0x00, g_t404080.u0);
			else
				g_t4040A4.u0 = (Eq_1877 (*)[]) MapViewOfFileEx(eax_131, 0x22, 0x00, 0x00, 0x00, edx_82.u0->t0034.u0);
			if (g_t4040A4.u0 == 0x00)
			{
				if (g_dw404098 != 0x00)
				{
					if (UnmapViewOfFile(g_t404080.u0) == 0x00 && VirtualFree(g_t404080.u0, 0x00, 0x8000) == 0x00)
					{
						eax_215 = 0x00;
						return eax_215;
					}
				}
				else if (UnmapViewOfFile(edx_82.u0->t0034.u0) == 0x00 && VirtualFree(((edx_82.u0)->t0034).u0, 0x00, 0x8000) == 0x00)
				{
					eax_215 = 0x00;
					return eax_215;
				}
				if (g_dw404098 != 0x00)
					g_t4040A4.u0 = (Eq_1877 (*)[]) MapViewOfFileEx(eax_131, 0x22, 0x00, 0x00, 0x00, g_t404080.u0);
				else
					g_t4040A4.u0 = (Eq_1877 (*)[]) MapViewOfFileEx(eax_131, 0x22, 0x00, 0x00, 0x00, edx_82.u0->t0034.u0);
				if (g_t4040A4.u0 == 0x00)
				{
					if (g_dw404098 != 0x00)
						g_t4040A4.u0 = (Eq_1877 (*)[]) VirtualAlloc(g_t404080.u0, edx_82.u0->t0050.u2, 0x3000, 0x40);
					else
						g_t4040A4.u0 = (Eq_1877 (*)[]) VirtualAlloc(edx_82.u0->t0034.u0, edx_82.u0->t0050.u2, 0x3000, 0x40);
					if (g_t4040A4.u0 == 0x00)
					{
						eax_215 = 0x00;
						return eax_215;
					}
				}
			}
			fn00401000(g_t4040A4.u0, eax_33, edx_82.u0->t0050.u2);
			if (g_dw404098 != 0x00)
				fn00402580(g_t404080.u0, Mem341[0x004040A4<p32>:word32] + Mem341[edx_82 + 40:word32]);
			else
				fn00402670(g_t4040A4.u0);
			Mem390[0x004040AC<p32>:word32] = Mem386[0x004040A4<p32>:word32] + Mem386[edx_82 + 40:word32];
			edx_82.u0->ptr0028 = g_ptr4040AC;
			eax_215 = 0x01;
			return eax_215;
		}
		else
		{
			eax_215 = 0x00;
			return eax_215;
		}
	}
	else
	{
		eax_215 = 0x00;
		return eax_215;
	}
}

// 00402580: void fn00402580(Stack Eq_2 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fn00401F60
void fn00402580(Eq_2 dwArg04, ptr32 dwArg08)
{
	word32 dwLoc1C;
	int32 dwLoc14;
	struct Eq_1697 * eax_18 = g_ptr4040A8->ptr0030->ptr000C;
	g_t4040A0.u0 = (int32) ((0x000AD806 >> (byte) dwLoc1C *s 0x3D + 171) - g_t4040A0.u0 - g_t404074.u0);
	struct Eq_1717 * eax_25 = eax_18->ptr000C;
	struct Eq_1717 * dwLoc18_100 = eax_25;
	int32 edx_30 = g_t404074.u0 - dwLoc14;
	do
	{
		g_t4040A0.u0 = (int32) (0x00 >> g_t4040A0.u1 + 212);
		if (dwLoc18_100 == null)
			return;
		g_t40409C.u0 = (int32) (g_t404074.u0 *s 0x000F117E >> (byte) edx_30);
		if (dwLoc18_100->t0018.u0 == dwArg04)
		{
			dwLoc18_100->ptr001C = dwArg08;
			return;
		}
		g_t40409C.u0 = (int32) (g_t40409C.u0 *s 3078608);
		struct Eq_1717 * ecx_67 = dwLoc18_100->ptr0000;
		dwLoc18_100 = ecx_67;
	} while (ecx_67 != eax_25);
}

// 00402670: void fn00402670(Stack Eq_2 dwArg04)
// Called from:
//      fn00401F60
void fn00402670(Eq_2 dwArg04)
{
	g_ptr4040A8->ptr0030->t0008.u0 = (Eq_1877 (*)[]) dwArg04;
}

// 004026F0: void fn004026F0(Stack Eq_2 dwArg04)
// Called from:
//      Win32CrtStartup
void fn004026F0(Eq_2 dwArg04)
{
	g_t40409C.u0 = (int32) (~0x18F97085 << g_t404074);
	HeapFree(GetProcessHeap(), 0x00, dwArg04);
}

// 00402730: void fn00402730(Stack Eq_4 dwArg04)
// Called from:
//      Win32CrtStartup
void fn00402730(Eq_4 dwArg04)
{
	word32 dwLoc08;
	int32 dwLoc14;
	word32 dwLoc10;
	g_t4040B0.u0 = (int32) (dwLoc14 >> 0x32 - (byte) dwLoc08);
	HeapAlloc(GetProcessHeap(), 0x00, dwArg04);
	g_t4040B0.u0 = (int32) (g_t4040A0.u0 + 0x000F036D + dwLoc10 << (byte) dwLoc08);
}

