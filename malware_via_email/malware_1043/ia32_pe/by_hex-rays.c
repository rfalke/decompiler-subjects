/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD nullsub_1(); // weak
// double __usercall sub_407A01@<st0>(int@<ecx>, unsigned int@<ebx>, int@<esi>, double@<st0>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_407B59; // weak
char byte_407BD9[3] = { '\xFF', '†', 'M' }; // weak


//----- (00407A01) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
double __usercall sub_407A01@<st0>(int a1@<ecx>, unsigned int a2@<ebx>, int a3@<esi>, double a4@<st0>)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  int v6; // ebx
  char *v7; // esi
  int v10; // esi
  _DWORD *v15; // edi
  unsigned int v16; // edx
  int v18; // esi
  int v19; // esi
  int v20; // edx
  unsigned int v23; // ecx
  int v27; // eax
  float *v28; // edi
  int v29; // ecx
  int v30; // edx
  int v31; // esi
  char v32; // bl
  unsigned int v35; // eax
  _DWORD *v37; // ecx
  char *v38; // eax
  char *v39; // eax
  unsigned int v40; // esi
  unsigned int v41; // esi
  int v42; // edx
  int v43; // ebx
  int v45; // edx
  int v46; // eax
  int v47; // esi
  int v48; // eax
  double result; // st7
  bool v51; // cf
  _DWORD *v52; // edi
  int v54; // esi
  unsigned int v55; // esi
  char *v58; // edi
  bool v60; // tt
  int v61; // ebx
  bool v64; // tt
  unsigned int v65; // esi
  int v68; // eax
  unsigned int v71; // eax
  int v72; // ecx
  _DWORD *i; // eax
  int v76; // [esp-24h] [ebp-24h] BYREF
  int v77; // [esp-20h] [ebp-20h]
  int *v78; // [esp-1Ch] [ebp-1Ch]
  int v79; // [esp-18h] [ebp-18h] BYREF
  void *retaddr[2]; // [esp+0h] [ebp+0h]

  _ECX = ~a1;
  v54 = a3 - 1;
  BYTE1(_ECX) = __ROL1__(BYTE1(_ECX), _ECX) - 1;
  LOWORD(v54) = (unsigned __int16)v54 >> _ECX;
  LOBYTE(a2) = (_BYTE)a2 << 7;
  _EBX = a2 >> _ECX;
  LOWORD(_ECX) = (_WORD)_ECX << _ECX;
  __asm { rcr     ebx, cl }
  v79 = _ECX;
  v78 = &v79;
  v77 = 64;
  v76 = 4225881;
  for ( i = (_DWORD *)&loc_407B59; *i != 9460301; i = (_DWORD *)(((unsigned int)i - 1) & 0xFFFFF000) )
    ;
  v37 = i;
  v38 = (char *)i + i[15];
  v76 = *((_DWORD *)v38 + 20);
  v39 = (char *)v37 + *(_DWORD *)&byte_407BD9[(_DWORD)v38 - 4225881];
  if ( v54 == -1874645801 )
  {
    __outbyte(0x80u, (_BYTE)v39 - 46);
    __asm { retf }
  }
  v27 = (*(int (__stdcall **)(_DWORD *))((char *)v37 + *((_DWORD *)v39 + 4)))(v37);
  v29 = v76;
  v28 = (float *)v77;
  BYTE1(v29) = -BYTE1(v76);
  LOBYTE(v30) = __ROR1__(v30, v76);
  LOWORD(v29) = v77 & v29;
  _ECX = v54 + v29;
  v46 = v27 + 38132220;
  LOBYTE(_ECX) = _ECX + 23;
  v51 = __CFADD__(v54, 1132836458);
  v47 = v54 + 1132836458;
  BYTE1(v30) += _EBX + v51;
  if ( _EBX != -315020760 )
    JUMPOUT(0x4079E4);
  v48 = v46 + 1;
  v77 = v30;
  __inbyte(0xC8u);
  LOBYTE(v48) = __inbyte(0xC0u);
  __asm { icebp }
  LOBYTE(v48) = 2 * v48;
  result = a4 + *v28;
  _EDX = v30 << _ECX;
  LOBYTE(_EBX) = _EDX;
  v51 = (unsigned int)v28 < 0xFFFFFA0A;
  v52 = (_DWORD *)((char *)v28 + 1526);
  LOWORD(_EBX) = _EBX - (v51 + (_WORD)_EDX);
  __asm { rcl     edx, 1Dh }
  LOBYTE(_EDX) = _ECX | _EDX;
  BYTE1(_ECX) = 38;
  _ESI = __ROR4__(v47, 2);
  v71 = __ROR4__(v48, 9);
  v61 = (_EBX | 0x3241EAF0) << _ECX;
  if ( _ECX == -2032297287 )
  {
    v72 = v79;
    LOBYTE(v72) = 65;
    MK_FP(retaddr[0], retaddr[0])(v72, v78);
  }
  else
  {
    BYTE1(v71) >>= _ECX;
    LOWORD(_EDX) = _EDX ^ 0xB069;
    _EAX = ((v71 >> 11) | 0x49C594DA) + 636523301;
    v76 = (int)v52;
    if ( v52 != (_DWORD *)102481186 )
    {
      BYTE1(v61) = ~BYTE1(v61);
      LOWORD(_ESI) = (unsigned __int16)_ESI >> _ECX;
      __asm
      {
        rcr     dl, cl
        rcr     si, cl
      }
      v64 = __CFSHL__(_EAX, 20);
      LOBYTE(_EAX) = __ROL1__(_EAX, 20);
      v65 = _ESI - (v64 - 1650023475);
      LOBYTE(_ECX) = _ECX ^ 0xBA;
      if ( _ECX == -1496800115 )
      {
        *v52 |= (unsigned int)&v76;
        _CL = -114;
        v68 = _EAX ^ 0x12DEF731;
        _disable();
        LOWORD(_EDX) = (_WORD)v52 + __CFSHL__(v61, -114) + (_WORD)_EDX;
        _EBX = (v61 << 14) & 0xD10A50E7;
        BYTE1(_EBX) -= 36;
        _EDX = _EDX >> 29;
        __asm
        {
          rcr     ebx, cl
          rcr     dh, cl
        }
        v51 = __CFADD__(_EDX, -1207038228);
        v16 = _EDX - 1207038228;
        v15 = (_DWORD *)((char *)v52 + 1);
        LOBYTE(v16) = v68 + v51 + v16;
        if ( v15 == (_DWORD *)-257784812 )
        {
          _EBX = v76;
          BYTE1(v16) = -116;
          LOBYTE(v68) = v68 ^ 0xB9;
        }
        _EDX = (_EBX | v16) + 1;
        HIWORD(v18) = HIWORD(_EDX);
        LOWORD(v18) = ~(_WORD)_EDX;
        BYTE1(_EDX) = __ROL1__(BYTE1(_EDX), 27);
        v19 = -16384 * v18;
        __asm { rcl     edx, 3 }
        BYTE1(_EBX) = v68 - BYTE1(_EDX);
        v35 = v68 - 1;
        LOBYTE(_EDX) = 0;
        __asm { rcr     dl, cl }
        v31 = ~(v19 << 14);
        LOBYTE(_EBX) = __ROL1__(_EBX, 20) | 0xAE;
        _EDX = 710219448;
        __asm { rcr     bh, 13h }
        if ( v35 == 1917081092 )
        {
          *v15 = *(_DWORD *)v31;
          v76 = (int)(v15 + 1);
          JUMPOUT(0x407861);
        }
        __asm { rcr     edx, 0Ch }
        HIBYTE(_BX) = v35;
        LOBYTE(_BX) = ((((_EDX - ((v35 < 0x72445604) - 60)) & v32) + 22) & (((_EDX - ((v35 < 0x72445604) - 60)) & v32)
                                                                          + 22
                                                                          + ((_EDX - ((v35 < 0x72445604) - 60)) & v32)) | 0xAF)
                    + (v35 < 0x5611F9F0)
                    + ((_EDX - ((v35 < 0x72445604) - 60)) & v32)
                    + 22;
        __asm { rcl     bx, cl }
        JUMPOUT(0x4076CE);
      }
      BYTE1(_ECX) = __ROR1__(38, _ECX);
      v58 = (char *)v52 - 1526;
      LOWORD(_ECX) = (_WORD)_ECX << _ECX;
      v60 = __CFSHR__(v61, 19);
      _EBX = __ROR4__(v61, 19);
      BYTE1(_EBX) += (SBYTE1(_EAX) >> 7) + v60;
      __asm { rcr     bh, 16h }
      BYTE1(_ECX) &= ~0x40u;
      v55 = v65 >> _ECX;
      LOBYTE(_EBX) = __ROL1__(_EBX | 0x88, _ECX) ^ 0x7B;
      __asm { rcl     al, 15h }
      _ECX = _ECX | 0x21160C8B;
      v40 = __ROL4__(v55, 7) | 0xE32E0395;
      v51 = v40 < 0x2B9C3886;
      v41 = v40 - 731658374;
      v42 = v51 + (_EDX << 30) + 1709603841;
      __asm { rcr     ecx, cl }
      LOBYTE(v42) = v42 ^ 0xE4;
      v43 = _EBX - 1392493771;
      __asm { rcr     ch, 9 }
      v45 = v42 - 359536379;
      v4 = v45 - 1342966651;
      LOBYTE(v4) = 16;
      v5 = v4 >> 7;
      v6 = ~v43;
      v7 = &v58[v41];
      LOBYTE(v6) = __ROR1__(v6, 29);
      BYTE1(v6) = __ROR1__(BYTE1(v6) << _ECX, _ECX);
      _EBX = -v6;
      if ( _ECX == 261460123 )
        BYTE1(_EBX) = 15;
      LOBYTE(_EBX) = _EBX - ((_ECX < 0xF95909B) + 51);
      _EAX = 3046;
      v10 = __ROR4__(v7, 7);
      __asm { rcr     bh, cl }
      BYTE1(_EBX) = BYTE1(_ECX);
      SBYTE1(_ECX) >>= 7;
      LOWORD(v10) = _EBX;
      LOWORD(_ECX) = (__int16)_ECX >> _ECX;
      BYTE1(v5) = __ROR1__(BYTE1(v5), 27) - v5;
      v20 = __ROL4__(8 * v5, 10);
      _EBX = v58;
      if ( v10 == 1895188633 )
      {
        __asm { das }
        v58[8 * _ECX - 2147027008] += BYTE1(v20) + 1;
        __asm { rcr     eax, 0D2h }
        v23 = _ECX - 1;
        if ( !v23 )
        {
          __asm
          {
            xlat
            rcl     bl, 6
          }
          JUMPOUT(0x407916);
        }
        if ( v23 == 307610483 )
          JUMPOUT(0x407783);
        JUMPOUT(0x4077A7);
      }
      JUMPOUT(0x407ACD);
    }
    _EDX = ((__CFADD__((_EAX & 0x100) != 0, _EAX) | __CFADD__(((_EAX & 0x100) != 0) + _EAX, -1023484562))
          + _EDX
          - 1494927934) & 0x5413E657;
    BYTE1(_EDX) ^= 0x63u;
    __asm { rcl     edx, 1Eh }
    nullsub_1();
  }
  return result;
}
// 407B2C: positive sp value 14 has been found
// 40777E: control flows out of bounds to 407783
// 407860: control flows out of bounds to 407861
// 407B93: control flows out of bounds to 407B9A
// 407C5C: control flows out of bounds to 407C5E
// 4077B8: control flows out of bounds to 407916
// 40761B: control flows out of bounds to 4075E1
// 407695: control flows out of bounds to 4076CE
// 40777C: control flows out of bounds to 4077A7
// 40779C: control flows out of bounds to 407ACD
// 4079B3: control flows out of bounds to 4079DC
// 4079DD: control flows out of bounds to 4079E4
// 407C5A: control flows out of bounds to 407CCD
// 407A01: could not find valid save-restore pair for ebp
// 40761B: conditional instruction was optimized away because ecx.4==F95909B
// 40781B: variable 'v30' is possibly undefined
// 407644: using guessed type _DWORD nullsub_1();

// nfuncs=2 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
