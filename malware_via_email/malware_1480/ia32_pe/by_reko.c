// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw13102050 = 0x2108; // 13102050
word32 g_dw13102054 = 0x2112; // 13102054
word32 g_dw13102058 = 0x2122; // 13102058
word32 g_dw1310205C = 8500; // 1310205C
word32 g_dw13102060 = 0x2148; // 13102060
word32 g_dw13102064 = 0x2158; // 13102064
word32 g_dw13102068 = 8558; // 13102068
word32 g_dw1310206C = 0x217E; // 1310206C
word32 g_dw13102070 = 0x218E; // 13102070
word32 g_dw13102074 = 0x219C; // 13102074
word32 g_dw1310207C = 0x21C0; // 1310207C
word32 g_dw13102080 = 8662; // 13102080
word32 g_dw13102084 = 0x21F4; // 13102084
word32 g_dw13102088 = 0x2210; // 13102088
word32 g_dw1310208C = 0x2224; // 1310208C
word32 g_dw13102090 = 0x223A; // 13102090
word32 g_dw13102098 = 0x2262; // 13102098
word32 g_dw1310209C = 0x2278; // 1310209C
word32 g_dw131020A0 = 8838; // 131020A0
word32 g_dw131020A4 = 0x229E; // 131020A4
<anonymous> * __imp__GetACP = &g_t2108; // 131020AC
<anonymous> * __imp__SetConsoleCP = &g_t2112; // 131020B0
<anonymous> * __imp__GetStartupInfoA = &g_t2122; // 131020B4
<anonymous> * __imp__GetModuleHandleA = &g_t2134; // 131020B8
<anonymous> * __imp__VirtualAlloc = &g_t2148; // 131020BC
<anonymous> * __imp__EnumResourceNamesA = &g_t2158; // 131020C0
<anonymous> * __imp__FindResourceA = &g_t216E; // 131020C4
<anonymous> * __imp__LockResource = &g_t217E; // 131020C8
<anonymous> * __imp__ExitProcess = &g_t218E; // 131020CC
<anonymous> * __imp__EnumResourceTypesA = &g_t219C; // 131020D0
<anonymous> * __imp__RevokeActiveObject = &g_t21C0; // 131020D8
<anonymous> * __imp__SafeArrayAllocDescriptorEx = &g_t21D6; // 131020DC
<anonymous> * __imp__SafeArrayAllocDescriptor = &g_t21F4; // 131020E0
<anonymous> * __imp__CreateStdDispatch = &g_t2210; // 131020E4
<anonymous> * __imp__VarNumFromParseNum = &g_t2224; // 131020E8
<anonymous> * __imp__SafeArraySetRecordInfo = &g_t223A; // 131020EC
<anonymous> * __imp__CLSIDFromOle1Class = &g_t2262; // 131020F4
<anonymous> * __imp__BindMoniker = &g_t2278; // 131020F8
<anonymous> * __imp__PropVariantChangeType = &g_t2286; // 131020FC
<anonymous> * __imp__CLIPFORMAT_UserFree = &g_t229E; // 13102100
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack word32 dwArg04, Stack (ptr32 byte) dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack word32 dwArg14, Stack (arr byte) dwArg18)
// Called from:
//      Win32CrtStartup
void fn13101000(word32 dwArg04, byte * dwArg08, word32 dwArg0C, word32 * dwArg10, word32 dwArg14, byte dwArg18[])
{
	ptr32 fp;
	word32 * dwArg10;
	word32 dwArg0C;
	word32 dwArg14;
	word32 dwArg04;
	byte dwArg18[];
	byte * dwArg08;
	*dwArg10 = dwArg0C;
	edx_eax_15 = (uint64) dwArg14;
	edx_17 = (uint32) (edx_eax_15 % 0x05);
	dx_19 = (word16) edx_17;
	wLoc0C_644 = dx_19;
	edx_22 = dwArg04 + dwArg14;
	dwArg04_646 = edx_22;
	while (true)
	{
		dwArg08_815 = ϕ(dwArg08, dwArg08_838);
		wLoc0C_809 = ϕ(wLoc0C_644, wLoc0C_919);
		dwArg04_807 = ϕ(dwArg04_646, dwArg04_856);
		dwArg0C_805 = ϕ(dwArg0C, dwArg0C_806);
		dwArg0C_806 = dwArg0C_805 - 0x01;
		if (dwArg0C_805 == 0x00)
			break;
		al_36 = *dwArg04_807;
		ecx_38 = (int32) wLoc0C_809;
		eax_40 = (word32) dwArg18[ecx_38];
		ecx_41 = (int32) al_36;
		ebp_55 = eax_40 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_55 == 0x00);
		ecx_70 = ecx_41 ^ eax_40;
		cl_100 = (byte) ecx_70;
		ebp_85 = eax_40 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_85 == 0x00);
		ebp_111 = eax_40 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_111 == 0x00);
		ebp_135 = eax_40 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_135 == 0x00);
		eax_24_8_156 = SLICE(eax_40, word24, 8);
		eax_157 = SEQ(eax_24_8_156, cl_100);
		ebp_161 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_161 == 0x00);
		*dwArg08_815 = cl_100;
		ebp_188 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_188 == 0x00);
		ebp_212 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_212 == 0x00);
		ebp_240 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_240 == 0x00);
		wLoc0C_824 = wLoc0C_809 + 0x01;
		ebp_265 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_265 == 0x00);
		ebp_289 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_289 == 0x00);
		ebp_316 = eax_157 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_316 == 0x00);
		eax_324 = eax_157;
		if (!(fp - 0x14))
			;
		wLoc0C_919 = ϕ(wLoc0C_824, wLoc0C_826);
		eax_396 = ϕ(eax_324, eax_379);
		ebp_399 = eax_396 + 0x00038884;
		do
			;
		while ((ebp_399 ^ 0xF90A) == 0x00);
		ebp_428 = eax_396 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_428 == 0x00);
		dwArg08_838 = dwArg08_815 + 1;
		ebp_453 = eax_396 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_453 == 0x00);
		ebp_477 = eax_396 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_477 == 0x00);
		ebp_505 = eax_396 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_505 == 0x00);
		dwArg04_856 = dwArg04_807 + 1;
		ebp_530 = eax_396 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_530 == 0x00);
	}
}

// 131012E4: Register Eq_198 Win32CrtStartup()
Eq_198 Win32CrtStartup()
{
	word32 eax;
	ui32 ebp_18 = eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_18 == 0x00);
	ui32 ebp_42 = eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_42 == 0x00);
	ui32 ebp_69 = eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_69 == 0x00);
	ui32 ebp_93 = eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_93 == 0x00);
}

