/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// int __userpurge sub_401010@<eax>(unsigned int a1@<ebx>, unsigned int a2);
void __stdcall sub_401241(int a1, unsigned int a2, unsigned int a3);
// int __userpurge sub_401268@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3);
// int __usercall sub_4012D3@<eax>(_DWORD *a1@<edi>);
// _BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>);
int sub_40138A();
char *__stdcall sub_401390(char *a1, int a2, int a3);
int __stdcall sub_4014E5(char *a1, int (__stdcall **a2)(char *));
// int __usercall sub_40159A@<eax>(_BYTE *a1@<eax>, int a2@<ecx>);
// int __userpurge sub_4015E7@<eax>(int a1@<esi>, int a2);
// _BYTE *__usercall sub_401639@<eax>(int a1@<eax>);
// int __userpurge sub_40166B@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
// _BYTE *__usercall sub_4016C9@<eax>(int a1@<eax>);
// int __userpurge sub_4016F7@<eax>(int a1@<eax>, int a2);
// _BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_401767@<eax>(int a1@<eax>);
// BOOL __usercall sub_401799@<eax>(int a1@<edx>, _DWORD *a2@<esi>);
// _BYTE *__usercall sub_40186E@<eax>(_BYTE *result@<eax>);
// unsigned int __userpurge sub_401892@<eax>(int a1@<edi>, _DWORD *a2);
// _DWORD *__userpurge sub_401A35@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// _BYTE *__userpurge sub_401A5A@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
HANDLE __stdcall GetKJfkdsjgksjgd();
HANDLE __stdcall GetLKVGskgdh();
HANDLE __stdcall GetGHsdjkglkdh();
HANDLE __stdcall GetFJlksdjglkdfjhd();
HANDLE __stdcall GetKJGjhgfdhfdkh();
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// BOOL __stdcall DeleteDC(HDC hdc);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// BOOL __stdcall Polyline(HDC hdc, const POINT *apt, int cpt);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// DWORD __stdcall GetCurrentThreadId();
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall SetEvent(HANDLE hEvent);
// HANDLE __stdcall GetCurrentProcess();
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// HWND __stdcall GetActiveWindow();
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HACCEL __stdcall LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
// int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// BOOL __stdcall GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
// LONG __stdcall SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong);
// HMENU __stdcall GetMenu(HWND hWnd);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall GetWindowInfo(HWND hwnd, PWINDOWINFO pwi);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// HDC __stdcall GetDC(HWND hWnd);
// HWND __stdcall GetForegroundWindow();
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);

//-------------------------------------------------------------------------
// Data declarations

int dword_4050D8 = 0; // weak
int dword_4060D8 = 0; // weak


//----- (00401010) --------------------------------------------------------
int __userpurge sub_401010@<eax>(unsigned int a1@<ebx>, unsigned int a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // edi
  HDC v4; // esi
  HWND v5; // eax
  HDC v6; // edi
  HPEN v7; // eax
  HDC v8; // esi
  HANDLE v9; // eax
  HWND v10; // esi
  char v11; // cl
  unsigned int *v12; // eax
  bool v14; // [esp+13h] [ebp-2Dh]
  unsigned int v15; // [esp+14h] [ebp-2Ch]
  unsigned int v16; // [esp+1Ch] [ebp-24h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  HWND hWnd; // [esp+2Ch] [ebp-14h]
  struct tagRECT Rect; // [esp+30h] [ebp-10h] BYREF

  v2 = 0;
  v3 = 0x40 / a2;
  if ( 0x40 / a2 )
  {
    v14 = 0;
    v17 = a1 % 0x41;
    do
    {
      v15 = v2;
      v16 = v2;
      if ( a1 % 0xF <= 0x14 )
      {
        v15 = v2 + 8 * v14 + 15;
      }
      else
      {
        v4 = GetDC(0);
        TextOutA(v4, 10, 10, "Trololo", 32);
        if ( !v4 || MoveToEx(v4, 10, 10, 0) )
          LineTo((HDC)((char *)v4 + 10), 150, 200);
        else
          Polyline(v4, (const POINT *)0x324345, 20);
        ReleaseDC(0, v4);
      }
      if ( v17 <= 0x56 )
      {
        if ( v15 > v3 - 1 )
          v15 %= v3;
      }
      else
      {
        v5 = GetForegroundWindow();
        hWnd = v5;
        if ( v5 )
        {
          v6 = GetDC(v5);
          if ( v6 )
          {
            v7 = CreatePen(2, 3, 0x101010u);
            if ( v7 )
            {
              SelectObject(v6, v7);
            }
            else
            {
              v8 = CreateCompatibleDC(v6);
              SelectObject(v8, 0);
              BitBlt(v6, 0, 0, 50, 50, v8, 0, 0, 0xCC0020u);
              DeleteDC(v8);
            }
            ReleaseDC(hWnd, v6);
          }
          v3 = 0x40 / a2;
        }
      }
      if ( (a1 & 7) <= 0xA )
      {
        v14 = !v14;
      }
      else
      {
        v9 = CreateEventA(0, 1, 1, "TestEvent");
        SetEvent(v9);
      }
      if ( v17 <= 0x50 )
      {
        if ( a2 == 1 )
        {
          v11 = *(_BYTE *)(a1 + v2);
          goto LABEL_32;
        }
        v16 = *(_DWORD *)(a1 + 4 * v2);
      }
      else
      {
        v10 = FindWindowA(0, "MyWindow");
        if ( v10 && GetWindowRect(v10, &Rect) )
          SetWindowPos(v10, 0, Rect.left, Rect.top, Rect.right + 50, Rect.bottom, 4u);
      }
      if ( a2 != 1 )
      {
        v12 = (unsigned int *)(a1 + 4 * v15);
        *(_DWORD *)(a1 + 4 * v2) = *v12;
        *v12 = v16;
        goto LABEL_34;
      }
      v11 = v16;
LABEL_32:
      *(_BYTE *)(a1 + v2) = *(_BYTE *)(a1 + v15);
      *(_BYTE *)(a1 + v15) = v11;
LABEL_34:
      v2 += 2;
    }
    while ( v2 < v3 );
  }
  return 64;
}

//----- (00401241) --------------------------------------------------------
void __stdcall sub_401241(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int i; // esi

  for ( i = 0; i < a2; i += sub_401010(i + a1, a3) )
    ;
}

//----- (00401268) --------------------------------------------------------
int __userpurge sub_401268@<eax>(int a1@<ebx>, unsigned int a2, _BYTE *a3)
{
  int v3; // esi
  int result; // eax
  _DWORD *v5; // edi
  int v6; // [esp+10h] [ebp+8h]

  sub_401241(a1, a2, 1u);
  sub_401241(a1, a2, 4u);
  v3 = a1 + *(_DWORD *)(a1 + 60);
  sub_401A5A(a3, (_BYTE *)a1, *(_DWORD *)(v3 + 84));
  v6 = 0;
  result = *(unsigned __int16 *)(v3 + 20) + v3 + 24;
  if ( *(_WORD *)(v3 + 6) )
  {
    v5 = (_DWORD *)(*(unsigned __int16 *)(v3 + 20) + v3 + 44);
    do
    {
      sub_401A5A(&a3[*(v5 - 2)], (_BYTE *)(a1 + *v5), *(v5 - 1));
      result = *(unsigned __int16 *)(v3 + 6);
      v5 += 10;
      ++v6;
    }
    while ( v6 < result );
  }
  return result;
}

//----- (004012D3) --------------------------------------------------------
int __usercall sub_4012D3@<eax>(_DWORD *a1@<edi>)
{
  char *v1; // ecx
  _DWORD *v2; // eax
  int i; // esi
  char *v5; // [esp+0h] [ebp-14h]
  unsigned int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  _WORD *v8; // [esp+10h] [ebp-4h]

  v1 = (char *)a1 + a1[15];
  v2 = (_DWORD *)((char *)a1 + *((_DWORD *)v1 + 40));
  v5 = (char *)a1 - *((_DWORD *)v1 + 13);
  if ( v2 == a1 )
    return 0;
  v7 = 0;
  for ( i = v2[1]; i; i = v2[1] )
  {
    if ( (unsigned int)(i - 8) >> 1 )
    {
      v8 = v2 + 2;
      v6 = (unsigned int)(i - 8) >> 1;
      do
      {
        if ( (*v8 & 0xF000) == 12288 )
          *(_DWORD *)((char *)a1 + (*v8 & 0xFFF) + *v2) += v5;
        ++v8;
        --v6;
      }
      while ( v6 );
    }
    v7 += i;
    v2 = (_DWORD *)((char *)a1 + v7 + *((_DWORD *)v1 + 40));
  }
  return 1;
}

//----- (00401367) --------------------------------------------------------
_BYTE *__usercall sub_401367@<eax>(_BYTE *result@<eax>)
{
  _BYTE *v1; // ecx
  char v2; // dl

  if ( *result == 1 )
  {
    v1 = ++result;
    if ( *result )
    {
      do
      {
        if ( *v1 )
          v2 = *v1 + 30;
        else
          v2 = 0;
        *v1++ = v2;
      }
      while ( *v1 );
    }
  }
  return result;
}

//----- (0040138A) --------------------------------------------------------
int sub_40138A()
{
  return 6761486;
}

//----- (00401390) --------------------------------------------------------
char *__stdcall sub_401390(char *a1, int a2, int a3)
{
  int v4; // eax
  bool v5; // zf
  char *v6; // eax
  char *v7; // eax
  unsigned int v8; // ecx
  char *v9; // edi
  char *v10; // ebx
  _BYTE *v11; // edx
  unsigned int v12; // edx
  unsigned int v14; // eax
  unsigned int *v15; // ebx
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char *v18; // eax
  char v19; // dl
  int v20; // eax
  int v21; // [esp+0h] [ebp-24h]
  int v22; // [esp+4h] [ebp-20h]
  unsigned int v23; // [esp+Ch] [ebp-18h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  char *v25; // [esp+14h] [ebp-10h]
  char *v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  unsigned int v28; // [esp+20h] [ebp-4h]
  unsigned int v29; // [esp+2Ch] [ebp+8h]
  _BYTE *v30; // [esp+2Ch] [ebp+8h]
  char *v31; // [esp+30h] [ebp+Ch]
  int v32; // [esp+30h] [ebp+Ch]

  if ( a1 )
  {
    v4 = *((_DWORD *)a1 + 15);
    v5 = &a1[v4] == 0;
    v6 = &a1[v4];
    v26 = v6;
    if ( !v5 )
    {
      v7 = &a1[*((_DWORD *)v6 + 30)];
      if ( v7 != a1 )
      {
        v25 = &a1[*((_DWORD *)v7 + 9)];
        v8 = *((_DWORD *)v7 + 5);
        v9 = &a1[*((_DWORD *)v7 + 7)];
        v10 = &a1[*((_DWORD *)v7 + 8)];
        v23 = v8;
        v24 = *((_DWORD *)v7 + 6);
        v28 = v8;
        if ( v8 <= v24 )
          v28 = *((_DWORD *)v7 + 6);
        v11 = (_BYTE *)a2;
        if ( a2 >= 0 )
        {
          v14 = 0;
          v29 = 0;
          if ( v28 )
          {
            while ( 1 )
            {
              v27 = *(unsigned __int16 *)&v25[2 * v14];
              if ( v14 >= v24 || *(unsigned __int16 *)&v25[2 * v14] >= v23 )
                break;
              if ( sub_40159A(v11, (int)&a1[*(_DWORD *)&v10[4 * v29]]) )
              {
                v15 = (unsigned int *)&v9[4 * v27];
                v16 = *v15;
                v17 = *((_DWORD *)v26 + 30);
                if ( *v15 < v17 || v16 >= v17 + *((_DWORD *)v26 + 31) )
                  return &a1[v16];
                v18 = &a1[v16];
                do
                {
                  v19 = *v18++;
                  v31 = v18;
                }
                while ( v19 != 46 );
                v30 = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a3 + 8))(0, &v18[-v16] - a1, 12288, 4);
                if ( v30 )
                {
                  sub_401A5A(v30, &a1[*v15], &v31[-*v15] - a1 - 1);
                  v20 = (*(int (__stdcall **)(_BYTE *, char *, int))a3)(v30, v31, a3);
                  v32 = sub_401390(v20, v21, v22);
                  (*(void (__stdcall **)(_BYTE *))(a3 + 12))(v30);
                  return (char *)v32;
                }
                return 0;
              }
              if ( ++v29 >= v28 )
                return 0;
              v11 = (_BYTE *)a2;
              v14 = v29;
            }
          }
        }
        else
        {
          v12 = (a2 & 0x7FFFFFFF) - *((_DWORD *)v7 + 4);
          if ( v12 < v8 )
            return &a1[*(_DWORD *)&v9[4 * v12]];
        }
      }
    }
  }
  return 0;
}
// 4014BC: variable 'v21' is possibly undefined
// 4014BC: variable 'v22' is possibly undefined

//----- (004014E5) --------------------------------------------------------
int __stdcall sub_4014E5(char *a1, int (__stdcall **a2)(char *))
{
  char *v2; // edx
  char *v3; // esi
  char *v5; // edi
  char *v6; // ebx
  unsigned int v7; // eax
  char **v8; // ecx
  char *v9; // eax
  char *v10; // ecx
  char *v11; // eax
  int v12; // [esp-10h] [ebp-24h]
  char **v13; // [esp+4h] [ebp-10h]
  int v14; // [esp+8h] [ebp-Ch]
  unsigned int v15; // [esp+Ch] [ebp-8h]
  unsigned int v16; // [esp+10h] [ebp-4h]

  v2 = a1;
  v3 = &a1[*(_DWORD *)&a1[*((_DWORD *)a1 + 15) + 120]];
  v14 = (int)&a1[*((_DWORD *)a1 + 15) + 120];
  if ( v3 == a1 )
    return 1;
  v5 = &a1[*((_DWORD *)v3 + 7)];
  v6 = &a1[*((_DWORD *)v3 + 9)];
  v15 = *((_DWORD *)v3 + 5);
  if ( v15 <= *((_DWORD *)v3 + 6) )
    v15 = *((_DWORD *)v3 + 6);
  v7 = 0;
  v16 = 0;
  if ( v15 )
  {
    while ( 1 )
    {
      if ( v7 < *((_DWORD *)v3 + 5) )
        v7 = *(unsigned __int16 *)&v6[2 * v7];
      v8 = (char **)&v5[4 * v7];
      v9 = &(*v8)[(_DWORD)v2];
      v13 = v8;
      if ( v9 != v2 )
      {
        if ( v9 > v3 )
        {
          if ( v9 < &v3[40 * *(_DWORD *)(v14 + 4)] )
          {
            v10 = &(*v8)[(_DWORD)v2];
            do
              ++v10;
            while ( *v10 != 46 );
            *v10 = 0;
            v12 = (int)(v10 + 1);
            v11 = (char *)(*a2)(v9);
            v9 = sub_401390(v11, v12, (int)a2);
            v8 = v13;
          }
          v2 = a1;
        }
        if ( !v9 )
          return 0;
        *v8 = v9;
      }
      if ( ++v16 >= v15 )
        return 1;
      v7 = v16;
    }
  }
  return 1;
}

//----- (0040159A) --------------------------------------------------------
int __usercall sub_40159A@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  bool v2; // bl
  int v3; // esi
  int v4; // edx
  char v5; // cl
  bool v6; // zf

  v2 = *a1 == 1;
  if ( *a1 == 1 )
    ++a1;
  if ( *a1 == 2 )
    return 1;
  v3 = a2 - (_DWORD)a1;
  while ( 1 )
  {
    if ( v2 )
    {
      v4 = (char)*a1;
      if ( *a1 )
        v4 += 30;
      v5 = a1[v3];
      v6 = v5 == v4;
    }
    else
    {
      v5 = a1[v3];
      v6 = v5 == *a1;
    }
    if ( !v6 )
      break;
    if ( v5 )
    {
      if ( *++a1 != 2 )
        continue;
    }
    return 1;
  }
  return 0;
}

//----- (004015E7) --------------------------------------------------------
int __userpurge sub_4015E7@<eax>(int a1@<esi>, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v4; // ebx
  char **v5; // eax
  int v6; // [esp-14h] [ebp-14h]
  int v7; // [esp-10h] [ebp-10h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  if ( v2 == (_DWORD *)a1 )
    return 1;
  if ( !*v2 )
    return 1;
  v4 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  while ( 1 )
  {
    v7 = a1 + *v4;
    v5 = (char **)(a1 + v4[4]);
    v6 = a1 + v4[3];
    v4 += 5;
    if ( !sub_40166B(v5, a2, v6, v7, a1) )
      break;
    if ( !*v4 )
      return 1;
  }
  return 0;
}

//----- (00401639) --------------------------------------------------------
_BYTE *__usercall sub_401639@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 9, 12288, 4);
  result[8] = 2;
  result[1] = 111;
  result[3] = 98;
  result[6] = 101;
  result[2] = 109;
  result[5] = 110;
  *result = 67;
  result[7] = 82;
  result[4] = 105;
  return result;
}

//----- (0040166B) --------------------------------------------------------
int __userpurge sub_40166B@<eax>(char **a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int result; // eax
  int v7; // ebx
  int *v8; // ecx
  int v9; // eax
  char *v10; // eax
  char *v11; // [esp+Ch] [ebp+8h]

  result = (*(int (__stdcall **)(int))(a2 + 16))(a3);
  v11 = (char *)result;
  if ( result )
  {
    v7 = a4 - (_DWORD)a1;
    while ( 1 )
    {
      v8 = (int *)((char *)a1 + v7);
      v9 = 0;
      if ( (char **)((char *)a1 + v7) )
        v9 = *v8;
      if ( !a1 || !*a1 )
        return 1;
      if ( v8 )
      {
        if ( v9 >= 0 )
          v9 += a5 + 2;
        v10 = sub_401390(v11, v9, a2);
        if ( !v10 )
          return 0;
        *a1 = v10;
      }
      ++a1;
    }
  }
  return result;
}

//----- (004016C9) --------------------------------------------------------
_BYTE *__usercall sub_4016C9@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 8, 12288, 4);
  *result = 67;
  result[7] = 2;
  result[2] = 101;
  result[5] = 101;
  result[3] = 97;
  result[1] = 114;
  result[6] = 82;
  result[4] = 116;
  return result;
}

//----- (004016F7) --------------------------------------------------------
int __userpurge sub_4016F7@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  unsigned int v3; // ebx
  _DWORD *v4; // edi
  int v6; // [esp+Ch] [ebp+8h]

  v2 = a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 136);
  if ( v2 != a1 )
  {
    v6 = a1 - a2;
    if ( v6 )
    {
      v3 = 0;
      if ( *(_WORD *)(v2 + 14) )
      {
        v4 = (_DWORD *)(v2 + 20);
        do
        {
          sub_401A35((*v4 & 0x7FFFFFFF) + v2 + 16, v2, v6);
          v4 += 2;
          ++v3;
        }
        while ( v3 < *(unsigned __int16 *)(v2 + 14) );
      }
    }
  }
  return 1;
}

//----- (0040174B) --------------------------------------------------------
_BYTE *__usercall sub_40174B@<eax>(_BYTE *result@<eax>)
{
  *result = 71;
  result[1] = 101;
  result[5] = 103;
  result[6] = 2;
  result[2] = 116;
  result[4] = 101;
  result[3] = 82;
  return result;
}

//----- (00401767) --------------------------------------------------------
_BYTE *__usercall sub_401767@<eax>(int a1@<eax>)
{
  _BYTE *result; // eax

  result = (_BYTE *)(*(int (__stdcall **)(_DWORD, int, int, int))(a1 + 8))(0, 10, 12288, 4);
  result[7] = 108;
  result[6] = 100;
  result[3] = 51;
  result[8] = 108;
  *result = 103;
  result[1] = 100;
  result[4] = 50;
  result[5] = 46;
  result[2] = 105;
  return result;
}

//----- (00401799) --------------------------------------------------------
BOOL __usercall sub_401799@<eax>(int a1@<edx>, _DWORD *a2@<esi>)
{
  int v3; // edi
  int *v4; // ecx
  int *v5; // eax
  int v6; // ebx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // ebx
  _BYTE *v11; // ebx
  int (__stdcall *v12)(char *); // eax
  int v13; // eax
  char v14[16]; // [esp+0h] [ebp-10h] BYREF

  if ( a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128) == a1 )
    return 0;
  v3 = 0;
  v4 = (int *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 128));
  do
  {
    if ( !*v4 )
      return 0;
    v5 = v4;
    v6 = v4[3];
    v4 += 5;
  }
  while ( *(_BYTE *)(a1 + v6) != 75 );
  v7 = *v5;
  v8 = (_DWORD *)(a1 + v5[4]);
  v9 = a1 + v7;
  if ( !*v8 )
    return 0;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v9 + 4 * v3);
    if ( v10 >= 0 )
    {
      v11 = (_BYTE *)(a1 + v10);
      if ( v11[2] == 71 && v11[3] == 101 && v11[5] == 77 && v11[11] == 72 )
        break;
    }
    if ( !v8[++v3] )
      return 0;
  }
  v12 = (int (__stdcall *)(char *))v8[v3];
  strcpy(v14, "Kernel32.dll");
  v13 = v12(v14);
  sub_401892(v13, a2);
  return *a2 && a2[4] && a2[2] && a2[3] && a2[1] && a2[5];
}

//----- (0040186E) --------------------------------------------------------
_BYTE *__usercall sub_40186E@<eax>(_BYTE *result@<eax>)
{
  result[3] = 97;
  result[5] = 101;
  *result = 67;
  result[1] = 114;
  result[4] = 116;
  result[6] = 82;
  result[7] = 111;
  result[8] = 2;
  result[2] = 101;
  return result;
}

//----- (00401892) --------------------------------------------------------
unsigned int __userpurge sub_401892@<eax>(int a1@<edi>, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // esi
  int v4; // ebx
  unsigned int result; // eax
  unsigned int v6; // edx
  _BYTE *v7; // eax
  int v8; // esi
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  unsigned int v14; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 + 60) + a1 + 120));
  v9 = a1 + v2[9];
  v3 = a1 + v2[7];
  v4 = a1 + v2[8];
  v11 = v3;
  v10 = v4;
  v12 = v2[5];
  if ( v12 <= v2[6] )
    v12 = v2[6];
  result = 0;
  v14 = 0;
  v13 = 0;
  if ( v12 )
  {
    while ( 1 )
    {
      if ( v14 >= 6 )
        return result;
      v6 = *(unsigned __int16 *)(v9 + 2 * result);
      if ( result >= v2[6] || v6 >= v2[5] )
        return result;
      v7 = (_BYTE *)(a1 + *(_DWORD *)(v4 + 4 * result));
      v8 = a1 + *(_DWORD *)(v3 + 4 * v6);
      if ( *v7 == 71 && v7[1] == 101 )
      {
        if ( v7[2] == 116 && v7[3] == 77 && v7[15] == 65 )
        {
          *a2 = v8;
LABEL_47:
          ++v14;
          goto LABEL_48;
        }
        if ( v7[2] == 116 && v7[3] == 84 && v7[4] == 105 && v7[5] == 99 && v7[7] == 67 && v7[11] == 116 && !v7[12] )
        {
          a2[5] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 86 && v7[1] == 105 )
      {
        if ( v7[2] == 114 && v7[7] == 65 && v7[8] == v7[9] && !v7[12] )
        {
          a2[2] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 80 && v7[8] == 114 && !v7[14] )
        {
          a2[1] = v8;
          goto LABEL_47;
        }
        if ( v7[2] == 114 && v7[7] == 70 && v7[9] == v7[10] && !v7[11] )
        {
          a2[3] = v8;
          goto LABEL_47;
        }
      }
      if ( *v7 == 76 && v7[1] == 111 && v7[2] == 97 && v7[3] == 100 && v7[4] == 76 && v7[11] == 65 )
      {
        a2[4] = v8;
        goto LABEL_47;
      }
LABEL_48:
      result = ++v13;
      if ( v13 >= v12 )
        return result;
      v3 = v11;
      v4 = v10;
      result = v13;
    }
  }
  return result;
}
// 401942: conditional instruction was optimized away because of 'dl.1==65'
// 4019AB: conditional instruction was optimized away because of 'dl.1==69'
// 4019D0: conditional instruction was optimized away because of 'dl.1==69'

//----- (00401A35) --------------------------------------------------------
_DWORD *__userpurge sub_401A35@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ecx
  _DWORD *result; // eax

  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( (v3 & 0x80000000) == 0 )
      break;
    a1 = (v3 & 0x7FFFFFFF) + a2 + 16;
  }
  result = (_DWORD *)(a2 + *(_DWORD *)(a1 + 4));
  *result += a3;
  return result;
}

//----- (00401A5A) --------------------------------------------------------
_BYTE *__userpurge sub_401A5A@<eax>(_BYTE *result@<eax>, _BYTE *a2@<ecx>, int a3)
{
  while ( a3 )
  {
    --a3;
    *result++ = *a2++;
  }
  return result;
}

//----- (00401A70) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  const char *v3; // ecx
  int v4; // edx
  char v5; // al
  HMODULE v6; // eax
  HWND v7; // edi
  signed int i; // esi
  int v9; // edi
  HWND v10; // eax
  char *v11; // eax
  _BYTE *v12; // eax
  int v13; // edi
  void *v15; // eax
  HMENU v16; // eax
  _BYTE *v17; // eax
  HWND v18; // esi
  HWND v19; // esi
  HMENU v20; // eax
  int v21; // eax
  int *v22; // ecx
  unsigned int v23; // eax
  DWORD *v24; // eax
  DWORD v25; // edi
  DWORD v26; // esi
  HWND v27; // eax
  HMODULE v28; // eax
  HANDLE v29; // eax
  int v30; // esi
  HANDLE v31; // edi
  int v32; // esi
  int v33; // eax
  HANDLE v34; // eax
  void *v35; // eax
  char *v36; // esi
  HGLOBAL v37; // eax
  void *v38; // edi
  char *v39; // ebx
  int v40; // edi
  unsigned int v41; // ecx
  __int16 v42; // ax
  unsigned int v43; // edx
  _DWORD *v44; // eax
  char *v45; // edi
  char *v46; // ebx
  char *v47; // eax
  int v48; // [esp+0h] [ebp-128h]
  int v49; // [esp+0h] [ebp-128h]
  int v50; // [esp+4h] [ebp-124h]
  int v51; // [esp+4h] [ebp-124h]
  int v52; // [esp+8h] [ebp-120h]
  int v53; // [esp+8h] [ebp-120h]
  struct tagWINDOWINFO pwi; // [esp+Ch] [ebp-11Ch] BYREF
  char v55; // [esp+48h] [ebp-E0h] BYREF
  struct tagMSG v56; // [esp+4Ch] [ebp-DCh] BYREF
  char *v57; // [esp+68h] [ebp-C0h]
  _BYTE *v58; // [esp+6Ch] [ebp-BCh]
  int v59; // [esp+70h] [ebp-B8h]
  int v60; // [esp+74h] [ebp-B4h]
  int v61; // [esp+78h] [ebp-B0h]
  _BYTE *v62; // [esp+7Ch] [ebp-ACh]
  int v63; // [esp+80h] [ebp-A8h]
  DWORD dwExitCode; // [esp+84h] [ebp-A4h]
  int v65; // [esp+88h] [ebp-A0h]
  int v66; // [esp+8Ch] [ebp-9Ch]
  int v67; // [esp+90h] [ebp-98h]
  unsigned int v68; // [esp+94h] [ebp-94h]
  int v69; // [esp+98h] [ebp-90h]
  int v70; // [esp+9Ch] [ebp-8Ch]
  char v71[7]; // [esp+A0h] [ebp-88h] BYREF
  char v72[4]; // [esp+A7h] [ebp-81h] BYREF
  char v73[12]; // [esp+ACh] [ebp-7Ch] BYREF
  DWORD ExitCode; // [esp+B8h] [ebp-70h] BYREF
  char *v75; // [esp+BCh] [ebp-6Ch]
  int (__stdcall *v76)(char *); // [esp+C0h] [ebp-68h] BYREF
  void (__stdcall *v77)(DWORD, char *, int, int *); // [esp+C4h] [ebp-64h]
  char *v78; // [esp+C8h] [ebp-60h]
  void (__stdcall *v79)(HWND, _DWORD, int); // [esp+CCh] [ebp-5Ch]
  int (__stdcall *v80)(HWND); // [esp+D0h] [ebp-58h]
  int v81; // [esp+D8h] [ebp-50h] BYREF
  int v82; // [esp+DCh] [ebp-4Ch]
  int v83; // [esp+E0h] [ebp-48h]
  HWND hWndParent; // [esp+E4h] [ebp-44h]
  char *v85; // [esp+E8h] [ebp-40h]
  int v86; // [esp+ECh] [ebp-3Ch]
  char *v87; // [esp+F0h] [ebp-38h]
  HACCEL hAccTable; // [esp+F4h] [ebp-34h]
  HWND hWnd; // [esp+F8h] [ebp-30h]
  char *v90; // [esp+FCh] [ebp-2Ch]
  int v91; // [esp+100h] [ebp-28h]
  int v92; // [esp+104h] [ebp-24h] BYREF
  char *v93; // [esp+108h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+110h] [ebp-18h]

  if ( (unsigned int)lpReserved % 0x23 > 0x46 )
  {
    TlsGetValue(0);
    TlsSetValue(0, (LPVOID)0x6546);
    ms_exc.registration.TryLevel = 0;
    v3 = "This is SPARTA!";
    v4 = 1050196;
    do
    {
      v5 = *v3;
      *(_BYTE *)v4++ = *v3++;
    }
    while ( v5 );
    dword_4050D8 = 100;
    dword_4060D8 = 100;
    ms_exc.registration.TryLevel = -1;
  }
  v63 = 0;
  v91 = 0;
  if ( hinstDLL && fdwReason <= 3 && (!lpReserved || lpReserved == (LPVOID)1) )
  {
    v63 = 1;
    v91 = (int)hinstDLL;
  }
  hWndParent = 0;
  if ( (unsigned int)hinstDLL % 0x17 <= 0x32 )
  {
    if ( !v91 )
      v91 = ((unsigned int)DllEntryPoint & 0xFFFFF000) - 4096;
  }
  else
  {
    hWndParent = GetForegroundWindow();
    v6 = GetModuleHandleA(0);
    if ( hWndParent && v6 )
    {
      memset(&pwi.rcClient, 0, 0x28u);
      pwi.rcWindow.bottom = 15;
      v7 = GetActiveWindow();
      for ( i = 0; i < 11; ++i )
      {
        pwi.dwStyle = i;
        pwi.rcClient.right = (LONG)&v55;
        pwi.rcClient.top = 20;
        pwi.rcClient.left = i >= 2;
        if ( !SendMessageA(v7, 0x1019u, i, (LPARAM)&pwi.rcWindow.bottom) )
          return 0;
      }
    }
  }
  v87 = 0;
  v81 = 0;
  dwExitCode = 0;
  v85 = 0;
  v66 = 0;
  v71[0] = 1;
  v71[1] = 80;
  v71[2] = 86;
  v71[3] = 70;
  v71[4] = 78;
  v71[5] = 78;
  v71[6] = 16;
  strcpy(v72, "FNN");
  v73[0] = 1;
  v73[1] = 46;
  v73[2] = 70;
  v73[3] = 84;
  v73[4] = 40;
  v73[5] = 75;
  v73[6] = 80;
  v73[7] = 70;
  v73[8] = 39;
  v73[9] = 2;
  v9 = v91 + *(_DWORD *)(v91 + 60);
  v67 = v9;
  v69 = 0;
  v92 = 0;
  v60 = 0;
  v70 = 0;
  v90 = 0;
  v65 = 0;
  v61 = 0;
  v86 = 106194171;
  if ( !sub_401799(v91, &v76) )
    return 0;
  v62 = (_BYTE *)((int (__stdcall *)(_DWORD, int, int, int))v78)(0, 7, 12288, 4);
  if ( hWndParent )
  {
    hAccTable = LoadAcceleratorsA(hinstDLL, (LPCSTR)0x64);
    hWnd = CreateWindowExA(0, "Button", "Abc", 0x50010000u, 10, 5, 32, 18, hWndParent, (HMENU)0x1992, hinstDLL, 0);
    v10 = CreateWindowExA(
            0,
            "Static",
            "Q w e r t y B",
            0x50010000u,
            50,
            5,
            100,
            100,
            hWndParent,
            (HMENU)0x363,
            hinstDLL,
            0);
    if ( hWnd && v10 )
    {
      ShowWindow(v10, 0);
      SetWindowTextA(hWnd, "Qwerty Qwerty");
      while ( GetMessageA(&v56, 0, 0, 0) )
      {
        if ( !TranslateAcceleratorA(v56.hwnd, hAccTable, &v56) )
          TranslateMessage(&v56);
      }
      sub_40138A();
    }
  }
  else
  {
    v90 = (char *)((int (__stdcall *)(_DWORD, int, int, int))v78)(0, 10, 4096, 4);
  }
  v59 = *(_DWORD *)(v9 + 80);
  v11 = sub_401367(v71);
  v57 = (char *)v76(v11);
  hWnd = (HWND)sub_401767((int)&v76);
  v93 = (char *)v80(hWnd);
  v79(hWnd, 0, 0x8000);
  if ( !v93 )
    return 0;
  v75 = *(char **)(v9 - 8);
  if ( !v75 )
    return 0;
  v12 = sub_40186E(v90);
  hAccTable = (HACCEL)sub_401390(v93, (int)v12, (int)&v76);
  v79((HWND)v90, 0, 0x8000);
  if ( !hAccTable )
    return 0;
  v13 = v91 + *(_DWORD *)(v9 + 136);
  if ( v13 == v91 )
    return 1;
  hWnd = (HWND)sub_401639((int)&v76);
  v90 = sub_401390(v93, (int)hWnd, (int)&v76);
  v79(hWnd, 0, 0x8000);
  if ( !v90 )
    return 0;
  v68 = (unsigned int)hinstDLL % 0x1B;
  if ( (unsigned int)hinstDLL % 0x1B > 0x32 )
  {
    if ( GetScrollInfo((HWND)0x654757, 0, (LPSCROLLINFO)&v56) )
    {
      v56.pt.x += 20;
      SetScrollInfo((HWND)0x6547547, 0, (LPCSCROLLINFO)&v56, 1);
    }
    else
    {
      v15 = VirtualAlloc(0, 0xAu, 0x2000u, 0x20u);
      if ( v15 )
        VirtualFree(v15, 0, 0x8000u);
    }
  }
  v58 = sub_4016C9((int)&v76);
  hWnd = (HWND)sub_401390(v93, (int)v58, (int)&v76);
  if ( !hWnd )
    return 0;
  v83 = v13 + 16;
  v82 = 0;
  if ( (unsigned int)hinstDLL % 0x41 <= 0x4E )
  {
    if ( (unsigned int)hinstDLL % 0x14 <= 0x32 )
    {
      v92 = ((int (__stdcall *)(_DWORD, int, int, int))v78)(0, 10, 0x2000, 4);
      if ( v92 )
      {
        v86 = ((int (__stdcall *)(int, int, int, int, int, int))hAccTable)(15, 25, 60, 65, 35, 150);
        v79((HWND)v92, 0, 0x8000);
        v92 = 0;
      }
      if ( v86 )
        v70 = ((int (__stdcall *)(int, int, int, int))hWnd)(5, 7, 30, 29);
      v92 = 45;
    }
  }
  else
  {
    v16 = GetMenu(hWndParent);
    if ( v16 )
      ModifyMenuA(v16, 0, 0x400u, 0, "YYYY");
  }
  v17 = sub_40174B(v62);
  v93 = sub_401390(v93, (int)v17, (int)&v76);
  if ( !v93 )
    return 0;
  ExitCode = ((int (__stdcall *)(_DWORD, int, int, int))v78)(0, 100, 12288, 4);
  v86 = ((int (__stdcall *)(int, int, _DWORD))v93)(v86, 10, 0);
  v79((HWND)ExitCode, 0, 0x8000);
  if ( v86 != 400 )
  {
    v18 = hWndParent;
    ShowWindow(hWndParent, 0);
    SetWindowTextA(v18, "MyWindow");
    if ( GetWindowInfo(v18, &pwi) )
    {
      pwi.dwExStyle |= 0x40000u;
      SetWindowLongA(v18, -20, pwi.dwExStyle);
    }
    v19 = GetForegroundWindow();
    MoveWindow(v19, 10, 10, 50, 50, 1);
    if ( !PostMessageA(v19, 0xFu, 0, 0) )
      UpdateWindow(v19);
    return 0;
  }
  ExitCode = ((int (__stdcall *)(int, int, int, int, int, int))hAccTable)(20, 20, 50, 60, 15, 15);
  if ( !ExitCode || !v70 )
    return 0;
  if ( *(_WORD *)(v13 + 14) )
  {
    while ( 1 )
    {
      if ( *(_WORD *)v83 != 23 )
        goto LABEL_80;
      if ( (unsigned int)hinstDLL % 0x4C <= 0x64 )
      {
        v69 = ((int (__stdcall *)(int, int, int, int))hWnd)(15, 16, 20, 21);
      }
      else
      {
        v20 = GetMenu((HWND)0x654674);
        if ( v20 && ModifyMenuA(v20, 5u, 0x400u, 5u, 0) )
        {
          SendMessageA((HWND)0x654674, 0x1000Bu, 1u, 0);
        }
        else if ( GetWindowRect((HWND)0x654674, (LPRECT)&v56.lParam) )
        {
          v56.pt.x += 10;
          InvalidateRect((HWND)0x654674, (const RECT *)&v56.lParam, 1);
        }
      }
      if ( !v69 )
        return 0;
      if ( !v61 )
      {
        v65 = ((int (__stdcall *)(DWORD, _DWORD, _DWORD))v93)(ExitCode, 0, 0);
        v90 -= v65;
      }
      v21 = v13 + (*(_DWORD *)(v83 + 4) & 0x7FFFFFFF);
      v22 = (int *)(v21 + 16);
      v61 = 1;
      hAccTable = 0;
      v23 = *(unsigned __int16 *)(v21 + 14) + *(unsigned __int16 *)(v21 + 12);
      if ( v23 )
        break;
LABEL_80:
      v83 += 8;
      if ( ++v82 >= (unsigned int)*(unsigned __int16 *)(v13 + 14) )
        goto LABEL_81;
    }
    while ( 1 )
    {
      v86 = 0;
      if ( *v22 >= 0 )
      {
        if ( (unsigned int)*v22 > 0x5DC )
          goto LABEL_76;
        v86 = 1;
      }
      if ( v86 )
      {
        v24 = (DWORD *)(v13 + *(_DWORD *)((v22[1] & 0x7FFFFFFF) + v13 + 20));
        v92 += v65;
        dwExitCode = *v24;
        v85 = (char *)v24[1];
        v82 = *(unsigned __int16 *)(v13 + 14);
        v60 = ((int (__stdcall *)(int, int, int, int))hWnd)(1, 2, 3, 4);
        if ( v60 )
        {
          v90 += 176;
          goto LABEL_80;
        }
        return 0;
      }
LABEL_76:
      v22 += 2;
      hAccTable = (HACCEL)((char *)hAccTable + 1);
      if ( (unsigned int)hAccTable >= v23 )
        goto LABEL_80;
    }
  }
LABEL_81:
  v25 = dwExitCode;
  v26 = dwExitCode;
  if ( v68 <= 0x36 )
  {
    v26 = dwExitCode + 1;
  }
  else
  {
    v27 = GetActiveWindow();
    if ( v27 )
      ShowWindow(v27, 3);
  }
  if ( v26 == 1 )
  {
    v28 = GetModuleHandleA(0);
    CloseHandle(v28);
    if ( (unsigned int)hinstDLL % 0xA == 20 )
    {
      TerminateThread((HANDLE)0x54, 1u);
    }
    else
    {
      if ( (unsigned int)hinstDLL % 0xF != 16 )
        return 0;
      v29 = GetCurrentProcess();
      TerminateProcess(v29, 0);
    }
  }
  v78 += v65;
  v30 = v91;
  v68 = v25 + v91;
  if ( !(v25 + v91) )
    return 0;
  if ( (unsigned int)hinstDLL % 0xA == 27 )
  {
    v31 = GetCurrentThread();
    if ( v31 && GetCurrentThreadId() )
      GetExitCodeThread(v31, &ExitCode);
  }
  else
  {
    v77(v25 + v91, v85, 4, &v81);
    v78 -= 176;
  }
  v93 = 0;
  v32 = v59 + v30;
  do
  {
    if ( (unsigned int)v93 > 0x800 )
      break;
    v33 = v32;
    ++v93;
    v32 += 4096;
    v87 = (char *)((int (__stdcall *)(int, char *, int, int))v78)(v33, v75, 12288, 4);
  }
  while ( !v87 );
  ((void (__stdcall *)(_BYTE *, _DWORD, int, int, int, int))v79)(v62, 0, 0x8000, v48, v50, v52);
  if ( (unsigned int)hinstDLL % 0x11 == 21 )
  {
    v34 = HeapCreate(0, 0x400u, 0x100000u);
    if ( v34 )
    {
      v35 = HeapAlloc(v34, 8u, 0x400u);
      qmemcpy(v35, (const void *)(v91 + 1893), 0x400u);
    }
  }
  else
  {
    v93 = (char *)((int (__stdcall *)(int, int, int, int))v90)(v60, v70, v69, 3);
  }
  ((void (__cdecl *)(_BYTE *, _DWORD, int))v79)(v58, 0, 0x8000);
  if ( !v87 )
  {
    v87 = (char *)((int (__stdcall *)(_DWORD, char *, int, int))v78)(0, v75, 12288, 4);
    if ( !v87 )
      return 0;
  }
  sub_401268((int)&v93[v92 - 224 + v68], (unsigned int)v85, v87);
  v36 = v87;
  if ( !sub_4014E5(v87, &v76) )
    return 0;
  if ( (unsigned int)hinstDLL % 0xB == 15 )
  {
    v37 = GlobalAlloc(0x40u, 0x400u);
    v38 = v37;
    if ( v37 )
    {
      *(_BYTE *)((int (__stdcall *)(HGLOBAL, int))(v91 + 1381))(v37, 1049926) = 1;
      GlobalFree(v38);
    }
  }
  if ( !sub_4015E7((int)v36, (int)&v76) || !sub_4016F7((int)v36, v91) )
    return 0;
  v39 = &v36[*((_DWORD *)v36 + 15)];
  v40 = v67;
  ((void (__stdcall *)(int, int, int, int *, int, int, int, DWORD))v77)(v67, 248, 64, &v81, v49, v51, v53, pwi.cbSize);
  *(_DWORD *)(v40 + 80) = -1 - v91;
  *(_DWORD *)(v40 + 140) = *((_DWORD *)v39 + 35);
  *(_DWORD *)(v40 + 136) = &v36[*((_DWORD *)v39 + 34) - v91];
  v41 = (unsigned int)(v39 + 248);
  v42 = *((_WORD *)v39 + 3);
  *(_WORD *)(v40 + 6) = v42;
  v43 = 0;
  if ( v42 )
  {
    v85 = v39 + 248;
    v44 = (_DWORD *)(v40 + 260);
    do
    {
      qmemcpy(v44 - 3, v85, 0x28u);
      *v44 += &v87[-v91];
      ++v43;
      v44 += 10;
      v85 += 40;
      v41 = *(unsigned __int16 *)(v67 + 6);
    }
    while ( v43 < v41 );
  }
  ((void (__fastcall *)(unsigned int, unsigned int, int, int, int, int *))v77)(v41, v43, v67, 248, v81, &v81);
  v45 = v87;
  if ( !sub_4012D3(v87) )
    return 0;
  v77((DWORD)v45, v75, 64, &v81);
  v46 = &v45[*((_DWORD *)v39 + 10)];
  if ( v63 )
  {
    v47 = sub_401390(v57, (int)v73, (int)&v76);
    if ( v47 )
    {
      v92 = 0;
      ((void (__stdcall *)(HINSTANCE, int *))v47)(hinstDLL, &v92);
      if ( v92 )
      {
        *(_DWORD *)(v92 + 24) = v45;
        *(_DWORD *)(v92 + 28) = v46;
        *(_DWORD *)(v92 + 32) = v75;
        v66 = ((int (__stdcall *)(int, char *, DWORD, LPVOID))v46)(1, v45, fdwReason, lpReserved);
      }
    }
  }
  else
  {
    v66 = ((int (__stdcall *)(_DWORD, HINSTANCE, DWORD, LPVOID))v46)(0, hinstDLL, fdwReason, lpReserved);
    v79((HWND)v45, 0, 0x8000);
  }
  return v66;
}
// 401AC2: write access to const memory at 4050D8 has been detected
// 401ACF: write access to const memory at 4060D8 has been detected
// 401F7B: conditional instruction was optimized away because of '%var_24.4==0'
// 40233F: variable 'v48' is possibly undefined
// 40233F: variable 'v50' is possibly undefined
// 40233F: variable 'v52' is possibly undefined
// 402487: variable 'v49' is possibly undefined
// 402487: variable 'v51' is possibly undefined
// 402487: variable 'v53' is possibly undefined
// 4050D8: using guessed type int dword_4050D8;
// 4060D8: using guessed type int dword_4060D8;

//----- (004025B8) --------------------------------------------------------
HANDLE __stdcall GetKJfkdsjgksjgd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "KJgkfdjhlfh");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (004025DE) --------------------------------------------------------
HANDLE __stdcall GetLKVGskgdh()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "KJglfdjhlfhfhfg");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402604) --------------------------------------------------------
HANDLE __stdcall GetGHsdjkglkdh()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "<f;sdlkhldskhd;s");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (0040262A) --------------------------------------------------------
HANDLE __stdcall GetFJlksdjglkdfjhd()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, ">KFa;ksdg;rejh dj");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

//----- (00402650) --------------------------------------------------------
HANDLE __stdcall GetKJGjhgfdhfdkh()
{
  HANDLE v0; // esi

  v0 = CreateEventA(0, 1, 1, "F>K;sdkgsd;jhsdl;k");
  SetEvent(v0);
  CloseHandle(v0);
  return v0;
}

// nfuncs=30 queued=27 decompiled=27 lumina nreq=0 worse=0 better=0
// ALL OK, 27 function(s) have been successfully decompiled
