// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__VirtualProtect = &g_t1277C; // 00412000
<anonymous> * __imp__lstrlenW = &g_t1278E; // 00412004
<anonymous> * __imp__CreateThread = &g_t1279A; // 00412008
<anonymous> * __imp__ExitProcess = &g_t127AA; // 0041200C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t127B8; // 00412010
<anonymous> * __imp__GetCurrentThreadId = &g_t127D2; // 00412014
<anonymous> * __imp__GetProcessHeap = &g_t127E8; // 00412018
<anonymous> * __imp__ExitProcess = &g_t127FA; // 0041201C
<anonymous> * __imp__lstrcpyW = &g_t12808; // 00412020
<anonymous> * __imp__CloseHandle = &g_t12814; // 00412024
<anonymous> * __imp__GetACP = &g_t12822; // 00412028
<anonymous> * __imp__InitializeCriticalSection = &g_t1282C; // 0041202C
<anonymous> * __imp__GetModuleFileNameA = &g_t12848; // 00412030
<anonymous> * __imp__SetEvent = &g_t1285E; // 00412034
<anonymous> * __imp__LoadLibraryW = &g_t1286A; // 00412038
<anonymous> * __imp__VirtualProtect = &g_t1287A; // 0041203C
<anonymous> * __imp__InitializeCriticalSection = &g_t1288C; // 00412040
<anonymous> * __imp__GetCommandLineA = &g_t128A8; // 00412044
<anonymous> * __imp__TerminateProcess = &g_t128BA; // 00412048
<anonymous> * __imp__GetModuleFileNameA = &g_t128CE; // 0041204C
<anonymous> * __imp__HeapFree = &g_t128E4; // 00412050
<anonymous> * __imp__QueryPerformanceCounter = &g_t128F0; // 00412054
<anonymous> * __imp__CreateFileW = &g_t1290A; // 00412058
<anonymous> * __imp__SetEvent = &g_t12918; // 0041205C
<anonymous> * __imp__WaitForSingleObject = &g_t12924; // 00412060
<anonymous> * __imp__SetEvent = &g_t1293A; // 00412064
<anonymous> * __imp__SetLastError = &g_t12946; // 00412068
<anonymous> * __imp__CloseHandle = &g_t12956; // 0041206C
<anonymous> * __imp__lstrcpyW = &g_t12964; // 00412070
<anonymous> * __imp__LocalAlloc = &g_t12970; // 00412074
<anonymous> * __imp__FreeLibrary = &g_t1297E; // 00412078
<anonymous> * __imp__SetFilePointer = &g_t1298C; // 0041207C
<anonymous> * __imp__GetProcessHeap = &g_t1299E; // 00412080
<anonymous> * __imp__HeapFree = &g_t129B0; // 00412084
<anonymous> * __imp__GetLastError = &g_t129BC; // 00412088
<anonymous> * __imp__VirtualProtect = &g_t129CC; // 0041208C
<anonymous> * __imp__GetCurrentThreadId = &g_t129DE; // 00412090
<anonymous> * __imp__LocalFree = &g_t129F4; // 00412094
<anonymous> * __imp__FreeLibrary = &g_t12A00; // 00412098
<anonymous> * __imp__HeapReAlloc = &g_t12A0E; // 0041209C
<anonymous> * __imp__SetEvent = &g_t12A1C; // 004120A0
<anonymous> * __imp__UnhandledExceptionFilter = &g_t12A28; // 004120A4
<anonymous> * __imp__TerminateProcess = &g_t12A44; // 004120A8
<anonymous> * __imp__WideCharToMultiByte = &g_t12A58; // 004120AC
<anonymous> * __imp__WideCharToMultiByte = &g_t12A6E; // 004120B0
<anonymous> * __imp__VirtualFree = &g_t12A84; // 004120B4
<anonymous> * __imp__GetProcessHeap = &g_t12A92; // 004120B8
<anonymous> * __imp__GetStartupInfoA = &g_t12AA4; // 004120BC
<anonymous> * __imp__GetProcAddress = &g_t12AB6; // 004120C0
<anonymous> * __imp__MultiByteToWideChar = &g_t12AC8; // 004120C4
<anonymous> * __imp__EnterCriticalSection = &g_t12ADE; // 004120C8
<anonymous> * __imp__CloseHandle = &g_t12AF6; // 004120CC
<anonymous> * __imp__LeaveCriticalSection = &g_t12B04; // 004120D0
<anonymous> * __imp__CreateThread = &g_t12B1C; // 004120D4
<anonymous> * __imp__lstrcmpiW = &g_t12B2C; // 004120D8
<anonymous> * __imp__VirtualFree = &g_t12B38; // 004120DC
<anonymous> * __imp__LocalFree = &g_t12B46; // 004120E0
<anonymous> * __imp__LocalFree = &g_t12B52; // 004120E4
<anonymous> * __imp__LoadLibraryA = &g_t12B5E; // 004120E8
<anonymous> * __imp__GetLastError = &g_t12B6E; // 004120EC
<anonymous> * __imp__InterlockedDecrement = &g_t12B7E; // 004120F0
<anonymous> * __imp__VirtualAlloc = &g_t12B96; // 004120F4
<anonymous> * __imp__GetStartupInfoA = &g_t12BA6; // 004120F8
<anonymous> * __imp__GetCurrentProcessId = &g_t12BB8; // 004120FC
<anonymous> * __imp__GetModuleFileNameA = &g_t12BCE; // 00412100
<anonymous> * __imp__DeleteCriticalSection = &g_t12BE4; // 00412104
<anonymous> * __imp__ExitProcess = &g_t12BFC; // 00412108
<anonymous> * __imp__HeapDestroy = &g_t12C0A; // 0041210C
<anonymous> * __imp__lstrlenW = &g_t12C18; // 00412110
<anonymous> * __imp__LocalFree = &g_t12C24; // 00412114
<anonymous> * __imp__InterlockedDecrement = &g_t12C30; // 00412118
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12C48; // 0041211C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t12C62; // 00412120
<anonymous> * __imp__RealizePalette = &g_t12C8A; // 00412128
<anonymous> * __imp__CreateCompatibleBitmap = &g_t12C9C; // 0041212C
<anonymous> * __imp__SetTextColor = &g_t12CB6; // 00412130
<anonymous> * __imp__SetBkColor = &g_t12CC6; // 00412134
<anonymous> * __imp__Rectangle = &g_t12CD4; // 00412138
<anonymous> * __imp__GetObjectW = &g_t12CE0; // 0041213C
<anonymous> * __imp__TranslateCharsetInfo = &g_t12CEE; // 00412140
<anonymous> * __imp__SetBkColor = &g_t12D06; // 00412144
<anonymous> * __imp__GetObjectA = &g_t12D14; // 00412148
<anonymous> * __imp__CreateRectRgn = &g_t12D22; // 0041214C
<anonymous> * __imp__CreateFontIndirectW = &g_t12D32; // 00412150
<anonymous> * __imp__GetTextExtentPoint32W = &g_t12D48; // 00412154
<anonymous> * __imp__StretchBlt = &g_t12D60; // 00412158
<anonymous> * __imp__SaveDC = &g_t12D6E; // 0041215C
<anonymous> * __imp__MoveToEx = &g_t12D78; // 00412160
<anonymous> * __imp__SetBkMode = &g_t12D84; // 00412164
<anonymous> * __imp__SelectPalette = &g_t12D90; // 00412168
<anonymous> * __imp__SetTextAlign = &g_t12DA0; // 0041216C
<anonymous> * __imp__GetObjectW = &g_t12DB0; // 00412170
<anonymous> * __imp__GetStockObject = &g_t12DBE; // 00412174
<anonymous> * __imp__TextOutW = &g_t12DD0; // 00412178
<anonymous> * __imp__DeleteObject = &g_t12DDC; // 0041217C
<anonymous> * __imp__CreateCompatibleBitmap = &g_t12DEC; // 00412180
<anonymous> * __imp__SetTextAlign = &g_t12E06; // 00412184
<anonymous> * __imp__SelectObject = &g_t12E16; // 00412188
<anonymous> * __imp__CreateBitmap = &g_t12E26; // 0041218C
<anonymous> * __imp__GetDeviceCaps = &g_t12E36; // 00412190
<anonymous> * __imp__CreateRectRgn = &g_t12E46; // 00412194
<anonymous> * __imp__LineTo = &g_t12E56; // 00412198
<anonymous> * __imp__CreateBitmap = &g_t12E60; // 0041219C
<anonymous> * __imp__LineTo = &g_t12E70; // 004121A0
<anonymous> * __imp__CreateRectRgn = &g_t12E7A; // 004121A4
<anonymous> * __imp__SelectPalette = &g_t12E8A; // 004121A8
<anonymous> * __imp__TextOutW = &g_t12E9A; // 004121AC
<anonymous> * __imp__GetTextExtentPoint32W = &g_t12EA6; // 004121B0
<anonymous> * __imp__DeleteDC = &g_t12EBE; // 004121B4
<anonymous> * __imp__SetBkMode = &g_t12ECA; // 004121B8
<anonymous> * __imp__SetTextAlign = &g_t12ED6; // 004121BC
<anonymous> * __imp__TextOutW = &g_t12EE6; // 004121C0
<anonymous> * __imp__GetObjectA = &g_t12EF2; // 004121C4
<anonymous> * __imp__SetBkColor = &g_t12F00; // 004121C8
<anonymous> * __imp__CreateCompatibleBitmap = &g_t12F0E; // 004121CC
<anonymous> * __imp__DeleteObject = &g_t12F28; // 004121D0
<anonymous> * __imp__SaveDC = &g_t12F38; // 004121D4
<anonymous> * __imp__Rectangle = &g_t12F42; // 004121D8
<anonymous> * __imp__SetTextColor = &g_t12F4E; // 004121DC
<anonymous> * __imp__BitBlt = &g_t12F5E; // 004121E0
<anonymous> * __imp__CreateCompatibleBitmap = &g_t12F68; // 004121E4
<anonymous> * __imp__SetStretchBltMode = &g_t12F82; // 004121E8
<anonymous> * __imp__ExtTextOutW = &g_t12F96; // 004121EC
<anonymous> * __imp__SetBkColor = &g_t12FA4; // 004121F0
<anonymous> * __imp__SaveDC = &g_t12FB2; // 004121F4
<anonymous> * __imp__GetTextMetricsW = &g_t12FBC; // 004121F8
<anonymous> * __imp__SetTextColor = &g_t12FCE; // 004121FC
<anonymous> * __imp__SetWindowExtEx = &g_t12FDE; // 00412200
<anonymous> * __imp__RestoreDC = &g_t12FF0; // 00412204
<anonymous> * __imp__GetTextExtentPoint32W = &g_t12FFC; // 00412208
<anonymous> * __imp__SetTextAlign = &g_t13014; // 0041220C
<anonymous> * __imp__GetTextExtentPointW = &g_t13024; // 00412210
<anonymous> * __imp__CreatePen = &g_t1303A; // 00412214
<anonymous> * __imp__CreateBitmap = &g_t13046; // 00412218
<anonymous> * __imp__SetBkColor = &g_t13056; // 0041221C
<anonymous> * __imp__SetStretchBltMode = &g_t13064; // 00412220
<anonymous> * __imp__GetDeviceCaps = &g_t13078; // 00412224
<anonymous> * __imp__SetMapMode = &g_t13088; // 00412228
<anonymous> * __imp__SetMapMode = &g_t13096; // 0041222C
<anonymous> * __imp__GetObjectA = &g_t130A4; // 00412230
<anonymous> * __imp__DeleteObject = &g_t130B2; // 00412234
<anonymous> * __imp__CreatePatternBrush = &g_t130C2; // 00412238
<anonymous> * __imp__SelectObject = &g_t130D8; // 0041223C
<anonymous> * __imp__CreateRectRgn = &g_t130E8; // 00412240
<anonymous> * __imp__SetTextColor = &g_t130F8; // 00412244
<anonymous> * __imp__SaveDC = &g_t13108; // 00412248
<anonymous> * __imp__GetTextMetricsW = &g_t13112; // 0041224C
<anonymous> * __imp__PatBlt = &g_t13124; // 00412250
<anonymous> * __imp__CreateCompatibleBitmap = &g_t1312E; // 00412254
<anonymous> * __imp__TextOutW = &g_t13148; // 00412258
<anonymous> * __imp__CreateRectRgn = &g_t13154; // 0041225C
<anonymous> * __imp__SetWindowLongW = &g_t1316E; // 00412264
<anonymous> * __imp__MapWindowPoints = &g_t13180; // 00412268
<anonymous> * __imp__LoadAcceleratorsW = &g_t13192; // 0041226C
<anonymous> * __imp__ShowCursor = &g_t131A6; // 00412270
<anonymous> * __imp__SetTimer = &g_t131B4; // 00412274
<anonymous> * __imp__WinHelpW = &g_t131C0; // 00412278
<anonymous> * __imp__CloseWindowStation = &g_t131CC; // 0041227C
<anonymous> * __imp__CheckDlgButton = &g_t131E2; // 00412280
<anonymous> * __imp__SetWindowPlacement = &g_t131F4; // 00412284
<anonymous> * __imp__PostMessageW = &g_t1320A; // 00412288
<anonymous> * __imp__SetDlgItemTextW = &g_t1321A; // 0041228C
<anonymous> * __imp__SetScrollInfo = &g_t1322C; // 00412290
<anonymous> * __imp__GetParent = &g_t1323C; // 00412294
<anonymous> * __imp__PtInRect = &g_t13248; // 00412298
<anonymous> * __imp__GetWindowLongA = &g_t13254; // 0041229C
<anonymous> * __imp__GetDlgItemTextW = &g_t13266; // 004122A0
<anonymous> * __imp__SetCapture = &g_t13278; // 004122A4
<anonymous> * __imp__FindWindowW = &g_t13286; // 004122A8
<anonymous> * __imp__IntersectRect = &g_t13294; // 004122AC
<anonymous> * __imp__GetWindow = &g_t132A4; // 004122B0
<anonymous> * __imp__IsClipboardFormatAvailable = &g_t132B0; // 004122B4
<anonymous> * __imp__IsWindowEnabled = &g_t132CE; // 004122B8
<anonymous> * __imp__SendMessageW = &g_t132E0; // 004122BC
<anonymous> * __imp__DeleteMenu = &g_t132F0; // 004122C0
<anonymous> * __imp__GetFocus = &g_t132FE; // 004122C4
<anonymous> * __imp__SendMessageW = &g_t1330A; // 004122C8
<anonymous> * __imp__MsgWaitForMultipleObjects = &g_t1331A; // 004122CC
<anonymous> * __imp__ScreenToClient = &g_t13336; // 004122D0
<anonymous> * __imp__CloseWindowStation = &g_t13348; // 004122D4
<anonymous> * __imp__SetWindowPos = &g_t1335E; // 004122D8
<anonymous> * __imp__EndDialog = &g_t1336E; // 004122DC
<anonymous> * __imp__DefWindowProcA = &g_t1337A; // 004122E0
<anonymous> * __imp__SetCapture = &g_t1338C; // 004122E4
<anonymous> * __imp__EnableWindow = &g_t1339A; // 004122E8
<anonymous> * __imp__MapWindowPoints = &g_t133AA; // 004122EC
<anonymous> * __imp__SystemParametersInfoW = &g_t133BC; // 004122F0
<anonymous> * __imp__DefWindowProcA = &g_t133D4; // 004122F4
<anonymous> * __imp__BringWindowToTop = &g_t133E6; // 004122F8
<anonymous> * __imp__LoadStringW = &g_t133FA; // 004122FC
<anonymous> * __imp__SendMessageA = &g_t13408; // 00412300
<anonymous> * __imp__SetActiveWindow = &g_t13418; // 00412304
<anonymous> * __imp__CharUpperW = &g_t1342A; // 00412308
<anonymous> * __imp__SetDlgItemTextW = &g_t13438; // 0041230C
<anonymous> * __imp__UpdateWindow = &g_t1344A; // 00412310
<anonymous> * __imp__EndPaint = &g_t1345A; // 00412314
<anonymous> * __imp__CreateWindowExA = &g_t13466; // 00412318
<anonymous> * __imp__GetSystemMetrics = &g_t13478; // 0041231C
<anonymous> * __imp__SendDlgItemMessageW = &g_t1348C; // 00412320
<anonymous> * __imp__GetWindowTextLengthW = &g_t134A2; // 00412324
<anonymous> * __imp__MessageBoxW = &g_t134BA; // 00412328
<anonymous> * __imp__ReleaseCapture = &g_t134C8; // 0041232C
<anonymous> * __imp__MapWindowPoints = &g_t134DA; // 00412330
<anonymous> * __imp__EndDialog = &g_t134EC; // 00412334
<anonymous> * __imp__IntersectRect = &g_t134F8; // 00412338
<anonymous> * __imp__DestroyIcon = &g_t13508; // 0041233C
<anonymous> * __imp__GetAsyncKeyState = &g_t13516; // 00412340
<anonymous> * __imp__RegisterClassA = &g_t1352A; // 00412344
<anonymous> * __imp__SetScrollPos = &g_t1353C; // 00412348
<anonymous> * __imp__GetFocus = &g_t1354C; // 0041234C
<anonymous> * __imp__CallWindowProcW = &g_t13558; // 00412350
<anonymous> * __imp__BringWindowToTop = &g_t1356A; // 00412354
<anonymous> * __imp__SetScrollInfo = &g_t1357E; // 00412358
<anonymous> * __imp__LoadStringW = &g_t1358E; // 0041235C
<anonymous> * __imp__SetWindowTextW = &g_t1359C; // 00412360
<anonymous> * __imp__ScreenToClient = &g_t135AE; // 00412364
<anonymous> * __imp__SendMessageA = &g_t135C0; // 00412368
<anonymous> * __imp__RegisterClipboardFormatW = &g_t135D0; // 0041236C
<anonymous> * __imp__SetProcessWindowStation = &g_t135EC; // 00412370
<anonymous> * __imp__BringWindowToTop = &g_t13606; // 00412374
<anonymous> * __imp__GetWindowTextW = &g_t1361A; // 00412378
<anonymous> * __imp__EqualRect = &g_t1362C; // 0041237C
<anonymous> * __imp__GetSubMenu = &g_t13638; // 00412380
<anonymous> * __imp__RegisterClassW = &g_t13646; // 00412384
<anonymous> * __imp__GetFocus = &g_t13658; // 00412388
<anonymous> * __imp__CheckMenuItem = &g_t13664; // 0041238C
word32 g_dw4123E8 = 0x0001277C; // 004123E8
word32 g_dw4123EC = 75662; // 004123EC
word32 g_dw4123F0 = 75674; // 004123F0
word32 g_dw4123F4 = 0x000127AA; // 004123F4
word32 g_dw4123F8 = 75704; // 004123F8
word32 g_dw4123FC = 0x000127D2; // 004123FC
word32 g_dw412400 = 75752; // 00412400
word32 g_dw412404 = 75770; // 00412404
word32 g_dw412408 = 0x00012808; // 00412408
word32 g_dw41240C = 0x00012814; // 0041240C
word32 g_dw412410 = 0x00012822; // 00412410
word32 g_dw412414 = 0x0001282C; // 00412414
word32 g_dw412418 = 0x00012848; // 00412418
word32 g_dw41241C = 75870; // 0041241C
word32 g_dw412420 = 75882; // 00412420
word32 g_dw412424 = 75898; // 00412424
word32 g_dw412428 = 0x0001288C; // 00412428
word32 g_dw41242C = 0x000128A8; // 0041242C
word32 g_dw412430 = 0x000128BA; // 00412430
word32 g_dw412434 = 0x000128CE; // 00412434
word32 g_dw412438 = 76004; // 00412438
word32 g_dw41243C = 76016; // 0041243C
word32 g_dw412440 = 0x0001290A; // 00412440
word32 g_dw412444 = 0x00012918; // 00412444
word32 g_dw412448 = 0x00012924; // 00412448
word32 g_dw41244C = 76090; // 0041244C
word32 g_dw412450 = 0x00012946; // 00412450
word32 g_dw412454 = 76118; // 00412454
word32 g_dw412458 = 0x00012964; // 00412458
word32 g_dw41245C = 76144; // 0041245C
word32 g_dw412460 = 0x0001297E; // 00412460
word32 g_dw412464 = 76172; // 00412464
word32 g_dw412468 = 0x0001299E; // 00412468
word32 g_dw41246C = 0x000129B0; // 0041246C
word32 g_dw412470 = 76220; // 00412470
word32 g_dw412474 = 0x000129CC; // 00412474
word32 g_dw412478 = 0x000129DE; // 00412478
word32 g_dw41247C = 76276; // 0041247C
word32 g_dw412480 = 0x00012A00; // 00412480
word32 g_dw412484 = 0x00012A0E; // 00412484
word32 g_dw412488 = 0x00012A1C; // 00412488
word32 g_dw41248C = 0x00012A28; // 0041248C
word32 g_dw412490 = 0x00012A44; // 00412490
word32 g_dw412494 = 76376; // 00412494
word32 g_dw412498 = 0x00012A6E; // 00412498
word32 g_dw41249C = 0x00012A84; // 0041249C
word32 g_dw4124A0 = 0x00012A92; // 004124A0
word32 g_dw4124A4 = 0x00012AA4; // 004124A4
word32 g_dw4124A8 = 76470; // 004124A8
word32 g_dw4124AC = 76488; // 004124AC
word32 g_dw4124B0 = 0x00012ADE; // 004124B0
word32 g_dw4124B4 = 0x00012AF6; // 004124B4
word32 g_dw4124B8 = 0x00012B04; // 004124B8
word32 g_dw4124BC = 0x00012B1C; // 004124BC
word32 g_dw4124C0 = 0x00012B2C; // 004124C0
word32 g_dw4124C4 = 76600; // 004124C4
word32 g_dw4124C8 = 76614; // 004124C8
word32 g_dw4124CC = 76626; // 004124CC
word32 g_dw4124D0 = 76638; // 004124D0
word32 g_dw4124D4 = 76654; // 004124D4
word32 g_dw4124D8 = 76670; // 004124D8
word32 g_dw4124DC = 76694; // 004124DC
word32 g_dw4124E0 = 76710; // 004124E0
word32 g_dw4124E4 = 0x00012BB8; // 004124E4
word32 g_dw4124E8 = 76750; // 004124E8
word32 g_dw4124EC = 76772; // 004124EC
word32 g_dw4124F0 = 76796; // 004124F0
word32 g_dw4124F4 = 0x00012C0A; // 004124F4
word32 g_dw4124F8 = 0x00012C18; // 004124F8
word32 g_dw4124FC = 0x00012C24; // 004124FC
word32 g_dw412500 = 76848; // 00412500
word32 g_dw412504 = 76872; // 00412504
word32 g_dw412508 = 0x00012C62; // 00412508
word32 g_dw412510 = 0x00012C8A; // 00412510
word32 g_dw412514 = 0x00012C9C; // 00412514
word32 g_dw412518 = 0x00012CB6; // 00412518
word32 g_dw41251C = 0x00012CC6; // 0041251C
word32 g_dw412520 = 77012; // 00412520
word32 g_dw412524 = 77024; // 00412524
word32 g_dw412528 = 0x00012CEE; // 00412528
word32 g_dw41252C = 77062; // 0041252C
word32 g_dw412530 = 77076; // 00412530
word32 g_dw412534 = 0x00012D22; // 00412534
word32 g_dw412538 = 0x00012D32; // 00412538
word32 g_dw41253C = 77128; // 0041253C
word32 g_dw412540 = 77152; // 00412540
word32 g_dw412544 = 77166; // 00412544
word32 g_dw412548 = 77176; // 00412548
word32 g_dw41254C = 77188; // 0041254C
word32 g_dw412550 = 77200; // 00412550
word32 g_dw412554 = 77216; // 00412554
word32 g_dw412558 = 77232; // 00412558
word32 g_dw41255C = 77246; // 0041255C
word32 g_dw412560 = 0x00012DD0; // 00412560
word32 g_dw412564 = 77276; // 00412564
word32 g_dw412568 = 77292; // 00412568
word32 g_dw41256C = 77318; // 0041256C
word32 g_dw412570 = 77334; // 00412570
word32 g_dw412574 = 0x00012E26; // 00412574
word32 g_dw412578 = 77366; // 00412578
word32 g_dw41257C = 77382; // 0041257C
word32 g_dw412580 = 77398; // 00412580
word32 g_dw412584 = 77408; // 00412584
word32 g_dw412588 = 77424; // 00412588
word32 g_dw41258C = 77434; // 0041258C
word32 g_dw412590 = 77450; // 00412590
word32 g_dw412594 = 77466; // 00412594
word32 g_dw412598 = 77478; // 00412598
word32 g_dw41259C = 0x00012EBE; // 0041259C
word32 g_dw4125A0 = 77514; // 004125A0
word32 g_dw4125A4 = 77526; // 004125A4
word32 g_dw4125A8 = 0x00012EE6; // 004125A8
word32 g_dw4125AC = 77554; // 004125AC
word32 g_dw4125B0 = 0x00012F00; // 004125B0
word32 g_dw4125B4 = 77582; // 004125B4
word32 g_dw4125B8 = 0x00012F28; // 004125B8
word32 g_dw4125BC = 77624; // 004125BC
word32 g_dw4125C0 = 0x00012F42; // 004125C0
word32 g_dw4125C4 = 77646; // 004125C4
word32 g_dw4125C8 = 77662; // 004125C8
word32 g_dw4125CC = 77672; // 004125CC
word32 g_dw4125D0 = 0x00012F82; // 004125D0
word32 g_dw4125D4 = 77718; // 004125D4
word32 g_dw4125D8 = 77732; // 004125D8
word32 g_dw4125DC = 77746; // 004125DC
word32 g_dw4125E0 = 77756; // 004125E0
word32 g_dw4125E4 = 77774; // 004125E4
word32 g_dw4125E8 = 77790; // 004125E8
word32 g_dw4125EC = 77808; // 004125EC
word32 g_dw4125F0 = 0x00012FFC; // 004125F0
word32 g_dw4125F4 = 77844; // 004125F4
word32 g_dw4125F8 = 77860; // 004125F8
word32 g_dw4125FC = 77882; // 004125FC
word32 g_dw412600 = 77894; // 00412600
word32 g_dw412604 = 77910; // 00412604
word32 g_dw412608 = 77924; // 00412608
word32 g_dw41260C = 77944; // 0041260C
word32 g_dw412610 = 0x00013088; // 00412610
word32 g_dw412614 = 77974; // 00412614
word32 g_dw412618 = 77988; // 00412618
word32 g_dw41261C = 78002; // 0041261C
word32 g_dw412620 = 78018; // 00412620
word32 g_dw412624 = 78040; // 00412624
word32 g_dw412628 = 0x000130E8; // 00412628
word32 g_dw41262C = 78072; // 0041262C
word32 g_dw412630 = 78088; // 00412630
word32 g_dw412634 = 0x00013112; // 00412634
word32 g_dw412638 = 0x00013124; // 00412638
word32 g_dw41263C = 0x0001312E; // 0041263C
word32 g_dw412640 = 0x00013148; // 00412640
word32 g_dw412644 = 0x00013154; // 00412644
word32 g_dw41264C = 0x0001316E; // 0041264C
word32 g_dw412650 = 0x00013180; // 00412650
word32 g_dw412654 = 0x00013192; // 00412654
word32 g_dw412658 = 0x000131A6; // 00412658
word32 g_dw41265C = 0x000131B4; // 0041265C
word32 g_dw412660 = 78272; // 00412660
word32 g_dw412664 = 0x000131CC; // 00412664
word32 g_dw412668 = 0x000131E2; // 00412668
word32 g_dw41266C = 0x000131F4; // 0041266C
word32 g_dw412670 = 0x0001320A; // 00412670
word32 g_dw412674 = 0x0001321A; // 00412674
word32 g_dw412678 = 0x0001322C; // 00412678
word32 g_dw41267C = 0x0001323C; // 0041267C
word32 g_dw412680 = 78408; // 00412680
word32 g_dw412684 = 0x00013254; // 00412684
word32 g_dw412688 = 0x00013266; // 00412688
word32 g_dw41268C = 0x00013278; // 0041268C
word32 g_dw412690 = 78470; // 00412690
word32 g_dw412694 = 78484; // 00412694
word32 g_dw412698 = 78500; // 00412698
word32 g_dw41269C = 0x000132B0; // 0041269C
word32 g_dw4126A0 = 0x000132CE; // 004126A0
word32 g_dw4126A4 = 0x000132E0; // 004126A4
word32 g_dw4126A8 = 78576; // 004126A8
word32 g_dw4126AC = 0x000132FE; // 004126AC
word32 g_dw4126B0 = 0x0001330A; // 004126B0
word32 g_dw4126B4 = 0x0001331A; // 004126B4
word32 g_dw4126B8 = 0x00013336; // 004126B8
word32 g_dw4126BC = 0x00013348; // 004126BC
word32 g_dw4126C0 = 78686; // 004126C0
word32 g_dw4126C4 = 0x0001336E; // 004126C4
word32 g_dw4126C8 = 0x0001337A; // 004126C8
word32 g_dw4126CC = 0x0001338C; // 004126CC
word32 g_dw4126D0 = 0x0001339A; // 004126D0
word32 g_dw4126D4 = 0x000133AA; // 004126D4
word32 g_dw4126D8 = 78780; // 004126D8
word32 g_dw4126DC = 0x000133D4; // 004126DC
word32 g_dw4126E0 = 78822; // 004126E0
word32 g_dw4126E4 = 0x000133FA; // 004126E4
word32 g_dw4126E8 = 78856; // 004126E8
word32 g_dw4126EC = 78872; // 004126EC
word32 g_dw4126F0 = 78890; // 004126F0
word32 g_dw4126F4 = 0x00013438; // 004126F4
word32 g_dw4126F8 = 0x0001344A; // 004126F8
word32 g_dw4126FC = 78938; // 004126FC
word32 g_dw412700 = 0x00013466; // 00412700
word32 g_dw412704 = 78968; // 00412704
word32 g_dw412708 = 78988; // 00412708
word32 g_dw41270C = 79010; // 0041270C
word32 g_dw412710 = 0x000134BA; // 00412710
word32 g_dw412714 = 0x000134C8; // 00412714
word32 g_dw412718 = 79066; // 00412718
word32 g_dw41271C = 0x000134EC; // 0041271C
word32 g_dw412720 = 79096; // 00412720
word32 g_dw412724 = 79112; // 00412724
word32 g_dw412728 = 0x00013516; // 00412728
word32 g_dw41272C = 0x0001352A; // 0041272C
word32 g_dw412730 = 0x0001353C; // 00412730
word32 g_dw412734 = 0x0001354C; // 00412734
word32 g_dw412738 = 0x00013558; // 00412738
word32 g_dw41273C = 0x0001356A; // 0041273C
word32 g_dw412740 = 0x0001357E; // 00412740
word32 g_dw412744 = 0x0001358E; // 00412744
word32 g_dw412748 = 0x0001359C; // 00412748
word32 g_dw41274C = 79278; // 0041274C
word32 g_dw412750 = 79296; // 00412750
word32 g_dw412754 = 0x000135D0; // 00412754
word32 g_dw412758 = 0x000135EC; // 00412758
word32 g_dw41275C = 0x00013606; // 0041275C
word32 g_dw412760 = 0x0001361A; // 00412760
word32 g_dw412764 = 79404; // 00412764
word32 g_dw412768 = 0x00013638; // 00412768
word32 g_dw41276C = 0x00013646; // 0041276C
word32 g_dw412770 = 79448; // 00412770
word32 g_dw412774 = 0x00013664; // 00412774
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401290: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 fp;
	ui32 ecx;
	ui32 esi;
	struct Eq_6 * edx;
	struct Eq_7 * eax;
	struct Eq_8 * gs;
	byte al_32 = (byte) eax;
	uint64 eax_esi_990;
	ui64 esi_ebx_987;
	ui64 edi_edx_984;
	ui32 eax_161;
	struct Eq_15 * ecx_454;
	struct Eq_16 * ebx_147;
	struct Eq_17 * esi_319;
	struct Eq_17 * ecx_310;
	struct Eq_19 * edi_307;
	struct Eq_20 * eax_327;
	struct Eq_17 * edx_331;
	struct Eq_22 * edi_106;
	struct Eq_23 * ecx_330;
	uint32 ebx_321;
	struct Eq_25 * edx_100;
	uint32 ecx_489;
	ui32 ebx_485;
	struct Eq_28 * eax_456;
	struct Eq_29 * edx_239;
	ptr32 eax_265;
	struct Eq_31 * edx_113;
	struct Eq_32 * ecx_126;
	uint32 esi_285;
	struct Eq_25 * eax_286;
	ui32 esi_213;
	ui64 ebx_ecx_981;
	up32 v38_353;
	ui32 esi_17 = (esi & ecx) - eax;
	ui32 ecx_20 = ecx;
	struct Eq_29 * esi_124 = edx + esi_17 / 2073990975;
	struct Eq_44 * esp_235 = fp - 4;
	struct Eq_47 * ebp_175 = fp - 4;
	struct Eq_29 * ebx_129 = ecx - esi_17;
	struct Eq_51 * edi_223 = esi_124 - ecx;
	if (esi_124 != (struct Eq_29 *) 3976338867)
	{
		edi_223 = edi_223 - eax - (word32) (esi_124 < (struct Eq_29 *) 3976338867);
		goto l00401213;
	}
	eax->b90848411 &= al_32;
	ebx_129->dw0000 += fp - 4;
	while (true)
	{
		struct Eq_47 * esp_44 = esp_235 - 4;
		esp_44->dw0000 = ebp_175;
		ebx_147 = ebx_129 | esi_124;
		word24 eax_24_8_66 = SLICE(eax, word24, 8);
		byte al_141 = (byte) eax;
		ebp_175 = esp_44;
		esp_235 = esp_44 - -12329;
		ecx_454 = ecx_20 - edx | ebx_147 | ebx_147;
		esi_213 = esi_124 - eax;
		if (ebx_147 == (struct Eq_16 *) 3582934434)
		{
			eax->b20112220 &= al_141;
			eax_161 = SEQ(eax_24_8_66, al_141 + 11);
l004012EB:
			ebx_147->dw0000 = -ebx_147->dw0000;
			do
			{
				ui32 edi_160 = edx & ebx_147;
				edx = eax_161 | edi_160;
				eax_161 += 0x783BB7C9;
				word32 ebx_165 = ebx_147 + edx;
				ebx_147 = ebx_165 - ecx_454 - (word32) (ebx_165 < 0x00);
			} while (eax_161 != 0x000B4E03);
			__fclex();
			__wait();
			word32 ecx_171 = 0x00;
			do
			{
				ebp_175 = ebp_175->dw0000;
				Eq_2 eax_180 = __smsw<word32>();
				struct Eq_44 * esp_179 = &ebp_175->dw0000 + 1;
				byte al_188 = (byte) eax_180;
				++ecx_171;
				if (edi_160 == 0x070271B0)
				{
					eax_180->dwBF11B04 = eax_180 + eax_180->dwBF11B04 / 2073990975;
					goto l00401374;
				}
				if (ecx_171 == 0x02)
					return eax_180;
			} while ((al_188 & 0x08) != 0x00);
			do
			{
				Eq_2 eax_193 = __smsw<word32>();
				byte al_194 = (byte) eax_193;
			} while ((al_194 & 0x02) == 0x00);
			uint32 edi_200 = eax_193 + edi_160 / 2073990975;
			struct Eq_192 * edx_207 = edx - ebx_147 - (word32) (edi_200 < 0x00);
			if (edx_207 == (struct Eq_192 *) 0x65EDD98F)
			{
				edx_207->b0004 &= al_194;
				ui32 edi_276 = edi_200 | esi_213;
				ui64 eax_eax_905 = SEQ(eax_279, eax_193) - SEQ(edi_276, ebx_147);
				word32 eax_282 = SLICE(eax_eax_905, word32, 32);
				uint32 ecx_283 = ecx_171 + eax_282;
				esi_285 = (esi_213 & edx_207 | eax_193) - ebx_147;
				ui32 eax_279 = (word32) eax_eax_905;
				byte cl_361 = (byte) ecx_283;
				eax_286 = eax_282 - esi_285;
				uint32 edx_287 = edx_207 | edi_276 | ebx_147;
				if (edx_287 != 1954346488)
				{
					uint32 eax_296 = eax_286 - ebx_147;
					uint32 edx_290 = edx_287 | ebx_147;
					struct Eq_19 * ebx_301 = ebx_147 - eax_296;
					Eq_321 eax_315 = SLICE(SEQ(eax_296, ebx_301) - edx_290, word32, 32) + edx_290;
					ecx_310 = edx_290 - eax_296;
					edi_307 = ebx_301;
					byte al_358 = (byte) eax_315;
					word24 eax_24_8_822 = SLICE(eax_315, word24, 8);
					esi_319 = ecx_310;
					ebx_321 = ecx_310 - ebx_301 - (word32) (eax_315 < 0x00);
					if (ecx_310 == (struct Eq_17 *) 83858126)
					{
						eax = SEQ(eax_24_8_822, al_358 + 0x1B);
						goto l00401072;
					}
					struct Eq_342 * ecx_324 = ecx_310 - ebx_321;
					word32 ecx_326 = ecx_324 + eax_315;
					eax_327 = eax_315 | ecx_326;
					ui32 edi_325 = ebx_301 - ecx_324;
					ui64 edi_edx_914 = SEQ(edi_325, ecx_310) - &(&(eax_327->*(eax_327->*ecx_310).b0000));
					ecx_330 = ecx_326 - eax_327 | edi_325;
					edx_331 = (word32) edi_edx_914;
					edi_106 = SLICE(edi_edx_914, word32, 32);
					if (edi_106 != (struct Eq_22 *) 3911875859)
						return eax_327 + edx_331 - (edi_106 & ecx_330);
					v38_353 = ecx_330 + eax_327->dwFFFFFF90 / 2073990975 + (word32) (edi_106 < (struct Eq_22 *) 3911875859) / 2073990975;
					eax_327->dwFFFFFF90 = v38_353;
l004010B2:
					Eq_465 esi_548 = esi_319 - ebx_321 - (word32) (v38_353 < 0x00);
					struct Eq_471 * eax_555 = eax_327 - ecx_330;
					ui64 edi_esi_930 = SEQ(edi_106 | edx_331, esi_548) - &(&(ecx_330->*(ecx_330->*ecx_330).b0000));
					Eq_478 eax_558 = eax_555 | ecx_330;
					word32 * edx_557 = (edx_331 | esi_548) - eax_555;
					ui32 edi_563 = SLICE(edi_esi_930, word32, 32);
					ui32 esi_564 = (word32) edi_esi_930 & eax_558;
					word32 ecx_565 = ecx_330 + eax_558;
					struct Eq_503 * ebx_568;
					word32 ecx_569;
					struct Eq_505 * edi_570;
					struct Eq_506 * edx_571;
					struct Eq_507 * esi_572;
					fn004023CD(eax_558, ecx_565, edx_557, ecx_330, esi_564, edi_563, out ecx_569, out edx_571, out ebx_568, out esi_572, out edi_570);
					word32 eax_580 = __in<word32>((word16) edx_571);
					struct Eq_520 * esp_573 = (struct Eq_520 *) <invalid>;
					edi_570->t46D251AE.u1 = esp_573->t0000.u1;
					bool P_578 = <invalid>;
					bool O_577 = <invalid>;
					bool Z_576 = <invalid>;
					bool C_575 = <invalid>;
					bool S_574 = <invalid>;
					struct Eq_547 * eax_603 = SEQ(SLICE(eax_580, word16, 16), P_578 | O_577 | Z_576 | C_575 | S_574, (byte) eax_580);
					eax_603->ptr837ED081 = gs;
					edx_571->b0076 += SLICE(ebx_568, byte, 8);
					ebx_568->dwD20C917E += 0xB1D0D0AD;
					ui64 v47_v46_918 = SEQ(esi_572->dw707E8341, edi_570->dwB18FADAE) - SEQ(~0x7C, ebx_568);
					edi_570->dwB18FADAE = (word32) v47_v46_918;
					esi_572->dw707E8341 = SLICE(v47_v46_918, word32, 32);
					byte dl_629 = (byte) edx_571;
					byte dh_639 = SLICE(edx_571, byte, 8);
					word16 edx_16_16_645 = SLICE(edx_571, word16, 16);
					word24 ecx_24_8_649 = SLICE(ecx_569, word24, 8);
					byte * edi_581 = (char *) &edi_570->dwB18FADAE + 1315983958;
					struct Eq_604 * eax_610 = eax_603 - ~0x7C - (word32) (esi_572 < (struct Eq_507 *) ~0x4E);
					do
					{
						*(struct Eq_604 **) 2886504888 = eax_610;
						byte dl_631 = __rcl<byte,byte>(dl_629, 0x01, ((byte) eax_610 & 0x80) != 0x00);
						*edi_581 = *(byte *) 0xE0838C80;
						Eq_530 dx_640 = SEQ(dh_639, dl_631);
						__in<word32>(dx_640);
						__in<word32>(dx_640);
						struct Eq_637 * edx_646 = SEQ(edx_16_16_645, dh_639, dl_631);
						edx_646->dw4990471 -= ~0x5E;
						struct Eq_647 * ecx_650 = SEQ(ecx_24_8_649, 0x29);
						ecx_650->dwFFFFFFE5 -= ~0x30;
						struct Eq_658 * eax_662 = fn46D0_D0A9();
						eax_662->ptr837ED0A1 = gs;
						((Eq_3373[]) 0xB2D0D085)[ebx_568].b0000 += (byte) ecx_660;
						struct Eq_675 * edi_637 = edi_581 + 1;
						edi_637->b0008 = (byte) eax_662;
						word32 eax_677 = *(word32 *) 3766717572;
						byte al_679 = (byte) eax_677;
						ecx_24_8_649 = SLICE(ecx_660, word24, 8);
						dh_639 = SLICE(edx_661, byte, 8);
						word24 ebx_24_8_753 = SLICE(ebx_568, word24, 8);
						edx_16_16_645 = SLICE(edx_661, word16, 16);
						edi_581 = (byte *) &edi_637->dw0009;
						dl_629 = 0x5A;
						eax_610 = SEQ(SLICE(eax_677, word24, 8), al_679 << 0x01);
						struct Eq_700 * ecx_691 = SEQ(ecx_24_8_649, 0x6D);
						Eq_530 dx_734 = SEQ(dh_639, 0x5A);
					} while ((eax_610 & 2277375592) >= 0x00);
					word32 v56_693 = ecx_691->dwB2D2D0D0 - 0xE0838C88 - (word32) (eax_610->dwFFFFFFA4 *s 212765925 < 0x00);
					ecx_691->dwB2D2D0D0 = v56_693;
					edi_637->tB1F0BB9E.u0 = (byte) __rcr<byte,byte>(edi_637->tB1F0BB9E.u0, 0x6D, SLICE(cond(v56_693), bool, 1));
					edi_637->dw0009 = *(word32 *) 0xE0838C88;
					*(byte *) 3766717671 = __rcl<byte,byte>(*(byte *) 3766717671, 0x01, (al_679 << 0x01 & 0x80) != 0x00);
					((Eq_3377[]) 0x0C7ED0B1)[eax_610->dwFFFFFFA4].ptr0000 = gs;
					edi_637->dw000E = *(word32 *) 0xE0838C8E;
					__in<word32>(dx_734);
					SEQ(ecx_24_8_649, ~0x60)->dwFFFFFFA1 = esp_659->dwFFFFFFFC;
					edi_637->dw0016 = *(word32 *) 3766717586;
					fn8BB1C75F(ecx_691);
					struct Eq_789 * ebx_754 = SEQ(ebx_24_8_753, 0x44);
					ebx_754->b8CE5815E = __rol<byte,byte>(ebx_754->b8CE5815E, 0x0C);
					ecx_748->dwCFE588A5 -= 0x0C;
					memcpy(&edi_637->dw0016 + 1, (<unknown>*) 0xE0838C96, ecx_748 * 0x04);
					word32 edi_765 = edi_637 + 26 + ecx_748 *u 0x04;
					edi_765->dw0000 = ((word32[]) 0xE0838C96)[ecx_748];
					edi_765->b0004 = ~0x01;
					__in<word32>(0x68);
					__halt();
				}
				eax_286->bFFFFFF84 &= cl_361;
				ebx_ecx_981 = (ui64) ecx_283;
				edi_edx_984 = SEQ(edi_276, edx_287);
l004013DB:
				ui64 ebx_ecx_917 = ebx_ecx_981 - edi_edx_984;
				ui32 edi_376 = SLICE(edi_edx_984, word32, 32) | eax_286;
				ui32 ebx_381 = SLICE(ebx_ecx_917, word32, 32) + esi_285 - edi_376;
				ecx_126 = (word32) ebx_ecx_917;
				ui32 edx_382 = (word32) edi_edx_984 & ebx_381;
				esi_124 = esi_285 & ecx_126;
				byte cl_392 = (byte) ecx_126;
				eax = eax_286 - edx_382;
				ui32 edx_385 = edx_382 + ebx_381;
				ebx_147 = ebx_381 | esi_124;
				edi_223 = (struct Eq_51 *) (esi_124 + edi_376 / 2073990975);
				if (ebx_147 != (struct Eq_16 *) 4272643975)
				{
l00401374:
					ebx_147->dw0000 = -ebx_147->dw0000;
				}
				eax->t0000.u0 |= cl_392;
				edx_113 = edx_385 + 0x01;
				goto l00401400;
			}
			uint32 edx_221 = edx_207 + ecx_171 / 5 - ebx_147;
			uint32 ecx_219 = ecx_171 + esi_213 & ebx_147;
			esi_124 = esi_213 & edi_200;
			edi_223 = edi_200 - edx_221;
			esp_179->ptrFFFFFFFC = null;
			edx_239 = edx_221 - esi_124;
			eax = esp_179->ptrFFFFFFFC;
			esp_235 = esp_179;
			ebx_129 = edx_239;
			ecx_126 = ebx_147 - edi_223 - (word32) (ecx_219 - edx_221 < (word32) (edi_223 < null)) & edx_221;
			if (ecx_126 == (struct Eq_32 *) ~0x62868354)
			{
				Mem268[ecx_126 + 0xD1231180 + edx_239:byte] = Mem233[ecx_126 + 0xD1231180 + edx_239:byte] | SLICE(eax, byte, 0) - 0x01;
				eax_265 = eax - 0x01;
				goto l00401261;
			}
		}
		else
		{
			word32 eax_65;
			if (edx != (struct Eq_6 *) ~0x00)
				eax_65 = SEQ(eax_24_8_66, edx->bFFFFFFFF);
			else
				eax_65 = SEQ(eax_24_8_66, 0x2E);
			eax_456 = eax_65 - 0xC000002E;
			if (eax_456 == null)
			{
				edi_106 = edi_223 + eax_456;
				if (eax_456 != (struct Eq_28 *) 0x233E0868)
				{
					struct Eq_891 * esi_84 = (esi_213 | ecx_454) & ebx_147;
					struct Eq_894 * eax_78 = eax_456 | edx;
					word32 ecx_85 = edx + esi_84;
					word32 ebx_87 = ebx_147 + esi_84;
					struct Eq_974 * ecx_91 = ecx_85 - eax_78 - (word32) (ebx_87 < 0x00);
					word32 edx_96 = (ebx_87 | ecx_91) - ebx_87;
					ebx_485 = ebx_87 | edi_106;
					struct Eq_984 * esi_95 = esi_84 | edi_106;
					edx_100 = edx_96 + ebx_485;
					struct Eq_987 * eax_103 = eax_78 - esi_95 - (word32) (edx_100 < null);
					ecx_489 = (ecx_91 & edi_106 | ebx_87 | eax_78) + edx_96;
					edi_106 = edi_106 - edx_100 - (word32) (eax_103 < null);
					eax_esi_990 = (uint64) (&(eax_103->*esi_95).bFFFFFFFF + 1);
l00401137:
					ebx_321 = ebx_485 - edi_106;
					uint64 ecx_edx_927 = SEQ(ecx_489 - ebx_321, edx_100) - eax_esi_990;
					edx_331 = (word32) ecx_edx_927;
					eax_327 = SLICE(eax_esi_990, word32, 32);
					ecx_330 = SLICE(ecx_edx_927, word32, 32);
					esi_319 = edx_331;
					goto l004010B2;
				}
				eax_456->b8B809004 = eax_456->b8B809004 + ~0x01 + (byte) (eax_456 < (struct Eq_28 *) 0x233E0868);
				esi_ebx_987 = SEQ(esi_213, ebx_147);
l00401178:
				struct Eq_912 * ecx_461 = ecx_454 - (word32) esi_ebx_987;
				ui64 esi_ebx_933 = esi_ebx_987 - &(&(edi_106->*(edi_106->*ecx_461).dw0000));
				ui64 ebx_edx_924 = SEQ((word32) esi_ebx_933, SLICE(esi_ebx_987, word32, 32)) - SEQ(eax_456 | edx, ecx_461);
				struct Eq_402 * esi_472 = SLICE(esi_ebx_933, word32, 32);
				ui32 edx_473 = (word32) ebx_edx_924;
				ui32 ebx_476 = SLICE(ebx_edx_924, word32, 32);
				struct Eq_403 * ecx_478 = ecx_461 - esi_472;
				edx_100 = (struct Eq_25 *) (edi_106 + edx_473 / 2073990975);
				ebx_485 = ebx_476 | edi_106 | (edx_473 - edi_106) - (word32) (edx_100 < null);
				ecx_489 = edx_100 + ebx_485 / 2073990975;
				esi_285 = esi_472 & ecx_478;
				eax_286 = edx_100;
				byte al_495 = (byte) edx_100;
				ebx_ecx_981 = SEQ(ebx_485, ecx_489);
				edi_edx_984 = (ui64) &&(edi_106->*(edi_106->*edx_100).dw0000);
				if (ebx_485 == 38520211)
				{
					edx_100->b3844211 &= al_495;
					eax_esi_990 = (uint64) esi_285;
					goto l00401137;
				}
				goto l004013DB;
			}
			edx_113 = edx - ebx_147;
			ui32 ebx_118 = edx_113 & edi_223;
			struct Eq_877 * ecx_119 = ecx_454 - edi_223;
			ui32 esi_120 = edx_113 + esi_213 / 2073990975;
			ebx_129 = ebx_118 - edx_113 | edi_223;
			eax = edi_223 & ebx_129;
			esi_124 = (esi_120 | ecx_119) & edx_113;
			ecx_126 = ecx_119 - edi_223;
			byte al_133 = (byte) eax;
			if (eax != (struct Eq_7 *) 0x40AFCA89)
			{
l00401400:
				word32 ecx_400 = ecx_126 + edx_113;
				word32 eax_413 = eax + esi_124;
				ui32 edx_410 = (edx_113 - esi_124 - (word32) (ecx_400 < 0x00) - edi_223 | ecx_400) & edi_223;
				Eq_271 ecx_416 = ecx_400 - esi_124 - (word32) (eax_413 < null);
				ebx_129 = esi_124;
				ecx_20 = ecx_416 - eax_413;
				eax_265 = eax_413 - ecx_20;
				uint32 edx_427 = esi_124 + ((edx_410 & eax_413) - esi_124 | edi_223) / 2073990975;
				esi_124 = eax_413;
				byte al_788 = (byte) eax_265;
				word24 eax_24_8_795 = SLICE(eax_265, word24, 8);
				edi_223 = edi_223 - eax_413 - (word32) (edx_427 < 0x00) - esi_124;
				if (esi_124 == (struct Eq_29 *) 24406666)
				{
					null[esi_124].b0000 = null[esi_124].b0000 + ~0x07;
					eax = SEQ(eax_24_8_795, al_788 + 66);
l00401213:
					uint32 edi_801 = edi_223 & ecx_20;
					ui64 ebx_esi_908 = SEQ((ebx_129 - eax | ecx_20) & ecx_20, esi_124) - SEQ(edi_801, edi_801);
					ecx_310 = (struct Eq_17 *) (esi_124 + ecx_20 / 2073990975);
					esi_319 = (word32) ebx_esi_908;
					ui32 ebx_810 = SLICE(ebx_esi_908, word32, 32) & ecx_310 & edi_801;
					if (esi_319 == (struct Eq_17 *) 1287157821)
						ecx_310->b0000 += 0x1B;
					edi_307 = edi_801 - ebx_810 - (word32) (esi_319 < (struct Eq_17 *) 1287157821);
l00401072:
					ui32 edx_820 = ecx_310 | (edi_307 | ecx_310);
					ui32 edx_830 = edx_820 & esi_319 | eax & (eax * 0x02 & edx_820);
					eax_161 = 2220976321;
					uint32 ebx_837 = esi_319 - 2220976321;
					uint32 edx_839 = edx_830 + ebx_837;
					ui32 ebx_843 = ebx_837 - esi_319 - (word32) (edx_839 < 0x00) & edx_839;
					ecx_454 = ecx_310 & 2220976321;
					edx = (struct Eq_6 *) 2220976321;
					ebx_147 = ebx_843 - 2220976321;
					esi_213 = ebx_843 - 2220976321;
					goto l004012EB;
				}
				edx_239 = edx_427 & ecx_20;
l00401261:
				word32 esi_445 = esi_124 + edi_223;
				struct Eq_15 * eax_449 = eax_265 - esi_445 - (word32) (esi_445 < null);
				uint32 ebx_453 = ebx_129 + edi_223 - edx_239;
				ecx_454 = eax_449;
				edx = edx_239 + edi_223;
				eax_456 = eax_449 - edi_223;
				edi_106 = esi_445;
				esi_ebx_987 = (ui64) ebx_453;
				goto l00401178;
			}
			ecx_126->b0000 &= al_133;
			eax->dwD78B4211 = edx_113 + eax->dwD78B4211 / 2073990975;
		}
		__syscall<byte>(0x2E);
		struct Eq_964 * ecx_252 = ecx_126 - eax;
		ui32 ebx_255 = ebx_129 | esi_124;
		edx = null;
		ebx_129 = ebx_255 - (ecx_252 & ebx_255);
		ecx_20 = 0x00;
		esi_124 = esi_124 + ecx_252 | edi_223;
	}
}

// 00401FEA: Register (ptr32 Eq_520) fn00401FEA(Register ui32 eax, Register (ptr32 Eq_520) ecx, Register word32 edx, Register ui32 ebx, Register Eq_537 esi, Register Eq_537 edi, Register out ptr32 edxOut)
// Called from:
//      fn004020BE
//      fn004020C4
struct Eq_520 * fn00401FEA(ui32 eax, struct Eq_520 * ecx, word32 edx, ui32 ebx, Eq_537 esi, Eq_537 edi, ptr32 & edxOut)
{
	bool C;
	uint32 edi_7 = edi - ecx - (word32) C;
	ui32 edx_14 = edx - edi_7;
	ui64 esi_esi_68 = SEQ(esi_18, esi) - SEQ(edi_7, edi_7);
	struct Eq_1030 * eax_16 = eax | edx_14;
	uint32 esi_21 = SLICE(esi_esi_68, word32, 32);
	byte al_52 = (byte) eax_16;
	ui32 esi_18 = (word32) esi_esi_68;
	Eq_537 (* ebx_27)[] = ((ebx & esi) - edi_7 - (word32) (esi_21 < 0x00) & esi_21) - edx_14;
	struct Eq_520 * edi_29 = eax_16 + edi_7;
	if (eax_16 != (struct Eq_1030 *) 1124223206)
	{
		word32 eax_92;
		word32 ecx_93;
		word32 edx_94;
		fn00402498(out eax_92, out ecx_93, out edx_94);
		fn00402484();
	}
	else
	{
		Mem54[eax_16 + 4044066944 + (ecx ^ 35435435):byte] = Mem0[eax_16 + 4044066944 + (ecx ^ 35435435):byte] & al_52;
		struct Eq_520 * ecx_59;
		ptr32 edx_60;
		fn00402017(eax_16, edx_14, ebx_27, edi_29, out ecx_59, out edx_60);
		edxOut = edx_60;
		return ecx_59;
	}
}

// 00402017: FlagGroup byte fn00402017(Register (ptr32 Eq_1030) eax, Register ui32 edx, Register (arr Eq_537) ebx, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00401FEA
//      fn0040209D
//      fn0040272F
byte fn00402017(struct Eq_1030 * eax, ui32 edx, Eq_537 ebx[], struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	word32 eax_31 = eax + ebx;
	uint32 edx_38 = 0x00 - (word32) (eax_31 < 0x00);
	ui32 eax_43 = SEQ(SLICE(eax_31, word24, 8), ebx[0].u0);
	ui32 edx_44 = edx_38 - edx - (word32) (edx_38 < 0x00) | eax_43;
	Eq_537 esi_47 = edx - edi;
	if (edx_44 != 2555903382)
	{
		ptr32 ecx_52;
		ptr32 edx_53;
		fn004021F2(eax_43, edx_44, ebx, esi_47, edi, out ecx_52, out edx_53);
		ecxOut = ecx_52;
		edxOut = edx_53;
		return <invalid>;
	}
	else
	{
		ptr32 edx_62;
		ecxOut = fn00402037(eax_43, (byte) edx_44, out edx_62);
		edxOut = edx_62;
		return <invalid>;
	}
}

// 00402037: Register (ptr32 Eq_520) fn00402037(Register ui32 eax, Register byte dl, Register out Eq_1057 edxOut)
// Called from:
//      fn00401FEA
//      fn00402017
struct Eq_520 * fn00402037(ui32 eax, byte dl, union Eq_1057 & edxOut)
{
	struct Eq_520 * ecx;
	ui32 edx;
	ui32 * ebx;
	ui32 esi;
	struct Eq_1152 * eax_9 = SEQ(SLICE(eax - 0x01, word24, 8), (byte) eax + 0x03);
	eax_9->b2BD30B84 |= dl;
	byte dl_20;
	fn0040203D(eax_9, ecx, edx, ebx, esi, out dl_20);
	edxOut.u1 = <invalid>;
	return (struct Eq_520 *) <invalid>;
}

// 0040203D: FlagGroup byte fn0040203D(Register (ptr32 Eq_1152) eax, Register (ptr32 Eq_520) ecx, Register ui32 edx, Register (ptr32 ui32) ebx, Register ui32 esi, Register out Eq_1057 dlOut)
// Called from:
//      fn00402037
//      fn0040209D
byte fn0040203D(struct Eq_1152 * eax, struct Eq_520 * ecx, ui32 edx, ui32 * ebx, ui32 esi, union Eq_1057 & dlOut)
{
	ui32 edx_7 = (edx | ebx) - ebx;
	uint32 esi_20 = ebx + esi;
	ui32 ecx_16 = (ecx | eax) + edx_7 | ebx;
	ui32 edx_23 = edx_7 - esi_20 - (word32) (esi_20 < 0x00);
	ui32 ecx_27 = ecx_16 - esi_20;
	struct Eq_520 * ecx_32 = (ecx_27 | esi_20) - eax | esi_20;
	Eq_537 esi_36 = ecx_32 + esi_20 / 64;
	Eq_1203 edx_28 = edx_23 & ecx_27;
	Eq_537 eax_37 = eax & esi_36;
	byte cl_50 = (byte) ecx_32;
	struct Eq_520 * edi_34 = ((ebx | edx_23) & esi_20) - edx_28 - esi_20;
	byte ah_46 = SLICE(eax_37, byte, 8);
	if (ecx_32 != (struct Eq_520 *) 1696963177)
	{
		byte dl_90;
		fn004029AD(eax_37, ecx_32, edx_28, (char *) ebx - 0x0A11, esi_36, edi_34, out dl_90);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
	else
	{
		eax_37.u1->b0000 |= ah_46;
		eax_37.u1->b0023 &= cl_50;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_520 * stackArg0 = (struct Eq_520 *) <invalid>;
		byte dl_92;
		fn0040210F(eax_37, ecx_32, esi_36, stackArg0, out dl_92);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
}

// 0040205B: void fn0040205B(Register ui32 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register (ptr32 Eq_520) edi)
// Called from:
//      fn004023CD
void fn0040205B(ui32 eax, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], struct Eq_520 * edi)
{
	ptr32 fp;
	ui32 eax_11 = eax & ebx;
	Eq_537 esi_15 = eax_11 - ecx;
	byte * eax_18 = (eax_11 & esi_15) - esi_15;
	byte ah_96 = SLICE(eax_18, byte, 8);
	if (esi_15 != 1367093410)
	{
		ui32 eax_21 = eax_18 | esi_15;
		word32 esi_23 = esi_15 + ebx & edi;
		if (ecx != (struct Eq_520 *) 0x12776E70)
		{
			byte dl_136;
			fn0040272F(ecx, edx, ebx, edi, out dl_136);
		}
		else
		{
			ui32 ebx_34 = ebx & esi_23;
			up32 ecx_36 = ecx - edx;
			struct Eq_1326 * eax_40 = eax_21 - edx - (word32) (ecx_36 < 0x00);
			byte al_82 = (byte) eax_40;
			ui24 eax_24_8_87 = SLICE(eax_40, word24, 8);
			Eq_537 (* ebx_41)[] = eax_40 + ebx_34 / 55059073;
			struct Eq_520 * edi_44 = edi | esi_23;
			if (esi_23 != (struct Eq_517 *) 2006603164)
			{
				ui32 ebx_49 = ebx_41 | esi_23;
				ui32 edi_52 = edi_44 - ebx_49;
				ui32 edx_53 = ebx_49 | edi_52;
				if (eax_40 != (struct Eq_1326 *) ~0x6E361080)
					return;
				eax_40->b3482280 = eax_40->b3482280 + 242 + (byte) (eax_40 < (struct Eq_1326 *) ~0x6E361080);
				byte dl_139;
				fn004028F1(edx_53, ebx_49, 0x00, edi_52, out dl_139);
			}
			else
			{
				ui8 al_83 = al_82 & eax_40[fp / 55059073];
				word32 ecx_137;
				word32 edx_138;
				fn0040288B(al_83, eax_24_8_87, esi_23, esi_23, ebx_41, esi_23, edi_44, out ecx_137, out edx_138);
			}
		}
	}
	else
	{
		*eax_18 &= ah_96;
		edx->b0004 |= (byte) eax_18 - 0x02;
		byte dl_135;
		fn0040207C(eax_18 - 0x02, ecx, edx, ebx, esi_15, edi, out dl_135);
	}
}

// 0040207C: FlagGroup byte fn0040207C(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040205B
//      fn0040212D
byte fn0040207C(Eq_537 eax, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, union Eq_1057 & dlOut)
{
	struct Eq_1393 * fp;
	byte al;
	word24 eax_24_8;
	esi_289 = esi;
	eax_222 = eax;
	edx_284 = edx;
	ebx_10 = ebx;
	edi_11 = edi;
l0040207C:
	struct Eq_520 * edi_11;
	Eq_537 (* ebx_10)[];
	struct Eq_517 * edx_284;
	Eq_537 eax_222;
	Eq_537 esi_289;
	struct Eq_1401 * eax_7 = (word32) eax_222 + 0x0078;
	word32 edx_9 = edx_284 + eax_7;
	ui32 edi_15 = ecx + (edi_11 & edx_9) / 64;
	byte * edx_16 = edx_9 & edi_15;
	word32 esi_6 = esi_289 + eax_222;
	word32 ebx_12 = ebx_10 + edi_11;
	byte dh_134 = SLICE(edx_16, byte, 8);
	if (edi_15 != 353861337)
	{
		ui32 esi_23 = esi_6 - eax_7;
		ui32 edx_28 = (edx_16 & ecx) + esi_23 - ecx;
		ui32 esi_26 = esi_23 & eax_7 & ecx;
		ui32 ebx_33 = (&eax_7->dw0008 | edi_15 | edx_28) - edi_15;
		if (eax_7 != (struct Eq_1401 *) 332507179)
		{
			ui32 ebx_39 = (ebx_33 | &eax_7->dw0008) & esi_26 + edx_28;
			ui32 edi_41 = edi_15 | &eax_7->dw0008;
			uint32 edi_51 = edi_41 + ebx_39;
			word32 eax_49 = eax_7->dw0008;
			ui32 edx_55 = ebx_39 - edi_51 - (word32) (edi_51 < 0x00);
			ui32 ebx_58 = ebx_39 + edi_51 | edx_55;
			byte * eax_61 = ecx + eax_49 / 64;
			ui32 edx_59 = edx_55 + ebx_58;
			word32 edi_62 = edi_51 - ecx;
			ui32 esi_63 = edi_51 | eax_61;
			ui32 ebx_64 = ebx_58 + edi_51 & eax_61;
			ui32 esi_68 = esi_63 - ecx;
			up32 edi_69 = edi_62 + esi_68;
			ui32 edi_72 = edi_69 - esi_68 - (word32) (edi_69 < 0x00);
			uint32 ebx_74 = eax_61 + ebx_64;
			ui32 edx_73 = edx_59 | edi_72;
			ui32 edx_79 = edx_73 - (ebx_74 | edx_73);
			uint32 esi_80 = esi_68 - ebx_74 - (word32) (ebx_74 < 0x00) | edi_72;
			if (esi_80 != 0x39D23443)
			{
				uint32 edi_83 = edi_72 | ecx;
				ui64 edi_esi_365 = SEQ(edi_83, esi_80) - SEQ(edx_79, edi_83);
				if (edx_79 - (word32) edi_esi_365 - (word32) (SLICE(edi_esi_365, word32, 32) < 0x00) != 2036447730)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					struct Eq_520 * stackArg0 = (struct Eq_520 *) <invalid>;
					byte dl_422;
					fn0040210F(eax, ecx, esi, stackArg0, out dl_422);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
				else
				{
					*eax_61 &= 0x80;
					byte dl_420;
					fn0040276F(eax, ecx, edx, esi, out dl_420);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
			}
			else
			{
				fn004021F7(al, eax_24_8, ecx, edx, ebx, esi, edi);
				dlOut.u1 = <invalid>;
				return <invalid>;
			}
		}
		else
		{
			fn00402754(al, edx, ebx, edi);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
	}
	else
	{
		*edx_16 |= SLICE(eax_7 - 0x01, byte, 8);
		*(byte *) ~0x0137 |= dh_134;
		ui32 eax_141 = SEQ(SLICE(eax_7 - 0x01, word24, 8), (byte) eax_7 + 0x47);
		ui32 edx_146 = ebx_12 + (eax_141 | edi_15);
		ui32 esi_147 = esi_6 & eax_141 | edi_15;
		if (esi_147 != 2537255603)
		{
			ui32 ebx_150 = ebx_12 | edx_146;
			while (true)
			{
				byte ch_337 = SLICE(ecx, byte, 8);
				ui32 eax_156 = ~eax_141;
				Eq_537 ebx_161[] = ebx_150 - eax_141 | ecx;
				ui32 edi_165 = edi_15 - ecx;
				ui32 esi_170 = esi_147 & edi_165;
				struct Eq_520 * edi_173 = ebx_161 & esi_170;
				if (eax_156 != 0x00)
					break;
				ui32 edi_193 = edi_173 - eax_156;
				ui32 ebx_194 = &(ebx_161 + edi_193 / 4)->u0;
				ui32 esi_196 = (esi_170 & edi_193) + ebx_194;
				Eq_537 ebx_198[] = ebx_194 & eax_156;
				if (ebx_198 == (Eq_537 (*)[]) 2044600489)
				{
					ebx_198[0].u0 = (byte) (ebx_198[0].u0 | ch_337);
					byte dl_412;
					fn0040276F(eax, ecx, edx, esi, out dl_412);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
				ui32 edi_209 = edi_193 - ebx_198;
				ui32 esi_211 = esi_196 - ebx_198 - (word32) (ebx_198 < null) & edi_209;
				byte al_318 = (byte) ecx;
				struct Eq_517 * edx_210 = ebx_198 | ecx;
				struct Eq_520 * edi_213 = edi_209 - esi_211;
				if (ebx_198 == (Eq_537 (*)[]) 3261415481)
				{
					ecx->t0000.u0 = (byte) (ecx->t0000.u0 & al_318);
					word32 ecx_413;
					fn00402242(ecx, edx_210, ebx_198, edi_213, out ecx_413);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
				Eq_1549 ebx_217 = ebx_198 - ecx - (word32) (ebx_198 < (Eq_537 (*)[]) 3261415481);
				&eax_222.u1->b0000 = ecx + ecx->dw003C / 64;
				ui32 ebx_224 = ebx_217 | eax_222;
				ui32 esi_226 = (esi_211 | ecx) + ebx_224;
				ui32 edx_223 = edx_210 - esi_211 - (word32) (ebx_217 < 0x00) + esi_211;
				ui32 edi_229 = (edi_213 & esi_226) - edx_223;
				byte al_293 = (byte) eax_222;
				word24 eax_24_8_358 = SLICE(eax_222, word24, 8);
				ui32 ebx_231 = ebx_224 & edi_229;
				ui32 edx_233 = edx_223 - esi_226 * 0x02;
				if (edx_233 == 4275000651)
				{
					eax_222.u1->b0000 |= 0x84;
					word32 ecx_414;
					word32 edx_415;
					fn00402158(ecx, edx, edi, out ecx_414, out edx_415);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
				edi_15 = ecx + edi_229 / 64;
				ebx_150 = ebx_231 - edx_233 | ecx;
				esi_147 = (eax_222 | edi_15) + (eax_222 + 80);
				if (eax_222 != 4226294291)
				{
					ui32 esi_248 = esi_147 & ebx_150;
					word32 esi_253 = esi_248 + (eax_222 + 80);
					uint32 ebx_258 = ((ebx_150 | esi_248) & eax_222) - eax_222 - esi_253;
					word32 edi_261 = ((edi_15 + ecx | eax_222 + 80) & esi_253 & ebx_258) + ecx;
					word32 edi_265 = (edi_261 - ecx & eax_222 + 80) - eax_222;
					ui32 esi_269 = esi_253 & ebx_258;
					ui64 ebx_ebx_362 = SEQ(ebx_274, ebx_258) - SEQ(edi_265, ebx_258);
					edi_11 = edi_265 & SLICE(ebx_ebx_362, word32, 32);
					edx_284 = ebx_258 | esi_269 & edi_11;
					ui32 ebx_274 = (word32) ebx_ebx_362;
					esi_289 = eax_222;
					ebx_10 = edx_284 & ecx;
					if (edi_11 != (struct Eq_520 *) 1870009053)
						goto l0040207C;
					word32 ecx_416;
					fn00402242(ecx, edx_284, ebx_10, edi_11, out ecx_416);
					dlOut.u1 = <invalid>;
					return <invalid>;
				}
				eax_141 = SEQ(eax_24_8_358, al_293 & ((fp->aDA0B0848))[eax_222].b0000);
			}
			word32 ecx_417;
			fn00402242(ecx, null, ebx_161, edi_173, out ecx_417);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
		else
		{
			ebx_12->bD62359F9 |= 0x1B;
			word32 ecx_410;
			word32 edx_411;
			fn004020C4(eax, ecx, ebx, esi, edi, out ecx_410, out edx_411);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
	}
}

// 0040209D: void fn0040209D(Register word32 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi)
// Called from:
//      fn0040221E
void fn0040209D(word32 eax, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi)
{
	byte dl_25;
	fn0040212D(eax ^ ~0x0137, ecx, edx, ebx, esi, edi, out dl_25);
}

// 004020BE: FlagGroup byte fn004020BE(Register ui32 ecx, Register (ptr32 (arr Eq_537)) ebx, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn004023CD
//      fn004027F8
byte fn004020BE(ui32 ecx, Eq_537 (* ebx)[], ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_537 esi;
	struct Eq_520 * dwArg00;
	Eq_537 eax;
	struct Eq_520 * edi;
	Eq_537 (* ebx_14)[] = ebx - ecx;
	ptr32 ecx_17;
	ptr32 edx_18;
	fn004020C4(eax, dwArg00, ebx_14, esi, edi, out ecx_17, out edx_18);
	ecxOut = ecx_17;
	edxOut = edx_18;
	return <invalid>;
}

// 004020C4: FlagGroup byte fn004020C4(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0040209D
//      fn004020BE
byte fn004020C4(Eq_537 eax, struct Eq_520 * ecx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	word32 edx;
	ui32 eax_22 = eax - (edi - ecx);
	ui32 ebx_26 = (ebx & esi) + (ebx | esi);
	ptr32 edx_31;
	ecxOut = fn00401FEA(eax_22, ecx, edx, ebx_26, esi, esi, out edx_31);
	edxOut = edx_31;
	return <invalid>;
}

// 0040210F: FlagGroup byte fn0040210F(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register Eq_537 esi, Stack (ptr32 Eq_520) dwArg00, Register out Eq_1057 dlOut)
// Called from:
//      fn0040203D
//      fn0040212D
byte fn0040210F(Eq_537 eax, struct Eq_520 * ecx, Eq_537 esi, struct Eq_520 * dwArg00, union Eq_1057 & dlOut)
{
	struct Eq_517 * edx;
	Eq_537 (* ebx_35)[] = eax - ecx;
	word32 esi_36 = esi + eax | dwArg00;
	if (eax != 0x16883689)
	{
		byte dl_85;
		fn0040276F(eax, ecx, edx, esi_36, out dl_85);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
	else
	{
		byte dl_86;
		fn0040212D(eax, ecx, edx, ebx_35, esi_36, dwArg00, out dl_86);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
}

// 0040212D: FlagGroup byte fn0040212D(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040209D
//      fn0040210F
byte fn0040212D(Eq_537 eax, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, union Eq_1057 & dlOut)
{
	bool C;
	ecx->t0000.u0 = (byte) (ecx->t0000.u0 + 0x04 + (byte) C);
	byte dl_27;
	fn0040207C(eax, ecx, edx, ebx, esi, edi, out dl_27);
	dlOut.u1 = <invalid>;
	return <invalid>;
}

// 00402158: FlagGroup byte fn00402158(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn0040209D
//      fn004023CD
byte fn00402158(struct Eq_520 * ecx, struct Eq_517 * edx, struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_1877 ebx;
	ui32 esi;
	struct Eq_517 * edx_10 = edx & ecx;
	struct Eq_520 * edi_15 = ecx + (edi & ecx * 0x02) / 64;
	ptr32 ecx_19;
	ptr32 edx_20;
	fn004023A7(ecx, edx_10, ebx, esi, edi_15, out ecx_19, out edx_20);
	ecxOut = ecx_19;
	edxOut = edx_20;
	return <invalid>;
}

// 00402191: FlagGroup byte fn00402191(Register Eq_478 eax, Register Eq_537 ecx, Register (ptr32 word32) edx, Register (ptr32 word32) ebx, Register Eq_537 esi, Register ui32 edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn004023A7
//      fn004023CD
byte fn00402191(Eq_478 eax, Eq_537 ecx, word32 * edx, word32 * ebx, Eq_537 esi, ui32 edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	ui32 ecx_6 = ecx | edi;
	uint32 edx_8 = edx + ecx_6;
	struct Eq_520 * ecx_14 = ecx_6 - ebx - (word32) (edx_8 < 0x00);
	Eq_537 (* ebx_16)[] = ebx - eax;
	struct Eq_517 * edx_19 = edx_8 | esi;
	struct Eq_520 * edi_20 = esi.u1 + edi / 36;
	ptr32 ecx_25;
	ptr32 edx_26;
	fn004027F8(ecx_14, edx_19, ebx_16, esi, edi_20, out ecx_25, out edx_26);
	ecxOut = ecx_25;
	edxOut = edx_26;
	return <invalid>;
}

// 004021F2: FlagGroup byte fn004021F2(Register ui32 eax, Register ui32 edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00401FEA
//      fn00402017
byte fn004021F2(ui32 eax, ui32 edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	byte al_14 = (byte) eax;
	word24 eax_24_8_16 = SLICE(eax, word24, 8);
	struct Eq_517 * edx_9 = edx | eax;
	ptr32 ecx_18;
	ptr32 edx_19;
	fn004021F8(al_14, eax_24_8_16, null, edx_9, ebx, esi, edi, out ecx_18, out edx_19);
	ecxOut = ecx_18;
	edxOut = edx_19;
	return <invalid>;
}

// 004021F7: void fn004021F7(Register byte al, Register word24 eax_24_8, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (arr Eq_537) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi)
// Called from:
//      fn0040209D
void fn004021F7(byte al, word24 eax_24_8, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 ebx[], Eq_537 esi, struct Eq_520 * edi)
{
	bool C;
	ebx[0].u0 = (byte) __rcr<byte,byte>(ebx[0].u0, 0x01, C);
	word32 ecx_24;
	word32 edx_25;
	fn004021F8(al, eax_24_8, ecx, edx, ebx, esi, edi, out ecx_24, out edx_25);
}

// 004021F8: FlagGroup byte fn004021F8(Register byte al, Register word24 eax_24_8, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out Eq_1957 ecxOut, Register out (ptr32 byte) edxOut)
// Called from:
//      fn004021F2
//      fn004021F7
byte fn004021F8(byte al, word24 eax_24_8, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, union Eq_1957 & ecxOut, byte & edxOut)
{
	bool C;
	struct Eq_1981 * eax_41 = SEQ(eax_24_8, al + 0x17);
	byte * edx_34 = edx - ((ecx - edi) - (word32) (esi - edx < (word32) C));
	word32 esi_42 = edi + eax_41;
	if (ebx != (Eq_537 (*)[]) 1571502814)
	{
		Eq_1957 ecx_47;
		byte * edx_48;
		fn004028B0(eax_41, edx_34, ebx, esi_42, edi, out ecx_47, out edx_48);
		ecxOut = ecx_47;
		edxOut = edx_48;
		return <invalid>;
	}
	else
	{
		fn00402217(eax_41, edx_34);
		ecxOut = ebx * 0x02;
		edxOut = edx_34;
		return <invalid>;
	}
}

// 00402217: FlagGroup byte fn00402217(Register (ptr32 Eq_1981) eax, Register (ptr32 byte) edx)
// Called from:
//      fn004021F7
//      fn004021F8
byte fn00402217(struct Eq_1981 * eax, byte * edx)
{
	word24 eax_24_8;
	struct Eq_520 * ecx;
	Eq_537 (* ebx)[];
	Eq_537 esi;
	ui32 edi;
	byte ah = SLICE(eax, byte, 8);
	*edx &= ah;
	eax->dwB801122 = edx + eax->dwB801122;
	word32 eax_26;
	fn0040221F(al, eax_24_8, ecx, edx, ebx, esi, edi, out eax_26);
	return <invalid>;
}

// 0040221E: Register word32 fn0040221E(Register byte al, Register word24 eax_24_8, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register ui32 edi, Register out Eq_1057 ecxOut)
// Called from:
//      fn00402267
//      fn004027B3
word32 fn0040221E(byte al, word24 eax_24_8, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, ui32 edi, union Eq_1057 & ecxOut)
{
	byte * edx_6 = edx | edi;
	word32 eax_15;
	fn0040221F(al, eax_24_8, ecx, edx_6, ebx, esi, edi, out eax_15);
	ecxOut.u1 = <invalid>;
	return eax_15;
}

// 0040221F: FlagGroup byte fn0040221F(Register byte al, Register word24 eax_24_8, Register (ptr32 Eq_520) ecx, Register (ptr32 byte) edx, Register (arr Eq_537) ebx, Register Eq_537 esi, Register ui32 edi, Register out ptr32 eaxOut)
// Called from:
//      fn004021F7
//      fn0040221E
byte fn0040221F(byte al, word24 eax_24_8, struct Eq_520 * ecx, byte * edx, Eq_537 ebx[], Eq_537 esi, ui32 edi, ptr32 & eaxOut)
{
	ui32 eax_33 = SEQ(eax_24_8, ebx[(uint32) al / 4].u0);
	ptr32 eax_35 = &(ebx + eax_33 / 4)->u0;
	struct Eq_520 * edi_31 = (edi & ecx | esi.u1 + ((edx | ebx) | ebx) / 36) - ecx;
	struct Eq_517 * edx_38 = eax_33 - ebx - (word32) (eax_35 < 0x00);
	fn004025FF(ecx, edx_38, ebx, esi, edi_31);
	eaxOut = eax_35;
	return <invalid>;
}

// 0040223E: Register word32 fn0040223E(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (arr Eq_537) ebx, Register ui32 esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut)
// Called from:
//      fn00402267
word32 fn0040223E(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 ebx[], ui32 esi, struct Eq_520 * edi, ptr32 & ecxOut)
{
	struct Eq_517 * edx_6 = edx | edi;
	Eq_537 (* ebx_9)[] = &(ebx + esi / 4)->u0;
	ptr32 ecx_14;
	word32 eax_12 = fn00402242(ecx, edx_6, ebx_9, edi, out ecx_14);
	ecxOut = ecx_14;
	return eax_12;
}

// 00402242: Register Eq_537 fn00402242(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register (ptr32 Eq_520) edi, Register out (ptr32 Eq_520) ecxOut)
// Called from:
//      fn0040212D
//      fn0040223E
Eq_537 fn00402242(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], struct Eq_520 * edi, struct Eq_520 & ecxOut)
{
	Eq_537 eax;
	ui32 eax_13 = edi - ebx;
	word32 ebx_16 = ebx + edi - eax_13;
	word32 edx_11 = edx + edi;
	byte al_156 = (byte) eax_13;
	word24 eax_24_8_170 = SLICE(eax_13, word24, 8);
	ui32 edi_17 = edi & ecx & ebx_16;
	if (ecx != (struct Eq_520 *) 0x66F8D8B3)
	{
		ui32 eax_29 = (eax_13 | ecx) - (ecx - (struct Eq_2169 *) 0x01);
		struct Eq_2172 * esi_24 = ecx & ebx_16;
		ui32 edi_31 = (edi_17 - ebx_16 | eax_29) + (ecx - (struct Eq_2169 *) 0x01);
		Eq_2179 ebx_32 = ebx_16 + (ecx - (struct Eq_2169 *) 0x01);
		ui32 eax_39 = eax_29 & edi_31 | esi_24;
		struct Eq_2185 * ecx_41 = ecx - (struct Eq_2169 *) 0x01 >> 0x0F;
		struct Eq_2189 * edx_38 = ecx - (struct Eq_2169 *) 0x01 - esi_24;
		ui32 edi_40 = ebx_32 | eax_39;
		ui32 eax_44 = eax_39 - esi_24 - (word32) (ecx_41 < null);
		ui64 edi_edx_165 = SEQ(edi_40, edx_38) - &(&(edx_47->*((edx_47->*ecx_41).t0000).u0));
		struct Eq_2205 * edi_50 = SLICE(edi_edx_165, word32, 32);
		struct Eq_2207 * esi_51 = esi_24 - ecx_41;
		struct Eq_2202 * edx_47 = (word32) edi_edx_165;
		struct Eq_2210 * eax_56 = edx_47 + ((eax_44 | edi_50) | esi_51) / 64 - ecx_41;
		word32 ebx_54 = edx_38 + edi_50;
		byte al_148 = (byte) eax_56;
		if (ebx_54 != (struct Eq_2215 *) 1039511441)
		{
			uint32 esi_63 = edx_47 + (esi_51 & ebx_54) / 64;
			struct Eq_520 * ecx_61 = __align(ecx - (struct Eq_2169 *) 0x01, 0x00008000);
			ui32 eax_68 = (eax_56 | ecx_41) - esi_63;
			ui32 esi_70 = esi_63 & (ebx_54 - edx_47) - (word32) (esi_63 < 0x00);
			ui32 eax_83 = eax_68 & (esi_70 | eax_68);
			Eq_537 v21_76 = ecx_61->t0000.u1;
			byte al_143 = (byte) eax_83;
			word24 eax_24_8_172 = SLICE(eax_83, word24, 8);
			if (eax_83 != ~0x66626262)
			{
				if (v21_76 != 938381292)
				{
					byte dl_203;
					fn0040276F(eax, ecx, edx, esi, out dl_203);
					ecxOut = ecx_61;
					return v21_76;
				}
				else
				{
					v21_76.u1->b0020 |= 0x90;
					fn00402484();
					ecxOut = ecx_61;
					return v21_76;
				}
			}
			else
			{
				Eq_537 eax_173 = SEQ(eax_24_8_172, al_143 & ecx_61[(eax_83 + 3280667680) / 64]);
				word32 ecx_201;
				word32 edx_202;
				fn004027F8(ecx, edx, ebx, esi, edi, out ecx_201, out edx_202);
				ecxOut = ecx_61;
				return eax_173;
			}
		}
		else
			eax_56->b2B849084 &= al_148;
	}
	else
	{
		edx_11->dw0008 += eax_13;
		*ebx_16 &= ~0x28;
		Eq_537 eax_171 = SEQ(eax_24_8_170, al_156 + 0x20);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_520 * stackArg0 = (struct Eq_520 *) <invalid>;
		word32 eax_199;
		word32 ecx_200;
		fn00402269(eax, ecx, ebx, esi, edi, stackArg0, out eax_199, out ecx_200);
		ecxOut = ecx;
		return eax_171;
	}
}

// 00402267: FlagGroup byte fn00402267(Register out ptr32 eaxOut, Register out ptr32 ecxOut)
// Called from:
//      fn00402498
byte fn00402267(ptr32 & eaxOut, ptr32 & ecxOut)
{
	struct Eq_520 * edi;
	Eq_537 eax;
	struct Eq_520 * ecx;
	Eq_537 (* ebx)[];
	Eq_537 esi;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	struct Eq_520 * stackArg0 = (struct Eq_520 *) <invalid>;
	ptr32 ecx_12;
	ptr32 eax_13;
	fn00402269(eax, ecx, ebx, esi, edi, stackArg0, out eax_13, out ecx_12);
	eaxOut = eax_13;
	ecxOut = ecx_12;
	return <invalid>;
}

// 00402269: FlagGroup byte fn00402269(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Stack (ptr32 Eq_520) dwArg00, Register out ptr32 eaxOut, Register out ptr32 ecxOut)
// Called from:
//      fn0040209D
//      fn00402267
byte fn00402269(Eq_537 eax, struct Eq_520 * ecx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, struct Eq_520 * dwArg00, ptr32 & eaxOut, ptr32 & ecxOut)
{
	ui32 ecx_14 = ecx & ebx;
	word32 edi_16 = edi + ebx;
	struct Eq_517 * ebx_24 = (ebx - edi_16 | ecx_14) - eax;
	ui32 esi_22 = esi - ecx_14 | eax;
	ui32 edi_31 = edi_16 | ebx_24;
	ui32 ebx_32 = ebx_24 - dwArg00;
	ptr32 ecx_35;
	ptr32 eax_36;
	fn00402793(dwArg00, ebx_24, ebx_32, esi_22, edi_31, out eax_36, out ecx_35);
	eaxOut = eax_36;
	ecxOut = ecx_35;
	return <invalid>;
}

// 004022AB: FlagGroup byte fn004022AB(Register ui32 edx, Register up32 esi, Register up32 edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040276F
//      fn004029AD
byte fn004022AB(ui32 edx, up32 esi, up32 edi, union Eq_1057 & dlOut)
{
	bool C;
	ui32 ebx;
	word32 esi_16 = esi - 2984899155 - (word32) (edi - esi < (word32) C);
	ui32 esi_21 = esi_16 + (edx + 2984899155);
	byte dl_38;
	fn004028F1(edx + 2984899155, ebx, esi_21, 2984899155, out dl_38);
	dlOut.u1 = <invalid>;
	return <invalid>;
}

// 00402321: void fn00402321(Register ui8 al, Register word24 eax_24_8, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register (ptr32 Eq_520) edi)
// Called from:
//      fn0040209D
//      fn004021F7
void fn00402321(ui8 al, word24 eax_24_8, struct Eq_517 * edx, Eq_537 (* ebx)[], struct Eq_520 * edi)
{
	word32 eax_34 = SEQ(eax_24_8, -al);
	word32 edx_35 = edx + edi - ebx + eax_34;
	struct Eq_517 * edx_39 = edx_35 - ebx - (word32) (edx_35 < 0x00) | ebx;
	if (edi != (struct Eq_520 *) 1278668623)
		fn00402754(-al, edx_39, ebx, edi);
	else
		fn00402345();
}

// 00402345: void fn00402345()
// Called from:
//      fn0040209D
//      fn00402321
void fn00402345()
{
}

// 00402386: FlagGroup byte fn00402386(Register (ptr32 Eq_517) edx, Register Eq_1877 ebx, Register (ptr32 Eq_520) edi, Register out Eq_1877 ecxOut, Register out (ptr32 Eq_517) esiOut, Register out (ptr32 Eq_520) ediOut)
// Called from:
//      fn004023CD
//      fn004026B9
byte fn00402386(struct Eq_517 * edx, Eq_1877 ebx, struct Eq_520 * edi, union Eq_1877 & ecxOut, struct Eq_517 & esiOut, struct Eq_520 & ediOut)
{
	struct Eq_520 * ecx;
	if (edx != (struct Eq_517 *) 0x7A0E13E7)
	{
		ui64 esi_esi_42 = SEQ(esi_28, ebx) - SEQ(edi - 0x01, ebx - (edi - 0x01));
		ui32 esi_28 = (word32) esi_esi_42;
		struct Eq_517 * esi_31 = SLICE(esi_esi_42, word32, 32);
		Eq_1877 ecx_33 = 0x00 - (edi - 0x01);
		fn004025E1();
		ecxOut = ecx_33;
		esiOut = esi_31;
		ediOut = edi - 0x01;
		return <invalid>;
	}
	else
	{
		word32 ecx_66;
		word32 edx_67;
		fn004023A7(ecx, edx, ebx, esi, edi, out ecx_66, out edx_67);
		ecxOut = ebx;
		esiOut = edx;
		ediOut = edi;
		return <invalid>;
	}
}

// 004023A7: FlagGroup byte fn004023A7(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register Eq_1877 ebx, Register ui32 esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00402158
//      fn004023CD
byte fn004023A7(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_1877 ebx, ui32 esi, struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_478 eax;
	ui32 ebx_22 = ebx - edi;
	Eq_537 esi_30 = edi + (esi - ecx) / 64;
	word32 * ebx_34 = ebx_22 & esi & edx;
	ui32 edi_36 = edi - esi_30;
	if (ebx_22 != 0x99DB8350)
	{
		ptr32 ecx_41;
		ptr32 edx_42;
		fn00402191(eax, esi_30, ebx_34, ebx_34, esi_30, edi_36, out ecx_41, out edx_42);
		ecxOut = ecx_41;
		edxOut = edx_42;
		return <invalid>;
	}
	else
	{
		ptr32 ecx_47;
		ptr32 edx_48;
		fn004023C9(eax, (byte) esi_30, ebx_34, out ecx_47, out edx_48);
		ecxOut = ecx_47;
		edxOut = edx_48;
		return <invalid>;
	}
}

// 004023C9: FlagGroup byte fn004023C9(Register Eq_478 eax, Register byte cl, Register (ptr32 word32) edx, Register out Eq_1057 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn004023A7
//      fn004023CD
byte fn004023C9(Eq_478 eax, byte cl, word32 * edx, union Eq_1057 & ecxOut, ptr32 & edxOut)
{
	ptr32 fp;
	struct Eq_488 * ecx;
	struct Eq_23 * ebx;
	ui32 esi;
	ui32 edi;
	*eax.u0 |= cl;
	*edx += fp;
	ptr32 edx_18;
	word32 ecx_32;
	word32 ebx_33;
	word32 esi_34;
	word32 edi_35;
	fn004023CD(eax, ecx, edx, ebx, esi, edi, out ecx_32, out edx_18, out ebx_33, out esi_34, out edi_35);
	ecxOut.u1 = <invalid>;
	edxOut = edx_18;
	return <invalid>;
}

// 004023CD: FlagGroup byte fn004023CD(Register Eq_478 eax, Register (ptr32 Eq_488) ecx, Register (ptr32 word32) edx, Register (ptr32 Eq_23) ebx, Register ui32 esi, Register ui32 edi, Register out ptr32 ecxOut, Register out (ptr32 Eq_517) edxOut, Register out (ptr32 (arr Eq_537)) ebxOut, Register out Eq_519 esiOut, Register out (ptr32 Eq_520) ediOut)
// Called from:
//      Win32CrtStartup
//      fn004023C9
byte fn004023CD(Eq_478 eax, struct Eq_488 * ecx, word32 * edx, struct Eq_23 * ebx, ui32 esi, ui32 edi, ptr32 & ecxOut, struct Eq_517 & edxOut, Eq_537 (& ebxOut, union Eq_519 & esiOut, struct Eq_520 & ediOut)
{
	ui32 edi_8 = edi + esi;
	ui32 ebx_9 = (ebx | edi) + esi;
	ui32 edx_13 = edx - ecx | edi_8;
	Eq_537 ebx_19[] = ecx + ebx_9 / 2073990975;
	ui64 edi_ecx_66 = SEQ(edi_8 | edx_13, ecx) - &(&(ecx_20->*(ecx_20->*ebx_19).u0));
	struct Eq_520 * ecx_20 = (word32) edi_ecx_66;
	ui32 eax_16 = eax - ebx_9;
	byte cl_45 = (byte) ecx_20;
	ui32 esi_24 = esi & ebx_9 & ecx_20;
	struct Eq_520 * edi_27 = SLICE(edi_ecx_66, word32, 32) + edx_13;
	Eq_519 esi_33 = esi_24 - ebx_19 | ecx_20;
	struct Eq_2522 * eax_32 = eax_16 - edi_27 | ebx_19;
	word32 edx_36 = ebx_19 + esi_33 + edi_27;
	if (edi_27 != (struct Eq_520 *) 0x88DB8E0F)
	{
		struct Eq_517 * edx_40;
		ptr32 ecx_41;
		fn00402158(ecx_20, edx_36, edi_27, out ecx_41, out edx_40);
		ecxOut = ecx_41;
		edxOut = edx_40;
		ebxOut = ebx_19;
		esiOut = esi_33;
		ediOut = edi_27;
		return <invalid>;
	}
	else
	{
		eax_32->bFFFFFF80 |= cl_45;
		eax_32->b0000 &= cl_45;
		Eq_537 (* ebx_56)[];
		ptr32 ecx_57;
		struct Eq_520 * edi_58;
		Eq_519 esi_59;
		fn004026B9(edx_36, ebx_19, edi_27, out ecx_57, out ebx_56, out esi_59, out edi_58);
		ecxOut = ecx_57;
		edxOut = edx_36;
		ebxOut = ebx_56;
		esiOut = esi_59;
		ediOut = edi_58;
		return <invalid>;
	}
}

// 00402484: void fn00402484()
// Called from:
//      fn00401FEA
//      fn0040209D
void fn00402484()
{
}

// 00402498: FlagGroup byte fn00402498(Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out Eq_1057 edxOut)
// Called from:
//      fn00401FEA
byte fn00402498(ptr32 & eaxOut, ptr32 & ecxOut, union Eq_1057 & edxOut)
{
	ptr32 ecx_14;
	ptr32 eax_15;
	fn00402267(out eax_15, out ecx_14);
	eaxOut = eax_15;
	ecxOut = ecx_14;
	edxOut.u1 = <invalid>;
	return <invalid>;
}

// 004025E1: void fn004025E1()
// Called from:
//      fn004021F7
//      fn004023CD
void fn004025E1()
{
}

// 004025FF: FlagGroup byte fn004025FF(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi)
// Called from:
//      fn0040221E
//      fn0040221F
byte fn004025FF(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi)
{
	fn0040209D(eax, ecx, edx, ebx, esi, edi);
	return <invalid>;
}

// 004026B9: FlagGroup byte fn004026B9(Register (ptr32 Eq_517) edx, Register (arr Eq_537) ebx, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn0040209D
//      fn004023CD
byte fn004026B9(struct Eq_517 * edx, Eq_537 ebx[], struct Eq_520 * edi, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 ecx_36;
	ptr32 edi_37;
	ptr32 esi_38;
	fn00402386(edx, (char *) ebx + 1, edi, out ecx_36, out esi_38, out edi_37);
	ecxOut = ecx_36;
	ebxOut = (char *) ebx + 1;
	esiOut = esi_38;
	ediOut = edi_37;
	return <invalid>;
}

// 0040272F: FlagGroup byte fn0040272F(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register (ptr32 Eq_520) edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040205B
//      fn004029CE
byte fn0040272F(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], struct Eq_520 * edi, union Eq_1057 & dlOut)
{
	struct Eq_1030 * eax;
	ui32 eax_33 = edi & ebx;
	ui32 edx_21 = edx - ecx;
	byte al_43 = (byte) eax_33;
	word24 eax_24_8_44 = SLICE(eax_33, word24, 8);
	if (ebx != (Eq_537 (*)[]) 1280121415)
	{
		word32 edx_38;
		word32 ecx_73;
		fn00402017(eax, edx_21, ebx, edi, out ecx_73, out edx_38);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
	else
	{
		fn00402751(al_43, eax_24_8_44);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
}

// 00402751: FlagGroup byte fn00402751(Register byte al, Register word24 eax_24_8)
// Called from:
//      fn004022AB
//      fn0040272F
byte fn00402751(byte al, word24 eax_24_8)
{
	struct Eq_517 * edx;
	Eq_537 (* ebx)[];
	struct Eq_520 * edi;
	fn00402754(al, edx, ebx, edi);
	return <invalid>;
}

// 00402754: void fn00402754(Register byte al, Register (ptr32 Eq_517) edx, Register (arr Eq_537) ebx, Register (ptr32 Eq_520) edi)
// Called from:
//      fn0040209D
//      fn00402321
void fn00402754(byte al, struct Eq_517 * edx, Eq_537 ebx[], struct Eq_520 * edi)
{
	word32 eax;
	word24 edx_24_8_26 = SLICE(edx, word24, 8);
	Eq_537 al_22 = (byte) eax;
	ebx[0].u0 = (byte) al_22;
	struct Eq_517 * edx_46 = SEQ(edx_24_8_26, al_22);
	word32 ecx_60;
	word32 ebx_61;
	word32 esi_62;
	word32 edi_63;
	fn004026B9(edx_46, ebx, edi, out ecx_60, out ebx_61, out esi_62, out edi_63);
}

// 0040276F: FlagGroup byte fn0040276F(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register Eq_537 esi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040209D
//      fn0040210F
byte fn0040276F(Eq_537 eax, struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 esi, union Eq_1057 & dlOut)
{
	Eq_2644 fp;
	struct Eq_520 * dwLoc08;
	ui32 * dwLoc04;
	ui8 al;
	word24 eax_24_8;
	struct Eq_520 * edi;
	ui32 esi_11 = esi & ecx & ecx;
	word32 edx_19 = edx + ecx;
	ui32 edi_17 = (0x00 - ecx | esi_11) & eax;
	ui32 ebx_22 = ecx - eax - (word32) (edx_19 < null);
	ui32 edi_29 = edi_17 - esi_11 - edx_19 | esi_11;
	ui32 ebx_32 = ebx_22 + ((esi_11 | edi_29) - edi_29);
	ui32 edi_33 = edi_29 - eax;
	<anonymous> * eax_36 = *edx_19;
	ui32 eax_48;
	word32 edx_50;
	eax_36();
	ui32 ebx_41 = (char *) edx_19 + ebx_32 | edi_33;
	ui32 edi_42 = edi_33 - eax_36 | eax_36;
	ui32 edx_53 = edx_50 - (ebx_41 + edi_42 * 0x02);
	uint32 edi_56 = edi_42 + edx_53;
	struct Eq_2695 * eax_69 = eax_48 + ebx_41;
	ui32 edi_62 = edi_56 - ebx_41 - (word32) (edi_56 < 0x00) - eax_48;
	ui32 esi_72 = ebx_41 - edx_53 - (word32) (eax_69 < null);
	uint32 * edx_73 = dwLoc04 + edx_53;
	if (esi_72 != 1618963761)
	{
		*dwLoc04 <<= ~0x01;
		Eq_537 esi_80 = esi_72 - dwLoc04;
		ui64 eax_eax_172 = SEQ(eax_81, dwLoc04) - &(&(edx_73->*(edx_73->*esi_80.u1).b0000));
		struct Eq_2798 * eax_84 = SLICE(eax_eax_172, word32, 32);
		ui32 eax_81 = (word32) eax_eax_172;
		ui32 edi_87 = edi_62 - eax_84 - (word32) (eax_84 < null);
		if (dwLoc08 != (struct Eq_520 *) 1220488235)
		{
			word32 esi_94 = esi_80 + dwLoc04 | dwLoc04 - ~0x0A10;
			ui32 eax_95 = eax_84 & esi_94;
			ui32 edx_92 = edx_73 & edi_87;
			struct Eq_1152 * eax_98 = eax_95 & dwLoc04 - (ui32 *) ~0x0A10;
			ui32 esi_99 = esi_94 - eax_95 | edx_92;
			struct Eq_520 * ecx_100 = (dwLoc08 | eax_84) & eax_98;
			byte dl_219;
			fn0040203D(eax_98, ecx_100, edx_92, dwLoc04 - (ui32 *) ~0x0A10, esi_99, out dl_219);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
		else
		{
			eax_84->dwFFFFFFFF = dwLoc08 + eax_84->dwFFFFFFFF / 64;
			byte dl_220;
			fn004029AD(eax_84 - 0x01, dwLoc08, (char *) edx_73 + 2, dwLoc04, esi_80, edi, out dl_220);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
	}
	else
	{
		ui64 v18_v16_166 = SEQ(eax_69->dwFB8BFE02, *edx_73) + SEQ(eax_69 - (struct Eq_2722 *) 0x01, fp);
		*edx_73 = (word32) v18_v16_166;
		eax_69->dwFB8BFE02 = SLICE(v18_v16_166, word32, 32);
		uint32 esi_134 = edx_73 + ((esi_72 - edx_73) - (word32) (dwLoc08 + edi_62 / 64 < 0x00));
		up32 edi_142 = edx_73 + SLICE(SEQ(esi_134, (esi_134 - dwLoc08) - dwLoc04) - esi_134, word32, 32);
		if (edi_142 - dwLoc08 - (word32) (edi_142 < 0x00) != 3400468036)
		{
			word32 eax_217;
			word32 ecx_218;
			fn004027B3(eax, edx, ebx, out eax_217, out ecx_218);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
		else
		{
			eax_69->b8428403 &= (byte) edx_73 + 0x01;
			fn00402321(al, eax_24_8, edx, ebx, edi);
			dlOut.u1 = <invalid>;
			return <invalid>;
		}
	}
}

// 00402793: FlagGroup byte fn00402793(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register ui32 ebx, Register ui32 esi, Register ui32 edi, Register out ptr32 eaxOut, Register out ptr32 ecxOut)
// Called from:
//      fn00402267
//      fn00402269
byte fn00402793(struct Eq_520 * ecx, struct Eq_517 * edx, ui32 ebx, ui32 esi, ui32 edi, ptr32 & eaxOut, ptr32 & ecxOut)
{
	bool C;
	struct Eq_2849 * eax_16 = edi | ecx;
	Eq_537 (* ebx_11)[] = edx + (ebx & ecx) / 5;
	byte al_31 = (byte) eax_16;
	word24 eax_24_8_37 = SLICE(eax_16, word24, 8);
	struct Eq_520 * edi_17 = edi | ecx;
	ui32 esi_18 = esi - ebx - (word32) C | edx;
	if (ecx != (struct Eq_520 *) 584280663)
	{
		ptr32 ecx_23;
		eaxOut = fn0040223E(ecx, edx, ebx_11, esi_18, edi_17, out ecx_23);
		ecxOut = ecx_23;
		return <invalid>;
	}
	else
	{
		word32 eax_38 = SEQ(eax_24_8_37, al_31 & Mem0[(eax_16 + 0x8BF08B90) + ecx:byte]);
		ptr32 ecx_41;
		ptr32 eax_43;
		fn004027B3(eax_38, edx, ebx_11, out eax_43, out ecx_41);
		eaxOut = eax_43;
		ecxOut = ecx_41;
		return <invalid>;
	}
}

// 004027B3: FlagGroup byte fn004027B3(Register Eq_537 eax, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register out ptr32 eaxOut, Register out ptr32 ecxOut)
// Called from:
//      fn0040209D
//      fn00402793
byte fn004027B3(Eq_537 eax, struct Eq_517 * edx, Eq_537 (* ebx)[], ptr32 & eaxOut, ptr32 & ecxOut)
{
	struct Eq_520 * ecx;
	Eq_537 esi;
	word32 eax_23 = eax + edx;
	word32 edi_26 = ebx + edx;
	ptr32 ecx_30;
	eaxOut = fn0040221E((byte) eax_23, SLICE(eax_23, word24, 8), ecx, edx, ebx, esi, edi_26, out ecx_30);
	ecxOut = ecx_30;
	return <invalid>;
}

// 004027F8: FlagGroup byte fn004027F8(Register (ptr32 Eq_520) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out Eq_1934 ecxOut, Register out (ptr32 Eq_1935) edxOut)
// Called from:
//      fn0040209D
//      fn00402191
byte fn004027F8(struct Eq_520 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], Eq_537 esi, struct Eq_520 * edi, union Eq_1934 & ecxOut, struct Eq_1935 & edxOut)
{
	struct Eq_1935 * edx_37 = edx & ecx;
	byte al_51 = (byte) ebx;
	ui32 ecx_41 = ecx & esi.u1 + (edi - ecx) / 36 | edx_37;
	if (esi != 0x86531300)
	{
		Eq_1934 ecx_45;
		struct Eq_1935 * edx_47;
		fn004020BE(ecx_41, ebx, out ecx_45, out edx_47);
		ecxOut = ecx_45;
		edxOut = edx_47;
		return <invalid>;
	}
	else
	{
		edx_37->bFFFFFF90 &= al_51;
		ecxOut = ecx_41 | ebx;
		edxOut = edx_37;
		return <invalid>;
	}
}

// 0040288B: FlagGroup byte fn0040288B(Register ui8 al, Register ui24 eax_24_8, Register (ptr32 Eq_517) ecx, Register (ptr32 Eq_517) edx, Register (ptr32 (arr Eq_537)) ebx, Register (ptr32 Eq_517) esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out Eq_1366 edxOut)
// Called from:
//      fn0040205B
//      fn004028B0
byte fn0040288B(ui8 al, ui24 eax_24_8, struct Eq_517 * ecx, struct Eq_517 * edx, Eq_537 (* ebx)[], struct Eq_517 * esi, struct Eq_520 * edi, ptr32 & ecxOut, union Eq_1366 & edxOut)
{
	uint8 al_6 = __ror<byte,byte>(al, 0x10);
	ui32 eax_12 = SEQ(eax_24_8, al_6);
	uint32 ecx_16 = ecx - eax_12 & eax_12;
	ui64 edx_edx_47 = SEQ(edx_20, edx - esi | edi) - SEQ(ebx | edi, ecx_16);
	ui32 edx_20 = (word32) edx_edx_47;
	ui32 edx_23 = SLICE(edx_edx_47, word32, 32);
	ui32 edx_28 = edx_23 & eax_12;
	uint32 ecx_29 = ecx_16 & edx_28;
	Eq_1366 edx_39 = edx_28 + ecx_29;
	ptr32 ecx_43 = SLICE(SEQ(ecx_29, ecx_29 & edx_28) - SEQ(eax_24_8, __rol<byte,byte>(al_6, 0x0E), ecx_29), word32, 32);
	fn00402321(al, eax_24_8, edx, ebx, edi);
	ecxOut = ecx_43;
	edxOut = edx_39;
	return <invalid>;
}

// 004028B0: FlagGroup byte fn004028B0(Register (ptr32 Eq_1981) eax, Register (ptr32 byte) edx, Register (arr Eq_537) ebx, Register ui32 esi, Register (ptr32 Eq_520) edi, Register out ptr32 ecxOut, Register out (ptr32 Eq_517) edxOut)
// Called from:
//      fn004021F7
//      fn004021F8
byte fn004028B0(struct Eq_1981 * eax, byte * edx, Eq_537 ebx[], ui32 esi, struct Eq_520 * edi, ptr32 & ecxOut, struct Eq_517 & edxOut)
{
	byte al_16 = (byte) eax;
	ui24 eax_24_8_21 = SLICE(eax, word24, 8);
	uint32 edx_14 = edx & esi - ebx & edi;
	ui32 eax_22 = SEQ(eax_24_8_21, al_16 - 0x56);
	uint32 esi_25 = (eax & edx_14) - eax_22;
	uint32 ecx_26 = edi & eax_22 | edx_14;
	ui64 edx_edx_90 = SEQ(edx_31, edx_14 - edi - esi_25) - ecx_26;
	ui32 edx_31 = (word32) edx_edx_90;
	ui32 ecx_36 = ecx_26 + SLICE(edx_edx_90, word32, 32) | esi_25 & ecx_26;
	byte al_41 = 0x56 - al_16 - 1;
	uint32 edx_50 = ebx | edi;
	ui32 ecx_51 = (ecx_36 | edi) & edi;
	ui64 ecx_edx_93 = SEQ(ecx_51, edx_50) - &(&(ebx->*(ebx->*ebx).u0));
	struct Eq_517 * edx_60 = (word32) ecx_edx_93;
	word32 ecx_68 = SLICE(ecx_edx_93, word32, 32) + edx_60 + edi;
	struct Eq_517 * eax_69 = SEQ(eax_24_8_21, al_41 ^ 110);
	byte ch_83 = SLICE(ecx_68, byte, 8);
	word16 ecx_16_16_99 = SLICE(ecx_68, word16, 16);
	byte cl_100 = (byte) ecx_68;
	if (ebx != (Eq_537 (*)[]) 3937605745)
	{
		ptr32 ecx_74;
		struct Eq_517 * edx_75;
		fn0040288B(al_41 ^ 110, eax_24_8_21, ecx_68, edx_60, ebx, eax_69, edi, out ecx_74, out edx_75);
		ecxOut = ecx_74;
		edxOut = edx_75;
		return <invalid>;
	}
	else
	{
		ptr32 ecx_101 = SEQ(ecx_16_16_99, ch_83 & (ebx)[0].u0, cl_100);
		fn004025E1();
		ecxOut = ecx_101;
		edxOut = edx_60;
		return <invalid>;
	}
}

// 004028F1: FlagGroup byte fn004028F1(Register ui32 edx, Register ui32 ebx, Register ui32 esi, Register ui32 edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040205B
//      fn004022AB
byte fn004028F1(ui32 edx, ui32 ebx, ui32 esi, ui32 edi, union Eq_1057 & dlOut)
{
	ui32 eax;
	ui32 esi_25 = esi & ebx;
	ui32 ecx_20 = ebx - (edx - ebx | ebx);
	ui32 edx_27 = esi + (edi ^ 2984901101) - esi_25;
	fn004029CE(eax, ecx_20, edx_27, esi_25);
	dlOut.u1 = <invalid>;
	return <invalid>;
}

// 004029AD: FlagGroup byte fn004029AD(Register Eq_537 eax, Register (ptr32 Eq_520) ecx, Register Eq_1203 edx, Register (ptr32 ui32) ebx, Register Eq_537 esi, Register (ptr32 Eq_520) edi, Register out Eq_1057 dlOut)
// Called from:
//      fn0040203D
//      fn0040276F
byte fn004029AD(Eq_537 eax, struct Eq_520 * ecx, Eq_1203 edx, ui32 * ebx, Eq_537 esi, struct Eq_520 * edi, union Eq_1057 & dlOut)
{
	bool C;
	up32 esi_22 = esi - ebx - (word32) C;
	word32 eax_31 = eax.u1 + esi_22 / 36;
	up32 edi_29 = edi + (ecx | edx) / 64;
	ui32 edx_30 = eax.u1 + (edx | eax) / 36;
	byte al_41 = (byte) eax_31;
	word24 eax_24_8_42 = SLICE(eax_31, word24, 8);
	if (ebx != (ui32 *) 232422080)
	{
		byte dl_71;
		fn004022AB(edx_30, esi_22, edi_29, out dl_71);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
	else
	{
		fn004029C7(al_41, eax_24_8_42);
		dlOut.u1 = <invalid>;
		return <invalid>;
	}
}

// 004029C7: FlagGroup byte fn004029C7(Register byte al, Register word24 eax_24_8)
// Called from:
//      fn0040276F
//      fn004029AD
byte fn004029C7(byte al, word24 eax_24_8)
{
	struct Eq_3097 * fp;
	ui32 edx;
	up32 esi;
	up32 edi;
	int32 eax_7 = SEQ(eax_24_8, al + 0x01);
	fp->a8BF72311[eax_7] += ~0x29;
	byte dl_19;
	fn004022AB(edx, esi, edi, out dl_19);
	return <invalid>;
}

// 004029CE: Register byte fn004029CE(Register ui32 eax, Register ui32 ecx, Register ui32 edx, Register ui32 esi)
// Called from:
//      fn004022AB
//      fn004028F1
byte fn004029CE(ui32 eax, ui32 ecx, ui32 edx, ui32 esi)
{
	bool C;
	Eq_537 (* ebx)[];
	struct Eq_520 * edi;
	ui32 edx_7 = edx - ecx - (word32) C;
	ui32 eax_11 = eax | edx_7;
	struct Eq_517 * edx_12 = edx_7 & eax_11;
	struct Eq_520 * ecx_14 = ecx | (esi + ecx | eax_11);
	byte dl_34;
	fn0040272F(ecx_14, edx_12, ebx, edi, out dl_34);
	struct Eq_520 * edx_22 = (struct Eq_520 *) <invalid>;
	return (byte) edx_22;
}

