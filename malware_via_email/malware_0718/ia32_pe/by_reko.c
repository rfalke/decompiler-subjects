// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401030: void fn00401030(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack Eq_2 dwArg0C)
void fn00401030(HMODULE dwArg04, Eq_3 dwArg08, HMODULE dwArg0C)
{
	globals->t40633C = null;
	while (globals->t40633C < dwArg0C)
	{
		Mem25[dwArg04 + Mem6[0x0040633C:word32]:byte] = Mem6[dwArg08 + Mem6[0x0040633C:word32]:byte];
		globals->t40633C = (Eq_2) ((char *) &globals->t40633C->unused + 0x01);
	}
}

// 004010D0: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	do
		globals->dw406354 = 39821115;
	while (false);
	int32 dwLoc18_22 = 0x00;
	while (dwLoc18_22 < 0x01)
	{
		globals->dw406354 = 0x3799;
		dwLoc18_22 = dwLoc18_22 + 0x01;
	}
	int32 dwLoc1C_33 = 0x00;
	while (dwLoc1C_33 < 0x01)
	{
		globals->dw406354 = 0x22E3;
		dwLoc1C_33 = dwLoc1C_33 + 0x01;
	}
	Eq_2 eax_46 = GetModuleHandleA(0x00);
	if (RegOpenKeyA((struct HKEY__ *) 0x80000000, 0x00406280, fp - 0x0C) != 0x00)
		null = (byte *) 0x00;
	struct Eq_67 * edx_63 = globals->ptr402001;
	Eq_70 ecx_66 = globals->t402005;
	struct Eq_67 * dwLoc08_111 = null;
	while (dwLoc08_111 < edx_63)
	{
		do
			globals->dw406354 = 0x8E831298;
		while (false);
		do
			globals->dw406354 = 3552175835;
		while (false);
		int32 dwLoc28_90 = 0x00;
		while (dwLoc28_90 < 0x01)
		{
			globals->dw406354 = 336278;
			dwLoc28_90 = dwLoc28_90 + 0x01;
		}
		dwLoc08_111->dw402009 = dwLoc08_111->dw402009 ^ 0x3ADE68B1;
		dwLoc08_111 = dwLoc08_111 + 0x01;
	}
	globals->ptr40634C = fn00401630(ecx_66);
	fn004017F0(globals->a402009, globals->ptr40634C, edx_63);
	globals->dw406340 = edi;
	globals->dw406338 = esi;
	globals->dw406348 = ebx;
	globals->ptr406350 = fs->ptr0018;
	globals->ptr406344 = fp - 0x04;
	word32 ebp_149 = fn00401660(fp - 0x04, 4198995 - eax_46, eax_46);
	Eq_829 (* ecx_152)[] = globals->ptr40634C;
	*(fp - 0x48) = (Eq_829 (**)[]) ecx_152;
	word32 eax_156 = fn004012B0(ebp_149, dwArg00);
	word32 esp_163;
	word32 ebp_164;
	byte SCZO_165;
	word32 ebx_166;
	word32 esi_167;
	word32 edi_168;
	Eq_25 eax_169;
	byte SZO_170;
	byte C_171;
	byte Z_172;
	byte SO_173;
	word32 ecx_174;
	word32 edx_175;
	struct Eq_150 * fs_176;
	globals->ptr406358();
	return eax_169;
}

// 00401290: Register Eq_180 fn00401290(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08)
FARPROC fn00401290(HMODULE dwArg04, Eq_3 dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 004012B0: Register word32 fn004012B0(Register word32 ebp, Stack Eq_3 dwArg04)
word32 fn004012B0(word32 ebp, Eq_3 dwArg04)
{
	Eq_2 eax_9 = GetModuleHandleA(0x00406288);
	Eq_180 eax_16 = GetProcAddress(eax_9, 4219544);
	GetProcAddress(eax_9, 0x004062A8);
	Eq_180 eax_30 = GetProcAddress(eax_9, 0x004062B8);
	Eq_180 eax_37 = GetProcAddress(eax_9, 0x004062CC);
	Eq_180 eax_44 = GetProcAddress(eax_9, 4219612);
	GetProcAddress(eax_9, 0x004062EC);
	word32 edx_59 = dwArg04 + Mem0[dwArg04 + 0x3C:word32];
	struct Eq_220 * dwLoc30_111 = &edx_59->w0014 + 0x02 + (word32) edx_59->w0014 / 22;
	struct Eq_228 * eax_80 = eax_37();
	fn00401030(dwArg00, dwArg04, dwArg08);
	uint32 dwLoc10_106 = 0x00;
	while (dwLoc10_106 < (word32) edx_59->w0006)
	{
		if (dwLoc30_111->dw0014 != 0x00 && dwLoc30_111->dw0010 != 0x00)
			fn00401030(dwArg00, dwArg04, dwArg08);
		dwLoc30_111 = dwLoc30_111 + 0x01;
		dwLoc10_106 = dwLoc10_106 + 0x01;
	}
	struct Eq_242 * ecx_169 = eax_80 + eax_80->dw003C / 0x0040;
	Eq_247 eax_189 = eax_30();
	ptr32 * esp_186 = fp - 0xB8;
	struct Eq_253 * dwLoc5C_200 = eax_80 + ecx_169->dw0080 / 0x0040;
	while (dwLoc5C_200->dw0010 != 0x00)
	{
		word32 * dwLoc3C_240;
		ui32 * dwLoc2C_239;
		ptr32 * esp_224 = esp_186 - 0x04;
		*esp_224 = eax_80 + dwLoc5C_200->dw000C / 0x0040;
		int32 eax_229 = eax_44();
		if (dwLoc5C_200->dw0000 != 0x00)
		{
			dwLoc2C_239 = (ui32 *) (eax_80 + dwLoc5C_200->dw0000 / 0x0040);
			dwLoc3C_240 = (word32 *) (eax_80 + dwLoc5C_200->dw0010 / 0x0040);
		}
		else
		{
			dwLoc2C_239 = (ui32 *) (eax_80 + dwLoc5C_200->dw0010 / 0x0040);
			dwLoc3C_240 = (word32 *) (eax_80 + dwLoc5C_200->dw0000 / 0x0040);
		}
		word32 dwLoc1C_243 = 0x00;
		if (dwLoc5C_200->dw0010 != 0x00 && dwLoc5C_200->dw0000 != 0x00)
			dwLoc1C_243 = 0x01;
		while (true)
		{
			esp_186 = esp_224;
			if (*dwLoc2C_239 == 0x00)
				break;
			if ((*dwLoc2C_239 & 0x80000000) != 0x00)
			{
				*(esp_224 - 0x04) = *dwLoc2C_239 & 0x7FFFFFFF;
				*(esp_224 - 0x08) = eax_229;
				*dwLoc2C_239 = fn00401290(dwArg00, dwArg04);
			}
			else
			{
				*(esp_224 - 0x04) = eax_80 + (*dwLoc2C_239 + 0x02) / 0x0040;
				*(esp_224 - 0x08) = eax_229;
				*dwLoc2C_239 = fn00401290(dwArg00, dwArg04);
			}
			if (dwLoc1C_243 != 0x00)
				*dwLoc3C_240 = *dwLoc2C_239;
			dwLoc2C_239 = dwLoc2C_239 + 0x01;
			dwLoc3C_240 = dwLoc3C_240 + 0x01;
		}
		dwLoc5C_200 = dwLoc5C_200 + 0x01;
	}
	word32 eax_371;
	union Eq_278 * esp_341 = esp_186 - 0x04;
	*esp_341 = (union Eq_278 *) ecx_169->t0034;
	*(esp_341 - 0x04) = 0x00;
	*(esp_341 - 0x08) = 0x00;
	*(esp_341 - 0x0C) = 0x00;
	*(esp_341 - 0x10) = 0x22;
	*(esp_341 - 0x14) = (HANDLE *) eax_189;
	globals->t406334 = eax_16();
	ptr32 esp_354 = esp_341 - 0x14;
	if (globals->t406334 == 0x00)
	{
		*(esp_341 - 0x18) = (union Eq_278 *) ecx_169->t0034;
		ptr32 esp_413 = esp_341 - 0x18;
		if (UnmapViewOfFile(*(esp_341 - 0x18)) == 0x00)
		{
			*(esp_341 - 0x1C) = 0x8000;
			*(esp_341 - 0x20) = 0x00;
			*(esp_341 - 0x24) = (union Eq_278 *) ecx_169->t0034;
			esp_413 = esp_341 - 0x24;
			if (VirtualFree(*(esp_341 - 0x24), *(esp_341 - 0x20), *(esp_341 - 0x1C)) == 0x00)
			{
				eax_371 = 0x00;
				return eax_371;
			}
		}
		union Eq_278 * esp_424 = esp_413 - 0x04;
		*esp_424 = (union Eq_278 *) ecx_169->t0034;
		*(esp_424 - 0x04) = 0x00;
		*(esp_424 - 0x08) = 0x00;
		*(esp_424 - 0x0C) = 0x00;
		*(esp_424 - 0x10) = 0x22;
		*(esp_424 - 0x14) = (HANDLE *) eax_189;
		globals->t406334 = MapViewOfFileEx(*(esp_424 - 0x14), *(esp_424 - 0x10), *(esp_424 - 0x0C), *(esp_424 - 0x08), *(esp_424 - 0x04), *esp_424);
		esp_354 = esp_424 - 0x14;
		if (globals->t406334 == 0x00)
		{
			*(esp_424 - 0x18) = 0x40;
			*(esp_424 - 0x1C) = 0x3000;
			*(esp_424 - 0x20) = ecx_169->dw0050;
			*(esp_424 - 0x24) = (union Eq_278 *) ecx_169->t0034;
			globals->t406334 = VirtualAlloc(*(esp_424 - 0x24), *(esp_424 - 0x20), *(esp_424 - 0x1C), *(esp_424 - 0x18));
			esp_354 = esp_424 - 0x24;
		}
	}
	HANDLE * esp_382 = esp_354 - 0x04;
	*esp_382 = (HANDLE *) eax_189;
	CloseHandle(*esp_382);
	*(esp_382 - 0x04) = ecx_169->dw0050;
	*(esp_382 - 0x08) = (struct Eq_228 **) eax_80;
	*(esp_382 - 0x0C) = (union Eq_278 *) globals->t406334;
	fn00401030(dwArg00, dwArg04, dwArg08);
	*(esp_382 - 0x04) = (union Eq_278 *) globals->t406334;
	fn004017C0(dwArg00);
	Mem405[0x00406358:word32] = Mem399[0x00406334:word32] + Mem399[ecx_169 + 0x28:word32];
	ecx_169->ptr0028 = globals->ptr406358;
	eax_371 = 0x01;
	return eax_371;
}

// 00401630: Register Eq_278 fn00401630(Stack Eq_70 dwArg04)
Eq_278 fn00401630(SIZE_T dwArg04)
{
	return VirtualAlloc(0x00, dwArg04, 0x3000, 0x04);
}

// 00401660: Register ptr32 fn00401660(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack Eq_2 dwArg08)
ptr32 fn00401660(ptr32 ebp, Eq_3 dwArg04, HMODULE dwArg08)
{
	struct Eq_711 * edx_16 = dwArg08 + (&dwArg08->unused)[0x0F] / 0x04;
	globals->t406334 = GetProcAddress(GetModuleHandleA(0x00406308), &globals->t406308)();
	if (globals->t406334 != 0x00)
	{
		fn00401030(dwArg00, dwArg04, dwArg08);
		ui32 eax_90 = globals->t406334 - dwArg08;
		if (edx_16->dw00A4 != 0x00)
		{
			struct Eq_754 * dwLoc0C_116 = dwArg08 + edx_16->dw00A0 / 0x04;
			while (dwLoc0C_116->t0004 != 0x00)
			{
				uint32 eax_131 = dwLoc0C_116->t0004 - 0x08 >> 0x01;
				word16 ecx_134[] = (char *) &dwLoc0C_116->t0004 + 0x04;
				uint32 dwLoc08_137 = 0x00;
				while (dwLoc08_137 < eax_131)
				{
					if ((word32) ecx_134[dwLoc08_137] >> 0x0C == 0x03)
						(word32) globals->t406334 + dwLoc0C_116->dw0000 + ((word32) ecx_134[dwLoc08_137] & 0x0FFF) = (struct Eq_799 *) ((word32) globals->t406334 + dwLoc0C_116->dw0000 + ((word32) ecx_134[dwLoc08_137] & 0x0FFF) + eax_90);
					dwLoc08_137 = dwLoc08_137 + 0x01;
				}
				dwLoc0C_116 = dwLoc0C_116 + Mem85[dwLoc0C_116 + 0x04:word32];
			}
		}
		word32 edx_100 = dwArg04 + Mem85[0x00406334:word32];
		word32 esp_102;
		ptr32 ebp_103;
		byte SCZO_104;
		word32 esi_105;
		word32 eax_106;
		word32 ecx_107;
		word32 edx_108;
		byte Z_109;
		byte C_110;
		byte SZO_111;
		edx_100();
		return ebp_103;
	}
	else
		return ebp;
}

// 004017C0: void fn004017C0(Stack Eq_2 dwArg04)
void fn004017C0(HMODULE dwArg04)
{
	globals->ptr406350->ptr0030->t0008 = dwArg04;
}

// 004017F0: void fn004017F0(Stack (ptr Eq_829) dwArg04, Stack (arr Eq_829) dwArg08, Stack (ptr Eq_67) dwArg0C)
void fn004017F0(Eq_829 * dwArg04, Eq_829 dwArg08[], Eq_67 * dwArg0C)
{
	Eq_829 cl_12 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04->a0000[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
	lstrcpyA(fp - 0x94, 0x00406328);
	struct Eq_67 * dwLoc0C_119 = (struct Eq_67 *) 0x01;
	int32 dwLoc18_125 = 0x00;
	do
	{
		struct Eq_67 * edx_41 = (char *) dwLoc0C_119 + 0x01;
		byte cl_38 = Mem0[dwArg04 + dwLoc0C_119:byte];
		dwLoc0C_119 = edx_41;
		if ((word32) cl_38 == (word32) cl_12)
		{
			if ((word32) Mem0[dwArg04 + edx_41:byte] == 0x00)
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg08[dwLoc18_125].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = cl_12;
				dwLoc18_125 = dwLoc18_125 + 0x01;
				dwLoc0C_119 = (struct Eq_67 *) ((char *) edx_41 + 0x01);
			}
			else
			{
				word32 eax_105 = fn00401910(fp - 0x10, dwArg04 + edx_41) + edx_41;
				dwLoc0C_119 = fn00401910(fp - 0x20, dwArg04 + eax_105) + eax_105;
				uint32 dwLoc1C_120 = 0x00;
				while (dwLoc1C_120 < dwLoc10)
				{
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg08[dwLoc18_125].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg08[dwLoc18_125 - dwLoc20].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
					dwLoc18_125 = dwLoc18_125 + 0x01;
					dwLoc1C_120 = dwLoc1C_120 + 0x01;
				}
			}
		}
		else
		{
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg08[dwLoc18_125].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (Eq_829) cl_38;
			dwLoc18_125 = dwLoc18_125 + 0x01;
		}
	} while (dwLoc0C_119 < dwArg0C);
}

// 00401910: Register word32 fn00401910(Stack (ptr ui32) dwArg04, Stack (ptr byte) dwArg08)
word32 fn00401910(ui32 * dwArg04, byte * dwArg08)
{
	lstrcpyA(fp - 0x84, 0x00406318);
	ui32 dwLoc08_18 = 0x00;
	word32 dwLoc10_19 = 0x00;
	do
	{
		ui32 edx_22 = (word32) *dwArg08;
		ui32 edx_32 = edx_22 & 0x7F | dwLoc08_18 << 0x07;
		word32 eax_35 = dwLoc10_19 + 0x01;
		dwArg08 = dwArg08 + 0x01;
		dwLoc08_18 = edx_32;
		dwLoc10_19 = eax_35;
	} while ((edx_22 & 0x80) != 0x00);
	*dwArg04 = edx_32;
	return eax_35;
}

